:: The Ordinal Numbers. Transfinite Induction and Defining by
:: Transfinite Induction
::  by Grzegorz Bancerek
::
:: Received March 20, 1989
:: Copyright (c) 1990 Association of Mizar Users

environ

 vocabularies BOOLE, ZFMISC_1, TARSKI, FUNCT_1, RELAT_1, ORDINAL1, HAHNBAN,
      ARYTM, ORDINAL2;
 notations TARSKI, XBOOLE_0, ZFMISC_1, ENUMSET1, SUBSET_1, RELAT_1, FUNCT_1;
 constructors TARSKI, ENUMSET1, SUBSET_1, FUNCT_1;
 registrations XBOOLE_0, SUBSET_1, RELAT_1, FUNCT_1;
 requirements SUBSET, BOOLE;


begin

::
:: 1. Some consequences of regularity axiom (TARSKI:7)
::

 reserve X,Y,Z,X1,X2,X3,X4,X5,X6,x,y for set;

canceled 2;

theorem :: ORDINAL1:3
   not ( X in Y & Y in Z & Z in X);

theorem :: ORDINAL1:4
        not ( X1 in X2 & X2 in X3 & X3 in X4 & X4 in X1);

theorem :: ORDINAL1:5
       not ( X1 in X2 & X2 in X3 & X3 in X4 & X4 in X5 & X5 in X1);

theorem :: ORDINAL1:6
       not ( X1 in X2 & X2 in X3 & X3 in X4 & X4 in X5 & X5 in X6 & X6 in X1);

theorem :: ORDINAL1:7
  Y in X implies not X c= Y;

 definition let X;
  func succ X -> set equals
:: ORDINAL1:def 1
    X \/ { X };
 end;

 registration let X;
  cluster succ X -> non empty;
 end;

canceled 2;

theorem :: ORDINAL1:10
  X in succ X;

canceled;

theorem :: ORDINAL1:12
       succ X = succ Y implies X = Y;

theorem :: ORDINAL1:13
      x in succ X iff x in X or x = X;

theorem :: ORDINAL1:14
  X <> succ X;

::
:: 3. epsilon-transitivity & epsilon-connectedness
::

 reserve a,b,c,X,Y,Z,x,y,z for set;

 definition let X;
  attr X is epsilon-transitive means
:: ORDINAL1:def 2
 for x st x in X holds x c= X;
  attr X is epsilon-connected means
:: ORDINAL1:def 3
 for x,y st x in X & y in X holds x in y or x = y or y in x;
 end;

::
:: 4. Definition of ordinal numbers - Ordinal
::

 definition let IT be set;
  attr IT is ordinal means
:: ORDINAL1:def 4
  IT is epsilon-transitive epsilon-connected;
 end;

registration
  cluster ordinal -> epsilon-transitive epsilon-connected set;
  cluster epsilon-transitive epsilon-connected -> ordinal set;
end;

notation
  synonym number for set;
  end;

 registration
  cluster ordinal number;
 end;

definition
  mode Ordinal is ordinal number;
end;

 reserve A,B,C,D for Ordinal;

canceled 4;

theorem :: ORDINAL1:19
 for A being epsilon-transitive set st
  A in B & B in C holds A in C;

canceled;

theorem :: ORDINAL1:21
 for x being epsilon-transitive set, A being Ordinal
     st x c< A holds x in A;

theorem :: ORDINAL1:22
      for A being epsilon-transitive set,
     B, C being Ordinal st
  A c= B & B in C holds A in C;

theorem :: ORDINAL1:23
  a in A implies a is Ordinal;

theorem :: ORDINAL1:24
  A in B or A = B or B in A;

definition let A,B;
 redefine pred A c= B means
:: ORDINAL1:def 5
   for C st C in A holds C in B;
  connectedness;
end;

theorem :: ORDINAL1:25
       A,B are_c=-comparable;

theorem :: ORDINAL1:26
  A c= B or B in A;

theorem :: ORDINAL1:27
  {} is Ordinal;

 registration
  cluster empty Ordinal;
 end;

 registration
  cluster empty -> ordinal number;
 end;

registration
  cluster {} -> ordinal;
end;

canceled;

theorem :: ORDINAL1:29
  x is Ordinal implies succ x is Ordinal;

theorem :: ORDINAL1:30
  x is ordinal implies union x is ordinal;

registration
 cluster non empty Ordinal;
end;

 registration let A;
  cluster succ A -> non empty ordinal;
  cluster union A -> ordinal;
 end;

theorem :: ORDINAL1:31
      (for x st x in X holds x is Ordinal & x c= X) implies X is ordinal;

theorem :: ORDINAL1:32
  X c= A & X <> {} implies ex C st C in X & for B st B in X holds C c= B;

theorem :: ORDINAL1:33
  A in B iff succ A c= B;

theorem :: ORDINAL1:34
  A in succ C iff A c= C;

::
:: 6. Transfinite induction and principle of minimum of ordinals
::

scheme :: ORDINAL1:sch 1
 OrdinalMin { P[Ordinal] } :
  ex A st P[A] & for B st P[B] holds A c= B provided
 ex A st P[A];

scheme :: ORDINAL1:sch 2
 TransfiniteInd { P[Ordinal] } :
  for A holds P[A] provided
 for A st for C st C in A holds P[C] holds P[A];

::
:: 7. Properties of sets of ordinals
::

theorem :: ORDINAL1:35
 for X st for a st a in X holds a is Ordinal holds union X is ordinal;

theorem :: ORDINAL1:36
  for X st for a st a in X holds a is Ordinal ex A st X c= A;

theorem :: ORDINAL1:37
  not ex X st for x holds x in X iff x is Ordinal;

theorem :: ORDINAL1:38
  not ex X st for A holds A in X;

theorem :: ORDINAL1:39
       for X ex A st not A in X & for B st not B in X holds A c= B;

::
::  8. Limit ordinals
::

 definition let A be set;
  attr A is being_limit_ordinal means
:: ORDINAL1:def 6
  A = union A;
  end;

notation let A be set;
 synonym A is_limit_ordinal for A is being_limit_ordinal;
end;

canceled;

theorem :: ORDINAL1:41
  for A holds A is_limit_ordinal iff for C st C in A holds succ C in A;

theorem :: ORDINAL1:42
       not A is_limit_ordinal iff ex B st A = succ B;

 reserve F,G for Function;

::
::  9. Transfinite sequences
::

 definition let IT be Function;
  attr IT is T-Sequence-like means
:: ORDINAL1:def 7
 dom IT is ordinal;
 end;

 registration
  cluster T-Sequence-like Function;
 end;

definition
  mode T-Sequence is T-Sequence-like Function;
end;

 definition let Z;
  mode T-Sequence of Z -> T-Sequence means
:: ORDINAL1:def 8
 rng it c= Z;
 end;

canceled 2;

theorem :: ORDINAL1:45
       {} is T-Sequence of Z;

 reserve L,L1 for T-Sequence;

theorem :: ORDINAL1:46
       dom F is Ordinal implies F is T-Sequence of rng F;

 registration let L;
  cluster dom L -> ordinal;
 end;

theorem :: ORDINAL1:47
  X c= Y implies for L being T-Sequence of X holds L is T-Sequence of Y;

 definition let L,A;
 redefine func L|A -> T-Sequence of rng L;
 end;

theorem :: ORDINAL1:48
       for L being T-Sequence of X for A holds L|A is T-Sequence of X;

definition let IT be set;
 attr IT is c=-linear means
:: ORDINAL1:def 9
 for x,y being set st x in IT & y in IT holds x,y are_c=-comparable;
end;

theorem :: ORDINAL1:49
       (for a st a in X holds a is T-Sequence) & X is c=-linear
   implies union X is T-Sequence;

::
:: 10. Schemes of definability by transfinite induction
::

 scheme :: ORDINAL1:sch 3
 TSUniq { A()->Ordinal, H(T-Sequence)->set,
                    L1, L2() -> T-Sequence } :
  L1() = L2() provided
 dom L1() = A() & for B,L st B in A() & L = L1()|B holds L1().B = H(L) and
 dom L2() = A() & for B,L st B in A() & L = L2()|B holds L2().B = H(L);

 scheme :: ORDINAL1:sch 4
 TSExist { A()->Ordinal,H(T-Sequence)->set } :
   ex L st dom L = A() & for B,L1 st B in A() & L1 = L|B holds L.B = H(L1);

 scheme :: ORDINAL1:sch 5
 FuncTS { L() -> T-Sequence, F(Ordinal)->set, H(T-Sequence)->set } :
   for B st B in dom L() holds L().B = H(L()|B)
     provided
  for A,a holds a = F(A) iff
     ex L st a = H(L) & dom L = A & for B st B in A holds L.B = H(L|B) and
  for A st A in dom L() holds L().A = F(A);

theorem :: ORDINAL1:50
      A c< B or A = B or B c< A;

:: 2005.05.04, A.T.

::registration let O be Ordinal, x be set;
:: cluster O --> x -> T-Sequence-like;
:: coherence
::  proof dom(O --> x) = O by FUNCOP_1:19;
::   hence thesis by Def7;
::  end;
::end;

begin :: Addenda

:: moved from ORDINAL2, 2006.06.22, A.T.

definition let X;
 func On X -> set means
:: ORDINAL1:def 10
  x in it iff x in X & x is Ordinal;

 func Lim X -> set means
:: ORDINAL1:def 11
   x in it iff x in X & ex A st x = A & A is_limit_ordinal;
end;

theorem :: ORDINAL1:51
  for D ex A st D in A & A is_limit_ordinal;

definition
 func omega -> set means
:: ORDINAL1:def 12
 {} in it & it is_limit_ordinal & it is ordinal &
      for A st {} in A & A is_limit_ordinal holds it c= A;
end;

registration
 cluster omega -> non empty ordinal;
end;

definition let A be set;
 attr A is natural means
:: ORDINAL1:def 13
 A in omega;
end;

registration
 cluster natural number;
end;

:: from ARYTM_3, 2006.05.26

registration
 let A be Ordinal;
 cluster -> ordinal Element of A;
end;

:: missing, 2006.06.25, A.T.

registration
 cluster natural -> ordinal number;
end;

:: from ZF_REFLE, 2007,03.13, A.T.

scheme :: ORDINAL1:sch 6
 ALFA { D() -> non empty set, P[set,set] }:
 ex F st dom F = D() &
  for d being Element of D() ex A st A = F.d & P[d,A] &
   for B st P[d,B] holds A c= B
  provided
 for d being Element of D() ex A st P[d,A];

:: from CARD_4, 2007.08.06, A.T.

theorem :: ORDINAL1:52
 succ A \ {A} = A;

:: from ARYTM_3, 2007.09.16, A.T.

registration
 cluster empty -> natural number;
 cluster -> natural Element of omega;
end;

registration
 cluster non empty natural number;
end;

:: from ARYTM_3, 2007.10.23, A.T.

registration let a be natural Ordinal;
 cluster succ a -> natural;
end;

