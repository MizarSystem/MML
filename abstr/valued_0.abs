:: Number-Valued Functions
::  by Library Committee
::
:: Received November 22, 2007
:: Copyright (c) 2007 Association of Mizar Users

environ

 vocabularies VALUED_0, RELAT_1, COMPLEX1, RAT_1, INT_1, FUNCT_1, ORDINAL2,
      XCMPLX_0, XREAL_0, ARYTM, MEMBERED, BOOLE, FUNCOP_1, FUNCT_4, CAT_1,
      SUPINF_1;
 notations TARSKI, XBOOLE_0, ZFMISC_1, SUBSET_1, RELAT_1, FUNCT_1, ORDINAL1,
      RELSET_1, FUNCT_2, FUNCOP_1, FUNCT_4, NUMBERS, MEMBERED, XCMPLX_0,
      XREAL_0, XXREAL_0, RAT_1, INT_1;
 constructors RELAT_1, NUMBERS, XCMPLX_0, XREAL_0, RAT_1, INT_1, MEMBERED,
      FUNCT_2, FUNCOP_1, FUNCT_4, XXREAL_0;
 registrations MEMBERED, RELSET_1, RELAT_1, XCMPLX_0, FUNCOP_1, XREAL_0, RAT_1,
      ORDINAL1, INT_1, FUNCT_4, FUNCT_1, XBOOLE_0;
 requirements BOOLE, SUBSET;


begin

definition let f be Relation;
 attr f is complex-valued means
:: VALUED_0:def 1
 rng f c= COMPLEX;
 attr f is ext-real-valued means
:: VALUED_0:def 2
 rng f c= ExtREAL;
 attr f is real-valued means
:: VALUED_0:def 3
 rng f c= REAL;
 attr f is rational-valued means
:: VALUED_0:def 4
 rng f c= RAT;
 attr f is integer-valued means
:: VALUED_0:def 5
 rng f c= INT;
 attr f is natural-valued means
:: VALUED_0:def 6
 rng f c= NAT;
end;

registration
 cluster natural-valued -> integer-valued Relation;
 cluster integer-valued -> rational-valued Relation;
 cluster rational-valued -> real-valued Relation;
 cluster real-valued -> ext-real-valued Relation;
 cluster real-valued -> complex-valued Relation;
end;

registration
 cluster empty -> natural-valued Relation;
end;

registration
 cluster {} -> natural-valued;
end;

registration
 cluster natural-valued Function;
end;

registration let R be complex-valued Relation;
 cluster rng R -> complex-membered;
end;

registration let R be ext-real-valued Relation;
 cluster rng R -> ext-real-membered;
end;

registration let R be real-valued Relation;
 cluster rng R -> real-membered;
end;

registration let R be rational-valued Relation;
 cluster rng R -> rational-membered;
end;

registration let R be integer-valued Relation;
 cluster rng R -> integer-membered;
end;

registration let R be natural-valued Relation;
 cluster rng R -> natural-membered;
end;

reserve x,y,X for set,
        f for Function,
        R,S for Relation;

theorem :: VALUED_0:1
 for S being complex-valued Relation st R c= S
  holds R is complex-valued;

theorem :: VALUED_0:2
 for S being ext-real-valued Relation st R c= S
  holds R is ext-real-valued;

theorem :: VALUED_0:3
 for S being real-valued Relation st R c= S
  holds R is real-valued;

theorem :: VALUED_0:4
 for S being rational-valued Relation st R c= S
  holds R is rational-valued;

theorem :: VALUED_0:5
 for S being integer-valued Relation st R c= S
  holds R is integer-valued;

theorem :: VALUED_0:6
 for S being natural-valued Relation st R c= S
  holds R is natural-valued;

registration let R be complex-valued Relation;
 cluster -> complex-valued Subset of R;
end;

registration let R be ext-real-valued Relation;
 cluster -> ext-real-valued Subset of R;
end;

registration let R be real-valued Relation;
 cluster -> real-valued Subset of R;
end;

registration let R be rational-valued Relation;
 cluster -> rational-valued Subset of R;
end;

registration let R be integer-valued Relation;
 cluster -> integer-valued Subset of R;
end;

registration let R be natural-valued Relation;
 cluster -> natural-valued Subset of R;
end;

registration let R,S be complex-valued Relation;
 cluster R \/ S -> complex-valued;
end;

registration let R,S be ext-real-valued Relation;
 cluster R \/ S -> ext-real-valued;
end;

registration let R,S be real-valued Relation;
 cluster R \/ S -> real-valued;
end;

registration let R,S be rational-valued Relation;
 cluster R \/ S -> rational-valued;
end;

registration let R,S be integer-valued Relation;
 cluster R \/ S -> integer-valued;
end;

registration let R,S be natural-valued Relation;
 cluster R \/ S -> natural-valued;
end;

registration let R be complex-valued Relation; let S;
 cluster R /\ S -> complex-valued;
 cluster R \ S -> complex-valued;
end;

registration let R be ext-real-valued Relation; let S;
 cluster R /\ S -> ext-real-valued;
 cluster R \ S -> ext-real-valued;
end;

registration let R be real-valued Relation; let S;
 cluster R /\ S -> real-valued;
 cluster R \ S -> real-valued;
end;

registration let R be rational-valued Relation; let S;
 cluster R /\ S -> rational-valued;
 cluster R \ S -> rational-valued;
end;

registration let R be integer-valued Relation; let S;
 cluster R /\ S -> integer-valued;
 cluster R \ S -> integer-valued;
end;

registration let R be natural-valued Relation; let S;
 cluster R /\ S -> natural-valued;
 cluster R \ S -> natural-valued;
end;

registration let R,S be complex-valued Relation;
 cluster R \+\ S -> complex-valued;
end;

registration let R,S be ext-real-valued Relation;
 cluster R \+\ S -> ext-real-valued;
end;

registration let R,S be real-valued Relation;
 cluster R \+\ S -> real-valued;
end;

registration let R,S be rational-valued Relation;
 cluster R \+\ S -> rational-valued;
end;

registration let R,S be integer-valued Relation;
 cluster R \+\ S -> integer-valued;
end;

registration let R,S be natural-valued Relation;
 cluster R \+\ S -> natural-valued;
end;

registration let R be complex-valued Relation; let X;
 cluster R.:X -> complex-membered;
end;

registration let R be ext-real-valued Relation; let X;
 cluster R.:X -> ext-real-membered;
end;

registration let R be real-valued Relation; let X;
 cluster R.:X -> real-membered;
end;

registration let R be rational-valued Relation; let X;
 cluster R.:X -> rational-membered;
end;

registration let R be integer-valued Relation; let X;
 cluster R.:X -> integer-membered;
end;

registration let R be natural-valued Relation; let X;
 cluster R.:X -> natural-membered;
end;

registration let R be complex-valued Relation; let x;
 cluster Im(R,x) -> complex-membered;
end;

registration let R be ext-real-valued Relation; let x;
 cluster Im(R,x) -> ext-real-membered;
end;

registration let R be real-valued Relation; let x;
 cluster Im(R,x) -> real-membered;
end;

registration let R be rational-valued Relation; let x;
 cluster Im(R,x) -> rational-membered;
end;

registration let R be integer-valued Relation; let x;
 cluster Im(R,x) -> integer-membered;
end;

registration let R be natural-valued Relation; let x;
 cluster Im(R,x) -> natural-membered;
end;

registration let R be complex-valued Relation; let X;
 cluster R|X -> complex-valued;
end;

registration let R be ext-real-valued Relation; let X;
 cluster R|X -> ext-real-valued;
end;

registration let R be real-valued Relation; let X;
 cluster R|X -> real-valued;
end;

registration let R be rational-valued Relation; let X;
 cluster R|X -> rational-valued;
end;

registration let R be integer-valued Relation; let X;
 cluster R|X -> integer-valued;
end;

registration let R be natural-valued Relation; let X;
 cluster R|X -> natural-valued;
end;

registration let X be complex-membered set;
 cluster id X -> complex-valued;
end;

registration let X be ext-real-membered set;
 cluster id X -> ext-real-valued;
end;

registration let X be real-membered set;
 cluster id X -> real-valued;
end;

registration let X be rational-membered set;
 cluster id X -> rational-valued;
end;

registration let X be integer-membered set;
 cluster id X -> integer-valued;
end;

registration let X be natural-membered set;
 cluster id X -> natural-valued;
end;

registration let R; let S be complex-valued Relation;
 cluster R*S -> complex-valued;
end;

registration let R; let S be ext-real-valued Relation;
 cluster R*S -> ext-real-valued;
end;

registration let R; let S be real-valued Relation;
 cluster R*S -> real-valued;
end;

registration let R; let S be rational-valued Relation;
 cluster R*S -> rational-valued;
end;

registration let R; let S be integer-valued Relation;
 cluster R*S -> integer-valued;
end;

registration let R; let S be natural-valued Relation;
 cluster R*S -> natural-valued;
end;

definition let f be Function;
 redefine
 attr f is complex-valued means
:: VALUED_0:def 7
 for x st x in dom f holds f.x is complex;
 attr f is ext-real-valued means
:: VALUED_0:def 8
 for x st x in dom f holds f.x is ext-real;
 attr f is real-valued means
:: VALUED_0:def 9
 for x st x in dom f holds f.x is real;
 attr f is rational-valued means
:: VALUED_0:def 10
 for x st x in dom f holds f.x is rational;
 attr f is integer-valued means
:: VALUED_0:def 11
 for x st x in dom f holds f.x is integer;
 attr f is natural-valued means
:: VALUED_0:def 12
 for x st x in dom f holds f.x is natural;
end;

theorem :: VALUED_0:7
 f is complex-valued iff for x holds f.x is complex;

theorem :: VALUED_0:8
 f is ext-real-valued iff for x holds f.x is ext-real;

theorem :: VALUED_0:9
 f is real-valued iff for x holds f.x is real;

theorem :: VALUED_0:10
 f is rational-valued iff for x holds f.x is rational;

theorem :: VALUED_0:11
 f is integer-valued iff for x holds f.x is integer;

theorem :: VALUED_0:12
 f is natural-valued iff for x holds f.x is natural;


registration let f be complex-valued Function; let x;
 cluster f.x -> complex;
end;

registration let f be ext-real-valued Function; let x;
 cluster f.x -> ext-real;
end;

registration let f be real-valued Function; let x;
 cluster f.x -> real;
end;

registration let f be rational-valued Function; let x;
 cluster f.x -> rational;
end;

registration let f be integer-valued Function; let x;
 cluster f.x -> integer;
end;

registration let f be natural-valued Function; let x;
 cluster f.x -> natural;
end;

registration let X; let x be complex number;
 cluster X --> x -> complex-valued;
end;

registration let X; let x be ext-real number;
 cluster X --> x -> ext-real-valued;
end;

registration let X; let x be real number;
 cluster X --> x -> real-valued;
end;

registration let X; let x be rational number;
 cluster X --> x -> rational-valued;
end;

registration let X; let x be integer number;
 cluster X --> x -> integer-valued;
end;

registration let X; let x be natural number;
 cluster X --> x -> natural-valued;
end;

registration let f,g be complex-valued Function;
 cluster f +* g -> complex-valued;
end;

registration let f,g be ext-real-valued Function;
 cluster f +* g -> ext-real-valued;
end;

registration let f,g be real-valued Function;
 cluster f +* g -> real-valued;
end;

registration let f,g be rational-valued Function;
 cluster f +* g -> rational-valued;
end;

registration let f,g be integer-valued Function;
 cluster f +* g -> integer-valued;
end;

registration let f,g be natural-valued Function;
 cluster f +* g -> natural-valued;
end;

registration let x; let y be complex number;
 cluster x .--> y -> complex-valued;
end;

registration let x; let y be ext-real number;
 cluster x .--> y -> ext-real-valued;
end;

registration let x; let y be real number;
 cluster x .--> y -> real-valued;
end;

registration let x; let y be rational number;
 cluster x .--> y -> rational-valued;
end;

registration let x; let y be integer number;
 cluster x .--> y -> integer-valued;
end;

registration let x; let y be natural number;
 cluster x .--> y -> natural-valued;
end;

registration let X; let Y be complex-membered set;
 cluster -> complex-valued Relation of X,Y;
end;

registration let X; let Y be ext-real-membered set;
 cluster -> ext-real-valued Relation of X,Y;
end;

registration let X; let Y be real-membered set;
 cluster -> real-valued Relation of X,Y;
end;

registration let X; let Y be rational-membered set;
 cluster -> rational-valued Relation of X,Y;
end;

registration let X; let Y be integer-membered set;
 cluster -> integer-valued Relation of X,Y;
end;

registration let X; let Y be natural-membered set;
 cluster -> natural-valued Relation of X,Y;
end;

registration let X; let Y be complex-membered set;
 cluster [:X,Y:] -> complex-valued;
end;

registration let X; let Y be ext-real-membered set;
 cluster [:X,Y:] -> ext-real-valued;
end;

registration let X; let Y be real-membered set;
 cluster [:X,Y:] -> real-valued;
end;

registration let X; let Y be rational-membered set;
 cluster [:X,Y:] -> rational-valued;
end;

registration let X; let Y be integer-membered set;
 cluster [:X,Y:] -> integer-valued;
end;

registration let X; let Y be natural-membered set;
 cluster [:X,Y:] -> natural-valued;
end;

