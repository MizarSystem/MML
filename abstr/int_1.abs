:: Integers
::  by Micha{\l} J. Trybulec
::
:: Received February 7, 1990
:: Copyright (c) 1990 Association of Mizar Users

environ

 vocabularies NUMBERS, SUBSET_1, XREAL_0, ORDINAL1, ZFMISC_1, CARD_1, XBOOLE_0,
      ARYTM_1, TARSKI, ARYTM_2, ARYTM_3, ARYTM_0, REAL_1, XXREAL_0, NAT_1,
      RELAT_1, INT_1;
 notations TARSKI, XBOOLE_0, ZFMISC_1, SUBSET_1, ORDINAL1, ARYTM_2, ARYTM_1,
      NUMBERS, ARYTM_0, XCMPLX_0, XREAL_0, REAL_1, NAT_1, XXREAL_0;
 constructors FUNCT_4, ARYTM_1, ARYTM_0, XXREAL_0, REAL_1, NAT_1, FINSET_1,
      CARD_1;
 registrations ORDINAL1, NUMBERS, XXREAL_0, XREAL_0, REAL_1, NAT_1;
 requirements REAL, NUMERALS, SUBSET, BOOLE, ARITHM;


begin

reserve X,x,y,z for set,
  k,l,n for Element of NAT,
  r for real number;

definition
  redefine func INT means
:: INT_1:def 1

  x in it iff ex k st x = k or x = - k;
end;

definition
  let i be number;
  attr i is integer means
:: INT_1:def 2

  i in INT;
end;

registration
  cluster integer Real;
  cluster integer number;
  cluster -> integer Element of INT;
end;

definition
  mode Integer is integer number;
end;

canceled 6;

theorem :: INT_1:7
  for k being natural number st r = k or r = -k holds r is Integer;

theorem :: INT_1:8
  r is Integer implies ex k st r = k or r = - k;

:: Relations between sets INT, NAT and REAL ( and their elements )

registration
  cluster -> integer Element of NAT;
  cluster natural -> integer number;
end;

registration
  cluster integer -> real number;
end;

reserve i,i0,i1,i2,i3,i4,i5,i8,i9,j for Integer;

registration
  let i1,i2 be Integer;
  cluster i1 + i2 -> integer;
  cluster i1 * i2 -> integer;
end;

registration
  let i0 be Integer;
  cluster - i0 -> integer;
end;

registration
  let i1,i2 be Integer;
  cluster i1 - i2 -> integer;
end;

:: Some basic theorems about integers

canceled 7;

theorem :: INT_1:16
  0 <= i0 implies i0 in NAT;

theorem :: INT_1:17
  r is Integer implies r + 1 is Integer & r - 1 is Integer;

theorem :: INT_1:18
  i2 <= i1 implies i1 - i2 in NAT;

theorem :: INT_1:19
  i1 + k = i2 implies i1 <= i2;

theorem :: INT_1:20
  i0 < i1 implies i0 + 1 <= i1;

theorem :: INT_1:21
  i1 < 0 implies i1 <= - 1;

theorem :: INT_1:22
  i1 * i2 = 1 iff i1 = 1 & i2 = 1 or i1 = - 1 & i2 = - 1;

theorem :: INT_1:23
  i1 * i2 = - 1 iff i1 = - 1 & i2 = 1 or i1 = 1 & i2 = - 1;

scheme :: INT_1:sch 1

  SepInt { P[Integer] } : ex X being Subset of INT st for x being Integer
  holds x in X iff P[x];

scheme :: INT_1:sch 2

  IntIndUp { F() -> Integer, P[Integer] } : for i0 st F() <= i0 holds P[i0]
provided
 P[F()] and
 for i2 st F() <= i2 holds P[i2] implies P[i2 + 1];

scheme :: INT_1:sch 3

  IntIndDown { F() -> Integer, P[Integer] } : for i0 st i0 <= F() holds P[i0]
provided
 P[F()] and
 for i2 st i2 <= F() holds P[i2] implies P[i2 - 1];

scheme :: INT_1:sch 4

  IntIndFull { F() -> Integer, P[Integer] } : for i0 holds P[i0]
provided
 P[F()] and
 for i2 holds P[i2] implies P[i2 - 1] & P[i2 + 1];

scheme :: INT_1:sch 5

  IntMin { F() -> Integer, P[Integer] } : ex i0 st P[i0] & for i1 st P[i1]
  holds i0 <= i1
provided
 for i1 st P[i1] holds F() <= i1 and
 ex i1 st P[i1];

scheme :: INT_1:sch 6

  IntMax { F() -> Integer, P[Integer] } : ex i0 st P[i0] & for i1 st P[i1]
  holds i1 <= i0
provided
 for i1 st P[i1] holds i1 <= F() and
 ex i1 st P[i1];

:: abs and sgn functions with integers

definition
  let i1,i2,i3 be Integer;
  pred i1,i2 are_congruent_mod i3 means
:: INT_1:def 3

  ex i4 st i3 * i4 = i1 - i2;
end;

canceled 8;

theorem :: INT_1:32
  i1,i1 are_congruent_mod i2;

theorem :: INT_1:33
  i1,0 are_congruent_mod i1 & 0,i1 are_congruent_mod i1;

theorem :: INT_1:34
  i1,i2 are_congruent_mod 1;

theorem :: INT_1:35
  i1,i2 are_congruent_mod i3 implies i2,i1 are_congruent_mod i3;

theorem :: INT_1:36
  i1,i2 are_congruent_mod i5 & i2,i3 are_congruent_mod i5 implies i1,i3
  are_congruent_mod i5;

theorem :: INT_1:37
  i1,i2 are_congruent_mod i5 & i3,i4 are_congruent_mod i5 implies (i1 +
  i3),(i2 + i4) are_congruent_mod i5;

theorem :: INT_1:38
  i1,i2 are_congruent_mod i5 & i3,i4 are_congruent_mod i5 implies (i1 -
  i3),(i2 - i4) are_congruent_mod i5;

theorem :: INT_1:39
  i1,i2 are_congruent_mod i5 & i3,i4 are_congruent_mod i5 implies (i1 *
  i3),(i2 * i4) are_congruent_mod i5;

theorem :: INT_1:40
  (i1 + i2),i3 are_congruent_mod i5 iff i1, (i3 - i2) are_congruent_mod i5;

theorem :: INT_1:41
  i4 * i5 = i3 implies (i1,i2 are_congruent_mod i3 implies i1,i2
  are_congruent_mod i4);

theorem :: INT_1:42
  i1,i2 are_congruent_mod i5 iff (i1 + i5),i2 are_congruent_mod i5;

theorem :: INT_1:43
  i1,i2 are_congruent_mod i5 iff (i1 - i5),i2 are_congruent_mod i5;

theorem :: INT_1:44
  i1 <= r & r - 1 < i1 & i2 <= r & r - 1 < i2 implies i1 = i2;

theorem :: INT_1:45
  r <= i1 & i1 < r + 1 & r <= i2 & i2 < r + 1 implies i1 = i2;

reserve r1,p,p1,g,g1,g2 for real number,
  Y for Subset of REAL;

definition
  let r be real number;
  func [\ r /] -> Integer means
:: INT_1:def 4

  it <= r & r - 1 < it;
end;

canceled;

theorem :: INT_1:47
  [\ r /] = r iff r is integer;

theorem :: INT_1:48
  [\ r /] < r iff r is not integer;

canceled;

theorem :: INT_1:50
  [\ r /] - 1 < r & [\ r /] < r + 1;

theorem :: INT_1:51
  [\ r /] + i0 = [\ r + i0 /];

theorem :: INT_1:52
  r < [\ r /] + 1;

definition
  let r be real number;
  func [/ r \] -> Integer means
:: INT_1:def 5

  r <= it & it < r + 1;
end;

canceled;

theorem :: INT_1:54
  [/ r \] = r iff r is integer;

theorem :: INT_1:55
  r < [/ r \] iff r is not integer;

canceled;

theorem :: INT_1:57
  r - 1 < [/ r \] & r < [/ r \] + 1;

theorem :: INT_1:58
  [/ r \] + i0 = [/ r + i0 \];

theorem :: INT_1:59
  [\ r /] = [/ r \] iff r is integer;

theorem :: INT_1:60
  [\ r /] < [/ r \] iff r is not integer;

theorem :: INT_1:61
  [\ r /] <= [/ r \];

theorem :: INT_1:62
  [\ ([/ r \]) /] = [/ r \];

theorem :: INT_1:63
  [\ ([\ r /]) /] = [\ r /];

theorem :: INT_1:64
  [/ ([/ r \]) \] = [/ r \];

theorem :: INT_1:65
  [/ ([\ r /]) \] = [\ r /];

theorem :: INT_1:66
  [\ r /] = [/ r \] iff not [\ r /] + 1 = [/ r \];

definition
  let r be real number;
  func frac r equals
:: INT_1:def 6
  r - [\ r /];
end;

registration
  let r be real number;
  cluster frac r -> real;
end;

definition
  let r be real number;
  redefine func frac r -> Real;
end;

canceled;

theorem :: INT_1:68
  r = [\ r /] + frac r;

theorem :: INT_1:69
  frac r < 1 & 0 <= frac r;

theorem :: INT_1:70
  [\ frac r /] = 0;

theorem :: INT_1:71
  frac r = 0 iff r is integer;

theorem :: INT_1:72
  0 < frac r iff r is not integer;

:: Functions div and mod

definition
  let i1,i2 be Integer;
  func i1 div i2 -> Integer equals
:: INT_1:def 7
  [\ i1 / i2 /];
end;

definition
  let i1,i2 be Integer;
  func i1 mod i2 -> Integer equals
:: INT_1:def 8

  i1 - (i1 div i2) * i2 if i2 <> 0
  otherwise 0;
end;

:: The divisibility relation

definition
  let i1,i2 be Integer;
  pred i1 divides i2 means
:: INT_1:def 9

  ex i3 st i2 = i1 * i3;
  reflexivity;
end;

canceled;

theorem :: INT_1:74
  for r being real number st r <> 0 holds [\ r / r /] = 1;

theorem :: INT_1:75
  for i being Integer holds i div 0 = 0;

theorem :: INT_1:76
  for i being Integer st i <> 0 holds i div i = 1;

theorem :: INT_1:77
  for i being Integer holds i mod i = 0;

begin :: Addenda
:: from FSM_1

theorem :: INT_1:78
  for k, i being Integer holds
  k < i implies ex j being Element of NAT st j = i-k & 1 <= j;

:: from SCMFSA_7, 2005.02.05, A.T.

theorem :: INT_1:79
  for a,b being Integer st a < b holds a <= b - 1;

:: from UNIFORM1, 2005.08.22, A.T.

theorem :: INT_1:80
  for r being real number st r>=0 holds [/ r \]>=0 & [\ r /]>=0 &
  [/ r \] is Element of NAT & [\ r /] is Element of NAT;

:: from SCMFSA9A, 2005.11.16, A.T.

theorem :: INT_1:81
  for i being Integer, r being real number st i <= r holds i <= [\ r /];

theorem :: INT_1:82
  for m,n being natural number holds 0 <= m qua Integer div n;

:: from SCMFSA9A, 2006.03.14, A.T.

theorem :: INT_1:83
  0 < i & 1 < j implies i div j < i;

:: from NEWTON, 2007.01.02, AK

theorem :: INT_1:84
  i2 >= 0 implies i1 mod i2 >= 0;

theorem :: INT_1:85
  i2 > 0 implies i1 mod i2 < i2;

theorem :: INT_1:86
  i2 <> 0 implies i1 = (i1 div i2) * i2 + (i1 mod i2);

:: from AMI_3, 2007.06.14, A.T.

theorem :: INT_1:87
  for m,j being Integer holds m*j, 0 are_congruent_mod m;

:: from AMI_4, 2007.06.14, A.T.

theorem :: INT_1:88
  i >= 0 & j >= 0 implies i div j >= 0;

:: from INT_3, 2007.07.27, A.T.

theorem :: INT_1:89
  for n being natural number st n > 0 for a being Integer holds a mod n
  = 0 iff n divides a;

:: from JORDAN1D, 2007.07.27, A.T.

reserve r, s for real number;

theorem :: INT_1:90
  r/s is not Integer implies - [\ r/s /] = [\ (-r) / s /] + 1;

theorem :: INT_1:91
  r/s is Integer implies - [\ r/s /] = [\ (-r) / s /];

:: missing, 2008.05.16, A.T.

theorem :: INT_1:92
  r <= i implies [/ r \] <= i;

:: from POLYNOM2, 2010.02.13, A.T.

scheme :: INT_1:sch 7

  FinInd{M, N() -> Element of NAT, P[Nat]} : for i being Element of NAT st M()
  <= i & i <= N() holds P[i]
provided
 P[M()] and
 for j being Element of NAT st M() <= j & j < N() holds P[j] implies P[j+1];

scheme :: INT_1:sch 8

  FinInd2{M,N() -> Element of NAT, P[Nat]} : for i being Element of NAT st M()
  <= i & i <= N() holds P[i]
provided
 P[M()] and
 for j being Element of NAT st M() <= j & j < N() holds (for j9 being
Element of NAT st M() <= j9 & j9 <= j holds P[j9]) implies P[j+1];
