:: Integers
::  by Micha{\l} J. Trybulec
::
:: Received February 7, 1990
:: Copyright (c) 1990 Association of Mizar Users

environ

 vocabulary ARYTM, ARYTM_1, ORDINAL2, ABSVALUE, NAT_1, ARYTM_3, RELAT_1, INT_1,
      BOOLE, COMPLEX1, ARYTM_2, XCMPLX_0;
 notation TARSKI, XBOOLE_0, ZFMISC_1, SUBSET_1, ORDINAL1, ORDINAL2, ARYTM_2,
      ARYTM_1, NUMBERS, ARYTM_0, XCMPLX_0, XREAL_0, REAL_1, ABSVALUE, NAT_1;
 constructors REAL_1, ABSVALUE, NAT_1, XCMPLX_0, XREAL_0, XBOOLE_0, ARYTM_0,
      ARYTM_3, ARYTM_2, FUNCT_4, ARYTM_1;
 clusters XREAL_0, ARYTM_3, REAL_1, ORDINAL2, NUMBERS, ZFMISC_1, XBOOLE_0,
      XCMPLX_0;
 requirements REAL, NUMERALS, SUBSET, BOOLE, ARITHM;


begin

 reserve X,x,y,z for set,
         k,l,n,n1,n2 for Nat,
         r for real number;

registration
 cluster -> complex Element of COMPLEX;
 coherence
  proof let c be Element of COMPLEX;
   thus c in COMPLEX;
  end;
end;

 definition
  redefine func INT means
:: INT_1:def 1
    x in it iff ex k st x = k or x = - k;
 end;


 definition let i be number;
  attr i is integer means
:: INT_1:def 2
    i is Element of INT;
 end;


 registration
  cluster integer Real;
  existence
   proof
    take 0;
    thus 0 is Element of INT by Def1;
   end;
  cluster integer number;
  existence
   proof
    take 0;
    thus 0 is Element of INT by Def1;
   end;
  cluster -> integer Element of INT;
  coherence by Def2;
 end;


definition
  mode Integer is integer number;
end;


canceled 7;

 theorem :: INT_1:8
  r is Integer iff ex k st r = k or r = - k;

:: Relations between sets INT, NAT and REAL ( and their elements )

registration
 cluster -> integer Nat;
 coherence by Th8;
 cluster natural -> integer number;
 coherence
  proof let n be number;
   assume n is natural;
   then n is Nat by ORDINAL2:def 21;
   hence thesis by Th8;
  end;
end;

canceled 2;

 theorem :: INT_1:11
  x in INT implies x in REAL;

registration
 cluster integer -> real number;
coherence
  proof
    let n be number;
    assume n is integer;
    then n is Element of INT by Def2;
    then reconsider n as Element of REAL by Th11;
      n is real;
    hence thesis;
  end;
end;


 theorem :: INT_1:12
  x is Integer iff x in INT;

canceled;

 theorem :: INT_1:14
    NAT c= INT;

 theorem :: INT_1:15
    INT c= REAL;

 reserve i0,i1,i2,i3,i4,i5,i7,i8,i9 for Integer;

:: Now we are ready to redefine some functions
:: Redefinition of functions "+", "*" and "-"

 registration
  let i1,i2 be Integer;
   cluster i1 + i2 -> integer;
    coherence
     proof
      consider k such that A1: (i1 = k or i1 = - k) by Th8;
      consider l such that A2: (i2 = l or i2 = - l) by Th8;
A3:    now
       assume i1 = k & i2 = l;
       then i1 + i2 = k + l;
       hence i1 + i2 is Integer;
      end;
A4:    now
       assume A5: i1 = k & i2 = - l;
       A6: now
        assume k - l <= 0;
        then k <= 0 + l by REAL_1:86;
        then consider z being Nat such that A7: l = k + z by NAT_1:28;
          - z = - (l - k) by A7,XCMPLX_1:26
                .= 0 - (l - k) by XCMPLX_1:150
                .= 0 - l + k by XCMPLX_1:37
                .= 0 + (- l) + k by XCMPLX_0:def 8
                .= - l + k;
        then k - l = - z by XCMPLX_0:def 8;
        hence k - l is Integer by Th8;
       end;
        now
        assume 0 <= k - l;
        then 0 + l <= k by REAL_1:84;
        then consider z being Nat such that A8: k = l + z by NAT_1:28;
        thus k - l is Integer by A8,XCMPLX_1:26;
       end;
       hence i1 + i2 is Integer by A5,A6,XCMPLX_0:def 8;
      end;
A9:    now
       assume A10: i1 = - k & i2 = l;
       A11: now
        assume l - k <= 0;
        then l <= 0 + k by REAL_1:86;
        then consider z being Nat such that A12: k = l + z by NAT_1:28;
          - z = - (k - l) by A12,XCMPLX_1:26
                .= 0 - (k - l) by XCMPLX_1:150
                .= 0 - k + l by XCMPLX_1:37
                .= 0 + (- k) + l by XCMPLX_0:def 8
                .= - k + l;
        then l - k = - z by XCMPLX_0:def 8;
        hence l - k is Integer by Th8;
       end;
         now
        assume 0 <= l - k;
        then 0 + k <= l by REAL_1:84;
        then consider z being Nat such that A13: l = k + z by NAT_1:28;
        thus l - k is Integer by A13,XCMPLX_1:26;
       end;
       hence i1 + i2 is Integer by A10,A11,XCMPLX_0:def 8;
      end;
        now
       assume i1 = - k & i2 = - l;
       then i1 + i2 = - k - l by XCMPLX_0:def 8
                      .= 0 - k - l by XCMPLX_1:150
                      .= 0 - (k + l) by XCMPLX_1:36
                      .= - (k + l) by XCMPLX_1:150;
       hence i1 + i2 is Integer by Th8;
      end;
      hence thesis by A1,A2,A3,A4,A9;
     end;

   cluster i1 * i2 -> integer;
    coherence
     proof
      consider k such that A14: (i1 = k or i1 = - k) by Th8;
      consider l such that A15: (i2 = l or i2 = - l) by Th8;
A16:    now
       assume i1 = k & i2 = l;
       then i1 * i2 = k * l;
       hence i1 * i2 is Integer;
      end;
A17:    now
       assume i1 = - k & i2 = - l;
       then i1 * i2 = - (k * (- l)) by XCMPLX_1:175
                   .= - - (k * l) by XCMPLX_1:175
                   .= k * l;
       hence i1 * i2 is Integer;
      end;
        now
       assume (i1 = - k & i2 = l) or (i1 = k & i2 = - l);
       then i1 * i2 = - (k * l) by XCMPLX_1:175;
       hence i1 * i2 is Integer by Th8;
      end;
      hence i1 * i2 is integer by A14,A15,A16,A17;
     end;
 end;


 registration
  let i0 be Integer;
   cluster - i0 -> integer;
    coherence
     proof
      consider k such that A1: i0 = k or i0 = - k by Th8;
      thus thesis by A1,Th8;
     end;
 end;


 registration
  let i1,i2 be Integer;
   cluster i1 - i2 -> integer;
    coherence
     proof
        i1 - i2 = i1 + (- i2) by XCMPLX_0:def 8;
      hence i1 - i2 is integer;
     end;
 end;


:: More redefinitions

 registration
  let n be Nat;
   cluster - n -> integer;
    coherence;
  let i1 be Integer;
   cluster i1 + n -> integer;
    coherence;
   cluster i1 * n -> integer;
    coherence;
   cluster i1 - n -> integer;
    coherence;
 end;


 registration
  let n1,n2;
   cluster n1 - n2 -> integer;
    coherence
     proof
      reconsider l = n1 as Integer by Lm1;
        l - n2 is Integer;
      hence thesis;
     end;
 end;


:: Some basic theorems about integers

 theorem :: INT_1:16
  0 <= i0 implies i0 is Nat;

 theorem :: INT_1:17
    r is Integer implies r + 1 is Integer & r - 1 is Integer;

 theorem :: INT_1:18
  i2 <= i1 implies i1 - i2 is Nat;

 theorem :: INT_1:19
  i1 + k = i2 implies i1 <= i2;

 theorem :: INT_1:20
  i0 < i1 implies i0 + 1 <= i1;

 theorem :: INT_1:21
  i1 < 0 implies i1 <= - 1;

 theorem :: INT_1:22
  i1 * i2 = 1 iff (i1 = 1 & i2 = 1) or (i1 = - 1 & i2 = - 1);

 theorem :: INT_1:23
    i1 * i2 = - 1 iff (i1 = - 1 & i2 = 1) or (i1 = 1 & i2 = - 1);

canceled 2;

 theorem :: INT_1:26
  r - 1 < r;

scheme :: INT_1:sch 1
 SepInt { P[Integer] } :
 ex X being Subset of INT st
  for x being Integer holds x in X iff P[x]
proof
     defpred P1[set] means ex i0 st i0 = $1 & P[i0];
    consider X such that
A1:   for y holds y in X iff
      y in INT & P1[y] from XBOOLE_0:sch 1;
      X is Subset of INT
     proof
        y in X implies y in INT by A1;
      hence thesis by TARSKI:def 3;
     end;
    then reconsider X as Subset of INT;
    take X;
    let i0;
A2:  i0 in X implies P[i0]
     proof
      assume i0 in X;
      then ex i1 st i0 = i1 & P[i1] by A1;
      hence thesis;
     end;
      P[i0] implies i0 in X
     proof
      assume A3: P[i0];
        i0 in INT by Th12;
      hence thesis by A1,A3;
     end;
    hence thesis by A2;
   end;

scheme :: INT_1:sch 2
 Int_Ind_Up { F() -> Integer, P[Integer] } :
 for i0 st F() <= i0 holds P[i0] provided
 P[F()] and
 for i2 st F() <= i2 holds P[i2] implies P[i2 + 1]
proof
  let i0;
  assume A3: F() <= i0;
  defpred Q[Nat] means
   for i2 st $1 = i2 - F() holds P[i2];
A4: Q[0]
    proof
     let i2;
     assume 0 = i2 - F();
     then F() = i2 - F() + F()
             .= i2 by XCMPLX_1:27;
     hence thesis by A1;
    end;
A5: for k st Q[k] holds Q[k + 1]
    proof
     let k;
     reconsider i8 = k as Integer by Lm1;
     assume A6: Q[k];
     let i2;
     assume A7: k + 1 = i2 - F();
     then i2 - F() - 1 = k by XCMPLX_1:26;
     then k = i2 + (- F()) - 1 by XCMPLX_0:def 8
           .= i2 + (- F()) + (- 1) by XCMPLX_0:def 8
           .= i2 + (- 1) + (- F()) by XCMPLX_1:1
           .= i2 - 1 + (- F()) by XCMPLX_0:def 8
           .= i2 - 1 - F() by XCMPLX_0:def 8;
     then A8: P[i2 - 1] by A6;
        F() <= i2 - 1
      proof
         k + 1 + F() = i2 by A7,XCMPLX_1:27;
       then i2 - 1 = k + 1 + F() + (- 1) by XCMPLX_0:def 8
                      .= (k + 1 + (- 1)) + F() by XCMPLX_1:1
                      .= (k + 1 - 1) + F() by XCMPLX_0:def 8
                      .= i8 + F() by XCMPLX_1:26;
       hence thesis by Th19;
      end;
     then P[i2 - 1 + 1] by A2,A8;
     hence thesis by XCMPLX_1:27;
    end;
A9: for k holds Q[k] from NAT_1:sch 1(A4,A5);
  reconsider l = i0 - F() as Nat by A3,Th18;
    l = i0 - F();
  hence P[i0] by A9;
 end;

scheme :: INT_1:sch 3
 Int_Ind_Down { F() -> Integer, P[Integer] } :
 for i0 st i0 <= F() holds P[i0] provided
   P[F()] and
   for i2 st i2 <= F() holds P[i2] implies P[i2 - 1]
proof
  let i0;
  assume A3: i0 <= F();
  defpred Q[Integer] means
   for i2 st $1 = - i2 holds P[i2];
A4: Q[- F()]
    proof
     let i2;
     assume - F() = - i2;
     then - (- F()) = i2;
     hence thesis by A1;
    end;
A5: for i2 st - F() <= i2 holds Q[i2] implies Q[i2 + 1]
    proof
     let i2;
     assume that A6: - F() <= i2 and A7: Q[i2];
     let i3;
     assume A8: i2 + 1 = - i3;
     then - i3 - 1 = i2 by XCMPLX_1:26;
     then i2 = - i3 + (- 1) by XCMPLX_0:def 8
            .= 0 - i3 + (- 1) by XCMPLX_1:150
            .= 0 - i3 - 1 by XCMPLX_0:def 8
            .= 0 - (i3 + 1) by XCMPLX_1:36
            .= - (i3 + 1) by XCMPLX_1:150;
     then A9: P[i3 + 1] by A7;
        i3 + 1 <= F()
      proof
         i2 = - i3 - 1 by A8,XCMPLX_1:26;
       then A10: - (- i3 - 1) <= - (- F()) by A6,REAL_1:50;
         - (- i3 - 1) = 0 - (- i3 - 1) by XCMPLX_1:150
                   .= 0 - (- i3 + (- 1)) by XCMPLX_0:def 8
                   .= 0 - (- i3) - (- 1) by XCMPLX_1:36
                   .= 0 + (- (- i3)) - (- 1) by XCMPLX_0:def 8
                   .= 0 + i3 + (- (- 1)) by XCMPLX_0:def 8
                   .= i3 + 1;
       hence thesis by A10;
      end;
     then P[i3 + 1 - 1] by A2,A9;
     hence thesis by XCMPLX_1:26;
    end;
A11: for i2 st - F() <= i2 holds Q[i2] from Int_Ind_Up(A4,A5);
    - F() <= - i0 by A3,REAL_1:50;
  hence thesis by A11;
 end;

scheme :: INT_1:sch 4
 Int_Ind_Full { F() -> Integer, P[Integer] } :
 for i0 holds P[i0] provided
   P[F()] and
   for i2 holds P[i2] implies P[i2 - 1] & P[i2 + 1]
proof
   defpred P1[Integer] means P[$1];
    A3:P1[F()] by A1;
  let i0;
A4: now
    assume A5: F() <= i0;
    A6: for i2 st F() <= i2 holds P1[i2] implies P1[i2 + 1] by A2;
      for i2 st F() <= i2 holds P1[i2] from Int_Ind_Up(A3,A6);
    hence P[i0] by A5;
   end;
   now
    assume A7: i0 <= F();
    A8: for i2 st i2 <= F() holds P1[i2] implies P1[i2 - 1] by A2;
      for i2 st i2 <= F() holds P1[i2] from Int_Ind_Down(A3,A8);
    hence P[i0] by A7;
   end;
  hence thesis by A4;
 end;

scheme :: INT_1:sch 5
 Int_Min { F() -> Integer, P[Integer] } :
 ex i0 st P[i0] & for i1 st P[i1] holds i0 <= i1 provided
 for i1 st P[i1] holds F() <= i1 and
 ex i1 st P[i1]
proof
  consider i1 such that A3: P[i1] by A2;
    F() <= i1 by A1,A3;
  then A4: ex k st F() + k = i1 by Lm4;
  defpred Q[Nat] means P[F() + $1];
   A5: ex k st Q[k] by A3,A4;
   consider l such that A6: Q[l] & for n st Q[n] holds l <= n from NAT_1:sch 5
(A5);
   take i0 = F() + l;
   for i1 st P[i1] holds i0 <= i1
     proof
      let i1;
      assume A7: P[i1];
      then F() <= i1 by A1;
      then consider n such that A8: F() + n = i1 by Lm4;
      A9: l <= n by A6,A7,A8;
         n = i1 - F() by A8,XCMPLX_1:26;
      then i0 - F() <= i1 - F() by A9,XCMPLX_1:26;
      hence i0 <= i1 by REAL_1:54;
     end;
   hence thesis by A6;
 end;

scheme :: INT_1:sch 6
 Int_Max { F() -> Integer, P[Integer] } :
 ex i0 st P[i0] & for i1 st P[i1] holds i1 <= i0 provided
 for i1 st P[i1] holds i1 <= F() and
 ex i1 st P[i1]
proof
  consider i1 such that A3: P[i1] by A2;
    i1 <= F() by A1,A3;
  then A4: ex k st i1 = F() - k by Lm5;
  defpred Q[Nat] means P[F() - $1];
   A5: ex k st Q[k] by A3,A4;
   consider l such that A6: Q[l] & for n st Q[n] holds l <= n from NAT_1:sch 5
(A5);
   take i0 = F() - l;
   for i1 st P[i1] holds i1 <= i0
     proof
      let i1;
      assume A7: P[i1];
      then i1 <= F() by A1;
      then consider n such that A8: F() - n = i1 by Lm5;
      A9: l <= n by A6,A7,A8;
         n = F() - i1 by A8,XCMPLX_1:18;
      then F() - i0 <= F() - i1 by A9,XCMPLX_1:18;
      then F() - i0 - F() <= F() - i1 - F() by REAL_1:49;
      then F() + (- i0) - F() <= F() - i1 - F() by XCMPLX_0:def 8;
      then F() + (- i0) - F() <= F() + (- i1) - F() by XCMPLX_0:def 8;
      then - i0 <= F() + (- i1) - F() by XCMPLX_1:26;
      then - i0 <= - i1 by XCMPLX_1:26;
      hence i1 <= i0 by REAL_1:50;
     end;
   hence thesis by A6;
 end;

:: abs and sgn functions with integers

 registration
  let r;
   cluster sgn r -> integer;
    coherence
     proof
        r < 0 or 0 < r or r = 0;
      hence thesis by ABSVALUE:def 2;
     end;
 end;


canceled 2;

 theorem :: INT_1:29
    sgn r = 1 or sgn r = - 1 or sgn r = 0;

 theorem :: INT_1:30
  abs r = r or abs r = - r;

 registration
  let i0;
   cluster abs i0 -> integer;
    coherence
     proof
        abs i0 = i0 or abs i0 = - i0 by Th30;
      hence thesis;
     end;
 end;


:: Congruences

 definition
  let i1,i2,i3 be Integer;
  pred i1,i2 are_congruent_mod i3 means
:: INT_1:def 3
    ex i4 st i3 * i4 = i1 - i2;
 end;


canceled;

 theorem :: INT_1:32
    i1,i1 are_congruent_mod i2;

 theorem :: INT_1:33
    i1,0 are_congruent_mod i1 & 0,i1 are_congruent_mod i1;

 theorem :: INT_1:34
    i1,i2 are_congruent_mod 1;

 theorem :: INT_1:35
    i1,i2 are_congruent_mod i3 implies i2,i1 are_congruent_mod i3;

 theorem :: INT_1:36
    i1,i2 are_congruent_mod i5 & i2,i3 are_congruent_mod i5
             implies i1,i3 are_congruent_mod i5;

 theorem :: INT_1:37
    i1,i2 are_congruent_mod i5 & i3,i4 are_congruent_mod i5
      implies (i1 + i3),(i2 + i4) are_congruent_mod i5;

 theorem :: INT_1:38
    i1,i2 are_congruent_mod i5 & i3,i4 are_congruent_mod i5
            implies (i1 - i3),(i2 - i4) are_congruent_mod i5;

 theorem :: INT_1:39
    i1,i2 are_congruent_mod i5 & i3,i4 are_congruent_mod i5
          implies (i1 * i3),(i2 * i4) are_congruent_mod i5;

 theorem :: INT_1:40
    (i1 + i2),i3 are_congruent_mod i5 iff i1, (i3 - i2) are_congruent_mod i5;

 theorem :: INT_1:41
    i4 * i5 = i3
   implies (i1,i2 are_congruent_mod i3 implies i1,i2 are_congruent_mod i4);

 theorem :: INT_1:42
    i1,i2 are_congruent_mod i5 iff (i1 + i5),i2 are_congruent_mod i5;

 theorem :: INT_1:43
    i1,i2 are_congruent_mod i5 iff (i1 - i5),i2 are_congruent_mod i5;

 theorem :: INT_1:44
  (i1 <= r & r - 1 < i1) & (i2 <= r & r - 1 < i2) implies i1 = i2;

 theorem :: INT_1:45
  (r <= i1 & i1 < r + 1) & (r <= i2 & i2 < r + 1) implies i1 = i2;

reserve r1,p,p1,g,g1,g2 for real number,
        X,Y for Subset of REAL;

 definition
  let r be real number;
  func [\ r /] -> Integer means
:: INT_1:def 4
it <= r & r - 1 < it;
 end;


canceled;

 theorem :: INT_1:47
  [\ r /] = r iff r is integer;

 theorem :: INT_1:48
  [\ r /] < r iff r is not integer;

canceled;

 theorem :: INT_1:50
    [\ r /] - 1 < r & [\ r /] < r + 1;

 theorem :: INT_1:51
  [\ r /] + i0 = [\ r + i0 /];

 theorem :: INT_1:52
  r < [\ r /] + 1;

 definition
  let r be real number;
  func [/ r \] -> Integer means
:: INT_1:def 5
r <= it & it < r + 1;
 end;


canceled;

 theorem :: INT_1:54
  [/ r \] = r iff r is integer;

 theorem :: INT_1:55
  r < [/ r \] iff r is not integer;

canceled;

 theorem :: INT_1:57
    r - 1 < [/ r \] & r < [/ r \] + 1;

 theorem :: INT_1:58
    [/ r \] + i0 = [/ r + i0 \];

 theorem :: INT_1:59
  [\ r /] = [/ r \] iff r is integer;

 theorem :: INT_1:60
  [\ r /] < [/ r \] iff r is not integer;

 theorem :: INT_1:61
    [\ r /] <= [/ r \];

 theorem :: INT_1:62
    [\ ([/ r \]) /] = [/ r \];

 theorem :: INT_1:63
    [\ ([\ r /]) /] = [\ r /];

 theorem :: INT_1:64
    [/ ([/ r \]) \] = [/ r \];

 theorem :: INT_1:65
    [/ ([\ r /]) \] = [\ r /];

 theorem :: INT_1:66
    [\ r /] = [/ r \] iff not [\ r /] + 1 = [/ r \];

 definition
  let r be real number;
  func frac r equals
:: INT_1:def 6
     r - [\ r /];
 end;


 registration
  let r be real number;
  cluster frac r -> real;
  coherence
  proof
      frac r = r - [\ r /] by Def6;
    hence thesis;
  end;
 end;


 definition
  let r be real number;
  redefine func frac r -> Real;
 end;


canceled;

 theorem :: INT_1:68
    r = [\ r /] + frac r;

 theorem :: INT_1:69
  frac r < 1 & 0 <= frac r;

 theorem :: INT_1:70
    [\ frac r /] = 0;

  theorem :: INT_1:71
   frac r = 0 iff r is integer;

  theorem :: INT_1:72
     0 < frac r iff r is not integer;

:: Functions div and mod

 definition
  let i1,i2 be Integer;
   func i1 div i2 -> Integer equals
:: INT_1:def 7
      [\ i1 / i2 /];
 end;


 definition
  let i1,i2 be Integer;
   func i1 mod i2 -> Integer equals
:: INT_1:def 8
      i1 - (i1 div i2) * i2 if i2 <> 0
            otherwise 0;
 end;


:: The divisibility relation

 definition
  let i1,i2 be Integer;
  pred i1 divides i2 means
:: INT_1:def 9
      ex i3 st i2 = i1 * i3;
  reflexivity;
 end;


canceled;

theorem :: INT_1:74
 for r being real number st r <> 0 holds [\ r / r /] = 1;

theorem :: INT_1:75
   for i being Integer holds i div 0 = 0;

theorem :: INT_1:76
 for i being Integer st i <> 0 holds i div i = 1;

theorem :: INT_1:77
   for i being Integer holds i mod i = 0;

