:: Recursive Euclide Algorithm
::  by JingChao Chen
::
:: Received June 15, 1999
:: Copyright (c) 1999 Association of Mizar Users

environ

 vocabularies NUMBERS, SUBSET_1, SCMPDS_2, AMI_1, FSM_1, INT_1, ARYTM_3,
      COMPLEX1, XXREAL_0, CARD_1, NAT_1, AMI_3, AMI_2, ARYTM_1, TURING_1,
      SCMFSA_7, FUNCT_1, RELAT_1, GRAPHSP, SCMPDS_1, TARSKI, SCMFSA6A,
      CIRCUIT2, INT_2, MSUALG_1, FUNCOP_1, FUNCT_4, XBOOLE_0, STRUCT_0,
      SCMP_GCD, ORDINAL1, PARTFUN1, SCMNORM;
 notations XBOOLE_0, SUBSET_1, CARD_1, NUMBERS, XCMPLX_0, RELAT_1, FUNCT_1,
      INT_1, NAT_1, DOMAIN_1, PARTFUN1, STRUCT_0, FUNCT_4, AMI_1, SCMNORM,
      AMI_2, AMI_3, SCMPDS_1, SCMPDS_2, SCMPDS_3, SCMPDS_4, INT_2, XXREAL_0;
 constructors DOMAIN_1, XXREAL_0, REAL_1, NAT_1, NAT_D, SCMPDS_1, SCMPDS_4,
      AMI_3, SCMNORM, SCMPDS_3;
 registrations SETFAM_1, RELSET_1, NUMBERS, XREAL_0, INT_1, CARD_3, STRUCT_0,
      SCMPDS_2, ORDINAL1, FINSET_1, FUNCT_1, AMI_1, XBOOLE_0;
 requirements NUMERALS, REAL, SUBSET, ARITHM, BOOLE;


begin :: Preliminaries

reserve m,n for Element of NAT,
  a,b for Int_position,
  i,j for Instruction of SCMPDS,
  s,s1,s2 for State of SCMPDS,
  I,J for Program of SCMPDS;

canceled 2;

theorem :: SCMP_GCD:3
  for m being Element of NAT,j being Integer st  m=j holds
  (m+2) = (abs(j))+2;

definition
  let k be Nat;
  func intpos k -> Int_position equals
:: SCMP_GCD:def 1
  dl.k;
end;

canceled;

theorem :: SCMP_GCD:5
  for n1,n2 be Element of NAT holds DataLoc(n1,n2) = intpos(n1+n2);

theorem :: SCMP_GCD:6
  for s being State of SCMPDS,m1,m2 being Element of NAT st IC s= (m1+m2)
  holds ICplusConst(s,-m2)= m1;

:: GBP:Global Base Pointer

definition
  func GBP -> Int_position equals
:: SCMP_GCD:def 2
  intpos 0;
:: SBP:Stack Base(bottom) Pointer
  func SBP -> Int_position equals
:: SCMP_GCD:def 3
  intpos 1;
end;

theorem :: SCMP_GCD:7
  GBP <> SBP;

theorem :: SCMP_GCD:8
  card (I ';' i)= card I + 1;

theorem :: SCMP_GCD:9
  card (i ';' j)= 2;

theorem :: SCMP_GCD:10
  (I ';' i). card I =i &  card I in dom (I ';' i);

theorem :: SCMP_GCD:11
  (I ';' i ';' J). card I =i;

begin :: The Construction of Recursive Euclide Algorithm

:: Greatest Common Divisor
:: gcd(x,y)     < x=(SBP,2) y=(SBP,3) >
:: BEGIN
:: if y=0 then gcd:=x else
:: gcd:=gcd(y, x mod y)
:: END

definition
  func GCD-Algorithm -> Program of SCMPDS equals
:: SCMP_GCD:def 4
::Def04
  (((GBP:=0) ';' (SBP := 7) ';' saveIC(SBP,RetIC) ';'
  goto 2 ';' halt SCMPDS ) ';' (SBP,3)<=0_goto 9 ';'
  ((SBP,6):=(SBP,3)) ';' Divide(SBP,2,SBP,3) ';'
  ((SBP,7):=(SBP,3)) ';' ((SBP,4+RetSP):=(GBP,1))) ';'
  AddTo(GBP,1,4) ';' saveIC(SBP,RetIC) ';'
  (goto -7) ';' ((SBP,2):=(SBP,6)) ';' return SBP;
end;

begin :: The Computation of Recursive Euclide Algorithm

theorem :: SCMP_GCD:12
  card GCD-Algorithm = 15;

theorem :: SCMP_GCD:13
  n < 15 iff  n in dom GCD-Algorithm;

theorem :: SCMP_GCD:14
  GCD-Algorithm. 0=GBP:=0 & GCD-Algorithm. 1=SBP:= 7 &
  GCD-Algorithm. 2=saveIC(SBP,RetIC) & GCD-Algorithm. 3=goto 2 &
  GCD-Algorithm. 4=halt SCMPDS &
  GCD-Algorithm. 5=(SBP,3)<=0_goto 9 &
  GCD-Algorithm. 6=(SBP,6):=(SBP,3) &
  GCD-Algorithm. 7=Divide(SBP,2,SBP,3) &
  GCD-Algorithm. 8=(SBP,7):=(SBP,3) &
  GCD-Algorithm. 9=(SBP,4+RetSP):=(GBP,1) &
  GCD-Algorithm. 10=AddTo(GBP,1,4) &
  GCD-Algorithm. 11=saveIC(SBP,RetIC) &
  GCD-Algorithm. 12=goto -7 & GCD-Algorithm. 13=(SBP,2):=(SBP,6) &
  GCD-Algorithm. 14=return SBP;

theorem :: SCMP_GCD:15
  for s being State of SCMPDS st Initialized GCD-Algorithm c= s
  holds IC Comput(ProgramPart(s),s,4) =  5 & Comput(ProgramPart(s),s,4).GBP = 0
&
  Comput(ProgramPart(s),s,4).SBP = 7 & Comput(ProgramPart(s),s,4).intpos(7+
RetIC) =  2 &
  Comput(ProgramPart(s),s,4).intpos 9 = s.intpos 9 &
  Comput(ProgramPart(s),s,4).intpos 10 = s.intpos 10;

theorem :: SCMP_GCD:16
  for s being State of SCMPDS st GCD-Algorithm c= s
  & IC s =  5 & s.SBP >0 & s.GBP=0 &
  s.DataLoc(s.SBP,3) >= 0 & s.DataLoc(s.SBP,2) >= s.DataLoc(s.SBP,3) holds
  ex n st CurInstr(ProgramPart Comput(ProgramPart(s),s,n),Comput(ProgramPart(s)
,s,n)) =
  return SBP &
  s.SBP=Comput(ProgramPart(s),s,n).SBP & Comput(ProgramPart(s),s,n).DataLoc(s.
SBP,2)
  =s.DataLoc(s.SBP,2) gcd s.DataLoc(s.SBP,3) &
  for j be Element of NAT st 1<j & j <= s.SBP+1 holds
  s.intpos j=Comput(ProgramPart(s),s,n).intpos j;

theorem :: SCMP_GCD:17
  for s being State of SCMPDS st GCD-Algorithm c= s
  & IC s =  5 & s.SBP >0 & s.GBP=0 &
  s.DataLoc(s.SBP,3) >= 0 & s.DataLoc(s.SBP,2) >= 0 holds
  ex n st CurInstr(ProgramPart Comput(ProgramPart(s),s,n),Comput(ProgramPart(s)
,s,n)) =
  return SBP &
  s.SBP=Comput(ProgramPart(s),s,n).SBP & Comput(ProgramPart(s),s,n).DataLoc(s.
SBP,2)
  =s.DataLoc(s.SBP,2) gcd s.DataLoc(s.SBP,3) &
  for j be Element of NAT st 1<j & j <= s.SBP+1 holds
  s.intpos j=Comput(ProgramPart(s),s,n).intpos j;

begin :: The Correctness of Recursive Euclide Algorithm

theorem :: SCMP_GCD:18
  for s being State of SCMPDS st Initialized GCD-Algorithm c= s
  for x, y being Integer st s.intpos 9 = x & s.intpos 10 = y
  & x >= 0 & y >= 0 holds (Result s).intpos 9 = x gcd y;

begin :: The Autonomy of Recursive Euclide Algorithm

theorem :: SCMP_GCD:19
  for p being FinPartState of SCMPDS,x,y being Integer st y >= 0 & x >= y
  & p=(intpos 9,intpos 10) --> (x,y)
  holds Initialized GCD-Algorithm +* p is autonomic;

