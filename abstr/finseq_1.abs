:: Segments of Natural Numbers and Finite Sequences
::  by Grzegorz Bancerek and Krzysztof Hryniewiecki
::
:: Received April 1, 1989
:: Copyright (c) 1990 Association of Mizar Users

environ

 vocabularies ORDINAL2, FUNCT_1, BOOLE, RELAT_1, FINSET_1, TARSKI, ORDINAL1,
      CARD_1, PARTFUN1, ARYTM_1, FINSEQ_1, MONOID_0, FUNCOP_1, FRAENKEL,
      ZF_REFLE, ARYTM, XREAL_0;
 notations TARSKI, XBOOLE_0, ZFMISC_1, SUBSET_1, XCMPLX_0, RELAT_1, FUNCT_1,
      FUNCOP_1, WELLORD2, ORDINAL1, REAL_1, NAT_1, CARD_1, NUMBERS, PARTFUN1,
      FUNCT_4, FINSET_1, XXREAL_0;
 constructors WELLORD2, FUNCOP_1, FUNCT_4, XXREAL_0, XREAL_0, NAT_1, CARD_1;
 registrations XBOOLE_0, SUBSET_1, RELAT_1, FUNCT_1, ORDINAL1, FUNCOP_1,
      FINSET_1, XXREAL_0, XREAL_0, NAT_1, CARD_1, NUMBERS;
 requirements REAL, NUMERALS, SUBSET, BOOLE, ARITHM;


begin

reserve k,l,m,n,k1 for Nat,
  a,b,c,i for Nat,
  x,y,z,y1,y2,X,Y for set,
  f,g for Function;

::                                  ::
::   Segments of Natural Numbers    ::
::                                  ::

definition
  let n be Nat;
  func Seg n -> set equals
:: FINSEQ_1:def 1

  { k where k is Element of NAT: 1 <= k & k <= n };
end;

definition
  let n be Nat;
  redefine func Seg n -> Subset of NAT;
end;

canceled 2;

theorem :: FINSEQ_1:3
  a in Seg b iff 1 <= a & a <= b;

theorem :: FINSEQ_1:4
  Seg 0 = {} & Seg 1 = { 1 } & Seg 2 = { 1,2 };

theorem :: FINSEQ_1:5
  a = 0 or a in Seg a;

theorem :: FINSEQ_1:6
  a+1 in Seg(a+1);

theorem :: FINSEQ_1:7
  a <= b iff Seg a c= Seg b;

theorem :: FINSEQ_1:8
  Seg a = Seg b implies a = b;

theorem :: FINSEQ_1:9
  c <= a implies Seg c = Seg a /\ Seg c;

theorem :: FINSEQ_1:10
  Seg c = Seg c /\ Seg a implies c <= a;

theorem :: FINSEQ_1:11
  Seg a \/ { a+1 } = Seg (a+1);

theorem :: FINSEQ_1:12
  for k being Nat holds Seg k = Seg(k + 1) \ {k + 1};

::  Finite Sequences

definition
  let IT be Relation;
  attr IT is FinSequence-like means
:: FINSEQ_1:def 2

  ex n st dom IT = Seg n;
end;

registration
  cluster empty -> FinSequence-like Relation;
end;

definition
  mode FinSequence is FinSequence-like Function;
end;

reserve p,q,r,s,t for FinSequence;

registration
  let n be Nat;
  cluster Seg n -> finite;
end;

registration
  cluster FinSequence-like -> finite Function;
end;

notation
  let p;
  synonym len p for card p;
end;

definition
  let p;
  redefine func len p -> Element of NAT means
:: FINSEQ_1:def 3

  Seg it = dom p;
end;

definition
  let p;
  redefine func dom p -> Subset of NAT;
end;

canceled;

theorem :: FINSEQ_1:14
  {} is FinSequence;

theorem :: FINSEQ_1:15
  (ex k st dom f c= Seg k) implies ex p st f c= p;

scheme :: FINSEQ_1:sch 1
 SeqEx{A()->Nat,P[set,set]}:
  ex p st dom p = Seg A() & for k st k in Seg A() holds P[k,p.k]
provided
 for k st k in Seg A() ex x st P[k,x];

scheme :: FINSEQ_1:sch 2
 SeqLambda{A()->Nat,F(set) -> set}:
  ex p being FinSequence st len p = A() & for k st k in dom p holds p.k=F(k);

theorem :: FINSEQ_1:16
  z in p implies ex k st k in dom p & z=[k,p.k];

theorem :: FINSEQ_1:17
  dom p = dom q & (for k st k in dom p holds p.k = q.k) implies p=q;

theorem :: FINSEQ_1:18
  len p = len q & (for k st 1 <= k & k <= len p holds p.k = q.k) implies p=q;

theorem :: FINSEQ_1:19
  p|(Seg a) is FinSequence;

theorem :: FINSEQ_1:20
  rng p c= dom f implies f*p is FinSequence;

theorem :: FINSEQ_1:21
  a <= len p & q = p|(Seg a) implies len q = a & dom q = Seg a;

::                             ::
::    FinSequences of D        ::
::                             ::

definition
  let D be set;
  mode FinSequence of D -> FinSequence means
:: FINSEQ_1:def 4

    rng it c= D;
end;

registration
  let D be set;
  cluster -> D-valued FinSequence of D;
end;

registration
  cluster empty -> FinSequence-like Relation;
end;

registration
  let D be set;
  cluster FinSequence-like PartFunc of NAT,D;
end;

definition
  let D be set;
  redefine mode FinSequence of D -> FinSequence-like PartFunc of NAT,D;
end;

reserve D for set;

canceled;

theorem :: FINSEQ_1:23
  for p being FinSequence of D holds p|(Seg a) is FinSequence of D;

theorem :: FINSEQ_1:24
  for D being non empty set ex p being FinSequence of D st len p = a;

::                                ::
::    The Empty FinSequence       ::
::                                ::

canceled 3;

theorem :: FINSEQ_1:28
  p <> {} iff len p >= 1;

definition
  let x;
  func <*x*> -> set equals
:: FINSEQ_1:def 5

  { [1,x] };
end;

definition
  let D be set;
  func <*>D -> FinSequence of D equals
:: FINSEQ_1:def 6

  {};
end;

registration
  let D be set;
 cluster <*>D -> empty;
end;

registration
  let D be set;
  cluster empty FinSequence of D;
end;

canceled 3;

theorem :: FINSEQ_1:32
  p=<*>D iff len p = 0;

definition
  let p,q;
  func p^q -> FinSequence means
:: FINSEQ_1:def 7

  dom it = Seg (len p + len q) &
  (for k st k in dom p holds it.k=p.k) &
  (for k st k in dom q holds it.(len p + k) = q.k);
end;

theorem :: FINSEQ_1:33
  p = (p ^ q) | (dom p);

canceled;

theorem :: FINSEQ_1:35
  len(p^q) = len p + len q;

theorem :: FINSEQ_1:36
  for k being Nat st
  (len p + 1 <= k & k <= len p + len q) holds (p^q).k=q.(k-len p);

theorem :: FINSEQ_1:37
  for k being Nat st len p < k & k <= len(p^q) holds (p^q).k = q.(k - len p);

theorem :: FINSEQ_1:38
  for k being Nat st k in dom (p^q) holds
  (k in dom p or (ex n st n in dom q & k=len p + n));

theorem :: FINSEQ_1:39
  dom p c= dom(p^q);

theorem :: FINSEQ_1:40
  x in dom q implies ex k st k=x & len p + k in dom(p^q);

theorem :: FINSEQ_1:41
  k in dom q implies len p + k in dom(p^q);

theorem :: FINSEQ_1:42
  rng p c= rng(p^q);

theorem :: FINSEQ_1:43
  rng q c= rng(p^q);

theorem :: FINSEQ_1:44
  rng(p^q) = rng p \/ rng q;

theorem :: FINSEQ_1:45
  p^q^r = p^(q^r);

theorem :: FINSEQ_1:46
  p^r = q^r or r^p = r^q implies p = q;

theorem :: FINSEQ_1:47
  p^{} = p & {}^p = p;

theorem :: FINSEQ_1:48
  p^q = {} implies p={} & q={};

definition
  let D be set;
  let p,q be FinSequence of D;
  redefine func p^q -> FinSequence of D;
end;

definition
  let x;
  redefine func <*x*> -> Function means
:: FINSEQ_1:def 8

  dom it = Seg 1 & it.1 = x;
end;

registration
  let x;
  cluster <*x*> -> Function-like Relation-like;
end;

registration
  let x;
  cluster <*x*> -> FinSequence-like;
end;

canceled;

theorem :: FINSEQ_1:50
  p^q is FinSequence of D implies
  p is FinSequence of D & q is FinSequence of D;

definition
  let x,y;
  func <*x,y*> -> set equals
:: FINSEQ_1:def 9

  <*x*>^<*y*>;
  let z;
  func <*x,y,z*> -> set equals
:: FINSEQ_1:def 10

  <*x*>^<*y*>^<*z*>;
end;

registration
  let x,y;
  cluster <*x,y*> -> Function-like Relation-like;
  let z;
  cluster <*x,y,z*> -> Function-like Relation-like;
end;

registration
  let x,y;
  cluster <*x,y*> -> FinSequence-like;
  let z;
  cluster <*x,y,z*> -> FinSequence-like;
end;

canceled;

theorem :: FINSEQ_1:52
  <*x*> = { [1,x] };

canceled 2;

theorem :: FINSEQ_1:55
  p=<*x*> iff dom p = Seg 1 & rng p = {x};

theorem :: FINSEQ_1:56
  p=<*x*> iff len p = 1 & rng p = {x};

theorem :: FINSEQ_1:57
  p = <*x*> iff len p = 1 & p.1 = x;

theorem :: FINSEQ_1:58
  (<*x*>^p).1 = x;

theorem :: FINSEQ_1:59
  (p^<*x*>).(len p + 1)=x;

theorem :: FINSEQ_1:60
  <*x,y,z*>=<*x*>^<*y,z*> & <*x,y,z*>=<*x,y*>^<*z*>;

theorem :: FINSEQ_1:61
  p = <*x,y*> iff len p = 2 & p.1=x & p.2=y;

theorem :: FINSEQ_1:62
  p = <*x,y,z*> iff len p = 3 & p.1 = x & p.2 = y & p.3 = z;

theorem :: FINSEQ_1:63
  p <> {} implies ex q,x st p=q^<*x*>;

definition
  let D be non empty set;
  let x be Element of D;
  redefine func <*x*> -> FinSequence of D;
end;

:: scheme of induction for finite sequences ::

scheme :: FINSEQ_1:sch 3
 IndSeq{P[FinSequence]}: for p holds P[p]
provided
 P[{}]
and
 for p,x st P[p] holds P[p^<*x*>];

theorem :: FINSEQ_1:64
  for p,q,r,s being FinSequence st p^q = r^s & len p <= len r
  ex t being FinSequence st p^t = r;

definition
  let D be set;
  func D* -> set means
:: FINSEQ_1:def 11

  x in it iff x is FinSequence of D;
end;

registration
  let D be set;
  cluster D* -> non empty;
end;

theorem :: FINSEQ_1:65
  rng p = rng q & p is one-to-one & q is one-to-one implies len p = len q;

theorem :: FINSEQ_1:66
  {} in D*;

scheme :: FINSEQ_1:sch 4
 SepSeq{D()->non empty set, P[FinSequence]}:
  ex X st (for x holds x in X iff ex p st (p in D()* & P[p] & x=p));

::                           ::
::        Subsequences       ::
::                           ::

definition
  let IT be Function;
  attr IT is FinSubsequence-like means
:: FINSEQ_1:def 12

  ex k st dom IT c= Seg k;
end;

registration
  cluster FinSubsequence-like Function;
end;

definition
  mode FinSubsequence is FinSubsequence-like Function;
end;

canceled;

theorem :: FINSEQ_1:68
  for p being FinSequence holds p is FinSubsequence;

theorem :: FINSEQ_1:69
  p|X is FinSubsequence & X|p is FinSubsequence;

reserve p' for FinSubsequence;

definition
  let X;
  given k being Nat such that
 X c= Seg k;
  func Sgm X -> FinSequence of NAT means
:: FINSEQ_1:def 13

  rng it = X & for l,m,k1,k2 being Nat st ( 1 <= l & l < m & m <= len it &
  k1=it.l & k2=it.m) holds k1 < k2;
end;

canceled;

theorem :: FINSEQ_1:71
  rng Sgm dom p' = dom p';

definition
  let p';
  func Seq p' -> Function equals
:: FINSEQ_1:def 14

  p'* Sgm(dom p');
end;

registration
  let p';
  cluster Seq p' -> FinSequence-like;
end;

theorem :: FINSEQ_1:72
  for X st ex k st X c= Seg k holds Sgm X = {} iff X = {};

begin :: from FINSET_1, 1998

theorem :: FINSEQ_1:73 :: FINSET_1:def 1
  D is finite iff ex p st D = rng p;

begin :: Moved from CARD_1, 1999

theorem :: FINSEQ_1:74
  Seg n,Seg m are_equipotent implies n = m;

theorem :: FINSEQ_1:75
  Seg n,n are_equipotent;

theorem :: FINSEQ_1:76
  card Seg n = card n;

theorem :: FINSEQ_1:77
  X is finite implies ex n st X,Seg n are_equipotent;

theorem :: FINSEQ_1:78
  for n being Nat holds card Seg n = n;

begin :: Addenda

:: from FINSEQ_5

registration
  let x be set;
  cluster <*x*> -> non empty;
end;

:: From SPRECT_1

registration
  cluster non empty FinSequence;
end;

:: From FUNCT_7, actually from GOBOARD4

registration
  let f1 be FinSequence, f2 be non empty FinSequence;
  cluster f1^f2 -> non empty;
  cluster f2^f1 -> non empty;
end;

:: from MATRIX_2

scheme :: FINSEQ_1:sch 5
 SeqDEx{D()->non empty set,A()->Nat,P[set,set]}:
  ex p being FinSequence of D() st dom p = Seg A() &
  for k st k in Seg A() holds P[k,p.k]
provided
 for k st k in Seg A() ex x being Element of D() st P[k,x];

:: from TOPREAL1

reserve D for set,
  p for FinSequence of D,
  m for Nat;

definition
  let p be FinSequence;
  let m;
  func p|m -> FinSequence equals
:: FINSEQ_1:def 15

  p|Seg m;
end;

definition
  let D,p,m;
  redefine func p|m -> FinSequence of D;
end;

registration
  let f be FinSequence;
  cluster f|0 -> empty;
end;

theorem :: FINSEQ_1:79
  len q <= i implies q|i = q;

theorem :: FINSEQ_1:80
  i <= len q implies len(q|i) = i;

:: from FSM_1

theorem :: FINSEQ_1:81
  i in Seg n implies i+m in Seg (n+m);

theorem :: FINSEQ_1:82
  i>0 & i+m in Seg (n+m) implies i in Seg n & i in Seg (n+m);

:: from LANG1

definition
  let R be Relation;
  func R[*] -> Relation means
:: FINSEQ_1:def 16
  for x,y being set holds [x,y] in it iff x in field R & y in field R &
  ex p being FinSequence st len p >= 1 & p.1 = x & p.(len p) = y &
  for i being Nat st i >= 1 & i < len p holds [p.i,p.(i+1)] in R;
end;

theorem :: FINSEQ_1:83
  for D1,D2 being set st D1 c= D2 holds D1* c= D2*;

:: 2005.05.13, A.T.

registration
  let D be set;
  cluster D* -> functional;
end;

:: from SCMFSA_7, 2005.11.21, A.T.

theorem :: FINSEQ_1:84
  for p,q being FinSequence st p c= q holds len p <= len q;

theorem :: FINSEQ_1:85
  for p,q being FinSequence, i being Nat st
  1 <= i & i <= len p holds (p ^ q).i = p.i;

theorem :: FINSEQ_1:86
  for p,q being FinSequence, i being Nat st
  1 <= i & i <= len q holds (p ^ q).(len p + i) = q.i;

:: from GRAPH_2, 2006.01.09, A.T.

reserve i,j for Nat;

scheme :: FINSEQ_1:sch 6
 FinSegRng{m, n() -> Nat, F(set)->set, P[set]}:
  {F(i) where i is Element of NAT: m()<=i & i<=n() & P[i]} is finite;

theorem :: FINSEQ_1:87
  for x1, x2, x3, x4 being set, p being FinSequence
  st p = <*x1*>^<*x2*>^<*x3*>^<*x4*>
  holds len p = 4 & p.1 = x1 & p.2 = x2 & p.3 = x3 & p.4 = x4;

theorem :: FINSEQ_1:88
  for x1, x2, x3, x4, x5 being set, p being FinSequence
  st p = <*x1*>^<*x2*>^<*x3*>^<*x4*>^<*x5*>
  holds len p = 5 & p.1 = x1 & p.2 = x2 & p.3 = x3 & p.4 = x4 & p.5 = x5;

theorem :: FINSEQ_1:89
  for x1, x2, x3, x4, x5, x6 being set, p being FinSequence
  st p = <*x1*>^<*x2*>^<*x3*>^<*x4*>^<*x5*>^<*x6*>
  holds len p = 6 & p.1 = x1 & p.2 = x2 & p.3 = x3 & p.4 = x4 & p.5 = x5 &
  p.6 = x6;

theorem :: FINSEQ_1:90
  for x1, x2, x3, x4, x5, x6, x7 being set, p being FinSequence
  st p = <*x1*>^<*x2*>^<*x3*>^<*x4*>^<*x5*>^<*x6*>^<*x7*>
  holds len p = 7 & p.1 = x1 & p.2 = x2 & p.3 = x3 & p.4 = x4 & p.5 = x5 &
  p.6 = x6 & p.7 = x7;

theorem :: FINSEQ_1:91
  for x1,x2,x3,x4, x5, x6, x7, x8 being set, p being FinSequence
  st p = <*x1*>^<*x2*>^<*x3*>^<*x4*>^<*x5*>^<*x6*>^<*x7*>^<*x8*>
  holds len p = 8 & p.1 = x1 & p.2 = x2 & p.3 = x3 & p.4 = x4 & p.5 = x5 &
  p.6 = x6 & p.7 = x7 & p.8 = x8;

theorem :: FINSEQ_1:92
  for x1,x2,x3,x4,x5,x6,x7, x8, x9 being set, p being FinSequence
  st p = <*x1*>^<*x2*>^<*x3*>^<*x4*>^<*x5*>^<*x6*>^<*x7*>^<*x8*>^<*x9*>
  holds len p = 9 & p.1 = x1 & p.2 = x2 & p.3 = x3 & p.4 = x4 & p.5 = x5 &
  p.6 = x6 & p.7 = x7 & p.8 = x8 & p.9 = x9;

:: from SCMFSA_7, 2006.03.14, A.T.

theorem :: FINSEQ_1:93
  for p being FinSequence holds p | Seg 0 = {};

theorem :: FINSEQ_1:94
  for f,g being FinSequence holds f | Seg 0 = g | Seg 0;

theorem :: FINSEQ_1:95
  for D being non empty set, x being Element of D holds
  <* x *> is FinSequence of D;

theorem :: FINSEQ_1:96
  for D being set, p,q being FinSequence of D holds p ^ q is FinSequence of D;

:: from GROUP_7, 2007.02.10, AK

reserve a, b, c, d, e, f for set;

theorem :: FINSEQ_1:97
  <*a*> = <*b*> implies a = b;

theorem :: FINSEQ_1:98
  <*a,b*> = <*c,d*> implies a = c & b = d;

theorem :: FINSEQ_1:99
  <*a,b,c*> = <*d,e,f*> implies a = d & b = e & c = f;

:: from PRVECT_1, 2007.03.09, A.T

registration
  cluster non empty non-empty FinSequence;
end;

theorem :: FINSEQ_1:100
  for p,q being FinSequence st q = p|Seg n holds len q <= len p;

theorem :: FINSEQ_1:101
  for p,r being FinSequence st r = p|Seg n ex q being FinSequence st p = r^q;

:: from GOBOARD1, PRALG_1, 2007.04.06, A.T

registration
  let D be non empty set;
  cluster non empty FinSequence of D;
end;

:: Added by AK, 2007.11.07

definition
  let p,q be FinSequence;
  redefine pred p = q means
:: FINSEQ_1:def 17
  len p = len q & for k st 1 <= k & k <= len p holds p.k = q.k;
end;

:: from MATRIX_1, 2007.07.22, A.T generalized

theorem :: FINSEQ_1:102
  for M1, M2 being set st card M1 = 0 & card M2 = 0 holds M1 = M2;

:: 2008.08.31, A.K.

registration
  cluster Seg 0 -> empty;
end;

:: from CHAIN_1, 2008.08.31, A.K.

registration
  let n be non zero Nat;
  cluster Seg n -> non empty;
end;

:: from GROEB_2, 2008.10.08, A.T.

theorem :: FINSEQ_1:103
  for p being FinSequence, n,m being Nat st m <= n
   holds p|n|m = p|m;

:: from CARD_5, 2008.10.08, A.T.

reserve m for Element of NAT;

theorem :: FINSEQ_1:104
  Seg n = (n+1) \ {0};

:: new, 2009.01.26, A.T.

definition let n be Nat, f be FinSequence;
 attr f is n-long means
:: FINSEQ_1:def 18
 len f = n;
end;

:: from CIRCCOMB, 2009.03.27, A.T.

registration let n be Nat;
 cluster n-long FinSequence;
end;

:: from FACIRC_1, 2009.02.16, A.T.

registration
 let x be set;
 cluster <*x*> -> 1-long;
 let y be set;
 cluster <*x,y*> -> 2-long;
 let z be set;
 cluster <*x,y,z*> -> 3-long;
end;

registration
 cluster 0-long -> empty FinSequence;
 cluster empty -> 0-long FinSequence;
end;
