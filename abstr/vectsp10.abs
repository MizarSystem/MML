:: Quotient Vector Spaces and Functionals
::  by Jaros{\l}aw Kotowicz
::
:: Received November 5, 2002
:: Copyright (c) 2002 Association of Mizar Users

environ

 vocabulary RLVECT_1, VECTSP_1, ARYTM_1, HAHNBAN, FUNCT_1, GRCAT_1, UNIALG_1,
      BINOP_1, LATTICES, RELAT_1, HAHNBAN1, MCART_1, RLSUB_1, RLSUB_2,
      RLVECT_3, RLVECT_2, FUNCT_2, ALGSTR_2, REALSET1, BOOLE, SEQM_3, GROUP_6,
      SETFAM_1, ARYTM_3, VECTSP10;
 notation TARSKI, XBOOLE_0, ZFMISC_1, SUBSET_1, DOMAIN_1, STRUCT_0, FUNCT_1,
      REALSET1, RLVECT_1, BINOP_1, RLVECT_2, VECTSP_1, RELSET_1, FUNCT_2,
      SEQM_3, FRAENKEL, VECTSP_4, VECTSP_5, VECTSP_6, VECTSP_7, HAHNBAN1;
 constructors DOMAIN_1, REALSET1, BINOP_1, RLVECT_2, VECTSP_5, VECTSP_6,
      VECTSP_7, SEQM_3, HAHNBAN1;
 clusters STRUCT_0, SUBSET_1, FUNCT_1, RELSET_1, VECTSP_1, HAHNBAN1, VECTSP_4,
      XBOOLE_0;
 requirements SUBSET, BOOLE;


begin
::Auxiliary Facts about Double Loops and Vector Spaces

theorem :: VECTSP10:1
  for K be add-associative right_zeroed right_complementable
            left-distributive left_unital (non empty doubleLoopStr)
for a be Element of K holds (- 1_ K) * a = - a;

definition
 let K be doubleLoopStr;
func StructVectSp(K) -> strict VectSpStr over K equals
:: VECTSP10:def 1
 VectSpStr (# the carrier of K, the add of K, the Zero of K, the mult of K#);
end;

registration
 let K be non empty doubleLoopStr;
cluster StructVectSp(K) -> non empty;
 coherence
  proof
     the carrier of StructVectSp(K) = the carrier of K by Lm1;
   hence thesis by STRUCT_0:def 1;
  end;
end;


registration
 let K be Abelian (non empty doubleLoopStr);
cluster StructVectSp(K) -> Abelian;
 coherence
  proof
   set V = StructVectSp(K);
      now
    let x,y be Vector of V;
     reconsider x'=x,y'=y as Element of K by Lm1;
  A1: the add of V = the add of K by Lm1;
     thus x+y = (the add of V).(x,y) by RLVECT_1:5
       .= y'+x' by A1,RLVECT_1:5
       .= (the add of K).(y',x') by RLVECT_1:5
       .= y+x by A1,RLVECT_1:5;
     end;
    hence thesis by RLVECT_1:def 5;
  end;
end;


registration
 let K be add-associative (non empty doubleLoopStr);
cluster StructVectSp(K) -> add-associative;
 coherence
  proof
    set V = StructVectSp(K);
       now
     let x,y,z be Vector of V;
      reconsider x'=x,y'=y,z'=z as Element of K by Lm1;
    A1: the add of V = the add of K by Lm1;
      thus (x+y)+z = (the add of V).(x+y,z) by RLVECT_1:5
       .= (the add of V).((the add of V).(x,y),z) by RLVECT_1:5
       .= (the add of K).((x'+y'),z') by A1,RLVECT_1:5
       .= (x'+y')+z' by RLVECT_1:5
       .= x'+(y'+z') by RLVECT_1:def 6
       .= (the add of V).(x',(y'+z')) by A1,RLVECT_1:5
       .= (the add of V).(x',(the add of V).(y',z')) by A1,RLVECT_1:5
       .= (the add of V).(x,y+z) by RLVECT_1:5
       .= x+(y+z) by RLVECT_1:5;
      end;
  hence thesis by RLVECT_1:def 6;
 end;
end;


registration
 let K be right_zeroed (non empty doubleLoopStr);
cluster StructVectSp(K) -> right_zeroed;
 coherence
   proof
    set V = StructVectSp(K);
       now let x be Vector of V;
      reconsider x'=x as Element of K by Lm1;
    A1: the add of V = the add of K &
        the Zero of V = the Zero of K by Lm1;
    then A2: (the Zero of K) = 0.V & (the Zero of K) = 0.K by RLVECT_1:def 2;
      thus x+0.V = (the add of V).(x,0.V) by RLVECT_1:5
         .= x'+(0.K) by A1,A2,RLVECT_1:5
        .= x by RLVECT_1:def 7;
     end;
    hence thesis by RLVECT_1:def 7;
 end;
end;


registration
 let K be right_complementable (non empty doubleLoopStr);
cluster StructVectSp(K) -> right_complementable;
 coherence
   proof
    set V = StructVectSp(K);
       now let x be Vector of V;
      reconsider x'=x as Element of K by Lm1;
   A1: the add of V = the add of K &
       the Zero of V = the Zero of K by Lm1;
   then A2: (the Zero of K) = 0.V & (the Zero of K) = 0.K by RLVECT_1:def 2;
      consider t be Element of K such that
   A3: x' + t = 0.K by RLVECT_1:def 8;
      reconsider t' = t as Vector of V by Lm1;
      take t';
      thus x + t' = (the add of V).(x,t') by RLVECT_1:5
       .= 0.V by A1,A2,A3,RLVECT_1:5;
     end;
    hence thesis by RLVECT_1:def 8;
  end;
end;


registration
 let K be associative left_unital distributive (non empty doubleLoopStr);
cluster StructVectSp(K) -> VectSp-like;
 coherence
  proof
   set V = StructVectSp(K);
      now
    let x,y be Element of K;
    let v,w be Vector of V;
     reconsider v' = v , w' = w as Element of K by Lm1;
   A1: (the lmult of V).(x,w) = x*w by VECTSP_1:def 24;
   A2: (the lmult of V).(y,v) = y*v by VECTSP_1:def 24;
   A3: the add of V = the add of K &
       the lmult of V = the mult of K by Lm1;
     set MLT = the mult of K;
     thus x*(v+w) = (the lmult of V).(x,(v+w)) by VECTSP_1:def 24
       .= MLT.(x,(the add of K).(v',w')) by A3,RLVECT_1:5
       .= MLT.(x,v'+w') by RLVECT_1:5
       .= x*(v'+w') by VECTSP_1:def 10
       .= x*v'+x*w' by VECTSP_1:def 18
       .= (the add of K).(x*v',x*w') by RLVECT_1:5
       .= (the add of K).(MLT.(x,v'),x*w') by VECTSP_1:def 10
       .= (the add of K).
          ((the lmult of V).(x,v),(the lmult of V).(x,w)) by A3,VECTSP_1:def 10
       .= (the add of K).(x*v,x*w) by A1,VECTSP_1:def 24
       .= x*v+x*w by A3,RLVECT_1:5;
     thus (x+y)*v = (the lmult of V).((x+y),v) by VECTSP_1:def 24
       .= (x+y)*v' by A3,VECTSP_1:def 10
       .= x*v'+y*v' by VECTSP_1:def 18
       .= (the add of K).(x*v',y*v') by RLVECT_1:5
       .= (the add of K).(MLT.(x,v'),y*v') by VECTSP_1:def 10
       .= (the add of K).
          ((the lmult of V).(x,v),(the lmult of V).(y,v)) by A3,VECTSP_1:def 10
       .= (the add of K).(x*v,y*v) by A2,VECTSP_1:def 24
       .= x*v+y*v by A3,RLVECT_1:5;
     thus (x*y)*v = (the lmult of V).((x*y),v) by VECTSP_1:def 24
       .= (x*y)*v' by A3,VECTSP_1:def 10
       .= x*(y*v') by VECTSP_1:def 16
       .= MLT.(x,y*v') by VECTSP_1:def 10
       .= (the lmult of V).(x,(the lmult of V).(y,v)) by A3,VECTSP_1:def 10
       .= (the lmult of V).(x,(y*v)) by VECTSP_1:def 24
       .= x*(y*v) by VECTSP_1:def 24;
     thus (1_ K)*v = MLT.(1_ K,v') by A3,VECTSP_1:def 24
       .= (1_ K)*v' by VECTSP_1:def 10
       .= v by VECTSP_1:def 19;
    end;
   hence thesis by VECTSP_1:def 26;
  end;
end;


registration
 let K be non degenerated (non empty doubleLoopStr);
cluster StructVectSp(K) -> non trivial;
 coherence
  proof
   set V = StructVectSp(K);
   reconsider v = 1_ K as Vector of V by Lm1;
     the Zero of V = the Zero of K by Lm1;
   then the Zero of K = 0.V & (the Zero of K) = 0.K by RLVECT_1:def 2;
   then v <> 0.V by VECTSP_1:def 21;
   hence V is non trivial by ANPROJ_1:def 8;
  end;
end;


registration
 let K be non degenerated (non empty doubleLoopStr);
cluster non trivial (non empty VectSpStr over K);
 existence
  proof take StructVectSp(K); thus thesis; end;
end;


registration
 let K be add-associative right_zeroed right_complementable
         (non empty doubleLoopStr);
cluster add-associative right_zeroed right_complementable strict
         (non empty VectSpStr over K);
correctness
 proof take StructVectSp(K); thus thesis; end;
end;


registration
 let K be add-associative right_zeroed right_complementable associative
          left_unital distributive (non empty doubleLoopStr);
cluster add-associative right_zeroed right_complementable VectSp-like strict
        (non empty VectSpStr over K);
 correctness
  proof take StructVectSp(K); thus thesis; end;
end;


registration
 let K be Abelian add-associative right_zeroed right_complementable associative
          left_unital distributive non degenerated (non empty doubleLoopStr);
cluster Abelian add-associative right_zeroed right_complementable VectSp-like
         strict non trivial (non empty VectSpStr over K);
 existence
  proof take StructVectSp(K); thus thesis; end;
end;


theorem :: VECTSP10:2
for K be add-associative right_zeroed right_complementable associative
         left_unital distributive (non empty doubleLoopStr),
    a be Element of K
for V be add-associative right_zeroed right_complementable VectSp-like
        (non empty VectSpStr over K),
     v be Vector of V holds (0.K)*v = 0.V & a*(0.V) = 0.V;

theorem :: VECTSP10:3
  for K be add-associative right_zeroed right_complementable
      Abelian associative left_unital distributive (non empty doubleLoopStr)
for V be VectSp of K
for S, T be Subspace of V, v be Vector of V st
 S /\ T = (0).V & v in S & v in T holds v = 0.V;

theorem :: VECTSP10:4
for K be Field, V be VectSp of K
for x be set, v be Vector of V holds
x in Lin{v} iff ex a be Element of K st x =a*v;

theorem :: VECTSP10:5
for K be Field, V be VectSp of K, v be Vector of V, a,b be Scalar of V
 st v <> 0.V & a * v = b * v holds a = b;

theorem :: VECTSP10:6
for K be add-associative right_zeroed right_complementable associative
          Abelian left_unital distributive (non empty doubleLoopStr)
for V be VectSp of K
for W1,W2 be Subspace of V st V is_the_direct_sum_of W1,W2
for v,v1,v2 be Vector of V st v1 in W1 & v2 in W2 & v = v1 + v2
  holds v |-- (W1,W2) = [v1,v2];

theorem :: VECTSP10:7
for K be add-associative right_zeroed right_complementable associative
          Abelian left_unital distributive (non empty doubleLoopStr)
for V be VectSp of K
for W1,W2 be Subspace of V st V is_the_direct_sum_of W1,W2
for v,v1,v2 be Vector of V st v |-- (W1,W2) = [v1,v2] holds v = v1 + v2;

theorem :: VECTSP10:8
for K be add-associative right_zeroed right_complementable associative
          Abelian left_unital distributive (non empty doubleLoopStr)
for V be VectSp of K
for W1,W2 be Subspace of V st V is_the_direct_sum_of W1,W2
for v,v1,v2 be Vector of V st v |-- (W1,W2) = [v1,v2]
 holds v1 in W1 & v2 in W2;

theorem :: VECTSP10:9
for K be add-associative right_zeroed right_complementable associative
          Abelian left_unital distributive (non empty doubleLoopStr)
for V be VectSp of K
for W1,W2 be Subspace of V st V is_the_direct_sum_of W1,W2
for v,v1,v2 be Vector of V st v |-- (W1,W2) = [v1,v2]
  holds v |-- (W2,W1) = [v2,v1];

theorem :: VECTSP10:10
for K be add-associative right_zeroed right_complementable associative
          Abelian left_unital distributive (non empty doubleLoopStr)
for V be VectSp of K
for W1,W2 be Subspace of V st V is_the_direct_sum_of W1,W2
for v be Vector of V st v in W1 holds v |-- (W1,W2) = [v,0.V];

theorem :: VECTSP10:11
for K be add-associative right_zeroed right_complementable associative
          Abelian left_unital distributive (non empty doubleLoopStr)
for V be VectSp of K
for W1,W2 be Subspace of V st V is_the_direct_sum_of W1,W2
 for v be Vector of V st v in W2 holds v |-- (W1,W2) = [0.V,v];

theorem :: VECTSP10:12
for K be add-associative right_zeroed right_complementable associative
          Abelian left_unital distributive (non empty doubleLoopStr)
for V be VectSp of K
for V1 be Subspace of V, W1 be Subspace of V1,
  v be Vector of V st v in W1 holds v is Vector of V1;

theorem :: VECTSP10:13
for K be add-associative right_zeroed right_complementable associative
          Abelian left_unital distributive (non empty doubleLoopStr)
for V be VectSp of K
for V1,V2,W be Subspace of V, W1,W2 be Subspace of W
  st W1 = V1 & W2 = V2 holds W1 + W2 = V1 + V2;

theorem :: VECTSP10:14
for K be Field, V be VectSp of K, W be Subspace of V
for v be Vector of V, w be Vector of W st v = w holds Lin{w} = Lin{v};

theorem :: VECTSP10:15
for K be Field, V be VectSp of K
for v be Vector of V, X be Subspace of V st not v in X
for y be Vector of X + Lin{v}, W be Subspace of X + Lin{v}
  st v = y & W = X
 holds X + Lin{v} is_the_direct_sum_of W,Lin{y};

theorem :: VECTSP10:16
for K be Field, V be VectSp of K, v be Vector of V, X be Subspace of V,
  y be Vector of X + Lin{v}, W be Subspace of X + Lin{v}
 st v = y & X = W & not v in X holds y |-- (W,Lin{y}) = [0.W,y];

theorem :: VECTSP10:17
for K be Field, V be VectSp of K, v be Vector of V, X be Subspace of V
for y be Vector of X + Lin{v}, W be Subspace of X + Lin{v}
 st v = y & X = W & not v in X
for w be Vector of X + Lin{v} st w in X holds w |-- (W,Lin{y}) = [w,0.V];

theorem :: VECTSP10:18
for K be add-associative right_zeroed right_complementable associative
          Abelian left_unital distributive (non empty doubleLoopStr),
  V be VectSp of K
for v be Vector of V, W1,W2 be Subspace of V
 ex v1,v2 be Vector of V st v |-- (W1,W2) = [v1,v2];

theorem :: VECTSP10:19
for K be Field, V be VectSp of K
 for v be Vector of V, X be Subspace of V,
   y be Vector of X + Lin{v}, W be Subspace of X + Lin{v}
   st v = y & X = W & not v in X
for w be Vector of X + Lin{v}
 ex x be Vector of X,
   r be Element of K st w |-- (W,Lin{y}) = [x,r*v];

theorem :: VECTSP10:20
for K be Field, V be VectSp of K
for v be Vector of V, X be Subspace of V,
   y be Vector of X + Lin{v}, W be Subspace of X + Lin{v}
   st v = y & X = W & not v in X
 for w1,w2 be Vector of X + Lin{v}, x1,x2 be Vector of X,
     r1,r2 be Element of K
  st w1 |-- (W,Lin{y}) = [x1,r1*v] & w2 |-- (W,Lin{y}) = [x2,r2*v]
  holds w1 + w2 |-- (W,Lin{y}) = [x1 + x2, (r1+r2)*v];

theorem :: VECTSP10:21
for K be Field, V be VectSp of K
for v be Vector of V, X be Subspace of V,
   y be Vector of X + Lin{v}, W be Subspace of X + Lin{v}
   st v = y & X = W & not v in X
 for w be Vector of X + Lin{v}, x be Vector of X,
  t,r be Element of K
  st w |-- (W,Lin{y}) = [x,r*v]
  holds t*w |-- (W,Lin{y}) = [t*x, t*r*v];

begin
:: Quotient Vector Space for non commutative Double Loop

definition
 let K be add-associative right_zeroed right_complementable
    Abelian associative left_unital distributive (non empty doubleLoopStr);
 let V be VectSp of K;
 let W be Subspace of V;
func CosetSet(V,W) ->non empty Subset-Family of V equals
:: VECTSP10:def 2
 {A where A is Coset of W: not contradiction};
end;


definition
 let K be add-associative right_zeroed right_complementable
    Abelian associative left_unital distributive (non empty doubleLoopStr);
 let V be VectSp of K;
 let W be Subspace of V;
func addCoset(V,W) -> BinOp of CosetSet(V,W) means
:: VECTSP10:def 3
 for A,B be Element of CosetSet(V,W)
  for a,b be Vector of V st A = a + W & B = b + W holds it.(A,B) = (a+b)+W;
end;


definition
 let K be add-associative right_zeroed right_complementable
    Abelian associative left_unital distributive (non empty doubleLoopStr);
 let V be VectSp of K;
 let W be Subspace of V;
func zeroCoset(V,W) -> Element of CosetSet(V,W) equals
:: VECTSP10:def 4
 the carrier of W;
end;


definition
 let K be add-associative right_zeroed right_complementable
    Abelian associative left_unital distributive (non empty doubleLoopStr);
 let V be VectSp of K;
 let W be Subspace of V;
func lmultCoset(V,W) -> Function of [:the carrier of K, CosetSet(V,W):],
                                    CosetSet(V,W) means
:: VECTSP10:def 5
 for z be Element of K, A be Element of CosetSet(V,W)
 for a be Vector of V st A = a+W holds it.(z,A) = z*a +W;
end;


definition
 let K be add-associative right_zeroed right_complementable
    Abelian associative left_unital distributive (non empty doubleLoopStr);
 let V be VectSp of K;
 let W be Subspace of V;
func VectQuot(V,W) -> strict Abelian add-associative right_zeroed
    right_complementable VectSp-like (non empty VectSpStr over K) means
:: VECTSP10:def 6
  the carrier of it = CosetSet(V,W) &
  the add of it = addCoset(V,W) &
  the Zero of it = zeroCoset(V,W) &
  the lmult of it = lmultCoset(V,W);
end;


theorem :: VECTSP10:22
for K be add-associative right_zeroed right_complementable
    Abelian associative left_unital distributive (non empty doubleLoopStr),
  V be VectSp of K, W be Subspace of V holds
zeroCoset(V,W) = 0.V + W & 0.(VectQuot(V,W)) = zeroCoset(V,W);

theorem :: VECTSP10:23
for K be add-associative right_zeroed right_complementable
    Abelian associative left_unital distributive (non empty doubleLoopStr)
for V be VectSp of K, W be Subspace of V, w be Vector of VectQuot(V,W)
holds w is Coset of W & ex v be Vector of V st w = v + W;

theorem :: VECTSP10:24
for K be add-associative right_zeroed right_complementable
    Abelian associative left_unital distributive (non empty doubleLoopStr)
for V be VectSp of K, W be Subspace of V, v be Vector of V
holds v+W is Coset of W & v+W is Vector of VectQuot(V,W);

theorem :: VECTSP10:25
  for K be add-associative right_zeroed right_complementable
    Abelian associative left_unital distributive (non empty doubleLoopStr)
for V be VectSp of K, W be Subspace of V, A be Coset of W
holds A is Vector of VectQuot(V,W);

theorem :: VECTSP10:26
  for K be add-associative right_zeroed right_complementable
    Abelian associative left_unital distributive (non empty doubleLoopStr),
 V be VectSp of K, W be Subspace of V
for A be Vector of VectQuot(V,W), v be Vector of V, a be Scalar of V
st A = v + W holds a*A = a*v + W;

theorem :: VECTSP10:27
  for K be add-associative right_zeroed right_complementable
    Abelian associative left_unital distributive (non empty doubleLoopStr),
 V be VectSp of K, W be Subspace of V
for A1,A2 be Vector of VectQuot(V,W), v1,v2 be Vector of V
st A1 = v1 + W & A2 = v2 + W holds A1 + A2 = v1 + v2 + W;

begin
:: Auxiliary Facts about Functionals

theorem :: VECTSP10:28
for K be Field, V be VectSp of K
 for X be Subspace of V, fi be linear-Functional of X,
     v be Vector of V,
     y be Vector of X + Lin {v} st v = y & not v in X
   for r be Element of K
    ex psi be linear-Functional of X + Lin{v} st
       psi|the carrier of X=fi & psi.y = r;

registration
 let K be right_zeroed (non empty LoopStr);
 let V be non empty VectSpStr over K;
cluster additive 0-preserving Functional of V;
 existence
  proof take 0Functional(V); thus thesis; end;
end;


registration
 let K be add-associative right_zeroed right_complementable
      (non empty doubleLoopStr);
 let V be right_zeroed (non empty VectSpStr over K);
cluster additive -> 0-preserving Functional of V;
 coherence
  proof
  let f be Functional of V;
   assume
  A1: f is additive;
     f.(0.V) = f.(0.V+0.V) by RLVECT_1:def 7
   .= f.(0.V) + f.(0.V) by A1,HAHNBAN1:def 11;
   hence f.(0.V) = 0.K by RLVECT_1:22;
  end;
end;


registration
 let K be add-associative right_zeroed right_complementable associative
          left_unital distributive (non empty doubleLoopStr);
 let V be add-associative right_zeroed right_complementable VectSp-like
          (non empty VectSpStr over K);
cluster homogeneous -> 0-preserving Functional of V;
 coherence
  proof
   let f be Functional of V;
   assume A1: f is homogeneous;
   thus f.(0.V) = f.(0.K * 0.V) by Th2
   .= 0.K * f.(0.V) by A1,HAHNBAN1:def 12
   .= 0.K by VECTSP_1:39;
  end;
end;


registration
 let K be non empty ZeroStr;
 let V be non empty VectSpStr over K;
cluster 0Functional(V) -> constant;
 coherence
  proof
   set f = 0Functional(V);
   let x,y be set; assume
     x in dom f & y in dom f;
   then reconsider v=x, w=y as Vector of V;
   thus f.x = f.v
   .= 0.K by HAHNBAN1:22
   .= f.w by HAHNBAN1:22
   .= f.y;
  end;
end;


registration
 let K be non empty ZeroStr;
 let V be non empty VectSpStr over K;
cluster constant Functional of V;
 existence
  proof take 0Functional(V); thus thesis; end;
end;


definition
 let K be add-associative right_zeroed right_complementable
         (non empty doubleLoopStr);
 let V be right_zeroed (non empty VectSpStr over K);
 let f be 0-preserving Functional of V;
redefine attr f is constant means
:: VECTSP10:def 7
 f = 0Functional(V);
end;


registration
 let K be add-associative right_zeroed right_complementable
          (non empty doubleLoopStr);
 let V be right_zeroed (non empty VectSpStr over K);
cluster constant additive 0-preserving Functional of V;
 existence
  proof take 0Functional(V); thus thesis; end;
end;


registration
 let K be non empty 1-sorted;
 let V be non empty VectSpStr over K;
cluster non constant -> non trivial Functional of V;
coherence
 proof
  let f be Functional of V;
  assume f is non constant;
  then consider n1,n2 be set such that
 A1:  n1 in dom f & n2 in dom f and
 A2:  f.n1 <> f.n2 by SEQM_3:def 5;
 A3:  [n1,f.n1] in f & [n2,f.n2] in f by A1,FUNCT_1:8;
 assume A4: f is trivial;
  per cases by A4,REALSET1:def 12;
   suppose f = {};
    hence contradiction by A3;
   end;
   suppose ex x be set st f = {x};
    then consider x be set such that
   A5: f={x};
      [n1,f.n1] = x & x=[n2,f.n2] by A3,A5,TARSKI:def 1;
    hence contradiction by A2,ZFMISC_1:33;
  end;
  end;
end;


registration
 let K be Field;
 let V be non trivial VectSp of K;
cluster additive homogeneous non constant non trivial Functional of V;
existence
 proof
  consider v be Vector of V such that
A1: v <> 0.V by ANPROJ_1:def 8;
  consider W be Linear_Compl of Lin{v};
    V is_the_direct_sum_of W, Lin{v} by VECTSP_5:def 5;

then A2: the VectSpStr of V = W + Lin{v} & W /\ Lin{v} = (0).V
                by VECTSP_5:def 4;
  then reconsider y = v as Vector of W+Lin{v};
     now assume v in W;
     then A3: v in the carrier of W by RLVECT_1:def 1;
        v in {v} by TARSKI:def 1;
      then v in Lin{v} by VECTSP_7:13;
      then v in the carrier of Lin{v} by RLVECT_1:def 1;
      then v in (the carrier of W)/\(the carrier of Lin{v}) by A3,XBOOLE_0:def
3;
      then v in the carrier of (W /\ Lin{v}) by VECTSP_5:def 2;
      then v in {0.V} by A2,VECTSP_4:def 3;
      hence contradiction by A1,TARSKI:def 1;
   end;
  then consider psi be linear-Functional of W + Lin{v} such that
A4:  psi|the carrier of W=0Functional(W) & psi.y = 1_ K by Th28;
  reconsider f = psi as Functional of V by A2;
  take f;
 thus f is additive
   proof
    let v1,v2 be Vector of V;
    reconsider w1=v1, w2 =v2 as Vector of W +Lin{v} by A2;
      v1+v2 = (the add of (W + Lin{v})).[w1,w2] by A2,RLVECT_1:def 3
     .= w1+w2 by RLVECT_1:def 3;
    hence thesis by HAHNBAN1:def 11;
   end;
thus f is homogeneous
   proof
    let v1 be Vector of V, a be Element of K;
    reconsider w1=v1 as Vector of W +Lin{v} by A2;
      a*v1 = (the lmult of (W+Lin{v})).(a,w1) by A2,VECTSP_1:def 24
     .= a*w1 by VECTSP_1:def 24;
    hence thesis by HAHNBAN1:def 12;
   end;
   then reconsider f1=f as homogeneous Functional of V;
 thus f is non constant
   proof
    assume A5: f is constant;
   A6:  1_ K <> 0.K by VECTSP_1:def 21;
   A7: the carrier of V = dom f by FUNCT_2:def 1;
      f1.(0.V)=0.K by HAHNBAN1:def 13;
    hence contradiction by A4,A5,A6,A7,SEQM_3:def 5;
   end;
 thus f is non trivial
  proof
    set x = [v,1_ K], y = [0.V, 0.K];
    assume A8: f is trivial;
   A9:  1_ K <> 0.K by VECTSP_1:def 21;
   A10: the carrier of V = dom f by FUNCT_2:def 1;
     f1.(0.V)=0.K by HAHNBAN1:def 13;
   then A11: x in f & y in f by A4,A10,FUNCT_1:8;
    per cases by A8,REALSET1:def 12;
    suppose f = {};
    hence contradiction by A4,A10,FUNCT_1:8;
    end;
    suppose ex z be set st f = {z};
    then consider z be set such that
  A12: f = {z};
      z = x & z = y by A11,A12,TARSKI:def 1;
    hence contradiction by A9,ZFMISC_1:33;
   end;
   end;
 end;
end;


registration
 let K be Field;
 let V be non trivial VectSp of K;
cluster trivial -> constant Functional of V;
 coherence
  proof let f be Functional of V such that
  A1: f is trivial;
   assume f is not constant;
   then reconsider f as non constant Functional of V;
     f is not trivial;
   hence contradiction by A1;
  end;
end;


definition
 let K be Field;
 let V be non trivial VectSp of K;
 let v be Vector of V;
 let W be Linear_Compl of Lin{v};
 assume  v <> 0.V;
func coeffFunctional(v,W) -> non constant non trivial linear-Functional of V
means
:: VECTSP10:def 8
it.v = 1_ K & it|the carrier of W = 0Functional(W);
end;


theorem :: VECTSP10:29
for K be Field, V be non trivial VectSp of K
for f be non constant 0-preserving Functional of V
ex v be Vector of V st v <> 0.V & f.v <> 0.K;

theorem :: VECTSP10:30
for K be Field, V be non trivial VectSp of K
 for v be Vector of V, a be Scalar of V
 for W be Linear_Compl of Lin{v} st v <> 0.V holds
  (coeffFunctional(v,W)).(a*v) = a;

theorem :: VECTSP10:31
for K be Field, V be non trivial VectSp of K
 for v,w be Vector of V
 for W be Linear_Compl of Lin{v} st v <> 0.V & w in W holds
  (coeffFunctional(v,W)).w = 0.K;

theorem :: VECTSP10:32
  for K be Field, V be non trivial VectSp of K
 for v,w be Vector of V, a be Scalar of V
 for W be Linear_Compl of Lin{v} st v <> 0.V & w in W holds
  (coeffFunctional(v,W)).(a*v+w) = a;

theorem :: VECTSP10:33
  for K be non empty LoopStr
for V be non empty VectSpStr over K
for f,g be Functional of V, v be Vector of V holds (f-g).v = f.v - g.v;

registration
 let K be Field;
 let V be non trivial VectSp of K;
cluster V*' -> non trivial;
 coherence
  proof
   assume A1: V*' is trivial;
   consider g be non constant linear-Functional of V;
  A2: g <> 0Functional(V);
  A3: 0.(V*') = the Zero of (V*') by RLVECT_1:def 2;
   reconsider g as Element of (V*') by HAHNBAN1:def 14;
     g = 0.(V*') by A1,ANPROJ_1:def 8;
   hence contradiction by A2,A3,HAHNBAN1:def 14;
  end;
end;


begin
:: Kernel of Additive Functional and Subspace Generated by Kernel of
::  Linear Functional. Linear Functionals in Quotient Vector Space
::  generated by Additive Functional

definition
 let K be non empty ZeroStr;
 let V be non empty VectSpStr over K;
 let f be Functional of V;
func ker f -> Subset of V equals
:: VECTSP10:def 9
   {v where v is Vector of V : f.v = 0.K};
end;


registration
 let K be right_zeroed (non empty LoopStr);
 let V be non empty VectSpStr over K;
 let f be 0-preserving Functional of V;
cluster ker f -> non empty;
  coherence
   proof
       f.(0.V) = 0.K & ker f = {v where v is Vector of V : f.v = 0.K}
      by Def9,HAHNBAN1:def 13;
     then 0.V in ker f;
     hence thesis;
    end;
end;


theorem :: VECTSP10:34
for K be add-associative right_zeroed right_complementable
    associative left_unital distributive (non empty doubleLoopStr)
for V be add-associative right_zeroed right_complementable
         VectSp-like (non empty VectSpStr over K)
for f be linear-Functional of V holds ker f is lineary-closed;

definition
 let K be non empty ZeroStr;
 let V be non empty VectSpStr over K;
 let f be Functional of V;
attr f is degenerated means
:: VECTSP10:def 10
ker f <> {0.V};
end;


registration
 let K be non degenerated (non empty doubleLoopStr);
 let V be non trivial (non empty VectSpStr over K);
cluster non degenerated 0-preserving -> non constant Functional of V;
 coherence
  proof
   let f be Functional of V; assume that
  A1: f is non degenerated and
  A2: f is 0-preserving and
  A3: f is constant;
  A4: f.(0.V) =0.K by A2,HAHNBAN1:def 13;
  A5: dom f = the carrier of V by FUNCT_2:def 1;
     now assume
    A6: for v be Vector of V st v <> 0.V holds f.v = 0.K;
       the carrier of V c= ker f
      proof
       let x be set; assume x in the carrier of V;
       then reconsider v=x as Vector of V;
       per cases;
        suppose v = 0.V;
         then x in {w where w is Vector of V: f.w=0.K} by A4;
         hence thesis by Def9;
        end;
        suppose v <> 0.V;
         then f.v = 0.K by A6;
         then x in {w where w is Vector of V: f.w=0.K};
         hence thesis by Def9;
      end;
      end;
    then the carrier of V = ker f by XBOOLE_0:def 10
    .= {0.V} by A1,Def10;
    then the carrier of V is trivial by REALSET1:def 12;
    hence contradiction by REALSET1:def 13;
   end;
  then consider v be Vector of V such that
  A7: v <> 0.V & f. v <> 0.K;
  thus contradiction by A3,A4,A5,A7,SEQM_3:def 5;
  end;
end;


definition
 let K be add-associative right_zeroed right_complementable
       Abelian associative left_unital distributive (non empty doubleLoopStr);
 let V be VectSp of K;
 let f be linear-Functional of V;
func Ker f -> strict non empty Subspace of V means
:: VECTSP10:def 11
     the carrier of it = ker f;
end;


definition
 let K be add-associative right_zeroed right_complementable
    Abelian associative left_unital distributive (non empty doubleLoopStr);
 let V be VectSp of K;
 let W be Subspace of V;
 let f be additive Functional of V;
 assume  the carrier of W c= ker f;
func
 QFunctional(f,W) -> additive Functional of VectQuot(V,W) means
:: VECTSP10:def 12
 for A be Vector of VectQuot(V,W), a be Vector of V
  st A = a+W holds it.A = f.a;
end;


theorem :: VECTSP10:35
for K be add-associative right_zeroed right_complementable
    Abelian associative left_unital distributive (non empty doubleLoopStr)
for V be VectSp of K, W be Subspace of V
for f be linear-Functional of V st the carrier of W c= ker f
 holds QFunctional(f,W) is homogeneous;

definition
 let K be add-associative right_zeroed right_complementable
    Abelian associative left_unital distributive (non empty doubleLoopStr);
 let V be VectSp of K;
 let f be linear-Functional of V;
func CQFunctional(f) -> linear-Functional of VectQuot(V,Ker f) equals
:: VECTSP10:def 13
  QFunctional(f,Ker f);
end;


theorem :: VECTSP10:36
for K be add-associative right_zeroed right_complementable
    Abelian associative left_unital distributive (non empty doubleLoopStr)
for V be VectSp of K, f be linear-Functional of V
for A be Vector of VectQuot(V,Ker f), v be Vector of V st A = v+Ker f holds
 (CQFunctional(f)).A = f.v;

registration
 let K be Field;
 let V be non trivial VectSp of K;
 let f be non constant linear-Functional of V;
cluster CQFunctional(f) -> non constant;
 coherence
 proof
   set W = Ker f, qf = CQFunctional(f), qv = VectQuot(V,W);
   assume qf is constant;
  then A1: qf = 0Functional(qv) by Def7;
   consider v be Vector of V such that
  A2: v <> 0.V & f.v <> 0.K by Th29;
   reconsider cv = v+W as Vector of qv by Th24;
     0.K = qf.cv by A1,HAHNBAN1:22
   .= f.v by Th36;
   hence contradiction by A2;
  end;
end;


registration
 let K be add-associative right_zeroed right_complementable
    Abelian associative left_unital distributive (non empty doubleLoopStr);
 let V be VectSp of K;
 let f be linear-Functional of V;
cluster CQFunctional(f) -> non degenerated;
 coherence
 proof
  set qf = CQFunctional(f), W = Ker f, qV = VectQuot(V,W);
  A1: ker qf = {w where w is Vector of qV: qf.w=0.K} by Def9;
  A2: the carrier of qV = CosetSet(V,W) by Def6;
  A3: CosetSet(V,W) = {A where A is Coset of W: not contradiction} by Def2;
  A4: qf = QFunctional(f,W) by Def13;
  A5: the carrier of W = ker f by Def11;
  A6: ker f = {w where w is Vector of V: f.w=0.K} by Def9;
  thus ker qf c= {0.qV}
   proof
    let x be set; assume
      x in ker qf;
    then consider w be Vector of qV such that
   A7: x= w & qf.w=0.K by A1;
      w in CosetSet(V,W) by A2;
    then consider A be Coset of W such that
   A8: w = A by A3;
    consider v be Vector of V such that
   A9: A = v + W by VECTSP_4:def 6;
      f.v = 0.K by A4,A5,A7,A8,A9,Def12;
    then v in ker f by A6;
    then v in W by A5,RLVECT_1:def 1;
    then v+W = the carrier of W by VECTSP_4:64;
    then w = zeroCoset(V,W) by A8,A9,Def4
    .= 0.qV by Th22;
    hence thesis by A7,TARSKI:def 1;
   end;
  thus {0.qV} c= ker qf
   proof
    let x be set; assume
      x in {0.qV};
    then A10: x = 0.qV by TARSKI:def 1;
      qf.(0.qV) = 0.K by HAHNBAN1:def 13;
    hence thesis by A1,A10;
   end;
  end;
end;

