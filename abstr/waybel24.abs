:: Scott-Continuous Functions, Part II
::  by Adam Grabowski
::
:: Received June 22, 1999
:: Copyright (c) 1999 Association of Mizar Users

environ

 vocabulary WAYBEL_0, WAYBEL11, WAYBEL_9, WAYBEL17, LATTICES, ORDINAL2,
      PRE_TOPC, YELLOW_1, ORDERS_1, RELAT_2, SEQM_3, FUNCT_1, RELAT_1,
      FUNCOP_1, LATTICE3, BOOLE, GROUP_1, BHSP_3, YELLOW_0, FUNCT_2, BORSUK_1,
      FUNCT_5, MCART_1, QUANTAL1, CAT_1, MONOID_0, WAYBEL_3, PBOOLE, CARD_3,
      FUNCT_4, WAYBEL24;
 notation TARSKI, XBOOLE_0, ZFMISC_1, SUBSET_1, STRUCT_0, RELAT_1, FUNCT_1,
      FUNCT_2, FUNCT_5, SEQM_3, MONOID_0, CARD_3, FUNCOP_1, BORSUK_1, PRE_TOPC,
      ORDERS_1, LATTICE3, PBOOLE, FUNCT_7, YELLOW_0, ORDERS_3, WAYBEL_0,
      YELLOW_1, YELLOW_2, WAYBEL_3, WAYBEL_9, WAYBEL11, WAYBEL17, YELLOW_3;
 constructors FUNCT_7, SEQM_3, ORDERS_3, WAYBEL_3, WAYBEL_5, WAYBEL_1,
      WAYBEL17, MONOID_0, BORSUK_1;
 clusters STRUCT_0, WAYBEL_0, WAYBEL_3, RELSET_1, YELLOW_1, LATTICE3, BORSUK_2,
      WAYBEL10, WAYBEL11, WAYBEL17, YELLOW_3, YELLOW_0, MONOID_0, SUBSET_1,
      FUNCT_2, XBOOLE_0;
 requirements SUBSET, BOOLE;


begin :: Preliminaries

theorem :: WAYBEL24:1
   for S, T being up-complete Scott TopLattice
 for M being Subset of SCMaps (S,T) holds
  "\/" (M, SCMaps (S,T)) is continuous map of S, T;

registration let S be non empty RelStr,
               T be non empty reflexive RelStr;
  cluster constant -> monotone map of S, T;
  coherence
  proof
    let f be map of S, T;
    assume A1: f is constant;
      for x,y being Element of S st x <= y holds f.x <= f.y
    proof
      let x,y be Element of S;
      assume x <= y;
        x in the carrier of S & y in the carrier of S;
      then x in dom f & y in dom f by FUNCT_2:def 1;
      hence thesis by A1,SEQM_3:def 5;
    end;
    hence f is monotone by WAYBEL_1:def 2;
  end;
end;


registration let S be non empty RelStr,
               T be reflexive non empty RelStr,
               a be Element of T;
  cluster S --> a -> monotone;
  coherence
  proof
    set f = S --> a;
      for x, y being Element of S st x <= y holds f.x <= f.y
    proof
      let x, y be Element of S;
      assume x <= y;
        f.x = ((the carrier of S) --> a). x by BORSUK_1:def 3
         .= a by FUNCOP_1:13
         .= ((the carrier of S) --> a). y by FUNCOP_1:13
         .= f.y by BORSUK_1:def 3;
      hence thesis;
    end;
    hence thesis by WAYBEL_1:def 2;
  end;
end;


theorem :: WAYBEL24:2
   for S being non empty RelStr,
     T being lower-bounded antisymmetric reflexive non empty RelStr holds
  Bottom MonMaps(S, T) = S --> Bottom T;

theorem :: WAYBEL24:3
   for S being non empty RelStr,
     T being upper-bounded antisymmetric reflexive non empty RelStr holds
  Top MonMaps(S, T) = S --> Top T;

scheme :: WAYBEL24:sch 1
 FuncFraenkelSL{ B, C() -> non empty RelStr,
        A(set) -> Element of C(), f() -> Function, P[set]}:
  f().:{A(x) where x is Element of B(): P[x]} =
   {f().A(x) where x is Element of B(): P[x]}
  provided  the carrier of C() c= dom f()
proof   set f = f();
   thus f.:{A(x) where x is Element of B(): P[x]} c=
      {f.A(x) where x is Element of B(): P[x]}
     proof let y be set; assume
         y in f.:{A(x) where x is Element of B(): P[x]};
      then consider z being set such that
A2:     z in dom f & z in {A(x) where x is Element of B(): P[x]}
       & y = f.z by FUNCT_1:def 12;
         ex x being Element of B() st z = A(x) & P[x] by A2;
      hence thesis by A2;
     end;
   let y be set;
   assume y in {f.A(x) where x is Element of B(): P[x]};
   then consider x being Element of B() such that
A3:   y = f.A(x) & P[x];
     A(x) in the carrier of C();
   then A(x) in dom f &
    A(x) in {A(z) where z is Element of B(): P[z]} by A1,A3;
   hence thesis by A3,FUNCT_1:def 12;
  end;

scheme :: WAYBEL24:sch 2
 Fraenkel6A{ B() -> LATTICE, F(set) -> set, P[set], Q[set] } :
  { F(v1) where v1 is Element of B() : P[v1] }
  = { F(v2) where v2 is Element of B() : Q[v2] }
 provided
 for v being Element of B() holds P[v] iff Q[v]
proof
  thus { F(v1) where v1 is Element of B() : P[v1] } c=
    { F(v2) where v2 is Element of B() : Q[v2] }
  proof
    let a be set;
    assume a in { F(v1) where v1 is Element of B() : P[v1] };
    then consider V1 being Element of B() such that
A2:    a = F(V1) & P[V1];
      Q[V1] by A1,A2;
    hence thesis by A2;
  end;
  thus { F(v2) where v2 is Element of B() : Q[v2] } c=
    { F(v1) where v1 is Element of B() : P[v1] }
  proof
    let a be set;
    assume a in { F(v1) where v1 is Element of B() : Q[v1] };
    then consider V1 being Element of B() such that
A3:    a = F(V1) & Q[V1];
      P[V1] by A1,A3;
    hence thesis by A3;
  end;
end;

theorem :: WAYBEL24:4
 for S, T being complete LATTICE,
     f being monotone map of S, T holds
   for x being Element of S holds f.x = sup (f.:downarrow x);

theorem :: WAYBEL24:5
   for S, T being complete lower-bounded LATTICE,
     f being monotone map of S, T holds
    ( for x being Element of S holds
      f.x = "\/"({ f.w where w is Element of S : w <= x },T) );

theorem :: WAYBEL24:6
  for S being RelStr, T being non empty RelStr,
      F being Subset of (T |^ the carrier of S) holds sup F is map of S, T;

begin  :: On the Scott continuity of maps

definition let X1, X2, Y be non empty RelStr;
           let f be map of [:X1, X2:], Y;
           let x be Element of X1;
  func Proj (f, x) -> map of X2, Y equals
:: WAYBEL24:def 1
    (curry f).x;
end;


reserve X1, X2, Y for non empty RelStr,
        f for map of [:X1, X2:], Y,
        x for Element of X1,
        y for Element of X2;

theorem :: WAYBEL24:7
  for y being Element of X2 holds
    (Proj (f, x)). y = f. [x, y];

definition let X1, X2, Y be non empty RelStr;
           let f be map of [:X1, X2:], Y;
           let y be Element of X2;
  func Proj (f, y) -> map of X1, Y equals
:: WAYBEL24:def 2
    (curry' f).y;
end;


theorem :: WAYBEL24:8
  for x being Element of X1 holds
    (Proj (f, y)). x = f. [x, y];

theorem :: WAYBEL24:9
  for R, S, T being non empty RelStr,
      f being map of [:R,S:], T,
      a being Element of R,
      b being Element of S holds
    Proj (f, a). b = Proj (f, b). a;

registration
 let S be non empty RelStr, T be non empty reflexive RelStr;
 cluster antitone map of S, T;
 existence
  proof consider c being Element of T;
   take f = S --> c;
   let x, y be Element of S;
     assume
       [x, y] in the InternalRel of S;
A1:  f = (the carrier of S) --> c by BORSUK_1:def 3;
   let a, b be Element of T; assume a = f.x & b = f.y;
   then a = c & b = c by A1,FUNCOP_1:13;
   hence b <= a;
  end;
end;


theorem :: WAYBEL24:10
  for R, S, T being non empty reflexive RelStr,
      f being map of [:R,S:], T,
      a being Element of R,
      b being Element of S st
    f is monotone holds Proj (f, a) is monotone & Proj (f, b) is monotone;

theorem :: WAYBEL24:11
  for R, S, T being non empty reflexive RelStr,
      f being map of [:R,S:], T,
      a being Element of R,
      b being Element of S st
    f is antitone holds Proj (f, a) is antitone & Proj (f, b) is antitone;

registration let R, S, T be non empty reflexive RelStr;
  let f be monotone map of [:R, S:], T;
  let a be Element of R;
  cluster Proj (f, a) -> monotone;
  coherence by Th10;
end;


registration let R, S, T be non empty reflexive RelStr;
  let f be monotone map of [:R, S:], T;
  let b be Element of S;
  cluster Proj (f, b) -> monotone;
  coherence by Th10;
end;


registration let R, S, T be non empty reflexive RelStr;
  let f be antitone map of [:R, S:], T;
  let a be Element of R;
  cluster Proj (f, a) -> antitone;
  coherence by Th11;
end;


registration let R, S, T be non empty reflexive RelStr;
  let f be antitone map of [:R, S:], T;
  let b be Element of S;
  cluster Proj (f, b) -> antitone;
  coherence by Th11;
end;


theorem :: WAYBEL24:12
  for R, S, T being LATTICE,
      f being map of [:R,S:], T st
  ( for a being Element of R, b being Element of S holds
    Proj (f, a) is monotone & Proj (f, b) is monotone)
      holds f is monotone;

theorem :: WAYBEL24:13
    for R, S, T being LATTICE,
      f being map of [:R,S:], T st
  ( for a being Element of R, b being Element of S holds
    Proj (f, a) is antitone & Proj (f, b) is antitone)
      holds f is antitone;

theorem :: WAYBEL24:14
  for R, S, T being LATTICE,
      f being map of [:R,S:], T,
      b being Element of S,
      X being Subset of R holds
   Proj (f, b).:X = f.:[:X, {b}:];

theorem :: WAYBEL24:15
  for R, S, T being LATTICE,
      f being map of [:R,S:], T,
      b being Element of R,
      X being Subset of S holds
   Proj (f, b).:X = f.:[:{b}, X:];

theorem :: WAYBEL24:16 :: Lemma 2.9 p. 116  (1) => (2)
    for R, S, T being LATTICE,
      f being map of [:R,S:], T,
      a being Element of R,
      b being Element of S st
    f is directed-sups-preserving holds
     Proj (f, a) is directed-sups-preserving &
      Proj (f, b) is directed-sups-preserving;

theorem :: WAYBEL24:17
  for R, S, T being LATTICE,
      f being monotone map of [:R, S:], T,
      a being Element of R, b being Element of S,
      X being directed Subset of [:R, S:] st
    ex_sup_of f.:X, T & a in proj1 X & b in proj2 X holds
       f. [a, b] <= sup (f.:X);

theorem :: WAYBEL24:18 :: Lemma 2.9 p. 116  (2) => (1)
    for R, S, T being complete LATTICE,
      f being map of [:R, S:], T st
  ( for a being Element of R, b being Element of S holds
    Proj (f, a) is directed-sups-preserving &
     Proj (f, b) is directed-sups-preserving ) holds
       f is directed-sups-preserving;

theorem :: WAYBEL24:19
  for S being non empty 1-sorted,
      T being non empty RelStr,
      f be set holds
    f is Element of (T |^ the carrier of S) iff f is map of S, T;

begin  :: The poset of continuous maps

definition let S be TopStruct,
               T be non empty TopRelStr;
  func ContMaps (S, T) -> strict RelStr means
:: WAYBEL24:def 3
    it is full SubRelStr of T |^ the carrier of S &
    for x being set holds
      x in the carrier of it iff
        ex f being map of S, T st x = f & f is continuous;
end;


registration let S be non empty TopSpace,
               T be non empty TopSpace-like TopRelStr;
  cluster ContMaps (S, T) -> non empty;
  coherence
  proof
    consider f being continuous map of S, T;
      f in the carrier of ContMaps(S,T) by Def3;
    hence thesis by STRUCT_0:def 1;
  end;
end;


registration let S be non empty TopSpace,
               T be non empty TopSpace-like TopRelStr;
  cluster ContMaps (S, T) -> constituted-Functions;
  coherence
  proof
    let a be Element of ContMaps (S, T);
    consider a' being map of S, T such that
A1:    a' = a & a' is continuous by Def3;
    thus thesis by A1;
  end;
end;


theorem :: WAYBEL24:20
  for S being non empty TopSpace,
      T being non empty reflexive TopSpace-like TopRelStr,
      x, y being Element of ContMaps (S, T) holds
   x <= y iff for i being Element of S holds
     [x.i, y.i] in the InternalRel of T;

theorem :: WAYBEL24:21
  for S being non empty TopSpace,
      T being non empty reflexive TopSpace-like TopRelStr,
      x being set holds
    x is continuous map of S, T iff x is Element of ContMaps (S, T);

registration let S be non empty TopSpace,
               T be non empty reflexive TopSpace-like TopRelStr;
  cluster ContMaps (S, T) -> reflexive;
  coherence
  proof
    reconsider CS = ContMaps (S, T) as full SubRelStr of
      T |^ the carrier of S by Def3;
      CS is reflexive;
    hence thesis;
  end;
end;


registration let S be non empty TopSpace,
               T be non empty transitive TopSpace-like TopRelStr;
  cluster ContMaps (S, T) -> transitive;
  coherence
  proof
    reconsider CS = ContMaps (S, T) as full SubRelStr of
      T |^ the carrier of S by Def3;
      CS is transitive;
    hence thesis;
  end;
end;


registration let S be non empty TopSpace,
               T be non empty antisymmetric TopSpace-like TopRelStr;
  cluster ContMaps (S, T) -> antisymmetric;
  coherence
  proof
    reconsider CS = ContMaps (S, T) as full SubRelStr of
      T |^ the carrier of S by Def3;
      CS is antisymmetric;
    hence thesis;
  end;
end;


registration let S be non empty 1-sorted,
               T be non empty TopSpace-like TopRelStr;
  cluster T |^ the carrier of S -> constituted-Functions;
  coherence
  proof
    let a be Element of (T |^ the carrier of S);
    thus thesis by Th19;
  end;
end;


theorem :: WAYBEL24:22
    for S being non empty 1-sorted,
      T being complete LATTICE
  for f, g, h being map of S, T,
      i being Element of S st h = "\/" ({f, g}, T |^ the carrier of S) holds
   h.i = sup {f.i, g.i};

theorem :: WAYBEL24:23
 for I being non empty set
 for J being RelStr-yielding non-Empty reflexive-yielding ManySortedSet of I
  st for i being Element of I holds J.i is complete LATTICE
 for X being Subset of product J, i being Element of I holds
   (inf X).i = inf pi(X,i);

theorem :: WAYBEL24:24
    for S being non empty 1-sorted,
      T being complete LATTICE
  for f, g, h being map of S, T,
      i being Element of S st h = "/\" ({f, g}, T |^ the carrier of S) holds
   h.i = inf {f.i, g.i};

registration let S be non empty 1-sorted, T be LATTICE;
  cluster -> Function-like Relation-like Element of (T |^ the carrier of S);
  coherence by Th19;
end;


registration let S, T be TopLattice;
  cluster -> Function-like Relation-like Element of ContMaps (S, T);
  coherence;
end;


theorem :: WAYBEL24:25
  for S being non empty RelStr,
      T being complete LATTICE
  for F being non empty Subset of (T |^ the carrier of S),
      i being Element of S holds
    (sup F).i = "\/" ({ f.i where f is Element of (T |^ the carrier of S) :
      f in F }, T );

theorem :: WAYBEL24:26
  for S, T being complete TopLattice
  for F being non empty Subset of ContMaps (S, T),
      i being Element of S holds
    "\/" (F, (T |^ the carrier of S)).i =
     "\/" ({ f.i where f is Element of (T |^ the carrier of S) : f in F }, T );

reserve S for non empty RelStr, T for complete LATTICE;


theorem :: WAYBEL24:27
  for F being non empty Subset of (T |^ the carrier of S),
      D being non empty Subset of S holds
  (sup F).:D =
    { "\/" ({ f.i where f is Element of (T |^ the carrier of S) : f in F }, T )
     where i is Element of S : i in D };

theorem :: WAYBEL24:28
 for S, T being complete Scott TopLattice,
     F being non empty Subset of ContMaps (S, T),
     D being non empty Subset of S holds
  ("\/" (F, (T |^ the carrier of S))).:D =
    { "\/" ({ f.i where f is Element of (T |^ the carrier of S) : f in F }, T )
     where i is Element of S : i in D };

scheme :: WAYBEL24:sch 3
 FraenkelF'RS{ B() -> non empty TopRelStr, F(set) -> set, G(set) -> set,
  P[set] } :
  { F(v1) where v1 is Element of B() : P[v1] }
  = { G(v2) where v2 is Element of B() : P[v2] }
 provided
 for v being Element of B() st P[v] holds F(v) = G(v)
proof
  set X = { F(v1) where v1 is Element of B() : P[v1] },
      Y = { G(v2) where v2 is Element of B() : P[v2] };
A2: X c= Y
   proof let x be set;
    assume x in X;
     then consider v1 being Element of B() such that
A3:   x = F(v1) & P[v1];
       x = G(v1) by A1,A3;
    hence x in Y by A3;
   end;
    Y c= X
   proof let x be set;
    assume x in Y;
     then consider v1 being Element of B() such that
A4:   x = G(v1) & P[v1];
       x = F(v1) by A1,A4;
    hence x in X by A4;
   end;
 hence thesis by A2,XBOOLE_0:def 10;
end;

scheme :: WAYBEL24:sch 4
 FraenkelF'RSS{ B() -> non empty RelStr, F(set) -> set, G(set) -> set,
  P[set] } :
  { F(v1) where v1 is Element of B() : P[v1] }
  = { G(v2) where v2 is Element of B() : P[v2] }
 provided
 for v being Element of B() st P[v] holds F(v) = G(v)
proof
  set X = { F(v1) where v1 is Element of B() : P[v1] },
      Y = { G(v2) where v2 is Element of B() : P[v2] };
A2: X c= Y
   proof let x be set;
    assume x in X;
     then consider v1 being Element of B() such that
A3:   x = F(v1) & P[v1];
       x = G(v1) by A1,A3;
    hence x in Y by A3;
   end;
    Y c= X
   proof let x be set;
    assume x in Y;
     then consider v1 being Element of B() such that
A4:   x = G(v1) & P[v1];
       x = F(v1) by A1,A4;
    hence x in X by A4;
   end;
 hence thesis by A2,XBOOLE_0:def 10;
end;

scheme :: WAYBEL24:sch 5
 FuncFraenkelS{ B, C() -> non empty TopRelStr,
        A(set) -> Element of C(), f() -> Function, P[set]}:
  f().:{A(x) where x is Element of B(): P[x]} =
   {f().A(x) where x is Element of B(): P[x]}
  provided  the carrier of C() c= dom f()
proof   set f = f();
   thus f.:{A(x) where x is Element of B(): P[x]} c=
      {f.A(x) where x is Element of B(): P[x]}
     proof let y be set; assume
         y in f.:{A(x) where x is Element of B(): P[x]};
      then consider z being set such that
A2:     z in dom f & z in {A(x) where x is Element of B(): P[x]}
       & y = f.z by FUNCT_1:def 12;
         ex x being Element of B() st z = A(x) & P[x] by A2;
      hence thesis by A2;
     end;
   let y be set;
   assume y in {f.A(x) where x is Element of B(): P[x]};
   then consider x being Element of B() such that
A3:   y = f.A(x) & P[x];
     A(x) in the carrier of C();
   then A(x) in dom f &
    A(x) in {A(z) where z is Element of B(): P[z]} by A1,A3;
   hence thesis by A3,FUNCT_1:def 12;
  end;

theorem :: WAYBEL24:29
 for S, T being complete Scott TopLattice,
     F being non empty Subset of ContMaps (S, T) holds
  "\/" (F, (T |^ the carrier of S)) is monotone map of S, T;

theorem :: WAYBEL24:30
 for S, T being complete Scott TopLattice,
     F being non empty Subset of ContMaps (S, T),
     D being directed non empty Subset of S holds
  "\/"({ "\/"({g.i where i is Element of S : i in D }, T )
   where g is Element of (T |^ the carrier of S) : g in F }, T ) =
    "\/"({ "\/"
({g'.i' where g' is Element of (T |^ the carrier of S) : g' in F },
      T ) where i' is Element of S : i' in D }, T);

theorem :: WAYBEL24:31
 for S, T being complete Scott TopLattice,
     F being non empty Subset of ContMaps (S, T),
     D being directed non empty Subset of S holds
   "\/" (("\/"(F, (T |^ the carrier of S))).:D, T) =
     "\/" (F, (T |^ the carrier of S)).sup D;

theorem :: WAYBEL24:32
 for S, T being complete Scott TopLattice,
     F being non empty Subset of ContMaps (S, T) holds
 "\/"(F, (T |^ the carrier of S)) in the carrier of ContMaps (S, T);

theorem :: WAYBEL24:33
 for S being non empty RelStr,
     T being lower-bounded antisymmetric non empty RelStr holds
  Bottom (T |^ the carrier of S) = S --> Bottom T;

theorem :: WAYBEL24:34
   for S being non empty RelStr,
     T being upper-bounded antisymmetric non empty RelStr holds
  Top (T |^ the carrier of S) = S --> Top T;

registration let S be non empty reflexive RelStr,
               T be complete LATTICE,
               a be Element of T;
  cluster S --> a -> directed-sups-preserving;
  coherence
  proof
    set f = S --> a;
      for X being Subset of S st X is non empty directed holds
      f preserves_sup_of X
    proof
      let X be Subset of S;
      assume X is non empty directed;
      then reconsider X' = X as non empty directed Subset of S;
        f preserves_sup_of X
      proof
        assume ex_sup_of X,S;
        thus ex_sup_of f.:X, T by YELLOW_0:17;
A1:     f .: X c= rng f by RELAT_1:144;
A2:     f = (the carrier of S) --> a by BORSUK_1:def 3;
then A3:     f .: X c= {a} by A1,FUNCOP_1:14;
          {a} c= f .: X
        proof
          let b be set; assume b in {a};
then A4:       b = a by TARSKI:def 1;
          consider n being Element of X';
A5:       dom f = the carrier of S by A2,FUNCOP_1:19;
            a = ((the carrier of S) --> a).n by FUNCOP_1:13
           .= f.n by BORSUK_1:def 3;
          hence thesis by A4,A5,FUNCT_1:def 12;
        end;
        hence sup (f.:X) = sup {a} by A3,XBOOLE_0:def 10
                      .= a by YELLOW_0:39
                     .= ((the carrier of S) --> a). sup X by FUNCOP_1:13
                     .= f.sup X by BORSUK_1:def 3;
      end;
      hence thesis;
    end;
    hence f is directed-sups-preserving by WAYBEL_0:def 37;
  end;
end;


theorem :: WAYBEL24:35  :: Lemma 2.4, p. 115
 for S, T being complete Scott TopLattice holds
  ContMaps (S, T) is sups-inheriting SubRelStr of (T |^ the carrier of S);

registration let S, T be complete Scott TopLattice;
  cluster ContMaps (S, T) -> complete;
  coherence
  proof
      ContMaps (S, T) is sups-inheriting non empty full
      SubRelStr of (T |^ the carrier of S) by Def3,Th35;
    hence thesis by YELLOW_2:33;
  end;
end;


theorem :: WAYBEL24:36
   for S, T being non empty Scott complete TopLattice holds
  Bottom ContMaps (S, T) = S --> Bottom T;

theorem :: WAYBEL24:37
   for S, T being non empty Scott complete TopLattice holds
  Top ContMaps (S, T) = S --> Top T;

theorem :: WAYBEL24:38
    for S, T being Scott complete TopLattice holds
    SCMaps (S, T) = ContMaps (S, T);

