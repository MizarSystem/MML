:: K\"onig's Theorem
::  by Grzegorz Bancerek
::
:: Received April 10, 1990
:: Copyright (c) 1990 Association of Mizar Users

environ

 vocabularies ORDINAL1, CARD_1, FUNCT_1, RELAT_1, BOOLE, FUNCOP_1, FUNCT_2,
      TARSKI, MCART_1, PROB_1, RLVECT_1, CARD_2, ORDINAL2, FINSET_1, ARYTM_1,
      CLASSES1, ZFMISC_1, WELLORD1, WELLORD2, RELAT_2, CARD_3, HAHNBAN,
      FRAENKEL, AMI_1, ZF_REFLE, PARTFUN1, FUNCT_4, CAT_1, ARYTM, SETFAM_1,
      AMISTD_2, PRALG_2, CARD_4, SUPINF_2, FINSUB_1, BORSUK_1;
 notations TARSKI, XBOOLE_0, ZFMISC_1, SUBSET_1, CARD_1, NUMBERS, XCMPLX_0,
      NAT_1, RELAT_1, RELAT_2, FUNCT_1, RELSET_1, PARTFUN1, FUNCT_2, SETFAM_1,
      ORDINAL1, ORDINAL2, WELLORD1, MCART_1, WELLORD2, FUNCOP_1, FUNCT_4,
      FINSET_1, FINSUB_1, CARD_2, CLASSES1, XXREAL_0;
 constructors SETFAM_1, RELAT_2, WELLORD1, PARTFUN1, WELLORD2, FUNCOP_1,
      FUNCT_4, XREAL_0, NAT_1, CARD_2, CLASSES1, ORDINAL2, ORDINAL3, XXREAL_0,
      FINSUB_1, RELSET_1, FUNCT_1;
 registrations XBOOLE_0, SUBSET_1, SETFAM_1, RELAT_1, FUNCT_1, ORDINAL1,
      FUNCOP_1, FUNCT_4, FINSET_1, XREAL_0, CARD_1, FINSUB_1;
 requirements NUMERALS, BOOLE, SUBSET, ARITHM;


begin

reserve A,B,C for Ordinal,
  K,L,M,N for Cardinal,
  x,y,y1,y2,z,u,X,Y,Z,Z1,Z2 for set,
  n for Element of NAT,
  f,f1,g,h for Function,
  Q,R for Relation;

definition
  let IT be Function;
  attr IT is Cardinal-yielding means
:: CARD_3:def 1

   for x st x in dom IT holds IT.x is Cardinal;
end;

registration
  cluster Cardinal-yielding Function;
end;

definition
  mode Cardinal-Function is Cardinal-yielding Function;
end;

reserve ff for Cardinal-Function;

registration
  let ff,X;
  cluster ff|X -> Cardinal-yielding;
end;

registration
  let X,K;
  cluster X --> K -> Cardinal-yielding;
end;

registration
  let X,K;
  cluster X .--> K -> Cardinal-yielding;
end;

canceled 2;

theorem :: CARD_3:3
  {} is Cardinal-Function;

scheme :: CARD_3:sch 1
 CFLambda { A()->set, F(set)->Cardinal } :
  ex ff st dom ff = A() & for x st x in A() holds ff.x = F(x);

definition
  let f;
  func Card f -> Cardinal-Function means
:: CARD_3:def 2

   dom it = dom f & for x st x in dom f holds it.x = card(f.x);
  func disjoin f -> Function means
:: CARD_3:def 3

   dom it = dom f & for x st x in dom f holds it.x = [:f.x,{x}:];
  func Union f -> set equals
:: CARD_3:def 4
  union rng f;
  func product f -> set means
:: CARD_3:def 5

   x in it iff ex g st x = g & dom g = dom f &
  for y st y in dom f holds g.y in f.y;
end;

canceled 4;

theorem :: CARD_3:8
  Card ff = ff;

theorem :: CARD_3:9
  Card {} = {};

theorem :: CARD_3:10
  Card (X --> Y) = X --> card Y;

theorem :: CARD_3:11
  disjoin {} = {};

theorem :: CARD_3:12
  disjoin (x .--> X) = x .--> [:X,{x}:];

theorem :: CARD_3:13
  x in dom f & y in dom f & x <> y implies (disjoin f).x misses (disjoin f).y;

canceled;

theorem :: CARD_3:15
  Union (X --> Y) c= Y;

theorem :: CARD_3:16
  X <> {} implies Union (X --> Y) = Y;

theorem :: CARD_3:17
  Union (x .--> Y) = Y;

theorem :: CARD_3:18
  g in product f iff dom g = dom f & for x st x in dom f holds g.x in f.x;

theorem :: CARD_3:19
  product {} = {{}};

theorem :: CARD_3:20
  Funcs(X,Y) = product (X --> Y);

definition
  let x,X;
  func pi(X,x) -> set means
:: CARD_3:def 6

  y in it iff ex f st f in X & y = f.x;
end;

canceled;

theorem :: CARD_3:22
  x in dom f & product f <> {} implies pi(product f,x) = f.x;

canceled;

theorem :: CARD_3:24
  pi({},x) = {};

theorem :: CARD_3:25
  pi({g},x) = {g.x};

theorem :: CARD_3:26
  pi({f,g},x) = {f.x,g.x};

theorem :: CARD_3:27
  pi(X \/ Y,x) = pi(X,x) \/ pi(Y,x);

theorem :: CARD_3:28
  pi(X /\ Y,x) c= pi(X,x) /\ pi(Y,x);

theorem :: CARD_3:29
  pi(X,x) \ pi(Y,x) c= pi(X \ Y,x);

theorem :: CARD_3:30
  pi(X,x) \+\ pi(Y,x) c= pi(X \+\ Y,x);

theorem :: CARD_3:31
  card pi(X,x) c= card X;

theorem :: CARD_3:32
  x in Union disjoin f implies ex y,z st x = [y,z];

theorem :: CARD_3:33
  x in Union disjoin f iff x`2 in dom f & x`1 in f.(x`2) & x = [x`1,x`2];

theorem :: CARD_3:34
  f c= g implies disjoin f c= disjoin g;

theorem :: CARD_3:35
  f c= g implies Union f c= Union g;

theorem :: CARD_3:36
  Union disjoin (Y --> X) = [:X,Y:];

theorem :: CARD_3:37
  product f = {} iff {} in rng f;

theorem :: CARD_3:38
  dom f = dom g & (for x st x in dom f holds f.x c= g.x) implies
  product f c= product g;

reserve F,G for Cardinal-Function;

theorem :: CARD_3:39
  for x st x in dom F holds card (F.x) = F.x;

theorem :: CARD_3:40
  for x st x in dom F holds card ((disjoin F).x) = F.x;

definition
  let F;
  func Sum F -> Cardinal equals
:: CARD_3:def 7
  card Union disjoin F;
  func Product F -> Cardinal equals
:: CARD_3:def 8
  card product F;
end;

canceled 2;

theorem :: CARD_3:43
  dom F = dom G & (for x st x in dom F holds F.x c= G.x) implies Sum F c= Sum
  G;

theorem :: CARD_3:44
  {} in rng F iff Product F = 0;

theorem :: CARD_3:45
  dom F = dom G & (for x st x in dom F holds F.x c= G.x) implies
  Product F c= Product G;

theorem :: CARD_3:46
  F c= G implies Sum F c= Sum G;

theorem :: CARD_3:47
  F c= G & not 0 in rng G implies Product F c= Product G;

theorem :: CARD_3:48
  Sum({} --> K) = 0;

theorem :: CARD_3:49
  Product ({} --> K) = 1;

theorem :: CARD_3:50
  Sum(x .--> K) = K;

theorem :: CARD_3:51
  Product(x .--> K) = K;

theorem :: CARD_3:52
  Sum(M --> N) = M*`N;

theorem :: CARD_3:53
  Product(N --> M) = exp(M,N);

theorem :: CARD_3:54
  card Union f c= Sum Card f;

theorem :: CARD_3:55
  card Union F c= Sum F;

::
:: K\"onig's theorem
::

theorem :: CARD_3:56
  dom F = dom G & (for x st x in dom F holds F.x in G.x) implies
  Sum F in Product G;

scheme :: CARD_3:sch 2
 FinRegularity { X()->finite set, P[set,set] }:
  ex x st x in X() & for y st y in X() & y <> x holds not P[y,x]
provided
 X() <> {} and
 for x,y st P[x,y] & P[y,x] holds x = y and
 for x,y,z st P[x,y] & P[y,z] holds P[x,z];

scheme :: CARD_3:sch 3
 MaxFinSetElem { X()->finite set, P[set,set] }:
  ex x st x in X() & for y st y in X() holds P[x,y]
provided
 X() <> {} and
 for x,y holds P[x,y] or P[y,x] and
 for x,y,z st P[x,y] & P[y,z] holds P[x,z];

scheme :: CARD_3:sch 4
 FuncSeparation { X()->set, F(set)->set, P[set,set] }:
  ex f st dom f = X() &
  for x st x in X() for y holds y in f.x iff y in F(x) & P[x,y];

theorem :: CARD_3:57
  Rank n is finite;

theorem :: CARD_3:58
  X is finite implies card X in card omega;

theorem :: CARD_3:59
  card A in card B implies A in B;

theorem :: CARD_3:60
  card A in M implies A in M;

theorem :: CARD_3:61
  X is c=-linear implies
  ex Y st Y c= X & union Y = union X & for Z st Z c= Y & Z <> {}
  ex Z1 st Z1 in Z & for Z2 st Z2 in Z holds Z1 c= Z2;

theorem :: CARD_3:62
  (for Z st Z in X holds card Z in M) & X is c=-linear implies
  card union X c= M;

begin :: Addenda

:: from AMI_1

registration
  let f be Function;
  cluster product f -> functional;
end;

registration
  let A be set;
  let B be with_non-empty_elements set;
  cluster -> non-empty Function of A,B;
end;

:: from PRVECT_1

registration
  let f be non-empty Function;
  cluster product f -> non empty;
end;

:: from AMI_1, 2006.03.14, A.T.

theorem :: CARD_3:63
  for a,b,c,d being set st a <> b holds
  product (a,b) --> ({c},{d}) = { (a,b) --> (c,d) };

:: from AMI_1, 2006.03.14, A.T.

theorem :: CARD_3:64
  x in product f implies x is Function;

begin :: Superproducts, from AMI_1, 2006.03.14, A.T.

reserve A,B for set;

definition
  let f be Function;
  func sproduct f -> set means
:: CARD_3:def 9

  x in it iff ex g st x = g & dom g c= dom f &
  for x st x in dom g holds g.x in f.x;
end;

registration
  let f be Function;
  cluster sproduct f -> functional non empty;
end;

theorem :: CARD_3:65
  g in sproduct f implies dom g c= dom f &
  for x st x in dom g holds g.x in f.x;

theorem :: CARD_3:66
  {} in sproduct f;

registration let f;
 cluster empty Element of sproduct f;
end;

theorem :: CARD_3:67
  product f c= sproduct f;

theorem :: CARD_3:68
  x in sproduct f implies x is PartFunc of dom f, union rng f;

theorem :: CARD_3:69
  g in product f & h in sproduct f implies g +* h in product f;

theorem :: CARD_3:70
  product f <> {} implies
  (g in sproduct f iff ex h st h in product f & g c= h);

theorem :: CARD_3:71
  sproduct f c= PFuncs(dom f,union rng f);

theorem :: CARD_3:72
  f c= g implies sproduct f c= sproduct g;

theorem :: CARD_3:73
  sproduct {} = {{}};

theorem :: CARD_3:74
  PFuncs(A,B) = sproduct (A --> B);

theorem :: CARD_3:75
  for A, B being non empty set for f being Function of A,B
  holds sproduct f = sproduct(f|{x where x is Element of A: f.x <> {} });

theorem :: CARD_3:76
  x in dom f & y in f.x implies x .--> y in sproduct f;

theorem :: CARD_3:77
  sproduct f = {{}} iff for x st x in dom f holds f.x = {};

theorem :: CARD_3:78
  A c= sproduct f &
  (for h1,h2 being Function st h1 in A & h2 in A holds h1 tolerates h2)
  implies union A in sproduct f;

theorem :: CARD_3:79
  g tolerates h & g in sproduct f & h in sproduct f
  implies g \/ h in sproduct f;

theorem :: CARD_3:80
  x c= h & h in sproduct f implies x in sproduct f;

theorem :: CARD_3:81
  g in sproduct f implies g|A in sproduct f;

theorem :: CARD_3:82
  g in sproduct f implies g|A in sproduct f|A;

theorem :: CARD_3:83
  h in sproduct(f+*g) implies
  ex f',g' being Function st f' in sproduct f & g' in sproduct g & h = f'+*g';

theorem :: CARD_3:84
  for f',g' being Function st dom g misses dom f' \ dom g' &
  f' in sproduct f & g' in sproduct g holds f'+*g' in sproduct(f+*g);

theorem :: CARD_3:85
  for f',g' being Function st dom f' misses dom g \ dom g' &
  f' in sproduct f & g' in sproduct g holds f'+*g' in sproduct(f+*g);

theorem :: CARD_3:86
  g in sproduct f & h in sproduct f implies g +* h in sproduct f;

theorem :: CARD_3:87
  for x1,x2,y1,y2 being set holds
  x1 in dom f & y1 in f.x1 & x2 in dom f & y2 in f.x2
  implies (x1,x2)-->(y1,y2) in sproduct f;

begin  :: from PRALG_2, 2007.11.14, A.T.

definition
  let IT be set;
  attr IT is with_common_domain means
:: CARD_3:def 10

  for f,g be Function st f in IT & g in IT holds dom f = dom g;
end;

registration
  cluster with_common_domain functional non empty set;
end;

theorem :: CARD_3:88
  {{}} is functional with_common_domain set;

definition
  let X be with_common_domain functional set;
  canceled;  :: miejsce na uogolnienie
  func DOM X -> set means
:: CARD_3:def 12 :: overloading (dom) dozwolony

  for x be Function st x in X holds it = dom x if X <> {}
  otherwise it = {};
end;

theorem :: CARD_3:89
  for X be with_common_domain functional set st X = {{}} holds DOM X = {};

begin  :: Product like sets, from AMISTD_2, 2007.11.14, A.T.

definition
  let S be functional set;
  func product" S -> Function means
:: CARD_3:def 13  :: tu trzeba uzyc DOM
:: uzywajac meet mamy definicje
:: nie przez czesci

  (for x being set holds x in dom it iff
  for f being Function st f in S holds x in dom f) &
  for i being set st i in dom it holds it.i = pi(S,i) if S is non empty
  otherwise it = {};
end;

theorem :: CARD_3:90
  for S being non empty functional set holds
  dom product" S = meet {dom f where f is Element of S: not contradiction};

theorem :: CARD_3:91
  for S being non empty functional set,
  i being set st i in dom product" S holds
  (product" S).i = {f.i where f is Element of S: not contradiction};

definition
  let S be set;
  attr S is product-like means
:: CARD_3:def 14

  ex f being Function st S = product f;
end;

registration
  let f be Function;
  cluster product f -> product-like;
end;

registration
  cluster product-like -> functional with_common_domain set;
end;

registration
  cluster product-like non empty set;
end;

theorem :: CARD_3:92
  for S being functional with_common_domain set holds dom product" S = DOM S;

theorem :: CARD_3:93
  for S being functional set, i being set st i in dom product" S
  holds (product" S).i = pi(S,i);

theorem :: CARD_3:94
  for S being functional with_common_domain set holds S c= product product" S;

theorem :: CARD_3:95
  for S being non empty product-like set holds S = product product" S;

:: from AMI_1, 2008.04.11, A.T. (generalized)

theorem :: CARD_3:96
  for f being Function
  for s, t being Element of product f, A be set holds
  s +* t|A is Element of product f;

theorem :: CARD_3:97
  for f being non-empty Function
  for p being Element of sproduct f
  ex s being Element of product f st p c= s;

theorem :: CARD_3:98
  g in product f implies g|A in sproduct f;

:: needed, 2008.04.20, A.T.

definition
  let f be non-empty Function;
  let g be Element of product f;
  let X;
  redefine func g|X -> Element of sproduct f;
end;

theorem :: CARD_3:99
  for f being non-empty Function
  for s,ss being Element of product f, A being set
  holds (ss +* s | A) | A = s | A;

:: from PRE_CIRC, 2008.06.02, A.T.

theorem :: CARD_3:100
  for M,x, g being Function st x in product M holds x * g in product (M * g);

:: moved from CARD_4, 2008.10.08, A.T.

theorem :: CARD_3:101
  X is finite iff card X in omega;

reserve A,B for Ordinal;

theorem :: CARD_3:102
  A is infinite iff omega c= A;

theorem :: CARD_3:103
  N is finite & not M is finite implies N in M & N c= M;

theorem :: CARD_3:104
  not X is finite iff ex Y st Y c= X & card Y = omega;

theorem :: CARD_3:105
  card X = card Y iff nextcard X = nextcard Y;

theorem :: CARD_3:106
  nextcard N = nextcard M implies M = N;

theorem :: CARD_3:107
  N in M iff nextcard N c= M;

theorem :: CARD_3:108
  N in nextcard M iff N c= M;

theorem :: CARD_3:109
  0 in M iff 1 c= M;

theorem :: CARD_3:110
  1 in M iff 2 c= M;

theorem :: CARD_3:111
  M is finite & (N c= M or N in M) implies N is finite;

reserve n,k for Nat;

theorem :: CARD_3:112
  A is limit_ordinal iff for B,n st B in A holds B+^ n in A;

theorem :: CARD_3:113
  A+^succ n = succ A +^ n & A +^ (n+1) = succ A +^ n;

theorem :: CARD_3:114
  ex n st A*^succ 1 = A +^ n;

theorem :: CARD_3:115
  A is limit_ordinal implies A *^ succ 1 = A;

theorem :: CARD_3:116
  omega c= A implies 1+^A = A;

registration
  cluster infinite -> limit_ordinal Cardinal;
end;

theorem :: CARD_3:117
  not M is finite implies M+`M = M;

theorem :: CARD_3:118
  not M is finite & (N c= M or N in M) implies M+`N = M & N+`M = M;

theorem :: CARD_3:119
  not X is finite & (X,Y are_equipotent or Y,X are_equipotent) implies
  X \/ Y,X are_equipotent & card (X \/ Y) = card X;

theorem :: CARD_3:120
  not X is finite & Y is finite implies
  X \/ Y,X are_equipotent & card (X \/ Y) = card X;

theorem :: CARD_3:121
  not X is finite & (card Y in card X or card Y c= card X) implies
  X \/ Y,X are_equipotent & card (X \/ Y) = card X;

theorem :: CARD_3:122
  for M,N being finite Cardinal holds M+`N is finite;

theorem :: CARD_3:123
  not M is finite implies not M+`N is finite & not N+`M is finite;

theorem :: CARD_3:124
  for M,N being finite Cardinal holds M*`N is finite;

theorem :: CARD_3:125
  K in L & M in N or K c= L & M in N or K in L & M c= N or K c= L & M c= N
  implies K+`M c= L+`N & M+`K c= L+`N;

theorem :: CARD_3:126
  M in N or M c= N implies K+`M c= K+`N & K+`M c= N+`K &
  M+`K c= K+`N & M+`K c= N+`K;

definition
  let X;
  attr X is countable means
:: CARD_3:def 15

  card X c= omega;
  attr X is denumerable means
:: CARD_3:def 16
  card X = omega;
end;

registration
  cluster denumerable -> countable infinite set;
  cluster countable infinite -> denumerable set;
end;

registration
  cluster finite -> countable set;
end;

registration
  cluster omega -> denumerable;
end;

registration
  cluster denumerable set;
end;

theorem :: CARD_3:127
  X is countable iff ex f st dom f = NAT & X c= rng f;

registration
  let X be countable set;
  cluster -> countable Subset of X;
end;

theorem :: CARD_3:128
  X is countable & Y is countable implies X \/ Y is countable;

theorem :: CARD_3:129
  X is countable implies X /\ Y is countable;

theorem :: CARD_3:130
  X is countable implies X \ Y is countable;

theorem :: CARD_3:131
  X is countable & Y is countable implies X \+\ Y is countable;

theorem :: CARD_3:132
  (card dom f c= M & for x st x in dom f holds card (f.x) c= N) implies
  card Union f c= M*`N;

theorem :: CARD_3:133
  (card X c= M & for Y st Y in X holds card Y c= N) implies card union X c=
  M*`N;

theorem :: CARD_3:134
  for f st dom f is finite &
  for x st x in dom f holds f.x is finite holds Union f is finite;

theorem :: CARD_3:135
  (omega)*`(card n) c= omega & (card n)*`(omega) c= omega;

theorem :: CARD_3:136
  K in L & M in N or K c= L & M in N or K in L & M c= N or K c= L & M c= N
  implies K*`M c= L*`N & M*`K c= L*`N;

theorem :: CARD_3:137
  M in N or M c= N implies
  K*`M c= K*`N & K*`M c= N*`K & M*`K c= K*`N & M*`K c= N*`K;

theorem :: CARD_3:138
  K in L & M in N or K c= L & M in N or K in L & M c= N or K c= L & M c= N
  implies K = 0 or exp(K,M) c= exp(L,N);

theorem :: CARD_3:139
  M in N or M c= N implies K = 0 or
  exp(K,M) c= exp(K,N) & exp(M,K) c= exp(N,K);

theorem :: CARD_3:140
  M c= M+`N & N c= M+`N;

theorem :: CARD_3:141
  N <> 0 implies M c= M*`N & M c= N*`M;

theorem :: CARD_3:142
  K in L & M in N implies K+`M in L+`N & M+`K in L+`N;

theorem :: CARD_3:143
  K+`M in K+`N implies M in N;

theorem :: CARD_3:144
  card X +` card Y = card X & card Y in card X implies card (X \ Y) = card X;

theorem :: CARD_3:145
  K*`M in K*`N implies M in N;

registration
  let A be finite set, B be set, f be Function of A, Fin B;
  cluster Union f -> finite;
end;

theorem :: CARD_3:146
  for A being non empty countable set
  ex f being Function of NAT, A st rng f = A;

:: from CIRCCOMB, 2009.01.26, A.T.

theorem :: CARD_3:147
  for f,g being non-empty Function, x being Element of product f,
  y being Element of product g holds x+*y in product (f+*g);

theorem :: CARD_3:148
  for f,g being non-empty Function
  for x being Element of product (f+*g) holds x|dom g in product g;

theorem :: CARD_3:149
  for f,g being non-empty Function st f tolerates g
  for x being Element of product (f+*g) holds x|dom f in product f;

:: missing, 2009.09.06, A.T.

theorem :: CARD_3:150
  for S being with_common_domain functional set, f be Function
     st f in S  holds dom f = dom product" S;

theorem :: CARD_3:151
  for S being functional set, f be Function, i be set
     st f in S & i in dom product" S holds f.i in (product" S).i;

theorem :: CARD_3:152
  for S being with_common_domain functional set, f be Function, i be set
     st f in S & i in dom f holds f.i in (product" S).i;

:: 2009.09.12, A.T.

registration let X be with_common_domain set;
 cluster -> with_common_domain Subset of X;
end;

:: from PRALG_3, 2009.09.18, A.T.

definition
  let f be Function, x be set;
  func proj(f,x) -> Function means
:: CARD_3:def 17

  dom it = product f & for y being
  Function st y in dom it holds it.y = y.x;
end;

registration
  let f be Function, x be set;
  cluster proj(f,x) -> (product f)-defined;
end;

registration
  let f be Function, x be set;
  cluster proj(f,x) -> total;
end;

registration
  let f be non-empty Function;
  cluster -> f-compatible Element of product f;
end;

registration
  let I be set; let f be I-defined non-empty Function;
  cluster -> I-defined Element of product f;
end;

registration
  let f be Function;
  cluster -> f-compatible Element of sproduct f;
end;

registration
  let I be set; let f be I-defined Function;
  cluster -> I-defined Element of sproduct f;
end;

registration
  let I be set; let f be total (I-defined non-empty Function);
  cluster -> total Element of product f;
end;

theorem :: CARD_3:153
 for I being set, f being non-empty I-defined Function
 for p being f-compatible I-defined Function
  holds p in sproduct f;

