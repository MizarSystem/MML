:: An Extension of { \bf SCM }
::  by Andrzej Trybulec , Yatsuka Nakamura and Piotr Rudnicki
::
:: Received February 3, 1996
:: Copyright (c) 1996 Association of Mizar Users

environ

 vocabularies NUMBERS, SUBSET_1, AMI_2, XBOOLE_0, TARSKI, CARD_1, FINSEQ_1,
      ZFMISC_1, RELAT_1, AMI_1, ORDINAL1, MCART_1, XXREAL_0, FUNCT_1, FUNCOP_1,
      FUNCT_4, INT_1, CARD_3, PBOOLE, NAT_1, PARTFUN1, COMPLEX1, FINSEQ_2,
      FUNCT_2, FUNCT_5, SCMFSA_1, GROUP_9;
 notations TARSKI, XBOOLE_0, ZFMISC_1, SUBSET_1, ORDINAL1, CARD_1, NUMBERS,
      NAT_1, MCART_1, INT_2, PBOOLE, RELAT_1, FUNCT_1, PARTFUN1, FUNCT_2,
      BINOP_1, INT_1, FINSEQ_1, FUNCT_4, CAT_2, FINSEQ_2, CARD_3, FUNCOP_1,
      FINSEQ_4, AMI_2, FUNCT_7, XXREAL_0, GROUP_9;
 constructors PARTFUN1, DOMAIN_1, XXREAL_0, INT_2, FINSEQ_4, FINSOP_1, PBOOLE,
      CAT_2, REAL_1, WELLORD2, RELSET_1, AMI_2, FUNCT_7;
 registrations XBOOLE_0, SUBSET_1, SETFAM_1, FUNCT_1, ORDINAL1, FUNCOP_1,
      NUMBERS, XREAL_0, INT_1, FINSEQ_1, CARD_3, PBOOLE, GR_CY_1, AMI_2,
      AFINSQ_1, RELAT_1, FINSET_1, CARD_1, CARD_2, RELSET_1;
 requirements NUMERALS, REAL, BOOLE, SUBSET;


begin

reserve x,y,z for set,
  k for Element of NAT;

notation
  synonym SCM+FSA-Data-Loc for SCM-Data-Loc;
end;

definition
  func SCM+FSA-Data*-Loc equals
:: SCMFSA_1:def 1
  INT \ NAT;
end;

definition
  func SCM+FSA-Memory equals
:: SCMFSA_1:def 2
  SCM-Memory \/ SCM+FSA-Data*-Loc;
end;

registration
  cluster SCM+FSA-Memory -> non empty;
end;

theorem :: SCMFSA_1:1
  SCM-Memory c= SCM+FSA-Memory;

definition
  redefine func SCM+FSA-Data-Loc -> Subset of SCM+FSA-Memory;
end;

definition
  redefine func SCM+FSA-Data*-Loc -> Subset of SCM+FSA-Memory;
  canceled;
end;

definition
  redefine func NAT -> Subset of SCM+FSA-Memory;
end;

registration
  cluster SCM+FSA-Data*-Loc -> non empty;
end;

reserve J,K for Element of Segm 13,
  a for Element of NAT,
  b,b1,b2,c,c1,c2 for
  Element of SCM+FSA-Data-Loc,
  f,f1,f2 for Element of SCM+FSA-Data*-Loc;

definition
  func SCM+FSA-Instr -> non empty set equals
:: SCMFSA_1:def 4
  SCM-Instr \/ { [J,<*c,f,b*>] : J in {9,10} } \/ { [K,<*c1,f1*>] : K
  in {11,12} };
end;

theorem :: SCMFSA_1:2
  SCM-Instr c= SCM+FSA-Instr;

registration
  cluster SCM+FSA-Instr -> non empty;
end;

registration
  let I be Element of SCM+FSA-Instr;
  cluster I`1 -> natural;
end;

theorem :: SCMFSA_1:3
  for I being Element of SCM+FSA-Instr st I`1 <= 8 holds I in
  SCM-Instr;

theorem :: SCMFSA_1:4
  [0,{}] in SCM+FSA-Instr;

definition
  canceled;
  func SCM+FSA-OK -> Function of SCM+FSA-Memory, {INT,INT*} \/ { SCM+FSA-Instr
  , NAT } equals
:: SCMFSA_1:def 6
  (SCM+FSA-Memory --> INT*) +* SCM-OK +* ((SCM-Instr.-->
  SCM+FSA-Instr)*(SCM-OK|NAT));
end;

theorem :: SCMFSA_1:5
  NAT in SCM+FSA-Memory;

theorem :: SCMFSA_1:6
  x in {9,10} implies [x,<*c,f,b*>] in SCM+FSA-Instr;

theorem :: SCMFSA_1:7
  x in {11,12} implies [x,<*c,f*>] in SCM+FSA-Instr;

theorem :: SCMFSA_1:8
  SCM+FSA-Memory = {NAT} \/ SCM+FSA-Data-Loc \/ SCM+FSA-Data*-Loc
  \/ NAT;

theorem :: SCMFSA_1:9
  SCM+FSA-OK.NAT = NAT;

theorem :: SCMFSA_1:10
  SCM+FSA-OK.b = INT;

theorem :: SCMFSA_1:11
  SCM+FSA-OK.a = SCM+FSA-Instr;

theorem :: SCMFSA_1:12
  SCM+FSA-OK.f = INT*;

theorem :: SCMFSA_1:13
  SCM+FSA-Instr <> INT & NAT <> SCM+FSA-Instr & NAT
  <> INT* & SCM+FSA-Instr <> INT*;

theorem :: SCMFSA_1:14
  for i being Element of SCM+FSA-Memory st SCM+FSA-OK.i = NAT holds i =
  NAT;

theorem :: SCMFSA_1:15
  for i being Element of SCM+FSA-Memory st SCM+FSA-OK.i = INT holds i in
  SCM+FSA-Data-Loc;

theorem :: SCMFSA_1:16
  for i being Element of SCM+FSA-Memory st SCM+FSA-OK.i = SCM+FSA-Instr
  holds i in NAT;

theorem :: SCMFSA_1:17
  for i being Element of SCM+FSA-Memory st SCM+FSA-OK.i = INT* holds i
  in SCM+FSA-Data*-Loc;

registration
 cluster SCM-OK -> non-empty;
 cluster SCM+FSA-OK -> non-empty;
end;

definition
  mode SCM+FSA-State is Element of product SCM+FSA-OK;
end;

theorem :: SCMFSA_1:18
  for s being SCM+FSA-State, I being Element of SCM-Instr holds s|
  SCM-Memory +* (NAT --> I) is SCM-State;

theorem :: SCMFSA_1:19
  for s being SCM+FSA-State, s9 being SCM-State holds s +* s9 +* s
  |NAT is SCM+FSA-State;

definition
  let s be SCM+FSA-State, u be Nat;
  func SCM+FSA-Chg(s,u) -> SCM+FSA-State equals
:: SCMFSA_1:def 7
  s +* (NAT .--> u);
end;

definition
  let s be SCM+FSA-State, t be Element of SCM+FSA-Data-Loc, u be Integer;
  func SCM+FSA-Chg(s,t,u) -> SCM+FSA-State equals
:: SCMFSA_1:def 8
  s +* (t .--> u);
end;

definition
  let s be SCM+FSA-State, t be Element of SCM+FSA-Data*-Loc, u be FinSequence
  of INT;
  func SCM+FSA-Chg(s,t,u) -> SCM+FSA-State equals
:: SCMFSA_1:def 9
  s +* (t .--> u);
end;

definition
  let s be SCM+FSA-State, a be Element of SCM+FSA-Data-Loc;
  redefine func s.a -> Integer;
end;

definition
  let s be SCM+FSA-State, a be Element of SCM+FSA-Data*-Loc;
  redefine func s.a -> FinSequence of INT;
end;

definition
  let x be Element of SCM+FSA-Instr;
  given c,f,b,J such that
 x = [ J, <*c,f,b*>];
  func x int_addr1 -> Element of SCM+FSA-Data-Loc means
:: SCMFSA_1:def 10
  ex c,f,b st <*c,f,b*>
  = x`2 & it = c;
  func x int_addr2 -> Element of SCM+FSA-Data-Loc means
:: SCMFSA_1:def 11
  ex c,f,b st <*c,f,b*>
  = x`2 & it = b;
  func x coll_addr1 -> Element of SCM+FSA-Data*-Loc means
:: SCMFSA_1:def 12
  ex c,f,b st <*c,f,b
  *> = x`2 & it = f;
end;

definition
  let x be Element of SCM+FSA-Instr;
  given c,f,J such that
 x = [ J, <*c,f*>];
  func x int_addr3 -> Element of SCM+FSA-Data-Loc means
:: SCMFSA_1:def 13
  ex c,f st <*c,f*> = x
  `2 & it = c;
  func x coll_addr2 -> Element of SCM+FSA-Data*-Loc means
:: SCMFSA_1:def 14
  ex c,f st <*c,f*> =
  x`2 & it = f;
  canceled;
end;

definition
  let s be SCM+FSA-State;
  func IC(s) -> Element of NAT equals
:: SCMFSA_1:def 16
  s.NAT;
end;

definition
  let x be Element of SCM+FSA-Instr, s be SCM+FSA-State;
  func SCM+FSA-Exec-Res(x,s) -> SCM+FSA-State means
:: SCMFSA_1:def 17
  ex x9 being Element of
  SCM-Instr, s9 being SCM-State st x = x9 & s9 = s|SCM-Memory +* (NAT --> x9) &
it = s +* SCM-Exec-Res(x9,s9) +* s|NAT if x`1 <= 8, ex i being Integer, k
  st k = abs(s.(x int_addr2)) & i = (s.(x coll_addr1))/.k & it = SCM+FSA-Chg(
  SCM+FSA-Chg(s,x int_addr1,i),succ IC s) if x`1 = 9, ex f being
FinSequence of INT,k st k = abs(s.(x int_addr2)) & f = s.(x coll_addr1)+*(k,s.(
  x int_addr1)) & it = SCM+FSA-Chg(SCM+FSA-Chg(s,x coll_addr1,f),succ IC s) if
x`1 = 10, it = SCM+FSA-Chg(SCM+FSA-Chg(s,x int_addr3,len(s.(x coll_addr2)
)),succ IC s) if x`1 = 11, ex f being FinSequence of INT,k st k = abs(s.(
  x int_addr3)) & f = k |-> 0 & it = SCM+FSA-Chg(SCM+FSA-Chg(s,x coll_addr2,f),
  succ IC s) if x`1 = 12 otherwise it = s;
end;

definition
  let A be set, B be non empty set;
  mode Action of A,B is Function of A, Funcs(B,B);
end;

definition
  func SCM+FSA-Exec -> Action of SCM+FSA-Instr, product SCM+FSA-OK means
:: SCMFSA_1:def 18
  for x being Element of SCM+FSA-Instr, y being
  SCM+FSA-State holds (it.x).y = SCM+FSA-Exec-Res(x,y);
end;

theorem :: SCMFSA_1:20
  for s being SCM+FSA-State, u being Element of NAT holds SCM+FSA-Chg(s,
  u).NAT = u;

theorem :: SCMFSA_1:21
  for s being SCM+FSA-State, u being Element of NAT, mk being Element of
  SCM+FSA-Data-Loc holds SCM+FSA-Chg(s,u).mk = s.mk;

theorem :: SCMFSA_1:22
  for s being SCM+FSA-State, u being Element of NAT, p being Element of
  SCM+FSA-Data*-Loc holds SCM+FSA-Chg(s,u).p = s.p;

theorem :: SCMFSA_1:23
  for s being SCM+FSA-State, u,v being Element of NAT holds SCM+FSA-Chg(
  s,u).v = s.v;

theorem :: SCMFSA_1:24
  for s being SCM+FSA-State, t being Element of SCM+FSA-Data-Loc, u
  being Integer holds SCM+FSA-Chg(s,t,u).NAT = s.NAT;

theorem :: SCMFSA_1:25
  for s being SCM+FSA-State, t being Element of SCM+FSA-Data-Loc, u
  being Integer holds SCM+FSA-Chg(s,t,u).t = u;

theorem :: SCMFSA_1:26
  for s being SCM+FSA-State, t being Element of SCM+FSA-Data-Loc, u
  being Integer, mk being Element of SCM+FSA-Data-Loc st mk <> t holds
  SCM+FSA-Chg(s,t,u).mk = s.mk;

theorem :: SCMFSA_1:27
  for s being SCM+FSA-State, t being Element of SCM+FSA-Data-Loc, u
being Integer, f being Element of SCM+FSA-Data*-Loc holds SCM+FSA-Chg(s,t,u).f
  = s.f;

theorem :: SCMFSA_1:28
  for s being SCM+FSA-State, t being Element of SCM+FSA-Data-Loc, u
  being Integer, v being Element of NAT holds SCM+FSA-Chg(s,t,u).v = s.v;

theorem :: SCMFSA_1:29
  for s being SCM+FSA-State, t being Element of SCM+FSA-Data*-Loc, u
  being FinSequence of INT holds SCM+FSA-Chg(s,t,u).t = u;

theorem :: SCMFSA_1:30
  for s being SCM+FSA-State, t being Element of SCM+FSA-Data*-Loc, u
  being FinSequence of INT, mk being Element of SCM+FSA-Data*-Loc st mk <> t
  holds SCM+FSA-Chg(s,t,u).mk = s.mk;

theorem :: SCMFSA_1:31
  for s being SCM+FSA-State, t being Element of SCM+FSA-Data*-Loc, u
being FinSequence of INT, a being Element of SCM+FSA-Data-Loc holds SCM+FSA-Chg
  (s,t,u).a = s.a;

theorem :: SCMFSA_1:32
  for s being SCM+FSA-State, t being Element of SCM+FSA-Data*-Loc, u
being FinSequence of INT, v being Element of NAT holds SCM+FSA-Chg(s,t,u).v = s
  .v;

theorem :: SCMFSA_1:33
  SCM+FSA-Data*-Loc misses SCM-Memory;

theorem :: SCMFSA_1:34
 SCM+FSA-Instr c= [:NAT,proj2 SCM+FSA-Instr:];

registration
 cluster proj2 SCM+FSA-Instr -> FinSequence-membered;
end;
