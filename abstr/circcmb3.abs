:: Preliminaries to Automatic Generation of Mizar Documentation for Circuits
::  by Grzegorz Bancerek and Adam Naumowicz
::
:: Received July 26, 2002
:: Copyright (c) 2002 Association of Mizar Users

environ

 vocabulary BOOLE, CIRCCMB3, MSUALG_1, CIRCCOMB, FUNCT_1, FINSEQ_2, AMI_1,
      CIRCUIT1, MSAFREE2, NET_1, TARSKI, ZF_REFLE, PRE_CIRC, FINSET_1, RELAT_1,
      FINSEQ_1, FUNCOP_1, PBOOLE, SEQM_3, CIRCUIT2, PARTFUN1, FUNCT_4,
      SQUARE_1, REWRITE1, CLASSES1, ORDINAL2, CATALG_1, YELLOW_6, FUNCT_5,
      MCART_1, TDGROUP, QC_LANG1, FACIRC_1;
 notation TARSKI, XBOOLE_0, SUBSET_1, NUMBERS, XREAL_0, ENUMSET1, SCMPDS_1,
      ZFMISC_1, RELAT_1, FUNCT_1, FINSET_1, ORDINAL2, CLASSES1, FUNCT_2, NAT_1,
      PARTFUN1, LIMFUNC1, REWRITE1, STRUCT_0, FINSEQ_1, FINSEQ_2, FINSEQOP,
      PBOOLE, GROUP_1, MSUALG_1, FACIRC_1, MSAFREE2, CIRCUIT1, CIRCUIT2,
      CIRCCOMB, PRE_CIRC, MCART_1, BINARITH, FUNCT_5, SEQM_3, YELLOW_6;
 constructors CIRCUIT1, CIRCUIT2, FACIRC_1, REWRITE1, CLASSES1, FINSEQOP,
      PRALG_1, SCMPDS_1, LIMFUNC1, BINARITH, YELLOW_6, SEQM_3, DOMAIN_1;
 clusters MSUALG_1, CIRCCOMB, PRE_CIRC, FINSET_1, CIRCTRM1, RELSET_1, FINSEQ_1,
      FINSEQ_2, PRALG_1, STRUCT_0, SCMPDS_1, FSM_1, XBOOLE_0, ORDINAL1,
      YELLOW_6, MSAFREE, FACIRC_1, MEMBERED, SEQM_3, NUMBERS, ORDINAL2;
 requirements BOOLE, SUBSET, NUMERALS, REAL;


begin :: Stabilizing circuits

theorem :: CIRCCMB3:1
 for S being non void Circuit-like (non empty ManySortedSign)
 for A being non-empty Circuit of S
 for s being State of A, x being set st x in InputVertices S
 for n being Nat holds Following(s,n).x = s.x;

definition
 let S be non void Circuit-like (non empty ManySortedSign);
 let A be non-empty Circuit of S;
 let s be State of A;
 attr s is stabilizing means
:: CIRCCMB3:def 1
 ex n being Nat st Following(s,n) is stable;
end;


definition
 let S be non void Circuit-like (non empty ManySortedSign);
 let A be non-empty Circuit of S;
 attr A is stabilizing means
:: CIRCCMB3:def 2
 for s being State of A holds s is stabilizing;
 attr A is with_stabilization-limit means
:: CIRCCMB3:def 3
   ex n being Nat st
 for s being State of A holds Following(s,n) is stable;
end;


registration
 let S be non void Circuit-like (non empty ManySortedSign);
 cluster with_stabilization-limit -> stabilizing (non-empty Circuit of S);
 coherence
  proof let A be non-empty Circuit of S;
   given n being Nat such that
A1: for s being State of A holds Following(s,n) is stable;
   let s be State of A; take n; thus thesis by A1;
  end;
end;


definition
 let S be non void Circuit-like (non empty ManySortedSign);
 let A be non-empty Circuit of S;
 let s be State of A such that  s is stabilizing;
 func Result s -> State of A means
:: CIRCCMB3:def 4
 it is stable & ex n being Nat st it = Following(s,n);
end;


definition
 let S be non void Circuit-like (non empty ManySortedSign);
 let A be non-empty Circuit of S;
 let s be State of A such that  s is stabilizing;
 func stabilization-time s -> Nat means
:: CIRCCMB3:def 5
 Following(s,it) is stable & for n being Nat st n < it holds
 not Following(s,n) is stable;
end;


theorem :: CIRCCMB3:2
 for S being non void Circuit-like (non empty ManySortedSign)
 for A being non-empty Circuit of S
 for s being State of A st s is stabilizing holds
   Result s = Following(s,stabilization-time s);

theorem :: CIRCCMB3:3
   for S being non void Circuit-like (non empty ManySortedSign)
 for A being non-empty Circuit of S
 for s being State of A, n being Nat st Following(s,n) is stable
  holds stabilization-time s <= n;

theorem :: CIRCCMB3:4
 for S being non void Circuit-like (non empty ManySortedSign)
 for A being non-empty Circuit of S
 for s being State of A, n being Nat st Following(s,n) is stable
  holds Result s = Following(s, n);

theorem :: CIRCCMB3:5
 for S being non void Circuit-like (non empty ManySortedSign)
 for A being non-empty Circuit of S
 for s being State of A, n being Nat
  st s is stabilizing & n >= stabilization-time s
  holds Result s = Following(s, n);

theorem :: CIRCCMB3:6
   for S being non void Circuit-like (non empty ManySortedSign)
 for A being non-empty Circuit of S
 for s being State of A st s is stabilizing
 for x being set st x in InputVertices S
  holds (Result s).x = s.x;

theorem :: CIRCCMB3:7
   for S1,S being non void Circuit-like (non empty ManySortedSign)
 for A1 being non-empty Circuit of S1
 for A being non-empty Circuit of S
 for s being State of A
 for s1 being State of A1 st s1 = s|the carrier of S1
 for v1 being Vertex of S1 holds s1.v1 = s.v1;

theorem :: CIRCCMB3:8
 for S1,S2 being non void Circuit-like (non empty ManySortedSign) st
 InputVertices S1 misses InnerVertices S2 &
 InputVertices S2 misses InnerVertices S1
 for S being non void Circuit-like (non empty ManySortedSign) st S=S1 +* S2
 for A1 being non-empty Circuit of S1
 for A2 being non-empty Circuit of S2 st
 A1 tolerates A2
 for A being non-empty Circuit of S st A = A1 +* A2
 for s being State of A
 for s1 being State of A1
 for s2 being State of A2 st
 s1=s|the carrier of S1 & s2=s|the carrier of S2 &
 s1 is stabilizing & s2 is stabilizing holds s is stabilizing;

theorem :: CIRCCMB3:9
   for S1,S2 being non void Circuit-like (non empty ManySortedSign) st
 InputVertices S1 misses InnerVertices S2 &
 InputVertices S2 misses InnerVertices S1
 for S being non void Circuit-like (non empty ManySortedSign) st S=S1 +* S2
 for A1 being non-empty Circuit of S1
 for A2 being non-empty Circuit of S2 st
 A1 tolerates A2
 for A being non-empty Circuit of S st A = A1 +* A2
 for s being State of A
 for s1 being State of A1 st s1=s|the carrier of S1 & s1 is stabilizing
 for s2 being State of A2 st s2=s|the carrier of S2 & s2 is stabilizing holds
 stabilization-time(s) = max (stabilization-time s1,stabilization-time s2);

theorem :: CIRCCMB3:10
 for S1,S2 being non void Circuit-like (non empty ManySortedSign) st
 InputVertices S1 misses InnerVertices S2
 for S being non void Circuit-like (non empty ManySortedSign) st S=S1 +* S2
 for A1 being non-empty Circuit of S1
 for A2 being non-empty Circuit of S2 st
 A1 tolerates A2
 for A being non-empty Circuit of S st A = A1 +* A2
 for s being State of A
 for s1 being State of A1 st s1 = s|the carrier of S1 & s1 is stabilizing
 for s2 being State of A2
  st s2 = Following(s, stabilization-time s1)|the carrier of S2 &
     s2 is stabilizing
  holds s is stabilizing;

theorem :: CIRCCMB3:11
 for S1,S2 being non void Circuit-like (non empty ManySortedSign) st
 InputVertices S1 misses InnerVertices S2
 for S being non void Circuit-like (non empty ManySortedSign) st S = S1+*S2
 for A1 being non-empty Circuit of S1
 for A2 being non-empty Circuit of S2 st
 A1 tolerates A2
 for A being non-empty Circuit of S st A = A1 +* A2
 for s being State of A
 for s1 being State of A1 st s1 = s|the carrier of S1 & s1 is stabilizing
 for s2 being State of A2
  st s2 = Following(s, stabilization-time s1)|the carrier of S2 &
     s2 is stabilizing
  holds stabilization-time(s) = (stabilization-time s1)+(stabilization-time s2)
;

theorem :: CIRCCMB3:12
   for S1,S2,S being non void Circuit-like (non empty ManySortedSign)
  st InputVertices S1 misses InnerVertices S2 & S = S1+*S2
 for A1 being non-empty Circuit of S1, A2 being non-empty Circuit of S2
 for A being non-empty Circuit of S
  st A1 tolerates A2 & A = A1+*A2
 for s being State of A, s1 be State of A1
  st s1 = s|the carrier of S1 & s1 is stabilizing
 for s2 being State of A2
  st s2 = Following(s, stabilization-time s1)|the carrier of S2 &
     s2 is stabilizing
  holds (Result s)|the carrier of S1 = Result s1;

begin :: One-gate circuits

theorem :: CIRCCMB3:13
 for x being set, X being non empty finite set
 for n being Nat
 for p being FinSeqLen of n
 for g being Function of n-tuples_on X, X
 for s being State of 1GateCircuit(p,g) holds
 s*p is Element of n-tuples_on X;

theorem :: CIRCCMB3:14
 for x1,x2,x3,x4 being set holds
 rng <*x1,x2,x3,x4*> = {x1,x2,x3,x4};

theorem :: CIRCCMB3:15
 for x1,x2,x3,x4,x5 being set holds
 rng <*x1,x2,x3,x4,x5*> = {x1,x2,x3,x4,x5};

definition
 let x1,x2,x3,x4 be set;
 redefine func <*x1,x2,x3,x4*> -> FinSeqLen of 4;
 let x5 be set;
 redefine func <*x1,x2,x3,x4,x5*> -> FinSeqLen of 5;
end;


definition
 let S be ManySortedSign;
 attr S is one-gate means
:: CIRCCMB3:def 6
  ex X being non empty finite set, n being Nat, p being FinSeqLen of n,
  f being Function of n-tuples_on X,X st
  S = 1GateCircStr(p,f);
end;


definition
 let S be non empty ManySortedSign;
 let A be MSAlgebra over S;
 attr A is one-gate means
:: CIRCCMB3:def 7
  ex X being non empty finite set, n being Nat, p being FinSeqLen of n,
  f being Function of n-tuples_on X,X st
  S = 1GateCircStr(p,f) & A = 1GateCircuit(p,f);
end;


registration
 let p being FinSequence, x be set;
 cluster 1GateCircStr(p,x) -> finite;
 coherence
  proof
      the carrier of 1GateCircStr(p,x) = (rng p) \/ {[p,x]} by CIRCCOMB:def 6;
   hence thesis by GROUP_1:def 13;
  end;
end;


registration
 cluster one-gate -> strict non void non empty unsplit gate`1=arity
 finite ManySortedSign;
 coherence
  proof
   let S be ManySortedSign;
   assume S is one-gate;
   then ex X being non empty finite set, n being Nat, p being FinSeqLen of n,
   f being Function of n-tuples_on X,X st S = 1GateCircStr(p,f) by Def6;
   hence thesis;
  end;
end;


registration
 cluster one-gate -> gate`2=den (non empty ManySortedSign);
 coherence
  proof
   let S be non empty ManySortedSign;
   assume S is one-gate;
   then ex X being non empty finite set, n being Nat, p being FinSeqLen of n,
   f being Function of n-tuples_on X,X st S = 1GateCircStr(p,f) by Def6;
   hence thesis;
  end;
end;


registration
 let X be non empty finite set,
     n be Nat, p be FinSeqLen of n,
     f be Function of n-tuples_on X,X;
 cluster 1GateCircStr(p,f) -> one-gate;
 coherence by Def6;
end;


registration
 cluster one-gate ManySortedSign;
 existence
  proof
   consider X being non empty finite set, n being Nat, p being FinSeqLen of n,
   f being Function of n-tuples_on X,X;
   take 1GateCircStr(p,f);
   thus thesis;
  end;
end;


registration
 let S be one-gate ManySortedSign;
 cluster one-gate -> strict non-empty Circuit of S;
 coherence
  proof
   let A be Circuit of S;
   assume A is one-gate;
   then ex X being non empty finite set, n being Nat, p being FinSeqLen of n,
   f being Function of n-tuples_on X,X st
   S = 1GateCircStr(p,f) & A = 1GateCircuit(p,f) by Def7;
   hence thesis;
  end;
end;


registration
 let X be non empty finite set,
     n be Nat, p be FinSeqLen of n,
     f be Function of n-tuples_on X,X;
 cluster 1GateCircuit(p,f) -> one-gate;
 coherence by Def7;
end;


registration
 let S be one-gate ManySortedSign;
 cluster one-gate non-empty Circuit of S;
 existence
  proof
   consider X being non empty finite set, n being Nat, p being FinSeqLen of n,
   f being Function of n-tuples_on X,X such that
 A1: S = 1GateCircStr(p,f) by Def6;
   reconsider A = 1GateCircuit(p,f) as locally-finite MSAlgebra over S by A1;
   take A;
   thus thesis by A1;
  end;
end;


definition
 let S be one-gate ManySortedSign;
 func Output S -> Vertex of S equals
:: CIRCCMB3:def 8
union the OperSymbols of S;
end;


registration
 let S be one-gate ManySortedSign;
 cluster Output S -> pair;
 coherence
  proof
   consider X being non empty finite set, n being Nat, p being FinSeqLen of n,
   f being Function of n-tuples_on X,X such that
A1: S = 1GateCircStr(p,f) by Def6;
A2: the OperSymbols of S = {[p,f]} by A1,CIRCCOMB:def 6;
     Output S = union the OperSymbols of S by Def8 .= [p,f] by A2,ZFMISC_1:31;
   hence thesis;
  end;
end;


theorem :: CIRCCMB3:16
 for S being one-gate ManySortedSign,
 p being FinSequence, x being set st S = 1GateCircStr(p,x) holds
 Output S = [p,x];

theorem :: CIRCCMB3:17
 for S being one-gate ManySortedSign holds InnerVertices S = {Output S};

theorem :: CIRCCMB3:18
   for S being one-gate ManySortedSign
 for A being one-gate Circuit of S
 for n being Nat
 for X being finite non empty set
 for f being Function of n-tuples_on X, X, p being FinSeqLen of n st
 A = 1GateCircuit(p,f) holds S = 1GateCircStr(p,f);

theorem :: CIRCCMB3:19
   for n being Nat
 for X being finite non empty set
 for f being Function of n-tuples_on X, X, p being FinSeqLen of n
 for s being State of 1GateCircuit(p,f) holds
 (Following s).Output 1GateCircStr(p,f) = f.(s*p);

theorem :: CIRCCMB3:20
 for S being one-gate ManySortedSign
 for A being one-gate Circuit of S
 for s being State of A holds Following s is stable;

registration
 let S be non void Circuit-like (non empty ManySortedSign);
 cluster one-gate -> with_stabilization-limit (non-empty Circuit of S);
 coherence
  proof
   let A be non-empty Circuit of S;
   assume A1: A is one-gate;
   then consider X being non empty finite set, n being Nat, p being FinSeqLen
of n,
   f being Function of n-tuples_on X,X such that
A2: S = 1GateCircStr(p,f) & A = 1GateCircuit(p,f) by Def7;
   reconsider S1=S as one-gate ManySortedSign by A2;
   reconsider A1=A as one-gate Circuit of S1 by A1;
   take 1; let s be State of A;
   reconsider s1=s as State of A1;
     Following s1 is stable by Th20;
   hence thesis by FACIRC_1:14;
  end;
end;


theorem :: CIRCCMB3:21
 for S being one-gate ManySortedSign
 for A being one-gate Circuit of S
 for s being State of A holds
 Result s = Following s;

theorem :: CIRCCMB3:22
 for S being one-gate ManySortedSign
 for A being one-gate Circuit of S
 for s being State of A holds
 stabilization-time s <= 1;

scheme :: CIRCCMB3:sch 1
 OneGate1Ex {x()->set,X()->non empty finite set,f(set)->Element of X()}:
 ex S being one-gate ManySortedSign,
 A being one-gate Circuit of S st
 InputVertices S = {x()} & for s being State of A holds
 (Result s).(Output S) = f(s.x())
proof
   deffunc F(Element of 1-tuples_on X()) = f($1.1);
   consider g being Function of 1-tuples_on X(), X() such that
A1: for a being Element of 1-tuples_on X() holds g.a = F(a) from FUNCT_2:sch 4;
   reconsider S = 1GateCircStr(<*x()*>,g) as one-gate ManySortedSign;
   take S;
   reconsider A = 1GateCircuit(<*x()*>,g) as one-gate Circuit of S;
   take A;
     rng <*x()*> = {x()} by FINSEQ_1:55;
   hence InputVertices S = {x()} by CIRCCOMB:49;
   let s be State of A;
   reconsider sx = s*<*x()*> as Element of 1-tuples_on X() by Th13;
     dom <*x()*> = Seg 1 by FINSEQ_1:55;
then A2: 1 in dom <*x()*> by FINSEQ_1:3;
   thus (Result s).Output S = (Following s).(Output S) by Th21
   .= (Following s).[<*x()*>,g] by Th16
   .= g.(s*<*x()*>) by CIRCCOMB:64
   .= f(sx.1) by A1
   .= f(s.(<*x()*>.1)) by A2,FUNCT_1:23
   .= f(s.x()) by FINSEQ_1:def 8;
  end;

scheme :: CIRCCMB3:sch 2
 OneGate2Ex {x1,x2()->set,X()->non empty finite set,
                   f(set,set)->Element of X()}:
 ex S being one-gate ManySortedSign,
 A being one-gate Circuit of S st
 InputVertices S = {x1(),x2()} & for s being State of A holds
 (Result s).(Output S) = f(s.x1(),s.x2())
proof
   deffunc F(Element of 2-tuples_on X()) = f($1.1,$1.2);
   consider g being Function of 2-tuples_on X(), X() such that
A1: for a being Element of 2-tuples_on X() holds g.a = F(a) from FUNCT_2:sch 4;
   reconsider S = 1GateCircStr(<*x1(),x2()*>,g) as one-gate ManySortedSign;
   take S;
   reconsider A = 1GateCircuit(<*x1(),x2()*>,g) as one-gate Circuit of S;
   take A;
     rng <*x1(),x2()*> = {x1(),x2()} by FINSEQ_2:147;
   hence InputVertices S = {x1(),x2()} by CIRCCOMB:49;
   let s be State of A;
   reconsider sx = s*<*x1(),x2()*> as Element of 2-tuples_on X() by Th13;
     dom <*x1(),x2()*> = Seg 2 by FINSEQ_3:29;
then A2: 1 in dom <*x1(),x2()*> & 2 in dom <*x1(),x2()*> by FINSEQ_1:3;
     Result s = Following s by Th21;
   hence (Result s).(Output S) = (Following s).[<*x1(),x2()*>,g] by Th16
   .= g.(s*<*x1(),x2()*>) by CIRCCOMB:64
   .= f(sx.1,sx.2) by A1
   .= f(s.(<*x1(),x2()*>.1),sx.2) by A2,FUNCT_1:23
   .= f(s.(<*x1(),x2()*>.1),s.(<*x1(),x2()*>.2)) by A2,FUNCT_1:23
   .= f(s.x1(),s.(<*x1(),x2()*>.2)) by FINSEQ_1:61
   .= f(s.x1(),s.x2()) by FINSEQ_1:61;
  end;

scheme :: CIRCCMB3:sch 3
 OneGate3Ex {x1,x2,x3()->set,X()->non empty finite set,
                   f(set,set,set)->Element of X()}:
 ex S being one-gate ManySortedSign,
 A being one-gate Circuit of S st
 InputVertices S = {x1(),x2(),x3()} & for s being State of A holds
 (Result s).(Output S) = f(s.x1(),s.x2(),s.x3())
proof
   deffunc F(Element of 3-tuples_on X()) = f($1.1,$1.2,$1.3);
   consider g being Function of 3-tuples_on X(), X() such that
A1: for a being Element of 3-tuples_on X() holds g.a = F(a) from FUNCT_2:sch 4;
   reconsider
   S = 1GateCircStr(<*x1(),x2(),x3()*>,g) as one-gate ManySortedSign;
   take S;
   reconsider A = 1GateCircuit(<*x1(),x2(),x3()*>,g) as one-gate Circuit of S;
   take A;
     rng <*x1(),x2(),x3()*> = {x1(),x2(),x3()} by FINSEQ_2:148;
   hence InputVertices S = {x1(),x2(),x3()} by CIRCCOMB:49;
   let s be State of A;
   reconsider sx = s*<*x1(),x2(),x3()*> as
   Element of 3-tuples_on X() by Th13;
     dom <*x1(),x2(),x3()*> = Seg 3 by FINSEQ_3:30;
then A2: 1 in dom <*x1(),x2(),x3()*> & 2 in dom <*x1(),x2(),x3()*> &
   3 in dom <*x1(),x2(),x3()*> by FINSEQ_1:3;
     Result s = Following s by Th21;
   hence (Result s).(Output S) = (Following s).[<*x1(),x2(),x3()*>,g] by Th16
   .= g.(s*<*x1(),x2(),x3()*>) by CIRCCOMB:64
   .= f(sx.1,sx.2,sx.3) by A1
   .= f(s.(<*x1(),x2(),x3()*>.1),sx.2,sx.3) by A2,FUNCT_1:23
   .= f(s.x1(),sx.2,sx.3) by FINSEQ_1:62
   .= f(s.x1(),s.(<*x1(),x2(),x3()*>.2),sx.3) by A2,FUNCT_1:23
   .= f(s.x1(),s.x2(),sx.3) by FINSEQ_1:62
   .= f(s.x1(),s.x2(),s.(<*x1(),x2(),x3()*>.3)) by A2,FUNCT_1:23
   .= f(s.x1(),s.x2(),s.x3()) by FINSEQ_1:62;
  end;

scheme :: CIRCCMB3:sch 4
 OneGate4Ex {x1,x2,x3,x4()->set,X()->non empty finite set,
                   f(set,set,set,set)->Element of X()}:
 ex S being one-gate ManySortedSign,
 A being one-gate Circuit of S st
 InputVertices S = {x1(),x2(),x3(),x4()} & for s being State of A holds
 (Result s).(Output S) = f(s.x1(),s.x2(),s.x3(),s.x4())
proof
   deffunc F(Element of 4-tuples_on X()) = f($1.1,$1.2,$1.3,$1.4);
   consider g being Function of 4-tuples_on X(), X() such that
A1: for a being Element of 4-tuples_on X() holds g.a = F(a) from FUNCT_2:sch 4;
   reconsider
   S = 1GateCircStr(<*x1(),x2(),x3(),x4()*>,g) as one-gate ManySortedSign;
   take S;
   reconsider
   A = 1GateCircuit(<*x1(),x2(),x3(),x4()*>,g) as one-gate Circuit of S;
   take A;
     rng <*x1(),x2(),x3(),x4()*> = {x1(),x2(),x3(),x4()} by Th14;
   hence InputVertices S = {x1(),x2(),x3(),x4()} by CIRCCOMB:49;
   let s be State of A;
   reconsider sx = s*<*x1(),x2(),x3(),x4()*> as
   Element of 4-tuples_on X() by Th13;
     dom <*x1(),x2(),x3(),x4()*> = Seg 4 by SCMPDS_1:4;
then A2: 1 in dom <*x1(),x2(),x3(),x4()*> & 2 in dom <*x1(),x2(),x3(),x4()*> &
   3 in dom <*x1(),x2(),x3(),x4()*> & 4 in dom <*x1(),x2(),x3(),x4()*>
   by FINSEQ_1:3;
     Result s = Following s by Th21;
   hence (Result s).(Output S) =
   (Following s).[<*x1(),x2(),x3(),x4()*>,g] by Th16
   .= g.(s*<*x1(),x2(),x3(),x4()*>) by CIRCCOMB:64
   .= f(sx.1,sx.2,sx.3,sx.4) by A1
   .= f(s.(<*x1(),x2(),x3(),x4()*>.1),sx.2,sx.3,sx.4) by A2,FUNCT_1:23
   .= f(s.x1(),sx.2,sx.3,sx.4) by SCMPDS_1:3
   .= f(s.x1(),s.(<*x1(),x2(),x3(),x4()*>.2),sx.3,sx.4) by A2,FUNCT_1:23
   .= f(s.x1(),s.x2(),sx.3,sx.4) by SCMPDS_1:3
   .= f(s.x1(),s.x2(),s.(<*x1(),x2(),x3(),x4()*>.3),sx.4) by A2,FUNCT_1:23
   .= f(s.x1(),s.x2(),s.x3(),sx.4) by SCMPDS_1:3
   .= f(s.x1(),s.x2(),s.x3(),s.(<*x1(),x2(),x3(),x4()*>.4)) by A2,FUNCT_1:23
   .= f(s.x1(),s.x2(),s.x3(),s.x4()) by SCMPDS_1:3;
  end;

scheme :: CIRCCMB3:sch 5
 OneGate5Ex {x1,x2,x3,x4,x5()->set,X()->non empty finite set,
                   f(set,set,set,set,set)->Element of X()}:
 ex S being one-gate ManySortedSign,
 A being one-gate Circuit of S st
 InputVertices S = {x1(),x2(),x3(),x4(),x5()} & for s being State of A holds
 (Result s).(Output S) = f(s.x1(),s.x2(),s.x3(),s.x4(),s.x5())
proof
   deffunc F(Element of 5-tuples_on X()) = f($1.1,$1.2,$1.3,$1.4,$1.5);
   consider g being Function of 5-tuples_on X(), X() such that
A1: for a being Element of 5-tuples_on X() holds g.a = F(a) from FUNCT_2:sch 4;
   reconsider
   S = 1GateCircStr(<*x1(),x2(),x3(),x4(),x5()*>,g) as one-gate ManySortedSign;
   take S;
   reconsider
   A = 1GateCircuit(<*x1(),x2(),x3(),x4(),x5()*>,g) as one-gate Circuit of S;
   take A;
     rng <*x1(),x2(),x3(),x4(),x5()*> = {x1(),x2(),x3(),x4(),x5()} by Th15;
   hence InputVertices S = {x1(),x2(),x3(),x4(),x5()} by CIRCCOMB:49;
   let s be State of A;
   reconsider sx = s*<*x1(),x2(),x3(),x4(),x5()*> as
   Element of 5-tuples_on X() by Th13;
     dom <*x1(),x2(),x3(),x4(),x5()*> = Seg 5 by SCMPDS_1:6;
then A2: 1 in dom <*x1(),x2(),x3(),x4(),x5()*> &
   2 in dom <*x1(),x2(),x3(),x4(),x5()*> &
   3 in dom <*x1(),x2(),x3(),x4(),x5()*> &
   4 in dom <*x1(),x2(),x3(),x4(),x5()*> &
   5 in dom <*x1(),x2(),x3(),x4(),x5()*> by FINSEQ_1:3;
     Result s = Following s by Th21;
   hence (Result s).(Output S) =
   (Following s).[<*x1(),x2(),x3(),x4(),x5()*>,g] by Th16
   .= g.(s*<*x1(),x2(),x3(),x4(),x5()*>) by CIRCCOMB:64
   .= f(sx.1,sx.2,sx.3,sx.4,sx.5) by A1
   .= f(s.(<*x1(),x2(),x3(),x4(),x5()*>.1),sx.2,sx.3,sx.4,sx.5) by A2,FUNCT_1:
23
   .= f(s.x1(),sx.2,sx.3,sx.4,sx.5) by SCMPDS_1:5
   .= f(s.x1(),s.(<*x1(),x2(),x3(),x4(),x5()*>.2),sx.3,sx.4,sx.5)
      by A2,FUNCT_1:23
   .= f(s.x1(),s.x2(),sx.3,sx.4,sx.5) by SCMPDS_1:5
   .= f(s.x1(),s.x2(),s.(<*x1(),x2(),x3(),x4(),x5()*>.3),sx.4,sx.5)
      by A2,FUNCT_1:23
   .= f(s.x1(),s.x2(),s.x3(),sx.4,sx.5) by SCMPDS_1:5
   .= f(s.x1(),s.x2(),s.x3(),s.(<*x1(),x2(),x3(),x4(),x5()*>.4),sx.5)
      by A2,FUNCT_1:23
   .= f(s.x1(),s.x2(),s.x3(),s.x4(),sx.5) by SCMPDS_1:5
   .= f(s.x1(),s.x2(),s.x3(),s.x4(),s.(<*x1(),x2(),x3(),x4(),x5()*>.5))
      by A2,FUNCT_1:23
   .= f(s.x1(),s.x2(),s.x3(),s.x4(),s.x5()) by SCMPDS_1:5;
  end;

begin :: Mono-sorted circuits

theorem :: CIRCCMB3:23
 for f being constant Function
 holds f = (dom f) --> the_value_of f;

theorem :: CIRCCMB3:24
 for X,Y being non empty set, n,m being Nat st
 n<>0 & n-tuples_on X = m-tuples_on Y
 holds X=Y & n=m;

theorem :: CIRCCMB3:25
   for S1,S2 being non empty ManySortedSign
 for v being Vertex of S1 holds v is Vertex of S1+*S2;

theorem :: CIRCCMB3:26
   for S1,S2 being non empty ManySortedSign
 for v being Vertex of S2 holds v is Vertex of S1+*S2;

definition
 let X be non empty finite set;
 mode Signature of X ->
 gate`2=den (non void non empty unsplit gate`1=arity ManySortedSign) means
:: CIRCCMB3:def 9

 ex A being Circuit of it st the Sorts of A is constant &
 the_value_of the Sorts of A = X & A is gate`2=den;
end;


theorem :: CIRCCMB3:27
 for n being Nat, X being non empty finite set
 for f being Function of n-tuples_on X, X
 for p being FinSeqLen of n
  holds 1GateCircStr(p,f) is Signature of X;

registration
 let X be non empty finite set;
 cluster strict one-gate Signature of X;
 existence
  proof
   consider f being Function of 1-tuples_on X, X;
   consider p being FinSeqLen of 1;
      1GateCircStr(p,f) is Signature of X by Th27;
   hence thesis;
  end;
end;


definition let n be Nat; let X be non empty finite set;
 let f be Function of n-tuples_on X, X;
 let p be FinSeqLen of n;
 redefine func 1GateCircStr(p,f) -> strict Signature of X;
end;


definition
 let X be non empty finite set;
 let S be Signature of X;
 mode Circuit of X,S -> Circuit of S means
:: CIRCCMB3:def 10
 it is gate`2=den &
 the Sorts of it is constant & the_value_of the Sorts of it = X;
end;


registration
 let X be non empty finite set;
 let S be Signature of X;
 cluster -> gate`2=den non-empty Circuit of X,S;
 coherence
  proof
   let A be Circuit of X,S;
   thus A is gate`2=den by Def10;
A1: dom the Sorts of A = the carrier of S by PBOOLE:def 3;
  the Sorts of A is non empty constant &
   the_value_of the Sorts of A = X by Def10,PBOOLE:def 3,RELAT_1:60;
   then for i being set st i in dom the Sorts of A holds
    (the Sorts of A).i is non empty by YELLOW_6:def 1;
   then the Sorts of A is non-empty by A1,PBOOLE:def 16;
   hence A is non-empty by MSUALG_1:def 8;
  end;
end;


theorem :: CIRCCMB3:28
 for n being Nat, X being non empty finite set
 for f being Function of n-tuples_on X, X
 for p being FinSeqLen of n
  holds 1GateCircuit(p,f) is Circuit of X, 1GateCircStr(p,f);

registration
 let X be non empty finite set;
 let S be one-gate Signature of X;
 cluster strict one-gate Circuit of X,S;
 existence
  proof
   consider A being Circuit of S such that
A1: the Sorts of A is constant &
   the_value_of the Sorts of A = X & A is gate`2=den by Def9;
   A2: dom the Sorts of A = the carrier of S by PBOOLE:def 3;
   set B=the MSAlgebra of A;
     the Sorts of A is locally-finite by MSAFREE2:def 11;
   then reconsider B as Circuit of S by MSAFREE2:def 11;
     for g being set st g in the OperSymbols of S holds
   g = [g`1, (the Charact of B).g] by A1,CIRCCOMB:def 10;
then B is gate`2=den &
   the Sorts of B is non empty constant & the_value_of the Sorts of B = X
   by A1,CIRCCOMB:def 10,PBOOLE:def 3,RELAT_1:60;
   then reconsider B as Circuit of X,S by Def10;
   take B;
   consider Y being non empty finite set, n being Nat, p being FinSeqLen of n,
   f being Function of n-tuples_on Y,Y such that
A3: S = 1GateCircStr(p,f) by Def6;
   set C = 1GateCircuit(p,f);
   set g=[p,f];
     g in {g} by TARSKI:def 1;
then A4: g in the OperSymbols of S by A3,CIRCCOMB:def 6;
then A5: g = [g`1, (the Charact of B).g] by CIRCCOMB:def 10;
A6: g = [g`1, (the Charact of C).g] by A3,A4,CIRCCOMB:def 10;
     dom ((the Charact of B).g) = dom f by A5,ZFMISC_1:33;
then A7: dom ((the Charact of B).g) = n-tuples_on Y by FUNCT_2:def 1;
     dom (the ResultSort of S) = the OperSymbols of S by FUNCT_2:def 1;
then A8: ((the Sorts of B)*the ResultSort of S).g =
   (the Sorts of B).((the ResultSort of S).g) by A4,FUNCT_1:23;
   consider b being set such that
A9: b in dom the Sorts of B & X = (the Sorts of B).b by A1,A2,RELAT_1:60,
YELLOW_6:def 1;
A10: the Sorts of B = (the carrier of S) --> X by A1,A2,Th23;
     (the ResultSort of S).g in the carrier of S by A4,FUNCT_2:7;
   then (the ResultSort of S).g in dom the Sorts of B by PBOOLE:def 3;
then A11: (the Sorts of B).((the ResultSort of S).g) = X by A1,A9,SEQM_3:def 5;
     (the Charact of B).g is Function of
   (((the Sorts of B)# )*the Arity of S).g,
   ((the Sorts of B)*the ResultSort of S).g
   by A4,MSUALG_1:def 2;
then A12: dom ((the Charact of B).g) = (((the Sorts of B)# )*the Arity of S).g
                        by A8,A11,FUNCT_2:def 1;
A13: dom the Arity of S = the OperSymbols of S by FUNCT_2:def 1;
     (the Arity of S).g in (the carrier of S)* by A4,FUNCT_2:7;
   then reconsider Ag = (the Arity of S).g as FinSequence of the carrier of S
   by FINSEQ_1:def 11;
A14: dom ((the Charact of B).g) = ((the Sorts of B)# ).Ag by A4,A12,A13,FUNCT_1
:23
   .= (len Ag)-tuples_on X by A10,CIRCCOMB:6;
   per cases;
   suppose n <> 0;
   then X = Y by A7,A14,Th24;
then A15: the Sorts of B = the Sorts of 1GateCircuit(p,f) by A3,A10,CIRCCOMB:
def 14;
     now let i be set;
    assume i in the OperSymbols of S;
    then i in {g} by A3,CIRCCOMB:def 6;
    then i = g by TARSKI:def 1;
    hence (the Charact of B).i = (the Charact of C).i by A5,A6,ZFMISC_1:33;
   end;
   hence B is strict one-gate by A3,A15,PBOOLE:3;
   end;
   suppose A16: n = 0;
     (the Charact of B).g is Function of
   (((the Sorts of B)# )*the Arity of S).g,
   ((the Sorts of B)*the ResultSort of S).g
   by A4,MSUALG_1:def 2;
then A17: rng ((the Charact of B).g) c= ((the Sorts of B)*the ResultSort of S).
g
   by RELSET_1:12;
     n-tuples_on X = {<*>X} by A16,FINSEQ_2:112
    .= {<*>Y}
    .= n-tuples_on Y by A16,FINSEQ_2:112;
then A18: dom f = n-tuples_on X by FUNCT_2:def 1;
     (the Charact of B).g = f by A5,ZFMISC_1:33;
   then reconsider h=f as Function of n-tuples_on X,X by A8,A11,A17,A18,FUNCT_2
:4;
   set D = 1GateCircuit(p,h);
A19: g = [g`1, (the Charact of D).g] by A3,A4,CIRCCOMB:def 10;
A20: the Sorts of B = the Sorts of D by A3,A10,CIRCCOMB:def 14;
     now let i be set;
    assume i in the OperSymbols of S;
    then i in {g} by A3,CIRCCOMB:def 6;
    then i = g by TARSKI:def 1;
    hence (the Charact of B).i = (the Charact of D).i by A5,A19,ZFMISC_1:33;
   end;
   hence B is strict one-gate by A3,A20,PBOOLE:3;
  end;
  end;
end;


registration
 let X be non empty finite set;
 let S be Signature of X;
 cluster strict Circuit of X,S;
 existence
  proof
   consider A being Circuit of S such that
A1: the Sorts of A is constant &
   the_value_of the Sorts of A = X & A is gate`2=den by Def9;
   set B=the MSAlgebra of A;
     the Sorts of A is locally-finite by MSAFREE2:def 11;
   then reconsider B as Circuit of S by MSAFREE2:def 11;
     for g being set st g in the OperSymbols of S holds
   g = [g`1, (the Charact of B).g] by A1,CIRCCOMB:def 10;
   then B is gate`2=den &
   the Sorts of B is constant & the_value_of the Sorts of B = X
   by A1,CIRCCOMB:def 10;
   then reconsider B as Circuit of X,S by Def10;
   take B;
   thus thesis;
  end;
end;


definition let n be Nat; let X be non empty finite set;
 let f be Function of n-tuples_on X, X;
 let p be FinSeqLen of n;
 redefine func 1GateCircuit(p,f) -> strict Circuit of X,1GateCircStr(p,f);
end;


canceled;

theorem :: CIRCCMB3:30
 for X being non empty finite set
 for S1, S2 being Signature of X
 for A1 being Circuit of X,S1
 for A2 being Circuit of X,S2
  holds A1 tolerates A2;

theorem :: CIRCCMB3:31
 for X being non empty finite set
 for S1, S2 being Signature of X
 for A1 being Circuit of X,S1
 for A2 being Circuit of X,S2
  holds A1+*A2 is Circuit of S1+*S2;

theorem :: CIRCCMB3:32
 for X being non empty finite set
 for S1, S2 being Signature of X
 for A1 being Circuit of X,S1
 for A2 being Circuit of X,S2
  holds A1+*A2 is gate`2=den;

theorem :: CIRCCMB3:33
 for X being non empty finite set
 for S1, S2 being Signature of X
 for A1 being Circuit of X,S1
 for A2 being Circuit of X,S2
  holds the Sorts of A1+*A2 is constant &
        the_value_of the Sorts of A1+*A2 = X;

registration
 let S1,S2 be finite non empty ManySortedSign;
 cluster S1+*S2 -> finite;
 coherence
  proof
      the carrier of S1+*S2 = (the carrier of S1) \/ the carrier of S2
     by CIRCCOMB:def 2;
   hence thesis by GROUP_1:def 13;
  end;
end;


registration let X be non empty finite set;
 let S1,S2 be Signature of X;
 cluster S1+*S2 -> gate`2=den;
 coherence
  proof consider A1 be Circuit of S1 such that
A1: the Sorts of A1 is constant &
    the_value_of the Sorts of A1 = X & A1 is gate`2=den by Def9;
   reconsider A1 as Circuit of X,S1 by A1,Def10;
   consider A2 be Circuit of S2 such that
A2: the Sorts of A2 is constant &
    the_value_of the Sorts of A2 = X & A2 is gate`2=den by Def9;
   reconsider A2 as Circuit of X,S2 by A2,Def10;
      A1+*A2 is gate`2=den by Th32;
   hence thesis by CIRCCOMB:def 11;
  end;
end;


definition let X be non empty finite set;
 let S1,S2 be Signature of X;
 redefine func S1+*S2 -> strict Signature of X;
end;


definition let X be non empty finite set;
 let S1,S2 be Signature of X;
 let A1 be Circuit of X,S1;
 let A2 be Circuit of X,S2;
 redefine func A1+*A2 -> strict Circuit of X,S1+*S2;
end;


theorem :: CIRCCMB3:34
for x,y being set holds
the_rank_of x in the_rank_of [x,y] & the_rank_of y in the_rank_of [x,y];

theorem :: CIRCCMB3:35
 for S being gate`2=den finite
 (non void non empty unsplit gate`1=arity ManySortedSign)
 for A being non-empty Circuit of S st A is gate`2=den holds
 A is with_stabilization-limit;

registration
 let X be non empty finite set;
 let S be finite Signature of X;
 cluster -> with_stabilization-limit Circuit of X,S;
 coherence by Th35;
end;


scheme :: CIRCCMB3:sch 6
 1AryDef {X()-> non empty set,F(set) -> Element of X()}:
 (ex f being Function of 1-tuples_on X(), X() st
  for x being Element of X() holds f.<*x*> = F(x)) &
 for f1,f2 being Function of 1-tuples_on X(), X() st
  (for x being Element of X() holds f1.<*x*> = F(x)) &
  (for x being Element of X() holds f2.<*x*> = F(x))
 holds f1 = f2
proof
    deffunc f(Element of 1-tuples_on X()) = F($1.1);
    consider f being Function of 1-tuples_on X(), X() such that
A1: for a being Element of 1-tuples_on X() holds f.a = f(a) from FUNCT_2:sch 4;
   hereby take f; let x be Element of X();
    reconsider a = <*x*> as Element of 1-tuples_on X();
    thus f.<*x*> = F(a.1) by A1
       .= F(x) by FINSEQ_1:57;
   end;
   let f1,f2 be Function of 1-tuples_on X(), X() such that
A2: for x being Element of X() holds f1.<*x*> = F(x) and
A3: for x being Element of X() holds f2.<*x*> = F(x);
      now let a be Element of 1-tuples_on X();
     consider x being Element of X() such that
A4:   a = <*x*> by FINSEQ_2:117;
     thus f1.a = F(x) by A2,A4 .= f2.a by A3,A4;
    end;
   hence f1 = f2 by FUNCT_2:113;
  end;

scheme :: CIRCCMB3:sch 7
 2AryDef {X()-> non empty set,F(set,set) -> Element of X()}:
 (ex f being Function of 2-tuples_on X(), X() st
  for x,y being Element of X() holds f.<*x,y*> = F(x,y)) &
 for f1,f2 being Function of 2-tuples_on X(), X() st
  (for x,y being Element of X() holds f1.<*x,y*> = F(x,y)) &
  (for x,y being Element of X() holds f2.<*x,y*> = F(x,y))
 holds f1 = f2
proof
    deffunc f(Element of 2-tuples_on X()) = F($1.1,$1.2);
    consider f being Function of 2-tuples_on X(), X() such that
A1: for a being Element of 2-tuples_on X() holds f.a = f(a) from FUNCT_2:sch 4;
   hereby take f; let x,y be Element of X();
    reconsider a = <*x,y*> as Element of 2-tuples_on X() by FINSEQ_2:121;
    thus f.<*x,y*> = F(a.1,a.2) by A1
       .= F(x,a.2) by FINSEQ_1:61
       .= F(x,y) by FINSEQ_1:61;
   end;
   let f1,f2 be Function of 2-tuples_on X(), X() such that
A2: for x,y being Element of X() holds f1.<*x,y*> = F(x,y) and
A3: for x,y being Element of X() holds f2.<*x,y*> = F(x,y);
      now let a be Element of 2-tuples_on X();
     consider x,y being Element of X() such that
A4:   a = <*x,y*> by FINSEQ_2:120;
     thus f1.a = F(x,y) by A2,A4 .= f2.a by A3,A4;
    end;
   hence f1 = f2 by FUNCT_2:113;
  end;

scheme :: CIRCCMB3:sch 8
 3AryDef {X()-> non empty set,F(set,set,set) -> Element of X()}:
 (ex f being Function of 3-tuples_on X(), X() st
  for x,y,z being Element of X() holds f.<*x,y,z*> = F(x,y,z)) &
 for f1,f2 being Function of 3-tuples_on X(), X() st
  (for x,y,z being Element of X() holds f1.<*x,y,z*> = F(x,y,z)) &
  (for x,y,z being Element of X() holds f2.<*x,y,z*> = F(x,y,z))
 holds f1 = f2
proof
    deffunc f(Element of 3-tuples_on X()) = F($1.1,$1.2,$1.3);
    consider f being Function of 3-tuples_on X(), X() such that
A1: for a being Element of 3-tuples_on X() holds f.a = f(a) from FUNCT_2:sch 4;
   hereby take f; let x,y,z be Element of X();
    reconsider a = <*x,y,z*> as Element of 3-tuples_on X() by FINSEQ_2:124;
    thus f.<*x,y,z*> = F(a.1,a.2,a.3) by A1
       .= F(x,a.2,a.3) by FINSEQ_1:62
       .= F(x,y,a.3) by FINSEQ_1:62
       .= F(x,y,z) by FINSEQ_1:62;
   end;
   let f1,f2 be Function of 3-tuples_on X(), X() such that
A2: for x,y,z being Element of X() holds f1.<*x,y,z*> = F(x,y,z) and
A3: for x,y,z being Element of X() holds f2.<*x,y,z*> = F(x,y,z);
      now let a be Element of 3-tuples_on X();
     consider x,y,z being Element of X() such that
A4:   a = <*x,y,z*> by FINSEQ_2:123;
     thus f1.a = F(x,y,z) by A2,A4 .= f2.a by A3,A4;
    end;
   hence f1 = f2 by FUNCT_2:113;
  end;

theorem :: CIRCCMB3:36
 for f being Function, x being set st x in dom f
  holds f*<*x*> = <*f.x*>;

theorem :: CIRCCMB3:37
 for f being Function for x1,x2,x3,x4 being set st
  x1 in dom f & x2 in dom f & x3 in dom f & x4 in dom f holds
   f*<*x1,x2,x3,x4*> = <*f.x1,f.x2,f.x3,f.x4*>;

theorem :: CIRCCMB3:38
 for f being Function for x1,x2,x3,x4,x5 being set st
  x1 in dom f & x2 in dom f & x3 in dom f & x4 in dom f & x5 in dom f holds
   f*<*x1,x2,x3,x4,x5*> = <*f.x1,f.x2,f.x3,f.x4,f.x5*>;

scheme :: CIRCCMB3:sch 9
 OneGate1Result
 {x1()-> set, B()-> non empty finite set, F(set)->Element of B(),
  f() -> Function of 1-tuples_on B(), B()}:
 for s being State of 1GateCircuit(<*x1()*>,f())
 for a1 being Element of B() st a1 = s.x1()
  holds
   (Result s).Output(1GateCircStr(<*x1()*>,f())) = F(a1)
provided
 for g being Function of 1-tuples_on B(), B() holds
   g = f() iff for a1 being Element of B() holds g.<*a1*> = F(a1)
proof   let s be State of 1GateCircuit(<*x1()*>,f());
   let a1 be Element of B() such that
A2: a1 = s.x1();
   set S = 1GateCircStr(<*x1()*>,f());
      dom s = the carrier of S by CIRCUIT1:4
         .= (rng <*x1()*>) \/ {[<*x1()*>,f()]} by CIRCCOMB:def 6
         .= {x1()} \/ {[<*x1()*>,f()]} by FINSEQ_1:55
         .= {x1(),[<*x1()*>,f()]} by ENUMSET1:41;
    then x1() in dom s by TARSKI:def 2;
then A3: s*<*x1()*> = <*a1*> by A2,Th36;
   thus (Result s).Output S = (Following s).(Output S) by Th21
     .= (Following s).[<*x1()*>,f()] by Th16
     .= f().(s*<*x1()*>) by CIRCCOMB:64
     .= F(a1) by A1,A3;
  end;

scheme :: CIRCCMB3:sch 10
 OneGate2Result
 {x1,x2()-> set, B()-> non empty finite set, F(set,set)->Element of B(),
  f() -> Function of 2-tuples_on B(), B()}:
 for s being State of 1GateCircuit(<*x1(),x2()*>,f())
 for a1, a2 being Element of B() st a1 = s.x1() & a2 = s.x2()
  holds
   (Result s).Output(1GateCircStr(<*x1(),x2()*>,f())) = F(a1,a2)
provided
 for g being Function of 2-tuples_on B(), B() holds
   g = f() iff for a1,a2 being Element of B() holds g.<*a1,a2*> = F(a1,a2)
proof   let s be State of 1GateCircuit(<*x1(),x2()*>,f());
   let a1,a2 be Element of B() such that
A2: a1 = s.x1() & a2 = s.x2();
   set S = 1GateCircStr(<*x1(),x2()*>,f());
      dom s = the carrier of S by CIRCUIT1:4
         .= (rng <*x1(),x2()*>) \/ {[<*x1(),x2()*>,f()]} by CIRCCOMB:def 6
         .= {x1(),x2()} \/ {[<*x1(),x2()*>,f()]} by FINSEQ_2:147
         .= {x1(),x2(),[<*x1(),x2()*>,f()]} by ENUMSET1:43;
    then x1() in dom s & x2() in dom s by ENUMSET1:14;
then A3: s*<*x1(),x2()*> = <*a1,a2*> by A2,FINSEQ_2:145;
   thus (Result s).Output S = (Following s).(Output S) by Th21
     .= (Following s).[<*x1(),x2()*>,f()] by Th16
     .= f().(s*<*x1(),x2()*>) by CIRCCOMB:64
     .= F(a1,a2) by A1,A3;
  end;

scheme :: CIRCCMB3:sch 11
 OneGate3Result
 {x1,x2,x3()-> set, B()-> non empty finite set,
  F(set,set,set)->Element of B(),
  f() -> Function of 3-tuples_on B(), B()}:
 for s being State of 1GateCircuit(<*x1(),x2(),x3()*>,f())
 for a1, a2, a3 being Element of B() st a1 = s.x1() & a2 = s.x2() & a3 = s.x3()
  holds
   (Result s).Output(1GateCircStr(<*x1(),x2(),x3()*>,f())) = F(a1,a2,a3)
provided
 for g being Function of 3-tuples_on B(), B() holds g = f() iff
   for a1,a2,a3 being Element of B() holds g.<*a1,a2,a3*> = F(a1,a2,a3)
proof   let s be State of 1GateCircuit(<*x1(),x2(),x3()*>,f());
   let a1,a2,a3 be Element of B() such that
A2: a1 = s.x1() & a2 = s.x2() & a3 = s.x3();
   set S = 1GateCircStr(<*x1(),x2(),x3()*>,f());
      dom s = the carrier of S by CIRCUIT1:4
         .= (rng <*x1(),x2(),x3()*>) \/ {[<*x1(),x2(),x3()*>,f()]}
           by CIRCCOMB:def 6
         .= {x1(),x2(),x3()} \/ {[<*x1(),x2(),x3()*>,f()]} by FINSEQ_2:148
         .= {x1(),x2(),x3(),[<*x1(),x2(),x3()*>,f()]} by ENUMSET1:46;
    then x1() in dom s & x2() in dom s & x3() in dom s by ENUMSET1:19;
then A3: s*<*x1(),x2(),x3()*> = <*a1,a2,a3*> by A2,FINSEQ_2:146;
   thus (Result s).Output S = (Following s).(Output S) by Th21
     .= (Following s).[<*x1(),x2(),x3()*>,f()] by Th16
     .= f().(s*<*x1(),x2(),x3()*>) by CIRCCOMB:64
     .= F(a1,a2,a3) by A1,A3;
  end;

scheme :: CIRCCMB3:sch 12
 OneGate4Result
 {x1,x2,x3,x4()-> set, B()-> non empty finite set,
  F(set,set,set,set)->Element of B(),
  f() -> Function of 4-tuples_on B(), B()}:
 for s being State of 1GateCircuit(<*x1(),x2(),x3(),x4()*>,f())
 for a1, a2, a3, a4 being Element of B()
  st a1 = s.x1() & a2 = s.x2() & a3 = s.x3() & a4 = s.x4()
  holds
  (Result s).Output(1GateCircStr(<*x1(),x2(),x3(),x4()*>,f())) = F(a1,a2,a3,a4)
provided
 for g being Function of 4-tuples_on B(), B() holds g = f() iff
   for a1,a2,a3,a4 being Element of B()
    holds g.<*a1,a2,a3,a4*> = F(a1,a2,a3,a4)
proof   let s be State of 1GateCircuit(<*x1(),x2(),x3(),x4()*>,f());
   let a1,a2,a3,a4 be Element of B() such that
A2: a1 = s.x1() & a2 = s.x2() & a3 = s.x3() & a4 = s.x4();
   set S = 1GateCircStr(<*x1(),x2(),x3(),x4()*>,f());
      dom s = the carrier of S by CIRCUIT1:4
         .= (rng <*x1(),x2(),x3(),x4()*>) \/ {[<*x1(),x2(),x3(),x4()*>,f()]}
           by CIRCCOMB:def 6
         .= {x1(),x2(),x3(),x4()} \/ {[<*x1(),x2(),x3(),x4()*>,f()]} by Th14
         .= {[<*x1(),x2(),x3(),x4()*>,f()],x1(),x2(),x3(),x4()} by ENUMSET1:47;
         then x1() in dom s & x2() in dom s & x3() in dom s & x4() in dom s
    by ENUMSET1:24;
then A3: s*<*x1(),x2(),x3(),x4()*> = <*a1,a2,a3,a4*> by A2,Th37;
   thus (Result s).Output S = (Following s).(Output S) by Th21
     .= (Following s).[<*x1(),x2(),x3(),x4()*>,f()] by Th16
     .= f().(s*<*x1(),x2(),x3(),x4()*>) by CIRCCOMB:64
     .= F(a1,a2,a3,a4) by A1,A3;
  end;

scheme :: CIRCCMB3:sch 13
 OneGate5Result
 {x1,x2,x3,x4,x5()-> set, B()-> non empty finite set,
  F(set,set,set,set,set)->Element of B(),
  f() -> Function of 5-tuples_on B(), B()}:
 for s being State of 1GateCircuit(<*x1(),x2(),x3(),x4(),x5()*>,f())
 for a1, a2, a3, a4, a5 being Element of B()
  st a1 = s.x1() & a2 = s.x2() & a3 = s.x3() & a4 = s.x4() & a5 = s.x5()
  holds
   (Result s).Output(1GateCircStr(<*x1(),x2(),x3(),x4(),x5()*>,f()))
     = F(a1,a2,a3,a4,a5)
provided
 for g being Function of 5-tuples_on B(), B() holds g = f() iff
   for a1,a2,a3,a4,a5 being Element of B()
    holds g.<*a1,a2,a3,a4,a5*> = F(a1,a2,a3,a4,a5)
proof   let s be State of 1GateCircuit(<*x1(),x2(),x3(),x4(),x5()*>,f());
   let a1,a2,a3,a4,a5 be Element of B() such that
A2: a1 = s.x1() & a2 = s.x2() & a3 = s.x3() & a4 = s.x4() & a5 = s.x5();
   set S = 1GateCircStr(<*x1(),x2(),x3(),x4(),x5()*>,f());
      dom s = the carrier of S by CIRCUIT1:4
         .= (rng <*x1(),x2(),x3(),x4(),x5()*>) \/
         {[<*x1(),x2(),x3(),x4(),x5()*>,f()]}
           by CIRCCOMB:def 6
         .= {x1(),x2(),x3(),x4(),x5()} \/
         {[<*x1(),x2(),x3(),x4(),x5()*>,f()]} by Th15
         .= {x1(),x2(),x3(),x4(),x5(),[<*x1(),x2(),x3(),x4(),x5()*>,f()]}
         by ENUMSET1:55;
    then x1() in dom s & x2() in dom s & x3() in dom s
    & x4() in dom s & x5() in dom s by ENUMSET1:29;
then A3: s*<*x1(),x2(),x3(),x4(),x5()*> = <*a1,a2,a3,a4,a5*> by A2,Th38;
   thus (Result s).Output S = (Following s).(Output S) by Th21
     .= (Following s).[<*x1(),x2(),x3(),x4(),x5()*>,f()] by Th16
     .= f().(s*<*x1(),x2(),x3(),x4(),x5()*>) by CIRCCOMB:64
     .= F(a1,a2,a3,a4,a5) by A1,A3;
  end;

begin :: Input of a compound circuit

theorem :: CIRCCMB3:39
 for n being Nat, X being non empty finite set
 for f being Function of n-tuples_on X, X
 for p being FinSeqLen of n
 for S being Signature of X
  st rng p c= the carrier of S &
     not Output 1GateCircStr(p,f) in InputVertices S
  holds
   InputVertices (S +* 1GateCircStr(p,f)) = InputVertices S;

theorem :: CIRCCMB3:40
 for X1,X2 being set, X being non empty finite set, n be Nat
 for f being Function of n-tuples_on X, X
 for p being FinSeqLen of n
 for S being Signature of X
  st rng p = X1 \/ X2 & X1 c= the carrier of S & X2 misses InnerVertices S &
     not Output 1GateCircStr(p,f) in InputVertices S
  holds
   InputVertices (S +* 1GateCircStr(p,f)) = (InputVertices S) \/ X2;

theorem :: CIRCCMB3:41
 for x1 being set, X being non empty finite set
 for f being Function of 1-tuples_on X, X
 for S being Signature of X
  st x1 in the carrier of S &
     not Output 1GateCircStr(<*x1*>,f) in InputVertices S
  holds
   InputVertices (S +* 1GateCircStr(<*x1*>,f)) = InputVertices S;

theorem :: CIRCCMB3:42
 for x1,x2 being set, X being non empty finite set
 for f being Function of 2-tuples_on X, X
 for S being Signature of X
  st x1 in the carrier of S & not x2 in InnerVertices S &
     not Output 1GateCircStr(<*x1,x2*>,f) in InputVertices S
  holds
   InputVertices (S +* 1GateCircStr(<*x1,x2*>,f)) = (InputVertices S) \/ {x2};

theorem :: CIRCCMB3:43
 for x1,x2 being set, X being non empty finite set
 for f being Function of 2-tuples_on X, X
 for S being Signature of X
  st x2 in the carrier of S & not x1 in InnerVertices S &
     not Output 1GateCircStr(<*x1,x2*>,f) in InputVertices S
  holds
   InputVertices (S +* 1GateCircStr(<*x1,x2*>,f)) = (InputVertices S) \/ {x1};

theorem :: CIRCCMB3:44
 for x1,x2 being set, X being non empty finite set
 for f being Function of 2-tuples_on X, X
 for S being Signature of X
  st x1 in the carrier of S & x2 in the carrier of S &
     not Output 1GateCircStr(<*x1,x2*>,f) in InputVertices S
  holds
   InputVertices (S +* 1GateCircStr(<*x1,x2*>,f)) = InputVertices S;

theorem :: CIRCCMB3:45
 for x1,x2,x3 being set, X being non empty finite set
 for f being Function of 3-tuples_on X, X
 for S being Signature of X
  st x1 in the carrier of S & not x2 in InnerVertices S &
     not x3 in InnerVertices S &
     not Output 1GateCircStr(<*x1,x2,x3*>,f) in InputVertices S
  holds
   InputVertices (S +* 1GateCircStr(<*x1,x2,x3*>,f)) =
     (InputVertices S) \/ {x2,x3};

theorem :: CIRCCMB3:46
 for x1,x2,x3 being set, X being non empty finite set
 for f being Function of 3-tuples_on X, X
 for S being Signature of X
  st x2 in the carrier of S & not x1 in InnerVertices S &
     not x3 in InnerVertices S &
     not Output 1GateCircStr(<*x1,x2,x3*>,f) in InputVertices S
  holds
   InputVertices (S +* 1GateCircStr(<*x1,x2,x3*>,f)) =
     (InputVertices S) \/ {x1,x3};

theorem :: CIRCCMB3:47
 for x1,x2,x3 being set, X being non empty finite set
 for f being Function of 3-tuples_on X, X
 for S being Signature of X
  st x3 in the carrier of S & not x1 in InnerVertices S &
     not x2 in InnerVertices S &
     not Output 1GateCircStr(<*x1,x2,x3*>,f) in InputVertices S
  holds
   InputVertices (S +* 1GateCircStr(<*x1,x2,x3*>,f)) =
     (InputVertices S) \/ {x1,x2};

theorem :: CIRCCMB3:48
 for x1,x2,x3 being set, X being non empty finite set
 for f being Function of 3-tuples_on X, X
 for S being Signature of X
  st x1 in the carrier of S & x2 in the carrier of S &
     not x3 in InnerVertices S &
     not Output 1GateCircStr(<*x1,x2,x3*>,f) in InputVertices S
  holds
   InputVertices (S +* 1GateCircStr(<*x1,x2,x3*>,f)) =
     (InputVertices S) \/ {x3};

theorem :: CIRCCMB3:49
 for x1,x2,x3 being set, X being non empty finite set
 for f being Function of 3-tuples_on X, X
 for S being Signature of X
  st x1 in the carrier of S & x3 in the carrier of S &
     not x2 in InnerVertices S &
     not Output 1GateCircStr(<*x1,x2,x3*>,f) in InputVertices S
  holds
   InputVertices (S +* 1GateCircStr(<*x1,x2,x3*>,f)) =
     (InputVertices S) \/ {x2};

theorem :: CIRCCMB3:50
 for x1,x2,x3 being set, X being non empty finite set
 for f being Function of 3-tuples_on X, X
 for S being Signature of X
  st x2 in the carrier of S & x3 in the carrier of S &
     not x1 in InnerVertices S &
     not Output 1GateCircStr(<*x1,x2,x3*>,f) in InputVertices S
  holds
   InputVertices (S +* 1GateCircStr(<*x1,x2,x3*>,f)) =
     (InputVertices S) \/ {x1};

theorem :: CIRCCMB3:51
 for x1,x2,x3 being set, X being non empty finite set
 for f being Function of 3-tuples_on X, X
 for S being Signature of X
  st x1 in the carrier of S & x2 in the carrier of S &
     x3 in the carrier of S &
     not Output 1GateCircStr(<*x1,x2,x3*>,f) in InputVertices S
  holds
   InputVertices (S +* 1GateCircStr(<*x1,x2,x3*>,f)) = InputVertices S;

begin :: Result of a compound circuit

theorem :: CIRCCMB3:52
 for X being non empty finite set
 for S being finite Signature of X
 for A being Circuit of X,S
 for n being Nat, f being Function of n-tuples_on X, X
 for p being FinSeqLen of n
  st not Output 1GateCircStr(p,f) in InputVertices S
 for s being State of A +* 1GateCircuit(p,f)
 for s' being State of A st s' = s|the carrier of S
  holds stabilization-time s <= 1+stabilization-time s';

scheme :: CIRCCMB3:sch 14
 Comb1CircResult
 {x1()-> set, B()-> non empty finite set, F(set)->Element of B(),
  S() -> finite Signature of B(),
  C() -> Circuit of B(), S(),
  f() -> Function of 1-tuples_on B(), B()}:
 for s being State of C() +* 1GateCircuit(<*x1()*>,f())
 for s' being State of C() st s' = s|the carrier of S()
 for a1 being Element of B()
  st (x1() in InnerVertices S() implies a1 = (Result s').x1()) &
     (not x1() in InnerVertices S() implies a1 = s.x1())
  holds
   (Result s).Output 1GateCircStr(<*x1()*>,f()) = F(a1)
provided
 for g being Function of 1-tuples_on B(), B() holds
  g = f() iff for a1 being Element of B() holds g.<*a1*> = F(a1)
and
 not Output 1GateCircStr(<*x1()*>,f()) in InputVertices S()
proof
   let s be State of C() +* 1GateCircuit(<*x1()*>,f());
   let s' be State of C() such that
A3: s' = s|the carrier of S();
   let a1 be Element of B() such that
A4: (x1() in InnerVertices S() implies a1 = (Result s').x1()) &
    (not x1() in InnerVertices S() implies a1 = s.x1());
   set S = 1GateCircStr(<*x1()*>,f());
      rng <*x1()*> = {x1()} by FINSEQ_1:55;
then A5: the carrier of S = (rng <*x1()*>) \/ {[<*x1()*>,f()]} &
    InputVertices S = rng <*x1()*> &
    x1() in rng <*x1()*>
     by CIRCCOMB:49,def 6,TARSKI:def 1;
    then x1() in the carrier of S &
    the carrier of S()+*S = (the carrier of S()) \/ the carrier of S
     by CIRCCOMB:def 2;
then A6: x1() in the carrier of S()+*S by XBOOLE_0:def 2;
      InnerVertices S = {Output S} by Th17;
then A7: InputVertices S() misses InnerVertices S by A2,ZFMISC_1:56;
A8: C() tolerates 1GateCircuit(<*x1()*>,f()) by Th30;
    then the Sorts of C() tolerates the Sorts of 1GateCircuit(<*x1()*>,f())
     by CIRCCOMB:def 3;
   then reconsider s1 = Following(s, stabilization-time s')|the carrier of S
      as State of 1GateCircuit(<*x1()*>,f()) by CIRCCOMB:33;
A9: s is stabilizing & s' is stabilizing & s1 is stabilizing
     by Def2;
      S() tolerates S by CIRCCOMB:55;
then A10: InputVertices (S()+*S) =
     (InputVertices S()) \/ (InputVertices S \ InnerVertices S())
      by A7,FACIRC_1:4;
      x1() in InnerVertices S() or x1() in InputVertices S \ InnerVertices S()
     by A5,XBOOLE_0:def 4;
then A11: x1() in InnerVertices S() or x1() in InputVertices (S()+*S)
     by A10,XBOOLE_0:def 2;
      Following(s, stabilization-time s')|the carrier of S()
     = Following(s', stabilization-time s') by A3,A7,A8,CIRCCMB2:14
    .= Result s' by A9,Th2;
then A12: a1 = Following(s, stabilization-time s').x1() by A4,A11,Th1,FUNCT_1:
72;
      dom Following(s, stabilization-time s') = the carrier of S()+*S
     by CIRCUIT1:4;
then A13: Following(s, stabilization-time s')*<*x1()*> = <*a1*> by A6,A12,Th36;
A14: [<*x1()*>,f()] = Output S by Th16;
      the OperSymbols of S = {[<*x1()*>,f()]} by CIRCCOMB:def 6;
    then [<*x1()*>,f()] in {[<*x1()*>,f()]} &
    the OperSymbols of S()+*S = (the OperSymbols of S())\/{[<*x1()*>,f()]}
     by CIRCCOMB:def 2,TARSKI:def 1;
   then reconsider g = [<*x1()*>,f()] as Gate of S()+*S by XBOOLE_0:def 2;
A15: the_result_sort_of g = (the ResultSort of S()+*S).g by MSUALG_1:def 7
     .= g by CIRCCOMB:52;
      g = [(the Arity of S()+*S).g, g`2] by CIRCCOMB:def 8;
then A16: <*x1()*> =(the Arity of S()+*S).g by ZFMISC_1:33 .= the_arity_of g
     by MSUALG_1:def 6;
A17: g`2 = f() by MCART_1:7;
      stabilization-time s <= 1+stabilization-time s' by A2,A3,Th52;
   hence (Result s).Output S
      = (Following(s, 1+stabilization-time s')).Output S by A9,Th5
     .= (Following Following(s, stabilization-time s')).g by A14,FACIRC_1:12
     .= f().(Following(s, stabilization-time s')*<*x1()*>)
        by A15,A16,A17,FACIRC_1:34
     .= F(a1) by A1,A13;
  end;

scheme :: CIRCCMB3:sch 15
 Comb2CircResult
 {x1,x2()-> set, B()-> non empty finite set,
  F(set,set)->Element of B(),
  S() -> finite Signature of B(),
  C() -> Circuit of B(), S(),
  f() -> Function of 2-tuples_on B(), B()}:
 for s being State of C() +* 1GateCircuit(<*x1(),x2()*>,f())
 for s' being State of C() st s' = s|the carrier of S()
 for a1, a2 being Element of B()
  st (x1() in InnerVertices S() implies a1 = (Result s').x1()) &
     (not x1() in InnerVertices S() implies a1 = s.x1()) &
     (x2() in InnerVertices S() implies a2 = (Result s').x2()) &
     (not x2() in InnerVertices S() implies a2 = s.x2())
  holds
   (Result s).Output(1GateCircStr(<*x1(),x2()*>,f())) = F(a1,a2)
provided
 for g being Function of 2-tuples_on B(), B() holds g = f() iff
   for a1,a2 being Element of B() holds g.<*a1,a2*> = F(a1,a2)
and
 not Output 1GateCircStr(<*x1(),x2()*>,f()) in InputVertices S()
proof
   let s be State of C() +* 1GateCircuit(<*x1(),x2()*>,f());
   let s' be State of C() such that
A3: s' = s|the carrier of S();
   let a1, a2 be Element of B() such that
A4: (x1() in InnerVertices S() implies a1 = (Result s').x1()) &
    (not x1() in InnerVertices S() implies a1 = s.x1()) &
    (x2() in InnerVertices S() implies a2 = (Result s').x2()) &
    (not x2() in InnerVertices S() implies a2 = s.x2());
   set S = 1GateCircStr(<*x1(),x2()*>,f());
      rng <*x1(),x2()*> = {x1(),x2()} by FINSEQ_2:147;
then A5: the carrier of S = (rng <*x1(),x2()*>) \/ {[<*x1(),x2()*>,f()]} &
    InputVertices S = rng <*x1(),x2()*> &
    x2() in rng <*x1(),x2()*> & x1() in rng <*x1(),x2()*>
     by CIRCCOMB:49,def 6,TARSKI:def 2;
    then x2() in the carrier of S & x1() in the carrier of S &
    the carrier of S()+*S = (the carrier of S()) \/ the carrier of S
     by CIRCCOMB:def 2;
then A6: x1() in the carrier of S()+*S & x2() in the carrier of S()+*S
     by XBOOLE_0:def 2;
      InnerVertices S = {Output S} by Th17;
then A7: InputVertices S() misses InnerVertices S by A2,ZFMISC_1:56;
A8: C() tolerates 1GateCircuit(<*x1(),x2()*>,f()) by Th30;
    then the Sorts of C() tolerates the Sorts of 1GateCircuit(<*x1(),x2()*>,f(
))
     by CIRCCOMB:def 3;
   then reconsider s1 = Following(s, stabilization-time s')|the carrier of S
      as State of 1GateCircuit(<*x1(),x2()*>,f()) by CIRCCOMB:33;
A9: s is stabilizing & s' is stabilizing & s1 is stabilizing by Def2;
      S() tolerates S by CIRCCOMB:55;
then A10: InputVertices (S()+*S) =
     (InputVertices S()) \/ (InputVertices S \ InnerVertices S())
      by A7,FACIRC_1:4;
      x1() in InnerVertices S() or x1() in InputVertices S \ InnerVertices S()
     by A5,XBOOLE_0:def 4;
then A11: x1() in InnerVertices S() or x1() in InputVertices (S()+*S)
     by A10,XBOOLE_0:def 2;
      x2() in InnerVertices S() or x2() in InputVertices S \ InnerVertices S()
     by A5,XBOOLE_0:def 4;
then A12: x2() in InnerVertices S() or x2() in InputVertices (S()+*S)
     by A10,XBOOLE_0:def 2;
      Following(s, stabilization-time s')|the carrier of S()
     = Following(s', stabilization-time s') by A3,A7,A8,CIRCCMB2:14
    .= Result s' by A9,Th2;
then A13: a1 = Following(s, stabilization-time s').x1() &
    a2 = Following(s, stabilization-time s').x2() by A4,A11,A12,Th1,FUNCT_1:72;
      dom Following(s, stabilization-time s') = the carrier of S()+*S
     by CIRCUIT1:4;
then A14: Following(s, stabilization-time s')*<*x1(),x2()*> = <*a1,a2*>
     by A6,A13,FINSEQ_2:145;
A15: [<*x1(),x2()*>,f()] = Output S by Th16;
      the OperSymbols of S = {[<*x1(),x2()*>,f()]} by CIRCCOMB:def 6;
    then [<*x1(),x2()*>,f()] in {[<*x1(),x2()*>,f()]} &
    the OperSymbols of S()+*S = (the OperSymbols of S())\/{[<*x1(),x2()*>,f()]}
     by CIRCCOMB:def 2,TARSKI:def 1;
   then reconsider g = [<*x1(),x2()*>,f()] as Gate of S()+*S by XBOOLE_0:def 2;
A16: the_result_sort_of g = (the ResultSort of S()+*S).g by MSUALG_1:def 7
     .= g by CIRCCOMB:52;
      g = [(the Arity of S()+*S).g, g`2] by CIRCCOMB:def 8;
then A17: <*x1(),x2()*> =(the Arity of S()+*S).g by ZFMISC_1:33 .= the_arity_of
g
     by MSUALG_1:def 6;
A18: g`2 = f() by MCART_1:7;
      stabilization-time s <= 1+stabilization-time s' by A2,A3,Th52;
   hence (Result s).Output S
      = (Following(s, 1+stabilization-time s')).Output S by A9,Th5
     .= (Following Following(s, stabilization-time s')).g by A15,FACIRC_1:12
     .= f().(Following(s, stabilization-time s')*<*x1(),x2()*>)
        by A16,A17,A18,FACIRC_1:34
     .= F(a1,a2) by A1,A14;
  end;

scheme :: CIRCCMB3:sch 16
 Comb3CircResult
 {x1,x2,x3()-> set, B()-> non empty finite set,
  F(set,set,set)->Element of B(),
  S() -> finite Signature of B(),
  C() -> Circuit of B(), S(),
  f() -> Function of 3-tuples_on B(), B()}:
 for s being State of C() +* 1GateCircuit(<*x1(),x2(),x3()*>,f())
 for s' being State of C() st s' = s|the carrier of S()
 for a1, a2, a3 being Element of B()
  st (x1() in InnerVertices S() implies a1 = (Result s').x1()) &
     (not x1() in InnerVertices S() implies a1 = s.x1()) &
     (x2() in InnerVertices S() implies a2 = (Result s').x2()) &
     (not x2() in InnerVertices S() implies a2 = s.x2()) &
     (x3() in InnerVertices S() implies a3 = (Result s').x3()) &
     (not x3() in InnerVertices S() implies a3 = s.x3())
  holds
   (Result s).Output(1GateCircStr(<*x1(),x2(),x3()*>,f())) = F(a1,a2,a3)
provided
 for g being Function of 3-tuples_on B(), B() holds g = f() iff
   for a1,a2,a3 being Element of B() holds g.<*a1,a2,a3*> = F(a1,a2,a3)
and
 not Output 1GateCircStr(<*x1(),x2(),x3()*>,f()) in InputVertices S()
proof
   let s be State of C() +* 1GateCircuit(<*x1(),x2(),x3()*>,f());
   let s' be State of C() such that
A3: s' = s|the carrier of S();
   let a1, a2, a3 be Element of B() such that
A4: (x1() in InnerVertices S() implies a1 = (Result s').x1()) &
    (not x1() in InnerVertices S() implies a1 = s.x1()) &
    (x2() in InnerVertices S() implies a2 = (Result s').x2()) &
    (not x2() in InnerVertices S() implies a2 = s.x2()) &
    (x3() in InnerVertices S() implies a3 = (Result s').x3()) &
    (not x3() in InnerVertices S() implies a3 = s.x3());
   set S = 1GateCircStr(<*x1(),x2(),x3()*>,f());
      rng <*x1(),x2(),x3()*> = {x1(),x2(),x3()} by FINSEQ_2:148;
then A5: the carrier of S = (rng <*x1(),x2(),x3()*>) \/ {[<*x1(),x2(),x3()*>,f(
)]} &
    InputVertices S = rng <*x1(),x2(),x3()*> &
    x3() in rng <*x1(),x2(),x3()*> & x2() in rng <*x1(),x2(),x3()*> &
    x1() in rng <*x1(),x2(),x3()*>
     by CIRCCOMB:49,def 6,ENUMSET1:14;
    then x3() in the carrier of S & x2() in the carrier of S &
    x1() in the carrier of S &
    the carrier of S()+*S = (the carrier of S()) \/ the carrier of S
     by CIRCCOMB:def 2;
then A6: x1() in the carrier of S()+*S & x2() in the carrier of S()+*S &
    x3() in the carrier of S()+*S by XBOOLE_0:def 2;
      InnerVertices S = {Output S} by Th17;
then A7: InputVertices S() misses InnerVertices S by A2,ZFMISC_1:56;
A8: C() tolerates 1GateCircuit(<*x1(),x2(),x3()*>,f()) by Th30;
    then the Sorts of C() tolerates
      the Sorts of 1GateCircuit(<*x1(),x2(),x3()*>,f())
     by CIRCCOMB:def 3;
   then reconsider s1 = Following(s, stabilization-time s')|the carrier of S
      as State of 1GateCircuit(<*x1(),x2(),x3()*>,f()) by CIRCCOMB:33;
A9: s is stabilizing & s' is stabilizing & s1 is stabilizing by Def2;
      S() tolerates S by CIRCCOMB:55;
then A10: InputVertices (S()+*S) =
     (InputVertices S()) \/ (InputVertices S \ InnerVertices S())
      by A7,FACIRC_1:4;
      x1() in InnerVertices S() or x1() in InputVertices S \ InnerVertices S()
     by A5,XBOOLE_0:def 4;
then A11: x1() in InnerVertices S() or x1() in InputVertices (S()+*S)
     by A10,XBOOLE_0:def 2;
      x2() in InnerVertices S() or x2() in InputVertices S \ InnerVertices S()
     by A5,XBOOLE_0:def 4;
then A12: x2() in InnerVertices S() or x2() in InputVertices (S()+*S)
     by A10,XBOOLE_0:def 2;
      x3() in InnerVertices S() or x3() in InputVertices S \ InnerVertices S()
     by A5,XBOOLE_0:def 4;
then A13: x3() in InnerVertices S() or x3() in InputVertices (S()+*S)
     by A10,XBOOLE_0:def 2;
      Following(s, stabilization-time s')|the carrier of S()
     = Following(s', stabilization-time s') by A3,A7,A8,CIRCCMB2:14
    .= Result s' by A9,Th2;
then A14: a1 = Following(s, stabilization-time s').x1() &
    a2 = Following(s, stabilization-time s').x2() &
    a3 = Following(s, stabilization-time s').x3()
     by A4,A11,A12,A13,Th1,FUNCT_1:72;
      dom Following(s, stabilization-time s') = the carrier of S()+*S
     by CIRCUIT1:4;
then A15: Following(s, stabilization-time s')*<*x1(),x2(),x3()*> = <*a1,a2,a3*>
     by A6,A14,FINSEQ_2:146;
A16: [<*x1(),x2(),x3()*>,f()] = Output S by Th16;
      the OperSymbols of S = {[<*x1(),x2(),x3()*>,f()]} by CIRCCOMB:def 6;
    then [<*x1(),x2(),x3()*>,f()] in {[<*x1(),x2(),x3()*>,f()]} &
    the OperSymbols of S()+*S =
      (the OperSymbols of S())\/{[<*x1(),x2(),x3()*>,f()]}
     by CIRCCOMB:def 2,TARSKI:def 1;
    then reconsider g = [<*x1(),x2(),x3()*>,f()] as Gate of S()+*S by XBOOLE_0:
def 2;
A17: the_result_sort_of g = (the ResultSort of S()+*S).g by MSUALG_1:def 7
     .= g by CIRCCOMB:52;
      g = [(the Arity of S()+*S).g, g`2] by CIRCCOMB:def 8;
then A18: <*x1(),x2(),x3()*> = (the Arity of S()+*S).g by ZFMISC_1:33
       .= the_arity_of g by MSUALG_1:def 6;
A19: g`2 = f() by MCART_1:7;
      stabilization-time s <= 1+stabilization-time s' by A2,A3,Th52;
   hence (Result s).Output S
      = (Following(s, 1+stabilization-time s')).Output S by A9,Th5
     .= (Following Following(s, stabilization-time s')).g by A16,FACIRC_1:12
     .= f().(Following(s, stabilization-time s')*<*x1(),x2(),x3()*>)
        by A17,A18,A19,FACIRC_1:34
     .= F(a1,a2,a3) by A1,A15;
  end;

scheme :: CIRCCMB3:sch 17
 Comb4CircResult
 {x1,x2,x3,x4()-> set, B()-> non empty finite set,
  F(set,set,set,set)->Element of B(),
  S() -> finite Signature of B(),
  C() -> Circuit of B(), S(),
  f() -> Function of 4-tuples_on B(), B()}:
 for s being State of C() +* 1GateCircuit(<*x1(),x2(),x3(),x4()*>,f())
 for s' being State of C() st s' = s|the carrier of S()
 for a1, a2, a3, a4 being Element of B()
  st (x1() in InnerVertices S() implies a1 = (Result s').x1()) &
     (not x1() in InnerVertices S() implies a1 = s.x1()) &
     (x2() in InnerVertices S() implies a2 = (Result s').x2()) &
     (not x2() in InnerVertices S() implies a2 = s.x2()) &
     (x3() in InnerVertices S() implies a3 = (Result s').x3()) &
     (not x3() in InnerVertices S() implies a3 = s.x3()) &
     (x4() in InnerVertices S() implies a4 = (Result s').x4()) &
     (not x4() in InnerVertices S() implies a4 = s.x4())
  holds
   (Result s).Output(1GateCircStr(<*x1(),x2(),x3(),x4()*>,f()))
     = F(a1,a2,a3,a4)
provided
 for g being Function of 4-tuples_on B(), B() holds g = f() iff
   for a1,a2,a3,a4 being Element of B()
    holds g.<*a1,a2,a3,a4*> = F(a1,a2,a3,a4)
and
 not Output 1GateCircStr(<*x1(),x2(),x3(),x4()*>,f()) in InputVertices S()
proof
   let s be State of C() +* 1GateCircuit(<*x1(),x2(),x3(),x4()*>,f());
   let s' be State of C() such that
A3: s' = s|the carrier of S();
   let a1, a2, a3, a4 be Element of B() such that
A4: (x1() in InnerVertices S() implies a1 = (Result s').x1()) &
    (not x1() in InnerVertices S() implies a1 = s.x1()) &
    (x2() in InnerVertices S() implies a2 = (Result s').x2()) &
    (not x2() in InnerVertices S() implies a2 = s.x2()) &
    (x3() in InnerVertices S() implies a3 = (Result s').x3()) &
    (not x3() in InnerVertices S() implies a3 = s.x3()) &
    (x4() in InnerVertices S() implies a4 = (Result s').x4()) &
    (not x4() in InnerVertices S() implies a4 = s.x4());
   set S = 1GateCircStr(<*x1(),x2(),x3(),x4()*>,f());
      rng <*x1(),x2(),x3(),x4()*> = {x1(),x2(),x3(),x4()} by Th14;
then A5: the carrier of S = (rng <*x1(),x2(),x3(),x4()*>) \/
    {[<*x1(),x2(),x3(),x4()*>,f()]} &
    InputVertices S = rng <*x1(),x2(),x3(),x4()*> &
    x3() in rng <*x1(),x2(),x3(),x4()*> & x2() in rng <*x1(),x2(),x3(),x4()*>
  & x1() in rng <*x1(),x2(),x3(),x4()*> & x4() in rng <*x1(),x2(),x3(),x4()*>
     by CIRCCOMB:49,def 6,ENUMSET1:19;
    then x3() in the carrier of S & x2() in the carrier of S &
    x1() in the carrier of S & x4() in the carrier of S &
    the carrier of S()+*S = (the carrier of S()) \/ the carrier of S
     by CIRCCOMB:def 2;
then A6: x1() in the carrier of S()+*S & x2() in the carrier of S()+*S &
    x3() in the carrier of S()+*S & x4() in the carrier of S()+*S
    by XBOOLE_0:def 2;
      InnerVertices S = {Output S} by Th17;
then A7: InputVertices S() misses InnerVertices S by A2,ZFMISC_1:56;
A8: C() tolerates 1GateCircuit(<*x1(),x2(),x3(),x4()*>,f()) by Th30;
    then the Sorts of C() tolerates
      the Sorts of 1GateCircuit(<*x1(),x2(),x3(),x4()*>,f())
     by CIRCCOMB:def 3;
   then reconsider s1 = Following(s, stabilization-time s')|the carrier of S
      as State of 1GateCircuit(<*x1(),x2(),x3(),x4()*>,f()) by CIRCCOMB:33;
A9: s is stabilizing & s' is stabilizing & s1 is stabilizing
     by Def2;
      S() tolerates S by CIRCCOMB:55;
then A10: InputVertices (S()+*S) =
     (InputVertices S()) \/ (InputVertices S \ InnerVertices S())
      by A7,FACIRC_1:4;
      x1() in InnerVertices S() or x1() in InputVertices S \ InnerVertices S()
     by A5,XBOOLE_0:def 4;
then A11: x1() in InnerVertices S() or x1() in InputVertices (S()+*S)
     by A10,XBOOLE_0:def 2;
      x2() in InnerVertices S() or x2() in InputVertices S \ InnerVertices S()
     by A5,XBOOLE_0:def 4;
then A12: x2() in InnerVertices S() or x2() in InputVertices (S()+*S)
     by A10,XBOOLE_0:def 2;
      x3() in InnerVertices S() or x3() in InputVertices S \ InnerVertices S()
     by A5,XBOOLE_0:def 4;
then A13: x3() in InnerVertices S() or x3() in InputVertices (S()+*S)
     by A10,XBOOLE_0:def 2;
      x4() in InnerVertices S() or x4() in InputVertices S \ InnerVertices S()
     by A5,XBOOLE_0:def 4;
then A14: x4() in InnerVertices S() or x4() in InputVertices (S()+*S)
     by A10,XBOOLE_0:def 2;
      Following(s, stabilization-time s')|the carrier of S()
     = Following(s', stabilization-time s') by A3,A7,A8,CIRCCMB2:14
    .= Result s' by A9,Th2;
then A15: a1 = Following(s, stabilization-time s').x1() &
    a2 = Following(s, stabilization-time s').x2() &
    a3 = Following(s, stabilization-time s').x3() &
    a4 = Following(s, stabilization-time s').x4()
     by A4,A11,A12,A13,A14,Th1,FUNCT_1:72;
      dom Following(s, stabilization-time s') = the carrier of S()+*S
     by CIRCUIT1:4;
then A16: Following(s, stabilization-time s')*<*x1(),x2(),x3(),x4()*> =
   <*a1,a2,a3,a4*> by A6,A15,Th37;
A17: [<*x1(),x2(),x3(),x4()*>,f()] = Output S by Th16;
      the OperSymbols of S = {[<*x1(),x2(),x3(),x4()*>,f()]} by CIRCCOMB:def 6;
    then [<*x1(),x2(),x3(),x4()*>,f()] in {[<*x1(),x2(),x3(),x4()*>,f()]} &
    the OperSymbols of S()+*S =
      (the OperSymbols of S())\/{[<*x1(),x2(),x3(),x4()*>,f()]}
     by CIRCCOMB:def 2,TARSKI:def 1;
    then reconsider g = [<*x1(),x2(),x3(),x4()*>,f()] as Gate of S()+*S by
XBOOLE_0:def 2;
A18: the_result_sort_of g = (the ResultSort of S()+*S).g by MSUALG_1:def 7
     .= g by CIRCCOMB:52;
      g = [(the Arity of S()+*S).g, g`2] by CIRCCOMB:def 8;
then A19: <*x1(),x2(),x3(),x4()*> = (the Arity of S()+*S).g by ZFMISC_1:33
       .= the_arity_of g by MSUALG_1:def 6;
A20: g`2 = f() by MCART_1:7;
      stabilization-time s <= 1+stabilization-time s' by A2,A3,Th52;
   hence (Result s).Output S
      = (Following(s, 1+stabilization-time s')).Output S by A9,Th5
     .= (Following Following(s, stabilization-time s')).g by A17,FACIRC_1:12
     .= f().(Following(s, stabilization-time s')*<*x1(),x2(),x3(),x4()*>)
        by A18,A19,A20,FACIRC_1:34
     .= F(a1,a2,a3,a4) by A1,A16;
  end;

scheme :: CIRCCMB3:sch 18
 Comb5CircResult
 {x1,x2,x3,x4,x5()-> set, B()-> non empty finite set,
  F(set,set,set,set,set)->Element of B(),
  S() -> finite Signature of B(),
  C() -> Circuit of B(), S(),
  f() -> Function of 5-tuples_on B(), B()}:
 for s being State of C() +* 1GateCircuit(<*x1(),x2(),x3(),x4(),x5()*>,f())
 for s' being State of C() st s' = s|the carrier of S()
 for a1, a2, a3, a4, a5 being Element of B()
  st (x1() in InnerVertices S() implies a1 = (Result s').x1()) &
     (not x1() in InnerVertices S() implies a1 = s.x1()) &
     (x2() in InnerVertices S() implies a2 = (Result s').x2()) &
     (not x2() in InnerVertices S() implies a2 = s.x2()) &
     (x3() in InnerVertices S() implies a3 = (Result s').x3()) &
     (not x3() in InnerVertices S() implies a3 = s.x3()) &
     (x4() in InnerVertices S() implies a4 = (Result s').x4()) &
     (not x4() in InnerVertices S() implies a4 = s.x4()) &
     (x5() in InnerVertices S() implies a5 = (Result s').x5()) &
     (not x5() in InnerVertices S() implies a5 = s.x5())
  holds
   (Result s).Output(1GateCircStr(<*x1(),x2(),x3(),x4(),x5()*>,f()))
     = F(a1,a2,a3,a4,a5)
provided
 for g being Function of 5-tuples_on B(), B() holds g = f() iff
   for a1,a2,a3,a4,a5 being Element of B()
    holds g.<*a1,a2,a3,a4,a5*> = F(a1,a2,a3,a4,a5)
and
 not Output 1GateCircStr(<*x1(),x2(),x3(),x4(),x5()*>,f())
      in InputVertices S()
proof
   let s be State of C() +* 1GateCircuit(<*x1(),x2(),x3(),x4(),x5()*>,f());
   let s' be State of C() such that
A3: s' = s|the carrier of S();
   let a1, a2, a3, a4, a5 be Element of B() such that
A4: (x1() in InnerVertices S() implies a1 = (Result s').x1()) &
    (not x1() in InnerVertices S() implies a1 = s.x1()) &
    (x2() in InnerVertices S() implies a2 = (Result s').x2()) &
    (not x2() in InnerVertices S() implies a2 = s.x2()) &
    (x3() in InnerVertices S() implies a3 = (Result s').x3()) &
    (not x3() in InnerVertices S() implies a3 = s.x3()) &
    (x4() in InnerVertices S() implies a4 = (Result s').x4()) &
    (not x4() in InnerVertices S() implies a4 = s.x4()) &
    (x5() in InnerVertices S() implies a5 = (Result s').x5()) &
    (not x5() in InnerVertices S() implies a5 = s.x5());
   set S = 1GateCircStr(<*x1(),x2(),x3(),x4(),x5()*>,f());
      rng <*x1(),x2(),x3(),x4(),x5()*> = {x1(),x2(),x3(),x4(),x5()} by Th15;
then A5: the carrier of S = (rng <*x1(),x2(),x3(),x4(),x5()*>) \/
    {[<*x1(),x2(),x3(),x4(),x5()*>,f()]} &
    InputVertices S = rng <*x1(),x2(),x3(),x4(),x5()*> &
    x1() in rng <*x1(),x2(),x3(),x4(),x5()*> &
    x2() in rng <*x1(),x2(),x3(),x4(),x5()*> &
    x3() in rng <*x1(),x2(),x3(),x4(),x5()*> &
    x4() in rng <*x1(),x2(),x3(),x4(),x5()*> &
    x5() in rng <*x1(),x2(),x3(),x4(),x5()*>
     by CIRCCOMB:49,def 6,ENUMSET1:24;
    then x1() in the carrier of S & x2() in the carrier of S &
    x3() in the carrier of S & x4() in the carrier of S &
    x5() in the carrier of S &
    the carrier of S()+*S = (the carrier of S()) \/ the carrier of S
     by CIRCCOMB:def 2;
then A6: x1() in the carrier of S()+*S & x2() in the carrier of S()+*S &
    x3() in the carrier of S()+*S & x4() in the carrier of S()+*S &
    x5() in the carrier of S()+*S by XBOOLE_0:def 2;
      InnerVertices S = {Output S} by Th17;
then A7: InputVertices S() misses InnerVertices S by A2,ZFMISC_1:56;
A8: C() tolerates 1GateCircuit(<*x1(),x2(),x3(),x4(),x5()*>,f()) by Th30;
    then the Sorts of C() tolerates
      the Sorts of 1GateCircuit(<*x1(),x2(),x3(),x4(),x5()*>,f())
     by CIRCCOMB:def 3;
   then reconsider s1 = Following(s, stabilization-time s')|the carrier of S
    as State of 1GateCircuit(<*x1(),x2(),x3(),x4(),x5()*>,f()) by CIRCCOMB:33;
A9: s is stabilizing & s' is stabilizing & s1 is stabilizing by Def2;
      S() tolerates S by CIRCCOMB:55;
then A10: InputVertices (S()+*S) =
     (InputVertices S()) \/ (InputVertices S \ InnerVertices S())
      by A7,FACIRC_1:4;
      x1() in InnerVertices S() or x1() in InputVertices S \ InnerVertices S()
     by A5,XBOOLE_0:def 4;
then A11: x1() in InnerVertices S() or x1() in InputVertices (S()+*S)
     by A10,XBOOLE_0:def 2;
      x2() in InnerVertices S() or x2() in InputVertices S \ InnerVertices S()
     by A5,XBOOLE_0:def 4;
then A12: x2() in InnerVertices S() or x2() in InputVertices (S()+*S)
     by A10,XBOOLE_0:def 2;
      x3() in InnerVertices S() or x3() in InputVertices S \ InnerVertices S()
     by A5,XBOOLE_0:def 4;
then A13: x3() in InnerVertices S() or x3() in InputVertices (S()+*S)
     by A10,XBOOLE_0:def 2;
      x4() in InnerVertices S() or x4() in InputVertices S \ InnerVertices S()
     by A5,XBOOLE_0:def 4;
then A14: x4() in InnerVertices S() or x4() in InputVertices (S()+*S)
     by A10,XBOOLE_0:def 2;
      x5() in InnerVertices S() or x5() in InputVertices S \ InnerVertices S()
     by A5,XBOOLE_0:def 4;
then A15: x5() in InnerVertices S() or x5() in InputVertices (S()+*S)
     by A10,XBOOLE_0:def 2;
      Following(s, stabilization-time s')|the carrier of S()
     = Following(s', stabilization-time s') by A3,A7,A8,CIRCCMB2:14
    .= Result s' by A9,Th2;
then A16: a1 = Following(s, stabilization-time s').x1() &
    a2 = Following(s, stabilization-time s').x2() &
    a3 = Following(s, stabilization-time s').x3() &
    a4 = Following(s, stabilization-time s').x4() &
    a5 = Following(s, stabilization-time s').x5()
     by A4,A11,A12,A13,A14,A15,Th1,FUNCT_1:72;
      dom Following(s, stabilization-time s') = the carrier of S()+*S
     by CIRCUIT1:4;
then A17: Following(s, stabilization-time s')*<*x1(),x2(),x3(),x4(),x5()*> =
   <*a1,a2,a3,a4,a5*> by A6,A16,Th38;
A18: [<*x1(),x2(),x3(),x4(),x5()*>,f()] = Output S by Th16;
      the OperSymbols of S = {[<*x1(),x2(),x3(),x4(),x5()*>,f()]}
    by CIRCCOMB:def 6;
    then [<*x1(),x2(),x3(),x4(),x5()*>,f()] in {[<*x1(),x2(),x3(),x4(),x5()*>,
f()]}
    & the OperSymbols of S()+*S =
      (the OperSymbols of S())\/{[<*x1(),x2(),x3(),x4(),x5()*>,f()]}
     by CIRCCOMB:def 2,TARSKI:def 1;
    then reconsider g = [<*x1(),x2(),x3(),x4(),x5()*>,f()] as Gate of S()+*S
by XBOOLE_0:def 2;
A19: the_result_sort_of g = (the ResultSort of S()+*S).g by MSUALG_1:def 7
     .= g by CIRCCOMB:52;
      g = [(the Arity of S()+*S).g, g`2] by CIRCCOMB:def 8;
then A20: <*x1(),x2(),x3(),x4(),x5()*> = (the Arity of S()+*S).g by ZFMISC_1:33
       .= the_arity_of g by MSUALG_1:def 6;
A21: g`2 = f() by MCART_1:7;
      stabilization-time s <= 1+stabilization-time s' by A2,A3,Th52;
   hence (Result s).Output S
      = (Following(s, 1+stabilization-time s')).Output S by A9,Th5
     .= (Following Following(s, stabilization-time s')).g by A18,FACIRC_1:12
     .= f().(Following(s, stabilization-time s')*<*x1(),x2(),x3(),x4(),x5()*>)
        by A19,A20,A21,FACIRC_1:34
     .= F(a1,a2,a3,a4,a5) by A1,A17;
  end;

begin :: Inputs without pairs

definition
 let S be non empty ManySortedSign;
 attr S is with_nonpair_inputs means
:: CIRCCMB3:def 11

  InputVertices S is without_pairs;
end;


registration
 cluster NAT -> without_pairs;
 coherence
  proof let x be pair set; assume x in NAT;
    then x is Nat;
   hence thesis;
  end;
 let X be without_pairs set;
 cluster -> without_pairs Subset of X;
 coherence
  proof let Y be Subset of X;
   let x be pair set; assume x in Y;
   hence thesis by FACIRC_1:def 2;
  end;
end;


registration
 cluster natural-yielding -> nonpair-yielding Function;
 coherence
  proof let f be Function such that
A1: rng f c= NAT;
   let x be set; assume x in dom f;
    then f.x in rng f by FUNCT_1:def 5;
    then f.x is Nat by A1;
   hence thesis;
  end;
end;


registration
 cluster -> natural-yielding FinSequence of NAT;
 coherence
  proof let p be FinSequence of NAT;
   thus rng p c= NAT by FINSEQ_1:def 4;
  end;
end;


registration
 cluster one-to-one natural-yielding FinSequence;
 existence
  proof consider p being one-to-one FinSequence of NAT;
   take p; thus thesis;
  end;
end;


registration
 let n be Nat;
 cluster one-to-one natural-yielding FinSeqLen of n;
 existence
  proof set p = id Seg n;
A1: dom p = Seg n & rng p = Seg n by RELAT_1:71;
    then p is FinSequence by FINSEQ_1:def 2;
   then reconsider p as one-to-one FinSequence of NAT by A1,FINSEQ_1:def 4;
      len p = n by A1,FINSEQ_1:def 3;
   then reconsider p as FinSeqLen of n by CIRCCOMB:def 12;
   take p; thus thesis;
  end;
end;


registration
 let p be nonpair-yielding FinSequence;
 let f be set;
 cluster 1GateCircStr(p,f) -> with_nonpair_inputs;
 coherence
  proof
      InputVertices 1GateCircStr(p,f) = rng p by CIRCCOMB:49;
   hence InputVertices 1GateCircStr(p,f) is without_pairs;
  end;
end;


registration
 cluster with_nonpair_inputs (one-gate ManySortedSign);
 existence
  proof consider n being Nat, X being non empty finite set;
   consider f being Function of n-tuples_on X, X;
   consider p being natural-yielding FinSeqLen of n;
   take 1GateCircStr(p,f); thus thesis;
  end;
 let X be non empty finite set;
 cluster with_nonpair_inputs (one-gate Signature of X);
 existence
  proof consider n being Nat;
   consider f being Function of n-tuples_on X, X;
   consider p being natural-yielding FinSeqLen of n;
   take 1GateCircStr(p,f); thus thesis;
  end;
end;


registration
 let S be with_nonpair_inputs (non empty ManySortedSign);
 cluster InputVertices S -> without_pairs;
 coherence by Def11;
end;


theorem :: CIRCCMB3:53
   for S being with_nonpair_inputs (non empty ManySortedSign)
 for x being Vertex of S st x is pair
  holds x in InnerVertices S;

registration
 let S be unsplit gate`1=arity (non empty ManySortedSign);
 cluster InnerVertices S -> Relation-like;
 coherence
  proof
A1: InnerVertices S = the OperSymbols of S by FACIRC_1:37;
   let x be set; assume x in InnerVertices S;
    then x = [(the Arity of S).x, x`2] by A1,CIRCCOMB:def 8;
   hence thesis;
  end;
end;


registration
 let S be unsplit gate`2=den (non empty non void ManySortedSign);
 cluster InnerVertices S -> Relation-like;
 coherence
  proof consider A being MSAlgebra over S such that
A1: A is gate`2=den by CIRCCOMB:def 11;
   let x be set; assume x in InnerVertices S;
   then reconsider g = x as Gate of S by FACIRC_1:37;
      g = [g`1, (the Charact of A).g] by A1,CIRCCOMB:def 10;
   hence thesis;
  end;
end;


registration
 let S1,S2 be with_nonpair_inputs
   (unsplit gate`1=arity non empty ManySortedSign);
 cluster S1+*S2 -> with_nonpair_inputs;
 coherence
  proof
      S1 tolerates S2 by CIRCCOMB:55;
    then InputVertices (S1+*S2) is Subset of (InputVertices S1) \/
InputVertices S2 by CIRCCOMB:15;
   hence InputVertices (S1+*S2) is without_pairs;
  end;
end;


theorem :: CIRCCMB3:54
   for x being non pair set, R being Relation holds not x in R;

theorem :: CIRCCMB3:55
 for x1 being set, X being non empty finite set
 for f being Function of 1-tuples_on X, X
 for S being with_nonpair_inputs Signature of X
  st x1 in the carrier of S or x1 is non pair
  holds S +* 1GateCircStr(<*x1*>, f) is with_nonpair_inputs;

registration
 let X be non empty finite set;
 let S be with_nonpair_inputs Signature of X;
 let x1 be Vertex of S;
 let f be Function of 1-tuples_on X, X;
 cluster S +* 1GateCircStr(<*x1*>, f) -> with_nonpair_inputs;
 coherence by Th55;
end;


registration
 let X be non empty finite set;
 let S be with_nonpair_inputs Signature of X;
 let x1 be non pair set;
 let f be Function of 1-tuples_on X, X;
 cluster S +* 1GateCircStr(<*x1*>, f) -> with_nonpair_inputs;
 coherence;
end;

theorem :: CIRCCMB3:56
 for x1,x2 being set, X being non empty finite set
 for f being Function of 2-tuples_on X, X
 for S being with_nonpair_inputs Signature of X
  st (x1 in the carrier of S or x1 is non pair) &
     (x2 in the carrier of S or x2 is non pair)
  holds S +* 1GateCircStr(<*x1,x2*>, f) is with_nonpair_inputs;

registration
 let X be non empty finite set;
 let S be with_nonpair_inputs Signature of X;
 let x1 be Vertex of S, n2 be non pair set;
 let f be Function of 2-tuples_on X, X;
 cluster S +* 1GateCircStr(<*x1,n2*>, f) -> with_nonpair_inputs;
 coherence by Th56;
 cluster S +* 1GateCircStr(<*n2,x1*>, f) -> with_nonpair_inputs;
 coherence by Th56;
end;


registration
 let X be non empty finite set;
 let S be with_nonpair_inputs Signature of X;
 let x1,x2 be Vertex of S;
 let f be Function of 2-tuples_on X, X;
 cluster S +* 1GateCircStr(<*x1,x2*>, f) -> with_nonpair_inputs;
 coherence by Th56;
end;

theorem :: CIRCCMB3:57
 for x1,x2,x3 being set, X being non empty finite set
 for f being Function of 3-tuples_on X, X
 for S being with_nonpair_inputs Signature of X
  st (x1 in the carrier of S or x1 is non pair) &
     (x2 in the carrier of S or x2 is non pair) &
     (x3 in the carrier of S or x3 is non pair)
  holds S +* 1GateCircStr(<*x1,x2,x3*>, f) is with_nonpair_inputs;

registration
 let X be non empty finite set;
 let S be with_nonpair_inputs Signature of X;
 let x1,x2 be Vertex of S, n be non pair set;
 let f be Function of 3-tuples_on X, X;
 cluster S +* 1GateCircStr(<*x1,x2,n*>, f) -> with_nonpair_inputs;
 coherence by Th57;
 cluster S +* 1GateCircStr(<*x1,n,x2*>, f) -> with_nonpair_inputs;
 coherence by Th57;
 cluster S +* 1GateCircStr(<*n,x1,x2*>, f) -> with_nonpair_inputs;
 coherence by Th57;
end;


registration
 let X be non empty finite set;
 let S be with_nonpair_inputs Signature of X;
 let x be Vertex of S, n1,n2 be non pair set;
 let f be Function of 3-tuples_on X, X;
 cluster S +* 1GateCircStr(<*x,n1,n2*>, f) -> with_nonpair_inputs;
 coherence by Th57;
 cluster S +* 1GateCircStr(<*n1,x,n2*>, f) -> with_nonpair_inputs;
 coherence by Th57;
 cluster S +* 1GateCircStr(<*n1,n2,x*>, f) -> with_nonpair_inputs;
 coherence by Th57;
end;


registration
 let X be non empty finite set;
 let S be with_nonpair_inputs Signature of X;
 let x1,x2,x3 be Vertex of S;
 let f be Function of 3-tuples_on X, X;
 cluster S +* 1GateCircStr(<*x1,x2,x3*>, f) -> with_nonpair_inputs;
 coherence by Th57;
end;

