:: Modifying addresses of instructions of { \bf SCM_FSA }
::  by Andrzej Trybulec and Yatsuka Nakamura
::
:: Received February 14, 1996
:: Copyright (c) 1996 Association of Mizar Users

environ

 vocabularies NUMBERS, SUBSET_1, AMI_1, AMI_3, SCMFSA_2, AMISTD_2, CARD_1,
      GRAPHSP, ARYTM_3, XXREAL_0, SCMNORM, RELAT_1, FUNCT_1, CARD_3, TARSKI,
      STRUCT_0, FUNCT_4, XBOOLE_0, FUNCOP_1, FSM_1, CIRCUIT2, ARYTM_1, INT_1,
      COMPLEX1, PARTFUN1, FINSEQ_1, FINSEQ_2, VALUED_1, ORDINAL1, FINSET_1,
      NAT_1;
 notations TARSKI, XBOOLE_0, ENUMSET1, SUBSET_1, NUMBERS, CARD_3, XXREAL_0,
      XCMPLX_0, MCART_1, NAT_1, NAT_D, FINSET_1, VALUED_1, INT_1, INT_2,
      RELAT_1, FUNCT_1, PARTFUN1, FUNCT_2, FUNCT_4, FUNCOP_1, FUNCT_7,
      FINSEQ_1, FINSEQ_2, STRUCT_0, COMPOS_1, EXTPRO_1, AMI_1, AMI_3, SCMFSA_2,
      AMISTD_2;
 constructors DOMAIN_1, XXREAL_0, AMI_5, SCMFSA_2, NAT_D, RELSET_1, VALUED_1,
      AMISTD_2, AMI_1;
 registrations XBOOLE_0, SETFAM_1, FUNCT_1, ORDINAL1, RELSET_1, FUNCOP_1,
      NUMBERS, XREAL_0, INT_1, CARD_3, SCMFSA_2, FINSET_1, VALUED_1, FUNCT_4,
      RELAT_1, AMI_1, AMI_3, AMI_6, RELOC, XXREAL_0, SCMFSA10, AMISTD_2,
      VALUED_0, COMPOS_1, EXTPRO_1;
 requirements NUMERALS, REAL, SUBSET, BOOLE, ARITHM;


begin :: Incrementing addresses

reserve L, j, k, l, m, n, p, q for Element of NAT,
  A for Data-Location,
  I for Instruction of SCM;

registration
 let a,b be Int-Location;
 cluster a:=b -> ins-loc-free;
 cluster AddTo(a,b) -> ins-loc-free;
 cluster SubFrom(a,b) -> ins-loc-free;
 cluster MultBy(a,b) -> ins-loc-free;
 cluster Divide(a,b) -> ins-loc-free;
end;

canceled 7;

theorem :: SCMFSA_4:8
  for k being Element of NAT holds IncAddr(halt SCM+FSA,k) = halt
  SCM+FSA;

theorem :: SCMFSA_4:9
  for k being Element of NAT, a,b being Int-Location
   holds IncAddr(a:=b,k) = a:=b;

theorem :: SCMFSA_4:10
  for k being Element of NAT, a,b being Int-Location holds IncAddr
  (AddTo(a,b),k) = AddTo(a,b);

theorem :: SCMFSA_4:11
  for k being Element of NAT, a,b being Int-Location holds IncAddr
  (SubFrom(a,b),k) = SubFrom(a,b);

theorem :: SCMFSA_4:12
  for k being Element of NAT, a,b being Int-Location holds IncAddr
  (MultBy(a,b),k) = MultBy(a,b);

theorem :: SCMFSA_4:13
  for k being Element of NAT, a,b being Int-Location holds IncAddr
  (Divide(a,b),k) = Divide(a,b);

theorem :: SCMFSA_4:14
  for k being Element of NAT,loc being Element of NAT
  holds IncAddr(goto loc,k) = goto (loc + k);

theorem :: SCMFSA_4:15
  for k being Element of NAT,loc being Element of NAT, a being Int-Location
   holds IncAddr(a=0_goto loc,k) = a=0_goto (loc + k);

theorem :: SCMFSA_4:16
  for k being Element of NAT,loc being Element of NAT
, a being Int-Location holds IncAddr(a>0_goto loc,k) = a>0_goto (loc + k
  );

registration
 let a,b be Int-Location; let f be FinSeq-Location;
 cluster b:=(f,a) -> ins-loc-free;
 cluster (f,a):=b -> ins-loc-free;
end;

theorem :: SCMFSA_4:17
  for k being Element of NAT, a,b being Int-Location, f being
  FinSeq-Location holds IncAddr(b:=(f,a),k) = b:=(f,a);

theorem :: SCMFSA_4:18
  for k being Element of NAT, a,b being Int-Location, f being
  FinSeq-Location holds IncAddr((f,a):=b,k) = (f,a):=b;

registration
 let a be Int-Location; let f be FinSeq-Location;
 cluster a:=len f -> ins-loc-free;
 cluster f:=<0,...,0>a -> ins-loc-free;
end;

theorem :: SCMFSA_4:19
  for k being Element of NAT, a being Int-Location, f being
  FinSeq-Location holds IncAddr(a:=len f,k) = a:=len f;

theorem :: SCMFSA_4:20
  for k being Element of NAT, a being Int-Location, f being
  FinSeq-Location holds IncAddr(f:=<0,...,0>a,k) = f:=<0,...,0>a;

canceled;

theorem :: SCMFSA_4:22
  for I being Instruction of SCM+FSA, k being Element of NAT holds
  InsCode (IncAddr (I, k)) = InsCode I;

reserve i for Instruction of SCM+FSA;

theorem :: SCMFSA_4:23
  IncAddr(IncAddr(i,m),n) = IncAddr(i,m+n);

begin :: Incrementing Addresses in a finite partial state

theorem :: SCMFSA_4:24
  for p being finite NAT-defined (the Instructions of SCM+FSA)-valued Function,
      k being Element of NAT for l
  being Element of NAT st l in dom p holds IncAddr(p,k).l = IncAddr(p/.l,k);

theorem :: SCMFSA_4:25
  for I,J being
   finite NAT-defined (the Instructions of SCM+FSA)-valued Function
    holds IncAddr(I +* J, n) = IncAddr(I,n) +* IncAddr(J,n);

theorem :: SCMFSA_4:26
  for f being Function of the Instructions of SCM+FSA, the Instructions
of SCM+FSA st f = (id the Instructions of SCM+FSA) +* (halt SCM+FSA .--> i) for
  s being finite NAT-defined (the Instructions of SCM+FSA)-valued Function
  holds IncAddr(f*s,n) = ((id the Instructions of
  SCM+FSA) +* (halt SCM+FSA .--> IncAddr(i,n)))* IncAddr(s,n);

theorem :: SCMFSA_4:27
  for I being finite NAT-defined (the Instructions of SCM+FSA)-valued Function
   holds IncAddr(IncAddr(I,m),n) = IncAddr(I,m+n);

theorem :: SCMFSA_4:28
  for p being (the Instructions of SCM+FSA)-valued Function
  for s being State of SCM+FSA
   holds Exec(IncAddr(CurInstr(p, s),k),s +*
  Start-At(IC s+k,SCM+FSA)) = Following(p,s) +*
   Start-At(IC Following(p,s)+k,SCM+FSA);

theorem :: SCMFSA_4:29
  for INS being Instruction of SCM+FSA, s being State of SCM+FSA, p
being FinPartState of SCM+FSA, i, j, k being Element of NAT st IC s = j+k holds
Exec(INS, s +* Start-At(IC s -'k,SCM+FSA)) = Exec(IncAddr(INS, k), s)
 +* Start-At (IC
  Exec(IncAddr(INS,k), s) -'k,SCM+FSA);

theorem :: SCMFSA_4:30
 not InsCode i in {6,7,8} implies IncAddr(i,k) = i;
