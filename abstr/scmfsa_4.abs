:: Modifying addresses of instructions of { \bf SCM_FSA }
::  by Andrzej Trybulec and Yatsuka Nakamura
::
:: Received February 14, 1996
:: Copyright (c) 1996 Association of Mizar Users

environ

 vocabularies AMI_1, AMI_3, BOOLE, RELAT_1, FUNCT_1, FUNCT_4, SCMFSA_2,
      ARYTM_1, CAT_1, RELOC, AMI_5, AMI_2, NAT_1, ABSVALUE, FINSEQ_1, FINSEQ_2,
      SCMFSA_4, CARD_3, FINSEQ_4, ARYTM, AMISTD_2, SCMNORM;
 notations TARSKI, XBOOLE_0, ENUMSET1, SUBSET_1, NUMBERS, CARD_3, XCMPLX_0,
      NAT_1, INT_1, INT_2, RELAT_1, FUNCT_1, PARTFUN1, FUNCT_2, FUNCT_4,
      FUNCOP_1, FUNCT_7, FINSEQ_1, FINSEQ_2, STRUCT_0, AMI_1, SCMNORM, AMI_3,
      RELOC, SCMFSA_2, XXREAL_0;
 constructors DOMAIN_1, XXREAL_0, NAT_1, INT_2, AMI_5, PARTFUN1, RELOC,
      SCMFSA_2, SCMNORM;
 registrations XBOOLE_0, SUBSET_1, SETFAM_1, FUNCT_1, ORDINAL1, RELSET_1,
      FUNCOP_1, FRAENKEL, NUMBERS, XREAL_0, INT_1, CARD_3, AMI_1, SCMFSA_2,
      SCMNORM, FINSET_1;
 requirements NUMERALS, REAL, SUBSET, BOOLE, ARITHM;


begin :: Incrementing addresses

reserve j, k, l, m, n, p, q for Element of NAT;

reserve L for Instruction-Location of SCM,
  A for Data-Location,
  I for Instruction of SCM;

definition
  canceled 2;
  let i be Instruction of SCM+FSA , k be Element of NAT;
  func IncAddr (i,k) -> Instruction of SCM+FSA means
:: SCMFSA_4:def 3

  ex I being Instruction of SCM st I = i & it = IncAddr(I,k)
  if InsCode i in {6,7,8} otherwise it = i;
end;

canceled 7;

theorem :: SCMFSA_4:8
  for k being Element of NAT holds IncAddr(halt SCM+FSA,k) = halt SCM+FSA;

theorem :: SCMFSA_4:9
  for k being Element of NAT, a,b being Int-Location
  holds IncAddr(a:=b,k) = a:=b;

theorem :: SCMFSA_4:10
  for k being Element of NAT, a,b being Int-Location
  holds IncAddr(AddTo(a,b),k) = AddTo(a,b);

theorem :: SCMFSA_4:11
  for k being Element of NAT, a,b being Int-Location
  holds IncAddr(SubFrom(a,b),k) = SubFrom(a,b);

theorem :: SCMFSA_4:12
  for k being Element of NAT, a,b being Int-Location
  holds IncAddr(MultBy(a,b),k) = MultBy(a,b);

theorem :: SCMFSA_4:13
  for k being Element of NAT, a,b being Int-Location
  holds IncAddr(Divide(a,b),k) = Divide(a,b);

theorem :: SCMFSA_4:14
  for k being Element of NAT,loc being Instruction-Location of SCM+FSA
  holds IncAddr(goto loc,k) = goto (loc + k);

theorem :: SCMFSA_4:15
  for k being Element of NAT,loc being Instruction-Location of SCM+FSA,
  a being Int-Location holds IncAddr(a=0_goto loc,k) = a=0_goto (loc + k);

theorem :: SCMFSA_4:16
  for k being Element of NAT,loc being Instruction-Location of SCM+FSA,
  a being Int-Location holds IncAddr(a>0_goto loc,k) = a>0_goto (loc + k);

theorem :: SCMFSA_4:17
  for k being Element of NAT, a,b being Int-Location, f being FinSeq-Location
  holds IncAddr(b:=(f,a),k) = b:=(f,a);

theorem :: SCMFSA_4:18
  for k being Element of NAT, a,b being Int-Location, f being FinSeq-Location
  holds IncAddr((f,a):=b,k) = (f,a):=b;

theorem :: SCMFSA_4:19
  for k being Element of NAT, a being Int-Location, f being FinSeq-Location
  holds IncAddr(a:=len f,k) = a:=len f;

theorem :: SCMFSA_4:20
  for k being Element of NAT, a being Int-Location, f being FinSeq-Location
  holds IncAddr(f:=<0,...,0>a,k) = f:=<0,...,0>a;

theorem :: SCMFSA_4:21
  for i being Instruction of SCM+FSA, I st i = I holds
  IncAddr(i,k) = IncAddr(I,k);

theorem :: SCMFSA_4:22
  for I being Instruction of SCM+FSA, k being Element of NAT
  holds InsCode (IncAddr (I, k)) = InsCode I;

reserve i for Instruction of SCM+FSA;

theorem :: SCMFSA_4:23
  IncAddr(IncAddr(i,m),n) = IncAddr(i,m+n);

begin :: Incrementing Addresses in a finite partial state

definition
 canceled 2;
  let p be preProgram of SCM+FSA, k be Element of NAT;
  func IncAddr(p,k) -> preProgram of SCM+FSA means
:: SCMFSA_4:def 6

  dom it = dom p &
  for m st insloc m in dom p holds it.insloc m = IncAddr(pi(p,m),k);
end;

theorem :: SCMFSA_4:24
  for p being preProgram of SCM+FSA , k being Element of NAT
  for l being Element of NAT st l in dom p
  holds IncAddr (p,k).l = IncAddr(pi(p,l),k);

theorem :: SCMFSA_4:25
  for I,J being preProgram of SCM+FSA holds
  IncAddr(I +* J, n) = IncAddr(I,n) +* IncAddr(J,n);

theorem :: SCMFSA_4:26
  for f being Function of the Instructions of SCM+FSA,
  the Instructions of SCM+FSA
  st f = (id the Instructions of SCM+FSA) +* (halt SCM+FSA .--> i)
  for s being preProgram of SCM+FSA holds IncAddr(f*s,n) =
  ((id the Instructions of SCM+FSA) +* (halt SCM+FSA .--> IncAddr(i,n)))*
  IncAddr(s,n);

theorem :: SCMFSA_4:27
  for I being preProgram of SCM+FSA
  holds IncAddr(IncAddr(I,m),n) = IncAddr(I,m+n);

theorem :: SCMFSA_4:28
  for s being State of SCM+FSA
  holds Exec(IncAddr(CurInstr s,k),s +* Start-At (IC s + k))
  = Following(s) +* Start-At (IC Following(s) + k);

theorem :: SCMFSA_4:29
  for INS being Instruction of SCM+FSA, s being State of SCM+FSA,
  p being FinPartState of SCM+FSA, i, j, k being Element of NAT
  st IC s = j+k holds Exec(INS, s +* Start-At (IC s -' k))
  = Exec(IncAddr(INS, k), s) +* Start-At (IC Exec(IncAddr(INS,k), s) -' k);

begin :: Shifting the finite partial state

canceled 5;

theorem :: SCMFSA_4:35
  for i,j being Element of NAT, p being preProgram of SCM+FSA
  holds Shift(IncAddr(p,i),j) = IncAddr(Shift(p,j),i);

