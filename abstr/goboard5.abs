:: Decomposing a Go Board into Cells
::  by Yatsuka Nakamura and Andrzej Trybulec
::
:: Received May 26, 1995
:: Copyright (c) 1995 Association of Mizar Users

environ

 vocabulary PRE_TOPC, EUCLID, MATRIX_1, FINSEQ_1, TREES_1, RELAT_1, MCART_1,
      GOBOARD1, SEQM_3, FUNCT_1, INCSP_1, ORDINAL2, BOOLE, TOPREAL1, GOBOARD2,
      FINSEQ_6, CARD_1, MATRIX_2, ABSVALUE, ARYTM_1, GOBOARD5, FINSEQ_4;
 notation TARSKI, XBOOLE_0, ENUMSET1, ZFMISC_1, NUMBERS, XREAL_0, REAL_1,
      NAT_1, BINARITH, ABSVALUE, CARD_1, FUNCT_1, FINSEQ_1, FINSEQ_4, MATRIX_1,
      MATRIX_2, STRUCT_0, PRE_TOPC, EUCLID, TOPREAL1, GOBOARD1, GOBOARD2,
      FINSEQ_6;
 constructors DOMAIN_1, SEQM_3, REAL_1, BINARITH, ABSVALUE, MATRIX_2, TOPREAL1,
      GOBOARD2, FINSEQ_4, FINSEQ_6, MEMBERED, XBOOLE_0;
 clusters STRUCT_0, RELSET_1, GOBOARD1, GOBOARD2, MATRIX_1, EUCLID, FINSEQ_1,
      NAT_1, MEMBERED, ZFMISC_1, XBOOLE_0;
 requirements NUMERALS, REAL, BOOLE, SUBSET, ARITHM;


begin

 reserve p,q for Point of TOP-REAL 2,
         i,i1,i2,j,j1,j2,k for Nat,
         r,s for Real,
         G for Matrix of TOP-REAL 2;

theorem :: GOBOARD5:1
 for M being tabular FinSequence, i,j st [i,j] in Indices M
   holds 1 <= i & i <= len M & 1 <= j & j <= width M;

definition let G be Matrix of TOP-REAL 2; let i;
 func v_strip(G,i) -> Subset of TOP-REAL 2 equals
:: GOBOARD5:def 1
  { |[r,s]| : G*(i,1)`1 <= r & r <= G*(i+1,1)`1 }
                    if 1 <= i & i < len G,
     { |[r,s]| : G*(i,1)`1 <= r }
                    if i >= len G
   otherwise { |[r,s]| : r <= G*(i+1,1)`1 };
 func h_strip(G,i) -> Subset of TOP-REAL 2 equals
:: GOBOARD5:def 2
  { |[r,s]| : G*(1,i)`2 <= s & s <= G*(1,i+1)`2 }
                    if 1 <= i & i < width G,
     { |[r,s]| : G*(1,i)`2 <= s }
                    if i >= width G
   otherwise { |[r,s]| : s <= G*(1,i+1)`2 };
end;


theorem :: GOBOARD5:2
 G is Y_equal-in-column &
 1 <= j & j <= width G & 1 <= i & i <= len G
 implies G*(i,j)`2 = G*(1,j)`2;

theorem :: GOBOARD5:3
 G is X_equal-in-line &
 1 <= j & j <= width G & 1 <= i & i <= len G
 implies G*(i,j)`1 = G*(i,1)`1;

theorem :: GOBOARD5:4
 G is X_increasing-in-column &
 1 <= j & j <= width G & 1 <= i1 & i1 < i2 & i2 <= len G
 implies G*(i1,j)`1 < G*(i2,j)`1;

theorem :: GOBOARD5:5
 G is Y_increasing-in-line &
 1 <= j1 & j1 < j2 & j2 <= width G & 1 <= i & i <= len G
 implies G*(i,j1)`2 < G*(i,j2)`2;

theorem :: GOBOARD5:6
 G is Y_equal-in-column &
 1 <= j & j < width G & 1 <= i & i <= len G
  implies h_strip(G,j) = { |[r,s]| : G*(i,j)`2 <= s & s <= G*(i,j+1)`2 };

theorem :: GOBOARD5:7
 G is non empty-yielding Y_equal-in-column &
 1 <= i & i <= len G
  implies h_strip(G,width G) = { |[r,s]| : G*(i,width G)`2 <= s };

theorem :: GOBOARD5:8
 G is non empty-yielding Y_equal-in-column &
 1 <= i & i <= len G
  implies h_strip(G,0) = { |[r,s]| : s <= G*(i,1)`2 };

theorem :: GOBOARD5:9
 G is X_equal-in-line &
 1 <= i & i < len G & 1 <= j & j <= width G
  implies v_strip(G,i) = { |[r,s]| : G*(i,j)`1 <= r & r <= G*(i+1,j)`1 };

theorem :: GOBOARD5:10
 G is non empty-yielding X_equal-in-line &
 1 <= j & j <= width G
  implies v_strip(G,len G) = { |[r,s]| : G*(len G,j)`1 <= r };

theorem :: GOBOARD5:11
 G is non empty-yielding X_equal-in-line &
 1 <= j & j <= width G
  implies v_strip(G,0) = { |[r,s]| : r <= G*(1,j)`1 };

definition let G be Matrix of TOP-REAL 2; let i,j;
 func cell(G,i,j) -> Subset of TOP-REAL 2 equals
:: GOBOARD5:def 3
   v_strip(G,i) /\ h_strip(G,j);
end;


definition let IT be FinSequence of TOP-REAL 2;
 attr IT is s.c.c. means
:: GOBOARD5:def 4
    for i,j st i+1 < j & (i > 1 & j < len IT or j+1 < len IT)
       holds LSeg(IT,i) misses LSeg(IT,j);
end;


definition let IT be non empty FinSequence of TOP-REAL 2;
 attr IT is standard means
:: GOBOARD5:def 5
  IT is_sequence_on GoB IT;
end;


registration
 cluster non constant special unfolded circular s.c.c.
           standard (non empty FinSequence of TOP-REAL 2);
 existence
  proof
   set f1 = <*|[ 0,0 ]|,|[ 0,1 ]|,|[ 1,1 ]|*>, f2 = <*|[ 1,0 ]|,|[ 0,0 ]|*>;
A1:len f1 = 3 & len f2 = 2 by FINSEQ_1:61,62;
    then A2: len(f1^f2) = 3+2 by FINSEQ_1:35;
    then reconsider f = f1^f2 as non empty FinSequence of TOP-REAL 2
                                   by FINSEQ_1:25;
   take f;
A3:  1 in dom f1 by A1,FINSEQ_3:27;
then A4: f/.1 = f1/.1 by GROUP_5:95 .= |[ 0,0 ]| by FINSEQ_4:27;
A5:  2 in dom f1 by A1,FINSEQ_3:27;
then A6: f/.2 = f1/.2 by GROUP_5:95 .= |[ 0,1 ]| by FINSEQ_4:27;
   A7: dom f1 c= dom f by FINSEQ_1:39;
    then f.1 = f/.1 & f.2 = f/.2 by A3,A5,FINSEQ_4:def 4;
    then f.1 <> f.2 by A4,A6,SPPOL_2:1;
   hence f is non constant by A3,A5,A7,GOBOARD1:def 2;
      3 in dom f1 by A1,FINSEQ_3:27;
then A8: f/.3 = f1/.3 by GROUP_5:95 .= |[ 1,1 ]| by FINSEQ_4:27;
      1 in dom f2 by A1,FINSEQ_3:27;
then A9: f/.(3+1) = f2/.1 by A1,GROUP_5:96 .= |[ 1,0 ]| by FINSEQ_4:26;
      2 in dom f2 by A1,FINSEQ_3:27;
then A10: f/.(3+2) = f2/.2 by A1,GROUP_5:96 .= |[ 0,0 ]| by FINSEQ_4:26;
       1+1 = 2;
then A11: LSeg(f,1) = LSeg(|[ 0,0 ]|,|[ 0,1 ]|) by A2,A4,A6,TOPREAL1:def 5;
       2+1 = 3;
then A12: LSeg(f,2) = LSeg(|[ 0,1 ]|,|[ 1,1 ]|) by A2,A6,A8,TOPREAL1:def 5;
A13: LSeg(f,3) = LSeg(|[ 1,1 ]|,|[ 1,0 ]|) by A2,A8,A9,TOPREAL1:def 5;
       4+1 = 5;
then A14: LSeg(f,4) = LSeg(|[ 1,0 ]|,|[ 0,0 ]|) by A2,A9,A10,TOPREAL1:def 5;
   thus f is special
    proof let i;
    assume 1 <= i;
     then 1+1 <= i+1 by AXIOMS:24;
     then A15:   1 < i+1 & 0 < i+1 by AXIOMS:22;
    assume i+1 <= len f;
      then A16: i+1 = 1+1 or i+1 = 2+1 or i+1 = 3+1 or i+1 = 4+1
          by A2,A15,CQC_THE1:6;
     per cases by A16,XCMPLX_1:2;
      suppose
A17:      i = 1;
          (f/.1)`1 = 0 by A4,EUCLID:56 .= (f/.(1+1))`1 by A6,EUCLID:56;
       hence thesis by A17;
      end;
      suppose
A18:     i = 2;
         (f/.2)`2 = 1 by A6,EUCLID:56 .= (f/.(2+1))`2 by A8,EUCLID:56;
       hence thesis by A18;
      end;
      suppose
A19:     i = 3;
         (f/.3)`1 = 1 by A8,EUCLID:56 .= (f/.(3+1))`1 by A9,EUCLID:56;
       hence thesis by A19;
      end;
      suppose
A20:     i = 4;
         (f/.4)`2 = 0 by A9,EUCLID:56 .= (f/.(4+1))`2 by A10,EUCLID:56;
       hence thesis by A20;
    end;
    end;
   thus f is unfolded
    proof let i;
     assume 1 <= i;
      then 1+2 <= i+2 by AXIOMS:24;
      then A21:   2 < i+2 & 1 < i+2 & 0 < i+2 by AXIOMS:22;
     assume i + 2 <= len f;
      then A22: i+2 = 1+2 or i+2 = 2+2 or i+2 = 3+2 by A2,A21,CQC_THE1:6;
      per cases by A22,XCMPLX_1:2;
     suppose
      i = 1;
      hence LSeg(f,i) /\ LSeg(f,i+1) = {f/.(i+1)} by A2,A4,A6,A12,TOPREAL1:21,
def 5;
     end;
     suppose
      i = 2;
      hence LSeg(f,i) /\ LSeg(f,i+1) = {f/.(i+1)} by A2,A6,A8,A13,TOPREAL1:24,
def 5;
     end;
     suppose
      i = 3;
      hence LSeg(f,i) /\ LSeg(f,i+1) = {f/.(i+1)} by A2,A8,A9,A14,TOPREAL1:22,
def 5;
    end;
    end;
   thus
  f/.1 = f/.len f by A1,A4,A10,FINSEQ_1:35;
   thus f is s.c.c.
    proof let i,j;
     assume that
A23:  i+1 < j and
A24:  (i > 1 & j < len f or j+1 < len f);
A25:   i+1 >= 1 by NAT_1:29;
     then A26:   i+1 >= 0 by AXIOMS:22;
     A27:   j+1 = 0+1 or j+1 = 1+1 or j+1 = 2+1 or j+1 = 3+1 or j+1 = 4+1
                                            by A2,A24,CQC_THE1:6;
A28:   i+1+1 = i+(1+1) by XCMPLX_1:1;
     then A29:  i+2 <= j by A23,NAT_1:38;
A30:   (i+2 = 2+2 implies i=2) &
     (i+2 = 1+2 implies i=1) &
     (i+2 = 0+2 implies i=0) by XCMPLX_1:2;
A31:   i+2 <> 0+1 by A28,XCMPLX_1:2;
A32:   now per cases by A23,A25,A26,A27,XCMPLX_1:2;
       case j = 2;
        hence i = 0 by A23,A28,A30,CQC_THE1:3;
       end;
       case j = 3;
        hence i = 0 or i = 1 by A23,A28,A30,CQC_THE1:4;
       end;
       case
       j = 4;
        hence i = 0 or i = 2 by A2,A24,A29,A30,A31,CQC_THE1:5;
      end;
      end;
     per cases by A32;
     suppose i = 0;
      then LSeg(f,i) = {} by TOPREAL1:def 5;
     hence LSeg(f,i) /\ LSeg(f,j) = {};
     end;
     suppose i = 1 & j = 3;
     hence LSeg(f,i) /\ LSeg(f,j) = {} by A11,A13,TOPREAL1:26,XBOOLE_0:def 7;
     end;
     suppose i = 2 & j = 4;
     hence LSeg(f,i) /\ LSeg(f,j) = {} by A12,A14,TOPREAL1:25,XBOOLE_0:def 7;
    end;
    end;
    set Xf1 = <*0,0,1 qua Real *>, Xf2 = <* 1,0 qua Real *>;
    reconsider Xf = Xf1^Xf2 as FinSequence of REAL;
A33:len Xf1 = 3 & len Xf2 = 2 by FINSEQ_1:61,62;
    then A34: len Xf = 3+2 by FINSEQ_1:35;
      1 in dom Xf1 by A33,FINSEQ_3:27;
then A35: Xf.1 = Xf1.1 by FINSEQ_1:def 7 .= 0 by FINSEQ_1:62;
      2 in dom Xf1 by A33,FINSEQ_3:27;
then A36: Xf.2 = Xf1.2 by FINSEQ_1:def 7 .= 0 by FINSEQ_1:62;
      3 in dom Xf1 by A33,FINSEQ_3:27;
then A37: Xf.3 = Xf1.3 by FINSEQ_1:def 7 .= 1 by FINSEQ_1:62;
      1 in dom Xf2 by A33,FINSEQ_3:27;
then A38: Xf.(3+1) = Xf2.1 by A33,FINSEQ_1:def 7 .= 1 by FINSEQ_1:61;
      2 in dom Xf2 by A33,FINSEQ_3:27;
then A39: Xf.(3+2) = Xf2.2 by A33,FINSEQ_1:def 7 .= 0 by FINSEQ_1:61;
       now let n be Nat;
      assume n in dom Xf;
       then A40:    n <> 0 & n <= 5 by A34,FINSEQ_3:27;
      per cases by A40,CQC_THE1:6;
      suppose n = 1;
      hence Xf.n = (f/.n)`1 by A4,A35,EUCLID:56;
      end;
      suppose n = 2;
      hence Xf.n = (f/.n)`1 by A6,A36,EUCLID:56;
      end;
      suppose n = 3;
      hence Xf.n = (f/.n)`1 by A8,A37,EUCLID:56;
      end;
      suppose n = 4;
      hence Xf.n = (f/.n)`1 by A9,A38,EUCLID:56;
      end;
      suppose n = 5;
      hence Xf.n = (f/.n)`1 by A10,A39,EUCLID:56;
     end;
     end;
     then A41:   Xf = X_axis f by A2,A34,GOBOARD1:def 3;
A42:    rng Xf1 = { 0,0,1 } by FINSEQ_2:148 .= { 0,1 } by ENUMSET1:70;
        rng Xf2 = { 0,1 } by FINSEQ_2:147;
then A43:   rng Xf = { 0,1 } \/ { 0,1 } by A42,FINSEQ_1:44
            .= { 0,1 };
      then A44:   rng <*0,1 qua Real*> = rng Xf by FINSEQ_2:147;
A45:   len <*0,1 qua Real*> = 2 by FINSEQ_1:61 .= card rng Xf by A43,CARD_2:76;
       <*0,1 qua Real*> is increasing
       proof let n,m be Nat;
           len <*0,1 qua Real*> = 2 by FINSEQ_1:61;
then A46:       dom <*0,1 qua Real*> = { 1,2 } by FINSEQ_1:4,def 3;
        assume n in dom <*0,1 qua Real*> & m in dom <*0,1 qua Real*>;
         then A47:       (n = 1 or n = 2) & (m = 1 or m = 2) by A46,TARSKI:def
2;
        assume n < m;
         then <*0,1 qua Real*>.n = 0 & <*0,1 qua Real*>.m = 1 by A47,FINSEQ_1:
61;
        hence <*0,1 qua Real*>.n < <*0,1 qua Real*>.m;
       end;
     then A48: <*0,1 qua Real*> = Incr X_axis f by A41,A44,A45,GOBOARD2:def 2;
    set Yf1 = <*0,1,1 qua Real *>, Yf2 = <* 0,0 qua Real *>;
    reconsider Yf = Yf1^Yf2 as FinSequence of REAL;
A49:len Yf1 = 3 & len Yf2 = 2 by FINSEQ_1:61,62;
    then A50: len Yf = 3+2 by FINSEQ_1:35;
      1 in dom Yf1 by A49,FINSEQ_3:27;
then A51: Yf.1 = Yf1.1 by FINSEQ_1:def 7 .= 0 by FINSEQ_1:62;
      2 in dom Yf1 by A49,FINSEQ_3:27;
then A52: Yf.2 = Yf1.2 by FINSEQ_1:def 7 .= 1 by FINSEQ_1:62;
      3 in dom Yf1 by A49,FINSEQ_3:27;
then A53: Yf.3 = Yf1.3 by FINSEQ_1:def 7 .= 1 by FINSEQ_1:62;
      1 in dom Yf2 by A49,FINSEQ_3:27;
then A54: Yf.(3+1) = Yf2.1 by A49,FINSEQ_1:def 7 .= 0 by FINSEQ_1:61;
      2 in dom Yf2 by A49,FINSEQ_3:27;
then A55: Yf.(3+2) = Yf2.2 by A49,FINSEQ_1:def 7 .= 0 by FINSEQ_1:61;
       now let n be Nat;
      assume n in dom Yf;
       then A56:    n <> 0 & n <= 5 by A50,FINSEQ_3:27;
      per cases by A56,CQC_THE1:6;
      suppose n = 1;
      hence Yf.n = (f/.n)`2 by A4,A51,EUCLID:56;
      end;
      suppose n = 2;
      hence Yf.n = (f/.n)`2 by A6,A52,EUCLID:56;
      end;
      suppose n = 3;
      hence Yf.n = (f/.n)`2 by A8,A53,EUCLID:56;
      end;
      suppose n = 4;
      hence Yf.n = (f/.n)`2 by A9,A54,EUCLID:56;
      end;
      suppose n = 5;
      hence Yf.n = (f/.n)`2 by A10,A55,EUCLID:56;
     end;
     end;
     then A57:   Yf = Y_axis f by A2,A50,GOBOARD1:def 4;
A58:    rng Yf1 = { 0,1,1 } by FINSEQ_2:148 .= { 1,1,0 } by ENUMSET1:100
           .= { 0,1 } by ENUMSET1:70;
        rng Yf2 = { 0,0 } by FINSEQ_2:147 .= { 0 } by ENUMSET1:69;
then A59:   rng Yf = { 0,1 } \/ { 0 } by A58,FINSEQ_1:44
            .= { 0,0,1 } by ENUMSET1:42
            .= { 0,1 } by ENUMSET1:70;
      then A60:   rng <*0,1 qua Real*> = rng Yf by FINSEQ_2:147;
A61:   len <*0,1 qua Real*> = 2 by FINSEQ_1:61 .= card rng Yf by A59,CARD_2:76;
       <*0,1 qua Real*> is increasing
       proof let n,m be Nat;
           len <*0,1 qua Real*> = 2 by FINSEQ_1:61;
then A62:       dom <*0,1 qua Real*> = { 1,2 } by FINSEQ_1:4,def 3;
        assume n in dom <*0,1 qua Real*> & m in dom <*0,1 qua Real*>;
         then A63:       (n = 1 or n = 2) & (m = 1 or m = 2) by A62,TARSKI:def
2;
        assume n < m;
         then <*0,1 qua Real*>.n = 0 & <*0,1 qua Real*>.m = 1 by A63,FINSEQ_1:
61;
        hence <*0,1 qua Real*>.n < <*0,1 qua Real*>.m;
       end;
     then A64:   <*0,1 qua Real*> = Incr Y_axis f by A57,A60,A61,GOBOARD2:def 2
;
     set M = (|[0,0]|,|[0,1]|)][(|[1,0]|,|[1,1]|);
A65:  len M = 2 by MATRIX_2:3 .= len Incr X_axis f by A48,FINSEQ_1:61;
A66:  width M = 2 by MATRIX_2:3 .= len Incr Y_axis f by A64,FINSEQ_1:61;
       for n,m being Nat st [n,m] in Indices M
            holds M*(n,m) = |[(Incr X_axis f).n,(Incr Y_axis f).m]|
      proof let n,m be Nat;
       assume [n,m] in Indices M;
        then [n,m] in [:{ 1,2 },{ 1,2 }:] by FINSEQ_1:4,MATRIX_2:3;
        then A67:     [n,m] in {[1,1],[1,2],[2,1],[2,2]} by MCART_1:25;
A68:    <*0,1 qua Real*>.1 = 0 & <*0,1 qua Real*>.2 = 1 by FINSEQ_1:61;
       per cases by A67,ENUMSET1:18;
       suppose [n,m] = [1,1];
        then n = 1 & m = 1 by ZFMISC_1:33;
       hence M*(n,m) = |[(Incr X_axis f).n,(Incr Y_axis f).m]| by A48,A64,A68,
MATRIX_2:6;
       end;
       suppose [n,m] = [1,2];
        then n = 1 & m = 2 by ZFMISC_1:33;
       hence M*(n,m) = |[(Incr X_axis f).n,(Incr Y_axis f).m]| by A48,A64,A68,
MATRIX_2:6;
       end;
       suppose [n,m] = [2,1];
        then n = 2 & m = 1 by ZFMISC_1:33;
       hence M*(n,m) = |[(Incr X_axis f).n,(Incr Y_axis f).m]| by A48,A64,A68,
MATRIX_2:6;
       end;
       suppose [n,m] = [2,2];
        then n = 2 & m = 2 by ZFMISC_1:33;
       hence M*(n,m) = |[(Incr X_axis f).n,(Incr Y_axis f).m]| by A48,A64,A68,
MATRIX_2:6;
      end;
      end;
      then A69: (|[0,0]|,|[0,1]|)][(|[1,0]|,|[1,1]|)
              = GoB(Incr X_axis f, Incr Y_axis f) by A65,A66,GOBOARD2:def 1
             .= GoB f by GOBOARD2:def 3;
then A70: f/.1 = (GoB f)*(1,1) by A4,MATRIX_2:6;
A71: f/.2 = (GoB f)*(1,2) by A6,A69,MATRIX_2:6;
A72: f/.3 = (GoB f)*(2,2) by A8,A69,MATRIX_2:6;
A73: f/.4 = (GoB f)*(2,1) by A9,A69,MATRIX_2:6;
   thus for k st k in dom f
    ex i,j st [i,j] in Indices GoB f & f/.k = (GoB f)*(i,j)
   proof let k;
    assume A74: k in dom f;
     then A75:    k >= 1 & k <= 5 by A2,FINSEQ_3:27;
     A76:    k <> 0 by A74,FINSEQ_3:27;
    per cases by A75,A76,CQC_THE1:6;
    suppose
A77:    k = 1;
     take 1,1;
     thus [1,1] in Indices GoB f by A69,MATRIX_2:4;
     thus f/.k = (GoB f)*(1,1) by A4,A69,A77,MATRIX_2:6;
    end;
    suppose
A78:    k = 2;
     take 1,2;
     thus [1,2] in Indices GoB f by A69,MATRIX_2:4;
     thus f/.k = (GoB f)*(1,2) by A6,A69,A78,MATRIX_2:6;
    end;
    suppose
A79:    k = 3;
     take 2,2;
     thus [2,2] in Indices GoB f by A69,MATRIX_2:4;
     thus f/.k = (GoB f)*(2,2) by A8,A69,A79,MATRIX_2:6;
    end;
    suppose
A80:    k = 4;
     take 2,1;
     thus [2,1] in Indices GoB f by A69,MATRIX_2:4;
     thus f/.k = (GoB f)*(2,1) by A9,A69,A80,MATRIX_2:6;
    end;
    suppose
A81:    k = 5;
     take 1,1;
     thus [1,1] in Indices GoB f by A69,MATRIX_2:4;
     thus f/.k = (GoB f)*(1,1) by A10,A69,A81,MATRIX_2:6;
   end;
   end;
   let n be Nat such that
A82: n in dom f and
A83: n+1 in dom f;
   let m,k,i,j be Nat such that
A84: [m,k] in Indices GoB f and
A85: [i,j] in Indices GoB f and
A86: f/.n = (GoB f)*(m,k) and
A87: f/.(n+1) = (GoB f)*(i,j);
   A88:  n <> 0 by A82,FINSEQ_3:27;
      n+1 <= 4+1 by A2,A83,FINSEQ_3:27;
    then A89: n <= 4 by REAL_1:53;
   per cases by A88,A89,CQC_THE1:5;
   suppose
A90:  n = 1;
      [1,1] in Indices GoB f by A69,MATRIX_2:4;
then A91:  m = 1 & k = 1 by A70,A84,A86,A90,GOBOARD1:21;
      [1,2] in Indices GoB f by A69,MATRIX_2:4;
then A92:  i = 1 & j = 1+1 by A71,A85,A87,A90,GOBOARD1:21;
    then abs(k-j) = 1 by A91,GOBOARD1:1;
   hence abs(m-i)+abs(k-j) = 1 by A91,A92,GOBOARD1:2;
   end;
   suppose
A93:  n = 2;
      [1,2] in Indices GoB f by A69,MATRIX_2:4;
then A94:  m = 1 & k = 2 by A71,A84,A86,A93,GOBOARD1:21;
      [2,2] in Indices GoB f by A69,MATRIX_2:4;
then A95:  i = 1+1 & j = 2 by A72,A85,A87,A93,GOBOARD1:21;
    then abs(m-i) = 1 by A94,GOBOARD1:1;
   hence abs(m-i)+abs(k-j) = 1 by A94,A95,GOBOARD1:2;
   end;
   suppose
A96:  n = 3;
      [2,2] in Indices GoB f by A69,MATRIX_2:4;
then A97:  m = 2 & k = 1+1 by A72,A84,A86,A96,GOBOARD1:21;
      [2,1] in Indices GoB f by A69,MATRIX_2:4;
then A98:  i = 2 & j = 1 by A73,A85,A87,A96,GOBOARD1:21;
    then abs(k-j) = 1 by A97,GOBOARD1:1;
   hence abs(m-i)+abs(k-j) = 1 by A97,A98,GOBOARD1:2;
   end;
   suppose
A99:  n = 4;
      [2,1] in Indices GoB f by A69,MATRIX_2:4;
then A100:  m = 1+1 & k = 1 by A73,A84,A86,A99,GOBOARD1:21;
      [1,1] in Indices GoB f by A69,MATRIX_2:4;
then A101:  i = 1 & j = 1 by A4,A10,A70,A85,A87,A99,GOBOARD1:21;
    then abs(m-i) = 1 by A100,GOBOARD1:1;
   hence abs(m-i)+abs(k-j) = 1 by A100,A101,GOBOARD1:2;
  end;
  end;
end;

theorem :: GOBOARD5:12
 for f being non empty FinSequence of TOP-REAL 2
 for n being Nat st n in dom f
   ex i,j st [i,j] in Indices GoB f & f/.n = (GoB f)*(i,j);

theorem :: GOBOARD5:13
for f being standard (non empty FinSequence of TOP-REAL 2),
    n being Nat st n in dom f & n+1 in dom f
for m,k,i,j being Nat
      st [m,k] in Indices GoB f & [i,j] in Indices GoB f &
         f/.n = (GoB f)*(m,k) & f/.(n+1) = (GoB f)*(i,j)
holds abs(m-i)+abs(k-j) = 1;

definition
 mode special_circular_sequence is
       special unfolded circular s.c.c. non empty FinSequence of TOP-REAL 2;
end;


reserve f for standard special_circular_sequence;

definition let f,k;
  assume
 1 <= k & k+1 <= len f;
 func right_cell(f,k) -> Subset of TOP-REAL 2 means
:: GOBOARD5:def 6
 for i1,j1,i2,j2 being Nat st
      [i1,j1] in Indices GoB f & [i2,j2] in Indices GoB f &
      f/.k = (GoB f)*(i1,j1) & f/.(k+1) = (GoB f)*(i2,j2) holds
    i1 = i2 & j1+1 = j2 & it = cell(GoB f,i1,j1) or
    i1+1 = i2 & j1 = j2 & it = cell(GoB f,i1,j1-'1) or
    i1 = i2+1 & j1 = j2 & it = cell(GoB f,i2,j2) or
    i1 = i2 & j1 = j2+1 & it = cell(GoB f,i1-'1,j2);
 func left_cell(f,k) -> Subset of TOP-REAL 2 means
:: GOBOARD5:def 7
  for i1,j1,i2,j2 being Nat st
      [i1,j1] in Indices GoB f & [i2,j2] in Indices GoB f &
      f/.k = (GoB f)*(i1,j1) & f/.(k+1) = (GoB f)*(i2,j2) holds
    i1 = i2 & j1+1 = j2 & it = cell(GoB f,i1-'1,j1) or
    i1+1 = i2 & j1 = j2 & it = cell(GoB f,i1,j1) or
    i1 = i2+1 & j1 = j2 & it = cell(GoB f,i2,j2-'1) or
    i1 = i2 & j1 = j2+1 & it = cell(GoB f,i1,j2);
end;


theorem :: GOBOARD5:14
 G is non empty-yielding X_equal-in-line X_increasing-in-column &
 i < len G & 1 <= j & j < width G
  implies LSeg(G*(i+1,j),G*(i+1,j+1)) c= v_strip(G,i);

theorem :: GOBOARD5:15
 G is non empty-yielding X_equal-in-line X_increasing-in-column &
 1 <= i & i <= len G & 1 <= j & j < width G
  implies LSeg(G*(i,j),G*(i,j+1)) c= v_strip(G,i);

theorem :: GOBOARD5:16
 G is non empty-yielding Y_equal-in-column Y_increasing-in-line &
 j < width G & 1 <= i & i < len G
  implies LSeg(G*(i,j+1),G*(i+1,j+1)) c= h_strip(G,j);

theorem :: GOBOARD5:17
 G is non empty-yielding Y_equal-in-column Y_increasing-in-line &
 1 <= j & j <= width G & 1 <= i & i < len G
  implies LSeg(G*(i,j),G*(i+1,j)) c= h_strip(G,j);

theorem :: GOBOARD5:18
 G is Y_equal-in-column Y_increasing-in-line &
 1 <= i & i <= len G & 1 <= j & j+1 <= width G
  implies LSeg(G*(i,j),G*(i,j+1)) c= h_strip(G,j);

theorem :: GOBOARD5:19
 for G being Go-board holds
 i < len G & 1 <= j & j < width G
  implies LSeg(G*(i+1,j),G*(i+1,j+1)) c= cell(G,i,j);

theorem :: GOBOARD5:20
 for G being Go-board holds
 1 <= i & i <= len G & 1 <= j & j < width G
  implies LSeg(G*(i,j),G*(i,j+1)) c= cell(G,i,j);

theorem :: GOBOARD5:21
 G is X_equal-in-line X_increasing-in-column &
 1 <= j & j <= width G & 1 <= i & i+1 <= len G
  implies LSeg(G*(i,j),G*(i+1,j)) c= v_strip(G,i);

theorem :: GOBOARD5:22
 for G being Go-board holds
 j < width G & 1 <= i & i < len G
  implies LSeg(G*(i,j+1),G*(i+1,j+1)) c= cell(G,i,j);

theorem :: GOBOARD5:23
 for G being Go-board holds
 1 <= i & i < len G & 1 <= j & j <= width G
  implies LSeg(G*(i,j),G*(i+1,j)) c= cell(G,i,j);

theorem :: GOBOARD5:24
 G is non empty-yielding X_equal-in-line X_increasing-in-column &
 i+1 <= len G implies
  v_strip(G,i) /\ v_strip(G,i+1) = { q : q`1 = G*(i+1,1)`1 };

theorem :: GOBOARD5:25
 G is non empty-yielding Y_equal-in-column Y_increasing-in-line &
 j+1 <= width G implies
    h_strip(G,j) /\ h_strip(G,j+1) = { q : q`2 = G*(1,j+1)`2 };

theorem :: GOBOARD5:26
 for G being Go-board holds
  i < len G & 1 <= j & j < width G
  implies cell(G,i,j) /\ cell(G,i+1,j) = LSeg(G*(i+1,j),G*(i+1,j+1));

theorem :: GOBOARD5:27
 for G being Go-board holds
 j < width G & 1 <= i & i < len G
 implies cell(G,i,j) /\ cell(G,i,j+1) = LSeg(G*(i,j+1),G*(i+1,j+1));

theorem :: GOBOARD5:28
 1 <= k & k+1 <= len f & [i+1,j] in Indices GoB f & [i+1,j+1] in
 Indices GoB f &
 f/.k = (GoB f)*(i+1,j) & f/.(k+1) = (GoB f)*(i+1,j+1) implies
  left_cell(f,k) = cell(GoB f,i,j) & right_cell(f,k) = cell(GoB f,i+1,j);

theorem :: GOBOARD5:29
 1 <= k & k+1 <= len f & [i,j+1] in Indices GoB f & [i+1,j+1] in
 Indices GoB f &
 f/.k = (GoB f)*(i,j+1) & f/.(k+1) = (GoB f)*(i+1,j+1) implies
  left_cell(f,k) = cell(GoB f,i,j+1) & right_cell(f,k) = cell(GoB f,i,j);

theorem :: GOBOARD5:30
 1 <= k & k+1 <= len f & [i,j+1] in Indices GoB f & [i+1,j+1] in
 Indices GoB f &
 f/.k = (GoB f)*(i+1,j+1) & f/.(k+1) = (GoB f)*(i,j+1) implies
  left_cell(f,k) = cell(GoB f,i,j) & right_cell(f,k) = cell(GoB f,i,j+1);

theorem :: GOBOARD5:31
 1 <= k & k+1 <= len f & [i+1,j+1] in Indices GoB f & [i+1,j] in
 Indices GoB f &
 f/.k = (GoB f)*(i+1,j+1) & f/.(k+1) = (GoB f)*(i+1,j) implies
  left_cell(f,k) = cell(GoB f,i+1,j) & right_cell(f,k) = cell(GoB f,i,j);

theorem :: GOBOARD5:32
   1 <= k & k+1 <= len f implies left_cell(f,k) /\ right_cell(f,k) = LSeg(f,k);

