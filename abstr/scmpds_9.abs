:: SCMPDS Is Not Standard
::  by Artur Korni{\l}owicz and Yasunari Shidama
::
:: Received September 27, 2003
:: Copyright (c) 2003 Association of Mizar Users

environ

 vocabularies BOOLE, SETFAM_1, FUNCT_1, ARYTM, ORDINAL2, FUNCT_4, FINSEQ_1,
      FINSEQ_4, RELAT_1, CAT_1, FINSET_1, ARYTM_3, ARYTM_1, ABSVALUE, INT_1,
      NAT_1, FUNCOP_1, AMI_1, AMI_2, AMI_3, AMISTD_1, SCMPDS_2, SCMPDS_3,
      GOBOARD5, SQUARE_1, ORDINAL1;
 notations TARSKI, XBOOLE_0, SUBSET_1, SETFAM_1, ORDINAL1, NUMBERS, XCMPLX_0,
      XXREAL_0, XREAL_0, FUNCT_1, PARTFUN1, INT_1, NAT_1, FINSET_1, COMPLEX1,
      STRUCT_0, INT_2, RELAT_1, FUNCT_4, FINSEQ_1, PRE_CIRC, AMI_1, AMI_2,
      AMI_3, SCMPDS_2, SCMPDS_3, SCMNORM, AMISTD_1;
 constructors PARTFUN1, XXREAL_0, REAL_1, NAT_1, NAT_D, REALSET1, PRE_CIRC,
      AMI_5, SCMPDS_1, SCMPDS_3, AMISTD_2;
 registrations XBOOLE_0, SETFAM_1, ORDINAL1, RELSET_1, FINSET_1, FRAENKEL,
      NUMBERS, XXREAL_0, XREAL_0, NAT_1, INT_1, MEMBERED, CARD_3, AMI_1,
      SCMPDS_2, SCMNORM;
 requirements BOOLE, SUBSET, NUMERALS, ARITHM, REAL;


begin :: Preliminaries

reserve r, s for real number;

theorem :: SCMPDS_9:1
  0 <= r + abs(r);

theorem :: SCMPDS_9:2
  0 <= -r + abs(r);

theorem :: SCMPDS_9:3
  abs(r) = abs(s) implies r = s or r = -s;

theorem :: SCMPDS_9:4
  for i, j being natural number st i < j & i <> 0 holds i/j is not integer;

theorem :: SCMPDS_9:5
  {k where k is Element of NAT: k > 1} is infinite;

begin :: SCMPDS

reserve a, b for Int_position,
  i for Instruction of SCMPDS,
  l for Instruction-Location of SCMPDS,
  k, k1, k2 for Integer;

definition
  let la, lb be Int_position, a, b be Integer;
  redefine func (la,lb) --> (a,b) -> FinPartState of SCMPDS;
end;

definition
  let l be Instruction-Location of SCMPDS;
  func locnum l -> natural number means
:: SCMPDS_9:def 1

  il.it = l;
end;

definition
  let l be Instruction-Location of SCMPDS;
  redefine func locnum l -> Element of NAT;
end;

canceled 2;

theorem :: SCMPDS_9:8
  l = locnum l;

theorem :: SCMPDS_9:9
  for l1, l2 being Instruction-Location of SCMPDS st l1 <> l2 holds
  locnum l1 <> locnum l2;

canceled 2;

theorem :: SCMPDS_9:12
  (for s being State of SCMPDS st IC s = l & s.l = i
  holds Exec(i,s).IC SCMPDS = Next IC s) implies NIC(i, l) = {Next l};

theorem :: SCMPDS_9:13
  (for l being Instruction-Location of SCMPDS holds NIC(i,l)={Next l})
  implies JUMP i is empty;

theorem :: SCMPDS_9:14
  NIC(goto k,l) = { abs(k+locnum l) };

theorem :: SCMPDS_9:15
  NIC(return a,l) = {k where k is Element of NAT: k > 1};

theorem :: SCMPDS_9:16
  NIC(saveIC(a,k1), l) = {Next l};

theorem :: SCMPDS_9:17
  NIC(a:=k1, l) = {Next l};

theorem :: SCMPDS_9:18
  NIC((a,k1):=k2, l) = {Next l};

theorem :: SCMPDS_9:19
  NIC((a,k1):=(b,k2), l) = {Next l};

theorem :: SCMPDS_9:20
  NIC(AddTo(a,k1,k2), l) = {Next l};

theorem :: SCMPDS_9:21
  NIC(AddTo(a,k1,b,k2), l) = {Next l};

theorem :: SCMPDS_9:22
  NIC(SubFrom(a,k1,b,k2), l) = {Next l};

theorem :: SCMPDS_9:23
  NIC(MultBy(a,k1,b,k2), l) = {Next l};

theorem :: SCMPDS_9:24
  NIC(Divide(a,k1,b,k2), l) = {Next l};

theorem :: SCMPDS_9:25
  NIC((a,k1)<>0_goto k2,l) = { Next l, abs( (k2+locnum l) ) };

theorem :: SCMPDS_9:26
  NIC((a,k1)<=0_goto k2,l) = { Next l, abs( (k2+locnum l) ) };

theorem :: SCMPDS_9:27
  NIC((a,k1)>=0_goto k2,l) = { Next l, abs( (k2+locnum l) ) };

registration
  let k;
  cluster JUMP (goto k) -> empty;
end;

theorem :: SCMPDS_9:28
  JUMP (return a) = {k where k is Element of NAT: k > 1};

registration
  let a;
  cluster JUMP (return a) -> infinite;
end;

registration
  let a,k1;
  cluster JUMP (saveIC(a,k1)) -> empty;
end;

registration
  let a,k1;
  cluster JUMP (a:=k1) -> empty;
end;

registration
  let a,k1,k2;
  cluster JUMP ((a,k1):=k2) -> empty;
end;

registration
  let a,b,k1,k2;
  cluster JUMP ((a,k1):=(b,k2)) -> empty;
end;

registration
  let a,k1,k2;
  cluster JUMP (AddTo(a,k1,k2)) -> empty;
end;

registration
  let a,b,k1,k2;
  cluster JUMP (AddTo(a,k1,b,k2)) -> empty;
  cluster JUMP (SubFrom(a,k1,b,k2)) -> empty;
  cluster JUMP (MultBy(a,k1,b,k2)) -> empty;
  cluster JUMP (Divide(a,k1,b,k2)) -> empty;
end;

registration
  let a,k1,k2;
  cluster JUMP ((a,k1)<>0_goto k2) -> empty;
  cluster JUMP ((a,k1)<=0_goto k2) -> empty;
  cluster JUMP ((a,k1)>=0_goto k2) -> empty;
end;

theorem :: SCMPDS_9:29
  SUCC(l) = NAT;

registration
  cluster SCMPDS -> non InsLoc-antisymmetric;
end;

registration
  cluster SCMPDS -> non standard;
end;

