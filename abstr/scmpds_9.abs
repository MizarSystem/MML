:: SCMPDS Is Not Standard
::  by Artur Korni{\l}owicz and Yasunari Shidama
::
:: Received September 27, 2003
:: Copyright (c) 2003 Association of Mizar Users

environ

 vocabularies BOOLE, SETFAM_1, FUNCT_1, ARYTM, ORDINAL2, FUNCT_4, RELAT_1,
      CAT_1, FINSET_1, ARYTM_3, ARYTM_1, ABSVALUE, INT_1, NAT_1, FUNCOP_1,
      AMI_1, AMI_2, AMI_3, AMISTD_1, SCMPDS_2, SCMPDS_3, GOBOARD5, ORDINAL1;
 notations TARSKI, XBOOLE_0, SUBSET_1, SETFAM_1, ORDINAL1, NUMBERS, XCMPLX_0,
      XXREAL_0, XREAL_0, FUNCT_1, INT_1, NAT_1, FINSET_1, COMPLEX1, INT_2,
      RELAT_1, FUNCT_4, AMI_1, AMI_2, AMI_3, SCMPDS_2, SCMPDS_3, SCMNORM,
      AMISTD_1;
 constructors PARTFUN1, XXREAL_0, REAL_1, NAT_1, NAT_D, REALSET1, AMI_3,
      SCMPDS_1, SCMPDS_3, AMISTD_2, SCMNORM;
 registrations SETFAM_1, ORDINAL1, RELSET_1, NUMBERS, XXREAL_0, XREAL_0, NAT_1,
      INT_1, MEMBERED, CARD_3, SCMPDS_2, SCMNORM, FUNCT_1;
 requirements BOOLE, SUBSET, NUMERALS, ARITHM, REAL;


begin

reserve a, b for Int_position,
  i for Instruction of SCMPDS,
  l for
  Instruction-Location of SCMPDS,
  k, k1, k2 for Integer;

definition
  let la, lb be Int_position, a, b be Integer;
  redefine func (la,lb) --> (a,b) -> FinPartState of SCMPDS;
end;

definition
  let l be Instruction-Location of SCMPDS;
  func locnum l -> natural number means
:: SCMPDS_9:def 1

  il.it = l;
end;

definition
  let l be Instruction-Location of SCMPDS;
  redefine func locnum l -> Element of NAT;
end;

canceled 2;

theorem :: SCMPDS_9:3
  l = locnum l;

theorem :: SCMPDS_9:4
  for l1, l2 being Instruction-Location of SCMPDS st l1 <> l2 holds
  locnum l1 <> locnum l2;

canceled 2;

theorem :: SCMPDS_9:7
  (for s being State of SCMPDS st IC s = l & s.l = i holds Exec(i,s
  ).IC SCMPDS = Next IC s) implies NIC(i, l) = {Next l};

theorem :: SCMPDS_9:8
  (for l being Instruction-Location of SCMPDS holds NIC(i,l)={Next
  l}) implies JUMP i is empty;

theorem :: SCMPDS_9:9
  NIC(goto k,l) = { abs(k+locnum l) };

theorem :: SCMPDS_9:10
  NIC(return a,l) = {k where k is Element of NAT: k > 1};

theorem :: SCMPDS_9:11
  NIC(saveIC(a,k1), l) = {Next l};

theorem :: SCMPDS_9:12
  NIC(a:=k1, l) = {Next l};

theorem :: SCMPDS_9:13
  NIC((a,k1):=k2, l) = {Next l};

theorem :: SCMPDS_9:14
  NIC((a,k1):=(b,k2), l) = {Next l};

theorem :: SCMPDS_9:15
  NIC(AddTo(a,k1,k2), l) = {Next l};

theorem :: SCMPDS_9:16
  NIC(AddTo(a,k1,b,k2), l) = {Next l};

theorem :: SCMPDS_9:17
  NIC(SubFrom(a,k1,b,k2), l) = {Next l};

theorem :: SCMPDS_9:18
  NIC(MultBy(a,k1,b,k2), l) = {Next l};

theorem :: SCMPDS_9:19
  NIC(Divide(a,k1,b,k2), l) = {Next l};

theorem :: SCMPDS_9:20
  NIC((a,k1)<>0_goto k2,l) = { Next l, abs( (k2+locnum l) ) };

theorem :: SCMPDS_9:21
  NIC((a,k1)<=0_goto k2,l) = { Next l, abs( (k2+locnum l) ) };

theorem :: SCMPDS_9:22
  NIC((a,k1)>=0_goto k2,l) = { Next l, abs( (k2+locnum l) ) };

registration
  let k;
  cluster JUMP (goto k) -> empty;
end;

theorem :: SCMPDS_9:23
  JUMP (return a) = {k where k is Element of NAT: k > 1};

registration
  let a;
  cluster JUMP (return a) -> infinite;
end;

registration
  let a,k1;
  cluster JUMP (saveIC(a,k1)) -> empty;
end;

registration
  let a,k1;
  cluster JUMP (a:=k1) -> empty;
end;

registration
  let a,k1,k2;
  cluster JUMP ((a,k1):=k2) -> empty;
end;

registration
  let a,b,k1,k2;
  cluster JUMP ((a,k1):=(b,k2)) -> empty;
end;

registration
  let a,k1,k2;
  cluster JUMP (AddTo(a,k1,k2)) -> empty;
end;

registration
  let a,b,k1,k2;
  cluster JUMP (AddTo(a,k1,b,k2)) -> empty;
  cluster JUMP (SubFrom(a,k1,b,k2)) -> empty;
  cluster JUMP (MultBy(a,k1,b,k2)) -> empty;
  cluster JUMP (Divide(a,k1,b,k2)) -> empty;
end;

registration
  let a,k1,k2;
  cluster JUMP ((a,k1)<>0_goto k2) -> empty;
  cluster JUMP ((a,k1)<=0_goto k2) -> empty;
  cluster JUMP ((a,k1)>=0_goto k2) -> empty;
end;

theorem :: SCMPDS_9:24
  SUCC(l) = NAT;

registration
  cluster SCMPDS -> non InsLoc-antisymmetric;
end;

registration
  cluster SCMPDS -> non standard;
end;

