:: Binary Arithmetics. Addition
::  by Takaya Nishiyama and Yasuho Mizuhara
::
:: Received October 8, 1993
:: Copyright (c) 1993 Association of Mizar Users

environ

 vocabularies MONOID_0, FUNCT_1, RELAT_1, MIDSP_3, FINSEQ_1, MARGREL1, ZF_LANG,
      ORDINAL2, ARYTM_1, CQC_LANG, POWER, SETWISEO, BOOLE, FINSEQ_2, BINARITH,
      FINSEQ_4, ARYTM, NAT_1, RFINSEQ;
 notations XBOOLE_0, SUBSET_1, ORDINAL1, NUMBERS, XCMPLX_0, REAL_1, NAT_1,
      NAT_D, XBOOLEAN, MARGREL1, RELAT_1, FUNCT_1, FUNCT_2, BINOP_1, BINOP_2,
      SETWISEO, FUNCOP_1, SETWOP_2, SERIES_1, FINSEQ_1, FINSEQ_2, FINSEQ_4,
      RFINSEQ, XXREAL_0;
 constructors BINOP_1, SETWISEO, XXREAL_0, NAT_1, INT_1, BINOP_2, MEMBERED,
      MARGREL1, FINSEQ_4, FINSOP_1, SERIES_1, ORDINAL2, COMPLEX1, NAT_D,
      RFINSEQ;
 registrations INT_1, RELSET_1, MARGREL1, NAT_1, MEMBERED, ORDINAL2, FINSEQ_2,
      BINOP_2, XXREAL_0, ORDINAL1, XBOOLEAN, FUNCT_1, FINSEQ_1, SUBSET_1;
 requirements REAL, NUMERALS, BOOLE, SUBSET, ARITHM;


begin

definition let i be Nat, D be non empty set;
 mode Tuple of i,D is Element of i-tuples_on D;
end;

canceled;

  theorem :: BINARITH:2
    for i,n being Element of NAT,
        D being non empty set,
        d being Element of D,
        z being Tuple of n,D st i in Seg n holds
    (z^<*d*>)/.i=z/.i
    @proof
    let i,n be Element of NAT,
        D be non empty set,
        d be Element of D,
        z be Tuple of n,D such that A1: i in Seg n;
           len z = n by FINSEQ_2:109;
        then i in dom z by A1,FINSEQ_1:def 3;
        hence thesis by FINSEQ_4:83;
    end;

  theorem :: BINARITH:3
    for n being Element of NAT,
        D being non empty set,
        d being Element of D,
        z being Tuple of n,D holds
    (z^<*d*>)/.(n+1)=d
    @proof
    let n be Element of NAT,
        D be non empty set,
        d be Element of D,
        z be Tuple of n,D;
           len<*d*> = 1 by FINSEQ_1:56;
        then 0+1 in Seg len <*d*>;
        then A1: 0+1 in dom <*d*> by FINSEQ_1:def 3;
           len(z) = n by FINSEQ_2:109;
        hence (z^<*d*>)/.(n+1) = <*d*>/.1 by A1,FINSEQ_4:84
                      .= d by FINSEQ_4:25;
    end;

  registration
    let x, y be boolean set;
    cluster x 'xor' y -> boolean;
  end;

  definition
    let x, y be Element of BOOLEAN;
    redefine func x 'or' y -> Element of BOOLEAN;
    func x 'xor' y -> Element of BOOLEAN;
  end;

  reserve x,y,z for boolean set;

canceled 3;

  theorem :: BINARITH:7
  x 'or' FALSE = x;

canceled;

  theorem :: BINARITH:9
  'not' (x '&' y) = 'not' x 'or' 'not' y;

  theorem :: BINARITH:10
  'not' (x 'or' y) = 'not' x '&' 'not' y;

canceled;

  theorem :: BINARITH:12
     x '&' y = 'not' ('not' x 'or' 'not' y);

  theorem :: BINARITH:13
     TRUE 'xor' x = 'not' x;

  theorem :: BINARITH:14
     FALSE 'xor' x = x;

canceled;

  theorem :: BINARITH:16
  x '&' x = x;

canceled 2;

  theorem :: BINARITH:19
  x 'or' TRUE = TRUE;

  theorem :: BINARITH:20
  (x 'or' y) 'or' z = x 'or' (y 'or' z);

  theorem :: BINARITH:21
  x 'or' x = x;

canceled 11;

  theorem :: BINARITH:33
  TRUE 'xor' FALSE = TRUE;

  definition let i,j be natural number;
 canceled 2;

  func i -' j -> Element of NAT equals
:: BINARITH:def 3
      i - j if i - j >= 0 otherwise 0;
  end;

canceled 5;

  theorem :: BINARITH:39
  for i,j being natural number holds i + j -' j = i
  @proof
     let i, j be natural number;
     i + j - j >= 0;
    hence i + j -' j = i by Def3;
  end;

  reserve i,j,k for Element of NAT;
  reserve n for non empty Element of NAT;
  reserve x,y,z1,z2 for Tuple of n, BOOLEAN;

  definition let n be Element of NAT, x be Tuple of n, BOOLEAN;
  func 'not' x -> Tuple of n, BOOLEAN means
:: BINARITH:def 4
       for i st i in Seg n holds it/.i = 'not' (x/.i);
 end;

  definition let n be non empty Element of NAT, x, y be Tuple of n, BOOLEAN;
  func carry(x, y) -> Tuple of n, BOOLEAN means
:: BINARITH:def 5

    it/.1 = FALSE &
      for i st 1 <= i & i < n holds it/.(i+1) = (x/.i) '&' (y/.i) 'or'
        (x/.i) '&' (it/.i) 'or' (y/.i) '&' (it/.i);
  end;

  definition let n be Element of NAT, x be Tuple of n, BOOLEAN;
  func Binary(x) -> Tuple of n, NAT means
:: BINARITH:def 6
    for i st i in Seg n holds
                  it/.i = IFEQ(x/.i,FALSE,0,2 to_power(i-'1));
   end;

  definition let n be Element of NAT, x be Tuple of n, BOOLEAN;
  func Absval (x) -> Element of NAT equals
:: BINARITH:def 7
  addnat $$ Binary (x);
  end;

  definition let n, x, y;
  func x + y -> Tuple of n, BOOLEAN means
:: BINARITH:def 8
    for i st i in Seg n holds it/.i =
                     (x/.i) 'xor' (y/.i) 'xor' (carry(x,y)/.i);
  end;

  definition let n,z1,z2;
  func add_ovfl(z1,z2) -> Element of BOOLEAN equals
:: BINARITH:def 9
     (z1/.n) '&' (z2/.n) 'or'
        (z1/.n) '&' (carry(z1,z2)/.n) 'or' (z2/.n) '&' (carry(z1,z2)/.n);
  end;

 scheme :: BINARITH:sch 1
 Indfrom1 { P[Element of NAT] } :
 for k being non empty Element of NAT holds P[k]
   provided
    P[1] and
    for k being non empty Element of NAT st P[k] holds P[k + 1];

definition let n,z1,z2;
  pred z1,z2 are_summable means
:: BINARITH:def 10
      add_ovfl(z1,z2) = FALSE;
end;

  theorem :: BINARITH:40
   for z1 being Tuple of 1,BOOLEAN holds
     z1= <*FALSE*> or z1=<*TRUE*>
   @proof
     let z1 be Tuple of 1,BOOLEAN;
     consider B being Element of BOOLEAN such that
      A1: z1=<*B*> by FINSEQ_2:117;
     per cases by XBOOLEAN:def 3;
     suppose z1/.1 = FALSE;
     hence thesis by A1,FINSEQ_4:25;
     end;
     suppose z1/.1 = TRUE;
     hence thesis by A1,FINSEQ_4:25;
   end;
   end;

  theorem :: BINARITH:41
   for z1 being Tuple of 1,BOOLEAN holds
   z1=<*FALSE*> implies Absval(z1) = 0
   @proof
      let z1 be Tuple of 1,BOOLEAN;
      assume A1: z1=<*FALSE*>;
        consider k being Element of NAT such that
          A2: Binary( z1 ) = <* k *> by FINSEQ_2:117;
          A3: z1/.1 = FALSE by A1,FINSEQ_4:25;
          1 in Seg 1;
       then A4: (Binary(z1))/.1 = IFEQ(z1/.1,FALSE,0,2 to_power(1-'1)) by Def6
                        .= 0 by A3,CQC_LANG:def 1;
      thus Absval(z1) = addnat $$ <* 0 *> by A2,A4,FINSEQ_4:25
                  .= 0 by FINSOP_1:12;
        end;

  theorem :: BINARITH:42
   for z1 being Tuple of 1,BOOLEAN holds
   z1=<*TRUE*> implies Absval(z1)=1
   @proof
      let z1 be Tuple of 1,BOOLEAN;
      assume A1: z1=<*TRUE*>;
        consider k being Element of NAT such that
          A2: Binary( z1 ) = <* k *> by FINSEQ_2:117;
       A3: z1/.1 <> FALSE by A1,FINSEQ_4:25;
          1 in Seg 1;
      then A4: (Binary(z1))/.1 = IFEQ(z1/.1,FALSE,0,2 to_power(1-'1)) by Def6
                      .= 2 to_power(1-'1) by A3,CQC_LANG:def 1;
A5:                      1 - 1 = 0;
 thus Absval(z1) = addnat $$ <* 2 to_power(1-'1) *> by A2,A4,FINSEQ_4:25
                  .= 2 to_power(1-'1) by FINSOP_1:12
                  .= 2 to_power(0) by A5,Def3
                  .= 1 by POWER:29;
        end;

  definition
    let n1 be non empty Element of NAT;
    let n2 be Element of NAT;
    let D  be non empty set;
    let z1 be Tuple of n1,D;
    let z2 be Tuple of n2,D;
    redefine func z1 ^ z2 -> Tuple of n1+n2,D;
  end;

  definition
    let D be non empty set;
    let d be Element of D;
    redefine func <* d *> -> Tuple of 1,D;
  end;

  theorem :: BINARITH:43
    for z1,z2 being Tuple of n,BOOLEAN holds
    for d1,d2 being Element of BOOLEAN holds
    for i being Element of NAT holds
    i in Seg n implies
     carry(z1^<*d1*>,z2^<*d2*>)/.i = carry(z1,z2)/.i
     @proof
     let z1,z2 be Tuple of n,BOOLEAN;
     let d1,d2 be Element of BOOLEAN;
     defpred P[Element of NAT] means $1 in Seg n implies
          carry(z1^<*d1*>,z2^<*d2*>)/.$1 = carry(z1,z2)/.$1;
     A1: P[1] @proof assume 1 in Seg n;
         thus
              carry(z1^<*d1*>,z2^<*d2*>)/.1 = FALSE by Def5
               .= carry(z1,z2)/.1 by Def5;
         end;
     A2: for i being non empty Element of NAT st P[i] holds P[i+1] @proof
         let i be non empty Element of NAT;
         assume
       A3: P[i];
       A4: i+1 > i by XREAL_1:31;
         assume i+1 in Seg n;
          then i+1 >= 1 & i+1 <= n by FINSEQ_1:3;
       then A5: 1 <= i & i < n by A4,XXREAL_0:2,NAT_1:14;
       then A6: i in Seg n;
       then A7: (z1^<*d1*>)/.i = z1/.i by Th2;
       A8: (z2^<*d2*>)/.i = z2/.i by A6,Th2;
             n <= n+1 by NAT_1:11;
          then 1 <= i & i < n+1 by A5,XXREAL_0:2;
          hence carry(z1^<*d1*>,z2^<*d2*>)/.(i+1)
                   = ((z1/.i) '&' (z2/.i)) 'or'
                      (z1/.i) '&' (carry(z1,z2)/.i) 'or'
                      (z2/.i) '&' (carry(z1,z2)/.i) by A3,A5,A7,A8,Def5
                  .= carry(z1,z2)/.(i+1) by A5,Def5;
          end;
        let i be Element of NAT;
        assume A9:i in Seg n;
       then A10: i is non empty by FINSEQ_1:3;
           for i being non empty Element of NAT holds P[i]
           from Indfrom1 (A1,A2);
        hence thesis by A9,A10;
  end;

  theorem :: BINARITH:44
    for z1,z2 being Tuple of n,BOOLEAN,
              d1,d2 being Element of BOOLEAN holds
    add_ovfl(z1,z2) = carry(z1^<*d1*>,z2^<*d2*>)/.(n+1)
    @proof
    let z1,z2 be Tuple of n,BOOLEAN,
               d1,d2 be Element of BOOLEAN;
         A1: n in Seg n by FINSEQ_1:5;
      then A2: carry(z1^<*d1*>,z2^<*d2*>)/.n = carry(z1,z2)/.n by Th43;
      A3: z1/.n = (z1^<*d1*>)/.n by A1,Th2;
      A4: z2/.n = (z2^<*d2*>)/.n by A1,Th2;
      A5: 1 <= n & n < n+1 by NAT_1:14,XREAL_1:31;
      thus add_ovfl(z1,z2)
         = carry(z1^<*d1*>,z2^<*d2*>)/.(n+1) by A5,Def5,A2,A3,A4;
    end;

  theorem :: BINARITH:45
   for z1,z2 being Tuple of n,BOOLEAN,
             d1,d2 being Element of BOOLEAN holds
     z1^<*d1*> + z2^<*d2*> = (z1+z2)^<*d1 'xor' d2 'xor' add_ovfl(z1,z2)*>
   @proof
     let z1,z2 be Tuple of n,BOOLEAN,
         d1,d2 be Element of BOOLEAN;
        for i st i in Seg (n+1) holds
        ((z1+z2)^<*d1 'xor' d2 'xor' add_ovfl(z1,z2)*>)/.i =
           ((z1^<*d1*>)/.i) 'xor' ((z2^<*d2*>)/.i) 'xor'
               (carry(z1^<*d1*>,z2^<*d2*>)/.i)
     @proof
     let i such that A1:i in Seg (n+1);
     A2:Seg (n+1) = Seg (n) \/ {. n+1 .} by FINSEQ_1:11;
     per cases by A1,A2,XBOOLE_0:def 2;
     suppose A3:i in Seg n;
     hence ((z1+z2)^<*d1 'xor' d2 'xor' add_ovfl(z1,z2)*>)/.i
          = (z1+z2)/.i by Th2
         .= (z1/.i) 'xor' (z2/.i) 'xor'
              (carry(z1,z2)/.i) by A3,Def8
         .= ((z1^<*d1*>)/.i) 'xor' (z2/.i) 'xor'
              (carry(z1,z2)/.i) by A3,Th2
         .= ((z1^<*d1*>)/.i) 'xor' ((z2^<*d2*>)/.i) 'xor'
              (carry(z1,z2)/.i) by A3,Th2
         .= ((z1^<*d1*>)/.i) 'xor' ((z2^<*d2*>)/.i) 'xor'
               (carry(z1^<*d1*>,z2^<*d2*>)/.i) by A3,Th43;
     end;
     suppose i in {. n+1 .};
     then A4: i=n+1 by TARSKI:def 1;
     hence (((z1+z2)^<*d1 'xor' d2 'xor' add_ovfl(z1,z2)*>)/.i)
          = d1 'xor' d2 'xor' add_ovfl(z1,z2) by Th3
         .= d1 'xor' d2 'xor'
               (carry(z1^<*d1*>,z2^<*d2*>)/.i) by A4,Th44
         .= d1 'xor' ((z2^<*d2*>)/.i) 'xor'
               (carry(z1^<*d1*>,z2^<*d2*>)/.i) by A4,Th3
         .= ((z1^<*d1*>)/.i) 'xor' ((z2^<*d2*>)/.i) 'xor'
               (carry(z1^<*d1*>,z2^<*d2*>)/.i) by A4,Th3;
     end;
     end;
     hence z1^<*d1*> + z2^<*d2*>
           = (z1+z2)^<*d1 'xor' d2 'xor' add_ovfl(z1,z2)*> by Def8;
  end;

  theorem :: BINARITH:46
    for z being Tuple of n,BOOLEAN,
              d being Element of BOOLEAN holds
    Absval(z^<*d*>) = Absval(z)+IFEQ(d,FALSE,0,2 to_power n)
    @proof
      let z be Tuple of n,BOOLEAN,
          d be Element of BOOLEAN;
A1:     for i st i in Seg (n+1) holds
      ((Binary(z)^<*IFEQ(d,FALSE,0,2 to_power(n))*>)/.i)
              = IFEQ((z^<*d*>)/.i,FALSE,0,2 to_power(i-'1))
      @proof
     let i such that A2:i in Seg (n+1);
     A3:Seg (n+1) = Seg (n) \/ {. n+1 .} by FINSEQ_1:11;
     per cases by A2,A3,XBOOLE_0:def 2;
     suppose A4:i in Seg n;
     hence (Binary(z)^<*IFEQ(d,FALSE,0,2 to_power(n))*>)/.i
              = (Binary(z))/.i by Th2
             .= IFEQ(z/.i,FALSE,0,2 to_power(i-'1)) by A4,Def6
             .= IFEQ((z^<*d*>)/.i,FALSE,0,2 to_power(i-'1)) by A4,Th2;

     end;
     suppose i in {. n+1 .};
       then A5: i=n+1 by TARSKI:def 1;
     hence (Binary(z)^<*IFEQ(d,FALSE,0,2 to_power(n))*>)/.i
              = IFEQ(d,FALSE,0,2 to_power(n)) by Th3
             .= IFEQ((z^<*d*>)/.i,FALSE,0,2 to_power(n)) by A5,Th3
             .= IFEQ((z^<*d*>)/.i,FALSE,0,2 to_power(i-'1)) by A5,Th39;
      end;
      end;
      thus Absval(z^<*d*>)
       = addnat $$ (Binary(z)^<*IFEQ(d,FALSE,0,2 to_power(n))*>)
 by A1,Def6
       .= addnat.(addnat$$Binary(z),IFEQ(d,FALSE,0,2 to_power(n)))
 by FINSOP_1:5
       .= Absval(z)+IFEQ(d,FALSE,0,2 to_power n) by BINOP_2:def 23;
    end;

  theorem :: BINARITH:47
   for n for z1,z2 being Tuple of n,BOOLEAN holds
   Absval(z1+z2) + IFEQ(add_ovfl(z1,z2),FALSE,0,2 to_power (n)) =
                   Absval(z1) + Absval(z2)
   @proof
     set f = FALSE,
         t = TRUE;
    defpred P[ non empty Element of NAT] means
     for z1,z2 being Tuple of $1, BOOLEAN holds
       Absval(z1+z2) + IFEQ(add_ovfl(z1,z2),FALSE,0,2 to_power ($1)) =
                   Absval(z1) + Absval(z2);
     A1: P[1]  @proof
         let z1,z2 be Tuple of 1, BOOLEAN;
            carry(z1,z2)/.1 = f by Def5;
        then A2: add_ovfl(z1,z2)
        = (z1/.1) '&' (z2/.1);
          reconsider T= <*t*>,F= <*f*> as Tuple of 1,BOOLEAN;
A3:        Absval(T)=1 & Absval(F)=0 by Th41,Th42;
           per cases by Th40;
            suppose A4:z1=<*f*> & z2=<*f*>;
              A5: IFEQ(add_ovfl(z1,z2),FALSE,0,2 to_power (1)) = 0
                @proof
                 add_ovfl(z1,z2) = f by FINSEQ_4:25,A2,A4;
                  hence IFEQ(add_ovfl(z1,z2),FALSE,0,2 to_power (1))
                       = 0 by CQC_LANG:def 1;
               end;

               now
             let i;
             assume i in Seg 1;
             then A6:i=1 by FINSEQ_1:4,TARSKI:def 1;
             hence F/.i = (z1/.1) 'xor' f 'xor' f by
A4
                     .= (z1/.1) 'xor' (z2/.1) 'xor' f by A4,FINSEQ_4:25
                     .= (z1/.i) 'xor' (z2/.i) 'xor' (carry(z1,z2)/.i) by A6,
Def5;
            end;
              hence thesis by A3,A4,A5,Def8;

            end;
            suppose A7:z1=<*t*> & z2=<*f*>;
              A8: IFEQ(add_ovfl(z1,z2),FALSE,0,2 to_power (1)) = 0
                @proof
                      add_ovfl(z1,z2) = t '&' (<*f*>/.1) by A2,A7,FINSEQ_4:25
                       .= f by FINSEQ_4:25;
                  hence IFEQ(add_ovfl(z1,z2),FALSE,0,2 to_power (1))
                       = 0 by CQC_LANG:def 1;
               end;
               now
             let i;
             assume i in Seg 1;
             then A9:i=1 by FINSEQ_1:4,TARSKI:def 1;
             hence T/.i = (z1/.1) 'xor' f 'xor' f by
A7
           .= (z1/.1) 'xor' (z2/.1) 'xor' f by A7,FINSEQ_4:25
           .= (z1/.i) 'xor' (z2/.i) 'xor' (carry(z1,z2)/.i) by A9,Def5;
            end;
              hence thesis by A3,A7,A8,Def8;

            end;
            suppose A10:z1=<*f*> & z2=<*t*>;
              A11: IFEQ(add_ovfl(z1,z2),FALSE,0,2 to_power (1)) = 0
                @proof
                      add_ovfl(z1,z2) = f '&' (<*t*>/.1) by A2,A10,FINSEQ_4:25
                       .= f;
                  hence IFEQ(add_ovfl(z1,z2),FALSE,0,2 to_power (1))
                       = 0 by CQC_LANG:def 1;
               end;
               now
             let i;
             assume i in Seg 1;
             then A12:i=1 by FINSEQ_1:4,TARSKI:def 1;
             hence T/.i = 'not' t 'xor' t 'xor' f by FINSEQ_4:25
                     .= (z1/.1) 'xor' t 'xor' f by A10,FINSEQ_4:25
                     .= (z1/.1) 'xor' (z2/.1) 'xor' f
 by A10,FINSEQ_4:25
                     .= (z1/.i) 'xor' (z2/.i) 'xor' (carry(z1,z2)/.i)
 by A12,Def5;
            end;
              hence thesis by A3,A10,A11,Def8;

            end;
            suppose A13:z1=<*t*> & z2=<*t*>;
              A14: IFEQ(add_ovfl(z1,z2),FALSE,0,2 to_power 1) = 2
                @proof
                      add_ovfl(z1,z2) = t by FINSEQ_4:25,A2,A13;
                  hence IFEQ(add_ovfl(z1,z2),FALSE,0,2 to_power (1))
                       = 2 to_power 1 by CQC_LANG:def 1
                      .= 2 by POWER:30;
               end;

               now
             let i;
             assume i in Seg 1;
             then A15:i=1 by FINSEQ_1:4,TARSKI:def 1;
             hence F/.i = t 'xor' t 'xor' 'not' t by FINSEQ_4:25
                         .= (z1/.1) 'xor' t 'xor' f by A13,FINSEQ_4:25
                         .= (z1/.1) 'xor' (z2/.1) 'xor' f by A13,FINSEQ_4:25
                         .= (z1/.i) 'xor' (z2/.i) 'xor' (carry(z1,z2)/.i)
 by A15,Def5;
            end;
              then z1+z2=<*f*> by Def8;
              hence thesis by A3,A13,A14;

        end;
        end;
     A16: for n being non empty Element of NAT st P[n] holds P[n+1]
      @proof let n;
         assume A17: P[n];
              let z1,z2 be Tuple of n+1,BOOLEAN;
              consider t1 being (Element of n-tuples_on BOOLEAN),
                 d1 being Element of BOOLEAN such that A18: z1 = t1^<*d1*>
 by FINSEQ_2:137;
              consider t2 being (Element of n-tuples_on BOOLEAN),
                 d2 being Element of BOOLEAN such that A19: z2 = t2^<*d2*>
 by FINSEQ_2:137;
           IFEQ(add_ovfl(z1,z2),FALSE,0,2 to_power (n+1)) is Element of NAT &
        IFEQ(d1 'xor' d2 'xor' add_ovfl(t1,t2),FALSE,0,2 to_power n)
         is Element of NAT &
        IFEQ(d1,FALSE,0,2 to_power n) is Element of NAT &
        IFEQ(d2,FALSE,0,2 to_power n) is Element of NAT &
        IFEQ(add_ovfl(t1,t2),FALSE,0,2 to_power(n)) is Element of NAT;
        then reconsider
              C1= IFEQ(add_ovfl(z1,z2),FALSE,0,2 to_power (n+1)),
              C2= IFEQ(d1 'xor' d2 'xor' add_ovfl(t1,t2),FALSE,0,2 to_power n),
              C3= IFEQ(d1,FALSE,0,2 to_power n),
              C4= IFEQ(d2,FALSE,0,2 to_power n),
              C5= IFEQ(add_ovfl(t1,t2),FALSE,0,2 to_power(n)) as Real;
   A20: add_ovfl(z1,z2)
          = d1 '&' ((t2^<*d2*>)/.(n+1)) 'or'
        ((t1^<*d1*>)/.(n+1)) '&' (carry(t1^<*d1*>,t2^<*d2*>)/.(n+1))
                'or' ((t2^<*d2*>)/.(n+1)) '&'
                  (carry(t1^<*d1*>,t2^<*d2*>)/.(n+1)) by Th3,A18,A19
          .= d1 '&' d2 'or'
        ((t1^<*d1*>)/.(n+1)) '&' (carry(t1^<*d1*>,t2^<*d2*>)/.(n+1))
          'or' ((t2^<*d2*>)/.(n+1)) '&' (carry(t1^<*d1*>,t2^<*d2*>)/.(n+1))
 by Th3
          .= d1 '&' d2 'or' d1 '&' (carry(t1^<*d1*>,t2^<*d2*>)/.(n+1))
         'or' ((t2^<*d2*>)/.(n+1)) '&' (carry(t1^<*d1*>,t2^<*d2*>)/.(n+1))
 by Th3
          .= d1 '&' d2 'or' d1 '&' (carry(t1^<*d1*>,t2^<*d2*>)/.(n+1))
                'or' d2 '&' (carry(t1^<*d1*>,t2^<*d2*>)/.(n+1)) by Th3
          .= d1 '&' d2 'or' d1 '&' add_ovfl(t1,t2)
                'or' d2 '&' (carry(t1^<*d1*>,t2^<*d2*>)/.(n+1))
 by Th44
          .= d1 '&' d2 'or' d1 '&' add_ovfl(t1,t2) 'or' d2 '&' add_ovfl(t1,t2)
 by Th44;
      A21: C2 + C1 = C5 + C3 + C4
          @proof
             now per cases;
          suppose A22: d1=f;
          then A23:C3=0 by CQC_LANG:def 1;
               now per cases;
              suppose A24: d2=f;
              then A25:C4=0 by CQC_LANG:def 1;
                 now per cases;
                suppose A26:add_ovfl(t1,t2)=f;

                then A27:C5=0 by CQC_LANG:def 1;
                  A28: d1 '&' d2 'or' d1 '&' add_ovfl(t1,t2) 'or'
                          d2 '&' add_ovfl(t1,t2)
                     = f by  A22,A24;
                     d1 'xor' d2 'xor' add_ovfl(t1,t2)
                      = f by  A22,A24,A26;
                  hence C2 + C1 = C5 + C3 + C4 by A20,A22,A25,A27,A28,
CQC_LANG:def 1;
                end;
                suppose A29:add_ovfl(t1,t2)<>f;
                then A30:C5=2 to_power(n) by CQC_LANG:def 1;
                  A31: d1 '&' d2 'or' d1 '&' add_ovfl(t1,t2) 'or'
                          d2 '&' add_ovfl(t1,t2)
                       = f by  A22,A24;
                     d1 'xor' d2 'xor' add_ovfl(t1,t2)
                     = t by  A22,A24,A29,XBOOLEAN:def 3;
                  then C2=2 to_power n & C1=0 by A20,A31,CQC_LANG:def 1
;
                  hence C2 + C1 = C5 + C3 + C4 by A22,A25,A30,CQC_LANG:def 1;
              end;
              end;
              hence C2 + C1 = C5 + C3 +C4;
              end;
              suppose A32:d2 <> f;
              then A33:C4=2 to_power n by CQC_LANG:def 1;
                 now per cases;
                suppose A34:add_ovfl(t1,t2)=f;
                then A35:C5=0 by CQC_LANG:def 1;
                  A36: d1 '&' d2 'or' d1 '&' add_ovfl(t1,t2) 'or'
                          d2 '&' add_ovfl(t1,t2)
                       = f by  A22,A34;
                     d1 'xor' d2 'xor' add_ovfl(t1,t2)
                     = t by A22,A32,A34,XBOOLEAN:def 3;
                  then C2=2 to_power n & C1=0 by A20,A36,CQC_LANG:def 1;
                  hence C2 + C1 = C5 + C3 + C4 by A22,A33,A35,CQC_LANG:def 1;
                end;
                suppose A37:add_ovfl(t1,t2)<>f;
                then A38:C5=2 to_power(n) by CQC_LANG:def 1;
A39:                   d1 '&' d2 'or' d1 '&' add_ovfl(t1,t2) 'or'
                          d2 '&' add_ovfl(t1,t2)
                     = f 'or' f 'or' t '&' add_ovfl(t1,t2)
 by  A22,A32,XBOOLEAN:def 3
                    .= t by A37,XBOOLEAN:def 3;
                     d1 'xor' d2 'xor' add_ovfl(t1,t2)
                     = t 'xor' add_ovfl(t1,t2) by A22,A32,XBOOLEAN:def 3
                    .= f by A37,XBOOLEAN:def 3;
                  then C2=0 & C1=2 to_power(n+1) by A20,A39,CQC_LANG:def 1
;
                  hence C2 + C1 = 2 to_power n * 2 to_power 1 by POWER:32
                               .= 2 * 2 to_power n by POWER:30
                               .= C5 + C3 + C4 by A23,A33,A38;
              end;
              end;
              hence C2 + C1 = C5 + C3 +C4;
            end;
            end;
              hence C2 + C1 = C5 + C3 +C4;
          end;
          suppose A40:d1 <>f;
          then A41:C3=2 to_power n by CQC_LANG:def 1;
               now per cases;
            suppose A42:d2=f;
              then A43:C4=0 by CQC_LANG:def 1;
                 now per cases;
                suppose A44:add_ovfl(t1,t2)=f;
                then A45:C5=0 by CQC_LANG:def 1;
                  A46: d1 '&' d2 'or' d1 '&' add_ovfl(t1,t2) 'or'
                          d2 '&' add_ovfl(t1,t2)
                    = f by A42,A44;
                     d1 'xor' d2 'xor' add_ovfl(t1,t2)
                     = t by A40,A42,A44,XBOOLEAN:def 3;
                  then C2=2 to_power n & C1=0 by A20,A46,CQC_LANG:def 1
;
                  hence C2 + C1 = C5 + C3 + C4 by A40,A43,A45,CQC_LANG:def 1;
                end;
                suppose A47:add_ovfl(t1,t2)<>f;
                then A48:C5=2 to_power(n) by CQC_LANG:def 1;
A49:                   d1 '&' d2 'or' d1 '&' add_ovfl(t1,t2) 'or'
                          d2 '&' add_ovfl(t1,t2)
                     = f 'or' t '&' add_ovfl(t1,t2)
                          'or' d2 '&' add_ovfl(t1,t2) by  A42,A40,
XBOOLEAN:def 3
                    .= f 'or' t '&' t
                          'or' d2 '&' add_ovfl(t1,t2) by A47,XBOOLEAN:def 3
                    .= t;
                     d1 'xor' d2 'xor' add_ovfl(t1,t2)
                     = t 'xor' add_ovfl(t1,t2) by A40,A42,XBOOLEAN:def 3
                    .= f by A47,XBOOLEAN:def 3;
                  then C2=0 & C1=2 to_power (n+1) by A20,A49,CQC_LANG:def 1;
                  hence C2 + C1 = 2 to_power n * 2 to_power 1 by POWER:32
                               .= 2 * 2 to_power n by POWER:30
                               .= C5 + C3 + C4 by A41,A43,A48;
              end;
              end;
              hence C2 + C1 = C5 + C3 +C4;
            end;
            suppose A50:d2<>f;
              then A51:C4=2 to_power n by CQC_LANG:def 1;
                 now per cases;
                suppose A52:add_ovfl(t1,t2)=f;
                then A53:C5=0 by CQC_LANG:def 1;
A54:                   d1 '&' d2 'or' d1 '&' add_ovfl(t1,t2) 'or'
                          d2 '&' add_ovfl(t1,t2)
                     = t '&' d2 'or' d1 '&' add_ovfl(t1,t2) 'or'
                          d2 '&' add_ovfl(t1,t2) by A40,XBOOLEAN:def 3
                    .= t '&' t 'or' d1 '&' add_ovfl(t1,t2) 'or'
                          d2 '&' add_ovfl(t1,t2) by A50,XBOOLEAN:def 3
                    .= t;
                     d1 'xor' d2 'xor' add_ovfl(t1,t2)
                     = t 'xor' d2 'xor' add_ovfl(t1,t2) by A40,XBOOLEAN:def 3
                    .= f by  A50,XBOOLEAN:def 3,A52;
                  then C2=0 & C1=2 to_power (n+1)
 by A20,A54,CQC_LANG:def 1;
                  hence C2 + C1 = 2 to_power n * 2 to_power 1 by POWER:32
                               .= 2 * 2 to_power n by POWER:30
                               .= C5 + C3 + C4 by A41,A51,A53;
                end;
                suppose A55:add_ovfl(t1,t2)<>f;
A56:                   d1 '&' d2 'or' d1 '&' add_ovfl(t1,t2) 'or'
                          d2 '&' add_ovfl(t1,t2)
                     = t '&' d2 'or' d1 '&' add_ovfl(t1,t2) 'or'
                          d2 '&' add_ovfl(t1,t2) by A40,XBOOLEAN:def 3
                    .= t '&' t 'or' d1 '&' add_ovfl(t1,t2) 'or'
                          d2 '&' add_ovfl(t1,t2) by A50,XBOOLEAN:def 3
                    .= t;
                     d1 'xor' d2 'xor' add_ovfl(t1,t2)
                     = t 'xor' d2 'xor' add_ovfl(t1,t2) by A40,XBOOLEAN:def 3
                    .= f 'xor' add_ovfl(t1,t2) by A50,XBOOLEAN:def 3
                    .= t by A55,XBOOLEAN:def 3;
                  then C2=2 to_power n & C1=2 to_power (n+1)
 by A20,A56,CQC_LANG:def 1;
                  hence C2 + C1 = 2 to_power n + 2 to_power n * 2 to_power 1
 by POWER:32
                               .= 2 to_power n + 2 * 2 to_power n by POWER:30
                               .= 2 to_power n + 2 to_power n + 2 to_power n
                               .= C5 + C3 + C4 by A41,A51,A55,CQC_LANG:def 1;
              end;
              end;
              hence C2 + C1 = C5 + C3 +C4;
            end;
            end;
              hence C2 + C1 = C5 + C3 +C4;
          end;
          end;
              hence C2 + C1 = C5 + C3 +C4;
        end;

          thus Absval(z1+z2) + IFEQ(add_ovfl(z1,z2),FALSE,0,2 to_power (n+1))
                   = Absval((t1+t2)^<*d1 'xor' d2 'xor' add_ovfl(t1,t2)*>) +
              IFEQ(add_ovfl(z1,z2),FALSE,0,2 to_power (n+1)) by A18,A19,Th45
                  .=Absval(t1+t2) + C2 + C1 by Th46
                  .= Absval(t1+t2) + C5 + C3 + C4 by A21
                  .= Absval(t1) + Absval(t2) + C3 + C4 by A17
                  .= Absval(t1) + C3 + (Absval(t2) + C4 )
                  .= Absval(t1)+IFEQ(d1,FALSE,0,2 to_power n)
                         + Absval(t2^<*d2*>) by Th46
                  .= Absval(z1) + Absval(z2) by A18,A19,Th46;
       end;
     thus for n being non empty Element of NAT holds P[n]
      from Indfrom1 (A1,A16);
   end;

  theorem :: BINARITH:48
       for z1,z2 being Tuple of n,BOOLEAN holds
    z1,z2 are_summable implies
    Absval(z1+z2) = Absval(z1) + Absval(z2)
    @proof
      let z1,z2 be Tuple of n,BOOLEAN;
      assume z1,z2 are_summable;
      then add_ovfl(z1,z2) = FALSE by Def10;
      then IFEQ(add_ovfl(z1,z2),FALSE,0,2 to_power (n))=0 by CQC_LANG:def 1;
      hence Absval(z1+z2) =
          Absval(z1+z2) + IFEQ(add_ovfl(z1,z2),FALSE,0,2 to_power (n))
          .= Absval(z1) + Absval(z2) by Th47;
    end;

begin :: Addenda

reserve a,b,c for natural number;

:: from SCMFSA_7, 2005.02.05, A.T.

theorem :: BINARITH:49
  c <= a & c <= b & a -' c = b -' c implies a = b
 @proof
    assume A1: a >= c & b >= c & a -' c = b -' c;
    then a - c >= 0 by XREAL_1:50;
    then
A2: a -' c = a - c by Def3;
    b - c >= 0 by A1,XREAL_1:50;then
    a + (-c) = b + (-c) by A1,A2,Def3;
    hence thesis;
 end;

theorem :: BINARITH:50
   b <= a implies a -' b = a - b
 @proof
    assume a >= b;
    then a - b >= 0 by XREAL_1:50;
    hence thesis by Def3;
 end;

:: from GOBOARD9, 2005.02.05, A.T.

theorem :: BINARITH:51
 a -' a = 0
  @proof a-a = 0; hence thesis by Def3; end;

theorem :: BINARITH:52
 a -' b <= a
  @proof per cases;
   suppose
A1: a-b >= 0;
    a-b <= a-0 by REAL_2:106;
   hence thesis by A1,Def3;
   end;
   suppose a-b < 0;
   hence thesis by Def3;
  end;
  end;

:: from AMI_5, 2005.11.16, A.T.

theorem :: BINARITH:53
   for i,j being natural number st i >= j holds i -' j + j = i
  @proof
   let i,j be natural number;
   assume i >= j;
   then ex m being Nat st i = j + m by NAT_1:10;
   hence i -' j + j = i by Th39;
  end;


:: from JORDAN4:1, AK, 21.06,2006

reserve n,i,j,k for Nat;

theorem :: BINARITH:54
  n-'i=0 implies n<=i
@proof
  assume A1:n-'i=0;
  assume i<n; then i+1<=n by NAT_1:13; then i+1-i<=n-i by XREAL_1:11;
  hence contradiction by A1,Def3;
end;

theorem :: BINARITH:55
  i<=j implies j+k-'i=j+k-i
@proof assume i<=j; then i<=j+k by NAT_1:12;
 hence thesis by Th50;
end;

theorem :: BINARITH:56
  i<=j implies j+k-'i=j-'i+k
@proof assume A1:i<=j; then i<=j+k by NAT_1:12;
 hence j+k-'i=j+k-i by Th50 .=j-i+k
    .=j-'i+k by A1,Th50;
end;

:: from JORDAN3, 2006.09.16, A.T.

reserve i,j,k,i1,i2,n for natural number;

theorem :: BINARITH:57
 i-'i1>=1 or i-i1>=1 implies i-'i1=i-i1
@proof
 assume A1: i-'i1>=1 or i-i1>=1;
 per cases by A1;
 suppose A2:i-'i1>=1;
  i-i1>=0 by A2,Def3;
 hence thesis by Def3;
 end;
 suppose i-i1>=1;
 hence thesis by Def3;
end;
end;

theorem :: BINARITH:58
n-'0=n
@proof
  n-'0=n-0 by Def3 .=n;
 hence thesis;
end;

theorem :: BINARITH:59
i1<=i2 implies n-'i2<=n-'i1
@proof assume A1:i1<=i2;
 per cases;
 suppose A2:i2<=n; then i1<=n by A1,XXREAL_0:2;
    then A3:n-'i1=n-i1 by Th50;
        n-'i2=n-i2 by A2,Th50;
  hence n-'i2<=n-'i1 by A1,A3,REAL_2:106;
 end;
 suppose i2>n; then n-i2<0 by REAL_2:105;
  hence n-'i2<=n-'i1 by Def3;
end;
end;

theorem :: BINARITH:60
  i1<=i2 implies i1-'n<=i2-'n
@proof assume A1:i1<=i2;
 per cases;
 suppose i1-n>=0; then A2:i1-'n=i1-n by Def3;
     i1-n<=i2-n by A1,XREAL_1:11;
   hence thesis by A2,Def3;
 end;
 suppose i1-n<0;
  hence thesis by Def3;
end;
end;

theorem :: BINARITH:61
i-'i1>=1 or i-i1>=1 implies i-'i1+i1=i
@proof assume i-'i1>=1 or i-i1>=1;
 then i-'i1+i1=i-i1+i1 by Th57 .=i;
 hence thesis;
end;

theorem :: BINARITH:62
i1<=i2 implies i1-'1<=i2
@proof assume A1:i1<=i2;
 per cases;
 suppose i1-1>=0; then i1-'1=i1-1 by Def3;
  then i1-'1<=i1-1+1 by NAT_1:12;
  hence i1-'1<=i2 by A1,XXREAL_0:2;
 end;
 suppose i1-1<0;
  hence i1-'1<=i2 by Def3;
end;
end;

theorem :: BINARITH:63
i-'2=i-'1-'1
@proof
 per cases;
 suppose A1:i>=2;
      1<=i by A1,XXREAL_0:2;
  then i-1>=0 by XREAL_1:50;
  then A2:i-'1=i-1 by Def3;
      i-1>=1+1-1 by A1,XREAL_1:11;
  then i-1-1>=1-1 by XREAL_1:11;
  then i-'1-'1 =i-2 by A2,Def3;
  hence thesis by Def3;
 end;
 suppose A3:i<2; then i-2<2-2 by XREAL_1:11;
   then A4:i-'2=0 by Def3;
   A5: i+1-1<=1+1-1 by A3,NAT_1:13;
     now per cases;
 case 1<=i; then i=1 by A5,XXREAL_0:1;
  then A6:i-'1-'1=0-'1 by Th51;
    0<=0-'1;
  hence thesis by A4,A6,Th52;
 end;
 case i<1; then i-1<1-1 by XREAL_1:11;
  then A7:i-'1-'1=0-'1 by Def3;
    0<=0-'1;
  hence thesis by A4,A7,Th52;
 end;
 end;
 hence thesis;
end;
end;

theorem :: BINARITH:64
 i1+1<=i2 implies i1-'1<i2 & i1-'2<i2 & i1<=i2
@proof assume
A1: i1+1<=i2;
then A2: i1<i2 by NAT_1:13;
     i1-'1<=i1 by Th52;
 hence A3:i1-'1<i2 by A2,XXREAL_0:2;
 A4:i1-'1-'1=i1-'2 by Th63;
     i1-'1-'1<=i1-'1 by Th52;
 hence i1-'2<i2 by A3,A4,XXREAL_0:2;
 thus thesis by A1,NAT_1:13;
end;

theorem :: BINARITH:65
i1+2<=i2 or i1+1+1<=i2
        implies i1+1<i2 & i1+1-'1<i2 & i1+1-'2<i2 & i1+1<=i2 &
                i1-'1+1<i2 & i1-'1+1-'1<i2 &
               i1<i2 & i1-'1<i2 & i1-'2<i2 & i1<=i2
@proof assume i1+2<=i2 or i1+1+1<=i2;
  then i1+1+1<=i2;
hence A1:i1+1<i2 & i1+1-'1<i2 & i1+1-'2<i2 & i1+1<=i2 by Th64,NAT_1:13;
        i1-'1<=i1 by Th52; then i1-'1+1<=i1+1 by XREAL_1:8;
    then A2:i1-'1+1<i2 by A1,XXREAL_0:2;
        i1-'1+1-'1<=i1-'1+1 by Th52;
hence i1-'1+1<i2 & i1-'1+1-'1<i2 by A2,XXREAL_0:2;
thus i1<i2 & i1-'1<i2 & i1-'2<i2 & i1<=i2 by A1,Th64,NAT_1:13;
end;

theorem :: BINARITH:66
i1<=i2 or i1<=i2-'1
     implies i1<i2+1 & i1<=i2+1 & i1<i2+1+1 & i1<=i2+1+1 & i1<i2+2 & i1<=i2+2
@proof assume A1:i1<=i2 or i1<=i2-'1;
  A2:now assume i1<=i2;
   then A3:i1<i2+1 by NAT_1:13;
       i2+1+1=i2+(1+1);
   hence i1<i2+1 & i1<=i2+1 & i1<i2+1+1 & i1<=i2+1+1 & i1<i2+2 & i1<=i2+2
                  by A3,NAT_1:13;
  end;
      now assume A4:i1<=i2-'1;
       i2-'1<=i2 by Th52;
  hence i1<i2+1 & i1<=i2+1 & i1<i2+1+1 & i1<=i2+1+1 & i1<i2+2 & i1<=i2+2
                      by A2,A4,XXREAL_0:2;
  end;
 hence thesis by A1,A2;
end;

theorem :: BINARITH:67
i1<i2 or i1+1<=i2 implies i1<=i2-'1
@proof assume A1:i1<i2 or i1+1<=i2;
 per cases by A1;
 suppose A2:i1<i2; then i1+1<=i2 by NAT_1:13; then A3: i1+1-1<=i2-1 by
XREAL_1:11; 0+1<=i2 by A2,NAT_1:13;
  hence i1<=i2-'1 by A3,Th50;
 end;
 suppose A4:i1+1<=i2; then A5: i1+1-1<=i2-1 by XREAL_1:11;
  0+1<=i2 by A4,NAT_1:13;
  hence i1<=i2-'1 by A5,Th50;
end;
end;

theorem :: BINARITH:68
i>=i1 implies i>=i1-'i2
@proof assume A1:i>=i1;
      i1>=i1-'i2 by Th52;
  hence thesis by A1,XXREAL_0:2;
end;

theorem :: BINARITH:69
      1<=i & 1<=i1-'i implies i1-'i<i1
@proof assume A1:1<=i & 1<=i1-'i;
 then A2:i1-i=(i1-'i)+i-i by Th61 .=i1-'i;
  i1-(i1-'i) = i by A2;
 hence thesis by A1,REAL_2:106;
end;

:: from SPRECT_3, 2006.09.16, A.T.

theorem :: BINARITH:70   :: SPRECT_3:5
 i-'k <= j implies i <= j + k
@proof assume
A1: i-'k <= j;
 per cases;
 suppose
A2: i >= k;
      i-'k +k <= j + k by A1,XREAL_1:8;
 hence i <= j + k by A2,Th53;
 end;
 suppose
A3: i <= k;
      k <= j + k by NAT_1:11;
 hence i <= j + k by A3,XXREAL_0:2;
end;
end;

theorem :: BINARITH:71   :: SPRECT_3:6
 i <= j + k implies i-'k <= j
@proof assume i <= j + k;
  then i -' k <= j + k -' k by Th60;
 hence i-'k <= j by Th39;
end;

theorem :: BINARITH:72    :: SPRECT_3:7
 i <= j -' k & k <= j implies i + k <= j
@proof assume that
A1: i <= j -' k and
A2: j >= k;
      i + k <= j -' k + k by A1,XREAL_1:8;
 hence i + k <= j by A2,Th53;
end;

theorem :: BINARITH:73  :: SPRECT_3:8
     j + k <= i implies k <= i -' j
@proof assume
A1: j + k <= i;
 per cases by A1,XXREAL_0:1;
 suppose j + k = i;
 hence k <= i -' j by Th39;
 end;
 suppose j + k < i;
 hence k <= i -' j by Th70;
end;
end;

theorem :: BINARITH:74   :: SPRECT_3:9
  k <= i & i < j implies i -' k < j -' k
@proof assume that
A1: k <= i and
A2: i < j;
A3: k <= j by A1,A2,XXREAL_0:2;
  i -' k + k = i by A1,Th53;
  then i -' k + k < j -' k + k by A2,A3,Th53;
 hence i -' k < j -' k by XREAL_1:8;
end;

theorem :: BINARITH:75   :: SPRECT_3:10
  i < j & k < j implies i -' k < j -' k
@proof assume that
A1: i < j and
A2: k < j;
 per cases;
 suppose k <= i;
then A3: i -' k = i - k by Th50;
      j -' k = j - k by A2,Th50;
 hence thesis by A1,A3,XREAL_1:11;
 end;
 suppose k > i;
  then i - k < 0 by REAL_2:105;
  then A4: i -' k = 0 by Def3;
      j -' k <> 0 by A2,Th54;
 hence thesis by A4;
end;
end;

:: from JORDAN3, 2007.03.09, A.T

reserve D for non empty set;

theorem :: BINARITH:76
 for f being FinSequence of D,k being Nat holds
       len (f/^k)=len f-'k;

