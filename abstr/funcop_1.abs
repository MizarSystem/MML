:: Binary Operations Applied to Functions
::  by Andrzej Trybulec
::
:: Received September 4, 1989
:: Copyright (c) 1990 Association of Mizar Users

environ

 vocabularies FUNCT_1, FUNCT_3, PARTFUN1, RELAT_1, ZFMISC_1, XBOOLE_0, TARSKI,
      SUBSET_1, BINOP_1, MCART_1, FUNCOP_1, WELLORD1;
 notations TARSKI, XBOOLE_0, ZFMISC_1, SUBSET_1, MCART_1, RELAT_1, FUNCT_1,
      RELSET_1, PARTFUN1, FUNCT_2, FUNCT_3, BINOP_1, WELLORD1;
 constructors PARTFUN1, BINOP_1, FUNCT_3, RELSET_1, WELLORD1;
 registrations XBOOLE_0, SUBSET_1, RELAT_1, FUNCT_1, FUNCT_2, RELSET_1;
 requirements SUBSET, BOOLE;


begin

reserve f,g,h for Function,
  A for set;

canceled;

theorem :: FUNCOP_1:2
  delta A = <:id A, id A:>;

reserve F for Function,
  B,x,y,y1,y2,z for set;

definition
  let f;
  func f~ -> Function means
:: FUNCOP_1:def 1

  dom it = dom f & for x st x in dom f holds
(for y,z st f.x = [y,z] holds it.x = [z,y]) & (f.x = it.x or ex y,z st f.x =[y,
  z]);
  involutiveness;
end;

canceled 3;

theorem :: FUNCOP_1:6
  <:f,g:> = <:g,f:>~;

theorem :: FUNCOP_1:7
  (f|A)~ = f~|A;

canceled;

theorem :: FUNCOP_1:9
  (delta A)~ = delta A;

theorem :: FUNCOP_1:10
  <:f,g:>|A = <:f|A,g:>;

theorem :: FUNCOP_1:11
  <:f,g:>|A = <:f,g|A:>;

definition
  let A, z be set;
  func A --> z -> set equals
:: FUNCOP_1:def 2
  [:A, {z}:];
end;

registration
  let A, z be set;
  cluster A --> z -> Function-like Relation-like;
end;

canceled;

theorem :: FUNCOP_1:13
  x in A implies (A --> z).x = z;

theorem :: FUNCOP_1:14
  A <> {} implies rng (A --> x) = {x};

theorem :: FUNCOP_1:15
  rng f = {x} implies f = (dom f) --> x;

registration
  let x;
  cluster {} --> x -> empty;
end;

registration
  let x;
  let A be empty set;
  cluster A --> x -> empty;
end;

registration
  let x;
  let A be non empty set;
  cluster A --> x -> non empty;
end;

theorem :: FUNCOP_1:16
  dom ({} --> x) = {} & rng ({} --> x) = {};

theorem :: FUNCOP_1:17
  (for z st z in dom f holds f.z = x) implies f = dom f --> x;

theorem :: FUNCOP_1:18
  (A --> x)|B = A /\ B --> x;

theorem :: FUNCOP_1:19
  dom (A --> x) = A & rng (A --> x) c= {x};

theorem :: FUNCOP_1:20
  x in B implies (A --> x)"B = A;

theorem :: FUNCOP_1:21
  (A --> x)"{x} = A;

theorem :: FUNCOP_1:22
  not x in B implies (A --> x)"B = {};

theorem :: FUNCOP_1:23
  x in dom h implies h*(A --> x) = A --> h.x;

theorem :: FUNCOP_1:24
  A <> {} & x in dom h implies dom(h*(A --> x)) <> {};

theorem :: FUNCOP_1:25
  (A --> x)*h = h"A --> x;

theorem :: FUNCOP_1:26
  (A --> [x,y])~ = A --> [y,x];

definition
  let F,f,g;
  func F.:(f,g) -> set equals
:: FUNCOP_1:def 3
  F * <:f,g:>;
end;

registration
  let F,f,g;
  cluster F.:(f,g) -> Function-like Relation-like;
end;

theorem :: FUNCOP_1:27
  for h st dom h = dom(F.:(f,g)) & for z being set st z in dom (F.:(f,g)
  ) holds h.z = F.(f.z,g.z) holds h = F.:(f,g);

theorem :: FUNCOP_1:28
  x in dom (F.:(f,g)) implies (F.:(f,g)).x = F.(f.x,g.x);

theorem :: FUNCOP_1:29
  f|A = g|A implies (F.:(f,h))|A = (F.:(g,h))|A;

theorem :: FUNCOP_1:30
  f|A = g|A implies (F.:(h,f))|A = (F.:(h,g))|A;

theorem :: FUNCOP_1:31
  F.:(f,g)*h = F.:(f*h, g*h);

definition
  let F,f,x;
  func F[:](f,x) -> set equals
:: FUNCOP_1:def 4
  F * <:f, dom f --> x:>;
end;

registration
  let F,f,x;
  cluster F[:](f,x) -> Function-like Relation-like;
end;

canceled 2;

theorem :: FUNCOP_1:34
  F[:](f,x) = F.:(f, dom f --> x);

theorem :: FUNCOP_1:35
  x in dom (F[:](f,z)) implies (F[:](f,z)).x = F.(f.x,z);

theorem :: FUNCOP_1:36
  f|A = g|A implies (F[:](f,x))|A = (F[:](g,x))|A;

theorem :: FUNCOP_1:37
  F[:](f,x)*h = F[:](f*h,x);

canceled;

theorem :: FUNCOP_1:39
  F[:](f,x)*id A = F[:](f|A,x);

definition
  let F,x,g;
  func F[;](x,g) -> set equals
:: FUNCOP_1:def 5
  F * <:dom g --> x, g:>;
end;

registration
  let F,x,g;
  cluster F[;](x,g) -> Function-like Relation-like;
end;

canceled;

theorem :: FUNCOP_1:41
  F[;](x,g) = F.:(dom g --> x, g);

theorem :: FUNCOP_1:42
  x in dom (F[;](z,f)) implies (F[;](z,f)).x = F.(z,f.x);

theorem :: FUNCOP_1:43
  f|A = g|A implies (F[;](x,f))|A = (F[;](x,g))|A;

theorem :: FUNCOP_1:44
  F[;](x,f)*h = F[;](x,f*h);

canceled;

theorem :: FUNCOP_1:46
  F[;](x,f)*id A = F[;](x,f|A);

reserve X for non empty set,
  Y for set,
  F for BinOp of X,
  f,g,h for Function
  of Y,X,
  x,x1,x2 for Element of X;

theorem :: FUNCOP_1:47
  F.:(f,g) is Function of Y,X;

definition
  let X be non empty set, Z be set;
  let F be BinOp of X, f,g be Function of Z,X;
  redefine func F.:(f,g) -> Function of Z,X;
end;

reserve Y for non empty set,
  F for BinOp of X,
  f,g,h for Function of Y,X,
  x,
  x1,x2 for Element of X;

theorem :: FUNCOP_1:48
  for z being Element of Y holds (F.:(f,g)).z = F.(f.z,g.z);

theorem :: FUNCOP_1:49
  for h being Function of Y,X holds (for z being Element of Y
  holds h.z = F.(f.z,g.z)) implies h = F.:(f,g);

canceled;

theorem :: FUNCOP_1:51
  for g being Function of X,X holds F.:(id X, g)*f = F.:(f,g*f);

theorem :: FUNCOP_1:52
  for g being Function of X,X holds F.:(g, id X)*f = F.:(g*f,f);

theorem :: FUNCOP_1:53
  F.:(id X, id X)*f = F.:(f,f);

theorem :: FUNCOP_1:54
  for g being Function of X,X holds F.:(id X, g).x = F.(x,g.x);

theorem :: FUNCOP_1:55
  for g being Function of X,X holds F.:(g, id X).x = F.(g.x,x);

theorem :: FUNCOP_1:56
  F.:(id X, id X).x = F.(x,x);

theorem :: FUNCOP_1:57
  for A,B for x being set st x in B holds A --> x is Function of A
  , B;

definition
  let I,i be set;
  redefine func I --> i -> Function of I,{i};
end;

definition
  let B be non empty set, A be set, b be Element of B;
  redefine func A --> b -> Function of A,B;
end;

theorem :: FUNCOP_1:58
  for A,X,x holds A --> x is Function of A, X;

reserve Y for set,
  F for BinOp of X,
  f,g,h for Function
  of Y,X,
  x,x1,x2 for Element of X;

theorem :: FUNCOP_1:59
  F[:](f,x) is Function of Y,X;

definition
  let X be non empty set, Z be set;
  let F be BinOp of X, f be Function of Z,X, x be Element of X;
  redefine func F[:](f,x) -> Function of Z,X;
end;

reserve Y for non empty set,
  F for BinOp of X,
  f,g,h for Function of Y,X,
  x,
  x1,x2 for Element of X;

theorem :: FUNCOP_1:60
  for y being Element of Y holds (F[:](f,x)).y = F.(f.y,x);

theorem :: FUNCOP_1:61
  (for y being Element of Y holds g.y = F.(f.y,x)) implies g = F
  [:](f,x);

canceled;

theorem :: FUNCOP_1:63
  F[:](id X, x)*f = F[:](f,x);

theorem :: FUNCOP_1:64
  F[:](id X, x).x = F.(x,x);

reserve Y for set,
  F for BinOp of X,
  f,g,h for Function
  of Y,X,
  x,x1,x2 for Element of X;

theorem :: FUNCOP_1:65
  F[;](x,g) is Function of Y,X;

definition
  let X be non empty set, Z be set;
  let F be BinOp of X, x be Element of X;
  let g be Function of Z,X;
  redefine func F[;](x,g) -> Function of Z,X;
end;

reserve Y for non empty set,
  F for BinOp of X,
  f,g,h for Function of Y,X,
  x,
  x1,x2 for Element of X;

theorem :: FUNCOP_1:66
  for y being Element of Y holds (F[;](x,f)).y = F.(x,f.y);

theorem :: FUNCOP_1:67
  (for y being Element of Y holds g.y = F.(x,f.y)) implies g = F
  [;](x,f);

reserve Y for set,
  F for BinOp of X,
  f,g,h for Function
  of Y,X,
  x,x1,x2 for Element of X;

canceled;

theorem :: FUNCOP_1:69
  F[;](x, id X)*f = F[;](x,f);

theorem :: FUNCOP_1:70
  F[;](x, id X).x = F.(x,x);

theorem :: FUNCOP_1:71
  for X,Y,Z being non empty set for f being Function of X, [:Y,Z:] for x
  being Element of X holds f~.x =[(f.x)`2,(f.x)`1];

definition
  let X,Y,Z be non empty set;
  let f be Function of X, [:Y,Z:];
  redefine func rng f -> Relation of Y,Z;
end;

definition
  let X,Y,Z be non empty set;
  let f be Function of X, [:Y,Z:];
  redefine func f~ -> Function of X, [:Z,Y:];
end;

canceled;

theorem :: FUNCOP_1:73
  for X,Y,Z being non empty set for f being Function of X, [:Y,Z:] holds
  rng (f~) = (rng f)~;

reserve y for Element of Y;

theorem :: FUNCOP_1:74
  F is associative implies F[:](F[;](x1,f),x2) = F[;](x1,F[:](f,x2));

theorem :: FUNCOP_1:75
  F is associative implies F.:(F[:](f,x),g) = F.:(f,F[;](x,g));

theorem :: FUNCOP_1:76
  F is associative implies F.:(F.:(f,g),h) = F.:(f,F.:(g,h));

theorem :: FUNCOP_1:77
  F is associative implies F[;](F.(x1,x2),f) = F[;](x1,F[;](x2,f));

theorem :: FUNCOP_1:78
  F is associative implies F[:](f, F.(x1,x2)) = F[:](F[:](f,x1),x2);

theorem :: FUNCOP_1:79
  F is commutative implies F[;](x,f) = F[:](f,x);

theorem :: FUNCOP_1:80
  F is commutative implies F.:(f,g) = F.:(g,f);

theorem :: FUNCOP_1:81
  F is idempotent implies F.:(f,f) = f;

reserve Y for non empty set,
  F for BinOp of X,
  f for Function of Y,X,
  x for
  Element of X,
  y for Element of Y;

theorem :: FUNCOP_1:82
  F is idempotent implies F[;](f.y,f).y = f.y;

theorem :: FUNCOP_1:83
  F is idempotent implies F[:](f,f.y).y = f.y;

:: Addendum, 2002.07.08

theorem :: FUNCOP_1:84
  for F,f,g being Function st [:rng f, rng g:] c= dom F holds dom(F.:(f,
  g)) = dom f /\ dom g;

:: from PRALG_1, 2004.07.23

definition
  let IT be Function;
  attr IT is Function-yielding means
:: FUNCOP_1:def 6

  for x being set st x in dom IT
  holds IT.x is Function;
end;

registration
  cluster Function-yielding Function;
end;

registration
  let B be Function-yielding Function, j be set;
  cluster B.j -> Function-like Relation-like;
end;

registration
  let F be Function-yielding Function, f be Function;
  cluster F * f -> Function-yielding;
end;

:: missing, 2005.11.13, A.T.

registration
  let B;
  let c be non empty set;
  cluster B --> c -> non-empty;
end;

:: missing, 2005.12.20, A.T.

theorem :: FUNCOP_1:85
  ([:X,Y:] --> z).(x,y) = z;

:: from CAT_1, 2007.02.11, A.T.

reserve a,b,c for set;

definition
  let a,b,c;
  func (a,b).-->c -> Function equals
:: FUNCOP_1:def 7
  {[a,b]} --> c;
end;

theorem :: FUNCOP_1:86
  ((a,b).-->c).(a,b) = c;

:: from CQC_LANG, 2007.03.13, A.T.

definition
  let x,y,a,b be set;
  func IFEQ(x,y,a,b) -> set equals
:: FUNCOP_1:def 8

  a if x = y otherwise b;
end;

definition
  let D be set;
  let x,y be set, a,b be Element of D;
  redefine func IFEQ(x,y,a,b) -> Element of D;
end;

definition
  let x,y be set;
  func x .--> y -> set equals
:: FUNCOP_1:def 9
  {x} --> y;
end;

registration
  let x,y be set;
  cluster x .--> y -> Function-like Relation-like;
end;

registration
  let x,y be set;
  cluster x .--> y -> one-to-one;
end;

theorem :: FUNCOP_1:87
  for x,y be set holds (x .--> y).x = y;

:: from SCMFSA6A, 2007.07.22, A.T.

theorem :: FUNCOP_1:88
  for a,b being set, f being Function holds a.-->b c= f iff a in dom f &
  f.a = b;

:: from FUNCT_2, 2007.11.22, A.T., :: from CAT_4

notation
  let o,m,r be set;
  synonym (o,m) :-> r for (o,m) .--> r;
end;

definition
  let o,m,r be set;
  redefine func (o,m) :-> r -> Function of [:{o},{m}:],{r} means
:: FUNCOP_1:def 10
  not contradiction;
end;

:: missing, 2008.03.20, A.T.

reserve x,y,z for set;

theorem :: FUNCOP_1:89
  x in dom(x .--> y);

theorem :: FUNCOP_1:90
  z in dom(x .--> y) implies z = x;

:: missing, 2008.04.15, A.T.

theorem :: FUNCOP_1:91
  not x in A implies (x .--> y)|A = {};

:: from CAT_1, (new notation), 2008.06.30. A.T.

notation
  let x,y;
  synonym x :-> y for x .--> y;
end;

definition
  let m,o be set;
  redefine func m :-> o -> Function of {m}, {o};
end;

theorem :: FUNCOP_1:92
  for x being Element of {a} for y being Element of {b} holds ((a,b):->c
  ).(x,y) = c;

:: from MSUHOM_1, ALTCAT_1, 2008.07.06, A.T.

registration
  let f be Function-yielding Function, C be set;
  cluster f|C -> Function-yielding;
end;

:: from CIRCCOMB, 2008.07.06, A.T.

registration
  let A be set;
  let f be Function;
  cluster A --> f -> Function-yielding;
end;

:: from SEQM_3, 2008.07.17, A.T.

registration
  let X,a be set;
  cluster X --> a -> constant;
end;
:: from YELLOW_6, 2008.07.17, A.T.

registration
  cluster non empty constant Function;
end;
:: missing, 2008.07.17, A.T.

registration
  let f be constant Function, X be set;
  cluster f|X -> constant;
end;
:: missing, 2008.08.14, A.T.

theorem :: FUNCOP_1:93
  for f being non empty constant Function ex y st for x st x in dom f
  holds f.x = y;
:: from YELLOW_6, 2008.12.26, A.T.

theorem :: FUNCOP_1:94
  for X being non empty set, x being set holds the_value_of (X --> x) =
  x;

:: from CIRCCMB3, 2008.12.26, A.T.

theorem :: FUNCOP_1:95
  for f being constant Function holds f = (dom f) --> the_value_of f;

:: missing, 2009.01.21, A.T.

registration
  let X be set, Y be non empty set;
  cluster total PartFunc of X,Y;
end;

:: new, 2009.02.14, A.T.

registration
  let I, A be set;
  cluster I --> A -> I-defined;
end;

registration
  let I, A be set;
  cluster I .--> A -> {I}-defined;
end;

:: BORSUK_1:6, 2009.06.11, A.K.

theorem :: FUNCOP_1:96
  (A --> x).:B c= {x};

registration
  let I be set, f be Function;
  cluster I .--> f -> Function-yielding;
end;

:: 2009.10.03, A.T.

registration let I be set;
 cluster total (I-defined non-empty Function);
end;

theorem :: FUNCOP_1:97
  x .--> y is_isomorphism_of {[x,x]},{[y,y]};

theorem :: FUNCOP_1:98
  {[x,x]}, {[y,y]} are_isomorphic;

registration
  let I, A be set;
  cluster I --> A -> total (I-defined Function);
end;

theorem :: FUNCOP_1:99
  for f being Function st x in dom f
   holds x .--> f.x c= f;

registration let A be non empty set;
 let x be set, i be Element of A;
 cluster x .--> i -> A-valued;
end;

reserve Y for set,
        f,g for Function of Y,X,
        x for Element of X,
        y for Element of Y;

:: missing, 2010.02.10, A.T.

theorem :: FUNCOP_1:100
  F is associative implies F.:(F[;](x,f),g) = F[;](x,F.:(f,g));

