:: On the Composition of Macro Instructions of Standard Computers
::  by Artur Korni{\l}owicz
::
:: Received April 14, 2000
:: Copyright (c) 2000 Association of Mizar Users

environ

 vocabularies NUMBERS, ORDINAL1, SETFAM_1, ARYTM_1, ARYTM_3, CARD_1, SUBSET_1,
      AMI_1, XBOOLE_0, RELAT_1, TARSKI, FUNCOP_1, GLIB_000, GOBOARD5, AMISTD_1,
      UNIALG_1, FUNCT_1, CARD_3, CARD_5, FRECHET, RCOMP_1, STRUCT_0, VALUED_1,
      FSM_1, FUNCT_4, FUNCT_7, TURING_1, CIRCUIT2, AMISTD_2, PARTFUN1, CAT_1,
      SCMNORM;
 notations TARSKI, XBOOLE_0, SUBSET_1, ORDINAL1, MCART_1, SETFAM_1, MEMBERED,
      RELAT_1, FUNCT_1, PARTFUN1, FUNCT_2, FUNCT_4, CARD_1, NUMBERS, XCMPLX_0,
      XXREAL_0, NAT_1, CARD_3, FINSEQ_1, FUNCOP_1, NAT_D, FUNCT_7, VALUED_0,
      VALUED_1, AFINSQ_1, STRUCT_0, COMPOS_1, EXTPRO_1, AMISTD_1;
 constructors WELLORD2, REALSET1, NAT_D, AMISTD_1, XXREAL_2, PRE_POLY,
      AFINSQ_1, ORDINAL4, RECDEF_2, VALUED_1;
 registrations XBOOLE_0, SETFAM_1, RELAT_1, FUNCT_1, FUNCOP_1, FINSET_1,
      XXREAL_0, XREAL_0, NAT_1, MEMBERED, FINSEQ_1, CARD_3, REALSET1, FUNCT_7,
      STRUCT_0, AMISTD_1, CARD_1, FUNCT_4, XXREAL_2, RELSET_1, GRFUNC_1,
      FUNCT_2, ORDINAL1, AFINSQ_1, VALUED_1, VALUED_0, COMPOS_1, EXTPRO_1;
 requirements NUMERALS, BOOLE, SUBSET, REAL, ARITHM;


begin  :: Properties of AMI-Struct

reserve k, m for natural number,
  x, x1, x2, x3, y, y1, y2, y3, X,Y,Z for set,
  N for with_non-empty_elements non empty set;

canceled 16;

theorem :: AMISTD_2:17
  for I being Instruction of STC N holds JumpPart I = 0;

definition
 canceled 5;
  let N be with_non-empty_elements non empty set,
  S be IC-Ins-separated definite standard-ins
  (non empty stored-program AMI-Struct over N), I be Instruction of S;
  attr I is with_explicit_jumps means
:: AMISTD_2:def 6
 JUMP I = rng JumpPart I;
  canceled;
end;

definition
  let N be with_non-empty_elements non empty set,
  S be standard-ins IC-Ins-separated definite
  (non empty stored-program AMI-Struct over N);
  attr S is with_explicit_jumps means
:: AMISTD_2:def 8
 for I being Instruction of S holds I is with_explicit_jumps;
  canceled;
end;

registration
  let N be with_non-empty_elements non empty set;
  cluster standard -> (IC-Ins-separated definite
    (non empty stored-program AMI-Struct over N));
end;

registration
  let N be with_non-empty_elements non empty set;
  cluster standard standard-ins (IC-Ins-separated definite
    (non empty stored-program AMI-Struct over N));
end;

theorem :: AMISTD_2:18
  for S being standard (IC-Ins-separated definite
  (non empty stored-program AMI-Struct over N)), I being Instruction of S
  st for f being Element of NAT holds NIC(I,f)={succ f}
  holds JUMP I is empty;

registration
  let N be with_non-empty_elements non empty set,
  I be Instruction of STC N;
  cluster JUMP I -> empty;
end;

theorem :: AMISTD_2:19
  for T being InsType of STC N holds JumpParts T = {0};

registration
  let N be with_non-empty_elements non empty set;
  cluster STC N ->
   with_explicit_jumps homogeneous regular J/A-independent;
end;

registration
  let N be with_non-empty_elements non empty set;
  cluster standard regular J/A-independent homogeneous
   halting realistic with_explicit_jumps (IC-Ins-separated definite
   standard-ins
    (non empty stored-program AMI-Struct over N));
end;

registration
  let N be with_non-empty_elements non empty set;
  cluster Trivial-AMI N -> regular J/A-independent;
end;

registration

  let N be with_non-empty_elements non empty set;
  cluster regular J/A-independent (standard-ins AMI-Struct over N);
end;

registration

  let N be with_non-empty_elements non empty set,
  I be Instruction of Trivial-AMI N;
  cluster JUMP I -> empty;
end;

registration
  let N be with_non-empty_elements non empty set;
  cluster Trivial-AMI N -> with_explicit_jumps;
end;

registration
  let N;
  cluster regular J/A-independent
    (non empty stored-program standard-ins AMI-Struct over N);
end;

registration

  let N be with_non-empty_elements non empty set;
  cluster with_explicit_jumps halting realistic
    (standard-ins IC-Ins-separated definite
    (non empty stored-program AMI-Struct over N));
end;

registration

  let N be with_non-empty_elements non empty set;
  let S be with_explicit_jumps (IC-Ins-separated
  definite (non empty stored-program standard-ins AMI-Struct over N));
  cluster -> with_explicit_jumps Instruction of S;
end;

canceled;

theorem :: AMISTD_2:21
  for S being realistic IC-Ins-separated definite
  (non empty stored-program AMI-Struct over N),
  I being Instruction of S st I is halting holds JUMP I is empty;

registration

  let N be with_non-empty_elements non empty set,
  S be halting realistic
  (IC-Ins-separated definite (non empty stored-program AMI-Struct over N)),
  I be halting Instruction of S;
  cluster JUMP I -> empty;
end;

theorem :: AMISTD_2:22
  for S being halting with_explicit_jumps
  realistic (IC-Ins-separated definite
  (standard-ins non empty stored-program AMI-Struct over N)),
  I being Instruction of S st I is ins-loc-free holds JUMP I is empty;

registration

  let N be with_non-empty_elements non empty set,
  S be with_explicit_jumps
  realistic (standard-ins IC-Ins-separated definite
  (non empty stored-program AMI-Struct over N));
  cluster halting -> ins-loc-free Instruction of S;
end;

registration
  let N be with_non-empty_elements non empty set,
  S be standard with_explicit_jumps
   standard-ins (IC-Ins-separated definite
  (standard-ins non empty stored-program AMI-Struct over N));
  cluster sequential -> ins-loc-free Instruction of S;
end;

registration
  let N be with_non-empty_elements non empty set,
  S be standard realistic halting
  (IC-Ins-separated definite
  (non empty stored-program AMI-Struct over N));
  cluster Stop S -> closed;
end;

begin  :: On the composition of macro instructions

registration
  let N be with_non-empty_elements non empty set,
  S be halting standard with_explicit_jumps
  realistic regular homogeneous J/A-independent
   (standard-ins IC-Ins-separated definite
  (non empty stored-program AMI-Struct over N)),
  I be halting Instruction of S, k be natural number;
  cluster IncAddr(I,k) -> halting;
end;

canceled 13;

theorem :: AMISTD_2:36
  for S being regular homogeneous J/A-independent standard halting
  with_explicit_jumps
  realistic (standard-ins IC-Ins-separated definite
  (non empty stored-program AMI-Struct over N)),
  I being Instruction of S st I is sequential
  holds IncAddr(I,k) is sequential;

definition
 canceled 8;
  let N be with_non-empty_elements non empty set,
  S be regular homogeneous J/A-independent standard halting realistic
   (standard-ins IC-Ins-separated definite
  (non empty stored-program AMI-Struct over N)), I be Instruction of S;
  attr I is IC-good means
:: AMISTD_2:def 18

  for k being natural number, s1 being State of S
  holds IC Exec(I,s1) + k = IC Exec(IncAddr(I,k),IncrIC(s1,k));
end;

definition
  let N be with_non-empty_elements non empty set,
  S be regular homogeneous J/A-independent standard halting realistic
   (standard-ins IC-Ins-separated definite
  (non empty stored-program AMI-Struct over N));
  attr S is IC-good means
:: AMISTD_2:def 19

  for I being Instruction of S holds I is IC-good;
end;

definition
  let N be with_non-empty_elements set,
  S be stored-program AMI-Struct over N, I be Instruction of S;
  attr I is Exec-preserving means
:: AMISTD_2:def 20

  for s1, s2 being State of S
  st s1, s2 equal_outside NAT holds Exec(I,s1), Exec(I,s2) equal_outside NAT;
end;

definition
  let N be with_non-empty_elements set,
  S be stored-program AMI-Struct over N;
  attr S is Exec-preserving means
:: AMISTD_2:def 21

  for I being Instruction of S holds I is Exec-preserving;
end;

registration
  let N be with_non-empty_elements non empty set,
  S be regular homogeneous J/A-independent standard
  with_explicit_jumps
  (standard-ins IC-Ins-separated definite halting realistic
  (non empty stored-program AMI-Struct over N));
  cluster sequential -> IC-good Instruction of S;
end;

registration
  let N be with_non-empty_elements non empty set,
  S be regular homogeneous J/A-independent standard
  realistic with_explicit_jumps
  (standard-ins IC-Ins-separated definite halting realistic
  (non empty stored-program AMI-Struct over N));
  cluster halting -> IC-good Instruction of S;
end;

registration

  let N be with_non-empty_elements non empty set,
  S be stored-program AMI-Struct over N;
  cluster halting -> Exec-preserving Instruction of S;
end;

canceled 9;

theorem :: AMISTD_2:46
  for S being stored-program AMI-Struct over N,
  I being Instruction of S st I is halting holds I is Exec-preserving;

registration
  let N be with_non-empty_elements non empty set;
  cluster STC N -> IC-good Exec-preserving;
end;

registration
  let N be with_non-empty_elements non empty set;
  cluster homogeneous realistic halting
    with_explicit_jumps Exec-preserving
    (regular J/A-independent standard (standard-ins IC-Ins-separated definite
    (non empty stored-program AMI-Struct over N)));
end;

registration
  let N be with_non-empty_elements non empty set;
  cluster IC-good (homogeneous realistic
    with_explicit_jumps Exec-preserving halting
    (regular J/A-independent standard (standard-ins IC-Ins-separated definite
    (non empty stored-program AMI-Struct over N))));
end;

registration

  let N be with_non-empty_elements non empty set;
  cluster Trivial-AMI N -> Exec-preserving;
end;

registration
  let N be with_non-empty_elements non empty set,
  S be IC-good (regular homogeneous J/A-independent standard
  (standard-ins IC-Ins-separated definite halting realistic
  (non empty stored-program AMI-Struct over N)));
  cluster -> IC-good Instruction of S;
end;

registration
  let N be with_non-empty_elements non empty set,
  S be Exec-preserving (stored-program AMI-Struct over N);
  cluster -> Exec-preserving Instruction of S;
end;

registration
  let N be with_non-empty_elements non empty set,
  S be IC-good (homogeneous Exec-preserving
  (regular J/A-independent standard realistic halting (standard-ins
  IC-Ins-separated definite
  (non empty stored-program AMI-Struct over N)))),
  F, G be closed initial non empty (NAT-defined
  (the Instructions of S)-valued FinPartState of S);
  cluster F ';' G -> closed;
end;

canceled 16;

theorem :: AMISTD_2:63
  for I being Instruction of Trivial-AMI N holds JumpPart I = 0;

theorem :: AMISTD_2:64
  for T being InsType of Trivial-AMI N holds JumpParts T = {0};

