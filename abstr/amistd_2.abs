:: On the Composition of Macro Instructions of Standard Computers
::  by Artur Korni{\l}owicz
::
:: Received April 14, 2000
:: Copyright (c) 2000-2011 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies NUMBERS, ORDINAL1, SETFAM_1, ARYTM_1, ARYTM_3, CARD_1, SUBSET_1,
      AMI_1, XBOOLE_0, RELAT_1, TARSKI, FUNCOP_1, GLIB_000, GOBOARD5, AMISTD_1,
      UNIALG_1, FUNCT_1, CARD_3, CARD_5, FRECHET, RCOMP_1, STRUCT_0, VALUED_1,
      FSM_1, FUNCT_4, FUNCT_7, TURING_1, CIRCUIT2, AMISTD_2, PARTFUN1, CAT_1,
      SCMNORM, NAT_1, RELOC, PBOOLE, XXREAL_0, COMPOS_1, MSUALG_1;
 notations TARSKI, XBOOLE_0, SUBSET_1, ORDINAL1, MCART_1, SETFAM_1, MEMBERED,
      RELAT_1, FUNCT_1, PARTFUN1, FUNCT_2, FUNCT_4, PBOOLE, CARD_1, NUMBERS,
      XCMPLX_0, XXREAL_0, NAT_1, CARD_3, FINSEQ_1, FUNCOP_1, NAT_D, FUNCT_7,
      VALUED_0, VALUED_1, AFINSQ_1, STRUCT_0, COMPOS_1, EXTPRO_1, AMISTD_1;
 constructors WELLORD2, REALSET1, NAT_D, AMISTD_1, XXREAL_2, PRE_POLY,
      AFINSQ_1, ORDINAL4, RECDEF_2, VALUED_1, NAT_1;
 registrations XBOOLE_0, SETFAM_1, RELAT_1, FUNCT_1, FUNCOP_1, FINSET_1,
      XXREAL_0, XREAL_0, NAT_1, MEMBERED, FINSEQ_1, CARD_3, REALSET1, FUNCT_7,
      STRUCT_0, AMISTD_1, CARD_1, FUNCT_4, XXREAL_2, RELSET_1, GRFUNC_1,
      FUNCT_2, ORDINAL1, AFINSQ_1, VALUED_1, VALUED_0, COMPOS_1, EXTPRO_1,
      XCMPLX_0, REAL_1, PBOOLE;
 requirements NUMERALS, BOOLE, SUBSET, REAL, ARITHM;


begin  :: Properties of AMI-Struct

reserve k, m for natural number,
  x, x1, x2, x3, y, y1, y2, y3, X,Y,Z for set,
  N for with_non-empty_elements non empty set;

canceled 16;

theorem :: AMISTD_2:17
  for I being Instruction of STC N holds JumpPart I = 0;

definition
 canceled 5;
  let N be with_non-empty_elements non empty set,
  S be IC-Ins-separated definite standard-ins
  (non empty stored-program AMI-Struct over N), I be Instruction of S;
  attr I is with_explicit_jumps means
:: AMISTD_2:def 6
 JUMP I = rng JumpPart I;
  canceled;
end;

definition
  let N be with_non-empty_elements non empty set,
  S be standard-ins IC-Ins-separated definite
  (non empty stored-program AMI-Struct over N);
  attr S is with_explicit_jumps means
:: AMISTD_2:def 8
 for I being Instruction of S holds I is with_explicit_jumps;
  canceled;
end;

registration
  let N be with_non-empty_elements non empty set;
  cluster standard -> (IC-Ins-separated definite
    (non empty stored-program AMI-Struct over N));
end;

registration
  let N be with_non-empty_elements non empty set;
  cluster standard standard-ins (IC-Ins-separated definite
    (non empty stored-program AMI-Struct over N));
end;

theorem :: AMISTD_2:18
  for S being standard (IC-Ins-separated definite
  (non empty stored-program AMI-Struct over N)), I being Instruction of S
  st for f being Element of NAT holds NIC(I,f)={succ f}
  holds JUMP I is empty;

registration
  let N be with_non-empty_elements non empty set,
  I be Instruction of STC N;
  cluster JUMP I -> empty;
end;

theorem :: AMISTD_2:19
  for T being InsType of STC N holds JumpParts T = {0};

registration
  let N be with_non-empty_elements non empty set;
  cluster STC N ->
   with_explicit_jumps homogeneous regular J/A-independent;
end;

registration
  let N be with_non-empty_elements non empty set;
  cluster standard regular J/A-independent homogeneous
   halting realistic with_explicit_jumps (IC-Ins-separated definite
   standard-ins
    (non empty stored-program AMI-Struct over N));
end;

registration
  let N be with_non-empty_elements non empty set;
  cluster Trivial-AMI N -> regular J/A-independent;
end;

registration

  let N be with_non-empty_elements non empty set;
  cluster regular J/A-independent (standard-ins AMI-Struct over N);
end;

registration

  let N be with_non-empty_elements non empty set,
  I be Instruction of Trivial-AMI N;
  cluster JUMP I -> empty;
end;

registration
  let N be with_non-empty_elements non empty set;
  cluster Trivial-AMI N -> with_explicit_jumps;
end;

registration
  let N;
  cluster regular J/A-independent
    (non empty stored-program standard-ins AMI-Struct over N);
end;

registration

  let N be with_non-empty_elements non empty set;
  cluster with_explicit_jumps halting realistic
    (standard-ins IC-Ins-separated definite
    (non empty stored-program AMI-Struct over N));
end;

registration

  let N be with_non-empty_elements non empty set;
  let S be with_explicit_jumps (IC-Ins-separated
  definite (non empty stored-program standard-ins AMI-Struct over N));
  cluster -> with_explicit_jumps Instruction of S;
end;

canceled;

theorem :: AMISTD_2:21
  for S being realistic IC-Ins-separated definite
  (non empty stored-program AMI-Struct over N),
  I being Instruction of S st I is halting holds JUMP I is empty;

registration

  let N be with_non-empty_elements non empty set,
  S be halting realistic
  (IC-Ins-separated definite (non empty stored-program AMI-Struct over N)),
  I be halting Instruction of S;
  cluster JUMP I -> empty;
end;

theorem :: AMISTD_2:22
  for S being halting with_explicit_jumps
  realistic (IC-Ins-separated definite
  (standard-ins non empty stored-program AMI-Struct over N)),
  I being Instruction of S st I is ins-loc-free holds JUMP I is empty;

registration

  let N be with_non-empty_elements non empty set,
  S be with_explicit_jumps
  realistic (standard-ins IC-Ins-separated definite
  (non empty stored-program AMI-Struct over N));
  cluster halting -> ins-loc-free Instruction of S;
end;

registration
  let N be with_non-empty_elements non empty set,
  S be with_explicit_jumps
   standard-ins (IC-Ins-separated definite
  (standard-ins non empty stored-program AMI-Struct over N));
  cluster sequential -> ins-loc-free Instruction of S;
end;

registration
  let N be with_non-empty_elements non empty set,
  S be standard realistic halting
  (IC-Ins-separated definite
  (non empty stored-program AMI-Struct over N));
  cluster Stop S -> closed;
end;

begin  :: On the composition of macro instructions

registration
  let N be with_non-empty_elements non empty set,
  S be halting with_explicit_jumps
  realistic regular homogeneous J/A-independent
   (standard-ins IC-Ins-separated definite
  (non empty stored-program AMI-Struct over N)),
  I be halting Instruction of S, k be natural number;
  cluster IncAddr(I,k) -> halting;
end;

canceled 13;

theorem :: AMISTD_2:36
  for S being regular homogeneous J/A-independent standard halting
  with_explicit_jumps
  realistic (standard-ins IC-Ins-separated definite
  (non empty stored-program AMI-Struct over N)),
  I being Instruction of S st I is sequential
  holds IncAddr(I,k) is sequential;

definition
 canceled 8;
  let N be with_non-empty_elements non empty set,
  S be regular homogeneous J/A-independent halting realistic
   (standard-ins IC-Ins-separated definite
  (non empty stored-program AMI-Struct over N)), I be Instruction of S;
  attr I is IC-relocable means
:: AMISTD_2:def 18

  for j,k being natural number, s being State of S
  holds IC Exec(IncAddr(I,j),s) + k = IC Exec(IncAddr(I,j+k),IncIC(s,k));
end;

definition
  let N be with_non-empty_elements non empty set,
  S be regular homogeneous J/A-independent
  halting realistic
   (standard-ins IC-Ins-separated definite
  (non empty stored-program AMI-Struct over N));
  attr S is IC-relocable means
:: AMISTD_2:def 19

  for I being Instruction of S holds I is IC-relocable;
end;

definition
  let N be with_non-empty_elements set,
  S be stored-program AMI-Struct over N, I be Instruction of S;
  attr I is Exec-preserving means
:: AMISTD_2:def 20

  for s1, s2 being State of S st NPP s1 = NPP s2
   holds NPP Exec(I,s1) = NPP Exec(I,s2);
end;

definition
  let N be with_non-empty_elements set,
  S be stored-program AMI-Struct over N;
  attr S is Exec-preserving means
:: AMISTD_2:def 21

  for I being Instruction of S holds I is Exec-preserving;
end;

registration
  let N be with_non-empty_elements non empty set,
  S be regular homogeneous J/A-independent
  with_explicit_jumps
  (standard-ins IC-Ins-separated definite halting realistic
  (non empty stored-program AMI-Struct over N));
  cluster sequential -> IC-relocable Instruction of S;
end;

registration
  let N be with_non-empty_elements non empty set,
  S be regular homogeneous J/A-independent
  realistic with_explicit_jumps
  (standard-ins IC-Ins-separated definite halting realistic
  (non empty stored-program AMI-Struct over N));
  cluster halting -> IC-relocable Instruction of S;
end;

registration

  let N be with_non-empty_elements non empty set,
  S be stored-program AMI-Struct over N;
  cluster halting -> Exec-preserving Instruction of S;
end;

canceled 9;

theorem :: AMISTD_2:46
  for S being stored-program AMI-Struct over N,
  I being Instruction of S st I is halting holds I is Exec-preserving;

registration
  let N be with_non-empty_elements non empty set;
  cluster STC N -> IC-relocable Exec-preserving;
end;

registration
  let N be with_non-empty_elements non empty set;
  cluster homogeneous realistic halting
    with_explicit_jumps Exec-preserving
    (regular J/A-independent standard (standard-ins IC-Ins-separated definite
    (non empty stored-program AMI-Struct over N)));
end;

registration
  let N be with_non-empty_elements non empty set;
  cluster IC-relocable (homogeneous realistic
    with_explicit_jumps Exec-preserving halting
    (regular J/A-independent standard (standard-ins IC-Ins-separated definite
    (non empty stored-program AMI-Struct over N))));
end;

registration

  let N be with_non-empty_elements non empty set;
  cluster Trivial-AMI N -> Exec-preserving;
end;

registration
  let N be with_non-empty_elements non empty set,
  S be IC-relocable (regular homogeneous J/A-independent
  (standard-ins IC-Ins-separated definite halting realistic
  (non empty stored-program AMI-Struct over N)));
  cluster -> IC-relocable Instruction of S;
end;

registration
  let N be with_non-empty_elements non empty set,
  S be Exec-preserving (stored-program AMI-Struct over N);
  cluster -> Exec-preserving Instruction of S;
end;

registration
  let N be with_non-empty_elements non empty set,
  S be regular homogeneous J/A-independent
  realistic with_explicit_jumps
  (standard-ins IC-Ins-separated definite halting realistic
  (non empty stored-program AMI-Struct over N));
 cluster IC-relocable Instruction of S;
end;

theorem :: AMISTD_2:47
  for S be regular homogeneous J/A-independent halting
  realistic with_explicit_jumps
   (standard-ins IC-Ins-separated definite
  (non empty stored-program AMI-Struct over N)),
  I being IC-relocable Instruction of S
  for k being natural number, s being State of S
  holds IC Exec(I,s) + k = IC Exec(IncAddr(I,k),IncIC(s,k));

registration
  let N be with_non-empty_elements non empty set,
  S be IC-relocable (homogeneous Exec-preserving
  (regular J/A-independent standard realistic with_explicit_jumps
  halting (standard-ins
  IC-Ins-separated definite
  (non empty stored-program AMI-Struct over N)))),
  F, G be closed initial non empty (NAT-defined
  (the Instructions of S)-valued FinPartState of S);
  cluster F ';' G -> closed;
end;

canceled 15;

theorem :: AMISTD_2:63
  for I being Instruction of Trivial-AMI N holds JumpPart I = 0;

theorem :: AMISTD_2:64
  for T being InsType of Trivial-AMI N holds JumpParts T = {0};

theorem :: AMISTD_2:65
  for S being Exec-preserving IC-Ins-separated definite realistic
   (stored-program non empty AMI-Struct over N)
  for s1,s2 being State of S
   st (s1 | (Data-Locations S \/ {IC S}))
    = (s2 | (Data-Locations S \/ {IC S}))
for l being Instruction of S holds
 Exec (l,s1) | (Data-Locations S \/ {IC S})
  = Exec (l,s2) | (Data-Locations S \/ {IC S});

reserve n,m for Element of NAT;

theorem :: AMISTD_2:66
 for S being Exec-preserving IC-Ins-separated definite realistic
  (non empty stored-program AMI-Struct over N)
 for s1,s2 being State of S, I being Program of S
 for P1,P2 being (the Instructions of S)-valued ManySortedSet of NAT
  st I c= P1 & I c= P2 & NPP s1 = NPP s2 &
   (for m st m < n holds IC Comput(P2,s2,m) in dom I)
 for m st m <= n holds
    NPP Comput(P1,s1,m) = NPP Comput(P2,s2,m);

theorem :: AMISTD_2:67
 for S being Exec-preserving IC-Ins-separated definite realistic
  halting (non empty stored-program AMI-Struct over N)
 for s1,s2 being State of S
   st NPP s1 = NPP s2
 for P being (the Instructions of S)-valued ManySortedSet of NAT
 holds NPP Following(P,s1) = NPP Following(P,s2);


theorem :: AMISTD_2:68
 for S being Exec-preserving IC-Ins-separated definite realistic
  halting (non empty stored-program AMI-Struct over N)
 for s1,s2 being State of S
   st NPP s1 = NPP s2
 for P being (the Instructions of S)-valued ManySortedSet of NAT,
     k being Nat
 holds NPP Comput(P,s1,k) = NPP Comput(P,s2,k);


theorem :: AMISTD_2:69
 for S being Exec-preserving IC-Ins-separated definite realistic
  halting (non empty stored-program AMI-Struct over N)
 for s1,s2 being State of S
   st NPP s1 = NPP s2
 for P being (the Instructions of S)-valued ManySortedSet of NAT
 holds P halts_on s1 implies P halts_on s2;

theorem :: AMISTD_2:70
 for S being Exec-preserving IC-Ins-separated definite realistic
  halting (non empty stored-program AMI-Struct over N),
  P being (the Instructions of S)-valued ManySortedSet of NAT,
  s being State of S st NPP s = NPP Following(P,s)
  holds for n holds NPP Comput(P,s,n) = NPP s;

theorem :: AMISTD_2:71
 for S being Exec-preserving IC-Ins-separated definite realistic
  halting (non empty stored-program AMI-Struct over N)
 for s1,s2 being State of S
   st NPP s1 = NPP s2
 for P being (the Instructions of S)-valued ManySortedSet of NAT
   st P halts_on s1
 holds NPP Result(P,s1) = NPP Result(P,s2);
