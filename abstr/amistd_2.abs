:: On the Composition of Macro Instructions of Standard Computers
::  by Artur Korni{\l}owicz
::
:: Received April 14, 2000
:: Copyright (c) 2000 Association of Mizar Users

environ

 vocabularies AMI_3, ORDINAL2, ARYTM, AMI_1, RELAT_1, BOOLE, FUNCT_1, FUNCT_4,
      FINSET_1, TARSKI, CARD_1, ARYTM_1, FRAENKEL, SETFAM_1, CARD_3, PRALG_2,
      FINSEQ_2, FINSEQ_1, CAT_1, FUNCOP_1, GOBOARD5, WAYBEL_0, AMISTD_1,
      MCART_1, AMI_5, UNIALG_1, REALSET1, CARD_5, FRECHET, PRE_TOPC, RELOC,
      FUNCT_7, ORDINAL1, SQUARE_1, SCMFSA6A, AMISTD_2, MEMBERED, SCMNORM;
 notations TARSKI, XBOOLE_0, SUBSET_1, ORDINAL1, ZFMISC_1, MCART_1, SETFAM_1,
      MEMBERED, FINSET_1, RELAT_1, FUNCT_1, FUNCT_2, FRAENKEL, REALSET1,
      FUNCT_4, CARD_1, NUMBERS, XCMPLX_0, XXREAL_0, NAT_1, CARD_3, FINSEQ_1,
      FINSEQ_2, FUNCOP_1, BINARITH, FUNCT_7, XXREAL_2, STRUCT_0, AMI_1,
      AMISTD_1;
 constructors WELLORD2, XXREAL_0, NAT_1, REALSET1, BINARITH, PRE_CIRC, PRALG_2,
      AMISTD_1, INT_1, MEMBERED, XXREAL_2;
 registrations XBOOLE_0, SETFAM_1, RELAT_1, FUNCT_1, FUNCOP_1, FINSET_1,
      FRAENKEL, XXREAL_0, XREAL_0, NAT_1, MEMBERED, FINSEQ_1, FINSEQ_2, CARD_3,
      REALSET1, PRE_CIRC, FUNCT_7, STRUCT_0, AMI_1, AMISTD_1, CARD_1, FUNCT_4,
      XXREAL_2;
 requirements NUMERALS, BOOLE, SUBSET, REAL, ARITHM;


begin

reserve k, m for natural number,
  x, X for set,
  N for with_non-empty_elements set,
  IL for non empty set;

registration
  let D be set;
  cluster -> functional FinSequenceSet of D;
end;

registration
  let i be Element of NAT, D be set;
  cluster i-tuples_on D -> with_common_domain;
end;

registration
  let i be Element of NAT, D be set;
  cluster i-tuples_on D -> product-like;
end;

begin  :: Properties of AMI-Struct

canceled 10;

theorem :: AMISTD_2:11
  for IL,N being set, S being AMI-Struct over IL,N,
  F being FinPartState of S holds F \ X is FinPartState of S;

theorem :: AMISTD_2:12
  for S being IC-Ins-separated definite
  (non empty stored-program AMI-Struct over IL,N),
  F being programmed FinPartState of S
  holds F \ X is programmed FinPartState of S;

definition
  let IL be non empty set;
  canceled 2;
  let N be with_non-empty_elements set, S be IC-Ins-separated definite
  (non empty stored-program AMI-Struct over IL,N),
  i1, i2 be Instruction-Location of S,
  I1, I2 be Element of the Instructions of S;
  redefine func (i1,i2) --> (I1,I2) -> FinPartState of S;
end;

registration
  let IL be non empty set;
  let N be with_non-empty_elements set;
  let S be halting (stored-program AMI-Struct over IL,N);
  cluster halting Instruction of S;
end;

theorem :: AMISTD_2:13
  for S being standard (IC-Ins-separated definite
  (non empty stored-program AMI-Struct over NAT,N)),
  F being lower programmed FinPartState of S,
  G being programmed FinPartState of S st dom F = dom G holds G is lower;

theorem :: AMISTD_2:14
  for S being standard (IC-Ins-separated definite
  (non empty stored-program AMI-Struct over NAT,N)),
  F being lower programmed FinPartState of S,
  f being Instruction-Location of S st f in dom F holds locnum f < card F;

theorem :: AMISTD_2:15
  for S being standard (IC-Ins-separated definite
  (non empty stored-program AMI-Struct over NAT,N)),
  F being lower programmed FinPartState of S
  holds dom F = { il.(S,k) where k is Element of NAT: k < card F };

definition
  let IL,N be set;
  let S be AMI-Struct over IL,N;
  let I be Element of the Instructions of S;
  func AddressPart I equals
:: AMISTD_2:def 3

  I`2;
end;

definition
  let IL,N be set;
  let S be standard-ins AMI-Struct over IL,N;
  let I be Element of the Instructions of S;
  redefine func AddressPart I -> FinSequence of (union N) \/ the carrier of S;
end;

theorem :: AMISTD_2:16
  for N being set, S being standard-ins AMI-Struct over IL,N,
  I, J being Element of the Instructions of S holds
  InsCode I = InsCode J & AddressPart I = AddressPart J implies I = J;

definition
  let IL,N be set;
  let S be standard-ins AMI-Struct over IL,N;
  attr S is homogeneous means
:: AMISTD_2:def 4

  for I, J being Instruction of S st InsCode I = InsCode J holds
  dom AddressPart I = dom AddressPart J;
end;

theorem :: AMISTD_2:17
  for I being Instruction of STC N holds AddressPart I = 0;

definition
  let IL,N be set;
  let S be standard-ins AMI-Struct over IL,N;
  let T be InsType of S;
  func AddressParts T equals
:: AMISTD_2:def 5
  { AddressPart I where I is Instruction of S: InsCode I = T };
end;

registration
  let IL,N be set;
  let S be standard-ins AMI-Struct over IL,N;
  let T be InsType of S;
  cluster AddressParts T -> functional;
end;

definition
  let IL be non empty set;
  let N be with_non-empty_elements set,
  S be IC-Ins-separated definite standard-ins
  (non empty stored-program AMI-Struct over IL,N), I be Instruction of S;
  attr I is with_explicit_jumps means
:: AMISTD_2:def 6

  for f being set st f in JUMP I holds
  ex k being set st k in dom AddressPart I & f = (AddressPart I).k &
  (product" AddressParts InsCode I).k = IL;
  attr I is without_implicit_jumps means
:: AMISTD_2:def 7

  for f being set st
  ex k being set st k in dom AddressPart I & f = (AddressPart I).k &
  (product" AddressParts InsCode I).k = IL holds f in JUMP I;
end;

definition
  let IL be non empty set;
  let N be with_non-empty_elements set,
  S be standard-ins IC-Ins-separated definite
  (non empty stored-program AMI-Struct over IL,N);
  attr S is with_explicit_jumps means
:: AMISTD_2:def 8

  for I being Instruction of S holds I is with_explicit_jumps;
  attr S is without_implicit_jumps means
:: AMISTD_2:def 9

  for I being Instruction of S holds I is without_implicit_jumps;
end;

registration
  let N be with_non-empty_elements set;
  cluster standard -> (IC-Ins-separated definite
    (non empty stored-program AMI-Struct over NAT,N));
end;

registration
  let N be with_non-empty_elements set;
  cluster standard standard-ins (IC-Ins-separated definite
    (non empty stored-program AMI-Struct over NAT,N));
end;

theorem :: AMISTD_2:18
  for S being standard (IC-Ins-separated definite
  (non empty stored-program AMI-Struct over NAT,N)), I being Instruction of S
  st for f being Instruction-Location of S holds NIC(I,f)={NextLoc f}
  holds JUMP I is empty;

registration
  let N be with_non-empty_elements set, I be Instruction of STC N;
  cluster JUMP I -> empty;
end;

definition
  let IL,N be set;
  let S be standard-ins AMI-Struct over IL,N;
  canceled;
  attr S is regular means
:: AMISTD_2:def 11

  for T being InsType of S holds AddressParts T is product-like;
end;

registration
  let IL,N be set;
  cluster regular -> homogeneous (standard-ins AMI-Struct over IL,N);
end;

theorem :: AMISTD_2:19
  for T being InsType of STC N holds AddressParts T = {0};

registration
  let N be with_non-empty_elements set;
  cluster STC N -> with_explicit_jumps without_implicit_jumps regular;
end;

registration
  let N be with_non-empty_elements set;
  cluster standard regular halting realistic steady-programmed programmable
    with_explicit_jumps without_implicit_jumps
    (IC-Ins-separated definite standard-ins
    (non empty stored-program AMI-Struct over NAT,N));
end;

registration
  let IL be non empty set;
  let N be with_non-empty_elements set;
  cluster Trivial-AMI(IL,N) -> regular;
end;

registration
  let IL be non empty set;
  let N be with_non-empty_elements set;
  cluster regular (standard-ins AMI-Struct over IL,N);
end;

registration
  let IL be non empty set;
  let N be with_non-empty_elements set;
  let S be regular (standard-ins AMI-Struct over IL,N);
  let T be InsType of S;
  cluster AddressParts T -> product-like;
end;

registration
  let IL be non empty set;
  let N be with_non-empty_elements set;
  let S be homogeneous (standard-ins AMI-Struct over IL,N);
  let T be InsType of S;
  cluster AddressParts T -> with_common_domain;
end;

registration
  let IL be non trivial set;
  let N be with_non-empty_elements set, I be Instruction of Trivial-AMI(IL,N);
  cluster JUMP I -> empty;
end;

registration
  let IL be non trivial set;
  let N be with_non-empty_elements set;
  cluster Trivial-AMI(IL,N)
    -> with_explicit_jumps without_implicit_jumps regular;
end;

registration
  let IL be non trivial set, N;
  cluster regular
    (non empty stored-program standard-ins AMI-Struct over IL,N);
end;

theorem :: AMISTD_2:20
  for IL being non trivial set for S being homogeneous
  (non empty stored-program standard-ins AMI-Struct over IL,N),
  I being Instruction of S, x being set st x in dom AddressPart I holds
  (product" AddressParts InsCode I).x = IL implies
  (AddressPart I).x is Instruction-Location of S;

registration
  let IL be non empty set;
  let N be with_non-empty_elements set;
  cluster Trivial-AMI(IL,N) -> halting;
end;

registration
  let IL be non trivial set;
  let N be with_non-empty_elements set;
  cluster without_implicit_jumps with_explicit_jumps halting realistic
    (standard-ins IC-Ins-separated definite
    (non empty stored-program AMI-Struct over IL,N));
end;

registration
  let IL be non trivial set;
  let N be with_non-empty_elements set;
  let S be with_explicit_jumps (IC-Ins-separated
  definite (non empty stored-program standard-ins AMI-Struct over IL,N));
  cluster -> with_explicit_jumps Instruction of S;
end;

registration
  let IL be non trivial set;
  let N be with_non-empty_elements set;
  let S be without_implicit_jumps (standard-ins IC-Ins-separated definite
  (non empty stored-program AMI-Struct over IL,N));
  cluster -> without_implicit_jumps Instruction of S;
end;

theorem :: AMISTD_2:21
  for IL being non trivial set for S being realistic IC-Ins-separated definite
  (non empty stored-program AMI-Struct over IL,N),
  I being Instruction of S st I is halting holds JUMP I is empty;

registration
  let IL be non trivial set;
  let N be with_non-empty_elements set, S be halting realistic
  (IC-Ins-separated definite (non empty stored-program AMI-Struct over IL,N)),
  I be halting Instruction of S;
  cluster JUMP I -> empty;
end;

registration
  let IL be non trivial set;
  let N be with_non-empty_elements set, S be IC-Ins-separated definite
  (non empty stored-program AMI-Struct over IL,N);
  cluster non trivial programmed FinPartState of S;
end;

registration
  let N be with_non-empty_elements set,
  S be standard halting (IC-Ins-separated definite
  (non empty stored-program AMI-Struct over NAT,N));
  cluster trivial -> unique-halt (non empty programmed FinPartState of S);
end;

definition
  let IL,N be set;
  let S be standard-ins AMI-Struct over IL,N;
  let I be Instruction of S;
  attr I is ins-loc-free means
:: AMISTD_2:def 12

  for x being set st x in dom AddressPart I
  holds (product" AddressParts InsCode I).x <> IL;
end;

theorem :: AMISTD_2:22
  for IL being non trivial set for S being halting with_explicit_jumps
  realistic (IC-Ins-separated definite
  (standard-ins non empty stored-program AMI-Struct over IL,N)),
  I being Instruction of S st I is ins-loc-free holds JUMP I is empty;

theorem :: AMISTD_2:23
  for IL being non trivial set for S being without_implicit_jumps
  realistic (standard-ins IC-Ins-separated definite
  (non empty stored-program AMI-Struct over IL,N)),
  I being Instruction of S st I is halting holds I is ins-loc-free;

registration
  let IL be non trivial set;
  let N be with_non-empty_elements set, S be without_implicit_jumps
  realistic (standard-ins IC-Ins-separated definite
  (non empty stored-program AMI-Struct over IL,N));
  cluster halting -> ins-loc-free Instruction of S;
end;

theorem :: AMISTD_2:24
  for S being standard without_implicit_jumps standard-ins
  (IC-Ins-separated definite
  (standard-ins non empty stored-program AMI-Struct over NAT,N)),
  I being Instruction of S st I is sequential holds I is ins-loc-free;

registration
  let N be with_non-empty_elements set,
  S be standard without_implicit_jumps standard-ins (IC-Ins-separated definite
  (standard-ins non empty stored-program AMI-Struct over NAT,N));
  cluster sequential -> ins-loc-free Instruction of S;
end;

definition
  let N be with_non-empty_elements set, S be standard halting
  (IC-Ins-separated definite
  (non empty stored-program AMI-Struct over NAT,N));
  func Stop S -> FinPartState of S equals
:: AMISTD_2:def 13

  il.(S,0) .--> halt S;
end;

registration
  let N be with_non-empty_elements set, S be standard halting
  (IC-Ins-separated definite
  (non empty stored-program AMI-Struct over NAT,N));
  cluster Stop S -> lower non empty programmed trivial;
end;

registration
  let N be with_non-empty_elements set, S be standard realistic halting
  (IC-Ins-separated definite
  (non empty stored-program AMI-Struct over NAT,N));
  cluster Stop S -> closed;
end;

registration
  let N be with_non-empty_elements set,
  S be standard halting steady-programmed (IC-Ins-separated definite
  (non empty stored-program AMI-Struct over NAT,N));
  cluster Stop S -> autonomic;
end;

theorem :: AMISTD_2:25
  for S being standard halting (IC-Ins-separated definite
  (non empty stored-program AMI-Struct over NAT,N)) holds card Stop S = 1;

theorem :: AMISTD_2:26
  for S being standard halting (IC-Ins-separated definite
  (non empty stored-program AMI-Struct over NAT,N)),
  F being pre-Macro of S st card F = 1 holds F = Stop S;

theorem :: AMISTD_2:27
  for S being standard halting (IC-Ins-separated definite
  (non empty stored-program AMI-Struct over NAT,N))
  holds LastLoc Stop S = il.(S,0);

registration
  let N be with_non-empty_elements set,
  S be standard halting (IC-Ins-separated definite
  (non empty stored-program AMI-Struct over NAT,N));
  cluster Stop S -> halt-ending unique-halt;
end;

definition
  let N be with_non-empty_elements set,
  S be standard halting (IC-Ins-separated definite
  (non empty stored-program AMI-Struct over NAT,N));
  redefine func Stop S -> pre-Macro of S;
end;

begin  :: On the composition of macro instructions

definition
  let N be with_non-empty_elements set;
  let S be regular standard (standard-ins IC-Ins-separated definite
  (non empty stored-program AMI-Struct over NAT,N));
  let I be Element of the Instructions of S;
  let k be natural number;
  func IncAddr(I,k) -> Instruction of S means
:: AMISTD_2:def 14

  InsCode it = InsCode I &
  dom AddressPart it = dom AddressPart I &
  for n being set st n in dom AddressPart I holds
  ((product" AddressParts InsCode I).n = NAT implies
  ex f being Instruction-Location of S st
  f = (AddressPart I).n & (AddressPart it).n = il.(S,k + locnum f)) &
  ((product" AddressParts InsCode I).n <> NAT implies
  (AddressPart it).n = (AddressPart I).n);
end;

theorem :: AMISTD_2:28
  for S being regular standard (standard-ins IC-Ins-separated definite
  (non empty stored-program AMI-Struct over NAT,N)),
  I being Element of the Instructions of S holds IncAddr(I, 0) = I;

theorem :: AMISTD_2:29
  for S being regular standard (standard-ins IC-Ins-separated definite
  (non empty stored-program AMI-Struct over NAT,N)),
  I being Instruction of S st I is ins-loc-free holds IncAddr(I, k) = I;

theorem :: AMISTD_2:30
  for S being halting standard without_implicit_jumps realistic
  regular (standard-ins IC-Ins-separated definite
  (non empty stored-program AMI-Struct over NAT,N))
  holds IncAddr(halt S, k) = halt S;

registration
  let N be with_non-empty_elements set,
  S be halting standard without_implicit_jumps
  realistic regular (standard-ins IC-Ins-separated definite
  (non empty stored-program AMI-Struct over NAT,N)),
  I be halting Instruction of S, k be natural number;
  cluster IncAddr(I,k) -> halting;
end;

theorem :: AMISTD_2:31
  for S being regular standard (standard-ins IC-Ins-separated definite
  (non empty stored-program AMI-Struct over NAT,N)), I being Instruction of S
  holds AddressParts InsCode I = AddressParts InsCode IncAddr(I,k);

theorem :: AMISTD_2:32
  for S being regular standard (standard-ins IC-Ins-separated definite
  (non empty stored-program AMI-Struct over NAT,N)),
  I, J being Instruction of S st
  (ex k being natural number st IncAddr(I,k) = IncAddr(J,k)) holds
  (product" AddressParts InsCode I).x = NAT implies
  (product" AddressParts InsCode J).x = NAT;

theorem :: AMISTD_2:33
  for S being regular standard (standard-ins IC-Ins-separated definite
  (non empty stored-program AMI-Struct over NAT,N)),
  I, J being Instruction of S st
  (ex k being natural number st IncAddr(I,k) = IncAddr(J,k)) holds
  (product" AddressParts InsCode I).x <> NAT implies
  (product" AddressParts InsCode J).x <> NAT;

theorem :: AMISTD_2:34
  for S being regular standard (standard-ins IC-Ins-separated definite
  (non empty stored-program AMI-Struct over NAT,N)),
  I, J being Instruction of S st
  ex k being natural number st IncAddr(I,k) = IncAddr(J,k) holds I = J;

theorem :: AMISTD_2:35
  for S being regular standard halting without_implicit_jumps
  realistic (standard-ins IC-Ins-separated definite
  (non empty stored-program AMI-Struct over NAT,N)),
  I being Instruction of S st IncAddr(I,k) = halt S holds I = halt S;

theorem :: AMISTD_2:36
  for S being regular standard halting without_implicit_jumps
  realistic (standard-ins IC-Ins-separated definite
  (non empty stored-program AMI-Struct over NAT,N)),
  I being Instruction of S st I is sequential
  holds IncAddr(I,k) is sequential;

theorem :: AMISTD_2:37
  for S being regular standard (standard-ins IC-Ins-separated definite
  (non empty stored-program AMI-Struct over NAT,N)), I being Instruction of S
  holds IncAddr(IncAddr(I,k),m) = IncAddr(I,k+m);

definition
  let N be with_non-empty_elements set,
  S be regular standard (standard-ins IC-Ins-separated definite
  (non empty stored-program AMI-Struct over NAT,N)),
  p be programmed FinPartState of S, k be natural number;
  func IncAddr(p,k) -> FinPartState of S means
:: AMISTD_2:def 15

  dom it = dom p &
  for m being natural number st il.(S,m) in dom p holds
  it.il.(S,m) = IncAddr(pi(p,il.(S,m)),k);
end;

registration
  let N be with_non-empty_elements set,
  S be regular standard (standard-ins IC-Ins-separated definite
  (non empty stored-program AMI-Struct over NAT,N)),
  F be programmed FinPartState of S, k be natural number;
  cluster IncAddr(F,k) -> programmed;
end;

registration
  let N be with_non-empty_elements set,
  S be regular standard (standard-ins IC-Ins-separated definite
  (non empty stored-program AMI-Struct over NAT,N)),
  F be empty programmed FinPartState of S, k be natural number;
  cluster IncAddr(F,k) -> empty;
end;

registration
  let N be with_non-empty_elements set,
  S be regular standard (standard-ins IC-Ins-separated definite
  (non empty stored-program AMI-Struct over NAT,N)),
  F be non empty programmed FinPartState of S, k be natural number;
  cluster IncAddr(F,k) -> non empty;
end;

registration
  let N be with_non-empty_elements set,
  S be regular standard (standard-ins IC-Ins-separated definite
  (non empty stored-program AMI-Struct over NAT,N)),
  F be lower programmed FinPartState of S, k be natural number;
  cluster IncAddr(F,k) -> lower;
end;

theorem :: AMISTD_2:38
  for S being regular standard (standard-ins IC-Ins-separated definite
  (non empty stored-program AMI-Struct over NAT,N)),
  F being programmed FinPartState of S holds IncAddr(F,0) = F;

theorem :: AMISTD_2:39
  for S being regular standard (standard-ins IC-Ins-separated definite
  (non empty stored-program AMI-Struct over NAT,N)),
  F being lower programmed FinPartState of S
  holds IncAddr(IncAddr(F,k),m) = IncAddr(F,k+m);

definition
  let N be with_non-empty_elements set,
  S be standard (IC-Ins-separated definite
  (non empty stored-program AMI-Struct over NAT,N)), p be FinPartState of S,
  k be natural number;
  func Shift(p,k) -> FinPartState of S means
:: AMISTD_2:def 16

  dom it = { il.(S,m+k) where m is Element of NAT: il.(S,m) in dom p } &
  for m being Element of NAT st il.(S,m) in dom p
  holds it.il.(S,m+k) = p.il.(S,m);
end;

registration
  let N be with_non-empty_elements set,
  S be standard (IC-Ins-separated definite
  (non empty stored-program AMI-Struct over NAT,N)), F be FinPartState of S,
  k be natural number;
  cluster Shift(F,k) -> programmed;
end;

registration
  let N be with_non-empty_elements set,
  S be standard (IC-Ins-separated definite
  (non empty stored-program AMI-Struct over NAT,N)),
  F be empty FinPartState of S, k be natural number;
  cluster Shift(F,k) -> empty;
end;

registration
  let N be with_non-empty_elements set,
  S be standard (IC-Ins-separated definite
  (non empty stored-program AMI-Struct over NAT,N)),
  F be non empty programmed FinPartState of S, k be natural number;
  cluster Shift(F,k) -> non empty;
end;

theorem :: AMISTD_2:40
  for S being standard (IC-Ins-separated definite
  (non empty stored-program AMI-Struct over NAT,N)),
  F being programmed FinPartState of S holds Shift(F,0) = F;

theorem :: AMISTD_2:41
  for S being standard (IC-Ins-separated definite
  (non empty stored-program AMI-Struct over NAT,N)),
  F being FinPartState of S, k being natural number st k > 0
  holds not il.(S,0) in dom Shift(F,k);

theorem :: AMISTD_2:42
  for S being standard (IC-Ins-separated definite
  (non empty stored-program AMI-Struct over NAT,N)), F being FinPartState of S
  holds Shift(Shift(F,m),k) = Shift(F,m+k);

theorem :: AMISTD_2:43
  for S being standard (IC-Ins-separated definite
  (non empty stored-program AMI-Struct over NAT,N)),
  F being programmed FinPartState of S
  holds dom F,dom Shift(F,k) are_equipotent;

definition
  let N be with_non-empty_elements set,
  S be regular standard (standard-ins IC-Ins-separated definite
  (non empty stored-program AMI-Struct over NAT,N)), I be Instruction of S;
  attr I is IC-good means
:: AMISTD_2:def 17

  for k being natural number,
  s1, s2 being State of S st s2 = s1 +* (IC S .--> (IC s1 + k))
  holds IC Exec(I,s1) + k = IC Exec(IncAddr(I,k), s2);
end;

definition
  let N be with_non-empty_elements set,
  S be regular standard (standard-ins IC-Ins-separated definite
  (non empty stored-program AMI-Struct over NAT,N));
  attr S is IC-good means
:: AMISTD_2:def 18

  for I being Instruction of S holds I is IC-good;
end;

definition
  let IL;
  let N be with_non-empty_elements set,
  S be stored-program AMI-Struct over IL,N, I be Instruction of S;
  attr I is Exec-preserving means
:: AMISTD_2:def 19

  for s1, s2 being State of S
  st s1, s2 equal_outside IL holds Exec(I,s1), Exec(I,s2) equal_outside IL;
end;

definition
  let IL;
  let N be with_non-empty_elements set,
  S be stored-program AMI-Struct over IL,N;
  attr S is Exec-preserving means
:: AMISTD_2:def 20

  for I being Instruction of S holds I is Exec-preserving;
end;

theorem :: AMISTD_2:44
  for S being regular standard without_implicit_jumps
  (standard-ins IC-Ins-separated definite
  (non empty stored-program AMI-Struct over NAT,N)),
  I being Instruction of S st I is sequential holds I is IC-good;

registration
  let N be with_non-empty_elements set,
  S be regular standard without_implicit_jumps
  (standard-ins IC-Ins-separated definite
  (non empty stored-program AMI-Struct over NAT,N));
  cluster sequential -> IC-good Instruction of S;
end;

theorem :: AMISTD_2:45
  for S being regular standard without_implicit_jumps realistic
  (standard-ins IC-Ins-separated definite
  (non empty stored-program AMI-Struct over NAT,N)),
  I being Instruction of S st I is halting holds I is IC-good;

registration
  let N be with_non-empty_elements set,
  S be regular standard without_implicit_jumps realistic
  (standard-ins IC-Ins-separated definite
  (non empty stored-program AMI-Struct over NAT,N));
  cluster halting -> IC-good Instruction of S;
end;

theorem :: AMISTD_2:46
  for S being stored-program AMI-Struct over IL,N,
  I being Instruction of S st I is halting holds I is Exec-preserving;

registration
  let IL;
  let N be with_non-empty_elements set,
  S be stored-program AMI-Struct over IL,N;
  cluster halting -> Exec-preserving Instruction of S;
end;

registration
  let N be with_non-empty_elements set;
  cluster STC N -> IC-good Exec-preserving;
end;

registration
  let N be with_non-empty_elements set;
  cluster halting realistic steady-programmed programmable
    with_explicit_jumps without_implicit_jumps IC-good Exec-preserving
    (regular standard (standard-ins IC-Ins-separated definite
    (non empty stored-program AMI-Struct over NAT,N)));
end;

registration
  let IL;
  let N be with_non-empty_elements set;
  cluster regular (standard-ins IC-Ins-separated definite
    (non empty stored-program AMI-Struct over IL,N));
end;

registration
  let IL be non empty set;
  let N be with_non-empty_elements set;
  cluster Trivial-AMI(IL,N) -> Exec-preserving;
end;

registration
  let IL be non trivial set;
  let N be with_non-empty_elements set;
  cluster halting realistic steady-programmed programmable
    with_explicit_jumps without_implicit_jumps Exec-preserving
    (regular (standard-ins IC-Ins-separated definite
    (non empty stored-program AMI-Struct over IL,N)));
end;

registration
  let N be with_non-empty_elements set, S be IC-good (regular standard
  (standard-ins IC-Ins-separated definite
  (non empty stored-program AMI-Struct over NAT,N)));
  cluster -> IC-good Instruction of S;
end;

registration
  let IL be non trivial set;
  let N be with_non-empty_elements set,
  S be Exec-preserving (stored-program AMI-Struct over IL,N);
  cluster -> Exec-preserving Instruction of S;
end;

definition
  let N be with_non-empty_elements set;
  let S be standard (IC-Ins-separated definite
  (non empty stored-program AMI-Struct over NAT,N));
  let F be non empty programmed FinPartState of S;
  func CutLastLoc F -> FinPartState of S equals
:: AMISTD_2:def 21
  F \ ( LastLoc F .--> F.LastLoc F );
end;

theorem :: AMISTD_2:47
  for S being standard (IC-Ins-separated definite
  (non empty stored-program AMI-Struct over NAT,N)),
  F being non empty programmed FinPartState of S
  holds dom CutLastLoc F = (dom F) \ {LastLoc F};

theorem :: AMISTD_2:48
  for S being standard (IC-Ins-separated definite
  (non empty stored-program AMI-Struct over NAT,N)),
  F being non empty programmed FinPartState of S
  holds dom F = dom CutLastLoc F \/ {LastLoc F};

registration
  let N be with_non-empty_elements set;
  let S be standard (IC-Ins-separated definite
  (non empty stored-program AMI-Struct over NAT,N));
  let F be non empty trivial programmed FinPartState of S;
  cluster CutLastLoc F -> empty;
end;

registration
  let N be with_non-empty_elements set;
  let S be standard (IC-Ins-separated definite
  (non empty stored-program AMI-Struct over NAT,N));
  let F be non empty programmed FinPartState of S;
  cluster CutLastLoc F -> programmed;
end;

registration
  let N be with_non-empty_elements set;
  let S be standard (IC-Ins-separated definite
  (non empty stored-program AMI-Struct over NAT,N));
  let F be lower non empty programmed FinPartState of S;
  cluster CutLastLoc F -> lower;
end;

theorem :: AMISTD_2:49
  for S being standard (IC-Ins-separated definite
  (non empty stored-program AMI-Struct over NAT,N)),
  F being non empty programmed FinPartState of S
  holds card CutLastLoc F = card F - 1;

theorem :: AMISTD_2:50
  for S being regular standard (standard-ins IC-Ins-separated definite
  (non empty stored-program AMI-Struct over NAT,N)),
  F being lower non empty programmed FinPartState of S,
  G being non empty programmed FinPartState of S
  holds dom CutLastLoc F misses dom Shift(IncAddr(G,card F -' 1),card F -' 1);

theorem :: AMISTD_2:51
  for S being standard halting (IC-Ins-separated definite
  (non empty stored-program AMI-Struct over NAT,N)),
  F being unique-halt (lower non empty programmed FinPartState of S),
  I being Instruction-Location of S st I in dom CutLastLoc F
  holds (CutLastLoc F).I <> halt S;

definition
  let N be with_non-empty_elements set,
  S be regular standard (standard-ins IC-Ins-separated definite
  (non empty stored-program AMI-Struct over NAT,N)),
  F, G be non empty programmed FinPartState of S;
  func F ';' G -> FinPartState of S equals
:: AMISTD_2:def 22
  CutLastLoc F +* Shift(IncAddr(G,card F -' 1),card F -' 1);
end;

registration
  let N be with_non-empty_elements set,
  S be regular standard (standard-ins IC-Ins-separated definite
  (non empty stored-program AMI-Struct over NAT,N)),
  F, G be non empty programmed FinPartState of S;
  cluster F ';' G -> non empty programmed;
end;

theorem :: AMISTD_2:52
  for S being regular standard (standard-ins IC-Ins-separated definite
  (non empty stored-program AMI-Struct over NAT,N)),
  F being lower non empty programmed FinPartState of S,
  G being non empty programmed FinPartState of S
  holds card (F ';' G) = card F + card G - 1 &
  card (F ';' G) = card F + card G -' 1;

registration
  let N be with_non-empty_elements set;
  let S be regular standard (standard-ins IC-Ins-separated definite
  (non empty stored-program AMI-Struct over NAT,N));
  let F, G be lower non empty programmed FinPartState of S;
  cluster F ';' G -> lower;
end;

theorem :: AMISTD_2:53
  for S being regular standard (standard-ins IC-Ins-separated definite
  (non empty stored-program AMI-Struct over NAT,N)),
  F, G being lower non empty programmed FinPartState of S
  holds dom F c= dom (F ';' G);

theorem :: AMISTD_2:54
  for S being regular standard (standard-ins IC-Ins-separated definite
  (non empty stored-program AMI-Struct over NAT,N)),
  F, G being lower non empty programmed FinPartState of S
  holds CutLastLoc F c= CutLastLoc (F ';' G);

theorem :: AMISTD_2:55
  for S being regular standard (standard-ins IC-Ins-separated definite
  (non empty stored-program AMI-Struct over NAT,N)),
  F, G being lower non empty programmed FinPartState of S
  holds (F ';' G).LastLoc F = IncAddr(G,card F -' 1).il.(S,0);

theorem :: AMISTD_2:56
  for S being regular standard (standard-ins IC-Ins-separated definite
  (non empty stored-program AMI-Struct over NAT,N)),
  F, G being lower non empty programmed FinPartState of S,
  f being Instruction-Location of S st locnum f < card F - 1
  holds IncAddr(F,card F -' 1).f = IncAddr(F ';' G, card F -' 1).f;

registration
  let N be with_non-empty_elements set;
  let S be regular standard realistic halting steady-programmed
  without_implicit_jumps (standard-ins IC-Ins-separated definite
  (non empty stored-program AMI-Struct over NAT,N));
  let F be lower non empty programmed FinPartState of S;
  let G be halt-ending (lower non empty programmed FinPartState of S);
  cluster F ';' G -> halt-ending;
end;

registration
  let N be with_non-empty_elements set;
  let S be regular standard realistic halting steady-programmed
  without_implicit_jumps (standard-ins IC-Ins-separated definite
  (non empty stored-program AMI-Struct over NAT,N));
  let F, G be halt-ending unique-halt
  (lower non empty programmed FinPartState of S);
  cluster F ';' G -> unique-halt;
end;

definition
  let N be with_non-empty_elements set;
  let S be regular standard realistic halting steady-programmed
  without_implicit_jumps (standard-ins IC-Ins-separated definite
  (non empty stored-program AMI-Struct over NAT,N));
  let F, G be pre-Macro of S;
  redefine func F ';' G -> pre-Macro of S;
end;

registration
  let N be with_non-empty_elements set,
  S be realistic halting steady-programmed IC-good Exec-preserving
  (regular standard (standard-ins IC-Ins-separated definite
  (non empty stored-program AMI-Struct over NAT,N))),
  F, G be closed lower non empty (programmed FinPartState of S);
  cluster F ';' G -> closed;
end;

theorem :: AMISTD_2:57
  for S being regular standard halting without_implicit_jumps
  realistic (standard-ins IC-Ins-separated definite
  (non empty stored-program AMI-Struct over NAT,N))
  holds IncAddr(Stop S, k) = Stop S;

theorem :: AMISTD_2:58
  for S being standard halting (IC-Ins-separated definite
  (non empty stored-program AMI-Struct over NAT,N))
  holds Shift(Stop S, k) = il.(S,k) .--> halt S;

theorem :: AMISTD_2:59
  for S being regular standard halting without_implicit_jumps
  realistic (standard-ins IC-Ins-separated definite
  (non empty stored-program AMI-Struct over NAT,N)), F being pre-Macro of S
  holds F ';' Stop S = F;

theorem :: AMISTD_2:60
  for S being regular standard halting (standard-ins IC-Ins-separated definite
  (non empty stored-program AMI-Struct over NAT,N)), F being pre-Macro of S
  holds Stop S ';' F = F;

theorem :: AMISTD_2:61
  for S being regular standard realistic halting steady-programmed
  without_implicit_jumps (standard-ins IC-Ins-separated
  definite (non empty stored-program AMI-Struct over NAT,N)),
  F, G, H being pre-Macro of S holds F ';' G ';' H = F ';' (G ';' H);

theorem :: AMISTD_2:62
  for S being regular
  (standard-ins non empty stored-program AMI-Struct over IL,N),
  I being Instruction of S, x being set st x in dom AddressPart I holds
  (AddressPart I).x in (product" AddressParts InsCode I).x;

theorem :: AMISTD_2:63
  for I being Instruction of Trivial-AMI(IL,N) holds AddressPart I = 0;

theorem :: AMISTD_2:64
  for T being InsType of Trivial-AMI(IL,N) holds AddressParts T = {0};

begin :: Addenda

:: from SCMRING4, 2008.03.13, A.T.

reserve i, j, k for natural number,
  n for Element of NAT,
  IL for non empty set,
  N for with_non-empty_elements set,
  S for standard (IC-Ins-separated definite
  (non empty stored-program AMI-Struct over NAT,N)),
  l for Instruction-Location of S,
  f for FinPartState of S;

theorem :: AMISTD_2:65
  l in dom f implies Shift(f,k).(l + k) = f.l;

theorem :: AMISTD_2:66
  dom Shift(f,k) = { il+k where il is Instruction-Location of S: il in dom f};

theorem :: AMISTD_2:67
  for S being Exec-preserving IC-Ins-separated definite realistic
  steady-programmed (non empty stored-program AMI-Struct over NAT,N),
  s being State of S, i being Instruction of S,
  p being programmed FinPartState of S
  holds Exec (i, s +* p) = Exec (i,s) +* p;

definition
  let N be with_non-empty_elements set,
  S be regular standard (IC-Ins-separated definite
  (standard-ins non empty stored-program AMI-Struct over NAT,N)),
  k be natural number, p be FinPartState of S;
  func Relocated (p,k) -> FinPartState of S equals
:: AMISTD_2:def 23
  Start-At ((IC p)+k) +* IncAddr(Shift(ProgramPart(p),k),k) +* DataPart p;
end;

reserve S for regular standard (IC-Ins-separated definite
  (standard-ins non empty stored-program AMI-Struct over NAT,N)),
  g for FinPartState of S,
  il for Instruction-Location of S;

theorem :: AMISTD_2:68
  DataPart(Relocated(g,k)) = DataPart(g);

theorem :: AMISTD_2:69
  S is realistic implies
  ProgramPart(Relocated(g,k)) = IncAddr(Shift(ProgramPart(g),k),k);

theorem :: AMISTD_2:70
  S is realistic implies dom ProgramPart(Relocated(g,k))
  = { il.(S,j+k) where j is Element of NAT : il.(S,j) in dom ProgramPart(g) };

theorem :: AMISTD_2:71
  S is realistic implies (il in dom g iff il+k in dom Relocated(g,k));

theorem :: AMISTD_2:72
  IC S in dom Relocated (g,k);

theorem :: AMISTD_2:73
  S is realistic implies IC Relocated (g,k) = (IC g) + k;

theorem :: AMISTD_2:74
  for p being programmed FinPartState of S,
  l being Element of NAT st l in dom p holds
  IncAddr(p,k).l = IncAddr(pi(p,l),k);

registration let N be set, S be AMI-Struct over NAT,N;
 cluster -> natural Instruction-Location of S;
end;

theorem :: AMISTD_2:75
  for p being programmed FinPartState of S holds
  Shift(IncAddr(p,i),i) = IncAddr(Shift(p,i),i);

theorem :: AMISTD_2:76
  S is realistic implies
   for I being Instruction of S holds
  il in dom ProgramPart g & I = g.il implies
  IncAddr(I, k) = (Relocated (g, k)).(il + k);

theorem :: AMISTD_2:77
  S is realistic implies Start-At (IC g + k) c= Relocated (g,k);

theorem :: AMISTD_2:78
  for q being data-only FinPartState of S st IC S in dom g holds
  Relocated((g +* q), k) = Relocated (g,k) +* q;

