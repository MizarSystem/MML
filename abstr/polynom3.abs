:: The Ring of Polynomials
::  by Robert Milewski
::
:: Received April 17, 2000
:: Copyright (c) 2000 Association of Mizar Users

environ

 vocabulary RLVECT_1, FINSEQ_1, RELAT_1, FUNCT_1, FINSEQ_5, BOOLE, MATRIX_2,
      FINSEQ_2, MATRLIN, MEASURE6, SQUARE_1, ORDERS_1, RELAT_2, ORDERS_2,
      FINSET_1, TRIANG_1, ARYTM_1, CARD_1, VECTSP_1, NORMSP_1, FUNCT_2,
      POLYNOM1, ALGSEQ_1, FUNCOP_1, FUNCT_4, ARYTM_3, LATTICES, ALGSTR_2,
      GROUP_1, BINOP_1, DTCONSTR, RFINSEQ, POLYNOM3, FINSEQ_4, PARTFUN1;
 notation TARSKI, XBOOLE_0, ZFMISC_1, SUBSET_1, NUMBERS, XCMPLX_0, XREAL_0,
      SQUARE_1, STRUCT_0, NAT_1, RELAT_1, RELAT_2, RELSET_1, CARD_1, FINSET_1,
      FUNCT_1, PARTFUN1, FUNCT_2, ORDERS_1, ORDERS_2, TRIANG_1, FINSEQ_1,
      FINSEQ_2, FINSEQ_4, FINSEQ_5, FINSOP_1, FINSEQOP, TOPREAL1, RFINSEQ,
      BINOP_1, RVSUM_1, FVSUM_1, GOBOARD1, TREES_4, WSIERP_1, MATRLIN,
      BINARITH, GROUP_1, DTCONSTR, RLVECT_1, VECTSP_1, NORMSP_1, POLYNOM1,
      ALGSEQ_1;
 constructors SQUARE_1, REAL_1, MONOID_0, DOMAIN_1, ORDERS_2, TRIANG_1,
      FINSEQOP, ALGSTR_2, FINSEQ_5, FINSOP_1, RFINSEQ, BINARITH, ALGSEQ_1,
      SETWOP_2, FVSUM_1, TOPREAL1, POLYNOM1, GOBOARD1, WSIERP_1, MEMBERED;
 clusters XREAL_0, SUBSET_1, FINSEQ_1, STRUCT_0, RELSET_1, VECTSP_1, BINARITH,
      FINSEQ_2, FINSEQ_5, INT_1, GROUP_2, POLYNOM1, GOBRD13, FUNCT_2, MEMBERED,
      ORDINAL2;
 requirements NUMERALS, BOOLE, SUBSET, REAL, ARITHM;


begin  :: Preliminaries

  theorem :: POLYNOM3:1
   for L be add-associative right_zeroed right_complementable
    (non empty LoopStr)
   for p be FinSequence of the carrier of L st
    for i be Nat st i in dom p holds p.i = 0.L holds
     Sum p = 0.L;

  theorem :: POLYNOM3:2
   for V be Abelian add-associative right_zeroed (non empty LoopStr)
   for p be FinSequence of the carrier of V holds
    Sum p = Sum Rev p;

  theorem :: POLYNOM3:3
   for p be FinSequence of REAL holds
    Sum p = Sum Rev p;

  theorem :: POLYNOM3:4
   for p be FinSequence of NAT
   for i be Nat st i in dom p holds
    Sum p >= p.i;

  definition
   let D be non empty set;
   let i be Nat;
   let p be FinSequence of D;
   redefine func Del(p,i) -> FinSequence of D;
  end;


  definition
   let D be non empty set;
   let a,b be Element of D;
   redefine func <*a,b*> -> Element of 2-tuples_on D;
  end;


  definition
   let D be non empty set;
   let k,n be Nat;
   let p be Element of k-tuples_on D;
   let q be Element of n-tuples_on D;
   redefine func p^q -> Element of (k+n)-tuples_on D;
  end;


  registration
   let D be non empty set;
   let n be Nat;
   cluster -> FinSequence-yielding FinSequence of n-tuples_on D;
   coherence
   proof
    let p be FinSequence of n-tuples_on D;
    let x be set;
    assume A1: x in dom p;
    then x in Seg len p by FINSEQ_1:def 3;
    then reconsider i=x as Nat;
      p.i is Element of n-tuples_on D by A1,FINSEQ_2:13;
    hence thesis;
   end;
  end;


  definition
   let D be non empty set;
   let k,n be Nat;
   let p be FinSequence of (k-tuples_on D);
   let q be FinSequence of (n-tuples_on D);
   redefine func p ^^ q -> Element of ((k+n)-tuples_on D)*;
  end;


  scheme :: POLYNOM3:sch 1
 SeqOfSeqLambdaD{D()->non empty set,A()->Nat,T(Nat)->Nat,
                         F(set,set)->Element of D()}:
   ex p be FinSequence of D()* st
    len p = A() &
    for k be Nat st k in Seg A() holds
     len (p/.k) = T(k) &
     for n be Nat st n in dom (p/.k) holds
      (p/.k).n = F(k,n)
proof
    defpred P[Nat,Element of D()*] means len $2 = T($1) &
     for n be Nat st n in dom $2 holds $2.n = F($1,n);
    A1: for k be Nat st k in Seg A() ex d be Element of D()* st P[k,d]
    proof
     let k be Nat;
     assume k in Seg A();
     deffunc G(Nat) = F(k,$1);
     consider d be FinSequence of D() such that
      A2: len d = T(k) and
      A3: for n be Nat st n in Seg T(k) holds d.n = G(n) from FINSEQ_2:sch 1;
     reconsider d as Element of D()* by FINSEQ_1:def 11;
     take d;
     thus len d = T(k) by A2;
     let n be Nat;
     assume n in dom d;
     then n in Seg T(k) by A2,FINSEQ_1:def 3;
     hence d.n = F(k,n) by A3;
    end;
    consider p be FinSequence of D()* such that
     A4: dom p = Seg A() and
     A5: for k be Nat st k in Seg A() holds P[k,p/.k] from POLYNOM2:sch 1(A1);
    take p;
    thus len p = A() by A4,FINSEQ_1:def 3;
    let k be Nat;
    assume k in Seg A();
    hence thesis by A5;
   end;

begin  :: The Lexicographic Order of Finite Sequences

  definition
   let n be Nat;
   let p,q be Element of n-tuples_on NAT;
   pred p < q means
:: POLYNOM3:def 1
    ex i be Nat st i in Seg n & p.i < q.i &
     for k be Nat st 1 <= k & k < i holds p.k = q.k;
   asymmetry;
   end;
notation
   let n be Nat;
   let p,q be Element of n-tuples_on NAT;
   synonym q > p for p < q ; end;


  definition
   let n be Nat;
   let p,q be Element of n-tuples_on NAT;
   pred p <= q means
:: POLYNOM3:def 2
    p < q or p = q;
   reflexivity;
   end;
notation
   let n be Nat;
   let p,q be Element of n-tuples_on NAT;
   synonym q >= p for p <= q ; end;


  theorem :: POLYNOM3:5
   for n be Nat
   for p,q,r be Element of n-tuples_on NAT holds
    (p < q & q < r implies p < r) &
    ((p < q & q <= r) or (p <= q & q < r) or (p <= q & q <= r) implies p <= r);

  theorem :: POLYNOM3:6
   for n be Nat
   for p,q be Element of n-tuples_on NAT holds
    p <> q implies ex i be Nat st i in Seg n & p.i <> q.i &
     for k be Nat st 1 <= k & k < i holds p.k = q.k;

  theorem :: POLYNOM3:7
   for n be Nat
   for p,q be Element of n-tuples_on NAT holds
    p <= q or p > q;

  definition
   let n be Nat;
   func TuplesOrder n -> Order of n-tuples_on NAT means
:: POLYNOM3:def 3
    for p,q be Element of n-tuples_on NAT holds [p,q] in it iff p <= q;
  end;


  registration
   let n be Nat;
   cluster TuplesOrder n -> being_linear-order;
   coherence
   proof
    A1: field TuplesOrder n = n-tuples_on NAT by ORDERS_2:2;
      now let x,y be set;
     assume that
      A2: x in n-tuples_on NAT and
      A3: y in n-tuples_on NAT and
        x <> y and
      A4: not [x,y] in TuplesOrder n;
     reconsider p=x, q=y as Element of n-tuples_on NAT by A2,A3;
       not p <= q by A4,Def3;
     then p > q by Th7;
     then q <= p by Def2;
     hence [y,x] in TuplesOrder n by Def3;
    end;
    then TuplesOrder n is_connected_in n-tuples_on NAT by RELAT_2:def 6;
    then TuplesOrder n is connected by A1,RELAT_2:def 14;
    hence thesis by ORDERS_2:def 3;
   end;
  end;


begin  :: Decomposition of Natural Numbers

  definition
   let i be non empty Nat;
   let n be Nat;
   func Decomp(n,i) -> FinSequence of i-tuples_on NAT means
:: POLYNOM3:def 4
    ex A be finite Subset of i-tuples_on NAT st
     it = SgmX (TuplesOrder i,A) &
     for p be Element of i-tuples_on NAT holds p in A iff Sum p = n;
  end;


  registration
   let i be non empty Nat;
   let n be Nat;
   cluster Decomp(n,i) -> non empty one-to-one FinSequence-yielding;
   coherence
   proof
    consider A be finite Subset of i-tuples_on NAT such that
     A1: Decomp(n,i) = SgmX (TuplesOrder i,A) and
     A2: for p be Element of i-tuples_on NAT holds p in A iff Sum
 p = n by Def4;
      i >= 1 by RLVECT_1:99;
    then reconsider p1 = ((i-'1)|->0)^<*n*> as Element of i-tuples_on NAT
                                                                  by AMI_5:4;
    reconsider p2 = (i-'1)|->0 as FinSequence of NAT;
      Sum p1 = Sum p2 + n by RVSUM_1:104
        .= 0+n by RVSUM_1:111;
    then reconsider A as non empty finite Subset of i-tuples_on NAT by A2;
      SgmX (TuplesOrder i,A) is non empty finite;
    hence thesis by A1;
   end;
  end;


  theorem :: POLYNOM3:8
   for n be Nat holds len Decomp(n,1) = 1;

  theorem :: POLYNOM3:9
   for n be Nat holds len Decomp(n,2) = n+1;

  theorem :: POLYNOM3:10
     for n be Nat holds Decomp(n,1) = <*<*n*>*>;

  theorem :: POLYNOM3:11
   for i,j,n,k1,k2 be Nat st Decomp(n,2).i = <*k1,n-'k1*> &
    Decomp(n,2).j = <*k2,n-'k2*> holds i<j iff k1<k2;

  theorem :: POLYNOM3:12
   for i,n,k1,k2 be Nat st Decomp(n,2).i = <*k1,n-'k1*> &
    Decomp(n,2).(i+1) = <*k2,n-'k2*> holds k2=k1+1;

  theorem :: POLYNOM3:13
   for n be Nat holds Decomp(n,2).1 = <*0,n*>;

  theorem :: POLYNOM3:14
   for n,i be Nat st i in Seg (n+1) holds Decomp(n,2).i = <*i-'1,n+1-'i*>;

  definition
   let L be non empty HGrStr;
   let p,q,r be sequence of L;
   let t be FinSequence of 3-tuples_on NAT;
   func prodTuples(p,q,r,t) -> Element of (the carrier of L)* means
:: POLYNOM3:def 5
    len it = len t &
    for k be Nat st k in dom t holds
     it.k = (p.((t/.k)/.1))*(q.((t/.k)/.2))*(r.((t/.k)/.3));
  end;


  theorem :: POLYNOM3:15
   for L be non empty HGrStr
   for p,q,r be sequence of L
   for t be FinSequence of 3-tuples_on NAT
   for P be Permutation of dom t
   for t1 be FinSequence of 3-tuples_on NAT st t1 = t*P holds
    prodTuples(p,q,r,t1) = prodTuples(p,q,r,t)*P;

  theorem :: POLYNOM3:16
   for D be set
   for f be FinSequence of D*
   for i be Nat holds
    Card (f|i) = (Card f)|i;

  theorem :: POLYNOM3:17
   for p be FinSequence of REAL
   for q be FinSequence of NAT st p=q
   for i be Nat holds
    p|i = q|i;

  theorem :: POLYNOM3:18
   for p be FinSequence of NAT
   for i,j be Nat st i <= j holds
    Sum (p|i) <= Sum (p|j);

  theorem :: POLYNOM3:19
   for D being set,
       p be FinSequence of D
   for i be Nat st i < len p holds
    p|(i+1) = p|i ^ <*p.(i+1)*>;

  theorem :: POLYNOM3:20
   for p be FinSequence of REAL
   for i be Nat st i < len p holds
    Sum (p|(i+1)) = Sum (p|i) + p.(i+1);

  theorem :: POLYNOM3:21
   for p be FinSequence of NAT
   for i,j,k1,k2 be Nat st i < len p & j < len p &
    1 <= k1 & 1 <= k2 & k1 <= p.(i+1) & k2 <= p.(j+1) &
    (Sum (p|i)) + k1 = (Sum (p|j)) + k2 holds
     i = j & k1 = k2;

  theorem :: POLYNOM3:22
   for D1,D2 be set
   for f1 be FinSequence of D1*
   for f2 be FinSequence of D2*
   for i1,i2,j1,j2 be Nat st
    i1 in dom f1 & i2 in dom f2 & j1 in dom (f1.i1) & j2 in dom (f2.i2) &
    Card f1 = Card f2 &
    (Sum ((Card f1)|(i1-'1))) + j1 = (Sum ((Card f2)|(i2-'1))) + j2 holds
     i1 = i2 & j1 = j2;

begin  :: Polynomials

  definition
   let L be non empty ZeroStr;
   mode Polynomial of L is AlgSequence of L;
  end;


  theorem :: POLYNOM3:23
   for L be non empty ZeroStr
   for p be Polynomial of L
   for n be Nat holds
    n >= len p iff n is_at_least_length_of p;

  scheme :: POLYNOM3:sch 2
 PolynomialLambdaF{R()->non empty LoopStr, A()->Nat,
                           F(Nat)->Element of R()}:
   ex p be Polynomial of R() st
    len p <= A() & for n be Nat st n < A() holds p.n=F(n)
proof
   defpred P[Nat,Element of R()] means
    $1<A() & $2=F($1) or $1>=A() & $2=0.R();
   A1: for x be Element of NAT ex y be Element of R() st P[x,y]
   proof
    let x be Element of NAT;
      x<A() implies x<A() & F(x) = F(x);
    hence thesis;
   end;
   ex f be Function of NAT,the carrier of R() st
    for x be Element of NAT holds P[x,f.x] from FUNCT_2:sch 3(A1);
   then consider f be Function of NAT,the carrier of R() such that
    A2: for x be Element of NAT holds
     x<A() & f.x=F(x) or x>=A() & f.x=0.R();
   reconsider f as sequence of R() by NORMSP_1:def 3;
     ex n be Nat st for i be Nat st i >= n holds f.i = 0.R()
   proof
    take A();
    thus thesis by A2;
   end;
   then reconsider f as AlgSequence of R() by ALGSEQ_1:def 2;
   A3:len f <= A()
   proof
      for i be Nat st i>=A() holds f.i=0.R() by A2;
    then A() is_at_least_length_of f by ALGSEQ_1:def 3;
    hence thesis by ALGSEQ_1:def 4;
   end;
   take f;
   thus thesis by A2,A3;
  end;

  scheme :: POLYNOM3:sch 3
 ExDLoopStrSeq{ R() -> non empty LoopStr,
                        F(set) -> Element of R() } :
   ex S be sequence of R() st for n be Nat holds S.n = F(n)
proof
    set Y = the carrier of R();
    deffunc G(set) = F($1);
    A1: for x be set st x in NAT holds G(x) in Y;
    ex f be Function of NAT,Y st for x be set st x in NAT holds f.x = G(x)
     from FUNCT_2:sch 2(A1);
    then consider f be Function of NAT,Y such that
A2: for x be set st x in NAT holds f.x = F(x);
    reconsider f as sequence of R() by NORMSP_1:def 3;
    take f;
    thus thesis by A2;
   end;

  definition
   let L be non empty LoopStr;
   let p,q be sequence of L;
   func p+q -> sequence of L means
:: POLYNOM3:def 6
    for n be Nat holds it.n = p.n + q.n;
  end;


  registration
   let L be right_zeroed (non empty LoopStr);
   let p,q be Polynomial of L;
   cluster p+q -> finite-Support;
   coherence
   proof
    take s=len p + len q;
    let i be Nat;
     assume A1: i >= s;
       len p + len q >= len p by NAT_1:29;
     then i >= len p by A1,AXIOMS:22;
     then A2: p.i = 0.L by ALGSEQ_1:22;
       len p + len q >= len q by NAT_1:29;
     then A3: i >= len q by A1,AXIOMS:22;
     thus (p+q).i = p.i + q.i by Def6
        .= 0.L + 0.L by A2,A3,ALGSEQ_1:22
        .= 0.L by RLVECT_1:def 7;
   end;
  end;


  theorem :: POLYNOM3:24
   for L be right_zeroed (non empty LoopStr)
   for p,q be Polynomial of L
   for n be Nat holds
    (n is_at_least_length_of p & n is_at_least_length_of q) implies
     n is_at_least_length_of p+q;

  theorem :: POLYNOM3:25
     for L be right_zeroed (non empty LoopStr)
   for p,q be Polynomial of L holds
    support (p+q) c= support p \/ support q;

  definition
   let L be Abelian (non empty LoopStr);
   let p,q be sequence of L;
   redefine func p+q;
   commutativity;
  end;


  theorem :: POLYNOM3:26
   for L be add-associative (non empty LoopStr)
   for p,q,r be sequence of L holds
    p+q+r = p+(q+r);

  definition
   let L be non empty LoopStr;
   let p be sequence of L;
   func -p -> sequence of L means
:: POLYNOM3:def 7
    for n be Nat holds it.n = -p.n;
  end;


  registration
   let L be add-associative right_zeroed right_complementable
    (non empty LoopStr);
   let p be Polynomial of L;
   cluster -p -> finite-Support;
   coherence
   proof
    take s=len p;
    let i be Nat;
     assume A1: i >= s;
     thus (-p).i = -p.i by Def7
        .= - 0.L by A1,ALGSEQ_1:22
        .= 0.L by RLVECT_1:25;
   end;
  end;


  definition
   let L be non empty LoopStr;
   let p,q be sequence of L;
   func p-q -> sequence of L equals
:: POLYNOM3:def 8
    p+-q;
  end;


  registration
   let L be add-associative right_zeroed right_complementable
    (non empty LoopStr);
   let p,q be Polynomial of L;
   cluster p-q -> finite-Support;
   coherence
   proof
      p-q = p+-q by Def8;
    hence thesis;
   end;
  end;


  theorem :: POLYNOM3:27
   for L be non empty LoopStr
   for p,q be sequence of L
   for n be Nat holds
    (p-q).n = p.n - q.n;

  definition
   let L be non empty ZeroStr;
   func 0_.(L) -> sequence of L equals
:: POLYNOM3:def 9
    NAT --> 0.L;
  end;


  registration
   let L be non empty ZeroStr;
   cluster 0_.(L) -> finite-Support;
   coherence
   proof
    take 0;
    let i be Nat;
     assume i >= 0;
     thus (0_.(L)).i = (NAT --> 0.L).i by Def9
        .= 0.L by FUNCOP_1:13;
   end;
  end;


  theorem :: POLYNOM3:28
   for L be non empty ZeroStr
   for n be Nat holds
    (0_.(L)).n = 0.L;

  theorem :: POLYNOM3:29
   for L be right_zeroed (non empty LoopStr)
   for p be sequence of L holds
    p+0_.(L) = p;

  theorem :: POLYNOM3:30
   for L be add-associative right_zeroed right_complementable
    (non empty LoopStr)
   for p be sequence of L holds
    p-p = 0_.(L);

  definition
   let L be non empty multLoopStr_0;
   func 1_.(L) -> sequence of L equals
:: POLYNOM3:def 10
    0_.(L)+*(0,1_(L));
  end;


  registration
   let L be non empty multLoopStr_0;
   cluster 1_.(L) -> finite-Support;
   coherence
   proof
    take 1;
    let i be Nat;
     assume i >= 1;
     then A1: i <> 0;
     thus (1_.(L)).i = (0_.(L)+*(0,1_(L))).i by Def10
        .= (0_.(L)).i by A1,FUNCT_7:34
        .= 0.L by Th28;
   end;
  end;


  theorem :: POLYNOM3:31
   for L be non empty multLoopStr_0 holds
    (1_.(L)).0 = 1_(L) &
    for n be Nat st n <> 0 holds (1_.(L)).n = 0.L;

  definition
   let L be non empty doubleLoopStr;
   let p,q be sequence of L;
   func p*'q -> sequence of L means
:: POLYNOM3:def 11
    for i be Nat
    ex r be FinSequence of the carrier of L st
     len r = i+1 & it.i = Sum r &
     for k be Nat st k in dom r holds r.k = p.(k-'1) * q.(i+1-'k);
  end;


  registration
   let L be add-associative right_zeroed right_complementable distributive
    (non empty doubleLoopStr);
   let p,q be Polynomial of L;
   cluster p*'q -> finite-Support;
   coherence
   proof
    take s = len p + len q;
    let i be Nat;
     consider r be FinSequence of the carrier of L such that
      A1: len r = i+1 and
      A2: (p*'q).i = Sum r and
      A3: for k be Nat st k in dom r holds r.k = p.(k-'1) * q.(i+1-'k)
                                                                   by Def11;
     assume i >= s;
     then len p <= i - len q by REAL_1:84;
     then -len p >= -(i - len q) by REAL_1:50;
     then A4: -len p >= len q - i by XCMPLX_1:143;
       now let k be Nat;
      assume A5: k in dom r;
      then A6: r.k = p.(k-'1) * q.(i+1-'k) by A3;
      A7: 1 <= k & k <= i+1 by A1,A5,FINSEQ_3:27;
      then A8: i+1-k >= 0 by SQUARE_1:12;
      A9: k-1 >= 0 by A7,SQUARE_1:12;
      per cases;
       suppose k-'1 < len p;
        then k-1 < len p by A9,BINARITH:def 3;
        then -(k-1) > -len p by REAL_1:50;
        then 1-k > -len p by XCMPLX_1:143;
        then 1-k > len q - i by A4,AXIOMS:22;
        then i+(1-k) > len q by REAL_1:84;
        then i+1-k > len q by XCMPLX_1:29;
        then i+1-'k >= len q by A8,BINARITH:def 3;
        then q.(i+1-'k) = 0.L by ALGSEQ_1:22;
        hence r.k = 0.L by A6,VECTSP_1:36;
       end;
       suppose k-'1 >= len p;
        then p.(k-'1) = 0.L by ALGSEQ_1:22;
        hence r.k = 0.L by A6,VECTSP_1:39;
     end;
     end;
     hence thesis by A2,Th1;
   end;
  end;


  theorem :: POLYNOM3:32
   for L be Abelian add-associative right_zeroed right_complementable
    right-distributive (non empty doubleLoopStr)
   for p,q,r be sequence of L holds
    p*'(q+r) = p*'q+p*'r;

  theorem :: POLYNOM3:33
   for L be Abelian add-associative right_zeroed right_complementable
    left-distributive (non empty doubleLoopStr)
   for p,q,r be sequence of L holds
    (p+q)*'r = p*'r+q*'r;

  theorem :: POLYNOM3:34
   for L be Abelian add-associative right_zeroed right_complementable unital
    associative distributive (non empty doubleLoopStr)
   for p,q,r be sequence of L holds
    p*'q*'r = p*'(q*'r);

  definition
   let L be Abelian add-associative right_zeroed commutative
    (non empty doubleLoopStr);
   let p,q be sequence of L;
   redefine func p*'q;
   commutativity;
  end;


  theorem :: POLYNOM3:35
     for L be add-associative right_zeroed right_complementable
    right-distributive (non empty doubleLoopStr)
   for p be sequence of L holds
    p*'0_.(L) = 0_.(L);

  theorem :: POLYNOM3:36
   for L be add-associative right_zeroed right_unital right_complementable
    right-distributive (non empty doubleLoopStr)
   for p be sequence of L holds
    p*'1_.(L) = p;

begin  :: The Ring of Polynomials

  definition
   let L be add-associative right_zeroed right_complementable distributive
    (non empty doubleLoopStr);
   func Polynom-Ring L -> strict non empty doubleLoopStr means
:: POLYNOM3:def 12
    (for x be set holds x in the carrier of it iff x is Polynomial of L) &
    (for x,y be Element of it, p,q be sequence of L st
      x = p & y = q holds x+y = p+q) &
    (for x,y be Element of it, p,q be sequence of L st
      x = p & y = q holds x*y = p*'q) &
    0.it = 0_.(L) &
    1_(it) = 1_.(L);
  end;


  registration
   let L be Abelian add-associative right_zeroed right_complementable
                                      distributive (non empty doubleLoopStr);
   cluster Polynom-Ring L -> Abelian;
   coherence
   proof
    let p,q be Element of Polynom-Ring L;
    reconsider p1=p, q1=q as sequence of L by Def12;
    thus p + q = p1 + q1 by Def12
       .= q + p by Def12;
   end;
  end;


  registration
   let L be add-associative right_zeroed right_complementable
                                      distributive (non empty doubleLoopStr);
   cluster Polynom-Ring L -> add-associative;
   coherence
   proof
    let p,q,r be Element of Polynom-Ring L;
    reconsider p1=p, q1=q, r1=r as sequence of L by Def12;
    A1: q + r = q1 + r1 by Def12;
      p + q = p1 + q1 by Def12;
    hence (p + q) + r = (p1 + q1) + r1 by Def12
       .= p1 + (q1 + r1) by Th26
       .= p + (q + r) by A1,Def12;
   end;

   cluster Polynom-Ring L -> right_zeroed;
   coherence
   proof
    let p be Element of Polynom-Ring L;
    reconsider p1=p as sequence of L by Def12;
      0.(Polynom-Ring L) = 0_.(L) by Def12;
    hence p + 0.(Polynom-Ring L) = p1 + 0_.(L) by Def12
       .= p by Th29;
   end;

   cluster Polynom-Ring L -> right_complementable;
   coherence
   proof
    let p be Element of Polynom-Ring L;
    reconsider p1=p as Polynomial of L by Def12;
    reconsider q = -p1 as Element of Polynom-Ring L by Def12;
    take q;
    thus p + q = p1 + -p1 by Def12
       .= p1 - p1 by Def8
       .= 0_.(L) by Th30
       .= 0.(Polynom-Ring L) by Def12;
   end;
  end;


  registration
   let L be Abelian add-associative right_zeroed right_complementable
                          commutative distributive (non empty doubleLoopStr);
   cluster Polynom-Ring L -> commutative;
   coherence
   proof
    let p,q be Element of Polynom-Ring L;
    reconsider p1=p, q1=q as sequence of L by Def12;
    thus p * q = p1 *' q1 by Def12
       .= q * p by Def12;
   end;
  end;


  registration
   let L be Abelian add-associative right_zeroed right_complementable unital
                          associative distributive (non empty doubleLoopStr);
   cluster Polynom-Ring L -> associative;
   coherence
   proof
    let p,q,r be Element of Polynom-Ring L;
    reconsider p1=p, q1=q, r1=r as sequence of L by Def12;
    A1: q * r = q1 *' r1 by Def12;
      p * q = p1 *' q1 by Def12;
    hence (p * q) * r = (p1 *' q1) *' r1 by Def12
       .= p1 *' (q1 *' r1) by Th34
       .= p * (q * r) by A1,Def12;
   end;
  end;


  registration
   let L be add-associative right_zeroed right_complementable right_unital
                                      distributive (non empty doubleLoopStr);
   cluster Polynom-Ring L -> right_unital;
   coherence
   proof
    let p be Element of Polynom-Ring L;
    reconsider p1=p as sequence of L by Def12;
      1_(Polynom-Ring L) = 1_.(L) by Def12;
    hence p * 1_(Polynom-Ring L) = p1 *' 1_.(L) by Def12
       .= p by Th36;
   end;
  end;


  registration
   let L be Abelian add-associative right_zeroed right_complementable
                                      distributive (non empty doubleLoopStr);
   cluster Polynom-Ring L -> distributive;
   coherence
   proof
    let p,q,r be Element of Polynom-Ring L;
    reconsider p1=p, q1=q, r1=r as sequence of L by Def12;
    A1: p*q = p1*'q1 & p*r = p1*'r1 by Def12;
      q+r = q1+r1 by Def12;
    hence p*(q+r) = p1*'(q1+r1) by Def12
       .= p1*'q1+p1*'r1 by Th32
       .= p*q+p*r by A1,Def12;
    A2: q*p = q1*'p1 & r*p = r1*'p1 by Def12;
      q+r = q1+r1 by Def12;
    hence (q+r)*p = (q1+r1)*'p1 by Def12
       .= q1*'p1+r1*'p1 by Th33
       .= q*p+r*p by A2,Def12;
   end;
  end;

