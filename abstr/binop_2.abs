:: Binary Operations on Numbers
::  by Library Committee
::
:: Received June 21, 2004
:: Copyright (c) 2004 Association of Mizar Users

environ

 vocabularies XBOOLE_0, SUBSET_1, FUNCT_1, BINOP_1, XCMPLX_0, ORDINAL1,
      NUMBERS, XREAL_0, RAT_1, INT_1, ZFMISC_1, ARYTM_1, RELAT_1, ARYTM_3,
      CARD_1, SETWISEO, BINOP_2;
 notations XBOOLE_0, ZFMISC_1, SUBSET_1, FUNCT_1, FUNCT_2, BINOP_1, SETWISEO,
      ORDINAL1, XCMPLX_0, XREAL_0, INT_1, NUMBERS, RAT_1;
 constructors BINOP_1, SETWISEO, XCMPLX_0, RAT_1, RELSET_1;
 registrations ORDINAL1, NUMBERS, XCMPLX_0, XREAL_0, REAL_1, NAT_1, INT_1,
      RAT_1, RELSET_1;
 requirements BOOLE, SUBSET, ARITHM, NUMERALS;


begin

scheme :: BINOP_2:sch 1

  FuncDefUniq{C, D()->non empty set, F(Element of C())->set}: for f1,f2 being
Function of C(),D() st (for x being Element of C() holds f1.x = F(x)) & (for x
  being Element of C() holds f2.x = F(x)) holds f1 = f2;

scheme :: BINOP_2:sch 2

  BinOpDefuniq{A()->non empty set, O(Element of A(),Element of A())->set}: for
o1,o2 being BinOp of A() st (for a,b being Element of A() holds o1.(a,b) = O(a,
  b)) & (for a,b being Element of A() holds o2.(a,b) = O(a,b)) holds o1 = o2;

scheme :: BINOP_2:sch 3

  CFuncDefUniq{F(complex number)->set}: for f1,f2 being
Function of COMPLEX,COMPLEX st
   (for x being complex number holds f1.x = F(x)) & (for x
  being complex number holds f2.x = F(x)) holds f1 = f2;

scheme :: BINOP_2:sch 4

  RFuncDefUniq{F(real number)->set}: for f1,f2 being
Function of REAL,REAL st
   (for x being real number holds f1.x = F(x)) & (for x
  being real number holds f2.x = F(x)) holds f1 = f2;

registration
  cluster -> rational Element of RAT;
end;

scheme :: BINOP_2:sch 5

  WFuncDefUniq{F(rational number)->set}: for f1,f2 being
Function of RAT,RAT st
   (for x being rational number holds f1.x = F(x)) & (for x
  being rational number holds f2.x = F(x)) holds f1 = f2;

scheme :: BINOP_2:sch 6

  IFuncDefUniq{F(integer number)->set}: for f1,f2 being
Function of INT,INT st
   (for x being integer number holds f1.x = F(x)) & (for x
  being integer number holds f2.x = F(x)) holds f1 = f2;

scheme :: BINOP_2:sch 7

  NFuncDefUniq{F(natural number)->set}: for f1,f2 being
Function of NAT,NAT st
   (for x being natural number holds f1.x = F(x)) & (for x
  being natural number holds f2.x = F(x)) holds f1 = f2;

scheme :: BINOP_2:sch 8

  CBinOpDefuniq{O(complex number,complex number)->set}:
  for o1,o2 being BinOp of COMPLEX st
  (for a,b being complex number holds o1.(a,b) = O(a,b)) &
  (for a,b being complex number holds o2.(a,b) = O(a,b)) holds o1 = o2;

scheme :: BINOP_2:sch 9

  RBinOpDefuniq{O(real number,real number)->set}:
  for o1,o2 being BinOp of REAL st
  (for a,b being real number holds o1.(a,b) = O(a,b)) &
  (for a,b being real number holds o2.(a,b) = O(a,b)) holds o1 = o2;

scheme :: BINOP_2:sch 10

  WBinOpDefuniq{O(rational number,rational number)->set}:
  for o1,o2 being BinOp of RAT st
  (for a,b being rational number holds o1.(a,b) = O(a,b)) &
  (for a,b being rational number holds o2.(a,b) = O(a,b)) holds o1 = o2;

scheme :: BINOP_2:sch 11

  IBinOpDefuniq{O(integer number,integer number)->set}:
  for o1,o2 being BinOp of INT st
  (for a,b being integer number holds o1.(a,b) = O(a,b)) &
  (for a,b being integer number holds o2.(a,b) = O(a,b)) holds o1 = o2;

scheme :: BINOP_2:sch 12

  NBinOpDefuniq{O(natural number,natural number)->set}:
  for o1,o2 being BinOp of NAT st
  (for a,b being natural number holds o1.(a,b) = O(a,b)) &
  (for a,b being natural number holds o2.(a,b) = O(a,b)) holds o1 = o2;

scheme :: BINOP_2:sch 13

  CLambda2D{F(complex number,complex number) -> complex number}:
 ex f being Function of [:COMPLEX,COMPLEX:],COMPLEX st
  for x,y being complex number holds f.(x,y)=F(x,y);

scheme :: BINOP_2:sch 14

  RLambda2D{F(real number,real number) -> real number}:
 ex f being Function of [:REAL,REAL:],REAL st
  for x,y being real number holds f.(x,y)=F(x,y);

scheme :: BINOP_2:sch 15

  WLambda2D{F(rational number,rational number) -> rational number}:
 ex f being Function of [:RAT,RAT:],RAT st
  for x,y being rational number holds f.(x,y)=F(x,y);

scheme :: BINOP_2:sch 16

  ILambda2D{F(integer number,integer number) -> integer number}:
 ex f being Function of [:INT,INT:],INT st
  for x,y being integer number holds f.(x,y)=F(x,y);

scheme :: BINOP_2:sch 17

  NLambda2D{F(natural number,natural number) -> natural number}:
 ex f being Function of [:NAT,NAT:],NAT st
  for x,y being natural number holds f.(x,y)=F(x,y);

scheme :: BINOP_2:sch 18

  CLambdaD{F(complex number) -> complex number }: ex f
being Function of COMPLEX,COMPLEX st
 for x being complex number holds f.x = F(x);

scheme :: BINOP_2:sch 19

  RLambdaD{F(real number) -> real number }: ex f
being Function of REAL,REAL st
 for x being real number holds f.x = F(x);

scheme :: BINOP_2:sch 20

  WLambdaD{F(rational number) -> rational number }: ex f
being Function of RAT,RAT st
 for x being rational number holds f.x = F(x);

scheme :: BINOP_2:sch 21

  ILambdaD{F(integer number) -> integer number }: ex f
being Function of INT,INT st
 for x being integer number holds f.x = F(x);

scheme :: BINOP_2:sch 22

  NLambdaD{F(natural number) -> natural number }: ex f
being Function of NAT,NAT st
 for x being natural number holds f.x = F(x);

reserve c,c1,c2,c3 for complex number;

definition
  let c1;
  redefine func -c1 -> Element of COMPLEX;
  redefine func c1" -> Element of COMPLEX;
  let c2;
  redefine func c1+c2 -> Element of COMPLEX;
  redefine func c1-c2 -> Element of COMPLEX;
  redefine func c1*c2 -> Element of COMPLEX;
  redefine func c1/c2 -> Element of COMPLEX;
end;

reserve r,r1,r2,r3 for real number;

definition
  let r1;
  redefine func -r1 -> Element of REAL;
  redefine func r1" -> Element of REAL;
  let r2;
  redefine func r1+r2 -> Element of REAL;
  redefine func r1-r2 -> Element of REAL;
  redefine func r1*r2 -> Element of REAL;
  redefine func r1/r2 -> Element of REAL;
end;

reserve w,w1,w2,w3 for rational number;

definition
  let w1;
  redefine func -w1 -> Element of RAT;
  redefine func w1" -> Element of RAT;
  let w2;
  redefine func w1+w2 -> Element of RAT;
  redefine func w1-w2 -> Element of RAT;
  redefine func w1*w2 -> Element of RAT;
  redefine func w1/w2 -> Element of RAT;
end;

reserve i,i1,i2,i3 for integer number;

definition
  let i1;
  redefine func -i1 -> Element of INT;
  let i2;
  redefine func i1+i2 -> Element of INT;
  redefine func i1-i2 -> Element of INT;
  redefine func i1*i2 -> Element of INT;
end;

reserve n,n1,n2,n3 for natural number;

definition
  let n1,n2;
  redefine func n1+n2 -> Element of NAT;
  redefine func n1*n2 -> Element of NAT;
end;

definition
  func compcomplex -> UnOp of COMPLEX means
:: BINOP_2:def 1
  for c holds it.c = -c;
  func invcomplex -> UnOp of COMPLEX means
:: BINOP_2:def 2
  for c holds it.c = c";
  func addcomplex -> BinOp of COMPLEX means
:: BINOP_2:def 3

  for c1,c2 holds it.(c1,c2)
  = c1 + c2;
  func diffcomplex -> BinOp of COMPLEX means
:: BINOP_2:def 4
  for c1,c2 holds it.(c1,c2) = c1 -
  c2;
  func multcomplex -> BinOp of COMPLEX means
:: BINOP_2:def 5

  for c1,c2 holds it.(c1,c2)
  = c1 * c2;
  func divcomplex -> BinOp of COMPLEX means
:: BINOP_2:def 6
  for c1,c2 holds it.(c1,c2) = c1 /
  c2;
end;

definition
  func compreal -> UnOp of REAL means
:: BINOP_2:def 7
  for r holds it.r = -r;
  func invreal -> UnOp of REAL means
:: BINOP_2:def 8
  for r holds it.r = r";
  func addreal -> BinOp of REAL means
:: BINOP_2:def 9

  for r1,r2 holds it.(r1,r2) = r1 +
  r2;
  func diffreal -> BinOp of REAL means
:: BINOP_2:def 10
  for r1,r2 holds it.(r1,r2) = r1 - r2;
  func multreal -> BinOp of REAL means
:: BINOP_2:def 11

  for r1,r2 holds it.(r1,r2) = r1
  * r2;
  func divreal -> BinOp of REAL means
:: BINOP_2:def 12
  for r1,r2 holds it.(r1,r2) = r1 / r2;
end;

definition
  func comprat -> UnOp of RAT means
:: BINOP_2:def 13
  for w holds it.w = -w;
  func invrat -> UnOp of RAT means
:: BINOP_2:def 14
  for w holds it.w = w";
  func addrat -> BinOp of RAT means
:: BINOP_2:def 15

  for w1,w2 holds it.(w1,w2) = w1 +
  w2;
  func diffrat -> BinOp of RAT means
:: BINOP_2:def 16
  for w1,w2 holds it.(w1,w2) = w1 - w2;
  func multrat -> BinOp of RAT means
:: BINOP_2:def 17

  for w1,w2 holds it.(w1,w2) = w1 *
  w2;
  func divrat -> BinOp of RAT means
:: BINOP_2:def 18
  for w1,w2 holds it.(w1,w2) = w1 / w2;
end;

definition
  func compint -> UnOp of INT means
:: BINOP_2:def 19
  for i holds it.i = -i;
  func addint -> BinOp of INT means
:: BINOP_2:def 20

  for i1,i2 holds it.(i1,i2) = i1 +
  i2;
  func diffint -> BinOp of INT means
:: BINOP_2:def 21
  for i1,i2 holds it.(i1,i2) = i1 - i2;
  func multint -> BinOp of INT means
:: BINOP_2:def 22

  for i1,i2 holds it.(i1,i2) = i1 *
  i2;
end;

definition
  func addnat -> BinOp of NAT means
:: BINOP_2:def 23

  for n1,n2 holds it.(n1,n2) = n1 +
  n2;
  func multnat -> BinOp of NAT means
:: BINOP_2:def 24

  for n1,n2 holds it.(n1,n2) = n1 *
  n2;
end;

registration
  cluster addcomplex -> commutative associative;
  cluster multcomplex -> commutative associative;
  cluster addreal -> commutative associative;
  cluster multreal -> commutative associative;
  cluster addrat -> commutative associative;
  cluster multrat -> commutative associative;
  cluster addint -> commutative associative;
  cluster multint -> commutative associative;
  cluster addnat -> commutative associative;
  cluster multnat -> commutative associative;
end;

registration
  cluster addcomplex -> having_a_unity;
  cluster addreal -> having_a_unity;
  cluster addrat -> having_a_unity;
  cluster addint -> having_a_unity;
  cluster addnat -> having_a_unity;
  cluster multcomplex -> having_a_unity;
  cluster multreal -> having_a_unity;
  cluster multrat -> having_a_unity;
  cluster multint -> having_a_unity;
  cluster multnat -> having_a_unity;
end;

theorem :: BINOP_2:1
  the_unity_wrt addcomplex = 0;

theorem :: BINOP_2:2
  the_unity_wrt addreal = 0;

theorem :: BINOP_2:3
  the_unity_wrt addrat = 0;

theorem :: BINOP_2:4
  the_unity_wrt addint = 0;

theorem :: BINOP_2:5
  the_unity_wrt addnat = 0;

theorem :: BINOP_2:6
  the_unity_wrt multcomplex = 1;

theorem :: BINOP_2:7
  the_unity_wrt multreal = 1;

theorem :: BINOP_2:8
  the_unity_wrt multrat = 1;

theorem :: BINOP_2:9
  the_unity_wrt multint = 1;

theorem :: BINOP_2:10
  the_unity_wrt multnat = 1;

