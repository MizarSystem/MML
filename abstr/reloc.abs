:: Relocatability
::  by Yasushi Tanaka
::
:: Received June 16, 1994
:: Copyright (c) 1994 Association of Mizar Users

environ

 vocabularies SUBSET_1, NUMBERS, AMI_1, AMI_3, AMISTD_2, QC_LANG1, AMI_2,
      ARYTM_3, GRAPHSP, CARD_1, FINSET_1, RELAT_1, FUNCT_1, PARTFUN1, TARSKI,
      VALUED_1, FUNCT_4, XBOOLE_0, FSM_1, CIRCUIT2, SCMNORM, ARYTM_1, INT_1,
      XXREAL_0, GLIB_000, STRUCT_0, MSUALG_1, TURING_1, ORDINAL1, RELOC;
 notations TARSKI, XBOOLE_0, SUBSET_1, NUMBERS, XCMPLX_0, INT_1, NAT_1,
      VALUED_1, RELAT_1, FUNCT_1, PARTFUN1, FUNCT_4, FINSET_1, NAT_D, STRUCT_0,
      AMI_1, SCMNORM, AMI_2, AMI_3, AMI_5, XXREAL_0;
 constructors DOMAIN_1, XXREAL_0, AMI_5, SCMNORM, NAT_D, PRE_POLY;
 registrations XBOOLE_0, SETFAM_1, FUNCT_1, ORDINAL1, RELSET_1, NUMBERS,
      XREAL_0, INT_1, CARD_3, AMI_1, AMI_3, FINSET_1, RELAT_1, VALUED_1,
      SCMNORM, GRFUNC_1, FUNCT_2;
 requirements NUMERALS, SUBSET, BOOLE, ARITHM;


begin  :: Relocatability

reserve j, k, m for Element of NAT;

definition
  canceled 2;
  let I be Instruction of SCM , k be Element of NAT;
  func IncAddr (I,k) -> Instruction of SCM equals
:: RELOC:def 3

  SCM-goto (((@I) jump_address ) +k) if InsCode I = 6,
  ((@I) cond_address)@ =0_goto (((@I) cjump_address) +k) if InsCode I = 7,
  ((@I) cond_address)@ >0_goto (((@I) cjump_address) +k) if InsCode I = 8
   otherwise I;
end;

canceled 3;

theorem :: RELOC:4
  for k being Element of NAT holds IncAddr(halt SCM,k) = halt SCM;

theorem :: RELOC:5
  for k being Element of NAT, a,b being Data-Location holds IncAddr
  (a:=b,k) = a:=b;

theorem :: RELOC:6
  for k being Element of NAT, a,b being Data-Location holds IncAddr
  (AddTo(a,b),k) = AddTo(a,b);

theorem :: RELOC:7
  for k being Element of NAT, a,b being Data-Location holds IncAddr
  (SubFrom(a,b),k) = SubFrom(a,b);

theorem :: RELOC:8
  for k being Element of NAT, a,b being Data-Location holds IncAddr
  (MultBy(a,b),k) = MultBy(a,b);

theorem :: RELOC:9
  for k being Element of NAT, a,b being Data-Location holds IncAddr
  (Divide(a,b),k) = Divide(a,b);

theorem :: RELOC:10
  for k being Element of NAT,loc being Element of NAT
  holds IncAddr(SCM-goto loc,k) = SCM-goto (loc + k);

theorem :: RELOC:11
  for k being Element of NAT,loc being Element of NAT
  , a being Data-Location holds IncAddr(a=0_goto loc,k) = a=0_goto (loc + k);

theorem :: RELOC:12
  for k being Element of NAT,loc being Element of NAT
  , a being Data-Location holds IncAddr(a>0_goto loc,k) = a>0_goto (loc + k);

theorem :: RELOC:13
  for I being Instruction of SCM, k being Element of NAT holds
  InsCode (IncAddr (I, k)) = InsCode I;

theorem :: RELOC:14
  for II, I being Instruction of SCM, k being Element of NAT st (
InsCode I = 0 or InsCode I = 1 or InsCode I = 2 or InsCode I = 3 or InsCode I =
  4 or InsCode I = 5) & IncAddr (II, k) = I holds II = I;

canceled 3;

definition
  let p be finite NAT-defined (the Instructions of SCM)-valued Function,
      k be Element of NAT;
  func IncAddr(p,k) -> NAT-defined FinPartState of SCM means
:: RELOC:def 4
 dom it = dom p & for m st m in dom p holds it.m = IncAddr(p/.m,k);
end;

registration
  let p be finite NAT-defined (the Instructions of SCM)-valued Function,
      k be Element of NAT;
  cluster IncAddr(p,k) -> (the Instructions of SCM)-valued;
end;

definition
 let p be finite NAT-defined (the Instructions of SCM)-valued Function,
     k be Element of NAT;
 func Reloc(p,k) ->
   finite NAT-defined (the Instructions of SCM)-valued Function
   equals
:: RELOC:def 5
IncAddr(Shift(p,k),k);
end;

canceled;

theorem :: RELOC:19
  for i being Element of NAT, p being finite
   NAT-defined (the Instructions of SCM)-valued Function
    holds Shift(IncAddr(p,i),i) = Reloc(p,i);

definition
  let p be FinPartState of SCM , k be Element of NAT;
  func Relocated ( p, k ) -> FinPartState of SCM equals
:: RELOC:def 6
  Start-At ((IC p)+k,SCM)+* Reloc(ProgramPart(p),k)+*DataPart p;
end;

canceled;

theorem :: RELOC:21
  for p being FinPartState of SCM,k being Element of NAT holds
  DataPart(Relocated(p,k)) = DataPart(p);

theorem :: RELOC:22
  for p being FinPartState of SCM,k being Element of NAT holds
  ProgramPart(Relocated(p,k)) = Reloc(ProgramPart p,k);

theorem :: RELOC:23
  for p being finite NAT-defined (the Instructions of SCM)-valued Function
   holds dom Reloc(p,k) = { j+k:j in dom p };

theorem :: RELOC:24
  for p being FinPartState of SCM, k being Element of NAT, l being
  Element of NAT holds l in dom p iff l+k in dom Relocated(p,k);

theorem :: RELOC:25
  for p being FinPartState of SCM , k being Element of NAT holds
  IC SCM in dom Relocated (p,k);

theorem :: RELOC:26
  for p being FinPartState of SCM, k being Element of NAT holds IC
  Relocated (p,k) = (IC p) + k;

theorem :: RELOC:27
  for p being FinPartState of SCM, k being Element of NAT, loc
being Element of NAT, I being Instruction of SCM st loc in dom ProgramPart p &
  I = p.loc holds IncAddr(I, k) = (Relocated (p, k)).(loc + k);

theorem :: RELOC:28
  for p being FinPartState of SCM,k being Element of NAT holds
  Start-At(IC p+k,SCM) c= Relocated (p,k);

theorem :: RELOC:29
  for s being data-only FinPartState of SCM, p being FinPartState
of SCM, k being Element of NAT st IC SCM in dom p holds Relocated((p +* s), k)
  = Relocated (p,k) +* s;

theorem :: RELOC:30
  for k being Element of NAT, p being  FinPartState of
  SCM , s1, s2 being State of SCM st p c= s1 & Relocated (p,k) c= s2 holds p c=
  s1 +* DataPart s2;

theorem :: RELOC:31
  for s being State of SCM
   holds Exec(IncAddr(CurInstr(ProgramPart s, s),k),s +*
  Start-At(IC s+k,SCM)) = Following(ProgramPart s,s) +*
  Start-At(IC Following(ProgramPart s,s)+k,SCM);

theorem :: RELOC:32
  for INS being Instruction of SCM, s being State of SCM, j, k
being Element of NAT st IC s = j+k
 holds Exec(INS, s +* Start-At (IC s -' k,SCM)) =
  Exec(IncAddr(INS, k), s) +* Start-At (IC Exec(IncAddr(INS,k), s) -' k,SCM);

begin :: Main theorems of Relocatability

theorem :: RELOC:33
  for k being Element of NAT for p being autonomic FinPartState of SCM
  st IC SCM in dom p for s being State of SCM st p c= s for i being Element of
NAT holds Comput(ProgramPart(s +* Relocated (p,k)),s +* Relocated (p,k),i) =
Comput(ProgramPart(s),s,i) +* Start-At (
  IC Comput(ProgramPart(s),s,i) +k,SCM) +* ProgramPart (Relocated (p,k));

theorem :: RELOC:34
  for k being Element of NAT, p being autonomic FinPartState of SCM , s1
  , s2 being State of SCM st IC SCM in dom p & p c= s1 & Relocated (p,k) c= s2
for i being Element of NAT holds IC Comput(ProgramPart(s1),s1,i) + k = IC
Comput(ProgramPart(s2),s2,i);

theorem :: RELOC:35
  for k being Element of NAT, p being autonomic FinPartState of
SCM , s1, s2 being State of SCM st IC SCM in dom p & p c= s1 & Relocated (p,k)
c= s2 for i being Element of NAT
 holds IncAddr(CurInstr(ProgramPart s1,Comput(ProgramPart(s1),s1,i)), k)
  = CurInstr(ProgramPart s2,Comput(ProgramPart(s2),s2,i));

theorem :: RELOC:36
  for k being Element of NAT, p being autonomic FinPartState of SCM , s1
  , s2 being State of SCM st IC SCM in dom p & p c= s1 & Relocated (p,k) c= s2
  for i being Element of NAT holds Comput(ProgramPart(s1),s1,i)|dom (DataPart p
) =
  Comput(ProgramPart(s2),s2,i)|dom (DataPart (Relocated (p,k)));

theorem :: RELOC:37
  for k being Element of NAT, p being autonomic FinPartState of SCM , s1
  , s2, s3 being State of SCM st IC SCM in dom p & p c= s1 & Relocated (p,k) c=
  s2 & s3 = s1 +* DataPart s2 holds for i being Element of NAT holds DataPart
  Comput(ProgramPart(s1),s3,i) = DataPart Comput(ProgramPart(s2),s2,i);

theorem :: RELOC:38
  for p being autonomic FinPartState of SCM , k being Element of
  NAT st IC SCM in dom p holds p is halting iff Relocated (p,k) is halting;

theorem :: RELOC:39
  for k being Element of NAT for p being autonomic FinPartState of
  SCM st IC SCM in dom p for s being State of SCM st Relocated(p,k) c= s holds
  for i being Element of NAT holds Comput(ProgramPart(s),s,i) = Comput(
ProgramPart(s+*p),s+*p,i) +*
  Start-At (IC Comput(ProgramPart(s+*p),s+*p,i) +k,SCM) +* s|dom ProgramPart p
+*
   ProgramPart (Relocated (p,k));

theorem :: RELOC:40
  for k being Element of NAT for p being FinPartState of SCM st IC
  SCM in dom p for s being State of SCM st p c= s & Relocated(p,k) is autonomic
  holds for i being Element of NAT holds Comput(ProgramPart(s),s,i) = Comput(
ProgramPart(s+*
Relocated(p,k)),s+*
Relocated(p,k),i) +* Start-At (IC Comput(ProgramPart(s+*Relocated(p,k)),s+*
Relocated(p,k),i) -'k,SCM)
 +* s|
  dom ProgramPart Relocated(p,k) +* ProgramPart (p);

theorem :: RELOC:41
  for p being FinPartState of SCM st IC SCM in dom p for k being
  Element of NAT holds p is autonomic iff Relocated (p,k) is autonomic;

theorem :: RELOC:42
  for p being halting autonomic FinPartState of SCM st IC SCM in
  dom p for k being Element of NAT holds DataPart(Result(ProgramPart(p),p)) =
   DataPart Result(Reloc(ProgramPart p,k),Relocated(p,k));

:: Relocatability

theorem :: RELOC:43
  for F being PartFunc of FinPartSt SCM, FinPartSt SCM, p being
FinPartState of SCM st IC SCM in dom p & F is data-only
  for k being Element of
   NAT holds ProgramPart p, p computes F
    iff ProgramPart Relocated(p,k), Relocated(p,k) computes F;

