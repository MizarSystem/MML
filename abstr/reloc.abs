:: Relocatability
::  by Yasushi Tanaka
::
:: Received June 16, 1994
:: Copyright (c) 1994 Association of Mizar Users

environ

 vocabularies SUBSET_1, NUMBERS, AMI_1, AMI_3, AMISTD_2, ARYTM_3, GRAPHSP,
      CARD_1, RELAT_1, FUNCT_1, PARTFUN1, TARSKI, FUNCT_4, XBOOLE_0, FSM_1,
      CIRCUIT2, SCMNORM, ARYTM_1, INT_1, XXREAL_0, GLIB_000, STRUCT_0,
      TURING_1, ORDINAL1, RELOC, FINSEQ_1, NAT_1, AMISTD_5, PBOOLE, COMPOS_1;
 notations TARSKI, XBOOLE_0, SUBSET_1, NUMBERS, XCMPLX_0, INT_1, NAT_1,
      VALUED_1, RELAT_1, FUNCT_1, PARTFUN1, FUNCT_4, PBOOLE, FINSEQ_1, NAT_D,
      STRUCT_0, COMPOS_1, EXTPRO_1, AMI_3, XXREAL_0, AMISTD_2, AMISTD_5;
 constructors DOMAIN_1, XXREAL_0, AMI_3, NAT_D, PRE_POLY, RECDEF_2, AMISTD_2,
      VALUED_1, AMI_2, AMI_1, AMISTD_1, AMISTD_5, PBOOLE;
 registrations XBOOLE_0, SETFAM_1, FUNCT_1, ORDINAL1, RELSET_1, NUMBERS,
      XREAL_0, INT_1, CARD_3, AMI_1, AMI_3, RELAT_1, GRFUNC_1, FUNCT_2, AMI_6,
      VALUED_0, AMISTD_2, COMPOS_1, EXTPRO_1, NAT_1, FINSEQ_1, AMISTD_5, AMI_5,
      PBOOLE;
 requirements NUMERALS, SUBSET, BOOLE, ARITHM;


begin  :: Relocatability

reserve j, k, m for Element of NAT;

registration
 let a,b be Data-Location;
 cluster a:=b -> ins-loc-free;
 cluster AddTo(a,b) -> ins-loc-free;
 cluster SubFrom(a,b) -> ins-loc-free;
 cluster MultBy(a,b) -> ins-loc-free;
 cluster Divide(a,b) -> ins-loc-free;
end;

theorem :: RELOC:1
  for k,loc being Nat
  holds IncAddr(SCM-goto loc,k) = SCM-goto (loc + k);

theorem :: RELOC:2
  for k,loc being Nat, a being Data-Location
   holds IncAddr(a=0_goto loc,k) = a=0_goto (loc + k);

theorem :: RELOC:3
  for k,loc being Nat, a being Data-Location
   holds IncAddr(a>0_goto loc,k) = a>0_goto (loc + k);

theorem :: RELOC:4
  for I being Instruction of SCM, k being Element of NAT st
InsCode I = 0 or InsCode I = 1 or InsCode I = 2 or InsCode I = 3 or InsCode I =
  4 or InsCode I = 5 holds IncAddr (I, k) = I;

theorem :: RELOC:5
  for II, I being Instruction of SCM, k being Element of NAT st (
InsCode I = 0 or InsCode I = 1 or InsCode I = 2 or InsCode I = 3 or InsCode I =
  4 or InsCode I = 5) & IncAddr (II, k) = I holds II = I;

registration
 cluster SCM -> relocable;
end;

begin

theorem :: RELOC:6
  for k being Element of NAT, p being autonomic FinPartState of SCM , s1
  , s2 being State of SCM st IC SCM in dom p & p c= s1 & Relocated (p,k) c= s2
for P1,P2 being (the Instructions of SCM)-valued ManySortedSet of NAT
  st ProgramPart p c= P1 & Reloc(ProgramPart p,k) c= P2
for i being Element of NAT holds IC Comput(P1,s1,i) + k = IC
Comput(P2,s2,i);

registration
 cluster SCM -> relocable1 relocable2;
end;

theorem :: RELOC:7
  for k being Element of NAT, p being autonomic FinPartState of SCM , s1
  , s2, s3 being State of SCM st IC SCM in dom p & p c= s1 & Relocated (p,k) c=
  s2 & s3 = s1 +* DataPart s2 holds
  for P1,P2 being (the Instructions of SCM)-valued ManySortedSet of NAT
  st ProgramPart p c= P1 & Reloc(ProgramPart p,k) c= P2
  for i being Element of NAT holds DataPart
  Comput(P1,s3,i) = DataPart Comput(P2,s2,i);
