:: The Construction and Computation of Conditional Statements for SCMPDS
::  by JingChao Chen
::
:: Received June 15, 1999
:: Copyright (c) 1999 Association of Mizar Users

environ

 vocabularies NUMBERS, SUBSET_1, SCMPDS_2, AMI_1, FSM_1, INT_1, AMI_2, RELAT_1,
      XBOOLE_0, GRAPHSP, XXREAL_0, CIRCUIT2, ARYTM_3, CARD_1, FUNCT_7, FUNCT_1,
      SCMFSA6A, FUNCT_4, TARSKI, TURING_1, SCMFSA_7, SCMPDS_4, AMISTD_2,
      COMPLEX1, VALUED_1, SCMFSA6B, MSUALG_1, SCMPDS_5, SCMFSA8A, AMI_3,
      ARYTM_1, UNIALG_2, SCMFSA7B, GLIB_000, SCMFSA8B, NAT_1, STRUCT_0,
      SCMPDS_6, ORDINAL1, PARTFUN1, SCMNORM, AFINSQ_1;
 notations TARSKI, XBOOLE_0, SUBSET_1, SETFAM_1, XCMPLX_0, RELAT_1, FUNCT_1,
      CARD_1, PARTFUN1, AFINSQ_1, VALUED_1, NUMBERS, COMPLEX1, FUNCT_4, INT_1,
      NAT_1, STRUCT_0, AMI_1, SCMNORM, AMI_2, FUNCT_7, SCMPDS_2, SCMPDS_4,
      SCMPDS_5, XXREAL_0;
 constructors XXREAL_0, REAL_1, NAT_1, INT_2, SCM_1, SCMPDS_4, SCMPDS_5,
      SCMNORM, SCMPDS_3, AFINSQ_1, VALUED_1;
 registrations SETFAM_1, FUNCT_1, RELSET_1, NUMBERS, XXREAL_0, XREAL_0, NAT_1,
      INT_1, CARD_3, AMI_1, SCMPDS_2, SCMPDS_4, SCMPDS_5, ORDINAL1, XBOOLE_0,
      SCMNORM, VALUED_1, AFINSQ_1;
 requirements NUMERALS, REAL, SUBSET, BOOLE, ARITHM;


begin :: Preliminaries

reserve m,n for Element of NAT,
  a for Int_position,
  i,j for Instruction of
  SCMPDS,
  s,s1,s2 for State of SCMPDS,
  k1 for Integer,
  loc for
  Element of NAT,
  I,J,K for Program of SCMPDS;

canceled;

theorem :: SCMPDS_6:2
  for s being State of SCMPDS st ProgramPart s halts_on s for k being Element
  of NAT st LifeSpan(ProgramPart(s),s) <= k
   holds CurInstr(ProgramPart (s), Comput(ProgramPart(s),s,k))
        = halt SCMPDS;

theorem :: SCMPDS_6:3
  for s being State of SCMPDS st ProgramPart s halts_on s for k being Element
of NAT st LifeSpan(ProgramPart(s),s) <= k holds IC Comput(ProgramPart(s),s,k) =
IC Comput(ProgramPart(s),s,LifeSpan(ProgramPart s,s));

theorem :: SCMPDS_6:4
  for s1,s2 being State of SCMPDS holds s1,s2 equal_outside NAT iff
  IC s1 = IC s2 & DataPart s1 = DataPart s2;

theorem :: SCMPDS_6:5
  for s being State of SCMPDS, I being Program of SCMPDS holds
  Initialized s +* Initialized I = s +* Initialized I;

theorem :: SCMPDS_6:6
  for I being Program of SCMPDS, l being Element of NAT
  holds I c= I +* Start-At(l,SCMPDS);

theorem :: SCMPDS_6:7
  for s being State of SCMPDS, l being Element of NAT
  holds DataPart s = DataPart(s +* Start-At(l,SCMPDS));

theorem :: SCMPDS_6:8
  for s being State of SCMPDS,I being Program of SCMPDS, l being
Element of NAT holds DataPart s = DataPart(s +* (I +* Start-At(
  l,SCMPDS)));

theorem :: SCMPDS_6:9
  for s being State of SCMPDS,I being Program of SCMPDS holds
  DataPart s = DataPart(s +* Initialized I);

theorem :: SCMPDS_6:10
  for s being State of SCMPDS, l being Element of NAT
  holds dom ProgramPart s misses dom Start-At(l,SCMPDS);

theorem :: SCMPDS_6:11
  for s being State of SCMPDS, I,J being Program of SCMPDS, l being
  Element of NAT holds s +* (I +* Start-At(l,SCMPDS)),
  s +* (J +*
  Start-At(l,SCMPDS)) equal_outside NAT;

theorem :: SCMPDS_6:12
  for s1,s2 be State of SCMPDS,I,J be Program of SCMPDS holds
  DataPart s1 = DataPart s2 implies s1 +* Initialized I, s2 +* Initialized J
  equal_outside NAT;

canceled;

theorem :: SCMPDS_6:14
  for s being State of SCMPDS, l1,l2 being Element of NAT
  holds s +* Start-At(l1,SCMPDS) +* Start-At(l2,SCMPDS) =
  s +* Start-At(l2,SCMPDS);

theorem :: SCMPDS_6:15
  card (i ';' I)= card I + 1;

theorem :: SCMPDS_6:16
  (i ';' I). 0=i;

theorem :: SCMPDS_6:17
  I c= Initialized stop I;

theorem :: SCMPDS_6:18
  loc in dom I implies loc in dom (stop I);

theorem :: SCMPDS_6:19
  loc in dom I implies (stop I).loc=I.loc;

theorem :: SCMPDS_6:20
  loc in dom I implies (Initialized stop I).loc=I.loc;

theorem :: SCMPDS_6:21
  IC (s+* Initialized I)= 0;

theorem :: SCMPDS_6:22
  CurInstr(ProgramPart(s+* Initialized stop(i ';' I)),
  s+* Initialized stop(i ';' I)) = i;

theorem :: SCMPDS_6:23
  for s being State of SCMPDS,m1,m2 being Element of NAT st IC s=
   m1 holds ICplusConst(s,m2)= (m1+m2);

theorem :: SCMPDS_6:24
  for I,J being Program of SCMPDS holds Shift(stop J,card I) c=
  stop(I ';' J);

theorem :: SCMPDS_6:25
  (card I) in dom (stop I) & (stop I).(card I) = halt
  SCMPDS;

theorem :: SCMPDS_6:26
  for x,l being Element of NAT holds IExec(J,s).x
  = (IExec(I,s) +* Start-At(l,SCMPDS)).x;

theorem :: SCMPDS_6:27
  for x,l being Element of NAT holds IExec(I,s).x
  = (s +* Start-At(l,SCMPDS)).x;

theorem :: SCMPDS_6:28
  for s being State of SCMPDS, i being No-StopCode parahalting
Instruction of SCMPDS,J being parahalting shiftable Program of SCMPDS, a being
  Int_position holds IExec(i ';' J,s).a = IExec(J,Exec(i,Initialized s)).a;

theorem :: SCMPDS_6:29
  for a being Int_position,k1,k2 being Integer holds (a,k1)
  <>0_goto k2 <> halt SCMPDS;

theorem :: SCMPDS_6:30
  for a being Int_position,k1,k2 being Integer holds (a,k1)
  <=0_goto k2 <> halt SCMPDS;

theorem :: SCMPDS_6:31
  for a being Int_position,k1,k2 being Integer holds (a,k1)
  >=0_goto k2 <> halt SCMPDS;

definition
  let k1;
  func Goto k1 -> Program of SCMPDS equals
:: SCMPDS_6:def 1
  Load (goto k1);
end;

registration
  let n be Element of NAT;
  cluster goto (n+1) -> No-StopCode;
  cluster goto -(n+1) -> No-StopCode;
end;

registration
  let n be Element of NAT;
  cluster Goto (n+1) -> halt-free;
  cluster Goto -(n+1) -> halt-free;
end;

canceled;

theorem :: SCMPDS_6:33
   0 in dom Goto k1 & (Goto k1). 0 = goto k1;

begin :: The predicates of is_closed_on and is_halting_on

definition
  let I be Program of SCMPDS;
  let s be State of SCMPDS;
  pred I is_closed_on s means
:: SCMPDS_6:def 2

  for k being Element of NAT holds IC
  Comput(ProgramPart(s+*Initialized stop I),s+*Initialized stop I,k) in dom
stop I;
  pred I is_halting_on s means
:: SCMPDS_6:def 3

  ProgramPart(s+*Initialized stop I) halts_on s+*Initialized stop I;
end;

theorem :: SCMPDS_6:34
  for I being Program of SCMPDS holds I is paraclosed iff for s
  being State of SCMPDS holds I is_closed_on s;

theorem :: SCMPDS_6:35
  for I being Program of SCMPDS holds I is parahalting iff for s
  being State of SCMPDS holds I is_halting_on s;

theorem :: SCMPDS_6:36
  for s1,s2 being State of SCMPDS, I being Program of SCMPDS st
  DataPart s1 = DataPart s2 holds I is_closed_on s1 implies I is_closed_on s2;

theorem :: SCMPDS_6:37
  for s1,s2 being State of SCMPDS,I being Program of SCMPDS st DataPart
  s1 = DataPart s2 holds I is_closed_on s1 & I is_halting_on s1 implies I
  is_closed_on s2 & I is_halting_on s2;

theorem :: SCMPDS_6:38
  for s being State of SCMPDS, I,J being Program of SCMPDS holds I
  is_closed_on s iff I is_closed_on s +* Initialized J;

theorem :: SCMPDS_6:39
  for I,J being Program of SCMPDS,s being State of SCMPDS st I
  is_closed_on s & I is_halting_on s holds (for k being Element of NAT st k <=
LifeSpan(ProgramPart(s +* Initialized stop I),s +* Initialized stop I) holds IC
Comput(ProgramPart( (s +*
Initialized stop
  I)), (s +* Initialized stop
  I),k) = IC Comput(ProgramPart( (s +* Initialized stop (I ';' J))), (s +*
Initialized stop (I ';' J)),k)) & DataPart
Comput(ProgramPart( (s +* Initialized stop I)), (s +* Initialized stop I), (
LifeSpan(ProgramPart(s +* Initialized stop I),s +* Initialized stop I))) =
  DataPart Comput(ProgramPart( (s +* Initialized stop (I ';' J))), (s +*
Initialized stop (I ';' J)), (LifeSpan(ProgramPart(s +*
  Initialized stop I),s +*
  Initialized stop I)));

theorem :: SCMPDS_6:40
  for I being Program of SCMPDS,k be Element of NAT st I
  is_closed_on s & I is_halting_on s & k < LifeSpan(ProgramPart(s +*
Initialized stop(I)),s +* Initialized stop(I))
  holds IC Comput(ProgramPart( (s +* Initialized stop(I))), (s +* Initialized
stop(I)),k) in dom I;

theorem :: SCMPDS_6:41
  for I,J being Program of SCMPDS,s being State of SCMPDS, k being
  Element of NAT st I is_closed_on s & I is_halting_on s & k < LifeSpan(
ProgramPart(s +* Initialized stop I),s +* Initialized stop I)
 holds CurInstr(ProgramPart (s +* Initialized stop I),
      Comput(ProgramPart(s +* Initialized stop I), (s +* Initialized stop I)
,k)) =
  CurInstr(ProgramPart (s +* Initialized stop (I ';' J)),
Comput(ProgramPart(s +* Initialized stop (I ';' J)), (s +* Initialized
stop (I ';' J)),k));

theorem :: SCMPDS_6:42  ::SCMPDS_5:32
  for I being halt-free Program of SCMPDS,s being State of
  SCMPDS, k being Element of NAT st I is_closed_on s & I is_halting_on s & k <
  LifeSpan(ProgramPart(s +* Initialized stop I),s +* Initialized stop I)
   holds CurInstr(ProgramPart Comput(ProgramPart( (s +*
  Initialized stop I)), (s +*
  Initialized stop I),k),Comput(ProgramPart( (s +*
  Initialized stop I)), (s +*
  Initialized stop I),k)) <> halt SCMPDS;

theorem :: SCMPDS_6:43
  for I being halt-free Program of SCMPDS,s being State of
  SCMPDS st I is_closed_on s & I is_halting_on s holds IC Comput(ProgramPart( (
s +*
  Initialized stop I)), (s +*
  Initialized stop I), LifeSpan(ProgramPart(s +* Initialized stop I),s +*
Initialized stop I)) =  card I;

theorem :: SCMPDS_6:44
  for I,J being Program of SCMPDS,s being State of SCMPDS st I
  is_closed_on s & I is_halting_on s holds I ';' Goto (card J + 1) ';' J
  is_halting_on s & I ';' Goto (card J + 1) ';' J is_closed_on s;

theorem :: SCMPDS_6:45
  for I being shiftable Program of SCMPDS st Initialized stop I c=
s1 & I is_closed_on s1 for n being Element of NAT st Shift(stop I,n) c= s2 & IC
  s2 =  n & DataPart s1 = DataPart s2 for i being Element of NAT holds IC
Comput(ProgramPart( s1), s1,i) + n = IC Comput(ProgramPart( s2), s2,i) &
 CurInstr(ProgramPart Comput(ProgramPart(s1),s1,i),Comput(ProgramPart(s1),s1,i)
)
  = CurInstr(ProgramPart Comput(ProgramPart(s2),s2,i),Comput(ProgramPart(s2),s2
,i)) &
  DataPart Comput(ProgramPart( s1), s1,i) = DataPart
  Comput(ProgramPart( s2), s2,i);

theorem :: SCMPDS_6:46  ::SCMFSA8A:61
  for s being State of SCMPDS,I being halt-free Program of
SCMPDS, J being Program of SCMPDS st I is_closed_on s & I is_halting_on s holds
  IC IExec(I ';' Goto (card J + 1) ';' J,s) = (card I + card J + 1);

theorem :: SCMPDS_6:47  ::SCMFSA8A:62
  for s being State of SCMPDS,I being halt-free Program of
SCMPDS, J being Program of SCMPDS st I is_closed_on s & I is_halting_on s holds
IExec(I ';' Goto (card J + 1) ';' J,s) = IExec(I,s) +* Start-At( (card I
  + card J + 1),SCMPDS);

theorem :: SCMPDS_6:48
  for s being State of SCMPDS,I being halt-free Program of
  SCMPDS st I is_closed_on s & I is_halting_on s holds IC IExec(I,s) =
  card I;

begin :: The construction of conditional statements

definition
  let a be Int_position,k be Integer;
  let I,J be Program of SCMPDS;
  func if=0(a,k,I,J) -> Program of SCMPDS equals
:: SCMPDS_6:def 4
  (a,k)<>0_goto (card I +2) ';'
  I ';' Goto (card J+1) ';' J;
  func if>0(a,k,I,J) -> Program of SCMPDS equals
:: SCMPDS_6:def 5
  (a,k)<=0_goto (card I +2) ';'
  I ';' Goto (card J+1) ';' J;
  func if<0(a,k,I,J) -> Program of SCMPDS equals
:: SCMPDS_6:def 6
  (a,k)>=0_goto (card I +2) ';'
  I ';' Goto (card J+1) ';' J;
end;

definition
  let a be Int_position,k be Integer;
  let I be Program of SCMPDS;
  func if=0(a,k,I) -> Program of SCMPDS equals
:: SCMPDS_6:def 7
  (a,k)<>0_goto (card I +1) ';' I;
  func if<>0(a,k,I) -> Program of SCMPDS equals
:: SCMPDS_6:def 8
  (a,k)<>0_goto 2 ';' goto (card
  I+1) ';' I;
  func if>0(a,k,I) -> Program of SCMPDS equals
:: SCMPDS_6:def 9
  (a,k)<=0_goto (card I +1) ';' I;
  func if<=0(a,k,I) -> Program of SCMPDS equals
:: SCMPDS_6:def 10
  (a,k)<=0_goto 2 ';' goto (card
  I+1) ';' I;
  func if<0(a,k,I) -> Program of SCMPDS equals
:: SCMPDS_6:def 11
  (a,k)>=0_goto (card I +1) ';' I;
  func if>=0(a,k,I) -> Program of SCMPDS equals
:: SCMPDS_6:def 12
  (a,k)>=0_goto 2 ';' goto (card
  I+1) ';' I;
end;

begin :: The computation of "if var=0 then block1 else block2"

theorem :: SCMPDS_6:49
  card if=0(a,k1,I,J) = card I + card J + 2;

theorem :: SCMPDS_6:50
   0 in dom if=0(a,k1,I,J) &  1 in dom if=0(a,k1,I,J);

theorem :: SCMPDS_6:51
  if=0(a,k1,I,J). 0 = (a,k1)<>0_goto (card I + 2);

theorem :: SCMPDS_6:52
  for s being State of SCMPDS, I,J being shiftable Program of
  SCMPDS, a being Int_position,k1 being Integer st s.DataLoc(s.a,k1)= 0 & I
is_closed_on s & I is_halting_on s holds if=0(a,k1,I,J) is_closed_on s & if=0(a
  ,k1,I,J) is_halting_on s;

theorem :: SCMPDS_6:53
  for s being State of SCMPDS,I being Program of SCMPDS,J being
shiftable Program of SCMPDS,a being Int_position,k1 being Integer st s.DataLoc(
  s.a,k1)<> 0 & J is_closed_on s & J is_halting_on s holds if=0(a,k1,I,J)
  is_closed_on s & if=0(a,k1,I,J) is_halting_on s;

theorem :: SCMPDS_6:54
  for s being State of SCMPDS,I being halt-free shiftable
Program of SCMPDS, J being shiftable Program of SCMPDS,a being Int_position,k1
  being Integer st s.DataLoc(s.a,k1)= 0 & I is_closed_on s & I is_halting_on s
holds IExec(if=0(a,k1,I,J),s) = IExec(I,s) +* Start-At( (card I + card J
  + 2),SCMPDS);

theorem :: SCMPDS_6:55
  for s being State of SCMPDS,I being Program of SCMPDS,J being
  halt-free shiftable Program of SCMPDS,a being Int_position,k1 being Integer
  st s.DataLoc(s.a,k1)<> 0 & J is_closed_on s & J is_halting_on s holds IExec(
  if=0(a,k1,I,J),s) = IExec(J,s) +*
  Start-At( (card I + card J + 2),SCMPDS);

registration
  let I,J be shiftable parahalting Program of SCMPDS, a be Int_position,k1 be
  Integer;
  cluster if=0(a,k1,I,J) -> shiftable parahalting;
end;

registration
  let I,J be halt-free Program of SCMPDS, a be Int_position,k1 be Integer;
  cluster if=0(a,k1,I,J) -> halt-free;
end;

theorem :: SCMPDS_6:56
  for s being State of SCMPDS,I,J being halt-free shiftable
  parahalting Program of SCMPDS,a being Int_position,k1 being Integer holds IC
  IExec(if=0(a,k1,I,J),s) =  (card I + card J + 2);

theorem :: SCMPDS_6:57
  for s being State of SCMPDS,I being halt-free shiftable parahalting
  Program of SCMPDS,J being shiftable Program of SCMPDS,a,b being Int_position,
  k1 being Integer st s.DataLoc(s.a,k1)= 0 holds IExec(if=0(a,k1,I,J),s).b =
  IExec(I,s).b;

theorem :: SCMPDS_6:58
  for s being State of SCMPDS,I being Program of SCMPDS,J being
  halt-free parahalting shiftable Program of SCMPDS,a,b being Int_position,k1
being Integer st s.DataLoc(s.a,k1)<> 0 holds IExec(if=0(a,k1,I,J),s).b = IExec(
  J,s).b;

begin :: The computation of "if var=0 then block"

theorem :: SCMPDS_6:59
  card if=0(a,k1,I) = card I + 1;

theorem :: SCMPDS_6:60
   0 in dom if=0(a,k1,I);

theorem :: SCMPDS_6:61
  if=0(a,k1,I). 0 = (a,k1)<>0_goto (card I + 1);

theorem :: SCMPDS_6:62
  for s being State of SCMPDS, I being shiftable Program of SCMPDS
  , a being Int_position,k1 being Integer st s.DataLoc(s.a,k1)= 0 & I
is_closed_on s & I is_halting_on s holds if=0(a,k1,I) is_closed_on s & if=0(a,
  k1,I) is_halting_on s;

theorem :: SCMPDS_6:63
  for s being State of SCMPDS,I being Program of SCMPDS, a being
  Int_position, k1 being Integer st s.DataLoc(s.a,k1)<> 0 holds if=0(a,k1,I)
  is_closed_on s & if=0(a,k1,I) is_halting_on s;

theorem :: SCMPDS_6:64
  for s being State of SCMPDS,I being halt-free shiftable
Program of SCMPDS, a being Int_position,k1 being Integer st s.DataLoc(s.a,k1)=
0 & I is_closed_on s & I is_halting_on s holds IExec(if=0(a,k1,I),s) = IExec(I,
  s) +* Start-At((card I+1),SCMPDS);

theorem :: SCMPDS_6:65
  for s being State of SCMPDS,I being Program of SCMPDS,a being
Int_position, k1 being Integer st s.DataLoc(s.a,k1)<> 0 holds IExec(if=0(a,k1,I
  ),s) = s +* Start-At((card I+1),SCMPDS);

registration
  let I be shiftable parahalting Program of SCMPDS, a be Int_position,k1 be
  Integer;
  cluster if=0(a,k1,I) -> shiftable parahalting;
end;

registration
  let I be halt-free Program of SCMPDS, a be Int_position,k1 be Integer;
  cluster if=0(a,k1,I) -> halt-free;
end;

theorem :: SCMPDS_6:66
  for s being State of SCMPDS,I being halt-free shiftable parahalting
Program of SCMPDS,a being Int_position,k1 being Integer holds IC IExec(if=0(a,
  k1,I),s) =  (card I + 1);

theorem :: SCMPDS_6:67
  for s being State of SCMPDS,I being halt-free shiftable parahalting
Program of SCMPDS,a,b being Int_position,k1 being Integer st s.DataLoc(s.a,k1)=
  0 holds IExec(if=0(a,k1,I),s).b = IExec(I,s).b;

theorem :: SCMPDS_6:68
  for s being State of SCMPDS,I being Program of SCMPDS,a,b being
Int_position, k1 being Integer st s.DataLoc(s.a,k1)<> 0 holds IExec(if=0(a,k1,I
  ),s).b = s.b;

begin :: The computation of "if var<>0 then block"

theorem :: SCMPDS_6:69
  card if<>0(a,k1,I) = card I + 2;

theorem :: SCMPDS_6:70
   0 in dom if<>0(a,k1,I) &  1 in dom if<>0(a,k1,I);

theorem :: SCMPDS_6:71
  if<>0(a,k1,I). 0 = (a,k1)<>0_goto 2 & if<>0(a,k1,I). 1 =
  goto (card I + 1);

theorem :: SCMPDS_6:72
  for s being State of SCMPDS, I being shiftable Program of SCMPDS
  , a being Int_position,k1 being Integer st s.DataLoc(s.a,k1)<>0 & I
is_closed_on s & I is_halting_on s holds if<>0(a,k1,I) is_closed_on s & if<>0(a
  ,k1,I) is_halting_on s;

theorem :: SCMPDS_6:73
  for s being State of SCMPDS,I being Program of SCMPDS, a being
  Int_position, k1 being Integer st s.DataLoc(s.a,k1)= 0 holds if<>0(a,k1,I)
  is_closed_on s & if<>0(a,k1,I) is_halting_on s;

theorem :: SCMPDS_6:74
  for s being State of SCMPDS,I being halt-free shiftable
  Program of SCMPDS, a being Int_position,k1 being Integer st s.DataLoc(s.a,k1)
  <> 0 & I is_closed_on s & I is_halting_on s holds IExec(if<>0(a,k1,I),s) =
  IExec(I,s) +* Start-At((card I+2),SCMPDS);

theorem :: SCMPDS_6:75
  for s being State of SCMPDS,I being Program of SCMPDS,a being
Int_position, k1 being Integer st s.DataLoc(s.a,k1)= 0 holds IExec(if<>0(a,k1,I
  ),s) = s +* Start-At((card I+2),SCMPDS);

registration
  let I be shiftable parahalting Program of SCMPDS, a be Int_position,k1 be
  Integer;
  cluster if<>0(a,k1,I) -> shiftable parahalting;
end;

registration
  let I be halt-free Program of SCMPDS, a be Int_position,k1 be Integer;
  cluster if<>0(a,k1,I) -> halt-free;
end;

theorem :: SCMPDS_6:76
  for s being State of SCMPDS,I being halt-free shiftable parahalting
Program of SCMPDS,a being Int_position,k1 being Integer holds IC IExec(if<>0(a,
  k1,I),s) =  (card I + 2);

theorem :: SCMPDS_6:77
  for s being State of SCMPDS,I being halt-free shiftable parahalting
Program of SCMPDS,a,b being Int_position,k1 being Integer st s.DataLoc(s.a,k1)
  <> 0 holds IExec(if<>0(a,k1,I),s).b = IExec(I,s).b;

theorem :: SCMPDS_6:78
  for s being State of SCMPDS,I being Program of SCMPDS,a,b being
Int_position, k1 being Integer st s.DataLoc(s.a,k1)= 0 holds IExec(if<>0(a,k1,I
  ),s).b = s.b;

begin :: The computation of "if var>0 then block1 else block2"

theorem :: SCMPDS_6:79
  card if>0(a,k1,I,J) = card I + card J + 2;

theorem :: SCMPDS_6:80
   0 in dom if>0(a,k1,I,J) &  1 in dom if>0(a,k1,I,J);

theorem :: SCMPDS_6:81
  if>0(a,k1,I,J). 0 = (a,k1)<=0_goto (card I + 2);

theorem :: SCMPDS_6:82
  for s being State of SCMPDS, I,J being shiftable Program of
  SCMPDS, a being Int_position,k1 being Integer st s.DataLoc(s.a,k1)>0 & I
is_closed_on s & I is_halting_on s holds if>0(a,k1,I,J) is_closed_on s & if>0(a
  ,k1,I,J) is_halting_on s;

theorem :: SCMPDS_6:83
  for s being State of SCMPDS,I being Program of SCMPDS,J being
shiftable Program of SCMPDS,a being Int_position,k1 being Integer st s.DataLoc(
  s.a,k1) <= 0 & J is_closed_on s & J is_halting_on s holds if>0(a,k1,I,J)
  is_closed_on s & if>0(a,k1,I,J) is_halting_on s;

theorem :: SCMPDS_6:84
  for s being State of SCMPDS,I being halt-free shiftable
Program of SCMPDS, J being shiftable Program of SCMPDS,a being Int_position,k1
  being Integer st s.DataLoc(s.a,k1) > 0 & I is_closed_on s & I is_halting_on s
holds IExec(if>0(a,k1,I,J),s) = IExec(I,s) +* Start-At( (card I + card J
  + 2),SCMPDS);

theorem :: SCMPDS_6:85
  for s being State of SCMPDS,I being Program of SCMPDS,J being
  halt-free shiftable Program of SCMPDS,a being Int_position,k1 being Integer
  st s.DataLoc(s.a,k1) <= 0 & J is_closed_on s & J is_halting_on s holds IExec(
  if>0(a,k1,I,J),s) = IExec(J,s) +* Start-At((card I+card J+2),SCMPDS);

registration
  let I,J be shiftable parahalting Program of SCMPDS, a be Int_position,k1 be
  Integer;
  cluster if>0(a,k1,I,J) -> shiftable parahalting;
end;

registration
  let I,J be halt-free Program of SCMPDS, a be Int_position,k1 be Integer;
  cluster if>0(a,k1,I,J) -> halt-free;
end;

theorem :: SCMPDS_6:86
  for s being State of SCMPDS,I,J being halt-free shiftable
  parahalting Program of SCMPDS,a being Int_position,k1 being Integer holds IC
  IExec(if>0(a,k1,I,J),s) =  (card I + card J + 2);

theorem :: SCMPDS_6:87
  for s being State of SCMPDS,I being halt-free shiftable parahalting
  Program of SCMPDS,J being shiftable Program of SCMPDS,a,b being Int_position,
k1 being Integer st s.DataLoc(s.a,k1)>0 holds IExec(if>0(a,k1,I,J),s).b = IExec
  (I,s).b;

theorem :: SCMPDS_6:88
  for s being State of SCMPDS,I being Program of SCMPDS,J being
  halt-free parahalting shiftable Program of SCMPDS,a,b being Int_position,k1
being Integer st s.DataLoc(s.a,k1) <= 0 holds IExec(if>0(a,k1,I,J),s).b = IExec
  (J,s).b;

begin :: The computation of "if var>0 then block"

theorem :: SCMPDS_6:89
  card if>0(a,k1,I) = card I + 1;

theorem :: SCMPDS_6:90
   0 in dom if>0(a,k1,I);

theorem :: SCMPDS_6:91
  if>0(a,k1,I). 0 = (a,k1)<=0_goto (card I + 1);

theorem :: SCMPDS_6:92
  for s being State of SCMPDS, I being shiftable Program of SCMPDS
  , a being Int_position,k1 being Integer st s.DataLoc(s.a,k1)> 0 & I
is_closed_on s & I is_halting_on s holds if>0(a,k1,I) is_closed_on s & if>0(a,
  k1,I) is_halting_on s;

theorem :: SCMPDS_6:93
  for s being State of SCMPDS,I being Program of SCMPDS, a being
  Int_position, k1 being Integer st s.DataLoc(s.a,k1) <= 0 holds if>0(a,k1,I)
  is_closed_on s & if>0(a,k1,I) is_halting_on s;

theorem :: SCMPDS_6:94
  for s being State of SCMPDS,I being halt-free shiftable
Program of SCMPDS, a being Int_position,k1 being Integer st s.DataLoc(s.a,k1)>
0 & I is_closed_on s & I is_halting_on s holds IExec(if>0(a,k1,I),s) = IExec(I,
  s) +* Start-At((card I+1),SCMPDS);

theorem :: SCMPDS_6:95
  for s being State of SCMPDS,I being Program of SCMPDS,a being
Int_position, k1 being Integer st s.DataLoc(s.a,k1) <= 0 holds IExec(if>0(a,k1,
  I),s) = s +* Start-At((card I+1),SCMPDS);

registration
  let I be shiftable parahalting Program of SCMPDS, a be Int_position,k1 be
  Integer;
  cluster if>0(a,k1,I) -> shiftable parahalting;
end;

registration
  let I be halt-free Program of SCMPDS, a be Int_position,k1 be Integer;
  cluster if>0(a,k1,I) -> halt-free;
end;

theorem :: SCMPDS_6:96
  for s being State of SCMPDS,I being halt-free shiftable parahalting
Program of SCMPDS,a being Int_position,k1 being Integer holds IC IExec(if>0(a,
  k1,I),s) =  (card I + 1);

theorem :: SCMPDS_6:97
  for s being State of SCMPDS,I being halt-free shiftable parahalting
Program of SCMPDS,a,b being Int_position,k1 being Integer st s.DataLoc(s.a,k1)>
  0 holds IExec(if>0(a,k1,I),s).b = IExec(I,s).b;

theorem :: SCMPDS_6:98
  for s being State of SCMPDS,I being Program of SCMPDS,a,b being
Int_position, k1 being Integer st s.DataLoc(s.a,k1) <= 0 holds IExec(if>0(a,k1,
  I),s).b = s.b;

begin :: The computation of "if var<=0 then block"

theorem :: SCMPDS_6:99
  card if<=0(a,k1,I) = card I + 2;

theorem :: SCMPDS_6:100
   0 in dom if<=0(a,k1,I) &  1 in dom if<=0(a,k1,I);

theorem :: SCMPDS_6:101
  if<=0(a,k1,I). 0 = (a,k1)<=0_goto 2 & if<=0(a,k1,I). 1 =
  goto (card I + 1);

theorem :: SCMPDS_6:102
  for s being State of SCMPDS, I being shiftable Program of
  SCMPDS, a being Int_position,k1 being Integer st s.DataLoc(s.a,k1) <= 0 & I
is_closed_on s & I is_halting_on s holds if<=0(a,k1,I) is_closed_on s & if<=0(a
  ,k1,I) is_halting_on s;

theorem :: SCMPDS_6:103
  for s being State of SCMPDS,I being Program of SCMPDS, a being
  Int_position, k1 being Integer st s.DataLoc(s.a,k1) > 0 holds if<=0(a,k1,I)
  is_closed_on s & if<=0(a,k1,I) is_halting_on s;

theorem :: SCMPDS_6:104
  for s being State of SCMPDS,I being halt-free shiftable
  Program of SCMPDS, a being Int_position,k1 being Integer st s.DataLoc(s.a,k1)
  <= 0 & I is_closed_on s & I is_halting_on s holds IExec(if<=0(a,k1,I),s) =
  IExec(I,s) +* Start-At((card I+2),SCMPDS);

theorem :: SCMPDS_6:105
  for s being State of SCMPDS,I being Program of SCMPDS,a being
Int_position, k1 being Integer st s.DataLoc(s.a,k1) > 0 holds IExec(if<=0(a,k1,
  I),s) = s +* Start-At((card I+2),SCMPDS);

registration
  let I be shiftable parahalting Program of SCMPDS, a be Int_position,k1 be
  Integer;
  cluster if<=0(a,k1,I) -> shiftable parahalting;
end;

registration
  let I be halt-free Program of SCMPDS, a be Int_position,k1 be Integer;
  cluster if<=0(a,k1,I) -> halt-free;
end;

theorem :: SCMPDS_6:106
  for s being State of SCMPDS,I being halt-free shiftable parahalting
Program of SCMPDS,a being Int_position,k1 being Integer holds IC IExec(if<=0(a,
  k1,I),s) =  (card I + 2);

theorem :: SCMPDS_6:107
  for s being State of SCMPDS,I being halt-free shiftable parahalting
Program of SCMPDS,a,b being Int_position,k1 being Integer st s.DataLoc(s.a,k1)
  <= 0 holds IExec(if<=0(a,k1,I),s).b = IExec(I,s).b;

theorem :: SCMPDS_6:108
  for s being State of SCMPDS,I being Program of SCMPDS,a,b being
Int_position, k1 being Integer st s.DataLoc(s.a,k1) > 0 holds IExec(if<=0(a,k1,
  I),s).b = s.b;

begin :: The computation of "if var<0 then block1 else block2"

theorem :: SCMPDS_6:109
  card if<0(a,k1,I,J) = card I + card J + 2;

theorem :: SCMPDS_6:110
   0 in dom if<0(a,k1,I,J) &  1 in dom if<0(a,k1,I,J);

theorem :: SCMPDS_6:111
  if<0(a,k1,I,J). 0 = (a,k1)>=0_goto (card I + 2);

theorem :: SCMPDS_6:112
  for s being State of SCMPDS, I,J being shiftable Program of
  SCMPDS, a being Int_position,k1 being Integer st s.DataLoc(s.a,k1)<0 & I
is_closed_on s & I is_halting_on s holds if<0(a,k1,I,J) is_closed_on s & if<0(a
  ,k1,I,J) is_halting_on s;

theorem :: SCMPDS_6:113
  for s being State of SCMPDS,I being Program of SCMPDS,J being
shiftable Program of SCMPDS,a being Int_position,k1 being Integer st s.DataLoc(
  s.a,k1) >= 0 & J is_closed_on s & J is_halting_on s holds if<0(a,k1,I,J)
  is_closed_on s & if<0(a,k1,I,J) is_halting_on s;

theorem :: SCMPDS_6:114
  for s being State of SCMPDS,I being halt-free shiftable
Program of SCMPDS, J being shiftable Program of SCMPDS,a being Int_position,k1
  being Integer st s.DataLoc(s.a,k1) < 0 & I is_closed_on s & I is_halting_on s
holds IExec(if<0(a,k1,I,J),s) = IExec(I,s) +* Start-At( (card I + card J
  + 2),SCMPDS);

theorem :: SCMPDS_6:115
  for s being State of SCMPDS,I being Program of SCMPDS,J being
  halt-free shiftable Program of SCMPDS,a being Int_position,k1 being Integer
  st s.DataLoc(s.a,k1) >= 0 & J is_closed_on s & J is_halting_on s holds IExec(
  if<0(a,k1,I,J),s) = IExec(J,s) +* Start-At((card I+card J+2),SCMPDS);

registration
  let I,J be shiftable parahalting Program of SCMPDS, a be Int_position,k1 be
  Integer;
  cluster if<0(a,k1,I,J) -> shiftable parahalting;
end;

registration
  let I,J be halt-free Program of SCMPDS, a be Int_position,k1 be Integer;
  cluster if<0(a,k1,I,J) -> halt-free;
end;

theorem :: SCMPDS_6:116
  for s being State of SCMPDS,I,J being halt-free shiftable
  parahalting Program of SCMPDS,a being Int_position,k1 being Integer holds IC
  IExec(if<0(a,k1,I,J),s) =  (card I + card J + 2);

theorem :: SCMPDS_6:117
  for s being State of SCMPDS,I being halt-free shiftable parahalting
  Program of SCMPDS,J being shiftable Program of SCMPDS,a,b being Int_position,
k1 being Integer st s.DataLoc(s.a,k1)<0 holds IExec(if<0(a,k1,I,J),s).b = IExec
  (I,s).b;

theorem :: SCMPDS_6:118
  for s being State of SCMPDS,I being Program of SCMPDS,J being
  halt-free parahalting shiftable Program of SCMPDS,a,b being Int_position,k1
being Integer st s.DataLoc(s.a,k1) >= 0 holds IExec(if<0(a,k1,I,J),s).b = IExec
  (J,s).b;

begin :: The computation of "if var<0 then block"

theorem :: SCMPDS_6:119
  card if<0(a,k1,I) = card I + 1;

theorem :: SCMPDS_6:120
   0 in dom if<0(a,k1,I);

theorem :: SCMPDS_6:121
  if<0(a,k1,I). 0 = (a,k1)>=0_goto (card I + 1);

theorem :: SCMPDS_6:122
  for s being State of SCMPDS, I being shiftable Program of
  SCMPDS, a being Int_position,k1 being Integer st s.DataLoc(s.a,k1) < 0 & I
is_closed_on s & I is_halting_on s holds if<0(a,k1,I) is_closed_on s & if<0(a,
  k1,I) is_halting_on s;

theorem :: SCMPDS_6:123
  for s being State of SCMPDS,I being Program of SCMPDS, a being
  Int_position, k1 being Integer st s.DataLoc(s.a,k1) >= 0 holds if<0(a,k1,I)
  is_closed_on s & if<0(a,k1,I) is_halting_on s;

theorem :: SCMPDS_6:124
  for s being State of SCMPDS,I being halt-free shiftable
Program of SCMPDS, a being Int_position,k1 being Integer st s.DataLoc(s.a,k1) <
0 & I is_closed_on s & I is_halting_on s holds IExec(if<0(a,k1,I),s) = IExec(I,
  s) +* Start-At((card I+1),SCMPDS);

theorem :: SCMPDS_6:125
  for s being State of SCMPDS,I being Program of SCMPDS,a being
Int_position, k1 being Integer st s.DataLoc(s.a,k1) >= 0 holds IExec(if<0(a,k1,
  I),s) = s +* Start-At((card I+1),SCMPDS);

registration
  let I be shiftable parahalting Program of SCMPDS, a be Int_position,k1 be
  Integer;
  cluster if<0(a,k1,I) -> shiftable parahalting;
end;

registration
  let I be halt-free Program of SCMPDS, a be Int_position,k1 be Integer;
  cluster if<0(a,k1,I) -> halt-free;
end;

theorem :: SCMPDS_6:126
  for s being State of SCMPDS,I being halt-free shiftable parahalting
Program of SCMPDS,a being Int_position,k1 being Integer holds IC IExec(if<0(a,
  k1,I),s) =  (card I + 1);

theorem :: SCMPDS_6:127
  for s being State of SCMPDS,I being halt-free shiftable parahalting
Program of SCMPDS,a,b being Int_position,k1 being Integer st s.DataLoc(s.a,k1)
  < 0 holds IExec(if<0(a,k1,I),s).b = IExec(I,s).b;

theorem :: SCMPDS_6:128
  for s being State of SCMPDS,I being Program of SCMPDS,a,b being
Int_position, k1 being Integer st s.DataLoc(s.a,k1) >= 0 holds IExec(if<0(a,k1,
  I),s).b = s.b;

begin :: The computation of "if var>=0 then block"

theorem :: SCMPDS_6:129
  card if>=0(a,k1,I) = card I + 2;

theorem :: SCMPDS_6:130
   0 in dom if>=0(a,k1,I) &  1 in dom if>=0(a,k1,I);

theorem :: SCMPDS_6:131
  if>=0(a,k1,I). 0 = (a,k1)>=0_goto 2 & if>=0(a,k1,I). 1 =
  goto (card I + 1);

theorem :: SCMPDS_6:132
  for s being State of SCMPDS, I being shiftable Program of
  SCMPDS, a being Int_position,k1 being Integer st s.DataLoc(s.a,k1) >= 0 & I
is_closed_on s & I is_halting_on s holds if>=0(a,k1,I) is_closed_on s & if>=0(a
  ,k1,I) is_halting_on s;

theorem :: SCMPDS_6:133
  for s being State of SCMPDS,I being Program of SCMPDS, a being
  Int_position, k1 being Integer st s.DataLoc(s.a,k1) < 0 holds if>=0(a,k1,I)
  is_closed_on s & if>=0(a,k1,I) is_halting_on s;

theorem :: SCMPDS_6:134
  for s being State of SCMPDS,I being halt-free shiftable
  Program of SCMPDS, a being Int_position,k1 being Integer st s.DataLoc(s.a,k1)
  >= 0 & I is_closed_on s & I is_halting_on s holds IExec(if>=0(a,k1,I),s) =
  IExec(I,s) +* Start-At((card I+2),SCMPDS);

theorem :: SCMPDS_6:135
  for s being State of SCMPDS,I being Program of SCMPDS,a being
Int_position, k1 being Integer st s.DataLoc(s.a,k1) < 0 holds IExec(if>=0(a,k1,
  I),s) = s +* Start-At((card I+2),SCMPDS);

registration
  let I be shiftable parahalting Program of SCMPDS, a be Int_position,k1 be
  Integer;
  cluster if>=0(a,k1,I) -> shiftable parahalting;
end;

registration
  let I be halt-free Program of SCMPDS, a be Int_position,k1 be Integer;
  cluster if>=0(a,k1,I) -> halt-free;
end;

theorem :: SCMPDS_6:136
  for s being State of SCMPDS,I being halt-free shiftable parahalting
Program of SCMPDS,a being Int_position,k1 being Integer holds IC IExec(if>=0(a,
  k1,I),s) =  (card I + 2);

theorem :: SCMPDS_6:137
  for s being State of SCMPDS,I being halt-free shiftable parahalting
Program of SCMPDS,a,b being Int_position,k1 being Integer st s.DataLoc(s.a,k1)
  >= 0 holds IExec(if>=0(a,k1,I),s).b = IExec(I,s).b;

theorem :: SCMPDS_6:138
  for s being State of SCMPDS,I being Program of SCMPDS,a,b being
Int_position, k1 being Integer st s.DataLoc(s.a,k1) < 0 holds IExec(if>=0(a,k1,
  I),s).b = s.b;

