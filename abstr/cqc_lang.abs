:: A Classical First Order Language
::  by Czes{\l}aw Byli\'nski
::
:: Received May 11, 1990
:: Copyright (c) 1990 Association of Mizar Users

environ

 vocabularies CAT_1, FUNCOP_1, FUNCT_1, RELAT_1, BOOLE, QC_LANG1, FINSEQ_1,
      PARTFUN1, QC_LANG3, ZF_MODEL, ZF_LANG, CQC_LANG, CAT_4, FUNCT_4, ARYTM;
 notations TARSKI, XBOOLE_0, ENUMSET1, SUBSET_1, NUMBERS, RELAT_1, FUNCT_1,
      FUNCT_2, BINOP_1, PARTFUN1, FUNCOP_1, FUNCT_4, FINSEQ_1, QC_LANG1,
      QC_LANG2, QC_LANG3, XXREAL_0, NAT_1;
 constructors ENUMSET1, PARTFUN1, BINOP_1, FUNCOP_1, FUNCT_4, XXREAL_0,
      MEMBERED, QC_LANG2, QC_LANG3, VALUED_1, SEQ_1;
 registrations XBOOLE_0, SUBSET_1, RELSET_1, FUNCOP_1, FUNCT_4, MEMBERED,
      QC_LANG1, XXREAL_0, VALUED_1, FUNCT_2;
 requirements NUMERALS, SUBSET, BOOLE;


begin

reserve i,j,k for Element of NAT;

canceled 4;

theorem :: CQC_LANG:5
  for x,y be set holds dom(x .--> y) = {x} & rng(x .--> y) = {y};

theorem :: CQC_LANG:6
  for x,y be set holds (x .--> y).x = y;

reserve x,y for bound_QC-variable;
reserve a for free_QC-variable;
reserve p,q for Element of QC-WFF;
reserve l,l1,l2,ll for FinSequence of QC-variables;

theorem :: CQC_LANG:7
  for x being set holds x in QC-variables iff
  x in fixed_QC-variables or x in free_QC-variables or x in bound_QC-variables;

definition
  mode Substitution is PartFunc of free_QC-variables,QC-variables;
end;

reserve f for Substitution;

definition
  let l,f;
  canceled 2;
  func Subst(l,f) -> FinSequence of QC-variables means
:: CQC_LANG:def 3

  len it = len l &
  for k st 1 <= k & k <= len l holds
  (l.k in dom f implies it.k = f.(l.k)) & (not l.k in
  dom f implies it.k = l.k);
end;

definition
  let k;
  let l be QC-variable_list of k;
  let f;
  redefine func Subst(l,f) -> QC-variable_list of k;
end;

canceled 2;

theorem :: CQC_LANG:10
  a .--> x is Substitution;

definition
  let a,x;
  redefine func a .--> x -> Substitution;
end;

theorem :: CQC_LANG:11
  f = a .--> x & ll = Subst(l,f) & 1 <= k & k <= len l implies
  (l.k = a implies ll.k = x) & (l.k <> a implies ll.k = l.k);

definition
  func CQC-WFF -> Subset of QC-WFF equals
:: CQC_LANG:def 4
  {s where s is QC-formula: Fixed s = {} & Free s = {} };
end;

registration
  cluster CQC-WFF -> non empty;
end;

canceled;

theorem :: CQC_LANG:13
  p is Element of CQC-WFF iff Fixed p = {} & Free p = {};

definition
  let k;
  let IT be QC-variable_list of k;
  attr IT is CQC-variable_list-like means
:: CQC_LANG:def 5

  rng IT c= bound_QC-variables;
end;

registration
  let k;
  cluster CQC-variable_list-like QC-variable_list of k;
end;

definition
  let k;
  mode CQC-variable_list of k is CQC-variable_list-like QC-variable_list of k;
end;

canceled;

theorem :: CQC_LANG:15
  for l being QC-variable_list of k holds l is CQC-variable_list of k iff
  { l.i : 1 <= i & i <= len l & l.i in free_QC-variables } = {} &
  { l.j : 1 <= j & j <= len l & l.j in fixed_QC-variables } = {};

reserve r,s for Element of CQC-WFF;

theorem :: CQC_LANG:16
  VERUM is Element of CQC-WFF;

theorem :: CQC_LANG:17
  for P being QC-pred_symbol of k for l being QC-variable_list of k
  holds P!l is Element of CQC-WFF iff
  { l.i : 1 <= i & i <= len l & l.i in free_QC-variables } = {} &
  { l.j : 1 <= j & j <= len l & l.j in fixed_QC-variables } = {};

definition
  let k;
  let P be QC-pred_symbol of k;
  let l be CQC-variable_list of k;
  redefine func P!l -> Element of CQC-WFF;
end;

theorem :: CQC_LANG:18
  'not' p is Element of CQC-WFF iff p is Element of CQC-WFF;

theorem :: CQC_LANG:19
  p '&' q is Element of CQC-WFF
  iff p is Element of CQC-WFF & q is Element of CQC-WFF;

definition
  redefine
  func VERUM -> Element of CQC-WFF;
  let r;
  func 'not' r -> Element of CQC-WFF;
  let s;
  func r '&' s -> Element of CQC-WFF;
end;

theorem :: CQC_LANG:20
  r => s is Element of CQC-WFF;

theorem :: CQC_LANG:21
  r 'or' s is Element of CQC-WFF;

theorem :: CQC_LANG:22
  r <=> s is Element of CQC-WFF;

definition
  let r,s;
  redefine
  func r => s -> Element of CQC-WFF;
  func r 'or' s -> Element of CQC-WFF;
  func r <=> s -> Element of CQC-WFF;
end;

theorem :: CQC_LANG:23
  All(x,p) is Element of CQC-WFF iff p is Element of CQC-WFF;

definition
  let x,r;
  redefine func All(x,r) -> Element of CQC-WFF;
end;

theorem :: CQC_LANG:24
  Ex(x,r) is Element of CQC-WFF;

definition
  let x,r;
  redefine func Ex(x,r) -> Element of CQC-WFF;
end;

scheme :: CQC_LANG:sch 1
 CQCInd { P[set] }: for r holds P[r]
provided
 for r,s,x,k for l being CQC-variable_list of k
for P being QC-pred_symbol of k holds P[VERUM] & P[P!l] &
(P[r] implies P['not' r]) & (P[r] & P[s] implies P[r '&' s]) &
(P[r] implies P[All(x, r)]);

scheme :: CQC_LANG:sch 2
 CQCFuncEx { D() -> non empty set, V() -> (Element of D()),
  A(set,set,set) -> (Element of D()), N(set) -> (Element of D()),
  C(set,set) -> (Element of D()), Q(set,set) -> Element of D()} :
  ex F being Function of CQC-WFF, D() st F.VERUM = V() &
  for r,s,x,k for l being CQC-variable_list of k
  for P being QC-pred_symbol of k holds F.(P!l) = A(k,P,l) &
  F.('not' r) = N(F.r) & F.(r '&' s) = C(F.r,F.s) & F.All(x,r) = Q(x,F.r);

scheme :: CQC_LANG:sch 3
 CQCFuncUniq { D() -> non empty set, F1() -> (Function of CQC-WFF, D()),
  F2() -> (Function of CQC-WFF, D()), V() -> (Element of D()),
  A(set,set,set) -> (Element of D()), N(set) -> (Element of D()),
  C(set,set) -> (Element of D()), Q(set,set) -> Element of D()} : F1() = F2()
provided
 F1().VERUM = V() & for r,s,x,k for l being CQC-variable_list of k
for P being QC-pred_symbol of k holds F1().(P!l) = A(k,P,l) &
F1().('not' r) = N(F1().r) & F1().(r '&' s) = C(F1().r,F1().s) &
F1().All(x,r) = Q(x,F1().r)
and
 F2().VERUM = V() & for r,s,x,k for l being CQC-variable_list of k
for P being QC-pred_symbol of k holds F2().(P!l) = A(k,P,l) &
F2().('not' r) = N(F2().r) & F2().(r '&' s) = C(F2().r,F2().s) &
F2().All(x,r) = Q(x,F2().r);

scheme :: CQC_LANG:sch 4
 CQCDefcorrectness { D() -> non empty set, p() -> (Element of CQC-WFF),
  V() -> (Element of D()), A(set,set,set) -> (Element of D()),
  N(set) -> (Element of D()), C(set,set) -> (Element of D()),
  Q(set,set) -> Element of D()} : (ex d being Element of D() st
  ex F being Function of CQC-WFF, D() st d = F.p() & F.VERUM = V() &
  for r,s,x,k for l being CQC-variable_list of k
  for P being QC-pred_symbol of k holds F.(P!l) = A(k,P,l) &
  F.('not' r) = N(F.r) & F.(r '&' s) = C(F.r,F.s) & F.All(x,r) = Q(x,F.r) )
  & (for d1,d2 being Element of D() st
  (ex F being Function of CQC-WFF, D() st d1 = F.p() & F.VERUM = V() &
  for r,s,x,k for l being CQC-variable_list of k
  for P being QC-pred_symbol of k holds F.(P!l) = A(k,P,l) &
  F.('not' r) = N(F.r) & F.(r '&' s) = C(F.r,F.s) & F.All(x,r) = Q(x,F.r) ) &
  (ex F being Function of CQC-WFF, D() st d2 = F.p() & F.VERUM = V() &
  for r,s,x,k for l being CQC-variable_list of k
  for P being QC-pred_symbol of k holds F.(P!l) = A(k,P,l) &
  F.('not' r) = N(F.r) & F.(r '&' s) = C(F.r,F.s) & F.All(x,r) = Q(x,F.r) )
  holds d1 = d2);

scheme :: CQC_LANG:sch 5
 CQCDefVERUM { D() -> non empty set, F(set) -> (Element of D()),
  V() -> (Element of D()), A(set,set,set) -> (Element of D()),
  N(set) -> (Element of D()), C(set,set) -> (Element of D()),
  Q(set,set) -> Element of D()} : F(VERUM) = V()
provided
 for p being (Element of CQC-WFF), d being Element of D() holds
d = F(p) iff ex F being Function of CQC-WFF, D() st d = F.p & F.VERUM = V() &
for r,s,x,k for l being CQC-variable_list of k
for P being QC-pred_symbol of k holds F.(P!l) = A(k,P,l) &
F.('not' r) = N(F.r) & F.(r '&' s) = C(F.r,F.s) & F.All(x,r) = Q(x,F.r);

scheme :: CQC_LANG:sch 6
 CQCDefatomic { D() -> non empty set, V() -> (Element of D()),
  F(set) -> (Element of D()), A(set,set,set) -> (Element of D()),
  k() -> Element of NAT, P() -> (QC-pred_symbol of k()),
  l() -> (CQC-variable_list of k()), N(set) -> (Element of D()),
  C(set,set) -> (Element of D()), Q(set,set) -> Element of D()} :
  F(P()!l()) = A(k(),P(),l())
provided
 for p being (Element of CQC-WFF), d being Element of D() holds
d = F(p) iff ex F being Function of CQC-WFF, D() st d = F.p & F.VERUM = V() &
for r,s,x,k for l being CQC-variable_list of k
for P being QC-pred_symbol of k holds F.(P!l) = A(k,P,l) &
F.('not' r) = N(F.r) & F.(r '&' s) = C(F.r,F.s) & F.All(x,r) = Q(x,F.r);

scheme :: CQC_LANG:sch 7
 CQCDefnegative { D() -> non empty set, F(set) -> (Element of D()),
  V() -> (Element of D()), A(set,set,set) -> (Element of D()),
  N(set) -> (Element of D()), r() -> (Element of CQC-WFF),
  C(set,set) -> (Element of D()), Q(set,set) -> Element of D()} :
  F('not' r()) = N(F(r()))
provided
 for p being (Element of CQC-WFF), d being Element of D() holds
d = F(p) iff ex F being Function of CQC-WFF, D() st d = F.p & F.VERUM = V() &
for r,s,x,k for l being CQC-variable_list of k
for P being QC-pred_symbol of k holds F.(P!l) = A(k,P,l) &
F.('not' r) = N(F.r) & F.(r '&' s) = C(F.r,F.s) & F.All(x,r) = Q(x,F.r);

scheme :: CQC_LANG:sch 8
 QCDefconjunctive { D() -> non empty set, F(set) -> (Element of D()),
  V() -> (Element of D()), A(set,set,set) -> (Element of D()),
  N(set) -> (Element of D()), C(set,set) -> (Element of D()),
  r() -> (Element of CQC-WFF), s() -> (Element of CQC-WFF),
  Q(set,set) -> Element of D()} : F(r() '&' s()) = C(F(r()), F(s()))
provided
 for p being (Element of CQC-WFF), d being Element of D() holds
d = F(p) iff ex F being Function of CQC-WFF, D() st d = F.p & F.VERUM = V() &
for r,s,x,k for l being CQC-variable_list of k
for P being QC-pred_symbol of k holds F.(P!l) = A(k,P,l) &
F.('not' r) = N(F.r) & F.(r '&' s) = C(F.r,F.s) & F.All(x,r) = Q(x,F.r);

scheme :: CQC_LANG:sch 9
 QCDefuniversal { D() -> non empty set, F(set) -> (Element of D()),
  V() -> (Element of D()), A(set,set,set) -> (Element of D()),
  N(set) -> (Element of D()), C(set,set) -> (Element of D()),
  Q(set,set) -> (Element of D()), x() -> bound_QC-variable,
  r() -> Element of CQC-WFF} : F(All(x(),r())) = Q(x(),F(r()))
provided
 for p being (Element of CQC-WFF), d being Element of D() holds
d = F(p) iff ex F being Function of CQC-WFF, D() st d = F.p & F.VERUM = V() &
for r,s,x,k for l being CQC-variable_list of k
for P being QC-pred_symbol of k holds F.(P!l) = A(k,P,l) &
F.('not' r) = N(F.r) & F.(r '&' s) = C(F.r,F.s) & F.All(x,r) = Q(x,F.r);

definition
  let p,x;
  func p.x -> Element of QC-WFF means
:: CQC_LANG:def 6

  ex F being Function of QC-WFF,QC-WFF st it = F.p &
  for q holds F.VERUM = VERUM & (q is atomic implies
  F.q = (the_pred_symbol_of q)!Subst(the_arguments_of q,a.0.-->x)) &
  (q is negative implies F.q = 'not' (F.the_argument_of q) ) &
  (q is conjunctive implies F.q = (F.the_left_argument_of q) '&'
  (F.the_right_argument_of q)) & (q is universal implies
  F.q = IFEQ(bound_in q,x,q,All(bound_in q,F.the_scope_of q)));
end;

canceled 3;

theorem :: CQC_LANG:28
  VERUM.x = VERUM;

theorem :: CQC_LANG:29
  p is atomic implies
  p.x = (the_pred_symbol_of p)!Subst(the_arguments_of p,a.0.-->x);

theorem :: CQC_LANG:30
  for P being QC-pred_symbol of k for l being QC-variable_list of k
  holds (P!l).x = P!Subst(l,a.0.-->x);

theorem :: CQC_LANG:31
  p is negative implies p.x = 'not'((the_argument_of p).x);

theorem :: CQC_LANG:32
  ('not' p).x = 'not'(p.x);

theorem :: CQC_LANG:33
  p is conjunctive implies
  p.x = ((the_left_argument_of p).x) '&' ((the_right_argument_of p).x);

theorem :: CQC_LANG:34
  (p '&' q).x = (p.x) '&' (q.x);

theorem :: CQC_LANG:35
  p is universal & bound_in p = x implies p.x = p;

theorem :: CQC_LANG:36
  p is universal & bound_in p <> x
  implies p.x = All(bound_in p,(the_scope_of p).x);

theorem :: CQC_LANG:37
  (All(x,p)).x = All(x,p);

theorem :: CQC_LANG:38
  x<>y implies (All(x,p)).y = All(x,p.y);

theorem :: CQC_LANG:39
  Free p = {} implies p.x = p;

theorem :: CQC_LANG:40
  r.x = r;

theorem :: CQC_LANG:41
  Fixed(p.x) = Fixed p;

begin :: Addenda

:: from ALTCAT_1

reserve x,y,i,j,k for set;

theorem :: CQC_LANG:42
  (i,j):->k = [i,j].-->k;

theorem :: CQC_LANG:43
  ((i,j):->k).(i,j) = k;

:: from AMI_1, 2006.03.14, A.T.

theorem :: CQC_LANG:44
  for a,b,c being set holds (a,a) --> (b,c) = a .--> c;

theorem :: CQC_LANG:45
  for x,y holds x .--> y = {[x,y]};

:: from SCMPDS_9, 2006.03.26, A.T.

theorem :: CQC_LANG:46
  for f being Function, a,b,c being set st a <> c holds
  (f +* (a .-->b)).c = f.c;

theorem :: CQC_LANG:47
  for f being Function, a,b,c,d being set st a <> b holds
  (f +* ((a,b)-->(c,d))) .a = c & (f +* ((a,b)-->(c,d))) .b = d;

