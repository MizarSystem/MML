:: Zero Based Finite Sequences
::  by Tetsuya Tsunetou , Grzegorz Bancerek and Yatsuka Nakamura
::
:: Received September 28, 2001
:: Copyright (c) 2001 Association of Mizar Users

environ

 vocabulary FUNCT_1, BOOLE, ORDINAL1, FINSEQ_1, FINSET_1, RELAT_1, ORDINAL2,
      CARD_1, TARSKI, PARTFUN1, ALGSEQ_1, ARYTM_1, FUNCT_4, FINSEQ_7, CAT_1,
      AFINSQ_1;
 notation TARSKI, XBOOLE_0, ZFMISC_1, SUBSET_1, NUMBERS, XREAL_0, RELAT_1,
      FUNCT_1, ORDINAL1, ORDINAL2, ORDINAL4, REAL_1, NAT_1, PARTFUN1, FINSET_1,
      CARD_1, FINSEQ_1, FUNCT_4, CQC_LANG, FUNCT_7;
 constructors REAL_1, NAT_1, WELLORD2, CQC_LANG, FUNCT_7, ORDINAL4, XREAL_0,
      MEMBERED;
 clusters FUNCT_1, RELAT_1, RELSET_1, CARD_1, SUBSET_1, ORDINAL1, ARYTM_3,
      FUNCT_7, NAT_1, XREAL_0, MEMBERED, NUMBERS, ORDINAL2;
 requirements REAL, NUMERALS, SUBSET, BOOLE, ARITHM;


begin

 reserve k,m,n for Nat,
         x,y,z,y1,y2,X,Y for set,
         f,g for Function;

:::::::::::::::::::::::::::::::::::::::::::::::
::                                           ::
::   Extended Segments of Natural Numbers    ::
::                                           ::
:::::::::::::::::::::::::::::::::::::::::::::::

theorem :: AFINSQ_1:1
  n in n+1;

theorem :: AFINSQ_1:2
   k <= n implies k = k /\ n;

theorem :: AFINSQ_1:3
    k = k /\ n implies k <= n;

theorem :: AFINSQ_1:4   :: ORDINAL1:def 1, CARD_1:52
  n \/ { n } = n+1;

theorem :: AFINSQ_1:5
 Seg n c= n+1;

theorem :: AFINSQ_1:6
   n+1 = {0} \/ Seg n;

::::::::::::::::::::::::::::::::
::                            ::
::  Finite ExFinSequences     ::
::                            ::
::::::::::::::::::::::::::::::::

theorem :: AFINSQ_1:7
 for r being Function holds
  r is finite T-Sequence-like iff ex n st dom r = n;

 registration
  cluster finite T-Sequence-like Function;
   existence proof
     deffunc _F(set) = 0;
     consider f such that
 A1: dom f = {} & for x st x in {} holds f.x = _F(x) from FUNCT_1:sch 3;
     take f;
     thus thesis by A1,Th7;
    end;
 end;


definition
  mode XFinSequence is finite T-Sequence;
end;


 reserve p,q,r,s,t for XFinSequence;

registration
 cluster natural -> finite set;
 coherence
  proof let a be set; assume a in omega;
    then a is Nat;
   hence thesis;
  end;
 let p;
 cluster dom p -> natural;
 coherence
  proof ex n st dom p = n by Th7;
   hence thesis;
  end;
end;


notation let p;
 synonym len p for Card p ;
end;
definition let p;
 redefine func len p -> Nat means
:: AFINSQ_1:def 1
  it = dom p;
 end;


 definition let p;
  redefine func dom p -> Subset of NAT;
 end;


theorem :: AFINSQ_1:8
    (ex k st dom f c= k) implies ex p st f c= p;

scheme :: AFINSQ_1:sch 1
 XSeqEx{A()->Nat,P[set,set]}:
 ex p st dom p = A() & for k st k in A() holds P[k,p.k]
 provided
  for k,y1,y2 st k in A() & P[k,y1] & P[k,y2] holds y1=y2
   and
  for k st k in A() ex x st P[k,x]
proof
    defpred _P[set, set] means P[$1,$2];
   A3: for x,y1,y2 st x in A() & _P[x,y1] & _P[x,y2] holds y1=y2
    proof let x,y1,y2;assume A4:x in A() & _P[x,y1] & _P[x,y2];
        A()={i where i is Nat: i<A()} by AXIOMS:30;
      then consider i being Nat such that A5:i=x & i<A() by A4;
     thus y1=y2 by A1,A4,A5;
    end;
   A6: for x st x in A() ex y st _P[x,y]
    proof let x;assume A7:x in A();
        A()={i where i is Nat: i<A()} by AXIOMS:30;
      then consider i being Nat such that A8:i=x & i<A() by A7;
     thus thesis by A2,A7,A8;
    end;
    consider f being Function such that A9: dom f = A() &
        (for x st x in A() holds _P[x,f.x]) from FUNCT_1:sch 2(A3,A6);
    reconsider p=f as XFinSequence by A9,Th7;
    take p;
    thus thesis by A9;
 end;

scheme :: AFINSQ_1:sch 2
 XSeqLambda{A()->Nat,F(set) -> set}:
 ex p being XFinSequence st len p = A() & for k st k in A() holds p.k=F(k)
proof
   deffunc _F(set) = F($1);
   consider f being Function such that
    A1: dom f = A() & for x st x in A() holds f.x=_F(x) from FUNCT_1:sch 3;
   reconsider p=f as XFinSequence by A1,Th7;
   take p;
  thus thesis by A1,Def1;
 end;

theorem :: AFINSQ_1:9
    z in p implies ex k st (k in dom p & z=[k,p.k]);

theorem :: AFINSQ_1:10
  dom p = dom q & (for k st k in dom p holds p.k = q.k) implies p=q;

theorem :: AFINSQ_1:11
   ( len p = len q & for k st k < len p holds p.k=q.k ) implies p=q;

theorem :: AFINSQ_1:12
   p|n is XFinSequence;

theorem :: AFINSQ_1:13
   rng p c= dom f implies f*p is XFinSequence;

theorem :: AFINSQ_1:14
    k < len p & q = p|k implies len q = k & dom q = k;

:::::::::::::::::::::::::::::::::
::                             ::
::    XFinSequences of D       ::
::                             ::
:::::::::::::::::::::::::::::::::

registration let D be set;
 cluster finite T-Sequence of D;
 existence
  proof
     {} is T-Sequence of D by ORDINAL1:45;
   hence thesis;
  end;
end;


definition let D be set;
 mode XFinSequence of D is finite T-Sequence of D;
end;


theorem :: AFINSQ_1:15
 for D being set, f being XFinSequence of D holds f is PartFunc of NAT,D;

registration
 cluster {} -> T-Sequence-like;
 coherence by ORDINAL1:45;
end;


registration let D be set;
 cluster finite T-Sequence-like PartFunc of NAT,D;
  existence proof {} is PartFunc of NAT,D by PARTFUN1:56; hence thesis;end;
end;


reserve D for set;

theorem :: AFINSQ_1:16
   for p being XFinSequence of D holds p|k is XFinSequence of D;

theorem :: AFINSQ_1:17
   for D being non empty set
  ex p being XFinSequence of D st len p = k;

::::::::::::::::::::::::::::::::::::
::                                ::
::    The Empty XFinSequence      ::
::                                ::
::::::::::::::::::::::::::::::::::::

registration
  cluster empty XFinSequence;
  existence by ORDINAL1:45;
end;


theorem :: AFINSQ_1:18
 len p = 0 iff p = {};

theorem :: AFINSQ_1:19
  for D be set holds {} is XFinSequence of D;

registration
  let D be set;
  cluster empty XFinSequence of D;
existence
 proof
     {} is XFinSequence of D by Th19;
   hence thesis;
 end;
end;


definition let x;
  func <%x%> -> set equals
:: AFINSQ_1:def 2
    { [0,x] };
end;


definition let D be set;
  func <%>D -> empty XFinSequence of D equals
:: AFINSQ_1:def 3
     {};
end;


 definition let p,q;
  redefine func p^q means
:: AFINSQ_1:def 4
 dom it = len p + len q &
       (for k st k in dom p holds it.k=p.k) &
       (for k st k in dom q holds it.(len p + k) = q.k);
 end;
registration let p,q;
  cluster p^q -> finite;
  coherence
   proof
       dom (p^q) = (dom p)+^dom q by ORDINAL4:def 1;
     then dom (p^q) is Nat by ORDINAL2:def 21;
    hence thesis by Th7;
   end;
  end;


theorem :: AFINSQ_1:20
  len(p^q) = len p + len q;

theorem :: AFINSQ_1:21
  (len p <= k & k < len p + len q) implies (p^q).k=q.(k-len p);

theorem :: AFINSQ_1:22
    len p <= k & k < len(p^q) implies (p^q).k = q.(k - len p);

theorem :: AFINSQ_1:23
  k in dom (p^q) implies
    (k in dom p or (ex n st n in dom q & k=len p + n));

theorem :: AFINSQ_1:24
 for p,q being T-Sequence holds dom p c= dom(p^q);

theorem :: AFINSQ_1:25
  x in dom q implies ex k st k=x & len p + k in dom(p^q);

theorem :: AFINSQ_1:26
  k in dom q implies len p + k in dom(p^q);

theorem :: AFINSQ_1:27
   rng p c= rng(p^q);

theorem :: AFINSQ_1:28
  rng q c= rng(p^q);

theorem :: AFINSQ_1:29
  rng(p^q) = rng p \/ rng q;

theorem :: AFINSQ_1:30
  p^q^r = p^(q^r);

theorem :: AFINSQ_1:31
    p^r = q^r or r^p = r^q implies p = q;

theorem :: AFINSQ_1:32
  p^{} = p & {}^p = p;

theorem :: AFINSQ_1:33
     p^q = {} implies p={} & q={};

 definition let D be set;let p,q be XFinSequence of D;
 redefine func p^q -> T-Sequence of D;
 end;

 definition let x;
  redefine func <%x%> -> Function means
:: AFINSQ_1:def 5
  dom it = 1 & it.0 = x;
 end;


 registration let x;
  cluster <%x%> -> Function-like Relation-like;
  coherence;
 end;


 registration let x;
  cluster <%x%> -> finite T-Sequence-like;
 coherence
    proof
        dom <%x%> = 1 by Def5;
     hence thesis by AMI_1:21,ORDINAL1:def 7;
    end;
 end;


theorem :: AFINSQ_1:34
    p^q is XFinSequence of D implies
     p is XFinSequence of D & q is XFinSequence of D;

definition let x,y;
  func <%x,y%> -> set equals
:: AFINSQ_1:def 6
    <%x%>^<%y%>;

  let z;
  func <%x,y,z%> -> set equals
:: AFINSQ_1:def 7
    <%x%>^<%y%>^<%z%>;
end;


registration let x,y;
  cluster <%x,y%> -> Function-like Relation-like;
  coherence
  proof
      <%x%>^<%y%> = <%x,y%> by Def6;
    hence thesis;
  end;

  let z;
  cluster <%x,y,z%> -> Function-like Relation-like;
  coherence
  proof
      <%x%>^<%y%>^<%z%> = <%x,y,z%> by Def7;
    hence thesis;
  end;
end;


registration let x,y;
  cluster <%x,y%> -> finite T-Sequence-like;
  coherence
  proof
      <%x%>^<%y%> = <%x,y%> by Def6;
    hence thesis;
  end;

  let z;
  cluster <%x,y,z%> -> finite T-Sequence-like;
  coherence
  proof
      <%x%>^<%y%>^<%z%> = <%x,y,z%> by Def7;
    hence thesis;
  end;
end;


theorem :: AFINSQ_1:35
    <%x%> = { [0,x] };

theorem :: AFINSQ_1:36
   p=<%x%> iff dom p = 1 & rng p = {x};

theorem :: AFINSQ_1:37
  p=<%x%> iff len p = 1 & rng p = {x};

theorem :: AFINSQ_1:38
    p = <%x%> iff len p = 1 & p.0 = x;

theorem :: AFINSQ_1:39
    (<%x%>^p).0 = x;

theorem :: AFINSQ_1:40
    (p^<%x%>).(len p)=x;

theorem :: AFINSQ_1:41
  <%x,y,z%>=<%x%>^<%y,z%> &
  <%x,y,z%>=<%x,y%>^<%z%>;

theorem :: AFINSQ_1:42
  p = <%x,y%> iff len p = 2 & p.0=x & p.1=y;

theorem :: AFINSQ_1:43
    p = <%x,y,z%> iff len p = 3 & p.0 = x & p.1 = y & p.2 = z;

theorem :: AFINSQ_1:44
   p <> {} implies ex q,x st p=q^<%x%>;

definition let D be non empty set; let x be Element of D;
 redefine func <%x%> -> XFinSequence of D;
 end;


:: scheme of induction for extended finite sequences ::

scheme :: AFINSQ_1:sch 3
 IndXSeq{P[XFinSequence]}:
 for p holds P[p]
  provided
  P[{}] and
  for p,x st P[p] holds P[p^<%x%>]
proof  let p;
    defpred _P[Real] means for p st len p = $1 holds P[p];
    consider X being Subset of REAL such that
      A3:  for x being Real holds x in X iff _P[x] from REAL_1:sch 1;
     for k holds k in X proof
         defpred _R[Nat] means $1 in X;
      A4: _R[0]
          proof
              for q st len q = 0 holds P[q] by A1,Th18;
           hence 0 in X by A3;
          end;

          now let n such that A5:n in X;
              now let q;
              assume A6: len q = n+1;
              then q <> {} by Th18;
              then consider r,x such that A7: q=r^<%x%> by Th44;
                len q = len r + len <%x%> by A7,Th20
              .= len r + 1 by Th37;
              then len r = n + 1 - 1 by A6,XCMPLX_1:26;
              then len r = n +(1-1) by XCMPLX_1:29;
              then P[r] by A3,A5;
             hence P[q] by A2,A7;
            end;
           hence n+1 in X by A3;
          end;
    then A8:   for n st _R[n] holds _R[n+1];
         thus for k holds _R[k] from NAT_1:sch 1(A4,A8);
       end;

      then len p in X;
      hence P[p] by A3;
 end;

theorem :: AFINSQ_1:45
    for p,q,r,s being XFinSequence st p^q = r^s & len p <= len r
  ex t being XFinSequence st p^t = r;

 definition let D be set;
  func D^omega -> set means
:: AFINSQ_1:def 8
 x in it iff x is XFinSequence of D;
 end;


 registration let D be set;
  cluster D^omega -> non empty;
  coherence
  proof
    consider f being XFinSequence of D;
      f in D^omega by Def8;
    hence thesis;
   end;
  end;


theorem :: AFINSQ_1:46
    x in D^omega iff x is XFinSequence of D;

theorem :: AFINSQ_1:47
    {} in D^omega;

scheme :: AFINSQ_1:sch 4
 SepXSeq{D()->non empty set, P[XFinSequence]}:
 ex X st (for x holds x in X iff ex p st p in D()^omega & P[p] & x=p)
proof
  defpred _P[set] means ex p st P[p] & $1=p;
  consider Y such that A1: x in Y iff x in D()^omega & _P[x]
         from XBOOLE_0:sch 1;
  take Y;
    x in Y implies ex p st p in D()^omega & P[p] & x=p
  proof
   assume x in Y;
       then x in D()^omega & ex p st P[p] & x=p by A1;
   hence ex p st p in D()^omega & P[p] & x=p;
  end;
hence thesis by A1;
end;

notation
 let p be XFinSequence;
 let i,x be set;
 synonym Replace(p,i,x) for p+*(i,x); end;
registration
 let p be XFinSequence;
 let i,x be set;
 cluster p+*(i,x) -> finite T-Sequence-like;
 coherence
  proof dom (p+*(i,x)) = dom p by FUNCT_7:32;
   hence thesis by AMI_1:21,ORDINAL1:def 7;
  end;
 end;


theorem :: AFINSQ_1:48
   for p being XFinSequence, i being Nat, x being set holds
   len Replace(p,i,x) = len p &
   (i < len p implies Replace(p,i,x).i = x) &
   for j being Nat st j <> i holds Replace(p,i,x).j = p.j;

definition
 let D be non empty set;
 let p be XFinSequence of D;
 let i be Nat, a be Element of D;
 redefine func Replace(p,i,a) -> XFinSequence of D;
end;


