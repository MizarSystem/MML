:: The Complex Numbers
::  by Czes{\l}aw Byli\'nski
::
:: Received March 1, 1990
:: Copyright (c) 1990 Association of Mizar Users

environ

 vocabularies ARYTM, ARYTM_3, SQUARE_1, ARYTM_1, RELAT_1, ABSVALUE, COMPLEX1,
      FUNCT_2, BOOLE, FUNCT_1, FUNCOP_1, XCMPLX_0, OPPCAT_1, ORDINAL1, XREAL_0;
 notations TARSKI, XBOOLE_0, SUBSET_1, ORDINAL1, ARYTM_0, NUMBERS, XCMPLX_0,
      XREAL_0, REAL_1, SQUARE_1, RELAT_1, FUNCT_1, FUNCT_2, FUNCT_4, XXREAL_0;
 constructors FUNCT_4, FRAENKEL, ARYTM_0, REAL_1, SQUARE_1, MEMBERED;
 registrations XBOOLE_0, RELSET_1, FRAENKEL, NUMBERS, XCMPLX_0, XXREAL_0,
      XREAL_0, SQUARE_1, MEMBERED;
 requirements REAL, NUMERALS, SUBSET, BOOLE, ARITHM;


begin

 reserve a,b,c,d for Element of REAL;

canceled;

theorem :: COMPLEX1:2
  for a, b being real number st a^2 + b^2 = 0 holds a = 0;

:: Complex Numbers

definition let z be complex number;
 canceled;

  func Re z means
:: COMPLEX1:def 2
  it = z if z in REAL
  otherwise
   ex f being Function of 2,REAL st z = f & it = f.0;

  func Im z means
:: COMPLEX1:def 3
  it = 0 if z in REAL
  otherwise
   ex f being Function of 2,REAL st z = f & it = f.1;
end;

registration let z be complex number;
  cluster Re z -> real;
  cluster Im z -> real;
end;

definition let z be complex number;
  redefine func Re z -> Real;
  redefine func Im z -> Real;
end;

canceled 2;

theorem :: COMPLEX1:5
  for f being Function of 2,REAL
    ex a,b st f = (0,1)-->(a,b);

canceled 3;

theorem :: COMPLEX1:9
  for z1, z2 being complex number st
   Re z1 = Re z2 & Im z1 = Im z2 holds z1 = z2;

definition let z1,z2 be complex number;
  redefine  canceled;

pred z1 = z2 means
:: COMPLEX1:def 5
Re z1 = Re z2 & Im z1 = Im z2;
end;

definition
  func 0c -> Element of COMPLEX equals
:: COMPLEX1:def 6
  0;

  func 1r -> Element of COMPLEX equals
:: COMPLEX1:def 7
   1;

 redefine func <i> -> Element of COMPLEX equals
:: COMPLEX1:def 8
   [*0,1*];
end;

registration
  cluster 0c -> zero;
end;

canceled 2;

theorem :: COMPLEX1:12
  Re 0 = 0 & Im 0 = 0;

theorem :: COMPLEX1:13
  for z being complex number holds
    z = 0 iff (Re z)^2 + (Im z)^2 = 0;

canceled;

theorem :: COMPLEX1:15
  Re(1r) = 1 & Im(1r) = 0;

canceled;

theorem :: COMPLEX1:17
  Re(<i>) = 0 & Im(<i>) = 1;

 reserve z,z1,z2 for Element of COMPLEX;

definition let z1,z2;
  redefine func z1 + z2 -> Element of COMPLEX equals
:: COMPLEX1:def 9
   Re z1 + Re z2+(Im z1 + Im z2)*<i>;
end;

canceled;

theorem :: COMPLEX1:19
  for z1, z2 being complex number holds
   Re(z1 + z2) = Re z1 + Re z2 & Im(z1 + z2) = Im z1 + Im z2;

definition let z1,z2 be Element of COMPLEX;
 redefine func z1 * z2 -> Element of COMPLEX equals
:: COMPLEX1:def 10
   Re z1 * Re z2 - Im z1 * Im z2+(Re z1 * Im z2 + Re z2 * Im z1)*<i>;
end;

canceled 4;

theorem :: COMPLEX1:24
  for z1, z2 being complex number holds
   Re(z1 * z2) = Re z1 * Re z2 - Im z1 * Im z2 &
   Im(z1 * z2) = Re z1 * Im z2 + Re z2 * Im z1;

theorem :: COMPLEX1:25
  for x being Real holds Re (x*<i>) = 0;

theorem :: COMPLEX1:26
  for x being Real holds Im (x*<i>) = x;

theorem :: COMPLEX1:27
   for x, y being Real holds [*x,y*] = x + y * <i>;

theorem :: COMPLEX1:28
  Re(a+b*<i>) = a & Im(a+b*<i>) = b;

theorem :: COMPLEX1:29
  for z being complex number holds Re z+(Im z)*<i> = z;

theorem :: COMPLEX1:30
  for z1, z2 being complex number holds
    Im z1 = 0 & Im z2 = 0 implies Re(z1*z2) = Re z1 * Re z2 & Im(z1*z2) = 0;

theorem :: COMPLEX1:31
  for z1, z2 being complex number holds
    Re z1 = 0 & Re z2 = 0 implies Re(z1*z2) = - Im z1 * Im z2 & Im(z1*z2) = 0;

theorem :: COMPLEX1:32
   Re(z*z) = (Re z)^2 - (Im z)^2 & Im(z*z) = 2*(Re z *Im z);

definition let z;
  redefine func -z -> Element of COMPLEX equals
:: COMPLEX1:def 11
  -Re z+(-Im z)*<i>;
end;

canceled;

theorem :: COMPLEX1:34
  for z being complex number holds
    Re(-z) = -(Re z) & Im(-z) = -(Im z);

canceled 2;

theorem :: COMPLEX1:37
   <i>*<i> = -1r;

definition let z1,z2;
 redefine func z1 - z2 -> Element of COMPLEX equals
:: COMPLEX1:def 12
 Re z1 - Re z2 + (Im z1 - Im z2)*<i>;
end;

canceled 10;

theorem :: COMPLEX1:48
  Re(z1 - z2) = Re z1 - Re z2 & Im(z1 - z2) = Im z1 - Im z2;

definition let z;
  redefine func z" -> Element of COMPLEX equals
:: COMPLEX1:def 13
 Re z / ((Re z)^2+(Im z)^2)+((- Im z) / ((Re z)^2+(Im z)^2))*<i>;
end;

canceled 15;

theorem :: COMPLEX1:64
  for z being complex number holds
   Re(z") = Re z / ((Re z)^2+(Im z)^2) &
   Im(z") = (- Im z) / ((Re z)^2+(Im z)^2);

canceled 7;

theorem :: COMPLEX1:72
   <i>" = -<i>;

canceled 6;

theorem :: COMPLEX1:79
  Re z <> 0 & Im z = 0 implies Re(z") = (Re z)" & Im(z") = 0;

theorem :: COMPLEX1:80
  Re z = 0 & Im z <> 0 implies Re(z") = 0 & Im(z") = -(Im z)";

definition let z1,z2;
  redefine func z1 / z2 -> Element of COMPLEX equals
:: COMPLEX1:def 14
 (Re z1 * Re z2 + Im z1 * Im z2) / ((Re z2)^2 + (Im z2)^2) +
          ((Re z2 * Im z1 - Re z1 * Im z2) / ((Re z2)^2 + (Im z2)^2))*<i>;
end;

canceled;

theorem :: COMPLEX1:82
   Re(z1 / z2) = (Re z1 * Re z2 + Im z1 * Im z2) / ((Re z2)^2 + (Im z2)^2) &
   Im(z1 / z2) = (Re z2 * Im z1 - Re z1 * Im z2) / ((Re z2)^2 + (Im z2)^2);

canceled 26;

theorem :: COMPLEX1:109
   Im z1 = 0 & Im z2 = 0 & Re z2 <> 0 implies
    Re(z1/z2) = (Re z1)/(Re z2) & Im(z1/z2) = 0;

theorem :: COMPLEX1:110
   Re z1 = 0 & Re z2 = 0 & Im z2 <> 0 implies
    Re(z1/z2) = (Im z1)/(Im z2) & Im(z1/z2) = 0;

definition let z be complex number;
  func z*' -> complex number equals
:: COMPLEX1:def 15
    Re z-(Im z)*<i>;
 involutiveness;
end;

definition let z be complex number;
  redefine func z*' -> Element of COMPLEX;
end;

canceled;

theorem :: COMPLEX1:112
  for z being complex number holds
    Re (z*') = Re z & Im (z*') = -Im z;

theorem :: COMPLEX1:113
   0*' = 0;

theorem :: COMPLEX1:114
   for z being complex number holds
    z*' = 0 implies z = 0;

theorem :: COMPLEX1:115
     1r*' = 1r;

theorem :: COMPLEX1:116
   <i>*' = -<i>;

canceled;

theorem :: COMPLEX1:118
  for z1, z2 being complex number holds
  (z1 + z2)*' = z1*' + z2*';

theorem :: COMPLEX1:119
  (-z)*' = -(z*');

theorem :: COMPLEX1:120
   (z1 - z2)*' = z1*' - z2*';

theorem :: COMPLEX1:121
  (z1*z2)*' = z1*'*z2*';

theorem :: COMPLEX1:122
  z"*' = z*'";

theorem :: COMPLEX1:123
   (z1/z2)*' = (z1*')/(z2*');

theorem :: COMPLEX1:124
   Im z = 0 implies z*' = z;

theorem :: COMPLEX1:125
   Re z = 0 implies z*' = -z;

theorem :: COMPLEX1:126
   Re(z*z*') = (Re z)^2 + (Im z)^2 & Im(z*z*') = 0;

theorem :: COMPLEX1:127
   Re(z + z*') = 2*Re z & Im(z + z*') = 0;

theorem :: COMPLEX1:128
   Re(z - z*') = 0 & Im(z - z*') = 2*Im z;

definition let z be complex number;
  func |.z.| -> complex number equals
:: COMPLEX1:def 16
   sqrt ((Re z)^2 + (Im z)^2);
  projectivity;
end;

registration let z be complex number;
  cluster |.z.| -> real;
end;

definition let z be complex number;
  redefine func |.z.| -> Real;
end;

theorem :: COMPLEX1:129
  for x being real number st x >= 0 holds |.x.| = x;

 reserve z for complex number;

theorem :: COMPLEX1:130
   |.0.| = 0;

theorem :: COMPLEX1:131
  |.z.| = 0 implies z = 0;

theorem :: COMPLEX1:132
  0 <= |.z.|;

theorem :: COMPLEX1:133
   z <> 0 iff 0 < |.z.|;

theorem :: COMPLEX1:134
   |.1r.| = 1;

theorem :: COMPLEX1:135
   |.<i>.| = 1;

theorem :: COMPLEX1:136
   Im z = 0 implies |.z.| = |.Re z.|;

theorem :: COMPLEX1:137
   Re z = 0 implies |.z.| = |.Im z.|;

theorem :: COMPLEX1:138
   |.-z.| = |.z.|;

theorem :: COMPLEX1:139
  |.z*'.| = |.z.|;

theorem :: COMPLEX1:140
   Re z <= |.z.|;

theorem :: COMPLEX1:141
   Im z <= |.z.|;

 reserve z1, z2 for complex number;

theorem :: COMPLEX1:142
   |.z1 + z2.| <= |.z1.| + |.z2.|;

theorem :: COMPLEX1:143
  |.z1 - z2.| <= |.z1.| + |.z2.|;

theorem :: COMPLEX1:144
   |.z1.| - |.z2.| <= |.z1 + z2.|;

theorem :: COMPLEX1:145
  |.z1.| - |.z2.| <= |.z1 - z2.|;

theorem :: COMPLEX1:146
  |.z1 - z2.| = |.z2 - z1.|;

theorem :: COMPLEX1:147
  |.z1 - z2.| = 0 iff z1 = z2;

theorem :: COMPLEX1:148
   z1 <> z2 iff 0 < |.z1 - z2.|;

theorem :: COMPLEX1:149
   |.z1 - z2.| <= |.z1 - z.| + |.z - z2.|;

theorem :: COMPLEX1:150
   |.|.z1.| - |.z2.|.| <= |.z1 - z2.|;

theorem :: COMPLEX1:151
   |.z1*z2.| = |.z1.|*|.z2.|;

theorem :: COMPLEX1:152
  |.z".| = |.z.|";

theorem :: COMPLEX1:153
   |.z1.|/|.z2.| = |.z1/z2.|;

theorem :: COMPLEX1:154
   |.z*z.| = (Re z)^2 + (Im z)^2;

theorem :: COMPLEX1:155
   |.z*z.| = |.z*z*'.|;

:: Originally from SQUARE_1

theorem :: COMPLEX1:156
   for a being real number st a <= 0 holds
    |.a.| = -a;

theorem :: COMPLEX1:157
  for a being real number holds
    |.a.| = a or |.a.| = -a;

theorem :: COMPLEX1:158  :: SQUARE_1'91
  for a being real number holds sqrt a^2 = |.a.|;

theorem :: COMPLEX1:159 :: SQUARE_1'34
   for x, y being real number holds
    min(x,y) = (x + y - |.x - y.|) / 2;

theorem :: COMPLEX1:160 :: SQUARE_1'45
   for x, y being real number holds
    max(x,y) = (x + y + |.x - y.|) / 2;

theorem :: COMPLEX1:161  :: SQUARE_1'62
  for x being real number holds
    |.x.|^2 = x^2;

theorem :: COMPLEX1:162
   for x being real number holds
    -|.x.| <= x & x <= |.x.|;

notation let x be complex number;
  synonym abs x for |.x.|;
end;

definition let x be complex number;
  redefine func abs x -> Real;
end;

theorem :: COMPLEX1:163
  for a,b,c,d being real number st a+b*<i> = c+d*<i> holds a = c & b = d;

:: from JGRAPH_1, 29.12.2006, AK

reserve r1, r2 for real number;

theorem :: COMPLEX1:164
sqrt(r1^2+r2^2)<=abs(r1)+abs(r2);

theorem :: COMPLEX1:165
abs(r1)<=sqrt(r1^2+r2^2);
