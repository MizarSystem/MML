:: The Complex Numbers
::  by Czes{\l}aw Byli\'nski
::
:: Received March 1, 1990
:: Copyright (c) 1990 Association of Mizar Users

environ

 vocabularies NUMBERS, SUBSET_1, XREAL_0, ORDINAL1, SQUARE_1, ARYTM_3, CARD_1,
      XXREAL_0, XCMPLX_0, FUNCT_1, FUNCT_2, XBOOLE_0, RELAT_1, REAL_1,
      FUNCOP_1, ARYTM_0, ARYTM_1, COMPLEX1;
 notations TARSKI, SUBSET_1, ORDINAL1, ARYTM_0, NUMBERS, XCMPLX_0, XREAL_0,
      REAL_1, SQUARE_1, RELAT_1, FUNCT_1, FUNCT_2, FUNCT_4, XXREAL_0;
 constructors FUNCT_4, ARYTM_0, REAL_1, SQUARE_1, MEMBERED, RELSET_1;
 registrations XBOOLE_0, RELSET_1, NUMBERS, XCMPLX_0, XXREAL_0, XREAL_0,
      SQUARE_1, MEMBERED;
 requirements REAL, NUMERALS, SUBSET, BOOLE, ARITHM;


begin

reserve a,b,c,d for Element of REAL;

:: Auxiliary theorems

canceled;

theorem :: COMPLEX1:2
  for a, b being real number st a^2 + b^2 = 0 holds a = 0;

:: Complex Numbers

definition
  let z be complex number;
  canceled;
  func Re z means
:: COMPLEX1:def 2

  it = z if z in REAL otherwise ex f being Function of
  2,REAL st z = f & it = f.0;
  func Im z means
:: COMPLEX1:def 3

  it = 0 if z in REAL otherwise ex f being Function of
  2,REAL st z = f & it = f.1;
end;

registration
  let z be complex number;
  cluster Re z -> real;
  cluster Im z -> real;
end;

definition
  let z be complex number;
  redefine func Re z -> Real;
  redefine func Im z -> Real;
end;

canceled 2;

theorem :: COMPLEX1:5
  for f being Function of 2,REAL ex a,b st f = (0,1)-->(a,b);

canceled 3;

theorem :: COMPLEX1:9
  for z1, z2 being complex number st Re z1 = Re z2 & Im z1 = Im z2
  holds z1 = z2;

definition
  let z1,z2 be complex number;
  canceled;
  redefine pred z1 = z2 means
:: COMPLEX1:def 5
  Re z1 = Re z2 & Im z1 = Im z2;
end;

notation
  synonym 0c for 0;
end;

definition
  redefine func 0c -> Element of COMPLEX;
end;

definition
  canceled;
  func 1r -> Element of COMPLEX equals
:: COMPLEX1:def 7
  1;
  redefine func <i> -> Element of COMPLEX;
end;

canceled 2;

theorem :: COMPLEX1:12
  Re 0 = 0 & Im 0 = 0;

theorem :: COMPLEX1:13
  for z being complex number holds z = 0 iff (Re z)^2 + (Im z)^2 =
  0;

canceled;

theorem :: COMPLEX1:15
  Re(1r) = 1 & Im(1r) = 0;

canceled;

theorem :: COMPLEX1:17
  Re(<i>) = 0 & Im(<i>) = 1;

reserve z,z1,z2 for Element of COMPLEX;

definition
  canceled;
  let z1,z2;
  redefine func z1 + z2 -> Element of COMPLEX equals
:: COMPLEX1:def 9
  Re z1 + Re z2+(Im z1 + Im
  z2)*<i>;
end;

canceled;

theorem :: COMPLEX1:19
  for z1, z2 being complex number holds Re(z1 + z2) = Re z1 + Re
  z2 & Im(z1 + z2) = Im z1 + Im z2;

definition
  let z1,z2 be Element of COMPLEX;
  redefine func z1 * z2 -> Element of COMPLEX equals
:: COMPLEX1:def 10
  Re z1 * Re z2 - Im z1 *
  Im z2+(Re z1 * Im z2 + Re z2 * Im z1)*<i>;
end;

canceled 4;

theorem :: COMPLEX1:24
  for z1, z2 being complex number holds Re(z1 * z2) = Re z1 * Re
  z2 - Im z1 * Im z2 & Im(z1 * z2) = Re z1 * Im z2 + Re z2 * Im z1;

theorem :: COMPLEX1:25
  for x being Real holds Re (x*<i>) = 0;

theorem :: COMPLEX1:26
  for x being Real holds Im (x*<i>) = x;

canceled;

theorem :: COMPLEX1:28
  for a,b being real number holds Re(a+b*<i>) = a & Im(a+b*<i>) =
  b;

theorem :: COMPLEX1:29
  for z being complex number holds Re z+(Im z)*<i> = z;

theorem :: COMPLEX1:30
  for z1, z2 being complex number holds Im z1 = 0 & Im z2 = 0
  implies Re(z1*z2) = Re z1 * Re z2 & Im(z1*z2) = 0;

theorem :: COMPLEX1:31
  for z1, z2 being complex number holds Re z1 = 0 & Re z2 = 0
  implies Re(z1*z2) = - Im z1 * Im z2 & Im(z1*z2) = 0;

theorem :: COMPLEX1:32
  Re(z*z) = (Re z)^2 - (Im z)^2 & Im(z*z) = 2*(Re z *Im z);

definition
  let z;
  redefine func -z -> Element of COMPLEX equals
:: COMPLEX1:def 11

  -Re z+(-Im z)*<i>;
end;

canceled;

theorem :: COMPLEX1:34
  for z being complex number holds Re(-z) = -(Re z) & Im(-z) = -(
  Im z);

canceled 2;

theorem :: COMPLEX1:37
  <i>*<i> = -1r;

definition
  let z1,z2;
  redefine func z1 - z2 -> Element of COMPLEX equals
:: COMPLEX1:def 12

  Re z1 - Re z2 + (
  Im z1 - Im z2)*<i>;
end;

canceled 10;

theorem :: COMPLEX1:48
  Re(z1 - z2) = Re z1 - Re z2 & Im(z1 - z2) = Im z1 - Im z2;

definition
  let z;
  redefine func z" -> Element of COMPLEX equals
:: COMPLEX1:def 13

  Re z / ((Re z)^2+(Im z
  )^2)+((- Im z) / ((Re z)^2+(Im z)^2))*<i>;
end;

canceled 15;

theorem :: COMPLEX1:64
  for z being complex number holds Re(z") = Re z / ((Re z)^2+(Im z
  )^2) & Im(z") = (- Im z) / ((Re z)^2+(Im z)^2);

canceled 7;

theorem :: COMPLEX1:72
  <i>" = -<i>;

canceled 6;

theorem :: COMPLEX1:79
  Re z <> 0 & Im z = 0 implies Re(z") = (Re z)" & Im(z") = 0;

theorem :: COMPLEX1:80
  Re z = 0 & Im z <> 0 implies Re(z") = 0 & Im(z") = -(Im z)";

definition
  let z1,z2 be complex number;
  redefine func z1 / z2 -> Element of COMPLEX equals
:: COMPLEX1:def 14

  (Re z1 * Re z2 +
Im z1 * Im z2) / ((Re z2)^2 + (Im z2)^2) + ((Re z2 * Im z1 - Re z1 * Im z2) / (
  (Re z2)^2 + (Im z2)^2))*<i>;
end;

canceled;

theorem :: COMPLEX1:82
  for z1,z2 being complex number holds Re(z1 / z2) = (Re z1 * Re z2 + Im
z1 * Im z2) / ((Re z2)^2 + (Im z2)^2) & Im(z1 / z2) = (Re z2 * Im z1 - Re z1 *
  Im z2) / ((Re z2)^2 + (Im z2)^2);

canceled 26;

theorem :: COMPLEX1:109
  Im z1 = 0 & Im z2 = 0 & Re z2 <> 0 implies Re(z1/z2) = (Re z1)/(Re z2)
  & Im(z1/z2) = 0;

theorem :: COMPLEX1:110
  Re z1 = 0 & Re z2 = 0 & Im z2 <> 0 implies Re(z1/z2) = (Im z1)/(Im z2)
  & Im(z1/z2) = 0;

definition
  let z be complex number;
  func z*' -> complex number equals
:: COMPLEX1:def 15
  Re z-(Im z)*<i>;
  involutiveness;
end;

definition
  let z be complex number;
  redefine func z*' -> Element of COMPLEX;
end;

canceled;

theorem :: COMPLEX1:112
  for z being complex number holds Re (z*') = Re z & Im (z*') = -
  Im z;

theorem :: COMPLEX1:113
  0*' = 0;

theorem :: COMPLEX1:114
  for z being complex number holds z*' = 0 implies z = 0;

theorem :: COMPLEX1:115
  1r*' = 1r;

theorem :: COMPLEX1:116
  <i>*' = -<i>;

canceled;

theorem :: COMPLEX1:118
  for z1, z2 being complex number holds (z1 + z2)*' = z1*' + z2*';

theorem :: COMPLEX1:119
  (-z)*' = -(z*');

theorem :: COMPLEX1:120
  (z1 - z2)*' = z1*' - z2*';

theorem :: COMPLEX1:121
  for z1,z2 being complex number holds (z1*z2)*' = z1*'*z2*';

theorem :: COMPLEX1:122
  for z being complex number holds z"*' = z*'";

theorem :: COMPLEX1:123
  for z1,z2 being complex number holds (z1/z2)*' = (z1*')/(z2*');

theorem :: COMPLEX1:124
  Im z = 0 implies z*' = z;

theorem :: COMPLEX1:125
  Re z = 0 implies z*' = -z;

theorem :: COMPLEX1:126
  Re(z*z*') = (Re z)^2 + (Im z)^2 & Im(z*z*') = 0;

theorem :: COMPLEX1:127
  Re(z + z*') = 2*Re z & Im(z + z*') = 0;

theorem :: COMPLEX1:128
  Re(z - z*') = 0 & Im(z - z*') = 2*Im z;

definition
  let z be complex number;
  func |.z.| -> complex number equals
:: COMPLEX1:def 16
  sqrt ((Re z)^2 + (Im z)^2);
  projectivity;
end;

registration
  let z be complex number;
  cluster |.z.| -> real;
end;

definition
  let z be complex number;
  redefine func |.z.| -> Real;
end;

theorem :: COMPLEX1:129
  for x being real number st x >= 0 holds |.x.| = x;

reserve z for complex number;

theorem :: COMPLEX1:130
  |.0.| = 0;

theorem :: COMPLEX1:131
  |.z.| = 0 implies z = 0;

theorem :: COMPLEX1:132
  0 <= |.z.|;

theorem :: COMPLEX1:133
  z <> 0 iff 0 < |.z.|;

theorem :: COMPLEX1:134
  |.1r.| = 1;

theorem :: COMPLEX1:135
  |.<i>.| = 1;

theorem :: COMPLEX1:136
  Im z = 0 implies |.z.| = |.Re z.|;

theorem :: COMPLEX1:137
  Re z = 0 implies |.z.| = |.Im z.|;

theorem :: COMPLEX1:138
  |.-z.| = |.z.|;

theorem :: COMPLEX1:139
  |.z*'.| = |.z.|;

theorem :: COMPLEX1:140
  Re z <= |.z.|;

theorem :: COMPLEX1:141
  Im z <= |.z.|;

reserve z1, z2 for complex number;

theorem :: COMPLEX1:142
  |.z1 + z2.| <= |.z1.| + |.z2.|;

theorem :: COMPLEX1:143
  |.z1 - z2.| <= |.z1.| + |.z2.|;

theorem :: COMPLEX1:144
  |.z1.| - |.z2.| <= |.z1 + z2.|;

theorem :: COMPLEX1:145
  |.z1.| - |.z2.| <= |.z1 - z2.|;

theorem :: COMPLEX1:146
  |.z1 - z2.| = |.z2 - z1.|;

theorem :: COMPLEX1:147
  |.z1 - z2.| = 0 iff z1 = z2;

theorem :: COMPLEX1:148
  z1 <> z2 iff 0 < |.z1 - z2.|;

theorem :: COMPLEX1:149
  |.z1 - z2.| <= |.z1 - z.| + |.z - z2.|;

theorem :: COMPLEX1:150
  |.|.z1.| - |.z2.|.| <= |.z1 - z2.|;

theorem :: COMPLEX1:151
  |.z1*z2.| = |.z1.|*|.z2.|;

theorem :: COMPLEX1:152
  |.z".| = |.z.|";

theorem :: COMPLEX1:153
  |.z1.|/|.z2.| = |.z1/z2.|;

theorem :: COMPLEX1:154
  |.z*z.| = (Re z)^2 + (Im z)^2;

theorem :: COMPLEX1:155
  |.z*z.| = |.z*z*'.|;

:: Originally from SQUARE_1

theorem :: COMPLEX1:156
  for a being real number st a <= 0 holds |.a.| = -a;

theorem :: COMPLEX1:157
  for a being real number holds |.a.| = a or |.a.| = -a;

theorem :: COMPLEX1:158 :: SQUARE_1'91
  for a being real number holds sqrt a^2 = |.a.|;

theorem :: COMPLEX1:159 :: SQUARE_1'34
  for x, y being real number holds min(x,y) = (x + y - |.x - y.|) / 2;

theorem :: COMPLEX1:160 :: SQUARE_1'45
  for x, y being real number holds max(x,y) = (x + y + |.x - y.|) / 2;

theorem :: COMPLEX1:161  :: SQUARE_1'62
  for x being real number holds |.x.|^2 = x^2;

theorem :: COMPLEX1:162
  for x being real number holds -|.x.| <= x & x <= |.x.|;

notation
  let x be complex number;
  synonym abs x for |.x.|;
end;

definition
  let x be complex number;
  redefine func abs x -> Real;
end;

theorem :: COMPLEX1:163
  for a,b,c,d being real number st a+b*<i> = c+d*<i> holds a = c & b = d;

:: from JGRAPH_1, 29.12.2006, AK

reserve r1, r2 for real number;

theorem :: COMPLEX1:164
  sqrt(r1^2+r2^2)<=abs(r1)+abs(r2);

theorem :: COMPLEX1:165
  abs(r1)<=sqrt(r1^2+r2^2);

theorem :: COMPLEX1:166
  for a being complex number holds |.1/a.| = 1/|.a.|;

