:: The Complex Numbers
::  by Czes{\l}aw Byli\'nski
::
:: Received March 1, 1990
:: Copyright (c) 1990 Association of Mizar Users

environ

 vocabularies NUMBERS, SUBSET_1, XREAL_0, ORDINAL1, SQUARE_1, ARYTM_3, CARD_1,
      XXREAL_0, XCMPLX_0, FUNCT_1, FUNCT_2, XBOOLE_0, RELAT_1, REAL_1,
      FUNCOP_1, ARYTM_0, ARYTM_1, COMPLEX1;
 notations TARSKI, SUBSET_1, ORDINAL1, ARYTM_0, NUMBERS, XCMPLX_0, XREAL_0,
      REAL_1, SQUARE_1, RELAT_1, FUNCT_1, FUNCT_2, FUNCT_4, XXREAL_0;
 constructors FUNCT_4, ARYTM_0, REAL_1, SQUARE_1, MEMBERED, RELSET_1;
 registrations XBOOLE_0, RELSET_1, NUMBERS, XCMPLX_0, XXREAL_0, XREAL_0,
      SQUARE_1, MEMBERED;
 requirements REAL, NUMERALS, SUBSET, BOOLE, ARITHM;


begin

reserve a,b,c,d for real number;

:: Auxiliary theorems

canceled;

theorem :: COMPLEX1:2
  a^2 + b^2 = 0 implies a = 0;

:: Complex Numbers

definition
  let z be complex number;
  canceled;
  func Re z means
:: COMPLEX1:def 2

  it = z if z in REAL
  otherwise ex f being Function of 2,REAL st z = f & it = f.0;
  func Im z means
:: COMPLEX1:def 3

  it = 0 if z in REAL otherwise ex f being Function of
  2,REAL st z = f & it = f.1;
end;

registration
  let z be complex number;
  cluster Re z -> real;
  cluster Im z -> real;
end;

definition
  let z be complex number;
  redefine func Re z -> Real;
  redefine func Im z -> Real;
end;

canceled 2;

theorem :: COMPLEX1:5
  for f being Function of 2,REAL
  ex a,b being Element of REAL st f = (0,1)-->(a,b);

reserve z,z1,z2 for complex number;

canceled 3;

theorem :: COMPLEX1:9
  Re z1 = Re z2 & Im z1 = Im z2 implies z1 = z2;

definition
  let z1,z2 be complex number;
  canceled;
  redefine pred z1 = z2 means
:: COMPLEX1:def 5
  Re z1 = Re z2 & Im z1 = Im z2;
end;

notation
  synonym 0c for 0;
end;

definition
  redefine func 0c -> Element of COMPLEX;
end;

definition
  canceled;
  func 1r -> Element of COMPLEX equals
:: COMPLEX1:def 7
  1;
  redefine func <i> -> Element of COMPLEX;
end;

canceled 2;

theorem :: COMPLEX1:12
  Re 0 = 0 & Im 0 = 0;

theorem :: COMPLEX1:13
  z = 0 iff (Re z)^2 + (Im z)^2 = 0;

canceled;

theorem :: COMPLEX1:15
  Re(1r) = 1 & Im(1r) = 0;

canceled;

theorem :: COMPLEX1:17
  Re(<i>) = 0 & Im(<i>) = 1;

definition
  canceled;
  let z1,z2 be Element of COMPLEX;
  redefine func z1 + z2 -> Element of COMPLEX equals
:: COMPLEX1:def 9
  Re z1 + Re z2 + (Im z1 + Im z2)*<i>;
end;

canceled;

theorem :: COMPLEX1:19
  Re(z1 + z2) = Re z1 + Re z2 & Im(z1 + z2) = Im z1 + Im z2;

definition
  let z1,z2 be Element of COMPLEX;
  redefine func z1 * z2 -> Element of COMPLEX equals
:: COMPLEX1:def 10
  Re z1 * Re z2 - Im z1 *
  Im z2+(Re z1 * Im z2 + Re z2 * Im z1)*<i>;
end;

canceled 4;

theorem :: COMPLEX1:24
  Re(z1 * z2) = Re z1 * Re z2 - Im z1 * Im z2 &
  Im(z1 * z2) = Re z1 * Im z2 + Re z2 * Im z1;

theorem :: COMPLEX1:25
  Re (a*<i>) = 0;

theorem :: COMPLEX1:26
  Im (a*<i>) = a;

canceled;

theorem :: COMPLEX1:28
  Re(a+b*<i>) = a & Im(a+b*<i>) = b;

theorem :: COMPLEX1:29
  Re z+(Im z)*<i> = z;

theorem :: COMPLEX1:30
  Im z1 = 0 & Im z2 = 0 implies Re(z1*z2) = Re z1 * Re z2 & Im(z1*z2) = 0;

theorem :: COMPLEX1:31
  Re z1 = 0 & Re z2 = 0 implies Re(z1*z2) = - Im z1 * Im z2 & Im(z1*z2) = 0;

theorem :: COMPLEX1:32
  Re(z*z) = (Re z)^2 - (Im z)^2 & Im(z*z) = 2*(Re z *Im z);

definition
  let z be Element of COMPLEX;
  redefine func -z -> Element of COMPLEX equals
:: COMPLEX1:def 11

  -Re z+(-Im z)*<i>;
end;

canceled;

theorem :: COMPLEX1:34
  Re(-z) = -(Re z) & Im(-z) = -(Im z);

canceled 2;

theorem :: COMPLEX1:37
  <i>*<i> = -1r;

definition
  let z1,z2 be Element of COMPLEX;
  redefine func z1 - z2 -> Element of COMPLEX equals
:: COMPLEX1:def 12

  Re z1 - Re z2 + (Im z1 - Im z2)*<i>;
end;

canceled 10;

theorem :: COMPLEX1:48
  Re(z1 - z2) = Re z1 - Re z2 & Im(z1 - z2) = Im z1 - Im z2;

definition
  let z be Element of COMPLEX;
  redefine func z" -> Element of COMPLEX equals
:: COMPLEX1:def 13

  Re z / ((Re z)^2+(Im z
  )^2)+((- Im z) / ((Re z)^2+(Im z)^2))*<i>;
end;

canceled 15;

theorem :: COMPLEX1:64
  Re(z") = Re z / ((Re z)^2+(Im z)^2) & Im(z") = (- Im z) / ((Re z)^2+(Im z)^2)
;

canceled 7;

theorem :: COMPLEX1:72
  <i>" = -<i>;

canceled 6;

theorem :: COMPLEX1:79
  Re z <> 0 & Im z = 0 implies Re(z") = (Re z)" & Im(z") = 0;

theorem :: COMPLEX1:80
  Re z = 0 & Im z <> 0 implies Re(z") = 0 & Im(z") = -(Im z)";

definition
  let z1,z2 be complex number;
  redefine func z1 / z2 -> Element of COMPLEX equals
:: COMPLEX1:def 14

  (Re z1 * Re z2 + Im z1 * Im z2) / ((Re z2)^2 + (Im z2)^2) +
  ((Re z2 * Im z1 - Re z1 * Im z2) / ((Re z2)^2 + (Im z2)^2))*<i>;
end;

canceled;

theorem :: COMPLEX1:82
  Re(z1 / z2) = (Re z1 * Re z2 + Im z1 * Im z2) / ((Re z2)^2 + (Im z2)^2) &
  Im(z1 / z2) = (Re z2 * Im z1 - Re z1 * Im z2) / ((Re z2)^2 + (Im z2)^2);

canceled 26;

theorem :: COMPLEX1:109
  Im z1 = 0 & Im z2 = 0 & Re z2 <> 0 implies Re(z1/z2) = (Re z1)/(Re z2)
  & Im(z1/z2) = 0;

theorem :: COMPLEX1:110
  Re z1 = 0 & Re z2 = 0 & Im z2 <> 0 implies Re(z1/z2) = (Im z1)/(Im z2)
  & Im(z1/z2) = 0;

definition
  let z be complex number;
  func z*' -> complex number equals
:: COMPLEX1:def 15
  Re z-(Im z)*<i>;
  involutiveness;
end;

definition
  let z be complex number;
  redefine func z*' -> Element of COMPLEX;
end;

canceled;

theorem :: COMPLEX1:112
  Re (z*') = Re z & Im (z*') = -Im z;

theorem :: COMPLEX1:113
  0*' = 0;

theorem :: COMPLEX1:114
  z*' = 0 implies z = 0;

theorem :: COMPLEX1:115
  1r*' = 1r;

theorem :: COMPLEX1:116
  <i>*' = -<i>;

canceled;

theorem :: COMPLEX1:118
  (z1 + z2)*' = z1*' + z2*';

theorem :: COMPLEX1:119
  (-z)*' = -(z*');

theorem :: COMPLEX1:120
  (z1 - z2)*' = z1*' - z2*';

theorem :: COMPLEX1:121
  (z1*z2)*' = z1*'*z2*';

theorem :: COMPLEX1:122
  z"*' = z*'";

theorem :: COMPLEX1:123
  (z1/z2)*' = (z1*')/(z2*');

theorem :: COMPLEX1:124
  Im z = 0 implies z*' = z;

theorem :: COMPLEX1:125
  Re z = 0 implies z*' = -z;

theorem :: COMPLEX1:126
  Re(z*z*') = (Re z)^2 + (Im z)^2 & Im(z*z*') = 0;

theorem :: COMPLEX1:127
  Re(z + z*') = 2*Re z & Im(z + z*') = 0;

theorem :: COMPLEX1:128
  Re(z - z*') = 0 & Im(z - z*') = 2*Im z;

definition
  let z be complex number;
  func |.z.| -> complex number equals
:: COMPLEX1:def 16
  sqrt ((Re z)^2 + (Im z)^2);
  projectivity;
end;

registration
  let z;
  cluster |.z.| -> real;
end;

definition
  let z;
  redefine func |.z.| -> Real;
end;

theorem :: COMPLEX1:129
  a >= 0 implies |.a.| = a;

registration
  cluster |.0.| -> zero;
end;

theorem :: COMPLEX1:130
  |.0.| = 0;

registration
  let z be non zero complex number;
  cluster |.z.| -> non zero;
end;

theorem :: COMPLEX1:131
  |.z.| = 0 implies z = 0;

registration
  let z;
  cluster |.z.| -> non negative;
end;

theorem :: COMPLEX1:132
  0 <= |.z.|;

theorem :: COMPLEX1:133
  z <> 0 iff 0 < |.z.|;

theorem :: COMPLEX1:134
  |.1r.| = 1;

theorem :: COMPLEX1:135
  |.<i>.| = 1;

theorem :: COMPLEX1:136
  Im z = 0 implies |.z.| = |.Re z.|;

theorem :: COMPLEX1:137
  Re z = 0 implies |.z.| = |.Im z.|;

theorem :: COMPLEX1:138
  |.-z.| = |.z.|;

theorem :: COMPLEX1:139
  |.z*'.| = |.z.|;

theorem :: COMPLEX1:140
  Re z <= |.z.|;

theorem :: COMPLEX1:141
  Im z <= |.z.|;

theorem :: COMPLEX1:142
  |.z1 + z2.| <= |.z1.| + |.z2.|;

theorem :: COMPLEX1:143
  |.z1 - z2.| <= |.z1.| + |.z2.|;

theorem :: COMPLEX1:144
  |.z1.| - |.z2.| <= |.z1 + z2.|;

theorem :: COMPLEX1:145
  |.z1.| - |.z2.| <= |.z1 - z2.|;

theorem :: COMPLEX1:146
  |.z1 - z2.| = |.z2 - z1.|;

theorem :: COMPLEX1:147
  |.z1 - z2.| = 0 iff z1 = z2;

theorem :: COMPLEX1:148
  z1 <> z2 iff 0 < |.z1 - z2.|;

theorem :: COMPLEX1:149
  |.z1 - z2.| <= |.z1 - z.| + |.z - z2.|;

theorem :: COMPLEX1:150
  |.|.z1.| - |.z2.|.| <= |.z1 - z2.|;

theorem :: COMPLEX1:151
  |.z1*z2.| = |.z1.|*|.z2.|;

theorem :: COMPLEX1:152
  |.z".| = |.z.|";

theorem :: COMPLEX1:153
  |.z1.| / |.z2.| = |.z1/z2.|;

theorem :: COMPLEX1:154
  |.z*z.| = (Re z)^2 + (Im z)^2;

theorem :: COMPLEX1:155
  |.z*z.| = |.z*z*'.|;

:: Originally from SQUARE_1

theorem :: COMPLEX1:156
  a <= 0 implies |.a.| = -a;

theorem :: COMPLEX1:157
  |.a.| = a or |.a.| = -a;

theorem :: COMPLEX1:158 :: SQUARE_1'91
  sqrt a^2 = |.a.|;

theorem :: COMPLEX1:159 :: SQUARE_1'34
  min(a,b) = (a + b - |.a - b.|) / 2;

theorem :: COMPLEX1:160 :: SQUARE_1'45
  max(a,b) = (a + b + |.a - b.|) / 2;

theorem :: COMPLEX1:161  :: SQUARE_1'62
  |.a.|^2 = a^2;

theorem :: COMPLEX1:162
  -|.a.| <= a & a <= |.a.|;

notation
  let z be complex number;
  synonym abs z for |.z.|;
end;

definition
  let z be complex number;
  redefine func abs z -> Real;
end;

theorem :: COMPLEX1:163
  a+b*<i> = c+d*<i> implies a = c & b = d;

:: from JGRAPH_1, 29.12.2006, AK

theorem :: COMPLEX1:164
  sqrt(a^2+b^2) <= abs(a)+abs(b);

theorem :: COMPLEX1:165
  abs(a) <= sqrt(a^2+b^2);

theorem :: COMPLEX1:166
  |. 1/z1 .| = 1 / |.z1.|;
