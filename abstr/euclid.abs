:: The Euclidean Space
::  by Agata Darmochwa{\l}
::
:: Received November 21, 1991
:: Copyright (c) 1991 Association of Mizar Users

environ

 vocabularies ARYTM, FINSEQ_2, FINSEQ_1, FUNCT_1, ABSVALUE, ARYTM_1, RVSUM_1,
      COMPLEX1, SQUARE_1, RLVECT_1, RELAT_1, PCOMPS_1, METRIC_1, PRE_TOPC,
      FUNCT_2, ARYTM_3, MCART_1, EUCLID, BOOLE, MONOID_0, SEQ_1, ZF_LANG,
      XREAL_0;
 notations TARSKI, XBOOLE_0, ZFMISC_1, SUBSET_1, ORDINAL1, NUMBERS, XCMPLX_0,
      XREAL_0, COMPLEX1, FUNCT_1, STRUCT_0, METRIC_1, FUNCT_2, REAL_1, SEQ_1,
      FINSEQ_1, FINSEQ_2, FINSEQOP, FRAENKEL, SQUARE_1, RVSUM_1, MONOID_0,
      PRE_TOPC, PCOMPS_1, XXREAL_0;
 constructors FRAENKEL, REAL_1, SQUARE_1, BINOP_2, COMPLEX1, FINSEQOP,
      FINSOP_1, SETWOP_2, PCOMPS_1, MONOID_0;
 registrations XBOOLE_0, FUNCT_1, RELSET_1, NUMBERS, XXREAL_0, XREAL_0,
      BINOP_2, MEMBERED, SEQ_1, FINSEQ_2, RVSUM_1, METRIC_1, PCOMPS_1,
      MONOID_0;
 requirements NUMERALS, REAL, SUBSET, BOOLE, ARITHM;


begin

 reserve k,j,n for Element of NAT, r for real number;

 definition let n;
  func REAL n -> FinSequence-DOMAIN of REAL equals
:: EUCLID:def 1
   n-tuples_on REAL;
 end;

 definition
  func absreal -> Function of REAL,REAL means
:: EUCLID:def 2
    for r holds it.r = abs r;
 end;

 definition let x be real-yielding FinSequence;
   func abs x -> FinSequence of REAL equals
:: EUCLID:def 3
    absreal*x;
 end;

 definition let n;
   func 0*n -> real-yielding FinSequence equals
:: EUCLID:def 4
    n |-> (0 qua Real);
 end;

 definition let n;
  redefine func 0*n -> Element of REAL n;
 end;

reserve x,x1,x2,y,z for Element of REAL n;

 definition let n,x;
   redefine func -x -> Element of REAL n;
 end;

 definition let n,x,y;
   redefine func x + y -> Element of REAL n;
   redefine func x - y -> Element of REAL n;
 end;

 definition let n, x; let r be real number;
  redefine func r*x -> Element of REAL n;
 end;

 definition let n,x;
  redefine func abs x -> Element of n-tuples_on REAL;
 end;

 definition let n,x;
  redefine func sqr x -> Element of n-tuples_on REAL;
 end;

reserve f for real-yielding FinSequence;

definition let f;
   func |. f .| -> Real equals
:: EUCLID:def 5
    sqrt Sum sqr f;
 end;

canceled;

theorem :: EUCLID:2
len x = n;

theorem :: EUCLID:3
  dom x = Seg n;

theorem :: EUCLID:4
   f.k in REAL;

canceled;

theorem :: EUCLID:6
   r = x .k implies (abs x).k = abs r;

theorem :: EUCLID:7
abs 0*n = n |-> (0 qua Real);

theorem :: EUCLID:8
  abs -f = abs f;

theorem :: EUCLID:9
   abs(r*f) = abs(r)*(abs f);

theorem :: EUCLID:10
|.0*n.| = 0;

theorem :: EUCLID:11
|. x .| = 0 implies x = 0*n;

theorem :: EUCLID:12
|.f.| >= 0;

registration
  let f;
  cluster |.f.| -> non negative;
end;

theorem :: EUCLID:13
|.-f.| = |.f.|;

theorem :: EUCLID:14
|.r*f.| = abs(r)*|.f.|;

theorem :: EUCLID:15
|.x1 + x2.| <= |.x1.| + |.x2.|;

theorem :: EUCLID:16
|.x1 - x2.| <= |.x1.| + |.x2.|;

theorem :: EUCLID:17
|.x1.| - |.x2.| <= |.x1 + x2.|;

theorem :: EUCLID:18
|.x1.| - |.x2.| <= |.x1 - x2.|;

theorem :: EUCLID:19
|.x1 - x2.| = 0 iff x1 = x2;

registration
  let n,x1;
  cluster |. x1 - x1 .| -> zero;
end;

theorem :: EUCLID:20
x1 <> x2 implies |.x1 - x2.| > 0;

theorem :: EUCLID:21
|.x1 - x2.| = |.x2 - x1.|;

theorem :: EUCLID:22
|.x1 - x2.| <= |.x1 - x .| + |.x - x2.|;

 definition let n;
  func Pitag_dist n -> Function of [:REAL n,REAL n:],REAL means
:: EUCLID:def 6
  for x,y being Element of REAL n holds it.(x,y) = |.x-y.|;
 end;

theorem :: EUCLID:23
sqr(x-y) = sqr(y-x);

theorem :: EUCLID:24
Pitag_dist n is_metric_of REAL n;

 definition let n;
  func Euclid n -> strict MetrSpace equals
:: EUCLID:def 7
      MetrStruct(#REAL n,Pitag_dist n#);
 end;

 registration let n;
  cluster Euclid n -> non empty;
 end;

 definition let n;
  func TOP-REAL n -> strict TopSpace equals
:: EUCLID:def 8
      TopSpaceMetr (Euclid n);
 end;

registration let n;
 cluster TOP-REAL n -> non empty;
end;

reserve p,p1,p2,p3 for Point of TOP-REAL n,
        x,x1,x2,y,y1,y2 for real number;

theorem :: EUCLID:25
the carrier of TOP-REAL n = REAL n;

theorem :: EUCLID:26
p is Function of Seg n, REAL;

theorem :: EUCLID:27
p is FinSequence of REAL;

registration
  let n;
  cluster TOP-REAL n -> constituted-FinSeqs;
end;

registration
  let n;
  cluster -> real-yielding Point of TOP-REAL n;
end;

theorem :: EUCLID:28
len p = n;

notation let n;
  synonym 0.REAL n for 0*n;
end;

definition let n;
  canceled;
  redefine func 0.REAL n -> Point of TOP-REAL n;
end;

definition let n,p1,p2;
  canceled;
  redefine func p1 + p2 -> Point of TOP-REAL n;
   commutativity;
 end;

 theorem :: EUCLID:29
   for x being Element of REAL n holds sqr abs x = sqr x;

 theorem :: EUCLID:30
p1 + p2 + p3 = p1 + (p2 + p3);

 theorem :: EUCLID:31
0.REAL n + p = p & p + 0.REAL n = p;

 definition let n,p,x;
   canceled;
   redefine func x*p -> Point of TOP-REAL n;
 end;

 theorem :: EUCLID:32
x*0.REAL n = 0.REAL n;

 theorem :: EUCLID:33
1*p = p & 0 * p = 0.REAL n;

 theorem :: EUCLID:34
(x*y)*p = x*(y*p);

 theorem :: EUCLID:35
x*p = 0.REAL n implies x = 0 or p = 0.REAL n;

 theorem :: EUCLID:36
x*(p1 + p2) = x*p1 + x*p2;

 theorem :: EUCLID:37
(x + y)*p = x*p + y*p;

 theorem :: EUCLID:38
x*p1 = x*p2 implies x = 0 or p1 = p2;

definition let n,p;
  canceled;
  redefine func -p -> Point of TOP-REAL n;
 end;

theorem :: EUCLID:39
--p = p;

theorem :: EUCLID:40
p + -p = 0.REAL n;

theorem :: EUCLID:41
p1 + p2 = 0.REAL n implies p1 = -p2 & p2 = -p1;

theorem :: EUCLID:42
-(p1 + p2) = -p1 + -p2;

theorem :: EUCLID:43
-p = (-1)*p;

theorem :: EUCLID:44
-x*p = (-x)*p & -x*p = x*(-p);

 definition let n,p1,p2;
   canceled;
   redefine func p1 - p2 -> Point of TOP-REAL n;
 end;

theorem :: EUCLID:45
p1 - p2 = p1 + -p2;

theorem :: EUCLID:46
p - p = 0.REAL n;

theorem :: EUCLID:47
p1 - p2 = 0.REAL n implies p1 = p2;

theorem :: EUCLID:48
-(p1 - p2) = p2 - p1 & -(p1 - p2) = -p1 + p2;

theorem :: EUCLID:49
p1 + (p2 - p3) = p1 + p2 - p3;

theorem :: EUCLID:50
p1 - (p2 + p3) = p1 - p2 - p3;

theorem :: EUCLID:51
p1 - (p2 - p3) = p1 - p2 + p3;

theorem :: EUCLID:52
p = p + p1 - p1 & p = p - p1 + p1;

theorem :: EUCLID:53
x*(p1 - p2) = x*p1 - x*p2;

theorem :: EUCLID:54
(x-y)*p = x*p - y*p;

reserve p,p1,p2 for Point of TOP-REAL 2;

theorem :: EUCLID:55
   ex x,y being Real st p=<*x,y*>;

 definition let p;
   func p`1 -> Real equals
:: EUCLID:def 14
    p.1;
   func p`2 -> Real equals
:: EUCLID:def 15
    p.2;
 end;

notation let x,y be real number;
  synonym |[ x,y ]| for <*x,y*>;
end;

 definition let x,y be real number;
   redefine func |[ x,y ]| -> Point of TOP-REAL 2;
 end;

theorem :: EUCLID:56
   |[x,y]|`1 = x & |[x,y]|`2 = y;

theorem :: EUCLID:57
p = |[p`1, p`2]|;

theorem :: EUCLID:58
0.REAL 2 = |[0,0]|;

theorem :: EUCLID:59
p1 + p2 = |[ p1`1 + p2`1, p1`2 + p2`2]|;

theorem :: EUCLID:60
|[x1, y1]| + |[x2, y2]| = |[ x1 + x2, y1 + y2]|;

theorem :: EUCLID:61
x*p = |[ x*p`1 ,x*p`2 ]|;

theorem :: EUCLID:62
x*|[x1,y1]| = |[ x*x1 ,x*y1 ]|;

theorem :: EUCLID:63
-p = |[ -p`1, -p`2]|;

theorem :: EUCLID:64
-|[x1,y1]| = |[ -x1, -y1]|;

theorem :: EUCLID:65
p1 - p2 = |[ p1`1 - p2`1, p1`2 - p2`2]|;

theorem :: EUCLID:66
|[x1, y1]| - |[x2, y2]| = |[ x1 - x2, y1 - y2]|;
