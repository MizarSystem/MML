:: The Ring of Integers, Euclidean Rings and Modulo Integers
::  by Christoph Schwarzweller
::
:: Received February 4, 1999
:: Copyright (c) 1999 Association of Mizar Users

environ

 vocabulary BINOP_1, INT_1, FUNCT_1, VECTSP_1, RELAT_1, ARYTM_1, GR_CY_1,
      FUNCT_7, RLVECT_1, VECTSP_2, LATTICES, ABSVALUE, EUCLID, NAT_1, FUNCSDOM,
      GCD_1, ARYTM_3, INT_2, MCART_1, ORDINAL2, NAT_LAT, INT_3;
 notation TARSKI, XBOOLE_0, SUBSET_1, ORDINAL2, NUMBERS, XCMPLX_0, XREAL_0,
      RLVECT_1, MCART_1, RELAT_1, FUNCT_1, STRUCT_0, FUNCT_2, GCD_1, VECTSP_1,
      VECTSP_2, FUNCSDOM, BINOP_1, REAL_1, EUCLID, GR_CY_1, INT_1, FUNCT_7,
      NAT_LAT, INT_2, NAT_1, GROUP_1;
 constructors DOMAIN_1, GROUP_2, REAL_1, GCD_1, NAT_1, EUCLID, GR_CY_1,
      FUNCT_7, NAT_LAT, ALGSTR_2, SEQ_1, MEMBERED;
 clusters STRUCT_0, FUNCT_1, VECTSP_2, XREAL_0, INT_1, RELSET_1, GCD_1, SEQ_1,
      MEMBERED, NUMBERS, ORDINAL2;
 requirements REAL, NUMERALS, SUBSET, BOOLE, ARITHM;


begin

definition
func multint -> BinOp of INT means
:: INT_3:def 1
 for a,b being Element of INT holds it.(a,b) = multreal.(a,b);
end;


definition
func compint -> UnOp of INT means
:: INT_3:def 2
   for a being Element of INT holds it.(a) = compreal.(a);
end;


definition
func INT.Ring -> doubleLoopStr equals
:: INT_3:def 3
 doubleLoopStr(#INT,addint,multint,In (1,INT),In (0,INT)#);
end;

registration
 cluster INT.Ring -> strict non empty;
coherence
  proof
    thus INT.Ring is strict by Def3;
    thus the carrier of INT.Ring is non empty by Def3;
  end;
end;

registration
 cluster INT.Ring -> Abelian add-associative right_zeroed right_complementable
                     well-unital distributive commutative associative
                     domRing-like non degenerated;
coherence
  proof
    hereby
     let a,b be Element of M;
     reconsider a' = a as Element of REAL by Lm1;
     reconsider b' = b as Element of REAL by Lm1;
     thus a + b = (the add of M).[a,b] by RLVECT_1:def 3
          .= (the add of M).(a,b) by BINOP_1:def 1
          .= addreal.(a,b) by Def3,GR_CY_1:def 2
          .= a' + b' by VECTSP_1:def 4
          .= addreal.(b,a) by VECTSP_1:def 4
          .= addint.(b,a) by Def3,GR_CY_1:def 2
          .= (the add of M).[b,a] by Def3,BINOP_1:def 1
          .= b + a by RLVECT_1:def 3;
    end;
    hereby
     let a,b,c be Element of M;
     A1: a + b = (the add of M).[a,b] by RLVECT_1:def 3
               .= (the add of M).(a,b) by BINOP_1:def 1
               .= addreal.(a,b) by Def3,GR_CY_1:def 2;
     A2: (a + b) + c = (the add of M).[(a+b),c] by RLVECT_1:def 3
                     .= addint.((a+b),c) by Def3,BINOP_1:def 1
                     .= addreal.(addreal.(a,b),c) by A1,Def3,GR_CY_1:def 2;
     A3: b + c = (the add of M).[b,c] by RLVECT_1:def 3
               .= (the add of M).(b,c) by BINOP_1:def 1
               .= addreal.(b,c) by Def3,GR_CY_1:def 2;
     A4: a + (b + c) = (the add of M).[a,(b+c)] by RLVECT_1:def 3
                     .= addint.(a,(b+c)) by Def3,BINOP_1:def 1
                     .= addreal.(a,addreal.(b,c)) by A3,Def3,GR_CY_1:def 2;
     reconsider a' = a, b' = b, c' = c as Element of REAL by Lm1;
          addreal.(addreal.(a',b'),c')
      = addreal.(a' + b',c') by VECTSP_1:def 4
     .= (a' + b') + c' by VECTSP_1:def 4
     .= a' + (b' + c') by XCMPLX_1:1
     .= addreal.(a',b' + c') by VECTSP_1:def 4
     .= addreal.(a',addreal.(b',c')) by VECTSP_1:def 4;
     hence (a + b) + c = a + (b + c) by A2,A4;
    end;
    hereby
     let a be Element of M;
     A5: 0 in INT by INT_1:12;
     A6: a + 0.M = (the add of M).[a,0.M] by RLVECT_1:def 3
                 .= addint.(a,0.M) by Def3,BINOP_1:def 1
                 .= addreal.(a,0.M) by Def3,GR_CY_1:def 2
                 .= addreal.(a,the Zero of M) by RLVECT_1:def 2
                 .= addreal.(a,0) by A5,Def3,FUNCT_7:def 1;
     reconsider a' = a as Element of REAL by Lm1;
     reconsider t = 0 as Element of REAL;
       addreal.(a',t) = a' + t by VECTSP_1:def 4
                   .= a;
     hence a + 0.M = a by A6;
    end;
    hereby
     let a be Element of M;
     reconsider a' = a as Integer by Def3,INT_1:12;
     reconsider v = -a' as Element of M by Def3,INT_1:12;
     reconsider v' = v as Integer;
     take v;
     thus a + v = (the add of M).[a,v] by RLVECT_1:def 3
         .= addint.(a,v) by Def3,BINOP_1:def 1
         .= a'+v' by GR_CY_1:14
         .= 0.M by Lm2,XCMPLX_0:def 6;
    end;
    hereby
     let a be Element of M;
     A7: a * 1_ M = (the mult of M).(a,1_ M) by VECTSP_1:def 10
                 .= multreal.(a,1_ M) by Def1,Def3;
     reconsider a' = a as Element of REAL by Lm1;
     A8: 1_ M = 1
          proof
          A9: 1 in INT by INT_1:12;
          thus 1_ M = the unity of M by VECTSP_1:def 9
                  .= 1 by A9,Def3,FUNCT_7:def 1;
          end;
     A10: multreal.(a,1) = a' * 1 by VECTSP_1:def 14
                        .= a;
     A11: 1_ M * a = (the mult of M).(1_ M,a) by VECTSP_1:def 10
                 .= multreal.(1_ M,a) by Def1,Def3;
       multreal.(1,a') = 1 * a' by VECTSP_1:def 14
                   .= a;
     hence a*(1_ M) = a & (1_ M)*a = a by A7,A8,A10,A11;
    end;
 A12: for a,b being Element of M holds
     a * b = b * a
     proof
     let a,b be Element of M;
     reconsider a' = a as Element of REAL by Lm1;
     reconsider b' = b as Element of REAL by Lm1;
       a * b = (the mult of M).(a,b) by VECTSP_1:def 10
          .= multreal.(a,b) by Def1,Def3
          .= a' * b' by VECTSP_1:def 14
          .= multreal.(b,a) by VECTSP_1:def 14
          .= (the mult of M).(b,a) by Def1,Def3
          .= b * a by VECTSP_1:def 10;
     hence thesis;
     end;
 A13: for a,b,c being Element of M holds
     a * (b + c) = a * b + a * c
     proof
     let a,b,c be Element of M;
     A14: b + c = (the add of M).[b,c] by RLVECT_1:def 3
               .= (the add of M).(b,c) by BINOP_1:def 1
               .= addreal.(b,c) by Def3,GR_CY_1:def 2;
     A15: a * (b + c) = (the mult of M).(a,(b+c)) by VECTSP_1:def 10
                     .= multreal.(a,addreal.(b,c)) by A14,Def1,Def3;
     A16: a * b = (the mult of M).(a,b) by VECTSP_1:def 10
               .= multreal.(a,b) by Def1,Def3;
     A17: a * c = (the mult of M).(a,c) by VECTSP_1:def 10
               .= multreal.(a,c) by Def1,Def3;
     A18: a * b + a * c = (the add of M).[(a*b),(a*c)] by RLVECT_1:def 3
                       .= (the add of M).((a*b),(a*c)) by BINOP_1:def 1
                       .= addreal.(multreal.(a,b),multreal.(a,c)) by A16,A17,
Def3,GR_CY_1:def 2;
     reconsider a,b,c as Element of REAL by Lm1;
     reconsider t = multreal.(a,b) as Element of REAL;
     reconsider t' = multreal.(a,c) as Element of REAL;
          multreal.(a,addreal.(b,c))
      = multreal.(a,b+c) by VECTSP_1:def 4
     .= a * (b + c) by VECTSP_1:def 14
     .= a * b + a * c by XCMPLX_1:8
     .= t + (a * c) by VECTSP_1:def 14
     .= t + t' by VECTSP_1:def 14
     .= addreal.(multreal.(a,b),multreal.(a,c)) by VECTSP_1:def 4;
     hence thesis by A15,A18;
     end;
    hereby
     let a,b,c be Element of M;
     thus a*(b+c) = a*b+a*c by A13;
     thus (b + c) * a = a * (b + c) by A12
                     .= a * b + a * c by A13
                     .= b * a + a * c by A12
                     .= b * a + c * a by A12;
    end;
     thus for x,y be Element of M holds x*y = y*x by A12;
    hereby
     let a,b,c be Element of M;
     A19: a * b = (the mult of M).(a,b) by VECTSP_1:def 10
               .= multreal.(a,b) by Def1,Def3;
     A20: (a * b) * c = (the mult of M).((a*b),c) by VECTSP_1:def 10
                     .= multreal.(multreal.(a,b),c) by A19,Def1,Def3;
     A21: b * c = (the mult of M).(b,c) by VECTSP_1:def 10
               .= multreal.(b,c) by Def1,Def3;
     A22: a * (b * c) = (the mult of M).(a,(b*c)) by VECTSP_1:def 10
                     .= multreal.(a,multreal.(b,c)) by A21,Def1,Def3;
     reconsider a' = a, b' = b, c' = c as Element of REAL by Lm1;
          multreal.(multreal.(a,b),c)
      = multreal.(a' * b',c') by VECTSP_1:def 14
     .= (a' * b') * c' by VECTSP_1:def 14
     .= a' * (b' * c') by XCMPLX_1:4
     .= multreal.(a',b' * c') by VECTSP_1:def 14
     .= multreal.(a',multreal.(b',c')) by VECTSP_1:def 14;
     hence a*b*c = a*(b*c) by A20,A22;
    end;
    hereby
      let a,b be Element of M;
      assume A23: a * b = 0.M;
      A24: a * b = (the mult of M).(a,b) by VECTSP_1:def 10
                .= multreal.(a,b) by Def1,Def3;
      reconsider a' = a as Element of REAL by Lm1;
      reconsider b' = b as Element of REAL by Lm1;
             multreal.(a,b) = a' * b' by VECTSP_1:def 14;
      hence a = 0.M or b = 0.M by A23,A24,Lm2,XCMPLX_1:6;
    end;
      A25: 1 in INT & 0 in INT by INT_1:12;
      A26: 1_ M = the unity of M by VECTSP_1:def 9
             .= 1 by A25,Def3,FUNCT_7:def 1;
        0.M = the Zero of M by RLVECT_1:def 2
         .= 0 by A25,Def3,FUNCT_7:def 1;
    hence 0.M <> 1_ M by A26;
  end;
end;

definition
let a,b be Element of INT.Ring;
pred a <= b means
:: INT_3:def 4
 ex a',b' being Integer st a' = a & b' = b & a' <= b';
reflexivity;
connectedness;
end;
notation
let a,b be Element of INT.Ring;
synonym b >= a for a <= b ; antonym b < a for a <= b ; antonym a > b for
 a <= b ; end;

definition
let a be Element of INT.Ring;
func abs(a) -> Element of INT.Ring equals
:: INT_3:def 5
 a if a >= 0.INT.Ring
 otherwise - a;
end;


definition
func absint -> Function of the carrier of INT.Ring,NAT means
:: INT_3:def 6
 for a being Element of INT.Ring holds
 it.a = absreal.(a);
end;


theorem :: INT_3:1
for a being Element of INT.Ring holds
absint.a = abs(a);

theorem :: INT_3:2
for a,b,q1,q2,r1,r2 being Element of INT.Ring
st b <> 0.INT.Ring &
   a = q1 * b + r1 & 0.INT.Ring <= r1 & r1 < abs(b) &
   a = q2 * b + r2 & 0.INT.Ring <= r2 & r2 < abs(b)
holds q1 = q2 & r1 = r2;

definition
let a,b be Element of INT.Ring;
assume b <> 0.INT.Ring;
func a div b -> Element of INT.Ring means
:: INT_3:def 7
 ex r being Element of INT.Ring st
 a = it * b + r & 0.INT.Ring <= r & r < abs(b);
end;


definition
let a,b be Element of INT.Ring;
assume b <> 0.INT.Ring;
func a mod b -> Element of INT.Ring means
:: INT_3:def 8
 ex q being Element of INT.Ring st
 a = q * b + it & 0.INT.Ring <= it & it < abs(b);
end;


theorem :: INT_3:3
  for a,b being Element of INT.Ring
st b <> 0.INT.Ring holds a = (a div b) * b + (a mod b);


::: Euclidian Domains
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

begin

definition
let I be non empty doubleLoopStr;
attr I is Euclidian means
:: INT_3:def 9
 ex f being Function of the carrier of I,NAT st
 (for a,b being Element of I st b <> 0.I holds
  (ex q,r being Element of I st
  (a = q * b + r & (r = 0.I or f.r < f.b))));
end;


registration
 cluster INT.Ring -> Euclidian;
coherence
 proof
  take absint;
  let a,b be Element of M;
  assume A1: b <> 0.M;
  reconsider b' = b as Integer by Def3,INT_1:12;
    now per cases;
  case 0 <= b';
  hence thesis by A1,Lm8;
  end;
  case A2: b' < 0;
  then A3: 0 < -b' by REAL_1:66;
  reconsider c = -b' as Element of M by Def3,INT_1:12;
  consider q,r being Element of M such that
  A4: a = q * c + r & (r = 0.M or absint.r < absint.c) by A3,Lm2,Lm8;
  reconsider t = -q as Element of M;
  reconsider t' = t, q' = q, r' = r as Integer by Def3,INT_1:12;
  reconsider c' = c as Integer;
  consider d being Element of M such that A5: d = t * b;
  consider d' being Integer such that A6: d' = t' * b';
  consider e being Element of M such that A7: e = q * c;
  consider e' being Integer such that A8: e' = q' * c';
  A9: d = d' by A5,A6,Lm7;
  A10: e = e' by A7,A8,Lm7;
  A11: t * b + r= d' + r' by A5,A9,Lm6
               .= (-q') * b' + r' by A6,Lm3
               .= q' * (-b') + r' by XCMPLX_1:176
               .= a by A4,A7,A8,A10,Lm6;
    r = 0.M or absint.r < absint.b
    proof
    assume A12: r <> 0.M;
      absint.c = absreal.c by Def6
            .= abs((-b')) by EUCLID:def 2
            .= -b' by A3,ABSVALUE:def 1
            .= abs((b')) by A2,ABSVALUE:def 1
            .= absreal.(b') by EUCLID:def 2
            .= absint.b by Def6;
    hence thesis by A4,A12;
    end;
  hence ex q,r being Element of M st
        (a = q * b + r & (r = 0.M or absint.r < absint.b)) by A11;
  end;
  end;
  hence thesis;
  end;
end;

registration
cluster strict Euclidian domRing-like non degenerated well-unital
        distributive commutative Ring;
existence
proof
  take INT.Ring;
  thus thesis;
end;
end;


definition
mode EuclidianRing is Euclidian domRing-like non degenerated well-unital
     distributive commutative Ring;
end;


registration
cluster strict EuclidianRing;
existence
 proof
   take INT.Ring;
   thus thesis;
 end;
end;


definition
let E be Euclidian (non empty doubleLoopStr);
mode DegreeFunction of E ->
              Function of the carrier of E,NAT means
:: INT_3:def 10
 (for a,b being Element of E
  st b <> 0.E holds
  (ex q,r being Element of E st
  (a = q * b + r & (r = 0.E or it.r < it.b))));
end;


theorem :: INT_3:4
for E being EuclidianRing holds E is gcdDomain;

registration
cluster Euclidian -> gcd-like (domRing-like non degenerated
    Abelian add-associative right_zeroed right_complementable
    associative commutative right_unital right-distributive
     (non empty doubleLoopStr));
coherence by Th4;
end;


definition
redefine func absint -> DegreeFunction of INT.Ring;
end;


theorem :: INT_3:5
for F being commutative associative left_unital Field-like right_zeroed
  (non empty doubleLoopStr) holds F is Euclidian;

registration
cluster commutative associative left_unital Field-like right_zeroed Field-like
  -> Euclidian (non empty doubleLoopStr);
coherence by Th5;
end;


theorem :: INT_3:6
  for F being commutative associative left_unital Field-like right_zeroed
  (non empty doubleLoopStr)
for f being Function of the carrier of F,NAT holds
f is DegreeFunction of F;


::: Some Theorems about DIV and MOD
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

begin

canceled;

theorem :: INT_3:8
for n being Nat st n > 0
for a,k being Integer holds
(a + n * k) div n = (a div n) + k & (a + n * k) mod n = a mod n;

theorem :: INT_3:9
for n being Nat st n > 0
for a being Integer holds a mod n >= 0 & a mod n < n;

theorem :: INT_3:10
for n being Nat st n > 0
for a being Integer holds
((0 <= a & a < n) implies a mod n = a) &
((0 > a & a >= -n) implies a mod n = n + a);

theorem :: INT_3:11
for n being Nat st n > 0
for a being Integer holds a mod n = 0 iff n divides a;

theorem :: INT_3:12
for n being Nat st n > 0
for a,b being Integer holds
a mod n = b mod n iff a,b are_congruent_mod n;

theorem :: INT_3:13
for n being Nat st n > 0
for a being Integer holds (a mod n) mod n = a mod n;

theorem :: INT_3:14
for n being Nat st n > 0
for a,b being Integer holds (a + b) mod n = ((a mod n) + (b mod n)) mod n;

theorem :: INT_3:15
for n being Nat st n > 0
for a,b being Integer holds (a * b) mod n = ((a mod n) * (b mod n)) mod n;

theorem :: INT_3:16
for a,b being Integer ex s,t being Integer st a gcd b = s * a + t * b;


::: Modulo Integers
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

begin

definition
let n be Nat such that n > 0;
func multint(n) -> BinOp of Segm(n) means
:: INT_3:def 11
 for k,l being Element of Segm(n) holds
 it.(k,l) = (k * l) mod n;
end;


definition
let n be Nat such that n > 0;
func compint(n) -> UnOp of Segm(n) means
:: INT_3:def 12
 for k being Element of Segm(n) holds
 it.k = (n - k) mod n;
end;

theorem :: INT_3:17
for n being Nat st n > 0
for a,b being Element of Segm(n) holds
(a + b < n iff (addint(n)).(a,b) = a + b) &
(a + b >= n iff (addint(n)).(a,b) = (a + b) - n);

theorem :: INT_3:18
for n being Nat st n > 0
for a,b being Element of Segm(n)
for k being Nat holds
(k * n <= a * b & a * b < (k + 1) * n)
iff (multint(n)).(a,b) = a * b - k * n;

theorem :: INT_3:19
  for n being Nat st n > 0
for a being Element of Segm(n) holds
(a = 0 iff (compint(n)).(a) = 0) &
(a <> 0 iff (compint(n)).(a) = n - a);

definition let n be Nat;
func INT.Ring(n) -> doubleLoopStr equals
:: INT_3:def 13
 doubleLoopStr(#Segm(n),addint(n),multint(n),In (1,Segm(n)),In (0,Segm(n))#);
end;


registration let n be Nat;
 cluster INT.Ring(n) -> strict non empty;
coherence
  proof
     INT.Ring n = doubleLoopStr(#Segm(n),addint(n),multint(n),
          In (1,Segm(n)),In (0,Segm(n))#) by Def13;
   hence INT.Ring n is strict &
         the carrier of INT.Ring n is non empty;
  end;
end;


theorem :: INT_3:20
INT.Ring 1 is degenerated & INT.Ring 1 is Ring &
INT.Ring 1 is Field-like well-unital distributive commutative;

registration
 cluster strict degenerated well-unital distributive Field-like commutative
  Ring;
existence by Th20;
end;

theorem :: INT_3:21
for n being Nat st n > 1 holds
 INT.Ring(n) is non degenerated &
 INT.Ring(n) is well-unital distributive commutative Ring;

theorem :: INT_3:22
for p being Nat st p > 1 holds
 INT.Ring(p) is add-associative right_zeroed right_complementable
    Abelian commutative associative left_unital distributive
      Field-like non degenerated (non empty doubleLoopStr)
  iff p is Prime;

registration
let p be Prime;
 cluster INT.Ring(p) -> add-associative right_zeroed right_complementable
   Abelian commutative associative left_unital distributive Field-like
    non degenerated;
coherence
 proof
   p > 1 by INT_2:def 5; hence thesis by Th22;
 end;
end;

