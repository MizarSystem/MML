:: The Ring of Integers, Euclidean Rings and Modulo Integers
::  by Christoph Schwarzweller
::
:: Received February 4, 1999
:: Copyright (c) 1999 Association of Mizar Users

environ

 vocabularies BINOP_1, INT_1, FUNCT_1, VECTSP_1, RELAT_1, ARYTM_1, GR_CY_1,
      FUNCT_7, RLVECT_1, VECTSP_2, LATTICES, ABSVALUE, EUCLID, NAT_1, FUNCSDOM,
      GCD_1, ARYTM_3, INT_2, MCART_1, ORDINAL2, NAT_LAT, INT_3, ARYTM, GROUP_1,
      XREAL_0;
 notations TARSKI, XBOOLE_0, SUBSET_1, ORDINAL1, NUMBERS, XCMPLX_0, COMPLEX1,
      RLVECT_1, MCART_1, RELAT_1, FUNCT_1, BINOP_2, STRUCT_0, FUNCT_2, GCD_1,
      GROUP_1, CARD_1, VECTSP_1, VECTSP_2, FUNCSDOM, BINOP_1, EUCLID, GR_CY_1,
      INT_1, FUNCT_7, NEWTON, INT_2, NAT_1, NAT_D, XXREAL_0;
 constructors DOMAIN_1, XXREAL_0, REAL_1, NAT_1, NAT_D, BINOP_2, NEWTON,
      FUNCT_7, GR_CY_1, EUCLID, GCD_1;
 registrations XBOOLE_0, FUNCT_1, ORDINAL1, RELSET_1, NUMBERS, XXREAL_0,
      XREAL_0, NAT_1, INT_1, MEMBERED, SEQ_1, NEWTON, STRUCT_0, VECTSP_1,
      GR_CY_1, GCD_1;
 requirements REAL, NUMERALS, SUBSET, BOOLE, ARITHM;


begin

definition
  redefine func multint means
:: INT_3:def 1
  for a,b being Element of INT holds it.(a,b) = multreal.(a,b);
end;

definition
 redefine func compint means
:: INT_3:def 2
     for a being Element of INT holds it.(a) = compreal.(a);
end;

definition
func INT.Ring -> doubleLoopStr equals
:: INT_3:def 3
  doubleLoopStr(#INT,addint,multint,In (1,INT),In (0,INT)#);
end;

registration
 cluster INT.Ring -> strict non empty;
end;

registration
  cluster -> integer Element of INT.Ring;
end;

registration let a,b be Element of INT.Ring, c,d be Integer;
  identify a * b with c * d when a = c, b = d;
  identify a + b with c + d when a = c, b = d;
end;

registration
 cluster INT.Ring -> well-unital;
end;

registration
 cluster INT.Ring -> Abelian add-associative right_zeroed right_complementable
                     distributive commutative associative
                     domRing-like non degenerated;
end;

registration let a be Element of INT.Ring, b be Integer;
  identify -a with -b when a = b;
end;

definition
  canceled;
  let a be Element of INT.Ring;
  redefine func abs(a) -> Element of INT.Ring equals
:: INT_3:def 5
   a if a >= 0.INT.Ring
  otherwise - a;
end;

definition
func absint -> Function of the carrier of INT.Ring,NAT means
:: INT_3:def 6
 for a being Element of INT.Ring holds
 it.a = absreal.(a);
end;

theorem :: INT_3:1
for a being Element of INT.Ring holds absint.a = abs(a);

theorem :: INT_3:2
for a,b,q1,q2,r1,r2 being Element of INT.Ring
st b <> 0.INT.Ring &
   a = q1 * b + r1 & 0.INT.Ring <= r1 & r1 < abs(b) &
   a = q2 * b + r2 & 0.INT.Ring <= r2 & r2 < abs(b)
holds q1 = q2 & r1 = r2;

definition
let a,b be Element of INT.Ring;
assume b <> 0.INT.Ring;
func a div b -> Element of INT.Ring means
:: INT_3:def 7
 ex r being Element of INT.Ring st
 a = it * b + r & 0.INT.Ring <= r & r < abs(b);
end;

definition
let a,b be Element of INT.Ring;
assume b <> 0.INT.Ring;
func a mod b -> Element of INT.Ring means
:: INT_3:def 8
 ex q being Element of INT.Ring st
 a = q * b + it & 0.INT.Ring <= it & it < abs(b);
end;

theorem :: INT_3:3
   for a,b being Element of INT.Ring
st b <> 0.INT.Ring holds a = (a div b) * b + (a mod b);

::: Euclidian Domains
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

begin

definition
let I be non empty doubleLoopStr;
attr I is Euclidian means
:: INT_3:def 9
 ex f being Function of the carrier of I,NAT st
 for a,b being Element of I st b <> 0.I holds
 ex q,r being Element of I st
  a = q * b + r & (r = 0.I or f.r < f.b);
end;

registration
 cluster INT.Ring -> Euclidian;
end;

registration
cluster strict Euclidian domRing-like non degenerated
        distributive commutative Ring;
end;

definition
mode EuclidianRing is Euclidian domRing-like non degenerated
     distributive commutative Ring;
end;

registration
cluster strict EuclidianRing;
end;

definition
let E be Euclidian (non empty doubleLoopStr);
mode DegreeFunction of E ->
              Function of the carrier of E,NAT means
:: INT_3:def 10
 (for a,b being Element of E
  st b <> 0.E holds
  (ex q,r being Element of E st
  (a = q * b + r & (r = 0.E or it.r < it.b))));
end;

theorem :: INT_3:4
for E being EuclidianRing holds E is gcdDomain;

registration
cluster Euclidian -> gcd-like (domRing-like non degenerated
    Abelian add-associative right_zeroed right_complementable
    associative commutative well-unital right-distributive
     (non empty doubleLoopStr));
end;

definition
redefine func absint -> DegreeFunction of INT.Ring;
end;

theorem :: INT_3:5
for F being commutative associative well-unital Field-like right_zeroed
  (non empty doubleLoopStr) holds F is Euclidian;

registration
cluster commutative associative well-unital Field-like right_zeroed Field-like
  -> Euclidian (non empty doubleLoopStr);
end;

theorem :: INT_3:6
    for F being commutative associative well-unital Field-like right_zeroed
  (non empty doubleLoopStr)
for f being Function of the carrier of F,NAT holds
f is DegreeFunction of F;

::: Some Theorems about DIV and MOD
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

begin

canceled;

theorem :: INT_3:8
for n,a,k being Integer holds
(n <> 0 implies (a + n * k) div n = (a div n) + k) &
(a + n * k) mod n = a mod n;

theorem :: INT_3:9
for n being natural number st n > 0
for a being Integer holds a mod n >= 0 & a mod n < n;

theorem :: INT_3:10
for n,a being Integer holds
(0 <= a & a < n implies a mod n = a) &
(0 > a & a >= -n implies a mod n = n + a);

canceled;

theorem :: INT_3:12
for n,a,b being Integer holds
(n <> 0 & a mod n = b mod n implies a,b are_congruent_mod n) &
(a,b are_congruent_mod n implies a mod n = b mod n);

theorem :: INT_3:13
for n being natural number
for a being Integer holds (a mod n) mod n = a mod n;

theorem :: INT_3:14
for n,a,b being Integer holds
(a + b) mod n = ((a mod n) + (b mod n)) mod n;

theorem :: INT_3:15
for n,a,b being Integer holds
(a * b) mod n = ((a mod n) * (b mod n)) mod n;

theorem :: INT_3:16
for a,b being Integer ex s,t being Integer st a gcd b = s * a + t * b;

::: Modulo Integers
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

begin

definition
let n be natural number such that n > 0;
func multint(n) -> BinOp of Segm(n) means
:: INT_3:def 11
 for k,l being Element of Segm(n) holds
 it.(k,l) = (k * l) mod n;
end;

definition
let n be natural number such that n > 0;
func compint(n) -> UnOp of Segm(n) means
:: INT_3:def 12
 for k being Element of Segm(n) holds
 it.k = (n - k) mod n;
end;

theorem :: INT_3:17
for n being natural number st n > 0
for a,b being Element of Segm(n) holds
(a + b < n iff (addint(n)).(a,b) = a + b) &
(a + b >= n iff (addint(n)).(a,b) = (a + b) - n);

theorem :: INT_3:18
for n being natural number st n > 0
for a,b being Element of Segm(n)
for k being natural number holds
(k * n <= a * b & a * b < (k + 1) * n)
iff (multint(n)).(a,b) = a * b - k * n;

theorem :: INT_3:19
    for n being natural number st n > 0
for a being Element of Segm(n) holds
(a = 0 iff (compint(n)).(a) = 0) &
(a <> 0 iff (compint(n)).(a) = n - a);

definition let n be natural number;
func INT.Ring(n) -> doubleLoopStr equals
:: INT_3:def 13
  doubleLoopStr(#Segm(n),addint(n),multint(n),In (1,Segm(n)),In (0,Segm(n))#);
end;

registration let n be non zero natural number;
 cluster INT.Ring(n) -> strict non empty;
end;

theorem :: INT_3:20
INT.Ring 1 is degenerated & INT.Ring 1 is Ring &
INT.Ring 1 is Field-like unital distributive commutative;

registration
 cluster strict degenerated unital distributive Field-like commutative Ring;
end;

theorem :: INT_3:21
for n being natural number st n > 1 holds
 INT.Ring(n) is non degenerated &
 INT.Ring(n) is well-unital distributive commutative Ring;

theorem :: INT_3:22
for p being natural number st p > 1 holds
 INT.Ring(p) is add-associative right_zeroed right_complementable
    Abelian commutative associative well-unital distributive
      Field-like non degenerated (non empty doubleLoopStr)
  iff p is Prime;

registration
 cluster -> non zero Prime;
end;

registration
let p be Prime;
 cluster INT.Ring(p) -> add-associative right_zeroed right_complementable
   Abelian commutative associative well-unital distributive Field-like
    non degenerated;
end;

theorem :: INT_3:23
   1.INT.Ring = 1;

theorem :: INT_3:24
   for n being natural number st 1 < n holds 1.INT.Ring(n) = 1;

