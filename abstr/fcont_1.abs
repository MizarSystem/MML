:: Real Function Continuity
::  by Konrad Raczkowski and Pawe{\l} Sadowski
::
:: Received June 18, 1990
:: Copyright (c) 1990 Association of Mizar Users

environ

 vocabularies ARYTM, SEQ_1, PARTFUN1, RELAT_1, SEQ_2, ORDINAL2, FUNCT_1,
      SEQM_3, ABSVALUE, ARYTM_1, ARYTM_3, RCOMP_1, BOOLE, FINSEQ_1, COMPTS_1,
      SEQ_4, SQUARE_1, FCONT_1, FRECHET2, OPPCAT_1, COMPLEX1, ANPROJ_1, PROB_1,
      LATTICES, REALSET1;
 notations TARSKI, XBOOLE_0, SUBSET_1, RELAT_1, ORDINAL1, REALSET1, NUMBERS,
      XCMPLX_0, XXREAL_0, XREAL_0, COMPLEX1, REAL_1, NAT_1, FUNCT_1, RELSET_1,
      PARTFUN1, FUNCT_2, VALUED_0, VALUED_1, SEQ_1, SEQ_2, SEQM_3, SEQ_4,
      SQUARE_1, PARTFUN2, RFUNCT_1, RCOMP_1, RECDEF_1, RFUNCT_2;
 constructors PARTFUN1, REAL_1, SQUARE_1, NAT_1, COMPLEX1, VALUED_1, SEQ_2,
      SEQM_3, SEQ_4, RCOMP_1, PARTFUN2, RFUNCT_1, RFUNCT_2, SEQ_1, RECDEF_1;
 registrations XBOOLE_0, ORDINAL1, RELSET_1, NUMBERS, XXREAL_0, XREAL_0, NAT_1,
      MEMBERED, SEQM_3, RCOMP_1, RFUNCT_2, VALUED_0, VALUED_1, FUNCT_2,
      XXREAL_2, REALSET1, RELAT_1, RFUNCT_1, SEQ_2, FUNCT_1;
 requirements REAL, NUMERALS, SUBSET, BOOLE, ARITHM;


begin

reserve n,m,k for Element of NAT;
reserve x, X,X1,Z,Z1 for set;
reserve s,g,r,p,x0,x1,x2 for real number;
reserve s1,s2,q1 for Real_Sequence;
reserve Y for Subset of REAL;
reserve f,f1,f2 for PartFunc of REAL,REAL;

definition
  let f,x0;
  pred f is_continuous_in x0 means
:: FCONT_1:def 1

  for s1 st rng s1 c= dom f & s1 is convergent & lim s1 = x0 holds
  f/*s1 is convergent & f.x0 = lim (f/*s1);
end;

theorem :: FCONT_1:1
  x0 in X & f is_continuous_in x0 implies f|X is_continuous_in x0;

theorem :: FCONT_1:2
  f is_continuous_in x0 iff for s1 st rng s1 c= dom f &
  s1 is convergent & lim s1=x0 & (for n holds s1.n<>x0) holds
  f/*s1 is convergent & f.x0=lim(f/*s1);

theorem :: FCONT_1:3
  f is_continuous_in x0 iff
  for r st 0<r ex s st 0<s & for x1 st x1 in dom f & abs(x1-x0)<s holds
  abs(f.x1-f.x0)<r;

theorem :: FCONT_1:4
  for f,x0 holds f is_continuous_in x0 iff
  for N1 being Neighbourhood of f.x0 ex N being Neighbourhood of x0 st
  for x1 st x1 in dom f & x1 in N holds f.x1 in N1;

theorem :: FCONT_1:5
  for f,x0 holds f is_continuous_in x0 iff
  for N1 being Neighbourhood of f.x0
  ex N being Neighbourhood of x0 st f.:N c= N1;

theorem :: FCONT_1:6
  (ex N be Neighbourhood of x0 st dom f /\ N = {x0}) implies
  f is_continuous_in x0;

theorem :: FCONT_1:7
  x0 in dom f1 /\ dom f2 & f1 is_continuous_in x0 & f2 is_continuous_in x0
   implies
  f1+f2 is_continuous_in x0 & f1-f2 is_continuous_in x0 &
  f1(#)f2 is_continuous_in x0;

theorem :: FCONT_1:8
  x0 in dom f & f is_continuous_in x0 implies r(#)f is_continuous_in x0;

theorem :: FCONT_1:9
  x0 in dom f & f is_continuous_in x0 implies abs(f) is_continuous_in x0 &
  -f is_continuous_in x0;

theorem :: FCONT_1:10
  f is_continuous_in x0 & f.x0<>0 implies f^ is_continuous_in x0;

theorem :: FCONT_1:11
 x0 in dom f2 &  f1 is_continuous_in x0 & f1.x0<>0 & f2 is_continuous_in x0
   implies f2/f1 is_continuous_in x0;

theorem :: FCONT_1:12
  x0 in dom (f2*f1) & f1 is_continuous_in x0 & f2 is_continuous_in f1.x0
  implies f2*f1 is_continuous_in x0;

definition
  let f;
  attr f is continuous means
:: FCONT_1:def 2
 for x0 st x0 in dom f holds f is_continuous_in x0;
end;

canceled;

theorem :: FCONT_1:14
  for X,f st X c= dom f holds f|X is continuous iff
  for s1 st rng s1 c= X & s1 is convergent & lim s1 in X holds
  f/*s1 is convergent & f.(lim s1) = lim (f/*s1);

theorem :: FCONT_1:15
  X c= dom f implies (f|X is continuous iff
  for x0,r st x0 in X & 0<r ex s st 0<s & for x1 st x1 in X &
  abs(x1-x0) < s holds abs(f.x1 - f.x0) < r);

registration
 cluster constant -> continuous PartFunc of REAL,REAL;
end;

registration
 cluster continuous PartFunc of REAL,REAL;
end;

registration let f be continuous PartFunc of REAL,REAL, X be set;
 cluster f|X -> continuous PartFunc of REAL,REAL;
end;

theorem :: FCONT_1:16
  f|X is continuous iff f|X|X is continuous;

theorem :: FCONT_1:17
   f|X is continuous & X1 c= X implies f|X1 is continuous;

registration
 cluster empty -> continuous PartFunc of REAL,REAL;
end;

registration let f; let X be trivial set;
 cluster f|X -> continuous PartFunc of REAL,REAL;
end;

theorem :: FCONT_1:18
  f|{x0} is continuous;

registration let f1,f2 be continuous PartFunc of REAL,REAL;
 cluster f1+f2 -> continuous PartFunc of REAL,REAL;
 cluster f1-f2 -> continuous PartFunc of REAL,REAL;
 cluster f1(#)f2 -> continuous PartFunc of REAL,REAL;
end;

theorem :: FCONT_1:19
  for X,f1,f2 st X c= dom f1 /\ dom f2 &
   f1|X is continuous & f2|X is continuous holds
  (f1+f2)|X is continuous & (f1-f2)|X is continuous &
  (f1(#)f2)|X is continuous;

theorem :: FCONT_1:20
  for X,X1,f1,f2 st X c= dom f1 & X1 c= dom f2 &
   f1|X is continuous & f2|X1 is continuous holds
  (f1+f2)|(X /\ X1) is continuous & (f1-f2)|(X /\ X1) is continuous &
  (f1(#)f2)|(X /\ X1) is continuous;

registration let f be continuous PartFunc of REAL,REAL; let r;
 cluster r(#)f -> continuous PartFunc of REAL,REAL;
end;

theorem :: FCONT_1:21
  for r,X,f st X c= dom f & f|X is continuous
   holds (r(#)f)|X is continuous;

theorem :: FCONT_1:22
  X c= dom f & f|X is continuous implies (abs f)|X is continuous &
  (-f)|X is continuous;

theorem :: FCONT_1:23
  f|X is continuous & f"{0} = {}
   implies f^|X is continuous;

theorem :: FCONT_1:24
  f|X is continuous & (f|X)"{0} = {}
   implies f^|X is continuous;

theorem :: FCONT_1:25
   X c= dom f1 /\ dom f2 &
  f1|X is continuous & f1"{0} = {} & f2|X is continuous
   implies (f2/f1)|X is continuous;

registration let f1,f2 be continuous PartFunc of REAL,REAL;
 cluster f2*f1 -> continuous PartFunc of REAL,REAL;
end;

theorem :: FCONT_1:26
  f1|X is continuous & f2|(f1.:X) is continuous implies
  (f2*f1)|X is continuous;

theorem :: FCONT_1:27
  f1|X is continuous & f2|X1 is continuous implies
  (f2*f1)|(X /\ (f1"X1)) is continuous;

theorem :: FCONT_1:28
  f is total & (for x1,x2 holds f.(x1+x2) = f.x1 + f.x2) &
  (ex x0 st f is_continuous_in x0) implies f|REAL is continuous;

theorem :: FCONT_1:29

for f st dom f is compact & f|dom f is continuous holds (rng f) is compact;

theorem :: FCONT_1:30
  Y c= dom f & Y is compact & f|Y is continuous implies (f.:Y) is compact;

theorem :: FCONT_1:31
  for f st dom f<>{} & (dom f) is compact & f|dom f is continuous
  ex x1,x2 st x1 in dom f & x2 in dom f & f.x1 = upper_bound (rng f) &
  f.x2 = lower_bound (rng f);

theorem :: FCONT_1:32
  for f,Y st Y<>{} & Y c= dom f & Y is compact & f|Y is continuous
  ex x1,x2 st x1 in Y & x2 in Y &
  f.x1 = upper_bound (f.:Y) & f.x2 = lower_bound (f.:Y);

definition
  let f;
  attr f is Lipschitzian means
:: FCONT_1:def 3

  ex r st 0<r & for x1,x2 st x1 in dom f & x2 in dom f holds
  abs(f.x1-f.x2)<=r*abs(x1-x2);
end;

theorem :: FCONT_1:33
 f|X is Lipschitzian iff
  ex r st 0<r & for x1,x2 st x1 in dom(f|X) & x2 in dom(f|X) holds
  abs(f.x1-f.x2)<=r*abs(x1-x2);

registration
 cluster empty -> Lipschitzian PartFunc of REAL,REAL;
end;

registration
 cluster empty PartFunc of REAL,REAL;
end;

registration let f be Lipschitzian PartFunc of REAL,REAL, X be set;
 cluster f|X -> Lipschitzian PartFunc of REAL,REAL;
end;

theorem :: FCONT_1:34
  f|X is Lipschitzian & X1 c= X implies f|X1 is Lipschitzian;

registration let f1,f2 be Lipschitzian PartFunc of REAL,REAL;
 cluster f1+f2 -> Lipschitzian PartFunc of REAL,REAL;
 cluster f1-f2 -> Lipschitzian PartFunc of REAL,REAL;

end;

theorem :: FCONT_1:35
  f1|X is Lipschitzian & f2|X1 is Lipschitzian implies
  (f1+f2)|(X /\ X1) is Lipschitzian;

theorem :: FCONT_1:36
  f1|X is Lipschitzian & f2|X1 is Lipschitzian implies
  (f1-f2)|(X /\ X1) is Lipschitzian;

registration
 let f1,f2 be bounded Lipschitzian PartFunc of REAL,REAL;
 cluster f1 (#) f2 -> Lipschitzian PartFunc of REAL,REAL;
end;

theorem :: FCONT_1:37
  f1|X is Lipschitzian & f2|X1 is Lipschitzian &
  f1|Z is bounded & f2|Z1 is bounded implies
  (f1(#)f2)|(X /\ Z /\ X1 /\ Z1) is Lipschitzian;

registration let f be Lipschitzian PartFunc of REAL, REAL; let p;
 cluster p(#)f -> Lipschitzian PartFunc of REAL, REAL;
end;

theorem :: FCONT_1:38
  f|X is Lipschitzian & X c= dom f implies (p(#)f)|X is Lipschitzian;

registration let f be Lipschitzian PartFunc of REAL, REAL;
 cluster abs f -> Lipschitzian PartFunc of REAL, REAL;
end;

theorem :: FCONT_1:39
  f|X is Lipschitzian implies -f|X is Lipschitzian &
  (abs f)|X is Lipschitzian;

registration
 cluster constant -> Lipschitzian PartFunc of REAL, REAL;
end;

theorem :: FCONT_1:40
  f|X is constant implies f|X is Lipschitzian;

registration let Y;
 cluster id Y -> Lipschitzian PartFunc of REAL,REAL;
end;

theorem :: FCONT_1:41
  (id Y)|Y is Lipschitzian;

registration
 cluster Lipschitzian -> continuous PartFunc of REAL, REAL;
end;

theorem :: FCONT_1:42
  f|X is Lipschitzian implies f|X is continuous;

theorem :: FCONT_1:43
  for f st (ex r st rng f = {r}) holds f is continuous;

theorem :: FCONT_1:44
  X c= dom f & f|X is constant implies f|X is continuous;

theorem :: FCONT_1:45

for f st (for x0 st x0 in dom f holds f.x0 = x0) holds f is continuous;

theorem :: FCONT_1:46
  f = id dom f implies f is continuous;

theorem :: FCONT_1:47
  Y c= dom f & f|Y = id Y implies f|Y is continuous;

theorem :: FCONT_1:48
  (for x0 st x0 in X holds f.x0 = r*x0+p) implies
  f|X is continuous;

theorem :: FCONT_1:49
  (for x0 st x0 in dom f holds f.x0 = x0^2) implies f|dom f is continuous;

theorem :: FCONT_1:50
  X c= dom f & (for x0 st x0 in X holds f.x0 = x0^2) implies
  f|X is continuous;

theorem :: FCONT_1:51
  (for x0 st x0 in dom f holds f.x0 = abs(x0)) implies
  f is continuous;

theorem :: FCONT_1:52
  X c= dom f & (for x0 st x0 in X holds f.x0 = abs(x0)) implies
  f|X is continuous;

theorem :: FCONT_1:53
  f|X is monotone & (ex p,g st p<=g & f.:X=[.p,g.]) implies
  f|X is continuous;

theorem :: FCONT_1:54
  for f being one-to-one PartFunc of REAL,REAL st
  p<=g & [.p,g.] c= dom f & (f|[.p,g.] is increasing or
  f|[.p,g.] is decreasing) holds (f|[.p,g.])"|(f.:[.p,g.]) is continuous;

