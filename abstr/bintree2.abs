:: Full Trees
::  by Robert Milewski
::
:: Received February 25, 1998
:: Copyright (c) 1998 Association of Mizar Users

environ

 vocabulary FINSEQ_1, RELAT_1, BINTREE1, TREES_1, MARGREL1, BOOLE, ORDINAL1,
      FUNCT_1, TREES_2, MIDSP_3, TREES_4, CQC_LANG, MCART_1, FINSEQ_5,
      BINARITH, CAT_1, EUCLID, FINSET_1, POWER, BINARI_3, ARYTM_1, ZF_LANG,
      CARD_1, FINSEQ_2, TARSKI, NAT_1, MATRIX_2, BINTREE2, FINSEQ_4;
 notation TARSKI, XBOOLE_0, ZFMISC_1, SUBSET_1, NUMBERS, XREAL_0, MCART_1,
      REAL_1, NAT_1, ABIAN, SERIES_1, RELAT_1, CARD_1, MARGREL1, DOMAIN_1,
      FUNCT_1, FUNCT_2, FINSET_1, CQC_LANG, FINSEQ_1, FINSEQ_2, FINSEQ_4,
      FINSEQ_5, BINARITH, BINARI_3, TREES_1, TREES_2, TREES_4, BINTREE1,
      EUCLID, MIDSP_3;
 constructors REAL_1, ABIAN, SERIES_1, DOMAIN_1, WELLORD2, TREES_9, CQC_LANG,
      FINSEQ_5, FINSEQOP, BINARITH, BINARI_3, BINTREE1, EUCLID, FINSEQ_4,
      INT_1, MEMBERED;
 clusters SUBSET_1, XREAL_0, RELSET_1, FINSET_1, BINTREE1, TREES_2, TREES_9,
      BINARITH, MARGREL1, FINSEQ_1, NAT_1, MEMBERED, NUMBERS, ORDINAL2;
 requirements REAL, NUMERALS, BOOLE, SUBSET, ARITHM;


begin :: Trees and Binary Trees

  theorem :: BINTREE2:1
   for D be set
   for p be FinSequence
   for n be Nat holds
    p in D* implies p|Seg n in D*;

  theorem :: BINTREE2:2
   for T be binary Tree
   for t be Element of T holds
    t is FinSequence of BOOLEAN;

  definition
   let T be binary Tree;
   redefine mode Element of T -> FinSequence of BOOLEAN;
  end;


  theorem :: BINTREE2:3
   for T be Tree st T = {0,1}* holds
    T is binary;

  theorem :: BINTREE2:4
   for T be Tree st T = {0,1}* holds
    Leaves T = {};

  theorem :: BINTREE2:5
     for T be binary Tree
   for n be Nat
   for t be Element of T st t in T-level n holds
    t is Tuple of n,BOOLEAN;

  theorem :: BINTREE2:6
     for T be Tree st
    for t be Element of T holds succ t = { t^<* 0 *>, t^<* 1 *> } holds
     Leaves T = {};

  theorem :: BINTREE2:7
   for T be Tree st
    for t be Element of T holds succ t = { t^<* 0 *>, t^<* 1 *> } holds
     T is binary;

  theorem :: BINTREE2:8
   for T be Tree holds
    T = {0,1}* iff
    for t be Element of T holds succ t = { t^<* 0 *>, t^<* 1 *> };

  scheme :: BINTREE2:sch 1
 DecoratedBinTreeEx {A() -> non empty set, a() -> Element of A(),
                             P[set,set,set]}:
   ex D be binary DecoratedTree of A() st dom D = {0,1}* & D.{} = a() &
    for x be Node of D holds P[D.x,D.(x ^ <* 0 *>),D.(x ^ <*1*>)]
   provided
     for a be Element of A() ex b,c be Element of A() st P[a,b,c]
proof
    defpred Q[set,set] means
     ex b,c be Element of A() st P[$1,b,c] & $2 = [b,c];
    A2: for e be set st e in A() ex u be set st u in [:A(),A():] & Q[e,u]
    proof
     let e be set;
     assume e in A();
     then consider b,c be Element of A() such that
      A3: P[e,b,c] by A1;
     take u = [b,c];
     thus u in [:A(),A():];
     thus Q[e,u] by A3;
    end;
    consider f be Function such that
     A4: dom f = A() and
     A5: rng f c= [:A(),A():] and
     A6: for e be set st e in A() holds Q[e,f.e] from COMPTS_1:sch 1(A2);
    deffunc _F(set) = IFEQ($1`2,0,(f.($1`1))`1,(f.($1`1))`2);
    A7: for x be set st x in [:A(),NAT:] holds _F(x) in A() proof
     let x be set;
     assume x in [:A(),NAT:];
     then x`1 in A() by MCART_1:10;
     then f.(x`1) in rng f by A4,FUNCT_1:def 5;
     then A8: (f.(x`1))`1 in A() & (f.(x`1))`2 in A() by A5,MCART_1:10;
       now per cases;
      suppose x`2 = 0;
       hence IFEQ(x`2,0,(f.(x`1))`1,(f.(x`1))`2) in A() by A8,CQC_LANG:def 1;
      end;
      suppose x`2 <> 0;
       hence IFEQ(x`2,0,(f.(x`1))`1,(f.(x`1))`2) in A() by A8,CQC_LANG:def 1;
     end;
     end;
     hence IFEQ(x`2,0,(f.(x`1))`1,(f.(x`1))`2) in A();
    end;
    consider F be Function of [:A(),NAT:],A() such that
     A9: for x be set st x in [:A(),NAT:] holds F.x = _F(x) from FUNCT_2:sch 2
(A7);
    A10: for e be set st e in A() holds P[e,F.[e,0],F.[e,1]]
    proof
     let e be set;
     assume A11: e in A();
     then consider b,c be Element of A() such that
      A12: P[e,b,c] and
      A13: f.e = [b,c] by A6;
     A14: [e,0]`2 = 0 by MCART_1:7;
       [e,0] in [:A(),NAT:] by A11,ZFMISC_1:106;
     then A15: F.[e,0] = IFEQ([e,0]`2,0,(f.([e,0]`1))`1,(f.([e,0]`1))`2) by A9
        .= (f.([e,0]`1))`1 by A14,CQC_LANG:def 1
        .= (f.e)`1 by MCART_1:7
        .= b by A13,MCART_1:7;
     A16: [e,1]`2 = 1 & 1 <> 0 by MCART_1:7;
       [e,1] in [:A(),NAT:] by A11,ZFMISC_1:106;
     then F.[e,1] = IFEQ([e,1]`2,0,(f.([e,1]`1))`1,(f.([e,1]`1))`2) by A9
        .= (f.([e,1]`1))`2 by A16,CQC_LANG:def 1
        .= (f.e)`2 by MCART_1:7
        .= c by A13,MCART_1:7;
     hence P[e,F.[e,0],F.[e,1]] by A12,A15;
    end;
    deffunc _F(set) = 2;
    consider D be DecoratedTree of A() such that
     A17: D.{} = a() and
     A18: for d be Element of dom D holds
      succ d = { d^<*k*> where k is Nat : k < _F(D.d) } &
      for n be Nat, x be set st x = D.d & n < _F(x)
        holds D.(d^<*n*>) = F.[x,n] from TREES_2:sch 9;
      now let t be Element of dom D;
     assume not t in Leaves dom D;
       { t^<*k*> where k is Nat : k < 2 } = { t^<* 0 *>, t^<* 1 *> }
     proof
      thus { t^<*k*> where k is Nat : k < 2 } c= { t^<* 0 *>, t^<* 1 *> }
      proof
       let v be set;
       assume v in { t^<*k*> where k is Nat : k < 2 };
       then consider k be Nat such that
        A19: v = t^<*k*> and
        A20: k < 2;
         k = 0 or k = 1 by A20,ALGSEQ_1:4;
       hence v in { t^<* 0 *>, t^<* 1 *> } by A19,TARSKI:def 2;
      end;
      let v be set;
      assume v in { t^<* 0 *>, t^<* 1 *> };
      then v = t^<* 0 *> or v = t^<* 1 *> by TARSKI:def 2;
      hence v in { t^<*k*> where k is Nat : k < 2 };
     end;
     hence succ t = { t^<* 0 *>, t^<* 1 *> } by A18;
    end;
    then dom D is binary by BINTREE1:def 2;
    then reconsider D as binary DecoratedTree of A() by BINTREE1:def 3;
    take D;
      now let t be Element of dom D;
       { t^<*k*> where k is Nat : k < 2 } = { t^<* 0 *>, t^<* 1 *> }
     proof
      thus { t^<*k*> where k is Nat : k < 2 } c= { t^<* 0 *>, t^<* 1 *> }
      proof
       let v be set;
       assume v in { t^<*k*> where k is Nat : k < 2 };
       then consider k be Nat such that
        A21: v = t^<*k*> and
        A22: k < 2;
         k = 0 or k = 1 by A22,ALGSEQ_1:4;
       hence v in { t^<* 0 *>, t^<* 1 *> } by A21,TARSKI:def 2;
      end;
      let v be set;
      assume v in { t^<* 0 *>, t^<* 1 *> };
      then v = t^<* 0 *> or v = t^<* 1 *> by TARSKI:def 2;
      hence v in { t^<*k*> where k is Nat : k < 2 };
     end;
     hence succ t = { t^<* 0 *>, t^<* 1 *> } by A18;
    end;
    hence dom D = {0,1}* by Th8;
    thus D.{} = a() by A17;
    let x be Node of D;
      P[D.x,F.[D.x,0],F.[D.x,1]] by A10;
    then P[D.x,D.(x ^ <* 0 *>),F.[D.x,1]] by A18;
    hence P[D.x,D.(x ^ <* 0 *>),D.(x ^ <* 1 *>)] by A18;
   end;

  scheme :: BINTREE2:sch 2
 DecoratedBinTreeEx1 {A() -> non empty set, a() -> Element of A(),
                             P[set,set], Q[set,set]}:
   ex D be binary DecoratedTree of A() st dom D = {0,1}* & D.{} = a() &
    for x be Node of D holds P[D.x,D.(x ^ <* 0 *>)] & Q[D.x,D.(x ^ <*1*>)]
   provided
     for a be Element of A() ex b be Element of A() st P[a,b] and
     for a be Element of A() ex b be Element of A() st Q[a,b]
proof
    defpred _P[set,set] means
    ( $1`2 = 0 implies P[$1`1,$2] ) & ( $1`2 = 1 implies Q[$1`1,$2] );
    A3: for e be set st e in [:A(),NAT:] ex u be set st u in A() & _P[e,u]
    proof
     let e be set;
     assume e in [:A(),NAT:];
     then reconsider e1 = e`1 as Element of A() by MCART_1:10;
     consider u1 be Element of A() such that
      A4: P[e1,u1] by A1;
     consider u2 be Element of A() such that
      A5: Q[e1,u2] by A2;
     take u = IFEQ(e`2,0,u1,u2);
     thus u in A();
     thus e`2 = 0 implies P[e`1,u] by A4,CQC_LANG:def 1;
     thus e`2 = 1 implies Q[e`1,u] by A5,CQC_LANG:def 1;
    end;
    consider F be Function such that
     A6: dom F = [:A(),NAT:] and
     A7: rng F c= A() and
     A8: for e be set st e in [:A(),NAT:] holds _P[e,F.e]
                                                 from COMPTS_1:sch 1(A3);
    reconsider F as Function of [:A(),NAT:],A() by A6,A7,FUNCT_2:4;
    deffunc _F(set) = 2;
    consider D be DecoratedTree of A() such that
     A9: D.{} = a() and
     A10: for d be Element of dom D holds
      succ d = { d^<*k*> where k is Nat : k < _F(D.d) } &
      for n be Nat, x be set st x = D.d & n < _F(x) holds D.(d^<*n*>) = F.[x,n]
                                                       from TREES_2:sch 9;
      now let t be Element of dom D;
     assume not t in Leaves dom D;
       { t^<*k*> where k is Nat : k < 2 } = { t^<* 0 *>, t^<* 1 *> }
     proof
      thus { t^<*k*> where k is Nat : k < 2 } c= { t^<* 0 *>, t^<* 1 *> }
      proof
       let v be set;
       assume v in { t^<*k*> where k is Nat : k < 2 };
       then consider k be Nat such that
        A11: v = t^<*k*> and
        A12: k < 2;
         k = 0 or k = 1 by A12,ALGSEQ_1:4;
       hence v in { t^<* 0 *>, t^<* 1 *> } by A11,TARSKI:def 2;
      end;
      let v be set;
      assume v in { t^<* 0 *>, t^<* 1 *> };
      then v = t^<* 0 *> or v = t^<* 1 *> by TARSKI:def 2;
      hence v in { t^<*k*> where k is Nat : k < 2 };
     end;
     hence succ t = { t^<* 0 *>, t^<* 1 *> } by A10;
    end;
    then dom D is binary by BINTREE1:def 2;
    then reconsider D as binary DecoratedTree of A() by BINTREE1:def 3;
    take D;
      now let t be Element of dom D;
       { t^<*k*> where k is Nat : k < 2 } = { t^<* 0 *>, t^<* 1 *> }
     proof
      thus { t^<*k*> where k is Nat : k < 2 } c= { t^<* 0 *>, t^<* 1 *> }
      proof
       let v be set;
       assume v in { t^<*k*> where k is Nat : k < 2 };
       then consider k be Nat such that
        A13: v = t^<*k*> and
        A14: k < 2;
         k = 0 or k = 1 by A14,ALGSEQ_1:4;
       hence v in { t^<* 0 *>, t^<* 1 *> } by A13,TARSKI:def 2;
      end;
      let v be set;
      assume v in { t^<* 0 *>, t^<* 1 *> };
      then v = t^<* 0 *> or v = t^<* 1 *> by TARSKI:def 2;
      hence v in { t^<*k*> where k is Nat : k < 2 };
     end;
     hence succ t = { t^<* 0 *>, t^<* 1 *> } by A10;
    end;
    hence dom D = {0,1}* by Th8;
    thus D.{} = a() by A9;
    let x be Node of D;
      [D.x,0]`2 = 0 by MCART_1:7;
    then P[[D.x,0]`1,F.[D.x,0]] by A8;
    then P[D.x,F.[D.x,0]] by MCART_1:7;
    hence P[D.x,D.(x ^ <* 0 *>)] by A10;
      [D.x,1]`2 = 1 by MCART_1:7;
    then Q[[D.x,1]`1,F.[D.x,1]] by A8;
    then Q[D.x,F.[D.x,1]] by MCART_1:7;
    hence Q[D.x,D.(x ^ <* 1 *>)] by A10;
   end;

  definition
   let T be binary Tree;
   let n be non empty Nat;
   func NumberOnLevel(n,T) -> Function of T-level n,NAT means
:: BINTREE2:def 1
    for t be Element of T st t in T-level n
    for F be Tuple of n,BOOLEAN st F = Rev t holds
     it.t = (Absval F) + 1;
  end;


  registration
   let T be binary Tree;
   let n be non empty Nat;
   cluster NumberOnLevel(n,T) -> one-to-one;
   coherence
   proof
      now let x1,x2 be set;
     assume that
      A1: x1 in dom NumberOnLevel(n,T) and
      A2: x2 in dom NumberOnLevel(n,T) and
      A3: NumberOnLevel(n,T).x1 = NumberOnLevel(n,T).x2;
     A4: x1 in T-level n by A1,FUNCT_2:def 1;
     then x1 in { w where w is Element of T : len w = n } by TREES_2:def 6;
     then consider t1 be Element of T such that
      A5: t1 = x1 and
      A6: len t1 = n;
       len Rev t1 = n by A6,FINSEQ_5:def 3;
     then reconsider F1 = Rev t1 as Tuple of n,BOOLEAN by FINSEQ_2:110;
     A7: x2 in T-level n by A2,FUNCT_2:def 1;
     then x2 in { w where w is Element of T : len w = n } by TREES_2:def 6;
     then consider t2 be Element of T such that
      A8: t2 = x2 and
      A9: len t2 = n;
       len Rev t2 = n by A9,FINSEQ_5:def 3;
     then reconsider F2 = Rev t2 as Tuple of n,BOOLEAN by FINSEQ_2:110;
       (Absval F1) + 1 = NumberOnLevel(n,T).x1 by A4,A5,Def1
        .= (Absval F2) + 1 by A3,A7,A8,Def1;
     then Absval F1 = Absval F2 by XCMPLX_1:2;
     then F1 = F2 by BINARI_3:2;
     hence x1 = x2 by A5,A8,BINARI_3:3;
    end;
    hence NumberOnLevel(n,T) is one-to-one by FUNCT_1:def 8;
   end;
  end;


begin :: Full Trees

  definition
   let T be Tree;
   attr T is full means
:: BINTREE2:def 2
    T = {0,1}*;
  end;


  theorem :: BINTREE2:9
   {0,1}* is Tree;

  theorem :: BINTREE2:10
   for T be Tree st T = {0,1}*
   for n be Nat holds
    0*n in T-level n;

  theorem :: BINTREE2:11
   for T be Tree st T = {0,1}*
   for n be non empty Nat
   for y be Tuple of n,BOOLEAN holds
    y in T-level n;

  registration
   let T be binary Tree;
   let n be Nat;
   cluster T-level n -> finite;
   coherence by QC_LANG4:19;
  end;


  registration
   cluster full -> binary Tree;
   coherence
   proof
    let T be Tree;
    assume T is full;
    then T = {0,1}* by Def2;
    hence T is binary by Th3;
   end;
  end;


  registration
   cluster full Tree;
   existence
   proof
    reconsider T = {0,1}* as Tree by Th9;
    take T;
    thus T is full by Def2;
   end;
  end;


  theorem :: BINTREE2:12
   for T be full Tree
   for n be non empty Nat holds
    Seg (2 to_power n) c= rng NumberOnLevel(n,T);

  definition
   let T be full Tree;
   let n be non empty Nat;
   func FinSeqLevel(n,T) -> FinSequence of T-level n equals
:: BINTREE2:def 3
    NumberOnLevel(n,T)";
  end;


  registration
   let T be full Tree;
   let n be non empty Nat;
   cluster FinSeqLevel(n,T) -> one-to-one;
   coherence
   proof
      NumberOnLevel(n,T)" is one-to-one by FUNCT_1:62;
    hence FinSeqLevel(n,T) is one-to-one by Def3;
   end;
  end;


  theorem :: BINTREE2:13
   for T be full Tree
   for n be non empty Nat holds
    NumberOnLevel(n,T).(0*n) = 1;

  theorem :: BINTREE2:14
   for T be full Tree
   for n be non empty Nat
   for y be Tuple of n,BOOLEAN st y = 0*n holds
    NumberOnLevel(n,T).'not' y = 2 to_power n;

  theorem :: BINTREE2:15
   for T be full Tree
   for n be non empty Nat holds
    FinSeqLevel(n,T).1 = 0*n;

  theorem :: BINTREE2:16
   for T be full Tree
   for n be non empty Nat
   for y be Tuple of n,BOOLEAN st y = 0*n holds
    FinSeqLevel(n,T).(2 to_power n) = 'not' y;

  theorem :: BINTREE2:17
   for T be full Tree
   for n be non empty Nat
   for i be Nat st i in Seg (2 to_power n) holds
    FinSeqLevel(n,T).i = Rev (n-BinarySequence (i-'1));

  theorem :: BINTREE2:18
   for T be full Tree
   for n be Nat holds
    Card (T-level n) = 2 to_power n;

  theorem :: BINTREE2:19
   for T be full Tree
   for n be non empty Nat holds
    len FinSeqLevel(n,T) = 2 to_power n;

  theorem :: BINTREE2:20
   for T be full Tree
   for n be non empty Nat holds
    dom FinSeqLevel(n,T) = Seg (2 to_power n);

  theorem :: BINTREE2:21
     for T be full Tree
   for n be non empty Nat holds
    rng FinSeqLevel(n,T) = T-level n;

  theorem :: BINTREE2:22
     for T be full Tree holds
    FinSeqLevel(1,T).1 = <* 0 *>;

  theorem :: BINTREE2:23
     for T be full Tree holds
    FinSeqLevel(1,T).2 = <* 1 *>;

  theorem :: BINTREE2:24
     for T be full Tree
   for n,i be non empty Nat st i <= 2 to_power (n+1)
   for F be Tuple of n,BOOLEAN st F = FinSeqLevel(n,T).((i+1) div 2) holds
    FinSeqLevel(n+1,T).i = F^<*(i+1) mod 2*>;
