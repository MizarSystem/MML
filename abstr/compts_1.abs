:: Compact Spaces
::  by Agata Darmochwa{\l}
::
:: Received September 19, 1989
:: Copyright (c) 1990 Association of Mizar Users

environ

 vocabulary FUNCT_1, RELAT_1, BOOLE, MCART_1, FINSET_1, ORDERS_1, TARSKI,
      PRE_TOPC, SETFAM_1, SUBSET_1, ORDINAL2, TOPS_2, COMPTS_1;
 notation TARSKI, XBOOLE_0, ZFMISC_1, SUBSET_1, MCART_1, RELAT_1, FUNCT_1,
      FUNCT_2, FUNCT_3, SETFAM_1, FINSET_1, ORDERS_1, DOMAIN_1, STRUCT_0,
      PRE_TOPC, TOPS_2;
 constructors FUNCT_3, FINSET_1, ORDERS_1, DOMAIN_1, TOPS_2, MEMBERED;
 clusters FUNCT_1, PRE_TOPC, STRUCT_0, RELSET_1, SUBSET_1, FINSET_1, MEMBERED,
      ZFMISC_1;
 requirements SUBSET, BOOLE;


begin

reserve x, y, z, X, Y, Z for set;
reserve f for Function;

scheme :: COMPTS_1:sch 1
 NonUniqBoundFuncEx { X() -> set, Y() -> set, P[set,set] }:
 ex f being Function st dom f = X() & rng f c= Y() &
   for x st x in X() holds P[x,f.x]
  provided
 for x st x in X() ex y st y in Y() & P[x,y]
proof   defpred Q[set,set] means
    ex X st $2 = X & for y holds y in X iff y in Y() & P[$1,y];
A2:  for e,u1,u2 being set st e in X() & Q[e,u1] & Q[e,u2] holds u1 = u2
     proof let e,u1,u2 be set such that e in X();
      given X such that
A3:    u1 = X and
A4:    for y holds y in X iff y in Y() & P[e,y];
      given Y such that
A5:    u2 = Y and
A6:    for y holds y in Y iff y in Y() & P[e,y];
       defpred A[set] means $1 in Y() & P[e,$1];
A7:    for x be set holds x in X iff A[x] by A4;
A8:    for x be set holds x in Y iff A[x] by A6;
        X = Y from XBOOLE_0:sch 2(A7,A8);
      hence thesis by A3,A5;
     end;
A9:  for x st x in X() ex y st Q[x,y]
     proof let x such that x in X();
       defpred R[set] means P[x,$1];
      consider X such that
A10:    y in X iff y in Y() & R[y] from XBOOLE_0:sch 1;
      take X,X; thus thesis by A10;
     end;
   consider G being Function such that
A11:  dom G = X() & for x st x in X() holds Q[x,G.x] from FUNCT_1:sch 2(A2,A9);
A12:  now assume
A13:   X() = {};
     deffunc G(set) = 0;
     consider F being Function such that
A14:   dom F = {} & for x st x in {} holds F.x = G(x) from FUNCT_1:sch 3;
     thus thesis
       proof take F; thus dom F = X() by A13,A14; rng F = {} by A14,RELAT_1:65;
        hence thesis by A13,XBOOLE_1:2;
       end;
    end;
      now assume X() <> {};
     then reconsider D = rng G as non empty set by A11,RELAT_1:65;
        now let X; assume X in D;
       then consider x such that
A15:     x in dom G & X = G.x by FUNCT_1:def 5;
A16:     ex Y st X = Y & for y holds y in Y iff y in Y() & P[x,y] by A11,A15;
       consider y such that
A17:     y in Y() & P[x,y] by A1,A11,A15;
       thus X <> {} by A16,A17;
      end;
     then consider F be Function such that
A18:   dom F = D and
A19:   for X st X in D holds F.X in X by WELLORD2:28;
A20:   dom (F*G) = X() & rng (F*G) = rng F by A11,A18,RELAT_1:46,47;
     thus thesis
       proof take f = F*G; thus dom f = X() by A11,A18,RELAT_1:46;
           rng F c= Y()
          proof let x; assume x in rng F;
           then consider y such that
A21:         y in dom F & x = F.y by FUNCT_1:def 5;
           consider z such that
A22:         z in dom G & y = G.z by A18,A21,FUNCT_1:def 5;
           consider X such that
A23:         y = X & for x holds x in X iff x in Y() & P[z,x] by A11,A22;
              x in X by A18,A19,A21,A23;
           hence x in Y() by A23;
          end;
        hence rng f c= Y() by A18,RELAT_1:47;
        let x; assume
A24:       x in X();
        then consider X such that
A25:      G.x = X & for y holds y in X iff y in Y() & P[x,y] by A11;
           f.x = F.X & X in D by A11,A20,A24,A25,FUNCT_1:22,def 5;
         then f.x in X by A19;
        hence P[x,f.x] by A25;
       end;
    end;
   hence thesis by A12;
  end;

scheme :: COMPTS_1:sch 2
 BiFuncEx{A()->set,B()->set,C()->set,P[set,set,set]}:
 ex f,g being Function st dom f = A() & dom g = A() &
  for x st x in A() holds P[x,f.x,g.x]
provided
 x in A() implies ex y,z st y in B() & z in C() & P[x,y,z]
proof
    defpred H[set,set] means
      for y,z st $2`1 = y & $2`2 = z holds P[$1,y,z];
A2:  x in A() implies ex p being set st p in [:B(),C():] & H[x,p]
      proof
       assume x in A();
       then consider y,z such that A3: y in B() & z in C() & P[x,y,z] by A1;
       take p=[y,z];
       thus p in [:B(),C():] by A3,ZFMISC_1:106;
       thus for y,z st p`1 = y & p`2 = z holds P[x,y,z]
        proof
         let x1,x2 be set; assume p`1 = x1 & p`2 = x2;
         then x1=y & x2=z by MCART_1:7;
         hence thesis by A3;
        end;
      end;
    consider h being Function such that
      dom h = A() & rng h c= [:B(),C():] and
     A4: for x st x in A() holds H[x,h.x] from NonUniqBoundFuncEx(A2);
     deffunc f(set) = (h.$1)`1;
     consider f being Function such that A5: dom f = A() and
     A6: for x st x in A() holds f.x = f(x) from FUNCT_1:sch 3;
     deffunc g(set) = (h.$1)`2;
     consider g being Function such that A7: dom g = A() and
     A8: for x st x in A() holds g.x = g(x) from FUNCT_1:sch 3;
     take f,g;
     thus dom f = A() & dom g = A() by A5,A7;
     thus for x st x in A() holds P[x,f.x,g.x]
      proof
       let x; assume A9: x in A();
       then f.x = (h.x)`1 & g.x = (h.x)`2 by A6,A8;
       hence thesis by A4,A9;
      end;
   end;

theorem :: COMPTS_1:1
  Z is finite & Z c= rng f implies
  ex Y st Y c= dom f & Y is finite & f.:Y = Z;

reserve T for TopStruct;
reserve A for SubSpace of T;
reserve P, Q for Subset of T;

definition let T be 1-sorted, F be Subset-Family of T,
   P be Subset of T;
 pred F is_a_cover_of P means
:: COMPTS_1:def 1
     P c= union F;
end;


definition let F be set;
  attr F is centered means
:: COMPTS_1:def 2
    F <> {} &
  for G being set st G <> {} & G c= F & G is finite holds meet G <> {};
end;


definition let T be TopStruct;
  attr T is compact means
:: COMPTS_1:def 3
   for F being Subset-Family of T st
     F is_a_cover_of T & F is open
      ex G being Subset-Family of T
       st G c= F & G is_a_cover_of T & G is finite;

  attr T is being_T2 means
:: COMPTS_1:def 4
     for p, q being Point of T st not p = q
      ex W, V being Subset of T st W is open & V is open &
       p in W & q in V & W misses V;
  attr T is being_T3 means
:: COMPTS_1:def 5
       for p being Point of T, P being Subset of T
      st P <> {} & P is closed & not p in P
      ex W, V being Subset of T st W is open & V is open &
       p in W & P c= V & W misses V;
  attr T is being_T4 means
:: COMPTS_1:def 6
      for W, V being Subset of T st W <> {} & V <> {} &
      W is closed & V is closed & W misses V
     ex P, Q being Subset of T st P is open & Q is open &
         W c= P & V c= Q & P misses Q;
  end;
notation let T be TopStruct;
  synonym T is_T2 for T is being_T2 ; synonym T is_T3 for T is being_T3 ;
synonym T is_T4 for T is being_T4 ; end;


definition let T be TopStruct, P be Subset of T;
  attr P is compact means
:: COMPTS_1:def 7
   for F being Subset-Family of T st
    F is_a_cover_of P & F is open
    ex G being Subset-Family of T st G c= F & G is_a_cover_of P & G is finite;
end;


canceled 7;

theorem :: COMPTS_1:9
{}T is compact;

theorem :: COMPTS_1:10
T is compact iff [#]T is compact;

theorem :: COMPTS_1:11
 Q c= [#] A implies
  (Q is compact iff
   (for P being Subset of A st P=Q holds P is compact));

theorem :: COMPTS_1:12
 ( P = {} implies (P is compact iff T|P is compact) ) &
 ( T is TopSpace-like & P <> {} implies (P is compact iff T|P is compact) );

theorem :: COMPTS_1:13
for T being non empty TopSpace holds
 T is compact iff
  for F being Subset-Family of T st F is centered & F is closed
   holds meet F <> {};

theorem :: COMPTS_1:14
  for T being non empty TopSpace holds
  T is compact iff for F being Subset-Family of T st F <> {} & F is closed &
   meet F = {}
 ex G being Subset-Family of T st G <> {} & G c= F & G is finite & meet G = {};

reserve TS for TopSpace;
reserve PS, QS for Subset of TS;

theorem :: COMPTS_1:15
 TS is_T2 implies
  for A being Subset of TS st A <> {} & A is compact
   for p being Point of TS st not p in A
 ex PS,QS st PS is open & QS is open & p in PS & A c= QS & PS misses QS;

theorem :: COMPTS_1:16
  TS is_T2 & PS is compact implies PS is closed;

theorem :: COMPTS_1:17
 T is compact & P is closed implies P is compact;

theorem :: COMPTS_1:18
 PS is compact & QS c= PS & QS is closed implies QS is compact;

theorem :: COMPTS_1:19
   P is compact & Q is compact implies P \/ Q is compact;

theorem :: COMPTS_1:20
   TS is_T2 & PS is compact & QS is compact implies PS /\ QS is compact;

theorem :: COMPTS_1:21
   TS is_T2 & TS is compact implies TS is_T3;

theorem :: COMPTS_1:22
   TS is_T2 & TS is compact implies TS is_T4;

reserve S for non empty TopStruct;
reserve f for map of T,S;

theorem :: COMPTS_1:23
   T is compact & f is continuous & rng f = [#] S implies S is compact;

theorem :: COMPTS_1:24
 f is continuous & rng f = [#] S & P is compact implies f.:P is compact;

reserve SS for non empty TopSpace;
reserve f for map of TS,SS;

theorem :: COMPTS_1:25
 TS is compact & SS is_T2 & rng f = [#] SS & f is continuous implies
  for PS st PS is closed holds f.:PS is closed;

theorem :: COMPTS_1:26
   TS is compact & SS is_T2 & dom f = [#]TS & rng f = [#]SS & f is one-to-one &
  f is continuous implies f is_homeomorphism;
