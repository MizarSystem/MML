:: On Paracompactness of Metrizable Spaces
::  by Leszek Borys
::
:: Received July 23, 1992
:: Copyright (c) 1992 Association of Mizar Users

environ

 vocabulary ARYTM, FUNCT_1, ARYTM_3, RELAT_1, WELLORD1, RELAT_2, BOOLE, TARSKI,
      FINSEQ_1, PRE_TOPC, METRIC_1, SETFAM_1, COMPTS_1, SUBSET_1, ARYTM_1,
      PCOMPS_1, FINSET_1, PCOMPS_2, GROUP_1, FINSEQ_4;
 notation TARSKI, XBOOLE_0, ZFMISC_1, SUBSET_1, ORDINAL1, NUMBERS, XCMPLX_0,
      XREAL_0, REAL_1, TOPS_2, FUNCT_1, FUNCT_2, NAT_1, SETFAM_1, STRUCT_0,
      NEWTON, METRIC_1, COMPTS_1, PRE_TOPC, PCOMPS_1, PREPOWER, WELLORD1,
      RELAT_1, FINSEQ_1, FINSET_1, RELAT_2, FINSEQ_2, FINSEQ_4;
 constructors TOPS_2, NAT_1, COMPTS_1, PCOMPS_1, REAL_1, PREPOWER, WELLORD1,
      WELLORD2, RELAT_2, FINSEQ_4, MEMBERED;
 clusters SUBSET_1, PRE_TOPC, FINSET_1, RELSET_1, STRUCT_0, XREAL_0, FINSEQ_1,
      METRIC_1, NEWTON, MEMBERED, ZFMISC_1, ORDINAL2;
 requirements REAL, NUMERALS, BOOLE, SUBSET, ARITHM;


begin :: 1. Selected properties of real numbers

  reserve r,u for real number;
  reserve n,k,i for Nat;

canceled 2;

  theorem :: PCOMPS_2:3
   r>0 & u > 0 implies ex k be Nat st u/(2 |^ k) <= r;

theorem :: PCOMPS_2:4
    k>=n & r >= 1 implies r |^ k >= r |^ n;

begin :: 2. Certain functions defined on families of sets

  reserve R for Relation;
  reserve A for set;

theorem :: PCOMPS_2:5
   R well_orders A implies R |_2 A well_orders A & A = field (R |_2 A);

scheme :: PCOMPS_2:sch 1
 MinSet{A()->set,R()->Relation,P[set]}:
  ex X be set st X in A() & P[X] &
    for Y be set st Y in A() & P[Y] holds [X,Y] in R()
  provided
    R() well_orders A() and
    ex X be set st X in A() & P[X]
proof
     defpred Q[set] means P[$1];
     consider Y be set such that
       A3: for x be set holds x in Y iff x in A() & Q[x] from XBOOLE_0:sch 1;
A4:     ex x be set st x in Y
       proof
         consider x be set such that A5: x in A() & P[x] by A2;
         take x;
         thus x in Y by A3,A5;
       end;
       for x be set holds x in Y implies x in A() by A3;
     then Y c= A() by TARSKI:def 3;
     then consider X be set such that A6: X in Y and
       A7: for Z be set st Z in Y holds [X,Z] in R() by A1,A4,WELLORD1:9;
     A8: X in A() by A3,A6;
     A9: P[X] by A3,A6;
       for M be set st M in A() & P[M] holds [X,M] in R()
       proof
         let M be set;
         assume M in A() & P[M];
         then M in Y by A3;
         hence thesis by A7;
       end;
     hence thesis by A8,A9;
   end;

definition let FX be set, R be Relation,
               B be Element of FX;
  func PartUnion(B,R) equals
:: PCOMPS_2:def 1
   union (R-Seg(B));
end;


definition let FX be set, R be Relation;
  func DisjointFam(FX,R) means
:: PCOMPS_2:def 2
    A in it iff ex B be Element of FX st B in FX & A = B\PartUnion(B,R);
end;


definition let X be set, n be Nat, f be Function of NAT,bool X;
  func PartUnionNat(n,f) equals
:: PCOMPS_2:def 3
      union (f.:(Seg(n)\{n}));
  end;


begin :: 3. Paracompactness of metrizable spaces

  reserve PT for non empty TopSpace;
  reserve PM for MetrSpace;
  reserve FX,GX,HX for Subset-Family of PT;
  reserve Y,V,W for Subset of PT;

theorem :: PCOMPS_2:6
  PT is_T3 implies
       for FX st FX is_a_cover_of PT & FX is open
         ex HX st HX is open & HX is_a_cover_of PT &
           for V st V in HX ex W st W in FX & Cl V c= W;

theorem :: PCOMPS_2:7
    for PT,FX st PT is_T2 & PT is paracompact &
             FX is_a_cover_of PT & FX is open
         ex GX st GX is open & GX is_a_cover_of PT &
           clf GX is_finer_than FX & GX is locally_finite;

theorem :: PCOMPS_2:8
  for f being Function of
      [:the carrier of PT,the carrier of PT:],REAL st
      f is_metric_of ( the carrier of PT) holds
      PM = SpaceMetr(the carrier of PT,f) implies
      the carrier of PM = the carrier of PT;

canceled 2;

theorem :: PCOMPS_2:11
    for f being Function of
      [:the carrier of PT,the carrier of PT:],REAL st
      f is_metric_of ( the carrier of PT) holds
      PM = SpaceMetr(the carrier of PT,f) implies
        (FX is Subset-Family of PT iff
        FX is Subset-Family of PM);

  reserve Mn for Relation;
  reserve n,k,l,q,p,q1 for Nat;

definition let PM be non empty set;
           let g be Function of NAT,(bool bool PM)*;
           let n;
     redefine func g.n -> FinSequence of bool bool PM;
     end;


scheme :: PCOMPS_2:sch 2
 XXX1 { PM() -> non empty set, UB() -> Element of bool bool PM(),
            F(set,set) -> Subset of PM(),
            P[set],
            Q[set,set,set,set]} :
ex f being Function of NAT, bool bool PM() st
  f.0 = UB() &
  for n holds f.(n+1) =
  {union { F(c,n) where c is Element of PM():
              for fq be Element of bool bool PM(),q
              st q <= n & fq = f.q holds Q[c,V,n,fq]
              }
      where V is Element of bool PM() : P[V]}
proof
    defpred T[Nat,FinSequence of bool bool PM(),set] means
     $3 = $2^<*{union { F(c,$1) where c is Element of PM():
      for fq be Element of bool bool PM(),q st q <= $1 & fq = $2/.(q+1) holds
       Q[c,V,$1,fq] } where V is Element of bool PM() : P[V]}*>;
    A1: for n being Element of NAT for x being Element of (bool bool PM())*
     ex y being Element of (bool bool PM())* st T[n,x,y]
        proof
          let n;
          let x be Element of (bool bool PM())*;
          set T = {
            union { F(c,n) where c is Element of PM():
                    for fq be Element of bool bool PM(),q
                    st q <= n & fq = x/.(q+1) holds Q[c,V,n,fq]}
            where V is Element of bool PM() : P[V]};
            T in bool bool PM()
            proof
                now
                let X be set; assume X in T;
                then consider V be Element of bool PM() such that
                 A2:  X=union { F(c,n) where c is Element of PM():
                    for fq be Element of bool bool PM(),q
                    st q <= n & fq = x/.(q+1) holds Q[c,V,n,fq]
                    } and P[V];
                  now let a be set; assume a in X;
                  then consider P be set such that A3: a in P and
                  A4: P in { F(c,n) where c is Element of PM():
                    for fq be Element of bool bool PM(),q
                    st q <= n & fq = x/.(q+1) holds Q[c,V,n,fq]}
                      by A2,TARSKI:def 4;
                  consider c be Element of PM() such that
                    A5: P = F(c,n) and
                      for fq be Element of bool bool PM(),q
                    st q <= n & fq = x/.(q+1) holds Q[c,V,n,fq] by A4;
                  thus a in PM() by A3,A5;
                end;
                then X c= PM() by TARSKI:def 3;
                hence X in bool PM();
              end;
              then T c= bool PM() by TARSKI:def 3;
              hence thesis;
            end;
          then reconsider T as Element of bool bool PM();
          reconsider T1 = <*T*> as FinSequence of bool bool PM();
          consider y be FinSequence of bool bool PM() such that
            A6: y = x^T1;
          reconsider y as Element of (bool bool PM())* by FINSEQ_1:def 11;
          take y;
          thus thesis by A6;
        end;
      reconsider A = <*UB()*> as Element of (bool bool PM())*
        by FINSEQ_1:def 11;
    consider g be Function of NAT,(bool bool PM())* such that
      A7: g.0=A and
      A8: for n be Element of NAT holds T[n,g.n,g.(n+1)] from RECDEF_1:sch 2
(A1);
      deffunc G(Nat) = (g.$1)/.len(g.$1);
      consider f be Function of NAT,bool bool PM() such that
       A9: for n holds f.n=G(n) from FUNCT_2:sch 4;
      take f;
        len <*UB()*> = 1 by FINSEQ_1:56;
      hence f.0 = <*UB()*>/.1 by A7,A9 .= UB() by FINSEQ_4:25;
      defpred R[Nat] means len(g.$1) = $1 + 1;
      A10: R[0] by A7,FINSEQ_1:56;
      A11: for k st R[k] holds R[k+1]
        proof
          let k such that A12: len(g.k) = k+1;
            len(g.(k+1))=len((g.k)^<*{
            union { F(c,k) where c is Element of PM():
                    for fq be Element of bool bool PM(),q
                    st q <= k & fq = (g.k)/.(q+1) holds Q[c,V,k,fq]
                    }
            where V is Element of bool PM() : P[V]}*>) by A8
          .= len(g.k)+1 by FINSEQ_2:19;
          hence thesis by A12;
        end;
      A13: for n holds R[n] from NAT_1:sch 1(A10,A11);
      defpred T[Nat] means for q st q <= $1 holds f.q = (g.$1)/.(q+1);
      A14: T[0]
        proof
          let q;
          assume q <= 0;
          then A15: q = 0 by NAT_1:18;
         thus f.q = (g.q)/.len(g.q) by A9 .= (g.0)/.(q+1)
           by A7,A15,FINSEQ_1:56;
        end;
      A16: for k st T[k] holds T[k+1]
          proof
            let k;
            assume A17: for q st q <= k holds f.q = (g.k)/.(q+1);
            let q;
            assume A18: q <= k+1;
              now per cases by A18,REAL_1:def 5;
            suppose A19: q = k+1;
            thus f.q=(g.q)/.len(g.q) by A9 .= (g.(k+1))/.(q+1) by A13,A19;
            end;
            suppose A20: q < k+1; then A21: q+1 <= k+1 by NAT_1:38;
            A22: q <= k by A20,NAT_1:38; q+1>=1 by NAT_1:29;
            then A23: q+1 in Seg(k+1) by A21,FINSEQ_1:3;
            k+1+1>=k+1 by NAT_1:29; then Seg(k+1) c= Seg(k+1+1) by FINSEQ_1:7;
            then q+1 in Seg(k+1+1) by A23;
        then q+1 in Seg(len(g.(k+1))) by A13;
then A24:          q+1 in dom(g.(k+1)) by FINSEQ_1:def 3;
           q+1 in Seg len(g.k) by A13,A23;
then A25:          q+1 in dom (g.k) by FINSEQ_1:def 3;
            thus (g.(k+1))/.(q+1) = (g.(k+1)).(q+1) by A24,FINSEQ_4:def 4
              .= ((g.k)^<*{ union { F(c,k) where c is Element of PM():
                    for fq be Element of bool bool PM(),q
                    st q <= k & fq = (g.k)/.(q+1) holds Q[c,V,k,fq]}
            where V is Element of bool PM()
            : P[V]}*>).(q+1) by A8 .= (g.k).(q+1) by A25,FINSEQ_1:def 7
            .= (g.k)/.(q+1) by A25,FINSEQ_4:def 4 .= f.q by A17,A22;
            end;
            end;
            hence thesis;
          end;
      A26: for n holds T[n] from NAT_1:sch 1(A14,A16);
      let n;
      defpred P2[set] means P[$1];
      deffunc F2(set) = union { F(c,n) where c is Element of PM():
       for fq be Element of bool bool PM(),q st q <= n & fq = f.q holds
        Q[c,$1,n,fq]};
      deffunc G2(set) = union { F(c,n) where c is Element of PM():
       for fq be Element of bool bool PM(),q st q <= n &
        fq = (g.n)/.(q+1) holds Q[c,$1,n,fq]};
      set NF = { F2(V) where V is Element of bool PM(): P2[V] };
      A27: for V be Element of bool PM() st P2[V] holds F2(V) = G2(V)
          proof
            let V be Element of bool PM() such that P[V];
            deffunc F1(set) = F($1,n);
            defpred P1[set] means for fq be Element of bool bool PM(),q st
             q <= n & fq = f.q holds Q[$1,V,n,fq];
            defpred P2[set] means for fq be Element of bool bool PM(),q st
             q <= n & fq = (g.n)/.(q+1) holds Q[$1,V,n,fq];
                A28:for c be Element of PM() holds P1[c] iff P2[c]
                  proof
                  let c be Element of PM();
                  thus (for fq be Element of bool bool PM(),q
                  st q <= n & fq = f.q holds Q[c,V,n,fq]) implies
                  for fq be Element of bool bool PM(),q
                  st q <= n & fq = (g.n)/.(q+1) holds Q[c,V,n,fq]
                    proof
                      assume A29: for fq be Element of bool bool PM(),q
                      st q <= n & fq = f.q holds Q[c,V,n,fq];
                      let fq be Element of bool bool PM(),q;
                      assume A30: q <= n & fq = (g.n)/.(q+1);
                      then fq = f.q by A26;
                      hence thesis by A29,A30;
                    end;
                  assume A31: for fq be Element of bool bool PM(),q
                  st q <= n & fq = (g.n)/.(q+1) holds Q[c,V,n,fq];
                  let fq be Element of bool bool PM(),q; assume
                    A32: q <= n & fq = f.q;
                  then f.q = (g.n)/.(q+1) by A26;
                  hence Q[c,V,n,fq] by A31,A32;
                  end;
            { F1(c) where c is Element of PM(): P1[c] } =
            { F1(c) where c is Element of PM(): P2[c] } from FRAENKEL:sch 3
(A28);
            hence thesis;
          end;
      A33: NF = { G2(V) where V is Element of bool PM() : P2[V] }
       from FRAENKEL:sch 6(A27);
      then A34: len(g.(n+1))=len((g.n)^<*NF*>) by A8
      .= len(g.n)+1 by FINSEQ_2:19;
      A35: len(g.n)+1 in dom (g.(n+1))
        proof
            len(g.(n+1))= n+1+1 by A13;
          then A36: dom(g.(n+1)) = Seg(n+1+1) by FINSEQ_1:def 3;
            len(g.n)+1=n+1+1 by A13;
          hence thesis by A36,FINSEQ_1:6;
        end;
      thus f.(n+1) = (g.(n+1))/.(len(g.n)+1) by A9,A34
      .= g.(n+1).(len(g.n)+1) by A35,FINSEQ_4:def 4
      .= ((g.n)^<*NF*>).(len(g.n)+1) by A8,A33
      .= NF by FINSEQ_1:59;
  end;

scheme :: PCOMPS_2:sch 3
 XXX { PM() -> non empty set, UB() -> Element of bool bool PM(),
            F(set,set) -> Subset of PM(),
            P[set],
            Q[set,set,set]} :
ex f being Function of NAT, bool bool PM() st
  f.0 = UB() &
  for n holds f.(n+1) =
  { union { F(c,n) where c is Element of PM():
              Q[c,V,n] &
              not c in union{union(f.q): q <= n }
              }
      where V is Element of bool PM()
      : P[V]}
proof
    defpred P1[set] means P[$1];
    defpred Q1[set,set,set,set] means Q[$1,$2,$3] & not $1 in union $4;
    deffunc F1(set,set) = F($1,$2);
    consider f being Function of NAT, bool bool PM() such that
      A1: f.0 = UB() and
      A2: for n holds f.(n+1) =
      { union { F1(c,n) where c is Element of PM():
                  for fq be Element of bool bool PM(),q
                  st q <= n & fq = f.q holds Q1[c,V,n,fq] }
        where V is Element of bool PM() : P1[V]} from XXX1;
    take f;
    thus f.0 = UB() by A1;
    let n;
    defpred P2[set] means P[$1];
    deffunc F2(set) = union { F(c,n) where c is Element of PM():
     for fq be Element of bool bool PM(),q st q <= n & fq = f.q holds
      Q[c,$1,n] & not c in union(fq) };
    deffunc G2(set) = union { F(c,n) where c is Element of PM(): Q[c,$1,n] &
     not c in union{union(f.q): q <= n } };
    set fxxx1 = { F2(V) where V is Element of bool PM() : P2[V] };
    set fxxx = { G2(V) where V is Element of bool PM() : P2[V] };
    A3:now
        let V be Element of bool PM();
        assume P2[V];
        deffunc F1(set) = F($1,n);
        defpred P1[set] means for fq be Element of bool bool PM(),q
         st q <= n & fq = f.q holds Q[$1,V,n] & not $1 in union(fq);
        defpred Q1[set] means Q[$1,V,n] & not $1 in union{union(f.q1):
         q1 <= n };
          A4:now
              let c be Element of PM();
                A5: ( for fq be Element of bool bool PM(),q
                st q <= n & fq = f.q holds not c in union(fq))
                iff not c in union{union(f.q): q <= n }
                proof
                thus (for fq be Element of bool bool PM(),q
                st q <= n & fq = f.q holds not c in union(fq))
                implies not c in union{union(f.q): q <= n }
                  proof
                    assume A6: for fq be Element of bool bool PM(),q
                      st q <= n & fq = f.q holds not c in union(fq);
                    assume c in union{union(f.q): q <= n};
                    then consider C be set such that
                      A7: c in C and A8: C in {union(f.q): q <=
 n}by TARSKI:def 4;
                    consider q be Nat such that
                      A9: C = union(f.q) and A10: q <= n by A8;
                    thus contradiction by A6,A7,A9,A10;
                  end;
                assume A11: not c in union{union(f.q): q <= n };
                let fq be Element of bool bool PM(),q;
                assume that A12: q <= n and A13: fq = f.q;
                assume A14: c in union(fq);
                  union(fq) in {union(f.p): p <= n} by A12,A13;
                hence contradiction by A11,A14,TARSKI:def 4;
                end;
              thus P1[c] iff Q1[c]
                proof
                  hereby assume A15:( for fq be Element of bool bool PM(),q
                    st q <= n & fq = f.q holds Q[c,V,n] & not c in union(fq));
                    consider q such that A16: q <= n;
                    consider fq be Element of bool bool PM() such that
                      A17: fq = f.q;
                    thus Q[c,V,n] by A15,A16,A17;
                    thus not c in union{union(f.p): p <= n } by A5,A15;
                  end;
                  assume Q[c,V,n] & not c in union{union(f.q): q <= n };
                  hence thesis by A5;
                end;
            end;
        { F1(c) where c is Element of PM(): P1[c] }
         = { F1(c) where c is Element of PM(): Q1[c] } from FRAENKEL:sch 3(A4);
        hence F2(V) = G2(V);
      end;
      fxxx1 = fxxx from FRAENKEL:sch 6(A3);
    hence thesis by A2;
  end;

theorem :: PCOMPS_2:12  :: Stone Theorem - general case
   PT is metrizable implies
     for FX being Subset-Family of PT
        st FX is_a_cover_of PT & FX is open
      ex GX being Subset-Family of PT
         st GX is open & GX is_a_cover_of PT &
               GX is_finer_than FX & GX is locally_finite;

theorem :: PCOMPS_2:13  :: Stone Theorem
    PT is metrizable implies PT is paracompact;
