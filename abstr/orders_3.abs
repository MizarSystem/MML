:: On the Category of Posets
::  by Adam Grabowski
::
:: Received January 22, 1996
:: Copyright (c) 1996 Association of Mizar Users

environ

 vocabulary ORDERS_1, NATTRA_1, RELAT_1, RELAT_2, BOOLE, WELLORD1, SUBSET_1,
      PRE_TOPC, SEQM_3, FUNCT_1, FUNCT_2, UNIALG_3, FRAENKEL, CAT_5, CAT_1,
      ALTCAT_1, PBOOLE, PRALG_1, BINOP_1, ORDERS_3;
 notation TARSKI, XBOOLE_0, ZFMISC_1, SUBSET_1, RELAT_1, RELAT_2, FUNCT_1,
      CAT_5, STRUCT_0, MCART_1, WELLORD1, PARTFUN1, BINOP_1, MULTOP_1,
      RELSET_1, PRE_TOPC, ORDERS_1, CAT_1, ENS_1, FRAENKEL, PBOOLE, GRCAT_1,
      FUNCT_2, PRALG_1, ALTCAT_1;
 constructors RELAT_2, ORDERS_1, WELLORD1, ALTCAT_1, ENS_1, CAT_5, DOMAIN_1,
      TOPS_2, GRCAT_1;
 clusters SUBSET_1, RELSET_1, ORDERS_1, STRUCT_0, FUNCT_1, FRAENKEL, CAT_5,
      ALTCAT_1, ENS_1, PARTFUN1, XBOOLE_0;
 requirements BOOLE, SUBSET;


begin :: Preliminaries

definition let IT be RelStr;
  attr IT is discrete means
:: ORDERS_3:def 1
  the InternalRel of IT = id (the carrier of IT);
end;


registration
  cluster strict discrete non empty Poset;
 existence
 proof
   consider A be non empty set;
   reconsider R = id A as Relation of A;
   reconsider R as Order of A;
   take RelStr(#A,R#);
   thus thesis by Def1;
 end;

  cluster strict discrete empty Poset;
  existence
  proof
    consider A be empty set;
    reconsider R = id A as Relation of A;
   reconsider R as Order of A;
   take RelStr(#A,R#);
   thus thesis by Def1,STRUCT_0:def 1;
  end;
end;

registration
  cluster RelStr (#{},id {}#) -> empty;
  coherence by STRUCT_0:def 1;

  let P be empty RelStr;
  cluster the InternalRel of P -> empty;
  coherence by Lm1;
end;

registration
  cluster empty -> discrete RelStr;
  coherence by Lm2;
end;


definition let P be RelStr;
  let IT be Subset of P;
  attr IT is disconnected means
:: ORDERS_3:def 2
   ex A,B be Subset of P st A <> {} & B <> {}
  & IT = A \/ B & A misses B &
    the InternalRel of P =
     (the InternalRel of P) |_2 A \/ (the InternalRel of P) |_2 B;
  end;
notation let P be RelStr;
  let IT be Subset of P;
  antonym IT is connected for IT is disconnected ; end;


definition let IT be RelStr;
  attr IT is disconnected means
:: ORDERS_3:def 3
   [#] IT is disconnected;
  end;
notation let IT be RelStr;
  antonym IT is connected for IT is disconnected ; end;


reserve T for non empty RelStr,
        a for Element of T;

theorem :: ORDERS_3:1
    for DP be discrete non empty RelStr, x,y be Element of DP holds
   x <= y iff x = y;

theorem :: ORDERS_3:2
    for R be Relation, a be set st R is Order of {a} holds R = id {a};

theorem :: ORDERS_3:3
    T is reflexive & [#] T = {a} implies T is discrete;

 reserve a for set;

theorem :: ORDERS_3:4
  [#] T = {a} implies T is connected;

theorem :: ORDERS_3:5
  for DP be discrete non empty Poset st
   (ex a,b be Element of DP st a <> b) holds DP is disconnected;

registration
  cluster strict connected (non empty Poset);
  existence
  proof
    consider x be set;
    reconsider A = RelStr (#{x},id {x}#) as non empty Poset;
      [#] A = {x} by PRE_TOPC:12;
    then A is connected by Th4;
    hence thesis;
  end;

  cluster strict disconnected discrete (non empty Poset);
  existence
  proof
     ex Y be non empty Poset st Y is strict & Y is disconnected & Y is discrete
   proof
    reconsider A = RelStr (#{1,2},id {1,2}#) as non empty Poset;
    reconsider A as discrete (non empty Poset) by Def1;
    take A;
      ex a,b be Element of A st a <> b
    proof
     set a = 1 , b = 2;
       a is Element of A &
     b is Element of A by TARSKI:def 2;
     then reconsider a, b as Element of A;
     take a, b;
     thus thesis;
    end;
    hence thesis by Th5;
   end;
   hence thesis;
  end;
end;


begin  :: Category of Posets

definition let IT be set;
  attr IT is POSet_set-like means
:: ORDERS_3:def 4
   for a be set st a in IT holds a is non empty Poset;
end;


registration
  cluster non empty POSet_set-like set;
  existence
  proof
    consider P be non empty Poset;
    set A = {P};
A1:  for a be set st a in A holds a is non empty Poset by TARSKI:def 1;
    take A;
    thus thesis by A1,Def4;
  end;
end;


definition
  mode POSet_set is POSet_set-like set;
end;


definition let P be non empty POSet_set;
  redefine mode Element of P -> non empty Poset;
end;


definition
 let L1,L2 be RelStr;
 let f be map of L1, L2;
 attr f is monotone means
:: ORDERS_3:def 5
  for x,y being Element of L1 st x <= y
   for a,b being Element of L2 st a = f.x & b = f.y holds a <= b;
end;

 reserve P for non empty POSet_set, A,B for Element of P;

definition let A,B be RelStr;
 func MonFuncs (A,B) means
:: ORDERS_3:def 6
   a in it iff ex f be map of A, B st a = f &
    f in Funcs (the carrier of A, the carrier of B) & f is monotone;
end;


theorem :: ORDERS_3:6
for A,B,C be non empty RelStr
 for f,g be Function st f in MonFuncs (A,B) & g in MonFuncs (B,C) holds
  (g*f) in MonFuncs (A,C);

theorem :: ORDERS_3:7
  id the carrier of T in MonFuncs (T,T);

registration let T;
  cluster MonFuncs (T,T) -> non empty;
  coherence by Th7;
end;


definition let X be set;
  func Carr X -> set means
:: ORDERS_3:def 7
    a in it iff ex s be 1-sorted st s in X & a = the carrier of s;
end;

registration let P;
  cluster Carr P -> non empty;
  coherence by Lm5;
end;


theorem :: ORDERS_3:8
    for f be 1-sorted holds Carr {f} = {the carrier of f};

theorem :: ORDERS_3:9
    for f,g be 1-sorted holds Carr {f,g} = {the carrier of f, the carrier of g}
;

theorem :: ORDERS_3:10
  MonFuncs (A,B) c= Funcs Carr P;

theorem :: ORDERS_3:11
  for A,B be RelStr holds
   MonFuncs (A,B) c= Funcs (the carrier of A,the carrier of B);

registration let A,B be non empty Poset;
  cluster MonFuncs (A,B) -> functional;
  coherence
  proof
    reconsider X = MonFuncs (A,B) as Subset of
           Funcs (the carrier of A,the carrier of B) by Th11;
      X is functional;
    hence thesis;
  end;
end;


definition let P be non empty POSet_set;
  func POSCat P -> strict with_triple-like_morphisms Category means
:: ORDERS_3:def 8
    the Objects of it = P &
  (for a,b be Element of P, f be Element of Funcs Carr P st
    f in MonFuncs (a,b) holds [[a,b],f] is Morphism of it) &
  (for m be Morphism of it
    ex a,b be Element of P, f be Element of Funcs (Carr P) st
     m = [[a,b],f] & f in MonFuncs (a,b)) &
   for m1,m2 be (Morphism of it), a1,a2,a3 be Element of P,
   f1,f2 be Element of Funcs (Carr P) st
   m1 = [[a1,a2],f1] & m2 = [[a2,a3],f2]
    holds m2*m1 = [[a1,a3], f2*f1];
end;


begin   :: Alternative Category of Posets

scheme :: ORDERS_3:sch 1
 AltCatEx
 {A() -> non empty set, F(set,set) -> functional set }:
  ex C be strict AltCatStr st
   the carrier of C = A() &
   for i,j be Element of A() holds (the Arrows of C).(i,j) = F (i,j) &
   for i,j,k be Element of A() holds
    (the Comp of C).(i,j,k) = FuncComp ( F(i,j) , F(j,k) )
   provided
 for i,j,k be Element of A() for f,g be Function st
     f in F(i,j) & g in F(j,k) holds g * f in F (i,k)
proof
    deffunc G(set,set) = F($1,$2);
    consider M be ManySortedSet of [:A(),A():] such that
A2:   for i,j be Element of A() holds M.(i,j) = G(i,j) from ALTCAT_1:sch 2;
    deffunc H(set,set,set) = FuncComp(G($1,$2),G($2,$3));
    consider c be ManySortedSet of [:A(),A(),A():] such that
A3:   for i,j,k be Element of A() holds
      c.(i,j,k) = H(i,j,k) from ALTCAT_1:sch 4;
      c is Function-yielding
    proof let i be set;
     assume i in dom c;
     then i in [:A(),A(),A():] by PBOOLE:def 3;
     then consider x1,x2,x3 be set such that
A4:   x1 in A() & x2 in A() & x3 in A() and
A5:   i = [x1,x2,x3] by MCART_1:72;
       c.i = c.(x1,x2,x3) by A5,MULTOP_1:def 1
        .= FuncComp(F(x1,x2),F(x2,x3)) by A3,A4;
     hence c.i is Function;
    end;
    then reconsider c as ManySortedFunction of [:A(),A(),A():];
      now let i be set;
     assume i in [:A(),A(),A():];
     then consider x1,x2,x3 be set such that
A6:   x1 in A() & x2 in A() & x3 in A() and
A7:   i = [x1,x2,x3] by MCART_1:72;
A8:    M.(x1,x2) = F(x1,x2) by A2,A6;
A9:     c.i = c.(x1,x2,x3) by A7,MULTOP_1:def 1
         .= FuncComp(F(x1,x2),F(x2,x3)) by A3,A6;
      then reconsider ci = c.i as Function;
A10:   dom ci = [:F(x2,x3),F(x1,x2):] by A9,PBOOLE:def 3;
A11:   [:F(x2,x3),F(x1,x2):] = [:M.(x2,x3),M.(x1,x2):] by A2,A6,A8
         .= {|M,M|}.(x1,x2,x3) by A6,ALTCAT_1:def 6
         .= {|M,M|}.i by A7,MULTOP_1:def 1;
A12:   rng FuncComp(F(x1,x2),F(x2,x3)) c= F (x1,x3)
      proof let i be set;
       set F = FuncComp(F(x1,x2),F(x2,x3));
       assume i in rng F;
       then consider j be set such that
A13:     j in dom F and
A14:     i = F.j by FUNCT_1:def 5;
       consider f,g be Function such that
A15:      j = [g,f] and
A16:     F.j = g*f by A13,ALTCAT_1:def 11;
         dom F = [:F(x2,x3),F(x1,x2):] by PBOOLE:def 3;
       then g in F(x2,x3) & f in F(x1,x2) by A13,A15,ZFMISC_1:106;
       hence i in F(x1,x3) by A1,A6,A14,A16;
      end;
A17:    {|M|}.i = {|M|}.(x1,x2,x3) by A7,MULTOP_1:def 1
             .= M.(x1,x3) by A6,ALTCAT_1:def 5;
then A18:    rng ci c= {|M|}.i by A2,A6,A9,A12;
        now assume {|M,M|}.i <> {};
        then consider j be set such that
A19:      j in [:F(x2,x3),F(x1,x2):] by A11,XBOOLE_0:def 1;
        consider j1,j2 be set such that
A20:      j1 in F(x2,x3) and
A21:      j2 in F(x1,x2) and
           j = [j1,j2] by A19,ZFMISC_1:103;
        reconsider j1 as Function by A20,FRAENKEL:def 1;
        reconsider j2 as Function by A21,FRAENKEL:def 1;
          j1*j2 in F (x1,x3) by A1,A6,A20,A21;
       hence {|M|}.i <> {} by A2,A6,A17;
      end;
     hence c.i is Function of {|M,M|}.i, {|M|}.i by A10,A11,A18,FUNCT_2:def 1,
RELSET_1:11;
    end;
    then reconsider c as BinComp of M by MSUALG_1:def 2;
    set C = AltCatStr(#A(),M,c#);
    take C;
    thus the carrier of C = A();
    let i,j be Element of A();
    thus (the Arrows of C).(i,j) = F (i,j) by A2;
    let i,j,k be Element of A();
    thus (the Comp of C).(i,j,k) = FuncComp ( F(i,j) , F(j,k) ) by A3;
  end;

scheme :: ORDERS_3:sch 2
 AltCatUniq
   {A() -> non empty set, F(set,set) -> functional set } :
  for C1,C2 be strict AltCatStr st
  ( the carrier of C1 = A() &
   for i,j be Element of A() holds (the Arrows of C1).(i,j) = F (i,j) &
   for i,j,k be Element of A() holds
    (the Comp of C1).(i,j,k) = FuncComp ( F(i,j) , F(j,k) ) ) &
  ( the carrier of C2 = A() &
   for i,j be Element of A() holds (the Arrows of C2).(i,j) = F (i,j) &
   for i,j,k be Element of A() holds
    (the Comp of C2).(i,j,k) = FuncComp ( F(i,j) , F(j,k) ) )
    holds C1 = C2
proof
    let C1,C2 be strict AltCatStr; assume that
A1:   the carrier of C1 = A() &
   for i,j be Element of A() holds (the Arrows of C1).(i,j) = F (i,j) &
   for i,j,k be Element of A() holds
    (the Comp of C1).(i,j,k) = FuncComp ( F(i,j) , F(j,k) ) and
A2:   the carrier of C2 = A() &
   for i,j be Element of A() holds (the Arrows of C2).(i,j) = F (i,j) &
   for i,j,k be Element of A() holds
    (the Comp of C2).(i,j,k) = FuncComp ( F(i,j) , F(j,k) );
      now let i,j be Element of A();
        thus (the Arrows of C1).(i,j) = F (i,j) by A1
                                     .= (the Arrows of C2).(i,j) by A2;
    end;
then A3: the Arrows of C1 = the Arrows of C2 by A1,A2,ALTCAT_1:9;
      now let i,j,k be set; assume
A4:   i in A() & j in A() & k in A();
      hence (the Comp of C1).(i,j,k) = FuncComp ( F(i,j) , F(j,k) ) by A1
            .= (the Comp of C2).(i,j,k) by A2,A4;
    end;
    hence C1 = C2 by A1,A2,A3,ALTCAT_1:10;
  end;

definition let P be non empty POSet_set;
  func POSAltCat P -> strict AltCatStr means
:: ORDERS_3:def 9
   the carrier of it = P &
   for i,j be Element of P holds
    (the Arrows of it).(i,j) = MonFuncs (i,j) &
   for i,j,k be Element of P holds
    (the Comp of it).(i,j,k) = FuncComp ( MonFuncs (i,j) , MonFuncs (j,k) );
end;


registration let P be non empty POSet_set;
  cluster POSAltCat P -> transitive non empty;
  coherence
  proof
   set A = POSAltCat P;
   thus A is transitive
   proof
     let o1,o2,o3 be object of A;
     reconsider o1' = o1 ,o2' = o2 ,o3' = o3 as Element of P by Def9;
     assume <^o1,o2^> <> {} & <^o2,o3^> <> {};
     then (the Arrows of A).(o1,o2) <> {} & (the Arrows of A).(o2,o3) <> {}
                                              by ALTCAT_1:def 2;
  then A1: MonFuncs (o1',o2') <> {} & MonFuncs (o2',o3') <> {} by Def9;
     then consider f be set such that
  A2: f in MonFuncs (o1',o2') by XBOOLE_0:def 1;
     consider g be set such that
  A3:  g in MonFuncs (o2',o3') by A1,XBOOLE_0:def 1;
     consider g' be map of o2', o3'
       such that A4: g = g' &
        g' in Funcs (the carrier of o2',the carrier of o3') &
       g' is monotone by A3,Def6;
     consider f' be map of o1', o2'
       such that A5: f = f' &
        f' in Funcs (the carrier of o1',the carrier of o2') &
       f' is monotone by A2,Def6;
     reconsider f,g as Function by A4,A5;
       g * f in MonFuncs (o1',o3') by A2,A3,Th6;
     then (the Arrows of A).(o1,o3) <> {} by Def9;
     hence thesis by ALTCAT_1:def 2;
    end;
      the carrier of A is non empty by Def9;
    hence thesis by STRUCT_0:def 1;
  end;
end;


registration let P be non empty POSet_set;
  cluster POSAltCat P -> associative with_units;
  coherence
  proof
   set A = POSAltCat P;
   set G = the Arrows of A, C = the Comp of A;
   thus C is associative
   proof
     let i,j,k,l be Element of A;
     reconsider i'=i,j'=j,k'=k,l'=l as Element of P by Def9;
     let f,g,h be set; assume f in G.(i,j) & g in G.(j,k) & h in G.(k,l);
then A1:  f in MonFuncs (i',j') &
     g in MonFuncs (j',k') & h in MonFuncs (k',l') by Def9;
     then consider f' be map of i', j'
              such that
A2:     f = f' &
        f' in Funcs (the carrier of i',the carrier of j') &
f' is monotone by Def6;
     consider g' be map of j', k'
             such that
A3:     g = g' &
        g' in Funcs (the carrier of j',the carrier of k') &
g' is monotone by A1,Def6;
     consider h' be map of k', l'
             such that
A4:     h = h' &
        h' in Funcs (the carrier of k',the carrier of l') &
h' is monotone by A1,Def6;
     reconsider f' = f, g'=g ,h'=h as Function by A2,A3,A4;
A5: g' * f' in MonFuncs (i',k') by A1,Th6;
A6: h' * g' in MonFuncs (j',l') by A1,Th6;
A7:  C.(i,k,l) = FuncComp ( MonFuncs (i',k') , MonFuncs (k',l') ) by Def9;
A8:  C.(i,j,k) = FuncComp ( MonFuncs (i',j') , MonFuncs (j',k') ) by Def9;
A9:  C.(i,j,l) = FuncComp ( MonFuncs (i',j') , MonFuncs (j',l') ) by Def9;
A10:  C.(j,k,l) = FuncComp ( MonFuncs (j',k') , MonFuncs (k',l') ) by Def9;
A11:  C.(i,j,k).(g,f) = g' * f' by A1,A8,ALTCAT_1:13;
A12:   C.(i,k,l).(h,g'*f') = h' * ( g' *f') by A1,A5,A7,ALTCAT_1:13;
A13:  C.(j,k,l).(h,g) = h' * g' by A1,A10,ALTCAT_1:13;
       C.(i,j,l).((h' *g'),f') = (h' * g') * f'
          by A1,A6,A9,ALTCAT_1:13;
     hence thesis by A11,A12,A13,RELAT_1:55;
   end;
   thus C is with_left_units
   proof
     let j be Element of A;
     reconsider j' = j as Element of P by Def9;
     take e = id the carrier of j';
       G.(j,j) = MonFuncs (j',j') by Def9;
     hence e in G.(j,j) by Th7;
A14:     e in MonFuncs (j',j') by Th7;
     then consider e' be map of j', j'
              such that
A15:     e = e' &
        e' in Funcs (the carrier of j',the carrier of j') &
e' is monotone by Def6;
     let i be Element of A, f be set;
     reconsider i' = i as Element of P by Def9;
     assume f in G.(i,j);
then A16:  f in MonFuncs(i',j') by Def9;
     then consider f' be map of i', j'
              such that
A17:     f = f' &
        f' in Funcs (the carrier of i',the carrier of j') &
f' is monotone by Def6;
A18:   rng f' c= the carrier of j';
A19:  C.(i,j,j) = FuncComp ( MonFuncs (i',j') , MonFuncs (j',j') ) by Def9;
       e' * f' = f by A15,A17,A18,RELAT_1:79;
     hence C.(i,j,j).(e,f) = f by A14,A15,A16,A17,A19,ALTCAT_1:13;
   end;
   thus C is with_right_units
   proof
     let i be Element of A;
     reconsider i' = i as Element of P by Def9;
     take e = id the carrier of i';
       G.(i,i) = MonFuncs (i',i') by Def9;
     hence e in G.(i,i) by Th7;
A20:     e in MonFuncs (i',i') by Th7;
     then consider e' be map of i', i'
              such that
A21:     e = e' &
        e' in Funcs (the carrier of i',the carrier of i') &
e' is monotone by Def6;
     let j be Element of A, f be set;
     reconsider j' = j as Element of P by Def9;
     assume f in G.(i,j);
then A22:  f in MonFuncs(i',j') by Def9;
     then consider f' be map of i', j'
              such that
A23:     f = f' & f' in Funcs (the carrier of i',the carrier of j') &
      f' is monotone by Def6;
A24:   dom f' = the carrier of i' by FUNCT_2:def 1;
A25:  C.(i,i,j) = FuncComp ( MonFuncs (i',i') , MonFuncs (i',j') ) by Def9;
       f' * e' = f by A21,A23,A24,RELAT_1:78;
     hence C.(i,i,j).(f,e) = f by A20,A21,A22,A23,A25,ALTCAT_1:13;
   end;
  end;
end;


theorem :: ORDERS_3:12
   for o1,o2 be object of POSAltCat P, A,B be Element of P st o1 = A & o2 = B
  holds <^ o1 , o2 ^> c= Funcs (the carrier of A, the carrier of B);

