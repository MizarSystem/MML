:: Transpose Matrices and Groups of Permutations
::  by Katarzyna Jankowska
::
:: Received May 20, 1992
:: Copyright (c) 1992 Association of Mizar Users

environ

 vocabulary VECTSP_1, FINSEQ_1, RELAT_1, FUNCT_1, FUNCOP_1, MATRIX_1, FINSEQ_2,
      TREES_1, RLVECT_1, BOOLE, CARD_1, INCSP_1, QC_LANG1, FUNCT_2, BINOP_1,
      GROUP_1, NAT_1, ARYTM_1, FINSET_1, FINSUB_1, MATRIX_2, CARD_3;
 notation TARSKI, XBOOLE_0, ZFMISC_1, SUBSET_1, XREAL_0, RELAT_1, FUNCT_1,
      PARTFUN1, FUNCT_2, STRUCT_0, NAT_1, GROUP_1, GROUP_4, BINOP_1, RLVECT_1,
      VECTSP_1, FINSEQ_1, CARD_1, MATRIX_1, FINSET_1, FINSUB_1, FINSEQ_2,
      FINSEQ_4, FINSEQOP;
 constructors NAT_1, GROUP_4, BINOP_1, MATRIX_1, FINSEQOP, FINSEQ_4, MEMBERED,
      PARTFUN1, RELAT_2, XBOOLE_0;
 clusters FUNCT_1, GROUP_1, MATRIX_1, FINSET_1, RELSET_1, STRUCT_0, FINSEQ_1,
      FINSEQ_2, XREAL_0, ARYTM_3, FUNCT_2, ZFMISC_1, PARTFUN1, XBOOLE_0;
 requirements NUMERALS, REAL, BOOLE, SUBSET, ARITHM;


begin :: Some Examples of Matrices

 reserve x,y,x1,x2,y1,y2 for set,
  i,j,k,l,n,m for Nat,
  D for non empty set,
  K for Field,
  s,s2 for FinSequence,
  a,b,c,d for Element of D,
  q,r for FinSequence of D;

scheme :: MATRIX_2:sch 1
 SeqDEx{D()->non empty set,A()->Nat,P[set,set]}:
  ex p being FinSequence of D() st dom p = Seg A() &
                     for k st k in Seg A() holds P[k,p.k]
 provided
 for k st k in Seg A() ex x being Element of D() st P[k,x]
proof
 defpred _P[set,set] means P[$1,$2];
 A2: for y be set st y in Seg A() ex x st x in D() & _P[y,x]
  proof
   let y;
   assume A3:y in Seg A();
   then reconsider k=y as Nat;
   consider x being Element of D() such that A4:P[k,x] by A1,A3;
   take x;
   thus thesis by A4;
  end;
 consider f being Function such that A5:dom f = Seg A() and A6:rng f c= D() and
   A7:for y be set st y in Seg A() holds _P[y,f.y] from COMPTS_1:sch 1(A2);
 reconsider f as FinSequence by A5,FINSEQ_1:def 2;
 reconsider p=f as FinSequence of D() by A6,FINSEQ_1:def 4;
 take p;
 thus thesis by A5,A7;
end;

definition let n,m; let a be set;
 func (n,m) --> a -> tabular FinSequence equals
:: MATRIX_2:def 1
   n |-> (m |-> a);
end;


 definition
  let D,n,m;let d;
  redefine func (n,m) --> d ->Matrix of n,m,D;
 end;


theorem :: MATRIX_2:1
 [i,j] in Indices ((n,m)-->a) implies ((n,m)-->a) *(i,j)=a;

 reserve a',b' for Element of K;

theorem :: MATRIX_2:2
  ((n,n)-->a') + ((n,n)-->b')= (n,n)-->(a'+b');

definition
 let a,b,c,d be set;
 func (a,b)][(c,d) ->tabular FinSequence equals
:: MATRIX_2:def 2
 <*<*a,b*>,<*c,d*>*>;
 end;


theorem :: MATRIX_2:3
len (x1,x2)][(y1,y2)=2 & width (x1,x2)][(y1,y2)=2 &
        Indices (x1,x2)][(y1,y2)=[:Seg 2,Seg 2:];

theorem :: MATRIX_2:4
 [1,1] in Indices (x1,x2)][(y1,y2) &
     [1,2] in Indices (x1,x2)][(y1,y2) &
     [2,1] in Indices (x1,x2)][(y1,y2) &
     [2,2] in Indices (x1,x2)][(y1,y2);

definition let D;let a be Element of D;
 redefine func <*a*> -> Element of 1-tuples_on D;
end;


 definition let D;let n;let p be Element of n-tuples_on D;
 redefine func <*p*> -> Matrix of 1,n,D;
 end;


theorem :: MATRIX_2:5
   [1,1] in Indices <*<*a*>*> & <*<*a*>*>*(1,1)=a;

 definition let D;let a,b,c,d be Element of D;
  redefine func (a,b)][(c,d) -> Matrix of 2,D;
  end;


theorem :: MATRIX_2:6
   (a,b)][(c,d)*(1,1)=a &
      (a,b)][(c,d)*(1,2)=b &
      (a,b)][(c,d)*(2,1)=c &
      (a,b)][(c,d)*(2,2)=d;

definition let n;let K be Field;
mode Upper_Triangular_Matrix of n,K -> Matrix of n,K means
:: MATRIX_2:def 3
   for i,j st [i,j] in Indices it holds
          (i>j implies it*(i,j) = 0.K );
end;


definition let n;let K;
mode Lower_Triangular_Matrix of n,K -> Matrix of n,K means
:: MATRIX_2:def 4
   for i,j st [i,j] in Indices it holds
          (i<j implies it*(i,j) = 0.K );
end;


theorem :: MATRIX_2:7
  for M being Matrix of D st len M=n holds M is Matrix of n,width M,D;

begin :: Deleting of Rows and Columns in a Matrix

definition let i; let p be FinSequence;
func Del(p,i) -> FinSequence equals
:: MATRIX_2:def 5
   p * Sgm ((dom p) \ {i});
end;


theorem :: MATRIX_2:8
for p being FinSequence holds
  (i in dom p implies ex m st len p = m + 1 & len Del(p,i) = m) &
  (not i in dom p implies Del(p,i) = p);

theorem :: MATRIX_2:9
 for p being FinSequence of D holds Del(p,i) is FinSequence of D;

theorem :: MATRIX_2:10
for M be Matrix of n,m,K holds
  for k st k in Seg n holds M.k=Line(M,k);

definition let i;
let K;
let M be Matrix of K;
assume i in Seg (width M);
func DelCol(M,i) -> Matrix of K means
:: MATRIX_2:def 6
  len it=len M & for k st k in dom M holds it.k=Del(Line(M,k),i);
end;


theorem :: MATRIX_2:11
 for M1,M2 being Matrix of D st M1@=M2@ & len M1=len M2
      holds M1 = M2;

theorem :: MATRIX_2:12
for M being Matrix of D st width M > 0
        holds len (M@)=width M & width (M@)=len M;

theorem :: MATRIX_2:13
   for M1,M2 being Matrix of D st width M1>0 & width M2>0 &
     M1@=M2@ & width (M1@) =width (M2@)
     holds M1=M2;

theorem :: MATRIX_2:14
 for M1,M2 being Matrix of D st width M1>0 & width M2>0 holds
     M1=M2 iff M1@=M2@ & width M1 = width M2;

theorem :: MATRIX_2:15
for M being Matrix of D st len M>0 & width M>0 holds (M@)@=M;

theorem :: MATRIX_2:16
for M being Matrix of D holds
       for i st i in dom M holds Line(M,i)=Col(M@,i);

theorem :: MATRIX_2:17
for M being Matrix of D holds
       for j st j in Seg(width M) holds Line(M@,j)=Col(M,j);

theorem :: MATRIX_2:18
for M being Matrix of D holds for i st i in dom M holds M.i=Line(M,i);

definition let i; let K;let M be Matrix of K;
assume i in dom M & width M>0;
func DelLine(M,i) -> Matrix of K means
:: MATRIX_2:def 7
     it={} if len M=1 otherwise
     width it=width M &
     for k st k in Seg (width M) holds Col(it,k)=Del(Col(M,k),i);
end;


definition let i,j; let n;let K;let M be Matrix of n,K;
func Deleting(M,i,j) -> Matrix of K equals
:: MATRIX_2:def 8
    {} if n=1 otherwise
     DelCol((DelLine(M,i)),j);
end;


begin :: Sets of Permutations

definition let IT be set;
  attr IT is permutational means
:: MATRIX_2:def 9
 ex n st for x st x in IT holds x is Permutation of Seg n;
end;


registration
 cluster permutational non empty set;
  existence
   proof
   consider n;consider p being Permutation of Seg n;
   take P={p};
   thus P is permutational
    proof
     take n;let x;
     assume x in P;
     hence thesis by TARSKI:def 1;
    end;
  thus thesis;
   end;
end;


definition let P be permutational non empty set;
func len P -> Nat means
:: MATRIX_2:def 10
 ex s st s in P & it=len s;
 end;


definition let P be permutational non empty set;
redefine mode Element of P -> Permutation of Seg len P;
 end;


theorem :: MATRIX_2:19
   ex P being permutational non empty set st len P =n;

definition let n;
func Permutations(n) -> set means
:: MATRIX_2:def 11
x in it iff x is Permutation of Seg n;
end;


registration let n;
cluster Permutations(n) -> permutational non empty;
coherence
 proof
 defpred P[set] means $1 is Permutation of Seg n;
 consider P being set such that A1:for x holds x in P iff x in
 Funcs(Seg n,Seg n) & P[x] from XBOOLE_0:sch 1;
  A2:id Seg n= idseq n & idseq n is Permutation of Seg n by FINSEQ_2:65,def 1;
    idseq n is Function of Seg n,Seg n by FINSEQ_2:65;
  then idseq n in Funcs(Seg n,Seg n) by FUNCT_2:12;
  then reconsider P as non empty set by A1,A2;
    P is permutational non empty set
   proof now take n;let x;
    assume x in P;
    hence x is Permutation of Seg n by A1;
    end;
    hence thesis by Def9;
   end;
  then reconsider P as permutational non empty set;
    x in P iff x is Permutation of Seg n
   proof
    thus x in P implies x is Permutation of Seg n by A1;
    assume A3:x is Permutation of Seg n;
    then x in Funcs(Seg n,Seg n) by FUNCT_2:12;
    hence thesis by A1,A3;
 end;
 hence thesis by Def11;
end;
end;


theorem :: MATRIX_2:20
  len Permutations(n)=n;

theorem :: MATRIX_2:21
  Permutations(1)={idseq 1};

definition let n;let p be Element of Permutations(n);
func len p -> Nat means
:: MATRIX_2:def 12
 ex s being FinSequence st s=p & it=len s;
end;


theorem :: MATRIX_2:22
  for p being Element of Permutations(n) holds len p= n;

begin :: Group of Permutations

reserve p,q for Element of Permutations(n);

definition let n;
 func Group_of_Perm(n) -> strict HGrStr means
:: MATRIX_2:def 13
 the carrier of it = Permutations(n) &
  for q,p be Element of Permutations(n) holds (the mult of it).(q,p)=p*q;
end;


registration let n;
 cluster Group_of_Perm(n) -> non empty;
 coherence
  proof
      the carrier of Group_of_Perm(n) = Permutations(n) by Def13;
   hence the carrier of Group_of_Perm(n) is non empty;
  end;
end;


theorem :: MATRIX_2:23
 idseq n is Element of Group_of_Perm(n);

theorem :: MATRIX_2:24
  p *(idseq n)=p & (idseq n)*p=p;

theorem :: MATRIX_2:25
 p *p"=idseq n & p"*p=idseq n;

theorem :: MATRIX_2:26
p" is Element of Group_of_Perm(n);

 definition let n;
  mode permutation of n is Element of Permutations(n);
  end;
registration let n;
  cluster Group_of_Perm(n) -> associative Group-like;
 coherence
 proof
    A1:for p,q,r being Element of Group_of_Perm(n)
       holds (p * q) * r = p * (q * r)
       proof
        let p,q,r be Element of Group_of_Perm(n);
        reconsider p'=p,q'=q,r'=r as Element of Permutations(n) by Def13;
         A2:q'*p' is Permutation of Seg n & r'*q' is Permutation of Seg n
           proof
             reconsider p',q',r' as Permutation of Seg n by Def11;
             A3: q'*p' is Permutation of Seg n;
                r'*q' is Permutation of Seg n;
            hence thesis by A3;
           end;
        then A4:q' * p' is Element of Permutations(n) by Def11;
        A5:r' * q' is Element of Permutations(n) by A2,Def11;
          (p * q) * r = (the mult of Group_of_Perm(n)).((p*q),r)
                                                     by VECTSP_1:def 10
                     .=(the mult of Group_of_Perm(n)).
                    (((the mult of Group_of_Perm(n)).(p',q')),r') by VECTSP_1:
def 10
                    .=(the mult of Group_of_Perm(n)).((q'*p'),r') by Def13
                    .=r'*(q' *p' ) by A4,Def13
                    .=(r' *q') * p' by RELAT_1:55
                    .=(the mult of Group_of_Perm(n)).(p',(r'*q'))
                                                   by A5,Def13
                    .=(the mult of Group_of_Perm(n)).
                       (p,(the mult of Group_of_Perm(n)).(q,r)) by Def13
                    .=(the mult of Group_of_Perm(n)).(p,(q*r))
                                                 by VECTSP_1:def 10
                    .=p *(q* r) by VECTSP_1:def 10;
        hence thesis;
       end;
       ex e being Element of Group_of_Perm(n) st
        for p being Element of Group_of_Perm(n) holds
         p * e = p & e * p = p &
           ex g being Element of Group_of_Perm(n) st
        p * g = e & g * p = e
         proof
            idseq n = id Seg n by FINSEQ_2:def 1;
          then reconsider e'=idseq n as Element of Permutations(n) by Def11;
          reconsider e=idseq n as Element of Group_of_Perm(n)
          by Th23;
       A6:  for p being Element of Group_of_Perm(n) holds
                p * e =p & e* p=p
             proof
              let p be Element of Group_of_Perm(n);
              reconsider p'=p as Element of Permutations(n) by Def13;
             A7:p * e =(the mult of Group_of_Perm(n)).(p',e') by VECTSP_1:def
10
                    .=e' * p' by Def13
                    .=p by Th24;
                 e * p =(the mult of Group_of_Perm(n)).(e',p') by VECTSP_1:def
10
                    .=p' * e' by Def13
                    .=p by Th24;
            hence thesis by A7;
          end;
         take e;
        for p being Element of Group_of_Perm(n)
                holds ex g being Element of Group_of_Perm(n) st
                       p * g= e & g * p=e
              proof
               let p be Element of Group_of_Perm(n);
               reconsider q=p as Element of Permutations(n) by Def13;
               reconsider r=q as Permutation of Seg n by Def11;
               reconsider f=r" as Element of Permutations(n) by Def11;
               reconsider g=f as Element of Group_of_Perm(n)
               by Th26;
              A8: p * g=(the mult of Group_of_Perm(n)).(q,f) by VECTSP_1:def 10
                     .=f*q by Def13
                     .=e by Th25;
              A9: g * p=(the mult of Group_of_Perm(n)).(f,q) by VECTSP_1:def 10
                     .=q*f by Def13
                     .=e by Th25;
               take g;
              thus thesis by A8,A9;
             end;
         hence thesis by A6;
         end;
  hence thesis by A1,GROUP_1:5;
 end;
 end;


canceled;

theorem :: MATRIX_2:28
 idseq n= 1.Group_of_Perm(n);

definition let n;let p be Permutation of Seg n;
 attr p is being_transposition means
:: MATRIX_2:def 14
     ex i,j st i in dom p & j in dom p & i<>j & p.i=j & p.j=i &
   for k st k <>i & k<>j & k in dom p holds p.k=k;
  end;
notation let n;let p be Permutation of Seg n;
 synonym p is_transposition for p is being_transposition ; end;


definition let n;
  let IT be Permutation of Seg n;
  attr IT is even means
:: MATRIX_2:def 15
ex l be FinSequence of the carrier of Group_of_Perm(n)
   st (len l)mod 2=0 & IT=Product l &
  for i st i in dom l ex q st l.i=q & q is_transposition;
 end;
notation let n;
  let IT be Permutation of Seg n;
  antonym IT is odd for IT is even ; end;


theorem :: MATRIX_2:29
  id Seg n is even;

definition
 let K,n;let x be Element of K;
 let p be Element of Permutations(n);
func -(x,p)-> Element of K equals
:: MATRIX_2:def 16
     x if p is even otherwise -x;
end;


definition let X be set;
assume X is finite;
func FinOmega(X) -> Element of Fin X equals
:: MATRIX_2:def 17
   X;
end;


theorem :: MATRIX_2:30
   Permutations(n) is finite;
