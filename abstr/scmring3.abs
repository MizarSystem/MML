:: The Properties of Instructions of { \bf SCM } over Ring
::  by Artur Korni{\l}owicz
::
:: Received April 14, 2000
:: Copyright (c) 2000 Association of Mizar Users

environ

 vocabularies NUMBERS, SCMFSA7B, FUNCSDOM, SUBSET_1, AMI_3, AMI_1, FSM_1,
      ORDINAL1, INT_3, FINSET_1, STRUCT_0, AMI_2, TARSKI, ZFMISC_1, RELAT_1,
      FUNCOP_1, XBOOLE_0, CAT_1, FUNCT_7, FUNCT_1, CARD_1, MCART_1, GRAPHSP,
      FINSEQ_1, AMISTD_2, CARD_3, AMISTD_1, CIRCUIT2, FUNCT_4, SETFAM_1,
      SUPINF_2, FUNCT_2, ARYTM_3, XXREAL_0, GOBOARD5, ARYTM_1, GROUP_1,
      FRECHET, UNIALG_1, CARD_5, PARTFUN1;
 notations TARSKI, XBOOLE_0, SUBSET_1, FINSET_1, ENUMSET1, ZFMISC_1, MCART_1,
      SETFAM_1, RELAT_1, FUNCT_1, XXREAL_0, STRUCT_0, ALGSTR_0, FUNCSDOM,
      ORDINAL1, CARD_1, NUMBERS, NAT_1, FUNCOP_1, FINSEQ_1, PARTFUN1, FUNCT_4,
      CARD_3, FUNCT_7, GROUP_1, AMI_1, AMI_2, AMI_3, SCMRING1, SCMRING2, INT_3,
      SCMNORM, AMISTD_1, AMISTD_2, FUNCT_2;
 constructors XXREAL_0, NAT_1, FINSEQ_4, VECTSP_2, REALSET2, INT_3, AMI_5,
      SCMRING2, AMISTD_2, SCMNORM, BINOP_2, RELSET_1, PBOOLE;
 registrations XBOOLE_0, SETFAM_1, RELAT_1, FUNCT_1, ORDINAL1, FUNCOP_1,
      XREAL_0, INT_1, FINSEQ_1, CARD_3, STRUCT_0, VECTSP_1, INT_3, AMI_1,
      AMI_3, SCMRING1, SCMRING2, AMISTD_2, AFINSQ_1, REALSET1, NUMBERS,
      RELSET_1, ZFMISC_1, CARD_2, PBOOLE, FUNCT_2, FUNCT_4;
 requirements NUMERALS, REAL, BOOLE, SUBSET, ARITHM;


begin

reserve R for good Ring,
  r for Element of R,
  a, b, d1, d2 for Data-Location of R,
  il, i1, i2 for Element of NAT,
  I for Instruction of SCM R,
  s,
  s1, s2 for State of SCM R,
  T for InsType of SCM R,
  k for natural number;


registration
  cluster INT.Ring -> infinite good;
end;

registration
  cluster strict infinite good Ring;
end;

theorem :: SCMRING3:1
  ObjectKind a = the carrier of R;

definition
  let R be good Ring;
  let la, lb be Data-Location of R;
  let a, b be Element of R;
  redefine func (la,lb) --> (a,b) -> FinPartState of SCM R;
end;

theorem :: SCMRING3:2
  not a in NAT;

theorem :: SCMRING3:3
  a <> IC SCM R;

theorem :: SCMRING3:4
  SCM-Data-Loc <> NAT;

theorem :: SCMRING3:5
  for o being Object of SCM R holds o = IC SCM R or o in NAT or o
  is Data-Location of R;

canceled;

theorem :: SCMRING3:7
  s1,s2 equal_outside NAT implies s1.a = s2.a;

theorem :: SCMRING3:8
  InsCode halt SCM R = 0;

theorem :: SCMRING3:9
  InsCode (a:=b) = 1;

theorem :: SCMRING3:10
  InsCode AddTo(a,b) = 2;

theorem :: SCMRING3:11
  InsCode SubFrom(a,b) = 3;

theorem :: SCMRING3:12
  InsCode MultBy(a,b) = 4;

theorem :: SCMRING3:13
  InsCode (a:=r) = 5;

theorem :: SCMRING3:14
  InsCode goto(i1,R) = 6;

theorem :: SCMRING3:15
  InsCode (a=0_goto i1) = 7;

theorem :: SCMRING3:16
  InsCode I = 0 implies I = halt SCM R;

theorem :: SCMRING3:17
  InsCode I = 1 implies ex a, b st I = a:=b;

theorem :: SCMRING3:18
  InsCode I = 2 implies ex a, b st I = AddTo(a,b);

theorem :: SCMRING3:19
  InsCode I = 3 implies ex a, b st I = SubFrom(a,b);

theorem :: SCMRING3:20
  InsCode I = 4 implies ex a, b st I = MultBy(a,b);

theorem :: SCMRING3:21
  InsCode I = 5 implies ex a, r st I = a:=r;

theorem :: SCMRING3:22
  InsCode I = 6 implies ex i2 st I = goto(i2,R);

theorem :: SCMRING3:23
  InsCode I = 7 implies ex a, i1 st I = a=0_goto i1;

theorem :: SCMRING3:24
  AddressPart halt SCM R = {};

canceled 7;

theorem :: SCMRING3:32
  T = 0 implies AddressParts T = {0};

registration
  let R, T;
  cluster AddressParts T -> non empty;
end;

theorem :: SCMRING3:33
  T = 1 implies dom product" AddressParts T = {1,2};

theorem :: SCMRING3:34
  T = 2 implies dom product" AddressParts T = {1,2};

theorem :: SCMRING3:35
  T = 3 implies dom product" AddressParts T = {1,2};

theorem :: SCMRING3:36
  T = 4 implies dom product" AddressParts T = {1,2};

theorem :: SCMRING3:37
  T = 5 implies dom product" AddressParts T = {1,2};

theorem :: SCMRING3:38
  T = 6 implies dom product" AddressParts T = {1};

theorem :: SCMRING3:39
  T = 7 implies dom product" AddressParts T = {1,2};

theorem :: SCMRING3:40
  (product" AddressParts InsCode (a:=b)).1 = SCM-Data-Loc;

theorem :: SCMRING3:41
  (product" AddressParts InsCode (a:=b)).2 = SCM-Data-Loc;

theorem :: SCMRING3:42
  (product" AddressParts InsCode AddTo(a,b)).1 = SCM-Data-Loc;

theorem :: SCMRING3:43
  (product" AddressParts InsCode AddTo(a,b)).2 = SCM-Data-Loc;

theorem :: SCMRING3:44
  (product" AddressParts InsCode SubFrom(a,b)).1 = SCM-Data-Loc;

theorem :: SCMRING3:45
  (product" AddressParts InsCode SubFrom(a,b)).2 = SCM-Data-Loc;

theorem :: SCMRING3:46
  (product" AddressParts InsCode MultBy(a,b)).1 = SCM-Data-Loc;

theorem :: SCMRING3:47
  (product" AddressParts InsCode MultBy(a,b)).2 = SCM-Data-Loc;

theorem :: SCMRING3:48
  (product" AddressParts InsCode (a:=r)).1 = SCM-Data-Loc;

theorem :: SCMRING3:49
  (product" AddressParts InsCode (a:=r)).2 = the carrier of R;

theorem :: SCMRING3:50
  (product" AddressParts InsCode goto(i1,R)).1 = NAT;

theorem :: SCMRING3:51
  (product" AddressParts InsCode (a =0_goto i1)).1 = NAT;

theorem :: SCMRING3:52
  (product" AddressParts InsCode (a =0_goto i1)).2 = SCM-Data-Loc;

theorem :: SCMRING3:53
  NIC(halt SCM R, il) = {il};

registration
  let R;
  cluster JUMP halt SCM R -> empty;
end;

theorem :: SCMRING3:54
  NIC(a := b, il) = {succ il};

registration
  let R, a, b;
  cluster JUMP (a := b) -> empty;
end;

theorem :: SCMRING3:55
  NIC(AddTo(a,b), il) = {succ il};

registration
  let R, a, b;
  cluster JUMP AddTo(a, b) -> empty;
end;

theorem :: SCMRING3:56
  NIC(SubFrom(a,b), il) = {succ il};

registration
  let R, a, b;
  cluster JUMP SubFrom(a, b) -> empty;
end;

theorem :: SCMRING3:57
  NIC(MultBy(a,b), il) = {succ il};

registration
  let R, a, b;
  cluster JUMP MultBy(a,b) -> empty;
end;

theorem :: SCMRING3:58
  NIC(a := r, il) = {succ il};

registration
  let R, a, r;
  cluster JUMP (a := r) -> empty;
end;

theorem :: SCMRING3:59
  NIC(goto(i1,R), il) = {i1};

theorem :: SCMRING3:60
  JUMP goto(i1,R) = {i1};

registration
  let R, i1;
  cluster JUMP goto(i1,R) -> non empty trivial;
end;

theorem :: SCMRING3:61
  i1 in NIC(a=0_goto i1, il) & NIC(a=0_goto i1, il) c= {i1, succ
  il};

theorem :: SCMRING3:62
  for R being non trivial good Ring, a being Data-Location of R, il, i1
being Element of NAT holds NIC(a=0_goto i1, il) = {i1, succ il};

theorem :: SCMRING3:63
  JUMP (a=0_goto i1) = {i1};

registration
  let R, a, i1;
  cluster JUMP (a =0_goto i1) -> non empty trivial;
end;

theorem :: SCMRING3:64
  SUCC(il,SCM R) = {il, succ il};

theorem :: SCMRING3:65
  for f being Function of NAT, NAT st for k being Element of
NAT holds f.k = k holds f is bijective & for k being Element of NAT holds f.
  (k+1) in SUCC(f.k,SCM R) & for j being Element of NAT
   st f.j in SUCC(f.k,SCM R)
   holds k <= j;

registration
  let R;
  cluster SCM R -> standard;
end;

theorem :: SCMRING3:66
 for k being natural number holds
  il.(SCM R,k) = k;

theorem :: SCMRING3:67
  succ il.(SCM R,k) = il.(SCM R,k+1);

theorem :: SCMRING3:68
  succ il = NextLoc(il,SCM R);

definition
  let R be good Ring, k be Element of NAT;
  func dl.(R,k) -> Data-Location of R equals
:: SCMRING3:def 1
  dl.k;
end;

registration
  let R;
  cluster InsCode halt SCM R -> jump-only InsType of SCM R;
end;

registration
  let R;
  cluster halt SCM R -> jump-only;
end;

registration
  let R, i1;
  cluster InsCode goto(i1,R) -> jump-only InsType of SCM R;
end;

registration
  let R, i1;
  cluster goto(i1,R) -> jump-only;
end;

registration
  let R, a, i1;
  cluster InsCode (a =0_goto i1) -> jump-only InsType of SCM R;
end;

registration
  let R, a, i1;
  cluster a =0_goto i1 -> jump-only;
end;

reserve S for non trivial good Ring,
  p, q for Data-Location of S,
  w for
  Element of S;

registration
  let S, p, q;
  cluster InsCode (p:=q) -> non jump-only InsType of SCM S;
end;

registration
  let S, p, q;
  cluster p:=q -> non jump-only;
end;

registration
  let S, p, q;
  cluster InsCode AddTo(p,q) -> non jump-only InsType of SCM S;
end;

registration
  let S, p, q;
  cluster AddTo(p, q) -> non jump-only;
end;

registration
  let S, p, q;
  cluster InsCode SubFrom(p,q) -> non jump-only InsType of SCM S;
end;

registration
  let S, p, q;
  cluster SubFrom(p, q) -> non jump-only;
end;

registration
  let S, p, q;
  cluster InsCode MultBy(p,q) -> non jump-only InsType of SCM S;
end;

registration
  let S, p, q;
  cluster MultBy(p, q) -> non jump-only;
end;

registration
  let S, p, w;
  cluster InsCode (p:=w) -> non jump-only InsType of SCM S;
end;

registration
  let S, p, w;
  cluster p:=w -> non jump-only;
end;

registration
  let R, a, b;
  cluster a:=b -> sequential;
end;

registration
  let R, a, b;
  cluster AddTo(a,b) -> sequential;
end;

registration
  let R, a, b;
  cluster SubFrom(a,b) -> sequential;
end;

registration
  let R, a, b;
  cluster MultBy(a,b) -> sequential;
end;

registration
  let R, a, r;
  cluster a:=r -> sequential;
end;

registration
  let R, i1;
  cluster goto(i1,R) -> non sequential;
end;

registration
  let R, a, i1;
  cluster a =0_goto i1 -> non sequential;
end;

registration
  let R, i1;
  cluster goto(i1,R) -> non ins-loc-free;
end;

registration
  let R, a, i1;
  cluster a =0_goto i1 -> non ins-loc-free;
end;

registration
  let R;
  cluster SCM R -> homogeneous with_explicit_jumps without_implicit_jumps;
end;

registration
  let R;
  cluster SCM R -> regular;
end;

theorem :: SCMRING3:69
  IncAddr(goto(i1,R),k) = goto(il.(SCM R, locnum(i1,SCM R) + k),R);

theorem :: SCMRING3:70
  IncAddr(a=0_goto i1,k) = a=0_goto il.(SCM R, locnum(i1,SCM R) + k);

registration
  let R;
  cluster SCM R -> IC-good Exec-preserving;
end;

theorem :: SCMRING3:71
  InsCode I <= 7;

