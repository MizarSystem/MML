:: The Properties of Instructions of { \bf SCM } over Ring
::  by Artur Korni{\l}owicz
::
:: Received April 14, 2000
:: Copyright (c) 2000 Association of Mizar Users

environ

 vocabulary AMI_3, SCMFSA7B, FUNCSDOM, AMI_1, ORDINAL2, ARYTM, INT_1, FINSET_1,
      INT_3, AMI_2, GR_CY_1, TARSKI, BOOLE, FUNCT_1, FUNCOP_1, CAT_1, FUNCT_7,
      RELAT_1, AMI_5, MCART_1, FINSEQ_1, AMISTD_2, AMISTD_1, FUNCT_4, SETFAM_1,
      REALSET1, RLVECT_1, SGRAPH1, GOBOARD5, ARYTM_1, VECTSP_1, FRECHET,
      UNIALG_1, CARD_5, CARD_3, RELOC;
 notation TARSKI, XBOOLE_0, SUBSET_1, FINSET_1, MCART_1, SETFAM_1, RELAT_1,
      FUNCT_1, FUNCT_2, STRUCT_0, FUNCSDOM, REALSET1, ORDINAL1, ORDINAL2,
      NUMBERS, XCMPLX_0, XREAL_0, NAT_1, RLVECT_1, CQC_LANG, FINSEQ_1, FUNCT_4,
      GR_CY_1, CARD_3, FUNCT_7, VECTSP_1, GROUP_1, AMI_1, AMI_2, AMI_3, AMI_5,
      SCMRING1, SCMRING2, INT_3, AMISTD_1, AMISTD_2;
 constructors AMI_5, AMISTD_2, DOMAIN_1, NAT_1, SCMRING2, FUNCT_7, PRALG_2,
      INT_3, GCD_1, ALGSTR_2, MEMBERED;
 clusters AMI_1, RELSET_1, SCMRING1, SCMRING2, STRUCT_0, TEX_2, AMISTD_2,
      RELAT_1, FUNCT_1, CQC_LANG, FINSEQ_1, INT_1, INT_3, WAYBEL12, XBOOLE_0,
      REVROT_1, AMI_3, NAT_1, VECTSP_1, FRAENKEL, MEMBERED;
 requirements NUMERALS, REAL, BOOLE, SUBSET, ARITHM;


begin

reserve R for good Ring,
        r for Element of R,
        a, b, d1, d2 for Data-Location of R,
        il, i1, i2 for Instruction-Location of SCM R,
        I for Instruction of SCM R,
        s, s1, s2 for State of SCM R,
        T for InsType of SCM R,
        k for natural number;

registration
 cluster INT -> infinite;
coherence by FINSET_1:13,INT_1:14;
end;


registration
 cluster INT.Ring -> infinite good;
coherence
  proof
    thus the carrier of INT.Ring is infinite by INT_3:def 3;
    thus the carrier of INT.Ring <> SCM-Instr-Loc by AMI_2:6,INT_3:def 3;
    assume the carrier of INT.Ring = SCM-Instr INT.Ring;
    then 1 in SCM-Instr INT.Ring by INT_1:12,INT_3:def 3;
    then ex a, b being set st a in Segm 8 &
     b in (union {the carrier of INT.Ring} \/ NAT)* & 1 = [a,b]
      by ZFMISC_1:def 2;
    hence thesis by AMI_1:2;
  end;
end;


registration
 cluster strict infinite 1-sorted;
existence
  proof
    take A = 1-sorted(#INT#);
    thus A is strict & the carrier of A is infinite;
  end;
end;


registration
 cluster strict infinite good Ring;
existence
  proof
    take INT.Ring;
    thus thesis;
  end;
end;


theorem :: SCMRING3:1
 ObjectKind a = the carrier of R;

definition
 let R be good Ring;
 let la, lb be Data-Location of R;
 let a, b be Element of R;
 redefine func (la,lb) --> (a,b) -> FinPartState of SCM R;
end;


theorem :: SCMRING3:2
 not a in the Instruction-Locations of SCM R;

theorem :: SCMRING3:3
 a <> IC SCM R;

theorem :: SCMRING3:4
 SCM-Data-Loc <> the Instruction-Locations of SCM R;

theorem :: SCMRING3:5
 for o being Object of SCM R holds
  o = IC SCM R or o in the Instruction-Locations of SCM R or
  o is Data-Location of R;

theorem :: SCMRING3:6
 i1 <> i2 implies Next i1 <> Next i2;

theorem :: SCMRING3:7
 s1,s2 equal_outside the Instruction-Locations of SCM R implies s1.a = s2.a;

theorem :: SCMRING3:8
 InsCode halt SCM R = 0;

theorem :: SCMRING3:9
 InsCode (a:=b) = 1;

theorem :: SCMRING3:10
 InsCode AddTo(a,b) = 2;

theorem :: SCMRING3:11
 InsCode SubFrom(a,b) = 3;

theorem :: SCMRING3:12
 InsCode MultBy(a,b) = 4;

theorem :: SCMRING3:13
 InsCode (a:=r) = 5;

theorem :: SCMRING3:14
 InsCode goto i1 = 6;

theorem :: SCMRING3:15
 InsCode (a=0_goto i1) = 7;

theorem :: SCMRING3:16
 InsCode I = 0 implies I = halt SCM R;

theorem :: SCMRING3:17
 InsCode I = 1 implies ex a, b st I = a:=b;

theorem :: SCMRING3:18
 InsCode I = 2 implies ex a, b st I = AddTo(a,b);

theorem :: SCMRING3:19
 InsCode I = 3 implies ex a, b st I = SubFrom(a,b);

theorem :: SCMRING3:20
 InsCode I = 4 implies ex a, b st I = MultBy(a,b);

theorem :: SCMRING3:21
 InsCode I = 5 implies ex a, r st I = a:=r;

theorem :: SCMRING3:22
 InsCode I = 6 implies ex i2 st I = goto i2;

theorem :: SCMRING3:23
 InsCode I = 7 implies ex a, i1 st I = a=0_goto i1;

theorem :: SCMRING3:24
 AddressPart halt SCM R = {};

theorem :: SCMRING3:25
 AddressPart (a:=b) = <*a,b*>;

theorem :: SCMRING3:26
 AddressPart AddTo(a,b) = <*a,b*>;

theorem :: SCMRING3:27
 AddressPart SubFrom(a,b) = <*a,b*>;

theorem :: SCMRING3:28
 AddressPart MultBy(a,b) = <*a,b*>;

theorem :: SCMRING3:29
 AddressPart (a:=r) = <*a,r*>;

theorem :: SCMRING3:30
 AddressPart goto i1 = <*i1*>;

theorem :: SCMRING3:31
 AddressPart (a=0_goto i1) = <*i1,a*>;

theorem :: SCMRING3:32
 T = 0 implies AddressParts T = {0};

registration let R, T;
 cluster AddressParts T -> non empty;
coherence
  proof
A1: AddressParts T = {AddressPart I where
      I is Instruction of SCM R: InsCode I = T} by AMISTD_2:def 5;
    consider a, b, i1, r;
A2: T = 0 or T = 1 or T = 2 or T = 3 or T = 4 or T = 5 or T = 6 or T = 7
      by Lm3;
      InsCode halt SCM R = 0 & InsCode (a:=b) = 1 & InsCode AddTo(a,b) = 2 &
     InsCode SubFrom(a,b) = 3 & InsCode MultBy(a,b) = 4 & InsCode (a:=r) = 5 &
      InsCode goto i1 = 6 & InsCode (a =0_goto i1) = 7
       by Th8,Th9,Th10,Th11,Th12,Th13,Th14,Th15;
    then AddressPart halt SCM R in AddressParts T or
     AddressPart (a:=b) in AddressParts T or
      AddressPart AddTo(a,b) in AddressParts T or
       AddressPart SubFrom(a,b) in AddressParts T or
        AddressPart MultBy(a,b) in AddressParts T or
         AddressPart (a:=r) in AddressParts T or
          AddressPart goto i1 in AddressParts T or
           AddressPart (a =0_goto i1) in AddressParts T by A1,A2;
    hence thesis;
  end;
end;


theorem :: SCMRING3:33
 T = 1 implies dom PA AddressParts T = {1,2};

theorem :: SCMRING3:34
 T = 2 implies dom PA AddressParts T = {1,2};

theorem :: SCMRING3:35
 T = 3 implies dom PA AddressParts T = {1,2};

theorem :: SCMRING3:36
 T = 4 implies dom PA AddressParts T = {1,2};

theorem :: SCMRING3:37
 T = 5 implies dom PA AddressParts T = {1,2};

theorem :: SCMRING3:38
 T = 6 implies dom PA AddressParts T = {1};

theorem :: SCMRING3:39
 T = 7 implies dom PA AddressParts T = {1,2};

theorem :: SCMRING3:40
 (PA AddressParts InsCode (a:=b)).1 = SCM-Data-Loc;

theorem :: SCMRING3:41
 (PA AddressParts InsCode (a:=b)).2 = SCM-Data-Loc;

theorem :: SCMRING3:42
 (PA AddressParts InsCode AddTo(a,b)).1 = SCM-Data-Loc;

theorem :: SCMRING3:43
 (PA AddressParts InsCode AddTo(a,b)).2 = SCM-Data-Loc;

theorem :: SCMRING3:44
 (PA AddressParts InsCode SubFrom(a,b)).1 = SCM-Data-Loc;

theorem :: SCMRING3:45
 (PA AddressParts InsCode SubFrom(a,b)).2 = SCM-Data-Loc;

theorem :: SCMRING3:46
 (PA AddressParts InsCode MultBy(a,b)).1 = SCM-Data-Loc;

theorem :: SCMRING3:47
 (PA AddressParts InsCode MultBy(a,b)).2 = SCM-Data-Loc;

theorem :: SCMRING3:48
 (PA AddressParts InsCode (a:=r)).1 = SCM-Data-Loc;

theorem :: SCMRING3:49
 (PA AddressParts InsCode (a:=r)).2 = the carrier of R;

theorem :: SCMRING3:50
 (PA AddressParts InsCode goto i1).1 = the Instruction-Locations of SCM R;

theorem :: SCMRING3:51
 (PA AddressParts InsCode (a =0_goto i1)).1 =
   the Instruction-Locations of SCM R;

theorem :: SCMRING3:52
 (PA AddressParts InsCode (a =0_goto i1)).2 = SCM-Data-Loc;

theorem :: SCMRING3:53
 NIC(halt SCM R, il) = {il};

registration let R;
 cluster JUMP halt SCM R -> empty;
coherence
proof
 set X = { NIC(halt SCM R, il) : not contradiction };
 assume not thesis;
   then meet X is non empty by AMISTD_1:def 6;
   then consider x being set such that
A1:   x in meet X by XBOOLE_0:def 1;
   reconsider i1 = il.1, i2 = il.2 as Instruction-Location of SCM R
    by AMI_3:def 1,SCMRING2:def 1;
     NIC(halt SCM R, i1) in X & NIC(halt SCM R, i2) in X;
   then {i1} in X & {i2} in X by Th53;
   then x in {i1} & x in {i2} by A1,SETFAM_1:def 1;
   then x = i1 & x = i2 by TARSKI:def 1;
 hence contradiction by AMI_3:53;
end;
end;


theorem :: SCMRING3:54
 NIC(a := b, il) = {Next il};

registration let R, a, b;
 cluster JUMP (a := b) -> empty;
coherence
proof
  for l being Instruction-Location of SCM R holds NIC(a:=b,l)={Next l} by Th54;
  hence thesis by Lm6;
end;
end;


theorem :: SCMRING3:55
 NIC(AddTo(a,b), il) = {Next il};

registration let R, a, b;
 cluster JUMP AddTo(a, b) -> empty;
coherence
proof
  for l being Instruction-Location of SCM R holds NIC(AddTo(a,b),l)={Next l}
   by Th55;
  hence thesis by Lm6;
end;
end;


theorem :: SCMRING3:56
 NIC(SubFrom(a,b), il) = {Next il};

registration let R, a, b;
 cluster JUMP SubFrom(a, b) -> empty;
coherence
proof
  for l being Instruction-Location of SCM R holds NIC(SubFrom(a,b),l)={Next l}
   by Th56;
  hence thesis by Lm6;
end;
end;


theorem :: SCMRING3:57
 NIC(MultBy(a,b), il) = {Next il};

registration let R, a, b;
 cluster JUMP MultBy(a,b) -> empty;
coherence
proof
  for l being Instruction-Location of SCM R holds NIC(MultBy(a,b),l)={Next l}
   by Th57;
  hence thesis by Lm6;
end;
end;


theorem :: SCMRING3:58
 NIC(a := r, il) = {Next il};

registration let R, a, r;
 cluster JUMP (a := r) -> empty;
coherence
proof
  for l being Instruction-Location of SCM R holds NIC(a:=r,l)={Next l}
   by Th58;
  hence thesis by Lm6;
end;
end;


theorem :: SCMRING3:59
 NIC(goto i1, il) = {i1};

theorem :: SCMRING3:60
 JUMP goto i1 = {i1};

registration let R, i1;
 cluster JUMP goto i1 -> non empty trivial;
coherence
  proof
      JUMP goto i1 = {i1} by Th60;
    hence thesis;
  end;
end;


theorem :: SCMRING3:61
 i1 in NIC(a=0_goto i1, il) & NIC(a=0_goto i1, il) c= {i1, Next il};

theorem :: SCMRING3:62
  for R being non trivial good Ring,
      a being Data-Location of R,
      il, i1 being Instruction-Location of SCM R
  holds NIC(a=0_goto i1, il) = {i1, Next il};

theorem :: SCMRING3:63
 JUMP (a=0_goto i1) = {i1};

registration let R, a, i1;
 cluster JUMP (a =0_goto i1) -> non empty trivial;
coherence
  proof
      JUMP (a =0_goto i1) = {i1} by Th63;
    hence thesis;
  end;
end;


theorem :: SCMRING3:64
 SUCC il = {il, Next il};

theorem :: SCMRING3:65
 for f being Function of NAT, the Instruction-Locations of SCM R
   st for k being Nat holds f.k = il.k holds
  f is bijective &
  for k being Nat holds f.(k+1) in SUCC (f.k) &
   for j being Nat st f.j in SUCC (f.k) holds k <= j;

registration let R;
 cluster SCM R -> standard;
coherence
  proof deffunc U(Nat) = il.$1;
    consider f being Function of NAT, the Instruction-Locations of SCM
       such that
A1:   for k being Nat holds f.k = U(k) from FUNCT_2:sch 4;
      the Instruction-Locations of SCM
     = the Instruction-Locations of SCM R by AMI_3:def 1,SCMRING2:def 1;
    then reconsider f as Function of NAT, the Instruction-Locations of SCM R;
      for k being Nat holds f.k = il.k by A1;
    then f is bijective &
     for k being Nat holds f.(k+1) in SUCC (f.k) &
      for j being Nat st f.j in SUCC (f.k) holds k <= j by Th65;
    hence SCM R is standard by AMISTD_1:19;
  end;
end;


theorem :: SCMRING3:66
 il.(SCM R,k) = il.k;

theorem :: SCMRING3:67
 Next il.(SCM R,k) = il.(SCM R,k+1);

theorem :: SCMRING3:68
 Next il = NextLoc il;

definition let R be good Ring, k be Nat;
 func dl.(R,k) -> Data-Location of R equals
:: SCMRING3:def 1
  dl.k;
end;


registration let R;
 cluster InsCode halt SCM R -> jump-only;
coherence
  proof
    let s be State of SCM R, o be Object of SCM R, I be Instruction of SCM R;
    assume that
A1:   InsCode I = InsCode halt SCM R and
        o <> IC SCM R;
      InsCode halt SCM R = 0 by Th8;
    then I = halt SCM R by A1,Th16;
    hence Exec(I, s).o = s.o by AMI_1:def 8;
  end;
end;


registration let R;
 cluster halt SCM R -> jump-only;
coherence
  proof
    thus InsCode halt SCM R is jump-only;
  end;
end;


registration let R, i1;
 cluster InsCode goto i1 -> jump-only;
coherence
  proof
    set S = SCM R;
    let s be State of S, o be Object of S, I be Instruction of S;
    assume that
A1:    InsCode I = InsCode goto i1 and
A2:    o <> IC S;
      InsCode goto i1 = 6 by Th14;
    then consider i2 such that
A3:    I = goto i2 by A1,Th22;
    per cases by A2,Th5;
    suppose o in the Instruction-Locations of S;
    hence Exec(I, s).o = s.o by AMI_1:def 13;
    end;
    suppose o is Data-Location of R;
    hence Exec(I, s).o = s.o by A3,SCMRING2:17;
  end;
  end;
end;


registration let R, i1;
 cluster goto i1 -> jump-only;
coherence
  proof
    thus InsCode goto i1 is jump-only;
  end;
end;


registration let R, a, i1;
 cluster InsCode (a =0_goto i1) -> jump-only;
coherence
  proof
    set S = SCM R;
    let s be State of S, o be Object of S, I be Instruction of S;
    assume that
A1:    InsCode I = InsCode (a =0_goto i1) and
A2:    o <> IC S;
      InsCode (a =0_goto i1) = 7 by Th15;
    then consider b, i2 such that
A3:    I = (b =0_goto i2) by A1,Th23;
    per cases by A2,Th5;
    suppose o in the Instruction-Locations of S;
    hence Exec(I, s).o = s.o by AMI_1:def 13;
    end;
    suppose o is Data-Location of R;
    hence Exec(I, s).o = s.o by A3,SCMRING2:18;
  end;
  end;
end;


registration let R, a, i1;
 cluster a =0_goto i1 -> jump-only;
coherence
  proof
    thus InsCode (a =0_goto i1) is jump-only;
  end;
end;


reserve S for non trivial good Ring,
        p, q for Data-Location of S,
        w for Element of S;

registration let S, p, q;
 cluster InsCode (p:=q) -> non jump-only;
coherence
proof
   consider e being Element of S such that
A1:   e <> 0.S by ANPROJ_1:def 8;
   reconsider e as Element of S;
   consider w being State of SCM S;
   set t = w+*((dl.(S,0), dl.(S,1))-->(0.S,e));
A2: InsCode (p:=q) = 1 by Th9
    .= InsCode (dl.(S,0):=dl.(S,1)) by Th9;
A3: IC SCM S = IC SCM by AMI_3:4,SCMRING2:9;
A4: dl.(S,0) = dl.0 by Def1;
then A5: dl.(S,0) <> IC SCM S by A3,AMI_3:57;
     dom ((dl.(S,0), dl.(S,1))-->(0.S,e)) = {dl.(S,0), dl.(S,1)} by FUNCT_4:65
;
then A6: dl.(S,0) in dom ((dl.(S,0), dl.(S,1))-->(0.S,e)) &
   dl.(S,1) in dom ((dl.(S,0), dl.(S,1))-->(0.S,e)) by TARSKI:def 2;
     dl.(S,1) = dl.1 by Def1;
then A7: dl.(S,0) <> dl.(S,1) by A4,AMI_3:52;
A8: t.dl.(S,0) = (dl.(S,0), dl.(S,1))-->(0.S,e).dl.(S,0) by A6,FUNCT_4:14
             .= 0.S by A7,FUNCT_4:66;
     Exec((dl.(S,0):=dl.(S,1)), t).dl.(S,0)
    = t.dl.(S,1) by SCMRING2:13
   .= (dl.(S,0), dl.(S,1))-->(0.S,e).dl.(S,1) by A6,FUNCT_4:14
   .= e by A7,FUNCT_4:66;
  hence thesis by A1,A2,A5,A8,AMISTD_1:def 3;
end;
end;


registration let S, p, q;
 cluster p:=q -> non jump-only;
coherence
  proof
    thus InsCode (p:=q) is not jump-only;
  end;
end;


registration let S, p, q;
 cluster InsCode AddTo(p,q) -> non jump-only;
coherence
proof
   consider e being Element of S such that
A1:   e <> 0.S by ANPROJ_1:def 8;
   reconsider e as Element of S;
   consider w being State of SCM S;
   set t = w+*((dl.(S,0), dl.(S,1))-->(0.S,e));
A2: InsCode AddTo(p,q) = 2 by Th10
    .= InsCode AddTo(dl.(S,0), dl.(S,1)) by Th10;
A3: IC SCM S = IC SCM by AMI_3:4,SCMRING2:9;
A4: dl.(S,0) = dl.0 by Def1;
then A5: dl.(S,0) <> IC SCM S by A3,AMI_3:57;
     dom ((dl.(S,0), dl.(S,1))-->(0.S,e)) = {dl.(S,0), dl.(S,1)} by FUNCT_4:65
;
then A6: dl.(S,0) in dom ((dl.(S,0), dl.(S,1))-->(0.S,e)) &
   dl.(S,1) in dom ((dl.(S,0), dl.(S,1))-->(0.S,e)) by TARSKI:def 2;
     dl.(S,1) = dl.1 by Def1;
then A7: dl.(S,0) <> dl.(S,1) by A4,AMI_3:52;
A8: t.dl.(S,0) = (dl.(S,0), dl.(S,1))-->(0.S,e).dl.(S,0) by A6,FUNCT_4:14
             .= 0.S by A7,FUNCT_4:66;
A9: t.dl.(S,1) = (dl.(S,0), dl.(S,1))-->(0.S,e).dl.(S,1) by A6,FUNCT_4:14
             .= e by A7,FUNCT_4:66;
     Exec(AddTo(dl.(S,0), dl.(S,1)), t).dl.(S,0)
    = t.dl.(S,0) + t.dl.(S,1) by SCMRING2:14
   .= e by A8,A9,RLVECT_1:10;
  hence thesis by A1,A2,A5,A8,AMISTD_1:def 3;
end;
end;


registration let S, p, q;
 cluster AddTo(p, q) -> non jump-only;
coherence
  proof
    thus InsCode AddTo(p, q) is not jump-only;
  end;
end;


registration let S, p, q;
 cluster InsCode SubFrom(p,q) -> non jump-only;
coherence
proof
   consider e being Element of S such that
A1:   e <> 0.S by ANPROJ_1:def 8;
   reconsider e as Element of S;
   consider w being State of SCM S;
   set t = w+*((dl.(S,0), dl.(S,1))-->(0.S,e));
A2: InsCode SubFrom(p,q) = 3 by Th11
    .= InsCode SubFrom(dl.(S,0), dl.(S,1)) by Th11;
A3: IC SCM S = IC SCM by AMI_3:4,SCMRING2:9;
A4: dl.(S,0) = dl.0 by Def1;
then A5: dl.(S,0) <> IC SCM S by A3,AMI_3:57;
     dom ((dl.(S,0), dl.(S,1))-->(0.S,e)) = {dl.(S,0), dl.(S,1)} by FUNCT_4:65
;
then A6: dl.(S,0) in dom ((dl.(S,0), dl.(S,1))-->(0.S,e)) &
   dl.(S,1) in dom ((dl.(S,0), dl.(S,1))-->(0.S,e)) by TARSKI:def 2;
     dl.(S,1) = dl.1 by Def1;
then A7: dl.(S,0) <> dl.(S,1) by A4,AMI_3:52;
A8: t.dl.(S,0) = (dl.(S,0), dl.(S,1))-->(0.S,e).dl.(S,0) by A6,FUNCT_4:14
             .= 0.S by A7,FUNCT_4:66;
A9: t.dl.(S,1) = (dl.(S,0), dl.(S,1))-->(0.S,e).dl.(S,1) by A6,FUNCT_4:14
             .= e by A7,FUNCT_4:66;
A10: Exec(SubFrom(dl.(S,0), dl.(S,1)), t).dl.(S,0)
    = t.dl.(S,0) - t.dl.(S,1) by SCMRING2:15
   .= -e by A8,A9,RLVECT_1:27;
    now
    assume -e = 0.S;
    then e = -0.S by RLVECT_1:30;
    hence contradiction by A1,RLVECT_1:25;
  end;
  hence thesis by A2,A5,A8,A10,AMISTD_1:def 3;
end;
end;


registration let S, p, q;
 cluster SubFrom(p, q) -> non jump-only;
coherence
  proof
    thus InsCode SubFrom(p, q) is not jump-only;
  end;
end;


registration let S, p, q;
 cluster InsCode MultBy(p,q) -> non jump-only;
coherence
proof
A1: 0.S <> 1_ S by LMOD_6:def 2;
   consider w being State of SCM S;
   set t = w+*((dl.(S,0), dl.(S,1))-->(1_ S,0.S));
A2: InsCode MultBy(p,q) = 4 by Th12
    .= InsCode MultBy(dl.(S,0), dl.(S,1)) by Th12;
A3: IC SCM S = IC SCM by AMI_3:4,SCMRING2:9;
A4:  dl.(S,0) = dl.0 by Def1;
then A5:  dl.(S,0) <> IC SCM S by A3,AMI_3:57;
      dom ((dl.(S,0), dl.(S,1))-->(1_ S,0.S)) = {dl.(S,0), dl.(S,1)} by FUNCT_4
:65;
     then A6: dl.(S,0) in dom ((dl.(S,0), dl.(S,1))-->(1_ S,0.S)) &
   dl.(S,1) in dom ((dl.(S,0), dl.(S,1))-->(1_ S,0.S)) by TARSKI:def 2;
     dl.(S,1) = dl.1 by Def1;
then A7: dl.(S,0) <> dl.(S,1) by A4,AMI_3:52;
A8: t.dl.(S,0) = (dl.(S,0), dl.(S,1))-->(1_ S,0.S).dl.(S,0) by A6,FUNCT_4:14
             .= 1_ S by A7,FUNCT_4:66;
A9: t.dl.(S,1) = (dl.(S,0), dl.(S,1))-->(1_ S,0.S).dl.(S,1) by A6,FUNCT_4:14
             .= 0.S by A7,FUNCT_4:66;
     Exec(MultBy(dl.(S,0), dl.(S,1)), t).dl.(S,0)
    = t.dl.(S,0) * t.dl.(S,1) by SCMRING2:16
   .= 0.S by A9,VECTSP_1:36;
  hence thesis by A1,A2,A5,A8,AMISTD_1:def 3;
end;
end;


registration let S, p, q;
 cluster MultBy(p, q) -> non jump-only;
coherence
  proof
    thus InsCode MultBy(p, q) is not jump-only;
  end;
end;


registration let S, p, w;
 cluster InsCode (p:=w) -> non jump-only;
coherence
  proof
      the carrier of S <> {w};
    then consider e being set such that
A1:   e in the carrier of S and
A2:   e <> w by ZFMISC_1:41;
    reconsider e as Element of S by A1;
    consider j being State of SCM S;
      ObjectKind dl.(S,0) = the carrier of S by Th1;
    then reconsider v = dl.(S,0) .--> e as FinPartState of SCM S by AMI_1:59;
    set t = j+*v;
A3: InsCode (p:=w) = 5 by Th13
      .= InsCode (dl.(S,0):=w) by Th13;
A4: IC SCM S = IC SCM by AMI_3:4,SCMRING2:9;
      dl.(S,0) = dl.0 by Def1;
then A5: dl.(S,0) <> IC SCM S by A4,AMI_3:57;
      dom (dl.(S,0).-->e) = {dl.(S,0)} by CQC_LANG:5;
then dl.(S,0) in dom (dl.(S,0).-->e) by TARSKI:def 1;
then A6: t.dl.(S,0) = (dl.(S,0) .--> e).dl.(S,0) by FUNCT_4:14
              .= e by CQC_LANG:6;
      Exec((dl.(S,0):=w), t).dl.(S,0) = w by SCMRING2:19;
    hence thesis by A2,A3,A5,A6,AMISTD_1:def 3;
  end;
end;


registration let S, p, w;
 cluster p:=w -> non jump-only;
coherence
  proof
    thus InsCode (p:=w) is not jump-only;
  end;
end;


registration let R, a, b;
 cluster a:=b -> sequential;
coherence
  proof
    let s be State of SCM R;
      Next IC s = NextLoc IC s by Th68;
    hence thesis by SCMRING2:13;
  end;
end;


registration let R, a, b;
 cluster AddTo(a,b) -> sequential;
coherence
  proof
    let s be State of SCM R;
      Next IC s = NextLoc IC s by Th68;
    hence thesis by SCMRING2:14;
  end;
end;


registration let R, a, b;
 cluster SubFrom(a,b) -> sequential;
coherence
  proof
    let s be State of SCM R;
      Next IC s = NextLoc IC s by Th68;
    hence thesis by SCMRING2:15;
  end;
end;


registration let R, a, b;
 cluster MultBy(a,b) -> sequential;
coherence
  proof
    let s be State of SCM R;
      Next IC s = NextLoc IC s by Th68;
    hence thesis by SCMRING2:16;
  end;
end;


registration let R, a, r;
 cluster a:=r -> sequential;
coherence
  proof
    let s be State of SCM R;
      Next IC s = NextLoc IC s by Th68;
    hence thesis by SCMRING2:19;
  end;
end;


registration let R, i1;
 cluster goto i1 -> non sequential;
coherence
  proof
      JUMP goto i1 <> {};
    hence thesis by AMISTD_1:43;
  end;
end;


registration let R, a, i1;
 cluster a =0_goto i1 -> non sequential;
coherence
  proof
      JUMP (a =0_goto i1) <> {};
    hence thesis by AMISTD_1:43;
  end;
end;


registration let R, i1;
 cluster goto i1 -> non ins-loc-free;
coherence
  proof
    take 1;
      dom AddressPart goto i1 = dom <*i1*> by Th30
      .= {1} by FINSEQ_1:4,def 8;
    hence 1 in dom AddressPart goto i1 by TARSKI:def 1;
    thus thesis by Th50;
  end;
end;


registration let R, a, i1;
 cluster a =0_goto i1 -> non ins-loc-free;
coherence
  proof
    take 1;
      dom AddressPart (a =0_goto i1) = dom <*i1,a*> by Th31
      .= {1,2} by FINSEQ_1:4,FINSEQ_3:29;
    hence 1 in dom AddressPart (a =0_goto i1) by TARSKI:def 2;
    thus thesis by Th51;
  end;
end;


registration let R;
 cluster SCM R -> homogeneous with_explicit_jumps without_implicit_jumps;
coherence
  proof
    thus SCM R is homogeneous
    proof
      let I, J be Instruction of SCM R such that
A1:     InsCode I = InsCode J;
A2:   J = [0,{}] or
      (ex a,b st J = a:=b) or
      (ex a,b st J = AddTo(a,b)) or
      (ex a,b st J = SubFrom(a,b)) or
      (ex a,b st J = MultBy(a,b)) or
      (ex i1 st J = goto i1) or
      (ex a,i1 st J = a=0_goto i1) or
      ex a,r st J = a:=r by SCMRING2:8;
      per cases by SCMRING2:8;
      suppose
A3:     I = [0,{}];
      then I = halt SCM R by SCMRING2:30;
      then InsCode I = 0 by Th8;
      hence thesis by A1,A2,A3,Th9,Th10,Th11,Th12,Th13,Th14,Th15;
      end;
      suppose ex a,b st I = a:=b;
      then consider a, b such that
A4:     I = a:=b;
A5:   InsCode I = 1 by A4,Th9;
        now per cases by SCMRING2:8;
        suppose J = [0,{}];
        then J = halt SCM R by SCMRING2:30;
        hence dom AddressPart I = dom AddressPart J by A1,A5,Th8;
        end;
        suppose ex a,b st J = a:=b;
        then consider d1, d2 such that
A6:       J = d1:=d2;
        thus dom AddressPart I = dom <*a,b*> by A4,Th25
          .= Seg 2 by FINSEQ_3:29
          .= dom <*d1,d2*> by FINSEQ_3:29
          .= dom AddressPart J by A6,Th25;
        end;
        suppose (ex a,b st J = AddTo(a,b)) or
                (ex a,b st J = SubFrom(a,b)) or
                (ex a,b st J = MultBy(a,b)) or
                (ex i1 st J = goto i1) or
                (ex a,i1 st J = a=0_goto i1) or
                (ex a,r st J = a:=r);
        hence dom AddressPart I = dom AddressPart J
          by A1,A5,Th10,Th11,Th12,Th13,Th14,Th15;
      end;
      end;
      hence thesis;
      end;
      suppose ex a,b st I = AddTo(a,b);
      then consider a, b such that
A7:     I = AddTo(a,b);
A8:   InsCode I = 2 by A7,Th10;
        now per cases by SCMRING2:8;
        suppose J = [0,{}];
        then J = halt SCM R by SCMRING2:30;
        hence dom AddressPart I = dom AddressPart J by A1,A8,Th8;
        end;
        suppose ex a,b st J = AddTo(a,b);
        then consider d1, d2 such that
A9:       J = AddTo(d1,d2);
        thus dom AddressPart I = dom <*a,b*> by A7,Th26
          .= Seg 2 by FINSEQ_3:29
          .= dom <*d1,d2*> by FINSEQ_3:29
          .= dom AddressPart J by A9,Th26;
        end;
        suppose (ex a,b st J = a:=b) or
                (ex a,b st J = SubFrom(a,b)) or
                (ex a,b st J = MultBy(a,b)) or
                (ex i1 st J = goto i1) or
                (ex a,i1 st J = a=0_goto i1) or
                (ex a,r st J = a:=r);
        hence dom AddressPart I = dom AddressPart J
          by A1,A8,Th9,Th11,Th12,Th13,Th14,Th15;
      end;
      end;
      hence thesis;
      end;
      suppose ex a,b st I = SubFrom(a,b);
      then consider a, b such that
A10:     I = SubFrom(a,b);
A11:   InsCode I = 3 by A10,Th11;
        now per cases by SCMRING2:8;
        suppose J = [0,{}];
        then J = halt SCM R by SCMRING2:30;
        hence dom AddressPart I = dom AddressPart J by A1,A11,Th8;
        end;
        suppose ex a,b st J = SubFrom(a,b);
        then consider d1, d2 such that
A12:       J = SubFrom(d1,d2);
        thus dom AddressPart I = dom <*a,b*> by A10,Th27
          .= Seg 2 by FINSEQ_3:29
          .= dom <*d1,d2*> by FINSEQ_3:29
          .= dom AddressPart J by A12,Th27;
        end;
        suppose (ex a,b st J = a:=b) or
                (ex a,b st J = AddTo(a,b)) or
                (ex a,b st J = MultBy(a,b)) or
                (ex i1 st J = goto i1) or
                (ex a,i1 st J = a=0_goto i1) or
                (ex a,r st J = a:=r);
        hence dom AddressPart I = dom AddressPart J
          by A1,A11,Th9,Th10,Th12,Th13,Th14,Th15;
      end;
      end;
      hence thesis;
      end;
      suppose ex a,b st I = MultBy(a,b);
      then consider a, b such that
A13:     I = MultBy(a,b);
A14:   InsCode I = 4 by A13,Th12;
        now per cases by SCMRING2:8;
        suppose J = [0,{}];
        then J = halt SCM R by SCMRING2:30;
        hence dom AddressPart I = dom AddressPart J by A1,A14,Th8;
        end;
        suppose ex a,b st J = MultBy(a,b);
        then consider d1, d2 such that
A15:       J = MultBy(d1,d2);
        thus dom AddressPart I = dom <*a,b*> by A13,Th28
          .= Seg 2 by FINSEQ_3:29
          .= dom <*d1,d2*> by FINSEQ_3:29
          .= dom AddressPart J by A15,Th28;
        end;
        suppose (ex a,b st J = a:=b) or
                (ex a,b st J = AddTo(a,b)) or
                (ex a,b st J = SubFrom(a,b)) or
                (ex i1 st J = goto i1) or
                (ex a,i1 st J = a=0_goto i1) or
                (ex a,r st J = a:=r);
        hence dom AddressPart I = dom AddressPart J
          by A1,A14,Th9,Th10,Th11,Th13,Th14,Th15;
      end;
      end;
      hence thesis;
      end;
      suppose ex i1 st I = goto i1;
      then consider i1 such that
A16:     I = goto i1;
A17:   InsCode I = 6 by A16,Th14;
        now per cases by SCMRING2:8;
        suppose J = [0,{}];
        then J = halt SCM R by SCMRING2:30;
        hence dom AddressPart I = dom AddressPart J by A1,A17,Th8;
        end;
        suppose ex i2 st J = goto i2;
        then consider i2 such that
A18:       J = goto i2;
        thus dom AddressPart I = dom <*i1*> by A16,Th30
          .= Seg 1 by FINSEQ_1:def 8
          .= dom <*i2*> by FINSEQ_1:def 8
          .= dom AddressPart J by A18,Th30;
        end;
        suppose (ex a,b st J = a:=b) or
                (ex a,b st J = AddTo(a,b)) or
                (ex a,b st J = SubFrom(a,b)) or
                (ex a,b st J = MultBy(a,b)) or
                (ex a,i1 st J = a=0_goto i1) or
                (ex a,r st J = a:=r);
        hence dom AddressPart I = dom AddressPart J
          by A1,A17,Th9,Th10,Th11,Th12,Th13,Th15;
      end;
      end;
      hence thesis;
      end;
      suppose ex a,i1 st I = a=0_goto i1;
      then consider a, i1 such that
A19:     I = a=0_goto i1;
A20:   InsCode I = 7 by A19,Th15;
        now per cases by SCMRING2:8;
        suppose J = [0,{}];
        then J = halt SCM R by SCMRING2:30;
        hence dom AddressPart I = dom AddressPart J by A1,A20,Th8;
        end;
        suppose ex d1,i2 st J = d1 =0_goto i2;
        then consider d1, i2 such that
A21:       J = d1 =0_goto i2;
        thus dom AddressPart I = dom <*i1,a*> by A19,Th31
          .= Seg 2 by FINSEQ_3:29
          .= dom <*i2,d1*> by FINSEQ_3:29
          .= dom AddressPart J by A21,Th31;
        end;
        suppose (ex a,b st J = a:=b) or
                (ex a,b st J = AddTo(a,b)) or
                (ex a,b st J = SubFrom(a,b)) or
                (ex a,b st J = MultBy(a,b)) or
                (ex i1 st J = goto i1) or
                (ex a,r st J = a:=r);
        hence dom AddressPart I = dom AddressPart J
          by A1,A20,Th9,Th10,Th11,Th12,Th13,Th14;
      end;
      end;
      hence thesis;
      end;
      suppose ex a,r st I = a:=r;
      then consider a, r such that
A22:     I = a:=r;
A23:   InsCode I = 5 by A22,Th13;
        now per cases by SCMRING2:8;
        suppose J = [0,{}];
        then J = halt SCM R by SCMRING2:30;
        hence dom AddressPart I = dom AddressPart J by A1,A23,Th8;
        end;
        suppose ex a,r st J = a:=r;
        then consider b being Data-Location of R,
                 r1 being Element of R such that
A24:       J = b:=r1;
        thus dom AddressPart I = dom <*a,r*> by A22,Th29
          .= Seg 2 by FINSEQ_3:29
          .= dom <*b,r1*> by FINSEQ_3:29
          .= dom AddressPart J by A24,Th29;
        end;
        suppose (ex a,b st J = a:=b) or
                (ex a,b st J = AddTo(a,b)) or
                (ex a,b st J = SubFrom(a,b)) or
                (ex a,b st J = MultBy(a,b)) or
                (ex i1 st J = goto i1) or
                (ex a,i1 st J = a =0_goto i1);
        hence dom AddressPart I = dom AddressPart J
          by A1,A23,Th9,Th10,Th11,Th12,Th14,Th15;
      end;
      end;
      hence thesis;
    end;
    end;

    thus SCM R is with_explicit_jumps
    proof
      let I be Instruction of SCM R;
      let f be set such that
A25:     f in JUMP I;
      per cases by SCMRING2:8;
      suppose
A26:     I = [0,{}];
        JUMP halt SCM R is empty;
      hence thesis by A25,A26,SCMRING2:30;
      end;
      suppose ex a,b st I = a:=b;
      then consider a, b such that
A27:     I = a:=b;
        JUMP (a:=b) is empty;
      hence thesis by A25,A27;
      end;
      suppose ex a,b st I = AddTo(a,b);
      then consider a, b such that
A28:     I = AddTo(a,b);
        JUMP AddTo(a,b) is empty;
      hence thesis by A25,A28;
      end;
      suppose ex a,b st I = SubFrom(a,b);
      then consider a, b such that
A29:     I = SubFrom(a,b);
        JUMP SubFrom(a,b) is empty;
      hence thesis by A25,A29;
      end;
      suppose ex a,b st I = MultBy(a,b);
      then consider a, b such that
A30:     I = MultBy(a,b);
        JUMP MultBy(a,b) is empty;
      hence thesis by A25,A30;
      end;
      suppose ex i1 st I = goto i1;
      then consider i1 such that
A31:     I = goto i1;
        JUMP goto i1 = {i1} by Th60;
then A32:   f = i1 by A25,A31,TARSKI:def 1;
      take 1;
A33:   AddressPart goto i1 = <*i1*> by Th30;
        dom <*i1*> = Seg 1 by FINSEQ_1:def 8;
      hence 1 in dom AddressPart I by A31,A33,FINSEQ_1:4,TARSKI:def 1;
      thus f = (AddressPart I).1 &
       (PA AddressParts InsCode I).1 = the Instruction-Locations of SCM R
        by A31,A32,A33,Th50,FINSEQ_1:def 8;
      end;
      suppose ex a,i1 st I = a=0_goto i1;
      then consider a, i1 such that
A34:     I = a=0_goto i1;
        JUMP (a=0_goto i1) = {i1} by Th63;
then A35:   f = i1 by A25,A34,TARSKI:def 1;
      take 1;
A36:   AddressPart (a=0_goto i1) = <*i1,a*> by Th31;
        dom <*i1,a*> = Seg 2 by FINSEQ_3:29;
      hence 1 in dom AddressPart I by A34,A36,FINSEQ_1:4,TARSKI:def 2;
      thus f = (AddressPart I).1 &
       (PA AddressParts InsCode I).1 = the Instruction-Locations of SCM R
        by A34,A35,A36,Th51,FINSEQ_1:61;
      end;
      suppose ex a,r st I = a:=r;
      then consider a, r such that
A37:     I = a:=r;
        JUMP (a:=r) is empty;
      hence thesis by A25,A37;
    end;
    end;

    let I be Instruction of SCM R;
    let f be set;
    given k being set such that
A38:   k in dom AddressPart I and
A39:   f = (AddressPart I).k and
A40:   (PA AddressParts InsCode I).k = the Instruction-Locations of SCM R;
A41: SCM-Data-Loc <> the Instruction-Locations of SCM R by Th4;
    per cases by SCMRING2:8;
    suppose I = [0,{}];
    then I = halt SCM R by SCMRING2:30;
    then dom AddressPart I = dom {} by Th24;
    hence thesis by A38;
    end;
    suppose ex a,b st I = a:=b;
    then consider a, b such that
A42:   I = a:=b;
      k in dom <*a,b*> by A38,A42,Th25;
    then k = 1 or k = 2 by Lm2;
    hence thesis by A40,A41,A42,Th40,Th41;
    end;
    suppose ex a,b st I = AddTo(a,b);
    then consider a, b such that
A43:   I = AddTo(a,b);
      k in dom <*a,b*> by A38,A43,Th26;
    then k = 1 or k = 2 by Lm2;
    hence thesis by A40,A41,A43,Th42,Th43;
    end;
    suppose ex a,b st I = SubFrom(a,b);
    then consider a, b such that
A44:   I = SubFrom(a,b);
      k in dom <*a,b*> by A38,A44,Th27;
    then k = 1 or k = 2 by Lm2;
    hence thesis by A40,A41,A44,Th44,Th45;
    end;
    suppose ex a,b st I = MultBy(a,b);
    then consider a, b such that
A45:   I = MultBy(a,b);
      k in dom <*a,b*> by A38,A45,Th28;
    then k = 1 or k = 2 by Lm2;
    hence thesis by A40,A41,A45,Th46,Th47;
    end;
    suppose ex i1 st I = goto i1;
    then consider i1 such that
A46:   I = goto i1;
A47: AddressPart I = <*i1*> by A46,Th30;
    then k = 1 by A38,Lm1;
then A48: f = i1 by A39,A47,FINSEQ_1:def 8;
      JUMP I = {i1} by A46,Th60;
    hence thesis by A48,TARSKI:def 1;
    end;
    suppose ex a,i1 st I = a=0_goto i1;
    then consider a, i1 such that
A49:   I = a=0_goto i1;
A50: AddressPart I = <*i1,a*> by A49,Th31;
    then k = 1 or k = 2 by A38,Lm2;
then A51: f = i1 by A39,A40,A41,A49,A50,Th52,FINSEQ_1:61;
      JUMP I = {i1} by A49,Th63;
    hence thesis by A51,TARSKI:def 1;
    end;
    suppose ex a,r st I = a:=r;
    then consider a, r such that
A52:   I = a:=r;
      k in dom <*a,r*> by A38,A52,Th29;
then A53: k = 1 or k = 2 by Lm2;
      (PA AddressParts InsCode I).2 = the carrier of R by A52,Th49;
    then (PA AddressParts InsCode I).2 <> SCM-Instr-Loc by SCMRING1:def 2;
    hence thesis by A40,A41,A52,A53,Th48,SCMRING2:def 1;
  end;
  end;
end;


registration let R;
 cluster SCM R -> regular;
coherence
  proof
    let T be InsType of SCM R;
A1: AddressParts T =
      { AddressPart I where I is Instruction of SCM R: InsCode I = T }
        by AMISTD_2:def 5;
    per cases by Lm3;
    suppose
A2:   T = 0;
    reconsider f = {} as Function;
    take f;
    thus thesis by A2,Th32,CARD_3:19;

    end;
    suppose
A3:   T = 1;
    take PA AddressParts T;
    thus AddressParts T c= product PA AddressParts T by AMISTD_2:9;
    let x be set;
    assume x in product PA AddressParts T;
    then consider f being Function such that
A4:   x = f and
A5:   dom f = dom PA AddressParts T and
A6:   for k being set st k in dom PA AddressParts T holds
        f.k in (PA AddressParts T).k by CARD_3:def 5;
A7: dom PA AddressParts T = {1,2} by A3,Th33;
then A8: 1 in dom PA AddressParts T by TARSKI:def 2;
    then f.1 in (PA AddressParts T).1 by A6;
    then f.1 in pi(AddressParts T,1) by A8,AMISTD_2:def 1;
    then consider g being Function such that
A9:   g in AddressParts T and
A10:   g.1 = f.1 by CARD_3:def 6;
A11: 2 in dom PA AddressParts T by A7,TARSKI:def 2;
    then f.2 in (PA AddressParts T).2 by A6;
    then f.2 in pi(AddressParts T,2) by A11,AMISTD_2:def 1;
    then consider h being Function such that
A12:   h in AddressParts T and
A13:   h.2 = f.2 by CARD_3:def 6;
    consider I being Instruction of SCM R such that
A14:   g = AddressPart I and
A15:   InsCode I = T by A1,A9;
    consider d1, b such that
A16:   I = d1:=b by A3,A15,Th17;
A17: g = <*d1,b*> by A14,A16,Th25;
    consider J being Instruction of SCM R such that
A18:   h = AddressPart J and
A19:   InsCode J = T by A1,A12;
    consider a, d2 such that
A20:   J = a:=d2 by A3,A19,Th17;
A21: h = <*a,d2*> by A18,A20,Th25;
A22: dom <*d1,d2*> = {1,2} by FINSEQ_1:4,FINSEQ_3:29;
      for k being set st k in {1,2} holds <*d1,d2*>.k = f.k
    proof
      let k be set;
      assume
A23:     k in {1,2};
      per cases by A23,TARSKI:def 2;
      suppose
A24:     k = 1;
        <*d1,d2*>.1 = d1 by FINSEQ_1:61
        .= f.1 by A10,A17,FINSEQ_1:61;
      hence <*d1,d2*>.k = f.k by A24;
      end;
      suppose
A25:     k = 2;
        <*d1,d2*>.2 = d2 by FINSEQ_1:61
        .= f.2 by A13,A21,FINSEQ_1:61;
      hence <*d1,d2*>.k = f.k by A25;
    end;
    end;
then A26: <*d1,d2*> = f by A5,A7,A22,FUNCT_1:9;
      InsCode (d1:=d2) = 1 & AddressPart (d1:=d2) = <*d1,d2*> by Th9,Th25;
    hence thesis by A1,A3,A4,A26;

    end;
    suppose
A27:   T = 2;
    take PA AddressParts T;
    thus AddressParts T c= product PA AddressParts T by AMISTD_2:9;
    let x be set;
    assume x in product PA AddressParts T;
    then consider f being Function such that
A28:   x = f and
A29:   dom f = dom PA AddressParts T and
A30:   for k being set st k in dom PA AddressParts T holds
        f.k in (PA AddressParts T).k by CARD_3:def 5;
A31: dom PA AddressParts T = {1,2} by A27,Th34;
then A32: 1 in dom PA AddressParts T by TARSKI:def 2;
    then f.1 in (PA AddressParts T).1 by A30;
    then f.1 in pi(AddressParts T,1) by A32,AMISTD_2:def 1;
    then consider g being Function such that
A33:   g in AddressParts T and
A34:   g.1 = f.1 by CARD_3:def 6;
A35: 2 in dom PA AddressParts T by A31,TARSKI:def 2;
    then f.2 in (PA AddressParts T).2 by A30;
    then f.2 in pi(AddressParts T,2) by A35,AMISTD_2:def 1;
    then consider h being Function such that
A36:   h in AddressParts T and
A37:   h.2 = f.2 by CARD_3:def 6;
    consider I being Instruction of SCM R such that
A38:   g = AddressPart I and
A39:   InsCode I = T by A1,A33;
    consider d1, b such that
A40:   I = AddTo(d1,b) by A27,A39,Th18;
A41: g = <*d1,b*> by A38,A40,Th26;
    consider J being Instruction of SCM R such that
A42:   h = AddressPart J and
A43:   InsCode J = T by A1,A36;
    consider a, d2 such that
A44:   J = AddTo(a,d2) by A27,A43,Th18;
A45: h = <*a,d2*> by A42,A44,Th26;
A46: dom <*d1,d2*> = {1,2} by FINSEQ_1:4,FINSEQ_3:29;
      for k being set st k in {1,2} holds <*d1,d2*>.k = f.k
    proof
      let k be set;
      assume
A47:     k in {1,2};
      per cases by A47,TARSKI:def 2;
      suppose
A48:     k = 1;
        <*d1,d2*>.1 = d1 by FINSEQ_1:61
        .= f.1 by A34,A41,FINSEQ_1:61;
      hence <*d1,d2*>.k = f.k by A48;
      end;
      suppose
A49:     k = 2;
        <*d1,d2*>.2 = d2 by FINSEQ_1:61
        .= f.2 by A37,A45,FINSEQ_1:61;
      hence <*d1,d2*>.k = f.k by A49;
    end;
    end;
then A50: <*d1,d2*> = f by A29,A31,A46,FUNCT_1:9;
      InsCode AddTo(d1,d2) = 2 & AddressPart AddTo(d1,d2) = <*d1,d2*>
      by Th10,Th26;
    hence thesis by A1,A27,A28,A50;

    end;
    suppose
A51:   T = 3;
    take PA AddressParts T;
    thus AddressParts T c= product PA AddressParts T by AMISTD_2:9;
    let x be set;
    assume x in product PA AddressParts T;
    then consider f being Function such that
A52:   x = f and
A53:   dom f = dom PA AddressParts T and
A54:   for k being set st k in dom PA AddressParts T holds
        f.k in (PA AddressParts T).k by CARD_3:def 5;
A55: dom PA AddressParts T = {1,2} by A51,Th35;
then A56: 1 in dom PA AddressParts T by TARSKI:def 2;
    then f.1 in (PA AddressParts T).1 by A54;
    then f.1 in pi(AddressParts T,1) by A56,AMISTD_2:def 1;
    then consider g being Function such that
A57:   g in AddressParts T and
A58:   g.1 = f.1 by CARD_3:def 6;
A59: 2 in dom PA AddressParts T by A55,TARSKI:def 2;
    then f.2 in (PA AddressParts T).2 by A54;
    then f.2 in pi(AddressParts T,2) by A59,AMISTD_2:def 1;
    then consider h being Function such that
A60:   h in AddressParts T and
A61:   h.2 = f.2 by CARD_3:def 6;
    consider I being Instruction of SCM R such that
A62:   g = AddressPart I and
A63:   InsCode I = T by A1,A57;
    consider d1, b such that
A64:   I = SubFrom(d1,b) by A51,A63,Th19;
A65: g = <*d1,b*> by A62,A64,Th27;
    consider J being Instruction of SCM R such that
A66:   h = AddressPart J and
A67:   InsCode J = T by A1,A60;
    consider a, d2 such that
A68:   J = SubFrom(a,d2) by A51,A67,Th19;
A69: h = <*a,d2*> by A66,A68,Th27;
A70: dom <*d1,d2*> = {1,2} by FINSEQ_1:4,FINSEQ_3:29;
      for k being set st k in {1,2} holds <*d1,d2*>.k = f.k
    proof
      let k be set;
      assume
A71:     k in {1,2};
      per cases by A71,TARSKI:def 2;
      suppose
A72:     k = 1;
        <*d1,d2*>.1 = d1 by FINSEQ_1:61
        .= f.1 by A58,A65,FINSEQ_1:61;
      hence <*d1,d2*>.k = f.k by A72;
      end;
      suppose
A73:     k = 2;
        <*d1,d2*>.2 = d2 by FINSEQ_1:61
        .= f.2 by A61,A69,FINSEQ_1:61;
      hence <*d1,d2*>.k = f.k by A73;
    end;
    end;
then A74: <*d1,d2*> = f by A53,A55,A70,FUNCT_1:9;
      InsCode SubFrom(d1,d2) = 3 & AddressPart SubFrom(d1,d2) = <*d1,d2*>
      by Th11,Th27;
    hence thesis by A1,A51,A52,A74;

    end;
    suppose
A75:   T = 4;
    take PA AddressParts T;
    thus AddressParts T c= product PA AddressParts T by AMISTD_2:9;
    let x be set;
    assume x in product PA AddressParts T;
    then consider f being Function such that
A76:   x = f and
A77:   dom f = dom PA AddressParts T and
A78:   for k being set st k in dom PA AddressParts T holds
        f.k in (PA AddressParts T).k by CARD_3:def 5;
A79: dom PA AddressParts T = {1,2} by A75,Th36;
then A80: 1 in dom PA AddressParts T by TARSKI:def 2;
    then f.1 in (PA AddressParts T).1 by A78;
    then f.1 in pi(AddressParts T,1) by A80,AMISTD_2:def 1;
    then consider g being Function such that
A81:   g in AddressParts T and
A82:   g.1 = f.1 by CARD_3:def 6;
A83: 2 in dom PA AddressParts T by A79,TARSKI:def 2;
    then f.2 in (PA AddressParts T).2 by A78;
    then f.2 in pi(AddressParts T,2) by A83,AMISTD_2:def 1;
    then consider h being Function such that
A84:   h in AddressParts T and
A85:   h.2 = f.2 by CARD_3:def 6;
    consider I being Instruction of SCM R such that
A86:   g = AddressPart I and
A87:   InsCode I = T by A1,A81;
    consider d1, b such that
A88:   I = MultBy(d1,b) by A75,A87,Th20;
A89: g = <*d1,b*> by A86,A88,Th28;
    consider J being Instruction of SCM R such that
A90:   h = AddressPart J and
A91:   InsCode J = T by A1,A84;
    consider a, d2 such that
A92:   J = MultBy(a,d2) by A75,A91,Th20;
A93: h = <*a,d2*> by A90,A92,Th28;
A94: dom <*d1,d2*> = {1,2} by FINSEQ_1:4,FINSEQ_3:29;
      for k being set st k in {1,2} holds <*d1,d2*>.k = f.k
    proof
      let k be set;
      assume
A95:     k in {1,2};
      per cases by A95,TARSKI:def 2;
      suppose
A96:     k = 1;
        <*d1,d2*>.1 = d1 by FINSEQ_1:61
        .= f.1 by A82,A89,FINSEQ_1:61;
      hence <*d1,d2*>.k = f.k by A96;
      end;
      suppose
A97:     k = 2;
        <*d1,d2*>.2 = d2 by FINSEQ_1:61
        .= f.2 by A85,A93,FINSEQ_1:61;
      hence <*d1,d2*>.k = f.k by A97;
    end;
    end;
then A98: <*d1,d2*> = f by A77,A79,A94,FUNCT_1:9;
      InsCode MultBy(d1,d2) = 4 & AddressPart MultBy(d1,d2) = <*d1,d2*>
      by Th12,Th28;
    hence thesis by A1,A75,A76,A98;

    end;
    suppose
A99:   T = 5;
    take PA AddressParts T;
    thus AddressParts T c= product PA AddressParts T by AMISTD_2:9;
    let x be set;
    assume x in product PA AddressParts T;
    then consider f being Function such that
A100:   x = f and
A101:   dom f = dom PA AddressParts T and
A102:   for k being set st k in dom PA AddressParts T holds
        f.k in (PA AddressParts T).k by CARD_3:def 5;
A103: dom PA AddressParts T = {1,2} by A99,Th37;
then A104: 1 in dom PA AddressParts T by TARSKI:def 2;
    then f.1 in (PA AddressParts T).1 by A102;
    then f.1 in pi(AddressParts T,1) by A104,AMISTD_2:def 1;
    then consider g being Function such that
A105:   g in AddressParts T and
A106:   g.1 = f.1 by CARD_3:def 6;
A107: 2 in dom PA AddressParts T by A103,TARSKI:def 2;
    then f.2 in (PA AddressParts T).2 by A102;
    then f.2 in pi(AddressParts T,2) by A107,AMISTD_2:def 1;
    then consider h being Function such that
A108:   h in AddressParts T and
A109:   h.2 = f.2 by CARD_3:def 6;
    consider I being Instruction of SCM R such that
A110:   g = AddressPart I and
A111:   InsCode I = T by A1,A105;
    consider d1, r such that
A112:   I = d1:=r by A99,A111,Th21;
A113: g = <*d1,r*> by A110,A112,Th29;
    consider J being Instruction of SCM R such that
A114:   h = AddressPart J and
A115:   InsCode J = T by A1,A108;
    consider a being Data-Location of R,
             r2 being Element of R such that
A116:   J = a:=r2 by A99,A115,Th21;
A117: h = <*a,r2*> by A114,A116,Th29;
A118: dom <*d1,r2*> = {1,2} by FINSEQ_1:4,FINSEQ_3:29;
      for k being set st k in {1,2} holds <*d1,r2*>.k = f.k
    proof
      let k be set;
      assume
A119:     k in {1,2};
      per cases by A119,TARSKI:def 2;
      suppose
A120:     k = 1;
        <*d1,r2*>.1 = d1 by FINSEQ_1:61
        .= f.1 by A106,A113,FINSEQ_1:61;
      hence <*d1,r2*>.k = f.k by A120;
      end;
      suppose
A121:     k = 2;
        <*d1,r2*>.2 = r2 by FINSEQ_1:61
        .= f.2 by A109,A117,FINSEQ_1:61;
      hence <*d1,r2*>.k = f.k by A121;
    end;
    end;
then A122: <*d1,r2*> = f by A101,A103,A118,FUNCT_1:9;
      InsCode (d1:=r2) = 5 & AddressPart (d1:=r2) = <*d1,r2*> by Th13,Th29;
    hence thesis by A1,A99,A100,A122;

    end;
    suppose
A123:   T = 6;
    take PA AddressParts T;
    thus AddressParts T c= product PA AddressParts T by AMISTD_2:9;
    let x be set;
    assume x in product PA AddressParts T;
    then consider f being Function such that
A124:   x = f and
A125:   dom f = dom PA AddressParts T and
A126:   for k being set st k in dom PA AddressParts T holds
        f.k in (PA AddressParts T).k by CARD_3:def 5;
A127: dom PA AddressParts T = {1} by A123,Th38;
then A128: 1 in dom PA AddressParts T by TARSKI:def 1;
    then f.1 in (PA AddressParts T).1 by A126;
    then f.1 in pi(AddressParts T,1) by A128,AMISTD_2:def 1;
    then consider g being Function such that
A129:   g in AddressParts T and
A130:   g.1 = f.1 by CARD_3:def 6;
    consider I being Instruction of SCM R such that
A131:   g = AddressPart I and
A132:   InsCode I = T by A1,A129;
    consider i1 such that
A133:   I = goto i1 by A123,A132,Th22;
A134: dom <*i1*> = {1} by FINSEQ_1:4,def 8;
      for k being set st k in {1} holds <*i1*>.k = f.k
    proof
      let k be set;
      assume k in {1};
then k = 1 by TARSKI:def 1;
      hence <*i1*>.k = f.k by A130,A131,A133,Th30;
    end;
then A135: <*i1*> = f by A125,A127,A134,FUNCT_1:9;
      InsCode goto i1 = 6 & AddressPart goto i1 = <*i1*> by Th14,Th30;
    hence thesis by A1,A123,A124,A135;

    end;
    suppose
A136:   T = 7;
    take PA AddressParts T;
    thus AddressParts T c= product PA AddressParts T by AMISTD_2:9;
    let x be set;
    assume x in product PA AddressParts T;
    then consider f being Function such that
A137:   x = f and
A138:   dom f = dom PA AddressParts T and
A139:   for k being set st k in dom PA AddressParts T holds
        f.k in (PA AddressParts T).k by CARD_3:def 5;
A140: dom PA AddressParts T = {1,2} by A136,Th39;
then A141: 1 in dom PA AddressParts T by TARSKI:def 2;
    then f.1 in (PA AddressParts T).1 by A139;
    then f.1 in pi(AddressParts T,1) by A141,AMISTD_2:def 1;
    then consider g being Function such that
A142:   g in AddressParts T and
A143:   g.1 = f.1 by CARD_3:def 6;
A144: 2 in dom PA AddressParts T by A140,TARSKI:def 2;
    then f.2 in (PA AddressParts T).2 by A139;
    then f.2 in pi(AddressParts T,2) by A144,AMISTD_2:def 1;
    then consider h being Function such that
A145:   h in AddressParts T and
A146:   h.2 = f.2 by CARD_3:def 6;
    consider I being Instruction of SCM R such that
A147:   g = AddressPart I and
A148:   InsCode I = T by A1,A142;
    consider d1, i1 such that
A149:   I = d1 =0_goto i1 by A136,A148,Th23;
A150: g = <*i1,d1*> by A147,A149,Th31;
    consider J being Instruction of SCM R such that
A151:   h = AddressPart J and
A152:   InsCode J = T by A1,A145;
    consider d2, i2 such that
A153:   J = d2 =0_goto i2 by A136,A152,Th23;
A154: h = <*i2,d2*> by A151,A153,Th31;
A155: dom <*i1,d2*> = {1,2} by FINSEQ_1:4,FINSEQ_3:29;
      for k being set st k in {1,2} holds <*i1,d2*>.k = f.k
    proof
      let k be set;
      assume
A156:     k in {1,2};
      per cases by A156,TARSKI:def 2;
      suppose
A157:     k = 1;
        <*i1,d2*>.1 = i1 by FINSEQ_1:61
        .= f.1 by A143,A150,FINSEQ_1:61;
      hence <*i1,d2*>.k = f.k by A157;
      end;
      suppose
A158:     k = 2;
        <*i1,d2*>.2 = d2 by FINSEQ_1:61
        .= f.2 by A146,A154,FINSEQ_1:61;
      hence <*i1,d2*>.k = f.k by A158;
    end;
    end;
then A159: <*i1,d2*> = f by A138,A140,A155,FUNCT_1:9;
      InsCode (d2 =0_goto i1) = 7 & AddressPart (d2 =0_goto i1) = <*i1,d2*>
      by Th15,Th31;
    hence thesis by A1,A136,A137,A159;
  end;
  end;
end;


theorem :: SCMRING3:69
 IncAddr(goto i1,k) = goto il.(SCM R, locnum i1 + k);

theorem :: SCMRING3:70
 IncAddr(a=0_goto i1,k) = a=0_goto il.(SCM R, locnum i1 + k);

registration let R;
 cluster SCM R -> IC-good Exec-preserving;
coherence
  proof
    thus SCM R is IC-good
    proof
      let I be Instruction of SCM R;
      per cases by SCMRING2:8;
      suppose I = [0,{}];
      then I = halt SCM R by SCMRING2:30;
      hence thesis;
      end;
      suppose ex a,b st I = a:=b;
      then consider a, b such that
A1:     I = a:=b;
      thus thesis by A1;
      end;
      suppose ex a,b st I = AddTo(a,b);
      then consider a, b such that
A2:     I = AddTo(a,b);
      thus thesis by A2;
      end;
      suppose ex a,b st I = SubFrom(a,b);
      then consider a, b such that
A3:     I = SubFrom(a,b);
      thus thesis by A3;
      end;
      suppose ex a,b st I = MultBy(a,b);
      then consider a, b such that
A4:     I = MultBy(a,b);
      thus thesis by A4;
      end;
      suppose ex i1 st I = goto i1;
      then consider i1 such that
A5:     I = goto i1;
      let k be natural number,
          s1, s2 be State of SCM R such that
          s2 = s1 +* (IC SCM R .--> (IC s1 + k));
A6:   IC Exec(I,s1) = Exec(I,s1).IC SCM R by AMI_1:def 15
        .= i1 by A5,SCMRING2:17;
      thus IC Exec(I,s1) + k
         = il.(SCM R, locnum IC Exec(I,s1) + k) by AMISTD_1:def 14
        .= Exec(goto il.(SCM R, locnum i1 + k),s2).IC SCM R by A6,SCMRING2:17
        .= IC Exec(goto il.(SCM R, locnum i1 + k),s2) by AMI_1:def 15
        .= IC Exec(IncAddr(I,k), s2) by A5,Th69;
      end;
      suppose ex a,i1 st I = a=0_goto i1;
      then consider a, i1 such that
A7:     I = a=0_goto i1;
      let k be natural number,
          s1, s2 be State of SCM R such that
A8:     s2 = s1 +* (IC SCM R .--> (IC s1 + k));
A9:   a <> IC SCM R by Th3;
        dom (IC SCM R .--> (IC s1 + k)) = {IC SCM R} by CQC_LANG:5;
      then not a in dom (IC SCM R .--> (IC s1 + k)) by A9,TARSKI:def 1;
then A10:   s1.a = s2.a by A8,FUNCT_4:12;
        now per cases;
        suppose
A11:       s1.a = 0.R;
A12:     IC Exec(I,s1) = Exec(I,s1).IC SCM R by AMI_1:def 15
          .= i1 by A7,A11,SCMRING2:18;
        thus IC Exec(I,s1) + k
           = il.(SCM R, locnum IC Exec(I,s1) + k) by AMISTD_1:def 14
          .= Exec(a=0_goto il.(SCM R, locnum i1 + k),s2).IC SCM R
             by A10,A11,A12,SCMRING2:18
          .= IC Exec(a=0_goto il.(SCM R, locnum i1 + k),s2) by AMI_1:def 15
          .= IC Exec(IncAddr(I,k), s2) by A7,Th70;
        end;
        suppose
A13:       s1.a <> 0.R;
          dom (IC SCM R .--> (IC s1 + k)) = {IC SCM R} by CQC_LANG:5;
then A14:     IC SCM R in dom (IC SCM R .--> (IC s1 + k)) by TARSKI:def 1;
A15:     IC s2 = s2.IC SCM R by AMI_1:def 15
             .= (IC SCM R .--> (IC s1 + k)).IC SCM R by A8,A14,FUNCT_4:14
             .= IC s1 + k by CQC_LANG:6
             .= il.(SCM R,locnum IC s1 + k) by AMISTD_1:def 14;
A16:     IC Exec(I, s2) = Exec(I, s2).IC SCM R by AMI_1:def 15
          .= Next IC s2 by A7,A10,A13,SCMRING2:18
          .= NextLoc IC s2 by Th68
          .= il.(SCM R,locnum IC s1 + k) + 1 by A15,AMISTD_1:def 15
          .= il.(SCM R,locnum il.(SCM R,locnum IC s1 + k) + 1)
             by AMISTD_1:def 14
          .= il.(SCM R,locnum IC s1 + k + 1) by AMISTD_1:def 13
          .= il.(SCM R,locnum IC s1 + 1 + k) by XCMPLX_1:1;
A17:     IC Exec(I,s1) = Exec(I,s1).IC SCM R by AMI_1:def 15
          .= Next IC s1 by A7,A13,SCMRING2:18
          .= NextLoc IC s1 by Th68
          .= il.(SCM R,locnum IC s1 + 1) by AMISTD_1:34;
        thus IC Exec(I,s1) + k = il.(SCM R,locnum IC Exec(I,s1) + k)
             by AMISTD_1:def 14
          .= IC Exec(I,s2) by A16,A17,AMISTD_1:def 13
          .= Exec(I,s2).IC SCM R by AMI_1:def 15
          .= Next IC s2 by A7,A10,A13,SCMRING2:18
          .= Exec(a=0_goto il.(SCM R, locnum i1 + k),s2).IC SCM R
             by A10,A13,SCMRING2:18
          .= IC Exec(a=0_goto il.(SCM R, locnum i1 + k),s2) by AMI_1:def 15
          .= IC Exec(IncAddr(I,k), s2) by A7,Th70;
      end;
      end;
      hence thesis;
      end;
      suppose ex a,r st I = a:=r;
      then consider a, r such that
A18:     I = a:=r;
      thus thesis by A18;
    end;
    end;

    let I be Instruction of SCM R;
    let s1, s2 be State of SCM R such that
A19:   s1, s2 equal_outside the Instruction-Locations of SCM R;
A20: dom Exec(I,s1) = dom the Object-Kind of SCM R by CARD_3:18;
then A21: dom Exec(I,s1) = dom Exec(I,s2) by CARD_3:18;
A22: dom the Object-Kind of SCM R = the carrier of SCM R by FUNCT_2:def 1;
A23: dom Exec(I,s1) \ the Instruction-Locations of SCM R c= dom Exec(I,s1)
      by XBOOLE_1:36;
A24: IC s1 = IC s2 by A19,SCMFSA6A:29;
    per cases by SCMRING2:8;
    suppose I = [0,{}];
    then I = halt SCM R by SCMRING2:30;
    hence thesis by A19,AMISTD_2:def 19;
    end;
    suppose ex a,b st I = a:=b;
    then consider a, b such that
A25:   I = a:=b;
      for x being set st x in dom Exec(I,s1) \ the Instruction-Locations of SCM
R
      holds Exec(I,s1).x = Exec(I,s2).x
    proof
      let x be set;
      assume
A26:     x in dom Exec(I,s1) \ the Instruction-Locations of SCM R;
then A27:   not x in the Instruction-Locations of SCM R by XBOOLE_0:def 4;
A28:   x in dom Exec(I,s1) by A26,XBOOLE_0:def 4;
      per cases by A20,A22,A27,A28,Th5;
      suppose
A29:     x = IC SCM R;
      hence Exec(I,s1).x = Next IC s1 by A25,SCMRING2:13
         .= Exec(I,s2).x by A24,A25,A29,SCMRING2:13;
      end;
      suppose
A30:     x = a;
      hence Exec(I,s1).x = s1.b by A25,SCMRING2:13
        .= s2.b by A19,Th7
        .= Exec(I,s2).x by A25,A30,SCMRING2:13;
      end;
      suppose that
A31:     x is Data-Location of R and
A32:     x <> a;
      thus Exec(I,s1).x = s1.x by A25,A31,A32,SCMRING2:13
        .= s2.x by A19,A31,Th7
        .= Exec(I,s2).x by A25,A31,A32,SCMRING2:13;
    end;
    end;
    hence Exec(I,s1)|(dom Exec(I,s1) \ the Instruction-Locations of SCM R) =
      Exec(I,s2)|(dom Exec(I,s2) \ the Instruction-Locations of SCM R)
        by A21,A23,SCMFSA6A:9;
    end;
    suppose ex a,b st I = AddTo(a,b);
    then consider a, b such that
A33:   I = AddTo(a,b);
      for x being set st x in dom Exec(I,s1) \ the Instruction-Locations of SCM
R
      holds Exec(I,s1).x = Exec(I,s2).x
    proof
      let x be set;
      assume
A34:     x in dom Exec(I,s1) \ the Instruction-Locations of SCM R;
then A35:   not x in the Instruction-Locations of SCM R by XBOOLE_0:def 4;
A36:   x in dom Exec(I,s1) by A34,XBOOLE_0:def 4;
      per cases by A20,A22,A35,A36,Th5;
      suppose
A37:     x = IC SCM R;
      hence Exec(I,s1).x = Next IC s1 by A33,SCMRING2:14
         .= Exec(I,s2).x by A24,A33,A37,SCMRING2:14;
      end;
      suppose
A38:     x = a;
      hence Exec(I,s1).x = s1.a + s1.b by A33,SCMRING2:14
        .= s1.a + s2.b by A19,Th7
        .= s2.a + s2.b by A19,Th7
        .= Exec(I,s2).x by A33,A38,SCMRING2:14;
      end;
      suppose that
A39:     x is Data-Location of R and
A40:     x <> a;
      thus Exec(I,s1).x = s1.x by A33,A39,A40,SCMRING2:14
        .= s2.x by A19,A39,Th7
        .= Exec(I,s2).x by A33,A39,A40,SCMRING2:14;
    end;
    end;
    hence Exec(I,s1)|(dom Exec(I,s1) \ the Instruction-Locations of SCM R) =
      Exec(I,s2)|(dom Exec(I,s2) \ the Instruction-Locations of SCM R)
        by A21,A23,SCMFSA6A:9;
    end;
    suppose ex a,b st I = SubFrom(a,b);
    then consider a, b such that
A41:   I = SubFrom(a,b);
      for x being set st x in dom Exec(I,s1) \ the Instruction-Locations of SCM
R
      holds Exec(I,s1).x = Exec(I,s2).x
    proof
      let x be set;
      assume
A42:     x in dom Exec(I,s1) \ the Instruction-Locations of SCM R;
then A43:   not x in the Instruction-Locations of SCM R by XBOOLE_0:def 4;
A44:   x in dom Exec(I,s1) by A42,XBOOLE_0:def 4;
      per cases by A20,A22,A43,A44,Th5;
      suppose
A45:     x = IC SCM R;
      hence Exec(I,s1).x = Next IC s1 by A41,SCMRING2:15
         .= Exec(I,s2).x by A24,A41,A45,SCMRING2:15;
      end;
      suppose
A46:     x = a;
      hence Exec(I,s1).x = s1.a - s1.b by A41,SCMRING2:15
        .= s1.a - s2.b by A19,Th7
        .= s2.a - s2.b by A19,Th7
        .= Exec(I,s2).x by A41,A46,SCMRING2:15;
      end;
      suppose that
A47:     x is Data-Location of R and
A48:     x <> a;
      thus Exec(I,s1).x = s1.x by A41,A47,A48,SCMRING2:15
        .= s2.x by A19,A47,Th7
        .= Exec(I,s2).x by A41,A47,A48,SCMRING2:15;
    end;
    end;
    hence Exec(I,s1)|(dom Exec(I,s1) \ the Instruction-Locations of SCM R) =
      Exec(I,s2)|(dom Exec(I,s2) \ the Instruction-Locations of SCM R)
        by A21,A23,SCMFSA6A:9;
    end;
    suppose ex a,b st I = MultBy(a,b);
    then consider a, b such that
A49:   I = MultBy(a,b);
      for x being set st x in dom Exec(I,s1) \ the Instruction-Locations of SCM
R
      holds Exec(I,s1).x = Exec(I,s2).x
    proof
      let x be set;
      assume
A50:     x in dom Exec(I,s1) \ the Instruction-Locations of SCM R;
then A51:   not x in the Instruction-Locations of SCM R by XBOOLE_0:def 4;
A52:   x in dom Exec(I,s1) by A50,XBOOLE_0:def 4;
      per cases by A20,A22,A51,A52,Th5;
      suppose
A53:     x = IC SCM R;
      hence Exec(I,s1).x = Next IC s1 by A49,SCMRING2:16
         .= Exec(I,s2).x by A24,A49,A53,SCMRING2:16;
      end;
      suppose
A54:     x = a;
      hence Exec(I,s1).x = s1.a * s1.b by A49,SCMRING2:16
        .= s1.a * s2.b by A19,Th7
        .= s2.a * s2.b by A19,Th7
        .= Exec(I,s2).x by A49,A54,SCMRING2:16;
      end;
      suppose that
A55:     x is Data-Location of R and
A56:     x <> a;
      thus Exec(I,s1).x = s1.x by A49,A55,A56,SCMRING2:16
        .= s2.x by A19,A55,Th7
        .= Exec(I,s2).x by A49,A55,A56,SCMRING2:16;
    end;
    end;
    hence Exec(I,s1)|(dom Exec(I,s1) \ the Instruction-Locations of SCM R) =
      Exec(I,s2)|(dom Exec(I,s2) \ the Instruction-Locations of SCM R)
        by A21,A23,SCMFSA6A:9;
    end;
    suppose ex i1 st I = goto i1;
    then consider i1 such that
A57:   I = goto i1;
      for x being set st x in dom Exec(I,s1) \ the Instruction-Locations of SCM
R
      holds Exec(I,s1).x = Exec(I,s2).x
    proof
      let x be set;
      assume
A58:     x in dom Exec(I,s1) \ the Instruction-Locations of SCM R;
then A59:   not x in the Instruction-Locations of SCM R by XBOOLE_0:def 4;
A60:   x in dom Exec(I,s1) by A58,XBOOLE_0:def 4;
      per cases by A20,A22,A59,A60,Th5;
      suppose
A61:     x = IC SCM R;
      hence Exec(I,s1).x = i1 by A57,SCMRING2:17
         .= Exec(I,s2).x by A57,A61,SCMRING2:17;
      end;
      suppose
A62:     x is Data-Location of R;
      hence Exec(I,s1).x = s1.x by A57,SCMRING2:17
        .= s2.x by A19,A62,Th7
        .= Exec(I,s2).x by A57,A62,SCMRING2:17;
    end;
    end;
    hence Exec(I,s1)|(dom Exec(I,s1) \ the Instruction-Locations of SCM R) =
      Exec(I,s2)|(dom Exec(I,s2) \ the Instruction-Locations of SCM R)
        by A21,A23,SCMFSA6A:9;
    end;
    suppose ex a,i1 st I = a=0_goto i1;
    then consider a, i1 such that
A63:   I = a=0_goto i1;
      for x being set st x in dom Exec(I,s1) \ the Instruction-Locations of SCM
R
      holds Exec(I,s1).x = Exec(I,s2).x
    proof
      let x be set;
      assume
A64:     x in dom Exec(I,s1) \ the Instruction-Locations of SCM R;
then A65:   not x in the Instruction-Locations of SCM R by XBOOLE_0:def 4;
A66:   x in dom Exec(I,s1) by A64,XBOOLE_0:def 4;
A67:   s1.a = s2.a by A19,Th7;
      per cases by A20,A22,A65,A66,Th5;
      suppose that
A68:     x = IC SCM R and
A69:     s1.a = 0.R;
      thus Exec(I,s1).x = i1 by A63,A68,A69,SCMRING2:18
        .= Exec(I,s2).x by A63,A67,A68,A69,SCMRING2:18;
      end;
      suppose that
A70:     x = IC SCM R and
A71:     s1.a <> 0.R;
      thus Exec(I,s1).x = Next IC s1 by A63,A70,A71,SCMRING2:18
        .= Exec(I,s2).x by A24,A63,A67,A70,A71,SCMRING2:18;
      end;
      suppose
A72:     x is Data-Location of R;
      hence Exec(I,s1).x = s1.x by A63,SCMRING2:18
        .= s2.x by A19,A72,Th7
        .= Exec(I,s2).x by A63,A72,SCMRING2:18;
    end;
    end;
    hence Exec(I,s1)|(dom Exec(I,s1) \ the Instruction-Locations of SCM R) =
      Exec(I,s2)|(dom Exec(I,s2) \ the Instruction-Locations of SCM R)
        by A21,A23,SCMFSA6A:9;
    end;
    suppose ex a,r st I = a:=r;
    then consider a, r such that
A73:   I = a:=r;
      for x being set st x in dom Exec(I,s1) \ the Instruction-Locations of SCM
R
      holds Exec(I,s1).x = Exec(I,s2).x
    proof
      let x be set;
      assume
A74:     x in dom Exec(I,s1) \ the Instruction-Locations of SCM R;
then A75:   not x in the Instruction-Locations of SCM R by XBOOLE_0:def 4;
A76:   x in dom Exec(I,s1) by A74,XBOOLE_0:def 4;
      per cases by A20,A22,A75,A76,Th5;
      suppose
A77:     x = IC SCM R;
      hence Exec(I,s1).x = Next IC s1 by A73,SCMRING2:19
         .= Exec(I,s2).x by A24,A73,A77,SCMRING2:19;
      end;
      suppose
A78:     x = a;
      hence Exec(I,s1).x = r by A73,SCMRING2:19
        .= Exec(I,s2).x by A73,A78,SCMRING2:19;
      end;
      suppose that
A79:     x is Data-Location of R and
A80:     x <> a;
      thus Exec(I,s1).x = s1.x by A73,A79,A80,SCMRING2:19
        .= s2.x by A19,A79,Th7
        .= Exec(I,s2).x by A73,A79,A80,SCMRING2:19;
    end;
    end;
    hence Exec(I,s1)|(dom Exec(I,s1) \ the Instruction-Locations of SCM R) =
      Exec(I,s2)|(dom Exec(I,s2) \ the Instruction-Locations of SCM R)
        by A21,A23,SCMFSA6A:9;
  end;
  end;
end;


