:: On Cosets in Segre's Product of Partial Linear Spaces
::  by Adam Naumowicz
::
:: Received August 14, 2001
:: Copyright (c) 2001 Association of Mizar Users

environ

 vocabulary FINSEQ_1, MATRIX_2, RELAT_1, ARYTM_1, RFINSEQ, BOOLE, FUNCT_1,
      FINSEQ_4, PRALG_1, PBOOLE, MSUALG_2, RLVECT_2, FUNCT_4, PENCIL_1, CARD_3,
      INTEGRA1, SUBSET_1, PRE_TOPC, REALSET1, CARD_1, SGRAPH1, CAT_1, AMI_1,
      RELAT_2, TARSKI, PENCIL_2;
 notation TARSKI, XBOOLE_0, ZFMISC_1, SUBSET_1, XCMPLX_0, XREAL_0, NAT_1,
      RELAT_1, BINARITH, STRUCT_0, FUNCT_1, PARTFUN1, FUNCT_2, REALSET1,
      RFINSEQ, CARD_1, FINSEQ_1, CARD_3, PRE_TOPC, PBOOLE, MSUALG_1, MSUALG_2,
      PZFMISC1, TOPS_2, T_0TOPSP, GRCAT_1, PRALG_1, POLYNOM1, TOPREAL1,
      FINSEQ_4, PENCIL_1;
 constructors BINARITH, REAL_1, MSUALG_2, POLYNOM1, PZFMISC1, TOPS_2, T_0TOPSP,
      TOPGRP_1, RFINSEQ, TOPREAL1, PENCIL_1, MEMBERED;
 clusters STRUCT_0, RELSET_1, SUBSET_1, PRALG_1, FINSEQ_5, REALSET1, BORSUK_2,
      PENCIL_1, XREAL_0, ARYTM_3, TREES_9, FUNCT_2, PARTFUN1, XBOOLE_0;
 requirements REAL, BOOLE, SUBSET, NUMERALS, ARITHM;


begin :: Preliminaries on finite sequences

definition
 let D be set;
 let p be FinSequence of D;
 let i,j be Nat;
func Del(p,i,j) -> FinSequence of D equals
:: PENCIL_2:def 1
 (p|(i -' 1))^(p/^j);
end;


theorem :: PENCIL_2:1
for D being set,p being FinSequence of D,i,j being Nat
holds rng Del(p,i,j) c= rng p;

theorem :: PENCIL_2:2
for D being set,p being FinSequence of D,i,j being Nat st
i in dom p & j in dom p holds len Del(p,i,j) = len p - j + i - 1;

theorem :: PENCIL_2:3
for D being set,p being FinSequence of D,i,j being Nat st
i in dom p & j in dom p holds len Del(p,i,j) = 0 implies i=1 & j=len p;

theorem :: PENCIL_2:4
for D being set,p being FinSequence of D,i,j,k being Nat st
i in dom p & 1 <= k & k <= i-1 holds Del(p,i,j).k = p.k;

theorem :: PENCIL_2:5
for p,q being FinSequence, k being Nat holds
len p + 1 <= k implies (p^q).k=q.(k-len p);

theorem :: PENCIL_2:6
for D being set,p being FinSequence of D,i,j,k being Nat st
i in dom p & j in dom p & i <= j & i <= k & k <= len p - j + i - 1
holds Del(p,i,j).k = p.(j -'i + k + 1);

scheme :: PENCIL_2:sch 1
 FinSeqOneToOne{X,Y,D()->set,f()-> FinSequence of D(),P[set,set]}:
 ex g being one-to-one FinSequence of D() st
 X() = g.1 & Y()=g.len g & rng g c= rng f() &
 for j being Nat st 1 <= j & j < len g holds P[g.j,g.(j+1)]
provided
  X() = f().1 & Y()=f().len f() and
  for i being Nat, d1,d2 being set
 st 1 <= i & i < len f() & d1 =f().i & d2 = f().(i+1) holds P[d1,d2]
proof
    defpred Q[Nat] means
    ex f being FinSequence of D() st
    len f = $1 &
    X() = f.1 & Y() = f.(len f) &
    rng f c= rng f() &
    for i being Nat st 1 <= i & i < len f holds P[f.i,f.(i+1)];
      for i being Nat st 1 <= i & i < len f() holds P[f().i,f().(i+1)] by A2;
    then A3: ex k being Nat st Q[k] by A1;
    consider k being Nat such that
   A4: Q[k] & for n being Nat st Q[n] holds k <= n from NAT_1:sch 5(A3);
    consider g being FinSequence of D() such that
   A5: len g = k &
    X() = g.1 & Y() = g.(len g) &
    rng g c= rng f() &
    for i being Nat st 1 <= i & i < len g holds P[g.i,g.(i+1)] by A4;
      now assume not g is one-to-one; then consider x,y being set such that
   A6: x in dom g & y in dom g & g.x = g.y & x <> y by FUNCT_1:def 8;
    reconsider x,y as Nat by A6;
    per cases by A6,AXIOMS:21;
    suppose A7: x < y;
then A8:  x+1 <= y by NAT_1:38;
then A9: y - (x+1) >= 0 by SQUARE_1:12;
    set d = Del(g,x+1,y);
   A10: x+1 >= 1 by NAT_1:29;
A11: 1 <= y & y <= len g by A6,FINSEQ_3:27;
then A12: x < len g by A7,AXIOMS:22;
    then x+1 <= len g by NAT_1:38;
then A13: x+1 in dom g by A10,FINSEQ_3:27;
      1 <= x + (1-1) by A6,FINSEQ_3:27;
    then 1 <= (x+1)-1 by XCMPLX_1:29;
   then A14: X() = d.1 by A5,A13,Th4;
   A15: Y() = d.(len d)
    proof
     per cases;
     suppose A16: len d <= x;
     then len g - y + (x+1) - 1 <= x by A6,A13,Th2;
     then len g - y + x + 1 - 1 <= x by XCMPLX_1:1;
     then len g - y + x <= x by XCMPLX_1:26;
     then len g - y <= 0 by REAL_2:174;
     then len g <= y by SQUARE_1:11;
then A17: len g = y by A11,AXIOMS:21;
       now assume len d = 0;
      then x+1 = 0+1 by A6,A13,Th3;
      then x = 0 by XCMPLX_1:2;
      hence contradiction by A6,FINSEQ_3:26;
     end;
     then 0 < len d by NAT_1:19;
then A18:  0+1 <= len d by NAT_1:38;
       len d <= x+(1-1) by A16;
then len d <= (x+1)-1 by XCMPLX_1:29;
then A19:  d.len d = g.len d by A13,A18,Th4;
       x <= 0 + (x+1) - 1 by XCMPLX_1:26;
     then x <= len g - y + (x+1) - 1 by A17,XCMPLX_1:14;
     then x <= len d by A6,A13,Th2;
     hence thesis by A5,A6,A16,A17,A19,AXIOMS:21;
     end;
     suppose A20: len d > x;
A21: len d = len g - y + (x+1) - 1 by A6,A13,Th2;
       x+1 <= len d by A20,NAT_1:38;
     hence d.len d = g.(y -'(x+1) + (len g - y + (x+1) - 1) + 1)
                     by A6,A8,A13,A21,Th6
            .= g.(y - (x+1) + (len g - y + (x+1) - 1) + 1) by A8,SCMFSA_7:3
            .= g.(y - (x+1) + ((x+1) + ((len g - y) - 1)) + 1) by XCMPLX_1:29
            .= g.(y - (x+1) + ((x+1) + (((len g - y) - 1)) + 1)) by XCMPLX_1:1
            .= g.( ((x+1) + ((((len g - y) - 1)) + 1)) + (y - (x+1)))
            by XCMPLX_1:1
            .= g.( (((len g - y) - 1) + 1) + y ) by XCMPLX_1:28
            .= g.( ((len g - y) - (1 - 1)) + y ) by XCMPLX_1:37
            .= g.( len g - (y - y) ) by XCMPLX_1:37
            .= g.( len g - 0 ) by XCMPLX_1:14
            .= Y() by A5;
    end;
    end;
    A22: rng d c= rng f() &
    for i being Nat st 1 <= i & i < len d holds P[d.i,d.(i+1)]
     proof
        rng d c= rng g by Th1;
      hence rng d c= rng f() by A5,XBOOLE_1:1;
      let i be Nat;
      assume A23: 1 <= i & i < len d;
A24:  1<=i+1 by NAT_1:29;
      per cases by REAL_1:def 5;
      suppose A25: i < x;
      then i <= (x+1)-1 by XCMPLX_1:26;
then A26:   d.i = g.i by A13,A23,Th4;
        i+1 <= x by A25,NAT_1:38;
      then i+1 <= (x+1)-1 by XCMPLX_1:26;
then A27:  d.(i+1) = g.(i+1) by A13,A24,Th4;
        i < len g by A12,A25,AXIOMS:22;
      hence P[d.i,d.(i+1)] by A5,A23,A26,A27;
      end;
      suppose A28: i = x;
      then i <= (x+1)-1 by XCMPLX_1:26;
then A29:   d.i = g.y by A6,A13,A23,A28,Th4;
        now assume y=len g;
       then x < len g - len g + (x+1) - 1 by A6,A13,A23,A28,Th2;
       then x < len g - len g + ((x+1) - 1) by XCMPLX_1:29;
       then x < 0 + ((x+1) - 1) by XCMPLX_1:14;
       hence contradiction by XCMPLX_1:26;
      end;
then A30:  y < len g by A11,REAL_1:def 5;
then A31:   0 < len g - y by SQUARE_1:11;
      then 0 < len g -' y by BINARITH:def 3;
      then 0+1 <= len g -' y by NAT_1:38;
      then 1-1 <= (len g -' y) - 1 by REAL_1:49;
      then 0 <= (len g - y) - 1 by A31,BINARITH:def 3;
      then (i+1) + 0 <= (i+1) + ((len g - y) - 1) by REAL_1:55;
      then (i+1) + 0 <= (i+1) + (len g - y) - 1 by XCMPLX_1:29;
then d.(i+1) = g.(y -'(x+1) + (i+1) + 1) by A6,A8,A13,A28,Th6
             .= g.(y+1) by A8,A28,AMI_5:4;
      hence P[d.i,d.(i+1)] by A5,A11,A29,A30;
      end;
      suppose i > x;
then A32:   x+1 <= i by NAT_1:38;
        i <= len g - y + (x+1) - 1 by A6,A13,A23,Th2;
then A33:   d.i = g.(y -'(x+1) + i + 1) by A6,A8,A13,A32,Th6;
        i <= i+1 by NAT_1:29;
then A34:  x+1 <= i+1 by A32,AXIOMS:22;
A35:   len g - y >= 0 by A11,SQUARE_1:12;
        i < len g - y + (x+1) - 1 by A6,A13,A23,Th2;
      then i < len g -' y + (x+1) - 1 by A35,BINARITH:def 3;
      then i < len g -' y + x + 1 - 1 by XCMPLX_1:1;
then A36:   i < len g -' y + x by XCMPLX_1:26;
      then i+1 <= len g -' y + x by NAT_1:38;
      then i+1 <= len g -' y + x + 1 - 1 by XCMPLX_1:26;
      then i+1 <= len g - y + x + 1 - 1 by A35,BINARITH:def 3;
      then i+1 <= len g - y + (x+1) - 1 by XCMPLX_1:1;
then A37:   d.(i+1) = g.(y -'(x+1) + (i+1) + 1) by A6,A8,A13,A34,Th6
             .= g.(y -'(x+1) + i + 1 + 1) by XCMPLX_1:1;
A38:   1 <= y -'(x+1) + i + 1 by NAT_1:29;
        i < len g - y + x by A35,A36,BINARITH:def 3;
      then i - x < len g - y + x - x by REAL_1:54;
      then i - x < len g - y by XCMPLX_1:26;
      then i - x + y < len g - y + y by REAL_1:67;
      then y + (i - x) < len g - (y - y) by XCMPLX_1:37;
      then y + (i - x) < len g - 0 by XCMPLX_1:14;
      then y + i - x < len g by XCMPLX_1:29;
      then y - x - (1 - 1) + i < len g by XCMPLX_1:29;
      then y - x - 1 + 1 + i < len g by XCMPLX_1:37;
      then y - x - 1 + i + 1 < len g by XCMPLX_1:1;
      then y - (x+1) + i + 1 < len g by XCMPLX_1:36;
      then y -'(x+1) + i + 1 < len g by A9,BINARITH:def 3;
      hence P[d.i,d.(i+1)] by A5,A33,A37,A38;
     end;
     end;
      0 < --(y - x) by A7,SQUARE_1:11;
    then -(y - x) < 0 by REAL_1:66;
    then len g + - (y - x) < len g + 0 by REAL_1:67;
    then len g - (y - x) < len g by XCMPLX_0:def 8;
    then len g - y + x < len g by XCMPLX_1:37;
    then (len g - y + x) + 1 - 1 < len g by XCMPLX_1:26;
    then len g - y + (x+1) - 1 < len g by XCMPLX_1:1;
    then len d < len g by A6,A13,Th2;
    hence contradiction by A4,A5,A14,A15,A22;
    end;
    suppose A39: y < x;
then A40:  y+1 <= x by NAT_1:38;
then A41: x - (y+1) >= 0 by SQUARE_1:12;
    set d = Del(g,y+1,x);
   A42: y+1 >= 1 by NAT_1:29;
A43: 1 <= x & x <= len g by A6,FINSEQ_3:27;
then A44: y < len g by A39,AXIOMS:22;
    then y+1 <= len g by NAT_1:38;
then A45: y+1 in dom g by A42,FINSEQ_3:27;
      1 <= y + (1-1) by A6,FINSEQ_3:27;
    then 1 <= (y+1)-1 by XCMPLX_1:29;
   then A46: X() = d.1 by A5,A45,Th4;
   A47: Y() = d.(len d)
    proof
     per cases;
     suppose A48: len d <= y;
     then len g - x + (y+1) - 1 <= y by A6,A45,Th2;
     then len g - x + y + 1 - 1 <= y by XCMPLX_1:1;
     then len g - x + y <= y by XCMPLX_1:26;
     then len g - x <= 0 by REAL_2:174;
     then len g <= x by SQUARE_1:11;
then A49: len g = x by A43,AXIOMS:21;
       now assume len d = 0;
      then y+1 = 0+1 by A6,A45,Th3;
      then y = 0 by XCMPLX_1:2;
      hence contradiction by A6,FINSEQ_3:26;
     end;
     then 0 < len d by NAT_1:19;
then A50:  0+1 <= len d by NAT_1:38;
       len d <= y+(1-1) by A48;
then len d <= (y+1)-1 by XCMPLX_1:29;
then A51:  d.len d = g.len d by A45,A50,Th4;
       y <= 0 + (y+1) - 1 by XCMPLX_1:26;
     then y <= len g - x + (y+1) - 1 by A49,XCMPLX_1:14;
     then y <= len d by A6,A45,Th2;
     hence thesis by A5,A6,A48,A49,A51,AXIOMS:21;
     end;
     suppose A52: len d > y;
A53: len d = len g - x + (y+1) - 1 by A6,A45,Th2;
       y+1 <= len d by A52,NAT_1:38;
     hence d.len d = g.(x -'(y+1) + (len g - x + (y+1) - 1) + 1)
                 by A6,A40,A45,A53,Th6
            .= g.(x - (y+1) + (len g - x + (y+1) - 1) + 1) by A40,SCMFSA_7:3
            .= g.(x - (y+1) + ((y+1) + ((len g - x) - 1)) + 1) by XCMPLX_1:29
            .= g.(x - (y+1) + ((y+1) + (((len g - x) - 1)) + 1)) by XCMPLX_1:1
            .= g.( ((y+1) + ((((len g - x) - 1)) + 1)) + (x - (y+1)))
            by XCMPLX_1:1
            .= g.( (((len g - x) - 1) + 1) + x ) by XCMPLX_1:28
            .= g.( ((len g - x) - (1 - 1)) + x ) by XCMPLX_1:37
            .= g.( len g - (x - x) ) by XCMPLX_1:37
            .= g.( len g - 0 ) by XCMPLX_1:14
            .= Y() by A5;
    end;
    end;
    A54: rng d c= rng f() &
    for i being Nat st 1 <= i & i < len d holds P[d.i,d.(i+1)]
     proof
        rng d c= rng g by Th1;
      hence rng d c= rng f() by A5,XBOOLE_1:1;
      let i be Nat;
      assume A55: 1 <= i & i < len d;
A56:  1<=i+1 by NAT_1:29;
      per cases by REAL_1:def 5;
      suppose A57: i < y;
      then i <= (y+1)-1 by XCMPLX_1:26;
then A58:   d.i = g.i by A45,A55,Th4;
        i+1 <= y by A57,NAT_1:38;
      then i+1 <= (y+1)-1 by XCMPLX_1:26;
then A59:  d.(i+1) = g.(i+1) by A45,A56,Th4;
        i < len g by A44,A57,AXIOMS:22;
      hence P[d.i,d.(i+1)] by A5,A55,A58,A59;
      end;
      suppose A60: i = y;
      then i <= (y+1)-1 by XCMPLX_1:26;
then A61:   d.i = g.x by A6,A45,A55,A60,Th4;
        now assume x=len g;
       then y < len g - len g + (y+1) - 1 by A6,A45,A55,A60,Th2;
       then y < len g - len g + ((y+1) - 1) by XCMPLX_1:29;
       then y < 0 + ((y+1) - 1) by XCMPLX_1:14;
       hence contradiction by XCMPLX_1:26;
      end;
then A62:  x < len g by A43,REAL_1:def 5;
then A63:   0 < len g - x by SQUARE_1:11;
      then 0 < len g -' x by BINARITH:def 3;
      then 0+1 <= len g -' x by NAT_1:38;
      then 1-1 <= (len g -' x) - 1 by REAL_1:49;
      then 0 <= (len g - x) - 1 by A63,BINARITH:def 3;
      then (i+1) + 0 <= (i+1) + ((len g - x) - 1) by REAL_1:55;
      then (i+1) + 0 <= (i+1) + (len g - x) - 1 by XCMPLX_1:29;
then d.(i+1) = g.(x -'(y+1) + (i+1) + 1) by A6,A40,A45,A60,Th6
             .= g.(x+1) by A40,A60,AMI_5:4;
      hence P[d.i,d.(i+1)] by A5,A43,A61,A62;
      end;
      suppose i > y;
then A64:   y+1 <= i by NAT_1:38;
        i <= len g - x + (y+1) - 1 by A6,A45,A55,Th2;
then A65:   d.i = g.(x -'(y+1) + i + 1) by A6,A40,A45,A64,Th6;
        i <= i+1 by NAT_1:29;
then A66:  y+1 <= i+1 by A64,AXIOMS:22;
A67:   len g - x >= 0 by A43,SQUARE_1:12;
        i < len g - x + (y+1) - 1 by A6,A45,A55,Th2;
      then i < len g -' x + (y+1) - 1 by A67,BINARITH:def 3;
      then i < len g -' x + y + 1 - 1 by XCMPLX_1:1;
then A68:   i < len g -' x + y by XCMPLX_1:26;
      then i+1 <= len g -' x + y by NAT_1:38;
      then i+1 <= len g -' x + y + 1 - 1 by XCMPLX_1:26;
      then i+1 <= len g - x + y + 1 - 1 by A67,BINARITH:def 3;
      then i+1 <= len g - x + (y+1) - 1 by XCMPLX_1:1;
then A69:   d.(i+1) = g.(x -'(y+1) + (i+1) + 1) by A6,A40,A45,A66,Th6
             .= g.(x -'(y+1) + i + 1 + 1) by XCMPLX_1:1;
A70:   1 <= x -'(y+1) + i + 1 by NAT_1:29;
        i < len g - x + y by A67,A68,BINARITH:def 3;
      then i - y < len g - x + y - y by REAL_1:54;
      then i - y < len g - x by XCMPLX_1:26;
      then i - y + x < len g - x + x by REAL_1:67;
      then x + (i - y) < len g - (x - x) by XCMPLX_1:37;
      then x + (i - y) < len g - 0 by XCMPLX_1:14;
      then x + i - y < len g by XCMPLX_1:29;
      then x - y - (1 - 1) + i < len g by XCMPLX_1:29;
      then x - y - 1 + 1 + i < len g by XCMPLX_1:37;
      then x - y - 1 + i + 1 < len g by XCMPLX_1:1;
      then x - (y+1) + i + 1 < len g by XCMPLX_1:36;
      then x -'(y+1) + i + 1 < len g by A41,BINARITH:def 3;
      hence P[d.i,d.(i+1)] by A5,A65,A69,A70;
     end;
     end;
      0 < --(x - y) by A39,SQUARE_1:11;
    then -(x - y) < 0 by REAL_1:66;
    then len g + - (x - y) < len g + 0 by REAL_1:67;
    then len g - (x - y) < len g by XCMPLX_0:def 8;
    then len g - x + y < len g by XCMPLX_1:37;
    then (len g - x + y) + 1 - 1 < len g by XCMPLX_1:26;
    then len g - x + (y+1) - 1 < len g by XCMPLX_1:1;
    then len d < len g by A6,A45,Th2;
    hence contradiction by A4,A5,A46,A47,A54;
    end;
    end;
    hence ex f being one-to-one FinSequence of D() st
    X() = f.1 & Y() = f.(len f) &
    rng f c= rng f() &
    for i being Nat st 1 <= i & i < len f holds P[f.i,f.(i+1)] by A5;
end;

begin :: Segre cosets

theorem :: PENCIL_2:7
for I being non empty set
for A being 1-sorted-yielding ManySortedSet of I
for L being ManySortedSubset of Carrier A
for i being Element of I
for S being Subset of A.i holds
L+*(i,S) is ManySortedSubset of Carrier A;

definition
 let I be non empty set;
 let A be non-Trivial-yielding (TopStruct-yielding ManySortedSet of I);
mode Segre-Coset of A -> Subset of Segre_Product A means
:: PENCIL_2:def 2
 ex L being Segre-like non trivial-yielding ManySortedSubset of Carrier A st
 it = product L & L.indx(L) = [#](A.indx(L));
end;


theorem :: PENCIL_2:8
for I being non empty set
for A being non-Trivial-yielding (TopStruct-yielding ManySortedSet of I)
for B1,B2 being Segre-Coset of A st 2 c= Card(B1 /\ B2) holds B1 = B2;

definition
 let S be TopStruct;
 let X,Y be Subset of S;
pred X,Y are_joinable means
:: PENCIL_2:def 3
 ex f being FinSequence of bool the carrier of S st
 X = f.1 & Y = f.(len f) &
 (for W being Subset of S st W in rng f holds
 W is closed_under_lines strong) &
 for i being Nat st 1 <= i & i < len f holds
 2 c= Card((f.i) /\ (f.(i+1)));
end;


theorem :: PENCIL_2:9
  for S being TopStruct
for X,Y being Subset of S st
X,Y are_joinable
ex f being one-to-one FinSequence of bool the carrier of S st
(X = f.1 & Y = f.(len f) &
(for W being Subset of S st W in rng f holds
W is closed_under_lines strong) &
for i being Nat st 1 <= i & i < len f holds 2 c= Card((f.i) /\ (f.(i+1))));

theorem :: PENCIL_2:10
for S being TopStruct
for X being Subset of S st X is closed_under_lines strong
holds X,X are_joinable;

theorem :: PENCIL_2:11
for I being non empty set
for A being PLS-yielding ManySortedSet of I
for X,Y being Subset of Segre_Product A st
X is non trivial closed_under_lines strong &
Y is non trivial closed_under_lines strong & X,Y are_joinable
for X1,Y1 being Segre-like non trivial-yielding ManySortedSubset
of Carrier A st X = product X1 & Y = product Y1 holds
indx(X1) = indx(Y1) & for i being set st i <> indx(X1) holds X1.i = Y1.i;

begin :: Collineations of Segre product

theorem :: PENCIL_2:12
  for S being 1-sorted
for T being non empty 1-sorted
for f being map of S,T st f is bijective holds f" is bijective;

definition
 let S,T be TopStruct;
 let f be map of S,T;
attr f is isomorphic means
:: PENCIL_2:def 4
 f is bijective open & f" is bijective open;
end;


registration
 let S be non empty TopStruct;
cluster isomorphic map of S,S;
existence
 proof
  take f = id S;
  thus f is isomorphic
   proof
    A1: f = id the carrier of S by GRCAT_1:def 11;
    hence f is bijective;
    thus f is open;
    thus f" is bijective open by A1,TOPGRP_1:2;
   end;
 end;
end;


definition
 let S be non empty TopStruct;
mode Collineation of S is isomorphic map of S,S;
end;


definition
 let S be non empty non void TopStruct;
 let f be Collineation of S;
 let l be Block of S;
redefine func f.:l -> Block of S;
end;


definition
 let S be non empty non void TopStruct;
 let f be Collineation of S;
 let l be Block of S;
redefine func f"l -> Block of S;
end;


theorem :: PENCIL_2:13
for S being non empty TopStruct
for f being Collineation of S holds f" is Collineation of S;

theorem :: PENCIL_2:14
for S being non empty TopStruct
for f being Collineation of S
for X being Subset of S st
X is non trivial holds f.:X is non trivial;

theorem :: PENCIL_2:15
  for S being non empty TopStruct
for f being Collineation of S
for X being Subset of S st
X is non trivial holds f"X is non trivial;

theorem :: PENCIL_2:16
for S being non empty non void TopStruct
for f being Collineation of S
for X being Subset of S st
X is strong holds f.:X is strong;

theorem :: PENCIL_2:17
  for S being non empty non void TopStruct
for f being Collineation of S
for X being Subset of S st
X is strong holds f"X is strong;

theorem :: PENCIL_2:18
for S being non empty non void TopStruct
for f being Collineation of S
for X being Subset of S st
X is closed_under_lines holds
f.:X is closed_under_lines;

theorem :: PENCIL_2:19
  for S being non empty non void TopStruct
for f being Collineation of S
for X being Subset of S st
X is closed_under_lines holds f"X is closed_under_lines;

theorem :: PENCIL_2:20
for S being non empty non void TopStruct
for f being Collineation of S
for X,Y being Subset of S st
X is non trivial & Y is non trivial & X,Y are_joinable holds
f.:X,f.:Y are_joinable;

theorem :: PENCIL_2:21
  for S being non empty non void TopStruct
for f being Collineation of S
for X,Y being Subset of S st
X is non trivial & Y is non trivial & X,Y are_joinable holds
f"X,f"Y are_joinable;

theorem :: PENCIL_2:22
for I being non empty set
for A being PLS-yielding ManySortedSet of I st
for i being Element of I holds A.i is strongly_connected
for W being Subset of Segre_Product A st
W is non trivial strong closed_under_lines holds
union {Y where Y is Subset of Segre_Product A :
Y is non trivial strong closed_under_lines & W,Y are_joinable}
is Segre-Coset of A;

theorem :: PENCIL_2:23
for I being non empty set
for A being PLS-yielding ManySortedSet of I st
for i being Element of I holds A.i is strongly_connected
for B being set holds B is Segre-Coset of A iff
ex W being Subset of Segre_Product A st
W is non trivial strong closed_under_lines &
B = union {Y where Y is Subset of Segre_Product A :
           Y is non trivial strong closed_under_lines & W,Y are_joinable};

theorem :: PENCIL_2:24
for I being non empty set
for A being PLS-yielding ManySortedSet of I st
for i being Element of I holds A.i is strongly_connected
for B being Segre-Coset of A
for f being Collineation of Segre_Product A holds
f.:B is Segre-Coset of A;

theorem :: PENCIL_2:25
  for I being non empty set
for A being PLS-yielding ManySortedSet of I st
for i being Element of I holds A.i is strongly_connected
for B being Segre-Coset of A
for f being Collineation of Segre_Product A holds
f"B is Segre-Coset of A;

