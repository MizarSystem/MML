:: Introduction to Go-Board - Part II.
:: Go-Board Determined by Finite Sequence of point from ${\calE}^2_{\rm T}$
::  by Jaros{\l}aw Kotowicz and Yatsuka Nakamura
::
:: Received August 24, 1992
:: Copyright (c) 1992 Association of Mizar Users

environ

 vocabulary PRE_TOPC, EUCLID, FINSEQ_1, GOBOARD1, RELAT_1, FUNCT_1, FINSET_1,
      BOOLE, CARD_1, SEQ_2, SEQ_4, LATTICES, ARYTM_1, SQUARE_1, TOPREAL1,
      TARSKI, MCART_1, MATRIX_1, INCSP_1, TREES_1, ORDINAL2, SEQM_3, ABSVALUE,
      GOBOARD2, FINSEQ_4, ARYTM;
 notation TARSKI, XBOOLE_0, ZFMISC_1, SUBSET_1, ORDINAL1, NUMBERS, XCMPLX_0,
      XREAL_0, REAL_1, NAT_1, RELAT_1, FUNCT_1, FINSEQ_1, FINSET_1, STRUCT_0,
      PRE_TOPC, ABSVALUE, CARD_1, SQUARE_1, SEQ_4, FINSEQ_4, MATRIX_1, EUCLID,
      TOPREAL1, GOBOARD1;
 constructors SEQM_3, REAL_1, NAT_1, ABSVALUE, SQUARE_1, SEQ_4, TOPREAL1,
      GOBOARD1, FINSEQ_4, INT_1, MEMBERED, XBOOLE_0;
 clusters FUNCT_1, GOBOARD1, FINSET_1, RELSET_1, STRUCT_0, EUCLID, XREAL_0,
      FINSEQ_1, INT_1, NAT_1, MEMBERED, ZFMISC_1, XBOOLE_0;
 requirements NUMERALS, REAL, BOOLE, SUBSET, ARITHM;


begin

 reserve p,p1,p2,q for Point of TOP-REAL 2,
         f,f1,f2,g,g1,g2 for FinSequence of TOP-REAL 2,
         r,s for Real,
         v,v1,v2 for FinSequence of REAL,
         n,m,i,j,k for Nat,
         G for Go-board,
         x for set;

scheme :: GOBOARD2:sch 1
 PiLambdaD{D()-> non empty set, l()->Nat, F(set)-> Element of D()}:
 ex g being FinSequence of D() st
  len g=l() & for n st n in dom g holds g/.n=F(n)
proof
  deffunc G(Nat) = F($1);
  consider g being FinSequence of D() such that
A1: len g=l() & for n st n in Seg l() holds g.n=G(n) from FINSEQ_2:sch 1;
 take g;
 thus len g=l() by A1;
 let n; assume
A2: n in dom g;
  then n in Seg l() by A1,FINSEQ_1:def 3;
  then g.n = F(n) by A1;
 hence thesis by A2,FINSEQ_4:def 4;
end;

:::::::::::::::::::::::::::::
:: Real numbers prelimineries
:::::::::::::::::::::::::::::

theorem :: GOBOARD2:1
 for R being finite Subset of REAL holds
  R <> {} implies R is bounded_above & upper_bound(R) in R &
                             R is bounded_below & lower_bound(R) in R;

begin

canceled;

theorem :: GOBOARD2:3
for f being FinSequence
  holds 1 <= n & n+1 <= len f iff n in dom f & n+1 in dom f;

theorem :: GOBOARD2:4
for f being FinSequence
  holds 1 <= n & n+2 <= len f iff n in dom f & n+1 in dom f & n+2 in dom f;

theorem :: GOBOARD2:5
 for D being non empty set, f1,f2 being FinSequence of D, n
  st 1 <= n & n <= len f2 holds (f1^f2)/.(n + len f1) = f2/.n;

theorem :: GOBOARD2:6
  (for n,m st m>n+1 & n in dom f & n+1 in dom f & m in dom f & m+1 in dom f
holds
  LSeg(f,n) misses LSeg(f,m)) implies f is s.n.c.;

theorem :: GOBOARD2:7
   f is unfolded s.n.c. one-to-one &
  f/.len f in LSeg(f,i) & i in dom f & i+1 in dom f implies i+1=len f;

theorem :: GOBOARD2:8
k<>0 & len f = k+1 implies L~f = L~(f|k) \/ LSeg(f,k);

theorem :: GOBOARD2:9
   1 < k & len f = k+1 & f is unfolded s.n.c. implies
  L~(f|k) /\ LSeg(f,k) = {f/.k};

theorem :: GOBOARD2:10
  len f1 < n & n+1 <= len (f1^f2) & m+len f1 = n implies
LSeg(f1^f2,n) = LSeg(f2,m);

theorem :: GOBOARD2:11
L~f c= L~(f^g);

theorem :: GOBOARD2:12
   f is s.n.c. implies f|i is s.n.c.;

theorem :: GOBOARD2:13
   f1 is special & f2 is special &
  ((f1/.len f1)`1=(f2/.1)`1 or (f1/.len f1)`2=(f2/.1)`2) implies
     f1^f2 is special;

theorem :: GOBOARD2:14
f <> {} implies X_axis(f) <> {};

theorem :: GOBOARD2:15
f <> {} implies Y_axis(f) <> {};

registration let f be non empty FinSequence of TOP-REAL 2;
 cluster X_axis f -> non empty;
 coherence by Th14;
 cluster Y_axis f -> non empty;
 coherence by Th15;
end;


theorem :: GOBOARD2:16
 f is special implies
for n st n in dom f & n+1 in dom f holds
 for i,j,m,k st [i,j] in Indices G & [m,k] in Indices G & f/.n=G*(i,j) &
                f/.(n+1)=G*(m,k) holds i=m or k=j;

theorem :: GOBOARD2:17
  (for n st n in dom f ex i,j st [i,j] in Indices G & f/.n=G*(i,j)) &
 f is special &
 (for n st n in dom f & n+1 in dom f holds f/.n <> f/.(n+1))
 implies
 ex g st g is_sequence_on G & L~f = L~g & g/.1=f/.1 &
        g/.len g=f/.len f & len f<=len g;

theorem :: GOBOARD2:18
  v is increasing implies
for n,m st n in dom v & m in dom v & n<=m holds v.n <= v.m;

theorem :: GOBOARD2:19
v is increasing implies
 for n,m st n in dom v & m in dom v & n<>m holds v.n<>v.m;

theorem :: GOBOARD2:20
v is increasing & v1 = v|Seg n implies v1 is increasing;

theorem :: GOBOARD2:21
 for v holds ex v1 st rng v1 = rng v & len v1 = card rng v & v1 is increasing;

theorem :: GOBOARD2:22
 for v1,v2 st len v1 = len v2 & rng v1 = rng v2 & v1 is increasing &
  v2 is increasing holds v1 = v2;

begin

::::::::::::::::::::::::
:: Proper text
::::::::::::::::::::::::

definition let v1,v2 be increasing FinSequence of REAL;
 assume  v1 <> {} & v2 <> {};
func GoB(v1,v2) -> Matrix of TOP-REAL 2 means
:: GOBOARD2:def 1
 len it = len v1 & width it = len v2 &
 for n,m st [n,m] in Indices it holds it*(n,m) = |[v1.n,v2.m]|;
end;


registration let v1,v2 be non empty increasing FinSequence of REAL;
 cluster GoB(v1,v2) -> non empty-yielding X_equal-in-line Y_equal-in-column
   Y_increasing-in-line X_increasing-in-column;
 coherence
  proof set M = GoB(v1,v2);
   A1: rng v1 c= REAL & rng v2 c= REAL & dom v1=Seg len v1 & dom v2=Seg len v2
      by FINSEQ_1:def 3,def 4;
   A2: len v1 <>0 & len v2 <> 0 by FINSEQ_1:25;
   A3: len M=len v1 & width M=len v2 by Def1;
then A4: dom M = dom v1 & width M=len v2 by FINSEQ_3:31;
then A5: Indices M=[:dom v1,Seg len v2:] by MATRIX_1:def 5;
   thus M is non empty-yielding by A2,A3,GOBOARD1:def 5;
   thus M is X_equal-in-line
    proof let n;
     reconsider l = Line(M,n) as FinSequence of TOP-REAL 2;
     set x = X_axis(l); assume
     A6: n in dom M;
     A7: len x = len l & len l = width M & dom x = Seg len x
       by FINSEQ_1:def 3,GOBOARD1:def 3,MATRIX_1:def 8;
then A8: dom x = dom l by FINSEQ_3:31;
        now let i,j; assume
       A9: i in dom x & j in dom x;
then A10:   [n,i] in Indices M & [n,j] in Indices M by A4,A5,A6,A7,ZFMISC_1:106
;
       reconsider r=v1.n, s1=v2.i, s2=v2.j as Real;
         M*(n,i)=|[r,s1]| & M*(n,j)=|[r,s2]| by A10,Def1;
       then A11: M*(n,i)`1 = r & M*(n,j)`1 = r by EUCLID:56;
         l/.i = l.i & l/.j = l.j by A8,A9,FINSEQ_4:def 4;
       then l/.i=M*(n,i) & l/.j=M*(n,j) by A7,A9,MATRIX_1:def 8;
       then x.i=r & x.j=r by A9,A11,GOBOARD1:def 3;
       hence x.i=x.j;
      end;
     hence X_axis(Line(M,n)) is constant by GOBOARD1:def 2;
    end;
   thus M is Y_equal-in-column
    proof let n;
     reconsider c = Col(M,n) as FinSequence of TOP-REAL 2;
     set y = Y_axis(c); assume
     A12: n in Seg width M;
        len y = len c & len c = len M & dom y = Seg len y
       by FINSEQ_1:def 3,GOBOARD1:def 4,MATRIX_1:def 9;
then A13:  dom y = dom c & dom c = dom M by FINSEQ_3:31;
        now let i,j; assume
       A14: i in dom y & j in dom y;
then A15: [i,n] in Indices M & [j,n] in Indices M by A4,A5,A12,A13,ZFMISC_1:106
;
       reconsider r=v2.n, s1=v1.i, s2=v1.j as Real;
         M*(i,n)=|[s1,r]| & M*(j,n)=|[s2,r]| by A15,Def1;
       then A16: M*(i,n)`2 = r & M*(j,n)`2 = r by EUCLID:56;
         c/.i = c.i & c/.j = c.j by A13,A14,FINSEQ_4:def 4;
       then c/.i=M*(i,n) & c/.j=M*(j,n) by A13,A14,MATRIX_1:def 9;
       then y.i=r & y.j=r by A14,A16,GOBOARD1:def 4;
       hence y.i=y.j;
      end;
     hence Y_axis(Col(M,n)) is constant by GOBOARD1:def 2;
    end;
   thus M is Y_increasing-in-line
    proof let n;
     reconsider l = Line(M,n) as FinSequence of TOP-REAL 2;
     set y = Y_axis(l); assume
     A17: n in dom M;
     A18: len y = len l & len l = width M & dom y = Seg len y
       by FINSEQ_1:def 3,GOBOARD1:def 4,MATRIX_1:def 8;
then A19:  dom y = dom l by FINSEQ_3:31;
        now let i,j; assume
       A20: i in dom y & j in dom y & i<j;
then A21: [n,i] in Indices M & [n,j] in Indices M
        by A4,A5,A17,A18,ZFMISC_1:106;
       reconsider r=v1.n, s1=v2.i, s2=v2.j as Real;
         M*(n,i)=|[r,s1]| & M*(n,j)=|[r,s2]| by A21,Def1;
       then A22: M*(n,i)`2 = s1 & M*(n,j)`2 = s2 by EUCLID:56;
         l/.i = l.i & l/.j = l.j by A19,A20,FINSEQ_4:def 4;
       then l/.i=M*(n,i) & l/.j=M*(n,j) by A18,A20,MATRIX_1:def 8;
       then y.i=s1 & y.j=s2 & s1<s2 by A1,A3,A18,A20,A22,GOBOARD1:def 1,def 4;
       hence y.i<y.j;
      end;
     hence Y_axis(Line(M,n)) is increasing by GOBOARD1:def 1;
    end;
   thus M is X_increasing-in-column
    proof let n;
     reconsider c = Col(M,n) as FinSequence of TOP-REAL 2;
     set x = X_axis(c); assume
     A23: n in Seg width M;
     A24: len x = len c & len c = len M & dom x = Seg len x
       by FINSEQ_1:def 3,GOBOARD1:def 3,MATRIX_1:def 9;
then A25:  dom x = dom c & dom c = dom M by FINSEQ_3:31;
        now let i,j; assume
       A26: i in dom x & j in dom x & i<j;
then A27: [i,n] in Indices M & [j,n] in Indices M by A4,A5,A23,A25,ZFMISC_1:106
;
       reconsider r=v2.n, s1=v1.i, s2=v1.j as Real;
         M*(i,n)=|[s1,r]| & M*(j,n)=|[s2,r]| by A27,Def1;
       then A28: M*(i,n)`1 = s1 & M*(j,n)`1 = s2 by EUCLID:56;
         c/.i = c.i & c/.j = c.j by A25,A26,FINSEQ_4:def 4;
       then c/.i=M*(i,n) & c/.j=M*(j,n) by A25,A26,MATRIX_1:def 9;
       then x.i=s1 & x.j=s2 & s1<s2 by A1,A3,A24,A26,A28,GOBOARD1:def 1,def 3;
       hence x.i<x.j;
      end;
     hence X_axis(Col(M,n)) is increasing by GOBOARD1:def 1;
    end;
  end;
end;


definition let v;
func Incr(v) ->increasing FinSequence of REAL means
:: GOBOARD2:def 2
rng it = rng v & len it = card rng v;
end;


definition let f be non empty FinSequence of TOP-REAL 2;
func GoB(f) -> Matrix of TOP-REAL 2 equals
:: GOBOARD2:def 3
 GoB(Incr(X_axis(f)),Incr(Y_axis(f)));
end;


theorem :: GOBOARD2:23
v <> {} implies Incr(v) <> {};

registration let v be non empty FinSequence of REAL;
 cluster Incr v -> non empty;
 coherence by Th23;
end;


registration let f be non empty FinSequence of TOP-REAL 2;
 cluster GoB(f) -> non empty-yielding X_equal-in-line Y_equal-in-column
   Y_increasing-in-line X_increasing-in-column;
 coherence
  proof
    reconsider w1 = X_axis f, w2 = Y_axis f as
         non empty FinSequence of REAL;
    reconsider v1 = Incr w1, v2 = Incr w2 as
         non empty increasing FinSequence of REAL;
      GoB(f) = GoB(v1,v2) by Def3;
   hence thesis;
  end;
end;


reserve f for non empty FinSequence of TOP-REAL 2;

theorem :: GOBOARD2:24
 len GoB(f) = card rng X_axis(f) & width GoB(f) = card rng Y_axis(f);

theorem :: GOBOARD2:25
  for n st n in dom f holds
 ex i,j st [i,j] in Indices GoB(f) & f/.n = GoB(f)*(i,j);

theorem :: GOBOARD2:26
   n in dom f &
(for m st m in dom f holds (X_axis(f)).n <= (X_axis(f)).m) implies
f/.n in rng Line(GoB(f),1);

theorem :: GOBOARD2:27
   n in dom f &
(for m st m in dom f holds (X_axis(f)).m <= (X_axis(f)).n) implies
f/.n in rng Line(GoB(f),len GoB(f));

theorem :: GOBOARD2:28
   n in dom f &
(for m st m in dom f holds (Y_axis(f)).n <= (Y_axis(f)).m) implies
f/.n in rng Col(GoB(f),1);

theorem :: GOBOARD2:29
   n in dom f &
(for m st m in dom f holds (Y_axis(f)).m <= (Y_axis(f)).n) implies
f/.n in rng Col(GoB(f),width GoB(f));
