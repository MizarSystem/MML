:: K\"onig's Lemma
::  by Grzegorz Bancerek
::
:: Received January 10, 1991
:: Copyright (c) 1991 Association of Mizar Users

environ

 vocabulary TREES_1, FUNCT_1, FINSEQ_1, ZFMISC_1, RELAT_1, BOOLE, ORDERS_1,
      ORDINAL1, TARSKI, FINSET_1, CARD_1, ARYTM_1, FUNCOP_1, TREES_2, HAHNBAN;
 notation TARSKI, XBOOLE_0, ZFMISC_1, SUBSET_1, ORDINAL1, XREAL_0, RELAT_1,
      FUNCT_1, REAL_1, NAT_1, NUMBERS, FINSEQ_1, FINSET_1, CARD_1, FUNCT_2,
      FUNCOP_1, TREES_1;
 constructors WELLORD2, REAL_1, NAT_1, FUNCOP_1, TREES_1, XREAL_0, MEMBERED,
      XBOOLE_0;
 clusters SUBSET_1, RELSET_1, FINSEQ_1, CARD_1, TREES_1, FINSET_1, FUNCOP_1,
      RELAT_1, NAT_1, XREAL_0, MEMBERED, ZFMISC_1, XBOOLE_0, NUMBERS, ORDINAL2;
 requirements NUMERALS, REAL, BOOLE, SUBSET, ARITHM;


begin

 reserve x,y,z,a,b,c,X,X1,X2,Y,Z for set,
         W,W1,W2 for Tree,
         w,w' for Element of W,
         f for Function,
         D,D' for non empty set,
         i,k,k1,k2,l,m,n for Nat,
         v,v1,v2 for FinSequence,
         p,q,r,r1,r2 for FinSequence of NAT;

theorem :: TREES_2:1
  for v1,v2,v st v1 is_a_prefix_of v & v2 is_a_prefix_of v
   holds v1,v2 are_c=-comparable;

theorem :: TREES_2:2
  for v1,v2,v st v1 is_a_proper_prefix_of v & v2 is_a_prefix_of v holds
   v1,v2 are_c=-comparable;

canceled;

theorem :: TREES_2:4
  len v1 = k+1 implies ex v2,x st v1 = v2^<*x*> & len v2 = k;

canceled;

theorem :: TREES_2:6
  ProperPrefixes (v^<*x*>) = ProperPrefixes v \/ {v};

scheme :: TREES_2:sch 1
 TreeStruct_Ind { T()->Tree, P[set] }:
 for t being Element of T() holds P[t]
  provided
 P[{}] and
 for t being Element of T(), n st P[t] & t^<*n*> in T() holds P[t^<*n*>]
proof
     defpred X[set] means
       for t being Element of T() st len t = $1 holds P[t];
A3:  X[0] by A1,FINSEQ_1:25;
A4:  X[k] implies X[k+1]
     proof assume
A5:     for t being Element of T() st len t = k holds P[t];
      let t be Element of T(); assume len t = k+1;
      then consider v, x such that
A6:     t = v^<*x*> & len v = k by Th4;
      reconsider v as FinSequence of NAT by A6,FINSEQ_1:50;
      reconsider v as Element of T() by A6,TREES_1:46;
         rng <*x*> c= rng t & rng t c= NAT by A6,FINSEQ_1:43,def 4;
       then rng <*x*> = {x} & rng <*x*> c= NAT by FINSEQ_1:56,XBOOLE_1:1;
      then reconsider x as Nat by ZFMISC_1:37;
         P[v] & x = x by A5,A6;
      hence P[t] by A2,A6;
     end;
A7:  X[k] from NAT_1:sch 1(A3,A4);
   let t be Element of T(); len t = len t;
   hence thesis by A7;
  end;

theorem :: TREES_2:7
  (for p holds p in W1 iff p in W2) implies W1 = W2;

definition let W1,W2;
 redefine pred W1 = W2 means
:: TREES_2:def 1
    for p holds p in W1 iff p in W2;
end;


theorem :: TREES_2:8
   p in W implies W = W with-replacement (p,W|p);

theorem :: TREES_2:9
  p in W & q in W & not p is_a_prefix_of q implies
   q in W with-replacement (p,W1);

theorem :: TREES_2:10
   p in W & q in W & not p,q are_c=-comparable implies
   (W with-replacement (p,W1)) with-replacement (q,W2) =
   (W with-replacement (q,W2)) with-replacement (p,W1);

definition let IT be Tree;
 attr IT is finite-order means
:: TREES_2:def 2
     ex n st for t being Element of IT holds not t^<*n*> in IT;
end;


registration
 cluster finite-order Tree;
  existence
   proof reconsider T = {{}} as Tree by TREES_1:48;
    take T,0; let t be Element of T;
       t = {} & {}^<*0*> = <*0*> & {} <> <*0*>
      by FINSEQ_1:47,TARSKI:def 1,TREES_1:4;
    hence thesis by TARSKI:def 1;
   end;
end;


definition let W;
 mode Chain of W -> Subset of W means
:: TREES_2:def 3

   for p,q st p in it & q in it holds p,q are_c=-comparable;
 mode Level of W -> Subset of W means
:: TREES_2:def 4

   ex n st it = { w: len w = n};
 let w;
 func succ w -> Subset of W equals
:: TREES_2:def 5

    { w^<*n*>: w^<*n*> in W };
end;


theorem :: TREES_2:11
   for L being Level of W holds L is AntiChain_of_Prefixes of W;

theorem :: TREES_2:12
   succ w is AntiChain_of_Prefixes of W;

theorem :: TREES_2:13
   for A being AntiChain_of_Prefixes of W, C being Chain of W
   ex w st A /\ C c= {w};

definition let W,n;
 func W-level n -> Level of W equals
:: TREES_2:def 6

    { w: len w = n };
end;


theorem :: TREES_2:14
  w^<*n*> in succ w iff w^<*n*> in W;

theorem :: TREES_2:15
   w = {} implies W-level 1 = succ w;

theorem :: TREES_2:16
    W = union { W-level n: not contradiction };

theorem :: TREES_2:17
   for W being finite Tree holds W = union { W-level n: n <= height W };

theorem :: TREES_2:18
   for L being Level of W ex n st L = W-level n;

scheme :: TREES_2:sch 2
 FraenkelCard { A() ->non empty set, X() -> set, F(set) -> set }:
 Card { F(w) where w is Element of A(): w in X() } <=` Card X()
proof
   deffunc U(set) = F($1);
   consider f such that
A1:  dom f = X() & for x st x in X() holds f.x = U(x) from FUNCT_1:sch 3;
      { F(w) where w is Element of A(): w in X() } c= rng f
     proof let x; assume x in { F(w) where w is Element of A(): w in
 X() };
      then consider w being Element of A() such that
A2:     x = F(w) & w in X();
         f.w = x by A1,A2;
      hence thesis by A1,A2,FUNCT_1:def 5;
     end;
   hence thesis by A1,CARD_1:28;
  end;

scheme :: TREES_2:sch 3
 FraenkelFinCard { A() ->non empty set,
  X,Y() -> finite set, F(set) -> set }:
 card Y() <= card X()
  provided
 Y() = { F(w) where w is Element of A(): w in X() }
proof
    deffunc U(set) = F($1);
      Card { U(w) where w is Element of A(): w in X() } <=` Card X()
        from FraenkelCard;
   hence thesis by A1,CARD_2:57;
  end;

theorem :: TREES_2:19
  W is finite-order implies ex n st for w holds
   ex B being finite set st B = succ w & card B <= n;

theorem :: TREES_2:20
  W is finite-order implies succ w is finite;

registration let W be finite-order Tree;
 let w be Element of W;
  cluster succ w -> finite;
  coherence by Th20;
end;


theorem :: TREES_2:21
  {} is Chain of W;

theorem :: TREES_2:22
  {{}} is Chain of W;

registration let W;
 cluster non empty Chain of W;
  existence
   proof
       {{}} is non empty & {{}} is Chain of W by Th22;
    hence thesis;
   end;
end;


definition let W;
  let IT be Chain of W;
 attr IT is Branch-like means
:: TREES_2:def 7

   (for p st p in IT holds ProperPrefixes p c= IT) &
   not ex p st p in W & for q st q in IT holds q is_a_proper_prefix_of p;
end;


registration let W;
 cluster Branch-like Chain of W;
  existence
   proof
    defpred X[set] means $1 is Chain of W &
      for p st p in $1 holds ProperPrefixes p c= $1;
    consider X such that
A1:   Y in X iff Y in bool W & X[Y] from XBOOLE_0:sch 1;
       {} is Chain of W &
      for p st p in {} holds ProperPrefixes p c= {}
       by Th21;
then A2:   X <> {} by A1;
       now let Z; assume that
A3:     Z <> {} & Z c= X and
A4:     Z is c=-linear;
      union Z c= W
        proof let x; assume x in union Z;
         then consider Y such that
A5:       x in Y & Y in Z by TARSKI:def 4;
            Y in bool W by A1,A3,A5;
         hence thesis by A5;
        end;
      then reconsider Z' = union Z as Subset of W;
A6:    Z' is Chain of W
        proof let p,q; assume p in Z';
         then consider X1 such that
A7:       p in X1 & X1 in Z by TARSKI:def 4;
         assume q in Z';
         then consider X2 such that
A8:       q in X2 & X2 in Z by TARSKI:def 4;
            X1,X2 are_c=-comparable & X1 in X & X2 in X
            by A3,A4,A7,A8,ORDINAL1:def 9;
          then (X1 c= X2 or X2 c= X1) & X1 in X & X2 in X by XBOOLE_0:def 9;
          then (p in X2 or q in X1) & X1 is Chain of W & X2 is Chain of W
           by A1,A7,A8;
         hence thesis by A7,A8,Def3;
        end;
         now let p; assume p in union Z;
        then consider X1 such that
A9:      p in X1 & X1 in Z by TARSKI:def 4;
           ProperPrefixes p c= X1 & X1 c= union Z by A1,A3,A9,ZFMISC_1:92;
        hence ProperPrefixes p c= union Z by XBOOLE_1:1;
       end;
      hence union Z in X by A1,A6;
     end;
    then consider Y such that
A10:  Y in X and
A11:  Z in X & Z <> Y implies not Y c= Z by A2,ORDERS_2:79;
    reconsider Y as Chain of W by A1,A10;
    take Y;
    thus for p st p in Y holds ProperPrefixes p c= Y by A1,A10;
    given p such that
A12:  p in W and
A13:  for q st q in Y holds q is_a_proper_prefix_of p;
    set Z = (ProperPrefixes p) \/ {p};
       ProperPrefixes p c= W & {p} c= W by A12,TREES_1:def 5,ZFMISC_1:37;
    then reconsider Z' = Z as Subset of W by XBOOLE_1:8;
A14:  Z' is Chain of W
      proof let q,r; assume q in Z' & r in Z';
        then (q in ProperPrefixes p or q in {p}) &
        (r in ProperPrefixes p or r in {p}) by XBOOLE_0:def 2;
        then (q is_a_proper_prefix_of p or q = p) &
        (r is_a_proper_prefix_of p or r = p) by TARSKI:def 1,TREES_1:36;
        then q is_a_prefix_of p & r is_a_prefix_of p by XBOOLE_0:def 8;
       hence thesis by Th1;
      end;
    now let q; assume q in Z;
       then q in ProperPrefixes p or q in {p} by XBOOLE_0:def 2;
       then q is_a_proper_prefix_of p or q = p by TARSKI:def 1,TREES_1:36;
       then q is_a_prefix_of p by XBOOLE_0:def 8;
       then ProperPrefixes q c= ProperPrefixes p &
       ProperPrefixes p c= Z by TREES_1:41,XBOOLE_1:7;
      hence ProperPrefixes q c= Z by XBOOLE_1:1;
     end;
then A15:  Z in X by A1,A14;
       not p is_a_proper_prefix_of p & p in {p} by TARSKI:def 1;
then A16:     not p in Y & p in Z by A13,XBOOLE_0:def 2;
       Y c= Z
      proof let x; assume
A17:     x in Y;
       then reconsider t = x as Element of W;
          t is_a_proper_prefix_of p by A13,A17;
        then t in ProperPrefixes p by TREES_1:36;
       hence thesis by XBOOLE_0:def 2;
      end;
    hence thesis by A11,A15,A16;
   end;
end;


definition let W;
 mode Branch of W is Branch-like Chain of W;
end;


registration let W;
 cluster Branch-like -> non empty Chain of W;
  coherence
   proof let B be Chain of W such that
A1:  B is Branch-like empty;
    consider t being Element of W;
       t in W & for q st q in B holds q is_a_proper_prefix_of t by A1;
    hence contradiction by A1,Def7;
   end;
end;


 reserve C for Chain of W, B for Branch of W;

theorem :: TREES_2:23
  v1 in C & v2 in C implies v1 in
 ProperPrefixes v2 or v2 is_a_prefix_of v1;

theorem :: TREES_2:24
  v1 in C & v2 in C & v is_a_prefix_of v2 implies
   v1 in ProperPrefixes v or v is_a_prefix_of v1;

registration let W;
 cluster finite Chain of W;
  existence
   proof reconsider C = {} as Chain of W by Th21;
    take C;
    thus thesis;
   end;
end;


theorem :: TREES_2:25
  for C being finite Chain of W st card C > n
     ex p st p in C & len p >= n;

theorem :: TREES_2:26
  for C holds { w: ex p st p in C & w is_a_prefix_of p } is Chain of W;

theorem :: TREES_2:27
  p is_a_prefix_of q & q in B implies p in B;

theorem :: TREES_2:28
  {} in B;

theorem :: TREES_2:29
  p in C & q in C & len p <= len q implies p is_a_prefix_of q;

theorem :: TREES_2:30
  ex B st C c= B;

scheme :: TREES_2:sch 4
 FuncExOfMinNat { P[set,Nat], X()->set }:
 ex f st dom f = X() & for x st x in X() ex n st f.x = n & P[x,n] &
   for m st P[x,m] holds n <= m
  provided
 for x st x in X() ex n st P[x,n]
proof
   defpred Q[set,set] means
    ex n st $2 = n & P[$1,n] & for m st P[$1,m] holds n <= m;
A2:  for x,y,z st x in X() & Q[x,y] & Q[x,z] holds y = z
     proof let x,y,z such that x in X(); given k such that
A3:    y = k & P[x,k] & for m st P[x,m] holds k <= m;
      given l such that
A4:    z = l & P[x,l] & for m st P[x,m] holds l <= m;
         k <= l & l <= k by A3,A4;
      hence thesis by A3,A4,AXIOMS:21;
     end;
A5:  for x st x in X() ex y st Q[x,y]
     proof let x;
       defpred X[Nat] means P[x,$1];
      assume x in X();
then A6:    ex n st X[n] by A1;
         ex n st X[n] & for m st X[m] holds n <= m from NAT_1:sch 5(A6);
      hence thesis;
     end;
   thus  ex f st dom f = X() & for x st x in X() holds Q[x,f.x]
    from FUNCT_1:sch 2(A2,A5);
  end;

scheme :: TREES_2:sch 5
 InfiniteChain { X()->set, a()->set, Q[set], P[set,set] }:
 ex f st dom f = NAT & rng f c= X() & f.0 = a() &
   for k holds P[f.k,f.(k+1)] & Q[f.k]
  provided
  a() in X() & Q[a()] and
  for x st x in X() & Q[x] ex y st y in X() & P[x,y] & Q[y]
proof
    defpred X[set] means Q[$1];
    consider Y such that
A3:   x in Y iff x in X() & X[x] from XBOOLE_0:sch 1;
      defpred X[set,set] means $2 in Y & P[$1,$2];
A4:   for x st x in Y ex y st X[x,y]
      proof let x; assume x in Y; then x in X() & Q[x] by A3;
       then consider y such that
A5:      y in X() & P[x,y] & Q[y] by A2;
       take y; thus thesis by A3,A5;
      end;
    consider g be Function such that
A6:   dom g = Y & for x st x in Y holds X[x,g.x] from ZFREFLE1:sch 1(A4);
    deffunc U(set,set) = g.$2;
    consider f such that
A7:   dom f = NAT & f.0 = a() & for n holds f.(n+1) = U(n,f.n)
       from RECDEF_1:sch 3;
    take f;
    thus dom f = NAT by A7;
    defpred X[Nat] means f.$1 in Y;
A8:  X[0] by A1,A3,A7;
A9:  X[k] implies X[k+1]
      proof assume f.k in Y;
        then g.(f.k) in Y & f.(k+1) = g.(f.k) by A6,A7;
       hence thesis;
      end;
A10: X[k] from NAT_1:sch 1(A8,A9);
    thus rng f c= X()
      proof let x; assume x in rng f;
       then consider y such that
A11:     y in dom f & x = f.y by FUNCT_1:def 5;
       reconsider y as Nat by A7,A11;
          f.y in Y by A10;
       hence thesis by A3,A11;
      end;
    thus f.0 = a() by A7;
    let k;
A12:   f.k in Y by A10;
     then g.(f.k) in Y & P[f.k,g.(f.k)] & f.(k+1) = g.(f.k) by A6,A7;
    hence P[f.k,f.(k+1)] & Q[f.k] by A3,A12;
   end;

theorem :: TREES_2:31
 for T being Tree st
   (for n ex C being finite Chain of T st card C = n) &
    for t being Element of T holds succ t is finite
   ex B being Chain of T st not B is finite;

theorem :: TREES_2:32
   for T being finite-order Tree st
  for n ex C being finite Chain of T st card C = n
   ex B being Chain of T st not B is finite;

definition let IT be Relation;
 attr IT is DecoratedTree-like means
:: TREES_2:def 8
  dom IT is Tree;
end;


registration
 cluster DecoratedTree-like Function;
  existence
   proof
    deffunc U(set) = 0;
    consider W; consider f such that
A1:   dom f = W & for x st x in W holds f.x = U(x) from FUNCT_1:sch 3;
    take f; thus dom f is Tree by A1;
   end;
end;


definition
 mode DecoratedTree is DecoratedTree-like Function;
end;


 reserve T,T1,T2 for DecoratedTree;

registration let T;
 cluster dom T -> non empty Tree-like;
  coherence by Def8;
end;


definition let X be set;
 mode ParametrizedSubset of X -> Relation means
:: TREES_2:def 9
 rng it c= X;
end;


registration let D;
 cluster DecoratedTree-like Function-like ParametrizedSubset of D;
  existence
   proof consider W; consider d being Element of D;
    deffunc U(set) = d;
    consider f such that
A1:   dom f = W & for x st x in W holds f.x = U(x) from FUNCT_1:sch 3;
    reconsider f as DecoratedTree by A1,Def8;
      f is ParametrizedSubset of D
    proof
    let x; assume x in rng f;
    then consider y such that
A2:   y in dom f & x = f.y by FUNCT_1:def 5;
       f.y = d & d in D by A1,A2;
    hence thesis by A2;
    end;
    hence thesis;
   end;
end;


definition let D;
 mode DecoratedTree of D is
    DecoratedTree-like Function-like ParametrizedSubset of D;
end;


definition let D be non empty set, T be DecoratedTree of D,
     t be Element of dom T;
 redefine func T.t -> Element of D;
end;


theorem :: TREES_2:33
 dom T1 = dom T2 & (for p st p in dom T1 holds T1.p = T2.p) implies T1 = T2;

scheme :: TREES_2:sch 6
 DTreeEx { T() -> Tree, P[set,set] }:
 ex T st dom T = T() & for p st p in T() holds P[p,T.p]
  provided
 for p st p in T() ex x st P[p,x]
proof
    defpred X[set,set] means P[$1,$2];
A2:  for x st x in T() ex y st X[x,y]
     proof let x; assume
       x in T();
      then reconsider p = x as Element of T();
         ex y st P[p,y] by A1;
      hence thesis;
     end;
   consider f such that
A3:  dom f = T() & for x st x in T() holds X[x,f.x] from ZFREFLE1:sch 1(A2);
   reconsider T = f as DecoratedTree by A3,Def8;
   take T; thus thesis by A3;
  end;

scheme :: TREES_2:sch 7
 DTreeLambda { T() -> Tree, f(set) -> set }:
 ex T st dom T = T() & for p st p in T() holds T.p = f(p)
proof
   deffunc U(set) = f($1);
   consider f such that
A1:  dom f = T() & for x st x in T() holds f.x = U(x) from FUNCT_1:sch 3;
   reconsider T = f as DecoratedTree by A1,Def8;
   take T; thus thesis by A1;
  end;

definition let T;
 func Leaves T -> set equals
:: TREES_2:def 10

  T.:Leaves dom T;
 let p;
 func T|p -> DecoratedTree means
:: TREES_2:def 11

  dom it = (dom T)|p & for q st q in (dom T)|p holds it.q = T.(p^q);
end;


theorem :: TREES_2:34
  p in dom T implies rng (T|p) c= rng T;

definition let D; let T be DecoratedTree of D;
 redefine func Leaves T -> Subset of D;
 let p be Element of dom T;
 func T|p -> DecoratedTree of D;
end;


definition let T,p,T1;
 assume
   p in dom T;
 func T with-replacement (p,T1) -> DecoratedTree means
:: TREES_2:def 12
    dom it = dom T with-replacement (p,dom T1) &
   for q st q in dom T with-replacement (p,dom T1) holds
    not p is_a_prefix_of q & it.q = T.q or
    ex r st r in dom T1 & q = p^r & it.q = T1.r;
end;


registration let W,x;
 cluster W --> x -> DecoratedTree-like;
  coherence
   proof dom (W --> x) = W by FUNCOP_1:19;
    hence thesis by Def8;
   end;
end;


definition let D be non empty set; let W; let d be Element of D;
 redefine func W --> d -> DecoratedTree of D;
end;


theorem :: TREES_2:35
  (for x st x in D holds x is Tree) implies union D is Tree;

theorem :: TREES_2:36
  (for x st x in X holds x is Function) & X is c=-linear
   implies
    union X is Relation-like Function-like;

theorem :: TREES_2:37
  (for x st x in D holds x is DecoratedTree) & D is c=-linear
   implies union D is DecoratedTree;

theorem :: TREES_2:38
  (for x st x in D' holds x is DecoratedTree of D) &
   D' is c=-linear implies
    union D' is DecoratedTree of D;

scheme :: TREES_2:sch 8
 DTreeStructEx
     { D() -> non empty set, d() -> Element of D(), F(set) -> set,
       S() -> Function of [:D(),NAT:],D()}:
 ex T being DecoratedTree of D() st T.{} = d() &
  for t being Element of dom T holds succ t = { t^<*k*>: k in F(T.t)} &
   for n,x st x = T.t & n in F(x) holds T.(t^<*n*>) = S().[x,n]
  provided
 for d being Element of D(), k1,k2 st k1 <= k2 & k2 in F(d) holds k1 in F(d)

proof   defpred P[Nat] means
    ex T being DecoratedTree of D() st T.{} = d() &
     for t being Element of dom T holds len t <= $1 &
      (len t < $1 implies succ t = { t^<*k*>: k in F(T.t)} &
       for n,x st x = T.t & n in F(x) holds T.(t^<*n*>) = S().[x,n]);
     defpred X[Nat] means P[$1];
A2:  X[0]
     proof reconsider W = {{}} as Tree by TREES_1:48;
      take T = W --> d(); {} in W by TREES_1:47;
      hence T.{} = d() by FUNCOP_1:13;
      let t be Element of dom T;
         t in dom T & dom T = W by FUNCOP_1:19;
       then t = {} by TARSKI:def 1;
      hence len t <= 0 by FINSEQ_1:25; assume len t < 0;
      hence thesis by NAT_1:18;
     end;
A3:  X[k] implies X[k+1]
     proof given T be DecoratedTree of D() such that
A4:    T.{} = d() & for t being Element of dom T holds len t <= k &
        (len t < k implies succ t = { t^<*m*>: m in F(T.t)} &
         for n,x st x = T.t & n in F(x) holds T.(t^<*n*>) = S().[x,n]);
   reconsider M
 = { t^<*n*> where t is Element of dom T: n in F(T.t) } \/ dom T
 as non empty set;
         M is Tree-like
        proof
         thus M c= NAT*
           proof let x; assume x in M;
then A5:          x in { t^<*n*> where t is Element of dom T: n in F(T.t) } or
             x in dom T & dom T c= NAT* by TREES_1:def 5,XBOOLE_0:def 2;
            assume A6:not x in NAT*;
             then ex n be Nat,t being Element of dom T st x = t^<*n*> & n in F
(T.t)
 by A5;
            hence thesis by A6,FINSEQ_1:def 11;
           end;
         thus for p st p in M holds ProperPrefixes p c= M
           proof let p; assume p in M;
then A7:          p in { t^<*n*> where t is Element of dom T: n in F(T.t) } or
             p in dom T by XBOOLE_0:def 2;
               now assume
                 p in { t^<*n*> where t is Element of dom T: n in F(T.t) };
              then consider n be Nat, t be Element of dom T such that
A8:            p = t^<*n*> & n in F(T.t);
               A9: ProperPrefixes t c= dom T & dom T c= M & t in dom T
                by TREES_1:def 5,XBOOLE_1:7;
then A10:            ProperPrefixes t c= M & t in M by XBOOLE_1:1;
                 {t} c= M & ProperPrefixes p = ProperPrefixes t \/ {t}
                by A8,A9,Th6,ZFMISC_1:37;
              hence thesis by A10,XBOOLE_1:8;
             end;
             then ProperPrefixes p c= M or ProperPrefixes p c= dom T & dom T
c= M
              by A7,TREES_1:def 5,XBOOLE_1:7;
            hence thesis by XBOOLE_1:1;
           end;
         let p,m,n; assume p^<*m*> in M;
then A11:       p^<*m*> in { t^<*l*> where t is Element of dom T: l in F(T.t) }
or
          p^<*m*> in dom T by XBOOLE_0:def 2;
         assume
A12:       n <= m & not p^<*n*> in M;
          then not p^<*n*> in dom T by XBOOLE_0:def 2;
         then consider l be Nat, t be Element of dom T such that
A13:       p^<*m*> = t^<*l*> & l in F(T.t) by A11,A12,TREES_1:def 5;
            len (p^<*m*>) = len p + len <*m*> & len <*m*> = 1 &
          len (t^<*l*>) = len t + len <*l*> & len <*l*> = 1 &
          (p^<*m*>).(len p + 1) = m & (t^<*l*>).(len t + 1) = l
           by FINSEQ_1:35,57,59;
          then p = t & n in F(T.t) by A1,A12,A13,FINSEQ_1:46;
          then p^<*n*> in { s^<*i*> where s is Element of dom T: i in F(T.s) }
;
         hence thesis by A12,XBOOLE_0:def 2;
        end;
      then reconsider M as Tree;
      defpred X[FinSequence,set] means $1 in dom T & $2 = T.$1 or
         not $1 in dom T & ex n,q st $1 = q^<*n*> & $2 = S().[T.q,n];
A14:    for p st p in M ex x st X[p,x]
        proof let p; assume p in M;
then A15:       p in { t^<*l*> where t is Element of dom T: l in F(T.t) } or
          p in dom T by XBOOLE_0:def 2;
            now assume
A16:         not p in dom T;
           then consider l be Nat, t be Element of dom T such that
A17:         p = t^<*l*> & l in F(T.t) by A15;
           take x = S().[T.t,l];
           thus p in dom T & x = T.p or
            not p in
 dom T & ex n,q st p = q^<*n*> & x = S().[T.q,n] by A16,A17;
          end;
         hence thesis;
        end;
      consider T' be DecoratedTree such that
A18:    dom T' = M & for p st p in M holds X[p,T'.p] from DTreeEx(A14);
         rng T' c= D()
        proof let x; assume x in rng T';
         then consider y such that
A19:       y in dom T' & x = T'.y by FUNCT_1:def 5;
         reconsider y as Element of dom T' by A19;
A20:       now assume
A21:         y in dom T;
           then reconsider t = y as Element of dom T;
              T.t in D() & T'.y = T.y by A18,A21;
           hence thesis by A19;
          end;
            now assume
A22:         not y in dom T;
           then consider n,q such that
A23:         y = q^<*n*> & T'.y = S().[T.q,n] by A18;
              y in { t^<*l*> where t is Element of dom T: l in F(T.t) }
             by A18,A22,XBOOLE_0:def 2;
           then consider l be Nat, t be Element of dom T such that
A24:         y = t^<*l*> & l in F(T.t);
              len <*n*> = 1 & len <*l*> = 1 by FINSEQ_1:56;
            then len (q^<*n*>) = len q + 1 & len (t^<*l*>) = len t + 1 &
            (q^<*n*>).(len q + 1) = n & (t^<*l*>).(len t + 1) = l
             by FINSEQ_1:35,59;
            then q = t & T.t in D() & n in NAT by A23,A24,FINSEQ_1:46;
            then [T.q,n] in [:D(),NAT:] by ZFMISC_1:106;
           hence x in D() by A19,A23,FUNCT_2:7;
          end;
         hence thesis by A20;
        end;
      then reconsider T' as DecoratedTree of D() by Def9;
      take T';
        <*> NAT in M & <*> NAT in dom T & {} = <*> NAT by TREES_1:47;
      hence T'. {} = d() by A4,A18;
      let t be Element of dom T';
A25:    now assume t in { s^<*l*> where s is Element of dom T: l in F(T.s) };
        then consider l be Nat, s being Element of dom T such that
A26:      t = s^<*l*> & l in F(T.s);
           len s <= k & len <*l*> = 1 by A4,FINSEQ_1:56;
         then len s + 1 <= k+1 & len s + 1 = len t by A26,FINSEQ_1:35,REAL_1:55
;
        hence len t <= k+1;
       end;
         now assume t in dom T;
        then reconsider s = t as Element of dom T;
           len s <= k & k <= k+1 by A4,NAT_1:29;
        hence len t <= k+1 by AXIOMS:22;
       end;
      hence len t <= k+1 by A18,A25,XBOOLE_0:def 2;
      assume
A27:    len t < k+1;
A28:    now assume
A29:      not t in dom T;
         then t in { s^<*l*> where s is Element of dom T: l in F(T.s) }
          by A18,XBOOLE_0:def 2;
        then consider l be Nat, s be Element of dom T such that
A30:      t = s^<*l*> & l in F(T.s);
           len t = len s + len <*l*> & len <*l*> = 1 & 0 < 1
          by A30,FINSEQ_1:35,56;
         then len s < len t & len t <= k by A27,NAT_1:38;
         then len s < k by AXIOMS:22;
         then succ s = { s^<*m*>: m in F(T.s)} by A4;
         then t in succ s & succ s c= dom T by A30;
        hence contradiction by A29;
       end;
then A31:    T'.t = T.t by A18;
      reconsider t' = t as Element of dom T by A28;
      thus succ t c= { t^<*i*>: i in F(T'.t)}
        proof let x; assume x in succ t;
          then x in { t^<*n*>: t^<*n*> in dom T' } by Def5;
         then consider n such that
A32:       x = t^<*n*> & t^<*n*> in dom T';
            now per cases;
           suppose
A33:          t^<*n*> in dom T;
            then reconsider s = t^<*n*>, t' = t as Element of dom T by TREES_1:
46
;
               len s <= k & len s = len t + 1 by A4,Lm1;
             then len t < k by NAT_1:38;
             then succ t' = { t'^<*m*>: m in F(T.t') } & t^<*n*> in succ t'
              by A4,A33,Th14;
            hence thesis by A31,A32;
           end;
           suppose not t^<*n*> in dom T;
             then t^<*n*> in { s^<*l*> where s is Element of dom T: l in F(T.s
) }
              by A18,A32,XBOOLE_0:def 2;
            then consider l be Nat, s be Element of dom T such that
A34:          t^<*n*> = s^<*l*> & l in F(T.s);
               n = l & t = s by A34,FINSEQ_2:20;
            hence thesis by A31,A32,A34;
          end;
          end;
         hence thesis;
        end;
      thus
A35:    { t^<*i*>: i in F(T'.t)} c= succ t
        proof let x; assume x in { t^<*i*>: i in F(T'.t)};
         then consider n such that
A36:       x = t^<*n*> & n in F(T'.t);
            x = t'^<*n*> by A36;
          then x in { s^<*l*> where s is Element of dom T: l in F(T.s) }
           by A31,A36;
          then x in dom T' by A18,XBOOLE_0:def 2;
         hence thesis by A36,Th14;
        end;
      let n,x; assume
A37:    x = T'.t & n in F(x);
       then t^<*n*> in { t^<*i*>: i in F(T'.t)};
then A38:   t^<*n*> in succ t by A35;
         now per cases;
        suppose
A39:       t^<*n*> in dom T;
         then reconsider s = t^<*n*> as Element of dom T;
            len s <= k & len s = len t + 1 by A4,Lm1;
          then len t' < k by NAT_1:38;
          then T.(t'^<*n*>) = S().[x,n] by A4,A31,A37;
         hence thesis by A18,A38,A39;
        end;
        suppose not t^<*n*> in dom T;
         then consider l,q such that
A40:       t^<*n*> = q^<*l*> & T'.(t^<*n*>) = S().[T.q,l] by A18,A38;
            t = q & n = l by A40,FINSEQ_2:20;
         hence thesis by A18,A28,A37,A40;
       end;
       end;
      hence T'.(t^<*n*>) = S().[x,n];
     end;
A41:  X[k] from NAT_1:sch 1(A2,A3);
      defpred X[set,set] means ex T being DecoratedTree of D(), k st
        $1 = k & $2 = T & T.{} = d() &
      for t being Element of dom T holds len t <= k &
       (len t < k implies succ t = { t^<*i*>: i in F(T.t)} &
        for n,x st x = T.t & n in F(x) holds T.(t^<*n*>) = S().[x,n]);
A42:  for x st x in NAT ex y st X[x,y]
     proof let x; assume x in NAT;
      then reconsider n = x as Nat;
      consider T being DecoratedTree of D() such that
A43:    T.{} = d() & for t being Element of dom T holds len t <= n &
        (len t < n implies succ t = { t^<*k*>: k in F(T.t)} &
         for n,x st x = T.t & n in F(x) holds T.(t^<*n*>) = S().[x,n]) by A41;
      reconsider y = T as set;
      take y,T,n; thus thesis by A43;
     end;
   consider f such that
A44:  dom f = NAT & for x st x in NAT holds X[x,f.x] from ZFREFLE1:sch 1(A42);
     reconsider E = rng f as non empty set by A44,RELAT_1:65;
A45:  for x st x in E holds x is DecoratedTree of D()
     proof let x; assume x in E;
      then consider y such that
A46:    y in dom f & x = f.y by FUNCT_1:def 5;
         ex T being DecoratedTree of D(), k st
    y = k & f.y = T & T.{} = d() &
        for t being Element of dom T holds len t <= k &
        (len t < k implies succ t = { t^<*i*>: i in F(T.t)} &
         for n,x st x = T.t & n in F(x) holds T.(t^<*n*>) = S().[x,n]) by A44,
A46;
      hence thesis by A46;
     end;
A47: for T1,T2,k1,k2 st T1 = f.k1 & T2 = f.k2 & k1 <= k2 holds
      T1 c= T2
     proof let T1,T2; let x,y be Nat such that
A48:    T1 = f.x & T2 = f.y & x <= y;
      consider T1' being DecoratedTree of D(), k1 such that
A49:    x = k1 & f.x = T1' & T1'.{} = d() &
       for t being Element of dom T1' holds len t <= k1 &
        (len t < k1 implies succ t = { t^<*i*>: i in F(T1'.t)} &
         for n,x st x = T1'.t & n in F(x) holds T1'.(t^<*n*>) = S().[x,n])
          by A44;
      consider T2' being DecoratedTree of D(), k2 such that
A50:    y = k2 & f.y = T2' & T2'.{} = d() &
       for t being Element of dom T2' holds len t <= k2 &
        (len t < k2 implies succ t = { t^<*i*>: i in F(T2'.t)} &
         for n,x st x = T2'.t & n in F(x) holds T2'.(t^<*n*>) = S().[x,n])
          by A44;
      defpred I[Nat] means
       for t being Element of dom T1 st len t <= $1 holds
        t in dom T2 & T1.t = T2.t;
A51:    I[0]
        proof let t be Element of dom T1 such that
A52:       len t <= 0; len t = 0 by A52,NAT_1:18;
          then t = {} by FINSEQ_1:25;
         hence thesis by A48,A49,A50,TREES_1:47;
        end;
A53:    I[k] implies I[k+1]
        proof assume
A54:       for t being Element of dom T1 st len t <= k holds
           t in dom T2 & T1.t = T2.t;
         let t be Element of dom T1; assume len t <= k+1;
then A55:       (len t <= k or len t = k+1) & t in dom T1 by NAT_1:26;
            now assume
A56:         len t = k+1;
           reconsider p = t|Seg k as FinSequence of NAT by FINSEQ_1:23;
              p is_a_prefix_of t & t in dom T1
             by TREES_1:def 1;
           then reconsider p as Element of dom T1 by TREES_1:45;
              k <= k+1 & k+1 <= k1 by A48,A49,A56,NAT_1:29;
then A57:         len p = k & k <= k & k < k1 by A56,FINSEQ_1:21,NAT_1:38;
then A58:         p in dom T2 & T1.p = T2.p by A54;
           reconsider p' = p as Element of dom T2 by A54,A57;
             t <> {} by A56,FINSEQ_1:25;
           then consider q being FinSequence, x being set such that
A59:         t = q^<*x*> by FINSEQ_1:63;
              p is_a_prefix_of t & q is_a_prefix_of t & k+1 = len q + 1
             by A56,A59,Lm1,TREES_1:8,def 1;
            then k = len q & p,q are_c=-comparable by Th1,XCMPLX_1:2;
then A60:         p = q by A57,TREES_1:19;
              <*x*> is FinSequence of NAT by A59,FINSEQ_1:50;
            then rng <*x*> c= NAT & rng <*x*> = {x} & x in {x}
             by FINSEQ_1:55,def 4,TARSKI:def 1;
           then reconsider x as Nat;
              p^<*x*> in succ p & succ p = { p^<*i*>: i in F(T1.p)}
             by A48,A49,A57,A59,A60,Th14;
           then consider i such that
A61:         p^<*x*> = p^<*i*> & i in F(T1.p);
A62:         k < k2 by A48,A49,A50,A57,AXIOMS:22;
            then succ p' = { p'^<*l*>: l in F(T2.p') } & x = i
             by A48,A50,A57,A61,FINSEQ_2:20;
            then T2'.t = S().[T2'.p',x] & t in succ p' & T1'.t = S().[T1'.p,x]
&
            succ p' c= dom T2 by A48,A49,A50,A57,A58,A59,A60,A61,A62;
           hence thesis by A48,A49,A50,A54,A57;
          end;
         hence thesis by A54,A55;
        end;
A63:    I[k] from NAT_1:sch 1(A51,A53);
      let x; assume
A64:    x in T1;
      then consider y,z such that
A65:    [y,z] = x by RELAT_1:def 1;
A66:    y in dom T1 & T1.y = z by A64,A65,FUNCT_1:8;
      reconsider y as Element of dom T1 by A64,A65,FUNCT_1:8;
         len y <= len y;
       then y in dom T2 & T1.y = T2.y by A63;
      hence thesis by A65,A66,FUNCT_1:8;
     end;
       E is c=-linear
     proof let T1,T2 be set; assume A67:T1 in E;
      then consider x such that
A68:    x in dom f & T1 = f.x by FUNCT_1:def 5;
      assume A69:T2 in E;
      then consider y such that
A70:    y in dom f & T2 = f.y by FUNCT_1:def 5;
A71:   T1 is DecoratedTree & T2 is DecoratedTree by A45,A67,A69;
      reconsider x,y as Nat by A44,A68,A70;
         x <= y or y <= x;
      hence T1 c= T2 or T2 c= T1 by A47,A68,A70,A71;
     end;
   then reconsider T = union rng f as DecoratedTree of D() by A45,Th38;
   take T;
   consider T' being DecoratedTree of D(), k such that
A72:  0 = k & f.0 = T' & T'.{} = d() &
     for t being Element of dom T' holds len t <= k &
      (len t < k implies succ t = { t^<*i*>: i in F(T'.t)} &
       for n,x st x = T'.t & n in F(x) holds T'.(t^<*n*>) = S().[x,n]) by A44;
      {} in dom T' by TREES_1:47;
    then [{},d()] in T' & T' = T' & T' in rng f
     by A44,A72,FUNCT_1:8,def 5;
    then [{},d()] in T by TARSKI:def 4;
   hence T.{} = d() by FUNCT_1:8;
A73:  for T1,x st T1 in E & x in dom T1 holds x in dom T & T1.x = T.x
     proof let T1,x; assume T1 in E & x in dom T1;
       then [x,T1.x] in T1 & T1 in E by FUNCT_1:8;
       then [x,T1.x] in T by TARSKI:def 4;
      hence thesis by FUNCT_1:8;
     end;
   let t be Element of dom T;
   thus succ t c= { t^<*i*>: i in F(T.t)}
     proof let x; assume x in succ t;
       then x in { t^<*i*>: t^<*i*> in dom T } by Def5;
      then consider l such that
A74:    x = t^<*l*> & t^<*l*> in dom T;
         [x,T.x] in T by A74,FUNCT_1:8;
      then consider X such that
A75:    [x,T.x] in X & X in rng f by TARSKI:def 4;
      consider y such that
A76:    y in NAT & X = f.y by A44,A75,FUNCT_1:def 5;
      consider T1 being DecoratedTree of D(), k1 such that
A77:    y = k1 & f.y = T1 & T1.{} = d() &
       for t being Element of dom T1 holds len t <= k1 &
        (len t < k1 implies succ t = { t^<*i*>: i in F(T1.t)} &
         for n,x st x = T1.t & n in F(x) holds T1.(t^<*n*>) = S().[x,n])
          by A44,A76;
A78:    t^<*l*> in dom T1 by A74,A75,A76,A77,FUNCT_1:8;
      then reconsider t' = t, p = t^<*l*> as Element of dom T1 by TREES_1:46;
         len p <= k1 by A77; then len t + 1 <= k1 by Lm1;
       then len t' < k1 by NAT_1:38;
       then succ t' = { t'^<*i*>: i in F(T1.t')} & T1.t = T.t & t'^<*l*> in
succ t'
        by A73,A75,A76,A77,A78,Th14;
      hence thesis by A74;
     end;
      [t,T.t] in T by FUNCT_1:8;
   then consider X such that
A79: [t,T.t] in X & X in E by TARSKI:def 4;
   consider y such that
A80: y in NAT & X = f.y by A44,A79,FUNCT_1:def 5;
   reconsider y as Nat by A80;
   consider T1 being DecoratedTree of D(), k1 such that
A81: y = k1 & f.y = T1 & T1.{} = d() &
    for t being Element of dom T1 holds len t <= k1 &
     (len t < k1 implies succ t = { t^<*i*>: i in F(T1.t)} &
      for n,x st x = T1.t & n in F(x) holds T1.(t^<*n*>) = S().[x,n])
       by A44;
   consider T2 being DecoratedTree of D(), k2 such that
A82: y+1 = k2 & f.(y+1) = T2 & T2.{} = d() &
    for t being Element of dom T2 holds len t <= k2 &
     (len t < k2 implies succ t = { t^<*i*>: i in F(T2.t)} &
      for n,x st x = T2.t & n in F(x) holds T2.(t^<*n*>) = S().[x,n])
       by A44;
      y <= y+1 by NAT_1:29;
then A83: T1 = X & T2 = T2 & T1 c= T2
     by A47,A80,A81,A82;
   reconsider t1 = t as Element of dom T1 by A79,A80,A81,FUNCT_1:8;
A84: len t1 <= y by A81;
A85: t in dom T2 & T2.t = T.t by A79,A83,FUNCT_1:8;
   reconsider t2 = t as Element of dom T2 by A79,A83,FUNCT_1:8;
A86: len t2 < y+1 by A84,NAT_1:38;
then A87: succ t2 = { t2^<*i*>: i in F(T2.t2)} by A82;
   thus { t^<*i*>: i in F(T.t)} c= succ t
     proof let x; assume A88: x in { t^<*i*>: i in F(T.t)};
 then A89:      ex l st x = t^<*l*> & l in F(T.t);
         x in succ t2 & succ t2 c= dom T2 by A82,A85,A86,A88;
       then x in dom T2 & T2 in E by A44,A82,FUNCT_1:def 5;
       then x in dom T by A73;
      hence thesis by A89,Th14;
     end;
   let n,x; assume
A90:  x = T.t & n in F(x);
    then t^<*n*> in succ t2 & succ t2 c= dom T2 by A85,A87;
    then t^<*n*> in dom T2 & T2 in E by A44,A82,FUNCT_1:def 5;
    then T2.(t^<*n*>) = T.(t^<*n*>) by A73;
   hence T.(t^<*n*>) = S().[x,n] by A82,A85,A86,A90;
  end;

scheme :: TREES_2:sch 9
 DTreeStructFinEx
     { D() -> non empty set, d() -> Element of D(), F(set) -> Nat,
       S() -> Function of [:D(),NAT:],D()}:
 ex T being DecoratedTree of D() st T.{} = d() &
  for t being Element of dom T holds succ t = { t^<*k*>: k < F(T.t)} &
   for n,x st x = T.t & n < F(x) holds T.(t^<*n*>) = S().[x,n]
proof   deffunc FF(Nat) = { i: i < $1};
    deffunc U(set) = FF(F($1));
A1: for d being Element of D(), k1,k2 st k1 <= k2 & k2 in U(d) holds
      k1 in U(d)
     proof let d be Element of D(), k1,k2; assume
A2:    k1 <= k2 & k2 in { i: i < F(d)};
       then ex i st k2 = i & i < F(d);
       then k1 < F(d) by A2,AXIOMS:22;
      hence thesis;
     end;
   consider T being DecoratedTree of D() such that
A3:  T.{} = d() &
    for t being Element of dom T holds succ t = { t^<*k*>: k in U(T.t)} &
     for n,x st x = T.t & n in U(x) holds T.(t^<*n*>) = S().[x,n]
      from DTreeStructEx(A1);
   take T; thus T.{} = d() by A3;
   let t be Element of dom T;
A4:  succ t = { t^<*k*>: k in FF(F(T.t))} by A3;
   thus succ t c= { t^<*i*>: i < F(T.t)}
     proof let x; assume x in succ t;
      then consider l such that
A5:    x = t^<*l*> & l in FF(F(T.t)) by A4;
         ex i st l = i & i < F(T.t) by A5;
      hence thesis by A5;
     end;
   thus { t^<*i*>: i < F(T.t)} c= succ t
     proof let x; assume x in { t^<*i*>: i < F(T.t)};
      then consider l such that
A6:    x = t^<*l*> & l < F(T.t);
         l in FF(F(T.t)) by A6;
      hence thesis by A4,A6;
     end;
   let n,x; assume
A7:  x = T.t & n < F(x);
    then n in FF(F(x));
   hence T.(t^<*n*>) = S().[x,n] by A3,A7;
  end;
