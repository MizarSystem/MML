:: Miscellaneous Facts about Functors
::  by Grzegorz Bancerek
::
:: Received July 31, 2001
:: Copyright (c) 2001 Association of Mizar Users

environ

 vocabulary RELAT_2, ALTCAT_1, MSUALG_6, FUNCTOR0, SGRAPH1, FUNCT_1, RELAT_1,
      BOOLE, CAT_1, ENS_1, PARTFUN1, YELLOW18, CANTOR_1, PBOOLE, ALTCAT_2,
      PRALG_1, FUNCT_3, MCART_1, MSUALG_3, WELLORD1, OPPCAT_1, YELLOW20;
 notation TARSKI, XBOOLE_0, ZFMISC_1, SUBSET_1, RELAT_1, RELSET_1, FUNCT_1,
      FUNCT_2, MCART_1, BINOP_1, MULTOP_1, STRUCT_0, FUNCT_4, PARTFUN1, PBOOLE,
      MSUALG_1, PRALG_1, MSUALG_3, FUNCT_3, ALTCAT_1, ALTCAT_2, FUNCTOR0,
      FUNCTOR3, YELLOW18;
 constructors AMI_1, FUNCTOR3, YELLOW18;
 clusters SUBSET_1, RELSET_1, RELAT_1, PRALG_1, STRUCT_0, MSUALG_1, ALTCAT_2,
      FUNCTOR0, FUNCTOR2, ALTCAT_4, YELLOW18, FUNCT_1;
 requirements SUBSET, BOOLE;


begin :: Reverse functors

reserve x,y for set;

theorem :: YELLOW20:1
 for A,B being transitive with_units (non empty AltCatStr)
 for F being feasible reflexive FunctorStr over A,B
  st F is coreflexive bijective
 for a being object of A, b being object of B
  holds F.a = b iff F".b = a;

theorem :: YELLOW20:2
 for A,B being transitive with_units (non empty AltCatStr)
 for F being Covariant feasible FunctorStr over A,B
 for G being Covariant feasible FunctorStr over B,A
  st F is bijective & G = F"
 for a1,a2 being object of A st <^a1,a2^> <> {}
 for f being Morphism of a1,a2, g being Morphism of F.a1, F.a2
  holds F.f = g iff G.g = f;

theorem :: YELLOW20:3
 for A,B being transitive with_units (non empty AltCatStr)
 for F being Contravariant feasible FunctorStr over A,B
 for G being Contravariant feasible FunctorStr over B,A
  st F is bijective & G = F"
 for a1,a2 being object of A st <^a1,a2^> <> {}
 for f being Morphism of a1,a2, g being Morphism of F.a2, F.a1
  holds F.f = g iff G.g = f;

theorem :: YELLOW20:4
 for A,B being category, F being Functor of A,B st F is bijective
 for G being Functor of B,A st F*G = id B
  holds the FunctorStr of G = F";

theorem :: YELLOW20:5
 for A,B being category, F being Functor of A,B st F is bijective
 for G being Functor of B,A st G*F = id A
  holds the FunctorStr of G = F";

theorem :: YELLOW20:6
   for A,B being category, F being covariant Functor of A,B st F is bijective
 for G being covariant Functor of B,A st
   (for b being object of B holds F.(G.b) = b) &
   (for a,b being object of B st <^a,b^> <> {}
     for f being Morphism of a,b holds F.(G.f) = f)
  holds the FunctorStr of G = F";

theorem :: YELLOW20:7
   for A,B being category, F being contravariant Functor of A,B st F is
bijective
 for G being contravariant Functor of B,A st
   (for b being object of B holds F.(G.b) = b) &
   (for a,b being object of B st <^a,b^> <> {}
     for f being Morphism of a,b holds F.(G.f) = f)
  holds the FunctorStr of G = F";

theorem :: YELLOW20:8
   for A,B being category, F being covariant Functor of A,B st F is bijective
 for G being covariant Functor of B,A st
   (for a being object of A holds G.(F.a) = a) &
   (for a,b being object of A st <^a,b^> <> {}
     for f being Morphism of a,b holds G.(F.f) = f)
  holds the FunctorStr of G = F";

theorem :: YELLOW20:9
   for A,B being category, F being contravariant Functor of A,B st F is
bijective
 for G being contravariant Functor of B,A st
   (for a being object of A holds G.(F.a) = a) &
   (for a,b being object of A st <^a,b^> <> {}
     for f being Morphism of a,b holds G.(F.f) = f)
  holds the FunctorStr of G = F";

begin :: Intersection of categories

definition
 let A, B be AltCatStr;
 pred A, B have_the_same_composition means
:: YELLOW20:def 1

  for a1, a2, a3 being set holds
    (the Comp of A).[a1,a2,a3] tolerates (the Comp of B).[a1,a2,a3];
 symmetry;
end;


theorem :: YELLOW20:10
 for A, B being AltCatStr holds
    A,B have_the_same_composition
  iff
  for a1,a2,a3,x being set st
    x in dom ((the Comp of A).[a1,a2,a3]) &
    x in dom ((the Comp of B).[a1,a2,a3])
   holds ((the Comp of A).[a1,a2,a3]).x = ((the Comp of B).[a1,a2,a3]).x;

theorem :: YELLOW20:11
 for A, B being transitive non empty AltCatStr holds
    A,B have_the_same_composition
  iff
   for a1,a2,a3 being object of A st <^a1,a2^> <> {} & <^a2,a3^> <> {}
   for b1,b2,b3 being object of B st <^b1,b2^> <> {} & <^b2,b3^> <> {} &
     b1 = a1 & b2 = a2 & b3 = a3
   for f1 being Morphism of a1,a2, g1 being Morphism of b1,b2 st g1 = f1
   for f2 being Morphism of a2,a3, g2 being Morphism of b2,b3 st g2 = f2
    holds f2 * f1 = g2 * g1;

theorem :: YELLOW20:12
   for A, B being para-functional semi-functional category holds
   A, B have_the_same_composition;

definition
 let f, g be Function;
 func Intersect(f, g) -> Function means
:: YELLOW20:def 2

  dom it = (dom f) /\ (dom g) &
  for x being set st x in (dom f) /\ (dom g) holds it.x = (f.x) /\ (g.x);
 commutativity;
end;


theorem :: YELLOW20:13
   for I being set, A,B being ManySortedSet of I
  holds Intersect(A, B) = A /\ B;

theorem :: YELLOW20:14
 for I,J being set
 for A being ManySortedSet of I, B being ManySortedSet of J
  holds Intersect(A, B) is ManySortedSet of I /\ J;

theorem :: YELLOW20:15
 for I,J being set
 for A being ManySortedSet of I, B being Function
 for C being ManySortedSet of J st C = Intersect(A, B)
  holds C cc= A;

theorem :: YELLOW20:16
 for A1,A2, B1,B2 being set
 for f being Function of A1,A2, g being Function of B1,B2
  st f tolerates g
  holds f /\ g is Function of A1 /\ B1, A2 /\ B2;

theorem :: YELLOW20:17
 for I1,I2 being set
 for A1,B1 being ManySortedSet of I1
 for A2,B2 being ManySortedSet of I2
 for A,B being ManySortedSet of I1 /\ I2
  st A = Intersect(A1, A2) & B = Intersect(B1, B2)
 for F being ManySortedFunction of A1,B1
 for G being ManySortedFunction of A2,B2
  st for x being set st x in dom F & x in dom G holds F.x tolerates G.x
  holds Intersect(F, G) is ManySortedFunction of A, B;

theorem :: YELLOW20:18
 for I,J being set
 for F being ManySortedSet of [:I,I:]
 for G being ManySortedSet of [:J,J:]
 ex H being ManySortedSet of [:I/\J,I/\J:]
  st H = Intersect(F, G) & Intersect({|F|}, {|G|}) = {|H|};

theorem :: YELLOW20:19
 for I,J being set
 for F1,F2 being ManySortedSet of [:I,I:]
 for G1,G2 being ManySortedSet of [:J,J:]
 ex H1,H2 being ManySortedSet of [:I/\J,I/\J:]
  st H1 = Intersect(F1, G1) & H2 = Intersect(F2, G2) &
     Intersect({|F1,F2|}, {|G1,G2|}) = {|H1, H2|};

definition
 let A, B be AltCatStr such that
    A, B have_the_same_composition;
 func Intersect(A, B) -> strict AltCatStr means
:: YELLOW20:def 3

   the carrier of it = (the carrier of A) /\ (the carrier of B) &
   the Arrows of it = Intersect(the Arrows of A, the Arrows of B) &
   the Comp of it = Intersect(the Comp of A, the Comp of B);
end;


theorem :: YELLOW20:20
   for A, B being AltCatStr st A, B have_the_same_composition
  holds Intersect(A, B) = Intersect(B, A);

theorem :: YELLOW20:21
 for A, B being AltCatStr st A, B have_the_same_composition
  holds Intersect(A, B) is SubCatStr of A;

theorem :: YELLOW20:22
 for A, B being AltCatStr st A, B have_the_same_composition
 for a1,a2 being object of A, b1,b2 being object of B
 for o1, o2 being object of Intersect(A, B)
  st o1 = a1 & o1 = b1 & o2 = a2 & o2 = b2
  holds <^o1,o2^> = <^a1,a2^> /\ <^b1,b2^>;

theorem :: YELLOW20:23
 for A, B being transitive AltCatStr st A, B have_the_same_composition
  holds Intersect(A, B) is transitive;

theorem :: YELLOW20:24
 for A, B being AltCatStr
  st A, B have_the_same_composition
 for a1,a2 being object of A, b1,b2 being object of B
 for o1,o2 being object of Intersect(A, B)
  st o1 = a1 & o1 = b1 & o2 = a2 & o2 = b2 &
     <^a1,a2^> <> {} & <^b1,b2^> <> {}
 for f being Morphism of a1,a2, g being Morphism of b1,b2 st f = g
  holds f in <^o1,o2^>;

theorem :: YELLOW20:25
 for A, B being with_units (non empty AltCatStr)
  st A, B have_the_same_composition
 for a being object of A, b being object of B
 for o being object of Intersect(A, B)
  st o = a & o = b & idm a = idm b
  holds idm a in <^o,o^>;

theorem :: YELLOW20:26
   for A, B being category
  st A, B have_the_same_composition &
     Intersect(A,B) is non empty &
     for a being object of A, b being object of B st a = b holds idm a = idm b
  holds Intersect(A, B) is subcategory of A;

begin :: Subcategories

scheme :: YELLOW20:sch 1
 SubcategoryUniq
 { A() -> category,
   B1, B2() -> non empty subcategory of A(),
   P[set], Q[set,set,set]}:
  the AltCatStr of B1() = the AltCatStr of B2()
 provided
  for a being object of A() holds a is object of B1() iff P[a] and
  for a,b being object of A(), a',b' being object of B1()
     st a' = a & b' = b & <^a,b^> <> {}
    for f being Morphism of a,b holds f in <^a',b'^> iff Q[a,b,f] and
  for a being object of A() holds a is object of B2() iff P[a] and
  for a,b being object of A(), a',b' being object of B2()
     st a' = a & b' = b & <^a,b^> <> {}
    for f being Morphism of a,b holds f in <^a',b'^> iff Q[a,b,f]
proof
A5: the carrier of B1() c= the carrier of A() &
    the carrier of B2() c= the carrier of A() by ALTCAT_2:def 11;
A6: the carrier of B1() = the carrier of B2()
     proof
      hereby let x be set; assume
A7:      x in the carrier of B1();
        then reconsider a = x as object of B1();
        reconsider a as object of A() by A5,A7;
           P[a] by A1;
         then a is object of B2() by A3;
        hence x in the carrier of B2();
       end;
      let x be set; assume
A8:    x in the carrier of B2();
      then reconsider a = x as object of B2();
      reconsider a as object of A() by A5,A8;
         P[a] by A3;
       then a is object of B1() by A1;
      hence x in the carrier of B1();
     end;
      now let a,b be Element of B1();
     reconsider x1 = a, y1 = b as object of B1();
     reconsider x2 = x1, y2 = y1 as object of B2() by A6;
        x1 in the carrier of B1() & y1 in the carrier of B1();
     then reconsider a' = a, b' = b as object of A() by A5;
A9:   <^x1,y1^> c= <^a',b'^> & <^x2,y2^> c= <^a',b'^> by ALTCAT_2:32;
A10:   <^x1,y1^> c= <^x2,y2^>
       proof let f be set; assume
A11:      f in <^x1,y1^>;
        then reconsider f as Morphism of a',b' by A9;
           Q[a',b',f] by A2,A9,A11;
        hence thesis by A4,A9,A11;
       end;
A12:   <^x2,y2^> c= <^x1,y1^>
       proof let f be set; assume
A13:      f in <^x2,y2^>;
        then reconsider f as Morphism of a',b' by A9;
           Q[a',b',f] by A4,A9,A13;
        hence thesis by A2,A9,A13;
       end;
     thus (the Arrows of B1()).(a,b)
        = <^x1,y1^> by ALTCAT_1:def 2
       .= <^x2,y2^> by A10,A12,XBOOLE_0:def 10
       .= (the Arrows of B2()).(a,b) by ALTCAT_1:def 2;
    end;
    then the Arrows of B1() = the Arrows of B2() by A6,ALTCAT_1:9;
   hence thesis by A6,ALTCAT_2:27;
  end;

theorem :: YELLOW20:27
 for A being non empty AltCatStr, B being non empty SubCatStr of A holds
   B is full iff
    for a1,a2 being object of A, b1,b2 being object of B st b1 = a1 & b2 = a2
     holds <^b1,b2^> = <^a1,a2^>;

scheme :: YELLOW20:sch 2
 FullSubcategoryEx
 { A() -> category, P[set]}:
 ex B being strict full non empty subcategory of A() st
  for a being object of A() holds a is object of B iff P[a]
 provided
  ex a being object of A() st P[a]
proof   defpred p[set] means P[$1];
    defpred Q[set,set,set] means not contradiction;
A2:  ex a being object of A() st p[a] by A1;
A3: for a,b,c being object of A()
     st p[a] & p[b] & p[c] & <^a,b^> <> {} & <^b,c^> <> {}
     for f being Morphism of a,b, g being Morphism of b,c
       st Q[a,b,f] & Q[b,c,g]
       holds Q[a,c,g*f];
A4: for a being object of A() st p[a] holds Q[a,a, idm a];
   consider B being strict non empty subcategory of A() such that
A5: for a being object of A() holds a is object of B iff p[a] and
A6: for a,b being object of A(), a',b' being object of B
     st a' = a & b' = b & <^a,b^> <> {}
    for f being Morphism of a,b holds f in <^a',b'^> iff Q[a,b,f]
     from YELLOW18:sch 7(A2,A3,A4);
      now let a1,a2 be object of A(), b1,b2 be object of B; assume
A7:   b1 = a1 & b2 = a2;
then A8:   <^b1,b2^> c= <^a1,a2^> by ALTCAT_2:32;
        <^a1,a2^> c= <^b1,b2^>
       proof let f be set; assume f in <^a1,a2^>;
        hence thesis by A6,A7;
       end;
     hence <^b1,b2^> = <^a1,a2^> by A8,XBOOLE_0:def 10;
    end;
    then B is full by Th27;
   hence thesis by A5;
  end;

scheme :: YELLOW20:sch 3
 FullSubcategoryUniq
 { A() -> category,
   B1, B2() -> full non empty subcategory of A(),
   P[set]}:
  the AltCatStr of B1() = the AltCatStr of B2()
 provided
  for a being object of A() holds a is object of B1() iff P[a] and
  for a being object of A() holds a is object of B2() iff P[a]
proof   defpred p[set] means P[$1];
A3:  for a being object of A() holds a is object of B1() iff p[a] by A1;
A4:  for a being object of A() holds a is object of B2() iff p[a] by A2;
    defpred Q[set,set,set] means not contradiction;
A5: now let a,b be object of A(), a',b' be object of B1();
     assume a' = a & b' = b; then <^a',b'^> = <^a,b^> by Th27;
     hence <^a,b^> <> {} implies
      for f being Morphism of a,b holds f in <^a',b'^> iff Q[a,b,f];
    end;
A6: now let a,b be object of A(), a',b' be object of B2();
     assume a' = a & b' = b; then <^a',b'^> = <^a,b^> by Th27;
     hence <^a,b^> <> {} implies
      for f being Morphism of a,b holds f in <^a',b'^> iff Q[a,b,f];
    end;
   thus thesis from SubcategoryUniq(A3,A5,A4,A6);
  end;

begin :: Inclusion functors and functor restrictions

registration
 let f be Function-yielding Function;
 let x,y be set;
 cluster f.(x,y) -> Relation-like Function-like;
 coherence
  proof f.(x,y) = f.[x,y] by BINOP_1:def 1;
   hence thesis;
  end;
end;


theorem :: YELLOW20:28
 for A being category, C being non empty subcategory of A
 for a,b being object of C st <^a,b^> <> {}
 for f being Morphism of a,b holds (incl C).f = f;

registration
 let A be category;
 let C be non empty subcategory of A;
 cluster incl C -> id-preserving comp-preserving;
 coherence
  proof
   thus incl C is id-preserving
     proof let a be object of C;
A2:    (incl C).a = a by FUNCTOR0:28;
      thus Morph-Map(incl C, a, a).idm a = (incl C).idm a by FUNCTOR0:def 16
        .= idm a by Th28
        .= idm ((incl C).a) by A2,ALTCAT_2:35;
     end;
   let o1,o2,o3 be object of C such that
A3: <^o1,o2^> <> {} & <^o2,o3^> <> {};
   let f be Morphism of o1,o2, g be Morphism of o2,o3;
      <^o1,o3^> <> {} by A3,ALTCAT_1:def 4;
    then (incl C).o1 = o1 & (incl C).o2 = o2 & (incl C).o3 = o3 &
    (incl C).g = g & (incl C).f = f & (incl C).(g*f) = g*f
     by A3,Th28,FUNCTOR0:28;
   hence (incl C).(g*f) = ((incl C).g)*((incl C).f) by A3,ALTCAT_2:33;
  end;
end;


registration
 let A be category;
 let C be non empty subcategory of A;
 cluster incl C -> Covariant;
 coherence;
end;


definition
 let A be category;
 let C be non empty subcategory of A;
 redefine func incl C -> strict covariant Functor of C,A;
end;


definition
 let A,B be category;
 let C be non empty subcategory of A;
 let F be covariant Functor of A,B;
 redefine func F|C -> strict covariant Functor of C,B;
end;


definition
 let A,B be category;
 let C be non empty subcategory of A;
 let F be contravariant Functor of A,B;
 redefine func F|C -> strict contravariant Functor of C,B;
end;


theorem :: YELLOW20:29
 for A,B being category, C being non empty subcategory of A
 for F being FunctorStr over A,B
 for a being object of A, c being object of C st c = a
  holds (F|C).c = F.a;

theorem :: YELLOW20:30
 for A,B being category, C being non empty subcategory of A
 for F being covariant Functor of A,B
 for a,b being object of A, c,d being object of C
  st c = a & d = b & <^c,d^> <> {}
 for f being Morphism of a,b for g being Morphism of c,d st g = f
  holds (F|C).g = F.f;

theorem :: YELLOW20:31
 for A,B being category, C being non empty subcategory of A
 for F being contravariant Functor of A,B
 for a,b being object of A, c,d being object of C
  st c = a & d = b & <^c,d^> <> {}
 for f being Morphism of a,b for g being Morphism of c,d st g = f
  holds (F|C).g = F.f;

theorem :: YELLOW20:32
 for A,B being non empty AltGraph
 for F being BimapStr over A,B st F is Covariant one-to-one
 for a,b being object of A
  st F.a = F.b holds a = b;

theorem :: YELLOW20:33
 for A,B being non empty reflexive AltGraph
 for F being feasible Covariant FunctorStr over A,B st F is faithful
 for a,b being object of A st <^a,b^> <> {}
 for f,g being Morphism of a,b
  st F.f = F.g holds f = g;

theorem :: YELLOW20:34
 for A,B being non empty AltGraph
 for F being Covariant FunctorStr over A,B st F is surjective
 for a,b being object of B st <^a,b^> <> {}
 for f being Morphism of a,b
 ex c,d being object of A, g being Morphism of c,d st
  a = F.c & b = F.d & <^c,d^> <> {} & f = F.g;

theorem :: YELLOW20:35
 for A,B being non empty AltGraph
 for F being BimapStr over A,B st F is Contravariant one-to-one
 for a,b being object of A
  st F.a = F.b holds a = b;

theorem :: YELLOW20:36
 for A,B being non empty reflexive AltGraph
 for F being feasible Contravariant FunctorStr over A,B st F is faithful
 for a,b being object of A st <^a,b^> <> {}
 for f,g being Morphism of a,b
  st F.f = F.g holds f = g;

theorem :: YELLOW20:37
 for A,B being non empty AltGraph
 for F being Contravariant FunctorStr over A,B st F is surjective
 for a,b being object of B st <^a,b^> <> {}
 for f being Morphism of a,b
 ex c,d being object of A, g being Morphism of c,d st
  b = F.c & a = F.d & <^c,d^> <> {} & f = F.g;

begin :: Isomorphisms under arbitrary functor

definition
 let A,B be category;
 let F be FunctorStr over A,B;
 let A', B' be category;
 pred A',B' are_isomorphic_under F means
:: YELLOW20:def 4
    A' is subcategory of A & B' is subcategory of B &
  ex G being covariant Functor of A',B' st G is bijective &
  (for a' being object of A', a being object of A st a' = a holds G.a' = F.a) &
  (for b',c' being object of A', b,c being object of A
    st <^b',c'^> <> {} & b' = b & c' = c
   for f' being Morphism of b',c', f being Morphism of b,c
    st f' = f holds G.f' = Morph-Map(F,b,c).f);

 pred A',B' are_anti-isomorphic_under F means
:: YELLOW20:def 5
    A' is subcategory of A & B' is subcategory of B &
  ex G being contravariant Functor of A',B' st G is bijective &
  (for a' being object of A', a being object of A st a' = a holds G.a' = F.a) &
  (for b',c' being object of A', b,c being object of A
    st <^b',c'^> <> {} & b' = b & c' = c
   for f' being Morphism of b',c', f being Morphism of b,c
    st f' = f holds G.f' = Morph-Map(F,b,c).f);
end;


theorem :: YELLOW20:38
   for A,B, A1, B1 being category, F being FunctorStr over A,B
  st A1, B1 are_isomorphic_under F
  holds A1, B1 are_isomorphic;

theorem :: YELLOW20:39
   for A,B, A1, B1 being category, F being FunctorStr over A,B
  st A1, B1 are_anti-isomorphic_under F
  holds A1, B1 are_anti-isomorphic;

theorem :: YELLOW20:40
   for A,B being category, F being covariant Functor of A,B
  st A, B are_isomorphic_under F
  holds F is bijective;

theorem :: YELLOW20:41
   for A,B being category, F being contravariant Functor of A,B
  st A, B are_anti-isomorphic_under F
  holds F is bijective;

theorem :: YELLOW20:42
   for A,B being category, F being covariant Functor of A,B
  st F is bijective
  holds A, B are_isomorphic_under F;

theorem :: YELLOW20:43
   for A,B being category, F being contravariant Functor of A,B
  st F is bijective
  holds A, B are_anti-isomorphic_under F;

scheme :: YELLOW20:sch 4
 CoBijectRestriction
 {A1, A2() -> non empty category,
  F() -> covariant Functor of A1(), A2(),
  B1() -> non empty subcategory of A1(),
  B2() -> non empty subcategory of A2()}:
   B1(), B2() are_isomorphic_under F()
 provided
 F() is bijective and
 for a being object of A1() holds
   a is object of B1() iff F().a is object of B2() and
 for a,b being object of A1() st <^a,b^> <> {}
   for a1,b1 being object of B1() st a1 = a & b1 = b
   for a2,b2 being object of B2() st a2 = F().a & b2 = F().b
   for f being Morphism of a,b holds
       f in <^a1,b1^> iff F().f in <^a2,b2^>
proof
   thus B1() is subcategory of A1() & B2() is subcategory of A2();
A4: the carrier of B1() c= the carrier of A1() by ALTCAT_2:def 11;
   deffunc O(object of B1()) = (F()|B1()).$1;
   deffunc F(object of B1(),object of B1(),Morphism of $1,$2) =
      (F()|B1()).$3;
A5: now let a be object of B1();
        a in the carrier of B1();
     then reconsider b = a as object of A1() by A4;
        (F()|B1()).a = F().b by Th29;
     hence O(a) is object of B2() by A2;
    end;
A6: now let a,b be object of B1() such that
A7:   <^a,b^> <> {};
        a in the carrier of B1() & b in the carrier of B1();
     then reconsider c = a, d = b as object of A1() by A4;
     reconsider a' = (F()|B1()).a, b' = (F()|B1()).b as object of B2() by A5;
     let f be Morphism of a,b;
A8:   <^a,b^> c= <^c,d^> & f in <^a,b^> by A7,ALTCAT_2:32;
     then reconsider g = f as Morphism of c,d ;
        (F()|B1()).a = F().c & (F()|B1()).b = F().d &
      (F()|B1()).f = F().g by A7,Th29,Th30;
      then (F()|B1()).f in <^a',b'^> by A3,A8;
     hence F(a,b,f) in (the Arrows of B2()).(O(a), O(b)) by ALTCAT_1:def 2;
    end;
A9: now let a,b,c be object of B1() such that
A10:   <^a,b^> <> {} & <^b,c^> <> {};
        a in the carrier of B1() & b in the carrier of B1() &
      c in the carrier of B1();
     then reconsider a1 = a, b1 = b, c1 = c as object of A1()
       by A4;
     let f be Morphism of a,b, g be Morphism of b,c;
     let a',b',c' be object of B2() such that
A11:   a' = O(a) & b' = O(b) & c' = O(c);
     let f' be Morphism of a',b', g' be Morphism of b',c' such that
A12:   f' = F(a,b,f) & g' = F(b,c,g);
A13:   <^a,b^> c= <^a1,b1^> & f in <^a,b^> by A10,ALTCAT_2:32;
     then reconsider f1 = f as Morphism of a1,b1 ;
A14:   <^b,c^> c= <^b1,c1^> & g in <^b,c^> by A10,ALTCAT_2:32;
     then reconsider g1 = g as Morphism of b1,c1 ;
A15:   <^a,c^> <> {} by A10,ALTCAT_1:def 4;
A16:   g*f = g1*f1 by A10,ALTCAT_2:33;
A17:   a' = F().a1 & b' = F().b1 & c' = F().c1 by A11,Th29;
A18:   (F()|B1()).(g*f) = F().(g1*f1) & f' = F().f1 & g' = F().g1
       by A10,A12,A15,A16,Th30; then
A19:  f' in <^a',b'^> & g' in <^b',c'^> by A3,A13,A14,A17;
     thus F(a,c,g*f) = (F().g1)*(F().f1) by A13,A14,A18,FUNCTOR0:def 24
        .= g'*f' by A17,A18,A19,ALTCAT_2:33;
    end;
A20: now let a be object of B1(), a' be object of B2() such that
A21:   a' = O(a);
        a in the carrier of B1();
     then reconsider a1 = a as object of A1() by A4;
        idm a in <^a,a^> & idm a = idm a1 by ALTCAT_2:35;
     hence F(a,a,idm a) = F().idm a1 by Th30
        .= idm (F().a1) by FUNCTOR2:2
        .= idm ((F()|B1()).a) by Th29
        .= idm a' by A21,ALTCAT_2:35;
    end;
   consider G being covariant strict Functor of B1(),B2() such that
A22: for a being object of B1() holds G.a = O(a) and
A23: for a,b being object of B1() st <^a,b^> <> {}
     for f being Morphism of a,b holds G.f = F(a,b,f)
      from YELLOW18:sch 8(A5,A6,A9,A20);
   take G;
A24: F() is injective surjective by A1,FUNCTOR0:def 36;
then
A25: F() is one-to-one faithful surjective by FUNCTOR0:def 34;
A26: now let a,b be object of B1();
        a in the carrier of B1() & b in the carrier of B1();
     then reconsider a1 = a, b1 = b as object of A1() by A4;
     assume O(a) = O(b);
      then F().a1 = (F()|B1()).b by Th29 .= F().b1 by Th29;
     hence a = b by A25,Th32;
    end;
A27: now let a,b be object of B1() such that
A28:   <^a,b^> <> {};
        a in the carrier of B1() & b in the carrier of B1();
     then reconsider a1 = a, b1 = b as object of A1() by A4;
     let f,g be Morphism of a,b;
A29:   <^a,b^> c= <^a1,b1^> & f in <^a,b^> & g in <^a,b^>
       by A28,ALTCAT_2:32;
     then reconsider f1 = f, g1 = g as Morphism of a1,b1 ;
     assume F(a,b,f) = F(a,b,g);
      then F().f1 = (F()|B1()).g by A28,Th30 .= F().g1 by A28,Th30;
     hence f = g by A25,A29,Th33;
    end;
A30: for a,b being object of B2() st <^a,b^> <> {}
    for f being Morphism of a,b
     ex c,d being object of B1(), g being Morphism of c,d
      st a = O(c) & b = O(d) & <^c,d^> <> {} & f = F(c,d,g)
      proof let a,b be object of B2() such that
A31:     <^a,b^> <> {};
          a in the carrier of B2() & b in the carrier of B2() &
        the carrier of B2() c= the carrier of A2() by ALTCAT_2:def 11;
       then reconsider a1 = a, b1 = b as object of A2();
       let f be Morphism of a,b;
A32:     <^a,b^> c= <^a1,b1^> & f in <^a,b^> by A31,ALTCAT_2:32;
       then reconsider f1 = f as Morphism of a1,b1 ;
       consider c1, d1 being object of A1(), g1 being Morphism of c1,d1
       such that
A33:     a1 = F().c1 & b1 = F().d1 & <^c1,d1^> <> {} & f1 = F().g1
         by A24,A32,Th34;
       reconsider c = c1, d = d1 as object of B1() by A2,A33;
A34:     g1 in <^c,d^> by A3,A31,A33;
       then reconsider g = g1 as Morphism of c,d ;
       take c,d,g;
       thus thesis by A33,A34,Th29,Th30;
      end;
   thus G is bijective from YELLOW18:sch 10(A22,A23,A26,A27,A30);
   hereby let a be object of B1(), a1 be object of A1() such that
A35:   a = a1;
     thus G.a = (F()|B1()).a by A22 .= F().a1 by A35,Th29;
    end;
   let b,c be object of B1(), b1,c1 be object of A1() such that
A36: <^b,c^> <> {} & b1 = b & c1 = c;
   let f be Morphism of b,c, f1 be Morphism of b1,c1 such that
A37: f = f1;
A38: <^b,c^> c= <^b1,c1^> & f in <^b,c^> by A36,ALTCAT_2:32;
then A39: <^F().b1, F().c1^> <> {} by FUNCTOR0:def 19;
   thus G.f = (F()|B1()).f by A23,A36 .= F().f1 by A36,A37,Th30
      .= Morph-Map(F(),b1,c1).f1 by A38,A39,FUNCTOR0:def 16;
  end;

scheme :: YELLOW20:sch 5
 ContraBijectRestriction
 {A1, A2() -> non empty category,
  F() -> contravariant Functor of A1(), A2(),
  B1() -> non empty subcategory of A1(),
  B2() -> non empty subcategory of A2()}:
   B1(), B2() are_anti-isomorphic_under F()
 provided
 F() is bijective and
 for a being object of A1() holds
   a is object of B1() iff F().a is object of B2() and
 for a,b being object of A1() st <^a,b^> <> {}
   for a1,b1 being object of B1() st a1 = a & b1 = b
   for a2,b2 being object of B2() st a2 = F().a & b2 = F().b
   for f being Morphism of a,b holds
       f in <^a1,b1^> iff F().f in <^b2,a2^>
proof
   thus B1() is subcategory of A1() & B2() is subcategory of A2();
A4: the carrier of B1() c= the carrier of A1() by ALTCAT_2:def 11;
   deffunc O(object of B1()) = (F()|B1()).$1;
   deffunc F(object of B1(),object of B1(),Morphism of $1,$2) =
          (F()|B1()).$3;
A5: now let a be object of B1();
        a in the carrier of B1();
     then reconsider b = a as object of A1() by A4;
        (F()|B1()).a = F().b by Th29;
     hence O(a) is object of B2() by A2;
    end;
A6: now let a,b be object of B1() such that
A7:   <^a,b^> <> {};
        a in the carrier of B1() & b in the carrier of B1();
     then reconsider c = a, d = b as object of A1() by A4;
     reconsider a' = (F()|B1()).a, b' = (F()|B1()).b as object of B2() by A5;
     let f be Morphism of a,b;
A8:   <^a,b^> c= <^c,d^> & f in <^a,b^> by A7,ALTCAT_2:32;
     then reconsider g = f as Morphism of c,d ;
        (F()|B1()).a = F().c & (F()|B1()).b = F().d &
      (F()|B1()).f = F().g by A7,Th29,Th31;
      then (F()|B1()).f in <^b',a'^> by A3,A8;
     hence F(a,b,f) in (the Arrows of B2()).(O(b), O(a)) by ALTCAT_1:def 2;
    end;
A9: now let a,b,c be object of B1() such that
A10:   <^a,b^> <> {} & <^b,c^> <> {};
        a in the carrier of B1() & b in the carrier of B1() &
      c in the carrier of B1();
     then reconsider a1 = a, b1 = b, c1 = c as object of A1() by A4;
     let f be Morphism of a,b, g be Morphism of b,c;
     let a',b',c' be object of B2() such that
A11:   a' = O(a) & b' = O(b) & c' = O(c);
     let f' be Morphism of b',a', g' be Morphism of c',b' such that
A12:   f' = F(a,b,f) & g' = F(b,c,g);
A13:   <^a,b^> c= <^a1,b1^> & f in <^a,b^> by A10,ALTCAT_2:32;
     then reconsider f1 = f as Morphism of a1,b1 ;
A14:   <^b,c^> c= <^b1,c1^> & g in <^b,c^> by A10,ALTCAT_2:32;
     then reconsider g1 = g as Morphism of b1,c1 ;
A15:   <^a,c^> <> {} by A10,ALTCAT_1:def 4;
A16:   g*f = g1*f1 by A10,ALTCAT_2:33;
A17:   a' = F().a1 & b' = F().b1 & c' = F().c1 by A11,Th29;
A18:   (F()|B1()).(g*f) = F().(g1*f1) & f' = F().f1 & g' = F().g1
       by A10,A12,A15,A16,Th31;
then
A19:  f' in <^b',a'^> & g' in <^c',b'^> by A3,A13,A14,A17;
     thus F(a,c,g*f) = (F().f1)*(F().g1) by A13,A14,A18,FUNCTOR0:def 25
        .= f'*g' by A17,A18,A19,ALTCAT_2:33;
    end;
A20: now let a be object of B1(), a' be object of B2() such that
A21:   a' = O(a);
        a in the carrier of B1();
     then reconsider a1 = a as object of A1() by A4;
        idm a in <^a,a^> & idm a = idm a1 by ALTCAT_2:35;
     hence F(a,a,idm a) = F().idm a1 by Th31
        .= idm (F().a1) by ALTCAT_4:13
        .= idm ((F()|B1()).a) by Th29
        .= idm a' by A21,ALTCAT_2:35;
    end;
   consider G being contravariant strict Functor of B1(),B2() such that
A22: for a being object of B1() holds G.a = O(a) and
A23: for a,b being object of B1() st <^a,b^> <> {}
     for f being Morphism of a,b holds G.f = F(a,b,f)
      from YELLOW18:sch 9(A5,A6,A9,A20);
   take G;
    A24: F() is injective surjective by A1,FUNCTOR0:def 36;
then A25: F() is one-to-one faithful surjective by FUNCTOR0:def 34;
A26: now let a,b be object of B1();
        a in the carrier of B1() & b in the carrier of B1();
     then reconsider a1 = a, b1 = b as object of A1() by A4;
     assume O(a) = O(b);
      then F().a1 = (F()|B1()).b by Th29 .= F().b1 by Th29;
     hence a = b by A25,Th35;
    end;
A27: now let a,b be object of B1() such that
A28:   <^a,b^> <> {};
        a in the carrier of B1() & b in the carrier of B1();
     then reconsider a1 = a, b1 = b as object of A1() by A4;
     let f,g be Morphism of a,b;
A29:   <^a,b^> c= <^a1,b1^> & f in <^a,b^> & g in <^a,b^>
       by A28,ALTCAT_2:32;
     then reconsider f1 = f, g1 = g as Morphism of a1,b1 ;
     assume F(a,b,f) = F(a,b,g);
      then F().f1 = (F()|B1()).g by A28,Th31 .= F().g1 by A28,Th31;
     hence f = g by A25,A29,Th36;
    end;
A30: for a,b being object of B2() st <^a,b^> <> {}
    for f being Morphism of a,b
     ex c,d being object of B1(), g being Morphism of c,d
      st b = O(c) & a = O(d) & <^c,d^> <> {} & f = F(c,d,g)
      proof let a,b be object of B2() such that
A31:     <^a,b^> <> {};
          a in the carrier of B2() & b in the carrier of B2() &
        the carrier of B2() c= the carrier of A2() by ALTCAT_2:def 11;
       then reconsider a1 = a, b1 = b as object of A2();
       let f be Morphism of a,b;
A32:     <^a,b^> c= <^a1,b1^> & f in <^a,b^> by A31,ALTCAT_2:32;
       then reconsider f1 = f as Morphism of a1,b1 ;
       consider c1, d1 being object of A1(), g1 being Morphism of c1,d1
       such that
A33:     b1 = F().c1 & a1 = F().d1 & <^c1,d1^> <> {} & f1 = F().g1
         by A24,A32,Th37;
       reconsider c = c1, d = d1 as object of B1() by A2,A33;
A34:     g1 in <^c,d^> by A3,A31,A33;
       then reconsider g = g1 as Morphism of c,d ;
       take c,d,g;
       thus thesis by A33,A34,Th29,Th31;
      end;
   thus G is bijective from YELLOW18:sch 12(A22,A23,A26,A27,A30);
   hereby let a be object of B1(), a1 be object of A1() such that
A35:   a = a1;
     thus G.a = (F()|B1()).a by A22 .= F().a1 by A35,Th29;
    end;
   let b,c be object of B1(), b1,c1 be object of A1();
   assume
A36: <^b,c^> <> {} & b = b1 & c = c1;
   let f be Morphism of b,c, f1 be Morphism of b1,c1 such that
A37: f = f1;
A38: <^b,c^> c= <^b1,c1^> & f in <^b,c^> by A36,ALTCAT_2:32;
then A39: <^F().c1, F().b1^> <> {} by FUNCTOR0:def 20;
   thus G.f = (F()|B1()).f by A23,A36 .= F().f1 by A36,A37,Th31
      .= Morph-Map(F(),b1,c1).f1 by A38,A39,FUNCTOR0:def 17;
  end;

theorem :: YELLOW20:44
   for A being category, B being non empty subcategory of A
  holds B,B are_isomorphic_under id A;

theorem :: YELLOW20:45
 for f, g being Function st f c= g holds ~f c= ~g;

theorem :: YELLOW20:46
   for f, g being Function st dom f is Relation & ~f c= ~g holds f c= g;

theorem :: YELLOW20:47
 for I, J being set
 for A being ManySortedSet of [:I,I:], B being ManySortedSet of [:J,J:]
  st A cc= B holds ~A cc= ~B;

theorem :: YELLOW20:48
 for A being transitive non empty AltCatStr
 for B being transitive non empty SubCatStr of A
  holds B opp is SubCatStr of A opp;

theorem :: YELLOW20:49
 for A being category, B being non empty subcategory of A
  holds B opp is subcategory of A opp;

theorem :: YELLOW20:50
   for A being category, B being non empty subcategory of A
  holds B,B opp are_anti-isomorphic_under dualizing-func(A, A opp);

theorem :: YELLOW20:51
   for A1,A2 being category, F being covariant Functor of A1,A2
  st F is bijective
 for B1 being non empty subcategory of A1
 for B2 being non empty subcategory of A2
  st B1,B2 are_isomorphic_under F
  holds B2,B1 are_isomorphic_under F";

theorem :: YELLOW20:52
   for A1,A2 being category, F being contravariant Functor of A1,A2
  st F is bijective
 for B1 being non empty subcategory of A1
 for B2 being non empty subcategory of A2
  st B1,B2 are_anti-isomorphic_under F
  holds B2,B1 are_anti-isomorphic_under F";

theorem :: YELLOW20:53
   for A1,A2,A3 being category
 for F being covariant Functor of A1,A2
 for G being covariant Functor of A2,A3
 for B1 being non empty subcategory of A1
 for B2 being non empty subcategory of A2
 for B3 being non empty subcategory of A3
  st B1,B2 are_isomorphic_under F & B2,B3 are_isomorphic_under G
  holds B1,B3 are_isomorphic_under G*F;

theorem :: YELLOW20:54
   for A1,A2,A3 being category
 for F being contravariant Functor of A1,A2
 for G being covariant Functor of A2,A3
 for B1 being non empty subcategory of A1
 for B2 being non empty subcategory of A2
 for B3 being non empty subcategory of A3
  st B1,B2 are_anti-isomorphic_under F & B2,B3 are_isomorphic_under G
  holds B1,B3 are_anti-isomorphic_under G*F;

theorem :: YELLOW20:55
   for A1,A2,A3 being category
 for F being covariant Functor of A1,A2
 for G being contravariant Functor of A2,A3
 for B1 being non empty subcategory of A1
 for B2 being non empty subcategory of A2
 for B3 being non empty subcategory of A3
  st B1,B2 are_isomorphic_under F & B2,B3 are_anti-isomorphic_under G
  holds B1,B3 are_anti-isomorphic_under G*F;

theorem :: YELLOW20:56
   for A1,A2,A3 being category
 for F being contravariant Functor of A1,A2
 for G being contravariant Functor of A2,A3
 for B1 being non empty subcategory of A1
 for B2 being non empty subcategory of A2
 for B3 being non empty subcategory of A3
  st B1,B2 are_anti-isomorphic_under F & B2,B3 are_anti-isomorphic_under G
  holds B1,B3 are_isomorphic_under G*F;
