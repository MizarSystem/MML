:: Partial Functions
::  by Czes{\l}aw Byli\'nski
::
:: Received September 18, 1989
:: Copyright (c) 1990 Association of Mizar Users

environ

 vocabulary BOOLE, FUNCT_1, RELAT_1, PARTFUN1, RELAT_2;
 notation TARSKI, XBOOLE_0, ZFMISC_1, SUBSET_1, RELAT_1, RELAT_2, RELSET_1,
      FUNCT_1;
 constructors TARSKI, FUNCT_1, RELSET_1, RELAT_2, XBOOLE_0;
 clusters RELAT_1, FUNCT_1, RELSET_1, SUBSET_1, ZFMISC_1, XBOOLE_0;
 requirements SUBSET, BOOLE;


begin

 reserve p,x,x1,x2,y,y',y1,y2,z,z1,z2,P,Q,X,X1,X2,Y,Y1,Y2,V,Z for set;

::::::::::::::::::::::::
:: Auxiliary theorems ::
::::::::::::::::::::::::

theorem :: PARTFUN1:1
   P c= [:X1,Y1:] & Q c= [:X2,Y2:] implies P \/ Q c= [:X1 \/ X2,Y1 \/ Y2:];

theorem :: PARTFUN1:2
   for f,g being Function
    st for x st x in dom f /\ dom g holds f.x = g.x
     ex h being Function st f \/ g = h;

theorem :: PARTFUN1:3
   for f,g,h being Function st f \/ g = h
    for x st x in dom f /\ dom g holds f.x = g.x;

scheme :: PARTFUN1:sch 1
 LambdaC{A()->set,C[set],F(set)->set,G(set)->set}:
 ex f being Function st dom f = A() &
  for x st x in A() holds
   (C[x] implies f.x = F(x)) & (not C[x] implies f.x = G(x))
proof
  defpred P[set,set] means
   (C[$1] implies $2 = F($1)) & (not C[$1] implies $2 = G($1));
A1:  for x,y1,y2 st x in A() & P[x,y1] & P[x,y2] holds y1 = y2;
A2: for x st x in A() ex y st P[x,y]
     proof let x;
         not C[x] implies
       (C[x] implies G(x) = F(x)) & (not C[x] implies G(x) = G(x));
      hence thesis;
     end;
  thus ex f being Function st dom f = A() &
   for x st x in A() holds P[x,f.x] from FUNCT_1:sch 2(A1,A2);
 end;

::::::::::::::::::::
:: Empty Function ::
::::::::::::::::::::

registration
  cluster empty Function;
 existence
  proof
      {} is Function;
    hence thesis;
  end;
end;

canceled 6;

theorem :: PARTFUN1:10
   rng {} = {};

registration let X,Y;
  cluster Function-like Relation of X,Y;
  existence
   proof
     consider E being Function such that
A1:    dom E c= X & rng E c= Y by Lm2;
     reconsider E as Relation of X,Y by A1,Lm3;
    take E;
    thus thesis;
   end;
 end;


definition let X,Y;
  mode PartFunc of X,Y is Function-like Relation of X,Y;
 end;


canceled 13;

theorem :: PARTFUN1:24
     for f being Function holds f is PartFunc of dom f, rng f;

theorem :: PARTFUN1:25
     for f being Function st rng f c= Y holds f is PartFunc of dom f, Y;

theorem :: PARTFUN1:26
     for f being PartFunc of X,Y st y in rng f
    ex x being Element of X st x in dom f & y = f.x;

theorem :: PARTFUN1:27
   for f being PartFunc of X,Y st x in dom f holds f.x in Y;

theorem :: PARTFUN1:28
     for f being PartFunc of X,Y st dom f c= Z holds f is PartFunc of Z,Y;

theorem :: PARTFUN1:29
     for f being PartFunc of X,Y st rng f c= Z holds f is PartFunc of X,Z;

theorem :: PARTFUN1:30
   for f being PartFunc of X,Y st X c= Z holds f is PartFunc of Z,Y;

theorem :: PARTFUN1:31
   for f being PartFunc of X,Y st Y c= Z holds f is PartFunc of X,Z;

theorem :: PARTFUN1:32
   for f being PartFunc of X1,Y1 st X1 c= X2 & Y1 c= Y2
    holds f is PartFunc of X2,Y2;

theorem :: PARTFUN1:33
     for f being Function,g being PartFunc of X,Y st f c= g
     holds f is PartFunc of X,Y;

theorem :: PARTFUN1:34
     for f1,f2 being PartFunc of X,Y st dom f1 = dom f2 &
      for x being Element of X st x in dom f1 holds f1.x = f2.x
    holds f1 = f2;

theorem :: PARTFUN1:35
     for f1,f2 being PartFunc of [:X,Y:],Z
     st dom f1 = dom f2 & for x,y st [x,y] in dom f1 holds f1.[x,y]=f2.[x,y]
    holds f1 = f2;

scheme :: PARTFUN1:sch 2
 PartFuncEx{X,Y()->set,P[set,set]}:
 ex f being PartFunc of X(),Y() st
  (for x holds x in dom f iff x in X() & ex y st P[x,y]) &
  (for x st x in dom f holds P[x,f.x])
provided
 for x,y st x in X() & P[x,y] holds y in Y() and
 for x,y1,y2 st x in X() & P[x,y1] & P[x,y2] holds y1 = y2
proof
A3: now assume
A4:   Y() = {};
     consider f being Function such that
A5:   dom f c= X() and
A6:   rng f c= Y() by Lm2;
     reconsider f as PartFunc of X(),Y() by A5,A6,Lm3;
     take f;
          rng f c= {} by A4,Lm3;
then A7:     rng f = {} by XBOOLE_1:3;
     hence for x holds x in dom f iff x in X() & ex y st P[x,y] by A1,A4,
RELAT_1:65;
     thus for x st x in dom f holds P[x,f.x] by A7,RELAT_1:65;
    end;
      now assume Y() <> {};
     consider y1;
defpred Q[set,set] means
 ((ex y st P[$1,y]) implies P[$1,$2]) &
 ((for y holds not P[$1,y]) implies $2=y1);
A8:    for x st x in X() ex z st Q[x,z]
        proof let x such that x in X();
           (for y holds not P[x,y]) implies
         ((ex y st P[x,y]) implies P[x,y1]) &
         ((for y holds not P[x,y]) implies y1=y1);
         hence thesis;
        end;
A9:    for x,z1,z2 st x in X() & Q[x,z1] & Q[x,z2]
       holds z1 = z2 by A2;
      consider g being Function such that
A10:     dom g = X() and
A11:     for x st x in X() holds Q[x,g.x] from FUNCT_1:sch 2(A9,A8);
defpred R[set] means ex y st P[$1,y];
      consider X being set such that
A12:    for x holds x in X iff x in X() & R[x] from XBOOLE_0:sch 1;
      set f=g|X;
A13:     dom f c= X() by A10,FUNCT_1:76;
        rng f c= Y()
       proof let y;
        assume y in rng f;
        then consider x such that
A14:       x in dom f and
A15:       y = f.x by FUNCT_1:def 5;
          dom f c= X by RELAT_1:87;
        then x in X() & ex y st P[x,y] by A12,A14;
        then x in X() & P[x,g.x] by A11;
        then x in X() & P[x,y] by A14,A15,FUNCT_1:70;
        hence thesis by A1;
       end;
      then reconsider f as PartFunc of X(),Y() by A13,Lm3;
      take f;
      thus for x holds x in dom f iff x in X() & ex y st P[x,y]
       proof let x;
           dom f c= X by RELAT_1:87;
         hence x in dom f implies x in X() & ex y st P[x,y] by A12;
         assume x in X() & ex y st P[x,y];
         then x in X & x in dom g by A10,A12;
         then x in dom g /\ X by XBOOLE_0:def 3;
         hence thesis by RELAT_1:90;
       end;
      let x;
      assume
A16:     x in dom f;
        dom f c= X by RELAT_1:87;
      then x in X() & ex y st P[x,y] by A12,A16;
      then P[x,g.x] by A11;
      hence P[x,f.x] by A16,FUNCT_1:70;
    end;
   hence thesis by A3;
 end;

scheme :: PARTFUN1:sch 3
 LambdaR{X,Y()->set,F(set)->set,P[set]}:
  ex f being PartFunc of X(),Y() st
   (for x holds x in dom f iff x in X() & P[x]) &
   (for x st x in dom f holds f.x = F(x))
provided
 for x st P[x] holds F(x) in Y()
proof
defpred Q[set,set] means P[$1] & $2 = F($1);
A2:  for x,y st x in X() & Q[x,y] holds y in Y() by A1;
A3:  for x,y1,y2 st x in X() & Q[x,y1] & Q[x,y2] holds y1 = y2;
   consider f being PartFunc of X(),Y() such that
A4:  for x holds x in dom f iff x in X() & ex y st Q[x,y] and
A5:  for x st x in dom f holds Q[x,f.x] from PartFuncEx(A2,A3);
   take f;
   thus for x holds x in dom f iff x in X() & P[x]
    proof let x;
     thus x in dom f implies x in X() & P[x]
      proof assume x in dom f;
       then x in X() & ex y st P[x] & y = F(x) by A4;
       hence thesis;
      end;
     assume x in X() & P[x];
     then x in X() & ex y st P[x] & y = F(x);
     hence thesis by A4;
    end;
   thus thesis by A5;
  end;

scheme :: PARTFUN1:sch 4
 PartFuncEx2{X,Y,Z()->set,P[set,set,set]}:
 ex f being PartFunc of [:X(),Y():],Z() st
   (for x,y holds [x,y] in dom f iff x in X() & y in Y() & ex z st P[x,y,z]) &
   (for x,y st [x,y] in dom f holds P[x,y,f.[x,y]])
provided
 for x,y,z st x in X() & y in Y() & P[x,y,z] holds z in Z() and
 for x,y,z1,z2 st x in X() & y in Y() & P[x,y,z1] & P[x,y,z2] holds z1 = z2
proof
defpred Q[set,set] means for x1,y1 st $1 = [x1,y1] holds P[x1,y1,$2];
A3: for x,z st x in [:X(),Y():] & Q[x,z] holds z in Z()
     proof let x,z;
      assume x in [:X(),Y():];
      then consider x1,y1 such that
A4:     x1 in X() & y1 in Y() and
A5:     x = [x1,y1] by ZFMISC_1:def 2;
      assume for x1,y1 st x = [x1,y1] holds P[x1,y1,z];
      then P[x1,y1,z] by A5;
      hence z in Z() by A1,A4;
     end;
A6: for x,z1,z2
      st x in [:X(),Y():] & Q[x,z1] & Q[x,z2] holds z1 = z2
    proof let x,z1,z2 such that
A7:    x in [:X(),Y():] and
A8:    (for x1,y1 st x = [x1,y1] holds P[x1,y1,z1]) and
A9:    (for x1,y1 st x = [x1,y1] holds P[x1,y1,z2]);
     consider x1,y1 such that
A10:    x1 in X() & y1 in Y() and
A11:    x = [x1,y1] by A7,ZFMISC_1:def 2;
       P[x1,y1,z1] & P[x1,y1,z2] by A8,A9,A11;
     hence thesis by A2,A10;
    end;
   consider f being PartFunc of [:X(),Y():],Z() such that
A12:  for x holds x in dom f iff x in [:X(),Y():] & ex z st Q[x,z] and
A13:  for x st x in dom f holds Q[x,f.x] from PartFuncEx(A3,A6);
   take f;
   thus for x,y holds [x,y] in dom f iff x in X() & y in Y() & ex z st P[x,y,z]
    proof let x,y;
      thus [x,y] in dom f implies x in X() & y in Y() & ex z st P[x,y,z]
       proof assume
A14:       [x,y] in dom f;
        hence x in X() & y in Y() by ZFMISC_1:106;
        consider z such that
A15:       for x1,y1 st [x,y] = [x1,y1] holds P[x1,y1,z] by A12,A14;
        take z;
        thus thesis by A15;
       end;
      assume x in X() & y in Y();
      then A16:     [x,y] in [:X(),Y():] by ZFMISC_1:def 2;
      given z such that
A17:     P[x,y,z];
        now take z;
       let x1,y1;
       assume [x,y] = [x1,y1];
       then x=x1 & y=y1 by ZFMISC_1:33;
       hence P[x1,y1,z] by A17;
      end;
      hence thesis by A12,A16;
    end;
   thus thesis by A13;
 end;

scheme :: PARTFUN1:sch 5
 LambdaR2{X,Y,Z()->set,F(set,set)->set,P[set,set]}:
 ex f being PartFunc of [:X(),Y():],Z()
  st (for x,y holds [x,y] in dom f iff x in X() & y in Y() & P[x,y]) &
     (for x,y st [x,y] in dom f holds f.[x,y] = F(x,y))
provided
  for x,y st P[x,y] holds F(x,y) in Z()
proof
defpred Q[set,set,set] means P[$1,$2] & $3 = F($1,$2);
A2: for x,y,z st x in X() & y in Y() & Q[x,y,z] holds z in Z() by A1;
A3: for x,y,z1,z2 st x in X() & y in Y() & Q[x,y,z1] & Q[x,y,z2] holds z1 = z2;
  consider f being PartFunc of [:X(),Y():],Z() such that
A4: for x,y holds [x,y] in dom f iff x in X() & y in Y() & ex z st Q[x,y,z] and
A5: for x,y st [x,y] in dom f holds Q[x,y,f.[x,y]] from PartFuncEx2(A2,A3);
  take f;
  thus for x,y holds [x,y] in dom f iff x in X() & y in Y() & P[x,y]
   proof let x,y;
    thus [x,y] in dom f implies x in X() & y in Y() & P[x,y]
     proof assume [x,y] in dom f;
      then x in X() & y in Y() & ex z st P[x,y] & z = F(x,y) by A4;
      hence thesis;
     end;
    assume x in X() & y in Y() & P[x,y];
    then x in X() & y in Y() & ex z st P[x,y] & z = F(x,y);
    hence thesis by A4;
   end;
  thus thesis by A5;
 end;

definition let X,Y,V,Z;
  let f be PartFunc of X,Y; let g be PartFunc of V,Z;
 redefine func g*f -> PartFunc of X,Z;
end;


theorem :: PARTFUN1:36
     for f being PartFunc of X,Y holds f*(id X) = f;

theorem :: PARTFUN1:37
     for f being PartFunc of X,Y holds (id Y)*f = f;

theorem :: PARTFUN1:38
     for f being PartFunc of X,Y st
     (for x1,x2 being Element of X
       st x1 in dom f & x2 in dom f & f.x1 = f.x2 holds x1 = x2)
    holds f is one-to-one;

theorem :: PARTFUN1:39
     for f being PartFunc of X,Y st f is one-to-one holds f" is PartFunc of Y,X
;

canceled 3;

theorem :: PARTFUN1:43
     for f being PartFunc of X,Y holds f|Z is PartFunc of Z,Y;

theorem :: PARTFUN1:44
   for f being PartFunc of X,Y holds f|Z is PartFunc of X,Y;

definition let X,Y; let f be PartFunc of X,Y; let Z be set;
 redefine func f|Z -> PartFunc of X,Y;
end;


theorem :: PARTFUN1:45
     for f being PartFunc of X,Y holds Z|f is PartFunc of X,Z;

theorem :: PARTFUN1:46
     for f being PartFunc of X,Y holds Z|f is PartFunc of X,Y;

theorem :: PARTFUN1:47
   for f being Function holds Y|f|X is PartFunc of X,Y;

canceled;

theorem :: PARTFUN1:49
     for f being PartFunc of X,Y st y in f.:X
     holds ex x being Element of X st x in dom f & y = f.x;

canceled;

theorem :: PARTFUN1:51
     for f being PartFunc of X,Y holds f.:X = rng f;

canceled;

theorem :: PARTFUN1:53
     for f being PartFunc of X,Y holds f"Y = dom f;

::::::::::::::::::::::::::::
:: Empty Function         ::
::::::::::::::::::::::::::::

theorem :: PARTFUN1:54
   for f being PartFunc of {},Y holds dom f = {} & rng f = {};

theorem :: PARTFUN1:55
   for f being Function st dom f = {} holds f is PartFunc of X,Y;

theorem :: PARTFUN1:56
    {} is PartFunc of X,Y;

theorem :: PARTFUN1:57
   for f being PartFunc of {},Y holds f = {};

theorem :: PARTFUN1:58
     for f1 being PartFunc of {},Y1 for f2 being PartFunc of {},Y2 holds f1 =
f2;

theorem :: PARTFUN1:59
     for f being PartFunc of {},Y holds f is one-to-one;

theorem :: PARTFUN1:60
     for f being PartFunc of {},Y holds f.:P = {};

theorem :: PARTFUN1:61
     for f being PartFunc of {},Y holds f"Q = {};

theorem :: PARTFUN1:62
   for f being PartFunc of X,{} holds dom f = {} & rng f = {};

theorem :: PARTFUN1:63
     for f being Function st rng f = {} holds f is PartFunc of X,Y;

theorem :: PARTFUN1:64
   for f being PartFunc of X,{} holds f = {};

theorem :: PARTFUN1:65
     for f1 being PartFunc of X1,{} for f2 being PartFunc of X2,{} holds f1 =
f2;

theorem :: PARTFUN1:66
     for f being PartFunc of X,{} holds f is one-to-one;

theorem :: PARTFUN1:67
     for f being PartFunc of X,{} holds f.:P = {};

theorem :: PARTFUN1:68
     for f being PartFunc of X,{} holds f"Q = {};

::::::::::::::::::::::::::::::::::::::::::::::::
:: Partial function from a singelton into set ::
::::::::::::::::::::::::::::::::::::::::::::::::

theorem :: PARTFUN1:69
   for f being PartFunc of {x},Y holds rng f c= {f.x};

theorem :: PARTFUN1:70
     for f being PartFunc of {x},Y holds f is one-to-one;

theorem :: PARTFUN1:71
     for f being PartFunc of {x},Y holds f.:P c= {f.x};

theorem :: PARTFUN1:72
     for f being Function st dom f = {x} & x in X & f.x in Y
    holds f is PartFunc of X,Y;

::::::::::::::::::::::::::::::::::::::::::::::::::
:: Partial function from a set into a singelton ::
::::::::::::::::::::::::::::::::::::::::::::::::::

theorem :: PARTFUN1:73
   for f being PartFunc of X,{y} st x in dom f holds f.x = y;

theorem :: PARTFUN1:74
     for f1,f2 being PartFunc of X,{y} st dom f1 = dom f2 holds f1 = f2;

::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: Construction of a Partial Function from a Function ::
::::::::::::::::::::::::::::::::::::::::::::::::::::::::

definition
 let f be Function; let X,Y be set;
 canceled 2;

func <:f,X,Y:> -> PartFunc of X,Y equals
:: PARTFUN1:def 3
  Y|f|X;
end;


canceled;

theorem :: PARTFUN1:76
   for f being Function holds <:f,X,Y:> c= f;

theorem :: PARTFUN1:77
   for f being Function holds dom <:f,X,Y:> c= dom f & rng <:f,X,Y:> c= rng f;

theorem :: PARTFUN1:78
   for f being Function holds x in dom <:f,X,Y:> iff x in dom f & x in X & f.x
in Y;

theorem :: PARTFUN1:79
   for f being Function st x in dom f & x in X & f.x in
 Y holds <:f,X,Y:>.x = f.x;

theorem :: PARTFUN1:80
   for f being Function st x in dom <:f,X,Y:> holds <:f,X,Y:>.x = f.x;

theorem :: PARTFUN1:81
     for f,g being Function st f c= g
    holds <:f,X,Y:> c= <:g,X,Y:>;

theorem :: PARTFUN1:82
   for f being Function st Z c= X holds <:f,Z,Y:> c= <:f,X,Y:>;

theorem :: PARTFUN1:83
   for f being Function st Z c= Y holds <:f,X,Z:> c= <:f,X,Y:>;

theorem :: PARTFUN1:84
     for f being Function st X1 c= X2 & Y1 c= Y2
    holds <:f,X1,Y1:> c= <:f,X2,Y2:>;

theorem :: PARTFUN1:85
   for f being Function st dom f c= X & rng f c= Y holds f = <:f,X,Y:>;

theorem :: PARTFUN1:86
     for f being Function holds f = <:f,dom f,rng f:>;

theorem :: PARTFUN1:87
     for f being PartFunc of X,Y holds <:f,X,Y:> = f;

canceled 3;

theorem :: PARTFUN1:91
   <:{},X,Y:> = {};

theorem :: PARTFUN1:92
   for f,g being Function
    holds (<:g,Y,Z:>*<:f,X,Y:>) c= <:g*f,X,Z:>;

theorem :: PARTFUN1:93
     for f,g being Function st rng f /\ dom g c= Y
    holds <:g,Y,Z:>*<:f,X,Y:> = <:g*f,X,Z:>;

theorem :: PARTFUN1:94
   for f being Function st f is one-to-one holds <:f,X,Y:> is one-to-one;

theorem :: PARTFUN1:95
     for f being Function st f is one-to-one holds <:f,X,Y:>" = <:f",Y,X:>;

theorem :: PARTFUN1:96
     for f being Function holds <:f,X,Y:>|Z = <:f,X /\ Z,Y:>;

theorem :: PARTFUN1:97
     for f being Function holds Z|<:f,X,Y:> = <:f,X,Z /\ Y:>;

::::::::::::::::::::
:: Total Function ::
::::::::::::::::::::

definition let X,Y; let f be Relation of X,Y;
 attr f is total means
:: PARTFUN1:def 4
 dom f = X;
end;


canceled;

theorem :: PARTFUN1:99
     for f being PartFunc of X,Y st f is total & Y = {} holds X = {};

canceled 12;

theorem :: PARTFUN1:112
   for f being PartFunc of {},Y holds f is total;

theorem :: PARTFUN1:113
   for f being Function st <:f,X,Y:> is total holds X c= dom f;

theorem :: PARTFUN1:114
     <:{},X,Y:> is total implies X = {};

theorem :: PARTFUN1:115
     for f being Function st X c= dom f & rng f c= Y holds <:f,X,Y:> is total;

theorem :: PARTFUN1:116
     for f being Function st <:f,X,Y:> is total holds f.:X c= Y;

theorem :: PARTFUN1:117
     for f being Function st X c= dom f & f.:X c= Y holds <:f,X,Y:> is total;

::::::::::::::::::::::::::::::::::::::::::::::::::::
:: set of partial functions from a set into a set ::
::::::::::::::::::::::::::::::::::::::::::::::::::::

definition let X,Y;
 func PFuncs(X,Y) -> set means
:: PARTFUN1:def 5
 x in it iff ex f being Function st x = f & dom f c= X & rng f c= Y;
end;


registration let X,Y;
 cluster PFuncs(X,Y) -> non empty;
coherence
  proof
      ex f being Function st
      dom f c= X & rng f c= Y by Lm2;
    hence thesis by Def5;
  end;
end;


canceled;

theorem :: PARTFUN1:119
   for f being PartFunc of X,Y holds f in PFuncs(X,Y);

theorem :: PARTFUN1:120
   for f being set st f in PFuncs(X,Y) holds f is PartFunc of X,Y;

theorem :: PARTFUN1:121
     for f being Element of PFuncs(X,Y) holds f is PartFunc of X,Y;

theorem :: PARTFUN1:122
     PFuncs({},Y) = { {} };

theorem :: PARTFUN1:123
     PFuncs(X,{}) = { {} };

canceled;

theorem :: PARTFUN1:125
   Z c= X implies PFuncs(Z,Y) c= PFuncs(X,Y);

theorem :: PARTFUN1:126
     PFuncs({},Y) c= PFuncs(X,Y);

theorem :: PARTFUN1:127
     Z c= Y implies PFuncs(X,Z) c= PFuncs(X,Y);

theorem :: PARTFUN1:128
     X1 c= X2 & Y1 c= Y2 implies PFuncs(X1,Y1) c= PFuncs(X2,Y2);

::::::::::::::::::::::::::::::::::::::::
:: Relation of Tolerance on Functions ::
::::::::::::::::::::::::::::::::::::::::

definition let f,g be Function;
  pred f tolerates g means
:: PARTFUN1:def 6
 for x st x in dom f /\ dom g holds f.x = g.x;
 reflexivity;
 symmetry;
end;


canceled;

theorem :: PARTFUN1:130
   for f,g being Function
    holds f tolerates g iff ex h being Function st f \/ g = h;

theorem :: PARTFUN1:131
   for f,g being Function
    holds f tolerates g iff
     ex h being Function st f c= h & g c= h;

theorem :: PARTFUN1:132
   for f,g being Function st dom f c= dom g
    holds f tolerates g iff for x st x in dom f holds f.x = g.x;

canceled 2;

theorem :: PARTFUN1:135
    for f,g being Function st f c= g holds f tolerates g;

theorem :: PARTFUN1:136
   for f,g being Function st dom f = dom g & f tolerates g holds f = g;

canceled;

theorem :: PARTFUN1:138
     for f,g being Function st dom f misses dom g holds f tolerates g;

theorem :: PARTFUN1:139
    for f,g,h being Function st f c= h & g c= h holds f tolerates g;

theorem :: PARTFUN1:140
     for f,g being PartFunc of X,Y for h being Function
    st f tolerates h & g c= f holds g tolerates h;

theorem :: PARTFUN1:141
   for f being Function holds {} tolerates f;

theorem :: PARTFUN1:142
   for f being Function holds <:{},X,Y:> tolerates f
;

theorem :: PARTFUN1:143
     for f,g being PartFunc of X,{y} holds f tolerates g;

theorem :: PARTFUN1:144
     for f being Function holds f|X tolerates f;

theorem :: PARTFUN1:145
     for f being Function holds Y|f tolerates f;

theorem :: PARTFUN1:146
   for f being Function holds Y|f|X tolerates f;

theorem :: PARTFUN1:147
     for f being Function holds <:f,X,Y:> tolerates f;

theorem :: PARTFUN1:148
   for f,g being PartFunc of X,Y st
    f is total & g is total & f tolerates g holds f = g;

canceled 9;

theorem :: PARTFUN1:158
   for f,g,h being PartFunc of X,Y st
   f tolerates h & g tolerates h & h is total holds f tolerates g;

canceled 3;

theorem :: PARTFUN1:162
   for f,g being PartFunc of X,Y st (Y = {} implies X = {}) & f tolerates g
    ex h being PartFunc of X,Y st h is total & f tolerates h & g tolerates h;

definition let X,Y; let f be PartFunc of X,Y;
 func TotFuncs f -> set means
:: PARTFUN1:def 7

   x in it iff ex g being PartFunc of X,Y st g = x &
   g is total & f tolerates g;
end;


canceled 5;

theorem :: PARTFUN1:168
  for f being PartFunc of X,Y for g being set
   st g in TotFuncs(f) holds g is PartFunc of X,Y;

theorem :: PARTFUN1:169
  for f,g being PartFunc of X,Y st g in TotFuncs(f) holds g is total;

canceled;

theorem :: PARTFUN1:171
  for f being PartFunc of X,Y for g being Function
   st g in TotFuncs(f) holds f tolerates g;

theorem :: PARTFUN1:172
     for f being PartFunc of X,{} st X <> {} holds TotFuncs(f) = {};

canceled;

theorem :: PARTFUN1:174
   for f being PartFunc of X,Y holds f is total iff TotFuncs f = {f};

theorem :: PARTFUN1:175
   for f being PartFunc of {},Y holds TotFuncs f = {f};

theorem :: PARTFUN1:176
     for f being PartFunc of {},Y holds TotFuncs f = {{}};

canceled 8;

theorem :: PARTFUN1:185
     for f,g being PartFunc of X,Y st TotFuncs f meets TotFuncs g holds
   f tolerates g;

theorem :: PARTFUN1:186
     for f,g being PartFunc of X,Y
    st (Y = {} implies X = {}) & f tolerates g holds
    TotFuncs f meets TotFuncs g;

begin

registration let X;
 cluster total reflexive symmetric antisymmetric transitive Relation of X;
 existence
  proof reconsider R = id X as Relation of X by Lm6;
   take R;
   thus thesis by Lm4,Lm5;
  end;
end;


registration
 cluster symmetric transitive -> reflexive Relation;
 coherence
  proof let R be Relation;
   assume that
A1: R is_symmetric_in field R and
A2: R is_transitive_in field R;
   let x;
   assume
A3:   x in field R;
    then x in dom R \/ rng R by RELAT_1:def 6;
    then x in dom R or x in rng R by XBOOLE_0:def 2;
    then consider y such that
A4:  [x,y] in R or [y,x] in R by RELAT_1:def 4,def 5;
A5:  field R = dom R \/ rng R by RELAT_1:def 6;
    y in rng R or y in dom R by A4,RELAT_1:def 4,def 5;
    then
A6:   y in field R by A5,XBOOLE_0:def 2;
    then [x,y] in R & [y,x] in R by A1,A3,A4,RELAT_2:def 3;
   hence [x,x] in R by A2,A3,A6,RELAT_2:def 8;
  end;
end;


registration let X;
 cluster id X -> symmetric antisymmetric transitive;
 coherence by Lm5;
end;


definition let X;
 redefine
  func id X -> total Relation of X;
end;


