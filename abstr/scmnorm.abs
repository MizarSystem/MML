:: Normal Computers
::  by Andrzej Trybulec
::
:: Received March 3, 2008
:: Copyright (c) 2008 Association of Mizar Users

environ

 vocabularies AMI_1, ORDINAL1, NAT_1, ARYTM_3, NUMBERS, ARYTM_1, SUBSET_1,
      SETFAM_1, XBOOLE_0, VALUED_1, RELAT_1, TARSKI, STRUCT_0, FUNCT_1, FSM_1,
      CAT_1, FUNCT_4, AFINSQ_1, GLIB_000, AMISTD_2, CARD_1, FUNCOP_1, FINSET_1,
      PARTFUN1, CIRCUIT2, CARD_3, XXREAL_0, MSUALG_1, TURING_1, SCMNORM;
 notations TARSKI, XBOOLE_0, SETFAM_1, ORDINAL1, FINSET_1, SUBSET_1, RELAT_1,
      FUNCT_1, PBOOLE, FUNCT_2, PARTFUN1, FUNCT_4, FUNCOP_1, CARD_1, CARD_3,
      AFINSQ_1, NUMBERS, VALUED_1, XXREAL_0, XCMPLX_0, XREAL_0, NAT_1, NAT_D,
      STRUCT_0, AMI_1;
 constructors NAT_1, NAT_D, AMI_1, VALUED_1, XXREAL_0, AFINSQ_1, FUNCT_4,
      DOMAIN_1, PARTFUN1, WELLORD2, RELSET_1, PRE_POLY, PBOOLE;
 registrations ORDINAL1, XREAL_0, CARD_3, AMI_1, RELSET_1, XBOOLE_0, SETFAM_1,
      VALUED_1, RELAT_1, FINSET_1, AFINSQ_1, FUNCT_1, FINSEQ_1, CARD_1, NAT_1,
      GRFUNC_1, PBOOLE, FRAENKEL, FUNCT_2, FUNCT_4;
 requirements BOOLE, SUBSET, NUMERALS, ARITHM;


begin

definition
  let l be Element of NAT;
  redefine func succ l -> Element of NAT;
end;

reserve m,j for Element of NAT;

definition
  let N be with_non-empty_elements non empty set,
  S be definite (stored-program non empty AMI-Struct over N);
  let p be PartState of S, k be Element of NAT;
  redefine func Shift(p,k) -> PartState of S;
end;

registration
  let N be set;
  let S be AMI-Struct over N;
  let p be NAT-defined (the Instructions of S)-valued Function,
      k be Element of NAT;
  cluster Shift(p,k) -> (the Instructions of S)-valued;
end;

definition
  let N be set;
  let S be AMI-Struct over N;
  mode preProgram of S is NAT-defined FinPartState of S;
end;

registration
  let N be with_non-empty_elements set;
  let S be AMI-Struct over N;
  cluster empty FinPartState of S;
end;

registration
  let N be set;
  let S be AMI-Struct over N;
  cluster empty -> NAT-defined FinPartState of S;
end;

registration
  let N be set;
  let S be AMI-Struct over N;
  cluster initial preProgram of S;
end;

definition
  let N be set;
  let S be AMI-Struct over N;
  mode Program of S is initial preProgram of S;
end;

definition
 canceled;
  let N be non empty with_non-empty_elements set;
  let S be halting definite (non empty stored-program AMI-Struct over N);
  func Stop S -> Program of S equals
:: SCMNORM:def 2
  <% halt S %>;
end;

registration
  let N be non empty with_non-empty_elements set;
  let S be halting definite (non empty stored-program AMI-Struct over N);
  cluster Stop S -> non empty;
end;

registration
  let N be non empty with_non-empty_elements set;
  let S be halting definite (non empty stored-program AMI-Struct over N);
  cluster initial NAT-defined non empty FinPartState of S;
end;

reserve N for non empty with_non-empty_elements set,
  S for halting definite (non empty stored-program AMI-Struct over N);

canceled;

theorem :: SCMNORM:2
  0 in dom Stop S;

theorem :: SCMNORM:3
  card Stop S = 1;

registration
  let N be with_non-empty_elements non empty set;
  let S be IC-Ins-separated definite
  (non empty stored-program AMI-Struct over N);
  let I be initial FinPartState of S;
  cluster ProgramPart I -> initial Function;
end;

definition
  canceled 4;
  let N be non empty with_non-empty_elements set;
  let S be IC-Ins-separated definite
  (non empty stored-program AMI-Struct over N);
  let p be finite NAT-defined (the Instructions of S)-valued Function;
  mode Autonomy of p -> FinPartState of S means
:: SCMNORM:def 7

    for s1,s2 being State of S st it c= s1 & it c= s2
    for q being finite NAT-defined (the Instructions of S)-valued Function
    st p c= q
    for i being Nat holds Comput(p,s1,i)|dom it = Comput(q,s2,i)|dom it;
end;

reserve N for non empty with_non-empty_elements set;

definition
 canceled;
  let N be non empty with_non-empty_elements set;
  let S be IC-Ins-separated halting definite
  (non empty stored-program AMI-Struct over N);
  let f be finite NAT-defined (the Instructions of S)-valued Function;
  let p be Autonomy of f;
  attr p is halting means
:: SCMNORM:def 9

  for s being State of S st p c= s holds
  f halts_on s;
end;

reserve i,j for Nat;

canceled 3;

theorem :: SCMNORM:7
  i <= j implies for N for S being halting IC-Ins-separated definite
  (non empty stored-program AMI-Struct over N),
  f be finite NAT-defined (the Instructions of S)-valued Function
  for s being State of S st CurInstr(f,Comput(f,s,i)) = halt S
  holds Comput(f,s,j) = Comput(f,s,i);

definition
  let N be non empty with_non-empty_elements set;
  let S be halting IC-Ins-separated definite
  (non empty stored-program AMI-Struct over N);
  let f be finite NAT-defined (the Instructions of S)-valued Function;
  let s be State of S such that
 f halts_on s;
  func Result(f,s) -> State of S means
:: SCMNORM:def 10

  ex k being Nat st it = Comput(f,s,k) & CurInstr(f,it) = halt S;
end;

definition
  let N be non empty with_non-empty_elements set;
  let S be realistic halting IC-Ins-separated definite
  (non empty stored-program AMI-Struct over N);
  let f be finite NAT-defined (the Instructions of S)-valued Function;
  let p be Autonomy of f;
  assume
 p is halting;
  func Result(f,p) -> FinPartState of S means
:: SCMNORM:def 11
  for p9 being State of S st p c= p9 holds it = Result(f, p9
)|dom p;
end;

definition
  let N be non empty with_non-empty_elements set;
let S be realistic halting IC-Ins-separated definite
(non empty stored-program AMI-Struct over N);
  let f be finite NAT-defined (the Instructions of S)-valued Function;
  let p be FinPartState of S, F be Function;
  pred f,p computes F means
:: SCMNORM:def 12
  for s being FinPartState of S st s in dom F
  ex q being Autonomy of f st q = p +* s & q is halting & F.s c= Result(
f,q);
end;

reserve j,k for Element of NAT;

theorem :: SCMNORM:8
  for S being IC-Ins-separated definite
  halting (non empty stored-program AMI-Struct over N)
  for s being State of S,
  f being finite NAT-defined (the Instructions of S)-valued Function,
  k st IC Comput(f,s,k) in dom f & f/.IC Comput(f,s,k) = halt S
  holds Result(f,s) = Comput(f,s,k);

:: from RELOC, SCMFSA_4, SCMPDS_3, 2008.04.12, A.T. (generalized)

reserve N for with_non-empty_elements non empty set,
  S for IC-Ins-separated (non empty AMI-Struct over N),
  s for State of S;

theorem :: SCMNORM:9
  for l1,l2 being Element of NAT, k being Element of NAT holds
  Start-At(l1 + k,S) = Start-At(l2 +k,S) iff Start-At(l1,S) = Start-At(l2,S);

theorem :: SCMNORM:10
  for l1,l2 being Element of NAT, k being Nat
  st Start-At(l1,S) = Start-At(l2,S)
   holds Start-At(l1 -' k,S) = Start-At(l2 -' k,S);

definition
  let N,S;
  let p be FinPartState of S, k be Element of NAT;
  func IncrIC(p,k) -> FinPartState of S equals
:: SCMNORM:def 13
  p +* Start-At(IC p+k,S);
end;

theorem :: SCMNORM:11
  for l being Element of NAT
  holds DataPart Start-At(l,S) = {};

theorem :: SCMNORM:12
  for p being FinPartState of S, k being Element of NAT
  holds DataPart IncrIC(p,k) = DataPart p;

theorem :: SCMNORM:13
  Data-Locations S c= dom s;

theorem :: SCMNORM:14
  dom DataPart s = Data-Locations S;

reserve N for non empty with_non-empty_elements set,
  S for halting definite IC-Ins-separated realistic
  (non empty stored-program AMI-Struct over N),
  p for FinPartState of S,
  l for Element of NAT,
  k for Element of NAT;

theorem :: SCMNORM:15
  NAT misses Data-Locations S;

canceled;

theorem :: SCMNORM:17
  IC S in dom Start-At(l,S);

theorem :: SCMNORM:18
  IC S in dom IncrIC(p,k);

theorem :: SCMNORM:19
  IC Start-At(l,S) = l;

theorem :: SCMNORM:20
  IncrIC(p,k).IC S = IC p + k;

theorem :: SCMNORM:21
  not IC S in Data-Locations S;

theorem :: SCMNORM:22
  for d being data-only FinPartState of S
  holds not IC S in dom d;

theorem :: SCMNORM:23
  for d being data-only FinPartState of S
  holds IC (p+*d) = IC p;

theorem :: SCMNORM:24
  for d being data-only FinPartState of S
  holds d tolerates Start-At(l,S);

theorem :: SCMNORM:25
  for d being data-only FinPartState of S
  holds IncrIC(p+*d,k) = IncrIC(p,k) +* d;

theorem :: SCMNORM:26
  for d being data-only FinPartState of S,
  f being finite NAT-defined (the Instructions of S)-valued Function
  holds d tolerates f;

theorem :: SCMNORM:27
  for d being data-only FinPartState of S
  holds IncrIC(d,k)|NAT = {};

theorem :: SCMNORM:28 :: AMI_1:55
  for S being IC-Ins-separated definite
  (non empty stored-program AMI-Struct over N),
  p be finite NAT-defined (the Instructions of S)-valued Function
 for s being State of S
  holds Comput(p,s,k+1) = Exec(p/.(IC Comput(p,s,k)), Comput(p,s,k));

definition
 canceled;
  let N;
  let S be IC-Ins-separated halting
  (non empty AMI-Struct over N);
  let p be finite NAT-defined (the Instructions of S)-valued Function,
      l be set;
  pred p halts_at l means
:: SCMNORM:def 15 :: AMI_1:def 45
 l in dom p & p.l = halt S;
end;

theorem :: SCMNORM:29
  for S being IC-Ins-separated halting definite
(non empty stored-program AMI-Struct over N),
  p be finite NAT-defined (the Instructions of S)-valued Function,
    s being State of S holds p halts_on s
   iff ex i st p halts_at IC Comput(p,s,i);

theorem :: SCMNORM:30
  for S being halting IC-Ins-separated definite
(non empty stored-program AMI-Struct over N),
  p be finite NAT-defined (the Instructions of S)-valued Function,
  s being State of S,
    k being Nat st p halts_on s
  holds Result(p,s) = Comput(p,s,k) iff p halts_at IC Comput(p
,s,k);

theorem :: SCMNORM:31
  for N for S being halting IC-Ins-separated definite
  (non empty stored-program AMI-Struct over N),
  p be finite NAT-defined (the Instructions of S)-valued Function,
  s being State of S, i st p halts_at IC Comput(p,s,i)
   holds Result(p,s) = Comput(p,s,i);

theorem :: SCMNORM:32
  i <= j implies for N for S being halting definite
IC-Ins-separated (non empty stored-program AMI-Struct over N),
  p be finite NAT-defined (the Instructions of S)-valued Function
 for s
  being State of S st p halts_at IC Comput(p,s,i)
   holds p halts_at IC Comput(p,s,j);

theorem :: SCMNORM:33 :: AMI_1:89
  i <= j implies for N for S being halting IC-Ins-separated definite
    (non empty stored-program AMI-Struct over N),
  p be finite NAT-defined (the Instructions of S)-valued Function
 for s being State of S st p halts_at IC Comput(p,s,i)
   holds Comput(p,s,j) = Comput(p,s,i);

theorem :: SCMNORM:34
   for N for S being halting definite
IC-Ins-separated (non empty stored-program AMI-Struct over N),
  p be finite NAT-defined (the Instructions of S)-valued Function
 for s being State of S
  for k holds Comput(p,s,i+k) = Comput(p,Comput(p,s,i),k);

theorem :: SCMNORM:35
  for N
  for S being IC-Ins-separated halting definite
(non empty stored-program AMI-Struct over N),
  p be finite NAT-defined (the Instructions of S)-valued Function
for s being State of S, k
    st IC Comput(p,s,k) in dom p & p.IC Comput(p,s,k) = halt S
  holds Result(p,s) = Comput(p,s,k);

theorem :: SCMNORM:36
  for N
  for S being IC-Ins-separated halting definite
  (non empty stored-program AMI-Struct over N),
  p be finite NAT-defined (the Instructions of S)-valued Function
 for s being State of S st
  ex k st IC Comput(p,s,k) in dom p & p.IC Comput(p,s,k) = halt S
 for i holds Result(p,s) = Result(p,Comput(p,s,i));

theorem :: SCMNORM:37
  for N
  for S being IC-Ins-separated halting definite (non
empty stored-program AMI-Struct over N),
  p be finite NAT-defined (the Instructions of S)-valued Function
 for s being State of S st
  ex k st p halts_at IC Comput(p,s,k)
   for i holds Result(p,s) = Result(p,Comput(p,s,i));

theorem :: SCMNORM:38
  for N
  for S being IC-Ins-separated halting definite
  (non empty stored-program AMI-Struct over N),
  p be finite NAT-defined (the Instructions of S)-valued Function,
      s being State of S holds
  p halts_on s iff ex k being Nat st p halts_at IC Comput(p,s,k);

