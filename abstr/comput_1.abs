:: The set of primitive recursive functions
::  by Grzegorz Bancerek and Piotr Rudnicki
::
:: Received July 27, 2001
:: Copyright (c) 2001 Association of Mizar Users

environ

 vocabulary RELAT_1, FUNCT_1, FINSEQ_1, FINSEQ_2, FUNCT_4, MATRIX_2, BOOLE,
      PARTFUN1, SETFAM_1, FUNCT_6, MSUALG_6, FRAENKEL, TARSKI, RFUNCT_3,
      SEQM_3, UNIALG_1, FUNCOP_1, FUNCT_2, PRALG_3, ORDINAL1, FINSEQ_4,
      BORSUK_1, PROB_1, FUNCT_5, FINSET_1, SQUARE_1, BINTREE1, CARD_3,
      MONOID_0, QC_LANG1, GROUP_1, ARYTM_1, COMPUT_1;
 notation TARSKI, XBOOLE_0, ZFMISC_1, SUBSET_1, NUMBERS, XCMPLX_0, XREAL_0,
      NAT_1, RELAT_1, RELSET_1, FUNCT_1, FINSEQ_1, FINSEQ_2, SETFAM_1,
      MATRIX_2, FRAENKEL, FUNCT_2, FUNCT_4, FUNCT_5, PROB_1, CARD_3, PRE_CIRC,
      FINSEQ_4, PARTFUN1, RFUNCT_3, PRALG_3, UNIALG_1, FUNCT_6, FUNCT_7,
      FINSET_1, SQUARE_1, NEWTON, SEQM_3, BINARITH, CARD_4;
 constructors DOMAIN_1, MATRIX_2, FINSEQ_4, PRALG_3, RFUNCT_3, FUNCT_7,
      PRE_CIRC, BINARITH, SEQM_3, CARD_4, PROB_1;
 clusters XREAL_0, PARTFUN1, RELAT_1, RELSET_1, FUNCT_1, FUNCOP_1, ALTCAT_1,
      FINSEQ_1, FINSEQ_2, FUNCT_7, FINSET_1, SUBSET_1, NAT_1, FRAENKEL,
      MEMBERED, PRE_CIRC, NUMBERS, ORDINAL2;
 requirements NUMERALS, REAL, BOOLE, SUBSET, ARITHM;


begin :: Preliminaries

reserve i, j, k, c, m, n for Nat,
        a, x, y, z, X, Y for set,
        D, E for non empty set,
        R for Relation,
        f, g for Function,
        p, q for FinSequence;

definition
 let X be non empty set, n be Nat, p be Element of n-tuples_on X,
     i be Nat, x be Element of X;
 redefine func p+*(i,x) -> Element of n-tuples_on X;
end;


definition
 let n be Nat, t be Element of n-tuples_on NAT, i be Nat;
 redefine func t.i -> Element of NAT;
end;


canceled 2;

theorem :: COMPUT_1:3
<*x,y*>+*(1,z) = <*z,y*> & <*x,y*>+*(2,z) = <*x,z*>;

canceled;

theorem :: COMPUT_1:5
f+*(a,x) = g+*(a,y) implies f+*(a,z) = g+*(a,z);

theorem :: COMPUT_1:6
Del(p+*(i,x),i) = Del(p,i);

theorem :: COMPUT_1:7
p+*(i,a) = q+*(i,a) implies Del(p,i) = Del(q,i);

theorem :: COMPUT_1:8
0-tuples_on X = {{}};

theorem :: COMPUT_1:9
  n <> 0 implies n-tuples_on {} = {};

theorem :: COMPUT_1:10
{} in rng f implies <:f:> = {};

theorem :: COMPUT_1:11
rng f = D implies rng <:<*f*>:> = 1-tuples_on D;

theorem :: COMPUT_1:12
1 <= i & i <= n+1 implies
  for p being Element of (n+1)-tuples_on D holds Del(p,i) in n-tuples_on D;

theorem :: COMPUT_1:13
for X being set, Y being FinSequenceSet of X holds Y c= X*;

begin :: Sets of compatible functions

definition
 let X be set;
 attr X is compatible means
:: COMPUT_1:def 1
 for f,g being Function st f in X & g in X holds f tolerates g;
end;


registration
 cluster non empty functional compatible set;
 existence proof set A = {{}};
A1: A is compatible proof let f, g be Function; assume f in A & g in A;
    then f={} by TARSKI:def 1; then f c= g by XBOOLE_1:2;
    hence f tolerates g by PARTFUN1:135;
   end; take A; thus thesis by A1;
 end;
end;


registration
 let X be functional compatible set;
 cluster union X -> Function-like Relation-like;
 coherence proof thus union X is Function-like proof let x,y1,y2 be set;
assume
  A1: [x,y1] in union X & [x,y2] in union X; then consider f being set such
that
  A2: [x,y1] in f & f in X by TARSKI:def 4; consider g being set such that
  A3: [x,y2] in g & g in X by A1,TARSKI:def 4;
     reconsider f, g as Function by A2,A3,FRAENKEL:def 1;
  A4: x in dom f & x in dom g by A2,A3,RELAT_1:def 4;
  then A5: f.x = y1 & g.x = y2 by A2,A3,FUNCT_1:def 4;
  A6: x in dom f /\ dom g by A4,XBOOLE_0:def 3
; f tolerates g by A2,A3,Def1
;
   hence y1 = y2 by A5,A6,PARTFUN1:def 6;
  end;
  thus union X is Relation-like proof let x be set; assume
       x in union X; then consider f being set such that
  A7: x in f & f in X by TARSKI:def 4;
    f is Function by A7,FRAENKEL:def 1; then consider y, z being set such
that
  A8: x = [y,z] by A7,RELAT_1:def 1; thus thesis by A8;
  end;
 end;
end;


theorem :: COMPUT_1:14
X is functional compatible iff union X is Function;

registration
 let X,Y be set;
 cluster non empty compatible PFUNC_DOMAIN of X,Y;
 existence proof set A = {{}};
     now let x be Element of A;
   A1: x = {} by TARSKI:def 1; dom {} c= X & rng {} c= Y by XBOOLE_1:2;
    hence x is PartFunc of X, Y by A1,RELSET_1:11;
   end;
then A2: A is PFUNC_DOMAIN of X,Y by RFUNCT_3:def 3;
     A is compatible proof let f, g be Function;
   assume f in A & g in A; then f = {} by TARSKI:def 1; then f c= g by XBOOLE_1
:2;
    hence f tolerates g by PARTFUN1:135;
    end;
  hence thesis by A2;
 end;
end;


theorem :: COMPUT_1:15
for X being non empty functional compatible set
 holds dom union X = union {dom f where f is Element of X: not contradiction};

theorem :: COMPUT_1:16
for X being functional compatible set, f being Function st f in X holds
 dom f c= dom union X & for x being set st x in dom f holds (union X).x = f.x;

theorem :: COMPUT_1:17
for X being non empty functional compatible set
 holds rng union X = union {rng f where f is Element of X: not contradiction};

registration let X,Y;
  cluster -> functional PFUNC_DOMAIN of X,Y;
  coherence
  proof
    let P be PFUNC_DOMAIN of X,Y;
    let x be set;
    assume x in P;
    hence thesis by RFUNCT_3:def 3;
  end;
end;


theorem :: COMPUT_1:18
for P being compatible PFUNC_DOMAIN of X,Y holds union P is PartFunc of X,Y;

begin :: Homogeneous relations

notation
 let f be Relation;
 synonym f is to-naturals for f is natural-yielding;
 end;


definition
 let f be Relation;
 attr f is from-natural-fseqs means
:: COMPUT_1:def 2
 dom f c= NAT*;
end;


registration
 cluster from-natural-fseqs to-naturals Function;
existence proof take f={}; thus dom f c= NAT* & rng f c= NAT by XBOOLE_1:2
; end;
end;


definition
 let f be from-natural-fseqs Relation;
 attr f is len-total means
:: COMPUT_1:def 3
 for x,y being FinSequence of NAT
  st len x = len y & x in dom f holds y in dom f;
end;


definition
 let f be Relation;
 attr f is homogeneous means
:: COMPUT_1:def 4
 for x,y being FinSequence st x in dom f & y in dom f holds len x = len y;
end;


theorem :: COMPUT_1:19
dom R c= n-tuples_on D implies R is homogeneous;

registration
 cluster {} -> homogeneous;
 coherence proof let x,y be FinSequence; assume x in dom {}; thus thesis; end
;
end;


registration
 let p be FinSequence, x be set;
 cluster {p} --> x -> non empty homogeneous;
 coherence proof set f = {p} --> x;
 A1: dom f = {p} by FUNCOP_1:19;
   thus f is non empty by FUNCOP_1:19,RELAT_1:60; let x,y be FinSequence;
assume
      x in dom f & y in dom f; then x = p & y = p by A1,TARSKI:def 1;
   hence thesis;
  end;
end;


registration
 cluster non empty homogeneous Function;
existence proof consider p being FinSequence;take {p}-->0; thus thesis; end;
end;


registration
 let f be homogeneous Function, g be Function;
 cluster g*f -> homogeneous;
 coherence proof let x,y be FinSequence such that
A1:  x in dom (g*f) & y in dom (g*f); dom (g*f) c= dom f by RELAT_1:44; hence
 thesis by A1,Def4;
  end;
end;


registration
 let X,Y be set;
 cluster homogeneous PartFunc of X*, Y;
 existence proof set f = {}; dom f c= X* & rng f c= Y by XBOOLE_1:2;
   then reconsider f as PartFunc of X*, Y by RELSET_1:11;
   take f; let x,y be FinSequence; assume
      x in dom f & y in dom f;
   hence thesis by RELAT_1:60;
  end;
end;


registration
 let X,Y be non empty set;
 cluster non empty homogeneous PartFunc of X*, Y;
 existence proof consider n being Nat, y being Element of Y;
   reconsider Z = n-tuples_on X as non empty Subset of X* by Th13;
   reconsider f = Z --> y as PartFunc of X*, Y;
   take f;
A1:  dom f = Z by FUNCOP_1:19;
   thus f is non empty by FUNCOP_1:19,RELAT_1:60;
   let x,y be FinSequence; assume x in dom f & y in dom f;
    then len x = n & len y = n by A1,FINSEQ_2:109;
   hence thesis;
  end;
end;


registration
 let X be non empty set;
 cluster non empty homogeneous quasi_total PartFunc of X*, X;
 existence proof consider n being Nat, y being Element of X;
   reconsider Z = n-tuples_on X as non empty Subset of X* by Th13;
   reconsider f = Z --> y as PartFunc of X*, X;
   take f;
A1:  dom f = Z by FUNCOP_1:19;
   thus f is non empty by FUNCOP_1:19,RELAT_1:60;
   thus f is homogeneous proof let x,y be FinSequence; assume
        x in dom f & y in dom f; then len x = n & len y = n by A1,FINSEQ_2:109
;
     hence thesis;
    end;
   let p,q be FinSequence of X; assume len p = len q & p in dom f;
    then len q = n by A1,FINSEQ_2:109; then q is Element of Z by FINSEQ_2:110
;
   hence thesis by A1;
  end;
end;


registration
 cluster non empty homogeneous to-naturals len-total
         (from-natural-fseqs Function);
 existence proof consider n, m being Nat;
   reconsider Z = n-tuples_on NAT as non empty Subset of NAT* by Th13;
   set f = Z --> m;
A1: dom f = Z & rng f c= {m} by FUNCOP_1:19;
    then reconsider f as from-natural-fseqs Function by Def2;
   take f;
A2: f is homogeneous proof let x,y be FinSequence; assume
       x in dom f & y in dom f; then len x = n & len y = n by A1,FINSEQ_2:109;
    hence thesis;
   end; {m} is Subset of NAT by SUBSET_1:55;
   then A3: rng f c= NAT by A1,XBOOLE_1:1;
  f is len-total proof let x,y be FinSequence of NAT such that
    A4: len x = len y and
    A5: x in dom f;
    A6: y is Element of (len y)-tuples_on NAT by FINSEQ_2:110;
         len x = n by A1,A5,FINSEQ_2:109;
     hence y in dom f by A1,A4,A6;
    end;
   hence thesis by A2,A3,FUNCOP_1:19,RELAT_1:60,SEQM_3:def 8;
 end;
end;


registration
cluster -> to-naturals from-natural-fseqs PartFunc of NAT*, NAT;
coherence proof let f be PartFunc of NAT*,NAT; A1: rng f c=NAT by RELSET_1:12;
 dom f c= NAT*;
  hence thesis by A1,Def2,SEQM_3:def 8;
 end;
end;


registration
cluster quasi_total -> len-total PartFunc of NAT*,NAT;
coherence proof let f be PartFunc of NAT*,NAT; assume
  A1: f is quasi_total; let x,y be FinSequence of NAT such that
  A2: len x = len y & x in dom f;
  thus y in dom f by A1,A2,UNIALG_1:def 2;
 end;
end;


theorem :: COMPUT_1:20
for g being len-total to-naturals (from-natural-fseqs Function)
 holds g is quasi_total PartFunc of NAT*, NAT;

definition
 let f be homogeneous Relation;
 func arity f -> Nat means
:: COMPUT_1:def 5
  for x being FinSequence st x in dom f holds it = len x
   if ex x being FinSequence st x in dom f
   otherwise it = 0;
end;


theorem :: COMPUT_1:21
arity {} = 0;

theorem :: COMPUT_1:22
for f being homogeneous Relation st dom f = {{}} holds arity f = 0;

theorem :: COMPUT_1:23
for f being homogeneous PartFunc of X*, Y holds dom f c= (arity f)-tuples_on X;

theorem :: COMPUT_1:24
for f being homogeneous from-natural-fseqs Function
 holds dom f c= (arity f)-tuples_on NAT;

theorem :: COMPUT_1:25
for f being homogeneous PartFunc of X*, X
 holds f is quasi_total non empty iff dom f = (arity f)-tuples_on X;

theorem :: COMPUT_1:26
for f being homogeneous to-naturals from-natural-fseqs Function
 holds f is len-total non empty iff dom f = (arity f)-tuples_on NAT;

theorem :: COMPUT_1:27
  for f being non empty homogeneous PartFunc of D*, D, n
 st dom f c= n-tuples_on D holds arity f = n;

theorem :: COMPUT_1:28
for f being homogeneous PartFunc of D*, D, n
 st dom f = n-tuples_on D holds arity f = n;

definition
 let R be Relation;
 attr R is with_the_same_arity means
:: COMPUT_1:def 6
  for f,g being Function st f in rng R & g in rng R holds
   (f is empty implies g is empty or dom g = {{}}) &
   (f is non empty & g is non empty implies
     ex n being Nat, X being non empty set
      st dom f c= n-tuples_on X & dom g c= n-tuples_on X);
end;


registration
 cluster {} -> with_the_same_arity;
 coherence proof let f, g be Function; thus thesis; end;
end;


registration
 cluster with_the_same_arity FinSequence;
 existence proof take {}; thus thesis; end;

 let X be set;
 cluster with_the_same_arity FinSequence of X;
 existence proof take <*>X; thus thesis; end;
 cluster with_the_same_arity Element of X*;
 existence proof reconsider p = <*>X as Element of X* by FINSEQ_1:def 11;
   take p; thus thesis;
 end;
end;


definition
 let F be with_the_same_arity Relation;
 func arity F -> Nat means
:: COMPUT_1:def 7
  for f being homogeneous Function st f in rng F holds it = arity f
   if ex f being homogeneous Function st f in rng F
   otherwise it = 0;
end;


theorem :: COMPUT_1:29
  for F be with_the_same_arity FinSequence st len F = 0 holds arity F = 0;

definition
 let X be set;
 func HFuncs X -> PFUNC_DOMAIN of X*, X equals
:: COMPUT_1:def 8
  {f where f is Element of PFuncs(X*, X): f is homogeneous};
end;


theorem :: COMPUT_1:30
{} in HFuncs X;

registration
 let X be non empty set;
 cluster non empty homogeneous quasi_total Element of HFuncs X;
 existence proof consider x being Element of X; set p = <*>X;
      p in X* by FINSEQ_1:def 11;
   then reconsider Y = {p} as Subset of X* by ZFMISC_1:37;
     {p} --> x is homogeneous & Y --> x in PFuncs(X*, X);
   then {p} --> x in {f where f is Element of PFuncs(X*
, X): f is homogeneous};
   then reconsider f = {p} --> x as Element of HFuncs X by Def8;
   take f;
A1:  dom f = {p} by FUNCOP_1:19;
   thus f is non empty homogeneous; let a,b be FinSequence of X such that
A2:  len a = len b; assume a in dom f; then a = p by A1,TARSKI:def 1;
    then len b = 0 by A2,FINSEQ_1:25; then b = {} by FINSEQ_1:25;
   hence thesis by A1,TARSKI:def 1;
  end;
end;


registration
 let X be set;
 cluster -> homogeneous Element of HFuncs X;
 coherence proof let f be Element of HFuncs X;
      HFuncs X = {g where g is Element of PFuncs(X*, X): g is homogeneous} &
    f in HFuncs X by Def8;
    then ex g being Element of PFuncs(X*, X) st f = g & g is homogeneous;
   hence thesis;
  end;
end;


registration
 let X be non empty set, S be non empty Subset of HFuncs X;
 cluster -> homogeneous Element of S;
 coherence proof let f be Element of S;
      HFuncs X = {g where g is Element of PFuncs(X*, X): g is homogeneous} &
    f in HFuncs X by Def8;
    then ex g being Element of PFuncs(X*, X) st f = g & g is homogeneous;
   hence thesis;
  end;
end;


theorem :: COMPUT_1:31
for f being to-naturals homogeneous from-natural-fseqs Function
 holds f is Element of HFuncs NAT;

theorem :: COMPUT_1:32
for f being len-total to-naturals (homogeneous from-natural-fseqs Function)
 holds f is quasi_total Element of HFuncs NAT;

theorem :: COMPUT_1:33
for X being non empty set, F being Relation
 st rng F c= HFuncs X &
    for f,g being homogeneous Function st f in rng F & g in rng F
     holds arity f = arity g
  holds F is with_the_same_arity;

definition
 let n, m be Nat;
 func n const m -> homogeneous to-naturals from-natural-fseqs Function equals
:: COMPUT_1:def 9
 (n-tuples_on NAT) --> m;
end;


theorem :: COMPUT_1:34
n const m in HFuncs NAT;

registration
 let n,m be Nat;
 cluster n const m -> len-total non empty;
 coherence proof set X = NAT;
A1: dom (n const m) = dom ((n-tuples_on X)-->m) by Def9
   .= n-tuples_on X by FUNCOP_1:19;
     n const m is len-total proof let x, y be FinSequence of X; assume
   A2: len x = len y & x in dom (n const m); then len x = n by A1,FINSEQ_2:109
;
       then y is Element of n-tuples_on X by A2,FINSEQ_2:110;
     hence y in dom (n const m) by A1;
   end;
  hence thesis by A1,RELAT_1:60;
 end;
end;


theorem :: COMPUT_1:35
arity (n const m) = n;

theorem :: COMPUT_1:36
for t being Element of n-tuples_on NAT holds (n const m).t = m;

definition
 let n,i be Nat;
 func n succ i -> homogeneous to-naturals from-natural-fseqs Function means
:: COMPUT_1:def 10
  dom it = n-tuples_on NAT &
  for p being Element of n-tuples_on NAT holds it.p = (p/.i)+1;
end;


theorem :: COMPUT_1:37
n succ i in HFuncs NAT;

registration
 let n,i be Nat;
 cluster n succ i -> len-total non empty;
 coherence proof
 A1: dom (n succ i) = n-tuples_on NAT by Def10;
      (n succ i) is len-total proof let x, y be FinSequence of NAT; assume
    A2: len x = len y & x in dom (n succ i); then len x = n by A1,FINSEQ_2:109
;
        then y is Element of n-tuples_on NAT by A2,FINSEQ_2:110;
     hence y in dom (n succ i) by A1;
    end; hence thesis by A1,RELAT_1:60;
 end;
end;


theorem :: COMPUT_1:38
arity (n succ i) = n;

definition
 let n,i be Nat;
 func n proj i -> homogeneous to-naturals from-natural-fseqs Function equals
:: COMPUT_1:def 11
  proj(n|->NAT, i);
end;


theorem :: COMPUT_1:39
n proj i in HFuncs NAT;

theorem :: COMPUT_1:40
dom (n proj i) = n-tuples_on NAT &
(1 <= i & i <= n implies rng (n proj i) = NAT);

registration
 let n,i be Nat;
 cluster n proj i -> len-total non empty;
 coherence proof
   A1: dom (n proj i) = n-tuples_on NAT by Th40;
     n proj i is len-total proof let x, y be FinSequence of NAT; assume
       A2: len x=len y & x in dom (n proj i); then len x=n by A1,FINSEQ_2:109;
           then y is Element of n-tuples_on NAT by A2,FINSEQ_2:110;
        hence y in dom (n proj i) by A1;
       end;
   hence thesis by A1,RELAT_1:60;
 end;
end;


theorem :: COMPUT_1:41
arity (n proj i) = n;

theorem :: COMPUT_1:42
for t being Element of n-tuples_on NAT holds (n proj i).t = t.i;

registration let X be set;
  cluster HFuncs X -> functional;
  coherence;
end;


theorem :: COMPUT_1:43
for F being Function of D, HFuncs E
 st rng F is compatible &
    for x being Element of D holds dom (F.x) c= n-tuples_on E
  ex f being Element of HFuncs E st f = Union F & dom f c= n-tuples_on E;

theorem :: COMPUT_1:44
  for F being Function of NAT, HFuncs D
 st for i holds F.i c= F.(i+1) holds Union F in HFuncs D;

theorem :: COMPUT_1:45
for F being with_the_same_arity FinSequence of HFuncs D
 holds dom <:F:> c= (arity F)-tuples_on D;

registration
 let X be non empty set;
 let F be with_the_same_arity FinSequence of HFuncs X;
 cluster <:F:> -> homogeneous;
 coherence proof let x,y be FinSequence such that
A1: x in dom <:F:> & y in dom <:F:>;
  dom <:F:> c= (arity F)-tuples_on X by Th45;
    then len x = arity F & len y = arity F by A1,FINSEQ_2:109;
   hence len x = len y;
  end;
end;


theorem :: COMPUT_1:46
for f being Element of HFuncs D,
    F being with_the_same_arity FinSequence of HFuncs D
  holds dom (f*<:F:>) c= (arity F)-tuples_on D & rng (f*<:F:>) c= D &
             f*<:F:> in HFuncs D;

definition
 let X,Y be non empty set, P be PFUNC_DOMAIN of X,Y;
 let S be non empty Subset of P;
 redefine mode Element of S -> Element of P;
end;


registration
 let f be homogeneous from-natural-fseqs Function;
 cluster <*f*> -> with_the_same_arity;
 coherence proof let h,g be Function such that
A1: h in rng <*f*> & g in rng <*f*>; rng <*f*> = {f} by FINSEQ_1:56;
then A2: h = f & g = f by A1,TARSKI:def 1;
   hence h is empty implies g is empty or dom g = {{}};
   assume h is non empty & g is non empty; take i = arity f,NAT;
   thus dom h c= i-tuples_on NAT & dom g c= i-tuples_on NAT by A2,Th24;
  end;
end;


theorem :: COMPUT_1:47
  for f being homogeneous to-naturals from-natural-fseqs Function
 holds arity <*f*> = arity f;

theorem :: COMPUT_1:48
for f,g being non empty Element of HFuncs NAT,
    F being with_the_same_arity FinSequence of HFuncs NAT
 st g = f*<:F:> holds arity g = arity F;

theorem :: COMPUT_1:49
for f being non empty quasi_total Element of HFuncs D,
    F being with_the_same_arity FinSequence of HFuncs D
 st arity f = len F & F is non empty &
    (for h being Element of HFuncs D st h in rng F
      holds h is quasi_total non empty)
  holds f*<:F:> is non empty quasi_total Element of HFuncs D &
        dom (f*<:F:>) = (arity F)-tuples_on D;

theorem :: COMPUT_1:50
for f being quasi_total Element of HFuncs D,
    F being with_the_same_arity FinSequence of HFuncs D
 st arity f = len F &
    for h being Element of HFuncs D st h in rng F holds h is quasi_total
  holds f*<:F:> is quasi_total Element of HFuncs D;

theorem :: COMPUT_1:51
for f,g being non empty quasi_total Element of HFuncs D
 st arity f = 0 & arity g = 0 & f.{} = g.{} holds f = g;

theorem :: COMPUT_1:52
for f,g being non empty len-total homogeneous to-naturals
              (from-natural-fseqs Function)
 st arity f = 0 & arity g = 0 & f.{} = g.{} holds f = g;

begin :: Primitive recursiveness

reserve f1, f2 for non empty homogeneous to-naturals from-natural-fseqs
                   Function,
        e1, e2 for homogeneous to-naturals from-natural-fseqs Function,
        p for Element of (arity f1+1)-tuples_on NAT;

definition
 let g, f1, f2 be homogeneous to-naturals from-natural-fseqs Function,
     i be Nat;
 pred g is_primitive-recursively_expressed_by f1,f2,i means
:: COMPUT_1:def 12
  ex n being Nat st dom g c= n-tuples_on NAT & i >= 1 & i <= n &
  (arity f1)+1 = n & n+1 = arity f2 &
  for p being FinSequence of NAT st len p = n
   holds
   (p+*(i,0) in dom g iff Del(p,i) in dom f1) &
   (p+*(i,0) in dom g implies g.(p+*(i,0)) = f1.Del(p,i)) &
   for n being Nat holds
    (p+*(i,n+1) in dom g iff
       p+*(i,n) in dom g & (p+*(i,n))^<*g.(p+*(i,n))*> in dom f2) &
    (p+*(i,n+1) in dom g implies
       g.(p+*(i,n+1)) = f2.((p+*(i,n))^<*g.(p+*(i,n))*>));
end;

definition
 let f1,f2 be homogeneous to-naturals from-natural-fseqs Function;
 let i be Nat;
 let p be FinSequence of NAT;
 func primrec(f1,f2,i,p) -> Element of HFuncs NAT means
:: COMPUT_1:def 13
  ex F being Function of NAT, HFuncs NAT st it = F.(p/.i) &
   (i in dom p & Del(p,i) in dom f1 implies
      F.0 = {p+*(i,0)} --> (f1.Del(p,i))) &
   (not i in dom p or not Del(p,i) in dom f1 implies F.0 = {}) &
  for m being Nat holds
   (i in dom p & p+*(i,m) in dom (F.m) &
    (p+*(i,m))^<*(F.m).(p+*(i,m))*> in dom f2
      implies F.(m+1) =
       (F.m)+*({p+*(i,m+1)}--> f2.((p+*(i,m))^<*(F.m).(p+*(i,m))*>))) &
   (not i in dom p or not p+*(i,m) in dom (F.m) or
      not (p+*(i,m))^<*(F.m).(p+*(i,m))*> in dom f2 implies F.(m+1) = F.m);
end;


theorem :: COMPUT_1:53
for p, q being FinSequence of NAT
 st q in dom primrec(e1,e2,i,p) ex k st q = p+*(i,k);

theorem :: COMPUT_1:54
for p being FinSequence of NAT st not i in dom p holds primrec(e1,e2,i,p) = {};

theorem :: COMPUT_1:55
for p, q being FinSequence of NAT holds
  primrec(e1,e2,i,p) tolerates primrec(e1,e2,i,q);

theorem :: COMPUT_1:56
for p being FinSequence of NAT
 holds dom primrec(e1,e2,i,p) c= (1+arity e1)-tuples_on NAT;

theorem :: COMPUT_1:57
for p being FinSequence of NAT st e1 is empty holds primrec(e1,e2,i,p) is empty
;

theorem :: COMPUT_1:58
f1 is len-total & f2 is len-total & arity f1 +2 = arity f2 &
 1 <= i & i <= 1+arity f1 implies p in dom primrec(f1,f2,i,p);

definition
 let f1,f2 be homogeneous to-naturals from-natural-fseqs Function;
 let i be Nat;
 func primrec(f1,f2,i) -> Element of HFuncs NAT means
:: COMPUT_1:def 14
  ex G being Function of (arity f1+1)-tuples_on NAT, HFuncs NAT st
   it = Union G &
   for p being Element of (arity f1+1)-tuples_on NAT
    holds G.p = primrec(f1,f2,i,p);
end;


theorem :: COMPUT_1:59
e1 is empty implies primrec(e1,e2,i) is empty;

theorem :: COMPUT_1:60
dom primrec(f1,f2,i) c= (arity f1+1)-tuples_on NAT;

theorem :: COMPUT_1:61
f1 is len-total & f2 is len-total & arity f1 +2 = arity f2 &
1 <= i & i <= 1+arity f1
 implies dom primrec(f1,f2,i) = (arity f1+1)-tuples_on NAT &
         arity primrec(f1,f2,i) = arity f1+1;

theorem :: COMPUT_1:62
 i in dom p implies (p+*(i,0) in dom primrec(f1,f2,i) iff Del(p,i) in dom f1);

theorem :: COMPUT_1:63
 i in dom p & p+*(i,0) in dom primrec(f1,f2,i) implies
   primrec(f1,f2,i).(p+*(i,0)) = f1.Del(p,i);

theorem :: COMPUT_1:64
i in dom p & f1 is len-total implies primrec(f1,f2,i).(p+*(i,0)) = f1.Del(p,i);

theorem :: COMPUT_1:65
 i in dom p implies
 (p+*(i,m+1) in dom primrec(f1,f2,i) iff
      p+*(i,m) in dom primrec(f1,f2,i) &
      (p+*(i,m))^<*primrec(f1,f2,i).(p+*(i,m))*> in dom f2);

theorem :: COMPUT_1:66
 i in dom p & p+*(i,m+1) in dom primrec(f1,f2,i) implies
 primrec(f1,f2,i).(p+*(i,m+1)) =
                   f2.((p+*(i,m))^<*primrec(f1,f2,i).(p+*(i,m))*>);

theorem :: COMPUT_1:67
 f1 is len-total & f2 is len-total & arity f1 +2 = arity f2 &
 1 <= i & i <= 1+arity f1 implies
primrec(f1,f2,i).(p+*(i,m+1)) = f2.((p+*(i,m))^<*primrec(f1,f2,i).(p+*(i,m))*>)
;

theorem :: COMPUT_1:68
arity f1+2 = arity f2 & 1 <= i & i <= arity f1+1 implies
 primrec(f1,f2,i) is_primitive-recursively_expressed_by f1,f2,i;

theorem :: COMPUT_1:69
  1 <= i & i <= arity f1+1 implies
 for g being Element of HFuncs NAT
  st g is_primitive-recursively_expressed_by f1,f2,i holds g = primrec(f1,f2,i)
;

begin :: The set of primitive recursive functions

definition
 let X be set;
 attr X is composition_closed means
:: COMPUT_1:def 15
for f being Element of HFuncs NAT,
     F being with_the_same_arity FinSequence of HFuncs NAT
 st f in X & arity f = len F & rng F c= X holds f*<:F:> in X;
 attr X is primitive-recursion_closed means
:: COMPUT_1:def 16
for g,f1,f2 being Element of HFuncs NAT, i being Nat
 st g is_primitive-recursively_expressed_by f1,f2,i & f1 in X & f2 in X
  holds g in X;
end;


definition
 let X be set;
 attr X is primitive-recursively_closed means
:: COMPUT_1:def 17
  0 const 0 in X & 1 succ 1 in X &
  (for n,i being Nat st 1 <= i & i <= n holds n proj i in X) &
  X is composition_closed & X is primitive-recursion_closed;
end;


theorem :: COMPUT_1:70
HFuncs NAT is primitive-recursively_closed;

registration
cluster primitive-recursively_closed non empty Subset of HFuncs NAT;
existence proof HFuncs NAT c= HFuncs NAT;
   then reconsider X = HFuncs NAT as non empty Subset of HFuncs NAT;
   take X; thus thesis by Th70;
  end;
end;


reserve P for primitive-recursively_closed non empty Subset of HFuncs NAT;

theorem :: COMPUT_1:71
for g being Element of HFuncs NAT
 st e1 = {} & g is_primitive-recursively_expressed_by e1, e2, i holds g = {};

theorem :: COMPUT_1:72
for g being Element of HFuncs(NAT),
    f1, f2 being quasi_total Element of HFuncs(NAT), i being Nat
 st g is_primitive-recursively_expressed_by f1, f2, i
  holds g is quasi_total & (f1 is non empty implies g is non empty);

theorem :: COMPUT_1:73
n const c in P;

theorem :: COMPUT_1:74
1 <= i & i <= n implies n succ i in P;

theorem :: COMPUT_1:75
{} in P;

theorem :: COMPUT_1:76
for f being Element of P, F being with_the_same_arity FinSequence of P
 st arity f = len F holds f*<:F:> in P;

theorem :: COMPUT_1:77
 for f1,f2 being Element of P st arity f1+2 = arity f2
 for i being Nat st 1 <= i & i <= arity f1+1 holds primrec(f1,f2,i) in P;

definition
 func PrimRec -> Subset of HFuncs(NAT) equals
:: COMPUT_1:def 18
 meet { R where R is Element of bool HFuncs(NAT) :
                R is primitive-recursively_closed };
end;


theorem :: COMPUT_1:78
for X being Subset of HFuncs(NAT) st X is primitive-recursively_closed
 holds PrimRec c= X;

registration
 cluster PrimRec -> non empty primitive-recursively_closed;
 coherence proof set S = { R where R is Element of bool HFuncs(NAT) :
               R is primitive-recursively_closed };
     HFuncs(NAT) in {HFuncs(NAT)} & {HFuncs(NAT)} c= bool HFuncs(NAT)
     by TARSKI:def 1,ZFMISC_1:80;
then A1: HFuncs(NAT) in S by Th70;
     A2: now let Y be set; assume Y in S;
       then consider R being Element of bool HFuncs(NAT) such that
     A3: R = Y & R is primitive-recursively_closed;
      thus 0 const 0 in Y by A3,Def17;
     end;
   hence PrimRec is non empty by A1,Def18,SETFAM_1:def 1;
   thus PrimRec is primitive-recursively_closed proof
    thus 0 const 0 in PrimRec by A1,A2,Def18,SETFAM_1:def 1;
       now let Y be set; assume Y in S;
       then consider R being Element of bool HFuncs(NAT) such that
     A4: R = Y & R is primitive-recursively_closed;
      thus 1 succ 1 in Y by A4,Def17;
     end;
    hence 1 succ 1 in PrimRec by A1,Def18,SETFAM_1:def 1;
    hereby let n, i be Nat; assume
    A5: 1 <= i & i <= n;
        now let Y be set; assume Y in S;
        then consider R being Element of bool HFuncs(NAT) such that
      A6: R = Y & R is primitive-recursively_closed;
       thus n proj i in Y by A5,A6,Def17;
      end;
     hence n proj i in PrimRec by A1,Def18,SETFAM_1:def 1;
    end;
    hereby     :: T is composition_closed;
     let f be Element of HFuncs NAT,
         F being with_the_same_arity FinSequence of HFuncs NAT such that
    A7: f in PrimRec & arity f = len F & rng F c= PrimRec;
        now let Y be set; assume
      A8: Y in S; then consider R being Element of bool HFuncs(NAT) such that
      A9: R = Y & R is primitive-recursively_closed;
      A10: R is composition_closed by A9,Def17;
            PrimRec c= R by A8,A9,Def18,SETFAM_1:4;
          then f in R & rng F c= R by A7,XBOOLE_1:1;
       hence f*<:F:> in Y by A7,A9,A10,Def15;
      end;
     hence f*<:F:> in PrimRec by A1,Def18,SETFAM_1:def 1;
    end;
    hereby ::  thus T is primitive-recursion_closed;
     let g, f1, f2 be Element of HFuncs NAT, i being Nat such that
    A11: g is_primitive-recursively_expressed_by f1,f2,i and
    A12: f1 in PrimRec and
    A13: f2 in PrimRec;
        now let Y be set; assume
      A14: Y in S; then consider R being Element of bool HFuncs(NAT) such that
      A15: R = Y & R is primitive-recursively_closed;
      A16: R is primitive-recursion_closed by A15,Def17;
            f1 in R & f2 in R by A12,A13,A14,A15,Def18,SETFAM_1:def 1;
       hence g in Y by A11,A15,A16,Def16;
      end;
     hence g in PrimRec by A1,Def18,SETFAM_1:def 1;
    end;
   end;
 end;
end;


registration
 cluster -> homogeneous Element of PrimRec; coherence;
end;


definition
 let x be set;
 attr x is primitive-recursive means
:: COMPUT_1:def 19
x in PrimRec;
end;


registration
 cluster primitive-recursive -> Relation-like Function-like set;
 coherence proof let x be set; assume x in PrimRec;
   then x is Element of PrimRec; hence thesis; end;
end;


registration
 cluster primitive-recursive -> homogeneous to-naturals from-natural-fseqs
                                Relation;
 coherence proof let x be Relation; assume x in PrimRec;
    then x is Element of PrimRec; hence thesis;
 end;
end;


registration
 cluster -> primitive-recursive Element of PrimRec;
 coherence by Def19;
end;


registration
 cluster primitive-recursive Function;
existence proof consider x being Element of PrimRec; take x; thus thesis; end;
 cluster primitive-recursive Element of HFuncs NAT;
existence proof consider x being Element of PrimRec; take x; thus thesis; end;
end;


definition
 func initial-funcs -> Subset of HFuncs NAT equals
:: COMPUT_1:def 20
  {0 const 0, 1 succ 1} \/ {n proj i where n,i is Nat: 1 <= i & i <= n};
 let Q be Subset of HFuncs NAT;
 func PR-closure Q -> Subset of HFuncs NAT equals
:: COMPUT_1:def 21
  Q \/ {g where g is Element of HFuncs NAT:
         ex f1,f2 being Element of HFuncs NAT, i being Nat
          st f1 in Q & f2 in Q &
             g is_primitive-recursively_expressed_by f1,f2,i};
 func composition-closure Q -> Subset of HFuncs NAT equals
:: COMPUT_1:def 22
  Q \/ {f*<:F:> where f is Element of HFuncs NAT,
           F is with_the_same_arity Element of (HFuncs NAT)*:
       f in Q & arity f = len F & rng F c= Q};
end;
 func PrimRec-Approximation -> Function of NAT, bool HFuncs NAT means
:: COMPUT_1:def 23
  it.0 = initial-funcs &
  for m being Nat
   holds it.(m+1) = (PR-closure (it.m)) \/ (composition-closure (it.m));
end;


theorem :: COMPUT_1:79
m <= n implies PrimRec-Approximation.m c= PrimRec-Approximation.n;

theorem :: COMPUT_1:80
Union PrimRec-Approximation is primitive-recursively_closed;

theorem :: COMPUT_1:81
PrimRec = Union PrimRec-Approximation;

theorem :: COMPUT_1:82
for f being Element of HFuncs(NAT)
 st f in PrimRec-Approximation.m holds f is quasi_total;

registration
 cluster -> quasi_total homogeneous Element of PrimRec;
 coherence proof let f be Element of PrimRec; set prd = PrimRec-Approximation;
     f in Union PrimRec-Approximation by Th81;
   then f in union rng PrimRec-Approximation by PROB_1:def 3;
   then consider X being set such that
A1: f in X & X in rng prd by TARSKI:def 4; ex m being set st
   m in dom prd & prd.m = X by A1,FUNCT_1:def 5;
  hence f is quasi_total homogeneous by A1,Th82;
 end;
end;


registration
 cluster primitive-recursive -> quasi_total Element of HFuncs NAT;
 coherence proof let f be Element of HFuncs NAT; assume f in PrimRec;
   then f is Element of PrimRec; hence thesis;
  end;
end;


registration
 cluster primitive-recursive -> len-total (from-natural-fseqs Function);
 coherence proof let x be from-natural-fseqs Function; assume x in PrimRec;
    then x is Element of PrimRec;
   hence x is len-total;
 end;
 cluster non empty Element of PrimRec;
 existence proof 0 const 0 in PrimRec by Th73; hence thesis; end;
end;


begin :: Examples

definition
 let f be homogeneous Relation;
 attr f is nullary means
:: COMPUT_1:def 24
arity f = 0;
 attr f is unary means
:: COMPUT_1:def 25
arity f = 1;
 attr f is binary means
:: COMPUT_1:def 26
arity f = 2;
 attr f is 3-ary means
:: COMPUT_1:def 27
arity f = 3;
end;


registration
 cluster unary -> non empty (homogeneous Function);
 coherence proof let f be homogeneous Function; assume arity f = 1; then ex
x being FinSequence st x in dom f by Def5;
   hence thesis by RELAT_1:60;
  end;
 cluster binary -> non empty (homogeneous Function);
 coherence proof let f be homogeneous Function; assume arity f = 2; then ex x
being FinSequence st x in dom f by Def5;
   hence thesis by RELAT_1:60;
  end;
 cluster 3-ary -> non empty (homogeneous Function);
 coherence proof let f be homogeneous Function; assume arity f = 3; then ex x
being FinSequence st x in dom f by Def5;
   hence thesis by RELAT_1:60;
  end;
end;


registration
 cluster 1 proj 1 -> primitive-recursive;
 coherence proof 1 proj 1 in PrimRec by Def17; hence thesis by Def19; end;
 cluster 2 proj 1 -> primitive-recursive;
 coherence proof 2 proj 1 in PrimRec by Def17; hence thesis by Def19; end;
 cluster 2 proj 2 -> primitive-recursive;
 coherence proof 2 proj 2 in PrimRec by Def17; hence thesis by Def19; end;
 cluster 1 succ 1 -> primitive-recursive;
 coherence proof 1 succ 1 in PrimRec by Th74; hence thesis by Def19; end;
 cluster 3 succ 3 -> primitive-recursive;
 coherence proof 3 succ 3 in PrimRec by Th74; hence thesis by Def19; end;

 let i be Nat;
 cluster 0 const i -> nullary;
 coherence proof thus arity (0 const i) = 0 by Th35; end;
 cluster 1 const i -> unary;
 coherence proof thus arity (1 const i) = 1 by Th35; end;
 cluster 2 const i -> binary;
 coherence proof thus arity (2 const i) = 2 by Th35; end;
 cluster 3 const i -> 3-ary;
 coherence proof thus arity (3 const i) = 3 by Th35; end;
 cluster 1 proj i -> unary;
 coherence proof thus arity (1 proj i) = 1 by Th41; end;
 cluster 2 proj i -> binary;
 coherence proof thus arity (2 proj i) = 2 by Th41; end;
 cluster 3 proj i -> 3-ary;
 coherence proof thus arity (3 proj i) = 3 by Th41; end;
 cluster 1 succ i -> unary;
 coherence proof thus arity (1 succ i) = 1 by Th38; end;
 cluster 2 succ i -> binary;
 coherence proof thus arity (2 succ i) = 2 by Th38; end;
 cluster 3 succ i -> 3-ary;
 coherence proof thus arity (3 succ i) = 3 by Th38; end;

 let j be Nat;
 cluster i const j -> primitive-recursive;
 coherence proof thus i const j in PrimRec by Th73; end;
end;


registration
 cluster nullary primitive-recursive non empty (homogeneous Function);
 existence by Def17;
 cluster unary primitive-recursive (homogeneous Function);
 existence by Def17;
 cluster binary primitive-recursive (homogeneous Function);
existence proof take f=2 proj 1;thus f is binary;thus f in PrimRec by Def17
;end;
 cluster 3-ary primitive-recursive (homogeneous Function);
existence proof take f=3 proj 1;thus f is 3-ary; thus f in PrimRec by Def17
;end;
end;


registration
  cluster non empty nullary len-total to-naturals
          (homogeneous from-natural-fseqs Function);
  existence proof 0 const 0 is nullary; hence thesis; end;
  cluster non empty unary len-total to-naturals
          (homogeneous from-natural-fseqs Function);
  existence proof 1 const 0 is unary; hence thesis; end;
  cluster non empty binary len-total to-naturals
          (homogeneous from-natural-fseqs Function);
  existence proof 2 const 0 is binary; hence thesis; end;
  cluster non empty 3-ary len-total to-naturals
          (homogeneous from-natural-fseqs Function);
  existence proof 3 const 0 is 3-ary; hence thesis; end;
end;


registration
 let f be nullary non empty (primitive-recursive Function);
 let g be binary (primitive-recursive Function);
 cluster primrec(f,g,1) -> primitive-recursive unary;
 coherence proof
A1:  0 <= 1 & 1 <= 0+1 & arity f = 0 & arity g = 0+2 &
    f in PrimRec & g in PrimRec by Def19,Def24,Def26;
   hence primrec(f,g,1) in PrimRec by Th77;
A2:  dom <*0*> = {1} by FINSEQ_1:4,55; f is Element of PrimRec by Def19;
    then dom f = 0-tuples_on NAT by A1,Th25 .= {<*>NAT} by FINSEQ_2:112;
    then Del(<*0*>,1) = {} & {} in dom f & 1 in dom <*0*>
     by A2,TARSKI:def 1,WSIERP_1:26; then <*0*>+*(1,0) in dom primrec(f,g,1)
by A1,Lm6
;
     then <*0*> in dom primrec(f,g,1) & len <*0*> = 1 by FINSEQ_1:56,SCMFSA10:2
;
   hence arity primrec(f,g,1) = 1 by Def5;
  end;
end;


registration
 let f be unary (primitive-recursive Function);
 let g be 3-ary (primitive-recursive Function);
 cluster primrec(f,g,1) -> primitive-recursive binary;
 coherence proof A1:  1 <= 1 & 1 <= 1+1 & arity f = 1 & arity g = 1+2 &
    f in PrimRec & g in PrimRec by Def19,Def25,Def27;
   hence primrec(f,g,1) in PrimRec by Th77;
   thus arity primrec(f,g,1) = 2 by A1,Th61;
  end;
 cluster primrec(f,g,2) -> primitive-recursive binary;
 coherence proof A2:  1 <= 2 & 2 <= 1+1 & arity f = 1 & arity g = 1+2 &
    f in PrimRec & g in PrimRec by Def19,Def25,Def27;
   hence primrec(f,g,2) in PrimRec by Th77;
   thus arity primrec(f,g,2) = 2 by A2,Th61;
  end;
end;


theorem :: COMPUT_1:83
for f1 be unary len-total to-naturals
          (homogeneous from-natural-fseqs Function),
    f2 be non empty to-naturals homogeneous from-natural-fseqs Function
 holds primrec(f1,f2,2).<*i,0*> = f1.<*i*>;

theorem :: COMPUT_1:84
f1 is len-total & arity f1 = 0 implies primrec(f1,f2,1).<*0*> = f1.{};

theorem :: COMPUT_1:85
for f1 being unary len-total to-naturals
              (homogeneous from-natural-fseqs Function),
    f2 being 3-ary len-total to-naturals
              (homogeneous from-natural-fseqs Function)
 holds primrec(f1,f2,2).<*i,j+1*> = f2.<*i,j,primrec(f1,f2,2).<*i,j*>*>;

theorem :: COMPUT_1:86
f1 is len-total & f2 is len-total & arity f1 = 0 & arity f2 = 2
 implies primrec(f1,f2,1).<*i+1*> = f2.<*i,primrec(f1,f2,1).<*i*>*>;

definition
 let g be Function;
 func (1,2)->(1,?,2) g -> Function equals
:: COMPUT_1:def 28
 g * <:<*3 proj 1, 3 proj 3*>:>;
end;


registration
 let g be to-naturals from-natural-fseqs Function;
 cluster (1,2)->(1,?,2) g -> to-naturals from-natural-fseqs;
 coherence proof set G = (1,2)->(1,?,2) g;
 A1: G = g*<:<*3 proj 1, 3 proj 3*>:> by Def28;
  dom <:<*3 proj 1, 3 proj 3*>:> = dom (3 proj 1) /\
 dom (3 proj 3) by FUNCT_6:62;
then A2: dom <:<*3 proj 1, 3 proj 3*>:>
 = (3-tuples_on NAT) /\ dom (3 proj 3) by Th40
.= (3-tuples_on NAT)/\(3-tuples_on NAT) by Th40.= (3-tuples_on NAT);
 A3: dom G c= dom <:<*3 proj 1, 3 proj 3*>:> by A1,RELAT_1:44;
   (3-tuples_on NAT) c= NAT* by MSUALG_1:12;
 then A4: dom G c= NAT* by A2,A3,XBOOLE_1:1;
 A5: rng g c= NAT by SEQM_3:def 8; rng G c= rng g by A1,RELAT_1:45;
    then rng G c= NAT by A5,XBOOLE_1:1;
  hence thesis by A4,Def2,SEQM_3:def 8;
 end;
end;


registration
 let g be homogeneous Function;
 cluster (1,2)->(1,?,2) g -> homogeneous;
 coherence proof set G = (1,2)->(1,?,2) g;
A1: G = g*<:<*3 proj 1, 3 proj 3*>:> by Def28;
  let x,y be FinSequence such that
A2: x in dom G and
A3: y in dom G;
  dom <:<*3 proj 1, 3 proj 3*>:> = dom (3 proj 1) /\
 dom (3 proj 3) by FUNCT_6:62;
then dom <:<*3 proj 1, 3 proj 3*>:>
 = (3-tuples_on NAT) /\ dom (3 proj 3) by Th40
.= (3-tuples_on NAT)/\(3-tuples_on NAT) by Th40 .=(3-tuples_on NAT);
 then dom (g*<:<*3 proj 1, 3 proj 3*>:>) c= 3-tuples_on NAT by RELAT_1:44;
    then 3 = len x & 3 = len y by A1,A2,A3,FINSEQ_2:109;
  hence len x = len y;
 end;
end;


registration
 let g be binary len-total to-naturals
          (homogeneous from-natural-fseqs Function);
 cluster (1,2)->(1,?,2) g -> non empty 3-ary len-total;
 coherence proof
 A1: arity g = 2 by Def26;
      g is quasi_total homogeneous non empty PartFunc of NAT*, NAT by Th20;
    then consider G being homogeneous PartFunc of NAT*, NAT such that
 A2: G = g*<:<*3 proj 1, 3 proj 3*>:> and G is Element of HFuncs NAT and
 A3: arity G = 3 and
 A4: G is quasi_total non empty by A1,Lm8;
    reconsider G' = G as quasi_total non empty
                         homogeneous PartFunc of NAT*, NAT by A4;
     G' is non empty 3-ary len-total to-naturals
                        (homogeneous from-natural-fseqs Function) by A3,Def27;
  hence thesis by A2,Def28;
 end;
end;


theorem :: COMPUT_1:87
for f being binary len-total to-naturals
            (homogeneous from-natural-fseqs Function)
 holds ((1,2)->(1,?,2) f).<*i,j,k*> = f.<*i,k*>;

theorem :: COMPUT_1:88
for g being binary (primitive-recursive Function)
 holds (1,2)->(1,?,2) g in PrimRec;

registration
 let f be binary primitive-recursive (homogeneous Function);
 cluster (1,2)->(1,?,2) f -> primitive-recursive 3-ary;
 coherence proof thus (1,2)->(1,?,2) f in PrimRec by Th88;
   thus arity ((1,2)->(1,?,2) f) = 3 by Def27;
  end;
end;


definition
 func [+] -> binary (primitive-recursive Function) equals
:: COMPUT_1:def 29
  primrec(1 proj 1, 3 succ 3, 2);
end;


theorem :: COMPUT_1:89
[+].<*i,j*> = i+j;

definition
 func [*] -> binary (primitive-recursive Function) equals
:: COMPUT_1:def 30
  primrec(1 const 0, (1,2)->(1,?,2) [+], 2);
end;


theorem :: COMPUT_1:90
for i, j being Nat holds [*].<*i,j*> = i*j;

registration
 let g,h be binary primitive-recursive (homogeneous Function);
 cluster <*g,h*> -> with_the_same_arity;
 coherence proof
   reconsider g, h as Element of PrimRec by Def19;
      rng <*g,h*> c= PrimRec by FINSEQ_1:def 4;
then A1:  rng <*g,h*> c= HFuncs NAT by XBOOLE_1:1;
A2:  rng <*g,h*> = {g,h} by FINSEQ_2:147;
      now let f1,f2 be homogeneous Function;
     assume f1 in rng <*g,h*> & f2 in rng <*g,h*>;
      then (f1 = g or f1 = h) & (f2 = g or f2 = h) by A2,TARSKI:def 2;
      then arity f1 = 2 & arity f2 = 2 by Def26;
     hence arity f1 = arity f2;
    end; hence thesis by A1,Th33;
  end;
end;


registration
 let f,g,h be binary (primitive-recursive Function);
 cluster f*<:<*g,h*>:> -> primitive-recursive;
 coherence proof
   reconsider g' = g, h' = h as Element of PrimRec by Def19;
A1:  rng <*g',h'*> c= PrimRec by FINSEQ_1:def 4;
    then rng <*g,h*> c= HFuncs NAT by XBOOLE_1:1;
   then reconsider F = <*g,h*> as with_the_same_arity FinSequence of HFuncs NAT
     by FINSEQ_1:def 4;
A2:  f in PrimRec & PrimRec is composition_closed by Def17,Def19;
    then f in HFuncs NAT & len F = 2 & arity f = 2 by Def26,FINSEQ_1:61;
   hence f*<:<*g,h*>:> in PrimRec by A1,A2,Def15;
  end;
end;


registration
 let f,g,h be binary (primitive-recursive Function);
 cluster f*<:<*g,h*>:> -> binary;
 coherence proof
  reconsider f' = f, fgh = f*<:<*g,h*>:>, g' = g, h' = h as Element of PrimRec
by Def19;
      rng <*g',h'*> c= PrimRec by FINSEQ_1:def 4;
    then rng <*g,h*> c= HFuncs NAT by XBOOLE_1:1;
   then reconsider F = <*g,h*> as with_the_same_arity FinSequence of HFuncs NAT
     by FINSEQ_1:def 4;
A1:  arity f = 2 & arity g = 2 & arity h = 2 by Def26;
then A2:  dom f' = 2-tuples_on NAT & dom g' = 2-tuples_on NAT &
    dom h' = 2-tuples_on NAT by Lm1;
   consider x being Element of 2-tuples_on NAT;
A3:  dom <:F:> = dom g /\ dom h by FUNCT_6:62;
then x in dom <:F:> & g'.x in rng g' & h'.x in rng h' & rng g' c= NAT &
    rng h' c= NAT by A2,FUNCT_1:def 5,RELSET_1:12;
    then <:F:>.x = <*g'.x,h'.x*> & g'.x in NAT & h'.x in NAT by A3,FUNCT_6:62;
    then <:F:>.x is Element of 2-tuples_on NAT by FINSEQ_2:121;
then A4:fgh is non empty & f' = f by A2,A3,FUNCT_1:21,RELAT_1:60; rng F = {g,
h
} by FINSEQ_2:147;
    then g in rng F by TARSKI:def 2; then arity F = 2 by A1,Def7;
   hence arity (f*<:<*g,h*>:>) = 2 by A4,Th48;
  end;
end;


registration
 let f be unary (primitive-recursive Function);
 let g be primitive-recursive Function;
 cluster f*<:<*g*>:> -> primitive-recursive;
 coherence proof
   reconsider g' = g as Element of PrimRec by Def19;
A1:  rng <*g'*> c= PrimRec by FINSEQ_1:def 4;
    then rng <*g*> c= HFuncs NAT by XBOOLE_1:1;
   then reconsider F = <*g'*> as with_the_same_arity FinSequence of HFuncs NAT
     by FINSEQ_1:def 4;
A2:  f in PrimRec & PrimRec is composition_closed by Def17,Def19;
    then f in HFuncs NAT & len F = 1 & arity f = 1 by Def25,FINSEQ_1:56;
   hence f*<:<*g*>:> in PrimRec by A1,A2,Def15;
  end;
end;


registration
 let f be unary (primitive-recursive Function);
 let g be binary (primitive-recursive Function);
 cluster f*<:<*g*>:> -> binary;
coherence proof
 reconsider f' = f, fg = f*<:<*g*>:>, g' = g as Element of PrimRec by Def19;
      rng <*g'*> c= PrimRec by FINSEQ_1:def 4;
    then rng <*g*> c= HFuncs NAT by XBOOLE_1:1;
   then reconsider F = <*g'*> as with_the_same_arity FinSequence of HFuncs NAT
     by FINSEQ_1:def 4;
A1:  arity f = 1 & arity g = 2 by Def25,Def26;
then A2:  dom f' = 1-tuples_on NAT & dom g' = 2-tuples_on NAT by Lm1;
   consider x being Element of 2-tuples_on NAT;
A3:  dom <:F:> = dom g by FUNCT_6:61;
then x in dom <:F:> & g'.x in rng g' & rng g' c= NAT
     by A2,FUNCT_1:def 5,RELSET_1:12;
    then <:F:>.x = <*g'.x*> & g'.x in NAT by A3,FUNCT_6:61;
    then <:F:>.x is Element of 1-tuples_on NAT by FINSEQ_2:118;
then A4:  fg is non empty & f' = f by A2,A3,FUNCT_1:21,RELAT_1:60; rng F =
{
g} by FINSEQ_1:56;
    then g in rng F by TARSKI:def 1; then arity F = 2 by A1,Def7;
   hence arity (f*<:<*g*>:>) = 2 by A4,Th48;
  end;
end;


definition
 func [!] -> unary (primitive-recursive Function) equals
:: COMPUT_1:def 31
 primrec(0 const 1, [*]*<:<*(1 succ 1)*<:<*2 proj 1*>:>, 2 proj 2*>:>, 1);
end;


scheme :: COMPUT_1:sch 1
 Primrec1{F() -> unary len-total to-naturals
                       (homogeneous from-natural-fseqs Function),
                G() -> binary len-total to-naturals
                       (homogeneous from-natural-fseqs Function),
                f(set) -> Nat, g(set,set) -> Nat}:
for i, j being Nat holds (F()*<:<*G()*>:>).<*i,j*> = f(g(i,j))
provided
 for i being Nat holds F().<*i*> = f(i) and
 for i,j being Nat holds G().<*i,j*> = g(i,j)
proof let i, j be Nat;
A3: dom <:<*G()*>:> = dom G() by FUNCT_6:61;
     arity G() = 2 by Def26;
then A4: dom G() = 2-tuples_on NAT by Th26;
   A5: <*i,j*> is Element of 2-tuples_on NAT by FINSEQ_2:121;
hence (F()*<:<*G()*>:>).<*i,j*>
   = F().(<:<*G()*>:>.<*i,j*>) by A3,A4,FUNCT_1:23
  .= F().<*G().<*i,j*>*> by A4,A5,FUNCT_6:61
  .= F().<*g(i,j)*> by A2
  .= f(g(i,j)) by A1;
end;

scheme :: COMPUT_1:sch 2
 Primrec2{F,G,H() -> binary len-total to-naturals
                           (homogeneous from-natural-fseqs Function),
                f,g,h(set,set) -> Nat}:
for i, j being Nat holds (F()*<:<*G(),H()*>:>).<*i,j*> = f(g(i,j),h(i,j))
provided
 for i,j being Nat holds F().<*i,j*> = f(i,j) and
 for i,j being Nat holds G().<*i,j*> = g(i,j) and
 for i,j being Nat holds H().<*i,j*> = h(i,j)
proof let i, j being Nat;
A4: dom <:<*G(),H()*>:> = dom G() /\ dom H() by FUNCT_6:62;
     arity G() = 2 & arity H() = 2 by Def26;
then A5: dom G() = 2-tuples_on NAT & dom H() = 2-tuples_on NAT by Th26;
   A6: <*i,j*> is Element of 2-tuples_on NAT by FINSEQ_2:121;
hence (F()*<:<*G(),H()*>:>).<*i,j*>
   = F().(<:<*G(),H()*>:>.<*i,j*>) by A4,A5,FUNCT_1:23
  .= F().<*G().<*i,j*>,H().<*i,j*>*> by A4,A5,A6,FUNCT_6:62
  .= F().<*g(i,j),H().<*i,j*>*> by A2
  .= F().<*g(i,j),h(i,j)*> by A3
  .= f(g(i,j),h(i,j)) by A1;
end;

theorem :: COMPUT_1:91
  [!].<*i*> = i!;

definition
 func [^] -> binary (primitive-recursive Function) equals
:: COMPUT_1:def 32
  primrec(1 const 1, (1,2)->(1,?,2) [*], 2);
end;


theorem :: COMPUT_1:92
  [^].<*i,j*> = i |^ j;

definition
 func [pred] -> unary (primitive-recursive Function) equals
:: COMPUT_1:def 33
   primrec(0 const 0, 2 proj 1, 1);
end;


theorem :: COMPUT_1:93
[pred].<*0*> = 0 & [pred].<*i+1*> = i;

definition
 func [-] -> binary (primitive-recursive Function) equals
:: COMPUT_1:def 34
primrec(1 proj 1, (1,2)->(1,?,2) ([pred]*<:<*2 proj 2*>:>), 2);
end;


theorem :: COMPUT_1:94
  [-].<*i,j*> = i -' j;

