:: The Properties of Product of Relational Structures
::  by Artur Korni{\l}owicz
::
:: Received March 27, 1998
:: Copyright (c) 1998 Association of Mizar Users

environ

 vocabulary LATTICES, ORDERS_1, LATTICE3, RELAT_2, YELLOW_0, BOOLE, BHSP_3,
      ORDINAL2, FUNCT_5, MCART_1, WAYBEL_0, WAYBEL_3, QUANTAL1, COMPTS_1,
      WAYBEL_8, WAYBEL_6, WAYBEL11, WAYBEL_2;
 notation TARSKI, XBOOLE_0, ZFMISC_1, STRUCT_0, MCART_1, ORDERS_1, LATTICE3,
      YELLOW_0, WAYBEL_0, WAYBEL_1, YELLOW_3, YELLOW_4, WAYBEL_2, WAYBEL_3,
      WAYBEL_6, WAYBEL_8, WAYBEL11;
 constructors YELLOW_4, WAYBEL_1, WAYBEL_3, WAYBEL_6, WAYBEL_8, ORDERS_3,
      WAYBEL11;
 clusters STRUCT_0, LATTICE3, YELLOW_0, YELLOW_3, YELLOW_4, WAYBEL_0, WAYBEL_2,
      WAYBEL_3, WAYBEL_8, WAYBEL14, SUBSET_1, XBOOLE_0;
 requirements SUBSET, BOOLE;


begin  :: On the elements of product of relational structures

registration let S, T be non empty upper-bounded RelStr;
 cluster [:S,T:] -> upper-bounded;
coherence
  proof
    consider s being Element of S such that
A1:   s is_>=_than the carrier of S by YELLOW_0:def 5;
    consider t being Element of T such that
A2:   t is_>=_than the carrier of T by YELLOW_0:def 5;
    take [s,t];
A3: the carrier of [:S,T:] = [:the carrier of S, the carrier of T:]
      by YELLOW_3:def 2;
      the carrier of S c= the carrier of S &
     the carrier of T c= the carrier of T;
    then the carrier of S is Subset of S & the carrier of T is Subset of T
     ;
    hence thesis by A1,A2,A3,YELLOW_3:30;
  end;
end;


registration let S, T be non empty lower-bounded RelStr;
 cluster [:S,T:] -> lower-bounded;
coherence
  proof
    consider s being Element of S such that
A1:   s is_<=_than the carrier of S by YELLOW_0:def 4;
    consider t being Element of T such that
A2:   t is_<=_than the carrier of T by YELLOW_0:def 4;
    take [s,t];
A3: the carrier of [:S,T:] = [:the carrier of S, the carrier of T:]
      by YELLOW_3:def 2;
      the carrier of S c= the carrier of S &
     the carrier of T c= the carrier of T;
    then the carrier of S is Subset of S & the carrier of T is Subset of T
     ;
    hence thesis by A1,A2,A3,YELLOW_3:33;
  end;
end;


theorem :: YELLOW10:1
  for S, T being non empty RelStr st [:S,T:] is upper-bounded
 holds S is upper-bounded & T is upper-bounded;

theorem :: YELLOW10:2
  for S, T being non empty RelStr st [:S,T:] is lower-bounded
 holds S is lower-bounded & T is lower-bounded;

theorem :: YELLOW10:3
for S, T being upper-bounded antisymmetric non empty RelStr holds
 Top [:S,T:] = [Top S,Top T];

theorem :: YELLOW10:4
for S, T being lower-bounded antisymmetric non empty RelStr holds
 Bottom [:S,T:] = [Bottom S,Bottom T];

theorem :: YELLOW10:5
for S, T being lower-bounded antisymmetric non empty RelStr,
    D being Subset of [:S,T:]
  st [:S,T:] is complete or ex_sup_of D,[:S,T:]
  holds sup D = [sup proj1 D,sup proj2 D];

theorem :: YELLOW10:6
  for S, T being upper-bounded antisymmetric (non empty RelStr),
    D being Subset of [:S,T:]
  st [:S,T:] is complete or ex_inf_of D,[:S,T:]
  holds inf D = [inf proj1 D,inf proj2 D];

theorem :: YELLOW10:7
  for S, T being non empty RelStr,
    x, y being Element of [:S,T:] holds
 x is_<=_than {y} iff x`1 is_<=_than {y`1} & x`2 is_<=_than {y`2};

theorem :: YELLOW10:8
  for S, T being non empty RelStr,
    x, y, z being Element of [:S,T:] holds
 x is_<=_than {y,z} iff x`1 is_<=_than {y`1,z`1} & x`2 is_<=_than {y`2,z`2};

theorem :: YELLOW10:9
  for S, T being non empty RelStr,
    x, y being Element of [:S,T:] holds
 x is_>=_than {y} iff x`1 is_>=_than {y`1} & x`2 is_>=_than {y`2};

theorem :: YELLOW10:10
  for S, T being non empty RelStr,
    x, y, z being Element of [:S,T:] holds
 x is_>=_than {y,z} iff x`1 is_>=_than {y`1,z`1} & x`2 is_>=_than {y`2,z`2};

theorem :: YELLOW10:11
  for S, T being non empty antisymmetric RelStr,
    x, y being Element of [:S,T:] holds
 ex_inf_of {x,y},[:S,T:] iff ex_inf_of {x`1,y`1}, S & ex_inf_of {x`2,y`2}, T;

theorem :: YELLOW10:12
  for S, T being non empty antisymmetric RelStr,
    x, y being Element of [:S,T:] holds
 ex_sup_of {x,y},[:S,T:] iff ex_sup_of {x`1,y`1}, S & ex_sup_of {x`2,y`2}, T;

theorem :: YELLOW10:13
for S, T being with_infima antisymmetric RelStr,
    x, y being Element of [:S,T:]
 holds (x "/\" y)`1 = x`1 "/\" y`1 & (x "/\" y)`2 = x`2 "/\" y`2;

theorem :: YELLOW10:14
for S, T being with_suprema antisymmetric RelStr,
    x, y being Element of [:S,T:]
 holds (x "\/" y)`1 = x`1 "\/" y`1 & (x "\/" y)`2 = x`2 "\/" y`2;

theorem :: YELLOW10:15
for S, T being with_infima antisymmetric RelStr,
    x1, y1 being Element of S,
    x2, y2 being Element of T
 holds [x1 "/\" y1, x2 "/\" y2] = [x1,x2] "/\" [y1,y2];

theorem :: YELLOW10:16
for S, T being with_suprema antisymmetric RelStr,
    x1, y1 being Element of S,
    x2, y2 being Element of T
 holds [x1 "\/" y1, x2 "\/" y2] = [x1,x2] "\/" [y1,y2];

definition let S be with_suprema with_infima antisymmetric RelStr,
               x, y be Element of S;
 redefine pred y is_a_complement_of x;
symmetry;
end;


theorem :: YELLOW10:17
for S, T being bounded with_suprema with_infima antisymmetric RelStr,
    x, y being Element of [:S,T:] holds
 x is_a_complement_of y iff
 x`1 is_a_complement_of y`1 & x`2 is_a_complement_of y`2;

theorem :: YELLOW10:18
for S, T being antisymmetric up-complete (non empty reflexive RelStr),
    a, c being Element of S, b, d being Element of T st [a,b] << [c,d]
 holds a << c & b << d;

theorem :: YELLOW10:19
for S, T being up-complete (non empty Poset)
 for a, c being Element of S, b, d being Element of T holds
  [a,b] << [c,d] iff a << c & b << d;

theorem :: YELLOW10:20
for S, T being antisymmetric up-complete (non empty reflexive RelStr),
    x, y being Element of [:S,T:] st x << y holds
  x`1 << y`1 & x`2 << y`2;

theorem :: YELLOW10:21
for S, T being up-complete (non empty Poset),
    x, y being Element of [:S,T:] holds
  x << y iff x`1 << y`1 & x`2 << y`2;

theorem :: YELLOW10:22
for S, T being antisymmetric up-complete (non empty reflexive RelStr),
    x being Element of [:S,T:]
 st x is compact holds x`1 is compact & x`2 is compact;

theorem :: YELLOW10:23
for S, T being up-complete (non empty Poset),
    x being Element of [:S,T:]
 st x`1 is compact & x`2 is compact holds x is compact;


begin  :: On the subsets of product of relational structures

theorem :: YELLOW10:24
for S, T being with_infima antisymmetric RelStr,
    X, Y being Subset of [:S,T:]
 holds proj1 (X "/\" Y) = proj1 X "/\" proj1 Y &
       proj2 (X "/\" Y) = proj2 X "/\" proj2 Y;

theorem :: YELLOW10:25
  for S, T being with_suprema antisymmetric RelStr,
    X, Y being Subset of [:S,T:]
 holds proj1 (X "\/" Y) = proj1 X "\/" proj1 Y &
       proj2 (X "\/" Y) = proj2 X "\/" proj2 Y;

theorem :: YELLOW10:26
  for S, T being RelStr, X being Subset of [:S,T:] holds
 downarrow X c= [:downarrow proj1 X,downarrow proj2 X:];

theorem :: YELLOW10:27
  for S, T being RelStr, X being Subset of S, Y being Subset of T holds
 [:downarrow X,downarrow Y:] = downarrow [:X,Y:];

theorem :: YELLOW10:28
for S, T being RelStr, X being Subset of [:S,T:] holds
 proj1 downarrow X c= downarrow proj1 X &
 proj2 downarrow X c= downarrow proj2 X;

theorem :: YELLOW10:29
  for S being RelStr, T being reflexive RelStr, X being Subset of [:S,T:] holds
 proj1 downarrow X = downarrow proj1 X;

theorem :: YELLOW10:30
  for S being reflexive RelStr, T being RelStr, X being Subset of [:S,T:] holds
 proj2 downarrow X = downarrow proj2 X;

theorem :: YELLOW10:31
  for S, T being RelStr, X being Subset of [:S,T:] holds
 uparrow X c= [:uparrow proj1 X,uparrow proj2 X:];

theorem :: YELLOW10:32
  for S, T being RelStr, X being Subset of S, Y being Subset of T holds
 [:uparrow X,uparrow Y:] = uparrow [:X,Y:];

theorem :: YELLOW10:33
for S, T being RelStr, X being Subset of [:S,T:] holds
 proj1 uparrow X c= uparrow proj1 X &
 proj2 uparrow X c= uparrow proj2 X;

theorem :: YELLOW10:34
  for S being RelStr, T being reflexive RelStr, X being Subset of [:S,T:] holds
 proj1 uparrow X = uparrow proj1 X;

theorem :: YELLOW10:35
  for S being reflexive RelStr, T being RelStr, X being Subset of [:S,T:] holds
 proj2 uparrow X = uparrow proj2 X;

theorem :: YELLOW10:36
  for S, T being non empty RelStr, s being Element of S, t being Element of T
 holds [:downarrow s,downarrow t:] = downarrow [s,t];

theorem :: YELLOW10:37
for S, T being non empty RelStr, x being Element of [:S,T:] holds
 proj1 downarrow x c= downarrow x`1 &
 proj2 downarrow x c= downarrow x`2;

theorem :: YELLOW10:38
  for S being non empty RelStr, T being non empty reflexive RelStr,
    x being Element of [:S,T:] holds
 proj1 downarrow x = downarrow x`1;

theorem :: YELLOW10:39
  for S being non empty reflexive RelStr, T being non empty RelStr,
    x being Element of [:S,T:] holds
 proj2 downarrow x = downarrow x`2;

theorem :: YELLOW10:40
  for S, T being non empty RelStr, s being Element of S, t being Element of T
 holds [:uparrow s,uparrow t:] = uparrow [s,t];

theorem :: YELLOW10:41
for S, T being non empty RelStr, x being Element of [:S,T:] holds
 proj1 uparrow x c= uparrow x`1 &
 proj2 uparrow x c= uparrow x`2;

theorem :: YELLOW10:42
  for S being non empty RelStr, T being non empty reflexive RelStr,
    x being Element of [:S,T:] holds
 proj1 uparrow x = uparrow x`1;

theorem :: YELLOW10:43
  for S being non empty reflexive RelStr, T being non empty RelStr,
    x being Element of [:S,T:] holds
 proj2 uparrow x = uparrow x`2;

theorem :: YELLOW10:44
for S, T being up-complete (non empty Poset),
    s being Element of S, t being Element of T
 holds [:waybelow s,waybelow t:] = waybelow [s,t];

theorem :: YELLOW10:45
for S, T being antisymmetric up-complete (non empty reflexive RelStr),
    x being Element of [:S,T:] holds
 proj1 waybelow x c= waybelow x`1 &
 proj2 waybelow x c= waybelow x`2;

theorem :: YELLOW10:46
for S being up-complete (non empty Poset),
    T being up-complete lower-bounded (non empty Poset),
    x being Element of [:S,T:] holds
 proj1 waybelow x = waybelow x`1;

theorem :: YELLOW10:47
for S being up-complete lower-bounded (non empty Poset),
    T being up-complete (non empty Poset),
    x being Element of [:S,T:] holds
 proj2 waybelow x = waybelow x`2;

theorem :: YELLOW10:48
  for S, T being up-complete (non empty Poset),
    s being Element of S, t being Element of T
 holds [:wayabove s,wayabove t:] = wayabove [s,t];

theorem :: YELLOW10:49
  for S, T being antisymmetric up-complete (non empty reflexive RelStr),
    x being Element of [:S,T:] holds
 proj1 wayabove x c= wayabove x`1 &
 proj2 wayabove x c= wayabove x`2;

theorem :: YELLOW10:50
for S, T being up-complete (non empty Poset),
    s being Element of S, t being Element of T
 holds [:compactbelow s,compactbelow t:] = compactbelow [s,t];

theorem :: YELLOW10:51
for S, T being antisymmetric up-complete (non empty reflexive RelStr),
    x being Element of [:S,T:] holds
 proj1 compactbelow x c= compactbelow x`1 &
 proj2 compactbelow x c= compactbelow x`2;

theorem :: YELLOW10:52
for S being up-complete (non empty Poset),
    T being up-complete lower-bounded (non empty Poset),
    x being Element of [:S,T:] holds
 proj1 compactbelow x = compactbelow x`1;

theorem :: YELLOW10:53
for S being up-complete lower-bounded (non empty Poset),
    T being up-complete (non empty Poset),
    x being Element of [:S,T:] holds
 proj2 compactbelow x = compactbelow x`2;

registration let S be non empty reflexive RelStr;
 cluster empty -> Open Subset of S;
coherence
  proof
    let X be Subset of S such that
A1:   X is empty;
    let x be Element of S;
    assume x in X;
    hence thesis by A1;
  end;
end;


theorem :: YELLOW10:54
  for S, T being antisymmetric up-complete (non empty reflexive RelStr),
    X being Subset of [:S,T:] st
 X is Open holds proj1 X is Open & proj2 X is Open;

theorem :: YELLOW10:55
  for S, T being up-complete (non empty Poset),
    X being Subset of S, Y being Subset of T st X is Open & Y is Open
 holds [:X,Y:] is Open;

theorem :: YELLOW10:56
  for S, T being antisymmetric up-complete (non empty reflexive RelStr),
    X being Subset of [:S,T:] st
 X is inaccessible holds proj1 X is inaccessible & proj2 X is inaccessible;

theorem :: YELLOW10:57
  for S, T being antisymmetric up-complete (non empty reflexive RelStr),
    X being upper Subset of S, Y being upper Subset of T st
  X is inaccessible & Y is inaccessible holds [:X,Y:] is inaccessible;

theorem :: YELLOW10:58
  for S, T being antisymmetric up-complete (non empty reflexive RelStr),
    X being Subset of S, Y being Subset of T st [:X,Y:] is directly_closed
 holds (Y <> {} implies X is directly_closed) &
       (X <> {} implies Y is directly_closed);

theorem :: YELLOW10:59
  for S, T being antisymmetric up-complete (non empty reflexive RelStr),
    X being Subset of S, Y being Subset of T
  st X is directly_closed & Y is directly_closed
 holds [:X,Y:] is directly_closed;

theorem :: YELLOW10:60
  for S, T being antisymmetric up-complete (non empty reflexive RelStr),
    X being Subset of [:S,T:] st X has_the_property_(S) holds
 proj1 X has_the_property_(S) & proj2 X has_the_property_(S);

theorem :: YELLOW10:61
  for S, T being up-complete (non empty Poset),
    X being Subset of S, Y being Subset of T
  st X has_the_property_(S) & Y has_the_property_(S)
 holds [:X,Y:] has_the_property_(S);


begin  :: On the products of relational structures

theorem :: YELLOW10:62
for S, T being non empty reflexive RelStr
 st the RelStr of S = the RelStr of T & S is /\-complete
   holds T is /\-complete;

registration let S be /\-complete (non empty reflexive RelStr);
 cluster the RelStr of S -> /\-complete;
coherence by Th62;
end;


registration let S, T be /\-complete (non empty reflexive RelStr);
 cluster [:S,T:] -> /\-complete;
coherence
  proof
    let X be non empty Subset of [:S,T:];
      proj1 X is non empty by YELLOW_3:21;
    then consider s being Element of S such that
A1:  s is_<=_than proj1 X and
A2:  for y being Element of S st y is_<=_than proj1 X holds s >= y
       by WAYBEL_0:def 40;
      proj2 X is non empty by YELLOW_3:21;
    then consider t being Element of T such that
A3:  t is_<=_than proj2 X and
A4:  for y being Element of T st y is_<=_than proj2 X holds t >= y
       by WAYBEL_0:def 40;
    take [s,t];
    thus [s,t] is_<=_than X by A1,A3,YELLOW_3:34;
    let y be Element of [:S,T:];
      the carrier of [:S,T:] = [:the carrier of S,the carrier of T:]
      by YELLOW_3:def 2;
then A5: y = [y`1,y`2] by MCART_1:23;
    assume y is_<=_than X;
    then y`1 is_<=_than proj1 X & y`2 is_<=_than proj2 X by A5,YELLOW_3:34;
    then s >= y`1 & t >= y`2 by A2,A4;
    hence [s,t] >= y by A5,YELLOW_3:11;
  end;
end;


theorem :: YELLOW10:63
  for S, T being non empty reflexive RelStr st [:S,T:] is /\-complete
 holds S is /\-complete & T is /\-complete;

registration let S, T be complemented bounded with_infima with_suprema
                       antisymmetric (non empty RelStr);
 cluster [:S,T:] -> complemented;
coherence
  proof
    let x be Element of [:S,T:];
    consider s being Element of S such that
A1:   s is_a_complement_of x`1 by WAYBEL_1:def 24;
    consider t being Element of T such that
A2:   t is_a_complement_of x`2 by WAYBEL_1:def 24;
    take [s,t];
      the carrier of [:S,T:] = [:the carrier of S,the carrier of T:]
      by YELLOW_3:def 2;
    then [s,t]`1 = s & [s,t]`2 = t & x = [x`1,x`2] by MCART_1:7,23;
    hence [s,t] is_a_complement_of x by A1,A2,Th17;
  end;
end;


theorem :: YELLOW10:64
  for S, T being bounded with_infima with_suprema antisymmetric RelStr
 st [:S,T:] is complemented holds S is complemented & T is complemented;

registration let S, T be distributive with_infima with_suprema antisymmetric
                       (non empty RelStr);
 cluster [:S,T:] -> distributive;
coherence
  proof
    let x, y, z be Element of [:S,T:];
A1: the carrier of [:S,T:] = [:the carrier of S,the carrier of T:]
      by YELLOW_3:def 2;
A2: (x "/\" (y "\/" z))`1
       = x`1 "/\" (y "\/" z)`1 by Th13
      .= x`1 "/\" (y`1 "\/" z`1) by Th14
      .= (x`1 "/\" y`1) "\/" (x`1 "/\" z`1) by WAYBEL_1:def 3
      .= (x "/\" y)`1 "\/" (x`1 "/\" z`1) by Th13
      .= (x "/\" y)`1 "\/" (x "/\" z)`1 by Th13
      .= ((x "/\" y) "\/" (x "/\" z))`1 by Th14;
      (x "/\" (y "\/" z))`2
       = x`2 "/\" (y "\/" z)`2 by Th13
      .= x`2 "/\" (y`2 "\/" z`2) by Th14
      .= (x`2 "/\" y`2) "\/" (x`2 "/\" z`2) by WAYBEL_1:def 3
      .= (x "/\" y)`2 "\/" (x`2 "/\" z`2) by Th13
      .= (x "/\" y)`2 "\/" (x "/\" z)`2 by Th13
      .= ((x "/\" y) "\/" (x "/\" z))`2 by Th14;
    hence x "/\" (y "\/" z) = (x "/\" y) "\/" (x "/\"
 z) by A1,A2,DOMAIN_1:12;
  end;
end;


theorem :: YELLOW10:65
  for S being with_infima with_suprema antisymmetric RelStr,
    T being with_infima with_suprema reflexive antisymmetric RelStr
 st [:S,T:] is distributive holds S is distributive;

theorem :: YELLOW10:66
  for S being with_infima with_suprema reflexive antisymmetric RelStr,
    T being with_infima with_suprema antisymmetric RelStr
 st [:S,T:] is distributive holds T is distributive;

registration let S, T be meet-continuous Semilattice;
 cluster [:S,T:] -> satisfying_MC;
coherence
  proof
    let x be Element of [:S,T:],
        D be non empty directed Subset of [:S,T:];
A1: proj1 D is non empty directed by YELLOW_3:21,22;
A2: proj2 D is non empty directed by YELLOW_3:21,22;
A3: the carrier of [:S,T:] = [:the carrier of S,the carrier of T:]
      by YELLOW_3:def 2;
then A4: x = [x`1,x`2] by MCART_1:23;
    reconsider x' = {x} as non empty directed Subset of [:S,T:] by WAYBEL_0:5;
      ex_sup_of x' "/\" D,[:S,T:] & ex_sup_of D,[:S,T:] by WAYBEL_0:75;
then A5: sup D = [sup proj1 D,sup proj2 D] by YELLOW_3:46;
      ex_sup_of x'"/\" D,[:S,T:] by WAYBEL_0:75;
then A6: sup ({x} "/\" D) = [sup proj1 ({x} "/\" D), sup proj2 ({x} "/\" D)]
      by YELLOW_3:46;
A7: (x "/\" sup D)`1 = x`1 "/\" (sup D)`1 by Th13
                  .= x`1 "/\" sup proj1 D by A5,MCART_1:7
                  .= sup ({x`1} "/\" proj1 D) by A1,WAYBEL_2:def 6
                  .= sup (proj1 {x} "/\" proj1 D) by A4,FUNCT_5:15
                  .= sup (proj1 ({x} "/\" D)) by Th24
                  .= (sup ({x} "/\" D))`1 by A6,MCART_1:7;
      (x "/\" sup D)`2 = x`2 "/\" (sup D)`2 by Th13
                  .= x`2 "/\" sup proj2 D by A5,MCART_1:7
                  .= sup ({x`2} "/\" proj2 D) by A2,WAYBEL_2:def 6
                  .= sup (proj2 {x} "/\" proj2 D) by A4,FUNCT_5:15
                  .= sup (proj2 ({x} "/\" D)) by Th24
                  .= (sup ({x} "/\" D))`2 by A6,MCART_1:7;
    hence x "/\" sup D = sup ({x} "/\" D) by A3,A7,DOMAIN_1:12;
  end;
end;


theorem :: YELLOW10:67
  for S, T being Semilattice st [:S,T:] is meet-continuous holds
 S is meet-continuous & T is meet-continuous;

registration let S, T be satisfying_axiom_of_approximation up-complete
                       /\-complete (non empty Poset);
 cluster [:S,T:] -> satisfying_axiom_of_approximation;
coherence
  proof
    let x be Element of [:S,T:];
A1: the carrier of [:S,T:] = [:the carrier of S,the carrier of T:]
      by YELLOW_3:def 2;
      ex_sup_of waybelow x,[:S,T:] by WAYBEL_0:75;
then A2: sup waybelow x = [sup proj1 waybelow x,sup proj2 waybelow x]
      by YELLOW_3:46;
then A3: (sup waybelow x)`1 = sup proj1 waybelow x by MCART_1:7
      .= sup waybelow x`1 by Th46
      .= x`1 by WAYBEL_3:def 5;
      (sup waybelow x)`2 = sup proj2 waybelow x by A2,MCART_1:7
      .= sup waybelow x`2 by Th47
      .= x`2 by WAYBEL_3:def 5;
    hence x = sup waybelow x by A1,A3,DOMAIN_1:12;
  end;
end;


registration let S, T be continuous /\-complete (non empty Poset);
 cluster [:S,T:] -> continuous;
coherence
  proof
    thus for x being Element of [:S,T:] holds
     waybelow x is non empty directed;
    thus [:S,T:] is up-complete satisfying_axiom_of_approximation;
  end;
end;


theorem :: YELLOW10:68
  for S, T being up-complete lower-bounded (non empty Poset)
 st [:S,T:] is continuous holds S is continuous & T is continuous;

registration let S, T be satisfying_axiom_K up-complete lower-bounded
                       sup-Semilattice;
 cluster [:S,T:] -> satisfying_axiom_K;
coherence
  proof
    let x be Element of [:S,T:];
A1: the carrier of [:S,T:] = [:the carrier of S,the carrier of T:]
      by YELLOW_3:def 2;
A2: sup compactbelow x = [sup proj1 compactbelow x,sup proj2 compactbelow x]
      by YELLOW_3:46;
then A3: (sup compactbelow x)`1 = sup proj1 compactbelow x by MCART_1:7
      .= sup compactbelow x`1 by Th52
      .= x`1 by WAYBEL_8:def 3;
      (sup compactbelow x)`2 = sup proj2 compactbelow x by A2,MCART_1:7
      .= sup compactbelow x`2 by Th53
      .= x`2 by WAYBEL_8:def 3;
    hence x = sup compactbelow x by A1,A3,DOMAIN_1:12;
  end;
end;


registration let S, T be complete algebraic lower-bounded sup-Semilattice;
 cluster [:S,T:] -> algebraic;
coherence
  proof
    thus for x being Element of [:S,T:] holds
     compactbelow x is non empty directed;
    thus [:S,T:] is up-complete satisfying_axiom_K;
  end;
end;


theorem :: YELLOW10:69
for S, T being lower-bounded (non empty Poset)
 st [:S,T:] is algebraic holds S is algebraic & T is algebraic;

registration let S, T be arithmetic lower-bounded LATTICE;
 cluster [:S,T:] -> arithmetic;
coherence
  proof
    thus [:S,T:] is algebraic;
    set C = CompactSublatt [:S,T:];
    let x, y be Element of [:S,T:] such that
A1:   x in the carrier of C & y in the carrier of C & ex_inf_of {x,y},[:S,T:];
A2: CompactSublatt S is meet-inheriting & CompactSublatt T is meet-inheriting
      by WAYBEL_8:def 5;
A3: ex_inf_of {x`1,y`1},S & ex_inf_of {x`2,y`2},T by YELLOW_0:21;
      x is compact & y is compact by A1,WAYBEL_8:def 1;
    then x`1 is compact & y`1 is compact & x`2 is compact & y`2 is compact by
Th22;
    then x`1 in the carrier of CompactSublatt S &
     y`1 in the carrier of CompactSublatt S &
      x`2 in the carrier of CompactSublatt T &
       y`2 in the carrier of CompactSublatt T by WAYBEL_8:def 1;
    then inf {x`1,y`1} in the carrier of CompactSublatt S &
     inf {x`2,y`2} in the carrier of CompactSublatt T
      by A2,A3,YELLOW_0:def 16;
    then x`1 "/\" y`1 in the carrier of CompactSublatt S &
     x`2 "/\" y`2 in the carrier of CompactSublatt T
      by YELLOW_0:40;
    then x`1 "/\" y`1 is compact & x`2 "/\" y`2 is compact by WAYBEL_8:def 1;
    then (x "/\" y)`1 is compact & (x "/\" y)`2 is compact by Th13;
    then x "/\" y is compact by Th23;
    then inf {x,y} is compact by YELLOW_0:40;
    hence inf {x,y} in the carrier of C by WAYBEL_8:def 1;
  end;
end;


theorem :: YELLOW10:70
  for S, T being lower-bounded LATTICE st [:S,T:] is arithmetic holds
 S is arithmetic & T is arithmetic;

