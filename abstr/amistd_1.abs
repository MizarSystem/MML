:: Standard Ordering of Instruction Locations
::  by Andrzej Trybulec , Piotr Rudnicki and Artur Korni{\l}owicz
::
:: Received April 14, 2000
:: Copyright (c) 2000 Association of Mizar Users

environ

 vocabularies NUMBERS, XBOOLE_0, SUBSET_1, ORDINAL1, SETFAM_1, AMI_1, FSM_1,
      FUNCT_4, FUNCOP_1, RELAT_1, TARSKI, STRUCT_0, FUNCT_1, CARD_3, ZFMISC_1,
      CIRCUIT2, CAT_1, NAT_1, GLIB_000, XXREAL_0, PARTFUN1, FINSEQ_1, ARYTM_3,
      CARD_1, GOBOARD5, FUNCT_2, FINSEQ_4, ARYTM_1, FINSET_1, FRECHET, RCOMP_1,
      AMISTD_1, SCMNORM, AFINSQ_1, COMPOS_1;
 notations TARSKI, XBOOLE_0, ZFMISC_1, SUBSET_1, RELAT_1, SETFAM_1, ORDINAL1,
      CARD_1, XXREAL_0, NUMBERS, XCMPLX_0, NAT_1, MEMBERED, FUNCT_1, RELSET_1,
      PARTFUN1, MCART_1, VALUED_1, DOMAIN_1, CARD_3, FINSEQ_1, FINSEQ_4,
      FUNCOP_1, FINSET_1, FUNCT_4, AFINSQ_1, STRUCT_0, GRAPH_2, NAT_D,
      XXREAL_2, COMPOS_1, AMI_1, FUNCT_2;
 constructors WELLORD2, REAL_1, FINSEQ_4, REALSET1, NAT_D, AMI_1, XXREAL_2,
      RELSET_1, PRE_POLY, GRAPH_2, AFINSQ_1, MCART_1;
 registrations XBOOLE_0, SETFAM_1, RELAT_1, FUNCT_1, PARTFUN1, FUNCT_2,
      FUNCOP_1, FINSET_1, NUMBERS, XREAL_0, NAT_1, MEMBERED, FINSEQ_1, CARD_3,
      REALSET1, FUNCT_7, STRUCT_0, AMI_1, JORDAN1J, CARD_1, XXREAL_2, RELSET_1,
      FUNCT_4, AFINSQ_1, ORDINAL1, ZFMISC_1, SUBSET_1, VALUED_1, COMPOS_1;
 requirements NUMERALS, BOOLE, REAL, SUBSET, ARITHM;


begin :: Ami-Struct

reserve x for set,
  D for non empty set,
  k, n for Element of NAT,
  z for natural number;

reserve
  N for with_non-empty_elements non empty set,
  S for
  IC-Ins-separated definite (non empty stored-program AMI-Struct over N),
  i
  for Element of the Instructions of S,
  l, l1, l2, l3 for Element of NAT,
  s for State of S;

registration

  let N be with_non-empty_elements set, S be stored-program
   AMI-Struct over N, i be Element of the Instructions of S, s be State of S;
  cluster ((the Execution of S).i).s -> Function-like Relation-like;
end;

canceled 12;

definition
  let N be with_non-empty_elements set;
  let S be non empty stored-program standard-ins AMI-Struct over N;
  let T be InsType of S;
  canceled 2;
  attr T is jump-only means
:: AMISTD_1:def 3
  for s being State of S, o being Object of S, I
  being Instruction of S st InsCode I = T & o <> IC S holds Exec(I, s).o = s.o;
end;

definition

  let N be with_non-empty_elements set;
  let S be non empty stored-program standard-ins AMI-Struct over N;
  let I be Instruction of S;
  attr I is jump-only means
:: AMISTD_1:def 4
  InsCode I is jump-only;
end;

reserve ss for Element of product the Object-Kind of S;

definition
  let N,S; let l be Nat;
  let i be Element of the Instructions of S;
  func NIC(i,l) -> Subset of NAT equals
:: AMISTD_1:def 5
  { IC Following(ProgramPart ss,ss) : IC ss = l & (ProgramPart ss)/.l = i };
end;

registration

  let N be with_non-empty_elements non empty set,
  S be realistic IC-Ins-separated
  definite steady-programmed
   (non empty stored-program AMI-Struct over N), i be Element of the
  Instructions of S, l be Element of NAT;
  cluster NIC(i,l) -> non empty;
end;

definition
  let N,S,i;
  func JUMP i -> Subset of NAT equals
:: AMISTD_1:def 6
  meet { NIC(i,l) : not contradiction };
end;

definition
  let N,S; let l be Nat;
  func SUCC(l,S) -> Subset of NAT equals
:: AMISTD_1:def 7
  union { NIC(i,l) \ JUMP i : not
  contradiction };
end;

canceled;

theorem :: AMISTD_1:14
  for i being Element of the Instructions of S
   st for l being Element of NAT holds NIC(i,l)={l}
  holds JUMP i is empty;

theorem :: AMISTD_1:15
  for S being realistic IC-Ins-separated definite steady-programmed
   (non empty stored-program AMI-Struct over N), il being Element of NAT,
   i being Instruction of S st i is halting holds NIC(i,il) = {il};

begin :: Ordering of Instruction Locations

definition
 canceled 2;
  let N, S;
  attr S is standard means
:: AMISTD_1:def 10

  for m, n being Element of NAT holds m <= n iff
   ex f being non empty FinSequence of NAT st f/.1 = m & f/.len f = n &
    for n st 1 <= n & n < len f holds f/.(n+1) in SUCC(f/.n,S);
end;

canceled 2;


theorem :: AMISTD_1:18
   S is standard iff
   for k being Element of NAT holds k+1 in SUCC(k,S) &
    for j being Element of NAT st j in SUCC(k,S) holds k <= j;

theorem :: AMISTD_1:19
  S is standard iff
  for k being Element of NAT holds k+1 in SUCC(k,S) & for j
  being Element of NAT st j in SUCC(k,S) holds k <= j;

begin :: Standard trivial computer

definition
  let N be with_non-empty_elements set;
  func STC N -> strict AMI-Struct over N means
:: AMISTD_1:def 11

  the carrier of it = NAT \/ {NAT} & the Instruction-Counter of it = NAT &
  the Instructions of it = {[0,0,0],[1,0,0]} &
  the haltF of it = [0,0,0] &
  the Object-Kind of it = (NAT --> {[1,0,0],[0,0,0]}) +* (NAT .-->NAT) &
  ex f being Function of product the Object-Kind of it,
                         product the Object-Kind of it st
  (for s being Element of product the Object-Kind of it holds
   f.s = s+*(NAT .-->succ(s.NAT))) &
  the Execution of it = ([1,0,0] .--> f) +*
    ([0,0,0] .--> id product the Object-Kind of it);
end;

registration
  let N be with_non-empty_elements set;
  cluster STC N -> infinite;
end;

registration
  let N be with_non-empty_elements set;
  cluster STC N -> non empty stored-program standard-ins;
end;

registration
  let N be with_non-empty_elements set;
  cluster STC N -> IC-Ins-separated definite realistic steady-programmed;
end;

theorem :: AMISTD_1:20
  for i being Instruction of STC N st InsCode i = 0 holds i is
  halting;

theorem :: AMISTD_1:21
  for i being Instruction of STC N st InsCode i = 1 holds i is non
  halting;

theorem :: AMISTD_1:22
  for i being Element of the Instructions of STC N holds InsCode i
  = 1 or InsCode i = 0;

theorem :: AMISTD_1:23
  for i being Instruction of STC N holds i is jump-only;

theorem :: AMISTD_1:24
  for l being Element of NAT st l = z holds SUCC(l,STC N)
  = {z, z+1};

registration
  let N be with_non-empty_elements non empty set;
  cluster STC N -> standard;
end;

registration
  let N be with_non-empty_elements non empty set;
  cluster STC N -> halting;
end;

registration
  let N be with_non-empty_elements non empty set;
  cluster standard halting realistic steady-programmed
standard-ins (IC-Ins-separated definite (non empty stored-program AMI-Struct
    over N));
end;

reserve T for standard (IC-Ins-separated definite (non empty stored-program
  AMI-Struct over N));

canceled 13;

theorem :: AMISTD_1:38
  for i being Instruction of STC N, s being State of STC N st InsCode i
  = 1 holds Exec(i,s).IC STC N = succ IC s;

theorem :: AMISTD_1:39
  for l being Element of NAT, i being Element of the
  Instructions of STC N st InsCode i = 1 holds NIC(i, l) = {succ l};

theorem :: AMISTD_1:40
  for l being Element of NAT holds SUCC(l,STC N) = {l, succ l};

definition
 canceled 4;
  let N be with_non-empty_elements non empty set,
  S be standard (IC-Ins-separated
definite (non empty stored-program AMI-Struct over N)), i be Instruction of
  S;
  attr i is sequential means
:: AMISTD_1:def 16
  for s being State of S holds Exec(i, s).IC S = succ IC s;
end;

theorem :: AMISTD_1:41
  for S being standard realistic (IC-Ins-separated definite steady-programmed
   (non
empty stored-program AMI-Struct over N)), il being Element of NAT,
  i being Instruction of S st i is sequential holds NIC(i,il)
   = {succ il};

registration
  let N;
  let S be realistic standard (IC-Ins-separated definite
   steady-programmed (non empty
  stored-program AMI-Struct over N));
  cluster sequential -> non halting Instruction of S;
  cluster halting -> non sequential Instruction of S;
end;

canceled;

theorem :: AMISTD_1:43
  for i being Instruction of T st JUMP i is non empty holds i is non
  sequential;

begin :: Closedness of finite partial states

definition

  let N be with_non-empty_elements non empty set;
  let S be IC-Ins-separated definite (non empty stored-program AMI-Struct over
  N);
  let F be NAT-defined (the Instructions of S)-valued FinPartState of S;
  attr F is closed means
:: AMISTD_1:def 17

  for l being Element of NAT st l in dom F holds NIC (F/.l, l) c= dom F;
  attr F is really-closed means
:: AMISTD_1:def 18
  for s being State of S st F c= s & IC s in dom F
   for k being Element of NAT holds IC Comput(ProgramPart(s),s,k) in dom F;
end;

definition
  let N be with_non-empty_elements non empty set;
  let S be standard (IC-Ins-separated definite (non empty stored-program
  AMI-Struct over N));
  let F be FinPartState of S;
  attr F is para-closed means
:: AMISTD_1:def 19
  for s being State of S st F c= s & IC s = 0
   for k being Element of NAT holds IC Comput(ProgramPart(s),s,k) in dom F;
end;

theorem :: AMISTD_1:44
  for S being standard steady-programmed (IC-Ins-separated
definite (non empty stored-program AMI-Struct over N)),
   F being NAT-defined (the Instructions of S)-valued
  FinPartState of S st F is really-closed & 0 in dom F holds F is
  para-closed;

theorem :: AMISTD_1:45
  for S being IC-Ins-separated definite steady-programmed (non
empty stored-program AMI-Struct over N),
  F being NAT-defined (the Instructions of S)-valued FinPartState of
  S st F is closed holds F is really-closed;

registration

  let N be with_non-empty_elements non empty set,
  S be IC-Ins-separated definite
  steady-programmed (non empty stored-program AMI-Struct over N);
  cluster closed -> really-closed
   (NAT-defined (the Instructions of S)-valued FinPartState of S);
end;

theorem :: AMISTD_1:46
  for S being standard realistic halting (IC-Ins-separated
definite steady-programmed
 (non empty stored-program AMI-Struct over N)) holds 0 .-->
  halt S qua NAT-defined (the Instructions of S)-valued
   FinPartState of S is closed;

registration
  let N be with_non-empty_elements non empty set,
  S be standard steady-programmed (
  IC-Ins-separated definite (non empty stored-program AMI-Struct over N));
  cluster really-closed initial non empty -> para-closed (NAT-defined
    (the Instructions of S)-valued FinPartState of S);
end;

registration
  let N be with_non-empty_elements non empty set;
  let S be standard halting realistic (IC-Ins-separated definite
   steady-programmed (non empty
  stored-program AMI-Struct over N));
  cluster trivial closed initial non empty
  (NAT-defined (the Instructions of S)-valued FinPartState of S);
end;

registration
  let N be with_non-empty_elements non empty set;
  let S be standard halting realistic (IC-Ins-separated definite
   steady-programmed (non empty
  stored-program AMI-Struct over N));
  cluster halt-ending unique-halt trivial closed (initial non empty NAT-defined
    (the Instructions of S)-valued FinPartState of S);
end;

registration
  let N be with_non-empty_elements non empty set;
  let S be standard realistic halting (IC-Ins-separated definite
   steady-programmed(non empty
  stored-program AMI-Struct over N));
  cluster closed pre-Macro of S;
end;

canceled 9;

theorem :: AMISTD_1:56
  for i being Instruction of Trivial-AMI(N) holds i is halting;

theorem :: AMISTD_1:57
  for i being Element of the Instructions of Trivial-AMI(N) holds
  InsCode i = 0;

begin :: Addenda

:: from SCMPDS_9, 2008.03.10, A.T.

theorem :: AMISTD_1:58
  for N being with_non-empty_elements non empty set, S
being IC-Ins-separated definite (non empty stored-program AMI-Struct over N)
, i being Instruction of S, l being Element of NAT holds JUMP(i) c=
  NIC(i,l);

