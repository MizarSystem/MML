:: Standard Ordering of Instruction Locations
::  by Andrzej Trybulec , Piotr Rudnicki and Artur Korni{\l}owicz
::
:: Received April 14, 2000
:: Copyright (c) 2000-2011 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies NUMBERS, XBOOLE_0, SUBSET_1, ORDINAL1, SETFAM_1, AMI_1, FSM_1,
      FUNCT_4, FUNCOP_1, RELAT_1, TARSKI, STRUCT_0, FUNCT_1, CARD_3, ZFMISC_1,
      CIRCUIT2, CAT_1, NAT_1, GLIB_000, XXREAL_0, PARTFUN1, FINSEQ_1, ARYTM_3,
      CARD_1, GOBOARD5, FUNCT_2, FINSEQ_4, ARYTM_1, FINSET_1, FRECHET,
      AMISTD_1, SCMNORM, AFINSQ_1, COMPOS_1, AMISTD_2, PBOOLE, SCMFSA6B;
 notations TARSKI, XBOOLE_0, ZFMISC_1, SUBSET_1, RELAT_1, SETFAM_1, ORDINAL1,
      CARD_1, XXREAL_0, NUMBERS, XCMPLX_0, NAT_1, MEMBERED, FUNCT_1, RELSET_1,
      PARTFUN1, MCART_1, VALUED_1, DOMAIN_1, CARD_3, FINSEQ_1, FINSEQ_4,
      FUNCOP_1, FINSET_1, FUNCT_4, FUNCT_7, AFINSQ_1, PBOOLE, STRUCT_0,
      GRAPH_2, NAT_D, XXREAL_2, MEMSTR_0, COMPOS_1, EXTPRO_1, FUNCT_2;
 constructors WELLORD2, REAL_1, FINSEQ_4, REALSET1, NAT_D, XXREAL_2, COMPOS_1,
      EXTPRO_1, RELSET_1, PRE_POLY, GRAPH_2, AFINSQ_1, MCART_1, FUNCT_7,
      PBOOLE, XXREAL_1, FUNCT_4, MEMSTR_0;
 registrations XBOOLE_0, SETFAM_1, RELAT_1, FUNCT_1, PARTFUN1, FUNCT_2,
      FUNCOP_1, FINSET_1, NUMBERS, XREAL_0, NAT_1, MEMBERED, FINSEQ_1, CARD_3,
      REALSET1, FUNCT_7, STRUCT_0, CARD_1, XXREAL_2, RELSET_1, FUNCT_4,
      AFINSQ_1, ORDINAL1, ZFMISC_1, SUBSET_1, VALUED_1, COMPOS_1, EXTPRO_1,
      PBOOLE, PRE_POLY, MEMSTR_0;
 requirements NUMERALS, BOOLE, REAL, SUBSET, ARITHM;


begin :: AMI-Struct

reserve x for set,
  D for non empty set,
  k, n for Element of NAT,
  z for natural number;

reserve
  N for with_non-empty_elements non empty set,
  S for IC-Ins-separated non empty AMI-Struct over N,
  i for Element of the Instructions of S,
  l, l1, l2, l3 for Element of NAT,
  s for State of S;

registration

  let N be with_non-empty_elements set, S be
   AMI-Struct over N, i be Element of the Instructions of S, s be State of S;
  cluster ((the Execution of S).i).s -> Function-like Relation-like;
end;



definition
  let N be with_non-empty_elements non empty set;
  let S be non empty standard-ins AMI-Struct over N;
  let T be InsType of S;

  attr T is jump-only means
:: AMISTD_1:def 1
  for s being State of S, o being Object of S, I
  being Instruction of S st InsCode I = T &
   o in Data-Locations S
  holds Exec(I, s).o = s.o;
end;

definition

  let N be with_non-empty_elements non empty set;
  let S be non empty standard-ins AMI-Struct over N;
  let I be Instruction of S;
  attr I is jump-only means
:: AMISTD_1:def 2
  InsCode I is jump-only;
end;

reserve ss for Element of product the Object-Kind of S;

definition
  let N,S; let l be Nat;
  let i be Element of the Instructions of S;
  func NIC(i,l) -> Subset of NAT equals
:: AMISTD_1:def 3
   { IC Exec(i,ss) : IC ss = l };
end;

registration
  let N be with_non-empty_elements non empty set,
  S be IC-Ins-separated
   non empty AMI-Struct over N, i be Element of the
  Instructions of S, l be Element of NAT;
  cluster NIC(i,l) -> non empty;
end;

definition
  let N,S,i;
  func JUMP i -> Subset of NAT equals
:: AMISTD_1:def 4
  meet { NIC(i,l) : not contradiction };
end;

definition
  let N,S; let l be Nat;
  func SUCC(l,S) -> Subset of NAT equals
:: AMISTD_1:def 5
  union { NIC(i,l) \ JUMP i : not
  contradiction };
end;



theorem :: AMISTD_1:1
  for i being Element of the Instructions of S
   st for l being Element of NAT holds NIC(i,l)={l}
  holds JUMP i is empty;

theorem :: AMISTD_1:2
  for S being IC-Ins-separated non empty AMI-Struct over N,
      il being Element of NAT, i being Instruction of S st i is halting
  holds NIC(i,il) = {il};

begin :: Ordering of Instruction Locations

definition

  let N, S;
  attr S is standard means
:: AMISTD_1:def 6

  for m, n being Element of NAT holds m <= n iff
   ex f being non empty FinSequence of NAT st f/.1 = m & f/.len f = n &
    for n st 1 <= n & n < len f holds f/.(n+1) in SUCC(f/.n,S);
end;



theorem :: AMISTD_1:3
   S is standard iff
   for k being Element of NAT holds k+1 in SUCC(k,S) &
    for j being Element of NAT st j in SUCC(k,S) holds k <= j;

begin :: Standard trivial computer

definition
  let N be with_non-empty_elements set;
  func STC N -> strict AMI-Struct over N means
:: AMISTD_1:def 7

  the carrier of it = {0} & the ZeroF of it = 0 &
  the Instructions of it = {[0,0,0],[1,0,0]} &
  the haltF of it = [0,0,0] &
  the Object-Kind of it = (0 .-->NAT) &
  ex f being Function of product the Object-Kind of it,
                         product the Object-Kind of it st
  (for s being Element of product the Object-Kind of it holds
   f.s = s+*(0 .-->succ(s.0))) &
  the Execution of it = ([1,0,0] .--> f) +*
    ([0,0,0] .--> id product the Object-Kind of it);
end;

registration
  let N be with_non-empty_elements set;
  cluster STC N -> finite non empty;
end;

registration
  let N be with_non-empty_elements set;
  cluster STC N -> non empty standard-ins;
end;

registration
  let N be with_non-empty_elements set;
  cluster STC N -> IC-Ins-separated;
end;

theorem :: AMISTD_1:4
  for i being Instruction of STC N st InsCode i = 0 holds i is halting;

theorem :: AMISTD_1:5
  for i being Instruction of STC N st InsCode i = 1 holds i is non halting;

theorem :: AMISTD_1:6
  for i being Element of the Instructions of STC N
    holds InsCode i = 1 or InsCode i = 0;

theorem :: AMISTD_1:7
  for i being Instruction of STC N holds i is jump-only;

registration let N;
 cluster -> ins-loc-free for Instruction of STC N;
end;

theorem :: AMISTD_1:8
  for l being Element of NAT st l = z holds SUCC(l,STC N) = {z, z+1};

registration
  let N be with_non-empty_elements non empty set;
  cluster STC N -> standard;
end;

registration
  let N be with_non-empty_elements non empty set;
  cluster STC N -> halting;
end;

registration
  let N be with_non-empty_elements non empty set;
  cluster standard halting standard-ins for IC-Ins-separated
      non empty AMI-Struct over N;
end;

reserve T for standard IC-Ins-separated non empty AMI-Struct over N;

theorem :: AMISTD_1:9
  for i being Instruction of STC N, s being State of STC N st InsCode i = 1
   holds Exec(i,s).IC STC N = succ IC s;

theorem :: AMISTD_1:10
  for l being Element of NAT, i being Element of the
  Instructions of STC N st InsCode i = 1 holds NIC(i, l) = {succ l};

theorem :: AMISTD_1:11
  for l being Element of NAT holds SUCC(l,STC N) = {l, succ l};

definition

  let N be with_non-empty_elements non empty set,
  S be IC-Ins-separated
   non empty AMI-Struct over N,
  i be Instruction of S;
  attr i is sequential means
:: AMISTD_1:def 8
  for s being State of S holds Exec(i, s).IC S = succ IC s;
end;

theorem :: AMISTD_1:12
  for S being IC-Ins-separated non empty AMI-Struct over N,
      il being Element of NAT, i being Instruction of S st i is sequential
       holds NIC(i,il) = {succ il};

registration
  let N;
  let S be IC-Ins-separated
   non empty AMI-Struct over N;
  cluster sequential -> non halting for Instruction of S;
  cluster halting -> non sequential for Instruction of S;
end;

theorem :: AMISTD_1:13
 for T being IC-Ins-separated non empty AMI-Struct over N
  for i being Instruction of T st JUMP i is non empty holds i is non
  sequential;

begin :: Closedness of finite partial states

definition
  let N be with_non-empty_elements non empty set;
  let S be IC-Ins-separated non empty AMI-Struct over N;
  let F be finite preProgram of S;
  attr F is really-closed means
:: AMISTD_1:def 9

  for l being Element of NAT st l in dom F holds NIC (F/.l, l) c= dom F;
end;

definition
  let N be with_non-empty_elements non empty set;
  let S be IC-Ins-separated non empty AMI-Struct over N;
  let F be NAT-defined (the Instructions of S)-valued Function;
  attr F is paraclosed means
:: AMISTD_1:def 10
  for s being 0-started State of S
  for P being Instruction-Sequence of S st F c= P
   for k being Element of NAT holds IC Comput(P,s,k) in dom F;
end;

definition
  let N be with_non-empty_elements non empty set;
  let S be halting IC-Ins-separated non empty AMI-Struct over N;
  let F be NAT-defined (the Instructions of S)-valued Function;
  attr F is parahalting means
:: AMISTD_1:def 11
  for s being 0-started State of S
  for P being Instruction-Sequence of S st F c= P
   holds P halts_on s;
end;

theorem :: AMISTD_1:14
 for N being with_non-empty_elements non empty set
 for S being IC-Ins-separated non empty AMI-Struct over N
 for F being finite preProgram of S
  holds F is really-closed iff
  for s being State of S st IC s in dom F
   for k being Element of NAT holds IC Comput(F,s,k) in dom F;

theorem :: AMISTD_1:15
  for S being standard IC-Ins-separated non empty AMI-Struct over N,
   F being NAT-defined (the Instructions of S)-valued
  finite Function st F is really-closed & 0 in dom F holds F is
  paraclosed;

theorem :: AMISTD_1:16
  for S being standard halting IC-Ins-separated
 non empty AMI-Struct over N holds 0 .-->
  halt S qua NAT-defined (the Instructions of S)-valued
   finite Function is really-closed;

registration
  let N be with_non-empty_elements non empty set,
  S be standard IC-Ins-separated non empty AMI-Struct over N;
  cluster really-closed initial non empty -> paraclosed for NAT-defined
    (the Instructions of S)-valued finite Function;
end;

registration
  let N be with_non-empty_elements non empty set;
  let S be standard halting IC-Ins-separated non empty AMI-Struct over N;
  cluster trivial really-closed initial non empty
   for NAT-defined (the Instructions of S)-valued finite Function;
end;

registration
  let N be with_non-empty_elements non empty set;
  let S be standard halting IC-Ins-separated non empty AMI-Struct over N;
  cluster halt-ending unique-halt trivial really-closed
   for initial non empty NAT-defined
    (the Instructions of S)-valued finite Function;
end;

registration
  let N be with_non-empty_elements non empty set;
  let S be standard halting IC-Ins-separated non empty AMI-Struct over N;
  cluster really-closed for pre-Macro of S;
end;



theorem :: AMISTD_1:17
  for i being Instruction of Trivial-AMI(N) holds i is halting;

theorem :: AMISTD_1:18
  for i being Element of the Instructions of Trivial-AMI(N) holds InsCode i = 0
;

begin :: Addenda

:: from SCMPDS_9, 2008.03.10, A.T.

theorem :: AMISTD_1:19
  for N being with_non-empty_elements non empty set, S
being IC-Ins-separated non empty AMI-Struct over N,
 i being Instruction of S, l being Element of NAT
 holds JUMP(i) c= NIC(i,l);

theorem :: AMISTD_1:20
 for i being Instruction of STC N, s being State of STC N st InsCode i = 1
  holds Exec(i,s) = IncIC(s,1);

registration let N; let p be PartState of STC N;
 cluster DataPart p -> empty;
end;

theorem :: AMISTD_1:21
 for N being with_non-empty_elements non empty set
 for S being IC-Ins-separated non empty AMI-Struct over N
 for F being finite preProgram of S
  holds F is really-closed iff
  for s being State of S st IC s in dom F
  for P being Instruction-Sequence of S st F c= P
   for k being Element of NAT holds IC Comput(P,s,k) in dom F;

