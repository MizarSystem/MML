:: Standard Ordering of Instruction Locations
::  by Andrzej Trybulec , Piotr Rudnicki and Artur Korni{\l}owicz
::
:: Received April 14, 2000
:: Copyright (c) 2000 Association of Mizar Users

environ

 vocabularies AMI_3, ORDINAL2, ARYTM, SQUARE_1, FINSET_1, REALSET1, FINSEQ_1,
      RELAT_1, AMI_1, BOOLE, FUNCT_1, SGRAPH1, FUNCOP_1, CAT_1, GRAPH_2,
      FINSEQ_4, FUNCT_4, CARD_3, AMI_5, SETFAM_1, TARSKI, GOBOARD5, ARYTM_1,
      ORDINAL1, FUNCT_2, FRECHET, PRE_TOPC, WAYBEL_0, CARD_1, AMISTD_1,
      MEMBERED;
 notations TARSKI, XBOOLE_0, ZFMISC_1, SUBSET_1, RELAT_1, SETFAM_1, ORDINAL1,
      NUMBERS, XCMPLX_0, NAT_1, MEMBERED, REALSET1, FUNCT_1, RELSET_1,
      PARTFUN1, FUNCT_2, DOMAIN_1, CARD_1, CARD_3, FINSEQ_1, FINSEQ_4,
      FUNCOP_1, FINSET_1, FUNCT_4, STRUCT_0, BINARITH, PRE_CIRC, XXREAL_0,
      AMI_1;
 constructors RELAT_2, PARTFUN1, WELLORD2, XXREAL_0, REAL_1, NAT_1, SEQ_1,
      FINSEQ_4, REALSET1, BINARITH, PRE_CIRC, AMI_5;
 registrations XBOOLE_0, SUBSET_1, SETFAM_1, RELAT_1, FUNCT_1, ORDINAL1,
      PARTFUN1, FUNCT_2, FUNCOP_1, FINSET_1, FRAENKEL, NUMBERS, XREAL_0, NAT_1,
      MEMBERED, FINSEQ_1, CARD_3, REALSET1, FINSEQ_5, PRE_CIRC, FUNCT_7,
      STRUCT_0, AMI_1, JORDAN1J;
 requirements NUMERALS, BOOLE, REAL, SUBSET, ARITHM;


begin :: Ami-Struct

reserve x for set,
        D for non empty set,
        k, n for Element of NAT,
        z for natural number;

reserve
  N for with_non-empty_elements set,
  S for IC-Ins-separated definite (non empty non void AMI-Struct over N),
  i for Element of the Instructions of S,
  l, l1, l2, l3 for Instruction-Location of S,
  s for State of S;

canceled 10;

theorem :: AMISTD_1:11
 for S being definite (non empty non void AMI-Struct over N),
     I being Element of the Instructions of S,
     s being State of S
  holds s +* ((the Instruction-Locations of S) --> I) is State of S;

registration
  let N be set, S be AMI-Struct over N;
 cluster empty -> programmed FinPartState of S;
end;

registration
  let N be set, S be AMI-Struct over N;
 cluster empty FinPartState of S;
end;

registration
 let N be with_non-empty_elements set,
     S be IC-Ins-separated definite (non empty non void AMI-Struct over N);
 cluster non empty trivial programmed FinPartState of S;
end;

registration let N be with_non-empty_elements set,
               S be non void AMI-Struct over N,
               i be Element of the Instructions of S,
               s be State of S;
 cluster ((the Execution of S).i).s -> Function-like Relation-like;

end;

registration
 let N be with_non-empty_elements set;
 let S be steady-programmed IC-Ins-separated definite
          (non empty non void AMI-Struct over N);
  cluster non empty trivial autonomic programmed FinPartState of S;
end;

theorem :: AMISTD_1:12
      for S being steady-programmed IC-Ins-separated definite
        (non empty non void AMI-Struct over N),
     il being Instruction-Location of S,
     I being Element of the Instructions of S
  holds il .--> I is autonomic;

theorem :: AMISTD_1:13
 for S being steady-programmed IC-Ins-separated definite
       (non empty non void AMI-Struct over N)
  holds S is programmable;

registration let N be with_non-empty_elements set;
 cluster steady-programmed -> programmable
         (IC-Ins-separated definite (non empty non void AMI-Struct over N));
end;

definition
 let N be with_non-empty_elements set;
 let S be non empty non void standard-ins AMI-Struct over N;
 let T be InsType of S;
 canceled 2;

 attr T is jump-only means
:: AMISTD_1:def 3
       for s being State of S, o being Object of S, I being Instruction of S
       st InsCode I = T & o <> IC S holds Exec(I, s).o = s.o;
end;

definition
 let N be with_non-empty_elements set;
 let S be non empty non void standard-ins AMI-Struct over N;
 let I be Instruction of S;
 attr I is jump-only means
:: AMISTD_1:def 4
       InsCode I is jump-only;
end;

definition
  let N,S,l;
  let i be Element of the Instructions of S;
 func NIC(i,l) -> Subset of the Instruction-Locations of S equals
:: AMISTD_1:def 5
   { IC Following s : IC s = l & s.l = i };
end;

registration
  let N be with_non-empty_elements set,
      S be realistic IC-Ins-separated definite
        (non empty non void AMI-Struct over N),
      i be Element of the Instructions of S,
      l be Instruction-Location of S;
  cluster NIC(i,l) -> non empty;
end;

definition let N,S,i;
 func JUMP i -> Subset of the Instruction-Locations of S equals
:: AMISTD_1:def 6
  meet { NIC(i,l) : not contradiction };
end;

definition let N,S,l;
 func SUCC l -> Subset of the Instruction-Locations of S equals
:: AMISTD_1:def 7
  union { NIC(i,l) \ JUMP i : not contradiction };
end;

theorem :: AMISTD_1:14
 for i being Element of the Instructions of S
  st the Instruction-Locations of S is non trivial &
  (for l being Instruction-Location of S holds NIC(i,l)={l})
  holds JUMP i is empty;

theorem :: AMISTD_1:15
 for S being realistic IC-Ins-separated definite
     (non empty non void AMI-Struct over N),
     il being Instruction-Location of S,
     i being Instruction of S st i is halting
  holds NIC(i,il) = {il};

begin :: Ordering of Instruction Locations

definition let N,S,l1,l2;
 pred l1 <= l2 means
:: AMISTD_1:def 8

  ex f being non empty IL-FinSequence of S st
   f/.1 = l1 & f/.len f = l2 &
   for n st 1 <= n & n < len f holds f/.(n+1) in SUCC f/.n;
 reflexivity;
end;

theorem :: AMISTD_1:16
      l1 <= l2 & l2 <= l3 implies l1 <= l3;

definition
 let N, S;
 attr S is InsLoc-antisymmetric means
:: AMISTD_1:def 9
       for l1, l2 st l1 <= l2 & l2 <= l1 holds l1 = l2;
end;

definition
 let N, S;
 attr S is standard means
:: AMISTD_1:def 10

 ex f being IL-Function of NAT, S st
  f is bijective & for m, n being Element of NAT holds m <= n iff f.m <= f.n;
end;

theorem :: AMISTD_1:17
 for f1, f2 being IL-Function of NAT, S
  st f1 is bijective & (for m, n being Element of NAT holds m <= n
  iff f1.m <= f1.n) &
     f2 is bijective & (for m, n being Element of NAT holds m <= n
     iff f2.m <= f2.n)
   holds f1 = f2;

theorem :: AMISTD_1:18
 for f being IL-Function of NAT, S
  st f is bijective holds
     (for m, n being Element of NAT holds m <= n iff f.m <= f.n) iff
     (for k being Element of NAT holds f.(k+1) in SUCC (f.k) &
           for j being Element of NAT st f.j in SUCC (f.k) holds k <= j);

theorem :: AMISTD_1:19
 S is standard iff
     ex f being IL-Function of NAT, S
      st f is bijective &
         for k being Element of NAT holds f.(k+1) in SUCC (f.k) &
           for j being Element of NAT st f.j in SUCC (f.k) holds k <= j;

begin :: Standard trivial computer

definition
 let N be with_non-empty_elements set;
 func STC N -> strict AMI-Struct over N means
:: AMISTD_1:def 11
 the carrier of it = NAT \/ {NAT} &
 the Instruction-Counter of it = NAT &
 the Instruction-Locations of it = NAT &
 the Instructions of it = {[0,0],[1,0]} &
 the Object-Kind of it =
              (NAT --> {[1,0],[0,0]}) +* (NAT .-->NAT) &
 ex f being Function of product the Object-Kind of it,
                        product the Object-Kind of it
  st (for s being Element of product the Object-Kind of it
       holds f.s = s+*(NAT .-->succ(s.NAT))) &
 the Execution of it
      = ([1,0] .--> f) +* ([0,0] .--> id product the Object-Kind of it);
end;

registration
 let N be with_non-empty_elements set;
 cluster the Instruction-Locations of STC N -> infinite;
end;

registration
 let N be with_non-empty_elements set;
 cluster STC N -> non empty non void standard-ins;
end;

registration
 let N be with_non-empty_elements set;
 cluster STC N -> IC-Ins-separated definite realistic steady-programmed;
end;

theorem :: AMISTD_1:20
 for i being Instruction of STC N st InsCode i = 0 holds
  i is halting;

theorem :: AMISTD_1:21
  for i being Instruction of STC N st InsCode i = 1 holds i is non halting;

theorem :: AMISTD_1:22
 for i being Element of the Instructions of STC N holds
  InsCode i = 1 or InsCode i = 0;

theorem :: AMISTD_1:23
     for i being Instruction of STC N holds i is jump-only;

theorem :: AMISTD_1:24
 for l being Instruction-Location of STC N
  st l = z holds SUCC l = {z, z+1};

registration
 let N be with_non-empty_elements set;
 cluster STC N -> standard;
end;

registration
 let N be with_non-empty_elements set;
 cluster STC N -> halting;
end;

registration
 let N be with_non-empty_elements set;
 cluster standard halting realistic steady-programmed programmable
         standard-ins
         (IC-Ins-separated definite
          (non empty non void AMI-Struct over N));
end;

reserve
  T for standard (IC-Ins-separated definite
        (non empty non void AMI-Struct over N));

definition
 let N be with_non-empty_elements set,
     S be standard (IC-Ins-separated definite
       (non empty non void AMI-Struct over N)),
     k be natural number;
 func il.(S,k) -> Instruction-Location of S means
:: AMISTD_1:def 12
 ex f being IL-Function of NAT, S st
   f is bijective &
   (for m, n being Element of NAT holds m <= n iff f.m <= f.n) &
   it = f.k;
end;

theorem :: AMISTD_1:25
 for k1, k2 being natural number st il.(T,k1) = il.(T,k2) holds k1 = k2;

theorem :: AMISTD_1:26
 for l being Instruction-Location of T
  ex k being natural number st l = il.(T,k);

definition
 let N be with_non-empty_elements set,
     S be standard (IC-Ins-separated definite
          (non empty non void AMI-Struct over N)),
     l be Instruction-Location of S;
 func locnum l -> natural number means
:: AMISTD_1:def 13
  il.(S,it) = l;
end;

definition
 let N be with_non-empty_elements set,
     S be standard (IC-Ins-separated definite
          (non empty non void AMI-Struct over N)),
     l be Instruction-Location of S;
 redefine func locnum l -> Element of NAT;
end;

theorem :: AMISTD_1:27
 for l1, l2 being Instruction-Location of T
  holds locnum l1 = locnum l2 implies l1 = l2;

theorem :: AMISTD_1:28
 for k1, k2 being natural number holds il.(T,k1) <= il.(T,k2) iff k1 <= k2;

theorem :: AMISTD_1:29
 for l1, l2 being Instruction-Location of T
  holds locnum l1 <= locnum l2 iff l1 <= l2;

theorem :: AMISTD_1:30
 S is standard implies S is InsLoc-antisymmetric;

registration let N;
 cluster standard -> InsLoc-antisymmetric
          (IC-Ins-separated definite (non empty non void AMI-Struct over N));
end;

definition
   let N be with_non-empty_elements set,
       S be standard (IC-Ins-separated definite
            (non empty non void AMI-Struct over N)),
       f be Instruction-Location of S,
       k be natural number;
 func f + k -> Instruction-Location of S equals
:: AMISTD_1:def 14
   il.(S,locnum f + k);
end;

theorem :: AMISTD_1:31
      for f being Instruction-Location of T holds f + 0 = f;

theorem :: AMISTD_1:32
      for f, g being Instruction-Location of T st f + z = g + z
  holds f = g;

theorem :: AMISTD_1:33
      for f being Instruction-Location of T
  holds locnum f + z = locnum (f + z);

definition
 let N be with_non-empty_elements set,
     S be standard (IC-Ins-separated definite
          (non empty non void AMI-Struct over N)),
     f be Instruction-Location of S;
 func NextLoc f -> Instruction-Location of S equals
:: AMISTD_1:def 15
   f + 1;
end;

theorem :: AMISTD_1:34
  for f being Instruction-Location of T
  holds NextLoc f = il.(T,locnum f + 1);

theorem :: AMISTD_1:35
 for f being Instruction-Location of T holds f <> NextLoc f;

theorem :: AMISTD_1:36
      for f, g being Instruction-Location of T st NextLoc f = NextLoc g
  holds f = g;

theorem :: AMISTD_1:37
 il.(STC N, z) = z;

theorem :: AMISTD_1:38
    for i being Instruction of STC N,
     s being State of STC N st InsCode i = 1
  holds Exec(i,s).IC STC N = NextLoc IC s;

theorem :: AMISTD_1:39
      for l being Instruction-Location of STC N,
       i being Element of the Instructions of STC N st InsCode i = 1
  holds NIC(i, l) = {NextLoc l};

theorem :: AMISTD_1:40
      for l being Instruction-Location of STC N
  holds SUCC l = {l, NextLoc l};

definition
  let N be with_non-empty_elements set,
      S be standard (IC-Ins-separated definite
          (non empty non void AMI-Struct over N)),
      i be Instruction of S;
 attr i is sequential means
:: AMISTD_1:def 16
       for s being State of S holds Exec(i, s).IC S = NextLoc IC s;
end;

theorem :: AMISTD_1:41
 for S being standard realistic
       (IC-Ins-separated definite (non empty non void AMI-Struct over N)),
     il being Instruction-Location of S,
     i being Instruction of S st i is sequential
  holds NIC(i,il) = {NextLoc il};

theorem :: AMISTD_1:42
 for S being realistic standard
       (IC-Ins-separated definite (non empty non void AMI-Struct over N)),
     i being Instruction of S st i is sequential
  holds i is non halting;

registration
 let N;
 let S be realistic standard
       (IC-Ins-separated definite (non empty non void AMI-Struct over N));
 cluster sequential -> non halting Instruction of S;
 cluster halting -> non sequential Instruction of S;
end;

theorem :: AMISTD_1:43
     for i being Instruction of T st JUMP i is non empty holds i is non
sequential;

begin :: Closedness of finite partial states

definition
 let N be with_non-empty_elements set;
 let S be IC-Ins-separated definite (non empty non void AMI-Struct over N);
 let F be FinPartState of S;
 attr F is closed means
:: AMISTD_1:def 17
  for l being Instruction-Location of S st l in dom F
   holds NIC (pi(F,l), l) c= dom F;

 attr F is really-closed means
:: AMISTD_1:def 18
       for s being State of S st F c= s & IC s in dom F
  for k being Element of NAT holds IC (Computation s).k in dom F;
end;

definition
 let N be with_non-empty_elements set;
 let S be standard (IC-Ins-separated definite
       (non empty non void AMI-Struct over N));
 let F be FinPartState of S;
 attr F is para-closed means
:: AMISTD_1:def 19
       for s being State of S st F c= s & IC s = il.(S,0)
  for k being Element of NAT holds IC (Computation s).k in dom F;
end;

theorem :: AMISTD_1:44
 for S being standard steady-programmed
       (IC-Ins-separated definite (non empty non void AMI-Struct over N)),
     F being FinPartState of S
 st F is really-closed & il.(S,0) in dom F holds F is para-closed;

theorem :: AMISTD_1:45
 for S being IC-Ins-separated definite steady-programmed
             (non empty non void AMI-Struct over N),
     F being FinPartState of S
 st F is closed holds F is really-closed;

registration
 let N be with_non-empty_elements set,
     S be IC-Ins-separated definite steady-programmed
          (non empty non void AMI-Struct over N);
 cluster closed -> really-closed FinPartState of S;
end;

theorem :: AMISTD_1:46
 for S being standard realistic halting
       (IC-Ins-separated definite (non empty non void AMI-Struct over N))
  holds il.(S,0) .--> halt S is closed;

definition
 let N be with_non-empty_elements set;
 let S be IC-Ins-separated definite (non empty non void AMI-Struct over N);
 let F be FinPartState of S;
 attr F is lower means
:: AMISTD_1:def 20
 for l being Instruction-Location of S st l in dom F
  holds for m being Instruction-Location of S st m <= l holds m in dom F;
end;

theorem :: AMISTD_1:47
 for F being empty FinPartState of S holds F is lower;

registration
  let N be with_non-empty_elements set,
      S be IC-Ins-separated definite (non empty non void AMI-Struct over N);
 cluster empty -> lower FinPartState of S;
end;

theorem :: AMISTD_1:48
 for i being Element of the Instructions of T holds il.(T,0) .--> i is lower;

registration
 let N be with_non-empty_elements set;
 let S be standard (IC-Ins-separated definite
        (non empty non void AMI-Struct over N));
 cluster lower non empty trivial programmed FinPartState of S;
end;

theorem :: AMISTD_1:49
 for F being lower non empty programmed FinPartState of T
  holds il.(T,0) in dom F;

theorem :: AMISTD_1:50
 for P being lower programmed FinPartState of T holds
  z < card P iff il.(T,z) in dom P;

definition
 let N be with_non-empty_elements set;
 let S be standard (IC-Ins-separated definite
        (non empty non void AMI-Struct over N));
 let F be non empty programmed FinPartState of S;
 func LastLoc F -> Instruction-Location of S means
:: AMISTD_1:def 21
  ex M being finite non empty natural-membered set st
     M = { locnum l where l is Instruction-Location of S
                        : l in dom F } &
     it = il.(S, max M);
end;

theorem :: AMISTD_1:51
 for F being non empty programmed FinPartState of T
  holds LastLoc F in dom F;

theorem :: AMISTD_1:52
      for F, G being non empty programmed FinPartState of T st F c= G
  holds LastLoc F <= LastLoc G;

theorem :: AMISTD_1:53
 for F being non empty programmed FinPartState of T,
     l being Instruction-Location of T st l in dom F
 holds l <= LastLoc F;

theorem :: AMISTD_1:54
      for F being lower non empty programmed FinPartState of T,
     G being non empty programmed FinPartState of T
 holds F c= G & LastLoc F = LastLoc G implies F = G;

theorem :: AMISTD_1:55
 for F being lower non empty programmed FinPartState of T
  holds LastLoc F = il.(T, card F -' 1);

registration
 let N be with_non-empty_elements set,
     S be standard steady-programmed (IC-Ins-separated
       definite (non empty non void AMI-Struct over N));
 cluster really-closed lower non empty programmed -> para-closed
                                                     FinPartState of S;
end;

definition
 let N be with_non-empty_elements set,
     S be standard halting (IC-Ins-separated definite
          (non empty non void AMI-Struct over N)),
     F be non empty programmed FinPartState of S;
 attr F is halt-ending means
:: AMISTD_1:def 22
       F.(LastLoc F) = halt S;
 attr F is unique-halt means
:: AMISTD_1:def 23
       for f being Instruction-Location of S st F.f = halt S & f in dom F
   holds f = LastLoc F;
end;

registration
 let N be with_non-empty_elements set;
 let S be standard halting (IC-Ins-separated definite
       (non empty non void AMI-Struct over N));
 cluster halt-ending unique-halt trivial (lower non empty programmed
         FinPartState of S);
end;

registration
 let N be with_non-empty_elements set;
 let S be standard halting realistic (IC-Ins-separated
       definite (non empty non void AMI-Struct over N));
 cluster trivial closed lower non empty programmed FinPartState of S;
end;

registration
 let N be with_non-empty_elements set;
 let S be standard halting realistic (IC-Ins-separated
       definite (non empty non void AMI-Struct over N));
 cluster halt-ending unique-halt trivial closed (lower non empty programmed
         FinPartState of S);
end;

registration
 let N be with_non-empty_elements set;
 let S be standard halting realistic steady-programmed
          (IC-Ins-separated definite (non empty non void AMI-Struct over N));
 cluster halt-ending unique-halt autonomic trivial closed
         (lower non empty programmed FinPartState of S);
end;

definition
 let N be with_non-empty_elements set;
 let S be standard halting (IC-Ins-separated definite
          (non empty non void AMI-Struct over N));
 mode pre-Macro of S is halt-ending unique-halt (lower non empty programmed
                        FinPartState of S);
end;

registration
 let N be with_non-empty_elements set;
 let S be standard realistic halting
          (IC-Ins-separated definite (non empty non void AMI-Struct over N));
 cluster closed pre-Macro of S;
end;

