:: Equivalence Relations and Classes of Abstraction
::  by Konrad Raczkowski and Pawe{\l} Sadowski
::
:: Received November 16, 1989
:: Copyright (c) 1990 Association of Mizar Users

environ

 vocabularies RELAT_1, SETFAM_1, ARYTM_1, BOOLE, RELAT_2, LATTICES, FINSEQ_1,
      FUNCT_1, TARSKI, EQREL_1, PARTFUN1, TOLER_1, AMI_1, T_1TOPSP, PUA2MSS1,
      PROB_1, COMPLEX1;
 notations TARSKI, XBOOLE_0, ZFMISC_1, SUBSET_1, XCMPLX_0, XXREAL_0, RELAT_1,
      RELAT_2, RELSET_1, SETFAM_1, FINSEQ_1, FUNCT_1, NUMBERS, NAT_1, PARTFUN1;
 constructors SETFAM_1, RELAT_2, PARTFUN1, XXREAL_0, XREAL_0, NAT_1, FINSEQ_1;
 registrations XBOOLE_0, SUBSET_1, PARTFUN1, XXREAL_0, XREAL_0, FINSEQ_1,
      RELAT_1, ORDINAL1;
 requirements REAL, NUMERALS, SUBSET, BOOLE, ARITHM;


begin

 reserve X,Y,Z,x,y,y1,y2,z for set;
 reserve i,j,k for Element of NAT;
 reserve A,B,C for Subset of X;
 reserve R,R1,R2 for Relation of X;
 reserve AX for Subset of [:X,X:];
 reserve SFXX for Subset-Family of [:X,X:];

:: Equivalence Relation and its properties

definition let X;
  func nabla X -> Relation of X equals
:: EQREL_1:def 1
  [:X,X:];
end;

registration let X;
  cluster nabla X -> total reflexive;
end;

definition let X; let R1,R2;
  redefine func R1 /\ R2 -> Relation of X;
  func R1 \/ R2 -> Relation of X;
end;

theorem :: EQREL_1:1
   nabla X \/ R1 = nabla X;

canceled 2;

theorem :: EQREL_1:4
  id X is_reflexive_in X & id X is_symmetric_in X &
id X is_transitive_in X;

definition let X;
  mode Tolerance of X is total reflexive symmetric Relation of X;
  mode Equivalence_Relation of X is total symmetric transitive Relation of X;
end;

canceled;

theorem :: EQREL_1:6
   id X is Equivalence_Relation of X;

theorem :: EQREL_1:7
  nabla X is Equivalence_Relation of X;

registration let X;
  cluster nabla X -> total symmetric transitive;
end;

 reserve EqR,EqR1,EqR2,EqR3 for Equivalence_Relation of X;

canceled 3;

theorem :: EQREL_1:11
  for R being total reflexive Relation of X holds
    x in X implies [x,x] in R;

theorem :: EQREL_1:12
  for R being total symmetric Relation of X holds
    [x,y] in R implies [y,x] in R;

theorem :: EQREL_1:13
  for R being total transitive Relation of X holds
    [x,y] in R & [y,z] in R implies [x,z] in R;

theorem :: EQREL_1:14
   for R being total reflexive Relation of X holds
    (ex x being set st x in X) implies R <> {};

canceled;

theorem :: EQREL_1:16
  R is Equivalence_Relation of X iff
    R is reflexive symmetric transitive & field R = X;

definition let X; let EqR1,EqR2;
  redefine func EqR1 /\ EqR2 -> Equivalence_Relation of X;
end;

theorem :: EQREL_1:17
   id X /\ EqR = id X;

canceled;

theorem :: EQREL_1:19
  for SFXX st (SFXX <> {} & for Y st Y in SFXX
   holds Y is Equivalence_Relation of X)
    holds meet SFXX is Equivalence_Relation of X;

theorem :: EQREL_1:20
  for R holds ex EqR st R c= EqR & for EqR2 st R c= EqR2 holds EqR c= EqR2;

definition let X; let EqR1,EqR2;
 canceled;

  func EqR1 "\/" EqR2 -> Equivalence_Relation of X means
:: EQREL_1:def 3
  EqR1 \/ EqR2 c= it & for EqR st EqR1 \/ EqR2 c= EqR holds it c= EqR;
 commutativity;
 idempotence;
end;

theorem :: EQREL_1:21
    (EqR1 "\/" EqR2) "\/" EqR3 = EqR1 "\/" (EqR2 "\/" EqR3);

theorem :: EQREL_1:22
   EqR "\/" EqR = EqR;

theorem :: EQREL_1:23
  EqR1 "\/" EqR2 = EqR2 "\/" EqR1;

theorem :: EQREL_1:24
   EqR1 /\ (EqR1 "\/" EqR2) = EqR1;

theorem :: EQREL_1:25
   EqR1 "\/" (EqR1 /\ EqR2) = EqR1;

scheme :: EQREL_1:sch 1
 ExEqRel {X() -> set,P[set,set]}:
  ex EqR being Equivalence_Relation of X() st
  for x,y holds [x,y] in EqR iff x in X() & y in X() & P[x,y]
  provided
 for x st x in X() holds P[x,x] and
 for x,y st P[x,y] holds P[y,x] and
 for x,y,z st P[x,y] & P[y,z] holds P[x,z];

:: Classes of abstraction

notation let R be Relation,
               x be set;
 synonym Class(R,x) for Im(R,x);
end;

definition let X, Y be set,
               R be Relation of X, Y,
               x be set;
 canceled;
  redefine func Class(R,x) -> Subset of Y;
end;

theorem :: EQREL_1:26
   for R being Relation holds
    y in Class (R,x) iff [x,y] in R;

theorem :: EQREL_1:27
  for R being total symmetric Relation of X holds
    y in Class (R,x) iff [y,x] in R;

theorem :: EQREL_1:28
  for R being Tolerance of X holds
    for x st x in X holds x in Class (R,x);

theorem :: EQREL_1:29
    for R being Tolerance of X holds
    for x st x in X holds ex y st x in Class(R,y);

theorem :: EQREL_1:30
    for R being transitive Tolerance of X holds
    y in Class(R,x) & z in Class(R,x) implies [y,z] in R;

theorem :: EQREL_1:31
  for x st x in X holds y in Class(EqR,x) iff Class(EqR,x) = Class(EqR,y);

theorem :: EQREL_1:32
  for x,y st x in X & y in X holds Class(EqR,x) = Class(EqR,y) or
    Class(EqR,x) misses Class(EqR,y);

theorem :: EQREL_1:33
   for x st x in X holds Class(id X,x) = {x};

theorem :: EQREL_1:34
for x st x in X holds Class(nabla X,x) = X;

theorem :: EQREL_1:35
(ex x st Class(EqR,x) = X) implies EqR = nabla X;

theorem :: EQREL_1:36
    x in X implies ([x,y] in EqR1 "\/" EqR2 iff
ex f being FinSequence st 1 <= len f & x = f.1 & y = f.(len f) &
for i st 1 <= i & i < len f holds [f.i,f.(i+1)] in EqR1 \/ EqR2);

theorem :: EQREL_1:37
for E being Equivalence_Relation of X st E = EqR1 \/ EqR2 holds
for x st x in X holds
Class(E,x) = Class(EqR1,x) or Class(E,x) = Class(EqR2,x);

theorem :: EQREL_1:38
   EqR1 \/ EqR2 = nabla X implies EqR1 = nabla X or EqR2 = nabla X;

definition let X; let EqR;
  func Class EqR -> Subset-Family of X means
:: EQREL_1:def 5
  A in it iff ex x st x in X & A = Class(EqR,x);
 end;

canceled;

theorem :: EQREL_1:40
  X = {} implies Class EqR = {};

definition let X;
  mode a_partition of X -> Subset-Family of X means
:: EQREL_1:def 6
  union it = X & for A st A in it holds A<>{} &
  for B st B in it holds A = B or A misses B if X <> {} otherwise it = {};
end;

canceled;

theorem :: EQREL_1:42
  Class EqR is a_partition of X;

theorem :: EQREL_1:43
  for P being a_partition of X holds ex EqR st P = Class EqR;

theorem :: EQREL_1:44
   for x st x in X holds [x,y] in EqR iff Class(EqR,x) = Class(EqR,y);

theorem :: EQREL_1:45
   x in Class EqR implies ex y being Element of X st x = Class(EqR,y);

begin :: Addenda

:: from FSM_1, PARTIT1, 2005.02.06, A.T.

registration let X be non empty set;
 cluster -> non empty a_partition of X;
end;

:: from PUA2MSS1

registration let X be set;
  cluster -> with_non-empty_elements a_partition of X;
end;

definition let X be set, R be Equivalence_Relation of X;
  redefine func Class R -> a_partition of X;
end;

:: from PRALG_3

registration let I be non empty set, R be Equivalence_Relation of I;
  cluster Class R -> non empty;
end;

registration let I be non empty set, R be Equivalence_Relation of I;
  cluster Class R -> with_non-empty_elements;
end;

notation let I be non empty set, R be Equivalence_Relation of I;
  let x be Element of I;
  synonym EqClass(R,x) for Class(R,x);
end;

definition let I be non empty set, R be Equivalence_Relation of I;
  let x be Element of I;
  redefine func EqClass(R,x) -> Element of Class R;
end;

definition let X be set;
  func SmallestPartition X -> a_partition of X equals
:: EQREL_1:def 7
     Class id X;
end;

theorem :: EQREL_1:46
  for X being non empty set holds
   SmallestPartition X = {{x} where x is Element of X: not contradiction};

:: from T_1TOPSP, 30.12.2006, AK

:: Classes of partitions of a set

reserve X for non empty set, x for Element of X, y,v,w for set;

definition
 let X be non empty set,x be Element of X,S1 be a_partition of X;
 func EqClass(x,S1) -> Subset of X means
:: EQREL_1:def 8
 x in it & it in S1;
end;

theorem :: EQREL_1:47
 for S1,S2 being a_partition of X st
 (for x being Element of X holds EqClass(x,S1) = EqClass(x,S2)) holds S1=S2;

theorem :: EQREL_1:48
 for X being non empty set holds {X} is a_partition of X;

definition let X be set;
  mode Family-Class of X means
:: EQREL_1:def 9
   it c= bool bool X;
end;

definition let X be set;
 let F be Family-Class of X;
 attr F is partition-membered means
:: EQREL_1:def 10
   for S being set st S in F holds S is a_partition of X;
end;

registration let X be set;
 cluster partition-membered Family-Class of X;
end;

definition let X be set;
  mode Part-Family of X is partition-membered Family-Class of X;
end;

reserve F for Part-Family of X;

registration
 let X be non empty set;
 cluster non empty a_partition of X;
end;

theorem :: EQREL_1:49
 for X being set, p being a_partition of X holds
  {p} is Part-Family of X;

registration let X be set;
 cluster non empty Part-Family of X;
end;

theorem :: EQREL_1:50
 for S1 being a_partition of X,
     x,y being Element of X holds
    EqClass(x,S1) meets EqClass(y,S1) implies EqClass(x,S1) = EqClass(y,S1);

theorem :: EQREL_1:51
  for A being set,X being non empty set,S being a_partition of X holds
 A in S implies ex x being Element of X st A = EqClass(x,S);

definition
 let X be non empty set,F be non empty Part-Family of X;
 func Intersection F -> non empty a_partition of X means
:: EQREL_1:def 11
  for x being Element of X holds EqClass(x,it)
  = meet{EqClass(x,S) where S is a_partition of X : S in F};
end;

theorem :: EQREL_1:52
 for X being non empty set,
     S being a_partition of X,
     A being Subset of S holds (union S) \ (union A) = union (S \ A);

theorem :: EQREL_1:53
  for X being non empty set,A being Subset of X,
     S being a_partition of X holds A in S implies union(S \ {A}) = X \ A;

