:: Ring Ideals
::  by Jonathan Backer , Piotr Rudnicki and Christoph Schwarzweller
::
:: Received November 20, 2000
:: Copyright (c) 2000 Association of Mizar Users

environ

 vocabulary RLVECT_1, ALGSTR_1, VECTSP_1, VECTSP_2, BINOM, BINOP_1, LATTICES,
      REALSET1, FINSEQ_1, FILTER_2, ALGSTR_2, COLLSP, BOOLE, ARYTM_1, GROUP_1,
      RELAT_1, FUNCT_1, FUNCT_7, ARYTM_3, FINSEQ_4, PRELAMB, MCART_1, SETFAM_1,
      RLVECT_3, SUBSET_1, GCD_1, LATTICE3, SQUARE_1, NEWTON, FINSET_1, INT_3,
      WAYBEL_0, TARSKI, NORMSP_1, GR_CY_1, IDEAL_1;
 notation TARSKI, XBOOLE_0, ZFMISC_1, SUBSET_1, CQC_SIM1, FINSET_1, FUNCT_1,
      FINSEQ_1, VECTSP_1, INT_3, NORMSP_1, NUMBERS, XCMPLX_0, XREAL_0, NAT_1,
      RELSET_1, RLVECT_1, PARTFUN1, FUNCT_2, ALGSTR_1, PRE_TOPC, GR_CY_1,
      PRE_CIRC, MCART_1, DOMAIN_1, FINSEQ_4, POLYNOM1, SETFAM_1, STRUCT_0,
      GROUP_1, BINOP_1, VECTSP_2, FUNCT_7, REALSET1, GCD_1, BINOM;
 constructors INT_3, CQC_SIM1, PRE_CIRC, GROUP_2, ALGSEQ_1, BINOM, GCD_1,
      ALGSTR_2, DOMAIN_1, POLYNOM1, MONOID_0, BINOP_1, PRE_TOPC;
 clusters INT_3, RELSET_1, FINSET_1, SUBSET_1, VECTSP_2, STRUCT_0, PRE_TOPC,
      FINSEQ_1, FINSEQ_5, XBOOLE_0, POLYNOM1, INT_1, GCD_1, BINOM, REALSET1,
      VECTSP_1, NAT_1, XREAL_0, MEMBERED, RELAT_1, FUNCT_2, PRE_CIRC, NUMBERS,
      ORDINAL2;
 requirements NUMERALS, REAL, SUBSET, BOOLE, ARITHM;


begin :: Preliminaries

registration
cluster add-associative left_zeroed right_zeroed (non empty LoopStr);
 existence
  proof consider R being non degenerated comRing; take R; thus thesis; end;
end;


registration
cluster
  Abelian left_zeroed right_zeroed add-cancelable well-unital add-associative
  associative commutative distributive non trivial (non empty doubleLoopStr);
existence
 proof consider R being non degenerated comRing; take R; thus thesis; end;
end;


theorem :: IDEAL_1:1
for V being add-associative left_zeroed right_zeroed (non empty LoopStr),
    v,u being Element of V
 holds Sum <* v,u *> = v + u;

begin :: Ideals

definition
 let L be non empty LoopStr, F being Subset of L;
 attr F is add-closed means
:: IDEAL_1:def 1
  for x, y being Element of L st x in F & y in F holds x+y in
 F;
end;


definition
 let L be non empty HGrStr, F be Subset of L;
 attr F is left-ideal means
:: IDEAL_1:def 2
  for p, x being Element of L st x in F holds p*x in F;
 attr F is right-ideal means
:: IDEAL_1:def 3
  for p, x being Element of L st x in F holds x*p in F;
end;


registration
let L be non empty LoopStr;
cluster add-closed (non empty Subset of L);
existence proof set M = the carrier of L;
   for u being set holds u in M implies u in the carrier of L;
 then reconsider M as Subset of L by TARSKI:def 3;
 reconsider M as non empty Subset of L;
 take M;
   for x, y being Element of L st x in M & y in M holds x+y in M
;
 hence thesis by Def1;
end;
end;


registration
let L be non empty HGrStr;
cluster left-ideal (non empty Subset of L);
existence proof set M = the carrier of L;
   for u being set holds u in M implies u in the carrier of L;
 then reconsider M as Subset of L by TARSKI:def 3;
 reconsider M as non empty Subset of L;
 take M;
   for p, x being Element of L st x in M holds p*x in M;
 hence thesis by Def2;
 end;
cluster right-ideal (non empty Subset of L);
existence proof set M = the carrier of L;
   for u being set holds u in M implies u in the carrier of L;
 then reconsider M as Subset of L by TARSKI:def 3;
 reconsider M as non empty Subset of L;
 take M;
   for p, x being Element of L st x in M holds x*p in M;
 hence thesis by Def3;
 end;
end;


registration
let L be non empty doubleLoopStr;
cluster add-closed left-ideal right-ideal (non empty Subset of L);
existence proof set M = the carrier of L;
   for u being set holds u in M implies u in the carrier of L;
 then reconsider M as Subset of L by TARSKI:def 3;
 reconsider M as non empty Subset of L;
 take M;
 A1: for x,y being Element of L st x in M & y in M holds x+y in
 M;
 A2: for p,x being Element of L st x in M holds p*x in M;
   for p, x being Element of L st x in M holds x*p in M;
 hence thesis by A1,A2,Def1,Def2,Def3;
 end;
cluster add-closed right-ideal (non empty Subset of L);
existence proof set M = the carrier of L;
   for u being set holds u in M implies u in the carrier of L;
 then reconsider M as Subset of L by TARSKI:def 3;
 reconsider M as non empty Subset of L;
 take M;
 A3: for x,y being Element of L st x in M & y in M holds x+y in
 M;
   for p, x being Element of L st x in M holds x*p in M;
 hence thesis by A3,Def1,Def3;
 end;
cluster add-closed left-ideal (non empty Subset of L);
existence proof set M = the carrier of L;
   for u being set holds u in M implies u in the carrier of L;
 then reconsider M as Subset of L by TARSKI:def 3;
 reconsider M as non empty Subset of L;
 take M;
 A4: for x,y being Element of L st x in M & y in M holds x+y in
 M;
   for p, x being Element of L st x in M holds p*x in M;
 hence thesis by A4,Def1,Def2;
 end;
end;


registration
let R be commutative (non empty HGrStr);
cluster left-ideal -> right-ideal (non empty Subset of R);
coherence proof let I be non empty Subset of R; assume I is left-ideal;
 then for p,x being Element of R st x in I holds x*p in
 I by Def2;
 hence thesis by Def3;
 end;
cluster right-ideal -> left-ideal (non empty Subset of R);
coherence proof let I be non empty Subset of R; assume I is right-ideal;
 then for p,x being Element of R st x in I holds p*x in
 I by Def3;
 hence thesis by Def2;
 end;
end;


definition
let L be non empty doubleLoopStr;
mode Ideal of L is add-closed left-ideal right-ideal (non empty Subset of L);
end;


definition
let L be non empty doubleLoopStr;
mode RightIdeal of L is add-closed right-ideal (non empty Subset of L);
end;


definition
let L be non empty doubleLoopStr;
mode LeftIdeal of L is add-closed left-ideal (non empty Subset of L);
end;


theorem :: IDEAL_1:2
for R being right_zeroed add-left-cancelable
            left-distributive (non empty doubleLoopStr),
    I being left-ideal (non empty Subset of R)
 holds 0.R in I;

theorem :: IDEAL_1:3
for R being left_zeroed add-right-cancelable
            right-distributive (non empty doubleLoopStr),
    I being right-ideal (non empty Subset of R)
 holds 0.R in I;

theorem :: IDEAL_1:4
for L being right_zeroed (non empty doubleLoopStr) holds {0.L} is add-closed;

theorem :: IDEAL_1:5
for L being left_zeroed add-right-cancelable
            right-distributive (non empty doubleLoopStr)
  holds {0.L} is left-ideal;

theorem :: IDEAL_1:6
for L being right_zeroed add-left-cancelable
            left-distributive (non empty doubleLoopStr)
  holds {0.L} is right-ideal;

theorem :: IDEAL_1:7
for L being add-associative right_zeroed right_complementable
             distributive (non empty doubleLoopStr)
  holds {0.L} is Ideal of L;

theorem :: IDEAL_1:8
  for L being add-associative right_zeroed right_complementable
             right-distributive (non empty doubleLoopStr)
  holds {0.L} is LeftIdeal of L;

theorem :: IDEAL_1:9
  for L being add-associative right_zeroed right_complementable
             left-distributive (non empty doubleLoopStr)
  holds {0.L} is RightIdeal of L;

theorem :: IDEAL_1:10
 for L being non empty doubleLoopStr holds the carrier of L is Ideal of L;

theorem :: IDEAL_1:11
 for L being non empty doubleLoopStr holds the carrier of L is LeftIdeal of L;

theorem :: IDEAL_1:12
 for L being non empty doubleLoopStr holds the carrier of L is RightIdeal of L;

definition
let R be left_zeroed right_zeroed add-cancelable
         distributive (non empty doubleLoopStr),
    I be Ideal of R;
redefine attr I is trivial means
:: IDEAL_1:def 4
    I = {0.R};
end;


definition
let S be 1-sorted,
    T be Subset of S;
attr T is proper means
:: IDEAL_1:def 5
  T <> the carrier of S;
end;


registration
let S be non empty 1-sorted;
cluster proper Subset of S;
existence proof for u being set holds u in {} implies u in the carrier of S;
then reconsider e = {} as Subset of S by TARSKI:def 3;
reconsider e as Subset of S;
take e; thus thesis by Def5;
end;
end;


registration
let R be non trivial left_zeroed right_zeroed add-cancelable
         distributive (non empty doubleLoopStr);
cluster proper Ideal of R;
existence proof
 reconsider M = {0.R} as Ideal of R by Th4,Th5,Th6;
   ex a being Element of R st a <> 0.R proof
   assume A1: not(ex a being Element of R st a <> 0.R);
   A2: for u being set holds u in {0.R} implies u in the carrier of R;
     for u being set holds u in the carrier of R implies u in {0.R} proof
      let u be set; assume u in the carrier of R;
      then reconsider u as Element of R; u = 0.R by A1;
      hence thesis by TARSKI:def 1;
      end;
   then A3: the carrier of R = {0.R} by A2,TARSKI:2;
     the carrier of R is non trivial by REALSET1:def 13;
   hence thesis by A3,REALSET1:def 12;
   end;
 then {0.R} <> the carrier of R by TARSKI:def 1; then M is proper by Def5;
 hence thesis;
 end;
end;


theorem :: IDEAL_1:13
 for L being add-associative right_zeroed right_complementable
             left-distributive left_unital (non empty doubleLoopStr),
     I being left-ideal (non empty Subset of L),
     x being Element of L
  st x in I holds -x in I;

theorem :: IDEAL_1:14
 for L being add-associative right_zeroed right_complementable
             right-distributive right_unital (non empty doubleLoopStr),
     I being right-ideal (non empty Subset of L),
     x being Element of L
  st x in I holds -x in I;

theorem :: IDEAL_1:15
   for L being add-associative right_zeroed right_complementable
             left-distributive left_unital (non empty doubleLoopStr),
     I being LeftIdeal of L, x,y being Element of L
  st x in I & y in I holds x-y in I;

theorem :: IDEAL_1:16
   for L being add-associative right_zeroed right_complementable
             right-distributive right_unital (non empty doubleLoopStr),
     I being RightIdeal of L, x,y being Element of L
  st x in I & y in I holds x-y in I;

theorem :: IDEAL_1:17
for R being left_zeroed right_zeroed add-cancelable
            add-associative distributive (non empty doubleLoopStr),
    I being add-closed right-ideal (non empty Subset of R),
    a being Element of I, n being Nat
 holds n*a in I;

theorem :: IDEAL_1:18
  for R being unital left_zeroed right_zeroed add-cancelable associative
            distributive (non empty doubleLoopStr),
    I being right-ideal (non empty Subset of R),
    a being Element of I, n being Nat
  st n <> 0 holds a|^n in I;

definition
let R be non empty LoopStr,
    I be add-closed (non empty Subset of R);
func add|(I,R) -> BinOp of I equals
:: IDEAL_1:def 6
  (the add of R)|[:I,I:];
end;


definition
let R be non empty HGrStr,
    I be right-ideal (non empty Subset of R);
func mult|(I,R) -> BinOp of I equals
:: IDEAL_1:def 7
    (the mult of R)|[:I,I:];
end;


definition
let R be non empty LoopStr,
    I be add-closed (non empty Subset of R);
func Gr(I,R) -> non empty LoopStr equals
:: IDEAL_1:def 8
  LoopStr (#I,add|(I,R),In (0.R,I)#);
end;


registration
let R be left_zeroed right_zeroed add-cancelable
         add-associative distributive (non empty doubleLoopStr),
    I be add-closed (non empty Subset of R);
cluster Gr(I,R) -> add-associative;
coherence proof set M = LoopStr (#I,add|(I,R),In (0.R,I)#);
 A1: M = Gr(I,R) by Def8;
 reconsider M as non empty LoopStr;
   now let u be set;
   assume A2: u in [:I,I:];
     dom(the add of R) = [:the carrier of R,the carrier of R:] by FUNCT_2:def 1
;
   hence u in dom(the add of R) by A2;
   end;
 then [:I,I:] c= dom(the add of R) by TARSKI:def 3;
 then A3: dom((the add of R)|[:I,I:]) = [:I,I:] by RELAT_1:91;
 A4: for a,b being Element of M, a',b' being Element of I
     st a' = a & b' = b holds a + b = a' + b' proof
     let a,b be Element of M, a',b' be Element of I;
     assume a' = a & b' = b;
     hence a + b = (add|(I,R)).[a',b'] by RLVECT_1:def 3
               .= ((the add of R)|[:I,I:]).[a',b'] by Def6
               .= (the add of R).[a',b'] by A3,FUNCT_1:70
               .= a' + b' by RLVECT_1:def 3;
     end;
   now let a,b,c be Element of M;
     reconsider a' = a, b' = b, c' = c as Element of I;
       a' + b' in I by Def1;
     then A5: [a'+b',c'] in dom((the add of R)|[:I,I:]) by A3,ZFMISC_1:def 2;
       b' + c' in I by Def1;
     then A6: [a',b'+c'] in dom((the add of R)|[:I,I:]) by A3,ZFMISC_1:def 2;
     thus (a + b) + c = (the add of M).[a+b,c] by RLVECT_1:def 3
                     .= (add|(I,R)).[a'+b',c'] by A4
                     .= ((the add of R)|[:I,I:]).[a'+b',c'] by Def6
                     .= (the add of R).[a'+b',c'] by A5,FUNCT_1:70
                     .= (a'+b') + c' by RLVECT_1:def 3
                     .= a' + (b' + c') by RLVECT_1:def 6
                     .= (the add of R).[a',b'+c'] by RLVECT_1:def 3
                     .= ((the add of R)|[:I,I:]).[a',b'+c'] by A6,FUNCT_1:70
                     .= (add|(I,R)).[a',b'+c'] by Def6
                     .= (the add of M).[a,b+c] by A4
                     .= a + (b + c) by RLVECT_1:def 3;
     end;
 hence thesis by A1,RLVECT_1:def 6;
 end;
end;


registration
let R be left_zeroed right_zeroed add-cancelable
         add-associative distributive (non empty doubleLoopStr),
    I be add-closed right-ideal (non empty Subset of R);
cluster Gr(I,R) -> right_zeroed;
coherence proof set M = LoopStr (#I,add|(I,R),In (0.R,I)#);
 A1: M = Gr(I,R) by Def8;
 reconsider M as non empty LoopStr;
   now let u be set;
   assume A2: u in [:I,I:];
     dom(the add of R) = [:the carrier of R,the carrier of R:] by FUNCT_2:def 1
;
   hence u in dom(the add of R) by A2;
   end;
 then [:I,I:] c= dom(the add of R) by TARSKI:def 3;
 then A3: dom((the add of R)|[:I,I:]) = [:I,I:] by RELAT_1:91;
   now let a be Element of M;
     reconsider a' = a as Element of I;
     A4: 0.R in I by Th3;
     then A5: [a',0.R] in dom((the add of R)|[:I,I:]) by A3,ZFMISC_1:def 2;
     thus a + 0.M = a + (the Zero of M) by RLVECT_1:def 2
                 .= (the add of M).[a,(In (0.R,I))] by RLVECT_1:def 3
                 .= (the add of M).[a,0.R] by A4,FUNCT_7:def 1
                 .= ((the add of R)|[:I,I:]).[a',0.R] by Def6
                 .= (the add of R).[a',0.R] by A5,FUNCT_1:70
                 .= a' + 0.R by RLVECT_1:def 3
                 .= a by RLVECT_1:def 7;
     end;
 hence thesis by A1,RLVECT_1:def 7;
 end;
end;


registration
let R be Abelian (non empty doubleLoopStr),
    I be add-closed (non empty Subset of R);
cluster Gr(I,R) -> Abelian;
coherence proof set M = LoopStr (#I,add|(I,R),In (0.R,I)#);
 A1: M = Gr(I,R) by Def8;
 reconsider M as non empty LoopStr;
   now let u be set;
   assume A2: u in [:I,I:];
     dom(the add of R) = [:the carrier of R,the carrier of R:] by FUNCT_2:def 1
;
   hence u in dom(the add of R) by A2;
   end;
 then [:I,I:] c= dom(the add of R) by TARSKI:def 3;
 then A3: dom((the add of R)|[:I,I:]) = [:I,I:] by RELAT_1:91;
 A4: for a,b being Element of M, a',b' being Element of I
     st a' = a & b' = b holds a + b = a' + b' proof
     let a,b be Element of M, a',b' be Element of I;
     assume a' = a & b' = b;
     hence a + b = (add|(I,R)).[a',b'] by RLVECT_1:def 3
               .= ((the add of R)|[:I,I:]).[a',b'] by Def6
               .= (the add of R).[a',b'] by A3,FUNCT_1:70
               .= a' + b' by RLVECT_1:def 3;
     end;
   now let a,b be Element of M;
   reconsider a' = a, b' = b as Element of I;
   thus a + b = a' + b' by A4 .= b + a by A4;
   end;
 hence thesis by A1,RLVECT_1:def 5;
 end;
end;


registration
let R be Abelian right_unital left_zeroed right_zeroed right_complementable
         add-associative distributive (non empty doubleLoopStr),
    I be add-closed right-ideal (non empty Subset of R);
cluster Gr(I,R) -> right_complementable;
coherence proof set M = LoopStr (#I,add|(I,R),In (0.R,I)#);
 A1: M = Gr(I,R) by Def8;
 reconsider M as non empty LoopStr;
   now let u be set;
   assume A2: u in [:I,I:];
     dom(the add of R) = [:the carrier of R,the carrier of R:] by FUNCT_2:def 1
;
   hence u in dom(the add of R) by A2;
   end;
 then [:I,I:] c= dom(the add of R) by TARSKI:def 3;
 then A3: dom((the add of R)|[:I,I:]) = [:I,I:] by RELAT_1:91;
 A4: for a,b being Element of M, a',b' being Element of I
     st a' = a & b' = b holds a + b = a' + b' proof
     let a,b be Element of M, a',b' be Element of I;
     assume a' = a & b' = b;
     hence a + b = (add|(I,R)).[a',b'] by RLVECT_1:def 3
               .= ((the add of R)|[:I,I:]).[a',b'] by Def6
               .= (the add of R).[a',b'] by A3,FUNCT_1:70
               .= a' + b' by RLVECT_1:def 3;
     end;
 reconsider I as RightIdeal of R;
   now let a be Element of M;
     A5: 0.R in I by Th3;
     reconsider a' = a as Element of I;
     reconsider b = -a' as Element of M by Th14;
       a + b = a' + -a' by A4 .= 0.R by RLVECT_1:16
      .= the Zero of M by A5,FUNCT_7:def 1
      .= 0.M by RLVECT_1:def 2;
     hence ex b being Element of M st a + b = 0.M;
     end;
 hence thesis by A1,RLVECT_1:def 8;
 end;
end;

theorem :: IDEAL_1:19
for R being right_unital (non empty doubleLoopStr),
    I being left-ideal (non empty Subset of R)
  holds I is proper iff not(1_ R in I);

theorem :: IDEAL_1:20
  for R being left_unital right_unital (non empty doubleLoopStr),
    I being right-ideal (non empty Subset of R)
  holds I is proper iff
for u being Element of R st u is unital holds not(u in I);

theorem :: IDEAL_1:21
  for R being right_unital (non empty doubleLoopStr),
    I being left-ideal right-ideal (non empty Subset of R)
 holds I is proper iff for u being Element of R st u is unital holds not(u in
 I);

theorem :: IDEAL_1:22
  for R being non degenerated comRing
 holds R is Field iff
       for I being Ideal of R holds (I = {0.R} or I = the carrier of R);

begin  :: Linear combinations

definition
  let R be non empty multLoopStr,
      A be non empty Subset of R;
  mode LinearCombination of A -> FinSequence of the carrier of R
                                                                  means
:: IDEAL_1:def 9
    for i being set st i in dom it
      ex u,v being Element of R, a being Element of A st it/.i = u*a*v;
  mode LeftLinearCombination of A -> FinSequence of the carrier of R
                                                                 means
:: IDEAL_1:def 10
    for i being set st i in dom it
      ex u being Element of R, a being Element of A st it/.i = u*a;
  mode RightLinearCombination of A -> FinSequence of the carrier of R
                                                                 means
:: IDEAL_1:def 11
    for i being set st i in dom it
      ex u being Element of R, a being Element of A st it/.i = a*u;
end;


registration
 let R be non empty multLoopStr,
      A be non empty Subset of R;
 cluster non empty LinearCombination of A;
 existence proof consider u, v being Element of R;
   consider a being Element of A;
   reconsider p = <*u*a*v*> as FinSequence of the carrier of R;
   take p;
     now let i be set; assume i in dom p; then i in {1} by FINSEQ_1:4,55
;
   then A1: i = 1 by TARSKI:def 1;
    take u,v, a; thus p/.i = u*a*v by A1,FINSEQ_4:25;
   end; hence thesis by Def9;
 end;
 cluster non empty LeftLinearCombination of A;
 existence proof consider u being Element of R;
   consider a being Element of A;
   reconsider p = <*u*a*> as FinSequence of the carrier of R;
   take p;
     now let i be set; assume i in dom p; then i in {1} by FINSEQ_1:4,55
;
   then A2: i = 1 by TARSKI:def 1;
    take u, a; thus p/.i = u*a by A2,FINSEQ_4:25;
   end; hence thesis by Def10;
 end;
 cluster non empty RightLinearCombination of A;
 existence proof consider v being Element of R;
   consider a being Element of A;
   reconsider p = <*a*v*> as FinSequence of the carrier of R;
   take p;
     now let i be set; assume i in dom p; then i in {1} by FINSEQ_1:4,55
;
   then A3: i = 1 by TARSKI:def 1;
    take v, a; thus p/.i = a*v by A3,FINSEQ_4:25;
   end; hence thesis by Def11;
 end;
end;


definition
  let R be non empty multLoopStr,
      A,B be non empty Subset of R,
      F be LinearCombination of A,
      G be LinearCombination of B;
  redefine func F^G -> LinearCombination of (A \/ B);
end;


theorem :: IDEAL_1:23
  for R be associative (non empty multLoopStr),
      A be non empty Subset of R,
      a be Element of R, F be LinearCombination of A
  holds a*F is LinearCombination of A;

theorem :: IDEAL_1:24
  for R be associative (non empty multLoopStr),
      A be non empty Subset of R,
      a be Element of R, F be LinearCombination of A
  holds F*a is LinearCombination of A;

theorem :: IDEAL_1:25
for R being right_unital (non empty multLoopStr),
    A being non empty Subset of R,
    f being LeftLinearCombination of A
 holds f is LinearCombination of A;

definition
  let R be non empty multLoopStr,
      A,B be non empty Subset of R,
      F be LeftLinearCombination of A,
      G be LeftLinearCombination of B;
  redefine func F^G -> LeftLinearCombination of (A \/ B);
end;


theorem :: IDEAL_1:26
  for R be associative (non empty multLoopStr),
      A be non empty Subset of R,
      a be Element of R,
      F be LeftLinearCombination of A
  holds a*F is LeftLinearCombination of A;

theorem :: IDEAL_1:27
    for R be non empty multLoopStr,
      A be non empty Subset of R,
      a be Element of R,
      F be LeftLinearCombination of A
  holds F*a is LinearCombination of A;

theorem :: IDEAL_1:28
for R being left_unital (non empty multLoopStr),
    A being non empty Subset of R,
    f being RightLinearCombination of A
holds f is LinearCombination of A;

definition
  let R be non empty multLoopStr,
      A,B be non empty Subset of R,
      F be RightLinearCombination of A,
      G be RightLinearCombination of B;
  redefine func F^G -> RightLinearCombination of (A \/ B);
end;


theorem :: IDEAL_1:29
  for R be associative (non empty multLoopStr),
      A be non empty Subset of R,
      a be Element of R,
      F be RightLinearCombination of A
  holds F*a is RightLinearCombination of A;

theorem :: IDEAL_1:30
    for R be associative (non empty multLoopStr),
      A be non empty Subset of R,
      a be Element of R,
      F be RightLinearCombination of A
  holds a*F is LinearCombination of A;

theorem :: IDEAL_1:31
for R being commutative associative (non empty multLoopStr),
    A being non empty Subset of R,
    f being LinearCombination of A
holds f is LeftLinearCombination of A & f is RightLinearCombination of A;

theorem :: IDEAL_1:32
for S being non empty doubleLoopStr,
    F being non empty Subset of S,
    lc being non empty LinearCombination of F
  ex p being LinearCombination of F,
     e being Element of S
   st lc = p^<* e *> & <*e*> is LinearCombination of F;

theorem :: IDEAL_1:33
for S being non empty doubleLoopStr,
    F being non empty Subset of S,
    lc being non empty LeftLinearCombination of F
  ex p being LeftLinearCombination of F,
     e being Element of S
   st lc = p^<* e *> & <*e*> is LeftLinearCombination of F;

theorem :: IDEAL_1:34
for S being non empty doubleLoopStr,
    F being non empty Subset of S,
    lc being non empty RightLinearCombination of F
  ex p being RightLinearCombination of F,
     e being Element of S
   st lc = p^<* e *> & <*e*> is RightLinearCombination of F;

definition
  let R be non empty multLoopStr, A be non empty Subset of R,
      L be LinearCombination of A,
      E be FinSequence of
                      [:the carrier of R, the carrier of R, the carrier of R:];
 pred E represents L means
:: IDEAL_1:def 12

   len E = len L &
   for i being set st i in dom L
     holds L.i = ((E/.i)`1)*((E/.i)`2)*((E/.i)`3) & ((E/.i)`2) in A;
end;


theorem :: IDEAL_1:35
    for R being non empty multLoopStr,
      A being non empty Subset of R,
      L be LinearCombination of A
   ex E be FinSequence of
                      [:the carrier of R, the carrier of R, the carrier of R:]
    st E represents L;

theorem :: IDEAL_1:36
    for R, S being non empty multLoopStr,
      F being non empty Subset of R,
      lc being LinearCombination of F,
      G being non empty Subset of S,
      P being Function of the carrier of R, the carrier of S,
      E being FinSequence of
                      [:the carrier of R, the carrier of R, the carrier of R:]
    st P.:F c= G & E represents lc
    holds ex LC being LinearCombination of G st len lc = len LC &
          for i being set st i in dom LC
           holds LC.i = (P.(E/.i)`1)*(P.(E/.i)`2)*(P.(E/.i)`3);

definition
  let R be non empty multLoopStr, A be non empty Subset of R,
      L be LeftLinearCombination of A,
      E be FinSequence of [:the carrier of R, the carrier of R:];
 pred E represents L means
:: IDEAL_1:def 13
   len E = len L &
   for i being set st i in dom L
     holds L.i = ((E/.i)`1)*((E/.i)`2) & ((E/.i)`2) in A;
end;


theorem :: IDEAL_1:37
    for R being non empty multLoopStr,
      A being non empty Subset of R,
      L be LeftLinearCombination of A
   ex E be FinSequence of [:the carrier of R, the carrier of R:]
    st E represents L;

theorem :: IDEAL_1:38
    for R, S being non empty multLoopStr,
      F being non empty Subset of R,
      lc being LeftLinearCombination of F,
      G being non empty Subset of S,
      P being Function of the carrier of R, the carrier of S,
      E being FinSequence of [:the carrier of R, the carrier of R:]
    st P.:F c= G & E represents lc
    holds ex LC being LeftLinearCombination of G st len lc = len LC &
          for i being set st i in dom LC
           holds LC.i = (P.(E/.i)`1)*(P.(E/.i)`2);

definition
  let R be non empty multLoopStr, A be non empty Subset of R,
      L be RightLinearCombination of A,
      E be FinSequence of [:the carrier of R, the carrier of R:];
 pred E represents L means
:: IDEAL_1:def 14
   len E = len L &
   for i being set st i in dom L
     holds L.i = ((E/.i)`1)*((E/.i)`2) & ((E/.i)`1) in A;
end;


theorem :: IDEAL_1:39
    for R being non empty multLoopStr,
      A being non empty Subset of R,
      L be RightLinearCombination of A
   ex E be FinSequence of [:the carrier of R, the carrier of R:]
    st E represents L;

theorem :: IDEAL_1:40
    for R, S being non empty multLoopStr,
      F being non empty Subset of R,
      lc being RightLinearCombination of F,
      G being non empty Subset of S,
      P being Function of the carrier of R, the carrier of S,
      E being FinSequence of [:the carrier of R, the carrier of R:]
    st P.:F c= G & E represents lc
    holds ex LC being RightLinearCombination of G st len lc = len LC &
          for i being set st i in dom LC
           holds LC.i = (P.(E/.i)`1)*(P.(E/.i)`2);

theorem :: IDEAL_1:41
  for R being non empty multLoopStr,
    A being non empty Subset of R,
    l being LinearCombination of A, n being Nat
 holds l|Seg n is LinearCombination of A;

theorem :: IDEAL_1:42
  for R being non empty multLoopStr,
    A being non empty Subset of R,
    l being LeftLinearCombination of A, n being Nat
 holds l|Seg n is LeftLinearCombination of A;

theorem :: IDEAL_1:43
  for R being non empty multLoopStr,
    A being non empty Subset of R,
    l being RightLinearCombination of A, n being Nat
 holds l|Seg n is RightLinearCombination of A;

begin :: Generated ideals

definition
  let L be non empty doubleLoopStr,
      F be Subset of L;
  assume  F is non empty;
  func F-Ideal -> Ideal of L means
:: IDEAL_1:def 15
     F c= it & for I being Ideal of L st F c= I holds it c= I;
  func F-LeftIdeal -> LeftIdeal of L means
:: IDEAL_1:def 16

     F c= it & for I being LeftIdeal of L st F c= I holds it c= I;
  func F-RightIdeal -> RightIdeal of L means
:: IDEAL_1:def 17

     F c= it & for I being RightIdeal of L st F c= I holds it c= I;
end;


theorem :: IDEAL_1:44
 for L being non empty doubleLoopStr, I being Ideal of L holds I-Ideal = I;

theorem :: IDEAL_1:45
 for L being non empty doubleLoopStr, I being LeftIdeal of L
  holds I-LeftIdeal = I;

theorem :: IDEAL_1:46
 for L being non empty doubleLoopStr, I being RightIdeal of L
  holds I-RightIdeal = I;

definition
let L be non empty doubleLoopStr,
    I be Ideal of L;
mode Basis of I -> non empty Subset of L means
:: IDEAL_1:def 18
    it-Ideal = I;
end;


theorem :: IDEAL_1:47
for L being add-associative right_zeroed right_complementable
             distributive (non empty doubleLoopStr)
   holds {0.L}-Ideal = {0.L};

theorem :: IDEAL_1:48
   for L being left_zeroed right_zeroed add-cancelable
             distributive (non empty doubleLoopStr)
   holds {0.L}-Ideal = {0.L};

theorem :: IDEAL_1:49
   for L being left_zeroed right_zeroed add-right-cancelable
             right-distributive (non empty doubleLoopStr)
   holds {0.L}-LeftIdeal = {0.L};

theorem :: IDEAL_1:50
   for L being right_zeroed add-left-cancelable
             left-distributive (non empty doubleLoopStr)
   holds {0.L}-RightIdeal = {0.L};

theorem :: IDEAL_1:51
   for L being well-unital (non empty doubleLoopStr)
  holds {1_ L}-Ideal = the carrier of L;

theorem :: IDEAL_1:52
   for L being right_unital (non empty doubleLoopStr)
  holds {1_ L}-LeftIdeal = the carrier of L;

theorem :: IDEAL_1:53
   for L being left_unital (non empty doubleLoopStr)
  holds {1_ L}-RightIdeal = the carrier of L;

theorem :: IDEAL_1:54
   for L being non empty doubleLoopStr holds ([#] L)-Ideal = the carrier of L;

theorem :: IDEAL_1:55
   for L being non empty doubleLoopStr holds ([#] L)-LeftIdeal = the carrier of
L;

theorem :: IDEAL_1:56
   for L being non empty doubleLoopStr holds ([#]
 L)-RightIdeal = the carrier of L;

theorem :: IDEAL_1:57
  for L being non empty doubleLoopStr,
      A, B being non empty Subset of L
  st A c= B holds A-Ideal c= B-Ideal;

theorem :: IDEAL_1:58
  for L being non empty doubleLoopStr,
      A, B being non empty Subset of L
  st A c= B holds A-LeftIdeal c= B-LeftIdeal;

theorem :: IDEAL_1:59
  for L being non empty doubleLoopStr,
      A, B being non empty Subset of L
  st A c= B holds A-RightIdeal c= B-RightIdeal;

theorem :: IDEAL_1:60
  for L being add-associative left_zeroed right_zeroed add-cancelable
              associative distributive well-unital (non empty doubleLoopStr),
      F being non empty Subset of L, x being set
  holds x in F-Ideal iff ex f being LinearCombination of F st x = Sum f;

theorem :: IDEAL_1:61
for L being add-associative left_zeroed right_zeroed add-cancelable
            associative distributive well-unital (non empty doubleLoopStr),
    F being non empty Subset of L, x being set
  holds x in F-LeftIdeal iff ex f being LeftLinearCombination of F st x = Sum f
;

theorem :: IDEAL_1:62
  for L being add-associative left_zeroed right_zeroed add-cancelable
              associative distributive well-unital (non empty doubleLoopStr),
      F being non empty Subset of L, x being set
  holds x in F-RightIdeal iff ex f being RightLinearCombination of F st x = Sum
 f;

theorem :: IDEAL_1:63
for R being add-associative left_zeroed right_zeroed add-cancelable well-unital
            associative commutative distributive (non empty doubleLoopStr),
    F being non empty Subset of R
holds F-Ideal = F-LeftIdeal & F-Ideal = F-RightIdeal;

theorem :: IDEAL_1:64
for R being add-associative left_zeroed right_zeroed add-cancelable well-unital
            associative commutative distributive (non empty doubleLoopStr),
    a being Element of R
holds {a}-Ideal = {a*r where r is Element of R : not contradiction};

theorem :: IDEAL_1:65
for R being Abelian left_zeroed right_zeroed
            add-cancelable well-unital add-associative
            associative commutative distributive (non empty doubleLoopStr),
    a,b being Element of R
holds {a,b}-Ideal = {a*r + b*s where r,s is Element of R : not contradiction};

theorem :: IDEAL_1:66
for R being non empty doubleLoopStr, a being Element of R
 holds a in {a}-Ideal;

theorem :: IDEAL_1:67
  for R being Abelian left_zeroed right_zeroed right_complementable
            add-associative associative commutative
            distributive well-unital (non empty doubleLoopStr),
    A being non empty Subset of R, a being Element of R
holds a in A-Ideal implies {a}-Ideal c= A-Ideal;

theorem :: IDEAL_1:68
  for R being non empty doubleLoopStr, a,b being Element of R
 holds a in {a,b}-Ideal & b in {a,b}-Ideal;

theorem :: IDEAL_1:69
  for R being non empty doubleLoopStr, a,b being Element of R
 holds {a}-Ideal c= {a,b}-Ideal & {b}-Ideal c= {a,b}-Ideal;

begin :: Some Operations on Ideals

definition
let R be non empty HGrStr, I be Subset of R, a be Element of R;
func a*I -> Subset of R equals
:: IDEAL_1:def 19
  {a*i where i is Element of R : i in I};
end;


registration
let R be non empty multLoopStr, I be non empty Subset of R, a be Element of R;
cluster a*I -> non empty;
coherence proof
 consider j being Element of I; a*j in {a*i where i is Element of R : i in I}
;
 hence thesis by Def19;
 end;
end;


registration
let R be distributive (non empty doubleLoopStr),
    I be add-closed Subset of R, a be Element of R;
cluster a*I -> add-closed;
coherence proof set M = {a*i where i is Element of R : i in I};
 A1: M = a*I by Def19;
   for x,y being Element of R st x in M & y in M holds x+y in
 M proof
     let x,y be Element of R; assume A2: x in M & y in M;
     then consider i being Element of R such that A3: x = a*i & i in I;
     consider j being Element of R such that A4: y = a*j & j in I by A2;
     reconsider k = i + j as Element of R;
     A5: k in I by A3,A4,Def1;
       x + y = a*k by A3,A4,VECTSP_1:def 18;
     hence thesis by A5;
     end;
 hence thesis by A1,Def1;
 end;
end;


registration
let R be associative (non empty doubleLoopStr),
    I be right-ideal Subset of R, a be Element of R;
cluster a*I -> right-ideal;
coherence proof set M = {a*i where i is Element of R : i in I};
 A1: M = a*I by Def19;
   for y,x being Element of R st x in M holds x*y in M proof
     let y,x be Element of R; assume x in M;
     then consider i being Element of R such that A2: x = a*i & i in I;
     A3: x*y = a*(i*y) by A2,VECTSP_1:def 16; i*y in
 I by A2,Def3;
     hence thesis by A3;
     end;
 hence thesis by A1,Def3;
 end;
end;


theorem :: IDEAL_1:70
for R being right_zeroed add-left-cancelable left-distributive
            (non empty doubleLoopStr), I being non empty Subset of R
 holds 0.R*I = {0.R};

theorem :: IDEAL_1:71
  for R being left_unital (non empty doubleLoopStr), I being Subset of R
 holds 1_ R*I = I;

definition
let R be non empty LoopStr, I,J be Subset of R;
func I + J -> Subset of R equals
:: IDEAL_1:def 20
 {a + b where a,b is Element of R : a in I & b in J};
end;


registration
let R be non empty LoopStr, I,J be non empty Subset of R;
cluster I + J -> non empty;
coherence proof
   {x + y where x,y is Element of R : x in I & y in J} is non empty
 proof
     consider x being Element of I;
     consider y being Element of J;
       x+y in {a + b where a,b is Element of R : a in I & b in J};
     hence thesis;
     end;
 hence thesis by Def20;
 end;
end;


definition
let R be Abelian (non empty LoopStr), I,J be Subset of R;
redefine func I + J;
commutativity;
end;


registration
let R be Abelian add-associative (non empty LoopStr),
    I,J be add-closed Subset of R;
cluster I + J -> add-closed;
coherence proof set M = {a + b where a,b is Element of R : a in I & b in J};
 A1: M = I + J by Def20;
   for x,y being Element of R st x in M & y in M holds x+y in
 M proof
     let x,y be Element of R;
     assume A2: x in M & y in M; then consider a',b' being Element of R such
that
     A3: x = a' + b' & a' in I & b' in J;
     consider c,d being Element of R such that
     A4: y = c + d & c in I & d in J by A2;
     A5: a' + c in I & b' + d in J by A3,A4,Def1;
       (a' + c) + (b' + d) = ((a' + c) + b') + d by RLVECT_1:def 6
      .= (c + x) + d by A3,RLVECT_1:def 6
      .= x + y by A4,RLVECT_1:def 6;
     hence thesis by A5;
     end;
 hence thesis by A1,Def1;
 end;
end;


registration
let R be left-distributive (non empty doubleLoopStr),
    I,J be right-ideal Subset of R;
cluster I + J -> right-ideal;
coherence proof set M = {a + b where a,b is Element of R : a in I & b in J};
 A1: M = I + J by Def20;
   for y,x being Element of R st x in M holds x*y in M proof
     let y,x be Element of R; assume x in M;
     then consider a',b' being Element of R such that
     A2: x = a' + b' & a' in I & b' in J;
     A3: a'*y in I & b'*y in J by A2,Def3;
       (a'*y) + (b'*y) = x*y by A2,VECTSP_1:def 12;
     hence thesis by A3;
     end;
 hence thesis by A1,Def3;
 end;
end;


registration
let R be right-distributive (non empty doubleLoopStr),
    I,J be left-ideal Subset of R;
cluster I + J -> left-ideal;
coherence proof set M = {a + b where a,b is Element of R : a in I & b in J};
 A1: M = I + J by Def20;
   for y,x being Element of R st x in M holds y*x in M proof
     let y,x be Element of R; assume x in M;
     then consider a',b' being Element of R such that
     A2: x = a' + b' & a' in I & b' in J;
     A3: y*a' in I & y*b' in J by A2,Def2;
       (y*a') + (y*b') = y*x by A2,VECTSP_1:def 11;
     hence thesis by A3;
     end;
 hence thesis by A1,Def2;
 end;
end;


theorem :: IDEAL_1:72
  for R being add-associative (non empty LoopStr), I,J,K being Subset of R
 holds I + (J + K) = (I + J) + K;

theorem :: IDEAL_1:73
for R being left_zeroed right_zeroed add-right-cancelable
            right-distributive (non empty doubleLoopStr),
    I,J being right-ideal (non empty Subset of R)
 holds I c= I + J;

theorem :: IDEAL_1:74
for R being left_zeroed add-right-cancelable
            right-distributive (non empty doubleLoopStr),
    I,J being right-ideal (non empty Subset of R)
 holds J c= I + J;

theorem :: IDEAL_1:75
  for R being non empty LoopStr, I,J being Subset of R,
    K being add-closed Subset of R
st I c= K & J c= K holds I + J c= K;

theorem :: IDEAL_1:76
  for R being Abelian left_zeroed right_zeroed add-cancelable
            well-unital add-associative associative
            commutative distributive (non empty doubleLoopStr),
    a,b being Element of R
 holds {a,b}-Ideal = {a}-Ideal + {b}-Ideal;

definition
let R be non empty 1-sorted, I,J be Subset of R;
func I /\ J -> Subset of R equals
:: IDEAL_1:def 21
  { x where x is Element of R : x in I & x in J };
end;


registration
let R be right_zeroed add-left-cancelable
         left-distributive (non empty doubleLoopStr),
    I,J be left-ideal (non empty Subset of R);
cluster I /\ J -> non empty;
coherence proof 0.R in I & 0.R in J by Th2;
 then 0.R in { x where x is Element of R : x in I & x in J };
 hence thesis by Def21;
 end;
end;


registration
let R be non empty LoopStr, I,J be add-closed Subset of R;
cluster I /\ J -> add-closed;
coherence proof set M = { x where x is Element of R : x in I & x in J };
 A1: M = I /\ J by Def21;
 then reconsider M as Subset of R;
   for x,y being Element of R st x in M & y in M holds x+y in
 M proof
     let x,y be Element of R; assume A2: x in M & y in M;
     then consider a being Element of R such that A3: x = a & a in I & a in J;
     consider c being Element of R such that A4: c = y & c in I & c in J by A2;
        a + c in I & a + c in J by A3,A4,Def1;
     hence thesis by A3,A4;
     end;
 hence thesis by A1,Def1;
 end;
end;


registration
let R be non empty multLoopStr, I,J be left-ideal Subset of R;
cluster I /\ J -> left-ideal;
coherence proof set M = { x where x is Element of R : x in I & x in J };
 A1: M = I /\ J by Def21;
 then reconsider M as Subset of R;
   for y,x being Element of R st x in M holds y*x in M proof
     let y,x be Element of R; assume x in M;
     then consider a being Element of R such that
     A2: x = a & a in I & a in J; y*a in I & y*a in J by A2,Def2;
     hence thesis by A2;
     end;
 hence thesis by A1,Def2;
 end;
end;


registration
let R be non empty multLoopStr, I,J be right-ideal Subset of R;
cluster I /\ J -> right-ideal;
coherence proof set M = { x where x is Element of R : x in I & x in J };
 A1: M = I /\ J by Def21; then reconsider M as Subset of R;
   for y,x being Element of R st x in M holds x*y in M proof
     let y,x be Element of R; assume x in M;
     then consider a being Element of R such that
     A2: x = a & a in I & a in J; a*y in I & a*y in J by A2,Def3;
     hence thesis by A2;
     end;
 hence thesis by A1,Def3;
 end;
end;


theorem :: IDEAL_1:77
for R being non empty 1-sorted, I,J being Subset of R
 holds I /\ J c= I & I /\ J c= J;

theorem :: IDEAL_1:78
  for R being non empty 1-sorted, I,J,K being Subset of R
 holds I /\ (J /\ K) = (I /\ J) /\ K;

theorem :: IDEAL_1:79
  for R being non empty 1-sorted, I,J,K being Subset of R
 st K c= I & K c= J holds K c= I /\ J;

theorem :: IDEAL_1:80
  for R being Abelian left_zeroed right_zeroed right_complementable left_unital
            add-associative left-distributive (non empty doubleLoopStr),
    I being add-closed left-ideal (non empty Subset of R),
    J being Subset of R, K being non empty Subset of R
st J c= I holds I /\ (J + K) = J + (I /\ K);

definition
let R be non empty doubleLoopStr, I,J be Subset of R;
func I *' J -> Subset of R equals
:: IDEAL_1:def 22
  { Sum s where s is FinSequence of the carrier of R :
       for i being Nat st 1 <= i & i <= len s
       ex a,b being Element of R st s.i = a*b & a in I & b in J};
end;


registration
let R be non empty doubleLoopStr, I,J be Subset of R;
cluster I *' J -> non empty;
coherence proof set M = {Sum s where s is FinSequence of the carrier of R :
          for i being Nat st 1 <= i & i <= len s
          ex a,b being Element of R st s.i = a*b & a in I & b in J};
   M is non empty proof set p = <*>(the carrier of R);
     for i being Nat st 1 <= i & i <= len p
   ex a,b being Element of R st p.i = a*b & a in I & b in J proof
     let i be Nat; assume A1: 1 <= i & i <= len p; len p = 0 by FINSEQ_1:32;
     hence thesis by A1,AXIOMS:22;
     end; then Sum p in M;
   hence thesis;
   end;
 hence thesis by Def22;
 end;
end;


definition
let R be commutative (non empty doubleLoopStr), I,J be Subset of R;
redefine func I *' J;
commutativity;
end;


registration
let R be right_zeroed add-associative (non empty doubleLoopStr),
    I,J be Subset of R;
cluster I *' J -> add-closed;
coherence proof set M = {Sum s where s is FinSequence of the carrier of R :
          for i being Nat st 1 <= i & i <= len s
          ex a,b being Element of R st s.i = a*b & a in I & b in J};
 A1: M = I *' J by Def22;
 then reconsider M as non empty Subset of R;
  for x,y being Element of R st x in M & y in M holds x+y in
 M proof
     let x,y be Element of R; assume A2: x in M & y in M;
     then consider s being FinSequence of the carrier of R such that
     A3: x = Sum s & for i being Nat st 1 <= i & i <= len s
        ex a,b being Element of R st s.i = a*b & a in I & b in J;
     consider t being FinSequence of the carrier of R such that
     A4: y = Sum t & for i being Nat st 1 <= i & i <= len t
        ex a,b being Element of R st t.i = a*b & a in I & b in J by A2;
     set q = s^t;
     A5: Sum q = x + y by A3,A4,RLVECT_1:58;
        now let i be Nat; assume A6: 1 <= i & i <= len q;
         thus ex a,r being Element of R st q.i = a*r & a in I & r in J proof
           per cases;
           suppose A7: i <= len s;
             then i in Seg(len s) by A6,FINSEQ_1:3;
             then i in dom s by FINSEQ_1:def 3;
             then q.i = s.i by FINSEQ_1:def 7;
             hence thesis by A3,A6,A7;
           end;
           suppose A8: len s < i;
             then reconsider j = i - len s as Nat by INT_1:18;
               len s - len s < j by A8,REAL_1:54
; then 0 < j by XCMPLX_1:14;
             then A9: 1 <= j by RLVECT_1:99;
               i <= len s + len t by A6,FINSEQ_1:35;
             then j <= (len s + len t) - len s by REAL_1:49;
             then j <= (len s + len t) + -len s by XCMPLX_0:def 8;
             then j <= len t + (len s + -len s) by XCMPLX_1:1;
             then j <= len t + (len s - len s) by XCMPLX_0:def 8;
             then A10: j <= len t + 0 by XCMPLX_1:14;
               t.j = q.i by A6,A8,FINSEQ_1:37;
             hence thesis by A4,A9,A10;
           end;
           end;
         end;
     hence thesis by A5;
     end;
 hence thesis by A1,Def1;
 end;
end;


registration
let R be right_zeroed add-left-cancelable associative
         left-distributive (non empty doubleLoopStr),
    I,J be right-ideal Subset of R;
cluster I *' J -> right-ideal;
coherence proof set M = {Sum s where s is FinSequence of the carrier of R :
          for i being Nat st 1 <= i & i <= len s
          ex a,b being Element of R st s.i = a*b & a in I & b in J};
 A1: M = I *' J by Def22; then reconsider M as non empty Subset of R;
   for y,x being Element of R st x in M holds x*y in M proof
     let y,x be Element of R; assume x in M;
     then consider s being FinSequence of the carrier of R such that
     A2: x = Sum s & for i being Nat st 1 <= i & i <= len s
        ex a,b being Element of R st s.i = a*b & a in I & b in J;
     set q = s*y;
     A3: Sum q = Sum s*y by BINOM:5;
     A4: Seg(len q) = dom q by FINSEQ_1:def 3 .= dom s by POLYNOM1:def 3
               .= Seg(len s) by FINSEQ_1:def 3;
     then A5: len q = len s by FINSEQ_1:8;
        now let i be Nat; assume A6: 1 <= i & i <= len q;
         then consider c,r' being Element of R such that
         A7: s.i = c*r' & c in I & r' in J by A2,A5;
           i in Seg(len s) & i in Seg(len q) by A4,A6,FINSEQ_1:3;
         then A8: i in dom s & i in dom q by FINSEQ_1:def 3;
         then A9: s/.i = c*r' by A7,FINSEQ_4:def 4;
         A10: q.i = q/.i by A8,FINSEQ_4:def 4 .= (c*r')*y by A8,A9,POLYNOM1:def
3 .= c*(r'*y) by VECTSP_1:def 16;
         thus ex b,r being Element of R st q.i = b*r & b in I & r in J proof
            take c,r'*y;
            thus thesis by A7,A10,Def3;
            end;
          end;
     hence thesis by A2,A3;
     end;
 hence thesis by A1,Def3;
 end;
end;


registration
let R be left_zeroed add-right-cancelable associative
         right-distributive (non empty doubleLoopStr),
    I,J be left-ideal Subset of R;
cluster I *' J -> left-ideal;
coherence proof set M = {Sum s where s is FinSequence of the carrier of R :
          for i being Nat st 1 <= i & i <= len s
          ex a,b being Element of R st s.i = a*b & a in I & b in J};
 A1: M = I *' J by Def22;
 then reconsider M as non empty Subset of R;
   for y,x being Element of R st x in M holds y*x in M proof
     let y,x be Element of R; assume x in M;
     then consider s being FinSequence of the carrier of R such that
     A2: x = Sum s & for i being Nat st 1 <= i & i <= len s
        ex a,b being Element of R st s.i = a*b & a in I & b in J;
     set q = y*s;
     A3: Sum q = y*Sum s by BINOM:4;
     A4: Seg(len q) = dom q by FINSEQ_1:def 3 .= dom s by POLYNOM1:def 2
               .= Seg(len s) by FINSEQ_1:def 3;
     then A5: len q = len s by FINSEQ_1:8;
        now let i be Nat; assume A6: 1 <= i & i <= len q;
         then consider c,r' being Element of R such that
         A7: s.i = c*r' & c in I & r' in J by A2,A5;
           i in Seg(len s) & i in Seg(len q) by A4,A6,FINSEQ_1:3;
         then A8: i in dom s & i in dom q by FINSEQ_1:def 3;
         then A9: s/.i = c*r' by A7,FINSEQ_4:def 4;
         A10: q.i = q/.i by A8,FINSEQ_4:def 4 .= y*(c*r') by A8,A9,POLYNOM1:def
2 .= (y*c)*r' by VECTSP_1:def 16;
         thus ex b,r being Element of R st q.i = b*r & b in I & r in J proof
            take y*c,r';
            thus thesis by A7,A10,Def2;
            end;
          end;
     hence thesis by A2,A3;
     end;
 hence thesis by A1,Def2;
 end;
end;


theorem :: IDEAL_1:81
  for R being left_zeroed right_zeroed add-left-cancelable
            left-distributive (non empty doubleLoopStr),
    I being non empty Subset of R
 holds {0.R} *' I = {0.R};

theorem :: IDEAL_1:82
for R being left_zeroed right_zeroed add-cancelable
            distributive (non empty doubleLoopStr),
    I being add-closed right-ideal (non empty Subset of R),
    J being add-closed left-ideal (non empty Subset of R)
holds I *' J c= I /\ J;

theorem :: IDEAL_1:83
for R being Abelian left_zeroed right_zeroed add-cancelable add-associative
            associative distributive (non empty doubleLoopStr),
    I,J,K being right-ideal (non empty Subset of R)
holds I *' (J + K) = (I *' J) + (I *' K);

theorem :: IDEAL_1:84
for R being Abelian left_zeroed right_zeroed add-cancelable add-associative
            commutative associative distributive (non empty doubleLoopStr),
    I,J being right-ideal (non empty Subset of R)
holds (I + J) *' (I /\ J) c= I *' J;

theorem :: IDEAL_1:85
  for R being right_zeroed add-left-cancelable
            left-distributive (non empty doubleLoopStr),
    I,J being add-closed left-ideal (non empty Subset of R)
holds (I + J) *' (I /\ J) c= I /\ J;

definition
let R be non empty LoopStr, I,J be Subset of R;
pred I,J are_co-prime means
:: IDEAL_1:def 23
 I + J = the carrier of R;
end;


theorem :: IDEAL_1:86
for R being left_zeroed left_unital (non empty doubleLoopStr),
    I,J being non empty Subset of R
 st I,J are_co-prime holds I /\ J c= (I + J) *' (I /\ J);

theorem :: IDEAL_1:87
  for R being Abelian left_zeroed right_zeroed add-cancelable
            add-associative left_unital commutative associative
            distributive (non empty doubleLoopStr),
    I being add-closed left-ideal right-ideal (non empty Subset of R),
    J being add-closed left-ideal (non empty Subset of R)
st I,J are_co-prime holds I *' J = I /\ J;

definition
let R be non empty HGrStr, I,J be Subset of R;
func I % J -> Subset of R equals
:: IDEAL_1:def 24
  {a where a is Element of R: a*J c= I};
end;


registration
let R be right_zeroed add-left-cancelable left-distributive
         (non empty doubleLoopStr),
    I,J be left-ideal (non empty Subset of R);
cluster I % J -> non empty;
coherence proof set M = {a where a is Element of R: a*J c= I};
   M is non empty Subset of R proof
     A1: 0.R*J = {0.R} by Th70; 0.R in I & 0.R in J by Th2;
     then for u being set holds u in {0.R} implies u in I by TARSKI:def 1;
     then {0.R} c= I by TARSKI:def 3; then A2: 0.R in M by A1;
       for x being set holds x in M implies x in the carrier of R proof
       let x be set; assume x in M;
       then consider a being Element of R such that A3: x = a & a*J c= I;
       thus thesis by A3;
       end;
     hence thesis by A2,TARSKI:def 3;
     end;
 hence thesis by Def24;
 end;
end;


registration
let R be right_zeroed add-left-cancelable left-distributive
         (non empty doubleLoopStr),
    I,J be add-closed left-ideal (non empty Subset of R);
cluster I % J -> add-closed;
coherence proof set M = {a where a is Element of R: a*J c= I};
 A1: M = I % J by Def24;
 then reconsider M as non empty Subset of R;
   for x,y being Element of R st x in M & y in M holds x+y in
 M proof
     let x,y be Element of R;
     assume A2: x in M & y in M;
     then consider a being Element of R such that A3: x = a & a*J c= I;
     consider b being Element of R such that A4: y = b & b*J c= I by A2;
       now let u be set; assume u in (a+b)*J;
       then u in {(a+b)*i where i is Element of R : i in J} by Def19;
       then consider c being Element of R such that
       A5: u = (a + b)*c & c in J;
       A6: u = a*c + b*c by A5,VECTSP_1:def 12;
         a*c in {a*i where i is Element of R : i in J} by A5;
       then A7: a*c in a*J by Def19;
         b*c in {b*i where i is Element of R : i in J} by A5;
       then b*c in b*J by Def19;
       hence u in I by A3,A4,A6,A7,Def1;
       end;
     then (a+b)*J c= I by TARSKI:def 3;
     hence thesis by A3,A4;
     end;
 hence thesis by A1,Def1;
 end;
end;


registration
let R be right_zeroed add-left-cancelable left-distributive
         associative commutative (non empty doubleLoopStr),
    I,J be left-ideal (non empty Subset of R);
cluster I % J -> left-ideal;
coherence proof set M = {a where a is Element of R: a*J c= I};
 A1: M = I % J by Def24; then reconsider M as non empty Subset of R;
   for y,x being Element of R st x in M holds y*x in M proof
     let y,x be Element of R;
     assume x in M;
     then consider a being Element of R such that A2: x = a & a*J c= I;
       now let u be set; assume u in (y*a)*J;
       then u in {(y*a)*i where i is Element of R : i in J} by Def19;
       then consider c being Element of R such that
       A3: u = (y*a)*c & c in J;
       A4: u = a*(y*c) by A3,VECTSP_1:def 16;
         y*c in J by A3,Def2
; then a*(y*c) in {a*i where i is Element of R : i in J};
       then u in a*J by A4,Def19;
       hence u in I by A2;
       end; then (y*a)*J c= I by TARSKI:def 3;
     hence thesis by A2;
     end;
 hence thesis by A1,Def2;
 end;
cluster I % J -> right-ideal;
coherence proof set M = {a where a is Element of R: a*J c= I};
 A5: M = I % J by Def24;
 then reconsider M as non empty Subset of R;
   for y,x being Element of R st x in M holds x*y in M proof
     let y,x be Element of R;
     assume x in M;
     then consider a being Element of R such that A6: x = a & a*J c= I;
       now let u be set; assume u in (a*y)*J;
       then u in {(a*y)*i where i is Element of R : i in J} by Def19;
       then consider c being Element of R such that
       A7: u = (a*y)*c & c in J;
       A8: u = y*(a*c) by A7,VECTSP_1:def 16;
         a*c in {a*i where i is Element of R : i in J} by A7; then a*c in a*J
by Def19;
       hence u in I by A6,A8,Def2;
       end;
     then (a*y)*J c= I by TARSKI:def 3;
     hence thesis by A6;
     end;
 hence thesis by A5,Def3;
 end;
end;


theorem :: IDEAL_1:88
  for R being (non empty multLoopStr),
    I being right-ideal (non empty Subset of R),
    J being Subset of R
 holds I c= I % J;

theorem :: IDEAL_1:89
  for R being right_zeroed add-left-cancelable
            left-distributive (non empty doubleLoopStr),
    I being add-closed left-ideal (non empty Subset of R),
    J being Subset of R
 holds (I % J) *' J c= I;

theorem :: IDEAL_1:90
for R being left_zeroed add-right-cancelable
            right-distributive (non empty doubleLoopStr),
    I being add-closed right-ideal (non empty Subset of R),
    J being Subset of R
 holds (I % J) *' J c= I;

theorem :: IDEAL_1:91
  for R being left_zeroed add-right-cancelable right-distributive
            commutative associative (non empty doubleLoopStr),
    I being add-closed right-ideal (non empty Subset of R),
    J,K being Subset of R
holds (I % J) % K = I % (J *' K);

theorem :: IDEAL_1:92
  for R being non empty multLoopStr, I,J,K being Subset of R
holds (J /\ K) % I = (J % I) /\ (K % I);

theorem :: IDEAL_1:93
  for R being left_zeroed right_zeroed add-right-cancelable
            right-distributive (non empty doubleLoopStr),
    I being add-closed Subset of R,
    J,K being right-ideal (non empty Subset of R)
holds I % (J + K) = (I % J) /\ (I % K);

definition
let R be unital (non empty doubleLoopStr),
    I be Subset of R;
func sqrt I -> Subset of R equals
:: IDEAL_1:def 25
  {a where a is Element of R: ex n being Nat st a|^n in I};
end;


registration
let R be unital (non empty doubleLoopStr), I be non empty Subset of R;
cluster sqrt I -> non empty;
coherence proof set M ={a where a is Element of R: ex n being Nat st a|^n in
 I};
   M is non empty proof consider a being Element of I; a|^1 = a by BINOM:8;
     then a in M;
     hence thesis;
     end;
 hence thesis by Def25;
 end;
end;


registration
let R be Abelian add-associative left_zeroed right_zeroed
         commutative associative add-cancelable distributive
         unital (non empty doubleLoopStr),
    I be add-closed right-ideal (non empty Subset of R);
cluster sqrt I -> add-closed;
coherence proof set M ={a where a is Element of R: ex n being Nat st a|^n in
 I};
 A1: M = sqrt I by Def25;
 then reconsider M as non empty Subset of R;
   for x,y being Element of R st x in M & y in M holds x+y in
 M proof
     let x,y be Element of R;
     assume A2: x in M & y in M; then consider a being Element of R such
that
     A3: x = a & ex n being Nat st a|^n in I;
     consider n being Nat such that A4: a|^n in I by A3;
     consider b being Element of R such that
     A5: y = b & ex m being Nat st b|^m in I by A2;
     consider m being Nat such that A6: b|^m in I by A5;
     A7: (a+b)|^(n+m) = Sum((a,b) In_Power (n+m)) by BINOM:26;
     set p = ((a,b) In_Power (n+m));
     consider f being Function of NAT,the carrier of R such that
     A8: Sum p = f.(len p) & f.0 = 0.R &
        for j being Nat, v being Element of R
     st j < len p & v = p.(j + 1) holds f.(j + 1) = f.j + v by RLVECT_1:def 12;
     A9: 0 <= len p by NAT_1:18;
     A10: for i being Nat st 1 <= i & i <= len p holds p.i in I proof
        let i be Nat;
        assume A11: 1 <= i & i <= len p; then i in Seg(len p) by FINSEQ_1:3;
        then A12: i in dom p by FINSEQ_1:def 3;
        set r = i - 1; set l = (n+m) - r;
          1 - 1 <= i - 1 by A11,REAL_1:49;
        then reconsider r as Nat by INT_1:16;
          i <= (n+m) + 1 by A11,BINOM:def 10;
        then r <= ((n+m) + 1) - 1 by REAL_1:49;
        then r <= ((n+m) + 1) + -1 by XCMPLX_0:def 8;
        then r <= (n+m) + (1 + -1) by XCMPLX_1:1;
        then r - r <= (n+m) - r by REAL_1:49;
        then 0 <= l by XCMPLX_1:14;
        then reconsider l as Nat by INT_1:16;
        A13: p.i = p/.i by A12,FINSEQ_4:def 4
              .= ((n+m) choose r)*a|^l*b|^r by A12,BINOM:def 10;
        per cases;
        suppose n <= l;
          then consider k being Nat such that
          A14: l = n + k by NAT_1:28;
            a|^l = (a|^n)*(a|^k) by A14,BINOM:11;
          then a|^l in I by A4,Def3; then ((n+m) choose r)*a|^l in I by Th17;
          hence thesis by A13,Def3;
        end;
        suppose l < n; then ((n+m) + -r) < n by XCMPLX_0:def 8;
          then ((n+m) + -r) + r < n + r by REAL_1:53;
          then (n+m) + (-r + r) < n + r by XCMPLX_1:1;
          then (n+m) + (r - r) < n + r by XCMPLX_0:def 8;
          then (n+m) + 0 < n + r by XCMPLX_1:14;
          then -n + (n+m) < -n + (n + r) by REAL_1:53;
          then (-n + n) + m < -n + (n + r) by XCMPLX_1:1;
          then (-n + n) + m < (-n + n) + r by XCMPLX_1:1;
          then (-n + n) + m < (n - n) + r by XCMPLX_0:def 8;
          then (-n + n) + m < 0 + r by XCMPLX_1:14;
          then (n - n) + m < 0 + r by XCMPLX_0:def 8;
          then 0 + m < r by XCMPLX_1:14; then consider k being Nat such that
          A15: r = m + k by NAT_1:28;
            b|^r = (b|^m)*(b|^k) by A15,BINOM:11;
          then b|^r in I by A6,Def3;
          hence thesis by A13,Def3;
        end;
        end;
        defpred P[Nat] means f.$1 in I;
     A16: P[0] by A8,Th2;
     A17: now let j be Nat;
         assume A18: 0 <= j & j < len p;
         thus P[j] implies P[j+1] proof
           assume A19: f.j in I;
           A20: 1 <= j + 1 by NAT_1:29;
           A21: j + 1 <= len p by A18,NAT_1:38;
           then j + 1 in Seg(len p) by A20,FINSEQ_1:3;
           then j + 1 in dom p by FINSEQ_1:def 3;
           then A22: p/.(j+1) = p.(j+1) by FINSEQ_4:def 4;
           then A23: f.(j + 1) = f.j + p/.(j+1) by A8,A18;
             p/.(j+1) in I by A10,A20,A21,A22;
           hence thesis by A19,A23,Def1;
           end;
         end;
       for i being Nat st 0 <= i & i <= len p holds P[i]
       from POLYNOM2:sch 4(A16,A17);
     then (a+b)|^(n+m) in I by A7,A8,A9;
     hence thesis by A3,A5;
     end;
 hence thesis by A1,Def1;
 end;
end;


registration
let R be unital commutative associative (non empty doubleLoopStr),
    I be left-ideal (non empty Subset of R);
cluster sqrt I -> left-ideal;
coherence proof set M ={a where a is Element of R: ex n being Nat st a|^n in
 I};
 A1: M = sqrt I by Def25;
 then reconsider M as non empty Subset of R;
   for y,x being Element of R st x in M holds y*x in M proof
     let y',x' be Element of R;
     assume A2: x' in M;
     reconsider x = x',y = y' as Element of R;
     consider a being Element of R such that
     A3: x = a & ex n being Nat st a|^n in I by A2;
     consider n being Nat such that A4: a|^n in I by A3;
     A5: (y|^n)*(a|^n) in I by A4,Def2; (y*a)|^n = (y|^n)*(a|^n) by BINOM:10
;
     hence thesis by A3,A5;
     end;
 hence thesis by A1,Def2;
 end;
cluster sqrt I -> right-ideal;
coherence proof set M ={a where a is Element of R: ex n being Nat st a|^n in
 I};
 A6: M = sqrt I by Def25;
 then reconsider M as non empty Subset of R;
   for y,x being Element of R st x in M holds x*y in M proof
     let y',x' be Element of R;
     assume A7: x' in M;
     reconsider x = x',y = y' as Element of R;
     consider a being Element of R such that
     A8: x = a & ex n being Nat st a|^n in I by A7;
     consider n being Nat such that A9: a|^n in I by A8;
     A10: (y|^n)*(a|^n) in I by A9,Def2;
       (y*a)|^n = (y|^n)*(a|^n) by BINOM:10;
     hence thesis by A8,A10;
     end;
 hence thesis by A6,Def3;
 end;
end;


theorem :: IDEAL_1:94
  for R being unital associative (non empty doubleLoopStr),
    I being non empty Subset of R, a being Element of R
holds a in sqrt I iff ex n being Nat st a|^n in sqrt I;

theorem :: IDEAL_1:95
  for R being left_zeroed right_zeroed add-cancelable distributive
            unital associative (non empty doubleLoopStr),
    I being add-closed right-ideal (non empty Subset of R),
    J being add-closed left-ideal (non empty Subset of R)
holds sqrt (I *' J) = sqrt (I /\ J);

begin :: Noetherian ideals

definition
 let L be non empty doubleLoopStr, I be Ideal of L;
 attr I is finitely_generated means
:: IDEAL_1:def 26

  ex F being non empty finite Subset of L st I = F-Ideal;
end;


registration
 let L be non empty doubleLoopStr;
 cluster finitely_generated Ideal of L;
 existence proof consider x being set such that
 A1:    x in the carrier of L by XBOOLE_0:def 1;
    reconsider x as Element of L by A1;
    take {x}-Ideal; thus thesis by Def26;
 end;
end;


registration
let L be non empty doubleLoopStr,
    F be non empty finite Subset of L;
cluster F-Ideal -> finitely_generated;
coherence by Def26;
end;


definition
 let L be non empty doubleLoopStr;
 attr L is Noetherian means
:: IDEAL_1:def 27
  for I being Ideal of L holds I is finitely_generated;
end;


registration
  cluster Euclidian Abelian add-associative right_zeroed right_complementable
          well-unital distributive commutative associative non degenerated
          (non empty doubleLoopStr);
  existence proof take INT.Ring; thus thesis; end;
end;


definition
  let L be non empty doubleLoopStr;
  let I be Ideal of L;
  attr I is principal means
:: IDEAL_1:def 28
    ex e being Element of L st I = {e}-Ideal;
end;


definition
  let L be non empty doubleLoopStr;
  attr L is PID means
:: IDEAL_1:def 29

    for I being Ideal of L holds I is principal;
end;


theorem :: IDEAL_1:96
  for L being non empty doubleLoopStr,
      F being non empty Subset of L st F <> {0.L}
    ex x being Element of L st x <> 0.L & x in F;

theorem :: IDEAL_1:97
 for R being add-associative left_zeroed right_zeroed right_complementable
             distributive left_unital Euclidian (non empty doubleLoopStr)
 holds R is PID;

theorem :: IDEAL_1:98
 for L being non empty doubleLoopStr st L is PID holds L is Noetherian;

registration
 cluster INT.Ring -> Noetherian;
 coherence proof INT.Ring is PID by Th97;
   hence thesis by Th98;
 end;
end;


registration
  cluster Noetherian Abelian add-associative right_zeroed right_complementable
          well-unital distributive commutative associative non degenerated
          (non empty doubleLoopStr);
  existence proof take INT.Ring; thus thesis; end;
end;


theorem :: IDEAL_1:99 :: Lemma_4_5_i_ii:
   for R being Noetherian add-associative left_zeroed right_zeroed
add-cancelable
             associative distributive well-unital (non empty doubleLoopStr)
   for B being non empty Subset of R
     ex C being non empty finite Subset of R
       st C c= B & C-Ideal = B-Ideal;

theorem :: IDEAL_1:100 :: Lemma_4_5_ii_iii:
   for R being (non empty doubleLoopStr)
   st for B being non empty Subset of R
        ex C being non empty finite Subset of R
          st C c= B & C-Ideal = B-Ideal
   for a being sequence of R
     ex m being Nat st a.(m+1) in (rng (a|Segm(m+1)))-Ideal;

registration
 let X, Y be non empty set, f be Function of X, Y, A be non empty Subset of X;
 cluster f|A -> non empty;
 coherence proof dom f = X by FUNCT_2:def 1;
  then (dom f) /\ A is non empty by XBOOLE_1:28;
  then (dom f) meets A by XBOOLE_0:def 7;
  hence f|A is non empty by RELAT_1:95;
 end;
end;


theorem :: IDEAL_1:101 :: Lemma_4_5_iii_iv:
    for R being (non empty doubleLoopStr)
   st for a being sequence of R
       ex m being Nat st a.(m+1) in (rng (a|Segm(m+1)))-Ideal
   holds not ex F being Function of NAT, bool (the carrier of R)
        st (for i being Nat holds F.i is Ideal of R) &
           (for j,k being Nat st j < k holds F.j c< F.k);

theorem :: IDEAL_1:102 :: Lemma_4_5_iv_i:
    for R being (non empty doubleLoopStr)
   st not ex F being Function of NAT, bool (the carrier of R)
           st (for i being Nat holds F.i is Ideal of R) &
              (for j,k being Nat st j < k holds F.j c< F.k)
  holds R is Noetherian;
