:: Another { \bf times } Macro Instruction
::  by Piotr Rudnicki
::
:: Received June 4, 1998
:: Copyright (c) 1998 Association of Mizar Users

environ

 vocabularies NUMBERS, FSM_1, SCMFSA_2, SF_MASTR, AMI_1, SCMFSA7B, SUBSET_1,
      XBOOLE_0, CARD_1, UNIALG_2, SCMFSA6B, FUNCT_1, FUNCT_4, SCMFSA6A, TARSKI,
      RELAT_1, ARYTM_3, GRAPHSP, MSUALG_1, SFMASTR1, TURING_1, SCMFSA_9, AMI_3,
      CARD_3, XXREAL_0, ARYTM_1, SCMFSA9A, COMPLEX1, AOFA_I00, PRE_FF,
      SFMASTR2, NAT_1, SCMNORM;
 notations TARSKI, XBOOLE_0, SUBSET_1, NUMBERS, XCMPLX_0, INT_2, XXREAL_0,
      RELAT_1, FUNCT_1, FUNCT_2, FUNCT_4, PRE_FF, CARD_3, COMPOS_1, EXTPRO_1,
      AMI_1, SCMFSA_2, SCMFSA6A, SCMFSA6B, SF_MASTR, SCMFSA6C, SCMFSA7B,
      SCMFSA_9, SFMASTR1, SCMFSA9A, NAT_1;
 constructors XXREAL_0, INT_2, PRE_FF, SCMFSA6A, SCMFSA6B, SCMFSA6C, SCMFSA_9,
      SFMASTR1, SCMFSA9A, RELSET_1, PRE_POLY, PBOOLE, SCMFSA8A, SCMFSA7B,
      AMI_1;
 registrations SETFAM_1, FUNCT_1, ORDINAL1, RELSET_1, FINSET_1, NUMBERS,
      XXREAL_0, XREAL_0, NAT_1, INT_1, CARD_3, SCMFSA_2, SF_MASTR, SCMFSA6B,
      SCMFSA6C, SCMFSA7B, SCMFSA8A, SCMFSA_9, SFMASTR1, XBOOLE_0, RELAT_1,
      FUNCT_2, AMI_1, COMPOS_1, EXTPRO_1;
 requirements NUMERALS, REAL, SUBSET, BOOLE, ARITHM;


begin :: SCM+FSA preliminaries

reserve s, s1, s2 for State of SCM+FSA,
  a, b for Int-Location,
  d for
  read-write Int-Location,
  f for FinSeq-Location,
  I for Program of SCM+FSA,
  J for
  good Program of SCM+FSA,
  k, m for Element of NAT;

theorem :: SFMASTR2:1
  I is_closed_on Initialized s & I is_halting_on Initialized s & not
  b in UsedIntLoc I implies IExec(I, s).b = (Initialized s).b;

theorem :: SFMASTR2:2
  I is_closed_on Initialized s & I is_halting_on Initialized s & not f in
  UsedInt*Loc I implies IExec(I, s).f = (Initialized s).f;

theorem :: SFMASTR2:3
  ( I is_closed_on Initialized s & I is_halting_on Initialized s or I
is parahalting ) & (s.intloc 0 = 1 or a is read-write) & not a in UsedIntLoc I
  implies IExec(I, s).a = s.a;

theorem :: SFMASTR2:4
  s.intloc 0 = 1 implies (I is_closed_on s iff I is_closed_on
  Initialized s);

theorem :: SFMASTR2:5
  s.intloc 0 = 1 implies ( I is_closed_on s & I is_halting_on s iff
  I is_closed_on Initialized s & I is_halting_on Initialized s);

theorem :: SFMASTR2:6
  for Iloc being Subset of Int-Locations, Floc being Subset of
  FinSeq-Locations holds s1 | (Iloc \/ Floc) = s2 | (Iloc \/ Floc) iff (for x
  being Int-Location st x in Iloc holds s1.x = s2.x) & for x being
  FinSeq-Location st x in Floc holds s1.x = s2.x;

theorem :: SFMASTR2:7
  for Iloc being Subset of Int-Locations holds s1 | (Iloc \/
  FinSeq-Locations) = s2 | (Iloc \/ FinSeq-Locations) iff (for x being
  Int-Location st x in Iloc holds s1.x = s2.x) & for x being FinSeq-Location
  holds s1.x = s2.x;

begin :: Another times macro instruction

definition
  let a be Int-Location, I be Program of SCM+FSA;
  func times(a, I) -> Program of SCM+FSA equals
:: SFMASTR2:def 1
  (1-stRWNotIn ({a} \/
  UsedIntLoc I)) := a ';' while>0 ( 1-stRWNotIn ({a} \/ UsedIntLoc I), I ';'
  SubFrom(1-stRWNotIn ({a} \/ UsedIntLoc I), intloc 0) );
end;

notation
  let a be Int-Location, I be Program of SCM+FSA;
  synonym a times I for times(a, I);
end;

theorem :: SFMASTR2:8
  {b} \/ UsedIntLoc I c= UsedIntLoc times(b, I);

theorem :: SFMASTR2:9
  UsedInt*Loc times(b, I) = UsedInt*Loc I;

registration
  let I be good Program of SCM+FSA, a be Int-Location;
  cluster times(a, I) -> good;
end;

definition
  let s be State of SCM+FSA, I be Program of SCM+FSA, a be Int-Location;
  func StepTimes(a, I, s) -> Function of NAT, product the Object-Kind of
  SCM+FSA equals
:: SFMASTR2:def 2
  StepWhile>0(1-stRWNotIn ({a} \/ UsedIntLoc I), I ';' SubFrom(1
  -stRWNotIn ({a} \/ UsedIntLoc I), intloc 0), Exec(1-stRWNotIn ({a} \/
  UsedIntLoc I) := a, Initialized s));
end;

theorem :: SFMASTR2:10
  StepTimes(a, J, s).0.intloc 0 = 1;

theorem :: SFMASTR2:11
  s.intloc 0 = 1 or a is read-write implies StepTimes(a, J, s).0.(
  1-stRWNotIn ({a} \/ UsedIntLoc J)) = s.a;

theorem :: SFMASTR2:12
  StepTimes(a, J, s).k.intloc 0 = 1 & J is_closed_on StepTimes(a,
J, s).k & J is_halting_on StepTimes(a, J, s).k implies StepTimes(a, J, s).(k+1)
  .intloc 0 = 1 & (StepTimes(a, J, s).k.(1-stRWNotIn ({a} \/ UsedIntLoc J)) > 0
  implies StepTimes(a, J, s).(k+1).(1-stRWNotIn ({a} \/ UsedIntLoc J)) =
  StepTimes(a, J, s).k.(1-stRWNotIn ({a} \/ UsedIntLoc J)) - 1);

theorem :: SFMASTR2:13
  s.intloc 0 = 1 or a is read-write implies StepTimes(a, I, s).0.a
  = s.a;

theorem :: SFMASTR2:14
  StepTimes(a, I, s).0.f = s.f;

definition
  let s be State of SCM+FSA, a be Int-Location, I be Program of SCM+FSA;
  pred ProperTimesBody a, I, s means
:: SFMASTR2:def 3

  for k being Element of NAT st k <
s.a holds I is_closed_on StepTimes(a,I,s).k & I is_halting_on StepTimes(a,I,s).
  k;
end;

theorem :: SFMASTR2:15
  I is parahalting implies ProperTimesBody a, I, s;

theorem :: SFMASTR2:16
  ProperTimesBody a, J, s implies for k st k <= s.a holds
  StepTimes(a, J, s).k.intloc 0 = 1;

theorem :: SFMASTR2:17
  (s.intloc 0 = 1 or a is read-write) & ProperTimesBody a, J, s
  implies for k st k <= s.a holds StepTimes(a, J, s).k.(1-stRWNotIn({a} \/
  UsedIntLoc J))+k = s.a;

theorem :: SFMASTR2:18
  ProperTimesBody a, J, s & 0 <= s.a & (s.intloc 0 = 1 or a is
read-write) implies for k st k >= s.a holds StepTimes(a, J, s).k.(1-stRWNotIn({
  a} \/ UsedIntLoc J)) = 0 & StepTimes(a, J, s).k.intloc 0 = 1;

theorem :: SFMASTR2:19
  s.intloc 0 = 1 implies StepTimes(a, I, s).0 | ((UsedIntLoc I) \/
  FinSeq-Locations) = s | ((UsedIntLoc I) \/ FinSeq-Locations);

theorem :: SFMASTR2:20
  StepTimes(a, J, s).k.intloc 0 = 1 & J is_halting_on Initialized
  StepTimes(a, J, s).k & J is_closed_on Initialized StepTimes(a, J, s).k &
StepTimes(a, J, s).k.(1-stRWNotIn ({a} \/ UsedIntLoc J)) > 0 implies StepTimes(
a, J, s).(k+1) | ((UsedIntLoc J) \/ FinSeq-Locations) = IExec(J, StepTimes(a, J
  , s).k) | ((UsedIntLoc J) \/ FinSeq-Locations);

theorem :: SFMASTR2:21
  (ProperTimesBody a, J, s or J is parahalting) & k < s.a & (s.
  intloc 0 = 1 or a is read-write) implies StepTimes(a, J, s).(k+1) | ((
  UsedIntLoc J) \/ FinSeq-Locations) = IExec(J, StepTimes(a, J, s).k) | ((
  UsedIntLoc J) \/ FinSeq-Locations);

theorem :: SFMASTR2:22
  s.a <= 0 & s.intloc 0 = 1 implies IExec(times(a, I), s) | ((UsedIntLoc
  I) \/ FinSeq-Locations) = s | ((UsedIntLoc I) \/ FinSeq-Locations);

theorem :: SFMASTR2:23
  s.a = k & (ProperTimesBody a, J, s or J is parahalting) & (s.
  intloc 0 = 1 or a is read-write) implies DataPart IExec(times(a, J), s) =
  DataPart StepTimes(a, J, s).k;

theorem :: SFMASTR2:24
  s.intloc 0 = 1 & (ProperTimesBody a, J, s or J is parahalting)
  implies times(a, J) is_closed_on s & times(a, J) is_halting_on s;

begin :: A trivial example

definition
  let d be read-write Int-Location;
  func triv-times(d) -> Program of SCM+FSA equals
:: SFMASTR2:def 4
  times( d, while=0(d, Macro(d
  := d)) ';' SubFrom(d, intloc 0) );
end;

theorem :: SFMASTR2:25
  s.d <= 0 implies IExec(triv-times(d), s).d = s.d;

theorem :: SFMASTR2:26
  0 <= s.d implies IExec(triv-times(d), s).d = 0;

begin :: A macro for the Fibonacci sequence

definition
  let N, result be Int-Location;
  func Fib-macro (N, result) -> Program of SCM+FSA equals
:: SFMASTR2:def 5
  (1-stNotUsed times(N
  , AddTo(result, (1-stRWNotIn {N, result}))';' swap(result, 1-stRWNotIn {N,
result}))) := N ';' (SubFrom(result, result)) ';' ((1-stRWNotIn {N, result}) :=
intloc 0) ';' times(N, AddTo(result, (1-stRWNotIn {N, result})) ';' swap(result
, (1-stRWNotIn {N, result})) ) ';' (N := (1-stNotUsed times(N, AddTo(result, 1
  -stRWNotIn {N, result})';' swap(result, 1-stRWNotIn {N, result}))));
end;

theorem :: SFMASTR2:27
  for N, result being read-write Int-Location st N <> result for n being
Element of NAT st n = s.N holds IExec(Fib-macro(N, result), s).result = Fib n &
  IExec(Fib-macro(N, result), s).N = s.N;

