:: Algebra of Morphisms
::  by Grzegorz Bancerek
::
:: Received January 28, 1997
:: Copyright (c) 1997 Association of Mizar Users

environ

 vocabulary FUNCT_1, PRALG_1, RELAT_1, PBOOLE, PROB_1, TARSKI, FUNCT_6,
      MSUALG_3, BOOLE, FINSEQ_1, FINSEQ_2, MSUALG_1, MATRIX_1, ZF_REFLE, AMI_1,
      MSAFREE, PROB_2, MSATERM, MCART_1, MSUALG_6, CAT_5, INSTALG1, FUNCT_5,
      QC_LANG1, CAT_1, PUA2MSS1, CARD_3, TDGROUP, ALG_1, CATALG_1, FINSEQ_4;
 notation TARSKI, XBOOLE_0, ENUMSET1, ZFMISC_1, SUBSET_1, NUMBERS, XREAL_0,
      NAT_1, MCART_1, RELAT_1, FUNCT_1, FUNCT_2, MSAFREE1, FINSEQ_1, FINSEQ_2,
      PROB_1, CARD_3, FINSEQ_4, FUNCT_5, FUNCT_6, STRUCT_0, PBOOLE, PRALG_1,
      MSUALG_1, MSUALG_3, MSAFREE, MSATERM, EXTENS_1, PUA2MSS1, MSUALG_6,
      INSTALG1, CAT_1;
 constructors ENUMSET1, CAT_1, FINSEQ_4, MSATERM, EXTENS_1, PUA2MSS1, MSUALG_6,
      INSTALG1, TWOSCOMP, MSAFREE1, MEMBERED, XCMPLX_0, ARYTM_0, ORDINAL2,
      FACIRC_1, ORDINAL1, NAT_1;
 clusters SUBSET_1, STRUCT_0, RELSET_1, FUNCT_1, FINSEQ_1, FINSEQ_2, PRALG_1,
      PBOOLE, MSUALG_1, MSAFREE, INSTALG1, ARYTM_3, XBOOLE_0, MEMBERED,
      ORDINAL2;
 requirements NUMERALS, BOOLE, SUBSET, ARITHM;


begin :: Preliminaries

definition
 let I be set;
 let A,f be Function;
 func f-MSF(I,A) -> ManySortedFunction of I means
:: CATALG_1:def 1

  for i being set st i in I holds it.i = f|(A.i);
end;


theorem :: CATALG_1:1
   for I being set, A being ManySortedSet of I holds
  (id Union A)-MSF(I,A) = id A;

theorem :: CATALG_1:2
   for I being set, A,B being ManySortedSet of I
 for f,g being Function st rngs (f-MSF(I,A)) c= B
  holds (g*f)-MSF(I,A) = (g-MSF(I,B))**(f-MSF(I,A));

theorem :: CATALG_1:3
   for f being Function, I being set
 for A,B being ManySortedSet of I
  st for i being set st i in I holds A.i c= dom f & f.:(A.i) c= B.i
  holds f-MSF(I,A) is ManySortedFunction of A,B;

theorem :: CATALG_1:4
 for A being set, i being Nat, p being FinSequence holds
   p in i-tuples_on A iff len p = i & rng p c= A;

theorem :: CATALG_1:5
 for A being set, i being Nat, p being FinSequence of A holds
   p in i-tuples_on A iff len p = i;

theorem :: CATALG_1:6
   for A being set, i being Nat holds i-tuples_on A c= A*;

theorem :: CATALG_1:7
 for A being set, i being Nat holds i <> 0 & A = {} iff i-tuples_on A = {};

theorem :: CATALG_1:8
 for A,x being set holds x in 1-tuples_on A iff
  ex a being set st a in A & x = <*a*>;

theorem :: CATALG_1:9
   for A,a being set st <*a*> in 1-tuples_on A holds a in A;

theorem :: CATALG_1:10
 for A,x being set holds x in 2-tuples_on A iff
  ex a,b being set st a in A & b in A & x = <*a,b*>;

theorem :: CATALG_1:11
 for A,a,b being set st <*a,b*> in 2-tuples_on A holds a in A & b in A;

theorem :: CATALG_1:12
 for A,x being set holds x in 3-tuples_on A iff
  ex a,b,c being set st a in A & b in A & c in A & x = <*a,b,c*>;

theorem :: CATALG_1:13
   for A,a,b,c being set st <*a,b,c*> in 3-tuples_on A holds a in A & b in A &
c
in A;

definition
 let S be non empty ManySortedSign;
 let A be MSAlgebra over S;
 canceled;

 attr A is empty means
:: CATALG_1:def 3

  the Sorts of A is empty-yielding;
end;


registration
 let S be non empty ManySortedSign;
 cluster non-empty -> non empty MSAlgebra over S;
 coherence
  proof let A be MSAlgebra over S; assume
      the Sorts of A is non-empty;
    then the Sorts of A is non-empty ManySortedSet of the carrier of S;
   hence the Sorts of A is not empty-yielding;
  end;
end;


registration
 let S be non empty non void ManySortedSign;
 let X be non-empty ManySortedSet of the carrier of S;
 cluster FreeMSA X -> disjoint_valued;
 coherence
  proof set A = FreeMSA X;
   let x,y be set; assume
A1:  x <> y;
   assume (the Sorts of A).x meets (the Sorts of A).y;
   then consider z being set such that
A2:  z in (the Sorts of A).x & z in (the Sorts of A).y by XBOOLE_0:3;
      dom the Sorts of A = the carrier of S by PBOOLE:def 3;
   then reconsider x, y as SortSymbol of S by A2,FUNCT_1:def 4;
      A = MSAlgebra(#FreeSort X, FreeOper X#) by MSAFREE:def 16;
then A3:  (the Sorts of A).x = FreeSort(X,x) & (the Sorts of A).y = FreeSort(X,
y)
     by MSAFREE:def 13;
      FreeSort(X,x) c= S-Terms X by MSATERM:12;
   then reconsider z as Term of S,X by A2,A3;
      the_sort_of z = x & the_sort_of z = y by A2,A3,MSATERM:def 5;
   hence thesis by A1;
  end;
end;


registration
 let S be non empty non void ManySortedSign;
 cluster strict non-empty disjoint_valued MSAlgebra over S;
 existence
  proof consider X being non-empty ManySortedSet of the carrier of S;
   take A = FreeMSA X; thus A is strict non-empty disjoint_valued;
  end;
end;


registration
 let S be non empty non void ManySortedSign;
 let A be non empty MSAlgebra over S;
 cluster the Sorts of A -> non empty-yielding;
 coherence by Def3;
end;


registration
 cluster non empty-yielding Function;
 existence
  proof consider S being non empty non void ManySortedSign;
   consider A being non empty MSAlgebra over S;
   take the Sorts of A; thus thesis;
  end;
end;


begin :: Signature of a category

definition
 let A be set;
 canceled;

 func CatSign A -> strict ManySortedSign means
:: CATALG_1:def 5

  the carrier of it = [:{0},2-tuples_on A:] &
  the OperSymbols of it = [:{1},1-tuples_on A:] \/ [:{2},3-tuples_on A:] &
  (for a being set st a in A holds
    (the Arity of it).[1,<*a*>] = {} &
    (the ResultSort of it).[1,<*a*>] = [0,<*a,a*>]) &
  (for a,b,c being set st a in A & b in A & c in A holds
    (the Arity of it).[2,<*a,b,c*>] = <*[0,<*b,c*>],[0,<*a,b*>]*> &
    (the ResultSort of it).[2,<*a,b,c*>] = [0,<*a,c*>]);
end;


registration
 let A be set;
 cluster CatSign A -> feasible;
 coherence
  proof assume
      the carrier of CatSign A = {};
    then A1: [:{0},2-tuples_on A:] = {} by Def5;
      now assume A <> {}; then reconsider A as non empty set;
        2-tuples_on A <> {};
     hence contradiction by A1,ZFMISC_1:113;
    end;
    then 1 <> 0 & 3 <> 0 implies 1-tuples_on A = {} & 3-tuples_on A = {}
 by Th7;
    then [:{1},1-tuples_on A:] = {} & [:{2},3-tuples_on A:] = {}
     by ZFMISC_1:113;
    then [:{1},1-tuples_on A:] \/ [:{2},3-tuples_on A:] = {};
   hence thesis by Def5;
  end;
end;


registration
 let A be non empty set;
 cluster CatSign A -> non empty non void;
 coherence
  proof
      the carrier of CatSign A = [:{0},2-tuples_on A:] by Def5;
   hence the carrier of CatSign A is non empty;
      the OperSymbols of CatSign A =
      [:{1},1-tuples_on A:] \/ [:{2},3-tuples_on A:] by Def5;
   hence the OperSymbols of CatSign A <> {};
  end;
end;


definition
 mode Signature is feasible ManySortedSign;
end;


definition
 let S be Signature;
 attr S is Categorial means
:: CATALG_1:def 6

 ex A being set st CatSign A is Subsignature of S &
  the carrier of S = [:{0},2-tuples_on A:];
end;


registration
 cluster Categorial -> non void (non empty Signature);
 coherence
  proof let S be non empty Signature;
   given A being set such that
A1:  CatSign A is Subsignature of S & the carrier of S = [:{0},2-tuples_on A:];
   consider s being SortSymbol of S;
   consider z,p being set such that
A2:  z in {0} & p in 2-tuples_on A & s = [z,p] by A1,ZFMISC_1:103;
      2-tuples_on A = {q where q is Element of A*: len q = 2}
     by FINSEQ_2:def 4;
   then consider q being Element of A* such that
A3:  p = q & len q = 2 by A2;
      dom q = Seg 2 by A3,FINSEQ_1:def 3;
    then 1 in dom q by FINSEQ_1:4,TARSKI:def 2;
    then A4: q.1 in rng q & rng q c= A by FINSEQ_1:def 4,FUNCT_1:def 5;
   then reconsider A' = A as non empty set;
   reconsider a = q.1 as Element of A' by A4;
      <*a*> is Element of 1-tuples_on A' by FINSEQ_2:118;
    then [1,<*a*>] in [:{1},1-tuples_on A:] & the OperSymbols of CatSign A
      = [:{1},1-tuples_on A:] \/ [:{2},3-tuples_on A:]
     by Def5,ZFMISC_1:128;
    then [:{1},1-tuples_on A:] \/ [:{2},3-tuples_on A:] c= the OperSymbols of
S &
    [1,<*a*>] in [:{1},1-tuples_on A:] \/ [:{2},3-tuples_on A:]
     by A1,INSTALG1:11,XBOOLE_0:def 2; hence the OperSymbols of S <> {};
  end;
end;


registration
 cluster Categorial non empty strict Signature;
 existence
  proof consider A being non empty set;
   take S = CatSign A;
   thus S is Categorial proof take A; thus thesis by Def5,INSTALG1:16; end;
   thus thesis;
  end;
end;


definition
 mode CatSignature is Categorial Signature;
end;


definition
 let A be set;
 mode CatSignature of A -> Signature means
:: CATALG_1:def 7

  CatSign A is Subsignature of it &
  the carrier of it = [:{0},2-tuples_on A:];
end;


theorem :: CATALG_1:14
   for A1,A2 being set, S being CatSignature of A1 st S is CatSignature of A2
  holds A1 = A2;

registration
 let A be set;
 cluster -> Categorial CatSignature of A;
 coherence proof let S be CatSignature of A; take A; thus thesis by Def7; end;
end;


registration
 let A be non empty set;
 cluster -> non empty CatSignature of A;
 coherence
  proof let S be CatSignature of A;
   consider s being Element of CatSign A;
      CatSign A is Subsignature of S by Def7;
    then s in the carrier of CatSign A &
    the carrier of CatSign A c= the carrier of S by INSTALG1:11;
hence the carrier of S is not empty;
  end;
end;


registration
 let A be set;
 cluster strict CatSignature of A;
 existence
  proof set S = CatSign A;
    S is Subsignature of S &
    the carrier of S = [:{0},2-tuples_on A:] by Def5,INSTALG1:16;
    then S is CatSignature of A by Def7;
   hence thesis;
  end;
end;


definition
 let A be set;
 redefine func CatSign A -> strict CatSignature of A;
end;


definition
 let S be ManySortedSign;
 func underlay S means
:: CATALG_1:def 8

   for x being set holds x in it iff
    ex a being set, f being Function st
     [a,f] in (the carrier of S) \/ (the OperSymbols of S) & x in rng f;
end;


theorem :: CATALG_1:15
 for A being set holds underlay CatSign A = A;

definition
 let S be ManySortedSign;
 attr S is delta-concrete means
:: CATALG_1:def 9

  ex f being Function of NAT,NAT st
   (for s being set st s in the carrier of S
     ex i being Nat, p being FinSequence st s = [i,p] & len p = f.i &
       [:{i}, (f.i)-tuples_on underlay S:] c= the carrier of S) &
   (for o being set st o in the OperSymbols of S
     ex i being Nat, p being FinSequence st o = [i,p] & len p = f.i &
       [:{i}, (f.i)-tuples_on underlay S:] c= the OperSymbols of S);
end;


registration
 let A be set;
 cluster CatSign A -> delta-concrete;
 coherence
  proof set S = CatSign A;
    defpred P[set,set] means
      ($1 = 0 implies $2 = 2) & ($1 = 1 implies $2 = 1) &
      ($1 = 2 implies $2 = 3);
A1:  for x be set st x in NAT ex y be set st y in NAT & P[x,y]
    proof
     let i be set; assume i in NAT;
     reconsider j0 = 2, j1 = 1, j2 = 3 as set;
     per cases;
     suppose
A2:  i = 0; take j = j0;
      thus j in NAT & (i = 0 implies j = 2) & (i = 1 implies j = 1) &
       (i = 2 implies j = 3) by A2;
     end;
     suppose
A3:  i = 1; take j = j1;
      thus j in NAT & (i = 0 implies j = 2) & (i = 1 implies j = 1) &
       (i = 2 implies j = 3) by A3;
     end;
     suppose
A4:  i = 2; take j = j2;
      thus j in NAT & (i = 0 implies j = 2) & (i = 1 implies j = 1) &
       (i = 2 implies j = 3) by A4;
     end;
     suppose
A5:  i <> 0 & i <> 1 & i <> 2; take j = j0;
      thus j in NAT & (i = 0 implies j = 2) & (i = 1 implies j = 1) &
       (i = 2 implies j = 3) by A5;
    end;
    end;
    consider f being Function such that
A6:  dom f = NAT & rng f c= NAT and
A7:  for i being set st i in NAT holds P[i,f.i] from COMPTS_1:sch 1(A1);
   reconsider f as Function of NAT,NAT by A6,FUNCT_2:4;
A8:  the carrier of S = [:{0},2-tuples_on A:] by Def5;
A9:  the OperSymbols of S = [:{1},1-tuples_on A:] \/ [:{2}, 3-tuples_on A:]
     by Def5;
A10:  A = underlay S by Th15;
   take f;
   hereby let s be set; assume s in the carrier of S;
    then consider i, p being set such that
A11:  i in {0} & p in 2-tuples_on A & s = [i,p] by A8,ZFMISC_1:103;
    reconsider p as FinSequence by A11,FINSEQ_2:def 3;
    take i = 0, p; f.i = 2 by A7;
    hence s = [i,p] & len p = f.i by A11,Th4,TARSKI:def 1; thus
  [:{i}, (f.i)-tuples_on underlay S:] c= the carrier of S by A7,A8,A10;
   end;
   let o be set; assume A12: o in the OperSymbols of S;
   per cases by A9,A12,XBOOLE_0:def 2;
   suppose o in [:{1}, 1-tuples_on A:];
    then consider i,p being set such that
A13:  i in {1} & p in 1-tuples_on A & o = [i,p] by ZFMISC_1:103;
    reconsider p as FinSequence of A by A13,FINSEQ_2:def 3;
    take i = 1, p;
       f.i = 1 by A7;
    hence thesis by A9,A10,A13,Th4,TARSKI:def 1,XBOOLE_1:7;
   end;
   suppose o in [:{2}, 3-tuples_on A:];
    then consider i,p being set such that
A14:  i in {2} & p in 3-tuples_on A & o = [i,p] by ZFMISC_1:103;
    reconsider p as FinSequence of A by A14,FINSEQ_2:def 3;
    take i = 2, p;
       f.i = 3 by A7;
    hence thesis by A9,A10,A14,Th4,TARSKI:def 1,XBOOLE_1:7;
  end;
  end;
end;


registration
 cluster delta-concrete non empty strict CatSignature;
 existence
  proof consider A being non empty set;
   take CatSign A; thus thesis;
  end;
 let A be set;
 cluster delta-concrete strict CatSignature of A;
 existence proof take CatSign A; thus thesis; end;
end;


theorem :: CATALG_1:16
 for S being delta-concrete ManySortedSign, x being set
  st x in the carrier of S or x in the OperSymbols of S
 ex i being Nat, p being FinSequence st x = [i,p] & rng p c= underlay S;

theorem :: CATALG_1:17
   for S being delta-concrete ManySortedSign, i being set,
     p1,p2 being FinSequence
  st [i,p1] in the carrier of S & [i,p2] in the carrier of S or
     [i,p1] in the OperSymbols of S & [i,p2] in the OperSymbols of S
  holds len p1 = len p2;

theorem :: CATALG_1:18
   for S being delta-concrete ManySortedSign, i being set,
     p1,p2 being FinSequence
  st len p2 = len p1 & rng p2 c= underlay S
  holds ([i,p1] in the carrier of S implies [i,p2] in the carrier of S) &
    ([i,p1] in the OperSymbols of S implies [i,p2] in the OperSymbols of S);

theorem :: CATALG_1:19
   for S being delta-concrete Categorial non empty Signature
  holds S is CatSignature of underlay S;

begin :: Symbols of categorial sygnature


registration
 let S be non empty CatSignature;
 let s be SortSymbol of S;
 cluster s`2 -> Relation-like Function-like;
 coherence
  proof consider A being set such that
A1:  CatSign A is Subsignature of S &
    the carrier of S = [:{0},2-tuples_on A:] by Def6;
      s`2 in 2-tuples_on A by A1,MCART_1:10;
    then ex a,b being set st a in A & b in A & s`2 = <*a,b*> by Th10;
   hence thesis;
  end;
end;


registration
 let S be non empty delta-concrete ManySortedSign;
 let s be SortSymbol of S;
 cluster s`2 -> Relation-like Function-like;
 coherence
  proof consider i being Nat, p being FinSequence such that
A1:  s = [i,p] & rng p c= underlay S by Th16;
    thus thesis by A1,MCART_1:7;
  end;
end;


registration
 let S be non void delta-concrete ManySortedSign;
 let o be Element of the OperSymbols of S;
 cluster o`2 -> Relation-like Function-like;
 coherence
  proof consider i being Nat, p being FinSequence such that
A1:  o = [i,p] & rng p c= underlay S by Th16;
    thus thesis by A1,MCART_1:7;
  end;
end;


registration
 let S be non empty CatSignature;
 let s be SortSymbol of S;
 cluster s`2 -> FinSequence-like;
 coherence
  proof consider A being set such that
A1:  CatSign A is Subsignature of S &
    the carrier of S = [:{0},2-tuples_on A:] by Def6;
      s`2 in 2-tuples_on A by A1,MCART_1:10;
    then ex a,b being set st a in A & b in A & s`2 = <*a,b*> by Th10;
   hence thesis;
  end;
end;


registration
 let S be non empty delta-concrete ManySortedSign;
 let s be SortSymbol of S;
 cluster s`2 -> FinSequence-like;
 coherence
  proof consider i being Nat, p being FinSequence such that
A1:  s = [i,p] & rng p c= underlay S by Th16;
    thus thesis by A1,MCART_1:7;
  end;
end;


registration
 let S be non void delta-concrete ManySortedSign;
 let o be Element of the OperSymbols of S;
 cluster o`2 -> FinSequence-like;
 coherence
  proof consider i being Nat, p being FinSequence such that
A1:  o = [i,p] & rng p c= underlay S by Th16;
    thus thesis by A1,MCART_1:7;
  end;
end;


definition let a be set;
 func idsym a equals
:: CATALG_1:def 10

   [1,<*a*>];
 let b be set;
 func homsym(a,b) equals
:: CATALG_1:def 11

   [0,<*a,b*>];
 let c be set;
 func compsym(a,b,c) equals
:: CATALG_1:def 12

   [2,<*a,b,c*>];
end;


theorem :: CATALG_1:20
 for A being non empty set, S being CatSignature of A
 for a being Element of A holds idsym a in the OperSymbols of S &
 for b being Element of A holds homsym(a,b) in the carrier of S &
 for c being Element of A holds compsym(a,b,c) in the OperSymbols of S;

definition let A be non empty set;
 redefine
 let a be Element of A;
 func idsym a -> OperSymbol of CatSign A;
 let b be Element of A;
 func homsym(a,b) -> SortSymbol of CatSign A;
 let c be Element of A;
 func compsym(a,b,c) -> OperSymbol of CatSign A;
end;


theorem :: CATALG_1:21
 for a,b being set st idsym(a) = idsym(b) holds a = b;

theorem :: CATALG_1:22
 for a1,b1,a2,b2 being set st homsym(a1,a2) = homsym(b1,b2)
  holds a1 = b1 & a2 = b2;

theorem :: CATALG_1:23
 for a1,b1,a2,b2,a3,b3 being set st compsym(a1,a2,a3) = compsym(b1,b2,b3)
  holds a1 = b1 & a2 = b2 & a3 = b3;

theorem :: CATALG_1:24
 for A being non empty set, S being CatSignature of A
 for s being SortSymbol of S ex a,b being Element of A st s = homsym(a,b);

theorem :: CATALG_1:25
 for A being non empty set, o being OperSymbol of CatSign A
  holds o`1 = 1 & len o`2 = 1 or o`1 = 2 & len o`2 = 3;

theorem :: CATALG_1:26
 for A being non empty set, o being OperSymbol of CatSign A
  st o`1 = 1 or len o`2 = 1
 ex a being Element of A st o = idsym(a);

theorem :: CATALG_1:27
 for A being non empty set, o being OperSymbol of CatSign A
  st o`1 = 2 or len o`2 = 3
 ex a,b,c being Element of A st o = compsym(a,b,c);

theorem :: CATALG_1:28
 for A being non empty set, a being Element of A holds
  the_arity_of idsym(a) = {} & the_result_sort_of idsym(a) = homsym(a,a);

theorem :: CATALG_1:29
 for A being non empty set, a,b,c being Element of A holds
  the_arity_of compsym(a,b,c) = <*homsym(b,c),homsym(a,b)*> &
  the_result_sort_of compsym(a,b,c) = homsym(a,c);

begin :: Signature homomorphism generated by a functor

definition
 let C1,C2 be Category;
 let F be Functor of C1,C2;
 func Upsilon F -> Function of the carrier of CatSign the Objects of C1,
                               the carrier of CatSign the Objects of C2 means
:: CATALG_1:def 13

  for s being SortSymbol of CatSign the Objects of C1
   holds it.s = [0,(Obj F)*s`2];
 func Psi F -> Function of the OperSymbols of CatSign the Objects of C1,
                           the OperSymbols of CatSign the Objects of C2 means
:: CATALG_1:def 14

  for o being OperSymbol of CatSign the Objects of C1
   holds it.o = [o`1,(Obj F)*o`2];
end;

theorem :: CATALG_1:30
 for C1,C2 being Category, F being Functor of C1,C2
 for a,b being Object of C1 holds
  (Upsilon F).homsym(a,b) = homsym(F.a,F.b);

theorem :: CATALG_1:31
 for C1,C2 being Category, F being Functor of C1,C2
 for a being Object of C1 holds (Psi F).idsym(a) = idsym(F.a);

theorem :: CATALG_1:32
 for C1,C2 being Category, F being Functor of C1,C2
 for a,b,c being Object of C1
  holds (Psi F).compsym(a,b,c) = compsym(F.a,F.b,F.c);

theorem :: CATALG_1:33
 for C1,C2 being Category, F being Functor of C1,C2 holds
   Upsilon F, Psi F form_morphism_between
    CatSign the Objects of C1, CatSign the Objects of C2;

begin :: Algebra of morphisms

theorem :: CATALG_1:34
 for C being non empty set, A being MSAlgebra over CatSign C
 for a being Element of C holds Args(idsym(a), A) = {{}};

scheme :: CATALG_1:sch 1
 CatAlgEx { X, Y() -> non empty set,
    H(set,set) -> set, R(set,set,set,set,set) -> set,
    I(set) -> set}:
 ex A being strict MSAlgebra over CatSign X() st
  (for a,b being Element of X() holds (the Sorts of A).homsym(a,b) = H(a,b)) &
  (for a being Element of X() holds Den(idsym(a),A).{} = I(a)) &
   for a,b,c being Element of X() for f,g being Element of Y()
    st f in H(a,b) & g in H(b,c)
    holds Den(compsym(a,b,c),A).<*g,f*> = R(a,b,c,g,f)
  provided
   for a,b being Element of X() holds H(a,b) c= Y()
  and
   for a being Element of X() holds I(a) in H(a,a)
  and
   for a,b,c being Element of X() for f,g being Element of Y()
     st f in H(a,b) & g in H(b,c) holds R(a,b,c,g,f) in H(a,c)
proof   set CS = CatSign X();
    defpred P[set,set] means
     ex a,b being Element of X() st $1 = homsym(a,b) & $2 = H(a,b);
A4:  now let s be set; assume s in the carrier of CS;
     then consider a,b being Element of X() such that
A5:   s = homsym(a,b) by Th24;
     take u = H(a,b); thus P[s,u] by A5;
    end;
   consider S being Function such that
A6: dom S = the carrier of CS and
A7: for s being set st s in the carrier of CS holds P[s,S.s]
       from ZFREFLE1:sch 1(A4);
    defpred Z[set,set] means
     ($1`1 = 1 & ex a being Element of X() st $1 = idsym(a) &
       ex F being Function of {{}}, H(a,a) st F = $2 & F.{} = I(a)) or
     ($1`1 = 2 & ex a,b,c being Element of X() st $1 = compsym(a,b,c) &
       ex F being Function of product<*H(b,c),H(a,b)*>, H(a,c) st F = $2 &
        for f,g being set st f in H(a,b) & g in H(b,c)
         holds F.<*g,f*> = R(a,b,c,g,f));
A8:  for o be set st o in the OperSymbols of CS ex u be set st Z[o,u]
    proof
    let o be set; assume
A9:   o in the OperSymbols of CS;
then A10:   o`1 = 1 or o`1 = 2 by Th25;
A11:   now assume o`1 = 1;
       then consider a being Element of X() such that
A12:     o = idsym a by A9,Th26;
        deffunc f(set) = I(a);
       consider F being Function such that
A13:     dom F = {{}} & for x being set st x in {{}} holds F.x = f(x)
         from FUNCT_1:sch 3;
       reconsider u = F as set;
       take u, a; thus o = idsym(a) by A12;
          rng F c= H(a,a)
         proof let y be set; assume y in rng F;
           then ex x being set st x in dom F & y = F.x by FUNCT_1:def 5;
           then y = I(a) by A13;
          hence thesis by A2;
         end;
       then reconsider F as Function of {{}}, H(a,a) by A13,FUNCT_2:4;
       take F; {} in {{}} by TARSKI:def 1;
       hence F = u & F.{} = I(a) by A13;
      end;
        now assume o`1 = 2;
       then consider a,b,c being Element of X() such that
A14:     o = compsym(a,b,c) by A9,Th27;
       defpred P[set,set] means
        ex f,g being set st f in H(a,b) & g in H(b,c) & $1 = <*g,f*> &
          $2 = R(a,b,c,g,f);
A15:     now let x be set; assume x in product<*H(b,c),H(a,b)*>;
         then consider g,f being set such that
A16:       g in H(b,c) & f in H(a,b) & x = <*g,f*> by FUNCT_6:2;
         take u = R(a,b,c,g,f);
            H(a,b) c= Y() & H(b,c) c= Y() by A1; hence u in H(a,c) by A3,A16;
         thus P[x,u] by A16;
        end;
       consider F being Function such that
A17:     dom F = product<*H(b,c),H(a,b)*> & rng F c= H(a,c) and
A18:     for x being set st x in product<*H(b,c),H(a,b)*> holds P[x,F.x]
          from COMPTS_1:sch 1(A15);
       reconsider u = F as set;
       take u, a, b, c; thus o = compsym(a,b,c) by A14;
       reconsider F as Function of product<*H(b,c),H(a,b)*>, H(a,c)
         by A17,FUNCT_2:4;
       take F; thus F = u;
       let f,g be set; assume f in H(a,b) & g in H(b,c);
        then <*g,f*> in product<*H(b,c),H(a,b)*> by FUNCT_6:2;
       then consider f',g' being set such that
A19:     f' in H(a,b) & g' in H(b,c) & <*g,f*> = <*g',f'*> &
        F.<*g,f*> = R(a,b,c,g',f') by A18;
          <*g,f*>.1 = g & <*g,f*>.1 = g' & <*g,f*>.2 = f & <*g,f*>.2 = f'
         by A19,FINSEQ_1:61;
       hence F.<*g,f*> = R(a,b,c,g,f) by A19;
      end;
     hence ex u being set st
      (o`1 = 1 & ex a being Element of X() st o = idsym(a) &
        ex F being Function of {{}}, H(a,a) st F = u & F.{} = I(a)) or
      (o`1 = 2 & ex a,b,c being Element of X() st o = compsym(a,b,c) &
        ex F being Function of product<*H(b,c),H(a,b)*>, H(a,c) st F = u &
         for f,g being set st f in H(a,b) & g in H(b,c)
          holds F.<*g,f*> = R(a,b,c,g,f)) by A10,A11;
    end;
   consider O being Function such that
A20: dom O = the OperSymbols of CS and
A21: for o being set st o in the OperSymbols of CS holds Z[o,O.o]
      from ZFREFLE1:sch 1(A8);
   reconsider S as ManySortedSet of the carrier of CS by A6,PBOOLE:def 3;
   reconsider O as ManySortedSet of the OperSymbols of CS by A20,PBOOLE:def 3;
      O is ManySortedFunction of S#*the Arity of CS, S*the ResultSort of CS
     proof let o be set; assume o in the OperSymbols of CS;
      then reconsider o as OperSymbol of CS;
A22:    (S#*the Arity of CS).o = S#.((the Arity of CS).o) by FUNCT_2:21
        .= S#.the_arity_of o by MSUALG_1:def 6
        .= product (S*the_arity_of o) by MSUALG_1:def 3;
A23:    (S*the ResultSort of CS).o = S.((the ResultSort of CS).o) by FUNCT_2:21
        .= S.the_result_sort_of o by MSUALG_1:def 7;
      per cases by Th25;
      suppose o`1 = 1 & 1 <> 2;
       then consider a being Element of X() such that
A24:     o = idsym a &
        ex F being Function of {{}}, H(a,a) st F = O.o & F.{} = I(a) by A21;
       consider c,b being Element of X() such that
A25:     homsym(a,a) = homsym(c,b) & S.homsym(a,a) = H(c,b) by A7;
          the_arity_of idsym(a) = {} & a = b & a = c & {} = S*{} &
        the_result_sort_of idsym(a) = homsym(a,a)
         by A25,Th22,Th28,RELAT_1:62; hence thesis by A22,A23,A24,A25,CARD_3:19
;
      end;
      suppose o`1 = 2 & 1 <> 2;
       then consider a,b,c being Element of X() such that
A26:     o = compsym(a,b,c) &
        ex F being Function of product<*H(b,c),H(a,b)*>, H(a,c) st F = O.o &
         for f,g being set st f in H(a,b) & g in H(b,c)
          holds F.<*g,f*> = R(a,b,c,g,f) by A21;
       consider a',b' being Element of X() such that
A27:     homsym(a,b) = homsym(a',b') & S.homsym(a,b) = H(a',b') by A7;
       consider b'',c' being Element of X() such that
A28:     homsym(b,c) = homsym(b'',c') & S.homsym(b,c) = H(b'',c') by A7;
       consider ax,cx being Element of X() such that
A29:     homsym(a,c) = homsym(ax,cx) & S.homsym(a,c) = H(ax,cx) by A7;
          a' = a & b' = b & b'' = b & c' = c & ax = a & cx = c &
        the_arity_of compsym(a,b,c) = <*homsym(b,c),homsym(a,b)*> &
        the_result_sort_of compsym(a,b,c) = homsym(a,c)
         by A27,A28,A29,Th22,Th29;
        then (S#*the Arity of CS).o = product<*H(b,c),H(a,b)*> &
        (S*the ResultSort of CS).o = H(a,c) by A6,A22,A23,A26,A27,A28,A29,
FINSEQ_2:145;
       hence thesis by A26;
     end;
     end;
   then reconsider O as ManySortedFunction of
        S#*the Arity of CS, S*the ResultSort of CS;
   take A = MSAlgebra(#S, O#);
   hereby let a,b be Element of X();
    consider a',b' being Element of X() such that
A30:  homsym(a,b) = homsym(a',b') & S.homsym(a,b) = H(a',b') by A7;
       a = a' & b = b' by A30,Th22;
    hence (the Sorts of A).homsym(a,b) = H(a,b) by A30;
   end;
   hereby let a be Element of X();
       idsym a = [1,<*a*>] by Def10;
     then (idsym a)`1 = 1 & 1 <> 2 by MCART_1:7;
    then consider b being Element of X() such that
A31:  idsym a = idsym b &
     ex F being Function of {{}}, H(b,b) st F = O.idsym a & F.{} = I(b)
      by A21;
    thus Den(idsym(a),A).{}
       = I(b) by A31,MSUALG_1:def 11
      .= I(a) by A31,Th21;
   end;
   let a,b,c be Element of X();
   set o = compsym(a,b,c); o = [2,<*a,b,c*>] by Def12;
    then o`1 = 2 & 1 <> 2 by MCART_1:7;
   then consider a',b',c' being Element of X() such that
A32: o = compsym(a',b',c') &
    ex F being Function of product<*H(b',c'),H(a',b')*>, H(a',c') st F = O.o &
     for f,g being set st f in H(a',b') & g in H(b',c')
      holds F.<*g,f*> = R(a',b',c',g,f) by A21;
      a = a' & b = b' & c = c' by A32,Th23;
   then consider F being Function of product<*H(b,c),H(a,b)*>, H(a,c) such that
A33: F = O.o &
    for f,g being set st f in H(a,b) & g in H(b,c)
     holds F.<*g,f*> = R(a,b,c,g,f) by A32;
   let f,g be Element of Y(); assume
      f in H(a,b) & g in H(b,c);
    then F.<*g,f*> = R(a,b,c,g,f) by A33;
   hence Den(compsym(a,b,c),A).<*g,f*> = R(a,b,c,g,f) by A33,MSUALG_1:def 11;
  end;

definition
 let C be Category;
 func MSAlg C -> strict MSAlgebra over CatSign the Objects of C means
:: CATALG_1:def 15

  (for a,b being Object of C holds (the Sorts of it).homsym(a,b) = Hom(a,b)) &
  (for a being Object of C holds Den(idsym(a),it).{} = id a) &
   for a,b,c being Object of C for f,g being Morphism of C
    st dom f = a & cod f = b & dom g = b & cod g = c
    holds Den(compsym(a,b,c),it).<*g,f*> = g*f;
end;


canceled;

theorem :: CATALG_1:36
 for A being Category, a being Object of A holds
   Result(idsym a, MSAlg A) = Hom(a,a);

theorem :: CATALG_1:37
 for A being Category, a,b,c being Object of A holds
   Args(compsym(a,b,c), MSAlg A) = product <*Hom(b,c), Hom(a,b)*> &
   Result(compsym(a,b,c), MSAlg A) = Hom(a,c);

registration
 let C be Category;
 cluster MSAlg C -> disjoint_valued feasible;
 coherence
  proof
   hereby let x,y be set; assume
A1:   x <> y & (the Sorts of MSAlg C).x meets (the Sorts of MSAlg C).y;
    then consider z being set such that
A2:   z in (the Sorts of MSAlg C).x & z in (the Sorts of MSAlg C).y
      by XBOOLE_0:3;
       (the Sorts of MSAlg C).x <> {} & (the Sorts of MSAlg C).y <> {} &
     dom the Sorts of MSAlg C = the carrier of CatSign the Objects of C
      by A2,PBOOLE:def 3;
    then reconsider x,y as SortSymbol of CatSign the Objects of C
      by FUNCT_1:def 4;
    consider a,b being Object of C such that
A3:   x = homsym(a,b) by Th24;
    consider c,d being Object of C such that
A4:   y = homsym(c,d) by Th24;
A5:   z in Hom(a,b) & z in Hom(c,d) by A2,A3,A4,Def15;
    then reconsider z as Morphism of C;
       dom z = a & dom z = c & cod z = b & cod z = d by A5,CAT_1:18;
    hence contradiction by A1,A3,A4;
   end;
   let o be OperSymbol of CatSign the Objects of C;
   per cases by Th25;
   suppose o`1 = 1;
    then consider a being Object of C such that
A6:   o = idsym a by Th26;
       Result(o, MSAlg C) = Hom(a,a) & id a in Hom(a,a) by A6,Th36,CAT_1:55;
    hence thesis;
   end;
   suppose o`1 = 2;
    then consider a,b,c being Object of C such that
A7:   o = compsym(a,b,c) by Th27;
A8:   Args(o, MSAlg C) = product <*Hom(b,c), Hom(a,b)*> &
     Result(o, MSAlg C) = Hom(a,c) by A7,Th37;
    consider A being Element of Args(o, MSAlg C);
    assume Args(o, MSAlg C) <> {};
     then ex g,f being set st g in Hom(b,c) & f in Hom(a,b) & A = <*g,f*>
      by A8,FUNCT_6:2;
    hence thesis by A8,CAT_1:52;
  end;
  end;
end;


theorem :: CATALG_1:38
 for C1,C2 being Category, F being Functor of C1,C2 holds
  F-MSF(the carrier of CatSign the Objects of C1, the Sorts of MSAlg C1)
 is ManySortedFunction of
   MSAlg C1, (MSAlg C2)|(CatSign the Objects of C1, Upsilon F, Psi F);

theorem :: CATALG_1:39
 for C being Category, a,b,c being Object of C
 for x being set holds x in Args(compsym(a,b,c), MSAlg C) iff
 ex g,f being Morphism of C st x = <*g,f*> &
  dom f = a & cod f = b & dom g = b & cod g = c;

theorem :: CATALG_1:40
 for C1,C2 being Category, F being Functor of C1,C2
 for a,b,c being Object of C1
 for f,g being Morphism of C1 st f in Hom(a,b) & g in Hom(b,c)
 for x being Element of Args(compsym(a,b,c),MSAlg C1) st x = <*g,f*>
 for H being ManySortedFunction of
   MSAlg C1, (MSAlg C2)|(CatSign the Objects of C1, Upsilon F, Psi F)
 st H = F-MSF(the carrier of CatSign the Objects of C1, the Sorts of MSAlg C1)
 holds H#x = <*F.g,F.f*>;

canceled;

theorem :: CATALG_1:42
 for C being Category, a,b,c being Object of C, f,g being Morphism of C
  st f in Hom(a,b) & g in Hom(b,c)
  holds Den(compsym(a,b,c), MSAlg C).<*g,f*> = g*f;

theorem :: CATALG_1:43
   for C being Category, a,b,c,d being Object of C, f,g,h being Morphism of C
  st f in Hom(a,b) & g in Hom(b,c) & h in Hom(c,d)
  holds
   Den(compsym(a,c,d), MSAlg C).<*h, Den(compsym(a,b,c), MSAlg C).<*g,f*>*> =
   Den(compsym(a,b,d), MSAlg C).<*Den(compsym(b,c,d), MSAlg C).<*h,g*>, f*>;

theorem :: CATALG_1:44
   for C being Category, a,b being Object of C, f being Morphism of C
  st f in Hom(a,b)
  holds Den(compsym(a,b,b), MSAlg C).<*id b, f*> = f &
        Den(compsym(a,a,b), MSAlg C).<*f, id a*> = f;

theorem :: CATALG_1:45
   for C1,C2 being Category, F being Functor of C1,C2
 ex H being ManySortedFunction of MSAlg C1,
   (MSAlg C2)|(CatSign the Objects of C1, Upsilon F, Psi F) st
  H = F-MSF(the carrier of CatSign the Objects of C1, the Sorts of MSAlg C1) &
  H is_homomorphism MSAlg C1,
    (MSAlg C2)|(CatSign the Objects of C1, Upsilon F, Psi F);

