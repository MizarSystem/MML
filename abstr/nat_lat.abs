:: The Lattice of Natural Numbers and The Sublattice of it.
:: The Set of Prime Numbers
::  by Marek Chmur
::
:: Received April 26, 1991
:: Copyright (c) 1991 Association of Mizar Users

environ

 vocabularies ARYTM_3, QC_LANG1, BINOP_1, FUNCT_1, LATTICES, ARYTM, RELAT_1,
      BOOLE, NAT_LAT, REALSET1, ORDINAL2, XREAL_0;
 notations TARSKI, XBOOLE_0, ZFMISC_1, SUBSET_1, NUMBERS, ORDINAL1, XREAL_0,
      REALSET1, STRUCT_0, NAT_1, NAT_D, LATTICES, BINOP_1, RELAT_1, FUNCT_1,
      XXREAL_0;
 constructors PARTFUN1, BINOP_1, FINSET_1, XXREAL_0, NAT_D, MEMBERED, REALSET1,
      LATTICES;
 registrations XBOOLE_0, ORDINAL1, RELSET_1, FINSET_1, XREAL_0, MEMBERED,
      STRUCT_0, LATTICES;
 requirements REAL, NUMERALS, SUBSET, BOOLE;


begin :: Auxiliary Theorems

reserve n,m for Nat;

definition
  canceled 2;
  func hcflat-> BinOp of NAT means
:: NAT_LAT:def 3

  it.(m,n)=m hcf n;
  func lcmlat -> BinOp of NAT means
:: NAT_LAT:def 4

  it.(m,n)=m lcm n;
end;

definition
  func Nat_Lattice -> strict non empty LattStr equals
:: NAT_LAT:def 5
  LattStr(# NAT, lcmlat, hcflat #);
end;

registration
  cluster -> natural Element of Nat_Lattice;
end;

reserve p,q,r for Element of Nat_Lattice;

registration
  let p,q;
  identify p"\/"q with p lcm q;
  identify p"/\"q with p hcf q;
end;

canceled 47;

theorem :: NAT_LAT:48
  p"\/"q =p lcm q;

theorem :: NAT_LAT:49
  p"/\"q = p hcf q;

canceled 2;

theorem :: NAT_LAT:52
  for a,b being Element of Nat_Lattice st a[=b holds a divides b;

definition
  func 0_NN -> Element of Nat_Lattice equals
:: NAT_LAT:def 6

  1;
  func 1_NN -> Element of Nat_Lattice equals
:: NAT_LAT:def 7

  0;
end;

canceled 2;

theorem :: NAT_LAT:55
  0_NN=1;

registration
  cluster Nat_Lattice -> Lattice-like;
end;

registration
  cluster Nat_Lattice -> strict;
end;

reserve p,q,r for Element of Nat_Lattice;

registration
  cluster Nat_Lattice -> lower-bounded;
end;

canceled 5;

theorem :: NAT_LAT:61
  lcmlat.(p,q)=lcmlat.(q,p);

theorem :: NAT_LAT:62
  hcflat.(q,p)=hcflat.(p,q);

theorem :: NAT_LAT:63
  lcmlat.(p,lcmlat.(q,r)) = lcmlat.(lcmlat.(p,q),r);

theorem :: NAT_LAT:64
  lcmlat.(p,lcmlat.(q,r)) = lcmlat.(lcmlat.(q,p),r) &
  lcmlat.(p,lcmlat.(q,r)) = lcmlat.(lcmlat.(p,r),q) &
  lcmlat.(p,lcmlat.(q,r)) = lcmlat.(lcmlat.(r,q),p) &
  lcmlat.(p,lcmlat.(q,r)) = lcmlat.(lcmlat.(r,p),q);

theorem :: NAT_LAT:65
  hcflat.(p,hcflat.(q,r)) = hcflat.(hcflat.(p,q),r);

theorem :: NAT_LAT:66
  hcflat.(p,hcflat.(q,r)) = hcflat.(hcflat.(q,p),r) &
  hcflat.(p,hcflat.(q,r)) = hcflat.(hcflat.(p,r),q) &
  hcflat.(p,hcflat.(q,r)) = hcflat.(hcflat.(r,q),p) &
  hcflat.(p,hcflat.(q,r)) = hcflat.(hcflat.(r,p),q);

theorem :: NAT_LAT:67
  hcflat.(q,lcmlat.(q,p))=q & hcflat.(lcmlat.(p,q),q)=q &
  hcflat.(q,lcmlat.(p,q))=q & hcflat.(lcmlat.(q,p),q)=q;

theorem :: NAT_LAT:68
  lcmlat.(q,hcflat.(q,p))=q & lcmlat.(hcflat.(p,q),q)=q &
  lcmlat.(q,hcflat.(p,q))=q & lcmlat.(hcflat.(q,p),q)=q;

:: NATPLUS

definition
  canceled;
  func NATPLUS -> Subset of NAT means
:: NAT_LAT:def 9

  for n being Nat holds n in it iff 0 < n;
end;

registration
  cluster NATPLUS -> non empty;
end;

definition
  let D be non empty set, S be non empty Subset of D,
  N be non empty Subset of S;
  redefine mode Element of N -> Element of S;
end;

registration
  let D be Subset of REAL;
  cluster -> real Element of D;
end;

registration
  let D be Subset of NAT;
  cluster -> real Element of D;
end;

definition
  mode NatPlus is Element of NATPLUS;
end;

:: LATTICE of NATURAL NUMBERS > 0

definition
  let k be Nat such that
 k>0;
  func @k->Element of NATPLUS equals
:: NAT_LAT:def 10

  k;
end;

definition
  let k be Element of NATPLUS;
  func @k -> NatPlus equals
:: NAT_LAT:def 11

  k;
end;

registration
  cluster -> natural non zero Element of NATPLUS;
end;

reserve m,n for NatPlus;

definition
  func hcflatplus -> BinOp of NATPLUS means
:: NAT_LAT:def 12

  it.(m,n) = m hcf n;
  func lcmlatplus-> BinOp of NATPLUS means
:: NAT_LAT:def 13

  it.(m,n)=m lcm n;
end;

definition
  func NatPlus_Lattice -> strict LattStr equals
:: NAT_LAT:def 14
  LattStr (# NATPLUS, lcmlatplus, hcflatplus #);
end;

registration
  cluster NatPlus_Lattice -> non empty;
end;

definition
  let m be Element of NatPlus_Lattice;
  func @m -> NatPlus equals
:: NAT_LAT:def 15

  m;
end;

registration
  cluster -> natural non zero Element of NatPlus_Lattice;
end;

reserve p,q for Element of NatPlus_Lattice;

registration
  let p,q be Element of NatPlus_Lattice;
  identify p"\/"q with p lcm q;
  identify p"/\"q with p hcf q;
end;

theorem :: NAT_LAT:69
  p"\/"q =@p lcm @q;

theorem :: NAT_LAT:70
  p"/\"q = @p hcf @q;

registration
  cluster NatPlus_Lattice -> join-commutative join-associative
    meet-commutative meet-associative join-absorbing meet-absorbing;
end;

definition
  let L be Lattice;
  mode SubLattice of L -> Lattice means
:: NAT_LAT:def 16

    the carrier of it c= the carrier of L &
    the L_join of it = (the L_join of L)||the carrier of it &
    the L_meet of it = (the L_meet of L)||the carrier of it;
end;

registration
  let L be Lattice;
  cluster strict SubLattice of L;
end;

canceled 4;

theorem :: NAT_LAT:75
  for L being Lattice holds L is SubLattice of L;

theorem :: NAT_LAT:76
  NatPlus_Lattice is SubLattice of Nat_Lattice;

