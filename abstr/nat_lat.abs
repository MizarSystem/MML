:: The Lattice of Natural Numbers and The Sublattice of it.
:: The Set of Prime Numbers
::  by Marek Chmur
::
:: Received April 26, 1991
:: Copyright (c) 1991 Association of Mizar Users

environ

 vocabularies ARYTM_3, QC_LANG1, BINOP_1, FUNCT_1, LATTICES, ARYTM, RELAT_1,
      BOOLE, NAT_LAT;
 notations TARSKI, XBOOLE_0, ZFMISC_1, SUBSET_1, NUMBERS, XREAL_0, STRUCT_0,
      NAT_1, LATTICES, BINOP_1, RELAT_1, FUNCT_1;
 constructors NAT_1, LATTICES, BINOP_1, NEWTON, PARTFUN1, MEMBERED;
 registrations FINSET_1, STRUCT_0, RELSET_1, LATTICES, NAT_1, MEMBERED,
      ORDINAL2;
 requirements REAL, NUMERALS, SUBSET, BOOLE;
 definitions LATTICES;
 theorems NEWTON, ZFMISC_1, LATTICES, BINOP_1, FUNCT_1, FUNCT_2, XBOOLE_1,
      RELAT_1;
 schemes BINOP_1, BINOP_2, SUBSET_1;

begin :: Auxiliary Theorems

reserve n,m,l,k,i,j,s,r,t for Nat;

definition
 canceled 2;

 func hcflat-> BinOp of NAT means
:: NAT_LAT:def 3
  it.(m,n)=m hcf n;

 func lcmlat-> BinOp of NAT means
:: NAT_LAT:def 4
  it.(m,n)=m lcm n;
end;

reserve p,q,r for Element of LattStr (# NAT, lcmlat, hcflat #);

definition
 let m be Element of LattStr (# NAT, lcmlat, hcflat #);
 func @m -> Nat equals
:: NAT_LAT:def 5
  m;
 end;

canceled 47;

theorem :: NAT_LAT:48
 p"\/"q =@p lcm @q;

theorem :: NAT_LAT:49
 p"/\"q = @p hcf @q;

canceled 2;

theorem :: NAT_LAT:52
    for a,b being Element of LattStr (# NAT, lcmlat, hcflat #)
           holds a[=b implies @a divides @b;

definition
 func 0_NN -> Element of LattStr (# NAT, lcmlat, hcflat #)
  equals
:: NAT_LAT:def 6
  1;

 func 1_NN -> Element of LattStr (# NAT, lcmlat, hcflat #)
  equals
:: NAT_LAT:def 7
0;
 end;

canceled 2;

theorem :: NAT_LAT:55
  @0_NN=1;

theorem :: NAT_LAT:56
 for a being Element of LattStr (# NAT, lcmlat, hcflat #) holds
                0_NN"/\"a = 0_NN & a"/\"0_NN = 0_NN;

definition
 func Nat_Lattice -> Lattice equals
:: NAT_LAT:def 8
  LattStr (# NAT, lcmlat, hcflat #);
end;

registration
 cluster Nat_Lattice -> strict;
end;

reserve p,q,r for Element of Nat_Lattice;

canceled 3;

theorem :: NAT_LAT:60
     Nat_Lattice is 0_Lattice;

theorem :: NAT_LAT:61
  lcmlat.(p,q)=lcmlat.(q,p);

theorem :: NAT_LAT:62
  hcflat.(q,p)=hcflat.(p,q);

theorem :: NAT_LAT:63
  lcmlat.(p,lcmlat.(q,r)) = lcmlat.(lcmlat.(p,q),r);

theorem :: NAT_LAT:64
     lcmlat.(p,lcmlat.(q,r)) = lcmlat.(lcmlat.(q,p),r) &
  lcmlat.(p,lcmlat.(q,r)) = lcmlat.(lcmlat.(p,r),q) &
  lcmlat.(p,lcmlat.(q,r)) = lcmlat.(lcmlat.(r,q),p) &
  lcmlat.(p,lcmlat.(q,r)) = lcmlat.(lcmlat.(r,p),q);

theorem :: NAT_LAT:65
  hcflat.(p,hcflat.(q,r)) = hcflat.(hcflat.(p,q),r);

theorem :: NAT_LAT:66
     hcflat.(p,hcflat.(q,r)) = hcflat.(hcflat.(q,p),r) &
  hcflat.(p,hcflat.(q,r)) = hcflat.(hcflat.(p,r),q) &
  hcflat.(p,hcflat.(q,r)) = hcflat.(hcflat.(r,q),p) &
  hcflat.(p,hcflat.(q,r)) = hcflat.(hcflat.(r,p),q);

theorem :: NAT_LAT:67
     hcflat.(q,lcmlat.(q,p))=q & hcflat.(lcmlat.(p,q),q)=q &
  hcflat.(q,lcmlat.(p,q))=q & hcflat.(lcmlat.(q,p),q)=q;

theorem :: NAT_LAT:68
     lcmlat.(q,hcflat.(q,p))=q & lcmlat.(hcflat.(p,q),q)=q &
  lcmlat.(q,hcflat.(p,q))=q & lcmlat.(hcflat.(q,p),q)=q;

:: NATPLUS

definition
  func NATPLUS -> Subset of NAT means
:: NAT_LAT:def 9
 for n being Nat holds n in it iff 0 < n;
end;

registration
  cluster NATPLUS -> non empty;
  end;

definition let D be non empty set, S be non empty Subset of D,
               N be non empty Subset of S;
redefine mode Element of N -> Element of S;
end;

registration let D be Subset of REAL;
  cluster -> real Element of D;
end;

registration let D be Subset of NAT;
  cluster -> real Element of D;
end;

definition
  mode NatPlus is Element of NATPLUS;
end;

:: LATTICE of NATURAL NUMBERS > 0

definition
 let k be Nat such that
  k>0;
 func @k->Element of NATPLUS equals
:: NAT_LAT:def 10
  k;
end;

definition
 let k be Element of NATPLUS;
 func @k -> NatPlus equals
:: NAT_LAT:def 11
  k;
 end;

reserve m,n for NatPlus;

definition
 func hcflatplus -> BinOp of NATPLUS means
:: NAT_LAT:def 12
  it.(m,n) = m hcf n;

 func lcmlatplus-> BinOp of NATPLUS means
:: NAT_LAT:def 13
  it.(m,n)=m lcm n;
end;

reserve p,q,r for Element of LattStr
                            (# NATPLUS, lcmlatplus, hcflatplus #);

definition
 let m be Element of LattStr
                            (# NATPLUS, lcmlatplus, hcflatplus #);
 func @m->NatPlus equals
:: NAT_LAT:def 14
  m;
 end;

theorem :: NAT_LAT:69
 p"\/"q =@p lcm @q;

theorem :: NAT_LAT:70
 p"/\"q = @p hcf @q;

definition
 func NatPlus_Lattice -> Lattice equals
:: NAT_LAT:def 15
  LattStr (# NATPLUS, lcmlatplus, hcflatplus #);
end;

registration
 cluster NatPlus_Lattice -> strict;
end;

reserve x,y1,y2 for set;

definition let L be Lattice;
 mode SubLattice of L -> Lattice means
:: NAT_LAT:def 16
  the carrier of it c= the carrier of L &
   the L_join of it = (the L_join of L) | [:the carrier of it,
   the carrier of it:] &
   the L_meet of it = (the L_meet of L) | [:the carrier of it,
   the carrier of it:];
end;

registration let L be Lattice;
 cluster strict SubLattice of L;
end;

canceled 4;

theorem :: NAT_LAT:75
   for L being Lattice holds L is SubLattice of L;

theorem :: NAT_LAT:76
   NatPlus_Lattice is SubLattice of Nat_Lattice;

