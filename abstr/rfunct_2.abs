:: Properties of Real Functions
::  by Jaros{\l}aw Kotowicz
::
:: Received June 18, 1990
:: Copyright (c) 1990 Association of Mizar Users

environ

 vocabularies SEQ_1, ORDINAL2, SEQM_3, PARTFUN1, FUNCT_1, RELAT_1, BOOLE,
      ARYTM_1, ABSVALUE, SEQ_2, ARYTM, FINSEQ_1, LATTICES, SEQ_4, RCOMP_1,
      ANPROJ_1, PROB_1, REALSET1, OPPCAT_1, SUPINF_1;
 notations TARSKI, XBOOLE_0, SUBSET_1, ORDINAL1, NUMBERS, XREAL_0, COMPLEX1,
      REAL_1, NAT_1, RELAT_1, FUNCT_1, FUNCT_2, REALSET1, RELSET_1, PARTFUN1,
      VALUED_0, VALUED_1, SEQ_1, SEQ_2, SEQ_4, PARTFUN2, RCOMP_1, RFUNCT_1,
      SEQM_3, XXREAL_0, XXREAL_2, RECDEF_1;
 constructors PARTFUN1, REAL_1, NAT_1, COMPLEX1, SEQ_2, SEQM_3, SEQ_4, RCOMP_1,
      PARTFUN2, RFUNCT_1, VALUED_1, SEQ_1, RECDEF_1, XXREAL_2, REALSET1;
 registrations XBOOLE_0, FUNCT_1, ORDINAL1, RELSET_1, NUMBERS, XREAL_0,
      MEMBERED, SEQM_3, VALUED_0, VALUED_1, FUNCT_2, RELAT_1, REALSET1,
      PARTFUN1;
 requirements REAL, NUMERALS, SUBSET, BOOLE, ARITHM;


begin

reserve x,y,X,X1,Y for set;
reserve g,r,r1,r2,p,p1,p2 for Element of REAL;
reserve R for Subset of REAL;
reserve seq,seq1,seq2,seq3 for Real_Sequence;
reserve Ns for increasing Seq_of_Nat;
reserve n,m for Element of NAT;
reserve h,h1,h2 for PartFunc of REAL,REAL;

canceled  5;

::
:: REAL SEQUENCES
::

theorem :: RFUNCT_2:6
  seq1=seq2-seq3 iff for n holds seq1.n=seq2.n-seq3.n;

canceled 6;

theorem :: RFUNCT_2:13
  (seq1 + seq2)*Ns = (seq1*Ns) + (seq2*Ns) &
  (seq1 - seq2)*Ns = (seq1*Ns) - (seq2*Ns) &
  (seq1 (#) seq2)*Ns = (seq1*Ns) (#) (seq2*Ns);

theorem :: RFUNCT_2:14
  (p(#)seq)*Ns = p(#)(seq*Ns);

theorem :: RFUNCT_2:15
  (-seq)*Ns = -(seq*Ns) & (abs(seq))*Ns = abs((seq*Ns));

theorem :: RFUNCT_2:16
  (seq*Ns)" = (seq")*Ns;

theorem :: RFUNCT_2:17
  (seq1/"seq)*Ns = (seq1*Ns)/"(seq*Ns);

theorem :: RFUNCT_2:18
  seq is convergent & (for n holds seq.n<=0) implies lim seq <= 0;

canceled 4;

theorem :: RFUNCT_2:23
  rng seq c= dom h1 /\ dom h2 implies (h1+h2)/*seq=h1/*seq+h2/*seq &
  (h1-h2)/*seq=h1/*seq-h2/*seq & (h1(#)h2)/*seq=(h1/*seq)(#)(h2/*seq);

theorem :: RFUNCT_2:24
  for r being real number holds rng seq c= dom h implies (r(#)h)/*seq = r(#)
  (h/*seq);

theorem :: RFUNCT_2:25
  rng seq c= dom h implies abs(h/*seq) = (abs(h))/*seq & -(h/*seq) = (-h)/*seq;

theorem :: RFUNCT_2:26
  rng seq c= dom (h^) implies h/*seq is non-zero;

theorem :: RFUNCT_2:27
  rng seq c= dom (h^) implies (h^)/*seq =(h/*seq)";

canceled 4;

theorem :: RFUNCT_2:32
  h1 is total & h2 is total implies (h1+h2)/*seq = h1/*seq + h2/*seq &
  (h1-h2)/*seq = h1/*seq - h2/*seq & (h1(#)h2)/*seq = (h1/*seq) (#) (h2/*seq);

theorem :: RFUNCT_2:33
  h is total implies (r(#)h)/*seq = r(#)(h/*seq);

canceled 2;

theorem :: RFUNCT_2:36
  rng seq c= dom (h|X) implies abs((h|X)/*seq) = ((abs(h))|X)/*seq;

theorem :: RFUNCT_2:37
  rng seq c= dom (h|X) & h"{0}={} implies ((h^)|X)/*seq = ((h|X)/*seq)";

::
:: MONOTONE FUNCTIONS
::

registration
  let Z be set;
  let f be one-to-one Function;
  cluster f|Z -> one-to-one;
end;

canceled 2;

theorem :: RFUNCT_2:40
  for h being one-to-one Function holds (h|X)" = (h")|(h.:X);

theorem :: RFUNCT_2:41
  rng h is bounded & upper_bound (rng h) = lower_bound (rng h) implies
  h is constant;

theorem :: RFUNCT_2:42
  Y c= dom h & h.:Y is bounded & upper_bound(h.:Y) = lower_bound(h.:Y)
  implies h|Y is constant;

reserve e1,e2 for ext-real number;

definition
 canceled;
 redefine
  let h;
  attr h is increasing means
:: RFUNCT_2:def 2
  for r1,r2 st r1 in dom h & r2 in dom h & r1<r2 holds h.r1 < h.r2;
  attr h is decreasing means
:: RFUNCT_2:def 3
  for r1,r2 st r1 in dom h & r2 in dom h & r1<r2 holds h.r2 < h.r1;
  attr h is non-decreasing means
:: RFUNCT_2:def 4
  for r1,r2 st r1 in dom h & r2 in dom h & r1<r2 holds h.r1 <= h.r2;
  attr h is non-increasing means
:: RFUNCT_2:def 5
  for r1,r2 st r1 in dom h & r2 in dom h & r1<r2 holds h.r2 <= h.r1;
end;

theorem :: RFUNCT_2:43
  h|Y is increasing iff
  for r1,r2 st r1 in Y /\ dom h & r2 in Y /\ dom h & r1<r2 holds
   h.r1 < h.r2;

theorem :: RFUNCT_2:44
 h|Y is decreasing iff
  for r1,r2 st r1 in Y /\ dom h & r2 in Y /\ dom h & r1<r2
   holds h.r2 < h.r1;

theorem :: RFUNCT_2:45
 h|Y is non-decreasing iff
  for r1,r2 st r1 in Y /\ dom h & r2 in Y /\ dom h & r1<r2
   holds h.r1 <= h.r2;

theorem :: RFUNCT_2:46
 h|Y is non-increasing iff
  for r1,r2 st r1 in Y /\ dom h & r2 in Y /\ dom h & r1<r2
   holds h.r2 <= h.r1;

definition
  let h;
  attr h is monotone means
:: RFUNCT_2:def 6

  h is non-decreasing or h is non-increasing;
end;

registration
 cluster non-decreasing -> monotone PartFunc of REAL,REAL;
 cluster non-increasing -> monotone PartFunc of REAL,REAL;
 cluster non monotone ->
  non non-decreasing non non-increasing PartFunc of REAL,REAL;
end;

canceled;

theorem :: RFUNCT_2:48

h|Y is non-decreasing iff for r1,r2 st r1 in Y /\ dom h & r2 in Y /\ dom h &
  r1<=r2 holds h.r1 <= h.r2;

theorem :: RFUNCT_2:49

h|Y is non-increasing iff for r1,r2 st r1 in Y /\ dom h & r2 in Y /\ dom h &
  r1<=r2 holds h.r2 <= h.r1;

registration
 cluster non-decreasing non-increasing -> constant PartFunc of REAL,REAL;
end;

registration
 cluster constant -> non-increasing non-decreasing PartFunc of REAL,REAL;
end;

registration
 cluster trivial PartFunc of REAL,REAL;
end;

registration let h be increasing PartFunc of REAL,REAL, X be set;
 cluster h|X -> increasing PartFunc of REAL,REAL;
end;

registration let h be decreasing PartFunc of REAL,REAL, X be set;
 cluster h|X -> decreasing PartFunc of REAL,REAL;
end;

registration let h be non-decreasing PartFunc of REAL,REAL, X be set;
 cluster h|X -> non-decreasing PartFunc of REAL,REAL;
end;

canceled 4;

theorem :: RFUNCT_2:54
  Y misses dom h implies h|Y is increasing & h|Y is decreasing &
  h|Y is non-decreasing & h|Y is non-increasing & h|Y is monotone;

canceled 4;

theorem :: RFUNCT_2:59
  h|Y is non-decreasing & h|X is non-increasing implies
  h|(Y /\ X) is constant;

theorem :: RFUNCT_2:60
  X c= Y & h|Y is increasing implies h|X is increasing;

theorem :: RFUNCT_2:61
  X c= Y & h|Y is decreasing implies h|X is decreasing;

theorem :: RFUNCT_2:62
  X c= Y & h|Y is non-decreasing implies h|X is non-decreasing;

theorem :: RFUNCT_2:63
  X c= Y & h|Y is non-increasing implies h|X is non-increasing;

theorem :: RFUNCT_2:64
  (h|Y is increasing & 0<r implies (r(#)h)|Y is increasing) &
  (r = 0 implies (r(#)h)|Y is constant) &
  (h|Y is increasing & r<0 implies (r(#)h)|Y is decreasing);

theorem :: RFUNCT_2:65
  (h|Y is decreasing & 0<r implies (r(#)h)|Y is decreasing) &
  (h|Y is decreasing & r<0 implies (r(#)h)|Y is increasing);

theorem :: RFUNCT_2:66
  (h|Y is non-decreasing & 0<=r implies (r(#)h)|Y is non-decreasing) &
  (h|Y is non-decreasing & r<=0 implies (r(#)h)|Y is non-increasing);

theorem :: RFUNCT_2:67
  (h|Y is non-increasing & 0<=r implies (r(#)h)|Y is non-increasing) &
  (h|Y is non-increasing & r<=0 implies (r(#)h)|Y is non-decreasing);

theorem :: RFUNCT_2:68
  r in X /\ Y /\ dom (h1+h2) implies r in X /\ dom h1 & r in Y /\ dom h2;

theorem :: RFUNCT_2:69
  (h1|X is increasing & h2|Y is increasing implies
  (h1+h2)|(X /\ Y) is increasing) &
  (h1|X is decreasing & h2|Y is decreasing implies
  (h1+h2)|(X /\ Y) is decreasing) &
  (h1|X is non-decreasing & h2|Y is non-decreasing implies
  (h1+h2)|(X /\ Y) is non-decreasing) &
  (h1|X is non-increasing & h2|Y is non-increasing implies
  (h1+h2)|(X /\ Y) is non-increasing);

theorem :: RFUNCT_2:70
  (h1|X is increasing & h2|Y is constant implies
  (h1+h2)|(X /\ Y) is increasing) &
  (h1|X is decreasing & h2|Y is constant implies
  (h1+h2)|(X /\ Y) is decreasing);

theorem :: RFUNCT_2:71
  h1|X is increasing & h2|Y is non-decreasing implies
  (h1+h2)|(X /\ Y) is increasing;

theorem :: RFUNCT_2:72
  h1|X is non-increasing & h2|Y is constant implies
  (h1+h2)|(X /\ Y) is non-increasing;

theorem :: RFUNCT_2:73
  h1|X is decreasing & h2|Y is non-increasing implies
  (h1+h2)|(X /\ Y) is decreasing;

theorem :: RFUNCT_2:74
  h1|X is non-decreasing & h2|Y is constant implies
  (h1+h2)|(X /\ Y) is non-decreasing;

theorem :: RFUNCT_2:75
  h|{x} is non-increasing;

theorem :: RFUNCT_2:76
  h|{x} is decreasing;

theorem :: RFUNCT_2:77
  h|{x} is non-decreasing;

theorem :: RFUNCT_2:78
  h|{x} is non-increasing;

theorem :: RFUNCT_2:79
  (id R)|R is increasing;

theorem :: RFUNCT_2:80
  h|X is increasing implies (-h)|X is decreasing;

theorem :: RFUNCT_2:81
  h|X is non-decreasing implies (-h)|X is non-increasing;

theorem :: RFUNCT_2:82
  (h|[.p,g.] is increasing or h|[.p,g.] is decreasing)
  implies h|[.p,g.] is one-to-one;

theorem :: RFUNCT_2:83
  for h being one-to-one PartFunc of REAL, REAL st h|[.p,g.] is increasing
  holds (h|[.p,g.])"|(h.:[.p,g.]) is increasing;

theorem :: RFUNCT_2:84
  for h being one-to-one PartFunc of REAL, REAL st h|[.p,g.] is decreasing
  holds (h|[.p,g.])"|(h.:[.p,g.]) is decreasing;

