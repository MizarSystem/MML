:: Free Many Sorted Universal Algebra
::  by Beata Perkowska
::
:: Received April 27, 1994
:: Copyright (c) 1994 Association of Mizar Users

environ

 vocabulary FUNCT_1, PBOOLE, TDGROUP, CARD_3, RELAT_1, MSUALG_2, PRALG_1,
      REALSET1, BOOLE, ZF_REFLE, PROB_1, TARSKI, AMI_1, MSUALG_1, FREEALG,
      PRELAMB, ALG_1, FINSEQ_1, QC_LANG1, LANG1, DTCONSTR, TREES_4, TREES_2,
      TREES_3, FUNCT_6, MCART_1, UNIALG_2, GROUP_6, MSUALG_3, MSAFREE,
      FINSEQ_4;
 notation TARSKI, XBOOLE_0, ZFMISC_1, SUBSET_1, XREAL_0, NAT_1, RELAT_1,
      RELSET_1, STRUCT_0, FUNCT_1, MCART_1, FUNCT_2, FINSEQ_1, FINSEQ_2,
      TREES_2, PROB_1, CARD_3, FINSEQ_4, LANG1, TREES_3, FUNCT_6, TREES_4,
      DTCONSTR, PBOOLE, PRALG_1, MSUALG_1, MSUALG_2, MSUALG_3;
 constructors NAT_1, MCART_1, MSUALG_3, FINSOP_1, FINSEQ_4, FINSEQOP, PROB_1,
      MEMBERED, XBOOLE_0;
 clusters SUBSET_1, FUNCT_1, FINSEQ_1, PBOOLE, TREES_3, TREES_4, DTCONSTR,
      PRALG_1, MSUALG_1, MSUALG_3, RELSET_1, STRUCT_0, XBOOLE_0, ARYTM_3,
      MEMBERED, ZFMISC_1, NUMBERS, ORDINAL2;
 requirements NUMERALS, BOOLE, SUBSET;


begin

::
:: Preliminaries
::

theorem :: MSAFREE:1
for I be set, J be non empty set, f be Function of I,J*,
    X be ManySortedSet of J, p be Element of J*, x be set
st x in I & p = f.x holds (X# * f).x = product (X * p);

definition
 let I be set,
     A,B be ManySortedSet of I,
     C be ManySortedSubset of A,
     F be ManySortedFunction of A,B;
func F || C -> ManySortedFunction of C,B means
:: MSAFREE:def 1
for i be set st i in I
 for f be Function of A.i,B.i st f = F.i holds it.i = f | (C.i);
end;


definition let I be set,
               X be ManySortedSet of I,
               i be set;
 assume  i in I;
func coprod(i,X) -> set means
:: MSAFREE:def 2
for x be set holds x in it iff ex a be set st a in X.i & x = [a,i];
end;


notation let I be set,
               X be ManySortedSet of I;
 synonym coprod X for disjoin X ;
end;
definition let I be set,
               X be ManySortedSet of I;
 redefine func coprod X -> ManySortedSet of I means
:: MSAFREE:def 3
   for i be set st i in I holds it.i = coprod(i,X);
 end;


registration
 let I be non empty set,
     X be non-empty ManySortedSet of I;
 cluster coprod X -> non-empty;
coherence
 proof
     now
    let x be set;
    assume x in I;
    then reconsider i = x as Element of I;
    A1: (coprod X).i = coprod(i,X) by Def3;
    consider a be set such that
    A2: a in X.i by XBOOLE_0:def 1;
      [a,i] in (coprod X).i by A1,A2,Def2;
    hence (coprod X).x is non empty;
   end;
  hence thesis by PBOOLE:def 16;
 end;
end;


registration
 let I be non empty set,
     X be non-empty ManySortedSet of I;
 cluster Union X -> non empty;
coherence
 proof
  consider i be Element of I;
  consider a be set such that
  A1: a in X.i by XBOOLE_0:def 1;
    dom X = I by PBOOLE:def 3;
  then X.i in rng X by FUNCT_1:def 5;
  then a in union rng X by A1,TARSKI:def 4;
  hence thesis by PROB_1:def 3;
 end;
end;


theorem :: MSAFREE:2
  for I be set, X be ManySortedSet of I, i be set st i in I holds
X.i <> {} iff (coprod X).i <> {};

begin
::
:: Free Many Sorted Universal Algebra - General Notions
::

reserve S for non void non empty ManySortedSign,
        U0 for MSAlgebra over S;

definition
 let S be non void non empty ManySortedSign,
     U0 be MSAlgebra over S;
mode GeneratorSet of U0 -> MSSubset of U0 means
:: MSAFREE:def 4
the Sorts of GenMSAlg(it) = the Sorts of U0;
end;


theorem :: MSAFREE:3
  for S be non void non empty ManySortedSign,
    U0 be strict non-empty MSAlgebra over S,
    A be MSSubset of U0 holds
          A is GeneratorSet of U0 iff GenMSAlg(A) = U0;

definition
 let S,U0;
 let IT be GeneratorSet of U0;
attr IT is free means
:: MSAFREE:def 5
for U1 be non-empty MSAlgebra over S
 for f be ManySortedFunction of IT,the Sorts of U1
  ex h be ManySortedFunction of U0,U1
                  st h is_homomorphism U0,U1 & h || IT = f;
end;


definition
 let S be non void non empty ManySortedSign;
 let IT be MSAlgebra over S;
attr IT is free means
:: MSAFREE:def 6
 ex G being GeneratorSet of IT st G is free;
end;


theorem :: MSAFREE:4
for S be non void non empty ManySortedSign,
    X be ManySortedSet of the carrier of S
holds Union coprod X misses [:the OperSymbols of S,{the carrier of S}:];

begin
::
:: Construction of Free Many Sorted Algebras for Given Signature
::

registration
 let S be non void ManySortedSign;
 cluster the OperSymbols of S -> non empty;
 coherence by MSUALG_1:def 5;
end;


definition
 let S be non void non empty ManySortedSign,
     X be ManySortedSet of the carrier of S;
 canceled 2;

func REL(X) -> Relation of
   ([:the OperSymbols of S,{the carrier of S}:] \/ Union (coprod X)),
   (([:the OperSymbols of S,{the carrier of S}:] \/ Union (coprod X))*) means
:: MSAFREE:def 9

for a be Element of
        [:the OperSymbols of S,{the carrier of S}:] \/ Union (coprod X),
    b be Element of
       ([:the OperSymbols of S,{the carrier of S}:] \/ Union (coprod X))*
 holds
 [a,b] in it iff
  a in [:the OperSymbols of S,{the carrier of S}:] &
  for o be OperSymbol of S st [o,the carrier of S] = a holds
   len b = len (the_arity_of o) &
   for x be set st x in dom b holds
    (b.x in [:the OperSymbols of S,{the carrier of S}:] implies
    for o1 be OperSymbol of S st [o1,the carrier of S] = b.x
      holds the_result_sort_of o1 = (the_arity_of o).x) &
    (b.x in Union (coprod X) implies b.x in coprod((the_arity_of o).x,X));
end;


reserve S for non void non empty ManySortedSign,
         X for ManySortedSet of the carrier of S,
         o for OperSymbol of S,
         b for Element of
            ([:the OperSymbols of S,{the carrier of S}:] \/ Union (coprod X))*
;

theorem :: MSAFREE:5
               [[o,the carrier of S],b] in REL(X)
                            iff
   len b = len (the_arity_of o) &
   for x be set st x in dom b holds
    (b.x in [:the OperSymbols of S,{the carrier of S}:] implies
     for o1 be OperSymbol of S st [o1,the carrier of S] = b.x
    holds the_result_sort_of o1 = (the_arity_of o).x) &
    (b.x in Union (coprod X) implies b.x in coprod((the_arity_of o).x,X));

definition
 let S be non void non empty ManySortedSign,
     X be ManySortedSet of the carrier of S;
func DTConMSA(X) -> DTConstrStr equals
:: MSAFREE:def 10
 DTConstrStr (# [:the OperSymbols of S,{the carrier of S}:]
                   \/ Union (coprod X), REL(X) #);
end;


registration
 let S be non void non empty ManySortedSign,
     X be ManySortedSet of the carrier of S;
 cluster DTConMSA(X) -> strict non empty;
 coherence
  proof
      DTConMSA(X) = DTConstrStr (# [:the OperSymbols of S,{the carrier of S}:]
                   \/ Union (coprod X), REL(X) #) by Def10;
   hence DTConMSA X is strict & the carrier of DTConMSA(X) is non empty;
  end;
end;


theorem :: MSAFREE:6
for S be non void non empty ManySortedSign,
    X be non-empty ManySortedSet of the carrier of S holds
NonTerminals(DTConMSA(X)) = [:the OperSymbols of S,{the carrier of S}:] &
Terminals (DTConMSA(X)) = Union (coprod X);

reserve x for set;

registration
 let S be non void non empty ManySortedSign,
     X be non-empty ManySortedSet of the carrier of S;
cluster DTConMSA(X) -> with_terminals with_nonterminals
   with_useful_nonterminals;
 coherence
  proof
   set D = DTConMSA(X),
       A = [:the OperSymbols of S,{the carrier of S}:] \/
            Union (coprod (X qua ManySortedSet of the carrier of S));
   A1: Union (coprod X) misses [:the OperSymbols of S,{the carrier of S}:]
        by Th4;
   A2: Terminals D = Union (coprod X) &
       NonTerminals D = [:the OperSymbols of S,{the carrier of S}:] by Th6;
   A3: D = DTConstrStr (# A , REL(X) #) by Def10;
    for nt being Symbol of D st nt in NonTerminals D
   ex p being FinSequence of TS(D) st nt ==> roots p
   proof
    let nt be Symbol of D;
    assume nt in NonTerminals D;
     then consider o being OperSymbol of S, x2 being Element of {the carrier of
S}
     such that
A4:   nt = [o,x2] by A2,DOMAIN_1:9;
A5:   the carrier of S = x2 by TARSKI:def 1;
    set O = the_arity_of o;
    defpred P[set,set] means $2 in coprod(O.$1,X);
    A6: for a be set st a in Seg len O ex b be set st P[a,b]
     proof
      let a be set; assume
        a in Seg len O;
      then a in dom O by FINSEQ_1:def 3;
      then A7: O.a in
 rng O & rng O c= the carrier of S by FINSEQ_1:def 4,FUNCT_1:def 5;
      then X.(O.a) is non empty by PBOOLE:def 16;
      then consider x be set such that
      A8: x in X.(O.a) by XBOOLE_0:def 1;
      take y = [x,O.a];
      thus y in coprod(O.a,X) by A7,A8,Def2;
     end;
    consider b be Function such that
    A9: dom b = Seg len O &
    for a be set st a in Seg len O holds P[a,b.a] from ZFREFLE1:sch 1(A6);
    reconsider b as FinSequence by A9,FINSEQ_1:def 2;
    A10: rng b c= A
     proof let a be set; assume a in rng b;
      then consider c be set such that
      A11: c in dom b & b.c = a by FUNCT_1:def 5;
      A12: a in coprod (O.c,X) by A9,A11;
        dom O = Seg len O by FINSEQ_1:def 3;
      then A13: O.c in rng O & rng O c= the carrier of S
                                 by A9,A11,FINSEQ_1:def 4,FUNCT_1:def 5;
        dom coprod(X) = the carrier of S by PBOOLE:def 3;
      then (coprod(X)).(O.c) in rng coprod(X) by A13,FUNCT_1:def 5;
      then coprod(O.c,X) in rng coprod(X) by A13,Def3;
      then a in union rng coprod(X) by A12,TARSKI:def 4;
      then a in Union coprod(X) by PROB_1:def 3;
      hence thesis by XBOOLE_0:def 2;
     end;
    then reconsider b as FinSequence of A by FINSEQ_1:def 4;
    reconsider b as Element of A* by FINSEQ_1:def 11;
    A14: len b = len O by A9,FINSEQ_1:def 3;
       now let c be set;
      assume A15: c in dom b;
      then A16: P[c,b.c] by A9;
        dom O = Seg len O by FINSEQ_1:def 3;
      then A17: O.c in rng O & rng O c= the carrier of S
                               by A9,A15,FINSEQ_1:def 4,FUNCT_1:def 5;
        dom coprod(X) = the carrier of S by PBOOLE:def 3;
      then (coprod(X)).(O.c) in rng coprod(X) by A17,FUNCT_1:def 5;
      then coprod(O.c,X) in rng coprod(X) by A17,Def3;
      then b.c in union rng coprod(X) by A16,TARSKI:def 4;
       then b.c in Union coprod(X) by PROB_1:def 3;
      hence b.c in [:the OperSymbols of S,{the carrier of S}:] implies
      for o1 be OperSymbol of S st [o1,the carrier of S] = b.c holds
      the_result_sort_of o1 = O.c by A1,XBOOLE_0:3;
      assume b.c in Union (coprod X);
      thus b.c in coprod(O.c,X) by A9,A15;
     end;
     then [nt,b] in REL(X) by A4,A5,A14,Th5;
    then A18: nt ==> b by A3,LANG1:def 1;
    deffunc F(set)=root-tree (b.$1);
    consider f be Function such that
    A19: dom f = dom b & for x st x in dom b holds f.x = F(x)
                                                        from FUNCT_1:sch 3;
    reconsider f as FinSequence by A9,A19,FINSEQ_1:def 2;
      rng f c= TS(D)
     proof
      let x;
      assume x in rng f;
      then consider y be set such that
      A20: y in dom f & f.y = x by FUNCT_1:def 5;
      A21: x = root-tree(b.y) by A19,A20;
        b.y in rng b by A19,A20,FUNCT_1:def 5;
      then reconsider a = b.y as Symbol of D by A3,A10;
      A22: P[y,b.y] by A9,A19,A20;
        dom O = Seg len O by FINSEQ_1:def 3;
      then A23: O.y in rng O & rng O c= the carrier of S
                               by A9,A19,A20,FINSEQ_1:def 4,FUNCT_1:def 5;
        dom coprod(X) = the carrier of S by PBOOLE:def 3;
      then (coprod(X)).(O.y) in rng coprod(X) by A23,FUNCT_1:def 5;
      then coprod(O.y,X) in rng coprod(X) by A23,Def3;
      then b.y in union rng coprod(X) by A22,TARSKI:def 4;
      then a in Terminals D by A2,PROB_1:def 3;
      hence thesis by A21,DTCONSTR:def 4;
     end;
    then reconsider f as FinSequence of TS(D) by FINSEQ_1:def 4;
    take f;
    A24: dom (roots f) = dom f by DTCONSTR:def 1;
      for x st x in dom b holds (roots f).x = b.x
     proof
      let x;
      assume A25: x in dom b;
      then A26: f.x = root-tree (b.x) by A19;
      reconsider i = x as Nat by A25;
      consider T be DecoratedTree such that
      A27: T = f.i & (roots f).i = T.{} by A19,A25,DTCONSTR:def 1;
      thus thesis by A26,A27,TREES_4:3;
     end;
    hence thesis by A18,A19,A24,FUNCT_1:9;
   end;
   hence thesis by A2,DTCONSTR:def 6,def 7,def 8;
  end;
end;


theorem :: MSAFREE:7
for S be non void non empty ManySortedSign,
    X be non-empty ManySortedSet of the carrier of S,
    t be set holds
               t in Terminals DTConMSA(X)
                          iff
 ex s be SortSymbol of S, x be set st x in X.s & t = [x,s];

definition
 let S be non void non empty ManySortedSign,
     X be non-empty ManySortedSet of the carrier of S,
     o be OperSymbol of S;
func Sym(o,X) ->Symbol of DTConMSA(X) equals
:: MSAFREE:def 11
 [o,the carrier of S];
end;


definition
 let S be non void non empty ManySortedSign,
     X be non-empty ManySortedSet of the carrier of S,
     s be SortSymbol of S;
func FreeSort(X,s) -> Subset of TS(DTConMSA(X)) equals
:: MSAFREE:def 12
 {a where a is Element of TS(DTConMSA(X)):
       (ex x be set st x in X.s & a = root-tree [x,s]) or
       ex o be OperSymbol of S st [o,the carrier of S] = a.{}
           & the_result_sort_of o = s};
end;


registration
 let S be non void non empty ManySortedSign,
     X be non-empty ManySortedSet of the carrier of S,
     s be SortSymbol of S;
cluster FreeSort(X,s) -> non empty;
 coherence
  proof
   set A = {a where a is Element of TS(DTConMSA(X)):
            (ex x be set st x in X.s & a = root-tree [x,s]) or
             ex o be OperSymbol of S st [o,the carrier of S] = a.{}
                  & the_result_sort_of o = s};
   consider x be set such that A1: x in X.s by XBOOLE_0:def 1;
   set a = [x,s];
   A2: a in coprod(s,X) by A1,Def2;
   A3: (Terminals (DTConMSA(X))) = Union (coprod X) by Th6;
     dom coprod(X) = the carrier of S by PBOOLE:def 3;
   then (coprod(X)).s in rng coprod(X) by FUNCT_1:def 5;
   then coprod(s,X) in rng coprod(X) by Def3;
   then a in union rng coprod(X) by A2,TARSKI:def 4;
   then A4: a in Terminals (DTConMSA X) by A3,PROB_1:def 3;
   then reconsider a as Symbol of DTConMSA(X);
   reconsider b = root-tree a as Element of TS(DTConMSA X)
                                                  by A4,DTCONSTR:def 4;
     b in A by A1;
   hence thesis by Def12;
  end;
end;


definition
 let S be non void non empty ManySortedSign,
     X be non-empty ManySortedSet of the carrier of S;
func FreeSort(X) -> ManySortedSet of the carrier of S means
:: MSAFREE:def 13
for s be SortSymbol of S holds it.s = FreeSort(X,s);
end;


registration
 let S be non void non empty ManySortedSign,
     X be non-empty ManySortedSet of the carrier of S;
cluster FreeSort(X) -> non-empty;
coherence
  proof
   let i be set;
   assume i in the carrier of S;
   then reconsider s = i as SortSymbol of S;
     (FreeSort(X)).s = FreeSort(X,s) by Def13;
   hence thesis;
  end;
end;


theorem :: MSAFREE:8
for S be non void non empty ManySortedSign,
    X be non-empty ManySortedSet of the carrier of S, o be OperSymbol of S,
    x be set
 st x in ((FreeSort X)# * (the Arity of S)).o holds
    x is FinSequence of TS(DTConMSA(X));

theorem :: MSAFREE:9
for S be non void non empty ManySortedSign,
    X be non-empty ManySortedSet of the carrier of S, o be OperSymbol of S,
    p be FinSequence of TS(DTConMSA(X))
holds p in ((FreeSort X)# * (the Arity of S)).o iff
 dom p = dom (the_arity_of o) &
 for n be Nat st n in dom p holds p.n in FreeSort(X,(the_arity_of o)/.n);

theorem :: MSAFREE:10
for S be non void non empty ManySortedSign,
    X be non-empty ManySortedSet of the carrier of S, o be OperSymbol of S,
    p be FinSequence of TS(DTConMSA(X)) holds
 Sym(o,X) ==> roots p iff p in ((FreeSort X)# * (the Arity of S)).o;

canceled;

theorem :: MSAFREE:12
for S be non void non empty ManySortedSign,
    X be non-empty ManySortedSet of the carrier of S holds
 union rng (FreeSort X) = TS (DTConMSA(X));

theorem :: MSAFREE:13
for S be non void non empty ManySortedSign,
    X be non-empty ManySortedSet of the carrier of S, s1,s2 be SortSymbol of S
 st s1 <> s2 holds (FreeSort X).s1 misses (FreeSort X).s2;

definition
 let S be non void non empty ManySortedSign,
     X be non-empty ManySortedSet of the carrier of S,
     o be OperSymbol of S;
func DenOp(o,X) ->
Function of ((FreeSort X)# * (the Arity of S)).o,
            ((FreeSort X) * (the ResultSort of S)).o means
:: MSAFREE:def 14
for p be FinSequence of TS(DTConMSA(X)) st Sym(o,X) ==> roots p holds
  it.p = (Sym(o,X))-tree p;
end;


definition
 let S be non void non empty ManySortedSign,
     X be non-empty ManySortedSet of the carrier of S;
func FreeOper(X) -> ManySortedFunction of (FreeSort X)# * (the Arity of S),
              (FreeSort X) * (the ResultSort of S) means
:: MSAFREE:def 15
for o be OperSymbol of S holds it.o = DenOp(o,X);
end;


definition
 let S be non void non empty ManySortedSign,
     X be non-empty ManySortedSet of the carrier of S;
func FreeMSA(X) -> MSAlgebra over S equals
:: MSAFREE:def 16
 MSAlgebra (# FreeSort(X), FreeOper(X) #);
end;


registration
 let S be non void non empty ManySortedSign,
     X be non-empty ManySortedSet of the carrier of S;
cluster FreeMSA(X) -> strict non-empty;
 coherence
  proof
   MSAlgebra (# FreeSort(X), FreeOper(X) #) = FreeMSA X by Def16;
    hence thesis by MSUALG_1:def 8;
  end;
end;


definition
 let S be non void non empty ManySortedSign,
     X be non-empty ManySortedSet of the carrier of S,
     s be SortSymbol of S;
func FreeGen(s,X) -> Subset of (FreeSort(X)).s means
:: MSAFREE:def 17
for x be set holds
     x in it iff ex a be set st a in X.s & x = root-tree [a,s];
end;


registration
 let S be non void non empty ManySortedSign,
     X be non-empty ManySortedSet of the carrier of S,
     s be SortSymbol of S;
cluster FreeGen(s,X) -> non empty;
 coherence
  proof
   consider x such that
   A1: x in X.s by XBOOLE_0:def 1;
    ex a be set st a in X.s & root-tree [x,s] = root-tree [a,s] by A1;
   hence thesis by Def17;
  end;
end;


theorem :: MSAFREE:14
for S be non void non empty ManySortedSign,
    X be non-empty ManySortedSet of the carrier of S,
    s be SortSymbol of S holds
FreeGen(s,X) = {root-tree t where t is Symbol of DTConMSA(X):
               t in Terminals DTConMSA(X) & t`2 = s};

definition
 let S be non void non empty ManySortedSign,
     X be non-empty ManySortedSet of the carrier of S;
func FreeGen(X) -> GeneratorSet of FreeMSA(X) means
:: MSAFREE:def 18
for s be SortSymbol of S holds it.s = FreeGen(s,X);
end;


theorem :: MSAFREE:15
  for S be non void non empty ManySortedSign,
    X be non-empty ManySortedSet of the carrier of S
holds FreeGen(X)is non-empty;

theorem :: MSAFREE:16
  for S be non void non empty ManySortedSign,
     X be non-empty ManySortedSet of the carrier of S holds
union rng FreeGen(X) = {root-tree t where t is Symbol of DTConMSA(X):
                           t in Terminals DTConMSA(X)};

definition
 let S be non void non empty ManySortedSign,
     X be non-empty ManySortedSet of the carrier of S,
     s be SortSymbol of S;
func Reverse(s,X) -> Function of FreeGen(s,X),X.s means
:: MSAFREE:def 19
for t be Symbol of DTConMSA(X) st
  root-tree t in FreeGen(s,X) holds it.(root-tree t) = t`1;
end;


definition
 let S be non void non empty ManySortedSign,
     X be non-empty ManySortedSet of the carrier of S;
func Reverse(X) -> ManySortedFunction of FreeGen(X),X means
:: MSAFREE:def 20
for s be SortSymbol of S holds it.s = Reverse(s,X);
end;


definition
 let S be non void non empty ManySortedSign,
     X be non-empty ManySortedSet of the carrier of S,
     A be non-empty ManySortedSet of the carrier of S,
     F be ManySortedFunction of FreeGen(X), A,
     t be Symbol of DTConMSA(X);
assume  t in Terminals (DTConMSA(X));
func pi(F,A,t) -> Element of Union A means
:: MSAFREE:def 21
 for f be Function st f = F.(t`2) holds it = f.(root-tree t);
end;


definition
 let S be non void non empty ManySortedSign,
     X be non-empty ManySortedSet of the carrier of S,
     t be Symbol of DTConMSA(X);
assume  ex p be FinSequence st t ==> p;
func @(X,t) -> OperSymbol of S means
:: MSAFREE:def 22
  [it,the carrier of S] = t;
end;


definition
 let S be non void non empty ManySortedSign,
    U0 be non-empty MSAlgebra over S,
    o be OperSymbol of S,
    p be FinSequence;
assume  p in Args(o,U0);
func pi(o,U0,p) -> Element of Union (the Sorts of U0) equals
:: MSAFREE:def 23
  Den(o,U0).p;
end;


theorem :: MSAFREE:17
for S be non void non empty ManySortedSign,
    X be non-empty ManySortedSet of the carrier of S holds FreeGen(X) is free;

theorem :: MSAFREE:18
for S be non void non empty ManySortedSign,
    X be non-empty ManySortedSet of the carrier of S holds
FreeMSA(X) is free;

registration
 let S be non void non empty ManySortedSign;
cluster free strict (non-empty MSAlgebra over S);
 existence
  proof
   consider U1 be non-empty MSAlgebra over S;
   set X = the Sorts of U1;
   take FreeMSA(X);
   thus thesis by Th18;
  end;
end;


registration
 let S be non void non empty ManySortedSign,
    U0 be free MSAlgebra over S;
cluster free GeneratorSet of U0;
 existence by Def6;
end;


theorem :: MSAFREE:19
for S be non void non empty ManySortedSign,
    U1 be non-empty MSAlgebra over S
 ex U0 be strict free (non-empty MSAlgebra over S),
    F be ManySortedFunction of U0,U1
       st F is_epimorphism U0,U1;

theorem :: MSAFREE:20
  for S be non void non empty ManySortedSign,
    U1 be strict non-empty MSAlgebra over S
 ex U0 be strict free (non-empty MSAlgebra over S),
    F be ManySortedFunction of U0,U1
       st F is_epimorphism U0,U1 & Image F = U1;
