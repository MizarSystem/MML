:: A First Order Language
::  by Piotr Rudnicki and Andrzej Trybulec
::
:: Received August 8, 1989
:: Copyright (c) 1990 Association of Mizar Users

environ

 vocabulary MCART_1, FINSEQ_1, RELAT_1, BOOLE, ZF_LANG, FUNCT_1, PRE_TOPC,
      QC_LANG1, FUNCOP_1;
 notation TARSKI, XBOOLE_0, ENUMSET1, ZFMISC_1, SUBSET_1, NUMBERS, XREAL_0,
      MCART_1, NAT_1, RELAT_1, FUNCT_1, RELSET_1, FUNCT_2, FUNCOP_1, FINSEQ_1;
 constructors MCART_1, NAT_1, FUNCT_2, ENUMSET1, FINSEQ_1, XREAL_0, MEMBERED,
      XBOOLE_0, FUNCOP_1;
 clusters RELSET_1, FINSEQ_1, SUBSET_1, ARYTM_3, MEMBERED, ZFMISC_1, XBOOLE_0,
      NUMBERS, ORDINAL2;
 requirements NUMERALS, REAL, SUBSET, BOOLE, ARITHM;


begin

:: Preliminaries

theorem :: QC_LANG1:1
  for D1 being non empty set, D2 being set, k being Element of D1 holds
  [: {k}, D2 :] c= [: D1, D2 :];

theorem :: QC_LANG1:2
for D1 being non empty set, D2 being set, k1, k2, k3 being Element of D1 holds
  [: {k1, k2, k3}, D2 :] c= [: D1, D2 :];

reserve k, l, m, n for Nat;

definition
 func QC-variables -> set equals
:: QC_LANG1:def 1
  [: { 4, 5, 6 }, NAT :];
end;


registration
 cluster QC-variables -> non empty;
coherence
  proof
   reconsider X = {4, 5, 6} as non empty set by ENUMSET1:14;
      [: X, NAT :] is non empty set;
    hence thesis by Def1;
  end;
end;


canceled;

theorem :: QC_LANG1:4
QC-variables c= [: NAT, NAT :];

definition
 mode QC-variable is Element of QC-variables;

 func bound_QC-variables -> Subset of QC-variables equals
:: QC_LANG1:def 2
  [: {4}, NAT :];

 func fixed_QC-variables -> Subset of QC-variables equals
:: QC_LANG1:def 3
 [: {5}, NAT :];

 func free_QC-variables -> Subset of QC-variables equals
:: QC_LANG1:def 4
  [: {6}, NAT :];

  func QC-pred_symbols -> set equals
:: QC_LANG1:def 5
  { [k, l]: 7 <= k };
end;


registration
 cluster bound_QC-variables -> non empty;
 coherence by Def2;

 cluster fixed_QC-variables -> non empty;
 coherence by Def3;

 cluster free_QC-variables -> non empty;
 coherence by Def4;

  cluster QC-pred_symbols -> non empty;
 coherence
   proof
       [7, 7] in { [k, l]: 7 <= k };
     hence thesis by Def5;
   end;
end;


canceled 5;

theorem :: QC_LANG1:10
QC-pred_symbols c= [: NAT, NAT :];

definition
  mode QC-pred_symbol is Element of QC-pred_symbols;
end;


definition let P be Element of QC-pred_symbols;
  func the_arity_of P -> Nat means
:: QC_LANG1:def 6
 P`1 = 7+it;
end;


 reserve P for QC-pred_symbol;

definition let k;
 func k-ary_QC-pred_symbols -> Subset of QC-pred_symbols equals
:: QC_LANG1:def 7
  { P : the_arity_of P = k };
end;


registration let k;
 cluster k-ary_QC-pred_symbols -> non empty;
 coherence
  proof
   set Y = {7+k};
      [: {7+k}, NAT :] c= QC-pred_symbols
        proof
          let x be set; assume
        A1: x in [: {7+k}, NAT :];
       then A2: x`1 = 7+k & x`2 in NAT by MCART_1:12;
            reconsider x1 = x`1, x2 = x`2 as Element of NAT by A1,MCART_1:12;
              7 <= x1 by A2,NAT_1:37;
            then [x1, x2] in { [m, n] : 7 <= m };
          hence x in QC-pred_symbols by A1,Def5,MCART_1:23;
        end;
   then reconsider X = [: Y, NAT :] as non empty Subset of QC-pred_symbols;
      X = { P : the_arity_of P = k }
   proof
   thus X c= { P : the_arity_of P = k }
     proof
        let x be set; assume
     A3: x in X;
         then reconsider Q = x as QC-pred_symbol;
           x`1 in Y by A3,MCART_1:10;
         then x`1 = 7+k by TARSKI:def 1;
         then the_arity_of Q = k by Def6;
        hence x in { P : the_arity_of P = k };
     end;
   let x be set;
   assume x in { P : the_arity_of P = k };
   then consider P such that
  A4: x = P and
 A5: the_arity_of P = k;
A6: P in [: NAT, NAT :] by Th10,TARSKI:def 3;
      P`1 = 7+k by A5,Def6;
    then P`1 in Y & P`2 in NAT by A6,MCART_1:10,TARSKI:def 1;
    then [P`1, P`2] in X by ZFMISC_1:106;
   hence x in X by A4,A6,MCART_1:23;
   end;
   hence thesis by Def7;
  end;
end;


definition
 mode bound_QC-variable is Element of bound_QC-variables;
 mode fixed_QC-variable is Element of fixed_QC-variables;
 mode free_QC-variable is Element of free_QC-variables;

let k;
 mode QC-pred_symbol of k is Element of k-ary_QC-pred_symbols;
end;


definition let k be Nat;
  mode QC-variable_list of k -> FinSequence of QC-variables means
:: QC_LANG1:def 8
 len it = k;
end;


definition let D be set;
  attr D is QC-closed means
:: QC_LANG1:def 9
   D is Subset of [:NAT, NAT:]* &
                :: Includes atomic formulae
     (for k being Nat, p being (QC-pred_symbol of k),
          ll being QC-variable_list of k holds <*p*>^ll in D) &
                :: Is closed under VERUM, 'not', '&', and quantification
     <*[0, 0]*> in D &
     (for p being FinSequence of [:NAT,NAT:]
      st p in D holds <*[1, 0]*>^p in D) &
     (for p, q being FinSequence of [:NAT, NAT:] st
      p in D & q in D
           holds <*[2, 0]*>^p^q in D) &
     (for x being bound_QC-variable,
          p being FinSequence of [:NAT, NAT:]
           st p in D holds <*[3, 0]*>^<*x*>^p in D);
end;

definition
   func QC-WFF -> non empty set means
:: QC_LANG1:def 10
 it is QC-closed &
                :: Is the smallest that is_QC-closed
   for D being non empty set st D is QC-closed holds it c= D;
end;


canceled 10;

theorem :: QC_LANG1:21
QC-WFF is QC-closed;

definition
  mode QC-formula is Element of QC-WFF;
end;


definition let P be QC-pred_symbol,l be FinSequence of QC-variables;
 assume  the_arity_of P = len l;
  func P!l -> Element of QC-WFF equals
:: QC_LANG1:def 11
  <*P*>^l;
end;


canceled;

theorem :: QC_LANG1:23
   for k being Nat, p being QC-pred_symbol of k,
           ll be QC-variable_list of k
         holds p!ll = <*p*>^ll;

definition
  let p be Element of QC-WFF;

  func @p -> FinSequence of [:NAT, NAT:] equals
:: QC_LANG1:def 12
  p;
end;


definition
  func VERUM -> QC-formula equals
:: QC_LANG1:def 13
  <*[0, 0]*>;

let p be Element of QC-WFF;

  func 'not' p -> QC-formula equals
:: QC_LANG1:def 14
  <*[1, 0]*>^@p;

let q be Element of QC-WFF;

        func p '&' q -> QC-formula equals
:: QC_LANG1:def 15
  <*[2, 0]*>^@p^@q;
end;


definition let x be bound_QC-variable, p be Element of QC-WFF;
  func All(x, p) -> QC-formula equals
:: QC_LANG1:def 16
 <*[3, 0]*>^<*x*>^@p;
end;


        reserve F for Element of QC-WFF;
scheme :: QC_LANG1:sch 1
 QC_Ind { Prop[Element of QC-WFF] }:
        for F being Element of QC-WFF holds Prop[F]
  provided
         for k being Nat, P being (QC-pred_symbol of k),
                ll being QC-variable_list of k
              holds Prop[P!ll] and
         Prop[VERUM] and
         for p being Element of QC-WFF st Prop[p] holds Prop['not' p] and
         for p, q being Element of QC-WFF st Prop[p] & Prop[q]
              holds Prop[p '&' q] and
         for x being bound_QC-variable, p being Element of QC-WFF st Prop[p]
                        holds Prop[All(x, p)]
proof
      VERUM in { F : Prop[F] } by A2;
    then reconsider X = { F : Prop[F] } as non empty set;
      X is QC-closed
      proof
          X c= [:NAT, NAT:]*
         proof
           let x be set;
           assume x in X;
           then consider p being Element of QC-WFF such that
        A6: x = p & Prop[p];
             p = @p by Def12;
           hence thesis by A6,FINSEQ_1:def 11;
         end;
       hence X is Subset of [:NAT, NAT:]*;
       thus for k being Nat, P being (QC-pred_symbol of k),
                ll being QC-variable_list of k
              holds <*P*>^ll in X
         proof
           let k be Nat, P be (QC-pred_symbol of k),
                ll be QC-variable_list of k;
               Prop[P!ll] by A1;
             then P!ll in X;
           hence thesis by Th23;
         end;
       thus <*[0, 0]*> in X by A2,Def13;
       thus for p being FinSequence of [:NAT, NAT:]
                 st p in X holds <*[1, 0]*>^p in X
         proof
          let p be FinSequence of [:NAT, NAT:];
          assume p in X;
          then consider p' being Element of QC-WFF such that
         A7: p = p' & Prop[p'];
            Prop['not' p'] by A3,A7;
          then 'not' p' in X;
          then <*[1, 0]*>^@p' in X by Def14;
          hence thesis by A7,Def12;
         end;
       thus for p, q being FinSequence of [:NAT, NAT:]
             st p in X & q in X
              holds <*[2, 0]*>^p^q in X
         proof
           let p, q be FinSequence of [:NAT, NAT:];
           assume p in X;
            then consider p' being Element of QC-WFF such that
         A8: p = p' & Prop[p'];
           assume q in X;
            then consider q' being Element of QC-WFF such that
         A9: q = q' & Prop[q'];
         A10: @p' = p & @q' = q by A8,A9,Def12;
              Prop[p' '&' q'] by A4,A8,A9;
            then p' '&' q' in X;
           hence thesis by A10,Def15;
         end;
        thus for x being bound_QC-variable,
              p being FinSequence of [:NAT, NAT:]
                 st p in X holds <*[3, 0]*>^<*x*>^p in X
         proof
          let x be bound_QC-variable,
              p be FinSequence of [:NAT, NAT:];
           assume p in X;
            then consider p' being Element of QC-WFF such that
         A11: p = p' & Prop[p'];
              Prop[All(x, p')] by A5,A11;
            then All(x, p') in X;
            then <*[3, 0]*>^<*x*>^@p' in X by Def16;
          hence thesis by A11,Def12;
         end;
      end;
  then A12: QC-WFF c= X by Def10;
    let F' be Element of QC-WFF;
      F' in X by A12,TARSKI:def 3;
    then ex F'' being Element of QC-WFF st F' = F'' & Prop[F''];
    hence Prop[F'];
  end;

definition

let F be Element of QC-WFF;
        attr F is atomic means
:: QC_LANG1:def 17
 ex k being Nat, p being (QC-pred_symbol of k),
                ll being QC-variable_list of k
                        st F = p!ll;
        attr F is negative means
:: QC_LANG1:def 18
 ex p being Element of QC-WFF st F = 'not' p;
        attr F is conjunctive means
:: QC_LANG1:def 19
 ex p, q being Element of QC-WFF st F = p '&' q;
        attr F is universal means
:: QC_LANG1:def 20
 ex x being bound_QC-variable, p being Element of QC-WFF
                        st F = All(x, p);
end;

canceled 9;

theorem :: QC_LANG1:33
for F being Element of QC-WFF holds
                F = VERUM or F is atomic or F is negative or
                F is conjunctive or F is universal;

theorem :: QC_LANG1:34
for F being Element of QC-WFF holds 1 <= len @F;

 reserve Q for QC-pred_symbol;

theorem :: QC_LANG1:35
for k being Nat, P being QC-pred_symbol of k
                  holds the_arity_of P = k;

 reserve F, G for (Element of QC-WFF), k,n for Nat, s for FinSequence;

theorem :: QC_LANG1:36
    ((@F.1)`1 = 0 implies F = VERUM) &
    ((@F.1)`1 = 1 implies F is negative) &
    ((@F.1)`1 = 2 implies F is conjunctive) &
    ((@F.1)`1 = 3 implies F is universal) &
    ((ex k being Nat st @F.1 is QC-pred_symbol of k) implies F is atomic);

theorem :: QC_LANG1:37
@F = @G^s implies @F = @G;

definition

        let F be Element of QC-WFF such that  F is atomic;

        func the_pred_symbol_of F -> QC-pred_symbol means
:: QC_LANG1:def 21
 ex k being Nat, ll being (QC-variable_list of k),
                        P being QC-pred_symbol of k
                st it = P & F = P!ll;
end;


definition let F be Element of QC-WFF such that  F is atomic;
  func the_arguments_of F -> FinSequence of QC-variables means
:: QC_LANG1:def 22
 ex k being Nat, P being (QC-pred_symbol of k),
                        ll being QC-variable_list of k
                st it = ll & F = P!ll;
end;


definition let F be Element of QC-WFF such that  F is negative;
  func the_argument_of F -> QC-formula means
:: QC_LANG1:def 23
 F = 'not' it;

end;

definition
  let F be Element of QC-WFF such that  F is conjunctive;
  func the_left_argument_of F -> QC-formula means
:: QC_LANG1:def 24
 ex q being Element of QC-WFF st F = it '&' q;
end;


definition
        let F be Element of QC-WFF such that  F is conjunctive;

        func the_right_argument_of F -> QC-formula means
:: QC_LANG1:def 25
 ex p being Element of QC-WFF st F = p '&' it;
end;


definition let F be Element of QC-WFF such that  F is universal;
  func bound_in F -> bound_QC-variable means
:: QC_LANG1:def 26
 ex p being Element of QC-WFF st F = All(it, p);

  func the_scope_of F -> QC-formula means
:: QC_LANG1:def 27
 ex x being bound_QC-variable st F = All(x, it);
end;


  reserve p for Element of QC-WFF;

canceled 7;

theorem :: QC_LANG1:45
p is negative implies len @the_argument_of p < len @p;

theorem :: QC_LANG1:46
p is conjunctive implies len @the_left_argument_of p < len @p
                        & len @the_right_argument_of p < len @p;
theorem :: QC_LANG1:47
p is universal implies len @the_scope_of p < len @p;

scheme :: QC_LANG1:sch 2
 QC_Ind2 { Prop[Element of QC-WFF] }:
        for p being Element of QC-WFF holds Prop[p]
  provided
       for p being Element of QC-WFF holds
         (p is atomic implies Prop[p]) &
         Prop[VERUM] &
         (p is negative & Prop[the_argument_of p] implies Prop[p]) &
         (p is conjunctive & Prop[the_left_argument_of p] &
                Prop[the_right_argument_of p] implies Prop[p]) &
         (p is universal & Prop[the_scope_of p] implies Prop[p])
proof
defpred Q[Element of QC-WFF] means Prop[$1];
A2: now let k be Nat, P be (QC-pred_symbol of k), ll be QC-variable_list of k;
          P!ll is atomic by Def17;
        hence Q[P!ll] by A1;
    end;
A3: Q[VERUM] by A1;
A4: now let p be Element of QC-WFF such that
     A5: Q[p];
     A6: 'not' p is negative by Def18;
        then p= the_argument_of 'not' p by Def23;
        hence Q['not' p] by A1,A5,A6;
    end;
A7: now let p, q be Element of QC-WFF such that
     A8: Q[p] & Q[q];
     A9: p '&' q is conjunctive by Def19;
        then p = the_left_argument_of (p '&' q) &
             q = the_right_argument_of (p '&' q)
          by Def24,Def25;
        hence Q[p '&' q] by A1,A8,A9;
    end;
A10: now let x be bound_QC-variable, p be Element of QC-WFF such that
     A11: Q[p];
     A12: All(x, p) is universal by Def20;
         then p = the_scope_of All(x, p) by Def27;
        hence Q[All(x, p)] by A1,A11,A12;
    end;
 thus for p be Element of QC-WFF holds Q[p] from QC_Ind (A2, A3, A4, A7, A10);
end;
        reserve F for Element of QC-WFF;

theorem :: QC_LANG1:48
for k being Nat, P being QC-pred_symbol of k holds
                P`1 <> 0 & P`1 <> 1 & P`1 <> 2 & P`1 <> 3;

theorem :: QC_LANG1:49
    (@VERUM.1)`1 = 0 &
    (F is atomic implies ex k being Nat st @F.1 is QC-pred_symbol of k) &
    (F is negative implies (@F.1)`1 = 1) &
    (F is conjunctive implies (@F.1)`1 = 2) &
    (F is universal implies (@F.1)`1 = 3);

theorem :: QC_LANG1:50
F is atomic implies
                (@F.1)`1 <> 0 & (@F.1)`1 <> 1 & (@F.1)`1 <> 2 & (@F.1)`1 <> 3;

 reserve p for Element of QC-WFF;

theorem :: QC_LANG1:51
not (VERUM is atomic or VERUM is negative or VERUM is conjunctive
                                  or VERUM is universal) &
        not (ex p st p is atomic & p is negative or
                        p is atomic & p is conjunctive or
                        p is atomic & p is universal or
                        p is negative & p is conjunctive or
                        p is negative & p is universal or
                        p is conjunctive & p is universal);

scheme :: QC_LANG1:sch 3
 QC_Func_Ex { D() -> non empty set,
                V() -> (Element of D()),
                A(Element of QC-WFF) -> (Element of D()),
                N(Element of D()) -> (Element of D()),
                C((Element of D()), Element of D()) -> (Element of D()),
                Q((Element of QC-WFF), Element of D()) -> Element of D()} :
ex F being Function of QC-WFF, D() st
        F.VERUM = V() &
        for p being Element of QC-WFF holds
        (p is atomic implies F.p = A(p)) &
        (p is negative implies F.p = N(F.the_argument_of p)) &
        (p is conjunctive implies
           F.p = C(F.the_left_argument_of p, F.the_right_argument_of p)) &
        (p is universal implies F.p = Q(p, F.the_scope_of p))
proof
defpred Pfgp[(Element of D()),
          (Function of QC-WFF, D()),
           Element of QC-WFF] means
      ($3 = VERUM implies $1 = V()) &
      ($3 is atomic implies $1 = A($3)) &
      ($3 is negative implies $1 = N($2.the_argument_of $3)) &
      ($3 is conjunctive implies
           $1 = C($2.the_left_argument_of $3,
                     $2.the_right_argument_of $3)) &
      ($3 is universal implies $1 = Q($3, $2.the_scope_of $3));
defpred Pfn[(Function of QC-WFF, D()), Nat] means
      $1.VERUM = V() &
      for p being Element of QC-WFF st len @p <= $2 holds
      (p is atomic implies $1.p = A(p)) &
      (p is negative implies $1.p = N($1.the_argument_of p)) &
      (p is conjunctive implies
           $1.p = C($1.the_left_argument_of p, $1.the_right_argument_of p)) &
      (p is universal implies
               $1.p = Q(p, $1.the_scope_of p));
defpred S[Nat] means ex F being Function of QC-WFF, D() st Pfn[F, $1];
A1: S[0]
    proof
      reconsider F = QC-WFF --> V() as Function of QC-WFF, D() by FUNCOP_1:57;
     take F;
     thus F.VERUM = V() by FUNCOP_1:13;
     let p be Element of QC-WFF such that
    A2: len @p <= 0;
          1 <= len @p by Th34;
        hence thesis by A2,AXIOMS:22;
    end;
A3: for n be Nat st S[n] holds S[n+1]
proof
  let n be Nat;
  given F being Function of QC-WFF, D() such that
  A4: Pfn[F, n];
  defpred R[Element of QC-WFF,Element of D()] means
   (len @$1 <> n+1 implies $2 = F.$1) & (len @$1 = n+1 implies Pfgp[$2,F,$1]);
  A5: for p be Element of QC-WFF ex y be Element of D() st R[p,y]
  proof
        let p be Element of QC-WFF;
        now per cases by Th33;
        case len @p <> n+1;
         take y = F.p;
         thus y =F.p;
        end;
        case A6:len @p = n+1 & p = VERUM;
         take y = V();
         thus Pfgp[y, F, p] by A6,Th51;
        end;
        case A7: len @p = n+1 & p is atomic;
         take y = A(p);
         thus Pfgp[y, F, p] by A7,Th51;
        end;
        case A8: len @p = n+1 & p is negative;
         take y = N(F.the_argument_of p);
         thus Pfgp[y, F, p] by A8,Th51;
        end;
        case A9: len @p = n+1 & p is conjunctive;
         take y = C(F.the_left_argument_of p, F.the_right_argument_of p);
         thus Pfgp[y, F, p] by A9,Th51;
        end;
        case A10: len @p = n+1 & p is universal;
         take y = Q(p, F.the_scope_of p);
         thus Pfgp[y, F, p] by A10,Th51;
      end;
      end;
      hence ex y being Element of D() st
                (len @p <> n+1 implies y = F.p) &
                (len @p = n+1 implies Pfgp[y, F, p]);
     end;
     consider G being Function of QC-WFF, D() such that
   A11:      for p being Element of QC-WFF holds R[p,G.p] from FUNCT_2:sch 3
(A5);
       take H = G;
     thus Pfn[H, n+1]
    proof
      thus H.VERUM = V()
        proof
         per cases;
          suppose len @VERUM <> n+1;
           hence thesis by A4,A11;
          end;
          suppose len @VERUM = n+1;
           hence thesis by A11;
        end;
        end;
      let p be Element of QC-WFF such that
   A12: len @p <= n+1;
     thus p is atomic implies H.p = A(p)
        proof
           now per cases;
          suppose A15: len @p <> n+1; then A16: len @p <= n by A12,NAT_1:26;
                  H.p = F.p by A11,A15;
           hence thesis by A4,A16;
          end;
          suppose len @p = n+1;
           hence thesis by A11;
         end;
         end;
        hence thesis;
        end;
     thus p is negative implies H.p = N(H.the_argument_of p)
        proof assume A17: p is negative;
          then len @the_argument_of p <> n+1 by A12,Th45;
        then A18:  H.the_argument_of p = F.the_argument_of p by A11;
           now per cases;
          suppose A19: len @p <> n+1; then A20: len @p <= n by A12,NAT_1:26;
              H.p = F.p by A11,A19;
           hence thesis by A4,A17,A18,A20;
          end;
          suppose len @p = n+1;
           hence thesis by A11,A17,A18;
         end;
         end;
        hence thesis;
        end;
      thus p is conjunctive implies
           H.p = C(H.the_left_argument_of p, H.the_right_argument_of p)
        proof assume A21: p is conjunctive;
          then len @the_left_argument_of p <> n+1 by A12,Th46;
        then A22:  H.the_left_argument_of p = F.the_left_argument_of p by A11;
            len @the_right_argument_of p <> n+1 by A12,A21,Th46;
        then A23: H.the_right_argument_of p = F.the_right_argument_of p by A11;
           now per cases;
          suppose A24: len @p <> n+1; then A25: len @p <= n by A12,NAT_1:26;
                  H.p = F.p by A11,A24;
           hence thesis by A4,A21,A22,A23,A25;
          end;
          suppose len @p = n+1;
           hence thesis by A11,A21,A22,A23;
         end;
         end;
        hence thesis;
        end;
      thus p is universal implies H.p = Q(p, H.the_scope_of p)
        proof assume A26: p is universal;
          then len @the_scope_of p <> n+1 by A12,Th47;
        then A27:  H.the_scope_of p = F.the_scope_of p by A11;
           now per cases;
          suppose A28: len @p <> n+1; then A29: len @p <= n by A12,NAT_1:26;
                  H.p = F.p by A11,A28;
           hence thesis by A4,A26,A27,A29;
          end;
          suppose len @p = n+1;
           hence thesis by A11,A26,A27;
         end;
         end;
        hence thesis;
        end;
     end;
   end;

A30: for n being Nat holds S[n] from NAT_1:sch 1 (A1, A3);

defpred Qfn[set, set] means
        ex p being Element of QC-WFF st p = $1 &
          for g being Function of QC-WFF, D() st Pfn[g, len @p] holds
                $2 = g.p;

A31: for x, y1, y2 being set st x in QC-WFF & Qfn[x, y1] & Qfn[x, y2]
        holds y1 = y2
   proof
        let x, y1, y2 be set such that
      x in QC-WFF and
   A32: Qfn[x, y1] and
   A33: Qfn[x, y2];
       consider p being Element of QC-WFF such that
   A34: p = x and
   A35: for g being Function of QC-WFF, D() st Pfn[g, len @p] holds y1 = g.p
                                                by A32;
       consider F being Function of QC-WFF, D() such that
   A36: Pfn[F, len @p] by A30;
     thus y1 = F.p by A35,A36
            .= y2 by A33,A34,A36;
   end;

A37: for x being set st x in QC-WFF ex y being set st Qfn[x, y]
   proof let x be set; assume
      x in QC-WFF;
       then reconsider x' = x as Element of QC-WFF;
       consider F being Function of QC-WFF, D() such that
   A38: Pfn[F, len @x'] by A30;
       take F.x, x';
       thus x = x';
       let G be Function of QC-WFF, D() such that
   A39: Pfn[G, len @x'];

     defpred  Prop[Element of QC-WFF] means
        len @$1 <= len@x' implies F.$1 = G.$1;
   A40: now
        let p be Element of QC-WFF;
        thus p is atomic implies Prop[p]
         proof assume that
         A41: p is atomic and
         A42: len @p <= len@x';
           thus F.p = A(p) by A38,A41,A42
                   .= G.p by A39,A41,A42;
         end;
        thus Prop[VERUM] by A38,A39;
        thus p is negative & Prop[the_argument_of p] implies Prop[p]
         proof assume that
          A44: p is negative and
          A45: Prop[the_argument_of p] and
          A46: len @p <= len @x';
            len @the_argument_of p < len @p by A44,Th45;
          hence F.p = N(G.the_argument_of p) by A38,A44,A45,A46,AXIOMS:22
                  .= G.p by A39,A44,A46;
         end;
        thus (p is conjunctive & Prop[the_left_argument_of p] &
                Prop[the_right_argument_of p] implies Prop[p])
         proof assume that
          A47: p is conjunctive and
          A48: Prop[the_left_argument_of p] and
         A49: Prop[the_right_argument_of p] and
          A50: len @p <= len @x';
A51:          len @the_left_argument_of p < len @p by A47,Th46;
            len @the_right_argument_of p < len @p by A47,Th46;
          hence F.p = C(G.the_left_argument_of p, G.the_right_argument_of p)
                                                 by A38,A47,A48,A49,A50,A51,
AXIOMS:22
                  .= G.p by A39,A47,A50;
         end;
        thus (p is universal & Prop[the_scope_of p] implies Prop[p])
         proof assume that
          A52: p is universal and
          A53: Prop[the_scope_of p] and
          A54: len @p <= len @x';
            len @the_scope_of p < len @p by A52,Th47;
          hence F.p = Q(p, G.the_scope_of p) by A38,A52,A53,A54,AXIOMS:22
                  .= G.p by A39,A52,A54;
         end;
       end;
      for p being Element of QC-WFF holds Prop[p]
                                from QC_Ind2 (A40);
       hence F.x = G.x';
   end;

 consider F being Function such that
A55: dom F = QC-WFF and
A56: for x being set st x in QC-WFF holds Qfn[x, F.x]
                                 from FUNCT_1:sch 2 (A31, A37);
    rng F c= D()
  proof
    let y be set; assume
     y in rng F;
    then consider x being set such that
  A57: x in QC-WFF and
  A58: y = F.x by A55,FUNCT_1:def 5;
      consider p being Element of QC-WFF such that
     p = x and
  A59: for g being Function of QC-WFF, D() st Pfn[g, len @p] holds y = g.p
                                          by A56,A57,A58;
    consider G being Function of QC-WFF, D() such that
  A60: Pfn[G, len @p] by A30;
        y = G.p by A59,A60;
    hence y in D();
  end;
   then reconsider F as Function of QC-WFF, D() by A55,FUNCT_2:def 1,RELSET_1:
11;
 take F;
  consider G being Function of QC-WFF, D() such that
Y: Pfn[G, len @VERUM] by A30;
  Qfn[VERUM, F.VERUM] by A56;
 hence F.VERUM = V() by Y;
 let p be Element of QC-WFF;
 consider p1 being Element of QC-WFF such that
A61: p1 = p and
A62: for g being Function of QC-WFF, D() st Pfn[g, len @p1] holds F.p = g.p1
by A56;
 consider G being Function of QC-WFF, D() such that
A63: Pfn[G, len @p1] by A30;
A64: F.p = G.p by A61,A62,A63;
  thus p is atomic implies F.p = A(p) by A61,A63,A64;
  A65: for k being Nat st k < len @p holds Pfn[G, k]
        proof let k be Nat;
         assume
A66:            k < len @p;
         thus G.VERUM = V() by A63;
          let p' be Element of QC-WFF; assume
             len @p' <= k;
           then len @p' <= len@p by A66,AXIOMS:22;
         hence thesis by A61,A63;
        end;
  thus p is negative implies F.p = N(F.the_argument_of p)
        proof assume
        A67: p is negative;
             set p' = the_argument_of p;
             set k = len @p';
               k < len @p by A67,Th45;
        then A68: Pfn[G, k] by A65;
                ex p1 being Element of QC-WFF st p1 = p' &
 for g being Function of QC-WFF, D() st Pfn[g, len @p1] holds
                F.p' = g.p1 by A56;
             then F.p' = G.p' by A68;
         hence thesis by A61,A63,A64,A67;
        end;
  thus p is conjunctive implies
          F.p = C(F.the_left_argument_of p, F.the_right_argument_of p)
        proof assume
        A69: p is conjunctive;
             set p' = the_left_argument_of p;
             set k' = len @p';
             set p'' = the_right_argument_of p;
             set k'' = len @p'';
               k' < len @p by A69,Th46;
        then A70: Pfn[G, k'] by A65;
               k'' < len @p by A69,Th46;
       then A71: Pfn[G, k''] by A65;
 A72:             ex p1 being Element of QC-WFF st p1 = p' &
 for g being Function of QC-WFF, D() st Pfn[g, len @p1] holds
                F.p' = g.p1 by A56;
 A73:             ex p2 being Element of QC-WFF st p2 = p'' &
 for g being Function of QC-WFF, D() st Pfn[g, len @p2] holds
                F.p'' = g.p2 by A56;
        A74: F.p' = G.p' by A70,A72;
               F.p'' = G.p'' by A71,A73;
         hence thesis by A61,A63,A64,A69,A74;
        end;
  assume
   A75: p is universal;
        set p' = the_scope_of p;
        set k = len @p';
          k < len @p by A75,Th47;
   then A76: Pfn[G, k] by A65;
           ex p1 being Element of QC-WFF st p1 = p' &
 for g being Function of QC-WFF, D() st Pfn[g, len @p1] holds
                         F.p' = g.p1 by A56;
        then F.p' = G.p' by A76;
  hence thesis by A61,A63,A64,A75;
end;

        reserve j,k for Nat;
definition
        let ll be FinSequence of QC-variables;
func still_not-bound_in ll -> Element of (bool bound_QC-variables)
         equals
:: QC_LANG1:def 28
 { ll.k : 1 <= k & k <= len ll & ll.k in bound_QC-variables };
end;


definition
  let b be bound_QC-variable;
redefine func { b } -> Element of bool bound_QC-variables;
end;


definition
  let X, Y be Element of bool bound_QC-variables;
redefine
  func X \/ Y -> Element of bool bound_QC-variables;
  func X \ Y -> Element of bool bound_QC-variables;
end;


        reserve k for Nat;
definition let p be QC-formula;
 func still_not-bound_in p -> Element of bool bound_QC-variables means
:: QC_LANG1:def 29

          ex F being Function of QC-WFF, bool bound_QC-variables st
         it = F.p &
         for p being Element of QC-WFF holds
         F.VERUM = {} &
         (p is atomic implies
           F.p = { (the_arguments_of p).k :
                         1 <= k & k <= len the_arguments_of p &
                         (the_arguments_of p).k in bound_QC-variables }) &
         (p is negative implies F.p = F.the_argument_of p) &
         (p is conjunctive implies F.p = (F.the_left_argument_of p) \/
                                         (F.the_right_argument_of p)) &
         (p is universal implies F.p = (F.the_scope_of p) \ {bound_in p});
end;


definition let p be QC-formula;
  attr p is closed means
:: QC_LANG1:def 30
     still_not-bound_in p = {};
end;

