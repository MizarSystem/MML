:: Relocability for { \bf SCM } over Ring
::  by Artur Korni{\l}owicz and Yasunari Shidama
::
:: Received February 6, 2004
:: Copyright (c) 2004 Association of Mizar Users

environ

 vocabularies AMI_3, SCMFSA7B, FUNCSDOM, AMI_1, ORDINAL2, AMI_2, BOOLE,
      FUNCT_1, FUNCOP_1, CAT_1, ARYTM, RELAT_1, AMI_5, FUNCT_4, REALSET1,
      RLVECT_1, ARYTM_1, CARD_3, RELOC, PARTFUN1;
 notations TARSKI, XBOOLE_0, SUBSET_1, SETFAM_1, DOMAIN_1, ORDINAL1, RELAT_1,
      NUMBERS, XXREAL_0, FUNCT_1, PARTFUN1, FUNCT_2, STRUCT_0, ALGSTR_0,
      FUNCSDOM, FUNCOP_1, XCMPLX_0, NAT_1, RLVECT_1, FUNCT_4, CARD_3, FUNCT_7,
      BINARITH, VALUED_1, AMI_1, SCMNORM, AMI_2, AMI_3, SCMRING1, SCMRING2,
      AMISTD_1, SCMRING3, AMISTD_2;
 constructors WELLORD2, XXREAL_0, NAT_1, REALSET2, AMI_5, AMISTD_2, SCMRING3,
      SCMNORM, PARTFUN1, VALUED_1;
 registrations XBOOLE_0, SETFAM_1, RELAT_1, FUNCT_1, FUNCOP_1, FRAENKEL,
      XREAL_0, NAT_1, CARD_3, REALSET1, STRUCT_0, AMI_1, AMI_3, AMI_5,
      SCMRING1, SCMRING2, AMISTD_2, SCMRING3, FINSET_1, AMI_2, ORDINAL1,
      SCMNORM, NUMBERS, RELSET_1;
 requirements NUMERALS, BOOLE, SUBSET, ARITHM;


begin :: On the standard computers

reserve i, j, k for natural number,
  n for Element of NAT,
  IL for non empty set,
  N for with_non-empty_elements set;

begin :: SCM R

reserve R for good Ring,
  a, b for Data-Location of R,
  loc for Instruction-Location of SCM R,
  I for Instruction of SCM R,
  p for FinPartState of SCM R,
  s, s1, s2 for State of SCM R,
  q for FinPartState of SCM;

theorem :: SCMRING4:1
  the carrier of SCM R = {IC SCM R} \/ SCM-Data-Loc \/ NAT;

theorem :: SCMRING4:2
  ObjectKind loc = SCM-Instr R;

theorem :: SCMRING4:3
  dl.(R,n) = [1,n];

theorem :: SCMRING4:4
  il.(SCM R,k) = k;

theorem :: SCMRING4:5
  for dl being Data-Location of R ex i being Element of NAT st dl = dl.(R,i);

theorem :: SCMRING4:6
  for i,j being Element of NAT holds i <> j implies dl.(R,i) <> dl.(R,j);

theorem :: SCMRING4:7
  a <> loc;

theorem :: SCMRING4:8
  SCM-Data-Loc c= dom s;

theorem :: SCMRING4:9
  dom (s|SCM-Data-Loc) = SCM-Data-Loc;

theorem :: SCMRING4:10
  p = q implies DataPart p = DataPart q;

theorem :: SCMRING4:11
  DataPart p = p | SCM-Data-Loc;

theorem :: SCMRING4:12
  p is data-only iff dom p c= SCM-Data-Loc;

theorem :: SCMRING4:13
  dom DataPart p c= SCM-Data-Loc;

theorem :: SCMRING4:14
  NAT c= dom s;

theorem :: SCMRING4:15
  p = q implies ProgramPart p = ProgramPart q;

theorem :: SCMRING4:16
  dom ProgramPart p c= NAT;

theorem :: SCMRING4:17
  InsCode(I) <= 7;

theorem :: SCMRING4:18
  IncAddr(goto loc,k) = goto (loc + k);

theorem :: SCMRING4:19
  IncAddr(a=0_goto loc,k) = a=0_goto (loc + k);

theorem :: SCMRING4:20
  s.a = (s +* Start-At loc).a;

theorem :: SCMRING4:21
  IC(s1) = IC(s2) & (for a being Data-Location of R holds s1.a = s2.a) &
  (for i being Instruction-Location of SCM R holds s1.i = s2.i)
  implies s1 = s2;

theorem :: SCMRING4:22
  Exec(IncAddr(CurInstr s,k),s +* Start-At (IC s + k))
  = Following(s) +* Start-At (IC Following(s) + k);

theorem :: SCMRING4:23
  IC s = il.(SCM R,j+k) implies Exec(I, s +* Start-At (IC s -' k))
  = Exec(IncAddr(I, k), s) +* Start-At (IC Exec(IncAddr(I,k), s) -' k);

registration
  let R;
  cluster autonomic non programmed FinPartState of SCM R;
end;

definition
  let R;
  let a be Data-Location of R;
  let r be Element of R;
  redefine func a .--> r -> FinPartState of SCM R;
end;

theorem :: SCMRING4:24
  R is non trivial implies
  for p being autonomic FinPartState of SCM R st DataPart p <> {} holds
  IC SCM R in dom p;

theorem :: SCMRING4:25
  R is non trivial implies
  for p being autonomic non programmed FinPartState of SCM R holds
  IC SCM R in dom p;

theorem :: SCMRING4:26
  for p being autonomic FinPartState of SCM R st IC SCM R in dom p holds
  IC p in dom p;

theorem :: SCMRING4:27
  R is non trivial implies
  for p being autonomic non programmed FinPartState of SCM R st p c= s
  holds IC Computation(s,n) in dom ProgramPart(p);

theorem :: SCMRING4:28
  R is non trivial implies
  for p being autonomic non programmed FinPartState of SCM R
  st p c= s1 & p c= s2 holds IC Computation(s1,n) = IC Computation(s2,n) &
  CurInstr (Computation(s1,n)) = CurInstr (Computation(s2,n));

theorem :: SCMRING4:29
  R is non trivial implies
  for p being autonomic non programmed FinPartState of SCM R
  st p c= s1 & p c= s2 & CurInstr (Computation(s1,n)) = a := b & a in dom p
  holds Computation(s1,n).b = Computation(s2,n).b;

theorem :: SCMRING4:30
  R is non trivial implies
  for p being autonomic non programmed FinPartState of SCM R
  st p c= s1 & p c= s2 &
  CurInstr (Computation(s1,n)) = AddTo(a,b) & a in dom p
  holds Computation(s1,n).a + Computation(s1,n).b
  = Computation(s2,n).a + Computation(s2,n).b;

theorem :: SCMRING4:31
  R is non trivial implies
  for p being autonomic non programmed FinPartState of SCM R
  st p c= s1 & p c= s2 &
  CurInstr (Computation(s1,n)) = SubFrom(a, b) & a in dom p
  holds Computation(s1,n).a - Computation(s1,n).b
  = Computation(s2,n).a - Computation(s2,n).b;

theorem :: SCMRING4:32
  R is non trivial implies
  for p being autonomic non programmed FinPartState of SCM R
  st p c= s1 & p c= s2 &
  CurInstr (Computation(s1,n)) = MultBy(a, b) & a in dom p
  holds Computation(s1,n).a * Computation(s1,n).b
  = Computation(s2,n).a * Computation(s2,n).b;

theorem :: SCMRING4:33
  R is non trivial implies
  for p being autonomic non programmed FinPartState of SCM R
  st p c= s1 & p c= s2 & CurInstr (Computation(s1,n)) = a=0_goto loc &
  loc <> Next (IC Computation(s1,n)) holds
  Computation(s1,n).a = 0.R iff Computation(s2,n).a = 0.R;

begin :: Relocability

theorem :: SCMRING4:34
  for p being autonomic FinPartState of SCM R
  st p c= s1 & Relocated (p,k) c= s2 holds p c= s1 +* s2|SCM-Data-Loc;

theorem :: SCMRING4:35
  R is non trivial implies for p being autonomic FinPartState of SCM R
  st IC SCM R in dom p & p c= s1 & Relocated (p,k) c= s2 &
  s = s1 +* s2|SCM-Data-Loc holds for i being Element of NAT holds
  IC Computation(s1,i) + k = IC Computation(s2,i) &
  IncAddr(CurInstr(Computation(s1,i)), k) = CurInstr(Computation(s2,i)) &
  Computation(s1,i)|dom (DataPart p)
  = Computation(s2,i)|dom (DataPart (Relocated (p,k))) &
  Computation(s,i)|SCM-Data-Loc = Computation(s2,i)|SCM-Data-Loc;

theorem :: SCMRING4:36
  R is non trivial implies
  for p being autonomic FinPartState of SCM R st IC SCM R in dom p holds
  p is halting iff Relocated (p,k) is halting;

theorem :: SCMRING4:37
  R is non trivial implies
  for p being autonomic FinPartState of SCM R st IC SCM R in dom p & p c= s
  for i being Element of NAT holds Computation(s+*Relocated(p,k),i)
  = Computation(s,i) +* Start-At (IC Computation(s,i) + k)
  +* ProgramPart (Relocated (p,k));

theorem :: SCMRING4:38
  R is non trivial implies for p being autonomic FinPartState of SCM R st
  IC SCM R in dom p & Relocated(p,k) c= s holds
  for i being Element of NAT holds Computation(s,i)
  = Computation(s+*p,i) +* Start-At (IC Computation(s+*p,i) + k)
  +* s|dom ProgramPart p +* ProgramPart (Relocated (p,k));

theorem :: SCMRING4:39
  R is non trivial & IC SCM R in dom p & p c= s & Relocated(p,k) is autonomic
  implies for i being Element of NAT holds Computation(s,i)
  = Computation(s+*Relocated(p,k),i)
  +* Start-At (IC Computation(s+*Relocated(p,k),i) -' k)
  +* s|dom ProgramPart Relocated(p,k) +* ProgramPart (p);

theorem :: SCMRING4:40
  R is non trivial & IC SCM R in dom p implies
  (p is autonomic iff Relocated (p,k) is autonomic);

theorem :: SCMRING4:41
  R is non trivial implies
  for p being halting autonomic FinPartState of SCM R st IC SCM R in dom p
  holds DataPart Result p = DataPart Result Relocated(p,k);

theorem :: SCMRING4:42
  R is non trivial implies
  for F being PartFunc of FinPartSt SCM R, FinPartSt SCM R
  st IC SCM R in dom p & F is data-only holds
  p computes F iff Relocated (p,k) computes F;

