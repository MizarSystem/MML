:: J\'onsson Theorem
::  by Jaros{\l}aw Gryko
::
:: Received November 13, 1997
:: Copyright (c) 1997 Association of Mizar Users

environ

 vocabulary FUNCT_1, RELAT_1, ORDINAL1, CLASSES1, ORDINAL2, MCART_1, PRALG_1,
      TARSKI, FUNCT_6, HAHNBAN, ZFMISC_1, ORDERS_1, LATTICE3, MSUALG_5,
      EQREL_1, LATTICES, BOOLE, WAYBEL_0, BHSP_3, SETFAM_1, CANTOR_1, RELAT_2,
      PRE_TOPC, GROUP_6, YELLOW_0, FILTER_2, CAT_1, FINSEQ_1, MATRIX_2,
      FINSEQ_2, ARYTM_1, SQUARE_1, REALSET1, SGRAPH1, CARD_1, PARTFUN1,
      LATTICE5;
 notation TARSKI, XBOOLE_0, ENUMSET1, ZFMISC_1, SUBSET_1, RELAT_1, RELAT_2,
      RELSET_1, FUNCT_1, FUNCT_2, FUNCT_6, NUMBERS, XCMPLX_0, XREAL_0,
      BINARITH, CANTOR_1, NAT_1, SETFAM_1, ORDINAL1, ORDINAL2, CARD_1, MCART_1,
      DOMAIN_1, PARTFUN1, PRALG_1, PRE_TOPC, STRUCT_0, ORDERS_1, EQREL_1,
      MSUALG_5, FINSEQ_1, FINSEQ_2, CLASSES1, CQC_SIM1, LATTICES, LATTICE3,
      BINOP_1, YELLOW_0, WAYBEL_0, YELLOW_2, ABIAN, FINSOP_1;
 constructors BINARITH, DOMAIN_1, RFUNCT_3, CANTOR_1, MSUALG_5, CQC_SIM1,
      BINOP_1, CLASSES1, WAYBEL_1, LATTICE3, ABIAN, FINSOP_1, MEMBERED;
 clusters SUBSET_1, RELSET_1, STRUCT_0, INT_1, YELLOW_0, YELLOW_1, CARD_1,
      ORDINAL1, PRALG_1, LATTICE3, ABIAN, GOBOARD4, ARYTM_3, LATTICES,
      MEMBERED, NUMBERS, ORDINAL2, PARTFUN1, EQREL_1;
 requirements REAL, NUMERALS, BOOLE, SUBSET, ARITHM;


begin :: Preliminaries

scheme :: LATTICE5:sch 1
 RecChoice{A() -> set,P[set,set,set]}:
   ex f being Function st dom f = NAT & f.0 = A() &
     for n being Element of NAT holds P[n,f.n,f.(n+1)]
 provided
  for n being Nat for x being set ex y being set st P[n,x,y]
proof
  defpred Q[set,set,set] means
    ex O2 being Ordinal st O2 = $3 &
     (for X being set, n being Nat st X c= Rank the_rank_of $2
       ex Y being set st Y c= Rank O2 & P[n,X,Y]) &
     (for O being Ordinal st
       for X being set, n being Nat st X c= Rank the_rank_of $2
       ex Y being set st Y c= Rank O & P[n,X,Y]
      holds O2 c= O);
A2: for n being Nat for x being set ex y being set st Q[n,x,y]
 proof
  let n be Nat; let x be set;
   defpred Y[set,set] means for m being Nat ex y being set st
           $2 is Ordinal & y c= Rank the_rank_of $2 & P[m,$1,y];
A3: for x' being set st x' in bool Rank the_rank_of x
    ex o being set st Y[x',o]
    proof
     let x' be set; assume
         x' in bool Rank the_rank_of x;
   defpred X[set,set] means
     ex y being set st $2 is Ordinal & y c= Rank the_rank_of $2 & P[$1,x',y];
A4: for e being set st e in NAT ex u being set st X[e,u]
     proof let i be set; assume i in NAT;
        then reconsider i' = i as Nat;
        thus ex o being set, y being set st
              o is Ordinal & y c= Rank the_rank_of o & P[i,x',y]
          proof
           consider y being set such that
         A5: P[i',x',y] by A1;
           take o = the_rank_of y, y;
           thus o is Ordinal;
              the_rank_of the_rank_of y = the_rank_of y by CLASSES1:81;
           hence y c= Rank the_rank_of o by CLASSES1:73;
           thus P[i,x',y] by A5;
          end;
      end;
      consider h being Function such that
   A6: dom h = NAT and
   A7: for i being set st i in NAT holds X[i,h.i]
         from ZFREFLE1:sch 1(A4);
      take o = sup rng h;
      thus for m being Nat ex y being set st
            o is Ordinal & y c= Rank the_rank_of o & P[m,x',y]
       proof
        let m be Nat;
         consider y being set such that
      A8: h.m is Ordinal and
      A9: y c= Rank the_rank_of (h.m) and
      A10: P[m,x',y] by A7;
         take y;
         thus o is Ordinal;
            h.m in rng h by A6,FUNCT_1:def 5;
          then h.m in sup rng h by A8,ORDINAL2:27;
      then A11: h.m c= o by ORDINAL1:def 2;
         reconsider O = h.m as Ordinal by A8;
      A12: Rank O c= Rank o by A11,CLASSES1:43;
            y c= Rank O by A9,CLASSES1:81;
          then y c= Rank o by A12,XBOOLE_1:1;
         hence y c= Rank the_rank_of o by CLASSES1:81;
         thus P[m,x',y] by A10;
       end;
    end;
  consider f being Function such that
A13: dom f = bool Rank the_rank_of x and
A14: for x' being set st x' in bool Rank the_rank_of x holds Y[x',f.x']
      from ZFREFLE1:sch 1(A3);
    defpred X[Ordinal] means
     for X being set, n being Nat st X c= Rank the_rank_of x
      ex Y being set st Y c= Rank $1 & P[n,X,Y];
A15: ex O being Ordinal st X[O]
 proof take O2 = sup rng f;
    thus (for X being set, m being Nat st X c= Rank the_rank_of x
      ex Y being set st Y c= Rank O2 & P[m,X,Y])
     proof
      let X be set; let m be Nat; assume
     A16: X c= Rank the_rank_of x;
       then consider Y being set such that
     A17: f.X is Ordinal and
     A18: Y c= Rank the_rank_of (f.X) and
     A19: P[m,X,Y] by A14;
       take Y;
          f.X in rng f by A13,A16,FUNCT_1:def 5;
        then f.X in sup rng f by A17,ORDINAL2:27;
     then A20:f.X c= O2 by ORDINAL1:def 2;
       reconsider O = f.X as Ordinal by A17;
     A21:Rank O c= Rank O2 by A20,CLASSES1:43;
          the_rank_of O = O by CLASSES1:81;
       hence Y c= Rank O2 by A18,A21,XBOOLE_1:1;
       thus P[m,X,Y] by A19;
     end;
   end;
   consider O2 being Ordinal such that
A22: X[O2] &
    (for O being Ordinal st X[O] holds O2 c= O) from ORDINAL1:sch 1(A15);
  take O2;
  thus Q[n,x,O2] by A22;
 end;
A23: for n being Nat for x,y1,y2 being set st Q[n,x,y1] & Q[n,x,y2]
      holds y1 = y2
 proof
  let n be Nat; let x,y1,y2 be set; assume that
 A24: Q[n,x,y1] and
 A25: Q[n,x,y2];
   consider O1 being Ordinal such that
 A26: O1 = y1 and
 A27: for X being set, n being Nat st X c= Rank the_rank_of x
       ex Y being set st Y c= Rank O1 & P[n,X,Y] and
 A28: for O being Ordinal st
      for X being set, n being Nat st X c= Rank the_rank_of x
       ex Y being set st Y c= Rank O & P[n,X,Y] holds O1 c= O by A24;
   consider O2 being Ordinal such that
 A29: O2 = y2 and
 A30: for X being set, n being Nat st X c= Rank the_rank_of x
       ex Y being set st Y c= Rank O2 & P[n,X,Y] and
 A31: for O being Ordinal st
      for X being set, n being Nat st X c= Rank the_rank_of x
       ex Y being set st Y c= Rank O & P[n,X,Y] holds O2 c= O by A25;
 A32: O1 c= O2 by A28,A30;
       O2 c= O1 by A27,A31;
  hence y1 = y2 by A26,A29,A32,XBOOLE_0:def 10;
 end;
  consider g being Function such that
A33: dom g = NAT and
A34: g.0 = the_rank_of A() and
A35: for n being Element of NAT holds Q[n,g.n,g.(n+1)] from RECDEF_1:sch 1
(A2,A23);
  set beta = sup rng g;
   defpred X[set,set] means ex i being Nat st i = $1`2 &
    P[$1`2,$1`1,$2`1] & $2`2 = i+1 &
    not ex y being set st P[$1`2,$1`1,y] & the_rank_of y in the_rank_of $2`1;
A36: for x being set st x in [:Rank beta, NAT:] ex u being set st X[x,u]
     proof
      let x be set; assume x in [:Rank beta, NAT:];
       then consider a,b being set such that
    A37: a in Rank beta and
    A38: b in NAT and
    A39: x = [a,b] by ZFMISC_1:def 2;
       reconsider b as Nat by A38;
          the_rank_of a in beta by A37,CLASSES1:74;
       then consider alfa being Ordinal such that
    A40: alfa in rng g and
    A41: the_rank_of a c= alfa by ORDINAL2:29;
    A42: a c= Rank alfa by A41,CLASSES1:73;
       consider k being set such that
    A43: k in dom g and
    A44: alfa = g.k by A40,FUNCT_1:def 5;
       reconsider k as Nat by A33,A43;
    A45: Q[k,alfa,g.(k+1)] by A35,A44;
       then reconsider O2 = g.(k+1) as Ordinal;
    A46: x`2 = b & x`1 = a by A39,MCART_1:7;
    defpred X[Ordinal] means ex y being set st y c= Rank $1 & P[x`2,x`1,y];
          a c= Rank the_rank_of alfa by A42,CLASSES1:81;
        then ex y being set st y c= Rank O2 & P[x`2,x`1,y] by A45,A46;
    then A47: ex O being Ordinal st X[O];
       consider O being Ordinal such that
    A48: X[O] and
    A49: for O' being Ordinal st X[O'] holds O c= O' from ORDINAL1:sch 1(A47);
       consider Y being set such that
    A50: Y c= Rank O and
    A51: P[b,a,Y] by A46,A48;
       take u = [Y,b+1], i = b;
       thus i = x`2 by A39,MCART_1:7;
       thus P[x`2,x`1,u`1] by A46,A51,MCART_1:7;
       thus u`2 = i+1 by MCART_1:7;
       given y being set such that
    A52: P[x`2,x`1,y] and
    A53: the_rank_of y in the_rank_of u`1;
    A54: the_rank_of y in the_rank_of Y by A53,MCART_1:7;
    A55: the_rank_of Y c= O by A50,CLASSES1:73;
          y c= Rank the_rank_of y by CLASSES1:def 8;
        then O c= the_rank_of y by A49,A52;
       hence contradiction by A54,A55,ORDINAL1:7;
     end;
  consider F being Function such that
     dom F = [:Rank beta, NAT:] and
A56: for x being set st x in [:Rank beta, NAT:] holds X[x,F.x]
       from ZFREFLE1:sch 1(A36);
  deffunc U(Nat,set) = (F.[$2,$1])`1;
  consider f being Function such that
A57: dom f = NAT and
A58: f.0 = A() and
A59: for n being Element of NAT holds f.(n+1) = U(n,f.n) from RECDEF_1:sch 3;
  take f;
  thus dom f = NAT by A57;
  thus f.0 = A() by A58;
   defpred X[Nat] means the_rank_of (f.$1) in sup rng g;
      g.0 in rng g by A33,FUNCT_1:def 5;
then A60: X[0] by A34,A58,ORDINAL2:27;
A61: for n being Element of NAT st X[n] holds X[n+1]
     proof
      let n be Element of NAT; assume
   A62:  the_rank_of (f.n) in sup rng g;
        then f.n in Rank sup rng g by CLASSES1:74;
   then A63: [f.n,n] in [:Rank beta, NAT:] by ZFMISC_1:106;
         [f.n,n]`1 = f.n & [f.n,n]`2 = n by MCART_1:7;
      then consider i being Nat such that
         i = n and
         P[n,f.n,(F.[f.n,n])`1] and
         (F.[f.n,n])`2 = i+1 and
   A64: not ex y being set st P[n,f.n,y] &
         the_rank_of y in the_rank_of (F.[f.n,n])`1 by A56,A63;
   A65: f.(n+1) = (F.[f.n,n])`1 by A59;
      consider o1 being Ordinal such that
   A66: o1 in rng g and
   A67: the_rank_of (f.n) c= o1 by A62,ORDINAL2:29;
      consider m being set such that
   A68: m in dom g and
   A69: g.m = o1 by A66,FUNCT_1:def 5;
      reconsider m as Nat by A33,A68;
      consider o2 being Ordinal such that
   A70: o2 = g.(m+1) and
   A71: for X being set, n being Nat st X c= Rank the_rank_of (g.m)
          ex Y being set st Y c= Rank o2 & P[n,X,Y] and
         for o being Ordinal st
          for X being set, n being Nat st X c= Rank the_rank_of (g.m)
          ex Y being set st Y c= Rank o & P[n,X,Y]
         holds o2 c= o by A35;
         the_rank_of (f.n) c= the_rank_of (g.m) by A67,A69,CLASSES1:81;
       then f.n c= Rank the_rank_of (g.m) by CLASSES1:73;
       then consider YY being set such that
   A72:  YY c= Rank o2 and
   A73:  P[n,f.n,YY] by A71;
          not P[n,f.n,YY] or
        not the_rank_of YY in the_rank_of (F.[f.n,n])`1 by A64;
   then A74:  the_rank_of (F.[f.n,n])`1 c= the_rank_of YY by A73,ORDINAL1:26;
          the_rank_of YY c= o2 by A72,CLASSES1:73;
   then A75:  the_rank_of (f.(n+1)) c= o2 by A65,A74,XBOOLE_1:1;
          g.(m+1) in rng g by A33,FUNCT_1:def 5;
        then o2 in sup rng g by A70,ORDINAL2:27;
       hence the_rank_of (f.(n+1)) in sup rng g by A75,ORDINAL1:22;
     end;
A76: for n being Element of NAT holds X[n] from NAT_1:sch 1(A60,A61);
A77: [A(),0]`1 = A() & [A(),0]`2 = 0 by MCART_1:7;
      the_rank_of A() in sup rng g by A58,A76;
    then A() in Rank sup rng g by CLASSES1:74;
    then [A(),0] in [:Rank beta, NAT:] by ZFMISC_1:106;
   then consider i being Nat such that
      i = [A(),0]`2 and
A78: P[0,A(),(F.[A(),0])`1] and
      (F.[A(),0])`2 = i+1 and not ex y being set st P[0,A(),y] &
       the_rank_of y in the_rank_of (F.[A(),0])`1 by A56,A77;
   defpred X[Nat] means P[$1,f.$1,f.($1+1)];
   A79: X[0] by A58,A59,A78;
A80: for n being Element of NAT st X[n] holds X[n+1]
     proof
      let n be Element of NAT; assume P[n,f.n,f.(n+1)];
   A81: [f.(n+1),n+1]`1 = f.(n+1) & [f.(n+1),n+1]`2 = n+1 by MCART_1:7;
         the_rank_of (f.(n+1)) in sup rng g by A76;
       then f.(n+1) in Rank sup rng g by CLASSES1:74;
       then [f.(n+1),n+1] in [:Rank beta, NAT:] by ZFMISC_1:106;
      then consider i being Nat such that i = n+1 and
   A82: P[n+1,f.(n+1),(F.[f.(n+1),n+1])`1] and
         (F.[f.(n+1),n+1])`2 = i+1 and
         not ex y being set st P[(n+1),f.(n+1),y] &
         the_rank_of y in the_rank_of (F.[f.(n+1),n+1])`1 by A56,A81;
      thus P[(n+1),f.(n+1),f.((n+1)+1)] by A59,A82;
     end;
  thus for n being Element of NAT holds X[n] from NAT_1:sch 1(A79,A80);
end;

theorem :: LATTICE5:1
for f being Function, F being Function-yielding Function
 st f = union rng F holds dom f = union rng doms F;

theorem :: LATTICE5:2
for A,B being non empty set holds [:union A, union B:] = union { [:a,b:]
 where a is Element of A, b is Element of B : a in A & b in B };

theorem :: LATTICE5:3
for A being non empty set st A is c=-linear holds
 [:union A, union A:] = union { [:a,a:] where a is Element of A : a in A };

begin :: An equivalence lattice of a set

reserve X for non empty set;

definition let A be set;
func EqRelLATT A -> Poset equals
:: LATTICE5:def 1
  LattPOSet EqRelLatt A;
end;


registration let A be set;
 cluster EqRelLATT A -> with_infima with_suprema;
 coherence
  proof
     LattPOSet EqRelLatt A is with_suprema with_infima;
   hence thesis by Def1;
  end;
end;


theorem :: LATTICE5:4
for A, x being set holds
 x in the carrier of EqRelLATT A iff x is Equivalence_Relation of A;

theorem :: LATTICE5:5
for A being set, x,y being Element of EqRelLatt A
 holds x [= y iff x c= y;

theorem :: LATTICE5:6
for A being set, a,b being Element of EqRelLATT A
 holds a <= b iff a c= b;

theorem :: LATTICE5:7
for L being Lattice, a,b being Element of LattPOSet L
  holds a "/\" b = %a "/\" %b;

theorem :: LATTICE5:8
for A being set, a,b being Element of EqRelLATT A
 holds a "/\" b = a /\ b;

theorem :: LATTICE5:9
for L being Lattice, a,b being Element of LattPOSet L
 holds a "\/" b = %a "\/" %b;

theorem :: LATTICE5:10
for A being set, a,b being Element of EqRelLATT A
 for E1,E2 being Equivalence_Relation of A st a = E1 & b = E2
  holds a "\/" b = E1 "\/" E2;

definition let L be non empty RelStr;
 redefine attr L is complete means
:: LATTICE5:def 2
    for X being Subset of L
   ex a being Element of L st a is_<=_than X &
   for b being Element of L st b is_<=_than X holds b <= a;
end;


registration let A be set;
cluster EqRelLATT A -> complete;
coherence
  proof
  let X be Subset of EqRelLATT A;
  set B = X /\ the carrier of EqRelLATT A;
    B c= bool [:A,A:]
    proof
    let x be set; assume x in B;
      then x in the carrier of EqRelLATT A by XBOOLE_0:def 3;
      then x is Equivalence_Relation of A by Th4;
    hence x in bool [:A,A:];
   end;
  then reconsider B as Subset-Family of [:A,A:] by SETFAM_1:def 7;
  consider b being Subset of [:A,A:] such that A1:b = Intersect(B);
A2:for Y being set st Y in B holds Y is Equivalence_Relation of A
    proof
    let Y be set; assume Y in B;
      then Y in the carrier of EqRelLATT A by XBOOLE_0:def 3;
    hence Y is Equivalence_Relation of A by Th4;
   end;
    for x being set holds x in A implies [x,x] in b
    proof
    let x be set; assume A3:x in A;
then A4:[x,x] in [:A,A:] by ZFMISC_1:def 2;
      for Y being set st Y in B holds [x,x] in Y
      proof
      let Y be set; assume Y in B;
      then Y is Equivalence_Relation of A by A2;
      hence [x,x] in Y by A3,EQREL_1:11;
     end;
    hence [x,x] in b by A1,A4,CANTOR_1:10;
   end;
then A5:b is_reflexive_in A by RELAT_2:def 1;
    reconsider b as Relation of A by RELSET_1:def 1;
A6:  dom b = A & field b = A by A5,ORDERS_1:98;
    for x,y being set st x in A & y in A & [x,y] in b holds [y,x] in b
    proof
    let x,y be set; assume A8:x in A & y in A & [x,y] in b;
then A9:[y,x] in [:A,A:] by ZFMISC_1:def 2;
      for Y being set st Y in B holds [y,x] in Y
      proof
      let Y be set; assume Y in B;
      then [x,y] in Y & Y is Equivalence_Relation of A by A1,A2,A8,CANTOR_1:10
;
      hence [y,x] in Y by EQREL_1:12;
     end;
    hence [y,x] in b by A1,A9,CANTOR_1:10;
   end;
then A10:b is_symmetric_in A by RELAT_2:def 3;
    for x,y,z being set holds x in A & y in A & z in A &
                            [x,y] in b & [y,z] in b implies [x,z] in b
    proof
    let x,y,z be set; assume that A11:x in A & y in A & z in A and
                                  A12:[x,y] in b & [y,z] in b;
A13:[x,z] in [:A,A:] by A11,ZFMISC_1:def 2;
      for Y being set st Y in B holds [x,z] in Y
      proof
      let Y be set; assume Y in B; then [x,y] in Y & [y,z] in Y &
       Y is Equivalence_Relation of A by A1,A2,A12,CANTOR_1:10;
      hence [x,z] in Y by EQREL_1:13;
     end;
    hence [x,z] in b by A1,A13,CANTOR_1:10;
   end;
  then b is_transitive_in A by RELAT_2:def 8;
  then reconsider b as Equivalence_Relation of A
                        by A6,PARTFUN1:def 4,A10,RELAT_2:def 11,def 16;
  reconsider b as Element of EqRelLATT A by Th4;
  take b;
    now let a be Element of EqRelLATT A; assume
 A14: a in X /\ the carrier of EqRelLATT A;
   reconsider a' = a as Equivalence_Relation of A by Th4;
   reconsider b' = b as Equivalence_Relation of A;
     for x,y being set holds [x,y] in b' implies [x,y] in a'
     by A1,A14,CANTOR_1:10;
   then b' c= a' by RELAT_1:def 3;
   hence b <= a by Th6;
  end;
  then b is_<=_than X /\ the carrier of EqRelLATT A by LATTICE3:def 8;
  hence b is_<=_than X by YELLOW_0:5;
   let a be Element of EqRelLATT A; assume a is_<=_than X;
then A15:  a is_<=_than X /\ the carrier of EqRelLATT A by YELLOW_0:5;
   reconsider a' = a as Equivalence_Relation of A by Th4;
A16: for d being Element of EqRelLATT A st d in B holds a' c= d
      proof
      let d be Element of EqRelLATT A;
      assume d in B; then a <= d by A15,LATTICE3:def 8;
      hence a' c= d by Th6;
     end;
     a' c= Intersect(B)
     proof
     let x be set; assume A17:x in a';
       for Y being set st Y in B holds x in Y
       proof
       let Y be set; assume A18:Y in B;
       then Y in the carrier of EqRelLATT A by XBOOLE_0:def 3;
       then a' c= Y by A16,A18;
       hence x in Y by A17;
      end;
     hence x in Intersect(B) by A17,CANTOR_1:10;
    end;
   hence a <= b by A1,Th6;
 end;
end;


begin :: A type of a sublattice of equivalence lattice of a set

registration let L1,L2 be LATTICE;
  cluster meet-preserving join-preserving map of L1,L2;
 existence
   proof
   consider z being Element of L2;
   deffunc U(set) = z;
   consider f being map of L1,L2 such that
A1:  for x being Element of L1 holds f.x = U(x) from YELLOW_2:sch 2;
   take f;
      for x,y being Element of L1 holds f.(x "/\" y) = f.x "/\" f.y
      proof
      let x,y be Element of L1;
      thus f.(x "/\" y) = z by A1 .= z "/\" z by YELLOW_5:2 .= f.x "/\" z by A1
                     .= f.x "/\" f.y by A1;
     end;
   hence f is meet-preserving by WAYBEL_6:1;
      for x,y being Element of L1 holds f.(x "\/" y) = f.x "\/" f.y
      proof
      let x,y be Element of L1;
      thus f.(x "\/" y) = z by A1 .= z "\/" z by YELLOW_5:1 .= f.x "\/" z by A1
                     .= f.x "\/" f.y by A1;
     end;
   hence f is join-preserving by WAYBEL_6:2;
  end;
end;


definition let L1,L2 be LATTICE;
 mode Homomorphism of L1,L2 is meet-preserving join-preserving map of L1,L2;
end;


registration let L be LATTICE;
  cluster meet-inheriting join-inheriting strict SubRelStr of L;
 existence
  proof
   consider a being Element of L;
   consider r be Relation of {a};
  A1: {a} c= the carrier of L
       proof let x be set; assume
            x in {a};
          then x = a by TARSKI:def 1;
        hence x in the carrier of L;
       end;
        r c= the InternalRel of L
        proof let z be set; assume z in r;
         then consider x,y be set such that
       A2: z = [x,y] & x in {a} & y in {a} by RELSET_1:6;
             x = a & y = a by A2,TARSKI:def 1;
           then z = [a,a] & a <= a by A2;
         hence z in the InternalRel of L by ORDERS_1:def 9;
        end;
   then reconsider S=RelStr(# {a}, r#) as strict SubRelStr of L
    by A1,YELLOW_0:def 13;
   take S;
A3:   for x,y being Element of L st x in {a} & y in {a} & ex_inf_of {x,y},L
       holds inf {x,y} in {a}
      proof let x,y be Element of L; assume
           x in {a} & y in {a} & ex_inf_of {x,y},L;
         then x = a & y = a by TARSKI:def 1;
         then inf {x,y} = a"/\"a by YELLOW_0:40 .= a by YELLOW_5:2;
       hence inf {x,y} in {a} by TARSKI:def 1;
      end;
       for x,y being Element of L st x in {a} & y in {a} & ex_sup_of {x,y},L
       holds sup {x,y} in {a}
      proof let x,y be Element of L; assume
           x in {a} & y in {a} & ex_sup_of {x,y},L;
         then x = a & y = a by TARSKI:def 1;
         then sup {x,y} = a"\/"a by YELLOW_0:41 .= a by YELLOW_5:1;
       hence sup {x,y} in {a} by TARSKI:def 1;
      end;
   hence thesis by A3,YELLOW_0:def 16,def 17;
  end;
end;


definition
 let L be non empty RelStr;
 mode Sublattice of L is meet-inheriting join-inheriting SubRelStr of L;
end;


definition
  let L1, L2 be LATTICE;
  let f be Homomorphism of L1,L2;
  redefine func Image f -> strict full Sublattice of L2;
end;


reserve e,e1,e2,e1',e2' for Equivalence_Relation of X,
        x,y,x',y' for set;

definition let X; let f be non empty FinSequence of X; let x,y;
           let R1, R2 be Relation;
  pred x,y are_joint_by f,R1,R2 means
:: LATTICE5:def 3
    f.1 = x & f.(len f) = y &
    for i being Nat st 1 <= i & i < len f holds
      (i is odd implies [f.i,f.(i+1)] in R1) &
      (i is even implies [f.i,f.(i+1)] in R2);
end;


canceled;

theorem :: LATTICE5:12
for x being set, o being Nat, R1,R2 being Relation,
 f being non empty FinSequence of X st
  R1 is_reflexive_in X & R2 is_reflexive_in X & f = o |-> x
  holds x,x are_joint_by f,R1,R2;

canceled;

theorem :: LATTICE5:14
for x,y being set, R1,R2 being Relation, n,m being Nat st
 (n <= m & R1 is_reflexive_in X & R2 is_reflexive_in X &
    ex f being non empty FinSequence of X st
      len f = n & x,y are_joint_by f,R1,R2)
  ex h being non empty FinSequence of X st
      len h = m & x,y are_joint_by h,R1,R2;

definition
 let X;let Y be Sublattice of EqRelLATT X;
 given e such that
 e in the carrier of Y and
 e <> id X;
 given o being Nat such that
 for e1,e2,x,y st e1 in the carrier of Y & e2 in the carrier of Y &
                     [x,y] in e1 "\/" e2 holds
     ex F being non empty FinSequence of X st
      len F = o & x,y are_joint_by F,e1,e2;
 func type_of Y -> Nat means
:: LATTICE5:def 4
 (for e1,e2,x,y st e1 in the carrier of Y & e2 in the carrier of Y &
                       [x,y] in e1 "\/" e2 holds
     (ex F being non empty FinSequence of X st
         len F = it+2 & x,y are_joint_by F,e1,e2)) &
 (ex e1,e2,x,y st e1 in the carrier of Y & e2 in the carrier of Y &
                      [x,y] in e1 "\/" e2 &
 not (ex F being non empty FinSequence of X st
     len F = it+1 & x,y are_joint_by F,e1,e2));
end;


theorem :: LATTICE5:15
for Y being Sublattice of EqRelLATT X, n being Nat st
 (ex e st e in the carrier of Y & e <> id X) &
 (for e1,e2,x,y st e1 in the carrier of Y & e2 in the carrier of Y &
    [x,y] in e1 "\/" e2 holds
   (ex F being non empty FinSequence of X st
     len F = n+2 & x,y are_joint_by F,e1,e2))
  holds type_of Y <= n;

begin :: A meet-representation of a lattice

reserve A for non empty set,
        L for lower-bounded LATTICE;

definition let A, L;
 mode BiFunction of A,L is Function of [:A,A:],the carrier of L;
 canceled;
end;


definition let A, L;
 let f be BiFunction of A,L;let x,y be Element of A;
 redefine func f.(x,y) -> Element of L;
end;


definition let A, L; let f be BiFunction of A,L;
attr f is symmetric means
:: LATTICE5:def 6
 for x,y being Element of A holds f.(x,y) = f.(y,x);
attr f is zeroed means
:: LATTICE5:def 7
 for x being Element of A holds f.(x,x) = Bottom L;
attr f is u.t.i. means
:: LATTICE5:def 8
 for x,y,z being Element of A holds f.(x,y) "\/" f.(y,z) >= f.(x,z);
end;


:: f is u.t.i. means that f satisfies the triangle inequality

registration let A, L;
 cluster symmetric zeroed u.t.i. BiFunction of A,L;
existence
  proof
   deffunc U(Element of A,Element of A) = Bottom L;
  consider f being Function of [:A,A:],the carrier of L such that
A1:for x,y being Element of A holds f.[x,y] = U(x,y) from FUNCT_2:sch 8;
  reconsider f as BiFunction of A,L;
A2:for x,y being Element of A holds f.(x,y) = Bottom L
    proof
    let x,y be Element of A;
    reconsider x' = x as set; reconsider y' = y as set;
      Bottom L = f.[x,y] by A1 .= f.(x',y') by BINOP_1:def 1;
    hence thesis;
   end;
    for x,y being Element of A holds f.(x,y) = f.(y,x)
    proof
    let x,y be Element of A;
    thus f.(x,y) = Bottom L by A2 .= f.(y,x) by A2;
   end;
then A3:f is symmetric by Def6;
    for x being Element of A holds f.(x,x) = Bottom L by A2;
then A4:f is zeroed by Def7;
    for x,y,z being Element of A holds f.(x,y) "\/" f.(y,z) >= f.(x,z)
    proof
    let x,y,z be Element of A;
  A5: f.(x,y) = Bottom L & f.(y,z) = Bottom L by A2;
        f.(x,z) <= Bottom L by A2;
    hence thesis by A5,YELLOW_5:1;
   end;
   then f is u.t.i. by Def8;
  hence thesis by A3,A4;
 end;
end;


definition let A, L;
 mode distance_function of A,L is symmetric zeroed u.t.i. BiFunction of A,L;
end;


definition let A, L; let d be distance_function of A,L;
 func alpha d -> map of L,EqRelLATT A means
:: LATTICE5:def 9
  for e being Element of L
   ex E being Equivalence_Relation of A st E = it.e &
   for x,y be Element of A holds [x,y] in E iff d.(x,y) <= e;
end;


theorem :: LATTICE5:16
for d being distance_function of A,L holds alpha d is meet-preserving;

theorem :: LATTICE5:17
for d being distance_function of A,L st d is onto holds alpha d is one-to-one;

begin :: J\'onsson theorem

definition let A be set;
 func new_set A equals
:: LATTICE5:def 10
  A \/ {{A}, {{A}}, {{{A}}} };
end;


registration let A be set;
 cluster new_set A -> non empty;
coherence
  proof
     {A} in {{A}, {{A}}, {{{A}}}} by ENUMSET1:14;
   then {A} in A \/ {{A}, {{A}}, {{{A}}}} by XBOOLE_0:def 2;
   hence new_set A is non empty by Def10;
 end;
end;


definition let A,L; let d be BiFunction of A,L;
  let q be Element of [:A,A,the carrier of L,the carrier of L:];
func new_bi_fun(d,q) -> BiFunction of new_set A,L means
:: LATTICE5:def 11
 (for u,v being Element of A holds it.(u,v) = d.(u,v) ) &
 it.({A},{A}) = Bottom L & it.({{A}},{{A}}) = Bottom
L & it.({{{A}}},{{{A}}}) = Bottom L &
 it.({{A}},{{{A}}}) = q`3 & it.({{{A}}},{{A}}) = q`3 &
 it.({A},{{A}}) = q`4 & it.({{A}},{A}) = q`4 &
 it.({A},{{{A}}}) = q`3"\/"q`4 & it.({{{A}}},{A}) = q`3"\/"q`4 &
 for u being Element of A holds
  (it.(u,{A}) = d.(u,q`1)"\/"q`3 & it.({A},u) = d.(u,q`1)"\/"q`3 &
  it.(u,{{A}}) = d.(u,q`1)"\/"q`3"\/"q`4 & it.({{A}},u) = d.(u,q`1)"\/"q`3"\/"
q`4 &
  it.(u,{{{A}}}) = d.(u,q`2)"\/"q`4 & it.({{{A}}},u) = d.(u,q`2)"\/"q`4);
end;


theorem :: LATTICE5:18
for d being BiFunction of A,L st d is zeroed
 for q being Element of [:A,A,the carrier of L,the carrier of L:]
  holds new_bi_fun(d,q) is zeroed;

theorem :: LATTICE5:19
for d being BiFunction of A,L st d is symmetric
 for q being Element of [:A,A,the carrier of L,the carrier of L:]
  holds new_bi_fun(d,q) is symmetric;

theorem :: LATTICE5:20
for d being BiFunction of A,L st d is symmetric & d is u.t.i.
 for q being Element of [:A,A,the carrier of L,the carrier of L:]
  st d.(q`1,q`2) <= q`3"\/"q`4
  holds new_bi_fun(d,q) is u.t.i.;

theorem :: LATTICE5:21
for A be set holds A c= new_set A;

theorem :: LATTICE5:22
for d be BiFunction of A,L
 for q be Element of [:A,A,the carrier of L,the carrier of L:]
  holds d c= new_bi_fun(d,q);

definition let A,L; let d be BiFunction of A,L;
 func DistEsti(d) -> Cardinal means
:: LATTICE5:def 12
   it,{ [x,y,a,b] where x is Element of A, y is Element of A,
   a is Element of L, b is Element of L: d.(x,y) <= a"\/"b} are_equipotent;
end;


theorem :: LATTICE5:23
 for d be distance_function of A,L holds DistEsti(d) <> {};

reserve T,L1,LL for T-Sequence, O,O1,O2,O3,C for Ordinal;

definition let A; let O;
 func ConsecutiveSet(A,O) means
:: LATTICE5:def 13
  ex L0 being T-Sequence st it = last L0 & dom L0 = succ O &
   L0.{} = A &
   (for C being Ordinal st
    succ C in succ O holds L0.succ C = new_set L0.C) &
      for C being Ordinal st C in succ O & C <> {} & C is_limit_ordinal
             holds L0.C = union rng (L0|C);
end;


theorem :: LATTICE5:24
ConsecutiveSet(A,{}) = A;

theorem :: LATTICE5:25
ConsecutiveSet(A,succ O) = new_set ConsecutiveSet(A,O);

theorem :: LATTICE5:26
O <> {} & O is_limit_ordinal & dom T = O &
 (for O1 being Ordinal st O1 in O holds T.O1 = ConsecutiveSet(A,O1))
  implies ConsecutiveSet(A,O) = union rng T;

registration let A; let O;
 cluster ConsecutiveSet(A,O) -> non empty;
coherence proof
   defpred X[Ordinal] means ConsecutiveSet(A,$1) is non empty;
A1: X[{}] by Th24;
A2: for O st X[O] holds X[succ O]
    proof let O1; assume ConsecutiveSet(A,O1) is non empty;
      ConsecutiveSet(A,succ O1) = new_set ConsecutiveSet(A,O1) by Th25;
    hence ConsecutiveSet(A,succ O1) is non empty;
   end;
A3: for O st O <> {} & O is_limit_ordinal &
      for B being Ordinal st B in O holds X[B] holds X[O]
   proof let O1; assume
  A4: O1 <> {} & O1 is_limit_ordinal &
     for O2 st O2 in O1 holds ConsecutiveSet(A,O2) is non empty;
     deffunc U(Ordinal) = ConsecutiveSet(A,$1);
     consider Ls being T-Sequence such that
  A5: dom Ls = O1 & for O2 being Ordinal st O2 in O1 holds
         Ls.O2 = U(O2) from ORDINAL2:sch 2;
  A6: ConsecutiveSet(A,O1) = union rng Ls by A4,A5,Th26;
  A7: {} in O1 by A4,ORDINAL3:10;
     then Ls.{} = ConsecutiveSet(A,{}) by A5 .= A by Th24;
     then A in rng Ls by A5,A7,FUNCT_1:def 5;
  then A8: A c= ConsecutiveSet(A,O1) by A6,ZFMISC_1:92;
     consider x being set such that A9:x in A by XBOOLE_0:def 1;
     thus ConsecutiveSet(A,O1) is non empty by A8,A9;
    end;
    for O holds X[O] from ORDINAL2:sch 1(A1,A2,A3);
  hence thesis;
 end;
end;


theorem :: LATTICE5:27
A c= ConsecutiveSet(A,O);

definition let A,L; let d be BiFunction of A,L;
 mode QuadrSeq of d -> T-Sequence of [:A,A,the carrier of L,the carrier of L:]
  means
:: LATTICE5:def 14
   dom it is Cardinal &
   it is one-to-one &
   rng it ={[x,y,a,b] where x is Element of A, y is Element of A,
          a is Element of L, b is Element of L: d.(x,y) <= a"\/"b};
end;


definition let A,L; let d be BiFunction of A,L; let q be QuadrSeq of d;
 let O;
assume  O in dom q;
 func Quadr(q,O) -> Element of [:ConsecutiveSet(A,O),ConsecutiveSet(A,O),
       the carrier of L,the carrier of L:] equals
:: LATTICE5:def 15
  q.O;
end;


theorem :: LATTICE5:28
for d being BiFunction of A,L, q being QuadrSeq of d holds
  O in DistEsti(d) iff O in dom q;

definition let A,L;
 let z be set;
 assume
  z is BiFunction of A,L;
 func BiFun(z,A,L) -> BiFunction of A,L equals
:: LATTICE5:def 16
  z;
end;


definition let A,L; let d be BiFunction of A,L; let q be QuadrSeq of d;
           let O;
 func ConsecutiveDelta(q,O) means
:: LATTICE5:def 17
  ex L0 being T-Sequence st it = last L0 & dom L0 = succ O &
   L0.{} = d &
   (for C being Ordinal st succ C in succ O holds
    L0.succ C = new_bi_fun(BiFun(L0.C,ConsecutiveSet(A,C),L),Quadr(q,C))) &
      for C being Ordinal st C in succ O & C <> {} & C is_limit_ordinal
             holds L0.C = union rng(L0|C);
end;


theorem :: LATTICE5:29
for d being BiFunction of A,L for q being QuadrSeq of d
  holds ConsecutiveDelta(q,{}) = d;

theorem :: LATTICE5:30
for d be BiFunction of A,L for q being QuadrSeq of d holds
 ConsecutiveDelta(q,succ O) = new_bi_fun(BiFun(ConsecutiveDelta(q,O),
   ConsecutiveSet(A,O),L),Quadr(q,O));

theorem :: LATTICE5:31
for d be BiFunction of A,L for q being QuadrSeq of d holds
 O <> {} & O is_limit_ordinal & dom T = O &
 (for O1 being Ordinal st O1 in O holds T.O1 = ConsecutiveDelta(q,O1))
 implies ConsecutiveDelta(q,O) = union rng T;

theorem :: LATTICE5:32
O1 c= O2 implies ConsecutiveSet(A,O1) c= ConsecutiveSet(A,O2);

theorem :: LATTICE5:33
for d be BiFunction of A,L for q being QuadrSeq of d
 holds ConsecutiveDelta(q,O) is BiFunction of ConsecutiveSet(A,O),L;

definition let A,L; let d be BiFunction of A,L; let q be QuadrSeq of d;
           let O;
  redefine func ConsecutiveDelta(q,O) -> BiFunction of ConsecutiveSet(A,O),L;
end;


theorem :: LATTICE5:34
for d be BiFunction of A,L for q being QuadrSeq of d holds
 d c= ConsecutiveDelta(q,O);

theorem :: LATTICE5:35
 for d being BiFunction of A,L for q being QuadrSeq of d st O1 c= O2 holds
   ConsecutiveDelta(q,O1) c= ConsecutiveDelta(q,O2);

theorem :: LATTICE5:36
for d be BiFunction of A,L st d is zeroed
 for q being QuadrSeq of d holds ConsecutiveDelta(q,O) is zeroed;

theorem :: LATTICE5:37
for d be BiFunction of A,L st d is symmetric
 for q being QuadrSeq of d holds ConsecutiveDelta(q,O) is symmetric;

theorem :: LATTICE5:38
for d be BiFunction of A,L st d is symmetric u.t.i.
 for q being QuadrSeq of d st O c= DistEsti(d) holds
  ConsecutiveDelta(q,O) is u.t.i.;

theorem :: LATTICE5:39
  for d being distance_function of A,L
 for q being QuadrSeq of d st O c= DistEsti(d) holds
  ConsecutiveDelta(q,O) is distance_function of ConsecutiveSet(A,O),L;

definition let A,L; let d be BiFunction of A,L;
 func NextSet(d) equals
:: LATTICE5:def 18
  ConsecutiveSet(A,DistEsti(d));
end;


registration let A,L; let d be BiFunction of A,L;
 cluster NextSet(d) -> non empty;
 coherence proof
    ConsecutiveSet(A,DistEsti(d)) is non empty;
  hence thesis by Def18;
 end;
end;


definition let A,L; let d be BiFunction of A,L; let q be QuadrSeq of d;
 func NextDelta(q) equals
:: LATTICE5:def 19
  ConsecutiveDelta(q,DistEsti(d));
end;


definition let A,L; let d be distance_function of A,L; let q be QuadrSeq of d;
redefine func NextDelta(q) -> distance_function of NextSet(d),L;
end;


definition let A,L; let d be distance_function of A,L;
           let Aq be non empty set, dq be distance_function of Aq,L;
  pred Aq, dq is_extension_of A,d means
:: LATTICE5:def 20
   ex q being QuadrSeq of d st Aq = NextSet(d) & dq = NextDelta(q);
end;


theorem :: LATTICE5:40
for d be distance_function of A,L
for Aq be non empty set, dq be distance_function of Aq,L
   st Aq, dq is_extension_of A,d
  for x,y being Element of A, a,b being Element of L st d.(x,y) <= a "\/" b
    ex z1,z2,z3 being Element of Aq st
    dq.(x,z1) = a & dq.(z2,z3) = a & dq.(z1,z2) = b & dq.(z3,y) = b;

definition let A,L; let d be distance_function of A,L;
mode ExtensionSeq of A,d -> Function means
:: LATTICE5:def 21
   dom it = NAT & it.0 = [A,d] &
    for n being Nat holds
    ex A' being non empty set, d' being distance_function of A',L,
       Aq being non empty set, dq being distance_function of Aq,L st
     Aq, dq is_extension_of A',d' & it.n = [A',d'] & it.(n+1) = [Aq,dq];
end;


theorem :: LATTICE5:41
 for d be distance_function of A,L for S being ExtensionSeq of A,d
 for k,l being Nat st k <= l holds (S.k)`1 c= (S.l)`1;

theorem :: LATTICE5:42
 for d be distance_function of A,L for S being ExtensionSeq of A,d
 for k,l being Nat st k <= l holds (S.k)`2 c= (S.l)`2;

definition let L;
func BasicDF(L) -> distance_function of the carrier of L,L means
:: LATTICE5:def 22
 for x,y being Element of L holds
  (x <> y implies it.(x,y) = x"\/"y) &
  (x = y implies it.(x,y) = Bottom L);
end;


theorem :: LATTICE5:43
BasicDF(L) is onto;

theorem :: LATTICE5:44
  for S being ExtensionSeq of the carrier of L, BasicDF(L)
  for FS being non empty set st
    FS = union { (S.i)`1 where i is Nat: not contradiction} holds
  union { (S.i)`2 where i is Nat: not contradiction}
   is distance_function of FS,L;

theorem :: LATTICE5:45
  for S being ExtensionSeq of the carrier of L, BasicDF(L)
  for FS being non empty set,
      FD being distance_function of FS,L
 for x,y being Element of FS for a,b being Element of L st
 FS = union { (S.i)`1 where i is Nat: not contradiction} &
 FD = union { (S.i)`2 where i is Nat: not contradiction} &
 FD.(x,y) <= a"\/"b
  ex z1,z2,z3 being Element of FS st FD.(x,z1) = a & FD.(z2,z3) = a &
   FD.(z1,z2) = b & FD.(z3,y) = b;

theorem :: LATTICE5:46
  for S being ExtensionSeq of the carrier of L, BasicDF(L)
  for FS being non empty set
  for FD being distance_function of FS,L
  for f being Homomorphism of L,EqRelLATT FS
  for x, y being Element of FS
  for e1,e2 being Equivalence_Relation of FS,x,y st f = alpha FD &
    FS = union { (S.i)`1 where i is Nat: not contradiction} &
    FD = union { (S.i)`2 where i is Nat: not contradiction} &
       e1 in the carrier of Image f & e2 in the carrier of Image f &
       [x,y] in e1 "\/" e2
      ex F being non empty FinSequence of FS st
           len F = 3+2 & x,y are_joint_by F,e1,e2;

theorem :: LATTICE5:47
  ex A being non empty set, f being Homomorphism of L,EqRelLATT A st
  f is one-to-one & type_of Image f <= 3;
