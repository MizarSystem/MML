:: Similarity of Formulae
::  by Agata Darmochwa{\l} and Andrzej Trybulec
::
:: Received November 22, 1991
:: Copyright (c) 1991 Association of Mizar Users

environ

 vocabulary FUNCT_1, FUNCT_4, FUNCOP_1, RELAT_1, BOOLE, CQC_LANG, QC_LANG1,
      ZF_LANG, FINSEQ_1, FUNCT_2, FINSUB_1, SQUARE_1, FINSET_1, QC_LANG3,
      GROUP_2, PRE_TOPC, PARTFUN1, SETWISEO, SETFAM_1, SUBSET_1, CQC_SIM1;
 notation TARSKI, XBOOLE_0, ZFMISC_1, SUBSET_1, NUMBERS, XREAL_0, DOMAIN_1,
      MCART_1, SETFAM_1, RELAT_1, RELSET_1, FUNCT_1, FUNCT_2, PARTFUN1,
      FUNCOP_1, FINSEQ_1, FINSET_1, FINSUB_1, FRAENKEL, NAT_1, SETWISEO,
      QC_LANG1, QC_LANG2, QC_LANG3, CQC_LANG, FUNCT_4;
 constructors DOMAIN_1, SETFAM_1, FUNCOP_1, FRAENKEL, NAT_1, SETWISEO,
      QC_LANG3, CQC_LANG, FUNCT_4, PARTFUN1, XREAL_0, MEMBERED, RELAT_2,
      XBOOLE_0;
 clusters SUBSET_1, RELSET_1, CQC_LANG, QC_LANG1, FINSUB_1, FUNCOP_1, FINSEQ_1,
      ARYTM_3, MEMBERED, ZFMISC_1, FUNCT_2, PARTFUN1, XBOOLE_0, ORDINAL2;
 requirements NUMERALS, REAL, BOOLE, SUBSET;


begin

theorem :: CQC_SIM1:1
 for x,y being set, f being Function holds (f+*({x} --> y)).:{x} = {y};

theorem :: CQC_SIM1:2
 for K,L being set
 for x,y being set, f being Function holds (f+*(L --> y)).:K c= f.:K \/ {y};

theorem :: CQC_SIM1:3
  for x,y being set, g being Function, A being set
   holds (g +* ({x} --> y)).:(A \ {x}) = g.:(A \ {x});

theorem :: CQC_SIM1:4
  for x,y being set
  for g being Function
  for A being set st not y in g.:(A \ {x}) holds
    (g +* ({x} --> y)).:(A \ {x}) = (g +* ({x} --> y)).:A \ {y};

reserve p,q,r,s for Element of CQC-WFF,
        x for Element of bound_QC-variables,
        i,j,k,l,m,n for Element of NAT,
        a,b,e for set,
        ll for CQC-variable_list of k,
        P for QC-pred_symbol of k;

theorem :: CQC_SIM1:5
p is atomic implies ex k,P,ll st p = P!ll;


theorem :: CQC_SIM1:6
   p is negative implies ex q st p = 'not' q;

theorem :: CQC_SIM1:7
   p is conjunctive implies ex q,r st p = q '&' r;

theorem :: CQC_SIM1:8
   p is universal implies ex x,q st p = All(x,q);

theorem :: CQC_SIM1:9
for l being FinSequence holds
  rng l = { l.i : 1 <= i & i <= len l };

scheme :: CQC_SIM1:sch 1
 QC_Func_ExN { D() -> non empty set,
                V() -> Element of D(),
                A(set) -> Element of D(),
                N(set,set) -> Element of D(),
                C(set,set,set) -> Element of D(),
                Q(set,set) -> Element of D()} :
ex F being Function of QC-WFF, D() st
    F.VERUM = V() &
        for p being Element of QC-WFF holds
        (p is atomic implies F.p = A(p)) &
        (p is negative implies F.p = N(F.the_argument_of p,p)) &
        (p is conjunctive implies
          F.p = C(F.the_left_argument_of p, F.the_right_argument_of p, p)) &
        (p is universal implies F.p = Q(F.the_scope_of p, p))
proof

defpred Pfgp[Element of D(),
          Function of QC-WFF, D(),
           Element of QC-WFF] means
      ($3 = VERUM implies $1 = V()) &
      ($3 is atomic implies $1 = A($3)) &
      ($3 is negative implies $1 = N($2.the_argument_of $3, $3)) &
      ($3 is conjunctive implies
           $1 = C($2.the_left_argument_of $3,
                     $2.the_right_argument_of $3, $3)) &
      ($3 is universal implies $1 = Q($2.the_scope_of $3,$3));
defpred Pfn[Function of QC-WFF, D(), Nat] means
      for p being Element of QC-WFF st len @p <= $2 holds
      (p = VERUM implies $1.p = V()) &
      (p is atomic implies $1.p = A(p)) &
      (p is negative implies $1.p = N($1.the_argument_of p, p)) &
      (p is conjunctive implies
           $1.p = C($1.the_left_argument_of p, $1.the_right_argument_of p, p))
    & (p is universal implies $1.p = Q($1.the_scope_of p, p));
defpred S[Nat] means ex F being Function of QC-WFF, D() st Pfn[F, $1];
A1: S[0]
    proof
     consider F being Function of QC-WFF, D();
     take F;
     let p be Element of QC-WFF such that
    A2: len @p <= 0;
          1 <= len @p by QC_LANG1:34;
        hence thesis by A2,AXIOMS:22;
    end;
A3: for n be Nat st S[n] holds S[n+1]
   proof let n be Nat;
       given F being Function of QC-WFF, D() such that
  A4: Pfn[F, n];
     defpred P[Element of QC-WFF,Element of D()] means
      (len @$1 <> n+1 implies $2 = F.$1) &
      (len @$1 = n+1 implies Pfgp[$2, F, $1]);
  A5:  for x being Element of QC-WFF ex y being Element of D() st P[x,y]
      proof let p be Element of QC-WFF;
        now per cases by QC_LANG1:33;
        case len @p <> n+1;
         take y = F.p;
         thus y =F.p;
        end;
        case A6:len @p = n+1 & p = VERUM;
         take y = V();
         thus Pfgp[y, F, p] by A6,QC_LANG1:51;
        end;
        case A7: len @p = n+1 & p is atomic;
         take y = A(p);
         thus Pfgp[y, F, p] by A7,QC_LANG1:51;
        end;
        case A8: len @p = n+1 & p is negative;
         take y = N(F.the_argument_of p, p);
         thus Pfgp[y, F, p] by A8,QC_LANG1:51;
        end;
        case A9: len @p = n+1 & p is conjunctive;
         take y = C(F.the_left_argument_of p, F.the_right_argument_of p, p);
         thus Pfgp[y, F, p] by A9,QC_LANG1:51;
        end;
        case A10: len @p = n+1 & p is universal;
         take y = Q(F.the_scope_of p, p);
         thus Pfgp[y, F, p] by A10,QC_LANG1:51;
      end;
      end;
      hence ex y being Element of D() st
                (len @p <> n+1 implies y = F.p) &
                (len @p = n+1 implies Pfgp[y, F, p]);
     end;
     consider G being Function of QC-WFF, D() such that
   A11:      for p being Element of QC-WFF holds P[p,G.p] from FUNCT_2:sch 3
 (A5);
       take H = G;
     thus Pfn[H, n+1]
    proof
      let p be Element of QC-WFF such that
   A12: len @p <= n+1;
      thus p = VERUM implies H.p = V()
        proof
           now per cases;
          suppose A13: len @p <> n+1; then A14: len @p <= n by A12,NAT_1:26;
                  H.p = F.p by A11,A13;
           hence thesis by A4,A14;
          end;
          suppose len @p = n+1;
           hence thesis by A11;
         end;
         end;
        hence thesis;
        end;
     thus p is atomic implies H.p = A(p)
        proof
           now per cases;
          suppose A15: len @p <> n+1; then A16: len @p <= n by A12,NAT_1:26;
                  H.p = F.p by A11,A15;
           hence thesis by A4,A16;
          end;
          suppose len @p = n+1;
           hence thesis by A11;
         end;
         end;
        hence thesis;
        end;
     thus p is negative implies H.p = N(H.the_argument_of p,p)
        proof assume A17: p is negative;
          then len @the_argument_of p <> n+1 by A12,QC_LANG1:45;
        then A18:  H.the_argument_of p = F.the_argument_of p by A11;
           now per cases;
          suppose A19: len @p <> n+1; then A20: len @p <= n by A12,NAT_1:26;
              H.p = F.p by A11,A19;
           hence thesis by A4,A17,A18,A20;
          end;
          suppose len @p = n+1;
           hence thesis by A11,A17,A18;
         end;
         end;
        hence thesis;
        end;
      thus p is conjunctive implies
           H.p = C(H.the_left_argument_of p, H.the_right_argument_of p, p)
        proof assume A21: p is conjunctive;
          then len @the_left_argument_of p <> n+1 by A12,QC_LANG1:46;
        then A22:  H.the_left_argument_of p = F.the_left_argument_of p by A11;
            len @the_right_argument_of p <> n+1 by A12,A21,QC_LANG1:46;
        then A23: H.the_right_argument_of p = F.the_right_argument_of p by A11;
           now per cases;
          suppose A24: len @p <> n+1; then A25: len @p <= n by A12,NAT_1:26;
                  H.p = F.p by A11,A24;
           hence thesis by A4,A21,A22,A23,A25;
          end;
          suppose len @p = n+1;
           hence thesis by A11,A21,A22,A23;
         end;
         end;
        hence thesis;
        end;
      thus p is universal implies H.p = Q(H.the_scope_of p, p)
        proof assume A26: p is universal;
          then len @the_scope_of p <> n+1 by A12,QC_LANG1:47;
        then A27:  H.the_scope_of p = F.the_scope_of p by A11;
           now per cases;
          suppose A28: len @p <> n+1; then A29: len @p <= n by A12,NAT_1:26;
                  H.p = F.p by A11,A28;
           hence H.p = Q(H.the_scope_of p, p) by A4,A26,A27,A29;
          end;
          suppose len @p = n+1;
           hence H.p = Q(H.the_scope_of p, p) by A11,A26,A27;
         end;
         end;
        hence thesis;
        end;
     end;
   end;

A30: for n being Nat holds S[n] from NAT_1:sch 1 (A1, A3);

defpred Qfn[set, set] means
        ex p being Element of QC-WFF st p = $1 &
          for g being Function of QC-WFF, D() st Pfn[g, len @p] holds $2 = g.p;

A31: for x being set st x in QC-WFF ex y being set st Qfn[x, y]
   proof let x be set; assume x in QC-WFF;
       then reconsider x' = x as Element of QC-WFF;
       consider F being Function of QC-WFF, D() such that
   A32: Pfn[F, len @x'] by A30;
       take F.x, x';
       thus x = x';
       let G be Function of QC-WFF, D() such that
   A33: Pfn[G, len @x'];

   defpred Prop[Element of QC-WFF] means
             len @$1 <= len@x' implies F.$1 = G.$1;
   A34: now
        let p be Element of QC-WFF;
        thus p is atomic implies Prop[p]
         proof assume that
         A35: p is atomic and
         A36: len @p <= len@x';
           thus F.p = A(p) by A32,A35,A36
                   .= G.p by A33,A35,A36;
         end;
        thus Prop[VERUM]
         proof assume
          A37: len @VERUM <= len @x';
          hence F.VERUM = V() by A32
                      .= G.VERUM by A33,A37;
         end;
        thus p is negative & Prop[the_argument_of p] implies Prop[p]
         proof assume that
          A38: p is negative and
          A39: Prop[the_argument_of p] and
          A40: len @p <= len @x';
            len @the_argument_of p < len @p by A38,QC_LANG1:45;
          hence F.p = N(G.the_argument_of p, p) by A32,A38,A39,A40,AXIOMS:22
                  .= G.p by A33,A38,A40;
         end;
        thus (p is conjunctive & Prop[the_left_argument_of p] &
                Prop[the_right_argument_of p] implies Prop[p])
         proof assume that
          A41: p is conjunctive and
          A42: Prop[the_left_argument_of p] and
         A43: Prop[the_right_argument_of p] and
          A44: len @p <= len @x';
A45:          len @the_left_argument_of p < len @p by A41,QC_LANG1:46;
            len @the_right_argument_of p < len @p by A41,QC_LANG1:46;
         hence F.p = C(G.the_left_argument_of p, G.the_right_argument_of p, p)
                       by A32,A41,A42,A43,A44,A45,AXIOMS:22
                  .= G.p by A33,A41,A44;
         end;
        thus (p is universal & Prop[the_scope_of p] implies Prop[p])
         proof assume that
          A46: p is universal and
          A47: Prop[the_scope_of p] and
          A48: len @p <= len @x';
            len @the_scope_of p < len @p by A46,QC_LANG1:47;
          hence F.p = Q(G.the_scope_of p, p) by A32,A46,A47,A48,AXIOMS:22
                  .= G.p by A33,A46,A48;
         end;
       end;
      for p being Element of QC-WFF holds Prop[p] from QC_LANG1:sch 2 (A34);
       hence F.x = G.x';
   end;

 consider F being Function such that
A49: dom F = QC-WFF and
A50: for x being set st x in
 QC-WFF holds Qfn[x, F.x] from ZFREFLE1:sch 1 (A31);
  F is Function of QC-WFF, D()
 proof
    rng F c= D()
  proof
    let y be set; assume
     y in rng F;
    then consider x being set such that
  A51: x in QC-WFF and
  A52: y = F.x by A49,FUNCT_1:def 5;
      consider p being Element of QC-WFF such that
        p = x and
  A53: for g being Function of QC-WFF, D() st Pfn[g, len @p] holds
       y = g.p by A50,A51,A52;
    consider G being Function of QC-WFF, D() such that
  A54: Pfn[G, len @p] by A30;
        y = G.p by A53,A54;
    hence y in D();
  end;
  hence thesis by A49,FUNCT_2:def 1,RELSET_1:11;
 end;
then reconsider F as Function of QC-WFF, D();
take F;
 consider p1 being Element of QC-WFF such that
A55: p1 = VERUM and
A56: for g being Function of QC-WFF, D() st Pfn[g, len @p1]
       holds F.VERUM = g.p1 by A50;
 consider G being Function of QC-WFF, D() such that
A57: Pfn[G, len @p1] by A30;
   F.VERUM = G.VERUM by A55,A56,A57;
  hence F.VERUM = V() by A55,A57;
 let p be Element of QC-WFF;
 consider p1 being Element of QC-WFF such that
A55: p1 = p and
A56: for g being Function of QC-WFF, D() st Pfn[g, len @p1] holds F.p = g.p1
by A50;
 consider G being Function of QC-WFF, D() such that
A57: Pfn[G, len @p1] by A30;
A58: F.p = G.p by A55,A56,A57;
  thus p is atomic implies F.p = A(p) by A55,A57,A58;
  A59: for k being Nat st k < len @p holds Pfn[G, k]
        proof let k be Nat; assume
A60:            k < len @p;
          let p' be Element of QC-WFF; assume
             len @p' <= k;
           then len @p' <= len@p by A60,AXIOMS:22;
         hence thesis by A55,A57;
        end;
  thus p is negative implies F.p = N(F.the_argument_of p, p)
        proof assume
        A61: p is negative;
             set p' = the_argument_of p;
             set k = len @p';
               k < len @p by A61,QC_LANG1:45;
        then A62: Pfn[G, k] by A59;
               ex p1 being Element of QC-WFF st p1 = p' &
 for g being Function of QC-WFF, D() st Pfn[g, len @p1] holds
                F.p' = g.p1 by A50;
             then F.p' = G.p' by A62;
         hence thesis by A55,A57,A58,A61;
        end;
  thus p is conjunctive implies
          F.p = C(F.the_left_argument_of p, F.the_right_argument_of p, p)
        proof assume
        A63: p is conjunctive;
             set p' = the_left_argument_of p;
             set k' = len @p';
             set p'' = the_right_argument_of p;
             set k'' = len @p'';
               k' < len @p by A63,QC_LANG1:46;
        then A64: Pfn[G, k'] by A59;
               k'' < len @p by A63,QC_LANG1:46;
       then A65: Pfn[G, k''] by A59;
A66:             ex p1 being Element of QC-WFF st p1 = p' &
 for g being Function of QC-WFF, D() st Pfn[g, len @p1] holds
                F.p' = g.p1 by A50;
A67:             ex p2 being Element of QC-WFF st p2 = p'' &
 for g being Function of QC-WFF, D() st Pfn[g, len @p2] holds
                F.p'' = g.p2 by A50;
        A68: F.p' = G.p' by A64,A66;
               F.p'' = G.p'' by A65,A67;
         hence thesis by A55,A57,A58,A63,A68;
        end;
  assume
   A69: p is universal;
        set p' = the_scope_of p;
        set k = len @p';
          k < len @p by A69,QC_LANG1:47;
   then A70: Pfn[G, k] by A59;
          ex p1 being Element of QC-WFF st p1 = p' &
 for g being Function of QC-WFF, D() st Pfn[g, len @p1] holds
                         F.p' = g.p1 by A50;
        then F.p' = G.p' by A70;
  hence thesis by A55,A57,A58,A69;
end;

scheme :: CQC_SIM1:sch 2
 CQCF2_Func_Ex { D, E() -> non empty set,
                V() -> Element of Funcs(D(),E()),
                A(set,set,set) -> Element of Funcs(D(),E()),
                N(set,set) -> Element of Funcs(D(),E()),
                C(set,set,set,set) -> Element of Funcs(D(),E()),
                Q(set,set,set) -> Element of Funcs(D(),E()) }:
  ex F being Function of CQC-WFF, Funcs(D(),E()) st
   F.VERUM = V() &
   (for k for l being CQC-variable_list of k
    for P being QC-pred_symbol of k holds F.(P!l) = A(k,P,l)) &
   for r,s,x holds
      F.('not' r) = N(F.r,r) &
      F.(r '&' s) = C(F.r,F.s,r,s) &
      F.All(x,r) = Q(x,F.r,r)
proof
  deffunc a(Element of QC-WFF) = A(the_arity_of the_pred_symbol_of $1,
                 the_pred_symbol_of $1,the_arguments_of $1);
  deffunc n(set,Element of QC-WFF) = N($1,the_argument_of $2);
  deffunc c(set,set,Element of QC-WFF) = C($1,$2,
              the_left_argument_of $3,the_right_argument_of $3);
  deffunc q(set,Element of QC-WFF) = Q(bound_in $2,$1,the_scope_of $2);
consider F being Function of QC-WFF, Funcs(D(),E()) such that
A1: F.VERUM = V() &
  for p being Element of QC-WFF holds
        (p is atomic implies F.p = a(p)) &
        (p is negative implies F.p = n(F.the_argument_of p,p)) &
        (p is conjunctive implies
         F.p = c(F.the_left_argument_of p,F.the_right_argument_of p,p)) &
        (p is universal implies
          F.p = q(F.the_scope_of p,p)) from QC_Func_ExN;
   reconsider G = F|CQC-WFF as Function of CQC-WFF,Funcs(D(),E())
    by FUNCT_2:38;
   take G;
   thus G.VERUM = V() by A1,FUNCT_1:72;
   thus for k for l being CQC-variable_list of k
    for P being QC-pred_symbol of k holds G.(P!l) = A(k,P,l)
   proof let k;
   let l be CQC-variable_list of k; let P be QC-pred_symbol of k;
A2:  P!l is atomic by QC_LANG1:def 17;
then A3:  the_arguments_of (P!l) = l & the_pred_symbol_of (P!l) = P &
     the_arity_of P = k by QC_LANG1:35,def 21,def 22;
   thus G.(P!l) = F.(P!l) by FUNCT_1:72 .= A(k,P,l) by A1,A2,A3;
   end;
   let r,s,x;
    set r' = G.r, s' = G.s;
A4:   r' = F.r & s' = F.s by FUNCT_1:72;
A5:   'not' r is negative by QC_LANG1:def 18;
then A6:   the_argument_of 'not' r = r by QC_LANG1:def 23;
   thus G.('not' r) = F.('not' r) by FUNCT_1:72 .= N(r',r) by A1,A4,A5,A6;
A7:  r '&' s is conjunctive by QC_LANG1:def 19;
then A8: the_left_argument_of(r '&' s) = r & the_right_argument_of(r '&' s) = s
       by QC_LANG1:def 24,def 25;
   thus G.(r '&' s) = F.(r '&' s) by FUNCT_1:72 .= C(r',s',r,s)
    by A1,A4,A7,A8;
A9:   All(x,r) is universal by QC_LANG1:def 20;
then A10:   bound_in All(x,r) = x & the_scope_of All(x,r) = r
    by QC_LANG1:def 26,def 27;
   thus G.All(x,r) = F.All(x,r) by FUNCT_1:72 .= Q(x,r',r) by A1,A4,A9,A10;
end;


scheme :: CQC_SIM1:sch 3
 CQCF2_FUniq { D, E() -> non empty set,
                F1, F2() -> Function of CQC-WFF,Funcs(D(),E()),
                V() -> Function of D(),E(),
                A(set,set,set) -> Function of D(),E(),
                N(set,set) -> Function of D(),E(),
                C(set,set,set,set) -> Function of D(),E(),
                Q(set,set,set) -> Function of D(),E() }:
 F1() = F2() provided
  F1().VERUM = V() and
  for k,ll,P holds F1().(P!ll) = A(k,P,ll) and
  for r,s,x holds F1().('not' r) = N(F1().r,r) &
       F1().(r '&' s) = C(F1().r,F1().s,r,s) &
       F1().All(x,r) = Q(x,F1().r,r) and
  F2().VERUM = V() and
  for k,ll,P holds F2().(P!ll) = A(k,P,ll) and
  for r,s,x holds F2().('not' r) = N(F2().r,r) &
       F2().(r '&' s) = C(F2().r,F2().s,r,s) &
       F2().All(x,r) = Q(x,F2().r,r)
proof
   defpred P[set] means F1().$1 = F2().$1;
A7: for r,s,x,k,ll,P holds
       P[VERUM] &
       P[P!ll] &
       (P[r] implies P['not' r]) &
       (P[r] & P[s] implies P[r '&' s]) &
       (P[r] implies P[All(x, r)])
   proof let r,s,x,k,ll,P;
    thus F1().VERUM = F2().VERUM by A1,A4;
      F1().(P!ll) = A(k,P,ll) & F2().(P!ll) = A(k,P,ll) by A2,A5;
    hence F1().(P!ll) = F2().(P!ll);
      F1().('not' r) = N(F1().r,r) & F2().('not' r) = N(F2().r,r) by A3,A6;
    hence (F1().r = F2().r implies F1().('not' r) = F2().('not' r));
      F1().(r '&' s) = C(F1().r,F1().s,r,s) &
     F2().(r '&' s) = C(F2().r,F2().s,r,s) by A3,A6;
    hence (F1().r = F2().r & F1().s = F2().s
        implies F1().(r '&' s) = F2().(r '&' s));
     F1().All(x,r) = Q(x,F1().r,r) & F2().All(x,r) = Q(x,F2().r,r) by A3,A6;
    hence thesis;
   end;
    P[r] from CQC_LANG:sch 1(A7);
  hence thesis by FUNCT_2:113;
 end;

theorem :: CQC_SIM1:10
p is_subformula_of 'not' p;

theorem :: CQC_SIM1:11
p is_subformula_of p '&' q & q is_subformula_of p '&' q;

theorem :: CQC_SIM1:12
p is_subformula_of All(x,p);

theorem :: CQC_SIM1:13
 for l being CQC-variable_list of k, i st 1<=i & i<=len l
  holds l.i in bound_QC-variables;

definition let D be non empty set, f be Function of D, CQC-WFF;
 func NEGATIVE f -> Element of Funcs(D, CQC-WFF) means
:: CQC_SIM1:def 1

   for a being Element of D
    for p being Element of CQC-WFF st p=f.a holds it.a = 'not' p;
end;


reserve f,h for Element of Funcs(bound_QC-variables,bound_QC-variables),
  K,L for Finite_Subset of bound_QC-variables;

definition let f,g be Function of
 [:NAT,Funcs(bound_QC-variables,bound_QC-variables):], CQC-WFF, n be Nat;
func CON(f,g,n) -> Element of
 Funcs([:NAT,Funcs(bound_QC-variables,bound_QC-variables):], CQC-WFF) means
:: CQC_SIM1:def 2
 for k,h,p,q st p = f.[k,h] & q = g.[k+n,h] holds it.[k,h] = p '&' q;
end;

definition let f be Function of
 [:NAT,Funcs(bound_QC-variables,bound_QC-variables):],CQC-WFF,
 x be bound_QC-variable;
func UNIVERSAL(x,f) -> Element of
 Funcs([:NAT,Funcs(bound_QC-variables,bound_QC-variables):],CQC-WFF) means
:: CQC_SIM1:def 3
 for k,h,p st p = f.[k+1,h +* ({x} --> x.k)] holds it.[k,h] = All(x.k,p);
end;

definition let k; let l be CQC-variable_list of k;
 let f be Element of Funcs(bound_QC-variables,bound_QC-variables);
 redefine func f*l -> CQC-variable_list of k;
end;


definition let k; let P be QC-pred_symbol of k, l be CQC-variable_list of k;
 func ATOMIC(P,l) -> Element of
  Funcs([:NAT,Funcs(bound_QC-variables,bound_QC-variables):], CQC-WFF) means
:: CQC_SIM1:def 4

   for n,h holds it.[n,h] = P!(h*l);
end;

definition let p;
func QuantNbr(p) -> Element of NAT means
:: CQC_SIM1:def 5

    ex F being Function of CQC-WFF, NAT st it = F.p &
      F.VERUM = 0 &
      for r,s,x,k for l being CQC-variable_list of k
       for P being QC-pred_symbol of k holds
         F.(P!l) = 0 &
         F.('not' r) = F.r &
         F.(r '&' s) = F.r + F.s &
         F.All(x,r) = F.r + 1;
end;


definition let f be Function of CQC-WFF,
 Funcs([:NAT,Funcs(bound_QC-variables,bound_QC-variables):],CQC-WFF),
 x be Element of CQC-WFF;
 redefine func f.x -> Element of
   Funcs([:NAT,Funcs(bound_QC-variables,bound_QC-variables):],CQC-WFF);
end;


definition
 func SepFunc -> Function of CQC-WFF,
    Funcs([:NAT,Funcs(bound_QC-variables,bound_QC-variables):],CQC-WFF)
 means
:: CQC_SIM1:def 6
  it.VERUM = [:NAT,Funcs(bound_QC-variables,bound_QC-variables):] --> VERUM &
  (for k for l being CQC-variable_list of k
   for P being QC-pred_symbol of k holds it.(P!l) = ATOMIC(P,l)) &
   for r,s,x holds
      it.('not' r) = NEGATIVE(it.r)
   & it.(r '&' s) = CON(it.r,it.s,QuantNbr(r))
   & it.All(x,r) = UNIVERSAL(x,it.r);
end;


definition let p,k,f;
 func SepFunc (p,k,f) -> Element of CQC-WFF equals
:: CQC_SIM1:def 7
   (SepFunc.p).[k,f];
end;

theorem :: CQC_SIM1:14
QuantNbr(VERUM) = 0;

theorem :: CQC_SIM1:15
QuantNbr(P!ll) = 0;

theorem :: CQC_SIM1:16
QuantNbr('not' p) = QuantNbr(p);

theorem :: CQC_SIM1:17
QuantNbr(p '&' q) = QuantNbr(p) + QuantNbr(q);

theorem :: CQC_SIM1:18
QuantNbr(All(x,p)) = QuantNbr(p) + 1;

definition let A be non empty Subset of NAT;
 func min A -> Nat means
:: CQC_SIM1:def 8
   it in A & for k st k in A holds it <= k;
end;


theorem :: CQC_SIM1:19
 for A,B being non empty Subset of NAT st A c= B
   holds min B <= min A;

theorem :: CQC_SIM1:20
  for p being Element of QC-WFF holds still_not-bound_in p is finite;

scheme :: CQC_SIM1:sch 4
 MaxFinDomElem {D()->non empty set, X()->set, P[set,set] }:
  ex x being Element of D() st x in X() &
   for y being Element of D() st y in X() holds P[x,y]
   provided
   X() is finite & X() <> {} & X() c= D() and
   for x,y being Element of D() holds P[x,y] or P[y,x] and
   for x,y,z being Element of D() st P[x,y] & P[y,z] holds P[x,z]
proof
  reconsider X = X() as finite set by A1;
  defpred R[set,set] means not $1 in X or ($2 in X & P[$1,$2]);
  A4: X <> {} by A1;
  A5: for x,y being set holds R[x,y] or R[y,x] by A1,A2;
  A6: for x,y,z being set st R[x,y] & R[y,z] holds R[x,z] by A1,A3;
  consider x being set such that
   A7: x in X and
   A8: for y being set st y in X holds R[x,y] from CARD_3:sch 3(A4,A5,A6);
  reconsider x as Element of D() by A1,A7;
  take x; thus x in X() by A7;
   let y be Element of D(); assume y in X();
  hence P[x,y] by A7,A8;
end;

definition let p;
 func NBI p -> Subset of NAT equals
:: CQC_SIM1:def 9
   {k: for i st k<=i holds not x.i in still_not-bound_in p};
end;


registration let p;
 cluster NBI p -> non empty;
 coherence
  proof
   set A = {k: for i st k<=i holds not x.i in still_not-bound_in p};
     ex k st k in A
    proof
       now per cases;
      suppose still_not-bound_in p = {};
       then 0<=i implies not x.i in still_not-bound_in p;
       then 0 in {k: for i st k<=i holds not x.i in still_not-bound_in p};
      hence ex n st n in A;
      end;
      suppose
A1:     still_not-bound_in p <> {};
      consider x being Element of still_not-bound_in p;
      reconsider x as bound_QC-variable by A1,TARSKI:def 3;
      consider i such that A2: x.i = x by QC_LANG3:36;
      A3: ex a st a in {k: x.k in still_not-bound_in p}
       proof
        take i; thus thesis by A1,A2;
       end;
      A4: still_not-bound_in p is finite by Th20;
      defpred R[set,set] means for n st n=$2 holds x.n=$1;
      A5: for e st e in still_not-bound_in p
            ex b st b in NAT & R[e,b]
           proof
            let e; assume e in still_not-bound_in p;
            then reconsider e as bound_QC-variable;
            consider i such that A6: x.i = e by QC_LANG3:36;
            reconsider i as set;
            take i;
            thus thesis by A6;
           end;
       defpred P[Nat] means x.$1 in still_not-bound_in p;
      A7: {l: P[l]} c= NAT from FRAENKEL:sch 10;
      consider f being Function such that
       A8: dom f = still_not-bound_in p & rng f c= NAT and
       A9: for e st e in still_not-bound_in p holds R[e,f.e]
         from COMPTS_1:sch 1(A5);
      reconsider f as Function of still_not-bound_in p, NAT
       by A8,FUNCT_2:def 1,RELSET_1:11;
        now let y be set;
       thus y in rng f implies y in {k: x.k in still_not-bound_in p}
        proof
         assume y in rng f;
         then consider x being set such that
          A10: x in dom f and
          A11: y = f.x by FUNCT_1:def 5;
          reconsider n=f.x as Nat by A10,FUNCT_2:7;
            x.n in still_not-bound_in p by A8,A9,A10;
         hence y in {k: x.k in still_not-bound_in p} by A11;
        end;
       assume y in {k: x.k in still_not-bound_in p};
        then consider k such that A12: y=k & x.k in still_not-bound_in p;
        reconsider a=x.k as Element of still_not-bound_in p by A12;
        reconsider n=f.a as Nat by A12,FUNCT_2:7;
          x.n = x.k by A9,A12;
        then n=k by QC_LANG3:35;
       hence y in rng f by A8,A12,FUNCT_1:def 5;
      end;
      then rng f = {k: x.k in still_not-bound_in p} &
       dom f = still_not-bound_in p by FUNCT_2:def 1,TARSKI:2;
      then A13: {k: x.k in still_not-bound_in p} is finite &
       {n: x.n in still_not-bound_in p} <> {} &
       {l: x.l in still_not-bound_in p} c= NAT by A3,A4,A7,FINSET_1:26;
      defpred R[Nat,Nat] means $2 <= $1;
      A14: for k,l holds R[k,l] or R[l,k];
      A15: for k,l,m st R[k,l] & R[l,m] holds R[k,m] by AXIOMS:22;
      consider m such that
        m in {k: x.k in still_not-bound_in p} and
      A16: for k st k in {n: x.n in still_not-bound_in p} holds R[m,k]
       from MaxFinDomElem(A13,A14,A15);
        now take n=m+1; thus n=m+1;
        let i; assume that A17: m+1<=i and A18: x.i in still_not-bound_in p;
          i in {l: x.l in still_not-bound_in p} by A18;
        then i<=m by A16;
        hence contradiction by A17,NAT_1:38;
      end;
      then m+1 in A;
      hence ex n st n in A;
     end;
     end;
     hence thesis;
    end;
   hence thesis by Def9;
  end;
end;


definition let p;
 func index p -> Nat equals
:: CQC_SIM1:def 10
    min (NBI p);
end;


theorem :: CQC_SIM1:21
index p = 0 iff p is closed;

theorem :: CQC_SIM1:22
 x.i in still_not-bound_in p implies i < index p;

theorem :: CQC_SIM1:23
index VERUM = 0;

theorem :: CQC_SIM1:24
index ('not' p) = index p;

theorem :: CQC_SIM1:25
   index p <= index(p '&' q) & index q <= index(p '&' q);

definition let C be non empty set, D be non empty Subset of C;
 redefine func id(D) -> Element of Funcs(D,D);
end;


definition let p;
 func SepVar(p) -> Element of CQC-WFF equals
:: CQC_SIM1:def 11
 SepFunc(p, index p, id(bound_QC-variables));
end;


theorem :: CQC_SIM1:26
SepVar VERUM = VERUM;

scheme :: CQC_SIM1:sch 5
 CQCInd{ P[set] }:
 for r holds P[r]
provided
 P[VERUM] and
 for k for l being CQC-variable_list of k
     for P being QC-pred_symbol of k holds P[P!l] and
 for r st P[r] holds P['not' r] and
 for r,s st P[r] & P[s] holds P[r '&' s] and
 for r,x st P[r] holds P[All(x, r)]
proof
  defpred p[set] means P[$1];
A6: for r,s,x,k for l being CQC-variable_list of k
   for P being QC-pred_symbol of k holds
    p[VERUM] &
    p[P!l] &
    (p[r] implies p['not' r]) &
    (p[r] & p[s] implies p[r '&' s]) &
    (p[r] implies p[All(x, r)]) by A1,A2,A3,A4,A5;
 thus for r holds p[r] from CQC_LANG:sch 1(A6);
end;

theorem :: CQC_SIM1:27
SepVar(P!ll) = P!ll;

theorem :: CQC_SIM1:28
p is atomic implies SepVar p = p;

theorem :: CQC_SIM1:29
SepVar 'not' p = 'not' SepVar p;

theorem :: CQC_SIM1:30
   p is negative & q = the_argument_of p implies SepVar p = 'not' SepVar q;

definition let p; let X be Subset of
          [:CQC-WFF,NAT,Fin bound_QC-variables,
            Funcs(bound_QC-variables,bound_QC-variables):];
 pred X is_Sep-closed_on p means
:: CQC_SIM1:def 12

  [p,index p, {}.bound_QC-variables,id(bound_QC-variables)] in X &
  (for q,k,K,f holds ['not' q,k,K,f] in X implies [q,k,K,f] in X) &
  (for q,r,k,K,f holds [q '&' r,k,K,f] in X implies
   [q,k,K,f] in X & [r,k+QuantNbr(q),K,f] in X) &
  for q,x,k,K,f st [All(x,q),k,K,f] in X
   holds [q,k+1,K \/ {x}, f+*({x} --> x.k)] in X;
end;


definition let D be non empty set; let x be Element of D;
 redefine func {x} -> Element of Fin D;
end;


definition let p;
 func SepQuadruples p -> Subset of
       [:CQC-WFF,NAT,Fin bound_QC-variables,
         Funcs(bound_QC-variables,bound_QC-variables):] means
:: CQC_SIM1:def 13
   it is_Sep-closed_on p &
   for D being Subset of
    [:CQC-WFF,NAT,Fin bound_QC-variables,
      Funcs(bound_QC-variables,bound_QC-variables):]
     st D is_Sep-closed_on p holds it c= D;
end;


theorem :: CQC_SIM1:31
 [p,index p,{}.bound_QC-variables,id(bound_QC-variables)] in SepQuadruples(p);

theorem :: CQC_SIM1:32
 for q,k,K,f st ['not' q,k,K,f] in SepQuadruples p
  holds [q,k,K,f] in SepQuadruples p;

theorem :: CQC_SIM1:33
 for q,r,k,K,f st [q '&' r,k,K,f] in SepQuadruples p
  holds [q,k,K,f] in SepQuadruples p & [r,k+QuantNbr(q),K,f] in SepQuadruples p
;

theorem :: CQC_SIM1:34
 for q,x,k,K,f st [All(x,q),k,K,f] in SepQuadruples p
  holds [q,k+1,K \/ {x}, f+*({x} --> x.k)] in SepQuadruples p;

theorem :: CQC_SIM1:35
 [q,k,K,f] in SepQuadruples p implies
    [q,k,K,f] = [p,index p,{}.bound_QC-variables,id bound_QC-variables] or
    ['not' q,k,K,f] in SepQuadruples p or
    (ex r st [q '&' r, k, K,f] in SepQuadruples p) or
    (ex r,l st k = l+QuantNbr r & [r '&' q,l,K,f] in SepQuadruples p) or
    ex x,l,h st l+1 = k & h +*({x} --> x.l) = f &
     ([All(x,q),l,K,h] in SepQuadruples p or
      [All(x,q),l,K\{x},h] in SepQuadruples p);

scheme :: CQC_SIM1:sch 6
 Sep_regression{p()-> Element of CQC-WFF, P[set,set,set,set] }:
 for q,k,K,f st [q,k,K,f] in SepQuadruples p() holds P[q,k,K,f]
provided
  P[p(),index p(),{}.bound_QC-variables,id bound_QC-variables] and
  for q,k,K,f st ['not' q,k,K,f] in SepQuadruples p() & P['not' q,k,K,f]
       holds P[q,k,K,f] and
  for q,r,k,K,f
       st [q '&' r, k, K,f] in SepQuadruples p() & P[q '&' r, k, K,f]
      holds P[q,k,K,f] & P[r,k+QuantNbr(q),K,f] and
  for q,x,k,K,f st [All(x,q),k,K,f] in SepQuadruples p() & P[All(x,q),k,K,f]
      holds P[q,k+1,K \/ {x},f+*({x} --> x.k)]
proof
A5: SepQuadruples p() is_Sep-closed_on p() by Def13;
  set Y = { [p,k,K,f] : P[p,k,K,f] };
    SepQuadruples p() /\ Y c= SepQuadruples p() by XBOOLE_1:17;
  then reconsider X = SepQuadruples p() /\ Y
   as Subset of [:CQC-WFF,NAT,Fin bound_QC-variables,
                  Funcs(bound_QC-variables,bound_QC-variables):] by XBOOLE_1:1;
    X is_Sep-closed_on p()
   proof
A6:  [p(),index p(),{}.bound_QC-variables,id(bound_QC-variables)]
      in SepQuadruples p() by Th31;
       [p(),index p(),{}.bound_QC-variables,id bound_QC-variables] in Y by A1;
    hence [p(),index p(), {}.bound_QC-variables,id(bound_QC-variables)] in X
     by A6,XBOOLE_0:def 3;
    thus for q,k,K,f holds ['not' q,k,K,f] in X implies [q,k,K,f] in X
     proof let q,k,K,f;
      assume
A7:     ['not' q,k,K,f] in X;
then A8:     ['not' q,k,K,f] in SepQuadruples p() by XBOOLE_0:def 3;
         ['not' q,k,K,f] in Y by A7,XBOOLE_0:def 3;
       then consider p,i,h,L such that
A9:     ['not' q,k,K,f] = [p,i,L,h] and
A10:     P[p,i,L,h];
         'not' q = p & k = i & K = L & f = h by A9,MCART_1:33;
       then P[q,k,K,f] by A2,A8,A10;
       then [q,k,K,f] in Y & [q,k,K,f] in SepQuadruples p() by A5,A8,Def12;
      hence [q,k,K,f] in X by XBOOLE_0:def 3;
     end;
    thus for q,r,k,K,f holds [q '&' r,k,K,f] in X implies
      [q,k,K,f] in X & [r,k+QuantNbr(q),K,f] in X
     proof let q,r,k,K,f;
      assume
A11:     [q '&' r,k,K,f] in X;
then A12:     [q '&' r,k,K,f] in SepQuadruples p() by XBOOLE_0:def 3;
         [q '&' r,k,K,f] in Y by A11,XBOOLE_0:def 3;
       then consider p,i,h,L such that
A13:     [q '&' r,k,K,f] = [p,i,L,h] and
A14:     P[p,i,L,h];
          q '&' r = p & k = i & K = L & f = h by A13,MCART_1:33;
        then P[q,k,K,f] & P[r,k+QuantNbr(q),K,f] by A3,A12,A14;
then A15:      [q,k,K,f] in Y & [r,k+QuantNbr(q),K,f] in Y;
          [q,k,K,f] in SepQuadruples p() &
        [r,k+QuantNbr(q),K,f] in SepQuadruples p() by A5,A12,Def12;
      hence [q,k,K,f] in X & [r,k+QuantNbr(q),K,f] in X by A15,XBOOLE_0:def 3;
     end;
    let q,x,k,K,f;
    assume
A16:   [All(x,q),k,K,f] in X;
then A17:   [All(x,q),k,K,f] in SepQuadruples p() by XBOOLE_0:def 3;
       [All(x,q),k,K,f] in Y by A16,XBOOLE_0:def 3;
     then consider p,i,h,L such that
A18:   [All(x,q),k,K,f] = [p,i,L,h] and
A19:   P[p,i,L,h];
        f+*({x} --> x.k) is Function of bound_QC-variables,bound_QC-variables
       by Lm1;
      then reconsider g = f+*({x} --> x.k) as
      Element of Funcs(bound_QC-variables,bound_QC-variables) by FUNCT_2:11;
       All(x,q) = p & k = i & K = L & f = h by A18,MCART_1:33;
     then P[q,k+1,K \/ {x},g] by A4,A17,A19;
then A20:   [q,k+1,K \/ {x},f+*({x} --> x.k)] in Y;
       [q,k+1,K \/ {x},f+*({x} --> x.k)] in SepQuadruples p() by A5,A17,Def12;
    hence [q,k+1,K \/ {x}, f+*({x} --> x.k)] in X by A20,XBOOLE_0:def 3;
   end;
  then A21: SepQuadruples p() c= X by Def13;
 let q,k,K,f;
 assume [q,k,K,f] in SepQuadruples p();
  then [q,k,K,f] in Y by A21,XBOOLE_0:def 3;
  then consider p,i,h,L such that
A22: [q,k,K,f] = [p,i,L,h] and
A23: P[p,i,L,h];
    q = p & k = i & K = L & f = h by A22,MCART_1:33;
 hence thesis by A23;
end;

theorem :: CQC_SIM1:36
 for q,k,K,f holds [q,k,K,f] in SepQuadruples p implies q is_subformula_of p;

theorem :: CQC_SIM1:37
   SepQuadruples VERUM =
  { [VERUM,0,{}.bound_QC-variables,id bound_QC-variables] };

theorem :: CQC_SIM1:38
   for k for l being CQC-variable_list of k
  for P being QC-pred_symbol of k holds
 SepQuadruples(P!l) =
  { [P!l,index(P!l),{}.bound_QC-variables,id bound_QC-variables] };

theorem :: CQC_SIM1:39
 for q,k,K,f st [q,k,K,f] in SepQuadruples p holds
  still_not-bound_in q c= still_not-bound_in p \/ K;

theorem :: CQC_SIM1:40
 [q,m,K,f] in SepQuadruples p & x.i in f.:K implies i < m;

theorem :: CQC_SIM1:41
   [q,m,K,f] in SepQuadruples p implies not x.m in f.:K;

theorem :: CQC_SIM1:42
 [q,m,K,f] in SepQuadruples p & x.i in f.:still_not-bound_in p implies i < m;

theorem :: CQC_SIM1:43
 [q,m,K,f] in SepQuadruples p & x.i in f.:still_not-bound_in q implies i < m;

theorem :: CQC_SIM1:44
  [q,m,K,f] in SepQuadruples p implies not x.m in f.:(still_not-bound_in q);

theorem :: CQC_SIM1:45
still_not-bound_in p = still_not-bound_in SepVar p;

theorem :: CQC_SIM1:46
index p = index(SepVar p);

definition let p,q;
 pred p,q are_similar means
:: CQC_SIM1:def 14
   SepVar(p) = SepVar(q);
 reflexivity;
 symmetry;
end;


canceled 2;

theorem :: CQC_SIM1:49
p,q are_similar & q,r are_similar implies p,r are_similar;
