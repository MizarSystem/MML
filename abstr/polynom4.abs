:: Evaluation of Polynomials
::  by Robert Milewski
::
:: Received June 7, 2000
:: Copyright (c) 2000 Association of Mizar Users

environ

 vocabulary ARYTM_1, FINSEQ_1, RELAT_1, FUNCT_1, RFINSEQ, RLVECT_1, FINSEQ_2,
      BINOP_1, VECTSP_1, LATTICES, REALSET1, ALGSTR_2, NORMSP_1, POLYNOM3,
      ARYTM_3, ALGSEQ_1, POLYNOM1, FUNCOP_1, SQUARE_1, FINSEQ_4, FUNCT_4,
      GROUP_1, POLYNOM2, VECTSP_2, PRE_TOPC, ENDALG, GRCAT_1, COHSP_1,
      QUOFIELD, POLYNOM4, ALGSTR_1;
 notation TARSKI, XBOOLE_0, SUBSET_1, NUMBERS, XCMPLX_0, XREAL_0, STRUCT_0,
      NAT_1, SQUARE_1, RELAT_1, FUNCT_1, FUNCT_2, BINOP_1, FINSEQ_1, FINSEQ_2,
      FINSEQ_4, FINSOP_1, RFINSEQ, TOPREAL1, BINARITH, PRE_TOPC, NORMSP_1,
      RLVECT_1, VECTSP_1, VECTSP_2, FVSUM_1, REALSET1, GROUP_1, ALGSTR_1,
      GRCAT_1, ENDALG, QUOFIELD, POLYNOM1, ALGSEQ_1, POLYNOM3;
 constructors REAL_1, SQUARE_1, FINSOP_1, SETWOP_2, RFINSEQ, TOPREAL1,
      BINARITH, QUOFIELD, FVSUM_1, ALGSTR_2, ALGSEQ_1, GRCAT_1, ENDALG,
      POLYNOM1, POLYNOM3, FINSEQOP, ALGSTR_1, MEMBERED;
 clusters STRUCT_0, RELSET_1, ALGSTR_1, FINSEQ_1, FINSEQ_2, VECTSP_2, VECTSP_1,
      POLYNOM1, POLYNOM3, INT_1, MONOID_0, XREAL_0, MEMBERED, ORDINAL2, GCD_1;
 requirements NUMERALS, SUBSET, REAL, BOOLE, ARITHM;


begin  :: Preliminaries

  theorem :: POLYNOM4:1
   for n be Nat holds 0-'n = 0;

canceled;

  theorem :: POLYNOM4:3
   for D be non empty set
   for p be FinSequence of D
   for n be Nat st 1 <= n & n <= len p holds
    p = (p|(n-'1))^<*p.n*>^(p/^n);

registration
cluster Field-like -> domRing-like
           (left_zeroed add-right-cancelable right-distributive
            left_unital commutative associative (non empty doubleLoopStr));
coherence
 proof
 let L be left_zeroed add-right-cancelable right-distributiveleft_unital
          commutative associative (non empty doubleLoopStr);
 assume A1: L is Field-like;
   now let x,y be Element of L;
   assume A2: x * y = 0.L;
   thus x = 0.L or y = 0.L
     proof
     assume x <> 0.L;
     then consider z being Element of L such that
     A3: x * z = 1_ L by A1,VECTSP_1:def 20;
       z * 0.L = 1_ L * y by A2,A3,VECTSP_1:def 16
            .= y by VECTSP_1:def 19;
     hence y = 0.L by BINOM'2;
     end;
   end;
 hence thesis by VECTSP_2:def 5;
 end;
end;


registration
 cluster strict Abelian add-associative right_zeroed right_complementable
         associative commutative distributive well-unital
         domRing-like Field-like
         non degenerated non trivial (non empty doubleLoopStr);
  existence proof
      consider F be non degenerated strict Field;
      take F;
      thus thesis;
     end;
end;


begin  :: About Polynomials

canceled;

  theorem :: POLYNOM4:5
   for L be add-associative right_zeroed right_complementable
    left-distributive (non empty doubleLoopStr)
   for p be sequence of L holds
    (0_.(L))*'p = 0_.(L);

  theorem :: POLYNOM4:6
   for L be non empty ZeroStr holds
    len 0_.(L) = 0;

  theorem :: POLYNOM4:7
   for L be non degenerated (non empty multLoopStr_0) holds
    len 1_.(L) = 1;

  theorem :: POLYNOM4:8
   for L be non empty ZeroStr
   for p be Polynomial of L st len p = 0 holds
    p = 0_.(L);

  theorem :: POLYNOM4:9
   for L be right_zeroed (non empty LoopStr)
   for p,q be Polynomial of L
   for n be Nat st n >= len p & n >= len q holds
    n >= len (p+q);

  theorem :: POLYNOM4:10
   for L be add-associative right_zeroed right_complementable
    (non empty LoopStr)
   for p,q be Polynomial of L st len p <> len q holds
    len (p+q) = max(len p,len q);

  theorem :: POLYNOM4:11
   for L be add-associative right_zeroed right_complementable
    (non empty LoopStr)
   for p be Polynomial of L holds
    len (-p) = len p;

  theorem :: POLYNOM4:12
     for L be add-associative right_zeroed right_complementable
    (non empty LoopStr)
   for p,q be Polynomial of L
   for n be Nat st n >= len p & n >= len q holds
    n >= len (p-q);

  theorem :: POLYNOM4:13
for L be add-associative right_zeroed right_complementable distributive
         commutative associative left_unital (non empty doubleLoopStr),
    p,q be Polynomial of L
 st p.(len p -'1) * q.(len q -'1) <> 0.L holds len (p*'q) = len p + len q - 1;

begin  :: Leading Monomials

  definition
   let L be non empty ZeroStr;
   let p be Polynomial of L;
   func Leading-Monomial(p) -> sequence of L means
:: POLYNOM4:def 1
    it.(len p-'1) = p.(len p-'1) &
    for n be Nat st n <> len p-'1 holds it.n = 0.L;
  end;


  theorem :: POLYNOM4:14
   for L be non empty ZeroStr
   for p be Polynomial of L holds
    Leading-Monomial(p) = 0_.(L)+*(len p-'1,p.(len p-'1));

  registration
   let L be non empty ZeroStr;
   let p be Polynomial of L;
   cluster Leading-Monomial(p) -> finite-Support;
   coherence
   proof
    take len p;
    let i be Nat;
    A1: Leading-Monomial(p) = 0_.(L)+*(len p-'1,p.(len p-'1)) by Th14;
    assume i >= len p;
    then i+1 > len p by NAT_1:38;
    then i+1-1 > len p-1 by REAL_1:54;
    then A2: i <> len p-1 by XCMPLX_1:26;
    per cases by NAT_1:18;
     suppose len p > 0;
      then len p >= 0+1 by NAT_1:38;
      then len p-1 >= 0+1-1 by REAL_1:49;
      then i <> len p-'1 by A2,BINARITH:def 3;
      hence (Leading-Monomial(p)).i = (0_.(L)).i by A1,FUNCT_7:34
         .= 0.L by POLYNOM3:28;
     end;
     suppose A3: len p = 0;
      then A4: len p-'1 = 0 by Th1;
        0 in NAT;
      then A5: 0 in dom 0_.(L) by NORMSP_1:17;
        now per cases by NAT_1:18;
       suppose i > 0;
        hence (Leading-Monomial(p)).i = (0_.(L)).i by A1,A4,FUNCT_7:34
           .= 0.L by POLYNOM3:28;
       end;
       suppose i = 0;
        hence (Leading-Monomial(p)).i = p.0 by A1,A4,A5,FUNCT_7:33
           .= (0_.(L)).0 by A3,Th8
           .= 0.L by POLYNOM3:28;
      end;
      end;
      hence thesis;
   end;
   end;
  end;


  theorem :: POLYNOM4:15
   for L be non empty ZeroStr
   for p be Polynomial of L st len p = 0 holds
    Leading-Monomial(p) = 0_.(L);

  theorem :: POLYNOM4:16
     for L be non empty ZeroStr holds
    Leading-Monomial(0_.(L)) = 0_.(L);

  theorem :: POLYNOM4:17
     for L be non degenerated (non empty multLoopStr_0) holds
    Leading-Monomial(1_.(L)) = 1_.(L);

  theorem :: POLYNOM4:18
   for L be non empty ZeroStr
   for p be Polynomial of L holds
    len Leading-Monomial(p) = len p;

  theorem :: POLYNOM4:19
   for L be add-associative right_zeroed right_complementable
    (non empty LoopStr)
   for p be Polynomial of L st len p <> 0
   ex q be Polynomial of L st
    len q < len p & p = q+Leading-Monomial(p) &
    for n be Nat st n < len p-1 holds q.n = p.n;

begin  :: Evaluation of Polynomials

  definition
   let L be unital (non empty doubleLoopStr);
   let p be Polynomial of L;
   let x be Element of the carrier of L;
   func eval(p,x) -> Element of L means
:: POLYNOM4:def 2
    ex F be FinSequence of the carrier of L st
     it = Sum F &
     len F = len p &
     for n be Nat st n in dom F holds F.n = p.(n-'1) * (power L).(x,n-'1);
  end;


  theorem :: POLYNOM4:20
   for L be unital (non empty doubleLoopStr)
   for x be Element of the carrier of L holds
    eval(0_.(L),x) = 0.L;

  theorem :: POLYNOM4:21
   for L be well-unital add-associative right_zeroed right_complementable
    associative non degenerated (non empty doubleLoopStr)
   for x be Element of the carrier of L holds
    eval(1_.(L),x) = 1_(L);

  theorem :: POLYNOM4:22
   for L be Abelian add-associative right_zeroed right_complementable unital
    left-distributive (non empty doubleLoopStr)
   for p,q be Polynomial of L
   for x be Element of the carrier of L holds
    eval(p+q,x) = eval(p,x) + eval(q,x);

  theorem :: POLYNOM4:23
   for L be Abelian add-associative right_zeroed right_complementable unital
    distributive (non empty doubleLoopStr)
   for p be Polynomial of L
   for x be Element of the carrier of L holds
    eval(-p,x) = -eval(p,x);

  theorem :: POLYNOM4:24
     for L be Abelian add-associative right_zeroed right_complementable unital
    distributive (non empty doubleLoopStr)
   for p,q be Polynomial of L
   for x be Element of the carrier of L holds
    eval(p-q,x) = eval(p,x) - eval(q,x);

  theorem :: POLYNOM4:25
   for L be add-associative right_zeroed right_complementable right_zeroed
    distributive unital (non empty doubleLoopStr)
   for p be Polynomial of L
   for x be Element of the carrier of L holds
    eval(Leading-Monomial(p),x) = p.(len p-'1) * (power L).(x,len p-'1);

  theorem :: POLYNOM4:26
   for L be add-associative right_zeroed right_complementable Abelian
    left_unital distributive commutative associative non trivial
    (non empty doubleLoopStr)
   for p,q be Polynomial of L
   for x be Element of the carrier of L holds
    eval((Leading-Monomial(p))*'q,x) = eval(Leading-Monomial(p),x) * eval(q,x);

  theorem :: POLYNOM4:27
   for L be add-associative right_zeroed right_complementable Abelian
    left_unital distributive commutative associative non trivial
    (non empty doubleLoopStr)
   for p,q be Polynomial of L
   for x be Element of the carrier of L holds
    eval(p*'q,x) = eval(p,x) * eval(q,x);

begin  :: Evaluation Homomorphism

  definition
   let L be add-associative right_zeroed right_complementable distributive
    unital (non empty doubleLoopStr);
   let x be Element of the carrier of L;
   func Polynom-Evaluation(L,x) -> map of Polynom-Ring L,L means
:: POLYNOM4:def 3
    for p be Polynomial of L holds it.p = eval(p,x);
  end;


  registration
   let L be add-associative right_zeroed right_complementable distributive
    associative well-unital non degenerated (non empty doubleLoopStr);
   let x be Element of the carrier of L;
   cluster Polynom-Evaluation(L,x) -> unity-preserving;
   coherence
   proof
    thus (Polynom-Evaluation(L,x)).(1_(Polynom-Ring L)) =
          (Polynom-Evaluation(L,x)).(1_.(L)) by POLYNOM3:def 12
       .= eval(1_.(L),x) by Def3
       .= 1_(L) by Th21;
   end;
  end;


  registration
   let L be Abelian add-associative right_zeroed right_complementable
    distributive unital (non empty doubleLoopStr);
   let x be Element of the carrier of L;
   cluster Polynom-Evaluation(L,x) -> additive;
   coherence
   proof
    let a,b be Element of the carrier of Polynom-Ring L;
    reconsider p=a,q=b as Polynomial of L by POLYNOM3:def 12;
    thus (Polynom-Evaluation(L,x)).(a+b) = (Polynom-Evaluation(L,x)).(p+q)
                                                          by POLYNOM3:def 12
       .= eval(p+q,x) by Def3
       .= eval(p,x) + eval(q,x) by Th22
       .= (Polynom-Evaluation(L,x)).a + eval(q,x) by Def3
       .= (Polynom-Evaluation(L,x)).a+(Polynom-Evaluation(L,x)).b by Def3;
   end;
  end;


  registration
   let L be add-associative right_zeroed right_complementable Abelian
    left_unital distributive commutative associative non trivial
    (non empty doubleLoopStr);
   let x be Element of the carrier of L;
   cluster Polynom-Evaluation(L,x) -> multiplicative;
   coherence
   proof
    let a,b be Element of the carrier of Polynom-Ring L;
    reconsider p=a,q=b as Polynomial of L by POLYNOM3:def 12;
    thus (Polynom-Evaluation(L,x)).(a*b) = (Polynom-Evaluation(L,x)).(p*'q)
                                                          by POLYNOM3:def 12
       .= eval(p*'q,x) by Def3
       .= eval(p,x)*eval(q,x) by Th27
       .= (Polynom-Evaluation(L,x)).a*eval(q,x) by Def3
       .= (Polynom-Evaluation(L,x)).a*(Polynom-Evaluation(L,x)).b by Def3;
   end;
  end;


  registration
   let L be add-associative right_zeroed right_complementable Abelian
    left_unital distributive commutative associative non degenerated
    (non empty doubleLoopStr);
   let x be Element of the carrier of L;
   cluster Polynom-Evaluation(L,x) -> RingHomomorphism;
   coherence
   proof
    thus Polynom-Evaluation(L,x) is additive multiplicative unity-preserving;
   end;
  end;

