:: The Class of Series-Parallel Graphs, {II}
::  by Krzysztof Retel
::
:: Received May 29, 2003
:: Copyright (c) 2003 Association of Mizar Users

environ

 vocabulary NECKLA_2, NECKLACE, CLASSES1, CLASSES2, ORDERS_1, RELAT_1,
      REALSET1, FUNCT_1, PRE_TOPC, BOOLE, SETFAM_1, CANTOR_1, CARD_1, PROB_1,
      SQUARE_1, ARYTM, FINSET_1, ORDINAL2, ORDINAL1;
 notation TARSKI, XBOOLE_0, ENUMSET1, SUBSET_1, ZFMISC_1, RELSET_1, FINSET_1,
      CARD_1, ORDINAL1, ORDINAL2, NUMBERS, XCMPLX_0, XREAL_0, NAT_1, STRUCT_0,
      GROUP_1, REALSET1, SQUARE_1, ORDERS_1, RELAT_1, NECKLACE, PRE_TOPC,
      FUNCT_1, FUNCT_2, CLASSES2, SETFAM_1, CANTOR_1, CLASSES1, PROB_1,
      CARD_LAR;
 constructors ENUMSET1, NECKLACE, NAT_1, CLASSES2, CANTOR_1, GROUP_1, PROB_1,
      SQUARE_1, COHSP_1, CARD_LAR, REALSET1, MEMBERED;
 clusters RELSET_1, ORDERS_1, STRUCT_0, FINSET_1, NAT_1, NECKLACE, ORDINAL1,
      CLASSES2, YELLOW13, XREAL_0, COHSP_1, XBOOLE_0, CARD_1, MEMBERED,
      NUMBERS, ORDINAL2;
 requirements BOOLE, SUBSET, REAL, NUMERALS, ARITHM;


begin

reserve U for Universe;

theorem :: NECKLA_2:1
  for X,Y being set st X in U & Y in U
      for R being Relation of X,Y holds R in U;

theorem :: NECKLA_2:2
  the InternalRel of Necklace 4 =
    {[0,1],[1,0],[1,2],[2,1],[2,3],[3,2]};

registration let n be natural number;
  cluster -> finite Element of Rank n;
  coherence
    proof
      let x be Element of Rank n;
      defpred P[natural number] means
           for x being set st x is Element of Rank $1
           holds x is finite;
      A1: P[0] by CLASSES1:33,SUBSET_1:def 2;
      A2: for k being natural number st P[k] holds P[k + 1]
       proof
         let k being natural number such that P[k];
         let x be set such that A3: x is Element of Rank (k+1);
         consider m being Nat such that A4: m = k by CARD_1:54;
             x is Element of Rank (succ m) by A3,A4,CARD_1:52;
           then A5: x is Element of bool Rank m by CLASSES1:34;
             Rank m is finite by CARD_3:57;
         hence thesis by A5,FINSET_1:13;
       end;
          for k being natural number holds P[k] from NAT_1:sch 2(A1,A2);
      hence thesis;
    end;
 end;


theorem :: NECKLA_2:3
  for x be set st x in FinSETS holds x is finite;

registration
  cluster -> finite Element of FinSETS;
  coherence by Th3;
 end;


registration
  cluster finite ordinal -> natural number;
  coherence
   proof
     let n be number;
     assume n is finite ordinal;
       then n in omega by CARD_4:7;
     hence n is natural by ORDINAL2:def 21;
   end;
end;



definition let G be non empty RelStr;
  attr G is N-free means
:: NECKLA_2:def 1
 not G embeds Necklace 4;
end;


registration
 cluster strict finite N-free (non empty RelStr);
 existence
  proof
   set X = {0,1},
       Y = Necklace 4;
   reconsider r = id X as Relation of X by RELSET_1:29;
   take R = RelStr(#X,r#);
      now let f being map of Y,R;
     assume A1: f is one-to-one;
A2: dom f = the carrier of Y by FUNCT_2:def 1
             .= {0,1,2,3} by NECKLACE:2,21;
then A3: 1 in dom f by ENUMSET1:19;
A4: 2 in dom f by A2,ENUMSET1:19;
A5: 3 in dom f by A2,ENUMSET1:19;
then A6: f.1 <> f.3 by A1,A3,FUNCT_1:def 8;
A7: f.2 <> f.3 by A1,A4,A5,FUNCT_1:def 8;
A8: f.1 in X by A3,PARTFUN1:27;
A9: f.2 in X by A4,PARTFUN1:27;
A10: f.3 in X by A5,PARTFUN1:27;
A11: f.1 = 0 or f.1 = 1 by A8,TARSKI:def 2;
       f.2 = 0 or f.2 = 1 by A9,TARSKI:def 2;
     hence ex x,y being Element of Y st
     not ([x,y] in the InternalRel of Y
                iff [f.x,f.y] in the InternalRel of R) by A1,A3,A4,A6,A7,A10,
A11,FUNCT_1:def 8,TARSKI:def 2;
   end;
   then A12: not R embeds Y by NECKLACE:def 2;
   R is finite by GROUP_1:def 13;
   hence thesis by A12,Def1;
  end;
end;


definition let R,S be RelStr;
  func union_of(R,S) -> strict RelStr means
:: NECKLA_2:def 2
 the carrier of it = (the carrier of R) \/ (the carrier of S) &
    the InternalRel of it = (the InternalRel of R) \/ (the InternalRel of S);
end;


definition let R, S be RelStr;
  func sum_of(R,S) -> strict RelStr means
:: NECKLA_2:def 3
 the carrier of it = (the carrier of R) \/ (the carrier of S) &
    the InternalRel of it = (the InternalRel of R) \/ (the InternalRel of S)
                         \/ [:the carrier of R, the carrier of S:]
                         \/ [:the carrier of S, the carrier of R:];
end;


definition
 func fin_RelStr means
:: NECKLA_2:def 4
 for X being set holds
       X in it iff
       ex R being strict RelStr st X = R & the carrier of R in FinSETS;
end;


registration
   cluster fin_RelStr -> non empty;
   correctness
   proof
     reconsider R = {}[:{},{}:] as Relation of {} by RELSET_1:25;
        RelStr(#{},R#) in fin_RelStr
      proof
        set X = RelStr(#{},R#);
          the carrier of X in FinSETS by CLASSES1:5,CLASSES2:def 2;
        hence thesis by Def4;
      end;
     hence thesis;
    end;
  end;


definition
  func fin_RelStr_sp -> Subset of fin_RelStr means
:: NECKLA_2:def 5
 (for R be strict RelStr st the carrier of R is non empty trivial
        & the carrier of R in FinSETS holds R in it) &
      (for H1,H2 be strict RelStr st
       (the carrier of H1) misses (the carrier of H2) & H1 in it & H2 in it
            holds union_of(H1,H2) in it & sum_of(H1,H2) in it)
        &
      for M be Subset of fin_RelStr st
      ( (for R be strict RelStr st the carrier of R is non empty trivial &
         the carrier of R in FinSETS holds R in M) &
       for H1,H2 be strict RelStr st
       (the carrier of H1) misses (the carrier of H2) & H1 in M & H2 in M
            holds union_of(H1,H2) in M & sum_of(H1,H2) in M )
      holds it c= M;
end;


registration
   cluster fin_RelStr_sp -> non empty;
   correctness
    proof
      reconsider R = [:{0},{0}:] as Relation of {0} by RELSET_1:def 1;
         RelStr(#{0},R#) in fin_RelStr_sp
       proof
         set X = RelStr(#{0},R#);
         A1: the carrier of X is non empty trivial by REALSET1:def 12;
             0 in Tarski-Class {} by CLASSES2:62;
          then the carrier of X in FinSETS by CLASSES2:63,def 2;
         hence thesis by A1,Def5;
       end;
      hence thesis;
    end;
end;



theorem :: NECKLA_2:4
  for X being set st X in fin_RelStr_sp holds
  X is finite strict non empty RelStr;

theorem :: NECKLA_2:5
    for R being RelStr st R in fin_RelStr_sp holds
   (the carrier of R) in FinSETS;

theorem :: NECKLA_2:6
  for X being set st X in fin_RelStr_sp holds
  X is strict non empty trivial RelStr or
  ex H1,H2 being strict RelStr st
    (the carrier of H1) misses (the carrier of H2) &
    H1 in fin_RelStr_sp & H2 in fin_RelStr_sp &
    (X = union_of(H1,H2) or X = sum_of(H1,H2) );

theorem :: NECKLA_2:7
      for R being strict non empty RelStr st
      R in fin_RelStr_sp holds R is N-free;
