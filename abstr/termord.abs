:: Term Orders
::  by Christoph Schwarzweller
::
:: Received December 20, 2002
:: Copyright (c) 2002 Association of Mizar Users

environ

 vocabulary POLYNOM1, POLYNOM7, BOOLE, FUNCT_1, TRIANG_1, FINSEQ_1, VECTSP_1,
      RLVECT_1, ORDINAL1, LATTICES, ALGSEQ_1, ANPROJ_1, CAT_3, GROUP_1,
      VECTSP_2, RELAT_1, RELAT_2, REALSET1, ALGSTR_1, CARD_1, ARYTM_1, MCART_1,
      FINSEQ_4, ARYTM_3, SQUARE_1, PBOOLE, ORDERS_1, ORDERS_2, FINSET_1,
      BAGORDER, WELLORD1, DICKSON, TERMORD;
 notation NUMBERS, XCMPLX_0, XREAL_0, TARSKI, XBOOLE_0, SUBSET_1, STRUCT_0,
      RELAT_1, MONOID_0, CARD_1, BAGORDER, RELSET_1, FUNCT_1, FINSET_1,
      ORDINAL1, NAT_1, ALGSTR_1, RLVECT_1, PBOOLE, FINSEQ_1, MCART_1, TRIANG_1,
      REALSET1, VECTSP_1, VECTSP_2, RELAT_2, POLYNOM1, BINARITH, ORDERS_1,
      ORDERS_2, FINSEQ_4, WELLORD1, POLYNOM7;
 constructors ALGSTR_2, POLYNOM7, MONOID_0, BINOM, BAGORDER, MCART_1, TRIANG_1,
      ORDERS_2, MEMBERED;
 clusters XREAL_0, STRUCT_0, FINSET_1, RELSET_1, FINSEQ_1, CARD_1, ALGSTR_1,
      POLYNOM1, POLYNOM2, POLYNOM7, BAGORDER, VECTSP_1, NAT_1, MEMBERED,
      NUMBERS, ORDINAL2;
 requirements NUMERALS, REAL, BOOLE, SUBSET, ARITHM;


begin :: Preliminaries

registration
cluster non trivial LoopStr;
existence
 proof
 consider R being Field;
 take R;
 thus thesis;
 end;
end;


registration
cluster add-associative right_complementable right_zeroed
        (non trivial LoopStr);
existence
 proof
 consider F being Field;
 take F;
 thus thesis;
 end;
end;


definition
let X be set,
    b be bag of X;
attr b is non-zero means
:: TERMORD:def 1
    b <> EmptyBag X;
end;


theorem :: TERMORD:1
for X being set,
    b1,b2 being bag of X
holds b1 divides b2 iff ex b being bag of X st b2 = b1 + b;

theorem :: TERMORD:2
for n being Ordinal,
    L being add-associative right_complementable right_zeroed
            unital distributive (non empty doubleLoopStr),
    p being Series of n, L
 holds 0_(n,L) *' p = 0_(n,L);

registration
let n be Ordinal,
    L be add-associative right_complementable right_zeroed
         unital distributive (non empty doubleLoopStr),
    m1,m2 be Monomial of n,L;
cluster m1 *' m2 -> monomial-like;
coherence
 proof
 per cases;
 suppose Support(m1*'m2) = {};
   hence thesis by POLYNOM7:6;
 end;
 suppose A1: Support(m1*'m2) <> {};
     now per cases;
   case A2: Support(m1) <> {} & Support(m2) <> {};
   then consider mb1 being bag of n such that
   A3: Support(m1) = {mb1} by POLYNOM7:6;
     mb1 in Support m1 by A3,TARSKI:def 1;
   then A4: m1.mb1 <> 0.L by POLYNOM1:def 9;
   A5: now let b be bag of n;
        assume A6: b <> mb1;
        consider b' being bag of n such that
        A7: for b being bag of n st b <> b' holds m1.b = 0.L
            by POLYNOM7:def 4;
          b' = mb1 by A4,A7;
        hence m1.b = 0.L by A6,A7;
        end;
   consider mb2 being bag of n such that
   A8: Support(m2) = {mb2} by A2,POLYNOM7:6;
     mb2 in Support m2 by A8,TARSKI:def 1;
   then A9: m2.mb2 <> 0.L by POLYNOM1:def 9;
   A10: now let b be bag of n;
        assume A11: b <> mb2;
        consider b' being bag of n such that
        A12: for b being bag of n st b <> b' holds m2.b = 0.L
            by POLYNOM7:def 4;
          b' = mb2 by A9,A12;
        hence m2.b = 0.L by A11,A12;
        end;
   consider b being Element of Support(m1*'m2);
   A13: b in Support(m1*'m2) by A1;
   then b is Element of Bags n;
   then reconsider b as bag of n;
   consider s being FinSequence of the carrier of L such that
   A14: (m1*'m2).b = Sum s &
       len s = len decomp b &
       for k being Nat st k in dom s
       ex b1,b2 being bag of n st (decomp b)/.k = <*b1, b2*> &
                                  s/.k = m1.b1*m2.b2 by POLYNOM1:def 26;
   A15: dom s = Seg(len decomp b) by A14,FINSEQ_1:def 3
            .= dom(decomp b) by FINSEQ_1:def 3;
   A16: now assume A17: b <> mb1 + mb2;
       A18: now let k be Nat;
            assume A19: k in dom s;
            then consider b1,b2 being bag of n such that
            A20: (decomp b)/.k = <*b1, b2*> & s/.k = m1.b1*m2.b2 by A14;
            consider b1',b2' being bag of n such that
            A21: (decomp b)/.k = <*b1',b2'*> & b = b1'+b2'
                by A15,A19,POLYNOM1:72;
            A22: b1 = <*b1', b2'*>.1 by A20,A21,FINSEQ_1:61
               .= b1' by FINSEQ_1:61;
            A23: b2 = <*b1', b2'*>.2 by A20,A21,FINSEQ_1:61
              .= b2' by FINSEQ_1:61;
              now per cases by A17,A21,A22,A23;
            case b1 <> mb1;
              then m1.b1 = 0.L by A5;
              hence m1.b1*m2.b2 = 0.L by BINOM:1;
            end;
            case b2 <> mb2;
              then m2.b2 = 0.L by A10;
              hence m1.b1*m2.b2 = 0.L by BINOM:2;
            end;
            end;
            hence s/.k = 0.L by A20;
            end;
         now per cases;
       case dom s = {};
         then s = <*>(the carrier of L) by FINSEQ_1:26;
         hence (m1*'m2).b = 0.L by A14,RLVECT_1:60;
       end;
       case A24: dom s <> {};
         consider k being Element of dom s;
         A25: k in dom s by A24;
           for k' being Nat st k' in dom s & k' <> k holds s/.k' = 0.L by A18;
         then s/.k = (m1*'m2).b by A14,A25,POLYNOM2:5;
         hence (m1*'m2).b = 0.L by A18,A25;
       end;
       end;
       hence contradiction by A13,POLYNOM1:def 9;
       end;
     now let b' be bag of n;
     assume A26: b' <> b;
     consider s being FinSequence of the carrier of L such that
     A27: (m1*'m2).b' = Sum s &
         len s = len decomp b' &
         for k being Nat st k in dom s
         ex b1, b2 being bag of n st (decomp b')/.k = <*b1, b2*> &
                                     s/.k = m1.b1*m2.b2 by POLYNOM1:def 26;
     A28: dom s = Seg(len decomp b') by A27,FINSEQ_1:def 3
              .= dom(decomp b') by FINSEQ_1:def 3;
     A29: now let k be Nat;
         assume A30: k in dom s;
         then consider b1, b2 being bag of n such that
         A31: (decomp b')/.k = <*b1,b2*> & s/.k = m1.b1*m2.b2 by A27;
         consider b1',b2' being bag of n such that
         A32: (decomp b')/.k = <*b1',b2'*> & b' = b1'+b2' by A28,A30,POLYNOM1:
72;
         A33: b1 = <*b1', b2'*>.1 by A31,A32,FINSEQ_1:61
               .= b1' by FINSEQ_1:61;
         A34: b2 = <*b1', b2'*>.2 by A31,A32,FINSEQ_1:61
               .= b2' by FINSEQ_1:61;
           now per cases by A16,A26,A32,A33,A34;
         case b1 <> mb1;
           then m1.b1 = 0.L by A5;
           hence m1.b1*m2.b2 = 0.L by BINOM:1;
         end;
         case b2 <> mb2;
           then m2.b2 = 0.L by A10;
           hence m1.b1*m2.b2 = 0.L by BINOM:2;
         end;
         end;
         hence s/.k = 0.L by A31;
         end;
       now per cases;
     case dom s = {};
       then s = <*>(the carrier of L) by FINSEQ_1:26;
       hence (m1*'m2).b' = 0.L by A27,RLVECT_1:60;
     end;
     case A35: dom s <> {};
       consider k being Element of dom s;
       A36: k in dom s by A35;
         for k' being Nat st k' in dom s & k' <> k holds s/.k' = 0.L by A29;
       then s/.k = (m1*'m2).b' by A27,A36,POLYNOM2:5;
       hence (m1*'m2).b' = 0.L by A29,A36;
      end;
      end;
     hence (m1*'m2).b' = 0.L;
     end;
   hence thesis by POLYNOM7:def 4;
   end;
   case A37: Support(m1) = {} or Support(m2) = {};
     now per cases by A37;
   case Support(m1) = {};
     then m1 = 0_(n,L) by POLYNOM7:1;
     hence thesis by Th2;
   end;
   case Support(m2) = {};
     then m2 = 0_(n,L) by POLYNOM7:1;
     hence thesis by POLYNOM1:87;
   end;
   end;
   hence thesis;
   end;
   end;
 hence thesis;
 end;
 end;
end;


registration
let n be Ordinal,
    L be add-associative right_complementable
         right_zeroed distributive (non empty doubleLoopStr),
    c1,c2 be ConstPoly of n,L;
cluster c1 *' c2 -> Constant;
coherence
 proof
 set p = c1 *' c2;
   now let b be bag of n;
   assume A1: b <> EmptyBag n;
   consider s being FinSequence of the carrier of L such that
   A2: p.b = Sum s &
      len s = len decomp b &
      for k being Nat st k in dom s
      ex b1, b2 being bag of n st (decomp b)/.k = <*b1, b2*> &
                                  s/.k = c1.b1*c2.b2 by POLYNOM1:def 26;

   A3: dom s = Seg(len decomp b) by A2,FINSEQ_1:def 3
            .= dom(decomp b) by FINSEQ_1:def 3;
   A4: now let k be Nat;
       assume A5: k in dom s;
       then consider b1, b2 being bag of n such that
       A6: (decomp b)/.k = <*b1,b2*> & s/.k = c1.b1*c2.b2 by A2;
       consider b1',b2' being bag of n such that
       A7: (decomp b)/.k = <*b1',b2'*> & b = b1'+b2' by A3,A5,POLYNOM1:72;
       A8: b1 = <*b1', b2'*>.1 by A6,A7,FINSEQ_1:61
             .= b1' by FINSEQ_1:61;
         b2 = <*b1', b2'*>.2 by A6,A7,FINSEQ_1:61
         .= b2' by FINSEQ_1:61;
       then A9: b1 <> EmptyBag n or b2 <> EmptyBag n by A1,A7,A8,POLYNOM1:57;
         now per cases by A9,POLYNOM7:def 8;
       case c1.b1 = 0.L;
         hence s/.k = 0.L by A6,BINOM:1;
       end;
       case c2.b2 = 0.L;
         hence s/.k = 0.L by A6,BINOM:2;
       end;
       end;
       hence s/.k = 0.L;
       end;
     now per cases;
   case dom s = {};
     then s = <*>(the carrier of L) by FINSEQ_1:26;
     hence p.b = 0.L by A2,RLVECT_1:60;
   end;
   case A10: dom s <> {};
     consider k being Element of dom s;
     A11: k in dom s by A10;
       for k' being Nat st k' in dom s & k' <> k holds s/.k' = 0.L by A4;
     then Sum s = s/.k by A11,POLYNOM2:5;
     hence p.b = 0.L by A2,A4,A11;
   end;
   end;
   hence p.b = 0.L;
   end;
 hence thesis by POLYNOM7:def 8;
 end;
end;


theorem :: TERMORD:3
for n being Ordinal,
    L being add-associative right_complementable right_zeroed
            unital distributive domRing-like (non trivial doubleLoopStr),
    b,b' being bag of n,
    a,a' being non-zero Element of L
holds Monom(a * a',b + b') = Monom(a,b) *' Monom(a',b');

theorem :: TERMORD:4
  for n being Ordinal,
    L being add-associative right_complementable right_zeroed
            unital distributive domRing-like (non trivial doubleLoopStr),
    a,a' being Element of L
holds (a * a') _(n,L) = (a _(n,L)) *' (a' _(n,L));

begin

registration
let n be Ordinal;
cluster admissible connected TermOrder of n;
existence
 proof
 set T = LexOrder n;
 take T;
   now let x,y be set;
   assume x in field T & y in field T & x <> y;
   then reconsider b1 = x, b2 = y as bag of n by Lm1;
     b1 <=' b2 or b2 <=' b1 by POLYNOM1:49;
   then [b1,b2] in BagOrder n or [b2,b1] in BagOrder n by POLYNOM1:def 16;
   hence [x,y] in T or [y,x] in T;
   end;
 then T is_connected_in field T by RELAT_2:def 6;
 hence thesis by RELAT_2:def 14;
 end;
end;


registration
::: theorem 5.5 (ii), p. 190
let n be Nat;
cluster -> well_founded (admissible TermOrder of n);
coherence
 proof
 let T be admissible TermOrder of n;
   T is well-ordering by BAGORDER:35;
 hence thesis by WELLORD1:def 4;
 end;
end;


definition
let n be Ordinal,
    T be TermOrder of n,
    b,b' be bag of n;
pred b <= b',T means
:: TERMORD:def 2
  [b,b'] in T;
end;


definition
let n be Ordinal,
    T be TermOrder of n,
    b,b' be bag of n;
pred b < b',T means
:: TERMORD:def 3
  b <= b',T & b <> b';
end;


definition
let n be Ordinal,
    T be TermOrder of n,
    b1,b2 be bag of n;
func min(b1,b2,T) -> bag of n equals
:: TERMORD:def 4
 b1 if b1 <= b2,T otherwise b2;
func max(b1,b2,T) -> bag of n equals
:: TERMORD:def 5
 b1 if b2 <= b1,T otherwise b2;
end;

theorem :: TERMORD:5
for n being Ordinal,
    T being connected TermOrder of n,
    b1,b2 being bag of n
holds b1 <= b2,T iff not(b2 < b1,T);

theorem :: TERMORD:6
  for n being Ordinal,
    T being TermOrder of n,
    b being bag of n
holds b <= b,T;

theorem :: TERMORD:7
  for n being Ordinal,
    T being TermOrder of n,
    b1,b2 being bag of n
st b1 <= b2,T & b2 <= b1,T holds b1 = b2;

theorem :: TERMORD:8
for n being Ordinal,
    T being TermOrder of n,
    b1,b2,b3 being bag of n
st b1 <= b2,T & b2 <= b3,T holds b1 <= b3,T;

theorem :: TERMORD:9
for n being Ordinal,
    T being admissible TermOrder of n,
    b being bag of n
holds EmptyBag n <= b,T;

theorem :: TERMORD:10
  for n being Ordinal,
    T being admissible TermOrder of n,
    b1,b2 being bag of n
holds b1 divides b2 implies b1 <= b2,T;

theorem :: TERMORD:11
for n being Ordinal,
    T being TermOrder of n,
    b1,b2 being bag of n
holds min(b1,b2,T) = b1 or min(b1,b2,T) = b2;

theorem :: TERMORD:12
for n being Ordinal,
    T being TermOrder of n,
    b1,b2 being bag of n
holds max(b1,b2,T) = b1 or max(b1,b2,T) = b2;

theorem :: TERMORD:13
  for n being Ordinal,
    T being connected TermOrder of n,
    b1,b2 being bag of n
holds min(b1,b2,T) <= b1,T & min(b1,b2,T) <= b2,T;

theorem :: TERMORD:14
for n being Ordinal,
    T being connected TermOrder of n,
    b1,b2 being bag of n
holds b1 <= max(b1,b2,T),T & b2 <= max(b1,b2,T),T;

theorem :: TERMORD:15
for n being Ordinal,
    T being connected TermOrder of n,
    b1,b2 being bag of n
holds min(b1,b2,T) = min(b2,b1,T) & max(b1,b2,T) = max(b2,b1,T);

theorem :: TERMORD:16
  for n being Ordinal,
    T being connected TermOrder of n,
    b1,b2 being bag of n
holds min(b1,b2,T) = b1 iff max(b1,b2,T) = b2;

begin :: Headterms, Headmonomials and Headcoefficients

definition
::: definition 5.15, p. 194
let n be Ordinal,
    T be connected TermOrder of n,
    L be non empty ZeroStr,
    p be Polynomial of n,L;
func HT(p,T) -> Element of Bags n means
:: TERMORD:def 6
  (Support p = {} & it = EmptyBag n) or
  (it in Support p &
   for b being bag of n st b in Support p holds b <= it,T);
end;


definition
::: definition 5.15, p. 194
let n be Ordinal,
    T be connected TermOrder of n,
    L be non empty ZeroStr,
    p be Polynomial of n,L;
func HC(p,T) -> Element of L equals
:: TERMORD:def 7
  p.(HT(p,T));
end;


definition
::: definition 5.15, p. 194
let n be Ordinal,
    T be connected TermOrder of n,
    L be non empty ZeroStr,
    p be Polynomial of n,L;
func HM(p,T) -> Monomial of n,L equals
:: TERMORD:def 8
  Monom(HC(p,T),HT(p,T));
end;

registration
let n be Ordinal,
    T be connected TermOrder of n,
    L be non trivial ZeroStr,
    p be non-zero Polynomial of n,L;
cluster HM(p,T) -> non-zero;
coherence
 proof
 set O = T;
   now per cases;
 case HC(p,O) <> 0.L;
   then HT(p,O) in Support(HM(p,O)) by Lm9;
   then HM(p,O) <> 0_(n,L) by POLYNOM7:1;
   hence thesis by POLYNOM7:def 2;
 end;
 case HC(p,O) = 0.L;
   then p = 0_(n,L) by Lm7;
   hence thesis by POLYNOM7:def 2;
 end;
 end;
 hence thesis;
 end;
cluster HC(p,T) -> non-zero;
coherence
 proof
 set O = T, a = HC(p,O);
   now assume a = 0.L;
   then p.(HT(p,O)) = 0.L by Def7;
   then not(HT(p,O)) in Support p by POLYNOM1:def 9;
   then Support p = {} by Def6;
   then p = 0_(n,L) by POLYNOM7:1;
   hence contradiction by POLYNOM7:def 2;
 end;
 hence thesis by RLVECT_1:def 13;
 end;
end;

theorem :: TERMORD:17
  for n being Ordinal,
    T being connected TermOrder of n,
    L being non empty ZeroStr,
    p being Polynomial of n,L
holds HC(p,T) = 0.L iff p = 0_(n,L);

theorem :: TERMORD:18
  for n being Ordinal,
    T being connected TermOrder of n,
    L being non trivial ZeroStr,
    p being Polynomial of n,L
holds (HM(p,T)).(HT(p,T)) = p.(HT(p,T));

theorem :: TERMORD:19
for n being Ordinal,
    T being connected TermOrder of n,
    L being non trivial ZeroStr,
    p being Polynomial of n,L,
    b being bag of n st b <> HT(p,T)
holds HM(p,T).b = 0.L;

theorem :: TERMORD:20
  for n being Ordinal,
    T being connected TermOrder of n,
    L being non trivial ZeroStr,
    p being Polynomial of n,L
holds Support(HM(p,T)) c= Support(p);

theorem :: TERMORD:21
  for n being Ordinal,
    T being connected TermOrder of n,
    L being non trivial ZeroStr,
    p being Polynomial of n,L
holds Support(HM(p,T)) = {} or Support(HM(p,T)) = {HT(p,T)};

theorem :: TERMORD:22
  for n being Ordinal,
    T being connected TermOrder of n,
    L being non trivial ZeroStr,
    p being Polynomial of n,L
holds term(HM(p,T)) = HT(p,T) & coefficient(HM(p,T)) = HC(p,T);

theorem :: TERMORD:23
  for n being Ordinal,
    T being connected TermOrder of n,
    L being non empty ZeroStr,
    m being Monomial of n,L
holds HT(m,T) = term(m) & HC(m,T) = coefficient(m) & HM(m,T) = m;

theorem :: TERMORD:24
  for n being Ordinal,
    T being connected TermOrder of n,
    L being non empty ZeroStr,
    c being ConstPoly of n,L
holds HT(c,T) = EmptyBag n & HC(c,T) = c.(EmptyBag n);

theorem :: TERMORD:25
  for n being Ordinal,
    T being connected TermOrder of n,
    L being non empty ZeroStr,
    a being Element of L
holds HT(a _(n,L),T) = EmptyBag n & HC(a _(n,L),T) = a;

theorem :: TERMORD:26
for n being Ordinal,
    T being connected TermOrder of n,
    L being non trivial ZeroStr,
    p being Polynomial of n,L
holds HT(HM(p,T),T) = HT(p,T);

theorem :: TERMORD:27
  for n being Ordinal,
    T being connected TermOrder of n,
    L being non trivial ZeroStr,
    p being Polynomial of n,L
holds HC(HM(p,T),T) = HC(p,T);

theorem :: TERMORD:28
  for n being Ordinal,
    T being connected TermOrder of n,
    L being non empty ZeroStr,
    p being Polynomial of n,L
holds HM(HM(p,T),T) = HM(p,T);

theorem :: TERMORD:29
for n being Ordinal,
    T being admissible connected TermOrder of n,
    L being add-associative right_complementable left_zeroed right_zeroed
            unital distributive domRing-like (non trivial doubleLoopStr),
    p,q being non-zero Polynomial of n,L
holds HT(p,T) + HT(q,T) in Support(p*'q);

theorem :: TERMORD:30
for n being Ordinal,
    L being add-associative right_complementable right_zeroed
            unital distributive (non empty doubleLoopStr),
    p,q being Polynomial of n,L
holds Support(p*'q) c= {s + t where s,t is Element of Bags n :
                                  s in Support p & t in Support q};

theorem :: TERMORD:31
::: lemma 5.17 (i), p. 195
for n being Ordinal,
    T being admissible connected TermOrder of n,
    L being add-associative right_complementable right_zeroed
            unital distributive domRing-like (non trivial doubleLoopStr),
    p,q being non-zero Polynomial of n,L
holds HT(p*'q,T) = HT(p,T) + HT(q,T);

theorem :: TERMORD:32
::: lemma 5.17 (iii), p. 195
for n being Ordinal,
    T being admissible connected TermOrder of n,
    L being add-associative right_complementable right_zeroed
            unital distributive domRing-like (non trivial doubleLoopStr),
    p,q being non-zero Polynomial of n,L
holds HC(p*'q,T) = HC(p,T) * HC(q,T);

theorem :: TERMORD:33
::: lemma 5.17 (ii), p. 195
  for n being Ordinal,
    T being admissible connected TermOrder of n,
    L being add-associative right_complementable right_zeroed
            unital distributive domRing-like (non trivial doubleLoopStr),
    p,q being non-zero Polynomial of n,L
holds HM(p*'q,T) = HM(p,T) *' HM(q,T);

theorem :: TERMORD:34
::: lemma 5.17 (iv), p. 195
  for n being Ordinal,
    T being admissible connected TermOrder of n,
    L being right_zeroed (non empty LoopStr),
    p,q being Polynomial of n,L
holds HT(p+q,T) <= max(HT(p,T),HT(q,T),T), T;

begin :: Reductum

definition
::: definition 5.15, p. 194
let n be Ordinal,
    T be connected TermOrder of n,
    L be add-associative right_complementable right_zeroed
         (non empty LoopStr),
    p be Polynomial of n,L;
func Red(p,T) -> Polynomial of n,L equals
:: TERMORD:def 9
  p - HM(p,T);
end;

theorem :: TERMORD:35
  for n being Ordinal,
    T being connected TermOrder of n,
    L being add-associative right_complementable right_zeroed
            (non trivial LoopStr),
    p being Polynomial of n,L
holds Support(Red(p,T)) c= Support(p);

theorem :: TERMORD:36
  for n being Ordinal,
    T being connected TermOrder of n,
    L being add-associative right_complementable right_zeroed
            (non trivial LoopStr),
    p being Polynomial of n,L
holds Support(Red(p,T)) = Support(p) \ {HT(p,T)};

theorem :: TERMORD:37
  for n being Ordinal,
    T being connected TermOrder of n,
    L being add-associative right_complementable right_zeroed
            (non trivial LoopStr),
    p being Polynomial of n,L
holds Support(HM(p,T) + Red(p,T)) = Support p;

theorem :: TERMORD:38
  for n being Ordinal,
    T being connected TermOrder of n,
    L being add-associative right_complementable right_zeroed
            (non trivial LoopStr),
    p being Polynomial of n,L
holds HM(p,T) + Red(p,T) = p;

theorem :: TERMORD:39
  for n being Ordinal,
    T being connected TermOrder of n,
    L being add-associative right_complementable right_zeroed
            (non trivial LoopStr),
    p being Polynomial of n,L
holds (Red(p,T)).(HT(p,T)) = 0.L;

theorem :: TERMORD:40
  for n being Ordinal,
    T being connected TermOrder of n,
    L being add-associative right_complementable right_zeroed
            (non trivial LoopStr),
    p being Polynomial of n,L,
    b being bag of n st b in Support p & b <> HT(p,T)
holds (Red(p,T)).b = p.b;
