:: Boolean Posets, Posets under Inclusion and Products of Relational
:: Structures
::  by Adam Grabowski and Robert Milewski
::
:: Received September 20, 1996
:: Copyright (c) 1996 Association of Mizar Users

environ

 vocabulary LATTICES, LATTICE3, ORDERS_1, FILTER_1, BOOLE, BHSP_3, WELLORD2,
      RELAT_1, RELAT_2, CAT_1, YELLOW_0, WELLORD1, TARSKI, SETFAM_1, ORDINAL2,
      PRE_TOPC, REALSET1, PRALG_1, FUNCT_1, PBOOLE, FUNCOP_1, CARD_3, RLVECT_2,
      GROUP_1, FUNCT_2, SEQM_3, ORDERS_3, YELLOW_1;
 notation TARSKI, XBOOLE_0, ZFMISC_1, SUBSET_1, RELAT_1, RELAT_2, RELSET_1,
      SETFAM_1, REALSET1, FUNCT_1, STRUCT_0, TOPS_2, WELLORD2, TOLER_1,
      PARTFUN1, FUNCT_2, ORDERS_1, LATTICES, ORDERS_3, LATTICE3, PRE_TOPC,
      PRE_CIRC, PBOOLE, CARD_3, PRALG_1, YELLOW_0;
 constructors YELLOW_0, WELLORD2, TOLER_1, ORDERS_3, TOPS_2, PRE_CIRC, KNASTER;
 clusters STRUCT_0, LATTICES, LATTICE3, YELLOW_0, ORDERS_1, RELSET_1, CANTOR_1,
      PRE_TOPC, KNASTER, FUNCOP_1, SUBSET_1, PARTFUN1, XBOOLE_0;
 requirements SUBSET, BOOLE;


begin :: Boolean Posets and Posets under Inclusion

 reserve X for set;

registration let L be Lattice;
 cluster LattPOSet L -> with_suprema with_infima;
 coherence by LATTICE3:11;
end;


registration let L be upper-bounded Lattice;
 cluster LattPOSet L -> upper-bounded;
 coherence
  proof
      ex x being Element of LattPOSet L st
     x is_>=_than the carrier of LattPOSet L
    proof
     A1: the carrier of LattPOSet L = the carrier of RelStr(#the carrier of L,
          LattRel L#) by LATTICE3:def 2
       .= the carrier of L;
     consider z be Element of L such that
      A2: for v being Element of L holds z"\/"v = z & v"\/"z = z
                                                          by LATTICES:def 14;
     reconsider z' = z as Element of LattPOSet L by A1;
     A3: z' is_<=_than {} by YELLOW_0:6;
     A4: z = Top L by A2,LATTICES:def 17;
       now let b' be Element of LattPOSet L;
      reconsider b = b' as Element of L by A1;
      assume b' is_<=_than {};
      A5: b% = b & z% = z by LATTICE3:def 3;
        b [= z by A4,LATTICES:45;
      hence z' >= b' by A5,LATTICE3:7;
     end;
     then A6: z' = "/\"({},LattPOSet L) by A3,YELLOW_0:31;
     take x = Top (LattPOSet L);
       now let a be Element of LattPOSet L;
      assume a in the carrier of LattPOSet L;
      reconsider a' = a as Element of L by A1;
      reconsider x' = x as Element of L by A1;
      A7: a'% = a' & x'% = x' by LATTICE3:def 3;
        Top (LattPOSet L) = Top L by A4,A6,YELLOW_0:def 12;
      then a' [= x' by LATTICES:45;
      hence a <= x by A7,LATTICE3:7;
     end;
     hence x is_>=_than the carrier of LattPOSet L by LATTICE3:def 9;
    end;
    hence LattPOSet L is upper-bounded by YELLOW_0:def 5;
   end;
end;


registration
 let L be lower-bounded Lattice;
 cluster LattPOSet L -> lower-bounded;
 coherence
 proof
    ex x being Element of LattPOSet L st
   x is_<=_than the carrier of LattPOSet L
  proof
   A1: the carrier of LattPOSet L = the carrier of RelStr(#the carrier of L,
        LattRel L#) by LATTICE3:def 2
     .= the carrier of L;
   consider z be Element of L such that
    A2: for v being Element of L holds z"/\"v = z & v"/\"z = z
                                                        by LATTICES:def 13;
   reconsider z' = z as Element of LattPOSet L by A1;
   A3: z' is_>=_than {} by YELLOW_0:6;
   A4: z = Bottom L by A2,LATTICES:def 16;
     now let b' be Element of LattPOSet L;
    reconsider b = b' as Element of L by A1;
    assume b' is_>=_than {};
    A5: b% = b & z% = z by LATTICE3:def 3;
      z [= b by A4,LATTICES:41;
    hence z' <= b' by A5,LATTICE3:7;
   end;
   then A6: z' = "\/"({},LattPOSet L) by A3,YELLOW_0:30;
   take x = Bottom (LattPOSet L);
     now let a be Element of LattPOSet L;
    assume a in the carrier of LattPOSet L;
    reconsider a' = a as Element of L by A1;
    reconsider x' = x as Element of L by A1;
    A7: a'% = a' & x'% = x' by LATTICE3:def 3;
      Bottom (LattPOSet L) = Bottom L by A4,A6,YELLOW_0:def 11;
    then x' [= a' by LATTICES:41;
    hence x <= a by A7,LATTICE3:7;
   end;
   hence x is_<=_than the carrier of LattPOSet L by LATTICE3:def 8;
  end;
  hence LattPOSet L is lower-bounded by YELLOW_0:def 4;
 end;
end;


registration let L be complete Lattice;
 cluster LattPOSet L -> complete;
 coherence
 proof
    for X be set ex a be Element of LattPOSet L st X is_<=_than a &
   for b being Element of LattPOSet L st X is_<=_than b holds a <= b
  proof
   A1: the carrier of LattPOSet L = the carrier of RelStr(#the carrier of L,
        LattRel L#) by LATTICE3:def 2
     .= the carrier of L;
   let X be set;
   take a = "\/"(X,LattPOSet L);
   A2: a = "\/"(X,L) by YELLOW_0:29;
     X is_less_than "\/"(X,L) by LATTICE3:def 21;
   then X is_<=_than "\/"(X,L)% by LATTICE3:30;
   hence X is_<=_than a by A2,LATTICE3:def 3;
   let b be Element of LattPOSet L;
   reconsider b' = b as Element of L by A1;
   A3: "\/"(X,L)% = a & b'% = b by A2,LATTICE3:def 3;
   assume X is_<=_than b;
   then X is_<=_than b'% by LATTICE3:def 3;
   then X is_less_than b' by LATTICE3:30;
   then "\/"(X,L) [= b' by LATTICE3:def 21;
   hence a <= b by A3,LATTICE3:7;
  end;
  hence thesis by LATTICE3:def 12;
 end;
end;


definition let X be set;
 redefine func RelIncl X -> Order of X;
end;


definition
 let X be set;
 func InclPoset X -> strict RelStr equals
:: YELLOW_1:def 1
   RelStr(#X, RelIncl X#);
end;


registration
 let X be set;
 cluster InclPoset X -> reflexive antisymmetric transitive;
 coherence
  proof InclPoset X = RelStr(#X, RelIncl X#) by Def1;
   hence thesis;
  end;
end;


registration
 let X be non empty set;
 cluster InclPoset X -> non empty;
 coherence
  proof InclPoset X = RelStr(#X, RelIncl X#) by Def1;
   hence thesis;
  end;
end;


theorem :: YELLOW_1:1
 the carrier of InclPoset X = X &
  the InternalRel of InclPoset X = RelIncl X;

definition let X be set;
 func BoolePoset X -> strict RelStr equals
:: YELLOW_1:def 2
   LattPOSet BooleLatt X;
end;


registration let X be set;
 cluster BoolePoset X -> non empty reflexive antisymmetric transitive;
 coherence
  proof BoolePoset X = LattPOSet BooleLatt X by Def2;
   hence thesis;
  end;
end;


registration let X be set;
 cluster BoolePoset X -> complete;
 coherence
  proof BoolePoset X = LattPOSet BooleLatt X by Def2;
   hence thesis;
  end;
end;


theorem :: YELLOW_1:2
 for x,y be Element of BoolePoset X holds
  x <= y iff x c= y;

theorem :: YELLOW_1:3
 for X be non empty set, x,y be Element of InclPoset X holds
  x <= y iff x c= y;

theorem :: YELLOW_1:4
 BoolePoset X = InclPoset bool X;

theorem :: YELLOW_1:5
   for Y be Subset of bool X holds
  InclPoset Y is full SubRelStr of BoolePoset X;

theorem :: YELLOW_1:6
   for X be non empty set holds
  InclPoset X is with_suprema implies
   for x,y be Element of InclPoset X holds x \/ y c= x "\/" y;

theorem :: YELLOW_1:7
   for X be non empty set holds
  InclPoset X is with_infima implies
  for x,y be Element of InclPoset X holds x "/\" y c= x /\ y;

theorem :: YELLOW_1:8
 for X be non empty set holds
 for x,y be Element of InclPoset X st x \/ y in X holds
  x "\/" y = x \/ y;

theorem :: YELLOW_1:9
 for X be non empty set
 for x,y be Element of InclPoset X st x /\ y in X holds
  x "/\" y = x /\ y;

theorem :: YELLOW_1:10
   for L be RelStr st for x,y be Element of L holds x <= y iff x c= y holds
  the InternalRel of L = RelIncl the carrier of L;

theorem :: YELLOW_1:11
  for X be non empty set st
 (for x,y be set st (x in X & y in X) holds x \/ y in X)
   holds InclPoset X is with_suprema;

theorem :: YELLOW_1:12
   for X be non empty set st
  for x,y be set st (x in X & y in X) holds x /\ y in X holds
   InclPoset X is with_infima;

theorem :: YELLOW_1:13
for X be non empty set holds
  {} in X implies Bottom InclPoset X = {};

theorem :: YELLOW_1:14
 for X be non empty set holds
  union X in X implies Top InclPoset X = union X;

theorem :: YELLOW_1:15
   for X being non empty set holds
  InclPoset X is upper-bounded implies union X in X;

theorem :: YELLOW_1:16
   for X be non empty set holds
  InclPoset X is lower-bounded implies meet X in X;

theorem :: YELLOW_1:17
   for x,y be Element of BoolePoset X holds
  x "\/" y = x \/ y & x "/\" y = x /\ y;

theorem :: YELLOW_1:18
   Bottom BoolePoset X = {};

theorem :: YELLOW_1:19
   Top BoolePoset X = X;

theorem :: YELLOW_1:20
   for Y being non empty Subset of BoolePoset X holds
  inf Y = meet Y;

theorem :: YELLOW_1:21
   for Y being Subset of BoolePoset X holds
  sup Y = union Y;

theorem :: YELLOW_1:22
   for T being non empty TopSpace, X being Subset of InclPoset the topology of
T
  holds sup X = union X;

theorem :: YELLOW_1:23
   for T be non empty TopSpace holds Bottom InclPoset the topology of T = {};

theorem :: YELLOW_1:24
    for T be non empty TopSpace
   holds Top InclPoset the topology of T = the carrier of T;

registration let T be non empty TopSpace;
  cluster InclPoset the topology of T -> complete non trivial;
  coherence by Lm4,Lm5;
end;


theorem :: YELLOW_1:25
   for T being TopSpace, F being Subset-Family of T holds
  F is open iff F is Subset of InclPoset the topology of T;

begin  :: Products of Relational Structures

reserve x,y,z for set;

definition let R be Relation;
 attr R is RelStr-yielding means
:: YELLOW_1:def 3
 for v being set st v in rng R holds v is RelStr;
end;


registration
 cluster RelStr-yielding -> 1-sorted-yielding Function;
 coherence
  proof let F be Function such that
A1:  F is RelStr-yielding;
   let x be set;
   assume x in dom F;
   then F.x in rng F by FUNCT_1:def 5;
   hence F.x is 1-sorted by A1,Def3;
  end;
end;


registration let I be set;
 cluster RelStr-yielding ManySortedSet of I;
 existence
  proof consider R being RelStr;
   take I --> R;
   let v be set;
A1:  rng(I-->R) c= {R} by FUNCOP_1:19;
   assume v in rng(I-->R);
   hence thesis by A1,TARSKI:def 1;
  end;
end;


definition
 let J be non empty set,
     A be RelStr-yielding ManySortedSet of J,
     j be Element of J;
 redefine func A.j -> RelStr;
end;


definition let I be set;
 let J be RelStr-yielding ManySortedSet of I;
 func product J -> strict RelStr means
:: YELLOW_1:def 4
 the carrier of it = product Carrier J &
  for x,y being Element of it st x in product Carrier J
   holds x <= y iff ex f,g being Function st f = x & g = y &
    for i be set st i in I
     ex R being RelStr, xi,yi being Element of R
       st R = J.i & xi = f.i & yi = g.i & xi <= yi;
end;


registration
 let X be set;
 let L be RelStr;
 cluster X --> L -> RelStr-yielding;
 coherence
 proof
   let v be set;
A1:  rng(X-->L) c= {L} by FUNCOP_1:19;
   assume v in rng(X-->L);
   hence thesis by A1,TARSKI:def 1;
 end;
end;


definition
 let I be set;
 let T be RelStr;
 func T|^I -> strict RelStr equals
:: YELLOW_1:def 5
   product (I --> T);
end;


theorem :: YELLOW_1:26
  for J be RelStr-yielding ManySortedSet of {} holds
   product J = RelStr (#{{}}, id {{}}#);

theorem :: YELLOW_1:27
 for Y be RelStr holds
  Y|^{} = RelStr (#{{}}, id {{}}#);

theorem :: YELLOW_1:28
 for X be set, Y be RelStr holds
  Funcs (X, the carrier of Y) = the carrier of Y|^X;

registration let X be set;
 let Y be non empty RelStr;
 cluster Y|^X -> non empty;
 coherence
 proof
  consider f be Function of X, the carrier of Y;
    f in Funcs (X, the carrier of Y) by FUNCT_2:11;
  then f in the carrier of Y|^X by Th28;
  hence thesis by STRUCT_0:def 1;
 end;
end;

registration let X be set;
 let Y be reflexive non empty RelStr;
 cluster Y|^X -> reflexive;
 coherence
 proof
  per cases;
  suppose X is empty;
   hence thesis by Th27;
  end;
  suppose X is non empty;
  then reconsider X as non empty set;
    for x being Element of Y|^X holds x <= x
  proof
   let x be Element of Y|^X;
     x in the carrier of Y|^X;
then A1: x in the carrier of product (X --> Y) by Def5;
   reconsider x' = x as Element of product (X --> Y)
     by Def5;
A2: x' in product Carrier (X --> Y) by A1,Def4;
   reconsider x1 = x as Function of X, the carrier of Y by Lm6;
     ex f,g being Function st f = x' & g = x' &
    for i be set st i in X
     ex R being RelStr, xi,yi being Element of R
       st R = (X --> Y).i & xi = f.i & yi = g.i & xi <= yi
   proof
    take x1, x1;
    thus x1 = x' & x1 = x';
    let i be set; assume i in X;
    then reconsider i as Element of X;
    take R = (X --> Y).i;
   R = Y by FUNCOP_1:13;
    then reconsider xi = x1.i, yi = x1.i as Element of R;
    take xi, yi;
    reconsider xi1 = xi, yi1 = xi as Element of Y;
      xi1 <= yi1;
    hence thesis by FUNCOP_1:13;
   end;
   then x' <= x' by A2,Def4;
   then [x',x'] in the InternalRel of product (X --> Y) by ORDERS_1:def 9;
   then [x,x] in the InternalRel of Y|^X by Def5;
   hence thesis by ORDERS_1:def 9;
  end;
  hence thesis by YELLOW_0:def 1;
 end;
 end;
end;


registration let Y be non empty RelStr;
 cluster Y|^{} -> trivial;
 coherence by Th27;
end;


registration
 let Y be non empty reflexive RelStr;
 cluster Y|^{} -> with_infima with_suprema antisymmetric;
 coherence;
end;


registration let X be set;
 let Y be transitive non empty RelStr;
 cluster Y|^X -> transitive;
 coherence
 proof
  set IT = Y|^X;
    now let x,y,z be Element of IT;
A1:x in the carrier of IT & y in the carrier of IT & z in the carrier of IT;
  reconsider x1 = x, y1 = y, z1 = z as
    Element of product (X --> Y) by Def5;
     x1 in the carrier of product (X --> Y) &
    y1 in the carrier of product (X --> Y) by A1,Def5;
then A2:  x1 in product Carrier (X --> Y) & y1 in product Carrier (X --> Y)
    by Def4;
   assume x <= y & y <= z;
   then [x,y] in the InternalRel of IT & [y,z] in the InternalRel of IT
     by ORDERS_1:def 9;
   then [x1,y1] in the InternalRel of product (X --> Y) &
     [y1,z1] in the InternalRel of product (X --> Y) by Def5;
then A3: x1 <= y1 & y1 <= z1 by ORDERS_1:def 9;
   then consider f,g being Function such that A4: f = x1 & g = y1 &
    for i be set st i in X
     ex R being RelStr, xi,yi being Element of R
       st R = (X --> Y).i & xi = f.i & yi = g.i & xi <= yi by A2,Def4;
   consider f1,g1 being Function such that A5: f1 = y1 & g1 = z1 &
    for i be set st i in X
     ex R being RelStr, xi,yi being Element of R
       st R = (X --> Y).i & xi = f1.i & yi = g1.i & xi <= yi by A2,A3,Def4;
     ex f2,g2 being Function st f2 = x1 & g2 = z1 &
    for i be set st i in X
     ex R being RelStr, xi,yi being Element of R
       st R = (X --> Y).i & xi = f2.i & yi = g2.i & xi <= yi
proof
 reconsider f2 = x, g2 = z as Function of X, the carrier of Y by Lm6;
 take f2, g2;
 thus f2 = x1 & g2 = z1;
 let i be set; assume A6: i in X;
 then reconsider X as non empty set;
 reconsider i as Element of X by A6;
 reconsider R = (X --> Y).i as RelStr;
A7:  R = Y by FUNCOP_1:13;
 then f2.i in the carrier of R & g2.i in the carrier of R by FUNCT_2:7;
 then reconsider xi = f2.i, yi = g2.i as Element of R;
 take R, xi, yi;
 consider R1 being RelStr, xi1,yi1 being Element of R1 such that
A8:   R1 = (X --> Y).i & xi1 = f.i & yi1 = g.i & xi1 <= yi1 by A4;
 consider R2 being RelStr, xi2,yi2 being Element of R2 such that
A9:   R2 = (X --> Y).i & xi2 = f1.i & yi2 = g1.i & xi2 <= yi2 by A5;
 thus thesis by A4,A5,A7,A8,A9,YELLOW_0:def 2;
end;
   then x1 <= z1 by A2,Def4;
   then [x1, z1] in the InternalRel of product (X --> Y) by ORDERS_1:def 9;
   then [x, z] in the InternalRel of IT by Def5;
   hence x <= z by ORDERS_1:def 9;
  end;
  hence thesis by YELLOW_0:def 2;
 end;
end;


registration let X be set;
 let Y be antisymmetric non empty RelStr;
 cluster Y|^X -> antisymmetric;
 coherence
 proof
  set IT = Y|^X;
    now let x,y be Element of IT;
A1:x in the carrier of IT & y in the carrier of IT;
  reconsider x1 = x, y1 = y as
    Element of product (X --> Y) by Def5;
     x1 in the carrier of product (X --> Y) &
    y1 in the carrier of product (X --> Y) by A1,Def5;
then A2:  x1 in product Carrier (X --> Y) & y1 in product Carrier (X --> Y)
    by Def4;
   assume x <= y & y <= x;
   then [x,y] in the InternalRel of IT & [y,x] in the InternalRel of IT
     by ORDERS_1:def 9;
   then [x1,y1] in the InternalRel of product (X --> Y) &
     [y1,x1] in the InternalRel of product (X --> Y) by Def5;
then A3: x1 <= y1 & y1 <= x1 by ORDERS_1:def 9;
   then consider f,g being Function such that A4: f = x1 & g = y1 &
    for i be set st i in X
     ex R being RelStr, xi,yi being Element of R
       st R = (X --> Y).i & xi = f.i & yi = g.i & xi <= yi by A2,Def4;
   consider f1,g1 being Function such that A5: f1 = y1 & g1 = x1 &
    for i be set st i in X
     ex R being RelStr, xi,yi being Element of R
       st R = (X --> Y).i & xi = f1.i & yi = g1.i & xi <= yi by A2,A3,Def4;
   reconsider x1' = x, y1' = y as Function of X, the carrier of Y by Lm6;
A6: dom x1' = X & dom y1' = X by FUNCT_2:def 1;
     now
     let i be set; assume A7: i in X;
     then consider R1 being RelStr, xi1,yi1 being Element of R1 such that
A8:     R1 = (X --> Y).i & xi1 = f.i & yi1 = g.i & xi1 <= yi1 by A4;
     consider R2 being RelStr, xi2,yi2 being Element of R2 such that
A9:     R2 = (X --> Y).i & xi2 = f1.i & yi2 = g1.i & xi2 <= yi2 by A5,A7;
    Y = R1 & Y = R2 by A7,A8,A9,FUNCOP_1:13;
     hence x1'.i = y1'.i by A4,A5,A8,A9,ORDERS_1:25;
   end;
   hence x = y by A6,FUNCT_1:9;
  end;
  hence thesis by YELLOW_0:def 3;
 end;
end;


registration let X be non empty set;
 let Y be non empty with_infima antisymmetric RelStr;
 cluster Y|^X -> with_infima;
 coherence
 proof
    set IT = Y|^X;
    let x, y be Element of IT;
    reconsider x' = x as Function of X, the carrier of Y by Lm6;
    reconsider y' = y as Function of X, the carrier of Y by Lm6;
    defpred P[set, set] means ex xa, ya be Element of Y
      st xa = x'.$1 & ya = y'.$1 & $2 = xa "/\" ya;
A1:  for x be set st x in X ex y be set st y in the carrier of Y & P[x,y]
    proof
     let a be set; assume a in X;
     then x'.a in the carrier of Y & y'.a in the carrier of Y by FUNCT_2:7;
     then reconsider xa = x'.a, ya = y'.a as Element of Y;
     take y = xa "/\" ya;
     thus y in the carrier of Y;
     take xa, ya;
     thus thesis;
    end;
    consider f be Function of X, the carrier of Y such that
A2:    for a be set st a in X holds P[a,f.a] from FUNCT_2:sch 1(A1);
      f in Funcs (X, the carrier of Y) by FUNCT_2:11;
    then f in the carrier of IT by Th28;
    then reconsider z = f as Element of IT;
    take z;
A3:  z <= x
    proof
     reconsider x1 = x, z1 = z as Element of
       product (X --> Y) by Lm6;
       z1 in the carrier of IT;
     then z1 in the carrier of product (X --> Y) by Def5;
then A4:   z1 in product Carrier (X --> Y) by Def4;
      ex f,g being Function st f = z1 & g = x1 &
      for i be set st i in X
       ex R being RelStr, xi,yi being Element of R
        st R = (X --> Y).i & xi = f.i & yi = g.i & xi <= yi
     proof
      take f, x';
      thus f = z1 & x' = x1;
      let i be set; assume i in X;
      then reconsider i as Element of X;
      reconsider R = (X --> Y).i as RelStr;
A5:    R = Y by FUNCOP_1:13;
      then reconsider xi = f.i, yi = x'.i as Element of R;
      take R, xi, yi;
      consider xa, ya be Element of Y such that
A6:     xa = x'.i & ya = y'.i & f.i = xa "/\" ya by A2;
      thus thesis by A5,A6,YELLOW_0:23;
     end;
     then z1 <= x1 by A4,Def4;
     then [z1,x1] in the InternalRel of product (X --> Y) by ORDERS_1:def 9;
     then [z1,x1] in the InternalRel of IT by Def5;
     hence thesis by ORDERS_1:def 9;
    end;
A7:  z <= y
    proof
     reconsider y1 = y, z1 = z as Element of
       product (X --> Y) by Lm6;
       z1 in the carrier of IT;
     then z1 in the carrier of product (X --> Y) by Def5;
then A8:   z1 in product Carrier (X --> Y) by Def4;
      ex f,g being Function st f = z1 & g = y1 &
      for i be set st i in X
       ex R being RelStr, xi,yi being Element of R
        st R = (X --> Y).i & xi = f.i & yi = g.i & xi <= yi
     proof
      take f, y';
      thus f = z1 & y' = y1;
      let i be set; assume i in X;
      then reconsider i as Element of X;
      reconsider R = (X --> Y).i as RelStr;
A9:    R = Y by FUNCOP_1:13;
      then reconsider xi = f.i, yi = y'.i as Element of R;
      take R, xi, yi;
      consider xa, ya be Element of Y such that
A10:     xa = x'.i & ya = y'.i & f.i = xa "/\" ya by A2;
      thus thesis by A9,A10,YELLOW_0:23;
     end;
     then z1 <= y1 by A8,Def4;
     then [z1,y1] in the InternalRel of product (X --> Y) by ORDERS_1:def 9;
     then [z1,y1] in the InternalRel of IT by Def5;
     hence thesis by ORDERS_1:def 9;
    end;
      for z' being Element of IT st z' <= x & z' <= y holds z' <= z
    proof
     let z' be Element of IT; assume A11: z' <= x & z' <= y;
       z' <= z
     proof
    reconsider z2 = z', z3 = z, z4 = y, z5 = x as Element of the carrier
        of product (X --> Y) by Lm6;
    reconsider J = z2, K = z3 as Function of X, the carrier of Y by Lm6;
      z' in the carrier of product (X --> Y) by Lm6;
then A12:  z2 in product Carrier (X --> Y) by Def4;
      [z',x] in the InternalRel of IT by A11,ORDERS_1:def 9;
then A13: [z2,z5] in the InternalRel of product (X --> Y) by Def5;
      [z',y] in the InternalRel of IT by A11,ORDERS_1:def 9;
    then [z2,z4] in the InternalRel of product (X --> Y) by Def5;
then A14:  z2 <= z5 & z2 <= z4 by A13,ORDERS_1:def 9;
    then consider f1,g1 being Function such that
A15:     f1 = z2 & g1 = z5 &
    for i be set st i in X
     ex R being RelStr, xi,yi being Element of R
       st R = (X --> Y).i & xi = f1.i & yi = g1.i & xi <= yi by A12,Def4;
    consider f2,g2 being Function such that
A16:     f2 = z2 & g2 = z4 &
    for i be set st i in X
     ex R being RelStr, xi,yi being Element of R
       st R = (X --> Y).i & xi = f2.i & yi = g2.i & xi <= yi by A12,A14,Def4;
      ex f,g being Function st f = z2 & g = z3 &
      for i be set st i in X
       ex R being RelStr, xi,yi being Element of R
        st R = (X --> Y).i & xi = f.i & yi = g.i & xi <= yi
      proof
      take J, K;
      thus J = z2 & K = z3;
      let i be set; assume i in X;
      then reconsider i as Element of X;
      reconsider R = (X --> Y).i as RelStr;
A17:    R = Y by FUNCOP_1:13;
      then reconsider xi = J.i, yi = K.i as Element of R;
      take R, xi, yi;
      consider xa, ya be Element of Y such that
A18:        xa = x'.i & ya = y'.i & f.i = xa "/\" ya by A2;
     consider R1 being RelStr, xi1,yi1 being Element of R1 such that
A19:     R1 = (X --> Y).i &
      xi1 = f1.i & yi1 = g1.i & xi1 <= yi1 by A15;
     consider R2 being RelStr, xi2,yi2 being Element of R2 such that
A20:     R2 = (X --> Y).i & xi2 = f2.i & yi2 = g2.i & xi2 <= yi2 by A16;
      thus thesis by A15,A16,A17,A18,A19,A20,YELLOW_0:23;
      end;
      then z2 <= z3 by A12,Def4;
      then [z2,z3] in the InternalRel of product (X --> Y) by ORDERS_1:def 9;
      then [z2,z3] in the InternalRel of IT by Def5;
      hence thesis by ORDERS_1:def 9;
     end;
     hence thesis;
    end;
    hence thesis by A3,A7;
 end;
end;


registration let X be non empty set;
 let Y be non empty with_suprema antisymmetric RelStr;
 cluster Y|^X -> with_suprema;
 coherence
 proof
    set IT = Y|^X;
    let x, y be Element of IT;
    reconsider x' = x as Function of X, the carrier of Y by Lm6;
    reconsider y' = y as Function of X, the carrier of Y by Lm6;
    defpred P[set, set] means ex xa, ya be Element of Y
      st xa = x'.$1 & ya = y'.$1 & $2 = xa "\/" ya;
A1:  for x be set st x in X ex y be set st y in the carrier of Y & P[x,y]
    proof
     let a be set; assume a in X;
     then x'.a in the carrier of Y & y'.a in the carrier of Y by FUNCT_2:7;
     then reconsider xa = x'.a, ya = y'.a as Element of Y;
     take y = xa "\/" ya;
     thus y in the carrier of Y;
     take xa, ya;
     thus thesis;
    end;
    consider f be Function of X, the carrier of Y such that
A2:    for a be set st a in X holds P[a,f.a] from FUNCT_2:sch 1(A1);
      f in Funcs (X, the carrier of Y) by FUNCT_2:11;
    then f in the carrier of IT by Th28;
    then reconsider z = f as Element of IT;
    take z;
A3:  x <= z
    proof
     reconsider x1 = x, z1 = z as Element of
       product (X --> Y) by Lm6;
      x1 in the carrier of product (X --> Y) by Lm6;
then A4:  x1 in product Carrier (X --> Y) by Def4;
      ex f,g being Function st f = x1 & g = z1 &
      for i be set st i in X
       ex R being RelStr, xi,yi being Element of R
        st R = (X --> Y).i & xi = f.i & yi = g.i & xi <= yi
     proof
      take x',f;
      thus x' = x1 & f = z1;
      let i be set; assume i in X;
      then reconsider i as Element of X;
      reconsider R = (X --> Y).i as RelStr;
A5:    R = Y by FUNCOP_1:13;
      then reconsider yi = f.i, xi = x'.i as Element of R;
      take R, xi, yi;
      consider xa, ya be Element of Y such that
A6:     xa = x'.i & ya = y'.i & f.i = xa "\/" ya by A2;
      thus thesis by A5,A6,YELLOW_0:22;
     end;
     then x1 <= z1 by A4,Def4;
     then [x1,z1] in the InternalRel of product (X --> Y) by ORDERS_1:def 9;
     then [x1,z1] in the InternalRel of IT by Def5;
     hence thesis by ORDERS_1:def 9;
    end;
A7:  y <= z
    proof
     reconsider y1 = y, z1 = z as Element of
       product (X --> Y) by Lm6;
      y1 in the carrier of product (X --> Y) by Lm6;
then A8:  y1 in product Carrier (X --> Y) by Def4;
      ex f,g being Function st f = y1 & g = z1 &
      for i be set st i in X
       ex R being RelStr, xi,yi being Element of R
        st R = (X --> Y).i & xi = f.i & yi = g.i & xi <= yi
     proof
      take y', f;
      thus y' = y1 & f = z1;
      let i be set; assume i in X;
      then reconsider i as Element of X;
      reconsider R = (X --> Y).i as RelStr;
A9:    R = Y by FUNCOP_1:13;
      then reconsider yi = f.i, xi = y'.i as Element of R;
      take R, xi, yi;
      consider xa, ya be Element of Y such that
A10:     xa = x'.i & ya = y'.i & f.i = xa "\/" ya by A2;
      thus thesis by A9,A10,YELLOW_0:22;
     end;
     then y1 <= z1 by A8,Def4;
     then [y1,z1] in the InternalRel of product (X --> Y) by ORDERS_1:def 9;
     then [y1,z1] in the InternalRel of IT by Def5;
     hence thesis by ORDERS_1:def 9;
    end;
      for z' being Element of IT st z' >= x & z' >= y holds z' >= z
    proof
     let z' be Element of IT; assume A11: z' >= x & z' >= y;
       z' >= z
     proof
    reconsider z2 = z', z3 = z, z4 = y, z5 = x as Element of the carrier
        of product (X --> Y) by Lm6;
    reconsider K = z3, J = z2 as Function of X, the carrier of Y by Lm6;
       z5 in the carrier of product (X --> Y) &
     z3 in the carrier of product (X --> Y) &
     z4 in the carrier of product (X --> Y) by Lm6;
then A12:  z5 in product Carrier (X --> Y) &
     z3 in product Carrier (X --> Y) &
     z4 in product Carrier (X --> Y) by Def4;
      [x, z'] in the InternalRel of IT by A11,ORDERS_1:def 9;
then A13: [z5,z2] in the InternalRel of product (X --> Y) by Def5;
      [y, z'] in the InternalRel of IT by A11,ORDERS_1:def 9;
    then [z4,z2] in the InternalRel of product (X --> Y) by Def5;
then A14:  z5 <= z2 & z4 <= z2 by A13,ORDERS_1:def 9;
    then consider f1,g1 being Function such that
A15:     f1 = z5 & g1 = z2 &
    for i be set st i in X
     ex R being RelStr, xi,yi being Element of R
       st R = (X --> Y).i & xi = f1.i & yi = g1.i & xi <= yi by A12,Def4;
    consider f2,g2 being Function such that
A16:     f2 = z4 & g2 = z2 &
    for i be set st i in X
     ex R being RelStr, xi,yi being Element of R
       st R = (X --> Y).i & xi = f2.i & yi = g2.i & xi <= yi by A12,A14,Def4;
      ex f,g being Function st f = z3 & g = z2 &
    for i be set st i in X
       ex R being RelStr, xi,yi being Element of R
        st R = (X --> Y).i & xi = f.i & yi = g.i & xi <= yi
      proof
      take K, J;
      thus K = z3 & J = z2;
      let i be set; assume i in X;
      then reconsider i as Element of X;
      reconsider R = (X --> Y).i as RelStr;
A17:    R = Y by FUNCOP_1:13;
      then reconsider yi = J.i, xi = K.i as Element of R;
      take R, xi, yi;
      consider xa, ya be Element of Y such that
A18:      xa = x'.i & ya = y'.i & f.i = xa "\/" ya by A2;
     consider R1 being RelStr, xi1,yi1 being Element of R1 such that
A19:     R1 = (X --> Y).i &
      xi1 = f1.i & yi1 = g1.i & xi1 <= yi1 by A15;
     consider R2 being RelStr, xi2,yi2 being Element of R2 such that
A20:     R2 = (X --> Y).i & xi2 = f2.i & yi2 = g2.i & xi2 <= yi2 by A16;
      thus thesis by A15,A16,A17,A18,A19,A20,YELLOW_0:22;
      end;
      then z3 <= z2 by A12,Def4;
      then [z3,z2] in the InternalRel of product (X --> Y) by ORDERS_1:def 9;
      then [z3,z2] in the InternalRel of IT by Def5;
      hence thesis by ORDERS_1:def 9;
     end;
     hence thesis;
    end;
    hence thesis by A3,A7;
 end;
end;


definition let S,T be RelStr;
 func MonMaps (S,T) -> strict full SubRelStr of T|^the carrier of S means
:: YELLOW_1:def 6
     for f being map of S,T holds f in the carrier of it iff
    f in Funcs (the carrier of S, the carrier of T) &
  f is monotone;
end;


