:: The Sum and Product of Finite Sequences of Real Numbers
::  by Czes{\l}aw Byli\'nski
::
:: Received May 11, 1990
:: Copyright (c) 1990 Association of Mizar Users

environ

 vocabularies NUMBERS, NAT_1, FINSEQ_1, VALUED_0, FINSEQ_2, CARD_1, RELAT_1,
      SUBSET_1, XBOOLE_0, FUNCT_1, TARSKI, XREAL_0, ORDINAL1, ORDINAL4,
      BINOP_1, BINOP_2, ARYTM_1, ARYTM_3, SQUARE_1, FUNCOP_1, REAL_1, FINSEQOP,
      ZFMISC_1, VALUED_1, XXREAL_0, CARD_3, XCMPLX_0, SETWISEO, SETWOP_2,
      FINSOP_1, RVSUM_1;
 notations TARSKI, SUBSET_1, ZFMISC_1, ORDINAL1, NUMBERS, VALUED_0, XBOOLE_0,
      XCMPLX_0, XXREAL_0, XREAL_0, REAL_1, SQUARE_1, RELAT_1, FUNCT_1,
      PARTFUN1, BINOP_2, SETWISEO, FUNCT_2, BINOP_1, FUNCOP_1, FINSEQ_1,
      FINSEQ_2, FINSEQ_4, VALUED_1, NAT_1, SEQ_1, FINSOP_1, FINSEQOP, SETWOP_2;
 constructors PARTFUN1, BINOP_1, SETWISEO, SQUARE_1, NAT_1, BINOP_2, VALUED_1,
      SEQ_1, FINSEQOP, FINSEQ_4, FINSOP_1, SETWOP_2, RELSET_1, XXREAL_1,
      REAL_1;
 registrations XBOOLE_0, FUNCT_1, ORDINAL1, FUNCT_2, FUNCOP_1, NUMBERS,
      XCMPLX_0, XREAL_0, SQUARE_1, NAT_1, BINOP_2, MEMBERED, FINSEQ_1,
      FINSEQ_2, VALUED_0, VALUED_1, RELAT_1, XXREAL_0, REAL_1, FINSEQ_4,
      CARD_1;
 requirements NUMERALS, SUBSET, BOOLE, ARITHM, REAL;


begin :: Auxiliary theorems

registration
  let n be Nat;
  cluster n-long natural-valued FinSequence;
end;

registration
  cluster real-valued FinSequence;
end;

definition
  let F be real-valued Relation;
  redefine func rng F -> Subset of REAL;
end;

registration
  let D be non empty set;
  let F be Function of REAL,D;
  let F1 be real-valued FinSequence;
  cluster F*F1 -> FinSequence-like;
end;

registration
  let r be real number;
  cluster <*r*> -> real-valued;
end;

registration
  let r1, r2 be real number;
  cluster <*r1, r2*> -> real-valued;
end;

registration
  let r1, r2, r3 be real number;
  cluster <*r1, r2, r3*> -> real-valued;
end;

registration
  let r1, r2, r3, r4 be real number;
  cluster <*r1, r2, r3, r4*> -> real-valued;
end;

registration
  let j be Nat, r be real number;
  cluster j |-> r -> real-valued;
end;

registration
  let f, g be real-valued FinSequence;
  cluster f ^ g -> real-valued;
end;

reserve s for set,
  i,j,k for Nat,
  x,x1,x2,x3 for Element of REAL,
  r,r1,r2,r3,r4 for real number,
  F,F1,F2,F3 for real-valued FinSequence,
  R,R1,R2 for Element of i-tuples_on REAL;

canceled 2;

theorem :: RVSUM_1:3
  0 is_a_unity_wrt addreal;

definition
  redefine func diffreal equals
:: RVSUM_1:def 1
  addreal*(id REAL,compreal);
end;

definition
  func sqrreal -> UnOp of REAL means
:: RVSUM_1:def 2

  for r holds it.r = r^2;
end;

canceled 9;

theorem :: RVSUM_1:13
  1 is_a_unity_wrt multreal;

canceled 2;

theorem :: RVSUM_1:16
  multreal is_distributive_wrt addreal;

theorem :: RVSUM_1:17
  sqrreal is_distributive_wrt multreal;

definition
  let x be real number;
  func x multreal -> UnOp of REAL equals
:: RVSUM_1:def 3
  multreal[;](x,id REAL);
end;

canceled;

theorem :: RVSUM_1:19
  (r multreal).r1 = r*r1;

theorem :: RVSUM_1:20
  r multreal is_distributive_wrt addreal;

theorem :: RVSUM_1:21
  compreal is_an_inverseOp_wrt addreal;

theorem :: RVSUM_1:22
  addreal is having_an_inverseOp;

theorem :: RVSUM_1:23
  the_inverseOp_wrt addreal = compreal;

theorem :: RVSUM_1:24
  compreal is_distributive_wrt addreal;

definition
  let F1,F2;
  redefine func F1 + F2 -> FinSequence of REAL equals
:: RVSUM_1:def 4
  addreal.:(F1,F2);
  commutativity;
end;

definition
  let i,R1,R2;
  redefine func R1 + R2 -> Element of i-tuples_on REAL;
end;

canceled 2;

theorem :: RVSUM_1:27
  (R1+R2).s = R1.s + R2.s;

theorem :: RVSUM_1:28
  <*>REAL + F = <*>REAL;

theorem :: RVSUM_1:29
  <*r1*> + <*r2*> = <*r1+r2*>;

theorem :: RVSUM_1:30
  (i|->r1) + (i|->r2) = i|->(r1+r2);

canceled;

theorem :: RVSUM_1:32
  F1 + (F2 + F3) = F1 + F2 + F3;

theorem :: RVSUM_1:33
  R + (i|->(0 qua Real)) = R;

canceled;

theorem :: RVSUM_1:35
  (-F).s = -F.s;

definition
  let F;
  redefine func -F -> FinSequence of REAL equals
:: RVSUM_1:def 5
  compreal*F;
end;

definition
  let i,R;
  redefine func -R -> Element of i-tuples_on REAL;
end;

theorem :: RVSUM_1:36
  (-F).s = -(F.s);

theorem :: RVSUM_1:37
  -(<*>REAL) = <*>REAL;

theorem :: RVSUM_1:38
  -<*r*> = <*-r*>;

theorem :: RVSUM_1:39
  -(i|->r) = i|->-r;

theorem :: RVSUM_1:40
  R + -R = i|->0;

theorem :: RVSUM_1:41
  R1 + R2 = i|->0 implies R1 = -R2;

canceled;

theorem :: RVSUM_1:43
  for R1, R2 being complex-valued Function st -R1 = -R2 holds R1 = R2;

theorem :: RVSUM_1:44
  R1 + R = R2 + R implies R1 = R2;

theorem :: RVSUM_1:45
  -(F1 + F2) = -F1 + -F2;

definition
  let F1,F2;
  redefine func F1 - F2 -> FinSequence of REAL equals
:: RVSUM_1:def 6
  diffreal.:(F1,F2);
end;

definition
  let i,R1,R2;
  redefine func R1 - R2 -> Element of i-tuples_on REAL;
end;

canceled 2;

theorem :: RVSUM_1:48
  (R1-R2).s = R1.s - R2.s;

theorem :: RVSUM_1:49
  <*>REAL - F = <*>REAL & F - <*>REAL = <*>REAL;

theorem :: RVSUM_1:50
  <*r1*> - <*r2*> = <*r1-r2*>;

theorem :: RVSUM_1:51
  (i|->r1) - (i|->r2) = i|->(r1-r2);

theorem :: RVSUM_1:52
  F1 - F2 = F1 + - F2;

theorem :: RVSUM_1:53
  R - (i|->(0 qua Real)) = R;

theorem :: RVSUM_1:54
  (i|->(0 qua Real)) - R = -R;

theorem :: RVSUM_1:55
  F1 - -F2 = F1 + F2;

theorem :: RVSUM_1:56
  -(F1 - F2) = F2 - F1;

theorem :: RVSUM_1:57
  -(F1 - F2) = -F1 + F2;

theorem :: RVSUM_1:58
  R - R = i|->0;

theorem :: RVSUM_1:59
  R1 - R2 = i|->0 implies R1 = R2;

theorem :: RVSUM_1:60
  F1 - F2 - F3 = F1 - (F2 + F3);

theorem :: RVSUM_1:61
  F1 + (F2 - F3) = F1 + F2 - F3;

theorem :: RVSUM_1:62
  F1 - (F2 - F3) = F1 - F2 + F3;

theorem :: RVSUM_1:63
  R1 = R1 + R - R;

theorem :: RVSUM_1:64
  R1 = R1 - R + R;

notation
  let F,r;
  synonym r*F for r(#)F;
end;

canceled;

theorem :: RVSUM_1:66
  (r*F).s = r*(F.s);

definition
  let F,r;
  redefine func r*F -> FinSequence of REAL equals
:: RVSUM_1:def 7
  (r multreal)*F;
end;

definition
  let i,R,r;
  redefine func r*R -> Element of i-tuples_on REAL;
end;

theorem :: RVSUM_1:67
  (r*F).s = r*(F.s);

theorem :: RVSUM_1:68
  r*(<*>REAL) = <*>REAL;

theorem :: RVSUM_1:69
  r*<*r1*> = <*r*r1*>;

theorem :: RVSUM_1:70
  r1*(i|->r2) = i|->(r1*r2);

theorem :: RVSUM_1:71
  (r1*r2)*F = r1*(r2*F);

theorem :: RVSUM_1:72
  (r1 + r2)*F = r1*F + r2*F;

theorem :: RVSUM_1:73
  r*(F1+F2) = r*F1 + r*F2;

theorem :: RVSUM_1:74
  1*F = F;

theorem :: RVSUM_1:75
  0*R = i|->0;

theorem :: RVSUM_1:76
  (-1)*F = -F;

notation
  let F;
  synonym sqr F for F^2;
end;

definition
  let F;
  redefine func sqr F -> FinSequence of REAL equals
:: RVSUM_1:def 8
  sqrreal*F;
end;

definition
  let i,R;
  redefine func sqr R -> Element of i-tuples_on REAL;
end;

canceled 4;

theorem :: RVSUM_1:81
  sqr <*r*> = <*r^2*>;

theorem :: RVSUM_1:82
  sqr(i |-> r) = i |-> r^2;

theorem :: RVSUM_1:83
  sqr -F = sqr F;

theorem :: RVSUM_1:84
  sqr (r*F) = r^2 * sqr F;

notation
  let F1,F2;
  synonym mlt(F1,F2) for F1(#)F2;
end;

definition
  let F1,F2;
  redefine func mlt(F1,F2) -> FinSequence of REAL equals
:: RVSUM_1:def 9
  multreal.:(F1,F2);
  commutativity;
end;

canceled;

theorem :: RVSUM_1:86
  mlt(F1,F2).s = F1.s * F2.s;

definition
  let i,R1,R2;
  redefine func mlt(R1,R2) -> Element of i-tuples_on REAL;
end;

theorem :: RVSUM_1:87 ::=VALUED_1:5
  mlt(F1,F2).s = F1.s * F2.s;

theorem :: RVSUM_1:88
  mlt(<*>REAL,F) = <*>REAL;

theorem :: RVSUM_1:89
  mlt(<*r1*>,<*r2*>) = <*r1*r2*>;

canceled 2;

theorem :: RVSUM_1:92
  mlt(i|->r,R) = r*R;

theorem :: RVSUM_1:93
  mlt(i|->r1,i|->r2) = i|->(r1*r2);

theorem :: RVSUM_1:94
  r*mlt(F1,F2) = mlt(r*F1,F2);

canceled;

theorem :: RVSUM_1:96 ::=Th92
  r*R = mlt(i|->r,R);

theorem :: RVSUM_1:97
  sqr(F) = mlt(F,F);

theorem :: RVSUM_1:98
  sqr(F1 + F2) = sqr F1 + 2*mlt(F1,F2) + sqr F2;

theorem :: RVSUM_1:99
  sqr(F1 - F2) = sqr F1 - 2*mlt(F1,F2) + sqr F2;

theorem :: RVSUM_1:100
  sqr mlt(F1,F2) = mlt(sqr F1,sqr F2);

:: Finite sum of Finite Sequence of Real Numbers

notation
  let F be Relation;
  synonym F is complex-yielding for F is complex-valued;
end;

registration
  cluster -> complex-valued FinSequence of COMPLEX;
  cluster real-valued complex-valued FinSequence;
end;

definition
  let F be complex-valued FinSequence;
  canceled;
  func Sum F -> complex number means
:: RVSUM_1:def 11

  ex f being FinSequence of COMPLEX st f = F & it = addcomplex $$ f;
end;

registration
  let F be real-valued FinSequence;
  cluster Sum F -> real;
end;

theorem :: RVSUM_1:101
  for F being FinSequence of REAL holds Sum F = addreal $$ F;

definition
  let F be FinSequence of COMPLEX;
  redefine func Sum F -> Element of COMPLEX equals
:: RVSUM_1:def 12
  addcomplex $$ F;
end;

definition
  let F be FinSequence of REAL;
  redefine func Sum F -> Element of REAL equals
:: RVSUM_1:def 13
  addreal $$ F;
end;

theorem :: RVSUM_1:102
  Sum(<*> REAL) = 0;

theorem :: RVSUM_1:103
  Sum <*r*> = r;

theorem :: RVSUM_1:104
  Sum(F^<*r*>) = Sum F + r;

theorem :: RVSUM_1:105
  Sum(F1^F2) = Sum F1 + Sum F2;

theorem :: RVSUM_1:106
  Sum(<*r*>^F) = r + Sum F;

theorem :: RVSUM_1:107
  Sum<*r1,r2*> = r1 + r2;

theorem :: RVSUM_1:108
  Sum<*r1,r2,r3*> = r1 + r2 + r3;

theorem :: RVSUM_1:109
  for R being Element of 0-tuples_on REAL holds Sum R = 0;

theorem :: RVSUM_1:110
  Sum(i |-> r) = i*r;

theorem :: RVSUM_1:111
  Sum(i |-> (0 qua Real)) = 0;

theorem :: RVSUM_1:112
  (for j st j in Seg i holds R1.j <= R2.j) implies Sum R1 <= Sum R2;

theorem :: RVSUM_1:113
  (for j st j in Seg i holds R1.j <= R2.j) & (ex j st j in Seg i
  & R1.j < R2.j) implies Sum R1 < Sum R2;

theorem :: RVSUM_1:114
  (for i st i in dom F holds 0 <= F.i) implies 0 <= Sum F;

theorem :: RVSUM_1:115
  (for i st i in dom F holds 0 <= F.i) & (ex i st i in dom F & 0
  < F.i) implies 0 < Sum F;

theorem :: RVSUM_1:116
  0 <= Sum sqr F;

theorem :: RVSUM_1:117
  Sum(r*F) = r*(Sum F);

theorem :: RVSUM_1:118
  Sum -F = -(Sum F);

theorem :: RVSUM_1:119
  Sum(R1 + R2) = Sum R1 + Sum R2;

theorem :: RVSUM_1:120
  Sum(R1 - R2) = Sum R1 - Sum R2;

theorem :: RVSUM_1:121
  Sum sqr R = 0 implies R = i |-> 0;

theorem :: RVSUM_1:122
  (Sum mlt(R1,R2))^2 <= (Sum sqr R1)*(Sum sqr R2);

:: The Product of Finite Sequences of Real Numbers

definition
  let F be complex-valued FinSequence;
  func Product F -> complex number means
:: RVSUM_1:def 14

  ex f being FinSequence of COMPLEX st f = F & it = multcomplex $$ f;
end;

registration
  let F be real-valued FinSequence;
  cluster Product F -> real;
end;

theorem :: RVSUM_1:123
  for F being FinSequence of REAL holds Product F = multreal $$ F;

definition
  let F be FinSequence of COMPLEX;
  redefine func Product F -> Element of COMPLEX equals
:: RVSUM_1:def 15
  multcomplex $$ F;
end;

definition
  let F be FinSequence of REAL;
  redefine func Product F -> Element of REAL equals
:: RVSUM_1:def 16
  multreal $$ F;
end;

theorem :: RVSUM_1:124
  Product <*>REAL = 1;

registration
  let r be complex number;
  cluster <*r*> -> complex-valued;
end;

registration
  let r1, r2 be complex number;
  cluster <*r1, r2*> -> complex-valued;
end;

registration
  let r1, r2, r3 be complex number;
  cluster <*r1, r2, r3*> -> complex-valued;
end;

theorem :: RVSUM_1:125
  for r being complex number holds Product <*r*> = r;

registration
  let f, g be complex-valued FinSequence;
  cluster f ^ g -> complex-valued;
end;

theorem :: RVSUM_1:126
  for F being complex-valued FinSequence, r being complex
  number holds Product (F^<*r*>) = Product F * r;

theorem :: RVSUM_1:127
  for F1, F2 being complex-valued FinSequence holds
  Product (F1^F2) = Product F1 * Product F2;

theorem :: RVSUM_1:128
  Product (<*r*>^F) = r * Product F;

theorem :: RVSUM_1:129
  for r1, r2 being complex number holds Product <*r1,r2*> = r1 * r2;

theorem :: RVSUM_1:130
  for r1, r2, r3 being complex number holds Product <*r1,r2,r3*> = r1 * r2 * r3
;

theorem :: RVSUM_1:131
  for R being Element of 0-tuples_on REAL holds Product R = 1;

theorem :: RVSUM_1:132
  Product (i|->1) = 1;

theorem :: RVSUM_1:133
  for F being complex-valued FinSequence holds
  (ex k st k in dom F & F.k = 0) iff Product F = 0;

theorem :: RVSUM_1:134
  Product ((i+j) |->r ) = (Product (i|->r))*(Product (j|->r));

theorem :: RVSUM_1:135
  Product ((i*j) |->r) = Product (j |-> (Product (i|->r)));

theorem :: RVSUM_1:136
  Product (i|->(r1*r2)) = (Product (i|->r1))*(Product (i|->r2));

theorem :: RVSUM_1:137
  Product mlt(R1,R2) = Product R1 * Product R2;

theorem :: RVSUM_1:138
  Product (r*R) = Product (i|->r) * Product R;

theorem :: RVSUM_1:139
  Product sqr R = (Product R)^2;

begin :: Addenda
:: 2006.07.13, A.T.

reserve z,z1,z2 for Element of COMPLEX;

theorem :: RVSUM_1:140
  for F being FinSequence of COMPLEX holds Product F = multcomplex $$ F;

theorem :: RVSUM_1:141
  Product ((i+j) |->z) = (Product (i|->z))*(Product (j|->z));

theorem :: RVSUM_1:142
  Product ((i*j) |->z) = Product (j |-> (Product (i|->z)));

theorem :: RVSUM_1:143
  Product (i|->(z1*z2)) = (Product (i|->z1))*(Product (i|->z2));

begin :: from EUCLID_2 (partially modified), 2009.09.12, A.T.

reserve  n for Nat,
  x, y, a for real number,
   p, p1, p2, p3, q, q1, q2 for Element of n-tuples_on REAL;

theorem :: RVSUM_1:144
  for x being real-valued FinSequence holds len (-x)=len x;

theorem :: RVSUM_1:145
  for x1,x2 being real-valued FinSequence st len x1=len x2 holds
  len (x1+x2)=len x1;

theorem :: RVSUM_1:146
  for x1,x2 being real-valued FinSequence st len x1=len x2 holds
  len (x1-x2)=len x1;

theorem :: RVSUM_1:147
  for a being real number, x being real-valued FinSequence
   holds len (a*x)=len x;

theorem :: RVSUM_1:148
  for x,y,z being real-valued FinSequence st len x=len y & len y=len z
  holds mlt(x+y,z) = mlt(x,z)+mlt(y,z);

begin :: Inner Product of Finite Sequences

definition
  let x1,x2 be real-valued FinSequence;
  func |( x1,x2 )| -> real number equals
:: RVSUM_1:def 17
  Sum mlt(x1,x2);
  commutativity;
end;

definition
  let x1,x2 be real-valued FinSequence;
  redefine func |( x1,x2 )| -> Element of REAL;
  commutativity;
end;

theorem :: RVSUM_1:149
  for x being real-valued FinSequence holds |(x,x)| >= 0;

theorem :: RVSUM_1:150
  for x,y,z being real-valued FinSequence st len x=len y & len y=len z
  holds |((x+y),z)| = |(x,z)| + |(y,z)|;

theorem :: RVSUM_1:151
  for x,y being real-valued FinSequence,a being real number st len x=
  len y holds |(a*x,y)| = a*|(x,y)|;

theorem :: RVSUM_1:152
  for x1,x2 being real-valued FinSequence st len x1=len x2 holds
  |(-x1, x2)| = -|(x1, x2)|;

theorem :: RVSUM_1:153
  for x1,x2 being real-valued FinSequence st len x1=len x2 holds
  |(-x1, -x2)| = |(x1, x2)|;

theorem :: RVSUM_1:154
  for x1,x2,x3 being real-valued FinSequence st len x1=len x2 & len x2
  =len x3 holds |(x1-x2, x3)| = |(x1, x3)| - |(x2, x3)|;

theorem :: RVSUM_1:155
  for x,y being real number,x1,x2,x3 being real-valued FinSequence st len x1
  =len x2 & len x2=len x3 holds |((x*x1+y*x2), x3)| = x*|(x1,x3)| + y*|(x2,x3)|
;

theorem :: RVSUM_1:156
  for x1,x2,y1,y2 being real-valued FinSequence st len x1=len x2 & len
x2=len y1 & len y1=len y2 holds |(x1+x2, y1+y2)| = |(x1, y1)| + |(x1, y2)| + |(
  x2, y1)| + |(x2, y2)|;

theorem :: RVSUM_1:157
  for x1,x2,y1,y2 being real-valued FinSequence st len x1=len x2 & len
x2=len y1 & len y1=len y2 holds |(x1-x2, y1-y2)| = |(x1, y1)| - |(x1, y2)| - |(
  x2, y1)| + |(x2, y2)|;

theorem :: RVSUM_1:158
  for x,y being real-valued FinSequence st len x=len y holds |(x+y, x+
  y)| = |(x, x)| + 2*|(x, y)| + |(y, y)|;

theorem :: RVSUM_1:159
  for x,y being real-valued FinSequence st len x=len y holds |(x-y, x-
  y)| = |(x, x)| - 2*|(x, y)| + |(y, y)|;

theorem :: RVSUM_1:160
  |(p1 + p2, p3)| = |(p1, p3)| + |(p2, p3)|;

theorem :: RVSUM_1:161
  for x being real number holds |(x*p1, p2)| = x*|(p1, p2)|;

theorem :: RVSUM_1:162
  |(-p1, p2)| = -|(p1, p2)|;

theorem :: RVSUM_1:163
  |(-p1, -p2)| = |(p1, p2)|;

theorem :: RVSUM_1:164
  |(p1-p2, p3)| = |(p1, p3)| - |(p2, p3)|;

theorem :: RVSUM_1:165
  |((x*p1+y*p2), p3)| = x*|(p1,p3)| + y*|(p2,p3)|;

theorem :: RVSUM_1:166
  |(p1+p2, q1+q2)| = |(p1, q1)| + |(p1, q2)| + |(p2, q1)| + |(p2, q2)|;

theorem :: RVSUM_1:167
  |(p1-p2, q1-q2)| = |(p1, q1)| - |(p1, q2)| - |(p2, q1)| + |(p2, q2)|;

theorem :: RVSUM_1:168
  |(p+q, p+q)| = |(p, p)| + 2*|(p, q)| + |(q, q)|;

theorem :: RVSUM_1:169
  |(p-q, p-q)| = |(p, p)| - 2*|(p, q)| + |(q, q)|;

theorem :: RVSUM_1:170
  |(p,q)| <= |(p,p)| + |(q,q)|;

definition
  let p, q be real-valued FinSequence;
  pred p,q are_orthogonal means
:: RVSUM_1:def 18

  |(p,q)| = 0;
  symmetry;
end;

theorem :: RVSUM_1:171
  p, q are_orthogonal implies a*p,q are_orthogonal;

:: 2009.08.15, from TURING_0, A.T.

theorem :: RVSUM_1:172
  Sum<*r1,r2,r3,r4*> = r1 + r2 + r3 + r4;
