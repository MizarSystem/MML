:: Two Programs for {\bf SCM}. Part II - Proofs
::  by Grzegorz Bancerek and Piotr Rudnicki
::
:: Received October 8, 1993
:: Copyright (c) 1993 Association of Mizar Users

environ

 vocabularies NUMBERS, CARD_1, INT_1, POWER, SUBSET_1, XXREAL_0, RELAT_1,
      ARYTM_3, ARYTM_1, NAT_1, AMI_3, AFINSQ_1, AMI_1, ORDINAL4, GRAPHSP,
      SCM_1, FINSEQ_1, MSUALG_1, FUNCT_1, PRE_FF, CIRCUIT2, FSM_1, NEWTON,
      FIB_FUSC, SCMNORM;
 notations XCMPLX_0, SUBSET_1, NUMBERS, INT_1, NAT_1, NEWTON, POWER, CARD_3,
      ORDINAL4, FUNCT_1, AFINSQ_1, FINSEQ_1, AMI_1, SCM_1, AMI_3, PRE_FF,
      XXREAL_0;
 constructors XXREAL_0, REAL_1, NAT_1, NEWTON, POWER, PRE_FF, SCM_1, AFINSQ_1,
      ORDINAL4, FINSUB_1, SCMNORM, CARD_3;
 registrations SETFAM_1, NUMBERS, XREAL_0, INT_1, AMI_3, XBOOLE_0, ORDINAL1,
      AMI_1, AFINSQ_1, CARD_3, SCMNORM, FUNCT_1, RELSET_1;
 requirements REAL, NUMERALS, SUBSET, ARITHM, BOOLE;


begin

definition
  func Fib_Program -> XFinSequence of the Instructions of SCM equals
:: FIB_FUSC:def 1
  <% dl.1
>0_goto 2 %>^ <% halt SCM %>^ <% dl.3 := dl.0 %>^ <% SubFrom(dl.1, dl.0) %>^
<% dl.1 =0_goto 1 %>^ <% dl.4 := dl.2 %>^ <% dl.2 := dl.3 %>^ <% AddTo(dl.3,
  dl.4) %>^ <% SCM-goto 3 %>;
end;

theorem :: FIB_FUSC:1
  for N being Element of NAT, s being State-consisting of 0, 0, 0,
  Fib_Program, <*1*>^<*N*>^<*0*>^<*0*>
   holds ProgramPart (s qua PartState of SCM)
   halts_on s &
   (N = 0 implies
  LifeSpan s = 1) & (N > 0 implies LifeSpan s = 6 * N - 2) & (Result s).dl.3 =
  Fib N;

:: Fusc

definition
  let i be Integer;
  func Fusc' i -> Element of NAT means
:: FIB_FUSC:def 2

  (ex n being Element of NAT st i
  = n & it = Fusc n) or i is not Element of NAT & it = 0;
end;

definition
  func Fusc_Program -> XFinSequence of the Instructions of SCM equals
:: FIB_FUSC:def 3
  <% dl.1
=0_goto 8 %>^ <% dl.4 := dl.0 %>^ <% Divide(dl.1, dl.4) %>^ <% dl.4 =0_goto
6 %>^ <% AddTo(dl.3, dl.2) %>^ <% SCM-goto 0 %>^ <% AddTo(dl.2, dl.3) %>
^ <% SCM-goto 0 %>^ <% halt SCM %>;
end;

theorem :: FIB_FUSC:2
  for N being Element of NAT st N > 0 for s being State-consisting of 0,
0, 0, Fusc_Program, <*2*>^<*N*>^<*1*>^<*0*> holds ProgramPart s halts_on s &
 (Result s).dl.
  3 = Fusc N & LifeSpan s = 6 * ([\ log(2, N) /] + 1) + 1;

theorem :: FIB_FUSC:3
  for N being Element of NAT, k, Fk, Fk1 being Element of NAT, s being
State-consisting of 3, 0, 0, Fib_Program, <* 1 *>^<* N *>^<* Fk *>^<* Fk1 *> st
N > 0 & Fk = Fib k & Fk1 = Fib (k+1) holds ProgramPart s halts_on s &
 LifeSpan s = 6 * N -
4 & ex m being Element of NAT st m = k+N-1 & (Result s).dl.2 = Fib m & (Result
  s).dl.3 = Fib (m+1);

canceled;

theorem :: FIB_FUSC:5
  for n being Element of NAT, N, A, B being Element of NAT, s being
  State-consisting of 0, 0, 0, Fusc_Program, <*2*>^<*n*>^<*A*>^<*B*> st N > 0 &
  Fusc N = A * Fusc n + B * Fusc (n+1) holds ProgramPart s halts_on s &
   (Result s).dl.3 =
  Fusc N & (n = 0 implies LifeSpan s = 1) & (n > 0 implies LifeSpan s = 6 * ([\
  log(2, n) /] + 1) + 1);

theorem :: FIB_FUSC:6
  for N being Element of NAT st N > 0 for s being State-consisting of 0,
0, 0, Fusc_Program, <*2*>^<*N*>^<*1*>^<*0*> holds ProgramPart s halts_on s &
 (Result s).dl.
3 = Fusc N & (N = 0 implies LifeSpan s = 1) & (N > 0 implies LifeSpan s = 6 * (
  [\ log(2, N) /] + 1)+1);

