:: Composition of Machines, Instructions and Programs
::  by Andrzej Trybulec
::
:: Received May 20, 2010
:: Copyright (c) 2010-2011 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies SUBSET_1, XBOOLE_0, FUNCT_1, NUMBERS, CARD_3, ORDINAL1, CARD_1,
      FUNCOP_1, FUNCT_4, RELAT_1, TARSKI, CAT_1, FINSET_1, NAT_1, AFINSQ_1,
      AMISTD_1, AMISTD_2, ARYTM_1, VALUED_1, PARTFUN1, ZFMISC_1, AMI_1,
      ARYTM_3, SCMNORM, PBOOLE, RECDEF_2, COMPOS_1, FINSEQ_1, UNIALG_1, CARD_5,
      RELOC, TURING_1, XXREAL_0, VALUED_0, SCMFSA_7, INT_1, SCMPDS_4, ORDINAL4,
      SCMFSA6A, SCMPDS_5;
 notations TARSKI, XBOOLE_0, ZFMISC_1, MCART_1, SUBSET_1, SETFAM_1, ORDINAL1,
      PBOOLE, FUNCT_7, CARD_1, CARD_3, XXREAL_0, XCMPLX_0, RELAT_1, FUNCT_1,
      PARTFUN1, FINSET_1, NUMBERS, INT_1, NAT_1, NAT_D, FUNCOP_1, FUNCT_4,
      FINSEQ_1, FUNCT_2, DOMAIN_1, VALUED_0, VALUED_1, RECDEF_2, AFINSQ_1,
      STRUCT_0, MEMSTR_0;
 constructors SETFAM_1, DOMAIN_1, FUNCT_4, XXREAL_0, RELSET_1, FUNCT_7,
      PRE_POLY, PBOOLE, RECDEF_2, AFINSQ_1, NAT_D, WELLORD2, STRUCT_0,
      MEMSTR_0;
 registrations XBOOLE_0, SETFAM_1, RELAT_1, FUNCT_1, ORDINAL1, FUNCT_2,
      FUNCOP_1, FUNCT_4, FINSET_1, XREAL_0, FINSEQ_1, CARD_3, STRUCT_0, INT_1,
      RELSET_1, GRFUNC_1, PRE_POLY, PBOOLE, AFINSQ_1, VALUED_1, XCMPLX_0,
      MEMSTR_0, PARTFUN1, NUMBERS, NAT_1, MEMBERED, FUNCT_7, CARD_1, XXREAL_2,
      ZFMISC_1, SUBSET_1, VALUED_0, XXREAL_0, ORDINAL4, ORDINAL5;
 requirements NUMERALS, BOOLE, SUBSET, ARITHM, REAL;


begin :: General concepts

reserve x,A for set,
  i,j,k,m,n, l, l1, l2 for Nat;
reserve D for non empty set,
  z for natural number;

definition
  struct COM-Struct(#
    Instructions -> non empty set,
    haltF -> Element of the Instructions
     #);
end;

definition
  func Trivial-COM -> strict COM-Struct means
:: COMPOS_1:def 1

  the Instructions of it = {[0,{},{}]} &
  the haltF of it = [0,{},{}];
end;

definition
  let S be COM-Struct;
  mode Instruction of S is Element of the Instructions of S;
end;

definition
  let S be COM-Struct;
  func halt S -> Instruction of S equals
:: COMPOS_1:def 2
   the haltF of S;
end;

definition

  let S be COM-Struct;
  let I be (the Instructions of S)-valued Function;
  attr I is halt-free means
:: COMPOS_1:def 3
  not halt S in rng I;
end;

begin :: General theory

reserve S for COM-Struct;
reserve ins for Element of the Instructions of S;

definition
 let S be COM-Struct;
 mode Instruction-Sequence of S is
    (the Instructions of S)-valued ManySortedSet of NAT;
end;

definition
 let S be COM-Struct;
 let P be Instruction-Sequence of S, k be Nat;
 redefine func P.k -> Instruction of S;
end;

begin :: InsType & InsCode

notation
  let x;
  synonym InsCode x for x`1_3;
  synonym JumpPart x for x`2_3;
  synonym AddressPart x for x`3_3;
end;

definition

  let  S be COM-Struct;
  attr S is standard-ins means
:: COMPOS_1:def 4

   ex X being non empty set
    st the Instructions of S c= [: NAT,NAT*,X*:];
end;

registration
  cluster Trivial-COM -> standard-ins;
end;

registration
  cluster standard-ins strict for COM-Struct;
end;

registration
  let S be standard-ins COM-Struct;
  cluster the Instructions of S -> Relation-like;
end;

registration
 let S be standard-ins COM-Struct;
 let x be Instruction of S;
 cluster InsCode x -> natural;
end;

definition
  let  S be standard-ins COM-Struct;
  func InsCodes S equals
:: COMPOS_1:def 5
  proj1 proj1 the Instructions of S;
end;

registration
  let  S be standard-ins COM-Struct;
  cluster InsCodes S ->non empty;
end;

definition
  let  S be standard-ins COM-Struct;
  mode InsType of S is Element of InsCodes S;
end;

definition
  let  S be standard-ins COM-Struct;
  let I be Element of the Instructions of S;
  redefine func InsCode I -> InsType of S;
end;

begin

theorem :: COMPOS_1:1
 for  S be standard-ins COM-Struct
 for I,J being Instruction of S
  st InsCode I = InsCode J & JumpPart I = JumpPart J &
   AddressPart I = AddressPart J
 holds I = J;

definition

  let S be (COM-Struct);
  let p be NAT-defined (the Instructions of S)-valued Function, l be set;
  pred p halts_at l means
:: COMPOS_1:def 6
 l in dom p & p.l = halt S;
end;

definition

  let S be COM-Struct;
  let s be Instruction-Sequence of S, l be Nat;
  redefine pred s halts_at l means
:: COMPOS_1:def 7
  s.l = halt S;
end;

begin :: Closedness of finite partial states

notation
  let S be COM-Struct;
  let i be Instruction of S;
  synonym Load i for <%i%>;
end;

registration
  let S;
  cluster initial 1-element NAT-defined
    (the Instructions of S)-valued for Function;
end;

definition
  let S be COM-Struct;
  mode preProgram of S is finite
   NAT-defined (the Instructions of S)-valued Function;
end;

definition
  let S be COM-Struct,
  F be non empty preProgram of S;
  attr F is halt-ending means
:: COMPOS_1:def 8

  F.(LastLoc F) = halt S;
  attr F is unique-halt means
:: COMPOS_1:def 9

  for f being Nat st
  F.f = halt S & f in dom F holds f = LastLoc F;
end;

registration let S;
  cluster halt-ending unique-halt trivial
   for initial non empty preProgram of S;
end;

registration
  let S be COM-Struct;
  cluster trivial initial non empty for preProgram of S;
end;

registration
  let S be COM-Struct;
  cluster halt-ending unique-halt trivial
    for initial non empty NAT-defined
    (the Instructions of S)-valued finite Function;
end;

definition
  let S be  COM-Struct;
  mode Program of S is initial non empty preProgram of S;
end;

definition let S;
  mode pre-Macro of S is halt-ending unique-halt Program of S;
end;

theorem :: COMPOS_1:2
  for ins being Element of the Instructions of Trivial-COM holds
  InsCode ins = 0;

begin :: Addenda

reserve i, j, k for natural number;

definition
  let S be  COM-Struct;
  func Stop S -> finite preProgram of S equals
:: COMPOS_1:def 10
   Load halt S;
end;

registration
  let S be  COM-Struct;
  cluster Stop S -> initial non empty;
end;

registration
  let S be  COM-Struct;
  cluster initial non empty for preProgram of S;
end;

theorem :: COMPOS_1:3
  0 in dom Stop S;

theorem :: COMPOS_1:4
  card Stop S = 1;

reserve k, m for natural number,
  x, x1, x2, x3, y, y1, y2, y3, X,Y,Z for set;

begin  :: Properties of AMI-Struct

definition

  let S be standard-ins COM-Struct;
  let T be InsType of S;
  func JumpParts T equals
:: COMPOS_1:def 11
  { JumpPart I where I is Instruction of S: InsCode I = T };
end;

registration
  let S be standard-ins COM-Struct;
  let I be Element of the Instructions of S;
  cluster AddressPart I -> Function-like Relation-like;
  cluster JumpPart I -> Function-like Relation-like;
end;

registration
  let S be standard-ins COM-Struct;
  let I be Element of the Instructions of S;
  cluster AddressPart I -> FinSequence-like;
  cluster JumpPart I -> FinSequence-like;
end;

definition
  let S be standard-ins COM-Struct;
  attr S is homogeneous means
:: COMPOS_1:def 12

  for I, J being Instruction of S st InsCode I = InsCode J holds
  dom JumpPart I = dom JumpPart J;
end;

theorem :: COMPOS_1:5
  for I being Instruction of Trivial-COM holds JumpPart I = 0;

definition
  let S be standard-ins COM-Struct;
  let T be InsType of S;
  func AddressParts T equals
:: COMPOS_1:def 13
  { AddressPart I where I is Instruction of S: InsCode I = T };
end;

registration
  let S be standard-ins COM-Struct;
  let T be InsType of S;
  cluster AddressParts T -> functional;
  cluster JumpParts T -> non empty functional;
end;

definition
  let S be standard-ins COM-Struct;
  attr S is regular means
:: COMPOS_1:def 14

  for I being Instruction of S, k being set st k in dom JumpPart I
   holds (product" JumpParts InsCode I).k = NAT;
  attr S is J/A-independent means
:: COMPOS_1:def 15
 for T being InsType of S, f1,f2 being Function,
     p being set
    st f1 in JumpParts T & f2 in product product" JumpParts T &
    [T,f1,p] in the Instructions of S
    holds [T,f2,p] in the Instructions of S;
end;

theorem :: COMPOS_1:6
  for T being InsType of Trivial-COM holds JumpParts T = {0};

registration
  cluster Trivial-COM -> homogeneous regular J/A-independent;
end;

registration
  cluster regular J/A-independent homogeneous
        for standard-ins strict COM-Struct;
end;

registration
 let S be regular homogeneous standard-ins COM-Struct;
 let T being InsType of S;
 cluster JumpParts T ->  with_common_domain;
end;

registration
 let S be regular homogeneous standard-ins COM-Struct;
 let I be Instruction of S;
 cluster JumpPart I -> NAT-valued for Function;
end;

registration
  let S be regular J/A-independent homogeneous standard-ins COM-Struct;
  let T be InsType of S;
  cluster JumpParts T -> product-like;
end;

registration
  cluster Trivial-COM -> regular J/A-independent;
end;

registration
  let S be homogeneous standard-ins COM-Struct;
  let T be InsType of S;
  cluster JumpParts T -> with_common_domain;
end;

theorem :: COMPOS_1:7
  for S being homogeneous regular standard-ins COM-Struct,
  I being Instruction of S, x being set st x in dom JumpPart I holds
  (JumpPart I).x is Element of NAT;

registration
  let S be COM-Struct;
  cluster trivial -> unique-halt for non empty finite preProgram of S;
end;

definition
  let S be standard-ins COM-Struct;
  let I be Instruction of S;
  attr I is ins-loc-free means
:: COMPOS_1:def 16
 JumpPart I is empty;
end;

registration
  let S be COM-Struct;
  cluster Stop S ->
   initial non empty NAT-defined (the Instructions of S)-valued trivial;
end;

theorem :: COMPOS_1:8
  for F being pre-Macro of S st card F = 1 holds F = Stop S;

theorem :: COMPOS_1:9
 for S being COM-Struct holds LastLoc Stop S = 0;

registration
  let S be COM-Struct;
  cluster Stop S -> halt-ending unique-halt;
end;

begin  :: On the composition of macro instructions

registration
  let S be regular J/A-independent homogeneous standard-ins COM-Struct;
  let I be Element of the Instructions of S;
 cluster JumpPart I -> natural-valued for Function;
end;

definition
  let S be regular J/A-independent homogeneous standard-ins COM-Struct;
  let I be Element of the Instructions of S;
  let k be natural number;
  func IncAddr(I,k) -> Instruction of S means
:: COMPOS_1:def 17

  InsCode it = InsCode I &
  AddressPart it = AddressPart I &
  JumpPart it = k + JumpPart I;
end;

theorem :: COMPOS_1:10
  for S being regular homogeneous J/A-independent standard-ins COM-Struct,
  I being Element of the Instructions of S holds IncAddr(I, 0) = I;

theorem :: COMPOS_1:11
  for S being regular homogeneous J/A-independent standard-ins COM-Struct,
  I being Instruction of S st I is ins-loc-free holds IncAddr(I, k) = I;

definition
  let S be standard-ins COM-Struct;
  attr S is proper-halt means
:: COMPOS_1:def 18
  halt S is ins-loc-free;
end;

registration
  cluster Trivial-COM -> proper-halt;
end;

registration
 cluster proper-halt regular homogeneous J/A-independent
  for standard-ins COM-Struct;
end;

registration
  let S be proper-halt standard-ins COM-Struct;
 cluster halt S -> ins-loc-free;
end;

registration
  let S be proper-halt standard-ins COM-Struct;
 cluster ins-loc-free for Instruction of S;
end;

registration
  let S be proper-halt standard-ins COM-Struct;
  let I be ins-loc-free Instruction of S;
  cluster JumpPart I -> empty;
end;



theorem :: COMPOS_1:12
  for S being regular homogeneous J/A-independent standard-ins COM-Struct,
      I being Instruction of S
  holds JumpParts InsCode I = JumpParts InsCode IncAddr(I,k);

theorem :: COMPOS_1:13
  for S being regular homogeneous J/A-independent standard-ins COM-Struct,
  I, J being Instruction of S st
  ex k being natural number st IncAddr(I,k) = IncAddr(J,k) holds I = J;

theorem :: COMPOS_1:14
  for S being regular homogeneous J/A-independent proper-halt
   standard-ins COM-Struct,
  I being Instruction of S st IncAddr(I,k) = halt S holds I = halt S;

theorem :: COMPOS_1:15
  for S being regular homogeneous J/A-independent
   standard-ins COM-Struct, I being Instruction of S
  holds IncAddr(IncAddr(I,k),m) = IncAddr(I,k+m);

definition
  let S be regular homogeneous J/A-independent standard-ins COM-Struct,
  p be NAT-defined (the Instructions of S)-valued finite Function,
  k be natural number;
  func IncAddr(p,k) ->
   NAT-defined (the Instructions of S)-valued finite Function
  means
:: COMPOS_1:def 19

  dom it = dom p &
  for m being natural number st m in dom p holds it.m = IncAddr(p/.m,k);
end;

registration
  let S be regular homogeneous J/A-independent standard-ins COM-Struct,
  F be NAT-defined (the Instructions of S)-valued finite Function,
  k be natural number;
  cluster IncAddr(F,k) -> NAT-defined (the Instructions of S)-valued;
end;

registration
  let S be regular homogeneous J/A-independent standard-ins COM-Struct,
  F be empty (the Instructions of S)-valued NAT-defined finite Function,
  k be natural number;
  cluster IncAddr(F,k) -> empty;
end;

registration
  let S be regular homogeneous J/A-independent standard-ins COM-Struct,
  F be non empty (the Instructions of S)-valued NAT-defined finite Function,
  k be natural number;
  cluster IncAddr(F,k) -> non empty;
end;

registration
  let S be regular homogeneous J/A-independent standard-ins COM-Struct,
  F be initial NAT-defined (the Instructions of S)-valued finite Function,
  k be natural number;
  cluster IncAddr(F,k) -> initial;
end;

theorem :: COMPOS_1:16
  for S being regular homogeneous J/A-independent standard-ins COM-Struct,
  F being NAT-defined (the Instructions of S)-valued finite Function
   holds IncAddr(F,0) = F;

theorem :: COMPOS_1:17
  for S being regular homogeneous J/A-independent standard-ins COM-Struct,
  F being NAT-defined (the Instructions of S)-valued finite Function
  holds IncAddr(IncAddr(F,k),m) = IncAddr(F,k+m);

definition
  let S be regular homogeneous J/A-independent standard-ins COM-Struct;
  let p be finite NAT-defined (the Instructions of S)-valued Function,
     k be Nat;
 func Reloc(p,k) ->
   finite NAT-defined (the Instructions of S)-valued Function
   equals
:: COMPOS_1:def 20
IncAddr(Shift(p,k),k);
end;

theorem :: COMPOS_1:18
  for S being regular  homogeneous J/A-independent standard-ins COM-Struct,
  F being initial non empty finite preProgram of S,
  G being non empty
   NAT-defined (the Instructions of S)-valued finite Function
  holds dom CutLastLoc F misses dom Shift(IncAddr(G,card F -' 1),card F -' 1);

theorem :: COMPOS_1:19
  for F being unique-halt initial non empty finite preProgram of S,
  I being Nat st I in dom CutLastLoc F
  holds (CutLastLoc F).I <> halt S;

definition
  let S be regular homogeneous J/A-independent standard-ins COM-Struct;
  let F, G be non empty finite preProgram of S;
  func F ';' G -> finite preProgram of S equals
:: COMPOS_1:def 21
  CutLastLoc F +* Shift(IncAddr(G,card F -' 1),card F -' 1);
end;

registration
  let S be regular  homogeneous J/A-independent standard-ins COM-Struct,
  F, G be non empty
  (the Instructions of S)-valued NAT-defined finite Function;
  cluster F ';' G -> non empty
  (the Instructions of S)-valued NAT-defined;
end;

theorem :: COMPOS_1:20
  for S being regular  homogeneous J/A-independent standard-ins COM-Struct,
  F being initial non empty finite preProgram of S,
  G being non empty
  (the Instructions of S)-valued NAT-defined finite Function
  holds card (F ';' G) = card F + card G - 1 &
  card (F ';' G) = card F + card G -' 1;

registration
  let S be regular  homogeneous J/A-independent standard-ins COM-Struct;
  let F, G be initial non empty finite preProgram of S;
  cluster F ';' G -> initial;
end;

theorem :: COMPOS_1:21
  for S being regular  homogeneous J/A-independent standard-ins COM-Struct,
  F, G being initial non empty finite preProgram of S
  holds dom F c= dom (F ';' G);

registration
 let S being regular  homogeneous J/A-independent standard-ins COM-Struct,
  F, G being initial non empty finite preProgram of S;
 cluster F ';' G -> initial non empty;
end;

theorem :: COMPOS_1:22
  for S being regular  homogeneous J/A-independent standard-ins COM-Struct,
  F, G being initial non empty finite preProgram of S
  holds CutLastLoc F c= CutLastLoc (F ';' G);

theorem :: COMPOS_1:23
  for S being regular  homogeneous J/A-independent standard-ins COM-Struct,
  F, G being initial non empty finite preProgram of S
  holds (F ';' G).LastLoc F = IncAddr(G,card F -' 1).0;

theorem :: COMPOS_1:24
  for S being regular  homogeneous J/A-independent standard-ins COM-Struct,
  F, G being initial non empty finite preProgram of S,
  f being Nat st f < card F - 1
  holds IncAddr(F,card F -' 1).f = IncAddr(F ';' G, card F -' 1).f;

registration
  let S be regular  homogeneous J/A-independent  proper-halt
      standard-ins COM-Struct;
  let F be initial non empty NAT-defined
  (the Instructions of S)-valued finite Function;
  let G be halt-ending initial non empty NAT-defined
  (the Instructions of S)-valued finite Function;
  cluster F ';' G -> halt-ending;
end;

registration
  let S be regular  homogeneous J/A-independent  proper-halt
   standard-ins COM-Struct;
  let F, G be halt-ending unique-halt
  initial non empty NAT-defined
  (the Instructions of S)-valued finite Function;
  cluster F ';' G -> unique-halt;
end;

definition

  let S be regular homogeneous J/A-independent  proper-halt
   standard-ins
  COM-Struct;
  let F, G be pre-Macro of S;
  redefine func F ';' G -> pre-Macro of S;
end;

theorem :: COMPOS_1:25
  for S being regular homogeneous J/A-independent proper-halt
   standard-ins COM-Struct
  holds IncAddr(Stop S, k) = Stop S;

theorem :: COMPOS_1:26
  for k being Nat
  for S being COM-Struct
  holds Shift(Stop S, k) = k .--> halt S;

theorem :: COMPOS_1:27
  for S being regular homogeneous J/A-independent proper-halt
                standard-ins COM-Struct,
      F being pre-Macro of S
  holds F ';' Stop S = F;

theorem :: COMPOS_1:28
  for S being regular homogeneous J/A-independent standard-ins COM-Struct,
      F being pre-Macro of S
  holds Stop S ';' F = F;

theorem :: COMPOS_1:29
  for S being regular homogeneous J/A-independent proper-halt
   standard-ins COM-Struct,
  F, G, H being pre-Macro of S holds F ';' G ';' H = F ';' (G ';' H);

theorem :: COMPOS_1:30
  for S being regular homogeneous standard-ins COM-Struct,
  I being Instruction of S, x being set st x in dom JumpPart I holds
  (JumpPart I).x in (product" JumpParts InsCode I).x;

theorem :: COMPOS_1:31
  for I being Instruction of Trivial-COM holds JumpPart I = 0;

theorem :: COMPOS_1:32
  for T being InsType of Trivial-COM holds JumpParts T = {0};

begin :: Addenda

:: from SCMRING4, 2008.03.13, A.T.

reserve i, j, k for natural number,
  n for Nat,
  l,il for Nat;

reserve S for regular homogeneous J/A-independent standard-ins COM-Struct;



theorem :: COMPOS_1:33
  for k being Nat holds
  for p being finite NAT-defined (the Instructions of S)-valued Function
   holds dom Reloc(p,k) = { j+k where j is Element of NAT:j in dom p };



theorem :: COMPOS_1:34
  for i,j being Nat holds
  for p being NAT-defined (the Instructions of S)-valued finite Function
  holds Shift(IncAddr(p,i),j) = IncAddr(Shift(p,j),i);

theorem :: COMPOS_1:35
  for g being NAT-defined (the Instructions of S)-valued finite Function
  for k being Nat holds
  for I being Instruction of S holds
  il in dom g & I = g.il implies
  IncAddr(I, k) = Reloc(g, k).(il + k);

begin :: SCMPDS_4

reserve S for COM-Struct;

reserve
  i,j,k for Instruction of S,
  I,J,K for Program of S;

definition
  let S be COM-Struct;
  let i be Instruction of S;
  redefine func Load i -> preProgram of S;
end;

reserve k1,k2 for Integer;

reserve l,l1,loc for Nat;

definition
  let S be COM-Struct;
  let I be initial preProgram of S;
  func stop I -> preProgram of S equals
:: COMPOS_1:def 22
  I ^ Stop S;
end;

registration let S be COM-Struct;
 let I be initial preProgram of S;
 cluster stop I -> initial non empty;
end;

reserve i1,i2 for Instruction of S;

theorem :: COMPOS_1:36
   0 in dom stop  I;

begin :: SCMFSA6A

reserve
  i,j,k for Instruction of S,
  I,J,K for Program of S;

definition
  let S be COM-Struct;
  let i be Instruction of S;
  func Macro i -> preProgram of S equals
:: COMPOS_1:def 23
   stop Load i;
end;

registration let S;
  let i;
  cluster Macro i -> initial non empty;
end;

begin :: SCMFSA7B

reserve m for Nat;

registration
  let S be  COM-Struct;
  cluster Stop S -> non halt-free;
end;

registration
  let S be COM-Struct;
  cluster non halt-free finite for Program of S;
end;

registration
  let S be  COM-Struct;
  let p be NAT-defined (the Instructions of S)-valued Function,
      q be non halt-free
       NAT-defined (the Instructions of S)-valued Function;
  cluster p +* q -> non halt-free;
end;

registration
  let S be regular homogeneous J/A-independent proper-halt
    standard-ins COM-Struct;
  let p be finite non halt-free
    NAT-defined (the Instructions of S)-valued Function,
     k be Nat;
 cluster Reloc(p,k) -> non halt-free;
end;

registration
  let S be  COM-Struct;
  cluster non halt-free non empty for Program of S;
end;

canceled 4;

theorem :: COMPOS_1:41
 for S being regular homogeneous J/A-independent standard-ins COM-Struct
  for p,q being
   finite NAT-defined (the Instructions of S)-valued Function
    holds IncAddr(p +* q, n) = IncAddr(p,n) +* IncAddr(q,n);

theorem :: COMPOS_1:42
 for S being regular homogeneous J/A-independent standard-ins COM-Struct
 for p,q being finite NAT-defined (the Instructions of S)-valued Function,
     k be Nat
  holds Reloc(p+*q,k) = Reloc(p,k)+*Reloc(q,k);

theorem :: COMPOS_1:43
 for S being regular homogeneous J/A-independent standard-ins COM-Struct
 for p being finite NAT-defined (the Instructions of S)-valued Function,
     m,n be Nat
 holds Reloc(Reloc(p,m), n) = Reloc(p, m + n);

theorem :: COMPOS_1:44
 for S being regular homogeneous J/A-independent standard-ins COM-Struct
  for P,Q being NAT-defined (the Instructions of S)-valued finite Function,
   k being Nat st
  P c= Q holds Reloc(P,k) c= Reloc(Q,k);

theorem :: COMPOS_1:45
 for S being regular homogeneous J/A-independent standard-ins COM-Struct
  for P being preProgram of S holds Reloc(P,0) = P;

theorem :: COMPOS_1:46
 for S being regular homogeneous J/A-independent
   standard-ins COM-Struct
  for k being Nat holds
    for P being preProgram of S holds
    il in dom P iff il + k in dom Reloc(P,k);



theorem :: COMPOS_1:47
  for S be regular J/A-independent homogeneous proper-halt
   standard-ins COM-Struct
  for i being Instruction of S
  for f being Function of the Instructions of S, the Instructions of S
   st f = (id the Instructions of S) +* (halt S .--> i)
  for s being finite NAT-defined (the Instructions of S)-valued Function
  holds IncAddr(f*s,n)
   = ((id the Instructions of S) +* (halt S .--> IncAddr(i,n)))* IncAddr(s,n);

reserve S for regular J/A-independent homogeneous standard-ins COM-Struct;
reserve I,J for Program of S;

theorem :: COMPOS_1:48
  dom I misses dom Reloc(J, card I);

theorem :: COMPOS_1:49
 for I being preProgram of S holds card Reloc(I, m) = card I;

:: from SCMPDS_5, 2011.05.16, A.T.

reserve S for COM-Struct;

reserve i for Instruction of S,
        I for Program of S;

theorem :: COMPOS_1:50
  x in dom Load i iff x =  0;

reserve loc for Nat;

theorem :: COMPOS_1:51
  loc in dom stop I & (stop I).loc <> halt S implies loc in dom I;

theorem :: COMPOS_1:52
  dom Load i = { 0} & (Load i).0 = i;

theorem :: COMPOS_1:53
   0 in dom Load i;

theorem :: COMPOS_1:54
  card Load i = 1;

theorem :: COMPOS_1:55
  card stop I = card I + 1;

theorem :: COMPOS_1:56
  card Macro i = 2;

theorem :: COMPOS_1:57
   0 in dom Macro i &  1 in dom Macro i;

theorem :: COMPOS_1:58
  (Macro i).0 = i;

theorem :: COMPOS_1:59
  (Macro i).1 = halt S;

theorem :: COMPOS_1:60
  x in dom Macro i iff x= 0 or x= 1;

theorem :: COMPOS_1:61
  dom Macro i = {0,1};

theorem :: COMPOS_1:62
  loc in dom I implies loc in dom stop I;

theorem :: COMPOS_1:63
 for I being initial preProgram of S st loc in dom I
  holds (stop I).loc=I.loc;

theorem :: COMPOS_1:64
  card I in dom stop I & (stop I).card I = halt S;

:: from SCMPDS_7, 2011.05.27, A.T.

theorem :: COMPOS_1:65
  loc in dom I implies Shift(stop I,n).(loc+n)=Shift(I,n).(loc+n);

theorem :: COMPOS_1:66
  Shift(stop I,n). n=Shift(I,n). n;

:: from SCMPDS_5, 2011.05.27,A.T.

definition
  let S be COM-Struct;
  let i be Instruction of S;
  attr i is No-StopCode means
:: COMPOS_1:def 24
  i <> halt S;
end;

registration let S be COM-Struct;
 cluster empty for preProgram of S;
end;

registration let S be COM-Struct;
 cluster empty -> halt-free for preProgram of S;
end;

definition
  let S be COM-Struct;
  let IT be NAT-defined (the Instructions of S)-valued Function;
  redefine attr IT is halt-free means
:: COMPOS_1:def 25
 for x being Nat st x in dom IT holds IT.x <> halt S;
end;

registration let S be COM-Struct;
 cluster halt-free -> unique-halt for non empty preProgram of S;
end;

theorem :: COMPOS_1:67
 rng Macro i = {i, halt S};

theorem :: COMPOS_1:68
 for p being initial preProgram of S
  holds CutLastLoc stop p = p;

registration let S be COM-Struct;
 let p be halt-free initial preProgram of S;
 cluster stop p -> unique-halt;
end;
