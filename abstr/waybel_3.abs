:: The "Way-Below" Relation
::  by Grzegorz Bancerek
::
:: Received October 11, 1996
:: Copyright (c) 1996 Association of Mizar Users

environ

 vocabulary RELAT_2, ORDERS_1, QUANTAL1, ORDINAL2, COMPTS_1, LATTICE3,
      WAYBEL_0, YELLOW_0, LATTICES, BHSP_3, BOOLE, REALSET1, FINSET_1,
      FILTER_2, WAYBEL_2, FUNCT_1, RELAT_1, FUNCT_4, YELLOW_1, PBOOLE,
      FUNCOP_1, CARD_3, RLVECT_2, PRE_TOPC, SETFAM_1, TARSKI, WELLORD2,
      SUBSET_1, TOPS_1, PCOMPS_1, WAYBEL_3;
 notation TARSKI, XBOOLE_0, SUBSET_1, XREAL_0, NAT_1, RELAT_1, FINSET_1,
      DOMAIN_1, STRUCT_0, REALSET1, FUNCT_1, FUNCT_4, FUNCOP_1, PBOOLE, CARD_3,
      PRALG_1, FUNCT_7, GROUP_1, ORDERS_1, PRE_TOPC, TOPS_1, TOPS_2, COMPTS_1,
      PCOMPS_1, LATTICE3, YELLOW_0, YELLOW_1, WAYBEL_0, YELLOW_4, WAYBEL_2;
 constructors NAT_1, REALSET1, FUNCT_7, GROUP_1, DOMAIN_1, TOPS_1, TOPS_2,
      COMPTS_1, PCOMPS_1, YELLOW_4, WAYBEL_2, YELLOW_1, MEMBERED;
 clusters SUBSET_1, STRUCT_0, FUNCT_1, FINSET_1, ORDERS_1, LATTICE3, PCOMPS_1,
      CANTOR_1, YELLOW_0, WAYBEL_0, YELLOW_1, ARYTM_3, SETFAM_1, TOPS_1,
      MEMBERED, ZFMISC_1;
 requirements NUMERALS, BOOLE, SUBSET, ARITHM;


begin :: 1. The "Way-Below" Relation

definition  :: 1.1, p. 38
 let L be non empty reflexive RelStr;
 let x,y be Element of L;
 pred x is_way_below y means
:: WAYBEL_3:def 1

  for D being non empty directed Subset of L st y <= sup D
   ex d being Element of L st d in D & x <= d;
 end;
notation  :: 1.1, p. 38
 let L be non empty reflexive RelStr;
 let x,y be Element of L;
 synonym x << y for x is_way_below y ; synonym y >> x for x is_way_below y ;
end;


definition  :: 1.1, p. 38
 let L be non empty reflexive RelStr;
 let x be Element of L;
 attr x is compact means
:: WAYBEL_3:def 2

  x is_way_below x;
 end;
notation  :: 1.1, p. 38
 let L be non empty reflexive RelStr;
 let x be Element of L;
 synonym x is isolated_from_below for x is compact ; end;


theorem :: WAYBEL_3:1  :: 1.2(i), p. 39
 for L being non empty reflexive antisymmetric RelStr
 for x,y being Element of L st x << y holds x <= y;

theorem :: WAYBEL_3:2  :: 1.2(ii), p. 39
 for L being non empty reflexive transitive RelStr, u,x,y,z being Element of L
  st u <= x & x << y & y <= z holds u << z;

theorem :: WAYBEL_3:3  :: 1.2(iii), p. 39
 for L being non empty Poset st L is with_suprema or L is /\-complete
 for x,y,z being Element of L
  st x << z & y << z holds ex_sup_of {x,y}, L & x "\/" y << z;

theorem :: WAYBEL_3:4    :: 1.2(iv), p. 39
 for L being lower-bounded antisymmetric reflexive non empty RelStr
 for x being Element of L holds Bottom L << x;

theorem :: WAYBEL_3:5
   for L being non empty Poset, x,y,z being Element of L
  st x << y & y << z holds x << z;

theorem :: WAYBEL_3:6
   for L being non empty reflexive antisymmetric RelStr, x,y being Element of L
  st x << y & x >> y holds x = y;

definition  :: after 1.2, p. 39
 let L be non empty reflexive RelStr;
 let x be Element of L;
 func waybelow x -> Subset of L equals
:: WAYBEL_3:def 3

   {y where y is Element of L: y << x};
 func wayabove x -> Subset of L equals
:: WAYBEL_3:def 4

   {y where y is Element of L: y >> x};
end;


theorem :: WAYBEL_3:7
 for L being non empty reflexive RelStr, x,y being Element of L holds
  x in waybelow y iff x << y;

theorem :: WAYBEL_3:8
 for L being non empty reflexive RelStr, x,y being Element of L holds
  x in wayabove y iff x >> y;

theorem :: WAYBEL_3:9
 for L being non empty reflexive antisymmetric RelStr
 for x being Element of L holds x is_>=_than waybelow x;

theorem :: WAYBEL_3:10
   for L being non empty reflexive antisymmetric RelStr
 for x being Element of L holds x is_<=_than wayabove x;

theorem :: WAYBEL_3:11
 for L being non empty reflexive antisymmetric RelStr
 for x being Element of L holds
  waybelow x c= downarrow x & wayabove x c= uparrow x;

theorem :: WAYBEL_3:12
 for L being non empty reflexive transitive RelStr
 for x,y being Element of L st x <= y
  holds waybelow x c= waybelow y & wayabove y c= wayabove x;

registration
 let L be lower-bounded (non empty reflexive antisymmetric RelStr);
 let x be Element of L;
 cluster waybelow x -> non empty;
 coherence
  proof Bottom L << x by Th4;
   hence thesis by Th7;
  end;
end;


registration
 let L be non empty reflexive transitive RelStr;
 let x be Element of L;
 cluster waybelow x -> lower;
 coherence
  proof let z,y be Element of L; assume z in waybelow x;
    then z << x by Th7;
    then y <= z implies y << x by Th2;
   hence y <= z implies y in waybelow x by Th7;
  end;
 cluster wayabove x -> upper;
 coherence
  proof
   hereby let z,y be Element of L; assume z in wayabove x;
     then z >> x by Th8;
     then y >= z implies y >> x by Th2;
    hence y >= z implies y in wayabove x by Th8;
   end;
  end;
end;


registration
 let L be sup-Semilattice;
 let x be Element of L;
 cluster waybelow x -> directed;
 coherence
  proof let v,y be Element of L; assume v in waybelow x & y in waybelow x;
then A1:  v << x & y << x by Th7;
then A2:  ex_sup_of {v,y},L by Th3;
   take z = v"\/"y; z << x by A1,Th3;
   hence z in waybelow x by Th7;
   thus v <= z & y <= z by A2,YELLOW_0:18;
  end;
end;


registration
 let L be /\-complete (non empty Poset);
 let x be Element of L;
 cluster waybelow x -> directed;
 coherence
  proof let v,y be Element of L; assume v in waybelow x & y in waybelow x;
then A1:  v << x & y << x by Th7;
then A2:  ex_sup_of {v,y},L by Th3;
   take z = v"\/"y; z << x by A1,Th3;
   hence z in waybelow x by Th7;
   thus v <= z & y <= z by A2,YELLOW_0:18;
  end;
end;



:: EXAMPLES, 1.3, p. 39

registration
 let L be connected (non empty RelStr);
 cluster -> directed filtered Subset of L;
 coherence
  proof let X be Subset of L;
   thus X is directed
    proof let x,y be Element of L;
        x <= y & y <= y or x >= x & x >= y by WAYBEL_0:def 29;
     hence thesis;
    end;
   let x,y be Element of L;
      x >= y & y <= y or x >= x & x <= y by WAYBEL_0:def 29;
   hence thesis;
  end;
end;


registration
 cluster up-complete lower-bounded -> complete (non empty Chain);
 coherence
  proof let L be non empty Chain such that
A1:  L is up-complete lower-bounded;
      now let X be Subset of L;
        X = {} or X <> {};
     hence ex_sup_of X,L by A1,WAYBEL_0:75,YELLOW_0:42;
    end;
   hence thesis by YELLOW_0:53;
  end;
end;


registration
 cluster complete (non empty Chain);
 existence
  proof consider x being set, O being Order of {x};
      RelStr(#{x},O#) is trivial non empty RelStr;
   hence thesis;
  end;
end;


theorem :: WAYBEL_3:13
 for L being up-complete (non empty Chain)
 for x,y being Element of L st x < y holds x << y;

theorem :: WAYBEL_3:14
   for L being non empty reflexive antisymmetric RelStr
 for x,y being Element of L st x is not compact & x << y
  holds x < y;

theorem :: WAYBEL_3:15
   for L being non empty lower-bounded reflexive antisymmetric RelStr
   holds Bottom L is compact;

theorem :: WAYBEL_3:16
 for L being up-complete (non empty Poset)
 for D being non empty finite directed Subset of L holds sup D in D;

theorem :: WAYBEL_3:17
   for L being up-complete (non empty Poset) st L is finite
 for x being Element of L holds x is isolated_from_below;

begin :: The Way-Below Relation in Other Terms

scheme :: WAYBEL_3:sch 1
 SSubsetEx {S() -> non empty RelStr, P[set]}:
 ex X being Subset of S() st
  for x being Element of S() holds x in X iff P[x]
proof
    defpred p[set] means P[$1];
    consider X being Subset of S() such that
A1:  for x being Element of S() holds x in X iff p[x]
     from SETWISEO:sch 1;
   take X;
   thus thesis by A1;
  end;

theorem :: WAYBEL_3:18
 for L being complete LATTICE, x,y being Element of L st x << y
  for X being Subset of L st y <= sup X
   ex A being finite Subset of L st A c= X & x <= sup A;

theorem :: WAYBEL_3:19
   for L being complete LATTICE, x,y being Element of L
  st for X being Subset of L st y <= sup X
    ex A being finite Subset of L st A c= X & x <= sup A
  holds x << y;

theorem :: WAYBEL_3:20
   for L being non empty reflexive transitive RelStr
 for x,y being Element of L st x << y
  for I being Ideal of L st y <= sup I holds x in I;

theorem :: WAYBEL_3:21
 for L being up-complete (non empty Poset), x,y being Element of L st
  for I being Ideal of L st y <= sup I holds x in I
 holds x << y;

theorem :: WAYBEL_3:22  :: Remark 1.5 (ii)
   for L being lower-bounded LATTICE st L is meet-continuous
 for x,y being Element of L holds
  x << y iff for I being Ideal of L st y = sup I holds x in I;

theorem :: WAYBEL_3:23
   for L being complete LATTICE holds
  (for x being Element of L holds x is compact)
 iff
  (for X being non empty Subset of L ex x being Element of L st x in X &
    for y being Element of L st y in X holds not x < y);

begin :: Continuous Lattices

definition
 let L be non empty reflexive RelStr;
 attr L is satisfying_axiom_of_approximation means
:: WAYBEL_3:def 5

  for x being Element of L holds x = sup waybelow x;
end;


registration
 cluster trivial -> satisfying_axiom_of_approximation
   (non empty reflexive RelStr);
 coherence
  proof let L be non empty reflexive RelStr; assume
      for x,y being Element of L holds x = y;
   hence for x being Element of L holds x = sup waybelow x;
  end;
end;


definition
 let L be non empty reflexive RelStr;
 attr L is continuous means
:: WAYBEL_3:def 6

  (for x being Element of L holds waybelow x is non empty directed) &
  L is up-complete satisfying_axiom_of_approximation;
end;


registration
 cluster continuous -> up-complete satisfying_axiom_of_approximation
  (non empty reflexive RelStr);
 coherence by Def6;
 cluster up-complete satisfying_axiom_of_approximation -> continuous
  (lower-bounded sup-Semilattice);
 coherence
  proof let L be lower-bounded sup-Semilattice; assume
A1:  L is up-complete satisfying_axiom_of_approximation;
   thus for x be Element of L holds waybelow x is non empty directed;
   thus thesis by A1;
  end;
end;


registration
 cluster continuous complete strict LATTICE;
 existence
  proof consider x being set, R be Order of {x};
      RelStr(#{x},R#) is trivial non empty RelStr;
   hence thesis;
  end;
end;


registration
 let L be continuous (non empty reflexive RelStr);
 let x be Element of L;
 cluster waybelow x -> non empty directed;
 coherence by Def6;
end;


theorem :: WAYBEL_3:24
   for L being up-complete Semilattice
  st for x being Element of L holds waybelow x is non empty directed
  holds
   L is satisfying_axiom_of_approximation
  iff
   for x,y being Element of L st not x <= y
    ex u being Element of L st u << x & not u <= y;

theorem :: WAYBEL_3:25
   for L being continuous LATTICE, x,y being Element of L
  holds x <= y iff waybelow x c= waybelow y;

registration
 cluster complete -> satisfying_axiom_of_approximation (non empty Chain);
 coherence
  proof let L be non empty Chain; assume
      L is complete;
   then reconsider S = L as complete (non empty Chain);
      S is satisfying_axiom_of_approximation
     proof let x be Element of S;
A1:     ex_sup_of waybelow x,S by YELLOW_0:17;
A2:     x is_>=_than waybelow x by Th9;
         now let y be Element of S; assume
A3:       y is_>=_than waybelow x & not x <= y;
         then x >= y & x <> y by WAYBEL_0:def 29;
         then x > y by ORDERS_1:def 10;
         then x >> y by Th13;
         then y in waybelow x by Th7;
         then for z being Element of S st z is_>=_than waybelow x holds z >= y
          by LATTICE3:def 9;
then A4:       sup waybelow x = y by A1,A3,YELLOW_0:def 9;
           x << x
          proof let D be non empty directed Subset of S; assume
A5:          x <= sup D; assume
A6:          for d being Element of S st d in D holds not x <= d;
A7:          D c= waybelow x
             proof let a be set; assume
A8:            a in D;
              then reconsider a as Element of S;
                 not x <= a by A6,A8;
               then a <= x & a <> x by WAYBEL_0:def 29;
               then a < x by ORDERS_1:def 10;
               then a << x by Th13;
              hence thesis by Th7;
             end;
              ex_sup_of D,S by YELLOW_0:17;
            then sup D <= sup waybelow x by A1,A7,YELLOW_0:34;
           hence contradiction by A3,A4,A5,ORDERS_1:26;
          end;
         then x in waybelow x by Th7;
        hence contradiction by A3,LATTICE3:def 9;
       end;
      hence thesis by A1,A2,YELLOW_0:def 9;
     end;
   hence thesis;
  end;
end;


theorem :: WAYBEL_3:26
   for L being complete LATTICE st
  for x being Element of L holds x is compact
 holds L is satisfying_axiom_of_approximation;

begin :: The Way-Below Relation in Directed Powers

definition
 let f be Relation;
 attr f is non-Empty means
:: WAYBEL_3:def 7

  for S being 1-sorted st S in rng f holds S is non empty;
 attr f is reflexive-yielding means
:: WAYBEL_3:def 8

  for S being RelStr st S in rng f holds S is reflexive;
end;


registration
 let I be set;
 cluster RelStr-yielding non-Empty reflexive-yielding ManySortedSet of I;
 existence
  proof consider R being reflexive non empty RelStr;
   set J = I --> R;
A1:  dom J = I & rng J c= {R} by FUNCOP_1:19;
   then reconsider J as ManySortedSet of I by PBOOLE:def 3;
   take J;
   thus J is RelStr-yielding;
   thus J is non-Empty
    proof let S be 1-sorted; assume S in rng J;
     hence thesis by A1,TARSKI:def 1;
    end;
   let S be RelStr; assume S in rng J;
   hence thesis by A1,TARSKI:def 1;
  end;
end;


registration
 let I be set;
 let J be RelStr-yielding non-Empty ManySortedSet of I;
 cluster product J -> non empty;
 coherence
  proof
A1:  the carrier of product J = product Carrier J by YELLOW_1:def 4;
      now assume {} in rng Carrier J;
     then consider i being set such that
A2:    i in dom Carrier J & {} = (Carrier J).i by FUNCT_1:def 5;
A3:    dom Carrier J = I & dom J = I by PBOOLE:def 3;
     then consider R being 1-sorted such that
A4:    R = J.i & {} = the carrier of R by A2,PRALG_1:def 13;
        R in rng J by A2,A3,A4,FUNCT_1:def 5;
     then reconsider R as non empty RelStr by Def7,YELLOW_1:def 3;
        the carrier of R = {} by A4;
     hence contradiction;
    end;
    then the carrier of product J <> {} by A1,CARD_3:37;
   hence thesis by STRUCT_0:def 1;
  end;
end;


definition
 let I be non empty set;
 let J be RelStr-yielding non-Empty ManySortedSet of I;
 let i be Element of I;
 redefine func J.i -> non empty RelStr;
end;


registration
 let I be set;
 let J be RelStr-yielding non-Empty ManySortedSet of I;
 cluster -> Function-like Relation-like (Element of product J);
 coherence
  proof let x be Element of product J;
      the carrier of product J = product Carrier J by YELLOW_1:def 4;
    then ex g being Function st x = g & dom g = dom Carrier J &
     for x being set st x in dom Carrier J holds g.x in (Carrier J).x
      by CARD_3:def 5;
   hence thesis;
  end;
end;


definition
 let I be non empty set;
 let J be RelStr-yielding non-Empty ManySortedSet of I;
 let x be Element of product J;
 let i be Element of I;
 redefine func x.i -> Element of J.i;
end;


definition
 let I be non empty set;
 let J be RelStr-yielding non-Empty ManySortedSet of I;
 let i be Element of I;
 let X be Subset of product J;
 redefine func pi(X,i) -> Subset of J.i;
end;


theorem :: WAYBEL_3:27
 for I being non empty set
 for J being RelStr-yielding non-Empty ManySortedSet of I
 for x being Function holds
  x is Element of product J iff dom x = I &
    for i being Element of I holds x.i is Element of J.i;

theorem :: WAYBEL_3:28
 for I being non empty set
 for J being RelStr-yielding non-Empty ManySortedSet of I
 for x,y being Element of product J holds
   x <= y iff for i being Element of I holds x.i <= y.i;

definition
 let I be non empty set;
 let J be RelStr-yielding non-Empty reflexive-yielding ManySortedSet of I;
 let i be Element of I;
 redefine func J.i -> non empty reflexive RelStr;
end;
registration
 let I be non empty set;
 let J be RelStr-yielding non-Empty reflexive-yielding ManySortedSet of I;
 cluster product J -> reflexive;
 coherence
  proof thus product J is reflexive
  proof let x be Element of product J;
      now let i be Element of I;
      J.i is reflexive;
     hence x.i <= x.i by YELLOW_0:def 1;
    end;
   hence thesis by Th28;
  end;
  end;
 end;

definition
 let I be non empty set;
 let J be RelStr-yielding non-Empty reflexive-yielding ManySortedSet of I;
 let x be Element of product J;
 let i be Element of I;
 redefine func x.i -> Element of J.i;
end;


theorem :: WAYBEL_3:29
 for I being non empty set
 for J being RelStr-yielding non-Empty ManySortedSet of I
  st for i being Element of I holds J.i is transitive
 holds product J is transitive;

theorem :: WAYBEL_3:30
 for I being non empty set
 for J being RelStr-yielding non-Empty ManySortedSet of I
  st for i being Element of I holds J.i is antisymmetric
 holds product J is antisymmetric;

theorem :: WAYBEL_3:31
 for I being non empty set
 for J being RelStr-yielding non-Empty reflexive-yielding ManySortedSet of I
  st for i being Element of I holds J.i is complete LATTICE
 holds product J is complete LATTICE;

theorem :: WAYBEL_3:32
 for I being non empty set
 for J being RelStr-yielding non-Empty reflexive-yielding ManySortedSet of I
  st for i being Element of I holds J.i is complete LATTICE
 for X being Subset of product J, i being Element of I holds
   (sup X).i = sup pi(X,i);

theorem :: WAYBEL_3:33
   for I being non empty set
 for J being RelStr-yielding non-Empty reflexive-yielding ManySortedSet of I
  st for i being Element of I holds J.i is complete LATTICE
 for x,y being Element of product J holds
   x << y
  iff
   (for i being Element of I holds x.i << y.i) &
   (ex K being finite Subset of I st
      for i being Element of I st not i in K holds x.i = Bottom (J.i));

begin :: The Way-Below Relation in Topological Spaces

theorem :: WAYBEL_3:34
 for T being non empty TopSpace
 for x,y being Element of InclPoset the topology of T
  st x is_way_below y
 for F being Subset-Family of T st F is open & y c= union F
  ex G being finite Subset of F st x c= union G;

theorem :: WAYBEL_3:35
 for T being non empty TopSpace
 for x,y being Element of InclPoset the topology of T
  st for F being Subset-Family of T st F is open & y c= union F
       ex G being finite Subset of F st x c= union G
  holds x is_way_below y;

theorem :: WAYBEL_3:36
 for T being non empty TopSpace
 for x being Element of InclPoset the topology of T
 for X being Subset of T st x = X
 holds x is compact iff X is compact;

theorem :: WAYBEL_3:37
   for T being non empty TopSpace
 for x being Element of InclPoset the topology of T
  st x = the carrier of T
 holds x is compact iff T is compact;

definition
 let T be non empty TopSpace;
 attr T is locally-compact means
:: WAYBEL_3:def 9

  for x being Point of T, X being Subset of T st x in X & X is open
   ex Y being Subset of T st x in Int Y & Y c= X & Y is compact;
end;


registration
 cluster compact being_T2 -> being_T3 being_T4 locally-compact
   (non empty TopSpace);
 coherence
  proof let T be non empty TopSpace; assume
A1:  T is compact being_T2;
   hence
A2:  T is_T3 & T is_T4 by COMPTS_1:21,22;
A3:  [#]T is compact & [#]T = the carrier of T by A1,COMPTS_1:10,PRE_TOPC:12;
   let x be Point of T, X be Subset of T;
   assume x in X & X is open;
   then consider Y being open Subset of T such that
A4:  x in Y & Cl Y c= X by A2,URYSOHN1:29;
   take Z = Cl Y;
      Y c= Z by PRE_TOPC:48;
    then Y c= Int Z & Z is closed by TOPS_1:56;
   hence x in Int Z & Z c= X & Z is compact by A3,A4,COMPTS_1:18;
  end;
end;


theorem :: WAYBEL_3:38
 for x being set holds 1TopSp {x} is being_T2;

registration
 cluster compact being_T2 (non empty TopSpace);
 existence
  proof take 1TopSp {0};
   thus thesis by Th38,PCOMPS_1:9;
  end;
end;


theorem :: WAYBEL_3:39
 for T being non empty TopSpace
 for x,y being Element of InclPoset the topology of T
   st ex Z being Subset of T st x c= Z & Z c= y & Z is compact
   holds x << y;

theorem :: WAYBEL_3:40
 for T being non empty TopSpace st T is locally-compact
 for x,y being Element of InclPoset the topology of T st x << y
  ex Z being Subset of T st x c= Z & Z c= y & Z is compact;

theorem :: WAYBEL_3:41
   for T being non empty TopSpace st T is locally-compact & T is_T2
 for x,y being Element of InclPoset the topology of T st x << y
  ex Z being Subset of T st Z = x & Cl Z c= y & Cl Z is compact;

theorem :: WAYBEL_3:42
   for X being non empty TopSpace st X is_T3 &
   InclPoset the topology of X is continuous
  holds X is locally-compact;

theorem :: WAYBEL_3:43
   for T being non empty TopSpace st T is locally-compact
  holds InclPoset the topology of T is continuous;

