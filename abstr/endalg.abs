:: On the Monoid of Endomorphisms of Universal Algebra \& Many
:: Sorted Algebra
::  by Jaros{\l}aw Gryko
::
:: Received October 17, 1995
:: Copyright (c) 1995 Association of Mizar Users

environ

 vocabulary UNIALG_1, FUNCT_1, FRAENKEL, ALG_1, FUNCT_2, BINOP_1, VECTSP_1,
      VECTSP_2, AMI_1, MSUALG_1, ZF_REFLE, AUTALG_1, PRALG_1, CARD_3, NATTRA_1,
      MSUALG_3, FUNCOP_1, MSUHOM_1, RELAT_1, PRE_TOPC, COHSP_1, GROUP_6,
      WELLORD1, ENDALG;
 notation TARSKI, XBOOLE_0, ZFMISC_1, SUBSET_1, PRE_TOPC, RELAT_1, FUNCT_1,
      CARD_3, STRUCT_0, MONOID_0, VECTSP_1, BINOP_1, PARTFUN1, FUNCT_2,
      FRAENKEL, FINSEQ_1, UNIALG_1, MSUALG_1, ALG_1, MSUALG_3, MSUHOM_1,
      AUTALG_1;
 constructors TEX_2, BINOP_1, ALG_1, MSUALG_3, MSUHOM_1, AUTALG_1, MONOID_0,
      MEMBERED;
 clusters FRAENKEL, MONOID_0, RELSET_1, MSUALG_1, STRUCT_0, SUBSET_1, MEMBERED,
      FUNCT_2, PARTFUN1, NUMBERS, ORDINAL2;
 requirements SUBSET, BOOLE;


begin

 reserve UA for Universal_Algebra;

definition let UA;
  func UAEnd UA -> FUNCTION_DOMAIN of the carrier of UA, the carrier of UA
  means
:: ENDALG:def 1
  for h be Function of UA, UA holds h in it iff h is_homomorphism UA, UA;
end;


theorem :: ENDALG:1
   UAEnd UA c= Funcs (the carrier of UA, the carrier of UA);

canceled;

theorem :: ENDALG:3
 id the carrier of UA in UAEnd UA;

theorem :: ENDALG:4
 for f1, f2 be Element of UAEnd UA holds f1 * f2 in UAEnd UA;

definition let UA;
  func UAEndComp UA -> BinOp of UAEnd UA means
:: ENDALG:def 2
   for x, y be Element of UAEnd UA holds it.(x, y) = y * x;
end;


definition let UA;
  func UAEndMonoid UA -> strict multLoopStr means
:: ENDALG:def 3
          the carrier of it = UAEnd UA &
          the mult of it = UAEndComp UA &
          the unity of it = id the carrier of UA;
end;


registration let UA;
  cluster UAEndMonoid UA -> non empty;
  coherence
    proof
     reconsider i = id the carrier of UA as Element of UAEnd UA by Th3;
       multLoopStr(#UAEnd UA, UAEndComp UA, i#) is non empty;
     hence thesis by Def3;
    end;
end;


registration let UA;
  cluster UAEndMonoid UA -> left_unital well-unital associative;
coherence
proof
 reconsider i = id the carrier of UA as Element of UAEnd UA by Th3;
 set H = multLoopStr (# UAEnd UA, UAEndComp UA, i#);
A1:H is left_unital
  proof
A2:    now
        let f, g be Element of H,
            A, B be Element of UAEnd UA;
        assume f = A & g = B;
        hence f * g = (UAEndComp UA).(A, B) by VECTSP_1:def 10
                   .= B * A by Def2;
      end;
       H is left_unital
      proof
         for x being Element of H holds (1_ H)*x = x
        proof
         let x be Element of H;
         consider A be Element of UAEnd UA such that
A3:       A = x;
           (1_ H)*x = (the unity of H)*x by VECTSP_1:def 9
                .= A*(id the carrier of UA) by A2,A3
                .= x by A3,FUNCT_2:74;
         hence thesis;
        end;
       hence thesis by VECTSP_1:def 19;
      end;
     hence thesis;
  end;
A4:H is well-unital
proof
A5:    now
        let f, g be Element of H,
            A, B be Element of UAEnd UA;
        assume f = A & g = B;
        hence f * g = (UAEndComp UA).(A, B) by VECTSP_1:def 10
                   .= B * A by Def2;
      end;
      consider e be Element of UAEnd UA such that
A6:   e = i;
        for a being Element of H holds
             (the unity of H)*a = a & a*(the unity of H) = a
      proof
       let a be Element of H;
       A7:(the unity of H)*a = a
         proof
          consider A be Element of UAEnd UA such that
A8:        A = a;
            (the unity of H)*a = A*e by A5,A6,A8
                            .= a by A6,A8,FUNCT_2:74;
         hence thesis;
         end;
            a*(the unity of H) = a
         proof
          consider A be Element of UAEnd UA such that
A9:        A = a;
            a*(the unity of H) = e*A by A5,A6,A9
                            .= a by A6,A9,FUNCT_2:74;
         hence thesis;
         end;
       hence thesis by A7;
      end;
    hence thesis by MONOID_0:18;
end;
 H is associative
proof
A10:    now
        let f, g be Element of H,
            A, B be Element of UAEnd UA;
        assume f = A & g = B;
        hence f * g = (UAEndComp UA).(A, B) by VECTSP_1:def 10
                   .= B * A by Def2;
      end;
      thus for f, g, h be Element of H
      holds (f * g) * h = f * (g * h)
     proof
        let f, g, h be Element of H;
        reconsider A = f, B = g, C = h as Element of UAEnd UA;
A11:     f * g = B * A by A10;
A12:     g * h = C * B by A10;
        thus (f * g) * h = C * (B * A) by A10,A11
                        .= (C * B) * A by RELAT_1:55
                        .= f * (g * h) by A10,A12;
      end;
    thus thesis;
  end;
 hence thesis by A1,A4,Def3;
 end;
end;


theorem :: ENDALG:5
 for x, y be Element of UAEndMonoid UA
  for f, g be Element of UAEnd UA st x = f & y = g holds x * y = g * f;

theorem :: ENDALG:6
 id the carrier of UA = 1_ UAEndMonoid UA;

 reserve S for non void non empty ManySortedSign,
         U1 for non-empty MSAlgebra over S;

definition let S, U1;
  func MSAEnd U1 -> MSFunctionSet of the Sorts of U1, the Sorts of U1 means
:: ENDALG:def 4
 (for f be Element of it holds f is ManySortedFunction of U1, U1) &
  for h be ManySortedFunction of U1, U1 holds
      h in it iff h is_homomorphism U1, U1;
end;


canceled 2;

theorem :: ENDALG:9
   MSAEnd U1 c= product MSFuncs (the Sorts of U1, the Sorts of U1);

theorem :: ENDALG:10
 id the Sorts of U1 in MSAEnd U1;

theorem :: ENDALG:11
 for f1, f2 be Element of MSAEnd U1 holds f1 ** f2 in MSAEnd U1;

theorem :: ENDALG:12
 for F be ManySortedFunction of MSAlg UA, MSAlg UA
  for f be Element of UAEnd UA st F = {0} --> f holds F in MSAEnd MSAlg UA;

definition let S, U1;
  func MSAEndComp U1 -> BinOp of MSAEnd U1 means
:: ENDALG:def 5
 for x, y be Element of MSAEnd U1 holds it.(x, y) = y ** x;
end;


definition let S, U1;
  func MSAEndMonoid U1 -> strict multLoopStr means
:: ENDALG:def 6
     the carrier of it = MSAEnd U1 &
        the mult of it = MSAEndComp U1 &
       the unity of it = id the Sorts of U1;
end;


registration let S, U1;
 cluster MSAEndMonoid U1 -> non empty;
 coherence
    proof
     reconsider i = id the Sorts of U1 as Element of MSAEnd U1 by Th10;
       multLoopStr(#MSAEnd U1, MSAEndComp U1, i#) is non empty;
     hence thesis by Def6;
    end;
end;


registration let S,U1;
  cluster MSAEndMonoid U1 -> left_unital well-unital associative;
coherence
 proof
  reconsider i = id the Sorts of U1 as Element of MSAEnd U1 by Th10;
  set H = multLoopStr(#MSAEnd U1, MSAEndComp U1, i#);
A1: H is left_unital
  proof
A2:    now
        let f, g be Element of H,
            A, B be Element of MSAEnd U1;
        assume f = A & g = B;
        hence f * g = (MSAEndComp U1).(A, B) by VECTSP_1:def 10
                   .= B ** A by Def5;
      end;
       H is left_unital
      proof
         for x being Element of H holds (1_ H)*x = x
        proof
         let x be Element of H;
         consider A be Element of MSAEnd U1 such that
A3:       A = x;
           (1_ H)*x = (the unity of H)*x by VECTSP_1:def 9
                .= A**(id the Sorts of U1) by A2,A3
                .= x by A3,MSUALG_3:3;
         hence thesis;
        end;
       hence thesis by VECTSP_1:def 19;
      end;
     hence thesis;
  end;
A4: H is well-unital
   proof
A5:    now
      let f, g be Element of H,
            A, B be Element of MSAEnd U1;
        assume f = A & g = B;
        hence f * g = (MSAEndComp U1).(A, B) by VECTSP_1:def 10
                   .= B ** A by Def5;
   end;
      consider e be Element of MSAEnd U1 such that
A6:   e = i;
      for a being Element of H holds
           (the unity of H)*a = a & a*(the unity of H) = a
     proof
      let a be Element of H;
      A7:(the unity of H)*a = a
         proof
          consider A be Element of MSAEnd U1 such that
A8:        A = a;
            (the unity of H)*a = A**e by A5,A6,A8
                            .= a by A6,A8,MSUALG_3:3;
         hence thesis;
         end;
           a*(the unity of H) = a
         proof
          consider A be Element of MSAEnd U1 such that
A9:        A = a;
            a*(the unity of H) = e**A by A5,A6,A9
                            .= a by A6,A9,MSUALG_3:4;
         hence thesis;
         end;
     hence thesis by A7;
     end;
    hence thesis by MONOID_0:18;
   end;
    H is associative
  proof
A10:    now
        let f, g be Element of H,
            A, B be Element of MSAEnd U1;
        assume f = A & g = B;
        hence f * g = (MSAEndComp U1).(A, B) by VECTSP_1:def 10
                   .= B ** A by Def5;
      end;
     thus for f, g, h be Element of H
      holds (f * g) * h = f * (g * h)
     proof
        let f, g, h be Element of H;
        reconsider A = f, B = g, C = h as Element of MSAEnd U1;
A11:     f * g = B ** A by A10;
A12:     g * h = C ** B by A10;
        thus (f * g) * h = C ** (B ** A) by A10,A11
                        .= (C ** B) ** A by AUTALG_1:13
                        .= f * (g * h) by A10,A12;
      end;
    thus thesis;
  end;
 hence thesis by A1,A4,Def6;
 end;
end;


theorem :: ENDALG:13
 for x, y be Element of MSAEndMonoid U1
  for f, g be Element of MSAEnd U1 st x = f & y = g holds x * y = g ** f;

theorem :: ENDALG:14
 id the Sorts of U1 = 1_ MSAEndMonoid U1;

canceled;

theorem :: ENDALG:16
 for f be Element of UAEnd UA
  holds {0} --> f is ManySortedFunction of MSAlg UA, MSAlg UA;

definition
  let G,H be non empty HGrStr;
  let IT be map of G,H;
  attr IT is multiplicative means
:: ENDALG:def 7
 for x,y being Element of G holds
       IT.(x*y) = (IT.x)*(IT.y);
end;


definition let G,H be non empty multLoopStr;
  let IT be map of G,H;
 attr IT is unity-preserving means
:: ENDALG:def 8
 IT.1_ G = 1_ H;
end;


registration
 cluster left_unital (non empty multLoopStr);
 existence
  proof
    consider m being BinOp of {0}, u be Element of {0};
   take multLoopStr(#{0},m,u#);
   let x be Element of multLoopStr(#{0},m,u#);
   thus (1_ multLoopStr(#{0},m,u#))*x = 0 by TARSKI:def 1
        .= x by TARSKI:def 1;
  end;
end;


registration let G,H be left_unital (non empty multLoopStr);
 cluster multiplicative unity-preserving map of G,H;
 existence
  proof
   reconsider m = (the carrier of G) --> 1_ H
          as Function of the carrier of G,the carrier of H by FUNCOP_1:57;
   reconsider m as map of G,H;
   take m;
    thus m is multiplicative
     proof
        for x,y being Element of G holds m.(x*y) = (m.x)*(m.y)
       proof
        let x,y be Element of G;
          m.(x*y) = 1_ H by FUNCOP_1:13
               .= 1_ H * 1_ H by VECTSP_1:def 19
               .= (m.x)* 1_ H by FUNCOP_1:13
               .= (m.x)*(m.y) by FUNCOP_1:13;
        hence thesis;
       end;
      hence thesis by Def7;
     end;
   thus m.1_ G = 1_ H by FUNCOP_1:13;
  end;
end;


definition let G,H be left_unital (non empty multLoopStr);
  mode Homomorphism of G,H is multiplicative unity-preserving map of G,H;
end;


definition let G,H be left_unital (non empty multLoopStr),h be map of G,H;
  pred h is_monomorphism means
:: ENDALG:def 9
   h is one-to-one;

  pred h is_epimorphism means
:: ENDALG:def 10
   rng h = the carrier of H;
end;


definition let G,H be left_unital (non empty multLoopStr),h be map of G,H;
  pred h is_isomorphism means
:: ENDALG:def 11
  h is_epimorphism & h is_monomorphism;
end;


theorem :: ENDALG:17
 for G be left_unital (non empty multLoopStr) holds
  id the carrier of G is Homomorphism of G,G;

definition let G,H be left_unital (non empty multLoopStr);
  pred G,H are_isomorphic means
:: ENDALG:def 12
  ex h be Homomorphism of G,H st h is_isomorphism;
 reflexivity;
end;


theorem :: ENDALG:18
 for h be Function st (dom h = UAEnd UA &
  for x be set st x in UAEnd UA holds h.x = {0} --> x)
   holds h is Homomorphism of UAEndMonoid UA, MSAEndMonoid (MSAlg UA);

theorem :: ENDALG:19
 for h be Homomorphism of UAEndMonoid UA, MSAEndMonoid (MSAlg UA) st
  for x be set st x in UAEnd UA holds h.x = {0} --> x holds h is_isomorphism;

theorem :: ENDALG:20
   UAEndMonoid UA, MSAEndMonoid (MSAlg UA) are_isomorphic;
