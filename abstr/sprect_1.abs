:: On Rectangular Finite Sequences of the Points of the Plane
::  by Andrzej Trybulec and Yatsuka Nakamura
::
:: Received November 30, 1997
:: Copyright (c) 1997 Association of Mizar Users

environ

 vocabulary REALSET1, SEQM_3, FUNCT_1, RELAT_1, FUNCOP_1, BOOLE, FINSEQ_1,
      PRE_TOPC, CONNSP_1, EUCLID, COMPTS_1, TOPREAL1, SPPOL_1, MCART_1,
      SPPOL_2, PSCOMP_1, FINSEQ_6, GOBOARD5, GOBOARD1, CARD_1, ORDINAL2,
      GOBOARD2, MATRIX_2, TREES_1, MATRIX_1, ABSVALUE, ARYTM_1, RCOMP_1, SEQ_2,
      FUNCT_5, SQUARE_1, LATTICES, ARYTM_3, JORDAN1, SUBSET_1, GOBOARD9,
      TOPS_1, SPRECT_1, FINSEQ_4, ARYTM;
 notation TARSKI, XBOOLE_0, ENUMSET1, ZFMISC_1, SUBSET_1, RELAT_1, ORDINAL1,
      NUMBERS, XREAL_0, REAL_1, NAT_1, ABSVALUE, CARD_1, FUNCOP_1, SQUARE_1,
      FUNCT_1, FUNCT_2, FINSEQ_1, FINSEQ_4, FINSEQ_6, SEQM_3, SEQ_4, MATRIX_1,
      MATRIX_2, REALSET1, RCOMP_1, STRUCT_0, PRE_TOPC, TOPS_1, COMPTS_1,
      CONNSP_1, EUCLID, TOPREAL1, JORDAN1, GOBOARD1, GOBOARD2, GOBOARD5,
      GOBOARD9, SPPOL_1, SPPOL_2, PSCOMP_1;
 constructors PSCOMP_1, NAT_1, SPPOL_1, SPPOL_2, TOPREAL4, REALSET1, GOBOARD2,
      ENUMSET1, MATRIX_2, REAL_1, ABSVALUE, GOBOARD9, JORDAN1, CONNSP_1,
      TOPS_1, FUNCOP_1, SQUARE_1, RCOMP_1, FINSEQ_4, COMPTS_1, PARTFUN1;
 clusters STRUCT_0, EUCLID, PSCOMP_1, RELSET_1, FINSEQ_6, YELLOW_6, GOBOARD2,
      FINSEQ_5, GOBOARD9, TEX_2, RELAT_1, GOBOARD5, PRE_TOPC, WAYBEL_2,
      TOPREAL1, FINSEQ_1, REALSET1, XBOOLE_0, SEQ_2, NAT_1, MEMBERED, SEQM_3;
 requirements REAL, NUMERALS, BOOLE, SUBSET, ARITHM;


begin :: Preliminaries

theorem :: SPRECT_1:1
 for A being trivial set
  for B being set st B c= A holds B is trivial;

registration
 cluster non constant -> non trivial Function;
 coherence
  proof let f be Function;
   assume f is non constant;
    then consider n1,n2 being set such that
A1:  n1 in dom f & n2 in dom f and
A2:  f.n1 <> f.n2 by SEQM_3:def 5;
      [n1,f.n1] in f & [n2,f.n2] in f by A1,FUNCT_1:8;
    then reconsider f as non empty Function;
      f is non trivial
     proof
      reconsider x = [n1,f.n1], y = [n2,f.n2] as Element of f by A1,FUNCT_1:8;
      take x,y;
      thus x <> y by A2,ZFMISC_1:33;
     end;
   hence thesis;
  end;
end;


registration
 cluster trivial -> constant Function;
 coherence
  proof let f be Function such that
A1: f is trivial;
   assume f is not constant;
    then reconsider f as non constant Function;
      f is not trivial;
   hence contradiction by A1;
  end;
end;


theorem :: SPRECT_1:2
 for f being Function st rng f is trivial holds f is constant;

registration let f be constant Function;
 cluster rng f -> trivial;
 coherence
  proof
    per cases;
    suppose f is empty;
     then reconsider g = f as empty Function;
      rng g is empty;
   hence rng f is trivial;
    end;
    suppose f <> {};
    then dom f <> {} by RELAT_1:64;
    then consider x being set such that
A1:   x in dom f by XBOOLE_0:def 1;
      for y being set holds
      y in {f.x} iff ex z being set st z in dom f & y = f.z
    proof let y be set;
      hereby assume
A2:      y in {f.x};
       take x;
       thus x in dom f & y = f.x by A1,A2,TARSKI:def 1;
      end;
     given z being set such that
A3:   z in dom f and
A4:   y = f.z;
        y = f.x by A1,A3,A4,SEQM_3:def 5;
     hence y in {f.x} by TARSKI:def 1;
    end;
   hence rng f is trivial by FUNCT_1:def 5;
  end;
  end;
end;


registration
 cluster non empty constant FinSequence;
 existence proof take <* 0 *>; thus thesis; end;
end;


theorem :: SPRECT_1:3
 for f,g being FinSequence st f^g is constant
  holds f is constant & g is constant;

theorem :: SPRECT_1:4
 for x,y being set st <*x,y*> is constant
  holds x = y;

theorem :: SPRECT_1:5
 for x,y,z being set st <*x,y,z*> is constant
  holds x = y & y = z & z = x;

begin :: Topology

theorem :: SPRECT_1:6
 for GX being non empty TopSpace,
     A being Subset of GX,
     B being non empty Subset of GX
 holds A is_a_component_of B implies A <> {};

theorem :: SPRECT_1:7
 for GX being TopStruct,
     A, B being Subset of GX
 holds A is_a_component_of B implies A c= B;

theorem :: SPRECT_1:8
 for T being non empty TopSpace,
     A being non empty Subset of T,
     B1,B2,S being Subset of T
  st B1 is_a_component_of A & B2 is_a_component_of A &
     S is_a_component_of A & B1 \/ B2 = A
 holds S = B1 or S = B2;

theorem :: SPRECT_1:9
 for T being non empty TopSpace,
     A being non empty Subset of T,
     B1,B2,C1,C2 being Subset of T
  st B1 is_a_component_of A & B2 is_a_component_of A &
     C1 is_a_component_of A & C2 is_a_component_of A &
     B1 \/ B2 = A & C1 \/ C2 = A
 holds { B1,B2 } = { C1,C2 };

begin :: Topology of Plane

reserve S for Subset of TOP-REAL 2,
        C,C1,C2 for non empty compact Subset of TOP-REAL 2,
        p,q for Point of TOP-REAL 2;

theorem :: SPRECT_1:10
 for p,q,r being Point of TOP-REAL 2
  holds L~<*p,q,r*> = LSeg(p,q) \/ LSeg(q,r);

registration let n be Nat; let f be non trivial FinSequence of TOP-REAL n;
 cluster L~f -> non empty;
 coherence
  proof
      len f <> 0 & len f <> 1 by SPPOL_1:2;
   hence L~f is non empty by TOPREAL1:28;
  end;
end;


registration let f be FinSequence of TOP-REAL 2;
 cluster L~f -> compact;
 coherence
  proof
    defpred X[Nat] means for f being FinSequence of TOP-REAL 2 st len f = $1
       holds L~f is compact;
A1: X[0]
   proof let f be FinSequence of TOP-REAL 2;
     assume len f = 0;
      then L~f ={}TOP-REAL 2 by TOPREAL1:28;
     hence L~f is compact by COMPTS_1:9;
    end;
A2: for m being Nat st X[m] holds X[m+1]
    proof let m be Nat;
     assume
A3:    for f being FinSequence of TOP-REAL 2 st len f = m
       holds L~f is compact;
     let f be FinSequence of TOP-REAL 2;
     assume
A4:   len f = m+1;
      then consider q being FinSequence of TOP-REAL 2,
                   x being Point of TOP-REAL 2 such that
A5:     f=q^<*x*> by FINSEQ_2:22;
        len f = len q + len<*x*> by A5,FINSEQ_1:35
           .= len q + 1 by FINSEQ_1:56;
      then len q = m by A4,XCMPLX_1:2;
      then A6:     L~q is compact by A3;
     per cases;
     suppose q is empty;
      then L~f = L~<*x*> by A5,FINSEQ_1:47
              .= {}TOP-REAL 2 by SPPOL_2:12;
     hence L~f is compact by COMPTS_1:9;
     end;
     suppose q is non empty;
      then L~f = L~q \/ LSeg(q/.len q,<*x*>/.1) \/ L~<*x*> by A5,SPPOL_2:23
              .= L~q \/ LSeg(q/.len q,<*x*>/.1) \/ {} by SPPOL_2:12
              .= L~q \/ LSeg(q/.len q,<*x*>/.1);
     hence L~f is compact by A6,COMPTS_1:19;
    end;
    end;
A7:  for m being Nat holds X[m] from NAT_1:sch 1(A1,A2);
      len f = len f;
   hence L~f is compact by A7;
  end;
end;


theorem :: SPRECT_1:11
 for A,B being Subset of TOP-REAL 2 st A c= B & B is horizontal
 holds A is horizontal;

theorem :: SPRECT_1:12
 for A,B being Subset of TOP-REAL 2 st A c= B & B is vertical
 holds A is vertical;

registration
 cluster R^2-unit_square -> special_polygonal non horizontal non vertical;
 coherence
  proof set Sq = R^2-unit_square;
   thus Sq is special_polygonal by SPPOL_2:61;
     Sq = ( LSeg(|[0,0]|,|[0,1]|) \/ LSeg(|[0,1]|,|[1,1]|) ) \/
        ( LSeg(|[1,1]|,|[1,0]|) \/ LSeg(|[1,0]|,|[0,0]|) ) by SPPOL_2:58,60;
   then A1:  LSeg(|[0,0]|,|[0,1]|) \/ LSeg(|[0,1]|,|[1,1]|) c= Sq by XBOOLE_1:7
;
      LSeg(|[0,0]|,|[0,1]|) c= LSeg(|[0,0]|,|[0,1]|) \/ LSeg(|[0,1]|,|[1,1]|)
            by XBOOLE_1:7;
    then A2:  LSeg(|[0,0]|,|[0,1]|) c= Sq by A1,XBOOLE_1:1;
      |[0,0]|`2 = 0 & |[0,1]|`2 = 1 by EUCLID:56;
    then LSeg(|[0,0]|,|[0,1]|) is not horizontal by SPPOL_1:36;
   hence Sq is not horizontal by A2,Th11;
      LSeg(|[0,1]|,|[1,1]|) c= LSeg(|[0,0]|,|[0,1]|) \/ LSeg(|[0,1]|,|[1,1]|)
            by XBOOLE_1:7;
    then A3:  LSeg(|[0,1]|,|[1,1]|) c= Sq by A1,XBOOLE_1:1;
      |[0,1]|`1 = 0 & |[1,1]|`1 = 1 by EUCLID:56;
    then LSeg(|[0,1]|,|[1,1]|) is not vertical by SPPOL_1:37;
   hence Sq is not vertical by A3,Th12;
  end;
end;


registration
 cluster non vertical non horizontal non empty compact Subset of TOP-REAL 2;
 existence
  proof
   take R^2-unit_square;
   thus thesis by SPPOL_2:63;
  end;
end;


begin :: Special points of a compact non empty subset of the plane

theorem :: SPRECT_1:13
 N-min C in C & N-max C in C;

theorem :: SPRECT_1:14
 S-min C in C & S-max C in C;

theorem :: SPRECT_1:15
 W-min C in C & W-max C in C;

theorem :: SPRECT_1:16
 E-min C in C & E-max C in C;

theorem :: SPRECT_1:17
 C is vertical iff W-bound C = E-bound C;

theorem :: SPRECT_1:18
 C is horizontal iff S-bound C = N-bound C;

theorem :: SPRECT_1:19
   NW-corner C = NE-corner C implies C is vertical;

theorem :: SPRECT_1:20
   SW-corner C = SE-corner C implies C is vertical;

theorem :: SPRECT_1:21
   NW-corner C = SW-corner C implies C is horizontal;

theorem :: SPRECT_1:22
   NE-corner C = SE-corner C implies C is horizontal;

 reserve i,j,k for Nat,
         t,r1,r2,s1,s2 for Real;

theorem :: SPRECT_1:23
 W-bound C <= E-bound C;

theorem :: SPRECT_1:24
 S-bound C <= N-bound C;

theorem :: SPRECT_1:25
 LSeg(SE-corner C, NE-corner C) =
  { p : p`1 = E-bound C & p`2 <= N-bound C & p`2 >= S-bound C };

theorem :: SPRECT_1:26
  LSeg(SW-corner C, SE-corner C) =
    { p : p`1 <= E-bound C & p`1 >= W-bound C & p`2 = S-bound C};

theorem :: SPRECT_1:27
 LSeg(NW-corner C, NE-corner C) =
  { p : p`1 <= E-bound C & p`1 >= W-bound C & p`2 = N-bound C};

theorem :: SPRECT_1:28
   LSeg(SW-corner C, NW-corner C) =
     { p : p`1 = W-bound C & p`2 <= N-bound C & p`2 >= S-bound C};

theorem :: SPRECT_1:29
   LSeg(SW-corner C,NW-corner C) /\ LSeg(NW-corner C,NE-corner C) = {NW-corner
C
};

theorem :: SPRECT_1:30
 LSeg(NW-corner C,NE-corner C) /\ LSeg(NE-corner C,SE-corner C) = {NE-corner C}
;

theorem :: SPRECT_1:31
 LSeg(SE-corner C,NE-corner C) /\ LSeg(SW-corner C,SE-corner C) = {SE-corner C}
;

theorem :: SPRECT_1:32
 LSeg(NW-corner C,SW-corner C) /\ LSeg(SW-corner C,SE-corner C) = {SW-corner C}
;

begin :: Neither vertical nor horizontal

reserve D1 for non vertical non empty compact Subset of TOP-REAL 2,
        D2 for non horizontal non empty compact Subset of TOP-REAL 2,
        D for non vertical non horizontal non empty compact
              Subset of TOP-REAL 2;

theorem :: SPRECT_1:33
 W-bound D1 < E-bound D1;

theorem :: SPRECT_1:34
 S-bound D2 < N-bound D2;

theorem :: SPRECT_1:35
 LSeg(SW-corner D1,NW-corner D1) misses LSeg(SE-corner D1,NE-corner D1);

theorem :: SPRECT_1:36
 LSeg(SW-corner D2,SE-corner D2) misses LSeg(NW-corner D2,NE-corner D2);

begin :: SpStSeq

definition let C be Subset of TOP-REAL 2;
 func SpStSeq C -> FinSequence of TOP-REAL 2 equals
:: SPRECT_1:def 1
 <*NW-corner C,NE-corner C,SE-corner C*>^
      <*SW-corner C,NW-corner C*>;
end;


theorem :: SPRECT_1:37
 (SpStSeq S)/.1 = NW-corner S;

theorem :: SPRECT_1:38
 (SpStSeq S)/.2 = NE-corner S;

theorem :: SPRECT_1:39
 (SpStSeq S)/.3 = SE-corner S;

theorem :: SPRECT_1:40
 (SpStSeq S)/.4 = SW-corner S;

theorem :: SPRECT_1:41
   (SpStSeq S)/.5 = NW-corner S;

theorem :: SPRECT_1:42
 len SpStSeq S = 5;

theorem :: SPRECT_1:43
 L~SpStSeq S =
   (LSeg(NW-corner S,NE-corner S) \/ LSeg(NE-corner S,SE-corner S)) \/
   (LSeg(SE-corner S,SW-corner S) \/ LSeg(SW-corner S,NW-corner S));

registration let D be non vertical non empty compact Subset of TOP-REAL 2;
 cluster SpStSeq D -> non constant;
  coherence
   proof
A1:    SpStSeq D = <*NW-corner D,NE-corner D,SE-corner D*>^
      <*SW-corner D,NW-corner D*> by Def1;
    assume SpStSeq D is constant;
     then A2:    <*NW-corner D,NE-corner D,SE-corner D*> is constant by A1,Th3;
        |[W-bound D, N-bound D]| = NW-corner D by PSCOMP_1:def 35
        .= NE-corner D by A2,Th5
        .= |[E-bound D, N-bound D]| by PSCOMP_1:def 36;
     then W-bound D = E-bound D by SPPOL_2:1;
    hence contradiction by Th17;
   end;
end;


registration let D be non horizontal non empty compact Subset of TOP-REAL 2;
 cluster SpStSeq D -> non constant;
  coherence
   proof
A1:    SpStSeq D = <*NW-corner D,NE-corner D,SE-corner D*>^
      <*SW-corner D,NW-corner D*> by Def1;
    assume SpStSeq D is constant;
     then A2:    <*SW-corner D,NW-corner D*> is constant by A1,Th3;
        |[W-bound D, N-bound D]| = NW-corner D by PSCOMP_1:def 35
        .= SW-corner D by A2,Th4
        .= |[W-bound D, S-bound D]| by PSCOMP_1:def 34;
     then N-bound D = S-bound D by SPPOL_2:1;
    hence contradiction by Th18;
   end;
end;


registration let D be non vertical non horizontal non empty compact
                    Subset of TOP-REAL 2;
 cluster SpStSeq D -> special unfolded circular s.c.c. standard;
  coherence
   proof
   set f1 = <*NW-corner D,NE-corner D,SE-corner D*>,
       f2 = <*SW-corner D,NW-corner D*>;
A1:len f1 = 3 & len f2 = 2 by FINSEQ_1:61,62;
    then A2: len(f1^f2) = 3+2 by FINSEQ_1:35;
    set f = SpStSeq D;
A3: f = f1^f2 by Def1;
A4: NW-corner D = |[W-bound D,N-bound D]| by PSCOMP_1:def 35;
A5: NE-corner D = |[E-bound D,N-bound D]| by PSCOMP_1:def 36;
A6: SE-corner D = |[E-bound D,S-bound D]| by PSCOMP_1:def 37;
A7: SW-corner D = |[W-bound D,S-bound D]| by PSCOMP_1:def 34;
      1 in dom f1 by A1,FINSEQ_3:27;
then A8: f/.1 = f1/.1 by A3,GROUP_5:95 .= NW-corner D by FINSEQ_4:27;
      2 in dom f1 by A1,FINSEQ_3:27;
then A9: f/.2 = f1/.2 by A3,GROUP_5:95 .= NE-corner D by FINSEQ_4:27;
      3 in dom f1 by A1,FINSEQ_3:27;
then A10: f/.3 = f1/.3 by A3,GROUP_5:95 .= SE-corner D by FINSEQ_4:27;
      1 in dom f2 by A1,FINSEQ_3:27;
then A11: f/.(3+1) = f2/.1 by A1,A3,GROUP_5:96 .= SW-corner D by FINSEQ_4:26;
      2 in dom f2 by A1,FINSEQ_3:27;
then A12: f/.(3+2) = f2/.2 by A1,A3,GROUP_5:96 .= NW-corner D by FINSEQ_4:26;
       1+1 = 2;
then A13: LSeg(f,1) = LSeg(NW-corner D,NE-corner D) by A2,A3,A8,A9,TOPREAL1:def
5;
       2+1 = 3;
then A14: LSeg(f,2) = LSeg(NE-corner D,SE-corner D) by A2,A3,A9,A10,TOPREAL1:
def 5;
A15: LSeg(f,3) = LSeg(SE-corner D,SW-corner D) by A2,A3,A10,A11,TOPREAL1:def 5;
       4+1 = 5;
then A16: LSeg(f,4) = LSeg(SW-corner D,NW-corner D) by A2,A3,A11,A12,TOPREAL1:
def 5;
 thus f is special
    proof let i;
    assume 1 <= i;
     then 1+1 <= i+1 by AXIOMS:24;
     then A17:   1 < i+1 & 0 < i+1 by AXIOMS:22;
    assume i+1 <= len f;
      then A18:    i+1 = 1+1 or i+1 = 2+1 or i+1 = 3+1 or i+1 = 4+1
          by A2,A3,A17,CQC_THE1:6;
     per cases by A18,XCMPLX_1:2;
      suppose
A19:      i = 1;
          (f/.1)`2 = N-bound D by A4,A8,EUCLID:56
                .= (f/.(1+1))`2 by A5,A9,EUCLID:56;
       hence thesis by A19;
      end;
      suppose
A20:     i = 2;
         (f/.2)`1 = E-bound D by A5,A9,EUCLID:56
               .= (f/.(2+1))`1 by A6,A10,EUCLID:56;
       hence thesis by A20;
      end;
      suppose
A21:     i = 3;
         (f/.3)`2 = S-bound D by A6,A10,EUCLID:56
               .= (f/.(3+1))`2 by A7,A11,EUCLID:56;
       hence thesis by A21;
      end;
      suppose
A22:     i = 4;
         (f/.4)`1 = W-bound D by A7,A11,EUCLID:56
               .= (f/.(4+1))`1 by A4,A12,EUCLID:56;
       hence thesis by A22;
    end;
    end;
 thus f is unfolded
    proof let i;
     assume 1 <= i;
      then 1+2 <= i+2 by AXIOMS:24;
      then A23:   2 < i+2 & 1 < i+2 & 0 < i+2 by AXIOMS:22;
     assume i + 2 <= len f;
      then A24:   i+2 = 1+2 or i+2 = 2+2 or i+2 = 3+2 by A2,A3,A23,CQC_THE1:6;
      per cases by A24,XCMPLX_1:2;
     suppose i = 1;
      hence LSeg(f,i) /\ LSeg(f,i+1) = {f/.(i+1)} by A9,A13,A14,Th30;
     end;
     suppose i = 2;
      hence LSeg(f,i) /\ LSeg(f,i+1) = {f/.(i+1)} by A10,A14,A15,Th31;
     end;
     suppose i = 3;
      hence LSeg(f,i) /\ LSeg(f,i+1) = {f/.(i+1)} by A11,A15,A16,Th32;
    end;
    end;
      thus f is circular by A2,A3,A8,A12,FINSEQ_6:def 1;
 thus f is s.c.c.
    proof let i,j;
     assume that
A25:  i+1 < j and
A26:  (i > 1 & j < len f or j+1 < len f);
A27:   i+1 >= 1 by NAT_1:29;
     then A28:   i+1 >= 0 by AXIOMS:22;
     A29:   j+1 = 0+1 or j+1 = 1+1 or j+1 = 2+1 or j+1 = 3+1 or j+1 = 4+1
                                                      by A2,A3,A26,CQC_THE1:6;
A30:   i+1+1 = i+(1+1) by XCMPLX_1:1;
     then A31:  i+2 <= j by A25,NAT_1:38;
A32:   (i+2 = 2+2 implies i=2) &
     (i+2 = 1+2 implies i=1) &
     (i+2 = 0+2 implies i=0) by XCMPLX_1:2;
A33: i+2 <> 0+1 by A30,XCMPLX_1:2;
A34:   now per cases by A25,A27,A28,A29,XCMPLX_1:2;
       case j = 2;
        hence i = 0 by A25,A30,A32,CQC_THE1:3;
       end;
       case j = 3;
        hence i = 0 or i = 1 by A25,A30,A32,CQC_THE1:4;
       end;
       case j = 4;
        hence i = 0 or i = 2 by A2,A26,A31,A32,A33,Def1,CQC_THE1:5;
      end;
      end;
     per cases by A34;
     suppose i = 0;
      then LSeg(f,i) = {} by TOPREAL1:def 5;
     hence LSeg(f,i) /\ LSeg(f,j) = {};
     end;
     suppose i = 1 & j = 3;
     then LSeg(f,i) misses LSeg(f,j) by A13,A15,Th36;
     hence LSeg(f,i) /\ LSeg(f,j) = {} by XBOOLE_0:def 7;
     end;
     suppose i = 2 & j = 4;
     then LSeg(f,i) misses LSeg(f,j) by A14,A16,Th35;
     hence LSeg(f,i) /\ LSeg(f,j) = {} by XBOOLE_0:def 7;
    end;
    end;
    set Xf1 = <*W-bound D,E-bound D,E-bound D*>,
        Xf2 = <*W-bound D,W-bound D*>;
    reconsider Xf = Xf1^Xf2 as FinSequence of REAL;
A35:len Xf1 = 3 & len Xf2 = 2 by FINSEQ_1:61,62;
    then A36: len Xf = 3+2 by FINSEQ_1:35;
      1 in dom Xf1 by A35,FINSEQ_3:27;
then A37: Xf.1 = Xf1.1 by FINSEQ_1:def 7 .= W-bound D by FINSEQ_1:62;
      2 in dom Xf1 by A35,FINSEQ_3:27;
then A38: Xf.2 = Xf1.2 by FINSEQ_1:def 7 .= E-bound D by FINSEQ_1:62;
      3 in dom Xf1 by A35,FINSEQ_3:27;
then A39: Xf.3 = Xf1.3 by FINSEQ_1:def 7 .= E-bound D by FINSEQ_1:62;
      1 in dom Xf2 by A35,FINSEQ_3:27;
then A40: Xf.(3+1) = Xf2.1 by A35,FINSEQ_1:def 7 .= W-bound D by FINSEQ_1:61;
      2 in dom Xf2 by A35,FINSEQ_3:27;
then A41: Xf.(3+2) = Xf2.2 by A35,FINSEQ_1:def 7 .= W-bound D by FINSEQ_1:61;
       now let n be Nat;
      assume n in dom Xf;
       then A42:    n <> 0 & n <= 5 by A36,FINSEQ_3:27;
      per cases by A42,CQC_THE1:6;
      suppose n = 1;
      hence Xf.n = (f/.n)`1 by A8,A37,PSCOMP_1:74;
      end;
      suppose n = 2;
      hence Xf.n = (f/.n)`1 by A9,A38,PSCOMP_1:76;
      end;
      suppose n = 3;
      hence Xf.n = (f/.n)`1 by A10,A39,PSCOMP_1:78;
      end;
      suppose n = 4;
      hence Xf.n = (f/.n)`1 by A11,A40,PSCOMP_1:72;
      end;
      suppose n = 5;
      hence Xf.n = (f/.n)`1 by A12,A41,PSCOMP_1:74;
     end;
     end;
     then A43:   Xf = X_axis f by A2,A3,A36,GOBOARD1:def 3;
A44:    W-bound D < E-bound D by Th33;
A45:    rng Xf1 = { W-bound D,E-bound D,E-bound D } by FINSEQ_2:148
             .= { E-bound D,E-bound D,W-bound D } by ENUMSET1:102
             .= { W-bound D,E-bound D } by ENUMSET1:70;
        rng Xf2 = { W-bound D,W-bound D } by FINSEQ_2:147
             .= { W-bound D } by ENUMSET1:69;
then A46:   rng Xf = { W-bound D,E-bound D } \/ { W-bound D } by A45,FINSEQ_1:
44
            .= { W-bound D,W-bound D,E-bound D } by ENUMSET1:42
            .= { W-bound D,E-bound D } by ENUMSET1:70;
      then A47:   rng <*W-bound D,E-bound D*> = rng Xf by FINSEQ_2:147;
A48:   len <*W-bound D,E-bound D*> = 2 by FINSEQ_1:61
               .= card rng Xf by A44,A46,CARD_2:76;
       <*W-bound D,E-bound D*> is increasing
       proof let n,m be Nat;
           len <*W-bound D,E-bound D*> = 2 by FINSEQ_1:61;
then A49:       dom <*W-bound D,E-bound D*> = { 1,2 } by FINSEQ_1:4,def 3;
        assume n in dom <*W-bound D,E-bound D*> &
               m in dom <*W-bound D,E-bound D*>;
         then A50:       (n = 1 or n = 2) & (m = 1 or m = 2) by A49,TARSKI:def
2;
        assume n < m;
         then <*W-bound D,E-bound D*>.n = W-bound D &
              <*W-bound D,E-bound D*>.m = E-bound D by A50,FINSEQ_1:61;
        hence <*W-bound D,E-bound D*>.n < <*W-bound D,E-bound D*>.m by Th33;
       end;
     then A51: <*W-bound D,E-bound D*> = Incr X_axis f by A43,A47,A48,GOBOARD2:
def 2;
    set Yf1 = <*N-bound D,N-bound D,S-bound D*>,
        Yf2 = <*S-bound D,N-bound D*>;
A52:  S-bound D < N-bound D by Th34;
    reconsider Yf = Yf1^Yf2 as FinSequence of REAL;
A53:len Yf1 = 3 & len Yf2 = 2 by FINSEQ_1:61,62;
    then A54: len Yf = 3+2 by FINSEQ_1:35;
      1 in dom Yf1 by A53,FINSEQ_3:27;
then A55: Yf.1 = Yf1.1 by FINSEQ_1:def 7 .= N-bound D by FINSEQ_1:62;
      2 in dom Yf1 by A53,FINSEQ_3:27;
then A56: Yf.2 = Yf1.2 by FINSEQ_1:def 7 .= N-bound D by FINSEQ_1:62;
      3 in dom Yf1 by A53,FINSEQ_3:27;
then A57: Yf.3 = Yf1.3 by FINSEQ_1:def 7 .= S-bound D by FINSEQ_1:62;
      1 in dom Yf2 by A53,FINSEQ_3:27;
then A58: Yf.(3+1) = Yf2.1 by A53,FINSEQ_1:def 7 .= S-bound D by FINSEQ_1:61;
      2 in dom Yf2 by A53,FINSEQ_3:27;
then A59: Yf.(3+2) = Yf2.2 by A53,FINSEQ_1:def 7 .= N-bound D by FINSEQ_1:61;
       now let n be Nat;
      assume n in dom Yf;
       then A60:    n <> 0 & n <= 5 by A54,FINSEQ_3:27;
      per cases by A60,CQC_THE1:6;
      suppose n = 1;
      hence Yf.n = (f/.n)`2 by A8,A55,PSCOMP_1:75;
      end;
      suppose n = 2;
      hence Yf.n = (f/.n)`2 by A9,A56,PSCOMP_1:77;
      end;
      suppose n = 3;
      hence Yf.n = (f/.n)`2 by A10,A57,PSCOMP_1:79;
      end;
      suppose n = 4;
      hence Yf.n = (f/.n)`2 by A11,A58,PSCOMP_1:73;
      end;
      suppose n = 5;
      hence Yf.n = (f/.n)`2 by A12,A59,PSCOMP_1:75;
     end;
     end;
     then A61:   Yf = Y_axis f by A2,A3,A54,GOBOARD1:def 4;
A62:    rng Yf1 = { N-bound D,N-bound D,S-bound D } by FINSEQ_2:148
           .= { S-bound D,N-bound D } by ENUMSET1:70;
        rng Yf2 = { S-bound D,N-bound D } by FINSEQ_2:147;
then A63:   rng Yf = { S-bound D,N-bound D } \/ { S-bound D,N-bound D }
                      by A62,FINSEQ_1:44
            .= { S-bound D,N-bound D };
      then A64:   rng <*S-bound D,N-bound D*> = rng Yf by FINSEQ_2:147;
A65:   len <*S-bound D,N-bound D*> = 2 by FINSEQ_1:61
              .= card rng Yf by A52,A63,CARD_2:76;
       <*S-bound D,N-bound D*> is increasing
       proof let n,m be Nat;
           len <*S-bound D,N-bound D*> = 2 by FINSEQ_1:61;
then A66:       dom <*S-bound D,N-bound D*> = { 1,2 } by FINSEQ_1:4,def 3;
        assume n in dom <*S-bound D,N-bound D*> &
               m in dom <*S-bound D,N-bound D*>;
         then A67:       (n = 1 or n = 2) & (m = 1 or m = 2) by A66,TARSKI:def
2;
        assume n < m;
         then <*S-bound D,N-bound D*>.n = S-bound D &
              <*S-bound D,N-bound D*>.m = N-bound D
            by A67,FINSEQ_1:61;
        hence <*S-bound D,N-bound D*>.n < <*S-bound D,N-bound D*>.m by Th34;
       end;
     then A68:   <*S-bound D,N-bound D*> = Incr Y_axis f by A61,A64,A65,
GOBOARD2:def 2;
     set S = (|[W-bound D,S-bound D]|,|[W-bound D,N-bound D]|)
           ][(|[E-bound D,S-bound D]|,|[E-bound D,N-bound D]|);
A69:  len S = 2 by MATRIX_2:3 .= len Incr X_axis f by A51,FINSEQ_1:61;
A70:  width S = 2 by MATRIX_2:3 .= len Incr Y_axis f by A68,FINSEQ_1:61;
       for n,m being Nat st [n,m] in Indices S
            holds S*(n,m) = |[(Incr X_axis f).n,(Incr Y_axis f).m]|
      proof let n,m be Nat;
       assume [n,m] in Indices S;
        then [n,m] in [:{ 1,2 },{ 1,2 }:] by FINSEQ_1:4,MATRIX_2:3;
        then A71:     [n,m] in {[1,1],[1,2],[2,1],[2,2]} by MCART_1:25;
A72:    <*S-bound D,N-bound D*>.1 = S-bound D &
       <*S-bound D,N-bound D*>.2 = N-bound D by FINSEQ_1:61;
       per cases by A71,ENUMSET1:18;
       suppose [n,m] = [1,1];
        then A73:       n = 1 & m = 1 by ZFMISC_1:33;
       hence S*(n,m) = |[W-bound D,S-bound D]| by MATRIX_2:6
          .= |[(Incr X_axis f).n,(Incr Y_axis f).m]|
          by A51,A68,A72,A73,FINSEQ_1:61;
       end;
       suppose [n,m] = [1,2];
        then A74:       n = 1 & m = 2 by ZFMISC_1:33;
       hence S*(n,m) = |[W-bound D,N-bound D]| by MATRIX_2:6
          .= |[(Incr X_axis f).n,(Incr Y_axis f).m]|
          by A51,A68,A72,A74,FINSEQ_1:61;
       end;
       suppose [n,m] = [2,1];
        then A75:       n = 2 & m = 1 by ZFMISC_1:33;
       hence S*(n,m) = |[E-bound D,S-bound D]| by MATRIX_2:6
            .= |[(Incr X_axis f).n,(Incr Y_axis f).m]|
            by A51,A68,A72,A75,FINSEQ_1:61;
       end;
       suppose [n,m] = [2,2];
        then A76:       n = 2 & m = 2 by ZFMISC_1:33;
       hence S*(n,m) = |[E-bound D,N-bound D]| by MATRIX_2:6
            .= |[(Incr X_axis f).n,(Incr Y_axis f).m]|
            by A51,A68,A72,A76,FINSEQ_1:61;
      end;
      end;
      then A77:   S = GoB(Incr X_axis f, Incr Y_axis f) by A69,A70,GOBOARD2:def
1
        .= GoB f by GOBOARD2:def 3;
A78: f/.1 = |[W-bound D,N-bound D]| by A8,PSCOMP_1:def 35
           .= (GoB f)*(1,2) by A77,MATRIX_2:6;
A79: f/.2 = |[E-bound D,N-bound D]| by A9,PSCOMP_1:def 36
           .= (GoB f)*(2,2) by A77,MATRIX_2:6;
A80: f/.3 = |[E-bound D,S-bound D]| by A10,PSCOMP_1:def 37
           .= (GoB f)*(2,1) by A77,MATRIX_2:6;
A81: f/.4 = |[W-bound D,S-bound D]| by A11,PSCOMP_1:def 34
           .= (GoB f)*(1,1) by A77,MATRIX_2:6;
  thus SpStSeq D is standard
   proof
   thus for k st k in dom f
    ex i,j st [i,j] in Indices GoB f & f/.k = (GoB f)*(i,j)
   proof let k;
    assume
A82:   k in dom f;
     then A83:    k >= 1 & k <= 5 by A2,A3,FINSEQ_3:27;
A84:    k <> 0 by A82,FINSEQ_3:27;
    per cases by A83,A84,CQC_THE1:6;
    suppose
A85:    k = 1;
     take 1,2;
     thus [1,2] in Indices GoB f by A77,MATRIX_2:4;
     thus f/.k = (GoB f)*(1,2) by A78,A85;
    end;
    suppose
A86:    k = 2;
     take 2,2;
     thus [2,2] in Indices GoB f by A77,MATRIX_2:4;
     thus f/.k = (GoB f)*(2,2) by A79,A86;
    end;
    suppose
A87:    k = 3;
     take 2,1;
     thus [2,1] in Indices GoB f by A77,MATRIX_2:4;
     thus f/.k = (GoB f)*(2,1) by A80,A87;
    end;
    suppose
A88:    k = 4;
     take 1,1;
     thus [1,1] in Indices GoB f by A77,MATRIX_2:4;
     thus f/.k = (GoB f)*(1,1) by A81,A88;
    end;
    suppose
A89:    k = 5;
     take 1,2;
     thus [1,2] in Indices GoB f by A77,MATRIX_2:4;
     thus f/.k = (GoB f)*(1,2) by A8,A12,A78,A89;
   end;
   end;

   let n be Nat such that
A90: n in dom f and
A91: n+1 in dom f;
   let m,k,i,j be Nat such that
A92: [m,k] in Indices GoB f and
A93: [i,j] in Indices GoB f and
A94: f/.n = (GoB f)*(m,k) and
A95: f/.(n+1) = (GoB f)*(i,j);
   A96:  n <> 0 by A90,FINSEQ_3:27;
      n+1 <= 4+1 by A2,A3,A91,FINSEQ_3:27;
    then A97: n <= 4 by REAL_1:53;
   per cases by A96,A97,CQC_THE1:5;
   suppose
A98:  n = 1;
      [1,2] in Indices GoB f by A77,MATRIX_2:4;
then A99:  m = 1 & k = 2 by A78,A92,A94,A98,GOBOARD1:21;
      [2,2] in Indices GoB f by A77,MATRIX_2:4;
then A100:  i = 1+1 & j = 2 by A79,A93,A95,A98,GOBOARD1:21;
    then abs(m-i) = 1 by A99,GOBOARD1:1;
   hence abs(m-i)+abs(k-j) = 1 by A99,A100,GOBOARD1:2;
   end;
   suppose
A101:  n = 2;
      [2,2] in Indices GoB f by A77,MATRIX_2:4;
then A102:  m = 2 & k = 1+1 by A79,A92,A94,A101,GOBOARD1:21;
      [2,1] in Indices GoB f by A77,MATRIX_2:4;
then A103:  i = 2 & j = 1 by A80,A93,A95,A101,GOBOARD1:21;
    then abs(k-j) = 1 by A102,GOBOARD1:1;
   hence abs(m-i)+abs(k-j) = 1 by A102,A103,GOBOARD1:2;
   end;
   suppose
A104:  n = 3;
      [2,1] in Indices GoB f by A77,MATRIX_2:4;
then A105:  m = 1+1 & k = 1 by A80,A92,A94,A104,GOBOARD1:21;
      [1,1] in Indices GoB f by A77,MATRIX_2:4;
then A106:  i = 1 & j = 1 by A81,A93,A95,A104,GOBOARD1:21;
    then abs(m-i) = 1 by A105,GOBOARD1:1;
   hence abs(m-i)+abs(k-j) = 1 by A105,A106,GOBOARD1:2;
   end;
   suppose
A107:  n = 4;
      [1,1] in Indices GoB f by A77,MATRIX_2:4;
then A108:  m = 1 & k = 1 by A81,A92,A94,A107,GOBOARD1:21;
      [1,2] in Indices GoB f by A77,MATRIX_2:4;
then A109:  i = 1 & j = 1+1 by A8,A12,A78,A93,A95,A107,GOBOARD1:21;
    then abs(k-j) = 1 by A108,GOBOARD1:1;
   hence abs(m-i)+abs(k-j) = 1 by A108,A109,GOBOARD1:2;
   end;
   end;
   end;
end;


theorem :: SPRECT_1:44
 L~SpStSeq D = [.W-bound D,E-bound D,S-bound D,N-bound D.];

:::: Special points of SpStSeq D (or C)

theorem :: SPRECT_1:45
 for T being non empty TopStruct, X being Subset of T,
     f be RealMap of T
 holds rng(f||X) = f.:X;

theorem :: SPRECT_1:46
 for T being non empty TopSpace, X being non empty compact Subset of T,
     f be continuous RealMap of T
 holds f.:X is bounded_below;

theorem :: SPRECT_1:47
 for T being non empty TopSpace, X being non empty compact Subset of T,
     f be continuous RealMap of T
 holds f.:X is bounded_above;

registration
 cluster non empty bounded_above bounded_below Subset of REAL;
  existence
  proof
    reconsider A = {0} as Subset of REAL;
   take A;
   thus A is non empty;
   thus A is bounded_above
    proof take 0; let t be real number;
     assume t in A;
     hence thesis by TARSKI:def 1;
    end;
   take 0; let t be real number;
   assume t in A;
   hence thesis by TARSKI:def 1;
  end;
end;


theorem :: SPRECT_1:48
 W-bound S = inf(proj1.:S);

theorem :: SPRECT_1:49
 S-bound S = inf(proj2.:S);

theorem :: SPRECT_1:50
 N-bound S = sup(proj2.:S);

theorem :: SPRECT_1:51
 E-bound S = sup(proj1.:S);

theorem :: SPRECT_1:52
 for A,B being non empty bounded_below Subset of REAL
  holds inf(A \/ B) = min(inf A,inf B);

theorem :: SPRECT_1:53
 for A,B being non empty bounded_above Subset of REAL
  holds sup(A \/ B) = max(sup A,sup B);

theorem :: SPRECT_1:54
 S = C1 \/ C2 implies W-bound S = min(W-bound C1, W-bound C2);

theorem :: SPRECT_1:55
 S = C1 \/ C2 implies S-bound S = min(S-bound C1, S-bound C2);

theorem :: SPRECT_1:56
 S = C1 \/ C2 implies N-bound S = max(N-bound C1, N-bound C2);

theorem :: SPRECT_1:57
 S = C1 \/ C2 implies E-bound S = max(E-bound C1, E-bound C2);

registration let p,q;
 cluster LSeg(p,q) -> compact;
 coherence;
end;


registration
 cluster {}REAL -> bounded;
 coherence
  proof
   thus {}REAL is bounded_below proof take 0; thus thesis; end;
   take 0; thus thesis;
  end;
end;


registration let r1,r2;
 cluster [.r1,r2.] -> bounded;
 coherence
  proof
   thus [.r1,r2.] is bounded_below
    proof
     take r1;
     thus thesis by TOPREAL5:1;
    end;
   take r2;
   thus thesis by TOPREAL5:1;
  end;
end;


registration
 cluster bounded -> bounded_below bounded_above Subset of REAL;
 coherence by SEQ_4:def 3;
 cluster bounded_below bounded_above -> bounded Subset of REAL;
 coherence by SEQ_4:def 3;
end;


canceled;

theorem :: SPRECT_1:59
 r1 <= r2 implies
  (t in [.r1,r2.] iff ex s1 st 0 <=s1 & s1 <= 1 & t = s1*r1 + (1-s1)*r2);

theorem :: SPRECT_1:60
 p`1 <= q`1 implies proj1.:LSeg(p,q) = [.p`1,q`1.];

theorem :: SPRECT_1:61
 p`2 <= q`2 implies proj2.:LSeg(p,q) = [.p`2,q`2.];

theorem :: SPRECT_1:62
 p`1 <= q`1 implies W-bound LSeg(p,q) = p`1;

theorem :: SPRECT_1:63
 p`2 <= q`2 implies S-bound LSeg(p,q) = p`2;

theorem :: SPRECT_1:64
 p`2 <= q`2 implies N-bound LSeg(p,q) = q`2;

theorem :: SPRECT_1:65
 p`1 <= q`1 implies E-bound LSeg(p,q) = q`1;

theorem :: SPRECT_1:66
 W-bound L~SpStSeq C = W-bound C;

theorem :: SPRECT_1:67
 S-bound L~SpStSeq C = S-bound C;

theorem :: SPRECT_1:68
 N-bound L~SpStSeq C = N-bound C;

theorem :: SPRECT_1:69
 E-bound L~SpStSeq C = E-bound C;

theorem :: SPRECT_1:70
  NW-corner L~SpStSeq C = NW-corner C;

theorem :: SPRECT_1:71
  NE-corner L~SpStSeq C = NE-corner C;

theorem :: SPRECT_1:72
  SW-corner L~SpStSeq C = SW-corner C;

theorem :: SPRECT_1:73
  SE-corner L~SpStSeq C = SE-corner C;

theorem :: SPRECT_1:74
 W-most L~SpStSeq C = LSeg(SW-corner C,NW-corner C);

theorem :: SPRECT_1:75
 N-most L~SpStSeq C = LSeg(NW-corner C,NE-corner C);

theorem :: SPRECT_1:76
 S-most L~SpStSeq C = LSeg(SW-corner C,SE-corner C);

theorem :: SPRECT_1:77
 E-most L~SpStSeq C = LSeg(SE-corner C,NE-corner C);

theorem :: SPRECT_1:78
 proj2.:LSeg(SW-corner C,NW-corner C) = [.S-bound C,N-bound C.];

theorem :: SPRECT_1:79
 proj1.:LSeg(NW-corner C,NE-corner C) = [.W-bound C,E-bound C.];

theorem :: SPRECT_1:80
 proj2.:LSeg(NE-corner C,SE-corner C) = [.S-bound C,N-bound C.];

theorem :: SPRECT_1:81
 proj1.:LSeg(SE-corner C,SW-corner C) = [.W-bound C,E-bound C.];

theorem :: SPRECT_1:82
 W-min L~SpStSeq C = SW-corner C;

theorem :: SPRECT_1:83
 W-max L~SpStSeq C = NW-corner C;

theorem :: SPRECT_1:84
 N-min L~SpStSeq C = NW-corner C;

theorem :: SPRECT_1:85
 N-max L~SpStSeq C = NE-corner C;

theorem :: SPRECT_1:86
 E-min L~SpStSeq C = SE-corner C;

theorem :: SPRECT_1:87
 E-max L~SpStSeq C = NE-corner C;

theorem :: SPRECT_1:88
 S-min L~SpStSeq C = SW-corner C;

theorem :: SPRECT_1:89
 S-max L~SpStSeq C = SE-corner C;

begin :: rectangular

definition let f be FinSequence of TOP-REAL 2;
 attr f is rectangular means
:: SPRECT_1:def 2
 ex D st f = SpStSeq D;
end;


registration let D;
 cluster SpStSeq D -> rectangular;
  coherence by Def2;
end;


registration
 cluster rectangular FinSequence of TOP-REAL 2;
 existence proof consider D; take SpStSeq D, D; thus thesis; end;
end;


reserve s for rectangular FinSequence of TOP-REAL 2;

theorem :: SPRECT_1:90
   len s = 5;

registration
 cluster rectangular -> non constant FinSequence of TOP-REAL 2;
 coherence
  proof let f be FinSequence of TOP-REAL 2;
   assume ex D st f = SpStSeq D;
   hence f is not constant;
  end;
end;


registration
 cluster rectangular ->
     standard special unfolded circular s.c.c.
       (non empty FinSequence of TOP-REAL 2);
 coherence
  proof let f be non empty FinSequence of TOP-REAL 2;
   assume ex D st f = SpStSeq D;
   hence thesis;
  end;
end;


:::: Special points of L~f, f - rectangular

theorem :: SPRECT_1:91
   s/.1 = N-min L~s & s/.1 = W-max L~s;

theorem :: SPRECT_1:92
   s/.2 = N-max L~s & s/.2 = E-max L~s;

theorem :: SPRECT_1:93
   s/.3 = S-max L~s & s/.3 = E-min L~s;

theorem :: SPRECT_1:94
   s/.4 = S-min L~s & s/.4 = W-min L~s;

begin :: Jordan

theorem :: SPRECT_1:95
  r1 < r2 & s1 < s2 implies [.r1,r2,s1,s2.] is Jordan;

registration let f be rectangular FinSequence of TOP-REAL 2;
 cluster L~f -> Jordan;
 coherence
  proof
    consider D such that
A1:   f = SpStSeq D by Def2;
A2:  L~f = [.W-bound D,E-bound D,S-bound D,N-bound D.] by A1,Th44;
      W-bound D < E-bound D & S-bound D < N-bound D by Th33,Th34;
   hence L~f is Jordan by A2,Th95;
  end;
end;


definition let S be Subset of TOP-REAL 2;
 redefine attr S is Jordan means
:: SPRECT_1:def 3
 S`<> {} &
 ex A1,A2 being Subset of TOP-REAL 2
  st S` = A1 \/ A2 & A1 misses A2 & (Cl A1) \ A1 = (Cl A2) \ A2 &
     A1 is_a_component_of S` & A2 is_a_component_of S`;
end;


theorem :: SPRECT_1:96
 for f being rectangular FinSequence of TOP-REAL 2
  holds LeftComp f misses RightComp f;

registration let f be non constant standard special_circular_sequence;
 cluster LeftComp f -> non empty;
 coherence
  proof
      len f > 4 by GOBOARD7:36;
    then 1+1 <= len f by AXIOMS:22;
then A1:  Int left_cell(f,1) <> {} by GOBOARD9:18;
      Int left_cell(f,1) c= LeftComp f by GOBOARD9:def 1;
   hence thesis by A1,XBOOLE_1:3;
  end;
 cluster RightComp f -> non empty;
 coherence
  proof
      len f > 4 by GOBOARD7:36;
    then 1+1 <= len f by AXIOMS:22;
then A2:  Int right_cell(f,1) <> {} by GOBOARD9:19;
      Int right_cell(f,1) c= RightComp f by GOBOARD9:def 2;
   hence thesis by A2,XBOOLE_1:3;
  end;
end;


theorem :: SPRECT_1:97
   for f being rectangular FinSequence of TOP-REAL 2
  holds LeftComp f <> RightComp f;
