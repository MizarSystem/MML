:: On the Calculus of Binary Arithmetics
::  by Shunichi Kobayashi
::
:: Received August 23, 2003
:: Copyright (c) 2003 Association of Mizar Users

environ

 vocabularies MARGREL1, ZF_LANG, BINARITH, PARTIT1, BINARI_5, NAT_1;
 notations SUBSET_1, XBOOLEAN, MARGREL1, BVFUNC_1;
 constructors XXREAL_0, BINARITH;
 registrations XBOOLEAN, MARGREL1;
 requirements ARITHM;


begin

definition
  let x, y be Element of BOOLEAN;
  redefine func x 'nand' y -> Element of BOOLEAN;
end;

definition
  let x, y be Element of BOOLEAN;
  redefine func x 'nor' y -> Element of BOOLEAN;
end;

definition
  let x, y be boolean set;
 redefine  canceled 2;

func x <=> y equals
:: BINARI_5:def 3
    'not' (x 'xor' y);
end;

definition
  let x, y be Element of BOOLEAN;
  redefine func x <=> y -> Element of BOOLEAN;
end;

 reserve x,y,z,w for boolean set;

theorem :: BINARI_5:1
  TRUE 'nand' x = 'not' x;

theorem :: BINARI_5:2
  FALSE 'nand' x = TRUE;

theorem :: BINARI_5:3
  x 'nand' x = 'not' x &
'not' (x 'nand' x) = x;

theorem :: BINARI_5:4
  'not' (x 'nand' y) = x '&' y;

theorem :: BINARI_5:5
  x 'nand' 'not' x = TRUE &
'not' (x 'nand' 'not' x) = FALSE;

theorem :: BINARI_5:6
  x 'nand' (y '&' z) = 'not' (x '&' y '&' z);

theorem :: BINARI_5:7
  x 'nand' (y '&' z) = (x '&' y) 'nand' z;

canceled 2;

theorem :: BINARI_5:10
  TRUE 'nor' x = FALSE;

theorem :: BINARI_5:11
  FALSE 'nor' x = 'not' x;

theorem :: BINARI_5:12
  x 'nor' x = 'not' x &
'not' (x 'nor' x) = x;

theorem :: BINARI_5:13
  'not' (x 'nor' y) = x 'or' y;

theorem :: BINARI_5:14
  x 'nor' 'not' x = FALSE &
'not' (x 'nor' 'not' x) = TRUE;

canceled;

theorem :: BINARI_5:16
  x 'nor' (y 'or' z) = 'not' (x 'or' y 'or' z);

theorem :: BINARI_5:17
  TRUE <=> x = x;

theorem :: BINARI_5:18
  FALSE <=> x = 'not' x;

theorem :: BINARI_5:19
  x <=> x = TRUE &
'not' (x <=> x) = FALSE;

theorem :: BINARI_5:20
  'not' (x <=> y) = x 'xor' y;

theorem :: BINARI_5:21
  x <=> 'not' x = FALSE &
'not' (x <=> 'not' x) = TRUE;

theorem :: BINARI_5:22
  x '<' (y => z) iff x '&' y '<' z;

theorem :: BINARI_5:23
 x <=> y = (x => y) '&' (y => x);

canceled 4;

theorem :: BINARI_5:28
 x => y = 'not' y => 'not' x;

theorem :: BINARI_5:29
  x <=> y = 'not' x <=> 'not' y;

canceled 4;

theorem :: BINARI_5:34
  x=TRUE & (x => y)=TRUE implies y=TRUE;

theorem :: BINARI_5:35
  y=TRUE implies (x => y)=TRUE;

theorem :: BINARI_5:36
  ('not' x)=TRUE implies (x => y)=TRUE;

canceled 14;

theorem :: BINARI_5:51
  z => (y => x)=TRUE implies y => (z => x)=TRUE;

theorem :: BINARI_5:52
  z => (y => x)=TRUE & y=TRUE implies z => x=TRUE;

theorem :: BINARI_5:53
  z => (y => x)=TRUE & y=TRUE & z = TRUE implies x=TRUE;
