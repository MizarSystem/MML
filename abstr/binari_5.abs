:: On the Calculus of Binary Arithmetics
::  by Shunichi Kobayashi
::
:: Received August 23, 2003
:: Copyright (c) 2003 Association of Mizar Users

environ

 vocabularies MARGREL1, ZF_LANG, BINARITH, PARTIT1, BINARI_5;
 notations SUBSET_1, XBOOLEAN, MARGREL1, BVFUNC_1;
 constructors XXREAL_0, BINARITH, BVFUNC_1;
 registrations MARGREL1, BINARITH, BVFUNC_1, XBOOLEAN;
 requirements SUBSET, BOOLE, NUMERALS, ARITHM, REAL;


begin

definition
 canceled;
  let x, y be Element of BOOLEAN;
  redefine func x 'nand' y -> Element of BOOLEAN;
end;

definition
 canceled;
  let x, y be Element of BOOLEAN;
  redefine func x 'nor' y -> Element of BOOLEAN;
end;

definition
  let x, y be boolean set;
 redefine func x <=> y equals
:: BINARI_5:def 3
   'not' (x 'xor' y);
end;

definition
  let x, y be Element of BOOLEAN;
  redefine func x <=> y -> Element of BOOLEAN;
end;

 reserve x,y,z,w for boolean set;

theorem :: BINARI_5:1
 TRUE 'nand' x = 'not' x;

theorem :: BINARI_5:2
 FALSE 'nand' x = TRUE;

theorem :: BINARI_5:3
 x 'nand' x = 'not' x &
'not' (x 'nand' x) = x;

theorem :: BINARI_5:4
 'not' (x 'nand' y) = x '&' y;

theorem :: BINARI_5:5
 x 'nand' 'not' x = TRUE &
'not' (x 'nand' 'not' x) = FALSE;

theorem :: BINARI_5:6
 x 'nand' (y '&' z) = 'not' (x '&' y '&' z);

theorem :: BINARI_5:7
 x 'nand' (y '&' z) = (x '&' y) 'nand' z;

theorem :: BINARI_5:8
 x 'nand' (y 'or' z) = 'not' (x '&' y) '&' 'not' (x '&' z);

theorem :: BINARI_5:9
 x 'nand' (y 'xor' z) = (x '&' y) <=> (x '&' z);

theorem :: BINARI_5:10
 TRUE 'nor' x = FALSE;

theorem :: BINARI_5:11
 FALSE 'nor' x = 'not' x;

theorem :: BINARI_5:12
 x 'nor' x = 'not' x &
'not' (x 'nor' x) = x;

theorem :: BINARI_5:13
 'not' (x 'nor' y) = x 'or' y;

theorem :: BINARI_5:14
 x 'nor' 'not' x = FALSE &
'not' (x 'nor' 'not' x) = TRUE;

theorem :: BINARI_5:15
 x 'nor' (y '&' z) = 'not' (x 'or' y) 'or' 'not' (x 'or' z);

theorem :: BINARI_5:16
 x 'nor' (y 'or' z) = 'not' (x 'or' y 'or' z);

theorem :: BINARI_5:17
 TRUE <=> x = x;

theorem :: BINARI_5:18
 FALSE <=> x = 'not' x;

theorem :: BINARI_5:19
 x <=> x = TRUE &
'not' (x <=> x) = FALSE;

theorem :: BINARI_5:20
 'not' (x <=> y) = x 'xor' y;

theorem :: BINARI_5:21
 x <=> 'not' x = FALSE &
'not' (x <=> 'not' x) = TRUE;

theorem :: BINARI_5:22
 x '<' (y => z) iff x '&' y '<' z;

theorem :: BINARI_5:23
x <=> y = (x => y) '&' (y => x);

theorem :: BINARI_5:24
x <=> y = TRUE iff (x => y) = TRUE & (y => x) = TRUE;

theorem :: BINARI_5:25
(x => y)=TRUE & (y => x)=TRUE implies x = y;

theorem :: BINARI_5:26
(x => y)=TRUE & (y => z)=TRUE implies (x => z)=TRUE;

theorem :: BINARI_5:27
 (x <=> y)=TRUE & (y <=> z)=TRUE implies (x <=> z)=TRUE;

theorem :: BINARI_5:28
x => y = 'not' y => 'not' x;

theorem :: BINARI_5:29
 x <=> y = 'not' x <=> 'not' y;

theorem :: BINARI_5:30
 (x <=> y)=TRUE & (z <=> w)=TRUE implies ((x '&' z) <=> (y '&' w))=TRUE;

theorem :: BINARI_5:31
 (x <=> y)=TRUE & (z <=> w)=TRUE implies
(x => z) <=> (y => w)=TRUE;

theorem :: BINARI_5:32
 (x <=> y)=TRUE & (z <=> w)=TRUE implies
(x 'or' z) <=> (y 'or' w)=TRUE;

theorem :: BINARI_5:33
 (x <=> y)=TRUE & (z <=> w)=TRUE implies
((x <=> z) <=> (y <=> w))=TRUE;

theorem :: BINARI_5:34
 x=TRUE & (x => y)=TRUE implies y=TRUE;

theorem :: BINARI_5:35
 y=TRUE implies (x => y)=TRUE;

theorem :: BINARI_5:36
 ('not' x)=TRUE implies (x => y)=TRUE;

theorem :: BINARI_5:37
 x => x=TRUE;

theorem :: BINARI_5:38
 (x => y)=TRUE & (x => 'not' y)=TRUE implies
'not' x=TRUE;

theorem :: BINARI_5:39
 ('not' x => x) => x = TRUE;

theorem :: BINARI_5:40
 (x => y) => ('not' (y '&' z) => 'not' (x '&' z)) = TRUE;

theorem :: BINARI_5:41
 (x => y) => ((y => z) => (x => z)) = TRUE;

theorem :: BINARI_5:42
 (x => y)=TRUE implies ((y => z) => (x => z)) = TRUE;

theorem :: BINARI_5:43
 y => (x => y) = TRUE;

theorem :: BINARI_5:44
 ((x => y) => z) => (y => z) = TRUE;

theorem :: BINARI_5:45
 y => ((y => x) => x) = TRUE;

theorem :: BINARI_5:46
 (z => (y => x)) => (y => (z => x)) = TRUE;

theorem :: BINARI_5:47
 (y => z) => ((x => y) => (x => z)) = TRUE;

theorem :: BINARI_5:48
 (y => (y => z)) => (y => z) = TRUE;

theorem :: BINARI_5:49
 (x => (y => z)) => ((x => y) => (x => z)) = TRUE;

theorem :: BINARI_5:50
 x=TRUE implies (x => y) => y=TRUE;

theorem :: BINARI_5:51
 z => (y => x)=TRUE implies y => (z => x)=TRUE;

theorem :: BINARI_5:52
 z => (y => x)=TRUE & y=TRUE implies z => x=TRUE;

theorem :: BINARI_5:53
 z => (y => x)=TRUE & y=TRUE & z = TRUE implies x=TRUE;

theorem :: BINARI_5:54
 y => (y => z)=TRUE implies y => z = TRUE;

theorem :: BINARI_5:55
 (x => (y => z)) = TRUE implies
(x => y) => (x => z) = TRUE;
