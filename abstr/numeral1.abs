:: On the Representation of Natural Numbers in Positional Numeral Systems
::  by Adam Naumowicz
::
:: Received December 31, 2006
:: Copyright (c) 2006 Association of Mizar Users

environ

 vocabularies BOOLE, NUMERAL1, ARYTM, AFINSQ_1, FUNCT_1, FINSEQ_1, ARYTM_1,
      RELAT_1, RLVECT_1, ALGSEQ_1, GROUP_1, NAT_1, MONOID_0, FINSOP_1, SEQ_1,
      SERIES_1, PREPOWER, POWER, ARYTM_3;
 notations TARSKI, XBOOLE_0, SUBSET_1, RELAT_1, FUNCT_1, RELSET_1, BINOP_1,
      NUMBERS, XCMPLX_0, XXREAL_0, NAT_1, NAT_D, BINOP_2, VALUED_1, SEQ_1,
      NEWTON, PREPOWER, POWER, SERIES_1, STIRL2_1, FUNCT_2, RECDEF_1, AFINSQ_1;
 constructors BINOP_1, SETWISEO, XXREAL_0, REAL_1, NAT_1, NAT_D, BINOP_2,
      SEQ_1, NEWTON, PREPOWER, SERIES_1, STIRL2_1, VALUED_1, PARTFUN1,
      RECDEF_1;
 registrations XBOOLE_0, RELAT_1, FUNCT_1, ORDINAL1, NUMBERS, XXREAL_0,
      XREAL_0, NAT_1, INT_1, BINOP_2, MEMBERED, NEWTON, RFINSEQ, AFINSQ_1,
      CARD_1, VALUED_1, FUNCT_2, POWER;
 requirements BOOLE, SUBSET, NUMERALS, ARITHM, REAL;


begin

theorem :: NUMERAL1:1
  for d,e being XFinSequence of NAT holds Sum(d^e)=Sum(d)+Sum(e);

theorem :: NUMERAL1:2
  for S being Real_Sequence, d being XFinSequence of NAT, n being Nat
  st d=S|(n+1) holds Sum(d)=Partial_Sums(S).n;

theorem :: NUMERAL1:3
  for k,l,m being Nat holds (k(#)(l GeoSeq))|m is XFinSequence of NAT;

theorem :: NUMERAL1:4
  for d,e being XFinSequence of NAT st len d >= 1 & len d = len e &
  for i being Nat st i in dom d holds d.i<=e.i holds Sum d <= Sum e;

theorem :: NUMERAL1:5
  for d being XFinSequence of NAT, n being Nat st
  for i being Nat st i in dom d holds n divides d.i holds n divides Sum d;

theorem :: NUMERAL1:6
  for d,e being XFinSequence of NAT, n being Nat st dom d = dom e &
  for i being Nat st i in dom d holds e.i = d.i mod n
  holds Sum d mod n = Sum e mod n;

begin :: Representation of numbers in the base-$b$ numeral system

definition
  let d be XFinSequence of NAT;
  let b be Nat;
  func value(d,b) -> Nat means
:: NUMERAL1:def 1

  ex d' being XFinSequence of NAT st (dom d' = dom d &
  for i being Nat st i in dom d' holds d'.i = (d.i)*(b|^i)) & it = Sum d';
end;

definition
  let n,b be Nat;
  assume
 b>1;
  func digits(n,b) -> XFinSequence of NAT means
:: NUMERAL1:def 2

  value(it,b)=n & it.(len(it)-1) <> 0 & for i being Nat st i in dom it holds
  0 <= it.i & it.i < b if n <> 0 otherwise it = <%0%>;
end;

theorem :: NUMERAL1:7
  for n,b being Nat st b > 1 holds len digits(n,b) >= 1;

theorem :: NUMERAL1:8
  for n,b being Nat st b > 1 holds value(digits(n,b),b)=n;

begin :: Selected divisibility criteria

theorem :: NUMERAL1:9
  for n,k being Nat st k=10|^n - 1 holds 9 divides k;

theorem :: NUMERAL1:10
  for n,b being Nat st b>1 holds b divides n iff digits(n,b).0 = 0;

theorem :: NUMERAL1:11
  for n being Nat holds 2 divides n iff 2 divides digits(n,10).0;

theorem :: NUMERAL1:12
  for n being Nat holds 3 divides n iff 3 divides Sum digits(n,10);

theorem :: NUMERAL1:13
  for n being Nat holds 5 divides n iff 5 divides digits(n,10).0;

