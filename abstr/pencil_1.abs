:: On Segre's Product of Partial Line Spaces
::  by Adam Naumowicz
::
:: Received May 29, 2000
:: Copyright (c) 2000 Association of Mizar Users

environ

 vocabulary FUNCT_1, CARD_3, ZF_REFLE, RELAT_1, BOOLE, CARD_1, REALSET1,
      PRE_TOPC, AMI_1, VECTSP_1, RELAT_2, FINSEQ_1, FINSET_1, SETFAM_1,
      PRALG_1, PBOOLE, FUNCOP_1, WAYBEL_3, FUNCT_4, RLVECT_2, MSUALG_2,
      INTEGRA1, SUBSET_1, ARYTM_1, PENCIL_1;
 notation TARSKI, XBOOLE_0, ENUMSET1, ZFMISC_1, SUBSET_1, XCMPLX_0, XREAL_0,
      SETFAM_1, NAT_1, FINSET_1, RELAT_1, STRUCT_0, FUNCT_1, REALSET1,
      WAYBEL_3, CARD_1, FINSEQ_1, CARD_3, PRE_TOPC, PBOOLE, MSUALG_1, MSUALG_2,
      PZFMISC1, PRE_CIRC, PRALG_1, POLYNOM1;
 constructors PRE_CIRC, WAYBEL_3, ENUMSET1, MSUALG_2, POLYNOM1, PZFMISC1,
      CQC_LANG;
 clusters STRUCT_0, RELSET_1, SUBSET_1, FINSET_1, YELLOW_6, PRALG_1, TEX_1,
      TEX_2, YELLOW13, REALSET1, PZFMISC1, XREAL_0, ARYTM_3, XBOOLE_0;
 requirements REAL, BOOLE, SUBSET, NUMERALS, ARITHM;


begin

theorem :: PENCIL_1:1
for f,g being Function st product f = product g holds
f is non-empty implies g is non-empty;

theorem :: PENCIL_1:2
for X being set holds 2 c= Card X iff ex x,y being set st
x in X & y in X & x<>y;

theorem :: PENCIL_1:3
for X being set st 2 c= Card X
for x being set ex y being set st y in X & x<>y;

theorem :: PENCIL_1:4
for X being set holds 2 c= Card X iff X is non trivial;

theorem :: PENCIL_1:5
for X being set holds 3 c= Card X iff ex x,y,z being set st
x in X & y in X & z in X & x<>y & x<>z & y<>z;

theorem :: PENCIL_1:6
for X being set st 3 c= Card X
for x,y being set ex z being set st z in X & x<>z & y<>z;

begin

definition
let S be TopStruct;
 mode Block of S is Element of the topology of S;
end;


definition
 let S be TopStruct;
 let x,y be Point of S;
pred x,y are_collinear means
:: PENCIL_1:def 1
 x=y or ex l being Block of S st {x,y} c= l;
end;


definition
let S be TopStruct;
let T be Subset of S;
attr T is closed_under_lines means
:: PENCIL_1:def 2
for l being Block of S st 2 c= Card (l /\ T) holds l c= T;
attr T is strong means
:: PENCIL_1:def 3
for x,y being Point of S st x in T & y in T holds x,y are_collinear;
end;


definition
let S be TopStruct;
attr S is void means
:: PENCIL_1:def 4
 the topology of S is empty;
attr S is degenerated means
:: PENCIL_1:def 5
 the carrier of S is Block of S;
attr S is with_non_trivial_blocks means
:: PENCIL_1:def 6
 for k being Block of S holds 2 c= Card k;
attr S is identifying_close_blocks means
:: PENCIL_1:def 7
 for k,l being Block of S st 2 c= Card(k /\ l) holds k=l;
attr S is truly-partial means
:: PENCIL_1:def 8
 ex x,y being Point of S st not x,y are_collinear;
attr S is without_isolated_points means
:: PENCIL_1:def 9
 for x being Point of S ex l being Block of S st x in l;
attr S is connected means
:: PENCIL_1:def 10
   for x,y being Point of S ex f being FinSequence of the carrier of S st
 x=f.1 & y=f.(len f) & for i being Nat st 1 <= i & i < len f
 for a,b being Point of S st a = f.i & b = f.(i+1)
 holds a,b are_collinear;
attr S is strongly_connected means
:: PENCIL_1:def 11
 for x being Point of S
 for X being Subset of S st X is closed_under_lines strong
 ex f being FinSequence of bool the carrier of S st
 X = f.1 & x in f.(len f) &
 (for W being Subset of S st W in rng f holds
 W is closed_under_lines strong) &
 for i being Nat st 1 <= i & i < len f holds
 2 c= Card((f.i) /\ (f.(i+1)));
end;


theorem :: PENCIL_1:7
for X being non empty set st 3 c= Card X
for S being TopStruct st the carrier of S = X &
the topology of S = {L where L is Subset of X : 2 = Card L} holds
S is non empty non void
non degenerated non truly-partial with_non_trivial_blocks
identifying_close_blocks without_isolated_points;

theorem :: PENCIL_1:8
for X being non empty set st 3 c= Card X
for K being Subset of X st Card K = 2
for S being TopStruct st the carrier of S = X &
the topology of S = {L where L is Subset of X : 2 = Card L} \ {K} holds
S is non empty non void
non degenerated truly-partial with_non_trivial_blocks identifying_close_blocks
without_isolated_points;

registration
cluster strict non empty non void non degenerated non truly-partial
        with_non_trivial_blocks identifying_close_blocks
        without_isolated_points TopStruct;
existence by Lm1;
cluster strict non empty non void non degenerated truly-partial
        with_non_trivial_blocks identifying_close_blocks
        without_isolated_points TopStruct;
existence by Lm2;
end;


registration
let S be non void TopStruct;
cluster the topology of S -> non empty;
coherence by Def4;
end;


definition
 let S be without_isolated_points TopStruct;
 let x,y be Point of S;
redefine pred x,y are_collinear means
:: PENCIL_1:def 12
   ex l being Block of S st {x,y} c= l;
end;


definition
mode PLS is non empty non void non degenerated with_non_trivial_blocks
identifying_close_blocks TopStruct;
end;


definition let F be Relation;
attr F is TopStruct-yielding means
:: PENCIL_1:def 13
 for x being set st x in rng F holds x is TopStruct;
end;


registration
 cluster TopStruct-yielding -> 1-sorted-yielding Function;
coherence
  proof let F be Function such that
A1:  F is TopStruct-yielding;
   let x be set;
   assume x in dom F;
   then F.x in rng F by FUNCT_1:def 5;
   hence F.x is 1-sorted by A1,Def13;
  end;
end;


registration let I be set;
 cluster TopStruct-yielding ManySortedSet of I;
existence
  proof consider R being TopStruct;
   take I --> R;
   let v be set;
A1:  rng(I-->R) c= {R} by FUNCOP_1:19;
   assume v in rng(I-->R);
   hence thesis by A1,TARSKI:def 1;
  end;
end;


registration
cluster TopStruct-yielding Function;
existence
 proof
  consider I being set;
  consider F being TopStruct-yielding ManySortedSet of I;
  take F;
  thus thesis;
 end;
end;


definition
let F be Relation;
attr F is non-void-yielding means
:: PENCIL_1:def 14
for S being TopStruct st S in rng F holds S is non void;
end;


definition
let F be TopStruct-yielding Function;
redefine attr F is non-void-yielding means
:: PENCIL_1:def 15
  for i being set st i in rng F holds i is non void TopStruct;
end;


definition
let F be Relation;
attr F is trivial-yielding means
:: PENCIL_1:def 16
for S being set st S in rng F holds S is trivial;
end;


definition
let F be Relation;
attr F is non-Trivial-yielding means
:: PENCIL_1:def 17
for S being 1-sorted st S in rng F holds S is non trivial;
end;


registration
cluster non-Trivial-yielding -> non-Empty Relation;
coherence
 proof
  let F be Relation such that A1: F is non-Trivial-yielding;
  let i be 1-sorted;
  assume i in rng F;
  then i is non trivial 1-sorted by A1,Def17;
  hence thesis;
 end;
end;


definition
let F be 1-sorted-yielding Function;
redefine attr F is non-Trivial-yielding means
:: PENCIL_1:def 18
  for i being set st i in rng F holds i is non trivial 1-sorted;
end;


definition let I be non empty set;
           let A be TopStruct-yielding ManySortedSet of I;
           let j be Element of I;
 redefine func A.j -> TopStruct;
end;


definition let F be Relation;
attr F is PLS-yielding means
:: PENCIL_1:def 19
 for x being set st x in rng F holds x is PLS;
end;


registration
 cluster PLS-yielding -> non-Empty TopStruct-yielding Function;
coherence
 proof
  let f be Function such that A1: f is PLS-yielding;
  thus f is non-Empty
   proof
    let S be 1-sorted;
    assume S in rng f;
    hence thesis by A1,Def19;
   end;
  let x be set; assume x in rng f;
  hence thesis by A1,Def19;
 end;
 cluster PLS-yielding -> non-void-yielding (TopStruct-yielding Function);
coherence
 proof
  let f be TopStruct-yielding Function such that A2: f is PLS-yielding;
    let x be set; assume x in rng f;
    hence x is non void TopStruct by A2,Def19;
 end;
 cluster PLS-yielding -> non-Trivial-yielding (TopStruct-yielding Function);
coherence
 proof
  let f be TopStruct-yielding Function such that A3: f is PLS-yielding;
    let x be set; assume x in rng f;
    then reconsider S1=x as with_non_trivial_blocks non void non empty
    TopStruct by A3,Def19;
    consider s being set such that
A4:  s in the topology of S1 by XBOOLE_0:def 1;
    reconsider s as Block of S1 by A4;
      2 c= Card s by Def6; then consider s1,s2 being set such that
A5: s1 in s & s2 in s & s1 <> s2 by Th2;
    thus thesis by A4,A5,REALSET1:def 20;
 end;
end;


registration let I be set;
 cluster PLS-yielding ManySortedSet of I;
existence
  proof consider R being PLS;
   take I --> R;
   let v be set;
A1:  rng(I-->R) c= {R} by FUNCOP_1:19;
   assume v in rng(I-->R);
   hence thesis by A1,TARSKI:def 1;
  end;
end;


definition let I be non empty set;
           let A be PLS-yielding ManySortedSet of I;
           let j be Element of I;
 redefine func A.j -> PLS;
end;


definition
let I be set;
let A be ManySortedSet of I;
attr A is Segre-like means
:: PENCIL_1:def 20
ex i being Element of I st for j being Element of I st i<>j
holds A.j is non empty trivial;
end;


registration
let I be set;
let A be ManySortedSet of I;
cluster {A} -> trivial-yielding;
coherence
 proof
  let a be set;
  assume a in rng {A}; then consider i being set such that
A1: i in dom {A} & a = {A}.i by FUNCT_1:def 5;
    dom {A} = I by PBOOLE:def 3;
  then a = {A.i} by A1,PZFMISC1:def 1;
  hence thesis;
 end;
end;


theorem :: PENCIL_1:9
  for I being non empty set
for A being ManySortedSet of I
for i being Element of I
for S being non trivial set holds
A+*(i,S) is non trivial-yielding;

registration
let I be non empty set;
let A be ManySortedSet of I;
cluster {A} -> Segre-like;
coherence
 proof
  consider i being Element of I;
  take i;
  let j be Element of I such that i<>j;
    {A}.j = {A.j} by PZFMISC1:def 1;
  hence thesis;
 end;
end;


theorem :: PENCIL_1:10
  for I being non empty set
for A being ManySortedSet of I
for i,S be set holds
{A}+*(i,S) is Segre-like;

theorem :: PENCIL_1:11
for I being non empty set
for A being non-Empty (1-sorted-yielding ManySortedSet of I)
for B being Element of Carrier A holds
{B} is ManySortedSubset of Carrier A;

registration
let I be non empty set;
let A be non-Empty (1-sorted-yielding ManySortedSet of I);
cluster Segre-like trivial-yielding non-empty ManySortedSubset of Carrier A;
existence
 proof
  consider B being Element of Carrier A;
  reconsider C={B} as ManySortedSubset of Carrier A by Th11;
  take C;
  thus C is Segre-like trivial-yielding non-empty;
 end;
end;


registration
let I be non empty set;
let A be non-Trivial-yielding (1-sorted-yielding ManySortedSet of I);
cluster Segre-like non trivial-yielding non-empty
ManySortedSubset of Carrier A;
existence
 proof
  consider i1 being Element of I;
  consider B being Element of Carrier A;
  consider R being 1-sorted such that
A1: R=A.i1 & the carrier of R = (Carrier A).i1 by PRALG_1:def 13;
    B.i1 is Element of (Carrier A).i1 by MSUALG_1:def 1;
  then reconsider b1=B.i1 as Element of A.i1 by A1;
    dom A = I by PBOOLE:def 3;
  then A.i1 in rng A by FUNCT_1:def 5;
  then A.i1 is non trivial by Def17;
  then reconsider Ai1=the carrier of A.i1 as non trivial set by REALSET1:def 13
;
  consider x1,x2 being Element of Ai1 such that
A2: x1 <> x2 by YELLOW_8:def 1;
    2 c= Card the carrier of (A.i1) by A2,Th2;
  then consider b2 being set such that
A3: b2 in the carrier of (A.i1) & b1 <> b2 by Th3;
  reconsider b2 as Element of A.i1 by A3;
  reconsider B as ManySortedSet of I;
  set B1=B+*(i1,b2);
A4: for i being set st i in I holds B1.i is Element of (Carrier A).i
   proof
    let i be set such that A5: i in I;
    per cases;
    suppose i <> i1;
    then B1.i = B.i by FUNCT_7:34;
    hence thesis by A5,MSUALG_1:def 1;
    end;
    suppose A6: i = i1;
    then i1 in dom B by A5,PBOOLE:def 3;
    hence thesis by A1,A6,FUNCT_7:33;
   end;
   end;
    {B,B1} c= Carrier A
   proof
    let i be set; assume A7: i in I;
    then reconsider j=i as Element of I;
      j in dom A by A7,PBOOLE:def 3;
    then A.j in rng A by FUNCT_1:def 5;
    then A.j is non empty by YELLOW_6:def 4;
    then A8: the carrier of A.j is non empty by STRUCT_0:def 1;
      B.j is Element of (Carrier A).j &
    B1.j is Element of (Carrier A).j by A4,MSUALG_1:def 1;
    then B.j is Element of A.j &
    B1.j is Element of A.j by YELLOW_6:9;
    then {B.j,B1.j} c= the carrier of A.j by A8,ZFMISC_1:38;
    then {B,B1}.j c= the carrier of A.j by PZFMISC1:def 2;
    hence thesis by YELLOW_6:9;
   end;
  then reconsider C = {B,B1} as
  ManySortedSubset of Carrier A by MSUALG_2:def 1;
  take C;
  thus C is Segre-like
   proof
    take i1;
    let j be Element of I;
    assume i1<>j;
    then B.j = B1.j by FUNCT_7:34;
    then C.j = {B.j,B.j} by PZFMISC1:def 2
    .= {B.j} by ENUMSET1:69;
    hence thesis;
   end;
     dom C = I by PBOOLE:def 3;
then A9: C.i1 in rng C by FUNCT_1:def 5;
    dom B = I by PBOOLE:def 3;
  then B1.i1 = b2 by FUNCT_7:33;
  then A10: C.i1 = {b1,b2} by PZFMISC1:def 2;
    now assume C.i1 is trivial;
  then C.i1 is empty or ex x being set st C.i1 = {x} by REALSET1:def 12;
  hence contradiction by A3,A10,ZFMISC_1:9; end;
  hence C is non trivial-yielding by A9,Def16;
  thus C is non-empty;
 end;
end;


registration
let I be non empty set;
cluster Segre-like non trivial-yielding ManySortedSet of I;
existence
 proof
  consider i being Element of I;
  consider B being ManySortedSet of I;
  take C={B}+*(i,{0,1});
  thus C is Segre-like
   proof
    take i;
    let j be Element of I;
      j in I; then A1: j in dom {B} by PBOOLE:def 3; assume j<>i;
then A2: C.j = {B}.j by FUNCT_7:34;
    then C.j in rng {B} by A1,FUNCT_1:def 5;
    hence C.j is non empty trivial by A2,Def16;
   end;
  thus C is non trivial-yielding
   proof
    take S = C.i;
      dom C = I by PBOOLE:def 3;
    hence S in rng C by FUNCT_1:def 5;
      dom {B} = I by PBOOLE:def 3;
    then A3: C.i = {0,1} by FUNCT_7:33;
      0 in {0,1} & 1 in {0,1} by TARSKI:def 2;
    then 2 c= Card {0,1} by Th2;
    hence S is non trivial by A3,Th4;
   end;
 end;
end;


definition
let I be non empty set;
let B be Segre-like non trivial-yielding ManySortedSet of I;
func indx(B) -> Element of I means
:: PENCIL_1:def 21
B.it is non trivial;
end;


theorem :: PENCIL_1:12
for I being non empty set
for A being Segre-like non trivial-yielding ManySortedSet of I
for i being Element of I st i <> indx(A) holds A.i is non empty trivial;

registration
let I be non empty set;
cluster Segre-like non trivial-yielding -> non-empty ManySortedSet of I;
coherence
 proof
  let f be ManySortedSet of I;
  assume f is Segre-like non trivial-yielding;
  then reconsider g=f as Segre-like non trivial-yielding ManySortedSet of I;
    now assume {} in rng g; then consider i being set such that
A1: i in dom f & g.i = {} by FUNCT_1:def 5;
  reconsider i as Element of I by A1,PBOOLE:def 3;
  per cases; suppose i=indx(g);
  then g.i is non trivial by Def21;
  hence contradiction by A1,REALSET1:def 12;
  end;
  suppose i <> indx(g);
  hence contradiction by A1,Th12; end;
                                  end;
  hence f is non-empty by RELAT_1:def 9;
 end;
end;


theorem :: PENCIL_1:13
for I being non empty set
for A being ManySortedSet of I holds
2 c= Card (product A) iff A is non-empty non trivial-yielding;

registration
let I be non empty set;
let B be Segre-like non trivial-yielding ManySortedSet of I;
cluster product B -> non trivial;
coherence
 proof
     consider f being set such that
A1:   f in product B by XBOOLE_0:def 1;
     consider g being Function such that
A2:   g=f & dom g = dom B & for x being set st x in dom B
     holds g.x in B.x by A1,CARD_3:def 5;
       dom g = I by A2,PBOOLE:def 3;
     then reconsider f as ManySortedSet of I by A2,PBOOLE:def 3;
       B.indx(B) is non trivial by Def21;
     then 2 c= Card (B.indx(B)) by Th4; then consider y being set such that
A3:   y in B.indx(B) & y <> f.indx(B) by Th3;
     set l=f+*(indx(B),y);
       dom f=I by PBOOLE:def 3;
     then A4: l.indx(B) = y by FUNCT_7:33;
A5:  dom l = I by PBOOLE:def 3 .= dom B by PBOOLE:def 3;
       for x being set st x in dom B holds l.x in B.x
      proof
       let x be set; assume A6: x in dom B; then x in I by PBOOLE:def 3;
       then A7: x in dom f by PBOOLE:def 3;
       per cases;
       suppose x=indx(B);
       hence thesis by A3,A7,FUNCT_7:33;
       end;
       suppose x<>indx(B);
       then l.x = f.x by FUNCT_7:34;
       hence thesis by A2,A6;
      end;
      end;
     then l in product B by A5,CARD_3:def 5;
     then 2 c= Card product B by A1,A3,A4,Th2;
  hence product B is non trivial by Th4;
 end;
end;


begin

definition
let I be non empty set;
let A be non-Empty (TopStruct-yielding ManySortedSet of I);
func Segre_Blocks(A) -> Subset-Family of product Carrier A means
:: PENCIL_1:def 22
for x being set holds x in it iff
ex B being Segre-like ManySortedSubset of Carrier A st
x = product B & ex i being Element of I st B.i is Block of A.i;
end;


definition
let I be non empty set;
let A be non-Empty (TopStruct-yielding ManySortedSet of I);
func Segre_Product A -> non empty TopStruct equals
:: PENCIL_1:def 23
TopStruct(#product Carrier A, Segre_Blocks A#);
end;


theorem :: PENCIL_1:14
for I being non empty set
for A be non-Empty (TopStruct-yielding ManySortedSet of I)
for x being Point of Segre_Product A holds x is ManySortedSet of I;

theorem :: PENCIL_1:15
for I being non empty set
for A being non-Empty (TopStruct-yielding ManySortedSet of I)
st ex i being Element of I st A.i is non void
holds Segre_Product A is non void;

theorem :: PENCIL_1:16
for I being non empty set
for A being non-Empty (TopStruct-yielding ManySortedSet of I)
st for i being Element of I holds A.i is non degenerated &
ex i being Element of I st A.i is non void
holds Segre_Product A is non degenerated;

theorem :: PENCIL_1:17
for I being non empty set
for A being non-Empty (TopStruct-yielding ManySortedSet of I)
st for i being Element of I holds A.i is with_non_trivial_blocks &
ex i being Element of I st A.i is non void
holds Segre_Product A is with_non_trivial_blocks;

theorem :: PENCIL_1:18
for I being non empty set
for A being non-Empty (TopStruct-yielding ManySortedSet of I)
st for i being Element of I holds A.i is
identifying_close_blocks with_non_trivial_blocks &
ex i being Element of I st A.i is non void
holds Segre_Product A is identifying_close_blocks;

definition
let I be non empty set;
let A be PLS-yielding ManySortedSet of I;
redefine func Segre_Product A -> PLS;
end;


theorem :: PENCIL_1:19
  for T being TopStruct
for S being Subset of T holds
S is trivial implies S is strong closed_under_lines;

theorem :: PENCIL_1:20
 for S being identifying_close_blocks TopStruct, l being Block of S
 for L being Subset of S st L=l holds
 L is closed_under_lines;

theorem :: PENCIL_1:21
 for S being TopStruct, l being Block of S
 for L being Subset of S st L=l holds L is strong;

theorem :: PENCIL_1:22
   for S being non void TopStruct holds [#]S is closed_under_lines;

theorem :: PENCIL_1:23
for I being non empty set
for A being Segre-like non trivial-yielding ManySortedSet of I
for x,y being ManySortedSet of I st x in product A & y in product A
for i being set st i <> indx(A) holds x.i = y.i;

theorem :: PENCIL_1:24
for I being non empty set
for A being PLS-yielding ManySortedSet of I
for x being set holds x is Block of Segre_Product A iff
ex L being Segre-like non trivial-yielding ManySortedSubset of Carrier A st
x = product L & L.indx(L) is Block of A.indx(L);

theorem :: PENCIL_1:25
for I being non empty set
for A being PLS-yielding ManySortedSet of I
for P being ManySortedSet of I st P is Point of Segre_Product A
for i being Element of I
for p being Point of A.i holds
P+*(i,p) is Point of Segre_Product A;

theorem :: PENCIL_1:26
for I being non empty set
for A,B being Segre-like non trivial-yielding ManySortedSet of I st
2 c= Card ((product A) /\ (product B)) holds indx(A) = indx(B) &
for i being set st i <> indx(A) holds A.i = B.i;

theorem :: PENCIL_1:27
for I being non empty set
for A being Segre-like non trivial-yielding ManySortedSet of I
for N being non trivial set holds
A+*(indx(A),N) is Segre-like non trivial-yielding;

theorem :: PENCIL_1:28
  for S being non empty non void identifying_close_blocks
without_isolated_points
TopStruct holds S is strongly_connected implies S is connected;

theorem :: PENCIL_1:29
  for I being non empty set
for A being PLS-yielding ManySortedSet of I
for S being Subset of Segre_Product A holds
S is non trivial strong closed_under_lines iff
ex B being Segre-like non trivial-yielding
ManySortedSubset of Carrier A st
S = product B & for C being Subset of A.indx(B)
st C=B.indx(B) holds C is strong closed_under_lines;

