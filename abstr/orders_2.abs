:: Kuratowski - Zorn Lemma
::  by Wojciech A. Trybulec and Grzegorz Bancerek
::
:: Received September 19, 1989
:: Copyright (c) 1990 Association of Mizar Users

environ

 vocabularies FUNCT_1, BOOLE, TARSKI, RELAT_1, RELAT_2, WELLORD1, SUBSET_1,
      ORDERS_1, PARTFUN1, ORDERS_2;
 notations TARSKI, XBOOLE_0, ZFMISC_1, SUBSET_1, RELAT_1, RELAT_2, FUNCT_1,
      RELSET_1, PARTFUN1, WELLORD1, STRUCT_0, PRE_TOPC, ORDERS_1;
 constructors RELAT_2, WELLORD1, PRE_TOPC, PARTFUN1, MEMBERED, ORDERS_1;
 registrations RELSET_1, STRUCT_0, PRE_TOPC, SUBSET_1, XBOOLE_0, ORDERS_1;
 requirements BOOLE, SUBSET;


begin :: Original ORDERS_1

reserve X,Y,x,y for set;

definition
  struct(1-sorted) RelStr (#
    carrier -> set,
    InternalRel -> Relation of the carrier
  #);
end;

registration
 let X be non empty set;
 let R be Relation of X;
 cluster RelStr(#X,R#) -> non empty;
end;

definition let A be RelStr;
 canceled 3;

 attr A is reflexive means
:: ORDERS_2:def 4
  the InternalRel of A is_reflexive_in the carrier of A;
 attr A is transitive means
:: ORDERS_2:def 5
  the InternalRel of A is_transitive_in the carrier of A;
 attr A is antisymmetric means
:: ORDERS_2:def 6
  the InternalRel of A is_antisymmetric_in the carrier of A;
end;

registration
 cluster non empty reflexive transitive antisymmetric strict RelStr;
end;

definition
  mode Poset is reflexive transitive antisymmetric RelStr;
end;

registration let A be Poset;
 cluster the InternalRel of A -> total reflexive antisymmetric transitive;
end;

registration
 let X be set;
 let O be Order of X;
 cluster RelStr(#X,O#) -> reflexive transitive antisymmetric;
end;

 reserve A for non empty Poset;
 reserve a,a1,a2,a3,b,c for Element of A;
 reserve S,T for Subset of A;

definition let A be RelStr; let a1,a2 be Element of A;
 canceled 2;

 pred a1 <= a2 means
:: ORDERS_2:def 9
   [a1,a2] in the InternalRel of A;
end;

notation let A be RelStr; let a1,a2 be Element of A;
 synonym a2 >= a1 for a1 <= a2;
end;

definition let A be RelStr; let a1,a2 be Element of A;
 pred a1 < a2 means
:: ORDERS_2:def 10
   a1 <= a2 & a1 <> a2;
 irreflexivity;
end;

notation let A be RelStr; let a1,a2 be Element of A;
 synonym a2 > a1 for a1 < a2;
end;

canceled 23;

theorem :: ORDERS_2:24
 for A being reflexive non empty RelStr, a being Element of A
  holds a <= a;

definition let A be reflexive non empty RelStr;
           let a1,a2 be Element of A;
 redefine pred a1 <= a2;
 reflexivity;
end;

theorem :: ORDERS_2:25
 for A being antisymmetric RelStr,
 a1,a2 being Element of A
  st a1 <= a2 & a2 <= a1 holds a1 = a2;

theorem :: ORDERS_2:26
 for A being transitive RelStr,
   a1,a2,a3 being Element of A holds
 a1 <= a2 & a2 <= a3 implies a1 <= a3;

canceled;

theorem :: ORDERS_2:28
 for A being antisymmetric RelStr,
  a1,a2 being Element of A holds
 not(a1 < a2 & a2 < a1);

theorem :: ORDERS_2:29
 for A being transitive antisymmetric RelStr
 for a1,a2,a3 being Element of A holds
 a1 < a2 & a2 < a3 implies a1 < a3;

theorem :: ORDERS_2:30
 for A being antisymmetric RelStr,
  a1,a2 being Element of A holds
 a1 <= a2 implies not a2 < a1;

canceled;

theorem :: ORDERS_2:32
  for A being transitive antisymmetric RelStr
 for a1,a2,a3 being Element of A holds
 (a1 < a2 & a2 <= a3) or (a1 <= a2 & a2 < a3) implies a1 < a3;

::
::  Chains.
::

definition let A be RelStr;
 let IT be Subset of A;
 attr IT is strongly_connected means
:: ORDERS_2:def 11
   the InternalRel of A is_strongly_connected_in IT;
end;

registration let A be RelStr;
 cluster {}A -> strongly_connected;
end;

registration let A be RelStr;
 cluster strongly_connected Subset of A;
end;

definition let A be RelStr;
 mode Chain of A is strongly_connected Subset of A;
end;

canceled 2;

theorem :: ORDERS_2:35
 for A being non empty reflexive RelStr
 for a being Element of A holds {a} is Chain of A;

theorem :: ORDERS_2:36
 for A being non empty reflexive RelStr, a1,a2 being Element of A holds
 {a1,a2} is Chain of A iff a1 <= a2 or a2 <= a1;

theorem :: ORDERS_2:37
  for A being RelStr, C being Chain of A, S being Subset of A holds
 S c= C implies S is Chain of A;

theorem :: ORDERS_2:38
 for A being reflexive RelStr, a1,a2 being Element of A holds
 (ex C being Chain of A st a1 in C & a2 in C) iff a1 <= a2 or a2 <= a1;

theorem :: ORDERS_2:39
 for A being reflexive antisymmetric RelStr, a1,a2 being Element of A holds
 (ex C being Chain of A st a1 in C & a2 in C) iff (a1 < a2 iff not a2 <= a1);

theorem :: ORDERS_2:40
 for A being RelStr, T being Subset of A holds
 the InternalRel of A well_orders T implies
  T is Chain of A;

::
::  Upper and lower cones.
::

definition let A; let S;
 func UpperCone(S) -> Subset of A equals
:: ORDERS_2:def 12
    {a1 : for a2 st a2 in S holds a2 < a1};
end;

definition let A; let S;
 func LowerCone(S) -> Subset of A equals
:: ORDERS_2:def 13
    {a1 : for a2 st a2 in S holds a1 < a2};
end;

canceled 2;

theorem :: ORDERS_2:43
 UpperCone({}(A)) = the carrier of A;

theorem :: ORDERS_2:44
  UpperCone([#](A)) = {};

theorem :: ORDERS_2:45
  LowerCone({}(A)) = the carrier of A;

theorem :: ORDERS_2:46
  LowerCone([#](A)) = {};

theorem :: ORDERS_2:47
  a in S implies not a in UpperCone(S);

theorem :: ORDERS_2:48
  not a in UpperCone{a};

theorem :: ORDERS_2:49
  a in S implies not a in LowerCone(S);

theorem :: ORDERS_2:50
  not a in LowerCone{a};

theorem :: ORDERS_2:51
     c < a iff a in UpperCone{c};

theorem :: ORDERS_2:52
 a < c iff a in LowerCone{c};

::
::  Initial segments.
::

definition let A; let S; let a;
 func InitSegm(S,a) -> Subset of A equals
:: ORDERS_2:def 14
    LowerCone{a} /\ S;
end;

definition let A; let S;
 mode Initial_Segm of S -> Subset of A means
:: ORDERS_2:def 15
   ex a st a in S & it = InitSegm(S,a) if S <> {}
        otherwise it = {};
end;

canceled 3;

theorem :: ORDERS_2:56
 x in InitSegm(S,a) iff x in LowerCone{a} & x in S;

theorem :: ORDERS_2:57
 a in InitSegm(S,b) iff a < b & a in S;

canceled 2;

theorem :: ORDERS_2:60
  InitSegm({}(A),a) = {};

theorem :: ORDERS_2:61
 InitSegm(S,a) c= S;

theorem :: ORDERS_2:62
  not a in InitSegm(S,a);

canceled;

theorem :: ORDERS_2:64
  a1 < a2 implies InitSegm(S,a1) c= InitSegm(S,a2);

theorem :: ORDERS_2:65
  S c= T implies InitSegm(S,a) c= InitSegm(T,a);

canceled;

theorem :: ORDERS_2:67
  for I being Initial_Segm of S holds I c= S;

theorem :: ORDERS_2:68
 S <> {} iff not S is Initial_Segm of S;

theorem :: ORDERS_2:69
 (S <> {} or T <> {}) & (S is Initial_Segm of T) implies
   not T is Initial_Segm of S;

theorem :: ORDERS_2:70
 a1 < a2 & a1 in S & a2 in T & T is Initial_Segm of S implies
  a1 in T;

theorem :: ORDERS_2:71
 a in S & S is Initial_Segm of T implies
  InitSegm(S,a) = InitSegm(T,a);

theorem :: ORDERS_2:72
     S c= T & the InternalRel of A well_orders T &
  (for a1,a2 st a2 in S & a1 < a2 holds a1 in S) implies
    S = T or S is Initial_Segm of T;

theorem :: ORDERS_2:73
 S c= T & the InternalRel of A well_orders T &
  (for a1,a2 st a2 in S & a1 in T & a1 < a2 holds a1 in S) implies
    S = T or S is Initial_Segm of T;

::
::  Chains of choice function of BOOL of partially ordered sets.
::

reserve f for Choice_Function of BOOL(the carrier of A);

definition let A; let f;
 mode Chain of f -> Chain of A means
:: ORDERS_2:def 16
   it <> {} &
        the InternalRel of A well_orders it &
        for a st a in it holds f.UpperCone(InitSegm(it,a)) = a;
end;

reserve fC,fC1,fC2 for Chain of f;

canceled 4;

theorem :: ORDERS_2:78
 {f.(the carrier of A)} is Chain of f;

theorem :: ORDERS_2:79
 f.(the carrier of A) in fC;

theorem :: ORDERS_2:80
 a in fC & b = f.(the carrier of A) implies b <= a;

theorem :: ORDERS_2:81
     a = f.(the carrier of A) implies InitSegm(fC,a) = {};

theorem :: ORDERS_2:82
     fC1 meets fC2;

theorem :: ORDERS_2:83
 fC1 <> fC2 implies
  (fC1 is Initial_Segm of fC2 iff not fC2 is Initial_Segm of fC1);

theorem :: ORDERS_2:84
 fC1 c< fC2 iff fC1 is Initial_Segm of fC2;

definition let A; let f;
 func Chains f -> set means
:: ORDERS_2:def 17
   x in it iff x is Chain of f;
end;

registration let A; let f;
 cluster Chains f -> non empty;
end;

canceled 2;

theorem :: ORDERS_2:87
 union(Chains(f)) <> {};

theorem :: ORDERS_2:88
 fC <> union(Chains(f)) & S = union(Chains(f)) implies
  fC is Initial_Segm of S;

theorem :: ORDERS_2:89
     union(Chains(f)) is Chain of f;

begin :: From original ORDERS_2

 reserve R,P for Relation,
         D for non empty set,
         A for non empty Poset,
         C for Chain of A,
         S for Subset of A,
         a,a1,a2,b,c1,c2 for Element of A;

::
::  Orders.
::

canceled 17;

theorem :: ORDERS_2:107
 field((the InternalRel of A) |_2 S) = S;

theorem :: ORDERS_2:108
  (the InternalRel of A) |_2 S is_linear-order implies
  S is Chain of A;

theorem :: ORDERS_2:109
  (the InternalRel of A) |_2 C is_linear-order;

canceled 25;

theorem :: ORDERS_2:135
  the InternalRel of A linearly_orders S implies
  S is Chain of A;

theorem :: ORDERS_2:136
  the InternalRel of A linearly_orders C;

canceled 21;

theorem :: ORDERS_2:158
  a is_minimal_in the InternalRel of A iff
  for b holds not b < a;

theorem :: ORDERS_2:159
  a is_maximal_in the InternalRel of A iff
  for b holds not a < b;

theorem :: ORDERS_2:160
  a is_superior_of the InternalRel of A iff
  for b st a <> b holds b < a;

theorem :: ORDERS_2:161
  a is_inferior_of the InternalRel of A iff
  for b st a <> b holds a < b;

::
::  Kuratowski - Zorn Lemma.
::

theorem :: ORDERS_2:162
 (for C ex a st for b st b in C holds b <= a) implies
   ex a st for b holds not a < b;

theorem :: ORDERS_2:163
 (for C ex a st for b st b in C holds a <= b) implies
   ex a st for b holds not b < a;

