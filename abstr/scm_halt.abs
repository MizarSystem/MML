:: Initialization Halting Concepts and Their Basic Properties of SCM+FSA
::  by JingChao Chen and Yatsuka Nakamura
::
:: Received June 17, 1998
:: Copyright (c) 1998 Association of Mizar Users

environ

 vocabularies SCMFSA6A, AMI_1, SCMFSA_2, FUNCT_1, RELAT_1, CAT_1, FUNCT_4,
      AMI_3, BOOLE, SCMFSA6B, FUNCT_7, SF_MASTR, FINSEQ_1, INT_1, AMI_5, RELOC,
      SCM_1, CARD_1, SCMFSA6C, SCMFSA7B, UNIALG_2, SCMFSA8B, ARYTM_1, SCMFSA8C,
      SCMFSA8A, SCM_HALT, CARD_3, ARYTM, AMISTD_2;
 notations TARSKI, XBOOLE_0, ENUMSET1, SUBSET_1, CARD_1, NUMBERS, XCMPLX_0,
      NAT_1, RELAT_1, FINSEQ_1, FUNCT_1, FUNCT_7, CARD_3, STRUCT_0, AMI_1,
      SCMNORM, SCMFSA_2, FUNCOP_1, SCMFSA_4, SCMFSA6B, SCMFSA_5, SCMFSA6A,
      SF_MASTR, SCMFSA8A, SCMFSA8B, SCMFSA8C, SCMFSA7B, NAT_D, SCMFSA_3,
      SCMFSA6C, XXREAL_0;
 constructors DOMAIN_1, XXREAL_0, REAL_1, NAT_1, PARTFUN1, SCM_1, SCMFSA_3,
      SCMFSA_5, SCMFSA6A, SF_MASTR, SCMFSA6B, SCMFSA6C, SCMFSA8A, SCMFSA8B,
      SCMFSA8C, SCMNORM, SCMFSA_4, NAT_D, RELSET_1;
 registrations XBOOLE_0, SETFAM_1, FUNCT_1, RELSET_1, NUMBERS, XXREAL_0,
      XREAL_0, NAT_1, INT_1, CARD_3, SCMFSA_2, SCMFSA6A, SF_MASTR, SCMFSA6B,
      SCMFSA6C, SCMFSA7B, SCMFSA8A, SCMFSA8C, SCMFSA_9, ORDINAL1, SCMNORM,
      VALUED_1;
 requirements REAL, NUMERALS, BOOLE, SUBSET, ARITHM;


begin

reserve m,n for Element of NAT,
  I for Program of SCM+FSA,
  s,s1,s2 for State of
  SCM+FSA,
  a for Int-Location,
  f for FinSeq-Location;

definition
  let I be Program of SCM+FSA;
  attr I is InitClosed means
:: SCM_HALT:def 1

  for s being State of SCM+FSA, n being
  Element of NAT st Initialized I c= s holds IC Computation(s,n) in dom I;
  attr I is InitHalting means
:: SCM_HALT:def 2

  Initialized I is halting;
  attr I is keepInt0_1 means
:: SCM_HALT:def 3

  for s being State of SCM+FSA st
Initialized I c= s for k being Element of NAT holds (Computation(s,k)).intloc 0
  = 1;
end;

theorem :: SCM_HALT:1
  for x being set,i,m,n being Element of NAT st x in dom (((intloc
  i) .--> m) +* Start-At insloc n) holds x=intloc i or x=IC SCM+FSA;

theorem :: SCM_HALT:2
  for I being Program of SCM+FSA,i,m,n being Element of NAT holds
  dom I misses dom (((intloc i) .--> m) +* Start-At insloc n);

canceled;

theorem :: SCM_HALT:4
  Macro halt SCM+FSA is InitHalting;

registration
  cluster InitHalting Program of SCM+FSA;
end;

theorem :: SCM_HALT:5
  for I being InitHalting Program of SCM+FSA st Initialized I c= s
  holds s is halting;

theorem :: SCM_HALT:6
  I +* Start-At insloc 0 c= Initialized I;

theorem :: SCM_HALT:7
  for I being Program of SCM+FSA,s being State of SCM+FSA st
  Initialized I c= s holds s.intloc 0 =1;

registration
  cluster paraclosed -> InitClosed Program of SCM+FSA;
end;

registration
  cluster parahalting -> InitHalting Program of SCM+FSA;
end;

registration
  cluster InitHalting -> InitClosed Program of SCM+FSA;
  cluster keepInt0_1 -> InitClosed Program of SCM+FSA;
  cluster keeping_0 -> keepInt0_1 Program of SCM+FSA;
end;

theorem :: SCM_HALT:8
  for I being InitHalting Program of SCM+FSA, a being read-write
  Int-Location holds not a in UsedIntLoc I implies (IExec(I, s)).a = s.a;

theorem :: SCM_HALT:9
  for I being InitHalting Program of SCM+FSA,f being FinSeq-Location
  holds not f in UsedInt*Loc I implies (IExec(I, s)).f = s.f;

registration
  let I be InitHalting Program of SCM+FSA;
  cluster Initialized I -> halting;
end;

registration
  cluster InitHalting -> non empty Program of SCM+FSA;
end;

theorem :: SCM_HALT:10
  for I being InitHalting Program of SCM+FSA holds dom I <> {};

theorem :: SCM_HALT:11
  for I being InitHalting Program of SCM+FSA holds insloc 0 in dom
  I;

theorem :: SCM_HALT:12
  for J being InitHalting Program of SCM+FSA st Initialized J c=
  s1 for n being Element of NAT st ProgramPart Relocated(J,n) c= s2 & IC s2 =
  insloc n & DataPart s1 = DataPart s2 for i being Element of NAT holds IC
Computation(s1,i) + n = IC Computation(s2,i) & IncAddr(CurInstr (Computation(s1
,i)),n) = CurInstr (Computation(s2,i)) & DataPart Computation(s1,i) = DataPart
  Computation(s2,i);

theorem :: SCM_HALT:13
  Initialized I c= s implies I c= s;

theorem :: SCM_HALT:14
  for I being InitHalting Program of SCM+FSA st Initialized I c=
s1 & Initialized I c= s2 & s1,s2 equal_outside NAT holds for k being Element of
  NAT holds Computation(s1,k), Computation(s2,k) equal_outside NAT & CurInstr
  Computation(s1,k) = CurInstr Computation(s2,k);

theorem :: SCM_HALT:15
  for I being InitHalting Program of SCM+FSA st Initialized I c=
s1 & Initialized I c= s2 & s1,s2 equal_outside NAT holds LifeSpan s1 = LifeSpan
  s2 & Result s1, Result s2 equal_outside NAT;

registration
  cluster keeping_0 InitHalting Program of SCM+FSA;
end;

registration
  cluster keepInt0_1 InitHalting Program of SCM+FSA;
end;

canceled;

theorem :: SCM_HALT:17
  for I being keepInt0_1 InitHalting Program of SCM+FSA holds
  IExec(I, s).intloc 0 = 1;

theorem :: SCM_HALT:18
  for I being InitClosed Program of SCM+FSA, J being Program of
  SCM+FSA st Initialized I c= s & s is halting for m st m <= LifeSpan s holds
  Computation(s,m),Computation((s+*(I ';' J)),m) equal_outside NAT;

theorem :: SCM_HALT:19
  for i,m,n being Element of NAT holds s+*I+*(((intloc i) .--> m)
  +* Start-At insloc n) = s+*(((intloc i) .--> m) +* Start-At insloc n)+* I;

theorem :: SCM_HALT:20
  ((intloc 0) .--> 1) +* Start-At insloc 0 c= s implies
Initialized I c= s +* (I +* (((intloc 0) .--> 1) +* Start-At insloc 0)) & s +*
  (I +* (((intloc 0) .--> 1) +* Start-At insloc 0)) = s +* I & s +* (I +* (((
  intloc 0) .--> 1) +* Start-At insloc 0)) +* Directed I = s +* Directed I;

theorem :: SCM_HALT:21
  for I being InitClosed Program of SCM+FSA st s +*I is halting &
  Directed I c= s & ((intloc 0) .--> 1) +* Start-At insloc 0 c= s holds IC
  Computation( s,LifeSpan (s +*I) + 1) = insloc card I;

theorem :: SCM_HALT:22
  for I being InitClosed Program of SCM+FSA st s +*I is halting &
Directed I c= s & ((intloc 0) .--> 1) +* Start-At insloc 0 c= s holds DataPart
Computation( s,LifeSpan (s +*I)) = DataPart Computation( s,LifeSpan (s +*I) + 1
  );

theorem :: SCM_HALT:23
  for I being InitHalting Program of SCM+FSA st Initialized I c= s
holds for k being Element of NAT st k <= LifeSpan s holds CurInstr Computation(
  (s +* Directed I),k) <> halt SCM+FSA;

theorem :: SCM_HALT:24
  for I being InitClosed Program of SCM+FSA st s +* Initialized I
  is halting for J being Program of SCM+FSA, k being Element of NAT st k <=
  LifeSpan (s +* Initialized I ) holds Computation( (s +* Initialized I),k),
  Computation( (s +* Initialized (I ';' J)),k) equal_outside NAT;

theorem :: SCM_HALT:25
  for I being keepInt0_1 InitHalting Program of SCM+FSA, J being
InitHalting Program of SCM+FSA, s being State of SCM+FSA st Initialized (I ';'
  J) c= s holds IC Computation( s,LifeSpan (s +* I) + 1) = insloc card I &
DataPart Computation( s,LifeSpan (s +* I) + 1) = DataPart(Computation( (s +* I)
  ,LifeSpan (s +* I)) +* Initialized J) & ProgramPart Relocated(J,card I) c=
Computation( s,LifeSpan (s +* I) + 1) & Computation( s,LifeSpan (s +* I) + 1).
  intloc 0 = 1 & s is halting & LifeSpan s = LifeSpan (s +* I) + 1 + LifeSpan (
Result (s +* I) +* Initialized J) & (J is keeping_0 implies (Result s).intloc 0
  = 1);

registration
  let I be keepInt0_1 InitHalting Program of SCM+FSA, J be InitHalting Program
  of SCM+FSA;
  cluster I ';' J -> InitHalting;
end;

theorem :: SCM_HALT:26
  for I being keepInt0_1 Program of SCM+FSA st s +* I is halting
  for J being InitClosed Program of SCM+FSA st Initialized (I ';' J) c= s for k
being Element of NAT holds Computation( (Result(s +*I) +* Initialized J ),k) +*
  Start-At (IC Computation( (Result(s +*I) +* Initialized J ),k) + card I),
  Computation( (s +* (I ';' J)),LifeSpan (s +* I)+1+k) equal_outside NAT;

theorem :: SCM_HALT:27
  for I being keepInt0_1 Program of SCM+FSA st not s +*
Initialized I is halting for J being Program of SCM+FSA, k being Element of NAT
  holds Computation( (s +* Initialized I),k), Computation( (s +* Initialized (I
  ';' J)),k) equal_outside NAT;

theorem :: SCM_HALT:28
  for I being keepInt0_1 InitHalting Program of SCM+FSA, J being
  InitHalting Program of SCM+FSA holds LifeSpan (s +* Initialized (I ';' J)) =
  LifeSpan (s +* Initialized I) + 1 + LifeSpan (Result (s +* Initialized I) +*
  Initialized J);

theorem :: SCM_HALT:29
  for I being keepInt0_1 InitHalting Program of SCM+FSA, J being
InitHalting Program of SCM+FSA holds IExec(I ';' J,s) = IExec(J,IExec(I,s)) +*
  Start-At (IC IExec(J,IExec(I,s)) + card I);

registration
  let i be parahalting Instruction of SCM+FSA;
  cluster Macro i -> InitHalting;
end;

registration
  let i be parahalting Instruction of SCM+FSA, J be parahalting Program of
  SCM+FSA;
  cluster i ';' J -> InitHalting;
end;

registration
  let i be keeping_0 parahalting Instruction of SCM+FSA, J be InitHalting
  Program of SCM+FSA;
  cluster i ';' J -> InitHalting;
end;

registration
  let I, J be keepInt0_1 Program of SCM+FSA;
  cluster I ';' J -> keepInt0_1;
end;

registration
  let j be keeping_0 parahalting Instruction of SCM+FSA, I be keepInt0_1
  InitHalting Program of SCM+FSA;
  cluster I ';' j -> InitHalting keepInt0_1;
end;

registration
  let i be keeping_0 parahalting Instruction of SCM+FSA, J be keepInt0_1
  InitHalting Program of SCM+FSA;
  cluster i ';' J -> InitHalting keepInt0_1;
end;

registration
  let j be parahalting Instruction of SCM+FSA, I be parahalting Program of
  SCM+FSA;
  cluster I ';' j -> InitHalting;
end;

registration
  let i,j be parahalting Instruction of SCM+FSA;
  cluster i ';' j -> InitHalting;
end;

theorem :: SCM_HALT:30
  for I being keepInt0_1 InitHalting Program of SCM+FSA, J being
InitHalting Program of SCM+FSA holds IExec(I ';' J, s).a = IExec(J,IExec(I,s)).
  a;

theorem :: SCM_HALT:31
  for I being keepInt0_1 InitHalting Program of SCM+FSA, J being
InitHalting Program of SCM+FSA holds IExec(I ';' J, s).f = IExec(J,IExec(I,s)).
  f;

theorem :: SCM_HALT:32
  for I be keepInt0_1 InitHalting Program of SCM+FSA, s be State
  of SCM+FSA holds DataPart(Initialize IExec(I,s)) = DataPart IExec(I,s);

theorem :: SCM_HALT:33
  for I being keepInt0_1 InitHalting Program of SCM+FSA, j being
parahalting Instruction of SCM+FSA holds IExec(I ';' j, s).a = Exec(j, IExec(I,
  s)).a;

theorem :: SCM_HALT:34
  for I being keepInt0_1 InitHalting Program of SCM+FSA, j being
parahalting Instruction of SCM+FSA holds IExec(I ';' j, s).f = Exec(j, IExec(I,
  s)).f;

definition
  let I be Program of SCM+FSA;
  let s be State of SCM+FSA;
  pred I is_closed_onInit s means
:: SCM_HALT:def 4

  for k being Element of NAT holds IC
  Computation( (s +* Initialized I ),k) in dom I;
  pred I is_halting_onInit s means
:: SCM_HALT:def 5

  s +* Initialized I is halting;
end;

theorem :: SCM_HALT:35
  for I being Program of SCM+FSA holds I is InitClosed iff for s
  being State of SCM+FSA holds I is_closed_onInit s;

theorem :: SCM_HALT:36
  for I being Program of SCM+FSA holds I is InitHalting iff for s
  being State of SCM+FSA holds I is_halting_onInit s;

theorem :: SCM_HALT:37
  for s being State of SCM+FSA, I being Program of SCM+FSA, a
being Int-Location st I does_not_destroy a & I is_closed_onInit s & Initialized
  I c= s holds for k being Element of NAT holds Computation(s,k).a = s.a;

registration
  cluster InitHalting good Program of SCM+FSA;
end;

registration
  cluster InitClosed good -> keepInt0_1 Program of SCM+FSA;
end;

registration
  cluster Stop SCM+FSA -> InitHalting good;
end;

theorem :: SCM_HALT:38
  for s being State of SCM+FSA, i being keeping_0 parahalting
  Instruction of SCM+FSA, J being InitHalting Program of SCM+FSA, a being
  Int-Location holds IExec(i ';' J,s).a = IExec(J,Exec(i,Initialize s)).a;

theorem :: SCM_HALT:39
  for s being State of SCM+FSA, i being keeping_0 parahalting
  Instruction of SCM+FSA, J being InitHalting Program of SCM+FSA, f being
  FinSeq-Location holds IExec(i ';' J,s).f = IExec(J,Exec(i,Initialize s)).f;

theorem :: SCM_HALT:40
  for s being State of SCM+FSA, I being Program of SCM+FSA holds I
  is_closed_onInit s iff I is_closed_on Initialize s;

theorem :: SCM_HALT:41
  for s being State of SCM+FSA, I being Program of SCM+FSA holds I
  is_halting_onInit s iff I is_halting_on Initialize s;

theorem :: SCM_HALT:42
  for I be Program of SCM+FSA, s be State of SCM+FSA holds IExec(I,s) =
  IExec(I,Initialize s);

theorem :: SCM_HALT:43
  for s being State of SCM+FSA, I,J being Program of SCM+FSA, a
  being read-write Int-Location st s.a = 0 & I is_closed_onInit s & I
  is_halting_onInit s holds if=0(a,I,J) is_closed_onInit s & if=0(a,I,J)
  is_halting_onInit s;

theorem :: SCM_HALT:44
  for s being State of SCM+FSA, I,J being Program of SCM+FSA, a
  being read-write Int-Location st s.a = 0 & I is_closed_onInit s & I
is_halting_onInit s holds IExec(if=0(a,I,J),s) = IExec(I,s) +* Start-At insloc
  (card I + card J + 3);

theorem :: SCM_HALT:45
  for s being State of SCM+FSA, I,J being Program of SCM+FSA, a
  being read-write Int-Location st s.a <> 0 & J is_closed_onInit s & J
  is_halting_onInit s holds if=0(a,I,J) is_closed_onInit s & if=0(a,I,J)
  is_halting_onInit s;

theorem :: SCM_HALT:46
  for I,J being Program of SCM+FSA, a being read-write
  Int-Location holds for s being State of SCM+FSA st s.a <> 0 & J
is_closed_onInit s & J is_halting_onInit s holds IExec(if=0(a,I,J),s) = IExec(J
  ,s) +* Start-At insloc (card I + card J + 3);

theorem :: SCM_HALT:47
  for s being State of SCM+FSA, I,J being InitHalting Program of
SCM+FSA, a being read-write Int-Location holds if=0(a,I,J) is InitHalting & (s.
  a = 0 implies IExec(if=0(a,I,J),s) = IExec(I,s) +* Start-At insloc (card I +
card J + 3)) & (s.a <> 0 implies IExec(if=0(a,I,J),s) = IExec(J,s) +* Start-At
  insloc (card I + card J + 3));

theorem :: SCM_HALT:48
  for s being State of SCM+FSA, I,J being InitHalting Program of SCM+FSA
, a being read-write Int-Location holds IC IExec(if=0(a,I,J),s) = insloc (card
I + card J + 3) & (s.a = 0 implies ((for d being Int-Location holds IExec(if=0(
a,I,J),s).d = IExec(I,s).d) & for f being FinSeq-Location holds IExec(if=0(a,I,
  J),s).f = IExec(I,s).f)) & (s.a <> 0 implies ((for d being Int-Location holds
  IExec(if=0(a,I,J),s).d = IExec(J,s).d) & for f being FinSeq-Location holds
  IExec(if=0(a,I,J),s).f = IExec(J,s).f));

theorem :: SCM_HALT:49
  for s being State of SCM+FSA, I,J being Program of SCM+FSA, a
  being read-write Int-Location st s.a > 0 & I is_closed_onInit s & I
  is_halting_onInit s holds if>0(a,I,J) is_closed_onInit s & if>0(a,I,J)
  is_halting_onInit s;

theorem :: SCM_HALT:50
  for s being State of SCM+FSA, I,J being Program of SCM+FSA, a
  being read-write Int-Location st s.a > 0 & I is_closed_onInit s & I
is_halting_onInit s holds IExec(if>0(a,I,J),s) = IExec(I,s) +* Start-At insloc
  (card I + card J + 3);

theorem :: SCM_HALT:51
  for s being State of SCM+FSA, I,J being Program of SCM+FSA, a
  being read-write Int-Location st s.a <= 0 & J is_closed_onInit s & J
  is_halting_onInit s holds if>0(a,I,J) is_closed_onInit s & if>0(a,I,J)
  is_halting_onInit s;

theorem :: SCM_HALT:52
  for I,J being Program of SCM+FSA, a being read-write
  Int-Location holds for s being State of SCM+FSA st s.a <= 0 & J
is_closed_onInit s & J is_halting_onInit s holds IExec(if>0(a,I,J),s) = IExec(J
  ,s) +* Start-At insloc (card I + card J + 3);

theorem :: SCM_HALT:53
  for s being State of SCM+FSA, I,J being InitHalting Program of
SCM+FSA, a being read-write Int-Location holds if>0(a,I,J) is InitHalting & (s.
  a > 0 implies IExec(if>0(a,I,J),s) = IExec(I,s) +* Start-At insloc (card I +
card J + 3)) & (s.a <= 0 implies IExec(if>0(a,I,J),s) = IExec(J,s) +* Start-At
  insloc (card I + card J + 3));

theorem :: SCM_HALT:54
  for s being State of SCM+FSA, I,J being InitHalting Program of SCM+FSA
, a being read-write Int-Location holds IC IExec(if>0(a,I,J),s) = insloc (card
I + card J + 3) & (s.a > 0 implies ((for d being Int-Location holds IExec(if>0(
a,I,J),s).d = IExec(I,s).d) & for f being FinSeq-Location holds IExec(if>0(a,I,
  J),s).f = IExec(I,s).f)) & (s.a <= 0 implies ((for d being Int-Location holds
  IExec(if>0(a,I,J),s).d = IExec(J,s).d) & for f being FinSeq-Location holds
  IExec(if>0(a,I,J),s).f = IExec(J,s).f));

theorem :: SCM_HALT:55
  for s being State of SCM+FSA, I,J being Program of SCM+FSA, a
  being read-write Int-Location st s.a < 0 & I is_closed_onInit s & I
is_halting_onInit s holds IExec(if<0(a,I,J),s) = IExec(I,s) +* Start-At insloc
  (card I + card J + card J + 7);

theorem :: SCM_HALT:56
  for s being State of SCM+FSA, I,J being Program of SCM+FSA, a
  being read-write Int-Location st s.a = 0 & J is_closed_onInit s & J
is_halting_onInit s holds IExec(if<0(a,I,J),s) = IExec(J,s) +* Start-At insloc
  (card I + card J + card J + 7);

theorem :: SCM_HALT:57
  for s being State of SCM+FSA, I,J being Program of SCM+FSA, a
  being read-write Int-Location st s.a > 0 & J is_closed_onInit s & J
is_halting_onInit s holds IExec(if<0(a,I,J),s) = IExec(J,s) +* Start-At insloc
  (card I + card J + card J + 7);

theorem :: SCM_HALT:58
  for s being State of SCM+FSA, I,J being InitHalting Program of
SCM+FSA, a being read-write Int-Location holds if<0(a,I,J) is InitHalting & (s.
  a < 0 implies IExec(if<0(a,I,J),s) = IExec(I,s) +* Start-At insloc (card I +
card J + card J + 7)) & (s.a >= 0 implies IExec(if<0(a,I,J),s) = IExec(J,s) +*
  Start-At insloc (card I + card J + card J + 7));

registration
  let I,J be InitHalting Program of SCM+FSA;
  let a be read-write Int-Location;
  cluster if=0(a,I,J) -> InitHalting;
  cluster if>0(a,I,J) -> InitHalting;
  cluster if<0(a,I,J) -> InitHalting;
end;

theorem :: SCM_HALT:59
  for I being Program of SCM+FSA holds I is InitHalting iff for s
  being State of SCM+FSA holds I is_halting_on Initialize s;

theorem :: SCM_HALT:60
  for I being Program of SCM+FSA holds I is InitClosed iff for s
  being State of SCM+FSA holds I is_closed_on Initialize s;

theorem :: SCM_HALT:61
  for s being State of SCM+FSA, I being InitHalting Program of
  SCM+FSA, a being read-write Int-Location holds IExec(I,s).a = Computation( (
  Initialize s +* (I +* Start-At insloc 0)), (LifeSpan (Initialize s +* (I +*
  Start-At insloc 0)))).a;

theorem :: SCM_HALT:62
  for s being State of SCM+FSA, I being InitHalting Program of
  SCM+FSA, a being Int-Location,k being Element of NAT st I does_not_destroy a
holds IExec(I,s).a = Computation( (Initialize s +* (I +* Start-At insloc 0)),k)
  .a;

theorem :: SCM_HALT:63
  for s being State of SCM+FSA, I being InitHalting Program of
  SCM+FSA, a being Int-Location st I does_not_destroy a holds IExec(I,s).a = (
  Initialize s).a;

theorem :: SCM_HALT:64
  for s be State of SCM+FSA,I be keepInt0_1 InitHalting Program of
  SCM+FSA, a being read-write Int-Location st I does_not_destroy a holds
Computation( (Initialize s +* (I ';' SubFrom(a,intloc 0) +* Start-At insloc 0))
,LifeSpan (Initialize s +* (I ';' SubFrom(a,intloc 0) +* Start-At insloc 0))).a
  = s.a - 1;

theorem :: SCM_HALT:65
  for s being State of SCM+FSA, I being InitClosed Program of
SCM+FSA st Initialized I c= s & s is halting for m being Element of NAT st m <=
LifeSpan s holds Computation(s,m), Computation( (s +* loop I),m) equal_outside
  NAT;

theorem :: SCM_HALT:66
  for s being State of SCM+FSA, I being InitHalting Program of SCM+FSA
st Initialized I c= s holds for k being Element of NAT st k <= LifeSpan s holds
  CurInstr Computation( (s +* loop I),k) <> halt SCM+FSA;

theorem :: SCM_HALT:67
  I c= s +* Initialized I;

theorem :: SCM_HALT:68
  for s being State of SCM+FSA, I being Program of SCM+FSA st I
  is_closed_onInit s & I is_halting_onInit s for m being Element of NAT st m <=
  LifeSpan (s +* Initialized I) holds Computation( (s +* Initialized I),m),
  Computation((s +* Initialized (loop I)),m) equal_outside NAT;

theorem :: SCM_HALT:69
  for s being State of SCM+FSA, I being Program of SCM+FSA st I
  is_closed_onInit s & I is_halting_onInit s for m being Element of NAT st m <
LifeSpan (s +* Initialized I) holds CurInstr Computation( (s +* Initialized I),
  m) = CurInstr Computation((s +* Initialized(loop I)),m);

theorem :: SCM_HALT:70
  for l being Instruction-Location of SCM+FSA holds not l in dom (
  ((intloc 0) .--> 1) +* Start-At insloc 0);

theorem :: SCM_HALT:71
  for s being State of SCM+FSA, I being Program of SCM+FSA st I
  is_closed_onInit s & I is_halting_onInit s holds (CurInstr Computation( (s +*
  Initialized (loop I)), LifeSpan (s +* Initialized I)) = goto insloc 0 & for m
  being Element of NAT st m <= LifeSpan (s +* Initialized I) holds CurInstr
  Computation( (s +* Initialized (loop I)),m) <> halt SCM+FSA);

theorem :: SCM_HALT:72
  for s being State of SCM+FSA, I being Program of SCM+FSA st I
  is_closed_onInit s & I is_halting_onInit s holds CurInstr Computation( (s +*
  Initialized loop I), LifeSpan (s +* Initialized I)) = goto insloc 0;

theorem :: SCM_HALT:73
  for s being State of SCM+FSA, I being good InitHalting Program
of SCM+FSA, a being read-write Int-Location st I does_not_destroy a & s.intloc
  0 = 1 & s.a > 0 holds loop if=0(a,Goto insloc 2,I ';' SubFrom(a,intloc 0))
  is_pseudo-closed_on s;

theorem :: SCM_HALT:74
  for s being State of SCM+FSA, I being good InitHalting Program of
  SCM+FSA, a being read-write Int-Location st I does_not_destroy a & s.a > 0
  holds Initialized loop if=0(a,Goto insloc 2,I ';' SubFrom(a,intloc 0))
  is_pseudo-closed_on s;

theorem :: SCM_HALT:75
  for s being State of SCM+FSA, I being good InitHalting Program of
SCM+FSA, a being read-write Int-Location st I does_not_destroy a & s.intloc 0 =
  1 holds Times(a,I) is_closed_on s & Times(a,I) is_halting_on s;

theorem :: SCM_HALT:76
  for I being good InitHalting Program of SCM+FSA, a being read-write
  Int-Location st I does_not_destroy a holds Initialized Times(a,I) is halting;

registration
  let a be read-write Int-Location,I be good Program of SCM+FSA;
  cluster Times(a,I) -> good;
end;

theorem :: SCM_HALT:77
  for s being State of SCM+FSA, I being good InitHalting Program
  of SCM+FSA, a being read-write Int-Location st I does_not_destroy a & s.a > 0
  holds ex s2 being State of SCM+FSA, k being Element of NAT st s2 = s +*
  Initialized (loop if=0(a,Goto insloc 2, I ';' SubFrom(a,intloc 0))) & k =
LifeSpan (s +* Initialized (if=0(a,Goto insloc 2, I ';' SubFrom(a,intloc 0))))
  + 1 & Computation(s2,k).a = s.a - 1 & Computation(s2,k).intloc 0 = 1 & (for b
being read-write Int-Location st b <> a holds Computation(s2,k).b = IExec(I,s).
  b) & (for f being FinSeq-Location holds Computation(s2,k).f = IExec(I,s).f) &
IC Computation(s2,k) = insloc 0 & for n being Element of NAT st n <= k holds IC
Computation( s2,n) in dom loop if=0(a,Goto insloc 2,I ';' SubFrom(a,intloc 0));

theorem :: SCM_HALT:78
  for s being State of SCM+FSA, I being good InitHalting Program
of SCM+FSA, a being read-write Int-Location st s.intloc 0 = 1 & s.a <= 0 holds
  DataPart IExec(Times(a,I),s) = DataPart s;

theorem :: SCM_HALT:79
  for s being State of SCM+FSA, I being good InitHalting Program
  of SCM+FSA, a being read-write Int-Location st I does_not_destroy a & s.a > 0
holds IExec(I ';' SubFrom(a,intloc 0),s).a = s.a - 1 & DataPart IExec(Times(a,I
  ),s) = DataPart IExec(Times(a,I),IExec(I ';' SubFrom(a,intloc 0),s));

theorem :: SCM_HALT:80
  for s be State of SCM+FSA, I be good InitHalting Program of SCM+FSA, f
be FinSeq-Location,a be read-write Int-Location st s.a <= 0 holds IExec(Times(a
  ,I),s).f=s.f;

theorem :: SCM_HALT:81
  for s be State of SCM+FSA, I be good InitHalting Program of SCM+FSA, b
be Int-Location,a be read-write Int-Location st s.a <= 0 holds IExec(Times(a,I)
  ,s).b=(Initialize s).b;

theorem :: SCM_HALT:82
  for s be State of SCM+FSA, I be good InitHalting Program of SCM+FSA, f
be FinSeq-Location,a be read-write Int-Location st I does_not_destroy a & s.a >
0 holds IExec(Times(a,I),s).f =IExec(Times(a,I),IExec(I ';' SubFrom(a,intloc 0)
  ,s)).f;

theorem :: SCM_HALT:83
  for s be State of SCM+FSA, I be good InitHalting Program of SCM+FSA, b
be Int-Location,a be read-write Int-Location st I does_not_destroy a & s.a > 0
holds IExec(Times(a,I),s).b =IExec(Times(a,I),IExec(I ';' SubFrom(a,intloc 0),s
  )).b;

definition
  let i be Instruction of SCM+FSA;
  attr i is good means
:: SCM_HALT:def 6

  i does_not_destroy intloc 0;
end;

registration
  cluster parahalting good Instruction of SCM+FSA;
end;

registration
  let i be good Instruction of SCM+FSA, J be good Program of SCM+FSA;
  cluster i ';' J -> good;
  cluster J ';' i -> good;
end;

registration
  let i,j be good Instruction of SCM+FSA;
  cluster i ';' j -> good;
end;

registration
  let a be read-write Int-Location,b be Int-Location;
  cluster a := b -> good;
  cluster SubFrom(a,b) -> good;
end;

registration
  let a be read-write Int-Location,b be Int-Location,f be FinSeq-Location;
  cluster a:=(f,b) -> good;
end;

registration
  let a,b be Int-Location,f be FinSeq-Location;
  cluster (f,a):=b -> good;
end;

registration
  let a be read-write Int-Location,f be FinSeq-Location;
  cluster a:=len f -> good;
end;

registration
  let n be Element of NAT;
  cluster intloc (n+1) -> read-write;
end;

