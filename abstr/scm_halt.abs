:: Initialization Halting Concepts and Their Basic Properties of SCM+FSA
::  by JingChao Chen and Yatsuka Nakamura
::
:: Received June 17, 1998
:: Copyright (c) 1998 Association of Mizar Users

environ

 vocabularies NUMBERS, SUBSET_1, AMI_1, SCMFSA_2, FSM_1, SCMFSA6A, TARSKI,
      CIRCUIT2, RELAT_1, GLIB_000, FUNCT_1, CARD_1, FUNCOP_1, FUNCT_4,
      XBOOLE_0, SCMFSA6B, NAT_1, XXREAL_0, ARYTM_3, AMI_3, FUNCT_7, SF_MASTR,
      GRAPHSP, MSUALG_1, FINSEQ_1, AMISTD_2, TURING_1, STRUCT_0, VALUED_1,
      SCMFSA6C, SCMFSA7B, UNIALG_2, SCMFSA8B, ARYTM_1, SCMFSA8C, SCMFSA8A,
      SCM_HALT, PARTFUN1, SCMNORM, RELOC;
 notations TARSKI, XBOOLE_0, ENUMSET1, SUBSET_1, CARD_1, NUMBERS, XCMPLX_0,
      NAT_1, RELAT_1, FINSEQ_1, FUNCT_1, PARTFUN1, FUNCT_4, FUNCT_7, VALUED_1,
      STRUCT_0, COMPOS_1, AMI_1, AMISTD_2, SCMFSA_2, FUNCOP_1, SCMFSA6B,
      SCMFSA6A, SF_MASTR, SCMFSA8A, SCMFSA8B, SCMFSA8C, SCMFSA7B, NAT_D,
      SCMFSA_3, SCMFSA6C, XXREAL_0;
 constructors DOMAIN_1, XXREAL_0, REAL_1, SCM_1, SCMFSA_3, SCMFSA6A, SF_MASTR,
      SCMFSA6B, SCMFSA6C, SCMFSA8A, SCMFSA8B, SCMFSA8C, AMISTD_2, NAT_D,
      RELSET_1, VALUED_1;
 registrations XBOOLE_0, SETFAM_1, FUNCT_1, NUMBERS, XXREAL_0, XREAL_0, NAT_1,
      INT_1, SCMFSA_2, SCMFSA6A, SF_MASTR, SCMFSA6B, SCMFSA6C, SCMFSA7B,
      SCMFSA8A, SCMFSA8C, SCMFSA_9, ORDINAL1, AMI_1, RELAT_1, SCMFSA10,
      AMISTD_2, COMPOS_1;
 requirements REAL, NUMERALS, BOOLE, SUBSET, ARITHM;


begin

reserve m,n for Element of NAT,
  I for Program of SCM+FSA,
  s,s1,s2 for State of SCM+FSA,
  a for Int-Location,
  f for FinSeq-Location;

definition
  let I be Program of SCM+FSA;
  attr I is InitClosed means
:: SCM_HALT:def 1

  for s being State of SCM+FSA, n being
  Element of NAT st Initialized I c= s holds IC Comput(ProgramPart(s),s,n) in
dom I;
  attr I is InitHalting means
:: SCM_HALT:def 2

  Initialized I is halting;
  attr I is keepInt0_1 means
:: SCM_HALT:def 3

  for s being State of SCM+FSA st
Initialized I c= s for k being Element of NAT holds (Comput(ProgramPart(s),s,k)
).intloc 0
  = 1;
end;

theorem :: SCM_HALT:1
  for x being set,i,m,n being Element of NAT st x in dom (((intloc
  i) .--> m) +* Start-At( n,SCM+FSA)) holds x=intloc i or x=IC SCM+FSA;

theorem :: SCM_HALT:2
  for I being Program of SCM+FSA,i,m,n being Element of NAT holds
  dom I misses dom (((intloc i) .--> m) +* Start-At( n,SCM+FSA));

canceled;

theorem :: SCM_HALT:4
  Macro halt SCM+FSA is InitHalting;

registration
  cluster InitHalting Program of SCM+FSA;
end;

theorem :: SCM_HALT:5
  for I being InitHalting Program of SCM+FSA st Initialized I c= s
  holds ProgramPart s halts_on s;

theorem :: SCM_HALT:6
  I +* Start-At( 0,SCM+FSA) c= Initialized I;

theorem :: SCM_HALT:7
  for I being Program of SCM+FSA,s being State of SCM+FSA st
  Initialized I c= s holds s.intloc 0 =1;

registration
  cluster paraclosed -> InitClosed Program of SCM+FSA;
end;

registration
  cluster parahalting -> InitHalting Program of SCM+FSA;
end;

registration
  cluster InitHalting -> InitClosed Program of SCM+FSA;
  cluster keepInt0_1 -> InitClosed Program of SCM+FSA;
  cluster keeping_0 -> keepInt0_1 Program of SCM+FSA;
end;

theorem :: SCM_HALT:8
  for I being InitHalting Program of SCM+FSA, a being read-write
  Int-Location holds not a in UsedIntLoc I implies (IExec(I, s)).a = s.a;

theorem :: SCM_HALT:9
  for I being InitHalting Program of SCM+FSA,f being FinSeq-Location
  holds not f in UsedInt*Loc I implies (IExec(I, s)).f = s.f;

registration
  let I be InitHalting Program of SCM+FSA;
  cluster Initialized I -> halting;
end;

registration
  cluster InitHalting -> non empty Program of SCM+FSA;
end;

canceled 2;

theorem :: SCM_HALT:12
  for J being InitHalting Program of SCM+FSA st Initialized J c=
  s1 for n being Element of NAT st ProgramPart Relocated(J,n) c= s2 & IC s2 =
   n & DataPart s1 = DataPart s2 for i being Element of NAT holds IC
Comput(ProgramPart(s1),s1,i) + n = IC Comput(ProgramPart(s2),s2,i) &
 IncAddr(CurInstr(ProgramPart (s1),Comput(ProgramPart(s1),s1,i)),n)
 = CurInstr(ProgramPart (s2),Comput(ProgramPart(s2),s2,i)) &
 DataPart Comput(ProgramPart(s1),s1,i) = DataPart
  Comput(ProgramPart(s2),s2,i);

theorem :: SCM_HALT:13
  Initialized I c= s implies I c= s;

theorem :: SCM_HALT:14
  for I being InitHalting Program of SCM+FSA st Initialized I c=
s1 & Initialized I c= s2 & s1,s2 equal_outside NAT holds for k being Element of
  NAT holds Comput(ProgramPart(s1),s1,k), Comput(ProgramPart(s2),s2,k)
equal_outside NAT &
  CurInstr(ProgramPart Comput(ProgramPart(s1),s1,k),Comput(ProgramPart(s1),s1,k
))
   = CurInstr(ProgramPart Comput(ProgramPart(s2),s2,k),Comput(ProgramPart(s2),
s2,k));

theorem :: SCM_HALT:15
  for I being InitHalting Program of SCM+FSA st Initialized I c=
s1 & Initialized I c= s2 & s1,s2 equal_outside NAT holds LifeSpan(ProgramPart(
s1),s1) = LifeSpan(ProgramPart s2,
  s2) & Result(ProgramPart(s1),s1), Result(ProgramPart(s2),s2)
  equal_outside NAT;

registration
  cluster keeping_0 InitHalting Program of SCM+FSA;
end;

registration
  cluster keepInt0_1 InitHalting Program of SCM+FSA;
end;

canceled;

theorem :: SCM_HALT:17
  for I being keepInt0_1 InitHalting Program of SCM+FSA holds
  IExec(I, s).intloc 0 = 1;

registration
 cluster InitClosed Program of SCM+FSA;
end;

theorem :: SCM_HALT:18
  for I being InitClosed Program of SCM+FSA, J being Program of
  SCM+FSA st Initialized I c= s & ProgramPart s halts_on s
   for m st m <= LifeSpan(ProgramPart(s),s) holds
  Comput(ProgramPart(s),s,m),Comput(ProgramPart((s+*(I ';' J))),(s+*(I ';' J)),
m) equal_outside NAT;

theorem :: SCM_HALT:19
  for i,m,n being Element of NAT holds s+*I+*(((intloc i) .--> m)
  +* Start-At( n,SCM+FSA)) = s+*(((intloc i) .--> m) +*
  Start-At( n,SCM+FSA))+* I;

theorem :: SCM_HALT:20
  ((intloc 0) .--> 1) +* Start-At( 0,SCM+FSA) c= s implies
Initialized I c= s +* (I +* (((intloc 0) .--> 1) +*
Start-At( 0,SCM+FSA))) &
s +* (I +* (((intloc 0) .--> 1) +* Start-At( 0,SCM+FSA))) = s +* I &
 s +* (I +* (((
  intloc 0) .--> 1) +* Start-At( 0,SCM+FSA))) +* Directed I =
  s +* Directed I;

theorem :: SCM_HALT:21
  for I being InitClosed Program of SCM+FSA
   st ProgramPart(s+*I) halts_on s+*I &
  Directed I c= s & ((intloc 0) .--> 1) +* Start-At( 0,SCM+FSA) c= s
   holds IC
  Comput(ProgramPart( s), s,LifeSpan(ProgramPart(s +*I),s +*I) + 1) =  card I;

theorem :: SCM_HALT:22
  for I being InitClosed Program of SCM+FSA
   st ProgramPart(s+*I) halts_on s+*I &
Directed I c= s & ((intloc 0) .--> 1) +* Start-At( 0,SCM+FSA) c= s
 holds DataPart
Comput(ProgramPart( s), s,LifeSpan(ProgramPart(s +*I),s +*I)) = DataPart Comput
(ProgramPart( s),
s,LifeSpan(ProgramPart(s +*I),s +*I) + 1
  );

theorem :: SCM_HALT:23
  for I being InitHalting Program of SCM+FSA st Initialized I c= s
holds for k being Element of NAT st k <= LifeSpan(ProgramPart(s),s)
 holds CurInstr(ProgramPart Comput(ProgramPart(
  (s +* Directed I)),
  (s +* Directed I),k),
  Comput(ProgramPart(
  (s +* Directed I)),
  (s +* Directed I),k)) <> halt SCM+FSA;

theorem :: SCM_HALT:24
  for I being InitClosed Program of SCM+FSA
   st ProgramPart(s+*Initialized I) halts_on s+*Initialized I
   for J being Program of SCM+FSA, k being Element of NAT st k <=
  LifeSpan(ProgramPart(s +* Initialized I ),s +* Initialized I ) holds Comput(
ProgramPart( (s +* Initialized I)
), (s +* Initialized I),k),
  Comput(ProgramPart( (s +* Initialized (I ';' J))), (s +* Initialized (I ';' J
)),k) equal_outside NAT;

theorem :: SCM_HALT:25
  for I being keepInt0_1 InitHalting Program of SCM+FSA, J being
InitHalting Program of SCM+FSA, s being State of SCM+FSA st Initialized (I ';'
  J) c= s holds IC Comput(ProgramPart( s), s,LifeSpan(ProgramPart(s +* I),s +*
I) + 1) =  card I &
DataPart Comput(ProgramPart( s), s,LifeSpan(ProgramPart(s +* I),s +* I) + 1) =
DataPart(Comput(
ProgramPart( (s +* I)
  ), (s +* I)
  ,LifeSpan(ProgramPart(s +* I),s +* I)) +* Initialized J) & ProgramPart
Relocated(J,card I) c=
Comput(ProgramPart( s), s,LifeSpan(ProgramPart(s +* I),s +* I) + 1) & Comput(
ProgramPart( s), s,
LifeSpan(ProgramPart(s +* I),s +* I) + 1).
  intloc 0 = 1 & ProgramPart s halts_on s &
   LifeSpan(ProgramPart(s),s) = LifeSpan(ProgramPart(s +* I),s +* I) + 1 +
LifeSpan(ProgramPart(
Result(ProgramPart(s +* I),s +* I) +* Initialized J),
Result(ProgramPart(s +* I),s +* I) +* Initialized J) & (J is keeping_0 implies
(Result(ProgramPart(s),s)).intloc 0
  = 1);

registration
  let I be keepInt0_1 InitHalting Program of SCM+FSA, J be InitHalting Program
  of SCM+FSA;
  cluster I ';' J -> InitHalting;
end;

theorem :: SCM_HALT:26
  for I being keepInt0_1 Program of SCM+FSA st ProgramPart(s+*I) halts_on s+*I
  for J being InitClosed Program of SCM+FSA st Initialized (I ';' J) c= s for k
being Element of NAT holds Comput(ProgramPart( (Result(ProgramPart(s +*I),s +*I
) +* Initialized J
)), (Result(ProgramPart(s +*I),s +*I) +* Initialized J ),k) +*
  Start-At (IC Comput(ProgramPart( (
  Result(ProgramPart(s +*I),s +*I) +* Initialized J )), (
  Result(ProgramPart(s +*I),s +*I) +* Initialized J ),k) + card I,SCM+FSA),
  Comput(ProgramPart( (s +* (I ';' J))), (s +* (I ';' J)),LifeSpan(ProgramPart(
s +* I),s +* I)+1+k
) equal_outside NAT;

theorem :: SCM_HALT:27
  for I being keepInt0_1 Program of SCM+FSA
   st not ProgramPart(s+*Initialized I) halts_on s+*Initialized I
 for J being Program of SCM+FSA, k being Element of NAT
  holds Comput(ProgramPart( (s +* Initialized I)), (s +* Initialized I),k),
Comput(ProgramPart( (s +* Initialized (I
  ';' J))), (s +* Initialized (I
  ';' J)),k) equal_outside NAT;

theorem :: SCM_HALT:28
  for I being keepInt0_1 InitHalting Program of SCM+FSA, J being
  InitHalting Program of SCM+FSA holds LifeSpan(ProgramPart(s +* Initialized (I
';' J)),s +* Initialized (I ';' J)) =
  LifeSpan(ProgramPart(s +* Initialized I),s +* Initialized I) + 1 + LifeSpan(
ProgramPart(Result(ProgramPart(s +* Initialized I),s +* Initialized I) +*
  Initialized J),Result(ProgramPart(s +* Initialized I),s +* Initialized I) +*
  Initialized J);

theorem :: SCM_HALT:29
  for I being keepInt0_1 InitHalting Program of SCM+FSA, J being
InitHalting Program of SCM+FSA holds IExec(I ';' J,s) = IExec(J,IExec(I,s)) +*
  Start-At (IC IExec(J,IExec(I,s)) + card I,SCM+FSA);

registration
  let i be parahalting Instruction of SCM+FSA;
  cluster Macro i -> InitHalting;
end;

registration
  let i be parahalting Instruction of SCM+FSA, J be parahalting Program of
  SCM+FSA;
  cluster i ';' J -> InitHalting;
end;

registration
  let i be keeping_0 parahalting Instruction of SCM+FSA, J be InitHalting
  Program of SCM+FSA;
  cluster i ';' J -> InitHalting;
end;

registration
  let I, J be keepInt0_1 Program of SCM+FSA;
  cluster I ';' J -> keepInt0_1;
end;

registration
  let j be keeping_0 parahalting Instruction of SCM+FSA, I be keepInt0_1
  InitHalting Program of SCM+FSA;
  cluster I ';' j -> InitHalting keepInt0_1;
end;

registration
  let i be keeping_0 parahalting Instruction of SCM+FSA, J be keepInt0_1
  InitHalting Program of SCM+FSA;
  cluster i ';' J -> InitHalting keepInt0_1;
end;

registration
  let j be parahalting Instruction of SCM+FSA, I be parahalting Program of
  SCM+FSA;
  cluster I ';' j -> InitHalting;
end;

registration
  let i,j be parahalting Instruction of SCM+FSA;
  cluster i ';' j -> InitHalting;
end;

theorem :: SCM_HALT:30
  for I being keepInt0_1 InitHalting Program of SCM+FSA, J being
InitHalting Program of SCM+FSA holds IExec(I ';' J, s).a = IExec(J,IExec(I,s)).
  a;

theorem :: SCM_HALT:31
  for I being keepInt0_1 InitHalting Program of SCM+FSA, J being
InitHalting Program of SCM+FSA holds IExec(I ';' J, s).f = IExec(J,IExec(I,s)).
  f;

theorem :: SCM_HALT:32
  for I be keepInt0_1 InitHalting Program of SCM+FSA, s be State
  of SCM+FSA holds DataPart(Initialized IExec(I,s)) = DataPart IExec(I,s);

theorem :: SCM_HALT:33
  for I being keepInt0_1 InitHalting Program of SCM+FSA, j being
parahalting Instruction of SCM+FSA holds IExec(I ';' j, s).a = Exec(j, IExec(I,
  s)).a;

theorem :: SCM_HALT:34
  for I being keepInt0_1 InitHalting Program of SCM+FSA, j being
parahalting Instruction of SCM+FSA holds IExec(I ';' j, s).f = Exec(j, IExec(I,
  s)).f;

definition
  let I be Program of SCM+FSA;
  let s be State of SCM+FSA;
  pred I is_closed_onInit s means
:: SCM_HALT:def 4

  for k being Element of NAT holds IC
  Comput(ProgramPart( (s +* Initialized I )), (s +* Initialized I ),k) in dom I
;
  pred I is_halting_onInit s means
:: SCM_HALT:def 5

  ProgramPart(s+*Initialized I) halts_on s+*Initialized I;
end;

theorem :: SCM_HALT:35
  for I being Program of SCM+FSA holds I is InitClosed iff for s
  being State of SCM+FSA holds I is_closed_onInit s;

theorem :: SCM_HALT:36
  for I being Program of SCM+FSA holds I is InitHalting iff for s
  being State of SCM+FSA holds I is_halting_onInit s;

theorem :: SCM_HALT:37
  for s being State of SCM+FSA, I being Program of SCM+FSA, a
being Int-Location st I does not destroy a & I is_closed_onInit s & Initialized
  I c= s holds for k being Element of NAT holds Comput(ProgramPart(s),s,k).a =
s.a;

registration
  cluster InitHalting good Program of SCM+FSA;
end;

registration
  cluster InitClosed good -> keepInt0_1 Program of SCM+FSA;
end;

registration
  cluster Stop SCM+FSA -> InitHalting good;
end;

theorem :: SCM_HALT:38
  for s being State of SCM+FSA, i being keeping_0 parahalting
  Instruction of SCM+FSA, J being InitHalting Program of SCM+FSA, a being
  Int-Location holds IExec(i ';' J,s).a = IExec(J,Exec(i,Initialized s)).a;

theorem :: SCM_HALT:39
  for s being State of SCM+FSA, i being keeping_0 parahalting
  Instruction of SCM+FSA, J being InitHalting Program of SCM+FSA, f being
  FinSeq-Location holds IExec(i ';' J,s).f = IExec(J,Exec(i,Initialized s)).f;

theorem :: SCM_HALT:40
  for s being State of SCM+FSA, I being Program of SCM+FSA holds I
  is_closed_onInit s iff I is_closed_on Initialized s;

theorem :: SCM_HALT:41
  for s being State of SCM+FSA, I being Program of SCM+FSA holds I
  is_halting_onInit s iff I is_halting_on Initialized s;

theorem :: SCM_HALT:42
  for I be Program of SCM+FSA, s be State of SCM+FSA holds IExec(I,s) =
  IExec(I,Initialized s);

theorem :: SCM_HALT:43
  for s being State of SCM+FSA, I,J being Program of SCM+FSA, a
  being read-write Int-Location st s.a = 0 & I is_closed_onInit s & I
  is_halting_onInit s holds if=0(a,I,J) is_closed_onInit s & if=0(a,I,J)
  is_halting_onInit s;

theorem :: SCM_HALT:44
  for s being State of SCM+FSA, I,J being Program of SCM+FSA, a
  being read-write Int-Location st s.a = 0 & I is_closed_onInit s & I
is_halting_onInit s holds IExec(if=0(a,I,J),s) = IExec(I,s) +* Start-At(
  (card I + card J + 3),SCM+FSA);

theorem :: SCM_HALT:45
  for s being State of SCM+FSA, I,J being Program of SCM+FSA, a
  being read-write Int-Location st s.a <> 0 & J is_closed_onInit s & J
  is_halting_onInit s holds if=0(a,I,J) is_closed_onInit s & if=0(a,I,J)
  is_halting_onInit s;

theorem :: SCM_HALT:46
  for I,J being Program of SCM+FSA, a being read-write
  Int-Location holds for s being State of SCM+FSA st s.a <> 0 & J
is_closed_onInit s & J is_halting_onInit s holds IExec(if=0(a,I,J),s) = IExec(J
  ,s) +* Start-At( (card I + card J + 3),SCM+FSA);

theorem :: SCM_HALT:47
  for s being State of SCM+FSA, I,J being InitHalting Program of
SCM+FSA, a being read-write Int-Location holds if=0(a,I,J) is InitHalting & (s.
  a = 0 implies IExec(if=0(a,I,J),s) = IExec(I,s) +* Start-At( (card I +
card J + 3),SCM+FSA)) &
 (s.a <> 0 implies IExec(if=0(a,I,J),s) = IExec(J,s) +* Start-At(
   (card I + card J + 3),SCM+FSA));

theorem :: SCM_HALT:48
  for s being State of SCM+FSA, I,J being InitHalting Program of SCM+FSA
, a being read-write Int-Location holds IC IExec(if=0(a,I,J),s) =  (card
I + card J + 3) & (s.a = 0 implies ((for d being Int-Location holds IExec(if=0(
a,I,J),s).d = IExec(I,s).d) & for f being FinSeq-Location holds IExec(if=0(a,I,
  J),s).f = IExec(I,s).f)) & (s.a <> 0 implies ((for d being Int-Location holds
  IExec(if=0(a,I,J),s).d = IExec(J,s).d) & for f being FinSeq-Location holds
  IExec(if=0(a,I,J),s).f = IExec(J,s).f));

theorem :: SCM_HALT:49
  for s being State of SCM+FSA, I,J being Program of SCM+FSA, a
  being read-write Int-Location st s.a > 0 & I is_closed_onInit s & I
  is_halting_onInit s holds if>0(a,I,J) is_closed_onInit s & if>0(a,I,J)
  is_halting_onInit s;

theorem :: SCM_HALT:50
  for s being State of SCM+FSA, I,J being Program of SCM+FSA, a
  being read-write Int-Location st s.a > 0 & I is_closed_onInit s & I
is_halting_onInit s holds IExec(if>0(a,I,J),s) = IExec(I,s) +* Start-At(
  (card I + card J + 3),SCM+FSA);

theorem :: SCM_HALT:51
  for s being State of SCM+FSA, I,J being Program of SCM+FSA, a
  being read-write Int-Location st s.a <= 0 & J is_closed_onInit s & J
  is_halting_onInit s holds if>0(a,I,J) is_closed_onInit s & if>0(a,I,J)
  is_halting_onInit s;

theorem :: SCM_HALT:52
  for I,J being Program of SCM+FSA, a being read-write
  Int-Location holds for s being State of SCM+FSA st s.a <= 0 & J
is_closed_onInit s & J is_halting_onInit s holds IExec(if>0(a,I,J),s) = IExec(J
  ,s) +* Start-At( (card I + card J + 3),SCM+FSA);

theorem :: SCM_HALT:53
  for s being State of SCM+FSA, I,J being InitHalting Program of
SCM+FSA, a being read-write Int-Location holds if>0(a,I,J) is InitHalting & (s.
  a > 0 implies IExec(if>0(a,I,J),s) = IExec(I,s) +* Start-At( (card I +
card J + 3),SCM+FSA)) &
 (s.a <= 0 implies IExec(if>0(a,I,J),s) = IExec(J,s) +* Start-At(
   (card I + card J + 3),SCM+FSA));

theorem :: SCM_HALT:54
  for s being State of SCM+FSA, I,J being InitHalting Program of SCM+FSA
, a being read-write Int-Location holds IC IExec(if>0(a,I,J),s) =  (card
I + card J + 3) & (s.a > 0 implies ((for d being Int-Location holds IExec(if>0(
a,I,J),s).d = IExec(I,s).d) & for f being FinSeq-Location holds IExec(if>0(a,I,
  J),s).f = IExec(I,s).f)) & (s.a <= 0 implies ((for d being Int-Location holds
  IExec(if>0(a,I,J),s).d = IExec(J,s).d) & for f being FinSeq-Location holds
  IExec(if>0(a,I,J),s).f = IExec(J,s).f));

theorem :: SCM_HALT:55
  for s being State of SCM+FSA, I,J being Program of SCM+FSA, a
  being read-write Int-Location st s.a < 0 & I is_closed_onInit s & I
is_halting_onInit s holds IExec(if<0(a,I,J),s) = IExec(I,s) +* Start-At(
  (card I + card J + card J + 7),SCM+FSA);

theorem :: SCM_HALT:56
  for s being State of SCM+FSA, I,J being Program of SCM+FSA, a
  being read-write Int-Location st s.a = 0 & J is_closed_onInit s & J
is_halting_onInit s holds IExec(if<0(a,I,J),s) = IExec(J,s) +* Start-At(
  (card I + card J + card J + 7),SCM+FSA);

theorem :: SCM_HALT:57
  for s being State of SCM+FSA, I,J being Program of SCM+FSA, a
  being read-write Int-Location st s.a > 0 & J is_closed_onInit s & J
is_halting_onInit s holds IExec(if<0(a,I,J),s) = IExec(J,s) +* Start-At(
  (card I + card J + card J + 7),SCM+FSA);

theorem :: SCM_HALT:58
  for s being State of SCM+FSA, I,J being InitHalting Program of
SCM+FSA, a being read-write Int-Location holds if<0(a,I,J) is InitHalting & (s.
  a < 0 implies IExec(if<0(a,I,J),s) = IExec(I,s) +* Start-At( (card I +
card J + card J + 7),SCM+FSA)) &
 (s.a >= 0 implies IExec(if<0(a,I,J),s) = IExec(J,s) +*
  Start-At( (card I + card J + card J + 7),SCM+FSA));

registration
  let I,J be InitHalting Program of SCM+FSA;
  let a be read-write Int-Location;
  cluster if=0(a,I,J) -> InitHalting;
  cluster if>0(a,I,J) -> InitHalting;
  cluster if<0(a,I,J) -> InitHalting;
end;

theorem :: SCM_HALT:59
  for I being Program of SCM+FSA holds I is InitHalting iff for s
  being State of SCM+FSA holds I is_halting_on Initialized s;

theorem :: SCM_HALT:60
  for I being Program of SCM+FSA holds I is InitClosed iff for s
  being State of SCM+FSA holds I is_closed_on Initialized s;

theorem :: SCM_HALT:61
  for s being State of SCM+FSA, I being InitHalting Program of
  SCM+FSA, a being read-write Int-Location holds IExec(I,s).a = Comput(
ProgramPart( (
  Initialized s +* (I +* Start-At( 0,SCM+FSA)))), (
  Initialized s +* (I +* Start-At( 0,SCM+FSA))),
  (LifeSpan(ProgramPart(Initialized s +* (I +*
  Start-At( 0,SCM+FSA))),Initialized s +* (I +*
  Start-At( 0,SCM+FSA))))).a;

theorem :: SCM_HALT:62
  for s being State of SCM+FSA, I being InitHalting Program of
  SCM+FSA, a being Int-Location,k being Element of NAT st I does not destroy a
holds IExec(I,s).a = Comput(ProgramPart( (Initialized s +* (I +*
Start-At( 0,SCM+FSA)))), (Initialized s +* (I +*
Start-At( 0,SCM+FSA))),k)
  .a;

theorem :: SCM_HALT:63
  for s being State of SCM+FSA, I being InitHalting Program of
  SCM+FSA, a being Int-Location st I does not destroy a holds IExec(I,s).a = (
  Initialized s).a;

theorem :: SCM_HALT:64
  for s be State of SCM+FSA,I be keepInt0_1 InitHalting Program of
  SCM+FSA, a being read-write Int-Location st I does not destroy a holds
Comput(ProgramPart( (Initialized s +* (I ';' SubFrom(a,intloc 0) +*
Start-At( 0,SCM+FSA)))
), (Initialized s +* (I ';' SubFrom(a,intloc 0) +*
Start-At( 0,SCM+FSA)))
,LifeSpan(ProgramPart(Initialized s +* (I ';' SubFrom(a,intloc 0) +*
Start-At( 0,SCM+FSA))),Initialized s +* (I ';' SubFrom(a,intloc 0) +*
Start-At( 0,SCM+FSA)))).a
  = s.a - 1;

theorem :: SCM_HALT:65
  for s being State of SCM+FSA, I being InitClosed Program of
SCM+FSA st Initialized I c= s & ProgramPart s halts_on s
 for m being Element of NAT st m <=
LifeSpan(ProgramPart(s),s) holds Comput(ProgramPart(s),s,m), Comput(ProgramPart
( (s +* loop I))
, (s +* loop I),m) equal_outside
  NAT;

theorem :: SCM_HALT:66
  for s being State of SCM+FSA, I being InitHalting Program of SCM+FSA
st Initialized I c= s holds for k being Element of NAT st k <= LifeSpan(
ProgramPart(s),s) holds
  CurInstr(ProgramPart Comput(ProgramPart( (s +* loop I)), (s +* loop I),k),
   Comput(ProgramPart( (s +* loop I)), (s +* loop I),k)) <> halt SCM+FSA;

theorem :: SCM_HALT:67
  I c= s +* Initialized I;

theorem :: SCM_HALT:68
  for s being State of SCM+FSA, I being Program of SCM+FSA st I
  is_closed_onInit s & I is_halting_onInit s for m being Element of NAT st m <=
  LifeSpan(ProgramPart(s +* Initialized I),s +* Initialized I) holds Comput(
ProgramPart( (s +* Initialized I))
, (s +* Initialized I),m),
  Comput(ProgramPart((s +* Initialized (loop I))),(s +* Initialized (loop I)),m
) equal_outside NAT;

theorem :: SCM_HALT:69
  for s being State of SCM+FSA, I being Program of SCM+FSA st I
  is_closed_onInit s & I is_halting_onInit s for m being Element of NAT st m <
LifeSpan(ProgramPart(s +* Initialized I),s +* Initialized I) holds
 CurInstr(ProgramPart Comput(ProgramPart( (s +* Initialized I)), (s +*
Initialized I),m),
  Comput(ProgramPart( (s +* Initialized I)), (s +* Initialized I),m))
  = CurInstr(ProgramPart Comput(ProgramPart((s +* Initialized(loop I))),(s +*
Initialized(loop I)),m),
   Comput(ProgramPart((s +* Initialized(loop I))),(s +* Initialized(loop I)),m)
);

theorem :: SCM_HALT:70
  for l being Element of NAT holds not l in dom (
  ((intloc 0) .--> 1) +* Start-At( 0,SCM+FSA));

theorem :: SCM_HALT:71
  for s being State of SCM+FSA, I being Program of SCM+FSA st I
  is_closed_onInit s & I is_halting_onInit s
   holds CurInstr(
   ProgramPart Comput(ProgramPart( (s +*Initialized (loop I))), (s +*
Initialized (loop I)),
      LifeSpan(ProgramPart(s +* Initialized I),s +* Initialized I)),
   Comput(ProgramPart( (s +*Initialized (loop I))), (s +*Initialized (loop I)),
LifeSpan(ProgramPart(s +* Initialized I),s +* Initialized I)))
    = goto  0 & for m
  being Element of NAT st m <= LifeSpan(ProgramPart(s +* Initialized I),s +*
Initialized I)
   holds CurInstr(
  ProgramPart Comput(ProgramPart( (s +* Initialized (loop I))), (s +*
Initialized (loop I)),m),
  Comput(ProgramPart( (s +* Initialized (loop I))), (s +* Initialized (loop I))
,m))
   <> halt SCM+FSA;

canceled;

theorem :: SCM_HALT:73
  for s being State of SCM+FSA, I being good InitHalting Program
of SCM+FSA, a being read-write Int-Location st I does not destroy a & s.intloc
  0 = 1 & s.a > 0 holds loop if=0(a,Goto  2,I ';' SubFrom(a,intloc 0))
  is_pseudo-closed_on s;

theorem :: SCM_HALT:74
  for s being State of SCM+FSA, I being good InitHalting Program of
  SCM+FSA, a being read-write Int-Location st I does not destroy a & s.a > 0
  holds Initialized loop if=0(a,Goto  2,I ';' SubFrom(a,intloc 0))
  is_pseudo-closed_on s;

theorem :: SCM_HALT:75
  for s being State of SCM+FSA, I being good InitHalting Program of
SCM+FSA, a being read-write Int-Location st I does not destroy a & s.intloc 0 =
  1 holds Times(a,I) is_closed_on s & Times(a,I) is_halting_on s;

theorem :: SCM_HALT:76
  for I being good InitHalting Program of SCM+FSA, a being read-write
  Int-Location st I does not destroy a holds Initialized Times(a,I) is halting;

registration
  let a be read-write Int-Location,I be good Program of SCM+FSA;
  cluster Times(a,I) -> good;
end;

theorem :: SCM_HALT:77
  for s being State of SCM+FSA, I being good InitHalting Program
  of SCM+FSA, a being read-write Int-Location st I does not destroy a & s.a > 0
  holds ex s2 being State of SCM+FSA, k being Element of NAT st s2 = s +*
  Initialized (loop if=0(a,Goto  2, I ';' SubFrom(a,intloc 0))) & k =
LifeSpan(ProgramPart(s +* Initialized (if=0(a,Goto  2, I ';' SubFrom(a,intloc 0
)))),s +* Initialized (if=0(a,Goto  2, I ';' SubFrom(a,intloc 0))))
  + 1 & Comput(ProgramPart(s2),s2,k).a = s.a - 1 & Comput(ProgramPart(s2),s2,k)
.intloc 0 = 1 & (for b
being read-write Int-Location st b <> a holds Comput(ProgramPart(s2),s2,k).b =
IExec(I,s).
  b) & (for f being FinSeq-Location holds Comput(ProgramPart(s2),s2,k).f =
IExec(I,s).f) &
IC Comput(ProgramPart(s2),s2,k) =  0 & for n being Element of NAT st n <= k
holds IC
Comput(ProgramPart( s2), s2,n) in dom loop if=0(a,Goto  2,I ';' SubFrom(a,
intloc 0));

theorem :: SCM_HALT:78
  for s being State of SCM+FSA, I being good InitHalting Program
of SCM+FSA, a being read-write Int-Location st s.intloc 0 = 1 & s.a <= 0 holds
  DataPart IExec(Times(a,I),s) = DataPart s;

theorem :: SCM_HALT:79
  for s being State of SCM+FSA, I being good InitHalting Program
  of SCM+FSA, a being read-write Int-Location st I does not destroy a & s.a > 0
holds IExec(I ';' SubFrom(a,intloc 0),s).a = s.a - 1 & DataPart IExec(Times(a,I
  ),s) = DataPart IExec(Times(a,I),IExec(I ';' SubFrom(a,intloc 0),s));

theorem :: SCM_HALT:80
  for s be State of SCM+FSA, I be good InitHalting Program of SCM+FSA, f
be FinSeq-Location,a be read-write Int-Location st s.a <= 0 holds IExec(Times(a
  ,I),s).f=s.f;

theorem :: SCM_HALT:81
  for s be State of SCM+FSA, I be good InitHalting Program of SCM+FSA, b
be Int-Location,a be read-write Int-Location st s.a <= 0 holds IExec(Times(a,I)
  ,s).b=(Initialized s).b;

theorem :: SCM_HALT:82
  for s be State of SCM+FSA, I be good InitHalting Program of SCM+FSA, f
be FinSeq-Location,a be read-write Int-Location st I does not destroy a & s.a >
0 holds IExec(Times(a,I),s).f =IExec(Times(a,I),IExec(I ';' SubFrom(a,intloc 0)
  ,s)).f;

theorem :: SCM_HALT:83
  for s be State of SCM+FSA, I be good InitHalting Program of SCM+FSA, b
be Int-Location,a be read-write Int-Location st I does not destroy a & s.a > 0
holds IExec(Times(a,I),s).b =IExec(Times(a,I),IExec(I ';' SubFrom(a,intloc 0),s
  )).b;

definition
  let i be Instruction of SCM+FSA;
  attr i is good means
:: SCM_HALT:def 6

  i does not destroy intloc 0;
end;

registration
  cluster parahalting good Instruction of SCM+FSA;
end;

registration
  let i be good Instruction of SCM+FSA, J be good Program of SCM+FSA;
  cluster i ';' J -> good;
  cluster J ';' i -> good;
end;

registration
  let i,j be good Instruction of SCM+FSA;
  cluster i ';' j -> good;
end;

registration
  let a be read-write Int-Location,b be Int-Location;
  cluster a := b -> good;
  cluster SubFrom(a,b) -> good;
end;

registration
  let a be read-write Int-Location,b be Int-Location,f be FinSeq-Location;
  cluster a:=(f,b) -> good;
end;

registration
  let a,b be Int-Location,f be FinSeq-Location;
  cluster (f,a):=b -> good;
end;

registration
  let a be read-write Int-Location,f be FinSeq-Location;
  cluster a:=len f -> good;
end;

registration
  let n be Element of NAT;
  cluster intloc (n+1) -> read-write;
end;

