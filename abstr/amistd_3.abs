:: A Tree of Execution of a Macroinstruction
::  by Artur Korni{\l}owicz
::
:: Received December 10, 2003
:: Copyright (c) 2003 Association of Mizar Users

environ

 vocabularies NUMBERS, ORDINAL1, RELAT_1, FUNCOP_1, FINSET_1, FUNCT_1, CARD_1,
      WELLORD2, XBOOLE_0, TARSKI, SUBSET_1, ZFMISC_1, WELLORD1, ORDINAL2,
      FINSEQ_2, FINSEQ_1, TREES_1, TREES_2, NAT_1, XXREAL_0, ARYTM_3, ORDINAL4,
      SETFAM_1, GOBOARD5, AMI_1, AMISTD_1, GLIB_000, AMISTD_2, AMISTD_3,
      PARTFUN1, CAT_1, AFINSQ_1;
 notations TARSKI, XBOOLE_0, SETFAM_1, ZFMISC_1, SUBSET_1, FINSET_1, CARD_1,
      NUMBERS, ORDINAL1, ORDINAL2, SEQ_4, XXREAL_0, NAT_1, RELAT_1, FUNCT_1,
      PARTFUN1, FUNCT_2, BINOP_1, WELLORD1, WELLORD2, FUNCOP_1, FINSEQ_1,
      FINSEQ_2, TREES_1, TREES_2, VALUED_1, AFINSQ_1, STRUCT_0, COMPOS_1,
      EXTPRO_1, AMISTD_1, AMISTD_2;
 constructors WELLORD1, WELLORD2, BINOP_1, ORDINAL2, FINSEQ_2, SEQ_4, REALSET1,
      AMISTD_2, SEQ_2, RELSET_1, TREES_2, VALUED_1, PRE_POLY, AMISTD_1;
 registrations XBOOLE_0, RELAT_1, ORDINAL1, FUNCOP_1, FINSET_1, XXREAL_0,
      NAT_1, CARD_1, MEMBERED, FINSEQ_1, TREES_2, FINSEQ_6, AMISTD_1, SETFAM_1,
      VALUED_0, XXREAL_2, RELSET_1, FINSEQ_2, SUBSET_1, CARD_5, TREES_1,
      VALUED_1, AMISTD_2, COMPOS_1, EXTPRO_1;
 requirements BOOLE, SUBSET, NUMERALS, REAL;


begin

reserve x, y, z, X for set,
  m, n for natural number,
  O for Ordinal,
  R, S for Relation;

reserve
  N for with_non-empty_elements non empty set,
  S for :::steady-programmed
  standard (IC-Ins-separated definite (non empty stored-program AMI-Struct over
  N)),
  L, l1 for Element of NAT,
  J for Instruction of S,
  F for Subset of NAT;

canceled 24;

:: LocSeq

definition
 canceled 2;
  let N be with_non-empty_elements non empty set,
  S be standard (IC-Ins-separated definite
   (non empty stored-program AMI-Struct over N)), M be Subset of NAT;
  func LocSeq(M,S) -> T-Sequence of NAT means
:: AMISTD_3:def 3

  dom it = card M & for m
being set st m in card M holds it.m = (canonical_isomorphism_of (RelIncl
  order_type_of RelIncl M, RelIncl M).m);
end;

canceled 6;

theorem :: AMISTD_3:31
  F = {n} implies LocSeq(F,S) = 0 .--> n;

registration
  let N be with_non-empty_elements non empty set,
  S be standard (IC-Ins-separated definite :::steady-programmed
 (non empty stored-program AMI-Struct over N)), M be Subset of NAT;
  cluster LocSeq(M,S) -> one-to-one;
end;

:: Tree of Execution

definition
  let N be with_non-empty_elements non empty set,
  S be standard (IC-Ins-separated
  definite (non empty stored-program AMI-Struct over N)),
  M be (the Instructions of S)-valued non empty NAT-defined FinPartState of S;
  func ExecTree(M) -> DecoratedTree of NAT means
:: AMISTD_3:def 4

  it.{} = FirstLoc(M) &
  for t being Element of dom it holds
  succ t = { t^<*k*> where k is Element of NAT: k in card NIC(M/.(it.t),it.t) }
   & for m being Element of NAT st m in card
  NIC(M/.(it.t),it.t) holds it.(t^<*m*>) = (LocSeq(NIC(M/.(it.t),it.t),S)).m;
end;

theorem :: AMISTD_3:32
  for S being standard halting realistic (IC-Ins-separated definite
:::   steady-programmed
    (non
  empty stored-program AMI-Struct over N)) holds ExecTree Stop S =
  TrivialInfiniteTree --> 0;

