:: On The Topological Properties of Meet-Continuous Lattices
::  by Artur Korni{\l}owicz
::
:: Received December 20, 1996
:: Copyright (c) 1996 Association of Mizar Users

environ

 vocabulary ORDERS_1, FUNCT_1, SEQM_3, PRE_TOPC, WAYBEL_0, SETFAM_1, SUBSET_1,
      TARSKI, RELAT_2, LATTICE3, LATTICES, RELAT_1, QUANTAL1, WELLORD1,
      YELLOW_0, CAT_1, ORDINAL2, WAYBEL_2, YELLOW_2, FINSUB_1, WELLORD2,
      YELLOW_1, YELLOW_6, BOOLE, PCOMPS_1, NATTRA_1, REALSET1, FINSET_1,
      COMPTS_1, CONNSP_2, TOPS_1, SEQ_2, WAYBEL_7, MCART_1, WAYBEL_9;
 notation TARSKI, XBOOLE_0, SUBSET_1, MCART_1, FINSUB_1, RELAT_1, RELSET_1,
      RELAT_2, FUNCT_1, FINSET_1, SETFAM_1, TOLER_1, PARTFUN1, FUNCT_2,
      STRUCT_0, PRE_TOPC, TOPS_1, TOPS_2, ORDERS_1, COMPTS_1, PCOMPS_1,
      REALSET1, GROUP_1, CONNSP_2, LATTICE3, ORDERS_3, TDLAT_3, YELLOW_0,
      WAYBEL_0, YELLOW_1, YELLOW_2, WAYBEL_1, GRCAT_1, YELLOW_4, WAYBEL_2,
      YELLOW_6;
 constructors FINSUB_1, TOPS_1, PCOMPS_1, CONNSP_2, ORDERS_3, WAYBEL_2,
      YELLOW_4, WAYBEL_1, TOLER_1, TOPS_2, YELLOW_6, TDLAT_3, GROUP_1, GRCAT_1,
      WAYBEL_3;
 clusters STRUCT_0, LATTICE3, WAYBEL_0, YELLOW_6, FUNCT_1, PRE_TOPC, RELSET_1,
      YELLOW_0, TDLAT_3, WAYBEL_2, YELLOW_4, FINSET_1, FINSUB_1, WAYBEL_3,
      FUNCT_2, XBOOLE_0;
 requirements BOOLE, SUBSET;


begin :: Preliminaries

::-------------------------------------------------------------------
:: Acknowledgements:
:: =================
::
:: I would like to thank Professor A. Trybulec for his help in the preparation
:: of the article.
::-------------------------------------------------------------------

registration let L be non empty RelStr;
 cluster id L -> monotone;
coherence by YELLOW_2:13;
end;


definition let S, T be non empty RelStr,
               f be map of S,T;
 redefine attr f is antitone means
:: WAYBEL_9:def 1
  for x, y being Element of S st x <= y holds f.x >= f.y;
end;


theorem :: WAYBEL_9:1
for S, T being RelStr, K, L being non empty RelStr
 for f being map of S, T, g being map of K, L
  st the RelStr of S = the RelStr of K & the RelStr of T = the RelStr of L &
   f = g & f is monotone
 holds g is monotone;

theorem :: WAYBEL_9:2
for S, T being RelStr, K, L being non empty RelStr
 for f being map of S, T, g being map of K, L
  st the RelStr of S = the RelStr of K & the RelStr of T = the RelStr of L &
   f = g & f is antitone
 holds g is antitone;

theorem :: WAYBEL_9:3
for A, B being 1-sorted
 for F being Subset-Family of A,
     G being Subset-Family of B
  st the carrier of A = the carrier of B & F = G & F is_a_cover_of A
 holds G is_a_cover_of B;

theorem :: WAYBEL_9:4
for L being antisymmetric reflexive with_suprema RelStr, x being Element of L
 holds uparrow x = {x} "\/" [#]L;

theorem :: WAYBEL_9:5
for L being antisymmetric reflexive with_infima RelStr, x being Element of L
 holds downarrow x = {x} "/\" [#]L;

theorem :: WAYBEL_9:6
  for L being antisymmetric reflexive with_infima RelStr, y being Element of L
 holds (y"/\").:(uparrow y) = {y};

theorem :: WAYBEL_9:7
for L being antisymmetric reflexive with_infima RelStr, x being Element of L
 holds (x"/\")"{x} = uparrow x;

theorem :: WAYBEL_9:8
for T being non empty 1-sorted, N being non empty NetStr over T
 holds N is_eventually_in rng the mapping of N;

registration let L be non empty reflexive RelStr,
               D be non empty directed Subset of L,
               n be Function of D, the carrier of L;
 cluster NetStr (#D,(the InternalRel of L)|_2 D,n#) -> directed;
coherence by WAYBEL_2:19;
end;


registration let L be non empty reflexive transitive RelStr,
               D be non empty directed Subset of L,
               n be Function of D, the carrier of L;
 cluster NetStr (#D,(the InternalRel of L)|_2 D,n#) -> transitive;
coherence by Lm3;
end;


:: cf WAYBEL_2:42
theorem :: WAYBEL_9:9
for L being non empty reflexive transitive RelStr st
 for x being Element of L, N being net of L st N is eventually-directed
  holds x "/\" sup N = sup ({x} "/\" rng netmap (N,L)) holds
 L is satisfying_MC;

theorem :: WAYBEL_9:10
for L being non empty RelStr, a being Element of L, N being net of L holds
 a "/\" N is net of L;

definition let L be non empty RelStr,
               x be Element of L,
               N be net of L;
 redefine func x "/\" N -> strict net of L;
end;


registration let L be non empty RelStr,
               x be Element of L,
               N be non empty reflexive NetStr over L;
 cluster x "/\" N -> reflexive;
coherence
  proof
      the RelStr of N = the RelStr of x "/\" N by WAYBEL_2:def 3;
    then the InternalRel of x "/\" N is_reflexive_in the carrier of x "/\" N
      by ORDERS_1:def 4;
    hence thesis by ORDERS_1:def 4;
  end;
end;


registration let L be non empty RelStr,
               x be Element of L,
               N be non empty antisymmetric NetStr over L;
 cluster x "/\" N -> antisymmetric;
coherence
  proof
      the RelStr of N = the RelStr of x "/\" N by WAYBEL_2:def 3;
    then the InternalRel of x "/\" N is_antisymmetric_in the carrier of x "/\"
N
      by ORDERS_1:def 6;
    hence thesis by ORDERS_1:def 6;
  end;
end;


registration let L be non empty RelStr,
               x be Element of L,
               N be non empty transitive NetStr over L;
 cluster x "/\" N -> transitive;
coherence
  proof
      the RelStr of N = the RelStr of x "/\" N by WAYBEL_2:def 3;
    then the InternalRel of x "/\" N is_transitive_in the carrier of x "/\" N
      by ORDERS_1:def 5;
    hence thesis by ORDERS_1:def 5;
  end;
end;


registration let L be non empty RelStr,
               J be set,
               f be Function of J,the carrier of L;
 cluster FinSups f -> transitive;
coherence
  proof
    let x, y, z be Element of FinSups f such that
A1:   x <= y & y <= z;
    consider g being Function of Fin J, the carrier of L such that
A2:  for x being Element of Fin J holds g.x = sup (f.:x) &
      FinSups f = NetStr (# Fin J, RelIncl Fin J, g #) by WAYBEL_2:def 2;
A3: InclPoset Fin J = RelStr(#Fin J, RelIncl Fin J#) by YELLOW_1:def 1;
    then reconsider x1 = x, y1 = y, z1 = z as Element of InclPoset Fin J
      by A2;
      x1 <= y1 & y1 <= z1 by A1,A2,A3,YELLOW_0:1;
    then x1 c= y1 & y1 c= z1 by YELLOW_1:3;
    then x1 c= z1 by XBOOLE_1:1;
    then x1 <= z1 by YELLOW_1:3;
    hence x <= z by A2,A3,YELLOW_0:1;
  end;
end;



begin :: The Operations Defined on Nets

definition let L be non empty RelStr,
               N be NetStr over L;
 func inf N -> Element of L equals
:: WAYBEL_9:def 2
   Inf the mapping of N;
end;


definition let L be RelStr,
               N be NetStr over L;
 pred ex_sup_of N means
:: WAYBEL_9:def 3
  ex_sup_of rng the mapping of N,L;
 pred ex_inf_of N means
:: WAYBEL_9:def 4
  ex_inf_of rng the mapping of N,L;
end;


definition let L be RelStr;
 func L+id -> strict NetStr over L means
:: WAYBEL_9:def 5
  the RelStr of it = the RelStr of L &
  the mapping of it = id L;
end;


registration let L be non empty RelStr;
 cluster L+id -> non empty;
coherence
  proof
      the RelStr of L = the RelStr of L+id by Def5;
    hence thesis by STRUCT_0:def 1;
  end;
end;


registration let L be reflexive RelStr;
 cluster L+id -> reflexive;
coherence
  proof
      the RelStr of L = the RelStr of L+id by Def5;
    then the InternalRel of L+id is_reflexive_in the carrier of L+id
      by ORDERS_1:def 4;
    hence thesis by ORDERS_1:def 4;
  end;
end;


registration let L be antisymmetric RelStr;
 cluster L+id -> antisymmetric;
coherence
  proof
      the RelStr of L = the RelStr of L+id by Def5;
    then the InternalRel of L+id is_antisymmetric_in the carrier of L+id
      by ORDERS_1:def 6;
    hence thesis by ORDERS_1:def 6;
  end;
end;


registration let L be transitive RelStr;
 cluster L+id -> transitive;
coherence
  proof
      the RelStr of L = the RelStr of L+id by Def5;
    then the InternalRel of L+id is_transitive_in the carrier of L+id
      by ORDERS_1:def 5;
    hence thesis by ORDERS_1:def 5;
  end;
end;


registration let L be with_suprema RelStr;
 cluster L+id -> directed;
coherence
  proof
A1: the RelStr of L = the RelStr of L+id by Def5;
      [#]L = the carrier of L by PRE_TOPC:12
      .= [#](L+id) by A1,PRE_TOPC:12;
    hence [#](L+id) is directed by A1,WAYBEL_0:3;
  end;
end;


registration let L be directed RelStr;
 cluster L+id -> directed;
coherence
  proof
A1: [#]L is directed by WAYBEL_0:def 6;
A2: the RelStr of L = the RelStr of L+id by Def5;
      [#]L = the carrier of L by PRE_TOPC:12
      .= [#](L+id) by A2,PRE_TOPC:12;
    hence [#](L+id) is directed by A1,A2,WAYBEL_0:3;
  end;
end;


registration let L be non empty RelStr;
 cluster L+id -> monotone eventually-directed;
coherence
  proof
    set N = L+id;
    thus N is monotone
    proof
A1:   netmap(N,L)
         = the mapping of N by WAYBEL_0:def 7
        .= id L by Def5;
    the RelStr of N = the RelStr of L by Def5;
      hence netmap(L+id,L) is monotone by A1,Th1;
    end;
      for i being Element of N ex j being Element of N st
     for k being Element of N st j <= k holds N.i <= N.k
    proof
      let i be Element of N;
      take j = i;
      let k be Element of N such that
A2:     j <= k;
A3:   the RelStr of N = the RelStr of L by Def5;
        the mapping of N = id L by Def5;
      then (the mapping of N).i = i & (the mapping of N).k = k by A3,TMAP_1:91
;
        then N.i = i & N.k = k by WAYBEL_0:def 8;
      hence N.i <= N.k by A2,A3,YELLOW_0:1;
    end;
    hence thesis by WAYBEL_0:11;
  end;
end;


definition let L be RelStr;
 func L opp+id -> strict NetStr over L means
:: WAYBEL_9:def 6
  the carrier of it = the carrier of L &
  the InternalRel of it = (the InternalRel of L)~ &
  the mapping of it = id L;
end;


theorem :: WAYBEL_9:11
for L being RelStr holds the RelStr of L~ = the RelStr of L opp+id;

registration let L be non empty RelStr;
 cluster L opp+id -> non empty;
coherence
  proof
      the RelStr of L~ = the RelStr of L opp+id by Th11;
    hence thesis by STRUCT_0:def 1;
  end;
end;


registration let L be reflexive RelStr;
 cluster L opp+id -> reflexive;
coherence
  proof
      the InternalRel of L is_reflexive_in the carrier of L by ORDERS_1:def 4;
      then A1: (the InternalRel of L)~ is_reflexive_in the carrier of L by
ORDERS_2:91;
      the InternalRel of L opp+id = (the InternalRel of L)~ by Def6;
    hence the InternalRel of L opp+id is_reflexive_in the carrier
     of L opp+id by A1,Def6;
  end;
end;


registration let L be antisymmetric RelStr;
 cluster L opp+id -> antisymmetric;
coherence
  proof
      the InternalRel of L is_antisymmetric_in the carrier of L
      by ORDERS_1:def 6;
then A1: (the InternalRel of L)~ is_antisymmetric_in the carrier of L
      by ORDERS_2:93;
      the InternalRel of L opp+id = (the InternalRel of L)~ by Def6;
    then the InternalRel of L opp+id is_antisymmetric_in
      the carrier of L opp+id by A1,Def6;
    hence thesis by ORDERS_1:def 6;
  end;
end;


registration let L be transitive RelStr;
 cluster L opp+id -> transitive;
coherence
  proof
      the InternalRel of L is_transitive_in the carrier of L
      by ORDERS_1:def 5;
then A1: (the InternalRel of L)~ is_transitive_in the carrier of L
      by ORDERS_2:92;
      the InternalRel of L opp+id = (the InternalRel of L)~ by Def6;
    then the InternalRel of L opp+id is_transitive_in
      the carrier of L opp+id by A1,Def6;
    hence thesis by ORDERS_1:def 5;
  end;
end;


registration let L be with_infima RelStr;
 cluster L opp+id -> directed;
coherence
  proof
A1: the RelStr of L~ = the RelStr of L opp+id by Th11;
    reconsider A = L~ as with_suprema RelStr by YELLOW_7:16;
      [#]A = the carrier of A by PRE_TOPC:12
      .= the carrier of L by YELLOW_6:12
      .= the carrier of L opp+id by Def6
      .= [#](L opp+id) by PRE_TOPC:12;
    hence [#](L opp+id) is directed by A1,WAYBEL_0:3;
  end;
end;


registration let L be non empty RelStr;
 cluster L opp+id -> antitone eventually-filtered;
coherence
  proof
    set N = L opp+id;
    thus N is antitone
    proof
A1:   netmap(N,L)
         = the mapping of N by WAYBEL_0:def 7
        .= id L by Def6;
A2:   the RelStr of L opp+id = the RelStr of L~ by Th11;
      reconsider f = id L as map of L~, L by YELLOW_7:39;
      reconsider g = f as map of L, L~ by YELLOW_7:39;
A3:   the RelStr of L = the RelStr of L;
        g is antitone by YELLOW_7:40;
      then f is antitone by YELLOW_7:41;
      hence netmap(N,L) is antitone by A1,A2,A3,Th2;
    end;
      for i being Element of N ex j being Element of N st
     for k being Element of N st j <= k holds N.i >= N.k
    proof
      let i be Element of N;
      take j = i;
      let k be Element of N such that
A4:     j <= k;
      reconsider i1 = i, k1 = k as Element of L
        by Def6;
A5:   (id L).i1 = i1 & (id L).k1 = k1 by TMAP_1:91;
        the mapping of N = id L by Def6;
then A6:   N.i = i & N.k = k by A5,WAYBEL_0:def 8;
      A7: the InternalRel of N = (the InternalRel of L)~ by Def6;
        [i,k] in the InternalRel of N by A4,ORDERS_1:def 9;
      then [k,i] in (the InternalRel of N)~ by RELAT_1:def 7;
      hence N.k <= N.i by A6,A7,ORDERS_1:def 9;
    end;
    hence thesis by WAYBEL_0:12;
  end;
end;


definition let L be non empty 1-sorted,
               N be non empty NetStr over L,
               i be Element of N;
 func N|i -> strict NetStr over L means
:: WAYBEL_9:def 7
  (for x being set holds x in the carrier of it iff ex y being Element of N
    st y = x & i <= y) &
  the InternalRel of it = (the InternalRel of N)|_2 the carrier of it &
  the mapping of it = (the mapping of N)|the carrier of it;
end;


theorem :: WAYBEL_9:12
  for L being non empty 1-sorted, N being non empty NetStr over L
 for i being Element of N holds
  the carrier of N|i = { y where y is Element of N : i <= y };

theorem :: WAYBEL_9:13
for L being non empty 1-sorted, N being non empty NetStr over L
 for i being Element of N holds the carrier of N|i c= the carrier of N;

theorem :: WAYBEL_9:14
for L being non empty 1-sorted, N being non empty NetStr over L
 for i being Element of N holds N|i is full SubNetStr of N;

registration let L be non empty 1-sorted,
               N be non empty reflexive NetStr over L,
               i be Element of N;
 cluster N|i -> non empty reflexive;
coherence
  proof
    thus N|i is non empty
    proof
        i <= i;
      then i in the carrier of N|i by Def7;
      hence thesis by STRUCT_0:def 1;
    end;
    then reconsider A = N|i as strict non empty NetStr over L;
      A is reflexive
    proof
      let x be Element of A;
      consider y being Element of N such that
A1:     y = x and i <= y by Def7;
A2:   N|i is full SubNetStr of N by Th14;
        y <= y;
      hence x <= x by A1,A2,YELLOW_6:21;
    end;
    hence thesis;
  end;
end;


registration let L be non empty 1-sorted,
               N be non empty directed NetStr over L,
               i be Element of N;
 cluster N|i -> non empty;
coherence
  proof
    consider z1 being Element of N such that
A1:   i <= z1 & i <= z1 by YELLOW_6:def 5;
      z1 in the carrier of N|i by A1,Def7;
    hence thesis by STRUCT_0:def 1;
  end;
end;


registration let L be non empty 1-sorted,
               N be non empty reflexive antisymmetric NetStr over L,
               i be Element of N;
 cluster N|i -> antisymmetric;
coherence
  proof
    let x, y be Element of N|i such that
A1:   x <= y & y <= x;
A2: N|i is SubNetStr of N by Th14;
    consider x1 being Element of N such that
A3:   x1 = x and i <= x1 by Def7;
    consider y1 being Element of N such that
A4:   y1 = y and i <= y1 by Def7;
      x1 <= y1 & y1 <= x1 by A1,A2,A3,A4,YELLOW_6:20;
    hence x = y by A3,A4,YELLOW_0:def 3;
  end;
end;


registration let L be non empty 1-sorted,
               N be non empty directed antisymmetric NetStr over L,
               i be Element of N;
 cluster N|i -> antisymmetric;
coherence
  proof
    let x, y be Element of N|i such that
A1:   x <= y & y <= x;
A2: N|i is SubNetStr of N by Th14;
    consider x1 being Element of N such that
A3:   x1 = x and i <= x1 by Def7;
    consider y1 being Element of N such that
A4:   y1 = y and i <= y1 by Def7;
      x1 <= y1 & y1 <= x1 by A1,A2,A3,A4,YELLOW_6:20;
    hence x = y by A3,A4,YELLOW_0:def 3;
  end;
end;


registration let L be non empty 1-sorted,
               N be non empty reflexive transitive NetStr over L,
               i be Element of N;
 cluster N|i -> transitive;
coherence
  proof
    let x, y, z be Element of N|i such that
A1:   x <= y & y <= z;
A2: N|i is full SubNetStr of N by Th14;
    consider x1 being Element of N such that
A3:   x1 = x and i <= x1 by Def7;
    consider y1 being Element of N such that
A4:   y1 = y and i <= y1 by Def7;
    consider z1 being Element of N such that
A5:   z1 = z and i <= z1 by Def7;
      x1 <= y1 & y1 <= z1 by A1,A2,A3,A4,A5,YELLOW_6:20;
    then x1 <= z1 by YELLOW_0:def 2;
    hence x <= z by A2,A3,A5,YELLOW_6:21;
  end;
end;


registration let L be non empty 1-sorted,
               N be net of L,
               i be Element of N;
 cluster N|i -> transitive directed;
coherence
  proof
    thus N|i is transitive
    proof
      let x, y, z be Element of N|i such that
A1:     x <= y & y <= z;
A2:   N|i is full SubNetStr of N by Th14;
      consider x1 being Element of N such that
A3:     x1 = x and i <= x1 by Def7;
      consider y1 being Element of N such that
A4:     y1 = y and i <= y1 by Def7;
      consider z1 being Element of N such that
A5:     z1 = z and i <= z1 by Def7;
        x1 <= y1 & y1 <= z1 by A1,A2,A3,A4,A5,YELLOW_6:20;
      then x1 <= z1 by YELLOW_0:def 2;
      hence x <= z by A2,A3,A5,YELLOW_6:21;
    end;
      for x, y being Element of N|i ex z being Element of N|i st x <= z & y <=
z
    proof
      let x, y be Element of N|i;
      consider x1 being Element of N such that
A6:     x1 = x and
A7:     i <= x1 by Def7;
      consider y1 being Element of N such that
A8:     y1 = y and i <= y1 by Def7;
      consider z1 being Element of N such that
A9:     x1 <= z1 & y1 <= z1 by YELLOW_6:def 5;
        i <= z1 by A7,A9,YELLOW_0:def 2;
      then z1 in the carrier of N|i by Def7;
      then reconsider z = z1 as Element of N|i;
      take z;
        N|i is full SubNetStr of N by Th14;
      hence x <= z & y <= z by A6,A8,A9,YELLOW_6:21;
    end;
    hence thesis by YELLOW_6:def 5;
  end;
end;


theorem :: WAYBEL_9:15
  for L being non empty 1-sorted, N being non empty reflexive NetStr over L
 for i, x being Element of N, x1 being Element of N|i st x = x1
  holds N.x = (N|i).x1;

theorem :: WAYBEL_9:16
for L being non empty 1-sorted, N being non empty directed NetStr over L
 for i, x being Element of N, x1 being Element of N|i st x = x1
  holds N.x = (N|i).x1;

theorem :: WAYBEL_9:17
for L being non empty 1-sorted, N being net of L, i being Element of N
 holds N|i is subnet of N;

registration let T be non empty 1-sorted,
               N be net of T;
 cluster strict subnet of N;
existence
  proof
    set A = NetStr (#the carrier of N,the InternalRel of N,the mapping of N#);
A1: the RelStr of A = the RelStr of N;
  A is directed
    proof
A2:   [#]N is directed by WAYBEL_0:def 6;
        [#]N = the carrier of N by PRE_TOPC:12
        .= [#]A by PRE_TOPC:12;
      hence [#]A is directed by A1,A2,WAYBEL_0:3;
    end;
    then reconsider A as net of T by A1,WAYBEL_8:13;
      A is subnet of N
    proof
      reconsider f = id N as map of A, N;
      take f;
      thus the mapping of A = (the mapping of N)*f by TMAP_1:93;
      let m be Element of N;
      reconsider n = m as Element of A;
      take n;
      let p be Element of A such that
A3:     n <= p;
        p = f.p by TMAP_1:91;
      hence m <= f.p by A1,A3,YELLOW_0:1;
    end;
    then reconsider A as subnet of N;
    take A;
    thus thesis;
  end;
end;


definition let L be non empty 1-sorted,
               N be net of L,
               i be Element of N;
 redefine func N|i -> strict subnet of N;
end;


definition let S be non empty 1-sorted,
               T be 1-sorted,
               f be map of S, T,
               N be NetStr over S;
 func f * N -> strict NetStr over T means
:: WAYBEL_9:def 8
  the RelStr of it = the RelStr of N &
  the mapping of it = f * the mapping of N;
end;


registration let S be non empty 1-sorted,
               T be 1-sorted,
               f be map of S, T,
               N be non empty NetStr over S;
 cluster f * N -> non empty;
coherence
  proof
      the RelStr of N = the RelStr of f * N by Def8;
    hence thesis by STRUCT_0:def 1;
  end;
end;


registration let S be non empty 1-sorted,
               T be 1-sorted,
               f be map of S, T,
               N be reflexive NetStr over S;
 cluster f * N -> reflexive;
coherence
  proof
      the RelStr of N = the RelStr of f * N by Def8;
    hence the InternalRel of f*N is_reflexive_in the carrier of f*N
      by ORDERS_1:def 4;
  end;
end;


registration let S be non empty 1-sorted,
               T be 1-sorted,
               f be map of S, T,
               N be antisymmetric NetStr over S;
 cluster f * N -> antisymmetric;
coherence
  proof
      the RelStr of N = the RelStr of f * N by Def8;
    then the InternalRel of f*N is_antisymmetric_in the carrier of f*N
      by ORDERS_1:def 6;
    hence thesis by ORDERS_1:def 6;
  end;
end;


registration let S be non empty 1-sorted,
               T be 1-sorted,
               f be map of S, T,
               N be transitive NetStr over S;
 cluster f * N -> transitive;
coherence
  proof
      the RelStr of N = the RelStr of f * N by Def8;
    then the InternalRel of f*N is_transitive_in the carrier of f*N
      by ORDERS_1:def 5;
    hence thesis by ORDERS_1:def 5;
  end;
end;


registration let S be non empty 1-sorted,
               T be 1-sorted,
               f be map of S, T,
               N be directed NetStr over S;
 cluster f * N -> directed;
coherence
  proof
A1: the RelStr of N = the RelStr of f * N by Def8;
    thus [#](f*N) is directed
    proof
A2:   [#]N is directed by WAYBEL_0:def 6;
        [#](f*N) = the carrier of f*N by PRE_TOPC:12
            .= [#]N by A1,PRE_TOPC:12;
      hence thesis by A1,A2,WAYBEL_0:3;
    end;
  end;
end;


theorem :: WAYBEL_9:18
for L being non empty RelStr, N being non empty NetStr over L
 for x being Element of L holds (x"/\")*N = x "/\" N;


begin :: The Properties of Topological Spaces

theorem :: WAYBEL_9:19
for S, T being TopStruct
 for F being Subset-Family of S,
     G being Subset-Family of T
  st the TopStruct of S = the TopStruct of T & F = G & F is open
 holds G is open;

theorem :: WAYBEL_9:20
  for S, T being TopStruct
 for F being Subset-Family of S, G being Subset-Family of T
  st the TopStruct of S = the TopStruct of T & F = G & F is closed
 holds G is closed;

definition
  struct(TopStruct,RelStr) TopRelStr (# carrier -> set,
             InternalRel -> (Relation of the carrier),
             topology -> Subset-Family of the carrier #);
end;


registration let A be non empty set,
               R be Relation of A,A,
               T be Subset-Family of A;
 cluster TopRelStr (#A,R,T#) -> non empty;
coherence
  proof
    thus the carrier of TopRelStr (#A,R,T#) is non empty;
  end;
end;


registration let x be set,
               R be Relation of {x};
           let T be Subset-Family of {x};
 cluster TopRelStr (#{x}, R, T#) -> trivial;
coherence
  proof
    let a, b be Element of TopRelStr (#{x},R,T#);
      a = x & b = x by TARSKI:def 1;
    hence thesis;
  end;
end;


registration let X be set,
               O be Order of X,
               T be Subset-Family of X;
 cluster TopRelStr (#X, O, T#) -> reflexive transitive antisymmetric;
coherence
  proof
    set A = TopRelStr(#X,O,T#);
  field the InternalRel of A = the carrier of A by ORDERS_1:97;
  then
      the InternalRel of A is_reflexive_in the carrier of A &
    the InternalRel of A is_transitive_in the carrier of A &
    the InternalRel of A is_antisymmetric_in the carrier of A
                        by RELAT_2:def 9,def 12,def 16;
    hence thesis by ORDERS_1:def 4,def 5,def 6;
  end;
end;

registration
 cluster trivial reflexive non empty discrete strict finite TopRelStr;
existence
  proof
      {{},{0}} = bool {0} & bool {0} c= bool {0} by ZFMISC_1:30;
    then reconsider tau = {{},{0}} as Subset-Family of {0};
      0 in {0} by TARSKI:def 1;
    then reconsider r = {[0,0]} as Relation of {0} by RELSET_1:8;
    take TopRelStr (#{0},r,tau#);
    thus thesis by Lm4;
  end;
end;


definition
 mode TopLattice is with_infima with_suprema
  reflexive transitive antisymmetric TopSpace-like TopRelStr;
end;


registration
 cluster strict non empty trivial discrete finite compact Hausdorff
         TopLattice;
existence
  proof
A1: {{},{0}} = bool {0} & bool {0} c= bool {0} by ZFMISC_1:30;
      0 in {0} by TARSKI:def 1;
    then reconsider r = {[0,0]} as Relation of {0} by RELSET_1:8;
A2: 1TopSp {0} = TopStruct (# {0}, bool {0}#) by PCOMPS_1:def 1;
    reconsider C = bool {0} as Subset-Family of {0};
    reconsider A = TopRelStr (#{0}, r, C#)
    as trivial reflexive non empty discrete finite TopRelStr by A1,Lm4;
    reconsider A as TopLattice;
    take A;
    thus A is strict non empty trivial discrete finite;
    thus A is compact
    proof
      let F be Subset-Family of A such that
A3:     F is_a_cover_of A and
A4:     F is open;
      reconsider F1 = F as Subset-Family of 1TopSp {0} by A2;
A5:   F1 is_a_cover_of 1TopSp {0} by A2,A3,Th3;
A6:   F1 is open by A2,A4,Th19;
        1TopSp {0} is compact by PCOMPS_1:9;
      then consider G1 being Subset-Family of 1TopSp {0} such that
A7:     G1 c= F1 and
A8:     G1 is_a_cover_of 1TopSp {0} and
A9:     G1 is finite by A5,A6,COMPTS_1:def 3;
      reconsider G = G1 as Subset-Family of A by A2;
      take G;
      thus G c= F by A7;
      thus G is_a_cover_of A by A2,A8,Th3;
      thus G is finite by A9;
    end;
    let p, q be Point of A such that
A10:   not p = q;
    assume not ex W, V being Subset of A
      st W is open & V is open & p in W & q in V & W misses V;
      p = 0 & q = 0 by TARSKI:def 1;
    hence contradiction by A10;
  end;
end;


registration let T be Hausdorff (non empty TopSpace);
 cluster -> Hausdorff (non empty SubSpace of T);
coherence by TOPMETR:3;
end;


theorem :: WAYBEL_9:21
for T being non empty TopSpace, p being Point of T
 for A being Element of OpenNeighborhoods p holds A is a_neighborhood of p;

theorem :: WAYBEL_9:22
for T being non empty TopSpace, p being Point of T
 for A, B being Element of OpenNeighborhoods p
  holds A /\ B is Element of OpenNeighborhoods p;

theorem :: WAYBEL_9:23
  for T being non empty TopSpace, p being Point of T
 for A, B being Element of OpenNeighborhoods p
  holds A \/ B is Element of OpenNeighborhoods p;

theorem :: WAYBEL_9:24
for T being non empty TopSpace, p being Element of T
 for N being net of T st p in Lim N
  for S being Subset of T st S = rng the mapping of N
   holds p in Cl S;

theorem :: WAYBEL_9:25
for T being Hausdorff TopLattice, N being convergent net of T
 for f being map of T, T st f is continuous
  holds f.(lim N) in Lim (f * N);

theorem :: WAYBEL_9:26
for T being Hausdorff TopLattice, N being convergent net of T
 for x being Element of T st x"/\" is continuous
  holds x "/\" lim N in Lim (x "/\" N);

theorem :: WAYBEL_9:27
for S being Hausdorff TopLattice, x being Element of S st
 for a being Element of S holds a"/\" is continuous holds uparrow x is closed;

theorem :: WAYBEL_9:28
for S being compact Hausdorff TopLattice, x being Element of S st
 for b being Element of S holds b"/\" is continuous holds downarrow x is closed
;

begin :: The Cluster Points of Nets

definition let T be non empty TopSpace,
               N be non empty NetStr over T,
               p be Point of T;
 pred p is_a_cluster_point_of N means
:: WAYBEL_9:def 9
  for O being a_neighborhood of p holds N is_often_in O;
end;


theorem :: WAYBEL_9:29
  for L being non empty TopSpace, N being net of L
 for c being Point of L st c in Lim N holds c is_a_cluster_point_of N;

theorem :: WAYBEL_9:30
for T being compact Hausdorff (non empty TopSpace), N being net of T
 ex c being Point of T st c is_a_cluster_point_of N;

theorem :: WAYBEL_9:31
for L being non empty TopSpace, N being net of L, M being subnet of N
 for c being Point of L st c is_a_cluster_point_of M holds
  c is_a_cluster_point_of N;

theorem :: WAYBEL_9:32
for T being non empty TopSpace, N being net of T
 for x being Point of T st x is_a_cluster_point_of N holds
  ex M being subnet of N st x in Lim M;

theorem :: WAYBEL_9:33
for L being compact Hausdorff (non empty TopSpace), N being net of L st
 for c, d being Point of L st c is_a_cluster_point_of N &
  d is_a_cluster_point_of N holds c = d holds
 for s being Point of L st s is_a_cluster_point_of N holds s in Lim N;

theorem :: WAYBEL_9:34
for S being non empty TopSpace, c being Point of S
 for N being net of S, A being Subset of S st c is_a_cluster_point_of N &
  A is closed & rng the mapping of N c= A
 holds c in A;

theorem :: WAYBEL_9:35
for S being compact Hausdorff TopLattice, c being Point of S
 for N being net of S st
  (for x being Element of S holds x"/\" is continuous) &
  N is eventually-directed & c is_a_cluster_point_of N
 holds c = sup N;

theorem :: WAYBEL_9:36
for S being compact Hausdorff TopLattice, c being Point of S
 for N being net of S st
  (for x being Element of S holds x"/\" is continuous) &
  N is eventually-filtered & c is_a_cluster_point_of N
 holds c = inf N;


begin :: On The Topological Properties of Meet-Continuous Lattices

:: Proposition 4.4 s. 32     (i) & (ii) => MC
theorem :: WAYBEL_9:37
for S being Hausdorff TopLattice st
 (for N being net of S st N is eventually-directed
   holds ex_sup_of N & sup N in Lim N) &
 (for x being Element of S holds x"/\" is continuous) holds
  S is meet-continuous;

:: Proposition 4.4 s. 32      (ii) => (i)
theorem :: WAYBEL_9:38
for S being compact Hausdorff TopLattice st
 for x being Element of S holds x"/\" is continuous
  holds
 for N being net of S st N is eventually-directed
  holds ex_sup_of N & sup N in Lim N;

:: Proposition 4.4 s. 32      (ii) => (i) dual
theorem :: WAYBEL_9:39
for S being compact Hausdorff TopLattice st
 for x being Element of S holds x"/\" is continuous
  holds
 for N being net of S st N is eventually-filtered holds
  ex_inf_of N & inf N in Lim N;

theorem :: WAYBEL_9:40
  for S being compact Hausdorff TopLattice st
 for x being Element of S holds x"/\" is continuous
  holds S is bounded;

theorem :: WAYBEL_9:41
  for S being compact Hausdorff TopLattice st
 for x being Element of S holds x"/\" is continuous holds
  S is meet-continuous;
