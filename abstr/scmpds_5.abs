:: Computation of Two Consecutive Program Blocks for SCMPDS
::  by JingChao Chen
::
:: Received June 15, 1999
:: Copyright (c) 1999 Association of Mizar Users

environ

 vocabulary AMI_3, SCMPDS_2, AMI_1, INT_1, SCMPDS_4, FUNCT_1, RELAT_1,
      SCMFSA_7, SCMPDS_3, CAT_1, RELOC, CARD_1, SCMFSA6A, FUNCT_4, BOOLE,
      SCMFSA6B, FUNCT_7, SCM_1, AMI_2, AMI_5, SCMPDS_1, ABSVALUE, NAT_1,
      ARYTM_1, SCMPDS_5;
 notation TARSKI, XBOOLE_0, ENUMSET1, XCMPLX_0, XREAL_0, RELAT_1, FUNCT_1,
      FUNCT_4, INT_1, NAT_1, STRUCT_0, AMI_1, AMI_2, AMI_3, AMI_5, FUNCT_7,
      SCMPDS_1, SCMPDS_2, GROUP_1, SCMPDS_3, CARD_1, SCMPDS_4, SCM_1;
 constructors DOMAIN_1, NAT_1, AMI_5, SCMPDS_1, SCMFSA_4, SCMPDS_4, SCM_1,
      MEMBERED;
 clusters AMI_1, INT_1, FUNCT_1, SCMPDS_2, PRELAMB, SCMFSA_4, SCMPDS_4,
      FRAENKEL, MEMBERED;
 requirements NUMERALS, REAL, SUBSET, BOOLE, ARITHM;


begin :: Preliminaries
reserve x for set,
        m,n for Nat,
        a,b,c for Int_position,
        i for Instruction of SCMPDS,
        s,s1,s2 for State of SCMPDS,
        k1,k2 for Integer,
        loc,l1 for Instruction-Location of SCMPDS,
        I,J for Program-block,
        N for with_non-empty_elements set;

theorem :: SCMPDS_5:1   :: S6B15
for S being halting IC-Ins-separated definite
   (non empty non void AMI-Struct over N),
    s being State of S st s = Following s
    holds for n holds (Computation s).n = s;

theorem :: SCMPDS_5:2
  x in dom Load i iff x = inspos 0;

theorem :: SCMPDS_5:3     :: Stp
   loc in dom (stop I) & (stop I).loc <> halt SCMPDS
   implies loc in dom I;

theorem :: SCMPDS_5:4     :: PDS4_72
     dom Load i = {inspos 0} & (Load i).(inspos 0)=i;

theorem :: SCMPDS_5:5
     inspos 0 in dom Load i;

theorem :: SCMPDS_5:6    :: PDS4_74
   card Load i = 1;

theorem :: SCMPDS_5:7   ::CardsI
 card stop I = card I + 1;

theorem :: SCMPDS_5:8
 card stop Load i = 2;

theorem :: SCMPDS_5:9   ::PDS4_75
 inspos 0 in dom stop (Load i) & inspos 1 in dom stop (Load i);

theorem :: SCMPDS_5:10
  (stop Load i).inspos 0=i & (stop Load i).inspos 1=halt SCMPDS;

theorem :: SCMPDS_5:11    ::SCMFSA6B_32
  x in dom (stop Load i) iff x=inspos 0 or x=inspos 1;

theorem :: SCMPDS_5:12
    dom (stop Load i)={inspos 0,inspos 1};

theorem :: SCMPDS_5:13
  inspos 0 in dom (Initialized stop Load i) &
  inspos 1 in dom (Initialized stop Load i) &
  (Initialized stop Load i).inspos 0=i &
  (Initialized stop Load i).inspos 1=halt SCMPDS;

theorem :: SCMPDS_5:14
 for I,J being Program-block holds
  Initialized stop (I ';' J) =
    (I ';' (J ';' SCMPDS-Stop)) +* Start-At inspos 0;

theorem :: SCMPDS_5:15
 for I,J being Program-block holds
  Initialized I c= Initialized stop (I ';' J);

theorem :: SCMPDS_5:16
   dom stop I c= dom stop (I ';' J);

theorem :: SCMPDS_5:17    :: SCMPDS_4:42,T6A40
 for I,J being Program-block holds
     Initialized stop I +* Initialized stop (I ';' J)
     = Initialized stop (I ';' J);

theorem :: SCMPDS_5:18
  Initialized I c= s implies IC s = inspos 0;

theorem :: SCMPDS_5:19
  (s +* Initialized I).a = s.a;

theorem :: SCMPDS_5:20  ::T13
 for I being parahalting Program-block st
     Initialized stop I c= s1 & Initialized stop I c= s2 &
     s1,s2 equal_outside the Instruction-Locations of SCMPDS holds
 for k being Nat holds
     (Computation s1).k, (Computation s2).k
         equal_outside the Instruction-Locations of SCMPDS &
     CurInstr (Computation s1).k = CurInstr (Computation s2).k;

theorem :: SCMPDS_5:21  ::T14
 for I being parahalting Program-block st
     Initialized stop I c= s1 & Initialized stop I c= s2 &
     s1,s2 equal_outside the Instruction-Locations of SCMPDS holds
 LifeSpan s1 = LifeSpan s2 &
     Result s1, Result s2 equal_outside the Instruction-Locations of SCMPDS;

theorem :: SCMPDS_5:22  ::T27
 for I being Program-block
  holds IC IExec(I,s) = IC Result (s +* Initialized stop I);

theorem :: SCMPDS_5:23
 for I being parahalting Program-block, J being Program-block
   st Initialized stop I c= s
 for m st m <= LifeSpan s
  holds (Computation s).m,(Computation(s+*(I ';' J))).m
    equal_outside the Instruction-Locations of SCMPDS;

theorem :: SCMPDS_5:24
 for I being parahalting Program-block, J being Program-block
   st Initialized stop I c= s
 for m st m <= LifeSpan s
  holds (Computation s).m,(Computation(s+*Initialized stop (I ';' J))).m
    equal_outside the Instruction-Locations of SCMPDS;

begin :: Non halting instrutions and parahalting instrutions

definition let i be Instruction of SCMPDS;
 attr i is No-StopCode means
:: SCMPDS_5:def 1
   i <> halt SCMPDS;
end;


definition
 let i be Instruction of SCMPDS;
 attr i is parahalting means
:: SCMPDS_5:def 2
   Load i is parahalting;
end;


registration
 cluster No-StopCode shiftable parahalting Instruction of SCMPDS;
 existence proof
  take i=DataLoc(0,0):=0;
A1:InsCode i=2 by SCMPDS_2:23;
     InsCode halt SCMPDS=0 by SCMPDS_2:21,93;
   hence thesis by A1,Def1,Def2,Lm1;
 end;
end;


theorem :: SCMPDS_5:25
     k1 <>0 implies goto k1 is No-StopCode;

registration
 let a;
 cluster return a -> No-StopCode;
 coherence
 proof
    set i=return a;
A1: InsCode i=1 by SCMPDS_2:22;
     InsCode halt SCMPDS=0 by SCMPDS_2:21,93;
   hence thesis by A1,Def1;
 end;
end;


registration
 let a,k1;
 cluster a := k1 -> No-StopCode;
 coherence
 proof
    set i=a:=k1;
A1: InsCode i=2 by SCMPDS_2:23;
     InsCode halt SCMPDS=0 by SCMPDS_2:21,93;
   hence thesis by A1,Def1;
 end;

 cluster saveIC(a,k1) -> No-StopCode;
 coherence
 proof
    set i=saveIC(a,k1);
A2: InsCode i=3 by SCMPDS_2:24;
     InsCode halt SCMPDS=0 by SCMPDS_2:21,93;
   hence thesis by A2,Def1;
 end;
end;


registration
 let a,k1,k2;
 cluster (a,k1)<>0_goto k2 -> No-StopCode;
 coherence
 proof
    set i=(a,k1)<>0_goto k2;
A1: InsCode i=4 by SCMPDS_2:25;
     InsCode halt SCMPDS=0 by SCMPDS_2:21,93;
   hence thesis by A1,Def1;
 end;

 cluster (a,k1)<=0_goto k2 -> No-StopCode;
 coherence
 proof
    set i=(a,k1)<=0_goto k2;
A2: InsCode i=5 by SCMPDS_2:26;
     InsCode halt SCMPDS=0 by SCMPDS_2:21,93;
   hence thesis by A2,Def1;
 end;

 cluster (a,k1)>=0_goto k2 -> No-StopCode;
 coherence
 proof
    set i=(a,k1)>=0_goto k2;
A3: InsCode i=6 by SCMPDS_2:27;
     InsCode halt SCMPDS=0 by SCMPDS_2:21,93;
   hence thesis by A3,Def1;
 end;

 cluster (a,k1) := k2 -> No-StopCode;
 coherence
 proof
    set i=(a,k1) := k2;
A4: InsCode i=7 by SCMPDS_2:28;
     InsCode halt SCMPDS=0 by SCMPDS_2:21,93;
   hence thesis by A4,Def1;
 end;
end;


registration
 let a,k1,k2;
 cluster AddTo(a,k1,k2) -> No-StopCode;
 coherence
 proof
    set i=AddTo(a,k1,k2);
A1: InsCode i=8 by SCMPDS_2:29;
     InsCode halt SCMPDS=0 by SCMPDS_2:21,93;
   hence thesis by A1,Def1;
 end;
end;


registration
 let a,b,k1,k2;
cluster AddTo(a,k1,b,k2) -> No-StopCode;
 coherence
 proof
    set i=AddTo(a,k1,b,k2);
A1: InsCode i=9 by SCMPDS_2:30;
     InsCode halt SCMPDS=0 by SCMPDS_2:21,93;
   hence thesis by A1,Def1;
 end;

cluster SubFrom(a,k1,b,k2) -> No-StopCode;
 coherence
 proof
    set i=SubFrom(a,k1,b,k2);
A2: InsCode i=10 by SCMPDS_2:31;
     InsCode halt SCMPDS=0 by SCMPDS_2:21,93;
   hence thesis by A2,Def1;
 end;

cluster MultBy(a,k1,b,k2) -> No-StopCode;
 coherence
 proof
    set i=MultBy(a,k1,b,k2);
A3: InsCode i=11 by SCMPDS_2:32;
     InsCode halt SCMPDS=0 by SCMPDS_2:21,93;
   hence thesis by A3,Def1;
 end;

cluster Divide(a,k1,b,k2) -> No-StopCode;
 coherence
 proof
    set i=Divide(a,k1,b,k2);
A4: InsCode i=12 by SCMPDS_2:33;
     InsCode halt SCMPDS=0 by SCMPDS_2:21,93;
   hence thesis by A4,Def1;
 end;

cluster (a,k1) := (b,k2) -> No-StopCode;
 coherence
 proof
    set i=(a,k1) := (b,k2);
A5: InsCode i=13 by SCMPDS_2:34;
     InsCode halt SCMPDS=0 by SCMPDS_2:21,93;
   hence thesis by A5,Def1;
 end;
end;


registration
 cluster halt SCMPDS -> parahalting;
 coherence proof
      SCMPDS-Stop=Load halt SCMPDS by SCMPDS_3:def 6,SCMPDS_4:def 1;
    hence thesis by Def2;
 end;
end;


registration
 let i be parahalting Instruction of SCMPDS;
 cluster Load i -> parahalting;
 coherence by Def2;
end;

registration
 let a,k1;
 cluster a := k1 -> parahalting;
 coherence
 proof
  set i= a:=k1;
    for s holds Exec(i,s).IC SCMPDS = Next IC s by SCMPDS_2:57;
  then Load i is parahalting by Lm2;
  hence thesis by Def2;
 end;
end;


registration
 let a,k1,k2;
 cluster (a,k1) := k2 -> parahalting;
 coherence
 proof
  set i= (a,k1) := k2;
    for s holds Exec(i,s).IC SCMPDS = Next IC s by SCMPDS_2:58;
  then Load i is parahalting by Lm2;
  hence thesis by Def2;
 end;

 cluster AddTo(a,k1,k2) -> parahalting;
 coherence
 proof
  set i= AddTo(a,k1,k2);
    for s holds Exec(i,s).IC SCMPDS = Next IC s by SCMPDS_2:60;
  then Load i is parahalting by Lm2;
  hence thesis by Def2;
 end;
end;


registration
 let a,b,k1,k2;
 cluster AddTo(a,k1,b,k2) -> parahalting;
 coherence
 proof
  set i= AddTo(a,k1,b,k2);
    for s holds Exec(i,s).IC SCMPDS = Next IC s by SCMPDS_2:61;
  then Load i is parahalting by Lm2;
  hence thesis by Def2;
 end;

 cluster SubFrom(a,k1,b,k2) -> parahalting;
 coherence
 proof
  set i= SubFrom(a,k1,b,k2);
    for s holds Exec(i,s).IC SCMPDS = Next IC s by SCMPDS_2:62;
  then Load i is parahalting by Lm2;
  hence thesis by Def2;
 end;

 cluster MultBy(a,k1,b,k2) -> parahalting;
 coherence
 proof
  set i= MultBy(a,k1,b,k2);
    for s holds Exec(i,s).IC SCMPDS = Next IC s by SCMPDS_2:63;
  then Load i is parahalting by Lm2;
  hence thesis by Def2;
 end;

 cluster Divide(a,k1,b,k2) -> parahalting;
 coherence
 proof
  set i= Divide(a,k1,b,k2);
    for s holds Exec(i,s).IC SCMPDS = Next IC s by SCMPDS_2:64;
  then Load i is parahalting by Lm2;
  hence thesis by Def2;
 end;

 cluster (a,k1) := (b,k2) -> parahalting;
 coherence
 proof
  set i= (a,k1) := (b,k2);
    for s holds Exec(i,s).IC SCMPDS = Next IC s by SCMPDS_2:59;
  then Load i is parahalting by Lm2;
  hence thesis by Def2;
 end;
end;


theorem :: SCMPDS_5:26
  InsCode i =1 implies i is not parahalting;

definition let IT be FinPartState of SCMPDS;
 attr IT is No-StopCode means
:: SCMPDS_5:def 3
      for x being Instruction-Location of SCMPDS
      st x in dom IT holds IT.x <> halt SCMPDS;
end;


registration
 cluster parahalting shiftable No-StopCode Program-block;
 existence
 proof
   set ii=DataLoc(0,0):=0;
   take II=Load ii;
     now let x be Instruction-Location of SCMPDS;
      assume x in dom II;
      then x in {inspos 0} by Th4;
      then x=inspos 0 by TARSKI:def 1;
  then A1: II.x=ii by Th4;
    InsCode ii=2 by SCMPDS_2:23;
      hence II.x <> halt SCMPDS by A1,SCMPDS_2:21,93;
   end;
   hence thesis by Def3;
  end;
end;


registration
 let I,J be No-StopCode Program-block;
 cluster I ';' J -> No-StopCode;
 coherence
 proof
     set IJ=I ';' J;
A1: I ';' J = I +* Shift(J,card I) by SCMPDS_4:def 3;
     now let x be Instruction-Location of SCMPDS such that
A2:    x in dom IJ;
       set D = {inspos(n+card I): inspos n in dom J };
         dom Shift(J,card I) = D by SCMPDS_3:def 7;
then A3:    dom IJ = dom I \/ D by A1,FUNCT_4:def 1;
      per cases by A2,A3,XBOOLE_0:def 2;
       suppose A4:x in dom I;
           then I.x=IJ.x by SCMPDS_4:37;
         hence IJ.x<>halt SCMPDS by A4,Def3;
       end;
       suppose x in D;
        then consider n such that
A5:      x = inspos(n+card I) and
A6:      inspos n in dom J;
           J.inspos n=IJ.(inspos n+card I) by A6,SCMPDS_4:38
         .=IJ.x by A5,SCMPDS_3:def 3;
         hence IJ.x<>halt SCMPDS by A6,Def3;
   end;
   end;
   hence thesis by Def3;
 end;
end;


registration
 let i be No-StopCode Instruction of SCMPDS;
 cluster Load i -> No-StopCode;
 coherence
 proof
   set p=Load i;
     now let x be Instruction-Location of SCMPDS; assume
      x in dom p;
       then x = inspos 0 by Th2;
       then p.x=i by Th4;
       hence p.x <>halt SCMPDS by Def1;
   end;
   hence thesis by Def3;
  end;
end;


registration
  let i be No-StopCode Instruction of SCMPDS,
      J be No-StopCode Program-block;
 cluster i ';' J -> No-StopCode;
 coherence
 proof
       i ';' J=Load i ';' J by SCMPDS_4:def 4;
     hence thesis;
 end;
end;


registration
 let I be No-StopCode Program-block,
     j be No-StopCode Instruction of SCMPDS;
 cluster I ';' j -> No-StopCode;
 coherence
 proof
       I ';' j=I ';' Load j by SCMPDS_4:def 5;
     hence thesis;
 end;
end;


registration
 let i,j be No-StopCode Instruction of SCMPDS;
 cluster i ';' j -> No-StopCode;
 coherence
 proof
       i ';' j=Load i ';' Load j by SCMPDS_4:def 6;
     hence thesis;
 end;
end;


theorem :: SCMPDS_5:27    ::Th37
 for I being parahalting No-StopCode Program-block
 st Initialized (stop I) c= s
 holds
     IC (Computation s).LifeSpan (s +* Initialized stop(I)) = inspos card I;

theorem :: SCMPDS_5:28
 for I being parahalting Program-block,k be Nat
 st k < LifeSpan (s +* Initialized stop(I))
 holds IC (Computation (s +* Initialized stop(I))).k in dom I;

theorem :: SCMPDS_5:29
 for I being parahalting Program-block,k be Nat
 st Initialized I c= s &
    k <= LifeSpan (s +* Initialized stop(I))
 holds
    (Computation s).k,(Computation (s +* Initialized stop(I))).k
    equal_outside the Instruction-Locations of SCMPDS;

theorem :: SCMPDS_5:30  :: Th37,Lemma01
 for I being parahalting No-StopCode Program-block
 st Initialized I c= s
 holds
     IC (Computation s).LifeSpan (s +* Initialized stop(I)) = inspos card I;

theorem :: SCMPDS_5:31     ::Th37 end
 for I being parahalting Program-block st Initialized I c= s
 holds
 CurInstr (Computation s).LifeSpan (s +* Initialized stop(I)) = halt SCMPDS
 or IC (Computation s).LifeSpan (s +* Initialized stop(I)) = inspos card I;

theorem :: SCMPDS_5:32  :: Th39
 for I being parahalting No-StopCode Program-block,k being Nat
 st Initialized I c= s & k < LifeSpan (s +* Initialized stop(I))
 holds CurInstr (Computation s).k <> halt SCMPDS;

theorem :: SCMPDS_5:33  ::Th40
 for I being parahalting Program-block,J being Program-block,
  k being Nat st k <= LifeSpan (s +* Initialized stop(I))
 holds (Computation (s +* Initialized stop I )).k,
       (Computation (s +* ((I ';' J) +* Start-At inspos 0))).k
        equal_outside the Instruction-Locations of SCMPDS;

theorem :: SCMPDS_5:34     ::Th41B
 for I being parahalting Program-block,J being Program-block,
  k being Nat st k <= LifeSpan (s +* Initialized stop(I))
 holds (Computation (s +* Initialized stop I )).k,
       (Computation (s +* Initialized stop (I ';' J))).k
        equal_outside the Instruction-Locations of SCMPDS;

registration
 let I be parahalting Program-block,
     J be parahalting shiftable Program-block;
 cluster I ';' J -> parahalting;
 coherence
 proof
   set sIJ = stop(I ';' J),
       IsIJ = Initialized sIJ;
   let s be State of SCMPDS; assume
A1: IsIJ c= s;
then A2: s = s +* IsIJ by AMI_5:10
    .= s +* ((I ';' (J ';' SCMPDS-Stop)) +* Start-At inspos 0) by Th14;
A3: sIJ c= s by A1,SCMPDS_4:57;
    set spJ = stop J,
       IsJ = Initialized spJ,
       s1 = s +* Initialized stop(I),
       m1 = LifeSpan s1,
       s3 = (Computation s1).m1 +* IsJ,
       m3 = LifeSpan s3,
       A = the Instruction-Locations of SCMPDS,
       D = SCM-Data-Loc;
A4:  s3 | D = ((Computation s1).m1 | D) +* IsJ | D by AMI_5:6;
A5:  now let x be set;
         assume x in dom (IsJ | D);
         then A6: x in dom IsJ /\ D by FUNCT_1:68;
    then A7: x in dom IsJ & x in D by XBOOLE_0:def 3;
         per cases by A7,SCMPDS_4:28;
         suppose A8: x in dom spJ;
              dom spJ c= A by AMI_3:def 13;
          hence (IsJ | D).x = ((Computation s1).m1 | D).x by A7,A8,SCMPDS_4:22
;
         end;
         suppose x = IC SCMPDS;
          hence (IsJ | D).x = ((Computation s1).m1 | D).x by A6,SCMPDS_3:6,
XBOOLE_0:def 3;
      end;
      end;
A9:   IsJ c= s3 by FUNCT_4:26;
      then dom IsJ c= dom s3 by GRFUNC_1:8;
then A10:   dom IsJ c= the carrier of SCMPDS by AMI_3:36;
        dom (IsJ | D) = dom IsJ /\ D by RELAT_1:90;
      then dom (IsJ | D) c= (the carrier of SCMPDS) /\ D by A10,XBOOLE_1:26;
      then dom (IsJ | D) c= dom ((Computation s1).m1) /\ D by AMI_3:36;
      then dom (IsJ | D) c= dom ((Computation s1).m1 | D) by RELAT_1:90;
      then IsJ | D c= (Computation s1).m1 | D by A5,GRFUNC_1:8;
then A11:   (Computation s1).m1 | D = s3 | D by A4,LATTICE2:8;
      set s4 = (Computation s).m1;
     (Computation s1).m1, s4 equal_outside A by A2,Th33;
then A12:   s4 | D = s3 | D by A11,SCMPDS_4:24;
A13:   s3 is halting by A9,AMI_1:def 26;
        Initialized I c= IsIJ by Th15;
      then A14: Initialized I c= s by A1,XBOOLE_1:1;
     per cases by A14,Th31;
     suppose A15: CurInstr s4 = halt SCMPDS;
       take m1;
       thus CurInstr s4 = halt SCMPDS by A15;
     end;
     suppose A16:IC s4 = inspos card I;
        reconsider m = m1 + m3 as Nat;
          sIJ = I ';' J ';' SCMPDS-Stop by SCMPDS_4:def 7
        .= I ';' (J ';' SCMPDS-Stop) by SCMPDS_4:46
        .= I ';' spJ by SCMPDS_4:def 7
        .= I +* Shift(spJ, card I) by SCMPDS_4:def 3;
        then Shift(spJ, card I) c= sIJ by FUNCT_4:26;
        then Shift(spJ, card I) c= s by A3,XBOOLE_1:1;
        then A17: Shift(spJ, card I) c= s4 by AMI_3:38;
        take m;
         CurInstr (Computation s3).m3 = CurInstr (Computation s4).m3 by A9,A12,
A16,A17,SCMPDS_4:84;
       then CurInstr (Computation s3).m3 = CurInstr (Computation s).(m1 + m3)
        by AMI_1:51;
       hence CurInstr (Computation s).m = halt SCMPDS by A13,SCM_1:def 2;
  end;
  end;
end;


registration
 let i be parahalting Instruction of SCMPDS,
     J be parahalting shiftable Program-block;
 cluster i ';' J -> parahalting;
 coherence proof
     i ';' J = Load i ';' J by SCMPDS_4:def 4;
  hence thesis;
 end;
end;


registration
 let I be parahalting Program-block,
     j be parahalting shiftable Instruction of SCMPDS;
 cluster I ';' j -> parahalting;
 coherence proof
     I ';' j = I ';' Load j by SCMPDS_4:def 5;
  hence thesis;
 end;
end;


registration
 let i be parahalting Instruction of SCMPDS,
     j be parahalting shiftable Instruction of SCMPDS;
 cluster i ';' j -> parahalting;
 coherence proof
     i ';' j = Load i ';' Load j by SCMPDS_4:def 6;
  hence thesis;
 end;
end;


theorem :: SCMPDS_5:35     :: SF4_28
 for s,s1 being State of SCMPDS, J being parahalting shiftable Program-block
 st s=(Computation (s1+*Initialized stop J)).m
  holds Exec(CurInstr s ,s +* Start-At (IC s + n))
      = Following(s) +* Start-At (IC Following(s) + n);

begin :: Computation of two consecutive program blocks

theorem :: SCMPDS_5:36    ::Th42
   for I being parahalting No-StopCode Program-block,J being parahalting
 shiftable Program-block,k being Nat
 st Initialized stop (I ';' J) c= s
 holds
 (Computation (Result(s +*Initialized stop I) +* Initialized stop J )).k
 +* Start-At (IC
 (Computation (Result(s +*Initialized stop I) +* Initialized stop J )).k
 + card I),
 (Computation (s +* Initialized stop (I ';' J))).
                          (LifeSpan (s +* Initialized stop I)+k)
            equal_outside the Instruction-Locations of SCMPDS;

theorem :: SCMPDS_5:37  ::Th43
 for I being parahalting No-StopCode Program-block,J being parahalting
 shiftable Program-block
   holds
     LifeSpan (s +* Initialized stop (I ';' J))
     = LifeSpan (s +* Initialized stop I)
      + LifeSpan (Result (s +* Initialized stop I) +* Initialized stop J);

theorem :: SCMPDS_5:38
 for I being parahalting No-StopCode Program-block,J being parahalting
 shiftable Program-block
  holds
     IExec(I ';' J,s) =
         IExec(J,IExec(I,s)) +* Start-At (IC IExec(J,IExec(I,s)) + card I);

theorem :: SCMPDS_5:39
   for I being parahalting No-StopCode Program-block,J being parahalting
 shiftable Program-block
  holds IExec(I ';' J, s).a = IExec(J,IExec(I,s)).a;

begin :: Computation of the program consisting of a instruction and a block

definition
 let s be State of SCMPDS;
 func Initialized s -> State of SCMPDS equals
:: SCMPDS_5:def 4
   s +* Start-At(inspos 0);
end;


theorem :: SCMPDS_5:40    ::Th3c
  IC Initialized s = inspos 0 & (Initialized s).a = s.a &
  (Initialized s).loc = s.loc;

theorem :: SCMPDS_5:41   ::Th4c
 s1, s2 equal_outside the Instruction-Locations of SCMPDS
iff
   s1 | (SCM-Data-Loc \/ {IC SCMPDS}) = s2 | (SCM-Data-Loc \/ {IC SCMPDS});

canceled;

theorem :: SCMPDS_5:43    ::Th5c
    s1 | SCM-Data-Loc = s2 | SCM-Data-Loc & InsCode i <> 3 implies
    Exec (i, s1) | SCM-Data-Loc = Exec (i, s2) | SCM-Data-Loc;

theorem :: SCMPDS_5:44    ::Th5c
  for i being shiftable Instruction of SCMPDS holds
   (s1 | SCM-Data-Loc = s2 | SCM-Data-Loc implies
    Exec (i, s1) | SCM-Data-Loc = Exec (i, s2) | SCM-Data-Loc);

theorem :: SCMPDS_5:45    ::Th6c
 for i being parahalting Instruction of SCMPDS
  holds Exec(i, Initialized s) = IExec(Load i, s);

theorem :: SCMPDS_5:46    ::Th7c
 for I being parahalting No-StopCode Program-block,j being parahalting
 shiftable Instruction of SCMPDS
  holds IExec(I ';' j, s).a = Exec(j, IExec(I, s)).a;

theorem :: SCMPDS_5:47    ::Th9c
   for i being No-StopCode parahalting Instruction of SCMPDS,
     j being shiftable parahalting Instruction of SCMPDS
  holds IExec(i ';' j, s).a = Exec(j, Exec(i, Initialized s)).a;
