:: Computation of Two Consecutive Program Blocks for SCMPDS
::  by JingChao Chen
::
:: Received June 15, 1999
:: Copyright (c) 1999 Association of Mizar Users

environ

 vocabularies NUMBERS, SUBSET_1, SCMPDS_2, AMI_1, FSM_1, INT_1, SETFAM_1,
      RELAT_1, SCMFSA_7, CARD_1, SCMPDS_4, FUNCT_1, AMISTD_2, VALUED_1,
      ARYTM_3, TARSKI, XXREAL_0, SCMFSA6A, TURING_1, FUNCT_4, XBOOLE_0,
      SCMFSA6B, FUNCT_7, CIRCUIT2, GRAPHSP, MSUALG_1, AMI_2, AMI_3, SCMPDS_1,
      COMPLEX1, STRUCT_0, ARYTM_1, NAT_1, SCMPDS_5, ORDINAL1, PARTFUN1,
      SCMNORM, GLIB_000;
 notations TARSKI, XBOOLE_0, SETFAM_1, ENUMSET1, SUBSET_1, CARD_1, NUMBERS,
      XCMPLX_0, RELAT_1, FUNCT_1, PARTFUN1, FUNCT_4, INT_1, NAT_1, STRUCT_0,
      AMI_1, VALUED_1, SCMNORM, AMI_2, FUNCT_7, SCMPDS_1, SCMPDS_2, INT_2,
      SCMPDS_4, XXREAL_0;
 constructors ENUMSET1, XXREAL_0, REAL_1, INT_2, SCMPDS_1, SCMPDS_4, SCMNORM,
      PRE_POLY;
 registrations SETFAM_1, FUNCT_1, NUMBERS, XREAL_0, INT_1, AMI_1, SCMPDS_2,
      SCMPDS_4, ORDINAL1, XBOOLE_0, SCMNORM, VALUED_1, AFINSQ_1;
 requirements NUMERALS, REAL, SUBSET, BOOLE, ARITHM;


begin :: Preliminaries

reserve x for set,
  m,n for Element of NAT,
  a,b,c for Int_position,
  i for
  Instruction of SCMPDS,
  s,s1,s2 for State of SCMPDS,
  k1,k2 for Integer,
  loc,l1
  for Element of NAT,
  I,J for Program of SCMPDS,
  N for with_non-empty_elements set;

canceled;

theorem :: SCMPDS_5:2
  x in dom Load i iff x =  0;

theorem :: SCMPDS_5:3
  loc in dom (stop I) & (stop I).loc <> halt SCMPDS implies loc in
  dom I;

theorem :: SCMPDS_5:4
  dom Load i = { 0} & (Load i).( 0)=i;

theorem :: SCMPDS_5:5
   0 in dom Load i;

theorem :: SCMPDS_5:6
  card Load i = 1;

theorem :: SCMPDS_5:7
  card stop I = card I + 1;

theorem :: SCMPDS_5:8
  card stop Load i = 2;

theorem :: SCMPDS_5:9
   0 in dom stop (Load i) &  1 in dom stop (Load i);

theorem :: SCMPDS_5:10
  (stop Load i). 0=i & (stop Load i). 1=halt SCMPDS;

theorem :: SCMPDS_5:11
  x in dom stop Load i iff x= 0 or x= 1;

theorem :: SCMPDS_5:12
  dom (stop Load i)={ 0, 1};

theorem :: SCMPDS_5:13
   0 in dom (Initialized stop Load i) &  1 in dom (
Initialized stop Load i) & (Initialized stop Load i). 0=i & (Initialized
  stop Load i). 1=halt SCMPDS;

canceled;

theorem :: SCMPDS_5:15
  for I,J being Program of SCMPDS holds Initialized I c=
  Initialized stop (I ';' J);

theorem :: SCMPDS_5:16
  dom stop I c= dom stop (I ';' J);

theorem :: SCMPDS_5:17
  for I,J being Program of SCMPDS holds Initialized stop I +*
  Initialized stop (I ';' J) = Initialized stop (I ';' J);

theorem :: SCMPDS_5:18
  Initialized I c= s implies IC s =  0;

theorem :: SCMPDS_5:19
  (s +* Initialized I).a = s.a;

theorem :: SCMPDS_5:20
  for I being parahalting Program of SCMPDS st Initialized stop I
  c= s1 & Initialized stop I c= s2 & s1,s2 equal_outside NAT holds for k being
  Element of NAT holds Comput(ProgramPart(s1),s1,k), Comput(ProgramPart(s2),s2,
k) equal_outside NAT &
  CurInstr(ProgramPart (s1),Comput(ProgramPart(s1),s1,k))
   = CurInstr(ProgramPart (s2),Comput(ProgramPart(s2),s2,k));

theorem :: SCMPDS_5:21
  for I being parahalting Program of SCMPDS st Initialized stop I
c= s1 & Initialized stop I c= s2 & s1,s2 equal_outside NAT holds LifeSpan(
ProgramPart(s1),s1) =
  LifeSpan(ProgramPart(s2),s2) & Result(ProgramPart(s1),s1), Result(ProgramPart
(s2),s2) equal_outside NAT;

theorem :: SCMPDS_5:22
  for I being Program of SCMPDS holds IC IExec(I,s) = IC Result(ProgramPart(s
  +* Initialized stop I),s
  +* Initialized stop I);

theorem :: SCMPDS_5:23
  for I being parahalting Program of SCMPDS, J being Program of
SCMPDS st Initialized stop I c= s for m st m <= LifeSpan(ProgramPart(s),s)
holds Comput(
ProgramPart(s),s,
  m),Comput(ProgramPart(s+*(I ';' J)),s+*(I ';' J),m) equal_outside NAT;

theorem :: SCMPDS_5:24
  for I being parahalting Program of SCMPDS, J being Program of
SCMPDS st Initialized stop I c= s for m st m <= LifeSpan(ProgramPart(s),s)
holds Comput(
ProgramPart(s),s,
  m),Comput(ProgramPart(s+*Initialized stop(I ';' J)),s+*Initialized stop(I ';'
J),m) equal_outside NAT;

begin :: Non halting instrutions and parahalting instrutions

definition
  let i be Instruction of SCMPDS;
  attr i is No-StopCode means
:: SCMPDS_5:def 1

  i <> halt SCMPDS;
end;

definition
  let i be Instruction of SCMPDS;
  attr i is parahalting means
:: SCMPDS_5:def 2

  Load i is parahalting;
end;

registration
  cluster No-StopCode shiftable parahalting Instruction of SCMPDS;
end;

theorem :: SCMPDS_5:25
  k1 <>0 implies goto k1 is No-StopCode;

registration
  let a;
  cluster return a -> No-StopCode;
end;

registration
  let a,k1;
  cluster a := k1 -> No-StopCode;
  cluster saveIC(a,k1) -> No-StopCode;
end;

registration
  let a,k1,k2;
  cluster (a,k1)<>0_goto k2 -> No-StopCode;
  cluster (a,k1)<=0_goto k2 -> No-StopCode;
  cluster (a,k1)>=0_goto k2 -> No-StopCode;
  cluster (a,k1) := k2 -> No-StopCode;
end;

registration
  let a,k1,k2;
  cluster AddTo(a,k1,k2) -> No-StopCode;
end;

registration
  let a,b,k1,k2;
  cluster AddTo(a,k1,b,k2) -> No-StopCode;
  cluster SubFrom(a,k1,b,k2) -> No-StopCode;
  cluster MultBy(a,k1,b,k2) -> No-StopCode;
  cluster Divide(a,k1,b,k2) -> No-StopCode;
  cluster (a,k1) := (b,k2) -> No-StopCode;
end;

registration
  cluster halt SCMPDS -> parahalting;
end;

registration
  let i be parahalting Instruction of SCMPDS;
  cluster Load i -> parahalting;
end;

registration
  let a,k1;
  cluster a := k1 -> parahalting;
end;

registration
  let a,k1,k2;
  cluster (a,k1) := k2 -> parahalting;
  cluster AddTo(a,k1,k2) -> parahalting;
end;

registration
  let a,b,k1,k2;
  cluster AddTo(a,k1,b,k2) -> parahalting;
  cluster SubFrom(a,k1,b,k2) -> parahalting;
  cluster MultBy(a,k1,b,k2) -> parahalting;
  cluster Divide(a,k1,b,k2) -> parahalting;
  cluster (a,k1) := (b,k2) -> parahalting;
end;

theorem :: SCMPDS_5:26
  InsCode i =1 implies i is not parahalting;

definition
  let N be with_non-empty_elements set;
  let S be halting (AMI-Struct over N);
  let IT be NAT-defined FinPartState of S;
  redefine attr IT is halt-free means
:: SCMPDS_5:def 3

  for x being Element of NAT st x in dom IT holds IT.x <> halt S;
end;

registration
  cluster parahalting shiftable halt-free Program of SCMPDS;
end;

registration
  let I,J be halt-free Program of SCMPDS;
  cluster I ';' J -> halt-free;
end;

registration
  let i be No-StopCode Instruction of SCMPDS;
  cluster Load i -> halt-free;
end;

registration
  let i be No-StopCode Instruction of SCMPDS, J be halt-free Program of
  SCMPDS;
  cluster i ';' J -> halt-free;
end;

registration
  let I be halt-free Program of SCMPDS, j be No-StopCode Instruction of
  SCMPDS;
  cluster I ';' j -> halt-free;
end;

registration
  let i,j be No-StopCode Instruction of SCMPDS;
  cluster i ';' j -> halt-free;
end;

theorem :: SCMPDS_5:27
  for I being parahalting halt-free Program of SCMPDS st
  Initialized (stop I) c= s holds IC Comput(ProgramPart( s), s,LifeSpan(
ProgramPart(s +*
Initialized
  stop(I)),s +*
Initialized
  stop(I))) =  card I;

theorem :: SCMPDS_5:28
  for I being parahalting Program of SCMPDS,k be Element of NAT st
k < LifeSpan(ProgramPart(s +* Initialized stop(I)),s +* Initialized stop(I))
holds IC Comput(ProgramPart( (s +*
Initialized
  stop(I))), (s +* Initialized
  stop(I)),k) in dom I;

theorem :: SCMPDS_5:29
  for I being parahalting Program of SCMPDS,k be Element of NAT st
Initialized I c= s & k <= LifeSpan(ProgramPart(s +* Initialized stop(I)),s +*
Initialized stop(I)) holds Comput(
ProgramPart( s), s,k), Comput(ProgramPart( (s +* Initialized stop(I))), (s +*
Initialized stop(I)),k) equal_outside NAT;

theorem :: SCMPDS_5:30
  for I being parahalting halt-free Program of SCMPDS st
Initialized I c= s holds IC Comput(ProgramPart(s),s,LifeSpan(ProgramPart(s +*
Initialized
stop(I)),s +* Initialized
stop(I)))
  =  card I;

theorem :: SCMPDS_5:31
  for I being parahalting Program of SCMPDS st Initialized I c= s
  holds CurInstr(
   ProgramPart Comput(ProgramPart( s), s,LifeSpan(ProgramPart(s +* Initialized
stop(I)),s +* Initialized stop(I))),
   Comput(ProgramPart( s), s,LifeSpan(ProgramPart(s +* Initialized stop(I)),s
+* Initialized stop(I))))
   = halt
SCMPDS or IC Comput(ProgramPart( s), s,LifeSpan(ProgramPart(s +* Initialized
stop(I)),s +* Initialized stop(I))) =
card
  I;

theorem :: SCMPDS_5:32
  for I being parahalting halt-free Program of SCMPDS,k being
Element of NAT st Initialized I c= s & k < LifeSpan(ProgramPart(s +*
Initialized stop(I)),s +* Initialized stop(I))
  holds CurInstr(ProgramPart Comput(ProgramPart(s),s,k),Comput(ProgramPart(s),s
,k)) <> halt SCMPDS;

theorem :: SCMPDS_5:33
  for I being parahalting Program of SCMPDS,J being Program of
  SCMPDS, k being Element of NAT st k <= LifeSpan(ProgramPart(s +* Initialized
stop(I)),s +* Initialized stop(I))
holds Comput(ProgramPart( (s +* Initialized stop I )), (s +* Initialized stop I
),k), Comput(ProgramPart( (s +* ((I ';' J)
  +* Start-At( 0,SCMPDS)))), (s +* ((I ';' J)
  +* Start-At( 0,SCMPDS))),k) equal_outside NAT;

theorem :: SCMPDS_5:34
  for I being parahalting Program of SCMPDS,J being Program of
  SCMPDS, k being Element of NAT st k <= LifeSpan(ProgramPart(s +* Initialized
stop(I)),s +* Initialized stop(I))
  holds Comput(ProgramPart( (s +* Initialized stop I )), (s +* Initialized stop
I ),k), Comput(ProgramPart( (s +*
  Initialized stop (I ';' J))), (s +*
  Initialized stop (I ';' J)),k) equal_outside NAT;

registration
  let I be parahalting Program of SCMPDS, J be parahalting shiftable Program
  of SCMPDS;
  cluster I ';' J -> parahalting;
end;

registration
  let i be parahalting Instruction of SCMPDS, J be parahalting shiftable
  Program of SCMPDS;
  cluster i ';' J -> parahalting;
end;

registration
  let I be parahalting Program of SCMPDS, j be parahalting shiftable
  Instruction of SCMPDS;
  cluster I ';' j -> parahalting;
end;

registration
  let i be parahalting Instruction of SCMPDS, j be parahalting shiftable
  Instruction of SCMPDS;
  cluster i ';' j -> parahalting;
end;

theorem :: SCMPDS_5:35
  for s,s1 being State of SCMPDS, J being parahalting shiftable
  Program of SCMPDS st s= Comput(ProgramPart( (s1+*Initialized stop J)), (s1+*
Initialized stop J),m) holds Exec(
CurInstr(ProgramPart s,s),s +* Start-At(IC s + n,SCMPDS))
 = Following(ProgramPart s,s) +*
Start-At (IC Following(ProgramPart s,s) + n,SCMPDS);

begin :: Computation of two consecutive program blocks

theorem :: SCMPDS_5:36
  for I being parahalting halt-free Program of SCMPDS,J being
  parahalting shiftable Program of SCMPDS,k being Element of NAT st Initialized
  stop (I ';' J) c= s holds Comput(ProgramPart( (Result(ProgramPart(s +*
Initialized stop I),s +*Initialized stop I)
+*
  Initialized stop J )), (Result(ProgramPart(s +*Initialized stop I),s +*
Initialized stop I) +*
  Initialized stop J ),k) +* Start-At (IC Comput(ProgramPart( (Result(
ProgramPart(s +*
Initialized
  stop I),s +*
Initialized
  stop I) +* Initialized stop J )), (Result(ProgramPart(s +*Initialized
  stop I),s +*Initialized
  stop I) +* Initialized stop J ),k) + card I,SCMPDS),
  Comput(ProgramPart( (s +* Initialized
  stop (I ';' J))), (s +* Initialized
  stop (I ';' J)), (LifeSpan(ProgramPart(s +* Initialized stop I),s +*
Initialized stop I)+k)) equal_outside NAT;

theorem :: SCMPDS_5:37
  for I being parahalting halt-free Program of SCMPDS,J being
parahalting shiftable Program of SCMPDS holds LifeSpan(ProgramPart(s +*
Initialized stop (
  I ';' J)),s +* Initialized stop (
  I ';' J)) = LifeSpan(ProgramPart(s +* Initialized stop I),s +* Initialized
stop I) + LifeSpan(ProgramPart(Result(ProgramPart(s +*
  Initialized stop I),s +*
  Initialized stop I) +* Initialized stop J),Result(ProgramPart(s +*
  Initialized stop I),s +*
  Initialized stop I) +* Initialized stop J);

theorem :: SCMPDS_5:38
  for I being parahalting halt-free Program of SCMPDS,J being
parahalting shiftable Program of SCMPDS holds IExec(I ';' J,s) = IExec(J,IExec(
  I,s)) +* Start-At (IC IExec(J,IExec(I,s)) + card I,SCMPDS);

theorem :: SCMPDS_5:39
  for I being parahalting halt-free Program of SCMPDS,J being
  parahalting shiftable Program of SCMPDS holds IExec(I ';' J, s).a = IExec(J,
  IExec(I,s)).a;

begin :: Computation of the program consisting of a instruction and a block

definition
  let s be State of SCMPDS;
  func Initialized s -> State of SCMPDS equals
:: SCMPDS_5:def 4
  s +* Start-At( 0,SCMPDS);
end;

theorem :: SCMPDS_5:40
  IC Initialized s =  0 & (Initialized s).a = s.a & (
  Initialized s).loc = s.loc;

theorem :: SCMPDS_5:41
  s1, s2 equal_outside NAT iff s1 | (SCM-Data-Loc \/ {IC SCMPDS})
  = s2 | (SCM-Data-Loc \/ {IC SCMPDS});

canceled;

theorem :: SCMPDS_5:43
  DataPart s1 = DataPart s2 & InsCode i <> 3 implies DataPart Exec
  (i,s1) = DataPart Exec(i,s2);

theorem :: SCMPDS_5:44
  for i being shiftable Instruction of SCMPDS holds (DataPart s1 =
  DataPart s2 implies DataPart Exec(i,s1) = DataPart Exec(i,s2));

theorem :: SCMPDS_5:45
  for i being parahalting Instruction of SCMPDS holds Exec(i,
  Initialized s) = IExec(Load i, s);

theorem :: SCMPDS_5:46
  for I being parahalting halt-free Program of SCMPDS,j being
parahalting shiftable Instruction of SCMPDS holds IExec(I ';' j, s).a = Exec(j,
  IExec(I, s)).a;

theorem :: SCMPDS_5:47
  for i being No-StopCode parahalting Instruction of SCMPDS, j being
shiftable parahalting Instruction of SCMPDS holds IExec(i ';' j, s).a = Exec(j,
  Exec(i, Initialized s)).a;

