:: Computation of Two Consecutive Program Blocks for SCMPDS
::  by JingChao Chen
::
:: Received June 15, 1999
:: Copyright (c) 1999 Association of Mizar Users

environ

 vocabularies NUMBERS, SUBSET_1, SCMPDS_2, AMI_1, FSM_1, INT_1, SETFAM_1,
      RELAT_1, SCMFSA_7, CARD_1, SCMPDS_4, FUNCT_1, AMISTD_2, VALUED_1,
      ARYTM_3, TARSKI, XXREAL_0, TURING_1, FUNCT_4, XBOOLE_0, SCMFSA6B,
      FUNCT_7, CIRCUIT2, GRAPHSP, MSUALG_1, AMI_2, AMI_3, SCMPDS_1, COMPLEX1,
      STRUCT_0, ARYTM_1, NAT_1, SCMPDS_5, ORDINAL1, PARTFUN1, SCMNORM,
      GLIB_000, SCMFSA6C;
 notations TARSKI, XBOOLE_0, SETFAM_1, ENUMSET1, SUBSET_1, CARD_1, NUMBERS,
      XCMPLX_0, RELAT_1, FUNCT_1, PARTFUN1, FUNCT_4, INT_1, NAT_1, STRUCT_0,
      COMPOS_1, EXTPRO_1, AMI_1, VALUED_1, AMI_2, FUNCT_7, SCMPDS_1, SCMPDS_2,
      INT_2, SCMPDS_4, XXREAL_0;
 constructors ENUMSET1, XXREAL_0, REAL_1, INT_2, SCMPDS_1, SCMPDS_4, PRE_POLY,
      DOMAIN_1, AMI_1, AMI_3;
 registrations SETFAM_1, FUNCT_1, NUMBERS, XREAL_0, INT_1, AMI_1, SCMPDS_2,
      SCMPDS_4, ORDINAL1, XBOOLE_0, VALUED_1, AFINSQ_1, COMPOS_1, RELAT_1,
      EXTPRO_1;
 requirements NUMERALS, REAL, SUBSET, BOOLE, ARITHM;


begin :: Preliminaries

reserve x for set,
  m,n for Element of NAT,
  a,b,c for Int_position,
  i for Instruction of SCMPDS,
  s,s1,s2 for State of SCMPDS,
  k1,k2 for Integer,
  loc,l1 for Element of NAT,
  I,J for Program of SCMPDS,
  N for with_non-empty_elements set;

canceled;

theorem :: SCMPDS_5:2
  x in dom Load i iff x =  0;

theorem :: SCMPDS_5:3
  loc in dom stop I & (stop I).loc <> halt SCMPDS implies loc in dom I;

theorem :: SCMPDS_5:4
  dom Load i = { 0} & (Load i).( 0)=i;

theorem :: SCMPDS_5:5
   0 in dom Load i;

theorem :: SCMPDS_5:6
  card Load i = 1;

theorem :: SCMPDS_5:7
  card stop I = card I + 1;

theorem :: SCMPDS_5:8
  card stop Load i = 2;

theorem :: SCMPDS_5:9
   0 in dom stop Load i &  1 in dom stop Load i;

theorem :: SCMPDS_5:10
  (stop Load i). 0=i & (stop Load i). 1=halt SCMPDS;

theorem :: SCMPDS_5:11
  x in dom stop Load i iff x= 0 or x= 1;

theorem :: SCMPDS_5:12
  dom stop Load i = {0,1};

canceled 2;

theorem :: SCMPDS_5:15
  for I,J being Program of SCMPDS holds I c= stop (I ';' J);

theorem :: SCMPDS_5:16
  dom stop I c= dom stop (I ';' J);

theorem :: SCMPDS_5:17
  for I,J being Program of SCMPDS holds
   stop I +* stop (I ';' J) = stop (I ';' J);

theorem :: SCMPDS_5:18
  Initialize I c= s implies IC s =  0;

theorem :: SCMPDS_5:19
  (Initialize s +* I).a = s.a;

theorem :: SCMPDS_5:20
  for s1,s2 being 0-started State of SCMPDS
  for I being parahalting Program of SCMPDS st stop I c= s1 &
  stop I c= s2 & s1,s2 equal_outside NAT
  for k being Element of NAT holds
   Comput(ProgramPart(s1),s1,k),
   Comput(ProgramPart(s2),s2,k) equal_outside NAT &
   CurInstr(ProgramPart (s1),Comput(ProgramPart(s1),s1,k))
    = CurInstr(ProgramPart (s2),Comput(ProgramPart(s2),s2,k));

theorem :: SCMPDS_5:21
  for s1,s2 being 0-started State of SCMPDS
  for I being parahalting Program of SCMPDS st stop I c= s1 &
      stop I c= s2 & s1,s2 equal_outside NAT
  holds LifeSpan(ProgramPart(s1),s1) =
  LifeSpan(ProgramPart(s2),s2) &
  Result(ProgramPart(s1),s1), Result(ProgramPart(s2),s2) equal_outside NAT;

theorem :: SCMPDS_5:22
  for I being Program of SCMPDS holds IC IExec(I,s) =
   IC Result(ProgramPart(Initialize s +* stop I),Initialize s +* stop I);

theorem :: SCMPDS_5:23
  for s being 0-started State of SCMPDS
  for I being parahalting Program of SCMPDS, J being Program of
SCMPDS st stop I c= s for m st m <= LifeSpan(ProgramPart(s),s)
holds Comput(ProgramPart(s),s,
  m),Comput(ProgramPart(s+*(I ';' J)),s+*(I ';' J),m) equal_outside NAT;

theorem :: SCMPDS_5:24
 for s being 0-started State of SCMPDS
 for I being parahalting Program of SCMPDS, J being Program of SCMPDS
   st stop I c= s
 for m st m <= LifeSpan(ProgramPart(s),s)
 holds Comput(ProgramPart(s),s,m),
  Comput(ProgramPart(s+*stop(I ';' J)), s+*stop(I ';' J),m) equal_outside NAT;

begin :: Non halting instrutions and parahalting instrutions

definition
  let i be Instruction of SCMPDS;
  attr i is No-StopCode means
:: SCMPDS_5:def 1

  i <> halt SCMPDS;
end;

definition
  let i be Instruction of SCMPDS;
  attr i is parahalting means
:: SCMPDS_5:def 2

  Load i is parahalting;
end;

registration
  cluster No-StopCode shiftable parahalting Instruction of SCMPDS;
end;

theorem :: SCMPDS_5:25
  k1 <>0 implies goto k1 is No-StopCode;

registration
  let a;
  cluster return a -> No-StopCode;
end;

registration
  let a,k1;
  cluster a := k1 -> No-StopCode;
  cluster saveIC(a,k1) -> No-StopCode;
end;

registration
  let a,k1,k2;
  cluster (a,k1)<>0_goto k2 -> No-StopCode;
  cluster (a,k1)<=0_goto k2 -> No-StopCode;
  cluster (a,k1)>=0_goto k2 -> No-StopCode;
  cluster (a,k1) := k2 -> No-StopCode;
end;

registration
  let a,k1,k2;
  cluster AddTo(a,k1,k2) -> No-StopCode;
end;

registration
  let a,b,k1,k2;
  cluster AddTo(a,k1,b,k2) -> No-StopCode;
  cluster SubFrom(a,k1,b,k2) -> No-StopCode;
  cluster MultBy(a,k1,b,k2) -> No-StopCode;
  cluster Divide(a,k1,b,k2) -> No-StopCode;
  cluster (a,k1) := (b,k2) -> No-StopCode;
end;

registration
  cluster halt SCMPDS -> parahalting;
end;

registration
  let i be parahalting Instruction of SCMPDS;
  cluster Load i -> parahalting Program of SCMPDS;
end;

registration
  let a,k1;
  cluster a := k1 -> parahalting;
end;

registration
  let a,k1,k2;
  cluster (a,k1) := k2 -> parahalting;
  cluster AddTo(a,k1,k2) -> parahalting;
end;

registration
  let a,b,k1,k2;
  cluster AddTo(a,k1,b,k2) -> parahalting;
  cluster SubFrom(a,k1,b,k2) -> parahalting;
  cluster MultBy(a,k1,b,k2) -> parahalting;
  cluster Divide(a,k1,b,k2) -> parahalting;
  cluster (a,k1) := (b,k2) -> parahalting;
end;

theorem :: SCMPDS_5:26
  InsCode i =1 implies i is not parahalting;

definition
  let N be with_non-empty_elements set;
:::  let S be halting (AMI-Struct over N);
  let S be definite (non empty stored-program AMI-Struct over N);
  let IT be  NAT-defined (the Instructions of S)-valued Function;
  redefine attr IT is halt-free means
:: SCMPDS_5:def 3

  for x being Element of NAT st x in dom IT holds IT.x <> halt S;
end;

registration
  cluster parahalting shiftable halt-free Program of SCMPDS;
end;

registration
  let I,J be halt-free Program of SCMPDS;
  cluster I ';' J -> halt-free;
end;

registration
  let i be No-StopCode Instruction of SCMPDS;
  cluster Load i -> halt-free;
end;

registration
  let i be No-StopCode Instruction of SCMPDS, J be halt-free Program of
  SCMPDS;
  cluster i ';' J -> halt-free;
end;

registration
  let I be halt-free Program of SCMPDS, j be No-StopCode Instruction of
  SCMPDS;
  cluster I ';' j -> halt-free;
end;

registration
  let i,j be No-StopCode Instruction of SCMPDS;
  cluster i ';' j -> halt-free;
end;

theorem :: SCMPDS_5:27
  for s being 0-started State of SCMPDS
  for I being parahalting halt-free Program of SCMPDS st stop I c= s
   holds IC Comput(ProgramPart(s), s,
     LifeSpan(ProgramPart(s +* stop I),s +* stop I))
     =  card I;

theorem :: SCMPDS_5:28
 for s being 0-started State of SCMPDS
  for I being parahalting Program of SCMPDS,k be Element of NAT st
     k < LifeSpan(ProgramPart(s +* stop I),s +* stop I)
holds IC Comput(ProgramPart(s +* stop I),(s +* stop I),k) in dom I;

theorem :: SCMPDS_5:29
  for s being 0-started State of SCMPDS
  for I being parahalting Program of SCMPDS,k be Element of NAT st
 I c= s & k <= LifeSpan(ProgramPart(s +* stop I),s +* stop I)
   holds Comput(ProgramPart s, s,k),
      Comput(ProgramPart(s +* stop I),s +* stop I,k) equal_outside NAT;

theorem :: SCMPDS_5:30
  for s being 0-started State of SCMPDS
  for I being parahalting halt-free Program of SCMPDS st I c= s
   holds IC Comput(ProgramPart s,s,
    LifeSpan(ProgramPart(s +* stop I),s +* stop I)) =  card I;

theorem :: SCMPDS_5:31
  for s being 0-started State of SCMPDS
  for I being parahalting Program of SCMPDS st I c= s
  holds CurInstr(ProgramPart s,
   Comput(ProgramPart s, s,LifeSpan(ProgramPart(s +* stop I),
    s +* stop I))) = halt SCMPDS or
   IC Comput(ProgramPart(s), s,
  LifeSpan(ProgramPart(s +* stop I),s +* stop I)) = card I;

theorem :: SCMPDS_5:32
  for s being 0-started State of SCMPDS
  for I being parahalting halt-free Program of SCMPDS,k being Element of NAT
   st I c= s & k < LifeSpan(ProgramPart(s +* stop I),s +* stop I)
  holds CurInstr(ProgramPart(s),Comput(ProgramPart(s),s,k)) <> halt SCMPDS;

theorem :: SCMPDS_5:33
  for I being parahalting Program of SCMPDS,J being Program of
  SCMPDS, k being Element of NAT st k <= LifeSpan(
  ProgramPart(Initialize s +* stop(I)),Initialize s +* stop(I))
holds Comput(ProgramPart((Initialize s +* stop I )), (Initialize s +* stop I
),k), Comput(ProgramPart((s +* (Initialize (I ';' J)))),
(s +* (Initialize(I ';' J))),k) equal_outside NAT;

theorem :: SCMPDS_5:34
  for s being 0-started State of SCMPDS
  for I being parahalting Program of SCMPDS,J being Program of SCMPDS,
      k being Element of NAT st
   k <= LifeSpan(ProgramPart(s +* stop I),s +* stop I)
  holds Comput(ProgramPart(s +* stop I), s +* stop I,k),
  Comput(ProgramPart(s +* stop (I ';' J)),s +* stop (I ';' J),k)
     equal_outside NAT;

registration
  let I be parahalting Program of SCMPDS, J be parahalting shiftable Program
  of SCMPDS;
  cluster I ';' J -> parahalting Program of SCMPDS;
end;

registration
  let i be parahalting Instruction of SCMPDS, J be parahalting shiftable
  Program of SCMPDS;
  cluster i ';' J -> parahalting;
end;

registration
  let I be parahalting Program of SCMPDS, j be parahalting shiftable
  Instruction of SCMPDS;
  cluster I ';' j -> parahalting;
end;

registration
  let i be parahalting Instruction of SCMPDS, j be parahalting shiftable
  Instruction of SCMPDS;
  cluster i ';' j -> parahalting;
end;

theorem :: SCMPDS_5:35
  for s being State of SCMPDS, s1 being 0-started State of SCMPDS,
      J being parahalting shiftable Program of SCMPDS
    st s = Comput(ProgramPart(s1+*stop J),
   s1+* stop J,m) holds
    Exec(CurInstr(ProgramPart s,s),s +* Start-At(IC s + n,SCMPDS))
  = Following(ProgramPart s,s) +*
    Start-At (IC Following(ProgramPart s,s) + n,SCMPDS);

begin :: Computation of two consecutive program blocks

theorem :: SCMPDS_5:36
  for s being 0-started State of SCMPDS
  for I being parahalting halt-free Program of SCMPDS,J being
  parahalting shiftable Program of SCMPDS,k being Element of NAT st
  stop (I ';' J) c= s holds Comput(ProgramPart(
   Initialize Result(ProgramPart(s +* stop I),s +*stop I)
      +* stop J ),
  Initialize Result(ProgramPart(s +*stop I),s +* stop I) +* stop J,k) +*
  Start-At (IC Comput(ProgramPart(
  Initialize Result(
      ProgramPart(s +* stop I),s +* stop I) +* stop J ),
   (Initialize Result(ProgramPart(s +*stop I),
      s +*stop I) +* stop J ),k) + card I,SCMPDS),
  Comput(ProgramPart(s +* stop (I ';' J)),s +* stop (I ';' J),
   LifeSpan(ProgramPart(s +* stop I),s +* stop I)+k) equal_outside NAT;

theorem :: SCMPDS_5:37
  for s being 0-started State of SCMPDS
  for I being parahalting halt-free Program of SCMPDS,
      J being parahalting shiftable Program of SCMPDS holds
 LifeSpan(ProgramPart(s +* stop(I ';' J)), s +* stop (I ';' J))
  = LifeSpan(ProgramPart(s +* stop I),s +* stop I) +
    LifeSpan(ProgramPart(Initialize Result(ProgramPart(s +*
  stop I),s +* stop I) +* stop J),
  Initialize Result(ProgramPart(s +* stop I),s +* stop I) +* stop J);

theorem :: SCMPDS_5:38
  for s being 0-started State of SCMPDS
  for I being parahalting halt-free Program of SCMPDS,J being
parahalting shiftable Program of SCMPDS holds IExec(I ';' J,s) = IExec(J,IExec(
  I,s)) +* Start-At (IC IExec(J,IExec(I,s)) + card I,SCMPDS);

theorem :: SCMPDS_5:39
 for s being 0-started State of SCMPDS
 for I being parahalting halt-free Program of SCMPDS,J being
  parahalting shiftable Program of SCMPDS holds IExec(I ';' J, s).a = IExec(J,
  IExec(I,s)).a;

begin :: Computation of the program consisting of a instruction and a block

theorem :: SCMPDS_5:40
  IC Initialize s =  0 & (Initialize s).a = s.a & (Initialize s).loc = s.loc;

theorem :: SCMPDS_5:41
  s1, s2 equal_outside NAT iff s1 | (SCM-Data-Loc \/ {IC SCMPDS})
  = s2 | (SCM-Data-Loc \/ {IC SCMPDS});

canceled;

theorem :: SCMPDS_5:43
  DataPart s1 = DataPart s2 & InsCode i <> 3 implies
   DataPart Exec(i,s1) = DataPart Exec(i,s2);

theorem :: SCMPDS_5:44
  for i being shiftable Instruction of SCMPDS holds (DataPart s1 =
  DataPart s2 implies DataPart Exec(i,s1) = DataPart Exec(i,s2));

theorem :: SCMPDS_5:45
  for i being parahalting Instruction of SCMPDS
   holds Exec(i,Initialize s) = IExec(Load i, s);

theorem :: SCMPDS_5:46
 for s being 0-started State of SCMPDS
  for I being parahalting halt-free Program of SCMPDS,
      j being parahalting shiftable Instruction of SCMPDS
 holds IExec(I ';' j, s).a = Exec(j,IExec(I, s)).a;

theorem :: SCMPDS_5:47
  for s being 0-started State of SCMPDS
  for i being No-StopCode parahalting Instruction of SCMPDS, j being
shiftable parahalting Instruction of SCMPDS holds IExec(i ';' j, s).a = Exec(j,
  Exec(i, Initialize s)).a;

theorem :: SCMPDS_5:48
  IExec(I,Initialize s) = IExec(I,s);
