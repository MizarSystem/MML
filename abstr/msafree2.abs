:: Preliminaries to Circuits, II
::  by Yatsuka Nakamura , Piotr Rudnicki , Andrzej Trybulec and Pauline N. Kawamoto
::
:: Received December 13, 1994
:: Copyright (c) 1994 Association of Mizar Users

environ

 vocabulary MSUALG_1, UNIALG_2, AMI_1, BOOLE, RELAT_1, FUNCT_1, FUNCOP_1,
      ZF_REFLE, PBOOLE, CARD_3, FINSEQ_1, QC_LANG1, FINSEQ_4, TDGROUP, PRELAMB,
      MSAFREE, FREEALG, PRALG_1, ALG_1, TREES_4, REALSET1, MSUALG_2, PRE_CIRC,
      FINSET_1, CAT_1, TREES_2, DTCONSTR, TREES_3, CARD_1, LANG1, PROB_1,
      TREES_1, MSAFREE2;
 notation TARSKI, XBOOLE_0, ZFMISC_1, SUBSET_1, NAT_1, CARD_1, RELAT_1,
      FUNCT_1, STRUCT_0, FINSET_1, FINSEQ_1, FUNCT_2, PROB_1, CARD_3, TREES_1,
      TREES_2, TREES_3, TREES_4, PBOOLE, PRALG_1, MSUALG_1, FINSEQ_2, MSAFREE,
      MSUALG_2, CQC_LANG, DTCONSTR, LANG1, GROUP_1, RELSET_1, MSUALG_3,
      FINSEQ_4, PRE_CIRC;
 constructors NAT_1, AMI_1, MSAFREE, GROUP_1, MSUALG_3, PRE_CIRC, FINSOP_1,
      PRVECT_1, FINSEQ_4, XBOOLE_0;
 clusters FINSET_1, TREES_1, TREES_2, TREES_3, DTCONSTR, PRELAMB, PRALG_1,
      MSUALG_1, MSAFREE, MSUALG_2, PRE_CIRC, CARD_1, FUNCT_1, RELSET_1,
      STRUCT_0, CQC_LANG, XBOOLE_0, ZFMISC_1;
 requirements BOOLE, SUBSET;


begin

::---------------------------------------------------------------------------
:: Many Sorted Signatures
::---------------------------------------------------------------------------

definition
  let S be ManySortedSign;
  mode Vertex of S is Element of S;
end;


definition
  let S be non empty ManySortedSign;
  func SortsWithConstants S -> Subset of S equals
:: MSAFREE2:def 1

     { v where v is SortSymbol of S : v is with_const_op }
      if S is non void otherwise {};
end;


definition
  let G be non empty ManySortedSign;
  func InputVertices G -> Subset of G equals
:: MSAFREE2:def 2

     (the carrier of G) \ rng the ResultSort of G;

  func InnerVertices G -> Subset of G equals
:: MSAFREE2:def 3

     rng the ResultSort of G;
end;


theorem :: MSAFREE2:1
    for G being void non empty ManySortedSign
    holds InputVertices G = the carrier of G;

theorem :: MSAFREE2:2
  for G being non void non empty ManySortedSign, v being Vertex of G
    st v in InputVertices G
    holds not ex o being OperSymbol of G st the_result_sort_of o = v;

theorem :: MSAFREE2:3
    for G being non empty ManySortedSign
    holds InputVertices G \/ InnerVertices G = the carrier of G;

theorem :: MSAFREE2:4
  for G being non empty ManySortedSign
    holds InputVertices G misses InnerVertices G;

theorem :: MSAFREE2:5
  for G being non empty ManySortedSign
    holds SortsWithConstants G c= InnerVertices G;

theorem :: MSAFREE2:6
    for G being non empty ManySortedSign
    holds InputVertices G misses SortsWithConstants G;

definition let IT be non empty ManySortedSign;
  attr IT is with_input_V means
:: MSAFREE2:def 4

    InputVertices IT <> {};
end;


registration
  cluster non void with_input_V (non empty ManySortedSign);
  existence
    proof
        {} in {{},{{}}}* by FINSEQ_1:66;
      then reconsider f = {{}}-->{} as Function of {{}},{{},{{}}}*
        by FUNCOP_1:58;
        {} in {{},{{}}} by TARSKI:def 2;
      then reconsider g = {{}}-->{} as Function of {{}},{{},{{}
}} by FUNCOP_1:58;
      take c = ManySortedSign (# {{},{{}}}, {{}}, f, g #);
        c is with_input_V
        proof
A1:        {{}} in the carrier of c by TARSKI:def 2;
          rng the ResultSort of c = {{}} by FUNCOP_1:14;
          then not {{}} in rng the ResultSort of c;
          then {{}} in (the carrier of c) \ rng the ResultSort of c
            by A1,XBOOLE_0:def 4;
          then InputVertices c <> {} by Def2;
          hence thesis by Def4;
        end;
      hence thesis by MSUALG_1:def 5;
    end;
end;


registration
  let G be with_input_V (non empty ManySortedSign);
  cluster InputVertices G -> non empty;
  coherence by Def4;
end;


definition
  let G be non void non empty ManySortedSign;
  redefine func InnerVertices G -> non empty Subset of G;
end;


definition
  let S be non empty ManySortedSign;
  let MSA be non-empty MSAlgebra over S;
  mode InputValues of MSA -> ManySortedSet of InputVertices S means
:: MSAFREE2:def 5
      for v being Vertex of S st v in InputVertices S
      holds it.v in (the Sorts of MSA).v;
end;


:: Generalize this for arbitrary subset of the carrier



definition
  let S be non empty ManySortedSign;
  attr S is Circuit-like means
:: MSAFREE2:def 6
    for S' being non void non empty ManySortedSign st S' = S
      for o1, o2 being OperSymbol of S'
        st the_result_sort_of o1 = the_result_sort_of o2
        holds o1 = o2;
end;


registration
  cluster void -> Circuit-like (non empty ManySortedSign);
  coherence
    proof
      let S be non empty ManySortedSign such that
A1:      S is void;
      let S' be non void non empty ManySortedSign;
      thus thesis by A1;
    end;
end;


registration
  cluster non void Circuit-like strict (non empty ManySortedSign);
  existence
    proof
        {} in {{}}* by FINSEQ_1:66;
      then reconsider f = {{}}-->{} as Function of {{}},{{}}* by FUNCOP_1:58;
        {} in {{}} by TARSKI:def 1;
      then reconsider g = {{}}-->{} as Function of {{}},{{}} by FUNCOP_1:58;
      take c = ManySortedSign(#{{}},{{}},f,g#);
        c is Circuit-like
        proof
          let S be non void non empty ManySortedSign;
          assume
A1:          S = c;
          let v1, v2 be OperSymbol of S such that
              the_result_sort_of v1 = the_result_sort_of v2;
          thus v1 = {} by A1,TARSKI:def 1 .= v2 by A1,TARSKI:def 1;
        end;
      hence thesis by MSUALG_1:def 5;
    end;
end;


definition
  let IIG be Circuit-like non void (non empty ManySortedSign);
  let v be Vertex of IIG such that
  v in InnerVertices IIG;
  func action_at v -> OperSymbol of IIG means
:: MSAFREE2:def 7

      the_result_sort_of it = v;
end;


begin

::---------------------------------------------------------------------------
:: Free Many Sorted Algebras
::---------------------------------------------------------------------------

theorem :: MSAFREE2:7
    for S being non void non empty ManySortedSign, A being MSAlgebra over S,
    o being OperSymbol of S,
    p being FinSequence st len p = len the_arity_of o
      & for k being Nat st k in dom p
          holds p.k in (the Sorts of A).((the_arity_of o)/.k)
    holds p in Args (o, A);

definition
  let S be non void non empty ManySortedSign,
    MSA be non-empty MSAlgebra over S;
  func FreeEnv MSA -> free strict (non-empty MSAlgebra over S) equals
:: MSAFREE2:def 8

     FreeMSA (the Sorts of MSA);
end;


theorem :: MSAFREE2:8
    for S being non void non empty ManySortedSign,
    MSA being non-empty MSAlgebra over S
    holds FreeGen(the Sorts of MSA) is free GeneratorSet of FreeEnv MSA;

definition
  let S be non void non empty ManySortedSign,
    MSA be non-empty MSAlgebra over S;
  func Eval MSA -> ManySortedFunction of FreeEnv MSA, MSA means
:: MSAFREE2:def 9

      it is_homomorphism FreeEnv MSA, MSA
      & for s being SortSymbol of S,
          x, y being set st y in FreeSort(the Sorts of MSA, s)
            & y = root-tree [x, s]
            & x in (the Sorts of MSA).s
          holds it.s.y = x;
end;



theorem :: MSAFREE2:9
  for S being non void non empty ManySortedSign,
      A being non-empty MSAlgebra over S
    holds the Sorts of A is GeneratorSet of A;

definition
  let S be non empty ManySortedSign;
  let IT be MSAlgebra over S;
  attr IT is finitely-generated means
:: MSAFREE2:def 10

    for S' being non void non empty ManySortedSign st S' = S
      for A being MSAlgebra over S' st A = IT
        ex G being GeneratorSet of A st G is locally-finite if S is not void
        otherwise the Sorts of IT is locally-finite;
end;


definition
  let S be non empty ManySortedSign;
  let IT be MSAlgebra over S;
  attr IT is locally-finite means
:: MSAFREE2:def 11

    the Sorts of IT is locally-finite;
end;


registration
  let S be non empty ManySortedSign;
  cluster locally-finite -> finitely-generated (non-empty MSAlgebra over S);
  coherence
    proof
      let A be non-empty MSAlgebra over S;
      assume
      A1: A is locally-finite;
      per cases;
      case S is non void;
      let S' be non void non empty ManySortedSign such that
A2:     S' = S;
      let A' be MSAlgebra over S'; assume
       A' = A;
      then reconsider G = the Sorts of A as GeneratorSet of A'
        by A2,Th9;
      take G;
      thus G is locally-finite by A1,A2,Def11;
      end;
      case S is void;
      thus the Sorts of A is locally-finite by A1,Def11;
    end;
    end;
end;


 definition
   let S be non empty ManySortedSign;
   func Trivial_Algebra S -> strict MSAlgebra over S means
:: MSAFREE2:def 12

   the Sorts of it = (the carrier of S) --> {0};
 end;


registration
  let S be non empty ManySortedSign;
  cluster locally-finite non-empty strict MSAlgebra over S;
  existence
    proof
     take T = Trivial_Algebra S;
A1:   the Sorts of T = (the carrier of S) --> {0} by Def12;
     thus T is locally-finite
       proof
         thus the Sorts of T is locally-finite
           proof
             let i be set;
             assume i in the carrier of S;
             hence (the Sorts of T).i is finite by A1,FUNCOP_1:13;
           end;
       end;
     thus T is non-empty
      proof
         thus the Sorts of T is non-empty
           proof
             let i be set;
             assume i in the carrier of S;
             hence (the Sorts of T).i is non empty by A1,FUNCOP_1:13;
           end;
      end;
     thus thesis;
    end;
end;


definition let IT be non empty ManySortedSign;
  attr IT is monotonic means
:: MSAFREE2:def 13
      for A being finitely-generated (non-empty MSAlgebra over IT)
      holds A is locally-finite;
end;


registration
  cluster non void finite monotonic Circuit-like (non empty ManySortedSign);
  existence
    proof
        {} in {{}}* by FINSEQ_1:66;
      then reconsider f = {[{},{{}}]}-->{} as Function of {[{},{{}}]},{{}}*
        by FUNCOP_1:58;
        {} in {{}} by TARSKI:def 1;
      then reconsider g = {[{},{{}}]}-->{} as Function of
        {[{},{{}}]},{{}} by FUNCOP_1:58;
      take S = ManySortedSign (# {{}}, {[{},{{}}]}, f, g #);
      thus
       S is non void by MSUALG_1:def 5;
      thus S is finite
        proof
          thus the carrier of S is finite;
        end;
      thus S is monotonic
        proof
          let A be finitely-generated (non-empty MSAlgebra over S);
          reconsider S' = S as non void non empty ManySortedSign by MSUALG_1:
def 5;
          reconsider A' = A as non-empty MSAlgebra over S';
          consider G being GeneratorSet of A' such that
A1:         G is locally-finite by Def10;
          consider s being SortSymbol of S';
A2:         s = {} by TARSKI:def 1;
          consider o being OperSymbol of S';
A3:         o = [{},{{}}] by TARSKI:def 1;
A4:       Args(o,A') = ((the Sorts of A')# * the Arity of S).o
            by MSUALG_1:def 9
            .= (the Sorts of A')#.((the Arity of S).o) by FUNCT_2:21
            .= (the Sorts of A')#.<*>the carrier of S' by FUNCOP_1:13
            .= {{}} by PRE_CIRC:5;
          then A5:         dom Den(o,A') = {{}} by FUNCT_2:def 1;

A6:       Result(o,A') = ((the Sorts of A')*the ResultSort of S).o
            by MSUALG_1:def 10
            .= (the Sorts of A').((the ResultSort of S).o) by FUNCT_2:21
            .= (the Sorts of A').{} by FUNCOP_1:13;

          set T = s .--> (G.s \/ { Den(o,A').{} });
       A7: dom T = the carrier of S by A2,CQC_LANG:5;
            now
            let i be set;
            assume i in the carrier of S;
            then i = s by A2,TARSKI:def 1;
            hence T.i is non empty by CQC_LANG:6;
          end;
          then reconsider T as non-empty ManySortedSet
            of the carrier of S by A7,PBOOLE:def 3,def 16;

          set O = (o .--> Den(o,A'));
        dom O = the OperSymbols of S by A3,CQC_LANG:5;
          then A8:        O is ManySortedSet of the OperSymbols of S by PBOOLE:
def 3;
            now
            let i be set;
            assume
A9:          i in the OperSymbols of S;
            then i = [{},{{}}] by TARSKI:def 1;
            then A10: i = o by TARSKI:def 1;
            then A11:          O.i = Den(o,A') by CQC_LANG:6;
              (T# * the Arity of S).i = T#.((the Arity of S).i) by A9,FUNCT_2:
21
                .= T#.(<*>the carrier of S) by A9,FUNCOP_1:13
                .= {{}} by PRE_CIRC:5;
            then reconsider Oi = O.i as Function of (T# * the Arity of S).i,
              Result(o,A') by A4,A10,CQC_LANG:6;
            A12:          rng (Oi) = { Den(o,A').{} } by A5,A11,FUNCT_1:14;
              (T * the ResultSort of S).i = T.((the ResultSort of S).i)
              by A9,FUNCT_2:21
              .= T.s by A2,A9,FUNCOP_1:13
              .= G.s \/ { Den(o,A').{} } by CQC_LANG:6;
            then rng (Oi) c= (T * the ResultSort of S).i by A12,XBOOLE_1:7;
            hence O.i is Function of (T# * the Arity of S).i,
              (T * the ResultSort of S).i by FUNCT_2:8;
          end;
          then reconsider O as ManySortedFunction of
            (T# * the Arity of S), (T * the ResultSort of S)
            by A8,MSUALG_1:def 2;

          reconsider G' = G as MSSubset of A';
          reconsider T' = T as ManySortedSet of the carrier of S';
            T' c= the Sorts of A'
            proof
              let i be set;
              assume i in the carrier of S';
              then A13:            i = {} by TARSKI:def 1;
              then A14:            T'.i = (G.s \/ { Den(o,A').{} }) by A2,
CQC_LANG:6;
                G c= the Sorts of A' by MSUALG_2:def 1;
              then A15:            G.s c= (the Sorts of A').i by A2,A13,PBOOLE:
def 5;
                dom Den(o,A') = Args(o,A') by FUNCT_2:def 1;
              then {} in dom Den(o,A') by A4,TARSKI:def 1;
              then Den(o,A').{} in rng Den(o,A') by FUNCT_1:def 5;
              then { Den(o,A').{} } c= (the Sorts of A').i by A6,A13,ZFMISC_1:
37;
              hence T'.i c= (the Sorts of A').i by A14,A15,XBOOLE_1:8;
            end;
          then A16:        the Sorts of MSAlgebra (# T, O #)
 is MSSubset of A' by MSUALG_2:def 1
;
          reconsider A'' = MSAlgebra (# T, O #)
             as non-empty MSAlgebra over S' by MSUALG_1:def 8;
            now
            let B be MSSubset of A';
            assume
A17:          B = the Sorts of MSAlgebra (# T, O #);
            thus
A18:           B is opers_closed
              proof
                let o' be OperSymbol of S';
                let x be set;
                A19:               o' = o by A3,TARSKI:def 1;
A20:            (B# * the Arity of S).o
                  = B#.((the Arity of S).o) by FUNCT_2:21
                 .= T#.(<*>the carrier of S) by A17,FUNCOP_1:13
                 .= {{}} by PRE_CIRC:5;
A21:             Den(o,A')|{{}} = Den(o,A') by A5,RELAT_1:97;

                assume x in rng ((Den(o',A'))|((B# * the Arity of S').o'));
                then consider y being set such that
A22:               y in dom(Den(o,A')) and
A23:               x = (Den(o,A')).y by A19,A20,A21,FUNCT_1:def 5;
A24:              x = Den(o,A').{} by A4,A22,A23,TARSKI:def 1;
A25:              B.s = (G.s \/ { Den(o,A').{} }) by A17,CQC_LANG:6;
                  x in { Den(o,A').{} } by A24,TARSKI:def 1;
then A26:              x in B.s by A25,XBOOLE_0:def 2;
                A27: dom the ResultSort of S' = {[{},{{}}]} by FUNCOP_1:19;
                  (the ResultSort of S').o = s by A2,FUNCOP_1:13;
                hence x in (B * the ResultSort of S').o'
                  by A19,A26,A27,FUNCT_1:23;
              end;

              now
              let o' be OperSymbol of S';
A28:             o' = o by A3,TARSKI:def 1;
A29:           B is_closed_on o by A18,MSUALG_2:def 7;
            (B# * the Arity of S').o
                = B#.((the Arity of S').o) by FUNCT_2:21
               .= T#.(<*>the carrier of S') by A17,FUNCOP_1:13
               .= {{}} by PRE_CIRC:5;
then (Den(o,A')) | ((B# * the Arity of S').o)
                = Den(o,A') by A5,RELAT_1:97;
              then (the Charact of MSAlgebra (# T, O #)).o
                = (Den(o,A')) | ((B# * the Arity of S').o) by CQC_LANG:6;
              hence (the Charact of MSAlgebra (# T, O #)).o' = o'/.B
                by A28,A29,MSUALG_2:def 8;
            end;
            hence the Charact of MSAlgebra (# T, O #) = Opers(A',B)
              by A17,MSUALG_2:def 9;
          end;
          then reconsider A'' as
            strict MSSubAlgebra of A' by A16,MSUALG_2:def 10;

            now
            let i be set;
            assume i in the carrier of S';
            then A30:          i = s by A2,TARSKI:def 1;
          (the Sorts of A'').s = G.s \/ { Den(o,A').{} } by CQC_LANG:6;
            hence G'.i c= (the Sorts of A'').i by A30,XBOOLE_1:7;
          end;
          then G' c= the Sorts of A'' by PBOOLE:def 5;
          then A31:         G' is MSSubset of A'' by MSUALG_2:def 1;

            now
            let U1 be MSSubAlgebra of A';
            assume
A32:          G' is MSSubset of U1;
              now
              let i be set;
              assume i in the carrier of S';
              then A33:            i = s by A2,TARSKI:def 1;
A34:          (the Sorts of A'').s = G.s \/ { Den(o,A').{} } by CQC_LANG:6;
                G c= (the Sorts of U1) by A32,MSUALG_2:def 1;
              then A35:            G.s c= (the Sorts of U1).s by PBOOLE:def 5;
                Constants(A') is MSSubset of U1 by MSUALG_2:11;
              then Constants(A') c= the Sorts of U1 by MSUALG_2:def 1;
              then (Constants(A')).s c= (the Sorts of U1).s by PBOOLE:def 5;
              then A36:            Constants(A',s) c= (the Sorts of U1).s by
MSUALG_2:def 5;

              A37: {} in dom Den(o,A') by A5,TARSKI:def 1;
              then Den(o,A').{} in rng Den(o,A') by FUNCT_1:def 5;
              then reconsider b = Den(o,A').{} as Element
                of (the Sorts of A').s by A6,TARSKI:def 1;
A38:           (the Arity of S').o = {} by FUNCOP_1:13;
              consider X being non empty set such that
A39:             X =(the Sorts of A').s &
               Constants(A',s) = { a where a is Element of X :
               ex o be OperSymbol of S' st (the Arity of S').o = {} &
              (the ResultSort of S').o = s & a in rng Den(o,A')}
                                                     by MSUALG_2:def 4;
                b in rng Den(o,A') by A37,FUNCT_1:def 5;
              then Den(o,A').{} in Constants(A',s) by A2,A38,A39;
              then { Den(o,A').{} } c= (the Sorts of U1).s by A36,ZFMISC_1:37;
              hence (the Sorts of A'').i c= (the Sorts of U1).i
               by A33,A34,A35,XBOOLE_1:8;
            end;
            then the Sorts of A'' c= the Sorts of U1 by PBOOLE:def 5;
            hence A'' is MSSubAlgebra of U1 by MSUALG_2:9;
          end;
          then A40:         s.--> (G.s \/ { Den(o, A').{} }) = the Sorts of
GenMSAlg(G) by A31,MSUALG_2:def 18
              .= the Sorts of A' by MSAFREE:def 4;

          reconsider Gs = G.s as finite set by A1,PRE_CIRC:def 3;
          let i be set;
          assume i in the carrier of S;
          then i = s by A2,TARSKI:def 1;
          then (the Sorts of A).i = Gs \/ { Den(o,A').{} } by A40,CQC_LANG:6;
          hence (the Sorts of A).i is finite;
        end;
      thus S is Circuit-like
        proof
          let S' be non void non empty ManySortedSign;
          assume
A41:         S' = S;
          let o1, o2 be OperSymbol of S' such that
              the_result_sort_of o1 = the_result_sort_of o2;
         o1 = [{},{{}}] by A41,TARSKI:def 1;
          hence o1 = o2 by A41,TARSKI:def 1;
        end;
    end;
end;


theorem :: MSAFREE2:10
  for S being non void non empty ManySortedSign
    for X being non-empty ManySortedSet of the carrier of S,
      v be SortSymbol of S,
      e be Element of (the Sorts of FreeMSA X).v
      holds e is finite DecoratedTree;

theorem :: MSAFREE2:11
    for S being non void non empty ManySortedSign,
    X being non-empty locally-finite ManySortedSet of the carrier of S
    holds FreeMSA X is finitely-generated;

theorem :: MSAFREE2:12
    for S being non void non empty ManySortedSign,
    A being non-empty MSAlgebra over S,
    v being Vertex of S,
    e being Element of (the Sorts of FreeEnv A).v
      st v in InputVertices S
    ex x being Element of (the Sorts of A).v st e = root-tree [x, v];

theorem :: MSAFREE2:13
  for S being non void non empty ManySortedSign,
    X being non-empty ManySortedSet of the carrier of S,
    o being OperSymbol of S,
    p being DTree-yielding FinSequence
      st [o,the carrier of S]-tree p
             in (the Sorts of FreeMSA X).(the_result_sort_of o)
    holds len p = len the_arity_of o;

theorem :: MSAFREE2:14
  for S being non void non empty ManySortedSign,
    X being non-empty ManySortedSet of the carrier of S,
    o being OperSymbol of S,
    p being DTree-yielding FinSequence
      st [o,the carrier of S]-tree p
             in (the Sorts of FreeMSA X).(the_result_sort_of o)
    holds
      for i being Nat st i in dom the_arity_of o
        holds p.i in (the Sorts of FreeMSA X).((the_arity_of o).i);

registration
  let S be non void non empty ManySortedSign,
    X be non-empty ManySortedSet of the carrier of S,
    v be Vertex of S;
  cluster -> finite non empty
   Function-like Relation-like Element of (the Sorts of FreeMSA X).v;
  coherence
  proof
    let e be Element of (the Sorts of FreeMSA X).v;
    thus e is finite by Th10;
     reconsider e' = e as DecoratedTree by Th10;
       dom e' is Tree;
    hence e is non empty by RELAT_1:60;
    thus thesis by Th10;
  end;
end;


registration
  let S be non void non empty ManySortedSign,
    X be non-empty ManySortedSet of the carrier of S,
    v be Vertex of S;
  cluster Function-like Relation-like Element of (the Sorts of FreeMSA X).v;
  existence
   proof
     consider e being Element of (the Sorts of FreeMSA X).v;
     take e;
     thus thesis;
   end;
end;


registration
  let S be non void non empty ManySortedSign,
    X be non-empty ManySortedSet of the carrier of S,
    v be Vertex of S;
  cluster -> DecoratedTree-like
         (Function-like Relation-like Element of (the Sorts of FreeMSA X).v);
  coherence by Th10;
end;


registration
  let IIG be non void non empty ManySortedSign;
  let X be non-empty ManySortedSet of the carrier of IIG,
    v be Vertex of IIG;
  cluster finite Element of (the Sorts of FreeMSA X).v;
  existence
    proof
      consider e being Element of (the Sorts of FreeMSA X).v;
      take e;
      thus thesis;
    end;
end;


theorem :: MSAFREE2:15
    for S being non void non empty ManySortedSign,
    X being non-empty ManySortedSet of the carrier of S,
    v being Vertex of S, o being OperSymbol of S,
    e being Element of (the Sorts of FreeMSA X).v
      st v in InnerVertices S & e.{} = [o,the carrier of S]
    ex p being DTree-yielding FinSequence st len p = len the_arity_of o
      & for i being Nat st i in dom p
          holds p.i in (the Sorts of FreeMSA X).((the_arity_of o).i);

definition
  let S be non void non empty ManySortedSign,
    X be non-empty ManySortedSet of the carrier of S,
    v be SortSymbol of S,
    e be Element of (the Sorts of FreeMSA X).v;
  func depth e -> Nat means
:: MSAFREE2:def 14
      ex dt being finite DecoratedTree, t being finite Tree
      st dt = e & t = dom dt & it = height t;
end;


