:: Cyclic Groups and Some of Their Properties - Part I
::  by Dariusz Surowik
::
:: Received November 22, 1991
:: Copyright (c) 1991 Association of Mizar Users

environ

 vocabularies INT_1, REALSET1, FINSEQ_1, NAT_1, ORDINAL2, ARYTM, BINOP_1,
      FUNCT_1, VECTSP_1, QC_LANG1, SETWISEO, RLVECT_1, FINSEQ_2, GROUP_1,
      GROUP_4, RELAT_1, ARYTM_1, FINSET_1, CARD_1, GROUP_2, TARSKI, ARYTM_3,
      FILTER_0, RLSUB_1, GRAPH_1, GR_CY_1, CARD_3;
 notations TARSKI, XBOOLE_0, ZFMISC_1, SUBSET_1, ORDINAL1, ORDINAL2, NUMBERS,
      XCMPLX_0, RELAT_1, FUNCT_1, REAL_1, FUNCT_2, CARD_1, FINSET_1, BINOP_1,
      DOMAIN_1, INT_1, BINOP_2, REALSET1, INT_2, NAT_1, RLVECT_1, GROUP_2,
      XXREAL_0, STRUCT_0, GROUP_1, GROUP_4, FUNCOP_1, FINSOP_1, SETWOP_2,
      FINSEQ_1;
 constructors WELLORD2, DOMAIN_1, BINOP_1, SETWISEO, XXREAL_0, REAL_1, NAT_1,
      BINOP_2, MEMBERED, FINSOP_1, REALSET1, INT_2, RLVECT_1, GROUP_4,
      ORDINAL2;
 registrations SUBSET_1, INT_1, GROUP_1, GROUP_2, RELSET_1, STRUCT_0, FINSEQ_1,
      XREAL_0, MEMBERED, ORDINAL2, NAT_1, BINOP_2, REALSET1, XXREAL_0,
      ORDINAL1;
 requirements NUMERALS, REAL, SUBSET, BOOLE, ARITHM;


begin

 reserve i1,i2,i3 for Element of INT;
 reserve j1,j2,j3 for Integer;
 reserve p,s,r,g,k,n,m,q,t for Nat;
 reserve x,y,xp,yp for set;
 reserve G for Group;
 reserve a,b for Element of G;
 reserve F for FinSequence of the carrier of G;
 reserve I for FinSequence of INT;

definition let n be natural number such that n > 0;
 func Segm (n) -> non empty Subset of NAT equals
:: GR_CY_1:def 1
  {p: p<n};
end;

canceled 9;

theorem :: GR_CY_1:10
  for n,s being natural number st n > 0 holds s in Segm (n) iff s < n;

canceled;

theorem :: GR_CY_1:12
  for n being natural number st n > 0 holds 0 in Segm (n);

theorem :: GR_CY_1:13
  Segm (1) = {0};

       :::::::::::::::::::::::::::::::::::::::::::::::::::::
       ::              Definition addint                  ::
       :::::::::::::::::::::::::::::::::::::::::::::::::::::

definition
  redefine func addint means
:: GR_CY_1:def 2
  for i1,i2 being Element of INT holds
  it.(i1,i2) = addreal.(i1,i2);
end;

theorem :: GR_CY_1:14
  addint.(j1,j2)=j1+j2;

theorem :: GR_CY_1:15
  for i1 st i1 = 0 holds i1 is_a_unity_wrt addint;

definition let F be FinSequence of INT;
 func Sum(F) -> Integer equals
:: GR_CY_1:def 3
  addint $$ F;
end;

canceled 4;

theorem :: GR_CY_1:20
  Sum(I^<*i1*>) =Sum I +@i1;

theorem :: GR_CY_1:21
  Sum <*i1*> = i1;

theorem :: GR_CY_1:22
  Sum (<*> INT) = 0;

canceled;

theorem :: GR_CY_1:24
  for I being FinSequence of INT holds Product(((len I)|->a)|^I) = a|^Sum I;

    :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
    ::          Finite groups and their some properties              ::
    :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

theorem :: GR_CY_1:25
  b in gr {a} iff ex j1 st b=a|^j1;

theorem :: GR_CY_1:26
  G is finite implies a is_not_of_order_0;

theorem :: GR_CY_1:27
  G is finite implies ord a = ord gr {a};

theorem :: GR_CY_1:28
  G is finite implies ord a divides ord G;

theorem :: GR_CY_1:29
  G is finite implies a|^ord G = 1.G;

theorem :: GR_CY_1:30
  G is finite implies (a|^n)" = a|^(ord G - (n mod ord G));

theorem :: GR_CY_1:31
  for G being strict Group holds
  ord G > 1 implies ex a being Element of G st a <> 1.G;

theorem :: GR_CY_1:32
  for G being strict Group holds
  G is finite & ord G = p & p is prime implies
   for H being strict Subgroup of G holds H = (1).G or H = G;

theorem :: GR_CY_1:33
  HGrStr(#INT,addint#) is associative Group-like;

 definition
 func INT.Group -> strict Group equals
:: GR_CY_1:def 4
HGrStr(#INT,addint#);
 end;

definition let n be natural number such that n > 0;
 func addint(n) -> BinOp of Segm(n) means
:: GR_CY_1:def 5
  for k,l being Element of Segm(n) holds
  it.(k,l) = (k+l) mod n;
end;

theorem :: GR_CY_1:34
  for n being natural number st n > 0 holds
  HGrStr(#Segm(n),addint(n)#) is associative Group-like;

definition let n be natural number such that  n > 0;
 func INT.Group(n) -> strict Group equals
:: GR_CY_1:def 6
 HGrStr(#Segm(n),addint(n)#);
end;

theorem :: GR_CY_1:35
  1.INT.Group = 0;

theorem :: GR_CY_1:36
  for n be natural number st n>0 holds 1.INT.Group(n) = 0;

registration
  cluster -> integer Element of INT.Group;
end;

definition
   canceled;
 let h be Integer;
 func @'h -> Element of INT.Group equals
:: GR_CY_1:def 8
      h;
end;

theorem :: GR_CY_1:37
  for h being Element of INT.Group holds h" = -h;

 reserve G1 for Subgroup of INT.Group,
         h for Element of INT.Group;

theorem :: GR_CY_1:38
  (@'1) |^ k = k;

theorem :: GR_CY_1:39
  j1 = (@'1) |^ j1;

definition let IT be Group;
 attr IT is cyclic means
:: GR_CY_1:def 9
  ex a being Element of IT st the HGrStr of IT=gr {a};
end;

registration
 cluster strict cyclic Group;
end;

theorem :: GR_CY_1:40
  (1).G is cyclic;

registration
  let G be Group;
  cluster (1).G -> cyclic;
end;

theorem :: GR_CY_1:41
  G is cyclic Group iff ex a being Element of G st
  for b being Element of G ex j1 st b=a|^j1;

theorem :: GR_CY_1:42
  G is finite implies (G is cyclic Group iff
  ex a being Element of G st
  for b being Element of G ex n st b=a|^n);

theorem :: GR_CY_1:43
  for G being strict Group holds
  G is finite implies
   ( G is cyclic Group iff
      ex a being Element of G st ord a =ord G );

theorem :: GR_CY_1:44
  for H being strict Subgroup of G holds
  G is finite & G is cyclic Group implies
   H is cyclic Group;

theorem :: GR_CY_1:45
  for G being strict Group holds
  G is finite & ord (G) = p & p is prime implies
   G is cyclic Group;

theorem :: GR_CY_1:46
  for n st n>0 ex g being Element of INT.Group(n) st
  for b being Element of INT.Group(n) ex j1 st b = g|^j1;

registration
 cluster cyclic -> commutative Group;
end;

theorem :: GR_CY_1:47
  INT.Group = gr {@'1};

theorem :: GR_CY_1:48
  INT.Group is cyclic;

registration
  cluster INT.Group -> cyclic;
end;

theorem :: GR_CY_1:49
  n > 0 implies INT.Group(n) is cyclic;

theorem :: GR_CY_1:50
  INT.Group is commutative;

theorem :: GR_CY_1:51
  0 < m & m <= n implies Segm m c= Segm n;

