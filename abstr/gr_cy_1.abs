:: Cyclic Groups and Some of Their Properties - Part I
::  by Dariusz Surowik
::
:: Received November 22, 1991
:: Copyright (c) 1991 Association of Mizar Users

environ

 vocabularies NUMBERS, SUBSET_1, INT_1, GROUP_1, FINSEQ_1, XCMPLX_0, ORDINAL1,
      CARD_1, XBOOLE_0, BINOP_2, FUNCT_1, BINOP_1, ARYTM_3, CARD_3, SETWISEO,
      RELAT_1, TARSKI, NAT_1, SETWOP_2, FINSEQ_2, NEWTON, STRUCT_0, ORDINAL4,
      QC_LANG1, GROUP_4, ARYTM_1, FINSET_1, XXREAL_0, GROUP_2, ALGSTR_0,
      ZFMISC_1, REALSET1, REAL_1, INT_2, RLSUB_1, GRAPH_1, GR_CY_1;
 notations TARSKI, XBOOLE_0, ZFMISC_1, SUBSET_1, CARD_1, ORDINAL1, NUMBERS,
      XCMPLX_0, RELAT_1, FUNCT_1, REAL_1, FUNCT_2, FINSET_1, BINOP_1, DOMAIN_1,
      INT_1, FINSEQ_1, FINSOP_1, SETWISEO, SETWOP_2, BINOP_2, REALSET1, INT_2,
      NAT_1, NAT_D, RVSUM_1, GROUP_2, XXREAL_0, STRUCT_0, ALGSTR_0, GROUP_1,
      GROUP_4;
 constructors WELLORD2, BINOP_1, SETWISEO, XXREAL_0, REAL_1, NAT_1, NAT_D,
      BINOP_2, FINSOP_1, SETWOP_2, RVSUM_1, REALSET1, GROUP_4, FUNCOP_1,
      RELSET_1;
 registrations XBOOLE_0, SUBSET_1, RELAT_1, NUMBERS, XXREAL_0, XREAL_0, NAT_1,
      INT_1, BINOP_2, MEMBERED, FINSEQ_1, REALSET1, STRUCT_0, GROUP_1, GROUP_2,
      VALUED_0, ALGSTR_0, CARD_1, FINSEQ_2;
 requirements NUMERALS, REAL, SUBSET, BOOLE, ARITHM;


begin

reserve i1 for Element of INT;
reserve j1,j2,j3 for Integer;
reserve p,s,k,n,m for Element of NAT;
reserve x,y,xp,yp for set;
reserve G for Group;
reserve a,b for Element of G;
reserve F for FinSequence of G;
reserve I for FinSequence of INT;

registration
  let n be non zero natural number;
  cluster Segm n -> non empty;
end;

:: Definition addint

definition
  canceled;
  redefine func addint means
:: GR_CY_1:def 2
  for i1,i2 being Element of INT holds it.(i1,i2) =
  addreal.(i1,i2);
end;

canceled 14;

theorem :: GR_CY_1:15
  for i1 st i1 = 0 holds i1 is_a_unity_wrt addint;

theorem :: GR_CY_1:16
  Sum I = addint $$ I;

definition
  let I;
  redefine func Sum(I) -> Element of INT equals
:: GR_CY_1:def 3
  addint $$ I;
end;

canceled 5;

theorem :: GR_CY_1:22
  Sum (<*> INT) = 0;

canceled;

theorem :: GR_CY_1:24
  for I being FinSequence of INT holds Product(((len I)|->a)|^I) =
  a|^Sum I;

:: Finite groups and their some properties

theorem :: GR_CY_1:25
  b in gr {a} iff ex j1 st b=a|^j1;

theorem :: GR_CY_1:26
  for G being finite Group, a being Element of G holds a is not
  being_of_order_0;

theorem :: GR_CY_1:27
  for G being finite Group, a being Element of G holds ord a =
  card gr {a};

theorem :: GR_CY_1:28
  for G being finite Group, a being Element of G holds ord a
  divides card G;

theorem :: GR_CY_1:29
  for G being finite Group, a being Element of G holds a|^card G =
  1_G;

theorem :: GR_CY_1:30
  for G being finite Group, a being Element of G holds (a|^n)" = a
  |^(card G - (n mod card G));

registration
  let G be associative (non empty multMagma);
  cluster the multMagma of G -> associative;
end;

registration
  let G be Group;
  cluster the multMagma of G -> Group-like;
end;

theorem :: GR_CY_1:31
  for G being strict finite Group st card G > 1 ex a being Element
  of G st a <> 1_G;

theorem :: GR_CY_1:32
  for G being strict finite Group st card G = p & p is prime holds for H
  being strict Subgroup of G holds H = (1).G or H = G;

theorem :: GR_CY_1:33
  multMagma(#INT,addint#) is associative Group-like;

definition
  func INT.Group -> strict Group equals
:: GR_CY_1:def 4
  multMagma(#INT,addint#);
end;

registration
  cluster -> integer Element of INT.Group;
end;

registration
  let a,b be Element of INT.Group;
  identify a*b with a+b;
end;

registration
  let n be natural number;
  cluster -> natural Element of Segm n;
end;

definition
  let n be natural number such that
 n > 0;
  func addint(n) -> BinOp of Segm(n) means
:: GR_CY_1:def 5

  for k,l being Element of
  Segm(n) holds it.(k,l) = (k+l) mod n;
end;

theorem :: GR_CY_1:34
  for n being non zero natural number holds multMagma(#Segm(n),
    addint(n)#) is associative Group-like;

definition
  let n be natural number such that
 n > 0;
  func INT.Group(n) -> strict Group equals
:: GR_CY_1:def 6

  multMagma(#Segm(n),addint(n)
  #);
end;

registration
  let n be non zero natural number;
  cluster INT.Group(n) -> finite;
end;

theorem :: GR_CY_1:35
  1_INT.Group = 0;

theorem :: GR_CY_1:36
  for n be natural number st n>0 holds 1_INT.Group(n) = 0;

definition
  let h be Integer;
  canceled;
  func @'h -> Element of INT.Group equals
:: GR_CY_1:def 8
  h;
end;

theorem :: GR_CY_1:37
  for h being Element of INT.Group holds h" = -h;

reserve G1 for Subgroup of INT.Group;

canceled;

theorem :: GR_CY_1:39
  j1 = (@'1) |^ j1;

definition
  let IT be Group;
  attr IT is cyclic means
:: GR_CY_1:def 9

  ex a being Element of IT st the multMagma of
  IT = gr {a};
end;

registration
  cluster strict cyclic Group;
end;

theorem :: GR_CY_1:40
  (1).G is cyclic;

registration
  let G be Group;
  cluster (1).G -> cyclic;
end;

registration
  cluster strict finite cyclic Group;
end;

theorem :: GR_CY_1:41
  G is cyclic Group iff ex a being Element of G st for b being
  Element of G ex j1 st b=a|^j1;

theorem :: GR_CY_1:42
  for G being finite Group holds G is cyclic iff ex a being
  Element of G st for b being Element of G ex n st b = a|^n;

theorem :: GR_CY_1:43
  for G being finite Group holds ( G is cyclic iff ex a being
  Element of G st ord a = card G );

theorem :: GR_CY_1:44
  for G being finite Group, H being strict Subgroup of G st G is cyclic
  holds H is cyclic;

theorem :: GR_CY_1:45
  for G being strict finite Group holds card G = p & p is prime implies
  G is cyclic Group;

theorem :: GR_CY_1:46
  for n st n>0 ex g being Element of INT.Group(n) st for b being
  Element of INT.Group(n) ex j1 st b = g|^j1;

registration
  cluster cyclic -> commutative Group;
end;

theorem :: GR_CY_1:47
  INT.Group = gr {@'1};

theorem :: GR_CY_1:48
  INT.Group is cyclic;

registration
  cluster INT.Group -> cyclic;
end;

theorem :: GR_CY_1:49
  n > 0 implies INT.Group(n) is cyclic;

theorem :: GR_CY_1:50
  INT.Group is commutative;

