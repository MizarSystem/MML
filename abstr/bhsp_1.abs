:: Introduction to Banach and Hilbert spaces - Part I
::  by Jan Popio{\l}ek
::
:: Received July 19, 1991
:: Copyright (c) 1991 Association of Mizar Users

environ

 vocabulary RLVECT_1, BINOP_1, FUNCT_1, PRE_TOPC, PROB_2, RLSUB_1, ARYTM_1,
      ABSVALUE, SQUARE_1, FUNCT_3, ARYTM_3, NORMSP_1, METRIC_1, RELAT_1,
      SEQM_3, BHSP_1, ARYTM;
 notation XBOOLE_0, ZFMISC_1, SUBSET_1, ORDINAL1, NUMBERS, XCMPLX_0, XREAL_0,
      NAT_1, REAL_1, FUNCT_1, FUNCT_2, BINOP_1, STRUCT_0, RELAT_1, DOMAIN_1,
      PRE_TOPC, ABSVALUE, RLVECT_1, RLSUB_1, SQUARE_1, NORMSP_1, QUIN_1;
 constructors REAL_1, NAT_1, DOMAIN_1, ABSVALUE, RLSUB_1, SQUARE_1, NORMSP_1,
      QUIN_1, MEMBERED, XBOOLE_0;
 clusters SUBSET_1, STRUCT_0, XREAL_0, RELSET_1, SQUARE_1, MEMBERED, ZFMISC_1,
      XBOOLE_0, NUMBERS, ORDINAL2;
 requirements REAL, NUMERALS, SUBSET, BOOLE, ARITHM;


begin

definition
 struct(RLSStruct) UNITSTR (# carrier -> set,
         Zero -> Element of the carrier,
          add -> BinOp of the carrier,
         Mult -> Function of [:REAL, the carrier:], the carrier,
       scalar -> Function of [: the carrier, the carrier :], REAL #);
end;


registration
 cluster non empty strict UNITSTR;
 existence
  proof
    consider D being non empty set, Z being Element of D,
             a being BinOp of D,m being Function of [:REAL, D:], D,
             s being Function of [: D,D:],REAL;
    take UNITSTR (#D,Z,a,m,s#);
    thus the carrier of UNITSTR (#D,Z,a,m,s#) is non empty;
    thus thesis;
  end;
end;


registration
  let D be non empty set, Z be Element of D,
      a be BinOp of D,m be Function of [:REAL, D:], D,
      s be Function of [: D,D:],REAL;
  cluster UNITSTR (#D,Z,a,m,s#) -> non empty;
 coherence
  proof
   thus the carrier of UNITSTR (#D,Z,a,m,s#) is non empty;
  end;
end;


 reserve X for non empty UNITSTR;
 reserve a, b for Real;
 reserve x, y for Point of X;

definition let X; let x, y;
  func x .|. y -> Real equals
:: BHSP_1:def 1
   (the scalar of X).[x,y];
end;

definition let IT be non empty UNITSTR;
  attr IT is RealUnitarySpace-like means
:: BHSP_1:def 2
  for x , y , z being Point of IT , a holds
    ( x .|. x = 0 iff x = 0.IT ) &
    0 <= x .|. x &
    x .|. y = y .|. x &
    (x+y) .|. z = x .|. z + y .|. z &
    (a*x) .|. y = a * ( x .|. y );
end;


registration
 cluster RealUnitarySpace-like RealLinearSpace-like Abelian add-associative
   right_zeroed right_complementable strict (non empty UNITSTR);
  existence
   proof
    take X0;
    thus X0 is RealUnitarySpace-like by Def2,Lm8;
A1: now
       let x,y be VECTOR of X0;
       let x',y' be VECTOR of (0).V0;
       assume A2: x = x' & y = y';
       hence x + y= (the add of X0).[x',y'] by RLVECT_1:def 3 .=
       x' + y' by RLVECT_1:def 3;
       let a;
       thus a * x = (the Mult of X0).[a,x'] by A2,RLVECT_1:def 4 .=
       a * x' by RLVECT_1:def 4;
      end;
A3:  0.X0 = the Zero of X0 by RLVECT_1:def 2 .=
     0.(0).V0 by RLVECT_1:def 2;
    thus X0 is RealLinearSpace-like
    proof
     thus for a for v,w being VECTOR of X0 holds a * (v + w) = a * v + a * w
     proof
      let a;
      let v,w be VECTOR of X0;
      reconsider v'= v, w' = w as VECTOR of (0).V0;
A4:   a * v' = a * v by A1;
A5:  a * w' = a * w by A1;
    v + w = v'+ w' by A1;
      hence a * (v + w) = a *( v' + w') by A1 .=
      a * v' + a * w' by RLVECT_1:def 9 .= a * v + a * w by A1,A4,A5;
     end;
     thus for a,b for v being VECTOR of X0 holds (a + b) * v = a * v + b * v
     proof
      let a,b;
      let v be VECTOR of X0;
      reconsider v'= v as VECTOR of (0).V0;
A6:   a * v' = a * v by A1;
A7:  b * v' = b * v by A1;
      thus (a + b) * v = (a + b) * v' by A1 .=
      a * v' + b * v' by RLVECT_1:def 9 .= a * v + b * v by A1,A6,A7;
     end;
     thus for a,b for v being VECTOR of X0 holds (a * b) * v = a * (b * v)
     proof
      let a,b;
      let v be VECTOR of X0;
      reconsider v'= v as VECTOR of (0).V0;
A8:   b * v' = b * v by A1;
      thus (a * b) * v = (a * b) * v' by A1
                .= a * (b * v') by RLVECT_1:def 9
                .= a * (b * v) by A1,A8;
     end;
     let v be VECTOR of X0;
     reconsider v'= v as VECTOR of (0).V0;
     thus 1 * v = 1 * v' by A1 .= v by RLVECT_1:def 9;
    end;
    thus for v,w being VECTOR of X0 holds v + w = w + v
    proof
     let v,w be VECTOR of X0;
     reconsider v'= v , w'= w as VECTOR of (0).V0;
     thus v + w = w'+ v' by A1 .= w + v by A1;
    end;
     thus for u,v,w being VECTOR of X0 holds (u + v) + w = u + (v + w)
     proof
      let u,v,w be VECTOR of X0;
      reconsider u'= u, v'= v, w'= w as VECTOR of (0).V0;
      A9: u + v = u'+ v' by A1;
      A10: v + w = v' + w' by A1;
      thus (u + v) + w = (u' + v') + w' by A1,A9 .=
      u' + (v' + w') by RLVECT_1:def 6 .= u + (v + w) by A1,A10;
     end;
     thus for v being VECTOR of X0 holds v + 0.X0 = v
     proof
      let v be VECTOR of X0;
      reconsider v'= v as VECTOR of (0).V0;
      thus v + 0.X0 = v'+ 0.(0).V0 by A1,A3 .=v by RLVECT_1:10;
     end;
     thus for v being VECTOR of X0
       ex w being VECTOR of X0 st v + w = 0.X0
       proof
        let v be VECTOR of X0;
        reconsider v'= v as VECTOR of (0).V0;
        consider w' be VECTOR of (0).V0 such that
        A11: v' + w' = 0.(0).V0 by RLVECT_1:def 8;
        reconsider w = w' as VECTOR of X0;
        take w;
        thus v + w = 0.X0 by A1,A3,A11;
       end;
    thus thesis;
   end;
end;


definition
 mode RealUnitarySpace is RealUnitarySpace-like RealLinearSpace-like
  Abelian add-associative right_zeroed right_complementable
   (non empty UNITSTR);
end;


reserve X for RealUnitarySpace;
reserve x , y , z , u , v for Point of X;

definition let X; let x, y;
  redefine func x .|. y;
  commutativity;
end;


canceled 5;

theorem :: BHSP_1:6
    (0.X) .|. (0.X) = 0;

theorem :: BHSP_1:7
   x .|. (y+z) = x .|. y + x .|. z;

theorem :: BHSP_1:8
   x .|. (a*y) = a * x .|. y;

theorem :: BHSP_1:9
    (a*x) .|. y = x .|. (a*y);

theorem :: BHSP_1:10
  (a*x+b*y) .|. z = a * x .|. z + b * y .|. z;

theorem :: BHSP_1:11
    x .|. (a*y + b*z) = a * x .|. y + b * x .|. z;

theorem :: BHSP_1:12
    (-x) .|. y = x .|. (-y);

theorem :: BHSP_1:13
  (-x) .|. y = - x .|. y;

theorem :: BHSP_1:14
   x .|. (-y) = - x .|. y;

theorem :: BHSP_1:15
  (-x) .|. (-y) = x .|. y;

theorem :: BHSP_1:16
  (x - y) .|. z = x .|. z - y .|. z;

theorem :: BHSP_1:17
  x .|. (y - z) = x .|. y - x .|. z;

theorem :: BHSP_1:18
    (x - y) .|. (u - v) = x .|. u - x .|. v - y .|. u + y .|. v;

theorem :: BHSP_1:19
  (0.X) .|. x = 0;

theorem :: BHSP_1:20
   x .|. 0.X = 0;

theorem :: BHSP_1:21
  (x + y) .|. (x + y) = x .|. x + 2 * x .|. y + y .|. y;

theorem :: BHSP_1:22
    (x + y) .|. (x - y) = x .|. x - y .|. y;

theorem :: BHSP_1:23
  (x - y) .|. (x - y) = x .|. x - 2 * x .|. y + y .|. y;

theorem :: BHSP_1:24
  abs(x .|. y) <= sqrt (x .|. x) * sqrt (y .|. y);

definition let X; let x, y;
  pred x, y are_orthogonal means
:: BHSP_1:def 3
   x .|. y = 0;
  symmetry;
end;


canceled;

theorem :: BHSP_1:26
    x, y are_orthogonal implies x, - y are_orthogonal;

theorem :: BHSP_1:27
    x, y are_orthogonal implies -x, y are_orthogonal;

theorem :: BHSP_1:28
    x, y are_orthogonal implies -x, -y are_orthogonal;

theorem :: BHSP_1:29
    x, 0.X are_orthogonal;

theorem :: BHSP_1:30
    x, y are_orthogonal implies (x + y) .|. (x + y) = x .|. x + y .|. y;

theorem :: BHSP_1:31
    x, y are_orthogonal implies (x - y) .|. (x - y) = x .|. x + y .|. y;

definition let X, x;
  func ||.x.|| -> Real equals
:: BHSP_1:def 4
  sqrt (x .|. x);
end;


theorem :: BHSP_1:32
  ||.x.|| = 0 iff x = 0.X;

theorem :: BHSP_1:33
  ||.a * x.|| = abs(a) * ||.x.||;

theorem :: BHSP_1:34
  0 <= ||.x.||;

theorem :: BHSP_1:35
  abs(x .|. y) <= ||.x.|| * ||.y.||;

theorem :: BHSP_1:36
  ||.x + y.|| <= ||.x.|| + ||.y.||;

theorem :: BHSP_1:37
  ||.-x.|| = ||.x.||;

theorem :: BHSP_1:38
  ||.x.|| - ||.y.|| <= ||.x - y.||;

theorem :: BHSP_1:39
    abs(||.x.|| - ||.y.||) <= ||.x - y.||;

definition let X, x, y;
 func dist(x,y) -> Real equals
:: BHSP_1:def 5
  ||.x - y.||;
end;


theorem :: BHSP_1:40
  dist(x,y) = dist(y,x);

definition let X, x, y;
  redefine func dist(x,y);
  commutativity;
end;


theorem :: BHSP_1:41
  dist(x,x) = 0;

theorem :: BHSP_1:42
    dist(x,z) <= dist(x,y) + dist(y,z);

theorem :: BHSP_1:43
  x <> y iff dist(x,y) <> 0;

theorem :: BHSP_1:44
  dist(x,y) >= 0;

theorem :: BHSP_1:45
    x <> y iff dist(x,y) > 0;

theorem :: BHSP_1:46
    dist(x,y) = sqrt ((x-y) .|. (x-y));

theorem :: BHSP_1:47
    dist(x + y,u + v) <= dist(x,u) + dist(y,v);

theorem :: BHSP_1:48
    dist(x - y,u - v) <= dist(x,u) + dist(y,v);

theorem :: BHSP_1:49
    dist(x - z, y - z) = dist(x,y);

theorem :: BHSP_1:50
    dist(x - z,y - z) <= dist(z,x) + dist(z,y);

reserve seq, seq1, seq2, seq3 for sequence of X;
reserve k, n, m for Nat;
reserve f for Function;
reserve d, s, t for set;

scheme :: BHSP_1:sch 1
 Ex_Seq_in_RUS { X() -> non empty UNITSTR, F(Nat) -> Point of X() } :
       ex seq be sequence of X() st for n holds seq.n = F(n)
proof
       defpred P[set,set] means ex n st n =$1 & $2 = F(n);
    A1: for d st d in NAT ex s st P[d,s]
       proof
            let d; assume d in NAT;
            then reconsider n = d as Nat;
            reconsider z = F(n) as set;
            take z;
            thus thesis;
       end;
    A2: for d , s , t st d in NAT & P[d,s] & P[d,t] holds s = t;
       consider f such that
    A3: dom f = NAT and
    A4: for d st d in NAT holds P[d,f.d] from FUNCT_1:sch 2(A2,A1);
         for d st d in NAT holds f.d is Point of X()
       proof
            let d; assume d in NAT;
            then ex n st n = d & f.d = F(n) by A4;
            hence f.d is Point of X();
       end;
       then reconsider f as sequence of X() by A3,NORMSP_1:17;
       take seq = f;
       let n;
         P[n,seq.n] by A4;
       hence seq.n = F(n);
end;

definition let X; let seq;
 canceled 4;

  func - seq -> sequence of X means
:: BHSP_1:def 10
 for n holds it.n = - seq.n;
end;


definition let X; let seq; let x;
 canceled;

 func seq + x -> sequence of X means
:: BHSP_1:def 12
     for n holds it.n = seq.n + x;
end;


canceled 4;

theorem :: BHSP_1:55
  seq1 + seq2 = seq2 + seq1;

definition let X, seq1, seq2;
 redefine func seq1 + seq2;
 commutativity;
end;


theorem :: BHSP_1:56
    seq1 + (seq2 + seq3) = (seq1 + seq2) + seq3;

theorem :: BHSP_1:57
    seq1 is constant & seq2 is constant & seq = seq1 + seq2
    implies seq is constant;

theorem :: BHSP_1:58
    seq1 is constant & seq2 is constant & seq = seq1 - seq2
    implies seq is constant;

theorem :: BHSP_1:59
    seq1 is constant & seq = a * seq1
    implies seq is constant;

canceled 8;

theorem :: BHSP_1:68
  seq is constant iff for n holds seq.n = seq.(n + 1);

theorem :: BHSP_1:69
  seq is constant iff for n , k holds seq.n = seq.(n + k);

theorem :: BHSP_1:70
    seq is constant iff for n, m holds seq.n = seq.m;

theorem :: BHSP_1:71
    seq1 - seq2 = seq1 + -seq2;

theorem :: BHSP_1:72
    seq = seq + 0.X;

theorem :: BHSP_1:73
    a * (seq1 + seq2) = a * seq1 + a * seq2;

theorem :: BHSP_1:74
    (a + b) * seq = a * seq + b * seq;

theorem :: BHSP_1:75
    (a * b) * seq = a * (b * seq);

theorem :: BHSP_1:76
    1 * seq = seq;

theorem :: BHSP_1:77
    (-1) * seq = - seq;

theorem :: BHSP_1:78
    seq - x = seq + -x;

theorem :: BHSP_1:79
    seq1 - seq2 = - (seq2 - seq1);

theorem :: BHSP_1:80
    seq = seq - 0.X;

theorem :: BHSP_1:81
    seq = - ( - seq );

theorem :: BHSP_1:82
    seq1 - (seq2 + seq3) = (seq1 - seq2) - seq3;

theorem :: BHSP_1:83
    (seq1 + seq2) - seq3 = seq1 + (seq2 - seq3);

theorem :: BHSP_1:84
    seq1 - (seq2 - seq3) = (seq1 - seq2) + seq3;

theorem :: BHSP_1:85
    a * (seq1 - seq2) = a * seq1 - a * seq2;
