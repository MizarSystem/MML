:: Properties of Fields
::  by J\'ozef Bia{\l}as
::
:: Received June 20, 1990
:: Copyright (c) 1990 Association of Mizar Users

environ

 vocabularies BOOLE, REALSET1, FUNCT_1, RELAT_1, BINOP_1, RLVECT_1, QC_LANG1,
      VECTSP_1, REALSET2, NAT_1, FUNCOP_1, FUNCT_4, CAT_1, FUNCT_7, GROUP_1;
 notations TARSKI, XBOOLE_0, ENUMSET1, ZFMISC_1, SUBSET_1, RELAT_1, FUNCT_1,
      REALSET1, FUNCOP_1, FUNCT_2, BINOP_1, FUNCT_4, FUNCT_7, STRUCT_0,
      RLVECT_1, GROUP_1, VECTSP_1;
 constructors ENUMSET1, BINOP_1, REALSET1, VECTSP_1, NAT_D, FUNCOP_1, FUNCT_4,
      FUNCT_7;
 registrations REALSET1, RELSET_1, SUBSET_1, XBOOLE_0, RLVECT_1, GROUP_1,
      VECTSP_1, STRUCT_0, FUNCOP_1;
 requirements SUBSET, BOOLE;


begin

reserve x,y for set;

definition
  let IT be LoopStr;
  attr IT is zeroed means
:: REALSET2:def 1
                 for a being Element of IT holds
                      (the add of IT).(a,0.IT) = a &
                      (the add of IT).(0.IT,a) = a;
  attr IT is complementable means
:: REALSET2:def 2
                 for a being Element of IT
                  ex b being Element of IT st
                      (the add of IT).(a,b) = 0.IT &
                      (the add of IT).(b,a) = 0.IT;
end;

registration
 cluster strict Abelian add-associative zeroed
                        complementable (non empty LoopStr);
end;

definition
   mode AbGroup is Abelian add-associative zeroed complementable
    (non empty LoopStr);
end;

definition
  canceled 2;
  let IT be 1-sorted;
  attr IT is trivial means
:: REALSET2:def 5
   the carrier of IT is trivial;
end;

registration
 cluster trivial 1-sorted;
end;

registration
 cluster non trivial strict doubleLoopStr;
end;

definition
 canceled;
 let IT be 1-sorted;
 redefine attr IT is trivial means
:: REALSET2:def 7
     for x,y being Element of IT holds x = y;
end;

definition
 func add_2 -> BinOp of 2 equals
:: REALSET2:def 8
  (0,0) .--> 0 +* (0,1) .--> 1 +* (1,0) .--> 1 +* (1,1) .--> 0;
 func mult_2 -> BinOp of 2 equals
:: REALSET2:def 9
  (0,0) .--> 0 +* (0,1) .--> 0 +* (1,0) .--> 0 +* (1,1) .--> 1;
end;

definition
 func dL-Z_2 -> doubleLoopStr equals
:: REALSET2:def 10
  doubleLoopStr(#2,add_2,mult_2,In(1,2),In(0,2)#);
end;

registration
 cluster dL-Z_2 -> strict non empty;
end;

definition
  let IT be non empty doubleLoopStr;
  attr IT is Field-like means
:: REALSET2:def 11
 the LoopStr of IT is AbGroup &
 ::IT is not degenerated &
   ex A being non trivial set,
            od being BinOp of A, nd being Element of A,
            om being DnT of nd,A, nm being Element of A\{nd} st
           (IT = doubleLoopStr(#A,od,om,nm,nd#) &
           (for B being non empty set, P being BinOp of B,
                e being Element of B holds
           B = A\{nd} & e = nm & P = om!(A,nd) implies
           LoopStr(#B,P,e#) is AbGroup)) &
           for x,y,z being Element of A holds
            om.(x,od.(y,z)) = od.(om.(x,y),om.(x,z)) &
            om.(od.(x,y),z) = od.(om.(x,z),om.(y,z));
end;

registration
 let A be non trivial set,
     od be BinOp of A,
     nd be Element of A,
     om be BinOp of A,
     nm be Element of A;
 cluster doubleLoopStr(#A,od,om,nm,nd#) -> non empty;
end;

registration
 cluster strict Field-like (non empty doubleLoopStr);
end;

definition
  mode Field is Field-like (non empty doubleLoopStr);
end;

definition
   let F be Field;
   func suppf(F) -> non trivial set equals
:: REALSET2:def 12
    the carrier of F;
end;

definition
   let F be Field;
   func odf(F) -> BinOp of suppf F means
:: REALSET2:def 13
 ex nd being Element of suppf(F),
              om being DnT of nd, suppf(F),
              nm being Element of suppf(F)\{nd} st
           F = doubleLoopStr(#suppf F,it,om,nm,nd#);
end;

definition
   let F be Field;
   func ndf(F) -> Element of suppf(F) means
:: REALSET2:def 14
    ex om being DnT of it,suppf(F),
             nm being Element of suppf(F)\{it} st
           F = doubleLoopStr(#suppf F,odf F,om,nm,it#);
end;

definition
   let F be Field;
   func omf(F) -> DnT of ndf(F),suppf(F) means
:: REALSET2:def 15
   ex nm being Element of suppf(F)\{ndf(F)} st
           F = doubleLoopStr(#suppf F,odf F,it,nm,ndf F#);
end;

definition
   let F be Field;
   func nmf(F) -> Element of suppf(F)\{ndf(F)} means
:: REALSET2:def 16
       F = doubleLoopStr(#suppf F,odf F,omf F,it,ndf F#);
end;

theorem :: REALSET2:1
   for F being Field holds LoopStr(#suppf(F),odf(F),ndf(F)#) is AbGroup;

theorem :: REALSET2:2
   for F being Field, B being non empty set,
       P being BinOp of B, e being Element of B st
   B = suppf(F)\{ndf(F)} & e = nmf(F) & P = omf(F)!(suppf(F),ndf(F)) holds
    LoopStr(#B,P,e#) is AbGroup;

theorem :: REALSET2:3
   for F being Field, x,y,z being Element of suppf(F) holds
    omf(F).(x,odf(F).(y,z)) = odf(F).(omf(F).(x,y),omf(F).(x,z)) &
    omf(F).(odf(F).(x,y),z) = odf(F).(omf(F).(x,z),omf(F).(y,z));

theorem :: REALSET2:4
   for F being Field,
       a,b,c being Element of suppf(F) holds
   odf(F).(odf(F).(a,b),c) = odf(F).(a,odf(F).(b,c));

theorem :: REALSET2:5
   for F being Field,
       a,b being Element of suppf(F) holds
   odf(F).(a,b) = odf(F).(b,a);

theorem :: REALSET2:6
   for F being Field,
       a being Element of suppf(F) holds
   odf(F).(a,ndf(F)) = a & odf(F).(ndf(F),a) = a;

theorem :: REALSET2:7
   for F being Field,
       a being Element of suppf(F) ex b being Element of suppf(F) st
   odf(F).(a,b) = ndf(F) & odf(F).(b,a) = ndf(F);

theorem :: REALSET2:8
   for F being Field,
       a,b,c being Element of suppf(F)\{ndf(F)} holds
   omf(F).(omf(F).(a,b),c) = omf(F).(a,omf(F).(b,c));

theorem :: REALSET2:9
   for F being Field,
       a,b being Element of suppf(F)\{ndf(F)} holds
   omf(F).(a,b) = omf(F).(b,a);

theorem :: REALSET2:10
   for F being Field,
       a being Element of suppf(F)\{ndf(F)} holds
   omf(F).(a,nmf(F)) = a & omf(F).(nmf(F),a) = a;

theorem :: REALSET2:11
   for F being Field,
       a being Element of suppf(F)\{ndf(F)}
   ex b being Element of suppf(F)\{ndf(F)} st
   omf(F).(a,b) = nmf(F) & omf(F).(b,a) = nmf(F);

definition
   let F be Field;
   func compf(F) -> Function of suppf(F),suppf(F) means
:: REALSET2:def 17
 for x being Element of suppf(F) holds odf(F).(x,it.x) = ndf(F);
end;

theorem :: REALSET2:12
   for F being Field,
       x,y being Element of suppf(F) holds
   odf(F).(x,y) = ndf(F) implies y = compf(F).x;

theorem :: REALSET2:13
   for F being Field,
       x being Element of suppf(F) holds
   x = compf(F).(compf(F).x);

theorem :: REALSET2:14
    for F being Field,
        a,b being Element of suppf(F) holds
    (odf(F).(a,b) is Element of suppf(F) &
    omf(F).(a,b) is Element of suppf(F) &
    compf(F).a is Element of suppf(F));

theorem :: REALSET2:15
   for F being Field,
       a,b,c being Element of suppf(F) holds
   omf(F).(a,odf(F).(b,compf(F).c)) =
   odf(F).(omf(F).(a,b),compf(F).(omf(F).(a,c)));

theorem :: REALSET2:16
   for F being Field,
       a,b,c being Element of suppf(F) holds
   omf(F).(odf(F).(a,compf(F).b),c) =
   odf(F).(omf(F).(a,c),compf(F).(omf(F).(b,c)));

theorem :: REALSET2:17
   for F being Field,
       a being Element of suppf(F) holds omf(F).(a,ndf(F)) = ndf(F);

theorem :: REALSET2:18
   for F being Field,
       a being Element of suppf(F) holds omf(F).(ndf(F),a) = ndf(F);

theorem :: REALSET2:19
  for F being Field,
       a,b being Element of suppf(F) holds
   compf(F).(omf(F).(a,b)) = omf(F).(a,compf(F).b);

theorem :: REALSET2:20
   for F being Field holds omf(F).(nmf(F),ndf(F)) = ndf(F);

theorem :: REALSET2:21
   for F being Field holds omf(F).(ndf(F),nmf(F)) = ndf(F);

theorem :: REALSET2:22
  for F being Field,
       a,b being Element of suppf(F) holds
   omf(F).(a,b) is Element of suppf(F);

theorem :: REALSET2:23
   for F being Field,
       a,b,c being Element of suppf(F) holds
   omf(F).(omf(F).(a,b),c) = omf(F).(a,omf(F).(b,c));

theorem :: REALSET2:24
  for F being Field,
       a,b being Element of suppf(F) holds
   omf(F).(a,b) = omf(F).(b,a);

theorem :: REALSET2:25
   for F being Field,
       a being Element of suppf(F) holds
   omf(F).(a,nmf(F)) = a & omf(F).(nmf(F),a) = a;

definition
  let F be Field;
  func revf(F) -> Function of suppf(F)\{ndf(F)},suppf(F)\{ndf(F)} means
:: REALSET2:def 18
 for x being Element of suppf(F)\{ndf(F)} holds
        omf(F).(x,it.x) = nmf(F);
end;

theorem :: REALSET2:26
  for F being Field,
      x,y being Element of suppf(F)\{ndf(F)} holds
      omf(F).(x,y) = nmf(F) implies y = revf(F).x;

theorem :: REALSET2:27
  for F being Field,
      x being Element of suppf(F)\{ndf(F)} holds
      x =revf(F).(revf(F).x);

theorem :: REALSET2:28
  for F being Field,
      a,b being Element of suppf(F)\{ndf(F)} holds
   omf(F).(a,b) is Element of suppf(F)\{ndf(F)} &
   revf(F).a is Element of suppf(F)\{ndf(F)};

theorem :: REALSET2:29
  for F being Field,
      a,b,c being Element of suppf(F) holds
   odf(F).(a,b) = odf(F).(a,c) implies b = c;

theorem :: REALSET2:30
  for F being Field,
      a being Element of suppf(F)\{ndf(F)},
      b,c being Element of suppf(F) holds
   omf(F).(a,b) = omf(F).(a,c) implies b = c;
