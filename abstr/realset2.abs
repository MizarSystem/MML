:: Properties of Fields
::  by J\'ozef Bia{\l}as
::
:: Received June 20, 1990
:: Copyright (c) 1990 Association of Mizar Users

environ

 vocabularies BOOLE, REALSET1, FUNCT_1, RELAT_1, BINOP_1, RLVECT_1, QC_LANG1,
      VECTSP_1, REALSET2;
 notations TARSKI, XBOOLE_0, ENUMSET1, ZFMISC_1, SUBSET_1, RELAT_1, FUNCT_1,
      FUNCT_2, BINOP_1, STRUCT_0, RLVECT_1, GROUP_1, VECTSP_1, REALSET1;
 constructors ENUMSET1, REALSET1, BINOP_1, VECTSP_1;
 registrations REALSET1, RELSET_1, SUBSET_1, XBOOLE_0, RLVECT_1, GROUP_1;
 requirements SUBSET, BOOLE;


begin

definition
  let IT be LoopStr;
  attr IT is zeroed means
:: REALSET2:def 1
                 for a being Element of IT holds
                      (the add of IT).[a,the Zero of IT] = a &
                      (the add of IT).[the Zero of IT,a] = a;
  attr IT is complementable means
:: REALSET2:def 2
                 for a being Element of IT
                  ex b being Element of IT st
                      (the add of IT).[a,b] = the Zero of IT &
                      (the add of IT).[b,a] = the Zero of IT;
end;

definition let L be non empty LoopStr;
 redefine attr L is add-associative means
:: REALSET2:def 3
        for a,b,c being Element of L holds
                      (the add of L).[(the add of L).[a,b],c] =
                       (the add of L).[a,(the add of L).[b,c]];
  redefine attr L is Abelian means
:: REALSET2:def 4
     for a,b being Element of L holds
        (the add of L).[a,b] = (the add of L).[b,a];
end;

registration
 cluster strict Abelian add-associative zeroed
                        complementable (non empty LoopStr);
end;

definition
   mode Group is Abelian add-associative zeroed complementable
    (non empty LoopStr);
end;

definition
  let IT be 1-sorted;
  attr IT is trivial means
:: REALSET2:def 5
     the carrier of IT is trivial;
end;

registration
 cluster trivial 1-sorted;
end;

registration
 cluster non trivial strict doubleLoopStr;
end;

definition
   let A be non trivial set;
   let od,om be BinOp of A;
   let nd be Element of A;
   let nm be Element of A\{nd};
   func field(A,od,om,nd,nm) -> non trivial strict doubleLoopStr means
:: REALSET2:def 6
   A = the carrier of it &
        od = the add of it &
        om = the mult of it &
        nd = the Zero of it &
        nm = the unity of it;
end;

definition
 let IT be 1-sorted;
 redefine attr IT is trivial means
:: REALSET2:def 7
     for x,y being Element of IT holds x = y;
end;

definition
  let IT be doubleLoopStr;
  attr IT is Field-like means
:: REALSET2:def 8
   ex A being non trivial set,
            od being BinOp of A, nd being Element of A,
            om being DnT of nd,A, nm being Element of A\{nd} st
           (IT = field(A,od,om,nd,nm) & LoopStr(#A,od,nd#) is Group &
           (for B being non empty set, P being BinOp of B,
                e being Element of B holds
               (B = A\{nd} & e = nm & P = om!(A,nd) implies
           LoopStr(#B,P,e#) is Group)) &
           for x,y,z being Element of A holds
            om.[x,od.[y,z]] = od.[om.[x,y],om.[x,z]] &
            om.[od.[x,y],z] = od.[om.[x,z],om.[y,z]]);
end;

registration
 cluster strict Field-like doubleLoopStr;
end;

definition
  mode Field is Field-like doubleLoopStr;
end;

definition
   let F be Field;
   func suppf(F) -> non trivial set means
:: REALSET2:def 9
    ex od being BinOp of it,
             nd being Element of it,
             om being DnT of nd,it,
             nm being Element of it\{nd} st
           F = field(it,od,om,nd,nm);
end;

definition
   let F be Field;
   func odf(F) -> BinOp of suppf(F) means
:: REALSET2:def 10
     ex nd being Element of suppf(F),
              om being DnT of nd, suppf(F),
              nm being Element of suppf(F)\{nd} st
           F = field(suppf(F),it,om,nd,nm);
end;

definition
   let F be Field;
   func ndf(F) -> Element of suppf(F) means
:: REALSET2:def 11
    ex om being DnT of it,suppf(F),
             nm being Element of suppf(F)\{it} st
           F = field(suppf(F),odf(F),om,it,nm);
end;

definition
   let F be Field;
   func omf(F) -> DnT of ndf(F),suppf(F) means
:: REALSET2:def 12
   ex nm being Element of suppf(F)\{ndf(F)} st
           F = field(suppf(F),odf(F),it,ndf(F),nm);
end;

definition
   let F be Field;
   func nmf(F) -> Element of suppf(F)\{ndf(F)} means
:: REALSET2:def 13
       F = field(suppf(F),odf(F),omf(F),ndf(F),it);
end;

theorem :: REALSET2:1
   for F being Field holds LoopStr(#suppf(F),odf(F),ndf(F)#) is Group;

theorem :: REALSET2:2
   for F being Field, B being non empty set,
       P being BinOp of B, e being Element of B st
   B = suppf(F)\{ndf(F)} & e = nmf(F) & P = omf(F)!(suppf(F),ndf(F)) holds
    LoopStr(#B,P,e#) is Group;

theorem :: REALSET2:3
   for F being Field, x,y,z being Element of suppf(F) holds
   (omf(F).[x,odf(F).[y,z]] = odf(F).[omf(F).[x,y],omf(F).[x,z]] &
    omf(F).[odf(F).[x,y],z] = odf(F).[omf(F).[x,z],omf(F).[y,z]] );

theorem :: REALSET2:4
   for F being Field,
       a,b,c being Element of suppf(F) holds
   odf(F).[odf(F).[a,b],c] = odf(F).[a,odf(F).[b,c]];

theorem :: REALSET2:5
   for F being Field,
       a,b being Element of suppf(F) holds
   odf(F).[a,b] = odf(F).[b,a];

theorem :: REALSET2:6
   for F being Field,
       a being Element of suppf(F) holds
   odf(F).[a,ndf(F)] = a & odf(F).[ndf(F),a] = a;

theorem :: REALSET2:7
   for F being Field,
       a being Element of suppf(F) ex b being Element of suppf(F) st
   odf(F).[a,b] = ndf(F) & odf(F).[b,a] = ndf(F);

theorem :: REALSET2:8
   for F being Field,
       a,b,c being Element of suppf(F)\{ndf(F)} holds
   omf(F).[omf(F).[a,b],c] = omf(F).[a,omf(F).[b,c]];

theorem :: REALSET2:9
   for F being Field,
       a,b being Element of suppf(F)\{ndf(F)} holds
   omf(F).[a,b] = omf(F).[b,a];

theorem :: REALSET2:10
   for F being Field,
       a being Element of suppf(F)\{ndf(F)} holds
   omf(F).[a,nmf(F)] = a & omf(F).[nmf(F),a] = a;

theorem :: REALSET2:11
   for F being Field,
       a being Element of suppf(F)\{ndf(F)}
   ex b being Element of suppf(F)\{ndf(F)} st
   omf(F).[a,b] = nmf(F) & omf(F).[b,a] = nmf(F);

definition
   let F be Field;
   func compf(F) -> Function of suppf(F),suppf(F) means
:: REALSET2:def 14
 for x being Element of suppf(F) holds odf(F).[x,it.x] = ndf(F);
end;

theorem :: REALSET2:12
   for F being Field,
       x,y being Element of suppf(F) holds
   odf(F).[x,y] = ndf(F) implies y = compf(F).x;

theorem :: REALSET2:13
   for F being Field,
       x being Element of suppf(F) holds
   x = compf(F).(compf(F).x);

theorem :: REALSET2:14
    for F being Field,
        a,b being Element of suppf(F) holds
    (odf(F).[a,b] is Element of suppf(F) &
    omf(F).[a,b] is Element of suppf(F) &
    compf(F).a is Element of suppf(F));

theorem :: REALSET2:15
   for F being Field,
       a,b,c being Element of suppf(F) holds
   omf(F).[a,odf(F).[b,compf(F).c]] =
   odf(F).[omf(F).[a,b],compf(F).(omf(F).[a,c])];

theorem :: REALSET2:16
   for F being Field,
       a,b,c being Element of suppf(F) holds
   omf(F).[odf(F).[a,compf(F).b],c] =
   odf(F).[omf(F).[a,c],compf(F).(omf(F).[b,c])];

theorem :: REALSET2:17
   for F being Field,
       a being Element of suppf(F) holds omf(F).[a,ndf(F)] = ndf(F);

theorem :: REALSET2:18
   for F being Field,
       a being Element of suppf(F) holds omf(F).[ndf(F),a] = ndf(F);

theorem :: REALSET2:19
  for F being Field,
       a,b being Element of suppf(F) holds
   compf(F).(omf(F).[a,b]) = omf(F).[a,compf(F).b];

theorem :: REALSET2:20
   for F being Field holds omf(F).[nmf(F),ndf(F)] = ndf(F);

theorem :: REALSET2:21
   for F being Field holds omf(F).[ndf(F),nmf(F)] = ndf(F);

theorem :: REALSET2:22
  for F being Field,
       a,b being Element of suppf(F) holds
   omf(F).[a,b] is Element of suppf(F);

theorem :: REALSET2:23
   for F being Field,
       a,b,c being Element of suppf(F) holds
   omf(F).[omf(F).[a,b],c] = omf(F).[a,omf(F).[b,c]];

theorem :: REALSET2:24
  for F being Field,
       a,b being Element of suppf(F) holds
   omf(F).[a,b] = omf(F).[b,a];

theorem :: REALSET2:25
   for F being Field,
       a being Element of suppf(F) holds
   omf(F).[a,nmf(F)] = a & omf(F).[nmf(F),a] = a;

definition
  let F be Field;
  func revf(F) -> Function of suppf(F)\{ndf(F)},suppf(F)\{ndf(F)} means
:: REALSET2:def 15
 for x being Element of suppf(F)\{ndf(F)} holds
        omf(F).[x,it.x] = nmf(F);
end;

theorem :: REALSET2:26
  for F being Field,
      x,y being Element of suppf(F)\{ndf(F)} holds
      omf(F).[x,y] = nmf(F) implies y = revf(F).x;

theorem :: REALSET2:27
  for F being Field,
      x being Element of suppf(F)\{ndf(F)} holds
      x =revf(F).(revf(F).x);

theorem :: REALSET2:28
  for F being Field,
      a,b being Element of suppf(F)\{ndf(F)} holds
   omf(F).[a,b] is Element of suppf(F)\{ndf(F)} &
   revf(F).a is Element of suppf(F)\{ndf(F)};

theorem :: REALSET2:29
  for F being Field,
      a,b,c being Element of suppf(F) holds
   odf(F).[a,b] = odf(F).[a,c] implies b = c;

theorem :: REALSET2:30
  for F being Field,
      a being Element of suppf(F)\{ndf(F)},
      b,c being Element of suppf(F) holds
   omf(F).[a,b] = omf(F).[a,c] implies b = c;
