:: Many-Argument Relations
::  by Edmund Woronowicz
::
:: Received June 1, 1990
:: Copyright (c) 1990 Association of Mizar Users

environ

 vocabularies SUBSET_1, NUMBERS, XBOOLE_0, FUNCOP_1, FUNCT_2, RELAT_1, TARSKI,
      FINSEQ_1, CARD_3, FUNCT_1, ZFMISC_1, ORDINAL4, CARD_1, XBOOLEAN,
      MARGREL1;
 notations TARSKI, XBOOLE_0, ZFMISC_1, SUBSET_1, NUMBERS, FUNCT_1, FINSEQ_1,
      RELAT_1, FUNCT_2, FUNCOP_1, XBOOLEAN, CARD_3;
 constructors FUNCOP_1, XCMPLX_0, FINSEQ_1, XBOOLEAN, RELSET_1, CARD_3;
 registrations XBOOLE_0, SUBSET_1, RELAT_1, FUNCT_1, XBOOLEAN, FINSEQ_1;
 requirements SUBSET, BOOLE, ARITHM;


begin

reserve x,z for set;
reserve k for Element of NAT;
reserve D for non empty set;

definition
  let B,A be non empty set, b be Element of B;
  redefine func A --> b -> Element of Funcs(A,B);
end;

definition
  let IT be FinSequence-membered set;
  redefine attr IT is with_common_domain means
:: MARGREL1:def 1

   for a,b being FinSequence st a in IT & b in IT holds len a = len b;
end;

registration
  cluster FinSequence-membered with_common_domain set;
end;

definition
  mode relation is FinSequence-membered with_common_domain set;
end;

reserve X for set;
reserve p,r for relation;
reserve a,a1,a2,b for FinSequence;

canceled 6;

theorem :: MARGREL1:7
  X c= p implies X is relation;

theorem :: MARGREL1:8
  {a} is relation;

scheme :: MARGREL1:sch 1

  relexist{A() -> set, P[FinSequence]}: ex r st for a holds a in r iff a in A(
  ) & P[a]
provided
 for a,b st P[a] & P[b] holds len a = len b;

definition
  let p,r;
  redefine pred p = r means
:: MARGREL1:def 2
  for a holds a in p iff a in r;
end;

registration
  cluster empty -> with_common_domain set;
end;

theorem :: MARGREL1:9
  for p st for a holds not a in p holds p = {};

definition
  let p;
  assume
 p <> {};
  canceled;
  func the_arity_of p -> Element of NAT means
:: MARGREL1:def 4
  for a st a in p holds it = len a;
end;

definition
  let k;
  mode relation_length of k -> relation means
:: MARGREL1:def 5
    for a st a in it holds len a = k;
end;

definition
  let X be set;
  mode relation of X -> relation means
:: MARGREL1:def 6
    for a st a in it holds rng a c= X;
end;

canceled 10;

theorem :: MARGREL1:20
  {} is relation of X;

theorem :: MARGREL1:21
  {} is relation_length of k;

definition
  let X, k;
  mode relation of X,k -> relation means
:: MARGREL1:def 7
    it is relation of X & it is
    relation_length of k;
end;

definition
  let D;
  func relations_on D -> set means
:: MARGREL1:def 8

  for X holds X in it iff X c= D* &
  for a,b being FinSequence of D st a in X & b in X holds len a = len b;
end;

registration
  let D;
  cluster relations_on D -> non empty;
end;

definition
  let D be non empty set;
  mode relation of D is Element of relations_on D;
end;

reserve a,b for FinSequence of D;
reserve p,r for Element of relations_on D;

canceled 4;

theorem :: MARGREL1:26
  X c= r implies X is Element of relations_on D;

theorem :: MARGREL1:27
  {a} is Element of relations_on D;

theorem :: MARGREL1:28
  for x,y being Element of D holds {<*x,y*>} is Element of relations_on
  D;

definition
  let D,p,r;
  redefine pred p = r means
:: MARGREL1:def 9

  for a holds a in p iff a in r;
end;

scheme :: MARGREL1:sch 2

  relDexist{D() -> non empty set, P[FinSequence of D()]}: ex r being Element
  of relations_on D() st for a being FinSequence of D() holds a in r iff P[a]
provided
 for a,b being FinSequence of D() st P[a] & P[b] holds len a = len b;

definition
  let D;
  func empty_rel(D) -> Element of relations_on D means
:: MARGREL1:def 10

  not a in it;
end;

canceled 3;

theorem :: MARGREL1:32
  empty_rel(D) = {};

definition
  let D,p;
  assume
 p <> empty_rel(D);
  func the_arity_of p -> Element of NAT means
:: MARGREL1:def 11
  a in p implies it = len a;
end;

scheme :: MARGREL1:sch 3

  relDexist2{D() -> non empty set, k() -> Element of NAT, P[FinSequence of D()
]}: ex r being Element of relations_on D() st for a being FinSequence of D() st
  len a = k() holds a in r iff P[a];

definition
  func BOOLEAN -> set equals
:: MARGREL1:def 12
  {0,1};
end;

registration
  cluster BOOLEAN -> non empty;
end;

definition
  redefine func FALSE -> Element of BOOLEAN;
  func TRUE -> Element of BOOLEAN;
end;

definition
  let x be set;
  redefine attr x is boolean means
:: MARGREL1:def 13

  x in BOOLEAN;
end;

registration
  cluster -> boolean Element of BOOLEAN;
end;

reserve u,v,w for boolean set;

definition
  redefine
  let v be boolean set;
  func 'not' v equals
:: MARGREL1:def 14
  TRUE if v = FALSE otherwise FALSE;
  let w be boolean set;
  func v '&' w equals
:: MARGREL1:def 15
  TRUE if v = TRUE & w =TRUE otherwise FALSE;
end;

definition
  let v be Element of BOOLEAN;
  redefine func 'not' v -> Element of BOOLEAN;
  let w be Element of BOOLEAN;
  func v '&' w -> Element of BOOLEAN;
end;

canceled 7;

theorem :: MARGREL1:40
  'not' 'not' v = v;

theorem :: MARGREL1:41
  (v = FALSE iff 'not' v = TRUE) & (v = TRUE iff 'not' v = FALSE);

canceled 3;

theorem :: MARGREL1:45
  (v '&' w = TRUE iff v = TRUE & w = TRUE) & (v '&' w = FALSE iff v =
  FALSE or w = FALSE);

canceled 3;

theorem :: MARGREL1:49
  FALSE '&' v = FALSE;

theorem :: MARGREL1:50
  TRUE '&' v = v;

theorem :: MARGREL1:51
  v '&' v = FALSE implies v = FALSE;

theorem :: MARGREL1:52
  v '&' (w '&' u) = (v '&' w) '&' u;

definition
  let X;
  func ALL(X) equals
:: MARGREL1:def 16

  TRUE if not FALSE in X otherwise FALSE;
end;

registration
  let X;
  cluster ALL X -> boolean;
end;

definition
  let X;
  redefine func ALL X -> Element of BOOLEAN;
end;

theorem :: MARGREL1:53
  (not FALSE in X iff ALL(X) = TRUE) & (FALSE in X iff ALL(X) = FALSE);

begin :: Addenda

:: from VALUAT_1, 2007.03.15, A.T.

definition
  let f be Function;
  attr f is boolean-valued means
:: MARGREL1:def 17

  rng f c= BOOLEAN;
end;

registration
  cluster boolean-valued Function;
end;

registration
  let f be boolean-valued Function, x be set;
  cluster f.x -> boolean;
end;

definition
  let p be boolean-valued Function;
  func 'not' p -> boolean-valued Function means
:: MARGREL1:def 18

  dom it = dom p & for x
  being set st x in dom p holds it.x = 'not'(p.x);
  involutiveness;
  let q be boolean-valued Function;
  func p '&' q -> boolean-valued Function means
:: MARGREL1:def 19

  dom it = dom p /\ dom
  q & for x being set st x in dom it holds it.x = (p.x) '&' (q.x);
  commutativity;
  idempotence;
end;

registration
  let A be set;
  cluster -> boolean-valued Element of Funcs(A,BOOLEAN);
end;

definition
  let A be non empty set;
  redefine
  let p be Element of Funcs(A,BOOLEAN);
  func 'not' p -> Element of Funcs(A,BOOLEAN) means
:: MARGREL1:def 20
  for x being Element of A
  holds it.x = 'not'(p.x);
  let q be Element of Funcs(A,BOOLEAN);
  func p '&' q -> Element of Funcs(A,BOOLEAN) means
:: MARGREL1:def 21
  for x being Element of A
  holds it.x = (p.x) '&' (q.x);
end;

