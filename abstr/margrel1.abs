:: Many-Argument Relations
::  by Edmund Woronowicz
::
:: Received June 1, 1990
:: Copyright (c) 1990 Association of Mizar Users

environ

 vocabulary FUNCOP_1, FUNCT_2, RELAT_1, FINSEQ_1, BOOLE, QC_LANG1, ZF_LANG,
      MARGREL1;
 notation TARSKI, XBOOLE_0, ZFMISC_1, SUBSET_1, NAT_1, FINSEQ_1, RELAT_1,
      FUNCOP_1, FRAENKEL;
 constructors FINSEQ_1, FUNCOP_1, FRAENKEL, MEMBERED, XBOOLE_0;
 clusters RELSET_1, FUNCOP_1, SUBSET_1, MEMBERED, ZFMISC_1, XBOOLE_0;
 requirements SUBSET, BOOLE;


begin
 reserve x,z for set;
 reserve k for Nat;
 reserve D for non empty set;

definition let B,A be non empty set, b be Element of B;
 redefine func A --> b -> Element of Funcs(A,B);
end;


definition let IT be set;
  attr IT is relation-like means
:: MARGREL1:def 1
   (for x being set st x in IT holds x is FinSequence) &
          for a,b being FinSequence st a in IT & b in IT holds len a = len b;
end;


registration
  cluster relation-like set;
 existence proof take {};
  thus (for x being set st x in {} holds x is FinSequence) &
          for a,b being FinSequence st a in {} & b in {} holds len a = len b;
 end;
end;


definition
  mode relation is relation-like set;
end;


 reserve X for set;
 reserve p,r for relation;
 reserve a,a1,a2,b for FinSequence;

canceled 6;

theorem :: MARGREL1:7
    X c= p implies X is relation-like;

theorem :: MARGREL1:8
    {a} is relation-like;

 scheme :: MARGREL1:sch 1
 rel_exist{A() -> set, P[FinSequence]}:
    ex r st for a holds a in r iff a in A() & P[a]
  provided
  for a,b st P[a] & P[b] holds len a = len b
proof
    defpred _P[set] means ex a st P[a] & $1 = a;
    consider X such that
  A2: x in X iff x in A() & _P[x] from XBOOLE_0:sch 1;
   A3: for x being set st x in X holds x is FinSequence
        proof let x be set;
            assume x in X;
             then ex a st P[a] & x = a by A2;
            hence x is FinSequence;
        end;
          for a,b st a in X & b in X holds len a = len b
        proof let a,b;
          assume that A4: a in X and A5: b in X;
 A6:               ex c being FinSequence st P[c] & a = c by A2,A4;
                  ex d being FinSequence st P[d] & b = d by A2,A5;
          hence thesis by A1,A6;
        end;
     then reconsider r = X as relation by A3,Def1;
       for a holds a in r iff a in A() & P[a]
     proof let a;
           now assume A7: a in r;
                then ex c being FinSequence st P[c] & a = c by A2;
                hence a in A() & P[a] by A2,A7;
            end;
          hence thesis by A2;
     end;
     hence thesis;
  end;

definition
 let p,r;
 redefine pred p = r means
:: MARGREL1:def 2
for a holds a in p iff a in r;
end;


registration
 cluster {} -> relation-like;
 coherence
  proof
   thus (for x being set st x in {} holds x is FinSequence) &
          for a,b being FinSequence st a in {} & b in {} holds len a = len b;
  end;
end;


theorem :: MARGREL1:9
 for p st for a holds not a in p holds p = {};

 definition let p;
  assume  p <> {};
 canceled;

   func the_arity_of p -> Nat means
:: MARGREL1:def 4
       for a st a in p holds it = len a;
 end;


definition let k;
  mode relation_length of k -> relation means
:: MARGREL1:def 5
     for a st a in it holds len a = k;
end;


definition
  let X be set;
  mode relation of X -> relation means
:: MARGREL1:def 6
     for a st a in it holds rng a c= X;
end;


canceled 10;

theorem :: MARGREL1:20
  {} is relation of X;

theorem :: MARGREL1:21
  {} is relation_length of k;

definition let X, k;
  mode relation of X,k -> relation means
:: MARGREL1:def 7
      it is relation of X & it is relation_length of k;
end;


definition let D;
   func relations_on D -> set means
:: MARGREL1:def 8
  for X holds X in it iff X c= D* &
    for a,b being FinSequence of D st a in X & b in X holds len a = len b;
end;


registration let D;
   cluster relations_on D -> non empty;
 coherence
  proof
  defpred P[set] means  ex Y being set st Y = $1 & Y c= D* &
           for a,b being FinSequence of D st a in Y & b in Y holds
            len a = len b;
  consider XX being set such that
A1:  for x holds x in XX iff x in bool(D*) & P[x] from XBOOLE_0:sch 1;
A2:      {} c= D* by XBOOLE_1:2;
      for a,b being FinSequence of D st a in {} & b in {} holds len a = len b;
     then reconsider A = XX as non empty set by A1,A2;
         for X being set holds X in A iff X c= D* &
        for a,b being FinSequence of D st a in X & b in X holds len a = len b
          proof let X be set;
            thus X in A implies X c= D* & for a,b being FinSequence of D st
              a in X & b in X holds len a = len b
            proof
              assume X in A;
              then ex Y being set st
              Y = X & Y c= D* & for a,b being FinSequence of D st
                  a in Y & b in Y holds len a=len b by A1;
              hence thesis;
            end;
            thus X c= D* & (for a,b being FinSequence of D st
               a in X & b in X holds len a = len b) implies X in A by A1;
          end;
          hence thesis by Def8;
   end;
end;


definition
  let D be non empty set;
  mode relation of D is Element of relations_on D;
end;


reserve a,b for FinSequence of D;
reserve p,r for Element of relations_on D;

canceled 4;

theorem :: MARGREL1:26
    X c= r implies X is Element of relations_on D;

theorem :: MARGREL1:27
    {a} is Element of relations_on D;

theorem :: MARGREL1:28
    for x,y being Element of D holds {<*x,y*>} is Element of relations_on D;

definition
 let D,p,r;
 redefine pred p = r means
:: MARGREL1:def 9
for a holds a in p iff a in r;
end;


scheme :: MARGREL1:sch 2
 rel_D_exist{D() -> non empty set, P[FinSequence of D()]}:
  ex r being Element of relations_on D() st
   for a being FinSequence of D() holds a in r iff P[a]
  provided
     for a,b being FinSequence of D() st P[a] & P[b] holds len a = len b
proof
    defpred _P[set] means ex a being FinSequence of D() st P[a] & $1 =  a;
    consider X being set such that
  A2: x in X iff x in D()* & _P[x] from XBOOLE_0:sch 1;
   A3:  X c= D()*
        proof
            for x holds x in X implies x in D()* by A2;
          hence thesis by TARSKI:def 3;
        end;
          for a,b being FinSequence of D() st a in X & b in X holds
                                                           len a = len b
        proof let a,b be FinSequence of D();
          assume that A4: a in X and A5: b in X;
 A6:               ex c being FinSequence of D() st P[c] & a = c by A2,A4;
                  ex d being FinSequence of D() st P[d] & b = d by A2,A5;
          hence thesis by A1,A6;
        end;
     then reconsider r = X as Element of relations_on D() by A3,Def8;
       for a being FinSequence of D() holds a in r iff P[a]
     proof let a be FinSequence of D();
        A7: now assume a in r;
                   then ex c being FinSequence of D() st P[c] & a = c by A2;
                hence P[a];
            end;
              now assume A8: P[a];
                  a in D()* by FINSEQ_1:def 11;
               hence a in r by A2,A8;
            end;
          hence thesis by A7;
     end;
     hence thesis;
  end;

definition let D;
  func empty_rel(D) -> Element of relations_on D means
:: MARGREL1:def 10
   not a in it;
 end;


canceled 3;

theorem :: MARGREL1:32
    empty_rel(D) = {};

definition
  let D,p;
  assume  p <> empty_rel(D);
   func the_arity_of p -> Nat means
:: MARGREL1:def 11
       a in p implies it = len a;
 end;


scheme :: MARGREL1:sch 3
 rel_D_exist2{D() -> non empty set, k() -> Nat, P[FinSequence of D()]}:
  ex r being Element of relations_on D() st
    for a being FinSequence of D() st len a = k() holds a in r iff P[a]
proof
    defpred _P[set] means
     ex a being FinSequence of D() st len a = k() & P[a] & $1 = a;
    consider X being set such that
  A1: x in X iff x in D()* & _P[x] from XBOOLE_0:sch 1;
   A2:  X c= D()*
        proof
            for x holds x in X implies x in D()* by A1;
          hence thesis by TARSKI:def 3;
        end;
          for a,b being FinSequence of D() st a in X & b in X holds
                                                           len a = len b
        proof let a,b be FinSequence of D();
          assume that A3: a in X and A4: b in X;
 A5:                ex c being FinSequence of D() st
 len c = k() & P[c] & a = c by A1,A3;
                   ex d being FinSequence of D() st
 len d = k() & P[d] & b = d by A1,A4;
          hence len a = len b by A5;
        end;
     then reconsider r = X as Element of relations_on D() by A2,Def8;
       for a being FinSequence of D() st len a = k() holds a in r iff P[a]
     proof let a be FinSequence of D() such that
        A6: len a = k();
        A7: now assume a in r;
                 then ex c being FinSequence of D() st
 len c = k() & P[c] & a = c by A1;
                hence P[a];
            end;
              now assume A8: P[a];
                  a in D()* by FINSEQ_1:def 11;
               hence a in r by A1,A6,A8;
            end;
          hence thesis by A7;
     end;
    hence thesis;
  end;

 definition
  func BOOLEAN -> set equals
:: MARGREL1:def 12
{0,1};
 end;


 registration
  cluster BOOLEAN -> non empty;
 coherence by Def12;
 end;


 definition
  func FALSE -> Element of BOOLEAN equals
:: MARGREL1:def 13
0;
  func TRUE -> Element of BOOLEAN equals
:: MARGREL1:def 14
1;
 end;


canceled 3;

theorem :: MARGREL1:36
    FALSE = 0 & TRUE = 1;

theorem :: MARGREL1:37
    BOOLEAN = {FALSE,TRUE};

theorem :: MARGREL1:38
    FALSE <> TRUE;

definition
 let x be set;
 attr x is boolean means
:: MARGREL1:def 15
 x in BOOLEAN;
end;


registration
 cluster boolean set;
 existence
  proof
   take FALSE;
   thus thesis by Def15;
  end;
 cluster -> boolean Element of BOOLEAN;
 coherence by Def15;
end;


reserve u,v,w for boolean set;

theorem :: MARGREL1:39
 v = FALSE or v = TRUE;

  definition
    let v be boolean set;
  func 'not' v equals
:: MARGREL1:def 16
     TRUE if v = FALSE,
               FALSE if v = TRUE;

    let w be boolean set;
  func v '&' w equals
:: MARGREL1:def 17
    TRUE if v = TRUE & w =TRUE
      otherwise FALSE;
  commutativity;
 end;


  registration let v be boolean set;
  cluster 'not' v -> boolean;
  coherence
   proof v in BOOLEAN by Def15;
    then v = FALSE or v = TRUE by Def12,Def13,Def14,TARSKI:def 2;
    hence thesis by Def16;
   end;
  let w be boolean set;
  cluster v '&' w -> boolean;
  correctness
   proof
      v = TRUE & w = TRUE or not(v = TRUE & w = TRUE);
    hence thesis by Def17;
   end;
 end;


definition let v be Element of BOOLEAN;
  redefine func 'not' v -> Element of BOOLEAN;
  let w be Element of BOOLEAN;
  func v '&' w -> Element of BOOLEAN;
end;


theorem :: MARGREL1:40
  'not' 'not' v = v;

theorem :: MARGREL1:41
  (v = FALSE iff 'not' v = TRUE) &
      (v = TRUE iff 'not' v = FALSE);

canceled;

theorem :: MARGREL1:43
    v <> TRUE iff v = FALSE;

canceled;

theorem :: MARGREL1:45
   (v '&' w = TRUE iff v = TRUE & w = TRUE) &
        (v '&' w = FALSE iff v = FALSE or w = FALSE);

theorem :: MARGREL1:46
   v '&' 'not' v = FALSE;

theorem :: MARGREL1:47
    'not'(v '&''not' v) = TRUE;

canceled;

theorem :: MARGREL1:49
    FALSE '&' v = FALSE;

theorem :: MARGREL1:50
    TRUE '&' v = v;

theorem :: MARGREL1:51
    v '&' v = FALSE implies v = FALSE;

theorem :: MARGREL1:52
    v '&' (w '&' u) = (v '&' w) '&' u;

 definition let X;
    func ALL(X) equals
:: MARGREL1:def 18
     TRUE if not FALSE in X
      otherwise FALSE;
 end;


 registration
  let X;
  cluster ALL X -> boolean;
   correctness
    proof FALSE in X or not FALSE in X;
     hence thesis by Def18;
    end;
 end;


definition let X;
  redefine func ALL X -> Element of BOOLEAN;
end;


theorem :: MARGREL1:53
    (not FALSE in X iff ALL(X) = TRUE) &
      (FALSE in X iff ALL(X) = FALSE);
