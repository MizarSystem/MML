:: The Field of Complex Numbers
::  by Anna Justyna Milewska
::
:: Received January 18, 2000
:: Copyright (c) 2000 Association of Mizar Users

environ

 vocabularies COMPLEX1, VECTSP_1, RLVECT_1, COMPLSP1, BINOP_1, LATTICES,
      FUNCT_1, ARYTM_1, RELAT_1, ARYTM_3, ABSVALUE, COMPLFLD, XCMPLX_0,
      GROUP_1, ARYTM, COMPTRIG, VECTSP_2;
 notations TARSKI, XBOOLE_0, SUBSET_1, ORDINAL1, NUMBERS, ARYTM_0, XCMPLX_0,
      COMPLEX1, NAT_1, FUNCT_1, XXREAL_0, COMPTRIG, BINOP_1, BINOP_2, STRUCT_0,
      RLVECT_1, GROUP_1, NEWTON, VECTSP_1;
 constructors BINOP_1, FUNCT_4, ARYTM_0, XXREAL_0, REAL_1, NAT_1, BINOP_2,
      MEMBERED, NEWTON, COMPTRIG, VECTSP_1;
 registrations ORDINAL1, RELSET_1, NUMBERS, XCMPLX_0, NAT_1, MEMBERED,
      COMPLEX1, STRUCT_0, VECTSP_1, XXREAL_0, XREAL_0, XBOOLE_0;
 requirements NUMERALS, SUBSET, BOOLE, ARITHM;


begin

canceled 2;

  definition
   func F_Complex -> strict doubleLoopStr means
:: COMPLFLD:def 1
    the carrier of it = COMPLEX &
    the add of it = addcomplex &
    the mult of it = multcomplex &
    1.it = 1r &
    0.it = 0c;
  end;

  registration
   cluster F_Complex -> non empty;
  end;

registration
  cluster -> complex Element of F_Complex;
end;

registration let a,b be complex number;
 let x,y be Element of F_Complex;
 identify x+y with a+b when x=a, y=b;
 identify x*y with a*b when x=a, y=b;
end;

  registration
   cluster F_Complex -> well-unital;
 end;

  registration
   cluster F_Complex -> add-associative right_zeroed right_complementable
         Abelian commutative associative left_unital
         right_unital distributive Field-like non degenerated;
  end;

  theorem :: COMPLFLD:3
    for x1,y1 be Element of F_Complex
   for x2,y2 be complex number st x1 = x2 & y1 = y2 holds
    x1 + y1 = x2 + y2;

  theorem :: COMPLFLD:4
   for x1 be Element of F_Complex
   for x2 be complex number st x1 = x2 holds
    - x1 = - x2;

  theorem :: COMPLFLD:5
   for x1,y1 be Element of F_Complex
   for x2,y2 be complex number st x1 = x2 & y1 = y2 holds
    x1 - y1 = x2 - y2;

  theorem :: COMPLFLD:6
    for x1,y1 be Element of F_Complex
   for x2,y2 be complex number st x1 = x2 & y1 = y2 holds
    x1 * y1 = x2 * y2;

  theorem :: COMPLFLD:7
   for x1 be Element of F_Complex
   for x2 be complex number st x1 = x2 & x1 <> 0.F_Complex holds
    x1" = x2";

  theorem :: COMPLFLD:8
   for x1,y1 be Element of F_Complex
   for x2,y2 be complex number st
    x1 = x2 & y1 = y2 & y1 <> 0.F_Complex holds x1/y1 = x2/y2;

  theorem :: COMPLFLD:9
   0.F_Complex = 0c;

  theorem :: COMPLFLD:10
   1_F_Complex = 1r;

  theorem :: COMPLFLD:11
        1_F_Complex + 1_F_Complex <> 0.F_Complex;

  definition
   let z be Element of F_Complex;
   redefine func z *' -> Element of F_Complex;
   redefine func |.z.| -> Element of REAL;
  end;

reserve z,z1,z2,z3,z4 for Element of F_Complex;

canceled 17;

  theorem :: COMPLFLD:29
        -z = (-1_F_Complex) * z;

canceled 5;

  theorem :: COMPLFLD:35
        z1 - -z2 = z1 + z2;

canceled 5;

  theorem :: COMPLFLD:41
        z1 = z1 + z - z;

  theorem :: COMPLFLD:42
        z1 = z1 - z + z;

canceled 4;

  theorem :: COMPLFLD:47
        z1 <> 0.F_Complex & z2 <> 0.F_Complex &
   z1" = z2" implies z1 = z2;

  theorem :: COMPLFLD:48
        z2 <> 0.F_Complex &
    (z1 * z2 = 1.F_Complex or z2 * z1 = 1.F_Complex)
    implies z1 = z2";

  theorem :: COMPLFLD:49
        z2 <> 0.F_Complex & (z1 * z2 = z3 or z2 * z1 = z3) implies
    z1 = z3 * z2" & z1 = z2" * z3;

  theorem :: COMPLFLD:50
        (1.F_Complex)" = 1.F_Complex;

  theorem :: COMPLFLD:51
        z1 <> 0.F_Complex & z2 <> 0.F_Complex implies
    (z1 * z2)" = z1" * z2";

canceled;

  theorem :: COMPLFLD:53
        z <> 0.F_Complex implies (-z)" = -(z");

canceled;

  theorem :: COMPLFLD:55
        z1 <> 0.F_Complex & z2 <> 0.F_Complex implies
    z1" + z2" = (z1 + z2) * (z1 * z2)";

  theorem :: COMPLFLD:56
        z1 <> 0.F_Complex & z2 <> 0.F_Complex implies
    z1" - z2" = (z2 - z1) * (z1 * z2)";

canceled;

  theorem :: COMPLFLD:58
        z <> 0.F_Complex implies z" = (1.F_Complex) / z;

  theorem :: COMPLFLD:59
        z / (1.F_Complex) = z;

  theorem :: COMPLFLD:60
        z <> 0.F_Complex implies z / z = 1.F_Complex;

  theorem :: COMPLFLD:61
        z <> 0.F_Complex implies (0.F_Complex) / z = 0.F_Complex;

  theorem :: COMPLFLD:62
   z2 <> 0.F_Complex & z1 / z2 = 0.F_Complex implies
    z1 = 0.F_Complex;

  theorem :: COMPLFLD:63
        z2 <> 0.F_Complex & z4 <> 0.F_Complex implies
    (z1 / z2) * (z3 / z4) = (z1 * z3) / (z2 * z4);

  theorem :: COMPLFLD:64
        z2 <> 0.F_Complex implies z * (z1 / z2) = (z * z1) / z2;

  theorem :: COMPLFLD:65
        z2 <> 0.F_Complex & z1 / z2 = 1.F_Complex implies
    z1 = z2;

  theorem :: COMPLFLD:66
        z <> 0.F_Complex implies z1 = (z1 * z) / z;

  theorem :: COMPLFLD:67
        z1 <> 0.F_Complex & z2 <> 0.F_Complex implies
    (z1 / z2)" = z2 / z1;

  theorem :: COMPLFLD:68
        z1 <> 0.F_Complex & z2 <> 0.F_Complex implies
    (z1" / z2") = z2 / z1;

  theorem :: COMPLFLD:69
        z2 <> 0.F_Complex implies z1 / z2" = z1 * z2;

  theorem :: COMPLFLD:70
        z1 <> 0.F_Complex & z2 <> 0.F_Complex implies
    z1" / z2 = (z1 * z2)";

  theorem :: COMPLFLD:71
        z1 <> 0.F_Complex & z2 <> 0.F_Complex implies
    z1"* (z / z2) = z / (z1 * z2);

  theorem :: COMPLFLD:72
        z <> 0.F_Complex & z2 <> 0.F_Complex implies
    (z1 / z2) = (z1 * z) / (z2 * z) & (z1 / z2) = (z * z1) / (z * z2);

  theorem :: COMPLFLD:73
        z2 <> 0.F_Complex & z3 <> 0.F_Complex implies
    z1 / (z2 * z3) = z1 / z2 / z3;

  theorem :: COMPLFLD:74
        z2 <> 0.F_Complex & z3 <> 0.F_Complex implies
    (z1 * z3) / z2 = z1 / (z2 / z3);

  theorem :: COMPLFLD:75
        z2 <> 0.F_Complex & z3 <> 0.F_Complex &
    z4 <> 0.F_Complex implies
    (z1 / z2) / (z3 / z4) = (z1 * z4) / (z2 * z3);

  theorem :: COMPLFLD:76
        z2 <> 0.F_Complex & z4 <> 0.F_Complex implies
    z1 / z2 + z3 / z4 = (z1 * z4 + z3 * z2) / (z2 * z4);

  theorem :: COMPLFLD:77
        z <> 0.F_Complex implies z1 / z + z2 / z = (z1 + z2) / z;

  theorem :: COMPLFLD:78
        z2 <> 0.F_Complex implies -(z1 / z2) = (-z1) / z2 &
    -(z1 / z2) = z1 / (-z2);

  theorem :: COMPLFLD:79
        z2 <> 0.F_Complex implies z1 / z2 = (-z1) / (-z2);

  theorem :: COMPLFLD:80
        z2 <> 0.F_Complex & z4 <> 0.F_Complex implies
    z1 / z2 - z3 / z4 = (z1 * z4 - z3 * z2) / (z2 * z4);

  theorem :: COMPLFLD:81
        z <> 0.F_Complex implies z1 / z - z2 / z = (z1 - z2) / z;

  theorem :: COMPLFLD:82
        z2 <> 0.F_Complex & (z1 * z2 = z3 or z2 * z1 = z3) implies
    z1 = z3 / z2;

  theorem :: COMPLFLD:83
        (0.F_Complex)*' = 0.F_Complex;

  theorem :: COMPLFLD:84
   z*' = 0.F_Complex implies z = 0.F_Complex;

  theorem :: COMPLFLD:85
        (1.F_Complex)*' = 1.F_Complex;

  theorem :: COMPLFLD:86
        z*'*' = z;

  theorem :: COMPLFLD:87
        (z1 + z2)*' = z1*' + z2*';

  theorem :: COMPLFLD:88
        (-z)*' = -(z*');

  theorem :: COMPLFLD:89
        (z1 - z2)*' = z1*' - z2*';

  theorem :: COMPLFLD:90
        (z1 * z2)*' = z1*' * z2*';

  theorem :: COMPLFLD:91
        z <> 0.F_Complex implies z"*' = z*'";

  theorem :: COMPLFLD:92
        z2 <> 0.F_Complex implies (z1 / z2)*' = (z1*') / (z2*');

  theorem :: COMPLFLD:93
        |.0.F_Complex.| = 0;

  theorem :: COMPLFLD:94
        |.z.| = 0 implies z = 0.F_Complex;

canceled;

  theorem :: COMPLFLD:96
        z <> 0.F_Complex iff 0 < |.z.|;

  theorem :: COMPLFLD:97
        |.1.F_Complex.| = 1;

  theorem :: COMPLFLD:98
        |.-z.| = |.z.|;

canceled;

  theorem :: COMPLFLD:100
        |.z1 + z2.| <= |.z1.| + |.z2.|;

  theorem :: COMPLFLD:101
        |.z1 - z2.| <= |.z1.| + |.z2.|;

  theorem :: COMPLFLD:102
        |.z1.| - |.z2.| <= |.z1 + z2.|;

  theorem :: COMPLFLD:103
        |.z1.| - |.z2.| <= |.z1 - z2.|;

  theorem :: COMPLFLD:104
        |.z1 - z2.| = |.z2 - z1.|;

  theorem :: COMPLFLD:105
        |.z1 - z2.| = 0 iff z1 = z2;

  theorem :: COMPLFLD:106
        z1 <> z2 iff 0 < |.z1 - z2.|;

  theorem :: COMPLFLD:107
        |.z1 - z2.| <= |.z1 - z.| + |.z - z2.|;

  theorem :: COMPLFLD:108
        abs(|.z1.| - |.z2.|) <= |.z1 - z2.|;

  theorem :: COMPLFLD:109
        |.z1*z2.| = |.z1.|*|.z2.|;

  theorem :: COMPLFLD:110
        z <> 0.F_Complex implies |.z".| = |.z.|";

  theorem :: COMPLFLD:111
        z2 <> 0.F_Complex implies |.z1.| / |.z2.| = |.z1 / z2.|;

begin :: Addenda

:: from COMPTRIG, 2006.08.12, A.T.

scheme :: COMPLFLD:sch 1
 Regrwithout0 { P[Nat] } :
  P[1]
  provided
 ex k be non empty Element of NAT st P[k] and
 for k be non empty Element of NAT st k <> 1 & P[k]
    ex n be non empty Element of NAT st n < k & P[n];

theorem :: COMPLFLD:112
 for e being Element of F_Complex, n be non empty Nat
  holds (power F_Complex).(e,n) = e|^n;

  definition
   let x be Element of F_Complex;
   let n be non empty Element of NAT;
   redefine
   mode CRoot of n,x -> Element of F_Complex means
:: COMPLFLD:def 2
    (power F_Complex).(it,n) = x;
  end;

  theorem :: COMPLFLD:113
    for x be Element of F_Complex
   for v be CRoot of 1,x holds
    v = x;

  theorem :: COMPLFLD:114
    for n be non empty Element of NAT
   for v be CRoot of n,0.F_Complex holds
    v = 0.F_Complex;

  theorem :: COMPLFLD:115
    for n be non empty Element of NAT
   for x be Element of F_Complex
   for v be CRoot of n,x st v = 0.F_Complex holds
    x = 0.F_Complex;

