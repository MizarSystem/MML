:: The Binomial Theorem for Algebraic Structures
::  by Christoph Schwarzweller
::
:: Received November 20, 2000
:: Copyright (c) 2000 Association of Mizar Users

environ

 vocabulary RLVECT_1, ALGSTR_1, VECTSP_2, ARYTM_1, BINOP_1, LATTICES, GROUP_1,
      VECTSP_1, ALGSTR_2, FUNCT_1, FUNCT_2, MCART_1, RELAT_1, FINSEQ_1,
      FINSEQ_4, NEWTON, FINSEQ_2, BOOLE, BINOM;
 notation TARSKI, XBOOLE_0, ZFMISC_1, SUBSET_1, NUMBERS, XCMPLX_0, XREAL_0,
      STRUCT_0, FINSEQ_1, FUNCT_1, FUNCT_2, NAT_1, FINSEQ_4, RELSET_1, BINOP_1,
      ALGSTR_1, FINSEQ_2, VECTSP_1, VECTSP_2, GROUP_1, NEWTON, RLVECT_1,
      MCART_1, POLYNOM1;
 constructors BINOP_1, REAL_1, ALGSTR_2, NEWTON, DOMAIN_1, POLYNOM1, MONOID_0,
      MEMBERED;
 clusters STRUCT_0, ALGSTR_1, RELSET_1, FUNCT_2, MONOID_0, FINSEQ_2, VECTSP_2,
      INT_1, VECTSP_1, MEMBERED, ZFMISC_1, ORDINAL2, NUMBERS;
 requirements NUMERALS, SUBSET, REAL, BOOLE, ARITHM;


begin  :: Preliminaries
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

definition
  let L be non empty LoopStr;
 canceled 2;

attr L is add-cancelable means
:: BINOM:def 3
  for a,b,c being Element of L
  holds (a + b = a + c implies b = c) & (b + a = c + a implies b = c);
end;


registration
cluster add-left-cancelable (non empty LoopStr);
existence
 proof
 consider R being comRing;
 take R;
 thus thesis;
 end;
cluster add-right-cancelable (non empty LoopStr);
existence
 proof
 consider R being comRing;
 take R;
 thus thesis;
 end;
cluster add-cancelable (non empty LoopStr);
existence
 proof
 consider R being comRing;
 take R;
  now let a,b,c be Element of R;
     now assume A1:  b + a = c + a;
   thus b = b + 0.R by RLVECT_1:def 7
         .= b + (a + -a) by RLVECT_1:16
         .= (c + a) + -a by A1,RLVECT_1:def 6
         .= c + (a + -a) by RLVECT_1:def 6
         .= c + 0.R by RLVECT_1:16
         .= c by RLVECT_1:def 7;
      end;
   hence (a + b = a + c implies b = c) & (b + a = c + a implies b = c);
   end;
 hence thesis by Def3;
 end;
end;


registration
cluster add-left-cancelable add-right-cancelable ->
                     add-cancelable (non empty LoopStr);
coherence
 proof
 let R be non empty LoopStr;
 assume R is add-left-cancelable add-right-cancelable;
 then for a,b,c being Element of R holds
 (a + b = a + c implies b = c) & (b + a = c + a implies b = c)
   by ALGSTR_1:def 6,def 7;
 hence thesis by Def3;
 end;
cluster add-cancelable ->
           add-left-cancelable add-right-cancelable (non empty LoopStr);
coherence
 proof
 let R be non empty LoopStr;
 assume R is add-cancelable;
 then for a,b,c being Element of R
  holds (a + b = a + c implies b = c) & (b + a = c + a implies b = c) by Def3;
 hence thesis by ALGSTR_1:def 6,def 7;
 end;
end;


registration
cluster Abelian add-right-cancelable ->
  add-left-cancelable (non empty LoopStr);
coherence
 proof
 let R be non empty LoopStr;
 assume A1: R is Abelian add-right-cancelable;
   now let a,b,c be Element of R;
   assume a + b = a + c;
   then b + a = a + c by A1,RLVECT_1:def 5
        .= c + a by A1,RLVECT_1:def 5;
   hence b = c by A1,ALGSTR_1:def 7;
   end;
 hence thesis by ALGSTR_1:def 6;
 end;
cluster Abelian add-left-cancelable ->
            add-right-cancelable (non empty LoopStr);
coherence
 proof
 let R be non empty LoopStr;
 assume A2: R is Abelian add-left-cancelable;
   now let a,b,c be Element of R;
   assume b + a = c + a;
   then a + b = c + a by A2,RLVECT_1:def 5
        .= a + c by A2,RLVECT_1:def 5;
   hence b = c by A2,ALGSTR_1:def 6;
   end;
 hence thesis by ALGSTR_1:def 7;
 end;
end;


registration
cluster right_zeroed right_complementable add-associative ->
           add-right-cancelable (non empty LoopStr);
coherence
 proof
 let R be (non empty LoopStr);
 assume A1: R is right_zeroed right_complementable add-associative;
   now let a,b,c be Element of R;
   assume A2:  b + a = c + a;
   thus b = b + 0.R by A1,RLVECT_1:def 7
         .= b + (a + -a) by A1,RLVECT_1:16
         .= (c + a) + -a by A1,A2,RLVECT_1:def 6
         .= c + (a + -a) by A1,RLVECT_1:def 6
         .= c + 0.R by A1,RLVECT_1:16
         .= c by A1,RLVECT_1:def 7;
   end;
 hence thesis by ALGSTR_1:def 7;
 end;
end;


registration
cluster Abelian add-associative left_zeroed right_zeroed
        commutative associative add-cancelable
        distributive unital (non empty doubleLoopStr);
existence
 proof
 consider R being comRing;
 take R;
 thus thesis;
 end;
end;


theorem :: BINOM:1
for R being right_zeroed add-left-cancelable
            left-distributive (non empty doubleLoopStr),
    a being Element of R
holds 0.R * a = 0.R;

theorem :: BINOM:2
for R being left_zeroed add-right-cancelable
            right-distributive (non empty doubleLoopStr),
    a being Element of R
holds a * 0.R = 0.R;

scheme :: BINOM:sch 1
 Ind2{M() -> Nat, P[Nat]} :
for i being Nat st M() <= i holds P[i]
provided
  P[M()] and
  for j being Nat st M() <= j holds P[j] implies P[j+1]
proof
let i be Nat;
assume A3: M() <= i;
defpred Q[Nat] means P[M() + $1];
A4: Q[0] by A1;
A5: now let m be Nat;
    assume A6: Q[m];
      M() <= M() + m by NAT_1:29;
    then P[(M() + m) + 1] by A2,A6;
    hence Q[m+1] by XCMPLX_1:1;
    end;
A7: for m being Nat holds Q[m] from NAT_1:sch 1(A4,A5);
  ex m being Nat st i = M() + m by A3,NAT_1:28;
hence thesis by A7;
end;

scheme :: BINOM:sch 2
 RecDef1 {C,D() -> non empty set,
                b() -> Element of D(),
                F() -> Function of [:C(),D():],D()} :
ex g being Function of [:NAT,C():],D() st
   for a being Element of C() holds g.(0,a) = b() &
   for n being Nat holds g.(n+1,a) = F().(a,g.(n,a))
proof
A1: for a being Element of C() holds
    ex f being Function of NAT,D()
    st f.0 = b() &
       for n being Nat holds f.(n+1) = F().(a,f.n)
    proof
    let a be Element of C();
    defpred P[Nat,Element of D(),Element of D()] means $3 = F().(a,$2);
    A2: for n being Nat for x being Element of D()
        ex y being Element of D() st P[n,x,y];
      ex f being Function of NAT,D() st
      f.0 = b() &
      for n being Element of NAT holds P[n,f.n,f.(n+1)] from RECDEF_1:sch 2
(A2);
    hence thesis;
    end;
  ex g being Function of C(),Funcs(NAT,D())
    st for a being Element of C() holds
       ex f being Function of NAT,D()
       st g.a = f &
          f.0 = b() &
          for n being Nat holds f.(n+1) = F().(a,f.n)
    proof
    set h = {[a,l] where a is Element of C(),
                         l is Element of Funcs(NAT,D()) :
              ex f being Function of NAT,D()
              st f = l & f.0 = b() &
                 for n being Nat holds f.(n+1) = F().(a,f.n) };
    A3: now let x,y1,y2 be set;
      assume A4: [x,y1] in h & [x,y2] in h;
      then consider a1 being Element of C(),
                    l1 being Element of Funcs(NAT,D()) such that
      A5: [x,y1] = [a1,l1] &
          ex f being Function of NAT,D()
          st f = l1 & f.0 = b() &
             for n being Nat holds f.(n+1) = F().(a1,f.n);
      consider f1 being Function of NAT,D() such that
      A6: f1 = l1 & f1.0 = b() &
          for n being Nat holds f1.(n+1) = F().(a1,f1.n) by A5;
      consider a2 being Element of C(),
               l2 being Element of Funcs(NAT,D()) such that
      A7: [x,y2] = [a2,l2] &
          ex f being Function of NAT,D()
          st f = l2 & f.0 = b() &
             for n being Nat holds f.(n+1) = F().(a2,f.n) by A4;
      consider f2 being Function of NAT,D() such that
      A8: f2 = l2 & f2.0 = b() &
          for n being Nat holds f2.(n+1) = F().(a2,f2.n) by A7;
      A9: a1 = [x,y1]`1 by A5,MCART_1:def 1
            .= x by MCART_1:def 1
            .= [a2,l2]`1 by A7,MCART_1:def 1
            .= a2 by MCART_1:def 1;
      A10: NAT = dom f1 & NAT = dom f2 by FUNCT_2:def 1;
      A11: now let x be set;
          assume x in NAT;
          then reconsider x' = x as Nat;
               defpred _P[Nat] means f1.$1 = f2.$1 ;
          A12: _P[0] by A6,A8;
          A13: now let n be Nat;
               assume A14: _P[n];
                    f1.(n+1) = F().(a2,f1.n) by A6,A9
                            .= f2.(n+1) by A8,A14;
                 hence _P[n+1];
               end;
            for n being Nat holds _P[n] from NAT_1:sch 1(A12,A13);
          hence f1.x = f2.x' .= f2.x;
          end;
      thus y1 = [a1,l1]`2 by A5,MCART_1:def 2
             .= l1 by MCART_1:def 2
             .= l2 by A6,A8,A10,A11,FUNCT_1:9
             .= [x,y2]`2 by A7,MCART_1:def 2
             .= y2 by MCART_1:def 2;
      end;
      now let x be set;
      assume x in h;
      then consider a being Element of C(),
                    l being Element of Funcs(NAT,D()) such that
      A15: x = [a,l] &
          ex f being Function of NAT,D()
          st f = l & f.0 = b() &
             for n being Nat holds f.(n+1) = F().(a,f.n);
      thus x in [:C(),Funcs(NAT,D()):] by A15,ZFMISC_1:def 2;
      end;
    then h c= [:C(),Funcs(NAT,D()):] by TARSKI:def 3;
    then reconsider h as Relation of C(),Funcs(NAT,D()) by RELSET_1:def 1;
    A16: for x being set holds x in dom h implies x in C();
      for x being set holds x in C() implies x in dom h
      proof
      let x be set;
      assume A17: x in C();
      then consider f being Function of NAT,D() such that
      A18:  f.0 = b() &
           for n being Nat holds f.(n+1) = F().(x,f.n) by A1;
      reconsider f' = f as Element of Funcs(NAT,D()) by FUNCT_2:11;
        [x,f'] in h by A17,A18;
      hence thesis by RELAT_1:def 4;
      end;
    then dom h = C() by A16,TARSKI:2;
    then reconsider h as Function of C(),Funcs(NAT,D())
      by A3,FUNCT_1:def 1,FUNCT_2:def 1;
    take h;
      for a being Element of C() holds
       ex f being Function of NAT,D()
       st h.a = f &
          f.0 = b() &
          for n being Nat holds f.(n+1) = F().(a,f.n)
      proof
      let a be Element of C();
        dom h = C() by FUNCT_2:def 1;
      then [a,h.a] in h by FUNCT_1:8;
      then consider a' being Element of C(),
                    l being Element of Funcs(NAT,D()) such that
      A19: [a,h.a] = [a',l] &
          ex f' being Function of NAT,D()
          st f' = l & f'.0 = b() &
             for n being Nat holds f'.(n+1) = F().(a',f'.n);
      consider f' being Function of NAT,D() such that
      A20: f' = l & f'.0 = b() &
          for n being Nat holds f'.(n+1) = F().(a',f'.n) by A19;
      A21: a = [a',l]`1 by A19,MCART_1:def 1
           .= a' by MCART_1:def 1;
        h.a = [a',l]`2 by A19,MCART_1:def 2
         .= l by MCART_1:def 2;
      hence thesis by A20,A21;
      end;
    hence thesis;
    end;
then consider g being Function of C(),Funcs(NAT,D()) such that
A22: for a being Element of C() holds
   ex f being Function of NAT,D()
   st g.a = f &
      f.0 = b() &
      for n being Nat holds f.(n+1) = F().(a,f.n);
set h = { [[n,a],z] where n is Nat, a is Element of C(), z is Element of D() :
          ex f being Function of NAT,D() st f = g.a & z = f.n };
A23: now let x,y1,y2 be set;
  assume A24: [x,y1] in h & [x,y2] in h;
  then consider n1 being Nat,
                a1 being Element of C(),
                z1 being Element of D() such that
  A25: [x,y1] = [[n1,a1],z1] &
      ex f1 being Function of NAT,D() st f1 = g.a1 & z1 = f1.n1;
  consider n2 being Nat,
           a2 being Element of C(),
           z2 being Element of D() such that
  A26: [x,y2] = [[n2,a2],z2] &
      ex f2 being Function of NAT,D() st f2 = g.a2 & z2 = f2.n2 by A24;
  A27: [n1,a1] = [x,y1]`1 by A25,MCART_1:def 1
             .= x by MCART_1:def 1
             .= [[n2,a2],z2]`1 by A26,MCART_1:def 1
             .= [n2,a2] by MCART_1:def 1;
  then A28: n1 = [n2,a2]`1 by MCART_1:def 1
         .= n2 by MCART_1:def 1;
    a1 = [n2,a2]`2 by A27,MCART_1:def 2
         .= a2 by MCART_1:def 2;
  hence y1 = [x,y2]`2 by A25,A26,A28,MCART_1:def 2
         .= y2 by MCART_1:def 2;
  end;
  now let x be set;
  assume x in h;
  then consider n1 being Nat,
                a1 being Element of C(),
                z1 being Element of D() such that
  A29: x = [[n1,a1],z1] &
      ex f1 being Function of NAT,D() st f1 = g.a1 & z1 = f1.n1;
    [n1,a1] in [:NAT,C():] by ZFMISC_1:def 2;
  hence x in [:[:NAT,C():],D():] by A29,ZFMISC_1:def 2;
  end;
then h c= [:[:NAT,C():],D():] by TARSKI:def 3;
then reconsider h as Relation of [:NAT,C():],D() by RELSET_1:def 1;
A30: for x being set holds x in dom h implies x in [:NAT,C():];
  for x being set holds x in [:NAT,C():] implies x in dom h
      proof
      let x be set;
      assume x in [:NAT,C():];
      then consider n,d being set such that
      A31: n in NAT & d in C() & x = [n,d] by ZFMISC_1:def 2;
      reconsider n as Nat by A31;
      reconsider d as Element of C() by A31;
      consider f' being Function of NAT,D() such that
      A32: g.d = f' &
          f'.0 = b() &
          for n being Nat holds f'.(n+1) = F().(d,f'.n) by A22;
        ex z being Element of D() st
      ex f being Function of NAT,D() st f = g.d & z = f.n
        proof
        take f'.n;
        take f';
        thus thesis by A32;
        end;
      then consider z being Element of D() such that
      A33: ex f being Function of NAT,D() st f = g.d & z = f.n;
        [x,z] in h by A31,A33;
      hence thesis by RELAT_1:def 4;
      end;
then dom h = [:NAT,C():] by A30,TARSKI:2;
then reconsider h as Function of [:NAT,C():],D()
   by A23,FUNCT_1:def 1,FUNCT_2:def 1;
take h;
  for a being Element of C() holds h.(0,a) = b() &
      for n being Nat holds h.(n+1,a) = F().(a,h.(n,a))
  proof
  let a be Element of C();
  consider f' being Function of NAT,D() such that
  A34: g.a = f' &
     f'.0 = b() &
     for n being Nat holds f'.(n+1) = F().(a,f'.n) by A22;
    [0,a] in [:NAT,C():] by ZFMISC_1:def 2;
  then [0,a] in dom h by FUNCT_2:def 1;
  then consider u being set such that
  A35: [[0,a],u] in h by RELAT_1:def 4;
  consider n being Nat,
           d being Element of C(),
           z being Element of D() such that
  A36: [[0,a],u] = [[n,d],z] &
      ex f1 being Function of NAT,D() st f1 = g.d & z = f1.n by A35;
  consider f1 being Function of NAT,D() such that
  A37: f1 = g.d & z = f1.n by A36;
  A38: [0,a] = [[n,d],z]`1 by A36,MCART_1:def 1
           .= [n,d] by MCART_1:def 1;
  then A39: n = [0,a]`1 by MCART_1:def 1
       .= 0 by MCART_1:def 1;
  A40: u = [[n,d],z]`2 by A36,MCART_1:def 2
       .= z by MCART_1:def 2;
  A41: d = [0,a]`2 by A38,MCART_1:def 2
       .= a by MCART_1:def 2;
  A42: h.(0,a) = h.[0,a] by BINOP_1:def 1
             .= b() by A34,A35,A37,A39,A40,A41,FUNCT_1:8;
    now let k be Nat;
      [k+1,a] in [:NAT,C():] by ZFMISC_1:def 2;
    then [k+1,a] in dom h by FUNCT_2:def 1;
    then consider u being set such that
    A43: [[k+1,a],u] in h by RELAT_1:def 4;
    consider n being Nat,
             d being Element of C(),
             z being Element of D() such that
    A44: [[k+1,a],u] = [[n,d],z] &
        ex f1 being Function of NAT,D() st f1 = g.d & z = f1.n by A43;
    consider f1 being Function of NAT,D() such that
    A45: f1 = g.d & z = f1.n by A44;
    A46: [k+1,a] = [[n,d],z]`1 by A44,MCART_1:def 1
               .= [n,d] by MCART_1:def 1;
    then A47: n = [k+1,a]`1 by MCART_1:def 1
         .= k+1 by MCART_1:def 1;
    A48: u = [[n,d],z]`2 by A44,MCART_1:def 2
         .= z by MCART_1:def 2;
    A49: d = [k+1,a]`2 by A46,MCART_1:def 2
         .= a by MCART_1:def 2;
      [k,a] in [:NAT,C():] by ZFMISC_1:def 2;
    then [k,a] in dom h by FUNCT_2:def 1;
    then consider v being set such that
    A50: [[k,a],v] in h by RELAT_1:def 4;
    consider n1 being Nat,
             d1 being Element of C(),
             z1 being Element of D() such that
    A51: [[k,a],v] = [[n1,d1],z1] &
         ex f2 being Function of NAT,D() st f2 = g.d1 & z1 = f2.n1 by A50;
    consider f2 being Function of NAT,D() such that
    A52: f2 = g.d1 & z1 = f2.n1 by A51;
    A53: [k,a] = [[n1,d1],z1]`1 by A51,MCART_1:def 1
              .= [n1,d1] by MCART_1:def 1;
    then A54: n1 = [k,a]`1 by MCART_1:def 1
           .= k by MCART_1:def 1;
    A55: v = [[n1,d1],z1]`2 by A51,MCART_1:def 2
          .= z1 by MCART_1:def 2;
    A56: d1 = [k,a]`2 by A53,MCART_1:def 2
           .= a by MCART_1:def 2;
    thus h.(k+1,a) = h.[k+1,a] by BINOP_1:def 1
                  .= f'.(k+1) by A34,A43,A45,A47,A48,A49,FUNCT_1:8
                  .= F().(a,z1) by A34,A52,A54,A56
                  .= F().(a,h.[k,a]) by A50,A55,FUNCT_1:8
                  .= F().(a,h.(k,a)) by BINOP_1:def 1;
    end;
  hence thesis by A42;
  end;
hence thesis;
end;

scheme :: BINOM:sch 3
 RecDef2 {C,D() -> non empty set,
                b() -> Element of D(),
                F() -> Function of [:D(),C():],D()} :
ex g being Function of [:C(),NAT:],D() st
   for a being Element of C() holds g.(a,0) = b() &
   for n being Nat holds g.(a,n+1) = F().(g.(a,n),a)
proof
A1: for a being Element of C() holds
    ex f being Function of NAT,D()
    st f.0 = b() &
       for n being Nat holds f.(n+1) = F().(f.n,a)
    proof
    let a be Element of C();
    defpred P[Nat,Element of D(),Element of D()] means $3 = F().($2,a);
    A2: for n being Nat for x being Element of D()
        ex y being Element of D() st P[n,x,y];
      ex f being Function of NAT,D() st
      f.0 = b() &
      for n being Element of NAT holds P[n,f.n,f.(n+1)] from RECDEF_1:sch 2
(A2);
    hence thesis;
    end;
  ex g being Function of C(),Funcs(NAT,D())
    st for a being Element of C() holds
       ex f being Function of NAT,D()
       st g.a = f &
          f.0 = b() &
          for n being Nat holds f.(n+1) = F().(f.n,a)
    proof
    set h = {[a,l] where a is Element of C(),
                         l is Element of Funcs(NAT,D()) :
              ex f being Function of NAT,D()
              st f = l & f.0 = b() &
                 for n being Nat holds f.(n+1) = F().(f.n,a) };
    A3: now let x,y1,y2 be set;
      assume A4: [x,y1] in h & [x,y2] in h;
      then consider a1 being Element of C(),
                    l1 being Element of Funcs(NAT,D()) such that
      A5: [x,y1] = [a1,l1] &
          ex f being Function of NAT,D()
          st f = l1 & f.0 = b() &
             for n being Nat holds f.(n+1) = F().(f.n,a1);
      consider f1 being Function of NAT,D() such that
      A6: f1 = l1 & f1.0 = b() &
          for n being Nat holds f1.(n+1) = F().(f1.n,a1) by A5;
      consider a2 being Element of C(),
               l2 being Element of Funcs(NAT,D()) such that
      A7: [x,y2] = [a2,l2] &
          ex f being Function of NAT,D()
          st f = l2 & f.0 = b() &
             for n being Nat holds f.(n+1) = F().(f.n,a2) by A4;
      consider f2 being Function of NAT,D() such that
      A8: f2 = l2 & f2.0 = b() &
          for n being Nat holds f2.(n+1) = F().(f2.n,a2) by A7;
      A9: a1 = [x,y1]`1 by A5,MCART_1:def 1
            .= x by MCART_1:def 1
            .= [a2,l2]`1 by A7,MCART_1:def 1
            .= a2 by MCART_1:def 1;
      A10: NAT = dom f1 & NAT = dom f2 by FUNCT_2:def 1;
      A11: now let x be set;
          assume x in NAT;
          then reconsider x' = x as Nat;
          defpred _P[Nat] means f1.$1 = f2.$1 ;
          A12: _P[0] by A6,A8;
          A13: now let n be Nat;
               assume A14: _P[n];
                f1.(n+1) = F().(f1.n,a2) by A6,A9
                            .= f2.(n+1) by A8,A14;
                hence _P[n+1];
               end;
            for n being Nat holds _P[n] from NAT_1:sch 1(A12,A13);
          hence f1.x = f2.x' .= f2.x;
          end;
      thus y1 = [a1,l1]`2 by A5,MCART_1:def 2
             .= l1 by MCART_1:def 2
             .= l2 by A6,A8,A10,A11,FUNCT_1:9
             .= [x,y2]`2 by A7,MCART_1:def 2
             .= y2 by MCART_1:def 2;
      end;
      now let x be set;
      assume x in h;
      then consider a being Element of C(),
                    l being Element of Funcs(NAT,D()) such that
      A15: x = [a,l] &
          ex f being Function of NAT,D()
          st f = l & f.0 = b() &
             for n being Nat holds f.(n+1) = F().(f.n,a);
      thus x in [:C(),Funcs(NAT,D()):] by A15,ZFMISC_1:def 2;
      end;
    then h c= [:C(),Funcs(NAT,D()):] by TARSKI:def 3;
    then reconsider h as Relation of C(),Funcs(NAT,D()) by RELSET_1:def 1;
    A16: for x being set holds x in dom h implies x in C();
      for x being set holds x in C() implies x in dom h
      proof
      let x be set;
      assume A17: x in C();
      then consider f being Function of NAT,D() such that
      A18:  f.0 = b() &
           for n being Nat holds f.(n+1) = F().(f.n,x) by A1;
      reconsider f' = f as Element of Funcs(NAT,D()) by FUNCT_2:11;
        [x,f'] in h by A17,A18;
      hence thesis by RELAT_1:def 4;
      end;
    then dom h = C() by A16,TARSKI:2;
    then reconsider h as Function of C(),Funcs(NAT,D())
      by A3,FUNCT_1:def 1,FUNCT_2:def 1;
    take h;
      for a being Element of C() holds
       ex f being Function of NAT,D()
       st h.a = f &
          f.0 = b() &
          for n being Nat holds f.(n+1) = F().(f.n,a)
      proof
      let a be Element of C();
        dom h = C() by FUNCT_2:def 1;
      then [a,h.a] in h by FUNCT_1:8;
      then consider a' being Element of C(),
                    l being Element of Funcs(NAT,D()) such that
      A19: [a,h.a] = [a',l] &
          ex f' being Function of NAT,D()
          st f' = l & f'.0 = b() &
             for n being Nat holds f'.(n+1) = F().(f'.n,a');
      consider f' being Function of NAT,D() such that
      A20: f' = l & f'.0 = b() &
          for n being Nat holds f'.(n+1) = F().(f'.n,a') by A19;
      A21: a = [a',l]`1 by A19,MCART_1:def 1
           .= a' by MCART_1:def 1;
        h.a = [a',l]`2 by A19,MCART_1:def 2
         .= l by MCART_1:def 2;
      hence thesis by A20,A21;
      end;
    hence thesis;
    end;
then consider g being Function of C(),Funcs(NAT,D()) such that
A22: for a being Element of C() holds
   ex f being Function of NAT,D()
   st g.a = f &
      f.0 = b() &
      for n being Nat holds f.(n+1) = F().(f.n,a);
set h = { [[a,n],z] where n is Nat, a is Element of C(), z is Element of D() :
          ex f being Function of NAT,D() st f = g.a & z = f.n };
A23: now let x,y1,y2 be set;
  assume A24: [x,y1] in h & [x,y2] in h;
  then consider n1 being Nat,
                a1 being Element of C(),
                z1 being Element of D() such that
  A25: [x,y1] = [[a1,n1],z1] &
      ex f1 being Function of NAT,D() st f1 = g.a1 & z1 = f1.n1;
  consider n2 being Nat,
           a2 being Element of C(),
           z2 being Element of D() such that
  A26: [x,y2] = [[a2,n2],z2] &
      ex f2 being Function of NAT,D() st f2 = g.a2 & z2 = f2.n2 by A24;
  A27: [a1,n1] = [x,y1]`1 by A25,MCART_1:def 1
             .= x by MCART_1:def 1
             .= [[a2,n2],z2]`1 by A26,MCART_1:def 1
             .= [a2,n2] by MCART_1:def 1;
  then A28: a1 = [a2,n2]`1 by MCART_1:def 1
         .= a2 by MCART_1:def 1;
    n1 = [a2,n2]`2 by A27,MCART_1:def 2
         .= n2 by MCART_1:def 2;
  hence y1 = [x,y2]`2 by A25,A26,A28,MCART_1:def 2
         .= y2 by MCART_1:def 2;
  end;
  now let x be set;
  assume x in h;
  then consider n1 being Nat,
                a1 being Element of C(),
                z1 being Element of D() such that
  A29: x = [[a1,n1],z1] &
      ex f1 being Function of NAT,D() st f1 = g.a1 & z1 = f1.n1;
    [a1,n1] in [:C(),NAT:] by ZFMISC_1:def 2;
  hence x in [:[:C(),NAT:],D():] by A29,ZFMISC_1:def 2;
  end;
then h c= [:[:C(),NAT:],D():] by TARSKI:def 3;
then reconsider h as Relation of [:C(),NAT:],D() by RELSET_1:def 1;
A30: for x being set holds x in dom h implies x in [:C(),NAT:];
  for x being set holds x in [:C(),NAT:] implies x in dom h
      proof
      let x be set;
      assume x in [:C(),NAT:];
      then consider d,n being set such that
      A31: d in C() & n in NAT & x = [d,n] by ZFMISC_1:def 2;
      reconsider n as Nat by A31;
      reconsider d as Element of C() by A31;
      consider f' being Function of NAT,D() such that
      A32: g.d = f' &
          f'.0 = b() &
          for n being Nat holds f'.(n+1) = F().(f'.n,d) by A22;
        ex z being Element of D() st
      ex f being Function of NAT,D() st f = g.d & z = f.n
        proof
        take f'.n;
        take f';
        thus thesis by A32;
        end;
      then consider z being Element of D() such that
      A33: ex f being Function of NAT,D() st f = g.d & z = f.n;
        [x,z] in h by A31,A33;
      hence thesis by RELAT_1:def 4;
      end;
then dom h = [:C(),NAT:] by A30,TARSKI:2;
then reconsider h as Function of [:C(),NAT:],D()
   by A23,FUNCT_1:def 1,FUNCT_2:def 1;
take h;
  for a being Element of C() holds h.(a,0) = b() &
      for n being Nat holds h.(a,n+1) = F().(h.(a,n),a)
  proof
  let a be Element of C();
  consider f' being Function of NAT,D() such that
  A34: g.a = f' &
     f'.0 = b() &
     for n being Nat holds f'.(n+1) = F().(f'.n,a) by A22;
    [a,0] in [:C(),NAT:] by ZFMISC_1:def 2;
  then [a,0] in dom h by FUNCT_2:def 1;
  then consider u being set such that
  A35: [[a,0],u] in h by RELAT_1:def 4;
  consider n being Nat,
           d being Element of C(),
           z being Element of D() such that
  A36: [[a,0],u] = [[d,n],z] &
      ex f1 being Function of NAT,D() st f1 = g.d & z = f1.n by A35;
  consider f1 being Function of NAT,D() such that
  A37: f1 = g.d & z = f1.n by A36;
  A38: [a,0] = [[d,n],z]`1 by A36,MCART_1:def 1
           .= [d,n] by MCART_1:def 1;
  then A39: n = [a,0]`2 by MCART_1:def 2
       .= 0 by MCART_1:def 2;
  A40: u = [[d,n],z]`2 by A36,MCART_1:def 2
       .= z by MCART_1:def 2;
  A41: d = [a,0]`1 by A38,MCART_1:def 1
       .= a by MCART_1:def 1;
  A42: h.(a,0) = h.[a,0] by BINOP_1:def 1
             .= b() by A34,A35,A37,A39,A40,A41,FUNCT_1:8;
    now let k be Nat;
      [a,k+1] in [:C(),NAT:] by ZFMISC_1:def 2;
    then [a,k+1] in dom h by FUNCT_2:def 1;
    then consider u being set such that
    A43: [[a,k+1],u] in h by RELAT_1:def 4;
    consider n being Nat,
             d being Element of C(),
             z being Element of D() such that
    A44: [[a,k+1],u] = [[d,n],z] &
        ex f1 being Function of NAT,D() st f1 = g.d & z = f1.n by A43;
    consider f1 being Function of NAT,D() such that
    A45: f1 = g.d & z = f1.n by A44;
    A46: [a,k+1] = [[d,n],z]`1 by A44,MCART_1:def 1
               .= [d,n] by MCART_1:def 1;
    then A47: n = [a,k+1]`2 by MCART_1:def 2
         .= k+1 by MCART_1:def 2;
    A48: u = [[d,n],z]`2 by A44,MCART_1:def 2
         .= z by MCART_1:def 2;
    A49: d = [a,k+1]`1 by A46,MCART_1:def 1
         .= a by MCART_1:def 1;
      [a,k] in [:C(),NAT:] by ZFMISC_1:def 2;
    then [a,k] in dom h by FUNCT_2:def 1;
    then consider v being set such that
    A50: [[a,k],v] in h by RELAT_1:def 4;
    consider n1 being Nat,
             d1 being Element of C(),
             z1 being Element of D() such that
    A51: [[a,k],v] = [[d1,n1],z1] &
         ex f2 being Function of NAT,D() st f2 = g.d1 & z1 = f2.n1 by A50;
    consider f2 being Function of NAT,D() such that
    A52: f2 = g.d1 & z1 = f2.n1 by A51;
    A53: [a,k] = [[d1,n1],z1]`1 by A51,MCART_1:def 1
              .= [d1,n1] by MCART_1:def 1;
    then A54: n1 = [a,k]`2 by MCART_1:def 2
           .= k by MCART_1:def 2;
    A55: v = [[d1,n1],z1]`2 by A51,MCART_1:def 2
          .= z1 by MCART_1:def 2;
    A56: d1 = [a,k]`1 by A53,MCART_1:def 1
           .= a by MCART_1:def 1;
    thus h.(a,k+1) = h.[a,k+1] by BINOP_1:def 1
                  .= f'.n by A34,A43,A45,A48,A49,FUNCT_1:8
                  .= F().(f2.n1,a) by A34,A47,A52,A54,A56
                  .= F().(h.[a,k],a) by A50,A52,A55,FUNCT_1:8
                  .= F().(h.(a,k),a) by BINOP_1:def 1;
    end;
  hence thesis by A42;
  end;
hence thesis;
end;


begin  ::  On Finite Sequences
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::


theorem :: BINOM:3
for L being left_zeroed (non empty LoopStr),
    a being Element of L
holds Sum <* a *> = a;

theorem :: BINOM:4
  for R being left_zeroed add-right-cancelable
            right-distributive (non empty doubleLoopStr),
    a being Element of R,
    p being FinSequence of the carrier of R
holds Sum(a * p) = a * Sum p;

theorem :: BINOM:5
for R being right_zeroed add-left-cancelable
            left-distributive (non empty doubleLoopStr),
    a being Element of R,
    p being FinSequence of the carrier of R
holds Sum(p * a) = Sum p * a;

theorem :: BINOM:6
  for R being commutative (non empty doubleLoopStr),
    a being Element of R,
    p being FinSequence of the carrier of R
holds Sum(p * a) = Sum(a * p);

definition
let R be non empty LoopStr,
    p,q be FinSequence of the carrier of R such that dom p = dom q;
func p + q -> FinSequence of the carrier of R means
:: BINOM:def 4
  dom it = dom p &
  for i being Nat st 1 <= i & i <= len it holds it/.i = p/.i + q/.i;
end;


theorem :: BINOM:7
for R being Abelian right_zeroed add-associative (non empty LoopStr),
    p,q being FinSequence of the carrier of R st dom p = dom q
holds Sum(p + q) = Sum p + Sum q;


begin  ::  On Powers in Rings
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::


definition
let R be unital (non empty HGrStr),
    a be Element of R,
    n be Nat;
func a|^n -> Element of R equals
:: BINOM:def 5
  power(R).(a,n);
end;


theorem :: BINOM:8
for R being unital (non empty HGrStr),
    a being Element of R
holds a|^0 = 1.R & a|^1 = a;

theorem :: BINOM:9
for R being unital (non empty HGrStr),
    a being Element of R,
    n being Nat
holds a|^(n+1) = (a|^n) * a;

theorem :: BINOM:10
  for R being unital associative commutative (non empty HGrStr),
    a,b being Element of R,
    n being Nat
holds (a * b)|^n = (a|^n) * (b|^n);

theorem :: BINOM:11
for R being unital associative (non empty HGrStr),
    a being Element of R,
    n,m being Nat
holds a|^(n+m) = (a|^n) * (a|^m);

theorem :: BINOM:12
  for R being unital associative (non empty HGrStr),
    a being Element of R,
    n,m being Nat
holds (a|^n)|^m = a|^(n * m);


begin  ::  On Natural Products in Rings
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::


definition
let R be non empty LoopStr;
func Nat-mult-left(R)
        -> Function of [:NAT,the carrier of R:],the carrier of R means
:: BINOM:def 6
  for a being Element of R
  holds it.(0,a) = 0.R &
        for n being Nat holds it.(n+1,a) = a + it.(n,a);
func Nat-mult-right(R)
        -> Function of [:the carrier of R,NAT:],the carrier of R means
:: BINOM:def 7
  for a being Element of R
  holds it.(a,0) = 0.R &
        for n being Nat holds it.(a,n+1) = it.(a,n) + a;
end;


definition
let R be non empty LoopStr,
    a be Element of R,
    n be Nat;
func n * a -> Element of R equals
:: BINOM:def 8
  (Nat-mult-left(R)).(n,a);
func a * n -> Element of R equals
:: BINOM:def 9
  (Nat-mult-right(R)).(a,n);
end;


theorem :: BINOM:13
for R being non empty LoopStr,
    a being Element of R
holds 0 * a = 0.R & a * 0 = 0.R;

theorem :: BINOM:14
for R being right_zeroed (non empty LoopStr),
    a being Element of R
holds 1 * a = a;

theorem :: BINOM:15
for R being left_zeroed (non empty LoopStr),
    a being Element of R
holds a * 1 = a;

theorem :: BINOM:16
for R being left_zeroed add-associative (non empty LoopStr),
    a being Element of R,
    n,m being Nat
holds (n + m) * a = n * a + m * a;

theorem :: BINOM:17
for R being right_zeroed add-associative (non empty LoopStr),
    a being Element of R,
    n,m being Nat
holds a * (n + m) = a * n + a * m;

theorem :: BINOM:18
for R being left_zeroed right_zeroed add-associative (non empty LoopStr),
    a being Element of R,
    n being Nat
holds n * a = a * n;

theorem :: BINOM:19
  for R being Abelian (non empty LoopStr),
    a being Element of R,
    n being Nat
holds n * a = a * n;

theorem :: BINOM:20
for R being left_zeroed right_zeroed add-left-cancelable add-associative
            left-distributive (non empty doubleLoopStr),
    a,b being Element of R,
    n being Nat
holds (n * a) * b = n * (a * b);

theorem :: BINOM:21
for R being left_zeroed right_zeroed add-right-cancelable add-associative
            distributive (non empty doubleLoopStr),
    a,b being Element of R,
    n being Nat
holds b * (n * a) = (b * a) * n;

theorem :: BINOM:22
for R being left_zeroed right_zeroed add-associative
            add-cancelable distributive (non empty doubleLoopStr),
    a,b being Element of R,
    n being Nat
holds (a * n) * b = a * (n * b);


begin  ::  The Binomial Theorem
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::


definition
let k,n be Nat;
redefine func n choose k -> Nat;
end;


definition
let R be unital (non empty doubleLoopStr),
    a,b be Element of R,
    n be Nat;
func (a,b) In_Power n -> FinSequence of the carrier of R means
:: BINOM:def 10
   len it = n + 1 &
   for i,l,m being Nat st i in dom it & m = i - 1 & l = n - m
   holds it/.i = (n choose m) * a|^l * b|^m;
end;


theorem :: BINOM:23
for R being right_zeroed unital (non empty doubleLoopStr),
    a,b being Element of R
holds (a,b) In_Power 0 = <*1.R*>;

theorem :: BINOM:24
for R being right_zeroed unital (non empty doubleLoopStr),
    a,b being Element of R,
    n being Nat
holds ((a,b) In_Power n).1 = a|^n;

theorem :: BINOM:25
for R being right_zeroed unital (non empty doubleLoopStr),
    a,b being Element of R,
    n being Nat
holds ((a,b) In_Power n).(n+1) = b|^n;

theorem :: BINOM:26
  for R being Abelian add-associative left_zeroed right_zeroed
            commutative associative add-cancelable
            distributive unital (non empty doubleLoopStr),
    a,b being Element of R,
    n being Nat
holds (a+b)|^n = Sum((a,b) In_Power n);
