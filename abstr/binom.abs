:: The Binomial Theorem for Algebraic Structures
::  by Christoph Schwarzweller
::
:: Received November 20, 2000
:: Copyright (c) 2000 Association of Mizar Users

environ

 vocabularies RLVECT_1, ALGSTR_1, VECTSP_2, ARYTM_1, BINOP_1, LATTICES,
      GROUP_1, VECTSP_1, ALGSTR_2, FUNCT_1, FUNCT_2, MCART_1, RELAT_1,
      FINSEQ_1, FINSEQ_4, NEWTON, FINSEQ_2, BOOLE, BINOM, NAT_1;
 notations TARSKI, XBOOLE_0, ZFMISC_1, SUBSET_1, NUMBERS, XCMPLX_0, STRUCT_0,
      FINSEQ_1, FUNCT_1, FUNCT_2, NAT_1, FINSEQ_4, RELSET_1, BINOP_1, ALGSTR_1,
      FINSEQ_2, VECTSP_1, VECTSP_2, GROUP_1, NEWTON, RLVECT_1, MCART_1,
      POLYNOM1, XXREAL_0;
 constructors BINOP_1, XXREAL_0, REAL_1, NAT_1, NEWTON, ALGSTR_1, MONOID_0,
      POLYNOM1;
 registrations XBOOLE_0, ORDINAL1, RELSET_1, FUNCT_2, XXREAL_0, XREAL_0, NAT_1,
      MEMBERED, FINSEQ_2, STRUCT_0, VECTSP_1, ALGSTR_1, MONOID_0;
 requirements NUMERALS, SUBSET, REAL, BOOLE, ARITHM;


begin  :: Preliminaries
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

definition
  let L be non empty LoopStr;
 canceled 2;

attr L is add-cancelable means
:: BINOM:def 3
  for a,b,c being Element of L
  holds (a + b = a + c implies b = c) & (b + a = c + a implies b = c);
end;

registration
cluster add-left-cancelable (non empty LoopStr);
cluster add-right-cancelable (non empty LoopStr);
cluster add-cancelable (non empty LoopStr);
end;

registration
cluster add-left-cancelable add-right-cancelable ->
                     add-cancelable (non empty LoopStr);
cluster add-cancelable ->
           add-left-cancelable add-right-cancelable (non empty LoopStr);
end;

registration
cluster Abelian add-right-cancelable ->
  add-left-cancelable (non empty LoopStr);
cluster Abelian add-left-cancelable ->
            add-right-cancelable (non empty LoopStr);
end;

registration
cluster right_zeroed right_complementable add-associative ->
           add-right-cancelable (non empty LoopStr);
end;

registration
cluster Abelian add-associative left_zeroed right_zeroed
        commutative associative add-cancelable
        distributive unital (non empty doubleLoopStr);
end;

theorem :: BINOM:1
for R being right_zeroed add-left-cancelable
            left-distributive (non empty doubleLoopStr),
    a being Element of R
holds 0.R * a = 0.R;

theorem :: BINOM:2
for R being left_zeroed add-right-cancelable
            right-distributive (non empty doubleLoopStr),
    a being Element of R
holds a * 0.R = 0.R;

scheme :: BINOM:sch 1
 RecDef1 {C,D() -> non empty set,
                b() -> Element of D(),
                F() -> Function of [:C(),D():],D()} :
ex g being Function of [:NAT,C():],D() st
   for a being Element of C() holds g.(0,a) = b() &
   for n being Element of NAT holds g.(n+1,a) = F().(a,g.(n,a));

scheme :: BINOM:sch 2
 RecDef2 {C,D() -> non empty set,
                b() -> Element of D(),
                F() -> Function of [:D(),C():],D()} :
ex g being Function of [:C(),NAT:],D() st
   for a being Element of C() holds g.(a,0) = b() &
   for n being Element of NAT holds g.(a,n+1) = F().(g.(a,n),a);

begin  ::  On Finite Sequences
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

theorem :: BINOM:3
for L being left_zeroed (non empty LoopStr),
    a being Element of L
holds Sum <* a *> = a;

theorem :: BINOM:4
   for R being left_zeroed add-right-cancelable
            right-distributive (non empty doubleLoopStr),
    a being Element of R,
    p being FinSequence of the carrier of R
holds Sum(a * p) = a * Sum p;

theorem :: BINOM:5
for R being right_zeroed add-left-cancelable
            left-distributive (non empty doubleLoopStr),
    a being Element of R,
    p being FinSequence of the carrier of R
holds Sum(p * a) = Sum p * a;

theorem :: BINOM:6
   for R being commutative (non empty doubleLoopStr),
    a being Element of R,
    p being FinSequence of the carrier of R
holds Sum(p * a) = Sum(a * p);

definition
let R be non empty LoopStr,
    p,q be FinSequence of the carrier of R such that dom p = dom q;
func p + q -> FinSequence of the carrier of R means
:: BINOM:def 4
  dom it = dom p &
  for i being Element of NAT st 1 <= i & i <= len it holds it/.i = p/.i + q/.i;
end;

theorem :: BINOM:7
for R being Abelian right_zeroed add-associative (non empty LoopStr),
    p,q being FinSequence of the carrier of R st dom p = dom q
holds Sum(p + q) = Sum p + Sum q;

begin  ::  On Powers in Rings
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

definition
let R be unital (non empty HGrStr),
    a be Element of R,
    n be Element of NAT;
func a|^n -> Element of R equals
:: BINOM:def 5
  power(R).(a,n);
end;

theorem :: BINOM:8
for R being unital (non empty HGrStr),
    a being Element of R
holds a|^0 = 1_R & a|^1 = a;

canceled;

theorem :: BINOM:10
   for R being unital associative commutative (non empty HGrStr),
    a,b being Element of R,
    n being Element of NAT
holds (a * b)|^n = (a|^n) * (b|^n);

theorem :: BINOM:11
for R being unital associative (non empty HGrStr),
    a being Element of R,
    n,m being Element of NAT
holds a|^(n+m) = (a|^n) * (a|^m);

theorem :: BINOM:12
   for R being unital associative (non empty HGrStr),
    a being Element of R,
    n,m being Element of NAT
holds (a|^n)|^m = a|^(n * m);

begin  ::  On Element of NATural Products in Rings
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

definition
let R be non empty LoopStr;
func Nat-mult-left(R)
        -> Function of [:NAT,the carrier of R:],the carrier of R means
:: BINOM:def 6
  for a being Element of R
  holds it.(0,a) = 0.R &
        for n being Element of NAT holds it.(n+1,a) = a + it.(n,a);
func Nat-mult-right(R)
        -> Function of [:the carrier of R,NAT:],the carrier of R means
:: BINOM:def 7
  for a being Element of R
  holds it.(a,0) = 0.R &
        for n being Element of NAT holds it.(a,n+1) = it.(a,n) + a;
end;

definition
let R be non empty LoopStr,
    a be Element of R,
    n be Element of NAT;
func n * a -> Element of R equals
:: BINOM:def 8
  (Nat-mult-left(R)).(n,a);
func a * n -> Element of R equals
:: BINOM:def 9
  (Nat-mult-right(R)).(a,n);
end;

theorem :: BINOM:13
for R being non empty LoopStr,
    a being Element of R
holds 0 * a = 0.R & a * 0 = 0.R;

theorem :: BINOM:14
for R being right_zeroed (non empty LoopStr),
    a being Element of R
holds 1 * a = a;

theorem :: BINOM:15
for R being left_zeroed (non empty LoopStr),
    a being Element of R
holds a * 1 = a;

theorem :: BINOM:16
for R being left_zeroed add-associative (non empty LoopStr),
    a being Element of R,
    n,m being Element of NAT
holds (n + m) * a = n * a + m * a;

theorem :: BINOM:17
for R being right_zeroed add-associative (non empty LoopStr),
    a being Element of R,
    n,m being Element of NAT
holds a * (n + m) = a * n + a * m;

theorem :: BINOM:18
for R being left_zeroed right_zeroed add-associative (non empty LoopStr),
    a being Element of R,
    n being Element of NAT
holds n * a = a * n;

theorem :: BINOM:19
   for R being Abelian (non empty LoopStr),
    a being Element of R,
    n being Element of NAT
holds n * a = a * n;

theorem :: BINOM:20
for R being left_zeroed right_zeroed add-left-cancelable add-associative
            left-distributive (non empty doubleLoopStr),
    a,b being Element of R,
    n being Element of NAT
holds (n * a) * b = n * (a * b);

theorem :: BINOM:21
for R being left_zeroed right_zeroed add-right-cancelable add-associative
            distributive (non empty doubleLoopStr),
    a,b being Element of R,
    n being Element of NAT
holds b * (n * a) = (b * a) * n;

theorem :: BINOM:22
for R being left_zeroed right_zeroed add-associative
            add-cancelable distributive (non empty doubleLoopStr),
    a,b being Element of R,
    n being Element of NAT
holds (a * n) * b = a * (n * b);

begin  ::  The Binomial Theorem
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

definition
let k,n be Element of NAT;
redefine func n choose k -> Element of NAT;
end;

definition
let R be unital (non empty doubleLoopStr),
    a,b be Element of R,
    n be Element of NAT;
func (a,b) In_Power n -> FinSequence of the carrier of R means
:: BINOM:def 10
   len it = n + 1 &
   for i,l,m being Element of NAT st i in dom it & m = i - 1 & l = n - m
   holds it/.i = (n choose m) * a|^l * b|^m;
end;

theorem :: BINOM:23
for R being right_zeroed unital (non empty doubleLoopStr),
    a,b being Element of R
holds (a,b) In_Power 0 = <*1_R*>;

theorem :: BINOM:24
for R being right_zeroed unital (non empty doubleLoopStr),
    a,b being Element of R,
    n being Element of NAT
holds ((a,b) In_Power n).1 = a|^n;

theorem :: BINOM:25
for R being right_zeroed unital (non empty doubleLoopStr),
    a,b being Element of R,
    n being Element of NAT
holds ((a,b) In_Power n).(n+1) = b|^n;

theorem :: BINOM:26
   for R being Abelian add-associative left_zeroed right_zeroed
            commutative associative add-cancelable
            distributive unital (non empty doubleLoopStr),
    a,b being Element of R,
    n being Element of NAT
holds (a+b)|^n = Sum((a,b) In_Power n);
