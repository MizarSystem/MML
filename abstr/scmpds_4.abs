:: The Construction and shiftability of Program Blocks for SCMPDS
::  by JingChao Chen
::
:: Received June 15, 1999
:: Copyright (c) 1999 Association of Mizar Users

environ

 vocabularies NUMBERS, SUBSET_1, AMI_1, SCMPDS_2, SCMFSA_7, CARD_1, FUNCOP_1,
      RELAT_1, FUNCT_1, CAT_1, NAT_1, ARYTM_3, XBOOLE_0, TARSKI, VALUED_1,
      SCMNORM, FSM_1, INT_1, SCMFSA6A, FUNCT_4, GRAPHSP, AMI_3, FUNCT_7, AMI_2,
      STRUCT_0, SCMPDS_1, COMPLEX1, XXREAL_0, ARYTM_1, TURING_1, AMISTD_2,
      SCMFSA6B, MSUALG_1, CIRCUIT2, GLIB_000, SCMPDS_4, ORDINAL1, PARTFUN1,
      AFINSQ_1;
 notations TARSKI, XBOOLE_0, ENUMSET1, SUBSET_1, CARD_1, NUMBERS, XCMPLX_0,
      RELAT_1, FUNCT_1, PARTFUN1, AFINSQ_1, VALUED_1, FUNCT_4, FUNCT_7, INT_1,
      NAT_1, INT_2, XXREAL_0, STRUCT_0, AMI_1, SCMNORM, AMI_2, AMI_3, SCMPDS_1,
      SCMPDS_2, SCMPDS_3;
 constructors WELLORD2, XXREAL_0, NAT_1, INT_2, AMI_5, SCMPDS_1, SCMPDS_3,
      DOMAIN_1, SCMNORM, AFINSQ_1, RELSET_1, PRE_POLY, PBOOLE;
 registrations XBOOLE_0, SUBSET_1, SETFAM_1, FUNCT_1, ORDINAL1, RELSET_1,
      NUMBERS, XXREAL_0, XREAL_0, NAT_1, INT_1, CARD_3, AMI_1, SCMPDS_2, AMI_2,
      SCMNORM, FINSET_1, CARD_1, VALUED_1, FUNCT_4, RELAT_1, PRE_POLY,
      AFINSQ_1;
 requirements REAL, NUMERALS, SUBSET, BOOLE, ARITHM;


begin :: Definition of a program block and its basic properties

reserve l, m, n for Element of NAT,
  i,j,k for Instruction of SCMPDS,
  I,J,K for Program of SCMPDS;

definition
  let i;
  func Load i -> preProgram of SCMPDS equals
:: SCMPDS_4:def 1
    <%i%>;
end;

registration
  let i;
  cluster Load i -> non empty initial;
end;

canceled;

theorem :: SCMPDS_4:2
  dom I misses dom Shift(J,card I);

theorem :: SCMPDS_4:3
  for I being preProgram of SCMPDS holds card Shift(I,m) = card I;

reserve a,b,c for Int_position,
  s,s1,s2 for State of SCMPDS,
  k1,k2 for Integer;

definition
  let I;
  func Initialized I -> FinPartState of SCMPDS equals
:: SCMPDS_4:def 2
  I +* Start-At( 0,SCMPDS);
end;

canceled 2;

theorem :: SCMPDS_4:6
  InsCode i in {0,1,4,5,6} or Exec(i,s).IC SCMPDS = succ IC s;

theorem :: SCMPDS_4:7
  IC SCMPDS in dom Initialized I;

theorem :: SCMPDS_4:8
  IC Initialized I =  0;

theorem :: SCMPDS_4:9
  I c= Initialized I;

canceled;

theorem :: SCMPDS_4:11
  for s1,s2 being State of SCMPDS st IC s1 = IC s2 & for a being
  Int_position holds s1.a = s2.a holds s1,s2 equal_outside NAT;

canceled;

theorem :: SCMPDS_4:13
  s1,s2 equal_outside NAT implies for a being Int_position holds
  s1.a = s2.a;

theorem :: SCMPDS_4:14
  s1,s2 equal_outside NAT implies s1.DataLoc(s1.a,k1)=s2.DataLoc(
  s2.a,k1);

theorem :: SCMPDS_4:15
  s1,s2 equal_outside NAT implies Exec(i,s1),Exec(i,s2)
  equal_outside NAT;

theorem :: SCMPDS_4:16
  (Initialized I)|NAT = I;

theorem :: SCMPDS_4:17
  for k1,k2 be Element of NAT st k1 <> k2 holds DataLoc(k1,0) <>
  DataLoc(k2,0);

theorem :: SCMPDS_4:18
  for dl being Int_position ex i being Element of NAT st dl =
  DataLoc(i,0);

scheme :: SCMPDS_4:sch 1

  SCMPDSEx{ F(set) -> Instruction of SCMPDS, G(set) -> Integer, I() ->
  Element of NAT }: ex S being State of SCMPDS st IC S = I() &
  for i being Element of NAT holds S. i = F(i) & S.DataLoc(i,0) = G(i);

theorem :: SCMPDS_4:19
  for s being State of SCMPDS holds dom s = {IC SCMPDS} \/ SCM-Data-Loc
  \/ NAT;

theorem :: SCMPDS_4:20
  for s being State of SCMPDS, x being set st x in dom s holds x is
  Int_position or x = IC SCMPDS or x is Element of NAT;

theorem :: SCMPDS_4:21
  for s1,s2 being State of SCMPDS holds (for l being
  Element of NAT holds s1.l = s2.l) iff s1 | NAT = s2 | NAT;

theorem :: SCMPDS_4:22
  for i being Element of NAT holds not i in SCM-Data-Loc;

theorem :: SCMPDS_4:23
  for s1,s2 being State of SCMPDS holds (for a being Int_position
  holds s1.a = s2.a) iff DataPart s1 = DataPart s2;

theorem :: SCMPDS_4:24
  for s1,s2 being State of SCMPDS st s1,s2 equal_outside NAT holds
  DataPart s1 = DataPart s2;

canceled;

theorem :: SCMPDS_4:26
  for I,J being Program of SCMPDS holds I,J equal_outside NAT;

theorem :: SCMPDS_4:27
  for I being Program of SCMPDS holds dom Initialized I = dom I \/
  {IC SCMPDS};

theorem :: SCMPDS_4:28
  for I being Program of SCMPDS, x being set st x in dom
  Initialized I holds x in dom I or x = IC SCMPDS;

theorem :: SCMPDS_4:29
  for I being Program of SCMPDS holds (Initialized I).IC SCMPDS =
   0;

canceled;

theorem :: SCMPDS_4:31
  for I being Program of SCMPDS, a being Int_position holds not a
  in dom Initialized I;

reserve x for set;

theorem :: SCMPDS_4:32
  x in dom I implies I.x = (I +* Start-At(n,SCMPDS)).x;

theorem :: SCMPDS_4:33
  for I being Program of SCMPDS, x being set st x in dom I holds I.x = (
  Initialized I).x;

theorem :: SCMPDS_4:34
  for I,J being Program of SCMPDS for s being State of SCMPDS st
  Initialized J c= s holds s +* Initialized I = s +* I;

theorem :: SCMPDS_4:35
  for I,J being Program of SCMPDS for s being State of SCMPDS st
  Initialized J c= s holds Initialized I c= s +* I;

theorem :: SCMPDS_4:36
  for I,J being Program of SCMPDS for s being State of SCMPDS holds s +*
  Initialized I, s +* Initialized J equal_outside NAT;

begin :: Combining two consecutive blocks into one program block

definition
  let I,J be Program of SCMPDS;
  func I ';' J -> Program of SCMPDS equals
:: SCMPDS_4:def 3
  I +* Shift(J, card I);
end;

theorem :: SCMPDS_4:37
  for I,J being Program of SCMPDS, l being Element of NAT
  st l in dom I holds (I ';' J).l = I.l;

theorem :: SCMPDS_4:38
  for I,J being Program of SCMPDS, l being Element of NAT
  st l in dom J holds (I ';' J).(l+card I)= J.l;

theorem :: SCMPDS_4:39
  for I,J being Program of SCMPDS holds dom I c= dom (I ';' J);

theorem :: SCMPDS_4:40
  for I,J being Program of SCMPDS holds I c= I ';' J;

theorem :: SCMPDS_4:41
  for I,J being Program of SCMPDS holds I +* (I ';' J) = (I ';' J);

theorem :: SCMPDS_4:42
  for I,J being Program of SCMPDS holds Initialized I +* (I ';' J) =
  Initialized (I ';' J);

begin :: Combining a block and a instruction into one program block

definition
  let i, J;
  func i ';' J -> Program of SCMPDS equals
:: SCMPDS_4:def 4
  Load i ';' J;
end;

definition
  let I, j;
  func I ';' j -> Program of SCMPDS equals
:: SCMPDS_4:def 5
  I ';' Load j;
end;

definition
  let i,j;
  func i ';' j -> Program of SCMPDS equals
:: SCMPDS_4:def 6
  Load i ';' Load j;
end;

theorem :: SCMPDS_4:43
  i ';' j = Load i ';' j;

theorem :: SCMPDS_4:44
  i ';' j = i ';' Load j;

theorem :: SCMPDS_4:45
  card(I ';' J) = card I + card J;

theorem :: SCMPDS_4:46
  I ';' J ';' K = I ';' (J ';' K);

theorem :: SCMPDS_4:47
  I ';' J ';' k = I ';' (J ';' k);

theorem :: SCMPDS_4:48
  I ';' j ';' K = I ';' (j ';' K);

theorem :: SCMPDS_4:49
  I ';' j ';' k = I ';' (j ';' k);

theorem :: SCMPDS_4:50
  i ';' J ';' K = i ';' (J ';' K);

theorem :: SCMPDS_4:51
  i ';' J ';' k = i ';' (J ';' k);

theorem :: SCMPDS_4:52
  i ';' j ';' K = i ';' (j ';' K);

theorem :: SCMPDS_4:53
  i ';' j ';' k = i ';' (j ';' k);

theorem :: SCMPDS_4:54
  dom I misses dom Start-At(n,SCMPDS);

canceled;

theorem :: SCMPDS_4:56
  I +* Start-At(n,SCMPDS) c= s implies I c= s;

theorem :: SCMPDS_4:57
  Initialized I c= s implies I c= s;

theorem :: SCMPDS_4:58
  (I +* Start-At(n,SCMPDS))|NAT = I;

reserve l,l1,loc for Element of NAT;

theorem :: SCMPDS_4:59
  not a in dom Start-At(l,SCMPDS);

canceled;

theorem :: SCMPDS_4:61
  not a in dom (I+*Start-At(l,SCMPDS));

theorem :: SCMPDS_4:62
  s+*I+*Start-At( 0,SCMPDS) = s+*Start-At( 0,SCMPDS)+*I;

definition
  let s be State of SCMPDS, li be Int_position, k be Integer;
  redefine func s+*(li,k) -> PartState of SCMPDS;
end;

begin :: The notions of paraclosed,parahalting and their basic properties

definition
  let I be Program of SCMPDS;
  func stop(I) -> Program of SCMPDS equals
:: SCMPDS_4:def 7
  I ';' Stop SCMPDS;
end;

definition
  let I be Program of SCMPDS, s be State of SCMPDS;
  func IExec(I,s) -> State of SCMPDS equals
:: SCMPDS_4:def 8
  Result(ProgramPart(s+*Initialized stop(I)),s+*Initialized stop(I)) +*
  s|NAT;
end;

definition
  let I be Program of SCMPDS;
  attr I is paraclosed means
:: SCMPDS_4:def 9

  for s being State of SCMPDS, n being
  Element of NAT st Initialized stop(I) c= s holds IC Comput(ProgramPart(s),s,n
) in dom
  stop(I);
  attr I is parahalting means
:: SCMPDS_4:def 10

  Initialized stop(I) is halting;
end;

registration
  cluster parahalting Program of SCMPDS;
end;

theorem :: SCMPDS_4:63
  for I being parahalting Program of SCMPDS st Initialized stop I
  c= s holds ProgramPart s halts_on s;

registration
  let I be parahalting Program of SCMPDS;
  cluster Initialized stop(I) -> halting;
end;

definition
  let la,lb be Element of NAT;
  let a, b be Instruction of SCMPDS;
  redefine func (la,lb) --> (a,b) -> FinPartState of SCMPDS;
end;

canceled 2;

theorem :: SCMPDS_4:66
  not ProgramPart(s2 +*((IC s2,succ IC s2) --> (goto 1, goto -1)))
    halts_on s2 +*((IC s2,succ IC s2) --> (goto 1, goto -1));

theorem :: SCMPDS_4:67
  s1,s2 equal_outside NAT & I c= s1 & I c= s2 & (for m st m < n
  holds IC (Comput(ProgramPart(s2),s2,m)) in dom I) implies for m st m <= n
holds
  Comput(ProgramPart(s1),s1,m), Comput(ProgramPart(s2),s2,m) equal_outside NAT;

theorem :: SCMPDS_4:68
  for s being State of SCMPDS,l being Element of NAT
  holds l in dom s;

reserve l1,l2 for Element of NAT,
  i1,i2 for Instruction of
  SCMPDS;

theorem :: SCMPDS_4:69
  s +*((l1,l2) --> (i1, i2)) = s +* (l1,i1) +* (l2,i2);

canceled;

theorem :: SCMPDS_4:71
  not IC s in dom I implies not succ IC s in dom I;

registration
  cluster parahalting -> paraclosed Program of SCMPDS;
end;

canceled 3;

theorem :: SCMPDS_4:75
   0 in dom stop (I);

begin :: Shiftability of program blocks and instructions

definition
  let i be Instruction of SCMPDS;
  let n be Element of NAT;
  pred i valid_at n means
:: SCMPDS_4:def 11

  (InsCode i= 0 implies ex k1 st i = goto k1 &
  n+k1 >= 0) & (InsCode i= 4 implies ex a,k1,k2 st i = (a,k1)<>0_goto k2 & n+k2
>= 0 ) & (InsCode i= 5 implies ex a,k1,k2 st i = (a,k1)<=0_goto k2 & n+k2 >= 0
  ) & (InsCode i= 6 implies ex a,k1,k2 st i = (a,k1)>=0_goto k2 & n+k2 >= 0);
end;

reserve l for Element of NAT;

canceled;

theorem :: SCMPDS_4:77
  for i be Instruction of SCMPDS,m,n be Element of NAT st i
  valid_at m & m <= n holds i valid_at n;

definition
  let IT be FinPartState of SCMPDS;
  attr IT is shiftable means
:: SCMPDS_4:def 12

  for n,i st  n in dom IT & i=IT.(
   n) holds InsCode i <> 1 & InsCode i <> 3 & i valid_at n;
end;

registration
  cluster parahalting shiftable Program of SCMPDS;
end;

definition
  let i be Instruction of SCMPDS;
  attr i is shiftable means
:: SCMPDS_4:def 13

  InsCode i = 2 or InsCode i > 6;
end;

registration
  cluster shiftable Instruction of SCMPDS;
end;

registration
  let a,k1;
  cluster a := k1 -> shiftable;
end;

registration
  let a,k1,k2;
  cluster (a,k1) := k2 -> shiftable;
end;

registration
  let a,k1,k2;
  cluster AddTo(a,k1,k2) -> shiftable;
end;

registration
  let a,b,k1,k2;
  cluster AddTo(a,k1,b,k2) -> shiftable;
  cluster SubFrom(a,k1,b,k2) -> shiftable;
  cluster MultBy(a,k1,b,k2) -> shiftable;
  cluster Divide(a,k1,b,k2) -> shiftable;
  cluster (a,k1) := (b,k2) -> shiftable;
end;

registration
  let I,J be shiftable Program of SCMPDS;
  cluster I ';' J -> shiftable;
end;

registration
  let i be shiftable Instruction of SCMPDS;
  cluster Load i -> shiftable;
end;

registration
  let i be shiftable Instruction of SCMPDS, J be shiftable Program of SCMPDS;
  cluster i ';' J -> shiftable;
end;

registration
  let I be shiftable Program of SCMPDS, j be shiftable Instruction of SCMPDS;
  cluster I ';' j -> shiftable;
end;

registration
  let i,j be shiftable Instruction of SCMPDS;
  cluster i ';' j -> shiftable;
end;

registration
  cluster Stop SCMPDS -> parahalting shiftable;
end;

registration
  let I be shiftable Program of SCMPDS;
  cluster stop I -> shiftable;
end;

theorem :: SCMPDS_4:78
  for I being shiftable Program of SCMPDS,k1 be Integer st card I + k1
  >= 0 holds I ';' goto k1 is shiftable;

registration
  let n be Element of NAT;
  cluster Load goto n -> shiftable;
end;

theorem :: SCMPDS_4:79
  for I being shiftable Program of SCMPDS,k1,k2 be Integer,a be
  Int_position st card I + k2 >= 0 holds I ';' (a,k1)<>0_goto k2 is shiftable;

registration
  let k1 be Integer,a be Int_position,n be Element of NAT;
  cluster Load (a,k1)<>0_goto n -> shiftable;
end;

theorem :: SCMPDS_4:80
  for I being shiftable Program of SCMPDS,k1,k2 be Integer,a be
  Int_position st card I + k2 >= 0 holds I ';' (a,k1)<=0_goto k2 is shiftable;

registration
  let k1 be Integer,a be Int_position,n be Element of NAT;
  cluster Load (a,k1)<=0_goto n -> shiftable;
end;

theorem :: SCMPDS_4:81
  for I being shiftable Program of SCMPDS,k1,k2 be Integer,a be
  Int_position st card I + k2 >= 0 holds I ';' (a,k1)>=0_goto k2 is shiftable;

registration
  let k1 be Integer,a be Int_position,n be Element of NAT;
  cluster Load (a,k1)>=0_goto n -> shiftable;
end;

theorem :: SCMPDS_4:82
  for s1,s2 being State of SCMPDS, n,m being Element of NAT,k1 be
Integer st IC s1= m & m+k1>=0 & IC s1 + n = IC s2 holds ICplusConst(s1,k1
  ) +n = ICplusConst(s2,k1);

theorem :: SCMPDS_4:83
  for s1,s2 being State of SCMPDS, n,m being Element of NAT, i
being Instruction of SCMPDS holds IC s1= m & i valid_at m & InsCode i <>
  1 & InsCode i <> 3 & IC s1 + n = IC s2 & DataPart s1 = DataPart s2 implies IC
  Exec(i,s1) + n = IC Exec(i,s2) & DataPart Exec(i,s1) = DataPart Exec(i,s2);

theorem :: SCMPDS_4:84
  for J being parahalting shiftable Program of SCMPDS st Initialized
  stop J c= s1 for n being Element of NAT st Shift(stop J,n) c= s2 & IC s2 =
   n & DataPart s1 = DataPart s2 for i being Element of NAT holds IC
  Comput(ProgramPart(s1),s1,i) + n = IC Comput(ProgramPart(s2),s2,i) &
   CurInstr(ProgramPart Comput(ProgramPart(s1),s1,i),Comput(ProgramPart(s1),s1,
i)) =
  CurInstr(ProgramPart Comput(ProgramPart(s2),s2,i),Comput(ProgramPart(s2),s2,i
)) &
  DataPart Comput(ProgramPart(s1),s1,i) = DataPart
  Comput(ProgramPart(s2),s2,i);

