:: The Construction and shiftability of Program Blocks for SCMPDS
::  by JingChao Chen
::
:: Received June 15, 1999
:: Copyright (c) 1999-2011 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies NUMBERS, SUBSET_1, AMI_1, SCMPDS_2, SCMFSA_7, CARD_1, FUNCOP_1,
      RELAT_1, FUNCT_1, NAT_1, ARYTM_3, XBOOLE_0, TARSKI, VALUED_1, SCMNORM,
      FSM_1, INT_1, FUNCT_4, GRAPHSP, AMI_3, AMI_2, STRUCT_0, SCMPDS_1,
      COMPLEX1, XXREAL_0, ARYTM_1, TURING_1, AMISTD_2, SCMFSA6B, MSUALG_1,
      CIRCUIT2, SCMPDS_4, ORDINAL1, PARTFUN1, SCMFSA6C, ORDINAL4, PBOOLE;
 notations TARSKI, XBOOLE_0, ENUMSET1, SUBSET_1, CARD_1, NUMBERS, XCMPLX_0,
      RELAT_1, FUNCT_1, PARTFUN1, AFINSQ_1, VALUED_1, FUNCT_4, FUNCT_7, INT_1,
      NAT_1, INT_2, XXREAL_0, PBOOLE, STRUCT_0, COMPOS_1, EXTPRO_1, AMI_2,
      AMISTD_2, SCMPDS_1, SCMPDS_2;
 constructors WELLORD2, XXREAL_0, INT_2, SCMPDS_1, SCMPDS_3, DOMAIN_1,
      RELSET_1, PRE_POLY, ORDINAL5, AMI_3, AMISTD_2, AMISTD_1;
 registrations XBOOLE_0, SETFAM_1, FUNCT_1, ORDINAL1, NUMBERS, XXREAL_0,
      XREAL_0, NAT_1, INT_1, SCMPDS_2, AMI_2, FINSET_1, CARD_1, VALUED_1,
      FUNCT_4, RELAT_1, PRE_POLY, AFINSQ_1, COMPOS_1, ORDINAL5, EXTPRO_1,
      FUNCOP_1, FUNCT_7, SCMPDS_3, AMISTD_2, PBOOLE;
 requirements REAL, NUMERALS, SUBSET, BOOLE, ARITHM;


begin :: Definition of a program block and its basic properties

reserve l, m, n for Element of NAT,
  i,j,k for Instruction of SCMPDS,
  I,J,K for Program of SCMPDS,
  p,q,r for PartState of SCMPDS;

reserve a,b,c for Int_position,
  s,s1,s2 for State of SCMPDS,
  k1,k2 for Integer;

canceled 5;

theorem :: SCMPDS_4:6
  InsCode i in {0,1,4,5,6} or Exec(i,s).IC SCMPDS = succ IC s;

canceled 4;

theorem :: SCMPDS_4:11
  for s1,s2 being State of SCMPDS st IC s1 = IC s2 & for a being
  Int_position holds s1.a = s2.a holds NPP s1 = NPP s2;

canceled;

theorem :: SCMPDS_4:13
  NPP s1 = NPP s2 implies for a being Int_position holds
  s1.a = s2.a;

theorem :: SCMPDS_4:14
  NPP s1 = NPP s2 implies s1.DataLoc(s1.a,k1)=s2.DataLoc(s2.a,k1);

theorem :: SCMPDS_4:15
  NPP s1 = NPP s2 implies NPP Exec(i,s1) = NPP Exec(i,s2);

registration
 cluster SCMPDS -> Exec-preserving;
end;

canceled;

theorem :: SCMPDS_4:17
  for k1,k2 be Element of NAT st k1 <> k2 holds DataLoc(k1,0) <>
  DataLoc(k2,0);

theorem :: SCMPDS_4:18
  for dl being Int_position ex i being Element of NAT st dl =
  DataLoc(i,0);

scheme :: SCMPDS_4:sch 1

  SCMPDSEx{ F(set) -> Instruction of SCMPDS, G(set) -> Integer, I() ->
  Element of NAT }: ex S being State of SCMPDS st IC S = I() &
  for i being Element of NAT holds S. i = F(i) & S.DataLoc(i,0) = G(i);

theorem :: SCMPDS_4:19
  for s being State of SCMPDS holds dom s = {IC SCMPDS} \/ SCM-Data-Loc
  \/ NAT;

theorem :: SCMPDS_4:20
  for s being State of SCMPDS, x being set st x in dom s holds x is
  Int_position or x = IC SCMPDS or x is Element of NAT;

canceled;

theorem :: SCMPDS_4:22
  for i being Element of NAT holds not i in SCM-Data-Loc;

theorem :: SCMPDS_4:23
  for s1,s2 being State of SCMPDS holds (for a being Int_position
  holds s1.a = s2.a) iff DataPart s1 = DataPart s2;

canceled 7;

theorem :: SCMPDS_4:31
  for I being Program of SCMPDS, a being Int_position holds not a
  in dom Initialize I;

reserve x for set;

begin :: Combining two consecutive blocks into one program block

notation
  let I,J be Program of SCMPDS;
  synonym I ';' J for I ^ J;
end;

definition
 canceled 2;
  let I,J be Program of SCMPDS;
  redefine func I ';' J -> Program of SCMPDS equals
:: SCMPDS_4:def 3
  I +* Shift(J, card I);
end;

begin :: Combining a block and a instruction into one program block

definition
  let i, J;
  func i ';' J -> Program of SCMPDS equals
:: SCMPDS_4:def 4
  Load i ';' J;
end;

definition
  let I, j;
  func I ';' j -> Program of SCMPDS equals
:: SCMPDS_4:def 5
  I ';' Load j;
end;

definition
  let i,j;
  func i ';' j -> Program of SCMPDS equals
:: SCMPDS_4:def 6
  Load i ';' Load j;
end;

canceled 11;

theorem :: SCMPDS_4:43
  i ';' j = Load i ';' j;

theorem :: SCMPDS_4:44
  i ';' j = i ';' Load j;

canceled 2;

theorem :: SCMPDS_4:47
  I ';' J ';' k = I ';' (J ';' k);

theorem :: SCMPDS_4:48
  I ';' j ';' K = I ';' (j ';' K);

theorem :: SCMPDS_4:49
  I ';' j ';' k = I ';' (j ';' k);

theorem :: SCMPDS_4:50
  i ';' J ';' K = i ';' (J ';' K);

theorem :: SCMPDS_4:51
  i ';' J ';' k = i ';' (J ';' k);

theorem :: SCMPDS_4:52
  i ';' j ';' K = i ';' (j ';' K);

theorem :: SCMPDS_4:53
  i ';' j ';' k = i ';' (j ';' k);

canceled 5;

reserve l,l1,loc for Element of NAT;

theorem :: SCMPDS_4:59
  not a in dom Start-At(l,SCMPDS);

canceled;

theorem :: SCMPDS_4:61
  not a in dom (I+*Start-At(l,SCMPDS));

definition
  let s be State of SCMPDS, li be Int_position, k be Integer;
  redefine func s+*(li,k) -> PartState of SCMPDS;
end;

begin :: The notions of paraclosed,parahalting and their basic properties

registration
  let s be State of SCMPDS;
  cluster Initialize s -> total;
end;

definition
 canceled;
  let I be Program of SCMPDS, s be State of SCMPDS;
  let P be (the Instructions of SCMPDS)-valued ManySortedSet of NAT;
  func IExec(I,P,s) -> State of SCMPDS equals
:: SCMPDS_4:def 8
  Result(P+*stop I,Initialize s) +* s|NAT;
end;

definition
  let I be Program of SCMPDS;
  attr I is paraclosed means
:: SCMPDS_4:def 9

  for s being 0-started State of SCMPDS, n being Element of NAT,
      P being (the Instructions of SCMPDS)-valued ManySortedSet of NAT
    st stop I c= P
   holds IC Comput(P,s,n) in dom stop(I);
  attr I is parahalting means
:: SCMPDS_4:def 10

  for s being 0-started State of SCMPDS,
      P being (the Instructions of SCMPDS)-valued ManySortedSet of NAT
    st stop I c= P
    holds P halts_on s;
end;

registration
  cluster parahalting Program of SCMPDS;
end;

definition
  let la,lb be Element of NAT;
  let a, b be Instruction of SCMPDS;
  redefine func (la,lb) --> (a,b) -> FinPartState of SCMPDS;
end;

canceled 4;

theorem :: SCMPDS_4:66
 for P,Q being (the Instructions of SCMPDS)-valued ManySortedSet of NAT
  st Q = P +*((IC s,succ IC s) --> (goto 1, goto -1))
 holds
  not Q halts_on s;

theorem :: SCMPDS_4:67
 for P1,P2 being (the Instructions of SCMPDS)-valued ManySortedSet of NAT
  st NPP s1 = NPP s2 & I c= P1 & I c= P2 & (for m st m < n
  holds IC (Comput(P2,s2,m)) in dom I)
 for m st m <= n
holds
  NPP Comput(P1,s1,m) = NPP Comput(P2,s2,m);

reserve l1,l2 for Element of NAT,
  i1,i2 for Instruction of SCMPDS;

registration
  cluster parahalting -> paraclosed Program of SCMPDS;
end;

begin :: Shiftability of program blocks and instructions

definition
  let i be Instruction of SCMPDS;
  let n be Element of NAT;
  pred i valid_at n means
:: SCMPDS_4:def 11

  (InsCode i= 0 implies ex k1 st i = goto k1 &
  n+k1 >= 0) & (InsCode i= 4 implies ex a,k1,k2 st i = (a,k1)<>0_goto k2 & n+k2
>= 0 ) & (InsCode i= 5 implies ex a,k1,k2 st i = (a,k1)<=0_goto k2 & n+k2 >= 0
  ) & (InsCode i= 6 implies ex a,k1,k2 st i = (a,k1)>=0_goto k2 & n+k2 >= 0);
end;

reserve l for Element of NAT;

definition
  let IT be FinPartState of SCMPDS;
  attr IT is shiftable means
:: SCMPDS_4:def 12

  for n,i st  n in dom IT & i=IT.(n)
   holds InsCode i <> 1 & InsCode i <> 3 & i valid_at n;
end;

canceled 9;

theorem :: SCMPDS_4:77
  for i be Instruction of SCMPDS,m,n be Element of NAT st i
  valid_at m & m <= n holds i valid_at n;

registration
  cluster parahalting shiftable Program of SCMPDS;
end;

definition
  let i be Instruction of SCMPDS;
  attr i is shiftable means
:: SCMPDS_4:def 13

  InsCode i = 2 or InsCode i > 6;
end;

registration
  cluster shiftable Instruction of SCMPDS;
end;

registration
  let a,k1;
  cluster a := k1 -> shiftable;
end;

registration
  let a,k1,k2;
  cluster (a,k1) := k2 -> shiftable;
end;

registration
  let a,k1,k2;
  cluster AddTo(a,k1,k2) -> shiftable;
end;

registration
  let a,b,k1,k2;
  cluster AddTo(a,k1,b,k2) -> shiftable;
  cluster SubFrom(a,k1,b,k2) -> shiftable;
  cluster MultBy(a,k1,b,k2) -> shiftable;
  cluster Divide(a,k1,b,k2) -> shiftable;
  cluster (a,k1) := (b,k2) -> shiftable;
end;

registration
  let I,J be shiftable Program of SCMPDS;
  cluster I ';' J -> shiftable Program of SCMPDS;
end;

registration
  let i be shiftable Instruction of SCMPDS;
  cluster Load i -> shiftable Program of SCMPDS;
end;

registration
  let i be shiftable Instruction of SCMPDS, J be shiftable Program of SCMPDS;
  cluster i ';' J -> shiftable;
end;

registration
  let I be shiftable Program of SCMPDS, j be shiftable Instruction of SCMPDS;
  cluster I ';' j -> shiftable;
end;

registration
  let i,j be shiftable Instruction of SCMPDS;
  cluster i ';' j -> shiftable;
end;

registration
  cluster Stop SCMPDS -> parahalting shiftable;
end;

registration
  let I be shiftable Program of SCMPDS;
  cluster stop I -> shiftable;
end;

theorem :: SCMPDS_4:78
  for I being shiftable Program of SCMPDS,k1 be Integer st card I + k1
  >= 0 holds I ';' goto k1 is shiftable;

registration
  let n be Element of NAT;
  cluster Load goto n -> shiftable Program of SCMPDS;
end;

theorem :: SCMPDS_4:79
  for I being shiftable Program of SCMPDS,k1,k2 be Integer,a be
  Int_position st card I + k2 >= 0 holds I ';' (a,k1)<>0_goto k2 is shiftable;

registration
  let k1 be Integer,a be Int_position,n be Element of NAT;
  cluster Load (a,k1)<>0_goto n -> shiftable Program of SCMPDS;
end;

theorem :: SCMPDS_4:80
  for I being shiftable Program of SCMPDS,k1,k2 be Integer,a be
  Int_position st card I + k2 >= 0 holds I ';' (a,k1)<=0_goto k2 is shiftable;

registration
  let k1 be Integer,a be Int_position,n be Element of NAT;
  cluster Load (a,k1)<=0_goto n -> shiftable Program of SCMPDS;
end;

theorem :: SCMPDS_4:81
  for I being shiftable Program of SCMPDS,k1,k2 be Integer,a be
  Int_position st card I + k2 >= 0 holds I ';' (a,k1)>=0_goto k2 is shiftable;

registration
  let k1 be Integer,a be Int_position,n be Element of NAT;
  cluster Load (a,k1)>=0_goto n -> shiftable Program of SCMPDS;
end;

theorem :: SCMPDS_4:82
  for s1,s2 being State of SCMPDS, n,m being Element of NAT,k1 be
Integer st IC s1= m & m+k1>=0 & IC s1 + n = IC s2
 holds ICplusConst(s1,k1) +n = ICplusConst(s2,k1);

theorem :: SCMPDS_4:83
  for s1,s2 being State of SCMPDS, n,m being Element of NAT, i
being Instruction of SCMPDS holds IC s1= m & i valid_at m & InsCode i <>
  1 & InsCode i <> 3 & IC s1 + n = IC s2 & DataPart s1 = DataPart s2 implies IC
  Exec(i,s1) + n = IC Exec(i,s2) & DataPart Exec(i,s1) = DataPart Exec(i,s2);

theorem :: SCMPDS_4:84
  for P1,P2 being (the Instructions of SCMPDS)-valued ManySortedSet of NAT
  for s1 being 0-started State of SCMPDS
  for J being parahalting shiftable Program of SCMPDS st stop J c= P1
  for n being Element of NAT st Shift(stop J,n) c= P2 &
    IC s2 = n & DataPart s1 = DataPart s2
  for i being Element of NAT holds
   IC Comput(P1,s1,i) + n = IC Comput(P2,s2,i) &
    CurInstr(P1,Comput(P1,s1,i)) =
     CurInstr(P2,Comput(P2,s2,i)) &
    DataPart Comput(P1,s1,i) = DataPart
       Comput(P2,s2,i);

