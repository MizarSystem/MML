:: The Construction and shiftability of Program Blocks for SCMPDS
::  by JingChao Chen
::
:: Received June 15, 1999
:: Copyright (c) 1999-2011 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies NUMBERS, SUBSET_1, AMI_1, SCMPDS_2, SCMFSA_7, CARD_1, FUNCOP_1,
      RELAT_1, FUNCT_1, NAT_1, ARYTM_3, XBOOLE_0, TARSKI, VALUED_1, SCMNORM,
      FSM_1, INT_1, FUNCT_4, GRAPHSP, AMI_3, AMI_2, STRUCT_0, SCMPDS_1,
      COMPLEX1, XXREAL_0, ARYTM_1, TURING_1, AMISTD_2, SCMFSA6B, MSUALG_1,
      CIRCUIT2, SCMPDS_4, ORDINAL1, PARTFUN1, SCMFSA6C, ORDINAL4, PBOOLE,
      FINSET_1, COMPOS_1;
 notations TARSKI, XBOOLE_0, ENUMSET1, SUBSET_1, CARD_1, FINSET_1, NUMBERS,
      XCMPLX_0, RELAT_1, FUNCT_1, PARTFUN1, AFINSQ_1, VALUED_1, FUNCT_4,
      FUNCT_7, INT_1, NAT_1, INT_2, XXREAL_0, PBOOLE, STRUCT_0, MEMSTR_0,
      COMPOS_1, EXTPRO_1, AMI_2, AMISTD_2, SCMPDS_1, SCMPDS_2;
 constructors WELLORD2, XXREAL_0, INT_2, SCMPDS_1, SCMPDS_3, DOMAIN_1,
      RELSET_1, PRE_POLY, ORDINAL5, AMI_3, AMISTD_2, AMISTD_1, FUNCT_7,
      MEMSTR_0;
 registrations XBOOLE_0, SETFAM_1, FUNCT_1, ORDINAL1, NUMBERS, XXREAL_0,
      XREAL_0, NAT_1, INT_1, SCMPDS_2, AMI_2, FINSET_1, CARD_1, VALUED_1,
      FUNCT_4, RELAT_1, PRE_POLY, AFINSQ_1, COMPOS_1, ORDINAL5, EXTPRO_1,
      FUNCOP_1, FUNCT_7, SCMPDS_3, AMISTD_2, PBOOLE, MEMSTR_0;
 requirements REAL, NUMERALS, SUBSET, BOOLE, ARITHM;


begin :: Definition of a program block and its basic properties

reserve l, m, n for Element of NAT,
  i,j,k for Instruction of SCMPDS,
  I,J,K for Program of SCMPDS,
  p,q,r for PartState of SCMPDS;

reserve a,b,c for Int_position,
  s,s1,s2 for State of SCMPDS,
  k1,k2 for Integer;



theorem :: SCMPDS_4:1
  InsCode i in {0,1,4,5,6} or Exec(i,s).IC SCMPDS = succ IC s;



theorem :: SCMPDS_4:2
  for s1,s2 being State of SCMPDS st IC s1 = IC s2 & for a being
  Int_position holds s1.a = s2.a holds  s1 =  s2;



theorem :: SCMPDS_4:3
  for k1,k2 be Element of NAT st k1 <> k2 holds DataLoc(k1,0) <>
  DataLoc(k2,0);

theorem :: SCMPDS_4:4
  for dl being Int_position ex i being Element of NAT st dl =
  DataLoc(i,0);

scheme :: SCMPDS_4:sch 1

  SCMPDSEx{ G(set) -> Integer, I() ->
  Element of NAT }: ex S being State of SCMPDS st IC S = I() &
  for i being Element of NAT holds S.DataLoc(i,0) = G(i);

theorem :: SCMPDS_4:5
  for s being State of SCMPDS holds dom s = {IC SCMPDS} \/ SCM-Data-Loc;

theorem :: SCMPDS_4:6
  for s being State of SCMPDS, x being set st x in dom s holds x is
  Int_position or x = IC SCMPDS;



theorem :: SCMPDS_4:7
  for i being Element of NAT holds not i in SCM-Data-Loc;

theorem :: SCMPDS_4:8
  for s1,s2 being State of SCMPDS holds (for a being Int_position
  holds s1.a = s2.a) iff DataPart s1 = DataPart s2;



reserve x for set;

begin :: Combining two consecutive blocks into one program block

notation
  let I,J be Program of SCMPDS;
  synonym I ';' J for I ^ J;
end;

definition

  let I,J be Program of SCMPDS;
  redefine func I ';' J -> Program of SCMPDS equals
:: SCMPDS_4:def 1
  I +* Shift(J, card I);
end;

begin :: Combining a block and a instruction into one program block

definition
  let i, J;
  func i ';' J -> Program of SCMPDS equals
:: SCMPDS_4:def 2
  Load i ';' J;
end;

definition
  let I, j;
  func I ';' j -> Program of SCMPDS equals
:: SCMPDS_4:def 3
  I ';' Load j;
end;

definition
  let i,j;
  func i ';' j -> Program of SCMPDS equals
:: SCMPDS_4:def 4
  Load i ';' Load j;
end;



theorem :: SCMPDS_4:9
  i ';' j = Load i ';' j;

theorem :: SCMPDS_4:10
  i ';' j = i ';' Load j;



theorem :: SCMPDS_4:11
  I ';' J ';' k = I ';' (J ';' k);

theorem :: SCMPDS_4:12
  I ';' j ';' K = I ';' (j ';' K);

theorem :: SCMPDS_4:13
  I ';' j ';' k = I ';' (j ';' k);

theorem :: SCMPDS_4:14
  i ';' J ';' K = i ';' (J ';' K);

theorem :: SCMPDS_4:15
  i ';' J ';' k = i ';' (J ';' k);

theorem :: SCMPDS_4:16
  i ';' j ';' K = i ';' (j ';' K);

theorem :: SCMPDS_4:17
  i ';' j ';' k = i ';' (j ';' k);



reserve l,l1,loc for Element of NAT;

theorem :: SCMPDS_4:18
  not a in dom Start-At(l,SCMPDS);



theorem :: SCMPDS_4:19
  not a in dom (I+*Start-At(l,SCMPDS));

definition
  let s be State of SCMPDS, li be Int_position, k be Integer;
  redefine func s+*(li,k) -> PartState of SCMPDS;
end;

begin :: The notions of paraclosed,parahalting and their basic properties

definition

  let I be Program of SCMPDS, s be State of SCMPDS;
  let P be Instruction-Sequence of SCMPDS;
  func IExec(I,P,s) -> State of SCMPDS equals
:: SCMPDS_4:def 5
  Result(P+*stop I,s);
end;

definition
  let I be Program of SCMPDS;
  attr I is paraclosed means
:: SCMPDS_4:def 6

  for s being 0-started State of SCMPDS, n being Element of NAT,
      P being Instruction-Sequence of SCMPDS
    st stop I c= P
   holds IC Comput(P,s,n) in dom stop(I);
  attr I is parahalting means
:: SCMPDS_4:def 7

  for s being 0-started State of SCMPDS,
      P being Instruction-Sequence of SCMPDS
    st stop I c= P
    holds P halts_on s;
end;

registration
  cluster parahalting for Program of SCMPDS;
end;

theorem :: SCMPDS_4:20
 for P,Q being Instruction-Sequence of SCMPDS
  st Q = P +*((IC s,succ IC s) --> (goto 1, goto -1))
 holds
  not Q halts_on s;

theorem :: SCMPDS_4:21
 for P1,P2 being Instruction-Sequence of SCMPDS
  st  s1 =  s2 & I c= P1 & I c= P2 & (for m st m < n
  holds IC (Comput(P2,s2,m)) in dom I)
 for m st m <= n
holds
   Comput(P1,s1,m) =  Comput(P2,s2,m);

reserve l1,l2 for Element of NAT,
  i1,i2 for Instruction of SCMPDS;

registration
  cluster parahalting -> paraclosed for Program of SCMPDS;
end;

begin :: Shiftability of program blocks and instructions

definition
  let i be Instruction of SCMPDS;
  let n be Element of NAT;
  pred i valid_at n means
:: SCMPDS_4:def 8

  (InsCode i= 0 implies ex k1 st i = goto k1 &
  n+k1 >= 0) & (InsCode i= 4 implies ex a,k1,k2 st i = (a,k1)<>0_goto k2 & n+k2
>= 0 ) & (InsCode i= 5 implies ex a,k1,k2 st i = (a,k1)<=0_goto k2 & n+k2 >= 0
  ) & (InsCode i= 6 implies ex a,k1,k2 st i = (a,k1)>=0_goto k2 & n+k2 >= 0);
end;

reserve l for Element of NAT;

definition
  let IT be finite (the Instructions of SCMPDS)-valued NAT-defined Function;
  attr IT is shiftable means
:: SCMPDS_4:def 9

  for n,i st  n in dom IT & i=IT.(n)
   holds InsCode i <> 1 & InsCode i <> 3 & i valid_at n;
end;



theorem :: SCMPDS_4:22
  for i be Instruction of SCMPDS,m,n be Element of NAT st i
  valid_at m & m <= n holds i valid_at n;

registration
  cluster parahalting shiftable for Program of SCMPDS;
end;

definition
  let i be Instruction of SCMPDS;
  attr i is shiftable means
:: SCMPDS_4:def 10

  InsCode i = 2 or InsCode i > 6;
end;

registration
  cluster shiftable for Instruction of SCMPDS;
end;

registration
  let a,k1;
  cluster a := k1 -> shiftable;
end;

registration
  let a,k1,k2;
  cluster (a,k1) := k2 -> shiftable;
end;

registration
  let a,k1,k2;
  cluster AddTo(a,k1,k2) -> shiftable;
end;

registration
  let a,b,k1,k2;
  cluster AddTo(a,k1,b,k2) -> shiftable;
  cluster SubFrom(a,k1,b,k2) -> shiftable;
  cluster MultBy(a,k1,b,k2) -> shiftable;
  cluster Divide(a,k1,b,k2) -> shiftable;
  cluster (a,k1) := (b,k2) -> shiftable;
end;

registration
  let I,J be shiftable Program of SCMPDS;
  cluster I ';' J -> shiftable for Program of SCMPDS;
end;

registration
  let i be shiftable Instruction of SCMPDS;
  cluster Load i -> shiftable for Program of SCMPDS;
end;

registration
  let i be shiftable Instruction of SCMPDS, J be shiftable Program of SCMPDS;
  cluster i ';' J -> shiftable;
end;

registration
  let I be shiftable Program of SCMPDS, j be shiftable Instruction of SCMPDS;
  cluster I ';' j -> shiftable;
end;

registration
  let i,j be shiftable Instruction of SCMPDS;
  cluster i ';' j -> shiftable;
end;

registration
  cluster Stop SCMPDS -> parahalting shiftable;
end;

registration
  let I be shiftable Program of SCMPDS;
  cluster stop I -> shiftable;
end;

theorem :: SCMPDS_4:23
  for I being shiftable Program of SCMPDS,k1 be Integer st card I + k1
  >= 0 holds I ';' goto k1 is shiftable;

registration
  let n be Element of NAT;
  cluster Load goto n -> shiftable for Program of SCMPDS;
end;

theorem :: SCMPDS_4:24
  for I being shiftable Program of SCMPDS,k1,k2 be Integer,a be
  Int_position st card I + k2 >= 0 holds I ';' (a,k1)<>0_goto k2 is shiftable;

registration
  let k1 be Integer,a be Int_position,n be Element of NAT;
  cluster Load (a,k1)<>0_goto n -> shiftable for Program of SCMPDS;
end;

theorem :: SCMPDS_4:25
  for I being shiftable Program of SCMPDS,k1,k2 be Integer,a be
  Int_position st card I + k2 >= 0 holds I ';' (a,k1)<=0_goto k2 is shiftable;

registration
  let k1 be Integer,a be Int_position,n be Element of NAT;
  cluster Load (a,k1)<=0_goto n -> shiftable for Program of SCMPDS;
end;

theorem :: SCMPDS_4:26
  for I being shiftable Program of SCMPDS,k1,k2 be Integer,a be
  Int_position st card I + k2 >= 0 holds I ';' (a,k1)>=0_goto k2 is shiftable;

registration
  let k1 be Integer,a be Int_position,n be Element of NAT;
  cluster Load (a,k1)>=0_goto n -> shiftable for Program of SCMPDS;
end;

theorem :: SCMPDS_4:27
  for s1,s2 being State of SCMPDS, n,m being Element of NAT,k1 be
Integer st IC s1= m & m+k1>=0 & IC s1 + n = IC s2
 holds ICplusConst(s1,k1) +n = ICplusConst(s2,k1);

theorem :: SCMPDS_4:28
  for s1,s2 being State of SCMPDS, n,m being Element of NAT, i
being Instruction of SCMPDS holds IC s1= m & i valid_at m & InsCode i <>
  1 & InsCode i <> 3 & IC s1 + n = IC s2 & DataPart s1 = DataPart s2 implies IC
  Exec(i,s1) + n = IC Exec(i,s2) & DataPart Exec(i,s1) = DataPart Exec(i,s2);

theorem :: SCMPDS_4:29
  for P1,P2 being Instruction-Sequence of SCMPDS
  for s1 being 0-started State of SCMPDS
  for J being parahalting shiftable Program of SCMPDS st stop J c= P1
  for n being Element of NAT st Shift(stop J,n) c= P2 &
    IC s2 = n & DataPart s1 = DataPart s2
  for i being Element of NAT holds
   IC Comput(P1,s1,i) + n = IC Comput(P2,s2,i) &
    CurInstr(P1,Comput(P1,s1,i)) =
     CurInstr(P2,Comput(P2,s2,i)) &
    DataPart Comput(P1,s1,i) = DataPart
       Comput(P2,s2,i);

