:: The Construction and shiftability of Program Blocks for SCMPDS
::  by JingChao Chen
::
:: Received June 15, 1999
:: Copyright (c) 1999 Association of Mizar Users

environ

 vocabulary AMI_3, CAT_1, AMI_1, SCMPDS_2, SCMFSA_7, SCMPDS_3, RELAT_1,
      FINSET_1, FUNCT_1, CARD_1, TARSKI, AMI_5, BOOLE, RELOC, FUNCT_4, INT_1,
      SCMFSA6A, AMI_2, FUNCT_7, SCMPDS_1, ABSVALUE, NAT_1, ARYTM_1, SCMFSA6B,
      FUNCOP_1, SCMPDS_4;
 notation TARSKI, XBOOLE_0, ENUMSET1, SUBSET_1, NUMBERS, XCMPLX_0, XREAL_0,
      RELAT_1, FUNCT_1, FUNCT_4, INT_1, NAT_1, CQC_LANG, FINSET_1, STRUCT_0,
      AMI_1, AMI_2, AMI_3, AMI_5, FUNCT_7, SCMPDS_1, SCMPDS_2, GROUP_1,
      SCMFSA_4, SCMPDS_3, CARD_1;
 constructors DOMAIN_1, NAT_1, AMI_5, FUNCT_7, SCMPDS_1, SCMFSA_4, SCMPDS_3,
      WELLORD2, MEMBERED;
 clusters AMI_1, INT_1, FUNCT_1, RELSET_1, XBOOLE_0, SCMPDS_2, FUNCT_7,
      PRELAMB, SCMFSA_4, SCMPDS_3, FRAENKEL, XREAL_0, MEMBERED, NUMBERS,
      ORDINAL2;
 requirements REAL, NUMERALS, SUBSET, BOOLE, ARITHM;


begin :: Definition of a program block and its basic properties

definition
  mode Program-block is initial programmed FinPartState of SCMPDS;
end;


reserve l, m, n for Nat,
        i,j,k for Instruction of SCMPDS,
        I,J,K for Program-block;

definition let i;
 func Load i -> Program-block equals
:: SCMPDS_4:def 1
 (inspos 0).--> i;
end;


registration let i;
 cluster Load i -> non empty;
 coherence
  proof
      Load i = (inspos 0) .--> i by Def1;
   hence Load i is non empty;
  end;
end;


theorem :: SCMPDS_4:1   ::SCMFSA6A=SCMPDS_4,Th15
 for P being Program-block, n holds
  n < card P iff inspos n in dom P;

registration let I be initial FinPartState of SCMPDS;
 cluster ProgramPart I -> initial;
 coherence
  proof let m,n such that
A1: inspos n in dom ProgramPart I and
A2: m < n;
      ProgramPart I c= I by AMI_5:63;
    then dom ProgramPart I c= dom I by RELAT_1:25;
    then inspos m in dom I by A1,A2,SCMPDS_3:def 5;
   hence inspos m in dom ProgramPart I by AMI_5:73;
  end;
end;


theorem :: SCMPDS_4:2    ::S6A02,Th16
 dom I misses dom Shift(J,card I);

theorem :: SCMPDS_4:3     :: S6A03,Th17
for I being programmed FinPartState of SCMPDS
 holds card Shift(I,m) = card I;

theorem :: SCMPDS_4:4    :: S6A04,Th20
for I,J being FinPartState of SCMPDS holds
 ProgramPart(I +* J) = ProgramPart I +* ProgramPart J;

theorem :: SCMPDS_4:5    ::Th21
  for I,J being FinPartState of SCMPDS holds
 Shift(ProgramPart(I +* J),n) =
    Shift(ProgramPart I,n) +* Shift(ProgramPart J,n);

reserve a,b,c for Int_position,
        s,s1,s2 for State of SCMPDS,
        k1,k2 for Integer;

definition let I;
 func Initialized I -> FinPartState of SCMPDS equals
:: SCMPDS_4:def 2
 I +* Start-At(inspos 0);
end;


theorem :: SCMPDS_4:6    ::S6A06,Th23
 InsCode i in {0,1,4,5,6} or Exec(i,s).IC SCMPDS = Next IC s;

theorem :: SCMPDS_4:7    :: Th24 SF_65
 IC SCMPDS in dom Initialized I;

theorem :: SCMPDS_4:8    :: S6A08
   IC Initialized I = inspos 0;

theorem :: SCMPDS_4:9    :: Th26
 I c= Initialized I;

canceled;

theorem :: SCMPDS_4:11   :: Th28
 for s1,s2 being State of SCMPDS
   st IC s1 = IC s2 & for a being Int_position holds s1.a = s2.a
  holds s1,s2 equal_outside the Instruction-Locations of SCMPDS;

canceled;

theorem :: SCMPDS_4:13   :: Th30
 s1,s2 equal_outside the Instruction-Locations of SCMPDS implies
  for a being Int_position holds s1.a = s2.a;

theorem :: SCMPDS_4:14   :: Lm1
    s1,s2 equal_outside the Instruction-Locations of SCMPDS implies
     s1.DataLoc(s1.a,k1)=s2.DataLoc(s2.a,k1);

theorem :: SCMPDS_4:15    ::Th32
 s1,s2 equal_outside the Instruction-Locations of SCMPDS implies
  Exec(i,s1),Exec(i,s2) equal_outside the Instruction-Locations of SCMPDS;

theorem :: SCMPDS_4:16
   (Initialized I)|the Instruction-Locations of SCMPDS = I;

theorem :: SCMPDS_4:17    :: SF2_16
 for k1,k2 be Nat st k1 <> k2 holds DataLoc(k1,0) <> DataLoc(k2,0);

theorem :: SCMPDS_4:18   :: SF2_19:
 for dl being Int_position ex i being Nat
  st dl = DataLoc(i,0);

scheme :: SCMPDS_4:sch 1
 SCMPDSEx{ F(set) -> Instruction of SCMPDS,
                 G(set) -> Integer,
                 I() -> Instruction-Location of SCMPDS }:
 ex S being State of SCMPDS st IC S = I() &
  for i being Nat holds
    S.inspos i = F(i) & S.DataLoc(i,0) = G(i)
proof
 defpred P[set,set] means ex m st
   $1 = IC SCMPDS & $2 = I() or
   $1 = inspos m & $2 = F(m) or
   $1 = DataLoc(m,0) & $2 = G(m);
  set S1={IC SCMPDS },
      S2=SCM-Data-Loc,
      S3=the Instruction-Locations of SCMPDS;
A1: for e being set st e in the carrier of SCMPDS
     ex u being set st P[e,u]
   proof let e be set;
    assume e in the carrier of SCMPDS;
    then A2: e in S1 \/ S2 or e in S3 by SCMPDS_3:5,XBOOLE_0:def 2;
       now per cases by A2,XBOOLE_0:def 2;
      case e in S1;
       hence e = IC SCMPDS by TARSKI:def 1;
      end;
      case e in S2;
        then e is Int_position by SCMPDS_2:9;
        hence ex m st e = DataLoc(m,0) by Th18;
      end;
      case e in S3;
       hence ex m st e = inspos m by SCMPDS_3:32;
     end;
     end;
     then consider m such that
A3:  e = IC SCMPDS or e = inspos m or e = DataLoc(m,0);
    per cases by A3;
    suppose
A4:   e = IC SCMPDS;
     take u = I(); thus P[e,u] by A4;
    end;
    suppose
A5:   e = inspos m;
     take u = F(m); thus P[e,u] by A5;
    end;
    suppose
A6:   e = DataLoc(m,0);
     take u = G(m); thus P[e,u] by A6;
   end;
   end;
  consider f being Function such that
A7: dom f = the carrier of SCMPDS and
A8: for e being set st e in the carrier of SCMPDS holds P[e,f.e]
                         from ZFREFLE1:sch 1(A1);
A9: dom the Object-Kind of SCMPDS = the carrier of SCMPDS by FUNCT_2:def 1;
    now let x be set;
   assume
A10: x in dom the Object-Kind of SCMPDS;
     then A11: x in S1 \/ S2 or x in S3 by A9,SCMPDS_3:5,XBOOLE_0:def 2;
   consider m such that
A12: x = IC SCMPDS & f.x = I() or
    x = inspos m & f.x = F(m) or
    x = DataLoc(m,0) & f.x = G(m) by A8,A9,A10;
   per cases by A11,XBOOLE_0:def 2;
    suppose x in S2;
     then A13: x is Int_position by SCMPDS_2:9;
    then (the Object-Kind of SCMPDS).x = ObjectKind DataLoc(m,0) by A12,AMI_1:
def 6,SCMPDS_2:52,53
        .= INT by SCMPDS_2:13;
   hence f.x in (the Object-Kind of SCMPDS).x by A12,A13,INT_1:12,SCMPDS_2:52,
53;
    end;
    suppose x in S1;
then A14:    x = IC SCMPDS by TARSKI:def 1;
    then (the Object-Kind of SCMPDS).x = ObjectKind IC SCMPDS by AMI_1:def 6
       .= the Instruction-Locations of SCMPDS by AMI_1:def 11;
   hence f.x in (the Object-Kind of SCMPDS).x by A12,A14,AMI_1:48,SCMPDS_2:52;
    end;
    suppose A15: x in the Instruction-Locations of SCMPDS;
    then (the Object-Kind of SCMPDS).x = ObjectKind inspos m by A12,AMI_1:48,
def 6,SCMPDS_2:53
        .= the Instructions of SCMPDS by AMI_1:def 14;
   hence f.x in (the Object-Kind of SCMPDS).x by A12,A15,AMI_1:48,SCMPDS_2:53;
  end;
  end;
  then reconsider f as State of SCMPDS by A7,A9,CARD_3:18;
 take f;
  consider m such that
A16: IC SCMPDS = IC SCMPDS & f.IC SCMPDS = I() or
    IC SCMPDS = inspos m & f.IC SCMPDS = F(m) or
    IC SCMPDS = DataLoc(m,0) & f.IC SCMPDS = G(m) by A8;
 thus IC f = I() by A16,AMI_1:48,def 15,SCMPDS_2:52;
 let i be Nat;
  consider m such that
A17: inspos i = IC SCMPDS & f.inspos i = I() or
    inspos i = inspos m & f.inspos i = F(m) or
    inspos i = DataLoc(m,0) & f.inspos i = G(m) by A8;
  thus f.inspos i = F(i) by A17,AMI_1:48,SCMPDS_2:53,SCMPDS_3:31;
  consider m such that
A18: DataLoc(i,0) = IC SCMPDS & f.DataLoc(i,0) = I() or
    DataLoc(i,0) = inspos m & f.DataLoc(i,0) = F(m) or
    DataLoc(i,0) = DataLoc(m,0) & f.DataLoc(i,0) = G(m) by A8;
 thus f.DataLoc(i,0) = G(i) by A18,Th17,SCMPDS_2:52,53;
end;

theorem :: SCMPDS_4:19    :: Th34
  for s being State of SCMPDS holds
     dom s = {IC SCMPDS} \/ SCM-Data-Loc \/
         the Instruction-Locations of SCMPDS;

theorem :: SCMPDS_4:20    :: T12'
   for s being State of SCMPDS, x being set st x in dom s holds
     x is Int_position or x = IC SCMPDS or
     x is Instruction-Location of SCMPDS;

theorem :: SCMPDS_4:21     :: T29
   for s1,s2 being State of SCMPDS holds
     (for l being Instruction-Location of SCMPDS holds s1.l = s2.l)
 iff s1 | the Instruction-Locations of SCMPDS =
     s2 | the Instruction-Locations of SCMPDS;

theorem :: SCMPDS_4:22  :: T32
   for i being Instruction-Location of SCMPDS holds
     not i in SCM-Data-Loc;

theorem :: SCMPDS_4:23     :: Th38
 for s1,s2 being State of SCMPDS holds
     (for a being Int_position holds s1.a = s2.a)
 iff s1 | SCM-Data-Loc = s2 | SCM-Data-Loc;

theorem :: SCMPDS_4:24     :: T19
   for s1,s2 being State of SCMPDS st
     s1,s2 equal_outside the Instruction-Locations of SCMPDS holds
     s1 | SCM-Data-Loc = s2 | SCM-Data-Loc;

theorem :: SCMPDS_4:25     :: T21
   for s,ss being State of SCMPDS, A being set holds
     (ss +* s | A) | A = s | A;

theorem :: SCMPDS_4:26    :: T18
   for I,J being Program-block holds
     I,J equal_outside the Instruction-Locations of SCMPDS;

theorem :: SCMPDS_4:27    :: Th43
 for I being Program-block holds
     dom Initialized I = dom I \/ {IC SCMPDS};

theorem :: SCMPDS_4:28    :: Th44
 for I being Program-block, x being set st x in dom Initialized I holds
     x in dom I or x = IC SCMPDS;

theorem :: SCMPDS_4:29     :: Th46
 for I being Program-block holds
     (Initialized I).IC SCMPDS = inspos 0;

theorem :: SCMPDS_4:30   :: Th47
  for I being Program-block holds not IC SCMPDS in dom I;

theorem :: SCMPDS_4:31   :: Th48
 for I being Program-block, a being Int_position holds
     not a in dom Initialized I;

reserve x for set;

theorem :: SCMPDS_4:32    ::TN32
 x in dom I implies I.x = (I +* Start-At inspos n).x;

theorem :: SCMPDS_4:33   :: Th50
 for I being Program-block, x being set st x in dom I holds
     I.x = (Initialized I).x;

theorem :: SCMPDS_4:34    :: Th51
 for I,J being Program-block
 for s being State of SCMPDS st Initialized J c= s holds
     s +* Initialized I = s +* I;

theorem :: SCMPDS_4:35
   for I,J being Program-block
 for s being State of SCMPDS st Initialized J c= s holds
     Initialized I c= s +* I;

theorem :: SCMPDS_4:36
   for I,J being Program-block
 for s being State of SCMPDS holds
     s +* Initialized I, s +* Initialized J
         equal_outside the Instruction-Locations of SCMPDS;

begin :: Combining two consecutive blocks into one program block

definition let I,J be Program-block;
 func I ';' J -> Program-block equals
:: SCMPDS_4:def 3
  I +* Shift(J, card I);
end;


theorem :: SCMPDS_4:37
 for I,J being Program-block, l being Instruction-Location of SCMPDS
  st l in dom I holds (I ';' J).l = I.l;

theorem :: SCMPDS_4:38
 for I,J being Program-block, l being Instruction-Location of SCMPDS
  st l in dom J holds (I ';' J).(l+card I)= J.l;

theorem :: SCMPDS_4:39    :: Th56
 for I,J being Program-block holds
     dom I c= dom (I ';' J);

theorem :: SCMPDS_4:40
   for I,J being Program-block holds
     I c= I ';' J;

theorem :: SCMPDS_4:41
   for I,J being Program-block holds
     I +* (I ';' J) = (I ';' J);

theorem :: SCMPDS_4:42
   for I,J being Program-block holds
     Initialized I +* (I ';' J) = Initialized (I ';' J);

begin :: Combining a block and a instruction into one program block

definition let i, J;
 func i ';' J -> Program-block equals
:: SCMPDS_4:def 4
  Load i ';' J;
end;


definition let I, j;
 func I ';' j -> Program-block equals
:: SCMPDS_4:def 5
  I ';' Load j;
end;


definition let i,j;
 func i ';' j -> Program-block equals
:: SCMPDS_4:def 6
  Load i ';' Load j;
end;


theorem :: SCMPDS_4:43   :: Th59
 i ';' j = Load i ';' j;

theorem :: SCMPDS_4:44    :: Th60
  i ';' j = i ';' Load j;

theorem :: SCMPDS_4:45    :: Th61
 card(I ';' J) = card I + card J;

theorem :: SCMPDS_4:46   :: Th62
 I ';' J ';' K = I ';' (J ';' K);

theorem :: SCMPDS_4:47   :: Th63
 I ';' J ';' k = I ';' (J ';' k);

theorem :: SCMPDS_4:48
   I ';' j ';' K = I ';' (j ';' K);

theorem :: SCMPDS_4:49
   I ';' j ';' k = I ';' (j ';' k);

theorem :: SCMPDS_4:50   :: Th66
 i ';' J ';' K = i ';' (J ';' K);

theorem :: SCMPDS_4:51
   i ';' J ';' k = i ';' (J ';' k);

theorem :: SCMPDS_4:52    :: Th68
 i ';' j ';' K = i ';' (j ';' K);

theorem :: SCMPDS_4:53
   i ';' j ';' k = i ';' (j ';' k);

theorem :: SCMPDS_4:54    :: SFM Th64:
  dom I misses dom Start-At inspos n;

theorem :: SCMPDS_4:55   :: TN55
   Start-At inspos 0 c= Initialized I;

theorem :: SCMPDS_4:56   ::TN56
 I +* Start-At inspos n c= s implies I c= s;

theorem :: SCMPDS_4:57    ::S6B_5
   Initialized I c= s implies I c= s;

theorem :: SCMPDS_4:58   ::TN58
 (I +* Start-At inspos n)|the Instruction-Locations of SCMPDS = I;

 reserve l,l1,loc for Instruction-Location of SCMPDS;

theorem :: SCMPDS_4:59    ::TN59
 not a in dom Start-At l;

theorem :: SCMPDS_4:60
   not l1 in dom Start-At l;

theorem :: SCMPDS_4:61     ::TN61
   not a in dom (I+*Start-At l);

theorem :: SCMPDS_4:62    ::TN62
   s+*I+*Start-At inspos 0 = s+*Start-At inspos 0+*I;

definition
 let s be State of SCMPDS, li be Int_position, k be Integer;
 redefine func s+*(li,k) -> State of SCMPDS;
end;


begin :: The notions of paraclosed,parahalting and their basic properties

definition let I be Program-block;
 func stop(I) -> Program-block equals
:: SCMPDS_4:def 7
  I ';' SCMPDS-Stop;
end;


definition let I be Program-block, s be State of SCMPDS;
 func IExec(I,s) -> State of SCMPDS equals
:: SCMPDS_4:def 8
      Result(s+*Initialized stop(I))
    +* s|the Instruction-Locations of SCMPDS;
end;


definition let I be Program-block;
 attr I is paraclosed means
:: SCMPDS_4:def 9
 for s being State of SCMPDS, n being Nat
    st Initialized stop(I) c= s
   holds IC (Computation s).n in dom stop(I);

 attr I is parahalting means
:: SCMPDS_4:def 10
 Initialized stop(I) is halting;
end;

registration
 cluster parahalting Program-block;
 existence by Lm1;
end;


theorem :: SCMPDS_4:63     ::TN63
 for I being parahalting Program-block
   st Initialized stop I c= s holds s is halting;

registration let I be parahalting Program-block;
 cluster Initialized stop(I) -> halting;
  coherence
  proof
  let s be State of SCMPDS;
   assume Initialized stop I c= s;
   hence s is halting by Th63;
  end;
end;


definition
 let la,lb be Instruction-Location of SCMPDS;
 let a, b be Instruction of SCMPDS;
 redefine func (la,lb) --> (a,b) -> FinPartState of SCMPDS;
end;


canceled;

theorem :: SCMPDS_4:65
    IC s <> Next IC s;

theorem :: SCMPDS_4:66     ::TN66
 s2 +*((IC s2,Next IC s2) --> (goto 1, goto -1)) is not halting;

theorem :: SCMPDS_4:67    ::Th21
 s1,s2 equal_outside the Instruction-Locations of SCMPDS &
  I c= s1 & I c= s2 &
  (for m st m < n holds IC ((Computation s2).m) in dom I)
 implies
 for m st m <= n holds
  (Computation s1).m, (Computation s2 ).m equal_outside
     the Instruction-Locations of SCMPDS;

theorem :: SCMPDS_4:68
 for s being State of SCMPDS,l being Instruction-Location of SCMPDS
  holds l in dom s;

reserve l1,l2 for Instruction-Location of SCMPDS,
         i1,i2 for Instruction of SCMPDS;

theorem :: SCMPDS_4:69
    s +*((l1,l2) --> (i1, i2)) = s +* (l1,i1) +* (l2,i2);

theorem :: SCMPDS_4:70
 Next inspos n = inspos(n+1);

theorem :: SCMPDS_4:71
    not IC s in dom I implies not Next IC s in dom I;

registration
 cluster parahalting -> paraclosed Program-block;
 coherence proof
  let I be Program-block; assume
A1: I is parahalting;
  let s be State of SCMPDS, n be Nat;
 assume
A2: Initialized stop(I) c= s;
   defpred X[Nat] means not IC (Computation s).$1 in dom stop(I);
 assume not IC (Computation s).n in dom stop(I);
then A3: ex n st X[n];
  consider n such that
A4: X[n] and
A5: for m st X[m] holds n <= m from NAT_1:sch 5(A3);
A6: not Next IC (Computation s).n in dom stop(I) by A4,Th71;
   set s2 = (Computation s).n,
       Ig = ((IC s2,Next IC s2) --> (goto 1, goto -1)),
       s0 = s +* Ig,
       s1 = s2 +* Ig,
       t1= s +* (IC s2,goto 1),
       t2= t1 +* (Next IC s2,goto -1),
       t3= s2 +* (IC s2,goto 1),
       t4= t3 +* (Next IC s2,goto -1),
       IL=the Instruction-Locations of SCMPDS;
   set IAt = stop(I) +* Start-At inspos 0;
     dom stop(I) misses dom Start-At inspos 0 by Th54;
then A7: stop I c= IAt by FUNCT_4:33;
A8: Initialized stop(I) = IAt by Def2;
then A9: IAt is halting by A1,Def10;
     (IAt) | IL = stop I by Th58;
then A10:  dom stop (I) = dom(IAt) /\ IL
        by RELAT_1:90;
then A11: not IC s2 in dom IAt by A4,XBOOLE_0:def 3;
A12: not Next IC s2 in dom IAt by A6,A10,XBOOLE_0:def 3;
      IAt c= t1 by A2,A8,A11,SCMFSA6A:1;
    then IAt c= t2 by A12,SCMFSA6A:1;
then A13: IAt c= s0 by Th69;
then A14: s0 is halting by A9,AMI_1:def 26;
A15: s,t1 equal_outside IL by SCMFSA6A:3;
    t1,t2 equal_outside IL by SCMFSA6A:3;
  then s,t2 equal_outside IL by A15,FUNCT_7:29;
  then s,s0 equal_outside IL by Th69;
then A16: s0,s equal_outside IL by FUNCT_7:28;
A17: stop I c= s0 by A7,A13,XBOOLE_1:1;
A18: stop I c= s by A2,A7,A8,XBOOLE_1:1;
   for m st m < n holds IC((Computation s).m) in dom stop I by A5;
then A19: (Computation s0).n,s2 equal_outside IL by A16,A17,A18,Th67;
A20: s2,t3 equal_outside IL by SCMFSA6A:3;
     t3,t4 equal_outside IL by SCMFSA6A:3;
   then s2,t4 equal_outside IL by A20,FUNCT_7:29;
   then s2,s1 equal_outside IL by Th69;
then A21: (Computation s0).n, s1 equal_outside IL by A19,FUNCT_7:29;
        s| IL = s2 | IL by SCMFSA6B:17;
      then t1 | IL = t3 | IL by SCMFSA6A:5;
      then t2 | IL = t4 | IL by SCMFSA6A:5;
      then s0 | IL = t4 | IL by Th69;
  then s0 | IL = s1 | IL by Th69;
    then (Computation s0).n | IL = s1 | IL by SCMFSA6B:17;
then A22: (Computation s0).n = s1 by A21,SCMFSA6A:2;
    s1 is not halting by Th66;
 hence contradiction by A14,A22,SCM_1:27;
 end;
end;


theorem :: SCMPDS_4:72    :: SCMFSA8A_15
     dom SCMPDS-Stop = {inspos 0};

theorem :: SCMPDS_4:73    ::S8A_16
    inspos 0 in dom SCMPDS-Stop & SCMPDS-Stop.inspos 0 = halt SCMPDS;

theorem :: SCMPDS_4:74
     card SCMPDS-Stop = 1;

theorem :: SCMPDS_4:75  ::Th26 T9
 inspos 0 in dom stop (I);

theorem :: SCMPDS_4:76
 for p being programmed FinPartState of SCMPDS,k being Nat,
 il be Instruction-Location of SCMPDS st il in dom p holds
 il+k in dom Shift(p,k);

begin :: Shiftability of program blocks and instructions

definition
 let i be Instruction of SCMPDS;
 let n be Nat;
 pred i valid_at n means
:: SCMPDS_4:def 11
  (InsCode i= 0 implies ex k1 st i = goto k1 & n+k1 >= 0) &
   (InsCode i= 4 implies ex a,k1,k2 st i = (a,k1)<>0_goto k2 & n+k2 >= 0 ) &
   (InsCode i= 5 implies ex a,k1,k2 st i = (a,k1)<=0_goto k2 & n+k2 >= 0 ) &
   (InsCode i= 6 implies ex a,k1,k2 st i = (a,k1)>=0_goto k2 & n+k2 >= 0);
end;


reserve l for Nat;

theorem :: SCMPDS_4:77
  for i be Instruction of SCMPDS,m,n be Nat st i valid_at m & m <= n
 holds i valid_at n;

definition let IT be FinPartState of SCMPDS;
 attr IT is shiftable means
:: SCMPDS_4:def 12
 for n,i st inspos n in dom IT & i=IT.(inspos n) holds
      InsCode i <> 1 & InsCode i <> 3 &   :: return  and save
      i valid_at n;
end;

registration
 cluster parahalting shiftable Program-block;
 existence by Lm1,Lm2;
end;


definition let i be Instruction of SCMPDS;
 attr i is shiftable means
:: SCMPDS_4:def 13
 InsCode i = 2 or InsCode i > 6;
end;


registration
 cluster shiftable Instruction of SCMPDS;
 existence
  proof
   take i=DataLoc(0,0):=1;
   InsCode i=2 by SCMPDS_2:23;
    hence thesis by Def13;
  end;
end;


registration
 let a,k1;
 cluster a := k1 -> shiftable;
 coherence
 proof
       InsCode (a:=k1)=2 by SCMPDS_2:23;
     hence thesis by Def13;
 end;
end;


registration
 let a,k1,k2;
 cluster (a,k1) := k2 -> shiftable;
 coherence
 proof
       InsCode ((a,k1) := k2)=7 by SCMPDS_2:28;
     hence thesis by Def13;
 end;
end;


registration
 let a,k1,k2;
 cluster AddTo(a,k1,k2) -> shiftable;
 coherence
 proof
       InsCode AddTo(a,k1,k2)=8 by SCMPDS_2:29;
     hence thesis by Def13;
 end;
end;


registration
 let a,b,k1,k2;
 cluster AddTo(a,k1,b,k2) -> shiftable;
 coherence
 proof
       InsCode AddTo(a,k1,b,k2)=9 by SCMPDS_2:30;
     hence thesis by Def13;
 end;

cluster SubFrom(a,k1,b,k2) -> shiftable;
 coherence
 proof
       InsCode SubFrom(a,k1,b,k2)=10 by SCMPDS_2:31;
     hence thesis by Def13;
 end;

cluster MultBy(a,k1,b,k2) -> shiftable;
 coherence
 proof
       InsCode MultBy(a,k1,b,k2)=11 by SCMPDS_2:32;
     hence thesis by Def13;
 end;

cluster Divide(a,k1,b,k2) -> shiftable;
 coherence
 proof
       InsCode Divide(a,k1,b,k2)=12 by SCMPDS_2:33;
     hence thesis by Def13;
 end;

cluster (a,k1) := (b,k2) -> shiftable;
 coherence
 proof
       InsCode (a,k1) := (b,k2)=13 by SCMPDS_2:34;
     hence thesis by Def13;
 end;
end;


registration
 let I,J be shiftable Program-block;
 cluster I ';' J -> shiftable;
 coherence
 proof
     set IJ=I ';' J;
A1: I ';' J = I +* Shift(J,card I) by Def3;
     now let n,i such that
A2:    inspos n in dom IJ and
A3:    i=IJ.(inspos n);
       set D = {inspos(l+card I): inspos l in dom J };
         dom Shift(J,card I) = D by SCMPDS_3:def 7;
then A4:    dom IJ = dom I \/ D by A1,FUNCT_4:def 1;
      per cases by A2,A4,XBOOLE_0:def 2;
       suppose A5:inspos n in dom I;
           then I.inspos n=i by A3,Th37;
         hence InsCode i <> 1 & InsCode i <> 3 & i valid_at n by A5,Def12;
       end;
       suppose inspos n in D;
        then consider l such that
A6:      inspos n = inspos(l+card I) and
A7:      inspos l in dom J;
A8:      J.inspos l=IJ.(inspos l+card I) by A7,Th38
         .=i by A3,A6,SCMPDS_3:def 3;
         hence InsCode i <> 1 & InsCode i <> 3 by A7,Def12;
           l <= l+card I by NAT_1:29;
then A9:      l <= n by A6,SCMPDS_3:31;
           i valid_at l by A7,A8,Def12;
         hence i valid_at n by A9,Th77;
   end;
   end;
   hence thesis by Def12;
 end;
end;


registration
 let i be shiftable Instruction of SCMPDS;
 cluster Load i -> shiftable;
 coherence
 proof
    set p=Load i;
     now let n,j such that
A1:    inspos n in dom p and
A2:    j=p.inspos n;
A3:    p=inspos 0 .--> i by Def1;
       then dom p = { inspos 0 } by CQC_LANG:5;
       then inspos n = inspos 0 by A1,TARSKI:def 1;
       then A4: j=i by A2,A3,CQC_LANG:6;
then A5:    InsCode j=2 or InsCode j > 6 by Def13;
       thus InsCode j <> 1 by A4,Def13;
       thus InsCode j <> 3 by A4,Def13;
A6:    InsCode j <> 0 by A4,Def13;
A7:    InsCode j <> 4 by A4,Def13;
     InsCode j <> 5 by A4,Def13;
       hence j valid_at n by A5,A6,A7,Def11;
     end;
     hence thesis by Def12;
  end;
end;


registration
  let i be shiftable Instruction of SCMPDS,
      J be shiftable Program-block;
 cluster i ';' J -> shiftable;
 coherence
 proof
       i ';' J=Load i ';' J by Def4;
     hence thesis;
 end;
end;


registration
 let I be shiftable Program-block,
     j be shiftable Instruction of SCMPDS;
 cluster I ';' j -> shiftable;
 coherence
 proof
       I ';' j=I ';' Load j by Def5;
     hence thesis;
 end;
end;


registration
 let i,j be shiftable Instruction of SCMPDS;
 cluster i ';' j -> shiftable;
 coherence
 proof
       i ';' j=Load i ';' Load j by Def6;
     hence thesis;
 end;
end;


registration
 cluster SCMPDS-Stop -> parahalting shiftable;
 coherence by Def1,Lm1,Lm2,SCMPDS_3:def 6;
end;


registration
 let I be shiftable Program-block;
 cluster stop I -> shiftable;
 coherence
 proof
      stop I= I ';' SCMPDS-Stop by Def7;
    hence thesis;
 end;
end;


theorem :: SCMPDS_4:78
    for I being shiftable Program-block,k1 be Integer st
  card I + k1 >= 0 holds I ';' goto k1 is shiftable;

registration
 let n be Nat;
 cluster Load goto n -> shiftable;
 coherence
 proof
   set k1=n;
   set J= Load goto k1;
     now let n,i such that
A1:    inspos n in dom J and
A2:    i=J.inspos n;
A3:    J=inspos 0 .--> goto k1 by Def1;
       then dom J = { inspos 0 } by CQC_LANG:5;
then inspos n = inspos 0 by A1,TARSKI:def 1;
then A4:    goto k1 =i by A2,A3,CQC_LANG:6;
       hence InsCode i <> 1 & InsCode i <> 3 by SCMPDS_2:21;
A5:    n+k1 >=0 by NAT_1:18;
     InsCode i <> 4 & InsCode i <> 5 & InsCode i <> 6 by A4,SCMPDS_2:21;
       hence i valid_at n by A4,A5,Def11;
    end;
   hence thesis by Def12;
  end;
end;


theorem :: SCMPDS_4:79
    for I being shiftable Program-block,k1,k2 be Integer,a be Int_position st
  card I + k2 >= 0 holds I ';' (a,k1)<>0_goto k2 is shiftable;

registration
  let k1 be Integer,a be Int_position,n be Nat;
  cluster Load (a,k1)<>0_goto n -> shiftable;
  coherence
  proof
   set k2=n;
   set ii= (a,k1)<>0_goto k2,
       J= Load ii;
     now let n,i such that
A1:    inspos n in dom J and
A2:    i=J.inspos n;
A3:    J=inspos 0 .--> ii by Def1;
       then dom J = { inspos 0 } by CQC_LANG:5;
then inspos n = inspos 0 by A1,TARSKI:def 1;
then A4:    ii =i by A2,A3,CQC_LANG:6;
       hence InsCode i <> 1 & InsCode i <> 3 by SCMPDS_2:25;
A5:    n+k2 >=0 by NAT_1:18;
     InsCode i <> 0 & InsCode i <> 5 & InsCode i <> 6 by A4,SCMPDS_2:25;
       hence i valid_at n by A4,A5,Def11;
    end;
   hence thesis by Def12;
   end;
end;


theorem :: SCMPDS_4:80
    for I being shiftable Program-block,k1,k2 be Integer,a be Int_position st
  card I + k2 >= 0 holds I ';' (a,k1)<=0_goto k2 is shiftable;

registration
  let k1 be Integer,a be Int_position,n be Nat;
  cluster Load (a,k1)<=0_goto n -> shiftable;
  coherence
  proof
   set k2=n;
   set ii= (a,k1)<=0_goto k2,
       J= Load ii;
     now let n,i such that
A1:    inspos n in dom J and
A2:    i=J.inspos n;
A3:    J=inspos 0 .--> ii by Def1;
       then dom J = { inspos 0 } by CQC_LANG:5;
then inspos n = inspos 0 by A1,TARSKI:def 1;
then A4:    ii =i by A2,A3,CQC_LANG:6;
       hence InsCode i <> 1 & InsCode i <> 3 by SCMPDS_2:26;
A5:    n+k2 >=0 by NAT_1:18;
     InsCode i <> 0 & InsCode i <> 4 & InsCode i <> 6 by A4,SCMPDS_2:26;
       hence i valid_at n by A4,A5,Def11;
    end;
   hence thesis by Def12;
   end;
end;


theorem :: SCMPDS_4:81
    for I being shiftable Program-block,k1,k2 be Integer,a be Int_position st
  card I + k2 >= 0 holds I ';' (a,k1)>=0_goto k2 is shiftable;

registration
  let k1 be Integer,a be Int_position,n be Nat;
  cluster Load (a,k1)>=0_goto n -> shiftable;
  coherence
  proof
   set k2=n;
   set ii= (a,k1)>=0_goto k2,
       J= Load ii;
     now let n,i such that
A1:    inspos n in dom J and
A2:    i=J.inspos n;
A3:    J=inspos 0 .--> ii by Def1;
       then dom J = { inspos 0 } by CQC_LANG:5;
then inspos n = inspos 0 by A1,TARSKI:def 1;
then A4:    ii =i by A2,A3,CQC_LANG:6;
       hence InsCode i <> 1 & InsCode i <> 3 by SCMPDS_2:27;
A5:    n+k2 >=0 by NAT_1:18;
     InsCode i <> 0 & InsCode i <> 4 & InsCode i <> 5 by A4,SCMPDS_2:27;
       hence i valid_at n by A4,A5,Def11;
    end;
   hence thesis by Def12;
   end;
end;


theorem :: SCMPDS_4:82
 for s1,s2 being State of SCMPDS, n,m being Nat,k1 be Integer st
     IC s1=inspos m & m+k1>=0 & IC s1 + n = IC s2
holds ICplusConst(s1,k1) +n = ICplusConst(s2,k1);

theorem :: SCMPDS_4:83   ::S6A_41
 for s1,s2 being State of SCMPDS, n,m being Nat,
     i being Instruction of SCMPDS holds
     IC s1=inspos m & i valid_at m & InsCode i <> 1 & InsCode i <> 3 &
     IC s1 + n = IC s2 &
     s1 | SCM-Data-Loc = s2 | SCM-Data-Loc
 implies
     IC Exec(i,s1) + n = IC Exec(i,s2) &
     Exec(i,s1) | SCM-Data-Loc = Exec(i,s2) | SCM-Data-Loc;

theorem :: SCMPDS_4:84  ::Th27 T0
   for J being parahalting shiftable Program-block st Initialized stop J c= s1
 for n being Nat st Shift(stop J,n) c= s2 &
   IC s2 = inspos n &
   s1 | SCM-Data-Loc = s2 | SCM-Data-Loc
   for i being Nat holds
     IC (Computation s1).i + n = IC (Computation s2).i &
     CurInstr ((Computation s1).i) = CurInstr ((Computation s2).i) &
     (Computation s1).i | SCM-Data-Loc = (Computation s2).i | SCM-Data-Loc;

