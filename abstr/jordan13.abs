:: Introducing Spans
::  by Andrzej Trybulec
::
:: Received May 27, 2002
:: Copyright (c) 2002 Association of Mizar Users

environ

 vocabularies JORDAN13, JORDAN11, FINSEQ_1, TOPREAL1, GOBOARD1, BOOLE,
      JORDAN1H, FINSEQ_4, EUCLID, MATRIX_1, PRE_TOPC, SEQM_3, SPPOL_1,
      SPRECT_2, GOBOARD5, ABSVALUE, CONNSP_1, TOPREAL2, ARYTM_1, TOPS_1,
      RELAT_1, FUNCT_1, SUBSET_1, RELAT_2, RFINSEQ, GOBOARD9, TARSKI, TREES_1,
      CARD_1, JORDAN8, GOBRD13, FINSEQ_5, JORDAN2C, METRIC_1, PCOMPS_1,
      GROUP_1, ARYTM, NAT_1;
 notations TARSKI, GOBOARD5, XBOOLE_0, SUBSET_1, ORDINAL1, NUMBERS, XCMPLX_0,
      XXREAL_0, XREAL_0, REAL_1, NAT_1, BINARITH, RELAT_1, FUNCT_1, FUNCT_2,
      COMPLEX1, CARD_1, NEWTON, FINSEQ_1, FINSEQ_2, FINSEQ_4, STRUCT_0,
      RFINSEQ, MATRIX_1, METRIC_1, PRE_TOPC, TOPS_1, CONNSP_1, PCOMPS_1,
      EUCLID, TOPREAL1, TOPREAL2, GOBOARD1, SPPOL_1, SPRECT_2, GOBOARD9,
      JORDAN8, GOBRD13, JORDAN2C, JORDAN1H, JORDAN11;
 constructors XXREAL_0, REAL_1, NAT_1, FINSEQ_4, NEWTON, RFINSEQ, BINARITH,
      TOPS_1, CONNSP_1, REALSET2, TOPREAL4, PSCOMP_1, GOBOARD9, SPRECT_2,
      JORDAN2C, JORDAN8, JORDAN1H, JORDAN11;
 registrations XBOOLE_0, RELAT_1, FUNCT_1, ORDINAL1, XXREAL_0, XREAL_0, NAT_1,
      MEMBERED, FINSEQ_1, STRUCT_0, EUCLID, TOPREAL2, SPPOL_2, GOBOARD9,
      SPRECT_2, SPRECT_3, TOPREAL6, JORDAN8, GOBRD13, JORDAN1A;
 requirements NUMERALS, SUBSET, BOOLE, REAL, ARITHM;


begin :: Spans

 reserve i, j, k, l, m, n, i1, i2, j1, j2 for Element of NAT;

definition let C be non vertical non horizontal non empty
                      being_simple_closed_curve Subset of TOP-REAL 2,
               n be Element of NAT;
  assume
 n is_sufficiently_large_for C;
  func Span(C,n) -> clockwise_oriented
    (standard non constant special_circular_sequence) means
:: JORDAN13:def 1
        it is_sequence_on Gauge(C,n) &
    it/.1 = Gauge(C,n)*(X-SpanStart(C,n),Y-SpanStart(C,n)) &
    it/.2 = Gauge(C,n)*(X-SpanStart(C,n)-'1,Y-SpanStart(C,n)) &
    for k being Element of NAT st 1 <= k & k+2 <= len it holds
      (front_right_cell(it,k,Gauge(C,n)) misses C &
        front_left_cell(it,k,Gauge(C,n)) misses C
          implies it turns_left k,Gauge(C,n)) &
      (front_right_cell(it,k,Gauge(C,n)) misses C &
        front_left_cell(it,k,Gauge(C,n)) meets C
          implies it goes_straight k,Gauge(C,n)) &
      (front_right_cell(it,k,Gauge(C,n)) meets C
        implies it turns_right k,Gauge(C,n));
end;

