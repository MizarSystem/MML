:: Bubble Sort on SCM+FSA
::  by JingChao Chen and Yatsuka Nakamura
::
:: Received June 17, 1998
:: Copyright (c) 1998 Association of Mizar Users

environ

 vocabularies NUMBERS, SCMNORM, SCMFSA_2, AMI_1, SUBSET_1, SCMFSA7B, SCMFSA8C,
      SCMFSA8A, AMI_3, CARD_1, AMISTD_2, SCMFSA8B, TURING_1, FSM_1, GRAPHSP,
      FUNCT_1, PARTFUN1, COMPLEX1, FUNCT_4, ARYTM_3, SCMFSA6C, SF_MASTR,
      SCMFSA6B, FUNCOP_1, ORDINAL1, RELAT_1, TARSKI, XBOOLE_0, XXREAL_0,
      CIRCUIT2, NAT_1, STRUCT_0, ARYTM_1, INT_1, FINSEQ_1, FINSEQ_2, SCMFSA6A,
      FINSUB_1, CARD_3, CLASSES1, VALUED_0, MSUALG_1, SCM_HALT, GLIB_000,
      SCMBSORT;
 notations TARSKI, XBOOLE_0, ENUMSET1, SUBSET_1, ORDINAL1, CARD_1, NUMBERS,
      XCMPLX_0, NAT_1, INT_1, RELAT_1, FINSEQ_1, FUNCT_1, COMPLEX1, FUNCT_2,
      FUNCT_4, FINSEQ_2, FUNCT_7, STRUCT_0, AMI_1, SCMNORM, SCMFSA_2, FUNCOP_1,
      SCMFSA_4, FINSUB_1, CARD_3, PARTFUN1, SCMFSA6B, SCMFSA6C, SCMFSA6A,
      SF_MASTR, SCMFSA8A, SCMFSA8B, SCMFSA8C, CLASSES1, RFINSEQ, SCMFSA7B,
      NAT_D, SCM_HALT, XXREAL_0;
 constructors PARTFUN1, SETWISEO, XXREAL_0, REAL_1, NAT_1, INT_2, SEQM_3,
      RFINSEQ, AMI_5, SCMFSA6A, SF_MASTR, SCMFSA6B, SCMFSA6C, SCMFSA8A,
      SCMFSA8B, SCMFSA8C, SCM_HALT, SEQ_1, SCMNORM, SCMFSA_4, NAT_D, CLASSES1,
      RELSET_1, SCMFSA_1;
 registrations XBOOLE_0, SETFAM_1, FUNCT_1, RELSET_1, FUNCOP_1, FINSUB_1,
      NUMBERS, XXREAL_0, XREAL_0, NAT_1, INT_1, CARD_3, RFINSEQ, AMI_1,
      SCMFSA_2, SF_MASTR, SCMFSA6C, SCMFSA7B, FINSET_1, SCMFSA8A, SCMFSA8B,
      SCMFSA_9, SCM_HALT, STRUCT_0, VALUED_0, ORDINAL1;
 requirements REAL, NUMERALS, SUBSET, BOOLE, ARITHM;


begin :: Preliminaries

reserve p for preProgram of SCM+FSA,
  ic for Instruction of SCM+FSA,
  i,j,k for Element of NAT,
  fa,f for FinSeq-Location,
  a,b,da,db for Int-Location,
  la,lb for Instruction-Location of SCM+FSA;

canceled 2;

theorem :: SCMBSORT:3
  for I being Program of SCM+FSA,a,b being Int-Location st
  I does_not_destroy b & a<>b holds Times(a,I) does_not_destroy b;

canceled 4;

theorem :: SCMBSORT:8
  for s be State of SCM+FSA,f be FinSeq-Location,a,b be Int-Location
  holds Exec(b:=(f,a), s).b = (s.f)/.abs(s.a);

theorem :: SCMBSORT:9
  for s be State of SCM+FSA,f be FinSeq-Location,a,b be Int-Location
  holds Exec((f,a):=b, s).f = s.f+*(abs(s.a),s.b);

theorem :: SCMBSORT:10
  for s be State of SCM+FSA,f be FinSeq-Location,m,n be Element of NAT,
  a be Int-Location
  st m<>n+1 holds Exec(intloc m:=(f,a), Initialize s).intloc (n+1)
  =s.intloc (n+1);

theorem :: SCMBSORT:11
  for s be State of SCM+FSA,m,n be Element of NAT,a be Int-Location
  st m<>n+1 holds Exec(intloc m:=a, Initialize s).intloc (n+1) =s.intloc (n+1);

theorem :: SCMBSORT:12
  for s be State of SCM+FSA, f be FinSeq-Location, a be read-write Int-Location
  holds IExec(Stop SCM+FSA,s).a =s.a & IExec(Stop SCM+FSA,s).f =s.f;

reserve n for natural number;

canceled 3;

theorem :: SCMBSORT:16
  ic in rng p & (ic = a:=b or ic = AddTo(a, b) or ic = SubFrom(a, b) or
  ic = MultBy(a, b) or ic = Divide(a, b))
  implies a in UsedIntLoc p & b in UsedIntLoc p;

theorem :: SCMBSORT:17
  ic in rng p & (ic = a=0_goto la or ic = a>0_goto la)
  implies a in UsedIntLoc p;

theorem :: SCMBSORT:18
  ic in rng p & ( ic = b := (fa, a) or ic = (fa, a) := b)
  implies a in UsedIntLoc p & b in UsedIntLoc p;

theorem :: SCMBSORT:19
  ic in rng p & ( ic = b := (fa, a) or ic = (fa, a) := b)
  implies fa in UsedInt*Loc p;

theorem :: SCMBSORT:20
  ic in rng p & (ic = a :=len fa or ic = fa :=<0,...,0>a)
  implies a in UsedIntLoc p;

theorem :: SCMBSORT:21
  ic in rng p & (ic = a :=len fa or ic = fa :=<0,...,0>a)
  implies fa in UsedInt*Loc p;

canceled;

theorem :: SCMBSORT:23
  for t being FinPartState of SCM+FSA,p being Program of SCM+FSA,
  x being set st dom t c= Int-Locations \/ FinSeq-Locations &
  x in dom t \/ UsedInt*Loc p \/ UsedIntLoc p
  holds x is Int-Location or x is FinSeq-Location;

canceled;

theorem :: SCMBSORT:25
  for i,k being Element of NAT,t being FinPartState of SCM+FSA,
  p being Program of SCM+FSA, s1,s2 being State of SCM+FSA
  st k <= i & p c= s1 & p c= s2 & dom t c= Int-Locations \/ FinSeq-Locations &
  (for j holds IC Computation(s1,j) in dom p &
  IC Computation(s2,j) in dom p) &
  Computation(s1,k).IC SCM+FSA = Computation(s2,k).IC SCM+FSA &
  Computation(s1,k) |(dom t \/ UsedInt*Loc p \/ UsedIntLoc p) =
  Computation(s2,k) |(dom t \/ UsedInt*Loc p \/ UsedIntLoc p) holds
  Computation(s1,i).IC SCM+FSA = Computation(s2,i).IC SCM+FSA &
  Computation(s1,i) |(dom t \/ UsedInt*Loc p \/ UsedIntLoc p) =
  Computation(s2,i) |(dom t \/ UsedInt*Loc p \/ UsedIntLoc p);

theorem :: SCMBSORT:26
  for i,k being Element of NAT,p being Program of SCM+FSA,
  s1,s2 being State of SCM+FSA st k <= i & p c= s1 & p c= s2 &
  (for j holds IC Computation(s1,j) in dom p &
  IC Computation(s2,j) in dom p) &
  Computation(s1,k).IC SCM+FSA = Computation(s2,k).IC SCM+FSA &
  Computation(s1,k) | (UsedInt*Loc p \/ UsedIntLoc p) =
  Computation(s2,k) | (UsedInt*Loc p \/ UsedIntLoc p) holds
  Computation(s1,i).IC SCM+FSA = Computation(s2,i).IC SCM+FSA &
  Computation(s1,i) |(UsedInt*Loc p \/ UsedIntLoc p) =
  Computation(s2,i) |(UsedInt*Loc p \/ UsedIntLoc p);

canceled 2;

theorem :: SCMBSORT:29
  for I,J being Program of SCM+FSA, a being Int-Location holds
  UsedIntLoc if=0(a,I,J) = {a} \/ UsedIntLoc I \/ UsedIntLoc J &
  UsedIntLoc if>0(a,I,J) = {a} \/ UsedIntLoc I \/ UsedIntLoc J;

theorem :: SCMBSORT:30
  for I be Program of SCM+FSA,l be Instruction-Location of SCM+FSA holds
  UsedIntLoc (Directed(I,l)) = UsedIntLoc I;

theorem :: SCMBSORT:31
  for a being Int-Location,I being Program of SCM+FSA holds
  UsedIntLoc Times(a,I) = UsedIntLoc I \/ {a,intloc 0};

canceled 3;

theorem :: SCMBSORT:35
  for I,J being Program of SCM+FSA, a being Int-Location holds
  UsedInt*Loc if=0(a,I,J) = UsedInt*Loc I \/ UsedInt*Loc J &
  UsedInt*Loc if>0(a,I,J) = UsedInt*Loc I \/ UsedInt*Loc J;

theorem :: SCMBSORT:36
  for I be Program of SCM+FSA,l be Instruction-Location of SCM+FSA holds
  UsedInt*Loc (Directed(I,l)) = UsedInt*Loc I;

theorem :: SCMBSORT:37
  for a being Int-Location,I being Program of SCM+FSA holds
  UsedInt*Loc Times(a,I) = UsedInt*Loc I;

definition
  let f be FinSeq-Location,t be FinSequence of INT;
  redefine func f .--> t -> FinPartState of SCM+FSA;
end;

theorem :: SCMBSORT:38
  for t be FinSequence of INT holds t is FinSequence of REAL;

theorem :: SCMBSORT:39
  for t being FinSequence of INT holds ex u being FinSequence of REAL
  st t,u are_fiberwise_equipotent & u is FinSequence of INT
  & u is non-increasing;

theorem :: SCMBSORT:40
  dom( ((intloc 0) .--> 1) +* Start-At(insloc 0) ) ={intloc 0,IC SCM+FSA};

theorem :: SCMBSORT:41
  for I be Program of SCM+FSA holds
  dom (Initialized I) = dom I \/ {intloc 0,IC SCM+FSA};

theorem :: SCMBSORT:42
  for w being FinSequence of INT,f be FinSeq-Location,I be Program of SCM+FSA
  holds dom (Initialized I +* (f.--> w)) = dom I \/ {intloc 0,IC SCM+FSA,f};

theorem :: SCMBSORT:43
  for l being Instruction-Location of SCM+FSA holds IC SCM+FSA <> l;

theorem :: SCMBSORT:44
  for a being Int-Location,I being Program of SCM+FSA holds
  card Times(a,I) = card I + 12;

theorem :: SCMBSORT:45
  for i1,i2,i3 be Instruction of SCM+FSA holds card (i1 ';' i2 ';' i3)=6;

theorem :: SCMBSORT:46
  for t be FinSequence of INT,f be FinSeq-Location,I be Program of SCM+FSA
  holds dom (Initialized I) misses dom (f .--> t);

theorem :: SCMBSORT:47
  for w be FinSequence of INT,f be FinSeq-Location,I be Program of SCM+FSA
  holds Initialized I +* (f .--> w) starts_at 0;

theorem :: SCMBSORT:48
  for I,J being Program of SCM+FSA, k being Element of NAT,
  i being Instruction of SCM+FSA st k< card J & i = J.insloc k holds
  (I ';' J).(insloc (card I +k)) =IncAddr( i, card I );

theorem :: SCMBSORT:49
  ic = a:=b or ic = AddTo(a, b) or ic = SubFrom(a, b) or
  ic = MultBy(a, b) or ic = Divide(a, b) or ic = goto la or ic = a=0_goto la
  or ic = a>0_goto la or ic = b := (f, a) or ic = (f, a) := b or
  ic = a :=len f or ic = f :=<0,...,0>a implies ic <> halt SCM+FSA;

theorem :: SCMBSORT:50
  for I,J be Program of SCM+FSA,k be Element of NAT,
  i be Instruction of SCM+FSA st
  (for n be Element of NAT holds IncAddr( i, n)=i) & i <> halt SCM+FSA &
  k= card I holds (I ';' i ';' J).(insloc k) = i &
  (I ';' i ';' J).(insloc (k+1)) = goto insloc (card I+2);

theorem :: SCMBSORT:51
  for I,J being Program of SCM+FSA, k being Element of NAT holds
  k= card I implies (I ';'(a:=b) ';' J).(insloc k) = a:= b
  & (I ';'(a:=b) ';' J).(insloc (k+1)) = goto insloc (card I+2);

theorem :: SCMBSORT:52
  for I,J being Program of SCM+FSA, k being Element of NAT holds
  k= card I implies (I ';'(a:=len f) ';' J).(insloc k) = a:=len f
  & (I ';'(a:=len f) ';' J).(insloc (k+1)) = goto insloc (card I+2);

theorem :: SCMBSORT:53
  for w being FinSequence of INT,f be FinSeq-Location,s being State of SCM+FSA,
  I be Program of SCM+FSA st Initialized I +* (f.--> w) c= s holds I c= s;

theorem :: SCMBSORT:54
  for w being FinSequence of INT,f be FinSeq-Location,s be State of SCM+FSA,
  I be Program of SCM+FSA st Initialized I +* (f .--> w) c= s
  holds s.f = w & s.(intloc 0) = 1;

theorem :: SCMBSORT:55
  for f being FinSeq-Location,a being Int-Location,s being State of SCM+FSA
  holds {a,IC SCM+FSA,f} c= dom s;

theorem :: SCMBSORT:56
  for p being Program of SCM+FSA,s being State of SCM+FSA holds
  UsedInt*Loc p \/ UsedIntLoc p c= dom s;

theorem :: SCMBSORT:57
  for s be State of SCM+FSA,I be Program of SCM+FSA,f be FinSeq-Location
  holds (Result (s +* Initialized I)).f = IExec(I,s).f;

:: set a0 = intloc 0;
:: set a1 = intloc 1;
:: set a2 = intloc 2;
:: set a3 = intloc 3;
:: set a4 = intloc 4;
:: set a5 = intloc 5;
:: set a6 = intloc 6;
:: set initializeWorkMem= (a2:= a0) ';' (a3:= a0) ';'
::                  (a4:= a0) ';' (a5:= a0) ';' (a6:= a0);

definition
  let f be FinSeq-Location;
  func bubble-sort f -> Program of SCM+FSA equals
:: SCMBSORT:def 1
  ( ((intloc 2):= (intloc 0)) ';' ((intloc 3):= (intloc 0)) ';'
  ((intloc 4):= (intloc 0)) ';' ((intloc 5):= (intloc 0)) ';'
  ((intloc 6):= (intloc 0)) ) ';' ((intloc 1):=len f) ';' Times((intloc 1),
  (intloc 2) := (intloc 1) ';' SubFrom(intloc 2,intloc 0) ';'
  ((intloc 3):=len f) ';' Times(intloc 2, (intloc 4):=(intloc 3) ';'
  SubFrom(intloc 3,intloc 0) ';' ((intloc 5):=(f,intloc 3)) ';'
  ((intloc 6):=(f,(intloc 4))) ';' SubFrom(intloc 6,intloc 5) ';'
  if>0(intloc 6,((intloc 6):=(f,intloc 4)) ';' ((f,intloc 3):=(intloc 6)) ';'
  ((f,intloc 4):=(intloc 5)),Stop SCM+FSA) ) );
end;

definition
  func Bubble-Sort-Algorithm -> Program of SCM+FSA equals
:: SCMBSORT:def 2
  bubble-sort fsloc 0;
end;

theorem :: SCMBSORT:58
  for f being FinSeq-Location holds
  UsedIntLoc (bubble-sort f) = {intloc 0,intloc 1,intloc 2,intloc 3, intloc 4,
  intloc 5,intloc 6};

theorem :: SCMBSORT:59
  for f being FinSeq-Location holds UsedInt*Loc (bubble-sort f) = {f};

definition
  func Sorting-Function -> PartFunc of FinPartSt SCM+FSA,FinPartSt SCM+FSA
  means
:: SCMBSORT:def 3

  for p,q being FinPartState of SCM+FSA holds [p,q] in it
  iff ex t being FinSequence of INT,u being FinSequence of REAL
  st t,u are_fiberwise_equipotent & u is FinSequence of INT &
  u is non-increasing & p = fsloc 0 .--> t & q = fsloc 0 .--> u;
end;

theorem :: SCMBSORT:60
  for p being set holds p in dom Sorting-Function iff
  ex t being FinSequence of INT st p = fsloc 0 .--> t;

theorem :: SCMBSORT:61
  for t being FinSequence of INT holds
  ex u being FinSequence of REAL st t,u are_fiberwise_equipotent &
  u is non-increasing & u is FinSequence of INT &
  Sorting-Function.(fsloc 0 .--> t ) = fsloc 0 .--> u;

theorem :: SCMBSORT:62
  for f being FinSeq-Location holds card (bubble-sort f) = 63;

theorem :: SCMBSORT:63
  for f being FinSeq-Location, k being Element of NAT st
  k < 63 holds insloc k in dom (bubble-sort f);

theorem :: SCMBSORT:64
  bubble-sort (fsloc 0) is keepInt0_1 InitHalting;

theorem :: SCMBSORT:65
  for s be State of SCM+FSA holds
  s.(fsloc 0), IExec(bubble-sort (fsloc 0),s).(fsloc 0)
  are_fiberwise_equipotent &
  for i,j be Element of NAT st i>=1 & j<=len (s.(fsloc 0)) & i<j
  for x1,x2 be Integer st x1 =IExec(bubble-sort (fsloc 0),s).(fsloc 0).i &
  x2=IExec(bubble-sort (fsloc 0),s).(fsloc 0).j holds x1 >= x2;

theorem :: SCMBSORT:66
  for i being Element of NAT, s being State of SCM+FSA,
  w being FinSequence of INT
  st Initialized Bubble-Sort-Algorithm +* ((fsloc 0) .--> w) c= s
  holds IC Computation( s,i) in dom Bubble-Sort-Algorithm;

theorem :: SCMBSORT:67
  for s be State of SCM+FSA,t be FinSequence of INT st
  Initialized Bubble-Sort-Algorithm +*(fsloc 0 .--> t) c= s
  holds ex u being FinSequence of REAL
  st t,u are_fiberwise_equipotent & u is non-increasing &
  u is FinSequence of INT & (Result s).(fsloc 0) = u;

theorem :: SCMBSORT:68
  for w being FinSequence of INT holds
  Initialized Bubble-Sort-Algorithm +* ((fsloc 0) .--> w) is autonomic;

theorem :: SCMBSORT:69
  Initialized Bubble-Sort-Algorithm computes Sorting-Function;

