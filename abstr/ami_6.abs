:: On the Instructions of { \bf SCM }
::  by Artur Korni{\l}owicz
::
:: Received May 8, 2001
:: Copyright (c) 2001 Association of Mizar Users

environ

 vocabularies NUMBERS, AMI_3, AMI_1, FSM_1, ORDINAL1, AMI_2, CAT_1, XBOOLE_0,
      FUNCT_7, FUNCT_1, RELAT_1, STRUCT_0, FINSEQ_1, CARD_1, AMISTD_2, GRAPHSP,
      CARD_3, AMISTD_1, SUBSET_1, CIRCUIT2, FUNCT_4, FUNCOP_1, SETFAM_1,
      ZFMISC_1, XXREAL_0, TARSKI, ARYTM_3, GOBOARD5, FRECHET, ARYTM_1, INT_1,
      UNIALG_1, CARD_5, PARTFUN1, NAT_1, SCMNORM;
 notations TARSKI, XBOOLE_0, SUBSET_1, SETFAM_1, RELAT_1, FUNCT_1, FUNCT_2,
      REALSET1, ORDINAL1, NAT_1, NUMBERS, XCMPLX_0, INT_1, FUNCOP_1, PARTFUN1,
      FINSEQ_1, FUNCT_4, XXREAL_0, MCART_1, VALUED_1, STRUCT_0, CARD_3,
      FUNCT_7, COMPOS_1, EXTPRO_1, AMI_2, AMI_3, AMISTD_1, AMISTD_2;
 constructors XXREAL_0, NAT_1, NAT_D, REALSET1, AMI_5, AMISTD_2, RELSET_1,
      RECDEF_2, MCART_1, VALUED_1, AMI_2, EXTPRO_1, AMI_1;
 registrations XBOOLE_0, SETFAM_1, RELAT_1, FUNCT_1, ORDINAL1, FUNCOP_1,
      NUMBERS, XREAL_0, NAT_1, INT_1, FINSEQ_1, CARD_3, AMI_1, AMI_3, AMISTD_2,
      RELSET_1, ZFMISC_1, FUNCT_2, FUNCT_4, VALUED_0, COMPOS_1, EXTPRO_1;
 requirements NUMERALS, BOOLE, SUBSET, REAL, ARITHM;


begin

reserve a, b, d1, d2 for Data-Location,
  il, i1, i2 for Element of NAT,
  I for Instruction of SCM,
  s, s1, s2 for State of SCM,
  T for InsType of SCM,
  k,k1 for natural number;

theorem :: AMI_6:1
  not a in NAT;

theorem :: AMI_6:2
  SCM-Data-Loc <> NAT;

theorem :: AMI_6:3
  for o being Object of SCM holds o = IC SCM or o in NAT or o is
  Data-Location;

canceled;

theorem :: AMI_6:5
  s1,s2 equal_outside NAT implies s1.a = s2.a;


registration
 cluster InsCodes SCM -> non empty;
end;

canceled;

theorem :: AMI_6:7
 T = 0 or T = 1 or T = 2 or T = 3 or T = 4 or T = 5 or T = 6 or T = 7 or T
= 8;

canceled;

theorem :: AMI_6:9
  JumpPart halt SCM = {};

canceled 8;

theorem :: AMI_6:18
  T = 0 implies JumpParts T = {0};

theorem :: AMI_6:19
  T = 1 implies JumpParts T = {{}};

theorem :: AMI_6:20
  T = 2 implies JumpParts T = {{}};

theorem :: AMI_6:21
  T = 3 implies JumpParts T = {{}};

theorem :: AMI_6:22
  T = 4 implies JumpParts T = {{}};

theorem :: AMI_6:23
  T = 5 implies JumpParts T = {{}};

theorem :: AMI_6:24
  T = 6 implies dom product" JumpParts T = {1};

theorem :: AMI_6:25
  T = 7 implies dom product" JumpParts T = {1};

theorem :: AMI_6:26
  T = 8 implies dom product" JumpParts T = {1};

canceled 10;

theorem :: AMI_6:37
  (product" JumpParts InsCode SCM-goto k1).1 = NAT;

theorem :: AMI_6:38
  (product" JumpParts InsCode (a =0_goto k1)).1 = NAT;

canceled;

theorem :: AMI_6:40
  (product" JumpParts InsCode (a >0_goto k1)).1 = NAT;

canceled;

theorem :: AMI_6:42
  NIC(halt SCM, il) = {il};

registration
  cluster JUMP halt SCM -> empty;
end;

theorem :: AMI_6:43
  NIC(a := b, il) = {succ il};

registration
  let a, b;
  cluster JUMP (a := b) -> empty;
end;

theorem :: AMI_6:44
  NIC(AddTo(a,b), il) = {succ il};

registration
  let a, b;
  cluster JUMP AddTo(a, b) -> empty;
end;

theorem :: AMI_6:45
  NIC(SubFrom(a,b), il) = {succ il};

registration
  let a, b;
  cluster JUMP SubFrom(a, b) -> empty;
end;

theorem :: AMI_6:46
  NIC(MultBy(a,b), il) = {succ il};

registration
  let a, b;
  cluster JUMP MultBy(a,b) -> empty;
end;

theorem :: AMI_6:47
  NIC(Divide(a,b), il) = {succ il};

registration
  let a, b;
  cluster JUMP Divide(a,b) -> empty;
end;

theorem :: AMI_6:48
  NIC(SCM-goto k, il) = {k};

theorem :: AMI_6:49
  JUMP SCM-goto k = {k};

registration
  let i1;
  cluster JUMP SCM-goto i1 -> non empty trivial;
end;

theorem :: AMI_6:50
  NIC(a=0_goto k, il) = {k, succ il};

theorem :: AMI_6:51
  JUMP (a=0_goto k) = {k};

registration
  let a, i1;
  cluster JUMP (a =0_goto i1) -> non empty trivial;
end;

theorem :: AMI_6:52
  NIC(a>0_goto k, il) = {k, succ il};

theorem :: AMI_6:53
  JUMP (a>0_goto k) = {k};

registration
  let a, i1;
  cluster JUMP (a >0_goto i1) -> non empty trivial;
end;

theorem :: AMI_6:54
  SUCC(il,SCM) = {il, succ il};

theorem :: AMI_6:55
for k being Element of NAT holds k+1 in SUCC(k,SCM) &
 for j being Element of NAT st j in SUCC(k,SCM) holds k <= j;

registration
  cluster SCM -> standard;
end;

registration
  cluster InsCode halt SCM -> jump-only InsType of SCM;
end;

registration
  cluster halt SCM -> jump-only;
end;

registration
  let i1;
  cluster InsCode SCM-goto i1 -> jump-only InsType of SCM;
end;

registration
  let i1;
  cluster SCM-goto i1 -> jump-only non sequential non ins-loc-free;
end;

registration
  let a, i1;
  cluster InsCode (a =0_goto i1) -> jump-only InsType of SCM;
  cluster InsCode (a >0_goto i1) -> jump-only InsType of SCM;
end;

registration
  let a, i1;
  cluster a =0_goto i1 -> jump-only non sequential non ins-loc-free;
  cluster a >0_goto i1 -> jump-only non sequential non ins-loc-free;
end;

registration
  let a, b;
  cluster InsCode (a:=b) -> non jump-only InsType of SCM;
  cluster InsCode AddTo(a,b) -> non jump-only InsType of SCM;
  cluster InsCode SubFrom(a,b) -> non jump-only InsType of SCM;
  cluster InsCode MultBy(a,b) -> non jump-only InsType of SCM;
  cluster InsCode Divide(a,b) -> non jump-only InsType of SCM;
end;

registration
  let a, b;
  cluster a:=b -> non jump-only sequential;
  cluster AddTo(a,b) -> non jump-only sequential;
  cluster SubFrom(a,b) -> non jump-only sequential;
  cluster MultBy(a,b) -> non jump-only sequential;
  cluster Divide(a,b) -> non jump-only sequential;
end;

registration
  cluster SCM -> homogeneous with_explicit_jumps;
end;

registration
  cluster SCM -> regular J/A-independent;
end;

canceled 3;

theorem :: AMI_6:59
  IncAddr(SCM-goto i1,k) = SCM-goto(i1+k);

theorem :: AMI_6:60
  IncAddr(a=0_goto i1,k) = a=0_goto(i1+k);

theorem :: AMI_6:61
  IncAddr(a>0_goto i1,k) = a>0_goto(i1+k);

registration
  cluster SCM -> IC-good Exec-preserving;
end;

