:: The Class of Series --- Parallel Graphs, {I}
::  by Krzysztof Retel
::
:: Received November 18, 2002
:: Copyright (c) 2002 Association of Mizar Users

environ

 vocabulary ORDINAL2, ARYTM_3, NECKLACE, FUNCT_3, ARYTM, FUNCT_2, PARTFUN1,
      ORDERS_1, PRE_TOPC, RELAT_1, RELAT_2, REALSET1, FUNCT_1, BOOLE, SEQM_3,
      SUBSET_1, WELLORD1, CAT_1, FUNCOP_1, FUNCT_4, ARYTM_1, TARSKI, CARD_1,
      CARD_2, FINSET_1, SQUARE_1, INCPROJ;
 notation TARSKI, XBOOLE_0, ENUMSET1, SUBSET_1, ZFMISC_1, CARD_1, CARD_2,
      WELLORD1, FINSET_1, SQUARE_1, QUIN_1, REALSET1, ORDINAL1, NUMBERS,
      XCMPLX_0, XREAL_0, REAL_1, NAT_1, STRUCT_0, ORDERS_1, RELAT_1, RELAT_2,
      BINARITH, BVFUNC24, FUNCT_3, CQC_LANG, FUNCOP_1, RELSET_1, FUNCT_1,
      PARTFUN1, FUNCT_2, FUNCT_4, ORDINAL2, WAYBEL_0, WAYBEL_1, ORDERS_3,
      PRE_TOPC;
 constructors ORDERS_3, QUIN_1, ENUMSET1, CARD_2, BVFUNC24, SQUARE_1, WELLORD1,
      WAYBEL_1, SEQM_3, REAL_1, BINARITH, AMISTD_1, MEMBERED, PRE_TOPC;
 clusters RELSET_1, ORDERS_1, STRUCT_0, SUBSET_1, ARYTM_3, XREAL_0, HILBERT3,
      TEX_2, FUNCT_1, FUNCT_4, FINSET_1, AFINSQ_1, SQUARE_1, ORDERS_3,
      TOPREAL8, FUNCOP_1, AMISTD_1, MEMBERED, FUNCT_2, NUMBERS, ORDINAL2;
 requirements BOOLE, SUBSET, NUMERALS, REAL, ARITHM;


begin    :: Preliminaries

 reserve i,j,k,n for natural number;
 reserve x,x1,x2,x3,x4,x5,y1,y2,y3 for set;

definition let x1,x2,x3,x4,x5 be set;
  pred x1, x2, x3, x4, x5 are_mutually_different means
:: NECKLACE:def 1
  x1 <> x2 & x1 <> x3 & x1 <> x4 & x1 <> x5 & x2 <> x3 &
  x2 <> x4 & x2 <> x5 & x3 <> x4 & x3 <> x5 & x4 <> x5;
end;


theorem :: NECKLACE:1
     x1,x2,x3,x4,x5 are_mutually_different
   implies card {x1,x2,x3,x4,x5} = 5;

theorem :: NECKLACE:2
   4 = {0,1,2,3};

theorem :: NECKLACE:3
   [:{x1,x2,x3},{y1,y2,y3}:] =
   {[x1,y1],[x1,y2],[x1,y3],[x2,y1],[x2,y2],[x2,y3],[x3,y1],[x3,y2],[x3,y3]};

theorem :: NECKLACE:4
   for x being set, n be natural number holds
       x in n implies x is natural number;

theorem :: NECKLACE:5
   for x be non empty natural number holds 0 in x;

registration
 cluster natural -> cardinal set;
 coherence
  proof
   let X be set;
   assume X is natural;
   then X in omega by ORDINAL2:def 21;
   hence X is cardinal by CARD_1:65;
  end;
end;


registration
 let X be set;
 cluster delta X -> one-to-one;
 coherence
  proof
   let x1,x2 be set;
   set f = delta X;
   assume that A1:x1 in dom f and A2: x2 in dom f and A3: f.x1 = f.x2;
A4:  f.x1 = [x1,x1] by A1,FUNCT_3:def 7;
    f.x2 = [x2,x2] by A2,FUNCT_3:def 7;
  hence thesis by A3,A4,ZFMISC_1:33;
  end;
end;


theorem :: NECKLACE:6
   for X being set holds Card id X = Card X;

registration let R be trivial Relation;
  cluster dom R -> trivial;
  coherence
  proof
  per cases by REALSET1:def 12;
  suppose R is empty;
  hence thesis by RELAT_1:60;
  end;
  suppose ex x being set st R = {x};
  then consider x being set such that
A1:  R = {x};
    x in R by A1,TARSKI:def 1;
  then consider y,z being set such that
A2:  x=[y,z] by RELAT_1:def 1;
    dom R = {y} by A1,A2,RELAT_1:23;
  hence thesis;
  end;
  end;
end;


registration
  cluster trivial -> one-to-one Function;
  coherence
  proof
  let f be Function such that
A1:  f is trivial;
  let x1,x2 be set;
  assume that
A2:  x1 in dom f & x2 in dom f and
    f.x1 = f.x2;
  reconsider f as trivial Function by A1;
  consider x being set such that
A3: dom f = {x} by A2,REALSET1:def 12;
    x1 = x & x2 = x by A2,A3,TARSKI:def 1;
  hence thesis;
  end;
end;


theorem :: NECKLACE:7
   for f,g be Function st dom f misses dom g holds
        rng(f +* g) = rng f \/ rng g;

theorem :: NECKLACE:8
   for f,g be one-to-one Function st dom f misses dom g &
   rng f misses rng g holds (f+*g)" = f" +* g";

theorem :: NECKLACE:9
    for A,a,b being set holds (A --> a) +* (A --> b) = A --> b;

theorem :: NECKLACE:10
  for a,b being set holds (a .--> b)" = b .--> a;

theorem :: NECKLACE:11
  for a,b,c,d being set st a = b iff c = d
       holds (a,b) --> (c,d)" = (c,d) --> (a,b);

scheme :: NECKLACE:sch 1
 Convers{X()-> non empty set, R() -> Relation, F,G(set)-> set, P[set]}:
 R()~ ={[F(x),G(x)] where x is Element of X(): P[x]}
 provided
  R() = {[G(x),F(x)] where x is Element of X(): P[x]}
proof
 set S = {[F(x),G(x)] where x is Element of X(): P[x]};
   S is Relation-like
 proof
  let x being set;
  assume x in S;
  then ex y being Element of X() st x = [F(y),G(y)] & P[y];
  hence thesis;
 end;
 then reconsider S' = S as Relation;
    for x,y being set holds [x,y] in S' iff [y,x] in R()
  proof
A2:   for x,y being set holds [x,y] in S' implies [y,x] in R()
   proof
    let x,y being set;
    assume [x,y] in S';
    then consider z being Element of X() such that
A3:   [x,y] = [F(z),G(z)] and
A4:   P[z];
     x = F(z) & y = G(z) by A3,ZFMISC_1:33;
    hence thesis by A1,A4;
   end;
     for x,y being set holds [y,x] in R() implies [x,y] in S'
   proof
    let x,y being set;
    assume [y,x] in R();
    then consider z being Element of X() such that
A5:   [y,x] = [G(z),F(z)] and
A6:   P[z] by A1;
     y = G(z) & x = F(z) by A5,ZFMISC_1:33;
    hence thesis by A6;
   end;
   hence thesis by A2;
  end;
 hence S = R()~ by RELAT_1:def 7;
end;

theorem :: NECKLACE:12
     for i,j,n be natural number holds
   i < j & j in n implies i in n;

begin   :: Auxiliary Concepts

definition let R,S be RelStr;
  pred S embeds R means
:: NECKLACE:def 2
  ex f being map of R,S st f is one-to-one
  & for x,y being Element of R holds
  [x,y] in the InternalRel of R iff [f.x,f.y] in the InternalRel of S;
end;


definition let R,S be non empty RelStr;
  redefine pred S embeds R;
 reflexivity;
end;


theorem :: NECKLACE:13
   for R,S,T be non empty RelStr holds
   R embeds S & S embeds T implies R embeds T;

definition let R,S be non empty RelStr;
 pred R is_equimorphic_to S means
:: NECKLACE:def 3
 R embeds S & S embeds R;
 reflexivity;
 symmetry;
end;


theorem :: NECKLACE:14
     for R,S,T be non empty RelStr holds
   R is_equimorphic_to S & S is_equimorphic_to T implies
   R is_equimorphic_to T;

notation
  let R be non empty RelStr;
  antonym R is parallel for R is connected;
  end;


definition let R be RelStr;
 attr R is symmetric means
:: NECKLACE:def 4
 the InternalRel of R is_symmetric_in the carrier of R;
end;


definition let R be RelStr;
 attr R is asymmetric means
:: NECKLACE:def 5
 the InternalRel of R is asymmetric;
end;


theorem :: NECKLACE:15
     for R be RelStr st R is asymmetric holds
   the InternalRel of R misses (the InternalRel of R)~;

definition let R be RelStr;
 attr R is irreflexive means
:: NECKLACE:def 6
   for x being set st x in the carrier of R
 holds not [x,x] in the InternalRel of R;
end;


definition
 let n be natural number;
 func n-SuccRelStr -> strict RelStr means
:: NECKLACE:def 7
 the carrier of it = n &
 the InternalRel of it = {[i,i+1] where i is Nat:i+1 < n};
end;


theorem :: NECKLACE:16
     for n be natural number holds n-SuccRelStr is asymmetric;

theorem :: NECKLACE:17
   n > 0 implies Card the InternalRel of n-SuccRelStr = n-1;

definition let R be RelStr;
 func SymRelStr R -> strict RelStr means
:: NECKLACE:def 8
 the carrier of it = the carrier of R &
 the InternalRel of it = (the InternalRel of R) \/ (the InternalRel of R)~;
end;


registration let R be RelStr;
 cluster SymRelStr R -> symmetric;
 coherence
  proof
   let x,y be set;
   assume that x in the carrier of SymRelStr R &
                   y in the carrier of SymRelStr R and
               A1: [x,y] in the InternalRel of SymRelStr R;
A2:  [x,y] in (the InternalRel of R) \/ (the InternalRel of R)~ by A1,Def8;
  per cases by A2,XBOOLE_0:def 2;
  suppose [x,y] in the InternalRel of R;
   then [y,x] in (the InternalRel of R)~ by RELAT_1:def 7;
   then [y,x] in (the InternalRel of R) \/ (the InternalRel of R)~
                      by XBOOLE_0:def 2;
  hence thesis by Def8;
  end;
  suppose [x,y] in (the InternalRel of R)~;
   then [y,x] in the InternalRel of R by RELAT_1:def 7;
   then [y,x] in (the InternalRel of R) \/ (the InternalRel of R)~
                      by XBOOLE_0:def 2;
  hence thesis by Def8;
  thus thesis;
  end;
  end;
end;


registration
 cluster non empty symmetric RelStr;
 existence
  proof
   set R = {[0,0]};
     R c= [:{0},{0}:] by ZFMISC_1:35;
   then reconsider R = {[0,0]} as Relation of {0} by RELSET_1:def 1;
   take S = RelStr (#{0},R#);
   thus S is non empty;
   thus the InternalRel of S is_symmetric_in the carrier of S
    proof
     let x,y be set;
     assume that x in the carrier of S &
                     y in the carrier of S and
                 A1: [x,y] in the InternalRel of S;
       x = 0 & y = 0 by A1,ZFMISC_1:34;
     then [y,x] in [:{0},{0}:] by ZFMISC_1:34;
     hence [y,x] in the InternalRel of S by ZFMISC_1:35;
    end;
  end;
end;


registration let R be symmetric RelStr;
 cluster the InternalRel of R -> symmetric;
 coherence
 proof
  let x,y be set;
  assume that A1: x in field the InternalRel of R &
                  y in field the InternalRel of R and
              A2: [x,y] in the InternalRel of R;
A3:  the InternalRel of R is_symmetric_in the carrier of R by Def4;
    field the InternalRel of R c= (the carrier of R) \/ the carrier of R
        by RELSET_1:19;
  hence thesis by A1,A2,A3,RELAT_2:def 3;
 end;
end;

definition let R be RelStr;
  func ComplRelStr R -> strict RelStr means
:: NECKLACE:def 9
  the carrier of it = the carrier of R &
  the InternalRel of it = (the InternalRel of R)` \
   id (the carrier of R);
end;


registration let R be non empty RelStr;
 cluster ComplRelStr R -> non empty;
 coherence
  proof
     the carrier of ComplRelStr R = the carrier of R by Def9;
   hence the carrier of ComplRelStr R is non empty;
  end;
end;


theorem :: NECKLACE:18
   for S,R being RelStr holds
   S,R are_isomorphic implies
   Card the InternalRel of S = Card the InternalRel of R;

begin   :: Necklace n

definition let n be natural number;
 func Necklace n -> strict RelStr equals
:: NECKLACE:def 10
 SymRelStr(n-SuccRelStr);
end;


registration let n be natural number;
 cluster Necklace n -> symmetric;
 coherence
 proof
    Necklace n = SymRelStr(n-SuccRelStr) by Def10;
  hence thesis;
 end;
end;


theorem :: NECKLACE:19
   the InternalRel of Necklace n
   = {[i,i+1] where i is Nat:i+1 < n} \/ {[i+1,i] where i is Nat:i+1 < n};

theorem :: NECKLACE:20
   for x be set holds x in the InternalRel of Necklace n iff
           ex i being Nat st i+1 < n & (x = [i,i+1] or x = [i+1,i]);

registration let n be natural number;
  cluster Necklace n -> irreflexive;
  coherence
  proof
  set A = Necklace n;
  let x be set;
  assume x in the carrier of A;
  assume A1:[x,x] in the InternalRel of A;
A2:  the InternalRel of Necklace n
    = {[i,i+1] where i is Nat:i+1 < n} \/ {[i+1,i] where i is Nat:i+1 < n}
      by Th19;
  per cases by A1,A2,XBOOLE_0:def 2;
   suppose [x,x] in {[i,i+1] where i is Nat:i+1 < n};
   then consider i being Nat such that
A3:   [x,x] = [i,i+1] & i+1 < n;
     x = i & x = i+1 by A3,ZFMISC_1:33;
   hence contradiction by REAL_1:69;
   end;
   suppose [x,x] in {[i+1,i] where i is Nat:i+1 < n};
   then consider i being Nat such that
A4:   [x,x] = [i+1,i] & i+1 < n;
     x = i+1 & x = i by A4,ZFMISC_1:33;
   hence contradiction by REAL_1:69;
  end;
  end;
end;


theorem :: NECKLACE:21
   for n be natural number holds the carrier of Necklace n = n;

registration let n be non empty natural number;
  cluster Necklace n -> non empty;
   coherence
   proof
      the carrier of Necklace n = n by Th21;
    hence thesis by STRUCT_0:def 1;
   end;
end;


registration let n be natural number;
  cluster the carrier of Necklace n -> finite;
  coherence by Th21;
end;


theorem :: NECKLACE:22
   for n,i be natural number st i+1 < n holds
   [i,i+1] in the InternalRel of Necklace n;

theorem :: NECKLACE:23
   for n be natural number, i being natural number
   st i in the carrier of Necklace n holds i < n;

theorem :: NECKLACE:24
     for n be non empty natural number holds Necklace n is connected;

theorem :: NECKLACE:25
  for i,j being natural number st [i,j] in the InternalRel of Necklace n
       holds i = j + 1 or j = i + 1;

theorem :: NECKLACE:26
   for i,j being natural number st (i = j + 1 or j = i + 1) &
   i in the carrier of Necklace n & j in the carrier of Necklace n
   holds [i,j] in the InternalRel of Necklace n;

theorem :: NECKLACE:27
   n > 0 implies Card ({[i+1,i] where i is Nat:i+1 < n}) = n-1;

theorem :: NECKLACE:28
   n > 0 implies Card the InternalRel of Necklace n = 2*(n-1);

theorem :: NECKLACE:29
     Necklace 1, ComplRelStr Necklace 1 are_isomorphic;

theorem :: NECKLACE:30
     Necklace 4, ComplRelStr Necklace 4 are_isomorphic;

theorem :: NECKLACE:31
     Necklace n, ComplRelStr Necklace n are_isomorphic implies
   n = 0 or n = 1 or n = 4;

