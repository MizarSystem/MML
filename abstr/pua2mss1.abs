:: Minimal Manysorted Signature for Partial Algebra
::  by Grzegorz Bancerek
::
:: Received October 1, 1995
:: Copyright (c) 1995 Association of Mizar Users

environ

 vocabulary RELAT_1, FINSEQ_1, FUNCT_1, ZF_REFLE, AMI_1, BOOLE, PARTFUN1,
      UNIALG_1, FUNCT_2, CARD_3, MSUALG_1, UNIALG_2, EQREL_1, SETFAM_1, TARSKI,
      FINSEQ_2, PROB_1, PBOOLE, INCPROJ, RELAT_2, GROUP_1, MCART_1, PRALG_1,
      TDGROUP, QC_LANG1, PUA2MSS1;
 notation TARSKI, XBOOLE_0, ZFMISC_1, SUBSET_1, NUMBERS, NAT_1, SETFAM_1,
      RELAT_1, STRUCT_0, RELSET_1, FUNCT_1, MCART_1, FINSEQ_1, FINSEQ_2,
      PARTFUN1, FUNCT_2, RELAT_2, EQREL_1, AMI_1, PROB_1, CARD_3, PBOOLE,
      MSUALG_1, UNIALG_1;
 constructors NAT_1, PRVECT_1, EQREL_1, AMI_1, MSUALG_1, PROB_1, MEMBERED,
      PARTFUN1, RELAT_1, RELAT_2;
 clusters SUBSET_1, STRUCT_0, RELSET_1, FUNCT_1, AMI_1, FINSEQ_1, FINSEQ_2,
      FINSEQ_5, UNIALG_1, PRVECT_1, MSUALG_1, MSAFREE, FSM_1, PARTFUN1, NAT_1,
      FRAENKEL, RELAT_1, EQREL_1, TOLER_1;
 requirements NUMERALS, BOOLE, SUBSET, ARITHM;


begin

registration
 let f be non-empty Function;
 cluster rng f -> with_non-empty_elements;
 coherence
  proof assume {} in rng f;
    then ex x being set st x in dom f & {} = f.x by FUNCT_1:def 5;
   hence thesis by UNIALG_1:def 6;
  end;
end;


registration let X,Y be non empty set;
 cluster non empty PartFunc of X,Y;
 existence
  proof consider f being non empty PartFunc of Y*,Y;
   consider g being Function of X, dom f;
A1:  dom g = X & rng g c= dom f & dom f c= Y* by FUNCT_2:def 1,RELSET_1:12;
   then rng g c= Y* by XBOOLE_1:1;
   then reconsider g as PartFunc of X, Y* by A1,PARTFUN1:25;
   take f*g; consider x being Element of X;
      g.x in dom f by FUNCT_2:7;
    then x in dom (f*g) by A1,FUNCT_1:21;
    then [x, (f*g).x] in f*g by FUNCT_1:8;
   hence thesis;
  end;
end;


registration let X be with_non-empty_elements set;
 cluster -> non-empty FinSequence of X;
 coherence
  proof let p be FinSequence of X;
   let x be set; assume x in dom p;
    then p.x in rng p & rng p c= X by FINSEQ_1:def 4,FUNCT_1:def 5;
   hence thesis by AMI_1:def 1;
  end;
end;


registration let A be non empty set;
 cluster homogeneous quasi_total non-empty non empty PFuncFinSequence of A;
 existence
  proof consider a being homogeneous quasi_total non empty PartFunc of A*,A;
   reconsider a as Element of PFuncs(A*,A) by PARTFUN1:119;
   take <*a*>;
   hereby let n be Nat, h be PartFunc of A*,A;
    assume n in dom <*a*>; then n in Seg 1 by FINSEQ_1:55;
     then n = 1 by FINSEQ_1:4,TARSKI:def 1;
    hence h = <*a*>.n implies h is homogeneous by FINSEQ_1:57;
   end;
   hereby let n be Nat, h be PartFunc of A*,A;
    assume n in dom <*a*>; then n in Seg 1 by FINSEQ_1:55;
     then n = 1 by FINSEQ_1:4,TARSKI:def 1;
    hence h = <*a*>.n implies h is quasi_total by FINSEQ_1:57;
   end;
   hereby let n be set; assume n in dom <*a*>;
     then n in Seg 1 by FINSEQ_1:55;
     then n = 1 by FINSEQ_1:4,TARSKI:def 1;
    hence <*a*>.n is non empty by FINSEQ_1:57;
   end;
   thus thesis;
  end;
end;


registration
 cluster non-empty -> non empty UAStr;
 coherence
  proof let A be UAStr; assume
A1:  the charact of A <> {} & the charact of A is non-empty;
   then reconsider f = the charact of A as non empty Function;
   consider x being Element of dom f;
   reconsider y = f.x as non empty set by A1,UNIALG_1:def 6;
    A2: y in rng f & rng f c= PFuncs((the carrier of A)*, the carrier of A)
     by FINSEQ_1:def 4,FUNCT_1:def 5;
then A3:  y is PartFunc of (the carrier of A)*, the carrier of A
     by PARTFUN1:121;
   reconsider y as non empty Function by A2,PARTFUN1:121;
   consider z being Element of rng y;
      z in rng y & rng y c= the carrier of A by A3,RELSET_1:12;
   hence the carrier of A is non empty;
  end;
end;


registration
 let X be non empty with_non-empty_elements set;
 cluster -> non empty Element of X;
 coherence by AMI_1:def 1;
end;


theorem :: PUA2MSS1:1
 for f,g being non-empty Function st product f c= product g holds
 dom f = dom g & for x being set st x in dom f holds f.x c= g.x;

theorem :: PUA2MSS1:2
 for f,g being non-empty Function st product f = product g holds f = g;

definition let A be non empty set;
 let f be PFuncFinSequence of A;
 redefine func rng f -> Subset of PFuncs(A*, A);
end;


definition let A,B be non empty set;
 let S be non empty Subset of PFuncs(A, B);
 redefine mode Element of S -> PartFunc of A,B;
end;


definition
 let A be non-empty UAStr;
 mode OperSymbol of A is Element of dom the charact of A;
 mode operation of A is Element of rng the charact of A;
end;


definition
 let A be non-empty UAStr;
 let o be OperSymbol of A;
 func Den(o, A) -> operation of A equals
:: PUA2MSS1:def 1
    (the charact of A).o;
end;


begin :: Partitions

registration let X be set;
 cluster -> with_non-empty_elements a_partition of X;
 coherence
  proof let P be a_partition of X; assume
A1:  {} in P;
    then X <> {} by EQREL_1:def 6;
   hence contradiction by A1,EQREL_1:def 6;
  end;
end;


definition
 let X be set;
 let R be Equivalence_Relation of X;
 redefine func Class R -> a_partition of X;
end;


theorem :: PUA2MSS1:3
 for X being set, P being a_partition of X, x,a,b being set
  st x in a & a in P & x in b & b in P holds a = b;

theorem :: PUA2MSS1:4
 for X,Y being set st X is_finer_than Y
 for p being FinSequence of X ex q being FinSequence of Y st
  product p c= product q;

theorem :: PUA2MSS1:5
 for X being set, P,Q being a_partition of X
 for f being Function of P,Q st for a being set st a in P holds a c= f.a
 for p being FinSequence of P, q being FinSequence of Q holds
  product p c= product q iff f*p = q;

theorem :: PUA2MSS1:6
 for P being set, f being Function st rng f c= union P
  ex p being Function st dom p = dom f & rng p c= P & f in product p;

theorem :: PUA2MSS1:7
 for X be set, P being a_partition of X, f being FinSequence of X
  ex p being FinSequence of P st f in product p;

theorem :: PUA2MSS1:8
   for X,Y being non empty set
 for P being a_partition of X, Q being a_partition of Y holds
  {[:p,q:] where p is Element of P, q is Element of Q: not contradiction}
   is a_partition of [:X,Y:];

theorem :: PUA2MSS1:9
 for X being non empty set
 for P being a_partition of X holds
  {product p where p is Element of P*: not contradiction} is a_partition of X
*;

theorem :: PUA2MSS1:10
   for X being non empty set, n be Nat
 for P being a_partition of X holds
  {product p where p is Element of n-tuples_on P: not contradiction}
   is a_partition of n-tuples_on X;

theorem :: PUA2MSS1:11
 for X being non empty set, Y be set st Y c= X
 for P being a_partition of X holds
  {a /\ Y where a is Element of P: a meets Y} is a_partition of Y;

theorem :: PUA2MSS1:12
 for f being non empty Function, P being a_partition of dom f holds
  {f|a where a is Element of P: not contradiction} is a_partition of f;

definition
 let X be set;
 func SmallestPartition X -> a_partition of X equals
:: PUA2MSS1:def 2

   Class id X;
end;


theorem :: PUA2MSS1:13
 for X being non empty set holds
   SmallestPartition X = {{x} where x is Element of X: not contradiction};

theorem :: PUA2MSS1:14
 for X being set, p being FinSequence of SmallestPartition X
  ex q being FinSequence of X st product p = {q};

definition let X be set;
 mode IndexedPartition of X -> Function means
:: PUA2MSS1:def 3

  rng it is a_partition of X & it is one-to-one;
end;


definition let X be set;
 let P be IndexedPartition of X;
 redefine func rng P -> a_partition of X;
end;
registration let X be set;
 cluster -> one-to-one non-empty IndexedPartition of X;
 coherence
  proof let P be IndexedPartition of X;
   thus P is one-to-one by Def3;
   let x be set; assume x in dom P;
    then P.x in rng P & rng P is a_partition of X & (X = {} or X <> {})
     by FUNCT_1:def 5;
   hence thesis by EQREL_1:def 6;
  end;
 end;


registration let X be non empty set;
 cluster -> non empty IndexedPartition of X;
 coherence
  proof let P be IndexedPartition of X;
   consider a being Element of rng P;
      ex b being set st [b,a] in P by RELAT_1:def 5;
   hence thesis;
  end;
end;


definition let X be set, P be a_partition of X;
 redefine func id P -> IndexedPartition of X;
end;


definition let X be set;
 let P be IndexedPartition of X;
 let x be set; assume
  x in X;
 func P-index_of x -> set means
:: PUA2MSS1:def 4

  it in dom P & x in P.it;
end;


theorem :: PUA2MSS1:15
 for X being set, P being non-empty Function st Union P = X &
   for x,y being set st x in dom P & y in dom P & x <> y holds P.x misses P.y
  holds P is IndexedPartition of X;

theorem :: PUA2MSS1:16
 for X,Y being non empty set, P being a_partition of Y
 for f being Function of X, P st P c= rng f & f is one-to-one
  holds f is IndexedPartition of Y;


begin :: Relations generated by operations of partial algebra

scheme :: PUA2MSS1:sch 1
 IndRelationEx
  {A, B() -> non empty set, i() -> Nat,
   R0() -> (Relation of A(),B()),
   RR(set,set) -> Relation of A(),B()}:
 ex R being Relation of A(),B(), F being ManySortedSet of NAT st
  R = F.i() & F.0 = R0() &
  for i being Nat, R being Relation of A(),B() st R = F.i
   holds F.(i+1) = RR(R,i)
proof
   deffunc G(set,set) = RR($2,$1);
   consider F being Function such that
A1:  dom F = NAT and
A2:  F.0 = R0() & for n being Nat holds F.(n+1) = G(n,F.n) from RECDEF_1:sch 3;
   reconsider F as ManySortedSet of NAT by A1,PBOOLE:def 3;
   defpred P[Nat] means F.$1 is Relation of A(),B();
A3:  P[0] by A2;
A4:  now let i be Nat; assume P[i];
     then reconsider R = F.i as Relation of A(),B();
     F.(i+1) = RR(R,i) by A2;
     hence P[i+1];
    end;
    for i being Nat holds P[i] from NAT_1:sch 1(A3,A4);
   then reconsider R = F.i() as Relation of A(),B();
   take R,F; thus thesis by A2;
  end;

scheme :: PUA2MSS1:sch 2
 RelationUniq
 {A, B() -> non empty set, P[set,set]}:
 for R1, R2 being Relation of A(), B() st
  (for x being Element of A(), y being Element of B() holds
     [x,y] in R1 iff P[x,y]) &
  (for x being Element of A(), y being Element of B() holds
     [x,y] in R2 iff P[x,y])
 holds R1 = R2
proof   let R1, R2 be Relation of A(), B() such that
A1: for x being Element of A(), y being Element of B() holds
     [x,y] in R1 iff P[x,y]
   and
A2: for x being Element of A(), y being Element of B() holds
     [x,y] in R2 iff P[x,y];
   let x,y be set;
   hereby assume
A3:  [x,y] in R1; then reconsider a = x as Element of A() by ZFMISC_1:106;
    reconsider b = y as Element of B() by A3,ZFMISC_1:106;
       P[a,b] by A1,A3;
    hence [x,y] in R2 by A2;
   end;
   assume
A4: [x,y] in R2; then reconsider a = x as Element of A() by ZFMISC_1:106;
   reconsider b = y as Element of B() by A4,ZFMISC_1:106;
      P[a,b] by A2,A4;
   hence thesis by A1;
  end;

scheme :: PUA2MSS1:sch 3
 IndRelationUniq
  {A, B() -> non empty set, i() -> Nat,
   R0() -> (Relation of A(),B()),
   RR(set,set) -> Relation of A(),B()}:
 for R1, R2 being Relation of A(),B() st
  (ex F being ManySortedSet of NAT st
    R1 = F.i() & F.0 = R0() &
    for i being Nat, R being Relation of A(),B() st R = F.i
     holds F.(i+1) = RR(R,i)) &
  (ex F being ManySortedSet of NAT st
    R2 = F.i() & F.0 = R0() &
    for i being Nat, R being Relation of A(),B() st R = F.i
     holds F.(i+1) = RR(R,i))
 holds R1 = R2
proof   let R1, R2 be Relation of A(),B();
   given F1 being ManySortedSet of NAT such that
A1:  R1 = F1.i() & F1.0 = R0() &
    for i being Nat, R being Relation of A(),B() st R = F1.i
     holds F1.(i+1) = RR(R,i);
   given F2 being ManySortedSet of NAT such that
A2:  R2 = F2.i() & F2.0 = R0() &
    for i being Nat, R being Relation of A(),B() st R = F2.i
     holds F2.(i+1) = RR(R,i);
     defpred P[Nat] means F1.$1 = F2.$1 & F1.$1 is Relation of A(),B();
A3:  P[0] by A1,A2;
A4:  now let i be Nat; assume
A5:  P[i];
     then reconsider R = F1.i as Relation of A(),B();
     F1.(i+1) = RR(R,i) & F2.(i+1) = RR(R,i) by A1,A2,A5;
     hence P[i+1];
    end;
    for i being Nat holds P[i] from NAT_1:sch 1(A3,A4);
   hence thesis by A1,A2;
  end;

definition
 let A be partial non-empty UAStr;
 func DomRel A -> Relation of the carrier of A means
:: PUA2MSS1:def 5

  for x,y being Element of A holds [x,y] in it iff
   for f being operation of A, p,q being FinSequence holds
    p^<*x*>^q in dom f iff p^<*y*>^q in dom f;
end;


registration
 let A be partial non-empty UAStr;
 cluster DomRel A -> total symmetric transitive;
 coherence
  proof set X = the carrier of A;
   DomRel A is_reflexive_in X
    proof let x be set;
        for f being operation of A for a,b be FinSequence holds
       a^<*x*>^b in dom f iff a^<*x*>^b in dom f;
     hence thesis by Def5;
    end;
    then
A1:  dom DomRel A = X & field DomRel A = X by ORDERS_1:98;
   hence DomRel A is total by PARTFUN1:def 4;
   DomRel A is_symmetric_in X
    proof let x,y be set; assume x in X & y in X;
     then reconsider x' = x, y' = y as Element of X;
     assume [x,y] in DomRel A;
      then for f being operation of A for a,b be FinSequence holds
       a^<*x'*>^b in dom f iff a^<*y'*>^b in dom f by Def5;
     hence thesis by Def5;
    end;
   hence DomRel A is symmetric by A1,RELAT_2:def 11;
   DomRel A is_transitive_in X
    proof let x,y,z be set; assume x in X & y in X & z in X;
     then reconsider x' = x, y' = y, z' = z as Element of X;
     assume A2: [x,y] in DomRel A & [y,z] in DomRel A;
        now let f be operation of A, a,b be FinSequence;
          a^<*x'*>^b in dom f iff a^<*y'*>^b in dom f by A2,Def5;
       hence a^<*x'*>^b in dom f iff a^<*z'*>^b in dom f by A2,Def5;
      end;
     hence thesis by Def5;
    end;
   hence DomRel A is transitive by A1,RELAT_2:def 16;
  end;
end;


definition
 let A be non-empty partial UAStr;
 let R be Relation of the carrier of A;
 func R|^A -> Relation of the carrier of A means
:: PUA2MSS1:def 6

  for x,y being Element of A holds
   [x,y] in it iff [x,y] in R &
    for f being operation of A for p,q being FinSequence
     st p^<*x*>^q in dom f & p^<*y*>^q in dom f
     holds [f.(p^<*x*>^q), f.(p^<*y*>^q)] in R;
end;


definition
 let A be non-empty partial UAStr;
 let R be Relation of the carrier of A;
 let i be Nat;
 func R|^(A,i) -> Relation of the carrier of A means
:: PUA2MSS1:def 7

  ex F being ManySortedSet of NAT st it = F.i & F.0 = R &
  for i being Nat, R being Relation of the carrier of A st R = F.i
   holds F.(i+1) = R|^A;
end;


theorem :: PUA2MSS1:17
 for A being non-empty partial UAStr,
     R being Relation of the carrier of A
  holds R|^(A,0) = R & R|^(A,1) = R|^A;

theorem :: PUA2MSS1:18
 for A being non-empty partial UAStr,
     i being Nat,
     R being Relation of the carrier of A
  holds R|^(A,i+1) = R|^(A,i)|^A;

theorem :: PUA2MSS1:19
   for A being non-empty partial UAStr,
     i,j being Nat,
     R being Relation of the carrier of A
  holds R|^(A,i+j) = R|^(A,i)|^(A,j);

theorem :: PUA2MSS1:20
 for A being non-empty partial UAStr
 for R being Equivalence_Relation of the carrier of A st R c= DomRel A
  holds R|^A is total symmetric transitive;

theorem :: PUA2MSS1:21
 for A being non-empty partial UAStr
 for R being Relation of the carrier of A holds R|^A c= R;

theorem :: PUA2MSS1:22
 for A being non-empty partial UAStr
 for R being Equivalence_Relation of the carrier of A st R c= DomRel A
 for i being Nat holds R|^(A,i) is total symmetric transitive;

definition
 let A be non-empty partial UAStr;
 func LimDomRel A -> Relation of the carrier of A means
:: PUA2MSS1:def 8

  for x,y being Element of A holds
   [x,y] in it iff for i being Nat holds [x,y] in (DomRel A)|^(A,i);
end;


theorem :: PUA2MSS1:23
 for A being non-empty partial UAStr holds LimDomRel A c= DomRel A;

registration
 let A be non-empty partial UAStr;
 cluster LimDomRel A -> total symmetric transitive;
 coherence
  proof
   now let x be set; assume x in the carrier of A;
    then reconsider a = x as Element of A;
       now let i be Nat;
BB:      (DomRel A)|^(A,i) is total symmetric transitive by Th22; then
         (DomRel A)|^(A,i) is reflexive by RELAT_2:22;
      hence [a,a] in (DomRel A)|^(A,i) by BB,EQREL_1:11;
     end;
    hence [x,x] in LimDomRel A by Def8;
   end;
   then LimDomRel A is_reflexive_in the carrier of A by RELAT_2:def 1;
   then
A1: dom(LimDomRel A) = the carrier of A & field(LimDomRel A) = the carrier of A
                          by ORDERS_1:98;
   hence LimDomRel A is total by PARTFUN1:def 4;
   now let x,y be set; assume
       x in the carrier of A & y in the carrier of A;
    then reconsider a = x, b = y as Element of A;
    assume
A2:   [x,y] in LimDomRel A;
       now let i be Nat;
         (DomRel A)|^(A,i) is total symmetric transitive &
       [a,b] in (DomRel A)|^(A,i) by A2,Def8,Th22;
      hence [b,a] in (DomRel A)|^(A,i) by EQREL_1:12;
     end;
    hence [y,x] in LimDomRel A by Def8;
   end;
    then LimDomRel A is_symmetric_in the carrier of A by RELAT_2:def 3;
   hence LimDomRel A is symmetric by A1,RELAT_2:def 11;
   now
   let x,y,z be set; assume
      x in the carrier of A & y in the carrier of A & z in the carrier of A;
   then reconsider a = x, b = y, c = z as Element of A;
   assume
A3:  [x,y] in LimDomRel A & [y,z] in LimDomRel A;
      now let i be Nat;
        (DomRel A)|^(A,i) is total symmetric transitive &
      [a,b] in (DomRel A)|^(A,i) & [b,c] in (DomRel A)|^(A,i) by A3,Def8,Th22;
     hence [a,c] in (DomRel A)|^(A,i) by EQREL_1:13;
    end;
   hence [x,z] in LimDomRel A by Def8;
   end;
    then LimDomRel A is_transitive_in the carrier of A by RELAT_2:def 8;
   hence LimDomRel A is transitive by A1,RELAT_2:def 16;
  end;
end;



begin :: Partitability

definition
 let X be non empty set;
 let f be PartFunc of X*, X;
 let P be a_partition of X;
 pred f is_partitable_wrt P means
:: PUA2MSS1:def 9

  for p being FinSequence of P ex a being Element of P st f.:product p c= a;
end;


definition
 let X be non empty set;
 let f be PartFunc of X*, X;
 let P be a_partition of X;
 pred f is_exactly_partitable_wrt P means
:: PUA2MSS1:def 10

  f is_partitable_wrt P &
  for p being FinSequence of P st product p meets dom f holds
   product p c= dom f;
end;


theorem :: PUA2MSS1:24
   for A being non-empty partial UAStr
 for f being operation of A holds
  f is_exactly_partitable_wrt SmallestPartition the carrier of A;



scheme :: PUA2MSS1:sch 4
 FiniteTransitivity
 {x, y() -> FinSequence, P[set], R[set,set]}:
 P[y()]
 provided
  P[x()]
 and
  len x() = len y()
 and
  for p,q being FinSequence, z1,z2 being set
   st P[p^<*z1*>^q] & R[z1,z2] holds P[p^<*z2*>^q]
 and
  for i being Nat st i in dom x() holds R[x().i, y().i]
proof
   defpred Q[Nat] means
    for x1,x2, y1,y2 being FinSequence
     st len x1 = $1 & x() = x1^x2 & len y1 = $1 & y() = y1^y2
     holds P[y1^x2];
A5:  Q[0]
     proof let x1,x2, y1,y2 be FinSequence; assume
A6:    len x1 = 0 & x() = x1^x2 & len y1 = 0 & y() = y1^y2;
       then x1 = {} & y1 = {} by FINSEQ_1:25;
      hence P[y1^x2] by A1,A6;
     end;
A7:  for i being Nat st Q[i] holds Q[i+1]
     proof let i be Nat such that
A8:    for x1,x2, y1,y2 being FinSequence
        st len x1 = i & x() = x1^x2 & len y1 = i & y() = y1^y2
        holds P[y1^x2];
      let x1,x2, y1,y2 be FinSequence such that
A9:    len x1 = i+1 & x() = x1^x2 & len y1 = i+1 & y() = y1^y2;
A10:    x1 <> {} & y1 <> {} by A9,FINSEQ_1:25;
      then consider x' being FinSequence, xx being set such that
A11:    x1 = x'^<*xx*> by FINSEQ_1:63;
      consider y' being FinSequence, yy being set such that
A12:    y1 = y'^<*yy*> by A10,FINSEQ_1:63;
A13:    dom x1 = Seg len x1 & dom y1 = Seg len y1 by FINSEQ_1:def 3;
         len <*xx*> = 1 & len <*yy*> = 1 by FINSEQ_1:57;
       then len x1 = len x'+1 & len y1 = len y'+1 by A11,A12,FINSEQ_1:35;
       then len x' = i & x() = x'^(<*xx*>^x2) & len y' = i & y() = y'^(<*yy*>^
y2) &
       i+1 in dom x1 & dom x1 c= dom x() &
       x1.(len x'+1) = xx & y1.(len y'+1) = yy
        by A9,A11,A12,A13,FINSEQ_1:6,39,45,59,XCMPLX_1:2;
       then P[y'^(<*xx*>^x2)] & i+1 in dom x() & x().(i+1) = xx & y().(i+1) =
yy
        by A8,A9,A13,FINSEQ_1:def 7;
       then P[y'^<*xx*>^x2] & R[xx,yy] by A4,FINSEQ_1:45;
      hence thesis by A3,A12;
     end;
A14:  for i being Nat holds Q[i] from NAT_1:sch 1(A5,A7);
      x() = x()^{} & y() = y()^{} by FINSEQ_1:47;
   hence thesis by A2,A14;
  end;

theorem :: PUA2MSS1:25
 for A being non-empty partial UAStr
 for f being operation of A holds
  f is_exactly_partitable_wrt Class LimDomRel A;

definition
 let A be partial non-empty UAStr;
 mode a_partition of A -> a_partition of the carrier of A means
:: PUA2MSS1:def 11

  for f being operation of A holds f is_exactly_partitable_wrt it;
end;


definition
 let A be partial non-empty UAStr;
 mode IndexedPartition of A -> IndexedPartition of the carrier of A means
:: PUA2MSS1:def 12

  rng it is a_partition of A;
end;


definition
 let A be partial non-empty UAStr;
 let P be IndexedPartition of A;
 redefine func rng P -> a_partition of A;
end;


theorem :: PUA2MSS1:26
   for A being non-empty partial UAStr holds
  Class LimDomRel A is a_partition of A;

theorem :: PUA2MSS1:27
 for X being non empty set, P being a_partition of X
 for p being FinSequence of P, q1,q2 being FinSequence, x,y being set
  st q1^<*x*>^q2 in product p & ex a being Element of P st x in a & y in a
  holds q1^<*y*>^q2 in product p;

theorem :: PUA2MSS1:28
 for A being partial non-empty UAStr, P being a_partition of A holds
  P is_finer_than Class LimDomRel A;


begin :: Morphisms between manysorted signatures


definition
 let S1,S2 be ManySortedSign;
 let f,g be Function;
 pred f,g form_morphism_between S1,S2 means
:: PUA2MSS1:def 13

  dom f = the carrier of S1 & dom g = the OperSymbols of S1 &
  rng f c= the carrier of S2 & rng g c= the OperSymbols of S2 &
  f*the ResultSort of S1 = (the ResultSort of S2)*g &
  for o being set, p being Function
    st o in the OperSymbols of S1 & p = (the Arity of S1).o
    holds f*p = (the Arity of S2).(g.o);
end;


theorem :: PUA2MSS1:29
 for S being non void non empty ManySortedSign holds
  id the carrier of S, id the OperSymbols of S form_morphism_between S,S;

theorem :: PUA2MSS1:30
 for S1,S2,S3 being ManySortedSign
 for f1,f2, g1,g2 being Function st
  f1, g1 form_morphism_between S1,S2 & f2, g2 form_morphism_between S2,S3
 holds f2*f1, g2*g1 form_morphism_between S1,S3;


definition
 let S1,S2 be ManySortedSign;
 pred S1 is_rougher_than S2 means
:: PUA2MSS1:def 14
    ex f,g being Function st f,g form_morphism_between S2,S1 &
   rng f = the carrier of S1 & rng g = the OperSymbols of S1;
end;


definition
 let S1,S2 be non void non empty ManySortedSign;
 redefine pred S1 is_rougher_than S2;
 reflexivity;
end;


theorem :: PUA2MSS1:31
   for S1,S2,S3 being ManySortedSign
   st S1 is_rougher_than S2 & S2 is_rougher_than S3
   holds S1 is_rougher_than S3;


begin :: Manysorted signature of partital algebra


definition
 let A be partial non-empty UAStr;
 let P be a_partition of A;
 func MSSign(A,P) -> strict ManySortedSign means
:: PUA2MSS1:def 15

  the carrier of it = P &
  the OperSymbols of it =
   {[o,p] where o is OperSymbol of A, p is Element of P*:
    product p meets dom Den(o,A)} &
  for o being OperSymbol of A, p being Element of P*
   st product p meets dom Den(o,A)
   holds (the Arity of it).[o,p] = p &
         Den(o, A).:product p c= (the ResultSort of it).[o,p];
end;


registration
 let A be partial non-empty UAStr;
 let P be a_partition of A;
 cluster MSSign(A,P) -> non empty non void;
 coherence
  proof
   thus the carrier of MSSign(A,P) is non empty by Def15;
   consider g being OperSymbol of A; consider x being Element of dom Den(g,A);
   reconsider x as Element of (the carrier of A)*;
      union P = the carrier of A & rng x c= the carrier of A
     by EQREL_1:def 6,FINSEQ_1:def 4;
   then consider q being Function such that
A1:  dom q = dom x & rng q c= P & x in product q by Th6;
      dom x = Seg len x by FINSEQ_1:def 3;
   then reconsider q as FinSequence by A1,FINSEQ_1:def 2;
   reconsider q as FinSequence of P by A1,FINSEQ_1:def 4;
   reconsider q as Element of P* by FINSEQ_1:def 11;
      product q meets dom Den(g, A) &
    the OperSymbols of MSSign(A,P) =
      {[f,p] where f is OperSymbol of A, p is Element of P*:
       product p meets dom Den(f,A)} by A1,Def15,XBOOLE_0:3;
    then [g,q] in the OperSymbols of MSSign(A,P);
   hence the OperSymbols of MSSign(A,P) <> {};
  end;
end;


definition
 let A be partial non-empty UAStr;
 let P be a_partition of A;
 let o be OperSymbol of MSSign(A,P);
 redefine
  func o`1 -> OperSymbol of A;
  func o`2 -> Element of P*;
end;


definition
 let A be partial non-empty UAStr;
 let S be non void non empty ManySortedSign;
 let G be MSAlgebra over S;
 let P be IndexedPartition of the OperSymbols of S;
 pred A can_be_characterized_by S,G,P means
:: PUA2MSS1:def 16

   the Sorts of G is IndexedPartition of A &
   dom P = dom the charact of A &
   for o being OperSymbol of A holds
    (the Charact of G)|(P.o) is IndexedPartition of Den(o, A);
end;


definition
 let A be partial non-empty UAStr;
 let S be non void non empty ManySortedSign;
 pred A can_be_characterized_by S means
:: PUA2MSS1:def 17
    ex G being MSAlgebra over S,
     P being IndexedPartition of the OperSymbols of S st
   A can_be_characterized_by S,G,P;
end;


theorem :: PUA2MSS1:32
   for A being partial non-empty UAStr, P being a_partition of A
  holds A can_be_characterized_by MSSign(A, P);

theorem :: PUA2MSS1:33
 for A being partial non-empty UAStr
 for S being non void non empty ManySortedSign
 for G being MSAlgebra over S
 for Q being IndexedPartition of the OperSymbols of S
     st A can_be_characterized_by S,G,Q
 for o being OperSymbol of A, r being FinSequence of rng the Sorts of G
     st product r c= dom Den(o,A)
 ex s being OperSymbol of S st
  (the Sorts of G)*the_arity_of s = r & s in Q.o;

theorem :: PUA2MSS1:34
   for A being partial non-empty UAStr, P being a_partition of A
  st P = Class LimDomRel A
 for S being non void non empty ManySortedSign st A can_be_characterized_by S
  holds MSSign(A,P) is_rougher_than S;


