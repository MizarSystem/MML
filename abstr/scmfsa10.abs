:: On the Instructions of { \bf SCM+FSA }
::  by Artur Korni{\l}owicz
::
:: Received May 8, 2001
:: Copyright (c) 2001 Association of Mizar Users

environ

 vocabularies AMI_3, SCMFSA_2, AMI_1, ORDINAL2, ARYTM, FUNCT_1, FUNCT_4, CAT_1,
      FINSEQ_1, RELAT_1, BOOLE, INT_1, FUNCOP_1, SCMFSA_1, AMI_2, GR_CY_1,
      AMISTD_2, MCART_1, AMI_5, FINSEQ_4, AMISTD_1, SETFAM_1, REALSET1, TARSKI,
      SGRAPH1, GOBOARD5, FRECHET, ARYTM_1, NAT_1, ABSVALUE, FINSEQ_2, UNIALG_1,
      CARD_5, CARD_3, RELOC, FUNCT_7;
 notations TARSKI, XBOOLE_0, ENUMSET1, SUBSET_1, MCART_1, SETFAM_1, RELAT_1,
      FUNCT_1, PARTFUN1, FUNCT_2, REALSET1, ORDINAL1, XCMPLX_0, INT_1,
      FUNCOP_1, FINSEQ_1, FINSEQ_2, FUNCT_4, COMPLEX1, CARD_1, CARD_3, FUNCT_7,
      XXREAL_0, AMI_1, SCMNORM, AMI_2, AMI_3, SCMFSA_1, SCMFSA_2, SCMFSA_3,
      AMISTD_1, AMISTD_2;
 constructors XXREAL_0, REAL_1, NAT_1, NAT_D, INT_2, FINSEQ_4, REALSET1,
      PRALG_2, AMI_5, SCMFSA_1, SCMFSA_3, AMISTD_2, VALUED_1, PARTFUN1, SEQ_1,
      SCMNORM;
 registrations XBOOLE_0, SUBSET_1, SETFAM_1, RELAT_1, FUNCT_1, ORDINAL1,
      FUNCOP_1, FRAENKEL, NUMBERS, XREAL_0, NAT_1, INT_1, FINSEQ_1, TEX_2,
      AMI_1, AMI_3, AMI_5, SCMFSA_2, AMISTD_2, AMI_2, RELSET_1, FUNCT_4,
      CARD_3, VALUED_1, FUNCT_2, AMISTD_1, SCMNORM;
 requirements NUMERALS, BOOLE, SUBSET, REAL, ARITHM;


begin

reserve a, b, d1, d2, d3, d4 for Int-Location,
  A, B for Data-Location,
  f, f1, f2, f3 for FinSeq-Location,
  il, i1, i2 for Instruction-Location of SCM+FSA,
  L for Instruction-Location of SCM,
  I for Instruction of SCM+FSA,
  s for State of SCM+FSA,
  T for InsType of SCM+FSA,
  k for natural number;

definition
  let la, lb be Int-Location, a, b be Integer;
  redefine func (la,lb) --> (a,b) -> FinPartState of SCM+FSA;
end;

canceled 2;

theorem :: SCMFSA10:3
  not a in NAT;

theorem :: SCMFSA10:4
  not f in NAT;

theorem :: SCMFSA10:5
  SCM+FSA-Data-Loc <> NAT;

theorem :: SCMFSA10:6
  SCM+FSA-Data*-Loc <> NAT;

theorem :: SCMFSA10:7
  for o being Object of SCM+FSA holds o = IC SCM+FSA or o in NAT or
  o is Int-Location or o is FinSeq-Location;

canceled;

theorem :: SCMFSA10:9
  a := b = [1, <* a,b *>];

theorem :: SCMFSA10:10
  AddTo(a,b) = [2, <* a,b *>];

theorem :: SCMFSA10:11
  SubFrom(a,b) = [3, <* a,b *>];

theorem :: SCMFSA10:12
  MultBy(a,b) = [4, <* a,b *>];

theorem :: SCMFSA10:13
  Divide(a,b) = [5, <* a,b *>];

theorem :: SCMFSA10:14
  goto il = [6, <* il *>];

theorem :: SCMFSA10:15
  a=0_goto il = [7, <* il,a *>];

theorem :: SCMFSA10:16
  a>0_goto il = [8, <* il,a *>];

reserve J,K for Element of Segm 13,
  b,c,c1 for Element of SCM+FSA-Data-Loc,
  f,f1 for Element of SCM+FSA-Data*-Loc;

theorem :: SCMFSA10:17
  AddressPart halt SCM+FSA = {};

reserve a, b, d1, d2, d3, d4 for Int-Location,
  A, B for Data-Location,
  f, f1, f2, f3 for FinSeq-Location;

theorem :: SCMFSA10:18
  AddressPart (a:=b) = <*a,b*>;

theorem :: SCMFSA10:19
  AddressPart AddTo(a,b) = <*a,b*>;

theorem :: SCMFSA10:20
  AddressPart SubFrom(a,b) = <*a,b*>;

theorem :: SCMFSA10:21
  AddressPart MultBy(a,b) = <*a,b*>;

theorem :: SCMFSA10:22
  AddressPart Divide(a,b) = <*a,b*>;

theorem :: SCMFSA10:23
  AddressPart goto i1 = <*i1*>;

theorem :: SCMFSA10:24
  AddressPart (a=0_goto i1) = <*i1,a*>;

theorem :: SCMFSA10:25
  AddressPart (a>0_goto i1) = <*i1,a*>;

theorem :: SCMFSA10:26
  AddressPart (b:=(f,a)) = <*b,f,a*>;

theorem :: SCMFSA10:27
  AddressPart ((f,a):=b) = <*b,f,a*>;

theorem :: SCMFSA10:28
  AddressPart (a:=len f) = <*a,f*>;

theorem :: SCMFSA10:29
  AddressPart (f:=<0,...,0>a) = <*a,f*>;

theorem :: SCMFSA10:30
  T = 0 implies AddressParts T = {0};

registration
  let T;
  cluster AddressParts T -> non empty;
end;

theorem :: SCMFSA10:31
  T = 1 implies dom product" AddressParts T = {1,2};

theorem :: SCMFSA10:32
  T = 2 implies dom product" AddressParts T = {1,2};

theorem :: SCMFSA10:33
  T = 3 implies dom product" AddressParts T = {1,2};

theorem :: SCMFSA10:34
  T = 4 implies dom product" AddressParts T = {1,2};

theorem :: SCMFSA10:35
  T = 5 implies dom product" AddressParts T = {1,2};

theorem :: SCMFSA10:36
  T = 6 implies dom product" AddressParts T = {1};

theorem :: SCMFSA10:37
  T = 7 implies dom product" AddressParts T = {1,2};

theorem :: SCMFSA10:38
  T = 8 implies dom product" AddressParts T = {1,2};

theorem :: SCMFSA10:39
  T = 9 implies dom product" AddressParts T = {1,2,3};

theorem :: SCMFSA10:40
  T = 10 implies dom product" AddressParts T = {1,2,3};

theorem :: SCMFSA10:41
  T = 11 implies dom product" AddressParts T = {1,2};

theorem :: SCMFSA10:42
  T = 12 implies dom product" AddressParts T = {1,2};

theorem :: SCMFSA10:43
  (product" AddressParts InsCode (a:=b)).1 = SCM+FSA-Data-Loc;

theorem :: SCMFSA10:44
  (product" AddressParts InsCode (a:=b)).2 = SCM+FSA-Data-Loc;

theorem :: SCMFSA10:45
  (product" AddressParts InsCode AddTo(a,b)).1 = SCM+FSA-Data-Loc;

theorem :: SCMFSA10:46
  (product" AddressParts InsCode AddTo(a,b)).2 = SCM+FSA-Data-Loc;

theorem :: SCMFSA10:47
  (product" AddressParts InsCode SubFrom(a,b)).1 = SCM+FSA-Data-Loc;

theorem :: SCMFSA10:48
  (product" AddressParts InsCode SubFrom(a,b)).2 = SCM+FSA-Data-Loc;

theorem :: SCMFSA10:49
  (product" AddressParts InsCode MultBy(a,b)).1 = SCM+FSA-Data-Loc;

theorem :: SCMFSA10:50
  (product" AddressParts InsCode MultBy(a,b)).2 = SCM+FSA-Data-Loc;

theorem :: SCMFSA10:51
  (product" AddressParts InsCode Divide(a,b)).1 = SCM+FSA-Data-Loc;

theorem :: SCMFSA10:52
  (product" AddressParts InsCode Divide(a,b)).2 = SCM+FSA-Data-Loc;

theorem :: SCMFSA10:53
  (product" AddressParts InsCode goto i1).1 = NAT;

theorem :: SCMFSA10:54
  (product" AddressParts InsCode (a =0_goto i1)).1 = NAT;

theorem :: SCMFSA10:55
  (product" AddressParts InsCode (a =0_goto i1)).2 = SCM+FSA-Data-Loc;

theorem :: SCMFSA10:56
  (product" AddressParts InsCode (a >0_goto i1)).1 = NAT;

theorem :: SCMFSA10:57
  (product" AddressParts InsCode (a >0_goto i1)).2 = SCM+FSA-Data-Loc;

theorem :: SCMFSA10:58
  (product" AddressParts InsCode (b:=(f,a))).1 = SCM+FSA-Data-Loc;

theorem :: SCMFSA10:59
  (product" AddressParts InsCode (b:=(f,a))).2 = SCM+FSA-Data*-Loc;

theorem :: SCMFSA10:60
  (product" AddressParts InsCode (b:=(f,a))).3 = SCM+FSA-Data-Loc;

theorem :: SCMFSA10:61
  (product" AddressParts InsCode ((f,a):=b)).1 = SCM+FSA-Data-Loc;

theorem :: SCMFSA10:62
  (product" AddressParts InsCode ((f,a):=b)).2 = SCM+FSA-Data*-Loc;

theorem :: SCMFSA10:63
  (product" AddressParts InsCode ((f,a):=b)).3 = SCM+FSA-Data-Loc;

theorem :: SCMFSA10:64
  (product" AddressParts InsCode (a:=len f)).1 = SCM+FSA-Data-Loc;

theorem :: SCMFSA10:65
  (product" AddressParts InsCode (a:=len f)).2 = SCM+FSA-Data*-Loc;

theorem :: SCMFSA10:66
  (product" AddressParts InsCode (f:=<0,...,0>a)).1 = SCM+FSA-Data-Loc;

theorem :: SCMFSA10:67
  (product" AddressParts InsCode (f:=<0,...,0>a)).2 = SCM+FSA-Data*-Loc;

theorem :: SCMFSA10:68
  NIC(halt SCM+FSA, il) = {il};

registration
  cluster JUMP halt SCM+FSA -> empty;
end;

theorem :: SCMFSA10:69
  NIC(a := b, il) = {Next il};

registration
  let a, b;
  cluster JUMP (a := b) -> empty;
end;

theorem :: SCMFSA10:70
  NIC(AddTo(a,b), il) = {Next il};

registration
  let a, b;
  cluster JUMP AddTo(a, b) -> empty;
end;

theorem :: SCMFSA10:71
  NIC(SubFrom(a,b), il) = {Next il};

registration
  let a, b;
  cluster JUMP SubFrom(a, b) -> empty;
end;

theorem :: SCMFSA10:72
  NIC(MultBy(a,b), il) = {Next il};

registration
  let a, b;
  cluster JUMP MultBy(a,b) -> empty;
end;

theorem :: SCMFSA10:73
  NIC(Divide(a,b), il) = {Next il};

registration
  let a, b;
  cluster JUMP Divide(a,b) -> empty;
end;

theorem :: SCMFSA10:74
  NIC(goto i1, il) = {i1};

theorem :: SCMFSA10:75
  JUMP goto i1 = {i1};

registration
  let i1;
  cluster JUMP goto i1 -> non empty trivial;
end;

theorem :: SCMFSA10:76
  NIC(a=0_goto i1, il) = {i1, Next il};

theorem :: SCMFSA10:77
  JUMP (a=0_goto i1) = {i1};

registration
  let a, i1;
  cluster JUMP (a =0_goto i1) -> non empty trivial;
end;

theorem :: SCMFSA10:78
  NIC(a>0_goto i1, il) = {i1, Next il};

theorem :: SCMFSA10:79
  JUMP (a>0_goto i1) = {i1};

registration
  let a, i1;
  cluster JUMP (a >0_goto i1) -> non empty trivial;
end;

theorem :: SCMFSA10:80
  NIC(a:=(f,b), il) = {Next il};

registration
  let a, b, f;
  cluster JUMP (a:=(f,b)) -> empty;
end;

theorem :: SCMFSA10:81
  NIC((f,b):=a, il) = {Next il};

registration
  let a, b, f;
  cluster JUMP ((f,b):=a) -> empty;
end;

theorem :: SCMFSA10:82
  NIC(a:=len f, il) = {Next il};

registration
  let a, f;
  cluster JUMP (a:=len f) -> empty;
end;

theorem :: SCMFSA10:83
  NIC(f:=<0,...,0>a, il) = {Next il};

registration
  let a, f;
  cluster JUMP (f:=<0,...,0>a) -> empty;
end;

theorem :: SCMFSA10:84
  SUCC il = {il, Next il};

theorem :: SCMFSA10:85
  for f being IL-Function of NAT, SCM+FSA
  st for k being Element of NAT holds f.k = insloc k holds f is bijective &
  for k being Element of NAT holds f.(k+1) in SUCC (f.k) &
  for j being Element of NAT st f.j in SUCC (f.k) holds k <= j;

registration
  cluster SCM+FSA -> standard;
end;

theorem :: SCMFSA10:86
  il.(SCM+FSA,k) = insloc k;

theorem :: SCMFSA10:87
  Next il.(SCM+FSA,k) = il.(SCM+FSA,k+1);

theorem :: SCMFSA10:88
  Next il = NextLoc il;

registration
  cluster InsCode halt SCM+FSA -> jump-only InsType of SCM+FSA;
end;

registration
  cluster halt SCM+FSA -> jump-only;
end;

registration
  let i1;
  cluster InsCode goto i1 -> jump-only InsType of SCM+FSA;
end;

registration
  let i1;
  cluster goto i1 -> jump-only non sequential non ins-loc-free;
end;

registration
  let a, i1;
  cluster InsCode (a =0_goto i1) -> jump-only InsType of SCM+FSA;
  cluster InsCode (a >0_goto i1) -> jump-only InsType of SCM+FSA;
end;

registration
  let a, i1;
  cluster a =0_goto i1 -> jump-only non sequential non ins-loc-free;
  cluster a >0_goto i1 -> jump-only non sequential non ins-loc-free;
end;

registration
  let a, b;
  cluster InsCode (a:=b) -> non jump-only InsType of SCM+FSA;
  cluster InsCode AddTo(a,b) -> non jump-only InsType of SCM+FSA;
  cluster InsCode SubFrom(a,b) -> non jump-only InsType of SCM+FSA;
  cluster InsCode MultBy(a,b) -> non jump-only InsType of SCM+FSA;
  cluster InsCode Divide(a,b) -> non jump-only InsType of SCM+FSA;
end;

registration
  let a, b;
  cluster a:=b -> non jump-only sequential;
  cluster AddTo(a,b) -> non jump-only sequential;
  cluster SubFrom(a,b) -> non jump-only sequential;
  cluster MultBy(a,b) -> non jump-only sequential;
  cluster Divide(a,b) -> non jump-only sequential;
end;

registration
  let a, b, f;
  cluster InsCode (b:=(f,a)) -> non jump-only InsType of SCM+FSA;
  cluster InsCode ((f,a):=b) -> non jump-only InsType of SCM+FSA;
end;

registration
  let a, b, f;
  cluster b:=(f,a) -> non jump-only sequential;
  cluster (f,a):=b -> non jump-only sequential;
end;

registration
  let a, f;
  cluster InsCode (a:=len f) -> non jump-only InsType of SCM+FSA;
  cluster InsCode (f:=<0,...,0>a) -> non jump-only InsType of SCM+FSA;
end;

registration
  let a, f;
  cluster a:=len f -> non jump-only sequential;
  cluster f:=<0,...,0>a -> non jump-only sequential;
end;

registration
  cluster SCM+FSA -> homogeneous with_explicit_jumps without_implicit_jumps;
end;

registration
  cluster SCM+FSA -> regular;
end;

theorem :: SCMFSA10:89
  IncAddr(goto i1,k) = goto il.(SCM+FSA, locnum i1 + k);

theorem :: SCMFSA10:90
  IncAddr(a=0_goto i1,k) = a=0_goto il.(SCM+FSA, locnum i1 + k);

theorem :: SCMFSA10:91
  IncAddr(a>0_goto i1,k) = a>0_goto il.(SCM+FSA, locnum i1 + k);

registration
  cluster SCM+FSA -> IC-good Exec-preserving;
end;

