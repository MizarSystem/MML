:: On the Instructions of { \bf SCM+FSA }
::  by Artur Korni{\l}owicz
::
:: Received May 8, 2001
:: Copyright (c) 2001 Association of Mizar Users

environ

 vocabularies NUMBERS, SCMFSA_2, AMI_3, AMI_1, FSM_1, ORDINAL1, INT_1,
      FUNCOP_1, SUBSET_1, SCMFSA_1, CAT_1, XBOOLE_0, GRAPHSP, FINSEQ_1,
      RELAT_1, CARD_1, AMI_2, MCART_1, AMISTD_2, CARD_3, FUNCT_1, AMISTD_1,
      CIRCUIT2, FUNCT_4, SETFAM_1, ZFMISC_1, XXREAL_0, TARSKI, FUNCT_2,
      ARYTM_3, GOBOARD5, FRECHET, ARYTM_1, COMPLEX1, PARTFUN1, FINSEQ_2,
      UNIALG_1, CARD_5, FUNCT_7, RECDEF_2, NAT_1, VALUED_1, VALUED_0, STRUCT_0,
      SCMNORM, COMPOS_1;
 notations TARSKI, XBOOLE_0, ENUMSET1, SUBSET_1, MCART_1, SETFAM_1, RELAT_1,
      ZFMISC_1, FUNCT_1, PARTFUN1, FUNCT_2, REALSET1, ORDINAL1, XCMPLX_0,
      INT_1, FUNCOP_1, FINSEQ_1, FINSEQ_2, FUNCT_4, COMPLEX1, CARD_1, CARD_3,
      FUNCT_7, XXREAL_0, NAT_1, RECDEF_2, VALUED_0, VALUED_1, NUMBERS,
      STRUCT_0, COMPOS_1, EXTPRO_1, AMI_1, AMI_2, AMI_3, SCMFSA_1, SCMFSA_2,
      SCMFSA_3, AMISTD_1, AMISTD_2;
 constructors XXREAL_0, REAL_1, NAT_D, FINSEQ_4, REALSET1, AMI_3, SCMFSA_3,
      AMISTD_2, SEQ_1, RELSET_1, RECDEF_2, VALUED_1, VALUED_0, AMI_1, AMISTD_1,
      SCMFSA_1;
 registrations XBOOLE_0, SETFAM_1, RELAT_1, FUNCT_1, ORDINAL1, FUNCOP_1,
      NUMBERS, XREAL_0, NAT_1, INT_1, FINSEQ_1, AMI_1, SCMFSA_2, AMISTD_2,
      RELSET_1, CARD_3, FUNCT_2, ZFMISC_1, AMI_3, FUNCT_4, VALUED_0, VALUED_1,
      COMPOS_1, EXTPRO_1;
 requirements NUMERALS, BOOLE, SUBSET, REAL, ARITHM;


begin

reserve a, b, d1, d2, d3, d4 for Int-Location,
  A, B for Data-Location,
  f, f1, f2, f3 for FinSeq-Location,
  il, i1, i2 for Element of NAT,
  L for Element of NAT,
  I for Instruction of SCM+FSA,
  s,s1,s2 for State of SCM+FSA,
  T for InsType of SCM+FSA,
  k for natural number;

definition
  let la, lb be Int-Location, a, b be Integer;
  redefine func (la,lb) --> (a,b) -> FinPartState of SCM+FSA;
end;

canceled 2;

theorem :: SCMFSA10:3
  not a in NAT;

theorem :: SCMFSA10:4
  not f in NAT;

theorem :: SCMFSA10:5
  SCM+FSA-Data-Loc <> NAT;

theorem :: SCMFSA10:6
  SCM+FSA-Data*-Loc <> NAT;

theorem :: SCMFSA10:7
  for o being Object of SCM+FSA st o in Data-Locations SCM+FSA
   holds o is Int-Location or o is FinSeq-Location;

canceled;

theorem :: SCMFSA10:9
  a := b = [1,{},<*a,b*>];

theorem :: SCMFSA10:10
  AddTo(a,b) = [2,{},<*a,b*>];

theorem :: SCMFSA10:11
  SubFrom(a,b) = [3,{},<* a,b *>];

theorem :: SCMFSA10:12
  MultBy(a,b) = [4,{},<* a,b *>];

theorem :: SCMFSA10:13
  Divide(a,b) = [5,{},<* a,b *>];

canceled;

theorem :: SCMFSA10:15
  a=0_goto il = [7, <* il*>,<*a *>];

theorem :: SCMFSA10:16
  a>0_goto il = [8, <* il*>,<*a *>];

reserve J,K for Element of Segm 13,
  b,c,c1 for Element of SCM+FSA-Data-Loc,
  f,
  f1 for Element of SCM+FSA-Data*-Loc;

theorem :: SCMFSA10:17
  JumpPart halt SCM+FSA = {};

reserve a, b, d1, d2, d3, d4 for Int-Location,
  A, B for Data-Location,
  f, f1,
  f2, f3 for FinSeq-Location;

theorem :: SCMFSA10:18
  JumpPart (a:=b) = {};

theorem :: SCMFSA10:19
  JumpPart AddTo(a,b) = {};

theorem :: SCMFSA10:20
  JumpPart SubFrom(a,b) = {};

theorem :: SCMFSA10:21
  JumpPart MultBy(a,b) = {};

theorem :: SCMFSA10:22
  JumpPart Divide(a,b) = {};

canceled;

theorem :: SCMFSA10:24
  JumpPart (a=0_goto i1) = <*i1*>;

theorem :: SCMFSA10:25
  JumpPart (a>0_goto i1) = <*i1*>;

theorem :: SCMFSA10:26
  JumpPart (b:=(f,a)) = {};

theorem :: SCMFSA10:27
  JumpPart ((f,a):=b) = {};

theorem :: SCMFSA10:28
  JumpPart (a:=len f) = {};

theorem :: SCMFSA10:29
  JumpPart (f:=<0,...,0>a) = {};

theorem :: SCMFSA10:30
  T = 0 implies JumpParts T = {0};

theorem :: SCMFSA10:31
  T = 1 implies JumpParts T = {{}};

theorem :: SCMFSA10:32
  T = 2 implies JumpParts T = {{}};

theorem :: SCMFSA10:33
  T = 3 implies JumpParts T = {{}};

theorem :: SCMFSA10:34
  T = 4 implies JumpParts T = {{}};

theorem :: SCMFSA10:35
  T = 5 implies JumpParts T = {{}};

theorem :: SCMFSA10:36
  T = 6 implies dom product" JumpParts T = {1};

theorem :: SCMFSA10:37
  T = 7 implies dom product" JumpParts T = {1};

theorem :: SCMFSA10:38
  T = 8 implies dom product" JumpParts T = {1};

theorem :: SCMFSA10:39
  T = 9 implies JumpParts T = {{}};

theorem :: SCMFSA10:40
  T = 10 implies JumpParts T = {{}};

theorem :: SCMFSA10:41
  T = 11 implies JumpParts T = {{}};

theorem :: SCMFSA10:42
  T = 12 implies JumpParts T = {{}};

canceled 10;

theorem :: SCMFSA10:53
  (product" JumpParts InsCode goto i1).1 = NAT;

theorem :: SCMFSA10:54
  (product" JumpParts InsCode (a =0_goto i1)).1 = NAT;

canceled;


theorem :: SCMFSA10:56
  (product" JumpParts InsCode (a >0_goto i1)).1 = NAT;

canceled 11;

theorem :: SCMFSA10:68
  NIC(halt SCM+FSA, il) = {il};

registration
  cluster JUMP halt SCM+FSA -> empty;
end;

theorem :: SCMFSA10:69
  NIC(a := b, il) = {succ il};

registration
  let a, b;
  cluster JUMP (a := b) -> empty;
end;

theorem :: SCMFSA10:70
  NIC(AddTo(a,b), il) = {succ il};

registration
  let a, b;
  cluster JUMP AddTo(a, b) -> empty;
end;

theorem :: SCMFSA10:71
  NIC(SubFrom(a,b), il) = {succ il};

registration
  let a, b;
  cluster JUMP SubFrom(a, b) -> empty;
end;

theorem :: SCMFSA10:72
  NIC(MultBy(a,b), il) = {succ il};

registration
  let a, b;
  cluster JUMP MultBy(a,b) -> empty;
end;

theorem :: SCMFSA10:73
  NIC(Divide(a,b), il) = {succ il};

registration
  let a, b;
  cluster JUMP Divide(a,b) -> empty;
end;

theorem :: SCMFSA10:74
  NIC(goto i1, il) = {i1};

theorem :: SCMFSA10:75
  JUMP goto i1 = {i1};

registration
  let i1;
  cluster JUMP goto i1 -> non empty trivial;
end;

theorem :: SCMFSA10:76
  NIC(a=0_goto i1, il) = {i1, succ il};

theorem :: SCMFSA10:77
  JUMP (a=0_goto i1) = {i1};

registration
  let a, i1;
  cluster JUMP (a =0_goto i1) -> non empty trivial;
end;

theorem :: SCMFSA10:78
  NIC(a>0_goto i1, il) = {i1, succ il};

theorem :: SCMFSA10:79
  JUMP (a>0_goto i1) = {i1};

registration
  let a, i1;
  cluster JUMP (a >0_goto i1) -> non empty trivial;
end;

theorem :: SCMFSA10:80
  NIC(a:=(f,b), il) = {succ il};

registration
  let a, b, f;
  cluster JUMP (a:=(f,b)) -> empty;
end;

theorem :: SCMFSA10:81
  NIC((f,b):=a, il) = {succ il};

registration
  let a, b, f;
  cluster JUMP ((f,b):=a) -> empty;
end;

theorem :: SCMFSA10:82
  NIC(a:=len f, il) = {succ il};

registration
  let a, f;
  cluster JUMP (a:=len f) -> empty;
end;

theorem :: SCMFSA10:83
  NIC(f:=<0,...,0>a, il) = {succ il};

registration
  let a, f;
  cluster JUMP (f:=<0,...,0>a) -> empty;
end;

theorem :: SCMFSA10:84
  SUCC(il,SCM+FSA) = {il, succ il};

theorem :: SCMFSA10:85
  for k being Element of NAT holds k+1 in SUCC(k,SCM+FSA) &
   for j being Element of NAT st j in SUCC(k,SCM+FSA) holds k <= j;

registration
  cluster SCM+FSA -> standard;
end;

registration
  cluster InsCode halt SCM+FSA -> jump-only InsType of SCM+FSA;
end;

registration
  cluster halt SCM+FSA -> jump-only;
end;

registration
  let i1;
  cluster InsCode goto i1 -> jump-only InsType of SCM+FSA;
end;

registration
  let i1;
  cluster goto i1 -> jump-only non sequential non ins-loc-free;
end;

registration
  let a, i1;
  cluster InsCode (a =0_goto i1) -> jump-only InsType of SCM+FSA;
  cluster InsCode (a >0_goto i1) -> jump-only InsType of SCM+FSA;
end;

registration
  let a, i1;
  cluster a =0_goto i1 -> jump-only non sequential non ins-loc-free;
  cluster a >0_goto i1 -> jump-only non sequential non ins-loc-free;
end;

registration
  let a, b;
  cluster InsCode (a:=b) -> non jump-only InsType of SCM+FSA;
  cluster InsCode AddTo(a,b) -> non jump-only InsType of SCM+FSA;
  cluster InsCode SubFrom(a,b) -> non jump-only InsType of SCM+FSA;
  cluster InsCode MultBy(a,b) -> non jump-only InsType of SCM+FSA;
  cluster InsCode Divide(a,b) -> non jump-only InsType of SCM+FSA;
end;

registration
  let a, b;
  cluster a:=b -> non jump-only sequential;
  cluster AddTo(a,b) -> non jump-only sequential;
  cluster SubFrom(a,b) -> non jump-only sequential;
  cluster MultBy(a,b) -> non jump-only sequential;
  cluster Divide(a,b) -> non jump-only sequential;
end;

registration
  let a, b, f;
  cluster InsCode (b:=(f,a)) -> non jump-only InsType of SCM+FSA;
  cluster InsCode ((f,a):=b) -> non jump-only InsType of SCM+FSA;
end;

registration
  let a, b, f;
  cluster b:=(f,a) -> non jump-only sequential;
  cluster (f,a):=b -> non jump-only sequential;
end;

registration
  let a, f;
  cluster InsCode (a:=len f) -> non jump-only InsType of SCM+FSA;
  cluster InsCode (f:=<0,...,0>a) -> non jump-only InsType of SCM+FSA;
end;

registration
  let a, f;
  cluster a:=len f -> non jump-only sequential;
  cluster f:=<0,...,0>a -> non jump-only sequential;
end;

registration
  cluster SCM+FSA -> homogeneous with_explicit_jumps;
end;

registration
  cluster SCM+FSA -> regular J/A-independent;
end;

canceled 2;

theorem :: SCMFSA10:88
  IncAddr(goto i1,k) = goto (i1+ k);

theorem :: SCMFSA10:89
  IncAddr(a=0_goto i1,k) = a=0_goto (i1+k);

theorem :: SCMFSA10:90
  IncAddr(a>0_goto i1,k) = a>0_goto (i1+k);

registration
  cluster SCM+FSA -> IC-relocable;
end;

:: moved from SCMFSA6A, 2010.04.17, A.T.

theorem :: SCMFSA10:91
  for s1,s2 being State of SCM+FSA st IC s1 = IC s2 & (for a being
Int-Location holds s1.a = s2.a) & for f being FinSeq-Location holds s1.f = s2.f
  holds s1,s2 equal_outside NAT;

theorem :: SCMFSA10:92
  s1,s2 equal_outside NAT implies for a being Int-Location holds
  s1.a = s2.a;

theorem :: SCMFSA10:93
  s1,s2 equal_outside NAT implies for f being FinSeq-Location
  holds s1.f = s2.f;

registration
  cluster SCM+FSA -> Exec-preserving;
end;
