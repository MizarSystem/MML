:: Real Sequences and Basic Operations on Them
::  by Jaros{\l}aw Kotowicz
::
:: Received July 4, 1989
:: Copyright (c) 1990 Association of Mizar Users

environ

 vocabulary FUNCT_1, ARYTM, RELAT_1, PARTFUN1, BOOLE, ARYTM_1, ABSVALUE,
      ARYTM_3, SEQ_1, ZF_REFLE;
 notation TARSKI, XBOOLE_0, SUBSET_1, ORDINAL1, NUMBERS, XCMPLX_0, XREAL_0,
      NAT_1, REAL_1, RELAT_1, FUNCT_1, ABSVALUE, RELSET_1, PARTFUN1, FUNCT_2;
 constructors REAL_1, ABSVALUE, FUNCT_2, PARTFUN1, MEMBERED, XBOOLE_0;
 clusters XREAL_0, RELSET_1, FUNCT_2, MEMBERED, ZFMISC_1, XBOOLE_0, ORDINAL2;
 requirements NUMERALS, SUBSET, BOOLE, ARITHM;


begin

  reserve f for Function;
  reserve n,k,n1 for Nat;
  reserve r,p for real number;
  reserve x,y,z for set;

definition
 mode Real_Sequence is Function of NAT,REAL;
end;


reserve seq,seq1,seq2,seq3,seq',seq1' for Real_Sequence;

canceled 2;

theorem :: SEQ_1:3
 f is Real_Sequence iff (dom f=NAT & for x st x in NAT holds f.x is real);

theorem :: SEQ_1:4
f is Real_Sequence iff (dom f=NAT & for n holds f.n is real);

definition let f be Relation;
 attr f is real-yielding means
:: SEQ_1:def 1
 rng f c= REAL;
end;


registration let C be set;
 cluster -> real-yielding PartFunc of C, REAL;
 coherence
  proof let f be PartFunc of C, REAL;
   thus rng f c= REAL;
  end;
end;


registration
 cluster real-yielding Function;
 existence
  proof consider A being set;
   consider f being Function of A, REAL;
   take f;
   thus rng f c= REAL;
  end;
end;


registration let f be real-yielding Function, x be set;
 cluster f.x -> real;
  coherence
 proof per cases;
  suppose x in dom f;
    then A1:   f.x in rng f by FUNCT_1:12;
       rng f c= REAL by Def1;
   hence f.x in REAL by A1;
  end;
  suppose not x in dom f;
   hence thesis by CARD_1:51,FUNCT_1:def 4;
 end;
 end;
end;


definition let f be real-yielding Function, x be set;
 redefine func f.x -> Real;
end;


definition let C be set, f be PartFunc of C, REAL, x be set;
 redefine func f.x -> Real;
end;


notation
 let f be PartFunc of NAT, REAL;
 synonym f is being_not_0 for f is non-empty ;
  synonym f is_not_0 for f is non-empty ;
end;
definition
 let f be PartFunc of NAT, REAL;
 redefine attr f is being_not_0 means
:: SEQ_1:def 2
rng f c= REAL \ {0};
  end;


canceled;

theorem :: SEQ_1:6
  seq is being_not_0 iff for x st x in NAT holds seq.x<>0;

theorem :: SEQ_1:7
  seq is being_not_0 iff for n holds seq.n<>0;

theorem :: SEQ_1:8
   for seq,seq1 st (for x st x in NAT holds seq.x=seq1.x) holds seq=seq1;

canceled;

theorem :: SEQ_1:10
   for r ex seq st rng seq={r};

scheme :: SEQ_1:sch 1
 ExRealSeq{F(set)->real number}:
 ex seq st for n holds seq.n=F(n)
proof
   defpred P[set,set] means ex n st n=$1 & $2=F(n);
 A1: now let x;
     assume x in NAT;
     then consider n such that
  A2: n=x;
     reconsider r2=F(n) as set;
     take y=r2;
     thus P[x,y] by A2;
    end;
 A3: for x,y,z st x in NAT & P[x,y] & P[x,z] holds y=z;
   consider f such that
A4: dom f=NAT and
A5: for x st x in NAT holds P[x,f.x] from FUNCT_1:sch 2(A3,A1);
      now let x;
     assume x in NAT;
      then ex n st n=x & f.x=F(n) by A5;
     hence f.x is real;
    end;
   then reconsider f as Real_Sequence by A4,Th3;
   take seq=f;
   let n;
      ex k st k=n & seq.n=F(k) by A5;
   hence seq.n=F(n);
  end;

::
::  BASIC OPERATIONS ON SEQUENCES
::

scheme :: SEQ_1:sch 2
 PartFuncExD'{D,C()->non empty set, P[set,set]}:
 ex f being PartFunc of D(),C() st
  (for d be Element of D() holds
      d in dom f iff (ex c be Element of C() st P[d,c])) &
  (for d be Element of D() st d in dom f holds P[d,f.d])
proof
  consider x being Element of C();
   defpred X[Element of D(),Element of C()] means
    ((ex c be Element of C() st P[$1,c]) implies P[$1,$2]) &
    ((for c be Element of C() holds not P[$1,c]) implies $2=x);
A1: for d be Element of D() ex z be Element of C() st X[d,z]
:::    ((ex c be Element of C() st P[d,c]) implies P[d,z]) &
:::    ((for c be Element of C() holds not P[d,c]) implies z=x)
   proof let d be Element of D();
      (for c be Element of C() holds not P[d,c]) implies
     ex z st ((ex c be Element of C() st P[d,c]) implies P[d,z]) &
          ((for c be Element of C() holds not P[d,c]) implies z=x);
    hence thesis;
   end;
  consider g being Function of D(),C() such that
A2: for d be Element of D() holds X[d,g.d]
:::     ((ex c be Element of C() st P[d,c]) implies P[d,g.d]) &
:::     ((for c be Element of C() holds not P[d,c]) implies g.d=x)
       from FUNCT_2:sch 3(A1);
A3: dom g = D() & rng g c= C() by FUNCT_2:def 1;
   defpred X[set] means ex c be Element of C() st P[$1,c];
  consider X be set such that
A4: for x holds x in X iff x in D() & X[x]
:::& ex c be Element of C() st P[x,c]
       from XBOOLE_0:sch 1;
     for x holds x in X implies x in D() by A4;
  then reconsider X as Subset of D() by TARSKI:def 3;
   reconsider f=g|X as PartFunc of D(),C();
   take f;
   thus for d be Element of D() holds
      d in dom f iff (ex c be Element of C() st P[d,c])
    proof let d be Element of D();
       dom f c= X by RELAT_1:87;
hence d in dom f implies ex c be Element of C() st P[d,c] by A4;
     assume ex c be Element of C() st P[d,c];
     then d in X & d in D() by A4;
     then d in dom g /\ X by A3,XBOOLE_0:def 3;
     hence thesis by RELAT_1:90;
    end;
   let d be Element of D();
   assume A5: d in dom f;
     dom f c= X by RELAT_1:87;
   then ex c be Element of C() st P[d,c] by A4,A5;
   then P[d,g.d] by A2;
   hence thesis by A5,FUNCT_1:70;
 end;

scheme :: SEQ_1:sch 3
 LambdaPFD'{D,C()->non empty set, F(set)->Element of C(), P[set]}:
  ex f being PartFunc of D(),C() st
   (for d be Element of D() holds d in dom f iff P[d]) &
   (for d be Element of D() st d in dom f holds f.d = F(d))
proof   defpred X[Element of D(),set] means P[$1] & $2 = F($1);
   consider f being PartFunc of D(),C() such that
A1:  for d be Element of D() holds
      d in dom f iff ex c be Element of C() st X[d,c] :::P[c,d] & c = F(d)
      and
A2:  for d be Element of D() st d in dom f holds X[d,f.d] :::P[d] & f.d = F(d)
      from PartFuncExD';
   take f;
   thus for d be Element of D() holds d in dom f iff P[d]
    proof let d be Element of D();
     thus d in dom f implies P[d]
      proof assume d in dom f;
       then ex c be Element of C() st P[d] & c = F(d) by A1;
       hence thesis;
      end;
     assume P[d];
     then ex c be Element of C() st P[d] & c = F(d);
     hence thesis by A1;
    end;
   thus thesis by A2;
  end;

scheme :: SEQ_1:sch 4
 UnPartFuncD'{C,D,X() -> set, F(set)->set}:
  for f,g being PartFunc of C(),D() st
   (dom f=X() & for c be Element of C() st c in dom f holds f.c = F(c)) &
   (dom g=X() & for c be Element of C() st c in dom g holds g.c = F(c))
  holds f = g
proof let f,g be PartFunc of C(),D(); assume that
A1: (dom f=X() & for c be Element of C() st c in dom f holds f.c = F(c)) and
A2: dom g=X() & for c be Element of C() st c in dom g holds g.c = F(c);
   now let c be Element of C(); assume A3: c in dom f;
  hence f.c = F(c) by A1
            .= g.c by A1,A2,A3;
 end;
 hence thesis by A1,A2,PARTFUN1:34;
end;

definition let C be :::non empty
  set; let f1,f2 be PartFunc of C,REAL;
func f1+f2 -> PartFunc of C,REAL means
:: SEQ_1:def 3
 dom it = dom f1 /\ dom f2 &
  for c being Element of C st c in dom it holds it.c = f1.c + f2.c;
  commutativity;
func f1-f2 -> PartFunc of C,REAL means
:: SEQ_1:def 4
dom it = dom f1 /\ dom f2 &
 for c being Element of C st c in dom it holds it.c = f1.c - f2.c;
func f1(#)f2 -> PartFunc of C,REAL means
:: SEQ_1:def 5
dom it = dom f1 /\ dom f2 &
   for c being Element of C st c in dom it holds it.c = f1.c * f2.c;
  commutativity;
end;


theorem :: SEQ_1:11
 seq = seq1 + seq2 iff for n holds seq.n =seq1.n + seq2.n;

theorem :: SEQ_1:12
 seq = seq1 (#) seq2 iff for n holds seq.n =seq1.n * seq2.n;

registration
  let seq1,seq2;
  cluster seq1+seq2 -> total;
  coherence
   proof
       dom seq1 = NAT & dom seq2 = NAT by FUNCT_2:def 1;
    hence dom(seq1 + seq2) = NAT /\ NAT by Def3 .= NAT;
   end;
  cluster seq1(#)seq2 -> total;
  coherence
   proof
       dom seq1 = NAT & dom seq2 = NAT by FUNCT_2:def 1;
    hence dom(seq1 (#) seq2) = NAT /\ NAT by Def5 .= NAT;
   end;
end;

definition let C be set; let f be PartFunc of C,REAL;
   let r be real number;
func r(#)f -> PartFunc of C,REAL means
:: SEQ_1:def 6
 dom it = dom f & for c being Element of C st c in dom it holds it.c = r * f.c;
end;


registration
 let r,seq;
 cluster r(#)seq -> total;
 coherence
  proof
   thus dom(r(#)seq) = dom seq by Def6 .= NAT by FUNCT_2:def 1;
  end;
end;


theorem :: SEQ_1:13
  seq1 = r(#)seq2 iff for n holds seq1.n=r*seq2.n;

definition let C be set; let f be PartFunc of C,REAL;
func -f ->PartFunc of C,REAL means
:: SEQ_1:def 7
 dom it = dom f & for c being Element of C st c in dom it holds it.c = -(f.c);
end;


registration
 let seq;
 cluster - seq -> total;
 coherence
  proof
   thus dom -seq = dom seq by Def7 .= NAT by FUNCT_2:def 1;
  end;
end;


theorem :: SEQ_1:14
  seq1 = -seq2 iff for n holds seq1.n= -seq2.n;

registration
 let seq1,seq2;
 cluster seq1-seq2 -> total;
 coherence
  proof
      dom seq1 = NAT & dom seq2 = NAT by FUNCT_2:def 1;
   hence dom(seq1 - seq2) = NAT /\ NAT by Def4 .= NAT;
  end;
end;


theorem :: SEQ_1:15
 seq1 - seq2 = seq1 +- seq2;

definition
 let seq;
func seq" -> Real_Sequence means
:: SEQ_1:def 8
for n holds it.n=(seq.n)";
end;


definition
 let seq1,seq;
func seq1 /" seq ->Real_Sequence equals
:: SEQ_1:def 9
seq1(#)(seq");
end;


definition let C be set; let f be PartFunc of C,REAL;
func abs f -> PartFunc of C,REAL means
:: SEQ_1:def 10
 dom it = dom f & for c being Element of C st c in dom it holds
   it.c = abs(f.c);
end;


registration let seq;
  cluster abs seq -> total;
 coherence
  proof
   thus dom abs seq = dom seq by Def10 .= NAT by FUNCT_2:def 1;
  end;
end;


theorem :: SEQ_1:16
  seq1 = abs seq iff for n holds seq1.n= abs(seq.n);

canceled 3;

theorem :: SEQ_1:20
  (seq1+seq2)+seq3=seq1+(seq2+seq3);

canceled;

theorem :: SEQ_1:22
  (seq1(#)seq2)(#)seq3=seq1(#)(seq2(#)seq3);

theorem :: SEQ_1:23
  (seq1+seq2)(#)seq3=seq1(#)seq3+seq2(#)seq3;

theorem :: SEQ_1:24
    seq3(#)(seq1+seq2)=seq3(#)seq1+seq3(#)seq2;

theorem :: SEQ_1:25
  -seq=(-1)(#)seq;

theorem :: SEQ_1:26
  r(#)(seq1(#)seq2)=r(#)seq1(#)seq2;

theorem :: SEQ_1:27
  r(#)(seq1(#)seq2)=seq1(#)(r(#)seq2);

theorem :: SEQ_1:28
  (seq1-seq2)(#)seq3=seq1(#)seq3-seq2(#)seq3;

theorem :: SEQ_1:29
    seq3(#)seq1-seq3(#)seq2=seq3(#)(seq1-seq2);

theorem :: SEQ_1:30
  r(#)(seq1+seq2)=r(#)seq1+r(#)seq2;

theorem :: SEQ_1:31
  (r*p)(#)seq=r(#)(p(#)seq);

theorem :: SEQ_1:32
  r(#)(seq1-seq2)=r(#)seq1-r(#)seq2;

theorem :: SEQ_1:33
  r(#)(seq1/"seq)=(r(#)seq1)/"seq;

theorem :: SEQ_1:34
    seq1-(seq2+seq3)=seq1-seq2-seq3;

theorem :: SEQ_1:35
   1(#)seq=seq;

theorem :: SEQ_1:36
   -(-seq)=seq;

theorem :: SEQ_1:37
  seq1-(-seq2)=seq1+seq2;

theorem :: SEQ_1:38
    seq1-(seq2-seq3)=seq1-seq2+seq3;

theorem :: SEQ_1:39
    seq1+(seq2-seq3)=seq1+seq2-seq3;

theorem :: SEQ_1:40
    (-seq1)(#)seq2=-(seq1(#)seq2) & seq1(#)(-seq2)=-(seq1(#)seq2);

theorem :: SEQ_1:41
 seq is being_not_0 implies seq" is being_not_0;

theorem :: SEQ_1:42
 seq""=seq;

theorem :: SEQ_1:43
 seq is being_not_0 & seq1 is being_not_0 iff seq(#)seq1 is being_not_0;

theorem :: SEQ_1:44
 seq"(#)seq1"=(seq(#)seq1)";

theorem :: SEQ_1:45
   seq is being_not_0 implies (seq1/"seq)(#)seq=seq1;

theorem :: SEQ_1:46
   (seq'/"seq)(#)(seq1'/"seq1)=(seq'(#)seq1')/"(seq(#)seq1);

theorem :: SEQ_1:47
   seq is being_not_0 & seq1 is being_not_0 implies seq/"seq1 is being_not_0;

theorem :: SEQ_1:48
 (seq/"seq1)"=seq1/"seq;

theorem :: SEQ_1:49
  seq2(#)(seq1/"seq)=(seq2(#)seq1)/"seq;

theorem :: SEQ_1:50
    seq2/"(seq/"seq1)=(seq2(#)seq1)/"seq;

theorem :: SEQ_1:51
 seq1 is being_not_0 implies
                  seq2/"seq=(seq2(#)seq1)/"(seq(#)seq1);

theorem :: SEQ_1:52
 r<>0 & seq is being_not_0 implies r(#)seq is being_not_0;

theorem :: SEQ_1:53
   seq is being_not_0 implies -seq is being_not_0;

theorem :: SEQ_1:54
 (r(#)seq)"=r"(#)seq";

theorem :: SEQ_1:55
 (-seq)"=(-1)(#)seq";

theorem :: SEQ_1:56
   -seq1/"seq=(-seq1)/"seq & seq1/"(-seq)=-seq1/"seq;

theorem :: SEQ_1:57
  seq1/"seq + seq1'/"seq=(seq1+seq1')/"seq &
                           seq1/"seq - seq1'/"seq=(seq1-seq1')/"seq;

theorem :: SEQ_1:58
   seq is being_not_0 & seq' is being_not_0 implies
       (seq1/"seq + seq1'/"seq'=(seq1(#)seq'+seq1'(#)seq)/"(seq(#)seq')) &
       (seq1/"seq - seq1'/"seq'=(seq1(#)seq'-seq1'(#)seq)/"(seq(#)seq'));

theorem :: SEQ_1:59
   (seq1'/"seq)/"(seq'/"seq1)=(seq1'(#)seq1)/"(seq(#)seq');

theorem :: SEQ_1:60
 abs(seq(#)seq')=abs(seq)(#)abs(seq');

theorem :: SEQ_1:61
   seq is being_not_0 implies abs(seq) is being_not_0;

theorem :: SEQ_1:62
 abs(seq)"=abs(seq");

theorem :: SEQ_1:63
   abs(seq'/"seq)=abs(seq')/"abs(seq);

theorem :: SEQ_1:64
   abs(r(#)seq)=abs(r)(#)abs(seq);
