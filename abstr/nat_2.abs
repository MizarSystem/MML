:: Natural Numbers
::  by Robert Milewski
::
:: Received February 23, 1998
:: Copyright (c) 1998 Association of Mizar Users

environ

 vocabularies FINSEQ_1, FUNCT_1, INT_1, ARYTM_1, ARYTM_3, NAT_1, POWER,
      MATRIX_2, FINSEQ_4, REALSET1, ARYTM;
 notations TARSKI, XBOOLE_0, SUBSET_1, ORDINAL1, XCMPLX_0, XREAL_0, REALSET1,
      NUMBERS, INT_1, NAT_1, NAT_D, POWER, ABIAN, SERIES_1, FUNCT_1, PARTFUN1,
      FINSEQ_1, FINSEQ_4, BINARITH, XXREAL_0;
 constructors XXREAL_0, REAL_1, NAT_1, NAT_D, MEMBERED, FINSEQ_4, SERIES_1,
      REALSET1, BINARITH, ABIAN;
 registrations RELSET_1, XXREAL_0, XREAL_0, NAT_1, INT_1, MEMBERED, REALSET1,
      ABIAN, SERIES_1, ORDINAL1, XBOOLE_0;
 requirements REAL, NUMERALS, SUBSET, BOOLE, ARITHM;


begin :: Preliminaries

 reserve i, j, k, l, m, n, t for Nat;

  scheme :: NAT_2:sch 1
 NonUniqPiFinRecExD{D() -> non empty set, A() -> Element of D(),
                          N() -> Element of NAT, P[set,set,set]}:
   ex p be FinSequence of D() st len p = N() & (p/.1 = A() or N() = 0) &
    for n be Element of NAT st 1 <= n & n < N() holds P[n,p/.n,p/.(n+1)]
   provided
     for n be Element of NAT st 1 <= n & n < N() for x be Element of D()
         ex y be Element of D() st P[n,x,y];

canceled;

  theorem :: NAT_2:2
    for x,y be real number st x >= 0 & y > 0 holds
    x / ( [\ x / y /] + 1 ) < y;

begin :: Division and Rest of Division

canceled;

  theorem :: NAT_2:4
    0 div n = 0;

  theorem :: NAT_2:5
    for n be non empty Nat holds n div n = 1;

  theorem :: NAT_2:6
    n div 1 = n;

  theorem :: NAT_2:7
    i <= j & k <= j & i = j -' k + l implies k = j -' i + l;

  theorem :: NAT_2:8
    i in Seg n implies n -' i + 1 in Seg n;

  theorem :: NAT_2:9
    j < i implies i -' (j + 1) + 1 = i -' j;

  theorem :: NAT_2:10
   i >= j implies j -' i = 0;

  theorem :: NAT_2:11
   for i,j be non empty Nat holds
    i -' j < i;

  theorem :: NAT_2:12
    k <= n implies
    2 to_power n = (2 to_power k) * (2 to_power (n-'k));

  theorem :: NAT_2:13
    k <= n implies
    2 to_power k divides 2 to_power n;

  theorem :: NAT_2:14
    k > 0 & n div k = 0 implies n < k;

  theorem :: NAT_2:15
     k > 0 & k <= n implies n div k >= 1;

  theorem :: NAT_2:16
     k <> 0 implies (n+k) div k = (n div k) + 1;

  theorem :: NAT_2:17
     k divides n & 1 <= n & 1 <= i & i <= k implies
    (n -' i) div k = (n div k) - 1;

  theorem :: NAT_2:18
    k <= n implies
    (2 to_power n) div (2 to_power k) = 2 to_power (n -' k);

  theorem :: NAT_2:19
    n > 0 implies 2 to_power n mod 2 = 0;

  theorem :: NAT_2:20
    n > 0 implies
    (n mod 2 = 0 iff (n -' 1) mod 2 = 1);

  theorem :: NAT_2:21
    for n be non empty Nat st n <> 1 holds
    n > 1;

  theorem :: NAT_2:22
    n <= k & k < n + n implies k div n = 1;

  theorem :: NAT_2:23
    n is even iff n mod 2 = 0;

  theorem :: NAT_2:24
    n is odd iff n mod 2 = 1;

  theorem :: NAT_2:25
    1 <= t & k <= n & 2*t divides k implies
    (n div t is even iff (n-'k) div t is even);

  theorem :: NAT_2:26
    n <= m implies n div k <= m div k;

  theorem :: NAT_2:27
    k <= 2 * n implies
    (k+1) div 2 <= n;

  theorem :: NAT_2:28
    n is even implies
    n div 2 = (n + 1) div 2;

  theorem :: NAT_2:29
    (n div k) div i = n div (k*i);

  definition
   let n be Nat;
   redefine attr n is trivial means
:: NAT_2:def 1
    n = 0 or n = 1;
  end;

  registration
   cluster non trivial Element of NAT;
   cluster non trivial Nat;
  end;

  theorem :: NAT_2:30
    k is non trivial iff k is non empty & k <> 1;

  theorem :: NAT_2:31
    for k be non trivial Nat holds
    k >= 2;

  scheme :: NAT_2:sch 2
 Indfrom2 { P[set] } :
   for k be non trivial Element of NAT holds P[k]
   provided
     P[2] and
     for k be non trivial Element of NAT st P[k] holds P[k + 1];

begin :: Addenda

:: from POLYNOM1, 2007.03.18, A.T.

theorem :: NAT_2:32
  i-'j-'k = i-'(j+k);

