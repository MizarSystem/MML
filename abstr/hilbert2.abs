:: Defining by structural induction in the positive propositional language
::  by Andrzej Trybulec
::
:: Received April 23, 1999
:: Copyright (c) 1999 Association of Mizar Users

environ

 vocabulary PBOOLE, FUNCT_1, PROB_1, RELAT_1, TARSKI, FINSEQ_1, BOOLE,
      HILBERT1, TREES_1, TREES_3, TREES_2, TREES_4, TREES_9, FUNCT_6, QC_LANG1,
      ZF_LANG, GRAPH_1, ZFMISC_1, SETFAM_1, FRAENKEL, PARTFUN1, FUNCT_4, CAT_1,
      HILBERT2, HAHNBAN;
 notation TARSKI, XBOOLE_0, ZFMISC_1, SUBSET_1, NUMBERS, XREAL_0, NAT_1,
      PROB_1, RELAT_1, ORDINAL1, FUNCT_1, PARTFUN1, SETFAM_1, FINSEQ_1,
      FRAENKEL, CQC_LANG, FUNCT_4, FUNCT_6, PBOOLE, TREES_1, TREES_2, TREES_3,
      TREES_4, TREES_9, HILBERT1;
 constructors MSUALG_3, HILBERT1, FRAENKEL, CQC_LANG, NAT_1, TREES_9, PROB_1,
      MEMBERED;
 clusters SUBSET_1, RELSET_1, HILBERT1, FRAENKEL, TREES_2, TREES_3, FINSEQ_5,
      FUNCT_7, PRVECT_1, NAT_1, MEMBERED, NUMBERS, ORDINAL2;
 requirements NUMERALS, REAL, BOOLE, SUBSET, ARITHM;


begin :: Preliminaries

reserve X,x for set;

theorem :: HILBERT2:1
 for Z being set, M being ManySortedSet of Z st
  for x being set st x in Z holds M.x is ManySortedSet of x
 for f being Function st f = Union M holds dom f = union Z;

theorem :: HILBERT2:2
 for x,y being set, f,g being FinSequence st <*x*>^f = <*y*>^g
  holds f = g;

theorem :: HILBERT2:3
 <*x*> is FinSequence of X implies x in X;

theorem :: HILBERT2:4
 for X for f being FinSequence of X st f <> {}
  ex g being FinSequence of X, d being Element of X st f = g^<*d*>;

reserve k,m,n for Nat,
        p,q,r,s,r',s' for Element of HP-WFF,
        T1,T2 for Tree;

theorem :: HILBERT2:5
 <*x*> in tree(T1,T2) iff x=0 or x=1;

registration
 cluster {} -> Tree-yielding;
 coherence by TREES_3:23;
end;


scheme :: HILBERT2:sch 1
 InTreeInd{T() -> Tree, P[set] }:
 for f being Element of T() holds P[f]
 provided
 P[<*>NAT] and
 for f being Element of T() st P[f]
     for n st f^<*n*> in T() holds P[f^<*n*>]
proof
 defpred
  Q[FinSequence] means $1 in T() implies P[$1];
A3: Q[ {} ] by A1;
A4: for p being FinSequence, x being set st Q[p] holds Q[p^<*x*>]
    proof let p be FinSequence, x be set such that
A5:   Q[p];
     assume
A6:    p^<*x*> in T();
      then reconsider h = p^<*x*> as FinSequence of NAT by TREES_1:44;
      consider g being FinSequence of NAT, n such that
A7:     h = g^<*n*> by Th4;
A8:     g = p by A7,FINSEQ_2:20;
      reconsider g as Element of T() by A6,A7,TREES_1:46;
        P[g] by A5,A8;
     hence P[p^<*x*>] by A2,A6,A7;
    end;
    for p being FinSequence holds Q[p] from FINSEQ_1:sch 3(A3,A4);
 hence thesis;
end;

reserve
        T1,T2 for DecoratedTree;

theorem :: HILBERT2:6
 for x being set, T1, T2 holds (x-tree (T1,T2)).{} = x;

theorem :: HILBERT2:7
 x-tree(T1,T2).<*0*> = T1.{} & x-tree(T1,T2).<*1*> = T2.{};

theorem :: HILBERT2:8
 x-tree(T1,T2)|<*0*> = T1 & x-tree(T1,T2)|<*1*> = T2;

registration let x; let p be DTree-yielding non empty FinSequence;
 cluster x-tree p -> non root;
 coherence
  proof
A1: dom p <> {};
   assume x-tree p is root;
    then A2:   dom(x-tree p) = tree{} by TREES_3:55,TREES_9:def 1;
      ex q being DTree-yielding FinSequence st p = q &
      dom(x-tree p) = tree doms q by TREES_4:def 4;
    then doms p = {} by A2,TREES_3:53;
   hence contradiction by A1,RELAT_1:60,TREES_3:39;
  end;
end;


registration let x; let T1 be DecoratedTree;
 cluster x-tree T1 -> non root;
 coherence
  proof x-tree T1 = x-tree <*T1*> by TREES_4:def 5;
   hence thesis;
  end;
 let T2 be DecoratedTree;
 cluster x-tree (T1,T2) -> non root;
 coherence
  proof x-tree (T1,T2) = x-tree <*T1,T2*> by TREES_4:def 6;
   hence thesis;
  end;
end;


begin :: About the language

definition let n;
 func prop n -> Element of HP-WFF equals
:: HILBERT2:def 1
 <*3+n*>;
end;


definition let D be set;
 redefine attr D is with_VERUM means
:: HILBERT2:def 2
    VERUM in D;
  attr D is with_propositional_variables means
:: HILBERT2:def 3
    for n holds prop n in D;
end;


definition let D be Subset of HP-WFF;
 redefine attr D is with_implication means
:: HILBERT2:def 4
   for p, q st p in D & q in D holds p => q in D;
  attr D is with_conjunction means
:: HILBERT2:def 5
   for p, q st p in D & q in D holds p '&' q in D;
end;


reserve t,t1 for FinSequence;

definition let p;
 attr p is conjunctive means
:: HILBERT2:def 6
 ex r,s st p = r '&' s;
 attr p is conditional means
:: HILBERT2:def 7
 ex r,s st p = r => s;
 attr p is simple means
:: HILBERT2:def 8
 ex n st p = prop n;
end;


scheme :: HILBERT2:sch 2
 HP_Ind { P[set] }:
    for r holds P[r]
  provided
 P[VERUM] and
 for n holds P[prop n] and
 for r,s st P[r] & P[s] holds P[r '&' s] & P[r => s]
proof
   set X = { p where p is Element of HP-WFF: P[p]};
     X c= HP-WFF
    proof let x be set;
     assume x in X;
     then ex p being Element of HP-WFF st x = p & P[p];
     hence x in HP-WFF;
    end;
   then reconsider X as Subset of HP-WFF;
A4:  HP-WFF c= NAT* by HILBERT1:def 5;
A5: X c= NAT*
    proof let x be set;
     assume x in X;
     then x in HP-WFF;
     hence x in NAT* by A4;
    end;
A6: X is with_VERUM
     proof thus VERUM in X by A1; end;
A7: X is with_implication
     proof let p, q;
      assume p in X;
       then A8:     ex x being Element of HP-WFF st p = x & P[x];
      assume q in X;
       then ex x being Element of HP-WFF st q = x & P[x];
       then P[p => q] by A3,A8;
      hence p => q in X;
     end;
A9: X is with_conjunction
     proof let p, q;
      assume p in X;
       then A10:     ex x being Element of HP-WFF st p = x & P[x];
      assume q in X;
       then ex x being Element of HP-WFF st q = x & P[x];
       then P[p '&' q] by A3,A10;
      hence p '&' q in X;
     end;
     X is with_propositional_variables
    proof let n;
        P[prop n] by A2;
     hence prop n in X;
    end;
   then X is HP-closed by A5,A6,A7,A9,HILBERT1:def 5;
   then A11:  HP-WFF c= X by HILBERT1:def 6;
  let r;
      r in HP-WFF;
   then r in X by A11;
   then ex p being Element of HP-WFF st r = p & P[p];
  hence thesis;
 end;

theorem :: HILBERT2:9
  p is conjunctive or p is conditional or p is simple or p = VERUM;

theorem :: HILBERT2:10
len p >= 1;

theorem :: HILBERT2:11
 p.1 = 1 implies p is conditional;

theorem :: HILBERT2:12
 p.1 = 2 implies p is conjunctive;

theorem :: HILBERT2:13
   p.1 = 3+n implies p is simple;

theorem :: HILBERT2:14
   p.1 = 0 implies p = VERUM;

theorem :: HILBERT2:15
 len p < len(p '&' q) & len q < len(p '&' q);

theorem :: HILBERT2:16
 len p < len(p => q) & len q < len(p => q);

theorem :: HILBERT2:17
 p = q^t implies p = q;

theorem :: HILBERT2:18
 p^q = r^s implies p = r & q = s;

theorem :: HILBERT2:19
 p '&' q = r '&' s implies p = r & s = q;

theorem :: HILBERT2:20
 p => q = r => s implies p = r & s = q;

theorem :: HILBERT2:21
 prop n = prop m implies n = m;

theorem :: HILBERT2:22
 p '&' q <> r => s;

theorem :: HILBERT2:23
 p '&' q <> VERUM;

theorem :: HILBERT2:24
 p '&' q <> prop n;

theorem :: HILBERT2:25
 p => q <> VERUM;

theorem :: HILBERT2:26
 p => q <> prop n;

theorem :: HILBERT2:27
 p '&' q <> p & p '&' q <> q;

theorem :: HILBERT2:28
 p => q <> p & p => q <> q;

theorem :: HILBERT2:29
 VERUM <> prop n;

begin :: Defining by structural induction

scheme :: HILBERT2:sch 3
 HP_MSSExL{V()->set,P(Nat)->set,
          C,I[Element of HP-WFF,Element of HP-WFF,set,set,set]}:
 ex M being ManySortedSet of HP-WFF st
  M.VERUM = V() &
  (for n holds M.prop n = P(n)) &
  for p,q holds C[p,q,M.p,M.q,M.(p '&' q)] & I[p,q,M.p,M.q,M.(p => q)]
  provided
 for p,q for a,b being set ex c being set st C[p,q,a,b,c] and
 for p,q for a,b being set ex d being set st I[p,q,a,b,d] and
 for p,q for a,b,c,d being set st C[p,q,a,b,c] & C[p,q,a,b,d]
        holds c = d and
 for p,q for a,b,c,d being set st I[p,q,a,b,c] & I[p,q,a,b,d] holds c = d
proof
 set X = { Y where Y is Subset of HP-WFF:
           VERUM in Y & (for n holds prop n in Y) &
           (for p,q st p '&' q in Y or p => q in Y holds p in Y & q in Y) &
   ex M being ManySortedSet of Y st
    M.VERUM = V() &
    (for n holds M.prop n = P(n)) &
    (for p,q st p '&' q in Y
      for a,b,c being set st a = M.p & b = M.q & c = M.(p '&' q)
       holds C[p,q,a,b,c] ) &
     for p,q st p => q in Y
      for a,b,c being set st a = M.p & b = M.q & c = M.(p => q)
       holds I[p,q,a,b,c] };
  set Pn = { prop n: not contradiction};
A5: Pn c= HP-WFF
   proof let x be set;
    assume x in Pn;
     then ex n st x = prop n;
    hence x in HP-WFF;
   end;
    {VERUM} c= HP-WFF by ZFMISC_1:37;
  then reconsider Y0 = Pn \/ {VERUM} as Subset of HP-WFF by A5,XBOOLE_1:8;
  defpred P[set,set] means
    ($1 = VERUM implies $2 = V()) &
    for n st $1 = prop n holds $2 = P(n);
A6: for x being set st x in Y0 ex y being set st P[x,y]
    proof let x be set;
     assume
A7:    x in Y0;
     per cases by A7,XBOOLE_0:def 2;
     suppose x in Pn;
      then consider n such that
A8:     x = prop n;
     take P(n);
     thus x = VERUM implies P(n) = V() by A8,Th29;
     let k;
     assume x = prop k;
     hence thesis by A8,Th21;
     end;
     suppose x in { VERUM };
then A9:     x = VERUM by TARSKI:def 1;
     take V();
     thus thesis by A9,Th29;
    end;
    end;
   consider M0 being ManySortedSet of Y0 such that
A10:  for x being set st x in Y0 holds P[x,M0.x] from MSUALG_1:sch 1(A6);
      VERUM in {VERUM} by TARSKI:def 1;
    then A11: VERUM in Y0 by XBOOLE_0:def 2;
then A12: M0.VERUM = V() by A10;
A13: for n holds prop n in Y0
      proof let k; prop k in Pn; hence thesis by XBOOLE_0:def 2; end;
A14: for n holds M0.prop n = P(n)
     proof let n; prop n in Y0 by A13; hence thesis by A10; end;
A15: for p,q holds not p '&' q in Y0 & not p => q in Y0
     proof let p,q;
      assume
A16:     not thesis;
      per cases by A16,XBOOLE_0:def 2;
      suppose p '&' q in {VERUM} or p => q in {VERUM};
       then p '&' q = VERUM or p => q = VERUM by TARSKI:def 1;
      hence contradiction by Th23,Th25;
      end;
      suppose p '&' q in Pn;
       then ex n st p '&' q = prop n;
       hence contradiction by Th24;
      end;
      suppose p => q in Pn;
       then ex n st p => q = prop n;
       hence contradiction by Th26;
     end;
     end;
then A17:  for p,q st p '&' q in Y0 or p => q in Y0 holds p in Y0 & q in Y0;
      (for p,q st p '&' q in Y0
    for x,y,z being set st x = M0.p & y = M0.q & z = M0.(p '&' q)
      holds C[p,q,x,y,z]) &
    for p,q st p => q in Y0
    for x,y,z being set st x = M0.p & y = M0.q & z = M0.(p => q)
      holds I[p,q,x,y,z] by A15;
   then A18: Y0 in X by A11,A12,A13,A14,A17;
     for Z being set st Z <> {} & Z c= X &
    Z is c=-linear
     holds union Z in X
    proof let Z be set such that
A19:   Z <> {} and
A20:   Z c= X and
A21:   Z is c=-linear;
A22:  X c= bool HP-WFF
      proof let x be set;
       assume x in X;
        then ex Y being Subset of HP-WFF st x = Y &
           VERUM in Y & (for n holds prop n in Y) &
           (for p,q st p '&' q in Y or p => q in Y holds p in Y & q in Y) &
       ex M being ManySortedSet of Y st
        M.VERUM = V() &
        (for n holds M.prop n = P(n)) &
        (for p,q st p '&' q in Y
        for x,y,z being set st x = M.p & y = M.q & z = M.(p '&' q)
         holds C[p,q,x,y,z]) &
        for p,q st p => q in Y
        for x,y,z being set st x = M.p & y = M.q & z = M.(p => q)
         holds I[p,q,x,y,z];
       hence x in bool HP-WFF;
      end;
     then X is Subset-Family of HP-WFF by SETFAM_1:def 7;
     then reconsider uZ = union Z as Subset of HP-WFF by A20,BORSUK_1:25;
     consider Z0 being set such that
A23:  Z0 in Z by A19,XBOOLE_0:def 1;
A24:  Z0 c= uZ by A23,ZFMISC_1:92;
A25:  Y0 c= Z0
      proof let x be set;
          Z0 in X by A20,A23;
        then consider Y being Subset of HP-WFF such that
A26:     Y = Z0 and
A27:     VERUM in Y and
A28:     for n holds prop n in Y and
             (for p,q st p '&' q in Y or p => q in Y holds p in Y & q in Y) &
   ex M being ManySortedSet of Y st
    M.VERUM = V() &
    (for n holds M.prop n = P(n)) &
    (for p,q st p '&' q in Y
    for x,y,z being set st x = M.p & y = M.q & z = M.(p '&' q)
     holds C[p,q,x,y,z]) &
    for p,q st p => q in Y
    for x,y,z being set st x = M.p & y = M.q & z = M.(p => q)
     holds I[p,q,x,y,z];
       assume
A29:     x in Y0;
        per cases by A29,XBOOLE_0:def 2;
       suppose x in {VERUM};
       hence x in Z0 by A26,A27,TARSKI:def 1;
       end;
       suppose x in Pn;
        then ex n st x = prop n;
       hence x in Z0 by A26,A28;
      end;
      end;
     then A30:   Y0 c= uZ by A24,XBOOLE_1:1;
A31:  for n holds prop n in uZ
      proof let n;
          prop n in Y0 by A13;
       hence thesis by A30;
      end;
A32:  for p,q st p '&' q in uZ or p => q in uZ holds p in uZ & q in uZ
     proof let p,q;
      assume
A33:     p '&' q in uZ or p => q in uZ;
      per cases by A33;
      suppose p '&' q in uZ;
       then consider Z0 being set such that
A34:     p '&' q in Z0 and
A35:     Z0 in Z by TARSKI:def 4;
         Z0 in X by A20,A35;
       then ex Y being Subset of HP-WFF st
         Z0 = Y & VERUM in Y & (for n holds prop n in Y) &
         (for p,q st p '&' q in Y or p => q in Y holds p in Y & q in Y) &
         ex M being ManySortedSet of Y st
          M.VERUM = V() &
          (for n holds M.prop n = P(n)) &
          (for p,q st p '&' q in Y
          for x,y,z being set st x = M.p & y = M.q & z = M.(p '&' q)
           holds C[p,q,x,y,z]) &
          for p,q st p => q in Y
          for x,y,z being set st x = M.p & y = M.q & z = M.(p => q)
           holds I[p,q,x,y,z];
       then p in Z0 & q in Z0 by A34;
      hence p in uZ & q in uZ by A35,TARSKI:def 4;
      end;
      suppose p => q in uZ;
       then consider Z0 being set such that
A36:     p => q in Z0 and
A37:     Z0 in Z by TARSKI:def 4;
         Z0 in X by A20,A37;
       then ex Y being Subset of HP-WFF st
         Z0 = Y & VERUM in Y & (for n holds prop n in Y) &
         (for p,q st p '&' q in Y or p => q in Y holds p in Y & q in Y) &
         ex M being ManySortedSet of Y st
          M.VERUM = V() &
          (for n holds M.prop n = P(n)) &
          (for p,q st p '&' q in Y
          for x,y,z being set st x = M.p & y = M.q & z = M.(p '&' q)
           holds C[p,q,x,y,z]) &
          for p,q st p => q in Y
          for x,y,z being set st x = M.p & y = M.q & z = M.(p => q)
           holds I[p,q,x,y,z];
       then p in Z0 & q in Z0 by A36;
      hence p in uZ & q in uZ by A37,TARSKI:def 4;
     end;
     end;
  defpred P[set,set] means
    ex M being ManySortedSet of $1 st M = $2 &
    M.VERUM = V() &
    (for n holds M.prop n = P(n)) &
    (for p,q st p '&' q in $1
    for x,y,z being set st x = M.p & y = M.q & z = M.(p '&' q)
     holds C[p,q,x,y,z]) &
    for p,q st p => q in $1
    for x,y,z being set st x = M.p & y = M.q & z = M.(p => q)
     holds I[p,q,x,y,z];
A38: for x being set st x in Z ex y being set st P[x,y]
    proof let x be set;
     assume x in Z;
      then x in X by A20;
      then consider Y being Subset of HP-WFF such that
A39:    Y = x and
             VERUM in Y & (for n holds prop n in Y) &
           (for p,q st p '&' q in Y or p => q in Y holds p in Y & q in Y) and
A40:   ex M being ManySortedSet of Y st
       M.VERUM = V() &
       (for n holds M.prop n = P(n)) &
       (for p,q st p '&' q in Y
       for x,y,z being set st x = M.p & y = M.q & z = M.(p '&' q)
        holds C[p,q,x,y,z]) &
       for p,q st p => q in Y
       for x,y,z being set st x = M.p & y = M.q & z = M.(p => q)
        holds I[p,q,x,y,z];
       consider M being ManySortedSet of Y such that
A41:     M.VERUM = V() &
       (for n holds M.prop n = P(n)) &
       (for p,q st p '&' q in Y
       for x,y,z being set st x = M.p & y = M.q & z = M.(p '&' q)
        holds C[p,q,x,y,z]) &
       for p,q st p => q in Y
       for x,y,z being set st x = M.p & y = M.q & z = M.(p => q)
        holds I[p,q,x,y,z] by A40;
     take M;
     thus P[x,M] by A39,A41;
    end;
   consider MM being ManySortedSet of Z such that
A42:   for x being set st x in Z holds P[x,MM.x] from MSUALG_1:sch 1(A38);
     rng MM is functional
    proof let y be set;
     assume y in rng MM;
      then consider x being set such that
A43:    x in dom MM and
A44:    y = MM.x by FUNCT_1:def 5;
        x in Z by A43,PBOOLE:def 3;
      then P[x,y] by A42,A44;
     hence y is Function;
    end;
   then reconsider rr = rng MM as functional set;
A45: for f, g being Function st f in rr & g in rr & dom f c= dom g holds
    f tolerates g
    proof let f, g be Function;
     assume f in rr;
      then consider x1 being set such that
A46:    x1 in dom MM and
A47:    f = MM.x1 by FUNCT_1:def 5;
A48:  x1 in Z by A46,PBOOLE:def 3;
then A49:    ex M being ManySortedSet of x1 st M = f &
      M.VERUM = V() &
      (for n holds M.prop n = P(n)) &
      (for p,q st p '&' q in x1
      for x,y,z being set st x = M.p & y = M.q & z = M.(p '&' q)
       holds C[p,q,x,y,z]) &
      for p,q st p => q in x1
      for x,y,z being set st x = M.p & y = M.q & z = M.(p => q)
       holds I[p,q,x,y,z] by A42,A47;
     assume g in rr;
      then consider x2 being set such that
A50:    x2 in dom MM and
A51:    g = MM.x2 by FUNCT_1:def 5;
        x2 in Z by A50,PBOOLE:def 3;
      then A52:    ex M being ManySortedSet of x2 st M = g &
      M.VERUM = V() &
      (for n holds M.prop n = P(n)) &
      (for p,q st p '&' q in x2
      for x,y,z being set st x = M.p & y = M.q & z = M.(p '&' q)
       holds C[p,q,x,y,z]) &
      for p,q st p => q in x2
      for x,y,z being set st x = M.p & y = M.q & z = M.(p => q)
       holds I[p,q,x,y,z] by A42,A51;
     assume
A53:  dom f c= dom g;
     let x be set;
     assume
A54:  x in dom f /\ dom g;
A55:  x1 = dom f by A49,PBOOLE:def 3;
then A56:   x in x1 by A53,A54,XBOOLE_1:28;
A57:  x1 in X by A20,A48;
defpred P[Element of HP-WFF] means $1 in x1 implies f.$1 = g.$1;
A58:  P[VERUM] by A49,A52;
A59: for n holds P[prop n]
     proof let n such that prop n in x1;
      thus f.prop n = P(n) by A49 .= g.prop n by A52;
     end;
A60: for r,s st P[r] & P[s]
      holds P[r '&' s] & P[r => s]
     proof let r,s such that
A61:    r in x1 implies f.r = g.r and
A62:    s in x1 implies f.s = g.s;
      consider Y being Subset of HP-WFF such that
A63:    Y = x1 and
         VERUM in Y & (for n holds prop n in Y) and
A64:    for p,q st p '&' q in Y or p => q in Y holds p in Y & q in Y and
        ex M being ManySortedSet of Y st
       M.VERUM = V() &
       (for n holds M.prop n = P(n)) &
       (for p,q st p '&' q in Y
       for x,y,z being set st x = M.p & y = M.q & z = M.(p '&' q)
        holds C[p,q,x,y,z]) &
       for p,q st p => q in Y
       for x,y,z being set st x = M.p & y = M.q & z = M.(p => q)
        holds I[p,q,x,y,z] by A57;
A65:   x1 c= x2 by A52,A53,A55,PBOOLE:def 3;
      thus r '&' s in x1 implies f.(r '&' s) = g.(r '&' s)
       proof assume r '&' s in x1;
         then C[r,s,g.r,g.s,f.(r '&' s)] & C[r,s,g.r,g.s,g.(r '&' s)]
             by A49,A52,A61,A62,A63,A64,A65;
        hence f.(r '&' s) = g.(r '&' s) by A3;
       end;
      thus r => s in x1 implies f.(r => s) = g.(r => s)
       proof assume r => s in x1;
         then I[r,s,g.r,g.s,f.(r => s)] & I[r,s,g.r,g.s,g.(r => s)]
             by A49,A52,A61,A62,A63,A64,A65;
        hence f.(r => s) = g.(r => s) by A4;
       end;
     end;
        for p holds P[p] from HP_Ind(A58,A59,A60);
     hence f.x = g.x by A22,A56,A57;
    end;
     for f, g being Function st f in rr & g in rr holds f tolerates g
    proof let f, g be Function;
     assume
A66:   f in rr;
      then consider x1 being set such that
A67:    x1 in dom MM and
A68:    f = MM.x1 by FUNCT_1:def 5;
A69:  x1 in Z by A67,PBOOLE:def 3;
then A70:    ex M being ManySortedSet of x1 st M = f &
      M.VERUM = V() &
      (for n holds M.prop n = P(n)) &
      (for p,q st p '&' q in x1
      for x,y,z being set st x = M.p & y = M.q & z = M.(p '&' q)
       holds C[p,q,x,y,z]) &
      for p,q st p => q in x1
      for x,y,z being set st x = M.p & y = M.q & z = M.(p => q)
       holds I[p,q,x,y,z] by A42,A68;
     assume
A71:   g in rr;
      then consider x2 being set such that
A72:    x2 in dom MM and
A73:    g = MM.x2 by FUNCT_1:def 5;
A74:  x2 in Z by A72,PBOOLE:def 3;
    then ex M being ManySortedSet of x2 st M = g &
      M.VERUM = V() &
      (for n holds M.prop n = P(n)) &
      (for p,q st p '&' q in x2
      for x,y,z being set st x = M.p & y = M.q & z = M.(p '&' q)
       holds C[p,q,x,y,z]) &
      for p,q st p => q in x2
      for x,y,z being set st x = M.p & y = M.q & z = M.(p => q)
       holds I[p,q,x,y,z] by A42,A73;
then A75:   x1 = dom f & x2 = dom g by A70,PBOOLE:def 3;
        x1,x2 are_c=-comparable by A21,A69,A74,ORDINAL1:def 9;
      then x1 c= x2 or x2 c= x1 by XBOOLE_0:def 9;
     hence f tolerates g by A45,A66,A71,A75;
    end;
   then union rr is Function by WELLFND1:2;
   then reconsider M = Union MM as Function by PROB_1:def 3;
      for x being set st x in Z holds MM.x is ManySortedSet of x
    proof let x be set;
     assume x in Z;
      then P[x,MM.x] by A42;
     hence MM.x is ManySortedSet of x;
    end;
   then dom M = uZ by Th1;
   then reconsider M as ManySortedSet of uZ by PBOOLE:def 3;
A76: M = union rr by PROB_1:def 3;
     Z0 in dom MM by A23,PBOOLE:def 3;
   then MM.Z0 in rr by FUNCT_1:def 5;
then A77:   MM.Z0 c= M by A76,ZFMISC_1:92;
   consider MZ0 being ManySortedSet of Z0 such that
A78:  MZ0 = MM.Z0 and
A79:  MZ0.VERUM = V() and
A80:  for n holds MZ0.prop n = P(n) and
      (for p,q st p '&' q in Z0
    for x,y,z being set st x = MZ0.p & y = MZ0.q & z = MZ0.(p '&' q)
     holds C[p,q,x,y,z]) &
    for p,q st p => q in Z0
    for x,y,z being set st x = MZ0.p & y = MZ0.q & z = MZ0.(p => q)
     holds I[p,q,x,y,z] by A23,A42;
A81: Y0 c= dom MZ0 by A25,PBOOLE:def 3;
then A82:  M.VERUM = V() by A11,A77,A78,A79,GRFUNC_1:8;
A83:  for n holds M.prop n = P(n)
     proof let n;
         prop n in Y0 by A13;
      hence M.prop n = MZ0.prop n by A77,A78,A81,GRFUNC_1:8 .= P(n) by A80;
     end;
A84:  for p,q st p '&' q in uZ
      for x,y,z being set st x = M.p & y = M.q & z = M.(p '&' q)
       holds C[p,q,x,y,z]
     proof let p,q;
      assume p '&' q in uZ;
       then consider Z1 being set such that
A85:      p '&' q in Z1 and
A86:      Z1 in Z by TARSKI:def 4;
       consider MZ1 being ManySortedSet of Z1 such that
A87:     MZ1 = MM.Z1 and
         MZ1.VERUM = V() &
       (for n holds MZ1.prop n = P(n)) and
A88:    for p,q st p '&' q in Z1
       for x,y,z being set st x = MZ1.p & y = MZ1.q & z = MZ1.(p '&' q)
        holds C[p,q,x,y,z] and
         for p,q st p => q in Z1
       for x,y,z being set st x = MZ1.p & y = MZ1.q & z = MZ1.(p => q)
        holds I[p,q,x,y,z] by A42,A86;
         Z1 in dom MM by A86,PBOOLE:def 3;
       then MM.Z1 in rr by FUNCT_1:def 5;
then A89:      MM.Z1 c= M by A76,ZFMISC_1:92;
      let x,y,z be set;
      assume
A90:     x = M.p & y = M.q & z = M.(p '&' q);
         Z1 in X by A20,A86;
       then ex Y being Subset of HP-WFF st Z1 = Y &
        VERUM in Y & (for n holds prop n in Y) &
        (for p,q st p '&' q in Y or p => q in Y holds p in Y & q in Y) &
        ex M being ManySortedSet of Y st
         M.VERUM = V() &
         (for n holds M.prop n = P(n)) &
         (for p,q st p '&' q in Y
         for x,y,z being set st x = M.p & y = M.q & z = M.(p '&' q)
          holds C[p,q,x,y,z]) &
         for p,q st p => q in Y
         for x,y,z being set st x = M.p & y = M.q & z = M.(p => q)
          holds I[p,q,x,y,z];
       then p in Z1 & q in Z1 by A85;
       then p in dom MZ1 & q in dom MZ1 & p '&' q in
 dom MZ1 by A85,PBOOLE:def 3;
       then x = MZ1.p & y = MZ1.q & z = MZ1.(p '&' q) by A87,A89,A90,GRFUNC_1:8
;
      hence C[p,q,x,y,z] by A85,A88;
     end;
      for p,q st p => q in uZ
     for x,y,z being set st x = M.p & y = M.q & z = M.(p => q)
      holds I[p,q,x,y,z]
     proof let p,q;
      assume p => q in uZ;
       then consider Z1 being set such that
A91:      p => q in Z1 and
A92:      Z1 in Z by TARSKI:def 4;
       consider MZ1 being ManySortedSet of Z1 such that
A93:     MZ1 = MM.Z1 and
         MZ1.VERUM = V() &
       (for n holds MZ1.prop n = P(n)) and
         for p,q st p '&' q in Z1
       for x,y,z being set st x = MZ1.p & y = MZ1.q & z = MZ1.(p '&' q)
        holds C[p,q,x,y,z] and
A94:    for p,q st p => q in Z1
       for x,y,z being set st x = MZ1.p & y = MZ1.q & z = MZ1.(p => q)
        holds I[p,q,x,y,z] by A42,A92;
         Z1 in dom MM by A92,PBOOLE:def 3;
       then MM.Z1 in rr by FUNCT_1:def 5;
       then A95:      MM.Z1 c= M by A76,ZFMISC_1:92;
      let x,y,z be set;
      assume
A96:     x = M.p & y = M.q & z = M.(p => q);
         Z1 in X by A20,A92;
       then ex Y being Subset of HP-WFF st Z1 = Y &
        VERUM in Y & (for n holds prop n in Y) &
        (for p,q st p '&' q in Y or p => q in Y holds p in Y & q in Y) &
        ex M being ManySortedSet of Y st
         M.VERUM = V() &
         (for n holds M.prop n = P(n)) &
         (for p,q st p '&' q in Y
         for x,y,z being set st x = M.p & y = M.q & z = M.(p '&' q)
          holds C[p,q,x,y,z]) &
         for p,q st p => q in Y
         for x,y,z being set st x = M.p & y = M.q & z = M.(p => q)
          holds I[p,q,x,y,z];
       then p in Z1 & q in Z1 by A91;
       then p in dom MZ1 & q in dom MZ1 & p => q in
 dom MZ1 by A91,PBOOLE:def 3;
       then x = MZ1.p & y = MZ1.q & z = MZ1.(p => q) by A93,A95,A96,GRFUNC_1:8
;
      hence I[p,q,x,y,z] by A91,A94;
     end;
     hence union Z in X by A11,A30,A31,A32,A82,A83,A84;
    end;
   then consider H being set such that
A97:  H in X and
A98: for Z being set st Z in X & Z <> H holds not H c= Z by A18,ORDERS_2:79;
  consider Y being Subset of HP-WFF such that
A99: Y = H and
A100:  VERUM in Y & (for n holds prop n in Y) and
A101:  for p,q st p '&' q in Y or p => q in Y holds p in Y & q in Y and
A102:  ex M being ManySortedSet of Y st
    M.VERUM = V() &
    (for n holds M.prop n = P(n)) &
    (for p,q st p '&' q in Y
    for x,y,z being set st x = M.p & y = M.q & z = M.(p '&' q)
     holds C[p,q,x,y,z]) &
    for p,q st p => q in Y
    for x,y,z being set st x = M.p & y = M.q & z = M.(p => q)
     holds I[p,q,x,y,z] by A97;
   consider M being ManySortedSet of Y such that
A103:  M.VERUM = V() &
    (for n holds M.prop n = P(n)) and
A104:  for p,q st p '&' q in Y
    for x,y,z being set st x = M.p & y = M.q & z = M.(p '&' q)
     holds C[p,q,x,y,z] and
A105:  for p,q st p => q in Y
    for x,y,z being set st x = M.p & y = M.q & z = M.(p => q)
     holds I[p,q,x,y,z] by A102;
A106: Y = HP-WFF
    proof
defpred P[Element of HP-WFF] means $1 in Y;
A107:  P[VERUM] by A100;
A108:  for n holds P[prop n] by A100;
A109:  for r,s st P[r] & P[s] holds P[r '&' s] & P[r => s]
      proof let r,s such that
A110:    r in Y & s in Y;
       assume
A111:      not thesis;
       per cases by A111;
       suppose
A112:       not r '&' s in Y;
           {r '&' s} c= HP-WFF by ZFMISC_1:37;
         then reconsider Y' = Y \/ {r '&' s} as Subset of HP-WFF by XBOOLE_1:8;
           r '&' s in {r '&' s} by TARSKI:def 1;
then A113:      r '&' s in Y' by XBOOLE_0:def 2;
A114:   Y c= Y' by XBOOLE_1:7;
A115: now let n; prop n in Y by A100; hence prop n in Y' by A114; end;
A116: for p,q st p '&' q in Y' or p => q in Y' holds p in Y' & q in Y'
     proof let p,q such that
A117:    p '&' q in Y' or p => q in Y';
      per cases by A117;
      suppose p '&' q = r '&' s;
       then p = r & q = s by Th19;
      hence p in Y' & q in Y' by A110,A114;
      end;
      suppose that
A118:     p '&' q in Y' and
A119:     p '&' q <> r '&' s;
         not p '&' q in {r '&' s} by A119,TARSKI:def 1;
       then p '&' q in Y by A118,XBOOLE_0:def 2;
       then p in Y & q in Y by A101;
      hence p in Y' & q in Y' by A114;
      end;
      suppose
A120:     p => q in Y';
       p => q <> r '&' s by Th22;
       then not p => q in {r '&' s} by TARSKI:def 1;
       then p => q in Y by A120,XBOOLE_0:def 2;
       then p in Y & q in Y by A101;
      hence p in Y' & q in Y' by A114;
     end;
     end;
     consider CMrMs being set such that
A121: C[r,s,M.r,M.s,CMrMs] by A1;
     set N = M +* (r '&' s .--> CMrMs);
A122:  dom(r '&' s .--> CMrMs) = {r '&' s} by CQC_LANG:5;
    dom M = Y by PBOOLE:def 3;
     then dom N = Y' by A122,FUNCT_4:def 1;
     then reconsider N as ManySortedSet of Y' by PBOOLE:def 3;
       VERUM <> r '&' s by Th23;
     then not VERUM in {r '&' s} by TARSKI:def 1;
then A123:  N.VERUM = V() by A103,A122,FUNCT_4:12;
A124:  for n holds N.prop n = P(n)
      proof let n;
          prop n <> r '&' s by Th24;
        then not prop n in {r '&' s} by TARSKI:def 1;
       hence N.prop n = M.prop n by A122,FUNCT_4:12 .= P(n) by A103;
      end;
A125:  for p,q st p '&' q in Y'
     for x,y,z being set st x = N.p & y = N.q & z = N.(p '&' q)
      holds C[p,q,x,y,z]
      proof let p,q such that
A126:     p '&' q in Y';
       let x,y,z be set such that
A127:     x = N.p & y = N.q & z = N.(p '&' q);
       per cases;
       suppose
A128:      p '&' q = r '&' s;
then A129:     p = r & q = s by Th19;
          p <> p '&' q & q <> p '&' q by Th27;
        then not p in {r '&' s} & not q in {r '&' s} by A128,TARSKI:def 1;
        then A130:      N.p = M.p & N.q = M.q by A122,FUNCT_4:12;
          p '&' q in {r '&' s} by A128,TARSKI:def 1;
        then N.(p '&' q) = (r '&' s .--> CMrMs).(p '&' q) by A122,FUNCT_4:14;
       hence C[p,q,x,y,z] by A121,A127,A129,A130,CQC_LANG:6;
       end;
       suppose p '&' q <> r '&' s;
        then A131:      not p '&' q in {r '&' s} by TARSKI:def 1;
        then A132:      p '&' q in Y by A126,XBOOLE_0:def 2;
        then p in Y & q in Y by A101;
        then not p in {r '&' s} & not q in {r '&' s} by A112,TARSKI:def 1;
        then A133:      N.p = M.p & N.q = M.q by A122,FUNCT_4:12;
          N.(p '&' q) = M.(p '&' q) by A122,A131,FUNCT_4:12;
       hence C[p,q,x,y,z] by A104,A127,A132,A133;
      end;
      end;
       for p,q st p => q in Y'
     for x,y,z being set st x = N.p & y = N.q & z = N.(p => q)
      holds I[p,q,x,y,z]
      proof let p,q such that
A134:     p => q in Y';
       let x,y,z be set such that
A135:     x = N.p & y = N.q & z = N.(p => q);
         p => q <> r '&' s by Th22;
        then A136:      not p => q in {r '&' s} by TARSKI:def 1;
        then A137:      p => q in Y by A134,XBOOLE_0:def 2;
        then p in Y & q in Y by A101;
        then not p in {r '&' s} & not q in {r '&' s} by A112,TARSKI:def 1;
        then A138:      N.p = M.p & N.q = M.q by A122,FUNCT_4:12;
          N.(p => q) = M.(p => q) by A122,A136,FUNCT_4:12;
       hence I[p,q,x,y,z] by A105,A135,A137,A138;
      end;
      then Y' in X by A100,A114,A115,A116,A123,A124,A125;
        hence contradiction by A98,A99,A112,A113,A114;
       end;
       suppose
A139:       not r => s in Y;
           {r => s} c= HP-WFF by ZFMISC_1:37;
         then reconsider Y' = Y \/ {r => s} as Subset of HP-WFF by XBOOLE_1:8;
           r => s in {r => s} by TARSKI:def 1;
then A140:      r => s in Y' by XBOOLE_0:def 2;
A141:   Y c= Y' by XBOOLE_1:7;
A142: now let n; prop n in Y by A100; hence prop n in Y' by A141; end;
A143: for p,q st p '&' q in Y' or p => q in Y' holds p in Y' & q in Y'
     proof let p,q such that
A144:    p '&' q in Y' or p => q in Y';
      per cases by A144;
      suppose p => q = r => s;
       then p = r & q = s by Th20;
      hence p in Y' & q in Y' by A110,A141;
      end;
      suppose that
A145:     p => q in Y' and
A146:     p => q <> r => s;
         not p => q in {r => s} by A146,TARSKI:def 1;
       then p => q in Y by A145,XBOOLE_0:def 2;
       then p in Y & q in Y by A101;
      hence p in Y' & q in Y' by A141;
      end;
      suppose
A147:     p '&' q in Y';
       p '&' q <> r => s by Th22;
       then not p '&' q in {r => s} by TARSKI:def 1;
       then p '&' q in Y by A147,XBOOLE_0:def 2;
       then p in Y & q in Y by A101;
      hence p in Y' & q in Y' by A141;
     end;
     end;
     consider IMrMs being set such that
A148: I[r,s,M.r,M.s,IMrMs] by A2;
     set N = M +* (r => s .--> IMrMs);
A149:  dom(r => s .--> IMrMs) = {r => s} by CQC_LANG:5;
    dom M = Y by PBOOLE:def 3;
     then dom N = Y' by A149,FUNCT_4:def 1;
     then reconsider N as ManySortedSet of Y' by PBOOLE:def 3;
       VERUM <> r => s by Th25;
     then not VERUM in {r => s} by TARSKI:def 1;
then A150:  N.VERUM = V() by A103,A149,FUNCT_4:12;
A151:  for n holds N.prop n = P(n)
      proof let n;
          prop n <> r => s by Th26;
        then not prop n in {r => s} by TARSKI:def 1;
       hence N.prop n = M.prop n by A149,FUNCT_4:12 .= P(n) by A103;
      end;
A152:  for p,q st p => q in Y'
     for x,y,z being set st x = N.p & y = N.q & z = N.(p => q)
      holds I[p,q,x,y,z]
      proof let p,q such that
A153:     p => q in Y';
       let x,y,z be set such that
A154:     x = N.p & y = N.q & z = N.(p => q);
       per cases;
       suppose
A155:      p => q = r => s;
then A156:     p = r & q = s by Th20;
          p <> p => q & q <> p => q by Th28;
        then not p in {r => s} & not q in {r => s} by A155,TARSKI:def 1;
        then A157:      N.p = M.p & N.q = M.q by A149,FUNCT_4:12;
          p => q in {r => s} by A155,TARSKI:def 1;
        then N.(p => q) = (r => s .--> IMrMs).(p => q) by A149,FUNCT_4:14;
       hence I[p,q,x,y,z] by A148,A154,A156,A157,CQC_LANG:6;
       end;
       suppose p => q <> r => s;
        then A158:      not p => q in {r => s} by TARSKI:def 1;
        then A159:      p => q in Y by A153,XBOOLE_0:def 2;
        then p in Y & q in Y by A101;
        then not p in {r => s} & not q in {r => s} by A139,TARSKI:def 1;
        then A160:      N.p = M.p & N.q = M.q by A149,FUNCT_4:12;
          N.(p => q) = M.(p => q) by A149,A158,FUNCT_4:12;
       hence I[p,q,x,y,z] by A105,A154,A159,A160;
      end;
      end;
       for p,q st p '&' q in Y'
     for x,y,z being set st x = N.p & y = N.q & z = N.(p '&' q)
      holds C[p,q,x,y,z]
      proof let p,q such that
A161:     p '&' q in Y';
       let x,y,z be set such that
A162:     x = N.p & y = N.q & z = N.(p '&' q);
         p '&' q <> r => s by Th22;
        then A163:      not p '&' q in {r => s} by TARSKI:def 1;
        then A164:      p '&' q in Y by A161,XBOOLE_0:def 2;
        then p in Y & q in Y by A101;
        then not p in {r => s} & not q in {r => s} by A139,TARSKI:def 1;
        then A165:      N.p = M.p & N.q = M.q by A149,FUNCT_4:12;
          N.(p '&' q) = M.(p '&' q) by A149,A163,FUNCT_4:12;
       hence C[p,q,x,y,z] by A104,A162,A164,A165;
      end;
      then Y' in X by A100,A141,A142,A143,A150,A151,A152;
        hence contradiction by A98,A99,A139,A140,A141;
      end;
      end;
        for s holds P[s] from HP_Ind(A107,A108,A109);
     hence thesis by SUBSET_1:49;
    end;
  then reconsider M as ManySortedSet of HP-WFF;
  take M;
  thus thesis by A103,A104,A105,A106;
 end;

scheme :: HILBERT2:sch 4
 HP_MSSLambda{V()->set,P(Nat)->set,C,I(set,set)->set}:
 ex M being ManySortedSet of HP-WFF st
  M.VERUM = V() &
  (for n holds M.prop n = P(n)) &
  for p,q holds M.(p '&' q) = C(M.p,M.q) & M.(p => q) = I(M.p,M.q)
proof
 defpred C[Element of HP-WFF,Element of HP-WFF,set,set,set] means
     $5 = C($3,$4);
 defpred I[Element of HP-WFF,Element of HP-WFF,set,set,set] means
     $5 = I($3,$4);
A1: for p,q for a,b being set ex c being set st C[p,q,a,b,c];
A2: for p,q for a,b being set ex d being set st I[p,q,a,b,d];
A3: for p,q for a,b,c,d being set st C[p,q,a,b,c] & C[p,q,a,b,d] holds c = d;
A4: for p,q for a,b,c,d being set st I[p,q,a,b,c] & I[p,q,a,b,d] holds c = d;
deffunc _P(Nat)=P($1);
 consider M being ManySortedSet of HP-WFF such that
A5:  M.VERUM = V() and
A6:  for n holds M.prop n = _P(n) and
A7:  for p,q holds C[p,q,M.p,M.q,M.(p '&' q)] & I[p,q,M.p,M.q,M.(p => q)]
    from HP_MSSExL(A1,A2,A3,A4);
 take M;
 thus M.VERUM = V() by A5;
 thus for n holds M.prop n = P(n) by A6;
 let p,q;
 set x = M.p, y = M.q;
A9: C[p,q,M.p,M.q,M.(p '&' q)] & I[p,q,M.p,M.q,M.(p => q)] by A7;
 hence M.(p '&' q) = C(x,y);
 thus M.(p => q) = I(x,y) by A9;
end;

begin :: The tree of the subformulae

definition
 func HP-Subformulae -> ManySortedSet of HP-WFF means
:: HILBERT2:def 9
 it.VERUM = root-tree VERUM &
  (for n holds it.prop n = root-tree prop n) &
  for p,q ex p',q' being DecoratedTree of HP-WFF st
    p' = it.p & q' = it.q &
    it.(p '&' q) = (p '&' q)-tree(p',q') &
    it.(p => q) = (p => q)-tree(p',q');
end;


definition let p;
 func Subformulae p -> DecoratedTree of HP-WFF equals
:: HILBERT2:def 10
 HP-Subformulae.p;
end;


theorem :: HILBERT2:30
 Subformulae VERUM = root-tree VERUM;

theorem :: HILBERT2:31
 Subformulae prop n = root-tree prop n;

theorem :: HILBERT2:32
 Subformulae(p '&' q) = (p '&' q)-tree(Subformulae p,Subformulae q);

theorem :: HILBERT2:33
 Subformulae(p => q) = (p => q)-tree(Subformulae p,Subformulae q);

theorem :: HILBERT2:34
 (Subformulae p).{} = p;

theorem :: HILBERT2:35
 for f being Element of dom Subformulae p
  holds (Subformulae p)|f = Subformulae((Subformulae p).f);

theorem :: HILBERT2:36
   p in Leaves Subformulae q implies p = VERUM or p is simple;

