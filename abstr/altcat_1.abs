:: Categories without Uniqueness of { \bf cod } and { \bf dom }
::  by Andrzej Trybulec
::
:: Received February 28, 1995
:: Copyright (c) 1995 Association of Mizar Users

environ

 vocabulary BOOLE, FRAENKEL, FUNCT_1, PRALG_1, RELAT_1, FUNCT_2, PBOOLE,
      MCART_1, CAT_4, CAT_1, RELAT_2, BINOP_1, REALSET1, CQC_LANG, ALTCAT_1;
 notation TARSKI, XBOOLE_0, ZFMISC_1, SUBSET_1, MCART_1, DOMAIN_1, RELAT_1,
      STRUCT_0, REALSET1, FUNCT_1, FUNCT_2, BINOP_1, MULTOP_1, CQC_LANG, CAT_4,
      FRAENKEL, PBOOLE, PRALG_1, MSUALG_1;
 constructors DOMAIN_1, BINOP_1, MULTOP_1, CQC_LANG, CAT_4, FRAENKEL, PRALG_1,
      MSUALG_1, STRUCT_0, XBOOLE_0;
 clusters FUNCT_1, FRAENKEL, TEX_2, PRALG_1, STRUCT_0, SUBSET_1, RELAT_1,
      CQC_LANG, RELSET_1, FUNCT_2, ZFMISC_1, XBOOLE_0;
 requirements BOOLE, SUBSET;


begin :: Preliminaries

theorem :: ALTCAT_1:1
   for A being non empty set, B,C,D being set st
  [:A,B:] c= [:C,D:] or [:B,A:] c= [:D,C:]
 holds B c= D;

reserve i,j,k,x for set;

registration let A be functional set;
 cluster -> functional Subset of A;
 coherence
  proof let A1 be Subset of A;
   let i;
   assume i in A1;
    hence i is Function by FRAENKEL:def 1;
  end;
end;


registration let f be Function-yielding Function, C be set;
 cluster f|C -> Function-yielding;
 correctness by MSUHOM_1:3;
end;


registration let f be Function;
 cluster {f} -> functional;
 coherence
 proof let i;
  assume i in {f};
   hence i is Function by TARSKI:def 1;
 end;
end;


theorem :: ALTCAT_1:2
 for A being set holds id A in Funcs(A,A);

theorem :: ALTCAT_1:3
 Funcs({},{}) = { id {} };

theorem :: ALTCAT_1:4
 for A,B,C being set, f,g being Function st f in Funcs(A,B) & g in Funcs(B,C)
  holds g*f in Funcs(A,C);

theorem :: ALTCAT_1:5
 for A,B,C being set st Funcs(A,B) <> {} & Funcs(B,C) <> {}
  holds Funcs(A,C) <> {};

theorem :: ALTCAT_1:6
   for A,B being set
 for f being Function st f in Funcs(A,B) holds dom f = A & rng f c= B;

theorem :: ALTCAT_1:7
   for A,B being set,
     F being ManySortedSet of [:B,A:],
     C being Subset of A, D being Subset of B,
     x,y being set st x in C & y in D holds
   F.(y,x) = (F|([:D,C:] qua set)).(y,x);

 scheme :: ALTCAT_1:sch 1
 MSSLambda2{ A,B() -> set, F(set,set) -> set }:
  ex M being ManySortedSet of [:A(),B():] st
   for i,j st i in A() & j in B() holds M.(i,j) = F(i,j)
proof
    deffunc _F(set) = F($1`1,$1`2);
    consider f being Function such that
A1:  dom f = [:A(),B():] and
A2:  for x st x in [:A(),B():] holds f.x = _F(x) from FUNCT_1:sch 3;
    reconsider f as ManySortedSet of [:A(),B():] by A1,PBOOLE:def 3;
   take f;
   let i,j;
   assume i in A() & j in B();
    then A3:  [i,j] in [:A(),B():] by ZFMISC_1:106;
A4:  [i,j]`1 = i & [i,j]`2 = j by MCART_1:7;
   thus f.(i,j) = f.[i,j] by BINOP_1:def 1 .= F(i,j) by A2,A3,A4;
  end;

 scheme :: ALTCAT_1:sch 2
 MSSLambda2D{ A,B() -> non empty set, F(set,set) -> set }:
  ex M being ManySortedSet of [:A(),B():] st
   for i being Element of A(), j being Element of B()
    holds M.(i,j) = F(i,j)
proof
   deffunc _F(set,set) = F($1,$2);
   consider M being ManySortedSet of [:A(),B():] such that
A1:  for i,j st i in A() & j in B() holds M.(i,j) = _F(i,j) from MSSLambda2;
  take M;
  thus thesis by A1;
 end;

 scheme :: ALTCAT_1:sch 3
 MSSLambda3{ A,B,C() -> set, F(set,set,set) -> set }:
  ex M being ManySortedSet of [:A(),B(),C():] st
   for i,j,k st i in A() & j in B() & k in C()
    holds M.(i,j,k) = F(i,j,k)
proof
   deffunc _F(set) = F($1`1`1,$1`1`2,$1`2);
    consider f being Function such that
A1:  dom f = [:A(),B(),C():] and
A2:  for x st x in [:A(),B(),C():] holds f.x = _F(x) from FUNCT_1:sch 3;
    reconsider f as ManySortedSet of [:A(),B(),C():] by A1,PBOOLE:def 3;
   take f;
   let i,j,k;
   assume i in A() & j in B() & k in C();
    then A3:  [i,j,k] in [:A(),B(),C():] by MCART_1:73;
      [i,j]`1 = i & [i,j]`2 = j by MCART_1:7;
then A4:  [[i,j],k]`1`1 = i & [[i,j],k]`1`2 = j & [[i,j],k]`2 = k by MCART_1:7;
A5:  [i,j,k] = [[i,j],k] by MCART_1:def 3;
   thus f.(i,j,k) = f.[i,j,k] by MULTOP_1:def 1
                 .= F(i,j,k) by A2,A3,A4,A5;
  end;

 scheme :: ALTCAT_1:sch 4
 MSSLambda3D{ A,B,C() -> non empty set, F(set,set,set) -> set }:
  ex M being ManySortedSet of [:A(),B(),C():] st
   for i being Element of A(), j being Element of B(), k being Element of C()
    holds M.(i,j,k) = F(i,j,k)
proof
   deffunc _F(set,set,set) = F($1,$2,$3);
   consider M being ManySortedSet of [:A(),B(),C():] such that
A1:  for i,j,k st i in A() & j in B() & k in C() holds M.(i,j,k) = _F(i,j,k)
      from MSSLambda3;
  take M;
  thus thesis by A1;
 end;

theorem :: ALTCAT_1:8
  for A,B being set, N,M being ManySortedSet of [:A,B:]
   st for i,j st i in A & j in B holds N.(i,j) = M.(i,j)
  holds M = N;

theorem :: ALTCAT_1:9
  for A,B being non empty set, N,M being ManySortedSet of [:A,B:]
   st for i being Element of A, j being Element of B holds N.(i,j) = M.(i,j)
  holds M = N;

theorem :: ALTCAT_1:10
  for A being set, N,M being ManySortedSet of [:A,A,A:]
   st for i,j,k st i in A & j in A & k in A holds N.(i,j,k) = M.(i,j,k)
  holds M = N;

theorem :: ALTCAT_1:11
 (i,j):->k = [i,j].-->k;

theorem :: ALTCAT_1:12
 ((i,j):->k).(i,j) = k;

begin :: Alternative Graphs

definition
 struct(1-sorted) AltGraph
   (# carrier -> set,
       Arrows -> ManySortedSet of [:the carrier, the carrier:]
   #);
end;


 definition let G be AltGraph;
   mode object of G is Element of G;
 end;


 definition let G be AltGraph;
  let o1,o2 be object of G;
 canceled;

  func <^o1,o2^> equals
:: ALTCAT_1:def 2
 (the Arrows of G).(o1,o2);
 end;


 definition let G be AltGraph;
  let o1,o2 be object of G;
   mode Morphism of o1,o2 is Element of <^o1,o2^>;
   canceled;
 end;


 definition let G be AltGraph;
  attr G is transitive means
:: ALTCAT_1:def 4
 for o1,o2,o3 being object of G st <^o1,o2^> <> {} & <^o2,o3^> <> {}
       holds <^o1,o3^> <> {};
 end;


begin :: Binary Compositions

definition
 let I be set;
 let G be ManySortedSet of [:I,I:];
 func {|G|} -> ManySortedSet of [:I,I,I:] means
:: ALTCAT_1:def 5
 for i,j,k st i in I & j in I & k in I holds it.(i,j,k) = G.(i,k);
 let H be ManySortedSet of [:I,I:];
 func {|G,H|} -> ManySortedSet of [:I,I,I:] means
:: ALTCAT_1:def 6
 for i,j,k st i in I & j in I & k in I holds
    it.(i,j,k) = [:H.(j,k),G.(i,j):];
end;


 definition let I be set;
  let G be ManySortedSet of [:I,I:];
  mode BinComp of G is ManySortedFunction of {|G,G|},{|G|};
 end;


 definition let I be non empty set; let G be ManySortedSet of [:I,I:];
  let o be BinComp of G;
  let i,j,k be Element of I;
  redefine func o.(i,j,k) -> Function of [:G.(j,k),G.(i,j):], G.(i,k);
 end;


 definition let I be non empty set; let G be ManySortedSet of [:I,I:];
  let IT be BinComp of G;
  attr IT is associative means
:: ALTCAT_1:def 7

   for i,j,k,l being Element of I
   for f,g,h being set st f in G.(i,j) & g in G.(j,k) & h in G.(k,l)
    holds IT.(i,k,l).(h,IT.(i,j,k).(g,f)) = IT.(i,j,l).(IT.(j,k,l).(h,g),f);
  attr IT is with_right_units means
:: ALTCAT_1:def 8

   for i being Element of I ex e being set st e in G.(i,i) &
    for j being Element of I, f be set st f in G.(i,j)
     holds IT.(i,i,j).(f,e) = f;
  attr IT is with_left_units means
:: ALTCAT_1:def 9

   for j being Element of I ex e being set st e in G.(j,j) &
    for i being Element of I, f be set st f in G.(i,j)
     holds IT.(i,j,j).(e,f) = f;
 end;


begin :: Alternative categories

definition
 struct(AltGraph) AltCatStr
   (# carrier -> set,
       Arrows -> ManySortedSet of [:the carrier, the carrier:],
         Comp -> BinComp of the Arrows
   #);
end;


registration
 cluster strict non empty AltCatStr;
 existence
  proof
    consider X being non empty set, A being ManySortedSet of [:X,X:],
             C being BinComp of A;
   take AltCatStr(#X,A,C#);
   thus AltCatStr(#X,A,C#) is strict;
   thus the carrier of AltCatStr(#X,A,C#) is non empty;
  end;
end;


 definition let C be non empty AltCatStr;
   let o1,o2,o3 be object of C such that
  <^o1,o2^> <> {} & <^o2,o3^> <> {};
   let f be Morphism of o1,o2, g be Morphism of o2,o3;
    func g*f -> Morphism of o1,o3 equals
:: ALTCAT_1:def 10
 (the Comp of C).(o1,o2,o3).(g,f);
 end;


 definition let IT be Function;
  attr IT is compositional means
:: ALTCAT_1:def 11
  x in dom IT implies
    ex f,g being Function st x = [g,f] & IT.x = g*f;
 end;


 registration let A,B be functional set;
  cluster compositional ManySortedFunction of [:A,B:];
   existence
    proof
     per cases;
     suppose A1: A = {} or B = {};
       set M = [0][:A,B:];
A2:     dom M = [:A,B:] by PBOOLE:def 3;
         M is Function-yielding proof let x; thus thesis by A1,A2,ZFMISC_1:113
;
end;
       then reconsider M as ManySortedFunction of [:A,B:];
      take M;
      let x;
      thus thesis by A1,A2,ZFMISC_1:113;
     end;
     suppose A <> {} & B <> {};
      then reconsider A1=A, B1=B as non empty functional set;
      deffunc _F(Element of A1,Element of B1) = $1*$2;
      consider M being ManySortedSet of [:A1,B1:] such that
A3:     for i being Element of A1, j being Element of B1
         holds M.(i,j) = _F(i,j) from MSSLambda2D;
        M is Function-yielding
       proof let x;
        assume x in dom M;
         then A4:        x in [:A1,B1:] by PBOOLE:def 3;
         then A5:        x`1 in A1 & x `2 in B1 by MCART_1:10;
         then reconsider f = x`1, g = x`2 as Function by FRAENKEL:def 1;
           x = [f,g] by A4,MCART_1:24;
         then M.x = M.(f,g) by BINOP_1:def 1 .= f*g by A3,A5;
        hence M.x is Function;
       end;
      then reconsider M as ManySortedFunction of [:A,B:];
     take M; let x;
     assume x in dom M;
      then A6:     x in [:A1,B1:] by PBOOLE:def 3;
      then A7:     x`1 in A1 & x `2 in B1 by MCART_1:10;
      then reconsider f = x`1, g = x`2 as Function by FRAENKEL:def 1;
     take g,f;
     thus x = [f,g] by A6,MCART_1:24;
        x = [f,g] by A6,MCART_1:24;
     hence M.x = M.(f,g) by BINOP_1:def 1 .= f*g by A3,A7;
    end;
    end;
 end;


theorem :: ALTCAT_1:13
 for A,B being functional set
 for F being compositional ManySortedSet of [:A,B:],
     g,f being Function st g in A & f in B
  holds F.(g,f) = g*f;

 definition let A,B be functional set;
  func FuncComp(A,B) -> compositional ManySortedFunction of [:B,A:] means
:: ALTCAT_1:def 12
   not contradiction;
 end;


theorem :: ALTCAT_1:14
 for A,B,C being set holds
  rng FuncComp(Funcs(A,B),Funcs(B,C)) c= Funcs(A,C);

theorem :: ALTCAT_1:15
 for o be set holds FuncComp({id o},{id o}) = (id o,id o) :-> id o;

theorem :: ALTCAT_1:16
 for A,B being functional set, A1 being Subset of A, B1 being Subset of B
  holds FuncComp(A1,B1) = FuncComp(A,B)|([:B1,A1:] qua set);

:: Kategorie przeksztalcen, Semadeni Wiweger, 1.2.2, str.15

definition let C be non empty AltCatStr;
 attr C is quasi-functional means
:: ALTCAT_1:def 13
 for a1,a2 being object of C holds <^a1,a2^> c= Funcs(a1,a2);
 attr C is semi-functional means
:: ALTCAT_1:def 14
  for a1,a2,a3 being object of C st
     <^a1,a2^> <> {} & <^a2,a3^> <> {} & <^a1,a3^> <> {}
   for f being Morphism of a1,a2, g being Morphism of a2,a3,
       f',g' being Function st f = f' & g = g'
    holds g*f =g'*f';
 attr C is pseudo-functional means
:: ALTCAT_1:def 15
 for o1,o2,o3 being object of C holds
     (the Comp of C).(o1,o2,o3) =
       FuncComp(Funcs(o1,o2),Funcs(o2,o3))|[:<^o2,o3^>,<^o1,o2^>:];
end;


registration let X be non empty set, A be ManySortedSet of [:X,X:],
               C be BinComp of A;
 cluster AltCatStr(#X,A,C#) -> non empty;
 coherence by STRUCT_0:def 1;
end;


registration
 cluster strict pseudo-functional (non empty AltCatStr);
 existence
  proof
A1:    0 in 1 by CARD_5:1,TARSKI:def 1;
      dom([0,0] .--> Funcs(0,0)) = {[0,0]} by CQC_LANG:5
       .= [: 1,1 :] by CARD_5:1,ZFMISC_1:35;
    then reconsider m = [0,0] .--> Funcs(0,0) as ManySortedSet of [: 1,1 :]
       by PBOOLE:def 3;
A2:  dom([0,0,0] .--> FuncComp(Funcs(0,0),Funcs(0,0))) = {[0,0,0]}
        by CQC_LANG:5;
A3:  {[0,0,0]} = [: 1,1,1 :] by CARD_5:1,MCART_1:39;
    then reconsider c = [0,0,0] .--> FuncComp(Funcs(0,0),Funcs(0,0))
      as ManySortedSet of [: 1,1,1 :] by A2,PBOOLE:def 3;
      c is Function-yielding
     proof let i;
      assume i in dom c;
       then i = [0,0,0] by A2,TARSKI:def 1;
       hence c.i is Function by CQC_LANG:6;
     end;
    then reconsider c as ManySortedFunction of [: 1,1,1 :];
A4:    m.(0,0) = m.[0,0] by BINOP_1:def 1
          .= Funcs(0,0) by CQC_LANG:6;
      now let i;
     assume i in [: 1,1,1 :];
       then A5:      i = [0,0,0] by A3,TARSKI:def 1;
       then A6:      c.i = FuncComp(Funcs(0,0),Funcs(0,0)) by CQC_LANG:6;
      reconsider ci = c.i as Function;
A7:    dom ci = [:m.(0,0),m.(0,0):] by A4,A6,PBOOLE:def 3
         .= {|m,m|}.(0,0,0) by A1,Def6
         .= {|m,m|}.i by A5,MULTOP_1:def 1;
A8:    {|m|}.i = {|m|}.(0,0,0) by A5,MULTOP_1:def 1
             .= m.(0,0) by A1,Def5;
      then rng ci c= {|m|}.i by A4,A6,Th14;
      hence c.i is Function of {|m,m|}.i, {|m|}.i by A4,A7,A8,FUNCT_2:def 1,
RELSET_1:11;
    end;
    then reconsider c as BinComp of m by MSUALG_1:def 2;
   take C = AltCatStr(#1,m,c#);
   thus C is strict;
   let o1,o2,o3 be object of C;
  A9:  o1 = 0 & o2 = 0 & o3 = 0 by CARD_5:1,TARSKI:def 1;
    then <^o2,o3^> = Funcs(0,0) by A4,Def2;
    then A10:  dom FuncComp(Funcs(0,0),Funcs(0,0)) = [:<^o2,o3^>,<^o1,o2^>:]
      by A9,PBOOLE:def 3;
   thus (the Comp of C).(o1,o2,o3) = c.[o1,o2,o3] by MULTOP_1:def 1
    .= FuncComp(Funcs(0,0),Funcs(0,0)) by A9,CQC_LANG:6
    .= FuncComp(Funcs(o1,o2),Funcs(o2,o3))|[:<^o2,o3^>,<^o1,o2^>:]
       by A9,A10,RELAT_1:97;
 end;
end;


theorem :: ALTCAT_1:17
 for C being non empty AltCatStr, a1,a2,a3 being object of C
  holds (the Comp of C).(a1,a2,a3)
     is Function of [:<^a2,a3^>,<^a1,a2^>:],<^a1,a3^>;

theorem :: ALTCAT_1:18
 for C being pseudo-functional (non empty AltCatStr)
   for a1,a2,a3 being object of C st
     <^a1,a2^> <> {} & <^a2,a3^> <> {} & <^a1,a3^> <> {}
   for f being Morphism of a1,a2, g being Morphism of a2,a3,
       f',g' being Function st f = f' & g = g'
    holds g*f =g'*f';

:: Kategorie EnsCat(A), Semadeni Wiweger 1.2.3, str. 15
:: ale bez parametryzacji

definition let A be non empty set;
 func EnsCat A -> strict pseudo-functional (non empty AltCatStr) means
:: ALTCAT_1:def 16
 the carrier of it = A &
     for a1,a2 being object of it holds <^a1,a2^> = Funcs(a1,a2);
end;


 definition let C be non empty AltCatStr;
  attr C is associative means
:: ALTCAT_1:def 17

   the Comp of C is associative;
  attr C is with_units means
:: ALTCAT_1:def 18

   the Comp of C is with_left_units with_right_units;
 end;

 registration
  cluster transitive associative with_units strict (non empty AltCatStr);
  existence proof take EnsCat {{}}; thus thesis by Lm1; end;
 end;


canceled;

theorem :: ALTCAT_1:20
   for C being transitive non empty AltCatStr, a1,a2,a3 being object of C
 holds dom((the Comp of C).(a1,a2,a3)) = [:<^a2,a3^>,<^a1,a2^>:]
  & rng((the Comp of C).(a1,a2,a3)) c= <^a1,a3^>;

theorem :: ALTCAT_1:21
 for C being with_units (non empty AltCatStr)
 for o being object of C holds <^o,o^> <> {};

registration let A be non empty set;
 cluster EnsCat A -> transitive associative with_units;
  coherence by Lm1;
end;


registration
 cluster quasi-functional semi-functional transitive
              -> pseudo-functional (non empty AltCatStr);
 coherence
  proof let C be non empty AltCatStr;
   assume
A1:  C is quasi-functional semi-functional transitive;
   let o1,o2,o3 be object of C;
    set c = (the Comp of C).(o1,o2,o3),
        f = FuncComp(Funcs(o1,o2),Funcs(o2,o3))|[:<^o2,o3^>,<^o1,o2^>:];
      <^o1,o3^> = {} implies <^o2,o3^> = {} or <^o1,o2^> = {} by A1,Def4;
    then A2: <^o1,o3^> = {} implies [:<^o2,o3^>,<^o1,o2^>:] = {} by ZFMISC_1:
113;
      c is Function of [:<^o2,o3^>,<^o1,o2^>:], <^o1,o3^> by Th17;
    then A3:  dom c = [:<^o2,o3^>,<^o1,o2^>:] by A2,FUNCT_2:def 1;
    per cases;
    suppose <^o2,o3^> = {} or <^o1,o2^> = {};
      then A4:    [:<^o2,o3^>,<^o1,o2^>:] = {} by ZFMISC_1:113;
     hence c = {} by A3,RELAT_1:64 .= f by A4,RELAT_1:110;
    end;
    suppose
A5: <^o2,o3^> <> {} & <^o1,o2^> <> {};
     then A6:    <^o1,o3^> <> {} by A1,Def4;
      dom FuncComp(Funcs(o1,o2),Funcs(o2,o3)) = [:Funcs(o2,o3),Funcs(o1,o2):]
     by PBOOLE:def 3;
    then A7:  dom f = [:Funcs(o2,o3),Funcs(o1,o2):] /\ [:<^o2,o3^>,<^o1,o2^>:]
      by RELAT_1:90;
A8:  <^o2,o3^> c= Funcs(o2,o3) & <^o1,o2^> c= Funcs(o1,o2) by A1,Def13;
    then A9:  [:<^o2,o3^>,<^o1,o2^>:] c= [:Funcs(o2,o3),Funcs(o1,o2):] by
ZFMISC_1:119;
      c is Function of [:<^o2,o3^>,<^o1,o2^>:], <^o1,o3^> by Th17;
    then A10:   dom c = [:<^o2,o3^>,<^o1,o2^>:] by A6,FUNCT_2:def 1;
    then A11:  dom c = dom f by A7,A9,XBOOLE_1:28;
     now let i;
    assume
A12: i in dom c;
    then consider i1,i2 being set such that
A13:  i1 in <^o2,o3^> & i2 in <^o1,o2^> and
A14:  i = [i1,i2] by A10,ZFMISC_1:103;
     reconsider g = i1, h = i2 as Function by A8,A13,FUNCT_2:121;
     reconsider a1 = i1 as Morphism of o2,o3 by A13;
     reconsider a2 = i2 as Morphism of o1,o2 by A13;
    thus c.i = (the Comp of C).(o1,o2,o3).(a1,a2) by A14,BINOP_1:def 1
      .= a1*a2 by A5,Def10
      .= g*h by A1,A5,A6,Def14
      .= FuncComp(Funcs(o1,o2),Funcs(o2,o3)).(g,h) by A8,A13,Th13
      .= FuncComp(Funcs(o1,o2),Funcs(o2,o3)).[g,h] by BINOP_1:def 1
      .= f.i by A11,A12,A14,FUNCT_1:70;
   end;
   hence (the Comp of C).(o1,o2,o3) =
       FuncComp(Funcs(o1,o2),Funcs(o2,o3))|[:<^o2,o3^>,<^o1,o2^>:]
      by A11,FUNCT_1:9;
  end;
  end;
  cluster with_units pseudo-functional transitive
        -> quasi-functional semi-functional (non empty AltCatStr);
  coherence
   proof let C be non empty AltCatStr such that
A15:  C is with_units pseudo-functional transitive;
    thus C is quasi-functional
     proof let a1,a2 be object of C;
      per cases;
      suppose <^a1,a2^> = {};
       hence <^a1,a2^> c= Funcs(a1,a2) by XBOOLE_1:2;
      end;
      suppose
A16:     <^a1,a2^> <> {};
       <^a1,a1^> <> {} by A15,Th21;
       then A17:     [:<^a1,a2^>,<^a1,a1^>:] <> {} by A16,ZFMISC_1:113;
         set c = (the Comp of C).(a1,a1,a2),
             f = FuncComp(Funcs(a1,a1),Funcs(a1,a2));
          c is Function of [:<^a1,a2^>,<^a1,a1^>:],<^a1,a2^> by Th17;
        then A18:       dom c = [:<^a1,a2^>,<^a1,a1^>:] by A16,FUNCT_2:def 1;
A19:       dom f = [:Funcs(a1,a2),Funcs(a1,a1):] by PBOOLE:def 3;
           c = f|[:<^a1,a2^>,<^a1,a1^>:] by A15,Def15;
        then [:<^a1,a2^>,<^a1,a1^>:] c= [:Funcs(a1,a2),Funcs(a1,a1):]
             by A18,A19,RELAT_1:89;
       hence <^a1,a2^> c= Funcs(a1,a2) by A17,BORSUK_1:7;
     end;
     end;
    let a1,a2,a3 be object of C;
    thus thesis by A15,Th18;
   end;
 end;


:: Definicja kategorii, Semadeni Wiweger 1.3.1, str. 16-17

 definition
  mode category is transitive associative with_units (non empty AltCatStr);
 end;


begin

 definition let C be with_units (non empty AltCatStr);
  let o be object of C;
  func idm o -> Morphism of o,o means
:: ALTCAT_1:def 19
 for o' being object of C st <^o,o'^> <> {}
      for a being Morphism of o,o' holds a*it = a;
 end;


canceled;

theorem :: ALTCAT_1:23
 for C being with_units (non empty AltCatStr)
 for o being object of C holds idm o in <^o,o^>;

theorem :: ALTCAT_1:24
   for C being with_units (non empty AltCatStr)
 for o1,o2 being object of C st <^o1,o2^> <> {}
 for a being Morphism of o1,o2 holds (idm o2)*a = a;

theorem :: ALTCAT_1:25
   for C being associative transitive (non empty AltCatStr)
 for o1,o2,o3,o4 being object of C st
  <^o1,o2^> <> {} & <^o2,o3^> <> {} & <^o3,o4^> <> {}
 for a being Morphism of o1,o2,
     b being Morphism of o2,o3, c being Morphism of o3,o4
  holds c*(b*a) = (c*b)*a;

begin

:: kategoria dyskretna, Semadeni Wiweger, 1.3.1, str.18

definition let C be AltCatStr;
 attr C is quasi-discrete means
:: ALTCAT_1:def 20
 for i,j being object of C st <^i,j^> <> {} holds i = j;
  :: to sa po prostu zbiory monoidow
 attr C is pseudo-discrete means
:: ALTCAT_1:def 21
 for i being object of C holds <^i,i^> is trivial;
end;


theorem :: ALTCAT_1:26
   for C being with_units (non empty AltCatStr) holds C is pseudo-discrete iff
   for o being object of C holds <^o,o^> = { idm o };

registration
 cluster trivial non empty -> quasi-discrete AltCatStr;
 coherence
  proof let C be AltCatStr;
   assume
A1:   C is trivial non empty;
   let i,j be object of C such that <^i,j^> <> {};
   thus i = j by A1,REALSET1:def 20;
  end;
end;


theorem :: ALTCAT_1:27
 EnsCat 1 is pseudo-discrete trivial;

registration
 cluster pseudo-discrete trivial strict category;
 existence by Th27;
end;


registration
 cluster quasi-discrete pseudo-discrete trivial strict category;
 existence
  proof
   take EnsCat 1;
    reconsider e = EnsCat 1 as pseudo-discrete trivial strict category
                  by Th27;
      e is quasi-discrete pseudo-discrete trivial;
   hence thesis;
  end;
end;


definition
 mode discrete_category is quasi-discrete pseudo-discrete category;
end;


definition let A be non empty set;
 func DiscrCat A -> quasi-discrete strict non empty AltCatStr means
:: ALTCAT_1:def 22
 the carrier of it = A &
     for i being object of it holds <^i,i^> = { id i };
end;


registration
 cluster quasi-discrete -> transitive AltCatStr;
  coherence
   proof let C be AltCatStr;
    assume
A1:   C is quasi-discrete;
    let o1,o2,o3 be object of C;
    assume
    <^o1,o2^> <> {} & <^o2,o3^> <> {};
     hence <^o1,o3^> <> {} by A1,Def20;
   end;
end;


theorem :: ALTCAT_1:28
 for A being non empty set, o1,o2,o3 being object of DiscrCat A
  st o1 <> o2 or o2 <> o3 holds (the Comp of DiscrCat A).(o1,o2,o3) = {};

theorem :: ALTCAT_1:29
 for A being non empty set, o being object of DiscrCat A
  holds (the Comp of DiscrCat A).(o,o,o) = (id o,id o) :-> id o;

registration let A be non empty set;
 cluster DiscrCat A ->
   pseudo-functional pseudo-discrete with_units associative;
 coherence
  proof set C = DiscrCat A;
   thus C is pseudo-functional
    proof let o1,o2,o3 be object of C;
A1:    id o1 in Funcs(o1,o1) by Th2;
     per cases;
     suppose
A2:    o1 = o2 & o2 = o3;
      then A3:    <^o2,o3^> = {id o1} & <^o1,o2^> = {id o1} by Def22;
      then A4:    <^o1,o2^> c= Funcs(o1,o2) & <^o2,o3^> c= Funcs(o2,o3) by A1,
A2,ZFMISC_1:37;
     thus (the Comp of C).(o1,o2,o3) = (id o1,id o1) :-> id o1 by A2,Th29
      .= FuncComp({id o1},{id o1}) by Th15
      .= FuncComp(Funcs(o1,o2),Funcs(o2,o3))|[:<^o2,o3^>,<^o1,o2^>:]
                  by A3,A4,Th16;
     end;
     suppose
A5:    o1 <> o2 or o2 <> o3;
      then <^o2,o3^> = {} or <^o1,o2^> = {} by Def20;
      then A6:    [:<^o2,o3^>,<^o1,o2^>:] = {} by ZFMISC_1:113;
     thus (the Comp of C).(o1,o2,o3) = {} by A5,Th28
      .= FuncComp(Funcs(o1,o2),Funcs(o2,o3))|[:<^o2,o3^>,<^o1,o2^>:]
         by A6,RELAT_1:110;
    end;
    end;
   thus C is pseudo-discrete
    proof let i be object of C;
         <^i,i^> = { id i } by Def22;
     hence <^i,i^> is trivial;
    end;
   thus C is with_units
    proof
     thus the Comp of C is with_left_units
      proof let j be Element of C;
        reconsider j'=j as object of C;
       take id j';
          (the Arrows of C).(j,j) = <^j',j'^> by Def2
           .= { id j' } by Def22;
       hence id j' in (the Arrows of C).(j,j) by TARSKI:def 1;
       let i be Element of C, f be set such that
A7:       f in (the Arrows of C).(i,j);
        reconsider i'=i as object of C;
A8:      (the Arrows of C).(i,j) = <^i',j'^> by Def2;
        then A9:       i' = j' by A7,Def20;
        then f in { id i'} by A7,A8,Def22;
        then A10:        f = id i' by TARSKI:def 1;
       thus (the Comp of C).(i,j,j).(id j',f)
            = ((id i',id i'):->id i').(id j',f) by A9,Th29
           .= f by A9,A10,Th12;
      end;
     let j be Element of C;
      reconsider j'=j as object of C;
     take id j';
        (the Arrows of C).(j,j) = <^j',j'^> by Def2
         .= { id j' } by Def22;
     hence id j' in (the Arrows of C).(j,j) by TARSKI:def 1;
     let i be Element of C, f be set such that
A11:       f in (the Arrows of C).(j,i);
      reconsider i'=i as object of C;
A12:      (the Arrows of C).(j,i) = <^j',i'^> by Def2;
      then A13:       i' = j' by A11,Def20;
      then f in { id i'} by A11,A12,Def22;
      then A14:        f = id i' by TARSKI:def 1;
     thus (the Comp of C).(j,j,i).(f,id j')
          = ((id i',id i'):->id i').(f,id j') by A13,Th29
         .= f by A13,A14,Th12;
    end;
   thus C is associative
    proof
     set G = the Arrows of C,
         c = the Comp of C;
     let i,j,k,l be Element of C;
      reconsider i'=i, j'=j, k'=k, l'=l as object of C;
     let f,g,h be set;
     assume f in G.(i,j) & g in G.(j,k) & h in G.(k,l);
      then A15:     f in <^i',j'^> & g in <^j',k'^> & h in <^k',l'^> by Def2;
      then A16:    i' = j' & j' = k' & k' = l' by Def20;
        <^i',i'^> = { id i' } by Def22;
      then A17:   f = id i' & g = id i' & h = id i' by A15,A16,TARSKI:def 1;
        c.(i',i',i') = (id i',id i') :-> id i' by Th29;
      then c.(i',i',i').(id i',id i') = id i' by Th12;
     hence c.(i,k,l).(h,c.(i,j,k).(g,f)) = c.(i,j,l).(c.(j,k,l).(h,g),f)
               by A16,A17;
    end;
  end;
end;


