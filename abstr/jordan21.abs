:: On Some Points of a Simple Closed Curve
::  by Artur Korni{\l}owicz
::
:: Received October 6, 2004
:: Copyright (c) 2004 Association of Mizar Users

environ

 vocabulary BOOLE, RELAT_1, RELAT_2, PRE_TOPC, COMPTS_1, EUCLID, TOPREAL2,
      JORDAN2C, TREES_1, JORDAN8, TOPREAL1, ORDINAL2, ARYTM, JORDAN6, JORDAN9,
      FINSEQ_1, FUNCT_1, PSCOMP_1, MCART_1, ARYTM_3, SUBSET_1, METRIC_1,
      PCOMPS_1, GOBOARD2, ARYTM_1, MATRIX_1, GOBOARD1, GROUP_1, GOBOARD9,
      SPPOL_1, JORDAN3, JORDAN1K, JORDAN1A, JORDAN1, FUNCT_5, SEQ_2, LATTICES,
      JORDAN21;
 notation TARSKI, XBOOLE_0, SUBSET_1, ORDINAL1, XCMPLX_0, XREAL_0, REAL_1,
      NAT_1, RELAT_1, FUNCT_2, SEQ_1, SEQ_4, NEWTON, FINSEQ_1, MATRIX_1,
      STRUCT_0, PRE_TOPC, COMPTS_1, BINARITH, CONNSP_1, TBSP_1, PCOMPS_1,
      RCOMP_1, PSCOMP_1, EUCLID, TOPREAL1, TOPREAL2, GOBOARD1, GOBOARD2,
      SPPOL_1, JORDAN1, JORDAN2C, JORDAN6, GOBOARD9, JORDAN5C, JORDAN8,
      JORDAN9, GOBRD14, JORDAN1A, JORDAN1K;
 constructors CARD_4, CONNSP_1, JORDAN2C, GOBOARD9, BINARITH, JORDAN1H, REAL_1,
      REALSET1, INT_1, JORDAN8, NAT_1, JORDAN6, JORDAN9, PSCOMP_1, JORDAN5C,
      JORDAN1K, GOBRD14, FINSEQ_4, GOBOARD2, JORDAN1A, RCOMP_1, TBSP_1,
      JORDAN1;
 clusters TOPREAL6, JORDAN8, INT_1, RELSET_1, XREAL_0, SPRECT_3, XBOOLE_0,
      EUCLID, SPRECT_4, BORSUK_2, BORSUK_4, MEMBERED, STRUCT_0, JORDAN1A,
      SPPOL_2;
 requirements SUBSET, BOOLE, REAL, NUMERALS, ARITHM;


begin :: On the Subsets of TOP-REAL 2

reserve C for Simple_closed_curve,
        P for Subset of TOP-REAL 2,
        R for non empty Subset of TOP-REAL 2,
        p, q for Point of TOP-REAL 2,
        i, j, k, m, n for Nat;

theorem :: JORDAN21:1
  for p being Point of TOP-REAL n holds {p} is Bounded;

theorem :: JORDAN21:2  :: P is an open east halfline
  for s1,t being real number, P being Subset of TOP-REAL 2
    st P = { |[ s,t ]| where s is Real : s1 < s } holds P is convex;

theorem :: JORDAN21:3  :: P is an open west halfline
  for s2,t being real number, P being Subset of TOP-REAL 2
    st P = {|[ s,t ]| where s is Real : s < s2 } holds P is convex;

theorem :: JORDAN21:4  :: P is an open north halfline
  for s,t1 being real number, P being Subset of TOP-REAL 2
    st P = {|[ s,t ]| where t is Real : t1 < t } holds P is convex;

theorem :: JORDAN21:5  :: P is an open south halfline
  for s,t2 being real number, P being Subset of TOP-REAL 2
    st P = { |[ s,t ]| where t is Real : t < t2 } holds P is convex;

theorem :: JORDAN21:6
  north_halfline p \ {p} is convex;

theorem :: JORDAN21:7
  south_halfline p \ {p} is convex;

theorem :: JORDAN21:8
  west_halfline p \ {p} is convex;

theorem :: JORDAN21:9
  east_halfline p \ {p} is convex;

theorem :: JORDAN21:10
  for A being Subset of the carrier of TOP-REAL 2 holds UBD A misses A;

theorem :: JORDAN21:11
  for P being Subset of the carrier of TOP-REAL 2,
      p1,p2,q1,q2 being Point of TOP-REAL 2 st
    P is_an_arc_of p1,p2 & p1 <> q1 & p2 <> q2 holds
   not p1 in Segment(P,p1,p2,q1,q2) & not p2 in Segment(P,p1,p2,q1,q2);

theorem :: JORDAN21:12
  proj2.:(C /\ Vertical_Line((W-bound C + E-bound C) / 2)) is not empty;

theorem :: JORDAN21:13
  for C being compact Subset of TOP-REAL 2 holds
   proj2.:(C /\ Vertical_Line((W-bound C + E-bound C) / 2))
    is closed bounded_below bounded_above;

begin

theorem :: JORDAN21:14
  [1,1] in Indices Gauge(R,n);

theorem :: JORDAN21:15
  [1,2] in Indices Gauge(R,n);

theorem :: JORDAN21:16
  [2,1] in Indices Gauge(R,n);

theorem :: JORDAN21:17
  for C being non vertical non horizontal compact Subset of TOP-REAL 2 holds
  m > k & [i,j] in Indices Gauge(C,k) & [i,j+1] in Indices Gauge(C,k)
  implies
    dist(Gauge(C,m)*(i,j),Gauge(C,m)*(i,j+1)) <
    dist(Gauge(C,k)*(i,j),Gauge(C,k)*(i,j+1));

theorem :: JORDAN21:18
  for C being non vertical non horizontal compact Subset of TOP-REAL 2 holds
  m > k implies
    dist(Gauge(C,m)*(1,1),Gauge(C,m)*(1,2)) <
    dist(Gauge(C,k)*(1,1),Gauge(C,k)*(1,2));

theorem :: JORDAN21:19
  for C being non vertical non horizontal compact Subset of TOP-REAL 2 holds
  m > k & [i,j] in Indices Gauge(C,k) & [i+1,j] in Indices Gauge(C,k)
  implies
    dist(Gauge(C,m)*(i,j),Gauge(C,m)*(i+1,j)) <
    dist(Gauge(C,k)*(i,j),Gauge(C,k)*(i+1,j));

theorem :: JORDAN21:20
  for C being non vertical non horizontal compact Subset of TOP-REAL 2 holds
  m > k implies
    dist(Gauge(C,m)*(1,1),Gauge(C,m)*(2,1)) <
    dist(Gauge(C,k)*(1,1),Gauge(C,k)*(2,1));

theorem :: JORDAN21:21
  for r, t being real number holds r > 0 & t > 0 implies
  ex n being Nat st i < n &
    dist(Gauge(C,n)*(1,1),Gauge(C,n)*(1,2)) < r &
    dist(Gauge(C,n)*(1,1),Gauge(C,n)*(2,1)) < t;

begin :: Middle Points

theorem :: JORDAN21:22
  Upper_Middle_Point C in C;

theorem :: JORDAN21:23
  Lower_Middle_Point C in C;

theorem :: JORDAN21:24
  (Lower_Middle_Point C)`2 <> (Upper_Middle_Point C)`2;

theorem :: JORDAN21:25
  Lower_Middle_Point C <> Upper_Middle_Point C;

begin :: Upper_Arc and Lower_Arc

theorem :: JORDAN21:26
  W-bound C = W-bound Upper_Arc C;

theorem :: JORDAN21:27
  E-bound C = E-bound Upper_Arc C;

theorem :: JORDAN21:28
  W-bound C = W-bound Lower_Arc C;

theorem :: JORDAN21:29
  E-bound C = E-bound Lower_Arc C;

theorem :: JORDAN21:30
  Upper_Arc C /\ Vertical_Line((W-bound C + E-bound C) / 2)
    is not empty &
  proj2.:(Upper_Arc C /\ Vertical_Line((W-bound C + E-bound C) / 2))
   is not empty;

theorem :: JORDAN21:31
  Lower_Arc C /\ Vertical_Line((W-bound C + E-bound C) / 2)
   is not empty  &
  proj2.:(Lower_Arc C /\ Vertical_Line((W-bound C + E-bound C) / 2))
   is not empty;

theorem :: JORDAN21:32
 for P being compact connected Subset of TOP-REAL 2 st P c= C
  & W-min C in P & E-max C in P
 holds Upper_Arc C c= P or Lower_Arc C c= P;

begin :: UMP and LMP

definition let P be Subset of the carrier of TOP-REAL 2;
  func UMP P -> Point of TOP-REAL 2 equals
:: JORDAN21:def 1

  |[ (E-bound P + W-bound P) / 2 ,
      sup (proj2.:(P /\ Vertical_Line ((E-bound P + W-bound P) / 2))) ]|;
  func LMP P -> Point of TOP-REAL 2 equals
:: JORDAN21:def 2

  |[ (E-bound P + W-bound P) / 2 ,
      inf (proj2.:(P /\ Vertical_Line ((E-bound P + W-bound P) / 2))) ]|;
end;

theorem :: JORDAN21:33
  (UMP P)`1 = (W-bound P + E-bound P) / 2;

theorem :: JORDAN21:34
  (UMP P)`2 =
    sup (proj2.:(P /\ Vertical_Line ((E-bound P + W-bound P) / 2)));

theorem :: JORDAN21:35
  (LMP P)`1 = (W-bound P + E-bound P) / 2;

theorem :: JORDAN21:36
  (LMP P)`2 =
    inf (proj2.:(P /\ Vertical_Line ((E-bound P + W-bound P) / 2)));

theorem :: JORDAN21:37
  for C being non vertical compact Subset of TOP-REAL 2 holds UMP C <> W-min C;

theorem :: JORDAN21:38
  for C being non vertical compact Subset of TOP-REAL 2 holds UMP C <> E-max C;

theorem :: JORDAN21:39
  for C being non vertical compact Subset of TOP-REAL 2 holds LMP C <> W-min C;

theorem :: JORDAN21:40
  for C being non vertical compact Subset of TOP-REAL 2 holds LMP C <> E-max C;

theorem :: JORDAN21:41
  for C being compact Subset of TOP-REAL 2 st
    p in C /\ Vertical_Line ((W-bound C + E-bound C) / 2) holds
   p`2 <= (UMP C)`2;

theorem :: JORDAN21:42
  for C being compact Subset of TOP-REAL 2 st
    p in C /\ Vertical_Line ((W-bound C + E-bound C) / 2) holds
   (LMP C)`2 <= p`2;

theorem :: JORDAN21:43
  UMP C in C;

theorem :: JORDAN21:44
  LMP C in C;

theorem :: JORDAN21:45
  LSeg(UMP P, |[ (W-bound P + E-bound P) / 2, N-bound P]|) is vertical;

theorem :: JORDAN21:46
  LSeg(LMP P, |[ (W-bound P + E-bound P) / 2, S-bound P]|) is vertical;

theorem :: JORDAN21:47
  LSeg(UMP C, |[ (W-bound C + E-bound C) / 2, N-bound C]|) /\ C = { UMP C };

theorem :: JORDAN21:48
  LSeg(LMP C, |[ (W-bound C + E-bound C) / 2, S-bound C]|) /\ C = { LMP C };

theorem :: JORDAN21:49
  (LMP C)`2 < (UMP C)`2;

theorem :: JORDAN21:50
  UMP C <> LMP C;

theorem :: JORDAN21:51
  S-bound C < (UMP C)`2;

theorem :: JORDAN21:52
  (UMP C)`2 <= N-bound C;

theorem :: JORDAN21:53
  S-bound C <= (LMP C)`2;

theorem :: JORDAN21:54
  (LMP C)`2 < N-bound C;

theorem :: JORDAN21:55
  LSeg(UMP C, |[ (W-bound C + E-bound C) / 2, N-bound C]|)
  misses
  LSeg(LMP C, |[ (W-bound C + E-bound C) / 2, S-bound C]|);

theorem :: JORDAN21:56
  for A, B being Subset of TOP-REAL 2 st A c= B &
    W-bound A + E-bound A = W-bound B + E-bound B &
    A /\ Vertical_Line ((W-bound A + E-bound A) / 2) is non empty
    &
    proj2.:(B /\ Vertical_Line ((W-bound A + E-bound A) / 2)) is bounded_above
   holds (UMP A)`2 <= (UMP B)`2;

theorem :: JORDAN21:57
  for A, B being Subset of TOP-REAL 2 st A c= B &
    W-bound A + E-bound A = W-bound B + E-bound B &
    A /\ Vertical_Line ((W-bound A + E-bound A) / 2) is non empty
    &
    proj2.:(B /\ Vertical_Line ((W-bound A + E-bound A) / 2)) is bounded_below
   holds (LMP B)`2 <= (LMP A)`2;

theorem :: JORDAN21:58
  for A, B being Subset of TOP-REAL 2 st A c= B & UMP B in A &
    A /\ Vertical_Line ((W-bound A + E-bound A) / 2) is non empty &
    proj2.:(B /\ Vertical_Line ((W-bound B + E-bound B) / 2))
      is bounded_above &
    W-bound A + E-bound A = W-bound B + E-bound B
   holds UMP A = UMP B;

theorem :: JORDAN21:59
  for A, B being Subset of TOP-REAL 2 st A c= B & LMP B in A &
    A /\ Vertical_Line ((W-bound A + E-bound A) / 2) is non empty &
    proj2.:(B /\ Vertical_Line ((W-bound B + E-bound B) / 2))
      is bounded_below &
    W-bound A + E-bound A = W-bound B + E-bound B
   holds LMP A = LMP B;

theorem :: JORDAN21:60
  (UMP Upper_Arc C)`2 <= N-bound C;

theorem :: JORDAN21:61
  S-bound C <= (LMP Lower_Arc C)`2;

theorem :: JORDAN21:62
  not (LMP C in Lower_Arc C & UMP C in Lower_Arc C);

theorem :: JORDAN21:63
  not (LMP C in Upper_Arc C & UMP C in Upper_Arc C);

theorem :: JORDAN21:64
  0 < n implies
  sup (proj2.:(L~Cage(C,n) /\
       LSeg(Gauge(C,n)*(Center Gauge(C,n),1),
            Gauge(C,n)*(Center Gauge(C,n),len Gauge(C,n)))))
  =
  sup (proj2.:(L~Cage(C,n) /\
       Vertical_Line ((E-bound L~Cage(C,n) + W-bound L~Cage(C,n)) / 2)));

theorem :: JORDAN21:65
  0 < n implies
  inf (proj2.:(L~Cage(C,n) /\
       LSeg(Gauge(C,n)*(Center Gauge(C,n),1),
            Gauge(C,n)*(Center Gauge(C,n),len Gauge(C,n)))))
  =
  inf (proj2.:(L~Cage(C,n) /\
       Vertical_Line ((E-bound L~Cage(C,n) + W-bound L~Cage(C,n)) / 2)));

theorem :: JORDAN21:66
  0 < n implies
  UMP L~Cage(C,n) =
    |[ (E-bound L~Cage(C,n) + W-bound L~Cage(C,n)) / 2,
      sup (proj2.:(L~Cage(C,n) /\
           LSeg(Gauge(C,n)*(Center Gauge(C,n),1),
                Gauge(C,n)*(Center Gauge(C,n),len Gauge(C,n))))) ]|;

theorem :: JORDAN21:67
  0 < n implies
  LMP L~Cage(C,n) =
    |[ (E-bound L~Cage(C,n) + W-bound L~Cage(C,n)) / 2,
      inf (proj2.:(L~Cage(C,n) /\
           LSeg(Gauge(C,n)*(Center Gauge(C,n),1),
                Gauge(C,n)*(Center Gauge(C,n),len Gauge(C,n))))) ]|;

theorem :: JORDAN21:68
  (UMP C)`2 < (UMP L~Cage(C,n))`2;

theorem :: JORDAN21:69
  (LMP C)`2 > (LMP L~Cage(C,n))`2;

theorem :: JORDAN21:70
  UMP Upper_Arc L~Cage(C,n) in Upper_Arc L~Cage(C,n);

theorem :: JORDAN21:71
  LMP Lower_Arc L~Cage(C,n) in Lower_Arc L~Cage(C,n);

theorem :: JORDAN21:72
  0 < n implies ex i being Nat st 1 <= i & i <= len Gauge(C,n) &
    UMP L~Cage(C,n) = Gauge(C,n)*(Center Gauge(C,n),i);

theorem :: JORDAN21:73
  0 < n implies ex i being Nat st 1 <= i & i <= len Gauge(C,n) &
    LMP L~Cage(C,n) = Gauge(C,n)*(Center Gauge(C,n),i);

theorem :: JORDAN21:74
  0 < n implies UMP L~Cage(C,n) = UMP Upper_Arc L~Cage(C,n);

theorem :: JORDAN21:75
  0 < n implies LMP L~Cage(C,n) = LMP Lower_Arc L~Cage(C,n);

theorem :: JORDAN21:76
  0 < n implies (UMP C)`2 < (UMP Upper_Arc L~Cage(C,n))`2;

theorem :: JORDAN21:77
  0 < n implies (LMP Lower_Arc L~Cage(C,n))`2 < (LMP C)`2;

theorem :: JORDAN21:78
  i <= j implies (UMP L~Cage(C,j))`2 <= (UMP L~Cage(C,i))`2;

theorem :: JORDAN21:79
  i <= j implies (LMP L~Cage(C,i))`2 <= (LMP L~Cage(C,j))`2;

theorem :: JORDAN21:80
  0 < i & i <= j implies
  (UMP Upper_Arc L~Cage(C,j))`2 <= (UMP Upper_Arc L~Cage(C,i))`2;

theorem :: JORDAN21:81
  0 < i & i <= j implies
  (LMP Lower_Arc L~Cage(C,i))`2 <= (LMP Lower_Arc L~Cage(C,j))`2;

