:: Basic Notation of Universal Algebra
::  by Jaros{\l}aw Kotowicz, Beata Madras and Ma{\l}gorzata Korolkiewicz
::
:: Received December 29, 1992
:: Copyright (c) 1992 Association of Mizar Users

environ

 vocabularies FINSEQ_1, PARTFUN1, RELAT_1, FUNCT_2, FUNCOP_1, BOOLE, FUNCT_1,
      ZF_REFLE, INCPROJ, UNIALG_1, FINSEQ_2, FRAENKEL, PRALG_1, ARYTM;
 notations TARSKI, XBOOLE_0, SUBSET_1, NUMBERS, NAT_1, RELAT_1, FUNCT_1,
      FINSEQ_1, FRAENKEL, FINSEQ_2, FUNCOP_1, STRUCT_0, PARTFUN1, XXREAL_0;
 constructors PARTFUN1, FUNCOP_1, FRAENKEL, XXREAL_0, FINSEQ_2, STRUCT_0,
      VALUED_1, SEQ_1;
 registrations XBOOLE_0, SUBSET_1, ORDINAL1, RELSET_1, PARTFUN1, FUNCOP_1,
      FRAENKEL, XXREAL_0, STRUCT_0, VALUED_1, FUNCT_2;
 requirements NUMERALS, BOOLE, SUBSET;


begin

reserve A,z for set,
  x,y for FinSequence of A,
  h for PartFunc of A*,A,
  n,m for Nat;

definition
  let IT be Relation;
  attr IT is homogeneous means
:: UNIALG_1:def 1

  for x,y being FinSequence st x in dom IT & y in dom IT holds len x = len y;
end;

definition
  let A;
  let IT be PartFunc of A*,A;
  attr IT is quasi_total means
:: UNIALG_1:def 2
  for x,y st len x = len y & x in dom IT holds y in dom IT;
end;

registration
  let f be Relation;
  let i be Nat;
  cluster f|(i-tuples_on NAT) -> homogeneous;
end;

registration
  let A be non empty set;
  cluster homogeneous quasi_total non empty PartFunc of A*,A;
end;

registration
  cluster homogeneous non empty Function;
end;

theorem :: UNIALG_1:1
  h is non empty iff dom h <> {};

theorem :: UNIALG_1:2
  for A being non empty set, a being Element of A
  holds {<*>A} -->a is homogeneous quasi_total non empty PartFunc of A*,A;

theorem :: UNIALG_1:3
  for A being non empty set, a being Element of A
  holds {<*>A} -->a is Element of PFuncs(A*,A);

::::::::::::::::::: stolen from HILBERT3 and improved

registration
  let A be set, B be functional set;
  cluster -> Function-yielding PartFunc of A,B;
end;

:::::::::::::::::

registration
  let A be set;
  let B be functional set;
  cluster -> Function-yielding PartFunc of A,B;
end;

definition
  let A;
  mode PFuncFinSequence of A is FinSequence of PFuncs(A*,A);
end;

definition
  struct (1-sorted) UAStr (# carrier -> set,
    charact -> PFuncFinSequence of the carrier #);
end;

registration
  cluster non empty strict UAStr;
end;

registration
  let D be non empty set, c be PFuncFinSequence of D;
  cluster UAStr (#D,c #) -> non empty;
end;

definition
  let A;
  let IT be PFuncFinSequence of A;
  canceled;
  attr IT is homogeneous means
:: UNIALG_1:def 4

  for n,h st n in dom IT & h = IT.n holds h is homogeneous;
end;

definition
  let A;
  let IT be PFuncFinSequence of A;
  attr IT is quasi_total means
:: UNIALG_1:def 5

  for n,h st n in dom IT & h = IT.n holds h is quasi_total;
end;

definition
  let A be non empty set;
  let x be Element of PFuncs(A*,A);
  redefine func <*x*> -> PFuncFinSequence of A;
end;

registration
  let A be non empty set;
  cluster homogeneous quasi_total non-empty PFuncFinSequence of A;
end;

registration
  let A be non empty set;
  let f be homogeneous PFuncFinSequence of A;
  let i be set;
  cluster f.i -> homogeneous;
end;

definition
  let IT be UAStr;
  canceled;
  attr IT is partial means
:: UNIALG_1:def 7

  the charact of IT is homogeneous;
  attr IT is quasi_total means
:: UNIALG_1:def 8

  the charact of IT is quasi_total;
  attr IT is non-empty means
:: UNIALG_1:def 9

  the charact of IT <> {} & the charact of IT is non-empty;
end;

reserve A for non empty set,
  h for PartFunc of A*,A,
  x,y for FinSequence of A,
  a for Element of A;

theorem :: UNIALG_1:4
  for x be Element of PFuncs(A*,A) st x = {<*>A} --> a holds
  <*x*> is homogeneous quasi_total non-empty;

registration
  cluster quasi_total partial non-empty strict non empty UAStr;
end;

registration
  let U1 be partial UAStr;
  cluster the charact of U1 -> homogeneous;
end;

registration
  let U1 be quasi_total UAStr;
  cluster the charact of U1 -> quasi_total;
end;

registration
  let U1 be non-empty UAStr;
  cluster the charact of U1 -> non-empty non empty;
end;

definition
  mode Universal_Algebra is quasi_total partial non-empty non empty UAStr;
end;

reserve U1 for partial non-empty non empty UAStr;

definition
  let f be homogeneous Relation;
  func arity(f) -> Nat means
:: UNIALG_1:def 10
  for x being FinSequence st x in dom f holds it = len x
  if ex x being FinSequence st x in dom f otherwise it = 0;
end;

definition
  let f be homogeneous Function;
  redefine func arity(f) -> Element of NAT;
end;

theorem :: UNIALG_1:5
  n in dom the charact of U1 implies (the charact of U1).n is
  PartFunc of (the carrier of U1)*,the carrier of U1;

definition
  let U1;
  func signature U1 ->FinSequence of NAT means
:: UNIALG_1:def 11
  len it = len the charact of U1 & for n st n in dom it holds
  for h be homogeneous non empty
  PartFunc of (the carrier of U1 )*,the carrier of U1
  st h = (the charact of U1).n holds it.n = arity(h);
end;

begin :: Addenda

:: from MSSUBLAT, 2007.05.13, A.T.

registration
  let U0 be Universal_Algebra;
  cluster the charact of U0 -> Function-yielding;
end;

