:: Solving Complex Roots of Polynomial Equation of Degree 2 and 3 with
:: Complex Coefficients
::  by Yuzhong Ding and Xiquan Liang
::
:: Received January 26, 2004
:: Copyright (c) 2004 Association of Mizar Users

environ

 vocabulary COMPLEX1, ARYTM_3, ARYTM_1, POLYEQ_1, SQUARE_1, FUNCT_3, POLYEQ_3,
      RELAT_1, POWER, GROUP_1, PREPOWER, FUNCT_1, SIN_COS, HAHNBAN1, COMPTRIG;
 notation SUBSET_1, NUMBERS, XBOOLE_0, XCMPLX_0, XREAL_0, REAL_1, COMPLEX1,
      POLYEQ_1, SQUARE_1, COMSEQ_1, ARYTM_0, QUIN_1, POWER, NAT_1, COMSEQ_3,
      SIN_COS, HAHNBAN1, PREPOWER, BINARITH, SEQ_1, COMPLEX2;
 constructors COMPLEX1, REAL_1, POLYEQ_1, QUIN_1, NEWTON, GROUP_1, COMSEQ_1,
      ARYTM_0, SQUARE_1, SUBSET_1, POWER, INT_1, NAT_1, COMSEQ_3, COMPLFLD,
      COMPLSP1, RLVECT_1, HAHNBAN1, COMPTRIG, SIN_COS, PREPOWER, BINARITH,
      VECTSP_1, NUMBERS, SEQ_1, COMPLEX2, ARYTM_3, FUNCT_4, BINOP_2;
 clusters ARYTM_3, REAL_1, NEWTON, SQUARE_1, XREAL_0, RELAT_1, QUIN_1, INT_1,
      SIN_COS, COMPLFLD, COMPLEX1, BINARITH, VECTSP_1, XCMPLX_0, NUMBERS,
      POLYEQ_1;
 requirements ARITHM, SUBSET, REAL, BOOLE, NUMERALS;


begin

 reserve a,b,c,d,e,a',b',c',d',x,y,x1,y1,x2,y2,u,v for Real,
         s,t,h,z,z1,z2,z3,z4,s1,s2,s3,p,q for Element of COMPLEX,
         m,n for Nat;

definition let a be Real,z;
  redefine func a*z -> Element of COMPLEX equals
:: POLYEQ_3:def 1
        [*a,0*]*z;
  redefine func a + z -> Element of COMPLEX equals
:: POLYEQ_3:def 2
    z+[*a,0*];
end;

definition let z;
  redefine func z^2 -> Element of COMPLEX equals
:: POLYEQ_3:def 3
      [*(Re z)^2-(Im z)^2,2*(Re z*Im z)*];
end;

definition let a,b,c,z;
  redefine func Poly2 (a,b,c,z) -> Element of COMPLEX;
end;

theorem :: POLYEQ_3:1
    [*a,c*]*[*b,d*]=[*a*b-c*d,a*d+b*c*];

theorem :: POLYEQ_3:2
  z=[*x,y*] implies z^2=[*x^2-y^2,2*x*y*];

theorem :: POLYEQ_3:3
  for a,b holds [*a,0*]*[*b,0*]=[*a*b,0*];

theorem :: POLYEQ_3:4
    a <> 0 & delta(a,b,c) >=0 & Poly2(a,b,c,z) = 0 implies
         z= (-b+sqrt delta(a,b,c))/(2*a) or
         z= (-b-sqrt delta(a,b,c))/(2*a) or
         z= -b/(2*a);

theorem :: POLYEQ_3:5
    a <> 0 & delta(a,b,c) < 0 & Poly2(a,b,c,z) = 0c implies
        z= [*-b/(2*a),sqrt (-delta(a,b,c))/(2*a)*] or
        z= [*-b/(2*a),-sqrt (-delta(a,b,c))/(2*a)*];

theorem :: POLYEQ_3:6
      b <> 0 & (for z holds Poly2(0,b,c,z) = 0c) implies z = -c/b;

theorem :: POLYEQ_3:7
      for a,b,c being Real,z,z1,z2 being Element of COMPLEX
      st a <> 0 holds
      (for z being Element of COMPLEX holds
          Poly2(a,b,c,z) = Quard(a,z1,z2,z)) implies
           [*b/a,0*] =-(z1+z2) & [*c/a,0*]= z1*z2;

definition let z be Element of COMPLEX;
    func z^3 -> Element of COMPLEX equals
:: POLYEQ_3:def 4
     z^2*z;
end;

definition let a,b,c,d be Real,z be Element of COMPLEX;
    func Poly_3(a,b,c,d,z) -> Element of COMPLEX equals
:: POLYEQ_3:def 5
       a*z^3+b*z^2+c*z+d;
end;

theorem :: POLYEQ_3:8
    0c^3 = 0c;

theorem :: POLYEQ_3:9
  1r^3 = 1r;

theorem :: POLYEQ_3:10
    (-1r)^3=-1r;

theorem :: POLYEQ_3:11
    Re z^3 = (Re z)|^3 - 3*Re z*(Im z)^2
    & Im z^3 = -(Im z)|^ 3+3*(Re z)^2*Im z;

theorem :: POLYEQ_3:12
      (for z holds Poly_3(a,b,c,d,z) = Poly_3(a',b',c',d',z)) implies
    a = a' & b = b' & c = c' & d = d';

theorem :: POLYEQ_3:13
    (z+h)^3 = z^3+(3*h)*z^2+(3*h^2)*z+h^3;

theorem :: POLYEQ_3:14
      (z*h)^3 = z^3*h^3;

theorem :: POLYEQ_3:15
      b<>0 & Poly_3(0,b,c,d,z)=0c & delta(b,c,d)>=0 implies
       z = (-c+sqrt delta(b,c,d))/(2*b) or
       z = (-c-sqrt delta(b,c,d))/(2*b) or
       z = -c/(2*b);

theorem :: POLYEQ_3:16
      b<>0 & Poly_3(0,b,c,d,z)=0c & delta(b,c,d)<0 implies
      z = [*-c/(2*b),sqrt (-delta(b,c,d))/(2*b)*] or
      z = [*-c/(2*b),-sqrt (-delta(b,c,d))/(2*b)*];

theorem :: POLYEQ_3:17
      a<>0 & Poly_3(a,0,c,0,z)=0 & 4*a*c <= 0 implies
       z = (sqrt -4*a*c)/(2*a) or
       z = (-sqrt -4*a*c)/(2*a) or
       z = 0;

theorem :: POLYEQ_3:18
      a<>0 & Poly_3(a,b,c,0,z)=0 & delta(a,b,c)>=0 implies
       z = (-b+sqrt delta(a,b,c))/(2*a) or
       z = (-b-sqrt delta(a,b,c))/(2*a) or
       z = -b/(2*a) or
       z = 0;

theorem :: POLYEQ_3:19
      a<>0 & Poly_3(a,b,c,0,z)=0c & delta(a,b,c)<0 implies
      z= [*-b/(2*a),sqrt (-delta(a,b,c))/(2*a)*] or
      z= [*-b/(2*a),-sqrt (-delta(a,b,c))/(2*a)*] or
      z = 0c;

theorem :: POLYEQ_3:20
    a>=0 & y^2 = a implies y = sqrt a or y = -sqrt a;

theorem :: POLYEQ_3:21
      a<>0 & Poly_3(a,0,c,d,z)=0c & Im z = 0
       implies
       (for u,v st Re z = u+v & 3*v*u+c/a=0 holds
          z = 3-root(-d/(2*a)+sqrt(d^2/(4*a^2)+(c/(3*a)) |^ 3))
             +3-root(-d/(2*a)-sqrt(d^2/(4*a^2)+(c/(3*a)) |^ 3))
       or z = 3-root(-d/(2*a)+sqrt(d^2/(4*a^2)+(c/(3*a)) |^ 3))
             +3-root(-d/(2*a)+sqrt(d^2/(4*a^2)+(c/(3*a)) |^ 3))
       or z = 3-root(-d/(2*a)-sqrt(d^2/(4*a^2)+(c/(3*a)) |^ 3))
             +3-root(-d/(2*a)-sqrt(d^2/(4*a^2)+(c/(3*a)) |^ 3)) );

theorem :: POLYEQ_3:22
      a<>0 & Poly_3(a,0,c,d,z)=0c & Im z <> 0 implies
    (for u,v st  Re z = u+v & 3*v*u+c/(4*a)=0 & c/a>=0 holds
          z=[*3-root(d/(16*a)+sqrt((d/(16*a))^2+(c/(12*a)) |^ 3))
             +3-root(d/(16*a)-sqrt((d/(16*a))^2+(c/(12*a)) |^ 3)),
             sqrt(3*(3-root(d/(16*a)+sqrt((d/(16*a))^2+(c/(12*a)) |^ 3))
             + 3-root(d/(16*a)-sqrt((d/(16*a))^2+(c/(12*a)) |^ 3)))^2+c/a)*]
       or z=[*3-root(d/(16*a)+sqrt((d/(16*a))^2+(c/(12*a)) |^ 3))
             +3-root(d/(16*a)-sqrt((d/(16*a))^2+(c/(12*a)) |^ 3)),
             -sqrt(3*(3-root(d/(16*a)+sqrt((d/(16*a))^2+(c/(12*a)) |^ 3))
             +3-root(d/(16*a)-sqrt((d/(16*a))^2+(c/(12*a)) |^ 3)))^2+c/a)*]
       or z=[*2*(3-root(d/(16*a)+sqrt((d/(16*a))^2+(c/(12*a)) |^ 3))),
             sqrt(3*(2*(3-root(d/(16*a)+sqrt((d/(16*a))^2
             +(c/(12*a)) |^ 3))))^2+c/a)*]
       or z=[*2*(3-root(d/(16*a)+sqrt((d/(16*a))^2+(c/(12*a)) |^ 3))),
             -sqrt(3*(2*(3-root(d/(16*a)+sqrt((d/(16*a))^2
             +(c/(12*a)) |^ 3))))^2+c/a)*]
       or z=[*2*(3-root(d/(16*a)-sqrt((d/(16*a))^2+(c/(12*a)) |^ 3))),
             sqrt(3*(2*(3-root(d/(16*a)-sqrt((d/(16*a))^2
             +(c/(12*a)) |^ 3))))^2+c/a)*]
       or z=[*2*(3-root(d/(16*a)-sqrt((d/(16*a))^2+(c/(12*a)) |^ 3))),
             -sqrt(3*(2*(3-root(d/(16*a)-sqrt((d/(16*a))^2
             +(c/(12*a)) |^ 3))))^2+c/a)*]
          );

theorem :: POLYEQ_3:23
      a<>0 & Poly_3(a,b,c,d,z)=0c & Im z=0 implies
    (for u,v,x1 st x1=Re z + b/(3*a) &
       Re z=u+v-b/(3*a) & 3*u*v+(3*a*c-b^2)/(3*a^2)=0 holds
              z =[* 3-root(-(b/(3*a)) |^ 3-(3*a*d-b*c)/(6*a^2)
                 +sqrt((2*((b/(3*a)) |^ 3)+(3*a*d-b*c)/(3*a^2))^2/4
                 +((3*a*c-b^2)/(9*a^2)) |^ 3)) +
                3-root(-(b/(3*a)) |^ 3-(3*a*d-b*c)/(6*a^2)
                 -sqrt((2*((b/(3*a)) |^ 3)+(3*a*d-b*c)/(3*a^2))^2/4
                 +((3*a*c-b^2)/(9*a^2)) |^ 3))-b/(3*a),0*] or
            z =[* 3-root(-(b/(3*a)) |^ 3-(3*a*d-b*c)/(6*a^2)
                 +sqrt((2*((b/(3*a)) |^ 3)+(3*a*d-b*c)/(3*a^2))^2/4
                 +((3*a*c-b^2)/(9*a^2)) |^ 3)) +
                3-root(-(b/(3*a)) |^ 3-(3*a*d-b*c)/(6*a^2)
                 +sqrt((2*((b/(3*a)) |^ 3)+(3*a*d-b*c)/(3*a^2))^2/4
                 +((3*a*c-b^2)/(9*a^2)) |^ 3))-b/(3*a),0*] or
            z =[* 3-root(-(b/(3*a)) |^ 3-(3*a*d-b*c)/(6*a^2)
                 -sqrt((2*((b/(3*a)) |^ 3)+(3*a*d-b*c)/(3*a^2))^2/4
                 +((3*a*c-b^2)/(9*a^2)) |^ 3)) +
                3-root(-(b/(3*a)) |^ 3-(3*a*d-b*c)/(6*a^2)
                 -sqrt((2*((b/(3*a)) |^ 3)+(3*a*d-b*c)/(3*a^2))^2/4
                 +((3*a*c-b^2)/(9*a^2)) |^ 3))-b/(3*a),0*] );

theorem :: POLYEQ_3:24
  z1 <> 0 & Poly1(z1,z2,z) = 0 implies z = -(z2/z1);

theorem :: POLYEQ_3:25
     z2 <> 0 implies not ex z st Poly1(0,z2,z) = 0;

begin

definition let z1,z2,z3,z;
  func CPoly2(z1,z2,z3,z) -> Element of COMPLEX equals
:: POLYEQ_3:def 6
     z1*z^2+z2*z+z3;
end;

theorem :: POLYEQ_3:26
      (for z holds CPoly2(z1,z2,z3,z) = CPoly2(s1,s2,s3,z)) implies
    z1 = s1 & z2 = s2 & z3 = s3;

theorem :: POLYEQ_3:27
      (-a+sqrt (a^2+b^2))/2 >=0 & (a+sqrt (a^2+b^2))/2>=0;

theorem :: POLYEQ_3:28
   z^2 = s & Im s >= 0 implies
   z=[*sqrt (( Re s+sqrt ((Re s)^2+(Im s)^2))/2),
       sqrt ((-Re s+sqrt ((Re s)^2+(Im s)^2))/2)*] or
   z=[*-sqrt (( Re s+sqrt ((Re s)^2+(Im s)^2))/2),
       -sqrt ((-Re s+sqrt ((Re s)^2+(Im s)^2))/2)*];

theorem :: POLYEQ_3:29
     z^2 = s & Im s = 0 & Re s > 0 implies z=sqrt(Re s) or z=-sqrt(Re s);

theorem :: POLYEQ_3:30
     z^2 = s & Im s = 0 & Re s < 0 implies
    z=[*0, sqrt (-Re s)*] or z=[*0,-sqrt (-Re s)*];

theorem :: POLYEQ_3:31
     z^2 = s & Im s <0 implies
   z=[* sqrt (( Re s+sqrt ((Re s)^2+(Im s)^2))/2),
       -sqrt ((-Re s+sqrt ((Re s)^2+(Im s)^2))/2)*] or
   z=[*-sqrt (( Re s+sqrt ((Re s)^2+(Im s)^2))/2),
        sqrt ((-Re s+sqrt ((Re s)^2+(Im s)^2))/2)*];

theorem :: POLYEQ_3:32
   z^2 = s implies
   z=[*sqrt (( Re s+sqrt ((Re s)^2+(Im s)^2))/2),
       sqrt ((-Re s+sqrt ((Re s)^2+(Im s)^2))/2)*] or
   z=[*-sqrt (( Re s+sqrt ((Re s)^2+(Im s)^2))/2),
       -sqrt ((-Re s+sqrt ((Re s)^2+(Im s)^2))/2)*] or
   z=[* sqrt (( Re s+sqrt ((Re s)^2+(Im s)^2))/2),
       -sqrt ((-Re s+sqrt ((Re s)^2+(Im s)^2))/2)*] or
   z=[*-sqrt (( Re s+sqrt ((Re s)^2+(Im s)^2))/2),
        sqrt ((-Re s+sqrt ((Re s)^2+(Im s)^2))/2)*];

theorem :: POLYEQ_3:33
    CPoly2(0c,0c,0c,z) = 0;

theorem :: POLYEQ_3:34
  z1<>0 & CPoly2(z1,0c,0c,z) = 0 implies z=0;

theorem :: POLYEQ_3:35
      z1<>0 & CPoly2(z1,z2,0c,z)=0 implies z=-(z2/z1) or z=0;

theorem :: POLYEQ_3:36
    z1<>0c & CPoly2(z1,0c,z3,z)=0c implies
    (for s st s=-(z3/z1) holds
       z=[* sqrt (( Re s+sqrt ((Re s)^2+(Im s)^2))/2),
            sqrt ((-Re s+sqrt ((Re s)^2+(Im s)^2))/2)*] or
       z=[*-sqrt (( Re s+sqrt ((Re s)^2+(Im s)^2))/2),
           -sqrt ((-Re s+sqrt ((Re s)^2+(Im s)^2))/2)*] or
       z=[* sqrt (( Re s+sqrt ((Re s)^2+(Im s)^2))/2),
           -sqrt ((-Re s+sqrt ((Re s)^2+(Im s)^2))/2)*] or
       z=[*-sqrt (( Re s+sqrt ((Re s)^2+(Im s)^2))/2),
            sqrt ((-Re s+sqrt ((Re s)^2+(Im s)^2))/2)*]);

theorem :: POLYEQ_3:37
    z1<>0 & CPoly2(z1,z2,z3,z)=0c implies
          (for h,t st h=(z2/(2*z1))^2-z3/z1 & t=z2/(2*z1) holds
           z=[* sqrt (( Re h+sqrt ((Re h)^2+(Im h)^2))/2),
                sqrt ((-Re h+sqrt ((Re h)^2+(Im h)^2))/2)*]-t   or
           z=[*-sqrt (( Re h+sqrt ((Re h)^2+(Im h)^2))/2),
               -sqrt ((-Re h+sqrt ((Re h)^2+(Im h)^2))/2)*]-t   or
           z=[* sqrt (( Re h+sqrt ((Re h)^2+(Im h)^2))/2),
               -sqrt ((-Re h+sqrt ((Re h)^2+(Im h)^2))/2)*]-t   or
           z=[*-sqrt (( Re h+sqrt ((Re h)^2+(Im h)^2))/2),
                sqrt ((-Re h+sqrt ((Re h)^2+(Im h)^2))/2)*]-t);

definition let z1,z2,z3,z4,z;
  func CPoly3(z1,z2,z3,z4,z) -> Element of COMPLEX equals
:: POLYEQ_3:def 7
        z1*z^3 +z2*z^2+z3*z+z4;
end;

theorem :: POLYEQ_3:38
    z^2=1 implies z=1 or z=-1;

theorem :: POLYEQ_3:39
  z#N 3=z*z*z & z#N 3=z^2*z & z#N 3 = z^3;

theorem :: POLYEQ_3:40
      z1<>0 & CPoly3(z1,z2,0c,0c,z)=0c implies z=-z2/z1 or z=0;

theorem :: POLYEQ_3:41
      z1<>0c & CPoly3(z1,0c,z3,0c,z)=0c implies
     (for s st s=-(z3/z1) holds
     z=0c or
     z=[*sqrt (( Re s+sqrt ((Re s)^2+(Im s)^2))/2),
          sqrt ((-Re s+sqrt ((Re s)^2+(Im s)^2))/2)*] or
     z=[*-sqrt (( Re s+sqrt ((Re s)^2+(Im s)^2))/2),
         -sqrt ((-Re s+sqrt ((Re s)^2+(Im s)^2))/2)*] or
     z=[* sqrt (( Re s+sqrt ((Re s)^2+(Im s)^2))/2),
         -sqrt ((-Re s+sqrt ((Re s)^2+(Im s)^2))/2)*] or
     z=[*-sqrt (( Re s+sqrt ((Re s)^2+(Im s)^2))/2),
          sqrt ((-Re s+sqrt ((Re s)^2+(Im s)^2))/2)*]);

theorem :: POLYEQ_3:42
      z1<>0 & CPoly3(z1,z2,z3,0c,z)=0c implies
     (for s,h,t st s=-(z3/z1) & h=(z2/(2*z1))^2-z3/z1 & t=z2/(2*z1) holds
           z=0 or
           z=[* sqrt (( Re h+sqrt ((Re h)^2+(Im h)^2))/2),
                sqrt ((-Re h+sqrt ((Re h)^2+(Im h)^2))/2)*]-t   or
           z=[*-sqrt (( Re h+sqrt ((Re h)^2+(Im h)^2))/2),
               -sqrt ((-Re h+sqrt ((Re h)^2+(Im h)^2))/2)*]-t   or
           z=[* sqrt (( Re h+sqrt ((Re h)^2+(Im h)^2))/2),
               -sqrt ((-Re h+sqrt ((Re h)^2+(Im h)^2))/2)*]-t   or
           z=[*-sqrt (( Re h+sqrt ((Re h)^2+(Im h)^2))/2),
                sqrt ((-Re h+sqrt ((Re h)^2+(Im h)^2))/2)*]-t);

theorem :: POLYEQ_3:43
   z=s-[*1/3,0*]*z1 implies
    z^2 =s^2+(-[*2/3,0*])*z1*s+[*1/9,0*]*z1^2;

theorem :: POLYEQ_3:44
   z=s-[*1/3,0*]*z1 implies
    z^3 =s^3-z1*s^2+[*1/3,0*]*z1^2*s-[*1/27,0*]*z1^3;

theorem :: POLYEQ_3:45
      CPoly3(1r,z1,z2,z3,z)=0c implies
    (for p,q,s st z=s-[*1/3,0*]*z1 & p=-[*1/3,0*]*z1^2+z2
                & q=[*2/27,0*]*z1^3-[*1/3,0*]*z1*z2+z3 holds
      CPoly3(1r,0c,p,q,s)=0c );

theorem :: POLYEQ_3:46
   for z being Element of COMPLEX holds
    [* |.z.|*cos Arg z, |.z.|*sin Arg z *]
    = [*|.z.|,0*]*[*cos Arg z,sin Arg z *];

theorem :: POLYEQ_3:47
  for z be Element of COMPLEX,n be Nat holds
    z #N (n+1)=(z #N n) * z;

theorem :: POLYEQ_3:48
  for z be Element of COMPLEX holds
    z#N 1= z;

theorem :: POLYEQ_3:49
    for z be Element of COMPLEX holds
    z#N 2= z*z;

theorem :: POLYEQ_3:50
  for n be Nat st n>0 holds
    0c#N n = 0c;

theorem :: POLYEQ_3:51
   for x,y be Element of COMPLEX
    for n be Nat holds
     (x*y) #N n = x #N n * y #N n;

theorem :: POLYEQ_3:52
    for x be Real st x > 0
      for n be Nat holds
      [*x,0*]#N n = [*x to_power n,0*];

theorem :: POLYEQ_3:53
   for x being Real
   for n be Nat holds
    [*cos x,sin x*] #N n = [*cos (n*x),sin (n*x)*];

theorem :: POLYEQ_3:54
       for z being Element of COMPLEX
     for n being Nat st z <> 0c or n > 0 holds
    z#N n = [*(|.z.| to_power n)*cos (n*Arg z)
             ,(|.z.| to_power n)*sin (n*Arg z)*];

theorem :: POLYEQ_3:55
   for n,k be Nat,x be Real st n <> 0 holds
    [*cos((x+2*PI*k)/n),sin((x+2*PI*k)/n)*]#N n = [*cos x,sin x*];

theorem :: POLYEQ_3:56
   for z be Element of COMPLEX
   for n,k be Nat st n <> 0 holds
    z = [*(n-root |.z.|)*cos((Arg z+2*PI*k)/n),
          (n-root |.z.|)*sin((Arg z+2*PI*k)/n)*]#N n;

definition
   let z be Element of COMPLEX;
   let n be non empty Nat;
   mode CRoot of n,z -> Element of COMPLEX means
:: POLYEQ_3:def 8
         it#N n = z;
end;

theorem :: POLYEQ_3:57
     for z be Element of COMPLEX
   for n be non empty Nat
   for k be Nat holds
    [*(n-root |.z.|)*cos((Arg z+2*PI*k)/n),
      (n-root |.z.|)*sin((Arg z+2*PI*k)/n)*] is CRoot of n,z;

theorem :: POLYEQ_3:58
       for z be Element of COMPLEX
     for v be CRoot of 1,z holds
       v = z;

theorem :: POLYEQ_3:59
     for n be non empty Nat
   for v be CRoot of n,0c holds
    v = 0c;

theorem :: POLYEQ_3:60
       for n be non empty Nat
     for z be Element of COMPLEX
     for v be CRoot of n,z st v = 0c holds
       z = 0c;

theorem :: POLYEQ_3:61
     for n be non empty Nat
   for k be Nat holds
    [*cos(2*PI*k/n),sin(2*PI*k/n)*] is CRoot of n,1r;

theorem :: POLYEQ_3:62
     for k be Nat holds
    [*cos(2*PI*k/3),sin(2*PI*k/3)*] is CRoot of 3,1r;

theorem :: POLYEQ_3:63
       for z,s being Element of COMPLEX, n being Nat st
     s<>0 & z<>0 & n>=1 & s#N n=z#N n holds
     |.s.| = |.z.|;
