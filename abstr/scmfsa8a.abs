:: Conditional branch macro instructions of SCM+FSA, Part I (preliminary)
::  by Noriko Asamoto
::
:: Received August 27, 1996
:: Copyright (c) 1996 Association of Mizar Users

environ

 vocabularies AMI_3, AMI_1, SCMFSA_2, BOOLE, FUNCT_1, RELAT_1, FUNCT_4, SCM_1,
      FUNCT_7, SCMFSA6A, SCMFSA6B, SCMFSA6C, CAT_1, SF_MASTR, CARD_1, SCMFSA7B,
      AMI_5, RELOC, SCMFSA_7, FINSEQ_1, UNIALG_2, SCMFSA8A, CARD_3, ARYTM,
      AMISTD_2, SCMNORM;
 notations TARSKI, XBOOLE_0, SUBSET_1, CARD_1, NUMBERS, NAT_1, FUNCOP_1,
      RELAT_1, FUNCT_1, FUNCT_4, FUNCT_7, FINSEQ_1, VALUED_1, STRUCT_0, AMI_1,
      SCMNORM, SCMFSA_2, SCMFSA_4, SCMFSA_5, SCMFSA_7, SCMFSA6A, SF_MASTR,
      SCMFSA6B, SCMFSA6C, SCMFSA7B, XXREAL_0;
 constructors PARTFUN1, DOMAIN_1, XXREAL_0, NAT_1, SCMFSA_5, SCMFSA_7,
      SCMFSA6A, SF_MASTR, SCMFSA6B, SCMFSA6C, SCMFSA7B, SCMNORM, SCMFSA_4,
      AFINSQ_1, RELSET_1, PRE_POLY, SCMFSA_1;
 registrations XBOOLE_0, SETFAM_1, FUNCT_1, RELSET_1, FUNCOP_1, NUMBERS,
      XXREAL_0, MEMBERED, CARD_3, AMI_1, SCMFSA_2, SCMFSA6A, SF_MASTR,
      SCMFSA7B, FINSET_1, SCMNORM, ORDINAL1, FINSEQ_1, VALUED_1;
 requirements NUMERALS, REAL, BOOLE, SUBSET, ARITHM;


begin

reserve m for Element of NAT;

canceled 2;

theorem :: SCMFSA8A:3
  for s being State of SCM+FSA holds dom (s | NAT) = NAT;

theorem :: SCMFSA8A:4
  for s being State of SCM+FSA st ProgramPart s halts_on s for k being Element
  of NAT st LifeSpan s <= k holds CurInstr Computation(s,k) = halt SCM+FSA;

theorem :: SCMFSA8A:5
  for s being State of SCM+FSA st ProgramPart s halts_on s for k being Element
of NAT st LifeSpan s <= k holds IC Computation(s,k) = IC Computation(s,LifeSpan
  s);

theorem :: SCMFSA8A:6
  for s1,s2 being State of SCM+FSA holds s1,s2 equal_outside NAT
  iff IC s1 = IC s2 & DataPart s1 = DataPart s2;

theorem :: SCMFSA8A:7
  for s being State of SCM+FSA, I being Program of SCM+FSA holds IC
  IExec(I,s) = IC Result (s +* Initialized I);

theorem :: SCMFSA8A:8
  for s being State of SCM+FSA, I being Program of SCM+FSA holds
  Initialize s +* Initialized I = s +* Initialized I;

theorem :: SCMFSA8A:9
  for I being Program of SCM+FSA, l being Instruction-Location of
  SCM+FSA holds I c= I +* Start-At l;

theorem :: SCMFSA8A:10
  for s being State of SCM+FSA, l being Instruction-Location of
  SCM+FSA holds DataPart s = DataPart(s +* Start-At l);

theorem :: SCMFSA8A:11
  for s being State of SCM+FSA, I being Program of SCM+FSA, l being
  Instruction-Location of SCM+FSA holds DataPart s = DataPart (s +* (I +*
  Start-At l));

theorem :: SCMFSA8A:12
  for s being State of SCM+FSA, l being Instruction-Location of
  SCM+FSA holds dom (s | NAT) misses dom Start-At l;

theorem :: SCMFSA8A:13
  for s being State of SCM+FSA, I being Program of SCM+FSA holds s
  +* Initialized I = Initialize s +* (I +* Start-At insloc 0);

theorem :: SCMFSA8A:14
  for s being State of SCM+FSA, I1,I2 being Program of SCM+FSA, l
  being Instruction-Location of SCM+FSA holds s +* (I1 +* Start-At l), s +* (I2
  +* Start-At l) equal_outside NAT;

theorem :: SCMFSA8A:15
  0 in dom Stop SCM+FSA;

theorem :: SCMFSA8A:16
  (Stop SCM+FSA).0 = halt SCM+FSA;

theorem :: SCMFSA8A:17
  card Stop SCM+FSA = 1;

canceled 3;

theorem :: SCMFSA8A:21
  for P being preProgram of SCM+FSA, l being Instruction-Location of
SCM+FSA, x being set st x in dom P holds (P.x = halt SCM+FSA implies Directed(P
  ,l).x = goto l) & (P.x <> halt SCM+FSA implies Directed(P,l).x = P.x);

theorem :: SCMFSA8A:22
  for i being Instruction of SCM+FSA, a being Int-Location, n
  being Element of NAT holds i does_not_destroy a implies IncAddr(i,n)
  does_not_destroy a;

theorem :: SCMFSA8A:23
  for P being preProgram of SCM+FSA, n being Element of NAT, a
being Int-Location holds P does_not_destroy a implies [ProgramPart Relocated(P,
  n)] does_not_destroy a;

theorem :: SCMFSA8A:24
  for P being good preProgram of SCM+FSA, n being Element of NAT
  holds [ProgramPart Relocated(P,n)] is good;

theorem :: SCMFSA8A:25
  for I,J being preProgram of SCM+FSA, a being Int-Location holds
  I does_not_destroy a & J does_not_destroy a implies I +* J does_not_destroy a
;

theorem :: SCMFSA8A:26
  for I,J being good preProgram of SCM+FSA holds I +* J is good;

theorem :: SCMFSA8A:27
  for I being preProgram of SCM+FSA, l being Instruction-Location
of SCM+FSA, a being Int-Location holds I does_not_destroy a implies Directed(I,
  l) does_not_destroy a;

registration
  let I be good preProgram of SCM+FSA;
  let l be Instruction-Location of SCM+FSA;
  cluster Directed(I,l) -> good;
end;

registration
  let I be good Program of SCM+FSA;
  cluster Directed I -> good;
end;

registration
  let I be Program of SCM+FSA, l be Instruction-Location of SCM+FSA;
  cluster Directed(I,l) -> initial;
end;

registration
  let I,J be good Program of SCM+FSA;
  cluster I ';' J -> good;
end;

definition
  canceled;
  let l be Instruction-Location of SCM+FSA;
  func Goto l -> halt-free good Program of SCM+FSA equals
:: SCMFSA8A:def 2
  insloc 0 .--> goto l;
end;

definition
  let s be State of SCM+FSA;
  let P be initial FinPartState of SCM+FSA;
  pred P is_pseudo-closed_on s means
:: SCMFSA8A:def 3

  ex k being Element of NAT st IC
Computation (s +* (P +* Start-At insloc 0),k) = insloc card ProgramPart P & for
  n being Element of NAT st n < k holds IC Computation (s +* (P +* Start-At
  insloc 0),n) in dom P;
end;

definition
  let P be initial FinPartState of SCM+FSA;
  attr P is pseudo-paraclosed means
:: SCMFSA8A:def 4

  for s being State of SCM+FSA holds
  P is_pseudo-closed_on s;
end;

registration
  cluster pseudo-paraclosed Program of SCM+FSA;
end;

definition
  let s be State of SCM+FSA, P be initial FinPartState of SCM+FSA such that
 P is_pseudo-closed_on s;
  func pseudo-LifeSpan(s,P) -> Element of NAT means
:: SCMFSA8A:def 5

  IC Computation((s
  +* (P +* Start-At insloc 0)),it) = insloc card ProgramPart P & for n being
Element of NAT st not IC Computation( (s +* (P +* Start-At insloc 0)),n) in dom
  P holds it <= n;
end;

theorem :: SCMFSA8A:28
  for I,J being Program of SCM+FSA, x being set holds x in dom I
  implies (I ';' J).x = (Directed I).x;

theorem :: SCMFSA8A:29
  for l being Instruction-Location of SCM+FSA holds card Goto l = 1;

theorem :: SCMFSA8A:30
  for P being preProgram of SCM+FSA, x being set st x in dom P holds (P.
  x = halt SCM+FSA implies (Directed P).x = goto insloc card P) & (P.x <> halt
  SCM+FSA implies (Directed P).x = P.x);

theorem :: SCMFSA8A:31
  for s being State of SCM+FSA, P being initial FinPartState of
  SCM+FSA st P is_pseudo-closed_on s holds for n being Element of NAT st n <
pseudo-LifeSpan(s,P) holds IC ( Computation( (s +* (P +* Start-At insloc 0)),n)
  ) in dom P & CurInstr ( Computation( (s +* (P +* Start-At insloc 0)),n)) <>
  halt SCM+FSA;

theorem :: SCMFSA8A:32
  for s being State of SCM+FSA, I,J being Program of SCM+FSA st I
  is_pseudo-closed_on s for k being Element of NAT st k <= pseudo-LifeSpan(s,I)
  holds Computation( (s +* (I +* Start-At insloc 0)),k), Computation( (s +* ((I
  ';' J) +* Start-At insloc 0)),k) equal_outside NAT;

theorem :: SCMFSA8A:33
  for I being preProgram of SCM+FSA, l being Instruction-Location
  of SCM+FSA holds card Directed(I,l) = card I;

theorem :: SCMFSA8A:34
  for I being Program of SCM+FSA holds card Directed I = card I;

theorem :: SCMFSA8A:35
  for s being State of SCM+FSA, I being Program of SCM+FSA st I
  is_closed_on s & I is_halting_on s holds for k being Element of NAT st k <=
  LifeSpan (s +* (I +* Start-At insloc 0)) holds Computation( (s +* (I +*
Start-At insloc 0)),k), Computation( (s +* (Directed I +* Start-At insloc 0)),k
  ) equal_outside NAT & CurInstr Computation( (s +* (Directed I +* Start-At
  insloc 0)),k) <> halt SCM+FSA;

theorem :: SCMFSA8A:36
  for s being State of SCM+FSA, I being Program of SCM+FSA st I
  is_closed_on s & I is_halting_on s holds IC Computation( (s +* (Directed I +*
  Start-At insloc 0)), (LifeSpan (s +* (I +* Start-At insloc 0)) + 1)) = insloc
card I & DataPart Computation( (s +* (I +* Start-At insloc 0)), (LifeSpan (s +*
  (I +* Start-At insloc 0)))) = DataPart Computation( (s +* (Directed I +*
  Start-At insloc 0)), (LifeSpan (s +* (I +* Start-At insloc 0)) + 1));

theorem :: SCMFSA8A:37
  for s being State of SCM+FSA, I being Program of SCM+FSA holds I
is_closed_on s & I is_halting_on s implies Directed I is_pseudo-closed_on s;

theorem :: SCMFSA8A:38
  for s being State of SCM+FSA, I being Program of SCM+FSA holds I
  is_closed_on s & I is_halting_on s implies pseudo-LifeSpan(s,Directed I) =
  LifeSpan (s +* (I +* Start-At insloc 0)) + 1;

canceled 2;

theorem :: SCMFSA8A:41
  for I,J being Program of SCM+FSA holds Directed I ';' J = I ';'
  J;

theorem :: SCMFSA8A:42
  for s being State of SCM+FSA, I,J being Program of SCM+FSA st I
  is_closed_on s & I is_halting_on s holds (for k being Element of NAT st k <=
LifeSpan (s +* (I +* Start-At insloc 0)) holds IC Computation( (s +* (Directed
  I +* Start-At insloc 0)),k) = IC Computation( (s +* ((I ';' J) +* Start-At
insloc 0)),k) & CurInstr Computation( (s +* (Directed I +* Start-At insloc 0)),
  k) = CurInstr Computation( (s +* ((I ';' J) +* Start-At insloc 0)),k)) &
DataPart Computation( (s +* (Directed I +* Start-At insloc 0)), (LifeSpan (s +*
  (I +* Start-At insloc 0)) + 1)) = DataPart Computation( (s +* ((I ';' J) +*
  Start-At insloc 0)), (LifeSpan (s +* (I +* Start-At insloc 0)) + 1)) & IC
  Computation( (s +* (Directed I +* Start-At insloc 0)), (LifeSpan (s +* (I +*
Start-At insloc 0)) + 1)) = IC Computation( (s +* ((I ';' J) +* Start-At insloc
  0)), (LifeSpan (s +* (I +* Start-At insloc 0)) + 1));

theorem :: SCMFSA8A:43
  for s being State of SCM+FSA, I,J being Program of SCM+FSA st I
  is_closed_on Initialize s & I is_halting_on Initialize s holds (for k being
  Element of NAT st k <= LifeSpan (s +* Initialized I) holds IC Computation( (s
+* Initialized Directed I),k) = IC Computation( (s +* Initialized (I ';' J)),k)
& CurInstr Computation( (s +* Initialized Directed I),k) = CurInstr Computation
  ( (s +* Initialized (I ';' J)),k)) & DataPart Computation( (s +* Initialized
Directed I), (LifeSpan (s +* Initialized I) + 1)) = DataPart Computation( (s +*
Initialized (I ';' J)), (LifeSpan (s +* Initialized I) + 1)) & IC Computation(
  (s +* Initialized Directed I), (LifeSpan (s +* Initialized I) + 1)) = IC
Computation( (s +* Initialized (I ';' J)), (LifeSpan (s +* Initialized I) + 1))
;

theorem :: SCMFSA8A:44
  for s being State of SCM+FSA, I being Program of SCM+FSA st I
  is_closed_on Initialize s & I is_halting_on Initialize s holds for k being
  Element of NAT st k <= LifeSpan (s +* Initialized I) holds Computation( (s +*
Initialized I),k), Computation( (s +* Initialized Directed I),k) equal_outside
  NAT & CurInstr Computation( (s +* Initialized Directed I),k) <> halt SCM+FSA;

theorem :: SCMFSA8A:45
  for s being State of SCM+FSA, I being Program of SCM+FSA st I
is_closed_on Initialize s & I is_halting_on Initialize s holds IC Computation(
  (s +* Initialized Directed I), (LifeSpan (s +* Initialized I) + 1)) = insloc
card I & DataPart Computation( (s +* Initialized I),LifeSpan (s +* Initialized
  I)) = DataPart Computation( (s +* Initialized Directed I), (LifeSpan (s +*
  Initialized I) + 1));

theorem :: SCMFSA8A:46
  for I being Program of SCM+FSA, s being State of SCM+FSA st I
is_closed_on s & I is_halting_on s holds I ';' Stop SCM+FSA is_closed_on s & I
  ';' Stop SCM+FSA is_halting_on s;

theorem :: SCMFSA8A:47
  for l being Instruction-Location of SCM+FSA holds insloc 0 in dom Goto
  l & (Goto l).insloc 0 = goto l;

canceled 5;

theorem :: SCMFSA8A:53
  for I being Program of SCM+FSA, s being State of SCM+FSA st I
is_closed_on Initialize s & I is_halting_on Initialize s holds IC Computation(
(s +* Initialized (I ';' Stop SCM+FSA)), (LifeSpan (s +* Initialized I) + 1)) =
  insloc card I;

theorem :: SCMFSA8A:54
  for I being Program of SCM+FSA, s being State of SCM+FSA st I
  is_closed_on Initialize s & I is_halting_on Initialize s holds DataPart
  Computation( (s +* Initialized I),LifeSpan (s +* Initialized I)) = DataPart
  Computation( (s +* Initialized (I ';' Stop SCM+FSA)), (LifeSpan (s +*
  Initialized I) + 1));

theorem :: SCMFSA8A:55
  for I being Program of SCM+FSA, s being State of SCM+FSA st I
is_closed_on Initialize s & I is_halting_on Initialize s
 holds ProgramPart(s +* Initialized(I ';' Stop SCM+FSA))
  halts_on s +* Initialized(I ';' Stop SCM+FSA);

theorem :: SCMFSA8A:56
  for I being Program of SCM+FSA, s being State of SCM+FSA st I
  is_closed_on Initialize s & I is_halting_on Initialize s holds LifeSpan (s +*
  Initialized (I ';' Stop SCM+FSA)) = LifeSpan (s +* Initialized I) + 1;

theorem :: SCMFSA8A:57
  for s being State of SCM+FSA, I being Program of SCM+FSA st I
is_closed_on Initialize s & I is_halting_on Initialize s holds IExec(I ';' Stop
  SCM+FSA,s) = IExec(I,s) +* Start-At insloc card I;

theorem :: SCMFSA8A:58
  for I,J being Program of SCM+FSA,s being State of SCM+FSA st I
  is_closed_on s & I is_halting_on s holds I ';' Goto insloc (card J + 1) ';' J
';' Stop SCM+FSA is_closed_on s & I ';' Goto insloc (card J + 1) ';' J ';' Stop
  SCM+FSA is_halting_on s;

theorem :: SCMFSA8A:59
  for I,J being Program of SCM+FSA, s being State of SCM+FSA st I
  is_closed_on s & I is_halting_on s
   holds ProgramPart(s +* (I ';' Goto insloc (card J + 1)
  ';' J ';' Stop SCM+FSA +* Start-At insloc 0))
   halts_on s +* (I ';' Goto insloc (card J + 1)
  ';' J ';' Stop SCM+FSA +* Start-At insloc 0);

theorem :: SCMFSA8A:60
  for I,J being Program of SCM+FSA, s being State of SCM+FSA st I
is_closed_on Initialize s & I is_halting_on Initialize s
 holds ProgramPart(s +* Initialized
  (I ';' Goto insloc (card J + 1) ';' J ';' Stop SCM+FSA))
   halts_on s +* Initialized
  (I ';' Goto insloc (card J + 1) ';' J ';' Stop SCM+FSA);

theorem :: SCMFSA8A:61
  for I,J being Program of SCM+FSA, s being State of SCM+FSA st I
  is_closed_on Initialize s & I is_halting_on Initialize s holds IC IExec(I ';'
Goto insloc (card J + 1) ';' J ';' Stop SCM+FSA,s) = insloc (card I + card J +
  1);

theorem :: SCMFSA8A:62
  for I,J being Program of SCM+FSA, s being State of SCM+FSA st I
is_closed_on Initialize s & I is_halting_on Initialize s holds IExec(I ';' Goto
insloc (card J + 1) ';' J ';' Stop SCM+FSA,s) = IExec(I,s) +* Start-At insloc (
  card I + card J + 1);

