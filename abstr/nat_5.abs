:: The Perfect Number Theorem and Wilson's Theorem
::  by Marco Riccardi
:: 
:: Received March 3, 2009
:: Copyright (c) 2009 Association of Mizar Users

environ

 vocabularies ORDINAL2, ARYTM, FINSEQ_1, ARYTM_3, ARYTM_1, RELAT_1, FUNCT_1,
      BOOLE, QC_LANG1, CARD_3, FINSET_1, XREAL_0, GROUP_1, NAT_1, INT_1,
      FILTER_0, CARD_1, TARSKI, SQUARE_1, POWER, EULER_1, MATRIX_2, INT_5,
      ABSVALUE, GR_CY_1, COMPLEX1, MOEBIUS1, BHSP_5, NAT_5, FUNCT_2, RLVECT_1,
      SUPINF_1, FUNCOP_1, FINSEQ_2, WAYBEL29, TOPGEN_1, COHSP_1, POLYNOM1,
      UPROOTS, ALGSEQ_1, MONOID_0, RFINSEQ, PARTFUN1, RFUNCT_3, INT_2, NAT_3,
      NAT_LAT, XXREAL_2, MEMBERED, PROB_1;
 notations VALUED_1, TARSKI, XBOOLE_0, ZFMISC_1, SUBSET_1, SETFAM_1, FUNCOP_1,
      RELAT_1, FUNCT_1, RELSET_1, PARTFUN1, MCART_1, FUNCT_2, ORDINAL1,
      NUMBERS, CARD_3, CARD_1, XCMPLX_0, XREAL_0, FINSEQ_1, FINSEQ_2, FINSEQ_3,
      INT_1, INT_2, NAT_1, NAT_D, RVSUM_1, REAL_1, SQUARE_1, XXREAL_0, NEWTON,
      ABIAN, EULER_2, PEPIN, ABSVALUE, EQREL_1, INT_5, MEMBERED, FINSEQOP,
      CARD_FIN, ENUMSET1, FINSET_1, COMPLEX1, NAT_3, DOMAIN_1, POWER, MOEBIUS1,
      INT_3, BHSP_5, EULER_1, WSIERP_1, BINOP_1, PROB_3, RECDEF_1, SUPINF_1,
      CONVFUN1, POLYNOM1, UPROOTS, BINOP_2, FUNCT_3, RFINSEQ, RFUNCT_3,
      XXREAL_2, CLASSES1;
 constructors VALUED_1, RELAT_2, PARTFUN1, MCART_1, SETFAM_1, FUNCT_2,
      WELLORD2, REAL_1, SQUARE_1, NAT_1, NAT_D, BINOP_2, INT_2, FINSOP_1,
      RVSUM_1, NEWTON, WSIERP_1, ABIAN, EULER_1, EULER_2, PEPIN, ABSVALUE,
      EQREL_1, INT_4, ZFMISC_1, RELSET_1, INT_5, RECDEF_1, MEMBERED, SEQ_4,
      MOEBIUS1, FINSEQOP, NUMBERS, MESFUNC2, CONVFUN1, CARD_FIN, XXREAL_0,
      COMPLEX1, INT_1, TARSKI, ENUMSET1, FUNCOP_1, XREAL_0, CARD_1, XCMPLX_0,
      UPROOTS, NAT_3, REALSET1, FUNCT_1, POWER, INT_3, BHSP_5, FINSEQ_1,
      FINSEQ_5, RFINSEQ, CALCUL_2, BINOP_1, PROB_3, SUPINF_1, FINSEQ_3,
      GOBRD10, POLYNOM1, FUNCT_3, RFUNCT_3, VALUED_0, XXREAL_2, CLASSES1,
      PBOOLE;
 registrations XBOOLE_0, ORDINAL1, RELSET_1, FINSET_1, NUMBERS, XCMPLX_0,
      XXREAL_0, XREAL_0, NAT_1, INT_1, INT_2, MEMBERED, FINSEQ_1, FINSEQ_2,
      RVSUM_1, VALUED_0, NEWTON, ABIAN, PEPIN, ABSVALUE, EQREL_1, INT_4,
      FUNCT_1, ZFMISC_1, SUBSET_1, INT_5, MOEBIUS1, FUNCT_2, PRE_CIRC,
      CARD_FIN, DYNKIN, RELAT_1, PARTFUN1, SQUARE_1, CARD_1, PREPOWER, POWER,
      INT_3, BHSP_5, WSIERP_1, FINSEQ_5, FINSEQ_7, RFINSEQ, CALCUL_2, BINOP_1,
      SUPINF_1, CONVFUN1, POLYNOM1, NAT_3, UPROOTS, BINOP_2, FUNCT_3, XXREAL_2,
      CLASSES1;
 requirements REAL, NUMERALS, SUBSET, BOOLE, ARITHM;


begin :: Preliminaries

reserve k,n,m,l,p for natural number;
reserve n0,m0 for non zero natural number;

theorem :: NAT_5:1
  2|^(n+1) < 2|^(n+2) - 1;

theorem :: NAT_5:2
  n0 is even implies ex k,m st m is odd & k > 0 & n0 = 2|^k * m;

theorem :: NAT_5:3
  n=2|^k & m is odd implies n,m are_relative_prime;

theorem :: NAT_5:4
  {n} is finite Subset of NAT;

theorem :: NAT_5:5
  {n,m} is finite Subset of NAT;

:: FinSequence

reserve f for FinSequence;
reserve x,X,Y for set;

theorem :: NAT_5:6
  f is one-to-one implies Del(f,n) is one-to-one;

theorem :: NAT_5:7
  f is one-to-one & n in dom f implies not f.n in rng Del(f,n);

theorem :: NAT_5:8
  x in rng f & not x in rng Del(f,n) implies x = f.n;

theorem :: NAT_5:9
  for f1 being FinSequence of NAT, f2 being FinSequence of X
  st rng f1 c= dom f2 holds f2*f1 is FinSequence of X;

reserve f1,f2,f3 for FinSequence of REAL;

theorem :: NAT_5:10
  X \/ Y = dom f1 & X misses Y & f2 = f1*Sgm(X) & f3 = f1*Sgm(Y)
  implies Sum f1 = Sum f2 + Sum f3;

theorem :: NAT_5:11
  f2 = f1*Sgm(X) & dom f1 \ f1"{0} c= X & X c= dom f1 implies Sum f1 = Sum f2;

theorem :: NAT_5:12
  f2 = f1 - {0} implies Sum f1 = Sum f2;

:: like FINSEQ_3:126
theorem :: NAT_5:13
  for f being FinSequence of NAT holds f is FinSequence of REAL;

:: NatDivisors

reserve n1,n2,m1,m2 for natural number;

theorem :: NAT_5:14
  n1 in NatDivisors n & m1 in NatDivisors m & n,m are_relative_prime
  implies n1,m1 are_relative_prime;

theorem :: NAT_5:15
  n1 in NatDivisors n & m1 in NatDivisors m &
  n2 in NatDivisors n & m2 in NatDivisors m &
  n,m are_relative_prime & n1*m1=n2*m2 implies n1=n2 & m1=m2;

theorem :: NAT_5:16
  n1 in NatDivisors n0 & m1 in NatDivisors m0 implies
  n1*m1 in NatDivisors(n0*m0);

theorem :: NAT_5:17
  n0,m0 are_relative_prime implies k gcd n0*m0 = (k gcd n0)*(k gcd m0);

theorem :: NAT_5:18
  n0,m0 are_relative_prime & k in NatDivisors(n0*m0) implies
  ex n1,m1 st n1 in NatDivisors n0 & m1 in NatDivisors m0 & k=n1*m1;

theorem :: NAT_5:19
  p is prime implies
  NatDivisors(p|^n) = {p|^k where k is Element of NAT : k <= n};

theorem :: NAT_5:20
  0 <> l & p > l & p > n1 & p > n2 &
  l*n1 mod p = l*n2 mod p & p is prime implies n1=n2;

theorem :: NAT_5:21
  p is prime implies
  p |-count(n0 gcd m0) = min(p |-count n0,p |-count m0);

begin :: Wilson's Theorem

:: Number Theory (Andrews) p.61-66
theorem :: NAT_5:22
  n is prime iff (n-'1)! + 1 mod n = 0 & n>1;

begin :: All Primes (1 mod 4) Equal the Sum of Two Squares

:: Proofs from THE BOOK (Aigner-Ziegler) p.19
theorem :: NAT_5:23
  p is prime & p mod 4 = 1 implies ex n,m st p = n^2 + m^2;

begin :: The Sum of Divisors Function

definition
  let I be set;
  let f be Function of I, NAT;
  let J be finite Subset of I;
  redefine func f|J -> bag of J;
end;

registration
  let I be set;
  let f be Function of I, NAT;
  let J be finite Subset of I;
  cluster Sum(f|J) -> natural number;
end;

theorem :: NAT_5:24
  for f being Function of NAT, NAT, F being Function of NAT, REAL,
      J being finite Subset of NAT st f = F & (ex k st J c= Seg k)
  holds Sum(f|J) = Sum Func_Seq(F,Sgm J);

theorem :: NAT_5:25
  for I being non empty set, F being PartFunc of I, REAL,
      f being Function of I, NAT, J being finite Subset of I st f = F
  holds Sum(f|J) = Sum(F,J);

reserve I,j for set;
reserve f,g for Function of I, NAT;
reserve J,K for finite Subset of I;

theorem :: NAT_5:26
  J misses K implies Sum(f|(J \/ K)) = Sum(f|J) + Sum(f|K);

theorem :: NAT_5:27
  J = {j} implies Sum(f|J) = f.j;

theorem :: NAT_5:28
  Sum((multnat*[:f,g:])|[:J,K:]) = Sum(f|J) * Sum(g|K);

definition
  let k be natural number;
  func EXP(k) -> Function of NAT, NAT means
:: NAT_5:def 1
  for n being natural number holds it.n = n|^k;
end;

definition
  let k,n be natural number;
  func sigma(k,n) -> Element of NAT means
:: NAT_5:def 2
  for m being non zero natural number st n = m holds
  it = Sum((EXP k)|NatDivisors m) if n<>0
  otherwise it = 0;
end;

definition
  let k be natural number;
  func Sigma(k) -> Function of NAT, NAT means
:: NAT_5:def 3
  for n being natural number holds it.n = sigma(k,n);
end;

definition
  let n be natural number;
  func sigma n -> Element of NAT equals
:: NAT_5:def 4
  sigma(1,n);
end;

theorem :: NAT_5:29
  sigma(k,1) = 1;

theorem :: NAT_5:30
  p is prime implies sigma(p|^n) = (p|^(n+1) - 1)/(p - 1);

theorem :: NAT_5:31
  m divides n0 & n0<>m & m<>1 implies 1+m+n0 <= sigma n0;

theorem :: NAT_5:32
  m divides n0 & k divides n0 & n0<>m & n0<>k & m<>1 & k<>1 & m<>k
  implies 1+m+k+n0 <= sigma n0;

theorem :: NAT_5:33
  sigma n0 = n0 + m & m divides n0 & n0<>m implies m = 1 & n0 is prime;

definition
  let f be Function of NAT, NAT;
  attr f is multiplicative means
:: NAT_5:def 5
  for n0,m0 being non zero natural number st n0,m0 are_relative_prime
  holds f.(n0*m0) = f.n0 * f.m0;
end;

theorem :: NAT_5:34
  for f,F being Function of NAT, NAT st
    f is multiplicative &
    (for n0 holds F.n0 = Sum(f|NatDivisors n0))
  holds F is multiplicative;

theorem :: NAT_5:35
  EXP(k) is multiplicative;

theorem :: NAT_5:36
  Sigma(k) is multiplicative;

theorem :: NAT_5:37
  n0,m0 are_relative_prime implies sigma(n0*m0) = sigma(n0) * sigma m0;

begin :: The Perfect Number Theorem

definition
  let n0 be non zero natural number;
  attr n0 is perfect means
:: NAT_5:def 6
  sigma n0 = 2 * n0;
end;

:: Fundamentals of Number Theory (LeVeque) p.123
:: Euclid
theorem :: NAT_5:38
  2|^p -' 1 is prime & n0 = 2|^(p -' 1)*(2|^p -' 1) implies n0 is perfect;

:: Euler
theorem :: NAT_5:39
  n0 is even & n0 is perfect implies
  ex p being natural number
  st 2|^p -' 1 is prime & n0 = 2|^(p -' 1)*(2|^p -' 1);

begin :: A Formula involving Euler's Function

definition
  func Euler_phi -> Function of NAT, NAT means
:: NAT_5:def 7
  for k being Element of NAT holds it.k = Euler(k);
end;

:: Number Theory (Andrews) p.76
theorem :: NAT_5:40
  Sum(Euler_phi|NatDivisors n0) = n0;
