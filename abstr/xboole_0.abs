:: Boolean Properties of Sets - Definitions
::  by Library Committee
::
:: Received April 6, 2002
:: Copyright (c) 2002 Association of Mizar Users

environ

 vocabulary TARSKI, BOOLE, ZFMISC_1;
 notation TARSKI;
 constructors TARSKI;


begin

 reserve X, Y, Z, x, y, z for set;

scheme :: XBOOLE_0:sch 1
 Separation { A()-> set, P[set] } :
   ex X being set st for x being set holds x in X iff x in A() & P[x]
proof
   defpred Q[set,set] means $1 = $2 & P[$2];
A1: for x,y,z st Q[x,y] & Q[x,z] holds y = z;
   consider X such that
A2: for x holds x in X iff ex y st y in A() & Q[y,x] from TARSKI:sch 1(A1);
  take X;
  let x;
     x in X iff ex y st y in A() & y = x & P[x] by A2;
  hence thesis;
 end;

definition
  func {} -> set means
:: XBOOLE_0:def 1
   not ex x being set st x in it;

 let X,Y be set;
  func X \/ Y -> set means
:: XBOOLE_0:def 2
   x in it iff x in X or x in Y;
  commutativity;
  idempotence;

  func X /\ Y -> set means
:: XBOOLE_0:def 3
   x in it iff x in X & x in Y;
  commutativity;
  idempotence;

  func X \ Y -> set means
:: XBOOLE_0:def 4
   x in it iff x in X & not x in Y;
end;


definition let X be set;
 attr X is empty means
:: XBOOLE_0:def 5
    X = {};

 let Y be set;
 func X \+\ Y -> set equals
:: XBOOLE_0:def 6
  (X \ Y) \/ (Y \ X);
 commutativity;

 pred X misses Y means
:: XBOOLE_0:def 7
   X /\ Y = {};
  symmetry;
  pred X c< Y means
:: XBOOLE_0:def 8
    X c= Y & X <> Y;
 irreflexivity;

 pred X,Y are_c=-comparable means
:: XBOOLE_0:def 9
    X c= Y or Y c= X;
 reflexivity;
 symmetry;
 redefine pred X = Y means
:: XBOOLE_0:def 10
    X c= Y & Y c= X;
end;
notation let X be set;
 let Y be set;
 antonym X meets Y for X misses Y ; end;


theorem :: XBOOLE_0:1
    x in X \+\ Y iff not (x in X iff x in Y);

theorem :: XBOOLE_0:2 :: BOOLE'25:
    (for x holds not x in X iff (x in Y iff x in Z)) implies X = Y \+\ Z;



registration
 cluster {} -> empty;
  coherence by Def5;
 cluster empty set;
  existence
   proof {} is empty by Def5; hence thesis; end;
 cluster non empty set;
  existence
   proof consider x;
      x in {x} by TARSKI:def 1;
    then {x} <> {} by Def1;
    then {x} is non empty by Def5;
    hence thesis;
   end;
end;


registration let D be non empty set, X be set;
  cluster D \/ X -> non empty;
  coherence
  proof
    consider x being set such that
A1: x in D by Def1;
      x in D \/ X by A1,Def2;
    then D \/ X <> {} by Def1;
    hence thesis by Def5;
  end;
  cluster X \/ D -> non empty;
  coherence
  proof
    consider x being set such that
A2: x in D by Def1;
      x in X \/ D by A2,Def2;
    then X \/ D <> {} by Def1;
    hence thesis by Def5;
  end;
end;


theorem :: XBOOLE_0:3  :: BOOLE'1:
  X meets Y iff ex x st x in X & x in Y;

theorem :: XBOOLE_0:4 :: BOOLE'2:
    X meets Y iff ex x st x in X /\ Y;

theorem :: XBOOLE_0:5 :: SYSREL'1:
    X misses Y & x in X \/ Y implies
    ((x in X & not x in Y) or (x in Y & not x in X));

scheme :: XBOOLE_0:sch 2
 Extensionality { X,Y() -> set, P[set] } :
  X() = Y() provided
  for x holds x in X() iff P[x] and
  for x holds x in Y() iff P[x]
proof
A3:  x in X() implies x in Y()
     proof assume x in X(); then P[x] by A1; hence x in Y() by A2; end;
      x in Y() implies x in X()
     proof assume x in Y(); then P[x] by A2; hence x in X() by A1; end;
   hence thesis by A3,TARSKI:2;
  end;

scheme :: XBOOLE_0:sch 3
 SetEq { P[set] } :
  for X1,X2 being set st
   (for x being set holds x in X1 iff P[x]) &
   (for x being set holds x in X2 iff P[x]) holds X1 = X2
proof defpred p[set] means P[$1];
  let X1,X2 be set such that
  A1: for x being set holds x in X1 iff p[x] and
  A2: for x being set holds x in X2 iff p[x];
  thus thesis from Extensionality(A1,A2);
end;

