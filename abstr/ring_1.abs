:: Quotient Rings
::  by Artur Korni{\l}owicz
::
:: Received December 7, 2005
:: Copyright (c) 2005 Association of Mizar Users

environ

 vocabularies RING_1, EQREL_1, RELAT_2, SETWISEO, VECTSP_1, FUNCT_1, ARYTM_3,
      RELAT_1, RLVECT_1, ARYTM_1, BINOP_1, FUNCSDOM, LATTICES, GROUP_1,
      FILTER_2, IDEAL_1, FILTER_0, SUBSET_1, VECTSP_2, GROUP_4, COLLSP,
      WAYBEL20, PARTFUN1, ORDERS_2, WELLORD2, WELLORD1, TARSKI, ARYTM;
 notations TARSKI, XBOOLE_0, SUBSET_1, SETWISEO, RELAT_1, RELSET_1, FUNCT_1,
      PARTFUN1, ALG_1, RELAT_2, EQREL_1, WELLORD1, WELLORD2, ORDERS_1, BINOP_1,
      DOMAIN_1, STRUCT_0, GROUP_1, RLVECT_1, VECTSP_1, VECTSP_2, FUNCSDOM,
      IDEAL_1;
 constructors WELLORD1, WELLORD2, BINOP_1, SETWISEO, ORDERS_1, EQREL_1, GCD_1,
      IDEAL_1;
 registrations XBOOLE_0, SUBSET_1, RELSET_1, FINSUB_1, EQREL_1, STRUCT_0,
      VECTSP_1, ALGSTR_1, QUOFIELD, IDEAL_1;
 requirements BOOLE, SUBSET;


begin :: Preliminaries

registration
  let S be non empty 1-sorted;
  cluster [#]S -> non proper;
end;

theorem :: RING_1:1
  for L being add-associative right_zeroed right_complementable
  (non empty LoopStr),
  a, b being Element of L
  holds a - b + b = a;

theorem :: RING_1:2
  for L being add-associative right_zeroed right_complementable
  Abelian (non empty LoopStr),
      b, c being Element of L holds
  c = b - (b - c);

theorem :: RING_1:3
  for L being add-associative right_zeroed right_complementable
  Abelian (non empty LoopStr),
  a, b, c being Element of L holds
  a - b - (c - b) = a - c;

begin :: Ideals

definition
  let K be non empty HGrStr, S be Subset of K;
  attr S is quasi-prime means
:: RING_1:def 1

  for a, b being Element of K st a*b in S holds a in S or b in S;
end;

definition
  let K be non empty multLoopStr, S be Subset of K;
  attr S is prime means
:: RING_1:def 2

  S is proper quasi-prime;
end;

definition
  let R be non empty doubleLoopStr;
  let I be Subset of R;
  attr I is quasi-maximal means
:: RING_1:def 3

  for J being Ideal of R st I c= J
  holds J = I or J is non proper;
end;

definition
  let R be non empty doubleLoopStr;
  let I be Subset of R;
  attr I is maximal means
:: RING_1:def 4

  I is proper quasi-maximal;
end;

registration
  let K be non empty multLoopStr;
  cluster prime -> proper quasi-prime Subset of K;
  cluster proper quasi-prime -> prime Subset of K;
end;

registration
  let R be non empty doubleLoopStr;
  cluster maximal -> proper quasi-maximal Subset of R;
  cluster proper quasi-maximal -> maximal Subset of R;
end;

registration
  let R be non empty LoopStr;
  cluster [#]R -> add-closed;
end;

registration
  let R be non empty HGrStr;
  cluster [#]R -> left-ideal right-ideal;
end;

theorem :: RING_1:4
   for R being domRing holds {0.R} is prime;

begin :: Equivalence Relation

reserve
  R for Ring,
  I for Ideal of R,
  a, b for Element of R;

definition
  let R be Ring, I be Ideal of R;
  func EqRel(R,I) -> Relation of R means
:: RING_1:def 5

  for a, b being Element of R holds [a,b] in it iff a-b in I;
end;

registration
  let R be Ring, I be Ideal of R;
  cluster EqRel(R,I) -> non empty total symmetric transitive;
end;

theorem :: RING_1:5
  a in Class(EqRel(R,I),b) iff a-b in I;

theorem :: RING_1:6
  Class(EqRel(R,I),a) = Class(EqRel(R,I),b) iff a-b in I;

theorem :: RING_1:7
  Class(EqRel(R,[#]R),a) = the carrier of R;

theorem :: RING_1:8
   Class EqRel(R,[#]R) = {the carrier of R};

theorem :: RING_1:9
  Class(EqRel(R,{0.R}),a) = {a};

theorem :: RING_1:10
   Class EqRel(R,{0.R}) = rng singleton the carrier of R;

begin :: Quotient Ring

definition
  let R be Ring, I be Ideal of R;
  func QuotientRing(R,I) -> strict doubleLoopStr means
:: RING_1:def 6

  the carrier of it = Class EqRel(R,I) &
  1.it = Class(EqRel(R,I),1.R) &
  0.it = Class(EqRel(R,I),0.R) &

  (for x, y being Element of it ex a, b being Element of R st
  x = Class(EqRel(R,I),a) & y = Class(EqRel(R,I),b) &
  (the add of it).(x,y) = Class(EqRel(R,I),a+b)) &

  (for x, y being Element of it ex a, b being Element of R st
  x = Class(EqRel(R,I),a) & y = Class(EqRel(R,I),b) &
  (the mult of it).(x,y) = Class(EqRel(R,I),a*b));
end;

notation
  let R be Ring, I be Ideal of R;
  synonym R/I for QuotientRing(R,I);
end;

registration
  let R be Ring, I be Ideal of R;
  cluster R/I -> non empty;
end;

reserve
  x, y for Element of R/I;

theorem :: RING_1:11
  ex a being Element of R st x = Class(EqRel(R,I),a);

theorem :: RING_1:12
  Class(EqRel(R,I),a) is Element of R/I;

theorem :: RING_1:13
  x = Class(EqRel(R,I),a) & y = Class(EqRel(R,I),b) implies
  x+y = Class(EqRel(R,I),a+b);

theorem :: RING_1:14
  x = Class(EqRel(R,I),a) & y = Class(EqRel(R,I),b) implies
  x*y = Class(EqRel(R,I),a*b);

theorem :: RING_1:15
  Class(EqRel(R,I),1.R) = 1.(R/I);

registration
  let R be Ring, I be Ideal of R;
  cluster R/I -> Abelian add-associative right_zeroed right_complementable
  associative well-unital distributive;
end;

registration
  let R be commutative Ring, I be Ideal of R;
  cluster R/I -> commutative;
end;

theorem :: RING_1:16
  I is proper iff R/I is non degenerated;

theorem :: RING_1:17
  I is quasi-prime iff R/I is domRing-like;

theorem :: RING_1:18
   for R being commutative Ring, I being Ideal of R holds
  I is prime iff R/I is domRing;

theorem :: RING_1:19
  R is commutative & I is quasi-maximal implies R/I is Field-like;

theorem :: RING_1:20
  R/I is Field-like implies I is quasi-maximal;

theorem :: RING_1:21
   for R being commutative Ring, I being Ideal of R holds
  I is maximal iff R/I is Skew-Field;

registration
  let R be non degenerated commutative Ring;
  cluster maximal -> prime Ideal of R;
end;

registration
  let R be non degenerated Ring;
  cluster maximal Ideal of R;
end;

registration
  :: to round up conditional clusters
  let R be non degenerated commutative Ring;
  cluster maximal Ideal of R;
end;

registration
  let R be non degenerated commutative Ring, I be quasi-prime Ideal of R;
  cluster R/I -> domRing-like;
end;

registration
  let R be non degenerated commutative Ring, I be quasi-maximal Ideal of R;
  cluster R/I -> Field-like;
end;
