:: Real Linear Space of Real Sequences
::  by Noboru Endou , Yasumasa Suzuki and Yasunari Shidama
::
:: Received April 3, 2003
:: Copyright (c) 2003 Association of Mizar Users

environ

 vocabulary RLVECT_1, FUNCT_1, ARYTM, ARYTM_1, RELAT_1, ABSVALUE, ORDINAL2,
      BINOP_1, SQUARE_1, PROB_1, FUNCT_2, RLSUB_1, SEQ_1, SEQ_2, SERIES_1,
      BHSP_1, SUPINF_2, RSSPACE;
 notation TARSKI, SUBSET_1, XBOOLE_0, ZFMISC_1, ORDINAL1, NUMBERS, XREAL_0,
      STRUCT_0, REAL_1, NAT_1, RELAT_1, FUNCT_1, PARTFUN1, FUNCT_2, RLVECT_1,
      ABSVALUE, RLSUB_1, BHSP_1, SQUARE_1, SEQ_1, SEQ_2, SEQM_3, SERIES_1,
      BINOP_1;
 constructors REAL_1, NAT_1, DOMAIN_1, SQUARE_1, SEQ_2, SERIES_1, PREPOWER,
      PARTFUN1, BINOP_1, RLSUB_1, BHSP_3, MEMBERED;
 clusters RELSET_1, STRUCT_0, RLVECT_1, SEQ_1, BHSP_1, XREAL_0, MEMBERED;
 requirements SUBSET, REAL, BOOLE, NUMERALS, ARITHM;


begin

definition
 func the_set_of_RealSequences -> non empty set means
:: RSSPACE:def 1
  for x being set holds x in it iff x is Real_Sequence;
end;


definition
  let a be set such that
  a in the_set_of_RealSequences;
  func seq_id(a) -> Real_Sequence equals
:: RSSPACE:def 2
   a;
end;


definition
 let a be set such that
 a in REAL;
 func R_id(a) -> Real equals
:: RSSPACE:def 3
  a;
end;


theorem :: RSSPACE:1
ex ADD be BinOp of the_set_of_RealSequences st
  (for a,b being Element of the_set_of_RealSequences
    holds ADD.(a,b) = seq_id(a)+seq_id(b)) & ADD is commutative associative;

theorem :: RSSPACE:2
ex f be Function of [: REAL, the_set_of_RealSequences :],
  the_set_of_RealSequences st
   for r,x be set st r in REAL & x in the_set_of_RealSequences
      holds f.[r,x] = R_id(r) (#) seq_id(x);

definition
  func l_add -> BinOp of the_set_of_RealSequences means
:: RSSPACE:def 4
    for a,b being Element of the_set_of_RealSequences holds
      it.(a,b) = seq_id(a)+seq_id(b);
end;


definition
 func l_mult -> Function of [: REAL, the_set_of_RealSequences :],
  the_set_of_RealSequences means
:: RSSPACE:def 5
   for r,x be set st r in REAL & x in the_set_of_RealSequences
      holds it.[r,x] = R_id(r)(#)seq_id(x);
end;


definition
 func Zeroseq -> Element of the_set_of_RealSequences means
:: RSSPACE:def 6
 for n be Nat holds (seq_id it).n=0;
end;


theorem :: RSSPACE:3
for x be Real_Sequence holds seq_id x = x;

theorem :: RSSPACE:4
for v,w being VECTOR of
 RLSStruct(#the_set_of_RealSequences,Zeroseq,l_add,l_mult#) holds
  v + w = seq_id(v)+seq_id(w);

theorem :: RSSPACE:5
for r being Real,
 v being VECTOR of RLSStruct(# the_set_of_RealSequences,Zeroseq,l_add,l_mult #)
  holds r * v = r(#)seq_id(v);

registration
  cluster RLSStruct (# the_set_of_RealSequences, Zeroseq, l_add, l_mult #) ->
    Abelian;
  coherence
  proof
     let v,w being VECTOR of
     RLSStruct(# the_set_of_RealSequences,Zeroseq,l_add,l_mult #);
       v + w = seq_id(v)+seq_id(w) by Th4;
     hence thesis by Th4;
  end;
end;

theorem :: RSSPACE:6
for u,v,w being VECTOR of
 RLSStruct(# the_set_of_RealSequences,Zeroseq,l_add,l_mult #) holds
  (u + v) + w = u + (v + w);

theorem :: RSSPACE:7
for v being VECTOR of
 RLSStruct(# the_set_of_RealSequences,Zeroseq,l_add,l_mult #) holds
  v + 0.RLSStruct(# the_set_of_RealSequences,Zeroseq,l_add,l_mult #) = v;

theorem :: RSSPACE:8
for v being VECTOR of
 RLSStruct(# the_set_of_RealSequences,Zeroseq,l_add,l_mult #)
  ex w being VECTOR of
   RLSStruct(# the_set_of_RealSequences,Zeroseq,l_add,l_mult #) st
    v + w = 0.RLSStruct(# the_set_of_RealSequences,Zeroseq,l_add,l_mult #);

theorem :: RSSPACE:9
for a being Real, v,w being VECTOR of
 RLSStruct(# the_set_of_RealSequences,Zeroseq,l_add,l_mult #) holds
  a * (v + w) = a * v + a * w;

theorem :: RSSPACE:10
for a,b being Real, v being VECTOR of
 RLSStruct(# the_set_of_RealSequences,Zeroseq,l_add,l_mult #) holds
  (a + b) * v = a * v + b * v;

theorem :: RSSPACE:11
for a,b be Real, v being VECTOR of
 RLSStruct(# the_set_of_RealSequences,Zeroseq,l_add,l_mult #) holds
  (a * b) * v = a * (b * v);

theorem :: RSSPACE:12
for v being VECTOR of
 RLSStruct(# the_set_of_RealSequences,Zeroseq,l_add,l_mult #) holds 1 * v = v;

definition
  func Linear_Space_of_RealSequences -> RealLinearSpace equals
:: RSSPACE:def 7
   RLSStruct (# the_set_of_RealSequences, Zeroseq, l_add, l_mult #);
end;


definition
let X be RealLinearSpace;
let X1 be Subset of X such that
X1 is lineary-closed non empty;
func Add_(X1,X) -> BinOp of X1 equals
:: RSSPACE:def 8
(the add of X) | [:X1,X1:];
end;


definition
let X be RealLinearSpace;
let X1 be Subset of X such that
 X1 is lineary-closed non empty;
func Mult_(X1,X) -> Function of [:REAL,X1:], X1 equals
:: RSSPACE:def 9
(the Mult of X) | [:REAL,X1:];
end;


definition
let X be RealLinearSpace, X1 be Subset of X such that
 X1 is lineary-closed non empty;
func Zero_(X1,X) -> Element of X1 equals
:: RSSPACE:def 10
  0.X;
end;


theorem :: RSSPACE:13
for V be RealLinearSpace, V1 be Subset of V
 st V1 is lineary-closed non empty holds
  RLSStruct (# V1,Zero_(V1,V), Add_(V1,V),Mult_(V1,V) #) is Subspace of V;

definition
  func the_set_of_l2RealSequences -> Subset of
    Linear_Space_of_RealSequences means
:: RSSPACE:def 11
  for x being set holds x in it iff
  (x in the_set_of_RealSequences & seq_id(x)(#)seq_id(x) is summable);
end;


canceled;

registration
  cluster the_set_of_l2RealSequences -> lineary-closed non empty;
  coherence
proof
set W = the_set_of_l2RealSequences;
A1:for v,u be VECTOR of Linear_Space_of_RealSequences st
    v in the_set_of_l2RealSequences &
    u in the_set_of_l2RealSequences
        holds v + u in the_set_of_l2RealSequences
   proof
     let v,u be VECTOR of Linear_Space_of_RealSequences such that
A2: v in W & u in W;
  (seq_id(v+u))(#)(seq_id(v+u)) is summable
     proof
A3:  (seq_id(v))(#)(seq_id(v)) is summable by A2,Def11;
A4:  (seq_id(u))(#)(seq_id(u)) is summable by A2,Def11;
       set p = (seq_id(v))(#)(seq_id(v));
       set q = (seq_id(u))(#)(seq_id(u));
       set r = (seq_id(v+u))(#)(seq_id(v+u));
A5:  2(#)p is summable by A3,SERIES_1:13;
   2(#)q is summable by A4,SERIES_1:13;
then A6:  2(#)p+2(#)q is summable by A5,SERIES_1:10;
A7:  for n be Nat holds 0<=r.n
       proof
        let n be Nat;
          r.n=(seq_id(v+u)).n * (seq_id(v+u)).n by SEQ_1:12;
        hence thesis by REAL_1:93;
      end;
  for n be Nat holds r.n <=(2(#)p+2(#)q).n
      proof
        let n be Nat;
        set s = seq_id v;
        set t = seq_id u;
        reconsider sn=s.n, tn=t.n as Real;
A8:     seq_id(v+u)=seq_id(seq_id(v)+seq_id(u)) by Def7,Th4
                    .=seq_id(v)+seq_id(u) by Th3;
A9:     r.n=(seq_id(v+u)).n * (seq_id(v+u)).n by SEQ_1:12
         .=(s.n+t.n) * (seq_id(v)+seq_id(u)).n by A8,SEQ_1:11
         .=(s.n+t.n) * (s.n+t.n) by SEQ_1:11
         .=((s.n)+(t.n))^2 by SQUARE_1:def 3
         .= sn^2 + 2*sn*tn + tn^2 by SQUARE_1:63;
      (2(#)p+2(#)q).n=(2(#)p).n +(2(#)q).n by SEQ_1:11
                    .= 2*p.n + (2(#)q).n by SEQ_1:13
                    .= 2*p.n + 2*q.n by SEQ_1:13
                    .= 2*(s.n*s.n) + 2*q.n by SEQ_1:12
                    .= 2*(s.n*s.n) + 2*(t.n*t.n) by SEQ_1:12
                    .= 2*sn^2 + 2*(t.n*t.n) by SQUARE_1:def 3
                    .= 2*sn^2 + 2*tn^2 by SQUARE_1:def 3;
then A10:     (2(#)p+2(#)q).n - r.n
          = 2*sn^2 + 2*tn^2 - (sn^2 + 2*sn*tn) - tn^2 by A9,XCMPLX_1:36
         .= 2*sn^2 + 2*tn^2 - sn^2 - 2*sn*tn - tn^2 by XCMPLX_1:36
         .= 2*sn^2 - sn^2 + 2*tn^2 - 2*sn*tn - tn^2 by XCMPLX_1:29
         .= sn^2 + sn^2 - sn^2 + 2*tn^2 - 2*sn*tn - tn^2 by XCMPLX_1:11
         .= sn^2 + 2*tn^2 - 2*sn*tn - tn^2 by XCMPLX_1:26
         .= sn^2 - 2*sn*tn + 2*tn^2 - tn^2 by XCMPLX_1:29
         .= sn^2 - 2*sn*tn + (2*tn^2 - tn^2) by XCMPLX_1:29
         .= sn^2 - 2*sn*tn + (tn^2 + tn^2 - tn^2) by XCMPLX_1:11
         .= sn^2 - 2 * sn * tn + tn^2 by XCMPLX_1:26
         .= (sn-tn)^2 by SQUARE_1:64;
         0 <= (sn-tn)^2 by SQUARE_1:72;
       then 0 + r.n <= (2(#)p+2(#)q).n - r.n + r.n by A10,REAL_1:55;
       then r.n <= (2(#)p+2(#)q).n - (r.n - r.n) by XCMPLX_1:37;
      hence thesis by XCMPLX_1:17;
     end;
     hence thesis by A6,A7,SERIES_1:24;
    end;
    hence v+u in W by Def7,Def11;
end;
A2:W is non empty
   proof
       seq_id Zeroseq (#)seq_id Zeroseq is summable
     proof
       reconsider rseq=(seq_id(Zeroseq)(#)seq_id(Zeroseq)) as Real_Sequence;
         now let n be Nat;
         thus rseq.n =((seq_id(Zeroseq)).n ) * ((seq_id(Zeroseq)).n )
          by SEQ_1:12
          .=((seq_id(Zeroseq)).n ) * 0 by Def6
          .=0;
       end;
       then rseq is absolutely_summable by COMSEQ_3:3;
       hence thesis by SERIES_1:40;
     end;
     hence thesis by Def11;
  end;
  for a be Real for v be VECTOR of Linear_Space_of_RealSequences
    st v in W holds a * v in W
    proof
let a be Real;
let v be VECTOR of Linear_Space_of_RealSequences such that
    A11: v in W;
      (seq_id(a*v))(#)(seq_id(a*v)) is summable
    proof
     A12: (seq_id(v))(#)(seq_id(v)) is summable by A11,Def11;
       seq_id(a*v)=seq_id(a(#)seq_id(v)) by Def7,Th5
                     .=a(#)seq_id(v) by Th3;
     then (seq_id(a*v))(#)(seq_id(a*v))
          =a(#)((a(#)seq_id(v))(#) seq_id(v)) by SEQ_1:27
         .=a(#)(a(#)( seq_id(v)(#)seq_id(v))) by SEQ_1:26
         .=(a*a)(#)(seq_id(v)(#)seq_id(v)) by SEQ_1:31;
     hence thesis by A12,SERIES_1:13;
    end;
    hence a*v in W by Def7,Def11;
  end;
  hence thesis by A1,A2,RLSUB_1:def 1;
end;
end;


theorem :: RSSPACE:15
  RLSStruct(# the_set_of_l2RealSequences,
        Zero_(the_set_of_l2RealSequences,Linear_Space_of_RealSequences),
        Add_(the_set_of_l2RealSequences,Linear_Space_of_RealSequences),
        Mult_(the_set_of_l2RealSequences,Linear_Space_of_RealSequences) #)
is Subspace of Linear_Space_of_RealSequences;

theorem :: RSSPACE:16
RLSStruct (# the_set_of_l2RealSequences,
        Zero_(the_set_of_l2RealSequences,Linear_Space_of_RealSequences),
        Add_(the_set_of_l2RealSequences,Linear_Space_of_RealSequences),
        Mult_(the_set_of_l2RealSequences,Linear_Space_of_RealSequences) #)
is RealLinearSpace;

theorem :: RSSPACE:17
   the carrier of Linear_Space_of_RealSequences = the_set_of_RealSequences &
  (for x be set holds x is VECTOR of Linear_Space_of_RealSequences
  iff x is Real_Sequence )
& (for u be VECTOR of Linear_Space_of_RealSequences
  holds u =seq_id(u) )
& (for u,v be VECTOR of Linear_Space_of_RealSequences
  holds u+v =seq_id(u)+seq_id(v) )
& (for r be Real for u be VECTOR of Linear_Space_of_RealSequences
  holds r*u =r(#)seq_id(u) );

theorem :: RSSPACE:18
ex f be Function of
[: the_set_of_l2RealSequences, the_set_of_l2RealSequences :], REAL st
  ( for x,y be set st
        x in the_set_of_l2RealSequences & y in the_set_of_l2RealSequences
      holds f.[x,y] = Sum(seq_id(x)(#)seq_id(y)) );

definition
  func l_scalar -> Function of
   [:the_set_of_l2RealSequences, the_set_of_l2RealSequences:], REAL means
:: RSSPACE:def 12
    (for x,y be set st
    x in the_set_of_l2RealSequences & y in the_set_of_l2RealSequences
     holds it.[x,y] = Sum(seq_id(x)(#)seq_id(y)));
end;


registration
  cluster UNITSTR (# the_set_of_l2RealSequences,
        Zero_(the_set_of_l2RealSequences,Linear_Space_of_RealSequences),
         Add_(the_set_of_l2RealSequences,Linear_Space_of_RealSequences),
        Mult_(the_set_of_l2RealSequences,Linear_Space_of_RealSequences),
        l_scalar #) -> non empty;
  coherence;
end;


definition
  func l2_Space -> non empty UNITSTR equals
:: RSSPACE:def 13
  UNITSTR (# the_set_of_l2RealSequences,
        Zero_(the_set_of_l2RealSequences,Linear_Space_of_RealSequences),
         Add_(the_set_of_l2RealSequences,Linear_Space_of_RealSequences),
        Mult_(the_set_of_l2RealSequences,Linear_Space_of_RealSequences),
        l_scalar #);
end;


theorem :: RSSPACE:19
for l be UNITSTR st
RLSStruct (# the carrier of l, the Zero of l, the add of l,
        the Mult of l #) is RealLinearSpace holds l is RealLinearSpace;

theorem :: RSSPACE:20
  for rseq be Real_Sequence
   st (for n be Nat holds rseq.n=0) holds
   rseq is summable & Sum rseq = 0;

theorem :: RSSPACE:21
  for rseq be Real_Sequence
   st ( (for n be Nat holds 0 <= rseq.n) & rseq is summable & Sum rseq=0)
   holds for n be Nat holds rseq.n =0;

registration
  cluster l2_Space -> Abelian add-associative right_zeroed
    right_complementable RealLinearSpace-like;
  coherence by Def13,Th16,Th19;
end;

