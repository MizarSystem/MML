:: Armstrong's Axioms
::  by William W. Armstrong , Yatsuka Nakamura and Piotr Rudnicki
::
:: Received October 25, 2002
:: Copyright (c) 2002 Association of Mizar Users

environ

 vocabulary ARMSTRNG, BOOLE, RELAT_1, RELAT_2, FINSET_1, FUNCT_1, FUNCT_4,
      CARD_3, PBOOLE, ZF_REFLE, MCART_1, ORDERS_1, SETFAM_1, INT_1, EQREL_1,
      WAYBEL_4, SUBSET_1, CANTOR_1, CARD_1, FUNCOP_1, FINSEQ_1, FINSEQ_2,
      MARGREL1, MATRLIN, BINARITH, BINARI_3, ZF_LANG, MIDSP_3, POWER, EUCLID,
      ARYTM_1, FINSEQ_4, CONLAT_1, FINSUB_1, PARTFUN1;
 notation TARSKI, XBOOLE_0, ZFMISC_1, SUBSET_1, FINSET_1, FINSUB_1, RELAT_1,
      RELAT_2, RELSET_1, SETFAM_1, PARTFUN1, NUMBERS, XCMPLX_0, XREAL_0, NAT_1,
      FUNCT_4, FUNCT_1, ORDERS_1, MCART_1, EQREL_1, CARD_3, PBOOLE, INT_1,
      STRUCT_0, WAYBEL_4, CANTOR_1, YELLOW_8, CARD_1, FINSEQ_1, PRE_CIRC,
      MARGREL1, FUNCT_2, FINSEQ_2, MATRLIN, BINARITH, BINARI_3, MIDSP_3,
      FINSEQ_4, SERIES_1, EUCLID;
 constructors INT_1, WAYBEL_4, CANTOR_1, YELLOW_8, PRE_CIRC, MATRLIN, BINARITH,
      BINARI_3, MIDSP_3, REAL_1, SERIES_1, EUCLID, FINSEQOP, PRALG_1;
 clusters FINSET_1, SUBSET_1, ALTCAT_1, PBOOLE, FINSEQ_1, FINSEQ_2, GOBRD13,
      FUNCT_1, ORDERS_1, CANTOR_1, RELSET_1, EQREL_1, WAYBEL_7, INT_1,
      MARGREL1, BINARITH, XBOOLE_0, MATRLIN, PRALG_1, FRAENKEL, XREAL_0,
      MEMBERED, NUMBERS, ORDINAL2;
 requirements BOOLE, SUBSET, NUMERALS, REAL, ARITHM;


begin

theorem :: ARMSTRNG:1
for B being set st B is cap-closed
for X being set, S being finite Subset-Family of X
 st X in B & S c= B holds Intersect S in B;

registration
  cluster reflexive antisymmetric transitive non empty Relation;
  existence proof set R = {[{},{}]};
   reconsider R as Relation by RELAT_1:4;
  A1: field R = {{},{}} by RELAT_1:32 .= {{}} by ENUMSET1:69;
   take R;
   thus R is reflexive proof
    let x be set; assume x in field R; then x = {} by A1,TARSKI:def 1;
     hence [x,x] in R by TARSKI:def 1;
   end;
   thus R is antisymmetric proof let x, y be set; assume
       x in field R & y in field R & [x,y] in R & [y,x] in R;
     then x = {} & y = {} by A1,TARSKI:def 1;
     hence thesis;
   end;
   thus R is transitive proof let x, y, z be set; assume
       x in field R & y in field R & z in field R & [x,y] in R & [y,z] in R;
     then x = {} & z = {} by A1,TARSKI:def 1;
    hence [x,z] in R by TARSKI:def 1;
   end;
   thus R is non empty;
  end;
end;


theorem :: ARMSTRNG:2
for R being antisymmetric transitive non empty Relation,
    X being finite Subset of field R
 st X <> {} ex x being Element of X st x is_maximal_wrt X, R;

scheme :: ARMSTRNG:sch 1
 SubsetS_Eq { X() -> set, P[set] }:
 for X1,X2 being Subset of X() st
   (for y being set holds y in X1 iff P[y]) &
   (for y being set holds y in X2 iff P[y]) holds X1 = X2
proof
 let X1,X2 being Subset of X() such that
A1:for y being set holds y in X1 iff P[y] and
A2:for y being set holds y in X2 iff P[y];
    for x being set holds x in X1 iff x in X2
  proof
    let x be set;
    hereby assume x in X1;
      then P[x] by A1;
      hence x in X2 by A2;
    end;
    assume x in X2;
    then P[x] by A2;
    hence thesis by A1;
  end;
  hence thesis by TARSKI:2;
end;

definition
 let X be set, R be Relation;
 func R Maximal_in X -> Subset of X means
:: ARMSTRNG:def 1
  for x being set holds x in it iff x is_maximal_wrt X, R;
end;


definition
  let x, X be set;
  pred x is_/\-irreducible_in X means
:: ARMSTRNG:def 2
   x in X &
   for z, y being set st z in X & y in X & x = z /\ y holds x = z or x = y;
  end;
notation
  let x, X be set;
  antonym x is_/\-reducible_in X for x is_/\-irreducible_in X ; end;


definition
  let X be non empty set;
  func /\-IRR X -> Subset of X means
:: ARMSTRNG:def 3
   for x being set holds x in it iff x is_/\-irreducible_in X;
end;


scheme :: ARMSTRNG:sch 2
 FinIntersect {X() -> non empty finite set, P[set]} :
  for x being set st x in X() holds P[x]
provided
 for x being set st x is_/\-irreducible_in X() holds P[x] and
 for x, y being set st x in X() & y in X() & P[x] & P[y] holds P[x /\ y]
proof
 deffunc U(set) = {x where x is Element of X(): $1 c= x};
 given x being set such that
A3: x in X() and
A4: not P[x];
 defpred R[Nat] means ex s being Element of X() st Card U(s) = $1 & not P[s];
         U(x) c= X() proof let x1 be set; assume x1 in U(x);
           then ex xx being Element of X() st x1 = xx & x c= xx;
        hence x1 in X();
       end; then reconsider Ux = U(x) as finite set by FINSET_1:13;
A5: ex k being Nat st R[k]
    proof
     take k = card Ux;
     reconsider x as Element of X() by A3;
     take x; thus Card U(x) = k; thus not P[x] by A4;
   end; consider k being Nat such that
A6: R[k] and
A7: for n being Nat st R[n] holds k <= n from NAT_1:sch 5(A5);
   consider s being Element of X() such that
A8: Card U(s) = k and
A9: not P[s] by A6;
   per cases;
   suppose s is_/\-irreducible_in X();
    hence contradiction by A1,A9;
   end;
   suppose s is_/\-reducible_in X();
    then consider z, y being set such that
   A10: z in X() & y in X() and
   A11: s = z /\ y and
   A12: s <> z & s <> y by Def2;
   A13: s c= z & s c= y by A11,XBOOLE_1:17;
         U(s) c= X() proof let x be set; assume x in U(s);
           then ex xx being Element of X() st x = xx & s c= xx;
        hence x in X();
       end; then reconsider Us = U(s) as finite set by FINSET_1:13;
         U(y) c= X() proof let x be set; assume x in U(y);
           then ex xx being Element of X() st x = xx & y c= xx;
        hence x in X();
       end; then reconsider Uy = U(y) as finite set by FINSET_1:13;
         U(z) c= X() proof let x be set; assume x in U(z);
           then ex xx being Element of X() st x = xx & z c= xx;
        hence x in X();
       end; then reconsider Uz = U(z) as finite set by FINSET_1:13;
       reconsider y, z as Element of X() by A10;
   A14: now assume s in Uz; then ex x being Element of X() st s = x & z c= x;
        hence contradiction by A12,A13,XBOOLE_0:def 10;
       end;
         now assume s in Uy; then ex x being Element of X() st s = x & y c= x
;
        hence contradiction by A12,A13,XBOOLE_0:def 10;
       end;
   then A15: Uz <> Us & Uy <> Us by A14;
   A16: Uz c= Us proof let x be set; assume x in Uz;
           then consider xx being Element of X() such that
       A17: x = xx and
       A18: z c= xx;
             s c= xx by A13,A18,XBOOLE_1:1;
         hence x in Us by A17;
        end;
         Uy c= Us proof let x be set; assume x in Uy;
           then consider xx being Element of X() such that
       A19: x = xx and
       A20: y c= xx; s c= xx by A13,A20,XBOOLE_1:1;
         hence x in Us by A19;
        end; then Uz c< Us & Uy c< Us by A15,A16,XBOOLE_0:def 8;
       then card Us > card Uz & card Us > card Uy by TREES_1:24;
       then P[z] & P[y] by A7,A8;
    hence contradiction by A2,A9,A11;
end;
end;

theorem :: ARMSTRNG:3
for X being non empty finite set, x being Element of X
 ex A being non empty Subset of X
  st x = meet A & for s being set st s in A holds s is_/\-irreducible_in X;

definition
  let X be set, B be Subset-Family of X;
  attr B is (B1) means
:: ARMSTRNG:def 4

  X in B;
end;


notation
  let B be set;
  synonym B is (B2) for B is cap-closed;
  end;


registration
  let X be set;
  cluster (B1) (B2) Subset-Family of X;
  existence proof set B = {X}; {X} c= bool X by ZFMISC_1:80;
    then reconsider B as Subset-Family of X by SETFAM_1:def 7;
   take B;
     X in B by TARSKI:def 1;
   hence B is (B1) by Def4;
   thus B is (B2) proof let a, b be set; assume a in B & b in B;
     then a = X & b = X by TARSKI:def 1;
    hence a/\b in B by TARSKI:def 1;
   end;
  end;
end;


theorem :: ARMSTRNG:4
for X being set, B being non empty Subset-Family of X st B is cap-closed
for x being Element of B st x is_/\-irreducible_in B & x <> X
for S being finite Subset-Family of X st S c= B & x = Intersect S holds x in S;

registration
  let X, D be non empty set, n be Nat;
  cluster -> FinSequence-yielding Function of X, n-tuples_on D;
  coherence proof let f be Function of X, n-tuples_on D;
   let x be set; assume x in dom f;
     then reconsider fx = f.x as Element of n-tuples_on D by FUNCT_2:7; fx =
f
.x;
   hence f.x is FinSequence;
  end;
end;


registration
 let f be FinSequence-yielding Function, x be set;
 cluster f.x -> FinSequence-like;
 coherence proof
 per cases;
  suppose x in dom f; hence thesis by MATRLIN:def 1;
  end;
  suppose not x in dom f;
   hence thesis by FUNCT_1:def 4;
 end;
 end;
end;


definition
  :: cannot redefine from VALUAT for I need to use functions from
  :: BINARI* and they are on Tuple of
 let n be Nat, p, q be Tuple of n, BOOLEAN;
 func p '&' q -> Tuple of n, BOOLEAN means
:: ARMSTRNG:def 5
 for i being set st i in Seg n holds it.i = (p/.i) '&' (q/.i);
 commutativity;
end;


theorem :: ARMSTRNG:5
for n being Nat, p being Tuple of n, BOOLEAN
 holds (n-BinarySequence 0) '&' p = n-BinarySequence 0;

theorem :: ARMSTRNG:6 :: band2:
  for n being Nat, p being Tuple of n, BOOLEAN
 holds 'not' (n-BinarySequence 0) '&' p = p;

theorem :: ARMSTRNG:7  :: BINARI_3:29 generalized
for i being Nat holds (i+1)-BinarySequence 2 to_power i= 0*i^<*1*>;

theorem :: ARMSTRNG:8
for n, i being Nat st i < n
 holds (n-BinarySequence 2 to_power i).(i+1) = 1 &
       for j being Nat st j in Seg n & j<>i+1
        holds (n-BinarySequence 2 to_power i).j = 0;

begin :: 2. The relational model of data

definition
 struct DB-Rel (#
   Attributes -> finite non empty set,
   Domains -> non-empty ManySortedSet of the Attributes,
   Relationship -> Subset of product the Domains
 #);
end;


begin :: 3. Dependency structures

definition
  let X be set;
  mode Subset-Relation of X is Relation of bool X;
  mode Dependency-set of X is Relation of bool X;
  canceled;
end;


registration
  let X be set;
  cluster non empty finite Dependency-set of X;
  existence proof {} c= X by XBOOLE_1:2;
   then reconsider R = {[{},{}]} as Relation of bool X by RELSET_1:8;
   take R; thus R is non empty; thus R is finite;
  end;
end;


definition
  let X be set;
  func Dependencies(X) -> Dependency-set of X equals
:: ARMSTRNG:def 7

   [: bool X, bool X :];
end;


definition
  let X be set;
  mode Dependency of X is Element of Dependencies X;
end;
registration
  let X be set;
  cluster Dependencies X -> non empty;
  coherence proof Dependencies X = [: bool X, bool X :] by Def7; hence thesis
;
  end;

  end;


definition
  let X be set, F be non empty Dependency-set of X;
  redefine mode Element of F -> Dependency of X;
end;


theorem :: ARMSTRNG:9
for X, x being set
 holds x in Dependencies X iff ex a, b being Subset of X st x = [a,b];

theorem :: ARMSTRNG:10
for X, x being set, F being Dependency-set of X
 holds x in F implies ex a, b being Subset of X st x = [a,b];

theorem :: ARMSTRNG:11
for X being set, F being Dependency-set of X, S being Subset of F
 holds S is Dependency-set of X;

definition
  let R be DB-Rel, A, B be Subset of the Attributes of R;
  pred A >|> B, R means
:: ARMSTRNG:def 8
  for f, g being Element of the Relationship of R st f|A = g|A holds f|B = g|B;
  end;
notation
  let R be DB-Rel, A, B be Subset of the Attributes of R;
  synonym A, B holds_in R for A >|> B, R ; end;


definition
 let R be DB-Rel;
 func Dependency-str R -> Dependency-set of the Attributes of R equals
:: ARMSTRNG:def 9
 { [A, B] where A, B is Subset of the Attributes of R: A >|> B, R };
end;


theorem :: ARMSTRNG:12
for R being DB-Rel, A, B being Subset of the Attributes of R
 holds [A, B] in Dependency-str R iff A >|> B, R;

begin :: 4. Full families of dependencies

definition
  let X be set, P, Q be Dependency of X;
  pred P >= Q means
:: ARMSTRNG:def 10

   P`1 c= Q`1 & Q`2 c= P`2;
  reflexivity;
  end;
notation
  let X be set, P, Q be Dependency of X;
  synonym Q <= P for P >= Q ; synonym P is_at_least_as_informative_as Q for
 P >= Q ; end;


theorem :: ARMSTRNG:13  :: antisymmetry
for X being set, P, Q being Dependency of X st P <= Q & Q <= P holds P = Q;

theorem :: ARMSTRNG:14  :: transitivity
for X being set, P, Q, S being Dependency of X st P <= Q & Q <= S holds P <= S;

definition
  let X be set, A, B be Subset of X;
  redefine func [A, B] -> Dependency of X;
end;


theorem :: ARMSTRNG:15
for X being set, A, B, A', B' being Subset of X
 holds [A,B] >= [A',B'] iff A c= A' & B' c= B;

definition
  let X be set;
  func Dependencies-Order X -> Relation of Dependencies X equals
:: ARMSTRNG:def 11
   { [P, Q] where P, Q is Dependency of X : P <= Q };
end;


theorem :: ARMSTRNG:16
for X, x being set
 holds x in Dependencies-Order X
   iff ex P, Q being Dependency of X st x = [P, Q] & P <= Q;

theorem :: ARMSTRNG:17
for X being set holds dom Dependencies-Order X = [: bool X, bool X :];

theorem :: ARMSTRNG:18
for X being set holds rng Dependencies-Order X = [: bool X, bool X :];

theorem :: ARMSTRNG:19
for X being set holds field Dependencies-Order X = [: bool X, bool X :];

registration
  let X be set;
  cluster Dependencies-Order X -> non empty;
  coherence proof dom Dependencies-Order X = [:bool X, bool X:] by Th17;
   hence thesis by RELAT_1:60;
  end;

  cluster Dependencies-Order X
      -> total reflexive antisymmetric transitive;
  coherence proof set dox = Dependencies-Order X; set dx = Dependencies X;
A1: dox = { [E, F] where E, F is Element of dx : E <= F } by Def11;
    dx c= dom dox
    proof let x be set; assume x in dx;
      then reconsider x' = x as Element of dx; x' <= x';
      then [x,x] in dox by A1;
     hence thesis by RELAT_1:def 4;
    end;
    then
A2: dom dox = dx by XBOOLE_0:def 10;
   then
A3: field dox = dx \/ rng dox by RELAT_1:def 6
       .= dx by XBOOLE_1:12;
   thus dox is total by A2,PARTFUN1:def 4;
   dox is_reflexive_in dx
    proof let x be set; assume x in dx;
      then reconsider x' = x as Element of dx; x' <= x';
     hence [x,x] in dox by A1;
    end;
  hence dox is reflexive by A3,RELAT_2:def 9;
   dox is_antisymmetric_in dx proof let x, y be set; assume that
        x in dx & y in dx and
  A4: [x,y] in dox & [y,x] in dox;
      consider x', y' being Element of dx such that
  A5: [x,y]=[x',y'] & x' <= y' by A1,A4;
      consider y'', x'' being Element of dx such that
  A6: [y,x]=[y'',x''] & y'' <= x'' by A1,A4;
        x = x' & x = x'' & y = y' & y = y'' by A5,A6,ZFMISC_1:33;
   hence x = y by A5,A6,Th13;
  end;
  hence dox is antisymmetric by A3,RELAT_2:def 12;
   dox is_transitive_in dx proof let x, y, z be set; assume that
       x in dx & y in dx & z in dx and
  A7: [x,y] in dox & [y,z] in dox;
      consider x', y' being Element of dx such that
  A8: [x,y]=[x',y'] & x' <= y' by A1,A7;
      consider y'', z' being Element of dx such that
  A9: [y,z]=[y'',z'] & y'' <= z' by A1,A7;
  A10: x = x' & y = y' & y = y'' & z = z' by A8,A9,ZFMISC_1:33;
      then x' <= z' by A8,A9,Th14;
   hence [x,z] in dox by A1,A10;
  end;
   hence dox is transitive by A3,RELAT_2:def 16;
  end;
end;

notation
  let X be set, F be Dependency-set of X;
  synonym F is (F2) for F is transitive;
  synonym F is (DC1) for F is transitive;
  end;

definition
  let X be set, F be Dependency-set of X;
  attr F is (F1) means
:: ARMSTRNG:def 12

   for A being Subset of X holds [A, A] in F;
end;

notation
  let X be set, F be Dependency-set of X;
  synonym F is (DC2) for F is (F1) ; end;

theorem :: ARMSTRNG:20
for X being set, F being Dependency-set of X
 holds F is (F2) iff
   for A, B, C being Subset of X st [A, B] in F & [B, C] in F holds [A, C] in F
;

definition
  let X be set, F be Dependency-set of X;
  attr F is (F3) means
:: ARMSTRNG:def 13

  for A, B, A', B' being Subset of X
   st [A, B] in F & [A, B] >= [A', B'] holds [A', B'] in F;
  attr F is (F4) means
:: ARMSTRNG:def 14

  for A, B, A', B' being Subset of X
   st [A, B] in F & [A', B'] in F holds [A\/A', B\/B'] in F;
end;


theorem :: ARMSTRNG:21
for X being set holds Dependencies X is (F1) (F2) (F3) (F4);

registration
  let X be set;
  cluster (F1) (F2) (F3) (F4) non empty Dependency-set of X;
  existence proof take Dependencies X; thus thesis by Th21; end;
end;


definition
  let X be set, F be Dependency-set of X;
  attr F is full_family means
:: ARMSTRNG:def 15

   F is (F1) (F2) (F3) (F4);
end;


registration
  let X be set;
  cluster full_family Dependency-set of X;
  existence proof
   consider D being (F1) (F2) (F3) (F4) non empty Dependency-set of X;
   take D; thus thesis by Def15;
  end;
end;


definition
  let X be set;
  mode Full-family of X is full_family Dependency-set of X;
end;


theorem :: ARMSTRNG:22
for X being finite set, F being Dependency-set of X holds F is finite;

registration
  let X be finite set;
  cluster finite Full-family of X;
  existence proof
   consider D being (F1) (F2) (F3) (F4) non empty Dependency-set of X;
   reconsider D as Full-family of X by Def15;
   take D; bool X is finite by FINSET_1:24;
           then [:bool X, bool X:] is finite by FINSET_1:19;
   hence thesis by FINSET_1:13;
  end;

  cluster -> finite Dependency-set of X;
  coherence by Th22;
end;



registration
  let X be set;
  cluster full_family -> (F1) (F2) (F3) (F4) Dependency-set of X;
  coherence by Def15;
  cluster (F1) (F2) (F3) (F4) -> full_family Dependency-set of X;
  correctness by Def15;
end;


definition
  let X be set, F be Dependency-set of X;
  attr F is (DC3) means
:: ARMSTRNG:def 16

   for A, B being Subset of X st B c= A holds [A, B] in F;
end;


registration
 let X be set;
 cluster (F1) (F3) -> (DC3) Dependency-set of X;
 coherence proof let F be Dependency-set of X; assume
 A1: F is (F1) (F3);
  let A, B being Subset of X such that
 A2: B c= A;
 A3: [A, A] in F by A1,Def12;
     [A, A] >= [A, B] by A2,Th15;
  hence [A, B] in F by A1,A3,Def13;
 end;
 cluster (DC3) (F2) -> (F1) (F3) Dependency-set of X;
 coherence proof let F be Dependency-set of X; assume
 A4: F is (DC3) (F2);
  thus F is (F1) proof let A be Subset of X; thus [A, A] in F by A4,Def16
; end;
  let A, B, A', B' be Subset of X; assume
 A5: [A, B] in F; assume
     [A, B] >= [A', B']; then A c= A' & B' c= B by Th15;
   then [A', A] in F & [B, B'] in F by A4,Def16;
   then [A', B] in F & [B, B'] in F by A4,A5,Th20;
  hence [A', B'] in F by A4,Th20;
 end;
end;


registration
 let X be set;
 cluster (DC3) (F2) (F4) non empty Dependency-set of X;
 existence proof
  consider D being (F1) (F3) (F2) (F4) non empty Dependency-set of X;
  take D; thus thesis;
 end;
end;


theorem :: ARMSTRNG:23  ::  F13_2_1_3:
for X being set, F being Dependency-set of X
 st F is (DC3) (F2) holds F is (F1) (F3);

theorem :: ARMSTRNG:24  ::  F1_3_13:
for X being set, F being Dependency-set of X st F is (F1) (F3) holds F is (DC3)
;

registration
  let X be set;
  cluster (F1) -> non empty Dependency-set of X;
  coherence by Def12;
end;


theorem :: ARMSTRNG:25  ::  WWA1:
for R being DB-Rel holds Dependency-str R is full_family;

theorem :: ARMSTRNG:26  :: Ex1:
  for X being set, K being Subset of X holds
 { [A, B] where A, B is Subset of X : K c= A or B c= A } is Full-family of X;

begin :: 5. Maximal elements of full families

definition
  let X be set, F be Dependency-set of X;
  func Maximal_wrt F -> Dependency-set of X equals
:: ARMSTRNG:def 17
  Dependencies-Order X Maximal_in F;
end;


theorem :: ARMSTRNG:27
for X being set, F being Dependency-set of X holds Maximal_wrt F c= F;

definition
  let X be set, F be Dependency-set of X, x, y be set;
  pred x ^|^ y, F means
:: ARMSTRNG:def 18
   [x, y] in Maximal_wrt F;
end;


theorem :: ARMSTRNG:28
for X being finite set, P being Dependency of X, F being Dependency-set of X
 st P in F
  ex A, B being Subset of X st [A, B] in Maximal_wrt F & [A, B] >= P;

theorem :: ARMSTRNG:29
for X being set, F being Dependency-set of X, A, B being Subset of X
 holds A ^|^ B, F
   iff [A, B] in F &
       not ex A', B' being Subset of X
            st [A', B'] in F & (A <> A' or B <> B') & [A, B] <= [A', B'];

definition
  let X be set, M be Dependency-set of X;
 attr M is (M1) means
:: ARMSTRNG:def 19

 for A being Subset of X
  ex A', B' being Subset of X st [A', B'] >= [A, A] & [A', B'] in M;
 attr M is (M2) means
:: ARMSTRNG:def 20

 for A, B, A', B' being Subset of X
  st [A, B] in M & [A', B'] in M & [A, B] >= [A', B'] holds A = A' & B = B';
 attr M is (M3) means
:: ARMSTRNG:def 21

 for A, B, A', B' being Subset of X
  st [A, B] in M & [A', B'] in M & A' c= B holds B' c= B;
end;


theorem :: ARMSTRNG:30  ::  WWA2:
for X being finite non empty set, F being Full-family of X
 holds Maximal_wrt F is (M1) (M2) (M3);

theorem :: ARMSTRNG:31  :: WWA2a check this proof, WWA is sketchy
for X being finite set, M, F being Dependency-set of X
 st M is (M1) (M2) (M3) &
    F = {[A, B] where A, B is Subset of X :
            ex A', B' being Subset of X st [A', B'] >= [A, B] & [A', B'] in M}
  holds M = Maximal_wrt F & F is full_family &
   for G being Full-family of X st M = Maximal_wrt G holds G = F;

registration
  let X be non empty finite set, F be Full-family of X;
  cluster Maximal_wrt F -> non empty;
  coherence proof set M = Maximal_wrt F; M is (M1) by Th30;
    then ex A',B' being Subset of X st [A', B']>=[[#]X, [#]X]&[A', B'] in M
by Def19
;
   hence thesis;
  end;
end;


theorem :: ARMSTRNG:32  ::  Ex2:
for X being finite set, F being Dependency-set of X, K being Subset of X
 st F = { [A, B] where A, B is Subset of X : K c= A or B c= A }
  holds {[K, X]}\/{[A, A] where A is Subset of X : not K c= A}
      = Maximal_wrt F;

begin :: 6. Saturated subsets of Attributes

definition
  let X be set, F be Dependency-set of X;
  func saturated-subsets F -> Subset-Family of X equals
:: ARMSTRNG:def 22

  { B where B is Subset of X: ex A being Subset of X st A ^|^ B, F };
 end;
notation
  let X be set, F be Dependency-set of X;
  synonym closed_attribute_subset F for saturated-subsets F ; end;


registration
  let X be set, F be finite Dependency-set of X;
  cluster saturated-subsets F -> finite;
  coherence proof
  set ss = {B where B is Subset of X: ex A being Subset of X st A ^|^ B, F };
A1: saturated-subsets F = ss by Def22;
  defpred P[set,set] means
  ex a,b being set st $1 = [a,b] & $2 = [a,b]`2;
A2: for x,y1,y2 being set st x in F & P[x,y1] & P[x,y2] holds y1 = y2;
A3: for x being set st x in F ex y being set st P[x,y] proof
     let x be set; assume x in F;
        then consider a, b being Subset of X such that
    A4: x = [a,b] by Th10;
        reconsider a, b as set;
     take b; take a, b; thus x = [a,b] & b = [a,b]`2 by A4,MCART_1:def 2;
    end;
  consider f being Function such that
A5: dom f = F and
A6: for x being set st x in F holds P[x,f.x] from FUNCT_1:sch 2(A2,A3);
A7: rng f is finite by A5,FINSET_1:26;
     ss c= rng f proof let x be set; assume x in ss;
      then consider B being Subset of X such that
   A8: x = B and
   A9: ex A being Subset of X st A ^|^ B, F;
       consider A being Subset of X such that
   A10: A ^|^ B, F by A9;
   A11: Maximal_wrt F c= F by Th27;
   A12: [A, B] in Maximal_wrt F by A10,Def18;
       then consider a,b being set such that
   A13: [A,B] = [a,b] & f.[A,B] = [a,b]`2 by A6,A11;
         f.[A,B] = B by A13,MCART_1:def 2;
     hence x in rng f by A5,A8,A11,A12,FUNCT_1:12;
   end;
   hence saturated-subsets F is finite by A1,A7,FINSET_1:13;
 end;
end;


theorem :: ARMSTRNG:33
for X, x being set, F being Dependency-set of X
 holds x in saturated-subsets F
   iff ex B, A being Subset of X st x = B & A ^|^ B, F;

theorem :: ARMSTRNG:34  ::  WWA3:
for X being finite non empty set, F being Full-family of X
 holds saturated-subsets F is (B1) (B2);

definition
 let X be set, B be set;
 func X deps_encl_by B -> Dependency-set of X equals
:: ARMSTRNG:def 23
  { [a, b] where a, b is Subset of X :
                 for c being set st c in B & a c= c holds b c= c};
end;


theorem :: ARMSTRNG:35  ::  WWA3_0:
for X being set, B being Subset-Family of X, F being Dependency-set of X
  holds X deps_encl_by B is full_family;

theorem :: ARMSTRNG:36  ::  WWA3_00:
for X being finite non empty set, B being Subset-Family of X
 holds B c= saturated-subsets (X deps_encl_by B);

theorem :: ARMSTRNG:37  ::  WWA3a:
for X being finite non empty set, B being Subset-Family of X
 st B is (B1) (B2)
  holds B = saturated-subsets (X deps_encl_by B) &
        for G being Full-family of X
         st B = saturated-subsets G holds G = X deps_encl_by B;

definition
  let X be set, F be Dependency-set of X;
  func enclosure_of F -> Subset-Family of X equals
:: ARMSTRNG:def 24

   { b where b is Subset of X :
           for A, B being Subset of X st [A, B] in F & A c= b holds B c= b };
end;


theorem :: ARMSTRNG:38  ::  WWA3c:
for X being finite non empty set, F being Dependency-set of X
  holds enclosure_of F is (B1) (B2);

theorem :: ARMSTRNG:39   :: WWA3b
:: Added for proving WWA7 where it is referenced but never
:: stated.  This characterizes the smallest full family
:: containing a given dependency set
for X being finite non empty set, F being Dependency-set of X
  holds F c= X deps_encl_by enclosure_of F &
        for G being Dependency-set of X st F c= G & G is full_family
         holds X deps_encl_by enclosure_of F c= G;

definition
 let X be finite non empty set, F be Dependency-set of X;
 func Dependency-closure F -> Full-family of X means
:: ARMSTRNG:def 25

  F c= it &
  for G being Dependency-set of X st F c= G & G is full_family holds it c= G;
end;


theorem :: ARMSTRNG:40  ::  WWA3d:
for X being finite non empty set, F being Dependency-set of X
 holds Dependency-closure F = X deps_encl_by enclosure_of F;

theorem :: ARMSTRNG:41  ::  Ex3:
for X being set, K being Subset of X, B being Subset-Family of X
 st B = {X}\/{A where A is Subset of X : not K c= A} holds B is (B1) (B2);

theorem :: ARMSTRNG:42  :: Ex3a:
:: use WWA3* to prove what is the saturated subset for the example
  for X being finite non empty set, F being Dependency-set of X,
    K being Subset of X
 st F = { [A, B] where A, B is Subset of X : K c= A or B c= A }
  holds {X}\/{B where B is Subset of X : not K c= B} = saturated-subsets F;

theorem :: ARMSTRNG:43  :: Ex3b:
  for X being finite set, F being Dependency-set of X, K being Subset of X
 st F = { [A, B] where A, B is Subset of X : K c= A or B c= A }
  holds {X}\/{B where B is Subset of X : not K c= B} = saturated-subsets F;

definition
  let X, G be set, B be Subset-Family of X;
  pred G is_generator-set_of B means
:: ARMSTRNG:def 26

  G c= B & B = { Intersect S where S is Subset-Family of X: S c= G };
end;


theorem :: ARMSTRNG:44  :: WWA4b:
  for X be finite non empty set, G being Subset-Family of X
 holds G is_generator-set_of saturated-subsets (X deps_encl_by G);

theorem :: ARMSTRNG:45  ::  WWA4a:
for X being finite non empty set, F being Full-family of X
 ex G being Subset-Family of X
  st G is_generator-set_of saturated-subsets F & F = X deps_encl_by G;

:: WWA did not show what generators B are,
:: they are the irreducible elements \ X

theorem :: ARMSTRNG:46
  for X being set, B being non empty finite Subset-Family of X
 st B is (B1) (B2) holds /\-IRR B is_generator-set_of B;

theorem :: ARMSTRNG:47
  for X, G being set, B being non empty finite Subset-Family of X
 st B is (B1) (B2) & G is_generator-set_of B holds /\-IRR B c= G\/{X};

begin :: 7. Justification of the axioms

theorem :: ARMSTRNG:48  :: WWA5:
  for X being non empty finite set, F being Full-family of X
 ex R being DB-Rel
  st the Attributes of R = X &
     (for a being Element of X holds (the Domains of R).a = INT) &
     F = Dependency-str R;

begin

definition
  let X be set, F be Dependency-set of X;
  func candidate-keys F -> Subset-Family of X equals
:: ARMSTRNG:def 27

   { A where A is Subset of X : [A, X] in Maximal_wrt F };
end;


theorem :: ARMSTRNG:49  :: Ex8:
  for X being finite set, F being Dependency-set of X, K being Subset of X
 st F = { [A, B] where A, B is Subset of X : K c= A or B c= A }
  holds candidate-keys F = {K};

notation
  let X be set;
  antonym X is (C1) for X is empty;
  end;


definition
  let X be set;
  attr X is without_proper_subsets means
:: ARMSTRNG:def 28

   for x, y being set st x in X & y in X & x c= y holds x = y;
  end;
notation
  let X be set;
  synonym X is (C2) for X is without_proper_subsets ; end;


theorem :: ARMSTRNG:50  :: WWA6:
  for R being DB-Rel holds candidate-keys Dependency-str R is (C1) (C2);

theorem :: ARMSTRNG:51  :: WWA6a:
  for X being finite set, C being Subset-Family of X st C is (C1) (C2)
  ex F being Full-family of X st C = candidate-keys F;

theorem :: ARMSTRNG:52  :: WWA6a A more reasonable version
  for X being finite set, C being Subset-Family of X, B being set
 st C is (C1) (C2) &
    B = {b where b is Subset of X :
           for K being Subset of X st K in C holds not K c= b}
  holds C = candidate-keys (X deps_encl_by B);

theorem :: ARMSTRNG:53  :: WWA6a proof II
  for X being non empty finite set, C being Subset-Family of X st C is (C1)
(C2)
 ex R being DB-Rel
  st the Attributes of R = X & C = candidate-keys Dependency-str R;

begin :: 9. Applications

definition
  let X be set, F be Dependency-set of X;
  attr F is (DC4) means
:: ARMSTRNG:def 29

   for A, B, C being Subset of X st [A, B] in F & [A, C] in F
    holds [A, B\/C] in F;
  attr F is (DC5) means
:: ARMSTRNG:def 30

   for A, B, C, D being Subset of X st [A, B] in F & [B\/C, D] in F
    holds [A\/C, D] in F;
  attr F is (DC6) means
:: ARMSTRNG:def 31

   for A, B, C being Subset of X st [A, B] in F holds [A\/C, B] in F;
end;


theorem :: ARMSTRNG:54  :: APP0:
  for X being set, F being Dependency-set of X
 holds F is (F1) (F2) (F3) (F4) iff F is (F2) (DC3) (F4);

theorem :: ARMSTRNG:55  :: APP1:
  for X being set, F being Dependency-set of X
 holds F is (F1) (F2) (F3) (F4) iff F is (DC1) (DC3) (DC4);

theorem :: ARMSTRNG:56  :: APP2:
  for X being set, F being Dependency-set of X
 holds F is (F1) (F2) (F3) (F4) iff F is (DC2) (DC5) (DC6);

definition
  let X be set, F be Dependency-set of X;
  func charact_set F equals
:: ARMSTRNG:def 32

   { A where A is Subset of X :
       ex a, b being Subset of X st [a, b] in F & a c= A & not b c= A };
end;


theorem :: ARMSTRNG:57
for X, A being set, F being Dependency-set of X st A in charact_set F
 holds A is Subset of X &
       ex a, b being Subset of X st [a, b] in F & a c= A & not b c= A;

theorem :: ARMSTRNG:58
for X being set, A being Subset of X, F being Dependency-set of X
 st ex a, b being Subset of X st [a, b] in F & a c= A & not b c= A
  holds A in charact_set F;

theorem :: ARMSTRNG:59    ::  WWA7:
for X being finite non empty set, F being Dependency-set of X
 holds
   (for A, B being Subset of X holds [A, B] in Dependency-closure F iff
     for a being Subset of X st A c= a & not B c= a holds a in charact_set F)
 & saturated-subsets Dependency-closure F = (bool X) \ charact_set F;

theorem :: ARMSTRNG:60  :: WWACorA: :: Bill: Is this the right translation
  for X being finite non empty set, F, G being Dependency-set of X
 st charact_set F = charact_set G
  holds Dependency-closure F = Dependency-closure G;

theorem :: ARMSTRNG:61
for X being non empty finite set, F being Dependency-set of X
 holds charact_set F = charact_set (Dependency-closure F);

definition
  let A be set, K be set, F be Dependency-set of A;
  pred K is_p_i_w_ncv_of F means
:: ARMSTRNG:def 33

  (for a being Subset of A st K c= a & a <> A holds a in charact_set F) &
  for k being set st k c< K
    ex a being Subset of A st k c= a & a <> A & not a in charact_set F;
end;


theorem :: ARMSTRNG:62  :: WWACorB:
  for X being finite non empty set, F being Dependency-set of X,
    K being Subset of X
 holds K in candidate-keys Dependency-closure F iff K is_p_i_w_ncv_of F;
