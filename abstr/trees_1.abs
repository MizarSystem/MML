:: Introduction to Trees
::  by Grzegorz Bancerek
::
:: Received October 25, 1989
:: Copyright (c) 1990 Association of Mizar Users

environ

 vocabulary FUNCT_1, FINSEQ_1, RELAT_1, BOOLE, ARYTM_1, FINSET_1, CARD_1,
      ZFMISC_1, TARSKI, ORDINAL2, TREES_1;
 notation TARSKI, XBOOLE_0, SUBSET_1, XCMPLX_0, XREAL_0, NAT_1, NUMBERS,
      ORDINAL2, RELAT_1, FUNCT_1, FINSEQ_1, FINSET_1, CARD_1;
 constructors REAL_1, NAT_1, FINSEQ_1, WELLORD2, XREAL_0, MEMBERED, XBOOLE_0;
 clusters RELSET_1, FINSEQ_1, CARD_1, FINSET_1, NAT_1, XREAL_0, MEMBERED,
      ZFMISC_1, XBOOLE_0, NUMBERS, ORDINAL2;
 requirements NUMERALS, REAL, BOOLE, SUBSET, ARITHM;


begin

 reserve D for non empty set,
         X,x,y,z for set,
         k,n,m for Nat,
         f for Function,
         p,q,r for FinSequence of NAT;

::
::  Auxiliary theorems on finite sequence
::

theorem :: TREES_1:1
    for p,q being FinSequence st q = p|Seg n holds len q <= n;

theorem :: TREES_1:2
  for p,q being FinSequence st q = p|Seg n holds len q <= len p;

theorem :: TREES_1:3
  for p,r being FinSequence st r = p|Seg n
      ex q being FinSequence st p = r^q;

theorem :: TREES_1:4
  {} <> <*x*>;

theorem :: TREES_1:5
   for p,q being FinSequence st p = p^q or p = q^p holds q = {};

theorem :: TREES_1:6
  for p,q being FinSequence st p^q = <*x*> holds
   p = <*x*> & q = {} or p = {} & q = <*x*>;

::
:: Relations "is a prefix of", "is a proper prefix of" and
:: "are comparable" of finite sequences
::

notation let p,q be FinSequence;
 synonym p is_a_prefix_of q for p c= q ;
end;
definition let p,q be FinSequence;
 redefine pred p is_a_prefix_of q means
:: TREES_1:def 1
  ex n st p = q|Seg n;
 end;


canceled;

theorem :: TREES_1:8
  for p,q being FinSequence holds p is_a_prefix_of q iff
   ex r being FinSequence st q = p^r;

canceled 6;

theorem :: TREES_1:15
  for p,q being FinSequence st
   p is_a_prefix_of q & len p = len q holds p = q;

theorem :: TREES_1:16
    <*x*> is_a_prefix_of <*y*> iff x = y;

notation let p,q be FinSequence;
 synonym p is_a_proper_prefix_of q for p c< q;
 end;

canceled 2;

theorem :: TREES_1:19
  for p,q being finite set st
   p,q are_c=-comparable & card p = card q holds
       p = q;

 reserve p1,p2,p3 for FinSequence;

canceled 3;

theorem :: TREES_1:23
  <*x*>,<*y*> are_c=-comparable iff x = y;

theorem :: TREES_1:24
  for p,q being finite set st p c< q holds card p < card q;

theorem :: TREES_1:25 :: BOOLE
  not ex p being FinSequence st
   p is_a_proper_prefix_of {} or p is_a_proper_prefix_of <*>D;

theorem :: TREES_1:26 :: BOOLE
   not ex p,q being FinSequence st
   p is_a_proper_prefix_of q & q is_a_proper_prefix_of p;

theorem :: TREES_1:27
    for p,q,r being FinSequence st
   p is_a_proper_prefix_of q & q is_a_proper_prefix_of r or
   p is_a_proper_prefix_of q & q is_a_prefix_of r or
   p is_a_prefix_of q & q is_a_proper_prefix_of r holds
    p is_a_proper_prefix_of r;

theorem :: TREES_1:28 :: BOOLE
  p1 is_a_prefix_of p2 implies not p2 is_a_proper_prefix_of p1;

canceled;

theorem :: TREES_1:30
    p1^<*x*> is_a_prefix_of p2 implies p1 is_a_proper_prefix_of p2;

theorem :: TREES_1:31
  p1 is_a_prefix_of p2 implies p1 is_a_proper_prefix_of p2^<*x*>;

theorem :: TREES_1:32
  p1 is_a_proper_prefix_of p2^<*x*> implies p1 is_a_prefix_of p2;

theorem :: TREES_1:33
    {} is_a_proper_prefix_of p2 or {} <> p2 implies
   p1 is_a_proper_prefix_of p1^p2;

::
:: The set of proper prefixes of a finite sequence
::

definition let p be FinSequence;
 canceled 2;

 func ProperPrefixes p -> set means
:: TREES_1:def 4
  x in
 it iff ex q being FinSequence st x = q & q is_a_proper_prefix_of p;
end;


canceled;

theorem :: TREES_1:35
  for p being FinSequence st x in ProperPrefixes p holds x is FinSequence;

theorem :: TREES_1:36
  for p,q being FinSequence holds
   p in ProperPrefixes q iff p is_a_proper_prefix_of q;

theorem :: TREES_1:37
  for p,q being FinSequence st p in ProperPrefixes q holds len p < len q;

theorem :: TREES_1:38
    for p,q,r being FinSequence st q^r in ProperPrefixes p holds
      q in ProperPrefixes p;

theorem :: TREES_1:39
  ProperPrefixes {} = {};

theorem :: TREES_1:40
  ProperPrefixes <*x*> = { {} };

theorem :: TREES_1:41
    for p,q being FinSequence st p is_a_prefix_of q holds
   ProperPrefixes p c= ProperPrefixes q;

theorem :: TREES_1:42
  for p,q,r being FinSequence st
   q in ProperPrefixes p & r in ProperPrefixes p holds q,r are_c=-comparable;

::
::  Trees and their properties
::

definition let X;
 attr X is Tree-like means
:: TREES_1:def 5
  X c= NAT* & (for p st p in X holds ProperPrefixes p c= X) &
      for p,k,n st p^<*k*> in X & n <= k holds p^<*n*> in X;
end;


registration
 cluster non empty Tree-like set;
  existence
   proof
    take D = { <*>(NAT) };
    thus D is non empty;
    thus D c= NAT*
      proof let x; assume x in D;
        then x = <*>(NAT) by TARSKI:def 1;
       hence thesis by FINSEQ_1:def 11;
      end;
    thus for p st p in D holds ProperPrefixes p c= D
      proof let p; assume p in D;
        then p = <*>(NAT) & <*>(NAT) = {} & ProperPrefixes {} = {} & {} c= D
         by Th39,TARSKI:def 1,XBOOLE_1:2;
       hence thesis;
      end;
    let p,k,n; assume
       p^<*k*> in D;
     then p^<*k*> = {} by TARSKI:def 1;
     then len {} = len p + len <*k*> by FINSEQ_1:35 .= 1 + len p by FINSEQ_1:56
;
    hence thesis by FINSEQ_1:25;
   end;
end;


definition
 mode Tree is Tree-like non empty set;
end;


 reserve T,T1 for Tree;

canceled;

theorem :: TREES_1:44
  x in T implies x is FinSequence of NAT;

definition let T;
 redefine mode Element of T -> FinSequence of NAT;
end;


theorem :: TREES_1:45
  for p,q being FinSequence st p in T & q is_a_prefix_of p holds q in T;

theorem :: TREES_1:46
  for r being FinSequence st q^r in T holds q in T;

theorem :: TREES_1:47
  {} in T & <*> NAT in T;

theorem :: TREES_1:48
  { {} } is Tree;

theorem :: TREES_1:49
  T \/ T1 is Tree;

theorem :: TREES_1:50
  T /\ T1 is Tree;

::
::  Finite trees and their properties
::

registration
 cluster finite Tree;
  existence by Th48;
end;


 reserve fT,fT1 for finite Tree;

canceled;

theorem :: TREES_1:52
    fT \/ fT1 is finite Tree;

theorem :: TREES_1:53
    fT /\ T is finite Tree & T /\ fT is finite Tree;

::
::  Elementary trees
::

definition let n;
 canceled;

 func elementary_tree n -> finite Tree equals
:: TREES_1:def 7
   { <*k*> : k < n } \/ { {} };
end;


canceled;

theorem :: TREES_1:55
   k < n implies <*k*> in elementary_tree n;

theorem :: TREES_1:56
  elementary_tree 0 = { {} };

theorem :: TREES_1:57
    p in elementary_tree n implies p = {} or ex k st k < n & p = <*k*>;

::
::  Leaves and subtrees
::

definition let T;
 func Leaves T -> Subset of T means
:: TREES_1:def 8
    p in it iff p in T & not ex q st q in T & p is_a_proper_prefix_of q;
 let p such that
  p in T;
 func T|p -> Tree means
:: TREES_1:def 9  :: subtree of T, which root is in p
  q in it iff p^q in T;
end;


canceled 2;

theorem :: TREES_1:60
   T|(<*> NAT) = T;

registration let T be finite Tree; let p be Element of T;
 cluster T|p -> finite;
  coherence
   proof
     consider t being Function such that
A1:   rng t = T and
A2:  dom t in omega by FINSET_1:def 1;
     defpred P[set,set] means
      ex q st t.$1 = q & ((ex r st $2 = r & q = p^r) or
      (for r holds q <> p^r) & $2 = <*> NAT);
A3:  for x,y,z st x in dom t & P[x,y] & P[x,z] holds y = z by FINSEQ_1:46;
A4:  for x st x in dom t ex y st P[x,y]
      proof let x; assume x in dom t;
        then t.x in T by A1,FUNCT_1:def 5;
        then reconsider q = t.x as FinSequence of NAT by Th44;
          (ex r st q = p^r) implies thesis;
       hence thesis;
      end;
     consider f being Function such that
A5:   dom f = dom t & for x st x in dom t holds P[x,f.x] from FUNCT_1:sch 2
(A3,A4);
       T|p is finite
      proof take f;
       thus rng f c= T|p
        proof let x; assume x in rng f;
          then consider y such that
A6:        y in dom f & x = f.y by FUNCT_1:def 5;
          consider q such that
A7:        t.y = q & ((ex r st x = r & q = p^r) or
             (for r holds q <> p^r) & x = <*> NAT) by A5,A6;
A8:       p^(<*> NAT) = p by FINSEQ_1:47;
         assume
A9:       not x in T|p;
            q in T & p in T by A1,A5,A6,A7,FUNCT_1:def 5;
         hence contradiction by A7,A8,A9,Def9;
        end;
       thus T|p c= rng f
        proof let x; assume
A10:      x in T|p;
          then reconsider q = x as FinSequence of NAT by Th44;
            p^q in T by A10,Def9;
          then consider y such that
A11:       y in dom t & p^q = t.y by A1,FUNCT_1:def 5;
            P[y,f.y] by A5,A11;
          then x = f.y by A11,FINSEQ_1:46;
         hence x in rng f by A5,A11,FUNCT_1:def 5;
        end;
       thus thesis by A2,A5;
      end;
    hence thesis;
   end;
end;


definition let T;
 assume  Leaves T <> {};
 mode Leaf of T -> Element of T means
:: TREES_1:def 10
    it in Leaves T;
end;


definition let T;
 mode Subtree of T -> Tree means
:: TREES_1:def 11
    ex p being Element of T st it = T|p;
end;


 reserve t for Element of T;

definition let T,p,T1;
 assume
   p in T;
 func T with-replacement (p,T1) -> Tree means
:: TREES_1:def 12
 q in it iff q in T & not p is_a_proper_prefix_of q or
      ex r st r in T1 & q = p^r;
end;


canceled 3;

theorem :: TREES_1:64
  p in T implies T with-replacement (p,T1) =
   { t1 where t1 is Element of T : not p is_a_proper_prefix_of t1 } \/
   { p^s where s is Element of T1 : s = s };

canceled;

theorem :: TREES_1:66
   p in T implies T1 = T with-replacement (p,T1)|p;

registration let T be finite Tree, t be Element of T;
 let T1 be finite Tree;
 cluster T with-replacement (t,T1) -> finite;
  coherence
   proof
       { s where s is Element of T : not t is_a_proper_prefix_of s } c= T
      proof let x; assume
          x in
 { s where s is Element of T : not t is_a_proper_prefix_of s };
        then ex s being Element of T st
     x = s & not t is_a_proper_prefix_of s;
       hence thesis;
      end;
then A1:   { s where s is Element of T : not t is_a_proper_prefix_of s } is
finite
      by FINSET_1:13;
       T1,{ t^s where s is Element of T1 : s = s } are_equipotent
      proof
       defpred P[set,set] means ex q st $1 = q & $2 = t^q;
A2:     x in T1 & P[x,y] & P[x,z] implies y = z;
A3:     x in T1 implies ex y st P[x,y]
         proof assume x in T1;
          then reconsider q = x as FinSequence of NAT by Th44;
             x = q & t^q = t^q;
          hence thesis;
         end;
       consider f such that
A4:      dom f = T1 & for x st x in T1 holds P[x,f.x] from FUNCT_1:sch 2
(A2,A3);
       take f;
       thus f is one-to-one
         proof let x,y; assume
A5:        x in dom f & y in dom f & f.x = f.y;
          then A6: ex q st x = q & f.x = t^q by A4;
             ex r st y = r & f.y = t^r by A4,A5;
          hence thesis by A5,A6,FINSEQ_1:46;
         end;
       thus dom f = T1 by A4;
       thus rng f c= { t^s where s is Element of T1 : s = s }
         proof let x; assume x in rng f;
          then consider y such that
A7:        y in dom f & x = f.y by FUNCT_1:def 5;
          consider q such that
A8:        y = q & f.y = t^q by A4,A7;
          reconsider q as Element of T1 by A4,A7,A8;
             x = t^q by A7,A8;
          hence thesis;
         end;
       let x; assume x in { t^s where s is Element of T1 : s = s };
       then consider s being Element of T1 such that
A9:      x = t^s & s = s;
          P[s,x] & P[s,f.s] by A4,A9;
       hence x in rng f by A4,FUNCT_1:def 5;
      end;
     then { t^s where s is Element of T1 : s = s } is finite by CARD_1:68;
     then t in T & { v where v is Element of T : not t is_a_proper_prefix_of v
} \/
      { t^s where s is Element of T1 : s = s } is finite
       by A1,FINSET_1:14;
    hence thesis by Th64;
   end;
end;


 reserve w for FinSequence;

theorem :: TREES_1:67
  for p being FinSequence holds ProperPrefixes p,dom p are_equipotent;

registration let p be FinSequence;
 cluster ProperPrefixes p -> finite;
 coherence
  proof
     ProperPrefixes p,dom p are_equipotent by Th67;
   then ProperPrefixes p,Seg len p are_equipotent by FINSEQ_1:def 3;
   hence thesis by CARD_1:68;
  end;
end;


theorem :: TREES_1:68
   for p being FinSequence holds card ProperPrefixes p = len p;

::
::  Height and width of finite trees
::

definition let IT be set;
 attr IT is AntiChain_of_Prefixes-like means
:: TREES_1:def 13
  (for x st x in IT holds x is FinSequence) &
  for p1,p2 st p1 in IT & p2 in IT & p1 <> p2 holds
   not p1,p2 are_c=-comparable;
end;


registration
 cluster AntiChain_of_Prefixes-like set;
  existence
   proof
    take {};
    thus for x st x in {} holds x is FinSequence;
    let p1,p2;
    thus thesis;
   end;
end;


definition
 mode AntiChain_of_Prefixes is AntiChain_of_Prefixes-like set;
end;


canceled;

theorem :: TREES_1:70
  { w } is AntiChain_of_Prefixes-like;

theorem :: TREES_1:71
 not p1,p2 are_c=-comparable implies
  { p1,p2 } is AntiChain_of_Prefixes-like;

definition let T;
 mode AntiChain_of_Prefixes of T -> AntiChain_of_Prefixes means
:: TREES_1:def 14
  it c= T;
end;


 reserve t1,t2 for Element of T;

canceled;

theorem :: TREES_1:73
  {} is AntiChain_of_Prefixes of T & { {} } is AntiChain_of_Prefixes of T;

theorem :: TREES_1:74
    { t } is AntiChain_of_Prefixes of T;

theorem :: TREES_1:75
    not t1,t2 are_c=-comparable implies { t1,t2 } is AntiChain_of_Prefixes of T
;

registration let T be finite Tree;
 cluster -> finite AntiChain_of_Prefixes of T;
 coherence
  proof let X be AntiChain_of_Prefixes of T;
      X c= T by Def14;
   hence thesis by FINSET_1:13;
  end;
end;


definition let T be finite Tree;
 func height T -> Nat means
:: TREES_1:def 15
  (ex p st p in T & len p = it) & for p st p in T holds len p <= it;
 func width T -> Nat means
:: TREES_1:def 16
  ex X being AntiChain_of_Prefixes of T st it = card X &
        for Y being AntiChain_of_Prefixes of T holds card Y <= card X;
end;


canceled 2;

theorem :: TREES_1:78
   1 <= width fT;

theorem :: TREES_1:79
   height elementary_tree 0 = 0;

theorem :: TREES_1:80
   height fT = 0 implies fT = elementary_tree 0;

theorem :: TREES_1:81
   height elementary_tree(n+1) = 1;

theorem :: TREES_1:82
   width elementary_tree 0 = 1;

theorem :: TREES_1:83
   width elementary_tree(n+1) = n+1;

theorem :: TREES_1:84
    for t being Element of fT holds height(fT|t) <= height fT;

theorem :: TREES_1:85
  for t being Element of fT st t <> {} holds height(fT|t) < height fT;

scheme :: TREES_1:sch 1
 Tree_Ind { P[Tree] }:
 for fT holds P[fT]
  provided
 for fT st for n st <*n*> in fT holds P[fT|<*n*>] holds P[fT]
proof
    defpred X[set] means for fT holds height fT = $1 implies P[fT];
A2:  for n st for k st k < n holds X[k] holds X[n]
     proof let n such that
A3:    for k st k < n for fT st height fT = k holds P[fT];
      let fT such that
A4:    height fT = n;
         now let k; assume <*k*> in fT;
        then reconsider k' = <*k*> as Element of fT;
           k' <> {} by Th4;
         then height(fT|k') < height fT by Th85;
        hence P[fT|<*k*>] by A3,A4;
       end;
      hence thesis by A1;
     end;
A5:  X[n] from NAT_1:sch 4(A2);
   let fT; height fT = height fT;
   hence thesis by A5;
  end;
