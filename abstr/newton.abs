:: Factorial and Newton coeffitients
::  by Rafa{\l} Kwiatek
::
:: Received July 27, 1990
:: Copyright (c) 1990 Association of Mizar Users

environ

 vocabulary ORDINAL2, ARYTM, FINSEQ_1, ARYTM_3, ARYTM_1, RELAT_1, FUNCT_1,
      BOOLE, FINSEQ_2, GROUP_1, QC_LANG1, RLVECT_1, NEWTON, FINSEQ_4, CARD_3,
      NAT_1, INT_1, ABSVALUE, FILTER_0, NAT_LAT, FINSET_1, CARD_1, TARSKI;
 notation TARSKI, XBOOLE_0, SUBSET_1, ORDINAL1, ORDINAL2, NUMBERS, COMPLEX1,
      XCMPLX_0, XREAL_0, CARD_1, REAL_1, FUNCT_1, FINSET_1, FINSEQ_1, FINSEQ_2,
      FINSEQ_4, INT_1, INT_2, NAT_1, RVSUM_1;
 constructors FINSEQOP, INT_1, REAL_1, NAT_1, RVSUM_1, FINSEQ_4, SEQ_1,
      MEMBERED, XBOOLE_0, BINOP_2, ABSVALUE, INT_2, WELLORD2;
 clusters RELSET_1, FINSEQ_2, INT_1, XREAL_0, NAT_1, MEMBERED, ZFMISC_1,
      XBOOLE_0, ORDINAL2, XCMPLX_0, FINSEQ_1, FINSET_1;
 requirements REAL, NUMERALS, BOOLE, SUBSET, ARITHM;


begin

  reserve i,k,n,m,l for Nat;
  reserve s,t,r for natural number;
  reserve a,b,x,y for real number;
  reserve F,G,H for FinSequence of REAL;

canceled 2;

theorem :: NEWTON:3
 for F,G being FinSequence st
     len F = len G & (for i st i in dom F holds F.i = G.i) holds F = G;

canceled;

theorem :: NEWTON:5
 for n st n>=1 holds Seg n = {1} \/ {k: 1<k & k<n} \/ {n};

theorem :: NEWTON:6
 for F holds len (a*F) = len F;

theorem :: NEWTON:7
 n in dom G iff n in dom (a*G);

::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
::    x |^ n  Function                                                      ::
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

 definition
 let i be natural number; let x be real number;
 redefine func i |-> x -> FinSequence of REAL;
end;

definition
  let x be real number; let n be natural number;
  func x|^n equals
:: NEWTON:def 1
Product(n |-> x);
end;

registration
  let x be real number; let n be natural number;
  cluster x|^n -> real;
end;

definition
  let x be Real; let n be natural number;
  redefine func x|^n -> Real;
end;

canceled;

theorem :: NEWTON:9
 x|^0 = 1;

theorem :: NEWTON:10
 x|^1 = x;

theorem :: NEWTON:11
 x|^(s+1) = x|^s*x;

registration
  let x, n be natural number;
  cluster x|^n -> natural;
end;

theorem :: NEWTON:12
    (x*y)|^s = x|^s * y|^s;

theorem :: NEWTON:13
    x|^(s+t) = x|^s * x|^t;

theorem :: NEWTON:14
    (x|^s)|^t = x|^(s*t);

theorem :: NEWTON:15
 1|^s = 1;

theorem :: NEWTON:16
   s >= 1 implies 0|^s = 0;

::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
::     n!  Function                                                         ::
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

definition let n be natural number;
 redefine func idseq n -> FinSequence of REAL;
end;

definition
  let n be natural number;
  func n! equals
:: NEWTON:def 2
Product(idseq n);
end;

registration
  let n be natural number;
  cluster n! -> real;
end;

definition
  let n be natural number;
  redefine func n! -> Real;
end;

canceled;

theorem :: NEWTON:18
 0! = 1;

theorem :: NEWTON:19
    1! = 1;

theorem :: NEWTON:20
    2! = 2;

theorem :: NEWTON:21
 for s holds (s+1)! = (s!) * (s+1);

theorem :: NEWTON:22
    for s holds s! is Nat;

theorem :: NEWTON:23
 for s holds s!>0;

canceled;

theorem :: NEWTON:25
 for s,t holds (s!) * (t!)<>0;

::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
::     n choose k  Function                                                 ::
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

definition
 let k,n be natural number;
 func n choose k means
:: NEWTON:def 3
    for l be natural number st l = n-k holds
     it = (n!)/((k!) * (l!)) if n >= k
  otherwise it = 0;
end;

registration
 let k,n be natural number;
 cluster n choose k -> real;
end;

definition
 let k,n be natural number;
 redefine func n choose k -> Real;
end;

canceled;

theorem :: NEWTON:27
 0 choose 0 = 1;

canceled;

theorem :: NEWTON:29
 for s holds (s choose 0) = 1;

theorem :: NEWTON:30
 for s,t st s>=t holds
       (for r st r = s-t holds (s choose t) = (s choose r));

theorem :: NEWTON:31
 for s holds s choose s = 1;

theorem :: NEWTON:32
 for s,t st s<t holds
        (((t+1) choose (s+1)) = (t choose (s+1)) + (t choose s)
        & ((t+1) choose (s+1)) = (t choose s) + (t choose (s+1)));

theorem :: NEWTON:33
 for s st s >= 1 holds s choose 1 = s;

theorem :: NEWTON:34
    for s,t st s>=1 & t = s-1 holds s choose t = s;

theorem :: NEWTON:35
    for s holds (for r holds (s choose r) is Nat);

theorem :: NEWTON:36
    for m,F st m <> 0 & len F = m & (for i,l st i in dom F & l = n+i-1
      holds F.i = l choose n) holds Sum F = (n+m) choose (n+1);

definition
let a,b be real number;
let n be natural number;
func (a,b) In_Power n -> FinSequence of REAL means
:: NEWTON:def 4
   len it = n+1 &
   (for i,l,m being natural number st i in dom it & m = i - 1 & l = n-m holds
   it.i = (n choose m)* a|^l * b|^m);
end;

canceled;

theorem :: NEWTON:38
 (a,b) In_Power 0 = <*1*>;

theorem :: NEWTON:39
 ((a,b) In_Power s).1 = a|^s;

theorem :: NEWTON:40
 ((a,b) In_Power s).(s+1) = b|^s;

theorem :: NEWTON:41
 for s holds (a+b)|^s = Sum((a,b) In_Power s);

definition let n be natural number;
func Newton_Coeff n -> FinSequence of REAL means
:: NEWTON:def 5
len it = n+1 &
 (for i,k be natural number st i in dom it & k = i-1 holds it.i = n choose k);
end;

canceled;

theorem :: NEWTON:43
 for s holds Newton_Coeff s = (1,1) In_Power s;

theorem :: NEWTON:44
    for s holds 2|^s = Sum(Newton_Coeff s);

begin :: Addenda

:: from NAT_LAT

theorem :: NEWTON:45
  l >= 1 implies k*l>=k;

theorem :: NEWTON:46
 l >= 1 & n >= k*l implies n>=k;

definition let n;
 redefine func n! -> Nat;
end;

theorem :: NEWTON:47
 l <> 0 implies l divides l!;

theorem :: NEWTON:48
    n <> 0 implies (n+1)/n > 1;

theorem :: NEWTON:49
  k/(k+1) < 1;

theorem :: NEWTON:50
  for l being Nat holds l! >= l;

reserve t,s,j,r for Nat;

theorem :: NEWTON:51
  for m,n st m<>1 holds m divides n implies not m divides (n+1);

theorem :: NEWTON:52
     j divides l & j divides l+1 iff j=1;

theorem :: NEWTON:53
 for k,j st j<>0 holds j divides (j+k)!;

theorem :: NEWTON:54
  j<=l & j<>0 implies j divides l!;

theorem :: NEWTON:55
  for l,j st j<>1 & j<>0 holds j divides (l!+1) implies j>l;

:: The fundamental properties of lcm, hcf

theorem :: NEWTON:56
  m lcm (n lcm k) = (m lcm n) lcm k;

theorem :: NEWTON:57
   m divides n iff m lcm n = n;

theorem :: NEWTON:58
    n divides m & k divides m iff n lcm k divides m;

theorem :: NEWTON:59
     m lcm 1 = m;

theorem :: NEWTON:60
 m lcm n divides m*n;

theorem :: NEWTON:61
  m hcf (n hcf k) = (m hcf n) hcf k;

theorem :: NEWTON:62
  n divides m implies n hcf m = n;

theorem :: NEWTON:63
     m divides n & m divides k iff m divides n hcf k;

theorem :: NEWTON:64
  m hcf 1 = 1;

theorem :: NEWTON:65
     m hcf 0 = m;

theorem :: NEWTON:66
  (m hcf n) lcm n = n;

theorem :: NEWTON:67
  m hcf (m lcm n) = m;

theorem :: NEWTON:68
     m hcf (m lcm n) = (n hcf m) lcm m;

theorem :: NEWTON:69
     m divides n implies m hcf k divides n hcf k;

theorem :: NEWTON:70
     m divides n implies k hcf m divides k hcf n;

theorem :: NEWTON:71
     m > 0 implies 0 hcf m > 0;

theorem :: NEWTON:72
  n > 0 implies n hcf m > 0;

theorem :: NEWTON:73
  m > 0 & n > 0 implies m lcm n > 0;

theorem :: NEWTON:74
     (n hcf m) lcm (n hcf k) divides n hcf (m lcm k);

theorem :: NEWTON:75
     m divides l implies m lcm (n hcf l) divides (m lcm n) hcf l;

theorem :: NEWTON:76
      n hcf m divides n lcm m;

:: from GR_CY_2

 reserve k,l,m,n,p,s,r for Nat;
 reserve i0,i,i1,i2,i3,i4 for Integer;

theorem :: NEWTON:77
 for n,m st 0 < m holds n mod m= n - m * (n div m);

theorem :: NEWTON:78
 i2 >= 0 implies i1 mod i2 >= 0;

theorem :: NEWTON:79
 i2 > 0 implies i1 mod i2 < i2;

theorem :: NEWTON:80
 i2 <> 0 implies i1 = (i1 div i2) * i2 + (i1 mod i2);

theorem :: NEWTON:81
 for m,n st m>0 or n>0 holds ex i,i1 st i*m + i1*n = m hcf n;

:: from NAT_LAT

 reserve n,j,i,k,k1,k2,k3,k4,m,l,s for Nat;

definition
  func SetPrimes -> Subset of NAT means
:: NEWTON:def 6
 for n being Nat holds n in it iff n is prime;
end;

registration
  cluster prime Nat;
end;

definition
  mode Prime is prime Nat;
end;

reserve p,f for Prime;
reserve x for set;

definition let p;
  func SetPrimenumber p -> Subset of NAT means
:: NEWTON:def 7
 for q being Nat holds q in it iff (q < p & q is prime);
end;

theorem :: NEWTON:82
 SetPrimenumber p c= SetPrimes;

theorem :: NEWTON:83
    for q being Prime st p < q holds
       SetPrimenumber p c= SetPrimenumber q;

theorem :: NEWTON:84
 SetPrimenumber p c= Seg p;

theorem :: NEWTON:85
    SetPrimenumber p is finite;

reserve p for Prime;

theorem :: NEWTON:86
   for l holds ex p st p is prime & p>l;

theorem :: NEWTON:87
    SetPrimes <> {};

theorem :: NEWTON:88
    {k:k<2 & k is prime}={};

theorem :: NEWTON:89
    for p holds {k:k<p & k is prime} c= NAT;

theorem :: NEWTON:90
 for m holds {k:k<m & k is prime} c= Seg m;

theorem :: NEWTON:91
 for m holds {k:k<m & k is prime} is finite;

theorem :: NEWTON:92
 for f being Prime holds not f in {k: k<f & k is prime};

theorem :: NEWTON:93
    for f holds {k: k<f & k is prime}\/{f} is finite;

theorem :: NEWTON:94
 for f,g being Prime st f<g holds
   {k1: k1<f & k1 is prime}\/{f} c={k2: k2<g & k2 is prime};

theorem :: NEWTON:95
    for k st k>m holds not k in {k1:k1<m & k1 is prime};

definition let n;
  func primenumber n -> Prime means
:: NEWTON:def 8

 ex B being finite set st B = {k:k<it & k is prime} & n = card B;
end;

theorem :: NEWTON:96
  SetPrimenumber p = {k:k<p & k is prime};

theorem :: NEWTON:97 ::Euklidesa::
    SetPrimes is infinite;

reserve m,m1,p',p1,i for Nat;

theorem :: NEWTON:98 :: divisibility
           for i st i is prime holds
   for m,n holds i divides m * n implies i divides m or i divides n;

:: from URYSOHN1, the proof from CARD_4

theorem :: NEWTON:99
   m|^n is Nat;

