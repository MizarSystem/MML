:: Factorial and Newton coeffitients
::  by Rafa{\l} Kwiatek
::
:: Received July 27, 1990
:: Copyright (c) 1990 Association of Mizar Users

environ

 vocabularies ORDINAL2, ARYTM, FINSEQ_1, ARYTM_3, ARYTM_1, RELAT_1, FUNCT_1,
      BOOLE, FINSEQ_2, GROUP_1, QC_LANG1, RLVECT_1, NEWTON, FINSEQ_4, CARD_3,
      NAT_1, INT_1, ABSVALUE, FILTER_0, NAT_LAT, FINSET_1, CARD_1, TARSKI,
      SQUARE_1, XCMPLX_0, SEQ_1, COMPLEX1;
 notations TARSKI, XBOOLE_0, SUBSET_1, ORDINAL1, NUMBERS, XCMPLX_0, XREAL_0,
      CARD_1, REAL_1, FUNCT_1, SEQ_1, FINSET_1, FINSEQ_1, FINSEQ_2, FINSEQ_4,
      INT_1, INT_2, NAT_1, NAT_D, RVSUM_1, SQUARE_1, XXREAL_0;
 constructors PARTFUN1, WELLORD2, SQUARE_1, NAT_1, BINOP_2, FINSEQOP, SEQ_1,
      FINSEQ_4, FINSOP_1, SETWOP_2, RVSUM_1, INT_2, ORDINAL2, DOMAIN_1, REAL_1,
      NAT_D;
 registrations RELSET_1, FINSEQ_2, INT_1, XREAL_0, NAT_1, MEMBERED, ORDINAL2,
      FINSEQ_1, FINSET_1, RVSUM_1, XXREAL_0, FUNCT_1, ORDINAL1, ARYTM_3,
      XCMPLX_0, SEQ_1;
 requirements REAL, NUMERALS, BOOLE, SUBSET, ARITHM;


begin

 reserve i,k,n,m,l for Element of NAT;
 reserve s,t,r for Nat;
 reserve a,b for real number;
 reserve F,G,H for FinSequence of REAL;

canceled 2;

theorem :: NEWTON:3
 for F,G being FinSequence st
     len F = len G & (for i st i in dom F holds F.i = G.i) holds F = G;

canceled;

theorem :: NEWTON:5
 for n st n>=1 holds Seg n = {1} \/ {k: 1<k & k<n} \/ {n};

theorem :: NEWTON:6
 for F holds len (a*F) = len F;

theorem :: NEWTON:7
 n in dom G iff n in dom (a*G);

::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
::    x |^ n  Function                                                      ::
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

definition let i be natural number; let x be real number;
  redefine func i |-> x -> FinSequence of REAL;
end;

registration let x be complex number, n be natural number;
  cluster n |-> x -> complex-yielding;
end;

definition let x be complex number, n be natural number;
  func x |^ n equals
:: NEWTON:def 1
    Product (n |-> x);
end;

registration let x be real number, n be natural number;
  cluster x |^ n -> real;
end;

definition let x be Real, n be natural number;
  redefine func x |^ n -> Real;
end;

reserve z for complex number;

canceled;

theorem :: NEWTON:9
 z|^0 = 1;

registration let z be complex number, n be natural number;
 cluster z|^n -> complex;
end;

theorem :: NEWTON:10
 z|^1 = z;

theorem :: NEWTON:11
 z|^(s+1) = z|^s*z;

registration let x, n be natural number;
  cluster x|^n -> natural;
end;

reserve x,y for complex number;

theorem :: NEWTON:12
  (x*y)|^s = x|^s * y|^s;

theorem :: NEWTON:13
  x|^(s+t) = x|^s * x|^t;

theorem :: NEWTON:14
  (x|^s)|^t = x|^(s*t);

theorem :: NEWTON:15
 1|^s = 1;

theorem :: NEWTON:16
  s >= 1 implies 0|^s = 0;

::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
::     n!  Function                                                         ::
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

definition let n be natural number;
 redefine func idseq n -> FinSequence of REAL;
end;

definition let n be natural number;
  func n! -> Real equals
:: NEWTON:def 2
    Product idseq n;
end;

registration let n be natural number;
  cluster n! -> real;
end;

definition let n be natural number;
  redefine func n! -> Real;
end;

canceled;

theorem :: NEWTON:18
  0! = 1;

theorem :: NEWTON:19
  1! = 1;

theorem :: NEWTON:20
  2! = 2;

theorem :: NEWTON:21
  for s holds (s+1)! = (s!) * (s+1);

theorem :: NEWTON:22
  for s holds s! is Element of NAT;

theorem :: NEWTON:23
 for s holds s!>0;

canceled;

theorem :: NEWTON:25
 for s,t holds (s!) * (t!)<>0;

::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
::     n choose k  Function                                                 ::
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

definition let k,n be natural number;
  func n choose k means
:: NEWTON:def 3
    for l be natural number st l = n-k holds
     it = (n!)/((k!) * (l!)) if n >= k
  otherwise it = 0;
end;

registration let k,n be natural number;
  cluster n choose k -> real;
end;

definition let k,n be natural number;
  redefine func n choose k -> Real;
end;

canceled;

theorem :: NEWTON:27
 0 choose 0 = 1;

canceled;

theorem :: NEWTON:29
 s choose 0 = 1;

theorem :: NEWTON:30
 for s,t st s>=t holds
       (for r st r = s-t holds s choose t = s choose r);

theorem :: NEWTON:31
 for s holds s choose s = 1;

theorem :: NEWTON:32
  (t+1) choose (s+1) = (t choose (s+1)) + (t choose s);

theorem :: NEWTON:33
  for s st s >= 1 holds s choose 1 = s;

theorem :: NEWTON:34
  for s,t st s>=1 & t = s-1 holds s choose t = s;

theorem :: NEWTON:35
  s choose r is Element of NAT;

theorem :: NEWTON:36
  for m,F st m <> 0 & len F = m & (for i,l st i in dom F & l = n+i-1
    holds F.i = l choose n) holds Sum F = (n+m) choose (n+1);

registration
  let k,n be natural number;
  cluster n choose k -> natural;
end;

definition
  let k,n be natural number;
  redefine func n choose k -> Element of NAT;
end;

definition let a,b be real number;
           let n be natural number;
  func (a,b) In_Power n -> FinSequence of REAL means
:: NEWTON:def 4
   len it = n+1 &
   (for i,l,m being natural number st i in dom it & m = i - 1 & l = n-m holds
   it.i = (n choose m)* a|^l * b|^m);
end;

canceled;

theorem :: NEWTON:38
  (a,b) In_Power 0 = <*1*>;

theorem :: NEWTON:39
  ((a,b) In_Power s).1 = a|^s;

theorem :: NEWTON:40
  ((a,b) In_Power s).(s+1) = b|^s;

theorem :: NEWTON:41
 for s holds (a+b)|^s = Sum((a,b) In_Power s);

definition let n be natural number;
  func Newton_Coeff n -> FinSequence of REAL means
:: NEWTON:def 5
    len it = n+1 &
    (for i,k be natural number st i in dom it & k = i-1 holds
      it.i = n choose k);
end;

canceled;

theorem :: NEWTON:43
  for s holds Newton_Coeff s = (1,1) In_Power s;

theorem :: NEWTON:44
  for s holds 2|^s = Sum(Newton_Coeff s);

begin :: Addenda

:: from NAT_LAT

theorem :: NEWTON:45
  l >= 1 implies k*l>=k;

theorem :: NEWTON:46
  l >= 1 & n >= k*l implies n>=k;

definition let n;
  redefine func n! -> Element of NAT;
end;

theorem :: NEWTON:47
  l <> 0 implies l divides l!;

theorem :: NEWTON:48
  n <> 0 implies (n+1)/n > 1;

theorem :: NEWTON:49
  k/(k+1) < 1;

theorem :: NEWTON:50
  for l being Element of NAT holds l! >= l;

 reserve s,j,r for Element of NAT;

theorem :: NEWTON:51
  for m,n st m<>1 holds m divides n implies not m divides (n+1);

theorem :: NEWTON:52
  j divides l & j divides l+1 iff j=1;

theorem :: NEWTON:53
  for k,j st j<>0 holds j divides (j+k)!;

theorem :: NEWTON:54
  j<=l & j<>0 implies j divides l!;

theorem :: NEWTON:55
  for l,j st j<>1 & j<>0 holds j divides (l!+1) implies j>l;

:: The fundamental properties of lcm, hcf

theorem :: NEWTON:56
  m lcm (n lcm k) = (m lcm n) lcm k;

theorem :: NEWTON:57
  m divides n iff m lcm n = n;

theorem :: NEWTON:58
  n divides m & k divides m iff n lcm k divides m;

theorem :: NEWTON:59
  m lcm 1 = m;

theorem :: NEWTON:60
  m lcm n divides m*n;

theorem :: NEWTON:61
  m hcf (n hcf k) = (m hcf n) hcf k;

theorem :: NEWTON:62
  n divides m implies n hcf m = n;

theorem :: NEWTON:63
  m divides n & m divides k iff m divides n hcf k;

theorem :: NEWTON:64
  m hcf 1 = 1;

theorem :: NEWTON:65
  m hcf 0 = m;

theorem :: NEWTON:66
  (m hcf n) lcm n = n;

theorem :: NEWTON:67
  m hcf (m lcm n) = m;

theorem :: NEWTON:68
  m hcf (m lcm n) = (n hcf m) lcm m;

theorem :: NEWTON:69
  m divides n implies m hcf k divides n hcf k;

theorem :: NEWTON:70
  m divides n implies k hcf m divides k hcf n;

theorem :: NEWTON:71
  n > 0 implies n hcf m > 0;

canceled;

theorem :: NEWTON:73
  m > 0 & n > 0 implies m lcm n > 0;

theorem :: NEWTON:74
  (n hcf m) lcm (n hcf k) divides n hcf (m lcm k);

theorem :: NEWTON:75
  m divides l implies m lcm (n hcf l) divides (m lcm n) hcf l;

theorem :: NEWTON:76
  n hcf m divides n lcm m;

:: from GR_CY_2

 reserve k,m,n,p for Element of NAT;
 reserve i0,i,i1,i2,i3,i4 for Integer;

theorem :: NEWTON:77
  for n,m st 0 < m holds n mod m= n - m * (n div m);

theorem :: NEWTON:78
  i2 >= 0 implies i1 mod i2 >= 0;

theorem :: NEWTON:79
  i2 > 0 implies i1 mod i2 < i2;

theorem :: NEWTON:80
  i2 <> 0 implies i1 = (i1 div i2) * i2 + (i1 mod i2);

theorem :: NEWTON:81
  for m,n st m>0 or n>0 holds ex i,i1 st i*m + i1*n = m hcf n;

:: from NAT_LAT

 reserve n,j,k,m,l for Element of NAT;

definition
  func SetPrimes -> Subset of NAT means
:: NEWTON:def 6
 for n being Nat holds n in it iff n is prime;
end;

registration
  cluster prime Element of NAT;
  cluster prime Nat;
end;

definition
  mode Prime is prime Element of NAT;
end;

 reserve
         x for set;

definition let p be Nat;
  func SetPrimenumber p -> Subset of NAT means
:: NEWTON:def 7
    for q being Nat holds q in it iff q < p & q is prime;
end;

theorem :: NEWTON:82
  for p being Nat holds SetPrimenumber p c= SetPrimes;

theorem :: NEWTON:83
  for p,q being Nat st p <= q holds
    SetPrimenumber p c= SetPrimenumber q;

theorem :: NEWTON:84
  for p being Nat holds SetPrimenumber p c= Seg p;

theorem :: NEWTON:85
  for p being Nat holds SetPrimenumber p is finite;

registration
  let n be Nat;
  cluster SetPrimenumber n -> finite;
end;

 reserve p for Prime;

theorem :: NEWTON:86
  for l being Nat ex p st p is prime & p>l;

theorem :: NEWTON:87
  SetPrimes <> {};

theorem :: NEWTON:88
  SetPrimenumber 2 = {};

registration
  cluster SetPrimenumber 2 -> empty;
end;

theorem :: NEWTON:89
  SetPrimenumber n c= NAT;

theorem :: NEWTON:90
  SetPrimenumber m c= Seg m;

theorem :: NEWTON:91
  SetPrimenumber n is finite;

theorem :: NEWTON:92
  k>=m implies not k in SetPrimenumber m;

theorem :: NEWTON:93
  for f being Nat holds SetPrimenumber f \/ {f} is finite;

theorem :: NEWTON:94
  for f being Prime, g being Nat st f < g holds
  SetPrimenumber f \/ {f} c= SetPrimenumber g;

theorem :: NEWTON:95
  k>=m implies not k in SetPrimenumber m;

definition let n be Nat;
  func primenumber n -> Prime means
:: NEWTON:def 8
  n = card SetPrimenumber it;
end;

theorem :: NEWTON:96
  SetPrimenumber n = {k: k<n & k is prime};

theorem :: NEWTON:97  :: Euclid
  SetPrimes is infinite;

registration
  cluster SetPrimes -> non empty infinite;
end;

 reserve m,i for Nat;

theorem :: NEWTON:98 :: divisibility
  for i st i is prime holds
    for m,n being Nat holds i divides m * n implies i divides m or i divides n;

canceled;

theorem :: NEWTON:100
  for x being real number holds x |^ 2 = x * x & x^2 = x |^ 2;

:: from SCMFSA9A, 2005.11.16, A.T

theorem :: NEWTON:101
 for m,n being natural number holds
 m qua Integer div n = m div n &
 m qua Integer mod n = m mod n;

:: from HEINE, 2006.01.07, A.T

 reserve k for Nat,
         x for real number;

theorem :: NEWTON:102
 x > 0 implies x|^k > 0;

:: missing, 2006.07.17, A.T.

theorem :: NEWTON:103
 n > 0 implies  0 |^ n = 0;

:: from CARD_4 and WSIERP_1, 2007.02.07, AK

definition let m,n be Element of NAT;
  redefine func m|^n -> Element of NAT;
end;
