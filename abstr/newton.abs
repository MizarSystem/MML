:: Factorial and Newton coefficients
::  by Rafa{\l} Kwiatek
::
:: Received July 27, 1990
:: Copyright (c) 1990 Association of Mizar Users

environ

 vocabularies NUMBERS, NAT_1, XREAL_0, ORDINAL1, FINSEQ_1, RELAT_1, FUNCT_1,
      XXREAL_0, XBOOLE_0, SUBSET_1, ARYTM_3, TARSKI, FINSEQ_2, XCMPLX_0,
      RVSUM_1, CARD_3, REAL_1, CARD_1, ORDINAL4, REALSET1, ARYTM_1, PARTFUN1,
      INT_2, INT_1, FINSET_1, SQUARE_1, FUNCOP_1, NEWTON;
 notations TARSKI, XBOOLE_0, SUBSET_1, ORDINAL1, CARD_1, NUMBERS, XCMPLX_0,
      XREAL_0, REAL_1, FUNCT_1, PARTFUN1, FUNCT_2, FINSET_1, FINSEQ_1,
      FINSEQ_2, FUNCOP_1, INT_1, INT_2, NAT_1, NAT_D, RVSUM_1, SQUARE_1,
      XXREAL_0;
 constructors PARTFUN1, WELLORD2, REAL_1, SQUARE_1, NAT_1, NAT_D, BINOP_2,
      FINSOP_1, SEQ_1, RVSUM_1, FUNCOP_1, RELSET_1, FINSEQOP;
 registrations ORDINAL1, RELSET_1, FINSET_1, NUMBERS, XCMPLX_0, XXREAL_0,
      XREAL_0, NAT_1, INT_1, MEMBERED, FINSEQ_1, FINSEQ_2, RVSUM_1, VALUED_0,
      CARD_1;
 requirements REAL, NUMERALS, BOOLE, SUBSET, ARITHM;


begin

reserve i,j,k,n,m,l,s,t,r for Nat;
reserve a,b for real number;
reserve F,G,H for FinSequence of REAL;

canceled 4;

theorem :: NEWTON:5
  n>=1 implies Seg n = {1} \/ {k where k is Element of NAT: 1<k & k <n} \/ {n};

theorem :: NEWTON:6
  len (a*F) = len F;

theorem :: NEWTON:7
  dom G = dom (a*G);

:: x |^ n Function

definition
  let i be Nat;
  let x be real number;
  redefine func i |-> x -> FinSequence of REAL;
end;

registration
  let x be complex number, n be Nat;
  cluster n |-> x -> complex-yielding;
end;

definition
  let x be complex number, n be Nat;
  func x |^ n equals
:: NEWTON:def 1
  Product (n |-> x);
end;

registration
  let x be real number, n be Nat;
  cluster x |^ n -> real;
end;

definition
  let x be Real, n be Nat;
  redefine func x |^ n -> Real;
end;

reserve z for complex number;

canceled;

registration
  let z be complex number, n be Nat;
  cluster z|^n -> complex;
end;

theorem :: NEWTON:9
  z|^0 = 1;

theorem :: NEWTON:10
  z|^1 = z;

theorem :: NEWTON:11
  z|^(s+1) = z|^s*z;

registration
  let x, n be Nat;
  cluster x|^n -> natural;
end;

reserve x,y for complex number;

theorem :: NEWTON:12
  (x*y) |^ s = x|^s * y|^s;

theorem :: NEWTON:13
  x|^(s+t) = x|^s * x|^t;

theorem :: NEWTON:14
  (x|^s) |^ t = x|^(s*t);

theorem :: NEWTON:15
  1|^s = 1;

theorem :: NEWTON:16
  s >= 1 implies 0|^s = 0;

:: n! Function

definition
  let n be Nat;
  redefine func idseq n -> FinSequence of REAL;
end;

definition
  let n be Nat;
  func n! -> Real equals
:: NEWTON:def 2
  Product idseq n;
end;

registration
  let n be Nat;
  cluster n! -> real;
end;

canceled;

theorem :: NEWTON:18
  0! = 1;

theorem :: NEWTON:19
  1! = 1;

theorem :: NEWTON:20
  2! = 2;

theorem :: NEWTON:21
  (s+1)! = (s!) * (s+1);

theorem :: NEWTON:22
  s! is Element of NAT;

registration
  let n;
  cluster n! -> natural;
end;

theorem :: NEWTON:23
  s! > 0;

registration
  let n;
  cluster n! -> positive;
end;

canceled;

theorem :: NEWTON:25
  (s!) * (t!) <> 0;

:: n choose k Function

definition
  let k,n be Nat;
  func n choose k means
:: NEWTON:def 3

  for l be Nat st l = n-k holds it = (n!)/((k!) * (l!)) if n >= k
  otherwise it = 0;
end;

registration
  let k,n be Nat;
  cluster n choose k -> real;
end;

definition
  let k,n be Nat;
  redefine func n choose k -> Real;
end;

canceled 3;

theorem :: NEWTON:29
  s choose 0 = 1;

theorem :: NEWTON:30
  s >= t & r = s-t implies s choose t = s choose r;

theorem :: NEWTON:31
  s choose s = 1;

theorem :: NEWTON:32
  (t+1) choose (s+1) = (t choose (s+1)) + (t choose s);

theorem :: NEWTON:33
  s >= 1 implies s choose 1 = s;

theorem :: NEWTON:34
  s>=1 & t = s-1 implies s choose t = s;

theorem :: NEWTON:35
  s choose r is Element of NAT;

theorem :: NEWTON:36
  for m,F st m <> 0 & len F = m & (for i,l st i in dom F & l = n+i-1
  holds F.i = l choose n) holds Sum F = (n+m) choose (n+1);

registration
  let k,n be Nat;
  cluster n choose k -> natural;
end;

definition
  let k,n be Nat;
  redefine func n choose k -> Element of NAT;
end;

definition
  let a,b be real number;
  let n be Nat;
  func (a,b) In_Power n -> FinSequence of REAL means
:: NEWTON:def 4

  len it = n+1 & for i,l,m being Nat st i in dom it & m = i - 1 & l = n-m holds
    it.i = (n choose m) * a|^l * b|^m;
end;

canceled;

theorem :: NEWTON:38
  (a,b) In_Power 0 = <*1*>;

theorem :: NEWTON:39
  ((a,b) In_Power s).1 = a|^s;

theorem :: NEWTON:40
  ((a,b) In_Power s).(s+1) = b|^s;

theorem :: NEWTON:41
  (a+b) |^ s = Sum((a,b) In_Power s);

definition
  let n be Nat;
  func Newton_Coeff n -> FinSequence of REAL means
:: NEWTON:def 5

  len it = n+1 & for i,k be Nat st i in dom it & k = i-1 holds
  it.i = n choose k;
end;

canceled;

theorem :: NEWTON:43
  Newton_Coeff s = (1,1) In_Power s;

theorem :: NEWTON:44
  2|^s = Sum(Newton_Coeff s);

begin :: Addenda
:: from NAT_LAT

theorem :: NEWTON:45
  l >= 1 implies k*l >= k;

theorem :: NEWTON:46
  l >= 1 & n >= k*l implies n >= k;

definition
  let n;
  redefine func n! -> Element of NAT;
end;

theorem :: NEWTON:47
  l <> 0 implies l divides l!;

theorem :: NEWTON:48
  n <> 0 implies (n+1)/n > 1;

theorem :: NEWTON:49
  k/(k+1) < 1;

theorem :: NEWTON:50
  l! >= l;

theorem :: NEWTON:51
  m<>1 & m divides n implies not m divides (n+1);

canceled;

theorem :: NEWTON:53
  j<>0 implies j divides (j+k)!;

theorem :: NEWTON:54
  j<=l & j<>0 implies j divides l!;

theorem :: NEWTON:55
  j<>1 & j<>0 & j divides (l!+1) implies j>l;

:: The fundamental properties of lcm, hcf

theorem :: NEWTON:56
  m lcm (n lcm k) = (m lcm n) lcm k;

theorem :: NEWTON:57
  m divides n iff m lcm n = n;

theorem :: NEWTON:58
  n divides m & k divides m iff n lcm k divides m;

theorem :: NEWTON:59
  m lcm 1 = m;

theorem :: NEWTON:60
  m lcm n divides m*n;

theorem :: NEWTON:61
  m gcd (n gcd k) = (m gcd n) gcd k;

theorem :: NEWTON:62
  n divides m implies n gcd m = n;

theorem :: NEWTON:63
  m divides n & m divides k iff m divides n gcd k;

theorem :: NEWTON:64
  m gcd 1 = 1;

theorem :: NEWTON:65
  m gcd 0 = m;

theorem :: NEWTON:66
  (m gcd n) lcm n = n;

theorem :: NEWTON:67
  m gcd (m lcm n) = m;

theorem :: NEWTON:68
  m gcd (m lcm n) = (n gcd m) lcm m;

theorem :: NEWTON:69
  m divides n implies m gcd k divides n gcd k;

theorem :: NEWTON:70
  m divides n implies k gcd m divides k gcd n;

theorem :: NEWTON:71
  n > 0 implies n gcd m > 0;

canceled;

theorem :: NEWTON:73
  m > 0 & n > 0 implies m lcm n > 0;

theorem :: NEWTON:74
  (n gcd m) lcm (n gcd k) divides n gcd (m lcm k);

theorem :: NEWTON:75
  m divides l implies m lcm (n gcd l) divides (m lcm n) gcd l;

theorem :: NEWTON:76
  n gcd m divides n lcm m;

:: from GR_CY_2

reserve p,q for Nat;
reserve i0,i,i1,i2,i4 for Integer;

theorem :: NEWTON:77
  0 < m implies n mod m = n - m * (n div m);

theorem :: NEWTON:78
  i2 >= 0 implies i1 mod i2 >= 0;

theorem :: NEWTON:79
  i2 > 0 implies i1 mod i2 < i2;

theorem :: NEWTON:80
  i2 <> 0 implies i1 = (i1 div i2) * i2 + (i1 mod i2);

::$N Bezout's Theorem
theorem :: NEWTON:81
  m>0 or n>0 implies ex i,i1 st i*m + i1*n = m gcd n;

:: from NAT_LAT

definition
  func SetPrimes -> Subset of NAT means
:: NEWTON:def 6

  for n being Nat holds n in it iff n is prime;
end;

registration
  cluster prime Element of NAT;
  cluster prime Nat;
end;

definition
  mode Prime is prime Nat;
end;

reserve x for set;

definition
  let p be Nat;
  func SetPrimenumber p -> Subset of NAT means
:: NEWTON:def 7

  for q being Nat holds q in it iff q < p & q is prime;
end;

theorem :: NEWTON:82
  SetPrimenumber p c= SetPrimes;

theorem :: NEWTON:83
  p <= q implies SetPrimenumber p c= SetPrimenumber q;

theorem :: NEWTON:84
  SetPrimenumber p c= Seg p;

theorem :: NEWTON:85
  SetPrimenumber p is finite;

registration
  let n be Nat;
  cluster SetPrimenumber n -> finite;
end;

reserve p for Prime;

theorem :: NEWTON:86
  ex p st p is prime & p>l;

canceled 3;

registration
  cluster SetPrimes -> non empty;
end;

registration
  cluster SetPrimenumber 2 -> empty;
end;

theorem :: NEWTON:90
  SetPrimenumber m c= Seg m;

canceled;

theorem :: NEWTON:92
  k>=m implies not k in SetPrimenumber m;

theorem :: NEWTON:93
  SetPrimenumber n \/ {n} is finite;

theorem :: NEWTON:94
  for f being Prime, g being Nat st f < g holds SetPrimenumber f
  \/ {f} c= SetPrimenumber g;

theorem :: NEWTON:95
  k>=m implies not k in SetPrimenumber m;

definition
  let n be Nat;
  func primenumber n -> prime Element of NAT means
:: NEWTON:def 8

  n = card SetPrimenumber it;
end;

theorem :: NEWTON:96
  SetPrimenumber n = {k where k is Element of NAT: k<n & k is prime};

::$N The Infinitude of Primes
theorem :: NEWTON:97
  SetPrimes is infinite;

registration
  cluster SetPrimes -> non empty infinite;
end;

reserve i for Nat;

:: divisibility

theorem :: NEWTON:98
  i is prime implies for m,n being Nat holds i divides m * n implies
  i divides m or i divides n;

canceled;

theorem :: NEWTON:100
  for x being complex number holds x |^ 2 = x * x & x^2 = x |^ 2;

:: from SCMFSA9A, 2005.11.16, A.T

theorem :: NEWTON:101
  m qua Integer div n = m div n & m qua Integer mod n = m mod n;

:: from HEINE, 2006.01.07, A.T

reserve x for real number;

theorem :: NEWTON:102
  x > 0 implies x|^k > 0;

:: missing, 2006.07.17, A.T.

theorem :: NEWTON:103
  n > 0 implies 0 |^ n = 0;

:: from CARD_4 and WSIERP_1, 2007.02.07, AK

definition
  let m,n be Element of NAT;
  redefine func m|^n -> Element of NAT;
end;

theorem :: NEWTON:104
  2|^n >= n + 1;

theorem :: NEWTON:105
  2|^n > n;

:: from AMI_4, 2008.02.14, A.T.

reserve k for Element of NAT;

scheme :: NEWTON:sch 1

  Euklides9 { F(Nat) -> Element of NAT, G(Nat) -> Element of NAT,
    a() -> Element of NAT, b() -> Element of NAT } :
    ex k st F(k) = a() gcd b() & G(k) = 0
provided
 0 < b() and
 b() < a() and
 F(0) = a() and
 G(0) = b() and
 for k st G(k) > 0 holds F(k+1) = G(k) & G(k+1) = F(k) mod G(k);

:: from CARD_4, 2008.05.11, A.T.

reserve k,n,n1,n2,m1,m2 for natural number;

theorem :: NEWTON:106
  r <> 0 or n = 0 iff r|^n <> 0;

theorem :: NEWTON:107
  (2|^n1)*(2*m1+1) = (2|^n2)*(2*m2+1) implies n1 = n2 & m1 = m2;
