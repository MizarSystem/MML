:: The Reflection Theorem
::  by Grzegorz Bancerek
::
:: Received August 10, 1990
:: Copyright (c) 1990 Association of Mizar Users

environ

 vocabulary CLASSES2, ZF_LANG, FUNCT_1, ZF_MODEL, ORDINAL1, TARSKI, ORDINAL2,
      BOOLE, ZFMODEL1, RELAT_1, CARD_1, ORDINAL4, PROB_1, CLASSES1, ZFMISC_1,
      QC_LANG1, FUNCT_2, ARYTM_3, ZF_REFLE;
 notation TARSKI, XBOOLE_0, ENUMSET1, SUBSET_1, NUMBERS, XREAL_0, NAT_1,
      RELAT_1, FUNCT_1, FUNCT_2, FRAENKEL, ZF_MODEL, ZFMODEL1, ORDINAL1,
      ORDINAL2, CARD_1, PROB_1, CLASSES1, CLASSES2, ZF_LANG, ORDINAL4,
      ZF_LANG1;
 constructors ENUMSET1, NAT_1, FRAENKEL, ZF_MODEL, ZFMODEL1, WELLORD2, PROB_1,
      CLASSES1, ORDINAL4, ZF_LANG1, MEMBERED, XBOOLE_0;
 clusters SUBSET_1, FUNCT_1, ZF_LANG, ORDINAL1, ORDINAL2, CLASSES2, ZF_LANG1,
      RELSET_1, CARD_1, ZFMISC_1, XBOOLE_0;
 requirements NUMERALS, BOOLE, SUBSET;


begin

 reserve W for Universe,
         H for ZF-formula,
         x,y,z,X,Y for set,
         k for Variable,
         f for Function of VAR,W,
         u,v for Element of W;

canceled;

theorem :: ZF_REFLE:2
  W |= the_axiom_of_pairs;

theorem :: ZF_REFLE:3
  W |= the_axiom_of_unions;

theorem :: ZF_REFLE:4
  omega in W implies W |= the_axiom_of_infinity;

theorem :: ZF_REFLE:5
  W |= the_axiom_of_power_sets;

theorem :: ZF_REFLE:6
  for H st { x.0,x.1,x.2 } misses Free H holds
   W |= the_axiom_of_substitution_for H;

theorem :: ZF_REFLE:7
   omega in W implies W is_a_model_of_ZF;

 reserve
         F for Function,

         A,A1,A2,B,C for Ordinal,
         a,b,b1,b2,c for Ordinal of W,
         fi for Ordinal-Sequence,
         phi for Ordinal-Sequence of W,
         H for ZF-formula;

 definition let A,B;
  redefine pred A c= B means
:: ZF_REFLE:def 1
for C st C in A holds C in B;
 end;


scheme :: ZF_REFLE:sch 1
 ALFA { D() -> non empty set, P[set,set] }:
 ex F st dom F = D() &
  for d being Element of D() ex A st A = F.d & P[d,A] &
   for B st P[d,B] holds A c= B
  provided
 for d being Element of D() ex A st P[d,A]
proof
   defpred Q[set,set] means
    ex A st A = $2 & P[$1,A] & for B st P[$1,B] holds A c= B;
A2:  for x,y,z st x in D() & Q[x,y] & Q[x,z] holds y = z
     proof let x,y,z such that x in D();
      given A1 such that
A3:    A1 = y & P[x,A1] & for B st P[x,B] holds A1 c= B;
      given A2 such that
A4:    A2 = z & P[x,A2] & for B st P[x,B] holds A2 c= B;
         A1 c= A2 & A2 c= A1 by A3,A4;
      hence thesis by A3,A4,XBOOLE_0:def 10;
     end;
A5:  for x st x in D() ex y st Q[x,y]
     proof let x; assume x in D(); then
       reconsider d = x as Element of D();
       defpred Q[Ordinal] means P[d,$1];
A6:    ex A st Q[A] by A1;
      consider A such that
A7:    Q[A] & for B st Q[B] holds A c= B from ORDINAL1:sch 1(A6);
      reconsider y = A as set;
      take y,A; thus thesis by A7;
     end;
   consider F such that
A8:  dom F = D() & for x st x in D() holds Q[x,F.x] from FUNCT_1:sch 2(A2,A5);
   take F; thus dom F = D() by A8;
   let d be Element of D();
   thus Q[d,F.d] by A8;
  end;

scheme :: ZF_REFLE:sch 2
 ALFA'Universe { W()->Universe, D() -> non empty set, P[set,set] }:
 ex F st dom F = D() &
  for d being Element of D() ex a being Ordinal of W() st a = F.d & P[d,a] &
   for b being Ordinal of W() st P[d,b] holds a c= b
  provided
 for d being Element of D() ex a being Ordinal of W() st P[d,a]
proof   defpred p[set,set] means P[$1,$2];
A2:  for d being Element of D() ex A st p[d,A]
     proof let d be Element of D();
      consider a being Ordinal of W() such that
A3:    P[d,a] by A1;
      reconsider a as Ordinal;
      take a; thus thesis by A3;
     end;
   consider F such that
A4:  dom F = D() and
A5:  for d being Element of D() ex A st A = F.d & p[d,A] &
     for B st p[d,B] holds A c= B from ALFA(A2);
   take F; thus dom F = D() by A4;
   let d be Element of D();
   consider A such that
A6:  A = F.d & P[d,A] & for B st P[d,B] holds A c= B by A5;
   consider a being Ordinal of W() such that
A7:  P[d,a] by A1;
      A c= a & a in W() by A6,A7,ORDINAL4:def 2;
    then A in W() by CLASSES1:def 1;
   then reconsider a = A as Ordinal of W() by ORDINAL4:def 2;
   take a; thus thesis by A6;
  end;

theorem :: ZF_REFLE:8
  x is Ordinal of W iff x in On W;

 reserve psi for Ordinal-Sequence;

scheme :: ZF_REFLE:sch 3
 OrdSeqOfUnivEx { W()->Universe, P[set,set] }:
 ex phi being Ordinal-Sequence of W() st
   for a being Ordinal of W() holds P[a,phi.a]
  provided
 for a,b1,b2 being Ordinal of W() st P[a,b1] & P[a,b2] holds b1 = b2 and
 for a being Ordinal of W() ex b being Ordinal of W() st P[a,b]
proof   defpred Q[set,set] means P[$1,$2] & $2 is Ordinal of W();
A3:  for x,y,z st x in On W() & Q[x,y] & Q[x,z] holds y = z
     proof let x,y,z; assume x in On W();
      then reconsider a = x as Ordinal of W() by Th8;
      assume
A4:    (P[x,y] & y is Ordinal of W()) & (P[x,z] & z is Ordinal of W());
      then reconsider b1 = y, b2 = z as Ordinal of W();
         P[a,b1] & P[a,b2] by A4;
      hence thesis by A1;
     end;
A5:  for x st x in On W() ex y st Q[x,y]
     proof let x; assume x in On W();
      then reconsider a = x as Ordinal of W() by Th8;
      consider b being Ordinal of W() such that
A6:    P[a,b] by A2;
      reconsider y = b as set;
      take y; thus thesis by A6;
     end;
   consider f being Function such that
A7:  dom f = On W() &
     for x st x in On W() holds Q[x,f.x] from FUNCT_1:sch 2(A3,A5);
   reconsider phi = f as T-Sequence by A7,ORDINAL1:def 7;
A8:  rng phi c= On W()
     proof let x; assume x in rng phi;
       then ex y st y in dom phi & x = phi.y by FUNCT_1:def 5;
      then reconsider x as Ordinal of W() by A7;
         x in W() by ORDINAL4:def 2;
      hence thesis by ORDINAL2:def 2;
     end;
   then reconsider phi as Ordinal-Sequence by ORDINAL2:def 8;
   reconsider phi as Ordinal-Sequence of W() by A7,A8,ORDINAL4:def 3;
   take phi; let a be Ordinal of W();
      a in W() by ORDINAL4:def 2;
    then a in On W() by ORDINAL2:def 2;
   hence P[a,phi.a] by A7;
  end;

scheme :: ZF_REFLE:sch 4
 UOS_Exist { W()->Universe, a()->Ordinal of W(),
                   C(Ordinal,Ordinal)->Ordinal of W(),
                   D(Ordinal,T-Sequence)->Ordinal of W() } :
  ex phi being Ordinal-Sequence of W() st
   phi.0-element_of W() = a() &
   (for a being Ordinal of W() holds phi.(succ a) = C(a,phi.a)) &
   (for a being Ordinal of W() st a <> 0-element_of W() & a is_limit_ordinal
     holds phi.a = D(a,phi|a))
proof
   deffunc c(Ordinal,Ordinal) = C($1,$2);
   deffunc d(Ordinal,T-Sequence) = D($1,$2);
   consider phi being Ordinal-Sequence such that
A1: dom phi = On W() and
A2: {} in On W() implies phi.{} = a() and
A3: for A st succ A in On W() holds phi.(succ A) = c(A,phi.A) and
A4: for A st A in On W() & A <> {} & A is_limit_ordinal
          holds phi.A = d(A,phi|A) from ORDINAL2:sch 11;
     rng phi c= On W()
    proof let x; assume x in rng phi;
     then consider y such that
A5:   y in dom phi & x = phi.y by FUNCT_1:def 5;
     reconsider y as Ordinal of W() by A1,A5,Th8;
A6:   now given A such that
A7:     y = succ A;
       reconsider B = phi.A as Ordinal;
          x = C(A,B) by A1,A3,A5,A7;
       hence thesis by Th8;
      end;
        now assume not ex A st y = succ A;
then A8:     y is_limit_ordinal by ORDINAL1:42;
       assume y <> {};
        then x = D(y,phi|y) by A1,A4,A5,A8;
       hence thesis by Th8;
      end;
     hence thesis by A2,A5,A6,Th8;
    end;
  then reconsider phi as Ordinal-Sequence of W() by A1,ORDINAL4:def 3;
  take phi; 0-element_of W() in dom phi by ORDINAL4:36;
  hence phi.0-element_of W() = a() by A1,A2,ORDINAL4:35;
  thus for a being Ordinal of W() holds phi.(succ a) = C(a,phi.a)
    proof let a be Ordinal of W();
        succ a in dom phi by ORDINAL4:36;
     hence thesis by A1,A3;
    end;
  let a be Ordinal of W();
     a in dom phi & {} = 0-element_of W() by ORDINAL4:35,36;
  hence thesis by A1,A4;
 end;

scheme :: ZF_REFLE:sch 5
 Universe_Ind { W()->Universe, P[Ordinal] }:
 for a being Ordinal of W() holds P[a]
  provided
  P[0-element_of W()] and
  for a being Ordinal of W() st P[a] holds P[succ a] and
  for a being Ordinal of W() st a <> 0-element_of W() & a is_limit_ordinal &
     for b being Ordinal of W() st b in a holds P[b] holds P[a]
proof   defpred Q[Ordinal] means $1 is Ordinal of W() implies P[$1];
A4: Q[{}] by A1,ORDINAL4:35;
A5: for A st Q[A] holds Q[succ A]
     proof let A such that
A6:    A is Ordinal of W() implies P[A] and
A7:    succ A is Ordinal of W();
         A in succ A & succ A in On W() by A7,Th8,ORDINAL1:10;
       then A in On W() by ORDINAL1:19;
      then reconsider a = A as Ordinal of W() by Th8;
         P[succ a] by A2,A6;
      hence thesis;
     end;
A8: for A st A <> {} & A is_limit_ordinal & for B st B in A holds Q[B]
      holds Q[A]
     proof let A such that
A9:    A <> {} & A is_limit_ordinal and
A10:    for B st B in A holds B is Ordinal of W() implies P[B];
      assume A is Ordinal of W();
      then reconsider a = A as Ordinal of W();
         {} = 0-element_of W() & for b be Ordinal of W() st b in a holds P[b]
        by A10,ORDINAL4:35;
      hence P[A] by A3,A9;
     end;
      Q[A] from ORDINAL2:sch 1(A4,A5,A8);
   hence thesis;
  end;

 definition let f be Function, W be Universe, a be Ordinal of W;
  func union(f,a) -> set equals
:: ZF_REFLE:def 2
    Union (W|(f|Rank a));
 end;


canceled;

theorem :: ZF_REFLE:10
  for L being T-Sequence,A holds L|Rank A is T-Sequence;

theorem :: ZF_REFLE:11
  for L being Ordinal-Sequence,A holds L|Rank A is Ordinal-Sequence;

theorem :: ZF_REFLE:12
    Union psi is Ordinal;

theorem :: ZF_REFLE:13
  Union (X|psi) is Ordinal;

theorem :: ZF_REFLE:14
  On Rank A = A;

theorem :: ZF_REFLE:15
  psi|Rank A = psi|A;

 definition let phi be Ordinal-Sequence, W be Universe, a be Ordinal of W;
  redefine func union(phi,a) -> Ordinal of W;
 end;


canceled;

theorem :: ZF_REFLE:17
  for phi being Ordinal-Sequence of W holds
   union(phi,a) = Union (phi|a) & union(phi|a,a) = Union (phi|a);

 definition let W be Universe, a,b be Ordinal of W;
  redefine func a \/ b -> Ordinal of W;
 end;


 registration let W;
  cluster non empty Element of W;
   existence
    proof consider u;
        {u} is non empty Element of W;
     hence thesis;
    end;
 end;


 definition let W;
  mode Subclass of W is non empty Subset of W;
 end;


 definition let W;
   let IT be T-Sequence of W;
 canceled 2;

  attr IT is DOMAIN-yielding means
:: ZF_REFLE:def 5
   dom IT = On W;
 end;


 registration let W;
  cluster DOMAIN-yielding non-empty T-Sequence of W;
   existence
    proof consider D being non empty Element of W;
      deffunc F(set) = D;
     consider L being T-Sequence such that
A1:    dom L = On W &
       for A for L1 being T-Sequence st A in On W & L1 = L|A holds L.A = F(L1)
        from ORDINAL1:sch 4;
        rng L c= W
       proof let x; assume x in rng L;
        then consider y such that
A2:       y in dom L & x = L.y by FUNCT_1:def 5;
        reconsider y as Ordinal by A2,ORDINAL1:23;
           L|y = L|y;
         then x = D by A1,A2;
        hence thesis;
       end;
     then reconsider L as T-Sequence of W by ORDINAL1:def 8;
     take L; thus dom L = On W by A1;
     assume {} in rng L;
     then consider x such that
A3:    x in dom L & {} = L.x by FUNCT_1:def 5;
     reconsider x as Ordinal by A3,ORDINAL1:23;
        L|x = L|x;
     hence contradiction by A1,A3;
    end;
 end;


definition let W;
  mode DOMAIN-Sequence of W is non-empty DOMAIN-yielding T-Sequence of W;
end;

 definition let W; let L be DOMAIN-Sequence of W;
 redefine func Union L -> Subclass of W;
  let a;
  func L.a -> non empty Element of W;
 end;


 reserve L for DOMAIN-Sequence of W,
         n,j for Nat,
         f for Function of VAR,L.a;

canceled 5;

theorem :: ZF_REFLE:23
  a in dom L;

theorem :: ZF_REFLE:24
  L.a c= Union L;

theorem :: ZF_REFLE:25
  NAT,VAR are_equipotent;

canceled;

theorem :: ZF_REFLE:27
  sup X c= succ union On X;

theorem :: ZF_REFLE:28
  X in W implies sup X in W;

 reserve x1 for Variable;

theorem :: ZF_REFLE:29
    omega in W & (for a,b st a in b holds L.a c= L.b) &
    (for a st a <> {} & a is_limit_ordinal holds L.a = Union (L|a)) implies
     for H ex phi st phi is increasing & phi is continuous &
      for a st phi.a = a & {} <> a
       for f holds Union L,(Union L)!f |= H iff L.a,f |= H;
