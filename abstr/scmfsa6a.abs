:: On the compositions of macro instructions
::  by Andrzej Trybulec , Yatsuka Nakamura and Noriko Asamoto
::
:: Received June 20, 1996
:: Copyright (c) 1996-2011 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies NUMBERS, SUBSET_1, AMI_1, SCMFSA_2, SCMNORM, FUNCT_4, AMI_3,
      FUNCOP_1, RELAT_1, FUNCT_1, TARSKI, XBOOLE_0, CARD_1, CAT_1, NAT_1,
      ARYTM_3, FINSET_1, STRUCT_0, XXREAL_0, AMISTD_2, VALUED_1, FSM_1,
      GRAPHSP, FUNCT_7, ARYTM_1, INT_1, COMPLEX1, PARTFUN1, FINSEQ_1, FINSEQ_2,
      TURING_1, SCMFSA6A, ORDINAL1, RELOC, SCMFSA6C;
 notations TARSKI, XBOOLE_0, SUBSET_1, CARD_1, NUMBERS, XCMPLX_0, COMPLEX1,
      NAT_1, INT_1, RELAT_1, FUNCT_1, PARTFUN1, FUNCT_2, FINSEQ_1, FINSEQ_2,
      FINSET_1, FUNCT_4, DOMAIN_1, VALUED_1, AFINSQ_1, STRUCT_0, COMPOS_1,
      EXTPRO_1, FUNCT_7, SCMFSA_2, AMISTD_2, FUNCOP_1, XXREAL_0;
 constructors WELLORD2, DOMAIN_1, XXREAL_0, INT_2, AMISTD_2, SCMFSA_2,
      RELSET_1, VALUED_1, AMI_3, PRE_POLY, AMISTD_1;
 registrations XBOOLE_0, SETFAM_1, FUNCT_1, ORDINAL1, RELSET_1, FUNCOP_1,
      FINSET_1, NUMBERS, XREAL_0, INT_1, STRUCT_0, SCMFSA_2, FUNCT_4, RELAT_1,
      VALUED_1, SCMFSA10, AMISTD_2, COMPOS_1, EXTPRO_1, SCMFSA_4;
 requirements NUMERALS, REAL, SUBSET, BOOLE, ARITHM;


begin

reserve l, m, n for Element of NAT,
  i,j,k for Instruction of SCM+FSA,
  I,J,K for Program of SCM+FSA;

definition
  let P be NAT-defined (the Instructions of SCM+FSA)-valued finite Function;
  let l be Element of NAT;
  func Directed(P,l) -> preProgram of SCM+FSA equals
:: SCMFSA6A:def 1
  P +~ (halt SCM+FSA,goto l);
end;

definition
  let P be NAT-defined (the Instructions of SCM+FSA)-valued finite Function;
  func Directed P -> preProgram of SCM+FSA equals
:: SCMFSA6A:def 2
  Directed(P, card P);
end;

canceled 14;

registration
  let I be Program of SCM+FSA;
  cluster Directed I -> initial non empty;
end;

canceled 3;

theorem :: SCMFSA6A:18
  not halt SCM+FSA in rng Directed I;

theorem :: SCMFSA6A:19
  Reloc(ProgramPart Directed I, m) = ((id the Instructions of
SCM+FSA) +* (halt SCM+FSA .--> goto (m + card I)))* Reloc
  (ProgramPart I, m);

reserve a,b for Int-Location,
  f for FinSeq-Location,
  s,s1,s2 for State of SCM+FSA;

registration
  let n be Nat;
  let i be Integer;
  cluster (intloc n) .--> i -> (the Object-Kind of SCM+FSA)-compatible;
end;

definition
 canceled;
  let I be PartState of SCM+FSA;
  func Initialized I -> PartState of SCM+FSA equals
:: SCMFSA6A:def 4
  I +* Initialize ((intloc 0) .--> 1);
 projectivity;
end;

registration
  let I be FinPartState of SCM+FSA;
 cluster Initialized I -> finite;
end;

canceled 3;

theorem :: SCMFSA6A:23
  InsCode i in {0,6,7,8} or Exec(i,s).IC SCM+FSA = succ IC s;

theorem :: SCMFSA6A:24
 for p being PartState of SCM+FSA
  holds IC SCM+FSA in dom Initialized p;

theorem :: SCMFSA6A:25
  IC Initialized I =  0;

theorem :: SCMFSA6A:26
  I c= Initialized I;

registration
  let I be non halt-free Program of SCM+FSA;
  cluster Initialized I -> non halt-free;
end;

canceled 6;

theorem :: SCMFSA6A:33
  (Initialized I) | NAT = I;

scheme :: SCMFSA6A:sch 1

  SCMFSAEx{ F(set) -> Element of the Instructions of SCM+FSA, G(set) ->
Integer, H(set) -> FinSequence of INT, I() -> Element of NAT }
: ex S being State of SCM+FSA st IC S = I() & for i being Element of NAT holds
  S. i = F(i) & S.intloc i = G(i) & S.fsloc i = H(i);

canceled;

theorem :: SCMFSA6A:35
  for s being State of SCM+FSA, x being set st x in dom s holds x is
  Int-Location or x is FinSeq-Location or x = IC SCM+FSA or x is
  Element of NAT;

canceled;

theorem :: SCMFSA6A:37
  for i being Element of NAT holds not i in
  Data-Locations SCM+FSA & not IC SCM+FSA in Data-Locations SCM+FSA;

theorem :: SCMFSA6A:38
  for s1,s2 being State of SCM+FSA holds ((for a being
Int-Location holds s1.a = s2.a) & for f being FinSeq-Location holds s1.f = s2.f
  ) iff DataPart s1 = DataPart s2;

canceled 2;

theorem :: SCMFSA6A:41
  for s1,s2 being State of SCM+FSA, n being Element of NAT, i being
  Instruction of SCM+FSA holds IC s1 + n = IC s2 & DataPart s1 = DataPart s2
  implies IC Exec(i,s1) + n = IC Exec(IncAddr(i,n),s2) & DataPart Exec(i,s1) =
  DataPart Exec(IncAddr(i,n),s2);

canceled;

theorem :: SCMFSA6A:43
  for p being PartState of SCM+FSA holds dom Initialized p = dom p
  \/ {intloc 0} \/ {IC SCM+FSA};

theorem :: SCMFSA6A:44
  for I being Program of SCM+FSA, x being set st x in dom
  Initialized I holds x in dom I or x = intloc 0 or x = IC SCM+FSA;

theorem :: SCMFSA6A:45
  for p being PartState of SCM+FSA holds intloc 0 in dom Initialized p;

theorem :: SCMFSA6A:46
  for I being Program of SCM+FSA holds (Initialized I).intloc 0 =
  1 & (Initialized I).IC SCM+FSA =  0;

theorem :: SCMFSA6A:47
  for I being Program of SCM+FSA holds not intloc 0 in dom I;

theorem :: SCMFSA6A:48
  for I being Program of SCM+FSA, a being Int-Location st a <>
  intloc 0 holds not a in dom Initialized I;

theorem :: SCMFSA6A:49
  for I being Program of SCM+FSA, f being FinSeq-Location holds
  not f in dom Initialized I;

theorem :: SCMFSA6A:50
  for I being Program of SCM+FSA, x being set st x in dom I holds
  I.x = (Initialized I).x;

theorem :: SCMFSA6A:51
  for I,J being Program of SCM+FSA for s being State of SCM+FSA st
  Initialized J c= s holds s +* Initialized I = s +* I;

theorem :: SCMFSA6A:52
  for I,J being Program of SCM+FSA for s being State of SCM+FSA st
  Initialized J c= s holds Initialized I c= s +* I;

canceled;

begin :: The composition of macroinstructions

definition
  let I,J be Program of SCM+FSA;
  func I ';' J -> Program of SCM+FSA equals
:: SCMFSA6A:def 5
  Directed I +* Reloc(J, card I);
end;

registration
 let I be Program of SCM+FSA, J be non halt-free Program of SCM+FSA;
  cluster I ';' J -> non halt-free;
end;

theorem :: SCMFSA6A:54
  for I,J being Program of SCM+FSA, l being Element of NAT
   st l in dom I & I.l <> halt SCM+FSA holds (I ';' J).l = I.l;

theorem :: SCMFSA6A:55
  for I,J being Program of SCM+FSA holds Directed I c= I ';' J;

theorem :: SCMFSA6A:56
  for I,J being Program of SCM+FSA holds dom I c= dom (I ';' J);

theorem :: SCMFSA6A:57
  for I,J being Program of SCM+FSA holds I +* (I ';' J) = (I ';' J);

theorem :: SCMFSA6A:58
  for I,J being Program of SCM+FSA holds Initialized I +* (I ';' J) =
  Initialized (I ';' J);

begin :: The compostion of instruction and macroinstructions

definition
  let i, J;
  func i ';' J -> Program of SCM+FSA equals
:: SCMFSA6A:def 6
  Macro i ';' J;
end;

definition
  let I, j;
  func I ';' j -> Program of SCM+FSA equals
:: SCMFSA6A:def 7
  I ';' Macro j;
end;

definition
  let i,j;
  func i ';' j -> Program of SCM+FSA equals
:: SCMFSA6A:def 8
  Macro i ';' Macro j;
end;

theorem :: SCMFSA6A:59
  i ';' j = Macro i ';' j;

theorem :: SCMFSA6A:60
  i ';' j = i ';' Macro j;

theorem :: SCMFSA6A:61
  card(I ';' J) = card I + card J;

registration
  let P be preProgram of SCM+FSA;
  let l be Element of NAT;
  cluster Directed(P,l) -> halt-free;
end;

registration
  let P be preProgram of SCM+FSA;
  cluster Directed P -> halt-free;
end;

canceled;

theorem :: SCMFSA6A:63
  for I being preProgram of SCM+FSA, l being Element of NAT
   holds I is halt-free implies Directed(I,l) = I;

canceled;

theorem :: SCMFSA6A:65
  for I being preProgram of SCM+FSA, k being Element of NAT holds
  Reloc(Directed I,k) = Directed(Reloc(I,k),(card I + k));

theorem :: SCMFSA6A:66
  for I,J being Program of SCM+FSA holds Directed (I ';' J) = I
  ';' Directed J;

theorem :: SCMFSA6A:67
  I ';' J ';' K = I ';' (J ';' K);

theorem :: SCMFSA6A:68
  I ';' J ';' k = I ';' (J ';' k);

theorem :: SCMFSA6A:69
  I ';' j ';' K = I ';' (j ';' K);

theorem :: SCMFSA6A:70
  I ';' j ';' k = I ';' (j ';' k);

theorem :: SCMFSA6A:71
  i ';' J ';' K = i ';' (J ';' K);

theorem :: SCMFSA6A:72
  i ';' J ';' k = i ';' (J ';' k);

theorem :: SCMFSA6A:73
  i ';' j ';' K = i ';' (j ';' K);

theorem :: SCMFSA6A:74
  i ';' j ';' k = i ';' (j ';' k);

theorem :: SCMFSA6A:75
 card(i ';' J) = card J + 2;

theorem :: SCMFSA6A:76
 card(I ';' j) = card I + 2;

theorem :: SCMFSA6A:77
 card(i ';' j) = 4;

theorem :: SCMFSA6A:78
 for i,j being Nat
 holds NPP ((intloc i) .--> j) = (intloc i) .--> j;

theorem :: SCMFSA6A:79
 NPP Initialized I = Initialize ((intloc 0) .--> 1);

theorem :: SCMFSA6A:80 :: SCM_HALT:6
  Initialize I c= Initialized I;

theorem :: SCMFSA6A:81  :: from SCMFSA8C
  for s being State of SCM+FSA st s.intloc 0 = 1 & IC s =  0
  holds Initialized s = s;

theorem :: SCMFSA6A:82  :: a part of SCMFSA6C:3
 for p being PartState of SCM+FSA holds
  IC Initialized p = 0 & (Initialized p).intloc 0 = 1;

theorem :: SCMFSA6A:83
 for p being PartState of SCM+FSA holds
   Initialize Initialized p = Initialized p;

theorem :: SCMFSA6A:84
  for s being State of SCM+FSA, I being Program of SCM+FSA holds
   s +* NPP Initialized I =
    Initialized s +* Start-At(0,SCM+FSA);

theorem :: SCMFSA6A:85
 for p,q being PartState of SCM+FSA
 holds IC SCM+FSA in dom(p +* Initialized q);

theorem :: SCMFSA6A:86
 intloc 0 in dom Initialize ((intloc 0).-->1);

theorem :: SCMFSA6A:87
 dom Initialize((intloc 0).-->1) misses NAT;
