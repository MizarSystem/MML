:: On the compositions of macro instructions
::  by Andrzej Trybulec , Yatsuka Nakamura and Noriko Asamoto
::
:: Received June 20, 1996
:: Copyright (c) 1996 Association of Mizar Users

environ

 vocabularies NUMBERS, SUBSET_1, AMI_1, SCMFSA_2, SCMNORM, FUNCT_4, AMI_3,
      FUNCOP_1, RELAT_1, FUNCT_1, TARSKI, XBOOLE_0, CARD_1, CAT_1, NAT_1,
      ARYTM_3, FINSET_1, STRUCT_0, XXREAL_0, AMISTD_2, VALUED_1, FSM_1,
      GRAPHSP, FUNCT_7, ARYTM_1, INT_1, COMPLEX1, PARTFUN1, FINSEQ_1, FINSEQ_2,
      TURING_1, SCMFSA6A, ORDINAL1, RELOC, SCMFSA6C;
 notations TARSKI, XBOOLE_0, SUBSET_1, CARD_1, NUMBERS, XCMPLX_0, COMPLEX1,
      NAT_1, INT_1, RELAT_1, FUNCT_1, PARTFUN1, FUNCT_2, FINSEQ_1, FINSEQ_2,
      FUNCOP_1, FINSET_1, FUNCT_4, DOMAIN_1, VALUED_1, AFINSQ_1, STRUCT_0,
      COMPOS_1, AMI_1, FUNCT_7, SCMFSA_2, AMISTD_2, XXREAL_0;
 constructors WELLORD2, DOMAIN_1, XXREAL_0, INT_2, AMISTD_2, SCMFSA_2,
      RELSET_1, VALUED_1, AMI_3;
 registrations XBOOLE_0, SETFAM_1, FUNCT_1, ORDINAL1, RELSET_1, FUNCOP_1,
      FINSET_1, NUMBERS, XREAL_0, INT_1, STRUCT_0, AMI_1, SCMFSA_2, FUNCT_4,
      RELAT_1, VALUED_1, SCMFSA10, AMISTD_2, COMPOS_1;
 requirements NUMERALS, REAL, SUBSET, BOOLE, ARITHM;


begin

reserve l, m, n for Element of NAT,
  i,j,k for Instruction of SCM+FSA,
  I,J,K for Program of SCM+FSA;

definition
  let P be preProgram of SCM+FSA;
  let l be Element of NAT;
  func Directed(P,l) -> preProgram of SCM+FSA equals
:: SCMFSA6A:def 1
  P +~ (halt SCM+FSA,goto l);
end;

definition
  let P be preProgram of SCM+FSA;
  func Directed P -> preProgram of SCM+FSA equals
:: SCMFSA6A:def 2
  Directed(P, card P);
end;

canceled 14;

registration
  let I be Program of SCM+FSA;
  cluster Directed I -> initial;
end;

definition
  let i;
  func Macro i -> Program of SCM+FSA equals
:: SCMFSA6A:def 3
  ( 0, 1) --> (i,halt SCM+FSA);
end;

registration
  let i;
  cluster Macro i -> non empty;
end;

canceled;

theorem :: SCMFSA6A:16
  dom I misses dom ProgramPart Relocated(J, card I);

theorem :: SCMFSA6A:17
  for I being preProgram of SCM+FSA holds card ProgramPart
  Relocated(I, m) = card I;

theorem :: SCMFSA6A:18
  not halt SCM+FSA in rng Directed I;

theorem :: SCMFSA6A:19
  ProgramPart Relocated(Directed I, m) = ((id the Instructions of
SCM+FSA) +* (halt SCM+FSA .--> goto (m + card I)))* ProgramPart Relocated
  (I, m);

canceled;

theorem :: SCMFSA6A:21
  for I,J being FinPartState of SCM+FSA holds ProgramPart
Relocated(I +* J, n) = ProgramPart Relocated(I,n) +* ProgramPart Relocated(J,n)
;

theorem :: SCMFSA6A:22
  ProgramPart Relocated(ProgramPart Relocated(I,m), n) =
  ProgramPart Relocated(I, m + n);

reserve a,b for Int-Location,
  f for FinSeq-Location,
  s,s1,s2 for State of SCM+FSA;

definition
  let I be PartState of SCM+FSA;
  func Initialized I -> PartState of SCM+FSA equals
:: SCMFSA6A:def 4
  I +* ((intloc 0) .--> 1) +* Start-At( 0,SCM+FSA);
end;

registration
  let I be FinPartState of SCM+FSA;
 cluster Initialized I -> finite;
end;

theorem :: SCMFSA6A:23
  InsCode i in {0,6,7,8} or Exec(i,s).IC SCM+FSA = succ IC s;

theorem :: SCMFSA6A:24
  IC SCM+FSA in dom Initialized I;

theorem :: SCMFSA6A:25
  IC Initialized I =  0;

theorem :: SCMFSA6A:26
  I c= Initialized I;

canceled 5;

theorem :: SCMFSA6A:32
  s1,s2 equal_outside NAT implies Exec(i,s1),Exec(i,s2) equal_outside
  NAT;

theorem :: SCMFSA6A:33
  (Initialized I)|NAT = I;

scheme :: SCMFSA6A:sch 1

  SCMFSAEx{ F(set) -> Element of the Instructions of SCM+FSA, G(set) ->
Integer, H(set) -> FinSequence of INT, I() -> Element of NAT }
: ex S being State of SCM+FSA st IC S = I() & for i being Element of NAT holds
  S. i = F(i) & S.intloc i = G(i) & S.fsloc i = H(i);

theorem :: SCMFSA6A:34
  for s being State of SCM+FSA holds dom s = Int-Locations \/
  FinSeq-Locations \/ {IC SCM+FSA} \/ NAT;

theorem :: SCMFSA6A:35
  for s being State of SCM+FSA, x being set st x in dom s holds x is
  Int-Location or x is FinSeq-Location or x = IC SCM+FSA or x is
  Element of NAT;

theorem :: SCMFSA6A:36
  for s1,s2 being State of SCM+FSA holds (for l being
  Element of NAT holds s1.l = s2.l) iff s1 | NAT = s2 | NAT;

theorem :: SCMFSA6A:37
  for i being Element of NAT holds not i in
  Int-Locations \/ FinSeq-Locations & not IC SCM+FSA in Int-Locations \/
  FinSeq-Locations;

theorem :: SCMFSA6A:38
  for s1,s2 being State of SCM+FSA holds ((for a being
Int-Location holds s1.a = s2.a) & for f being FinSeq-Location holds s1.f = s2.f
  ) iff DataPart s1 = DataPart s2;

theorem :: SCMFSA6A:39
  for s1,s2 being State of SCM+FSA st s1,s2 equal_outside NAT holds
  DataPart s1 = DataPart s2;

canceled;

theorem :: SCMFSA6A:41
  for s1,s2 being State of SCM+FSA, n being Element of NAT, i being
  Instruction of SCM+FSA holds IC s1 + n = IC s2 & DataPart s1 = DataPart s2
  implies IC Exec(i,s1) + n = IC Exec(IncAddr(i,n),s2) & DataPart Exec(i,s1) =
  DataPart Exec(IncAddr(i,n),s2);

canceled;

theorem :: SCMFSA6A:43
  for I being Program of SCM+FSA holds dom Initialized I = dom I
  \/ {intloc 0} \/ {IC SCM+FSA};

theorem :: SCMFSA6A:44
  for I being Program of SCM+FSA, x being set st x in dom
  Initialized I holds x in dom I or x = intloc 0 or x = IC SCM+FSA;

theorem :: SCMFSA6A:45
  for I being Program of SCM+FSA holds intloc 0 in dom Initialized
  I;

theorem :: SCMFSA6A:46
  for I being Program of SCM+FSA holds (Initialized I).intloc 0 =
  1 & (Initialized I).IC SCM+FSA =  0;

theorem :: SCMFSA6A:47
  for I being Program of SCM+FSA holds not intloc 0 in dom I & not
  IC SCM+FSA in dom I;

theorem :: SCMFSA6A:48
  for I being Program of SCM+FSA, a being Int-Location st a <>
  intloc 0 holds not a in dom Initialized I;

theorem :: SCMFSA6A:49
  for I being Program of SCM+FSA, f being FinSeq-Location holds
  not f in dom Initialized I;

theorem :: SCMFSA6A:50
  for I being Program of SCM+FSA, x being set st x in dom I holds
  I.x = (Initialized I).x;

theorem :: SCMFSA6A:51
  for I,J being Program of SCM+FSA for s being State of SCM+FSA st
  Initialized J c= s holds s +* Initialized I = s +* I;

theorem :: SCMFSA6A:52
  for I,J being Program of SCM+FSA for s being State of SCM+FSA st
  Initialized J c= s holds Initialized I c= s +* I;

theorem :: SCMFSA6A:53
  for I,J being Program of SCM+FSA for s being State of SCM+FSA holds s
  +* Initialized I, s +* Initialized J equal_outside NAT;

begin :: The composition of macroinstructions

definition
  let I,J be Program of SCM+FSA;
  func I ';' J -> Program of SCM+FSA equals
:: SCMFSA6A:def 5
  Directed I +* ProgramPart Relocated(J, card I);
end;

theorem :: SCMFSA6A:54
  for I,J being Program of SCM+FSA, l being Element of NAT
   st l in dom I & I.l <> halt SCM+FSA holds (I ';' J).l = I.l;

theorem :: SCMFSA6A:55
  for I,J being Program of SCM+FSA holds Directed I c= I ';' J;

theorem :: SCMFSA6A:56
  for I,J being Program of SCM+FSA holds dom I c= dom (I ';' J);

theorem :: SCMFSA6A:57
  for I,J being Program of SCM+FSA holds I +* (I ';' J) = (I ';' J);

theorem :: SCMFSA6A:58
  for I,J being Program of SCM+FSA holds Initialized I +* (I ';' J) =
  Initialized (I ';' J);

begin :: The compostion of instruction and macroinstructions

definition
  let i, J;
  func i ';' J -> Program of SCM+FSA equals
:: SCMFSA6A:def 6
  Macro i ';' J;
end;

definition
  let I, j;
  func I ';' j -> Program of SCM+FSA equals
:: SCMFSA6A:def 7
  I ';' Macro j;
end;

definition
  let i,j;
  func i ';' j -> Program of SCM+FSA equals
:: SCMFSA6A:def 8
  Macro i ';' Macro j;
end;

theorem :: SCMFSA6A:59
  i ';' j = Macro i ';' j;

theorem :: SCMFSA6A:60
  i ';' j = i ';' Macro j;

theorem :: SCMFSA6A:61
  card(I ';' J) = card I + card J;

registration
  let P be preProgram of SCM+FSA;
  let l be Element of NAT;
  cluster Directed(P,l) -> halt-free;
end;

registration
  let P be preProgram of SCM+FSA;
  cluster Directed P -> halt-free;
end;

canceled;

theorem :: SCMFSA6A:63
  for I being preProgram of SCM+FSA, l being Element of NAT
   holds I is halt-free implies Directed(I,l) = I;

theorem :: SCMFSA6A:64
  for I being preProgram of SCM+FSA, x being set, k being Element
of NAT holds x in dom ProgramPart Relocated(I,k) implies (ProgramPart Relocated
  (I,k)).x = Relocated(I,k).x;

theorem :: SCMFSA6A:65
  for I being preProgram of SCM+FSA, k being Element of NAT holds
  ProgramPart Relocated(Directed I,k) = Directed(ProgramPart Relocated(I,k),
   (card I + k));

theorem :: SCMFSA6A:66
  for I,J being Program of SCM+FSA holds Directed (I ';' J) = I
  ';' Directed J;

theorem :: SCMFSA6A:67
  I ';' J ';' K = I ';' (J ';' K);

theorem :: SCMFSA6A:68
  I ';' J ';' k = I ';' (J ';' k);

theorem :: SCMFSA6A:69
  I ';' j ';' K = I ';' (j ';' K);

theorem :: SCMFSA6A:70
  I ';' j ';' k = I ';' (j ';' k);

theorem :: SCMFSA6A:71
  i ';' J ';' K = i ';' (J ';' K);

theorem :: SCMFSA6A:72
  i ';' J ';' k = i ';' (J ';' k);

theorem :: SCMFSA6A:73
  i ';' j ';' K = i ';' (j ';' K);

theorem :: SCMFSA6A:74
  i ';' j ';' k = i ';' (j ';' k);


