:: Bounding boxes for compact sets in ${\calE}^2$
::  by Czes{\l}aw Byli\'nski and Piotr Rudnicki
::
:: Received July 29, 1997
:: Copyright (c) 1997 Association of Mizar Users

environ

 vocabulary AMI_1, FREEALG, HAHNBAN, COMPTS_1, BOOLE, FINSET_1, ZFMISC_1,
      SETFAM_1, FUNCT_1, RELAT_1, ABSVALUE, ARYTM_1, SEQ_1, SEQ_2, ORDINAL2,
      LATTICES, ARYTM_3, SEQ_4, PRE_TOPC, RCOMP_1, FUNCOP_1, PRALG_1, SUBSET_1,
      NEWTON, INT_1, REALSET1, LIMFUNC1, PCOMPS_1, EUCLID, TOPREAL1, FUNCT_5,
      MCART_1, PSCOMP_1, ARYTM, MEMBERED;
 notation TARSKI, XBOOLE_0, SUBSET_1, ORDINAL1, NUMBERS, XCMPLX_0, XREAL_0,
      SETFAM_1, FINSET_1, STRUCT_0, FINSOP_1, ABSVALUE, REAL_1, NAT_1, INT_1,
      MEMBERED, RELAT_1, FUNCT_1, FUNCT_2, SEQ_1, SEQ_2, AMI_1, SEQ_4, RCOMP_1,
      LIMFUNC1, PRE_TOPC, TOPS_2, COMPTS_1, PCOMPS_1, EUCLID, TOPREAL1;
 constructors REAL_1, TOPS_2, NAT_1, INT_1, FINSOP_1, ABSVALUE, SEQ_2, SEQ_4,
      AMI_1, RCOMP_1, COMPTS_1, LIMFUNC1, TOPREAL1, SEQM_3, TSP_1, PCOMPS_1,
      XCMPLX_0, XREAL_0, MEMBERED, RELSET_1, PARTFUN1, XBOOLE_0;
 clusters NUMBERS, SUBSET_1, STRUCT_0, PRE_TOPC, RCOMP_1, SEQM_3, EUCLID,
      PCOMPS_1, FUNCT_1, XREAL_0, RELSET_1, SEQ_1, REAL_1, SETFAM_1, INT_1,
      XBOOLE_0, SEQ_2, NAT_1, MEMBERED, RELAT_1, FUNCT_2, ZFMISC_1, ORDINAL2;
 requirements REAL, NUMERALS, BOOLE, SUBSET, ARITHM;


begin :: Preliminaries

notation let X be set;
 synonym X is without_zero for X is with_non-empty_elements ;
 antonym X is with_zero for X is with_non-empty_elements ;
end;
definition let X be set;
 redefine attr X is without_zero means
:: PSCOMP_1:def 1
 not 0 in X;
 end;


registration
 cluster REAL -> with_zero;
 coherence by Def1;
 cluster NAT -> with_zero;
 coherence by Def1;
end;


registration
 cluster non empty without_zero set;
 existence proof set s = {1};
  take s;
  thus s is non empty; not 0 in s by TARSKI:def 1;
  hence s is without_zero by Def1;
 end;
 cluster non empty with_zero set;
 existence by Def1;
end;


registration
 cluster non empty without_zero Subset of REAL;
 existence proof set s = {1 qua Real};
  take s;
  thus s is non empty; not 0 in s by TARSKI:def 1;
  hence s is without_zero by Def1;
 end;
 cluster non empty with_zero Subset of REAL;
 existence by Def1;
end;


theorem :: PSCOMP_1:1
 for F being set st F is non empty with_non-empty_elements c=-linear
  holds F is centered;

registration let F be set;
 cluster non empty with_non-empty_elements c=-linear
          -> centered Subset-Family of F;
  coherence by Th1;
end;


definition let A, B be set, f be Function of A, B;
 redefine func rng f -> Subset of B;
end;


registration let X, Y be non empty set, f be Function of X, Y;
   :: see WAYBEL_2
 cluster f.:X -> non empty;
coherence proof
    consider x being Element of X;
A1: dom f = X by FUNCT_2:def 1;
    then f.x in rng f by FUNCT_1:def 5;
    hence thesis by A1,FUNCT_1:def 12;
  end;
end;


definition let X, Y be set, f be Function of X, Y;
 func "f -> Function of bool Y, bool X means
:: PSCOMP_1:def 2
 :: see FUNCT_3:def 2
 for y being Subset of Y holds it.y = f"y;
end;


theorem :: PSCOMP_1:2
for X, Y, x being set, S being Subset of bool Y, f being Function of X, Y
 st x in meet (("f).:S) holds f.x in meet S;

 reserve r, s, t, t' for real number;

theorem :: PSCOMP_1:3
 abs r + abs s = 0 implies r = 0;

theorem :: PSCOMP_1:4
r < s & s < t implies abs s < abs r + abs t;

theorem :: PSCOMP_1:5
-s < r & r < s implies abs r < s;

 reserve seq for Real_Sequence,
         X, Y for Subset of REAL;

theorem :: PSCOMP_1:6
seq is convergent & seq is_not_0 & lim seq = 0 implies seq" is non bounded;

theorem :: PSCOMP_1:7
rng seq is bounded iff seq is bounded;

notation let X be real-membered set;
 synonym sup X for upper_bound X; synonym inf X for lower_bound X; end;


definition let X be Subset of REAL;
 redefine func sup X -> Element of REAL;
 redefine func inf X -> Element of REAL;
end;


theorem :: PSCOMP_1:8
 for X being non empty real-membered set
 for t st for s st s in X holds s >= t holds inf X >= t;

theorem :: PSCOMP_1:9
for X being non empty real-membered set
 st (for s st s in X holds s >= r) &
    for t st for s st s in X holds s >= t holds r >= t
  holds r = inf X;

theorem :: PSCOMP_1:10
for X being non empty real-membered set, r
 for t st for s st s in X holds s <= t holds sup X <= t;

theorem :: PSCOMP_1:11
for X being non empty real-membered set, r
 st (for s st s in X holds s <= r) &
    for t st for s st s in X holds s <= t holds r <= t
  holds r = sup X;

theorem :: PSCOMP_1:12
 for X being non empty real-membered set, Y being real-membered set
  st X c= Y & Y is bounded_below holds inf Y <= inf X;

theorem :: PSCOMP_1:13
 for X being non empty real-membered set, Y being real-membered set
  st X c= Y & Y is bounded_above holds sup X <= sup Y;

definition let X be real-membered set;
 attr X is with_max means
:: PSCOMP_1:def 3
 X is bounded_above & sup X in X;
 attr X is with_min means
:: PSCOMP_1:def 4
 X is bounded_below & inf X in X;
end;


registration
 cluster non empty closed bounded Subset of REAL;
 existence proof
   reconsider 0r = 0 as Real;
     [.0,0.]={0} & [.0,0.] is closed & {0r} is bounded by RCOMP_1:14,23,SEQ_4:
15
;
  hence thesis;
 end;
end;


definition let R be Subset-Family of REAL;
  attr R is open means
:: PSCOMP_1:def 5
 for X being Subset of REAL st X in R holds X is open;
  attr R is closed means
:: PSCOMP_1:def 6
 for X being Subset of REAL st X in R holds X is closed;
end;


 reserve p, q, r3, r1, r2, q3, p3 for Real;

definition let X be Subset of REAL;
 func -X -> Subset of REAL equals
:: PSCOMP_1:def 7
 { -r3 : r3 in X};
 involutiveness;
end;


theorem :: PSCOMP_1:14
r in X iff -r in -X;

registration let X be non empty Subset of REAL;
 cluster -X -> non empty;
 coherence proof
     ex x being Real st x in X by SUBSET_1:10;
  hence thesis by Th14;
 end;
end;

theorem :: PSCOMP_1:15
X is bounded_above iff -X is bounded_below;

theorem :: PSCOMP_1:16
  X is bounded_below iff -X is bounded_above;

theorem :: PSCOMP_1:17
for X being non empty Subset of REAL
 st X is bounded_below holds inf X = - sup -X;

theorem :: PSCOMP_1:18
for X being non empty Subset of REAL
 st X is bounded_above holds sup X = - inf -X;

theorem :: PSCOMP_1:19
X is closed iff -X is closed;

definition let X be Subset of REAL, p be Real;
 func p+X -> Subset of REAL equals
:: PSCOMP_1:def 8
 { p+r3 : r3 in X};
end;


theorem :: PSCOMP_1:20
r in X iff q3+r in q3+X;

registration let X be non empty Subset of REAL, s be Real;
 cluster s+X -> non empty;
 coherence proof ex x being Real st x in X by SUBSET_1:10;
  hence thesis by Th20;
 end;
end;


theorem :: PSCOMP_1:21
X = 0+X;

theorem :: PSCOMP_1:22
q3+(p3+X) = (q3+p3)+X;

theorem :: PSCOMP_1:23
  X is bounded_above iff q3+X is bounded_above;

theorem :: PSCOMP_1:24
  X is bounded_below iff q3+X is bounded_below;

theorem :: PSCOMP_1:25
  for X being non empty Subset of REAL
 st X is bounded_below holds inf (q3+X) = q3+inf X;

theorem :: PSCOMP_1:26
  for X being non empty Subset of REAL
 st X is bounded_above holds sup (q3+X) = q3+sup X;

theorem :: PSCOMP_1:27
X is closed iff q3+X is closed;

definition let X be Subset of REAL;
 func Inv X -> Subset of REAL equals
:: PSCOMP_1:def 9
 { 1/r3 : r3 in X};
end;


theorem :: PSCOMP_1:28
for X being without_zero Subset of REAL holds r in X iff 1/r in Inv X;

registration let X be non empty without_zero Subset of REAL;
 cluster Inv X -> non empty without_zero;
 coherence proof consider x being Real such that
 A1: x in X by SUBSET_1:10;
 A2: not 0 in X by Def1;
  thus Inv X is non empty by A1,Th28;
     now assume
 A3: 0 in Inv X;
      Inv X = {1/r3 : r3 in X} by Def9;
    then ex r3 st 0 = 1/r3 & r3 in X by A3;
    hence contradiction by A2,XCMPLX_1:62;
   end;
  hence thesis by Def1;
 end;
end;


registration let X be without_zero Subset of REAL;
 cluster Inv X -> without_zero;
 coherence proof
 A1: not 0 in X by Def1;
     now assume
 A2: 0 in Inv X;
      Inv X = {1/r3 : r3 in X} by Def9;
    then ex r3 st 0 = 1/r3 & r3 in X by A2;
    hence contradiction by A1,XCMPLX_1:62;
   end;
  hence thesis by Def1;
 end;
end;


theorem :: PSCOMP_1:29
for X being without_zero Subset of REAL holds Inv Inv X = X;

theorem :: PSCOMP_1:30
  for X being without_zero Subset of REAL
 st X is closed & X is bounded holds Inv X is closed;

theorem :: PSCOMP_1:31
 for Z being Subset-Family of REAL st Z is closed holds meet Z is closed;

definition let X be Subset of REAL;
 func Cl X -> Subset of REAL equals
:: PSCOMP_1:def 10
 meet { A where A is Element of bool REAL : X c= A & A is closed };
 projectivity;
end;


registration let X be Subset of REAL;
 cluster Cl X -> closed;
 coherence proof
   defpred P[Element of bool REAL] means X c= $1 & $1 is closed;
   deffunc F(Element of bool REAL) = $1;
   reconsider Z = { F(A) where A is Element of bool REAL : P[A] }
   as Subset of bool REAL from COMPLSP1:sch 3;
   reconsider Z as Subset-Family of REAL by SETFAM_1:def 7;
A1: Z is closed proof let Y be Subset of REAL; assume Y in Z;
     then ex A being Element of bool REAL st Y = A & X c= A & A is closed;
    hence Y is closed;
   end;
     Cl X = meet Z by Def10;
  hence thesis by A1,Th31;
 end;
end;


theorem :: PSCOMP_1:32
 for Y being closed Subset of REAL st X c= Y holds Cl X c= Y;

theorem :: PSCOMP_1:33
X c= Cl X;

theorem :: PSCOMP_1:34
X is closed iff X = Cl X;

theorem :: PSCOMP_1:35
   Cl ({}REAL) = {};

theorem :: PSCOMP_1:36
   Cl ([#]REAL) = REAL;

theorem :: PSCOMP_1:37
  X c= Y implies Cl X c= Cl Y;

theorem :: PSCOMP_1:38
r3 in Cl X iff for O being open Subset of REAL st r3 in
 O holds O /\ X is non empty;

theorem :: PSCOMP_1:39
r3 in Cl X implies ex seq st rng seq c= X & seq is convergent & lim seq = r3;

begin :: Functions into Reals

definition let X be set, f be Function of X, REAL;
 redefine attr f is bounded_below means
:: PSCOMP_1:def 11
 f.:X is bounded_below;
 attr f is bounded_above means
:: PSCOMP_1:def 12
  f.:X is bounded_above;
end;


definition let X be set, f be Function of X, REAL;
 canceled;
 attr f is with_max means
:: PSCOMP_1:def 14
 f.:X is with_max;
 attr f is with_min means
:: PSCOMP_1:def 15
 f.:X is with_min;
end;


definition let X be set, f be Function of X, REAL;
 func -f -> Function of X, REAL means
:: PSCOMP_1:def 16
 for p being set st p in X holds it.p = -(f.p);
 involutiveness;
end;


theorem :: PSCOMP_1:40
 for X, A being set, f being Function of X, REAL holds (-f).:A = -(f.:A);

theorem :: PSCOMP_1:41
for X being non empty set, f being Function of X, REAL
 holds f is with_min iff -f is with_max;

theorem :: PSCOMP_1:42
  for X being non empty set, f being Function of X, REAL
 holds f is with_max iff -f is with_min;

theorem :: PSCOMP_1:43
for X being set, A being Subset of REAL, f being Function of X, REAL
 holds (-f)"A = f"(-A);

definition let X be set, r be Real, f be Function of X, REAL;
 func r+f -> Function of X, REAL means
:: PSCOMP_1:def 17
 for p being set st p in X holds it.p = r+f.p;
end;


theorem :: PSCOMP_1:44
   for X, A being set, f being Function of X, REAL, s being Real
  holds (s+f).:A = s+(f.:A);

theorem :: PSCOMP_1:45
for X being set, A being Subset of REAL, f being Function of X, REAL, q3
 holds (q3+f)"A = f"(-q3+A);

definition let X be set, f be Function of X, REAL;
 func Inv f -> Function of X, REAL means
:: PSCOMP_1:def 18
 for p being set st p in X holds it.p = 1/(f.p);
 involutiveness;
end;


theorem :: PSCOMP_1:46
for X being set, A being without_zero Subset of REAL,
    f being Function of X, REAL holds (Inv f)"A = f"(Inv A);

begin :: Real maps

definition let T be 1-sorted;
 mode RealMap of T is Function of the carrier of T, REAL;
 canceled;
end;


registration let T be non empty 1-sorted;
 cluster bounded RealMap of T;
 existence proof set c = (the carrier of T);
  reconsider f = c --> (0 qua Real) as RealMap of T;
  take f;
A1: dom f = c by FUNCT_2:def 1;
    rng f = {0 qua Real} by FUNCOP_1:14;
  then f.:c = {0 qua Real} by A1,RELAT_1:146;
then A2: f.:c is bounded by SEQ_4:15;
  hence f.:c is bounded_above by SEQ_4:def 3;
  thus f.:c is bounded_below by A2,SEQ_4:def 3;
 end;
end;


scheme :: PSCOMP_1:sch 1
 NonUniqExRF{X() -> non empty TopStruct, P[set,set]}:
  ex f being RealMap of X() st
    for x being Element of X() holds P[x, f.x]
provided
 for x being set st x in the carrier of X() ex r3 st P[x, r3]
proof
  defpred Q[set,set] means P[$1,$2];
A2: for x being set st x in the carrier of X()
     ex y being set st y in REAL & Q[x,y]
   proof let x be set;
    assume x in the carrier of X();
    then ex r3 st P[x, r3] by A1;
    hence thesis;
   end;
  consider f being Function of the carrier of X(),REAL such that
A3: for x being set st x in the carrier of X() holds Q[x,f.x]
   from FUNCT_2:sch 1(A2);
  reconsider f as RealMap of X();
  take f;
  thus thesis by A3;
 end;

scheme :: PSCOMP_1:sch 2
 LambdaRF{X() -> non empty TopStruct, F(set) -> Real}:
ex f being RealMap of X() st
 for x being Element of X() holds f.x = F(x)
proof
  defpred P[set,set] means $2 = F($1);
A1: for x being set st x in the carrier of X() ex r3 st P[x,r3];
  thus ex f be RealMap of X() st for x be Element of X() holds
   P[x,f.x] from NonUniqExRF(A1);
 end;

definition let T be 1-sorted, f be RealMap of T, P be set;
 redefine func f"P -> Subset of T;
end;


definition let T be 1-sorted, f be RealMap of T;
 func inf f -> Real equals
:: PSCOMP_1:def 20
 inf (f.:the carrier of T);
 func sup f -> Real equals
:: PSCOMP_1:def 21
 sup (f.:the carrier of T);
end;


theorem :: PSCOMP_1:47
for T being non empty TopSpace, f being bounded_below RealMap of T
 for p being Point of T holds f.p >= inf f;

theorem :: PSCOMP_1:48
  for T being non empty TopSpace, f being bounded_below RealMap of T
 for s being Real st for t being Point of T holds f.t >= s holds inf f >= s;

theorem :: PSCOMP_1:49
  for T being non empty TopSpace, f being RealMap of T
  st (for p being Point of T holds f.p >= r) &
   for t st for p being Point of T holds f.p >= t holds r >= t
 holds r = inf f;

theorem :: PSCOMP_1:50
for T being non empty TopSpace, f being bounded_above RealMap of T
 for p being Point of T holds f.p <= sup f;

theorem :: PSCOMP_1:51
  for T being non empty TopSpace, f being bounded_above RealMap of T
 for t st for p being Point of T holds f.p <= t holds sup f <= t;

theorem :: PSCOMP_1:52
  for T being non empty TopSpace, f being RealMap of T
   st (for p being Point of T holds f.p <= r) &
      (for t st for p being Point of T holds f.p <= t holds r <= t)
 holds r = sup f;

theorem :: PSCOMP_1:53
 for T being non empty 1-sorted, f being bounded RealMap of T
  holds inf f <= sup f;



definition let T be TopStruct, f be RealMap of T;
 canceled 3;
 attr f is continuous means
:: PSCOMP_1:def 25
 for Y being Subset of REAL st Y is closed holds f"Y is closed;
end;


registration let T be non empty TopSpace;
 cluster continuous RealMap of T;
 existence proof set c = (the carrier of T);
  reconsider f = c --> (0 qua Real) as RealMap of T;
  take f;
A1: dom f = c by FUNCT_2:def 1;
A2: rng f = {0 qua Real} by FUNCOP_1:14;
  let Y be Subset of REAL; assume Y is closed;
  per cases;
  suppose 0 in Y;
  then A3: rng f c= Y by A2,ZFMISC_1:37;
        f"Y = f"(rng f /\ Y) by RELAT_1:168
         .= f"rng f by A3,XBOOLE_1:28
         .= c by A1,RELAT_1:169
         .= [#]T by PRE_TOPC:12;
   hence f"Y is closed;
  end;
  suppose not 0 in Y;
then A4:    rng f misses Y by A2,ZFMISC_1:56;
        f"Y = f"(rng f /\ Y) by RELAT_1:168
         .= f"{} by A4,XBOOLE_0:def 7
         .= {}T by RELAT_1:171;
   hence f"Y is closed by TOPS_1:22;
 end;
 end;
end;


registration let T be non empty TopSpace, S be non empty SubSpace of T;
 cluster continuous RealMap of S;
 existence proof set c = (the carrier of S);
  reconsider f = c --> (0 qua Real) as RealMap of S;
  take f;
A1: dom f = c by FUNCT_2:def 1;
A2: rng f = {0 qua Real} by FUNCOP_1:14;
  let Y be Subset of REAL; assume Y is closed;
  per cases;
  suppose 0 in Y;
  then A3: rng f c= Y by A2,ZFMISC_1:37;
        f"Y = f"(rng f /\ Y) by RELAT_1:168
         .= f"rng f by A3,XBOOLE_1:28
         .= c by A1,RELAT_1:169
         .= [#]S by PRE_TOPC:12;
   hence f"Y is closed;
  end;
  suppose not 0 in Y;
then A4:    rng f misses Y by A2,ZFMISC_1:56;
        f"Y = f"(rng f /\ Y) by RELAT_1:168
         .= f"{} by A4,XBOOLE_0:def 7
         .= {}S by RELAT_1:171;
   hence f"Y is closed by TOPS_1:22;
 end;
 end;
end;


 reserve T for TopStruct,
         f for RealMap of T;

theorem :: PSCOMP_1:54
f is continuous iff for Y being Subset of REAL st Y is open holds f"Y is open;

theorem :: PSCOMP_1:55
f is continuous implies -f is continuous;

theorem :: PSCOMP_1:56
f is continuous implies r3+f is continuous;

theorem :: PSCOMP_1:57
 f is continuous & not 0 in rng f implies Inv f is continuous;

definition let X, Y be set, f be Function of bool X, bool Y;
           let R be Subset-Family of X;
  redefine func f.:R -> Subset-Family of Y;
end;


theorem :: PSCOMP_1:58
  for R being Subset-Family of REAL
 st f is continuous & R is open holds ("f).:R is open;

theorem :: PSCOMP_1:59
for R being Subset-Family of REAL
 st f is continuous & R is closed holds ("f).:R is closed;

definition let T be non empty TopStruct, X be Subset of T,
               f be RealMap of T;
 func f||X -> RealMap of T|X equals
:: PSCOMP_1:def 26
 f|X;
end;


registration let T be non empty TopSpace;
 cluster compact non empty Subset of T;
 existence proof
  consider x being Point of T;
  take {x};
  thus thesis by BORSUK_1:41;
 end;
end;


registration let T be non empty TopSpace, f be continuous RealMap of T,
               X be Subset of T;
 cluster f||X -> continuous;
 coherence proof
    now let Y be Subset of REAL; assume
     Y is open;
  then A1: f"Y is open by Th54;
  A2: the carrier of (T|X) = X by JORDAN1:1;
       (f||X)"Y = (f|X)"Y by Def26 .= X/\(f"Y) by FUNCT_1:139;
   hence (f||X)"Y is open by A1,A2,TSP_1:def 1;
  end;
  hence thesis by Th54;
 end;
end;


registration let T be non empty TopSpace, P be compact non empty Subset of T;
 cluster T|P -> compact;
 coherence by COMPTS_1:12;
end;


begin :: Pseudocompact spaces

theorem :: PSCOMP_1:60
 for T being non empty TopSpace
  holds
   (for f being RealMap of T st f is continuous holds f is with_max)
 iff
   (for f being RealMap of T st f is continuous holds f is with_min);

theorem :: PSCOMP_1:61
for T being non empty TopSpace
  holds
   (for f being RealMap of T st f is continuous holds f is bounded)
 iff
   (for f being RealMap of T st f is continuous holds f is with_max);

definition let T be TopStruct;
 attr T is pseudocompact means
:: PSCOMP_1:def 27

 for f being RealMap of T st f is continuous holds f is bounded;
end;


registration
 cluster compact -> pseudocompact (non empty TopSpace);
 coherence proof let T be non empty TopSpace;
  assume that
A1: T is compact;
  let f be RealMap of T such that
A2: f is continuous;
  thus f is bounded_above
  proof
  assume
A3: for s be real number ex r be real number
       st r in f.:(the carrier of T) & r > s;
    consider p being Element of T;
    defpred P[Real] means $1 >= f.p;
    deffunc F(Real) = right_closed_halfline($1);
    set R = {F(r3) : P[r3]};
A4: R is Subset of bool REAL from COMPLSP1:sch 3;
A5: right_closed_halfline(f.p) in R;
    then reconsider R as non empty Subset-Family of REAL by A4,SETFAM_1:def 7;
    reconsider F = ("f).:R as Subset-Family of T;
A6: ("f).right_closed_halfline(f.p) in F by A5,FUNCT_2:43;
      now assume {} in F; then consider rchx being set such that
    A7: rchx in bool REAL and
    A8: rchx in R and
    A9: {} = ("f).rchx by FUNCT_2:115;
        consider r3 being Real such that
    A10: rchx = right_closed_halfline(r3) & r3 >= f.p by A8;
    A11: {} = f"rchx by A7,A9,Def2;
        consider r1 being real number such that
    A12: r1 in f.:(the carrier of T) and
    A13: r1 > r3 by A3;
        consider c being set such that
    A14: c in the carrier of T & c in the carrier of T and
    A15: r1 = f.c by A12,FUNCT_2:115;
A16:  r1 is Real by XREAL_0:def 1;
          rchx = {g where g is Real : g >= r3} by A10,LIMFUNC1:def 2;
        then r1 in rchx by A13,A16;
     hence contradiction by A11,A14,A15,FUNCT_2:46;
    end;
then A17: F is with_non-empty_elements by AMI_1:def 1;
      F is c=-linear proof let X,Y be set;
     assume X in F;
        then consider A being set such that
    A18: A in bool REAL and
    A19: A in R and
    A20: X = ("f).A by FUNCT_2:115;
        consider r1 such that
    A21: A = right_closed_halfline(r1) and r1 >= f.p by A19;
     assume Y in F;
        then consider B being set such that
    A22: B in bool REAL and
    A23: B in R and
    A24: Y = ("f).B by FUNCT_2:115;
        consider r2 such that
    A25: B = right_closed_halfline(r2) and r2 >= f.p by A23;
          r1 >= r2 or r2 >= r1;
    then A26: A c= B or B c= A by A21,A25,LIMFUNC1:9;
          X = f"A & Y = f"B by A18,A20,A22,A24,Def2;
     then X c= Y or Y c= X by A26,RELAT_1:178;
     hence thesis by XBOOLE_0:def 9;
    end;
then A27: F is centered by A6,A17,Th1;
      R is closed proof let X be Subset of REAL;
     assume X in R;
        then ex r3 st X = right_closed_halfline(r3) & r3 >= f.p;
     hence X is closed by FCONT_3:5;
    end;
    then F is closed by A2,Th59;
    then meet F <> {} by A1,A27,COMPTS_1:13;
    then consider x being set such that
A28:  x in meet F by XBOOLE_0:def 1;
    reconsider x as Element of T by A28;
A29: f.x in meet R by A28,Th2;
    consider eR being Element of R;
A30: f.x in eR by A29,SETFAM_1:def 1;
      eR in R; then consider er being Real such that
A31: eR = right_closed_halfline(er) & er >= f.p;
      right_closed_halfline(er) = {r3:r3>=er} by LIMFUNC1:def 2;
    then consider r1 being Real such that
A32: f.x = r1 & r1 >= er by A30,A31;
A33: f.x >= f.p by A31,A32,AXIOMS:22;
    consider fx' being real number such that
A34:  fx' > f.x by REAL_1:76;
    reconsider fx' as Real by XREAL_0:def 1;
      fx' >= f.p by A33,A34,AXIOMS:22;
    then right_closed_halfline(fx') in R;
then A35:  f.x in right_closed_halfline(fx') by A29,SETFAM_1:def 1;
      right_closed_halfline(fx') = {r3:r3>=fx'} by LIMFUNC1:def 2;
    then ex r3 st f.x = r3 & r3 >= fx' by A35;
  hence contradiction by A34;
  end;
  assume
A36: for s be real number ex r3 be real number st
      r3 in f.:(the carrier of T) & r3 < s;
    consider p being Element of T;
    defpred P[Real] means $1 <= f.p;
    deffunc F(Real) = left_closed_halfline($1);
    set R = {F(r3): P[r3]};
A37: R is Subset of bool REAL from COMPLSP1:sch 3;
A38: left_closed_halfline(f.p) in R;
    then reconsider R as non empty Subset-Family of REAL by A37,SETFAM_1:def 7;
    reconsider F = ("f).:R as Subset-Family of T;
    A39: ("f).left_closed_halfline(f.p) in F by A38,FUNCT_2:43;
      now assume {} in F; then consider rchx being set such that
    A40: rchx in bool REAL and
    A41: rchx in R and
    A42: {} = ("f).rchx by FUNCT_2:115;
        consider r3 being Real such that
    A43: rchx = left_closed_halfline(r3) & r3 <= f.p by A41;
    A44: {} = f"rchx by A40,A42,Def2;
        consider r1 being real number such that
    A45: r1 in f.:(the carrier of T) and
    A46: r1 < r3 by A36;
        consider c being set such that
    A47: c in the carrier of T & c in the carrier of T and
    A48: r1 = f.c by A45,FUNCT_2:115;
A49:  r1 is Real by XREAL_0:def 1;
          rchx = {g where g is Real : g <= r3} by A43,LIMFUNC1:def 1;
        then r1 in rchx by A46,A49;
     hence contradiction by A44,A47,A48,FUNCT_2:46;
    end;
then A50: F is with_non-empty_elements by AMI_1:def 1;
      F is c=-linear proof let X,Y be set;
     assume X in F;
        then consider A being set such that
    A51: A in bool REAL and
    A52: A in R and
    A53: X = ("f).A by FUNCT_2:115;
        consider r1 such that
    A54: A = left_closed_halfline(r1) and r1 <= f.p by A52;
     assume Y in F;
        then consider B being set such that
    A55: B in bool REAL and
    A56: B in R and
    A57: Y = ("f).B by FUNCT_2:115;
        consider r2 such that
    A58: B = left_closed_halfline(r2) and r2 <= f.p by A56;
          r1 <= r2 or r2 <= r1;
    then A59: A c= B or B c= A by A54,A58,LIMFUNC1:14;
          X = f"A & Y = f"B by A51,A53,A55,A57,Def2;
     then X c= Y or Y c= X by A59,RELAT_1:178;
     hence thesis by XBOOLE_0:def 9;
    end;
then A60: F is centered by A39,A50,Th1;
      R is closed proof let X be Subset of REAL;
     assume X in R;
        then ex r3 st X = left_closed_halfline(r3) & r3 <= f.p;
     hence X is closed by FCONT_3:6;
    end;
    then F is closed by A2,Th59;
    then meet F <> {} by A1,A60,COMPTS_1:13;
    then consider x being set such that
A61:  x in meet F by XBOOLE_0:def 1;
    reconsider x as Element of T by A61;
A62: f.x in meet R by A61,Th2;
    consider eR being Element of R;
A63: f.x in eR by A62,SETFAM_1:def 1;
      eR in R; then consider er being Real such that
A64: eR = left_closed_halfline(er) & er <= f.p;
      left_closed_halfline(er) = {r3 : r3 <= er} by LIMFUNC1:def 1;
    then consider r1 being Real such that
A65: f.x = r1 & r1 <= er by A63,A64;
A66: f.x <= f.p by A64,A65,AXIOMS:22;
    consider fx' being real number such that
A67:  fx' < f.x by REAL_1:77;
    reconsider fx' as Real by XREAL_0:def 1;
      fx' <= f.p by A66,A67,AXIOMS:22;
    then left_closed_halfline(fx') in R;
then A68:  f.x in left_closed_halfline(fx') by A62,SETFAM_1:def 1;
      left_closed_halfline(fx') = {r3 : r3 <= fx'} by LIMFUNC1:def 1;
    then ex r3 st f.x = r3 & r3 <= fx' by A68;
  hence contradiction by A67;
 end;
end;


registration
 cluster compact non empty TopSpace;
 existence proof
  take 1TopSp {{}};
  thus thesis by PCOMPS_1:9;
 end;
end;


registration let T be pseudocompact non empty TopSpace;
 cluster continuous -> bounded with_max with_min RealMap of T;
 coherence proof let f be RealMap of T; assume
A1: f is continuous;
  hence f is bounded by Def27;
  A2: for f being RealMap of T st f is continuous holds f is bounded by Def27;
  then A3:for f being RealMap of T st f is continuous holds f is with_max by
Th61;
  thus f is with_max by A1,A2,Th61;
  thus f is with_min by A1,A3,Th60;
 end;
end;


theorem :: PSCOMP_1:62
for T being non empty TopSpace, X being non empty Subset of T,
    Y being compact Subset of T, f being continuous RealMap of T
 st X c= Y holds inf (f||Y) <= inf (f||X);

theorem :: PSCOMP_1:63
for T being non empty TopSpace, X being non empty Subset of T,
    Y being compact Subset of T, f being continuous RealMap of T
 st X c= Y holds sup (f||X) <= sup (f||Y);

begin :: Bounding boxes of compact sets in TOP-REAL 2

registration let n be Nat; let p1, p2 be Point of TOP-REAL n;
 cluster LSeg(p1,p2) -> compact;
 coherence by SPPOL_1:28;
end;


theorem :: PSCOMP_1:64
for n being Nat, X, Y being compact Subset of TOP-REAL n
 holds X /\ Y is compact;

 reserve p for Point of TOP-REAL 2,
         P for Subset of TOP-REAL 2,
         Z for non empty Subset of TOP-REAL 2,
         X for non empty compact Subset of TOP-REAL 2;

definition
 func proj1 -> RealMap of TOP-REAL 2 means
:: PSCOMP_1:def 28
 for p being Point of TOP-REAL 2 holds it.p = p`1;
 func proj2 -> RealMap of TOP-REAL 2 means
:: PSCOMP_1:def 29
 for p being Point of TOP-REAL 2 holds it.p = p`2;
end;


theorem :: PSCOMP_1:65
proj1"].r,s.[ = {|[ r1, r2 ]| : r < r1 & r1 < s};

theorem :: PSCOMP_1:66
for r3, q3 st P = {|[ r1, r2 ]| : r3 < r1 & r1 < q3} holds P is open;

theorem :: PSCOMP_1:67
proj2"].r,s.[ = {|[ r1, r2 ]| : r < r2 & r2 < s};

theorem :: PSCOMP_1:68
for r3, q3 st P = {|[ r1, r2 ]| : r3 < r2 & r2 < q3} holds P is open;

registration
 cluster proj1 -> continuous;
 coherence proof
   now let Y be Subset of REAL; assume
 A1: Y is open;
  set p1Y = (proj1"Y);
     now let x be set;
    hereby assume
   A2: x in p1Y;
       then reconsider p = x as Point of TOP-REAL 2;
       set p1 = proj1.p;
         p1 in Y by A2,FUNCT_2:46; then consider g being real number such that
   A3: 0<g and
   A4: ].p1-g,p1+g.[ c= Y by A1,RCOMP_1:40;
       reconsider g as Real by XREAL_0:def 1;
   A5: p1 < p1+g by A3,REAL_1:69;
   then A6: p1-g < p1 by REAL_1:84;
         ].p1-g,p1+g.[ = {r3 : p1-g<r3 & r3<p1+g} by RCOMP_1:def 2;
   then A7: p1 in ].p1-g,p1+g.[ by A5,A6;
     reconsider Q = proj1"].p1-g,p1+g.[
                      as Subset of TOP-REAL 2;
     take Q;
       Q = {|[ q3,p3 ]|: p1-g < q3 & q3 < p1+g} by Th65;
     hence Q is open by Th66;
     thus Q c= p1Y by A4,RELAT_1:178;
     thus x in Q by A7,FUNCT_2:46;
    end;
    assume ex Q being Subset of TOP-REAL 2 st Q is open & Q c= p1Y & x in Q;
    hence x in p1Y;
   end;
  hence p1Y is open by TOPS_1:57;
  end;
  hence thesis by Th54;
 end;
 cluster proj2 -> continuous;
 coherence proof now let Y be Subset of REAL; assume
 A8: Y is open;
  set p1Y = (proj2"Y);
     now let x be set;
    hereby assume
   A9: x in p1Y;
       then reconsider p = x as Point of TOP-REAL 2;
       set p1 = proj2.p;
         p1 in Y by A9,FUNCT_2:46; then consider g being real number such that
   A10: 0<g and
   A11: ].p1-g,p1+g.[ c= Y by A8,RCOMP_1:40;
       reconsider g as Real by XREAL_0:def 1;
   A12: p1 < p1+g by A10,REAL_1:69;
   then A13: p1-g < p1 by REAL_1:84;
         ].p1-g,p1+g.[ = {r3 : p1-g<r3 & r3<p1+g} by RCOMP_1:def 2;
   then A14: p1 in ].p1-g,p1+g.[ by A12,A13;
     reconsider Q = proj2"].p1-g,p1+g.[
                      as Subset of TOP-REAL 2;
     take Q;
       Q = {|[ q3,p3 ]|: p1-g < p3 & p3 < p1+g} by Th67;
     hence Q is open by Th68;
     thus Q c= p1Y by A11,RELAT_1:178;
     thus x in Q by A14,FUNCT_2:46;
    end;
    assume ex Q being Subset of TOP-REAL 2 st Q is open & Q c= p1Y & x in Q;
    hence x in p1Y;
   end;
  hence p1Y is open by TOPS_1:57;
  end;
  hence thesis by Th54;
 end;
end;


theorem :: PSCOMP_1:69
 for X being Subset of TOP-REAL 2, p being Point of TOP-REAL 2
  st p in X holds (proj1||X).p = p`1;

theorem :: PSCOMP_1:70
 for X being Subset of TOP-REAL 2, p being Point of TOP-REAL 2
  st p in X holds (proj2||X).p = p`2;

definition let X be Subset of TOP-REAL 2;
 func W-bound X -> Real equals
:: PSCOMP_1:def 30
 inf (proj1||X);
 func N-bound X -> Real equals
:: PSCOMP_1:def 31
 sup (proj2||X);
 func E-bound X -> Real equals
:: PSCOMP_1:def 32
 sup (proj1||X);
 func S-bound X -> Real equals
:: PSCOMP_1:def 33
 inf (proj2||X);
end;


theorem :: PSCOMP_1:71
p in X implies W-bound X <= p`1 & p`1 <= E-bound X &
                 S-bound X <= p`2 & p`2 <= N-bound X;

definition let X be Subset of TOP-REAL 2;
 func SW-corner X -> Point of TOP-REAL 2 equals
:: PSCOMP_1:def 34
 |[W-bound X, S-bound X]|;
 func NW-corner X -> Point of TOP-REAL 2 equals
:: PSCOMP_1:def 35
 |[W-bound X, N-bound X]|;
 func NE-corner X -> Point of TOP-REAL 2 equals
:: PSCOMP_1:def 36
 |[E-bound X, N-bound X]|;
 func SE-corner X -> Point of TOP-REAL 2 equals
:: PSCOMP_1:def 37
 |[E-bound X, S-bound X]|;
end;


:: Corners

theorem :: PSCOMP_1:72
(SW-corner P)`1 = W-bound P;

theorem :: PSCOMP_1:73
(SW-corner P)`2 = S-bound P;

theorem :: PSCOMP_1:74
(NW-corner P)`1 = W-bound P;

theorem :: PSCOMP_1:75
(NW-corner P)`2 = N-bound P;

theorem :: PSCOMP_1:76
(NE-corner P)`1 = E-bound P;

theorem :: PSCOMP_1:77
(NE-corner P)`2 = N-bound P;

theorem :: PSCOMP_1:78
(SE-corner P)`1 = E-bound P;

theorem :: PSCOMP_1:79
(SE-corner P)`2 = S-bound P;

theorem :: PSCOMP_1:80
  (SW-corner P)`1 = (NW-corner P)`1;

theorem :: PSCOMP_1:81
  (SE-corner P)`1 = (NE-corner P)`1;

theorem :: PSCOMP_1:82
  (NW-corner P)`2 = (NE-corner P)`2;

theorem :: PSCOMP_1:83
  (SW-corner P)`2 = (SE-corner P)`2;

definition let X be Subset of TOP-REAL 2;
 func W-most X -> Subset of TOP-REAL 2 equals
:: PSCOMP_1:def 38
 LSeg(SW-corner X, NW-corner X)/\X;
 func N-most X -> Subset of TOP-REAL 2 equals
:: PSCOMP_1:def 39
 LSeg(NW-corner X, NE-corner X)/\X;
 func E-most X -> Subset of TOP-REAL 2 equals
:: PSCOMP_1:def 40
 LSeg(SE-corner X, NE-corner X)/\X;
 func S-most X -> Subset of TOP-REAL 2 equals
:: PSCOMP_1:def 41
 LSeg(SW-corner X, SE-corner X)/\X;
end;


registration let X be non empty compact Subset of TOP-REAL 2;
 cluster W-most X -> non empty compact;
 coherence proof
A1: W-most X = LSeg(SW-corner X, NW-corner X)/\X by Def38;
    SW-corner X = |[W-bound X, S-bound X]| &
  NW-corner X = |[W-bound X, N-bound X]| by Def34,Def35;
then A2: (SW-corner X)`1 = W-bound X & (NW-corner X)`1 = W-bound X &
   (SW-corner X)`2 = S-bound X & (NW-corner X)`2 = N-bound X
          by EUCLID:56;
   set p1X = (proj1||X), c = the carrier of (TOP-REAL 2)|X;
A3: inf p1X = W-bound X by Def30;
A4: c = X by JORDAN1:1;
A5: inf p1X = inf (p1X.:c) by Def20;
     p1X.:c is with_min by Def15;
   then inf (p1X.:c) in p1X.:c by Def4;
   then consider p being set such that
A6: p in c & p in c & inf (p1X.:c) = p1X.p by FUNCT_2:115;
   reconsider p as Point of TOP-REAL 2 by A4,A6;
A7: p1X.p = p`1 by A4,A6,Th69;
     S-bound X <= p`2 & p`2 <= N-bound X by A4,A6,Th71;
   then p in LSeg(SW-corner X, NW-corner X) by A2,A3,A5,A6,A7,GOBOARD7:8;
  hence thesis by A1,A4,A6,Th64,XBOOLE_0:def 3;
 end;
 cluster N-most X -> non empty compact;
 coherence proof
A8:N-most X = LSeg(NW-corner X, NE-corner X)/\X by Def39;
    NW-corner X = |[W-bound X, N-bound X]| &
  NE-corner X = |[E-bound X, N-bound X]| by Def35,Def36;
then A9: (NW-corner X)`1 = W-bound X & (NE-corner X)`1 = E-bound X &
   (NW-corner X)`2 = N-bound X & (NE-corner X)`2 = N-bound X
          by EUCLID:56;
   set p2X = (proj2||X), c = the carrier of (TOP-REAL 2)|X;
A10: sup p2X = N-bound X by Def31;
A11: c = X by JORDAN1:1;
A12: sup p2X = sup (p2X.:c) by Def21;
     p2X.:c is with_max by Def14;
   then sup (p2X.:c) in p2X.:c by Def3;
   then consider p being set such that
A13: p in c & p in c & sup (p2X.:c) = p2X.p by FUNCT_2:115;
   reconsider p as Point of TOP-REAL 2 by A11,A13;
A14: p2X.p = p`2 by A11,A13,Th70;
     W-bound X <= p`1 & p`1 <= E-bound X by A11,A13,Th71;
   then p in LSeg(NW-corner X, NE-corner X) by A9,A10,A12,A13,A14,GOBOARD7:9;
  hence thesis by A8,A11,A13,Th64,XBOOLE_0:def 3;
 end;
 cluster E-most X -> non empty compact;
 coherence proof
A15:E-most X = LSeg(SE-corner X, NE-corner X)/\X by Def40;
    SE-corner X = |[E-bound X, S-bound X]| &
  NE-corner X = |[E-bound X, N-bound X]| by Def36,Def37;
then A16: (SE-corner X)`1 = E-bound X & (NE-corner X)`1 = E-bound X &
   (SE-corner X)`2 = S-bound X & (NE-corner X)`2 = N-bound X
          by EUCLID:56;
   set p1X = (proj1||X), c = the carrier of (TOP-REAL 2)|X;
A17: sup p1X = E-bound X by Def32;
A18: c = X by JORDAN1:1;
A19: sup p1X = sup (p1X.:c) by Def21;
     p1X.:c is with_max by Def14;
   then sup (p1X.:c) in p1X.:c by Def3;
   then consider p being set such that
A20: p in c & p in c & sup (p1X.:c) = p1X.p by FUNCT_2:115;
   reconsider p as Point of TOP-REAL 2 by A18,A20;
A21: p1X.p = p`1 by A18,A20,Th69;
     S-bound X <= p`2 & p`2 <= N-bound X by A18,A20,Th71;
   then p in LSeg(SE-corner X, NE-corner X) by A16,A17,A19,A20,A21,GOBOARD7:8;
  hence thesis by A15,A18,A20,Th64,XBOOLE_0:def 3;
 end;
 cluster S-most X -> non empty compact;
 coherence proof
A22:S-most X = LSeg(SW-corner X, SE-corner X)/\X by Def41;
    SW-corner X = |[W-bound X, S-bound X]| &
  SE-corner X = |[E-bound X, S-bound X]| by Def34,Def37;
then A23: (SW-corner X)`1 = W-bound X & (SE-corner X)`1 = E-bound X &
   (SW-corner X)`2 = S-bound X & (SE-corner X)`2 = S-bound X
          by EUCLID:56;
   set p2X = (proj2||X), c = the carrier of (TOP-REAL 2)|X;
A24: inf p2X = S-bound X by Def33;
A25: c = X by JORDAN1:1;
A26: inf p2X = inf (p2X.:c) by Def20;
     p2X.:c is with_min by Def15;
   then inf (p2X.:c) in p2X.:c by Def4;
   then consider p being set such that
A27: p in c & p in c & inf (p2X.:c) = p2X.p by FUNCT_2:115;
   reconsider p as Point of TOP-REAL 2 by A25,A27;
A28: p2X.p = p`2 by A25,A27,Th70;
     W-bound X <= p`1 & p`1 <= E-bound X by A25,A27,Th71;
   then p in LSeg(SW-corner X, SE-corner X) by A23,A24,A26,A27,A28,GOBOARD7:9;
  hence thesis by A22,A25,A27,Th64,XBOOLE_0:def 3;
 end;
end;


definition let X be Subset of TOP-REAL 2;
 func W-min X -> Point of TOP-REAL 2 equals
:: PSCOMP_1:def 42
 |[W-bound X, inf (proj2||W-most X)]|;
 func W-max X -> Point of TOP-REAL 2 equals
:: PSCOMP_1:def 43
 |[W-bound X, sup (proj2||W-most X)]|;
 func N-min X -> Point of TOP-REAL 2 equals
:: PSCOMP_1:def 44
 |[inf (proj1||N-most X), N-bound X]|;
 func N-max X -> Point of TOP-REAL 2 equals
:: PSCOMP_1:def 45
 |[sup (proj1||N-most X), N-bound X]|;
 func E-max X -> Point of TOP-REAL 2 equals
:: PSCOMP_1:def 46
 |[E-bound X, sup (proj2||E-most X)]|;
 func E-min X -> Point of TOP-REAL 2 equals
:: PSCOMP_1:def 47
 |[E-bound X, inf (proj2||E-most X)]|;
 func S-max X -> Point of TOP-REAL 2 equals
:: PSCOMP_1:def 48
 |[sup (proj1||S-most X), S-bound X]|;
 func S-min X -> Point of TOP-REAL 2 equals
:: PSCOMP_1:def 49
 |[inf (proj1||S-most X), S-bound X]|;
end;


theorem :: PSCOMP_1:84
(W-min P)`1 = W-bound P &
(W-max P)`1 = W-bound P;

theorem :: PSCOMP_1:85
(SW-corner P)`1 = (W-min P)`1 &
(SW-corner P)`1 = (W-max P)`1 &
(W-min P)`1 = (W-max P)`1 &
(W-min P)`1 = (NW-corner P)`1 &
(W-max P)`1 = (NW-corner P)`1;

theorem :: PSCOMP_1:86
(W-min P)`2 = inf (proj2||W-most P) &
(W-max P)`2 = sup (proj2||W-most P);

theorem :: PSCOMP_1:87
(SW-corner X)`2 <= (W-min X)`2 &
(SW-corner X)`2 <= (W-max X)`2 &
(SW-corner X)`2 <= (NW-corner X)`2 &
(W-min X)`2 <= (W-max X)`2 &
(W-min X)`2 <= (NW-corner X)`2 &
(W-max X)`2 <= (NW-corner X)`2;

theorem :: PSCOMP_1:88
p in W-most Z implies
p`1 = (W-min Z)`1 &
(Z is compact implies (W-min Z)`2 <= p`2 & p`2 <= (W-max Z)`2);

theorem :: PSCOMP_1:89
W-most X c= LSeg(W-min X, W-max X);

theorem :: PSCOMP_1:90
  LSeg(W-min X, W-max X) c= LSeg(SW-corner X, NW-corner X);

theorem :: PSCOMP_1:91
W-min X in W-most X & W-max X in W-most X;

theorem :: PSCOMP_1:92
  LSeg(SW-corner X, W-min X)/\X = {W-min X} &
LSeg(W-max X, NW-corner X)/\X = {W-max X};

theorem :: PSCOMP_1:93
  W-min X = W-max X implies W-most X = {W-min X};

:: North

theorem :: PSCOMP_1:94
(N-min P)`2 = N-bound P &
(N-max P)`2 = N-bound P;

theorem :: PSCOMP_1:95
(NW-corner P)`2 = (N-min P)`2 &
(NW-corner P)`2 = (N-max P)`2 &
(N-min P)`2 = (N-max P)`2 &
(N-min P)`2 = (NE-corner P)`2 &
(N-max P)`2 = (NE-corner P)`2;

theorem :: PSCOMP_1:96
(N-min P)`1 = inf (proj1||N-most P) &
(N-max P)`1 = sup (proj1||N-most P);

theorem :: PSCOMP_1:97
(NW-corner X)`1 <= (N-min X)`1 &
(NW-corner X)`1 <= (N-max X)`1 &
(NW-corner X)`1 <= (NE-corner X)`1 &
(N-min X)`1 <= (N-max X)`1 &
(N-min X)`1 <= (NE-corner X)`1 &
(N-max X)`1 <= (NE-corner X)`1;

theorem :: PSCOMP_1:98
p in N-most Z implies
p`2 = (N-min Z)`2 &
(Z is compact implies (N-min Z)`1 <= p`1 & p`1 <= (N-max Z)`1);

theorem :: PSCOMP_1:99
N-most X c= LSeg(N-min X, N-max X);

theorem :: PSCOMP_1:100
  LSeg(N-min X, N-max X) c= LSeg(NW-corner X, NE-corner X);

theorem :: PSCOMP_1:101
N-min X in N-most X & N-max X in N-most X;

theorem :: PSCOMP_1:102
  LSeg(NW-corner X, N-min X)/\X = {N-min X} &
LSeg(N-max X, NE-corner X)/\X = {N-max X};

theorem :: PSCOMP_1:103
  N-min X = N-max X implies N-most X = {N-min X};

:: East

theorem :: PSCOMP_1:104
(E-min P)`1 = E-bound P &
(E-max P)`1 = E-bound P;

theorem :: PSCOMP_1:105
(SE-corner P)`1 = (E-min P)`1 &
(SE-corner P)`1 = (E-max P)`1 &
(E-min P)`1 = (E-max P)`1 &
(E-min P)`1 = (NE-corner P)`1 &
(E-max P)`1 = (NE-corner P)`1;

theorem :: PSCOMP_1:106
(E-min P)`2 = inf (proj2||E-most P) &
(E-max P)`2 = sup (proj2||E-most P);

theorem :: PSCOMP_1:107
(SE-corner X)`2 <= (E-min X)`2 &
(SE-corner X)`2 <= (E-max X)`2 &
(SE-corner X)`2 <= (NE-corner X)`2 &
(E-min X)`2 <= (E-max X)`2 &
(E-min X)`2 <= (NE-corner X)`2 &
(E-max X)`2 <= (NE-corner X)`2;

theorem :: PSCOMP_1:108
p in E-most Z implies
p`1 = (E-min Z)`1 &
(Z is compact implies (E-min Z)`2 <= p`2 & p`2 <= (E-max Z)`2);

theorem :: PSCOMP_1:109
E-most X c= LSeg(E-min X, E-max X);

theorem :: PSCOMP_1:110
  LSeg(E-min X, E-max X) c= LSeg(SE-corner X, NE-corner X);

theorem :: PSCOMP_1:111
E-min X in E-most X & E-max X in E-most X;

theorem :: PSCOMP_1:112
  LSeg(SE-corner X, E-min X)/\X = {E-min X} &
LSeg(E-max X, NE-corner X)/\X = {E-max X};

theorem :: PSCOMP_1:113
  E-min X = E-max X implies E-most X = {E-min X};

:: South

theorem :: PSCOMP_1:114
(S-min P)`2 = S-bound P &
(S-max P)`2 = S-bound P;

theorem :: PSCOMP_1:115
(SW-corner P)`2 = (S-min P)`2 &
(SW-corner P)`2 = (S-max P)`2 &
(S-min P)`2 = (S-max P)`2 &
(S-min P)`2 = (SE-corner P)`2 &
(S-max P)`2 = (SE-corner P)`2;

theorem :: PSCOMP_1:116
(S-min P)`1 = inf (proj1||S-most P) &
(S-max P)`1 = sup (proj1||S-most P);

theorem :: PSCOMP_1:117
(SW-corner X)`1 <= (S-min X)`1 &
(SW-corner X)`1 <= (S-max X)`1 &
(SW-corner X)`1 <= (SE-corner X)`1 &
(S-min X)`1 <= (S-max X)`1 &
(S-min X)`1 <= (SE-corner X)`1 &
(S-max X)`1 <= (SE-corner X)`1;

theorem :: PSCOMP_1:118
p in S-most Z implies
p`2 = (S-min Z)`2 &
(Z is compact implies (S-min Z)`1 <= p`1 & p`1 <= (S-max Z)`1);

theorem :: PSCOMP_1:119
S-most X c= LSeg(S-min X, S-max X);

theorem :: PSCOMP_1:120
  LSeg(S-min X, S-max X) c= LSeg(SW-corner X, SE-corner X);

theorem :: PSCOMP_1:121
S-min X in S-most X & S-max X in S-most X;

theorem :: PSCOMP_1:122
  LSeg(SW-corner X, S-min X)/\X = {S-min X} &
LSeg(S-max X, SE-corner X)/\X = {S-max X};

theorem :: PSCOMP_1:123
  S-min X = S-max X implies S-most X = {S-min X};

:: Degenerate cases

theorem :: PSCOMP_1:124
  W-max P = N-min P implies W-max P = NW-corner P;

theorem :: PSCOMP_1:125
  N-max P = E-max P implies N-max P = NE-corner P;

theorem :: PSCOMP_1:126
  E-min P = S-max P implies E-min P = SE-corner P;

theorem :: PSCOMP_1:127
  S-min P = W-min P implies S-min P = SW-corner P;
