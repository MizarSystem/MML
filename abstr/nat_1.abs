:: The Fundamental Properties of Natural Numbers
::  by Grzegorz Bancerek
::
:: Received January 11, 1989
:: Copyright (c) 1990 Association of Mizar Users

environ

 vocabularies ORDINAL2, ARYTM, ARYTM_1, ARYTM_3, ORDINAL1, NAT_1, XREAL_0,
      ZF_LANG;
 notations TARSKI, XBOOLE_0, SUBSET_1, ORDINAL1, NUMBERS, XCMPLX_0, XREAL_0,
      REAL_1, XXREAL_0;
 constructors NUMBERS, XCMPLX_0, XXREAL_0, XREAL_0, ORDINAL2;
 registrations REAL_1, NUMBERS, ORDINAL2, XREAL_0, ARYTM_3, ZFMISC_1, XBOOLE_0,
      XXREAL_0, ORDINAL1;
 requirements REAL, NUMERALS, SUBSET, BOOLE, ARITHM;


begin

definition
  mode Nat is natural number;
end;

 reserve x for Real,
         p,k,l,m,n,s,h,i,j,k1,t,t1 for Nat,
         X for Subset of REAL;

:: The results of axioms of natural numbers

canceled;

theorem :: NAT_1:2                       :: axiom of induction
  for X st 0 in X & for x st x in X holds x + 1 in X
  for n holds n in X;

:: Addition and multiplication

:: The natural numbers are real numbers therefore some theorems of real
:: numbers are translated for natural numbers.

definition let n,k be Element of NAT;
  redefine func n + k -> Element of NAT;
 end;

registration let n,k be Nat;
  cluster n + k -> natural;
end;

:: Now we can form and prove the scheme of induction.

scheme :: NAT_1:sch 1
 Ind { P[Nat] } :
 for k being Element of NAT holds P[k]
   provided
   P[0] and
   for k being Element of NAT st P[k] holds P[k + 1];

scheme :: NAT_1:sch 2
 NatInd { P[Nat] } :
 for k being Nat holds P[k]
   provided
   P[0] and
   for k be Nat st P[k] holds P[k + 1];

:: Like addition, the result of multiplication of two natural numbers is
:: a natural number.

definition let n,k be Element of NAT;
  redefine func n * k -> Element of NAT;
end;

registration let n,k be Nat;
  cluster n * k -> natural;
end;

                ::::::::::::::::::::
                :: Order relation ::
                ::::::::::::::::::::

:: Some theorems of not great relation "<=" in real numbers are translated
:: to natural number easy and it is necessary to have them here.

canceled 15;

theorem :: NAT_1:18
  0 <= i;

theorem :: NAT_1:19
  0 <> i implies 0 < i;

theorem :: NAT_1:20
  i <= j implies i * h <= j * h;

theorem :: NAT_1:21
  0 < i + 1;

theorem :: NAT_1:22
  i = 0 or ex k st i = k + 1;

theorem :: NAT_1:23
  i + j = 0 implies i = 0 & j = 0;

registration
  cluster non zero Nat;
end;

registration let m be Nat, n be non zero Nat;
  cluster m + n -> non zero;
  cluster n + m -> non zero;
end;

scheme :: NAT_1:sch 3
 DefbyInd { N()->Nat, F(Nat,Nat)->Nat, P[Nat,Nat] } :
  (for k being Element of NAT ex n being Element of NAT st P[k,n]) &
    for k,n,m being Element of NAT st P[k,n] & P[k,m] holds n = m
     provided
    for k,n being Element of NAT holds P[k,n] iff
       k = 0 & n = N() or
       ex m,l being Element of NAT st k = m + 1 & P[m,l] & n = F(k,l);

canceled 2;

theorem :: NAT_1:26
  i <= j + 1 implies i <= j or i = j + 1;

theorem :: NAT_1:27
  i <= j & j <= i + 1 implies i = j or j = i + 1;

theorem :: NAT_1:28
  i <= j implies ex k st j = i + k;

theorem :: NAT_1:29
  i <= i + j;

scheme :: NAT_1:sch 4
 CompInd { P[Nat] } :
  for k being Element of NAT holds P[k]
   provided
   for k being Element of NAT st
      for n being Element of NAT st n < k holds P[n] holds P[k];

:: Principle of minimum

scheme :: NAT_1:sch 5
 Min { P[Nat] } :
 ex k being Element of NAT st P[k] &
 for n being Element of NAT st P[n] holds k <= n
  provided
  ex k being Element of NAT st P[k];

:: Principle of maximum

scheme :: NAT_1:sch 6
 Max { P[Nat], N()->Nat } :
  ex k being Element of NAT st P[k] &
  for n being Element of NAT st P[n] holds n <= k
   provided
   for k being Element of NAT st P[k] holds k <= N() and
   ex k being Element of NAT st P[k];

canceled 7;

theorem :: NAT_1:37
  i <= j implies i <= j + h;

theorem :: NAT_1:38
  i < j + 1 iff i <= j;

theorem :: NAT_1:39
  j < 1 implies j = 0;

theorem :: NAT_1:40
  i * j = 1 implies i = 1 & j = 1;

theorem :: NAT_1:41
  k <> 0 implies n < n + k;

scheme :: NAT_1:sch 7
 Regr { P[Nat] } :
  P[0]
  provided
  ex k being Element of NAT st P[k] and
  for k being Element of NAT st k <> 0 & P[k]
     ex n being Element of NAT st n < k & P[n];

:: Exact division and rest of division

theorem :: NAT_1:42
  0 < m implies for n ex k,t st n = (m*k)+t & t < m;

theorem :: NAT_1:43
  n = m*k+t & t < m & n = m*k1+t1 & t1 < m implies k = k1 & t = t1;

definition let k,l be Nat;
  func k div l -> Nat means
:: NAT_1:def 1       :: the exact division
  ( ex t being Nat st k = l * it + t & t < l ) or it = 0 & l = 0;

  func k mod l -> Nat means
:: NAT_1:def 2         :: the rest of division
 ( ex t being Nat st k = l * t + it & it < l ) or it = 0 & l = 0;
 end;

definition let k,l be Nat;
  redefine func k div l -> Element of NAT;
  redefine func k mod l -> Element of NAT;
end;

canceled 2;

theorem :: NAT_1:46
  0 < i implies j mod i < i;

theorem :: NAT_1:47
  0 < i implies j = i * (j div i) + (j mod i);

:: The divisibility relation

definition let k,l be Nat;
  pred k divides l means
:: NAT_1:def 3
  ex t being Nat st l = k * t;
  reflexivity;
end;

canceled;

theorem :: NAT_1:49
  j divides i iff i = j * (i div j);

canceled;

theorem :: NAT_1:51
  i divides j & j divides h implies i divides h;

theorem :: NAT_1:52
  i divides j & j divides i implies i = j;

theorem :: NAT_1:53
  i divides 0 & 1 divides i;

theorem :: NAT_1:54
  0 < j & i divides j implies i <= j;

theorem :: NAT_1:55
  i divides j & i divides h implies i divides j+h;

theorem :: NAT_1:56
  i divides j implies i divides j * h;

theorem :: NAT_1:57
  i divides j & i divides j + h implies i divides h;

theorem :: NAT_1:58
  i divides j & i divides h implies i divides j mod h;

:: The least common multiple and the greatest common divisor

definition let k,n be Nat;
  func k lcm n -> Nat means
:: NAT_1:def 4
  k divides it & n divides it &
  for m being Nat st k divides m & n divides m holds it divides m;
    idempotence;
    commutativity;
end;

definition let k,n be Nat;
  redefine func k lcm n -> Element of NAT;
end;

definition let k,n be Nat;
  func k hcf n -> Nat means
:: NAT_1:def 5
  it divides k & it divides n &
    for m being Nat st m divides k & m divides n holds m divides it;
    idempotence;
    commutativity;
end;

definition let k,n be Nat;
  redefine func k hcf n -> Element of NAT;
end;

scheme :: NAT_1:sch 8
 Euklides { Q(Nat)->Nat, a,b()->Nat } :
  ex n being Element of NAT st Q(n) = a() hcf b() & Q(n + 1) = 0
   provided
   0 < b() & b() < a() and
   Q(0) = a() & Q(1) = b() and
   for n being Element of NAT holds Q(n + 2) = Q(n) mod Q(n + 1);

registration
  cluster -> ordinal Nat;
end;

registration
  cluster non empty ordinal Subset of REAL;
end;

theorem :: NAT_1:59
  k < k + n iff 1 <= n;

theorem :: NAT_1:60
  k < n implies n - 1 is Element of NAT;

theorem :: NAT_1:61
  k <= n implies n - k is Element of NAT;

theorem :: NAT_1:62
  n mod 2 = 0 or n mod 2 = 1;

theorem :: NAT_1:63
  (k * n) mod k = 0;

theorem :: NAT_1:64
  k > 1 implies 1 mod k = 1;

theorem :: NAT_1:65
  k mod n = 0 & l = k - m * n implies l mod n = 0;

theorem :: NAT_1:66
  n <> 0 & k mod n = 0 & l < n implies k + l mod n = l;

theorem :: NAT_1:67
  k mod n = 0 implies k + l mod n = l mod n;

theorem :: NAT_1:68
  k <> 0 implies (k * n) div k = n;

theorem :: NAT_1:69
  k mod n = 0 implies (k + l) div n = (k div n) + (l div n);

begin :: Addenda

:: from ALGSEQ_1

theorem :: NAT_1:70
  m < n+1 implies m < n or m = n;

theorem :: NAT_1:71
  k < 2 implies k = 0 or k = 1;

registration
  cluster non zero Element of NAT;
end;

registration
  cluster -> non negative Element of NAT;
end;

registration
  cluster -> non negative Nat;
end;

:: from AMI_5, 2005.11.16, A.T.

theorem :: NAT_1:72
  k <> 0 implies m * k div k = m;

:: from GR_CY_1, 2005.11.16, A.T.

theorem :: NAT_1:73
  m mod n = (n*k + m) mod n;

theorem :: NAT_1:74
  (p+s) mod n = ((p mod n)+s) mod n;

theorem :: NAT_1:75
  (p+s) mod n = (p + ( s mod n)) mod n;

theorem :: NAT_1:76
  k < n implies k mod n = k;

theorem :: NAT_1:77
  n mod n = 0;

theorem :: NAT_1:78
  0 = 0 mod n;

:: from JORDAN4

theorem :: NAT_1:79
 i <> 0 & h = j*i implies j <= h;

theorem :: NAT_1:80
  i < j implies i div j=0;

:: from SCMFSA_7, 2006.03.15, A.T.

theorem :: NAT_1:81
  k < n iff 1 <= k + 1 & k + 1 <= n;

:: from BINOM, 2006.05.28, A.T.

scheme :: NAT_1:sch 9
 Ind1{M() -> Nat, P[Nat]} :
  for i being Element of NAT st M() <= i holds P[i]
provided
  P[M()] and
  for j being Element of NAT st M() <= j holds P[j] implies P[j+1];

:: from INT_2, 2006.05.30, AG

scheme :: NAT_1:sch 10
 CompInd1 { a() -> Nat, P[Nat] } :
  for k being Element of NAT st k>=a() holds P[k]
  provided
   for k being Element of NAT st k>=a() &
  (for n being Element of NAT st n>=a() & n<k holds P[n]) holds P[k];

:: Moved from CQC_THE1 on 07.07.2006 by AK

theorem :: NAT_1:82
  n <= 1 implies n = 0 or n = 1;

theorem :: NAT_1:83
  n <= 2 implies n = 0 or n = 1 or n = 2;

theorem :: NAT_1:84
  n <= 3 implies n = 0 or n = 1 or n = 2 or n = 3;

theorem :: NAT_1:85
  n <= 4 implies n = 0 or n = 1 or n = 2 or n = 3 or n = 4;

theorem :: NAT_1:86
  n <= 5 implies n = 0 or n = 1 or n = 2 or n = 3 or n = 4 or n = 5;

theorem :: NAT_1:87
  n <= 6 implies n = 0 or n = 1 or n = 2 or n = 3 or n = 4 or n = 5 or n = 6;

theorem :: NAT_1:88
  n <= 7 implies n = 0 or n = 1 or n = 2 or n = 3 or n = 4 or n = 5 or n = 6
  or n = 7;

theorem :: NAT_1:89
  n <= 8 implies n = 0 or n = 1 or n = 2 or n = 3
  or n = 4 or n = 5 or n = 6 or n = 7 or n = 8;

theorem :: NAT_1:90
  n <= 9 implies n = 0 or n = 1 or n = 2 or n = 3
  or n = 4 or n = 5 or n = 6 or n = 7 or n = 8 or n = 9;

:: compare BINARITH:sch 1, 2006.07.19, A.T.

 scheme :: NAT_1:sch 11
 Indfrom1 { P[Nat] } :
 for k being non empty Nat holds P[k]
   provided
    P[1] and
    for k being non empty Nat st P[k] holds P[k + 1];
