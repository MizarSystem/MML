:: The Fundamental Properties of Natural Numbers
::  by Grzegorz Bancerek
::
:: Received January 11, 1989
:: Copyright (c) 1990 Association of Mizar Users

environ

 vocabulary ORDINAL2, ARYTM, ARYTM_1, ARYTM_3, ORDINAL1, NAT_1, XREAL_0;
 notation TARSKI, XBOOLE_0, SUBSET_1, ORDINAL1, ORDINAL2, NUMBERS, XCMPLX_0,
      XREAL_0, REAL_1;
 constructors REAL_1, XREAL_0, XCMPLX_0, XBOOLE_0;
 clusters REAL_1, NUMBERS, ORDINAL2, XREAL_0, ARYTM_3, ZFMISC_1, XBOOLE_0;
 requirements REAL, NUMERALS, SUBSET, BOOLE, ARITHM;


begin

definition
  mode Nat is Element of NAT;
end;


 reserve x for Real,
         k,l,m,n for Nat,
         h,i,j for natural number,
         X for Subset of REAL;

:: The results of axioms of natural numbers

canceled;

theorem :: NAT_1:2                       :: axiom of induction
  for X st 0 in X & for x st x in X holds x + 1 in X
  for k holds k in X;

:: Addition and multiplication

:: The natural numbers are real numbers therefore some theorems of real
:: numbers are translated for natural numbers.

 definition let n,k be Nat;
 redefine func n + k -> Nat;
 end;


 registration let n,k be natural number;
  cluster n + k -> natural;
   coherence
   proof
     reconsider n,k as Nat by ORDINAL2:def 21;
       n+k is Nat;
     hence thesis;
   end;
 end;


:: Now we can form and prove the scheme of induction.

scheme :: NAT_1:sch 1
 Ind { P[Nat] } :
 for k being Nat holds P[k]
   provided
   P[0] and
   for k being Nat st P[k] holds P[k + 1]
proof    let k;
      defpred _P[Real] means ex k st P[k] & k = $1;
    consider X such that
A3:   x in X iff _P[x] from REAL_1:sch 1;
A4:   0 in X by A1,A3;
     for x st x in X holds x + 1 in X
      proof let x; assume
          x in X;
       then consider k such that
A5:      P[k] & k = x by A3;
          P[k + 1] by A2,A5;
       hence thesis by A3,A5;
      end;
     then k in X by A4,Th2;
     then ex n st P[n] & n = k by A3;
    hence P[k];
   end;

scheme :: NAT_1:sch 2
 Nat_Ind { P[natural number] } :
 for k being natural number holds P[k]
   provided
   P[0] and
   for k be natural number st P[k] holds P[k + 1]
proof
      defpred _P[Nat] means P[$1];
A3: _P[0] by A1;
A4:   for k st _P[k] holds _P[k + 1] by A2;
A5:   for k holds _P[k] from Ind(A3,A4);
      let k be natural number;
        k is Nat by ORDINAL2:def 21;
      hence thesis by A5;
   end;

:: Like addition, the result of multiplication of two natural numbers is
:: a natural number.

 definition let n,k be Nat;
 redefine func n * k -> Nat;
 end;


 registration let n,k be natural number;
  cluster n * k -> natural;
   coherence
   proof
     reconsider n,k as Nat by ORDINAL2:def 21;
       n*k is Nat;
     hence thesis;
   end;
 end;


                ::::::::::::::::::::
                :: Order relation ::
                ::::::::::::::::::::

:: Some theorems of not great relation "<=" in real numbers are translated
:: to natural number easy and it is necessary to have them here.

canceled 15;

theorem :: NAT_1:18
  0 <= i;

theorem :: NAT_1:19
  0 <> i implies 0 < i;

theorem :: NAT_1:20
  i <= j implies i * h <= j * h;

theorem :: NAT_1:21
0 <> i + 1;

theorem :: NAT_1:22
  i = 0 or ex k st i = k + 1;

theorem :: NAT_1:23
  i + j = 0 implies i = 0 & j = 0;

registration
  cluster non zero (natural number);
  existence
  proof
    take 1;
    thus thesis;
  end;
end;


registration let m be natural number, n be non zero (natural number);
  cluster m + n -> non zero;
  coherence by Th23;
  cluster n + m -> non zero;
  coherence by Th23;
end;


scheme :: NAT_1:sch 3
 Def_by_Ind { N()->Nat, F(Nat,Nat)->Nat, P[Nat,Nat] } :
  (for k ex n st P[k,n] ) &
    for k,n,m st P[k,n] & P[k,m] holds n = m
     provided
    for k,n holds P[k,n] iff
       k = 0 & n = N() or ex m,l st k = m + 1 & P[m,l] & n = F(k,l)
proof
      defpred _P[Nat] means ex n st P[$1,n];
       P[0,N()] by A1;
then A2:   _P[0];
A3:   _P[k] implies _P[k+1]
      proof given n such that
A4:      P[k,n];
       take F(k+1,n);
       thus P[k+1,F(k+1,n)] by A1,A4;
      end;
    thus for k holds _P[k] from Ind(A2,A3);
    defpred _P[Nat] means for n,m st P[$1,n] & P[$1,m] holds n = m;
A5:   _P[0]
      proof let n,m such that
A6:     P[0,n] & P[0,m];
          (not ex m,l st 0 = m + 1 & P[m,l] & n = F(0,l) ) &
        not ex n,l st 0 = n + 1 & P[n,l] & m = F(0,l);
        then n = N() & m = N() by A1,A6;
       hence n = m;
      end;
A7:   for k st _P[k] holds _P[k+1]
      proof let k such that
A8:      for n,m st P[k,n] & P[k,m] holds n = m;
       let n,m such that
A9:      P[k+1,n] & P[k+1,m];
       consider l,u be Nat such that
A10:      k + 1 = l + 1 & P[l,u] & n = F(k + 1,u) by A1,A9;
       consider v,w be Nat such that
A11:      k + 1 = v + 1 & P[v,w] & m = F(k + 1,w) by A1,A9;
          l = k & v = k by A10,A11,XCMPLX_1:2;
       hence n = m by A8,A10,A11;
      end;
    thus for k holds _P[k] from Ind(A5,A7);
   end;

canceled 2;

theorem :: NAT_1:26
  for i,j st i <= j + 1 holds i <= j or i = j + 1;

theorem :: NAT_1:27
    i <= j & j <= i + 1 implies i = j or j = i + 1;

theorem :: NAT_1:28
  for i,j st i <= j ex k st j = i + k;

theorem :: NAT_1:29
  i <= i + j;

scheme :: NAT_1:sch 4
 Comp_Ind { P[Nat] } :
 for k holds P[k]
   provided
   for k st for n st n < k holds P[n] holds P[k]
proof
      defpred _P[Nat] means for n st n < $1 holds P[n];
A2:   _P[0] by Th18;
A3:   _P[k] implies _P[k+1]
      proof assume
A4:   for n st n < k holds P[n];
      let n; assume
        n < k + 1;
      then n <= k by Th26;
      then n < k or n = k & n <= k by REAL_1:def 5;
      hence thesis by A1,A4;
    end;
    let k;
       for k holds _P[k] from Ind(A2,A3);
     then for n st n < k holds P[n];
    hence P[k] by A1;
   end;

:: Principle of minimum

scheme :: NAT_1:sch 5
 Min { P[Nat] } :
 ex k st P[k] & for n st P[n] holds k <= n
  provided
  ex k st P[k]
proof    assume A2: not thesis;
      defpred _P[Nat] means not P[$1];
A3:   for k st for n st n < k holds _P[n] holds _P[k]
      proof let k;
A4:    not (ex n st P[n] & not k <= n) implies not P[k] by A2;
       assume for n st n < k holds not P[n];
       hence thesis by A4;
      end;
       for k holds _P[k] from Comp_Ind(A3);
    hence contradiction by A1;
   end;

:: Principle of maximum

scheme :: NAT_1:sch 6
 Max { P[Nat],N()->Nat } :
  ex k st P[k] & for n st P[n] holds n <= k
   provided
   for k st P[k] holds k <= N() and
   ex k st P[k]
proof
      defpred _P[Nat] means for n st P[n] holds n <= $1;
A3:   ex k st _P[k] by A1;
    consider k such that
A4:   _P[k] &
      for m st _P[m] holds k <= m from Min(A3);
    take k;
    thus P[k]
      proof assume
A5:      not P[k];
       consider n such that
A6:      P[n] by A2;
       n <= k & n <> k by A4,A5,A6;
       then k <> 0 by Th18;
       then consider m such that
A7:      k = m + 1 by Th22;
          now let n; assume
            P[n];
          then n <= k & n <> k by A4,A5;
         hence n <= m by A7,Th26;
        end;
then A8:    k <= m by A4;
A9:    m + (- m) = 0 by XCMPLX_0:def 6;
          (- m) + m + 1 = (- m) + (m + 1) & (- m) + m + 0 = (- m) + (m + 0)
                              by XCMPLX_1:1;
       hence contradiction by A7,A8,A9,AXIOMS:24;
      end;
    thus thesis by A4;
   end;

canceled 7;

theorem :: NAT_1:37
  i <= j implies i <= j + h;

theorem :: NAT_1:38
  i < j + 1 iff i <= j;

canceled;

theorem :: NAT_1:40
  i * j = 1 implies i = 1 & j = 1;

scheme :: NAT_1:sch 7
 Regr { P[Nat] } :
 P[0]
  provided
  ex k st P[k] and
  for k st k <> 0 & P[k] ex n st n < k & P[n]
proof
     defpred _P[Nat] means P[$1];
A3: ex k st _P[k] by A1;
   consider k such that
A4:  _P[k] & for n st _P[n] holds k <= n from Min(A3);
      now assume k <> 0;
      then ex n st n < k & P[n] by A2,A4;
     hence contradiction by A4;
    end;
   hence P[0] by A4;
  end;

:: Exact division and rest of division

 reserve k1,t,t1 for Nat;

canceled;

theorem :: NAT_1:42
   for m st 0 < m for n ex k,t st n = (m*k)+t & t < m;

theorem :: NAT_1:43
 for n,m,k,k1,t,t1 being natural number
     st n = m*k+t & t < m & n = m*k1+t1 & t1 < m holds
      k = k1 & t = t1;

definition let k,l be natural number;
  func k div l -> Nat means
:: NAT_1:def 1       :: the exact division
  ( ex t st k = l * it + t & t < l ) or it = 0 & l = 0;

  func k mod l -> Nat means
:: NAT_1:def 2         :: the rest of division
 ( ex t st k = l * t + it & it < l ) or it = 0 & l = 0;
end;


canceled 2;

theorem :: NAT_1:46
  0 < i implies j mod i < i;

theorem :: NAT_1:47
  0 < i implies j = i * (j div i) + (j mod i);

:: The divisibility relation

definition let k,l be natural number;
  pred k divides l means
:: NAT_1:def 3
  ex t st l = k * t;
  reflexivity;
end;


canceled;

theorem :: NAT_1:49
  j divides i iff i = j * (i div j);

canceled;

theorem :: NAT_1:51
   i divides j & j divides h implies i divides h;

theorem :: NAT_1:52
  i divides j & j divides i implies i = j;

theorem :: NAT_1:53
  i divides 0 & 1 divides i;

theorem :: NAT_1:54
  0 < j & i divides j implies i <= j;

theorem :: NAT_1:55
  i divides j & i divides h implies i divides j+h;

theorem :: NAT_1:56
  i divides j implies i divides j * h;

theorem :: NAT_1:57
  i divides j & i divides j + h implies i divides h;

theorem :: NAT_1:58
  i divides j & i divides h implies i divides j mod h;

:: The least common multiple and the greatest common divisor

 definition let k,n be Nat;
  func k lcm n -> Nat means
:: NAT_1:def 4
  k divides it & n divides it & for m st k divides m & n divides
 m holds it divides m;
    idempotence;
    commutativity;
 end;


 definition let k,n be Nat;
  func k hcf n -> Nat means
:: NAT_1:def 5
  it divides k & it divides n & for m st m divides k & m divides
 n holds m divides it;
    idempotence;
    commutativity;
 end;


scheme :: NAT_1:sch 8
 Euklides { Q(Nat)->Nat, a,b()->Nat } :
  ex n st Q(n) = a() hcf b() & Q(n + 1) = 0
   provided
   0 < b() & b() < a() and
   Q(0) = a() & Q(1) = b() and
   for n holds Q(n + 2) = Q(n) mod Q(n + 1)
proof
     defpred _P[Nat] means ex n st $1 = Q(n);
A4:  ex k st _P[k] by A2;
A5:  for k st k <> 0 & _P[k] holds ex n st n < k & _P[n]
     proof let k; assume
A6:    k <> 0 & ex n st k = Q(n);
      then consider n such that
A7:    k = Q(n);
      take Q(n + 1);
A8:    (n = 0 implies Q(n + 1) < k) & ex m st m = n+1 & Q(n + 1) = Q(m)
       by A1,A2,A7;
         now given m such that
A9:      n = m + 1;
          A10: 0 <= Q(n) by Th18;
A11:         Q(m + 2) = Q(m) mod Q(m + 1) by A3;
           m + 1 + 1 = m + (1 + 1) by XCMPLX_1:1;
        hence Q(n + 1) < k by A6,A7,A9,A10,A11,Th46;
        take m = n + 1;
        thus Q(n + 1) =Q(m);
       end;
      hence thesis by A8,Th22;
     end;
A12:  _P[0] from Regr(A4,A5);
     defpred _Q[Nat] means 0 = Q($1);
A13: ex n st _Q[n] by A12;
   consider k such that
A14:  _Q[k] & for n st _Q[n] holds k <= n from Min(A13);
   consider n such that
A15:  k = n + 1 by A1,A2,A14,Th22;
   take n;
   defpred _PP[Nat] means Q(n) divides Q($1) & Q(n) divides Q($1 + 1);
      _PP[n] by A14,A15,Th53;
then A16:  ex k st _PP[k];
A17:  for k st k <> 0 & _PP[k] ex m st m < k & _PP[m]
     proof let l; assume
A18:    l <> 0 & Q(n) divides Q(l) & Q(n) divides Q(l + 1);
      then consider m such that
A19:    l = m + 1 by Th22;
      take m;
A20:    m <= m + 1 by Th29;
         now assume m = m + 1; then m + 0 = m + 1;
         hence contradiction by XCMPLX_1:2;
       end;
      hence m < l by A19,A20,REAL_1:def 5;
A21:    now assume
A22:      Q(m + 1) = 0;
           now assume
A23:        m + 1 <> k;
             k <= m + 1 by A14,A22;
           then k < m + 1 by A23,REAL_1:def 5;
then A24:        k <= m by Th38;
defpred _Q[Nat] means k <= $1 implies Q($1) = 0;
A25: _Q[0]
            proof assume A26: k <= 0; 0 <= k by Th18;
             hence thesis by A14,A26,AXIOMS:21;
            end;
A27:  for m st _Q[m] holds _Q[m+1]
     proof let m such that
A28:           k <= m implies Q(m) = 0 and
A29:           k <= m + 1;
               now assume k <> m + 1; then A30: k < m + 1 by A29,REAL_1:def 5;
               then consider l such that
A31:             m = l + 1 by A1,A2,A28,Th22,Th38;
A32:                Q(l + 2) = Q(l) mod Q(l + 1) by A3;
                  l + 1 + 1 = l + (1 + 1) by XCMPLX_1:1;
               hence Q(m + 1) = 0 by A28,A30,A31,A32,Def2,Th38;
              end;
             hence Q(m + 1) = 0 by A14;
            end;
             for m holds _Q[m] from Ind(A25,A27);
           then Q(m) = 0 by A24;
          hence Q(n) divides Q(m) by Th53;
         end;
        hence Q(n) divides Q(m) by A15,XCMPLX_1:2;
       end;
         now assume
A33:      Q(m + 1) <> 0;
          A34: 0 <= Q(m + 1) by Th18;
           Q(m + 2) = Q(m) mod Q(m + 1) by A3;
then A35:      Q(m) = Q(m + 1) * (Q(m) div Q(m + 1)) + Q(m + 2) by A33,A34,Th47
;
           m + 1 + 1 = m + (1 + 1) by XCMPLX_1:1;
         then Q(n) divides Q(m + 1) * (Q(m) div Q(m + 1)) & Q(n) divides
 Q(m + 2)
          by A18,A19,Th56;
        hence Q(n) divides Q(m) by A35,Th55;
       end;
      hence Q(n) divides Q(m) by A21;
      thus Q(n) divides Q(m + 1) by A18,A19;
     end;
      now
        _PP[0] from Regr(A16,A17);
     hence Q(n) divides a() & Q(n) divides b() by A2;
     let m;
     defpred _P1[Nat] means m divides Q($1) & m divides Q($1 + 1);
     assume
        m divides a() & m divides b();
then A36: _P1[0] by A2;
A37:    for k st _P1[k] holds _P1[k+1]
       proof let k; assume
A38:       m divides Q(k) & m divides Q(k + 1);
        hence m divides Q(k + 1);
A39:       Q(k + 2) = Q(k) mod Q(k + 1) by A3;
           k + 1 + 1 = k + (1 + 1) by XCMPLX_1:1;
        hence m divides Q(k + 1 + 1) by A38,A39,Th58;
       end;
        for k holds _P1[k] from Ind(A36,A37);
     hence m divides Q(n);
    end;
   hence Q(n) = a() hcf b() by Def5;
   thus Q(n + 1) = 0 by A14,A15;
  end;

registration
 cluster -> ordinal Nat;
 coherence;
end;


registration
 cluster non empty ordinal Subset of REAL;
  existence proof take NAT; thus thesis; end;
end;

