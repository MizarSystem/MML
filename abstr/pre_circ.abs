:: Preliminaries to Circuits, I
::  by Yatsuka Nakamura, Piotr Rudnicki, Andrzej Trybulec and Pauline N. Kawamoto
::
:: Received November 17, 1994
:: Copyright (c) 1994 Association of Mizar Users

environ

 vocabulary FINSET_1, FUNCT_1, RELAT_1, FUNCOP_1, FUNCT_4, BOOLE, SQUARE_1,
      FINSUB_1, SETWISEO, PBOOLE, TDGROUP, FINSEQ_1, CARD_3, ZF_REFLE, TARSKI,
      FUNCT_5, FUNCT_2, PRALG_1, PRALG_2, MCART_1, FINSEQ_2, TREES_1, TREES_3,
      TREES_2, FUNCT_6, TREES_4, CQC_LANG, CARD_1, PRE_CIRC, ORDINAL2, ARYTM,
      MEMBERED, SEQ_2, SEQ_4, ARYTM_1;
 notation TARSKI, XBOOLE_0, ZFMISC_1, SUBSET_1, ORDINAL1, NUMBERS, XCMPLX_0,
      XREAL_0, REAL_1, NAT_1, MCART_1, CARD_1, ORDINAL2, MEMBERED, SEQ_4,
      RELAT_1, FUNCT_1, FINSET_1, FINSUB_1, SETWISEO, FUNCT_2, FUNCOP_1,
      FUNCT_4, CARD_3, TREES_1, TREES_2, TREES_3, TREES_4, FUNCT_5, FUNCT_6,
      PBOOLE, PRALG_1, MSUALG_1, PRALG_2, CQC_LANG, FINSEQ_1, FINSEQ_2;
 constructors WELLORD2, NAT_1, SETWISEO, PRALG_2, CQC_LANG, XCMPLX_0, XREAL_0,
      MEMBERED, SEQ_4, PSCOMP_1, XBOOLE_0;
 clusters NUMBERS, SUBSET_1, FINSET_1, AMI_1, TREES_1, TREES_2, TREES_3,
      DTCONSTR, PRELAMB, PRALG_1, MSUALG_1, PRVECT_1, FUNCT_1, RELSET_1,
      XREAL_0, ARYTM_3, FINSEQ_1, REAL_1, FRAENKEL, MEMBERED, XBOOLE_0,
      ORDINAL2;
 requirements NUMERALS, REAL, BOOLE, SUBSET;


begin

scheme :: PRE_CIRC:sch 1
 FraenkelFinIm{ A() -> finite non empty set, F(set) -> set, P[set] }:
 { F(x) where x is Element of A() : P[x] } is finite
proof
A1: A() is finite;
 deffunc G(Element of A()) = F($1);
 set B = { G(x) where x is Element of A() : x in A() };
A2: B is finite from FRAENKEL:sch 21(A1);
   { F(x) where x is Element of A() : P[x] } c= B
  proof let a be set;
   assume a in { F(x) where x is Element of A() : P[x] };
    then consider b being Element of A() such that
A3:   F(b) = a and P[b];
   thus thesis by A3;
  end;
 hence thesis by A2,FINSET_1:13;
end;

canceled;

theorem :: PRE_CIRC:2
    for f being Function, x, y being set st dom f = {x} & rng f = {y}
    holds f = { [x,y] };

theorem :: PRE_CIRC:3
  for f, g, h being Function st f c= g holds f +* h c= g +* h;

theorem :: PRE_CIRC:4
    for f, g, h being Function st f c= g & dom f misses dom h
    holds f c= g +* h;

registration
 cluster finite non empty natural-membered set;
 existence
  proof
    consider A being finite non empty Subset of NAT;
   take A;
   thus A is finite non empty natural-membered;
  end;
end;


notation let A be finite non empty real-membered set;
   synonym max A for upper_bound A ;
end;
definition let A be finite non empty real-membered set;
 redefine func max A -> real number means
:: PRE_CIRC:def 1
 it in A & for k being real number st k in A holds k <= it;
 end;


registration
  let X be finite non empty natural-membered set;
  cluster max X -> natural;
  coherence
    proof max X in X by Def1;
      hence max X is natural by MEMBERED:def 5;
    end;
end;


begin
::---------------------------------------------------------------------------
:: Many Sorted Sets and Functions
::---------------------------------------------------------------------------

theorem :: PRE_CIRC:5
    for I being set, MSS being ManySortedSet of I
    holds MSS#.<*>I = {{}};

reserve i,j,x,y for set,
        g for Function;

scheme :: PRE_CIRC:sch 2
 MSSLambda2Part { I() -> set, P [set], F, G (set) -> set }:
    ex f being ManySortedSet of I() st
      for i being Element of I() st i in I()
        holds (P[i] implies f.i = F(i)) & (not P[i] implies f.i = G(i))
proof
     defpred Q[set,set] means
      (P[$1] implies $2 = F($1)) & (not P[$1] implies $2 = G($1));
A1:    now let i such that i in I();
       thus ex j st Q[i,j]
        proof
         per cases;
         suppose A2: P[i]; take F(i); thus thesis by A2;
         end;
         suppose A3: not P[i]; take G(i); thus thesis by A3;
        end;
        end;
      end;
      consider f being ManySortedSet of I() such that
A4:     for i st i in I() holds Q[i,f.i] from MSUALG_1:sch 1(A1);

      take f;
      thus thesis by A4;
    end;

definition
  let I be set;
   let IT be ManySortedSet of I;
  canceled;
  attr IT is locally-finite means
:: PRE_CIRC:def 3

      for i being set st i in I holds IT.i is finite;
end;


registration
  let I be set;
  cluster non-empty locally-finite ManySortedSet of I;
  existence
    proof
      reconsider f = I --> {{}} as Function;
        dom f = I by FUNCOP_1:19;
      then reconsider f as ManySortedSet of I by PBOOLE:def 3;
      take f;
      thus f is non-empty
        proof
          let i be set;
          assume i in I;
          hence f.i is non empty by FUNCOP_1:13;
        end;
      thus f is locally-finite
        proof
          let i be set;
          assume i in I;
          hence f.i is finite by FUNCOP_1:13;
        end;
    end;
end;


definition
  let I, A be set;
  redefine func I --> A -> ManySortedSet of I;
end;


definition
  let I be set, M be ManySortedSet of I, A be Subset of I;
  redefine func M | A -> ManySortedSet of A;
end;


registration
  let M be non-empty Function, A be set;
  cluster M | A -> non-empty;
  coherence
    proof
        rng(M|A) c= rng M by FUNCT_1:76;
      hence not {} in rng(M|A) by RELAT_1:def 9;
    end;
end;


theorem :: PRE_CIRC:6
  for I being non empty set, B being non-empty ManySortedSet of I
    holds union rng B is non empty;

theorem :: PRE_CIRC:7
  for I being set holds uncurry (I --> {}) = {};

theorem :: PRE_CIRC:8
    for I being non empty set, A being set,
    B being non-empty ManySortedSet of I,
    F being ManySortedFunction of (I --> A), B
    holds dom commute F = A;

scheme :: PRE_CIRC:sch 3
 LambdaRecCorrD {D() -> non empty set,
                  A() -> Element of D(),
                  F(Nat, Element of D()) -> Element of D() } :
    (ex f being Function of NAT, D() st f.0 = A()
      & for i being Nat holds f.(i+1) = F(i, f.i))
      & for f1, f2 being Function of NAT, D() st (f1.0 = A()
          & for i being Nat holds f1.(i+1) = F(i, f1.i))
          & (f2.0 = A() & for i being Nat holds f2.(i+1) = F(i,f2.i))
          holds f1 = f2
proof
    deffunc G(Nat,Element of D()) = F($1,$2);
    thus ex f being Function of NAT, D() st f.0 = A()
      & for i being Nat holds f.(i+1) = G(i,f.i) from RECDEF_1:sch 4;
     let f1, f2 be Function of NAT, D() such that
A1:   f1.0 = A() & for i being Nat holds f1.(i+1) = G(i,f1.i) and
A2:   f2.0 = A() & for i being Nat holds f2.(i+1) = G(i,f2.i);
     thus f1 = f2 from RECDEF_1:sch 12(A1,A2);
    end;

scheme :: PRE_CIRC:sch 4
 LambdaMSFD{J() -> non empty set, I() -> Subset of J(),
    A, B() -> ManySortedSet of I(), F(set) -> set } :
    ex f being ManySortedFunction of A(), B() st
      for i being Element of J() st i in I() holds f.i = F(i)
  provided
  for i being Element of J() st i in I()
     holds F(i) is Function of A().i, B().i
proof
      deffunc G(set) = F($1);
      consider f being ManySortedSet of I() such that
A2:     for i st i in I() holds f.i = G(i) from MSUALG_1:sch 2;
        f is Function-yielding
       proof let i;
        assume i in dom f;
         then A3:       i in I() by PBOOLE:def 3;
         then F(i) is Function by A1;
        hence thesis by A2,A3;
       end;
      then reconsider f as ManySortedFunction of I();
        f is ManySortedFunction of A(), B()
       proof let i;
        assume
A4:      i in I();
         then F(i) is Function of A().i, B().i by A1;
        hence thesis by A2,A4;
       end;
      then reconsider f as ManySortedFunction of A(), B();
     take f;
     thus thesis by A2;
    end;

registration
  let F be non-empty Function, f be Function;
  cluster F * f -> non-empty;
  coherence
    proof
      rng(F*f) c= rng F by RELAT_1:45;
      hence not {} in rng(F*f) by RELAT_1:def 9;
    end;
end;


registration
  let I be set, MSS be non-empty ManySortedSet of I;
  cluster -> Function-like Relation-like Element of (product MSS);
  coherence;
end;


theorem :: PRE_CIRC:9
    for I being set, f being non-empty ManySortedSet of I, g being Function,
    s being Element of product f
      st dom g c= dom f & for x being set st x in dom g holds g.x in f.x
    holds s+*g is Element of product f;

theorem :: PRE_CIRC:10
    for A, B being non empty set,
    C being non-empty ManySortedSet of A,
    InpFs being ManySortedFunction of A --> B, C,
    b being Element of B
    ex c being ManySortedSet of A st c = (commute InpFs).b & c in C;

theorem :: PRE_CIRC:11
    for I being set, M be ManySortedSet of I,
    x, g being Function st x in product M
    holds x * g in product (M * g);

theorem :: PRE_CIRC:12
    for n being Nat, a being set
    holds product ( n |-> {a} ) = { n |-> a };

begin
::---------------------------------------------------------------------------
:: Trees
::---------------------------------------------------------------------------

reserve T,T1 for finite Tree,
        t,p for Element of T,
        t1 for Element of T1;

registration
  let D be non empty set;
  cluster -> finite Element of FinTrees D;
  coherence
    proof
      let t be Element of FinTrees D;
        dom t is finite;
      hence t is finite by AMI_1:21;
    end;
end;


registration
  let T be finite DecoratedTree, t be Element of dom T;
  cluster T|t -> finite;
  coherence
    proof
       dom(T|t) = (dom T)|t by TREES_2:def 11;
     hence thesis by AMI_1:21;
    end;
end;


theorem :: PRE_CIRC:13
  T|p,{ t : p is_a_prefix_of t } are_equipotent;

registration
  let T be finite DecoratedTree, t be Element of dom T;
  let T1 be finite DecoratedTree;
  cluster T with-replacement (t,T1) -> finite;
  coherence
    proof
        dom (T with-replacement (t,T1)) =
        dom T with-replacement (t,dom T1) by TREES_2:def 12;
     hence thesis by AMI_1:21;
    end;
end;


theorem :: PRE_CIRC:14
  T with-replacement (p,T1) =
    { t : not p is_a_prefix_of t } \/ { p^t1 : not contradiction };

theorem :: PRE_CIRC:15
 for f being FinSequence of NAT st f in T with-replacement (p,T1) &
   p is_a_prefix_of f ex t1 st f = p^t1;

theorem :: PRE_CIRC:16
 for p being Tree-yielding FinSequence, k being Nat st k+1 in dom p
  holds (tree p)|<*k*> = p.(k+1);

theorem :: PRE_CIRC:17
    for q being DTree-yielding FinSequence, k being Nat st k+1 in dom q
        holds <*k*> in tree doms q;

theorem :: PRE_CIRC:18
 for p,q being Tree-yielding FinSequence, k being Nat
   st len p = len q & k+1 in dom p &
      for i being Nat st i in dom p & i <> k+1 holds p.i = q.i
 for t being Tree st q.(k+1) = t
  holds tree(q) = tree(p) with-replacement (<*k*>, t);

theorem :: PRE_CIRC:19
    for e1,e2 being finite DecoratedTree, x being set, k being Nat,
      p being DTree-yielding FinSequence st
       <*k*> in dom e1 & e1 = x-tree p
  ex q being DTree-yielding FinSequence st
   e1 with-replacement (<*k*>,e2) = x-tree q &
    len q = len p & q.(k+1) = e2 &
    for i being Nat st i in dom p & i <> k+1 holds q.i = p.i;

theorem :: PRE_CIRC:20
    for T being finite Tree, p being Element of T st p <> {}
    holds card (T|p) < card T;

theorem :: PRE_CIRC:21
 for f being Function holds Card (f qua set) = Card dom f;

theorem :: PRE_CIRC:22
  for T, T1 being finite Tree, p being Element of T
    holds card(T with-replacement (p,T1)) + card (T|p) = card T + card T1;

theorem :: PRE_CIRC:23
    for T, T1 being finite DecoratedTree,
    p being Element of dom T
    holds card(T with-replacement (p,T1)) + card (T|p) = card T + card T1;

registration let x be set;
 cluster root-tree x -> finite;
 coherence
  proof
      root-tree x = {[{},x]} by TREES_4:6;
   hence thesis;
  end;
end;


theorem :: PRE_CIRC:24
   for x being set
    holds card root-tree x = 1;

