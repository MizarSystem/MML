:: On the compositions of macro instructions, Part III
::  by Noriko Asamoto , Yatsuka Nakamura , Piotr Rudnicki and Andrzej Trybulec
::
:: Received July 22, 1996
:: Copyright (c) 1996 Association of Mizar Users

environ

 vocabulary AMI_1, SCMFSA_2, AMI_3, SCMFSA6B, SCMFSA6A, FUNCT_1, FUNCT_4,
      CARD_1, RELAT_1, FUNCOP_1, BOOLE, AMI_2, SF_MASTR, CAT_1, FUNCT_7, AMI_5,
      ARYTM_1, NAT_1, ABSVALUE, FINSEQ_1, FINSEQ_2, SCMFSA6C, FINSEQ_4;
 notation TARSKI, XBOOLE_0, ENUMSET1, XCMPLX_0, XREAL_0, NAT_1, INT_1,
      ABSVALUE, RELAT_1, FUNCT_1, FINSEQ_1, FINSEQ_2, FINSEQ_4, CARD_1,
      CQC_LANG, FUNCT_4, STRUCT_0, AMI_1, AMI_3, AMI_5, FUNCT_7, SCMFSA_2,
      SCMFSA_4, SCMFSA6A, SF_MASTR, SCMFSA6B;
 constructors SCMFSA6A, SF_MASTR, SCMFSA6B, NAT_1, AMI_5, SETWISEO, FINSEQ_4;
 clusters AMI_1, SCMFSA_2, FUNCT_1, FINSET_1, RELSET_1, SCMFSA6A, SF_MASTR,
      SCMFSA6B, INT_1, CQC_LANG, FRAENKEL, XBOOLE_0, ORDINAL2, NUMBERS;
 requirements NUMERALS, BOOLE, SUBSET, ARITHM;


begin :: Consequences of the main theorem from SCMFSA6B

 reserve m, n for Nat,
         x for set,
         i for Instruction of SCM+FSA,

         a,b for Int-Location, f for FinSeq-Location,
         l, l1 for Instruction-Location of SCM+FSA,
         s,s1,s2 for State of SCM+FSA;

theorem :: SCMFSA6C:1
   for I being keeping_0 parahalting Macro-Instruction,
     J being parahalting Macro-Instruction
  holds IExec(I ';' J, s).a = IExec(J,IExec(I,s)).a;

theorem :: SCMFSA6C:2
   for I being keeping_0 parahalting Macro-Instruction,
     J being parahalting Macro-Instruction
  holds IExec(I ';' J, s).f = IExec(J,IExec(I,s)).f;

begin :: Properties of simple macro instructions

definition
 let i be Instruction of SCM+FSA;
 attr i is parahalting means
:: SCMFSA6C:def 1
 Macro i is parahalting;
 attr i is keeping_0 means
:: SCMFSA6C:def 2
 Macro i is keeping_0;
end;

registration
 cluster halt SCM+FSA -> keeping_0 parahalting;
 coherence proof
  thus Macro halt SCM+FSA is keeping_0 parahalting by Lm2;
 end;
end;


registration
 cluster keeping_0 parahalting Instruction of SCM+FSA;
 existence proof
  take halt SCM+FSA;
  thus thesis;
 end;
end;


registration
 let i be parahalting Instruction of SCM+FSA;
 cluster Macro i -> parahalting;
 coherence by Def1;
end;


registration
 let i be keeping_0 Instruction of SCM+FSA;
 cluster Macro i -> keeping_0;
 coherence by Def2;
end;


registration
 let a, b be Int-Location;
 cluster a := b -> parahalting;
 coherence proof
  let s such that
A1: Macro (a := b) +* Start-At insloc 0 c= s;
  set Ma = Macro (a := b);
  take 1;
      SA0 c= Macro (a := b) +* Start-At insloc 0 by FUNCT_4:26;
then A2:  SA0 c= s by A1,XBOOLE_1:1;
     dom Start-At insloc 0 = {IC SCM+FSA} by AMI_3:34;
then A3: IC SCM+FSA in dom SA0 by TARSKI:def 1;
A4: IC s = s.IC SCM+FSA by AMI_1:def 15
       .= SA0.IC SCM+FSA by A2,A3,GRFUNC_1:8
         .= insloc 0 by AMI_3:50;
A5: insloc 0 in dom Ma & insloc 1 in dom Ma by SCMFSA6B:32;
     Ma c= s by A1,SCMFSA6B:5;
   then Ma.insloc 0 = s.insloc 0 & Ma.insloc 1 = s.insloc 1 by A5,GRFUNC_1:8;
then A6: s.insloc 0 = a:=b & s.insloc 1 = halt SCM+FSA by SCMFSA6B:33;
A7: IC Exec(a:=b, s) = Exec(a:=b, s).IC SCM+FSA by AMI_1:def 15
                   .= Next insloc 0 by A4,SCMFSA_2:89
                   .= insloc (0+1) by SCMFSA_2:32;
   (Computation s).(0+1) = Following (Computation s).0 by AMI_1:def 19
      .= Following s by AMI_1:def 19
      .= Exec(CurInstr s, s) by AMI_1:def 18
      .= Exec(a:=b, s) by A4,A6,AMI_1:def 17;
  hence CurInstr((Computation s).1)
      = Exec(a:=b, s).IC Exec(a:=b, s) by AMI_1:def 17
     .= halt SCM+FSA by A6,A7,AMI_1:def 13;
 end;

 cluster AddTo(a,b) -> parahalting;
 coherence proof
  let s such that
A8: Macro (AddTo(a,b)) +* Start-At insloc 0 c= s;
  set Ma = Macro (AddTo(a,b));
  take 1;
      SA0 c= Macro (AddTo(a,b)) +* Start-At insloc 0 by FUNCT_4:26;
then A9:  SA0 c= s by A8,XBOOLE_1:1;
     dom Start-At insloc 0 = {IC SCM+FSA} by AMI_3:34;
then A10: IC SCM+FSA in dom SA0 by TARSKI:def 1;
A11: IC s = s.IC SCM+FSA by AMI_1:def 15
       .= SA0.IC SCM+FSA by A9,A10,GRFUNC_1:8
         .= insloc 0 by AMI_3:50;
A12: insloc 0 in dom Ma & insloc 1 in dom Ma by SCMFSA6B:32;
     Ma c= s by A8,SCMFSA6B:5;
   then Ma.insloc 0 = s.insloc 0 & Ma.insloc 1 = s.insloc 1 by A12,GRFUNC_1:8;
then A13: s.insloc 0 = AddTo(a,b) & s.insloc 1 = halt SCM+FSA by SCMFSA6B:33;
A14: IC Exec(AddTo(a,b), s) = Exec(AddTo(a,b), s).IC SCM+FSA by AMI_1:def 15
                   .= Next insloc 0 by A11,SCMFSA_2:90
                   .= insloc (0+1) by SCMFSA_2:32;
   (Computation s).(0+1) = Following (Computation s).0 by AMI_1:def 19
      .= Following s by AMI_1:def 19
      .= Exec(CurInstr s, s) by AMI_1:def 18
      .= Exec(AddTo(a,b), s) by A11,A13,AMI_1:def 17;
  hence CurInstr((Computation s).1)
      = Exec(AddTo(a,b), s).IC Exec(AddTo(a,b), s) by AMI_1:def 17
     .= halt SCM+FSA by A13,A14,AMI_1:def 13;
 end;

 cluster SubFrom(a,b) -> parahalting;
 coherence proof
  let s such that
A15: Macro (SubFrom(a,b)) +* Start-At insloc 0 c= s;
  set Ma = Macro (SubFrom(a,b));
  take 1;
      SA0 c= Macro (SubFrom(a,b)) +* Start-At insloc 0 by FUNCT_4:26;
then A16:  SA0 c= s by A15,XBOOLE_1:1;
     dom Start-At insloc 0 = {IC SCM+FSA} by AMI_3:34;
then A17: IC SCM+FSA in dom SA0 by TARSKI:def 1;
A18: IC s = s.IC SCM+FSA by AMI_1:def 15
       .= SA0.IC SCM+FSA by A16,A17,GRFUNC_1:8
         .= insloc 0 by AMI_3:50;
A19: insloc 0 in dom Ma & insloc 1 in dom Ma by SCMFSA6B:32;
     Ma c= s by A15,SCMFSA6B:5;
   then Ma.insloc 0 = s.insloc 0 & Ma.insloc 1 = s.insloc 1 by A19,GRFUNC_1:8;
then A20: s.insloc 0 = SubFrom(a,b) & s.insloc 1 = halt SCM+FSA by SCMFSA6B:33;
A21: IC Exec(SubFrom(a,b), s) = Exec(SubFrom(a,b), s).IC SCM+FSA by AMI_1:def
15
                   .= Next insloc 0 by A18,SCMFSA_2:91
                   .= insloc (0+1) by SCMFSA_2:32;
   (Computation s).(0+1) = Following (Computation s).0 by AMI_1:def 19
      .= Following s by AMI_1:def 19
      .= Exec(CurInstr s, s) by AMI_1:def 18
      .= Exec(SubFrom(a,b), s) by A18,A20,AMI_1:def 17;
  hence CurInstr((Computation s).1)
      = Exec(SubFrom(a,b), s).IC Exec(SubFrom(a,b), s) by AMI_1:def 17
     .= halt SCM+FSA by A20,A21,AMI_1:def 13;
end;

 cluster MultBy(a,b) -> parahalting;
 coherence proof
  let s such that
A22: Macro (MultBy(a,b)) +* Start-At insloc 0 c= s;
  set Ma = Macro (MultBy(a,b));
  take 1;
      SA0 c= Macro (MultBy(a,b)) +* Start-At insloc 0 by FUNCT_4:26;
then A23:  SA0 c= s by A22,XBOOLE_1:1;
     dom Start-At insloc 0 = {IC SCM+FSA} by AMI_3:34;
then A24: IC SCM+FSA in dom SA0 by TARSKI:def 1;
A25: IC s = s.IC SCM+FSA by AMI_1:def 15
       .= SA0.IC SCM+FSA by A23,A24,GRFUNC_1:8
         .= insloc 0 by AMI_3:50;
A26: insloc 0 in dom Ma & insloc 1 in dom Ma by SCMFSA6B:32;
     Ma c= s by A22,SCMFSA6B:5;
   then Ma.insloc 0 = s.insloc 0 & Ma.insloc 1 = s.insloc 1 by A26,GRFUNC_1:8;
then A27: s.insloc 0 = MultBy(a,b) & s.insloc 1 = halt SCM+FSA by SCMFSA6B:33;
A28: IC Exec(MultBy(a,b), s) = Exec(MultBy(a,b), s).IC SCM+FSA by AMI_1:def 15
                   .= Next insloc 0 by A25,SCMFSA_2:92
                   .= insloc (0+1) by SCMFSA_2:32;
   (Computation s).(0+1) = Following (Computation s).0 by AMI_1:def 19
      .= Following s by AMI_1:def 19
      .= Exec(CurInstr s, s) by AMI_1:def 18
      .= Exec(MultBy(a,b), s) by A25,A27,AMI_1:def 17;
  hence CurInstr((Computation s).1)
      = Exec(MultBy(a,b), s).IC Exec(MultBy(a,b), s) by AMI_1:def 17
     .= halt SCM+FSA by A27,A28,AMI_1:def 13;
end;

 cluster Divide(a,b) -> parahalting;
 coherence proof
  let s such that
A29: Macro (Divide(a,b)) +* Start-At insloc 0 c= s;
  set Ma = Macro (Divide(a,b));
  take 1;
      SA0 c= Macro (Divide(a,b)) +* Start-At insloc 0 by FUNCT_4:26;
then A30:  SA0 c= s by A29,XBOOLE_1:1;
     dom Start-At insloc 0 = {IC SCM+FSA} by AMI_3:34;
then A31: IC SCM+FSA in dom SA0 by TARSKI:def 1;
A32: IC s = s.IC SCM+FSA by AMI_1:def 15
       .= SA0.IC SCM+FSA by A30,A31,GRFUNC_1:8
         .= insloc 0 by AMI_3:50;
A33: insloc 0 in dom Ma & insloc 1 in dom Ma by SCMFSA6B:32;
     Ma c= s by A29,SCMFSA6B:5;
   then Ma.insloc 0 = s.insloc 0 & Ma.insloc 1 = s.insloc 1 by A33,GRFUNC_1:8;
then A34: s.insloc 0 = Divide(a,b) & s.insloc 1 = halt SCM+FSA by SCMFSA6B:33;
A35: IC Exec(Divide(a,b), s) = Exec(Divide(a,b), s).IC SCM+FSA by AMI_1:def 15
                   .= Next insloc 0 by A32,SCMFSA_2:93
                   .= insloc (0+1) by SCMFSA_2:32;
   (Computation s).(0+1) = Following (Computation s).0 by AMI_1:def 19
      .= Following s by AMI_1:def 19
      .= Exec(CurInstr s, s) by AMI_1:def 18
      .= Exec(Divide(a,b), s) by A32,A34,AMI_1:def 17;
  hence CurInstr((Computation s).1)
      = Exec(Divide(a,b), s).IC Exec(Divide(a,b), s) by AMI_1:def 17
     .= halt SCM+FSA by A34,A35,AMI_1:def 13;
end;

 let f be FinSeq-Location;
 cluster b := (f,a) -> parahalting;
 coherence proof
  let s such that
A36: Macro (b:=(f,a)) +* Start-At insloc 0 c= s;
  set Ma = Macro (b:=(f,a));
  take 1;
      SA0 c= Macro (b:=(f,a)) +* Start-At insloc 0 by FUNCT_4:26;
then A37:  SA0 c= s by A36,XBOOLE_1:1;
     dom Start-At insloc 0 = {IC SCM+FSA} by AMI_3:34;
then A38: IC SCM+FSA in dom SA0 by TARSKI:def 1;
A39: IC s = s.IC SCM+FSA by AMI_1:def 15
       .= SA0.IC SCM+FSA by A37,A38,GRFUNC_1:8
         .= insloc 0 by AMI_3:50;
A40: insloc 0 in dom Ma & insloc 1 in dom Ma by SCMFSA6B:32;
     Ma c= s by A36,SCMFSA6B:5;
   then Ma.insloc 0 = s.insloc 0 & Ma.insloc 1 = s.insloc 1 by A40,GRFUNC_1:8;
then A41: s.insloc 0 = b:=(f,a) & s.insloc 1 = halt SCM+FSA by SCMFSA6B:33;
A42: IC Exec(b:=(f,a), s) = Exec(b:=(f,a), s).IC SCM+FSA by AMI_1:def 15
                   .= Next insloc 0 by A39,SCMFSA_2:98
                   .= insloc (0+1) by SCMFSA_2:32;
   (Computation s).(0+1) = Following (Computation s).0 by AMI_1:def 19
      .= Following s by AMI_1:def 19
      .= Exec(CurInstr s, s) by AMI_1:def 18
      .= Exec(b:=(f,a), s) by A39,A41,AMI_1:def 17;
  hence CurInstr((Computation s).1)
      = Exec(b:=(f,a), s).IC Exec(b:=(f,a), s) by AMI_1:def 17
     .= halt SCM+FSA by A41,A42,AMI_1:def 13;
end;

 cluster (f,a) := b -> parahalting keeping_0;
 coherence proof
 thus (f,a) := b is parahalting proof
  let s such that
A43: Macro ((f,a):=b) +* Start-At insloc 0 c= s;
  set Ma = Macro ((f,a):=b);
  take 1;
      SA0 c= Macro ((f,a):=b) +* Start-At insloc 0 by FUNCT_4:26;
then A44:  SA0 c= s by A43,XBOOLE_1:1;
     dom Start-At insloc 0 = {IC SCM+FSA} by AMI_3:34;
then A45: IC SCM+FSA in dom SA0 by TARSKI:def 1;
A46: IC s = s.IC SCM+FSA by AMI_1:def 15
       .= SA0.IC SCM+FSA by A44,A45,GRFUNC_1:8
         .= insloc 0 by AMI_3:50;
A47: insloc 0 in dom Ma & insloc 1 in dom Ma by SCMFSA6B:32;
     Ma c= s by A43,SCMFSA6B:5;
   then Ma.insloc 0 = s.insloc 0 & Ma.insloc 1 = s.insloc 1 by A47,GRFUNC_1:8;
then A48: s.insloc 0 = (f,a):=b & s.insloc 1 = halt SCM+FSA by SCMFSA6B:33;
A49: IC Exec((f,a):=b, s) = Exec((f,a):=b, s).IC SCM+FSA by AMI_1:def 15
                   .= Next insloc 0 by A46,SCMFSA_2:99
                   .= insloc (0+1) by SCMFSA_2:32;
   (Computation s).(0+1) = Following (Computation s).0 by AMI_1:def 19
      .= Following s by AMI_1:def 19
      .= Exec(CurInstr s, s) by AMI_1:def 18
      .= Exec((f,a):=b, s) by A46,A48,AMI_1:def 17;
  hence CurInstr((Computation s).1)
      = Exec((f,a):=b, s).IC Exec((f,a):=b, s) by AMI_1:def 17
     .= halt SCM+FSA by A48,A49,AMI_1:def 13;
 end;
 thus (f,a) := b is keeping_0 proof
  let s; assume
A50: Macro ((f,a):=b) +* Start-At insloc 0 c= s;
  let k be Nat;
  set Ma = Macro ((f,a):=b);
      SA0 c= Macro ((f,a):=b) +* Start-At insloc 0 by FUNCT_4:26;
then A51:  SA0 c= s by A50,XBOOLE_1:1;
     dom Start-At insloc 0 = {IC SCM+FSA} by AMI_3:34;
then A52: IC SCM+FSA in dom SA0 by TARSKI:def 1;
A53: IC s = s.IC SCM+FSA by AMI_1:def 15
       .= SA0.IC SCM+FSA by A51,A52,GRFUNC_1:8
         .= insloc 0 by AMI_3:50;
A54: insloc 0 in dom Ma & insloc 1 in dom Ma by SCMFSA6B:32;
     Ma c= s by A50,SCMFSA6B:5;
   then Ma.insloc 0 = s.insloc 0 & Ma.insloc 1 = s.insloc 1 by A54,GRFUNC_1:8;
then A55: s.insloc 0 = (f,a):=b & s.insloc 1 = halt SCM+FSA by SCMFSA6B:33;
A56: IC Exec((f,a):=b, s) = Exec((f,a):=b, s).IC SCM+FSA by AMI_1:def 15
                   .= Next insloc 0 by A53,SCMFSA_2:99
                   .= insloc (0+1) by SCMFSA_2:32;
A57: (Computation s).(0+1) = Following (Computation s).0 by AMI_1:def 19
      .= Following s by AMI_1:def 19
      .= Exec(CurInstr s, s) by AMI_1:def 18
      .= Exec((f,a):=b, s) by A53,A55,AMI_1:def 17;
then A58: CurInstr((Computation s).1)
      = Exec((f,a):=b, s).IC Exec((f,a):=b, s) by AMI_1:def 17
     .= halt SCM+FSA by A55,A56,AMI_1:def 13;
  per cases by RLVECT_1:99;
  suppose k = 0;
   hence ((Computation s).k).intloc 0 = s.intloc 0 by AMI_1:def 19;
  end;
  suppose
  A59: 1 <= k;
      (Computation s).1.intloc 0 = s.intloc 0 by A57,SCMFSA_2:99;
   hence ((Computation s).k).intloc 0 = s.intloc 0 by A58,A59,AMI_1:52;
 end;
 end;
 end;
end;


registration
 let a be Int-Location, f be FinSeq-Location;
 cluster a :=len f -> parahalting;
 coherence proof
  let s such that
A1: Macro (a:=len f) +* Start-At insloc 0 c= s;
  set Ma = Macro (a:=len f);
  take 1;
      SA0 c= Macro (a:=len f) +* Start-At insloc 0 by FUNCT_4:26;
then A2:  SA0 c= s by A1,XBOOLE_1:1;
     dom Start-At insloc 0 = {IC SCM+FSA} by AMI_3:34;
then A3: IC SCM+FSA in dom SA0 by TARSKI:def 1;
A4: IC s = s.IC SCM+FSA by AMI_1:def 15
       .= SA0.IC SCM+FSA by A2,A3,GRFUNC_1:8
         .= insloc 0 by AMI_3:50;
A5: insloc 0 in dom Ma & insloc 1 in dom Ma by SCMFSA6B:32;
     Ma c= s by A1,SCMFSA6B:5;
   then Ma.insloc 0 = s.insloc 0 & Ma.insloc 1 = s.insloc 1 by A5,GRFUNC_1:8;
then A6: s.insloc 0 = a:=len f & s.insloc 1 = halt SCM+FSA by SCMFSA6B:33;
A7: IC Exec(a:=len f, s) = Exec(a:=len f, s).IC SCM+FSA by AMI_1:def 15
                   .= Next insloc 0 by A4,SCMFSA_2:100
                   .= insloc (0+1) by SCMFSA_2:32;
   (Computation s).(0+1) = Following (Computation s).0 by AMI_1:def 19
      .= Following s by AMI_1:def 19
      .= Exec(CurInstr s, s) by AMI_1:def 18
      .= Exec(a:=len f, s) by A4,A6,AMI_1:def 17;
  hence CurInstr((Computation s).1)
      = Exec(a:=len f, s).IC Exec(a:=len f, s) by AMI_1:def 17
     .= halt SCM+FSA by A6,A7,AMI_1:def 13;
end;

 cluster f :=<0,...,0> a -> parahalting keeping_0;
 coherence proof
 thus f :=<0,...,0> a is parahalting proof
  let s such that
A8: Macro (f:=<0,...,0>a) +* Start-At insloc 0 c= s;
  set Ma = Macro (f:=<0,...,0>a);
  take 1;
      SA0 c= Macro (f:=<0,...,0>a) +* Start-At insloc 0 by FUNCT_4:26;
then A9:  SA0 c= s by A8,XBOOLE_1:1;
     dom Start-At insloc 0 = {IC SCM+FSA} by AMI_3:34;
then A10: IC SCM+FSA in dom SA0 by TARSKI:def 1;
A11: IC s = s.IC SCM+FSA by AMI_1:def 15
       .= SA0.IC SCM+FSA by A9,A10,GRFUNC_1:8
         .= insloc 0 by AMI_3:50;
A12: insloc 0 in dom Ma & insloc 1 in dom Ma by SCMFSA6B:32;
     Ma c= s by A8,SCMFSA6B:5;
   then Ma.insloc 0 = s.insloc 0 & Ma.insloc 1 = s.insloc 1 by A12,GRFUNC_1:8;
then A13: s.insloc 0 = f:=<0,...,0>a & s.insloc 1 = halt SCM+FSA by SCMFSA6B:33
;
A14:IC Exec(f:=<0,...,0>a, s) = Exec(f:=<0,...,0>a, s).IC SCM+FSA by AMI_1:def
15
                   .= Next insloc 0 by A11,SCMFSA_2:101
                   .= insloc (0+1) by SCMFSA_2:32;
   (Computation s).(0+1) = Following (Computation s).0 by AMI_1:def 19
      .= Following s by AMI_1:def 19
      .= Exec(CurInstr s, s) by AMI_1:def 18
      .= Exec(f:=<0,...,0>a, s) by A11,A13,AMI_1:def 17;
  hence CurInstr((Computation s).1)
      = Exec(f:=<0,...,0>a, s).IC Exec(f:=<0,...,0>a, s) by AMI_1:def 17
     .= halt SCM+FSA by A13,A14,AMI_1:def 13;
 end;
thus (f:=<0,...,0>a) is keeping_0 proof
  let s; assume
A15: Macro (f:=<0,...,0>a) +* Start-At insloc 0 c= s;
  let k be Nat;
  set Ma = Macro (f:=<0,...,0>a);
      SA0 c= Macro (f:=<0,...,0>a) +* Start-At insloc 0 by FUNCT_4:26;
then A16:  SA0 c= s by A15,XBOOLE_1:1;
     dom Start-At insloc 0 = {IC SCM+FSA} by AMI_3:34;
then A17: IC SCM+FSA in dom SA0 by TARSKI:def 1;
A18: IC s = s.IC SCM+FSA by AMI_1:def 15
       .= SA0.IC SCM+FSA by A16,A17,GRFUNC_1:8
         .= insloc 0 by AMI_3:50;
A19: insloc 0 in dom Ma & insloc 1 in dom Ma by SCMFSA6B:32;
     Ma c= s by A15,SCMFSA6B:5;
   then Ma.insloc 0 = s.insloc 0 & Ma.insloc 1 = s.insloc 1 by A19,GRFUNC_1:8;
then A20: s.insloc 0 = f:=<0,...,0>a & s.insloc 1 = halt SCM+FSA by SCMFSA6B:33
;
A21:IC Exec(f:=<0,...,0>a, s) = Exec(f:=<0,...,0>a, s).IC SCM+FSA by AMI_1:def
15
                   .= Next insloc 0 by A18,SCMFSA_2:101
                   .= insloc (0+1) by SCMFSA_2:32;
A22: (Computation s).(0+1) = Following (Computation s).0 by AMI_1:def 19
      .= Following s by AMI_1:def 19
      .= Exec(CurInstr s, s) by AMI_1:def 18
      .= Exec(f:=<0,...,0>a, s) by A18,A20,AMI_1:def 17;
then A23: CurInstr((Computation s).1)
      = Exec(f:=<0,...,0>a, s).IC Exec(f:=<0,...,0>a, s) by AMI_1:def 17
     .= halt SCM+FSA by A20,A21,AMI_1:def 13;
  per cases by RLVECT_1:99;
  suppose k = 0;
   hence ((Computation s).k).intloc 0 = s.intloc 0 by AMI_1:def 19;
  end;
  suppose
  A24: 1 <= k;
      (Computation s).1.intloc 0 = s.intloc 0 by A22,SCMFSA_2:101;
   hence ((Computation s).k).intloc 0 = s.intloc 0 by A23,A24,AMI_1:52;
 end;
 end;
end;
end;


registration
 let a be read-write Int-Location, b be Int-Location;
 cluster a := b -> keeping_0;
 coherence proof
  let s; assume
A1: Macro (a:=b) +* Start-At insloc 0 c= s;
  let k be Nat;
  set Ma = Macro (a:=b);
      SA0 c= Macro (a:=b) +* Start-At insloc 0 by FUNCT_4:26;
then A2:  SA0 c= s by A1,XBOOLE_1:1;
     dom Start-At insloc 0 = {IC SCM+FSA} by AMI_3:34;
then A3: IC SCM+FSA in dom SA0 by TARSKI:def 1;
A4: IC s = s.IC SCM+FSA by AMI_1:def 15
       .= SA0.IC SCM+FSA by A2,A3,GRFUNC_1:8
         .= insloc 0 by AMI_3:50;
A5: insloc 0 in dom Ma & insloc 1 in dom Ma by SCMFSA6B:32;
     Ma c= s by A1,SCMFSA6B:5;
   then Ma.insloc 0 = s.insloc 0 & Ma.insloc 1 = s.insloc 1 by A5,GRFUNC_1:8;
then A6: s.insloc 0 = a:=b & s.insloc 1 = halt SCM+FSA by SCMFSA6B:33;
A7: IC Exec(a:=b, s) = Exec(a:=b, s).IC SCM+FSA by AMI_1:def 15
                   .= Next insloc 0 by A4,SCMFSA_2:89
                   .= insloc (0+1) by SCMFSA_2:32;
A8: (Computation s).(0+1) = Following (Computation s).0 by AMI_1:def 19
      .= Following s by AMI_1:def 19
      .= Exec(CurInstr s, s) by AMI_1:def 18
      .= Exec(a:=b, s) by A4,A6,AMI_1:def 17;
then A9: CurInstr((Computation s).1)
      = Exec(a:=b, s).IC Exec(a:=b, s) by AMI_1:def 17
     .= halt SCM+FSA by A6,A7,AMI_1:def 13;
  per cases by RLVECT_1:99;
  suppose k = 0;
   hence ((Computation s).k).intloc 0 = s.intloc 0 by AMI_1:def 19;
  end;
  suppose
  A10: 1 <= k;
      (Computation s).1.intloc 0 = s.intloc 0 by A8,SCMFSA_2:89;
   hence ((Computation s).k).intloc 0 = s.intloc 0 by A9,A10,AMI_1:52;
 end;
 end;

 cluster AddTo(a, b) -> keeping_0;
 coherence proof
  let s; assume
A11: Macro (AddTo(a,b)) +* Start-At insloc 0 c= s;
  let k be Nat;
  set Ma = Macro (AddTo(a,b));
      SA0 c= Macro (AddTo(a,b)) +* Start-At insloc 0 by FUNCT_4:26;
then A12:  SA0 c= s by A11,XBOOLE_1:1;
     dom Start-At insloc 0 = {IC SCM+FSA} by AMI_3:34;
then A13: IC SCM+FSA in dom SA0 by TARSKI:def 1;
A14: IC s = s.IC SCM+FSA by AMI_1:def 15
       .= SA0.IC SCM+FSA by A12,A13,GRFUNC_1:8
         .= insloc 0 by AMI_3:50;
A15: insloc 0 in dom Ma & insloc 1 in dom Ma by SCMFSA6B:32;
     Ma c= s by A11,SCMFSA6B:5;
   then Ma.insloc 0 = s.insloc 0 & Ma.insloc 1 = s.insloc 1 by A15,GRFUNC_1:8;
then A16: s.insloc 0 = AddTo(a,b) & s.insloc 1 = halt SCM+FSA by SCMFSA6B:33;
A17: IC Exec(AddTo(a,b), s) = Exec(AddTo(a,b), s).IC SCM+FSA by AMI_1:def 15
                   .= Next insloc 0 by A14,SCMFSA_2:90
                   .= insloc (0+1) by SCMFSA_2:32;
A18: (Computation s).(0+1) = Following (Computation s).0 by AMI_1:def 19
      .= Following s by AMI_1:def 19
      .= Exec(CurInstr s, s) by AMI_1:def 18
      .= Exec(AddTo(a,b), s) by A14,A16,AMI_1:def 17;
then A19: CurInstr((Computation s).1)
      = Exec(AddTo(a,b), s).IC Exec(AddTo(a,b), s) by AMI_1:def 17
     .= halt SCM+FSA by A16,A17,AMI_1:def 13;
  per cases by RLVECT_1:99;
  suppose k = 0;
   hence ((Computation s).k).intloc 0 = s.intloc 0 by AMI_1:def 19;
  end;
  suppose
  A20: 1 <= k;
      (Computation s).1.intloc 0 = s.intloc 0 by A18,SCMFSA_2:90;
   hence ((Computation s).k).intloc 0 = s.intloc 0 by A19,A20,AMI_1:52;
 end;
 end;

 cluster SubFrom(a, b) -> keeping_0;
 coherence proof
  let s; assume
A21: Macro (SubFrom(a,b)) +* Start-At insloc 0 c= s;
  let k be Nat;
  set Ma = Macro (SubFrom(a,b));
      SA0 c= Macro (SubFrom(a,b)) +* Start-At insloc 0 by FUNCT_4:26;
then A22:  SA0 c= s by A21,XBOOLE_1:1;
     dom Start-At insloc 0 = {IC SCM+FSA} by AMI_3:34;
then A23: IC SCM+FSA in dom SA0 by TARSKI:def 1;
A24: IC s = s.IC SCM+FSA by AMI_1:def 15
       .= SA0.IC SCM+FSA by A22,A23,GRFUNC_1:8
         .= insloc 0 by AMI_3:50;
A25: insloc 0 in dom Ma & insloc 1 in dom Ma by SCMFSA6B:32;
     Ma c= s by A21,SCMFSA6B:5;
   then Ma.insloc 0 = s.insloc 0 & Ma.insloc 1 = s.insloc 1 by A25,GRFUNC_1:8;
then A26: s.insloc 0 = SubFrom(a,b) & s.insloc 1 = halt SCM+FSA by SCMFSA6B:33;
A27: IC Exec(SubFrom(a,b), s) = Exec(SubFrom(a,b), s).IC SCM+FSA by AMI_1:def
15
                   .= Next insloc 0 by A24,SCMFSA_2:91
                   .= insloc (0+1) by SCMFSA_2:32;
A28: (Computation s).(0+1) = Following (Computation s).0 by AMI_1:def 19
      .= Following s by AMI_1:def 19
      .= Exec(CurInstr s, s) by AMI_1:def 18
      .= Exec(SubFrom(a,b), s) by A24,A26,AMI_1:def 17;
then A29: CurInstr((Computation s).1)
      = Exec(SubFrom(a,b), s).IC Exec(SubFrom(a,b), s) by AMI_1:def 17
     .= halt SCM+FSA by A26,A27,AMI_1:def 13;
  per cases by RLVECT_1:99;
  suppose k = 0;
   hence ((Computation s).k).intloc 0 = s.intloc 0 by AMI_1:def 19;
  end;
  suppose
  A30: 1 <= k;
      (Computation s).1.intloc 0 = s.intloc 0 by A28,SCMFSA_2:91;
   hence ((Computation s).k).intloc 0 = s.intloc 0 by A29,A30,AMI_1:52;
 end;
 end;

 cluster MultBy(a, b) -> keeping_0;
 coherence proof
  let s; assume
A31: Macro (MultBy(a,b)) +* Start-At insloc 0 c= s;
  let k be Nat;
  set Ma = Macro (MultBy(a,b));
      SA0 c= Macro (MultBy(a,b)) +* Start-At insloc 0 by FUNCT_4:26;
then A32:  SA0 c= s by A31,XBOOLE_1:1;
     dom Start-At insloc 0 = {IC SCM+FSA} by AMI_3:34;
then A33: IC SCM+FSA in dom SA0 by TARSKI:def 1;
A34: IC s = s.IC SCM+FSA by AMI_1:def 15
       .= SA0.IC SCM+FSA by A32,A33,GRFUNC_1:8
         .= insloc 0 by AMI_3:50;
A35: insloc 0 in dom Ma & insloc 1 in dom Ma by SCMFSA6B:32;
     Ma c= s by A31,SCMFSA6B:5;
   then Ma.insloc 0 = s.insloc 0 & Ma.insloc 1 = s.insloc 1 by A35,GRFUNC_1:8;
then A36: s.insloc 0 = MultBy(a,b) & s.insloc 1 = halt SCM+FSA by SCMFSA6B:33;
A37: IC Exec(MultBy(a,b), s) = Exec(MultBy(a,b), s).IC SCM+FSA by AMI_1:def 15
                   .= Next insloc 0 by A34,SCMFSA_2:92
                   .= insloc (0+1) by SCMFSA_2:32;
A38: (Computation s).(0+1) = Following (Computation s).0 by AMI_1:def 19
      .= Following s by AMI_1:def 19
      .= Exec(CurInstr s, s) by AMI_1:def 18
      .= Exec(MultBy(a,b), s) by A34,A36,AMI_1:def 17;
then A39: CurInstr((Computation s).1)
      = Exec(MultBy(a,b), s).IC Exec(MultBy(a,b), s) by AMI_1:def 17
     .= halt SCM+FSA by A36,A37,AMI_1:def 13;
  per cases by RLVECT_1:99;
  suppose k = 0;
   hence ((Computation s).k).intloc 0 = s.intloc 0 by AMI_1:def 19;
  end;
  suppose
  A40: 1 <= k;
      (Computation s).1.intloc 0 = s.intloc 0 by A38,SCMFSA_2:92;
   hence ((Computation s).k).intloc 0 = s.intloc 0 by A39,A40,AMI_1:52;
 end;
 end;
end;


registration
 let a, b be read-write Int-Location;
 cluster Divide(a, b) -> keeping_0;
 coherence proof
  let s; assume
A1: Macro (Divide(a,b)) +* Start-At insloc 0 c= s;
  let k be Nat;
  set Ma = Macro (Divide(a,b));
      SA0 c= Macro (Divide(a,b)) +* Start-At insloc 0 by FUNCT_4:26;
then A2:  SA0 c= s by A1,XBOOLE_1:1;
     dom Start-At insloc 0 = {IC SCM+FSA} by AMI_3:34;
then A3: IC SCM+FSA in dom SA0 by TARSKI:def 1;
A4: IC s = s.IC SCM+FSA by AMI_1:def 15
       .= SA0.IC SCM+FSA by A2,A3,GRFUNC_1:8
         .= insloc 0 by AMI_3:50;
A5: insloc 0 in dom Ma & insloc 1 in dom Ma by SCMFSA6B:32;
     Ma c= s by A1,SCMFSA6B:5;
   then Ma.insloc 0 = s.insloc 0 & Ma.insloc 1 = s.insloc 1 by A5,GRFUNC_1:8;
then A6: s.insloc 0 = Divide(a,b) & s.insloc 1 = halt SCM+FSA by SCMFSA6B:33;
A7: IC Exec(Divide(a,b), s) = Exec(Divide(a,b), s).IC SCM+FSA by AMI_1:def 15
                   .= Next insloc 0 by A4,SCMFSA_2:93
                   .= insloc (0+1) by SCMFSA_2:32;
A8: (Computation s).(0+1) = Following (Computation s).0 by AMI_1:def 19
      .= Following s by AMI_1:def 19
      .= Exec(CurInstr s, s) by AMI_1:def 18
      .= Exec(Divide(a,b), s) by A4,A6,AMI_1:def 17;
then A9: CurInstr((Computation s).1)
      = Exec(Divide(a,b), s).IC Exec(Divide(a,b), s) by AMI_1:def 17
     .= halt SCM+FSA by A6,A7,AMI_1:def 13;
  per cases by RLVECT_1:99;
  suppose k = 0;
   hence ((Computation s).k).intloc 0 = s.intloc 0 by AMI_1:def 19;
  end;
  suppose
  A10: 1 <= k;
      (Computation s).1.intloc 0 = s.intloc 0 by A8,SCMFSA_2:93;
   hence ((Computation s).k).intloc 0 = s.intloc 0 by A9,A10,AMI_1:52;
 end;
 end;
end;


registration
 let a be Int-Location, f be FinSeq-Location, b be read-write Int-Location;
 cluster b := (f,a) -> keeping_0;
 coherence proof
  let s; assume
A1: Macro (b:=(f,a)) +* Start-At insloc 0 c= s;
  let k be Nat;
  set Ma = Macro (b:=(f,a));
      SA0 c= Macro (b:=(f,a)) +* Start-At insloc 0 by FUNCT_4:26;
then A2:  SA0 c= s by A1,XBOOLE_1:1;
     dom Start-At insloc 0 = {IC SCM+FSA} by AMI_3:34;
then A3: IC SCM+FSA in dom SA0 by TARSKI:def 1;
A4: IC s = s.IC SCM+FSA by AMI_1:def 15
       .= SA0.IC SCM+FSA by A2,A3,GRFUNC_1:8
         .= insloc 0 by AMI_3:50;
A5: insloc 0 in dom Ma & insloc 1 in dom Ma by SCMFSA6B:32;
     Ma c= s by A1,SCMFSA6B:5;
   then Ma.insloc 0 = s.insloc 0 & Ma.insloc 1 = s.insloc 1 by A5,GRFUNC_1:8;
then A6: s.insloc 0 = b:=(f,a) & s.insloc 1 = halt SCM+FSA by SCMFSA6B:33;
A7: IC Exec(b:=(f,a), s) = Exec(b:=(f,a), s).IC SCM+FSA by AMI_1:def 15
                   .= Next insloc 0 by A4,SCMFSA_2:98
                   .= insloc (0+1) by SCMFSA_2:32;
A8: (Computation s).(0+1) = Following (Computation s).0 by AMI_1:def 19
      .= Following s by AMI_1:def 19
      .= Exec(CurInstr s, s) by AMI_1:def 18
      .= Exec(b:=(f,a), s) by A4,A6,AMI_1:def 17;
then A9: CurInstr((Computation s).1)
      = Exec(b:=(f,a), s).IC Exec(b:=(f,a), s) by AMI_1:def 17
     .= halt SCM+FSA by A6,A7,AMI_1:def 13;
  per cases by RLVECT_1:99;
  suppose k = 0;
   hence ((Computation s).k).intloc 0 = s.intloc 0 by AMI_1:def 19;
  end;
  suppose
  A10: 1 <= k;
      (Computation s).1.intloc 0 = s.intloc 0 by A8,SCMFSA_2:98;
   hence ((Computation s).k).intloc 0 = s.intloc 0 by A9,A10,AMI_1:52;
 end;
 end;
end;


registration
 let f be FinSeq-Location, b be read-write Int-Location;
 cluster b :=len f -> keeping_0;
 coherence proof
  let s; assume
A1: Macro (b:=len f) +* Start-At insloc 0 c= s;
  let k be Nat;
  set Ma = Macro (b:=len f);
      SA0 c= Macro (b:=len f) +* Start-At insloc 0 by FUNCT_4:26;
then A2:  SA0 c= s by A1,XBOOLE_1:1;
     dom Start-At insloc 0 = {IC SCM+FSA} by AMI_3:34;
then A3: IC SCM+FSA in dom SA0 by TARSKI:def 1;
A4: IC s = s.IC SCM+FSA by AMI_1:def 15
       .= SA0.IC SCM+FSA by A2,A3,GRFUNC_1:8
         .= insloc 0 by AMI_3:50;
A5: insloc 0 in dom Ma & insloc 1 in dom Ma by SCMFSA6B:32;
     Ma c= s by A1,SCMFSA6B:5;
   then Ma.insloc 0 = s.insloc 0 & Ma.insloc 1 = s.insloc 1 by A5,GRFUNC_1:8;
then A6: s.insloc 0 = b:=len f & s.insloc 1 = halt SCM+FSA by SCMFSA6B:33;
A7: IC Exec(b:=len f, s) = Exec(b:=len f, s).IC SCM+FSA by AMI_1:def 15
                   .= Next insloc 0 by A4,SCMFSA_2:100
                   .= insloc (0+1) by SCMFSA_2:32;
A8: (Computation s).(0+1) = Following (Computation s).0 by AMI_1:def 19
      .= Following s by AMI_1:def 19
      .= Exec(CurInstr s, s) by AMI_1:def 18
      .= Exec(b:=len f, s) by A4,A6,AMI_1:def 17;
then A9: CurInstr((Computation s).1)
      = Exec(b:=len f, s).IC Exec(b:=len f, s) by AMI_1:def 17
     .= halt SCM+FSA by A6,A7,AMI_1:def 13;
  per cases by RLVECT_1:99;
  suppose k = 0;
   hence ((Computation s).k).intloc 0 = s.intloc 0 by AMI_1:def 19;
  end;
  suppose
  A10: 1 <= k;
      (Computation s).1.intloc 0 = s.intloc 0 by A8,SCMFSA_2:100;
   hence ((Computation s).k).intloc 0 = s.intloc 0 by A9,A10,AMI_1:52;
 end;
 end;
end;


registration
 let i be parahalting Instruction of SCM+FSA,
     J be parahalting Macro-Instruction;
 cluster i ';' J -> parahalting;
 coherence proof
     i ';' J = Macro i ';' J by SCMFSA6A:def 5;
  hence thesis;
 end;
end;


registration
 let I be parahalting Macro-Instruction,
     j be parahalting Instruction of SCM+FSA;
 cluster I ';' j -> parahalting;
 coherence proof
     I ';' j = I ';' Macro j by SCMFSA6A:def 6;
  hence thesis;
 end;
end;


registration
 let i be parahalting Instruction of SCM+FSA,
     j be parahalting Instruction of SCM+FSA;
 cluster i ';' j -> parahalting;
 coherence proof
     i ';' j = Macro i ';' Macro j by SCMFSA6A:def 7;
  hence thesis;
 end;
end;


registration
 let i be keeping_0 Instruction of SCM+FSA,
     J be keeping_0 Macro-Instruction;
 cluster i ';' J -> keeping_0;
 coherence proof
     i ';' J = Macro i ';' J by SCMFSA6A:def 5;
  hence thesis;
 end;
end;


registration
 let I be keeping_0 Macro-Instruction,
     j be keeping_0 Instruction of SCM+FSA;
 cluster I ';' j -> keeping_0;
 coherence proof
     I ';' j = I ';' Macro j by SCMFSA6A:def 6;
  hence thesis;
 end;
end;


registration
 let i, j be keeping_0 Instruction of SCM+FSA;
 cluster i ';' j -> keeping_0;
 coherence proof
     i ';' j = Macro i ';' Macro j by SCMFSA6A:def 7;
  hence thesis;
 end;
end;


begin :: Consequenses of the main theorem

definition
 let s be State of SCM+FSA;
 func Initialize s -> State of SCM+FSA equals
:: SCMFSA6C:def 3
 s +* ((intloc 0) .--> 1) +* Start-At(insloc 0);
end;


theorem :: SCMFSA6C:3
  IC Initialize s = insloc 0 & (Initialize s).intloc 0 = 1 &
  (for a being read-write Int-Location holds (Initialize s).a = s.a) &
  (for f holds (Initialize s).f = s.f) &
  for l holds (Initialize s).l = s.l;

theorem :: SCMFSA6C:4
 s1, s2 equal_outside the Instruction-Locations of SCM+FSA
iff
   (s1 | (Int-Locations \/ FinSeq-Locations \/ {IC SCM+FSA}))
 = (s2 | (Int-Locations \/ FinSeq-Locations \/ {IC SCM+FSA}));

theorem :: SCMFSA6C:5
    s1 | (Int-Locations \/ FinSeq-Locations)
  = s2 | (Int-Locations \/ FinSeq-Locations)
implies
    Exec (i, s1) | (Int-Locations \/ FinSeq-Locations)
  = Exec (i, s2) | (Int-Locations \/ FinSeq-Locations);

theorem :: SCMFSA6C:6
 for i being parahalting Instruction of SCM+FSA
  holds Exec(i, Initialize s) = IExec(Macro i, s);

theorem :: SCMFSA6C:7
 for I being keeping_0 parahalting Macro-Instruction,
     j being parahalting Instruction of SCM+FSA
  holds IExec(I ';' j, s).a = Exec(j, IExec(I, s)).a;

theorem :: SCMFSA6C:8
 for I being keeping_0 parahalting Macro-Instruction,
     j being parahalting Instruction of SCM+FSA
  holds IExec(I ';' j, s).f = Exec(j, IExec(I, s)).f;

theorem :: SCMFSA6C:9
 for i being keeping_0 parahalting Instruction of SCM+FSA,
     j being parahalting Instruction of SCM+FSA
  holds IExec(i ';' j, s).a = Exec(j, Exec(i, Initialize s)).a;

theorem :: SCMFSA6C:10
   for i being keeping_0 parahalting Instruction of SCM+FSA,
     j being parahalting Instruction of SCM+FSA
  holds IExec(i ';' j, s).f = Exec(j, Exec(i, Initialize s)).f;

begin :: An example

definition
 let a, b be Int-Location;
 func swap (a, b) -> Macro-Instruction equals
:: SCMFSA6C:def 4
 FirstNotUsed Macro (a := b) := a ';' (a := b) ';'
                 (b := FirstNotUsed Macro (a := b));
end;


registration
 let a, b be Int-Location;
 cluster swap(a,b) -> parahalting;
 coherence proof
     swap(a, b) = FirstNotUsed Macro (a := b) := a ';' (a := b) ';'
                 (b := FirstNotUsed Macro (a := b)) by Def4;
  hence thesis;
 end;
end;


registration
 let a, b be read-write Int-Location;
 cluster swap(a,b) -> keeping_0;
 coherence proof
     swap(a, b) = FirstNotUsed Macro (a := b) := a ';' (a := b) ';'
                 (b := FirstNotUsed Macro (a := b)) by Def4;
  hence thesis;
 end;
end;


theorem :: SCMFSA6C:11 :: SwapC:
   for a, b being read-write Int-Location
  holds IExec (swap(a, b), s).a = s.b & IExec (swap(a, b), s).b = s.a;

theorem :: SCMFSA6C:12 :: SwapNCF:
     UsedInt*Loc swap(a, b) = {};
