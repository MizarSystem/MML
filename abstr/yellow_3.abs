:: Cartesian Products of Relations and Relational Structures
::  by Artur Korni{\l}owicz
::
:: Received September 25, 1996
:: Copyright (c) 1996 Association of Mizar Users

environ

 vocabulary RELAT_1, FUNCT_5, ORDERS_1, WAYBEL_0, MCART_1, LATTICE3, RELAT_2,
      LATTICES, YELLOW_0, BHSP_3, ORDINAL2, PRE_TOPC, FUNCT_1, TARSKI,
      QUANTAL1, AMI_1, YELLOW_3;
 notation TARSKI, XBOOLE_0, ZFMISC_1, SUBSET_1, RELAT_1, RELAT_2, RELSET_1,
      FUNCT_1, MCART_1, DOMAIN_1, FUNCT_2, PRE_TOPC, FUNCT_5, STRUCT_0,
      ORDERS_1, LATTICE3, YELLOW_0, WAYBEL_0;
 constructors LATTICE3, DOMAIN_1, ORDERS_3, YELLOW_2, PRE_TOPC;
 clusters LATTICE3, STRUCT_0, ORDERS_3, RELSET_1, WAYBEL_0, YELLOW_0, SUBSET_1,
      XBOOLE_0;
 requirements SUBSET, BOOLE;


begin :: Preliminaries

scheme :: YELLOW_3:sch 1
 FraenkelA2 {A() -> non empty set,
                   F(set, set) -> set,
                   P[set, set], Q[set, set] } :
 { F(s,t) where s is Element of A(), t is Element of A() : P[s,t] }
  is Subset of A()
provided
 for s being Element of A(), t being Element of A() holds F(s,t) in A()
proof
      { F(s,t) where s is Element of A(), t is Element of A() : P[s,t] } c= A()
    proof
      let q be set;
      assume q in { F(s,t) where s is Element of A(), t is Element of A() :
        P[s,t] };
      then consider s, t being Element of A() such that
A2:     q = F(s,t) & P[s,t];
      thus q in A() by A1,A2;
    end;
    hence thesis;
  end;

scheme :: YELLOW_3:sch 2
 ExtensionalityR { A, B() -> Relation,
                         P[set,set] }:
 A() = B()
provided
 for a, b being set holds [a,b] in A() iff P[a,b] and
 for a, b being set holds [a,b] in B() iff P[a,b]
proof
    thus A() c= B()
    proof
      let q be set; assume
A3:     q in A();
      then consider y, z being set such that
A4:     q = [y,z] by RELAT_1:def 1;
        P[y,z] by A1,A3,A4;
      hence q in B() by A2,A4;
    end;
    let q be set; assume
A5:   q in B();
    then consider y, z being set such that
A6:   q = [y,z] by RELAT_1:def 1;
      P[y,z] by A2,A5,A6;
    hence q in A() by A1,A6;
  end;

registration let X be empty set;
 cluster proj1 X -> empty;
coherence by FUNCT_5:10;
 cluster proj2 X -> empty;
coherence by FUNCT_5:10;
end;


registration let X, Y be non empty set,
               D be non empty Subset of [:X,Y:];
 cluster proj1 D -> non empty;
coherence
  proof
    consider a being Element of D;
    consider x,y being set such that
A1:   x in X & y in Y & a = [x,y] by ZFMISC_1:def 2;
    assume proj1 D is empty;
    hence contradiction by A1,FUNCT_5:18;
  end;
 cluster proj2 D -> non empty;
coherence
  proof
    consider a being Element of D;
    consider x,y being set such that
A2:   x in X & y in Y & a = [x,y] by ZFMISC_1:def 2;
    assume proj2 D is empty;
    hence contradiction by A2,FUNCT_5:18;
  end;
end;


registration let L be RelStr,
               X be empty Subset of L;
 cluster downarrow X -> empty;
coherence
  proof
    assume downarrow X is non empty;
    then consider x being set such that
A1:   x in downarrow X by XBOOLE_0:def 1;
    reconsider x as Element of L by A1;
      ex z being Element of L st x <= z & z in X by A1,WAYBEL_0:def 15;
    hence contradiction;
  end;

 cluster uparrow X -> empty;
coherence
  proof
    assume uparrow X is non empty;
    then consider x being set such that
A2:   x in uparrow X by XBOOLE_0:def 1;
    reconsider x as Element of L by A2;
      ex z being Element of L st z <= x & z in X by A2,WAYBEL_0:def 16;
    hence contradiction;
  end;
end;


theorem :: YELLOW_3:1
for X, Y being set, D being Subset of [:X,Y:] holds D c= [:proj1 D, proj2 D:];

theorem :: YELLOW_3:2
  for L being with_infima transitive antisymmetric RelStr
 for a, b, c, d being Element of L st a <= c & b <= d holds a "/\" b <= c "/\"
 d;

theorem :: YELLOW_3:3
  for L being with_suprema transitive antisymmetric RelStr
 for a, b, c, d being Element of L st a <= c & b <= d holds a "\/" b <= c "\/"
 d;

theorem :: YELLOW_3:4
  for L being complete reflexive antisymmetric (non empty RelStr)
 for D being Subset of L, x being Element of L st x in D
  holds (sup D) "/\" x = x;

theorem :: YELLOW_3:5
  for L being complete reflexive antisymmetric (non empty RelStr)
 for D being Subset of L, x being Element of L st x in D
  holds (inf D) "\/" x = x;

theorem :: YELLOW_3:6
  for L being RelStr, X, Y being Subset of L st X c= Y holds
 downarrow X c= downarrow Y;

theorem :: YELLOW_3:7
  for L being RelStr, X, Y being Subset of L st X c= Y holds
 uparrow X c= uparrow Y;

theorem :: YELLOW_3:8
  for S, T being with_infima Poset, f being map of S, T
 for x, y being Element of S holds
  f preserves_inf_of {x,y} iff f.(x "/\" y) = f.x "/\" f.y;

theorem :: YELLOW_3:9
  for S, T being with_suprema Poset, f being map of S, T
 for x, y being Element of S holds
  f preserves_sup_of {x,y} iff f.(x "\/" y) = f.x "\/" f.y;

scheme :: YELLOW_3:sch 3
 Inf_Union { L() -> complete antisymmetric (non empty RelStr),
                   P[set] } :
 "/\" ({ "/\"(X,L()) where X is Subset of L(): P[X] },L())
  >= "/\" (union {X where X is Subset of L(): P[X]},L())
proof
      "/\"(union {X where X is Subset of L(): P[X]},L())
     is_<=_than { "/\"(X,L()) where X is Subset of L(): P[X] }
    proof
      let a be Element of L();
      assume a in { "/\"(X,L()) where X is Subset of L(): P[X] };
      then consider q being Subset of L() such that
A1:     a = "/\"(q,L()) & P[q];
A2:    ex_inf_of q,L() &
        ex_inf_of union {X where X is Subset of L(): P[X]},L() by YELLOW_0:17;
        q in {X where X is Subset of L(): P[X]} by A1;
      then q c= union {X where X is Subset of L(): P[X]} by ZFMISC_1:92;
      hence a >= "/\"(union {X where X is Subset of L(): P[X]},L())
        by A1,A2,YELLOW_0:35;
    end;
    hence thesis by YELLOW_0:33;
  end;

scheme :: YELLOW_3:sch 4
 Inf_of_Infs { L() -> complete LATTICE,
                     P[set] } :
 "/\" ({ "/\"(X,L()) where X is Subset of L(): P[X] },L())
  = "/\" (union {X where X is Subset of L(): P[X]},L())
proof   defpred p[set] means P[$1];
A1: "/\" ({ "/\"(X,L()) where X is Subset of L(): p[X] },L())
      >= "/\"(union {X where X is Subset of L(): p[X]},L())
       from Inf_Union;

      union {X where X is Subset of L(): P[X]}
     is_>=_than "/\" ({ "/\"(X,L()) where X is Subset of L(): P[X] },L())
    proof
      let a be Element of L();
      assume a in union {X where X is Subset of L(): P[X]};
      then consider b being set such that
A2:     a in b & b in {X where X is Subset of L(): P[X]} by TARSKI:def 4;
      consider c being Subset of L() such that
A3:     b = c & P[c] by A2;
A4:   "/\"(c,L()) <= a by A2,A3,YELLOW_2:24;
        "/\"(c,L()) in { "/\"
(X,L()) where X is Subset of L(): P[X] } by A3;
      then "/\"(c,L()) >= "/\" ({ "/\"(X,L()) where X is Subset of L(): P[X] }
,L())
        by YELLOW_2:24;
      hence a >= "/\" ({ "/\"(X,L()) where X is Subset of L(): P[X] },L())
        by A4,YELLOW_0:def 2;
    end;
    then "/\"(union {X where X is Subset of L(): P[X]},L())
      >= "/\" ({ "/\"(X,L()) where X is Subset of L(): P[X] },L())
       by YELLOW_0:33;
    hence thesis by A1,ORDERS_1:25;
  end;

scheme :: YELLOW_3:sch 5
 Sup_Union { L() -> complete antisymmetric (non empty RelStr),
                   P[set] } :
 "\/" ({ "\/"(X,L()) where X is Subset of L(): P[X] },L())
  <= "\/" (union {X where X is Subset of L(): P[X]},L())
proof
A1: ex_sup_of { "\/"
(X,L()) where X is Subset of L(): P[X] },L() by YELLOW_0:17;
      "\/"(union {X where X is Subset of L(): P[X]},L())
     is_>=_than { "\/"(X,L()) where X is Subset of L(): P[X] }
    proof
      let a be Element of L();
      assume a in { "\/"(X,L()) where X is Subset of L(): P[X] };
      then consider q being Subset of L() such that
A2:     a = "\/"(q,L()) & P[q];
A3:    ex_sup_of q,L() &
        ex_sup_of union {X where X is Subset of L(): P[X]},L() by YELLOW_0:17;
        q in {X where X is Subset of L(): P[X]} by A2;
      then q c= union {X where X is Subset of L(): P[X]} by ZFMISC_1:92;
      hence a <= "\/"(union {X where X is Subset of L(): P[X]},L())
        by A2,A3,YELLOW_0:34;
    end;
    hence thesis by A1,YELLOW_0:def 9;
  end;

scheme :: YELLOW_3:sch 6
 Sup_of_Sups { L() -> complete LATTICE,
                     P[set] } :
 "\/" ({ "\/"(X,L()) where X is Subset of L(): P[X] },L())
  = "\/" (union {X where X is Subset of L(): P[X]},L())
proof   defpred p[set] means P[$1];
A1: "\/" ({ "\/"(X,L()) where X is Subset of L(): p[X] },L())
      <= "\/"(union {X where X is Subset of L(): p[X]},L())
       from Sup_Union;

A2: ex_sup_of union {X where X is Subset of L(): P[X]},L() by YELLOW_0:17;
      union {X where X is Subset of L(): P[X]}
     is_<=_than "\/" ({ "\/"(X,L()) where X is Subset of L(): P[X] },L())
    proof
      let a be Element of L();
      assume a in union {X where X is Subset of L(): P[X]};
      then consider b being set such that
A3:     a in b & b in {X where X is Subset of L(): P[X]} by TARSKI:def 4;
      consider c being Subset of L() such that
A4:     b = c & P[c] by A3;
A5:   a <= "\/"(c,L()) by A3,A4,YELLOW_2:24;
        "\/"(c,L()) in { "\/"
(X,L()) where X is Subset of L(): P[X] } by A4;
      then "\/"(c,L()) <= "\/" ({ "\/"(X,L()) where X is Subset of L(): P[X] }
,L())
        by YELLOW_2:24;
      hence a <= "\/" ({ "\/"(X,L()) where X is Subset of L(): P[X] },L())
        by A5,YELLOW_0:def 2;
    end;
    then "\/"(union {X where X is Subset of L(): P[X]},L())
      <= "\/" ({ "\/"(X,L()) where X is Subset of L(): P[X] },L())
       by A2,YELLOW_0:def 9;
    hence thesis by A1,ORDERS_1:25;
  end;

begin :: Properties of Cartesian Products of Relational Structures

definition let P, R be Relation;
 func ["P,R"] -> Relation means
:: YELLOW_3:def 1
  for x, y being set holds [x,y] in it iff
   ex p,q,s,t being set st x = [p,q] & y = [s,t] & [p,s] in P & [q,t] in R;
end;


theorem :: YELLOW_3:10
for P, R being Relation, x being set holds
 x in ["P,R"] iff
  [x`1`1,x`2`1] in P & [x`1`2,x`2`2] in R &
   (ex a, b being set st x = [a,b]) & (ex c, d being set st x`1 = [c,d]) &
    ex e, f being set st x`2 = [e,f];

definition let A, B, X, Y be set;
           let P be Relation of A, B;
           let R be Relation of X, Y;
 redefine func ["P,R"] -> Relation of [:A,X:],[:B,Y:];
end;


definition let X, Y be RelStr;
 func [:X,Y:] -> strict RelStr means
:: YELLOW_3:def 2
  the carrier of it = [:the carrier of X, the carrier of Y:] &
  the InternalRel of it = ["the InternalRel of X, the InternalRel of Y"];
end;


definition let L1, L2 be RelStr,
               D be Subset of [:L1,L2:];
 redefine func proj1 D -> Subset of L1;
 redefine func proj2 D -> Subset of L2;
end;


definition let S1, S2 be RelStr,
               D1 be Subset of S1,
               D2 be Subset of S2;
 redefine func [:D1,D2:] -> Subset of [:S1,S2:];
end;


definition let S1, S2 be non empty RelStr,
               x be Element of S1,
               y be Element of S2;
 redefine func [x,y] -> Element of [:S1,S2:];
end;


definition let L1, L2 be non empty RelStr,
               x be Element of [:L1,L2:];
 redefine func x`1 -> Element of L1;
 redefine func x`2 -> Element of L2;
end;


theorem :: YELLOW_3:11
for S1, S2 being non empty RelStr
 for a, c being Element of S1, b, d being Element of S2 holds
  a <= c & b <= d iff [a,b] <= [c,d];

theorem :: YELLOW_3:12
for S1, S2 being non empty RelStr, x, y being Element of [:S1,S2:] holds
 x <= y iff x`1 <= y`1 & x`2 <= y`2;

theorem :: YELLOW_3:13
  for A, B being RelStr, C being non empty RelStr
 for f, g being map of [:A,B:],C
  st for x being Element of A, y being Element of B holds f.[x,y] = g.[x,y]
   holds f = g;

registration let X, Y be non empty RelStr;
 cluster [:X,Y:] -> non empty;
coherence
  proof
    consider x being Element of X;
    consider y being Element of Y;
      [x,y] in [:the carrier of X,the carrier of Y:] by ZFMISC_1:106;
    then the carrier of [:X,Y:] is non empty by Def2;
    hence [:X,Y:] is non empty by STRUCT_0:def 1;
  end;
end;


registration let X, Y be reflexive RelStr;
 cluster [:X,Y:] -> reflexive;
coherence
  proof
    let x be set;
    assume x in the carrier of [:X,Y:];
    then x in [:the carrier of X,the carrier of Y:] by Def2;
    then consider x1, x2 being set such that
A1:   x1 in the carrier of X & x2 in the carrier of Y & x = [x1,x2]
        by ZFMISC_1:def 2;
    set a = [[x1,x2],[x1,x2]];
      the InternalRel of X is_reflexive_in the carrier of X &
      the InternalRel of Y is_reflexive_in the carrier of Y by ORDERS_1:def 4;
    then A2: [x1,x1] in the InternalRel of X & [x2,x2] in the InternalRel of Y
      by A1,RELAT_2:def 1;
A3: a`1 = [x1,x2] & a`2 = [x1,x2] by MCART_1:7;
      a`1`1 = x1 & a`1`2 = x2 & a`2`1 = x1 & a`2`2 = x2 by Lm1;
    then [x,x] in ["the InternalRel of X,the InternalRel of Y"] by A1,A2,A3,
Th10;
    hence [x,x] in the InternalRel of [:X,Y:] by Def2;
  end;
end;


registration let X, Y be antisymmetric RelStr;
 cluster [:X,Y:] -> antisymmetric;
coherence
  proof
    let x, y be set such that
A1:   x in the carrier of [:X,Y:] and
A2:   y in the carrier of [:X,Y:] and
A3:   [x,y] in the InternalRel of [:X,Y:] & [y,x] in
 the InternalRel of [:X,Y:];
      x in [:the carrier of X,the carrier of Y:] by A1,Def2;
    then consider x1, x2 being set such that
A4:   x1 in the carrier of X & x2 in the carrier of Y & x = [x1,x2]
        by ZFMISC_1:def 2;
      y in [:the carrier of X,the carrier of Y:] by A2,Def2;
    then consider y1, y2 being set such that
A5:   y1 in the carrier of X & y2 in the carrier of Y & y = [y1,y2]
        by ZFMISC_1:def 2;
      [x,y] in ["the InternalRel of X,the InternalRel of Y"] by A3,Def2;
    then [[x,y]`1`1,[x,y]`2`1] in the InternalRel of X
      & [[x,y]`1`2,[x,y]`2`2] in the InternalRel of Y by Th10;
    then [x`1,[x,y]`2`1] in the InternalRel of X
      & [x`2,[x,y]`2`2] in the InternalRel of Y by MCART_1:7;
    then [x`1,y`1] in the InternalRel of X
      & [x`2,y`2] in the InternalRel of Y by MCART_1:7;
    then [x1,[y1,y2]`1] in the InternalRel of X
      & [x2,[y1,y2]`2] in the InternalRel of Y by A4,A5,MCART_1:7;
then A6: [x1,y1] in the InternalRel of X & [x2,y2] in the InternalRel of Y
      by MCART_1:7;
      [y,x] in ["the InternalRel of X,the InternalRel of Y"] by A3,Def2;
    then [[y,x]`1`1,[y,x]`2`1] in the InternalRel of X
      & [[y,x]`1`2,[y,x]`2`2] in the InternalRel of Y by Th10;
    then [y`1,[y,x]`2`1] in the InternalRel of X
      & [y`2,[y,x]`2`2] in the InternalRel of Y by MCART_1:7;
    then [y`1,x`1] in the InternalRel of X
      & [y`2,x`2] in the InternalRel of Y by MCART_1:7;
    then [y1,[x1,x2]`1] in the InternalRel of X
      & [y2,[x1,x2]`2] in the InternalRel of Y by A4,A5,MCART_1:7;
then A7: [y1,x1] in the InternalRel of X & [y2,x2] in the InternalRel of Y
      by MCART_1:7;
      the InternalRel of X is_antisymmetric_in the carrier of X &
     the InternalRel of Y is_antisymmetric_in the carrier of Y
      by ORDERS_1:def 6;
    then x1 = y1 & x2 = y2 by A4,A5,A6,A7,RELAT_2:def 4;
    hence x = y by A4,A5;
  end;
end;


registration let X, Y be transitive RelStr;
 cluster [:X,Y:] -> transitive;
coherence
  proof
    let x, y, z be set such that
A1:   x in the carrier of [:X,Y:] and
A2:   y in the carrier of [:X,Y:] and
A3:   z in the carrier of [:X,Y:] and
A4:   [x,y] in the InternalRel of [:X,Y:] and
A5:   [y,z] in the InternalRel of [:X,Y:];
      x in [:the carrier of X,the carrier of Y:] by A1,Def2;
    then consider x1, x2 being set such that
A6:   x1 in the carrier of X & x2 in the carrier of Y & x = [x1,x2]
        by ZFMISC_1:def 2;
      y in [:the carrier of X,the carrier of Y:] by A2,Def2;
    then consider y1, y2 being set such that
A7:   y1 in the carrier of X & y2 in the carrier of Y & y = [y1,y2]
        by ZFMISC_1:def 2;
      z in [:the carrier of X,the carrier of Y:] by A3,Def2;
    then consider z1, z2 being set such that
A8:   z1 in the carrier of X & z2 in the carrier of Y & z = [z1,z2]
        by ZFMISC_1:def 2;
    set P = the InternalRel of X,
        R = the InternalRel of Y;
A9: P is_transitive_in the carrier of X &
     R is_transitive_in the carrier of Y by ORDERS_1:def 5;
      [x,y] in ["P,R"] by A4,Def2;
    then [[x,y]`1`1,[x,y]`2`1] in P & [[x,y]`1`2,[x,y]`2`2] in R by Th10;
    then [x`1,[x,y]`2`1] in P & [x`2,[x,y]`2`2] in R by MCART_1:7;
    then [x`1,y`1] in P & [x`2,y`2] in R by MCART_1:7;
    then [x1,y`1] in P & [x2,y`2] in R by A6,MCART_1:7;
then A10: [x1,y1] in P & [x2,y2] in R by A7,MCART_1:7;
      [y,z] in ["P,R"] by A5,Def2;
    then [[y,z]`1`1,[y,z]`2`1] in P & [[y,z]`1`2,[y,z]`2`2] in R by Th10;
    then [y`1,[y,z]`2`1] in P & [y`2,[y,z]`2`2] in R by MCART_1:7;
    then [y`1,z`1] in P & [y`2,z`2] in R by MCART_1:7;
    then [y1,z`1] in P & [y2,z`2] in R by A7,MCART_1:7;
    then [y1,z1] in P & [y2,z2] in R by A8,MCART_1:7;
    then [x1,z1] in P & [x2,z2] in R by A6,A7,A8,A9,A10,RELAT_2:def 8;
    then [x1,z`1] in P & [x2,z`2] in R by A8,MCART_1:7;
then A11: [x`1,z`1] in P & [x`2,z`2] in R by A6,MCART_1:7;
      [x,z]`1 = x & [x,z]`2 = z by MCART_1:7;
    then [x,z] in ["P,R"] by A6,A8,A11,Th10;
    hence [x,z] in the InternalRel of [:X,Y:] by Def2;
  end;
end;


registration let X, Y be with_suprema RelStr;
 cluster [:X,Y:] -> with_suprema;
coherence
  proof
    set IT = [:X,Y:];
    let x, y be Element of IT;
    consider zx being Element of X such that
A1:   x`1 <= zx & y`1 <= zx and
A2:   for z' being Element of X st x`1 <= z' & y`1 <= z' holds zx <= z'
        by LATTICE3:def 10;
    consider zy being Element of Y such that
A3:   x`2 <= zy & y`2 <= zy and
A4:   for z' being Element of Y st x`2 <= z' & y`2 <= z' holds zy <= z'
        by LATTICE3:def 10;
A5: the carrier of [:X,Y:] = [:the carrier of X, the carrier of Y:]
      by Def2;
    then consider a, b being set such that
A6:  a in the carrier of X & b in the carrier of Y & x = [a,b]
      by ZFMISC_1:def 2;
    consider c, d being set such that
A7:  c in the carrier of X & d in the carrier of Y & y = [c,d]
      by A5,ZFMISC_1:def 2;
    take z = [zx,zy];
      [x`1,x`2] <= [zx,zy] & [y`1,y`2] <= [zx,zy] by A1,A3,Th11;
    hence x <= z & y <= z by A6,A7,MCART_1:8;
    let z' be Element of IT;
    consider a, b being set such that
A8:  a in the carrier of X & b in the carrier of Y & z' = [a,b]
      by A5,ZFMISC_1:def 2;
    assume x <= z' & y <= z';
    then x`1 <= z'`1 & x`2 <= z'`2 & y`1 <= z'`1 & y`2 <= z'`2 by Th12;
    then zx <= z'`1 & zy <= z'`2 by A2,A4;
    then [zx,zy] <= [z'`1,z'`2] by Th11;
    hence z <= z' by A8,MCART_1:8;
  end;
end;


registration let X, Y be with_infima RelStr;
 cluster [:X,Y:] -> with_infima;
coherence
  proof
    set IT = [:X,Y:];
    let x, y be Element of IT;
    consider zx being Element of X such that
A1:   x`1 >= zx & y`1 >= zx and
A2:   for z' being Element of X st x`1 >= z' & y`1 >= z' holds zx >= z'
        by LATTICE3:def 11;
    consider zy being Element of Y such that
A3:   x`2 >= zy & y`2 >= zy and
A4:   for z' being Element of Y st x`2 >= z' & y`2 >= z' holds zy >= z'
        by LATTICE3:def 11;
A5: the carrier of [:X,Y:] = [:the carrier of X, the carrier of Y:]
      by Def2;
    then consider a, b being set such that
A6:  a in the carrier of X & b in the carrier of Y & x = [a,b]
      by ZFMISC_1:def 2;
    consider c, d being set such that
A7:  c in the carrier of X & d in the carrier of Y & y = [c,d]
      by A5,ZFMISC_1:def 2;
    take z = [zx,zy];
      [x`1,x`2] >= [zx,zy] & [y`1,y`2] >= [zx,zy] by A1,A3,Th11;
    hence x >= z & y >= z by A6,A7,MCART_1:8;
    let z' be Element of IT;
    consider a, b being set such that
A8:  a in the carrier of X & b in the carrier of Y & z' = [a,b]
      by A5,ZFMISC_1:def 2;
    assume x >= z' & y >= z';
    then x`1 >= z'`1 & x`2 >= z'`2 & y`1 >= z'`1 & y`2 >= z'`2 by Th12;
    then zx >= z'`1 & zy >= z'`2 by A2,A4;
    then [zx,zy] >= [z'`1,z'`2] by Th11;
    hence z >= z' by A8,MCART_1:8;
  end;
end;


theorem :: YELLOW_3:14
  for X, Y being RelStr st [:X,Y:] is non empty
 holds X is non empty & Y is non empty;

theorem :: YELLOW_3:15
  for X, Y being non empty RelStr st [:X,Y:] is reflexive
 holds X is reflexive & Y is reflexive;

theorem :: YELLOW_3:16
  for X, Y being non empty reflexive RelStr st [:X,Y:] is antisymmetric
 holds X is antisymmetric & Y is antisymmetric;

theorem :: YELLOW_3:17
  for X, Y being non empty reflexive RelStr st [:X,Y:] is transitive
 holds X is transitive & Y is transitive;

theorem :: YELLOW_3:18
  for X, Y being non empty reflexive RelStr st [:X,Y:] is with_suprema
 holds X is with_suprema & Y is with_suprema;

theorem :: YELLOW_3:19
  for X, Y being non empty reflexive RelStr st [:X,Y:] is with_infima
 holds X is with_infima & Y is with_infima;

definition let S1, S2 be RelStr,
               D1 be directed Subset of S1,
               D2 be directed Subset of S2;
 redefine func [:D1,D2:] -> directed Subset of [:S1,S2:];
end;


theorem :: YELLOW_3:20
  for S1, S2 being non empty RelStr
 for D1 being non empty Subset of S1, D2 being non empty Subset of S2
  st [:D1,D2:] is directed holds D1 is directed & D2 is directed;

theorem :: YELLOW_3:21
for S1, S2 being non empty RelStr
 for D being non empty Subset of [:S1,S2:]
  holds proj1 D is non empty & proj2 D is non empty;

theorem :: YELLOW_3:22
  for S1, S2 being non empty reflexive RelStr
 for D being non empty directed Subset of [:S1,S2:]
  holds proj1 D is directed & proj2 D is directed;

definition let S1, S2 be RelStr,
               D1 be filtered Subset of S1,
               D2 be filtered Subset of S2;
 redefine func [:D1,D2:] -> filtered Subset of [:S1,S2:];
end;


theorem :: YELLOW_3:23
  for S1, S2 being non empty RelStr
 for D1 being non empty Subset of S1, D2 being non empty Subset of S2
  st [:D1,D2:] is filtered holds D1 is filtered & D2 is filtered;

theorem :: YELLOW_3:24
  for S1, S2 being non empty reflexive RelStr
 for D being non empty filtered Subset of [:S1,S2:]
  holds proj1 D is filtered & proj2 D is filtered;

definition let S1, S2 be RelStr,
               D1 be upper Subset of S1,
               D2 be upper Subset of S2;
 redefine func [:D1,D2:] -> upper Subset of [:S1,S2:];
end;


theorem :: YELLOW_3:25
  for S1, S2 being non empty reflexive RelStr
 for D1 being non empty Subset of S1, D2 being non empty Subset of S2
  st [:D1,D2:] is upper holds D1 is upper & D2 is upper;

theorem :: YELLOW_3:26
  for S1, S2 being non empty reflexive RelStr
 for D being non empty upper Subset of [:S1,S2:]
  holds proj1 D is upper & proj2 D is upper;

definition let S1, S2 be RelStr,
               D1 be lower Subset of S1,
               D2 be lower Subset of S2;
 redefine func [:D1,D2:] -> lower Subset of [:S1,S2:];
end;


theorem :: YELLOW_3:27
  for S1, S2 being non empty reflexive RelStr
 for D1 being non empty Subset of S1, D2 being non empty Subset of S2
  st [:D1,D2:] is lower holds D1 is lower & D2 is lower;

theorem :: YELLOW_3:28
  for S1, S2 being non empty reflexive RelStr
 for D being non empty lower Subset of [:S1,S2:]
  holds proj1 D is lower & proj2 D is lower;

definition let R be RelStr;
 attr R is void means
:: YELLOW_3:def 3
  the InternalRel of R is empty;
end;


registration
 cluster empty -> void RelStr;
coherence
  proof
    let R be RelStr;
    assume R is empty;
    then reconsider R1 = R as empty RelStr;
      the InternalRel of R1 is empty;
    hence the InternalRel of R is empty;
  end;
end;


registration
 cluster non void non empty strict Poset;
existence
  proof
    consider R being non empty strict Poset;
    consider x being set such that
A1:   x in the carrier of R by XBOOLE_0:def 1;
    take R;
      the InternalRel of R is_reflexive_in the carrier of R by ORDERS_1:def 4;
    hence the InternalRel of R is non empty by A1,RELAT_2:def 1;
    thus R is non empty strict;
  end;
end;


registration
 cluster non void -> non empty RelStr;
coherence
  proof
    let R be RelStr;
    assume R is non void;
    then the InternalRel of R is non empty by Def3;
    then consider a being set such that
A1:   a in the InternalRel of R by XBOOLE_0:def 1;
    consider x,y being set such that
A2:   a = [x,y] & x in the carrier of R & y in the carrier of R
        by A1,RELSET_1:6;
    thus R is non empty by A2,STRUCT_0:def 1;
  end;
end;


registration
 cluster non empty reflexive -> non void RelStr;
coherence
  proof
    let R be RelStr; assume
     R is non empty reflexive;
    then reconsider R1 = R as non empty reflexive RelStr;
    consider x being set such that
A1:   x in the carrier of R1 by XBOOLE_0:def 1;
      the InternalRel of R1 is_reflexive_in the carrier of R1 by ORDERS_1:def 4
;
    hence the InternalRel of R is non empty by A1,RELAT_2:def 1;
  end;
end;


registration let R be non void RelStr;
 cluster the InternalRel of R -> non empty;
coherence by Def3;
end;


theorem :: YELLOW_3:29
for S1, S2 being non empty RelStr
 for D1 being non empty Subset of S1, D2 being non empty Subset of S2
  for x being Element of S1, y being Element of S2 st
 [x,y] is_>=_than [:D1,D2:] holds x is_>=_than D1 & y is_>=_than D2;

theorem :: YELLOW_3:30
for S1, S2 being non empty RelStr
 for D1 being Subset of S1, D2 being Subset of S2
  for x being Element of S1, y being Element of S2 st
 x is_>=_than D1 & y is_>=_than D2 holds [x,y] is_>=_than [:D1,D2:];

theorem :: YELLOW_3:31
for S1, S2 being non empty RelStr
 for D being Subset of [:S1,S2:]
  for x being Element of S1, y being Element of S2 holds
 [x,y] is_>=_than D iff x is_>=_than proj1 D & y is_>=_than proj2 D;

theorem :: YELLOW_3:32
for S1, S2 being non empty RelStr
 for D1 being non empty Subset of S1, D2 being non empty Subset of S2
  for x being Element of S1, y being Element of S2 st
 [x,y] is_<=_than [:D1,D2:] holds x is_<=_than D1 & y is_<=_than D2;

theorem :: YELLOW_3:33
for S1, S2 being non empty RelStr
 for D1 being Subset of S1, D2 being Subset of S2
  for x being Element of S1, y being Element of S2 st
 x is_<=_than D1 & y is_<=_than D2 holds [x,y] is_<=_than [:D1,D2:];

theorem :: YELLOW_3:34
for S1, S2 being non empty RelStr
 for D being Subset of [:S1,S2:]
  for x being Element of S1, y being Element of S2 holds
 [x,y] is_<=_than D iff x is_<=_than proj1 D & y is_<=_than proj2 D;

theorem :: YELLOW_3:35
for S1, S2 being antisymmetric non empty RelStr
 for D1 being Subset of S1, D2 being Subset of S2
  for x being Element of S1, y being Element of S2 st
   ex_sup_of D1,S1 & ex_sup_of D2,S2 &
  for b being Element of [:S1,S2:] st b is_>=_than [:D1,D2:] holds [x,y] <= b
 holds
  (for c being Element of S1 st c is_>=_than D1 holds x <= c) &
   for d being Element of S2 st d is_>=_than D2 holds y <= d;

theorem :: YELLOW_3:36
for S1, S2 being antisymmetric non empty RelStr
 for D1 being Subset of S1, D2 being Subset of S2
  for x being Element of S1, y being Element of S2 st
   ex_inf_of D1,S1 & ex_inf_of D2,S2 &
  for b being Element of [:S1,S2:] st b is_<=_than [:D1,D2:] holds [x,y] >= b
 holds
  (for c being Element of S1 st c is_<=_than D1 holds x >= c) &
   for d being Element of S2 st d is_<=_than D2 holds y >= d;

theorem :: YELLOW_3:37
  for S1, S2 being antisymmetric non empty RelStr
 for D1 being non empty Subset of S1, D2 being non empty Subset of S2
  for x being Element of S1, y being Element of S2 st
   (for c being Element of S1 st c is_>=_than D1 holds x <= c) &
    for d being Element of S2 st d is_>=_than D2 holds y <= d holds
  for b being Element of [:S1,S2:] st b is_>=_than [:D1,D2:] holds [x,y] <= b;

theorem :: YELLOW_3:38
  for S1, S2 being antisymmetric non empty RelStr
 for D1 being non empty Subset of S1, D2 being non empty Subset of S2
  for x being Element of S1, y being Element of S2 st
   (for c being Element of S1 st c is_>=_than D1 holds x >= c) &
    for d being Element of S2 st d is_>=_than D2 holds y >= d holds
  for b being Element of [:S1,S2:] st b is_>=_than [:D1,D2:] holds [x,y] >= b;

theorem :: YELLOW_3:39
for S1, S2 being antisymmetric non empty RelStr
 for D1 being non empty Subset of S1, D2 being non empty Subset of S2
  holds ex_sup_of D1,S1 & ex_sup_of D2,S2 iff ex_sup_of [:D1,D2:],[:S1,S2:];

theorem :: YELLOW_3:40
for S1, S2 being antisymmetric non empty RelStr
 for D1 being non empty Subset of S1, D2 being non empty Subset of S2
  holds ex_inf_of D1,S1 & ex_inf_of D2,S2 iff ex_inf_of [:D1,D2:],[:S1,S2:];

theorem :: YELLOW_3:41
for S1, S2 being antisymmetric non empty RelStr
 for D being Subset of [:S1,S2:] holds
  ex_sup_of proj1 D,S1 & ex_sup_of proj2 D,S2 iff ex_sup_of D,[:S1,S2:];

theorem :: YELLOW_3:42
for S1, S2 being antisymmetric non empty RelStr
 for D being Subset of [:S1,S2:] holds
  ex_inf_of proj1 D,S1 & ex_inf_of proj2 D,S2 iff ex_inf_of D,[:S1,S2:];

theorem :: YELLOW_3:43
for S1, S2 being antisymmetric non empty RelStr
 for D1 being non empty Subset of S1, D2 being non empty Subset of S2
  st ex_sup_of D1,S1 & ex_sup_of D2,S2 holds sup [:D1,D2:] = [sup D1,sup D2];

theorem :: YELLOW_3:44
for S1, S2 being antisymmetric non empty RelStr
 for D1 being non empty Subset of S1, D2 being non empty Subset of S2
  st ex_inf_of D1,S1 & ex_inf_of D2,S2 holds inf [:D1,D2:] = [inf D1,inf D2];

registration let X, Y be complete antisymmetric (non empty RelStr);
 cluster [:X,Y:] -> complete;
coherence
  proof
    set IT = [:X,Y:];
      for D being Subset of IT holds ex_sup_of D, IT
    proof
      let D be Subset of IT;
        ex_sup_of proj1 D,X & ex_sup_of proj2 D,Y by YELLOW_0:17;
      hence thesis by Th41;
    end;
    hence IT is complete by YELLOW_0:53;
  end;
end;


theorem :: YELLOW_3:45
  for X, Y being non empty lower-bounded antisymmetric RelStr
 st [:X,Y:] is complete holds X is complete & Y is complete;

theorem :: YELLOW_3:46
  for L1,L2 being antisymmetric non empty RelStr
 for D being non empty Subset of [:L1,L2:]
  st [:L1,L2:] is complete or ex_sup_of D,[:L1,L2:]
  holds sup D = [sup proj1 D,sup proj2 D];

theorem :: YELLOW_3:47
  for L1,L2 being antisymmetric non empty RelStr
 for D being non empty Subset of [:L1,L2:]
  st [:L1,L2:] is complete or ex_inf_of D,[:L1,L2:]
  holds inf D = [inf proj1 D,inf proj2 D];

theorem :: YELLOW_3:48
  for S1,S2 being non empty reflexive RelStr
 for D being non empty directed Subset of [:S1,S2:]
  holds [:proj1 D,proj2 D:] c= downarrow D;

theorem :: YELLOW_3:49
  for S1,S2 being non empty reflexive RelStr
 for D being non empty filtered Subset of [:S1,S2:]
  holds [:proj1 D,proj2 D:] c= uparrow D;

scheme :: YELLOW_3:sch 7
 Kappa2DS { X,Y,Z() -> non empty RelStr,
                   F(set,set) -> set }:
 ex f being map of [:X(),Y():], Z()
  st for x being Element of X(), y being Element of Y() holds f.[x,y]=F(x,y)
provided
 for x being Element of X(), y being Element of Y() holds
  F(x,y) is Element of Z()
proof   deffunc f(set,set) = F($1,$2);
A2:  for x being Element of X(),
         y being Element of Y()
       holds f(x,y) in the carrier of Z()
    proof
      let x be Element of X(),
          y be Element of Y();
      reconsider x1 = x as Element of X();
      reconsider y1 = y as Element of Y();
        F(x1,y1) is Element of Z() by A1;
      hence F(x,y) in the carrier of Z();
    end;
    consider f being Function of [:the carrier of X(),the carrier of Y():],
     the carrier of Z() such that
A3:   for x being Element of X(),
          y being Element of Y() holds f.[x,y]=f(x,y)
       from FUNCT_7:sch 1(A2);
      the carrier of [:X(),Y():] = [:the carrier of X(), the carrier of Y():]
      by Def2;
    then reconsider f as map of [:X(),Y():], Z();
    take f;
    thus thesis by A3;
  end;
