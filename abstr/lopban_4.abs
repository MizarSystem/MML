:: The Exponential Function on {B}anach Algebra
::  by Yasunari Shidama
::
:: Received February 13, 2004
:: Copyright (c) 2004 Association of Mizar Users

environ

 vocabularies PRE_TOPC, NORMSP_1, RLVECT_1, FUNCT_1, ARYTM, ARYTM_1, ARYTM_3,
      RELAT_1, ABSVALUE, ORDINAL2, QC_LANG1, LATTICES, SEQ_1, PROB_1, SEQ_2,
      SEQM_3, SIN_COS, CAT_1, PREPOWER, SERIES_1, SQUARE_1, GROUP_1, RSSPACE3,
      LOPBAN_2, LOPBAN_3, SUPINF_2, LOPBAN_4;
 notations SUBSET_1, RELAT_1, FUNCT_1, FUNCT_2, PRE_TOPC, STRUCT_0, XCMPLX_0,
      XREAL_0, ORDINAL1, NUMBERS, REAL_1, NAT_1, RLVECT_1, GROUP_1, COMPLEX1,
      SQUARE_1, NORMSP_1, RSSPACE3, SEQ_1, SEQ_2, SEQM_3, SERIES_1, PREPOWER,
      BINARITH, SIN_COS, LOPBAN_2, LOPBAN_3;
 constructors ARYTM_0, REAL_1, SQUARE_1, BINARITH, SEQ_2, COMPLEX1, SERIES_1,
      SEQ_4, PREPOWER, COMSEQ_3, RVSUM_1, FINSEQ_4, SIN_COS, RSSPACE3,
      LOPBAN_3, NAT_1;
 registrations RELSET_1, STRUCT_0, ORDINAL2, XREAL_0, MEMBERED, SEQ_1,
      LOPBAN_2, LOPBAN_3, SIN_COS;
 requirements SUBSET, REAL, BOOLE, NUMERALS, ARITHM;


begin :: Basic Properties of Exponential Functiion on Banach_Algebra

 reserve X for Banach_Algebra,
         p,p1,q,th,th1,th2,th3,r for Real,
         w,z,z1,z2 for Element of X,
         k,l,m,n,n1,n2 for Nat,
         seq,seq1,seq2,cq1,s,s' for sequence of X,
         rseq,rseq1,rseq2 for Real_Sequence;

definition
  let X be non empty Normed_AlgebraStr;
  let x,y be Element of X;
  pred x,y are_commutative means
:: LOPBAN_4:def 1
  x * y = y * x;
  symmetry;
end;

theorem :: LOPBAN_4:1
  seq1 is convergent & seq2 is convergent & lim(seq1-seq2)=0.X
 implies lim seq1 = lim seq2;

theorem :: LOPBAN_4:2
   for z st for n being Nat holds s.n = z holds lim s = z;

theorem :: LOPBAN_4:3
   s is convergent & s' is convergent
   implies s * s' is convergent;

theorem :: LOPBAN_4:4
   s is convergent
   implies z * s is convergent;

theorem :: LOPBAN_4:5
   s is convergent
   implies s*z  is convergent;

theorem :: LOPBAN_4:6
   s is convergent
   implies lim (z * s) =z* lim(s);

theorem :: LOPBAN_4:7
   s is convergent
   implies lim (s*z) = lim(s)*z;

theorem :: LOPBAN_4:8
   s is convergent & s' is convergent
                            implies lim(s*s')=(lim s)*(lim s');

theorem :: LOPBAN_4:9
Partial_Sums(z * seq) = z * Partial_Sums(seq)
&
Partial_Sums(seq *z ) =  Partial_Sums(seq) *z;

theorem :: LOPBAN_4:10
  ||.Partial_Sums(seq).k.|| <= Partial_Sums(||.seq.||).k;

theorem :: LOPBAN_4:11
  (for n st n <= m holds seq1.n = seq2.n) implies
 Partial_Sums(seq1).m =Partial_Sums(seq2).m;

theorem :: LOPBAN_4:12
  ((for n holds ||. seq.n .|| <= rseq.n)
 & rseq is convergent & lim(rseq)=0)
  implies seq is convergent & lim(seq)=0.X;

definition let X;
           let z be Element of X;
 func z ExpSeq -> sequence of X means
:: LOPBAN_4:def 2
   for n holds it.n = 1/(n! )*(z #N n);
end;

scheme :: LOPBAN_4:sch 1
 ExNormSpace_CASE {RNS()->non empty Banach_Algebra,
   F(Nat,Nat)-> Point of RNS() }: for k holds
 ex seq be sequence of RNS()
   st for n holds ((n <= k implies seq.n=F(k,n)) &
                                   (n > k implies seq.n=0.RNS()));

theorem :: LOPBAN_4:13
(for k st 0 < k holds ((k-'1)! ) * k = k!) &
 for m,k st k <= m holds ((m-'k)! ) * (m+1-k) = (m+1-'k)!;

definition
let n be Nat;
func Coef(n) -> Real_Sequence means
:: LOPBAN_4:def 3
  for k be Nat holds
     (k <= n implies it.k = n!  /( (k!  ) * (( n -' k)!) ) )
    &(k > n implies it.k=0);
end;

definition let n be Nat;
func Coef_e(n) -> Real_Sequence means
:: LOPBAN_4:def 4
  for k be Nat holds
     (k <= n implies it.k = 1/((k! ) * ((n -' k)!  )))
    & (k > n implies it.k=0);
end;

definition let X,seq;
func Sift seq -> sequence of X means
:: LOPBAN_4:def 5
  it.0 = 0.X & for k be Nat holds it.(k+1) = seq.k;
end;

definition let n;
           let X;
           let z,w be Element of X;
func Expan(n,z,w) -> sequence of X means
:: LOPBAN_4:def 6
  for k be Nat holds
   ( k <= n implies
       it.k=((Coef(n)).k) * (z #N k) * (w #N (n-' k)) ) &
   (n < k implies it.k=0.X);
end;

definition let n;
           let X;
           let z,w be Element of X;
func Expan_e(n,z,w) -> sequence of X means
:: LOPBAN_4:def 7
  for k be Nat holds
   ( k <= n implies
       it.k=((Coef_e(n)).k) * (z #N k) * (w #N (n-' k)) ) &
   (n < k implies it.k=0.X );
end;

definition let n;
           let X;
           let z,w be Element of X;
func Alfa(n,z,w) -> sequence of X means
:: LOPBAN_4:def 8
   for k be Nat holds
   ( k <= n implies
       it.k= (z ExpSeq).k * Partial_Sums(w ExpSeq).(n-'k) ) &
   ( n < k implies it.k=0.X);
end;

definition let X;
           let z, w be Element of X;
           let n be Nat;
func Conj(n,z,w) -> sequence of X means
:: LOPBAN_4:def 9
  for k be Nat holds
  ( k <= n implies
     it.k= (z ExpSeq).k * (Partial_Sums(w ExpSeq).n
                          -Partial_Sums(w ExpSeq).(n-'k)))
   & (n < k implies it.k=0.X);
end;

theorem :: LOPBAN_4:14
 z ExpSeq.(n+1) = (1/(n+1) * z) * (z ExpSeq.n)  &
 z ExpSeq.0=1.X  &
||.(z ExpSeq).n.|| <= (||.z.|| ExpSeq ).n;

theorem :: LOPBAN_4:15
0 < k implies (Sift(seq)).k=seq.(k -' 1);

theorem :: LOPBAN_4:16
Partial_Sums(seq).k=Partial_Sums(Sift(seq)).k+seq.k;

theorem :: LOPBAN_4:17
for z,w st z,w are_commutative holds
(z+w) #N n = Partial_Sums(Expan(n,z,w)).n;

theorem :: LOPBAN_4:18
  Expan_e(n,z,w)=(1/(n!)) * Expan(n,z,w);

theorem :: LOPBAN_4:19
for z,w st z,w are_commutative holds
1/ (n! ) *((z+w) #N n)  = Partial_Sums(Expan_e(n,z,w)).n;

theorem :: LOPBAN_4:20
0.X  ExpSeq is norm_summable & Sum(0.X  ExpSeq)=1.X;

registration
   let X;
   let z be Element of X;
  cluster z ExpSeq -> norm_summable;
end;

theorem :: LOPBAN_4:21
(z ExpSeq).0 = 1.X  & Expan(0,z,w).0 = 1.X;

theorem :: LOPBAN_4:22
l <= k implies (Alfa(k+1,z,w)).l = (Alfa(k,z,w)).l + Expan_e(k+1,z,w).l;

theorem :: LOPBAN_4:23
Partial_Sums((Alfa(k+1,z,w))).k
   = (Partial_Sums(( Alfa(k,z,w)))).k
     + (Partial_Sums(( Expan_e(k+1,z,w) ))).k;

theorem :: LOPBAN_4:24
(z ExpSeq).k=(Expan_e(k,z,w)).k;

theorem :: LOPBAN_4:25
for z,w st z,w are_commutative holds
Partial_Sums((z+w) ExpSeq).n = Partial_Sums(Alfa(n,z,w)).n;

theorem :: LOPBAN_4:26
for z,w st z,w are_commutative holds
Partial_Sums(z ExpSeq).k * Partial_Sums(w ExpSeq).k
  -Partial_Sums((z+w) ExpSeq).k
       = Partial_Sums(Conj(k,z,w)).k;

theorem :: LOPBAN_4:27
0 <= (||. z .|| ExpSeq).n;

theorem :: LOPBAN_4:28
||. Partial_Sums((z ExpSeq)).k .|| <= Partial_Sums(||.z.|| ExpSeq).k &
 Partial_Sums((||.z.|| ExpSeq)).k <= Sum(||.z.|| ExpSeq) &
  ||. Partial_Sums(( z ExpSeq)).k .|| <= Sum(||.z.|| ExpSeq);

theorem :: LOPBAN_4:29
1 <= Sum(||.z.|| ExpSeq);

theorem :: LOPBAN_4:30
 abs((Partial_Sums(||.z.||  ExpSeq)).n) = Partial_Sums(||.z.||  ExpSeq).n
&
 (n <= m implies
 abs((Partial_Sums(||.z.||  ExpSeq).m-Partial_Sums(||.z.||  ExpSeq).n))
  = Partial_Sums(||.z.||  ExpSeq).m-Partial_Sums(||.z.||  ExpSeq).n);

theorem :: LOPBAN_4:31
abs(Partial_Sums(||.Conj(k,z,w).||).n)=Partial_Sums(||.Conj(k,z,w).||).n;

theorem :: LOPBAN_4:32
for p being real number st p>0 ex n st for k st n <= k
 holds abs(Partial_Sums(||.Conj(k,z,w).||).k) < p;

theorem :: LOPBAN_4:33
for seq st for k holds seq.k=Partial_Sums((Conj(k,z,w))).k
  holds seq is convergent & lim(seq)=0.X;

definition
let X be Banach_Algebra;
func exp_ X -> Function of the carrier of X, the carrier of X means
:: LOPBAN_4:def 10
  for z being Element of the carrier of X holds it.z=Sum(z ExpSeq);
 end;

definition let X,z;
  func exp z -> Element of X equals
:: LOPBAN_4:def 11
  (exp_ X).z;
end;

theorem :: LOPBAN_4:34
for z holds exp(z)=Sum(z ExpSeq);

theorem :: LOPBAN_4:35
 for z1,z2 st z1,z2 are_commutative holds
     exp(z1+z2)=exp(z1) *exp(z2)
   &exp(z2+z1)=exp(z2) *exp(z1)
   &exp(z1+z2)=exp(z2+z1)
   &exp(z1),exp(z2) are_commutative;

theorem :: LOPBAN_4:36
  for z1,z2 st z1,z2 are_commutative holds
    z1* exp(z2)=exp(z2)*z1;

theorem :: LOPBAN_4:37
exp(0.X) = 1.X;

theorem :: LOPBAN_4:38
exp(z)*exp(-z)= 1.X & exp(-z)*exp(z)= 1.X;

theorem :: LOPBAN_4:39
  exp(z) is invertible & (exp(z))" = exp(-z)
 &
 exp(-z) is invertible & (exp(-z))" = exp(z);

theorem :: LOPBAN_4:40
for z for s,t be Real holds s*z,t*z are_commutative;

theorem :: LOPBAN_4:41
 for z for s,t be Real holds
 exp(s*z)*exp(t*z) = exp((s+t)*z) &
 exp(t*z)*exp(s*z) = exp((t+s)*z) &
 exp((s+t)*z) = exp((t+s)*z) &
 exp(s*z),exp(t*z) are_commutative;
