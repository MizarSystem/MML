:: Hahn Banach Theorem in the Vector Space over the Field of
:: Complex Numbers
::  by Anna Justyna Milewska
::
:: Received May 23, 2000
:: Copyright (c) 2000 Association of Mizar Users

environ

 vocabulary RLVECT_1, VECTSP_1, ARYTM_1, COMPLEX1, ABSVALUE, ARYTM_3, SQUARE_1,
      COMPLFLD, HAHNBAN, FUNCT_1, SUBSET_1, FUNCOP_1, GRCAT_1, UNIALG_1,
      BINOP_1, LATTICES, ALGSTR_2, RLSUB_1, RELAT_1, BOOLE, HAHNBAN1, XCMPLX_0;
 notation TARSKI, XBOOLE_0, ZFMISC_1, SUBSET_1, NUMBERS, ARYTM_0, XREAL_0,
      STRUCT_0, REAL_1, ABSVALUE, SQUARE_1, PRE_TOPC, RLVECT_1, VECTSP_1,
      RLSUB_1, VECTSP_4, FUNCT_1, FUNCT_2, BINOP_1, RELSET_1, NATTRA_1,
      BORSUK_1, COMPLEX1, HAHNBAN, COMPLFLD;
 constructors REAL_1, SQUARE_1, RLSUB_1, VECTSP_4, NATTRA_1, BORSUK_1, HAHNBAN,
      COMPLFLD, DOMAIN_1, COMPLSP1, MONOID_0, COMPLEX1, MEMBERED, ARYTM_0,
      ARYTM_3, FUNCT_4;
 clusters STRUCT_0, VECTSP_1, RELSET_1, FUNCT_1, SUBSET_1, COMPLFLD, RLVECT_1,
      HAHNBAN, MEMBERED;
 requirements NUMERALS, SUBSET, BOOLE, ARITHM;


begin

  theorem :: HAHNBAN1:1
   for z be Element of COMPLEX holds
    abs |.z.| = |.z.|;

  theorem :: HAHNBAN1:2
   for x1,y1,x2,y2 be Real holds
    [*x1,y1*] * [*x2,y2*] = [*x1*x2 - y1*y2,x1*y2+x2*y1*];

  theorem :: HAHNBAN1:3
   for r be Real holds [*r,0*]*<i> = [*0,r*];

  theorem :: HAHNBAN1:4
   for r be Real holds |.[*r,0*].| = abs r;

  theorem :: HAHNBAN1:5
   for z be Element of COMPLEX st |.z.| <> 0 holds
    [*|.z.|,0*] = (z*'/[*|.z.|,0*])*z;

begin :: Some Facts on the Field of Complex Numbers

  definition
   let x,y be Real;
   func [**x,y**] -> Element of F_Complex equals
:: HAHNBAN1:def 1
    [*x,y*];
  end;


  definition
   func i_FC -> Element of F_Complex equals
:: HAHNBAN1:def 2
    <i>;
  end;


  theorem :: HAHNBAN1:6
     i_FC = [*0,1*] & i_FC = [**0,1**];

  theorem :: HAHNBAN1:7
     |.i_FC.| = 1;

  theorem :: HAHNBAN1:8
   i_FC * i_FC = -1_ F_Complex;

  theorem :: HAHNBAN1:9
   (-1_ F_Complex) * (-1_ F_Complex) = 1_ F_Complex;

  theorem :: HAHNBAN1:10
   for x1,y1,x2,y2 be Real holds
    [**x1,y1**] + [**x2,y2**] = [**x1 + x2,y1 + y2**];

  theorem :: HAHNBAN1:11
   for x1,y1,x2,y2 be Real holds
    [**x1,y1**] * [**x2,y2**] = [**x1*x2 - y1*y2,x1*y2+x2*y1**];

  theorem :: HAHNBAN1:12
     for z be Element of F_Complex holds
    abs(|.z.|) = |.z.|;

  theorem :: HAHNBAN1:13
   for r be Real holds |.[**r,0**].| = abs r;

  theorem :: HAHNBAN1:14
   for r be Real holds [**r,0**]*i_FC = [**0,r**];

  definition
   let z be Element of F_Complex;
   func Re z -> Real means
:: HAHNBAN1:def 3
    ex z' be Element of COMPLEX st z = z' & it = Re z';
  end;


  definition
   let z be Element of F_Complex;
   func Im z -> Real means
:: HAHNBAN1:def 4
    ex z' be Element of COMPLEX st z = z' & it = Im z';
  end;


  theorem :: HAHNBAN1:15
   for x,y be Real holds
    Re [**x,y**] = x & Im [**x,y**] = y;

  theorem :: HAHNBAN1:16
   for x,y be Element of F_Complex holds
    Re (x+y) = Re x + Re y &
    Im (x+y) = Im x + Im y;

  theorem :: HAHNBAN1:17
   for x,y be Element of F_Complex holds
    Re (x*y) = Re x * Re y - Im x * Im y &
    Im (x*y) = Re x * Im y + Re y * Im x;

  theorem :: HAHNBAN1:18
   for z be Element of F_Complex holds
    Re z <= |.z.|;

  theorem :: HAHNBAN1:19
     for z be Element of F_Complex holds
    Im z <= |.z.|;

begin :: Functionals of Vector Space

  definition
   let K be 1-sorted;
   let V be VectSpStr over K;
   mode Functional of V is Function of the carrier of V, the carrier of K;
   canceled;
  end;


  definition
   let K be non empty LoopStr;
   let V be non empty VectSpStr over K;
   let f,g be Functional of V;
   func f+g -> Functional of V means
:: HAHNBAN1:def 6
    for x be Element of V holds it.x = f.x + g.x;
  end;


  definition
   let K be non empty LoopStr;
   let V be non empty VectSpStr over K;
   let f be Functional of V;
   func -f -> Functional of V means
:: HAHNBAN1:def 7
    for x be Element of V holds it.x = -(f.x);
  end;


  definition
   let K be non empty LoopStr;
   let V be non empty VectSpStr over K;
   let f,g be Functional of V;
   func f-g -> Functional of V equals
:: HAHNBAN1:def 8
    f+-g;
  end;


  definition
   let K be non empty HGrStr;
   let V be non empty VectSpStr over K;
   let v be Element of K;
   let f be Functional of V;
   func v*f -> Functional of V means
:: HAHNBAN1:def 9
    for x be Element of V holds it.x = v*(f.x);
  end;


  definition
   let K be non empty ZeroStr;
   let V be VectSpStr over K;
   func 0Functional(V) -> Functional of V equals
:: HAHNBAN1:def 10
    [#]V --> 0.K;
  end;


  definition
   let K be non empty LoopStr;
   let V be non empty VectSpStr over K;
   let F be Functional of V;
   attr F is additive means
:: HAHNBAN1:def 11
    for x,y be Vector of V holds F.(x+y) = F.x+F.y;
  end;


  definition
   let K be non empty HGrStr;
   let V be non empty VectSpStr over K;
   let F be Functional of V;
   attr F is homogeneous means
:: HAHNBAN1:def 12
    for x be Vector of V, r be Scalar of V holds F.(r*x) = r*F.x;
  end;


  definition
   let K be non empty ZeroStr;
   let V be non empty VectSpStr over K;
   let F be Functional of V;
   attr F is 0-preserving means
:: HAHNBAN1:def 13
      F.(0.V) = 0.K;
  end;


  registration
   let K be add-associative right_zeroed right_complementable Abelian
    associative left_unital distributive (non empty doubleLoopStr);
   let V be VectSp of K;
   cluster homogeneous -> 0-preserving Functional of V;
   coherence
   proof
    let F be Functional of V;
    assume A1: F is homogeneous;
    thus F.(0.V) = F.(0.K * 0.V) by VECTSP_1:59
                .= 0.K * F.(0.V) by A1,Def12
                .= 0.K by VECTSP_1:39;
   end;
  end;


  registration
   let K be right_zeroed (non empty LoopStr);
   let V be non empty VectSpStr over K;
   cluster 0Functional(V) -> additive;
   coherence
   proof
    let x,y be Vector of V;
    A1: [#]V = the carrier of V by PRE_TOPC:12;
    A2: (0Functional(V)).x = ([#]V --> 0.K).x by Def10
                          .= 0.K by A1,FUNCOP_1:13;
    A3: (0Functional(V)).y = ([#]V --> 0.K).y by Def10
                          .= 0.K by A1,FUNCOP_1:13;
    thus (0Functional(V)).(x+y) = ([#]V --> 0.K).(x+y) by Def10
                               .= 0.K by A1,FUNCOP_1:13
                               .= (0Functional(V)).x + (0Functional(V)).y
                                                     by A2,A3,RLVECT_1:def 7;
   end;
  end;


  registration
   let K be add-associative right_zeroed right_complementable
                 right-distributive (non empty doubleLoopStr);
   let V be non empty VectSpStr over K;
   cluster 0Functional(V) -> homogeneous;
   coherence
   proof
    let x be Vector of V;
    let r be Scalar of V;
    A1: [#]V = the carrier of V by PRE_TOPC:12;
    A2: (0Functional(V)).x = ([#]V --> 0.K).x by Def10
                          .= 0.K by A1,FUNCOP_1:13;
    thus (0Functional(V)).(r*x) = ([#]V --> 0.K).(r*x) by Def10
                               .= 0.K by A1,FUNCOP_1:13
                               .= r*(0Functional(V)).x by A2,VECTSP_1:36;
   end;
  end;


  registration
   let K be non empty ZeroStr;
   let V be non empty VectSpStr over K;
   cluster 0Functional(V) -> 0-preserving;
   coherence
   proof
    A1: [#]V = the carrier of V by PRE_TOPC:12;
    thus (0Functional(V)).(0.V) = ([#]V --> 0.K).(0.V) by Def10
                               .= 0.K by A1,FUNCOP_1:13;
   end;
  end;


  registration
   let K be add-associative right_zeroed right_complementable
                 right-distributive (non empty doubleLoopStr);
   let V be non empty VectSpStr over K;
   cluster additive homogeneous 0-preserving Functional of V;
   existence
   proof
    take 0Functional(V);
    thus thesis;
   end;
  end;


  theorem :: HAHNBAN1:20
   for K be Abelian (non empty LoopStr)
   for V be non empty VectSpStr over K
   for f,g be Functional of V holds
    f+g = g+f;

  theorem :: HAHNBAN1:21
   for K be add-associative (non empty LoopStr)
   for V be non empty VectSpStr over K
   for f,g,h be Functional of V holds
    f+g+h = f+(g+h);

  theorem :: HAHNBAN1:22
   for K be non empty ZeroStr
   for V be non empty VectSpStr over K
   for x be Element of V holds
    (0Functional(V)).x = 0.K;

  theorem :: HAHNBAN1:23
   for K be right_zeroed (non empty LoopStr)
   for V be non empty VectSpStr over K
   for f be Functional of V holds
    f + 0Functional(V) = f;

  theorem :: HAHNBAN1:24
   for K be add-associative right_zeroed right_complementable
            (non empty LoopStr)
   for V be non empty VectSpStr over K
   for f be Functional of V holds
    f-f = 0Functional(V);

  theorem :: HAHNBAN1:25
   for K be right-distributive (non empty doubleLoopStr)
   for V be non empty VectSpStr over K
   for r be Element of K
   for f,g be Functional of V holds
    r*(f+g) = r*f+r*g;

  theorem :: HAHNBAN1:26
   for K be left-distributive (non empty doubleLoopStr)
   for V be non empty VectSpStr over K
   for r,s be Element of K
   for f be Functional of V holds
    (r+s)*f = r*f+s*f;

  theorem :: HAHNBAN1:27
   for K be associative (non empty HGrStr)
   for V be non empty VectSpStr over K
   for r,s be Element of K
   for f be Functional of V holds
    (r*s)*f = r*(s*f);

  theorem :: HAHNBAN1:28
   for K be left_unital (non empty doubleLoopStr)
   for V be non empty VectSpStr over K
   for f be Functional of V holds
    (1_ K)*f = f;

  registration
   let K be Abelian add-associative right_zeroed right_complementable
                 right-distributive (non empty doubleLoopStr);
   let V be non empty VectSpStr over K;
   let f,g be additive Functional of V;
   cluster f+g -> additive;
   coherence
   proof
    let x,y be Vector of V;
    thus (f+g).(x+y) = f.(x+y)+g.(x+y) by Def6
       .= f.x+f.y+g.(x+y) by Def11
       .= f.x+f.y+(g.x+g.y) by Def11
       .= f.x+(f.y+(g.x+g.y)) by RLVECT_1:def 6
       .= f.x+(g.x+(f.y+g.y)) by RLVECT_1:def 6
       .= f.x+g.x+(f.y+g.y) by RLVECT_1:def 6
       .= (f+g).x+(f.y+g.y) by Def6
       .= (f+g).x+(f+g).y by Def6;
   end;
  end;


  registration
   let K be Abelian add-associative right_zeroed right_complementable
                 right-distributive (non empty doubleLoopStr);
   let V be non empty VectSpStr over K;
   let f be additive Functional of V;
   cluster -f -> additive;
   coherence
   proof
    let x,y be Vector of V;
    thus (-f).(x+y) = -f.(x+y) by Def7
       .= -(f.x + f.y) by Def11
       .= -f.x+-f.y by RLVECT_1:45
       .= (-f).x+-f.y by Def7
       .= (-f).x+(-f).y by Def7;
   end;
  end;


  registration
   let K be add-associative right_zeroed right_complementable
                 right-distributive (non empty doubleLoopStr);
   let V be non empty VectSpStr over K;
   let v be Element of K;
   let f be additive Functional of V;
   cluster v*f -> additive;
   coherence
   proof
    let x,y be Vector of V;
    thus (v*f).(x+y) = v*f.(x+y) by Def9
       .= v*(f.x + f.y) by Def11
       .= v*f.x+v*f.y by VECTSP_1:def 11
       .= (v*f).x+v*f.y by Def9
       .= (v*f).x+(v*f).y by Def9;
   end;
  end;


  registration
   let K be add-associative right_zeroed right_complementable
                 right-distributive (non empty doubleLoopStr);
   let V be non empty VectSpStr over K;
   let f,g be homogeneous Functional of V;
   cluster f+g -> homogeneous;
   coherence
   proof
    let x be Vector of V;
    let r be Scalar of V;
    thus (f+g).(r*x) = f.(r*x) + g.(r*x) by Def6
       .= r*f.x + g.(r*x) by Def12
       .= r*f.x + r*g.x by Def12
       .= r*(f.x + g.x) by VECTSP_1:def 11
       .= r*(f+g).x by Def6;
   end;
  end;


  registration
   let K be Abelian add-associative right_zeroed right_complementable
                 right-distributive (non empty doubleLoopStr);
   let V be non empty VectSpStr over K;
   let f be homogeneous Functional of V;
   cluster -f -> homogeneous;
   coherence
   proof
    let x be Vector of V;
    let r be Scalar of V;
    thus (-f).(r*x) = -f.(r*x) by Def7
       .= -r*f.x by Def12
       .= r*-f.x by Lm1
       .= r*(-f).x by Def7;
   end;
  end;


  registration
   let K be add-associative right_zeroed right_complementable
        right-distributive associative commutative (non empty doubleLoopStr);
   let V be non empty VectSpStr over K;
   let v be Element of K;
   let f be homogeneous Functional of V;
   cluster v*f -> homogeneous;
   coherence
   proof
    let x be Vector of V;
    let r be Scalar of V;
    thus (v*f).(r*x) = v*f.(r*x) by Def9
       .= v*(r*f.x) by Def12
       .= r*(v*f.x) by VECTSP_1:def 16
       .= r*(v*f).x by Def9;
   end;
  end;


  definition
   let K be add-associative right_zeroed right_complementable
            right-distributive (non empty doubleLoopStr);
   let V be non empty VectSpStr over K;
   mode linear-Functional of V is additive homogeneous Functional of V;
  end;


begin :: The Vector Space of linear Functionals

  definition
   let K be Abelian add-associative right_zeroed right_complementable
        right-distributive associative commutative (non empty doubleLoopStr);
   let V be non empty VectSpStr over K;
   func V*' -> non empty strict VectSpStr over K means
:: HAHNBAN1:def 14
    (for x be set holds x in the carrier of it iff
                       x is linear-Functional of V) &
    (for f,g be linear-Functional of V holds (the add of it).(f,g) = f+g) &
    (the Zero of it = 0Functional(V)) &
    for f be linear-Functional of V for x be Element of K holds
     (the lmult of it).(x,f) = x*f;
  end;


  registration
   let K be Abelian add-associative right_zeroed right_complementable
        right-distributive associative commutative (non empty doubleLoopStr);
   let V be non empty VectSpStr over K;
   cluster V*' -> Abelian;
   coherence
   proof
    let v,w be Element of V*';
    reconsider f=v,g=w as linear-Functional of V by Def14;
    thus v+w = (the add of V*').[v,w] by RLVECT_1:def 3
       .= (the add of V*').(v,w) by BINOP_1:def 1
       .= f+g by Def14
       .= g+f by Th20
       .= (the add of V*').(w,v) by Def14
       .= (the add of V*').[w,v] by BINOP_1:def 1
       .= w+v by RLVECT_1:def 3;
   end;
  end;


  registration
   let K be Abelian add-associative right_zeroed right_complementable
        right-distributive associative commutative (non empty doubleLoopStr);
   let V be non empty VectSpStr over K;
   cluster V*' -> add-associative;
   coherence
   proof
    let u,v,w be Element of V*';
    reconsider f=u,g=v,h=w as linear-Functional of V by Def14;
    thus u+v+w = (the add of V*').[u+v,w] by RLVECT_1:def 3
       .= (the add of V*').(u+v,w) by BINOP_1:def 1
       .= (the add of V*').((the add of V*').[u,v],w) by RLVECT_1:def 3
       .= (the add of V*').((the add of V*').(u,v),w) by BINOP_1:def 1
       .= (the add of V*').(f+g,w) by Def14
       .= f+g+h by Def14
       .= f+(g+h) by Th21
       .= (the add of V*').(u,g+h) by Def14
       .= (the add of V*').(u,(the add of V*').(v,w)) by Def14
       .= (the add of V*').(u,(the add of V*').[v,w]) by BINOP_1:def 1
       .= (the add of V*').(u,v+w) by RLVECT_1:def 3
       .= (the add of V*').[u,v+w] by BINOP_1:def 1
       .= u+(v+w) by RLVECT_1:def 3;
   end;

   cluster V*' -> right_zeroed;
   coherence
   proof
    let x be Element of V*';
    reconsider f=x as linear-Functional of V by Def14;
    thus x + 0.(V*') = (the add of V*').[x,0.(V*')] by RLVECT_1:def 3
       .= (the add of V*').(x,0.(V*')) by BINOP_1:def 1
       .= (the add of V*').(x,the Zero of V*') by RLVECT_1:def 2
       .= (the add of V*').(x,0Functional(V)) by Def14
       .= f+0Functional(V) by Def14
       .= x by Th23;
   end;

   cluster V*' -> right_complementable;
   coherence
   proof
    let x be Element of V*';
    reconsider f=x as linear-Functional of V by Def14;
    reconsider b = -f as Element of V*' by Def14;
    take b;
    thus x+b = (the add of V*').[x,b] by RLVECT_1:def 3
       .= (the add of V*').(x,-f) by BINOP_1:def 1
       .= f+-f by Def14
       .= f-f by Def8
       .= 0Functional(V) by Th24
       .= the Zero of V*' by Def14
       .= 0.(V*') by RLVECT_1:def 2;
   end;
  end;


  registration
   let K be Abelian add-associative right_zeroed right_complementable
   left_unital distributive associative commutative (non empty doubleLoopStr);
   let V be non empty VectSpStr over K;
   cluster V*' -> VectSp-like;
   coherence
   proof
    let x,y be Element of K;
    let v,w be Element of V*';
    reconsider f=v,g=w as linear-Functional of V by Def14;
    thus x*(v+w) = (the lmult of V*').(x,v+w) by VECTSP_1:def 24
       .= (the lmult of V*').(x,(the add of V*').[v,w]) by RLVECT_1:def 3
       .= (the lmult of V*').(x,(the add of V*').(v,w)) by BINOP_1:def 1
       .= (the lmult of V*').(x,f+g) by Def14
       .= x*(f+g) by Def14
       .= x*f+x*g by Th25
       .= (the add of V*').(x*f,x*g) by Def14
       .= (the add of V*').((the lmult of V*').(x,f),x*g) by Def14
       .= (the add of V*').((the lmult of V*').(x,f),(the lmult of V*').(x,g))
                                                                       by Def14
       .= (the add of V*').(x*v,(the lmult of V*').(x,g)) by VECTSP_1:def 24
       .= (the add of V*').(x*v,x*w) by VECTSP_1:def 24
       .= (the add of V*').[x*v,x*w] by BINOP_1:def 1
       .= x*v+x*w by RLVECT_1:def 3;
    thus (x+y)*v = (the lmult of V*').(x+y,v) by VECTSP_1:def 24
       .= (x+y)*f by Def14
       .= x*f+y*f by Th26
       .= (the add of V*').(x*f,y*f) by Def14
       .= (the add of V*').((the lmult of V*').(x,f),y*f) by Def14
       .= (the add of V*').((the lmult of V*').(x,f),(the lmult of V*').(y,f))
                                                                       by Def14
       .= (the add of V*').(x*v,(the lmult of V*').(y,f)) by VECTSP_1:def 24
       .= (the add of V*').(x*v,y*v) by VECTSP_1:def 24
       .= (the add of V*').[x*v,y*v] by BINOP_1:def 1
       .= x*v+y*v by RLVECT_1:def 3;
    thus (x*y)*v = (the lmult of V*').(x*y,v) by VECTSP_1:def 24
       .= (x*y)*f by Def14
       .= x*(y*f) by Th27
       .= (the lmult of V*').(x,y*f) by Def14
       .= (the lmult of V*').(x,(the lmult of V*').(y,f)) by Def14
       .= (the lmult of V*').(x,y*v) by VECTSP_1:def 24
       .= x*(y*v) by VECTSP_1:def 24;
    thus (1_ K)*v = (the lmult of V*').(1_ K,v) by VECTSP_1:def 24
       .= (1_ K)*f by Def14
       .= v by Th28;
   end;
  end;


begin :: Semi Norm of Vector Space

  definition
   let K be 1-sorted;
   let V be VectSpStr over K;
   mode RFunctional of V is Function of the carrier of V,REAL;
   canceled;
  end;


  definition
   let K be 1-sorted;
   let V be non empty VectSpStr over K;
   let F be RFunctional of V;
   attr F is subadditive means
:: HAHNBAN1:def 16
    for x,y be Vector of V holds F.(x+y) <= F.x+F.y;
  end;


  definition
   let K be 1-sorted;
   let V be non empty VectSpStr over K;
   let F be RFunctional of V;
   attr F is additive means
:: HAHNBAN1:def 17
    for x,y be Vector of V holds F.(x+y) = F.x+F.y;
  end;


  definition
   let V be non empty VectSpStr over F_Complex;
   let F be RFunctional of V;
   attr F is Real_homogeneous means
:: HAHNBAN1:def 18
    for v be Vector of V
    for r be Real holds
     F.([**r,0**]*v) = r*F.v;
  end;


  theorem :: HAHNBAN1:29
   for V be VectSp-like (non empty VectSpStr over F_Complex)
   for F be RFunctional of V st F is Real_homogeneous
   for v be Vector of V
   for r be Real holds
    F.([**0,r**]*v) = r*F.(i_FC*v);

  definition
   let V be non empty VectSpStr over F_Complex;
   let F be RFunctional of V;
   attr F is homogeneous means
:: HAHNBAN1:def 19
    for v be Vector of V
    for r be Scalar of V holds F.(r*v) = |.r.|*F.v;
  end;


  definition
   let K be 1-sorted;
   let V be VectSpStr over K;
   let F be RFunctional of V;
   attr F is 0-preserving means
:: HAHNBAN1:def 20
      F.(0.V) = 0;
  end;


  registration
   let K be 1-sorted;
   let V be non empty VectSpStr over K;
   cluster additive -> subadditive RFunctional of V;
   coherence
   proof
    let F be RFunctional of V;
    assume A1: F is additive;
    let x,y be Vector of V;
    thus F.(x+y) <= F.x+F.y by A1,Def17;
   end;
  end;

  registration
   let V be VectSp of F_Complex;
   cluster Real_homogeneous -> 0-preserving RFunctional of V;
   coherence
   proof
    let F be RFunctional of V;
    assume A1: F is Real_homogeneous;
    A2: 0.F_Complex = [**0,0**] by Def1,COMPLFLD:9,L0;
    thus F.(0.V) = F.(0.F_Complex*0.V) by VECTSP_1:59
                .= 0*F.(0.V) by A1,A2,Def18
                .= 0;
   end;
  end;


  definition
   let K be 1-sorted;
   let V be VectSpStr over K;
   func 0RFunctional(V) -> RFunctional of V equals
:: HAHNBAN1:def 21
    [#]V --> 0;
  end;


  registration
   let K be 1-sorted;
   let V be non empty VectSpStr over K;
   cluster 0RFunctional(V) -> additive;
   coherence
   proof
    let x,y be Vector of V;
    A1: [#]V = the carrier of V by PRE_TOPC:12;
    A2: (0RFunctional(V)).x = ([#]V --> 0).x by Def21
                           .= 0 by A1,FUNCOP_1:13;
    A3: (0RFunctional(V)).y = ([#]V --> 0).y by Def21
                           .= 0 by A1,FUNCOP_1:13;
    thus (0RFunctional(V)).(x+y) = ([#]V --> 0).(x+y) by Def21
                                .= (0RFunctional(V)).x + (0RFunctional(V)).y
                                                       by A1,A2,A3,FUNCOP_1:13;
   end;

   cluster 0RFunctional(V) -> 0-preserving;
   coherence
   proof
    A4: [#]V = the carrier of V by PRE_TOPC:12;
    thus (0RFunctional(V)).(0.V) = ([#]V --> 0).(0.V) by Def21
                                .= 0 by A4,FUNCOP_1:13;
    thus thesis;
   end;
  end;


  registration
   let V be non empty VectSpStr over F_Complex;
   cluster 0RFunctional(V) -> Real_homogeneous;
   coherence
   proof
    let x be Vector of V;
    let r be Real;
    A1: [#]V = the carrier of V by PRE_TOPC:12;
    A2: (0RFunctional(V)).x = ([#]V --> 0).x by Def21
                          .= 0 by A1,FUNCOP_1:13;
    thus (0RFunctional(V)).([**r,0**]*x) = ([#]V --> 0).([**r,0**]*x) by Def21
           .= r*((0RFunctional(V)).x) by A1,A2,FUNCOP_1:13;
   end;

   cluster 0RFunctional(V) -> homogeneous;
   coherence
   proof
    let x be Vector of V;
    let r be Scalar of V;
    A3: [#]V = the carrier of V by PRE_TOPC:12;
    A4: (0RFunctional(V)).x = ([#]V --> 0).x by Def21
                          .= 0 by A3,FUNCOP_1:13;
    thus (0RFunctional(V)).(r*x) = ([#]V --> 0).(r*x) by Def21
           .= |.r.|*((0RFunctional(V)).x) by A3,A4,FUNCOP_1:13;
   end;
  end;


  registration
   let K be 1-sorted;
   let V be non empty VectSpStr over K;
   cluster additive 0-preserving RFunctional of V;
   existence
   proof
    take 0RFunctional(V);
    thus thesis;
   end;
  end;


  registration
   let V be non empty VectSpStr over F_Complex;
   cluster additive Real_homogeneous homogeneous RFunctional of V;
   existence
   proof
    take 0RFunctional(V);
    thus thesis;
   end;
  end;


  definition
   let V be non empty VectSpStr over F_Complex;
   mode Semi-Norm of V is subadditive homogeneous RFunctional of V;
  end;


begin :: Hahn Banach Theorem

  definition
   let V be non empty VectSpStr over F_Complex;
   func RealVS(V) -> strict RLSStruct means
:: HAHNBAN1:def 22
    the LoopStr of it = the LoopStr of V &
    for r be Real, v be Vector of V holds
     (the Mult of it).(r,v)=[**r,0**]*v;
  end;


  registration
   let V be non empty VectSpStr over F_Complex;
   cluster RealVS(V) -> non empty;
   coherence
   proof
      the LoopStr of V = the LoopStr of RealVS(V) by Def22;
    hence RealVS(V) is non empty by STRUCT_0:def 1;
   end;
  end;


  registration
   let V be Abelian (non empty VectSpStr over F_Complex);
   cluster RealVS(V) -> Abelian;
   coherence
   proof
    let v,w be Element of RealVS(V);
    A1: the LoopStr of V = the LoopStr of RealVS(V) by Def22;
    then reconsider v1=v,w1=w as Element of V;
    thus v + w = (the add of V).[v1,w1] by A1,RLVECT_1:def 3
              .= v1 + w1 by RLVECT_1:def 3
              .= (the add of RealVS(V)).[w,v] by A1,RLVECT_1:def 3
              .= w + v by RLVECT_1:def 3;
   end;
  end;


  registration
   let V be add-associative (non empty VectSpStr over F_Complex);
   cluster RealVS(V) -> add-associative;
   coherence
   proof
    let u,v,w be Element of RealVS(V);
    A1: the LoopStr of V = the LoopStr of RealVS(V) by Def22;
    then reconsider u1=u,v1=v,w1=w as Element of V;
    thus (u + v) + w = (the add of RealVS(V)).[u+v,w] by RLVECT_1:def 3
                 .= (the add of V).[((the add of V).[u1,v1]),w1] by A1,RLVECT_1
:def 3
                 .= (the add of V).[u1+v1,w1] by RLVECT_1:def 3
                 .= (u1 + v1) + w1 by RLVECT_1:def 3
                 .= u1 + (v1 + w1) by RLVECT_1:def 6
                 .= (the add of V).[u1,v1+w1] by RLVECT_1:def 3
                 .= (the add of RealVS(V)).[u,((the add of RealVS(V)).[v,w])]
                                                            by A1,RLVECT_1:def
3
                 .= (the add of RealVS(V)).[u,v+w] by RLVECT_1:def 3
                 .= u + (v + w) by RLVECT_1:def 3;
   end;
  end;


  registration
   let V be right_zeroed (non empty VectSpStr over F_Complex);
   cluster RealVS(V) -> right_zeroed;
   coherence
   proof
    let v be Element of RealVS(V);
    A1: the LoopStr of V = the LoopStr of RealVS(V) by Def22;
    then reconsider v1=v as Element of V;
    thus v + 0.RealVS(V) = (the add of V).[v1,0.RealVS(V)] by A1,RLVECT_1:def 3
                        .= (the add of V).[v1,the Zero of RealVS(V)]
                                                           by RLVECT_1:def 2
                        .= (the add of V).[v1,0.V] by A1,RLVECT_1:def 2
                        .= v1 + 0.V by RLVECT_1:def 3
                        .= v by RLVECT_1:def 7;
   end;
  end;


  registration
   let V be right_complementable (non empty VectSpStr over F_Complex);
   cluster RealVS(V) -> right_complementable;
   coherence
   proof
    let v be Element of RealVS(V);
    A1: the LoopStr of V = the LoopStr of RealVS(V) by Def22;
    then reconsider v1=v as Element of V;
    consider w1 be Element of V such that
     A2: v1 + w1 = 0.V by RLVECT_1:def 8;
    reconsider w=w1 as Element of RealVS(V) by A1;
    take w;
    thus v + w = (the add of V).[v1,w1] by A1,RLVECT_1:def 3
              .= v1 + w1 by RLVECT_1:def 3
              .= the Zero of RealVS(V) by A1,A2,RLVECT_1:def 2
              .= 0.RealVS(V) by RLVECT_1:def 2;
   end;
  end;


  registration
   let V be VectSp-like (non empty VectSpStr over F_Complex);
   cluster RealVS(V) -> RealLinearSpace-like;
   coherence
   proof
    thus for a be Real for v,w be Element of RealVS(V) holds
     a * (v + w) = a * v + a * w
     proof
      let a be Real;
      let v,w be Element of RealVS(V);
      A1: the LoopStr of V = the LoopStr of RealVS(V) by Def22;
      set a1=[**a,0**];
      reconsider v1=v,w1=w as Element of V by A1;
      thus a * (v + w) = (the Mult of RealVS(V)).[a,v+w] by RLVECT_1:def 4
            .= (the Mult of RealVS(V)).(a,v+w) by BINOP_1:def 1
            .= (the Mult of RealVS(V)).(a,((the add of V).[v1,w1])) by A1,
RLVECT_1:def 3
            .= (the Mult of RealVS(V)).(a,(v1 + w1)) by RLVECT_1:def 3
            .= [**a,0**] * (v1 + w1) by Def22
            .= a1 * v1 + a1 * w1 by VECTSP_1:def 26
            .= (the add of V).[a1*v1,a1*w1] by RLVECT_1:def 3
            .= (the add of V).[((the Mult of RealVS(V)).(a,v1)),[**a,0**]*w1]
                                                                       by Def22
            .= (the add of RealVS(V)).[((the Mult of RealVS(V)).(a,v)),
                                      ((the Mult of RealVS(V)).(a,w))] by A1,
Def22
            .= (the add of RealVS(V)).[((the Mult of RealVS(V)).[a,v]),
                              ((the Mult of RealVS(V)).(a,w))] by BINOP_1:def 1
            .= (the add of RealVS(V)).[((the Mult of RealVS(V)).[a,v]),
                              ((the Mult of RealVS(V)).[a,w])] by BINOP_1:def 1
            .= (the add of RealVS(V)).[((the Mult of RealVS(V)).[a,v]),
                                      (a*w)] by RLVECT_1:def 4
            .= (the add of RealVS(V)).[a*v,a*w] by RLVECT_1:def 4
            .= a * v + a * w by RLVECT_1:def 3;
     end;
    thus for a,b be Real for v be Element of RealVS(V) holds
     (a + b) * v = a * v + b * v
     proof
      let a,b be Real;
      let v be Element of RealVS(V);
      A2: the LoopStr of V = the LoopStr of RealVS(V) by Def22;
      set a1=[**a,0**];
      set b1=[**b,0**];
        [**a,0**] = [*a,0*] & [**b,0**] = [*b,0*] by Def1;
      then A3: [**a,0**] + [**b,0**] = [*a,0*] + [*b,0*] by COMPLFLD:3
                                    .= [*a+b,0+0*] by COMPLFLD:2
                                    .= [**a+b,0**] by Def1;
      reconsider v1=v as Element of V by A2;
      thus (a + b) * v = (the Mult of RealVS(V)).[a+b,v] by RLVECT_1:def 4
             .= (the Mult of RealVS(V)).(a+b,v) by BINOP_1:def 1
             .= ([**a,0**] + [**b,0**]) * v1 by A3,Def22
             .= a1 * v1 + b1 * v1 by VECTSP_1:def 26
             .= (the add of RealVS(V)).[([**a,0**]*v1),([**b,0**]*v1)] by A2,
RLVECT_1:def 3
             .= (the add of RealVS(V)).[((the Mult of RealVS(V)).(a,v)),
                                                       ([**b,0**]*v1)] by Def22
             .= (the add of RealVS(V)).[((the Mult of RealVS(V)).(a,v)),
                                      ((the Mult of RealVS(V)).(b,v))] by Def22
             .= (the add of RealVS(V)).[((the Mult of RealVS(V)).[a,v]),
                              ((the Mult of RealVS(V)).(b,v))] by BINOP_1:def 1
             .= (the add of RealVS(V)).[((the Mult of RealVS(V)).[a,v]),
                              ((the Mult of RealVS(V)).[b,v])] by BINOP_1:def 1
             .= (the add of RealVS(V)).[((the Mult of RealVS(V)).[a,v]),
                                                       b*v] by RLVECT_1:def 4
             .= (the add of RealVS(V)).[a*v,b*v] by RLVECT_1:def 4
             .= a * v + b * v by RLVECT_1:def 3;
     end;
    thus for a,b be Real for v be Element of RealVS(V) holds
     (a * b) * v = a * (b * v)
     proof
      let a,b be Real;
      let v be Element of RealVS(V);
      A4: the LoopStr of V = the LoopStr of RealVS(V) by Def22;
      A5: [**a,0**]=[*a,0*] & [**b,0**]=[*b,0*] by Def1;
      A6: [**a*b,0**] = [*a*b - 0*0,a*0+b*0*] by Def1
                     .= [*a,0*] * [*b,0*] by Th2
                     .= [**a,0**]*[**b,0**] by A5,COMPLFLD:6;
      reconsider v1=v as Element of V by A4;
      thus (a * b) * v = (the Mult of RealVS(V)).[a*b,v] by RLVECT_1:def 4
       .= (the Mult of RealVS(V)).(a*b,v) by BINOP_1:def 1
       .= ([**a,0**] * [**b,0**]) * v1 by A6,Def22
       .= [**a,0**] * ([**b,0**] * v1) by VECTSP_1:def 26
       .= (the Mult of RealVS(V)).(a,([**b,0**] * v1)) by Def22
       .= (the Mult of RealVS(V)).(a,(the Mult of RealVS(V)).(b,v)) by Def22
       .= (the Mult of RealVS(V)).[a,(the Mult of RealVS(V)).(b,v)]
                                                             by BINOP_1:def 1
       .= (the Mult of RealVS(V)).[a,(the Mult of RealVS(V)).[b,v]]
                                                             by BINOP_1:def 1
       .= (the Mult of RealVS(V)).[a,b*v] by RLVECT_1:def 4
       .= a * (b * v) by RLVECT_1:def 4;
     end;
    let v be Element of RealVS(V);
      the LoopStr of V = the LoopStr of RealVS(V) by Def22;
    then reconsider v1=v as Element of V;
    A7: [**1,0**] = 1_(F_Complex) by Def1,COMPLFLD:10,L1;
    thus 1 * v = (the Mult of RealVS(V)).[1,v] by RLVECT_1:def 4
              .= (the Mult of RealVS(V)).(1,v) by BINOP_1:def 1
              .= [**1,0**] * v1 by Def22
              .= v by A7,VECTSP_1:def 26;
   end;
  end;


  theorem :: HAHNBAN1:30
   for V be non empty VectSp of F_Complex
   for M be Subspace of V holds
    RealVS(M) is Subspace of RealVS(V);

  theorem :: HAHNBAN1:31
   for V be non empty VectSpStr over F_Complex
   for p be RFunctional of V holds
    p is Functional of RealVS(V);

  theorem :: HAHNBAN1:32
   for V be non empty VectSp of F_Complex
   for p be Semi-Norm of V holds
    p is Banach-Functional of RealVS(V);

  definition
   let V be non empty VectSpStr over F_Complex;
   let l be Functional of V;
   func projRe(l) -> Functional of RealVS(V) means
:: HAHNBAN1:def 23
    for i be Element of V holds
     it.i = Re(l.i);
  end;


  definition
   let V be non empty VectSpStr over F_Complex;
   let l be Functional of V;
   func projIm(l) -> Functional of RealVS(V) means
:: HAHNBAN1:def 24
    for i be Element of V holds
     it.i = Im(l.i);
  end;


  definition
   let V be non empty VectSpStr over F_Complex;
   let l be Functional of RealVS(V);
   func RtoC(l) -> RFunctional of V equals
:: HAHNBAN1:def 25
    l;
  end;


  definition
   let V be non empty VectSpStr over F_Complex;
   let l be RFunctional of V;
   func CtoR(l) -> Functional of RealVS(V) equals
:: HAHNBAN1:def 26
    l;
  end;


  registration
   let V be non empty VectSp of F_Complex;
   let l be additive Functional of RealVS(V);
   cluster RtoC(l) -> additive;
   coherence
   proof
    let x,y be Vector of V;
    A1: the LoopStr of V = the LoopStr of RealVS(V) by Def22;
    then reconsider x1=x,y1=y as VECTOR of RealVS(V);
      x+y = (the add of RealVS(V)).[x1,y1] by A1,RLVECT_1:def 3
       .= x1+y1 by RLVECT_1:def 3;
    hence (RtoC l).(x+y) = l.(x1+y1) by Def25
       .= l.x1+l.y1 by HAHNBAN:def 4
       .= (RtoC l).x+l.y1 by Def25
       .= (RtoC l).x+(RtoC l).y by Def25;
   end;
  end;


  registration
   let V be non empty VectSp of F_Complex;
   let l be additive RFunctional of V;
   cluster CtoR(l) -> additive;
   coherence
   proof
    let x,y be VECTOR of RealVS(V);
    A1: the LoopStr of V = the LoopStr of RealVS(V) by Def22;
    then reconsider x1=x,y1=y as Vector of V;
      x+y = (the add of V).[x1,y1] by A1,RLVECT_1:def 3
       .= x1+y1 by RLVECT_1:def 3;
    hence (CtoR l).(x+y) = l.(x1+y1) by Def26
       .= l.x1+l.y1 by Def17
       .= (CtoR l).x+l.y1 by Def26
       .= (CtoR l).x+(CtoR l).y by Def26;
   end;
  end;


  registration
   let V be non empty VectSp of F_Complex;
   let l be homogeneous Functional of RealVS(V);
   cluster RtoC(l) -> Real_homogeneous;
   coherence
   proof
    let x be Vector of V;
    let r be Real;
      the LoopStr of V = the LoopStr of RealVS(V) by Def22;
    then reconsider x1=x as VECTOR of RealVS(V);
      [**r,0**]*x = (the Mult of RealVS(V)).(r,x) by Def22
       .= (the Mult of RealVS(V)).[r,x] by BINOP_1:def 1
       .= r*x1 by RLVECT_1:def 4;
    hence (RtoC l).([**r,0**]*x) = l.(r*x1) by Def25
       .= r*l.x1 by HAHNBAN:def 5
       .= r*(RtoC l).x by Def25;
   end;
  end;


  registration
   let V be non empty VectSp of F_Complex;
   let l be Real_homogeneous RFunctional of V;
   cluster CtoR(l) -> homogeneous;
   coherence
   proof
    let x be VECTOR of RealVS(V);
    let r be Real;
      the LoopStr of V = the LoopStr of RealVS(V) by Def22;
    then reconsider x1=x as Vector of V;
      [**r,0**]*x1 = (the Mult of RealVS(V)).(r,x1) by Def22
       .= (the Mult of RealVS(V)).[r,x1] by BINOP_1:def 1
       .= r*x by RLVECT_1:def 4;
    hence (CtoR l).(r*x) = l.([**r,0**]*x1) by Def26
       .= r*l.x1 by Def18
       .= r*(CtoR l).x by Def26;
   end;
  end;


  definition
   let V be non empty VectSpStr over F_Complex;
   let l be RFunctional of V;
   func i-shift(l) -> RFunctional of V means
:: HAHNBAN1:def 27
    for v be Element of V holds
     it.v = l.(i_FC*v);
  end;


  definition
   let V be non empty VectSpStr over F_Complex;
   let l be Functional of RealVS(V);
   func prodReIm(l) -> Functional of V means
:: HAHNBAN1:def 28
    for v be Element of V holds
     it.v = [**(RtoC l).v,-(i-shift(RtoC l)).v**];
  end;


  theorem :: HAHNBAN1:33
   for V be non empty VectSp of F_Complex
   for l be linear-Functional of V holds
    projRe(l) is linear-Functional of RealVS(V);

  theorem :: HAHNBAN1:34
     for V be non empty VectSp of F_Complex
   for l be linear-Functional of V holds
    projIm(l) is linear-Functional of RealVS(V);

  theorem :: HAHNBAN1:35
   for V be non empty VectSp of F_Complex
   for l be linear-Functional of RealVS(V) holds
    prodReIm(l) is linear-Functional of V;

  theorem :: HAHNBAN1:36 :: Hahn Banach Theorem
     for V be non empty VectSp of F_Complex
   for p be Semi-Norm of V
   for M be Subspace of V
   for l be linear-Functional of M st
    for e be Vector of M for v be Vector of V st v=e holds |.l.e.| <= p.v
   ex L be linear-Functional of V st
    L|the carrier of M = l &
    for e be Vector of V holds |.L.e.| <= p.e;
