:: Recursive Definitions. {P}art {II}
::  by Artur Korni{\l}owicz
::
:: Received February 10, 2004
:: Copyright (c) 2004 Association of Mizar Users

environ

 vocabulary RELAT_1, FUNCT_1, MCART_1, ARYTM_1, FUNCT_3, RECDEF_2, BOOLE,
      FUNCT_4, FUNCT_7;
 notation TARSKI, XBOOLE_0, ZFMISC_1, SUBSET_1, MCART_1, MCART_2, DOMAIN_1,
      NUMBERS, XCMPLX_0, XREAL_0, NAT_1, RELAT_1, FUNCT_1, RELSET_1, FUNCT_2,
      DTCONSTR, FUNCT_4, BINARITH, JCT_MISC, FUNCT_7;
 constructors SUBSET_1, FUNCT_2, NAT_1, DOMAIN_1, DTCONSTR, XREAL_0, BINARITH,
      JCT_MISC, INT_1, FUNCT_4, MCART_2, FUNCT_7;
 clusters XBOOLE_0, RELSET_1, ZFMISC_1, SUBSET_1, ORDINAL2, ARYTM_3, XCMPLX_0,
      XREAL_0, NAT_1, INT_1;
 requirements BOOLE, SUBSET, NUMERALS, ARITHM, REAL;


begin

reserve a,b,c,d,e,z,A,B,C,D,E for set;

:: Projections

definition
  let x be set;
  given x1,x2,x3 being set such that
 x = [x1,x2,x3];
  func x`1_3 means
:: RECDEF_2:def 1
  for y1,y2,y3 being set holds x = [y1,y2,y3] implies it = y1;
  func x`2_3 means
:: RECDEF_2:def 2
  for y1,y2,y3 being set holds x = [y1,y2,y3] implies it = y2;
  func x`3_3 means
:: RECDEF_2:def 3
  for y1,y2,y3 being set holds x = [y1,y2,y3] implies it = y3;
end;

theorem :: RECDEF_2:1
  (ex a,b,c st z = [a,b,c]) implies z = [ z`1_3, z`2_3, z`3_3 ];

theorem :: RECDEF_2:2
   z in [:A,B,C:] implies z`1_3 in A & z`2_3 in B & z`3_3 in C;

theorem :: RECDEF_2:3
   z in [:A,B,C:] implies z = [ z`1_3, z`2_3, z`3_3 ];

definition
  let x be set;
  given x1,x2,x3,x4 being set such that
 x = [x1,x2,x3,x4];
  func x`1_4 means
:: RECDEF_2:def 4
  for y1,y2,y3,y4 being set holds x = [y1,y2,y3,y4] implies it = y1;
  func x`2_4 means
:: RECDEF_2:def 5
  for y1,y2,y3,y4 being set holds x = [y1,y2,y3,y4] implies it = y2;
  func x`3_4 means
:: RECDEF_2:def 6
  for y1,y2,y3,y4 being set holds x = [y1,y2,y3,y4] implies it = y3;
  func x`4_4 means
:: RECDEF_2:def 7
  for y1,y2,y3,y4 being set holds x = [y1,y2,y3,y4] implies it = y4;
end;

theorem :: RECDEF_2:4
  (ex a,b,c,d st z = [a,b,c,d]) implies z = [ z`1_4, z`2_4, z`3_4, z`4_4 ];

theorem :: RECDEF_2:5
   z in [:A,B,C,D:] implies z`1_4 in A & z`2_4 in B & z`3_4 in C & z`4_4 in D;

theorem :: RECDEF_2:6
   z in [:A,B,C,D:] implies z = [ z`1_4, z`2_4, z`3_4, z`4_4 ];

definition
  let x be set;
  given x1,x2,x3,x4,x5 being set such that
 x = [x1,x2,x3,x4,x5];
  func x`1_5 means
:: RECDEF_2:def 8
  for y1,y2,y3,y4,y5 being set holds x = [y1,y2,y3,y4,y5] implies it = y1;
  func x`2_5 means
:: RECDEF_2:def 9
  for y1,y2,y3,y4,y5 being set holds x = [y1,y2,y3,y4,y5] implies it = y2;
  func x`3_5 means
:: RECDEF_2:def 10
  for y1,y2,y3,y4,y5 being set holds x = [y1,y2,y3,y4,y5] implies it = y3;
  func x`4_5 means
:: RECDEF_2:def 11
  for y1,y2,y3,y4,y5 being set holds x = [y1,y2,y3,y4,y5] implies it = y4;
  func x`5_5 means
:: RECDEF_2:def 12
  for y1,y2,y3,y4,y5 being set holds x = [y1,y2,y3,y4,y5] implies it = y5;
end;

theorem :: RECDEF_2:7
  (ex a,b,c,d,e st z = [a,b,c,d,e]) implies
    z = [ z`1_5, z`2_5, z`3_5, z`4_5, z`5_5 ];

theorem :: RECDEF_2:8
   z in [:A,B,C,D,E:] implies
   z`1_5 in A & z`2_5 in B & z`3_5 in C & z`4_5 in D & z`5_5 in E;

theorem :: RECDEF_2:9
   z in [:A,B,C,D,E:] implies z = [ z`1_5, z`2_5, z`3_5, z`4_5, z`5_5 ];

:: Conditional schemes

scheme :: RECDEF_2:sch 1
 ExFunc3Cond { C() -> set, P,Q,R[set], F,G,H(set) -> set }:
  ex f being Function st dom f = C() &
   for c being set st c in C() holds (P[c] implies f.c = F(c)) &
    (Q[c] implies f.c = G(c)) & (R[c] implies f.c = H(c))
provided
 for c being set st c in C() holds (P[c] implies not Q[c]) &
    (P[c] implies not R[c]) & (Q[c] implies not R[c]) and
 for c being set st c in C() holds P[c] or Q[c] or R[c];

scheme :: RECDEF_2:sch 2
 ExFunc4Cond { C() -> set, P,Q,R,S[set], F,G,H,I(set) -> set }:
  ex f being Function st dom f = C() &
   for c being set st c in C() holds
    (P[c] implies f.c = F(c)) & (Q[c] implies f.c = G(c)) &
    (R[c] implies f.c = H(c)) & (S[c] implies f.c = I(c))
provided
 for c being set st c in C() holds
    (P[c] implies not Q[c]) & (P[c] implies not R[c]) &
    (P[c] implies not S[c]) & (Q[c] implies not R[c]) &
    (Q[c] implies not S[c]) & (R[c] implies not S[c]) and
 for c being set st c in C() holds P[c] or Q[c] or R[c] or S[c];

:: 1 step

scheme :: RECDEF_2:sch 3
 DoubleChoiceRec { A, B() -> non empty set,
  A0() -> Element of A(), B0() -> Element of B(), P[set,set,set,set,set] }:
  ex f being Function of NAT, A(),
     g being Function of NAT, B() st f.0 = A0() & g.0 = B0() &
   for n being Element of NAT holds P[n,f.n,g.n,f.(n+1),g.(n+1)]
provided
for n being Element of NAT, x being Element of A(), y being Element of B()
    ex x1 being Element of A(), y1 being Element of B() st P[n,x,y,x1,y1];

:: 2 steps

scheme :: RECDEF_2:sch 4
 LambdaRec2Ex { A,B() -> set, F(set,set,set) -> set }:
  ex f being Function st dom f = NAT & f.0 = A() & f.1 = B() &
     for n being Nat holds f.(n+2) = F(n,f.n,f.(n+1));

scheme :: RECDEF_2:sch 5
 LambdaRec2ExD { X() -> non empty set, A,B() -> Element of X(),
                       F(set,set,set) -> Element of X() }:
  ex f being Function of NAT,X() st f.0 = A() & f.1 = B() &
     for n being Nat holds f.(n+2) = F(n,f.n,f.(n+1));

scheme :: RECDEF_2:sch 6
 LambdaRec2Un { A,B() -> set, F,G() -> Function,
                      F(set,set,set) -> set }:
  F() = G()
provided
 dom F() = NAT and
 F().0 = A() & F().1 = B() and
 for n being Nat holds F().(n+2) = F(n,F().n,F().(n+1)) and
 dom G() = NAT and
 G().0 = A() & G().1 = B() and
 for n being Nat holds G().(n+2) = F(n,G().n,G().(n+1));

scheme :: RECDEF_2:sch 7
 LambdaRec2UnD { X() -> non empty set, A,B() -> Element of X(),
                       F,G() -> Function of NAT,X(),
                       F(set,set,set) -> Element of X() }:
  F() = G()
provided
 F().0 = A() & F().1 = B() and
 for n being Nat holds F().(n+2) = F(n,F().n,F().(n+1)) and
 G().0 = A() & G().1 = B() and
 for n being Nat holds G().(n+2) = F(n,G().n,G().(n+1));

:: 3 steps

scheme :: RECDEF_2:sch 8
 LambdaRec3Ex { A,B,C() -> set, F(set,set,set,set) -> set }:
  ex f being Function st dom f = NAT & f.0 = A() & f.1 = B() & f.2 = C() &
     for n being Nat holds f.(n+3) = F(n,f.n,f.(n+1),f.(n+2));

scheme :: RECDEF_2:sch 9
 LambdaRec3ExD { X() -> non empty set, A,B,C() -> Element of X(),
                       F(set,set,set,set) -> Element of X() }:
  ex f being Function of NAT,X() st f.0 = A() & f.1 = B() & f.2 = C() &
     for n being Nat holds f.(n+3) = F(n,f.n,f.(n+1),f.(n+2));

scheme :: RECDEF_2:sch 10
 LambdaRec3Un { A,B,C() -> set, F,G() -> Function,
                      F(set,set,set,set) -> set }:
  F() = G()
provided
 dom F() = NAT and
 F().0 = A() & F().1 = B() & F().2 = C() and
 for n being Nat holds F().(n+3) = F(n,F().n,F().(n+1),F().(n+2)) and
 dom G() = NAT and
 G().0 = A() & G().1 = B() & G().2 = C() and
 for n being Nat holds G().(n+3) = F(n,G().n,G().(n+1),G().(n+2));

scheme :: RECDEF_2:sch 11
 LambdaRec3UnD { X() -> non empty set, A,B,C() -> Element of X(),
                       F,G() -> Function of NAT,X(),
                       F(set,set,set,set) -> Element of X() }:
  F() = G()
provided
 F().0 = A() & F().1 = B() & F().2 = C() and
 for n being Nat holds F().(n+3) = F(n,F().n,F().(n+1),F().(n+2)) and
 G().0 = A() & G().1 = B() & G().2 = C() and
 for n being Nat holds G().(n+3) = F(n,G().n,G().(n+1),G().(n+2));

:: 4 steps

scheme :: RECDEF_2:sch 12
 LambdaRec4Ex { A,B,C,D() -> set, F(set,set,set,set,set) -> set }:
  ex f being Function st dom f = NAT &
   f.0 = A() & f.1 = B() & f.2 = C() & f.3 = D() &
    for n being Nat holds f.(n+4) = F(n,f.n,f.(n+1),f.(n+2),f.(n+3));

scheme :: RECDEF_2:sch 13
 LambdaRec4ExD { X() -> non empty set, A,B,C,D() -> Element of X(),
                       F(set,set,set,set,set) -> Element of X() }:
  ex f being Function of NAT,X() st
    f.0 = A() & f.1 = B() & f.2 = C() & f.3 = D() &
     for n being Nat holds f.(n+4) = F(n,f.n,f.(n+1),f.(n+2),f.(n+3));

scheme :: RECDEF_2:sch 14
 LambdaRec4Un { A,B,C,D() -> set, F,G() -> Function,
                      F(set,set,set,set,set) -> set }:
  F() = G()
provided
 dom F() = NAT and
 F().0 = A() & F().1 = B() & F().2 = C() & F().3 = D() and
 for n being Nat holds F().(n+4) = F(n,F().n,F().(n+1),F().(n+2),F().(n+3))
    and
 dom G() = NAT and
 G().0 = A() & G().1 = B() & G().2 = C() & G().3 = D() and
 for n being Nat holds G().(n+4) = F(n,G().n,G().(n+1),G().(n+2),G().(n+3));

scheme :: RECDEF_2:sch 15
 LambdaRec4UnD { X() -> non empty set, A,B,C,D() -> Element of X(),
                       F,G() -> Function of NAT,X(),
                       F(set,set,set,set,set) -> Element of X() }:
  F() = G()
provided
 F().0 = A() & F().1 = B() & F().2 = C() & F().3 = D() and
 for n being Nat holds F().(n+4) = F(n,F().n,F().(n+1),F().(n+2),F().(n+3))
    and
 G().0 = A() & G().1 = B() & G().2 = C() & G().3 = D() and
 for n being Nat holds G().(n+4) = F(n,G().n,G().(n+1),G().(n+2),G().(n+3));

