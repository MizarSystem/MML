:: Manysorted Sets
::  by Andrzej Trybulec
::
:: Received July 7, 1993
:: Copyright (c) 1993 Association of Mizar Users

environ

 vocabularies FUNCT_1, MATRIX_1, RELAT_1, BOOLE, ZF_REFLE, AMI_1, FUNCOP_1,
      CAT_4, LATTICES, CQC_LANG, PBOOLE, MSUALG_1, PRALG_1, CARD_3, TDGROUP,
      FINSEQ_1, FINSEQ_2, FUNCT_2, PRALG_2, AUTALG_1, MSUALG_2, MSUALG_3;
 notations TARSKI, ZFMISC_1, XBOOLE_0, SUBSET_1, SETFAM_1, RELAT_1, FUNCT_1,
      FUNCT_2, FUNCOP_1, FINSEQ_1, FINSEQ_2, CARD_3, NUMBERS;
 constructors SETFAM_1, FUNCOP_1, FINSEQ_2, CARD_3, SEQ_1;
 registrations XBOOLE_0, SUBSET_1, FUNCT_1, ORDINAL1, RELSET_1, FUNCOP_1;
 requirements BOOLE, SUBSET;


begin

reserve i,j,e,u for set;

theorem :: PBOOLE:1
     for f being Function st f is non-empty
  holds rng f is with_non-empty_elements;

theorem :: PBOOLE:2
     for f being Function holds
  f is empty-yielding iff f = {} or rng f = { {} };

reserve I for set; :: of indices

definition let I;
 canceled 2;

  mode ManySortedSet of I -> Function means
:: PBOOLE:def 3
 dom it = I;
end;

reserve x,X,Y,Z,V for ManySortedSet of I;

scheme :: PBOOLE:sch 1
 KuratowskiFunction{A()-> set, F(set) -> set}:
 ex f being ManySortedSet of A() st
  for e st e in A() holds f.e in F(e)
 provided
 for e st e in A() holds F(e) <> {};

definition let I,X,Y;
 pred X in Y means
:: PBOOLE:def 4
 for i st i in I holds X.i in Y.i;
 pred X c= Y means
:: PBOOLE:def 5
 for i st i in I holds X.i c= Y.i;
 reflexivity;
end;

definition let I be non empty set,X,Y be ManySortedSet of I;
 redefine pred X in Y;
 asymmetry;
end;

scheme :: PBOOLE:sch 2
 PSeparation { I()-> set, A() -> ManySortedSet of I(), P[set,set] } :
  ex X being ManySortedSet of I() st
   for i being set st i in I()
    for e holds e in X.i iff e in A().i & P[i,e];

theorem :: PBOOLE:3
 (for i st i in I holds X.i = Y.i) implies X = Y;

definition
 let I;
  func [0]I -> ManySortedSet of I equals
:: PBOOLE:def 6
   I --> {};
 let X,Y;
  func X \/ Y -> ManySortedSet of I means
:: PBOOLE:def 7
 for i st i in I holds it.i = X.i \/ Y.i;
  commutativity;
  idempotence;

  func X /\ Y -> ManySortedSet of I means
:: PBOOLE:def 8
 for i st i in I holds it.i = X.i /\ Y.i;
  commutativity;
  idempotence;

  func X \ Y -> ManySortedSet of I means
:: PBOOLE:def 9
 for i st i in I holds it.i = X.i \ Y.i;
  pred X overlaps Y means
:: PBOOLE:def 10
 for i st i in I holds X.i meets Y.i;
  symmetry;
  pred X misses Y means
:: PBOOLE:def 11
 for i st i in I holds X.i misses Y.i;
  symmetry;
  end;

notation
 let I;
  let X,Y;
  antonym X does_not_overlap Y for X overlaps Y; antonym X meets Y for
 X misses Y; end;

definition let I,X,Y;
 func X \+\ Y -> ManySortedSet of I equals
:: PBOOLE:def 12
   (X \ Y) \/ (Y \ X);
 commutativity;
end;

theorem :: PBOOLE:4
 for i st i in I holds (X \+\ Y).i = X.i \+\ Y.i;

theorem :: PBOOLE:5
 [0]I.i = {};

theorem :: PBOOLE:6
 (for i st i in I holds X.i = {}) implies X = [0]I;

theorem :: PBOOLE:7
 x in X or x in Y implies x in X \/ Y;

theorem :: PBOOLE:8
 x in X /\ Y iff x in X & x in Y;

theorem :: PBOOLE:9
 x in X & X c= Y implies x in Y;

theorem :: PBOOLE:10
 x in X & x in Y implies X overlaps Y;

theorem :: PBOOLE:11
 X overlaps Y implies ex x st x in X & x in Y;

theorem :: PBOOLE:12
     x in X \ Y implies x in X;

begin :: Lattice properties

definition let I,X,Y;
 redefine pred X = Y means
:: PBOOLE:def 13
       X c= Y & Y c= X;
end;

canceled 2;

theorem :: PBOOLE:15
 X c= Y & Y c= Z implies X c= Z;

theorem :: PBOOLE:16
 X c= X \/ Y & Y c= X \/ Y;

theorem :: PBOOLE:17
 X /\ Y c= X & X /\ Y c= Y;

theorem :: PBOOLE:18
 X c= Z & Y c= Z implies X \/ Y c= Z;

theorem :: PBOOLE:19
 Z c= X & Z c= Y implies Z c= X /\ Y;

theorem :: PBOOLE:20
     X c= Y implies X \/ Z c= Y \/ Z & Z \/ X c= Z \/ Y;

theorem :: PBOOLE:21
 X c= Y implies X /\ Z c= Y /\ Z & Z /\ X c= Z /\ Y;

theorem :: PBOOLE:22
 X c= Y & Z c= V implies X \/ Z c= Y \/ V;

theorem :: PBOOLE:23
     X c= Y & Z c= V implies X /\ Z c= Y /\ V;

theorem :: PBOOLE:24
 X c= Y implies X \/ Y = Y & Y \/ X = Y;

theorem :: PBOOLE:25
 X c= Y implies X /\ Y = X & Y /\ X = X;

theorem :: PBOOLE:26
     X /\ Y c= X \/ Z;

theorem :: PBOOLE:27
     X c= Z implies X \/ Y /\ Z = (X \/ Y) /\ Z;

theorem :: PBOOLE:28
     X = Y \/ Z iff Y c= X & Z c= X & for V st Y c= V & Z c= V holds X c= V;

theorem :: PBOOLE:29
     X = Y /\ Z iff X c= Y & X c= Z & for V st V c= Y & V c= Z holds V c= X;

canceled 4;

theorem :: PBOOLE:34
 (X \/ Y) \/ Z = X \/ (Y \/ Z);

theorem :: PBOOLE:35
 (X /\ Y) /\ Z = X /\ (Y /\ Z);

theorem :: PBOOLE:36
 X /\ (X \/ Y) = X & (X \/ Y) /\ X = X & X /\ (Y \/ X) = X & (Y \/ X) /\ X = X;

theorem :: PBOOLE:37
 X \/ (X /\ Y) = X & (X /\ Y) \/ X = X & X \/ (Y /\ X) = X & (Y /\ X) \/ X = X;

theorem :: PBOOLE:38
 X /\ (Y \/ Z) = X /\ Y \/ X /\ Z;

theorem :: PBOOLE:39
 X \/ Y /\ Z = (X \/ Y) /\ (X \/ Z) & Y /\ Z \/ X = (Y \/ X) /\ (Z \/ X);

theorem :: PBOOLE:40
     (X /\ Y) \/ (X /\ Z) = X implies X c= Y \/ Z;

theorem :: PBOOLE:41
     (X \/ Y) /\ (X \/ Z) = X implies Y /\ Z c= X;

theorem :: PBOOLE:42
     (X /\ Y) \/ (Y /\ Z) \/ (Z /\ X) = (X \/ Y) /\ (Y \/ Z) /\ (Z \/ X);

theorem :: PBOOLE:43 :: SETWISEO:7
     X \/ Y c= Z implies X c= Z & Y c= Z;

theorem :: PBOOLE:44 :: SYSREL:4
     X c= Y /\ Z implies X c= Y & X c= Z;

theorem :: PBOOLE:45 :: SYSREL:2
     X \/ Y \/ Z = (X \/ Z) \/ (Y \/ Z) &
  X \/ (Y \/ Z) = (X \/ Y) \/ (X \/ Z);

theorem :: PBOOLE:46
     X /\ Y /\ Z = (X /\ Z) /\ (Y /\ Z) &
  X /\ (Y /\ Z) = (X /\ Y) /\ (X /\ Z);

theorem :: PBOOLE:47 :: SYSREL:3
     X \/ (X \/ Y) = X \/ Y & X \/ Y \/ Y = X \/ Y;

theorem :: PBOOLE:48
     X /\ (X /\ Y) = X /\ Y & X /\ Y /\ Y = X /\ Y;

begin :: ManySortedSet with empty components

theorem :: PBOOLE:49
 [0]I c= X;

theorem :: PBOOLE:50
 X c= [0]I implies X = [0]I;

theorem :: PBOOLE:51
 X c= Y & X c= Z & Y /\ Z = [0]I implies X = [0]I;

theorem :: PBOOLE:52
     X c= Y & Y /\ Z = [0]I implies X /\ Z = [0]I;

theorem :: PBOOLE:53
 X \/ [0]I = X & [0]I \/ X = X;

theorem :: PBOOLE:54
     X \/ Y = [0]I implies X = [0]I & Y = [0]I;

theorem :: PBOOLE:55
     X /\ [0]I = [0]I & [0]I /\ X = [0]I;

theorem :: PBOOLE:56
     X c= (Y \/ Z) & X /\ Z = [0]I implies X c= Y;

theorem :: PBOOLE:57
     Y c= X & X /\ Y = [0]I implies Y = [0]I;

begin :: Difference and symmetric difference

theorem :: PBOOLE:58
 X \ Y = [0]I iff X c= Y;

theorem :: PBOOLE:59
 X c= Y implies X \ Z c= Y \ Z;

theorem :: PBOOLE:60
 X c= Y implies Z \ Y c= Z \ X;

theorem :: PBOOLE:61
     X c= Y & Z c= V implies X \ V c= Y \ Z;

theorem :: PBOOLE:62
 X \ Y c= X;

theorem :: PBOOLE:63
     X c= Y \ X implies X = [0]I;

theorem :: PBOOLE:64
     X \ X = [0]I;

theorem :: PBOOLE:65
 X \ [0]I = X;

theorem :: PBOOLE:66
 [0]I \ X = [0]I;

theorem :: PBOOLE:67
     X \ (X \/ Y) = [0]I & X \ (Y \/ X) = [0]I;

theorem :: PBOOLE:68
 X /\ (Y \ Z) = (X /\ Y) \ Z;

theorem :: PBOOLE:69
 (X \ Y) /\ Y = [0]I & Y /\ (X \ Y) = [0]I;

theorem :: PBOOLE:70
 X \ (Y \ Z) = (X \ Y) \/ X /\ Z;

theorem :: PBOOLE:71
 (X \ Y) \/ X /\ Y = X & X /\ Y \/ (X \ Y) = X;

theorem :: PBOOLE:72
     X c= Y implies Y = X \/ (Y \ X) & Y = (Y \ X) \/ X;

theorem :: PBOOLE:73
 X \/ (Y \ X) = X \/ Y & (Y \ X) \/ X = Y \/ X;

theorem :: PBOOLE:74
 X \ (X \ Y) = X /\ Y;

theorem :: PBOOLE:75
 X \ (Y /\ Z) = (X \ Y) \/ (X \ Z);

theorem :: PBOOLE:76
 X \ X /\ Y = X \ Y & X \ Y /\ X = X \ Y;

theorem :: PBOOLE:77
     X /\ Y = [0]I iff X \ Y = X;

theorem :: PBOOLE:78
 (X \/ Y) \ Z = (X \ Z) \/ (Y \ Z);

theorem :: PBOOLE:79
 (X \ Y) \ Z = X \ (Y \/ Z);

theorem :: PBOOLE:80 ::  TSEP_1, LEMMA3
     (X /\ Y) \ Z = (X \ Z) /\ (Y \ Z);

theorem :: PBOOLE:81
 (X \/ Y) \ Y = X \ Y;

theorem :: PBOOLE:82
     X c= Y \/ Z implies X \ Y c= Z & X \ Z c= Y;

theorem :: PBOOLE:83
 (X \/ Y) \ (X /\ Y) = (X \ Y) \/ (Y \ X);

theorem :: PBOOLE:84
 (X \ Y) \ Y = X \ Y;

theorem :: PBOOLE:85
     X \ (Y \/ Z) = (X \ Y) /\ (X \ Z);

theorem :: PBOOLE:86
     X \ Y = Y \ X implies X = Y;

theorem :: PBOOLE:87
     X /\ (Y \ Z) = X /\ Y \ X /\ Z;

theorem :: PBOOLE:88 :: NORMFORM:2
     X \ Y c= Z implies X c= Y \/ Z;

theorem :: PBOOLE:89
     X \ Y c= X \+\ Y;

canceled;

theorem :: PBOOLE:91
     X \+\ [0]I = X & [0]I \+\ X = X;

theorem :: PBOOLE:92
     X \+\ X = [0]I;

canceled;

theorem :: PBOOLE:94
     X \/ Y = (X \+\ Y) \/ X /\ Y;

theorem :: PBOOLE:95
 X \+\ Y = (X \/ Y) \ X /\ Y;

theorem :: PBOOLE:96
     (X \+\ Y) \ Z = (X \ (Y \/ Z)) \/ (Y \ (X \/ Z));

theorem :: PBOOLE:97
     X \ (Y \+\ Z) = X \ (Y \/ Z) \/ X /\ Y /\ Z;

theorem :: PBOOLE:98
 (X \+\ Y) \+\ Z = X \+\ (Y \+\ Z);

theorem :: PBOOLE:99
    X \ Y c= Z & Y \ X c= Z implies X \+\ Y c= Z;

theorem :: PBOOLE:100  :: FINSUB_1:3
 X \/ Y = X \+\ (Y \ X);

theorem :: PBOOLE:101
 X /\ Y = X \+\ (X \ Y);

theorem :: PBOOLE:102  :: FINSUB_1:5
 X \ Y = X \+\ (X /\ Y);

theorem :: PBOOLE:103
 Y \ X = X \+\ (X \/ Y);

theorem :: PBOOLE:104 :: FINSUB_1:4
     X \/ Y = X \+\ Y \+\ X /\ Y;

theorem :: PBOOLE:105 :: FINSUB_1:6
     X /\ Y = X \+\ Y \+\ (X \/ Y);

begin :: Meeting and overlap(p?)ing

theorem :: PBOOLE:106
     X overlaps Y or X overlaps Z implies X overlaps Y \/ Z;

canceled;

theorem :: PBOOLE:108
 X overlaps Y & Y c= Z implies X overlaps Z;

theorem :: PBOOLE:109
 X overlaps Y & X c= Z implies Z overlaps Y;

theorem :: PBOOLE:110  :: NORMFORM:1
 X c= Y & Z c= V & X overlaps Z implies Y overlaps V;

theorem :: PBOOLE:111
     X overlaps Y /\ Z implies X overlaps Y & X overlaps Z;

theorem :: PBOOLE:112 :: BORSUK_1:1
     X overlaps Z & X c= V implies X overlaps Z /\ V;

theorem :: PBOOLE:113
     X overlaps Y \ Z implies X overlaps Y;

theorem :: PBOOLE:114 :: PROB_2:7, RPR_1:36
     Y does_not_overlap Z implies X /\ Y does_not_overlap X /\ Z;

theorem :: PBOOLE:115 :: AMI_2:1
     X overlaps Y \ Z implies Y overlaps X \ Z;

theorem :: PBOOLE:116
 X meets Y & Y c= Z implies X meets Z;

canceled;

theorem :: PBOOLE:118
 Y misses X \ Y;

theorem :: PBOOLE:119
     X /\ Y misses X \ Y;

theorem :: PBOOLE:120
     X /\ Y misses X \+\ Y;

theorem :: PBOOLE:121
 X misses Y implies X /\ Y = [0]I;

theorem :: PBOOLE:122
     X <> [0]I implies X meets X;

theorem :: PBOOLE:123
     X c= Y & X c= Z & Y misses Z implies X = [0]I;

theorem :: PBOOLE:124  :: SETWISEO:9
     Z \/ V = X \/ Y & X misses Z & Y misses V
  implies X = V & Y = Z;

canceled;

theorem :: PBOOLE:126  :: FINSUB_1:1
 X misses Y implies X \ Y = X;

theorem :: PBOOLE:127 :: FINSUB_1:2
     X misses Y implies (X \/ Y) \ Y = X;

theorem :: PBOOLE:128 :: RPR_1:32
     X \ Y = X implies X misses Y;

theorem :: PBOOLE:129 :: RLVECT_2:102
     X \ Y misses Y \ X;

begin :: Roughly speaking

definition let I,X,Y;
 pred X [= Y means
:: PBOOLE:def 14
 for x st x in X holds x in Y;
 reflexivity;
end;

theorem :: PBOOLE:130
     X c= Y implies X [= Y;

canceled;

theorem :: PBOOLE:132
     X [= Y & Y [= Z implies X [= Z;

begin :: Non empty set of sorts

theorem :: PBOOLE:133
     [0]{} in [0]{};

theorem :: PBOOLE:134
     for X being ManySortedSet of {} holds X = {};

reserve I for non empty set,
        x,X,Y for ManySortedSet of I;

theorem :: PBOOLE:135
     X overlaps Y implies X meets Y;

theorem :: PBOOLE:136
 not ex x st x in [0]I;

theorem :: PBOOLE:137
      x in X & x in Y implies X /\ Y <> [0]I;

theorem :: PBOOLE:138
     X does_not_overlap [0]I & [0]I does_not_overlap X;

theorem :: PBOOLE:139
 X /\ Y = [0]I implies X does_not_overlap Y;

theorem :: PBOOLE:140
     X overlaps X implies X <> [0]I;

begin :: Empty and non-empty ManySortedSets

reserve I for set,
        x,X,Y,Z for ManySortedSet of I;

definition let I be set;
 let X be ManySortedSet of I;
 redefine attr X is empty-yielding means
:: PBOOLE:def 15
 for i st i in I holds X.i is empty;
 attr X is non-empty means
:: PBOOLE:def 16
 for i st i in I holds X.i is non empty;
end;

registration let I be set;
 cluster empty-yielding ManySortedSet of I;
 cluster non-empty ManySortedSet of I;
end;

registration let I be non empty set;
 cluster non-empty -> non empty-yielding ManySortedSet of I;
 cluster empty-yielding -> non non-empty ManySortedSet of I;
end;

theorem :: PBOOLE:141
     X is empty-yielding iff X = [0]I;

theorem :: PBOOLE:142
     Y is empty-yielding & X c= Y implies X is empty-yielding;

theorem :: PBOOLE:143
 X is non-empty & X c= Y implies Y is non-empty;

theorem :: PBOOLE:144
 X is non-empty & X [= Y implies X c= Y;

theorem :: PBOOLE:145
     X is non-empty & X [= Y implies Y is non-empty;

reserve X for non-empty ManySortedSet of I;

theorem :: PBOOLE:146
     ex x st x in X;

theorem :: PBOOLE:147
 (for x holds x in X iff x in Y) implies X = Y;

theorem :: PBOOLE:148
      (for x holds x in X iff x in Y & x in Z) implies X = Y /\ Z;

begin :: Addenda

:: from MSUALG_1

scheme :: PBOOLE:sch 3
 MSSEx { I() -> set, P[set,set] }:
 ex f being ManySortedSet of I() st
  for i st i in I() holds P[i,f.i]
  provided  for i st i in I() ex j st P[i,j];

scheme :: PBOOLE:sch 4
 MSSLambda { I() -> set, F(set) -> set }:
 ex f being ManySortedSet of I() st
  for i st i in I() holds f.i = F(i);

:: from PRALG_1

registration
 let I be set;
 cluster Function-yielding ManySortedSet of I;
 end;

definition
 let I be set;
mode ManySortedFunction of I is Function-yielding ManySortedSet of I;
end;

:: from MSUALG_1

begin :: Preliminaries

reserve i,j for set,
        I for set;

theorem :: PBOOLE:149
 not ex M being non-empty ManySortedSet of I st {} in rng M;

definition let I be set; let M be ManySortedSet of I;
 mode Component of M is Element of rng M;
end;

theorem :: PBOOLE:150
  for I being non empty set
 for M being ManySortedSet of I, A being Component of M
  ex i st i in I & A = M.i;

theorem :: PBOOLE:151
  for M being ManySortedSet of I, i st i in I holds M.i is Component of M;

definition let I; let B be ManySortedSet of I;
 mode Element of B -> ManySortedSet of I means
:: PBOOLE:def 17
     for i st i in I holds it.i is Element of B.i;
end;

begin :: Many Sorted Functions

definition let I;
 let A be ManySortedSet of I, B be ManySortedSet of I;
 mode ManySortedFunction of A,B -> ManySortedSet of I means
:: PBOOLE:def 18
 for i st i in I holds it.i is Function of A.i, B.i;
end;

registration let I;
 let A be ManySortedSet of I, B be ManySortedSet of I;
 cluster ->Function-yielding ManySortedFunction of A,B;
end;

definition let I be set; let M be ManySortedSet of I;
 func M# -> ManySortedSet of I* means
:: PBOOLE:def 19
 for i being Element of I* holds it.i = product(M*i);
end;

registration let I be set; let M be non-empty ManySortedSet of I;
 cluster M# -> non-empty;
end;

definition let I; let J be non empty set;
 let O be Function of I,J;
 let F be ManySortedSet of J;
 redefine func F*O -> ManySortedSet of I;
end;

definition let a be set;
 func *-->a -> Function of NAT,{a}* means
:: PBOOLE:def 20
 for n being Element of NAT holds it.n = n |-> a;
end;

 reserve D for non empty set,
         n for Element of NAT;

theorem :: PBOOLE:152
 for a,b being set holds ({a} --> b)*(n|->a) = n |-> b;

theorem :: PBOOLE:153
  for a being set
 for M being ManySortedSet of {a} st M = {a} --> D
   holds (M#* *-->a).n = Funcs(Seg n, D);

definition let I,i;
 redefine func I --> i -> Function of I,{i};
end;

:: from PRALG_2

scheme :: PBOOLE:sch 5
 LambdaDMS {D()->non empty set, F(set)->set}:
 ex X be ManySortedSet of D() st
  for d be Element of D() holds X.d = F(d);

:: from PRALG_1

registration
let J be non empty set,
    B be non-empty ManySortedSet of J,
    j be Element of J;
 cluster B.j -> non empty;
end;

:: from PRALG_2

reserve X,Y for ManySortedSet of I;

definition
 let I, X,Y;
func [|X,Y|] -> ManySortedSet of I means
:: PBOOLE:def 21
  for i st i in I holds it.i = [:X.i,Y.i:];
end;

:: from AUTALG_1

definition let I, X, Y;
  func MSFuncs (X, Y) -> ManySortedSet of I means
:: PBOOLE:def 22
   for i be set st i in I holds it.i = Funcs(X.i, Y.i);
end;

:: from MSUALG_2

definition let I be set,
               M be ManySortedSet of I;
mode ManySortedSubset of M -> ManySortedSet of I means
:: PBOOLE:def 23
 it c= M;
end;

registration let I be set,
               M be non-empty ManySortedSet of I;
cluster non-empty ManySortedSubset of M;
end;

:: from MSUALG_3

definition
 let F,G be Function-yielding Function;
 func G**F -> Function-yielding Function means
:: PBOOLE:def 24
  dom it = (dom F) /\ (dom G) &
 for i be set st i in dom it holds it.i = (G.i)*(F.i);
end;

definition let I be set,
               A be ManySortedSet of I,
               F be ManySortedFunction of I;
func F.:.:A -> ManySortedSet of I means
:: PBOOLE:def 25
    for i be set st i in I holds it.i = (F.i).:(A.i);
end;

:: missing, 2005.11.13, A.T.

registration let I;
 cluster [0]I -> empty-yielding;
end;

