:: The Product of the Families of the Groups
::  by Artur Korni{\l}owicz
::
:: Received June 10, 1998
:: Copyright (c) 1998 Association of Mizar Users

environ

 vocabulary FINSEQ_1, FUNCT_1, PBOOLE, RELAT_1, VECTSP_1, PRALG_1, RLVECT_2,
      ZF_REFLE, CARD_3, TARSKI, BINOP_1, GROUP_1, REALSET1, BOOLE, SEMI_AF1,
      GROUP_2, FINSET_1, FUNCT_4, GROUP_6, WELLORD1, GROUP_7;
 notation TARSKI, XBOOLE_0, ENUMSET1, ZFMISC_1, SUBSET_1, RELAT_1, FUNCT_1,
      PARTFUN1, XREAL_0, NAT_1, FINSEQ_1, FUNCT_2, FUNCT_4, FINSET_1, BINOP_1,
      STRUCT_0, VECTSP_1, GROUP_1, GROUP_2, GROUP_6, PBOOLE, CARD_3, PRALG_1,
      PRALG_2;
 constructors BINOP_1, GROUP_6, PRALG_2, ENUMSET1, XCMPLX_0, MEMBERED;
 clusters STRUCT_0, PRALG_2, GROUP_1, FINSET_1, RELAT_1, GROUP_2, FINSEQ_1,
      MOD_2, RELSET_1, ARYTM_3, MEMBERED;
 requirements NUMERALS, BOOLE, SUBSET;


begin  :: Preliminaries

reserve a, b, c, d, e, f for set;

theorem :: GROUP_7:1
 <*a*> = <*b*> implies a = b;

theorem :: GROUP_7:2
   <*a,b*> = <*c,d*> implies a = c & b = d;

theorem :: GROUP_7:3
   <*a,b,c*> = <*d,e,f*> implies a = d & b = e & c = f;


begin  :: The product of the families of the groups

reserve i, I for set,
        f, g, h for Function,
        s for ManySortedSet of I;

definition let R be Relation;
 attr R is HGrStr-yielding means
:: GROUP_7:def 1
  for y being set st y in rng R holds y is non empty HGrStr;
end;


registration
 cluster HGrStr-yielding -> 1-sorted-yielding Function;
coherence
  proof
    let f be Function such that
A1:   f is HGrStr-yielding;
    let x be set;
    assume x in dom f;
    then f.x in rng f by FUNCT_1:def 5;
    hence f.x is 1-sorted by A1,Def1;
  end;
end;


registration let I be set;
 cluster HGrStr-yielding ManySortedSet of I;
existence
  proof
    consider H being non empty HGrStr;
    deffunc F(set) = H;
    consider f being ManySortedSet of I such that
A1:   for i being set st i in I holds f.i = F(i) from MSUALG_1:sch 2;
    take f;
    let a be set;
    assume a in rng f;
then A2: ex x being set st x in dom f & a = f.x by FUNCT_1:def 5;
      dom f = I by PBOOLE:def 3;
    hence a is non empty HGrStr by A1,A2;
  end;
end;


registration
 cluster HGrStr-yielding Function;
existence
  proof
    consider I being set, f being HGrStr-yielding ManySortedSet of I;
    take f;
    thus thesis;
  end;
end;


definition let I be set;
 mode HGrStr-Family of I is HGrStr-yielding ManySortedSet of I;
end;


definition let I be non empty set,
               F be HGrStr-Family of I,
               i be Element of I;
 redefine func F.i -> non empty HGrStr;
end;


registration let I be set, F be HGrStr-Family of I;
 cluster Carrier F -> non-empty;
coherence
  proof
    let i be set; assume
A1:   i in I;
then A2: ex R being 1-sorted st R = F.i & (Carrier F).i = the carrier of R
      by PRALG_1:def 13;
      dom F = I by PBOOLE:def 3;
    then F.i in rng F by A1,FUNCT_1:def 5;
    then F.i is non empty HGrStr by Def1;
    hence thesis by A2,STRUCT_0:def 1;
  end;
end;

definition let I be set,
               F be HGrStr-Family of I;
 func product F -> strict HGrStr means
:: GROUP_7:def 2
  the carrier of it = product Carrier F &
  for f, g being Element of product Carrier F, i being set st i in I
   ex Fi being non empty HGrStr, h being Function st
    Fi = F.i & h = (the mult of it).(f,g) &
   h.i = (the mult of Fi).(f.i,g.i);
end;


registration let I be set, F be HGrStr-Family of I;
 cluster product F -> non empty;
coherence
  proof
      the carrier of product F = product Carrier F by Def2;
    hence the carrier of product F is non empty;
  end;
end;


registration let I be set, F be HGrStr-Family of I;
 cluster -> Function-like Relation-like Element of product F;
coherence
  proof
    let x be Element of product F;
    reconsider y = x as Element of product Carrier F by Def2;
      y is Function;
    hence thesis;
  end;
end;


registration let I be set,
               F be HGrStr-Family of I,
               f, g be Element of product Carrier F;
 cluster (the mult of product F).(f,g) -> Function-like Relation-like;
coherence
  proof
    set A = product Carrier F;
A1: the carrier of product F = product Carrier F by Def2;
    then [f,g] in [:the carrier of product F, the carrier of product F:]
      by ZFMISC_1:106;
    then (the mult of product F).[f,g] is Element of A by A1,FUNCT_2:7;
    then reconsider h = (the mult of product F).(f,g) as Element of A
      by BINOP_1:def 1;
      h is Function;
    hence thesis;
  end;
end;


theorem :: GROUP_7:4
 for F being HGrStr-Family of I, G being non empty HGrStr,
     p, q being Element of product F,
     x, y being Element of G st
   i in I & G = F.i & f = p & g = q & h = p * q & f.i = x & g.i = y holds
  x * y = h.i;

definition let I be set, F be HGrStr-Family of I;
 attr F is Group-like means
:: GROUP_7:def 3
  for i being set st i in I ex Fi being Group-like (non empty HGrStr)
   st Fi = F.i;
 attr F is associative means
:: GROUP_7:def 4
  for i being set st i in I ex Fi being associative (non empty HGrStr)
   st Fi = F.i;
 attr F is commutative means
:: GROUP_7:def 5
  for i being set st i in I ex Fi being commutative (non empty HGrStr)
   st Fi = F.i;
end;


definition let I be non empty set, F be HGrStr-Family of I;
 redefine attr F is Group-like means
:: GROUP_7:def 6
  for i being Element of I holds F.i is Group-like;
 redefine attr F is associative means
:: GROUP_7:def 7
  for i being Element of I holds F.i is associative;
 redefine attr F is commutative means
:: GROUP_7:def 8
    for i being Element of I holds F.i is commutative;
end;


registration let I be set;
 cluster Group-like associative
         commutative HGrStr-Family of I;
existence
  proof
    consider H being commutative Group;
    deffunc F(set) = H;
    consider f being ManySortedSet of I such that
A1:   for i being set st i in I holds f.i = F(i) from MSUALG_1:sch 2;
      f is HGrStr-yielding
    proof
      let i be set;
      assume i in rng f;
then A2:   ex x being set st x in dom f & i = f.x by FUNCT_1:def 5;
        dom f = I by PBOOLE:def 3;
      hence i is non empty HGrStr by A1,A2;
    end;
    then reconsider f as HGrStr-Family of I;
    take f;
    hereby
      let i be set; assume
A3:     i in I;
      then reconsider I1 = I as non empty set;
      reconsider i1 = i as Element of I1 by A3;
      reconsider F1 = f as HGrStr-Family of I1;
      reconsider Fi = F1.i1 as Group-like (non empty HGrStr) by A1;
      take Fi;
      thus Fi = f.i;
    end;
    hereby
      let i be set; assume
A4:     i in I;
      then reconsider I1 = I as non empty set;
      reconsider i1 = i as Element of I1 by A4;
      reconsider F1 = f as HGrStr-Family of I1;
      reconsider Fi = F1.i1 as associative (non empty HGrStr) by A1;
      take Fi;
      thus Fi = f.i;
    end;
    let i be set; assume
A5:   i in I;
    then reconsider I1 = I as non empty set;
    reconsider i1 = i as Element of I1 by A5;
    reconsider F1 = f as HGrStr-Family of I1;
    reconsider Fi = F1.i1 as commutative (non empty HGrStr) by A1;
    take Fi;
    thus Fi = f.i;
  end;
end;


registration let I be set, F be Group-like HGrStr-Family of I;
 cluster product F -> Group-like;
coherence
  proof
    set G = product F;
defpred P[set,set] means
 ex Fi being non empty HGrStr,
    e being Element of Fi st Fi = F.$1 & $2 = e &
   for h being Element of Fi holds h * e = h & e * h = h &
    ex g being Element of Fi st h * g = e & g * h = e;
A1: dom Carrier F = I by PBOOLE:def 3;
A2: for i being set st i in I ex y being set st
     y in union rng Carrier F & P[i,y]
    proof
      let i be set; assume
A3:     i in I;
     then reconsider I1 = I as non empty set;
     reconsider i1 = i as Element of I1 by A3;
     reconsider F1 = F as Group-like HGrStr-Family of I1;
       F1.i1 is Group-like by Def6;
     then consider e being Element of F1.i1 such that
A4:    for h being Element of F1.i1 holds
         h * e = h & e * h = h &
         ex g being Element of F1.i1 st h * g = e & g * h = e
      by GROUP_1:def 3;
     take e;
A5:  ex R being 1-sorted st R = F.i1 & (Carrier F1).i1 = the carrier of R
       by PRALG_1:def 13;
       (Carrier F).i1 in rng Carrier F by A1,FUNCT_1:def 5;
     hence e in union rng Carrier F by A5,TARSKI:def 4;
     take F1.i1, e;
     thus F1.i1 = F.i & e = e;
     let h be Element of F1.i1;
     thus thesis by A4;
    end;
    consider ee being Function such that
A6:   dom ee = I and rng ee c= union rng Carrier F and
A7:   for x being set st x in I holds P[x,ee.x] from COMPTS_1:sch 1(A2);
      now
      let i be set; assume
A8:    i in dom ee;
      then consider Fi being non empty HGrStr,
               e being Element of Fi such that
A9:    Fi = F.i & ee.i = e &
       for h being Element of Fi holds h * e = h & e * h = h &
        ex g being Element of Fi st h * g = e & g * h = e
         by A6,A7;
    ex R being 1-sorted st R = F.i & (Carrier F).i = the carrier of R
        by A6,A8,PRALG_1:def 13;
      hence ee.i in (Carrier F).i by A9;
    end;
then A10:ee in product Carrier F by A1,A6,CARD_3:18;
    then reconsider e1 = ee as Element of G by Def2;
    take e1;
    let h be Element of G;
    reconsider h1 = h as Element of product Carrier F by Def2;
    reconsider he = (the mult of G).(h,e1), eh = (the mult of G).(e1,h)
      as Element of product Carrier F by Def2;
A11:dom he = I & dom eh = I & dom h1 = I by A1,CARD_3:18;
      now
      let i be set; assume
A12:     i in I;
then A13:  ex Gi being non empty HGrStr, f being Function st
        Gi = F.i & f = (the mult of G).(h1,e1) &
        f.i = (the mult of Gi).(h1.i,ee.i) by A10,Def2;
      consider Fi being non empty HGrStr,
               e2 being Element of Fi such that
A14:   Fi = F.i & ee.i = e2 &
       for h being Element of Fi holds h * e2 = h & e2 * h = h &
        ex g being Element of Fi st h * g = e2 & g * h = e2
         by A7,A12;
      reconsider h2 = h1.i as Element of Fi by A12,A14,Lm1;
        h2 * e2 = h2 by A14;
      hence he.i = h1.i by A13,A14,VECTSP_1:def 10;
    end;
    then he = h by A11,FUNCT_1:9;
    hence h * e1 = h by VECTSP_1:def 10;
      now
      let i be set; assume
A15:    i in I;
then A16:  ex Gi being non empty HGrStr, f being Function st
        Gi = F.i & f = (the mult of G).(e1,h1) &
        f.i = (the mult of Gi).(ee.i,h1.i) by A10,Def2;
      consider Fi being non empty HGrStr,
               e2 being Element of Fi such that
A17:   Fi = F.i & ee.i = e2 &
       for h being Element of Fi holds h * e2 = h & e2 * h = h &
        ex g being Element of Fi st h * g = e2 & g * h = e2
         by A7,A15;
      reconsider h2 = h1.i as Element of Fi by A15,A17,Lm1;
        e2 * h2 = h2 by A17;
      hence eh.i = h1.i by A16,A17,VECTSP_1:def 10;
    end;
    then eh = h by A11,FUNCT_1:9;
    hence e1 * h = h by VECTSP_1:def 10;
defpred R[set,set] means
 ex Fi being non empty HGrStr,
    hi being Element of Fi st Fi = F.$1 & hi = h1.$1 &
  ex g being Element of Fi st hi * g = ee.$1 & g * hi = ee.$1
     & $2 = g;
A18:for i being set st i in I ex y being set st
     y in union rng Carrier F & R[i,y]
    proof
      let i be set; assume
A19:    i in I;
      then consider Fi being non empty HGrStr,
               e being Element of Fi such that
A20:    Fi = F.i & ee.i = e and
A21:    for h being Element of Fi holds h * e = h & e * h = h &
         ex g being Element of Fi st h * g = e & g * h = e
          by A7;
      reconsider hi = h1.i as Element of Fi by A19,A20,Lm1;
      consider g being Element of Fi such that
A22:    hi * g = e & g * hi = e by A21;
      take g;
A23:  ex R being 1-sorted st R = F.i & (Carrier F).i = the carrier of R
        by A19,PRALG_1:def 13;
        (Carrier F).i in rng Carrier F by A1,A19,FUNCT_1:def 5;
      hence g in union rng Carrier F by A20,A23,TARSKI:def 4;
      take Fi, hi;
      thus Fi = F.i & hi = h1.i by A20;
      take g;
      thus thesis by A20,A22;
    end;
    consider gg being Function such that
A24:  dom gg = I and rng gg c= union rng Carrier F and
A25:  for x being set st x in I holds R[x,gg.x] from COMPTS_1:sch 1(A18);
      now
      let i be set; assume
A26:    i in dom gg;
then A27:  ex R being 1-sorted st R = F.i & (Carrier F).i = the carrier of R
       by A24,PRALG_1:def 13;
      consider Fi being non empty HGrStr,
               hi being Element of Fi such that
A28:    Fi = F.i & hi = h1.i &
        ex g being Element of Fi
         st hi * g = ee.i & g * hi = ee.i & gg.i = g by A24,A25,A26;
      thus gg.i in (Carrier F).i by A27,A28;
    end;
then A29:gg in product Carrier F by A1,A24,CARD_3:18;
    then reconsider g1 = gg as Element of G by Def2;
    take g1;
    reconsider he = (the mult of G).(h,g1), eh = (the mult of G).(g1,h)
      as Element of product Carrier F by Def2;
A30:dom he = I & dom eh = I by A1,CARD_3:18;
      now
      let i be set; assume
A31:    i in I;
then A32:  ex Fi being non empty HGrStr,
         hi being Element of Fi st
       Fi = F.i & hi = h1.i &
        ex g being Element of Fi st
         hi * g = ee.i & g * hi = ee.i & gg.i = g by A25;
      consider Gi being non empty HGrStr, h5 being Function such that
A33:    Gi = F.i & h5 = (the mult of G).(h1,gg) &
        h5.i = (the mult of Gi).(h1.i,gg.i) by A29,A31,Def2;
      thus he.i = ee.i by A32,A33,VECTSP_1:def 10;
    end;
    then he = ee by A6,A30,FUNCT_1:9;
    hence h * g1 = e1 by VECTSP_1:def 10;
      now
      let i be set; assume
A34:    i in I;
      then consider Fi being non empty HGrStr,
               hi being Element of Fi such that
A35:    Fi = F.i & hi = h1.i &
        ex g being Element of Fi st
         hi * g = ee.i & g * hi = ee.i & gg.i = g by A25;
      consider Gi being non empty HGrStr, h5 being Function such that
A36:    Gi = F.i & h5 = (the mult of G).(gg,h1) &
        h5.i = (the mult of Gi).(gg.i,h1.i) by A29,A34,Def2;
      thus eh.i = ee.i by A35,A36,VECTSP_1:def 10;
    end;
    then eh = ee by A6,A30,FUNCT_1:9;
    hence g1 * h = e1 by VECTSP_1:def 10;
  end;
end;


registration let I be set, F be associative HGrStr-Family of I;
 cluster product F -> associative;
coherence
  proof
    set G = product F;
    let x, y, z be Element of G;
    reconsider x1 = x, y1 = y, z1 = z as Element of product Carrier F by Def2;
    set xy = (the mult of G).(x,y),
        yz = (the mult of G).(y,z),
        s = (the mult of G).(xy,z),
        t = (the mult of G).(x,yz);
    reconsider xy, yz, s, t as Element of product Carrier F by Def2;
      dom Carrier F = I by PBOOLE:def 3;
then A1: dom s = I & dom t = I by CARD_3:18;
A2: now
      let i be set; assume
A3:     i in I;
      then consider XY being non empty HGrStr, hxy being Function such that
A4:     XY = F.i & hxy = (the mult of G).(x,y) &
        hxy.i = (the mult of XY).(x1.i,y1.i) by Def2;
      consider YZ being non empty HGrStr, hyz being Function such that
A5:     YZ = F.i & hyz = (the mult of G).(y,z) &
        hyz.i = (the mult of YZ).(y1.i,z1.i) by A3,Def2;
      consider XY_Z being non empty HGrStr, hxy_z being Function such that
A6:     XY_Z = F.i & hxy_z = (the mult of G).(xy,z) &
        hxy_z.i = (the mult of XY_Z).(xy.i,z1.i) by A3,Def2;
      consider X_YZ being non empty HGrStr, hx_yz being Function such that
A7:     X_YZ = F.i & hx_yz = (the mult of G).(x,yz) &
        hx_yz.i = (the mult of X_YZ).(x1.i,yz.i) by A3,Def2;
     reconsider xi = x1.i, yi = y1.i as Element of XY
       by A3,A4,Lm1;
     reconsider zi = z1.i, xiyi = xi*yi
       as Element of XY_Z by A3,A4,A6,Lm1;
     reconsider xii = xi, yii = yi as Element of XY_Z
       by A4,A6;
     reconsider y3 = y1.i, z3 = zi as Element of YZ
       by A3,A5,Lm1;
A8:  XY_Z is associative by A3,A6,Def7;
     thus s.i = (the mult of XY_Z).(xi*yi,z1.i) by A4,A6,VECTSP_1:def 10
             .= xiyi*zi by VECTSP_1:def 10
             .= xii*(yii*zi) by A4,A6,A8,VECTSP_1:def 16
             .= (the mult of X_YZ).(x1.i,y3*z3) by A5,A6,A7,VECTSP_1:def 10
             .= t.i by A5,A7,VECTSP_1:def 10;
    end;
    thus x*y*z = (the mult of G).(x*y,z) by VECTSP_1:def 10
              .= (the mult of G).((the mult of G).(x,y),z) by VECTSP_1:def 10
              .= (the mult of G).(x,(the mult of G).(y,z)) by A1,A2,FUNCT_1:9
              .= (the mult of G).(x,y*z) by VECTSP_1:def 10
              .= x*(y*z) by VECTSP_1:def 10;
  end;
end;


registration let I be set, F be commutative HGrStr-Family of I;
 cluster product F -> commutative;
coherence
  proof
    set G = product F;
    let x, y be Element of G;
    reconsider x1 = x, y1 = y, xy = (the mult of G).(x,y),
        yx = (the mult of G).(y,x) as Element of product Carrier F by Def2;
      dom Carrier F = I by PBOOLE:def 3;
then A1: dom xy = I & dom yx = I by CARD_3:18;
A2: now
      let i be set; assume
A3:     i in I;
      then consider XY being non empty HGrStr, hxy being Function such that
A4:     XY = F.i & hxy = (the mult of G).(x,y) &
        hxy.i = (the mult of XY).(x1.i,y1.i) by Def2;
      consider YX being non empty HGrStr, hyx being Function such that
A5:     YX = F.i & hyx = (the mult of G).(y,x) &
        hyx.i = (the mult of YX).(y1.i,x1.i) by A3,Def2;
      reconsider xi = x1.i, yi = y1.i as Element of XY
       by A3,A4,Lm1;
      consider Fi being commutative (non empty HGrStr) such that
A6:     Fi = F.i by A3,Def5;
      thus xy.i = xi * yi by A4,VECTSP_1:def 10
               .= yi * xi by A4,A6,VECTSP_1:def 17
               .= yx.i by A4,A5,VECTSP_1:def 10;
    end;
    thus x*y = (the mult of G).(x,y) by VECTSP_1:def 10
            .= (the mult of G).(y,x) by A1,A2,FUNCT_1:9
            .= y*x by VECTSP_1:def 10;
  end;
end;


theorem :: GROUP_7:5
   for F being HGrStr-Family of I, G being non empty HGrStr st
   i in I & G = F.i & product F is Group-like holds
  G is Group-like;

theorem :: GROUP_7:6
   for F being HGrStr-Family of I, G being non empty HGrStr st
   i in I & G = F.i & product F is associative holds
  G is associative;

theorem :: GROUP_7:7
   for F being HGrStr-Family of I, G being non empty HGrStr st
   i in I & G = F.i & product F is commutative holds
  G is commutative;

theorem :: GROUP_7:8
 for F being Group-like HGrStr-Family of I
  st for i being set st i in I ex G being Group-like (non empty HGrStr)
   st G = F.i & s.i = 1.G
 holds s = 1.product F;

theorem :: GROUP_7:9
 for F being Group-like HGrStr-Family of I,
     G being Group-like (non empty HGrStr) st i in I & G = F.i &
   f = 1.product F
 holds f.i = 1.G;

theorem :: GROUP_7:10
 for F being associative Group-like HGrStr-Family of I,
     x being Element of product F
  st x = g & for i being set st i in I
   ex G being Group, y being Element of G st G = F.i & s.i = y"
    & y = g.i
  holds s = x";

theorem :: GROUP_7:11
 for F being associative Group-like HGrStr-Family of I,
     x being Element of product F,
     G being Group, y being Element of G
   st i in I & G = F.i & f = x & g = x" & f.i = y
  holds g.i = y";

definition let I be set,
      F be associative Group-like HGrStr-Family of I;
 func sum F -> strict Subgroup of product F means
:: GROUP_7:def 9
  for x being set holds x in the carrier of it iff
   ex g being Element of product Carrier F,
      J being finite Subset of I, f being ManySortedSet of J st
     g = 1.product F & x = g +* f &
     for j being set st j in J ex G being Group-like (non empty HGrStr) st
      G = F.j & f.j in the carrier of G & f.j <> 1.G;
end;


registration let I be set,
     F be associative Group-like HGrStr-Family of I,
               f, g be Element of sum F;
 cluster (the mult of sum F).(f,g) -> Function-like Relation-like;
coherence
  proof
A1: the carrier of sum F c= the carrier of product F by GROUP_2:def 5;
      (the mult of sum F).(f,g) in the carrier of sum F;
    then reconsider h = (the mult of sum F).(f,g) as Element of product Carrier
F
     by A1,Def2;
      h is Function;
    hence thesis;
  end;
end;


theorem :: GROUP_7:12
   for I being finite set,
     F being associative Group-like HGrStr-Family of I
   holds product F = sum F;


begin  :: The product of one, two and three groups

theorem :: GROUP_7:13
 for G1 being non empty HGrStr holds <*G1*> is HGrStr-Family of {1};

definition let G1 be non empty HGrStr;
 redefine func <*G1*> -> HGrStr-Family of {1};
end;


theorem :: GROUP_7:14
 for G1 being Group-like (non empty HGrStr) holds
  <*G1*> is Group-like HGrStr-Family of {1};

definition let G1 be Group-like (non empty HGrStr);
 redefine func <*G1*> -> Group-like HGrStr-Family of {1};
end;


theorem :: GROUP_7:15
 for G1 being associative (non empty HGrStr) holds
  <*G1*> is associative HGrStr-Family of {1};

definition let G1 be associative (non empty HGrStr);
 redefine func <*G1*> -> associative HGrStr-Family of {1};
end;


theorem :: GROUP_7:16
 for G1 being commutative (non empty HGrStr) holds
  <*G1*> is commutative HGrStr-Family of {1};

definition let G1 be commutative (non empty HGrStr);
 redefine func <*G1*> -> commutative HGrStr-Family of {1};
end;


theorem :: GROUP_7:17
 for G1 being Group holds
  <*G1*> is Group-like associative HGrStr-Family of {1};

definition let G1 be Group;
 redefine func <*G1*> -> Group-like associative HGrStr-Family of {1};
end;


theorem :: GROUP_7:18
 for G1 being commutative Group holds
  <*G1*> is commutative Group-like associative HGrStr-Family of {1};

definition let G1 be commutative Group;
 redefine func <*G1*> ->
                    Group-like associative commutative HGrStr-Family of {1};
end;


registration let G1 be non empty HGrStr;
 cluster -> FinSequence-like Element of product Carrier <*G1*>;
coherence
 proof
    let x be Element of product Carrier <*G1*>;
    take 1;
    thus dom x = dom Carrier <*G1*> by CARD_3:18
              .= Seg 1 by FINSEQ_1:4,PBOOLE:def 3;
  end;
end;


registration let G1 be non empty HGrStr;
 cluster -> FinSequence-like Element of product <*G1*>;
coherence
 proof
    let x be Element of product <*G1*>;
    reconsider y = x as Element of product Carrier <*G1*> by Def2;
      y is FinSequence-like;
    hence thesis;
  end;
end;


definition let G1 be non empty HGrStr,
               x be Element of G1;
 redefine func <*x*> -> Element of product <*G1*>;
end;


theorem :: GROUP_7:19
 for G1, G2 being non empty HGrStr holds <*G1,G2*> is HGrStr-Family of {1,2};

definition let G1, G2 be non empty HGrStr;
 redefine func <*G1,G2*> -> HGrStr-Family of {1,2};
end;


theorem :: GROUP_7:20
 for G1, G2 being Group-like (non empty HGrStr) holds
  <*G1,G2*> is Group-like HGrStr-Family of {1,2};

definition let G1, G2 be Group-like (non empty HGrStr);
 redefine func <*G1,G2*> -> Group-like HGrStr-Family of {1,2};
end;


theorem :: GROUP_7:21
 for G1, G2 being associative (non empty HGrStr) holds
  <*G1,G2*> is associative HGrStr-Family of {1,2};

definition let G1, G2 be associative (non empty HGrStr);
 redefine func <*G1,G2*> -> associative HGrStr-Family of {1,2};
end;


theorem :: GROUP_7:22
 for G1, G2 being commutative (non empty HGrStr) holds
  <*G1,G2*> is commutative HGrStr-Family of {1,2};

definition let G1, G2 be commutative (non empty HGrStr);
 redefine func <*G1,G2*> -> commutative HGrStr-Family of {1,2};
end;


theorem :: GROUP_7:23
 for G1, G2 being Group holds
  <*G1,G2*> is Group-like associative HGrStr-Family of {1,2};

definition let G1, G2 be Group;
 redefine func <*G1,G2*> -> Group-like associative HGrStr-Family of {1,2};
end;


theorem :: GROUP_7:24
 for G1, G2 being commutative Group holds
  <*G1,G2*> is Group-like associative commutative HGrStr-Family of {1,2};

definition let G1, G2 be commutative Group;
 redefine func <*G1,G2*> ->
                   Group-like associative commutative HGrStr-Family of {1,2};
end;


registration let G1, G2 be non empty HGrStr;
 cluster -> FinSequence-like Element of product Carrier <*G1,G2*>;
coherence
  proof
    let x be Element of product Carrier <*G1,G2*>;
    take 2;
    thus dom x = dom Carrier <*G1,G2*> by CARD_3:18
              .= Seg 2 by FINSEQ_1:4,PBOOLE:def 3;
  end;
end;


registration let G1, G2 be non empty HGrStr;
 cluster -> FinSequence-like Element of product <*G1,G2*>;
coherence
  proof
    let x be Element of product <*G1,G2*>;
    reconsider y = x as Element of product Carrier <*G1,G2*> by Def2;
      y is FinSequence-like;
    hence thesis;
  end;
end;


definition let G1, G2 be non empty HGrStr,
               x be Element of G1,
               y be Element of G2;
 redefine func <*x,y*> -> Element of product <*G1,G2*>;
end;


theorem :: GROUP_7:25
 for G1, G2, G3 being non empty HGrStr holds
  <*G1,G2,G3*> is HGrStr-Family of {1,2,3};

definition let G1, G2, G3 be non empty HGrStr;
 redefine func <*G1,G2,G3*> -> HGrStr-Family of {1,2,3};
end;


theorem :: GROUP_7:26
 for G1, G2, G3 being Group-like (non empty HGrStr) holds
  <*G1,G2,G3*> is Group-like HGrStr-Family of {1,2,3};

definition let G1, G2, G3 be Group-like (non empty HGrStr);
 redefine func <*G1,G2,G3*> -> Group-like HGrStr-Family of {1,2,3};
end;


theorem :: GROUP_7:27
 for G1, G2, G3 being associative (non empty HGrStr) holds
  <*G1,G2,G3*> is associative HGrStr-Family of {1,2,3};

definition let G1, G2, G3 be associative (non empty HGrStr);
 redefine func <*G1,G2,G3*> -> associative HGrStr-Family of {1,2,3};
end;


theorem :: GROUP_7:28
 for G1, G2, G3 being commutative (non empty HGrStr) holds
  <*G1,G2,G3*> is commutative HGrStr-Family of {1,2,3};

definition let G1, G2, G3 be commutative (non empty HGrStr);
 redefine func <*G1,G2,G3*> -> commutative HGrStr-Family of {1,2,3};
end;


theorem :: GROUP_7:29
 for G1, G2, G3 being Group holds
  <*G1,G2,G3*> is Group-like associative HGrStr-Family of {1,2,3};

definition let G1, G2, G3 be Group;
 redefine func <*G1,G2,G3*> -> Group-like associative HGrStr-Family of {1,2,3};
end;


theorem :: GROUP_7:30
 for G1, G2, G3 being commutative Group holds
  <*G1,G2,G3*> is Group-like associative commutative HGrStr-Family of {1,2,3};

definition let G1, G2, G3 be commutative Group;
 redefine func <*G1,G2,G3*> ->
                 Group-like associative commutative HGrStr-Family of {1,2,3};
end;


registration let G1, G2, G3 be non empty HGrStr;
 cluster -> FinSequence-like Element of product Carrier <*G1,G2,G3*>;
coherence
  proof
    let x be Element of product Carrier <*G1,G2,G3*>;
    take 3;
    thus dom x = dom Carrier <*G1,G2,G3*> by CARD_3:18
              .= Seg 3 by FINSEQ_3:1,PBOOLE:def 3;
  end;
end;


registration let G1, G2, G3 be non empty HGrStr;
 cluster -> FinSequence-like Element of product <*G1,G2,G3*>;
coherence
  proof
    let x be Element of product <*G1,G2,G3*>;
    reconsider y = x as Element of product Carrier <*G1,G2,G3*> by Def2;
      y is FinSequence-like;
    hence thesis;
  end;
end;


definition let G1, G2, G3 be non empty HGrStr,
               x be Element of G1,
               y be Element of G2,
               z be Element of G3;
 redefine func <*x,y,z*> -> Element of product <*G1,G2,G3*>;
end;


reserve G1, G2, G3 for non empty HGrStr,
        x1, x2 for Element of G1,
        y1, y2 for Element of G2,
        z1, z2 for Element of G3;

theorem :: GROUP_7:31
 <*x1*> * <*x2*> = <*x1*x2*>;

theorem :: GROUP_7:32
   <*x1,y1*> * <*x2,y2*> = <*x1*x2,y1*y2*>;

theorem :: GROUP_7:33
   <*x1,y1,z1*> * <*x2,y2,z2*> = <*x1*x2,y1*y2,z1*z2*>;

reserve G1, G2, G3 for Group-like (non empty HGrStr);

theorem :: GROUP_7:34
   1.product <*G1*> = <*1.G1*>;

theorem :: GROUP_7:35
   1.product <*G1,G2*> = <*1.G1,1.G2*>;

theorem :: GROUP_7:36
   1.product <*G1,G2,G3*> = <*1.G1,1.G2,1.G3*>;

reserve G1, G2, G3 for Group,
        x for Element of G1,
        y for Element of G2,
        z for Element of G3;

theorem :: GROUP_7:37
   (<*x*> qua Element of product <*G1*>)" = <*x"*>;

theorem :: GROUP_7:38
   (<*x,y*> qua Element of product <*G1,G2*>)" = <*x",y"*>;

theorem :: GROUP_7:39
   (<*x,y,z*> qua Element of product <*G1,G2,G3*>)" = <*x",y",z"
*>;

theorem :: GROUP_7:40
 for f being Function of the carrier of G1, the carrier of product <*G1*> st
  for x being Element of G1 holds f.x = <*x*> holds
   f is Homomorphism of G1, product <*G1*>;

theorem :: GROUP_7:41
 for f being Homomorphism of G1, product <*G1*> st
  for x being Element of G1 holds f.x = <*x*> holds
   f is_isomorphism;

theorem :: GROUP_7:42
   G1, product <*G1*> are_isomorphic;
