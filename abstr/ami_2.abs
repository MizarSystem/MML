:: On a Mathematical Model of Programs
::  by Yatsuka Nakamura and Andrzej Trybulec
::
:: Received December 29, 1992
:: Copyright (c) 1992 Association of Mizar Users

environ

 vocabularies GR_CY_1, TARSKI, INT_1, BOOLE, FINSEQ_1, NAT_1, FUNCT_1, CARD_3,
      RELAT_1, AMI_1, FUNCT_4, CAT_1, MCART_1, ARYTM_1, CQC_LANG, FUNCT_2,
      FUNCT_5, AMI_2, FINSEQ_4, ARYTM, ORDINAL2, ORDINAL1;
 notations TARSKI, XBOOLE_0, ENUMSET1, ZFMISC_1, SUBSET_1, ORDINAL1, NUMBERS,
      XCMPLX_0, CARD_1, CARD_3, RELAT_1, FUNCT_1, PARTFUN1, FUNCT_2, XXREAL_0,
      BINOP_1, DOMAIN_1, INT_1, NAT_1, FUNCOP_1, FRAENKEL, FUNCT_4, CAT_2,
      FINSEQ_1, FINSEQ_4;
 constructors DOMAIN_1, XXREAL_0, NAT_D, FINSEQ_4, CAT_2, CARD_3, ABIAN,
      SETFAM_1;
 registrations XBOOLE_0, SUBSET_1, SETFAM_1, ORDINAL1, FUNCOP_1, FRAENKEL,
      NUMBERS, XXREAL_0, XREAL_0, INT_1, FINSEQ_1, CARD_3, AFINSQ_1, RELAT_1,
      FINSET_1, ORDINAL2, CARD_1;
 requirements NUMERALS, REAL, SUBSET, BOOLE;


begin :: A small concrete machine

reserve x,y,z for set;
reserve i,j,k for Element of NAT;

notation
  synonym SCM-Halt for {};
end;

definition
  redefine func SCM-Halt -> Element of Segm 9;
end;

definition
  func SCM-Data-Loc equals
:: AMI_2:def 1

  [:{1},NAT:];
end;

definition
  canceled;
  func SCM-Memory equals
:: AMI_2:def 3

  {NAT} \/ SCM-Data-Loc \/ NAT;
end;

registration
  cluster SCM-Memory -> non empty;
end;

definition
  redefine func SCM-Data-Loc -> Subset of SCM-Memory;
  redefine func NAT -> Subset of SCM-Memory;
end;

registration
  cluster SCM-Data-Loc -> non empty;
end;

reserve I,J,K for Element of Segm 9,
  a,a1,a2 for Element of NAT,
  b,b1,b2,c,c1 for Element of SCM-Data-Loc;

definition
  func SCM-Instr -> Subset of [: NAT, (union {INT} \/ SCM-Memory)* :] equals
:: AMI_2:def 4
  { [SCM-Halt,{}] } \/ { [J,<*a*>] : J = 6 } \/
  { [K,<*a1,b1*>] : K in { 7,8 } } \/ { [I,<*b,c*>] : I in { 1,2,3,4,5} };
end;

canceled;

theorem :: AMI_2:2
  [0,{}] in SCM-Instr;

registration
  cluster SCM-Instr -> non empty;
end;

theorem :: AMI_2:3
  [6,<*a2*>] in SCM-Instr;

theorem :: AMI_2:4
  x in { 7, 8 } implies [x,<*a2,b2*>] in SCM-Instr;

theorem :: AMI_2:5
  x in { 1,2,3,4,5} implies [x,<*b1,c1*>] in SCM-Instr;

definition
  func SCM-OK -> Function of SCM-Memory, {INT} \/ { SCM-Instr, NAT }
  means
:: AMI_2:def 5

  for k being Element of SCM-Memory holds
  (k = NAT implies it.k = NAT) &
  (k in SCM-Data-Loc implies it.k = INT) &
  (k in NAT implies it.k = SCM-Instr);
end;

theorem :: AMI_2:6
  SCM-Instr <> INT & NAT <> SCM-Instr;

theorem :: AMI_2:7
  for i being Element of SCM-Memory holds SCM-OK.i = NAT iff i = NAT;

theorem :: AMI_2:8
  for i being Element of SCM-Memory holds SCM-OK.i = INT iff i in SCM-Data-Loc;

theorem :: AMI_2:9
  for i being Element of SCM-Memory
  holds SCM-OK.i = SCM-Instr iff i in NAT;

definition
  mode SCM-State is Element of product SCM-OK;
end;

theorem :: AMI_2:10
  for a being Element of SCM-Data-Loc holds SCM-OK.a = INT;

theorem :: AMI_2:11
  for a being Element of NAT holds SCM-OK.a = SCM-Instr;

theorem :: AMI_2:12
  for a being Element of NAT,
  t being Element of SCM-Data-Loc holds a <> t;

theorem :: AMI_2:13
  pi(product SCM-OK,NAT) = NAT;

theorem :: AMI_2:14
  for a being Element of SCM-Data-Loc holds pi(product SCM-OK,a) = INT;

theorem :: AMI_2:15
  for a being Element of NAT holds pi(product SCM-OK,a) = SCM-Instr;

definition
  let s be SCM-State;
  func IC(s) -> Element of NAT equals
:: AMI_2:def 6

  s.NAT;
end;

definition
  let s be SCM-State, u be Nat;
  func SCM-Chg(s,u) -> SCM-State equals
:: AMI_2:def 7

  s +* (NAT .--> u);
end;

theorem :: AMI_2:16
  for s being SCM-State, u being Nat
  holds SCM-Chg(s,u).NAT = u;

theorem :: AMI_2:17
  for s being SCM-State, u being Nat,
  mk being Element of SCM-Data-Loc holds SCM-Chg(s,u).mk = s.mk;

theorem :: AMI_2:18
  for s being SCM-State, u,v being Nat
  holds SCM-Chg(s,u).v = s.v;

definition
  let s be SCM-State, t be Element of SCM-Data-Loc, u be Integer;
  func SCM-Chg(s,t,u) -> SCM-State equals
:: AMI_2:def 8

  s +* (t .--> u);
end;

theorem :: AMI_2:19
  for s being SCM-State, t being Element of SCM-Data-Loc, u being Integer
  holds SCM-Chg(s,t,u).NAT = s.NAT;

theorem :: AMI_2:20
  for s being SCM-State, t being Element of SCM-Data-Loc, u being Integer
  holds SCM-Chg(s,t,u).t = u;

theorem :: AMI_2:21
  for s being SCM-State, t being Element of SCM-Data-Loc, u being Integer,
  mk being Element of SCM-Data-Loc st mk <> t holds SCM-Chg(s,t,u).mk = s.mk;

theorem :: AMI_2:22
  for s being SCM-State, t being Element of SCM-Data-Loc, u being Integer,
  v being Element of NAT holds SCM-Chg(s,t,u).v = s.v;

definition
  let x be Element of SCM-Instr;
  given mk, ml being Element of SCM-Data-Loc, I such that
 x = [ I, <*mk, ml*>];
  func x address_1 -> Element of SCM-Data-Loc means
:: AMI_2:def 9

  ex f being FinSequence of SCM-Data-Loc st f = x`2 & it = f/.1;
  func x address_2 -> Element of SCM-Data-Loc means
:: AMI_2:def 10

  ex f being FinSequence of SCM-Data-Loc st f = x`2 & it = f/.2;
end;

theorem :: AMI_2:23
  for x being Element of SCM-Instr, mk, ml being Element of SCM-Data-Loc, I
  st x = [ I, <*mk, ml*>] holds x address_1 = mk & x address_2 = ml;

definition
  let x be Element of SCM-Instr;
  given mk being Element of NAT, I such that
 x = [ I, <*mk*>];
  func x jump_address -> Element of NAT means
:: AMI_2:def 11

  ex f being FinSequence of NAT st f = x`2 & it = f/.1;
end;

theorem :: AMI_2:24
  for x being Element of SCM-Instr, mk being Element of NAT, I
  st x = [ I, <*mk*>] holds x jump_address = mk;

definition
  let x be Element of SCM-Instr;
  given mk being Element of NAT,
  ml being Element of SCM-Data-Loc, I such that
 x = [ I, <*mk,ml*>];
  func x cjump_address -> Element of NAT means
:: AMI_2:def 12

  ex mk being Element of NAT,
  ml being Element of SCM-Data-Loc st <*mk,ml*> = x`2 & it = <*mk,ml*>/.1;
  func x cond_address -> Element of SCM-Data-Loc means
:: AMI_2:def 13

  ex mk being Element of NAT,
  ml being Element of SCM-Data-Loc st <*mk,ml*> = x`2 & it = <*mk,ml*>/.2;
end;

theorem :: AMI_2:25
  for x being Element of SCM-Instr, mk being Element of NAT,
  ml being Element of SCM-Data-Loc, I st x = [ I, <*mk,ml*>]
  holds x cjump_address = mk & x cond_address = ml;

registration
  let s be SCM-State, a be Element of SCM-Data-Loc;
  cluster s.a -> integer;
end;

definition
 canceled 2;
  let x be Element of SCM-Instr, s be SCM-State;
  func SCM-Exec-Res(x,s) -> SCM-State equals
:: AMI_2:def 16
  SCM-Chg(SCM-Chg(s, x address_1,s.(x address_2)), succ IC s)
  if ex mk, ml being Element of SCM-Data-Loc st x = [ 1, <*mk, ml*>],
  SCM-Chg(SCM-Chg(s,x address_1, s.(x address_1)+s.(x address_2)),succ IC s)
  if ex mk, ml being Element of SCM-Data-Loc st x = [ 2, <*mk, ml*>],
  SCM-Chg(SCM-Chg(s,x address_1, s.(x address_1)-s.(x address_2)),succ IC s)
  if ex mk, ml being Element of SCM-Data-Loc st x = [ 3, <*mk, ml*>],
  SCM-Chg(SCM-Chg(s,x address_1, s.(x address_1)*s.(x address_2)),succ IC s)
  if ex mk, ml being Element of SCM-Data-Loc st x = [ 4, <*mk, ml*>],
  SCM-Chg(SCM-Chg( SCM-Chg(s,x address_1,s.(x address_1) div s.(x address_2)),
  x address_2,s.(x address_1) mod s.(x address_2)),succ IC s)
  if ex mk, ml being Element of SCM-Data-Loc st x = [ 5, <*mk, ml*>],
  SCM-Chg(s,x jump_address)
  if ex mk being Element of NAT st x = [ 6, <*mk*>],
  SCM-Chg(s,IFEQ(s.(x cond_address),0,x cjump_address,succ IC s))
  if ex mk being Element of NAT,
  ml being Element of SCM-Data-Loc st x = [ 7, <*mk,ml*>],
  SCM-Chg(s,IFGT(s.(x cond_address),0,x cjump_address,succ IC s))
  if ex mk being Element of NAT,
  ml being Element of SCM-Data-Loc st x = [ 8, <*mk,ml*>] otherwise s;
end;

definition
  func SCM-Exec ->
  Function of SCM-Instr, Funcs(product SCM-OK, product SCM-OK) means
:: AMI_2:def 17
  for x being Element of SCM-Instr, y being SCM-State holds
  (it.x).y = SCM-Exec-Res(x,y);
end;

begin :: Addenda

:: missing, 2007.07.27, A.T.

canceled;

theorem :: AMI_2:27
  not NAT in SCM-Data-Loc;

theorem :: AMI_2:28
  not NAT in NAT;

theorem :: AMI_2:29
  SCM-Data-Loc misses NAT;

theorem :: AMI_2:30
  NAT in SCM-Memory;

canceled;

theorem :: AMI_2:32
  x in SCM-Data-Loc implies ex k being Element of NAT st x = [1,k];

theorem :: AMI_2:33
  for k being natural number holds [1,k] in SCM-Data-Loc;

