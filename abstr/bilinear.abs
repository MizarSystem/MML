:: Bilinear Functionals in Vector Spaces
::  by Jaros{\l}aw Kotowicz
::
:: Received November 5, 2002
:: Copyright (c) 2002 Association of Mizar Users

environ

 vocabulary RLVECT_1, VECTSP_1, ARYTM_1, HAHNBAN, FUNCT_1, SUBSET_1, FUNCOP_1,
      GRCAT_1, UNIALG_1, BINOP_1, LATTICES, RELAT_1, HAHNBAN1, FUNCT_5,
      RLSUB_1, ALGSTR_2, REALSET1, BOOLE, SEQM_3, GROUP_6, VECTSP10, BILINEAR,
      RELAT_2, SPPOL_1;
 notation TARSKI, XBOOLE_0, ZFMISC_1, SUBSET_1, STRUCT_0, DOMAIN_1, FUNCT_1,
      RELAT_1, PRE_TOPC, REALSET1, RLVECT_1, BINOP_1, VECTSP_1, RELSET_1,
      FUNCT_2, SEQM_3, FUNCT_5, VECTSP_4, BORSUK_1, HAHNBAN1, VECTSP10;
 constructors DOMAIN_1, NATTRA_1, BORSUK_1, VECTSP10;
 clusters STRUCT_0, SUBSET_1, RELSET_1, VECTSP_1, HAHNBAN1, VECTSP_4, VECTSP10,
      XBOOLE_0;
 requirements SUBSET, BOOLE;


begin
:: Two Form on Vector Spaces and Operations on Them.

definition
 let K be 1-sorted;
 let V,W be VectSpStr over K;
mode Form of V,W is Function of [:the carrier of V,the carrier of W:],
                                       the carrier of K;
 canceled;
end;


definition
 let K be non empty ZeroStr;
 let V,W be VectSpStr over K;
 func NulForm(V,W) -> Form of V,W equals
:: BILINEAR:def 2
         [:the carrier of V,the carrier of W:] --> 0.K;
end;


definition
 let K be non empty LoopStr;
 let V,W be non empty VectSpStr over K;
 let f,g be Form of V,W;
func f+g -> Form of V,W means
:: BILINEAR:def 3
 for v be Vector of V, w be Vector of W holds it.[v,w] = f.[v,w]+g.[v,w];
end;


definition
 let K be non empty HGrStr;
 let V,W be non empty VectSpStr over K;
 let f be Form of V,W;
 let a be Element of K;
func a*f -> Form of V,W means
:: BILINEAR:def 4
 for v be Vector of V, w be Vector of W holds it.[v,w] = a*f.[v,w];
end;


definition
 let K be non empty LoopStr;
 let V,W be non empty VectSpStr over K;
 let f be Form of V,W;
func -f -> Form of V,W means
:: BILINEAR:def 5
 for v be Vector of V, w be Vector of W holds it.[v,w] = -f.[v,w];
end;


definition
 let K be add-associative right_zeroed right_complementable
       left-distributive left_unital (non empty doubleLoopStr);
 let V,W be non empty VectSpStr over K;
 let f be Form of V,W;
redefine func -f -> Form of V,W equals
:: BILINEAR:def 6
   (- 1_ K) *f;
end;


definition
 let K be non empty LoopStr;
 let V,W be non empty VectSpStr over K;
 let f,g be Form of V,W;
func f-g -> Form of V,W equals
:: BILINEAR:def 7
   f + -g;
end;


definition
 let K be non empty LoopStr;
 let V,W be non empty VectSpStr over K;
 let f,g be Form of V,W;
redefine func f - g -> Form of V,W means
:: BILINEAR:def 8
 for v be Vector of V, w be Vector of W holds it.[v,w] = f.[v,w] - g.[v,w];
end;

definition
 let K be Abelian (non empty LoopStr);
 let V,W be non empty VectSpStr over K;
 let f,g be Form of V,W;
redefine func f+g;
commutativity;
end;


theorem :: BILINEAR:1
for K be non empty ZeroStr
for V,W be non empty VectSpStr over K
 for v be Vector of V,w be Vector of W holds NulForm(V,W).[v,w] = 0.K;

theorem :: BILINEAR:2
  for K be right_zeroed (non empty LoopStr)
for V,W be non empty VectSpStr over K
 for f be Form of V,W holds f + NulForm(V,W) = f;

theorem :: BILINEAR:3
  for K be add-associative (non empty LoopStr)
for V,W be non empty VectSpStr over K
 for f,g,h be Form of V,W holds f+g+h = f+(g+h);

theorem :: BILINEAR:4
  for K be add-associative right_zeroed right_complementable (non empty LoopStr
)
for V,W be non empty VectSpStr over K
 for f be Form of V,W holds f - f = NulForm(V,W);

theorem :: BILINEAR:5
  for K be right-distributive (non empty doubleLoopStr)
for V,W be non empty VectSpStr over K, a be Element of K
 for f,g be Form of V,W holds a*(f+g) = a*f+a*g;

theorem :: BILINEAR:6
  for K be left-distributive (non empty doubleLoopStr)
for V,W be non empty VectSpStr over K
for a,b be Element of K
 for f be Form of V,W holds (a+b)*f = a*f+b*f;

theorem :: BILINEAR:7
  for K be associative (non empty doubleLoopStr)
for V,W be non empty VectSpStr over K
for a,b be Element of K
 for f be Form of V,W holds (a*b)*f = a*(b*f);

theorem :: BILINEAR:8
  for K be left_unital (non empty doubleLoopStr)
for V,W be non empty VectSpStr over K
 for f be Form of V,W holds (1_ K)*f = f;

begin
:: Functional generated by Two Form when the One of Arguments is Fixed.

definition
  let K be non empty 1-sorted;
  let V,W be non empty VectSpStr over K;
  let f be Form of V,W, v be Vector of V;
 func FunctionalFAF(f,v) -> Functional of W equals
:: BILINEAR:def 9
(curry f).v;
end;


definition
  let K be non empty 1-sorted;
  let V,W be non empty VectSpStr over K;
  let f be Form of V,W, w be Vector of W;
 func FunctionalSAF(f,w) -> Functional of V equals
:: BILINEAR:def 10
(curry' f).w;
end;


theorem :: BILINEAR:9
for K be non empty 1-sorted
for V,W be non empty VectSpStr over K
 for f be Form of V,W, v be Vector of V holds
   dom (FunctionalFAF(f,v)) = the carrier of W &
   rng (FunctionalFAF(f,v)) c= the carrier of K &
   for w be Vector of W holds (FunctionalFAF(f,v)).w = f.[v,w];

theorem :: BILINEAR:10
for K be non empty 1-sorted
for V,W be non empty VectSpStr over K
 for f be Form of V,W, w be Vector of W holds
   dom (FunctionalSAF(f,w)) = the carrier of V &
   rng (FunctionalSAF(f,w)) c= the carrier of K &
   for v be Vector of V holds (FunctionalSAF(f,w)).v = f.[v,w];

theorem :: BILINEAR:11
for K be non empty ZeroStr
for V,W be non empty VectSpStr over K
  for f be Form of V,W, v be Vector of V holds
     FunctionalFAF(NulForm(V,W),v) = 0Functional(W);

theorem :: BILINEAR:12
for K be non empty ZeroStr
for V,W be non empty VectSpStr over K
  for f be Form of V,W, w be Vector of W holds
     FunctionalSAF(NulForm(V,W),w) = 0Functional(V);

theorem :: BILINEAR:13
for K be non empty LoopStr
for V,W be non empty VectSpStr over K
 for f,g be Form of V,W, w be Vector of W holds
  FunctionalSAF(f+g,w) = FunctionalSAF(f,w) + FunctionalSAF(g,w);

theorem :: BILINEAR:14
for K be non empty LoopStr
for V,W be non empty VectSpStr over K
 for f,g be Form of V,W, v be Vector of V holds
  FunctionalFAF(f+g,v) = FunctionalFAF(f,v) + FunctionalFAF(g,v);

theorem :: BILINEAR:15
for K be non empty doubleLoopStr
for V,W be non empty VectSpStr over K
 for f be Form of V,W, a be Element of K, w be Vector of W holds
  FunctionalSAF(a*f,w) = a*FunctionalSAF(f,w);

theorem :: BILINEAR:16
for K be non empty doubleLoopStr
for V,W be non empty VectSpStr over K
 for f be Form of V,W, a be Element of K, v be Vector of V holds
  FunctionalFAF(a*f,v) = a*FunctionalFAF(f,v);

theorem :: BILINEAR:17
for K be non empty LoopStr
for V,W be non empty VectSpStr over K
 for f be Form of V,W, w be Vector of W holds
  FunctionalSAF(-f,w) = - FunctionalSAF(f,w);

theorem :: BILINEAR:18
for K be non empty LoopStr
for V,W be non empty VectSpStr over K
 for f be Form of V,W, v be Vector of V holds
  FunctionalFAF(-f,v) = -FunctionalFAF(f,v);

theorem :: BILINEAR:19
  for K be non empty LoopStr
for V,W be non empty VectSpStr over K
 for f,g be Form of V,W, w be Vector of W holds
  FunctionalSAF(f-g,w) = FunctionalSAF(f,w) - FunctionalSAF(g,w);

theorem :: BILINEAR:20
  for K be non empty LoopStr
for V,W be non empty VectSpStr over K
 for f,g be Form of V,W, v be Vector of V holds
  FunctionalFAF(f-g,v) = FunctionalFAF(f,v) - FunctionalFAF(g,v);

begin
:: Two Form generated by Functionals.

definition
  let K be non empty HGrStr;
  let V,W be non empty VectSpStr over K;
  let f be Functional of V; let g be Functional of W;
 func FormFunctional(f,g) -> Form of V,W means
:: BILINEAR:def 11
   for v be Vector of V, w be Vector of W holds it.[v,w]= f.v * g.w;
end;


theorem :: BILINEAR:21
for K be add-associative right_zeroed right_complementable
         right-distributive (non empty doubleLoopStr)
for V,W be non empty VectSpStr over K
 for f be Functional of V ,v be Vector of V, w be Vector of W holds
     FormFunctional(f,0Functional(W)).[v,w] = 0.K;

theorem :: BILINEAR:22
for K be add-associative right_zeroed right_complementable
         left-distributive (non empty doubleLoopStr)
for V,W be non empty VectSpStr over K
  for g be Functional of W, v be Vector of V, w be Vector of W holds
     FormFunctional(0Functional(V),g).[v,w] = 0.K;

theorem :: BILINEAR:23
  for K be add-associative right_zeroed right_complementable
         right-distributive (non empty doubleLoopStr)
for V,W be non empty VectSpStr over K
 for f be Functional of V holds FormFunctional(f,0Functional(W)) = NulForm(V,W)
;

theorem :: BILINEAR:24
  for K be add-associative right_zeroed right_complementable
         left-distributive (non empty doubleLoopStr)
for V,W be non empty VectSpStr over K
 for g be Functional of W holds FormFunctional(0Functional(V),g) = NulForm(V,W)
;

theorem :: BILINEAR:25
for K be non empty HGrStr
for V,W be non empty VectSpStr over K
  for f be Functional of V, g be Functional of W, v be Vector of V holds
     FunctionalFAF(FormFunctional(f,g),v) = f.v * g;

theorem :: BILINEAR:26
for K be commutative (non empty HGrStr)
for V,W be non empty VectSpStr over K
  for f be Functional of V, g be Functional of W, w be Vector of W holds
      FunctionalSAF(FormFunctional(f,g),w) = g.w * f;

begin
::Bilinear Forms and Their Properties

definition
  let K be non empty LoopStr;
  let V,W be non empty VectSpStr over K;
  let f be Form of V,W;
 attr f is additiveFAF means
:: BILINEAR:def 12
    for v be Vector of V holds FunctionalFAF(f,v) is additive;
 attr f is additiveSAF means
:: BILINEAR:def 13
    for w be Vector of W holds FunctionalSAF(f,w) is additive;
end;


definition
  let K be non empty HGrStr;
  let V,W be non empty VectSpStr over K;
  let f be Form of V,W;
 attr f is homogeneousFAF means
:: BILINEAR:def 14
    for v be Vector of V holds FunctionalFAF(f,v) is homogeneous;
 attr f is homogeneousSAF means
:: BILINEAR:def 15
    for w be Vector of W holds FunctionalSAF(f,w) is homogeneous;
end;


registration
  let K be right_zeroed (non empty LoopStr);
  let V,W be non empty VectSpStr over K;
cluster NulForm(V,W) -> additiveFAF;
  coherence
   proof
    let v be Vector of V;
      FunctionalFAF(NulForm(V,W),v)= 0Functional(W) by Th11;
    hence thesis;
   end;
cluster NulForm(V,W) -> additiveSAF;
  coherence
   proof
    let y be Vector of W;
      FunctionalSAF(NulForm(V,W),y)= 0Functional(V) by Th12;
    hence thesis;
   end;
end;


registration
  let K be right_zeroed (non empty LoopStr);
  let V,W be non empty VectSpStr over K;
cluster additiveFAF additiveSAF Form of V,W;
  existence
  proof
   take NulForm(V,W); thus thesis;
  end;
end;


registration
  let K be add-associative right_zeroed right_complementable
                 right-distributive (non empty doubleLoopStr);
  let V,W be non empty VectSpStr over K;
cluster NulForm(V,W) -> homogeneousFAF;
  coherence
    proof
     let v be Vector of V;
       FunctionalFAF(NulForm(V,W),v)= 0Functional(W) by Th11;
     hence thesis;
    end;
cluster NulForm(V,W) -> homogeneousSAF;
  coherence
   proof
    let y be Vector of W;
      FunctionalSAF(NulForm(V,W),y)= 0Functional(V) by Th12;
    hence thesis;
   end;
end;


registration
  let K be add-associative right_zeroed right_complementable
           right-distributive (non empty doubleLoopStr);
  let V,W be non empty VectSpStr over K;
cluster additiveFAF homogeneousFAF additiveSAF homogeneousSAF Form of V,W;
  existence proof take NulForm(V,W); thus thesis; end;
end;


definition
  let K be add-associative right_zeroed right_complementable
           right-distributive (non empty doubleLoopStr);
  let V,W be non empty VectSpStr over K;
 mode bilinear-Form of V,W is additiveSAF homogeneousSAF
           additiveFAF homogeneousFAF Form of V,W;
end;


registration
 let K be add-associative right_zeroed right_complementable
          right-distributive (non empty doubleLoopStr);
 let V,W be non empty VectSpStr over K;
 let f be additiveFAF Form of V,W, v be Vector of V;
cluster FunctionalFAF(f,v) -> additive;
  coherence by Def12;
end;


registration
 let K be add-associative right_zeroed right_complementable
          right-distributive (non empty doubleLoopStr);
 let V,W be non empty VectSpStr over K;
 let f be additiveSAF Form of V,W, w be Vector of W;
cluster FunctionalSAF(f,w) -> additive;
  coherence by Def13;
end;


registration
 let K be add-associative right_zeroed right_complementable
          right-distributive (non empty doubleLoopStr);
 let V,W be non empty VectSpStr over K;
 let f be homogeneousFAF Form of V,W, v be Vector of V;
cluster FunctionalFAF(f,v) -> homogeneous;
  coherence by Def14;
end;


registration
 let K be add-associative right_zeroed right_complementable
          right-distributive (non empty doubleLoopStr);
 let V,W be non empty VectSpStr over K;
 let f be homogeneousSAF Form of V,W, w be Vector of W;
cluster FunctionalSAF(f,w) -> homogeneous;
  coherence by Def15;
end;


registration
  let K be add-associative right_zeroed right_complementable
           right-distributive (non empty doubleLoopStr);
  let V,W be non empty VectSpStr over K;
  let f be Functional of V, g be additive Functional of W;
cluster FormFunctional(f,g) -> additiveFAF;
 coherence
  proof
   let v be Vector of V;
   set fg = FormFunctional(f,g), F = FunctionalFAF(fg,v);
  A1: F= f.v * g by Th25;
   let y,y' be Vector of W;
   thus F.(y+y') = f.v * g.(y+y') by A1,HAHNBAN1:def 9
     .= f.v *(g.y +g.y') by HAHNBAN1:def 11
     .= f.v * g.y + f.v * g.y' by VECTSP_1:def 11
     .=f.v * g.y + F.y' by A1,HAHNBAN1:def 9
     .=F.y + F.y' by A1,HAHNBAN1:def 9;
  end;
end;


registration
 let K be add-associative right_zeroed right_complementable
          commutative right-distributive (non empty doubleLoopStr);
 let V,W be non empty VectSpStr over K;
 let f be additive Functional of V, g be Functional of W;
cluster FormFunctional(f,g) -> additiveSAF;
  coherence
   proof
    let y be Vector of W;
    set fg= FormFunctional(f,g), F = FunctionalSAF(fg,y);
   A1: F= g.y * f by Th26;
       now let v,v' be Vector of V;
      thus F.(v+v') = g.y * f.(v+v') by A1,HAHNBAN1:def 9
       .= g.y *(f.v +f.v') by HAHNBAN1:def 11
       .= g.y * f.v + g.y * f.v' by VECTSP_1:def 11
       .= g.y * f.v + F.v' by A1,HAHNBAN1:def 9
       .= F.v + F.v' by A1,HAHNBAN1:def 9;
     end;
     hence F is additive by HAHNBAN1:def 11;
   end;
end;


registration
 let K be add-associative right_zeroed right_complementable commutative
         associative right-distributive (non empty doubleLoopStr);
 let V,W be non empty VectSpStr over K;
 let f be Functional of V, g be homogeneous Functional of W;
cluster FormFunctional(f,g) -> homogeneousFAF;
 coherence
  proof
   let v be Vector of V;
   set fg= FormFunctional(f,g), F = FunctionalFAF(fg,v);
  A1: F= f.v * g by Th25;
   let y be Vector of W,r be Scalar of W;
   thus F.(r* y) = f.v * g.(r*y) by A1,HAHNBAN1:def 9
    .= f.v *(r*g.y) by HAHNBAN1:def 12
    .= r*(f.v * g.y) by VECTSP_1:def 16
    .= r *F.y by A1,HAHNBAN1:def 9;
  end;
end;


registration
 let K be add-associative right_zeroed right_complementable commutative
         associative right-distributive (non empty doubleLoopStr);
 let V,W be non empty VectSpStr over K;
 let f be homogeneous Functional of V, g be Functional of W;
cluster FormFunctional(f,g) -> homogeneousSAF;
 coherence
  proof
   set fg= FormFunctional(f,g);
   let y be Vector of W;
   set F = FunctionalSAF(fg,y);
  A1: F= g.y * f by Th26;
   let v be Vector of V,r be Scalar of V;
   thus F.(r* v) = g.y * f.(r*v) by A1,HAHNBAN1:def 9
     .= g.y *(r*f.v) by HAHNBAN1:def 12
     .= r*(g.y * f.v) by VECTSP_1:def 16
     .= r *F.v by A1,HAHNBAN1:def 9;
  end;
end;


registration
 let K be non degenerated (non empty doubleLoopStr);
 let V be non trivial (non empty VectSpStr over K),
     W be non empty VectSpStr over K;
 let f be Functional of V, g be Functional of W;
cluster FormFunctional(f,g) -> non trivial;
 coherence
  proof
   consider v be Vector of V such that
  A1: v <> 0.V by ANPROJ_1:def 8;
   consider w be Vector of W;
   set fg = FormFunctional(f,g);
   assume A2: fg is trivial;
    dom fg = [:the carrier of V, the carrier of W:] by FUNCT_2:def 1;
  then A3: [[0.V,0.W],fg.[0.V,0.W]] in fg & [[v,w],fg.[v,w]] in fg by FUNCT_1:8
;
  A4:  [0.V,0.W] <> [v,w] by A1,ZFMISC_1:33;
   per cases by A2,REALSET1:def 12;
    suppose fg = {};
     hence contradiction by A3;
    end;
    suppose ex x be set st fg = {x};
     then consider x be set such that
    A5: fg={x};
       [[0.V,0.W],fg.[0.V,0.W]] = x & x=[[v,w],fg.[v,w]] by A3,A5,TARSKI:def 1;
     hence contradiction by A4,ZFMISC_1:33;
  end;
  end;
end;


registration
 let K be non degenerated (non empty doubleLoopStr);
 let V be non empty VectSpStr over K,
     W be non trivial (non empty VectSpStr over K);
 let f be Functional of V, g be Functional of W;
cluster FormFunctional(f,g) -> non trivial;
 coherence
  proof
   consider v be Vector of V;
   consider w be Vector of W such that
  A1: w <> 0.W by ANPROJ_1:def 8;
   set fg = FormFunctional(f,g);
   assume A2: fg is trivial;
    dom fg = [:the carrier of V, the carrier of W:] by FUNCT_2:def 1;
  then A3: [[0.V,0.W],fg.[0.V,0.W]] in fg & [[v,w],fg.[v,w]] in fg by FUNCT_1:8
;
  A4:  [0.V,0.W] <> [v,w] by A1,ZFMISC_1:33;
   per cases by A2,REALSET1:def 12;
    suppose fg = {};
     hence contradiction by A3;
    end;
    suppose ex x be set st fg = {x};
     then consider x be set such that
    A5: fg={x};
       [[0.V,0.W],fg.[0.V,0.W]] = x & x=[[v,w],fg.[v,w]] by A3,A5,TARSKI:def 1;
     hence contradiction by A4,ZFMISC_1:33;
  end;
  end;
end;


registration
 let K be Field;
 let V,W be non trivial VectSp of K;
 let f be non constant 0-preserving Functional of V,
     g be non constant 0-preserving Functional of W;
cluster FormFunctional(f,g) -> non constant;
 coherence
  proof
   consider v be Vector of V such that
 A1: v <> 0.V & f.v <> 0.K by VECTSP10:29;
  consider w be Vector of W such that
 A2: w <> 0.W & g.w <> 0.K by VECTSP10:29;
   set fg = FormFunctional(f,g);
 A3: fg.[0.V,0.W] = f.(0.V)*g.(0.W) by Def11
    .= 0.K * g.(0.W) by HAHNBAN1:def 13
    .= 0.K by VECTSP_1:39;
 A4: dom fg = [:the carrier of V, the carrier of W:] by FUNCT_2:def 1;
     fg.[v,w] = f.v * g.w by Def11;
   then fg.[v,w] <> 0.K by A1,A2,VECTSP_1:44;
   hence thesis by A3,A4,SEQM_3:def 5;
  end;
end;


registration
  let K be Field;
  let V,W be non trivial VectSp of K;
cluster non trivial non constant
         additiveFAF homogeneousFAF additiveSAF homogeneousSAF Form of V,W;
 existence
  proof
   consider f be non constant non trivial linear-Functional of V,
    g be non constant non trivial linear-Functional of W;
   take FormFunctional(f,g);
   thus thesis;
  end;
end;


registration
 let K be Abelian add-associative right_zeroed (non empty LoopStr);
 let V,W be non empty VectSpStr over K;
 let f,g be additiveSAF Form of V,W;
cluster f+g -> additiveSAF;
 correctness
  proof
  let w be Vector of W;
   set Ffg = FunctionalSAF(f+g,w), Ff = FunctionalSAF(f,w);
   set Fg = FunctionalSAF(g,w);
A1: Ff is additive & Fg is additive by Def13;
  let v,y be Vector of V;
   thus Ffg.(v+y) = (Ff+Fg).(v+y) by Th13
   .= Ff.(v+y) + Fg.(v+y) by HAHNBAN1:def 6
   .= Ff.v+Ff.y + Fg.(v+y) by A1,HAHNBAN1:def 11
   .= Ff.v+Ff.y + (Fg.v+Fg.y) by A1,HAHNBAN1:def 11
   .= Ff.v+Ff.y + Fg.v + Fg.y by RLVECT_1:def 6
   .= Ff.v+Fg.v + Ff.y+Fg.y by RLVECT_1:def 6
   .= (Ff+Fg).v + Ff.y+Fg.y by HAHNBAN1:def 6
   .= (Ff+Fg).v + (Ff.y+Fg.y) by RLVECT_1:def 6
   .= (Ff+Fg).v + (Ff+Fg).y by HAHNBAN1:def 6
   .= Ffg.v + (Ff+Fg).y by Th13
   .= Ffg.v + Ffg.y by Th13;
  end;
end;


registration
 let K be Abelian add-associative right_zeroed (non empty LoopStr);
 let V,W be non empty VectSpStr over K;
 let f,g be additiveFAF Form of V,W;
cluster f+g -> additiveFAF;
 correctness
  proof
  let w be Vector of V;
   set Ffg = FunctionalFAF(f+g,w), Ff = FunctionalFAF(f,w);
   set Fg = FunctionalFAF(g,w);
A1: Ff is additive & Fg is additive by Def12;
  let v,y be Vector of W;
   thus Ffg.(v+y) = (Ff+Fg).(v+y) by Th14
   .= Ff.(v+y) + Fg.(v+y) by HAHNBAN1:def 6
   .= Ff.v+Ff.y + Fg.(v+y) by A1,HAHNBAN1:def 11
   .= Ff.v+Ff.y + (Fg.v+Fg.y) by A1,HAHNBAN1:def 11
   .= Ff.v+Ff.y + Fg.v +Fg.y by RLVECT_1:def 6
   .= Ff.v+Fg.v + Ff.y+Fg.y by RLVECT_1:def 6
   .= (Ff+Fg).v + Ff.y+Fg.y by HAHNBAN1:def 6
   .= (Ff+Fg).v + (Ff.y+Fg.y) by RLVECT_1:def 6
   .= (Ff+Fg).v + (Ff+Fg).y by HAHNBAN1:def 6
   .= Ffg.v + (Ff+Fg).y by Th14
   .= Ffg.v + Ffg.y by Th14;
  end;
end;


registration
 let K be right-distributive right_zeroed (non empty doubleLoopStr);
 let V,W be non empty VectSpStr over K;
 let f be additiveSAF Form of V,W;
 let a be Element of K;
cluster a*f -> additiveSAF;
 correctness
  proof
  let w be Vector of W;
   set Ffg = FunctionalSAF(a*f,w), Ff = FunctionalSAF(f,w);
A1: Ff is additive by Def13;
  let v,y be Vector of V;
   thus Ffg.(v+y) = (a*Ff).(v+y) by Th15
   .= a*Ff.(v+y) by HAHNBAN1:def 9
   .= a*(Ff.v + Ff.y) by A1,HAHNBAN1:def 11
   .= a* Ff.v + a*Ff.y by VECTSP_1:def 11
   .= (a*Ff).v +a* Ff.y by HAHNBAN1:def 9
   .= (a*Ff).v + (a*Ff).y by HAHNBAN1:def 9
   .= Ffg.v + (a*Ff).y by Th15
   .= Ffg.v + Ffg.y by Th15;
  end;
end;


registration
 let K be right-distributive right_zeroed (non empty doubleLoopStr);
 let V,W be non empty VectSpStr over K;
 let f be additiveFAF Form of V,W;
 let a be Element of K;
cluster a*f -> additiveFAF;
 correctness
  proof
  let w be Vector of V;
   set Ffg = FunctionalFAF(a*f,w), Ff = FunctionalFAF(f,w);
 A1: Ff is additive by Def12;
  let v,y be Vector of W;
   thus Ffg.(v+y) = (a*Ff).(v+y) by Th16
    .= a*Ff.(v+y) by HAHNBAN1:def 9
    .= a*(Ff.v + Ff.y) by A1,HAHNBAN1:def 11
    .= a* Ff.v +a* Ff.y by VECTSP_1:def 11
    .= (a*Ff).v +a* Ff.y by HAHNBAN1:def 9
    .= (a*Ff).v + (a*Ff).y by HAHNBAN1:def 9
    .= Ffg.v + (a*Ff).y by Th16
    .= Ffg.v + Ffg.y by Th16;
  end;
end;


registration
 let K be Abelian add-associative right_zeroed right_complementable
          (non empty LoopStr);
 let V,W be non empty VectSpStr over K;
 let f be additiveSAF Form of V,W;
cluster -f -> additiveSAF;
 correctness
  proof
  let w be Vector of W;
   set Ffg = FunctionalSAF(-f,w), Ff = FunctionalSAF(f,w);
A1: Ff is additive by Def13;
  let v,y be Vector of V;
   thus Ffg.(v+y) = (-Ff).(v+y) by Th17
   .= -Ff.(v+y) by HAHNBAN1:def 7
   .= -(Ff.v + Ff.y) by A1,HAHNBAN1:def 11
   .= (- Ff.v) - Ff.y by RLVECT_1:44
   .= (-Ff).v - Ff.y by HAHNBAN1:def 7
   .= (-Ff).v + - Ff.y by RLVECT_1:def 11
   .= (-Ff).v + (-Ff).y by HAHNBAN1:def 7
   .= Ffg.v + (-Ff).y by Th17
   .= Ffg.v + Ffg.y by Th17;
  end;
end;


registration
 let K be Abelian add-associative right_zeroed right_complementable
         (non empty LoopStr);
 let V,W be non empty VectSpStr over K;
 let f be additiveFAF Form of V,W;
cluster -f -> additiveFAF;
 correctness
  proof
  let w be Vector of V;
   set Ffg = FunctionalFAF(-f,w), Ff = FunctionalFAF(f,w);
 A1: Ff is additive by Def12;
  let v,y be Vector of W;
   thus Ffg.(v+y) = (-Ff).(v+y) by Th18
    .= -Ff.(v+y) by HAHNBAN1:def 7
    .= -(Ff.v + Ff.y) by A1,HAHNBAN1:def 11
    .= (- Ff.v) - Ff.y by RLVECT_1:44
    .= (-Ff).v - Ff.y by HAHNBAN1:def 7
    .= (-Ff).v + - Ff.y by RLVECT_1:def 11
    .= (-Ff).v + (-Ff).y by HAHNBAN1:def 7
    .= Ffg.v + (-Ff).y by Th18
    .= Ffg.v + Ffg.y by Th18;
  end;
end;


registration
 let K be Abelian add-associative right_zeroed right_complementable
          (non empty LoopStr);
 let V,W be non empty VectSpStr over K;
 let f,g be additiveSAF Form of V,W;
cluster f-g -> additiveSAF;
 correctness
  proof f-g = f+-g by Def7; hence thesis; end;
end;


registration
 let K be Abelian add-associative right_zeroed right_complementable
          (non empty LoopStr);
 let V,W be non empty VectSpStr over K;
 let f,g be additiveFAF Form of V,W;
cluster f-g -> additiveFAF;
 correctness
  proof f-g = f+-g by Def7; hence thesis; end;
end;


registration
 let K be add-associative right_zeroed right_complementable
            right-distributive (non empty doubleLoopStr);
 let V,W be non empty VectSpStr over K;
 let f,g be homogeneousSAF Form of V,W;
cluster f+g -> homogeneousSAF;
 correctness
  proof
  let w be Vector of W;
   set Ffg = FunctionalSAF(f+g,w), Ff = FunctionalSAF(f,w);
   set Fg = FunctionalSAF(g,w);
  let v be Vector of V, a be Scalar of V;
   thus Ffg.(a*v) = (Ff+Fg).(a*v) by Th13
   .= Ff.(a*v) + Fg.(a*v) by HAHNBAN1:def 6
   .= a*Ff.v + Fg.(a*v) by HAHNBAN1:def 12
   .= a*Ff.v + a*Fg.v by HAHNBAN1:def 12
   .= a*(Ff.v + Fg.v) by VECTSP_1:def 11
   .= a*(Ff + Fg).v by HAHNBAN1:def 6
   .= a* Ffg.v by Th13;
  end;
end;


registration
 let K be add-associative right_zeroed right_complementable
            right-distributive (non empty doubleLoopStr);
 let V,W be non empty VectSpStr over K;
 let f,g be homogeneousFAF Form of V,W;
cluster f+g -> homogeneousFAF;
 correctness
  proof
   let w be Vector of V;
   set Ffg = FunctionalFAF(f+g,w), Ff = FunctionalFAF(f,w);
   set Fg = FunctionalFAF(g,w);
   let v be Vector of W, a be Scalar of V;
   thus Ffg.(a*v) = (Ff+Fg).(a*v) by Th14
    .= Ff.(a*v) + Fg.(a*v) by HAHNBAN1:def 6
    .= a*Ff.v + Fg.(a*v) by HAHNBAN1:def 12
    .= a*Ff.v + a*Fg.v by HAHNBAN1:def 12
    .= a*(Ff.v + Fg.v) by VECTSP_1:def 11
    .= a*(Ff + Fg).v by HAHNBAN1:def 6
    .= a* Ffg.v by Th14;
  end;
end;


registration
 let K be add-associative right_zeroed right_complementable
   associative commutative right-distributive (non empty doubleLoopStr);
 let V,W be non empty VectSpStr over K;
 let f be homogeneousSAF Form of V,W;
 let a be Element of K;
cluster a*f -> homogeneousSAF;
 correctness
  proof
  let w be Vector of W;
   set Ffg = FunctionalSAF(a*f,w), Ff = FunctionalSAF(f,w);
  let v be Vector of V, b be Scalar of V;
   thus Ffg.(b*v) = (a*Ff).(b*v) by Th15
   .= a*Ff.(b*v) by HAHNBAN1:def 9
   .= a*(b*Ff.v) by HAHNBAN1:def 12
   .= b*(a*Ff.v) by VECTSP_1:def 16
   .= b*(a*Ff).v by HAHNBAN1:def 9
   .= b* Ffg.v by Th15;
  end;
end;


registration
 let K be add-associative right_zeroed right_complementable
   associative commutative right-distributive (non empty doubleLoopStr);
 let V,W be non empty VectSpStr over K;
 let f be homogeneousFAF Form of V,W;
 let a be Element of K;
cluster a*f -> homogeneousFAF;
 correctness
 proof
  let w be Vector of V;
  set Ffg = FunctionalFAF(a*f,w), Ff = FunctionalFAF(f,w);
  let v be Vector of W, b be Scalar of V;
   thus Ffg.(b*v) = (a*Ff).(b*v) by Th16
    .= a*Ff.(b*v) by HAHNBAN1:def 9
    .= a*(b*Ff.v) by HAHNBAN1:def 12
    .= b*(a*Ff.v) by VECTSP_1:def 16
    .= b*(a*Ff).v by HAHNBAN1:def 9
    .= b* Ffg.v by Th16;
  end;
end;


registration
 let K be add-associative right_zeroed right_complementable
            right-distributive (non empty doubleLoopStr);
 let V,W be non empty VectSpStr over K;
 let f be homogeneousSAF Form of V,W;
cluster -f -> homogeneousSAF;
 correctness
  proof
  let w be Vector of W;
   set Ffg = FunctionalSAF(-f,w), Ff = FunctionalSAF(f,w);
  let v be Vector of V, a be Scalar of V;
   thus Ffg.(a*v) = (-Ff).(a*v) by Th17
   .= -Ff.(a*v) by HAHNBAN1:def 7
   .= -(a*Ff.v) by HAHNBAN1:def 12
   .= a*(-Ff.v) by VECTSP_1:40
   .= a*(-Ff).v by HAHNBAN1:def 7
   .= a*Ffg.v by Th17;
  end;
end;


registration
 let K be add-associative right_zeroed right_complementable
            right-distributive (non empty doubleLoopStr);
 let V,W be non empty VectSpStr over K;
 let f be homogeneousFAF Form of V,W;
cluster -f -> homogeneousFAF;
 correctness
  proof
   let w be Vector of V;
   set Ffg = FunctionalFAF(-f,w), Ff = FunctionalFAF(f,w);
   let v be Vector of W, a be Scalar of W;
   thus Ffg.(a*v) = (-Ff).(a*v) by Th18
   .= -Ff.(a*v) by HAHNBAN1:def 7
   .= -(a*Ff.v) by HAHNBAN1:def 12
   .= a*(-Ff.v) by VECTSP_1:40
   .= a*(-Ff).v by HAHNBAN1:def 7
   .= a*Ffg.v by Th18;
  end;
end;


registration
 let K be add-associative right_zeroed right_complementable
            right-distributive (non empty doubleLoopStr);
 let V,W be non empty VectSpStr over K;
 let f,g be homogeneousSAF Form of V,W;
cluster f-g -> homogeneousSAF;
 correctness
  proof f-g = f+-g by Def7; hence thesis; end;
end;


registration
 let K be add-associative right_zeroed right_complementable
            right-distributive (non empty doubleLoopStr);
 let V,W be non empty VectSpStr over K;
 let f,g be homogeneousFAF Form of V,W;
cluster f-g -> homogeneousFAF;
 correctness
  proof f-g = f+-g by Def7; hence thesis; end;
end;


theorem :: BILINEAR:27
for K be non empty LoopStr
 for V,W be non empty VectSpStr over K
 for v,u be Vector of V, w be Vector of W, f be Form of V,W
 st f is additiveSAF holds f.[v+u,w] = f.[v,w] + f.[u,w];

theorem :: BILINEAR:28
for K be non empty LoopStr
 for V,W be non empty VectSpStr over K
 for v be Vector of V, u,w be Vector of W, f be Form of V,W
 st f is additiveFAF holds f.[v,u+w] = f.[v,u] + f.[v,w];

theorem :: BILINEAR:29
for K be right_zeroed (non empty LoopStr)
for V,W be non empty VectSpStr over K
 for v,u be Vector of V, w,t be Vector of W,
    f be additiveSAF additiveFAF Form of V,W holds
   f.[v+u,w+t] = f.[v,w] + f.[v,t] + (f.[u,w] + f.[u,t]);

theorem :: BILINEAR:30
for K be add-associative right_zeroed right_complementable
    (non empty doubleLoopStr)
for V,W be right_zeroed (non empty VectSpStr over K)
 for f be additiveFAF Form of V,W, v be Vector of V holds f.[v,0.W] = 0.K;

theorem :: BILINEAR:31
for K be add-associative right_zeroed right_complementable
    (non empty doubleLoopStr)
for V,W be right_zeroed (non empty VectSpStr over K)
 for f be additiveSAF Form of V,W, w be Vector of W holds f.[0.V,w] = 0.K;

theorem :: BILINEAR:32
for K be non empty HGrStr
 for V,W be non empty VectSpStr over K
 for v be Vector of V, w be Vector of W, a be Element of K
 for f be Form of V,W st f is homogeneousSAF holds f.[a*v,w] = a*f.[v,w];

theorem :: BILINEAR:33
for K be non empty HGrStr
 for V,W be non empty VectSpStr over K
 for v be Vector of V, w be Vector of W, a be Element of K
 for f be Form of V,W st f is homogeneousFAF holds f.[v,a*w] = a*f.[v,w];

theorem :: BILINEAR:34
for K be add-associative right_zeroed right_complementable
         associative left_unital distributive (non empty doubleLoopStr)
for V,W be add-associative right_zeroed right_complementable VectSp-like
           (non empty VectSpStr over K)
for f be homogeneousSAF Form of V,W, w be Vector of W holds f.[0.V,w] = 0.K;

theorem :: BILINEAR:35
for K be add-associative right_zeroed right_complementable
       associative left_unital distributive (non empty doubleLoopStr)
for V,W be add-associative right_zeroed right_complementable
           VectSp-like (non empty VectSpStr over K)
 for f be homogeneousFAF Form of V,W, v be Vector of V holds f.[v,0.W] = 0.K;

theorem :: BILINEAR:36
for K be add-associative right_zeroed right_complementable Abelian
    associative left_unital distributive (non empty doubleLoopStr)
 for V,W be VectSp of K
 for v,u be Vector of V, w be Vector of W,
   f be additiveSAF homogeneousSAF Form of V,W holds
    f.[v-u,w] = f.[v,w] - f.[u,w];

theorem :: BILINEAR:37
for K be add-associative right_zeroed right_complementable
    Abelian associative left_unital distributive (non empty doubleLoopStr)
 for V,W be VectSp of K
 for v be Vector of V, w,t be Vector of W,
     f be additiveFAF homogeneousFAF Form of V,W holds
   f.[v,w-t] = f.[v,w] - f.[v,t];

theorem :: BILINEAR:38
for K be add-associative right_zeroed right_complementable
    Abelian associative left_unital distributive (non empty doubleLoopStr)
 for V,W be VectSp of K
 for v,u be Vector of V, w,t be Vector of W, f be bilinear-Form of V,W
  holds f.[v-u,w-t] = f.[v,w] - f.[v,t] -(f.[u,w] - f.[u,t]);

theorem :: BILINEAR:39
  for K be add-associative right_zeroed right_complementable
     associative left_unital distributive (non empty doubleLoopStr)
for V,W be add-associative right_zeroed right_complementable VectSp-like
         (non empty VectSpStr over K)
 for v,u be Vector of V, w,t be Vector of W, a,b be Element of K
 for f be bilinear-Form of V,W
    holds
   f.[v+a*u,w+b*t] = f.[v,w] + b*f.[v,t] + (a*f.[u,w] + a*(b*f.[u,t]));

theorem :: BILINEAR:40
  for K be add-associative right_zeroed right_complementable
    Abelian associative left_unital distributive (non empty doubleLoopStr)
 for V,W be VectSp of K
 for v,u be Vector of V, w,t be Vector of W, a,b be Element of K
 for f be bilinear-Form of V,W
   holds f.[v-a*u,w-b*t] = f.[v,w] - b*f.[v,t] - (a*f.[u,w] - a*(b*f.[u,t]));

theorem :: BILINEAR:41
for K be add-associative right_zeroed right_complementable
   (non empty doubleLoopStr), V,W be right_zeroed (non empty VectSpStr over K),
    f be Form of V,W
st f is additiveFAF or f is additiveSAF holds
f is constant iff for v be Vector of V, w be Vector of W holds f.[v,w]=0.K;

begin
:: Left and Right Kernel of Form. "Diagonal" Kernel of Form

definition
 let K be ZeroStr;
 let V,W be non empty VectSpStr over K;
 let f be Form of V,W;
func leftker f ->
    Subset of V equals
:: BILINEAR:def 16
   {v where v is Vector of V : for w be Vector of W holds f.[v,w] = 0.K};
end;


definition
 let K be ZeroStr;
 let V,W be non empty VectSpStr over K;
 let f be Form of V,W;
func rightker f ->
    Subset of W equals
:: BILINEAR:def 17
   {w where w is Vector of W : for v be Vector of V holds f.[v,w] = 0.K};
end;


definition
 let K be ZeroStr;
 let V be non empty VectSpStr over K;
 let f be Form of V,V;
func diagker f -> Subset of V equals
:: BILINEAR:def 18
   {v where v is Vector of V : f.[v,v] = 0.K};
end;


registration
 let K be add-associative right_zeroed right_complementable
       right-distributive (non empty doubleLoopStr);
 let V be right_zeroed (non empty VectSpStr over K);
 let W be non empty VectSpStr over K;
 let f be additiveSAF Form of V,W;
cluster leftker f -> non empty;
  coherence
   proof
    A1: now let w be Vector of W;
     thus f.[0.V,w] = (FunctionalSAF(f,w)).(0.V) by Th10
       .= 0.K by HAHNBAN1:def 13;
     end;
      leftker f = {v where v is Vector of V :
        for w be Vector of W holds f.[v,w] = 0.K} by Def16;
    then 0.V in leftker f by A1; hence thesis;
   end;
end;


registration
 let K be add-associative right_zeroed right_complementable
       associative left_unital distributive (non empty doubleLoopStr);
 let V be add-associative right_zeroed right_complementable
       VectSp-like (non empty VectSpStr over K);
 let W be non empty VectSpStr over K;
 let f be homogeneousSAF Form of V,W;
cluster leftker f -> non empty;
 coherence
  proof
   A1: now let w be Vector of W;
     thus f.[0.V,w] = (FunctionalSAF(f,w)).(0.V) by Th10
       .= 0.K by HAHNBAN1:def 13;
     end; leftker f = {v where v is Vector of V :
        for w be Vector of W holds f.[v,w] = 0.K} by Def16;
   then 0.V in leftker f by A1; hence thesis;
  end;
end;


registration
 let K be add-associative right_zeroed right_complementable
       right-distributive (non empty doubleLoopStr);
 let V be non empty VectSpStr over K;
 let W be right_zeroed (non empty VectSpStr over K);
 let f be additiveFAF Form of V,W;
cluster rightker f -> non empty;
  coherence
   proof
    A1: now let v be Vector of V;
     thus f.[v,0.W] = (FunctionalFAF(f,v)).(0.W) by Th9
       .= 0.K by HAHNBAN1:def 13;
     end;
      rightker f = {w where w is Vector of W :
     for v be Vector of V holds f.[v,w] = 0.K} by Def17;
    then 0.W in rightker f by A1; hence thesis;
   end;
end;


registration
 let K be add-associative right_zeroed right_complementable
       associative left_unital distributive (non empty doubleLoopStr);
 let V be non empty VectSpStr over K;
 let W be add-associative right_zeroed right_complementable
       VectSp-like (non empty VectSpStr over K);
 let f be homogeneousFAF Form of V,W;
cluster rightker f -> non empty;
 coherence
  proof
   A1: now let v be Vector of V;
     thus f.[v,0.W] = (FunctionalFAF(f,v)).(0.W) by Th9
       .= 0.K by HAHNBAN1:def 13;
    end;
     rightker f = {w where w is Vector of W :
     for v be Vector of V holds f.[v,w] = 0.K} by Def17;
   then 0.W in rightker f by A1; hence thesis;
  end;
end;


registration
 let K be add-associative right_zeroed right_complementable
       (non empty doubleLoopStr);
 let V be right_zeroed (non empty VectSpStr over K);
 let f be additiveFAF Form of V,V;
cluster diagker f -> non empty;
  coherence
   proof
      f.[0.V,0.V] = 0.K &
    diagker f = {v where v is Vector of V : f.[v,v] = 0.K} by Def18,Th30;
    then 0.V in diagker f; hence thesis;
   end;
end;


registration
 let K be add-associative right_zeroed right_complementable
       (non empty doubleLoopStr);
 let V be right_zeroed (non empty VectSpStr over K);
 let f be additiveSAF Form of V,V;
cluster diagker f -> non empty;
  coherence
   proof
      f.[0.V,0.V] = 0.K &
    diagker f = {v where v is Vector of V: f.[v,v] = 0.K} by Def18,Th31;
    then 0.V in diagker f; hence thesis;
   end;
end;


registration
 let K be add-associative right_zeroed right_complementable
       associative left_unital distributive (non empty doubleLoopStr);
 let V be add-associative right_zeroed right_complementable
       VectSp-like (non empty VectSpStr over K);
 let f be homogeneousFAF Form of V,V;
cluster diagker f -> non empty;
  coherence
   proof
      f.[0.V,0.V] = 0.K &
    diagker f = {v where v is Vector of V : f.[v,v] = 0.K} by Def18,Th35;
    then 0.V in diagker f; hence thesis;
   end;
end;


registration
 let K be add-associative right_zeroed right_complementable
       associative left_unital distributive (non empty doubleLoopStr);
 let V be add-associative right_zeroed right_complementable
       VectSp-like (non empty VectSpStr over K);
 let f be homogeneousSAF Form of V,V;
cluster diagker f -> non empty;
 coherence
  proof
     f.[0.V,0.V] = 0.K &
    diagker f = {v where v is Vector of V : f.[v,v] = 0.K} by Def18,Th34;
   then 0.V in diagker f; hence thesis;
  end;
end;


theorem :: BILINEAR:42
  for K be ZeroStr, V be non empty VectSpStr over K
for f be Form of V,V holds
leftker f c= diagker f & rightker f c= diagker f;

theorem :: BILINEAR:43
for K be add-associative right_zeroed right_complementable
       right-distributive (non empty doubleLoopStr)
for V,W be non empty VectSpStr over K
for f be additiveSAF homogeneousSAF Form of V,W
  holds leftker f is lineary-closed;

theorem :: BILINEAR:44
for K be add-associative right_zeroed right_complementable
       right-distributive (non empty doubleLoopStr)
for V,W be non empty VectSpStr over K
for f be additiveFAF homogeneousFAF Form of V,W
  holds rightker f is lineary-closed;

definition
 let K be add-associative right_zeroed right_complementable
       Abelian associative left_unital distributive (non empty doubleLoopStr);
 let V be VectSp of K, W be non empty VectSpStr over K;
 let f be additiveSAF homogeneousSAF Form of V,W;
func LKer f -> strict non empty Subspace of V means
:: BILINEAR:def 19
     the carrier of it = leftker f;
end;


definition
 let K be add-associative right_zeroed right_complementable
       Abelian associative left_unital distributive (non empty doubleLoopStr);
 let V be non empty VectSpStr over K, W be VectSp of K;
 let f be additiveFAF homogeneousFAF Form of V,W;
func RKer f -> strict non empty Subspace of W means
:: BILINEAR:def 20
     the carrier of it = rightker f;
end;


definition
 let K be add-associative right_zeroed right_complementable
       Abelian associative left_unital distributive (non empty doubleLoopStr);
 let V be VectSp of K, W be non empty VectSpStr over K;
 let f be additiveSAF homogeneousSAF Form of V,W;
func LQForm(f) -> additiveSAF homogeneousSAF Form of VectQuot(V,LKer f),W means
:: BILINEAR:def 21

for A be Vector of VectQuot(V,LKer(f)), w be Vector of W, v be Vector of V
st A = v + LKer(f) holds it.[A,w] = f.[v,w];
end;


definition
 let K be add-associative right_zeroed right_complementable
       Abelian associative left_unital distributive (non empty doubleLoopStr);
 let V be non empty VectSpStr over K, W be VectSp of K;
 let f be additiveFAF homogeneousFAF Form of V,W;
func RQForm(f) -> additiveFAF homogeneousFAF Form of V,VectQuot(W,RKer f) means
:: BILINEAR:def 22

for A be Vector of VectQuot(W,RKer(f)), v be Vector of V, w be Vector of W
st A = w + RKer(f) holds it.[v,A] = f.[v,w];
end;


registration
 let K be add-associative right_zeroed right_complementable
       Abelian associative left_unital distributive (non empty doubleLoopStr);
 let V,W be VectSp of K;
 let f be bilinear-Form of V,W;
cluster LQForm(f) -> additiveFAF homogeneousFAF;
 coherence
  proof
   set lf = LQForm(f);
   thus LQForm(f) is additiveFAF
    proof
     let A be Vector of VectQuot(V,LKer(f));
     set flf = FunctionalFAF(lf,A);
     consider v be Vector of V such that
    A1: A = v + LKer(f) by VECTSP10:23;
     let w,t be Vector of W;
     thus flf.(w+t) = lf.[A,w+t] by Th9
     .= f.[v,w+t] by A1,Def21
     .= f.[v,w]+f.[v,t] by Th28
     .= lf.[A,w]+ f.[v,t] by A1,Def21
     .= lf.[A,w]+ lf.[A,t] by A1,Def21
     .= flf.w+ lf.[A,t] by Th9
     .= flf.w + flf.t by Th9;
    end;
   let A be Vector of VectQuot(V,LKer(f));
   set flf = FunctionalFAF(lf,A);
   consider v be Vector of V such that
  A2: A = v + LKer(f) by VECTSP10:23;
   let w be Vector of W, r be Scalar of W;
   thus flf.(r*w) = lf.[A,r*w] by Th9
    .= f.[v,r*w] by A2,Def21
    .= r*f.[v,w] by Th33
    .= r*lf.[A,w] by A2,Def21
    .= r*flf.w by Th9;
  end;
cluster RQForm(f) -> additiveSAF homogeneousSAF;
 coherence
  proof
   set lf = RQForm(f);
   thus RQForm(f) is additiveSAF
    proof
     let A be Vector of VectQuot(W,RKer(f));
     set flf = FunctionalSAF(lf,A);
     consider w be Vector of W such that
    A3: A = w + RKer(f) by VECTSP10:23;
     let v,t be Vector of V;
     thus flf.(v+t) = lf.[v+t,A] by Th10
     .= f.[v+t,w] by A3,Def22
     .= f.[v,w]+f.[t,w] by Th27
     .= lf.[v,A]+ f.[t,w] by A3,Def22
     .= lf.[v,A]+ lf.[t,A] by A3,Def22
     .= flf.v+ lf.[t,A] by Th10
     .= flf.v + flf.t by Th10;
    end;
   let A be Vector of VectQuot(W,RKer(f));
   set flf = FunctionalSAF(lf,A);
   consider w be Vector of W such that
  A4: A = w + RKer(f) by VECTSP10:23;
   let v be Vector of V, r be Scalar of V;
   thus flf.(r*v) = lf.[r*v,A] by Th10
    .= f.[r*v,w] by A4,Def22
    .= r*f.[v,w] by Th32
    .= r*lf.[v,A] by A4,Def22
    .= r*flf.v by Th10;
  end;
end;


definition
 let K be add-associative right_zeroed right_complementable
       Abelian associative left_unital distributive (non empty doubleLoopStr);
 let V,W be VectSp of K;
 let f be bilinear-Form of V,W;
func QForm(f) -> bilinear-Form of VectQuot(V,LKer(f)),VectQuot(W,RKer(f)) means
:: BILINEAR:def 23

for A be Vector of VectQuot(V,LKer f), B be Vector of VectQuot(W, RKer(f))
 for v be Vector of V, w be Vector of W
 st A = v + LKer f & B = w + RKer f holds it.[A,B]= f.[v,w];
end;


theorem :: BILINEAR:45
for K be add-associative right_zeroed right_complementable
       Abelian associative left_unital distributive (non empty doubleLoopStr)
for V be VectSp of K, W be non empty VectSpStr over K
for f be additiveSAF homogeneousSAF Form of V,W holds
rightker f = rightker (LQForm f);

theorem :: BILINEAR:46
for K be add-associative right_zeroed right_complementable
       Abelian associative left_unital distributive (non empty doubleLoopStr)
for V be non empty VectSpStr over K, W be VectSp of K
for f be additiveFAF homogeneousFAF Form of V,W holds
leftker f = leftker (RQForm f);

theorem :: BILINEAR:47
for K be add-associative right_zeroed right_complementable
       Abelian associative left_unital distributive (non empty doubleLoopStr)
for V,W be VectSp of K, f be bilinear-Form of V,W holds
RKer f = RKer (LQForm f);

theorem :: BILINEAR:48
for K be add-associative right_zeroed right_complementable
       Abelian associative left_unital distributive (non empty doubleLoopStr)
for V,W be VectSp of K, f be bilinear-Form of V,W holds
LKer f = LKer (RQForm f);

theorem :: BILINEAR:49
for K be add-associative right_zeroed right_complementable
    Abelian associative left_unital distributive (non empty doubleLoopStr)
for V,W be VectSp of K, f be bilinear-Form of V,W
 holds QForm(f) = RQForm(LQForm(f)) & QForm(f) = LQForm(RQForm(f));

theorem :: BILINEAR:50
for K be add-associative right_zeroed right_complementable
    Abelian associative left_unital distributive (non empty doubleLoopStr)
for V,W be VectSp of K, f be bilinear-Form of V,W holds
 leftker QForm(f) = leftker (RQForm(LQForm(f))) &
 rightker QForm(f) = rightker (RQForm(LQForm(f))) &
 leftker QForm(f) = leftker (LQForm(RQForm(f))) &
 rightker QForm(f) = rightker (LQForm(RQForm(f)));

theorem :: BILINEAR:51
for K be add-associative right_zeroed right_complementable
      distributive (non empty doubleLoopStr)
for V,W be non empty VectSpStr over K
for f be Functional of V, g be Functional of W
 holds ker f c= leftker FormFunctional(f,g);

theorem :: BILINEAR:52
for K be add-associative right_zeroed right_complementable associative
 commutative left_unital Field-like distributive (non empty doubleLoopStr)
for V, W be non empty VectSpStr over K
for f be Functional of V, g be Functional of W
st g <> 0Functional(W) holds leftker FormFunctional(f,g) = ker f;

theorem :: BILINEAR:53
for K be add-associative right_zeroed right_complementable distributive
     (non empty doubleLoopStr)
for V,W be non empty VectSpStr over K
for f be Functional of V, g be Functional of W
 holds ker g c= rightker FormFunctional(f,g);

theorem :: BILINEAR:54
for K be add-associative right_zeroed right_complementable associative
   commutative left_unital Field-like distributive (non empty doubleLoopStr)
for V, W be non empty VectSpStr over K
for f be Functional of V, g be Functional of W
st f <> 0Functional(V) holds rightker FormFunctional(f,g) = ker g;

theorem :: BILINEAR:55
for K be add-associative right_zeroed right_complementable commutative Abelian
      associative left_unital distributive Field-like (non empty doubleLoopStr)
for V be VectSp of K, W be non empty VectSpStr over K
for f be linear-Functional of V, g be Functional of W
st g <> 0Functional(W) holds
  LKer FormFunctional(f,g) = Ker f &
  LQForm(FormFunctional(f,g)) = FormFunctional(CQFunctional(f),g);

theorem :: BILINEAR:56
for K be add-associative right_zeroed right_complementable commutative Abelian
    associative left_unital distributive Field-like (non empty doubleLoopStr)
for V be non empty VectSpStr over K, W be VectSp of K
for f be Functional of V, g be linear-Functional of W
st f <> 0Functional(V) holds
  RKer FormFunctional(f,g) = Ker g &
 RQForm(FormFunctional(f,g)) = FormFunctional(f,CQFunctional(g));

theorem :: BILINEAR:57
  for K be Field, V,W be non trivial VectSp of K
for f be non constant linear-Functional of V,
    g be non constant linear-Functional of W holds
QForm(FormFunctional(f,g)) = FormFunctional(CQFunctional(f),CQFunctional(g));

definition
 let K be ZeroStr;
 let V,W be non empty VectSpStr over K;
 let f be Form of V,W;
attr f is degenerated-on-left means
:: BILINEAR:def 24
 leftker f <> {0.V};
attr f is degenerated-on-right means
:: BILINEAR:def 25
 rightker f <> {0.W};
end;


registration
 let K be add-associative right_zeroed right_complementable
       Abelian associative left_unital distributive (non empty doubleLoopStr);
 let V be VectSp of K, W be right_zeroed (non empty VectSpStr over K);
 let f be additiveSAF homogeneousSAF Form of V,W;
 cluster LQForm(f) -> non degenerated-on-left;
  coherence
   proof
    set qf = LQForm(f), L = LKer f, qV = VectQuot(V,L);
    A1: leftker qf =
       {v where v is Vector of qV : for w be Vector of W holds qf.[v,w] = 0.K}
        by Def16;
    A2: leftker f =
       {v where v is Vector of V : for w be Vector of W holds f.[v,w] = 0.K}
        by Def16;
    thus leftker qf c= {0.qV}
     proof
      let x be set; assume x in leftker qf;
      then consider vv be Vector of qV such that
     A3: x= vv & for w be Vector of W holds qf.[vv,w]=0.K by A1;
      consider v be Vector of V such that
     A4: vv = v + L by VECTSP10:23;
          now let w be Vector of W;
         thus f.[v,w] = qf.[vv,w] by A4,Def21
         .= 0.K by A3;
        end;
       then v in leftker f by A2;
       then v in the carrier of L by Def19;
       then v in L by RLVECT_1:def 1;
       then v+L = the carrier of L by VECTSP_4:64
       .= zeroCoset(V,L) by VECTSP10:def 4
       .= 0.qV by VECTSP10:22;
       hence thesis by A3,A4,TARSKI:def 1;
     end;
    let x be set; assume x in {0.qV};
    then A5: x = 0.qV by TARSKI:def 1;
      for w be Vector of W holds qf.[0.qV,w] = 0.K by Th31;
    hence thesis by A1,A5;
   end;
end;


registration
 let K be add-associative right_zeroed right_complementable
       Abelian associative left_unital distributive (non empty doubleLoopStr);
 let V be right_zeroed (non empty VectSpStr over K), W be VectSp of K;
 let f be additiveFAF homogeneousFAF Form of V,W;
 cluster RQForm(f) -> non degenerated-on-right;
  coherence
  proof
    set qf = RQForm(f), R = RKer f, qW = VectQuot(W,R);
    A1: rightker qf =
       {w where w is Vector of qW : for v be Vector of V holds qf.[v,w] = 0.K}
        by Def17;
    A2: rightker f =
       {w where w is Vector of W : for v be Vector of V holds f.[v,w] = 0.K}
        by Def17;
    thus rightker qf c= {0.qW}
     proof
      let x be set; assume x in rightker qf;
      then consider ww be Vector of qW such that
     A3: x= ww & for v be Vector of V holds qf.[v,ww]=0.K by A1;
      consider w be Vector of W such that
     A4: ww = w + R by VECTSP10:23;
          now let v be Vector of V;
         thus f.[v,w] = qf.[v,ww] by A4,Def22
         .= 0.K by A3;
        end;
       then w in rightker f by A2;
       then w in the carrier of R by Def20;
       then w in R by RLVECT_1:def 1;
       then w+R = the carrier of R by VECTSP_4:64
       .= zeroCoset(W,R) by VECTSP10:def 4
       .= 0.qW by VECTSP10:22;
       hence thesis by A3,A4,TARSKI:def 1;
     end;
    let x be set; assume x in {0.qW};
    then A5: x = 0.qW by TARSKI:def 1;
      for v be Vector of V holds qf.[v,0.qW] = 0.K by Th30;
    hence thesis by A1,A5;
 end;
end;


registration
 let K be add-associative right_zeroed right_complementable
       Abelian associative left_unital distributive (non empty doubleLoopStr);
 let V,W be VectSp of K;
 let f be bilinear-Form of V,W;
 cluster QForm(f) -> non degenerated-on-left non degenerated-on-right;
  coherence
   proof
   A1: leftker RQForm(LQForm(f)) = leftker QForm(f) &
       rightker LQForm(RQForm(f)) = rightker QForm(f) by Th50;
      leftker LQForm(f) = {0.(VectQuot(V,LKer f))} by Def24;
   then A2: leftker RQForm(LQForm(f)) = {0.(VectQuot(V,LKer f))} by Th46;
      rightker RQForm(f) = {0.(VectQuot(W,RKer f))} by Def25;
    then rightker LQForm(RQForm(f)) = {0.(VectQuot(W,RKer f))} by Th45;
    hence thesis by A1,A2,Def24,Def25;
  end;
end;


registration
 let K be add-associative right_zeroed right_complementable
       Abelian associative left_unital distributive (non empty doubleLoopStr);
 let V,W be VectSp of K;
 let f be bilinear-Form of V,W;
cluster RQForm(LQForm(f)) -> non degenerated-on-left non degenerated-on-right;
 coherence
  proof
     leftker LQForm(f) = {0.(VectQuot(V,LKer f))} by Def24;
   then leftker RQForm(LQForm(f)) = {0.(VectQuot(V,LKer f))} by Th46;
   hence thesis by Def24;
  end;
cluster LQForm(RQForm(f)) -> non degenerated-on-left non degenerated-on-right;
 coherence
 proof
     rightker RQForm(f) = {0.(VectQuot(W,RKer f))} by Def25;
   then rightker LQForm(RQForm(f)) = {0.(VectQuot(W,RKer f))} by Th45;
   hence thesis by Def25;
  end;
end;


registration
 let K be Field;
 let V,W be non trivial VectSp of K;
 let f be non constant bilinear-Form of V,W;
 cluster QForm(f) -> non constant;
coherence
 proof
  consider v be Vector of V, w be Vector of W such that
 A1: f.[v,w] <> 0.K by Th41;
  reconsider A = v +LKer f as Vector of VectQuot(V,LKer(f)) by VECTSP10:24;
  reconsider B = w + RKer f as Vector of VectQuot(W,RKer(f)) by VECTSP10:24;
    (QForm(f)).[A,B] = f.[v,w] by Def23;
  hence thesis by A1,Th41;
 end;
end;


begin
:: Bilinear Symmetric and Alternating Forms

definition
 let K be 1-sorted;
 let V be VectSpStr over K;
 let f be Form of V,V;
attr f is symmetric means
:: BILINEAR:def 26
 for v,w be Vector of V holds f.[v,w] = f.[w,v];
end;


definition
 let K be ZeroStr;
 let V be VectSpStr over K;
 let f be Form of V,V;
attr f is alternating means
:: BILINEAR:def 27
 for v be Vector of V holds f.[v,v] = 0.K;
end;


registration
 let K be non empty ZeroStr;
 let V be non empty VectSpStr over K;
cluster NulForm(V,V) -> symmetric;
 coherence
  proof
   let v,w be Vector of V;
   thus NulForm(V,V).[v,w] = 0.K by Th1
    .= NulForm(V,V).[w,v] by Th1;
  end;
cluster NulForm(V,V) -> alternating;
 coherence
  proof
   let v be Vector of V;
   thus NulForm(V,V).[v,v] = 0.K by Th1;
  end;
end;


registration
 let K be non empty ZeroStr;
 let V be non empty VectSpStr over K;
cluster symmetric Form of V,V;
 existence proof take NulForm(V,V); thus thesis; end;
cluster alternating Form of V,V;
 existence proof take NulForm(V,V); thus thesis; end;
end;


registration
 let K be add-associative right_zeroed right_complementable
         right-distributive (non empty doubleLoopStr);
 let V be non empty VectSpStr over K;
cluster symmetric
         additiveFAF homogeneousFAF additiveSAF homogeneousSAF Form of V,V;
 existence proof take NulForm(V,V); thus thesis; end;
cluster alternating
         additiveFAF homogeneousFAF additiveSAF homogeneousSAF Form of V,V;
 existence proof take NulForm(V,V); thus thesis; end;
end;


registration
 let K be Field;
 let V be non trivial VectSp of K;
cluster symmetric non trivial non constant
         additiveFAF homogeneousFAF additiveSAF homogeneousSAF Form of V,V;
 existence
  proof
   consider f be non constant non trivial linear-Functional of V;
   take ff = FormFunctional(f,f);
      now let v,w be Vector of V;
     thus ff.[v,w]= f.v * f.w by Def11
      .= ff.[w,v] by Def11;
    end;
   hence thesis by Def26;
  end;
end;


registration
 let K be add-associative right_zeroed right_complementable
       (non empty LoopStr);
 let V be non empty VectSpStr over K;
cluster alternating additiveFAF additiveSAF Form of V,V;
 existence proof take NulForm(V,V); thus thesis; end;
end;


registration
 let K be non empty LoopStr;
 let V be non empty VectSpStr over K;
 let f,g be symmetric Form of V,V;
cluster f+g -> symmetric;
coherence
 proof
  let v,w be Vector of V;
  thus (f+g).[v,w] = f.[v,w] + g.[v,w] by Def3
  .= f.[w,v] + g.[v,w] by Def26
  .= f.[w,v] + g.[w,v] by Def26
  .= (f+g).[w,v] by Def3;
 end;
end;


registration
 let K be non empty doubleLoopStr;
 let V be non empty VectSpStr over K;
 let f be symmetric Form of V,V;
 let a be Element of K;
cluster a*f -> symmetric;
 coherence
  proof
   let v,w be Vector of V;
   thus (a*f).[v,w] = a*f.[v,w] by Def4
  .= a*f.[w,v] by Def26
  .= (a*f).[w,v] by Def4;
 end;
end;


registration
 let K be non empty LoopStr;
 let V be non empty VectSpStr over K;
 let f be symmetric Form of V,V;
cluster -f -> symmetric;
 coherence
  proof
   let v,w be Vector of V;
   thus (-f).[v,w] = -f.[v,w] by Def5
  .= -f.[w,v] by Def26
  .= (-f).[w,v] by Def5;
 end;
end;


registration
 let K be non empty LoopStr;
 let V be non empty VectSpStr over K;
 let f,g be symmetric Form of V,V;
cluster f-g -> symmetric;
 coherence proof f-g = f+-g by Def7; hence thesis; end;
end;


registration
 let K be right_zeroed (non empty LoopStr);
 let V be non empty VectSpStr over K;
 let f,g be alternating Form of V,V;
cluster f+g -> alternating;
coherence
 proof
  let v be Vector of V;
  thus (f+g).[v,v] = f.[v,v] + g.[v,v] by Def3
  .= 0.K + g.[v,v] by Def27
  .= 0.K + 0.K by Def27
  .= 0.K by RLVECT_1:def 7;
 end;
end;


registration
 let K be add-associative right_zeroed right_complementable
       right-distributive (non empty doubleLoopStr);
 let V be non empty VectSpStr over K;
 let f be alternating Form of V,V;
 let a be Scalar of K;
cluster a*f -> alternating;
 coherence
  proof
   let v be Vector of V;
   thus (a*f).[v,v] = a*f.[v,v] by Def4
  .= a*0.K by Def27
  .= 0.K by VECTSP_1:36;
 end;
end;


registration
 let K be add-associative right_zeroed right_complementable
       (non empty LoopStr);
 let V be non empty VectSpStr over K;
 let f be alternating Form of V,V;
cluster -f -> alternating;
 coherence
  proof
   let v be Vector of V;
   thus (-f).[v,v] = -f.[v,v] by Def5
  .= -0.K by Def27
  .= 0.K by RLVECT_1:25;
 end;
end;


registration
 let K be add-associative right_zeroed right_complementable
      (non empty LoopStr);
 let V be non empty VectSpStr over K;
 let f,g be alternating Form of V,V;
cluster f-g -> alternating;
 coherence proof f-g = f+-g by Def7; hence thesis; end;
end;


theorem :: BILINEAR:58
  for K be add-associative right_zeroed right_complementable
       right-distributive (non empty doubleLoopStr)
for V be non empty VectSpStr over K
for f be symmetric bilinear-Form of V,V holds
 leftker f = rightker f;

theorem :: BILINEAR:59
for K be add-associative right_zeroed right_complementable
    (non empty LoopStr)
for V be non empty VectSpStr over K
for f be alternating additiveSAF additiveFAF Form of V,V
for v,w be Vector of V holds f.[v,w]=-f.[w,v];

definition
 let K be Fanoian Field;
 let V be non empty VectSpStr over K;
 let f be additiveSAF additiveFAF Form of V,V;
redefine attr f is alternating means
:: BILINEAR:def 28
   for v,w be Vector of V holds f.[v,w] = -f.[w,v];
end;


theorem :: BILINEAR:60
  for K be add-associative right_zeroed right_complementable
       right-distributive (non empty doubleLoopStr)
for V be non empty VectSpStr over K
for f be alternating bilinear-Form of V,V holds
 leftker f = rightker f;
