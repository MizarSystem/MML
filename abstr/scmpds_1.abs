:: A Small Computer Model with Push-Down Stack
::  by JingChao Chen
::
:: Received June 15, 1999
:: Copyright (c) 1999 Association of Mizar Users

environ

 vocabularies GR_CY_1, AMI_2, INT_1, FINSEQ_1, FUNCT_1, RELAT_1, TARSKI, BOOLE,
      NAT_1, CARD_3, AMI_1, FUNCT_4, CAT_1, ABSVALUE, ARYTM_1, MCART_1,
      CQC_LANG, FUNCT_2, FUNCT_5, SCMPDS_1, FINSEQ_4;
 notations TARSKI, XBOOLE_0, ENUMSET1, ZFMISC_1, SUBSET_1, RELAT_1, FUNCT_1,
      CARD_1, FUNCT_2, BINOP_1, MCART_1, NUMBERS, XCMPLX_0, CARD_3, INT_1,
      NAT_1, NAT_D, FINSEQ_1, FRAENKEL, FINSEQ_4, FUNCOP_1, FUNCT_4, CAT_2,
      AMI_2, INT_2, XXREAL_0;
 constructors ENUMSET1, XXREAL_0, REAL_1, NAT_1, NAT_D, MEMBERED, INT_2,
      FINSEQ_4, CAT_2, AMI_1, AMI_2, DOMAIN_1;
 registrations XBOOLE_0, SUBSET_1, SETFAM_1, ORDINAL1, RELSET_1, FUNCOP_1,
      FRAENKEL, NUMBERS, XREAL_0, NAT_1, INT_1, MEMBERED, FINSEQ_1, CARD_3,
      GR_CY_1, AMI_2, AFINSQ_1;
 requirements NUMERALS, REAL, SUBSET, BOOLE, ARITHM;


begin :: Preliminaries

reserve x1,x2,x3,x4,x5 for set,
        i, j, k for Element of NAT,
        I,I2,I3,I4 for Element of Segm 14,
        i1 for Element of SCM-Instr-Loc,
        d1,d2,d3,d4,d5 for Element of SCM-Data-Loc,
        k1,k2 for Integer;

reserve ND for non empty set;
reserve y1,y2,y3,y4,y5 for Element of ND;
reserve p for FinSequence;

canceled 8;

theorem :: SCMPDS_1:9
 for k be Integer holds k in union {INT} \/ SCM-Memory;

theorem :: SCMPDS_1:10
 for k be Integer holds k in SCM-Data-Loc \/ INT;

theorem :: SCMPDS_1:11
  for d be Element of SCM-Data-Loc holds d in SCM-Data-Loc \/ INT;

begin  :: The construction of SCM with Push-Down Stack
:: [0,goto L]
:: [1,return sp<-sp+0,count<-(sp)+2]
:: [2,a:=c(constant)]
:: [3,saveIC (a,k)]
:: [4,if(a,k)<>0 goto L ]
:: [5,if(a,k)<=0 goto L ]
:: [6,if(a,k)>=0 goto L ]
:: [7,(a,k):=c(constant) ]
:: [8,(a,k1)+k2]
:: [9, (a1,k1)+(a2,k2)]
:: [10,(a1,k1)-(a2,k2)]
:: [11,(a1,k1)*(a2,k2)]
:: [12,(a1,k1)/(a2,k2)]
:: [13,(a1,k1):=(a2,k2)]

definition
 canceled 2;

 func SCMPDS-Instr ->
          Subset of [: NAT, (union {INT} \/ SCM-Memory)* :] equals
:: SCMPDS_1:def 3
   { [0,<*l*>] where l is Element of INT: not contradiction} \/
  { [1,<*sp*>] where sp is Element of SCM-Data-Loc:not contradiction} \/
  { [I,<*v,c*>] where I is Element of Segm 14,v is Element of SCM-Data-Loc,
         c is Element of INT: I in {2,3} } \/
  { [I,<*v,c1,c2*>] where I is Element of Segm 14,
                    v is Element of SCM-Data-Loc,
                    c1,c2 is Element of INT: I in {4,5,6,7,8} } \/
  { [I,<*v1,v2,c1,c2*>] where I is Element of Segm 14,
                    v1,v2 is Element of SCM-Data-Loc,
                    c1,c2 is Element of INT: I in {9,10,11,12,13} };
end;

canceled;

theorem :: SCMPDS_1:13
 [0,<*0*>] in SCMPDS-Instr;

registration
 cluster SCMPDS-Instr -> non empty;
end;

theorem :: SCMPDS_1:14
 for k being Element of SCM-Memory
 holds k = NAT or k in SCM-Data-Loc or k in SCM-Instr-Loc;

canceled;

theorem :: SCMPDS_1:16
  ((ex j st k = 2*j+1) implies k<>0 & not (ex j st k = 2*j+2)) &
  ((ex j st k = 2*j+2) implies k<>0 & not (ex j st k = 2*j+1));

definition
 func SCMPDS-OK ->
    Function of SCM-Memory, { INT } \/ { SCMPDS-Instr, SCM-Instr-Loc } means
:: SCMPDS_1:def 4
 for k being Element of SCM-Memory holds
   (k = NAT implies it.k = SCM-Instr-Loc) &
   (k in SCM-Data-Loc implies it.k = INT) &
   (k in SCM-Instr-Loc implies it.k = SCMPDS-Instr);
end;

definition
 mode SCMPDS-State is Element of product SCMPDS-OK;
end;

theorem :: SCMPDS_1:17
 SCM-Instr-Loc <> SCMPDS-Instr & SCMPDS-Instr <> INT;

theorem :: SCMPDS_1:18
 for i being Element of SCM-Memory holds
 SCMPDS-OK.i = SCM-Instr-Loc iff i = NAT;

theorem :: SCMPDS_1:19
 for i being Element of SCM-Memory
 holds  SCMPDS-OK.i = INT iff i in SCM-Data-Loc;

theorem :: SCMPDS_1:20
 for i being Element of SCM-Memory
 holds SCMPDS-OK.i = SCMPDS-Instr iff i in SCM-Instr-Loc;

theorem :: SCMPDS_1:21
 SCMPDS-OK.d1 = INT;

theorem :: SCMPDS_1:22
 SCMPDS-OK.i1 = SCMPDS-Instr;

theorem :: SCMPDS_1:23
 pi(product SCMPDS-OK,NAT) = SCM-Instr-Loc;

theorem :: SCMPDS_1:24
 pi(product SCMPDS-OK,d1) = INT;

theorem :: SCMPDS_1:25
   pi(product SCMPDS-OK,i1) = SCMPDS-Instr;

definition let s be SCMPDS-State;
 func IC s -> Element of SCM-Instr-Loc equals
:: SCMPDS_1:def 5
    s.NAT;
end;

definition let s be SCMPDS-State,
               u be Element of SCM-Instr-Loc;
 func SCM-Chg(s,u) -> SCMPDS-State equals
:: SCMPDS_1:def 6
   s +* (NAT .--> u);
end;

theorem :: SCMPDS_1:26
     for s being SCMPDS-State, u being Element of SCM-Instr-Loc
  holds SCM-Chg(s,u).NAT = u;

theorem :: SCMPDS_1:27
     for s being SCMPDS-State, u being Element of SCM-Instr-Loc,
     mk being Element of SCM-Data-Loc
  holds SCM-Chg(s,u).mk = s.mk;

theorem :: SCMPDS_1:28
     for s being SCMPDS-State,
     u, v being Element of SCM-Instr-Loc
  holds SCM-Chg(s,u).v = s.v;

definition let s be SCMPDS-State,
               t be Element of SCM-Data-Loc,
               u be Integer;
 func SCM-Chg(s,t,u) -> SCMPDS-State equals
:: SCMPDS_1:def 7
    s +* (t .--> u);
end;

theorem :: SCMPDS_1:29
     for s being SCMPDS-State, t being Element of SCM-Data-Loc,
     u being Integer
  holds SCM-Chg(s,t,u).NAT = s.NAT;

theorem :: SCMPDS_1:30
     for s being SCMPDS-State, t being Element of SCM-Data-Loc,
     u being Integer
  holds SCM-Chg(s,t,u).t = u;

theorem :: SCMPDS_1:31
     for s being SCMPDS-State, t being Element of SCM-Data-Loc,
     u being Integer,
     mk being Element of SCM-Data-Loc st mk <> t
  holds SCM-Chg(s,t,u).mk = s.mk;

theorem :: SCMPDS_1:32
     for s being SCMPDS-State, t being Element of SCM-Data-Loc,
     u being Integer,
     v being Element of SCM-Instr-Loc
  holds SCM-Chg(s,t,u).v = s.v;

definition let s be SCMPDS-State,
               a be Element of SCM-Data-Loc;
 redefine func s.a -> Integer;
end;

definition let s be SCMPDS-State,
               a be Element of SCM-Data-Loc,
               n be Integer;
 func Address_Add(s,a,n) -> Element of SCM-Data-Loc equals
:: SCMPDS_1:def 8
   [1,abs(s.a+n)];
end;

definition let s be SCMPDS-State,
               n be Integer;
 func jump_address(s,n) -> Element of SCM-Instr-Loc equals
:: SCMPDS_1:def 9
      abs((IC s qua Element of SCM-Instr-Loc)+n);
end;

definition let d be Element of SCM-Data-Loc,
               s be Integer;
 redefine func <*d,s*> -> FinSequence of SCM-Data-Loc \/ INT;
end;

definition let x be Element of SCMPDS-Instr;
 given mk be Element of SCM-Data-Loc, I such that
 x = [ I, <*mk*>];
 func x address_1 -> Element of SCM-Data-Loc means
:: SCMPDS_1:def 10
  ex f being FinSequence of SCM-Data-Loc st f = x`2 & it = f/.1;
end;

theorem :: SCMPDS_1:33
      for x being Element of SCMPDS-Instr, mk being Element of SCM-Data-Loc
  st x = [ I, <*mk*>] holds
 x address_1 = mk;

definition let x be Element of SCMPDS-Instr;
 given r being Integer, I such that
 x = [ I, <*r*>];
 func x const_INT -> Integer means
:: SCMPDS_1:def 11
 ex f being FinSequence of INT st f = x`2 & it = f/.1;
end;

theorem :: SCMPDS_1:34
      for x being Element of SCMPDS-Instr, k being Integer
  st x = [ I, <*k*>] holds
 x const_INT = k;

definition let x be Element of SCMPDS-Instr;
 given mk being Element of SCM-Data-Loc, r being Integer,
       I such that
 x = [ I, <*mk, r*>];
 func x P21address -> Element of SCM-Data-Loc means
:: SCMPDS_1:def 12
 ex f being FinSequence of SCM-Data-Loc \/ INT
   st f = x`2 & it = f/.1;

 func x P22const -> Integer means
:: SCMPDS_1:def 13
 ex f being FinSequence of SCM-Data-Loc \/ INT
  st f = x`2 & it = f/.2;
end;

theorem :: SCMPDS_1:35
     for x being Element of SCMPDS-Instr, mk being Element of SCM-Data-Loc,
     r being Integer st x = [ I, <*mk, r*>] holds
  x P21address = mk & x P22const = r;

definition let x be Element of SCMPDS-Instr;
 given m1 being Element of SCM-Data-Loc,k1,k2 be Integer,I such that
 x = [I, <*m1,k1,k2*>];

 func x P31address -> Element of SCM-Data-Loc means
:: SCMPDS_1:def 14
 ex f being FinSequence of (SCM-Data-Loc \/ INT) st
       f = x`2 & it = f/.1;

  func x P32const -> Integer means
:: SCMPDS_1:def 15
 ex f being FinSequence of (SCM-Data-Loc \/ INT) st
  f = x`2 & it = f/.2;

  func x P33const -> Integer means
:: SCMPDS_1:def 16
   ex f being FinSequence of (SCM-Data-Loc \/ INT) st
   f = x`2 & it = f/.3;
end;

theorem :: SCMPDS_1:36
     for x being Element of SCMPDS-Instr, d1 being Element of SCM-Data-Loc,
     k1,k2 being Integer st x = [ I, <*d1,k1,k2*>] holds
  x P31address = d1 & x P32const = k1 & x P33const = k2;

definition let x be Element of SCMPDS-Instr;
 given m1,m2 being Element of SCM-Data-Loc,k1,k2 be Integer,I such that
 x = [ I, <*m1,m2,k1,k2*>];

 func x P41address -> Element of SCM-Data-Loc means
:: SCMPDS_1:def 17
 ex f being FinSequence of (SCM-Data-Loc \/ INT) st
   f = x`2 & it = f/.1;

   func x P42address -> Element of SCM-Data-Loc means
:: SCMPDS_1:def 18
  ex f being FinSequence of (SCM-Data-Loc \/ INT) st
  f = x`2 & it = f/.2;

  func x P43const -> Integer means
:: SCMPDS_1:def 19
  ex f being FinSequence of (SCM-Data-Loc \/ INT) st
  f = x`2 & it = f/.3;

  func x P44const -> Integer means
:: SCMPDS_1:def 20
  ex f being FinSequence of (SCM-Data-Loc \/ INT) st
  f = x`2 & it = f/.4;
end;

theorem :: SCMPDS_1:37
     for x being Element of SCMPDS-Instr, d1,d2 being Element of SCM-Data-Loc,
     k1,k2 being Integer st x = [ I, <*d1,d2,k1,k2*>] holds
  x P41address = d1 & x P42address = d2 & x P43const = k1 & x P44const = k2;

definition let s be SCMPDS-State,
           a be Element of SCM-Data-Loc;
 func PopInstrLoc(s,a) -> Element of SCM-Instr-Loc equals
:: SCMPDS_1:def 21
       abs(s.a)+2;
end;

:: RetSP: Return Stack Pointer
:: RetIC: Return Instruction-Counter

definition
   func RetSP -> Element of NAT equals
:: SCMPDS_1:def 22
        0;
   func RetIC -> Element of NAT equals
:: SCMPDS_1:def 23
       1;
end;

definition let x be Element of SCMPDS-Instr,
               s be SCMPDS-State;
 func SCM-Exec-Res (x,s) -> SCMPDS-State equals
:: SCMPDS_1:def 24
      SCM-Chg(s, jump_address(s,x const_INT ))
        if ex k1 st x = [ 0, <*k1*>],
  SCM-Chg(SCM-Chg(s, x P21address, x P22const), Next IC s)
        if ex d1,k1 st x = [ 2, <*d1, k1*>],
  SCM-Chg(SCM-Chg(s, Address_Add(s,x P21address,x P22const),
  IC s qua Element of SCM-Instr-Loc),Next IC s)
        if ex d1,k1 st x = [ 3, <*d1, k1*>],
  SCM-Chg(SCM-Chg(s, x address_1,s.Address_Add(s,x address_1,RetSP)),
  PopInstrLoc(s,Address_Add(s,x address_1,RetIC)) )
        if ex d1 st x = [ 1, <*d1*>],
  SCM-Chg(s, IFEQ(s.Address_Add(s,x P31address,x P32const), 0,
  Next IC s,jump_address(s,x P33const )))
         if ex d1,k1,k2 st x = [ 4, <*d1,k1,k2*>],
  SCM-Chg(s, IFGT(s.Address_Add(s,x P31address,x P32const), 0,
  Next IC s,jump_address(s,x P33const )))
        if ex d1,k1,k2 st x = [ 5, <*d1,k1,k2*>],
  SCM-Chg(s, IFGT(0, s.Address_Add(s,x P31address,x P32const),
  Next IC s,jump_address(s,x P33const )))
        if ex d1,k1,k2 st x = [ 6, <*d1,k1,k2*>],
  SCM-Chg(SCM-Chg(s, Address_Add(s,x P31address,x P32const),
  x P33const), Next IC s)
        if ex d1,k1,k2 st x = [ 7, <*d1,k1,k2*>],
  SCM-Chg(SCM-Chg(s, Address_Add(s,x P31address,x P32const),
  s.Address_Add(s,x P31address,x P32const)+ (x P33const)), Next IC s)
        if ex d1,k1,k2 st x = [ 8, <*d1,k1,k2*>],
  SCM-Chg(SCM-Chg(s, Address_Add(s,x P41address,x P43const),
  s.Address_Add(s,x P41address,x P43const)+
  s.Address_Add(s,x P42address,x P44const)),Next IC s)
      if ex d1,d2,k1,k2 st x = [ 9, <*d1,d2,k1,k2*>],
  SCM-Chg(SCM-Chg(s, Address_Add(s,x P41address,x P43const),
  s.Address_Add(s,x P41address,x P43const) -
  s.Address_Add(s,x P42address,x P44const)),Next IC s)
      if ex d1,d2,k1,k2 st x = [ 10, <*d1,d2,k1,k2*>],
  SCM-Chg(SCM-Chg(s, Address_Add(s,x P41address,x P43const),
  s.Address_Add(s,x P41address,x P43const) *
  s.Address_Add(s,x P42address,x P44const)),Next IC s)
      if ex d1,d2,k1,k2 st x = [ 11, <*d1,d2,k1,k2*>],
  SCM-Chg(SCM-Chg(s, Address_Add(s,x P41address,x P43const),
  s.Address_Add(s,x P42address,x P44const)), Next IC s)
      if ex d1,d2,k1,k2 st x = [13, <*d1,d2,k1,k2*>],
  SCM-Chg(SCM-Chg(
           SCM-Chg(s,Address_Add(s,x P41address,x P43const),
     s.Address_Add(s,x P41address,x P43const) div
     s.Address_Add(s,x P42address,x P44const)),
           Address_Add(s,x P42address,x P44const),
     s.Address_Add(s,x P41address,x P43const) mod
     s.Address_Add(s,x P42address,x P44const)), Next IC s)
     if ex d1,d2,k1,k2 st x = [12, <*d1,d2,k1,k2*>]
  otherwise s;
end;

registration
 let f be Function of SCMPDS-Instr, Funcs(product SCMPDS-OK,
 product SCMPDS-OK ), x be Element of SCMPDS-Instr;
 cluster f.x -> Function-like Relation-like;
end;

definition
 func SCMPDS-Exec ->
      Function of SCMPDS-Instr, Funcs(product SCMPDS-OK, product SCMPDS-OK)
     means
:: SCMPDS_1:def 25
      for x being Element of SCMPDS-Instr, y being SCMPDS-State holds
   (it.x).y = SCM-Exec-Res (x,y);
end;

