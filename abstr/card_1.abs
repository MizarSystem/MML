:: Cardinal Numbers
::  by Grzegorz Bancerek
::
:: Received September 19, 1989
:: Copyright (c) 1990 Association of Mizar Users

environ

 vocabularies ORDINAL1, RELAT_1, FUNCT_1, XBOOLE_0, TARSKI, WELLORD1, WELLORD2,
      ZFMISC_1, ORDINAL2, FUNCOP_1, FINSET_1, SUBSET_1, MCART_1, CARD_1;
 notations TARSKI, XBOOLE_0, ZFMISC_1, SUBSET_1, RELAT_1, ENUMSET1, MCART_1,
      FUNCT_1, FUNCOP_1, WELLORD1, ORDINAL1, ORDINAL2, WELLORD2, FINSET_1;
 constructors ENUMSET1, WELLORD1, WELLORD2, FUNCOP_1, ORDINAL2, FINSET_1;
 registrations XBOOLE_0, SUBSET_1, FUNCT_1, ORDINAL1, FUNCOP_1, FINSET_1;
 requirements NUMERALS, SUBSET, BOOLE;


begin

reserve A,B,C for Ordinal,
  X,X1,Y,Y1,Z,a,b,b1,b2,x,y,z for set,
  R for Relation
  ,
  f,g,h for Function,
  k,m,n for natural number;

notation
  synonym 0 for {};
end;

definition
  let IT be set;
  attr IT is cardinal means
:: CARD_1:def 1

  ex B st IT = B & for A st A,B
  are_equipotent holds B c= A;
end;

registration
  cluster cardinal set;
end;

definition
  mode Cardinal is cardinal set;
end;

registration
  cluster cardinal -> ordinal set;
end;

reserve M,N for Cardinal;

canceled 3;

theorem :: CARD_1:4
  for X ex A st X,A are_equipotent;

canceled 3;

theorem :: CARD_1:8
  M = N iff M,N are_equipotent;

canceled 4;

theorem :: CARD_1:13
  M in N iff M c= N & M <> N;

theorem :: CARD_1:14
  M in N iff not N c= M;

definition
  let X;
  canceled 3;
  func card X -> Cardinal means
:: CARD_1:def 5

  X,it are_equipotent;
  projectivity;
end;

registration
  cluster empty -> cardinal set;
end;

registration
  let X be empty set;
  cluster card X -> empty;
end;

registration
  let X be non empty set;
  cluster card X -> non empty;
end;

canceled 6;

theorem :: CARD_1:21
  X,Y are_equipotent iff card X = card Y;

theorem :: CARD_1:22
  R is well-ordering implies field R,order_type_of R
  are_equipotent;

theorem :: CARD_1:23
  X c= M implies card X c= M;

theorem :: CARD_1:24
  card A c= A;

theorem :: CARD_1:25
  X in M implies card X in M;

theorem :: CARD_1:26
  card X c= card Y iff ex f st f is one-to-one & dom f = X & rng f
  c= Y;

theorem :: CARD_1:27
  X c= Y implies card X c= card Y;

theorem :: CARD_1:28
  card X c= card Y iff ex f st dom f = Y & X c= rng f;

theorem :: CARD_1:29
  not X,bool X are_equipotent;

theorem :: CARD_1:30
  card X in card bool X;

definition
  let X;
  func nextcard X -> Cardinal means
:: CARD_1:def 6

  card X in it & for M st card X in M
  holds it c= M;
end;

canceled;

theorem :: CARD_1:32
  M in nextcard M;

theorem :: CARD_1:33
  card {} in nextcard X;

theorem :: CARD_1:34
  card X = card Y implies nextcard X = nextcard Y;

theorem :: CARD_1:35
  X,Y are_equipotent implies nextcard X = nextcard Y;

theorem :: CARD_1:36
  A in nextcard A;

reserve S for T-Sequence;

definition
  let M;
  attr M is limit_cardinal means
:: CARD_1:def 7

  not ex N st M = nextcard N;
end;

definition
  let A;
  func alef A -> set means
:: CARD_1:def 8

  ex S st it = last S & dom S = succ A & S.{}
= card omega & (for B st succ B in succ A holds S.succ B = nextcard union { S.B
}) & for B st B in succ A & B <> {} & B is limit_ordinal holds S.B = card sup(S
  |B);
end;

registration
  let A;
  cluster alef A -> cardinal;
end;

canceled 2;

theorem :: CARD_1:39
  alef succ A = nextcard alef A;

theorem :: CARD_1:40
  A <> {} & A is limit_ordinal implies for S st dom S = A & for B st B
  in A holds S.B = alef B holds alef A = card sup S;

theorem :: CARD_1:41
  A in B iff alef A in alef B;

theorem :: CARD_1:42
  alef A = alef B implies A = B;

theorem :: CARD_1:43
  A c= B iff alef A c= alef B;

theorem :: CARD_1:44
  X c= Y & Y c= Z & X,Z are_equipotent implies X,Y are_equipotent & Y,Z
  are_equipotent;

theorem :: CARD_1:45
  bool Y c= X implies card Y in card X & not Y,X are_equipotent;

theorem :: CARD_1:46
  X,{} are_equipotent implies X = {};

theorem :: CARD_1:47
  card {} = {};

theorem :: CARD_1:48
  X,{x} are_equipotent iff ex x st X = { x };

theorem :: CARD_1:49
  card X = card { x } iff ex x st X = { x };

theorem :: CARD_1:50
  card { x } = 1;

canceled 7;

theorem :: CARD_1:58
  X misses X1 & Y misses Y1 & X,Y are_equipotent & X1,Y1
  are_equipotent implies X \/ X1,Y \/ Y1 are_equipotent;

theorem :: CARD_1:59
  x in X & y in X implies X \ { x },X \ { y } are_equipotent;

theorem :: CARD_1:60
  X c= dom f & f is one-to-one implies X,f.:X are_equipotent;

theorem :: CARD_1:61
  X,Y are_equipotent & x in X & y in Y implies X \ { x },Y \ { y }
  are_equipotent;

theorem :: CARD_1:62
  succ X, succ Y are_equipotent implies X, Y are_equipotent;

theorem :: CARD_1:63
  n = {} or ex m st n = succ m;

canceled;

theorem :: CARD_1:65
  x in omega implies x is cardinal;

registration
  cluster natural -> cardinal number;
end;

canceled 2;

theorem :: CARD_1:68
  X,Y are_equipotent & X is finite implies Y is finite;

theorem :: CARD_1:69
  n is finite & card n is finite;

canceled;

theorem :: CARD_1:71
  card n = card m implies n = m;

theorem :: CARD_1:72
  card n c= card m iff n c= m;

theorem :: CARD_1:73
  card n in card m iff n in m;

theorem :: CARD_1:74
  X is finite implies ex n st X,n are_equipotent;

canceled;

theorem :: CARD_1:76
  nextcard card n = card succ n;

definition
  let n be natural number;
  redefine func succ n -> Element of omega;
end;

definition
  let X be finite set;
  redefine func card X -> Element of omega;
end;

canceled 5;

theorem :: CARD_1:82
  X is finite implies nextcard X is finite;

scheme :: CARD_1:sch 1

  CardinalInd { Sigma[set] }: for M holds Sigma[M]
provided
 Sigma[{}] and
 for M st Sigma[M] holds Sigma[nextcard M] and
 for M st M <> {} & M is limit_cardinal & for N st N in M holds Sigma
[N] holds Sigma[M];

scheme :: CARD_1:sch 2

  CardinalCompInd { Sigma[set] }: for M holds Sigma[M]
provided
 for M st for N st N in M holds Sigma[N] holds Sigma[M];

theorem :: CARD_1:83
  alef 0 = omega;

registration
  cluster omega -> cardinal number;
end;

theorem :: CARD_1:84
  card omega = omega;

registration
  cluster omega -> limit_cardinal;
end;

registration
  cluster -> finite Element of omega;
end;

registration
  cluster finite Cardinal;
end;

canceled;

theorem :: CARD_1:86
  for M being finite Cardinal ex n st M = card n;

registration
  let X be finite set;
  cluster card X -> finite;
end;

registration
  cluster omega -> infinite;
end;

registration
  cluster infinite set;
end;

registration
  let X be infinite set;
  cluster card X -> infinite;
end;

begin :: The meaning of numerals, 2006.08.25

theorem :: CARD_1:87
  1 = { 0 };

theorem :: CARD_1:88
  2 = { 0,1 };

theorem :: CARD_1:89
  3 = { 0,1,2 };

theorem :: CARD_1:90
  4 = { 0,1,2,3 };

theorem :: CARD_1:91
  5 = { 0,1,2,3,4 };

theorem :: CARD_1:92
  6 = { 0,1,2,3,4,5 };

theorem :: CARD_1:93
  7 = { 0,1,2,3,4,5,6 };

theorem :: CARD_1:94
  8 = { 0,1,2,3,4,5,6,7 };

theorem :: CARD_1:95
  9 = { 0,1,2,3,4,5,6,7,8 };

theorem :: CARD_1:96
  10 = { 0,1,2,3,4,5,6,7,8,9 };

:: Moved from FRECHET2 by AK on 27.12.2006

theorem :: CARD_1:97
  for f being Function st dom f is infinite & f is one-to-one holds rng
  f is infinite;

:: from ALGSEQ_1, 2007.03.18, A.T.

reserve k,n,m for natural number;

definition
  canceled 3;
  let n;
  func Segm n -> set equals
:: CARD_1:def 12
  n;
end;

reserve l for Element of omega;

definition
  let n;
  redefine func Segm n -> Subset of omega;
end;

canceled 4;

:: from CARD_4, 2007.08.16, A.T.

theorem :: CARD_1:102
  A,n are_equipotent implies A = n;

theorem :: CARD_1:103
  A is finite iff A in omega;

registration
  cluster natural -> finite set;
end;

:: from CARD_4, CARD_5 etc. 2008.02.21, A.T.

registration
  let A be infinite set;
  cluster bool A -> infinite;
  let B be non empty set;
  cluster [:A,B:] ->infinite;
  cluster [:B,A:] ->infinite;
end;

registration
  let X be infinite set;
  cluster infinite Subset of X;
end;

:: from NECKLA_2, 2008.06.28, A.T.

registration
  cluster finite ordinal -> natural number;
end;

theorem :: CARD_1:104
  for f being Function holds card f = card dom f;

registration
  let X be finite set;
  cluster RelIncl X -> finite;
end;

:: from AMISTD_2, 2010.01.10, A.T

theorem :: CARD_1:105
  RelIncl X is finite implies X is finite;

