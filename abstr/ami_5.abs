:: On the Decomposition of the States of SCM
::  by Yasushi Tanaka
::
:: Received November 23, 1993
:: Copyright (c) 1993 Association of Mizar Users

environ

 vocabularies NUMBERS, AMI_3, SUBSET_1, AMI_2, AMI_1, STRUCT_0, XBOOLE_0,
      FSM_1, RELAT_1, FUNCT_1, TARSKI, FINSET_1, CARD_1, XXREAL_0, PBOOLE,
      FINSEQ_1, GRAPHSP, ARYTM_3, ARYTM_1, INT_1, FUNCT_4, FUNCOP_1, CIRCUIT2,
      ORDINAL1, PARTFUN1, SCMNORM, RECDEF_2, CAT_1, AMISTD_5, CARD_5, UNIALG_1,
      GLIB_000, AMISTD_2;
 notations TARSKI, XBOOLE_0, SUBSET_1, CARD_1, XCMPLX_0, MCART_1, DOMAIN_1,
      SETFAM_1, PBOOLE, RELAT_1, FUNCT_1, PARTFUN1, FUNCT_4, NUMBERS, INT_1,
      NAT_1, RECDEF_2, STRUCT_0, FINSET_1, FINSEQ_1, COMPOS_1, EXTPRO_1, AMI_1,
      AMI_2, AMI_3, XXREAL_0, AMISTD_5;
 constructors DOMAIN_1, XXREAL_0, FINSEQ_4, AMI_3, AMI_2, NUMBERS, PRE_POLY,
      RECDEF_2, MCART_2, AMISTD_2, AMI_1, AMISTD_5, AMISTD_1, PBOOLE;
 registrations XBOOLE_0, SETFAM_1, RELAT_1, FUNCT_1, ORDINAL1, NUMBERS,
      XREAL_0, INT_1, CARD_3, AMI_1, AMI_2, AMI_3, FINSET_1, CARD_1, RELSET_1,
      FUNCT_2, COMPOS_1, EXTPRO_1, AMISTD_5, PBOOLE;
 requirements NUMERALS, REAL, SUBSET, BOOLE, ARITHM;


begin

canceled 17;

reserve x,y for set;

theorem :: AMI_5:18
  for dl being Data-Location ex i being Element of NAT st dl = dl.i;

canceled;

theorem :: AMI_5:20
  for dl being Data-Location holds dl <> IC SCM;

canceled;

theorem :: AMI_5:22
  for il being Element of NAT, dl being Data-Location
  holds il <> dl;

reserve i, j, k for Element of NAT;

canceled;

theorem :: AMI_5:24
  for s being State of SCM, d being Data-Location
   holds d in dom s;

canceled;

theorem :: AMI_5:26
  for s1,s2 being State of SCM st IC(s1) = IC(s2) & (for a being
  Data-Location holds s1.a = s2.a) & (for i being Element of NAT
  holds s1.i = s2.i) holds s1 = s2;

registration
  cluster Data-Locations SCM -> infinite;
end;

reserve I,J,K for Element of Segm 9,
  a,a1 for Element of NAT,
  b,b1,c for Element of Data-Locations SCM;

canceled 9;

theorem :: AMI_5:36
  for l being Instruction of SCM holds InsCode(l) <= 8;

reserve a, b for Data-Location,
  loc for Element of NAT;

theorem :: AMI_5:37
  InsCode (halt SCM) = 0;

reserve I,J,K for Element of Segm 9,
  a,a1 for Element of NAT,
  b,b1,c for Element of Data-Locations SCM,
  da,db for Data-Location,
  loc for Element of NAT;

canceled 8;

theorem :: AMI_5:46
  for ins being Instruction of SCM st InsCode ins = 0 holds ins =
  halt SCM;

theorem :: AMI_5:47
  for ins being Instruction of SCM st InsCode ins = 1 holds ex da,
  db st ins = da:=db;

theorem :: AMI_5:48
  for ins being Instruction of SCM st InsCode ins = 2 holds ex da,
  db st ins = AddTo(da,db);

theorem :: AMI_5:49
  for ins being Instruction of SCM st InsCode ins = 3 holds ex da,
  db st ins = SubFrom(da,db);

theorem :: AMI_5:50
  for ins being Instruction of SCM st InsCode ins = 4 holds ex da,
  db st ins = MultBy(da,db);

theorem :: AMI_5:51
  for ins being Instruction of SCM st InsCode ins = 5 holds ex da,
  db st ins = Divide(da,db);

theorem :: AMI_5:52
  for ins being Instruction of SCM st InsCode ins = 6 holds ex loc
  st ins = SCM-goto loc;

theorem :: AMI_5:53
  for ins being Instruction of SCM st InsCode ins = 7 holds ex loc
  ,da st ins = da=0_goto loc;

theorem :: AMI_5:54
  for ins being Instruction of SCM st InsCode ins = 8 holds ex loc
  ,da st ins = da>0_goto loc;

begin :: Finite partial states of SCM

canceled 25;

theorem :: AMI_5:80
  for s being State of SCM, iloc being Element of NAT, a
  being Data-Location holds s.a = (s +* Start-At(iloc,SCM)).a;

begin :: Autonomic finite partial states of SCM

registration
 cluster SCM -> IC-recognized;
end;

registration
 cluster SCM -> CurIns-recognized;
end;

canceled 7;

theorem :: AMI_5:88
  for p being autonomic non NAT-defined FinPartState of SCM,
      s1, s2 being State of SCM st p c= s1 & p c= s2
  for P1,P2 being (the Instructions of SCM)-valued ManySortedSet of NAT
      st ProgramPart p c= P1 & ProgramPart p c= P2
  for i being Element of NAT, da, db being Data-Location,
      I being Instruction of SCM
       st I = CurInstr(P1,Comput(P1,s1,i))
   holds I = da := db & da in dom p implies
    Comput(P1,s1,i).db = Comput(P2,s2,i).db;

theorem :: AMI_5:89
  for p being autonomic non NAT-defined FinPartState of SCM, s1, s2
  being State of SCM st p c= s1 & p c= s2
  for P1,P2 being (the Instructions of SCM)-valued ManySortedSet of NAT
      st ProgramPart p c= P1 & ProgramPart p c= P2
  for i being Element of NAT, da, db
being Data-Location, I being Instruction of SCM st
 I = CurInstr(P1,Comput(P1,
s1,i))
  holds I = AddTo(da, db) & da in dom p implies Comput(P1,s1,i).da
+
  Comput(P1,s1,i).db = Comput(P2,s2,i).da + Comput(
P2,s2,i).db;

theorem :: AMI_5:90
  for p being autonomic non NAT-defined FinPartState of SCM, s1, s2
  being State of SCM st p c= s1 & p c= s2
  for P1,P2 being (the Instructions of SCM)-valued ManySortedSet of NAT
      st ProgramPart p c= P1 & ProgramPart p c= P2
  for i being Element of NAT, da, db
being Data-Location, I being Instruction of SCM st
 I = CurInstr(P1,Comput(P1,
s1,i))
  holds I = SubFrom(da, db) & da in dom p implies Comput(P1,s1,i).
da -
  Comput(P1,s1,i).db = Comput(P2,s2,i).da - Comput(
P2,s2,i).db;

theorem :: AMI_5:91
  for p being autonomic non NAT-defined FinPartState of SCM, s1, s2
  being State of SCM st p c= s1 & p c= s2
  for P1,P2 being (the Instructions of SCM)-valued ManySortedSet of NAT
      st ProgramPart p c= P1 & ProgramPart p c= P2
  for i being Element of NAT, da, db
being Data-Location, I being Instruction of SCM
 st I = CurInstr(P1,Comput(P1,s1,i))
  holds I = MultBy(da, db) & da in dom p implies Comput(P1,s1,i).
da *
  Comput(P1,s1,i).db = Comput(P2,s2,i).da * Comput(
P2,s2,i).db;

theorem :: AMI_5:92
  for p being autonomic non NAT-defined FinPartState of SCM, s1, s2
  being State of SCM st p c= s1 & p c= s2
  for P1,P2 being (the Instructions of SCM)-valued ManySortedSet of NAT
      st ProgramPart p c= P1 & ProgramPart p c= P2
  for i being Element of NAT, da, db
being Data-Location, I being Instruction of SCM
 st I = CurInstr(P1,Comput(P1,s1,i))
  holds I = Divide(da, db) & da in dom p & da <> db implies
   Comput(P1,s1
,i).da div Comput(P1,s1,i).db = Comput(P2,s2,i).da
div Comput(P2,s2,i).db;

theorem :: AMI_5:93
  for p being autonomic non NAT-defined FinPartState of SCM, s1, s2
  being State of SCM st p c= s1 & p c= s2
  for P1,P2 being (the Instructions of SCM)-valued ManySortedSet of NAT
      st ProgramPart p c= P1 & ProgramPart p c= P2
  for i being Element of NAT, da, db
being Data-Location, I being Instruction of SCM st
 I = CurInstr(P1,Comput(P1,s1,i))
  holds I = Divide(da, db) & db in dom p implies Comput(P1,s1,i).
da mod
  Comput(P1,s1,i).db = Comput(P2,s2,i).da mod Comput(P2,s2,i).db;

theorem :: AMI_5:94
  for p being autonomic non NAT-defined FinPartState of SCM, s1, s2
  being State of SCM st p c= s1 & p c= s2
  for P1,P2 being (the Instructions of SCM)-valued ManySortedSet of NAT
      st ProgramPart p c= P1 & ProgramPart p c= P2
  for i being Element of NAT, da being
  Data-Location, loc being Element of NAT, I being Instruction of
SCM st I = CurInstr(P1,Comput(P1,s1,i))
 holds I = da=0_goto loc & loc <> succ
(IC Comput(P1,s1,i)) implies ( Comput(P1,s1,i).da = 0
iff Comput(P2,s2,i)
  .da = 0);

theorem :: AMI_5:95
  for p being autonomic non NAT-defined FinPartState of SCM, s1, s2
  being State of SCM st p c= s1 & p c= s2
  for P1,P2 being (the Instructions of SCM)-valued ManySortedSet of NAT
      st ProgramPart p c= P1 & ProgramPart p c= P2
  for i being Element of NAT, da being
  Data-Location, loc being Element of NAT, I being Instruction of
SCM st I = CurInstr(P1,Comput(P1,s1,i))
 holds I = da>0_goto loc & loc <> succ
(IC Comput(P1,s1,i)) implies ( Comput(P1,s1,i).da > 0
iff Comput(P2,s2,i)
  .da > 0);

