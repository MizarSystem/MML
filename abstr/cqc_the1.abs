:: A First-Order Predicate Calculus.
:: Axiomatics, the Consequence Operation and a Concept of Proof
::  by Agata Darmochwa{\l}
::
:: Received May 25, 1990
:: Copyright (c) 1990-2011 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies NUMBERS, ORDINAL1, SUBSET_1, XXREAL_0, ARYTM_3, XBOOLE_0, TARSKI,
      FINSET_1, CARD_1, MCART_1, ZFMISC_1, CQC_LANG, QC_LANG1, XBOOLEAN,
      BVFUNC_2, FUNCT_1, FINSEQ_1, NAT_1, RELAT_1, ORDINAL4, ARYTM_1, CQC_THE1;
 notations TARSKI, XBOOLE_0, ZFMISC_1, SUBSET_1, ORDINAL1, XCMPLX_0, FUNCT_1,
      NUMBERS, NAT_1, FINSET_1, FINSEQ_1, MCART_1, QC_LANG1, CQC_LANG,
      XXREAL_0;
 constructors XXREAL_0, XREAL_0, NAT_1, CQC_LANG;
 registrations SUBSET_1, RELSET_1, FINSET_1, XXREAL_0, XREAL_0, FINSEQ_1,
      CQC_LANG, ORDINAL1, CARD_1;
 requirements NUMERALS, REAL, BOOLE, SUBSET, ARITHM;


begin

:: --------- Auxiliary theorems

reserve i,j,n,k,l for Element of NAT;
reserve a for set;

theorem :: CQC_THE1:1
  {k: k <= n + 1} = {i: i <= n} \/ {n + 1};

theorem :: CQC_THE1:2
  for n holds {k: k <= n} is finite;

reserve X,Y,Z for set;

theorem :: CQC_THE1:3
  X is finite & X c= [:Y,Z:] implies
  ex A,B being set st A is finite & A c= Y & B is finite & B c= Z &
  X c= [:A,B:];

theorem :: CQC_THE1:4
  X is finite & Z is finite & X c= [:Y,Z:] implies
  ex A being set st A is finite & A c= Y & X c= [:A,Z:];

:: --------- The axiomatic of a first-order calculus

reserve T,S,X,Y for Subset of CQC-WFF;
reserve p,q,r,t,F,H,G for Element of CQC-WFF;
reserve s for QC-formula;
reserve x,y for bound_QC-variable;

definition
  let T;
  attr T is being_a_theory means
:: CQC_THE1:def 1

  VERUM in T & for p,q,r,s,x,y holds
  ('not' p => p) => p in T & p => ('not' p => q) in T &
  (p => q) => ('not'(q '&' r) => 'not'(p '&' r)) in T &
  p '&' q => q '&' p in T & (p in T & p => q in T implies q in T) &
  All(x,p) => p in T &
  (p => q in T & not x in still_not-bound_in p implies p => All(x,q) in T) &
  (s.x in CQC-WFF & s.y in CQC-WFF & not x in still_not-bound_in s & s.x in T
  implies s.y in T);
end;

theorem :: CQC_THE1:5
  T is being_a_theory & S is being_a_theory implies T /\ S is being_a_theory;

:: --------- The consequence operation

definition
  let X;
  func Cn(X) -> Subset of CQC-WFF means
:: CQC_THE1:def 2

  t in it iff for T st T is being_a_theory & X c= T holds t in T;
end;

theorem :: CQC_THE1:6
  VERUM in Cn(X);

theorem :: CQC_THE1:7
  ('not' p => p) => p in Cn(X);

theorem :: CQC_THE1:8
  p => ('not' p => q) in Cn(X);

theorem :: CQC_THE1:9
  (p => q) => ('not'(q '&' r) => 'not'(p '&' r)) in Cn(X);

theorem :: CQC_THE1:10
  p '&' q => q '&' p in Cn(X);

theorem :: CQC_THE1:11
  p in Cn(X) & p => q in Cn(X) implies q in Cn(X);

theorem :: CQC_THE1:12
  All(x,p) => p in Cn(X);

theorem :: CQC_THE1:13
  p => q in Cn(X) & not x in still_not-bound_in p implies
  p => All(x,q) in Cn(X);

theorem :: CQC_THE1:14
  s.x in CQC-WFF & s.y in CQC-WFF & not x in still_not-bound_in s &
  s.x in Cn(X) implies s.y in Cn(X);

theorem :: CQC_THE1:15
  Cn(X) is being_a_theory;

theorem :: CQC_THE1:16
  T is being_a_theory & X c= T implies Cn(X) c= T;

theorem :: CQC_THE1:17
  X c= Cn(X);

theorem :: CQC_THE1:18
  X c= Y implies Cn(X) c= Cn(Y);

theorem :: CQC_THE1:19
  Cn(Cn(X)) = Cn(X);

theorem :: CQC_THE1:20
  T is being_a_theory iff Cn(T) = T;

:: ---------- The notion of proof

definition
  func Proof_Step_Kinds -> set equals
:: CQC_THE1:def 3
  {k: k <= 9};
end;

registration
  cluster Proof_Step_Kinds -> non empty;
end;

theorem :: CQC_THE1:21
  0 in Proof_Step_Kinds & 1 in Proof_Step_Kinds & 2 in Proof_Step_Kinds &
  3 in Proof_Step_Kinds & 4 in Proof_Step_Kinds & 5 in Proof_Step_Kinds &
  6 in Proof_Step_Kinds & 7 in Proof_Step_Kinds & 8 in Proof_Step_Kinds &
  9 in Proof_Step_Kinds;

theorem :: CQC_THE1:22
  Proof_Step_Kinds is finite;

reserve f,g for FinSequence of [:CQC-WFF,Proof_Step_Kinds:];

theorem :: CQC_THE1:23
  for n being Nat holds 1 <= n & n <= len f implies
  (f.n)`2 = 0 or (f.n)`2 = 1 or (f.n)`2 = 2 or (f.n)`2 = 3 or (f.n)`2 = 4
  or (f.n)`2 = 5 or (f.n)`2 = 6 or (f.n)`2 = 7 or (f.n)`2 = 8 or (f.n)`2 = 9;

definition
  let PR be (FinSequence of [:CQC-WFF,Proof_Step_Kinds:]),n be Nat,X;
  pred PR,n is_a_correct_step_wrt X means
:: CQC_THE1:def 4

  (PR.n)`1 in X if (PR.n)`2 = 0, (PR.n)`1 = VERUM if (PR.n)`2 = 1,
  ex p st (PR.n)`1 = ('not' p => p) => p if (PR.n)`2 = 2,
  ex p,q st (PR.n)`1 = p => ('not' p => q) if (PR.n)`2 = 3,
  ex p,q,r st (PR.n)`1 = (p => q) => ('not'(q '&' r) => 'not'(p '&' r))
  if (PR.n)`2 = 4, ex p,q st (PR.n)`1 = p '&' q => q '&' p if (PR.n)`2 = 5,
  ex p,x st (PR.n)`1 = All(x,p) => p if (PR.n)`2 = 6,
  ex i,j,p,q st 1 <= i & i < n & 1 <= j & j < i & p = (PR.j)`1 & q = (PR.n)`1 &
  (PR.i)`1 = p => q if (PR.n)`2 = 7,
  ex i,p,q,x st 1 <= i & i < n & (PR.i)`1 = p => q &
  not x in still_not-bound_in p & (PR.n)`1 = p => All(x,q) if (PR.n)`2 = 8,
  ex i,x,y,s st 1 <= i & i < n & s.x in CQC-WFF & s.y in CQC-WFF &
  not x in still_not-bound_in s & s.x = (PR.i)`1 & s.y = (PR.n)`1
  if (PR.n)`2 = 9;
end;

definition
  let X,f;
  pred f is_a_proof_wrt X means
:: CQC_THE1:def 5

  f <> {} & for n st 1 <= n & n <= len f holds f,n is_a_correct_step_wrt X;
end;

theorem :: CQC_THE1:24
  f is_a_proof_wrt X implies rng f <> {};

theorem :: CQC_THE1:25
  f is_a_proof_wrt X implies 1 <= len f;

theorem :: CQC_THE1:26
  f is_a_proof_wrt X implies (f.1)`2 = 0 or (f.1)`2 = 1 or
  (f.1)`2 = 2 or (f.1)`2 = 3 or (f.1)`2 = 4 or (f.1)`2 = 5 or (f.1)`2 = 6;

theorem :: CQC_THE1:27
  1 <= n & n <= len f implies
  (f,n is_a_correct_step_wrt X iff f^g,n is_a_correct_step_wrt X);

theorem :: CQC_THE1:28
  1 <= n & n <= len g & g,n is_a_correct_step_wrt X implies
  (f^g),(n+len f) is_a_correct_step_wrt X;

theorem :: CQC_THE1:29
  f is_a_proof_wrt X & g is_a_proof_wrt X implies f^g is_a_proof_wrt X;

theorem :: CQC_THE1:30
  f is_a_proof_wrt X & X c= Y implies f is_a_proof_wrt Y;

theorem :: CQC_THE1:31
  f is_a_proof_wrt X & 1 <= l & l <= len f implies (f.l)`1 in Cn(X);

definition
  let f;
  assume
 f <> {};
  func Effect(f) -> Element of CQC-WFF equals
:: CQC_THE1:def 6

  (f.(len f))`1;
end;

theorem :: CQC_THE1:32
  f is_a_proof_wrt X implies Effect(f) in Cn(X);

theorem :: CQC_THE1:33
  X c= {F: ex f st f is_a_proof_wrt X & Effect(f) = F};

theorem :: CQC_THE1:34
  for X holds Y = {p: ex f st f is_a_proof_wrt X & Effect(f) = p}
  implies Y is being_a_theory;

theorem :: CQC_THE1:35
  for X holds {p: ex f st f is_a_proof_wrt X & Effect(f) = p} = Cn(X);

theorem :: CQC_THE1:36
  p in Cn(X) iff ex f st f is_a_proof_wrt X & Effect(f) = p;

theorem :: CQC_THE1:37
  p in Cn(X) implies ex Y st Y c= X & Y is finite & p in Cn(Y);

:: --------- TAUT - the set of all tautologies

definition

  func TAUT -> Subset of CQC-WFF equals
:: CQC_THE1:def 7
  Cn({}(CQC-WFF));
end;

theorem :: CQC_THE1:38
  T is being_a_theory implies TAUT c= T;

theorem :: CQC_THE1:39
  TAUT c= Cn(X);

theorem :: CQC_THE1:40
  TAUT is being_a_theory;

theorem :: CQC_THE1:41
  VERUM in TAUT;

theorem :: CQC_THE1:42
  ('not' p => p) =>p in TAUT;

theorem :: CQC_THE1:43
  p => ('not' p => q) in TAUT;

theorem :: CQC_THE1:44
  (p => q) => ('not'(q '&' r) => 'not' (p '&' r)) in TAUT;

theorem :: CQC_THE1:45
  p '&' q => q '&' p in TAUT;

theorem :: CQC_THE1:46
  p in TAUT & p => q in TAUT implies q in TAUT;

theorem :: CQC_THE1:47
  All(x,p) => p in TAUT;

theorem :: CQC_THE1:48
  p => q in TAUT & not x in still_not-bound_in p implies
  p => All(x,q) in TAUT;

theorem :: CQC_THE1:49
  s.x in CQC-WFF & s.y in CQC-WFF & not x in still_not-bound_in s &
  s.x in TAUT implies s.y in TAUT;

:: --------- Relation of consequence of a set of formulas

definition
  let X,s;
  pred X|-s means
:: CQC_THE1:def 8

  s in Cn(X);
end;

theorem :: CQC_THE1:50
  X |- VERUM;

theorem :: CQC_THE1:51
  X |- ('not' p => p) => p;

theorem :: CQC_THE1:52
  X |- p => ('not' p => q);

theorem :: CQC_THE1:53
  X |- (p => q) => ('not'(q '&' r) => 'not'(p '&' r));

theorem :: CQC_THE1:54
  X |- p '&' q => q '&' p;

theorem :: CQC_THE1:55
  X |- p & X |- p => q implies X |- q;

theorem :: CQC_THE1:56
  X |- All(x,p) => p;

theorem :: CQC_THE1:57
  X |- p => q & not x in still_not-bound_in p implies X |- p => All(x,q);

theorem :: CQC_THE1:58
  s.y in CQC-WFF & not x in still_not-bound_in s & X |- s.x implies X |- s.y;

definition
  let s;
  attr s is valid means
:: CQC_THE1:def 9

  {}(CQC-WFF)|-s;
end;

definition
  let s;
  redefine attr s is valid means
:: CQC_THE1:def 10
  s in TAUT;
end;

theorem :: CQC_THE1:59
  p is valid implies X |- p;

theorem :: CQC_THE1:60
  VERUM is valid;

theorem :: CQC_THE1:61
  ('not' p => p) =>p is valid;

theorem :: CQC_THE1:62
  p => ('not' p => q) is valid;

theorem :: CQC_THE1:63
  (p => q) => ('not'(q '&' r) => 'not'(p '&' r)) is valid;

theorem :: CQC_THE1:64
  p '&' q => q '&' p is valid;

theorem :: CQC_THE1:65
  p is valid & p => q is valid implies q is valid;

theorem :: CQC_THE1:66
  All(x,p) => p is valid;

theorem :: CQC_THE1:67
  p => q is valid & not x in still_not-bound_in p
  implies p => All(x,q) is valid;

theorem :: CQC_THE1:68
  s.y in CQC-WFF & not x in still_not-bound_in s &
  s.x is valid implies s.y is valid;
