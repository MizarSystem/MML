:: Introduction to Modal Propositional Logic
::  by Alicia de la Cruz
::
:: Received September 30, 1991
:: Copyright (c) 1991 Association of Mizar Users

environ

 vocabulary TREES_2, FINSEQ_1, BOOLE, TREES_1, FUNCT_1, RELAT_1, ZFMISC_1,
      PARTFUN1, ORDINAL1, TARSKI, FINSET_1, PRELAMB, CARD_1, FUNCOP_1,
      QC_LANG1, MCART_1, ZF_LANG, SEQ_1, MODAL_1;
 notation TARSKI, XBOOLE_0, ENUMSET1, ZFMISC_1, SUBSET_1, NUMBERS, XREAL_0,
      NAT_1, DOMAIN_1, MCART_1, RELAT_1, FUNCT_1, RELSET_1, FINSEQ_1, FINSEQ_2,
      FUNCT_2, FINSET_1, CARD_1, PARTFUN1, TREES_1, TREES_2, PRELAMB;
 constructors WELLORD2, NAT_1, DOMAIN_1, PARTFUN1, PRELAMB, XREAL_0, MEMBERED,
      XBOOLE_0;
 clusters SUBSET_1, FINSEQ_1, TREES_1, TREES_2, PRELAMB, FINSET_1, RELSET_1,
      XREAL_0, ARYTM_3, MEMBERED, ZFMISC_1, XBOOLE_0, ORDINAL2, NUMBERS;
 requirements NUMERALS, REAL, BOOLE, SUBSET, ARITHM;


begin

reserve x,y,x1,x2,y1,y2,z for set,
        n,m,k for Nat,
        t1 for DecoratedTree of [: NAT,NAT :],
        w,s,t,u for FinSequence of NAT,
        D for non empty set;

definition let Z be Tree;
func Root Z -> Element of Z equals
:: MODAL_1:def 1
 {};
end;


definition let D; let T be DecoratedTree of D;
func Root T -> Element of D equals
:: MODAL_1:def 2
  T.(Root dom T);
end;


canceled 2;

theorem :: MODAL_1:3
n <> m implies not <*n*>,<*m*>^s are_c=-comparable;

theorem :: MODAL_1:4
for s st s <> {} ex w,n st s = <*n*>^w;

theorem :: MODAL_1:5
n <> m implies not <*n*> is_a_proper_prefix_of <*m*>^s;

theorem :: MODAL_1:6
n <> m implies not <*n*> is_a_prefix_of <*m*>^s;

theorem :: MODAL_1:7
not <*n*> is_a_proper_prefix_of <*m*>;

canceled;

theorem :: MODAL_1:9
elementary_tree 1 = {{},<*0*>};

theorem :: MODAL_1:10
elementary_tree 2 = {{},<*0*>,<*1*>};

theorem :: MODAL_1:11
for Z being Tree,n,m st n <= m & <*m*> in Z holds <*n*> in Z;

theorem :: MODAL_1:12
w^t is_a_proper_prefix_of w^s implies t is_a_proper_prefix_of s;

theorem :: MODAL_1:13
t1 in PFuncs(NAT*,[: NAT,NAT :]);

canceled;

theorem :: MODAL_1:15
for Z,Z1,Z2 being Tree,z being Element of Z st
  Z with-replacement (z,Z1) = Z with-replacement (z,Z2) holds Z1 = Z2;

theorem :: MODAL_1:16
for Z,Z1,Z2 being DecoratedTree of D,z being Element of dom Z
  st Z with-replacement (z,Z1) = Z with-replacement (z,Z2) holds Z1 = Z2;

theorem :: MODAL_1:17
for Z1,Z2 being Tree,p being FinSequence of NAT st p in Z1 holds
for v being Element of Z1 with-replacement (p,Z2), w being Element of Z1
st v = w & w is_a_proper_prefix_of p holds succ v = succ w;

theorem :: MODAL_1:18
for Z1,Z2 being Tree,p being FinSequence of NAT st p in Z1 holds
for v being Element of Z1 with-replacement (p,Z2),w being Element of Z1
st v = w & not p,w are_c=-comparable holds succ v = succ w;

theorem :: MODAL_1:19
for Z1,Z2 being Tree,p being FinSequence of NAT st p in Z1 holds
  for v being Element of Z1 with-replacement (p,Z2),w being Element of Z2
     st v = p^w holds succ v,succ w are_equipotent;

theorem :: MODAL_1:20
for Z1 being Tree,p being FinSequence of NAT st p in Z1 holds
  for v being Element of Z1,w being Element of Z1|p
     st v = p^w holds succ v,succ w are_equipotent;

canceled;

theorem :: MODAL_1:22
for Z being finite Tree st branchdeg (Root Z) = 0 holds
   card Z = 1 & Z = {{}};

theorem :: MODAL_1:23
for Z being finite Tree st branchdeg (Root Z) = 1 holds
     succ (Root Z) = { <*0*> };

theorem :: MODAL_1:24
for Z being finite Tree st branchdeg (Root Z) = 2 holds
      succ (Root Z) = { <*0*>,<*1*> };

reserve s',w',v' for Element of NAT*;

theorem :: MODAL_1:25
for Z being Tree,o being Element of Z st o <> Root Z holds
  Z|o,{ o^s': o^s' in Z } are_equipotent &
  not Root Z in { o^w' : o^w' in Z };

theorem :: MODAL_1:26
for Z being finite Tree,o being Element of Z st o <> Root Z holds
 card (Z|o) < card Z;

theorem :: MODAL_1:27
for Z being finite Tree,z being Element of Z st succ (Root Z) = {z}
 holds Z = elementary_tree 1 with-replacement (<*0*>,Z|z);

theorem :: MODAL_1:28
for Z being finite DecoratedTree of D,z be Element of dom Z st
   succ (Root dom Z) = {z} & dom Z is finite holds
   Z = ((elementary_tree 1) --> Root Z) with-replacement (<*0*>,Z|z);

theorem :: MODAL_1:29
for Z being Tree,x1,x2 be Element of Z st Z is finite & x1 = <*0*> & x2 = <*1*>
 & succ (Root Z) = {x1,x2} holds
 Z = (elementary_tree 2 with-replacement (<*0*>,Z|x1))
   with-replacement (<*1*>,Z|x2);

theorem :: MODAL_1:30
for Z being DecoratedTree of D,x1,x2 being Element of dom Z st
  dom Z is finite & x1 = <*0*> & x2 = <*1*> & succ (Root dom Z) = {x1,x2} holds
   Z = (((elementary_tree 2) --> Root Z) with-replacement (<*0*>,
     Z|x1)) with-replacement (<*1*>,Z|x2);

definition
func MP-variables -> set equals
:: MODAL_1:def 3
 [: {3},NAT :];
end;


registration
cluster MP-variables -> non empty;
 coherence by Def3;
end;


definition
mode MP-variable is Element of MP-variables;
end;


definition
func MP-conectives -> set equals
:: MODAL_1:def 4
 [: {0,1,2},NAT :];
end;


registration
cluster MP-conectives -> non empty;
 coherence
  proof
   reconsider X = {0,1,2} as non empty set by ENUMSET1:14;
     [: X,NAT :] is non empty set;
   hence thesis by Def4;
  end;
end;


definition
mode MP-conective is Element of MP-conectives;
end;


theorem :: MODAL_1:31
MP-conectives misses MP-variables;

reserve p,q for MP-variable;

definition let T be finite Tree,v be Element of T;
redefine func branchdeg v -> Nat;
end;


definition let D be non empty set;
mode DOMAIN_DecoratedTree of D -> non empty set means
:: MODAL_1:def 5
for x st x in it holds x is DecoratedTree of D;
end;


definition let D0 be non empty set,D be DOMAIN_DecoratedTree of D0;
redefine
mode Element of D -> DecoratedTree of D0;
end;


definition
func MP-WFF -> DOMAIN_DecoratedTree of [: NAT,NAT :] means
:: MODAL_1:def 6

(for x being DecoratedTree of [: NAT,NAT :] st x in it holds x is finite) &
for x being finite DecoratedTree of [: NAT,NAT :] holds
   x in it iff
    for v being Element of dom x holds branchdeg v <= 2 &
   (branchdeg v = 0 implies x .v = [0,0] or ex k st x .v = [3,k]) &
   (branchdeg v = 1 implies x .v = [1,0] or x .v = [1,1]) &
   (branchdeg v = 2 implies x .v = [2,0]);
 end;


 :: [0,0] = VERUM
 :: [1,0] = negation
 :: [1,1] = modal operator of necessity
 :: [2,0] = &

definition
  mode MP-wff is Element of MP-WFF;
end;


registration
 cluster -> finite MP-wff;
 coherence by Def6;
end;


reserve A,A1,B,B1,C,C1 for MP-wff;

definition let A; let a be Element of dom A;
redefine func A|a -> MP-wff;
end;


definition let a be Element of MP-conectives;
func the_arity_of a -> Nat equals
:: MODAL_1:def 7
   a`1;
end;


definition let D be non empty set, T,T1 be DecoratedTree of D,
  p be FinSequence of NAT;
assume  p in dom T;
func @(T,p,T1) -> DecoratedTree of D equals
:: MODAL_1:def 8
 T with-replacement (p,T1);
end;


theorem :: MODAL_1:32
((elementary_tree 1) --> [1,0]) with-replacement (<*0*>,A) is MP-wff;

theorem :: MODAL_1:33
((elementary_tree 1)-->[1,1]) with-replacement (<*0*>,A) is MP-wff;

theorem :: MODAL_1:34
((((elementary_tree 2)-->[2,0]) with-replacement (<*0*>,A)))
  with-replacement (<*1*>,B)
  is MP-wff;

definition let A;
func 'not' A -> MP-wff equals
:: MODAL_1:def 9
 ((elementary_tree 1)-->[1,0]) with-replacement (<*0*>,A);
func (#) A -> MP-wff equals
:: MODAL_1:def 10
 ((elementary_tree 1)-->[1,1]) with-replacement (<*0*>,A);
let B;
func A '&' B -> MP-wff equals
:: MODAL_1:def 11
 ((((elementary_tree 2)-->[2,0]) with-replacement (<*0*>,A)))
   with-replacement (<*1*>,B);
end;


definition let A;
func ? A -> MP-wff equals
:: MODAL_1:def 12
   'not' (#) 'not' A;
let B;
func A 'or' B -> MP-wff equals
:: MODAL_1:def 13
   'not'('not' A '&' 'not' B);
func A => B -> MP-wff equals
:: MODAL_1:def 14
   'not'(A '&' 'not' B);
end;


theorem :: MODAL_1:35
(elementary_tree 0) --> [3,n] is MP-wff;

theorem :: MODAL_1:36
(elementary_tree 0) --> [0,0] is MP-wff;

definition let p;
func @p -> MP-wff equals
:: MODAL_1:def 15
 (elementary_tree 0) --> p;
end;


theorem :: MODAL_1:37
@p = @q implies p = q;

theorem :: MODAL_1:38
'not' A = 'not' B implies A = B;

theorem :: MODAL_1:39
(#)A = (#)B implies A = B;

theorem :: MODAL_1:40
(A '&' B) = (A1 '&' B1) implies A = A1 & B = B1;

definition
func VERUM -> MP-wff equals
:: MODAL_1:def 16
 (elementary_tree 0) --> [0,0];
end;


canceled;

theorem :: MODAL_1:42
card dom A = 1 implies A = VERUM or ex p st A = @p;

theorem :: MODAL_1:43
card dom A >= 2 implies (ex B st A = 'not' B or A = (#)B) or
ex B,C st A = B '&' C;

theorem :: MODAL_1:44
card dom A < card dom 'not' A;

theorem :: MODAL_1:45
card dom A < card dom (#)A;

theorem :: MODAL_1:46
card dom A < card dom A '&' B & card dom B < card dom A '&' B;

definition let IT be MP-wff;
attr IT is atomic means
:: MODAL_1:def 17
ex p st IT = @p;
attr IT is negative means
:: MODAL_1:def 18
ex A st IT = 'not' A;
attr IT is necessitive means
:: MODAL_1:def 19
ex A st IT = (#) A;
attr IT is conjunctive means
:: MODAL_1:def 20
ex A,B st IT = A '&' B;
end;


registration
cluster atomic MP-wff;
 existence
  proof
   reconsider p = [3,0] as MP-variable by Def3,ZFMISC_1:128;
   take @p; take p; thus thesis;
  end;
cluster negative MP-wff;
 existence
  proof
   set A = VERUM;
   take 'not' A; take A; thus thesis;
  end;
cluster necessitive MP-wff;
 existence
  proof
   set A = VERUM;
   take (#)A; take A; thus thesis;
  end;
cluster conjunctive MP-wff;
 existence
  proof
   set A = VERUM;
   set B = VERUM;
   take A '&' B; take B; take A; thus thesis;
  end;
end;


scheme :: MODAL_1:sch 1
 MP_Ind { Prop[Element of MP-WFF] }:
        for A being Element of MP-WFF holds Prop[A]
  provided
  Prop[VERUM] and
  for p being MP-variable holds Prop[@p] and
  for A being Element of MP-WFF st Prop[A] holds Prop['not' A] and
  for A being Element of MP-WFF st Prop[A] holds Prop[(#) A] and
  for A, B being Element of MP-WFF st Prop[A] & Prop[B] holds Prop[A '&' B]
proof
  defpred P[Nat] means for A st card dom A <= $1 holds Prop[A];
  A6: P[0]
   proof let A such that A7: card dom A <= 0;
     card dom A = 0 by A7,NAT_1:18;
    hence thesis by CARD_2:59;
   end;
  A8: for k st P[k] holds P[k+1]
   proof let k such that
    A9: for A st card dom A <= k holds Prop[A]; let A such that
    A10: card dom A <= k + 1;
    set a = Root dom A;
    set b = branchdeg a;
A11:    b <= 2 by Def6;
       now per cases by A11,CQC_THE1:3;
     suppose b = 0; then A12: card dom A = 1 by Th22;
          now per cases by A12,Th42;
        suppose A = VERUM; hence Prop[A] by A1;
        end;
        suppose ex p st A = @p; hence Prop[A] by A2;
        end;
        end;
      hence Prop[A];
     end;
     suppose A13: b = 1;
      then A14: succ a ={<*0*>} by Th23;
       then <*0*> in succ a by TARSKI:def 1;
      then reconsider o = <*0*> as Element of dom A;
      A15: A = ((elementary_tree 1) --> Root A) with-replacement (<*0*>, A|o)
        by A14,Th28;
      A16: Root A = A.a by Def2;
         now per cases by A13,Def6;
       suppose A.a = [1,0];
        then A17: A = 'not'(A|o) by A15,A16,Def9;
        A18: dom (A|o) = (dom A)|o by TREES_2:def 11;
          o <> {} by TREES_1:4;
        then o <> Root dom A by Def1;
        then card ((dom A)|o) < card dom A by Th26;
        then card dom (A|o) < k + 1 by A10,A18,AXIOMS:22;
        then card dom (A|o) <= k by NAT_1:38;
        then Prop[A|o] by A9;
        hence Prop[A] by A3,A17;
       end;
       suppose A.a = [1,1];
        then A19: A = (#)(A|o) by A15,A16,Def10;
        A20: dom (A|o) = (dom A)|o by TREES_2:def 11;
          o <> {} by TREES_1:4;
        then o <> Root dom A by Def1;
        then card ((dom A)|o) < card dom A by Th26;
        then card dom (A|o) < k + 1 by A10,A20,AXIOMS:22;
        then card dom (A|o) <= k by NAT_1:38;
        then Prop[A|o] by A9;
        hence Prop[A] by A4,A19;
       end;
       end;
      hence thesis;
     end;
     suppose A21: b = 2;
      then A22: succ a ={<*0*>,<*1*>} by Th24;
       then <*0*> in succ a & <*1*> in succ a by TARSKI:def 2;
      then reconsider o1 = <*0*>, o2 = <*1*> as Element of dom A;
      A23: A = ((elementary_tree 2) --> Root A) with-replacement
      (<*0*>, A|o1) with-replacement (<*1*>,A|o2) by A22,Th30;
        Root A = A.a by Def2
            .= [2,0] by A21,Def6;
      then A24: A = (A|o1) '&' (A|o2) by A23,Def11;
      A25: dom (A|o1) = (dom A)|o1 by TREES_2:def 11;
        o1 <> {} by TREES_1:4;
      then o1 <> Root dom A by Def1;
      then card ((dom A)|o1) < card dom A by Th26;
      then card dom (A|o1) < k + 1 by A10,A25,AXIOMS:22;
      then card dom (A|o1) <= k by NAT_1:38;
      then A26: Prop[A|o1] by A9;
      A27: dom (A|o2) = (dom A)|o2 by TREES_2:def 11;
        o2 <> {} by TREES_1:4;
      then o2 <> Root dom A by Def1;
      then card ((dom A)|o2) < card dom A by Th26;
      then card dom (A|o2) < k + 1 by A10,A27,AXIOMS:22;
      then card dom (A|o2) <= k by NAT_1:38;
      then Prop[A|o2] by A9;
      hence thesis by A5,A24,A26;
     end;
     end;
    hence thesis;
   end;
  A28: for n holds P[n] from NAT_1:sch 1(A6,A8);
  let A; card dom A <= card dom A;
  hence Prop[A] by A28;
 end;

theorem :: MODAL_1:47
  for A being Element of MP-WFF holds
                A = VERUM or A is atomic MP-wff or
                A is negative MP-wff or A is necessitive MP-wff or
                A is conjunctive MP-wff;


theorem :: MODAL_1:48
 A = VERUM or (ex p st A = @p) or (ex B st A = 'not' B) or (ex B st A = (#)
B) or
 (ex B,C st A = B '&' C);

theorem :: MODAL_1:49
@p <> 'not' A & @p <> (#)A & @p <> A '&' B;

theorem :: MODAL_1:50
'not' A <> (#)B & 'not' A <> B '&' C;

theorem :: MODAL_1:51
(#)A <> B '&' C;

theorem :: MODAL_1:52
  VERUM <> @p & VERUM <> 'not' A & VERUM <> (#)A & VERUM <> A '&' B;

scheme :: MODAL_1:sch 2
 MP_Func_Ex{ D() -> non empty set,
                   d() -> Element of D(),
                   F(Element of MP-variables) -> Element of D(),
                   N,H(Element of D()) -> Element of D(),
                   C((Element of D()),Element of D()) -> Element of D() }:
 ex f being Function of MP-WFF, D() st
    f.VERUM = d() &
    (for p being MP-variable holds f.@p = F(p)) &
    (for A being Element of MP-WFF holds f.('not' A) = N(f.A)) &
    (for A being Element of MP-WFF holds f.((#)A) = H(f.A)) &
    (for A,B being Element of MP-WFF holds f.(A '&' B) = C(f.A,f.B))
proof
 defpred
 Pfgp[(Element of D()),(Function of MP-WFF,D()),Element of MP-WFF] means
      ($3 = VERUM implies $1 = d()) &
      (for p st $3 = @p holds $1 = F(p)) &
      (for A st $3 = 'not' A holds $1 = N($2.A)) &
      (for A st $3 = (#)A holds $1 = H($2.A)) &
      (for A,B st $3 = A '&' B holds $1 = C($2.A,$2.B));
 defpred Pfn[(Function of MP-WFF, D()), Nat] means
      for A st card dom A <= $2 holds
      (A = VERUM implies $1.A = d()) &
      (for p st A = @p holds $1.A = F(p)) &
      (for B st A = 'not' B holds $1.A = N($1.B)) &
      (for B st A = (#)B holds $1.A = H($1.B)) &
      (for B,C st A = B '&' C holds $1.A = C($1.B,$1.C));
   defpred P[Nat] means ex F be Function of MP-WFF,D() st Pfn[F,$1];
  A1: P[0]
   proof consider F be Function of MP-WFF,D();
    take F; let A such that A2: card dom A <= 0;
     card dom A = 0 by A2,NAT_1:18; hence thesis by CARD_2:59;
   end;
  A3: for k st P[k] holds P[k+1]
   proof let k; given F be Function of MP-WFF,D() such that
    A4: Pfn[F,k];
    defpred Q[Element of MP-WFF,Element of D()] means
    (card dom $1 <> k+1 implies $2 = F.$1) &
           (card dom $1 = k+1 implies Pfgp[$2, F, $1]);
 A5:  for x being Element of MP-WFF ex y being Element of D() st Q[x,y]
 proof let A be Element of MP-WFF;
        now per cases by Th48;
      case card dom A <> k+1;
       take y=F.A;
      end;
      case A6: card dom A = k+1 & A = VERUM;
       take y = d();
       thus Pfgp[y,F,A] by A6,Lm4,Lm6;
      end;
      case card dom A = k + 1 & ex p st A = @p; then consider p such that
       A7: A = @p;
       take y = F(p);
       thus Pfgp[y,F,A] by A7,Lm6,Th37,Th49;
      end;
      case card dom A = k + 1 & ex B st A = 'not' B; then consider B such that
       A8: A = 'not' B;
       take y = N(F.B);
       thus Pfgp[y,F,A] by A8,Lm4,Th38,Th49,Th50;
      end;
      case card dom A = k + 1 & ex B st A = (#)B; then consider B such that
       A9: A = (#)B;
       take y = H(F.B);
       thus Pfgp[y,F,A] by A9,Lm4,Th39,Th49,Th50,Th51;
      end;
      case card dom A = k + 1 & ex B,C st A = B '&' C;
      then consider B,C such that A10: A = B '&' C;
       take y = C(F.B,F.C);
         now
          now let B1,C1; assume A = B1 '&' C1; then B=B1 & C=C1 by A10,Th40;
         hence y=C(F.B1,F.C1);
        end;
       hence Pfgp[y,F,A] by A10,Lm4,Th49,Th50,Th51;
       end;
       hence Pfgp[y,F,A];
      end;
      end;
     hence ex y be Element of D() st
                 (card dom A <> k +1 implies y = F.A) &
                 (card dom A = k + 1 implies Pfgp[y,F,A]);
    end;
     consider G being Function of MP-WFF, D() such that
     A11: for p being Element of MP-WFF holds Q[p,G.p] from FUNCT_2:sch 3(A5);
    take H = G;
    thus Pfn[H, k+1]
     proof
      let A be Element of MP-WFF; set p = card dom A; assume
      A12: p <= k+1;
      thus A = VERUM implies H.A = d()
        proof
         per cases;
          suppose A13: p <> k+1; then A14: p <= k by A12,NAT_1:26;
             H.A = F.A by A11,A13;
           hence thesis by A4,A14;
          end;
          suppose p = k+1;
           hence thesis by A11;
        end;
        end;
     thus for p st A = @p holds H.A = F(p)
       proof let q such that A15: A = @q;
         per cases;
          suppose A16: p <> k+1; then A17: p <= k by A12,NAT_1:26;
                  H.A = F.A by A11,A16;
           hence thesis by A4,A15,A17;
          end;
          suppose p = k+1;
           hence thesis by A11,A15;
         end;
         end;
     thus for B st A = 'not' B holds H.A = N(H.B)
        proof let B; assume A18: A = 'not' B;
          then card dom B <> k+1 by A12,Th44;
        then A19:  H.B = F.B by A11;
         per cases;
          suppose A20: p <> k+1; then A21: p <= k by A12,NAT_1:26;
              H.A = F.A by A11,A20;
           hence thesis by A4,A18,A19,A21;
          end;
          suppose p = k+1;
           hence thesis by A11,A18,A19;
        end;
        end;
      thus for B st A = (#)B holds H.A = H(H.B)
        proof let B; assume A22: A = (#)B;
          then card dom B <> k+1 by A12,Th45;
        then A23:  H.B = F.B by A11;
         per cases;
          suppose A24: p <> k+1; then A25: p <= k by A12,NAT_1:26;
              H.A = F.A by A11,A24;
           hence thesis by A4,A22,A23,A25;
          end;
          suppose p = k+1;
           hence thesis by A11,A22,A23;
        end;
        end;
      thus for B,C st A = B '&' C holds H.A = C(H.B,H.C)
        proof let B,C;
         assume A26: A = B '&' C;
          then (card dom B) <> k+1 by A12,Th46;
        then A27:  H.B = F.B by A11;
            (card dom C) <> k+1 by A12,A26,Th46;
        then A28:  H.C = F.C by A11;
         per cases;
          suppose A29: p <> k+1; then A30: p <= k by A12,NAT_1:26;
                  H.A = F.A by A11,A29;
           hence thesis by A4,A26,A27,A28,A30;
          end;
          suppose p = k+1;
           hence thesis by A11,A26,A27,A28;
        end;
        end;
     end;
   end;

  A31: for n holds P[n] from NAT_1:sch 1(A1,A3);
 defpred Qfn[set, set] means
       ex A being Element of MP-WFF st A = $1 &
       for g being Function of MP-WFF, D() st Pfn[g, card dom A] holds
                $2 = g.A;
  A32: for x, y1, y2 st x in MP-WFF & Qfn[x, y1] & Qfn[x, y2] holds y1 = y2
   proof let x, y1, y2 such that
      x in MP-WFF and
   A33: Qfn[x, y1] and
   A34: Qfn[x, y2];
       consider p being Element of MP-WFF such that
   A35: p = x and
   A36: for g being Function of MP-WFF, D() st Pfn[g, card dom p] holds y1 = g.
p
                                                by A33;
       consider F being Function of MP-WFF, D() such that
   A37: Pfn[F, card dom p] by A31;
     thus y1 = F.p by A36,A37
            .= y2 by A34,A35,A37;
   end;
  A38: for x st x in MP-WFF ex y st Qfn[x, y]
   proof let x; assume
      x in MP-WFF;
       then reconsider x' = x as Element of MP-WFF;
       consider F being Function of MP-WFF, D() such that
   A39: Pfn[F, card dom x'] by A31;
       take F.x, x';
       thus x = x';
       let G be Function of MP-WFF, D(); assume
   A40: Pfn[G, card dom x'];
       defpred Prop[Element of MP-WFF] means
       card dom $1 <= card dom x' implies F.$1 = G.$1;
   A41: Prop[VERUM]
       proof assume
          A42: card dom VERUM <= card dom x';
          hence F.VERUM = d() by A39
                      .= G.VERUM by A40,A42;
         end;
   A43: for p holds Prop[@p]
         proof let p; assume
         A44: card dom @p <= card dom x';
           hence F.@p = F(p) by A39
                   .= G.@p by A40,A44;
         end;
   A45: for A be Element of MP-WFF st Prop[A] holds Prop['not' A]
       proof let A such that A46: Prop[A]; assume
          A47: card dom 'not' A <= card dom x';
            card dom A < card dom 'not' A by Th44;
          hence F.('not' A) = N(G.A) by A39,A46,A47,AXIOMS:22
                  .= G.('not' A) by A40,A47;
         end;
   A48: for A be Element of MP-WFF st Prop[A] holds Prop[(#) A]
       proof let A such that A49: Prop[A]; assume
          A50: card dom (#)A <= card dom x';
            card dom A < card dom (#)A by Th45;
          hence F.((#)A) = H(G.A) by A39,A49,A50,AXIOMS:22
                  .= G.((#)A) by A40,A50;
         end;
   A51: for A,B be Element of MP-WFF st Prop[A] & Prop[B] holds Prop[A '&' B]
      proof let A,B; assume that
         A52: Prop[A] and
         A53: Prop[B] and
         A54: card dom A '&' B <= card dom x';
A55:          card dom A < card dom A '&' B by Th46;
            card dom B < card dom A '&' B by Th46;
          hence F.(A '&' B) = C(G.A, G.B) by A39,A52,A53,A54,A55,AXIOMS:22
                  .= G.(A '&' B) by A40,A54;
         end;
      for p be Element of MP-WFF holds Prop[p]
       from MP_Ind(A41,A43,A45,A48,A51);
    hence F.x = G.x';
   end;
  consider F being Function such that
  A56: dom F = MP-WFF and
  A57: for x st x in MP-WFF holds Qfn[x, F.x] from FUNCT_1:sch 2(A32,A38);
    F is Function of MP-WFF, D()
 proof
   rng F c= D()
   proof
    let y; assume y in rng F;
    then consider x being set such that
  A58: x in MP-WFF and
  A59: y = F.x by A56,FUNCT_1:def 5;
      consider p being Element of MP-WFF such that p = x and
  A60: for g being Function of MP-WFF, D() st Pfn[g, card dom p] holds y = g.p
                                          by A57,A58,A59;
    consider G being Function of MP-WFF, D() such that
  A61: Pfn[G, card dom p] by A31;
        y = G.p by A60,A61;
    hence y in D();
  end;
  hence thesis by A56,FUNCT_2:def 1,RELSET_1:11;
 end;
  then reconsider F as Function of MP-WFF, D();
  take F;
  consider A such that
  A62: A = VERUM & for g being Function of MP-WFF,D() st Pfn[g,card dom A]
   holds F.VERUM = g.A by A57;
  consider G being Function of MP-WFF,D() such that
  A63: Pfn[G,card dom A] by A31;
     F.VERUM = G.VERUM by A62,A63;
  hence F.VERUM = d() by A62,A63;
  thus for p being MP-variable holds F.@p = F(p)
   proof let p be MP-variable;
    consider A such that
    A64: A = @p & for g being Function of MP-WFF,D() st Pfn[g,card dom A]
        holds F.@p = g.A by A57;
    consider G being Function of MP-WFF,D() such that
    A65: Pfn[G,card dom A] by A31;
      F.@p = G.@p by A64,A65;
    hence thesis by A64,A65;
   end;
  thus for A being Element of MP-WFF holds F.('not' A) = N(F.A)
   proof
    let A be Element of MP-WFF;
    consider A1 such that
A67: A1 = 'not' A & for g being Function of MP-WFF,D() st Pfn[g,card dom A1]
        holds F.'not' A = g.A1 by A57;
    consider G being Function of MP-WFF,D() such that
    A68: Pfn[G,card dom A1] by A31;
    A69: for k st k < card dom 'not' A holds Pfn[G,k]
     proof
      let k; assume A70: k < card dom 'not' A;
      let a be Element of MP-WFF; assume card dom a <= k;
      then card dom a <= card dom 'not' A by A70,AXIOMS:22;
      hence thesis by A67,A68;
     end;
    A71: F.'not' A = G.'not' A by A67,A68;
    set k = card dom A;
      k < card dom 'not' A by Th44;
    then A72: Pfn[G,k] by A69;
       ex B st B = A &
         for g be Function of MP-WFF,D() st Pfn[g,card dom B] holds F.A = g.B
 by A57;
    then F.A = G.A by A72;
    hence thesis by A67,A68,A71;
   end;
  thus for A being Element of MP-WFF holds F.((#)A) = H(F.A)
   proof
    let A be Element of MP-WFF;
    consider A1 such that
    A74: A1 = (#)A & for g being Function of MP-WFF,D() st Pfn[g,card dom A1]
        holds F.((#)A) = g.A1 by A57;
    consider G being Function of MP-WFF,D() such that
    A75: Pfn[G,card dom A1] by A31;
    A76: for k st k < card dom (#)A holds Pfn[G,k]
     proof
      let k; assume A77: k < card dom (#)A;
      let a be Element of MP-WFF; assume card dom a <= k;
      then card dom a <= card dom (#)A by A77,AXIOMS:22;
      hence thesis by A74,A75;
     end;
    A78: F.((#)A) = G.((#)A) by A74,A75;
    set k = card dom A;
      k < card dom (#)A by Th45;
    then A79: Pfn[G,k] by A76;
       ex B st B = A &
         for g be Function of MP-WFF,D() st Pfn[g,card dom B] holds F.A = g.B
 by A57;
    then F.A = G.A by A79;
    hence thesis by A74,A75,A78;
   end;
  thus for A,B being Element of MP-WFF holds F.(A '&' B) = C(F.A,F.B)
   proof
    let A,B be Element of MP-WFF;
    consider A1 such that
    A81: A1 = A '&' B &
        for g being Function of MP-WFF,D() st Pfn[g,card dom A1] holds
        F.(A '&' B) = g.A1 by A57;
    consider G being Function of MP-WFF,D() such that
    A82: Pfn[G,card dom A1] by A31;
    A83: for k st k < card dom A '&' B holds Pfn[G,k]
     proof
      let k; assume A84: k < card dom A '&' B;
      let a be Element of MP-WFF; assume card dom a <= k;
      then card dom a <= card dom A '&' B by A84,AXIOMS:22;
      hence thesis by A81,A82;
     end;
    A85: F.(A '&' B) = G.(A '&' B) by A81,A82;
    set k1 = card dom A;
    set k2 = card dom B;
      k1 < card dom A '&' B by Th46;
    then A86: Pfn[G,k1] by A83;
       ex B1 st B1 = A &
        for g be Function of MP-WFF,D() st Pfn[g,card dom B1] holds F.A = g.B1
 by A57;
    then A87: F.A = G.A by A86;
      k2 < card dom A '&' B by Th46;
    then A88: Pfn[G,k2] by A83;
       ex C st C = B &
         for g be Function of MP-WFF,D() st Pfn[g,card dom C] holds F.B = g.C
 by A57;
    then F.B = G.B by A88;
    hence thesis by A81,A82,A85,A87;
   end;
end;
