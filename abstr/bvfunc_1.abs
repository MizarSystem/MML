:: A Theory of Boolean Valued Functions and Partitions
::  by Shunichi Kobayashi and Kui Jia
::
:: Received October 22, 1998
:: Copyright (c) 1998 Association of Mizar Users

environ

 vocabulary MARGREL1, ZF_LANG, BINARITH, ORDINAL2, PARTIT1, FUNCT_2, FRAENKEL,
      VALUAT_1, RELAT_1, FUNCT_1, BOOLE, SEQM_3, EQREL_1, T_1TOPSP, SETFAM_1,
      TARSKI, BVFUNC_1;
 notation TARSKI, XBOOLE_0, ZFMISC_1, SUBSET_1, ORDINAL2, XREAL_0, MARGREL1,
      VALUAT_1, RELAT_1, FUNCT_1, FUNCT_2, SETFAM_1, FRAENKEL, BINARITH,
      EQREL_1, T_1TOPSP, PARTIT1, SEQM_3;
 constructors BINARITH, T_1TOPSP, PARTIT1, SEQM_3, PUA2MSS1, VALUAT_1, XREAL_0,
      MEMBERED;
 clusters SUBSET_1, MARGREL1, PARTIT1, XREAL_0, ARYTM_3, VALUAT_1, BINARITH,
      FRAENKEL;
 requirements NUMERALS, REAL, SUBSET, BOOLE;


begin :: Chap. 1  Boolean Operations

reserve Y for set;

definition let k,l be boolean set;
 func k 'imp' l equals
:: BVFUNC_1:def 1
  'not' k 'or' l;

 func k 'eqv' l equals
:: BVFUNC_1:def 2
  'not' (k 'xor' l);
 commutativity;
end;


registration let k,l be boolean set;
 cluster k 'imp' l -> boolean;
 correctness
  proof
      k 'imp' l = 'not' k 'or' l by Def1;
   hence thesis;
  end;
 cluster k 'eqv' l -> boolean;
 correctness
  proof
     k 'eqv' l = 'not' (k 'xor' l) by Def2;
   hence thesis;
  end;
end;


registration
 cluster boolean -> natural set;
 coherence
  proof let x be set;
   assume x is boolean;
    then x in BOOLEAN by MARGREL1:def 15;
   hence thesis by MARGREL1:def 12,TARSKI:def 2;
  end;
end;


notation let k,l be boolean set;
 synonym k '<' l for k <= l ;
end;
definition let k,l be boolean set;
 redefine
 pred k '<' l means
:: BVFUNC_1:def 3
  k 'imp' l = TRUE;
 end;


begin :: Chap.2   Boolean Valued Functions

definition let Y;
  func BVF(Y) equals
:: BVFUNC_1:def 4
  Funcs(Y,BOOLEAN);
end;


registration let Y be set;
 cluster BVF(Y) -> functional non empty;
coherence
 proof
   A1:BVF(Y) = Funcs(Y,BOOLEAN) by Def4;
   hence BVF(Y) is functional;
   thus BVF(Y) is non empty by A1;
 end;
end;


registration let Y be set;
 cluster -> boolean-valued Element of BVF Y;
 coherence
  proof let f be Element of BVF Y;
      BVF Y = Funcs(Y,BOOLEAN) by Def4;
   hence rng f c= BOOLEAN by ALTCAT_1:6;
  end;
end;


reserve Y for non empty set;
reserve B for Subset of Y;

notation let a be boolean-valued Function, x be set;
 synonym Pj(a,x) for a.x;
 end;


scheme :: BVFUNC_1:sch 1
 BVFUniq {Y() -> non empty set, a,b() -> Element of Funcs(Y(),BOOLEAN),
  F(set, Element of Funcs(Y(),BOOLEAN), Element of Funcs(Y(),BOOLEAN)) -> set}:
for f1,f2 being Element of Funcs(Y(),BOOLEAN) st
(for x being Element of Y() holds Pj(f1,x) = F(x,a(),b())) &
(for x being Element of Y() holds Pj(f2,x) = F(x,a(),b())) holds
  f1 = f2
proof
  let f1,f2 be Element of Funcs(Y(),BOOLEAN);
  assume that
A1:  (for x being Element of Y() holds Pj(f1,x) = F(x,a(),b())) and
A2:  (for x being Element of Y() holds Pj(f2,x) = F(x,a(),b()));
   consider k3 being Function such that
A3: f1=k3 & dom k3=Y() & rng k3 c= BOOLEAN by FUNCT_2:def 2;
   consider k4 being Function such that
A4: f2=k4 & dom k4=Y() & rng k4 c= BOOLEAN by FUNCT_2:def 2;
     for u being set st u in Y() holds k3.u=k4.u
    proof let u be set;assume u in Y();
      then reconsider u'=u as Element of Y();
       Pj(f2,u') = F(u',a(),b()) by A2;
     hence k3.u=k4.u by A1,A3,A4;
    end;
  hence f1=f2 by A3,A4,FUNCT_1:9;
end;

scheme :: BVFUNC_1:sch 2
 BVFUniq1 {Y() -> non empty set, F(set) -> set}:
for f1,f2 being Element of Funcs(Y(),BOOLEAN) st
(for x being Element of Y() holds Pj(f1,x) = F(x)) &
(for x being Element of Y() holds Pj(f2,x) = F(x)) holds
  f1 = f2
proof
  let f1,f2 be Element of Funcs(Y(),BOOLEAN);
  assume that
A1:  (for x being Element of Y() holds Pj(f1,x) = F(x)) and
A2:  (for x being Element of Y() holds Pj(f2,x) = F(x));
   consider k3 being Function such that
A3: f1=k3 & dom k3=Y() & rng k3 c= BOOLEAN by FUNCT_2:def 2;
   consider k4 being Function such that
A4: f2=k4 & dom k4=Y() & rng k4 c= BOOLEAN by FUNCT_2:def 2;
     for u being set st u in Y() holds k3.u=k4.u
    proof let u be set;assume u in Y();
      then reconsider u'=u as Element of Y();
       Pj(f2,u') = F(u') by A2;
     hence k3.u=k4.u by A1,A3,A4;
    end;
  hence f1=f2 by A3,A4,FUNCT_1:9;
end;

definition let Y;let a be Element of BVF(Y);
 redefine
 func 'not' a ->Element of BVF(Y);
 let b be Element of BVF(Y);
 func a '&' b ->Element of BVF(Y);
end;


definition
 let p,q be boolean-valued Function;
  func p 'or' q -> Function means
:: BVFUNC_1:def 5
 dom it = dom p /\ dom q &
  for x being set st x in dom it holds it.x = (p.x) 'or' (q.x);
 commutativity;
  func p 'xor' q -> Function means
:: BVFUNC_1:def 6
 dom it = dom p /\ dom q &
  for x being set st x in dom it holds it.x = (p.x) 'xor' (q.x);
 commutativity;
end;


registration
 let p,q be boolean-valued Function;
  cluster p 'or' q -> boolean-valued;
  coherence
   proof let x be set;
    assume x in rng(p 'or' q);
     then consider y being set such that
A1:   y in dom(p 'or' q) and
A2:   x = (p 'or' q).y by FUNCT_1:def 5;
    x = (p.y) 'or' (q.y) by A1,A2,Def5;
     then x = FALSE or x = TRUE by MARGREL1:39;
    hence x in BOOLEAN;
   end;
  cluster p 'xor' q -> boolean-valued;
  coherence
   proof let x be set;
    assume x in rng(p 'xor' q);
     then consider y being set such that
A3:   y in dom(p 'xor' q) and
A4:   x = (p 'xor' q).y by FUNCT_1:def 5;
    x = (p.y) 'xor' (q.y) by A3,A4,Def6;
     then x = FALSE or x = TRUE by MARGREL1:39;
    hence x in BOOLEAN;
   end;
end;


definition let A be non empty set;
 redefine
 let p,q be Element of Funcs(A,BOOLEAN);
  func p 'or' q -> Element of Funcs(A,BOOLEAN) means
:: BVFUNC_1:def 7
 for x being Element of A holds it.x = (p.x) 'or' (q.x);
  func p 'xor' q -> Element of Funcs(A,BOOLEAN) means
:: BVFUNC_1:def 8
   for x being Element of A holds it.x = (p.x) 'xor' (q.x);
end;


definition let Y;let a,b be Element of BVF(Y);
 redefine
 func a 'or' b ->Element of BVF(Y);
 func a 'xor' b ->Element of BVF(Y);
end;


definition
 let p,q be boolean-valued Function;
  func p 'imp' q -> Function means
:: BVFUNC_1:def 9
 dom it = dom p /\ dom q &
  for x being set st x in dom it holds it.x = (p.x) 'imp' (q.x);
  func p 'eqv' q -> Function means
:: BVFUNC_1:def 10
 dom it = dom p /\ dom q &
  for x being set st x in dom it holds it.x = (p.x) 'eqv' (q.x);
 commutativity;
end;


registration
 let p,q be boolean-valued Function;
  cluster p 'imp' q -> boolean-valued;
  coherence
   proof let x be set;
    assume x in rng(p 'imp' q);
     then consider y being set such that
A1:   y in dom(p 'imp' q) and
A2:   x = (p 'imp' q).y by FUNCT_1:def 5;
    x = (p.y) 'imp' (q.y) by A1,A2,Def9
      .= 'not' (p.y) 'or' (q.y) by Def1;
     then x = FALSE or x = TRUE by MARGREL1:39;
    hence x in BOOLEAN;
   end;
  cluster p 'eqv' q -> boolean-valued;
  coherence
   proof let x be set;
    assume x in rng(p 'eqv' q);
     then consider y being set such that
A3:   y in dom(p 'eqv' q) and
A4:   x = (p 'eqv' q).y by FUNCT_1:def 5;
    x = (p.y) 'eqv' (q.y) by A3,A4,Def10
      .= 'not' ((p.y) 'xor' (q.y)) by Def2;
     then x = FALSE or x = TRUE by MARGREL1:39;
    hence x in BOOLEAN;
   end;
end;


definition let A be non empty set;
 redefine
 let p,q be Element of Funcs(A,BOOLEAN);
  func p 'imp' q -> Element of Funcs(A,BOOLEAN) means
:: BVFUNC_1:def 11
 for x being Element of A holds it.x = ('not' Pj(p,x)) 'or' Pj(q,x);
  func p 'eqv' q -> Element of Funcs(A,BOOLEAN) means
:: BVFUNC_1:def 12
 for x being Element of A holds it.x = 'not' (Pj(p,x) 'xor' Pj(q,x));
end;


definition let Y;let a,b be Element of BVF(Y);
 redefine
 func a 'imp' b ->Element of BVF(Y);
 func a 'eqv' b ->Element of BVF(Y);
end;


definition let Y;
 func O_el(Y) ->Element of Funcs(Y,BOOLEAN) means
:: BVFUNC_1:def 13
 for x being Element of Y holds Pj(it,x)= FALSE;
end;


definition let Y;
 func I_el(Y) ->Element of Funcs(Y,BOOLEAN) means
:: BVFUNC_1:def 14
 for x being Element of Y holds Pj(it,x)= TRUE;
end;


canceled 3;

theorem :: BVFUNC_1:4
 for a being boolean-valued Function holds 'not' 'not' a=a;

theorem :: BVFUNC_1:5
 for a being Element of Funcs(Y,BOOLEAN) holds
 'not' I_el(Y)=O_el(Y) & 'not' O_el(Y)=I_el(Y);

theorem :: BVFUNC_1:6
for a,b being Element of Funcs(Y,BOOLEAN) holds
 a '&' a=a;

theorem :: BVFUNC_1:7
for a,b,c being Element of Funcs(Y,BOOLEAN) holds
 a '&' b '&' c = a '&' (b '&' c);

theorem :: BVFUNC_1:8
for a being Element of Funcs(Y,BOOLEAN) holds
 a '&' O_el(Y)=O_el(Y);

theorem :: BVFUNC_1:9
for a being Element of Funcs(Y,BOOLEAN) holds
 a '&' I_el(Y)=a;

theorem :: BVFUNC_1:10
for a being Element of Funcs(Y,BOOLEAN) holds
 a 'or' a=a;

theorem :: BVFUNC_1:11
for a,b,c being Element of Funcs(Y,BOOLEAN) holds
 a 'or' b 'or' c = a 'or' (b 'or' c);

theorem :: BVFUNC_1:12
for a being Element of Funcs(Y,BOOLEAN) holds
 a 'or' O_el(Y)=a;

theorem :: BVFUNC_1:13
for a being Element of Funcs(Y,BOOLEAN) holds
 a 'or' I_el(Y)=I_el(Y);

theorem :: BVFUNC_1:14  ::Distributive
   for a,b,c being Element of Funcs(Y,BOOLEAN) holds
 (a '&' b) 'or' c = (a 'or' c) '&' (b 'or' c);

theorem :: BVFUNC_1:15  ::Distributive
   for a,b,c being Element of Funcs(Y,BOOLEAN) holds
 (a 'or' b) '&' c = (a '&' c) 'or' (b '&' c);

theorem :: BVFUNC_1:16  ::De'Morgan
   for a,b being Element of Funcs(Y,BOOLEAN) holds
 'not' (a 'or' b)=('not' a) '&' ('not' b);

theorem :: BVFUNC_1:17  ::De'Morgan
   for a,b being Element of Funcs(Y,BOOLEAN) holds
  'not' (a '&' b)=('not' a) 'or' ('not' b);

definition let Y;let a,b be Element of Funcs(Y,BOOLEAN);
 pred a '<' b means
:: BVFUNC_1:def 15
 for x being Element of Y st Pj(a,x)= TRUE holds Pj(b,x)=TRUE;
reflexivity;
end;


theorem :: BVFUNC_1:18
for a,b,c being Element of Funcs(Y,BOOLEAN) holds
((a '<' b) & (b '<' a) implies a=b)&
((a '<' b) & (b '<' c) implies a '<' c);

theorem :: BVFUNC_1:19
for a,b being Element of Funcs(Y,BOOLEAN) holds
 (a 'imp' b)=I_el(Y) iff a '<' b;

theorem :: BVFUNC_1:20
for a,b being Element of Funcs(Y,BOOLEAN) holds
(a 'eqv' b)=I_el(Y) iff a = b;

theorem :: BVFUNC_1:21
for a being Element of Funcs(Y,BOOLEAN) holds
 O_el(Y) '<' a & a '<' I_el(Y);

begin :: Chap. 3  Infimum and Supremum

definition let Y;let a be Element of Funcs(Y,BOOLEAN);
 func B_INF(a) ->Element of Funcs(Y,BOOLEAN) means
:: BVFUNC_1:def 16
  it = I_el(Y) if (for x being Element of Y holds Pj(a,x)=TRUE)
   otherwise it = O_el(Y);

 func B_SUP(a) ->Element of Funcs(Y,BOOLEAN) means
:: BVFUNC_1:def 17
  it = O_el(Y) if (for x being Element of Y holds Pj(a,x)=FALSE)
   otherwise it = I_el(Y);
end;


theorem :: BVFUNC_1:22
for a being Element of Funcs(Y,BOOLEAN) holds
     'not' B_INF(a) = B_SUP('not' a) & 'not' B_SUP(a)=B_INF('not' a);

theorem :: BVFUNC_1:23
       B_INF(O_el(Y)) = O_el(Y) & B_INF(I_el(Y))=I_el(Y) &
     B_SUP(O_el(Y)) = O_el(Y) & B_SUP(I_el(Y))=I_el(Y);

registration let Y;
 cluster O_el(Y) -> constant;
coherence
proof
 thus O_el(Y) is constant
 proof
   consider f being Function such that
     A1:O_el(Y) = f & dom f = Y & rng f c= BOOLEAN by FUNCT_2:def 2;
     for n1,n2 being set st n1 in dom O_el(Y) & n2 in dom O_el(Y) holds
     O_el(Y).n1=O_el(Y).n2
   proof
     let n1,n2 be set;
     assume n1 in dom O_el(Y) & n2 in dom O_el(Y);
     then reconsider n1, n2 as Element of Y by A1;
     A2:Pj(O_el(Y),n2)= FALSE by Def13;
      Pj(O_el(Y),n1) = O_el(Y).n1;
     hence thesis by A2,Def13;
   end;
   hence thesis by SEQM_3:def 5;
 end;
end;
end;


registration let Y;
 cluster I_el(Y) -> constant;
coherence
proof
 thus I_el(Y) is constant
 proof
   consider f being Function such that
     A1:I_el(Y) = f & dom f = Y & rng f c= BOOLEAN by FUNCT_2:def 2;
     for n1,n2 being set st n1 in dom I_el(Y) & n2 in dom I_el(Y) holds
     I_el(Y).n1=I_el(Y).n2
   proof
     let n1,n2 be set;
     assume n1 in dom I_el(Y) & n2 in dom I_el(Y);
     then reconsider n1, n2 as Element of Y by A1;
     A2:Pj(I_el(Y),n2)= TRUE by Def14;
      Pj(I_el(Y),n1) = I_el(Y).n1;
     hence thesis by A2,Def14;
   end;
   hence thesis by SEQM_3:def 5;
 end;
end;
end;


registration
 let Y be non empty set;
 cluster constant Element of Funcs(Y,BOOLEAN);
existence
proof
  take O_el(Y);
  thus thesis;
end;
end;


theorem :: BVFUNC_1:24
for a being constant Element of Funcs(Y,BOOLEAN) holds
 a=O_el(Y) or a=I_el(Y);

theorem :: BVFUNC_1:25
for d being constant Element of Funcs(Y,BOOLEAN) holds
  B_INF(d) = d & B_SUP(d) = d;

theorem :: BVFUNC_1:26
for a,b being Element of Funcs(Y,BOOLEAN) holds
     B_INF(a '&' b) = B_INF(a) '&' B_INF(b) &
     B_SUP(a 'or' b) = B_SUP(a) 'or' B_SUP(b);

theorem :: BVFUNC_1:27
for a being Element of Funcs(Y,BOOLEAN),
                   d being constant Element of Funcs(Y,BOOLEAN) holds
     B_INF(d 'imp' a) = d 'imp' B_INF(a) &
     B_INF(a 'imp' d) = B_SUP(a) 'imp' d;

theorem :: BVFUNC_1:28
for a being Element of Funcs(Y,BOOLEAN),
                   d being constant Element of Funcs(Y,BOOLEAN) holds
     B_INF(d 'or' a) = d 'or' B_INF(a) &
     B_SUP(d '&' a) = d '&' B_SUP(a) &
     B_SUP(a '&' d) = B_SUP(a) '&' d;

theorem :: BVFUNC_1:29
for a being Element of Funcs(Y,BOOLEAN),x being Element of Y holds
     Pj(B_INF(a),x) '<' Pj(a,x);

theorem :: BVFUNC_1:30
for a being Element of Funcs(Y,BOOLEAN),x being Element of Y holds
     Pj(a,x) '<' Pj(B_SUP(a),x);

begin :: Chap. 4  Boolean Valued Functions and Partitions

definition let Y;let a be Element of Funcs(Y,BOOLEAN),PA be a_partition of Y;
pred a is_dependent_of PA means
:: BVFUNC_1:def 18
 for F being set st F in PA
  for x1,x2 being set st x1 in F & x2 in F holds a.x1=a.x2;
end;


theorem :: BVFUNC_1:31
for a being Element of Funcs(Y,BOOLEAN) holds
  a is_dependent_of %I(Y);

theorem :: BVFUNC_1:32
for a being constant Element of Funcs(Y,BOOLEAN) holds
  a is_dependent_of %O(Y);

definition let Y;let PA be a_partition of Y;
 redefine mode Element of PA -> Subset of Y;
end;


definition let Y;let x be Element of Y;let PA be a_partition of Y;
 redefine func EqClass(x,PA) -> Element of PA;
 end;


definition let Y;let a be Element of Funcs(Y,BOOLEAN),PA be a_partition of Y;
 func B_INF(a,PA) -> Element of Funcs(Y,BOOLEAN) means
:: BVFUNC_1:def 19
  for y being Element of Y holds
   ( (for x being Element of Y st x in EqClass(y,PA) holds Pj(a,x)=TRUE)
         implies Pj(it,y) = TRUE ) &
   (not (for x being Element of Y st x in EqClass(y,PA) holds Pj(a,x)=TRUE)
         implies Pj(it,y) = FALSE);
end;


definition let Y;let a be Element of Funcs(Y,BOOLEAN),PA be a_partition of Y;
 func B_SUP(a,PA) -> Element of Funcs(Y,BOOLEAN) means
:: BVFUNC_1:def 20
  for y being Element of Y holds
   ( (ex x being Element of Y st x in EqClass(y,PA) & Pj(a,x)=TRUE)
         implies Pj(it,y) = TRUE ) &
   (not (ex x being Element of Y st x in EqClass(y,PA) & Pj(a,x)=TRUE)
         implies Pj(it,y) = FALSE);
end;


theorem :: BVFUNC_1:33
for a being Element of Funcs(Y,BOOLEAN),PA being a_partition of Y
holds
  B_INF(a,PA) is_dependent_of PA;

theorem :: BVFUNC_1:34
for a being Element of Funcs(Y,BOOLEAN),PA being a_partition of Y
holds
  B_SUP(a,PA) is_dependent_of PA;

theorem :: BVFUNC_1:35
for a being Element of Funcs(Y,BOOLEAN),PA being a_partition of Y
holds
   B_INF(a,PA) '<' a;

theorem :: BVFUNC_1:36
for a being Element of Funcs(Y,BOOLEAN),PA being a_partition of Y
holds
   a '<' B_SUP(a,PA);

theorem :: BVFUNC_1:37
for a being Element of Funcs(Y,BOOLEAN),PA being a_partition of Y
holds
   'not' B_INF(a,PA) = B_SUP('not' a,PA);

theorem :: BVFUNC_1:38
for a being Element of Funcs(Y,BOOLEAN) holds
  B_INF(a,%O(Y))=B_INF(a);

theorem :: BVFUNC_1:39
for a being Element of Funcs(Y,BOOLEAN) holds
  B_SUP(a,%O(Y))=B_SUP(a);

theorem :: BVFUNC_1:40
for a being Element of Funcs(Y,BOOLEAN) holds
  B_INF(a,%I(Y))=a;

theorem :: BVFUNC_1:41
for a being Element of Funcs(Y,BOOLEAN) holds
  B_SUP(a,%I(Y))=a;

theorem :: BVFUNC_1:42
for a,b being Element of Funcs(Y,BOOLEAN),PA being a_partition of Y
  holds B_INF(a '&' b,PA)=B_INF(a,PA) '&' B_INF(b,PA);

theorem :: BVFUNC_1:43
for a,b being Element of Funcs(Y,BOOLEAN),PA being a_partition of Y
 holds B_SUP(a 'or' b,PA)=B_SUP(a,PA) 'or' B_SUP(b,PA);

definition let Y;let f be Element of Funcs(Y,BOOLEAN);
 func GPart(f) -> a_partition of Y equals
:: BVFUNC_1:def 21
   {{x where x is Element of Y:f.x = TRUE },
    {x' where x' is Element of Y:f.x' = FALSE}} \ {{}};
end;


theorem :: BVFUNC_1:44
for a being Element of Funcs(Y,BOOLEAN) holds
  a is_dependent_of GPart(a);

theorem :: BVFUNC_1:45
for a being Element of Funcs(Y,BOOLEAN),PA being a_partition of Y
  st a is_dependent_of PA holds PA is_finer_than GPart(a);
