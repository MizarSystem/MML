:: Partial Functions from a Domain to the Set of Real Numbers
::  by Jaros{\l}aw Kotowicz
::
:: Received May 27, 1990
:: Copyright (c) 1990 Association of Mizar Users

environ

 vocabularies PARTFUN1, ARYTM, ARYTM_1, RELAT_1, ARYTM_3, BOOLE, FUNCT_1,
      FINSEQ_1, SEQ_1, ABSVALUE, FUNCT_3, MEMBERED, ZF_LANG, ASYMPT_0,
      VALUED_0, COMPLEX1, XCMPLX_0, SEQM_3, SEQ_2, LATTICES;
 notations TARSKI, XBOOLE_0, SUBSET_1, ORDINAL1, NUMBERS, XCMPLX_0, XXREAL_0,
      XREAL_0, COMPLEX1, MEMBERED, RELAT_1, FUNCT_1, RELSET_1, PARTFUN1,
      FUNCT_3, PARTFUN2, VALUED_0, VALUED_1, SEQ_1, SEQ_2, REAL_1;
 constructors PARTFUN1, FUNCT_3, XXREAL_0, REAL_1, COMPLEX1, VALUED_1,
      PARTFUN2, SEQ_2, SEQ_1;
 registrations XBOOLE_0, FUNCT_1, RELSET_1, NUMBERS, XREAL_0, MEMBERED,
      VALUED_0, VALUED_1, XCMPLX_0, SEQ_2, XXREAL_0, RELAT_1, FUNCOP_1;
 requirements NUMERALS, SUBSET, BOOLE, ARITHM, REAL;


begin

reserve x,X,Y for set;
reserve C for non empty set;
reserve c for Element of C;
reserve f,f1,f2,f3,g,g1 for complex-valued Function;
reserve r,r1,r2,p for complex number;

::
::OPERATIONS ON PARTIAL FUNCTIONS FROM A DOMAIN, TO THE SET OF REAL NUMBERS
::

definition
  let f1,f2 be complex-valued Function;
  canceled 3;
  func f1/f2 -> Function means
:: RFUNCT_1:def 4

  dom it = dom f1 /\ (dom f2 \ f2"{0}) &
  for c being set st c in dom it holds it.c = f1.c * (f2.c)";
end;

registration
  let f1, f2 be complex-valued Function;
  cluster f1/f2 -> complex-valued;
end;

registration
  let f1, f2 be real-valued Function;
  cluster f1/f2 -> real-valued;
end;

definition
  let C be set, D be complex-membered set;
  let f1, f2 be PartFunc of C,D;
  redefine func f1/f2 -> PartFunc of C,COMPLEX;
end;

definition
  let C be set, D be real-membered set;
  let f1, f2 be PartFunc of C,D;
  redefine func f1/f2 -> PartFunc of C,REAL;
end;

definition
  let f be complex-valued Function;
  canceled 3;
  func f^ -> Function means
:: RFUNCT_1:def 8

  dom it = dom f \ f"{0} &
  for c being set st c in dom it holds it.c = (f.c)";
end;

registration
  let f be complex-valued Function;
  cluster f^ -> complex-valued;
end;

registration
  let f be real-valued Function;
  cluster f^ -> real-valued;
end;

definition
  let C be set, D be complex-membered set, f be PartFunc of C,D;
  redefine func f^ -> PartFunc of C,COMPLEX;
end;

definition
  let C be set, D be real-membered set, f be PartFunc of C,D;
  redefine func f^ -> PartFunc of C,REAL;
end;

canceled 10;

theorem :: RFUNCT_1:11
  dom (g^) c= dom g & dom g /\ (dom g \ g"{0}) = dom g \ g"{0};

theorem :: RFUNCT_1:12
  dom (f1(#)f2) \ (f1(#)f2)"{0} = (dom f1 \ f1"{0}) /\ (dom f2 \ f2"{0});

theorem :: RFUNCT_1:13
  c in dom (f^) implies f.c <> 0;

theorem :: RFUNCT_1:14
  (f^)"{0} = {};

theorem :: RFUNCT_1:15
  (abs(f))"{0} = f"{0} & (-f)"{0} = f"{0};

theorem :: RFUNCT_1:16
  dom (f^^) = dom (f|(dom (f^)));

theorem :: RFUNCT_1:17
  r<>0 implies (r(#)f)"{0} = f"{0};

::
:: BASIC PROPERTIES OF OPERATIONS
::

canceled;

theorem :: RFUNCT_1:19
  (f1 + f2) + f3 = f1 + (f2 + f3);

canceled;

theorem :: RFUNCT_1:21
  (f1 (#) f2) (#) f3 = f1 (#) (f2 (#) f3);

theorem :: RFUNCT_1:22
  (f1 + f2) (#) f3=f1 (#) f3 + f2 (#) f3;

theorem :: RFUNCT_1:23
  f3 (#) (f1 + f2)=f3(#)f1 + f3(#)f2;

theorem :: RFUNCT_1:24
  r(#)(f1(#)f2)=r(#)f1(#)f2;

theorem :: RFUNCT_1:25
  r(#)(f1(#)f2)=f1(#)(r(#)f2);

theorem :: RFUNCT_1:26
  (f1 - f2)(#)f3=f1(#)f3 - f2(#)f3;

theorem :: RFUNCT_1:27
  f3(#)f1 - f3(#)f2 = f3(#)(f1 - f2);

theorem :: RFUNCT_1:28
  r(#)(f1 + f2) = r(#)f1 + r(#)f2;

theorem :: RFUNCT_1:29
  (r*p)(#)f = r(#)(p(#)f);

theorem :: RFUNCT_1:30
  r(#)(f1 - f2) = r(#)f1 - r(#)f2;

theorem :: RFUNCT_1:31
  f1-f2 = (-1)(#)(f2-f1);

theorem :: RFUNCT_1:32
  f1 - (f2 + f3) = f1 - f2 - f3;

theorem :: RFUNCT_1:33
  1(#)f = f;

theorem :: RFUNCT_1:34
  f1 - (f2 - f3) = f1 - f2 + f3;

theorem :: RFUNCT_1:35
  f1 + (f2 - f3) = f1 + f2 - f3;

theorem :: RFUNCT_1:36
  abs(f1(#)f2) = abs(f1)(#)abs(f2);

theorem :: RFUNCT_1:37
  abs(r(#)f) = abs(r)(#)abs(f);

canceled 4;

theorem :: RFUNCT_1:42
  f^^ = f|(dom (f^));

theorem :: RFUNCT_1:43
  (f1(#)f2)^ = (f1^)(#)(f2^);

theorem :: RFUNCT_1:44
  r<>0 implies (r(#)f)^ = r" (#) (f^);

theorem :: RFUNCT_1:45
  (-f)^ = (-1)(#)(f^);

theorem :: RFUNCT_1:46
  (abs(f))^ = abs(f^);

theorem :: RFUNCT_1:47
  f/g = f(#) (g^);

theorem :: RFUNCT_1:48
  r(#)(g/f) = (r(#)g)/f;

theorem :: RFUNCT_1:49
  (f/g)(#)g = (f|dom(g^));

theorem :: RFUNCT_1:50
  (f/g)(#)(f1/g1) = (f(#)f1)/(g(#)g1);

theorem :: RFUNCT_1:51
  (f1/f2)^ = (f2|dom(f2^))/f1;

theorem :: RFUNCT_1:52
  g (#) (f1/f2) = (g (#) f1)/f2;

theorem :: RFUNCT_1:53
  g/(f1/f2) = (g(#)(f2|dom(f2^)))/f1;

theorem :: RFUNCT_1:54
  -f/g = (-f)/g & f/(-g) = -f/g;

theorem :: RFUNCT_1:55
  f1/f + f2/f = (f1 + f2)/f & f1/f - f2/f = (f1 - f2)/f;

theorem :: RFUNCT_1:56
  f1/f + g1/g = (f1(#)g + g1(#)f)/(f(#)g);

theorem :: RFUNCT_1:57
  (f/g)/(f1/g1) = (f(#)(g1|dom(g1^)))/(g(#)f1);

theorem :: RFUNCT_1:58
  f1/f - g1/g = (f1(#)g - g1(#)f)/(f(#)g);

theorem :: RFUNCT_1:59
  abs(f1/f2) = abs(f1)/abs(f2);

theorem :: RFUNCT_1:60
  (f1+f2)|X = f1|X + f2|X & (f1+f2)|X = f1|X + f2 & (f1+f2)|X = f1 + f2|X;

theorem :: RFUNCT_1:61
  (f1(#)f2)|X = f1|X (#) f2|X & (f1(#)f2)|X = f1|X (#) f2 &
  (f1(#)f2)|X = f1 (#) f2|X;

theorem :: RFUNCT_1:62
  (-f)|X = -(f|X) & (f^)|X = (f|X)^ & (abs(f))|X = abs((f|X));

theorem :: RFUNCT_1:63
  (f1-f2)|X = f1|X - f2|X & (f1-f2)|X = f1|X - f2 & (f1-f2)|X = f1 - f2|X;

theorem :: RFUNCT_1:64
  (f1/f2)|X = f1|X / f2|X & (f1/f2)|X = f1|X / f2 &(f1/f2)|X = f1 / f2|X;

theorem :: RFUNCT_1:65
  (r(#)f)|X = r(#)(f|X);

::
:: TOTAL PARTIAL FUNCTIONS FROM A DOMAIN, TO REAL
::

reserve r,r1,r2,p for real number;
reserve f,f1,f2 for PartFunc of C,REAL;

theorem :: RFUNCT_1:66
  (f1 is total & f2 is total iff f1+f2 is total) &
  (f1 is total & f2 is total iff f1-f2 is total) &
  (f1 is total & f2 is total iff f1(#)f2 is total);

theorem :: RFUNCT_1:67
  f is total iff r(#)f is total;

theorem :: RFUNCT_1:68
  f is total iff -f is total;

theorem :: RFUNCT_1:69
  f is total iff abs(f) is total;

theorem :: RFUNCT_1:70
  f^ is total iff f"{0} = {} & f is total;

theorem :: RFUNCT_1:71
  f1 is total & f2"{0} = {} & f2 is total iff f1/f2 is total;

theorem :: RFUNCT_1:72
  f1 is total & f2 is total implies (f1+f2).c = f1.c + f2.c &
  (f1-f2).c = f1.c - f2.c & (f1(#)f2).c = f1.c * f2.c;

theorem :: RFUNCT_1:73
  f is total implies (r(#)f).c = r * (f.c);

theorem :: RFUNCT_1:74
  f is total implies (-f).c = - f.c & (abs(f)).c = abs( f.c );

theorem :: RFUNCT_1:75
  f^ is total implies (f^).c = (f.c)";

theorem :: RFUNCT_1:76
  f1 is total & f2^ is total implies (f1/f2).c = f1.c *(f2.c)";

::
:: CHARCTERISTIC FUNCTION OF A SUBSET OF A DOMAIN
::

definition
  let X,C be set;
  redefine func chi(X,C) -> PartFunc of C,REAL;
end;

theorem :: RFUNCT_1:77
  f= chi(X,C) iff ( dom f = C &
  for c holds (c in X implies f.c = 1) & (not c in X implies f.c = 0));

theorem :: RFUNCT_1:78
  chi(X,C) is total;

theorem :: RFUNCT_1:79
  c in X iff chi(X,C).c = 1;

theorem :: RFUNCT_1:80
  not c in X iff chi(X,C).c = 0;

theorem :: RFUNCT_1:81
  c in C \ X iff chi(X,C).c = 0;

canceled;

theorem :: RFUNCT_1:83
  chi(C,C).c = 1;

theorem :: RFUNCT_1:84
  chi(X,C).c <> 1 iff chi(X,C).c = 0;

theorem :: RFUNCT_1:85
  X misses Y implies chi(X,C) + chi(Y,C) = chi(X \/ Y,C);

theorem :: RFUNCT_1:86
  chi(X,C) (#) chi(Y,C) = chi(X /\ Y,C);

::
:: BOUNDED AND CONSTANT PARTIAL FUNCTIONS FROM A DOMAIN, TO REAL
::

reserve f for real-valued Function;

theorem :: RFUNCT_1:87
 f|Y is bounded_above iff
  ex r st for c being set st c in Y /\ dom f holds f.c <= r;

theorem :: RFUNCT_1:88
 f|Y is bounded_below iff
  ex r st for c being set st c in Y /\ dom f holds r <= f.c;

theorem :: RFUNCT_1:89
  f is bounded iff
  ex r st for c being set st c in dom f holds abs(f.c)<=r;

theorem :: RFUNCT_1:90
  f|Y is bounded iff
  ex r st for c being set st c in Y /\ dom f holds abs(f.c)<=r;

theorem :: RFUNCT_1:91
  (Y c= X & f|X is bounded_above implies f|Y is bounded_above) &
  (Y c= X & f|X is bounded_below implies f|Y is bounded_below) &
  (Y c= X & f|X is bounded implies f|Y is bounded);

theorem :: RFUNCT_1:92
  f|X is bounded_above & f|Y is bounded_below implies
  f|(X /\ Y) is bounded;

registration
 cluster constant -> bounded (real-valued Function);
end;

theorem :: RFUNCT_1:93
  X misses dom f implies f|X is bounded;

theorem :: RFUNCT_1:94
  (0(#)f)|Y is bounded;

registration let f be bounded_above (real-valued Function), X be set;
 cluster f|X -> bounded_above (real-valued Function);
end;

registration let f be bounded_below (real-valued Function), X be set;
 cluster f|X -> bounded_below (real-valued Function);
end;

registration let f be bounded_above (real-valued Function);
 let r be non negative (real number);
 cluster r(#)f -> bounded_above (real-valued Function);
end;

registration let f be bounded_below (real-valued Function);
 let r be non negative (real number);
 cluster r(#)f -> bounded_below (real-valued Function);
end;

registration let f be bounded_above (real-valued Function);
 let r be non positive (real number);
 cluster r(#)f -> bounded_below (real-valued Function);
end;

registration let f be bounded_below (real-valued Function);
 let r be non positive (real number);
 cluster r(#)f -> bounded_above (real-valued Function);
end;

theorem :: RFUNCT_1:95
  (f|Y is bounded_above & 0<=r implies (r(#)f)|Y is bounded_above) &
  (f|Y is bounded_above & r<=0 implies (r(#)f)|Y is bounded_below);

theorem :: RFUNCT_1:96
  (f|Y is bounded_below & 0<=r implies (r(#)f)|Y is bounded_below) &
  (f|Y is bounded_below & r<=0 implies (r(#)f)|Y is bounded_above);

theorem :: RFUNCT_1:97
  f|Y is bounded implies (r(#)f)|Y is bounded;

registration let f;
 cluster abs f -> bounded_below;
end;

theorem :: RFUNCT_1:98
  (abs f)|X is bounded_below;

registration let f be bounded (real-valued Function);
 cluster abs f -> bounded (real-valued Function);
end;

registration let f be bounded_above (real-valued Function);
 cluster -f -> bounded_below (real-valued Function);
end;

theorem :: RFUNCT_1:99
  f|Y is bounded implies (abs f)|Y is bounded & (-f)|Y is bounded;

reserve f1,f2 for real-valued Function;

registration let f1,f2 be bounded_above (real-valued Function);
 cluster f1+f2 -> bounded_above (real-valued Function);
end;

registration let f1,f2 be bounded_below (real-valued Function);
 cluster f1+f2 -> bounded_below (real-valued Function);
end;

theorem :: RFUNCT_1:100
  (f1|X is bounded_above & f2|Y is bounded_above implies
  (f1+f2)|(X /\ Y) is bounded_above) &
  (f1|X is bounded_below & f2|Y is bounded_below implies
  (f1+f2)|(X /\ Y) is bounded_below) &
  (f1|X is bounded & f2|Y is bounded implies (f1+f2)|(X /\ Y) is bounded);

registration let f1,f2 be bounded (real-valued Function);
 cluster f1(#)f2 -> bounded (real-valued Function);
end;

theorem :: RFUNCT_1:101
  f1|X is bounded & f2|Y is bounded implies
  (f1(#)f2)|(X /\ Y) is bounded & (f1-f2)|(X /\ Y) is bounded;

theorem :: RFUNCT_1:102
  f|X is bounded_above & f|Y is bounded_above implies
  f|(X \/ Y) is bounded_above;

theorem :: RFUNCT_1:103
  f|X is bounded_below & f|Y is bounded_below implies
  f|(X \/ Y) is bounded_below;

theorem :: RFUNCT_1:104
  f|X is bounded & f|Y is bounded implies f|(X \/ Y) is bounded;

reserve f,f1,f2 for PartFunc of C,REAL;

registration let C; let f1,f2 be constant PartFunc of C,REAL;
 cluster f1+f2 -> constant;
 cluster f1-f2 -> constant;
 cluster f1(#)f2 -> constant;
end;

theorem :: RFUNCT_1:105
  f1|X is constant & f2|Y is constant implies
  (f1+f2)|(X /\ Y) is constant & (f1-f2)|(X /\ Y) is constant &
  (f1(#)f2)|(X /\ Y) is constant;

registration let C; let f be constant PartFunc of C,REAL;
 cluster -f -> constant;
 cluster abs f -> constant;
 let p;
 cluster p(#)f -> constant;
end;

theorem :: RFUNCT_1:106
  f|Y is constant implies (p(#)f)|Y is constant;

theorem :: RFUNCT_1:107
  f|Y is constant implies (-f)|Y is constant;

theorem :: RFUNCT_1:108
  f|Y is constant implies (abs f)|Y is constant;

theorem :: RFUNCT_1:109
  f|Y is constant implies (for r holds (r(#)f)|Y is bounded) &
  (-f)|Y is bounded & (abs f)|Y is bounded;

theorem :: RFUNCT_1:110
  (f1|X is bounded_above & f2|Y is constant implies
  (f1+f2)|(X /\ Y) is bounded_above) &
  (f1|X is bounded_below & f2|Y is constant implies
  (f1+f2)|(X /\ Y) is bounded_below) &
  (f1|X is bounded & f2|Y is constant implies
  (f1+f2)|(X /\ Y) is bounded);

theorem :: RFUNCT_1:111
  (f1|X is bounded_above & f2|Y is constant implies
  (f1-f2)|(X /\ Y) is bounded_above) &
  (f1|X is bounded_below & f2|Y is constant implies
  (f1-f2)|(X /\ Y) is bounded_below) &
  (f1|X is bounded & f2|Y is constant implies
  (f1-f2)|(X /\ Y) is bounded &
  (f2-f1)|(X /\ Y) is bounded& (f1(#)f2)|(X /\ Y) is bounded);

