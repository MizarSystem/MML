:: Euclide Algorithm
::  by Andrzej Trybulec and Yatsuka Nakamura
::
:: Received October 8, 1993
:: Copyright (c) 1993 Association of Mizar Users

environ

 vocabularies NUMBERS, SUBSET_1, AMI_3, CARD_1, NAT_1, AMI_1, FUNCOP_1,
      RELAT_1, GRAPHSP, FUNCT_4, FSM_1, FUNCT_1, XBOOLE_0, TARSKI, ARYTM_3,
      INT_1, XXREAL_0, MSUALG_1, INT_2, COMPLEX1, PARTFUN1, TURING_1, STRUCT_0,
      GLIB_000, AMI_4, ORDINAL1, SCMNORM, PBOOLE;
 notations TARSKI, XBOOLE_0, ENUMSET1, SUBSET_1, NUMBERS, RELAT_1, FUNCT_1,
      INT_1, NAT_1, FUNCOP_1, INT_2, FUNCT_4, PBOOLE, STRUCT_0, PARTFUN1,
      COMPOS_1, EXTPRO_1, AMI_3, XXREAL_0;
 constructors XXREAL_0, NAT_D, AMI_3, RELSET_1, PRE_POLY, DOMAIN_1, AMI_1,
      AMI_2;
 registrations SETFAM_1, ORDINAL1, RELSET_1, NUMBERS, XXREAL_0, XREAL_0, NAT_1,
      INT_1, CARD_3, STRUCT_0, AMI_3, AMI_1, XBOOLE_0, FINSET_1, FUNCT_2,
      FUNCT_4, PBOOLE, COMPOS_1, EXTPRO_1, FUNCOP_1;
 requirements REAL, NUMERALS, SUBSET, BOOLE, ARITHM;


begin :: Preliminaries

reserve i,j,k for Element of NAT;

begin :: Euclide algorithm

definition
  let i be Nat, I be Instruction of SCM;
  redefine func i .--> I -> NAT-defined FinPartState of SCM;
end;

definition
  func Euclide-Algorithm -> NAT-defined FinPartState of SCM equals
:: AMI_4:def 1
  (0 .--> (dl.2 := dl.1)) +* ((1 .--> Divide(dl.0,dl.1)) +*
  ((2 .--> (dl.0 := dl.2)) +* ((3 .--> (dl.1 >0_goto 0)) +*
  (4 .--> halt SCM))));
end;

canceled 3;

theorem :: AMI_4:4
  dom (Euclide-Algorithm qua Function) = 5;

begin :: Natural semantics of the program

theorem :: AMI_4:5
  for s being State of SCM
  for P being (the Instructions of SCM)-valued ManySortedSet of NAT
   st Euclide-Algorithm c= P
  for k st IC Comput(P,s,k) = 0 holds IC Comput(P,s,k+1) = 1 &
  Comput(P,s,k+1).dl.0 = Comput(P,s,k).dl.0 &
  Comput(P,s,k+1).dl.1 = Comput(P,s,k).dl.1 &
  Comput(P,s,k+1).dl.2 = Comput(P,s,k).dl.1;

theorem :: AMI_4:6
  for s being State of SCM
  for P being (the Instructions of SCM)-valued ManySortedSet of NAT
   st Euclide-Algorithm c= P
  for k st IC
Comput(P,s,k) = 1 holds IC Comput(P,s,k+1) = 2 &
Comput(P,s,k+1).dl.0
  = Comput(P,s,k).dl.0 div Comput(P,s,k).dl.1 &
Comput(P,s,k+1).dl.1 =
  Comput(P,s,k).dl.0 mod Comput(P,s,k).dl.1 & Comput(P,s,k+1).dl.2 =
  Comput(P,s,k).dl.2;

theorem :: AMI_4:7
  for s being State of SCM
  for P being (the Instructions of SCM)-valued ManySortedSet of NAT
   st Euclide-Algorithm c= P
  for k st IC
Comput(P,s,k) = 2 holds IC Comput(P,s,k+1) = 3 &
Comput(P,s,k+1).dl.0
  = Comput(P,s,k).dl.2 & Comput(P,s,k+1).dl.1 =
Comput(P,s,k).dl.1 &
  Comput(P,s,k+1).dl.2 = Comput(P,s,k).dl.2;

theorem :: AMI_4:8
 for s being State of SCM
  for P being (the Instructions of SCM)-valued ManySortedSet of NAT
   st Euclide-Algorithm c= P
   for k st IC
Comput(P,s,k) = 3 holds ( Comput(P,s,k).dl.1 > 0
implies IC Comput(P,s,k+1) = 0) &
( Comput(P,s,k).dl.1 <= 0 implies IC Comput(P,s,k+1) = 4) &
  Comput(P,s,k+1).dl.0 = Comput(P,s,k).dl.0 & Comput(P,s,k+1).dl.1 =
  Comput(P,s,k).dl.1;

theorem :: AMI_4:9
  for s being State of SCM
  for P being (the Instructions of SCM)-valued ManySortedSet of NAT
  st Euclide-Algorithm c= P
  for k,i st IC
  Comput(P,s,k) = 4 holds Comput(P,s,k+i) = Comput(P,s,k);

theorem :: AMI_4:10
  for s being 0-started State of SCM
  for P being (the Instructions of SCM)-valued ManySortedSet of NAT
   st Euclide-Algorithm c= P
   for x, y being Integer st s.dl.0 = x & s.dl.1 = y & x > 0 & y > 0 holds (
  Result(P,s)).dl.0 = x gcd y;

definition
  func Euclide-Function -> PartFunc of FinPartSt SCM, FinPartSt SCM means
:: AMI_4:def 2

   for p,q being FinPartState of SCM holds [p,q] in it iff ex x,y being
Integer st x > 0 & y > 0 & p = (dl.0,dl.1) --> (x,y) & q = dl.0 .--> (x gcd y);
end;

theorem :: AMI_4:11
  for p being set holds p in dom Euclide-Function iff ex x,y being
  Integer st x > 0 & y > 0 & p = (dl.0,dl.1) --> (x,y);

theorem :: AMI_4:12
  for i,j being Integer st i > 0 & j > 0 holds Euclide-Function.((
  dl.0,dl.1) --> (i,j)) = dl.0 .--> (i gcd j);

registration
 cluster Euclide-Algorithm -> (the Instructions of SCM)-valued;
end;

registration
 cluster Euclide-Algorithm -> non halt-free;
end;

theorem :: AMI_4:13
  ProgramPart((Start-At(0,SCM)) +* (Euclide-Algorithm)),
   Start-At(0,SCM) +* Euclide-Algorithm qua FinPartState of SCM
   computes Euclide-Function;

