:: Insert Sort on SCMPDS
::  by JingChao Chen
::
:: Received June 14, 2000
:: Copyright (c) 2000 Association of Mizar Users

environ

 vocabulary AMI_3, SCMPDS_2, AMI_1, SCMPDS_4, CARD_1, SCMFSA6A, FINSEQ_1,
      INT_1, FUNCT_1, SCMP_GCD, RFUNCT_2, RELAT_1, RFINSEQ, AMI_2, SCMPDS_8,
      SCMPDS_5, SCMFSA6B, UNIALG_2, SCMFSA7B, SCMFSA_7, SCMPDS_7, ARYTM_1,
      RELOC, FUNCT_4, SCMPDS_3, FUNCT_7, SCM_1, BOOLE, AMI_5, SCMISORT,
      SCMFSA_9, SCMFSA8B, ABSVALUE, SCPISORT;
 notation XBOOLE_0, XCMPLX_0, XREAL_0, RELAT_1, FUNCT_1, FUNCT_4, INT_1, NAT_1,
      AMI_1, AMI_2, AMI_3, AMI_5, FUNCT_7, SCMPDS_2, SCMPDS_3, CARD_1,
      SCMPDS_4, SCM_1, SCMPDS_5, SCMPDS_6, SCMP_GCD, DOMAIN_1, FINSEQ_1,
      SCMPDS_7, SCMPDS_8, ABSVALUE, SFMASTR3, RFINSEQ;
 constructors REAL_1, DOMAIN_1, AMI_5, SCMPDS_4, SCM_1, SCMPDS_5, SCMPDS_6,
      SCMP_GCD, SCMPDS_7, SCMPDS_8, SFMASTR3, RFINSEQ, NAT_1, MEMBERED, RAT_1;
 clusters AMI_1, INT_1, FUNCT_1, RELSET_1, SCMPDS_2, SCMFSA_4, SCMPDS_4,
      SCMPDS_5, SCMPDS_6, SCMPDS_7, SCMPDS_8, WSIERP_1, NAT_1, FRAENKEL,
      XREAL_0, MEMBERED;
 requirements NUMERALS, REAL, SUBSET, BOOLE, ARITHM;


begin :: Preliminaries

reserve x for Int_position,
        n,p0 for Nat;

definition
 let f be FinSequence of INT,s be State of SCMPDS,m be Nat;
 pred f is_FinSequence_on s,m means
:: SCPISORT:def 1
  for i be Nat st 1 <= i & i <= len f holds f.i=s.intpos(m+i);
end;

theorem :: SCPISORT:1
 for f being FinSequence of INT,m,n be Nat st m >= n holds
 f is_non_decreasing_on m,n;

theorem :: SCPISORT:2
  for s being State of SCMPDS,n,m be Nat holds
     ex f be FinSequence of INT st len f=n &
     for i be Nat st 1<=i & i <= len f holds f.i=s.intpos(m+i);

theorem :: SCPISORT:3
   for s being State of SCMPDS,n,m be Nat holds
    ex f be FinSequence of INT st len f=n & f is_FinSequence_on s,m;

theorem :: SCPISORT:4
 for f,g be FinSequence of INT,m,n be Nat st 1<=n & n <= len f &
 1<=m & m <= len f & len f=len g & f.m=g.n & f.n=g.m &
 (for k be Nat st k<>m & k<>n & 1<=k & k <= len f holds f.k=g.k)
 holds f,g are_fiberwise_equipotent;

theorem :: SCPISORT:5   ::see SCMPDS_8:2
 for s1,s2 being State of SCMPDS st
     (for a being Int_position holds s1.a = s2.a)
 holds Dstate(s1)=Dstate(s2);

theorem :: SCPISORT:6    :: see SCMPDS_7:50
 for s being State of SCMPDS, I being No-StopCode Program-block,
 j being parahalting shiftable Instruction of SCMPDS st
 I is_closed_on s & I is_halting_on s
 holds (I ';' j) is_closed_on s & (I ';' j) is_halting_on s;

theorem :: SCPISORT:7   :: see SCMPDS_7:49
   for s being State of SCMPDS, I being No-StopCode Program-block,
 J being shiftable parahalting Program-block,a be Int_position st
   I is_closed_on s & I is_halting_on s
 holds IExec(I ';' J, s).a = IExec(J,IExec(I,s)).a;

theorem :: SCPISORT:8   :: see SCMPDS_7:49
   for s being State of SCMPDS, I being No-StopCode parahalting Program-block,
 J being shiftable Program-block,a be Int_position st J is_closed_on
 IExec(I,s) & J is_halting_on IExec(I,s) holds
  IExec(I ';' J, s).a = IExec(J,IExec(I,s)).a;

theorem :: SCPISORT:9     :: SCMPDS_7:43
   for s being State of SCMPDS, I being Program-block,J being shiftable
 parahalting Program-block st I is_closed_on s & I is_halting_on s
 holds I ';' J is_closed_on s & I ';' J is_halting_on s;

theorem :: SCPISORT:10     :: SCMPDS_7:43
   for s being State of SCMPDS, I being parahalting Program-block,J being
 shiftable Program-block st J is_closed_on IExec(I,s) & J is_halting_on
 IExec(I,s) holds
     I ';' J is_closed_on s & I ';' J is_halting_on s;

theorem :: SCPISORT:11      :: SCMPDS_7:43
   for s being State of SCMPDS, I being Program-block, j being parahalting
 shiftable Instruction of SCMPDS st I is_closed_on s & I is_halting_on s
 holds I ';' j is_closed_on s & I ';' j is_halting_on s;

begin :: Computing the Execution Result of For-loop Program by Loop-Invariant

scheme :: SCPISORT:sch 1
 ForDownHalt { P[set],
 s() -> State of SCMPDS,I() -> No-StopCode shiftable Program-block,
 a() -> Int_position,i() -> Integer,n() -> Nat}:
    (P[s()] or not P[s()]) &
     for-down(a(),i(),n(),I()) is_closed_on s() &
     for-down(a(),i(),n(),I()) is_halting_on s()
provided
 n() > 0 and
 P[Dstate s()] and
 for t be State of SCMPDS st
       P[Dstate t] & t.a()=s().a() & t.DataLoc(s().a(),i()) > 0
    holds IExec(I() ';' AddTo(a(),i(),-n()),t).a()=t.a() &
     IExec(I() ';' AddTo(a(),i(),-n()),t).DataLoc(s().a(),i())
        =t.DataLoc(s().a(),i())-n() &
        I() is_closed_on t & I() is_halting_on t &
        P[Dstate(IExec(I() ';' AddTo(a(),i(),-n()),t))]
proof
   set b=DataLoc(s().a(),i());
   set i1=(a(),i())<=0_goto (card I()+3),
       J=I() ';' AddTo(a(),i(),-n()),
       i3=goto -(card I()+2);
   set FOR=for-down(a(),i(),n(),I()),
       pFOR=stop FOR,
       iFOR=Initialized pFOR,
       pJ=stop J ,
       IsJ= Initialized pJ;

    defpred Q[Nat] means
       for t be State of SCMPDS st t.b <= $1 &
       P[Dstate t] & t.a()=s().a()
      holds FOR is_closed_on t & FOR is_halting_on t;

A4:  Q[0] by SCMPDS_7:63;
A5:  for k be Nat st Q[k] holds Q[k + 1]
     proof
     let k be Nat;
     assume A6: Q[k];
        now
        let t be State of SCMPDS;
        assume A7: t.b <= k+1;
        assume A8: P[Dstate t];
        assume A9: t.a()=s().a();
        per cases;
        suppose t.b <= 0;
        hence FOR is_closed_on t & FOR is_halting_on t
         by A9,SCMPDS_7:63;
        end;
        suppose A10: t.b > 0;
        set t2 = t +* IsJ,
            t3 = t +* iFOR,
            C3 = Computation t3,
            t4 = C3.1,
            Jt = IExec(J,t);
A11:     card J = card I()+1 by SCMP_GCD:8;
then A12:     card J > 0 by NAT_1:19;
A13:     Jt.a()=t.a() & Jt.b=t.b-n()
        & I() is_closed_on t & I() is_halting_on t & P[Dstate Jt]
         by A3,A8,A9,A10;
then A14:    J is_closed_on t & J is_halting_on t by Th6;

A15:     IsJ c= t2 by FUNCT_4:26;
A16:     t2 is halting by A14,SCMPDS_6:def 3;
        then t2 +* IsJ is halting by A15,AMI_5:10;
then A17:     J is_halting_on t2 by SCMPDS_6:def 3;
A18:     J is_closed_on t2 by A14,SCMPDS_6:38;
A19:     inspos 0 in dom pFOR by SCMPDS_4:75;
A20:     IC t3 =inspos 0 by SCMPDS_6:21;
          FOR = i1 ';' (J ';' i3) by Lm3;
then A21:     CurInstr t3 = i1 by SCMPDS_6:22;
A22:     (Computation t3).(0 + 1) = Following (Computation t3).0 by AMI_1:def
19
        .= Following t3 by AMI_1:def 19
        .= Exec(i1,t3) by A21,AMI_1:def 18;
A23:     not a() in dom iFOR & a() in dom t by SCMPDS_2:49,SCMPDS_4:31;
A24:     not b in dom iFOR & b in dom t by SCMPDS_2:49,SCMPDS_4:31;
        A25: t3.DataLoc(t3.a(),i())= t3.b by A9,A23,FUNCT_4:12
        .= t.b by A24,FUNCT_4:12;
A26:     IC t4 = t4.IC SCMPDS by AMI_1:def 15
        .= Next IC t3 by A10,A22,A25,SCMPDS_2:68
        .= inspos(0+1) by A20,SCMPDS_4:70;
          t2,t3 equal_outside A by SCMPDS_4:36;
then A27:     t2 | D = t3 | D by SCMPDS_4:24;
          now let x;
          thus t2.x = t3.x by A27,SCMPDS_4:23
          .= t4.x by A22,SCMPDS_2:68;
        end;
then A28:    t2 | D = t4 | D by SCMPDS_4:23;

        set m2=LifeSpan t2,
            t5=(Computation t4).m2,
            l1=inspos (card J + 1);

A29:     IExec(J,t) = Result t2 +* t | A by SCMPDS_4:def 8;
A30:     dom (t | A) = A by SCMPDS_6:1;
then A31:     not a() in dom (t | A) by SCMPDS_2:53;
A32:     not b in dom (t | A) by A30,SCMPDS_2:53;

A33:     l1=inspos (card I()+(1+1)) by A11,XCMPLX_1:1;
          card I() + 2 < card I() + 3 by REAL_1:53;
then A34:     l1 in dom FOR by A33,SCMPDS_7:61;
A35:     FOR c= iFOR by SCMPDS_6:17;
          iFOR c= t3 by FUNCT_4:26;
then A36:     FOR c= t3 by A35,XBOOLE_1:1;
          Shift(J,1) c= FOR by Lm4;
        then Shift(J,1) c= t3 by A36,XBOOLE_1:1;
then A37:     Shift(J,1) c= t4 by AMI_3:38;
then A38:     (Computation t2).m2 | D = t5 | D
        by A12,A15,A17,A18,A26,A28,SCMPDS_7:36;
        A39: dom (t | A) = A by SCMPDS_6:1;
A40:     t5|D =(Result t2)|D by A16,A38,SCMFSA6B:16
        .= (Result t2 +* t | A)|D by A39,AMI_5:7,SCMPDS_2:10
        .= Jt | D by SCMPDS_4:def 8;

A41:     t5.a()=(Computation t2).m2.a() by A38,SCMPDS_4:23
        .=(Result t2).a() by A16,SCMFSA6B:16
        .=s().a() by A9,A13,A29,A31,FUNCT_4:12;

A42:     t5.b=(Computation t2).m2.b by A38,SCMPDS_4:23
        .=(Result t2).b by A16,SCMFSA6B:16
        .=t.b - n() by A13,A29,A32,FUNCT_4:12;

        set m3=m2 +1;
        set t6=(Computation t3).m3;
A43:     IC t5=l1 by A12,A15,A17,A18,A26,A28,A37,SCMPDS_7:36;
A44:     t6=t5 by AMI_1:51;
then A45:     CurInstr t6=t5.l1 by A43,AMI_1:def 17
        .=t4.l1 by AMI_1:54
        .=t3.l1 by AMI_1:54
        .=FOR.l1 by A34,A36,GRFUNC_1:8
        .=i3 by A33,SCMPDS_7:62;

        set m4=m3+1,
            t7=(Computation t3).m4;
A46:    t7 = Following t6 by AMI_1:def 19
       .= Exec(i3,t6) by A45,AMI_1:def 18;
A47:    IC t7=t7.IC SCMPDS by AMI_1:def 15
       .=ICplusConst(t6,-(card I()+2)) by A46,SCMPDS_2:66
       .=ICplusConst(t6,0-(card I()+2)) by XCMPLX_1:150
       .=inspos 0 by A33,A43,A44,SCMPDS_7:1;
A48:    t7.a()=s().a() by A41,A44,A46,SCMPDS_2:66;

         InsCode i3=0 by SCMPDS_2:21;
       then InsCode i3 in {0,4,5,6} by ENUMSET1:19;
       then Dstate(t7)=Dstate(t6) by A46,SCMPDS_8:3
       .=Dstate(Jt) by A40,A44,SCMPDS_8:2;
then A49:   P[Dstate t7] by A3,A8,A9,A10;
A50:    t7.b=t.b-n() by A42,A44,A46,SCMPDS_2:66
       .=-n()+t.b by XCMPLX_0:def 8;
         -(-n()) > 0 by A1;
       then -n() < 0 by REAL_1:66;
       then -n() <= -1 by INT_1:21;
       then -n()+t.b <= -1+t.b by AXIOMS:24;
then A51:    -n()+t.b <= t.b-1 by XCMPLX_0:def 8;
         t.b-1 <= k by A7,REAL_1:86;
       then -n()+t.b <= k by A51,AXIOMS:22;
then A52:    FOR is_closed_on t7 & FOR is_halting_on t7 by A6,A48,A49,A50;
A53:    t7 +* iFOR=t7 by A47,SCMPDS_7:37;
         now
          let k be Nat;
          per cases;
          suppose k < m4;
           then A54: k <= m3 by INT_1:20;
           hereby
              per cases by A54,NAT_1:26;
              suppose A55:k <= m2;
               hereby
               per cases;
                 suppose k=0;
                 hence IC (Computation t3).k in dom pFOR by A19,A20,AMI_1:def
19;
                 end;
                 suppose k<>0;
                  then consider kn be Nat such that
              A56: k=kn+1 by NAT_1:22;
                    kn < k by A56,REAL_1:69;
                  then kn < m2 by A55,AXIOMS:22;
              then A57: IC (Computation t2).kn + 1 = IC (Computation t4).kn
                  by A12,A15,A17,A18,A26,A28,A37,SCMPDS_7:34;
              A58: IC (Computation t2).kn in dom pJ by A14,SCMPDS_6:def 2;
                  consider lm be Nat such that
              A59: IC (Computation t2).kn=inspos lm by SCMPDS_3:32;
                    lm < card pJ by A58,A59,SCMPDS_4:1;
                  then lm < card J+1 by SCMPDS_5:7;
                  then lm+1 <= card J +1 by INT_1:20;
              then A60: lm+1 <= card I()+(1+1) by A11,XCMPLX_1:1;
                    card I() + 2 < card I() + 4 by REAL_1:53;
                  then lm+1 < card I() +4 by A60,AXIOMS:22;
                  then A61: lm+1 < card pFOR by Lm2;
                    IC (Computation t3).k=inspos lm +1 by A56,A57,A59,AMI_1:51
                  .=inspos (lm+1) by SCMPDS_3:def 3;
                  hence IC (Computation t3).k in dom pFOR by A61,SCMPDS_4:1;
               end;
               end;
              end;
              suppose A62:k=m3;
                 l1 in dom pFOR by A34,SCMPDS_6:18;
               hence IC (Computation t3).k in dom pFOR by A12,A15,A17,A18,A26,
A28,A37,A44,A62,SCMPDS_7:36;
            end;
            end;
          end;
          suppose k >= m4;
          then consider nn be Nat such that
         A63: k=m4+nn by NAT_1:28;
               C3.k=(Computation (t7 +* iFOR)).nn by A53,A63,AMI_1:51;
           hence IC (Computation t3).k in dom pFOR by A52,SCMPDS_6:def 2;
       end;
       end;
       hence FOR is_closed_on t by SCMPDS_6:def 2;
         t7 is halting by A52,A53,SCMPDS_6:def 3;
       then t3 is halting by SCM_1:27;
       hence FOR is_halting_on t by SCMPDS_6:def 3;
     end;
     end;
     hence Q[k+1];
     end;
A64:  for k being Nat holds Q[k] from NAT_1:sch 1(A4,A5);
     thus P[s()] or not P[s()];
     per cases;
     suppose s().b <= 0;
       hence FOR is_closed_on s() & FOR is_halting_on s() by SCMPDS_7:63;
     end;
     suppose s().b > 0;
     then reconsider m=s().b as Nat by INT_1:16;
       Q[m] by A64;
     hence FOR is_closed_on s() & FOR is_halting_on s() by A2;
end;
end;

scheme :: SCPISORT:sch 2
 ForDownExec { P[set],
 s() -> State of SCMPDS,I() -> No-StopCode shiftable Program-block,
 a() -> Int_position,i() -> Integer,n() -> Nat}:
    (P[s()] or not P[s()]) &
    IExec(for-down(a(),i(),n(),I()),s()) =
 IExec(for-down(a(),i(),n(),I()),IExec(I() ';' AddTo(a(),i(),-n()),s()))
 provided
 n() > 0 and
 s().DataLoc(s().a(),i()) > 0 and
 P[Dstate s()] and
 for t be State of SCMPDS st
       P[Dstate t] & t.a()=s().a() & t.DataLoc(s().a(),i()) > 0
    holds IExec(I() ';' AddTo(a(),i(),-n()),t).a()=t.a() &
        IExec(I() ';' AddTo(a(),i(),-n()),t).DataLoc(s().a(),i())
        =t.DataLoc(s().a(),i())-n() &
        I() is_closed_on t & I() is_halting_on t &
        P[Dstate(IExec(I() ';' AddTo(a(),i(),-n()),t))]
proof
   set b=DataLoc(s().a(),i());
   set i1=(a(),i())<=0_goto (card I()+3),
       J=I() ';' AddTo(a(),i(),-n()),
       i3=goto -(card I()+2);

   set FOR=for-down(a(),i(),n(),I()),
       iFOR=Initialized stop FOR,
       iJ= Initialized stop J,
       s1= s() +* iFOR,
       C1=Computation s1,
       ps= s() | A;
     defpred X[set] means P[$1];
A5: X[Dstate s()] by A3;
A6: for t be State of SCMPDS st
       X[Dstate t] & t.a()=s().a() & t.DataLoc(s().a(),i()) > 0
    holds IExec(I() ';' AddTo(a(),i(),-n()),t).a()=t.a() &
        IExec(I() ';' AddTo(a(),i(),-n()),t).DataLoc(s().a(),i())
        =t.DataLoc(s().a(),i())-n() &
        I() is_closed_on t & I() is_halting_on t &
        X[Dstate(IExec(I() ';' AddTo(a(),i(),-n()),t))] by A4;
      (X[s()] or not X[s()]) &
     for-down(a(),i(),n(),I()) is_closed_on s() &
     for-down(a(),i(),n(),I()) is_halting_on s()
        from ForDownHalt(A1,A5,A6);
then A7: s1 is halting by SCMPDS_6:def 3;
   set sJ= s() +* iJ,
       mJ=LifeSpan sJ,
       m1=mJ+2,
       s2=IExec(J,s()) +* iFOR,
       C2=Computation s2,
       m2=LifeSpan s2;
  set Es=IExec(J,s()),
      bj=DataLoc(Es.a(),i());

A8:  card J = card I()+1 by SCMP_GCD:8;
then A9:  card J > 0 by NAT_1:19;
A10:  Es.a()=s().a() & Es.b =s().b-n() &
     I() is_closed_on s() & I() is_halting_on s() &
     P[Dstate Es] by A2,A5,A6;
then A11:  J is_closed_on s() & J is_halting_on s() by Th6;
A12:  X[Dstate Es] by A2,A5,A6;
A13:  for t being State of SCMPDS st
       X[Dstate t] & t.a()=Es.a() & t.bj > 0 holds
       IExec(J,t).a()=t.a() & IExec(J,t).bj=t.bj-n() &
       I() is_closed_on t & I() is_halting_on t &
          X[Dstate IExec(J,t) ] by A6,A10;
    A14: (X[Es] or not X[Es]) & FOR is_closed_on Es & FOR is_halting_on Es
        from ForDownHalt(A1,A12,A13);

   set s4 = C1.1;
A15:  iJ c= sJ by FUNCT_4:26;
A16:  sJ is halting by A11,SCMPDS_6:def 3;
     then sJ +* iJ is halting by A15,AMI_5:10;
then A17:  J is_halting_on sJ by SCMPDS_6:def 3;
A18:  J is_closed_on sJ by A11,SCMPDS_6:38;
A19:  IC s1 =inspos 0 by SCMPDS_6:21;
A20:  FOR = i1 ';' (J ';' i3) by Lm3;
then A21:  CurInstr s1 = i1 by SCMPDS_6:22;
A22:  (Computation s1).(0 + 1) = Following (Computation s1).0 by AMI_1:def 19
        .= Following s1 by AMI_1:def 19
        .= Exec(i1,s1) by A21,AMI_1:def 18;
A23:  not a() in dom iFOR & a() in dom s() by SCMPDS_2:49,SCMPDS_4:31;
A24:  not b in dom iFOR & b in dom s() by SCMPDS_2:49,SCMPDS_4:31;
     A25: s1.DataLoc(s1.a(),i())=s1.b by A23,FUNCT_4:12
     .= s().b by A24,FUNCT_4:12;
A26:   IC s4 = s4.IC SCMPDS by AMI_1:def 15
      .= Next IC s1 by A2,A22,A25,SCMPDS_2:68
      .= inspos(0+1) by A19,SCMPDS_4:70;
        sJ,s1 equal_outside A by SCMPDS_4:36;
then A27:   sJ | D = s1 | D by SCMPDS_4:24;
          now let x;
          thus sJ.x = s1.x by A27,SCMPDS_4:23
          .= s4.x by A22,SCMPDS_2:68;
        end;
then A28:    sJ | D = s4 | D by SCMPDS_4:23;

        set s5=(Computation s4).mJ,
            l1=inspos (card J + 1);

A29:  IExec(J,s()) = Result sJ +* s() | A by SCMPDS_4:def 8;
A30:  dom (s() | A) = A by SCMPDS_6:1;

A31:  l1=inspos (card I()+(1+1)) by A8,XCMPLX_1:1;
       card I() + 2 < card I() + 3 by REAL_1:53;
then A32:  l1 in dom FOR by A31,SCMPDS_7:61;
A33:  FOR c= iFOR by SCMPDS_6:17;
       iFOR c= s1 by FUNCT_4:26;
then A34:  FOR c= s1 by A33,XBOOLE_1:1;
       Shift(J,1) c= FOR by Lm4;
     then Shift(J,1) c= s1 by A34,XBOOLE_1:1;
then A35:  Shift(J,1) c= s4 by AMI_3:38;

then A36:  (Computation sJ).mJ | D = s5 | D
       by A9,A15,A17,A18,A26,A28,SCMPDS_7:36;

      set m3=mJ +1;
      set s6=(Computation s1).m3;
A37:   IC s5=l1 by A9,A15,A17,A18,A26,A28,A35,SCMPDS_7:36;
A38:   s6=s5 by AMI_1:51;
then A39:   CurInstr s6=s5.l1 by A37,AMI_1:def 17
     .=s4.l1 by AMI_1:54
     .=s1.l1 by AMI_1:54
     .=FOR.l1 by A32,A34,GRFUNC_1:8
     .=i3 by A31,SCMPDS_7:62;

      set m4=m3+1,
      s7=(Computation s1).m4;
A40:   s7 = Following s6 by AMI_1:def 19
      .= Exec(i3,s6) by A39,AMI_1:def 18;
A41:   IC s7=s7.IC SCMPDS by AMI_1:def 15
      .=ICplusConst(s6,-(card I()+2)) by A40,SCMPDS_2:66
      .=ICplusConst(s6,0-(card I()+2)) by XCMPLX_1:150
      .=inspos 0 by A31,A37,A38,SCMPDS_7:1;

      A42: m4=mJ+(1+1) by XCMPLX_1:1
      .=mJ+2;
        now
       let x be Int_position;
         not x in dom iFOR & x in dom IExec(J,s())
          by SCMPDS_2:49,SCMPDS_4:31;
then A43:    s2.x=IExec(J,s()).x by FUNCT_4:12;
       A44:  not x in dom (s() | A) by A30,SCMPDS_2:53;
          s5.x=(Computation sJ).mJ.x by A36,SCMPDS_4:23
            .=(Result sJ).x by A16,SCMFSA6B:16
            .=IExec(J,s()).x by A29,A44,FUNCT_4:12;
      hence s7.x=s2.x by A38,A40,A43,SCMPDS_2:66;
     end;
     then A45: s7 | D = s2 | D by SCMPDS_4:23;
A46:  IC s2 =IC C1.m1 by A41,A42,SCMPDS_6:21;

A47: s2 is halting by A14,SCMPDS_6:def 3;
A48: dom ps = dom s() /\ A by RELAT_1:90
    .= ({IC SCMPDS} \/ D \/ A) /\ A by SCMPDS_4:19
    .= A by XBOOLE_1:21;
      s2 | A= (Result sJ +* ps +* iFOR) | A by SCMPDS_4:def 8
    .=(Result sJ +* ps)|A +* iFOR | A by AMI_5:6
    .= ps +* iFOR | A by A48,FUNCT_4:24
    .= s1 | A by AMI_5:6
    .= C1.m1 | A by SCMPDS_7:6;
then A49: C1.m1=s2 by A42,A45,A46,SCMPDS_7:7;
    then CurInstr C1.m1=i1 by A20,SCMPDS_6:22;
then A50: CurInstr C1.m1 <> halt SCMPDS by SCMPDS_6:30;
    set m0=LifeSpan s1;
      m0 > m1 by A7,A50,SCMPDS_6:2;
    then consider nn be Nat such that
A51: m0=m1+nn by NAT_1:28;
A52: C1.m0 = C2.nn by A49,A51,AMI_1:51;
    then CurInstr C2.nn =halt SCMPDS by A7,SCM_1:def 2;
then A53: nn >= m2 by A47,SCM_1:def 2;
      C1.(m1 + m2) = C2.m2 by A49,AMI_1:51;
    then CurInstr C1.(m1 + m2) = halt SCMPDS by A47,SCM_1:def 2;
    then m1 + m2 >= m0 by A7,SCM_1:def 2;
    then m2 >= nn by A51,REAL_1:53;
then nn=m2 by A53,AXIOMS:21;
then A54: Result s1 = C2.m2 by A7,A52,SCMFSA6B:16;
A55: IExec(J,s()) | A= (Result sJ +* ps) | A by SCMPDS_4:def 8
    .= ps by A48,FUNCT_4:24;
    thus P[s()] or not P[s()];
    thus IExec(FOR,s())
     = C2.m2 +* ps by A54,SCMPDS_4:def 8
    .= Result s2 +* IExec(J,s()) | A by A47,A55,SCMFSA6B:16
    .= IExec(FOR,IExec(J,s())) by SCMPDS_4:def 8;
end;

scheme :: SCPISORT:sch 3
 ForDownEnd { P[set],
 s() -> State of SCMPDS,I() -> No-StopCode shiftable Program-block,
 a() -> Int_position,i() -> Integer,n() -> Nat}:
    (P[s()] or not P[s()]) &
    IExec(for-down(a(),i(),n(),I()),s()).DataLoc(s().a(),i()) <= 0 &
     P[Dstate IExec(for-down(a(),i(),n(),I()),s())]
provided
 n() > 0 and
 P[Dstate s()] and
 for t be State of SCMPDS st
       P[Dstate t] & t.a()=s().a() & t.DataLoc(s().a(),i()) > 0
    holds IExec(I() ';' AddTo(a(),i(),-n()),t).a()=t.a() &
     IExec(I() ';' AddTo(a(),i(),-n()),t).DataLoc(s().a(),i())
        =t.DataLoc(s().a(),i())-n() &
        I() is_closed_on t & I() is_halting_on t &
        P[Dstate(IExec(I() ';' AddTo(a(),i(),-n()),t))]
proof
   set b=DataLoc(s().a(),i()),
       FR=for-down(a(),i(),n(),I());

    defpred Q[Nat] means
       for t be State of SCMPDS st t.b <= $1 & t.a()=s().a() & P[Dstate t]
      holds IExec(FR,t).b <= 0 & P[Dstate IExec(FR,t)];

A4: Q[0]
    proof
       let t be State of SCMPDS;
       assume A5: t.b <= 0 & t.a()=s().a() & P[Dstate t];
then A6:   for x be Int_position holds IExec(FR,t).x = t.x by SCMPDS_7:66;
      thus IExec(FR,t).b <= 0 by A5,SCMPDS_7:66;
     thus P[Dstate IExec(FR,t)] by A5,A6,Th5;
   end;
A7: now
       let k be Nat;
       assume A8:Q[k];
         now
         let u be State of SCMPDS;
         assume A9: u.b <= k+1 & u.a()=s().a() & P[Dstate u];
         per cases;
         suppose u.b <= 0;
         hence IExec(FR,u).b <= 0 & P[Dstate IExec(FR,u)] by A4,A9;
         end;
         suppose A10: u.b > 0;
        then A11: u.DataLoc(u.a(),i()) > 0 by A9;
      defpred X[set] means P[$1];
        A12: X[Dstate u] by A9;
            set Ad=AddTo(a(),i(),-n());
        A13: for t being State of SCMPDS st
            X[Dstate t] & t.a()=u.a() & t.DataLoc(u.a(),i()) > 0 holds
            IExec(I() ';' Ad,t).a()=t.a() &
            IExec(I() ';' Ad,t).DataLoc(u.a(),i())
              =t.DataLoc(u.a(),i())-n() &
            I() is_closed_on t & I() is_halting_on t &
             X[Dstate(IExec(I() ';' Ad,t))] by A3,A9;
           set Iu=IExec(I() ';' Ad,u);
       A14:  (X[u] or not X[u]) &
            IExec(FR,u) = IExec(FR,Iu) from ForDownExec(A1,A11,A12,A13);
       A15:  Iu.b=u.b-n() by A3,A9,A10;
              u.b-n() < u.b by A1,SQUARE_1:29;
            then Iu.b+1 <= u.b by A15,INT_1:20;
            then Iu.b+1 <= k+1 by A9,AXIOMS:22;
       then A16:  Iu.b <= k by REAL_1:53;
       A17:  Iu.a()=s().a() by A3,A9,A10;
              P[Dstate Iu] by A3,A9,A10;
         hence IExec(FR,u).b <= 0 & P[Dstate IExec(FR,u)] by A8,A14,A16,A17;
      end;
      end;
      hence Q[k+1];
   end;
A18:  for k being Nat holds Q[k] from NAT_1:sch 1(A4,A7);
     thus (P[s()] or not P[s()]);
     per cases;
     suppose s().b > 0;
       then reconsider m=s().b as Nat by INT_1:16;
         Q[m] by A18;
       hence thesis by A2;
     end;
     suppose s().b <= 0;
       hence thesis by A2,A4;
end;
end;

theorem :: SCPISORT:12
 for s being State of SCMPDS,I being No-StopCode shiftable Program-block,
 a,x,y be Int_position, i,c be Integer,n be Nat st
  n > 0 & s.x >= s.y +c &
 for t be State of SCMPDS st
   t.x >= t.y +c & t.a=s.a & t.DataLoc(s.a,i) > 0
 holds IExec(I ';' AddTo(a,i,-n),t).a=t.a &
    IExec(I ';' AddTo(a,i,-n),t).DataLoc(s.a,i)=t.DataLoc(s.a,i)-n &
    I is_closed_on t & I is_halting_on t &
    IExec(I ';' AddTo(a,i,-n),t).x>=IExec(I ';' AddTo(a,i,-n),t).y+c
holds
   for-down(a,i,n,I) is_closed_on s & for-down(a,i,n,I) is_halting_on s;

theorem :: SCPISORT:13
 for s being State of SCMPDS,I being No-StopCode shiftable Program-block,
 a,x,y be Int_position, i,c be Integer,n be Nat st
  n > 0 & s.x >= s.y +c & s.DataLoc(s.a,i) > 0 &
 for t be State of SCMPDS st
   t.x >= t.y +c & t.a=s.a & t.DataLoc(s.a,i) > 0
 holds IExec(I ';' AddTo(a,i,-n),t).a=t.a &
    IExec(I ';' AddTo(a,i,-n),t).DataLoc(s.a,i)=t.DataLoc(s.a,i)-n &
    I is_closed_on t & I is_halting_on t &
    IExec(I ';' AddTo(a,i,-n),t).x>=IExec(I ';' AddTo(a,i,-n),t).y+c
holds
    IExec(for-down(a,i,n,I),s) =
    IExec(for-down(a,i,n,I),IExec(I ';' AddTo(a,i,-n),s));

theorem :: SCPISORT:14
   for s being State of SCMPDS,I being No-StopCode shiftable Program-block,
 a be Int_position, i be Integer,n be Nat
 st s.DataLoc(s.a,i) > 0 & n > 0 & card I > 0 &
    a <> DataLoc(s.a,i) & (for t be State of SCMPDS st t.a=s.a
 holds IExec(I,t).a=t.a & IExec(I,t).DataLoc(s.a,i)=t.DataLoc(s.a,i) &
   I is_closed_on t & I is_halting_on t)
 holds
     for-down(a,i,n,I) is_closed_on s & for-down(a,i,n,I) is_halting_on s;

begin :: A Program for Insert Sort
:: n -> intpos 2,  x1 -> intpos 3
definition
 let n,p0 be Nat;
 func insert-sort(n,p0) -> Program-block equals
:: SCPISORT:def 2
       ((GBP:=0) ';'
       ((GBP,1):=0) ';'
       ((GBP,2):=(n-1)) ';'
       ((GBP,3):=p0)) ';'
       for-down(GBP,2,1,
          AddTo(GBP,3,1) ';'
          ((GBP,4):=(GBP,3)) ';'
          AddTo(GBP,1,1) ';'
          ((GBP,6):=(GBP,1)) ';'
          while>0(GBP,6,
            ((GBP,5):=(intpos 4,-1)) ';'
            SubFrom(GBP,5,intpos 4,0) ';'
            if>0(GBP,5,
              ((GBP,5):=(intpos 4,-1)) ';'
                ((intpos 4,-1):=(intpos 4,0)) ';'
                ((intpos 4,0 ):=(GBP,5)) ';'
                AddTo(GBP,4,-1) ';' AddTo(GBP,6,-1),
              Load ((GBP,6):=0)
            )
         )
      );
end;

begin :: The Property of Insert Sort and Its Correctness

theorem :: SCPISORT:15
     card insert-sort (n,p0) = 23;

theorem :: SCPISORT:16
    p0 >= 7 implies insert-sort (n,p0) is parahalting;

theorem :: SCPISORT:17
 for s being State of SCMPDS,f,g be FinSequence of INT,k0,k being Nat
 st s.a4 >= 7+s.a6 & s.GBP=0 & k=s.a6 & k0=s.a4-s.a6-1 &
  f is_FinSequence_on s,k0 &
  g is_FinSequence_on IExec(Insert_the_k1_item,s),k0 &
  len f=len g & len f > k & f is_non_decreasing_on 1,k
 holds
  f,g are_fiberwise_equipotent & g is_non_decreasing_on 1,k+1 &
  (for i be Nat st i>k+1 & i <= len f holds f.i=g.i) &
  (for i be Nat st 1 <= i & i <= k+1 holds
    ex j be Nat st 1 <= j & j <= k+1 & g.i=f.j);

theorem :: SCPISORT:18
   for s being State of SCMPDS,f,g be FinSequence of INT,p0,n being Nat
 st p0 >= 6 & len f=n & len g = n & f is_FinSequence_on s,p0 &
    g is_FinSequence_on IExec(insert-sort(n,p0+1),s),p0 holds
    f,g are_fiberwise_equipotent & g is_non_decreasing_on 1,n;
