:: Conditional branch macro instructions of SCM+FSA, Part II
::  by Noriko Asamoto
::
:: Received August 27, 1996
:: Copyright (c) 1996 Association of Mizar Users

environ

 vocabularies NUMBERS, SCMFSA_2, XBOOLE_0, AMI_1, AMISTD_2, CARD_1, TARSKI,
      TURING_1, SCMFSA6A, FUNCT_4, FSM_1, RELAT_1, UNIALG_2, CIRCUIT2, FUNCT_1,
      SF_MASTR, SUBSET_1, ARYTM_3, FUNCT_7, SCMFSA7B, SCMFSA6B, AMI_3,
      SCMFSA8A, NAT_1, GRAPHSP, XXREAL_0, MSUALG_1, STRUCT_0, GLIB_000,
      ARYTM_1, INT_1, COMPLEX1, PARTFUN1, FINSEQ_1, FINSEQ_2, SCMFSA8B,
      ORDINAL1, SCMNORM;
 notations TARSKI, XBOOLE_0, SUBSET_1, CARD_1, NUMBERS, XCMPLX_0, NAT_1, INT_1,
      RELAT_1, FUNCT_1, PARTFUN1, FUNCT_4, FUNCT_7, FINSEQ_1, FINSEQ_2,
      STRUCT_0, COMPOS_1, EXTPRO_1, AMI_1, AMISTD_2, SCMFSA_2, SCMFSA6A,
      SF_MASTR, SCMFSA6B, SCMFSA6C, SCMFSA7B, SCMFSA8A, INT_2, XXREAL_0;
 constructors DOMAIN_1, XXREAL_0, NAT_1, INT_2, SCMFSA6A, SF_MASTR, SCMFSA6B,
      SCMFSA6C, SCMFSA8A, AMISTD_2, RELSET_1, SCMFSA7B, AMI_1, PRE_POLY;
 registrations SETFAM_1, FUNCT_1, NUMBERS, XXREAL_0, XREAL_0, NAT_1, INT_1,
      AMI_1, SCMFSA_2, SF_MASTR, SCMFSA6A, SCMFSA6B, SCMFSA6C, ORDINAL1,
      XBOOLE_0, FINSET_1, RELSET_1, SCMFSA10, AMISTD_2, COMPOS_1, EXTPRO_1;
 requirements NUMERALS, REAL, SUBSET, BOOLE, ARITHM;


begin

canceled 2;

theorem :: SCMFSA8B:3
  for I being Program of SCM+FSA, s being State of SCM+FSA st I
  is_closed_on s holds  0 in dom I;

canceled;

theorem :: SCMFSA8B:5
  for s being State of SCM+FSA, I being Program of SCM+FSA holds
  DataPart Initialized s = DataPart(s +* Initialized I);

theorem :: SCMFSA8B:6
  for s1,s2 being State of SCM+FSA, I being Program of SCM+FSA st
  DataPart s1 = DataPart s2 holds I is_closed_on s1 implies I is_closed_on s2;

theorem :: SCMFSA8B:7
  for s1,s2 being State of SCM+FSA, I,J being Program of SCM+FSA
holds DataPart s1 = DataPart s2
 implies s1 +* (I +* Start-At( 0,SCM+FSA)),
   s2 +* (J +* Start-At( 0,SCM+FSA)) equal_outside NAT;

theorem :: SCMFSA8B:8
  for s1,s2 being State of SCM+FSA, I being Program of SCM+FSA st
DataPart s1 = DataPart s2 holds I is_closed_on s1 & I is_halting_on s1
 implies
  I is_closed_on s2 & I is_halting_on s2;

theorem :: SCMFSA8B:9
  for s being State of SCM+FSA, I,J being Program of SCM+FSA holds
  I is_closed_on Initialized s iff I is_closed_on s +* Initialized J;

theorem :: SCMFSA8B:10
  for s being State of SCM+FSA, I,J being Program of SCM+FSA, l
being Element of NAT holds I is_closed_on s iff I is_closed_on
  s +* (I +* Start-At(l,SCM+FSA));

theorem :: SCMFSA8B:11
  for s1,s2 being State of SCM+FSA, I being Program of SCM+FSA st
I +* Start-At( 0,SCM+FSA) c= s1 & I is_closed_on s1
 for n being Element of NAT st
ProgramPart Relocated(I,n) c= s2 & IC s2 =  n & DataPart s1 = DataPart s2
for i being Element of NAT holds IC Comput(ProgramPart( s1), s1,i) + n = IC
Comput(ProgramPart( s2
), s2
,i) & IncAddr(CurInstr(ProgramPart s1,Comput( ProgramPart(s1),s1,i)),n)
 = CurInstr(ProgramPart s2,Comput(ProgramPart(s2),s2,i)) &
  DataPart Comput(ProgramPart( s1), s1,i) = DataPart Comput(ProgramPart( s2),
s2,i);

theorem :: SCMFSA8B:12
  for s being State of SCM+FSA, i being keeping_0 parahalting
  Instruction of SCM+FSA, J being parahalting Program of SCM+FSA, a being
  Int-Location holds IExec(i ';' J,s).a = IExec(J,Exec(i,Initialized s)).a;

theorem :: SCMFSA8B:13
  for s being State of SCM+FSA, i being keeping_0 parahalting
  Instruction of SCM+FSA, J being parahalting Program of SCM+FSA, f being
  FinSeq-Location holds IExec(i ';' J,s).f = IExec(J,Exec(i,Initialized s)).f;

definition
  let a be Int-Location;
  let I,J be Program of SCM+FSA;
  func if=0(a,I,J) -> Program of SCM+FSA equals
:: SCMFSA8B:def 1
  a =0_goto  (card J + 3)
  ';' J ';' Goto  (card I + 1) ';' I ';' Stop SCM+FSA;
  func if>0(a,I,J) -> Program of SCM+FSA equals
:: SCMFSA8B:def 2
  a >0_goto  (card J + 3)
  ';' J ';' Goto  (card I + 1) ';' I ';' Stop SCM+FSA;
end;

definition
  let a be Int-Location;
  let I,J be Program of SCM+FSA;
  func if<0(a,I,J) -> Program of SCM+FSA equals
:: SCMFSA8B:def 3
  if=0(a,J,if>0(a,J,I));
end;

theorem :: SCMFSA8B:14
  for I,J being Program of SCM+FSA, a being Int-Location holds
  card if=0(a,I,J) = card I + card J + 4;

theorem :: SCMFSA8B:15
  for I,J being Program of SCM+FSA, a being Int-Location holds
  card if>0(a,I,J) = card I + card J + 4;

theorem :: SCMFSA8B:16
  for s being State of SCM+FSA, I,J being Program of SCM+FSA, a
being read-write Int-Location st s.a = 0 & I is_closed_on s & I is_halting_on s
  holds if=0(a,I,J) is_closed_on s & if=0(a,I,J) is_halting_on s;

theorem :: SCMFSA8B:17
  for s being State of SCM+FSA, I,J being Program of SCM+FSA, a
  being read-write Int-Location st s.a = 0 & I is_closed_on Initialized s & I
is_halting_on Initialized s holds IExec(if=0(a,I,J),s)
= IExec(I,s) +* Start-At((card I + card J + 3),SCM+FSA);

theorem :: SCMFSA8B:18
  for s being State of SCM+FSA, I,J being Program of SCM+FSA, a
being read-write Int-Location st s.a <> 0 & J is_closed_on s & J is_halting_on
  s holds if=0(a,I,J) is_closed_on s & if=0(a,I,J) is_halting_on s;

theorem :: SCMFSA8B:19
  for I,J being Program of SCM+FSA, a being read-write
  Int-Location holds for s being State of SCM+FSA st s.a <> 0 & J is_closed_on
Initialized s & J is_halting_on Initialized s
holds IExec(if=0(a,I,J),s) = IExec(
  J,s) +* Start-At((card I+card J+3),SCM+FSA);

theorem :: SCMFSA8B:20
  for s being State of SCM+FSA, I,J being parahalting Program of
SCM+FSA, a being read-write Int-Location holds if=0(a,I,J) is parahalting & (s.
  a = 0 implies IExec(if=0(a,I,J),s) = IExec(I,s) +* Start-At( (card I +
card J + 3),SCM+FSA)) & (s.a <> 0 implies IExec(if=0(a,I,J),s) =
 IExec(J,s) +* Start-At(
   (card I + card J + 3),SCM+FSA));

theorem :: SCMFSA8B:21
  for s being State of SCM+FSA, I,J being parahalting Program of
SCM+FSA, a being read-write Int-Location holds IC IExec(if=0(a,I,J),s) =
(card I + card J + 3) & (s.a = 0 implies ((for d being Int-Location holds IExec
  (if=0(a,I,J),s).d = IExec(I,s).d) & for f being FinSeq-Location holds IExec(
  if=0(a,I,J),s).f = IExec(I,s).f)) & (s.a <> 0 implies ((for d being
  Int-Location holds IExec(if=0(a,I,J),s).d = IExec(J,s).d) & for f being
  FinSeq-Location holds IExec(if=0(a,I,J),s).f = IExec(J,s).f));

theorem :: SCMFSA8B:22
  for s being State of SCM+FSA, I,J being Program of SCM+FSA, a
being read-write Int-Location st s.a > 0 & I is_closed_on s & I is_halting_on s
  holds if>0(a,I,J) is_closed_on s & if>0(a,I,J) is_halting_on s;

theorem :: SCMFSA8B:23
  for I,J being Program of SCM+FSA, a being read-write
  Int-Location holds for s being State of SCM+FSA st s.a > 0 & I is_closed_on
Initialized s & I is_halting_on Initialized s
holds IExec(if>0(a,I,J),s) = IExec(
  I,s) +* Start-At((card I+card J+3),SCM+FSA);

theorem :: SCMFSA8B:24
  for s being State of SCM+FSA, I,J being Program of SCM+FSA, a
being read-write Int-Location st s.a <= 0 & J is_closed_on s & J is_halting_on
  s holds if>0(a,I,J) is_closed_on s & if>0(a,I,J) is_halting_on s;

theorem :: SCMFSA8B:25
  for I,J being Program of SCM+FSA, a being read-write
  Int-Location holds for s being State of SCM+FSA st s.a <= 0 & J is_closed_on
Initialized s & J is_halting_on Initialized s
holds IExec(if>0(a,I,J),s) = IExec(
  J,s) +* Start-At((card I+card J+3),SCM+FSA);

theorem :: SCMFSA8B:26
  for s being State of SCM+FSA, I,J being parahalting Program of
SCM+FSA, a being read-write Int-Location holds if>0(a,I,J) is parahalting & (s.
  a > 0 implies IExec(if>0(a,I,J),s) = IExec(I,s) +* Start-At( (card I +
card J + 3),SCM+FSA)) & (s.a <= 0 implies IExec(if>0(a,I,J),s) =
 IExec(J,s) +* Start-At(
   (card I + card J + 3),SCM+FSA));

theorem :: SCMFSA8B:27
  for s being State of SCM+FSA, I,J being parahalting Program of
SCM+FSA, a being read-write Int-Location holds IC IExec(if>0(a,I,J),s) =
(card I + card J + 3) & (s.a > 0 implies ((for d being Int-Location holds IExec
  (if>0(a,I,J),s).d = IExec(I,s).d) & for f being FinSeq-Location holds IExec(
  if>0(a,I,J),s).f = IExec(I,s).f)) & (s.a <= 0 implies ((for d being
  Int-Location holds IExec(if>0(a,I,J),s).d = IExec(J,s).d) & for f being
  FinSeq-Location holds IExec(if>0(a,I,J),s).f = IExec(J,s).f));

theorem :: SCMFSA8B:28
  for s being State of SCM+FSA, I,J being Program of SCM+FSA, a being
read-write Int-Location st s.a < 0 & I is_closed_on s & I is_halting_on s holds
  if<0(a,I,J) is_closed_on s & if<0(a,I,J) is_halting_on s;

theorem :: SCMFSA8B:29
  for s being State of SCM+FSA, I,J being Program of SCM+FSA, a
  being read-write Int-Location st s.a < 0 & I is_closed_on Initialized s & I
is_halting_on Initialized s
holds IExec(if<0(a,I,J),s) = IExec(I,s) +* Start-At(
   (card I + card J + card J + 7),SCM+FSA);

theorem :: SCMFSA8B:30
  for s being State of SCM+FSA, I,J being Program of SCM+FSA, a being
read-write Int-Location st s.a = 0 & J is_closed_on s & J is_halting_on s holds
  if<0(a,I,J) is_closed_on s & if<0(a,I,J) is_halting_on s;

theorem :: SCMFSA8B:31
  for s being State of SCM+FSA, I,J being Program of SCM+FSA, a
  being read-write Int-Location st s.a = 0 & J is_closed_on Initialized s & J
is_halting_on Initialized s
holds IExec(if<0(a,I,J),s) = IExec(J,s) +* Start-At(
   (card I + card J + card J + 7),SCM+FSA);

theorem :: SCMFSA8B:32
  for s being State of SCM+FSA, I,J being Program of SCM+FSA, a being
read-write Int-Location st s.a > 0 & J is_closed_on s & J is_halting_on s holds
  if<0(a,I,J) is_closed_on s & if<0(a,I,J) is_halting_on s;

theorem :: SCMFSA8B:33
  for s being State of SCM+FSA, I,J being Program of SCM+FSA, a
  being read-write Int-Location st s.a > 0 & J is_closed_on Initialized s & J
is_halting_on Initialized s
holds IExec(if<0(a,I,J),s) = IExec(J,s) +* Start-At(
   (card I + card J + card J + 7),SCM+FSA);

theorem :: SCMFSA8B:34
  for s being State of SCM+FSA, I,J being parahalting Program of SCM+FSA
  , a being read-write Int-Location holds if<0(a,I,J) is parahalting & (s.a < 0
implies IExec(if<0(a,I,J),s) = IExec(I,s) +* Start-At( (card I + card J +
card J + 7),SCM+FSA)) & (s.a >= 0 implies IExec(if<0(a,I,J),s) =
 IExec(J,s) +* Start-At((card I + card J + card J + 7),SCM+FSA));

registration
  let I,J be parahalting Program of SCM+FSA;
  let a be read-write Int-Location;
  cluster if=0(a,I,J) -> parahalting;
  cluster if>0(a,I,J) -> parahalting;
end;

definition
  let a,b be Int-Location;
  let I,J be Program of SCM+FSA;
  func if=0(a,b,I,J) -> Program of SCM+FSA equals
:: SCMFSA8B:def 4
  SubFrom(a,b) ';' if=0(a,I,J);
  func if>0(a,b,I,J) -> Program of SCM+FSA equals
:: SCMFSA8B:def 5
  SubFrom(a,b) ';' if>0(a,I,J);
end;

registration
  let a be Int-Location;
  let I,J be Program of SCM+FSA;
 cluster if=0(a,I,J) -> non halt-free;
 cluster  if>0(a,I,J) -> non halt-free;
 cluster if<0(a,I,J) -> non halt-free;
end;

registration
  let a,b be Int-Location;
  let I,J be Program of SCM+FSA;
 cluster if=0(a,b,I,J) -> non halt-free;
 cluster if>0(a,b,I,J) -> non halt-free;
end;

notation
  let a,b be Int-Location;
  let I,J be Program of SCM+FSA;
  synonym if<0(b,a,I,J) for if>0(a,b,I,J);
end;

registration
  let I,J be parahalting Program of SCM+FSA;
  let a,b be read-write Int-Location;
  cluster if=0(a,b,I,J) -> parahalting;
  cluster if>0(a,b,I,J) -> parahalting;
end;

theorem :: SCMFSA8B:35
  for s being State of SCM+FSA, I being Program of SCM+FSA holds
  DataPart Result(ProgramPart(s +* Initialized I),s +* Initialized I) =
DataPart IExec(I,s);

theorem :: SCMFSA8B:36
  for s being State of SCM+FSA, I being Program of SCM+FSA, a
  being Int-Location holds Result(ProgramPart(s +* Initialized I),s +*
Initialized I),IExec(I,s) equal_outside
  NAT;

theorem :: SCMFSA8B:37
  for s1,s2 being State of SCM+FSA, i being Instruction of SCM+FSA
  , a being Int-Location holds (for b being Int-Location st a <> b holds s1.b =
s2.b) & (for f being FinSeq-Location holds s1.f = s2.f) & i does not refer a &
IC s1 = IC s2 implies (for b being Int-Location st a <> b holds Exec(i,s1).b =
Exec(i,s2).b) & (for f being FinSeq-Location holds Exec(i,s1).f = Exec(i,s2).f)
  & IC Exec(i,s1) = IC Exec(i,s2);

theorem :: SCMFSA8B:38
  for s1,s2 being State of SCM+FSA, I being Program of SCM+FSA, a
being Int-Location st I does not refer a & (for b being Int-Location st a <> b
  holds s1.b = s2.b) & (for f being FinSeq-Location holds s1.f = s2.f) & I
  is_closed_on s1 holds for k being Element of NAT holds (for b being
Int-Location st a <> b holds Comput(ProgramPart( (s1 +* (I +*
 Start-At( 0,SCM+FSA)))), (s1 +* (I +*
 Start-At( 0,SCM+FSA))),k).b
  = Comput(ProgramPart( (s2 +* (I +* Start-At( 0,SCM+FSA)))), (s2 +* (I +*
Start-At( 0,SCM+FSA))),k).b) & (for f being
  FinSeq-Location holds Comput(ProgramPart( (s1 +* (I +*
   Start-At( 0,SCM+FSA)))), (s1 +* (I +*
   Start-At( 0,SCM+FSA))),k).f =
Comput(ProgramPart( (s2 +* (I +* Start-At( 0,SCM+FSA)))), (s2 +* (I +* Start-At
( 0,SCM+FSA))),k).f) &
 IC Comput(ProgramPart( (s1 +* (I
+* Start-At( 0,SCM+FSA)))), (s1 +* (I
+* Start-At( 0,SCM+FSA))),k) = IC Comput(ProgramPart( (s2 +* (I +*
 Start-At( 0,SCM+FSA)))), (s2 +* (I +*
 Start-At( 0,SCM+FSA))),k)
  & CurInstr(ProgramPart Comput(ProgramPart( (s1 +* (I +* Start-At( 0,SCM+FSA))
)), (s1 +* (I +* Start-At( 0,SCM+FSA))),k),
     Comput(ProgramPart( (s1 +* (I +* Start-At( 0,SCM+FSA)))), (s1 +* (I +*
Start-At( 0,SCM+FSA))),k))
   = CurInstr(
  ProgramPart Comput(ProgramPart( (s2 +* (I +* Start-At( 0,SCM+FSA)))), (s2 +*
(I +* Start-At( 0,SCM+FSA))),k),
   Comput(ProgramPart( (s2 +* (I +* Start-At( 0,SCM+FSA)))), (s2 +* (I +*
Start-At( 0,SCM+FSA))),k));

theorem :: SCMFSA8B:39
  for s being State of SCM+FSA, I,J being Program of SCM+FSA, l
being Element of NAT holds I is_closed_on s & I is_halting_on
  s iff I is_closed_on s +* (I +* Start-At(l,SCM+FSA)) & I is_halting_on s
   +* (I +*
  Start-At(l,SCM+FSA));

theorem :: SCMFSA8B:40
  for s1,s2 being State of SCM+FSA, I being Program of SCM+FSA, a
being Int-Location st I does not refer a & (for b being Int-Location st a <> b
  holds s1.b = s2.b) & (for f being FinSeq-Location holds s1.f = s2.f) & I
is_closed_on s1 & I is_halting_on s1 holds I is_closed_on s2 & I is_halting_on
  s2;

theorem :: SCMFSA8B:41
  for s1,s2 being State of SCM+FSA, I being Program of SCM+FSA, a
  being Int-Location holds (for d being read-write Int-Location st a <> d holds
  s1.d = s2.d) & (for f being FinSeq-Location holds s1.f = s2.f) & I
does not refer a & I is_closed_on Initialized s1 &
I is_halting_on Initialized s1
implies (for d being Int-Location st a <> d holds IExec(I,s1).d = IExec(I,s2).d
  ) & (for f being FinSeq-Location holds IExec(I,s1).f = IExec(I,s2).f) & IC
  IExec(I,s1) = IC IExec(I,s2);

theorem :: SCMFSA8B:42
  for s being State of SCM+FSA, I,J being parahalting Program of SCM+FSA
, a,b being read-write Int-Location st I does not refer a & J does not refer a
  holds IC IExec(if=0(a,b,I,J),s) =  (card I + card J + 5) & (s.a = s.b
  implies ((for d being Int-Location st a <> d holds IExec(if=0(a,b,I,J),s).d =
  IExec(I,s).d) & for f being FinSeq-Location holds IExec(if=0(a,b,I,J),s).f =
IExec(I,s).f)) & (s.a <> s.b implies ((for d being Int-Location st a <> d holds
  IExec(if=0(a,b,I,J),s).d = IExec(J,s).d) & for f being FinSeq-Location holds
  IExec(if=0(a,b,I,J),s).f = IExec(J,s).f));

theorem :: SCMFSA8B:43
  for s being State of SCM+FSA, I,J being parahalting Program of SCM+FSA
, a,b being read-write Int-Location st I does not refer a & J does not refer a
  holds IC IExec(if>0(a,b,I,J),s) =  (card I + card J + 5) & (s.a > s.b
  implies (for d being Int-Location st a <> d holds IExec(if>0(a,b,I,J),s).d =
  IExec(I,s).d) & for f being FinSeq-Location holds IExec(if>0(a,b,I,J),s).f =
  IExec(I,s).f) & (s.a <= s.b implies (for d being Int-Location st a <> d holds
  IExec(if>0(a,b,I,J),s).d = IExec(J,s).d) & for f being FinSeq-Location holds
  IExec(if>0(a,b,I,J),s).f = IExec(J,s).f);

