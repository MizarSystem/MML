:: Metrics in the Cartesian Product - Part II
::  by Stanis\l awa Kanas and Adam Lecko
::
:: Received July 8, 1991
:: Copyright (c) 1991 Association of Mizar Users

environ

 vocabularies METRIC_1, FUNCT_1, SQUARE_1, ARYTM_1, ABSVALUE, METRIC_4,
      XCMPLX_0, ARYTM, MCART_1;
 notations ZFMISC_1, SUBSET_1, ORDINAL1, NUMBERS, XCMPLX_0, XREAL_0, COMPLEX1,
      REAL_1, FUNCT_2, STRUCT_0, METRIC_1, DOMAIN_1, SQUARE_1, MCART_1,
      XXREAL_0;
 constructors DOMAIN_1, REAL_1, SQUARE_1, MEMBERED, COMPLEX1, METRIC_1;
 registrations XBOOLE_0, SUBSET_1, NUMBERS, XCMPLX_0, XREAL_0, SQUARE_1,
      MEMBERED, STRUCT_0, METRIC_1, METRIC_3;
 requirements NUMERALS, REAL, SUBSET, BOOLE, ARITHM;


begin :: Metrics in the Cartesian Product of Two Sets

 reserve X,Y for non empty MetrSpace;

definition let X,Y;
  func dist_cart2S(X,Y) -> Function of [:[:the carrier of X,the carrier of Y:],
                          [:the carrier of X,the carrier of Y:]:],REAL means
:: METRIC_4:def 1
  for x1,y1 being Element of X
              for x2,y2 being Element of Y
              for x,y being Element of [:the carrier of X,the carrier of Y:]
              st x = [x1,x2] & y = [y1,y2] holds
              it.(x,y) = sqrt((dist(x1,y1))^2 + (dist(x2,y2)^2));
   end;

canceled;

theorem :: METRIC_4:2
  for a,b being real number st 0 <= a & 0 <= b holds
    sqrt(a + b) = 0 iff (a = 0 & b = 0);

theorem :: METRIC_4:3
  for x,y being Element of [:the carrier of X,the carrier of Y:] holds
    dist_cart2S(X,Y).(x,y) = 0 iff x = y;

theorem :: METRIC_4:4
  for x,y being Element of [:the carrier of X,the carrier of Y:] holds
    dist_cart2S(X,Y).(x,y) = dist_cart2S(X,Y).(y,x);

theorem :: METRIC_4:5
  for a,b,c,d being real number
     st 0 <= a & 0 <= b & 0 <= c & 0 <= d holds
    sqrt((a + c)^2 + (b + d)^2) <= sqrt(a^2 + b^2) + sqrt(c^2 + d^2);

theorem :: METRIC_4:6
  for x,y,z being Element of [:the carrier of X,the carrier of Y:] holds
    dist_cart2S(X,Y).(x,z) <= dist_cart2S(X,Y).(x,y) + dist_cart2S(X,Y).(y,z);

definition let X,Y;
  let x,y be Element of [:the carrier of X,the carrier of Y:];
  func dist2S(x,y) -> Real equals
:: METRIC_4:def 2
     dist_cart2S(X,Y).(x,y);
end;

definition let X,Y;
  func MetrSpaceCart2S(X,Y) -> strict non empty MetrSpace equals
:: METRIC_4:def 3
     MetrStruct(#[:the carrier of X,the carrier of Y:],dist_cart2S(X,Y)#);
end;

begin :: Metrics in the Cartesian Product of Three Sets

 reserve Z for non empty MetrSpace;

definition let X,Y,Z;
  func dist_cart3S(X,Y,Z) -> Function of
   [:[:the carrier of X,the carrier of Y,the carrier of Z:],
     [:the carrier of X,the carrier of Y,the carrier of Z:]:],REAL means
:: METRIC_4:def 4
  for x1,y1 being Element of X
       for x2,y2 being Element of Y
       for x3,y3 being Element of Z
       for x,y being Element of
         [:the carrier of X,the carrier of Y,the carrier of Z:]
         st x = [x1,x2,x3] & y = [y1,y2,y3] holds
         it.(x,y) =sqrt((dist(x1,y1))^2 + (dist(x2,y2))^2 + (dist(x3,y3))^2);
end;

canceled 3;

theorem :: METRIC_4:10
  for x,y being Element of
      [:the carrier of X,the carrier of Y,the carrier of Z:] holds
    dist_cart3S(X,Y,Z).(x,y) = 0 iff x = y;

theorem :: METRIC_4:11
  for x,y being Element of
      [:the carrier of X,the carrier of Y,the carrier of Z:] holds
    dist_cart3S(X,Y,Z).(x,y) = dist_cart3S(X,Y,Z).(y,x);

theorem :: METRIC_4:12
   for a,b,c being complex number holds
    (a + b + c)^2 = a^2 + b^2 + c^2 + (2*a*b + 2*a*c + 2*b*c);

theorem :: METRIC_4:13
  for a,b,c,d,e,f being real number holds
    (2*(a*d)*(c*b) + 2*(a*f)*(e*c) + 2*(b*f)*(e*d)) <=
    (((a*d)^2 + (c*b)^2 + (a*f)^2 + (e*c)^2 + (b*f)^2) + (e*d)^2);

canceled;

theorem :: METRIC_4:15
  for a,b,c,d,e,f being real number holds
    ((a*c) + (b*d) + (e*f))^2 <= (a^2 + b^2 + e^2)*(c^2 + d^2 + f^2);

theorem :: METRIC_4:16
  for x,y,z being Element of
       [:the carrier of X,the carrier of Y,the carrier of Z:] holds
    dist_cart3S(X,Y,Z).(x,z) <=
                       dist_cart3S(X,Y,Z).(x,y) + dist_cart3S(X,Y,Z).(y,z);

definition let X,Y,Z;
  let x,y be Element of [:the carrier of X,the carrier of Y,the carrier of Z:];
  func dist3S(x,y) -> Real equals
:: METRIC_4:def 5
     dist_cart3S(X,Y,Z).(x,y);
end;

definition let X,Y,Z;
  func MetrSpaceCart3S(X,Y,Z) -> strict non empty MetrSpace equals
:: METRIC_4:def 6
     MetrStruct(#[:the carrier of X,the carrier of Y,the carrier of Z:],
      dist_cart3S(X,Y,Z)#);
end;

canceled 2;

definition
  func taxi_dist2 -> Function of [:[:REAL,REAL:],[:REAL,REAL:]:],REAL means
:: METRIC_4:def 7
   for x1,y1,x2,y2 being Element of REAL
           for x,y being Element of [:REAL,REAL:]
           st x = [x1,x2] & y = [y1,y2] holds
           it.(x,y) = real_dist.(x1,y1) + real_dist.(x2,y2);
end;

theorem :: METRIC_4:19
  for x,y being Element of [:REAL,REAL:] holds
    taxi_dist2.(x,y) = 0 iff x = y;

theorem :: METRIC_4:20
  for x,y being Element of [:REAL,REAL:] holds
    taxi_dist2.(x,y) = taxi_dist2.(y,x);

theorem :: METRIC_4:21
  for x,y,z being Element of [:REAL,REAL:] holds
    taxi_dist2.(x,z) <= taxi_dist2.(x,y) + taxi_dist2.(y,z);

definition
  func RealSpaceCart2 -> strict non empty MetrSpace equals
:: METRIC_4:def 8
     MetrStruct(#[:REAL,REAL:],taxi_dist2#);
end;

definition
  func Eukl_dist2 -> Function of [:[:REAL,REAL:],[:REAL,REAL:]:],REAL means
:: METRIC_4:def 9
   for x1,y1,x2,y2 being Element of REAL
      for x,y being Element of [:REAL,REAL:]
      st x = [x1,x2] & y = [y1,y2] holds
      it.(x,y) = sqrt((real_dist.(x1,y1))^2 + (real_dist.(x2,y2)^2));
end;

theorem :: METRIC_4:22
  for x,y being Element of [:REAL,REAL:] holds
    Eukl_dist2.(x,y) = 0 iff x = y;

theorem :: METRIC_4:23
  for x,y being Element of [:REAL,REAL:] holds
    Eukl_dist2.(x,y) = Eukl_dist2.(y,x);

theorem :: METRIC_4:24
  for x,y,z being Element of [:REAL,REAL:] holds
    Eukl_dist2.(x,z) <= Eukl_dist2.(x,y) + Eukl_dist2.(y,z);

definition
  func EuklSpace2 -> strict non empty MetrSpace equals
:: METRIC_4:def 10
     MetrStruct(#[:REAL,REAL:],Eukl_dist2#);
end;

definition
  func taxi_dist3 -> Function of [:[:REAL,REAL,REAL:],
                                   [:REAL,REAL,REAL:]:],REAL means
:: METRIC_4:def 11
   for x1,y1,x2,y2,x3,y3 being Element of REAL
          for x,y being Element of [:REAL,REAL,REAL:]
          st x = [x1,x2,x3] & y = [y1,y2,y3] holds
          it.(x,y) = real_dist.(x1,y1) + real_dist.(x2,y2) + real_dist.(x3,y3);
end;

theorem :: METRIC_4:25
  for x,y being Element of [:REAL,REAL,REAL:] holds
    taxi_dist3.(x,y) = 0 iff x = y;

theorem :: METRIC_4:26
  for x,y being Element of [:REAL,REAL,REAL:] holds
    taxi_dist3.(x,y) = taxi_dist3.(y,x);

theorem :: METRIC_4:27
  for x,y,z being Element of [:REAL,REAL,REAL:] holds
    taxi_dist3.(x,z) <= taxi_dist3.(x,y) + taxi_dist3.(y,z);

definition
  func RealSpaceCart3 -> strict non empty MetrSpace equals
:: METRIC_4:def 12
     MetrStruct(#[:REAL,REAL,REAL:],taxi_dist3#);
end;

definition
  func Eukl_dist3 -> Function of [:[:REAL,REAL,REAL:],
                                   [:REAL,REAL,REAL:]:],REAL means
:: METRIC_4:def 13
   for x1,y1,x2,y2,x3,y3 being Element of REAL
           for x,y being Element of [:REAL,REAL,REAL:]
           st x = [x1,x2,x3] & y = [y1,y2,y3] holds
           it.(x,y) = sqrt((real_dist.(x1,y1))^2 + (real_dist.(x2,y2)^2)
                      + (real_dist.(x3,y3)^2));
end;

theorem :: METRIC_4:28
  for x,y being Element of [:REAL,REAL,REAL:] holds
    Eukl_dist3.(x,y) = 0 iff x = y;

theorem :: METRIC_4:29
  for x,y being Element of [:REAL,REAL,REAL:] holds
    Eukl_dist3.(x,y) = Eukl_dist3.(y,x);

theorem :: METRIC_4:30
  for x,y,z being Element of [:REAL,REAL,REAL:] holds
    Eukl_dist3.(x,z) <= Eukl_dist3.(x,y) + Eukl_dist3.(y,z);

definition
  func EuklSpace3 -> strict non empty MetrSpace equals
:: METRIC_4:def 14
     MetrStruct(#[:REAL,REAL,REAL:],Eukl_dist3#);
end;

