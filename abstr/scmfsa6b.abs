:: On the compositions of macro instructions, Part II
::  by Noriko Asamoto , Yatsuka Nakamura , Piotr Rudnicki and Andrzej Trybulec
::
:: Received July 22, 1996
:: Copyright (c) 1996-2011 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies NUMBERS, SUBSET_1, AMI_1, SCMFSA_2, FSM_1, CARD_1, TARSKI,
      SCMFSA6A, FUNCT_4, RELAT_1, XBOOLE_0, FUNCT_1, INT_1, MSUALG_1, CIRCUIT2,
      GLIB_000, AMI_3, ARYTM_3, XXREAL_0, NAT_1, SF_MASTR, GRAPHSP, AMISTD_2,
      TURING_1, STRUCT_0, VALUED_1, FUNCOP_1, SCMFSA6B, PARTFUN1, SCMNORM,
      RELOC, SCMFSA6C, PBOOLE, COMPOS_1;
 notations TARSKI, XBOOLE_0, SUBSET_1, SETFAM_1, CARD_1, NUMBERS, XCMPLX_0,
      XXREAL_0, NAT_1, FUNCT_7, INT_1, RELAT_1, FUNCT_1, PARTFUN1, PBOOLE,
      FINSEQ_1, FUNCOP_1, FUNCT_4, VALUED_1, STRUCT_0, COMPOS_1, EXTPRO_1,
      SCMFSA_2, AMISTD_2, SCMFSA6A, SF_MASTR;
 constructors XXREAL_0, SCMFSA6A, SF_MASTR, AMISTD_1, AMISTD_2, RELSET_1,
      PRE_POLY, AMISTD_5, DOMAIN_1, PBOOLE, AMI_3;
 registrations SETFAM_1, RELAT_1, FUNCT_1, ORDINAL1, FUNCOP_1, NUMBERS,
      XXREAL_0, XREAL_0, NAT_1, INT_1, SCMFSA_2, SCMFSA6A, SF_MASTR, XBOOLE_0,
      FINSET_1, AMISTD_2, SCMFSA10, COMPOS_1, EXTPRO_1, SCMFSA_4, PBOOLE,
      PRE_POLY, FUNCT_7, FUNCT_4, STRUCT_0;
 requirements NUMERALS, REAL, BOOLE, SUBSET, ARITHM;


begin

reserve m, n for Element of NAT,
  x for set,
  i for Instruction of SCM+FSA,
  I for Program of SCM+FSA,
  a for Int-Location,
  f for FinSeq-Location,
  l, l1 for Element of NAT,
  s,s1,s2 for State of SCM+FSA,
  P,P1,P2 for (the Instructions of SCM+FSA)-valued ManySortedSet of NAT;

canceled 3;

theorem :: SCMFSA6B:4
 for p being PartState of SCM+FSA
 holds Start-At(0,SCM+FSA) c= Initialized p;

theorem :: SCMFSA6B:5
  I +* Start-At(n,SCM+FSA) c= s implies I c= s;

canceled 2;

theorem :: SCMFSA6B:8
  Initialize((intloc 0).-->1) c= s implies Start-At(0,SCM+FSA) c= s;

theorem :: SCMFSA6B:9
  not a in dom Start-At(l,SCM+FSA);

theorem :: SCMFSA6B:10
  not f in dom Start-At(l,SCM+FSA);

canceled;

theorem :: SCMFSA6B:12
  not a in dom (I+*Start-At(l,SCM+FSA));

theorem :: SCMFSA6B:13
  not f in dom (I+*Start-At(l,SCM+FSA));

begin ::  General theory

definition
  let s be State of SCM+FSA, li be Int-Location, k be Integer;
  redefine func s+*(li,k) -> State of SCM+FSA;
end;

begin

definition
  let I be Program of SCM+FSA, s be State of SCM+FSA;
  let P be (the Instructions of SCM+FSA)-valued ManySortedSet of NAT;
  func IExec(I,P,s) -> State of SCM+FSA equals
:: SCMFSA6B:def 1
  Result(P+*I,s+*Initialize((intloc 0).-->1)) +* s|NAT;
end;

definition
  let I be Program of SCM+FSA;
  attr I is paraclosed means
:: SCMFSA6B:def 2

  for s being State of SCM+FSA,
      P being (the Instructions of SCM+FSA)-valued ManySortedSet of NAT
    st I c= P
  for n being Element of NAT st Start-At(0,SCM+FSA) c= s
   holds IC Comput(P,s,n) in dom I;
  attr I is parahalting means
:: SCMFSA6B:def 3

:::  Initialize I is halting;
  for s being State of SCM+FSA st Start-At(0,SCM+FSA) c= s
  for P being (the Instructions of SCM+FSA)-valued ManySortedSet of NAT
   st I c= P
  holds P halts_on s;
  attr I is keeping_0 means
:: SCMFSA6B:def 4

  for s being State of SCM+FSA st Start-At(0,SCM+FSA) c= s
  for P being (the Instructions of SCM+FSA)-valued ManySortedSet of NAT
   st I c= P
  for k being Element of NAT holds Comput(P,s,k).intloc 0 = s.intloc 0;
end;

registration
  cluster parahalting Program of SCM+FSA;
end;

canceled 4;

theorem :: SCMFSA6B:18
  for I being parahalting Program of SCM+FSA
  for P being (the Instructions of SCM+FSA)-valued ManySortedSet of NAT
   st I c= P & Start-At(0,SCM+FSA) c= s
  holds P halts_on s;

theorem :: SCMFSA6B:19
  for s being State of SCM+FSA
  for I being parahalting Program of SCM+FSA
   st Initialize((intloc 0).-->1) c= s
  for P being (the Instructions of SCM+FSA)-valued ManySortedSet of NAT
   st I c= P
  holds P halts_on s;

registration
  let I be parahalting Program of SCM+FSA;
  cluster Initialized I -> halting;
end;

theorem :: SCMFSA6B:20
  not P2 +*(IC s2, goto IC s2) halts_on s2 +*(IC s2, goto IC s2);

registration
  cluster parahalting -> paraclosed Program of SCM+FSA;
  cluster keeping_0 -> paraclosed Program of SCM+FSA;
end;

canceled;

theorem :: SCMFSA6B:22
  for I being parahalting Program of SCM+FSA, a being read-write
  Int-Location holds not a in UsedIntLoc I implies IExec(I,P,s).a = s.a;

theorem :: SCMFSA6B:23
  for I being parahalting Program of SCM+FSA holds not f in UsedInt*Loc
  I implies (IExec(I,P,s)).f = s.f;

theorem :: SCMFSA6B:24
  IC s = l & P.l = goto l implies not P halts_on s;

registration
  cluster parahalting -> non empty Program of SCM+FSA;
end;

canceled 2;

theorem :: SCMFSA6B:27
 for P,Q being (the Instructions of SCM+FSA)-valued ManySortedSet of NAT
for J being parahalting Program of SCM+FSA
   st Start-At(0,SCM+FSA) c= s1 & J c= P
 for n being Element of NAT
  st Reloc(J,n) c= Q
  & IC s2 = n & DataPart s1 = DataPart s2
 for i being Element of NAT holds
  IC Comput(P,s1,i) + n = IC Comput(Q,s2,i) &
  IncAddr(CurInstr(P,Comput(P,s1,i)),n) = CurInstr(Q,Comput(Q,s2,i)) &
  DataPart Comput(P,s1,i) = DataPart Comput(Q,s2,i);

theorem :: SCMFSA6B:28
  for I being parahalting Program of SCM+FSA st
    I c= P1 & I c= P2 & Start-At(0,SCM+FSA) c= s1 & Start-At(0,SCM+FSA) c= s2 &
   NPP s1 = NPP s2 holds
  for k being Element of NAT holds
   NPP Comput(P1,s1,k) = NPP Comput(P2,s2,k) &
   CurInstr(P1,Comput(P1,s1,k)) = CurInstr(P2,Comput(P2,s2,k));

theorem :: SCMFSA6B:29
  for I being parahalting Program of SCM+FSA st
   I c= P1 & I c= P2 & Start-At(0,SCM+FSA) c= s1 & Start-At(0,SCM+FSA) c= s2 &
   NPP s1 = NPP s2 holds
  LifeSpan(P1,s1) = LifeSpan(P2,s2) &
  NPP Result(P1,s1) = NPP Result(P2,s2);

theorem :: SCMFSA6B:30
  for I being parahalting Program of SCM+FSA holds IC IExec(I,P,s) =
  IC Result(P+*I,s +* Initialize((intloc 0).-->1));

theorem :: SCMFSA6B:31
  for I being non empty Program of SCM+FSA holds
    0 in dom Initialized I;

canceled;

theorem :: SCMFSA6B:33
  (Initialized Macro i). 0 = i & (Initialized Macro i). 1 = halt SCM+FSA;

theorem :: SCMFSA6B:34
  Initialize((intloc 0).-->1) c= s implies IC s =  0;

registration
  cluster keeping_0 parahalting Program of SCM+FSA;
end;

theorem :: SCMFSA6B:35
  for I being keeping_0 parahalting Program of SCM+FSA holds IExec(I,P,s)
  .intloc 0 = 1;

begin :: The composition of macroinstructions

registration
 cluster paraclosed Program of SCM+FSA;
end;

theorem :: SCMFSA6B:36
  for I being paraclosed Program of SCM+FSA, J being Program of SCM+FSA
  for P being (the Instructions of SCM+FSA)-valued ManySortedSet of NAT
   st I c= P & Start-At(0,SCM+FSA) c= s & P halts_on s
 for m st m <= LifeSpan(P,s)
  holds NPP Comput(P,s,m) = NPP Comput(P+*(I ';' J),s,m);

theorem :: SCMFSA6B:37
 for P being (the Instructions of SCM+FSA)-valued ManySortedSet of NAT
  for I being paraclosed Program of SCM+FSA
   st P+*I halts_on s &
     Directed I c= P & Start-At(0,SCM+FSA) c= s
 holds IC Comput(P,s,LifeSpan(P+*I,s) + 1) =  card I;

theorem :: SCMFSA6B:38
  for P being (the Instructions of SCM+FSA)-valued ManySortedSet of NAT
  for I being paraclosed Program of SCM+FSA
   st P+*I halts_on s &
       Directed I c= P &
       Start-At(0,SCM+FSA) c= s
 holds DataPart Comput(P,s,LifeSpan(P+*I,s))
   = DataPart Comput(P,s,LifeSpan(P+*I,s)+ 1);

theorem :: SCMFSA6B:39
  for I being parahalting Program of SCM+FSA st
   I c= P & Initialize((intloc 0).-->1) c= s
holds for k being Element of NAT st k <= LifeSpan(P,s)
 holds CurInstr(P+*Directed I,
 Comput(P+*Directed I,s,k)) <> halt SCM+FSA;

theorem :: SCMFSA6B:40
  for P being (the Instructions of SCM+FSA)-valued ManySortedSet of NAT
  for I being paraclosed Program of SCM+FSA
   st P+*I halts_on s +* Start-At(0,SCM+FSA)
 for J being Program of SCM+FSA, k being Element of NAT st
  k <= LifeSpan(P+*I,s +* Start-At(0,SCM+FSA))
   holds NPP Comput(P+*I,s +* Start-At(0,SCM+FSA),k)
    = NPP Comput(P+*(I ';' J), s +* Start-At(0,SCM+FSA),k);

registration
  let I, J be parahalting Program of SCM+FSA;
  cluster I ';' J -> parahalting;
end;

theorem :: SCMFSA6B:41
  for I being keeping_0 Program of SCM+FSA
   st not P+* I halts_on s +* Start-At(0,SCM+FSA)
   for J being Program of SCM+FSA, k being Element of NAT holds
   NPP Comput(P+*I,s +* Start-At(0,SCM+FSA),k)
    = NPP Comput(P+*(I ';' J),s +* Start-At(0,SCM+FSA),k);

theorem :: SCMFSA6B:42
  for I being keeping_0 Program of SCM+FSA st P+*I halts_on s
for J being paraclosed Program of SCM+FSA st
  I ';' J c= P & Start-At(0,SCM+FSA) c= s
 for k being Element of NAT holds
  NPP IncIC(Comput(P+*I+*J,
    Result(P+*I,s) +* Start-At(0,SCM+FSA),k),card I)
  = NPP Comput(P+*(I ';' J),s +* Start-At(0,SCM+FSA),
   (LifeSpan(P+*I,s +* Start-At(0,SCM+FSA))+1+k));

registration
  let I, J be keeping_0 Program of SCM+FSA;
  cluster I ';' J -> keeping_0;
end;

theorem :: SCMFSA6B:43
  for I being keeping_0 parahalting Program of SCM+FSA, J being
  parahalting Program of SCM+FSA holds
   LifeSpan(P+*(I ';' J),
     s +* Initialize((intloc 0).-->1)) =
  LifeSpan(P+*I,s +* Initialize((intloc 0).-->1)) + 1 + LifeSpan(P+*I+*J,
   Result(P+*I,s +* Initialize((intloc 0).-->1)) +*
    Initialize((intloc 0).-->1));

theorem :: SCMFSA6B:44
  for I being keeping_0 parahalting Program of SCM+FSA,
      J being parahalting Program of SCM+FSA
 holds IExec(I ';' J,P,s) = IExec(J,P,IExec(I,P,s)) +*
  Start-At (IC IExec(J,P,IExec(I,P,s)) + card I,SCM+FSA);

theorem :: SCMFSA6B:45
 for P being (the Instructions of SCM+FSA)-valued ManySortedSet of NAT
   holds not P +*(IC s, goto IC s) halts_on s;

theorem :: SCMFSA6B:46
  Initialize((intloc 0).-->1) c= s implies Start-At(0,SCM+FSA) c= s;

