:: On the compositions of macro instructions, Part II
::  by Noriko Asamoto , Yatsuka Nakamura , Piotr Rudnicki and Andrzej Trybulec
::
:: Received July 22, 1996
:: Copyright (c) 1996 Association of Mizar Users

environ

 vocabulary FUNCT_1, RELAT_1, FUNCT_4, BOOLE, AMI_1, SCMFSA_2, SCMFSA6A, AMI_3,
      CAT_1, SCM_1, INT_1, FUNCOP_1, FUNCT_7, SF_MASTR, AMI_5, FINSEQ_1, RELOC,
      CARD_1, SCMFSA6B, CARD_3;
 notation TARSKI, XBOOLE_0, NUMBERS, XCMPLX_0, XREAL_0, NAT_1, INT_1, RELAT_1,
      FUNCT_1, FUNCT_2, FINSEQ_1, CARD_1, CQC_LANG, FUNCT_4, STRUCT_0, AMI_1,
      AMI_3, SCM_1, AMI_5, FUNCT_7, SCMFSA_2, SCMFSA_4, SCMFSA_5, SCMFSA6A,
      SF_MASTR;
 constructors SCM_1, SCMFSA6A, SF_MASTR, FUNCT_7, SCMFSA_5, AMI_5, NAT_1,
      MEMBERED;
 clusters AMI_1, SCMFSA_2, FUNCT_1, SCMFSA_4, INT_1, SCMFSA6A, SF_MASTR,
      CQC_LANG, RELSET_1, FRAENKEL, XREAL_0, MEMBERED, NUMBERS, ORDINAL2;
 requirements NUMERALS, REAL, BOOLE, SUBSET, ARITHM;


begin

canceled 2;

theorem :: SCMFSA6B:3
   for f, g being Function, A being set st A /\ dom f c= A /\ dom g
  holds (f+*g|A)|A = g|A;

begin

 reserve m, n for Nat,
         x for set,
         i for Instruction of SCM+FSA,
         I for Macro-Instruction,
         a for Int-Location, f for FinSeq-Location,
         l, l1 for Instruction-Location of SCM+FSA,
         s,s1,s2 for State of SCM+FSA;

theorem :: SCMFSA6B:4
 Start-At insloc 0 c= Initialized I;

theorem :: SCMFSA6B:5
 I +* Start-At insloc n c= s implies I c= s;

theorem :: SCMFSA6B:6
 (I +* Start-At insloc n)|the Instruction-Locations of SCM+FSA = I;

theorem :: SCMFSA6B:7
 x in dom I implies I.x = (I +* Start-At insloc n).x;

theorem :: SCMFSA6B:8
 Initialized I c= s implies I +* Start-At insloc 0 c= s;

theorem :: SCMFSA6B:9
 not a in dom Start-At l;

theorem :: SCMFSA6B:10
 not f in dom Start-At l;

theorem :: SCMFSA6B:11
   not l1 in dom Start-At l;

theorem :: SCMFSA6B:12
 not a in dom (I+*Start-At l);

theorem :: SCMFSA6B:13
 not f in dom (I+*Start-At l);

theorem :: SCMFSA6B:14
 s+*I+*Start-At insloc 0 = s+*Start-At insloc 0+*I;

begin ::  General theory

 reserve N for non empty with_non-empty_elements set;

theorem :: SCMFSA6B:15
   s = Following s implies for n holds (Computation s).n = s;

theorem :: SCMFSA6B:16
for S being halting IC-Ins-separated definite
   (non empty non void AMI-Struct over N),
    s being State of S st s is halting
 holds Result s = (Computation s).LifeSpan s;

definition let N;
 let S be IC-Ins-separated definite (non empty non void AMI-Struct over N);
 let s be State of S, l be Instruction-Location of S, i be Instruction of S;
 redefine func s+*(l,i) -> State of S;
end;


definition
 let s be State of SCM+FSA, li be Int-Location, k be Integer;
 redefine func s+*(li,k) -> State of SCM+FSA;
end;


theorem :: SCMFSA6B:17
 for S being steady-programmed IC-Ins-separated definite
    (non empty non void AMI-Struct over N)
 for s being State of S, n
  holds s|the Instruction-Locations of S
    = ((Computation s).n)|the Instruction-Locations of S;

begin

definition let I be Macro-Instruction, s be State of SCM+FSA;
 func IExec(I,s) -> State of SCM+FSA equals
:: SCMFSA6B:def 1

  Result(s+*Initialized I) +* s|the Instruction-Locations of SCM+FSA;
end;


definition let I be Macro-Instruction;
 attr I is paraclosed means
:: SCMFSA6B:def 2
 for s being State of SCM+FSA, n being Nat
    st I +* Start-At insloc 0 c= s
   holds IC (Computation s).n in dom I;

 attr I is parahalting means
:: SCMFSA6B:def 3
 I +* Start-At insloc 0 is halting;

 attr I is keeping_0 means
:: SCMFSA6B:def 4
 ::Lkeep
 for s being State of SCM+FSA st I +* Start-At insloc 0 c= s
  for k being Nat holds ((Computation s).k).intloc 0 = s.intloc 0;
end;

registration
 cluster parahalting Macro-Instruction;
 existence by Lm1;
end;


theorem :: SCMFSA6B:18
 for I being parahalting Macro-Instruction
   st I +* Start-At insloc 0 c= s holds s is halting;

theorem :: SCMFSA6B:19
 for I being parahalting Macro-Instruction
   st Initialized I c= s holds s is halting;

registration let I be parahalting Macro-Instruction;
 cluster Initialized I -> halting;
 coherence proof
  let s be State of SCM+FSA; assume Initialized I c= s;
  hence s is halting by Th19;
 end;
end;


theorem :: SCMFSA6B:20
 s2 +*(IC s2, goto IC s2) is not halting;

theorem :: SCMFSA6B:21
 s1,s2 equal_outside the Instruction-Locations of SCM+FSA &
  I c= s1 & I c= s2 &
  (for m st m < n holds IC((Computation s2).m) in dom I)
 implies
 for m st m <= n holds
  (Computation s1).m, (Computation s2 ).m equal_outside
     the Instruction-Locations of SCM+FSA;

registration
 cluster parahalting -> paraclosed Macro-Instruction;
 coherence proof
  let I be Macro-Instruction; assume
A1: I is parahalting;
  let s be State of SCM+FSA, n be Nat;
 assume
A2: I +* Start-At insloc 0 c= s;
  defpred X[Nat] means not IC (Computation s).$1 in dom I;
 assume not IC (Computation s).n in dom I;
then A3: ex n st X[n];
  consider n such that
A4: X[n] and
A5: for m st X[m] holds n <= m from NAT_1:sch 5(A3);
   set s2 = (Computation s).n,
       s0 = s +*(IC s2, goto IC s2), s1 = s2 +*(IC s2, goto IC s2);
   set IAt = I +* Start-At insloc 0;
     dom I misses dom Start-At insloc 0 by SF_MASTR:64;
then A6: I c= IAt by FUNCT_4:33;
A7: IAt is halting by A1,Def3;
    (IAt)|the Instruction-Locations of SCM+FSA = I by Th6;
  then dom I = dom(IAt)/\the Instruction-Locations of SCM+FSA
        by RELAT_1:90;
  then not IC s2 in dom IAt by A4,XBOOLE_0:def 3;
  then A8: IAt c= s0 by A2,SCMFSA6A:1;
then A9: s0 is halting by A7,AMI_1:def 26;
     s,s0 equal_outside the Instruction-Locations of SCM+FSA by SCMFSA6A:3;
then A10: s0,s equal_outside the Instruction-Locations of SCM+FSA by FUNCT_7:28
;
A11: I c= s0 by A6,A8,XBOOLE_1:1;
A12: I c= s by A2,A6,XBOOLE_1:1;
   for m st m < n holds IC((Computation s).m) in dom I by A5;
then A13: (Computation s0).n,s2 equal_outside
    the Instruction-Locations of SCM+FSA by A10,A11,A12,Th21;
     s2,s1 equal_outside the Instruction-Locations of SCM+FSA by SCMFSA6A:3;
   then A14: (Computation s0).n,s1 equal_outside
    the Instruction-Locations of SCM+FSA by A13,FUNCT_7:29;
A15:  s|the Instruction-Locations of SCM+FSA
     = s2|the Instruction-Locations of SCM+FSA by Th17;
     (Computation s0).n|the Instruction-Locations of SCM+FSA
      = s0|the Instruction-Locations of SCM+FSA by Th17
     .= s1|the Instruction-Locations of SCM+FSA by A15,SCMFSA6A:5;
   then A16: (Computation s0).n = s1 by A14,SCMFSA6A:2;
    s1 is not halting by Th20;
 hence contradiction by A9,A16,SCM_1:27;
end;

 cluster keeping_0 -> paraclosed Macro-Instruction;
 coherence proof
  let I be Macro-Instruction; assume
A17: I is keeping_0;
  let s be State of SCM+FSA, n be Nat;
 assume
A18: I +* Start-At insloc 0 c= s;
A19: dom I c= the Instruction-Locations of SCM+FSA by AMI_3:def 13;
  defpred X[Nat] means not IC (Computation s).$1 in dom I;
 assume not IC (Computation s).n in dom I;
then A20: ex n st X[n];
  consider n such that
A21: X[n] and
A22: for m st X[m] holds n <= m from NAT_1:sch 5(A20);
   set FI = FirstNotUsed(I);
   set s2 = (Computation s).n;
   reconsider s00 = s +*(IC s2, intloc 0 := FI) as State of SCM+FSA;
   reconsider s0 = s00+* (FI, (s.intloc 0)+1) as State of SCM+FSA;
   not I is keeping_0 proof
  take s0;
   set IS = I +* Start-At insloc 0;
A23: dom IS = dom I \/ dom Start-At insloc 0 by FUNCT_4:def 1
           .= dom I \/ {IC SCM+FSA} by AMI_3:34;
     IC s2 <> IC SCM+FSA by AMI_1:48;
   then not IC s2 in {IC SCM+FSA} by TARSKI:def 1;
   then not IC s2 in dom IS by A21,A23,XBOOLE_0:def 2;
then A24: IS c= s00 by A18,SCMFSA6A:1;
A25:  not FI in dom I by A19,SCMFSA_2:84;
     FI <> IC SCM+FSA by SCMFSA_2:81;
   then not FI in {IC SCM+FSA} by TARSKI:def 1;
   then not FI in dom IS by A23,A25,XBOOLE_0:def 2;
  hence
A26: I +* Start-At insloc 0 c= s0 by A24,SCMFSA6A:1;
  take k = n+1;
 set s02 = (Computation s0).n;
A27: (for m st m < n holds IC (Computation s).m in dom I) by A22;
A28: not FI in UsedIntLoc I by SF_MASTR:54;
A29: not IC s2 in UsedIntLoc I proof assume not thesis; then IC s2 is
Int-Location by SCMFSA_2:11;
      hence contradiction by SCMFSA_2:84;
     end;
A30:  s0 | UsedIntLoc I = s00 | UsedIntLoc I by A28,SCMFSA6A:4
                        .= s | UsedIntLoc I by A29,SCMFSA6A:4;
A31: not FI in UsedInt*Loc I proof assume not thesis; then FI is
FinSeq-Location by SCMFSA_2:12;
       hence contradiction by SCMFSA_2:83;
      end;
A32: not IC s2 in UsedInt*Loc I proof assume not thesis; then IC s2 is
FinSeq-Location by SCMFSA_2:12;
      hence contradiction by SCMFSA_2:85;
     end;
A33:  s0 | UsedInt*Loc I = s00 | UsedInt*Loc I by A31,SCMFSA6A:4
                         .= s | UsedInt*Loc I by A32,SCMFSA6A:4;
then A34: (for m st m < n holds IC (Computation s0).m in dom I)
       by A18,A26,A27,A30,SF_MASTR:73;
A35: IC s02 = IC s2 by A18,A26,A27,A30,A33,SF_MASTR:73;
        FI in dom s00 by SCMFSA_2:66;
 then s0.FI = (s.intloc 0)+1 by FUNCT_7:33;
then A36: s02.FI = (s.intloc 0)+1 by A26,A28,A34,SF_MASTR:69;
A37: IC s2 in dom s by SCMFSA_2:5;
       IC s2 <> FI & IC s2 in dom s00 by SCMFSA_2:5,84;
     then s0.IC s2 = s00.IC s2 by FUNCT_7:34
             .= intloc 0 := FI by A37,FUNCT_7:33;
then A38: s02.IC s02 = intloc 0 := FI by A35,AMI_1:54;
A39: intloc 0 <> IC s2 & intloc 0 in dom s by SCMFSA_2:66,84;
A40: s0.intloc 0 = s00.intloc 0 by FUNCT_7:34
                .= s.intloc 0 by A39,FUNCT_7:34;
A41: (s.intloc 0) < (s.intloc 0)+1 by REAL_1:69;
      (Computation s0).k = Following s02 by AMI_1:def 19
      .= Exec(CurInstr s02, s02) by AMI_1:def 18
      .= Exec(intloc 0 := FI, s02) by A38,AMI_1:def 17;
  hence ((Computation s0).k).intloc 0 <> s0.intloc 0 by A36,A40,A41,SCMFSA_2:89
;
 end;
 hence contradiction by A17;
end;
end;


theorem :: SCMFSA6B:22
   for I being parahalting Macro-Instruction,
     a being read-write Int-Location
 holds not a in UsedIntLoc I implies (IExec(I, s)).a = s.a;

theorem :: SCMFSA6B:23
   for I being parahalting Macro-Instruction
  holds not f in UsedInt*Loc I implies (IExec(I, s)).f = s.f;

theorem :: SCMFSA6B:24
 IC s = l & s.l = goto l implies s is not halting;

registration
 cluster parahalting -> non empty Macro-Instruction;
 coherence
  proof let I be Macro-Instruction such that
A1: I is parahalting and
A2: I is empty;
    reconsider I as parahalting Macro-Instruction by A1;
   deffunc U(set) = goto insloc 0;
   deffunc V(set) = 1;
   deffunc W(set) = <*>INT;
   consider S be State of SCM+FSA such that
A3: IC S = insloc 0 and
A4:  for i being Nat holds
     S.insloc i = U(i) & S.intloc i = V(i) & S.fsloc i = W(i) from
SCMFSA6A:sch 1;
A5:  I c= S by A2,XBOOLE_1:2;
A6:  intloc 0 in dom S by SCMFSA_2:66;
      S.intloc 0 = 1 by A4;
    then (intloc 0) .--> 1 c= S by A6,SCMFSA6A:7;
then A7:  I +* ((intloc 0) .--> 1) c= S by A5,SCMFSA6A:6;
A8:  IC SCM+FSA in dom S by AMI_5:25;
      S.IC SCM+FSA = insloc 0 by A3,AMI_1:def 15;
    then IC SCM+FSA .--> insloc 0 c= S by A8,SCMFSA6A:7;
then A9:  Start-At(insloc 0) c= S by AMI_3:def 12;
      Initialized I = I +* ((intloc 0) .--> 1) +* Start-At(insloc 0)
              by SCMFSA6A:def 3;
    then Initialized I c= S by A7,A9,SCMFSA6A:6;
    then A10:   S is halting by AMI_1:def 26;
      S.insloc 0 = goto insloc 0 by A4;
   hence contradiction by A3,A10,Th24;
  end;
end;


theorem :: SCMFSA6B:25  ::T9'
 for I being parahalting Macro-Instruction holds dom I <> {};

theorem :: SCMFSA6B:26  ::T9
 for I being parahalting Macro-Instruction holds insloc 0 in dom I;

theorem :: SCMFSA6B:27  ::T0
 for J being parahalting Macro-Instruction st J +* Start-At insloc 0 c= s1
 for n being Nat st ProgramPart Relocated(J,n) c= s2 &
     IC s2 = insloc n &
     s1 | (Int-Locations \/ FinSeq-Locations)
     = s2 | (Int-Locations \/ FinSeq-Locations)
 for i being Nat holds
     IC (Computation s1).i + n = IC (Computation s2).i &
     IncAddr(CurInstr ((Computation s1).i),n) = CurInstr ((Computation s2).i) &
     (Computation s1).i | (Int-Locations \/ FinSeq-Locations)
         = (Computation s2).i | (Int-Locations \/ FinSeq-Locations);

theorem :: SCMFSA6B:28  ::T13
 for I being parahalting Macro-Instruction st
     I +* Start-At insloc 0 c= s1 & I +* Start-At insloc 0 c= s2 &
     s1,s2 equal_outside the Instruction-Locations of SCM+FSA holds
 for k being Nat holds
     (Computation s1).k, (Computation s2).k
         equal_outside the Instruction-Locations of SCM+FSA &
     CurInstr (Computation s1).k = CurInstr (Computation s2).k;

theorem :: SCMFSA6B:29  ::T14
 for I being parahalting Macro-Instruction st
     I +* Start-At insloc 0 c= s1 & I +* Start-At insloc 0 c= s2 &
     s1,s2 equal_outside the Instruction-Locations of SCM+FSA holds
 LifeSpan s1 = LifeSpan s2 &
     Result s1, Result s2 equal_outside the Instruction-Locations of SCM+FSA;

theorem :: SCMFSA6B:30  ::T27
 for I being parahalting Macro-Instruction
  holds IC IExec(I,s) = IC Result (s +* Initialized I);

theorem :: SCMFSA6B:31
 for I being non empty Macro-Instruction
  holds insloc 0 in dom I & insloc 0 in dom Initialized I &
        insloc 0 in dom (I +* Start-At insloc 0);

theorem :: SCMFSA6B:32
  x in dom Macro i iff x = insloc 0 or x = insloc 1;

theorem :: SCMFSA6B:33
        (Macro i).(insloc 0) = i &
        (Macro i).(insloc 1) = halt SCM+FSA &
        (Initialized Macro i).insloc 0 = i &
        (Initialized Macro i).insloc 1 = halt SCM+FSA &
        ((Macro i) +* Start-At insloc 0).insloc 0 = i;

theorem :: SCMFSA6B:34
    Initialized I c= s implies IC s = insloc 0;

registration
 cluster keeping_0 parahalting Macro-Instruction;
 existence by Lm2;
end;


theorem :: SCMFSA6B:35
   for I being keeping_0 parahalting Macro-Instruction
  holds IExec(I, s).intloc 0 = 1;

begin :: The composition of macroinstructions

theorem :: SCMFSA6B:36
 for I being paraclosed Macro-Instruction, J being Macro-Instruction
   st I +* Start-At insloc 0 c= s & s is halting
 for m st m <= LifeSpan s
  holds (Computation s).m,(Computation(s+*(I ';' J))).m
    equal_outside the Instruction-Locations of SCM+FSA;

theorem :: SCMFSA6B:37  ::Lemma01
 for I being paraclosed Macro-Instruction
 st s +*I is halting & Directed I c= s & Start-At insloc 0 c= s holds
     IC (Computation s).(LifeSpan (s +*I) + 1)
         = insloc card I;

theorem :: SCMFSA6B:38  ::Lemma02
 for I being paraclosed Macro-Instruction
 st s +*I is halting & Directed I c= s & Start-At insloc 0 c= s
   holds
     (Computation s).(LifeSpan (s +*I)) |
                                      (Int-Locations \/ FinSeq-Locations) =
     (Computation s).(LifeSpan (s +*I) + 1) |
                                      (Int-Locations \/ FinSeq-Locations);

theorem :: SCMFSA6B:39  ::Lemma0
 for I being parahalting Macro-Instruction
 st Initialized I c= s holds
     for k being Nat st k <= LifeSpan s holds
         CurInstr (Computation (s +* Directed I)).k <> halt SCM+FSA;

theorem :: SCMFSA6B:40
 for I being paraclosed Macro-Instruction
  st s +* (I +* Start-At insloc 0) is halting
   for J being Macro-Instruction, k being Nat
    st k <= LifeSpan (s +* (I +* Start-At insloc 0))
     holds (Computation (s +* (I +* Start-At insloc 0))).k,
           (Computation (s +* ((I ';' J) +* Start-At insloc 0))).k
            equal_outside the Instruction-Locations of SCM+FSA;

registration
 let I, J be parahalting Macro-Instruction;
 cluster I ';' J -> parahalting;
 coherence
  proof
   let s be State of SCM+FSA; assume
A1: (I ';' J) +* Start-At insloc 0 c= s;
then A2: s = s +*((I ';' J) +* SA0) by AMI_5:10;
   set SAt = Start-At insloc 0;
A3: dom I misses dom SAt by SF_MASTR:64;
     SAt c= (I ';' J) +* SAt by FUNCT_4:26;
then A4: SAt c= s by A1,XBOOLE_1:1;
   then s +*SAt = s by AMI_5:10;
   then s +*(SAt +* I) = s +* I by FUNCT_4:15;
   then s +* (I +* SAt) = s +* I by A3,FUNCT_4:36;
then A5: I +* SAt c= s +* I by FUNCT_4:26;
A6: s +* I = s +*Start-At insloc 0 +* I by A4,AMI_5:10
       .= s +*I+*Start-At insloc 0 by Th14
       .= s +*(I+*Start-At insloc 0) by FUNCT_4:15;
 A7: s +* I is halting by A5,Th18;
   set JAt = J +* SAt;
   set s1 = s +* I;
   set s3 = (Computation s1).(LifeSpan s1) +* JAt;
   set m1 = LifeSpan s1;
   set m3 = LifeSpan s3;
   set D = Int-Locations \/ FinSeq-Locations;
          reconsider kk = JAt | D as Function;
A8:  s3 | D = ((Computation s1).m1 | D) +* kk by AMI_5:6;
  A9: now let x be set;
         assume x in dom (JAt | D);
         then A10: x in dom JAt /\ D by FUNCT_1:68;
      then A11: x in dom JAt & x in D by XBOOLE_0:def 3;
         then x in dom J \/ dom SAt by FUNCT_4:def 1;
         then x in dom J \/ {IC SCM+FSA} by AMI_3:34;
         then A12: x in dom J or x in {IC SCM+FSA} by XBOOLE_0:def 2;
         per cases by A12,TARSKI:def 1;
         suppose A13: x in dom J;
            dom J c= the Instruction-Locations of SCM+FSA by AMI_3:def 13;
          hence kk.x = ((Computation s1).m1 | D).x by A11,A13,SCMFSA6A:37;
         end;
         suppose x = IC SCM+FSA;
          hence kk.x = ((Computation s1).m1 | D).x by A10,SCMFSA6A:37,XBOOLE_0:
def 3;
        end;
        end;
        JAt c= s3 by FUNCT_4:26;
      then dom JAt c= dom s3 by GRFUNC_1:8;
  then A14: dom JAt c= the carrier of SCM+FSA by AMI_3:36;
        dom (JAt | D) = dom JAt /\ D by RELAT_1:90;
      then dom (JAt | D) c= (the carrier of SCM+FSA) /\ D
          by A14,XBOOLE_1:26;
      then dom (JAt | D) c= dom ((Computation s1).m1) /\ D
          by AMI_3:36;
      then dom (JAt | D) c= dom ((Computation s1).m1 | D)
          by RELAT_1:90;
      then JAt | D c= (Computation s1).m1 | D by A9,GRFUNC_1:8;
then A15:   (Computation s1).m1 | D = s3 | D by A8,LATTICE2:8;
        (Computation s1).m1, (Computation s).m1
            equal_outside the Instruction-Locations of SCM+FSA
              by A2,A6,A7,Th40;
then A16: (Computation s).m1 | D = s3 | D by A15,SCMFSA6A:39;
        JAt c= s3 & JAt is halting by Def3,FUNCT_4:26;
then A17:   s3 is halting by AMI_1:def 26;
  A18: dom Directed I = dom I by SCMFSA6A:14;
A19: Directed I c= I ';' J by SCMFSA6A:55;
       dom (I ';' J) misses dom Start-At insloc 0 by SF_MASTR:64;
then A20:   I ';' J c= (I ';' J) +* SAt by FUNCT_4:33;
then A21:  Directed I c= (I ';' J) +* SAt by A19,XBOOLE_1:1;
     s1 +* Directed I = s +* (I +* Directed I) by FUNCT_4:15
      .= s +* Directed I by A18,FUNCT_4:20
      .= s +* ((I ';' J) +* SAt) +* Directed I
                                                    by A1,LATTICE2:8
      .= s +* (((I ';' J) +* SAt) +* Directed I) by FUNCT_4:15
      .= s +* ((I ';' J) +* SAt) by A21,LATTICE2:8
      .= s by A1,LATTICE2:8;
then A22: Directed I c= s by FUNCT_4:26;
then A23:    IC (Computation s).(LifeSpan (s +* I) + 1) = insloc card I
                             by A4,A7,Th37;
A24:  (Computation s).(m1 + 1) | D = s3 | D
                         by A4,A7,A16,A22,Th38;
      reconsider m = m1 + 1 + m3 as Nat;
      set s4 = (Computation s).(m1 + 1);
  A25: JAt c= s3 by FUNCT_4:26;
  A26: I ';' J c= s by A1,A20,XBOOLE_1:1;
        I ';' J = Directed I +* ProgramPart Relocated(J,card I)
          by SCMFSA6A:def 4;
      then ProgramPart Relocated(J,card I) c= I ';' J by FUNCT_4:26;
      then ProgramPart Relocated(J,card I) c= s by A26,XBOOLE_1:1;
   then A27: ProgramPart Relocated(J,card I) c= s4 by AMI_3:38;
   take m;
        IncAddr(CurInstr (Computation s3).m3,card I)
          = CurInstr (Computation s4).m3 by A23,A24,A25,A27,Th27;
      then IncAddr(CurInstr (Computation s3).m3,card I)
          = CurInstr (Computation s).(m1 + 1 + m3) by AMI_1:51;
   hence CurInstr((Computation s).m)
        = IncAddr (halt SCM+FSA,card I) by A17,SCM_1:def 2
       .= halt SCM+FSA by SCMFSA_4:8;
  end;
end;


theorem :: SCMFSA6B:41
 for I being keeping_0 Macro-Instruction
  st not s +* (I +* Start-At insloc 0) is halting
   for J being Macro-Instruction, k being Nat
    holds (Computation (s +* (I +* Start-At insloc 0))).k,
          (Computation (s +* ((I ';' J) +* Start-At insloc 0))).k
           equal_outside the Instruction-Locations of SCM+FSA;

theorem :: SCMFSA6B:42
 for I being keeping_0 Macro-Instruction
  st s +* I is halting
   for J being paraclosed Macro-Instruction
    st (I ';' J) +* Start-At insloc 0 c= s
     for k being Nat
     holds (Computation (Result(s +*I)
                               +* (J +* Start-At insloc 0))).k
    +* Start-At (IC (Computation ((Result(s +*I))
                           +* (J +* Start-At insloc 0))).k + card I),
           (Computation (s +* (I ';' J))).
                          (LifeSpan (s +* I)+1+k)
            equal_outside the Instruction-Locations of SCM+FSA;

registration
 let I, J be keeping_0 Macro-Instruction;
 cluster I ';' J -> keeping_0;
 coherence
 proof set SA0 = Start-At insloc 0;
  let s be State of SCM+FSA; assume
A1: (I ';' J) +* SA0 c= s;
then A2: s +* ((I ';' J) +* SA0) = s by AMI_5:10;

           SA0 c= (I ';' J) +* SA0 by FUNCT_4:26;
then A3:      SA0 c= s by A1,XBOOLE_1:1;

A4: s +*((I ';' J) +* Start-At insloc 0)
   = s +*(I ';' J) +* Start-At insloc 0 by FUNCT_4:15
  .= s +* Start-At insloc 0 +*(I ';' J) by Th14
  .= s +* (I ';' J) by A3,AMI_5:10;

A5: I +* SA0 c= s +* (I +* SA0) by FUNCT_4:26;
      dom SA0 = {IC SCM+FSA} & intloc 0 <> IC SCM+FSA by AMI_3:34,SCMFSA_2:81;
    then not intloc 0 in dom I & not intloc 0 in dom SA0
           by SCMFSA6A:47,TARSKI:def 1;
    then not intloc 0 in dom I \/ dom SA0 by XBOOLE_0:def 2;
then A6: not intloc 0 in dom (I +* SA0) by FUNCT_4:def 1;
 per cases;
  suppose A7: s +* (I +* SA0) is halting;
    A8: s +* (I +* SA0) = s +*I +* SA0 by FUNCT_4:15
         .= s +* SA0 +* I by Th14
         .= s +* I by A3,AMI_5:10;
   let k be Nat;
  hereby
   per cases;
   suppose A9: k <= LifeSpan(s +* (I +* SA0));
A10:  (Computation (s +* (I +* SA0))).k.intloc 0
     = (s +* (I +* SA0)).intloc 0 by A5,Def4
    .= s.intloc 0 by A6,FUNCT_4:12;
       (Computation (s +* (I +* Start-At insloc 0))).k,
     (Computation (s +* ((I ';' J) +* Start-At insloc 0))).k
        equal_outside the Instruction-Locations of SCM+FSA by A7,A9,Th40
;
    hence ((Computation s).k).intloc 0 = s.intloc 0 by A2,A10,SCMFSA6A:30;
   end;
   suppose A11: k > LifeSpan(s +* (I +* SA0));
    set LS = LifeSpan(s +* (I +* SA0));
     consider p being Nat such that
   A12: k = LS + p & 1 <= p by A11,FSM_1:1;
     consider r being Nat such that
   A13: p = 1 + r by A12,NAT_1:28;
   A14: k = LS + 1 + r by A12,A13,XCMPLX_1:1;
        dom SA0 = {IC SCM+FSA} & intloc 0 <> IC SCM+FSA
      by AMI_3:34,SCMFSA_2:81;
        then not intloc 0 in dom J & not intloc 0 in dom SA0
           by SCMFSA6A:47,TARSKI:def 1;
      then not intloc 0 in dom J \/ dom SA0 by XBOOLE_0:def 2;
   then A15: not intloc 0 in dom (J +* SA0) by FUNCT_4:def 1;

     J +* SA0 c= Result(s +*(I+*SA0)) +* (J +* SA0) by FUNCT_4:26;
        then A16: (Computation (Result(s +*(I+*SA0)) +* (J +* SA0))).r.intloc 0
     = (Result(s +*(I+*SA0)) +* (J +* SA0)).intloc 0 by Def4
    .= (Result(s +*(I+*SA0))).intloc 0 by A15,FUNCT_4:12
    .= (Computation(s +*(I+*SA0))).(LifeSpan (s +*(I+*SA0)))
                                                 .intloc 0 by A7,Th16
    .= (s +*(I+*SA0)).intloc 0 by A5,Def4
    .= s.intloc 0 by A6,FUNCT_4:12;
set Rr = (Computation (Result(s +*(I+*SA0)) +* (J +* SA0))).r;
set Sr = Start-At (IC ((Computation (Result(s +*(I+*SA0))
                           +* (J +* SA0)))).r + card I);
         dom Sr = {IC SCM+FSA} & intloc 0 <> IC SCM+FSA
       by AMI_3:34,SCMFSA_2:81;
    then not intloc 0 in dom Sr by TARSKI:def 1;
   then A17: (Rr +* Sr).intloc 0 = Rr.intloc 0 by FUNCT_4:12;
          Rr +* Sr,
      (Computation (s +* ((I ';' J) +* Start-At insloc 0))).(LS+1+r)
        equal_outside the Instruction-Locations of SCM+FSA
                     by A1,A4,A7,A8,Th42;
    hence ((Computation s).k).intloc 0 = s.intloc 0 by A2,A14,A16,A17,SCMFSA6A:
30;
  end;
  end;
  end;
  suppose A18: not s +* (I +* SA0) is halting;
   let k be Nat;
      I +* SA0 c= s +* (I +* SA0) by FUNCT_4:26;
then A19:  (Computation (s +* (I +* SA0))).k.intloc 0
     = (s +* (I +* SA0)).intloc 0 by Def4
    .= s.intloc 0 by A6,FUNCT_4:12;
      (Computation (s +* (I +* SA0))).k,
    (Computation (s +* ((I ';' J) +* SA0))).k
           equal_outside the Instruction-Locations of SCM+FSA by A18,Th41;
   hence ((Computation s).k).intloc 0 = s.intloc 0 by A2,A19,SCMFSA6A:30;
 end;
 end;
end;


theorem :: SCMFSA6B:43  ::T22
 for I being keeping_0 parahalting Macro-Instruction,
     J being parahalting Macro-Instruction
   holds
     LifeSpan (s +* Initialized (I ';' J))
         = LifeSpan (s +* Initialized I) + 1
         + LifeSpan (Result (s +* Initialized I) +* Initialized J);

theorem :: SCMFSA6B:44
    for I being keeping_0 parahalting Macro-Instruction,
     J being parahalting Macro-Instruction
  holds
     IExec(I ';' J,s) =
         IExec(J,IExec(I,s)) +* Start-At (IC IExec(J,IExec(I,s)) + card I);

