:: On the compositions of macro instructions, Part II
::  by Noriko Asamoto , Yatsuka Nakamura , Piotr Rudnicki and Andrzej Trybulec
::
:: Received July 22, 1996
:: Copyright (c) 1996 Association of Mizar Users

environ

 vocabularies NUMBERS, SUBSET_1, AMI_1, SCMFSA_2, FSM_1, CARD_1, TARSKI,
      SCMFSA6A, FUNCT_4, RELAT_1, XBOOLE_0, FUNCT_1, SETFAM_1, INT_1, MSUALG_1,
      CIRCUIT2, GLIB_000, AMI_3, ARYTM_3, FUNCT_7, XXREAL_0, NAT_1, SF_MASTR,
      GRAPHSP, FINSEQ_1, FUNCOP_1, AMISTD_2, TURING_1, STRUCT_0, VALUED_1,
      CARD_3, SCMFSA6B, PARTFUN1, SCMNORM;
 notations TARSKI, XBOOLE_0, SUBSET_1, SETFAM_1, CARD_1, NUMBERS, XCMPLX_0,
      XXREAL_0, NAT_1, FUNCT_7, INT_1, RELAT_1, FUNCT_1, PARTFUN1, FINSEQ_1,
      FUNCOP_1, FUNCT_4, VALUED_1, STRUCT_0, AMI_1, SCMNORM, SCMFSA_2,
      SCMFSA_4, SCMFSA_5, SCMFSA6A, SF_MASTR;
 constructors DOMAIN_1, XXREAL_0, NAT_1, PARTFUN1, SCMFSA_5, SCMFSA6A,
      SF_MASTR, SCMNORM, SCMFSA_4, RELSET_1, SCMFSA_1, PRE_POLY, RELOC;
 registrations SETFAM_1, RELAT_1, FUNCT_1, ORDINAL1, FUNCOP_1, NUMBERS,
      XXREAL_0, XREAL_0, NAT_1, INT_1, CARD_3, SCMFSA_2, SCMFSA6A, SF_MASTR,
      XBOOLE_0, SCMNORM, FINSET_1, VALUED_1, AMI_1, GRFUNC_1, RELSET_1,
      FUNCT_2;
 requirements NUMERALS, REAL, BOOLE, SUBSET, ARITHM;


begin

reserve m, n for Element of NAT,
  x for set,
  i for Instruction of SCM+FSA,
  I for Program of SCM+FSA,
  a for Int-Location,
  f for FinSeq-Location,
  l, l1 for
  Element of NAT,
  s,s1,s2 for State of SCM+FSA;

canceled 3;

theorem :: SCMFSA6B:4
  Start-At( 0,SCM+FSA) c= Initialized I;

theorem :: SCMFSA6B:5
  I +* Start-At( n,SCM+FSA) c= s implies I c= s;

theorem :: SCMFSA6B:6
  (I +* Start-At( n,SCM+FSA))|NAT = I;

theorem :: SCMFSA6B:7
  x in dom I implies I.x = (I +* Start-At( n,SCM+FSA)).x;

theorem :: SCMFSA6B:8
  Initialized I c= s implies I +* Start-At( 0,SCM+FSA) c= s;

theorem :: SCMFSA6B:9
  not a in dom Start-At(l,SCM+FSA);

theorem :: SCMFSA6B:10
  not f in dom Start-At(l,SCM+FSA);

canceled;

theorem :: SCMFSA6B:12
  not a in dom (I+*Start-At(l,SCM+FSA));

theorem :: SCMFSA6B:13
  not f in dom (I+*Start-At(l,SCM+FSA));

theorem :: SCMFSA6B:14
  s+*I+*Start-At( 0,SCM+FSA) = s+*Start-At( 0,SCM+FSA)+*I;

begin ::  General theory

reserve N for with_non-empty_elements set;

definition
  let s be State of SCM+FSA, li be Int-Location, k be Integer;
  redefine func s+*(li,k) -> State of SCM+FSA;
end;

begin

definition
  let I be Program of SCM+FSA, s be State of SCM+FSA;
  func IExec(I,s) -> State of SCM+FSA equals
:: SCMFSA6B:def 1
  Result(ProgramPart(s+*Initialized I),s+*Initialized I) +* s|NAT;
end;

definition
  let I be Program of SCM+FSA;
  attr I is paraclosed means
:: SCMFSA6B:def 2

  for s being State of SCM+FSA, n being
Element of NAT st I +* Start-At( 0,SCM+FSA) c= s
 holds IC Comput(ProgramPart(s),s,n) in dom
  I;
  attr I is parahalting means
:: SCMFSA6B:def 3

  I +* Start-At( 0,SCM+FSA) is halting;
  attr I is keeping_0 means
:: SCMFSA6B:def 4

  for s being State of SCM+FSA st I +*
Start-At( 0,SCM+FSA) c= s for k being Element of NAT
 holds Comput(ProgramPart(s),s,k).intloc
  0 = s.intloc 0;
end;

registration
  cluster parahalting Program of SCM+FSA;
end;

canceled 3;

theorem :: SCMFSA6B:18
  for I being parahalting Program of SCM+FSA st I +* Start-At
  ( 0,SCM+FSA) c= s holds ProgramPart s halts_on s;

theorem :: SCMFSA6B:19
  for I being parahalting Program of SCM+FSA st Initialized I c= s
  holds ProgramPart s halts_on s;

registration
  let I be parahalting Program of SCM+FSA;
  cluster Initialized I -> halting;
end;

theorem :: SCMFSA6B:20
  not ProgramPart(s2 +*(IC s2, goto IC s2)) halts_on s2 +*(IC s2, goto IC s2);

theorem :: SCMFSA6B:21
  s1,s2 equal_outside NAT & I c= s1 & I c= s2 & (for m st m < n
holds IC Comput(ProgramPart(s2),s2,m) in dom I) implies for m st m <= n holds
Comput(ProgramPart(
  s1),
  s1,m), Comput(ProgramPart(s2),s2,m) equal_outside NAT;

registration
  cluster parahalting -> paraclosed Program of SCM+FSA;
  cluster keeping_0 -> paraclosed Program of SCM+FSA;
end;

theorem :: SCMFSA6B:22
  for I being parahalting Program of SCM+FSA, a being read-write
  Int-Location holds not a in UsedIntLoc I implies (IExec(I, s)).a = s.a;

theorem :: SCMFSA6B:23
  for I being parahalting Program of SCM+FSA holds not f in UsedInt*Loc
  I implies (IExec(I, s)).f = s.f;

theorem :: SCMFSA6B:24
  IC s = l & s.l = goto l implies not ProgramPart s halts_on s;

registration
  cluster parahalting -> non empty Program of SCM+FSA;
end;

canceled 2;

theorem :: SCMFSA6B:27
  for J being parahalting Program of SCM+FSA st J +* Start-At(
 0,SCM+FSA) c= s1 for n being Element of NAT
 st ProgramPart Relocated(J,n) c= s2 &
  IC s2 =  n & DataPart s1 = DataPart s2 for i being Element of NAT holds
  IC Comput(ProgramPart(s1),s1,i) + n = IC Comput(ProgramPart(s2),s2,i) &
   IncAddr(CurInstr(ProgramPart Comput(ProgramPart(s1),s1,i),Comput(ProgramPart
(s1),s1,i)),n)
    = CurInstr(ProgramPart Comput(ProgramPart(s2),s2,i),Comput(ProgramPart(s2),
s2,i))
     & DataPart Comput(ProgramPart(s1
  ),s1
  ,i) = DataPart Comput(ProgramPart(s2),s2,i);

theorem :: SCMFSA6B:28
  for I being parahalting Program of SCM+FSA st I +* Start-At(
   0,SCM+FSA) c= s1 & I +* Start-At( 0,SCM+FSA) c= s2 &
   s1,s2 equal_outside NAT holds
  for k being Element of NAT holds Comput(ProgramPart(s1),s1,k), Comput(
ProgramPart(s2),s2,k)
  equal_outside NAT & CurInstr(ProgramPart Comput(ProgramPart(s1),s1,k),Comput(
ProgramPart(s1),s1,k))
   = CurInstr(ProgramPart Comput(ProgramPart(s2),s2,k),Comput(ProgramPart(s2),
s2,k));

theorem :: SCMFSA6B:29
  for I being parahalting Program of SCM+FSA st I +* Start-At(
   0,SCM+FSA) c= s1 & I +* Start-At( 0,SCM+FSA) c= s2 &
   s1,s2 equal_outside NAT holds
  LifeSpan(ProgramPart(s1),s1) = LifeSpan(ProgramPart(s2),s2) & Result(
ProgramPart(s1),s1), Result(ProgramPart(s2),s2) equal_outside NAT;

theorem :: SCMFSA6B:30
  for I being parahalting Program of SCM+FSA holds IC IExec(I,s) =
  IC Result(ProgramPart(s +* Initialized I),s +* Initialized I);

theorem :: SCMFSA6B:31
  for I being non empty Program of SCM+FSA holds
    0 in dom Initialized I & 0 in dom (I +* Start-At( 0,SCM+FSA));

theorem :: SCMFSA6B:32
  x in dom Macro i iff x =  0 or x =  1;

theorem :: SCMFSA6B:33
  (Macro i).( 0) = i & (Macro i).( 1) = halt SCM+FSA &
  (Initialized Macro i). 0 = i & (Initialized Macro i). 1 = halt
  SCM+FSA & ((Macro i) +* Start-At( 0,SCM+FSA)). 0 = i;

theorem :: SCMFSA6B:34
  Initialized I c= s implies IC s =  0;

registration
  cluster keeping_0 parahalting Program of SCM+FSA;
end;

theorem :: SCMFSA6B:35
  for I being keeping_0 parahalting Program of SCM+FSA holds IExec(I, s)
  .intloc 0 = 1;

begin :: The composition of macroinstructions

registration
 cluster paraclosed Program of SCM+FSA;
end;

theorem :: SCMFSA6B:36
  for I being paraclosed Program of SCM+FSA, J being Program of
SCM+FSA st I +* Start-At( 0,SCM+FSA) c= s & ProgramPart s halts_on s
 for m st m <= LifeSpan(ProgramPart(s),s)
  holds Comput(ProgramPart(s),s,m), Comput(ProgramPart(s+*(I ';' J)),s+*(I ';'
J),m) equal_outside NAT;

theorem :: SCMFSA6B:37
  for I being paraclosed Program of SCM+FSA
   st ProgramPart(s+*I) halts_on s+*I &
Directed I c= s & Start-At( 0,SCM+FSA) c= s
 holds IC Comput(ProgramPart(s),s,LifeSpan(ProgramPart(s +*I
  ),s +*I
  ) + 1) =  card I;

theorem :: SCMFSA6B:38
  for I being paraclosed Program of SCM+FSA
   st ProgramPart(s+*I) halts_on s+*I &
Directed I c= s & Start-At( 0,SCM+FSA) c= s
 holds DataPart Comput(ProgramPart(s),s,LifeSpan(ProgramPart(
  s+*I),
  s+*I)) = DataPart Comput(ProgramPart(s),s,LifeSpan(ProgramPart(s +*I),s +*I)
+ 1);

theorem :: SCMFSA6B:39
  for I being parahalting Program of SCM+FSA st Initialized I c= s
holds for k being Element of NAT st k <= LifeSpan(ProgramPart(s),s)
 holds CurInstr(ProgramPart(s+*Directed I),
 Comput(ProgramPart(s+*Directed I),s+*Directed I,k)) <> halt SCM+FSA;

theorem :: SCMFSA6B:40
  for I being paraclosed Program of SCM+FSA
   st ProgramPart(s +* (I +* Start-At( 0,SCM+FSA)))
    halts_on s +* (I +* Start-At( 0,SCM+FSA))
 for J being Program of SCM+FSA, k being Element of NAT st
  k <= LifeSpan(ProgramPart(s +* (I +* Start-At( 0,SCM+FSA))),s +* (I +*
Start-At( 0,SCM+FSA)))
   holds Comput(ProgramPart(s +* (I +*
  Start-At( 0,SCM+FSA))),s +* (I +*
  Start-At( 0,SCM+FSA)),k), Comput(ProgramPart(s +* ((I ';' J)
   +* Start-At( 0,SCM+FSA))),s +* ((I ';' J)
   +* Start-At( 0,SCM+FSA)),k)
  equal_outside NAT;

registration
  let I, J be parahalting Program of SCM+FSA;
  cluster I ';' J -> parahalting;
end;

theorem :: SCMFSA6B:41
  for I being keeping_0 Program of SCM+FSA
   st not ProgramPart(s +* (I +* Start-At( 0,SCM+FSA)))
    halts_on s +* (I +* Start-At( 0,SCM+FSA))
   for J being Program of SCM+FSA, k being Element
of NAT holds Comput(ProgramPart(s +*
 (I +* Start-At( 0,SCM+FSA))),s +*
 (I +* Start-At( 0,SCM+FSA)),k), Comput(ProgramPart(s +* ((I
  ';' J) +* Start-At( 0,SCM+FSA))),s +* ((I
  ';' J) +* Start-At( 0,SCM+FSA)),k) equal_outside NAT;

theorem :: SCMFSA6B:42
  for I being keeping_0 Program of SCM+FSA st ProgramPart(s+*I) halts_on s+*I
for J being paraclosed Program of SCM+FSA st (I ';' J)
 +* Start-At( 0,SCM+FSA) c=
s for k being Element of NAT holds Comput(ProgramPart(Result(ProgramPart(s +*I)
,s +*I) +* (J +*
Start-At
  ( 0,SCM+FSA))),Result(ProgramPart(s +*I),s +*I) +* (J +* Start-At
  ( 0,SCM+FSA)),k) +* Start-At (IC (Comput(ProgramPart((Result(ProgramPart(s +*
I),s +*I)) +*
   (J +* Start-At(
 0,SCM+FSA))),(Result(ProgramPart(s +*I),s +*I)) +*
   (J +* Start-At(
 0,SCM+FSA)),k)) + card I,SCM+FSA),
 Comput(ProgramPart(s +* (I ';' J)),s +* (I ';' J), (LifeSpan(ProgramPart(s +*
I),s +* I)+1+k))
  equal_outside NAT;

registration
  let I, J be keeping_0 Program of SCM+FSA;
  cluster I ';' J -> keeping_0;
end;

theorem :: SCMFSA6B:43
  for I being keeping_0 parahalting Program of SCM+FSA, J being
  parahalting Program of SCM+FSA holds LifeSpan(ProgramPart(s +* Initialized (I
';' J)),s +* Initialized (I ';' J)) =
  LifeSpan(ProgramPart(s +* Initialized I),s +* Initialized I) + 1 + LifeSpan(
ProgramPart(Result(ProgramPart(s +* Initialized I),s +* Initialized I) +*
  Initialized J),Result(ProgramPart(s +* Initialized I),s +* Initialized I) +*
  Initialized J);

theorem :: SCMFSA6B:44
  for I being keeping_0 parahalting Program of SCM+FSA, J being
parahalting Program of SCM+FSA holds IExec(I ';' J,s) = IExec(J,IExec(I,s)) +*
  Start-At (IC IExec(J,IExec(I,s)) + card I,SCM+FSA);

