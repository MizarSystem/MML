:: Abelian Groups, Fields and Vector Spaces
::  by Eugeniusz Kusak, Wojciech Leo\'nczuk and Micha{\l} Muzalewski
::
:: Received November 23, 1989
:: Copyright (c) 1990 Association of Mizar Users

environ

 vocabularies RLVECT_1, BINOP_1, ARYTM_1, FUNCT_1, LATTICES, RELAT_1, ARYTM_3,
      VECTSP_1, ALGSTR_2, REALSET1, GROUP_1, ARYTM, MOD_1, VECTSP_2, STRUCT_0,
      ALGSTR_0;
 notations XBOOLE_0, ZFMISC_1, SUBSET_1, NUMBERS, FUNCT_1, FUNCT_2, BINOP_1,
      ORDINAL1, XCMPLX_0, XXREAL_0, XREAL_0, NAT_D, BINARITH, BINOP_2,
      STRUCT_0, ALGSTR_0, RLVECT_1, GROUP_1;
 constructors BINOP_1, XXREAL_0, NAT_1, BINARITH, RLVECT_1, GROUP_1, BINOP_2,
      NAT_D;
 registrations ORDINAL1, RELSET_1, NUMBERS, XREAL_0, STRUCT_0, GROUP_1,
      ALGSTR_0;
 requirements NUMERALS, SUBSET, ARITHM, BOOLE;


begin

::
::                         1_ GROUP STRUCTURE
::

reserve GS for non empty addLoopStr;

definition
  canceled 5;
  func G_Real -> strict addLoopStr equals
:: VECTSP_1:def 6

  addLoopStr (# REAL,addreal,0 #);
end;

registration
  cluster G_Real -> non empty;
end;

registration
  cluster -> real Element of G_Real;
end;

registration
  let a,b be Element of G_Real, x,y be real number;
  identify a+b with x+y when a = x, b = y;
end;

registration
  cluster G_Real -> Abelian add-associative right_zeroed right_complementable;
end;

registration
  let a be Element of G_Real, x be real number;
  identify -a with -x when a = x;
end;

canceled 5;

theorem :: VECTSP_1:6
  for x,y,z being Element of G_Real holds x+y = y+x & (x+y)+z = x+(y+z) &
  x+(0.G_Real) = x & x+(-x) = 0.G_Real;

registration
  cluster strict add-associative right_zeroed right_complementable
    Abelian (non empty addLoopStr);
end;

definition
  mode AddGroup is add-associative right_zeroed right_complementable
    (non empty addLoopStr);
end;

definition
  mode AbGroup is Abelian AddGroup;
end;

::
::                         4. FIELD STRUCTURE
::

definition
  let IT be non empty doubleLoopStr;
  canceled 4;
  attr IT is right-distributive means
:: VECTSP_1:def 11

  for a, b, c being Element of IT holds a*(b+c) = a*b + a*c;
  attr IT is left-distributive means
:: VECTSP_1:def 12

  for a, b, c being Element of IT holds (b+c)*a = b*a + c*a;
end;

definition
  let IT be non empty multLoopStr;
  attr IT is right_unital means
:: VECTSP_1:def 13

  for x being Element of IT holds x * 1.IT = x;
end;

definition
  canceled;
  func F_Real -> strict doubleLoopStr equals
:: VECTSP_1:def 15
  doubleLoopStr (# REAL,addreal,multreal,1,0 #);
end;

registration
  cluster F_Real -> non empty;
end;

registration
  cluster -> real Element of F_Real;
end;

registration
  let a,b be Element of F_Real, x,y be real number;
  identify a+b with x+y when a = x, b = y;
end;

registration
  let a,b be Element of F_Real, x,y be real number;
  identify a*b with x*y when a = x, b = y;
end;

definition
  let IT be non empty multLoopStr;
  attr IT is well-unital means
:: VECTSP_1:def 16

  for x being Element of IT holds x * 1.IT = x & 1.IT * x = x;
end;

registration
  cluster F_Real -> well-unital;
end;

registration
  cluster well-unital (non empty multLoopStr_0);
end;

definition
  let IT be non empty doubleLoopStr;
  canceled;
  attr IT is distributive means
:: VECTSP_1:def 18

  for x,y,z being Element of IT holds
  x*(y+z) = x*y+x*z & (y+z)*x = y*x+z*x;
end;

definition
  let IT be non empty multLoopStr;
  attr IT is left_unital means
:: VECTSP_1:def 19

  for x being Element of IT holds 1.IT * x = x;
end;

definition
  let IT be non empty multLoopStr_0;
  redefine attr IT is almost_left_invertible means
:: VECTSP_1:def 20

  for x being Element of IT st x <> 0.IT ex y be Element of IT st y*x = 1.IT;
end;

registration
  cluster F_Real -> unital;
end;

registration
  cluster F_Real -> add-associative right_zeroed right_complementable Abelian
    commutative associative left_unital right_unital distributive
    almost_left_invertible non degenerated;
end;

registration
  let a be Element of F_Real, x be real number;
  identify -a with -x when a = x;
end;

registration
  cluster distributive -> left-distributive right-distributive
    (non empty doubleLoopStr);
  cluster left-distributive right-distributive -> distributive
    (non empty doubleLoopStr);
end;

registration
  cluster well-unital -> left_unital right_unital (non empty multLoopStr);
  cluster left_unital right_unital -> unital (non empty multLoopStr);
end;

registration
  cluster commutative associative (non empty multMagma);
end;

registration
  cluster commutative associative unital (non empty multLoopStr);
end;

registration
  cluster add-associative right_zeroed right_complementable Abelian
    commutative associative left_unital right_unital distributive
    almost_left_invertible
    non degenerated well-unital strict (non empty doubleLoopStr);
end;

definition
  mode Field is add-associative right_zeroed right_complementable
    Abelian commutative associative well-unital distributive
    almost_left_invertible non degenerated (non empty doubleLoopStr);
end;

canceled 13;

theorem :: VECTSP_1:20
  1.F_Real = 1;

theorem :: VECTSP_1:21
  for x,y,z being Element of F_Real holds x+y = y+x & (x+y)+z = x+(y+z) &
  x+(0.F_Real) = x & x+(-x) = 0.F_Real & x*y = y*x & (x*y)*z = x*(y*z) &
  (1.F_Real)*x = x &
  (x <> 0.F_Real implies ex y be Element of F_Real st y*x = 1.F_Real) &
  x*(y+z) = x*y+x*z & (y+z)*x = y*x+z*x;

theorem :: VECTSP_1:22
  for FS being non empty doubleLoopStr holds
  (for x,y,z being Element of FS holds
  (x <> 0.FS implies ex y be Element of FS st y*x = 1.FS)
  & x*(y+z) = x*y+x*z & (y+z)*x = y*x+z*x ) iff
  FS is distributive almost_left_invertible (non empty doubleLoopStr);

::
::                        6. AXIOMS OF FIELD
::

canceled 10;

registration
  cluster well-unital -> unital (non empty multLoopStr);
end;

theorem :: VECTSP_1:33
  for F being associative commutative well-unital distributive
  almost_left_invertible (non empty doubleLoopStr), x,y,z being Element of F
  holds (x <> 0.F & x*y = x*z) implies y = z;

definition
  let F be associative commutative well-unital
  almost_left_invertible (non empty doubleLoopStr), x be Element of F;
  canceled;
  assume
 x <> 0.F;
  redefine func x" means
:: VECTSP_1:def 22

  it*x = 1.F;
end;

definition
  let F be associative commutative well-unital distributive
  almost_left_invertible (non empty doubleLoopStr), x,y be Element of F;
  func x/y ->Element of F equals
:: VECTSP_1:def 23

  x*y";
end;

canceled 2;

theorem :: VECTSP_1:36
  for F being add-associative right_zeroed right_complementable
  right-distributive (non empty doubleLoopStr), x being Element of F
  holds x*(0.F) = 0.F;

canceled 2;

theorem :: VECTSP_1:39
  for F being add-associative right_zeroed right_complementable
  left-distributive (non empty doubleLoopStr), x being Element of F
  holds (0.F)*x = 0.F;

theorem :: VECTSP_1:40
  for F be add-associative right_zeroed right_complementable
  right-distributive (non empty doubleLoopStr), x,y being Element of F
  holds x*(-y) = -x*y;

theorem :: VECTSP_1:41
  for F be add-associative right_zeroed right_complementable
  left-distributive (non empty doubleLoopStr), x,y being Element of F
  holds (-x)*y = -x*y;

theorem :: VECTSP_1:42
  for F be add-associative right_zeroed right_complementable
  distributive (non empty doubleLoopStr), x,y being Element of F
  holds (-x)*(-y) = x*y;

theorem :: VECTSP_1:43
  for F be add-associative right_zeroed right_complementable
  right-distributive (non empty doubleLoopStr), x,y,z being Element of F holds
  x*(y-z) = x*y - x*z;

theorem :: VECTSP_1:44
  for F being add-associative right_zeroed right_complementable
  associative commutative well-unital almost_left_invertible
  distributive (non empty doubleLoopStr), x,y being Element of F holds
  x*y=0.F iff x=0.F or y=0.F;

theorem :: VECTSP_1:45
  for K being add-associative right_zeroed right_complementable
  left-distributive (non empty doubleLoopStr)
  for a,b,c be Element of K holds (a-b)*c =a*c -b*c;

::
::                      8. VECTOR SPACE STRUCTURE
::

definition
  let F be 1-sorted;
  struct(addLoopStr) VectSpStr over F (# carrier -> set,
    addF -> BinOp of the carrier, ZeroF -> Element of the carrier,
    lmult -> Function of [:the carrier of F,the carrier:], the carrier #);
end;

registration
  let F be 1-sorted;
  cluster non empty strict VectSpStr over F;
end;

registration
  let F be 1-sorted;
  let A be non empty set, a be BinOp of A, Z be Element of A,
  l be Function of [:the carrier of F,A:], A;
  cluster VectSpStr(#A,a,Z,l#) -> non empty;
end;

definition
  let F be 1-sorted;
  mode Scalar of F is Element of F;
end;

definition
  let F be 1-sorted;
  let VS be VectSpStr over F;
  mode Scalar of VS is Scalar of F;
  mode Vector of VS is Element of VS;
end;

definition
  let F be non empty 1-sorted, V be non empty VectSpStr over F;
  let x be Element of F;
  let v be Element of V;
  func x*v -> Element of V equals
:: VECTSP_1:def 24

  (the lmult of V).(x,v);
end;

definition
  let F be non empty addLoopStr;
  func comp F -> UnOp of the carrier of F means
:: VECTSP_1:def 25
  for x being Element of F holds it.x = -x;
end;

definition
  let F be non empty doubleLoopStr;
  let IT be non empty VectSpStr over F;
  attr IT is VectSp-like means
:: VECTSP_1:def 26

  for x,y being Element of F
  for v,w being Element of IT holds x*(v+w) = x*v+x*w & (x+y)*v = x*v+y*v &
  (x*y)*v = x*(y*v) & (1.F)*v = v;
end;

registration
  let F be add-associative right_zeroed right_complementable Abelian
  associative well-unital distributive (non empty doubleLoopStr);
  cluster VectSp-like add-associative right_zeroed right_complementable Abelian
    strict (non empty VectSpStr over F);
end;

definition
  let F be add-associative right_zeroed right_complementable Abelian
  associative well-unital distributive (non empty doubleLoopStr);
  mode VectSp of F is VectSp-like
    add-associative right_zeroed right_complementable Abelian
    (non empty VectSpStr over F);
end;

reserve F for Field,
  x for Element of F,
  V for VectSp-like add-associative right_zeroed right_complementable
  (non empty VectSpStr over F),
  v for Element of V;

canceled 13;

theorem :: VECTSP_1:59
  for F being add-associative right_zeroed right_complementable
  Abelian associative well-unital distributive (non empty doubleLoopStr),
  x being Element of F for V being add-associative right_zeroed
  right_complementable VectSp-like (non empty VectSpStr over F),
  v being Element of V holds (0.F)*v = 0.V & (-1.F)*v = -v & x*(0.V) = 0.V;

theorem :: VECTSP_1:60
  x*v = 0.V iff x = 0.F or v = 0.V;

::
::                          13. APPENDIX
::

canceled 2;

theorem :: VECTSP_1:63
  for V being add-associative right_zeroed
  right_complementable (non empty addLoopStr), v,w being Element of V holds
  v+w=0.V iff -v=w;

theorem :: VECTSP_1:64
  for V being add-associative right_zeroed
  right_complementable (non empty addLoopStr), u,v,w being Element of V holds
  -(v+w)=-w-v & -(w+-v)=v-w & -(v-w)=w+-v & -(-v-w)=w+v &
  u-(w+v)=u-v-w;

theorem :: VECTSP_1:65
  for V being add-associative right_zeroed
  right_complementable (non empty addLoopStr), v being Element of V holds
  0.V-v=-v & v-0.V=v;

theorem :: VECTSP_1:66
  for F being add-associative right_zeroed
  right_complementable (non empty addLoopStr), x,y being Element of F holds
  (x+(-y)=0.F iff x=y) & (x-y=0.F iff x=y);

theorem :: VECTSP_1:67
  x<>0.F implies x"*(x*v)=v;

theorem :: VECTSP_1:68
  for F be add-associative right_zeroed right_complementable Abelian
  associative well-unital distributive (non empty doubleLoopStr),
  V be VectSp-like add-associative right_zeroed right_complementable
  (non empty VectSpStr over F), x being Element of F,
  v,w being Element of V holds -x*v=(-x)*v & w-x*v=w+(-x)*v;

registration
  cluster commutative left_unital -> right_unital (non empty multLoopStr);
end;

theorem :: VECTSP_1:69
  for F be add-associative right_zeroed right_complementable Abelian
  associative well-unital right_unital distributive (non empty doubleLoopStr),
  V be VectSp-like add-associative right_zeroed right_complementable
  (non empty VectSpStr over F), x being Element of F,
  v being Element of V holds x*(-v)=-x*v;

theorem :: VECTSP_1:70
  for F be add-associative right_zeroed right_complementable Abelian
  associative well-unital right_unital distributive (non empty doubleLoopStr),
  V be VectSp-like add-associative right_zeroed right_complementable
  (non empty VectSpStr over F), x being Element of F,
  v,w being Element of V holds x*(v-w)=x*v-x*w;

canceled 2;

theorem :: VECTSP_1:73
  for F being add-associative right_zeroed right_complementable
  commutative associative well-unital non degenerated
  almost_left_invertible distributive (non empty doubleLoopStr),
  x being Element of F holds x <> 0.F implies (x")" = x;

theorem :: VECTSP_1:74
  for F being Field, x being Element of F holds
  x <> 0.F implies x" <> 0.F & -x" <> 0.F;

canceled 3;

theorem :: VECTSP_1:78
  1.F_Real + 1.F_Real <> 0.F_Real;

definition
  let IT be non empty addLoopStr;
  canceled;
  attr IT is Fanoian means
:: VECTSP_1:def 28

  for a being Element of IT st a + a = 0.IT
  holds a = 0.IT;
end;

registration
  cluster Fanoian (non empty addLoopStr);
end;

definition
  let F be add-associative right_zeroed right_complementable
  commutative associative well-unital almost_left_invertible
  non degenerated distributive (non empty doubleLoopStr);
  redefine attr F is Fanoian means
:: VECTSP_1:def 29

  1.F+1.F<>0.F;
end;

registration
  cluster strict Fanoian Field;
end;

canceled 5;

theorem :: VECTSP_1:84
  for F being add-associative right_zeroed
  right_complementable (non empty addLoopStr), a,b being Element of F holds
  a - b = 0.F implies a = b;

canceled;

theorem :: VECTSP_1:86
  for F being add-associative right_zeroed
  right_complementable (non empty addLoopStr), a being Element of F holds
  -a = 0.F implies a = 0.F;

theorem :: VECTSP_1:87
  for F being add-associative right_zeroed
  right_complementable (non empty addLoopStr), a, b being Element of F holds
  a - b = 0.F implies b - a = 0.F;

theorem :: VECTSP_1:88
  for a, b, c being Element of F holds
  (a <> 0.F & a*c - b = 0.F implies c = b*a") &
  (a <> 0.F & b - c*a = 0.F implies c = b*a");

theorem :: VECTSP_1:89
  for F being add-associative right_zeroed
  right_complementable (non empty addLoopStr), a, b being Element of F holds
  a + b = -(-b + -a);

theorem :: VECTSP_1:90
  for F being add-associative right_zeroed
  right_complementable (non empty addLoopStr),
  a, b, c being Element of F holds (b+a)-(c+a) = b-c;

canceled;

theorem :: VECTSP_1:92
  for G being add-associative right_zeroed right_complementable
  (non empty addLoopStr), v,w being Element of G holds -(-v+w) = -w+v;

theorem :: VECTSP_1:93
  for G being Abelian add-associative (non empty addLoopStr),
  u,v,w being Element of G holds u - v - w = u - w - v;

theorem :: VECTSP_1:94
  for B being AbGroup holds
  multMagma (# the carrier of B, the addF of B #) is commutative Group;

begin :: Addenda

:: from COMPTRIG, 2006.08.12, A.T.

theorem :: VECTSP_1:95
  for L be add-associative right_zeroed right_complementable
  right-distributive unital (non empty doubleLoopStr)
  for n be Element of NAT st n > 0 holds (power L).(0.L,n) = 0.L;

:: 2007.02.14, A.T.

registration
  cluster well-unital (non empty multLoopStr);
end;

registration
  let S be well-unital (non empty multLoopStr);
  identify 1_S with 1.S;
end;

theorem :: VECTSP_1:96
  for L being non empty multLoopStr st L is well-unital holds 1.L = 1_L;

