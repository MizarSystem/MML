:: The Construction and Computation of While-loop Programs for SCMPDS
::  by JingChao Chen
::
:: Received June 14, 2000
:: Copyright (c) 2000 Association of Mizar Users

environ

 vocabulary AMI_3, SCMPDS_2, AMI_1, AMI_2, SCMP_GCD, FUNCT_1, SCMPDS_3,
      RELAT_1, AMI_5, CARD_3, INT_1, SCMPDS_4, SCMFSA_9, CARD_1, SCMFSA6A,
      ARYTM_1, SCMFSA_7, SCMPDS_5, UNIALG_2, SCMFSA7B, FUNCT_4, SCMFSA6B,
      SCM_1, RELOC, FUNCT_7, BOOLE, SCMPDS_8;
 notation XBOOLE_0, SUBSET_1, FUNCT_2, NUMBERS, XCMPLX_0, XREAL_0, RELAT_1,
      FUNCT_1, FUNCT_4, RECDEF_1, INT_1, NAT_1, STRUCT_0, AMI_1, AMI_2, AMI_3,
      AMI_5, FUNCT_7, SCMPDS_2, SCMPDS_3, CARD_1, SCMPDS_4, SCM_1, SCMPDS_5,
      SCMPDS_6, SCMP_GCD, CARD_3, DOMAIN_1;
 constructors DOMAIN_1, NAT_1, AMI_5, RECDEF_1, SCMPDS_4, SCM_1, SCMPDS_5,
      SCMPDS_6, SCMP_GCD, MEMBERED;
 clusters AMI_1, INT_1, FUNCT_1, RELSET_1, SCMPDS_2, SCMFSA_4, SCMPDS_4,
      SCMPDS_5, SCMPDS_6, FRAENKEL, XREAL_0, MEMBERED, NUMBERS, ORDINAL2;
 requirements NUMERALS, REAL, SUBSET, BOOLE, ARITHM;


begin :: Preliminaries

reserve x,a for Int_position,
        s for State of SCMPDS;

theorem :: SCMPDS_8:1     :: see SCMPDS_3:32
 for a be Int_position ex i being Nat
  st a = intpos i;

definition
 let t be State of SCMPDS;
 func Dstate(t) -> State of SCMPDS means
:: SCMPDS_8:def 1
  for x be set holds
    (x in SCM-Data-Loc implies it.x = t.x)
    & ( x in the Instruction-Locations of SCMPDS implies it.x = goto 0) &
    (x=IC SCMPDS implies it.x=inspos 0);
end;


theorem :: SCMPDS_8:2
 for t1,t2 being State of SCMPDS st t1|SCM-Data-Loc=t2|SCM-Data-Loc
 holds Dstate(t1)=Dstate(t2);

theorem :: SCMPDS_8:3
 for t being State of SCMPDS,i being Instruction of SCMPDS
 st InsCode i in {0,4,5,6} holds Dstate(t)=Dstate(Exec(i,t));

theorem :: SCMPDS_8:4
 (Dstate(s)).a=s.a;

theorem :: SCMPDS_8:5
 for a be Int_position holds
 (ex f be Function of product the Object-Kind of SCMPDS,NAT st
     for s being State of SCMPDS holds
 (s.a <= 0 implies f.s =0) & (s.a > 0 implies f.s=s.a));

begin :: The construction and several basic properties of while<0 program
:: while (a,i)<0 do I
definition
 let a be Int_position, i be Integer,I be Program-block;
 func while<0(a,i,I) -> Program-block equals
:: SCMPDS_8:def 2
    (a,i)>=0_goto (card I +2) ';' I ';' goto -(card I+1);
end;


registration
   let I be shiftable Program-block,a be Int_position,i be Integer;
   cluster while<0(a,i,I) -> shiftable;
   correctness
   proof
    set WHL=while<0(a,i,I),
        i1= (a,i)>=0_goto (card I +2),
        i2= goto -(card I+1);
   set PF= Load i1 ';' I;
A1: PF=i1 ';' I by SCMPDS_4:def 4;
    then card PF=card I + 1 by SCMPDS_6:15;
then A2:  card PF+ -(card I+1) =0 by XCMPLX_0:def 6;
       WHL= PF ';' i2 by A1,Def2;
     hence WHL is shiftable by A2,SCMPDS_4:78;
  end;
end;


registration
   let I be No-StopCode Program-block, a be Int_position,i be Integer;
   cluster while<0(a,i,I) -> No-StopCode;
   correctness
   proof
     reconsider i2=goto -(card I+1) as No-StopCode Instruction of SCMPDS;
       while<0(a,i,I) =
     (a,i)>=0_goto (card I +2) ';' I ';' i2 by Def2;
     hence thesis;
   end;
end;


theorem :: SCMPDS_8:6
 for a be Int_position,i be Integer,I be Program-block holds
  card while<0(a,i,I)= card I +2;

theorem :: SCMPDS_8:7
 for a be Int_position,i be Integer,m be Nat,I be Program-block holds
   m < card I+2 iff inspos m in dom while<0(a,i,I);

theorem :: SCMPDS_8:8
 for a be Int_position,i be Integer,I be Program-block holds
    while<0(a,i,I).inspos 0=(a,i)>=0_goto (card I +2) &
    while<0(a,i,I).inspos (card I+1)=goto -(card I+1);

theorem :: SCMPDS_8:9
 for s being State of SCMPDS,I being Program-block,a being Int_position,
 i being Integer st s.DataLoc(s.a,i) >= 0 holds
 while<0(a,i,I) is_closed_on s & while<0(a,i,I) is_halting_on s;

theorem :: SCMPDS_8:10
 for s being State of SCMPDS,I being Program-block,a,c being Int_position,
 i being Integer st s.DataLoc(s.a,i) >= 0 holds
 IExec(while<0(a,i,I),s) = s +* Start-At inspos (card I + 2);

theorem :: SCMPDS_8:11
   for s being State of SCMPDS,I being Program-block,a being Int_position,
 i being Integer st s.DataLoc(s.a,i) >= 0 holds
   IC IExec(while<0(a,i,I),s) = inspos (card I + 2);

theorem :: SCMPDS_8:12
   for s being State of SCMPDS,I being Program-block,a,b being Int_position,
 i being Integer st s.DataLoc(s.a,i) >= 0 holds
   IExec(while<0(a,i,I),s).b = s.b;

scheme :: SCMPDS_8:sch 1
 WhileLHalt { F(State of SCMPDS)-> Nat,
 s() -> State of SCMPDS,I() -> No-StopCode shiftable Program-block,
 a() -> Int_position,i() -> Integer,P[State of SCMPDS]}:
   (F(s())=F(s()) or P[s()]) &
   while<0(a(),i(),I()) is_closed_on s() &
   while<0(a(),i(),I()) is_halting_on s()
provided
 card I() > 0 and
 (for t be State of SCMPDS st P[Dstate t] & F(Dstate(t))=0 holds
    t.DataLoc(s().a(),i()) >= 0) and
 P[Dstate s()] and
 for t be State of SCMPDS st
       P[Dstate t] & t.a()=s().a() & t.DataLoc(s().a(),i()) < 0
    holds IExec(I(),t).a()=t.a() & I() is_closed_on t &
        I() is_halting_on t & F(Dstate IExec(I(),t)) < F(Dstate t) &
        P[Dstate(IExec(I(),t))]
proof
   set b=DataLoc(s().a(),i());
   set WHL=while<0(a(),i(),I()),
       pWHL=stop WHL,
       iWHL=Initialized pWHL,
       pI=stop I(),
       IsI= Initialized pI;
   set i1=(a(),i())>=0_goto (card I()+2),
       i2=goto -(card I()+1);

    defpred Q[Nat] means
       for t be State of SCMPDS st F(Dstate(t)) <= $1 & P[Dstate t] &
       t.a()=s().a()
       holds WHL is_closed_on t & WHL is_halting_on t;
A5:  Q[0]
      proof
        let t be State of SCMPDS;
        assume A6: F(Dstate(t)) <= 0 & P[Dstate t] & t.a()=s().a();
        then F(Dstate(t))=0 by NAT_1:18;
        then t.b >= 0 by A2,A6;
        hence WHL is_closed_on t & WHL is_halting_on t by A6,Th9;
      end;
A7:  for k be Nat st Q[k] holds Q[k + 1]
     proof
     let k be Nat;
     assume A8: Q[k];
        now
        let t be State of SCMPDS;
        assume A9: F(Dstate(t)) <= k+1;
        assume A10: P[Dstate t];
        assume A11: t.a()=s().a();
        per cases;
        suppose t.b >= 0;
          hence WHL is_closed_on t & WHL is_halting_on t by A11,Th9;
        end;
        suppose A12: t.b < 0;
        set t2 = t +* IsI,
            t3 = t +* iWHL,
            C3 = Computation t3,
            t4 = C3.1;
A13:     IExec(I(),t).a()=t.a() & I() is_closed_on t & I() is_halting_on t &
        F(Dstate IExec(I(),t)) < F(Dstate t) &
        P[Dstate(IExec(I(),t))] by A4,A10,A11,A12;
A14:     IsI c= t2 by FUNCT_4:26;
A15:     t2 is halting by A13,SCMPDS_6:def 3;
        then t2 +* IsI is halting by A14,AMI_5:10;
then A16:     I() is_halting_on t2 by SCMPDS_6:def 3;
A17:     I() is_closed_on t2 by A13,SCMPDS_6:38;
A18:     inspos 0 in dom pWHL by SCMPDS_4:75;
A19:     IC t3 =inspos 0 by SCMPDS_6:21;
          WHL = i1 ';' (I() ';' i2) by Lm2;
then A20:     CurInstr t3 = i1 by SCMPDS_6:22;
A21:     (Computation t3).(0 + 1) = Following (Computation t3).0 by AMI_1:def
19
        .= Following t3 by AMI_1:def 19
        .= Exec(i1,t3) by A20,AMI_1:def 18;
A22:     not a() in dom iWHL & a() in dom t by SCMPDS_2:49,SCMPDS_4:31;
A23:     not b in dom iWHL & b in dom t by SCMPDS_2:49,SCMPDS_4:31;
        A24: t3.DataLoc(t3.a(),i())= t3.b by A11,A22,FUNCT_4:12
        .= t.b by A23,FUNCT_4:12;
A25:     IC t4 = t4.IC SCMPDS by AMI_1:def 15
        .= Next IC t3 by A12,A21,A24,SCMPDS_2:69
        .= inspos(0+1) by A19,SCMPDS_4:70;
          t2,t3 equal_outside A by SCMPDS_4:36;
then A26:     t2 | D = t3 | D by SCMPDS_4:24;
          now let a;
          thus t2.a = t3.a by A26,SCMPDS_4:23
          .= t4.a by A21,SCMPDS_2:69;
        end;
then A27:    t2 | D = t4 | D by SCMPDS_4:23;

        set m2=LifeSpan t2,
            t5=(Computation t4).m2,
            l1=inspos (card I() + 1);

A28:     IExec(I(),t) = Result t2 +* t | A by SCMPDS_4:def 8;
      dom (t | A) = A by SCMPDS_6:1;
then A29:     not a() in dom (t | A) by SCMPDS_2:53;
          card I() + 1 < card I() + 2 by REAL_1:53;
then A30:     l1 in dom WHL by Th7;
A31:     WHL c= iWHL by SCMPDS_6:17;
          iWHL c= t3 by FUNCT_4:26;
then A32:     WHL c= t3 by A31,XBOOLE_1:1;
          Shift(I(),1) c= WHL by Lm3;
        then Shift(I(),1) c= t3 by A32,XBOOLE_1:1;
then A33:     Shift(I(),1) c= t4 by AMI_3:38;
then A34:     (Computation t2).m2 | D = t5 | D by A1,A14,A16,A17,A25,A27,
SCMPDS_7:36;
then A35:     t5.a()=(Computation t2).m2.a() by SCMPDS_4:23
        .=(Result t2).a() by A15,SCMFSA6B:16
        .=s().a() by A11,A13,A28,A29,FUNCT_4:12;
        A36: dom (t | A) = A by SCMPDS_6:1;
A37:     t5|D =(Result t2)|D by A15,A34,SCMFSA6B:16
        .= (Result t2 +* t | A)|D by A36,AMI_5:7,SCMPDS_2:10
        .=IExec(I(),t)|D by SCMPDS_4:def 8;

        set m3=m2 +1;
        set t6=(Computation t3).m3;
A38:     IC t5=l1 by A1,A14,A16,A17,A25,A27,A33,SCMPDS_7:36;
A39:     t6=t5 by AMI_1:51;
then A40:     CurInstr t6=t5.l1 by A38,AMI_1:def 17
        .=t4.l1 by AMI_1:54
        .=t3.l1 by AMI_1:54
        .=WHL.l1 by A30,A32,GRFUNC_1:8
        .=i2 by Th8;
        set t7=(Computation t3).(m3+ 1);
A41:     t7 = Following t6 by AMI_1:def 19
        .= Exec(i2,t6) by A40,AMI_1:def 18;
A42:    IC t7=t7.IC SCMPDS by AMI_1:def 15
       .=ICplusConst(t6,-(card I()+1)) by A41,SCMPDS_2:66
       .=ICplusConst(t6,0-(card I()+1)) by XCMPLX_1:150
       .=inspos 0 by A38,A39,SCMPDS_7:1;
A43:    t7.a()=t6.a() by A41,SCMPDS_2:66
       .=s().a() by A35,AMI_1:51;

         InsCode i2=0 by SCMPDS_2:21;
       then InsCode i2 in {0,4,5,6} by ENUMSET1:19;
then A44:    Dstate(t7)=Dstate(t6) by A41,Th3
       .=Dstate(IExec(I(),t)) by A37,A39,Th2;
        now
         assume A45:F(Dstate(t7)) > k;
           F(Dstate(IExec(I(),t))) < F(Dstate(t)) by A4,A10,A11,A12;
    then F(Dstate(t7)) < k+1 by A9,A44,AXIOMS:22;
         hence contradiction by A45,INT_1:20;
       end;
then A46:    WHL is_closed_on t7 & WHL is_halting_on t7 by A8,A13,A43,A44;
A47:    t7 +* iWHL=t7 by A42,SCMPDS_7:37;
         now
          let k be Nat;
          per cases;
          suppose k < m3+1;
           then A48: k <= m3 by INT_1:20;
           hereby
              per cases by A48,NAT_1:26;
              suppose A49:k <= m2;
               hereby
               per cases;
                 suppose k=0;
                 hence IC (Computation t3).k in dom pWHL by A18,A19,AMI_1:def
19;
                 end;
                 suppose k<>0;
                  then consider kn be Nat such that
              A50: k=kn+1 by NAT_1:22;
                    kn < k by A50,REAL_1:69;
                  then kn < m2 by A49,AXIOMS:22;
              then A51: IC (Computation t2).kn + 1 = IC (Computation t4).kn
                  by A1,A14,A16,A17,A25,A27,A33,SCMPDS_7:34;
              A52: IC (Computation t2).kn in dom pI by A13,SCMPDS_6:def 2;
                  consider lm be Nat such that
              A53: IC (Computation t2).kn=inspos lm by SCMPDS_3:32;
                    lm < card pI by A52,A53,SCMPDS_4:1;
                  then lm < card I()+1 by SCMPDS_5:7;
              then A54: lm+1 <= card I() +1 by INT_1:20;
                    card I() + 1 < card I() + 3 by REAL_1:53;
                  then lm+1 < card I() +3 by A54,AXIOMS:22;
                  then A55: lm+1 < card pWHL by Lm1;
                    IC (Computation t3).k=inspos lm +1 by A50,A51,A53,AMI_1:51
                  .=inspos (lm+1) by SCMPDS_3:def 3;
                  hence IC (Computation t3).k in dom pWHL by A55,SCMPDS_4:1;
               end;
               end;
              end;
              suppose A56:k=m3;
                 l1 in dom pWHL by A30,SCMPDS_6:18;
               hence IC (Computation t3).k in dom pWHL by A1,A14,A16,A17,A25,
A27,A33,A39,A56,SCMPDS_7:36;
            end;
            end;
          end;
          suppose k >= m3+1;
          then consider nn be Nat such that
         A57: k=m3+1+nn by NAT_1:28;
               C3.k=(Computation (t7 +* iWHL)).nn by A47,A57,AMI_1:51;
           hence IC (Computation t3).k in dom pWHL by A46,SCMPDS_6:def 2;
       end;
       end;
       hence WHL is_closed_on t by SCMPDS_6:def 2;
         t7 is halting by A46,A47,SCMPDS_6:def 3;
       then t3 is halting by SCM_1:27;
       hence WHL is_halting_on t by SCMPDS_6:def 3;
     end;
     end;
     hence Q[k+1];
     end;
A58:  for k being Nat holds Q[k] from NAT_1:sch 1(A5,A7);
     set n=F(Dstate s());
     A59: Q[n] by A58;
     thus F(s())=F(s()) or P[s()];
     thus WHL is_closed_on s() & WHL is_halting_on s() by A3,A59;
end;

scheme :: SCMPDS_8:sch 2
 WhileLExec { F(State of SCMPDS)-> Nat,
 s() -> State of SCMPDS,I() -> No-StopCode shiftable Program-block,
 a() -> Int_position,i() -> Integer,P[State of SCMPDS]}:
   (F(s())=F(s()) or P[s()]) &
   IExec(while<0(a(),i(),I()),s()) =
    IExec(while<0(a(),i(),I()),IExec(I(),s()))
provided
 card I() > 0 and
 s().DataLoc(s().a(),i()) < 0 and
 (for t be State of SCMPDS st P[Dstate t] & F(Dstate(t))=0 holds
    t.DataLoc(s().a(),i()) >= 0) and
 P[Dstate s()] and
 for t be State of SCMPDS st
       P[Dstate t] & t.a()=s().a() & t.DataLoc(s().a(),i()) < 0
    holds IExec(I(),t).a()=t.a() & I() is_closed_on t &
        I() is_halting_on t & F(Dstate IExec(I(),t)) < F(Dstate t) &
        P[Dstate(IExec(I(),t))]
proof
   set b=DataLoc(s().a(),i());
   set WHL=while<0(a(),i(),I()),
       iWHL=Initialized stop WHL,
       iI= Initialized stop I(),
       s1= s() +* iWHL,
       C1=Computation s1,
       ps= s() | A;
   set i1=(a(),i())>=0_goto (card I()+2),
       i2=goto -(card I()+1);
   deffunc U(State of SCMPDS) = F($1);
   defpred X[State of SCMPDS] means P[$1];
A6: (for t be State of SCMPDS st X[Dstate t] & U(Dstate(t))=0 holds
    t.DataLoc(s().a(),i()) >= 0) by A3;
A7: X[Dstate s()] by A4;
A8: for t be State of SCMPDS st
       X[Dstate t] & t.a()=s().a() & t.DataLoc(s().a(),i()) < 0
    holds IExec(I(),t).a()=t.a() & I() is_closed_on t &
        I() is_halting_on t & U(Dstate IExec(I(),t)) < U(Dstate t) &
        X[Dstate(IExec(I(),t))] by A5;

      (U(s())=U(s()) or X[s()]) & WHL is_closed_on s() &
    WHL is_halting_on s() from WhileLHalt(A1,A6,A7,A8);
then A9: s1 is halting by SCMPDS_6:def 3;
    set sI= s() +* iI,
       m1=LifeSpan sI+2,
       s2=IExec(I(),s()) +* iWHL,
       C2=Computation s2,
       m2=LifeSpan s2;
       set Es=IExec(I(),s()),
           bj=DataLoc(Es.a(),i());
A10: I() is_closed_on s() & I() is_halting_on s() by A2,A7,A8;
A11: IExec(I(), s()).a()=s().a() by A2,A7,A8;
then
A12: for t be State of SCMPDS st P[Dstate(t)] & F(Dstate(t))=0 holds
    t.bj >= 0 by A6;
A13: P[Dstate Es] by A2,A7,A8;
A14: for t being State of SCMPDS st P[Dstate t] & t.a()=Es.a() & t.bj < 0
      holds IExec(I(),t).a()=t.a() & I() is_closed_on t &
          I() is_halting_on t & F(Dstate IExec(I(),t)) < F(Dstate t)
          & P[Dstate(IExec(I(),t))] by A8,A11;
   deffunc U(State of SCMPDS) = F($1);
   defpred X[State of SCMPDS] means P[$1];
 A15: for t be State of SCMPDS st X[Dstate(t)] & U(Dstate(t))=0 holds
    t.bj >= 0 by A12;
A16: X[Dstate Es] by A13;
A17: for t being State of SCMPDS st X[Dstate t] & t.a()=Es.a() & t.bj < 0
      holds IExec(I(),t).a()=t.a() & I() is_closed_on t &
          I() is_halting_on t & U(Dstate IExec(I(),t)) < U(Dstate t)
          & X[Dstate(IExec(I(),t))] by A14;

A18:  (U(Es)=U(Es) or X[Es]) & WHL is_closed_on Es &
     WHL is_halting_on Es from WhileLHalt(A1,A15,A16,A17);
   set s4 = C1.1;
A19:   sI is halting by A10,SCMPDS_6:def 3;
A20:   iI c= sI by FUNCT_4:26;
      then sI +* iI is halting by A19,AMI_5:10;
then A21:   I() is_halting_on sI by SCMPDS_6:def 3;
A22:   I() is_closed_on sI by A10,SCMPDS_6:38;
A23:   WHL = i1 ';' (I() ';' i2) by Lm2;
then A24:  CurInstr s1 = i1 by SCMPDS_6:22;
A25:  IC s1 =inspos 0 by SCMPDS_6:21;
A26:  (Computation s1).(0 + 1) = Following (Computation s1).0 by AMI_1:def 19
     .= Following s1 by AMI_1:def 19
     .= Exec(i1,s1) by A24,AMI_1:def 18;
     A27: s1.DataLoc(s1.a(),i())=s1.b by SCMPDS_5:19
     .= s().b by SCMPDS_5:19;
A28:  IC s4 = s4.IC SCMPDS by AMI_1:def 15
     .= Next IC s1 by A2,A26,A27,SCMPDS_2:69
     .= inspos(0+1) by A25,SCMPDS_4:70;
       sI,s1 equal_outside A by SCMPDS_4:36;
then A29:  sI | D = s1 | D by SCMPDS_4:24;
       now let a;
         thus sI.a = s1.a by A29,SCMPDS_4:23
          .= s4.a by A26,SCMPDS_2:69;
     end;
then A30:  sI | D = s4 | D by SCMPDS_4:23;

     set mI=LifeSpan sI,
         s5=(Computation s4).mI,
         l1=inspos (card I() + 1);

A31:    IExec(I(),s()) = Result sI +* s() | A by SCMPDS_4:def 8;
A32:    dom (s() | A) = A by SCMPDS_6:1;
         card I() + 1 < card I() + 2 by REAL_1:53;
then A33:    l1 in dom WHL by Th7;
A34:    WHL c= iWHL by SCMPDS_6:17;
         iWHL c= s1 by FUNCT_4:26;
then A35:    WHL c= s1 by A34,XBOOLE_1:1;
         Shift(I(),1) c= WHL by Lm3;
       then Shift(I(),1) c= s1 by A35,XBOOLE_1:1;
then A36:    Shift(I(),1) c= s4 by AMI_3:38;
then A37:    (Computation sI).mI | D = s5 | D
       by A1,A20,A21,A22,A28,A30,SCMPDS_7:36;
        set m3=mI +1;
        set s6=(Computation s1).m3;
A38:     IC s5=l1 by A1,A20,A21,A22,A28,A30,A36,SCMPDS_7:36;
A39:     s6=s5 by AMI_1:51;
then A40:     CurInstr s6=s5.l1 by A38,AMI_1:def 17
        .=s4.l1 by AMI_1:54
        .=s1.l1 by AMI_1:54
        .=WHL.l1 by A33,A35,GRFUNC_1:8
        .=i2 by Th8;
        set s7=(Computation s1).(m3+ 1);
A41:     s7 = Following s6 by AMI_1:def 19
        .= Exec(i2,s6) by A40,AMI_1:def 18;
A42:    IC s7=s7.IC SCMPDS by AMI_1:def 15
       .=ICplusConst(s6,-(card I()+1)) by A41,SCMPDS_2:66
       .=ICplusConst(s6,0-(card I()+1)) by XCMPLX_1:150
       .=inspos 0 by A38,A39,SCMPDS_7:1;
       A43: m3+1=mI+(1+1) by XCMPLX_1:1
       .=mI+2;
         now
          let x be Int_position;
  A44:     not x in dom iWHL & x in dom IExec(I(),s())
          by SCMPDS_2:49,SCMPDS_4:31;
  A45:     not x in dom (s() | A) by A32,SCMPDS_2:53;
        s5.x=(Computation sI).mI.x by A37,SCMPDS_4:23
         .=(Result sI).x by A19,SCMFSA6B:16
         .=IExec(I(),s()).x by A31,A45,FUNCT_4:12;
       hence s7.x=IExec(I(),s()).x by A39,A41,SCMPDS_2:66
         .=s2.x by A44,FUNCT_4:12;
     end;
     then A46: s7 | D = s2 | D by SCMPDS_4:23;
A47:  IC s2 =IC C1.m1 by A42,A43,SCMPDS_6:21;
A48: s2 is halting by A18,SCMPDS_6:def 3;
A49: dom ps = dom s() /\ A by RELAT_1:90
    .= ({IC SCMPDS} \/ D \/ A) /\ A by SCMPDS_4:19
    .= A by XBOOLE_1:21;
      s2 | A= (Result sI +* ps +* iWHL) | A by SCMPDS_4:def 8
    .=(Result sI +* ps)|A +* iWHL | A by AMI_5:6
    .= ps +* iWHL | A by A49,FUNCT_4:24
    .= s1 | A by AMI_5:6
    .= C1.m1 | A by SCMPDS_7:6;
then A50: C1.m1=s2 by A43,A46,A47,SCMPDS_7:7;
    then CurInstr C1.m1=i1 by A23,SCMPDS_6:22;
then A51: CurInstr C1.m1 <> halt SCMPDS by SCMPDS_6:31;
    set m0=LifeSpan s1;
      m0 > m1 by A9,A51,SCMPDS_6:2;
    then consider nn be Nat such that
A52: m0=m1+nn by NAT_1:28;
A53: C1.m0 = C2.nn by A50,A52,AMI_1:51;
    then CurInstr C2.nn =halt SCMPDS by A9,SCM_1:def 2;
then A54: nn >= m2 by A48,SCM_1:def 2;
      C1.(m1 + m2) = C2.m2 by A50,AMI_1:51;
    then CurInstr C1.(m1 + m2) = halt SCMPDS by A48,SCM_1:def 2;
    then m1 + m2 >= m0 by A9,SCM_1:def 2;
    then m2 >= nn by A52,REAL_1:53;
then nn=m2 by A54,AXIOMS:21;
then A55: Result s1 = C2.m2 by A9,A53,SCMFSA6B:16;
A56: IExec(I(),s()) | A= (Result sI +* ps) | A by SCMPDS_4:def 8
    .= ps by A49,FUNCT_4:24;
    thus F(s())=F(s()) or P[s()];
    thus IExec(WHL,s())
      = C2.m2 +* ps by A55,SCMPDS_4:def 8
     .= Result s2 +* IExec(I(),s()) | A by A48,A56,SCMFSA6B:16
     .= IExec(WHL,IExec(I(),s())) by SCMPDS_4:def 8;
end;

theorem :: SCMPDS_8:13
   for s being State of SCMPDS,I being No-StopCode shiftable Program-block,
 a be Int_position, i be Integer,X be set, f being Function of
 product the Object-Kind of SCMPDS,NAT st card I > 0 &
 ( for t be State of SCMPDS st f.Dstate(t)=0 holds t.DataLoc(s.a,i) >= 0 ) &
 (for t be State of SCMPDS st
    (for x be Int_position st x in X holds t.x=s.x) &
    t.a=s.a & t.DataLoc(s.a,i) < 0
   holds IExec(I,t).a=t.a & f.Dstate(IExec(I,t)) < f.Dstate(t) &
    I is_closed_on t & I is_halting_on t &
     for x be Int_position st x in X holds IExec(I,t).x=t.x)
 holds
     while<0(a,i,I) is_closed_on s & while<0(a,i,I) is_halting_on s;

theorem :: SCMPDS_8:14
   for s being State of SCMPDS,I being No-StopCode shiftable Program-block,
 a be Int_position, i be Integer,X be set,f being Function of product the
 Object-Kind of SCMPDS,NAT st card I > 0 & s.DataLoc(s.a,i) < 0 &
 (for t be State of SCMPDS st f.Dstate(t)=0 holds t.DataLoc(s.a,i) >= 0 ) &
 (for t be State of SCMPDS st
    (for x be Int_position st x in X holds t.x=s.x) &
    t.a=s.a & t.DataLoc(s.a,i) < 0
   holds IExec(I,t).a=t.a & I is_closed_on t & I is_halting_on t &
    f.Dstate(IExec(I,t)) < f.Dstate(t) &
    for x be Int_position st x in X holds IExec(I,t).x=t.x)
 holds
    IExec(while<0(a,i,I),s) =IExec(while<0(a,i,I),IExec(I,s));

theorem :: SCMPDS_8:15
 for s being State of SCMPDS,I being No-StopCode shiftable Program-block,
 a be Int_position, i be Integer,X be set st card I > 0 &
 (for t be State of SCMPDS st
   (for x be Int_position st x in X holds t.x=s.x) &
   t.a=s.a & t.DataLoc(s.a,i) < 0
 holds IExec(I,t).a=t.a & IExec(I,t).DataLoc(s.a,i) > t.DataLoc(s.a,i) &
   I is_closed_on t & I is_halting_on t &
  for x be Int_position st x in X holds IExec(I,t).x=t.x)
 holds
     while<0(a,i,I) is_closed_on s & while<0(a,i,I) is_halting_on s;

theorem :: SCMPDS_8:16
   for s being State of SCMPDS,I being No-StopCode shiftable Program-block,
 a be Int_position,i be Integer,X be set st
  s.DataLoc(s.a,i) < 0 & card I > 0 &
  (for t be State of SCMPDS st
    (for x be Int_position st x in X holds t.x=s.x) &
    t.a=s.a & t.DataLoc(s.a,i) < 0
   holds IExec(I,t).a=t.a & IExec(I,t).DataLoc(s.a,i) > t.DataLoc(s.a,i) &
    I is_closed_on t & I is_halting_on t &
    for x be Int_position st x in X holds IExec(I,t).x=t.x)
 holds
   IExec(while<0(a,i,I),s) =IExec(while<0(a,i,I),IExec(I,s));

begin :: The construction and basic properties of while>0 program
:: while (a,i)>0 do I
definition
 let a be Int_position, i be Integer,I be Program-block;
 func while>0(a,i,I) -> Program-block equals
:: SCMPDS_8:def 3
   (a,i)<=0_goto (card I +2) ';' I ';' goto -(card I+1);
end;


registration
   let I be shiftable Program-block,a be Int_position,i be Integer;
   cluster while>0(a,i,I) -> shiftable;
   correctness
   proof
    set WHL=while>0(a,i,I),
        i1= (a,i)<=0_goto (card I +2),
        i2= goto -(card I+1);
   reconsider PF= Load i1 ';' I as shiftable Program-block;
A1: PF=i1 ';' I by SCMPDS_4:def 4;
    then card PF=card I + 1 by SCMPDS_6:15;
then A2:  card PF+ -(card I+1) =0 by XCMPLX_0:def 6;
       WHL= PF ';' i2 by A1,Def3;
     hence WHL is shiftable by A2,SCMPDS_4:78;
  end;
end;


registration
   let I be No-StopCode Program-block,a be Int_position,i be Integer;
   cluster while>0(a,i,I) -> No-StopCode;
   correctness
   proof
     reconsider i2=goto -(card I+1) as No-StopCode Instruction of SCMPDS;
       while>0(a,i,I) =
     (a,i)<=0_goto (card I +2) ';' I ';' i2 by Def3;
     hence thesis;
   end;
end;


theorem :: SCMPDS_8:17
 for a be Int_position,i be Integer,I be Program-block holds
  card while>0(a,i,I)= card I +2;

theorem :: SCMPDS_8:18
 for a be Int_position,i be Integer,m be Nat,I be Program-block holds
   m < card I+2 iff inspos m in dom while>0(a,i,I);

theorem :: SCMPDS_8:19
 for a be Int_position,i be Integer,I be Program-block holds
    while>0(a,i,I).inspos 0=(a,i)<=0_goto (card I +2) &
    while>0(a,i,I).inspos (card I+1)=goto -(card I+1);

theorem :: SCMPDS_8:20
 for s being State of SCMPDS,I being Program-block,a being Int_position,
 i being Integer st s.DataLoc(s.a,i) <= 0 holds
 while>0(a,i,I) is_closed_on s & while>0(a,i,I) is_halting_on s;

theorem :: SCMPDS_8:21
 for s being State of SCMPDS,I being Program-block,a,c being Int_position,
 i being Integer st s.DataLoc(s.a,i) <= 0 holds
 IExec(while>0(a,i,I),s) = s +* Start-At inspos (card I + 2);

theorem :: SCMPDS_8:22
   for s being State of SCMPDS,I being Program-block,a being Int_position,
 i being Integer st s.DataLoc(s.a,i) <= 0 holds
    IC IExec(while>0(a,i,I),s) = inspos (card I + 2);

theorem :: SCMPDS_8:23
   for s being State of SCMPDS,I being Program-block,a,b being Int_position,
 i being Integer st s.DataLoc(s.a,i) <= 0 holds
   IExec(while>0(a,i,I),s).b = s.b;

scheme :: SCMPDS_8:sch 3
 WhileGHalt { F(State of SCMPDS)-> Nat,
 s() -> State of SCMPDS,I() -> No-StopCode shiftable Program-block,
 a() -> Int_position,i() -> Integer,P[State of SCMPDS]}:
   (F(s())=F(s()) or P[s()]) &
   while>0(a(),i(),I()) is_closed_on s() &
   while>0(a(),i(),I()) is_halting_on s()
provided
 card I() > 0 and
 (for t be State of SCMPDS st P[Dstate t] & F(Dstate(t))=0 holds
    t.DataLoc(s().a(),i()) <= 0) and
 P[Dstate s()] and
 for t be State of SCMPDS st
       P[Dstate t] & t.a()=s().a() & t.DataLoc(s().a(),i()) > 0
    holds IExec(I(),t).a()=t.a() & I() is_closed_on t &
        I() is_halting_on t & F(Dstate IExec(I(),t)) < F(Dstate t) &
        P[Dstate(IExec(I(),t))]
proof
   set b=DataLoc(s().a(),i());
   set WHL=while>0(a(),i(),I()),
       pWHL=stop WHL,
       iWHL=Initialized pWHL,
       pI=stop I(),
       IsI= Initialized pI;
   set i1=(a(),i())<=0_goto (card I()+2),
       i2=goto -(card I()+1);
    defpred Q[Nat] means
       for t be State of SCMPDS st F(Dstate(t)) <= $1 & P[Dstate t] &
       t.a()=s().a()
       holds WHL is_closed_on t & WHL is_halting_on t;
A5:  Q[0]
      proof
        let t be State of SCMPDS;
        assume A6: F(Dstate(t)) <= 0 & P[Dstate t] & t.a()=s().a();
        then F(Dstate(t))=0 by NAT_1:18;
        then t.b <= 0 by A2,A6;
        hence WHL is_closed_on t & WHL is_halting_on t by A6,Th20;
      end;
A7:  for k be Nat st Q[k] holds Q[k + 1]
     proof
     let k be Nat;
     assume A8: Q[k];
        now
        let t be State of SCMPDS;
        assume A9: F(Dstate(t)) <= k+1;
        assume A10: P[Dstate t];
        assume A11: t.a()=s().a();
        per cases;
        suppose t.b <= 0;
          hence WHL is_closed_on t & WHL is_halting_on t by A11,Th20;
        end;
        suppose A12: t.b > 0;
        set t2 = t +* IsI,
            t3 = t +* iWHL,
            C3 = Computation t3,
            t4 = C3.1;
A13:     IExec(I(),t).a()=t.a() & I() is_closed_on t & I() is_halting_on t &
        F(Dstate IExec(I(),t)) < F(Dstate t) &
        P[Dstate(IExec(I(),t))] by A4,A10,A11,A12;
A14:     IsI c= t2 by FUNCT_4:26;
A15:     t2 is halting by A13,SCMPDS_6:def 3;
        then t2 +* IsI is halting by A14,AMI_5:10;
then A16:     I() is_halting_on t2 by SCMPDS_6:def 3;
A17:     I() is_closed_on t2 by A13,SCMPDS_6:38;
A18:     inspos 0 in dom pWHL by SCMPDS_4:75;
A19:     IC t3 =inspos 0 by SCMPDS_6:21;
          WHL = i1 ';' (I() ';' i2) by Lm5;
then A20:     CurInstr t3 = i1 by SCMPDS_6:22;
A21:     (Computation t3).(0 + 1) = Following (Computation t3).0 by AMI_1:def
19
        .= Following t3 by AMI_1:def 19
        .= Exec(i1,t3) by A20,AMI_1:def 18;
A22:     not a() in dom iWHL & a() in dom t by SCMPDS_2:49,SCMPDS_4:31;
A23:     not b in dom iWHL & b in dom t by SCMPDS_2:49,SCMPDS_4:31;
        A24: t3.DataLoc(t3.a(),i())= t3.b by A11,A22,FUNCT_4:12
        .= t.b by A23,FUNCT_4:12;
A25:     IC t4 = t4.IC SCMPDS by AMI_1:def 15
        .= Next IC t3 by A12,A21,A24,SCMPDS_2:68
        .= inspos(0+1) by A19,SCMPDS_4:70;
          t2,t3 equal_outside A by SCMPDS_4:36;
then A26:     t2 | D = t3 | D by SCMPDS_4:24;
          now let a;
          thus t2.a = t3.a by A26,SCMPDS_4:23
          .= t4.a by A21,SCMPDS_2:68;
        end;
then A27:    t2 | D = t4 | D by SCMPDS_4:23;

        set m2=LifeSpan t2,
            t5=(Computation t4).m2,
            l1=inspos (card I() + 1);

A28:     IExec(I(),t) = Result t2 +* t | A by SCMPDS_4:def 8;
      dom (t | A) = A by SCMPDS_6:1;
then A29:     not a() in dom (t | A) by SCMPDS_2:53;
          card I() + 1 < card I() + 2 by REAL_1:53;
then A30:     l1 in dom WHL by Th18;
A31:     WHL c= iWHL by SCMPDS_6:17;
          iWHL c= t3 by FUNCT_4:26;
then A32:     WHL c= t3 by A31,XBOOLE_1:1;
          Shift(I(),1) c= WHL by Lm6;
        then Shift(I(),1) c= t3 by A32,XBOOLE_1:1;
then A33:     Shift(I(),1) c= t4 by AMI_3:38;
then A34:     (Computation t2).m2 | D = t5 | D by A1,A14,A16,A17,A25,A27,
SCMPDS_7:36;
then A35:     t5.a()=(Computation t2).m2.a() by SCMPDS_4:23
        .=(Result t2).a() by A15,SCMFSA6B:16
        .=s().a() by A11,A13,A28,A29,FUNCT_4:12;
        A36: dom (t | A) = A by SCMPDS_6:1;
A37:     t5|D =(Result t2)|D by A15,A34,SCMFSA6B:16
        .= (Result t2 +* t | A)|D by A36,AMI_5:7,SCMPDS_2:10
        .=IExec(I(),t)|D by SCMPDS_4:def 8;

        set m3=m2 +1;
        set t6=(Computation t3).m3;
A38:     IC t5=l1 by A1,A14,A16,A17,A25,A27,A33,SCMPDS_7:36;
A39:     t6=t5 by AMI_1:51;
then A40:     CurInstr t6=t5.l1 by A38,AMI_1:def 17
        .=t4.l1 by AMI_1:54
        .=t3.l1 by AMI_1:54
        .=WHL.l1 by A30,A32,GRFUNC_1:8
        .=i2 by Th19;
        set t7=(Computation t3).(m3+ 1);
A41:     t7 = Following t6 by AMI_1:def 19
        .= Exec(i2,t6) by A40,AMI_1:def 18;
A42:    IC t7=t7.IC SCMPDS by AMI_1:def 15
       .=ICplusConst(t6,-(card I()+1)) by A41,SCMPDS_2:66
       .=ICplusConst(t6,0-(card I()+1)) by XCMPLX_1:150
       .=inspos 0 by A38,A39,SCMPDS_7:1;
A43:    t7.a()=t6.a() by A41,SCMPDS_2:66
       .=s().a() by A35,AMI_1:51;

         InsCode i2=0 by SCMPDS_2:21;
       then InsCode i2 in {0,4,5,6} by ENUMSET1:19;
then A44:    Dstate(t7)=Dstate(t6) by A41,Th3
       .=Dstate(IExec(I(),t)) by A37,A39,Th2;
        now
         assume A45:F(Dstate(t7)) > k;
           F(Dstate(IExec(I(),t))) < F(Dstate(t)) by A4,A10,A11,A12;
    then F(Dstate(t7)) < k+1 by A9,A44,AXIOMS:22;
         hence contradiction by A45,INT_1:20;
       end;
then A46:    WHL is_closed_on t7 & WHL is_halting_on t7 by A8,A13,A43,A44;
A47:    t7 +* iWHL=t7 by A42,SCMPDS_7:37;
         now
          let k be Nat;
          per cases;
          suppose k < m3+1;
           then A48: k <= m3 by INT_1:20;
           hereby
              per cases by A48,NAT_1:26;
              suppose A49:k <= m2;
               hereby
               per cases;
                 suppose k=0;
                 hence IC (Computation t3).k in dom pWHL by A18,A19,AMI_1:def
19;
                 end;
                 suppose k<>0;
                  then consider kn be Nat such that
              A50: k=kn+1 by NAT_1:22;
                    kn < k by A50,REAL_1:69;
                  then kn < m2 by A49,AXIOMS:22;
              then A51: IC (Computation t2).kn + 1 = IC (Computation t4).kn
                  by A1,A14,A16,A17,A25,A27,A33,SCMPDS_7:34;
              A52: IC (Computation t2).kn in dom pI by A13,SCMPDS_6:def 2;
                  consider lm be Nat such that
              A53: IC (Computation t2).kn=inspos lm by SCMPDS_3:32;
                    lm < card pI by A52,A53,SCMPDS_4:1;
                  then lm < card I()+1 by SCMPDS_5:7;
              then A54: lm+1 <= card I() +1 by INT_1:20;
                    card I() + 1 < card I() + 3 by REAL_1:53;
                  then lm+1 < card I() +3 by A54,AXIOMS:22;
                  then A55: lm+1 < card pWHL by Lm4;
                    IC (Computation t3).k=inspos lm +1 by A50,A51,A53,AMI_1:51
                  .=inspos (lm+1) by SCMPDS_3:def 3;
                  hence IC (Computation t3).k in dom pWHL by A55,SCMPDS_4:1;
               end;
               end;
              end;
              suppose A56:k=m3;
                 l1 in dom pWHL by A30,SCMPDS_6:18;
               hence IC (Computation t3).k in dom pWHL by A1,A14,A16,A17,A25,
A27,A33,A39,A56,SCMPDS_7:36;
            end;
            end;
          end;
          suppose k >= m3+1;
          then consider nn be Nat such that
         A57: k=m3+1+nn by NAT_1:28;
               C3.k=(Computation (t7 +* iWHL)).nn by A47,A57,AMI_1:51;
           hence IC (Computation t3).k in dom pWHL by A46,SCMPDS_6:def 2;
       end;
       end;
       hence WHL is_closed_on t by SCMPDS_6:def 2;
         t7 is halting by A46,A47,SCMPDS_6:def 3;
       then t3 is halting by SCM_1:27;
       hence WHL is_halting_on t by SCMPDS_6:def 3;
     end;
     end;
     hence Q[k+1];
     end;
A58:  for k being Nat holds Q[k] from NAT_1:sch 1(A5,A7);
     set n=F(Dstate s());
     A59: Q[n] by A58;
     thus F(s())=F(s()) or P[s()];
     thus WHL is_closed_on s() & WHL is_halting_on s() by A3,A59;
end;

scheme :: SCMPDS_8:sch 4
 WhileGExec { F(State of SCMPDS)-> Nat,
 s() -> State of SCMPDS,I() -> No-StopCode shiftable Program-block,
 a() -> Int_position,i() -> Integer,P[State of SCMPDS]}:
   (F(s())=F(s()) or P[s()]) &
   IExec(while>0(a(),i(),I()),s()) =
    IExec(while>0(a(),i(),I()),IExec(I(),s()))
provided
 card I() > 0 and
 s().DataLoc(s().a(),i()) > 0 and
 (for t be State of SCMPDS st P[Dstate t] & F(Dstate(t))=0 holds
    t.DataLoc(s().a(),i()) <= 0) and
 P[Dstate s()] and
 for t be State of SCMPDS st
       P[Dstate t] & t.a()=s().a() & t.DataLoc(s().a(),i()) > 0
    holds IExec(I(),t).a()=t.a() & I() is_closed_on t &
        I() is_halting_on t & F(Dstate IExec(I(),t)) < F(Dstate t) &
        P[Dstate(IExec(I(),t))]
proof
   set b=DataLoc(s().a(),i());
   set WHL=while>0(a(),i(),I()),
       iWHL=Initialized stop WHL,
       iI= Initialized stop I(),
       s1= s() +* iWHL,
       C1=Computation s1,
       ps= s() | A;
   set i1=(a(),i())<=0_goto (card I()+2),
       i2=goto -(card I()+1);
   deffunc U(State of SCMPDS) = F($1);
   defpred X[State of SCMPDS] means P[$1];
A6: (for t be State of SCMPDS st X[Dstate t] & U(Dstate(t))=0 holds
    t.DataLoc(s().a(),i()) <= 0) by A3;
A7: X[Dstate s()] by A4;
A8: for t be State of SCMPDS st
       X[Dstate t] & t.a()=s().a() & t.DataLoc(s().a(),i()) > 0
    holds IExec(I(),t).a()=t.a() & I() is_closed_on t &
        I() is_halting_on t & U(Dstate IExec(I(),t)) < U(Dstate t) &
        X[Dstate(IExec(I(),t))] by A5;

      (U(s())=U(s()) or X[s()]) & WHL is_closed_on s() &
    WHL is_halting_on s() from WhileGHalt(A1,A6,A7,A8);
then A9: s1 is halting by SCMPDS_6:def 3;
    set sI= s() +* iI,
       m1=LifeSpan sI+2,
       s2=IExec(I(),s()) +* iWHL,
       C2=Computation s2,
       m2=LifeSpan s2;
       set Es=IExec(I(),s()),
           bj=DataLoc(Es.a(),i());
A10: I() is_closed_on s() & I() is_halting_on s() by A2,A7,A8;
A11: IExec(I(), s()).a()=s().a() by A2,A7,A8;
then
 A12: for t be State of SCMPDS st P[Dstate t] & F(Dstate(t))=0
    holds t.bj <= 0 by A6;
A13: P[Dstate Es] by A2,A7,A8;
A14: for t be State of SCMPDS st
      P[Dstate t] & t.a()=Es.a() & t.bj > 0 holds
      IExec(I(),t).a()=t.a() & I() is_closed_on t &
          I() is_halting_on t & F(Dstate IExec(I(),t)) < F(Dstate t)
          & P[Dstate(IExec(I(),t))] by A8,A11;
   deffunc U(State of SCMPDS) = F($1);
   defpred X[State of SCMPDS] means P[$1];
 A15: for t be State of SCMPDS st X[Dstate t] & U(Dstate(t))=0
    holds t.bj <= 0 by A12;
A16: X[Dstate Es] by A13;
A17: for t be State of SCMPDS st
      X[Dstate t] & t.a()=Es.a() & t.bj > 0 holds
      IExec(I(),t).a()=t.a() & I() is_closed_on t &
          I() is_halting_on t & U(Dstate IExec(I(),t)) < U(Dstate t)
          & X[Dstate(IExec(I(),t))] by A14;
A18:  (U(Es)=U(Es) or X[Es]) & WHL is_closed_on Es &
     WHL is_halting_on Es from WhileGHalt(A1,A15,A16,A17);
   set s4 = C1.1;
A19:   sI is halting by A10,SCMPDS_6:def 3;
A20:   iI c= sI by FUNCT_4:26;
      then sI +* iI is halting by A19,AMI_5:10;
then A21:   I() is_halting_on sI by SCMPDS_6:def 3;
A22:   I() is_closed_on sI by A10,SCMPDS_6:38;
A23:   WHL = i1 ';' (I() ';' i2) by Lm5;
then A24:  CurInstr s1 = i1 by SCMPDS_6:22;
A25:  IC s1 =inspos 0 by SCMPDS_6:21;
A26:  (Computation s1).(0 + 1) = Following (Computation s1).0 by AMI_1:def 19
     .= Following s1 by AMI_1:def 19
     .= Exec(i1,s1) by A24,AMI_1:def 18;
     A27: s1.DataLoc(s1.a(),i())=s1.b by SCMPDS_5:19
     .= s().b by SCMPDS_5:19;
A28:  IC s4 = s4.IC SCMPDS by AMI_1:def 15
     .= Next IC s1 by A2,A26,A27,SCMPDS_2:68
     .= inspos(0+1) by A25,SCMPDS_4:70;
       sI,s1 equal_outside A by SCMPDS_4:36;
then A29:  sI | D = s1 | D by SCMPDS_4:24;
       now let a;
         thus sI.a = s1.a by A29,SCMPDS_4:23
          .= s4.a by A26,SCMPDS_2:68;
     end;
then A30:  sI | D = s4 | D by SCMPDS_4:23;

     set mI=LifeSpan sI,
         s5=(Computation s4).mI,
         l1=inspos (card I() + 1);

A31:    IExec(I(),s()) = Result sI +* s() | A by SCMPDS_4:def 8;
A32:    dom (s() | A) = A by SCMPDS_6:1;
         card I() + 1 < card I() + 2 by REAL_1:53;
then A33:    l1 in dom WHL by Th18;
A34:    WHL c= iWHL by SCMPDS_6:17;
         iWHL c= s1 by FUNCT_4:26;
then A35:    WHL c= s1 by A34,XBOOLE_1:1;
         Shift(I(),1) c= WHL by Lm6;
       then Shift(I(),1) c= s1 by A35,XBOOLE_1:1;
then A36:    Shift(I(),1) c= s4 by AMI_3:38;
then A37:    (Computation sI).mI | D = s5 | D
       by A1,A20,A21,A22,A28,A30,SCMPDS_7:36;
        set m3=mI +1;
        set s6=(Computation s1).m3;
A38:     IC s5=l1 by A1,A20,A21,A22,A28,A30,A36,SCMPDS_7:36;
A39:     s6=s5 by AMI_1:51;
then A40:     CurInstr s6=s5.l1 by A38,AMI_1:def 17
        .=s4.l1 by AMI_1:54
        .=s1.l1 by AMI_1:54
        .=WHL.l1 by A33,A35,GRFUNC_1:8
        .=i2 by Th19;
        set s7=(Computation s1).(m3+ 1);
A41:     s7 = Following s6 by AMI_1:def 19
        .= Exec(i2,s6) by A40,AMI_1:def 18;
A42:    IC s7=s7.IC SCMPDS by AMI_1:def 15
       .=ICplusConst(s6,-(card I()+1)) by A41,SCMPDS_2:66
       .=ICplusConst(s6,0-(card I()+1)) by XCMPLX_1:150
       .=inspos 0 by A38,A39,SCMPDS_7:1;
       A43: m3+1=mI+(1+1) by XCMPLX_1:1
       .=mI+2;
         now
          let x be Int_position;
  A44:     not x in dom iWHL & x in dom IExec(I(),s())
          by SCMPDS_2:49,SCMPDS_4:31;
  A45:     not x in dom (s() | A) by A32,SCMPDS_2:53;
        s5.x=(Computation sI).mI.x by A37,SCMPDS_4:23
         .=(Result sI).x by A19,SCMFSA6B:16
         .=IExec(I(),s()).x by A31,A45,FUNCT_4:12;
       hence s7.x=IExec(I(),s()).x by A39,A41,SCMPDS_2:66
         .=s2.x by A44,FUNCT_4:12;
     end;
     then A46: s7 | D = s2 | D by SCMPDS_4:23;
A47:  IC s2 =IC C1.m1 by A42,A43,SCMPDS_6:21;
A48: s2 is halting by A18,SCMPDS_6:def 3;
A49: dom ps = dom s() /\ A by RELAT_1:90
    .= ({IC SCMPDS} \/ D \/ A) /\ A by SCMPDS_4:19
    .= A by XBOOLE_1:21;
      s2 | A= (Result sI +* ps +* iWHL) | A by SCMPDS_4:def 8
    .=(Result sI +* ps)|A +* iWHL | A by AMI_5:6
    .= ps +* iWHL | A by A49,FUNCT_4:24
    .= s1 | A by AMI_5:6
    .= C1.m1 | A by SCMPDS_7:6;
then A50: C1.m1=s2 by A43,A46,A47,SCMPDS_7:7;
    then CurInstr C1.m1=i1 by A23,SCMPDS_6:22;
then A51: CurInstr C1.m1 <> halt SCMPDS by SCMPDS_6:30;
    set m0=LifeSpan s1;
      m0 > m1 by A9,A51,SCMPDS_6:2;
    then consider nn be Nat such that
A52: m0=m1+nn by NAT_1:28;
A53: C1.m0 = C2.nn by A50,A52,AMI_1:51;
    then CurInstr C2.nn =halt SCMPDS by A9,SCM_1:def 2;
then A54: nn >= m2 by A48,SCM_1:def 2;
      C1.(m1 + m2) = C2.m2 by A50,AMI_1:51;
    then CurInstr C1.(m1 + m2) = halt SCMPDS by A48,SCM_1:def 2;
    then m1 + m2 >= m0 by A9,SCM_1:def 2;
    then m2 >= nn by A52,REAL_1:53;
then nn=m2 by A54,AXIOMS:21;
then A55: Result s1 = C2.m2 by A9,A53,SCMFSA6B:16;
A56: IExec(I(),s()) | A= (Result sI +* ps) | A by SCMPDS_4:def 8
    .= ps by A49,FUNCT_4:24;
    thus F(s())=F(s()) or P[s()];
    thus IExec(WHL,s())
      = C2.m2 +* ps by A55,SCMPDS_4:def 8
     .= Result s2 +* IExec(I(),s()) | A by A48,A56,SCMFSA6B:16
     .= IExec(WHL,IExec(I(),s())) by SCMPDS_4:def 8;
end;

theorem :: SCMPDS_8:24
 for s being State of SCMPDS,I being No-StopCode shiftable Program-block,
 a be Int_position,i,c be Integer,X,Y be set, f being Function of
 product the Object-Kind of SCMPDS,NAT st card I > 0 &
 ( for t be State of SCMPDS st f.Dstate(t)=0 holds t.DataLoc(s.a,i) <= 0 ) &
  (for x st x in X holds s.x >= c+s.DataLoc(s.a,i)) &
  (for t be State of SCMPDS st
    (for x st x in X holds t.x >= c+t.DataLoc(s.a,i)) &
    (for x st x in Y holds t.x=s.x) & t.a=s.a & t.DataLoc(s.a,i) > 0
   holds IExec(I,t).a=t.a & I is_closed_on t & I is_halting_on t &
    f.Dstate(IExec(I,t)) < f.Dstate(t) &
    (for x st x in X holds IExec(I,t).x >= c+IExec(I,t).DataLoc(s.a,i)) &
    for x st x in Y holds IExec(I,t).x=t.x)
holds
     while>0(a,i,I) is_closed_on s & while>0(a,i,I) is_halting_on s;

theorem :: SCMPDS_8:25
 for s being State of SCMPDS,I being No-StopCode shiftable Program-block,
 a be Int_position, i,c be Integer,X,Y be set,f being Function of product
 the Object-Kind of SCMPDS,NAT st s.DataLoc(s.a,i) > 0 & card I > 0 &
 ( for t be State of SCMPDS st f.Dstate(t)=0 holds t.DataLoc(s.a,i) <= 0 ) &
 (for x st x in X holds s.x >= c+s.DataLoc(s.a,i)) &
 (for t be State of SCMPDS st
    (for x st x in X holds t.x >= c+t.DataLoc(s.a,i)) &
    (for x st x in Y holds t.x=s.x) & t.a=s.a & t.DataLoc(s.a,i) > 0
   holds IExec(I,t).a=t.a & I is_closed_on t & I is_halting_on t &
    f.Dstate(IExec(I,t)) < f.Dstate(t) &
    (for x st x in X holds IExec(I,t).x >= c+IExec(I,t).DataLoc(s.a,i)) &
    for x st x in Y holds IExec(I,t).x=t.x)
holds
   IExec(while>0(a,i,I),s) =IExec(while>0(a,i,I),IExec(I,s));

theorem :: SCMPDS_8:26
   for s being State of SCMPDS,I being No-StopCode shiftable Program-block,
 a be Int_position, i be Integer,X be set, f being Function of
 product the Object-Kind of SCMPDS,NAT st card I > 0 &
 (for t be State of SCMPDS st f.Dstate(t)=0 holds t.DataLoc(s.a,i) <= 0 ) &
 (for t be State of SCMPDS st
    (for x st x in X holds t.x=s.x) & t.a=s.a & t.DataLoc(s.a,i) > 0
   holds IExec(I,t).a=t.a & I is_closed_on t & I is_halting_on t &
    f.Dstate(IExec(I,t)) < f.Dstate(t) &
    for x st x in X holds IExec(I,t).x=t.x)
 holds
    while>0(a,i,I) is_closed_on s & while>0(a,i,I) is_halting_on s &
    (s.DataLoc(s.a,i) > 0 implies
    IExec(while>0(a,i,I),s) =IExec(while>0(a,i,I),IExec(I,s)));

theorem :: SCMPDS_8:27
 for s being State of SCMPDS,I being No-StopCode shiftable Program-block,
 a be Int_position, i,c be Integer,X,Y be set st
 card I > 0 & (for x st x in X holds s.x >= c+s.DataLoc(s.a,i)) &
 (for t be State of SCMPDS st
   (for x st x in X holds t.x >= c+t.DataLoc(s.a,i)) &
   (for x st x in Y holds t.x=s.x) & t.a=s.a & t.DataLoc(s.a,i) > 0
 holds IExec(I,t).a=t.a & I is_closed_on t & I is_halting_on t &
   IExec(I,t).DataLoc(s.a,i) < t.DataLoc(s.a,i) &
   (for x st x in X holds IExec(I,t).x >= c+IExec(I,t).DataLoc(s.a,i)) &
   for x st x in Y holds IExec(I,t).x=t.x)
holds
   while>0(a,i,I) is_closed_on s & while>0(a,i,I) is_halting_on s &
   ( s.DataLoc(s.a,i) > 0 implies
      IExec(while>0(a,i,I),s) =IExec(while>0(a,i,I),IExec(I,s)));

theorem :: SCMPDS_8:28
   for s being State of SCMPDS,I being No-StopCode shiftable Program-block,
 a be Int_position, i be Integer,X be set st card I > 0 &
 (for t be State of SCMPDS st
    (for x st x in X holds t.x=s.x) & t.a=s.a & t.DataLoc(s.a,i) > 0
   holds IExec(I,t).a=t.a & I is_closed_on t & I is_halting_on t &
    IExec(I,t).DataLoc(s.a,i) < t.DataLoc(s.a,i) &
    for x st x in X holds IExec(I,t).x=t.x)
 holds
    while>0(a,i,I) is_closed_on s & while>0(a,i,I) is_halting_on s &
    (s.DataLoc(s.a,i) > 0 implies
     IExec(while>0(a,i,I),s) =IExec(while>0(a,i,I),IExec(I,s)));

theorem :: SCMPDS_8:29
   for s being State of SCMPDS,I being No-StopCode shiftable Program-block,
 a be Int_position, i,c be Integer,X be set st card I > 0 &
  (for x st x in X holds s.x >= c+s.DataLoc(s.a,i)) &
  (for t be State of SCMPDS st
    (for x st x in X holds t.x >= c+t.DataLoc(s.a,i)) &
    t.a=s.a & t.DataLoc(s.a,i) > 0
  holds IExec(I,t).a=t.a & I is_closed_on t & I is_halting_on t &
    IExec(I,t).DataLoc(s.a,i) < t.DataLoc(s.a,i) &
    for x st x in X holds IExec(I,t).x >= c+IExec(I,t).DataLoc(s.a,i))
 holds
   while>0(a,i,I) is_closed_on s & while>0(a,i,I) is_halting_on s &
   (s.DataLoc(s.a,i) > 0 implies
     IExec(while>0(a,i,I),s) =IExec(while>0(a,i,I),IExec(I,s)));

