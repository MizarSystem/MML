:: The Subformula Tree of a Formula of the First Order Language
::  by Oleg Okhotnikov
::
:: Received October 2, 1995
:: Copyright (c) 1995 Association of Mizar Users

environ

 vocabulary FINSEQ_1, RELAT_1, TREES_1, ZFMISC_1, FUNCT_1, TREES_2, FINSET_1,
      TREES_4, BOOLE, TREES_9, ORDINAL1, CARD_1, MCART_1, ORDERS_1, TARSKI,
      QC_LANG1, ZF_LANG, QC_LANG4;
 notation TARSKI, XBOOLE_0, ZFMISC_1, SUBSET_1, NUMBERS, XREAL_0, NAT_1,
      RELAT_1, FUNCT_1, FUNCT_2, FINSET_1, FINSEQ_1, FINSEQ_4, CARD_1, TREES_1,
      TREES_2, TREES_4, TREES_9, QC_LANG1, QC_LANG2, MCART_1;
 constructors NAT_1, FINSEQ_4, TREES_4, TREES_9, QC_LANG2, XREAL_0, MEMBERED;
 clusters SUBSET_1, TREES_1, TREES_2, TREES_9, RELSET_1, TREES_A, FINSET_1,
      FINSEQ_1, NAT_1, MEMBERED, ORDINAL2;
 requirements NUMERALS, REAL, BOOLE, SUBSET, ARITHM;


begin

canceled 3;

theorem :: QC_LANG4:4
  for n being Nat, r being FinSequence ex q being FinSequence st
    q = r|Seg n & q is_a_prefix_of r;

canceled;

theorem :: QC_LANG4:6
  for D being non empty set, r being FinSequence of D,
    r1,r2 being FinSequence, k being Nat
      st k+1 <= len r & r1 = r|Seg (k+1) & r2 = r|Seg k holds
        ex x being Element of D st r1 = r2^<*x*>;

theorem :: QC_LANG4:7
  for D being non empty set, r being FinSequence of D, r1 being FinSequence
    st 1 <= len r & r1 = r|Seg 1 holds ex x being Element of D st r1 = <*x*>;

registration let D be non empty set, T be DecoratedTree of D;
 cluster -> Function-like Relation-like Element of dom T;
 coherence;
end;


registration let D be non empty set, T be DecoratedTree of D;
 cluster -> FinSequence-like Element of dom T;
 coherence;
end;


registration let D be non empty set;
 cluster finite DecoratedTree of D;
 existence
   proof
     consider d being Element of D;
     take root-tree d;
     thus root-tree d is finite;
   end;
end;


reserve T for DecoratedTree,
        p for FinSequence of NAT;

theorem :: QC_LANG4:8
  T.p = (T|p).{};

reserve T for finite-branching DecoratedTree,
        t for Element of dom T,
        x for FinSequence,
        n, k, m for Nat;

theorem :: QC_LANG4:9
  succ(T,t) = T*(t succ);

theorem :: QC_LANG4:10
  dom (T*(t succ)) = dom (t succ);

theorem :: QC_LANG4:11
  dom succ(T,t) = dom (t succ);

theorem :: QC_LANG4:12
  t^<*n*> in dom T iff n+1 in dom (t succ);

theorem :: QC_LANG4:13
  for T, x, n st x^<*n*> in dom T holds T.(x^<*n*>) = succ(T,x).(n+1);

reserve x, x' for Element of dom T,
        y' for set;

theorem :: QC_LANG4:14
  x' in succ x implies T.x' in rng succ(T,x);

theorem :: QC_LANG4:15
  y' in rng succ(T,x) implies ex x' st y' = T.x' & x' in succ x;

reserve n,k1,k2,l,k,m for Nat,
        x,y,y1,y2 for set;

scheme :: QC_LANG4:sch 1
 ExDecTrees { D() -> non empty set, d() -> Element of D(),
    G(set) -> FinSequence of D() }:
 ex T being finite-branching DecoratedTree of D() st
    T.{} = d() &
    for t being Element of dom T, w being Element of D() st w = T.t
      holds succ(T,t) = G(w)
proof
   defpred P[set,set] means (len G($1) = 0 & $2 = {}) or
     len G($1) <> 0 & ex m st m+1 = len G($1) & $2 = {0} \/ Seg m;
   A1: for x,y1,y2 st x in D() & P[x,y1] & P[x,y2] holds y1 = y2 by XCMPLX_1:2;
   A2: for x st x in D() ex y st P[x,y]
     proof let x such that x in D();
       per cases;
         suppose len G(x) = 0;
         hence ex y st P[x,y];
         end;
         suppose len G(x) <> 0;
           then consider m such that A3: m+1 = len G(x) by NAT_1:22;
             ex y st y = {0} \/ Seg m;
         hence ex y st P[x,y] by A3;
     end;
     end;
     ex F being Function st dom F = D() & for x st x in D() holds P[x,F.x]
     from FUNCT_1:sch 2(A1,A2);
   then consider F being Function such that
A4:  for x st x in D() holds (len G(x) = 0 & F.x = {}) or
       len G(x) <> 0 & ex m st m+1 = len G(x) & F.x = {0} \/ Seg m;
   deffunc F(set) = F.$1;
A5:for k,x st x in D() holds k in F(x) iff k+1 in Seg len G(x)
     proof let k,x such that A6: x in D();
         now assume A7: k in F(x);
         then consider m such that
A8:     m+1 = len G(x) & F.x = {0} \/ Seg m by A4,A6;
           0 <= k & k <= m
           proof per cases by A7,A8,XBOOLE_0:def 2;
             suppose k in {0}; then k = 0 by TARSKI:def 1;
             hence thesis by NAT_1:18;
             end;
             suppose k in
 Seg m; then 0+1 <= k & k <= m by FINSEQ_1:3;
             hence thesis by NAT_1:38;
           end;
           end; then 0+1 <= k+1 & k+1 <= m+1 by AXIOMS:24;
         hence k+1 in Seg len G(x) by A8,FINSEQ_1:3;
       end;
       hence k in F(x) implies k+1 in Seg len G(x);
       assume A9: k+1 in Seg len G(x);
         then consider m such that A10: m+1 = len G(x) & F.x = {0} \/
          Seg m by A4,A6,FINSEQ_1:4;
           k in {0} \/ Seg m
           proof per cases;
             suppose k = 0; then k in {0} by TARSKI:def 1;
             hence thesis by XBOOLE_0:def 2;
             end;
             suppose k <> 0; then 0 < k by NAT_1:19;
then A11:            0+1 <= k by NAT_1:38;
                 1 <= k+1 & k+1 <= len G(x) by A9,FINSEQ_1:3;
               then 1 <= k & k <= m by A10,A11,REAL_1:53;
               then k in Seg m by FINSEQ_1:3;
             hence thesis by XBOOLE_0:def 2;
           end;
           end;
       hence k in F(x) by A10;
     end;
A12:for x being set, t being Element of dom T st x in D() holds
     { t^<*k*>: k in F(x)} = { t^<*m*>: m+1 in Seg len G(x)}
     proof let x be set, t be Element of dom T such that A13: x in D();
       thus { t^<*k*>: k in F(x)} c= { t^<*m*>: m+1 in Seg len G(x)}
         proof let y be set; assume y in { t^<*k*>: k in F(x)};
           then consider k such that A14: y = t^<*k*> & k in F(x);
             y = t^<*k*> & k+1 in Seg len G(x) by A5,A13,A14;
           hence y in { t^<*m*>: m+1 in Seg len G(x)};
         end;
       thus { t^<*m*>: m+1 in Seg len G(x)} c= { t^<*k*>: k in F(x)}
         proof let y be set; assume y in { t^<*m*>: m+1 in Seg len G(x)};
           then consider m such that A15: y = t^<*m*> & m+1 in Seg len G(x);
             y = t^<*m*> & m in F(x) by A5,A13,A15;
           hence y in { t^<*k*>: k in F(x)};
         end;
     end;
   defpred P[set,set] means ex x,n st x in D() & $1 = [x,n] &
     (n in F(x) & $2 = G(x).(n+1) or not n in F(x) & $2 = d());
   A16: for c being Element of [:D(),NAT:] ex y being Element of D() st P[c,y]
     proof let c be Element of [:D(),NAT:];
         c`1 in D() & c`2 in NAT by MCART_1:10;
       then consider x being Element of D(), n being Nat such that
A17:       x = c`1 & n = c`2;
A18:     c = [x,n] by A17,MCART_1:23;
       per cases;
         suppose A19: n in F(x);
         then n+1 in Seg len G(x) by A5;
         then n+1 in dom G(x) by FINSEQ_1:def 3;
then A20:       G(x).(n+1) in rng G(x) by FUNCT_1:def 5;
           rng G(x) c= D() by FINSEQ_1:def 4;
         then consider y being Element of D() such that
A21:      y = G(x).(n+1) by A20;
         thus ex y being Element of D() st P[c,y] by A18,A19,A21;
         end;
         suppose not n in F(x);
         hence ex y being Element of D() st P[c,y] by A18;
     end;
     end;
     ex S being Function of [:D(),NAT:],D() st for c being
          Element of [:D(),NAT:] holds P[c,S.c] from FUNCT_2:sch 3(A16);
   then consider S being Function of [: D(), NAT :],D() such that
A22:  for c being Element of [: D(), NAT :] holds P[c,S.c];
A23: for n, x st x in D() & n in F(x) holds S.[x,n] = G(x).(n+1)
     proof let n, x such that A24: x in D() & n in F(x);
A25:    [x,n]`1 = x by MCART_1:def 1;
         [x,n]`2 = n by MCART_1:def 2;
       then [x,n] in [: D(), NAT :] by A24,A25,MCART_1:11;
       then consider c being Element of [:D(),NAT:] such that A26: c = [x,n];
       consider x' being set, n' being Nat such that
A27:      x' in D() & c = [x',n'] & (n' in F(x') & S.c = G(x').(n'+1) or
           not n' in F(x') & S.c = d()) by A22;
         x' = x & n' = n by A26,A27,ZFMISC_1:33;
       hence S.[x,n] = G(x).(n+1) by A24,A27;
     end;
A28:for n,x,m st m+1 = len G(x) & x in D() holds n in F(x) iff 0 <= n & n <= m
  proof let n,x,m such that A29: m+1 = len G(x) & x in D();
    thus n in F(x) implies 0 <= n & n <= m
      proof assume A30: n in F(x);
        consider k such that A31: k+1 = len G(x) & F(x) = {0} \/ Seg k
            by A4,A29;
        A32: m = k by A29,A31,XCMPLX_1:2;
        per cases by A30,A31,A32,XBOOLE_0:def 2;
          suppose n in {0}; then n = 0 by TARSKI:def 1;
          hence 0 <= n & n <= m by NAT_1:18;
          end;
          suppose n in Seg m;
        then 1 <= n & n <= m by FINSEQ_1:3;
          hence 0 <= n & n <= m by AXIOMS:22;
      end;
      end;
    thus 0 <= n & n <= m implies n in F(x)
      proof assume
A33:    0 <= n & n <= m;
        consider k such that
        A34: k+1 = len G(x) & F(x) = {0} \/ Seg k by A4,A29;
        A35: m = k by A29,A34,XCMPLX_1:2;
        per cases;
          suppose n = 0; then n in {0} by TARSKI:def 1;
          hence n in F(x) by A34,XBOOLE_0:def 2;
          end;
          suppose n <> 0; then 0 < n by NAT_1:19; then 0+1 <= n by NAT_1:38;
          then n in Seg m by A33,FINSEQ_1:3;
          hence n in F(x) by A34,A35,XBOOLE_0:def 2;
      end;
      end;
  end;
A36: for d being Element of D(), k1,k2 st k1 <= k2 & k2 in F(d) holds k1 in
 F(d)
     proof let d be Element of D(), k1,k2; assume A37: k1 <= k2 & k2 in F(d);
       then len G(d) <> 0 & ex m st m+1 = len G(d) & F.d = {0} \/ Seg m by A4;
       then consider m such that A38: m+1 = len G(d);
         0 <= k2 & k2 <= m by A28,A37,A38;
       then 0 <= k1 & k1 <= m by A37,AXIOMS:22,NAT_1:18;
       hence k1 in F(d) by A28,A38;
     end;
   consider T being DecoratedTree of D() such that
A39:   T.{} = d() &
     for t being Element of dom T holds succ t = { t^<*k*>: k in F(T.t)} &
       for n,x st x = T.t & n in F(x) holds T.(t^<*n*>) = S.[x,n]
         from TREES_2:sch 8(A36);
     T is finite-branching
     proof
         for t being Element of dom T holds succ t is finite
         proof let t be Element of dom T;
A40:         succ t = { t^<*k*>: k in F(T.t)} by A39;
           defpred P[set,set] means ex m st m+1 = $1 & $2 = t^<*m*>;
           A41: for k,y1,y2 st k in Seg len G(T.t) & P[k,y1] & P[k,y2]
              holds y1=y2 by XCMPLX_1:2;
           A42: for k st k in Seg len G(T.t) ex x st P[k,x]
             proof let k; assume k in Seg len G(T.t);
               then k <> 0 by FINSEQ_1:3;
               then consider m such that A43: m+1 = k by NAT_1:22;
               consider x such that A44: x = t^<*m*>;
               thus ex x st P[k,x] by A43,A44;
             end;
             ex L being FinSequence st dom L = Seg len G(T.t) &
             for k st k in Seg len G(T.t) holds P[k,L.k] from FINSEQ_1:sch 1
(A41,A42);
           then consider L being FinSequence such that
A45:          dom L = Seg len G(T.t) &
             for k st k in Seg len G(T.t) holds P[k,L.k];
A46:        for k st 1 <= k+1 & k+1 <= len G(T.t) holds L.(k+1) = t^<*k*>
             proof let k; assume 1 <= k+1 & k+1 <= len G(T.t);
               then k+1 in Seg len G(T.t) by FINSEQ_1:3;
               then consider m such that
               A47: m+1 = k+1 & L.(k+1) = t^<*m*> by A45;
               thus L.(k+1) = t^<*k*> by A47,XCMPLX_1:2;
             end;
             succ t = rng L
             proof
               thus succ t c= rng L
               proof let x; assume x in succ t;
                 then consider k such that
A48:                x = t^<*k*> & k in F(T.t) by A40;
A49:              k+1 in Seg len G(T.t) by A5,A48;
                 then 1 <= k+1 & k+1 <= len G(T.t) by FINSEQ_1:3;
                 then L.(k+1) = t^<*k*> by A46;
                 hence x in rng L by A45,A48,A49,FUNCT_1:def 5;
               end;
               thus rng L c= succ t
               proof let y be set; assume y in rng L;
                 then consider m being set such that
A50:                 m in dom L & y = L.m by FUNCT_1:def 5;
                 reconsider m as Nat by A50;
A51:              1 <= m & m <= len G(T.t) by A45,A50,FINSEQ_1:3;
                   m <> 0 by A45,A50,FINSEQ_1:3;
                 then consider k such that A52: k+1 = m by NAT_1:22;
                   y = t^<*k*> & k in F(T.t) by A5,A45,A46,A50,A51,A52;
                 hence y in succ t by A40;
               end;
             end;
           hence thesis;
         end;
       then dom T is finite-branching by TREES_9:def 2;
       hence thesis by TREES_9:def 4;
     end;
   then reconsider T as finite-branching DecoratedTree of D();
     now let t be Element of dom T, w be Element of D() such that A53: w = T.t;
A54:   dom succ(T,t) = dom G(w)
       proof
A55:      dom G(w) = Seg len G(w) by FINSEQ_1:def 3;
A56:      dom (t succ) = Seg len (t succ) by FINSEQ_1:def 3;
            succ t = { t^<*k*>: k in F(w)} by A39,A53;
         then A57:      succ t = { t^<*k*>: k+1 in Seg len G(w)} by A12;
           dom G(w) = dom (t succ)
           proof
             thus dom G(w) c= dom (t succ)
             proof let n' be set; assume A58: n' in dom G(w);
A59:            Seg len G(w) = { k : 1 <= k & k <=
 len G(w)} by FINSEQ_1:def 1;
               then consider m such that A60: n' = m & 1 <= m & m <=
 len G(w) by A55,A58;
                 0 <> m by A60;
               then consider n such that A61: m = n+1 by NAT_1:22;
                 n+1 in Seg len G(w) by A59,A60,A61;
               then t^<*n*> in succ t by A57;
               hence n' in dom (t succ) by A60,A61,Th12;
             end;
             thus dom (t succ) c= dom G(w)
             proof let n' be set; assume A62: n' in dom (t succ);
A63:            Seg len (t succ) = { k : 1 <= k & k <= len (t succ)}
                 by FINSEQ_1:def 1;
               then consider m such that A64: n' = m & 1 <= m & m <=
 len (t succ) by A56,A62;
                 0 <> m by A64;
               then consider n such that A65: m = n+1 by NAT_1:22;
                 n+1 in dom (t succ) by A56,A63,A64,A65;
then A66:            t^<*n*> in dom T by Th12;
                 succ t = { t^<*k*>: t^<*k*> in dom T } by TREES_2:def 5;
               then t^<*n*> in succ t by A66;
               then consider k such that
A67:             t^<*k*> = t^<*n*> & k+1 in Seg len G(w) by A57;
                 <*k*> = <*n*> by A67,FINSEQ_1:46;
               hence n' in dom G(w) by A55,A64,A65,A67,TREES_1:23;
             end;
           end;
         hence thesis by Th11;
       end;
       for m st m in dom succ(T,t) holds (succ(T,t)).m = G(w).m
       proof let m; assume A68: m in dom succ(T,t);
         then A69:      m in Seg len G(w) by A54,FINSEQ_1:def 3;
           Seg len G(w) = { k : 1 <= k & k <= len G(w)} by FINSEQ_1:def 1;
         then consider k such that A70: m = k & 1 <= k & k <= len G(w) by A69;
           0 <> k by A70;
         then consider n such that A71: m = n+1 by A70,NAT_1:22;
           n+1 in dom (t succ) by A68,A71,Th11;
then A72:       t^<*n*> in dom T by Th12;
         consider l such that
A73:      l+1 = len G(T.t) & F.(T.t) = {0} \/ Seg l by A4,A53,A69,FINSEQ_1:4;
           0+1 <= n+1 & n+1 <= l+1 by A53,A70,A71,A73;
then A74:       0 <= n & n <= l by REAL_1:53;
         A75: n in {0} \/ Seg l
           proof per cases;
             suppose n = 0; then n in {0} by TARSKI:def 1;
             hence thesis by XBOOLE_0:def 2;
             end;
             suppose n <> 0; then 0 < n by NAT_1:19; then 0+1 <= n by NAT_1:38;
             then n in Seg l by A74,FINSEQ_1:3;
             hence thesis by XBOOLE_0:def 2;
           end;
           end;
           succ(T,t).(n+1) = T.(t^<*n*>) by A72,Th13
                        .= S.[T.t,n] by A39,A73,A75
                        .= G(w).(n+1) by A23,A53,A73,A75;
         hence succ(T,t).m = G(w).m by A71;
       end;
     hence succ(T,t) = G(w) by A54,FINSEQ_1:17;
   end;
   hence thesis by A39;
end;

theorem :: QC_LANG4:16
  for T being Tree, t being Element of T holds
    ProperPrefixes t is finite Chain of T;

theorem :: QC_LANG4:17
  for T being Tree holds T-level 0 = {{}};

theorem :: QC_LANG4:18
  for T being Tree holds
    T-level (n+1) = union { succ w where w is Element of T : len w = n };

theorem :: QC_LANG4:19
  for T being finite-branching Tree, n being Nat holds T-level n is finite;

theorem :: QC_LANG4:20
  for T being finite-branching Tree holds
    T is finite iff ex n being Nat st T-level n = {};

theorem :: QC_LANG4:21
  for T being finite-branching Tree st not T is finite
    ex C being Chain of T st not C is finite;

theorem :: QC_LANG4:22
  for T being finite-branching Tree st not T is finite
    ex B being Branch of T st not B is finite;

theorem :: QC_LANG4:23
  for T being Tree, C being Chain of T, t being Element of T
    st t in C & not C is finite
      ex t' being Element of T st t' in C & t is_a_proper_prefix_of t';

theorem :: QC_LANG4:24
  for T being Tree, B being Branch of T, t being Element of T
    st t in B & not B is finite
      ex t' being Element of T st t' in B & t' in succ t;

theorem :: QC_LANG4:25
  for f being Function of NAT,NAT st
   (for n holds f.(n+1) qua Nat <= f.n qua Nat)
     ex m st for n st m <= n holds f.n = f.m;

scheme :: QC_LANG4:sch 2
 FinDecTree { D() -> non empty set,
    T() -> finite-branching DecoratedTree of D(), F(Element of D()) -> Nat }:
  T() is finite
provided
for t,t' being Element of dom T(), d being Element of D()
    st t' in succ t & d = T().t' holds F(d) < F(T().t)
proof
    now assume not T() is finite;
    then not dom T() is finite by AMI_1:21;
    then consider B being Branch of dom T() such that A2: not B is finite by
Th22;
    defpred Q[set] means ex t being Element of dom T() st t in B & $1 = T().t;
    defpred P[set,set] means ex t,t' being Element of dom T() st
      t' in succ t & t in B & t' in B & $1 = T().t & $2 = T().t';
    A3: T().{} in D() & Q[T().{}]
      proof
          {} in B by TREES_2:28;
        then Q[T().{}];
        hence thesis;
      end;
    A4: for x st x in D() & Q[x] ex y st y in D() & P[x,y] & Q[y]
      proof let x; assume x in D() & Q[x];
        then consider t being Element of dom T() such that A5: t in B & x = T()
.t;
        consider t' being Element of dom T() such that
A6:        t' in B & t' in succ t by A2,A5,Th24;
          ex y st y = T().t';
        hence ex y st y in D() & P[x,y] & Q[y] by A5,A6;
      end;
      ex g being Function st dom g = NAT & rng g c= D() & g.0 = T().{} &
      for k holds P[g.k,g.(k+1)] & Q[g.k] from TREES_2:sch 5(A3,A4);
    then consider g being Function such that A7: dom g = NAT & rng g c= D() &
      g.0 = T().{} & for k holds (ex t,t' being Element of dom T() st
        t' in succ t & t in B & t' in B & g.k = T().t & g.(k+1) = T().t') &
        ex t being Element of dom T() st t in B & g.k = T().t;
    defpred P[set,set] means
      ex d being Element of D() st d = g.$1 & $2 = F(d);
    A8: for x st x in NAT ex y st y in NAT & P[x,y]
      proof let x; assume x in NAT;
        then reconsider k = x as Nat;
        consider t being Element of dom T() such that
A9:       t in B & g.k = T().t by A7;
        consider y such that A10: y = F(T().t);
        thus ex y st y in NAT & P[x,y] by A9,A10;
      end;
      ex f being Function of NAT,NAT st for x st x in NAT holds P[x,f.x]
      from FUNCT_2:sch 1(A8);
    then consider f being Function of NAT,NAT such that
A11:   for x st x in NAT ex d being Element of D() st d = g.x & f.x = F(d);
A12:  (ex d being Element of D() st d = T().{} & f.0 = F(d)) &
      for k ex t,t' being Element of dom T() st t' in succ t & t in B & t' in
 B &
        f.k = F(T().t) & f.(k+1) = F(T().t')
      proof
        thus ex d being Element of D() st d = T().{} & f.0 = F(d) by A7,A11;
        thus for k ex t,t' being Element of dom T() st t' in succ t &
          t in B & t' in B & f.k = F(T().t) & f.(k+1) = F(T().t')
          proof let k;
            consider d being Element of D() such that
A13:           d = g.k & f.k = F(d) by A11;
            consider d1 being Element of D() such that
A14:           d1 = g.(k+1) & f.(k+1) = F(d1) by A11;
            consider t,t' being Element of dom T() such that
A15:           t' in succ t & t in B & t' in B & g.k = T().t & g.(k+1) = T().t'
                by A7;
            thus ex t,t' being Element of dom T() st t' in succ t &
              t in B & t' in B & f.k = F(T().t) & f.(k+1) = F(T().t')
                by A13,A14,A15;
          end;
      end;
A16:  for n ex t,t' being Element of dom T() st t' in succ t & f.n = F(T().t) &
      f.(n+1) = F(T().t') & f.(n+1) qua Nat < f.n qua Nat
      proof let n;
        consider t,t' being Element of dom T() such that
A17:        t' in succ t & t in B & t' in
 B & f.n = F(T().t) & f.(n+1) = F(T().t')
            by A12;
          f.(n+1) qua Nat < f.n qua Nat by A1,A17;
        hence thesis by A17;
      end;
      ex m st for n st m <= n holds f.n = f.m
      proof
          for n holds f.(n+1) qua Nat <= f.n qua Nat
          proof let n;
            consider t,t' being Element of dom T() such that
A18:            t' in succ t & f.n = F(T().t) &
                f.(n+1) = F(T().t') & f.(n+1) qua Nat < f.n qua Nat by A16;
            thus thesis by A18;
          end;
        hence ex m st for n st m <= n holds f.n = f.m by Th25;
      end;
    then consider m such that A19: for n st m <= n holds f.n = f.m;
    consider k such that A20: k = m+1;
    consider t,t' being Element of dom T() such that
A21:    t' in succ t & f.m = F(T().t) &
        f.(m+1) = F(T().t') & f.(m+1) qua Nat < f.m qua Nat by A16;
        m <= k
      proof m+0 <= m+1 by AXIOMS:24;
        hence thesis by A20;
      end;
    hence contradiction by A19,A20,A21;
  end;
  hence T() is finite;
end;

reserve D for non empty set,
        T for DecoratedTree of D;

theorem :: QC_LANG4:26
  for y being set st y in rng T holds y is Element of D;

theorem :: QC_LANG4:27
  for x being set st x in dom T holds T.x is Element of D;

begin

reserve F, G, G',H, H' for Element of QC-WFF;

theorem :: QC_LANG4:28
  F is_subformula_of G implies len @ F <= len @ G;

theorem :: QC_LANG4:29
    F is_subformula_of G & len @ F = len @ G implies F = G;

definition let p be Element of QC-WFF;
  func list_of_immediate_constituents(p) -> FinSequence of QC-WFF equals
:: QC_LANG4:def 1
     <*> QC-WFF if p = VERUM or p is atomic,
     <* the_argument_of p *> if p is negative,
     <* the_left_argument_of p, the_right_argument_of p *> if
      p is conjunctive
    otherwise <* the_scope_of p *>;
end;


theorem :: QC_LANG4:30
  k in dom list_of_immediate_constituents(F) &
    G = (list_of_immediate_constituents(F)).k implies
      G is_immediate_constituent_of F;

theorem :: QC_LANG4:31
  rng list_of_immediate_constituents(F) =
    { G where G is Element of QC-WFF : G is_immediate_constituent_of F };

definition let p be Element of QC-WFF;
  func tree_of_subformulae(p) -> finite DecoratedTree of QC-WFF means
:: QC_LANG4:def 2
    it.{} = p & for x being Element of dom it holds
      succ(it,x) = list_of_immediate_constituents(it.x);
end;


reserve t, t', t'' for Element of dom tree_of_subformulae(F);

canceled 2;

theorem :: QC_LANG4:34
  F in rng tree_of_subformulae(F);

theorem :: QC_LANG4:35
  t^<*n*> in dom tree_of_subformulae(F) implies
    ex G st G = (tree_of_subformulae(F)).(t^<*n*>) &
      G is_immediate_constituent_of (tree_of_subformulae(F)).t;

theorem :: QC_LANG4:36
  H is_immediate_constituent_of (tree_of_subformulae(F)).t iff
    ex n st t^<*n*> in dom tree_of_subformulae(F) &
      H = (tree_of_subformulae(F)).(t^<*n*>);

theorem :: QC_LANG4:37
  G in rng tree_of_subformulae(F) & H is_immediate_constituent_of G
    implies H in rng tree_of_subformulae(F);

theorem :: QC_LANG4:38
  G in rng tree_of_subformulae(F) & H is_subformula_of G implies
    H in rng tree_of_subformulae(F);

theorem :: QC_LANG4:39
  G in rng tree_of_subformulae(F) iff G is_subformula_of F;

theorem :: QC_LANG4:40
    rng tree_of_subformulae(F) = Subformulae(F);

theorem :: QC_LANG4:41
    t' in succ t implies (tree_of_subformulae(F)).t'
    is_immediate_constituent_of (tree_of_subformulae(F)).t;

reserve x,y1,y2 for set;

theorem :: QC_LANG4:42
  t is_a_prefix_of t' implies (tree_of_subformulae(F)).t'
    is_subformula_of (tree_of_subformulae(F)).t;

theorem :: QC_LANG4:43
  t is_a_proper_prefix_of t' implies
    len @((tree_of_subformulae(F)).t') < len @((tree_of_subformulae(F)).t);

theorem :: QC_LANG4:44
  t is_a_proper_prefix_of t' implies
    (tree_of_subformulae(F)).t' <> (tree_of_subformulae(F)).t;

theorem :: QC_LANG4:45
  t is_a_proper_prefix_of t' implies (tree_of_subformulae(F)).t'
    is_proper_subformula_of (tree_of_subformulae(F)).t;

theorem :: QC_LANG4:46
    (tree_of_subformulae(F)).t = F iff t = {};

theorem :: QC_LANG4:47
  t <> t' & (tree_of_subformulae(F)).t = (tree_of_subformulae(F)).t' implies
    not t,t' are_c=-comparable;

definition let F, G be Element of QC-WFF;
  func F-entry_points_in_subformula_tree_of G ->
    AntiChain_of_Prefixes of dom tree_of_subformulae(F) means
:: QC_LANG4:def 3
      for t being Element of dom tree_of_subformulae(F) holds
        t in it iff (tree_of_subformulae(F)).t = G;
end;


canceled;

theorem :: QC_LANG4:49
  F-entry_points_in_subformula_tree_of G =
    { t where t is Element of dom tree_of_subformulae(F) :
      (tree_of_subformulae(F)).t = G };

theorem :: QC_LANG4:50
  G is_subformula_of F iff F-entry_points_in_subformula_tree_of G <> {};

theorem :: QC_LANG4:51
  t' = t^<*m*> & (tree_of_subformulae(F)).t is negative implies
    (tree_of_subformulae(F)).t' = the_argument_of (tree_of_subformulae(F)).t &
      m = 0;

theorem :: QC_LANG4:52
  t' = t^<*m*> & (tree_of_subformulae(F)).t is conjunctive implies
    (tree_of_subformulae(F)).t'
      = the_left_argument_of (tree_of_subformulae(F)).t & m = 0 or
    (tree_of_subformulae(F)).t'
      = the_right_argument_of (tree_of_subformulae(F)).t & m = 1;

theorem :: QC_LANG4:53
  t' = t^<*m*> & (tree_of_subformulae(F)).t is universal implies
    (tree_of_subformulae(F)).t' = the_scope_of (tree_of_subformulae(F)).t &
      m = 0;

theorem :: QC_LANG4:54
  (tree_of_subformulae(F)).t is negative implies
    t^<*0*> in dom tree_of_subformulae(F) & (tree_of_subformulae(F)).(t^<*0*>)
      = the_argument_of (tree_of_subformulae(F)).t;

reserve x,y for set;

theorem :: QC_LANG4:55
  (tree_of_subformulae(F)).t is conjunctive implies
    t^<*0*> in dom tree_of_subformulae(F) & (tree_of_subformulae(F)).(t^<*0*>)
      = the_left_argument_of (tree_of_subformulae(F)).t &
    t^<*1*> in dom tree_of_subformulae(F) & (tree_of_subformulae(F)).(t^<*1*>)
      = the_right_argument_of (tree_of_subformulae(F)).t;

theorem :: QC_LANG4:56
  (tree_of_subformulae(F)).t is universal implies
    t^<*0*> in dom tree_of_subformulae(F) & (tree_of_subformulae(F)).(t^<*0*>)
      = the_scope_of (tree_of_subformulae(F)).t;

reserve t for Element of dom tree_of_subformulae(F),
        s for Element of dom tree_of_subformulae(G);

theorem :: QC_LANG4:57
  t in F-entry_points_in_subformula_tree_of G &
  s in G-entry_points_in_subformula_tree_of H implies
  t^s in F-entry_points_in_subformula_tree_of H;

reserve t for Element of dom tree_of_subformulae(F),
        s for FinSequence;

theorem :: QC_LANG4:58
  t in F-entry_points_in_subformula_tree_of G &
  t^s in F-entry_points_in_subformula_tree_of H implies
  s in G-entry_points_in_subformula_tree_of H;

theorem :: QC_LANG4:59
for F,G,H holds
  { t^s where t is Element of dom tree_of_subformulae(F),
    s is Element of dom tree_of_subformulae(G) :
      t in F-entry_points_in_subformula_tree_of G &
      s in G-entry_points_in_subformula_tree_of H } c=
  F-entry_points_in_subformula_tree_of H;

theorem :: QC_LANG4:60
  (tree_of_subformulae(F))|t
    = tree_of_subformulae((tree_of_subformulae(F)).t);

theorem :: QC_LANG4:61
  t in F-entry_points_in_subformula_tree_of G iff
    (tree_of_subformulae(F))|t = tree_of_subformulae(G);

theorem :: QC_LANG4:62
    F-entry_points_in_subformula_tree_of G =
    { t where t is Element of dom tree_of_subformulae(F) :
      (tree_of_subformulae(F))|t = tree_of_subformulae(G) };

reserve C for Chain of dom tree_of_subformulae(F);

theorem :: QC_LANG4:63
    for F,G,H,C st
  G in { (tree_of_subformulae(F)).t
    where t is Element of dom tree_of_subformulae(F) : t in C } &
  H in { (tree_of_subformulae(F)).t
    where t is Element of dom tree_of_subformulae(F) : t in C } holds
      G is_subformula_of H or H is_subformula_of G;

definition let F be Element of QC-WFF;
  mode Subformula of F -> Element of QC-WFF means
:: QC_LANG4:def 4
    it is_subformula_of F;
end;


definition let F be Element of QC-WFF; let G be Subformula of F;
  mode Entry_Point_in_Subformula_Tree of G ->
    Element of dom tree_of_subformulae(F) means
:: QC_LANG4:def 5
      (tree_of_subformulae(F)).it = G;
end;


reserve G for Subformula of F;

reserve t, t' for Entry_Point_in_Subformula_Tree of G;

canceled;

theorem :: QC_LANG4:65
    t <> t' implies not t,t' are_c=-comparable;

definition let F be Element of QC-WFF; let G be Subformula of F;
  func entry_points_in_subformula_tree(G) ->
    non empty AntiChain_of_Prefixes of dom tree_of_subformulae(F) equals
:: QC_LANG4:def 6
      F-entry_points_in_subformula_tree_of G;
end;


canceled;

theorem :: QC_LANG4:67
  t in entry_points_in_subformula_tree(G);

theorem :: QC_LANG4:68
  entry_points_in_subformula_tree(G) =
    { t where t is Entry_Point_in_Subformula_Tree of G : t = t };

reserve G1, G2 for Subformula of F,
        t1 for Entry_Point_in_Subformula_Tree of G1,
        s for Element of dom tree_of_subformulae(G1);

theorem :: QC_LANG4:69
  s in G1-entry_points_in_subformula_tree_of G2 implies
    t1^s is Entry_Point_in_Subformula_Tree of G2;

reserve s for FinSequence;

theorem :: QC_LANG4:70
    t1^s is Entry_Point_in_Subformula_Tree of G2 implies
  s in G1-entry_points_in_subformula_tree_of G2;

theorem :: QC_LANG4:71
for F,G1,G2 holds
  { t^s where t is Entry_Point_in_Subformula_Tree of G1,
    s is Element of dom tree_of_subformulae(G1) :
      s in G1-entry_points_in_subformula_tree_of G2 } =
  { t^s where t is Element of dom tree_of_subformulae(F),
    s is Element of dom tree_of_subformulae(G1) :
      t in F-entry_points_in_subformula_tree_of G1 &
      s in G1-entry_points_in_subformula_tree_of G2 };

theorem :: QC_LANG4:72
    for F,G1,G2 holds
  { t^s where t is Entry_Point_in_Subformula_Tree of G1,
    s is Element of dom tree_of_subformulae(G1) :
      s in G1-entry_points_in_subformula_tree_of G2 } c=
  entry_points_in_subformula_tree(G2);

reserve G1, G2 for Subformula of F,
        t1 for Entry_Point_in_Subformula_Tree of G1,
        t2 for Entry_Point_in_Subformula_Tree of G2;

theorem :: QC_LANG4:73
    (ex t1,t2 st t1 is_a_prefix_of t2) implies G2 is_subformula_of G1;

theorem :: QC_LANG4:74
    G2 is_subformula_of G1 implies for t1 ex t2 st t1 is_a_prefix_of t2;


