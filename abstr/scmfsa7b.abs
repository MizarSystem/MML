:: Constant assignment macro instructions of SCM+FSA, Part II
::  by Noriko Asamoto
::
:: Received August 27, 1996
:: Copyright (c) 1996 Association of Mizar Users

environ

 vocabulary AMI_3, AMI_1, SCMFSA_2, FINSEQ_1, RELAT_1, SCMFSA_7, ARYTM_1,
      FUNCT_1, CAT_1, SCMFSA6A, CARD_1, FUNCT_4, INT_1, FINSEQ_2, AMI_2,
      SCMFSA6B, SF_MASTR, BOOLE, DTCONSTR, ABSVALUE, AMI_5, UNIALG_2, SCMFSA_4,
      FUNCOP_1, SCMFSA7B, FINSEQ_4;
 notation TARSKI, XBOOLE_0, ENUMSET1, XCMPLX_0, XREAL_0, REAL_1, NAT_1, INT_1,
      RELAT_1, FUNCT_1, FUNCT_4, FUNCT_7, FINSEQ_1, FINSEQ_2, FINSEQ_4,
      BINARITH, FINSOP_1, FUNCOP_1, DTCONSTR, CARD_1, CQC_LANG, AMI_1, AMI_3,
      AMI_5, SCMFSA_2, SCMFSA_4, SCMFSA_7, SCMFSA6A, SF_MASTR, SCMFSA6B,
      GROUP_1;
 constructors REAL_1, FINSOP_1, ENUMSET1, BINARITH, AMI_5, SCMFSA_7, SCMFSA6A,
      SF_MASTR, SCMFSA6B, FINSEQ_4, MEMBERED;
 clusters RELSET_1, FINSEQ_1, INT_1, FUNCT_1, AMI_1, SCMFSA_2, SCMFSA_4,
      SCMFSA_7, SF_MASTR, SCMFSA6B, FUNCOP_1, CQC_LANG, NAT_1, FRAENKEL,
      XREAL_0, MEMBERED;
 requirements REAL, NUMERALS, BOOLE, SUBSET, ARITHM;


begin

reserve m for Nat;

theorem :: SCMFSA7B:1  ::TG4
 for p being FinSequence of the Instructions of SCM+FSA holds
     dom Load p = {insloc m: m < len p};

theorem :: SCMFSA7B:2  ::T83(@AAAA)
 for p being FinSequence of the Instructions of SCM+FSA holds
     rng Load p = rng p;

registration
 let p be FinSequence of the Instructions of SCM+FSA;
 cluster Load p -> initial programmed;
 coherence
  proof
A1: dom Load p = {insloc m: m < len p} by Th1;
   A2: now let k,n be Nat; assume that
A3:   insloc n in dom Load p and
A4:   k < n;
        n < len p by A3,SCMFSA_7:29;
      then k < len p by A4,AXIOMS:22;
      hence insloc k in dom Load p by A1;
     end;
     now let x be set;
      assume x in dom Load p;
      then consider m such that A5: insloc m = x & m < len p by A1;
      thus x in the Instruction-Locations of SCM+FSA by A5;
     end;
   then dom Load p c= the Instruction-Locations of SCM+FSA by TARSKI:def 3;
   hence thesis by A2,AMI_3:def 13,SCMFSA_4:def 4;
  end;
end;


theorem :: SCMFSA7B:3  ::TQ50
   for i being Instruction of SCM+FSA holds
     Load <* i *> = insloc 0 .--> i;

theorem :: SCMFSA7B:4
 for i being Instruction of SCM+FSA holds
 dom Macro i = { insloc 0, insloc 1 };

theorem :: SCMFSA7B:5  ::TQ56
 for i being Instruction of SCM+FSA holds
     Macro i = Load <* i,halt SCM+FSA *>;

theorem :: SCMFSA7B:6  ::T54(@BBB8)
 for i being Instruction of SCM+FSA holds
     card Macro i = 2;

theorem :: SCMFSA7B:7  ::T25(@BBB8)
   for i being Instruction of SCM+FSA holds
     (i = halt SCM+FSA implies (Directed Macro i).insloc 0 = goto insloc 2) &
     (i <> halt SCM+FSA implies (Directed Macro i).insloc 0 = i);

theorem :: SCMFSA7B:8  ::T26(@BBB8)
   for i being Instruction of SCM+FSA holds
     (Directed Macro i).insloc 1 = goto insloc 2;

registration
 let a be Int-Location, k be Integer;
 cluster a := k -> initial programmed;
 coherence
  proof
     a := k = Load (aSeq(a,k) ^ <* halt SCM+FSA *>) by SCMFSA_7:33;
   hence a := k is initial programmed;
  end;
end;

registration
 let a be Int-Location, k be Integer;
 cluster a := k -> parahalting;
 correctness
  proof
     now let s be State of SCM+FSA;
      assume A1: a := k +* Start-At insloc 0 c= s;
  A2: IC SCM+FSA in dom (a := k +* Start-At insloc 0) by SF_MASTR:65;
  A3: IC s = s.IC SCM+FSA by AMI_1:def 15
      .= (a := k +* Start-At insloc 0).IC SCM+FSA by A1,A2,GRFUNC_1:8
      .= insloc 0 by SF_MASTR:66;
        a := k c= s by A1,SCMFSA6B:5;
      hence s is halting by A3,Lm1;
     end;
   then a := k +* Start-At insloc 0 is halting by AMI_1:def 26;
   hence a := k is parahalting by SCMFSA6B:def 3;
  end;
end;


theorem :: SCMFSA7B:9 ::*
   for s being State of SCM+FSA
 for a being read-write Int-Location, k being Integer holds
     IExec(a := k,s).a = k &
     (for b being read-write Int-Location st b <> a holds
         IExec(a := k,s).b = s.b) &
     (for f being FinSeq-Location holds IExec(a := k,s).f = s.f);

registration
 let f be FinSeq-Location, p be FinSequence of INT;
 cluster f := p -> initial programmed;
 coherence
  proof
     f := p = Load (aSeq(intloc 1,len p) ^
            <* f :=<0,...,0> intloc 1 *> ^
            aSeq(f,p) ^
            <* halt SCM+FSA *> ) by SCMFSA_7:def 5;
   hence f := p is initial programmed;
  end;
end;


registration
 let f be FinSeq-Location, p be FinSequence of INT;
 cluster f := p -> parahalting;
 correctness
  proof
     now let s be State of SCM+FSA;
      assume A1: (f := p) +* Start-At insloc 0 c= s;
  A2: IC SCM+FSA in dom ((f := p) +* Start-At insloc 0) by SF_MASTR:65;
  A3: IC s = s.IC SCM+FSA by AMI_1:def 15
      .= ((f := p) +* Start-At insloc 0).IC SCM+FSA by A1,A2,GRFUNC_1:8
      .= insloc 0 by SF_MASTR:66;
        (f := p) c= s by A1,SCMFSA6B:5;
      hence s is halting by A3,Lm8;
     end;
   then (f := p) +* Start-At insloc 0 is halting by AMI_1:def 26;
   hence (f := p) is parahalting by SCMFSA6B:def 3;
  end;
end;


theorem :: SCMFSA7B:10 ::*TG1
   for s being State of SCM+FSA, f being FinSeq-Location,
 p being FinSequence of INT holds
     IExec(f := p,s).f = p &
     (for a being read-write Int-Location st a <> intloc 1 & a <> intloc 2
         holds IExec(f := p,s).a = s.a) &
     for g being FinSeq-Location st g <> f holds IExec(f := p,s).g = s.g;

definition
 let i be Instruction of SCM+FSA;
 let a be Int-Location;
 pred i does_not_refer a means
:: SCMFSA7B:def 1
 ::D20'
   for b being Int-Location
 for l being Instruction-Location of SCM+FSA
 for f being FinSeq-Location holds
     b := a <> i &
     AddTo(b,a) <> i &
     SubFrom(b,a) <> i &
     MultBy(b,a) <> i &
     Divide(b,a) <> i &
     Divide(a,b) <> i &
     a =0_goto l <> i &
     a >0_goto l <> i &
     b :=(f,a) <> i &
     (f,b):= a <> i &
     (f,a):= b <> i &
     f :=<0,...,0> a <> i;
end;


definition
 let I be programmed FinPartState of SCM+FSA;
 let a be Int-Location;
 pred I does_not_refer a means
:: SCMFSA7B:def 2
 ::D20
   for i being Instruction of SCM+FSA
 st i in rng I holds i does_not_refer a;
end;


definition
 let i be Instruction of SCM+FSA;
 let a be Int-Location;
 pred i does_not_destroy a means
:: SCMFSA7B:def 3
 ::D19'
 for b being Int-Location
 for f being FinSeq-Location holds
     a := b <> i &
     AddTo(a,b) <> i &
     SubFrom(a,b) <> i &
     MultBy(a,b) <> i &
     Divide(a,b) <> i &
     Divide(b,a) <> i &
     a :=(f,b) <> i &
     a :=len f <> i;
end;


definition
 let I be FinPartState of SCM+FSA;
 let a be Int-Location;
 pred I does_not_destroy a means
:: SCMFSA7B:def 4
 ::D19
 for i being Instruction of SCM+FSA
 st i in rng I holds i does_not_destroy a;
end;


definition let I be FinPartState of SCM+FSA;
 attr I is good means
:: SCMFSA7B:def 5
 ::Dg
 I does_not_destroy intloc 0;
end;


definition let I be FinPartState of SCM+FSA;
 attr I is halt-free means
:: SCMFSA7B:def 6
 ::D8
 not halt SCM+FSA in rng I;
end;


registration
 cluster halt-free good Macro-Instruction;
 existence
  proof
   set I = Load (<*>(the Instructions of SCM+FSA));
A1: card I = len <*>(the Instructions of SCM+FSA) by SCMFSA_7:25
   .= 0 by FINSEQ_1:25;
     now assume halt SCM+FSA in rng I;
      then consider x being set such that
  A2: x in dom I and I.x = halt SCM+FSA by FUNCT_1:def 5;
        dom I c= A by AMI_3:def 13;
      then consider k being Nat such that A3: x = insloc k by A2,SCMFSA_2:21;
        k < 0 by A1,A2,A3,SCMFSA6A:15;
      hence contradiction by NAT_1:18;
     end;
then A4: I is halt-free by Def6;
     now let i be Instruction of SCM+FSA;
      assume i in rng I & not i does_not_destroy intloc 0;
      then consider x being set such that
  A5: x in dom I and I.x = i by FUNCT_1:def 5;
        dom I c= A by AMI_3:def 13;
      then consider k being Nat such that A6: x = insloc k by A5,SCMFSA_2:21;
        k < 0 by A1,A5,A6,SCMFSA6A:15;
      hence contradiction by NAT_1:18;
     end;
   then I does_not_destroy intloc 0 by Def4;
   then I is good by Def5;
   hence thesis by A4;
  end;
end;


theorem :: SCMFSA7B:11  ::R0''
 for a being Int-Location holds
     halt SCM+FSA does_not_destroy a;

theorem :: SCMFSA7B:12  ::R1''
 for a,b,c being Int-Location holds
     a <> b implies b := c does_not_destroy a;

theorem :: SCMFSA7B:13  ::R2''
 for a,b,c being Int-Location holds
     a <> b implies AddTo(b,c) does_not_destroy a;

theorem :: SCMFSA7B:14  ::R3''
 for a,b,c being Int-Location holds
     a <> b implies SubFrom(b,c) does_not_destroy a;

theorem :: SCMFSA7B:15  ::R4''
   for a,b,c being Int-Location holds
     a <> b implies MultBy(b,c) does_not_destroy a;

theorem :: SCMFSA7B:16  ::R5''
   for a,b,c being Int-Location holds
     a <> b & a <> c implies Divide(b,c) does_not_destroy a;

theorem :: SCMFSA7B:17  ::R6''
   for a being Int-Location, l being Instruction-Location of SCM+FSA holds
     goto l does_not_destroy a;

theorem :: SCMFSA7B:18  ::R7''
   for a,b being Int-Location, l being Instruction-Location of SCM+FSA holds
     b =0_goto l does_not_destroy a;

theorem :: SCMFSA7B:19  ::R8''
   for a,b being Int-Location, l being Instruction-Location of SCM+FSA holds
     b >0_goto l does_not_destroy a;

theorem :: SCMFSA7B:20  ::R9''
   for a,b,c being Int-Location, f being FinSeq-Location holds
     a <> b implies b := (f,c) does_not_destroy a;

theorem :: SCMFSA7B:21  ::R10''
   for a,b,c being Int-Location, f being FinSeq-Location holds
     (f,c):= b does_not_destroy a;

theorem :: SCMFSA7B:22  ::R11''
   for a,b being Int-Location, f being FinSeq-Location holds
     a <> b implies b :=len f does_not_destroy a;

theorem :: SCMFSA7B:23  ::R12''
   for a,b being Int-Location, f being FinSeq-Location holds
     f :=<0,...,0> b does_not_destroy a;

definition
 let I be FinPartState of SCM+FSA;
 let s be State of SCM+FSA;
 pred I is_closed_on s means
:: SCMFSA7B:def 7
 ::D18
 for k being Nat holds
     IC (Computation (s +* (I +* Start-At insloc 0))).k in dom I;
 pred I is_halting_on s means
:: SCMFSA7B:def 8
 ::D18'
 s +* (I +* Start-At insloc 0) is halting;
end;


theorem :: SCMFSA7B:24  ::TQ6
 for I being Macro-Instruction holds
     I is paraclosed iff for s being State of SCM+FSA holds I is_closed_on s;

theorem :: SCMFSA7B:25 ::*TQ6'
   for I being Macro-Instruction holds
     I is parahalting iff for s being State of SCM+FSA holds I is_halting_on s;

theorem :: SCMFSA7B:26  ::TA10
 for i being Instruction of SCM+FSA, a being Int-Location,
 s being State of SCM+FSA holds
     i does_not_destroy a implies Exec(i,s).a = s.a;

theorem :: SCMFSA7B:27  ::TQ9''
 for s being State of SCM+FSA, I being Macro-Instruction, a being Int-Location
 st I does_not_destroy a & I is_closed_on s holds
     for k being Nat holds
         (Computation (s +* (I +* Start-At insloc 0))).k.a = s.a;

theorem :: SCMFSA7B:28  ::TQ7
 SCM+FSA-Stop does_not_destroy intloc 0;

registration
 cluster parahalting good Macro-Instruction;
 existence
  proof
   take SCM+FSA-Stop;
   thus thesis by Def5,Lm9,Th28;
  end;
end;


registration
 cluster SCM+FSA-Stop -> parahalting good;
 coherence by Def5,Lm9,Th28;
end;


registration
 cluster paraclosed good -> keeping_0 Macro-Instruction;
 correctness
  proof
   let I be Macro-Instruction;
   assume A1: I is paraclosed good;
then A2: I does_not_destroy intloc 0 by Def5;
     now let s be State of SCM+FSA;
      assume A3: I +* Start-At insloc 0 c= s;
      let k be Nat;
   A4: I is_closed_on s by A1,Th24;
        s +* (I +* Start-At insloc 0) = s by A3,AMI_5:10;
      hence (Computation s).k.intloc 0 = s.intloc 0 by A2,A4,Th27;
     end;
   hence I is keeping_0 by SCMFSA6B:def 4;
  end;
end;


theorem :: SCMFSA7B:29  ::TS3
 for a being Int-Location, k being Integer holds
     rng aSeq(a,k) c=
         {a := intloc 0,AddTo(a,intloc 0),SubFrom(a,intloc 0)};

theorem :: SCMFSA7B:30  ::TS1
 for a being Int-Location, k being Integer holds
     rng (a := k) c=
         {halt SCM+FSA,a := intloc 0,AddTo(a,intloc 0),SubFrom(a,intloc 0)};

registration
 let a be read-write Int-Location, k be Integer;
 cluster a := k -> good;
 correctness
  proof
     now let i be Instruction of SCM+FSA;
      assume A1: i in rng (a := k);
      A2: rng (a := k) c=
          {halt SCM+FSA,a := intloc 0,AddTo(a,intloc 0),SubFrom(a,intloc 0)}
          by Th30;
      per cases by A1,A2,ENUMSET1:18;
      suppose i = halt SCM+FSA;
       hence i does_not_destroy intloc 0 by Th11;
      end;
      suppose i = a := intloc 0;
       hence i does_not_destroy intloc 0 by Th12;
      end;
      suppose i = AddTo(a,intloc 0);
       hence i does_not_destroy intloc 0 by Th13;
      end;
      suppose i = SubFrom(a,intloc 0);
       hence i does_not_destroy intloc 0 by Th14;
     end;
     end;
   then a := k does_not_destroy intloc 0 by Def4;
   hence thesis by Def5;
  end;
end;


registration
 let a be read-write Int-Location, k be Integer;
 cluster a := k -> keeping_0;
 correctness;
end;

