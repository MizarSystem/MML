:: Constant assignment macro instructions of SCM+FSA, Part II
::  by Noriko Asamoto
::
:: Received August 27, 1996
:: Copyright (c) 1996 Association of Mizar Users

environ

 vocabularies NUMBERS, SUBSET_1, FINSEQ_1, AMI_1, SCMFSA_2, RELAT_1, SCMFSA_7,
      ARYTM_3, ARYTM_1, TARSKI, FUNCT_1, XXREAL_0, PARTFUN1, CAT_1, NAT_1,
      CARD_1, FUNCOP_1, SCMFSA6A, ORDINAL4, AMI_3, FUNCT_4, INT_1, GRAPHSP,
      FSM_1, CIRCUIT2, SCMNORM, SCMFSA6B, GLIB_000, SF_MASTR, MSUALG_1,
      XBOOLE_0, PRE_POLY, UNIALG_2, AMISTD_2, SCMFSA7B, ORDINAL1, AFINSQ_1;
 notations TARSKI, XBOOLE_0, ENUMSET1, SUBSET_1, CARD_1, NUMBERS, XCMPLX_0,
      NAT_1, INT_1, RELAT_1, FUNCT_1, PARTFUN1, FUNCT_4, FUNCT_7, FINSEQ_1,
      FINSEQ_2, NAT_D, FUNCOP_1, AFINSQ_1, AFINSQ_2, COMPOS_1, EXTPRO_1, AMI_1,
      SCMFSA_2, SCMFSA_7, SCMFSA6A, SF_MASTR, SCMFSA6B, INT_2, XXREAL_0,
      PRE_POLY;
 constructors ENUMSET1, XXREAL_0, REAL_1, AMI_5, SCMFSA_7, SCMFSA6A, SF_MASTR,
      SCMFSA6B, NAT_D, RELSET_1, PRE_POLY, DOMAIN_1, AFINSQ_2, PARTFUN3, AMI_1;
 registrations XBOOLE_0, SETFAM_1, RELAT_1, FUNCT_1, FUNCOP_1, NUMBERS,
      XXREAL_0, XREAL_0, NAT_1, INT_1, FINSEQ_1, FUNCT_7, AMI_1, SCMFSA_2,
      SF_MASTR, SCMFSA6B, ORDINAL1, FINSET_1, FINSEQ_2, CARD_1, AFINSQ_1,
      COMPOS_1, AFINSQ_2, ORDINAL5, EXTPRO_1;
 requirements REAL, NUMERALS, BOOLE, SUBSET, ARITHM;


begin

reserve m for Element of NAT;

canceled 6;

theorem :: SCMFSA7B:7
  for i being Instruction of SCM+FSA holds (i = halt SCM+FSA implies (
  Directed Macro i). 0 = goto  2) & (i <> halt SCM+FSA implies (
  Directed Macro i). 0 = i);

theorem :: SCMFSA7B:8
  for i being Instruction of SCM+FSA holds (Directed Macro i). 1 = goto  2;

registration
  let a be Int-Location, k be Integer;
  cluster a := k -> initial non empty
    NAT-defined (the Instructions of SCM+FSA)-valued;
end;

registration
  let a be Int-Location, k be Integer;
  cluster a := k -> parahalting;
end;

theorem :: SCMFSA7B:9
  for s being State of SCM+FSA for a being read-write Int-Location, k
  being Integer holds IExec(a := k,s).a = k & (for b being read-write
  Int-Location st b <> a holds IExec(a := k,s).b = s.b) & for f being
  FinSeq-Location holds IExec(a := k,s).f = s.f;

registration
  let f be FinSeq-Location, p be FinSequence of INT;
  cluster f := p -> initial non empty
  NAT-defined (the Instructions of SCM+FSA)-valued;
end;

registration
  let f be FinSeq-Location, p be FinSequence of INT;
  cluster f := p -> parahalting;
end;

theorem :: SCMFSA7B:10
  for s being State of SCM+FSA, f being FinSeq-Location, p being
  FinSequence of INT holds IExec(f := p,s).f = p & (for a being read-write
Int-Location st a <> intloc 1 & a <> intloc 2 holds IExec(f := p,s).a = s.a) &
  for g being FinSeq-Location st g <> f holds IExec(f := p,s).g = s.g;

definition
  let i be Instruction of SCM+FSA;
  let a be Int-Location;
  pred i refers a means
:: SCMFSA7B:def 1
  not for b being Int-Location for l being
Element of NAT for f being FinSeq-Location holds b := a <> i &
  AddTo(b,a) <> i & SubFrom(b,a) <> i & MultBy(b,a) <> i & Divide(b,a) <> i &
Divide(a,b) <> i & a =0_goto l <> i & a >0_goto l <> i & b :=(f,a) <> i & (f,b)
  := a <> i & (f,a):= b <> i & f :=<0,...,0> a <> i;
end;

definition
  let I be preProgram of SCM+FSA;
  let a be Int-Location;
  pred I refers a means
:: SCMFSA7B:def 2
  ex i being Instruction of SCM+FSA st i in rng I & i refers a;
end;

definition
  let i be Instruction of SCM+FSA;
  let a be Int-Location;
  pred i destroys a means
:: SCMFSA7B:def 3

  not for b being Int-Location for f being
  FinSeq-Location holds a := b <> i & AddTo(a,b) <> i & SubFrom(a,b) <> i &
  MultBy(a,b) <> i & Divide(a,b) <> i & Divide(b,a) <> i & a :=(f,b) <> i & a
  :=len f <> i;
end;

definition
  let I be FinPartState of SCM+FSA;
  let a be Int-Location;
  pred I destroys a means
:: SCMFSA7B:def 4

  ex i being Instruction of SCM+FSA st i in rng I & i destroys a;
end;

definition
  let I be FinPartState of SCM+FSA;
  attr I is good means
:: SCMFSA7B:def 5

  not I destroys intloc 0;
end;

theorem :: SCMFSA7B:11
  for a being Int-Location holds not halt SCM+FSA destroys a;

theorem :: SCMFSA7B:12
  for a,b,c being Int-Location holds a <> b implies
   not b := c destroy a;

theorem :: SCMFSA7B:13
  for a,b,c being Int-Location holds a <> b implies
  not AddTo(b,c) destroy a;

theorem :: SCMFSA7B:14
  for a,b,c being Int-Location holds a <> b implies
   not SubFrom(b,c) destroy a;

theorem :: SCMFSA7B:15
  for a,b,c being Int-Location holds a <> b implies
  not MultBy(b,c) destroy a;

theorem :: SCMFSA7B:16
  for a,b,c being Int-Location holds a <> b & a <> c implies
  not Divide(b,c) destroy a;

theorem :: SCMFSA7B:17
  for a being Int-Location, l being Element of NAT
  holds not goto l destroy a;

theorem :: SCMFSA7B:18
  for a,b being Int-Location, l being Element of NAT
  holds not b =0_goto l destroy a;

theorem :: SCMFSA7B:19
  for a,b being Int-Location, l being Element of NAT
  holds not b >0_goto l destroy a;

theorem :: SCMFSA7B:20
  for a,b,c being Int-Location, f being FinSeq-Location holds a <> b
  implies not b := (f,c) destroy a;

theorem :: SCMFSA7B:21
  for a,b,c being Int-Location, f being FinSeq-Location holds
  not (f,c):= b destroy a;

theorem :: SCMFSA7B:22
  for a,b being Int-Location, f being FinSeq-Location holds a <> b
  implies not b :=len f destroy a;

theorem :: SCMFSA7B:23
  for a,b being Int-Location, f being FinSeq-Location holds
   not f:=<0,...,0> b destroy a;

definition
  canceled;
  let I be FinPartState of SCM+FSA;
  let s be State of SCM+FSA;
  pred I is_closed_on s means
:: SCMFSA7B:def 7

  for k being Element of NAT holds IC
  Comput(ProgramPart(s +* (I +* Start-At( 0,SCM+FSA))),s +* (I +* Start-At( 0,
SCM+FSA)),k) in dom I;
  pred I is_halting_on s means
:: SCMFSA7B:def 8

  ProgramPart(s +* (I +* Start-At( 0,SCM+FSA)))
     halts_on s +* (I +* Start-At( 0,SCM+FSA));
end;

theorem :: SCMFSA7B:24
  for I being Program of SCM+FSA holds I is paraclosed iff for s
  being State of SCM+FSA holds I is_closed_on s;

theorem :: SCMFSA7B:25
  for I being Program of SCM+FSA holds I is parahalting iff for s being
  State of SCM+FSA holds I is_halting_on s;

theorem :: SCMFSA7B:26
  for i being Instruction of SCM+FSA, a being Int-Location, s
  being State of SCM+FSA holds not i destroy a implies Exec(i,s).a = s.a;

theorem :: SCMFSA7B:27
  for s being State of SCM+FSA, I being Program of SCM+FSA, a
being Int-Location st not I destroy a & I is_closed_on s holds for k being
  Element of NAT holds Comput(ProgramPart(s +* (I +* Start-At( 0,SCM+FSA))),s
+* (I +* Start-At( 0,SCM+FSA)),k).a = s.a;

registration
  cluster Stop SCM+FSA -> parahalting good;
end;

registration
  cluster parahalting good Program of SCM+FSA;
end;

registration
  cluster paraclosed good -> keeping_0 Program of SCM+FSA;
end;

canceled;

theorem :: SCMFSA7B:29
  for a being Int-Location, k being Integer holds rng aSeq(a,k) c=
  {a := intloc 0,AddTo(a,intloc 0),SubFrom(a,intloc 0)};

theorem :: SCMFSA7B:30
  for a being Int-Location, k being Integer holds rng (a := k) c=
  {halt SCM+FSA,a := intloc 0,AddTo(a,intloc 0),SubFrom(a,intloc 0)};

registration
  let a be read-write Int-Location, k be Integer;
  cluster a := k -> good;
end;

registration
  let a be read-write Int-Location, k be Integer;
  cluster a := k -> keeping_0;
end;

