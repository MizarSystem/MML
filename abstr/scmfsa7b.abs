:: Constant assignment macro instructions of SCM+FSA, Part II
::  by Noriko Asamoto
::
:: Received August 27, 1996
:: Copyright (c) 1996 Association of Mizar Users

environ

 vocabularies NUMBERS, SUBSET_1, FINSEQ_1, AMI_1, SCMFSA_2, RELAT_1, SCMFSA_7,
      ARYTM_3, ARYTM_1, TARSKI, FUNCT_1, XXREAL_0, PARTFUN1, CAT_1, NAT_1,
      CARD_1, FUNCOP_1, SCMFSA6A, ORDINAL4, AMI_3, FUNCT_4, INT_1, GRAPHSP,
      FSM_1, FINSEQ_2, CIRCUIT2, SCMNORM, SCMFSA6B, GLIB_000, SF_MASTR,
      MSUALG_1, XBOOLE_0, PRE_POLY, COMPLEX1, UNIALG_2, AMISTD_2, SCMFSA7B;
 notations TARSKI, XBOOLE_0, ENUMSET1, SUBSET_1, CARD_1, NUMBERS, XCMPLX_0,
      NAT_1, INT_1, RELAT_1, FUNCT_1, PARTFUN1, FUNCT_4, FUNCT_7, FINSEQ_1,
      FINSEQ_2, NAT_D, FUNCOP_1, AMI_1, SCMNORM, SCMFSA_2, SCMFSA_7, SCMFSA6A,
      SF_MASTR, SCMFSA6B, INT_2, XXREAL_0, PRE_POLY;
 constructors ENUMSET1, XXREAL_0, REAL_1, NAT_1, INT_2, FINSEQ_4, FINSOP_1,
      PARTFUN1, DTCONSTR, AMI_5, SCMFSA_7, SCMFSA6A, SF_MASTR, SCMFSA6B,
      SCMNORM, SCMFSA_4, AFINSQ_1, NAT_D, RELSET_1, PRE_POLY, SCMFSA_1;
 registrations XBOOLE_0, SETFAM_1, RELAT_1, FUNCT_1, FUNCOP_1, NUMBERS,
      XXREAL_0, XREAL_0, NAT_1, INT_1, FINSEQ_1, CARD_3, FUNCT_7, AMI_1,
      SCMFSA_2, SF_MASTR, SCMFSA6B, ORDINAL1, SCMNORM, FINSET_1, FINSEQ_2,
      CARD_1;
 requirements REAL, NUMERALS, BOOLE, SUBSET, ARITHM;


begin

reserve m for Element of NAT;

theorem :: SCMFSA7B:1
  for p being FinSequence of the Instructions of SCM+FSA holds dom
  Load p = { m: m < len p};

theorem :: SCMFSA7B:2
  for p being FinSequence of the Instructions of SCM+FSA holds rng
  Load p = rng p;

registration
  let p be FinSequence of the Instructions of SCM+FSA;
  cluster Load p -> initial NAT-defined;
end;

theorem :: SCMFSA7B:3
  for i being Instruction of SCM+FSA holds Load <* i *> = insloc 0 .-->
  i;

theorem :: SCMFSA7B:4
  for i being Instruction of SCM+FSA holds dom Macro i = { insloc 0
  , insloc 1 };

theorem :: SCMFSA7B:5
  for i being Instruction of SCM+FSA holds Macro i = Load <* i,halt
  SCM+FSA *>;

theorem :: SCMFSA7B:6
  for i being Instruction of SCM+FSA holds card Macro i = 2;

theorem :: SCMFSA7B:7
  for i being Instruction of SCM+FSA holds (i = halt SCM+FSA implies (
  Directed Macro i).insloc 0 = goto insloc 2) & (i <> halt SCM+FSA implies (
  Directed Macro i).insloc 0 = i);

theorem :: SCMFSA7B:8
  for i being Instruction of SCM+FSA holds (Directed Macro i).insloc 1 =
  goto insloc 2;

registration
  let a be Int-Location, k be Integer;
  cluster a := k -> initial NAT-defined;
end;

registration
  let a be Int-Location, k be Integer;
  cluster a := k -> parahalting;
end;

theorem :: SCMFSA7B:9
  for s being State of SCM+FSA for a being read-write Int-Location, k
  being Integer holds IExec(a := k,s).a = k & (for b being read-write
  Int-Location st b <> a holds IExec(a := k,s).b = s.b) & for f being
  FinSeq-Location holds IExec(a := k,s).f = s.f;

registration
  let f be FinSeq-Location, p be FinSequence of INT;
  cluster f := p -> initial NAT-defined;
end;

registration
  let f be FinSeq-Location, p be FinSequence of INT;
  cluster f := p -> parahalting;
end;

theorem :: SCMFSA7B:10
  for s being State of SCM+FSA, f being FinSeq-Location, p being
  FinSequence of INT holds IExec(f := p,s).f = p & (for a being read-write
Int-Location st a <> intloc 1 & a <> intloc 2 holds IExec(f := p,s).a = s.a) &
  for g being FinSeq-Location st g <> f holds IExec(f := p,s).g = s.g;

definition
  let i be Instruction of SCM+FSA;
  let a be Int-Location;
  pred i does_not_refer a means
:: SCMFSA7B:def 1
  for b being Int-Location for l being
Instruction-Location of SCM+FSA for f being FinSeq-Location holds b := a <> i &
  AddTo(b,a) <> i & SubFrom(b,a) <> i & MultBy(b,a) <> i & Divide(b,a) <> i &
Divide(a,b) <> i & a =0_goto l <> i & a >0_goto l <> i & b :=(f,a) <> i & (f,b)
  := a <> i & (f,a):= b <> i & f :=<0,...,0> a <> i;
end;

definition
  let I be preProgram of SCM+FSA;
  let a be Int-Location;
  pred I does_not_refer a means
:: SCMFSA7B:def 2
  for i being Instruction of SCM+FSA st i in rng
  I holds i does_not_refer a;
end;

definition
  let i be Instruction of SCM+FSA;
  let a be Int-Location;
  pred i does_not_destroy a means
:: SCMFSA7B:def 3

  for b being Int-Location for f being
  FinSeq-Location holds a := b <> i & AddTo(a,b) <> i & SubFrom(a,b) <> i &
  MultBy(a,b) <> i & Divide(a,b) <> i & Divide(b,a) <> i & a :=(f,b) <> i & a
  :=len f <> i;
end;

definition
  let I be FinPartState of SCM+FSA;
  let a be Int-Location;
  pred I does_not_destroy a means
:: SCMFSA7B:def 4

  for i being Instruction of SCM+FSA st
  i in rng I holds i does_not_destroy a;
end;

definition
  let I be FinPartState of SCM+FSA;
  attr I is good means
:: SCMFSA7B:def 5

  I does_not_destroy intloc 0;
end;

registration
  cluster halt-free good Program of SCM+FSA;
end;

theorem :: SCMFSA7B:11
  for a being Int-Location holds halt SCM+FSA does_not_destroy a;

theorem :: SCMFSA7B:12
  for a,b,c being Int-Location holds a <> b implies b := c
  does_not_destroy a;

theorem :: SCMFSA7B:13
  for a,b,c being Int-Location holds a <> b implies AddTo(b,c)
  does_not_destroy a;

theorem :: SCMFSA7B:14
  for a,b,c being Int-Location holds a <> b implies SubFrom(b,c)
  does_not_destroy a;

theorem :: SCMFSA7B:15
  for a,b,c being Int-Location holds a <> b implies MultBy(b,c)
  does_not_destroy a;

theorem :: SCMFSA7B:16
  for a,b,c being Int-Location holds a <> b & a <> c implies Divide(b,c)
  does_not_destroy a;

theorem :: SCMFSA7B:17
  for a being Int-Location, l being Instruction-Location of SCM+FSA
  holds goto l does_not_destroy a;

theorem :: SCMFSA7B:18
  for a,b being Int-Location, l being Instruction-Location of SCM+FSA
  holds b =0_goto l does_not_destroy a;

theorem :: SCMFSA7B:19
  for a,b being Int-Location, l being Instruction-Location of SCM+FSA
  holds b >0_goto l does_not_destroy a;

theorem :: SCMFSA7B:20
  for a,b,c being Int-Location, f being FinSeq-Location holds a <> b
  implies b := (f,c) does_not_destroy a;

theorem :: SCMFSA7B:21
  for a,b,c being Int-Location, f being FinSeq-Location holds (f,c):= b
  does_not_destroy a;

theorem :: SCMFSA7B:22
  for a,b being Int-Location, f being FinSeq-Location holds a <> b
  implies b :=len f does_not_destroy a;

theorem :: SCMFSA7B:23
  for a,b being Int-Location, f being FinSeq-Location holds f
  :=<0,...,0> b does_not_destroy a;

definition
  canceled;
  let I be FinPartState of SCM+FSA;
  let s be State of SCM+FSA;
  pred I is_closed_on s means
:: SCMFSA7B:def 7

  for k being Element of NAT holds IC
  Computation (s +* (I +* Start-At insloc 0),k) in dom I;
  pred I is_halting_on s means
:: SCMFSA7B:def 8

  ProgramPart(s +* (I +* Start-At insloc 0))
     halts_on s +* (I +* Start-At insloc 0);
end;

theorem :: SCMFSA7B:24
  for I being Program of SCM+FSA holds I is paraclosed iff for s
  being State of SCM+FSA holds I is_closed_on s;

theorem :: SCMFSA7B:25
  for I being Program of SCM+FSA holds I is parahalting iff for s being
  State of SCM+FSA holds I is_halting_on s;

theorem :: SCMFSA7B:26
  for i being Instruction of SCM+FSA, a being Int-Location, s
  being State of SCM+FSA holds i does_not_destroy a implies Exec(i,s).a = s.a;

theorem :: SCMFSA7B:27
  for s being State of SCM+FSA, I being Program of SCM+FSA, a
being Int-Location st I does_not_destroy a & I is_closed_on s holds for k being
  Element of NAT holds Computation (s +* (I +* Start-At insloc 0),k).a = s.a;

theorem :: SCMFSA7B:28
  Stop SCM+FSA does_not_destroy intloc 0;

registration
  cluster parahalting good Program of SCM+FSA;
end;

registration
  cluster Stop SCM+FSA -> parahalting good;
end;

registration
  cluster paraclosed good -> keeping_0 Program of SCM+FSA;
end;

theorem :: SCMFSA7B:29
  for a being Int-Location, k being Integer holds rng aSeq(a,k) c=
  {a := intloc 0,AddTo(a,intloc 0),SubFrom(a,intloc 0)};

theorem :: SCMFSA7B:30
  for a being Int-Location, k being Integer holds rng (a := k) c=
  {halt SCM+FSA,a := intloc 0,AddTo(a,intloc 0),SubFrom(a,intloc 0)};

registration
  let a be read-write Int-Location, k be Integer;
  cluster a := k -> good;
end;

registration
  let a be read-write Int-Location, k be Integer;
  cluster a := k -> keeping_0;
end;

