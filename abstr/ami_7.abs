:: Input and Output of Instructions
::  by Artur Korni{\l}owicz
::
:: Received May 8, 2001
:: Copyright (c) 2001 Association of Mizar Users

environ

 vocabulary AMI_3, AMI_1, BOOLE, CAT_1, FUNCT_1, RELAT_1, FUNCT_4, GOBOARD5,
      FRECHET, AMISTD_1, REALSET1, FUNCOP_1, AMISTD_2, CARD_5, NET_1, AMI_5,
      AMI_2, INT_1, FINSEQ_1, ARYTM_1, SQUARE_1, ARYTM_3, NAT_1, AMI_7;
 notation TARSKI, XBOOLE_0, ENUMSET1, SUBSET_1, RELAT_1, FUNCT_1, REALSET1,
      NUMBERS, XCMPLX_0, XREAL_0, SQUARE_1, FINSEQ_1, FUNCOP_1, CQC_LANG,
      INT_1, NAT_1, FUNCT_4, STRUCT_0, AMI_1, AMI_2, AMI_3, AMI_5, FUNCT_7,
      AMISTD_1, AMISTD_2;
 constructors DOMAIN_1, FUNCT_7, NAT_1, AMI_5, SQUARE_1, AMISTD_2, REALSET1,
      PRE_CIRC;
 clusters AMI_1, XREAL_0, INT_1, AMISTD_1, SCMRING1, AMI_6, AMISTD_2, RELSET_1,
      FUNCOP_1, WAYBEL12, SCMRING3, SQUARE_1, XBOOLE_0, FRAENKEL;
 requirements NUMERALS, SUBSET, BOOLE, REAL, ARITHM;


begin :: Preliminaries

reserve N for with_non-empty_elements set;

theorem :: AMI_7:1
 for x, y, z being set st x <> y & x <> z holds {x, y, z} \ {x} = {y, z};

theorem :: AMI_7:2
  for A being non empty non void AMI-Struct over N,
      s being State of A,
      o being Object of A holds
   s.o in ObjectKind o;

theorem :: AMI_7:3
   for A being realistic IC-Ins-separated definite
       (non empty non void AMI-Struct over N),
     s being State of A,
     f being Instruction-Location of A,
     w being Element of ObjectKind IC A
  holds (s+*(IC A,w)).f = s.f;

definition
  let N be with_non-empty_elements set,
      A be IC-Ins-separated definite (non empty non void AMI-Struct over N),
      s be State of A,
      o be Object of A,
      a be Element of ObjectKind o;
 redefine func s+*(o,a) -> State of A;
end;


theorem :: AMI_7:4
 for A being steady-programmed IC-Ins-separated definite
       (non empty non void AMI-Struct over N),
     s being State of A,
     o being Object of A,
     f being Instruction-Location of A,
     I being Instruction of A,
     w being Element of ObjectKind o
   st f <> o
   holds Exec(I,s).f = Exec(I,s+*(o,w)).f;

theorem :: AMI_7:5
 for A being IC-Ins-separated definite (non empty non void AMI-Struct over N),
     s being State of A,
     o being Object of A,
     w being Element of ObjectKind o
    st o <> IC A
  holds IC s = IC (s+*(o,w));

theorem :: AMI_7:6
 for A being standard (IC-Ins-separated definite
       (non empty non void AMI-Struct over N)),
     I being Instruction of A,
     s being State of A,
     o being Object of A,
     w being Element of ObjectKind o
    st I is sequential & o <> IC A
  holds IC Exec(I,s) = IC Exec(I,s+*(o,w));

theorem :: AMI_7:7
 for A being standard (IC-Ins-separated definite
       (non empty non void AMI-Struct over N)),
     I being Instruction of A,
     s being State of A,
     o being Object of A,
     w being Element of ObjectKind o
    st I is sequential & o <> IC A
  holds IC Exec(I,s+*(o,w)) = IC (Exec(I,s) +* (o,w));

theorem :: AMI_7:8
 for A being standard steady-programmed
       (IC-Ins-separated definite (non empty non void AMI-Struct over N)),
     I being Instruction of A,
     s being State of A,
     o being Object of A,
     w being Element of ObjectKind o,
     i being Instruction-Location of A
  holds Exec(I,s+*(o,w)).i = (Exec(I,s) +* (o,w)).i;

begin :: Input and Output of Instructions

definition
   let N be set,
       A be AMI-Struct over N;
 attr A is with_non_trivial_Instructions means
:: AMI_7:def 1

  the Instructions of A is non trivial;
end;


definition
   let N be set,
       A be non empty AMI-Struct over N;
 attr A is with_non_trivial_ObjectKinds means
:: AMI_7:def 2

  for o being Object of A holds ObjectKind o is non trivial;
end;


registration
   let N be with_non-empty_elements set;
 cluster STC N -> with_non_trivial_ObjectKinds;
coherence
  proof
    let o be Object of STC N;
A1: the carrier of STC N = NAT \/ {NAT} by AMISTD_1:def 11;
A2: the Object-Kind of STC N =
       (NAT --> {[1,0],[0,0]}) +* ({NAT} --> NAT) by AMISTD_1:def 11;
A3: ObjectKind o = (the Object-Kind of STC N).o by AMI_1:def 6;
A4: dom ({NAT} --> NAT) = {NAT} by FUNCOP_1:19;
    per cases by A1,XBOOLE_0:def 2;
    suppose
A5:   o in NAT;
    then o <> NAT;
    then not o in dom ({NAT} --> NAT) by A4,TARSKI:def 1;
then A6: ObjectKind o = (NAT --> {[1,0],[0,0]}).o by A2,A3,FUNCT_4:12
      .= {[1,0],[0,0]} by A5,FUNCOP_1:13;
A7: [1,0] <> [0,0] by ZFMISC_1:33;
      [1,0] in {[1,0],[0,0]} & [0,0] in {[1,0],[0,0]} by TARSKI:def 2;
    hence ObjectKind o is non trivial by A6,A7,YELLOW_8:def 1;
    end;
    suppose
A8:   o in {NAT};
    then ObjectKind o = ({NAT} --> NAT).o by A2,A3,A4,FUNCT_4:14
      .= NAT by A8,FUNCOP_1:13;
    hence ObjectKind o is non trivial;
  end;
  end;
end;


registration
   let N be with_non-empty_elements set;
 cluster halting realistic steady-programmed programmable
         with_explicit_jumps without_implicit_jumps
         IC-good Exec-preserving
         with_non_trivial_ObjectKinds with_non_trivial_Instructions
         (regular standard (IC-Ins-separated definite
         (non empty non void AMI-Struct over N)));
existence
  proof
    take STC N;
      STC N is with_non_trivial_Instructions
    proof
A1:   the Instructions of STC N = {[0,0],[1,0]} by AMISTD_1:def 11;
A2:   [1,0] <> [0,0] by ZFMISC_1:33;
        [1,0] in {[1,0],[0,0]} & [0,0] in {[1,0],[0,0]} by TARSKI:def 2;
      hence the Instructions of STC N is non trivial by A1,A2,YELLOW_8:def 1;
    end;
    hence thesis;
  end;
end;


registration
   let N be with_non-empty_elements set;
 cluster with_non_trivial_ObjectKinds -> with_non_trivial_Instructions
         (definite (non empty non void AMI-Struct over N));
coherence
  proof
    let A be definite (non empty non void AMI-Struct over N);
    assume
A1:   for o being Object of A holds ObjectKind o is non trivial;
    consider l being Instruction-Location of A;
      ObjectKind l = the Instructions of A by AMI_1:def 14;
    hence the Instructions of A is non trivial by A1;
  end;
end;


registration
   let N be with_non-empty_elements set;
 cluster with_non_trivial_ObjectKinds ->
         with-non-trivial-Instruction-Locations
         (IC-Ins-separated (non empty AMI-Struct over N));
coherence
  proof
    let A be IC-Ins-separated (non empty AMI-Struct over N);
    assume
A1:   for o being Object of A holds ObjectKind o is non trivial;
      ObjectKind IC A = the Instruction-Locations of A by AMI_1:def 11;
    hence the Instruction-Locations of A is non trivial by A1;
  end;
end;


registration
   let N be with_non-empty_elements set,
       A be with_non_trivial_ObjectKinds (non empty AMI-Struct over N),
       o be Object of A;
 cluster ObjectKind o -> non trivial;
coherence by Def2;
end;


registration
   let N be with_non-empty_elements set,
       A be with_non_trivial_Instructions AMI-Struct over N;
 cluster the Instructions of A -> non trivial;
coherence by Def1;
end;


registration
   let N be with_non-empty_elements set,
       A be with-non-trivial-Instruction-Locations
            IC-Ins-separated (non empty AMI-Struct over N);
 cluster ObjectKind IC A -> non trivial;
coherence by AMI_1:def 11;
end;


definition
  let N be with_non-empty_elements set,
      A be non empty non void AMI-Struct over N,
      I be Instruction of A;
 func Output I -> Subset of A means
:: AMI_7:def 3

  for o being Object of A holds o in it iff
   ex s being State of A st s.o <> Exec(I,s).o;
end;


definition
  let N be with_non-empty_elements set,
      A be IC-Ins-separated definite (non empty non void AMI-Struct over N),
      I be Instruction of A;
 func Out_\_Inp I -> Subset of A means
:: AMI_7:def 4

  for o being Object of A holds o in it iff
   for s being State of A, a being Element of ObjectKind o
    holds Exec(I,s) = Exec(I,s+*(o,a));

 func Out_U_Inp I -> Subset of A means
:: AMI_7:def 5

  for o being Object of A holds o in it iff
   ex s being State of A, a being Element of ObjectKind o
    st Exec(I,s+*(o,a)) <> Exec(I,s) +* (o,a);
end;


definition
  let N be with_non-empty_elements set,
      A be IC-Ins-separated definite (non empty non void AMI-Struct over N),
      I be Instruction of A;
 func Input I -> Subset of A equals
:: AMI_7:def 6

  Out_U_Inp I \ Out_\_Inp I;
end;


theorem :: AMI_7:9
 for A being IC-Ins-separated definite (non empty non void AMI-Struct over N),
     I being Instruction of A holds
  Out_\_Inp I misses Input I;

theorem :: AMI_7:10
 for A being with_non_trivial_ObjectKinds IC-Ins-separated definite
             (non empty non void AMI-Struct over N),
     I being Instruction of A holds
  Out_\_Inp I c= Output I;

theorem :: AMI_7:11
 for A being IC-Ins-separated definite (non empty non void AMI-Struct over N),
     I being Instruction of A holds
  Output I c= Out_U_Inp I;

theorem :: AMI_7:12
 for A being IC-Ins-separated definite (non empty non void AMI-Struct over N),
     I being Instruction of A holds
  Input I c= Out_U_Inp I;

theorem :: AMI_7:13
   for A being with_non_trivial_ObjectKinds IC-Ins-separated definite
             (non empty non void AMI-Struct over N),
     I being Instruction of A holds
  Out_\_Inp I = Output I \ Input I;

theorem :: AMI_7:14
   for A being with_non_trivial_ObjectKinds IC-Ins-separated definite
             (non empty non void AMI-Struct over N),
     I being Instruction of A holds
  Out_U_Inp I = Output I \/ Input I;

theorem :: AMI_7:15
 for A being IC-Ins-separated definite (non empty non void AMI-Struct over N),
     I being Instruction of A,
     o being Object of A st ObjectKind o is trivial
  holds not o in Out_U_Inp I;

theorem :: AMI_7:16
   for A being IC-Ins-separated definite (non empty non void AMI-Struct over N)
,
     I being Instruction of A,
     o being Object of A st ObjectKind o is trivial
  holds not o in Input I;

theorem :: AMI_7:17
   for A being IC-Ins-separated definite (non empty non void AMI-Struct over N)
,
     I being Instruction of A,
     o being Object of A st ObjectKind o is trivial
  holds not o in Output I;

theorem :: AMI_7:18
 for A being IC-Ins-separated definite (non empty non void AMI-Struct over N),
     I being Instruction of A holds
   I is halting iff Output I is empty;

theorem :: AMI_7:19
 for A being with_non_trivial_ObjectKinds IC-Ins-separated definite
             (non empty non void AMI-Struct over N),
     I being Instruction of A st I is halting
  holds Out_\_Inp I is empty;

theorem :: AMI_7:20
 for A being IC-Ins-separated definite (non empty non void AMI-Struct over N),
     I being Instruction of A st I is halting
  holds Out_U_Inp I is empty;

theorem :: AMI_7:21
 for A being IC-Ins-separated definite (non empty non void AMI-Struct over N),
     I being Instruction of A st I is halting
  holds Input I is empty;

registration
   let N be with_non-empty_elements set,
       A be halting IC-Ins-separated definite
         (non empty non void AMI-Struct over N),
       I be halting Instruction of A;
 cluster Input I -> empty;
coherence by Th21;
 cluster Output I -> empty;
coherence by Th18;
 cluster Out_U_Inp I -> empty;
coherence by Th20;
end;


registration
   let N be with_non-empty_elements set,
       A be halting with_non_trivial_ObjectKinds IC-Ins-separated definite
            (non empty non void AMI-Struct over N),
       I be halting Instruction of A;
 cluster Out_\_Inp I -> empty;
coherence by Th19;
end;


theorem :: AMI_7:22
 for A being with_non_trivial_Instructions steady-programmed IC-Ins-separated
             definite (non empty non void AMI-Struct over N),
     f being Instruction-Location of A,
     I being Instruction of A
  holds not f in Out_\_Inp I;

theorem :: AMI_7:23
 for A being standard (IC-Ins-separated definite
       (non empty non void AMI-Struct over N)),
     I being Instruction of A st I is sequential
  holds not IC A in Out_\_Inp I;

theorem :: AMI_7:24
 for A being IC-Ins-separated definite (non empty non void AMI-Struct over N),
     I being Instruction of A st
   ex s being State of A st Exec(I,s).IC A <> IC s
  holds IC A in Output I;

theorem :: AMI_7:25
 for A being standard (IC-Ins-separated definite
       (non empty non void AMI-Struct over N)),
     I being Instruction of A st I is sequential
  holds IC A in Output I;

theorem :: AMI_7:26
 for A being IC-Ins-separated definite (non empty non void AMI-Struct over N),
     I being Instruction of A st
   ex s being State of A st Exec(I,s).IC A <> IC s
  holds IC A in Out_U_Inp I;

theorem :: AMI_7:27
 for A being standard (IC-Ins-separated definite
       (non empty non void AMI-Struct over N)),
     I being Instruction of A st I is sequential
  holds IC A in Out_U_Inp I;

theorem :: AMI_7:28
 for A being IC-Ins-separated definite (non empty non void AMI-Struct over N),
     f being Instruction-Location of A,
     I being Instruction of A
  st for s being State of A, p being programmed FinPartState of A
      holds Exec (I, s +* p) = Exec (I,s) +* p
 holds not f in Out_U_Inp I;

theorem :: AMI_7:29
   for A being IC-Ins-separated definite (non empty non void AMI-Struct over N)
,
     I being Instruction of A,
     o being Object of A st I is jump-only
  holds o in Output I implies o = IC A;

begin  :: SCM

reserve a, b for Data-Location,
        f for Instruction-Location of SCM,
        I for Instruction of SCM;

theorem :: AMI_7:30
 for s being State of SCM, w being Element of ObjectKind IC SCM
  holds (s+*(IC SCM,w)).a = s.a;

theorem :: AMI_7:31
 f <> Next f;

definition
  let s be State of SCM, dl be Data-Location, k be Integer;
 redefine func s+*(dl,k) -> State of SCM;
end;

registration
 cluster SCM -> with_non_trivial_ObjectKinds;
coherence
  proof
    let o be Object of SCM;
    per cases by AMI_6:3;
    suppose o = IC SCM;
    hence thesis by AMI_1:def 11;
    end;
    suppose o is Instruction-Location of SCM;
then A1: ObjectKind o = the Instructions of SCM by AMI_1:def 14;
    consider a, b being Data-Location;
      AddTo(a,b) = [2, <*a,b*>] & SubFrom(a,b) = [3, <*a,b*>]
      by AMI_3:def 4,def 5;
    then AddTo(a,b) <> SubFrom(a,b) by ZFMISC_1:33;
    hence thesis by A1,YELLOW_8:def 1;
    end;
    suppose o is Data-Location;
    hence thesis by AMI_3:55;
  end;
  end;
end;


theorem :: AMI_7:32
 Out_\_Inp (a:=a) = {};

theorem :: AMI_7:33
 a <> b implies Out_\_Inp (a:=b) = { a };

theorem :: AMI_7:34
 Out_\_Inp AddTo(a,b) = {};

theorem :: AMI_7:35
 Out_\_Inp SubFrom(a,a) = { a };

theorem :: AMI_7:36
 a <> b implies Out_\_Inp SubFrom(a,b) = {};

theorem :: AMI_7:37
 Out_\_Inp MultBy(a,b) = {};

theorem :: AMI_7:38
 Out_\_Inp Divide(a,a) = { a };

theorem :: AMI_7:39
 a <> b implies Out_\_Inp Divide(a,b) = {};

theorem :: AMI_7:40
 Out_\_Inp goto f = { IC SCM };

theorem :: AMI_7:41
 Out_\_Inp (a =0_goto f) = {};

theorem :: AMI_7:42
  Out_\_Inp (a >0_goto f) = {};

theorem :: AMI_7:43
   Output (a:=a) = { IC SCM };

theorem :: AMI_7:44
 a <> b implies Output (a:=b) = { a, IC SCM };

theorem :: AMI_7:45
 Output AddTo(a,b) = { a, IC SCM };

theorem :: AMI_7:46
 Output SubFrom(a,b) = { a, IC SCM };

theorem :: AMI_7:47
 Output MultBy(a,b) = { a, IC SCM };

theorem :: AMI_7:48
 Output Divide(a,b) = { a, b, IC SCM };

theorem :: AMI_7:49
 Output goto f = { IC SCM };

theorem :: AMI_7:50
 Output (a =0_goto f) = { IC SCM };

theorem :: AMI_7:51
 Output (a >0_goto f) = { IC SCM };

theorem :: AMI_7:52
 not f in Out_U_Inp I;

theorem :: AMI_7:53
 Out_U_Inp (a:=a) = { IC SCM };

theorem :: AMI_7:54
 a <> b implies Out_U_Inp (a:=b) = { a, b, IC SCM };

theorem :: AMI_7:55
 Out_U_Inp AddTo(a,b) = { a, b, IC SCM };

theorem :: AMI_7:56
 Out_U_Inp SubFrom(a,b) = { a, b, IC SCM };

theorem :: AMI_7:57
 Out_U_Inp MultBy(a,b) = { a, b, IC SCM };

theorem :: AMI_7:58
 Out_U_Inp Divide(a,b) = { a, b, IC SCM };

theorem :: AMI_7:59
 Out_U_Inp (goto f) = { IC SCM };

theorem :: AMI_7:60
 Out_U_Inp (a =0_goto f) = { a, IC SCM };

theorem :: AMI_7:61
 Out_U_Inp (a >0_goto f) = { a, IC SCM };

theorem :: AMI_7:62
   Input (a:=a) = { IC SCM };

theorem :: AMI_7:63
   a <> b implies Input (a:=b) = { b, IC SCM };

theorem :: AMI_7:64
   Input AddTo(a,b) = { a, b, IC SCM };

theorem :: AMI_7:65
   Input SubFrom(a,a) = { IC SCM };

theorem :: AMI_7:66
   a <> b implies Input SubFrom(a,b) = { a, b, IC SCM };

theorem :: AMI_7:67
   Input MultBy(a,b) = { a, b, IC SCM };

theorem :: AMI_7:68
   Input Divide(a,a) = { IC SCM };

theorem :: AMI_7:69
   a <> b implies Input Divide(a,b) = { a, b, IC SCM };

theorem :: AMI_7:70
   Input goto f = {};

theorem :: AMI_7:71
   Input (a =0_goto f) = { a, IC SCM };

theorem :: AMI_7:72
   Input (a >0_goto f) = { a, IC SCM };
