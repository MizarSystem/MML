:: The Sum and Product of Finite Sequences of Real Numbers
::  by Czes{\l}aw Byli\'nski
::
:: Received May 11, 1990
:: Copyright (c) 1990 Association of Mizar Users

environ

 vocabularies FINSEQ_1, FINSEQ_2, ARYTM_1, FUNCT_1, RELAT_1, BINOP_1, VECTSP_1,
      SETWISEO, SQUARE_1, ARYTM, FUNCOP_1, FINSEQOP, RLVECT_1, RVSUM_1, CARD_3,
      BOOLE, COMPLEX1, COMPLSP1, SEQ_1, XCMPLX_0, SUBSET_1;
 notations TARSKI, SUBSET_1, ZFMISC_1, ORDINAL1, NUMBERS, XBOOLE_0, XCMPLX_0,
      XXREAL_0, XREAL_0, REAL_1, NAT_1, SQUARE_1, RELAT_1, FUNCT_1, RELSET_1,
      PARTFUN1, BINOP_2, FINSUB_1, SETWISEO, FUNCT_2, BINOP_1, FUNCOP_1,
      FINSEQ_1, FUNCT_4, FINSEQ_2, FINSEQ_4, SEQ_1, FINSEQOP, SETWOP_2;
 constructors NAT_1, SQUARE_1, BINOP_1, SETWISEO, FINSEQOP, FINSOP_1, FINSEQ_4,
      SEQ_2, PARTFUN1, BINOP_2, XXREAL_0, FUNCT_4, XCMPLX_0, FINSUB_1,
      FINSET_1, SETWOP_2;
 registrations RELSET_1, FINSEQ_2, NAT_1, MEMBERED, FUNCT_1, FUNCT_2, BINOP_2,
      XCMPLX_0, XREAL_0, SQUARE_1, FUNCOP_1, ORDINAL2, FINSEQ_1;
 requirements NUMERALS, SUBSET, BOOLE, ARITHM;
 definitions BINOP_1, FINSEQOP, FINSEQ_1, SQUARE_1, BINOP_2, FINSEQ_2;
 theorems SQUARE_1, FUNCT_1, FUNCT_2, BINOP_1, FINSEQ_1, FUNCOP_1, FINSEQ_2,
      FINSEQOP, SETWOP_2, RELAT_1, FINSOP_1, XREAL_0, ZFMISC_1, XCMPLX_0,
      XCMPLX_1, BINOP_2, SETWISEO, XREAL_1, SEQ_1, NUMBERS, XBOOLE_1, FINSEQ_3,
      XXREAL_0;
 schemes NAT_1, FUNCT_2;

begin :: Auxiliary theorems

BIN2: for a, b being real number holds
   multreal.(a,b) = a * b
  proof
    let a, b be real number;
    reconsider a' = a, b' = b as Element of REAL by XREAL_0:def 1;
    multreal.(a',b') = a' * b' by BINOP_2:def 11;
    hence thesis;
  end;

BIN3: for a, b being complex number holds
   multcomplex.(a,b) = a * b
  proof
    let a, b be complex number;
    reconsider a' = a, b' = b as Element of COMPLEX by XCMPLX_0:def 2;
    multcomplex.(a',b') = a' * b' by BINOP_2:def 5;
    hence thesis;
  end;

 reserve i,j,k for Nat;
 reserve x,x1,x2,x3,r,r1,r2,r3 for Element of REAL;
 reserve F,F',F1,F2 for FinSequence of REAL;
 reserve R,R1,R2,R3 for Element of i-tuples_on REAL;

canceled 2;

theorem Th3:
  0 is_a_unity_wrt addreal by BINOP_2:2,SETWISEO:22;

definition
  redefine func diffreal equals :Def1:
    addreal*(id REAL,compreal);
  compatibility
   proof let b be BinOp of REAL;
     now let r1,r2 be Element of REAL;
      thus diffreal.(r1,r2) = r1 - r2 by BINOP_2:def 10
          .= r1 + - r2
          .= addreal.(r1,- r2) by BINOP_2:def 9
          .= addreal.(r1,compreal.r2) by BINOP_2:def 7
          .= (addreal*(id REAL,compreal)).(r1,r2) by FINSEQOP:87;
     end;
    hence thesis by BINOP_1:2;
   end;
  correctness;
end;

Lm1: diffreal.(r1,r2) = r1 - r2 by BINOP_2:def 10;

definition
 func sqrreal -> UnOp of REAL means
:Def2: for r holds it.r = r^2;
  existence
 proof
  deffunc F(Element of REAL) = ($1)^2;
  consider G being Function of REAL,REAL such that
A1: for x being Element of REAL holds G.x = F(x) from FUNCT_2:sch 4;
  take G; let r; thus G.r = (r)^2 by A1;
 end;
  uniqueness
 proof let G1,G2 be UnOp of REAL such that
A2: (for r holds G1.r = r^2) & for r holds G2.r = r^2;
     now let x;  G1.(x) = (x)^2 & G2.(x) = (x)^2 & x = x by A2;
   hence G1.x = G2.x;
  end;
  hence thesis by FUNCT_2:113;
 end;
end;

canceled 9;

theorem
  1 is_a_unity_wrt multreal by BINOP_2:7,SETWISEO:22;

canceled 2;

theorem Th16:
  multreal is_distributive_wrt addreal
 proof
  now let x1,x2,x3;
   thus multreal.(x1,addreal.(x2,x3))
      = multreal.(x1,x2+x3) by BINOP_2:def 9
     .= x1*(x2+x3) by BINOP_2:def 11
     .= x1*x2+x1*x3
     .= addreal.(x1*x2,x1*x3) by BINOP_2:def 9
     .= addreal.(multreal.(x1,x2),x1*x3) by BINOP_2:def 11
     .= addreal.(multreal.(x1,x2),multreal.(x1,x3)) by BINOP_2:def 11;
   thus multreal.(addreal.(x1,x2),x3)
      = multreal.(x1+x2,x3) by BINOP_2:def 9
     .= (x1+x2)*x3 by BINOP_2:def 11
     .= x1*x3+x2*x3
     .= addreal.(x1*x3,x2*x3) by BINOP_2:def 9
     .= addreal.(multreal.(x1,x3),x2*x3) by BINOP_2:def 11
     .= addreal.(multreal.(x1,x3),multreal.(x2,x3)) by BINOP_2:def 11;
  end;
  hence thesis by BINOP_1:23;
 end;

theorem Th17:
  sqrreal is_distributive_wrt multreal
 proof let x1,x2;
   thus sqrreal.(multreal.(x1,x2))
      = sqrreal.(x1*x2) by BINOP_2:def 11
     .= (x1*x2)^2 by Def2
     .= x1^2*x2^2
     .= multreal.(x1^2,x2^2) by BINOP_2:def 11
     .= multreal.(sqrreal.x1,x2^2) by Def2
     .= multreal.(sqrreal.x1,sqrreal.x2) by Def2;
 end;

definition let x be real number;
 func x multreal -> UnOp of REAL equals
 multreal[;](x,id REAL);
 coherence
   proof
     reconsider y = x as Real by XREAL_0:def 1;
     multreal[;](y,id REAL) is UnOp of REAL;
     hence thesis;
   end;
end;

Lm2: (multreal[;](r,id REAL)).x = r*x
 proof
  thus (multreal[;](r,id REAL)).x = multreal.(r,(id REAL).x) by FUNCOP_1:66
                               .= multreal.(r,x) by FUNCT_1:35
                               .= r*x by BINOP_2:def 11;
 end;

canceled;

theorem
  (r multreal).x = r*x by Lm2;

theorem Th20:
  r multreal is_distributive_wrt addreal by Th16,FINSEQOP:55;

theorem Th21:
  compreal is_an_inverseOp_wrt addreal
 proof let x;
   thus addreal.(x,compreal.x) = x+compreal.x by BINOP_2:def 9
                              .= x+-x by BINOP_2:def 7
                              .= the_unity_wrt addreal by Th3,BINOP_1:def 8;
   thus addreal.(compreal.x,x) = compreal.x+x by BINOP_2:def 9
                              .= -x+x by BINOP_2:def 7
                              .= the_unity_wrt addreal by Th3,BINOP_1:def 8;
 end;

theorem Th22:
  addreal has_an_inverseOp by Th21,FINSEQOP:def 2;

theorem Th23:
  the_inverseOp_wrt addreal = compreal by Th21,Th22,FINSEQOP:def 3;

theorem
  compreal is_distributive_wrt addreal by Th22,Th23,FINSEQOP:67;

:: Some Functors on the i-tuples on Real

definition let F1,F2;
  func F1 + F2 -> FinSequence of REAL equals
  addreal.:(F1,F2);
  correctness;
 commutativity
  proof let F,F1,F2 be FinSequence of REAL;
   assume
A1:  F = addreal.:(F1,F2);
A2:  dom addreal = [:REAL,REAL:] by FUNCT_2:def 1;
A5:  [:rng F2, rng F1:] c= dom addreal by A2,ZFMISC_1:119;
     [:rng F1, rng F2:] c= dom addreal by A2,ZFMISC_1:119;
    then A6:  dom(addreal.:(F1,F2)) = dom F1 /\ dom F2 by FUNCOP_1:84
          .= dom(addreal.:(F2,F1)) by A5,FUNCOP_1:84;
       for z being set st z in dom(addreal.:(F2,F1))
       holds F.z = addreal.(F2.z,F1.z)
     proof let z be set such that
A7:    z in dom(addreal.:(F2,F1));
       set F1z = F1.z, F2z =F2.z;
      thus F.z = addreal.(F1.z,F2.z) by A1,A6,A7,FUNCOP_1:28
           .= F1z + F2z by BINOP_2:def 9
           .= addreal.(F2.z,F1.z) by BINOP_2:def 9;
     end;
   hence F = addreal.:(F2,F1) by A1,A6,FUNCOP_1:27;
  end;
end;

canceled;

theorem Th26:
  i in dom (F1+F2) implies (F1+F2).i = F1.i + F2.i
 proof assume that
A1: i in dom (F1+F2);
  set r1 = F1.i, r2 = F2.i;
  (F1 + F2).i = addreal.(r1,r2) by A1,FUNCOP_1:28;
  hence thesis by BINOP_2:def 9;
 end;

definition let i,R1,R2;
  redefine func R1 + R2 -> Element of i-tuples_on REAL;
  coherence by FINSEQ_2:140;
end;

theorem Th27:
  (R1+R2).j = R1.j + R2.j
 proof per cases;
  suppose
A1:  not j in Seg i;
   then A2:  not j in dom R1 by FINSEQ_2:144;
A3:  not j in dom R2 by A1,FINSEQ_2:144;
       not j in dom(R1+R2) by A1,FINSEQ_2:144;
   hence (R1+R2).j = 0+0 by FUNCT_1:def 4
       .= R1.j + 0 by A2,FUNCT_1:def 4
       .= R1.j + R2.j by A3,FUNCT_1:def 4;
  end;
  suppose j in Seg i;
   then j in dom (R1 + R2) by FINSEQ_2:144;
  hence thesis by Th26;
 end;
 end;

theorem
  <*>REAL + F = <*>REAL by FINSEQ_2:87;

theorem
  <*r1*> + <*r2*> = <*r1+r2*>
 proof
   thus <*r1*> + <*r2*> = <*addreal.(r1,r2)*> by FINSEQ_2:88
                       .= <*r1+r2*> by BINOP_2:def 9;
 end;

theorem
  (i|->r1) + (i|->r2) = i|->(r1+r2)
 proof
   thus (i|->r1) + (i|->r2) = i|->(addreal.(r1,r2)) by FINSEQOP:18
                           .= i|->(r1+r2) by BINOP_2:def 9;
 end;

canceled;

theorem Th32:
  R1 + (R2 + R3) = R1 + R2 + R3 by FINSEQOP:29;

theorem Th33:
  R + (i|->(0 qua Real)) = R by BINOP_2:2,FINSEQOP:57;

definition let F;
  func -F -> FinSequence of REAL equals
  compreal*F;
  correctness;
  involutiveness
  proof let f,F be FinSequence of REAL;
   assume
A1:   f = compreal*F;
A2:  rng f c= REAL;
A3:  rng F c= REAL;
A4:  rng f c= dom compreal by A2,FUNCT_2:def 1;
       rng F c= dom compreal by A3,FUNCT_2:def 1;
    then A5:  dom F = dom f by A1,RELAT_1:46;
    then A6:  dom F = dom(compreal*f) by A4,RELAT_1:46;
       for k st k in dom F holds F.k = (compreal*f).k
     proof let k such that
A7:    k in dom F;
      reconsider fk = f.k, Fk = F.k as Element of REAL;
      thus F.k = --Fk
          .= -compreal.(F.k) by BINOP_2:def 7
          .= -fk by A1,A7,FUNCT_1:23
          .= compreal.(f.k) by BINOP_2:def 7
          .= (compreal*f).k by A5,A7,FUNCT_1:23;
     end;
   hence F = compreal*f by A6,FINSEQ_1:17;
  end;
end;

theorem Th34:
  dom F = dom -F
  proof
    dom compreal = REAL by FUNCT_2:def 1;
    then rng F c= dom compreal;
    hence dom F = dom(compreal*F) by RELAT_1:46
        .= dom -F;
  end;

theorem Th35:
  (-F).i = -F.i
 proof per cases;
  suppose
A1:  not i in dom -F;
   then A2:   not i in dom F by Th34;
   thus (-F).i = -0 by A1,FUNCT_1:def 4
      .= -F.i by A2,FUNCT_1:def 4;
  end;
  suppose
A3:  i in dom -F;
  set r = F.i;
  (-F).i = compreal.r by A3,FUNCT_1:22;
  hence thesis by BINOP_2:def 7;
 end;
 end;

definition let i,R;
  redefine func -R -> Element of i-tuples_on REAL;
  coherence by FINSEQ_2:133;
end;

theorem
  r = R.j implies (-R).j = -r by Th35;

theorem
  -(<*>REAL) = <*>REAL by FINSEQ_2:38;

theorem
  -<*r*> = <*-r*>
 proof
   thus -<*r*> = <*compreal.r*> by FINSEQ_2:39
              .= <*-r*> by BINOP_2:def 7;
 end;

theorem Th39:
  -(i|->r) = i|->-r
 proof
   thus -(i|->r) = i|->(compreal.r) by FINSEQOP:17
                .= i|->-r by BINOP_2:def 7;
 end;

theorem Th40:
  R + -R = (i|->0) by Th22,Th23,BINOP_2:2,FINSEQOP:77;

theorem Th41:
  R1 + R2 = (i|->0) implies R1 = -R2 by Th22,Th23,BINOP_2:2,FINSEQOP:78;

canceled;

theorem
  -R1 = -R2 implies R1 = R2
 proof assume -R1 = -R2; hence R1 = --R2 .= R2; end;

theorem
  R1 + R = R2 + R implies R1 = R2
 proof assume R1 + R = R2 + R;
  then R1 + (R + -R)= (R2 + R)+-R by Th32;
  then R1 + (R + -R)= R2 + (R + -R) & R + -R = (i|->0) by Th32,Th40;
  then R1 = R2 + (i|->(0 qua Real)) by Th33;
  hence R1 = R2 by Th33;
 end;

theorem Th45:
  -(R1 + R2) = -R1 + -R2
 proof
   (R1 + R2) + (-R1 + -R2) = R1 + R2 + -R1 + -R2 by Th32
                          .= R2 + (R1 + -R1) + -R2 by Th32
                          .= R2 + (i|->(0 qua Real)) + -R2 by Th40
                          .= R2 + -R2 by Th33
                          .= (i|->0) by Th40;
   hence thesis by Th41;
 end;

definition let F1,F2;
  func F1 - F2 -> FinSequence of REAL equals
  diffreal.:(F1,F2);
  coherence;
end;

canceled;

theorem Th47:
  i in dom (F1-F2) implies (F1-F2).i = F1.i - F2.i
 proof assume that
A1: i in dom (F1-F2);
   set r1 = F1.i, r2 = F2.i;
  (F1 - F2).i = diffreal.(r1,r2) by A1,FUNCOP_1:28;
  hence thesis by Lm1;
 end;

definition let i,R1,R2;
  redefine func R1 - R2 -> Element of i-tuples_on REAL;
  coherence by FINSEQ_2:140;
end;

theorem
  (R1-R2).j = R1.j - R2.j
 proof per cases;
  suppose
A1:  not j in Seg i;
   then A2:  not j in dom R1 by FINSEQ_2:144;
A3:  not j in dom R2 by A1,FINSEQ_2:144;
       not j in dom(R1-R2) by A1,FINSEQ_2:144;
   hence (R1-R2).j = 0-0 by FUNCT_1:def 4
       .= R1.j - 0 by A2,FUNCT_1:def 4
       .= R1.j - R2.j by A3,FUNCT_1:def 4;
  end;
  suppose j in Seg i;
  then j in dom (R1 - R2) by FINSEQ_2:144;
  hence thesis by Th47;
 end;
 end;

theorem
  <*>REAL - F = <*>REAL & F - <*>REAL = <*>REAL by FINSEQ_2:87;

theorem
  <*r1*> - <*r2*> = <*r1-r2*>
 proof
   thus <*r1*> - <*r2*> = <*diffreal.(r1,r2)*> by FINSEQ_2:88
                       .= <*r1-r2*> by Lm1;
 end;

theorem
  (i|->r1) - (i|->r2) = i|->(r1-r2)
 proof
   thus (i|->r1) - (i|->r2) = i|->(diffreal.(r1,r2)) by FINSEQOP:18
                           .= i|->(r1-r2) by Lm1;
 end;

theorem Th52:
  R1 - R2 = R1 + - R2 by Def1,FINSEQOP:89;

theorem
  R - (i|->(0 qua Real)) = R
 proof
  thus R - (i|->(0 qua Real)) = R + - (i|->(0 qua Real)) by Th52
  .= R + (i|->(-0 qua Real)) by Th39 .= R by Th33;
 end;

theorem
  (i|->(0 qua Real)) - R = -R
 proof thus (i|->(0 qua Real)) - R = (i|->(0 qua Real)) + -R by Th52
 .= - R by Th33; end;

theorem
  R1 - -R2 = R1 + R2
 proof thus R1 - -R2 = R1 + --R2 by Th52 .= R1 + R2; end;

theorem
  -(R1 - R2) = R2 - R1
 proof
   thus -(R1 - R2) = -(R1 + -R2) by Th52
                  .= -R1 + --R2 by Th45
                  .= R2 - R1 by Th52;
 end;

theorem Th57:
  -(R1 - R2) = -R1 + R2
 proof
   thus -(R1 - R2) = -(R1+ -R2) by Th52
                  .= -R1 +--R2 by Th45
                  .= -R1 + R2;
 end;

theorem Th58:
  R - R = (i|->0)
 proof thus R - R = R + - R by Th52 .= (i|->0) by Th40; end;

theorem
  R1 - R2 = (i|->0) implies R1 = R2
 proof assume R1 - R2 = (i|->0);
   then R1 + - R2 = (i|->0) by Th52;
   then R1 = --R2 by Th41;
   hence thesis;
 end;

theorem
  R1 - R2 - R3 = R1 - (R2 + R3)
 proof
   thus R1 - R2 - R3 = R1 - R2 + - R3 by Th52
                    .= R1 + - R2 + - R3 by Th52
                    .= R1 + (- R2 + - R3) by Th32
                    .= R1 + -(R2 + R3) by Th45
                    .= R1 - (R2 + R3) by Th52;
 end;

theorem Th61:
  R1 + (R2 - R3) = R1 + R2 - R3
 proof
   thus R1 + (R2 - R3) = R1 + (R2 + - R3) by Th52
                      .= R1 + R2 + - R3 by Th32
                      .= R1 + R2 - R3 by Th52;
 end;

theorem
  R1 - (R2 - R3) = R1 - R2 + R3
 proof
   thus R1 - (R2 - R3) = R1 + - (R2 - R3) by Th52
                      .= R1 + (- R2 + R3) by Th57
                      .= R1 + - R2 + R3 by Th32
                      .= R1 - R2 + R3 by Th52;
 end;

theorem
  R1 = R1 + R - R
 proof
   thus R1 = R1 + (i|->(0 qua Real)) by Th33
          .= R1 + (R - R) by Th58
          .= R1 + R - R by Th61;
 end;

theorem
  R1 = R1 - R + R
 proof
   thus R1 = R1 + (i|->(0 qua Real)) by Th33
          .= R1 + (-R + R) by Th40
          .= R1 + -R + R by Th32
          .= R1 - R + R by Th52;
 end;

definition let r be real number; let F;
  func r*F -> FinSequence of REAL equals
  (r multreal)*F;
  coherence;
end;

theorem Th65:
 dom(r*F) = dom F
  proof
    dom(r multreal) = REAL by FUNCT_2:def 1;
    then rng F c= dom(r multreal);
    hence dom F = dom((r multreal)*F) by RELAT_1:46
        .= dom(r*F);
  end;

theorem Th66:
  (r*F).i = r*(F.i)
 proof per cases;
  suppose
A1: not i in dom (r*F);
    then A2:  not i in dom F by Th65;
   thus (r*F).i = r*0 by A1,FUNCT_1:def 4
      .= r*(F.i) by A2,FUNCT_1:def 4;
  end;
  suppose
A3:  i in dom (r*F);
  set r' = F.i;
A5:  r' in dom(multreal[;](r,id REAL)) by A3,FUNCT_1:21;
  thus (r*F).i = (multreal[;](r,id REAL)).r' by A3,FUNCT_1:22
              .= multreal.(r,(id REAL).r') by A5,FUNCOP_1:42
              .= multreal.(r,r') by FUNCT_1:35
              .= r*(F.i) by BINOP_2:def 11;
 end;
 end;

definition let i; let r be real number; let R;
  redefine func r*R -> Element of i-tuples_on REAL;
  coherence by FINSEQ_2:133;
end;

theorem
  (r*R).j = r*(R.j) by Th66;

theorem
  r*(<*>REAL) = <*>REAL by FINSEQ_2:38;

theorem
  r*<*r1*> = <*r*r1*>
 proof
   thus r*<*r1*> = <*(multreal[;](r,id REAL)).r1*> by FINSEQ_2:39
                .= <*r*r1*> by Lm2;
 end;

theorem Th70:
  r1*(i|->r2) = i|->(r1*r2)
 proof
   thus r1*(i|->r2) = i|->((multreal[;](r1,id REAL)).r2) by FINSEQOP:17
                   .= i|->(r1*r2) by Lm2;
 end;

theorem Th71:
  (r1*r2)*R = r1*(r2*R)
 proof
   thus (r1*r2)*R = (multreal[;](r1*r2,id REAL))*R
     .= multreal[;](multreal.(r1,r2),id REAL)*R by BINOP_2:def 11
     .= multreal[;](r1,multreal[;](r2,id REAL))*R by FUNCOP_1:77
     .= (multreal[;](r1,id REAL)*(multreal [;] (r2,id REAL)))*R
     by FUNCOP_1:69
     .= r1*(r2*R) by RELAT_1:55;
 end;

theorem
  (r1 + r2)*R = r1*R + r2*R
 proof
  thus (r1 + r2)*R
     = multreal[;](addreal.(r1,r2),id REAL)*R by BINOP_2:def 9
    .= addreal.:(multreal[;](r1,id REAL),multreal[;](r2,id REAL))*R
        by Th16,FINSEQOP:36
    .= addreal.:(multreal[;](r1,id REAL)*R,multreal[;](r2,id REAL)*R)
       by FUNCOP_1:31
    .= r1*R + r2*R;
 end;

theorem
  r*(R1+R2) = r*R1 + r*R2
 proof set rM = r multreal;
A1:  r multreal is_distributive_wrt addreal by Th20;
  thus r*(R1+R2)
     = addreal.:(rM*R1,rM*R2) by A1,FINSEQOP:52
    .= r*R1 + r*R2;
 end;

theorem
  1*R = R
 proof
A1: rng R c= REAL;
   thus 1*R = (id REAL)*R by BINOP_2:7,FINSEQOP:45
           .= R by A1,RELAT_1:79;
 end;

theorem
  0*R = (i|->0)
 proof
A1:  rng R c= REAL;
  thus 0*R = multreal[;](0,(id REAL)*R) by FUNCOP_1:44
          .= multreal[;](0,R) by A1,RELAT_1:79
          .= i|->0 by Th16,Th22,BINOP_2:2,FINSEQOP:80;
 end;

theorem Th76:
  (-1)*R = -R
 proof
A1:   compreal.1 = -1 by BINOP_2:def 7;
   thus (-1)*R
      = compreal*R by A1,Th16,Th22,Th23,BINOP_2:7,FINSEQOP:72
     .= -R;
 end;

definition let F;
  func sqr F -> FinSequence of REAL equals
  sqrreal*F;
  coherence;
end;

theorem Th77:
  dom(sqr F) = dom F
  proof
    dom sqrreal = REAL by FUNCT_2:def 1;
    then rng F c= dom sqrreal;
    hence dom F = dom(sqrreal*F) by RELAT_1:46
        .= dom(sqr F);
  end;

theorem Th78:
  (sqr F).i = (F.i)^2
 proof per cases;
  suppose
A1:  not i in dom sqr F;
    then A2:  not i in dom F by Th77;
   thus (sqr F).i = 0^2 by A1,FUNCT_1:def 4
      .= (F.i)^2 by A2,FUNCT_1:def 4;
  end;
  suppose
A3:  i in dom sqr F;
  set r = F.i;
  (sqr F).i = sqrreal.r by A3,FUNCT_1:22;
  hence thesis by Def2;
 end;
 end;

definition let i,R;
  redefine func sqr R -> Element of i-tuples_on REAL;
  coherence by FINSEQ_2:133;
end;

theorem
  (sqr R).j = (R.j)^2 by Th78;

theorem
  sqr (<*>REAL) = <*>REAL by FINSEQ_2:38;

theorem
  sqr <*r*> = <*r^2*>
 proof
   thus sqr <*r*> = <*sqrreal.r*> by FINSEQ_2:39
                 .= <*r^2*> by Def2;
 end;

theorem
  sqr(i |-> r) = i |-> r^2
 proof
  thus sqr(i |-> r) = i |-> (sqrreal.r) by FINSEQOP:17
                   .= i |-> r^2 by Def2;
 end;

theorem Th83:
  sqr -R = sqr R
 proof
   now let j; assume j in Seg i;
   set r = R.j, r' = (-R).j;
   thus (sqr -R).j = (r')^2 by Th78
                  .= (-r)^2 by Th35
                  .= r^2
                  .= (sqr R).j by Th78;
  end;
  hence thesis by FINSEQ_2:139;
 end;

theorem Th84:
  sqr (r*R) = r^2* sqr R
 proof
A1: rng R c= REAL;
A2: rng(sqrreal*R) c= REAL;
  thus sqr (r*R) = sqrreal*(multreal[;](r,(id REAL)*R)) by FUNCOP_1:44
                .= sqrreal*(multreal[;](r,R)) by A1,RELAT_1:79
                .= multreal[;](sqrreal.r,sqrreal*R) by Th17,FINSEQOP:53
                .= multreal[;]
(sqrreal.r,(id REAL)*(sqrreal*R)) by A2,RELAT_1:79
                .= multreal[;](sqrreal.r,id REAL)*(sqrreal*R) by FUNCOP_1:44
                .= multreal[;](r^2,id REAL)*(sqrreal*R) by Def2
                .= r^2* sqr R;
 end;

definition let F1,F2;
  func mlt(F1,F2) -> FinSequence of REAL equals
  multreal.:(F1,F2);
  coherence;
  commutativity
  proof let F,F1,F2 be FinSequence of REAL;
   assume
A1:  F = multreal.:(F1,F2);
A2:  dom multreal = [:REAL,REAL:] by FUNCT_2:def 1;
A5:  [:rng F2, rng F1:] c= dom multreal by A2,ZFMISC_1:119;
     [:rng F1, rng F2:] c= dom multreal by A2,ZFMISC_1:119;
    then A6:  dom(multreal.:(F1,F2)) = dom F1 /\ dom F2 by FUNCOP_1:84
          .= dom(multreal.:(F2,F1)) by A5,FUNCOP_1:84;
     for z being set st z in dom(multreal.:(F2,F1))
       holds F.z = multreal.(F2.z,F1.z)
     proof let z be set such that
A7:    z in dom(multreal.:(F2,F1));
       set F1z = F1.z, F2z =F2.z;
      thus F.z = multreal.(F1.z,F2.z) by A1,A6,A7,FUNCOP_1:28
           .= F1z * F2z by BINOP_2:def 11
           .= multreal.(F2.z,F1.z) by BINOP_2:def 11;
     end;
   hence F = multreal.:(F2,F1) by A1,A6,FUNCOP_1:27;
  end;
end;

canceled;

theorem Th86:
  i in dom mlt(F1,F2) implies mlt(F1,F2).i = F1.i * F2.i
 proof assume that
A1: i in dom mlt(F1,F2);
  set r1 = F1.i, r2 = F2.i;
  mlt(F1,F2).i = multreal.(r1,r2) by A1,FUNCOP_1:28;
  hence thesis by BINOP_2:def 11;
 end;

definition let i,R1,R2;
  redefine func mlt(R1,R2) -> Element of i-tuples_on REAL;
  coherence by FINSEQ_2:140;
end;

theorem Th87:
  mlt(R1,R2).j = R1.j * R2.j
 proof per cases;
  suppose
A1:  not j in Seg i; then
A2:  not j in dom R2 by FINSEQ_2:144;
     not j in dom mlt(R1,R2) by A1,FINSEQ_2:144;
   hence mlt(R1,R2).j = R1.j *0 by FUNCT_1:def 4
       .= R1.j * R2.j by A2,FUNCT_1:def 4;
  end;
  suppose j in Seg i;
  then j in dom mlt(R1,R2) by FINSEQ_2:144;
  hence thesis by Th86;
 end;
 end;

theorem
  mlt(<*>REAL,F) = <*>REAL by FINSEQ_2:87;

theorem
  mlt(<*r1*>,<*r2*>) = <*r1*r2*>
 proof
  thus mlt(<*r1*>,<*r2*>) = <*multreal.(r1,r2)*> by FINSEQ_2:88
                         .= <*r1*r2*> by BINOP_2:def 11;
 end;

canceled;

theorem
  mlt(R1,mlt(R2,R3)) = mlt(mlt(R1,R2),R3) by FINSEQOP:29;

theorem Th92:
  mlt(i|->r,R) = r*R
 proof
  thus mlt(i|->r,R) = multreal[;](r,R) by FINSEQOP:21
                   .= multreal[;](r,(id REAL))*R by FINSEQOP:23
                   .= r*R;
 end;

theorem
  mlt(i|->r1,i|->r2) = i|->(r1*r2)
 proof
   thus mlt(i|->r1,i|->r2) = r1*(i|->r2) by Th92
                          .= i|->(r1*r2) by Th70;
 end;

theorem Th94:
  r*mlt(R1,R2) = mlt(r*R1,R2) by FINSEQOP:27;

canceled;

theorem
  r*R = mlt(i|->r,R) by Th92;

theorem Th97:
  sqr(R) = mlt(R,R)
 proof
A1:  len R = i by FINSEQ_2:109;
then A2:  len(sqrreal*R) = i by FINSEQ_2:37;
A3:  len(multreal.:(R,R)) = i by A1,FINSEQ_2:86;
A4:  now let j;
    assume
A5:    j in Seg i;
then A6:    j in dom(sqrreal*R) by A2,FINSEQ_1:def 3;
A7:    j in dom(multreal.:(R,R)) by A3,A5,FINSEQ_1:def 3;
    set r = R.j;
    thus (sqrreal*R).j = sqrreal.r by A6,FUNCT_1:22
                      .= r^2 by Def2
                      .= multreal.(r,r) by BINOP_2:def 11
                      .= (multreal.:(R,R)).j by A7,FUNCOP_1:28;
   end;
  thus sqr(R) = multreal.:(R,R) by A2,A3,A4,FINSEQ_2:10
             .= mlt(R,R);
 end;

theorem Th98:
  sqr(R1 + R2) = sqr R1 + 2*mlt(R1,R2) + sqr R2
 proof
  now let j; assume j in Seg i;
   set r1r2 = (R1 + R2).j, r1 = R1.j, r2 = R2.j,
              r1'2 = (sqr R1).j, r2'2 = (sqr R2).j,
              r1r2a = mlt(R1,R2).j,2r1r2 = (2*mlt(R1,R2)).j,
              r1'22r1r2 = (sqr R1 + 2*mlt(R1,R2)).j;
   thus (sqr(R1 + R2)).j = r1r2^2 by Th78
                        .= (r1 + r2)^2 by Th27
                        .= r1^2+2*r1*r2+r2^2
                        .= r1'2+2*(r1*r2)+r2^2 by Th78
                        .= r1'2+2*(r1*r2)+r2'2 by Th78
                        .= r1'2+2*(r1r2a)+r2'2 by Th87
                        .= r1'2+2r1r2+r2'2 by Th66
                        .= r1'22r1r2+r2'2 by Th27
                        .= (sqr R1 + 2*mlt(R1,R2) + sqr R2).j by Th27;
  end;
  hence thesis by FINSEQ_2:139;
 end;

theorem Th99:
  sqr(R1 - R2) = sqr R1 - 2*mlt(R1,R2) + sqr R2
 proof
   thus sqr(R1 - R2) = sqr(R1 + -R2) by Th52
                    .= sqr R1 + 2*mlt(R1,-R2) + sqr -R2 by Th98
                    .= sqr R1 + 2*mlt(R1,-R2) + sqr R2 by Th83
                    .= sqr R1 + 2*mlt(R1,(-1)*R2) + sqr R2 by Th76
                    .= sqr R1 + 2*((-1)*mlt(R1,R2)) + sqr R2 by Th94
                    .= sqr R1 + ((-1)*2)*mlt(R1,R2) + sqr R2 by Th71
                    .= sqr R1 + (-1)*(2*mlt(R1,R2)) + sqr R2 by Th71
                    .= sqr R1 + -(2*mlt(R1,R2)) + sqr R2 by Th76
                    .= sqr R1 - 2*mlt(R1,R2) + sqr R2 by Th52;
 end;

theorem
  sqr mlt(R1,R2) = mlt(sqr R1,sqr R2) by Th17,FINSEQOP:52;

:: Finite sum of Finite Sequence of Real Numbers

definition let F be FinSequence of REAL;
  func Sum F -> Real equals
    addreal $$ F;
  coherence;
end;

canceled;

theorem Th102:
  Sum(<*> REAL) = 0 by BINOP_2:2,FINSOP_1:11;

theorem Th103:
  Sum <*r*> = r by FINSOP_1:12;

theorem Th104:
  Sum(F^<*r*>) = Sum F + r
 proof
  thus Sum(F^<*r*>) = addreal.(addreal $$ F,r) by FINSOP_1:5
                 .= Sum F + r by BINOP_2:def 9;
 end;

theorem Th105:
  Sum(F1^F2) = Sum F1 + Sum F2
 proof
  thus Sum(F1^F2)
     = addreal.(addreal $$ F1,addreal $$ F2) by FINSOP_1:6
    .= Sum F1 + Sum F2 by BINOP_2:def 9;
 end;

theorem
  Sum(<*r*>^F) = r + Sum F
 proof thus Sum(<*r*>^F) = Sum <*r*> + Sum F by Th105
  .= r + Sum F by Th103;
 end;

theorem Th107:
  Sum<*r1,r2*> = r1 + r2
 proof
   thus Sum<*r1,r2*> = Sum<*r1*> + r2 by Th104
                  .= r1 + r2 by Th103;
 end;

theorem
  Sum<*r1,r2,r3*> = r1 + r2 + r3
 proof
   thus Sum<*r1,r2,r3*> = Sum<*r1,r2*> + r3 by Th104
                     .= r1 + r2 + r3 by Th107;
 end;

theorem
  for R being Element of 0-tuples_on REAL holds Sum R = 0
    by Th102,FINSEQ_2:113;

theorem Th110:
  Sum(i |-> r) = i*r
 proof
   defpred P[Nat] means Sum($1 |->r) = $1*r;
A1: P[0] by Th102,FINSEQ_2:113;
A2:  for i st P[i] holds P[(i+1)]
   proof let i such that
A3:   Sum(i |-> r) = i*r;
    thus Sum((i+1) |-> r) = Sum((i |-> r)^<*r*>) by FINSEQ_2:74
                       .= i*r + 1*r by A3,Th104
                       .= (i+1)*r;
   end;
     for i holds P[i] from NAT_1:sch 1(A1,A2);
  hence thesis;
 end;

theorem Th111:
  Sum(i |-> (0 qua Real)) = 0
 proof
   thus Sum(i |-> (0 qua Real)) = i*0 by Th110 .= 0;
 end;

theorem Th112:
  (for j st j in Seg i holds R1.j <= R2.j) implies Sum R1 <= Sum R2
 proof
   defpred P[Nat] means
     for R1,R2 being Element of $1-tuples_on REAL
      st for j st j in Seg $1 holds R1.j <= R2.j holds
       Sum R1 <= Sum R2;
A1: P[0]
    proof let R1,R2 be Element of 0-tuples_on REAL;
        Sum R1 = 0 & Sum R2 = 0 by Th102,FINSEQ_2:113;
     hence thesis;
    end;
A2: for i st P[i] holds P[i+1]
   proof let i such that
A3:   for R1,R2 being Element of i-tuples_on REAL
        st for j st j in Seg i holds R1.j <= R2.j
       holds Sum R1 <= Sum R2;
    let R1,R2 be Element of (i+1)-tuples_on REAL such that
A4:   for j st j in Seg (i+1) holds R1.j <= R2.j;
    consider R1' being (Element of i-tuples_on REAL), x1 such that
A5:   R1 = R1'^<*x1*> by FINSEQ_2:137;
    consider R2' being (Element of i-tuples_on REAL), x2 such that
A6:   R2 = R2'^<*x2*> by FINSEQ_2:137;
    set n = i+1;
       n in Seg n & R1.n = x1 & R2.n = x2 by A5,A6,FINSEQ_1:6,FINSEQ_2:136;
then A7:   x1 <= x2 by A4;
       for j st j in Seg i holds R1'.j <= R2'.j
     proof let j such that
A8:      j in Seg i;
         Seg len R1' = dom R1' & Seg len R2' = dom R2' &
      len R1' = i & len R2' = i by FINSEQ_1:def 3,FINSEQ_2:109;
      then j in Seg n & R1'.j = R1.j & R2'.j = R2.j
        by A5,A6,A8,FINSEQ_1:def 7,FINSEQ_2:9;
      hence thesis by A4;
     end;
    then Sum R1' <= Sum R2' & Sum R1 = Sum R1' + x1 & Sum R2 = Sum R2' + x2
      by A3,A5,A6,Th104;
    hence Sum R1 <= Sum R2 by A7,XREAL_1:9;
   end;
    for i holds P[i] from NAT_1:sch 1(A1,A2);
  hence thesis;
 end;

theorem Th113:
  (for j st j in Seg i holds R1.j <= R2.j) &
    (ex j st j in Seg i & R1.j < R2.j)
      implies Sum R1 < Sum R2
 proof
   defpred P[Nat] means
     for R1,R2 be Element of $1-tuples_on REAL st
      (for j st j in Seg $1 holds R1.j <= R2.j) &
       (ex j st j in Seg $1 & R1.j < R2.j)
       holds Sum R1 < Sum R2;
A1: P[0] by FINSEQ_1:4;
A2: for i st P[i] holds P[i+1]
   proof
  now let i such that
A3: P[i];
     let R1,R2 be Element of (i+1)-tuples_on REAL such that
A4:    for j st j in Seg (i+1) holds R1.j <= R2.j;
     given j such that
A5:    j in Seg (i+1) & R1.j < R2.j;
     consider R1' being (Element of i-tuples_on REAL), x1 such that
A6:    R1 = R1'^<*x1*> by FINSEQ_2:137;
     consider R2' being (Element of i-tuples_on REAL), x2 such that
A7:    R2 = R2'^<*x2*> by FINSEQ_2:137;
A8:    (i+1) in Seg (i+1) & R1.(i+1) = x1 & R2.(i+1) = x2
        by A6,A7,FINSEQ_1:6,FINSEQ_2:136;
A9:    for j st j in Seg i holds R1'.j <= R2'.j
      proof let j such that
A10:     j in Seg i;
          Seg len R1' = dom R1' & Seg len R2' = dom R2' &
       len R1' = i & len R2' = i by FINSEQ_1:def 3,FINSEQ_2:109;
       then j in Seg (i+1) & R1'.j = R1.j & R2'.j = R2.j
         by A6,A7,A10,FINSEQ_1:def 7,FINSEQ_2:9;
        hence thesis by A4;
      end;
        now per cases by A5,FINSEQ_2:8;
      suppose
A11:     j in Seg i;
          Seg len R1' = dom R1' & Seg len R2' = dom R2' &
       len R1' = i & len R2' = i by FINSEQ_1:def 3,FINSEQ_2:109;
       then R1'.j = R1.j & R2'.j = R2.j by A6,A7,A11,FINSEQ_1:def 7;
       then Sum R1' < Sum R2' & Sum R1 = Sum R1' + x1 &
           Sum R2 = Sum R2' + x2 & x1 <= x2
        by A3,A4,A5,A6,A7,A8,A9,A11,Th104;
       hence Sum R1 < Sum R2 by XREAL_1:10;
      end;
      suppose
A12:     j = i+1;
          Sum R1' <= Sum R2' & Sum R1 = Sum R1' + x1 & Sum R2 = Sum R2' + x2
        by A6,A7,A9,Th104,Th112;
       hence Sum R1 < Sum R2 by A5,A8,A12,XREAL_1:10;
      end;
      end;
     hence Sum R1 < Sum R2;
   end;
   hence thesis;
  end;
   for i holds P[i] from NAT_1:sch 1(A1,A2);
   hence thesis;
 end;

theorem Th114:
  (for i st i in dom F holds 0 <= F.i) implies 0 <= Sum F
 proof assume
A1:  for i st i in dom F holds 0 <= F.i;
  set i = len F;
  set R1 = i|->(0 qua Real);
  reconsider R2 = F as Element of i-tuples_on REAL by FINSEQ_2:110;
A2: Seg len F = dom F by FINSEQ_1:def 3;
     now let j; assume
A3:   j in Seg i;
   then R1.j = 0 by FUNCOP_1:13;
   hence R1.j <= R2.j by A1,A2,A3;
  end;
  then Sum R1 <= Sum R2 by Th112;
  hence thesis by Th111;
 end;

theorem Th115:
   (for i st i in dom F holds 0 <= F.i) &
    (ex i st i in dom F & 0 < F.i)
     implies 0 < Sum F
 proof assume
A1:   for i st i in dom F holds 0 <= F.i;
  set i = len F, R1 = i|->(0 qua Real);
  reconsider R2 = F as Element of i-tuples_on REAL by FINSEQ_2:110;
A2:   Seg len F = dom F by FINSEQ_1:def 3;
A3: now let j; assume
A4:   j in Seg i;
   then R1.j = 0 by FUNCOP_1:13;
   hence R1.j <= R2.j by A1,A2,A4;
  end;
  given j such that
A5:  j in dom F and
A6:  0 < F.j;
     R1.j = 0 by A2,A5,FUNCOP_1:13;
  then Sum R1 < Sum R2 by A2,A3,A5,A6,Th113;
  hence thesis by Th111;
 end;

theorem Th116:
  0 <= Sum sqr F
 proof
  now let i such that
   i in dom sqr F;
   set r = (sqr F).i;
   set x = F.i;
   0 <= x^2 by XREAL_1:65; hence 0 <= r by Th78;
  end;
  hence thesis by Th114;
end;

theorem Th117:
  Sum(r*F) = r*(Sum F)
 proof set rM = multreal[;](r,id REAL);
  thus Sum (r*F) = rM.(addreal $$F) by Th16,Th22,SETWOP_2:41
    .= r*(Sum F) by Lm2;
 end;

theorem
  Sum -F = -(Sum F)
 proof
   thus Sum -F = compreal.(addreal $$ F) by Th22,Th23,SETWOP_2:42
            .= -(Sum F) by BINOP_2:def 7;
 end;

theorem Th119:
  Sum(R1 + R2) = Sum R1 + Sum R2
 proof
  thus Sum(R1 + R2) = addreal.(addreal$$R1,addreal$$R2) by SETWOP_2:46
    .= Sum R1 + Sum R2 by BINOP_2:def 9;
 end;

theorem Th120:
  Sum(R1 - R2) = Sum R1 - Sum R2
 proof
  thus Sum(R1 - R2)
     = diffreal.(addreal$$R1,addreal$$R2) by Def1,Th22,Th23,SETWOP_2:48
    .= Sum R1 - Sum R2 by Lm1;
 end;

theorem
  Sum sqr R = 0 implies R = i |-> 0
 proof assume
A1:  Sum sqr R = 0;
A2:  len R = i by FINSEQ_2:109;
A3:  len(i |-> 0) = i by FINSEQ_2:109;then
A4:  Seg i = dom R & Seg i = dom(i |-> 0) by A2,FINSEQ_1:def 3;
  assume R <> i |-> 0;
  then consider j such that
A5:   j in dom R and
A6:   R.j <> (i |-> 0).j by A2,A3,A4,FINSEQ_2:10;
A7:   dom sqr R = Seg len sqr R & dom R = Seg len R by FINSEQ_1:def 3;
A8: now let k such that
     k in dom sqr R;
     set r = (sqr R).k;
     set x = R.k;
     0 <= x^2 by XREAL_1:65; hence 0 <= r by Th78;
    end;
A9:  j in dom sqr R by A5,A7,FINSEQ_2:37;
  set x = R.j,x' = (sqr R).j;
     x <> 0 by A2,A5,A6,A7,FUNCOP_1:13;
  then 0 < x^2 by SQUARE_1:74;
  then 0 < x' by Th78;
  hence thesis by A1,A8,A9,Th115;
 end;

theorem
  (Sum mlt(R1,R2))^2 <= (Sum sqr R1)*(Sum sqr R2)
 proof
  defpred P[Nat] means
    for R1,R2 being Element of $1-tuples_on REAL
      holds (Sum mlt(R1,R2))^2 <= (Sum sqr R1)*(Sum sqr R2);
A1: P[0]
    proof let R1,R2 be Element of 0-tuples_on REAL;
      sqr R1 = <*>REAL & mlt(R1,R2) = <*>REAL by FINSEQ_2:113;
      hence thesis by Th102;
    end;
A2: for i st P[i] holds P[i+1]
    proof let i such that
A3:   for R1,R2 being Element of i-tuples_on REAL
        holds (Sum mlt(R1,R2))^2 <= (Sum sqr R1)*(Sum sqr R2);
    let R1,R2 be Element of (i+1)-tuples_on REAL;
    consider R1' being (Element of i-tuples_on REAL), x1 such that
A4:    R1 = R1'^<*x1*> by FINSEQ_2:137;
    consider R2' being (Element of i-tuples_on REAL), x2 such that
A5:    R2 = R2'^<*x2*> by FINSEQ_2:137;
       (Sum mlt(R1',R2'))^2 + 0 <= (Sum sqr R1')*(Sum sqr R2') by A3;
then A6:    0 <= (Sum sqr R1')*(Sum sqr R2') - (Sum mlt(R1',R2'))^2 by
XREAL_1:21;
A7:   (Sum sqr R1' + x1^2)*(Sum sqr R2' + x2^2)
        = (Sum sqr R1')*(Sum sqr R2')+(x1^2*(Sum sqr R2')+(Sum
 sqr R1')*x2^2)+x1^2*x2^2
       .= (Sum sqr R1')*(Sum sqr R2')+(Sum(x1^2*sqr R2')+(Sum
 sqr R1')*x2^2)+x1^2*x2^2 by Th117
       .= (Sum sqr R1')*(Sum sqr R2')+(Sum sqr(x1*R2')+x2^2*(Sum
 sqr R1'))+x1^2*x2^2 by Th84
       .= (Sum sqr R1')*(Sum sqr R2')+(Sum sqr(x1*R2')+Sum
(x2^2*sqr R1'))+x1^2*x2^2 by Th117
       .= (Sum sqr R1')*(Sum sqr R2')+(Sum sqr(x1*R2')+Sum
 sqr(x2*R1'))+x1^2*x2^2 by Th84;
       mlt(R1'^<*x1*>,R2'^<*x2*>)
      = (multreal.:(R1',R2'))^<*multreal.(x1,x2)*> by FINSEQOP:11
     .= (multreal.:(R1',R2'))^<*x1*x2*> by BINOP_2:def 11
     .= (mlt(R1',R2'))^<*x1*x2*>;
then A8:  Sum mlt(R1'^<*x1*>,R2'^<*x2*>) = Sum mlt(R1',R2') + x1*x2 by Th104;
A9:   2*(x1*x2)*Sum mlt(R1',R2')
        = 2*((x1*x2)*Sum mlt(R1',R2'))
       .= 2*Sum((x1*x2)*mlt(R1',R2')) by Th117
       .= 2*Sum(x1*(x2*mlt(R1',R2'))) by Th71
       .= 2*Sum(x1*mlt(R2',x2*R1')) by Th94
       .= 2*Sum(mlt(x1*R2',x2*R1')) by Th94;
A10:  -(Sum mlt(R1',R2')+x1*x2)^2
        = -(x1*x2)^2+-(2*(x1*x2)*Sum mlt(R1',R2')+(Sum mlt(R1',R2'))^2)
       .= -x1^2*x2^2+(-(Sum mlt(R1',R2'))^2+ -2*Sum(mlt(x1*R2',x2*R1')))
              by A9;
A11:  Sum sqr(x1*R2')+Sum sqr(x2*R1') + -2*Sum(mlt(x1*R2',x2*R1'))
       = Sum sqr(x1*R2')-2*Sum(mlt(x1*R2',x2*R1'))+Sum
 sqr(x2*R1')
      .= Sum sqr(x1*R2')-Sum(2*mlt(x1*R2',x2*R1'))+Sum sqr(x2*R1') by Th117
      .= Sum(sqr(x1*R2')-2*mlt(x1*R2',x2*R1'))+Sum sqr(x2*R1') by Th120
      .= Sum(sqr (x1*R2')-2*mlt(x1*R2',x2*R1')+sqr(x2*R1')) by Th119;
   Sum sqr (R^<*r*>) = Sum sqr R + r^2
 proof
   sqr(R^<*r*>) = (sqrreal*R)^<*sqrreal.r*> by FINSEQOP:9
                    .= (sqrreal*R)^<*r^2*> by Def2
                    .= (sqr R)^<*r^2*>;
   hence Sum sqr (R^<*r*>) = Sum sqr R + r^2 by Th104;
 end;
    then (Sum sqr R1' + x1^2) = Sum sqr R1 &
    (Sum sqr R2' + x2^2) = Sum sqr R2 by A4,A5;
    then A12:  (Sum sqr R1)*(Sum sqr R2) - (Sum mlt(R1,R2))^2
       = (Sum sqr R1' + x1^2)*(Sum sqr R2' + x2^2)
           + -(Sum mlt(R1',R2')+x1*x2)^2 by A4,A5,A8
      .= (Sum sqr R1')*(Sum sqr R2')+-(Sum mlt(R1',R2'))^2 +
         ((Sum sqr(x1*R2')+Sum sqr(x2*R1')) +- 2*Sum(mlt(x1*R2',x2*R1'))) by A7
,A10
      .= (Sum sqr R1')*(Sum sqr R2')-(Sum mlt(R1',R2'))^2 + Sum
 sqr (x1*R2'-x2*R1')
          by A11,Th99;
       0 <= Sum sqr (x1*R2'-x2*R1') by Th116;
    then 0 + 0 <= (Sum sqr R1)*(Sum sqr R2) - (Sum
 mlt(R1,R2))^2 by A6,A12,XREAL_1:9;
    then (Sum mlt(R1,R2))^2 + 0 <= (Sum sqr R1)*(Sum sqr R2) by XREAL_1:21;
    hence (Sum mlt(R1,R2))^2 <= (Sum sqr R1)*(Sum sqr R2);
   end;
   for i holds P[i] from NAT_1:sch 1(A1,A2);
   hence thesis;
 end;

:: The Product of Finite Sequences of Real Numbers

definition let F be Relation;
  attr F is complex-yielding means :ComY:
    rng F c= COMPLEX;
end;

registration
  cluster -> real-yielding FinSequence of REAL;
  coherence
  proof
    let f be FinSequence of REAL;
    rng f c= REAL;
    hence thesis by SEQ_1:def 1;
  end;
  cluster -> complex-yielding FinSequence of COMPLEX;
  coherence
  proof
    let f be FinSequence of COMPLEX;
    rng f c= COMPLEX;
    hence thesis by ComY;
  end;
  cluster real-yielding -> complex-yielding FinSequence;
  coherence
  proof
    let f be FinSequence;
    assume f is real-yielding; then
    rng f c= REAL by SEQ_1:def 1; then
    rng f c= COMPLEX by XBOOLE_1:1,NUMBERS:11;
    hence thesis by ComY;
  end;
  cluster real-yielding complex-yielding FinSequence;
  existence
  proof
    consider f being FinSequence of REAL;
    f is real-yielding;
    hence thesis;
  end;
end;

definition let F be complex-yielding FinSequence;
  func Product F -> complex number means :DefCO:
    ex f being FinSequence of COMPLEX st f = F &
    it = multcomplex $$ f;
  existence
  proof
    rng F c= COMPLEX by ComY; then
    reconsider f = F as FinSequence of COMPLEX by FINSEQ_1:def 4;
    take multcomplex $$ f;
    thus thesis;
  end;
  uniqueness;
end;

definition let F be FinSequence of COMPLEX; 
  redefine func Product F -> Element of COMPLEX;
  coherence by XCMPLX_0:def 2;
end;

registration let F be real-yielding FinSequence;
  cluster Product F -> real;
  coherence
  proof
    consider f being FinSequence of COMPLEX such that
A1: f = F & Product F = multcomplex $$ f by DefCO;
A0: rng f c= REAL by A1,SEQ_1:def 1; then
    reconsider f' = f as FinSequence of REAL by FINSEQ_1:def 4;
    set mc = multcomplex, mr = multreal;
A3: mc $$ f = mc $$ (dom f,[#](f,the_unity_wrt mc)) by SETWOP_2:def 2;
    consider n being Nat such that
B1: dom f = Seg n by FINSEQ_1:def 2;
    defpred P[Nat] means
      mc $$ (Seg $1,[#](f,the_unity_wrt mc)) is real;
    Seg 0 = {} by FINSEQ_1:4 .= {}.NAT; then
C1: P[0] by SETWISEO:40,BINOP_2:6;
    set g = [#](f,the_unity_wrt mc);
C2: for k being Nat st P[k] holds P[k+1]
    proof
      let k be Nat;
      assume P[k]; then
D1:   mc $$(Seg k,g) is real;
D3:   g.(k+1) is real
      proof
        per cases;
        suppose
E1:       k+1 in dom f; then
          g.(k+1) = f.(k+1) by SETWOP_2:22; then
          g.(k+1) in rng f by E1,FUNCT_1:12;
          hence thesis by A0,XREAL_0:def 1;
        end;
        suppose not k+1 in dom f; then
          g.(k+1) = the_unity_wrt mc by SETWOP_2:22 .= 1 by BINOP_2:6;
          hence thesis;
        end;
      end;
      reconsider a = g.(k+1), b = mc $$(Seg k,g) as real number by D1,D3;
      not (k + 1) in Seg k by FINSEQ_3:9; then
      mc $$ (Seg k \/ {k+1},g) = mc.(mc $$(Seg k,g),g.(k+1))
        by SETWOP_2:4
        .= mc $$(Seg k,g) * (g.(k+1)) by BINOP_2:def 5
        .= b * a;
      hence thesis by FINSEQ_1:11;
    end;
    for n being Nat holds P[n] from NAT_1:sch 1(C1,C2); then
    mc $$ f is real by B1,A3;
    hence thesis by A1;
  end;
end;

theorem Th123:
  for F being FinSequence of REAL holds
    Product F = multreal $$ F
  proof
    let F be FinSequence of REAL;
    rng F c= COMPLEX by XBOOLE_1:1,NUMBERS:11; then
    reconsider f = F as FinSequence of COMPLEX by FINSEQ_1:def 4;
    set g = multreal, h = multcomplex;
    consider n being Nat such that
B1: dom f = Seg n by FINSEQ_1:def 2;
D1: g $$ F = g $$ (dom F,[#](F,the_unity_wrt g)) by SETWOP_2:def 2
      .= g $$ (Seg n,[#](F,the_unity_wrt g)) by B1;
D2: h $$ f = h $$ (dom f,[#](f,the_unity_wrt h)) by SETWOP_2:def 2
      .= h $$ (Seg n,[#](f,the_unity_wrt h)) by B1;
    defpred P[Nat] means
      g $$ (Seg $1,[#](F,the_unity_wrt g)) =
        h $$ (Seg $1,[#](f,the_unity_wrt h));
C0: Seg 0 = {} by FINSEQ_1:4 .= {}.NAT;
C1: P[0]
    proof
      g $$ (Seg 0,[#](F,the_unity_wrt g)) =
        g $$ ({}.NAT,[#](F,the_unity_wrt g)) by C0
        .= the_unity_wrt g by SETWISEO:40
        .= the_unity_wrt h by BINOP_2:6,7
        .= h $$ (Seg 0,[#](f,the_unity_wrt h)) by C0,SETWISEO:40;
      hence thesis;
    end;
C2: for k being Nat st P[k] holds P[k+1]
    proof
      let k be Nat;
      assume P[k]; then
CC:   g $$ (Seg k,[#](F,the_unity_wrt g)) =
        h $$ (Seg k,[#](f,the_unity_wrt h));
      set i = [#](F,the_unity_wrt g);
      set j = [#](f,the_unity_wrt h);
ZZ:   i.(k+1) = j.(k+1)
      proof
        per cases;
        suppose
E1:       k+1 in dom f; then
          j.(k+1) = F.(k+1) by SETWOP_2:22
                 .= i.(k+1) by E1,SETWOP_2:22;
          hence thesis;
        end;
        suppose
E2:       not k+1 in dom f; then
          j.(k+1) = the_unity_wrt h by SETWOP_2:22
                 .= the_unity_wrt g by BINOP_2:7,6
                 .= i.(k+1) by E2,SETWOP_2:22;
          hence thesis;
        end;
      end;
      reconsider a = i.(k+1), b = g $$(Seg k,i) as real number;
I1:   not (k + 1) in Seg k by FINSEQ_3:9;
      g $$ (Seg (k+1),i) = g $$ (Seg k \/ {k+1},i) by FINSEQ_1:11
        .= g.(g $$(Seg k,i),i.(k+1)) by I1,SETWOP_2:4
        .= g $$(Seg k,i) * (i.(k+1)) by BINOP_2:def 11
        .= h $$(Seg k,j) * (j.(k+1)) by CC,ZZ
        .= h.(h $$(Seg k,j),j.(k+1)) by BINOP_2:def 5
        .= h $$ (Seg k \/ {k+1},j) by I1,SETWOP_2:4
        .= h $$ (Seg (k+1),j) by FINSEQ_1:11;
      hence thesis;
    end;
    for k being Nat holds P[k] from NAT_1:sch 1(C1,C2); then
    g $$ F = h $$ f by D1,D2;
    hence thesis by DefCO;
  end;

theorem Th124:
  Product (<*> REAL) = 1
  proof
    Product <*>REAL = multreal $$ <*>REAL by Th123
                   .= the_unity_wrt multreal by FINSOP_1:11
                   .= 1 by BINOP_2:7;
    hence thesis;
  end;

registration let r be complex number;
  cluster <*r*> -> complex-yielding FinSequence-like;
  coherence
  proof
    reconsider p = r as Element of COMPLEX by XCMPLX_0:def 2;
    reconsider f = <*p*> as FinSequence of COMPLEX;
    f is FinSequence-like;
    hence thesis;
  end;
end;

registration let r1, r2 be complex number;
  cluster <*r1, r2*> -> complex-yielding FinSequence-like;
  coherence
  proof
    reconsider p1 = r1, p2 = r2 as Element of COMPLEX by XCMPLX_0:def 2;
    reconsider f = <*p1,p2*> as FinSequence of COMPLEX;
    f is FinSequence-like;
    hence thesis;
  end;
end;

registration let r1, r2, r3 be complex number;
  cluster <*r1, r2, r3*> -> complex-yielding FinSequence-like;
  coherence
  proof
    reconsider p1 = r1, p2 = r2, p3 = r3 as Element of COMPLEX
      by XCMPLX_0:def 2;
    reconsider f = <*p1,p2,p3*> as FinSequence of COMPLEX;
    f is FinSequence-like;
    hence thesis;
  end;
end;

theorem Th125:
  for r being complex number holds
    Product <*r*> = r
  proof
    let r be complex number;
    reconsider r' = r as Element of COMPLEX by XCMPLX_0:def 2;
    reconsider F = <*r'*> as FinSequence of COMPLEX;
    multcomplex $$ F = r by FINSOP_1:12;
    hence thesis by DefCO;
  end;

registration let f, g be complex-yielding FinSequence;
  cluster f ^ g -> complex-yielding;
  coherence
  proof
A1: rng f c= COMPLEX & rng g c= COMPLEX by ComY;
    rng (f ^ g) = rng f \/ rng g by FINSEQ_1:44; then
    rng (f ^ g) c= COMPLEX by A1,XBOOLE_1:8;
    hence thesis by ComY;
  end;
end;

theorem Th126:
  for F being complex-yielding FinSequence, r being complex number holds
    Product (F^<*r*>) = Product F * r
  proof
    let F be complex-yielding FinSequence, r be complex number;
    reconsider p = r as Element of COMPLEX by XCMPLX_0:def 2;
A1: rng F c= COMPLEX by ComY;
    rng (F^<*p*>) c= COMPLEX by ComY; then
    reconsider Fr = F^<*r*>, Ff = F as FinSequence of COMPLEX
      by A1,FINSEQ_1:def 4;
    thus Product (F^<*r*>) = multcomplex $$ Fr by DefCO
                 .= multcomplex.(multcomplex $$ Ff,p) by FINSOP_1:5
                 .= multcomplex.(Product Ff,p) by DefCO
                 .= Product F * r by BINOP_2:def 5;
  end;

theorem Th127:
  for F1, F2 being complex-yielding FinSequence holds
    Product (F1^F2) = Product F1 * Product F2
 proof
  let F1, F2 be complex-yielding FinSequence;
A1: rng F1 c= COMPLEX & rng F2 c= COMPLEX by ComY;
    rng (F1^F2) c= COMPLEX by ComY; then
    reconsider FF = F1^F2, f1 = F1, f2 = F2 as FinSequence of COMPLEX
      by A1,FINSEQ_1:def 4;
  thus Product (F1^F2) = multcomplex $$ FF by DefCO
    .= multcomplex.(multcomplex $$ f1,multcomplex $$ f2) by FINSOP_1:6
    .= multcomplex.(Product F1,multcomplex $$ f2) by DefCO
    .= multcomplex.(Product f1,Product f2) by DefCO
    .= Product F1 * Product F2 by BIN3;
 end;

theorem
  Product (<*r*>^F) = r * Product F
  proof thus Product (<*r*>^F) = Product <*r*> * Product F by Th127
    .= r * Product F by Th125;
  end;

theorem Th129:
  for r1, r2 being complex number holds
    Product <*r1,r2*> = r1 * r2
 proof
   let r1, r2 be complex number;
   thus Product <*r1,r2*> = Product <*r1*> * r2 by Th126
                  .= r1 * r2 by Th125;
 end;

theorem
  for r1, r2, r3 being complex number holds
    Product <*r1,r2,r3*> = r1 * r2 * r3
 proof
   let r1, r2, r3 be complex number;
   thus Product <*r1,r2,r3*> = Product <*r1,r2*> * r3 by Th126
                     .= r1 * r2 * r3 by Th129;
 end;

theorem
  for R being Element of 0-tuples_on REAL holds Product R = 1
    by Th124,FINSEQ_2:113;

registration let j be Nat, r be real number;
  cluster j |-> r -> real-yielding;
  coherence
  proof
    r in REAL by XREAL_0:def 1; then
    (j |-> r) is FinSequence of REAL by FINSEQ_2:77;
    hence thesis;
  end;
end;

theorem
  Product (i|->1) = 1
  proof
    reconsider f = i |-> 1 as FinSequence of REAL by FINSEQ_2:77;
    Product (i |-> the_unity_wrt multreal) =
      multreal $$ f by Th123,BINOP_2:7
      .= the_unity_wrt multreal by BINOP_2:7,SETWOP_2:35;
    hence thesis by BINOP_2:7;
  end;

theorem
  (ex k st k in dom F & F.k = 0) iff Product F = 0
 proof
   defpred P[Nat] means
    for F st len F = $1 holds (ex k st k in
      Seg $1 & F.k = 0) iff Product F = 0;
A1:  P[0] by Th124,FINSEQ_1:4,32;
A2: for i st P[i] holds P[i+1]
     proof let i such that
A3:   for F st len F = i holds (ex k st k in Seg i & F.k = 0) iff
        Product F = 0;
      let F; assume
A4:   len F = i+1;
      then consider F',x such that
A5:   F = F'^<*x*> by FINSEQ_2:22;
A6:   len F = len F' + 1 by A5,FINSEQ_2:19;then
A7:   len F' = i by A4;
A8:   Product F = Product F' * x by A5,Th126;
      thus (ex k st k in Seg (i+1) & F.k = 0) implies Product F = 0
      proof given k such that
A9:     k in Seg (i+1) and
A10:    F.k = 0;
        now per cases by A9,FINSEQ_2:8;
         suppose
A11:      k in Seg i;
          Seg len F' = dom F' by FINSEQ_1:def 3;
          then F'.k = F.k by A5,A7,A11,FINSEQ_1:def 7;
          then Product F' = 0 by A3,A7,A10,A11;
          hence thesis by A8;
         end;
         suppose k = i+1;
          then x = 0 by A4,A5,A6,A10,FINSEQ_1:59;
          hence thesis by A8;
        end;
        end;
        hence thesis;
       end;
      assume
A12:  Product F = 0;
      per cases by A8,A12,XCMPLX_1:6;
       suppose Product F' = 0;
        then consider k such that
A13:    k in Seg i & F'.k = 0 by A3,A7;
        Seg len F' = dom F' by FINSEQ_1:def 3;
        then k in Seg (i+1) & F.k = 0 by A5,A7,A13,FINSEQ_1:def 7,FINSEQ_2:9;
        hence thesis;
       end;
       suppose x = 0;
        then i+1 in Seg(i+1) & F.(i+1) = 0 by A4,A5,A6,FINSEQ_1:6,59;
        hence thesis;
     end;
     end;
A14: Seg len F = dom F by FINSEQ_1:def 3;
     for i holds P[i] from NAT_1:sch 1(A1,A2);
  hence thesis by A14;
 end;

theorem
  Product ((i+j)|->r) = (Product (i|->r))*(Product (j|->r))
 proof
   thus Product ((i+j)|->r) = multreal$$((i+j)|->r) by Th123
     .= multreal.(multreal$$(i|->r),multreal$$(j|->r)) by SETWOP_2:37
     .= (multreal$$(i|->r))*(multreal$$(j|->r)) by BINOP_2:def 11
     .= (multreal$$(i|->r))*(Product (j|->r)) by Th123
     .= (Product (i|->r))*(Product (j|->r)) by Th123;
 end;

theorem
  Product ((i*j)|->r) = Product (j |-> (Product (i|->r)))
  proof
    Product ((i*j) |-> (r qua Real)) =
         multreal $$ ((i*j) |-> (r qua Real)) by Th123
      .= multreal $$ (j |-> (multreal $$ (i|->(r qua Real)))) by SETWOP_2:38
      .= Product (j |-> (multreal $$ (i|->(r qua Real)))) by Th123
      .= Product (j |-> (Product (i|->(r qua Real)))) by Th123;
    hence thesis;
  end;

theorem
  Product (i|->(r1*r2)) = (Product (i|->r1))*(Product (i|->r2))
 proof
   thus Product (i|->(r1*r2)) = multreal$$(i|->(r1*r2)) by Th123
     .= multreal$$(i|->multreal.(r1,r2)) by BINOP_2:def 11
     .= multreal.(multreal$$(i|->r1),multreal$$(i|->r2)) by SETWOP_2:47
     .= (multreal$$(i|->r1))*(multreal$$(i|->r2)) by BINOP_2:def 11
     .= (multreal$$(i|->r1))*(Product (i|->r2)) by Th123
     .= (Product (i|->r1))*(Product (i|->r2)) by Th123;
 end;

theorem Th137:
  Product mlt(R1,R2) = Product R1 * Product R2
 proof
   thus Product (mlt(R1,R2)) = multreal $$ mlt (R1,R2) by Th123
    .= multreal.(multreal$$R1,multreal$$R2) by SETWOP_2:46
    .= multreal.(Product R1,multreal$$R2) by Th123
    .= multreal.(Product R1,Product R2) by Th123
    .= Product R1 * Product R2 by BIN2;
 end;

theorem
  Product (r*R) = Product (i|->r) * Product R
 proof
   thus Product (r*R) = Product mlt(i|->r,R) by Th92
    .= Product (i|->r) * Product R by Th137;
 end;

theorem
  Product sqr R = (Product R)^2
 proof
   thus Product sqr R = Product (mlt(R,R)) by Th97
               .= (Product R)^2 by Th137;
 end;
