:: The {B}anach Algebra of Bounded Linear Operators
::  by Yasunari Shidama
:: 
:: Received January 26, 2004
:: Copyright (c) 2004 Association of Mizar Users

environ

 vocabulary PRE_TOPC, NORMSP_1, RLVECT_1, FUNCT_1, ARYTM, ARYTM_1, FUNCT_2,
      VECTSP_1, ARYTM_3, RELAT_1, ABSVALUE, ORDINAL2, BINOP_1, GRCAT_1,
      UNIALG_1, LATTICES, FUNCSDOM, SEQ_1, SEQ_2, REALSET1, PREPOWER, SERIES_1,
      BHSP_3, RSSPACE, RSSPACE3, ALGSTR_2, LOPBAN_1, LOPBAN_2, SUPINF_2;
 notation TARSKI, XBOOLE_0, ZFMISC_1, ENUMSET1, SUBSET_1, MCART_1, RELSET_1,
      RELAT_1, FUNCT_1, PARTFUN1, FUNCT_2, FUNCT_3, PRE_TOPC, DOMAIN_1,
      FUNCOP_1, BINOP_1, STRUCT_0, XCMPLX_0, XREAL_0, RAT_1, INT_1, ORDINAL1,
      ORDINAL2, NUMBERS, MEMBERED, REAL_1, NAT_1, PSCOMP_1, ALG_1, RLVECT_1,
      VECTSP_1, REALSET1, VECTSP_2, FRAENKEL, ABSVALUE, RLSUB_1, NORMSP_1,
      BHSP_1, BHSP_2, BHSP_3, RSSPACE, RSSPACE3, SEQ_1, SEQ_2, SEQM_3, SEQ_4,
      SERIES_1, PREPOWER, FUNCSDOM, LOPBAN_1;
 constructors MCART_1, FUNCT_3, BINOP_1, ARYTM_0, REAL_1, XREAL_0, NAT_1,
      SQUARE_1, FUNCT_2, FUNCT_4, FUNCT_5, FUNCT_7, ABIAN, REALSET1, XCMPLX_0,
      SUBSET_1, MEMBERED, DOMAIN_1, SEQ_1, SEQ_2, SERIES_1, SEQ_4, PSCOMP_1,
      FUNCOP_1, PREPOWER, POWER, RLVECT_1, VECTSP_1, FRAENKEL, FUNCSDOM,
      PARTFUN1, RLSUB_1, NORMSP_1, BHSP_2, BHSP_3, RSSPACE, RSSPACE3, LOPBAN_1,
      SEQM_3, XBOOLE_0, VECTSP_2, GRCAT_1;
 clusters SUBSET_1, RELSET_1, FINSEQ_1, STRUCT_0, ARYTM_3, RELAT_1, REAL_1,
      NUMBERS, ORDINAL2, XBOOLE_0, FUNCT_1, FUNCT_2, BINOP_1, FUNCOP_1,
      RLVECT_1, VECTSP_1, NORMSP_1, XREAL_0, MEMBERED, FUNCSDOM, INT_1, SEQ_1,
      RSSPACE3, BHSP_1, LOPBAN_1, ZFMISC_1;
 requirements SUBSET, REAL, BOOLE, NUMERALS, ARITHM;
 definitions STRUCT_0, VECTSP_1, LOPBAN_1;
 theorems REAL_2, AXIOMS, ABSVALUE, RLVECT_1, VECTSP_1, BINOP_1, FUNCSDOM,
      XCMPLX_0, XCMPLX_1, SERIES_1, PSCOMP_1, FUNCT_1, SQUARE_1, FUNCT_2,
      NORMSP_1, SEQ_4, RSSPACE, RSSPACE3, LOPBAN_1, PREPOWER, ANPROJ_1;
 schemes BINOP_1, NAT_1;

begin :: Banach Algebra of Bounded Linear Operators

definition 
  let X be non empty set;
  let f,g be Element of Funcs(X,X);
 redefine func g*f -> Element of Funcs(X,X);
  coherence
    proof
      thus g*f is Element of Funcs(X,X) by FUNCT_2:12;
     end;
   end;

theorem LM040:
for X,Y,Z be RealLinearSpace
 for f be LinearOperator of X,Y
 for g be LinearOperator of Y,Z
      holds g*f is LinearOperator of X,Z
   proof
 let X,Y,Z be RealLinearSpace;
 let f be LinearOperator  of X,Y;
 let g be LinearOperator of Y,Z;
 now let v,w be VECTOR of X;
      thus (g*f).(v+w)
              =g.(f.(v+w)) by FUNCT_2:21
              .=g.(f.v+f.w) by LOPBAN_1:def 5
              .=g.(f.v)+g.(f.w) by LOPBAN_1:def 5
              .=(g*f).(v)+g.(f.w) by FUNCT_2:21
              .=(g*f).(v)+(g*f).(w) by FUNCT_2:21;
       end;
 then 
    P1: g*f is additive by LOPBAN_1:def 5;
  now let v be VECTOR of X, a be Real;
      thus (g*f).(a*v)
              =g.(f.(a*v)) by FUNCT_2:21
              .=g.(a*f.v) by LOPBAN_1:def 6
              .=a*g.(f.v) by LOPBAN_1:def 6
              .=a*(g*f).(v) by FUNCT_2:21;
       end;
 then
   P2: g*f is homogeneous by LOPBAN_1:def 6;
 thus thesis by P1,P2;
   end;

theorem LM050:
for X,Y,Z be RealNormSpace
 for f be bounded LinearOperator of X,Y
 for g be bounded LinearOperator of Y,Z
      holds g*f is bounded LinearOperator of X,Z
      & for x be VECTOR of X holds ||.((g*f).x).||
              <=(BoundedLinearOperatorsNorm(Y,Z).g)
               *(BoundedLinearOperatorsNorm(X,Y).f )*||.x.||
      &  (BoundedLinearOperatorsNorm(X,Z).(g*f))
               <=(BoundedLinearOperatorsNorm(Y,Z).g)
                  *(BoundedLinearOperatorsNorm(X,Y).f)
     proof
 let X,Y,Z be RealNormSpace;
 let f be bounded LinearOperator of X,Y;
 let g be bounded LinearOperator of Y,Z;
 A0:
 R_NormSpace_of_BoundedLinearOperators(X,Y) =
 NORMSTR (# BoundedLinearOperators(X,Y),
         Zero_(BoundedLinearOperators(X,Y),
         R_VectorSpace_of_LinearOperators(X,Y)),
          Add_(BoundedLinearOperators(X,Y),
          R_VectorSpace_of_LinearOperators(X,Y)),
           Mult_(BoundedLinearOperators(X,Y),
           R_VectorSpace_of_LinearOperators(X,Y)),
          BoundedLinearOperatorsNorm(X,Y) #) by LOPBAN_1:def 15;

 B0:
  R_NormSpace_of_BoundedLinearOperators(Y,Z) =
  NORMSTR (# BoundedLinearOperators(Y,Z),
          Zero_(BoundedLinearOperators(Y,Z),
          R_VectorSpace_of_LinearOperators(Y,Z)),
           Add_(BoundedLinearOperators(Y,Z),
           R_VectorSpace_of_LinearOperators(Y,Z)),
            Mult_(BoundedLinearOperators(Y,Z),
            R_VectorSpace_of_LinearOperators(Y,Z)),
           BoundedLinearOperatorsNorm(Y,Z) #)
       by LOPBAN_1:def 15;
    f is Element of BoundedLinearOperators(X,Y) by LOPBAN_1:def 10;
    then
    reconsider ff=f as Point of
     R_NormSpace_of_BoundedLinearOperators(X,Y) by A0;
    g is Element of BoundedLinearOperators(Y,Z)
         by LOPBAN_1:def 10;
       then reconsider gg=g as Point of
        R_NormSpace_of_BoundedLinearOperators(Y,Z) by B0;
 P0: g*f is LinearOperator of X,Z by LM040;
 P1: now let v be VECTOR of X;
          P11: ||.(g*f).v.|| = ||.g.(f.v).|| by FUNCT_2:21;
          P12: ||.g.(f.(v)).|| <=||.gg.|| * ||.f.(v).|| by LOPBAN_1:38;
          P13: ||.f.(v).|| <=||.ff.|| * ||.v.|| by LOPBAN_1:38;
          0 <=   ||.gg.|| by NORMSP_1:8; then
          ||.gg.|| * ||.f.(v).|| <=||.gg.|| * ( ||.ff.|| * ||.v.||)
                by AXIOMS:25,P13; then
                 ||.g.(f.(v)).|| <=||.gg.|| * ( ||.ff.|| * ||.v.||)
             by AXIOMS:22,P12;
          hence ||.(g*f).v.||
                  <=(||.gg.|| *  ||.ff.||) * ||.v.|| by XCMPLX_1:4,P11;
      end;
0 <=  ||.gg.|| & 0 <= ||.ff.|| by NORMSP_1:8;
then
P2: 0 <= ||.gg.|| * ||.ff.|| by SQUARE_1:19;
set K = ||.gg.|| * ||.ff.||;
P3: g*f is bounded LinearOperator of X,Z by LOPBAN_1:def 9,P1,P0,P2;
P4: (BoundedLinearOperatorsNorm(X,Y).f) = ||.ff.|| by A0,NORMSP_1:def 1;
P5: (BoundedLinearOperatorsNorm(Y,Z).g) = ||.gg.|| by B0,NORMSP_1:def 1;
P6:for x be VECTOR of X holds ||.((g*f).x).||
              <=(BoundedLinearOperatorsNorm(Y,Z).g)
               *(BoundedLinearOperatorsNorm(X,Y).f )*||.x.|| by P4,P5,P1;

P7:
now let t be VECTOR of X such that
  A41: ||.t.|| <= 1;
 B7: K*||.t.|| <=K*1 by P2,A41,AXIOMS:25;
 ||.(g*f).t.|| <=K* ||.t.|| by P1;
   hence ||.(g*f).t.|| <=K by B7,AXIOMS:22;
end;

reconsider gf=g*f as bounded LinearOperator of X,Z by P3;

P8: now let r be Real such that
        AS1:  r in PreNorms(gf);
        AS2:  r in {||.gf.t.|| where t is VECTOR of X : ||.t.|| <= 1 }
 by LOPBAN_1:def 13,AS1;
        consider t be VECTOR of X such that
          PS1:   r=||.gf.t.|| & ||.t.|| <= 1 by AS2;
          thus r <=K by PS1,P7;
  end;

P9:
(for s be real number st s in PreNorms(gf) holds s <=K)
implies sup PreNorms(gf) <=K by PSCOMP_1:10;
P10:sup PreNorms(gf) <=K by P8,P9;
BoundedLinearOperatorsNorm(X,Z).(g*f) = sup PreNorms(gf) by LOPBAN_1:36;
then BoundedLinearOperatorsNorm(X,Z).(g*f)
             <=(BoundedLinearOperatorsNorm(Y,Z).g)
                  *(BoundedLinearOperatorsNorm(X,Y).f) by P10,P4,P5;
hence thesis by P3,P6;
end;

definition
  let X be RealNormSpace;
  let f,g be bounded LinearOperator of X,X;
  redefine func g*f -> bounded LinearOperator of X,X;
  correctness by LM050;
end;

definition
  let X be RealNormSpace;
  let f,g be Element of BoundedLinearOperators(X,X);
  func f + g -> Element of BoundedLinearOperators(X,X) equals :Def000:
  Add_ ( BoundedLinearOperators(X,X), R_VectorSpace_of_LinearOperators(X,X) )
     .(f,g);
correctness;
end;

definition
  let X be RealNormSpace;
  let f,g be Element of BoundedLinearOperators(X,X);
  func g*f -> Element of BoundedLinearOperators(X,X) equals :Def010:
  modetrans(g,X,X)*modetrans(f,X,X);
  correctness by LOPBAN_1:def 10;
end;

definition
  let X be RealNormSpace;
  let f be Element of BoundedLinearOperators(X,X);
  let a be Real;
  func a*f  -> Element of BoundedLinearOperators(X,X) equals :Def015:
  Mult_(BoundedLinearOperators(X,X),
                R_VectorSpace_of_LinearOperators(X,X)).(a,f);
  correctness;
end;

definition let X be RealNormSpace;
  func FuncMult(X) -> BinOp of BoundedLinearOperators(X,X) means :Def020:
  for f,g being Element of BoundedLinearOperators(X,X) holds
  it.(f,g) = f*g;
 existence
 proof
 deffunc F(Element of BoundedLinearOperators(X,X),
 Element of BoundedLinearOperators(X,X)) =
   $1*$2;
 consider F being BinOp of BoundedLinearOperators(X,X) such that
A1:  for x,y being Element of BoundedLinearOperators(X,X) holds
  F.(x,y) = F(x,y) from BINOP_1:sch 2;
 take F; let f,g be Element of BoundedLinearOperators(X,X);
 thus F.(f,g) =(f*g) by A1;
 end;
 uniqueness
  proof let it1,it2 be BinOp of
  BoundedLinearOperators(X,X) such that
   A2: for f,g being Element of
   BoundedLinearOperators(X,X) holds it1.(f,g) = f*g and
   A3: for f,g being Element of
   BoundedLinearOperators(X,X) holds it2.(f,g) = f*g;
     now let f,g be Element of 
     BoundedLinearOperators(X,X);
    thus it1.(f,g) = f*g by A2 .=it2.(f,g) by A3; end;
   hence thesis by BINOP_1:2;
  end;
end;

theorem LM055: 
  for X be RealNormSpace holds 
    id (the carrier of X) is bounded LinearOperator of X,X
   proof
   let  X be RealNormSpace;
   A1: id (the carrier of X) is LinearOperator of X,X
      proof
       now let v,w be VECTOR of X;
         thus ( id (the carrier of X)).(v+w)
                 =v+w by FUNCT_1:35
                .=(id (the carrier of X)).v
                  + w by FUNCT_1:35
               .=(id (the carrier of X)).v
                 + (id (the carrier of X)).w by FUNCT_1:35;
          end; then
       P1: id (the carrier of X) is additive by LOPBAN_1:def 5;
     now let v be VECTOR of X, a be Real;
         thus (id (the carrier of X)).(a*v)
                 =a*v by FUNCT_1:35
                 .=a*(id (the carrier of X)).(v) by FUNCT_1:35;
          end; then
      P2: id (the carrier of X) is homogeneous by LOPBAN_1:def 6;
    thus thesis by P1,P2;
   end;

A2: now let v be VECTOR of X;
         thus ||.id (the carrier of X).v.|| <=1* ||.v.|| by FUNCT_1:35;
      end;
 hence thesis by LOPBAN_1:def 9,A1;
 end;

definition let X be RealNormSpace;
   func FuncUnit(X) -> Element of BoundedLinearOperators(X,X) equals
 :Def030:   id (the carrier of X);
  coherence 
  proof
     id (the carrier of X) is bounded LinearOperator of X,X by LM055;
     then id (the carrier of X) in BoundedLinearOperators(X,X)
 by LOPBAN_1:def 10;
     hence thesis;
  end;
  end;

theorem LM060: 
   for X be RealNormSpace 
   for f,g,h be bounded LinearOperator of X,X holds
   h = f*g iff for x be VECTOR of X holds h.x = f.(g.x)
   proof
 let X be RealNormSpace;
 let f,g,h be bounded LinearOperator of X,X;
  A1: now assume A2: h = f*g;
     let x be VECTOR of X;
      thus h.x = f.(g.x) by A2,FUNCT_2:21;
       end;
     now assume A4: for x being VECTOR of X holds h.x=f.(g.x);
     now let x be VECTOR of X;
    thus (f*g).x = f.(g.x) by FUNCT_2:21
                        .= h.x by A4; 
     end;
   hence h = f*g by FUNCT_2:113;
   end;
 hence thesis by A1; 
 end;

theorem LM070:
  for X be RealNormSpace 
  for f,g,h be bounded LinearOperator of X,X 
  holds f*(g*h) =(f*g)*h
 proof
 let X be RealNormSpace;
 let f,g,h be bounded LinearOperator of X,X;
     now let x be VECTOR of X;
  thus (f*(g*h)).x
           =f.((g*h).x) by LM060
         .= f.(g.(h.x)) by LM060
         .= (f*g).(h.x) by FUNCT_2:21

        .= ((f*g)*h).x by LM060;
      end;
 hence thesis by FUNCT_2:113; end;

theorem LM080: 
  for X be RealNormSpace
  for f be bounded LinearOperator of X,X holds
  f*(id the carrier of X) = f  & (id the carrier of X )*f=f
  proof
 let X be RealNormSpace;
 let f be bounded LinearOperator of X,X;
   (id the carrier of X) is bounded LinearOperator of X,X by LM055;
   then reconsider
   ii=(id the carrier of X) as bounded LinearOperator of X,X;
now let x be VECTOR of X;
thus ( f*(id the carrier of X)).x
     =( f*ii).x
    .=f.(ii.x) by LM060 
   .=f.x by FUNCT_1:35;
end;
then 
P1: f*(id the carrier of X) = f by FUNCT_2:113;
now let x be VECTOR of X;
thus ( (id the carrier of X)*f).x =( ii*f).x
    .=ii.(f.x) by LM060
   .=f.x by FUNCT_1:35;
end;
then (id the carrier of X)*f = f by FUNCT_2:113;
hence thesis by P1;
end;

theorem LM071: 
 for X be RealNormSpace
 for f,g,h be Element of BoundedLinearOperators(X,X) 
 holds f*(g*h) =(f*g)*h
 proof
  let X be RealNormSpace;
  let f,g,h be Element of BoundedLinearOperators(X,X);
P1: f*(g*h) =modetrans(f,X,X)*modetrans((g*h),X,X) by Def010;
P3: modetrans(g,X,X)*modetrans(h,X,X)
  is Element of BoundedLinearOperators(X,X) by LOPBAN_1:def 10;
P4:modetrans((g*h),X,X)
 =modetrans(modetrans(g,X,X)*modetrans(h,X,X),X,X ) by Def010
.=modetrans(g,X,X)*modetrans(h,X,X) by P3,LOPBAN_1:def 12;
P5: modetrans(f,X,X)*modetrans((g*h),X,X)
=(modetrans(f,X,X)*modetrans(g,X,X))*modetrans(h,X,X) by LM070,P4;
P7: modetrans(f,X,X)*modetrans(g,X,X)
  is Element of BoundedLinearOperators(X,X) by LOPBAN_1:def 10;
P8:modetrans((f*g),X,X)
 =modetrans(modetrans(f,X,X)*modetrans(g,X,X),X,X ) by Def010
.=modetrans(f,X,X)*modetrans(g,X,X) by P7,LOPBAN_1:def 12;
modetrans(f,X,X)*modetrans((g*h),X,X) =(f*g)*h by Def010,P5,P8;
hence thesis by P1;
end;

theorem LM081:
  for X be RealNormSpace
  for f be Element of BoundedLinearOperators(X,X) holds
  f*FuncUnit(X)= f & FuncUnit(X)*f=f
proof
 let X be RealNormSpace;
 let f be Element of BoundedLinearOperators(X,X);
(id the carrier of X) is bounded LinearOperator of X,X by LM055; then
P2:  (id the carrier of X)
  is Element of BoundedLinearOperators(X,X) by LOPBAN_1:def 10;
P3:  modetrans( (id (the carrier of X)),X,X)
= (id the carrier of X) by P2,LOPBAN_1:def 12;
thus f*FuncUnit(X)
=modetrans(f,X,X)*modetrans(FuncUnit(X),X,X) by Def010
.=modetrans(f,X,X)*modetrans((id the carrier of X),X,X) by Def030
.=modetrans(f,X,X) by LM080,P3
.=f by LOPBAN_1:def 12;
thus FuncUnit(X)*f =modetrans(FuncUnit(X),X,X)*modetrans(f,X,X) by Def010
.=modetrans((id the carrier of X),X,X)*modetrans(f,X,X) by Def030
.=modetrans(f,X,X) by LM080,P3
.=f by LOPBAN_1:def 12;
end;

theorem LM090L:
  for X be RealNormSpace
  for f,g,h be Element of BoundedLinearOperators(X,X) holds
  f *(g+h)=f*g + f*h
proof
  let X be RealNormSpace;
  let f,g,h be Element of BoundedLinearOperators(X,X);
  A0: R_NormSpace_of_BoundedLinearOperators(X,X) =
       NORMSTR (# BoundedLinearOperators(X,X),
               Zero_(BoundedLinearOperators(X,X),
               R_VectorSpace_of_LinearOperators(X,X)),
                Add_(BoundedLinearOperators(X,X),
                R_VectorSpace_of_LinearOperators(X,X)),
                 Mult_(BoundedLinearOperators(X,X),
                 R_VectorSpace_of_LinearOperators(X,X)),
                BoundedLinearOperatorsNorm(X,X) #)
      by LOPBAN_1:def 15;
set BLOP=R_NormSpace_of_BoundedLinearOperators(X,X);
set ADD=Add_(BoundedLinearOperators(X,X),
                R_VectorSpace_of_LinearOperators(X,X));
set mf=modetrans(f,X,X);
set mg=modetrans(g,X,X);
set mh=modetrans(h,X,X);
set mgh=modetrans(g+h, X,X);
H0: f*(g+h) = mf*mgh by Def010;
H1: ADD.(mf*mg, mf*mh) =mf*mgh
proof 
reconsider ff = f as VECTOR of BLOP by A0;
reconsider gg = g as VECTOR of BLOP by A0;
reconsider hh = h as VECTOR of BLOP by A0;
H5:gg=mg by LOPBAN_1:def 12;
H6:hh=mh by LOPBAN_1:def 12;
mf*mgh in BoundedLinearOperators(X,X) by LOPBAN_1:def 10;
then
reconsider k=mf*mgh as VECTOR of BLOP by A0;
mf*mg in BoundedLinearOperators(X,X) by LOPBAN_1:def 10;
then
reconsider fg=mf*mg as VECTOR of BLOP by A0;
mf*mh in BoundedLinearOperators(X,X) by LOPBAN_1:def 10; then
reconsider fh=mf*mh as VECTOR of BLOP by A0;
H7: ADD.(mf*mg,mf*mh) =(the add of BLOP).[fg,fh] by BINOP_1:def 1,A0
    .=fg+fh by RLVECT_1:def 3;
H8: for x be VECTOR of X holds (mf*mgh).x=(mf*mg).x + (mf*mh).x
      proof
      let x be VECTOR of X;
      mgh in BoundedLinearOperators(X,X) by LOPBAN_1:def 10; then
        reconsider gh=mgh as VECTOR of BLOP by A0;
        H10:  g+h=ADD.(g,h) by Def000
               .=(the add of BLOP).[g,h] by BINOP_1:def 1,A0
                .=gg+hh by RLVECT_1:def 3;
         H11: modetrans(g+h, X,X) =g+h by LOPBAN_1:def 12;
         gh=gg+hh by H10,H11; then
         H13: mgh.x=mg.x+mh.x by H5,H6,LOPBAN_1:41;
         thus (mf*mgh).x=mf.(mgh.x) by LM060
                       .=mf.(mg.x) +mf.(mh.x) by LOPBAN_1:def 5,H13
                       .=(mf*mg).x+mf.(mh.x) by LM060
                       .=(mf*mg).x+ (mf*mh).x by LM060;
          end;
H9:  k=fg+fh by LOPBAN_1:41,H8;
 mf*mgh=ADD.(mf*mg,mf*mh) by H9,H7;
hence thesis;
end;

H2: ADD.(mf*mg,mf*mh)
          = ADD.(f*g,mf*mh) by Def010
         .= ADD.(f*g,f*h)  by Def010
         .=f*g+f*h by Def000;
thus f *(g+h)=f*g+f*h by H0,H1,H2;
end;

theorem LM090R:
  for X be RealNormSpace
  for f,g,h be Element of BoundedLinearOperators(X,X) holds
  (g+h)*f = g*f + h*f
proof
  let X be RealNormSpace;
  let f,g,h be Element of BoundedLinearOperators(X,X);
  A0: R_NormSpace_of_BoundedLinearOperators(X,X) =
       NORMSTR (# BoundedLinearOperators(X,X),
               Zero_(BoundedLinearOperators(X,X),
               R_VectorSpace_of_LinearOperators(X,X)),
                Add_(BoundedLinearOperators(X,X),
                R_VectorSpace_of_LinearOperators(X,X)),
                 Mult_(BoundedLinearOperators(X,X),
                 R_VectorSpace_of_LinearOperators(X,X)),
                BoundedLinearOperatorsNorm(X,X) #)
      by LOPBAN_1:def 15;

set BLOP=R_NormSpace_of_BoundedLinearOperators(X,X);
set ADD=Add_(BoundedLinearOperators(X,X),
                R_VectorSpace_of_LinearOperators(X,X));
set mf=modetrans(f,X,X);
set mg=modetrans(g,X,X);
set mh=modetrans(h,X,X);
set mgh=modetrans(g+h, X,X);
H0: (g+h)*f  = mgh*mf by Def010;
H1: ADD.(mg*mf, mh*mf) =mgh*mf
proof 
reconsider ff = f as VECTOR of BLOP by A0;
reconsider gg = g as VECTOR of BLOP by A0;
reconsider hh = h as VECTOR of BLOP by A0;
H5:gg=mg by LOPBAN_1:def 12;
H6:hh=mh by LOPBAN_1:def 12;
mgh*mf in BoundedLinearOperators(X,X) by LOPBAN_1:def 10; then
reconsider k=mgh*mf as VECTOR of BLOP by A0;
mg*mf in BoundedLinearOperators(X,X) by LOPBAN_1:def 10; then
reconsider gf=mg*mf as VECTOR of BLOP by A0;
mh*mf in BoundedLinearOperators(X,X) by LOPBAN_1:def 10; then
reconsider hf=mh*mf as VECTOR of BLOP by A0;
H7: ADD.(mg*mf,mh*mf) =(the add of BLOP).[gf,hf] by BINOP_1:def 1,A0
    .=gf+hf by RLVECT_1:def 3;
H8: for x be VECTOR of X holds
      (mgh*mf).x=(mg*mf).x + (mh*mf).x
      proof
      let x be VECTOR of X;
      mgh in BoundedLinearOperators(X,X) by LOPBAN_1:def 10;
        then
        reconsider gh=mgh as VECTOR of BLOP by A0;
        H10:  g+h=ADD.(g,h) by Def000
               .=(the add of BLOP).[g,h] by A0,BINOP_1:def 1
                .=gg+hh by RLVECT_1:def 3;
         H11: modetrans(g+h, X,X)
                  =g+h by LOPBAN_1:def 12;
          gh=gg+hh by H10,H11;
         then   
         H13: mgh.(mf.x)=mg.(mf.x)+mh.(mf.x) by H5,H6,LOPBAN_1:41;
         thus 
         (mgh*mf).x=mgh.(mf.x) by LM060
                       .=(mg*mf).x+mh.(mf.x) by LM060,H13
                       .=(mg*mf).x+ (mh*mf).x by LM060;
          end;
H9:  k=gf+hf by LOPBAN_1:41,H8;
 mgh*mf=ADD.(mg*mf,mh*mf) by H9,H7;
hence thesis;
end;

H2: ADD.(mg*mf,mh*mf)
          = ADD.(g*f,mh*mf) by Def010
         .= ADD.(g*f,h*f) by Def010
         .=g*f+h*f by Def000;
thus (g+h)*f=g*f+h*f by H0,H1,H2;
end;

theorem LM100:
 for X be RealNormSpace 
 for f,g be Element of BoundedLinearOperators(X,X) 
 for a,b be Real holds
 (a*b)*(f*g)=(a*f)*(b*g)
proof
 let X be RealNormSpace;
 let f,g be Element of BoundedLinearOperators(X,X);
 let a,b be Real;
  A0: R_NormSpace_of_BoundedLinearOperators(X,X) =
       NORMSTR (# BoundedLinearOperators(X,X),
               Zero_(BoundedLinearOperators(X,X),
               R_VectorSpace_of_LinearOperators(X,X)),
                Add_(BoundedLinearOperators(X,X),
                R_VectorSpace_of_LinearOperators(X,X)),
                 Mult_(BoundedLinearOperators(X,X),
                 R_VectorSpace_of_LinearOperators(X,X)),
                BoundedLinearOperatorsNorm(X,X) #) by LOPBAN_1:def 15;
set BLOP=R_NormSpace_of_BoundedLinearOperators(X,X);
set EXMULT=Mult_(BoundedLinearOperators(X,X),
                 R_VectorSpace_of_LinearOperators(X,X));
set mf=modetrans(f,X,X);
set mg=modetrans(g,X,X);
set maf=modetrans((a*f),X,X);
set mbg=modetrans(b*g,X,X);
set mfg=modetrans(f*g,X,X);
H0: (a*f)*(b*g) = maf*mbg by Def010;
H1: EXMULT.(a*b,mf*mg)=maf*mbg
proof
reconsider ff = f, gg = g as VECTOR of BLOP by A0;
H4:ff=mf by LOPBAN_1:def 12;
H5:gg=mg by LOPBAN_1:def 12;
mf*mg in BoundedLinearOperators(X,X) by LOPBAN_1:def 10;
then reconsider fg=mf*mg as VECTOR of BLOP by A0;
maf*mbg in BoundedLinearOperators(X,X) by LOPBAN_1:def 10;
then
reconsider k=(maf)*(mbg) as VECTOR of BLOP by A0;
H7: EXMULT.(a*b,mf*mg)=(the Mult of BLOP).[a*b,fg] by BINOP_1:def 1,A0
    .=(a*b)*fg by RLVECT_1:def 4;
H8: for x be VECTOR of X holds
     ( (maf)*(mbg)).x=(a*b)*(mf*mg).x
      proof
      let x be VECTOR of X;
        set y=b*mg.x;
        maf in BoundedLinearOperators(X,X) by LOPBAN_1:def 10; then
        reconsider af=maf as VECTOR of BLOP by A0;
        H10:  a*f=EXMULT.(a,f) by Def015
               .=(the Mult of BLOP).[a,f] by BINOP_1:def 1,A0
                .=a*ff by RLVECT_1:def 4;
         H11: modetrans(a*f, X,X)
                  =a*f by LOPBAN_1:def 12;
          af=a*ff by H10,H11; then
         H13: maf.y=a*mf.y by H4,LOPBAN_1:42;
         mbg in BoundedLinearOperators(X,X) by LOPBAN_1:def 10; then
          reconsider bg=mbg as VECTOR of BLOP by A0;
           KH10:  b*g=EXMULT.(b,g) by Def015
                      .=(the Mult of BLOP).[b,g] by BINOP_1:def 1,A0
                       .=b*gg by RLVECT_1:def 4;
            KH11: modetrans(b*g, X,X)
                        =b*g by LOPBAN_1:def 12;
             bg=b*gg by KH10,KH11; then
            KH13: mbg.x=b*mg.x by H5,LOPBAN_1:42;
           thus (maf*mbg).x=maf.(mbg.x) by LM060
                       .=a*(b*mf.(mg.x)) by LOPBAN_1:def 6,H13,KH13
                       .=(a*b)*mf.(mg.x) by RLVECT_1:def 9
                       .=(a*b)*(mf*mg).x by LM060;
          end;
H9:  k=(a*b)*fg by LOPBAN_1:42,H8;
 maf*mbg=EXMULT.(a*b,mf*mg) by H9,H7;
hence thesis;
end;
H2: EXMULT.(a*b,mf*mg) = EXMULT.(a*b,f*g) by Def010
          .=(a*b)*(f*g) by Def015;
thus (a*b)*(f*g)=(a*f)*(b*g) by H0,H1,H2;
end;

theorem LM101:
 for X be RealNormSpace
 for f,g be Element of BoundedLinearOperators(X,X)
 for a be Real holds
 a*(f*g) =(a*f)*g
proof
 let X be RealNormSpace;
 let f,g be Element of BoundedLinearOperators(X,X);
 let a be Real;
set BL=R_NormSpace_of_BoundedLinearOperators(X,X);
 set RRL=RLSStruct (# BoundedLinearOperators(X,X),
         Zero_(BoundedLinearOperators(X,X),
         R_VectorSpace_of_LinearOperators(X,X)),
          Add_(BoundedLinearOperators(X,X),
          R_VectorSpace_of_LinearOperators(X,X)),
         Mult_(BoundedLinearOperators(X,X),
         R_VectorSpace_of_LinearOperators(X,X)) #);
 set EXMULT=Mult_(BoundedLinearOperators(X,X),
                    R_VectorSpace_of_LinearOperators(X,X));
 reconsider gg=g as Element of RRL;
P1:  a*(f*g)=(a*1)*(f*g)
          .=(a*f)*(1*g) by LM100;
      (1*g)=(EXMULT).(1,g) by Def015
            .= (EXMULT).[1,g] by BINOP_1:def 1
         .=1*gg by RLVECT_1:def 4
         .=g by RLVECT_1:def 9;
hence a*(f*g)=(a*f)*g by P1;
 end;

definition
 let X be RealNormSpace;
  func Ring_of_BoundedLinearOperators(X) -> doubleLoopStr equals :Def040:
     doubleLoopStr
     (# BoundedLinearOperators(X,X),
           Add_(BoundedLinearOperators(X,X),
                    R_VectorSpace_of_LinearOperators(X,X)),
          FuncMult(X),
          FuncUnit(X),
          Zero_(BoundedLinearOperators(X,X),
                   R_VectorSpace_of_LinearOperators(X,X))
    #);
  correctness;
end;

registration
 let X be RealNormSpace;
 cluster Ring_of_BoundedLinearOperators(X) -> non empty strict;
 coherence
  proof
a1:      Ring_of_BoundedLinearOperators(X)
      = doubleLoopStr
     (# BoundedLinearOperators(X,X),
           Add_(BoundedLinearOperators(X,X),
                    R_VectorSpace_of_LinearOperators(X,X)),
          FuncMult(X),
          FuncUnit(X),
          Zero_(BoundedLinearOperators(X,X),
                   R_VectorSpace_of_LinearOperators(X,X))
     #) by Def040;
   hence the carrier of Ring_of_BoundedLinearOperators(X) is non empty;
   thus thesis by a1;
  end;
end;

theorem LM105:
   for X be RealNormSpace 
     for x,y,z being Element of Ring_of_BoundedLinearOperators(X) holds
         x+y = y+x &
         (x+y)+z = x+(y+z) &
         x+(0.Ring_of_BoundedLinearOperators(X)) = x &
         (ex t being Element of 
            Ring_of_BoundedLinearOperators(X) st  x+t=
          0.Ring_of_BoundedLinearOperators(X)) &
         (x*y)*z = x*(y*z) &
         x*(1_ Ring_of_BoundedLinearOperators(X)) = x &
         (1_ Ring_of_BoundedLinearOperators(X))*x = x &
         x*(y+z) = x*y + x*z &
         (y+z)*x = y*x + z*x
 proof 
 let X be RealNormSpace;
 let x,y,z be Element of Ring_of_BoundedLinearOperators(X);
 set RBLOP=Ring_of_BoundedLinearOperators(X);
 set BLOP=BoundedLinearOperators(X,X);
 set ADD=Add_(BoundedLinearOperators(X,X),
                    R_VectorSpace_of_LinearOperators(X,X));
 set MULT= FuncMult(X);
 set ZE=Zero_(BoundedLinearOperators(X,X),
                   R_VectorSpace_of_LinearOperators(X,X));
 set EXMULT =Mult_(BoundedLinearOperators(X,X),
                 R_VectorSpace_of_LinearOperators(X,X));
 set UNIT=FuncUnit(X);
 A1: RBLOP= doubleLoopStr
     (# BoundedLinearOperators(X,X),
           Add_(BoundedLinearOperators(X,X),
                    R_VectorSpace_of_LinearOperators(X,X)),
          FuncMult(X),
          FuncUnit(X),
          Zero_(BoundedLinearOperators(X,X),
                   R_VectorSpace_of_LinearOperators(X,X)) #) by Def040;
  set RRL=RLSStruct (# BoundedLinearOperators(X,X),
         Zero_(BoundedLinearOperators(X,X),
         R_VectorSpace_of_LinearOperators(X,X)),
          Add_(BoundedLinearOperators(X,X),
          R_VectorSpace_of_LinearOperators(X,X)),
         Mult_(BoundedLinearOperators(X,X),
         R_VectorSpace_of_LinearOperators(X,X)) #);
  set IT = RBLOP;
  reconsider f=x, g=y, h=z as Element of RRL by A1;
  thus x+y = ADD.(f,g) by A1,RLVECT_1:5
               .=f+g by RLVECT_1:5
               .= ADD.(g,f) by RLVECT_1:5
               .= y+x by A1,RLVECT_1:5;
   thus (x+y)+z = ADD.(x+y,h) by A1,RLVECT_1:5
              .= ADD.(ADD.(f,g),h) by A1,RLVECT_1:5
              .= ADD.((f+g),h) by RLVECT_1:5
              .=(f+g)+h by RLVECT_1:5
              .=f+(g+h) by RLVECT_1:def 6
              .= ADD.(f,(g+h)) by RLVECT_1:5
              .= ADD.(f,ADD.(g,h)) by RLVECT_1:5
              .= ADD.(f,y+z) by A1,RLVECT_1:5
              .= x+(y+z) by A1,RLVECT_1:5;
  thus x+(0.RBLOP) = ADD.(f,0.RBLOP) by A1,RLVECT_1:5
                     .= ADD.(f,ZE) by A1,RLVECT_1:def 2
                     .= ADD.(f,0.RRL) by RLVECT_1:def 2
                     .= f + 0.RRL by RLVECT_1:5
                     .= x by RLVECT_1:def 7;
  thus ex t being Element of RBLOP st x+t=(0.RBLOP)
   proof
    consider s be Element of RRL such that
    LL: f + s = 0.RRL by RLVECT_1:def 8;
    reconsider t=s as Element of RBLOP by A1;
    take t;
    thus x+t = ADD.(f,s) by A1,RLVECT_1:5
               .=f+s by RLVECT_1:5
               .=ZE by RLVECT_1:def 2,LL
               .=0.RBLOP by A1,RLVECT_1:def 2;
   end;
  reconsider xx=x,yy=y,zz=z as Element of BLOP by A1;
  thus (x*y)*z = MULT.(x*y,z) by A1, VECTSP_1:def 10
                   .= MULT.(MULT.(x,y),z) by A1, VECTSP_1:def 10
                   .= MULT.(xx*yy,zz) by Def020
                   .=(xx*yy)*zz by Def020
                   .=xx*(yy*zz) by LM071
                   .= MULT.(xx,yy*zz) by Def020
                  .= MULT.(xx,MULT.(yy,zz)) by Def020
                  .= MULT.(x,(y*z)) by A1, VECTSP_1:def 10
                  .=x*(y*z) by A1, VECTSP_1:def 10;
  thus x*(1_ RBLOP) = MULT.(x,1_ IT) by A1,VECTSP_1:def 10
                     .= MULT.(x,UNIT) by A1,VECTSP_1:def 9
                     .=xx*UNIT by Def020
                     .= x by LM081;
  thus (1_ RBLOP)*x = MULT.(1_ IT,x) by A1,VECTSP_1:def 10
                     .= MULT.(UNIT,x) by A1,VECTSP_1:def 9
                     .=UNIT*xx by Def020
                     .= x by LM081;
  thus x*(y+z) = MULT.(x,y+z) by A1,VECTSP_1:def 10
              .= MULT.(x,ADD.(y,z)) by A1,RLVECT_1:5
              .=MULT.(xx,(yy+zz)) by Def000
              .=xx*(yy+zz) by Def020
              .=xx*yy + xx*zz by LM090L
              .= ADD.(xx*yy,xx*zz) by Def000
              .= ADD.(xx*yy,MULT.(xx,zz)) by Def020
              .= ADD.(MULT.(xx,yy),MULT.(xx,zz)) by Def020
              .= ADD.(x*y,MULT.(x,z)) by A1,VECTSP_1:def 10
              .= ADD.(x*y,x*z) by A1,VECTSP_1:def 10
              .= x*y + x*z by A1,RLVECT_1:5;
  thus (y+z)*x = MULT.(y+z,x) by A1,VECTSP_1:def 10
              .= MULT.(ADD.(y,z),x) by A1,RLVECT_1:5
              .=MULT.((yy+zz),xx) by Def000
              .=(yy+zz)*xx by Def020
              .=yy*xx + zz*xx by LM090R
              .= ADD.(yy*xx,zz*xx) by Def000
              .= ADD.(yy*xx,MULT.(zz,xx)) by Def020
              .= ADD.(MULT.(yy,xx),MULT.(zz,xx)) by Def020
              .= ADD.(y*x,MULT.(z,x)) by A1,VECTSP_1:def 10
              .= ADD.(y*x,z*x) by A1,VECTSP_1:def 10
              .= y*x + z*x by A1,RLVECT_1:5;
   end;

theorem ttt:
   for X be RealNormSpace holds Ring_of_BoundedLinearOperators(X) is Ring
 proof
   let X be RealNormSpace;
     for x,y,z being Element of Ring_of_BoundedLinearOperators(X)
      holds
         x+y = y+x &
         (x+y)+z = x+(y+z) &
         x+(0.Ring_of_BoundedLinearOperators(X)) = x &
         (ex t being Element of
            Ring_of_BoundedLinearOperators(X) st  x+t=
          0.Ring_of_BoundedLinearOperators(X)) &
         (x*y)*z = x*(y*z) &
         x*(1_ Ring_of_BoundedLinearOperators(X)) = x &
         (1_ Ring_of_BoundedLinearOperators(X))*x = x &
         x*(y+z) = x*y + x*z &
         (y+z)*x = y*x + z*x by LM105;
      hence thesis by RLVECT_1:def 5,def 6,def 7,def 8,
      VECTSP_1:def 13,def 16,def 18,def 19;
  end;

registration
   let X be RealNormSpace;
   cluster Ring_of_BoundedLinearOperators(X) ->
     Abelian add-associative right_zeroed right_complementable
     associative left_unital right_unital distributive;
 coherence by ttt;
end;

definition
 let X be RealNormSpace;
  func R_Algebra_of_BoundedLinearOperators(X) -> AlgebraStr equals :Def050:
   AlgebraStr
    (# BoundedLinearOperators(X,X),
        FuncMult(X),
        Add_(BoundedLinearOperators(X,X),
                     R_VectorSpace_of_LinearOperators(X,X)),
        Mult_(BoundedLinearOperators(X,X),
                 R_VectorSpace_of_LinearOperators(X,X)),
      FuncUnit(X),
      Zero_(BoundedLinearOperators(X,X),
               R_VectorSpace_of_LinearOperators(X,X))
    #);
  correctness;
end;

registration
 let X be RealNormSpace;
 cluster R_Algebra_of_BoundedLinearOperators(X) -> non empty strict;
 coherence
  proof
a1:   R_Algebra_of_BoundedLinearOperators(X) =
     AlgebraStr
    (# BoundedLinearOperators(X,X),
        FuncMult(X),
        Add_(BoundedLinearOperators(X,X),
                     R_VectorSpace_of_LinearOperators(X,X)),
        Mult_(BoundedLinearOperators(X,X),
                 R_VectorSpace_of_LinearOperators(X,X)),
      FuncUnit(X),
      Zero_(BoundedLinearOperators(X,X),
               R_VectorSpace_of_LinearOperators(X,X)) #) by Def050;
   hence the carrier of R_Algebra_of_BoundedLinearOperators(X) is non empty;
   thus thesis by a1;
  end;
end;

theorem LM115:
   for X be RealNormSpace
     for x,y,z being Element of
       R_Algebra_of_BoundedLinearOperators(X)
        for a,b be Real holds
         x+y = y+x &
         (x+y)+z = x+(y+z) &
         x+(0.R_Algebra_of_BoundedLinearOperators(X)) = x &
         (ex t being Element of 
            R_Algebra_of_BoundedLinearOperators(X) st  x+t=
          0.R_Algebra_of_BoundedLinearOperators(X)) &
         (x*y)*z = x*(y*z) &
         x*(1_ R_Algebra_of_BoundedLinearOperators(X)) = x &
         (1_ R_Algebra_of_BoundedLinearOperators(X))*x = x &
         x*(y+z) = x*y + x*z &
         (y+z)*x = y*x + z*x &
        a*(x*y) = (a*x)*y &
         a*(x+y) = a*x + a*y &
         (a+b)*x = a*x + b*x &
         (a*b)*x = a*(b*x)    &
         (a*b)*(x*y)=(a*x)*(b*y)
 proof
 let X be RealNormSpace;
 let x,y,z be Element of
           R_Algebra_of_BoundedLinearOperators(X);
 let a,b be Real;
 set RBLOP=R_Algebra_of_BoundedLinearOperators(X);
 set BLOP=BoundedLinearOperators(X,X);
 set ADD=Add_(BoundedLinearOperators(X,X),
                    R_VectorSpace_of_LinearOperators(X,X));
 set MULT= FuncMult(X);
 set ZE=Zero_(BoundedLinearOperators(X,X),
                   R_VectorSpace_of_LinearOperators(X,X));
 set EXMULT =Mult_(BoundedLinearOperators(X,X),
                 R_VectorSpace_of_LinearOperators(X,X));
 set UNIT=FuncUnit(X);
 A1: RBLOP= AlgebraStr
    (# BoundedLinearOperators(X,X),
        FuncMult(X),
        Add_(BoundedLinearOperators(X,X),
                     R_VectorSpace_of_LinearOperators(X,X)),
        Mult_(BoundedLinearOperators(X,X),
                 R_VectorSpace_of_LinearOperators(X,X)),
      FuncUnit(X),
      Zero_(BoundedLinearOperators(X,X),
               R_VectorSpace_of_LinearOperators(X,X)) #) by Def050;
  set RRL=RLSStruct (# BoundedLinearOperators(X,X),
         Zero_(BoundedLinearOperators(X,X),
         R_VectorSpace_of_LinearOperators(X,X)),
          Add_(BoundedLinearOperators(X,X),
          R_VectorSpace_of_LinearOperators(X,X)),
         Mult_(BoundedLinearOperators(X,X),
         R_VectorSpace_of_LinearOperators(X,X)) #);
  set IT = RBLOP;
  reconsider f=x, g=y, h=z as Element of RRL by A1;
  thus x+y = (the add of RBLOP).(x,y) by RLVECT_1:5
               .=f+g by RLVECT_1:5,A1
               .= ADD.(g,f) by RLVECT_1:5
               .= y+x by A1,RLVECT_1:5;
   thus (x+y)+z = ADD.(x+y,h) by A1,RLVECT_1:5
              .= ADD.(ADD.(f,g),h) by A1,RLVECT_1:5
              .= ADD.((f+g),h) by RLVECT_1:5
              .=(f+g)+h by RLVECT_1:5
              .=f+(g+h) by RLVECT_1:def 6
              .= ADD.(f,(g+h)) by RLVECT_1:5
              .= ADD.(f,ADD.(g,h)) by RLVECT_1:5
              .= ADD.(f,y+z) by A1,RLVECT_1:5
              .= x+(y+z) by A1,RLVECT_1:5;
  thus x+(0.RBLOP) = ADD.(f,0.RBLOP) by A1,RLVECT_1:5
                     .= ADD.(f,ZE) by A1,RLVECT_1:def 2
                     .= ADD.(f,0.RRL) by RLVECT_1:def 2
                     .= f + 0.RRL by RLVECT_1:5
                     .= x by RLVECT_1:def 7;
  thus ex t being Element of RBLOP st x+t=(0.RBLOP)
   proof
    consider s be Element of RRL such that
    LL: f + s = 0.RRL by RLVECT_1:def 8;
    reconsider t=s as Element of RBLOP by A1;
    take t;
    thus x+t = ADD.(f,s) by A1,RLVECT_1:5
               .=f+s by RLVECT_1:5
               .=ZE by RLVECT_1:def 2,LL
               .=0.RBLOP by A1,RLVECT_1:def 2;
   end;
  reconsider xx=x,yy=y,zz=z as Element of BLOP by A1;
  thus (x*y)*z = MULT.(x*y,z) by A1, VECTSP_1:def 10
                   .= MULT.(MULT.(x,y),z) by A1, VECTSP_1:def 10
                   .= MULT.(xx*yy,zz) by Def020
                   .=(xx*yy)*zz by Def020
                   .=xx*(yy*zz) by LM071
                   .= MULT.(xx,yy*zz) by Def020
                  .= MULT.(xx,MULT.(yy,zz)) by Def020
                  .= MULT.(x,(y*z)) by A1, VECTSP_1:def 10
                  .=x*(y*z) by A1, VECTSP_1:def 10;
  thus x*(1_ RBLOP) = MULT.(x,1_ IT) by A1,VECTSP_1:def 10
                     .= MULT.(x,UNIT) by A1,VECTSP_1:def 9
                     .=xx*UNIT by Def020
                     .= x by LM081;
  thus (1_ RBLOP)*x = MULT.(1_ IT,x) by A1,VECTSP_1:def 10
                     .= MULT.(UNIT,x) by A1,VECTSP_1:def 9
                     .=UNIT*xx by Def020
                     .= x by LM081;
  thus x*(y+z) = MULT.(x,y+z) by A1,VECTSP_1:def 10
              .= MULT.(x,ADD.(y,z)) by A1,RLVECT_1:5
              .=MULT.(xx,(yy+zz)) by Def000
              .=xx*(yy+zz) by Def020
              .=xx*yy + xx*zz by LM090L
              .= ADD.(xx*yy,xx*zz) by Def000
              .= ADD.(xx*yy,MULT.(xx,zz)) by Def020
              .= ADD.(MULT.(xx,yy),MULT.(xx,zz)) by Def020
              .= ADD.(x*y,MULT.(x,z)) by A1,VECTSP_1:def 10
              .= ADD.(x*y,x*z) by A1,VECTSP_1:def 10
              .= x*y + x*z by A1,RLVECT_1:5;
  thus (y+z)*x = MULT.(y+z,x) by A1,VECTSP_1:def 10
              .= MULT.(ADD.(y,z),x) by A1,RLVECT_1:5
              .=MULT.((yy+zz),xx) by Def000
              .=(yy+zz)*xx by Def020
              .=yy*xx + zz*xx by LM090R
              .= ADD.(yy*xx,zz*xx) by Def000
              .= ADD.(yy*xx,MULT.(zz,xx)) by Def020
              .= ADD.(MULT.(yy,xx),MULT.(zz,xx)) by Def020
              .= ADD.(y*x,MULT.(z,x)) by A1,VECTSP_1:def 10
              .= ADD.(y*x,z*x) by A1,VECTSP_1:def 10
              .= y*x + z*x by A1,RLVECT_1:5;
 thus a*(x*y) =EXMULT.[a,x*y] by A1, RLVECT_1:def 4
                   .= EXMULT.[a, MULT.(x,y)] by A1, VECTSP_1:def 10
                   .= EXMULT.[a, (xx*yy)] by Def020
                   .= EXMULT.(a, (xx*yy)) by BINOP_1:def 1
                   .= a*(xx*yy) by Def015
                   .= (a*xx)*(yy) by LM101
                  .= MULT.((a*xx),yy) by Def020
                  .= MULT.(EXMULT.(a,xx),yy) by Def015
                  .= MULT.(EXMULT.[a,x],y) by BINOP_1:def 1
                   .= MULT.(a*x,y) by A1, RLVECT_1:def 4
                   .=(a*x)*y by A1,VECTSP_1:def 10;
thus a*(x+y) =(the Mult of RBLOP).[a,(x+y)] by RLVECT_1:def 4
              .=(the Mult of RBLOP).[a,(the add of RBLOP).[x,y]]
             by RLVECT_1:def 3
              .=(the Mult of RBLOP).[a,(f+g)] by RLVECT_1:def 3,A1
              .=a*(f+g) by RLVECT_1:def 4,A1
              .=a*f+a*g by RLVECT_1:def 9
              .=ADD.[a*f,a*g] by RLVECT_1:def 3
              .=ADD.[(EXMULT).[a,f],a*g] by RLVECT_1:def 4
              .=ADD.[(EXMULT).[a,f],(EXMULT).[a,g]] by RLVECT_1:def 4
              .=(the add of RBLOP).[a*x,(the Mult of RBLOP).[a,y]]
          by A1,RLVECT_1:def 4
              .=(the add of RBLOP).[a*x,a*y] by RLVECT_1:def 4
              .=a*x+a*y by RLVECT_1:def 3;
thus (a+b)*x =(the Mult of RBLOP).[(a+b), x] by RLVECT_1:def 4
              .=(a+b)*f by RLVECT_1:def 4,A1
              .=a*f+b*f by RLVECT_1:def 9
              .=ADD.[a*f,b*f] by RLVECT_1:def 3
              .=ADD.[(EXMULT).[a,f],b*f] by RLVECT_1:def 4
              .=ADD.[(EXMULT).[a,f],(EXMULT).[b,f]] by RLVECT_1:def 4
              .=(the add of RBLOP).[a*x,(the Mult of RBLOP).[b,x]]
          by A1,RLVECT_1:def 4
              .=(the add of RBLOP).[a*x,b*x] by RLVECT_1:def 4
              .=a*x+b*x by RLVECT_1:def 3;
thus (a*b)*x =(the Mult of RBLOP).[(a*b), x] by RLVECT_1:def 4
              .=(a*b)*f by RLVECT_1:def 4,A1
              .=a*(b*f) by RLVECT_1:def 9
              .=(EXMULT).[a,(b*f)] by RLVECT_1:def 4
              .=(the Mult of RBLOP).[a,(the Mult of RBLOP).[b,f]]
               by A1,RLVECT_1:def 4
              .=(the Mult of RBLOP).[a,(b*x)] by RLVECT_1:def 4
              .=a*(b*x) by RLVECT_1:def 4;
 thus (a*b)*(x*y) =EXMULT.[(a*b),x*y] by A1, RLVECT_1:def 4
                   .= EXMULT.[(a*b), MULT.(x,y)] by A1, VECTSP_1:def 10
                   .= EXMULT.[(a*b), (xx*yy)] by Def020
                   .= EXMULT.((a*b), (xx*yy)) by BINOP_1:def 1
                   .= (a*b)*(xx*yy) by Def015
                   .= (a*xx)*(b*yy) by LM100
                   .= MULT.((a*xx),(b*yy)) by Def020
                   .= MULT.(EXMULT.(a,xx),(b*yy)) by Def015
                   .= MULT.(EXMULT.(a,xx),EXMULT.(b,yy)) by Def015
                   .= MULT.(EXMULT.[a,x],EXMULT.(b,y)) by BINOP_1:def 1
                   .= MULT.(EXMULT.[a,x],EXMULT.[b,y]) by BINOP_1:def 1
                   .= MULT.(a*x,EXMULT.[b,y]) by A1, RLVECT_1:def 4
                   .= MULT.(a*x,b*y) by A1, RLVECT_1:def 4
                   .=(a*x)*(b*y) by A1,VECTSP_1:def 10;
   end;

definition
  mode BLAlgebra is Abelian add-associative right_zeroed right_complementable
     associative Algebra-like (non empty AlgebraStr);
end;

theorem
 for X be RealNormSpace holds
    R_Algebra_of_BoundedLinearOperators(X) is BLAlgebra
 proof
   let X be RealNormSpace;
     for x,y,z being Element of 
       R_Algebra_of_BoundedLinearOperators(X)
        for a,b be Real holds
         x+y = y+x &
         (x+y)+z = x+(y+z) &
         x+(0.R_Algebra_of_BoundedLinearOperators(X)) = x &
         (ex t being Element of 
            R_Algebra_of_BoundedLinearOperators(X) st  x+t=
          0.R_Algebra_of_BoundedLinearOperators(X)) &
         (x*y)*z = x*(y*z) &
         x*(1_ R_Algebra_of_BoundedLinearOperators(X)) = x &
         (1_ R_Algebra_of_BoundedLinearOperators(X))*x = x &
         x*(y+z) = x*y + x*z &
         (y+z)*x = y*x + z*x &
        a*(x*y) = (a*x)*y &
         a*(x+y) = a*x + a*y &
         (a+b)*x = a*x + b*x &
         (a*b)*x = a*(b*x) by LM115;
   hence thesis by FUNCSDOM:def 20,
   RLVECT_1:def 5,def 6,def 7,def 8,VECTSP_1:def 16;
 end;

registration
  cluster l1_Space -> complete;
coherence
proof
  thus for vseq be sequence of l1_Space st
  vseq is Cauchy_sequence_by_Norm holds  vseq is convergent by RSSPACE3:11;
end;
end;

registration
  cluster l1_Space -> non trivial;
coherence
proof
   set a=1/2;
   reconsider x = a GeoSeq as Real_Sequence;
   abs(a) = 1/2 by ABSVALUE:def 1; then 
   abs(a) < 1; then
P0:x is summable by SERIES_1:28;
   defpred P[Nat] means 0 <= x.$1;
A1:P[0]
   proof
     x.0 = 1 by PREPOWER:4;
     hence thesis;
   end;
A2:for n being Nat st P[n] holds P[n+1]
   proof
     let n be Nat;
     assume A3:P[n];
     x.(n+1) = x.n * a by PREPOWER:4;
     hence thesis by A3,REAL_2:121;
   end;
   for n being Nat holds P[n] from NAT_1:sch 1(A1,A2); then
  x is absolutely_summable by P0,SERIES_1:41; then
P3:seq_id(x) is absolutely_summable by RSSPACE:3;
   x is Element of l1_Space by P3,RSSPACE3:8; then
   reconsider v=x as VECTOR of l1_Space;
   (seq_id v).0 = x.0 by RSSPACE:3 .= 1 by PREPOWER:4; then
   v <> Zeroseq by RSSPACE:def 6; then
v <> 0.l1_Space by RSSPACE3:8;
hence thesis by ANPROJ_1:def 8;
end;
end;

registration
  cluster non trivial RealBanachSpace;
existence
proof
  take l1_Space;
  thus thesis;
end;
end;

theorem LM120:
   for X be non trivial RealNormSpace
   ex w be VECTOR of X st ||. w .|| = 1
   proof
     let X be non trivial RealNormSpace;
     consider v be VECTOR of X such that
     AS2:   v  <> 0.X by ANPROJ_1:def 8;
     P0:   ||. v .||  <> 0 by AS2,NORMSP_1:def 2;
      0 <=  ||. v .|| by NORMSP_1:8; then
      P1:   0 <  ||. v .|| by P0;
      set a= ||. v .||;
      P3:   a >0 by P1;
       reconsider w=a"*v as VECTOR of X;
      P4: abs(a") =abs(1*a") .=abs( 1/a) by XCMPLX_0:def 9
                                 .=1/abs(a) by ABSVALUE:15
                                  .=1*abs(a)" by XCMPLX_0:def 9
                                 .=a"by P3,ABSVALUE:def 1;
     take w;
     thus ||.w.|| =abs(a")*||.v.|| by NORMSP_1:def 2
                   .=1 by XCMPLX_0:def 7,P3,P4;
   end;
   
 theorem LM130:
   for X be non trivial RealNormSpace holds
       BoundedLinearOperatorsNorm(X,X).(id the carrier of X) = 1
    proof
     let X be non trivial RealNormSpace;
     consider v be VECTOR of X such that
     BS2:  ||.v.|| = 1 by LM120;
     (id the carrier of X) is bounded LinearOperator of X,X by LM055;
      then reconsider
        ii=(id the carrier of X) as bounded LinearOperator of X,X;
       P1: ii.v =v by FUNCT_1:35;
       Q1:  now let r be Real such that
            AS1:  r in PreNorms(ii);
            AS2:  r in {||.ii.t.|| where t is VECTOR of X : ||.t.|| <= 1 }
    by LOPBAN_1:def 13,AS1;
            consider t be VECTOR of X such that
              PS1:   r=||.ii.t.|| & ||.t.|| <= 1 by AS2;
              ||.ii.t.|| = ||.t.|| by FUNCT_1:35;
              hence r <=1 by PS1;
          end;
       (for s be real number st s in PreNorms(ii) holds s <= 1)
                   implies sup PreNorms(ii) <= 1 by PSCOMP_1:10; then
       P2 : sup PreNorms(ii) <=1 by Q1;
       1 in {||.ii.t.|| where t is VECTOR of X : ||.t.|| <= 1 } by P1,BS2;
       then
       P3:  1 in PreNorms(ii) by LOPBAN_1:def 13;
       P4:PreNorms(ii) is non empty bounded_above by LOPBAN_1:32;
       P5:  1 <=sup PreNorms(ii) by P3,P4,SEQ_4:def 4;
       sup PreNorms(ii) =1 by AXIOMS:21,P2,P5;
       hence thesis by LOPBAN_1:36;
    end;

definition
  struct(AlgebraStr,NORMSTR) Normed_AlgebraStr 
               (# carrier -> set,
                 mult,add -> (BinOp of the carrier),
                 Mult -> (Function of [:REAL,the carrier:],the carrier),
                 unity,Zero -> Element of the carrier, 
                 norm -> Function of the carrier, REAL#);
end;

registration
 cluster non empty Normed_AlgebraStr;
 existence
  proof
    consider A being non empty set,
                       m being BinOp of A,
                       a being BinOp of A,
                       M being Function of [:REAL,A:],A,
                       U being Element of A,
                       Z being Element of A,
                       n being Function of A,REAL;
   take Normed_AlgebraStr(#A,m,a,M,U,Z,n#);
   thus the carrier of Normed_AlgebraStr(#A,m,a,M,U,Z,n#) is non empty;
  end;
end;

definition
 let X be RealNormSpace;
 func R_Normed_Algebra_of_BoundedLinearOperators(X) -> Normed_AlgebraStr equals
 :Def060:
   Normed_AlgebraStr
    (# BoundedLinearOperators(X,X),
        FuncMult(X),
        Add_(BoundedLinearOperators(X,X),
                     R_VectorSpace_of_LinearOperators(X,X)),
        Mult_(BoundedLinearOperators(X,X),
                 R_VectorSpace_of_LinearOperators(X,X)),
        FuncUnit(X),
        Zero_(BoundedLinearOperators(X,X),
               R_VectorSpace_of_LinearOperators(X,X)),
       BoundedLinearOperatorsNorm(X,X)        
          #);
  correctness;
end;

registration
 let X be RealNormSpace;
 cluster R_Normed_Algebra_of_BoundedLinearOperators(X) -> non empty strict;
 coherence
  proof
a1:   R_Normed_Algebra_of_BoundedLinearOperators(X) =
   Normed_AlgebraStr
    (# BoundedLinearOperators(X,X),
        FuncMult(X),
        Add_(BoundedLinearOperators(X,X),
                     R_VectorSpace_of_LinearOperators(X,X)),
        Mult_(BoundedLinearOperators(X,X),
                 R_VectorSpace_of_LinearOperators(X,X)),
        FuncUnit(X),
        Zero_(BoundedLinearOperators(X,X),
               R_VectorSpace_of_LinearOperators(X,X)),
       BoundedLinearOperatorsNorm(X,X) #) by Def060;
   hence the carrier of
   R_Normed_Algebra_of_BoundedLinearOperators(X) is non empty;
   thus thesis by a1;
  end;
end;

theorem LM135:
   for X be RealNormSpace
     for x,y,z being Element of
       R_Normed_Algebra_of_BoundedLinearOperators(X)
        for a,b be Real holds
         x+y = y+x &
         (x+y)+z = x+(y+z) &
         x+(0.R_Normed_Algebra_of_BoundedLinearOperators(X)) = x &
         (ex t being Element of
            R_Normed_Algebra_of_BoundedLinearOperators(X) st  x+t=
          0.R_Normed_Algebra_of_BoundedLinearOperators(X)) &
         (x*y)*z = x*(y*z) &
         x*(1_ R_Normed_Algebra_of_BoundedLinearOperators(X)) = x &
         (1_ R_Normed_Algebra_of_BoundedLinearOperators(X))*x = x &
         x*(y+z) = x*y + x*z &
         (y+z)*x = y*x + z*x &
         a*(x*y) = (a*x)*y &
         (a*b)*(x*y)=(a*x)*(b*y) &
         a*(x+y) = a*x + a*y &
         (a+b)*x = a*x + b*x &
         (a*b)*x = a*(b*x) &
         1*x =x
 proof
 let X be RealNormSpace;
 let x,y,z be Element of
           R_Normed_Algebra_of_BoundedLinearOperators(X);
 let a,b be Real;
 set RBLOP=R_Normed_Algebra_of_BoundedLinearOperators(X);
 set BLOP=BoundedLinearOperators(X,X);
 set ADD=Add_(BoundedLinearOperators(X,X),
                    R_VectorSpace_of_LinearOperators(X,X));
 set MULT= FuncMult(X);
 set ZE=Zero_(BoundedLinearOperators(X,X),
                   R_VectorSpace_of_LinearOperators(X,X));
 set EXMULT =Mult_(BoundedLinearOperators(X,X),
                 R_VectorSpace_of_LinearOperators(X,X));
 set UNIT=FuncUnit(X);

 A1: RBLOP= Normed_AlgebraStr
        (# BoundedLinearOperators(X,X),
            FuncMult(X),
            Add_(BoundedLinearOperators(X,X),
                         R_VectorSpace_of_LinearOperators(X,X)),
            Mult_(BoundedLinearOperators(X,X),
                     R_VectorSpace_of_LinearOperators(X,X)),
            FuncUnit(X),
            Zero_(BoundedLinearOperators(X,X),
                   R_VectorSpace_of_LinearOperators(X,X)),
           BoundedLinearOperatorsNorm(X,X) #) by Def060;
  set RRL=RLSStruct (# BoundedLinearOperators(X,X),
         Zero_(BoundedLinearOperators(X,X),
         R_VectorSpace_of_LinearOperators(X,X)),
          Add_(BoundedLinearOperators(X,X),
          R_VectorSpace_of_LinearOperators(X,X)),
         Mult_(BoundedLinearOperators(X,X),
         R_VectorSpace_of_LinearOperators(X,X)) #);
  set IT = RBLOP;
  reconsider f=x, g=y, h=z as Element of RRL by A1;
  thus x+y = (the add of RBLOP).(x,y) by RLVECT_1:5
               .=f+g by RLVECT_1:5,A1
               .= ADD.(g,f) by RLVECT_1:5
               .= y+x by A1,RLVECT_1:5;
   thus (x+y)+z = ADD.(x+y,h) by A1,RLVECT_1:5
              .= ADD.(ADD.(f,g),h) by A1,RLVECT_1:5
              .= ADD.((f+g),h) by RLVECT_1:5
              .=(f+g)+h by RLVECT_1:5
              .=f+(g+h) by RLVECT_1:def 6
              .= ADD.(f,(g+h)) by RLVECT_1:5
              .= ADD.(f,ADD.(g,h)) by RLVECT_1:5
              .= ADD.(f,y+z) by A1,RLVECT_1:5
              .= x+(y+z) by A1,RLVECT_1:5;
  thus x+(0.RBLOP) = ADD.(f,0.RBLOP) by A1,RLVECT_1:5
                     .= ADD.(f,ZE) by A1,RLVECT_1:def 2
                     .= ADD.(f,0.RRL) by RLVECT_1:def 2
                     .= f + 0.RRL by RLVECT_1:5
                     .= x by RLVECT_1:def 7;
  thus ex t being Element of RBLOP st x+t=(0.RBLOP)
   proof
    consider s be Element of RRL such that
    LL: f + s = 0.RRL by RLVECT_1:def 8;
    reconsider t=s as Element of RBLOP by A1;
    take t;
    thus x+t = ADD.(f,s) by A1,RLVECT_1:5
               .=f+s by RLVECT_1:5
               .=ZE by RLVECT_1:def 2,LL
               .=0.RBLOP by A1,RLVECT_1:def 2;
   end;
  reconsider xx=x,yy=y,zz=z as Element of BLOP by A1;
  thus (x*y)*z = MULT.(x*y,z) by A1, VECTSP_1:def 10
                   .= MULT.(MULT.(x,y),z) by A1, VECTSP_1:def 10
                   .= MULT.(xx*yy,zz) by Def020
                   .=(xx*yy)*zz by Def020
                   .=xx*(yy*zz) by LM071
                   .= MULT.(xx,yy*zz) by Def020
                  .= MULT.(xx,MULT.(yy,zz)) by Def020
                  .= MULT.(x,(y*z)) by A1, VECTSP_1:def 10
                  .=x*(y*z) by A1, VECTSP_1:def 10;
  thus x*(1_ RBLOP) = MULT.(x,1_ IT) by A1,VECTSP_1:def 10
                     .= MULT.(x,UNIT) by A1,VECTSP_1:def 9
                     .=xx*UNIT by Def020
                     .= x by LM081;
  thus (1_ RBLOP)*x = MULT.(1_ IT,x) by A1,VECTSP_1:def 10
                     .= MULT.(UNIT,x) by A1,VECTSP_1:def 9
                     .=UNIT*xx by Def020
                     .= x by LM081;
  thus x*(y+z) = MULT.(x,y+z) by A1,VECTSP_1:def 10
              .= MULT.(x,ADD.(y,z)) by A1,RLVECT_1:5
              .=MULT.(xx,(yy+zz)) by Def000
              .=xx*(yy+zz) by Def020
              .=xx*yy + xx*zz by LM090L
              .= ADD.(xx*yy,xx*zz) by Def000
              .= ADD.(xx*yy,MULT.(xx,zz)) by Def020
              .= ADD.(MULT.(xx,yy),MULT.(xx,zz)) by Def020
              .= ADD.(x*y,MULT.(x,z)) by A1,VECTSP_1:def 10
              .= ADD.(x*y,x*z) by A1,VECTSP_1:def 10
              .= x*y + x*z by A1,RLVECT_1:5;
  thus (y+z)*x = MULT.(y+z,x) by A1,VECTSP_1:def 10
              .= MULT.(ADD.(y,z),x) by A1,RLVECT_1:5
              .=MULT.((yy+zz),xx) by Def000
              .=(yy+zz)*xx by Def020
              .=yy*xx + zz*xx by LM090R
              .= ADD.(yy*xx,zz*xx) by Def000
              .= ADD.(yy*xx,MULT.(zz,xx)) by Def020
              .= ADD.(MULT.(yy,xx),MULT.(zz,xx)) by Def020
              .= ADD.(y*x,MULT.(z,x)) by A1,VECTSP_1:def 10
              .= ADD.(y*x,z*x) by A1,VECTSP_1:def 10
              .= y*x + z*x by A1,RLVECT_1:5;
 thus a*(x*y) =EXMULT.[a,x*y] by A1, RLVECT_1:def 4
                   .= EXMULT.[a, MULT.(x,y)] by A1, VECTSP_1:def 10
                   .= EXMULT.[a, (xx*yy)] by Def020
                   .= EXMULT.(a, (xx*yy)) by BINOP_1:def 1
                   .= a*(xx*yy) by Def015
                   .= (a*xx)*(yy) by LM101
                  .= MULT.((a*xx),yy) by Def020
                  .= MULT.(EXMULT.(a,xx),yy) by Def015
                  .= MULT.(EXMULT.[a,x],y) by BINOP_1:def 1
                   .= MULT.(a*x,y) by A1, RLVECT_1:def 4
                   .=(a*x)*y by A1,VECTSP_1:def 10;
thus (a*b)*(x*y) =EXMULT.[(a*b),x*y] by A1, RLVECT_1:def 4
                   .= EXMULT.[(a*b), MULT.(x,y)] by A1, VECTSP_1:def 10
                   .= EXMULT.[(a*b), (xx*yy)] by Def020
                   .= EXMULT.((a*b), (xx*yy)) by BINOP_1:def 1
                   .= (a*b)*(xx*yy) by Def015
                   .= (a*xx)*(b*yy) by LM100
                   .= MULT.((a*xx),(b*yy)) by Def020
                   .= MULT.(EXMULT.(a,xx),(b*yy)) by Def015
                   .= MULT.(EXMULT.(a,xx),EXMULT.(b,yy)) by Def015
                   .= MULT.(EXMULT.[a,x],EXMULT.(b,y)) by BINOP_1:def 1
                   .= MULT.(EXMULT.[a,x],EXMULT.[b,y]) by BINOP_1:def 1
                   .= MULT.(a*x,EXMULT.[b,y]) by A1, RLVECT_1:def 4
                   .= MULT.(a*x,b*y) by A1, RLVECT_1:def 4
                   .=(a*x)*(b*y) by A1,VECTSP_1:def 10;
thus a*(x+y) =(the Mult of RBLOP).[a,(x+y)] by RLVECT_1:def 4
              .=(the Mult of RBLOP).[a,(the add of RBLOP).[x,y]] 
             by RLVECT_1:def 3
              .=(the Mult of RBLOP).[a,(f+g)] by RLVECT_1:def 3,A1
              .=a*(f+g) by RLVECT_1:def 4,A1
              .=a*f+a*g by RLVECT_1:def 9
              .=ADD.[a*f,a*g] by RLVECT_1:def 3
              .=ADD.[(EXMULT).[a,f],a*g] by RLVECT_1:def 4
              .=ADD.[(EXMULT).[a,f],(EXMULT).[a,g]] by RLVECT_1:def 4
              .=(the add of RBLOP).[a*x,(the Mult of RBLOP).[a,y]]
          by RLVECT_1:def 4,A1
              .=(the add of RBLOP).[a*x,a*y] by RLVECT_1:def 4
              .=a*x+a*y by RLVECT_1:def 3;
thus (a+b)*x =(the Mult of RBLOP).[(a+b), x] by RLVECT_1:def 4
              .=(a+b)*f by RLVECT_1:def 4,A1
              .=a*f+b*f by RLVECT_1:def 9
              .=ADD.[a*f,b*f] by RLVECT_1:def 3
              .=ADD.[(EXMULT).[a,f],b*f] by RLVECT_1:def 4
              .=ADD.[(EXMULT).[a,f],(EXMULT).[b,f]] by RLVECT_1:def 4
              .=(the add of RBLOP).[a*x,(the Mult of RBLOP).[b,x]]
          by RLVECT_1:def 4,A1
              .=(the add of RBLOP).[a*x,b*x] by RLVECT_1:def 4
              .=a*x+b*x by RLVECT_1:def 3;
thus (a*b)*x =(the Mult of RBLOP).[(a*b), x] by RLVECT_1:def 4
              .=(a*b)*f by RLVECT_1:def 4,A1
              .=a*(b*f) by RLVECT_1:def 9
              .=(EXMULT).[a,(b*f)] by RLVECT_1:def 4
              .=(the Mult of RBLOP).[a,(the Mult of RBLOP).[b,f]]
               by A1,RLVECT_1:def 4
              .=(the Mult of RBLOP).[a,(b*x)] by RLVECT_1:def 4
              .=a*(b*x) by RLVECT_1:def 4;
thus 1*x =(the Mult of RBLOP).[1, x] by RLVECT_1:def 4
              .=1*f by RLVECT_1:def 4,A1
              .=x by RLVECT_1:def 9;
   end;

 theorem LM136:
   for X be RealNormSpace
     holds R_Normed_Algebra_of_BoundedLinearOperators(X)
     is RealNormSpace-like Abelian add-associative
  right_zeroed right_complementable
     associative Algebra-like RealLinearSpace-like
   proof
    let X be RealNormSpace;
      A0:  R_Normed_Algebra_of_BoundedLinearOperators(X) =
      Normed_AlgebraStr
      (# BoundedLinearOperators(X,X),
        FuncMult(X),
        Add_(BoundedLinearOperators(X,X),
                     R_VectorSpace_of_LinearOperators(X,X)),
        Mult_(BoundedLinearOperators(X,X),
                 R_VectorSpace_of_LinearOperators(X,X)),
        FuncUnit(X),
        Zero_(BoundedLinearOperators(X,X),
               R_VectorSpace_of_LinearOperators(X,X)),
       BoundedLinearOperatorsNorm(X,X) #) by Def060;
  A1: for x,y,z being Element of
       R_Normed_Algebra_of_BoundedLinearOperators(X)
        for a,b be Real holds
         x+y = y+x &
         (x+y)+z = x+(y+z) &
         x+(0.R_Normed_Algebra_of_BoundedLinearOperators(X)) = x &
         (ex t being Element of
            R_Normed_Algebra_of_BoundedLinearOperators(X) st  x+t=
          0.R_Normed_Algebra_of_BoundedLinearOperators(X)) &
         (x*y)*z = x*(y*z) &
         x*(1_ R_Normed_Algebra_of_BoundedLinearOperators(X)) = x &
         (1_ R_Normed_Algebra_of_BoundedLinearOperators(X))*x = x &
         x*(y+z) = x*y + x*z &
         (y+z)*x = y*x + z*x &
        a*(x*y) = (a*x)*y &
        (a*b)*(x*y)=(a*x)*(b*y) &
         a*(x+y) = a*x + a*y &
         (a+b)*x = a*x + b*x &
         (a*b)*x = a*(b*x) & 
         1*x=x by LM135;
A2:
R_NormSpace_of_BoundedLinearOperators(X,X) 
 = NORMSTR (# BoundedLinearOperators(X,X),
        Zero_(BoundedLinearOperators(X,X),
        R_VectorSpace_of_LinearOperators(X,X)),
         Add_(BoundedLinearOperators(X,X),
         R_VectorSpace_of_LinearOperators(X,X)),
          Mult_(BoundedLinearOperators(X,X),
          R_VectorSpace_of_LinearOperators(X,X)),
          BoundedLinearOperatorsNorm(X,X) #) 
by LOPBAN_1:def 15;
A3:  R_Normed_Algebra_of_BoundedLinearOperators(X)
   is BLAlgebra by A1, FUNCSDOM:def 20,
  RLVECT_1:def 5,def 6,def 7,def 8,VECTSP_1:def 16;
 set RBLOP=R_Normed_Algebra_of_BoundedLinearOperators(X);
 set BLOP=BoundedLinearOperators(X,X);
 set BS=R_NormSpace_of_BoundedLinearOperators(X,X);
 set ADD=Add_(BoundedLinearOperators(X,X),
                    R_VectorSpace_of_LinearOperators(X,X));
 set MULT= FuncMult(X);
 set ZE=Zero_(BoundedLinearOperators(X,X),
                   R_VectorSpace_of_LinearOperators(X,X));
 set EXMULT =Mult_(BoundedLinearOperators(X,X),
                 R_VectorSpace_of_LinearOperators(X,X));
 set UNIT=FuncUnit(X);
 set NRM=BoundedLinearOperatorsNorm(X,X);
  (for a be Real for v,w being VECTOR of RBLOP
  holds a * (v + w) = a * v + a * w) &
  (for a,b be Real for v being VECTOR of RBLOP
  holds (a + b) * v = a * v + b * v) &
  (for a,b be Real for v being VECTOR of RBLOP
  holds (a * b) * v = a * (b * v)) &
  (for v being VECTOR of RBLOP holds 1 * v = v) by A1; then
A7:  R_Normed_Algebra_of_BoundedLinearOperators(X)
   is RealLinearSpace-like by RLVECT_1:def 9;
now
  let x,y be Point of RBLOP;
  let a be Real;
   reconsider x1 =x, y1 =y as Point of BS by A0,A2;
  L1:  ||.x + y.|| = ( the norm of RBLOP  ).(x+y) by NORMSP_1:def 1
    .= NRM.(ADD.(x,y)) by A0,RLVECT_1:5
    .= NRM.(x1+y1) by A2,RLVECT_1:5
    .= ||.x1 + y1.|| by A2,NORMSP_1:def 1;
  L2:  ||.x1 + y1.|| <= ||.x1.||  + ||. y1.|| by NORMSP_1:def 2;
  L3:  ||.x1.|| + ||. y1.||
     = NRM.(x1) + ||. y1.|| by A2,NORMSP_1:def 1
    .= NRM.(x1) + NRM.(y1) by A2,NORMSP_1:def 1
    .= ||.x.|| +( the norm of RBLOP  ).y by NORMSP_1:def 1,A0
    .= ||.x.|| + ||.y.|| by NORMSP_1:def 1;
   thus ||.x + y.|| <= ||.x.||  + ||. y.|| by L1,L2,L3;
  L4:    ||.x1.|| = NRM.(x1) by A2,NORMSP_1:def 1
      .= ||.x.|| by NORMSP_1:def 1,A0;
  L5:  ||.x.|| = 0 iff ||.x1.|| = 0 by L4;
  L6:   ||.x1.||=0 iff x1=0.BS by NORMSP_1:def 2;
  L7:   0.BS=ZE by A2,RLVECT_1:def 2
               .=0.RBLOP by A0,RLVECT_1:def 2;
  L8:  x1=0.BS  iff x= 0.RBLOP by L7;
  thus ||.x.|| = 0 iff  x= 0.RBLOP by L5,L6,L8;
  thus ||.a*x.|| =  ( the norm of RBLOP  ).(a*x) by NORMSP_1:def 1
                   .= NRM.(EXMULT.[a,x]) by A0,RLVECT_1:def 4
                  .= NRM.(a*x1) by A2,RLVECT_1:def 4
                  .= ||.a*x1.|| by A2,NORMSP_1:def 1
                    .=abs(a)* ||.x.|| by L4,NORMSP_1:def 2;
  end;
hence thesis by A3,A7,NORMSP_1:def 2;
 end;

registration
  cluster RealNormSpace-like Abelian add-associative
     right_zeroed right_complementable
     associative Algebra-like RealLinearSpace-like
     strict (non empty Normed_AlgebraStr);
   existence
 proof
   consider X be RealNormSpace;
   take R_Normed_Algebra_of_BoundedLinearOperators(X);
   thus thesis by LM136;
 end;
end;

definition
  mode Normed_Algebra is RealNormSpace-like Abelian add-associative
      right_zeroed right_complementable
      associative Algebra-like RealLinearSpace-like
      (non empty Normed_AlgebraStr);
end;

registration
  let X be RealNormSpace;
  cluster R_Normed_Algebra_of_BoundedLinearOperators(X)
  -> RealNormSpace-like Abelian add-associative
     right_zeroed right_complementable
     associative Algebra-like RealLinearSpace-like;
    correctness by LM136;
end;

definition let X be non empty Normed_AlgebraStr;
  attr X is Banach_Algebra-like_1 means
   for x,y being Element of X holds ||. x*y .|| <= ||.x.|| * ||.y.||;
  attr X is Banach_Algebra-like_2 means
   ||. 1_ X .|| = 1;
  attr X is Banach_Algebra-like_3 means
   for a being Real for x,y being Element of X
   holds a*(x*y)=x*(a*y);
end;

definition let X be Normed_Algebra;
  attr X is Banach_Algebra-like means  :Def090:
   X is Banach_Algebra-like_1 Banach_Algebra-like_2 Banach_Algebra-like_3
        left_unital left-distributive complete;
end;

registration
  cluster Banach_Algebra-like ->
     Banach_Algebra-like_1 Banach_Algebra-like_2 Banach_Algebra-like_3
     left-distributive left_unital complete Normed_Algebra;
coherence by Def090;
  cluster Banach_Algebra-like_1 Banach_Algebra-like_2 Banach_Algebra-like_3
    left-distributive left_unital complete ->
    Banach_Algebra-like Normed_Algebra;
coherence by Def090;
end;

registration
 let X be non trivial RealBanachSpace;
 cluster R_Normed_Algebra_of_BoundedLinearOperators(X) -> Banach_Algebra-like;
 coherence
 proof
      A0:  R_Normed_Algebra_of_BoundedLinearOperators(X) =
      Normed_AlgebraStr
      (# BoundedLinearOperators(X,X),
        FuncMult(X),
        Add_(BoundedLinearOperators(X,X),
                     R_VectorSpace_of_LinearOperators(X,X)),
        Mult_(BoundedLinearOperators(X,X),
                 R_VectorSpace_of_LinearOperators(X,X)),
        FuncUnit(X),
        Zero_(BoundedLinearOperators(X,X),
               R_VectorSpace_of_LinearOperators(X,X)),
       BoundedLinearOperatorsNorm(X,X) #) by Def060;

A1:
 R_NormSpace_of_BoundedLinearOperators(X,X)
 = NORMSTR (# BoundedLinearOperators(X,X),
        Zero_(BoundedLinearOperators(X,X),
        R_VectorSpace_of_LinearOperators(X,X)),
         Add_(BoundedLinearOperators(X,X),
         R_VectorSpace_of_LinearOperators(X,X)),
          Mult_(BoundedLinearOperators(X,X),
          R_VectorSpace_of_LinearOperators(X,X)),
          BoundedLinearOperatorsNorm(X,X) #) by LOPBAN_1:def 15;
 set RBLOP=R_Normed_Algebra_of_BoundedLinearOperators(X);
 set BLOP=BoundedLinearOperators(X,X);
 set BS=R_NormSpace_of_BoundedLinearOperators(X,X);
 set ADD=Add_(BoundedLinearOperators(X,X),
                    R_VectorSpace_of_LinearOperators(X,X));
 set MULT= FuncMult(X);
 set ZE=Zero_(BoundedLinearOperators(X,X),
                   R_VectorSpace_of_LinearOperators(X,X));
 set EXMULT =Mult_(BoundedLinearOperators(X,X),
                 R_VectorSpace_of_LinearOperators(X,X));
 set UNIT=FuncUnit(X);
 set NRM=BoundedLinearOperatorsNorm(X,X);
 thus RBLOP is Banach_Algebra-like_1
 proof
  let x,y be Point of RBLOP;
  reconsider x1=x,y1=y as Element of BLOP by A0;
  L1:  ||.x * y.|| 
    = ( the norm of RBLOP ).(x*y) by NORMSP_1:def 1
    .= NRM.(MULT.(x,y)) by A0,VECTSP_1:def 10
    .= NRM.(x1*y1) by Def020
    .= NRM.(modetrans(x1,X,X)*modetrans(y1,X,X)) by Def010;
  L2: NRM.(modetrans(x1,X,X)*modetrans(y1,X,X))
       <=NRM.(modetrans(x1,X,X))
         *NRM.(modetrans(y1,X,X)) by LM050;
 L3:NRM.(modetrans(x1,X,X)) *NRM.(modetrans(y1,X,X))
      =NRM.(x1)*NRM.(modetrans(y1,X,X)) by LOPBAN_1:def 12
      .=NRM.(x1) *NRM.(y1) by LOPBAN_1:def 12
      .= ||.x .|| * NRM.(y) by A0,NORMSP_1:def 1
      .= ||.x .|| * ||.y .|| by A0,NORMSP_1:def 1;
  thus ||.x * y.|| <= ||.x .|| * ||.y .|| by L1,L2,L3;
  end;
 thus RBLOP is Banach_Algebra-like_2
proof
  thus ||. 1_ RBLOP .|| = ||. the unity of RBLOP .|| by VECTSP_1:def 9
      .= NRM.(UNIT) by A0,NORMSP_1:def 1
      .= NRM.(id (the carrier of X)) by Def030
      .= 1 by LM130;
end;
 thus RBLOP is Banach_Algebra-like_3
proof
  let a be Real;
  let x,y be Element of RBLOP;
  thus a*(x*y)=(1*a)*(x*y)
                   .=(1*x)*(a*y) by LM135
                   .=x*(a*y) by LM135;
end;
 thus RBLOP is left_unital
 proof let x be Element of RBLOP; 
 reconsider xx=x as Element of BLOP by A0;
   thus (1_ RBLOP)*x  = MULT.(1_ RBLOP,x) by A0,VECTSP_1:def 10
                      .= MULT.(UNIT,x) by A0,VECTSP_1:def 9
                      .=UNIT*xx by Def020
                     .= x by LM081;
end;
 thus RBLOP is left-distributive
 proof
  let x,y,z be Element of RBLOP; 
 reconsider xx=x,yy=y,zz=z as Element of BLOP by A0;
  thus (y+z)*x = MULT.(y+z,x) by A0,VECTSP_1:def 10
              .= MULT.(ADD.(y,z),x) by A0,RLVECT_1:5
              .= MULT.((yy+zz),xx) by Def000
              .= (yy+zz)*xx by Def020
              .= yy*xx + zz*xx by LM090R
              .= ADD.(yy*xx,zz*xx) by Def000
              .= ADD.(yy*xx,MULT.(zz,xx)) by Def020
              .= ADD.(MULT.(yy,xx),MULT.(zz,xx)) by Def020
              .= ADD.(y*x,MULT.(z,x)) by A0,VECTSP_1:def 10
              .= ADD.(y*x,z*x) by A0,VECTSP_1:def 10
              .= y*x + z*x by A0,RLVECT_1:5;
 end;
        now let seq be sequence of RBLOP such that
           CS1: seq is Cauchy_sequence_by_Norm;
           seq is Function of NAT, BLOP by A0; then
           seq is Function of NAT, the carrier of BS by A1; then
           seq is sequence of BS by NORMSP_1:def 3; then
           reconsider seq1=seq as sequence of BS;
         now let r be Real such that
           D2: r > 0;
           consider k be Nat such that
           D3: for n, m be Nat st
                 n >= k & m >= k holds ||.(seq.n) - (seq.m).|| < r
             by RSSPACE3:10,D2,CS1;
           now let n, m be Nat such that
             D4:   n >= k & m >= k;
             D5:  ||.(seq.n) - (seq.m).|| < r by D3,D4;
               ||.(seq1.n) - (seq1.m).|| 
               = NRM.((seq1.n) - (seq1.m)) by A1,NORMSP_1:def 1
               .= NRM.((seq1.n) +(- (seq1.m))) by RLVECT_1:def 11
               .= NRM.((seq1.n) +((-1)*(seq1.m))) by RLVECT_1:29
               .= NRM. (ADD.(seq1.n,(-1)*(seq1.m))) by RLVECT_1:5,A1
               .= NRM. (ADD.(seq1.n,EXMULT.[(-1),(seq1.m)] )) 
                 by A1,RLVECT_1:def 4
               .= NRM. (ADD.(seq.n,(-1)*(seq.m))) 
                 by A0,RLVECT_1:def 4
              .= NRM.((seq.n) +((-1)*(seq.m))) by A0,RLVECT_1:5
               .= NRM.((seq.n) +(- (seq.m))) by RLVECT_1:29
               .= NRM.((seq.n) - (seq.m)) by RLVECT_1:def 11
               .= ||.(seq.n) - (seq.m).|| by A0,NORMSP_1:def 1;
             hence ||.(seq1.n) - (seq1.m).|| < r by D5;
           end;
           hence ex k be Nat st
                 for n, m be Nat st
                 n >= k & m >= k holds ||.(seq1.n) - (seq1.m).|| < r;
       end;
       then
       D6: seq1 is Cauchy_sequence_by_Norm by RSSPACE3:10;
       D7: seq1 is convergent by D6,LOPBAN_1:def 16;
         consider g1 be Point of BS such that
            D8: for r be Real st 0 < r
                ex m be Nat st for n be Nat st m <= n holds
                    ||.(seq1.n) - g1.|| < r by D7,NORMSP_1:def 9;
          reconsider g=g1 as Point of RBLOP by A0,A1;
              now let r be Real such that
                 D9: 0 < r;
                consider m be Nat such that
                   D10: for n be Nat st m <= n holds
                           ||.(seq1.n) - g1.|| < r by D9,D8;
                   now
                    let n be Nat such that
                       D11:m <= n;
                       D12:  ||.(seq1.n) - g1.|| < r by D11,D10;
                      ||.(seq1.n) - (g1).|| 
                      = NRM.((seq1.n) - (g1)) by A1,NORMSP_1:def 1
                     .= NRM.((seq1.n) +(- (g1))) by RLVECT_1:def 11
                     .= NRM.((seq1.n) +((-1)*(g1))) by RLVECT_1:29
                     .= NRM. (ADD.(seq1.n,(-1)*(g1))) by RLVECT_1:5,A1
                    .= NRM. (ADD.(seq1.n,EXMULT.[(-1),(g1)] ))
                 by A1,RLVECT_1:def 4
                    .= NRM. (ADD.(seq.n,(-1)*(g)))
                 by A0,RLVECT_1:def 4
                    .= NRM.((seq.n) +((-1)*(g))) by A0,RLVECT_1:5
                    .= NRM.((seq.n) +(- (g))) by RLVECT_1:29
                    .= NRM.((seq.n) - (g)) by RLVECT_1:def 11
                    .= ||.(seq.n) - (g).|| by A0,NORMSP_1:def 1;
                  hence ||.(seq.n) - (g).|| < r by D12;
                end;
           hence ex m be Nat  st for n be Nat st m <= n holds
                    ||.(seq.n) - g.|| < r;
          end;
       hence seq is convergent by NORMSP_1:def 9;
      end;
      hence thesis by LOPBAN_1:def 16;
end;
end;

registration
  cluster Banach_Algebra-like Normed_Algebra;
  existence
 proof
   consider X be non trivial RealBanachSpace;
   take R_Normed_Algebra_of_BoundedLinearOperators(X);
   thus thesis;
 end;
end;

definition
  mode Banach_Algebra is Banach_Algebra-like Normed_Algebra;
end;
