:: Subalgebras of a Many Sorted Algebra. Lattice of Subalgebras
::  by Ewa Burakowska
::
:: Received April 25, 1994
:: Copyright (c) 1994 Association of Mizar Users

environ

 vocabularies FUNCT_1, RELAT_1, PBOOLE, ZF_REFLE, BOOLE, CARD_3, AMI_1,
      MSUALG_1, UNIALG_2, FINSEQ_1, TDGROUP, QC_LANG1, FINSEQ_4, PRALG_1,
      FUNCT_2, PROB_1, TARSKI, SETFAM_1, LATTICES, BINOP_1, MSUALG_2;
 notations TARSKI, XBOOLE_0, ZFMISC_1, SUBSET_1, STRUCT_0, RELAT_1, FUNCT_1,
      FUNCT_2, FINSEQ_1, SETFAM_1, FINSEQ_2, LATTICES, BINOP_1, CARD_3, PBOOLE,
      MSUALG_1;
 constructors SETFAM_1, BINOP_1, CARD_3, LATTICES, MSUALG_1;
 registrations XBOOLE_0, SUBSET_1, RELAT_1, FUNCT_1, PBOOLE, STRUCT_0,
      LATTICES, MSUALG_1, FINSEQ_1;
 requirements BOOLE, SUBSET;
 definitions TARSKI, PBOOLE, LATTICES, XBOOLE_0;
 theorems TARSKI, FUNCT_1, FINSEQ_1, PBOOLE, CARD_3, MSUALG_1, FUNCT_2,
      ZFMISC_1, SETFAM_1, BINOP_1, LATTICES, RELAT_1, STRUCT_0, RELSET_1,
      XBOOLE_0, XBOOLE_1, PARTFUN1, FUNCOP_1;
 schemes CLASSES1, BINOP_1, FUNCT_1, XBOOLE_0;

begin

::
:: Auxiliary facts about Many Sorted Sets.
::

reserve x,y for set;

registration
  let I be set, X be ManySortedSet of I, Y be non-empty ManySortedSet of I;
  cluster X \/ Y -> non-empty;
  coherence
  proof
    let i be set;
A1: Y c= X \/ Y by PBOOLE:16;
    assume
A2: i in I;
    then (X \/ Y).i = X.i \/ Y.i by PBOOLE:def 7;
    then
A3: Y.i c= X.i \/ Y.i by A1,A2,PBOOLE:def 5;
    thus (X \/ Y).i is non empty by A2,A3,PBOOLE:def 7;
  end;
  cluster Y \/ X -> non-empty;
  coherence;
end;

canceled;

theorem Th2:
  for I be non empty set, X, Y be ManySortedSet of I, i be Element of I*
  holds product ((X /\ Y)*i) = product(X * i) /\ product(Y * i)
proof
  let I be non empty set, X, Y be ManySortedSet of I, i be Element of I*;
A1: rng i c= I by FINSEQ_1:def 4;
  dom X = I & dom Y =I & dom(X /\ Y) = I by PBOOLE:def 3;
  then
A2: dom (X *i) = dom i & dom (Y *i)= dom i & dom((X /\ Y)*i) = dom i
  by A1,RELAT_1:46;
  thus product ((X /\ Y)*i) c= product(X * i) /\ product(Y * i)
  proof
    let x;
    assume x in product((X /\ Y) * i);
    then consider g be Function such that
A3: x = g & dom g = dom ((X /\Y)*i) &
    for y st y in dom ((X /\ Y)*i) holds g.y in
    ((X /\ Y)*i).y by CARD_3:def 5;
    for y st y in dom( X*i) holds g.y in (X *i).y
    proof
      let y;
      assume
A4:   y in dom(X *i);
      then g.y in ((X /\ Y)*i).y by A2,A3;
      then
A5:   g.y in (X /\ Y).(i.y) by A2,A4,FUNCT_1:22;
      i.y in rng i by A2,A4,FUNCT_1:def 5;
      then g.y in X.(i.y) /\ Y.(i.y) by A1,A5,PBOOLE:def 8;
      then g.y in X.(i.y) by XBOOLE_0:def 3;
      hence thesis by A4,FUNCT_1:22;
    end;
    then
A6: x in product(X *i) by A2,A3,CARD_3:def 5;
    for y st y in dom( Y*i) holds g.y in (Y *i).y
    proof
      let y;
      assume
A7:   y in dom(Y *i);
      then g.y in ((X /\ Y)*i).y by A2,A3;
      then
A8:   g.y in (X /\ Y).(i.y) by A2,A7,FUNCT_1:22;
      i.y in rng i by A2,A7,FUNCT_1:def 5;
      then g.y in X.(i.y) /\ Y.(i.y) by A1,A8,PBOOLE:def 8;
      then g.y in Y.(i.y) by XBOOLE_0:def 3;
      hence thesis by A7,FUNCT_1:22;
    end;
    then x in product(Y *i) by A2,A3,CARD_3:def 5;
    hence thesis by A6,XBOOLE_0:def 3;
  end;
  let x;
  assume x in (product(X * i) /\ product(Y * i));
  then
A9: x in product(X * i) & x in product(Y * i) by XBOOLE_0:def 3;
  then consider g be Function such that
A10: x = g & dom g = dom (X *i) &
  for y st y in dom (X *i) holds g.y in (X *i).y by CARD_3:def 5;
  consider h be Function such that
A11: x = h & dom h = dom (Y *i) &
  for y st y in dom (Y *i) holds h.y in (Y *i).y by A9,CARD_3:def 5;
  for y st y in dom((X /\ Y)*i) holds g.y in ((X /\ Y) *i).y
  proof
    let y;
    assume
A12: y in dom((X /\ Y)*i);
    then g.y in (X *i).y & g.y in (Y *i).y by A2,A10,A11;
    then g.y in X.(i.y) & g.y in Y.(i.y) by A2,A12,FUNCT_1:22;
    then
A13: g.y in (X.(i.y) /\ Y.(i.y)) by XBOOLE_0:def 3;
    i.y in rng i by A2,A12,FUNCT_1:def 5;
    then g.y in (X /\ Y).(i.y) by A1,A13,PBOOLE:def 8;
    hence thesis by A12,FUNCT_1:22;
  end;
  hence thesis by A2,A10,CARD_3:def 5;
end;

begin

::
::  Constants of a Many Sorted Algebra.
::

reserve S for non void non empty ManySortedSign,
  o for OperSymbol of S,
  U0,U1,U2 for MSAlgebra over S;

definition
  let S be non empty ManySortedSign, U0 be MSAlgebra over S;
  mode MSSubset of U0 is ManySortedSubset of the Sorts of U0;
end;

definition
  let S be non empty ManySortedSign;
  let IT be SortSymbol of S;
  canceled;
  attr IT is with_const_op means
  :Def2:
  ex o be OperSymbol of S st
  (the Arity of S).o = {} & (the ResultSort of S).o = IT;
end;

definition
  let IT be non empty ManySortedSign;
  attr IT is all-with_const_op means
  :Def3:
  for s be SortSymbol of IT holds s is with_const_op;
end;

registration
  let A be non empty set, B be set,
  a be Function of B,A*, r be Function of B,A;
  cluster ManySortedSign(#A,B,a,r#) -> non empty;
  coherence;
end;

registration
  cluster non void all-with_const_op strict (non empty ManySortedSign);
  existence
  proof
    consider x be set;
    set C = {x};
    consider a be Function such that
A1: dom a = C & rng a = {<*>C} by FUNCT_1:15;
    rng a c= C*
    proof
      let y be set;
      assume y in rng a;
      then y = <*>C by A1,TARSKI:def 1;
      hence thesis by FINSEQ_1:def 11;
    end;
    then reconsider a as Function of C,C* by A1,FUNCT_2:def 1,RELSET_1:11;
    consider r be Function such that
A2: dom r = C & rng r = {x} by FUNCT_1:15;
    reconsider r as Function of C,C by A2,FUNCT_2:def 1,RELSET_1:11;
    set M = ManySortedSign (#C,C,a,r#);
    take M;
    thus M is non void by MSUALG_1:def 5;
    for s be SortSymbol of M holds s is with_const_op
    proof
      let s be SortSymbol of M;
A3:   s=x by TARSKI:def 1;
      reconsider o = x as OperSymbol of M by TARSKI:def 1;
      take o;
      a.o in rng a by A1,FUNCT_1:def 5;
      hence (the Arity of M).o = {} by A1,TARSKI:def 1;
      r.o in rng r by A2,FUNCT_1:def 5;
      hence (the ResultSort of M).o = s by A2,A3,TARSKI:def 1;
    end;
    hence M is all-with_const_op by Def3;
    thus thesis;
  end;
end;

definition
  let S be non void non empty ManySortedSign, U0 be MSAlgebra over S,
  s be SortSymbol of S;
  func Constants(U0,s) -> Subset of (the Sorts of U0).s means
  :Def4:
  ex A being non empty set st A =(the Sorts of U0).s &
  it = { a where a is Element of A :
  ex o be OperSymbol of S st (the Arity of S).o = {} &
  (the ResultSort of S).o = s & a in rng Den(o,U0)}
  if (the Sorts of U0).s <> {} otherwise it = {};
  existence
  proof
    hereby
      assume (the Sorts of U0).s <> {};
      then reconsider A = (the Sorts of U0).s as non empty set;
      set E = {a where a is Element of A :
      ex o be OperSymbol of S st (the Arity of S).o={} &
      (the ResultSort of S).o = s & a in rng Den(o,U0)};
      E c= A
      proof
        let x;
        assume x in E;
        then consider w be Element of (the Sorts of U0).s such that
A1:     w=x & ex o be OperSymbol of S st (the Arity of S).o={} &
        (the ResultSort of S).o = s & w in rng Den(o,U0);
        thus thesis by A1;
      end;
      then reconsider E as Subset of (the Sorts of U0).s;
      take E,A;
      thus A =(the Sorts of U0).s & E = { a where a is Element of A :
      ex o be OperSymbol of S st (the Arity of S).o = {} &
      (the ResultSort of S).o = s & a in rng Den(o,U0)};
    end;
    assume (the Sorts of U0).s = {};
    take {}((the Sorts of U0).s);
    thus thesis;
  end;
  correctness;
end;

definition
  let S be non void non empty ManySortedSign, U0 be MSAlgebra over S;
  func Constants (U0) -> MSSubset of U0 means
  :Def5:
  for s be SortSymbol of S holds it.s = Constants(U0,s);
  existence
  proof
    deffunc G(SortSymbol of S) = Constants(U0,$1);
    consider f be Function such that
A1: dom f = the carrier of S &
    for d be SortSymbol of S holds f.d = G(d) from FUNCT_1:sch 4;
    reconsider f as ManySortedSet of the carrier of S by A1,PBOOLE:def 3;
    f c= the Sorts of U0
    proof
      let s be set;
      assume s in the carrier of S;
      then reconsider s1 = s as SortSymbol of S;
      f.s1 = Constants(U0,s1) by A1;
      hence thesis;
    end;
    then reconsider f as MSSubset of U0 by PBOOLE:def 23;
    take f;
    thus thesis by A1;
  end;
  uniqueness
  proof
    let W1, W2 be MSSubset of U0;
    assume
A2: (for s be SortSymbol of S holds W1.s = Constants(U0,s)) &
    for s be SortSymbol of S holds W2.s = Constants(U0,s);
    for s be set st s in the carrier of S holds W1.s = W2.s
    proof
      let s be set;
      assume s in the carrier of S;
      then reconsider t = s as SortSymbol of S;
      W1.t = Constants(U0,t) & W2.t = Constants(U0,t) by A2;
      hence thesis;
    end;
    hence thesis by PBOOLE:3;
  end;
end;

registration
  let S be all-with_const_op non void (non empty ManySortedSign),
  U0 be non-empty MSAlgebra over S, s be SortSymbol of S;
  cluster Constants(U0,s) -> non empty;
  coherence
  proof
    s is with_const_op by Def3;
    then consider o be OperSymbol of S such that
A1: (the Arity of S).o = {} & (the ResultSort of S).o = s by Def2;
A2: the OperSymbols of S <> {} by MSUALG_1:def 5;
A3: dom ((the Sorts of U0)# qua ManySortedSet of(the carrier of S)*)
    = (the carrier of S)* by PBOOLE:def 3;
A4: dom (the Arity of S) = the OperSymbols of S &
    rng(the Arity of S) c= (the carrier of S)* by FUNCT_2:def 1,RELSET_1:12;
    then (the Arity of S).o in rng (the Arity of S) by A2,FUNCT_1:def 5;
    then
A5: o in dom ((the Sorts of U0)# * the Arity of S) by A2,A3,A4,FUNCT_1:21;
    set f = Den(o,U0);
    dom {} = {} & rng {} = {};
    then reconsider a = {} as Function of {},{} by FUNCT_2:3;
    Args(o,U0) = ((the Sorts of U0)# * the Arity of S).o by MSUALG_1:def 9
      .= (the Sorts of U0)# . ((the Arity of S).o) by A5,FUNCT_1:22
      .= (the Sorts of U0)# . (the_arity_of o) by MSUALG_1:def 6
      .= product ((the Sorts of U0) * (the_arity_of o)) by PBOOLE:def 19
      .= product ((the Sorts of U0) * a) by A1,MSUALG_1:def 6
      .= {{}} by CARD_3:19;
    then
A6: {} in Args(o,U0) by TARSKI:def 1;
A7: dom f = Args (o,U0) & rng f c= Result(o,U0) by FUNCT_2:def 1,RELSET_1:12;
    then
A8: f.{} in rng f by A6,FUNCT_1:def 5;
A9: dom (the Sorts of U0) = the carrier of S by PBOOLE:def 3;
A10: dom (the ResultSort of S) = the OperSymbols of S &
    rng(the ResultSort of S) c= the carrier of S by FUNCT_2:def 1,RELSET_1:12;
    then (the ResultSort of S).o in rng (the ResultSort of S) by A2,
    FUNCT_1:def 5;
    then
A11: o in
    dom ((the Sorts of U0) * the ResultSort of S) by A2,A9,A10,FUNCT_1:21;
    Result(o,U0) = ((the Sorts of U0) * the ResultSort of S).o
    by MSUALG_1:def 10
      .= (the Sorts of U0).s by A1,A11,FUNCT_1:22;
    then reconsider a = f.{} as Element of (the Sorts of U0).s by A7,A8;
    ex A being non empty set st A =(the Sorts of U0).s &
    Constants(U0,s) = { b where b is Element of A :
    ex o be OperSymbol of S st (the Arity of S).o = {} &
    (the ResultSort of S).o = s & b in rng Den(o,U0)} by Def4;
    then a in Constants (U0,s) by A1,A8;
    hence thesis;
  end;
end;

registration
  let S be non void all-with_const_op (non empty ManySortedSign),
  U0 be non-empty MSAlgebra over S;
  cluster Constants(U0) -> non-empty;
  coherence
  proof
    now
      let i be set;
      assume i in the carrier of S;
      then reconsider s = i as SortSymbol of S;
      (Constants(U0)).s = Constants(U0,s) by Def5;
      hence (Constants(U0)).i is non empty;
    end;
    hence thesis by PBOOLE:def 16;
  end;
end;

begin

::
::   Subalgebras of a Many Sorted Algebra.
::

definition
  let S be non void non empty ManySortedSign, U0 be MSAlgebra over S,
  o be OperSymbol of S, A be MSSubset of U0;
  pred A is_closed_on o means
  :Def6:
  rng ((Den(o,U0))|((A# * the Arity of S).o)) c= (A * the ResultSort of S).o;
end;

definition
  let S be non void non empty ManySortedSign, U0 be MSAlgebra over S,
  A be MSSubset of U0;
  attr A is opers_closed means
  :Def7:
  for o be OperSymbol of S holds A is_closed_on o;
end;

theorem Th3:
  for S be non void non empty ManySortedSign, o be OperSymbol of S,
  U0 be MSAlgebra over S, B0, B1 be MSSubset of U0 st B0 c= B1 holds
  ((B0# * the Arity of S).o) c= ((B1# * the Arity of S).o)
proof
  let S be non void non empty ManySortedSign, o be OperSymbol of S,
  U0 be MSAlgebra over S, B0, B1 be MSSubset of U0;
  assume
A1: B0 c= B1;
A2: rng the Arity of S c= (the carrier of S)* &
  dom (the Arity of S) = the OperSymbols of S by FUNCT_2:def 1,RELSET_1:12;
  then
A3: dom (B0# * the Arity of S) = dom (the Arity of S) &
  dom (B1# * the Arity of S) = dom (the Arity of S) by PBOOLE:def 3;
A4: the OperSymbols of S <> {} by MSUALG_1:def 5;
  then (the Arity of S).o in rng the Arity of S by A2,FUNCT_1:def 5;
  then reconsider a = (the Arity of S).o as Element of (the carrier of S)*
  by A2;
  (B0# * the Arity of S).o = B0#.a & (B1# * the Arity of S).o = B1#.a
  by A2,A3,A4,FUNCT_1:22;
  then
A5: (B0# * the Arity of S).o = product (B0 * a) &
  (B1# * the Arity of S).o = product (B1 * a) by PBOOLE:def 19;
A6: dom B0 = the carrier of S & dom B1 = the carrier of S by PBOOLE:def 3;
A7: rng a c= the carrier of S by FINSEQ_1:def 4;
  then
A8: dom (B0 * a) = dom a & dom (B1 * a) = dom a by A6,RELAT_1:46;
  for x st x in dom (B0 * a) holds (B0*a).x c= (B1 * a).x
  proof
    let x;
    assume
A9: x in dom (B0 * a);
    then a.x in rng a by A8,FUNCT_1:def 5;
    then B0.(a.x) c= B1.(a.x) by A1,A7,PBOOLE:def 5;
    then (B0*a).x c= B1.(a.x) by A8,A9,FUNCT_1:23;
    hence thesis by A8,A9,FUNCT_1:23;
  end;
  hence thesis by A5,A8,CARD_3:38;
end;

definition
  let S be non void non empty ManySortedSign, U0 be MSAlgebra over S,
  o be OperSymbol of S, A be MSSubset of U0;
  assume
A1: A is_closed_on o;
  func o/.A ->Function of (A# * the Arity of S).o, (A * the ResultSort of S).o
  equals
  :Def8:
  (Den(o,U0)) | ((A# * the Arity of S).o);
  coherence
  proof
    set f = (Den(o,U0)) | ((A# * the Arity of S).o), B = the Sorts of U0;
A2: dom the ResultSort of S = the OperSymbols of S by FUNCT_2:def 1;
A3: the OperSymbols of S <> {} by MSUALG_1:def 5;
    per cases;
    suppose
A4:   (A * the ResultSort of S).o = {};
      rng f c= (A * the ResultSort of S).o by A1,Def6;
      then rng f = {} by A4;
      then
A5:   f = {};
      now per cases;
        suppose (A# * the Arity of S).o = {};
          hence thesis by A5,FUNCT_2:55,RELAT_1:60;
        end;
        suppose (A# * the Arity of S).o <> {};
          hence thesis by A4,A5,FUNCT_2:def 1,RELSET_1:25;
        end;
      end;
      hence thesis;
    end;
    suppose (A * the ResultSort of S).o <> {};
      then
A6:   A.((the ResultSort of S).o) <> {} by A2,A3,FUNCT_1:23;
A7:   (the ResultSort of S).o in the carrier of S by A3,FUNCT_2:7;
      A c= B by PBOOLE:def 23;
      then A.((the ResultSort of S).o)
      c= B.((the ResultSort of S).o) by A7,PBOOLE:def 5;
      then B.((the ResultSort of S).o) <> {} by A6;
      then (B * the ResultSort of S).o <> {} by A2,A3,FUNCT_1:23;
      then
A8:   Result(o,U0) <> {} by MSUALG_1:def 10;
      reconsider B0 = B as MSSubset of U0 by PBOOLE:def 23;
A9:   A c= B0 by PBOOLE:def 23;
      dom Den(o,U0) = Args(o,U0) by A8,FUNCT_2:def 1
        .= (B# * the Arity of S).o by MSUALG_1:def 9;
      then
A10:  dom f = ((B# * the Arity of S).o) /\ ((A# * the Arity of S).o) by
      FUNCT_1:68
        .= (A# * the Arity of S).o by A9,Th3,XBOOLE_1:28;
      rng f c= (A * the ResultSort of S).o by A1,Def6;
      hence thesis by A10,FUNCT_2:4;
    end;
  end;
end;

definition
  let S be non void non empty ManySortedSign, U0 be MSAlgebra over S,
  A be MSSubset of U0;
  func Opers(U0,A) -> ManySortedFunction of
  (A# * the Arity of S),(A * the ResultSort of S) means
  :Def9:
  for o be OperSymbol of S holds it.o = o/.A;
  existence
  proof
    defpred P[set,set] means for o be OperSymbol of S st o = $1 holds $2=o/.A;
A1: the OperSymbols of S <> {} by MSUALG_1:def 5;
A2: for x st x in the OperSymbols of S ex y st P[x,y]
    proof
      let x;
      assume x in the OperSymbols of S;
      then reconsider o=x as OperSymbol of S;
      take o/.A;
      thus thesis;
    end;
    consider f be Function such that
A3: dom f = the OperSymbols of S &
    for x st x in the OperSymbols of S holds P[x,f.x] from CLASSES1:sch 1(A2);
    reconsider f as ManySortedSet of the OperSymbols of S by A3,PBOOLE:def 3;
    for x st x in dom f holds f.x is Function
    proof
      let x;
      assume
A4:   x in dom f;
      then reconsider o=x as OperSymbol of S by A3;
      o in dom f & f.o = o/.A by A3,A4;
      hence thesis;
    end;
    then reconsider f as ManySortedFunction of the OperSymbols of S
    by FUNCOP_1:def 6;
    set B= A# * the Arity of S, C= A * the ResultSort of S;
    for x st x in the OperSymbols of S holds f.x is Function of B.x,C.x
    proof
      let x;
      assume
A5:   x in the OperSymbols of S;
      then reconsider o=x as OperSymbol of S;
      o in dom f & f.o = o/.A by A3,A5;
      hence thesis;
    end;
    then reconsider f as ManySortedFunction of B,C by PBOOLE:def 18;
    take f;
    let o be OperSymbol of S;
    thus thesis by A1,A3;
  end;
  uniqueness
  proof
    let f1, f2 be ManySortedFunction of
    (A# * the Arity of S),(A * the ResultSort of S);
    assume
A6: (for o be OperSymbol of S holds f1.o = o/.A) &
    (for o be OperSymbol of S holds f2.o = o/.A);
    for x st x in (the OperSymbols of S) holds f1.x = f2.x
    proof
      let x;
      assume x in (the OperSymbols of S);
      then reconsider o1 = x as OperSymbol of S;
      f1.o1 = o1/.A & f2.o1 =o1/.A by A6;
      hence thesis;
    end;
    hence thesis by PBOOLE:3;
  end;
end;

theorem Th4:
  for U0 being MSAlgebra over S
  for B being MSSubset of U0 st B=the Sorts of U0 holds
  B is opers_closed & for o holds o/.B = Den(o,U0)
proof
  let U0 be MSAlgebra over S;
  let B be MSSubset of U0;
  assume
A1: B=the Sorts of U0; thus
A2: B is opers_closed
  proof
    let o;
    per cases;
    suppose (B * the ResultSort of S).o = {};
      then
A3:   Result(o,U0) = {} by A1,MSUALG_1:def 10;
      now per cases;
        suppose Args(o,U0) = {};
          hence Den(o,U0) = {} by PARTFUN1:57;
        end;
        suppose Args(o,U0) <> {};
          hence Den(o,U0) = {} by A3,FUNCT_2:def 1;
        end;
      end;
      then rng ((Den(o,U0))|((B# * the Arity of S).o)) = {} by RELAT_1:60,111;
      hence rng ((Den(o,U0))|((B# * the Arity of S).o))
      c= (B * the ResultSort of S).o by XBOOLE_1:2;
    end;
    suppose (B * the ResultSort of S).o <> {};
      then Result(o,U0) <> {} by A1,MSUALG_1:def 10;
      then
A4:   dom Den(o,U0) = Args(o,U0) & rng Den(o,U0) c= Result(o,U0)
      by FUNCT_2:def 1,RELSET_1:12;
A5:   Args(o,U0) = (B# * the Arity of S).o by A1,MSUALG_1:def 9;
      Result (o,U0) = (B* the ResultSort of S).o by A1,MSUALG_1:def 10;
      hence rng ((Den(o,U0))|((B# * the Arity of S).o))
      c= (B * the ResultSort of S).o by A4,A5,RELAT_1:97;
    end;
  end;
  let o;
  B is_closed_on o by A2,Def7;
  then
A6: o/.B = (Den(o,U0))|((B# * the Arity of S).o) by Def8;
  per cases;
  suppose (B * the ResultSort of S).o = {};
    then
A7: Result(o,U0) = {} by A1,MSUALG_1:def 10;
    now per cases;
      suppose Args(o,U0) = {};
        hence Den(o,U0) = {} by PARTFUN1:57;
      end;
      suppose Args(o,U0) <> {};
        hence Den(o,U0) = {} by A7,FUNCT_2:def 1;
      end;
    end;
    hence o/.B = Den(o,U0) by A6,RELAT_1:111;
  end;
  suppose (B * the ResultSort of S).o <> {};
    then Result(o,U0) <> {} by A1,MSUALG_1:def 10;
    then
A8: dom Den(o,U0) = Args(o,U0) & rng Den(o,U0) c= Result(o,U0)
    by FUNCT_2:def 1,RELSET_1:12;
    Args(o,U0) = (B# * the Arity of S).o by A1,MSUALG_1:def 9;
    hence thesis by A6,A8,RELAT_1:97;
  end;
end;

theorem Th5:
  for B being MSSubset of U0 st B=the Sorts of U0 holds
  Opers(U0,B) = the Charact of U0
proof
  let B be MSSubset of U0;
  assume
A1: B=the Sorts of U0;
  set f1 = the Charact of U0, f2 = Opers(U0,B);
  for x st x in (the OperSymbols of S) holds f1.x = f2.x
  proof
    let x;
    assume x in (the OperSymbols of S);
    then reconsider o1 = x as OperSymbol of S;
    f1.o1 = Den(o1,U0) & f2.o1 = o1/.B by Def9,MSUALG_1:def 11;
    hence thesis by A1,Th4;
  end;
  hence thesis by PBOOLE:3;
end;

definition
  let S be non void non empty ManySortedSign, U0 be MSAlgebra over S;
  mode MSSubAlgebra of U0 -> MSAlgebra over S means
    :Def10:
    the Sorts of it is MSSubset of U0 &
    for B be MSSubset of U0 st B = the Sorts of it holds
    B is opers_closed & the Charact of it = Opers(U0,B);
  existence
  proof
    take U1 = U0;
    thus the Sorts of U1 is MSSubset of U0 by PBOOLE:def 23;
    let B be MSSubset of U0;
    assume
A1: B=the Sorts of U1;
    hence B is opers_closed by Th4;
    set f1 = the Charact of U1, f2 = Opers(U0,B);
    for x st x in (the OperSymbols of S) holds f1.x = f2.x
    proof
      let x;
      assume x in (the OperSymbols of S);
      then reconsider o1 = x as OperSymbol of S;
      f1.o1 = Den(o1,U1) & f2.o1 = o1/.B by Def9,MSUALG_1:def 11;
      hence thesis by A1,Th4;
    end;
    hence the Charact of U1 = Opers(U0,B) by PBOOLE:3;
  end;
end;

Lm1: for S being non void non empty ManySortedSign,
U0 being MSAlgebra over S holds
MSAlgebra (#the Sorts of U0,the Charact of U0#) is MSSubAlgebra of U0
proof
  let S be non void non empty ManySortedSign, U0 be MSAlgebra over S;
  reconsider A = MSAlgebra (#the Sorts of U0,the Charact of U0#)
  as strict MSAlgebra over S;
  now
    thus the Sorts of A is MSSubset of U0 by PBOOLE:def 23;
    let B be MSSubset of U0;
    assume
A1: B=the Sorts of A;
    hence B is opers_closed by Th4;
    set f1 = the Charact of A, f2 = Opers(U0,B);
    for x st x in (the OperSymbols of S) holds f1.x = f2.x
    proof
      let x;
      assume x in (the OperSymbols of S);
      then reconsider o1 = x as Element of the OperSymbols of S;
      f1.o1 = Den(o1,U0) & f2.o1 = o1/.B by Def9,MSUALG_1:def 11;
      hence thesis by A1,Th4;
    end;
    hence the Charact of A = Opers(U0,B) by PBOOLE:3;
  end;
  hence thesis by Def10;
end;

registration
  let S be non void non empty ManySortedSign, U0 be MSAlgebra over S;
  cluster strict MSSubAlgebra of U0;
  existence
  proof
    MSAlgebra (#the Sorts of U0,the Charact of U0#) is MSSubAlgebra of U0
    by Lm1;
    hence thesis;
  end;
end;

registration
  let S be non void non empty ManySortedSign,
  U0 be non-empty MSAlgebra over S;
  cluster MSAlgebra (#the Sorts of U0,the Charact of U0#) -> non-empty;
  coherence by MSUALG_1:def 8;
end;

registration
  let S be non void non empty ManySortedSign,
  U0 be non-empty MSAlgebra over S;
  cluster non-empty strict MSSubAlgebra of U0;
  existence
  proof
    MSAlgebra (#the Sorts of U0,the Charact of U0#) is MSSubAlgebra of U0
    by Lm1;
    hence thesis;
  end;
end;

theorem
  U0 is MSSubAlgebra of U0
proof
  thus the Sorts of U0 is MSSubset of U0 by PBOOLE:def 23;
  let B be MSSubset of U0;
  assume
A1: B=the Sorts of U0;
  hence B is opers_closed by Th4;
  set f1 = the Charact of U0, f2 = Opers(U0,B);
  for x st x in (the OperSymbols of S) holds f1.x = f2.x
  proof
    let x;
    assume x in (the OperSymbols of S);
    then reconsider o1 = x as OperSymbol of S;
    f1.o1 = Den(o1,U0) & f2.o1 = o1/.B by Def9,MSUALG_1:def 11;
    hence thesis by A1,Th4;
  end;
  hence the Charact of U0 = Opers(U0,B) by PBOOLE:3;
end;

theorem
  U0 is MSSubAlgebra of U1 & U1 is MSSubAlgebra of U2 implies
  U0 is MSSubAlgebra of U2
proof
  assume
A1: U0 is MSSubAlgebra of U1 & U1 is MSSubAlgebra of U2;
  then the Sorts of U0 is MSSubset of U1 &
  the Sorts of U1 is MSSubset of U2 by Def10;
  then
A2: the Sorts of U1 c= the Sorts of U2 &
  the Sorts of U0 c= the Sorts of U1 by PBOOLE:def 23;
  then the Sorts of U0 c= the Sorts of U2 by PBOOLE:15;
  hence the Sorts of U0 is MSSubset of U2 by PBOOLE:def 23;
  let B be MSSubset of U2;
  assume
A3: B = the Sorts of U0;
  reconsider B0 = the Sorts of U0 as MSSubset of U1 by A1,Def10;
  reconsider B1 = the Sorts of U1 as MSSubset of U2 by A1,Def10;
  reconsider B1'= B1 as MSSubset of U1 by PBOOLE:def 23;
A4: B0 is opers_closed & the Charact of U0 = Opers (U1,B0) &
  B1 is opers_closed & the Charact of U1 = Opers (U2,B1) by A1,Def10;
A5: for o be OperSymbol of S holds B is_closed_on o
  proof
    let o be OperSymbol of S;
A6: B0 is_closed_on o & B1 is_closed_on o by A4,Def7;
A7: Den(o,U1) = Opers(U2,B1).o by A4,MSUALG_1:def 11
      .= o/.B1 by Def9
      .= (Den(o,U2))|((B1# * the Arity of S).o) by A6,Def8;
A8: ((B0# * the Arity of S).o) c= ((B1'# * the Arity of S).o) by A2,Th3;
    Den(o,U0) = Opers(U1,B0).o by A4,MSUALG_1:def 11
      .= o/.B0 by Def9
      .= ((Den(o,U2))|((B1# * the Arity of S).o))|((B0# * the Arity of S).o)
    by A6,A7,Def8
      .= (Den(o,U2))|(((B1# * the Arity of S).o)/\((B0# * the Arity of S).o))
    by RELAT_1:100
      .= (Den(o,U2))|((B0# * the Arity of S).o) by A8,XBOOLE_1:28;
    then rng ((Den(o,U2))|((B0# * the Arity of S).o)) c= Result(o,U0)
    by RELSET_1:12;
    then rng ((Den(o,U2))|((B0# * the Arity of S).o)) c=
    ((the Sorts of U0) * the ResultSort of S).o by MSUALG_1:def 10;
    hence thesis by A3,Def6;
  end;
  hence B is opers_closed by Def7;
  set O = the Charact of U0, P = Opers(U2,B);
  for x st x in the OperSymbols of S holds O.x =P.x
  proof
    let x;
    assume x in the OperSymbols of S;
    then reconsider o = x as OperSymbol of S;
A9: B0 is_closed_on o & B1 is_closed_on o by A4,Def7;
A10: Den(o,U1) = Opers(U2,B1).o by A4,MSUALG_1:def 11
      .= o/.B1 by Def9
      .= (Den(o,U2))|((B1# * the Arity of S).o) by A9,Def8;
    thus O.x = o/.B0 by A4,Def9
      .= ((Den(o,U2))|((B1# * the Arity of S).o))|((B0# * the Arity of S).o)
    by A9,A10,Def8
      .= (Den(o,U2))|(((B1# * the Arity of S).o)/\((B0# * the Arity of S).o))
    by RELAT_1:100
      .= (Den(o,U2))|((B# * the Arity of S).o) by A2,A3,Th3,XBOOLE_1:28
      .= o/.B by A5,Def8
      .= P.x by Def9;
  end;
  hence thesis by PBOOLE:3;
end;

theorem Th8:
  U1 is strict MSSubAlgebra of U2 & U2 is strict MSSubAlgebra of U1 implies
  U1 = U2
proof
  assume
A1: U1 is strict MSSubAlgebra of U2 & U2 is strict MSSubAlgebra of U1;
  then the Sorts of U1 is MSSubset of U2 &
  the Sorts of U2 is MSSubset of U1 by Def10;
  then the Sorts of U1 c= the Sorts of U2 & the Sorts of U2 c= the Sorts of U1
  by PBOOLE:def 23;
  then
A2: the Sorts of U1 = the Sorts of U2 by PBOOLE:def 13;
  reconsider B1 = the Sorts of U1 as MSSubset of U2 by A1,Def10;
  reconsider B2 = the Sorts of U2 as MSSubset of U1 by A1,Def10;
A3: B2 is opers_closed & the Charact of U2 = Opers(U1,B2) &
  B1 is opers_closed & the Charact of U1 = Opers(U2,B1) by A1,Def10;
  set O = the Charact of U1, P = Opers(U1,B2);
  for x st x in the OperSymbols of S holds O.x = P.x
  proof
    let x;
    assume x in the OperSymbols of S;
    then reconsider o = x as OperSymbol of S;
A4: B1 is_closed_on o by A3,Def7;
A5: Args(o,U2) = (B2# * the Arity of S).o by MSUALG_1:def 9;
    thus O.x = o/.B1 by A3,Def9
      .= (Den(o,U2))|((B1# * the Arity of S).o) by A4,Def8
      .= Den(o,U2) by A2,A5,FUNCT_2:40
      .= P.x by A3,MSUALG_1:def 11;
  end;
  hence thesis by A1,A2,A3,PBOOLE:3;
end;

theorem Th9:
  for U1,U2 be MSSubAlgebra of U0 st the Sorts of U1 c= the Sorts of U2
  holds U1 is MSSubAlgebra of U2
proof
  let U1, U2 be MSSubAlgebra of U0;
  assume
A1: the Sorts of U1 c= the Sorts of U2;
  hence the Sorts of U1 is MSSubset of U2 by PBOOLE:def 23;
  let B be MSSubset of U2;
  assume
A2: B = the Sorts of U1;
  reconsider B1 = the Sorts of U1, B2 = the Sorts of U2
  as MSSubset of U0 by Def10;
A3: B1 is opers_closed & the Charact of U1 = Opers(U0,B1) &
  B2 is opers_closed & the Charact of U2 = Opers(U0,B2) by Def10;
A4: for o be OperSymbol of S holds B is_closed_on o
  proof
    let o be OperSymbol of S;
A5: B1 is_closed_on o & B2 is_closed_on o by A3,Def7;
A6: Den(o,U2) = Opers(U0,B2).o by A3,MSUALG_1:def 11
      .= o/.B2 by Def9
      .= (Den(o,U0))|((B2# * the Arity of S).o) by A5,Def8;
    Den(o,U1) = Opers(U0,B1).o by A3,MSUALG_1:def 11
      .= o/.B1 by Def9
      .= (Den(o,U0))|((B1# * the Arity of S).o) by A5,Def8
      .= (Den(o,U0))|(((B2# * the Arity of S).o) /\ ((B1# * the Arity of S).o))
    by A1,Th3,XBOOLE_1:28
      .= (Den(o,U2))|((B1# * the Arity of S).o) by A6,RELAT_1:100;
    then rng ((Den(o,U2))|((B1# * the Arity of S).o)) c= Result(o,U1)
    by RELSET_1:12;
    then rng ((Den(o,U2))|((B1# * the Arity of S).o)) c=
    ((the Sorts of U1) * the ResultSort of S).o by MSUALG_1:def 10;
    hence thesis by A2,Def6;
  end;
  hence B is opers_closed by Def7;
  set O = the Charact of U1, P = Opers(U2,B);
  for x st x in the OperSymbols of S holds O.x =P.x
  proof
    let x;
    assume x in the OperSymbols of S;
    then reconsider o = x as OperSymbol of S;
A7: B1 is_closed_on o & B2 is_closed_on o by A3,Def7;
A8: Den(o,U2) = Opers(U0,B2).o by A3,MSUALG_1:def 11
      .= o/.B2 by Def9
      .= (Den(o,U0))|((B2# * the Arity of S).o) by A7,Def8;
    thus O.x = o/.B1 by A3,Def9
      .= (Den(o,U0))|((B1# * the Arity of S).o) by A7,Def8
      .= (Den(o,U0))|(((B2# * the Arity of S).o) /\ ((B1# * the Arity of S).o))
    by A1,Th3,XBOOLE_1:28
      .= (Den(o,U2))|((B1# * the Arity of S).o) by A8,RELAT_1:100
      .= o/.B by A2,A4,Def8
      .= P.x by Def9;
  end;
  hence thesis by PBOOLE:3;
end;

theorem Th10:
  for U1,U2 be strict MSSubAlgebra of U0 st the Sorts of U1 = the Sorts of U2
  holds U1 = U2
proof
  let U1,U2 be strict MSSubAlgebra of U0;
  assume the Sorts of U1 = the Sorts of U2;

then U1 is strict MSSubAlgebra of U2 & U2 is strict MSSubAlgebra of U1 by Th9;
  hence thesis by Th8;
end;

theorem Th11:
  for S be non void non empty ManySortedSign, U0 be MSAlgebra over S,
  U1 be MSSubAlgebra of U0 holds Constants(U0) is MSSubset of U1
proof
  let S be non void non empty ManySortedSign, U0 be MSAlgebra over S,
  U1 be MSSubAlgebra of U0;
  Constants(U0) c= the Sorts of U1
  proof
    let x be set;
    assume x in the carrier of S;
    then reconsider s = x as SortSymbol of S;
    thus (Constants(U0)).x c= (the Sorts of U1).x
    proof
      let y be set;
      per cases;
      suppose
A1:     (the Sorts of U0).s = {};
        (Constants(U0)).s = Constants(U0,s) by Def5
          .= {} by A1;
        hence thesis;
      end;
      suppose
A2:     (the Sorts of U0).s <> {};
        assume
A3:     y in (Constants(U0)).x;
A4:     (Constants(U0)).x = Constants(U0,s) by Def5;
        ex A being non empty set st A =(the Sorts of U0).s &
        Constants(U0,s) = { b where b is Element of A :
        ex o be OperSymbol of S st (the Arity of S).o = {} &
        (the ResultSort of S).o = s & b in rng Den(o,U0)} by A2,Def4;
        then consider b be Element of (the Sorts of U0).s such that
A5:     b=y & ex o be OperSymbol of S st (the Arity of S).o={} &
        (the ResultSort of S).o = s & b in rng Den(o,U0) by A3,A4;
        consider o be OperSymbol of S such that
A6:     (the Arity of S).o = {} & (the ResultSort of S).o = s &
        b in rng Den(o,U0) by A5;
        reconsider u1=the Sorts of U1 as MSSubset of U0 by Def10;
        u1 is opers_closed & the Charact of U1 = Opers(U0,u1) by Def10;
        then u1 is_closed_on o by Def7;
        then
A7:     rng ((Den(o,U0))|((u1# * the Arity of S).o))
        c=(u1*the ResultSort of S).o by Def6;
A8:     the OperSymbols of S <> {} by MSUALG_1:def 5;
A9:     dom ((the Sorts of U0)# qua ManySortedSet of(the carrier of S)*)

= (the carrier of S)* & dom (u1# qua ManySortedSet of(the carrier of S)* )
        = (the carrier of S)* by PBOOLE:def 3;
A10:    dom (the Arity of S) = the OperSymbols of S &
        rng(the Arity of S) c= (the carrier of S)*
        by FUNCT_2:def 1,RELSET_1:12;
        then (the Arity of S).o in rng (the Arity of S) by A8,FUNCT_1:def 5;
        then
A11:    o in dom ((the Sorts of U0)# * the Arity of S) &
        o in dom (u1# * the Arity of S)by A8,A9,A10,FUNCT_1:21;
        dom {} = {} & rng {} = {};
        then reconsider a = {} as Function of {},{} by FUNCT_2:3;
        rng Den(o,U0) c= Result(o,U0) by RELSET_1:12;
        then
A12:    dom (Den (o,U0)) = Args(o,U0) by A6,FUNCT_2:def 1
          .= ((the Sorts of U0)# * the Arity of S).o by MSUALG_1:def 9
          .= (the Sorts of U0)# . ((the Arity of S).o) by A11,FUNCT_1:22
          .= (the Sorts of U0)# . (the_arity_of o) by MSUALG_1:def 6
          .= product ((the Sorts of U0) * (the_arity_of o)) by PBOOLE:def 19
          .= product ((the Sorts of U0) * a) by A6,MSUALG_1:def 6
          .= {{}} by CARD_3:19;
        (u1# * the Arity of S).o = u1# . ((the Arity of S).o) by A11,FUNCT_1:22
          .= u1# . (the_arity_of o) by MSUALG_1:def 6
          .= product (u1 * (the_arity_of o)) by PBOOLE:def 19
          .= product (u1 * a) by A6,MSUALG_1:def 6
          .= {{}} by CARD_3:19;
        then (Den(o,U0))|((u1# * the Arity of S).o) =(Den(o,U0)) by A12,
        RELAT_1:97;
        then
A13:    b in (u1*the ResultSort of S).o by A6,A7;
        dom (the ResultSort of S) = the OperSymbols of S &
        rng(the ResultSort of S) c= the carrier of S
        by FUNCT_2:def 1,RELSET_1:12;
        hence thesis by A5,A6,A8,A13,FUNCT_1:23;
      end;
    end;
  end;
  hence thesis by PBOOLE:def 23;
end;

theorem
  for S be non void all-with_const_op (non empty ManySortedSign),
  U0 be non-empty MSAlgebra over S, U1 be non-empty MSSubAlgebra of U0 holds
  Constants(U0) is non-empty MSSubset of U1 by Th11;

theorem
  for S be non void all-with_const_op (non empty ManySortedSign),
  U0 be non-empty MSAlgebra over S, U1,U2 be non-empty MSSubAlgebra of U0 holds
  (the Sorts of U1) /\ (the Sorts of U2) is non-empty
proof
  let S be non void all-with_const_op (non empty ManySortedSign),
  U0 be non-empty MSAlgebra over S, U1,U2 be non-empty MSSubAlgebra of U0;
  Constants(U0) is non-empty MSSubset of U1 &
  Constants(U0) is non-empty MSSubset of U2 by Th11;
  then Constants(U0)c=the Sorts of U1 & Constants(U0)c=the Sorts of U2
  by PBOOLE:def 23;
  then
A1: (Constants(U0)) /\ (Constants(U0)) c= (the Sorts of U1) /\ (the
  Sorts of U2) by PBOOLE:23;
  now
    let i be set;
    assume i in the carrier of S;
    then reconsider s = i as SortSymbol of S;
    ((the Sorts of U1) /\ (the Sorts of U2)).s =
    ((the Sorts of U1).s) /\ ((the Sorts of U2).s) by PBOOLE:def 8;
    then
A2: (Constants (U0)).s c= ((the Sorts of U1).s) /\ ((the Sorts of U2). s)
    by A1,PBOOLE:def 5;
    consider a be set such that
A3: a in (Constants(U0)).s by XBOOLE_0:def 1;
    thus ((the Sorts of U1) /\ (the Sorts of U2)).i is non empty by A2,A3,
    PBOOLE:def 8;
  end;
  hence thesis by PBOOLE:def 16;
end;

begin

::
::  Many Sorted Subsets of a Many Sorted Algebra.
::

definition
  let S be non void non empty ManySortedSign, U0 be MSAlgebra over S,
  A be MSSubset of U0;
  func SubSort(A) -> set means
  :Def11:
  for x be set holds
  x in it iff x in Funcs(the carrier of S, bool (Union (the Sorts of U0))) &
  x is MSSubset of U0 & for B be MSSubset of U0 st
  B = x holds B is opers_closed & Constants(U0) c= B & A c= B;
  existence
  proof
    defpred P[set] means $1 is MSSubset of U0 & for B be MSSubset of U0 st
    B = $1 holds B is opers_closed & Constants(U0) c= B & A c= B;
    consider X be set such that
A1: for x be set holds
    x in X iff x in Funcs(the carrier of S, bool (Union (the Sorts of U0))) &
    P[x] from XBOOLE_0:sch 1;
    take X;
    thus thesis by A1;
  end;
  uniqueness
  proof
    defpred P[set] means
    $1 in Funcs(the carrier of S, bool (Union (the Sorts of U0))) &
    $1 is MSSubset of U0 & for B be MSSubset of U0 st
    B = $1 holds B is opers_closed & Constants(U0) c= B & A c= B;
    for X1,X2 being set st (for x be set holds x in X1 iff P[x]) &
    (for x be set holds x in X2 iff P[x]) holds X1 = X2 from XBOOLE_0:sch 3;
    hence thesis;
  end;
end;

Lm2: for S being non void non empty ManySortedSign, U0 being MSAlgebra over S,
A being MSSubset of U0 holds the Sorts of U0 in SubSort(A)
proof
  let S be non void non empty ManySortedSign, U0 be MSAlgebra over S,
  A be MSSubset of U0;
  set f = Funcs(the carrier of S, bool (Union (the Sorts of U0)));
A1: dom (the Sorts of U0) = the carrier of S by PBOOLE:def 3;
  (Union (the Sorts of U0)) = union rng(the Sorts of U0) by CARD_3:def 4;
  then rng(the Sorts of U0) c= bool(Union (the Sorts of U0)) by ZFMISC_1:100;
  then
A2: the Sorts of U0 in f by A1,FUNCT_2:def 2;
A3: the Sorts of U0 is MSSubset of U0 by PBOOLE:def 23;
  for B be MSSubset of U0 st B = the Sorts of U0
  holds B is opers_closed & Constants(U0) c= B & A c= B by Th4,PBOOLE:def 23;
  hence thesis by A2,A3,Def11;
end;

registration
  let S be non void non empty ManySortedSign, U0 be MSAlgebra over S,
  A be MSSubset of U0;
  cluster SubSort(A) -> non empty;
  coherence by Lm2;
end;

definition
  let S be non void non empty ManySortedSign, U0 be MSAlgebra over S;
  func SubSort(U0) -> set means
  :Def12:
  for x be set holds
  x in it iff x in Funcs(the carrier of S, bool Union the Sorts of U0) &
  x is MSSubset of U0 & for B be MSSubset of U0 st
  B = x holds B is opers_closed;
  existence
  proof
    defpred P[set] means $1 is MSSubset of U0 & for B be MSSubset of U0 st
    B = $1 holds B is opers_closed;
    consider X be set such that
A1: for x be set holds
    x in X iff x in Funcs(the carrier of S, bool Union the Sorts of U0) &
    P[x] from XBOOLE_0:sch 1;
    take X;
    thus thesis by A1;
  end;
  uniqueness
  proof
    defpred P[set] means
    $1 in Funcs(the carrier of S, bool Union the Sorts of U0) &
    $1 is MSSubset of U0 & for B be MSSubset of U0 st
    B = $1 holds B is opers_closed;
    for X1,X2 being set st (for x being set holds x in X1 iff P[x]) &
    (for x being set holds x in X2 iff P[x]) holds X1 = X2 from
    XBOOLE_0:sch 3;
    hence thesis;
  end;
end;

registration
  let S be non void non empty ManySortedSign, U0 be MSAlgebra over S;
  cluster SubSort(U0) -> non empty;
  coherence
  proof
    defpred P[set] means $1 is MSSubset of U0 & for B be MSSubset of U0 st
    B = $1 holds B is opers_closed;
    consider X be set such that
A1: for x be set holds
    x in X iff x in Funcs(the carrier of S, bool (Union (the Sorts of U0))) &
    P[x] from XBOOLE_0:sch 1;
    set f = Funcs(the carrier of S, bool (Union (the Sorts of U0)));
A2: dom (the Sorts of U0) = the carrier of S by PBOOLE:def 3;
    (Union (the Sorts of U0)) = union rng(the Sorts of U0) by CARD_3:def 4;
    then rng(the Sorts of U0) c= bool(Union (the Sorts of U0)) by ZFMISC_1:100;
    then
A3: the Sorts of U0 in f by A2,FUNCT_2:def 2;
A4: the Sorts of U0 is MSSubset of U0 by PBOOLE:def 23;
    for B be MSSubset of U0 st B = the Sorts of U0
    holds B is opers_closed by Th4;
    then reconsider X as non empty set by A1,A3,A4;
    SubSort U0 = X by A1,Def12;
    hence thesis;
  end;
end;

definition
  let S be non void non empty ManySortedSign, U0 be MSAlgebra over S,
  e be Element of SubSort(U0);
  func @e -> MSSubset of U0 equals

  e;
  coherence by Def12;
end;

theorem Th14:
  for A,B be MSSubset of U0 holds
  B in SubSort(A) iff B is opers_closed & Constants(U0) c= B & A c= B
proof
  let A, B be MSSubset of U0;
  thus B in SubSort(A) implies B is opers_closed & Constants(U0) c= B & A c= B
  by Def11;
  assume
A1: B is opers_closed & Constants(U0) c= B & A c= B;
  set C = bool (Union (the Sorts of U0));
A2: dom B = the carrier of S & dom (the Sorts of U0) = the carrier of S
  by PBOOLE:def 3;
  union rng B c= union(rng(the Sorts of U0))
  proof
    let x be set;
    assume x in union rng B;
    then consider Y be set such that
A3: x in Y & Y in rng B by TARSKI:def 4;
    consider y be set such that
A4: y in dom B & B.y = Y by A3,FUNCT_1:def 5;
    B c= the Sorts of U0 by PBOOLE:def 23;
    then
A5: B.y c= (the Sorts of U0).y by A2,A4,PBOOLE:def 5;
    (the Sorts of U0).y in rng(the Sorts of U0) by A2,A4,FUNCT_1:def 5;
    hence thesis by A3,A4,A5,TARSKI:def 4;
  end;
  then bool union rng B c= bool union(rng(the Sorts of U0)) by ZFMISC_1:79;
  then bool union rng B c= C & rng B c= bool union rng B
  by CARD_3:def 4,ZFMISC_1:100;
  then rng B c= C by XBOOLE_1:1;
  then
A6: B in Funcs(the carrier of S, C) by A2,FUNCT_2:def 2;
  for C be MSSubset of U0 st
  C = B holds C is opers_closed & Constants(U0) c= C & A c= C by A1;
  hence thesis by A6,Def11;
end;

theorem Th15:
  for B be MSSubset of U0 holds B in SubSort(U0) iff B is opers_closed
proof
  let B be MSSubset of U0;
  thus B in SubSort(U0) implies B is opers_closed by Def12;
  assume
A1: B is opers_closed;
  set C = bool (Union (the Sorts of U0));
A2: dom B = the carrier of S & dom (the Sorts of U0) = the carrier of S
  by PBOOLE:def 3;
  union rng B c= union(rng(the Sorts of U0))
  proof
    let x be set;
    assume x in union rng B;
    then consider Y be set such that
A3: x in Y & Y in rng B by TARSKI:def 4;
    consider y be set such that
A4: y in dom B & B.y = Y by A3,FUNCT_1:def 5;
    B c= the Sorts of U0 by PBOOLE:def 23;
    then
A5: B.y c= (the Sorts of U0).y by A2,A4,PBOOLE:def 5;
    (the Sorts of U0).y in rng(the Sorts of U0) by A2,A4,FUNCT_1:def 5;
    hence thesis by A3,A4,A5,TARSKI:def 4;
  end;
  then bool union rng B c= bool union(rng(the Sorts of U0)) by ZFMISC_1:79;
  then bool union rng B c= C & rng B c= bool union rng B
  by CARD_3:def 4,ZFMISC_1:100;
  then rng B c= C by XBOOLE_1:1;
  then
A6: B in Funcs(the carrier of S, C) by A2,FUNCT_2:def 2;
  for C be MSSubset of U0 st C = B holds C is opers_closed by A1;
  hence thesis by A6,Def12;
end;

definition
  let S be non void non empty ManySortedSign, U0 be MSAlgebra over S,
  A be MSSubset of U0, s be SortSymbol of S;
  func SubSort(A,s) -> set means
  :Def14:
  for x be set holds
  x in it iff ex B be MSSubset of U0 st B in SubSort(A) & x = B.s;
  existence
  proof
    set C =bool Union (the Sorts of U0);
    defpred P[set] means ex B be MSSubset of U0 st B in SubSort(A) & $1 = B.s;
    consider X be set such that
A1: for x be set holds x in X iff x in C & P[x] from XBOOLE_0:sch 1;
A2: C = bool union( rng(the Sorts of U0)) by CARD_3:def 4;
A3: for x be set holds
    x in X iff ex B be MSSubset of U0 st B in SubSort(A) & x = B.s
    proof
      let x be set;
      thus x in X implies
      ex B be MSSubset of U0 st B in SubSort(A) & x = B.s by A1;
      given B be MSSubset of U0 such that
A4:   B in SubSort(A) & x = B.s;
      dom (the Sorts of U0) = the carrier of S & dom B = the carrier of S
      by PBOOLE:def 3;
      then (the Sorts of U0).s in rng (the Sorts of U0) by FUNCT_1:def 5;
      then
A5:   (the Sorts of U0).s c= union( rng (the Sorts of U0)) by ZFMISC_1:92;
      B c= the Sorts of U0 by PBOOLE:def 23;
      then B.s c= (the Sorts of U0).s by PBOOLE:def 5;
      then x c= union( rng (the Sorts of U0)) by A4,A5,XBOOLE_1:1;
      hence thesis by A1,A2,A4;
    end;
    take X;
    thus thesis by A3;
  end;
  uniqueness
  proof
    defpred P[set] means ex B be MSSubset of U0 st B in SubSort(A) & $1 = B.s;
    for X1,X2 being set st (for x being set holds x in X1 iff P[x]) &
    (for x being set holds x in X2 iff P[x]) holds X1 = X2 from
    XBOOLE_0:sch 3;
    hence thesis;
  end;
end;

registration
  let S be non void non empty ManySortedSign, U0 be MSAlgebra over S,
  A be MSSubset of U0, s be SortSymbol of S;
  cluster SubSort(A,s) -> non empty;
  coherence
  proof
    set C =bool Union (the Sorts of U0);
    defpred P[set] means ex B be MSSubset of U0 st B in SubSort(A) & $1 = B.s;
    consider X be set such that
A1: for x be set holds x in X iff x in C & P[x] from XBOOLE_0:sch 1;
A2: C = bool union( rng(the Sorts of U0)) by CARD_3:def 4;
A3: for x be set holds
    x in X iff ex B be MSSubset of U0 st B in SubSort(A) & x = B.s
    proof
      let x be set;
      thus x in X implies
      ex B be MSSubset of U0 st B in SubSort(A) & x = B.s by A1;
      given B be MSSubset of U0 such that
A4:   B in SubSort(A) & x = B.s;
      dom (the Sorts of U0) = the carrier of S & dom B = the carrier of S
      by PBOOLE:def 3;
      then (the Sorts of U0).s in rng (the Sorts of U0) by FUNCT_1:def 5;
      then
A5:   (the Sorts of U0).s c= union( rng (the Sorts of U0)) by ZFMISC_1:92;
      B c= the Sorts of U0 by PBOOLE:def 23;
      then B.s c= (the Sorts of U0).s by PBOOLE:def 5;
      then x c= union( rng (the Sorts of U0)) by A4,A5,XBOOLE_1:1;
      hence thesis by A1,A2,A4;
    end;
    reconsider u0 = the Sorts of U0 as MSSubset of U0 by PBOOLE:def 23;
    A c= u0 & Constants(U0)c= u0 & u0 is opers_closed by Th4,PBOOLE:def 23;
    then u0 in SubSort(A) by Th14;
    then (the Sorts of U0).s in X by A3;
    then reconsider X as non empty set;
    X = SubSort(A,s) by A3,Def14;
    hence thesis;
  end;
end;

definition
  let S be non void non empty ManySortedSign, U0 be MSAlgebra over S,
  A be MSSubset of U0;
  func MSSubSort(A) -> MSSubset of U0 means
  :Def15:
  for s be SortSymbol of S holds it.s = meet (SubSort(A,s));
  existence
  proof
    deffunc F(SortSymbol of S) = meet (SubSort(A,$1));
    consider f be Function such that
A1: dom f = the carrier of S &
    for s be SortSymbol of S holds f.s = F(s) from FUNCT_1:sch 4;
    reconsider f as ManySortedSet of (the carrier of S) by A1,PBOOLE:def 3;
    f c= the Sorts of U0
    proof
      let x be set;
      assume x in the carrier of S;
      then reconsider s = x as SortSymbol of S;
A2:   f.s = meet (SubSort(A,s)) by A1;
      reconsider u0 = the Sorts of U0 as MSSubset of U0 by PBOOLE:def 23;
      A c= u0 & Constants(U0)c= u0 & u0 is opers_closed by Th4,PBOOLE:def 23;
      then u0 in SubSort(A) by Th14;
      then (the Sorts of U0).s in (SubSort(A,s)) by Def14;
      hence thesis by A2,SETFAM_1:4;
    end;
    then reconsider f as MSSubset of U0 by PBOOLE:def 23;
    take f;
    thus thesis by A1;
  end;
  uniqueness
  proof
    let W1,W2 be MSSubset of U0;
    assume
A3: (for s be SortSymbol of S holds W1.s = meet (SubSort(A,s))) &
    (for s be SortSymbol of S holds W2.s = meet (SubSort(A,s)));
    for s be set st s in (the carrier of S) holds W1.s = W2.s
    proof
      let s be set;
      assume s in (the carrier of S);
      then reconsider s as SortSymbol of S;
      W1.s = meet (SubSort(A,s)) & W2.s = meet (SubSort(A,s)) by A3;
      hence thesis;
    end;
    hence thesis by PBOOLE:3;
  end;
end;

theorem Th16:
  for A be MSSubset of U0 holds Constants(U0) \/ A c= MSSubSort(A)
proof
  let A be MSSubset of U0;
  let i be set;
  assume i in the carrier of S;
  then reconsider s = i as SortSymbol of S;
A1: (MSSubSort(A)).s = meet (SubSort(A,s)) by Def15;
  for Z be set st Z in SubSort(A,s) holds (Constants(U0) \/ A).s c= Z
  proof
    let Z be set;
    assume Z in SubSort(A,s);
    then consider B be MSSubset of U0 such that
A2: B in SubSort(A) & Z = B.s by Def14;
    Constants(U0) c= B & A c= B by A2,Th14;
    then Constants(U0) \/ A c= B by PBOOLE:18;
    hence thesis by A2,PBOOLE:def 5;
  end;
  hence thesis by A1,SETFAM_1:6;
end;

theorem Th17:
  for A be MSSubset of U0 st Constants(U0) \/ A is non-empty holds
  MSSubSort(A) is non-empty
proof
  let A be MSSubset of U0;
  assume
A1: Constants(U0) \/ A is non-empty;
  now
    let i be set;
    assume i in the carrier of S;
    then reconsider s = i as SortSymbol of S;
A2: (Constants(U0) \/ A).s is non empty by A1;
    for Z be set st Z in SubSort(A,s) holds (Constants(U0) \/ A).s c= Z
    proof
      let Z be set;
      assume Z in SubSort(A,s);
      then consider B be MSSubset of U0 such that
A3:   B in SubSort(A) & Z = B.s by Def14;
      Constants(U0) c= B & A c= B by A3,Th14;
      then Constants(U0) \/ A c= B by PBOOLE:18;
      hence thesis by A3,PBOOLE:def 5;
    end;
    then
A4: (Constants(U0) \/ A).s c= meet(SubSort(A,s)) by SETFAM_1:6;
    consider x be set such that
A5: x in (Constants(U0) \/ A).s by A2,XBOOLE_0:def 1;
    thus (MSSubSort(A)).i is non empty by A4,A5,Def15;
  end;
  hence thesis by PBOOLE:def 16;
end;

theorem Th18:
  for A be MSSubset of U0 for B be MSSubset of U0 st B in SubSort(A) holds
  ((MSSubSort A)# * (the Arity of S)).o c= (B# * (the Arity of S)).o
proof
  let A be MSSubset of U0, B be MSSubset of U0;
  assume
A1: B in SubSort(A);
  MSSubSort (A) c= B
  proof
    let i be set;
    assume i in the carrier of S;
    then reconsider s = i as SortSymbol of S;
A2: (MSSubSort A).s = meet (SubSort(A,s)) by Def15;
    B.s in (SubSort(A,s)) by A1,Def14;
    hence thesis by A2,SETFAM_1:4;
  end;
  hence thesis by Th3;
end;

theorem Th19:
  for A be MSSubset of U0 for B be MSSubset of U0 st B in SubSort(A) holds
  rng (Den(o,U0)|(((MSSubSort A)# * (the Arity of S)).o)) c=
  (B * (the ResultSort of S)).o
proof
  let A be MSSubset of U0, B be MSSubset of U0;
  set m = ((MSSubSort A)# * (the Arity of S)).o,
  b = (B# * (the Arity of S)).o, d = Den(o,U0);
  assume
A1: B in SubSort(A);
  then b /\ m = m by Th18,XBOOLE_1:28;
  then d|m = (d|b)|m by RELAT_1:100;
  then
A2: rng (d|m) c= rng(d|b) by RELAT_1:99;
  B is opers_closed by A1,Th14;
  then B is_closed_on o by Def7;
  then rng (d|b) c= (B * (the ResultSort of S)).o by Def6;
  hence thesis by A2,XBOOLE_1:1;
end;

theorem Th20:
  for A be MSSubset of U0 holds
  rng ((Den(o,U0))|(((MSSubSort A)# * (the Arity of S)).o)) c=
  ((MSSubSort A) * (the ResultSort of S)).o
proof
  let A be MSSubset of U0;
  let x be set;
  assume that
A1: x in rng ((Den(o,U0))|(((MSSubSort A)# * (the Arity of S)).o)) and
A2: not x in ((MSSubSort A) * (the ResultSort of S)).o;
  set r = the_result_sort_of o;
A3: r = (the ResultSort of S).o by MSUALG_1:def 7;
A4: dom (the ResultSort of S) = the OperSymbols of S &
  rng (the ResultSort of S) c= the carrier of S by FUNCT_2:def 1,RELSET_1:12;
A5: the OperSymbols of S <> {} by MSUALG_1:def 5;
  then ((MSSubSort A) * (the ResultSort of S)).o = (MSSubSort A).r
  by A3,A4,FUNCT_1:23
    .= meet SubSort(A,r) by Def15;
  then consider X be set such that
A6: X in SubSort(A,r) & not x in X by A2,SETFAM_1:def 1;
  consider B be MSSubset of U0 such that
A7: B in SubSort(A) & B.r = X by A6,Def14;
  rng (Den(o,U0)|(((MSSubSort A)# * (the Arity of S)).o)) c=
  (B * (the ResultSort of S)).o by A7,Th19;
  then x in (B * (the ResultSort of S)).o by A1;
  hence contradiction by A3,A4,A5,A6,A7,FUNCT_1:23;
end;

theorem Th21:
  for A be MSSubset of U0 holds
  MSSubSort(A) is opers_closed & A c= MSSubSort(A)
proof
  let A be MSSubset of U0;
  thus MSSubSort(A) is opers_closed
  proof
    let o be OperSymbol of S;
    rng ((Den(o,U0))|(((MSSubSort A)# * (the Arity of S)).o)) c=
    ((MSSubSort A) * (the ResultSort of S)).o by Th20;
    hence thesis by Def6;
  end;
A1: A c= Constants(U0) \/ A by PBOOLE:16;
  Constants(U0) \/ A c= MSSubSort(A) by Th16;
  hence thesis by A1,PBOOLE:15;
end;

begin

::
::  Operations on Subalgebras of a Many Sorted Algebra.
::

definition
  let S be non void non empty ManySortedSign, U0 be MSAlgebra over S,
  A be MSSubset of U0;
  assume
A1: A is opers_closed;
  func U0|A -> strict MSSubAlgebra of U0 equals
  :Def16:
  MSAlgebra (#A, Opers(U0,A) qua ManySortedFunction of
    (A# * the Arity of S),(A * the ResultSort of S)#);
  coherence
  proof
    reconsider E = MSAlgebra (#A, Opers(U0,A) qua ManySortedFunction of
      (A# * the Arity of S),(A * the ResultSort of S)#) as MSAlgebra over S;
    for B be MSSubset of U0 st B = the Sorts of E holds
    B is opers_closed & the Charact of E = Opers(U0,B) by A1;
    hence thesis by Def10;
  end;
end;

definition
  let S be non void non empty ManySortedSign, U0 be MSAlgebra over S,
  U1,U2 be MSSubAlgebra of U0;
  func U1 /\ U2 -> strict MSSubAlgebra of U0 means
  :Def17:
  the Sorts of it = (the Sorts of U1) /\ (the Sorts of U2) &
  for B be MSSubset of U0 st B=the Sorts of it holds
  B is opers_closed & the Charact of it = Opers(U0,B);
  existence
  proof
    the Sorts of U1 is MSSubset of U0 & the Sorts of U2 is MSSubset of U0
    by Def10;
    then the Sorts of U1 c=the Sorts of U0 & the Sorts of U2 c=the Sorts of U0
    by PBOOLE:def 23;
    then (the Sorts of U1) /\ (the Sorts of U2)c=(the Sorts of U0)/\(the Sorts
    of U0) by PBOOLE:23;

then reconsider A = (the Sorts of U1) /\ (the Sorts of U2) as MSSubset of U0
    by PBOOLE:def 23;
    A is opers_closed
    proof
      let o be OperSymbol of S;
      reconsider u1 = the Sorts of U1, u2 = the Sorts of U2
      as MSSubset of U0 by Def10;
      u1 is opers_closed & u2 is opers_closed by Def10;
      then u1 is_closed_on o & u2 is_closed_on o by Def7;
      then
A1:   rng((Den(o,U0))|((u1#*the Arity of S).o))c=(u1*the ResultSort of S).o &
      rng ((Den(o,U0))|((u2# * the Arity of S).o))c= (u2*the ResultSort of S).o
      by Def6;
A2:   the OperSymbols of S <> {} by MSUALG_1:def 5;
A3:   dom (A# * the Arity of S) = the OperSymbols of S &
      dom (u1 # * the Arity of S) = the OperSymbols of S &
      dom (u2 # * the Arity of S) = the OperSymbols of S by PBOOLE:def 3;
      then
A4:   (A# * the Arity of S).o =
      (A# qua ManySortedSet of (the carrier of S)*).((the Arity of S).o)
      by A2,FUNCT_1:22
        .= (A# qua ManySortedSet of (the carrier of S)*).(the_arity_of o)
      by MSUALG_1:def 6
        .= product ((u1 /\ u2) * (the_arity_of o)) by PBOOLE:def 19

.= product(u1 *(the_arity_of o)) /\ product(u2 *(the_arity_of o)) by Th2
        .= (u1 # qua ManySortedSet of (the carrier of S)*).(the_arity_of o) /\
      product(u2 *(the_arity_of o)) by PBOOLE:def 19
        .= (u1 # qua ManySortedSet of (the carrier of S)*).(the_arity_of o) /\
      (u2 # qua ManySortedSet of (the carrier of S)*).(the_arity_of o)
      by PBOOLE:def 19
        .= (u1 # qua ManySortedSet of (the carrier of S)*).((the Arity of S).o)
      /\ (u2 # qua ManySortedSet of (the carrier of S)*).(the_arity_of o)
      by MSUALG_1:def 6
        .= (u1 # qua ManySortedSet of (the carrier of S)*).((the Arity of S).o)
      /\ (u2 # qua ManySortedSet of (the carrier of S)*).((the Arity of S).o)
      by MSUALG_1:def 6
        .= (u1# *(the Arity of S)).o /\
      (u2 # qua ManySortedSet of (the carrier of S)*).((the Arity of S).o)
      by A2,A3,FUNCT_1:22
        .= (u1# *(the Arity of S)).o /\ (u2# *(the Arity of S)).o
      by A2,A3,FUNCT_1:22;
      then Den(o,U0)|((A# * the Arity of S).o) =
      ( (Den(o,U0)) | ((u1# *(the Arity of S)) .o)) |
      ( (u2# *(the Arity of S)) . o) by RELAT_1:100;
      then rng ( (Den(o,U0)) | ((A# *(the Arity of S)).o)) c=
      rng (Den(o,U0)| ((u1# *(the Arity of S)).o)) by RELAT_1:99;
      then
A5:   rng ((Den(o,U0))|((A# *(the Arity of S)).o)) c=
      (u1*the ResultSort of S).o by A1,XBOOLE_1:1;
      Den(o,U0)|((A# * the Arity of S).o) =
      ((Den(o,U0))| ((u2# *(the Arity of S)).o))|((u1# *(the Arity of S)).o)
      by A4,RELAT_1:100;
      then rng ((Den(o,U0))|((A# *(the Arity of S)).o)) c=
      rng (Den(o,U0)| ((u2# *(the Arity of S)).o)) by RELAT_1:99;

then rng ((Den(o,U0))|((A# *(the Arity of S)).o)) c= (u2*the ResultSort of
      S).o by A1,XBOOLE_1:1;
      then
A6:   rng ((Den(o,U0))|((A# *(the Arity of S)).o)) c=
      ((u1*the ResultSort of S).o)/\((u2*the ResultSort of S).o) by A5,
      XBOOLE_1:19;
A7:   dom (u1 * the ResultSort of S) = the OperSymbols of S &
      dom (A * the ResultSort of S) = the OperSymbols of S &
      dom (u2 * the ResultSort of S)=the OperSymbols of S by PBOOLE:def 3;
      then ((u1*the ResultSort of S).o)/\((u2*the ResultSort of S).o) =
      u1.((the ResultSort of S).o)/\
      ((u2*the ResultSort of S).o) by A2,FUNCT_1:22
        .= u1.((the ResultSort of S).o)/\ u2.((the ResultSort of S).o)
      by A2,A7,FUNCT_1:22
        .= u1.(the_result_sort_of o) /\ u2.((the ResultSort of S).o)
      by MSUALG_1:def 7
        .= u1.(the_result_sort_of o) /\
      u2.(the_result_sort_of o) by MSUALG_1:def 7
        .= A.(the_result_sort_of o) by PBOOLE:def 8
        .= A.((the ResultSort of S).o) by MSUALG_1:def 7
        .= (A*the ResultSort of S).o by A2,A7,FUNCT_1:22;
      hence thesis by A6,Def6;
    end;
    then
A8: U0|A=MSAlgebra (#A, Opers(U0,A) qua ManySortedFunction of
      (A# * the Arity of S),(A * the ResultSort of S)#) by Def16;
    reconsider E = U0|A as strict MSSubAlgebra of U0;
    take E;
    thus the Sorts of E = (the Sorts of U1) /\ (the Sorts of U2) by A8;
    thus thesis by Def10;
  end;
  uniqueness by Th10;
end;

definition
  let S be non void non empty ManySortedSign, U0 be MSAlgebra over S,
  A be MSSubset of U0;
  func GenMSAlg(A) -> strict MSSubAlgebra of U0 means
  :Def18:
  A is MSSubset of it &
  for U1 be MSSubAlgebra of U0 st A is MSSubset of U1 holds
  it is MSSubAlgebra of U1;
  existence
  proof
    set a = MSSubSort(A);
A1: a is opers_closed & A c= a by Th21;
    reconsider u1 = U0|a as strict MSSubAlgebra of U0;
    take u1;
A2: u1 = MSAlgebra (# a, Opers(U0,a)qua ManySortedFunction of
      (a# * the Arity of S),(a * the ResultSort of S)#) by A1,Def16;
    hence A is MSSubset of u1 by A1,PBOOLE:def 23;
    let U2 be MSSubAlgebra of U0;
    reconsider B = the Sorts of U2 as MSSubset of U0 by Def10;
A3: B is opers_closed by Def10;
    assume A is MSSubset of U2;
    then
A4: A c= B by PBOOLE:def 23;
    Constants(U0) is MSSubset of U2 by Th11;
    then Constants(U0) c= B by PBOOLE:def 23;
    then
A5: B in SubSort(A) by A3,A4,Th14;
    the Sorts of u1 c= the Sorts of U2
    proof
      let i be set;
      assume i in the carrier of S;
      then reconsider s = i as SortSymbol of S;
A6:   (the Sorts of u1).s = meet SubSort(A,s) by A2,Def15;
      B.s in SubSort(A,s) by A5,Def14;
      hence thesis by A6,SETFAM_1:4;
    end;
    hence u1 is MSSubAlgebra of U2 by Th9;
  end;
  uniqueness
  proof
    let W1,W2 be strict MSSubAlgebra of U0;
    assume A is MSSubset of W1 &
    (for U1 be MSSubAlgebra of U0 st A is MSSubset of U1 holds
    W1 is MSSubAlgebra of U1) & A is MSSubset of W2 &
    (for U2 be MSSubAlgebra of U0 st A is MSSubset of U2 holds
    W2 is MSSubAlgebra of U2);
    then W1 is strict MSSubAlgebra of W2 & W2 is strict MSSubAlgebra of W1;
    hence thesis by Th8;
  end;
end;

registration
  let S be non void non empty ManySortedSign,
  U0 be non-empty MSAlgebra over S, A be non-empty MSSubset of U0;
  cluster GenMSAlg(A) -> non-empty;
  coherence
  proof Constants(U0) \/ A is non-empty;
    then reconsider a = MSSubSort(A) as non-empty MSSubset of U0 by Th17;
A1: a is opers_closed & A c= a by Th21;
    then U0|a = MSAlgebra (#a, Opers(U0,a) qua ManySortedFunction of
      (a# * the Arity of S),(a * the ResultSort of S)#) by Def16;
    then reconsider u1 = U0|a as strict non-empty MSSubAlgebra of U0
    by MSUALG_1:def 8;
    now
A2:   u1 = MSAlgebra (# a, Opers(U0,a)qua ManySortedFunction of
        (a# * the Arity of S),(a * the ResultSort of S)#) by A1,Def16;
      hence A is MSSubset of u1 by A1,PBOOLE:def 23;
      let U2 be MSSubAlgebra of U0;
      reconsider B = the Sorts of U2 as MSSubset of U0 by Def10;
A3:   B is opers_closed by Def10;
      assume A is MSSubset of U2;
      then
A4:   A c= B by PBOOLE:def 23;
      Constants(U0) is MSSubset of U2 by Th11;
      then Constants(U0) c= B by PBOOLE:def 23;
      then
A5:   B in SubSort(A) by A3,A4,Th14;
      the Sorts of u1 c= the Sorts of U2
      proof
        let i be set;
        assume i in the carrier of S;
        then reconsider s = i as SortSymbol of S;
A6:     (the Sorts of u1).s = meet SubSort(A,s) by A2,Def15;
        B.s in SubSort(A,s) by A5,Def14;
        hence thesis by A6,SETFAM_1:4;
      end;
      hence u1 is MSSubAlgebra of U2 by Th9;
    end;
    hence thesis by Def18;
  end;
end;

theorem Th22:
  for S be non void non empty ManySortedSign,
  U0 be strict MSAlgebra over S, B be MSSubset of U0 st B = the Sorts of U0
  holds GenMSAlg(B) = U0
proof
  let S be non void non empty ManySortedSign, U0 be strict MSAlgebra over S,
  B be MSSubset of U0;
  assume
A1: B = the Sorts of U0;
  set W = GenMSAlg(B);
  (the Sorts of W) is MSSubset of U0 by Def10;
  then
A2: the Sorts of W c= the Sorts of U0 by PBOOLE:def 23;
  the Sorts of U0 is MSSubset of W by A1,Def18;
  then the Sorts of U0 c= the Sorts of W by PBOOLE:def 23;
  then
A3: the Sorts of U0 = the Sorts of W by A2,PBOOLE:def 13;
  reconsider B1 = the Sorts of W as MSSubset of U0 by Def10;
  B1 is opers_closed & the Charact of W = Opers(U0,B1) by Def10;
  hence thesis by A3,Th5;
end;

theorem Th23:
  for S be non void non empty ManySortedSign, U0 be MSAlgebra over S,
  U1 be strict MSSubAlgebra of U0,
  B be MSSubset of U0 st B = the Sorts of U1 holds GenMSAlg(B) = U1
proof
  let S be non void non empty ManySortedSign, U0 be MSAlgebra over S,
  U1 be strict MSSubAlgebra of U0, B be MSSubset of U0;
  assume
A1: B = the Sorts of U1;
  then
A2: B is MSSubset of U1 by PBOOLE:def 23;
  set W = GenMSAlg(B);
A3: W is strict MSSubAlgebra of U1 by A2,Def18;
  B is MSSubset of W by Def18;
  then the Sorts of U1 c= the Sorts of W by A1,PBOOLE:def 23;
  then U1 is strict MSSubAlgebra of W by Th9;
  hence thesis by A3,Th8;
end;

theorem Th24:
  for S be non void non empty ManySortedSign,
  U0 be non-empty MSAlgebra over S, U1 be MSSubAlgebra of U0 holds
  GenMSAlg(Constants(U0)) /\ U1 = GenMSAlg(Constants(U0))
proof
  let S be non void non empty ManySortedSign,
  U0 be non-empty MSAlgebra over S, U1 be MSSubAlgebra of U0;
  set C = Constants(U0), G = GenMSAlg(C);
A1: the Sorts of (G /\ U1) = (the Sorts of G) /\ (the Sorts of U1) by Def17;
  C is MSSubset of U1 by Th11;
  then G is strict MSSubAlgebra of U1 by Def18;
  then the Sorts of G is MSSubset of U1 by Def10;
  then the Sorts of G c= the Sorts of U1 by PBOOLE:def 23;
  then the Sorts of (G /\ U1) = the Sorts of G by A1,PBOOLE:25;
  hence thesis by Th10;
end;

definition
  let S be non void non empty ManySortedSign,
  U0 be non-empty MSAlgebra over S, U1,U2 be MSSubAlgebra of U0;
  func U1 "\/" U2 -> strict MSSubAlgebra of U0 means
  :Def19:
  for A be MSSubset of U0 st
  A = (the Sorts of U1) \/ (the Sorts of U2) holds it = GenMSAlg(A);
  existence
  proof
    set B=(the Sorts of U1) \/ (the Sorts of U2);
    the Sorts of U1 is MSSubset of U0 &
    the Sorts of U2 is MSSubset of U0 by Def10;
    then the Sorts of U1 c=the Sorts of U0 &
    the Sorts of U2 c=the Sorts of U0 by PBOOLE:def 23;
    then B c= the Sorts of U0 by PBOOLE:18;
    then reconsider B as MSSubset of U0 by PBOOLE:def 23;
    take GenMSAlg(B);
    thus thesis;
  end;
  uniqueness
  proof
    let W1,W2 be strict MSSubAlgebra of U0;
    assume
A1: (for A be MSSubset of U0 st
    A = (the Sorts of U1) \/ (the Sorts of U2) holds W1 = GenMSAlg(A)) &
    ( for A be MSSubset of U0 st
    A = (the Sorts of U1) \/ (the Sorts of U2) holds W2 = GenMSAlg(A));
    set B=(the Sorts of U1) \/ (the Sorts of U2);
    the Sorts of U1 is MSSubset of U0 &
    the Sorts of U2 is MSSubset of U0 by Def10;
    then the Sorts of U1 c=the Sorts of U0 &
    the Sorts of U2 c=the Sorts of U0 by PBOOLE:def 23;
    then B c= the Sorts of U0 by PBOOLE:18;
    then reconsider B as MSSubset of U0 by PBOOLE:def 23;
    W1 = GenMSAlg(B) & W2 = GenMSAlg(B) by A1;
    hence thesis;
  end;
end;

theorem Th25:
  for S be non void non empty ManySortedSign,U0 be non-empty MSAlgebra over S,
  U1 be MSSubAlgebra of U0, A,B be MSSubset of U0 st B = A \/ the Sorts of U1
  holds GenMSAlg(A) "\/" U1 = GenMSAlg(B)
proof
  let S be non void non empty ManySortedSign,
  U0 be non-empty MSAlgebra over S, U1 be MSSubAlgebra of U0,
  A,B be MSSubset of U0;
  assume
A1: B = A \/ the Sorts of U1;
  A is MSSubset of GenMSAlg(A) by Def18;
  then
A2: A c= the Sorts of GenMSAlg(A) by PBOOLE:def 23;
  reconsider u1 = the Sorts of U1, a = the Sorts of GenMSAlg(A)
  as MSSubset of U0 by Def10;
  a c= the Sorts of U0 & u1 c= the Sorts of U0 by PBOOLE:def 23;
  then a \/ u1 c= the Sorts of U0 by PBOOLE:18;
  then reconsider b=a \/ u1 as MSSubset of U0 by PBOOLE:def 23;
A3: (GenMSAlg(A) "\/" U1) = GenMSAlg(b) by Def19;
  then a \/ u1 is MSSubset of (GenMSAlg(A)"\/"U1) by Def18;
  then
A4: a \/ u1 c=the Sorts of (GenMSAlg(A)"\/"U1) by PBOOLE:def 23;
  A \/ u1 c= a \/ u1 by A2,PBOOLE:22;
  then B c=the Sorts of (GenMSAlg(A)"\/"U1) by A1,A4,PBOOLE:15;
  then B is MSSubset of (GenMSAlg(A)"\/"U1) by PBOOLE:def 23;
  then
A5: GenMSAlg(B) is strict MSSubAlgebra of (GenMSAlg(A)"\/"U1) by Def18;
  B is MSSubset of GenMSAlg(B) & u1 c= B & A c= B by A1,Def18,PBOOLE:16;
  then B c= the Sorts of GenMSAlg(B) & u1 c= B & A c= B by PBOOLE:def 23;
  then
A6: u1 c= the Sorts of GenMSAlg(B) & A c= the Sorts of GenMSAlg(B)
  by PBOOLE:15;
  then
A7: A c= (the Sorts of GenMSAlg(A)) /\ (the Sorts of GenMSAlg(B))
  by A2,PBOOLE:19;
A8: the Sorts of (GenMSAlg(A) /\ GenMSAlg(B)) = (the Sorts of GenMSAlg(A)) /\
  (the Sorts of GenMSAlg(B)) by Def17;
  then A is MSSubset of (GenMSAlg(A) /\ GenMSAlg(B)) by A7,PBOOLE:def 23;
  then GenMSAlg(A) is MSSubAlgebra of (GenMSAlg(A) /\ GenMSAlg(B)) by Def18;
  then a is MSSubset of (GenMSAlg(A) /\ GenMSAlg(B)) by Def10;
  then
A9: a c= (the Sorts of GenMSAlg(A)) /\ (the Sorts of GenMSAlg(B)) by A8,
  PBOOLE:def 23;
  (the Sorts of GenMSAlg(A)) /\ (the Sorts of GenMSAlg(B)) c= a by PBOOLE:17;
  then a= (the Sorts of GenMSAlg(A)) /\ (the Sorts of GenMSAlg(B))
  by A9,PBOOLE:def 13;
  then a c= the Sorts of GenMSAlg(B) by PBOOLE:17;
  then b c= the Sorts of GenMSAlg(B) by A6,PBOOLE:18;
  then b is MSSubset of GenMSAlg(B) by PBOOLE:def 23;
  then GenMSAlg(b) is strict MSSubAlgebra of GenMSAlg(B) by Def18;
  hence thesis by A3,A5,Th8;
end;

theorem Th26:
  for S be non void non empty ManySortedSign, U0 be non-empty MSAlgebra over S,
  U1 be MSSubAlgebra of U0, B be MSSubset of U0 st B = the Sorts of U0
  holds GenMSAlg(B) "\/" U1 = GenMSAlg(B)
proof
  let S be non void non empty ManySortedSign,
  U0 be non-empty MSAlgebra over S, U1 be MSSubAlgebra of U0,
  B be MSSubset of U0;
  assume
A1: B = the Sorts of U0;
  the Sorts of U1 is MSSubset of U0 by Def10;
  then the Sorts of U1 c= B by A1,PBOOLE:def 23;
  then B \/ the Sorts of U1 = B by PBOOLE:24;
  hence thesis by Th25;
end;

theorem Th27:
  for S be non void non empty ManySortedSign,U0 be non-empty MSAlgebra over S,
  U1,U2 be MSSubAlgebra of U0 holds U1 "\/" U2 = U2 "\/" U1
proof
  let S be non void non empty ManySortedSign,
  U0 be non-empty MSAlgebra over S, U1,U2 be MSSubAlgebra of U0;
  reconsider u1= the Sorts of U1, u2= the Sorts of U2
  as MSSubset of U0 by Def10;
  u1 c= the Sorts of U0 & u2 c= the Sorts of U0 by PBOOLE:def 23;
  then u1 \/ u2 c= the Sorts of U0 by PBOOLE:18;
  then reconsider A = u1 \/ u2 as MSSubset of U0 by PBOOLE:def 23;
  U1 "\/" U2 = GenMSAlg(A) by Def19;
  hence thesis by Def19;
end;

theorem Th28:
  for S be non void non empty ManySortedSign,
  U0 be non-empty MSAlgebra over S, U1,U2 be strict MSSubAlgebra of U0 holds
  U1 /\ (U1"\/"U2) = U1
proof
  let S be non void non empty ManySortedSign,
  U0 be non-empty MSAlgebra over S, U1,U2 be strict MSSubAlgebra of U0;

reconsider u1= the Sorts of U1,u2 =the Sorts of U2 as MSSubset of U0 by Def10;
  u1 c= the Sorts of U0 & u2 c= the Sorts of U0 by PBOOLE:def 23;
  then u1 \/ u2 c= the Sorts of U0 by PBOOLE:18;
  then reconsider A= u1 \/ u2 as MSSubset of U0 by PBOOLE:def 23;
  U1"\/"U2 = GenMSAlg(A) by Def19;
  then A is MSSubset of U1"\/"U2 by Def18;
  then
A1: A c= the Sorts of (U1 "\/" U2) by PBOOLE:def 23;
  the Sorts of U1 c= A by PBOOLE:16;
  then
A2: the Sorts of U1 c= the Sorts of (U1"\/"U2) by A1,PBOOLE:15;
A3: the Sorts of (U1 /\(U1"\/"U2))=(the Sorts of U1)/\(the Sorts of(U1"\/"U2))
  by Def17;
  then
A4: the Sorts of U1 c=the Sorts of (U1 /\(U1"\/"U2)) by A2,PBOOLE:19;
  the Sorts of (U1 /\(U1"\/"U2)) c= the Sorts of U1 by A3,PBOOLE:17;
  then
A5: the Sorts of (U1 /\(U1"\/"U2)) = the Sorts of U1 by A4,PBOOLE:def 13;
  reconsider u112=the Sorts of(U1 /\ (U1"\/"U2)) as MSSubset of U0 by Def10;
  u112 is opers_closed & the Charact of (U1/\(U1"\/"
  U2))=Opers(U0,u112) by Def17;
  hence thesis by A5,Def10;
end;

theorem Th29:
  for S be non void non empty ManySortedSign,
  U0 be non-empty MSAlgebra over S, U1,U2 be strict MSSubAlgebra of U0
  holds (U1 /\ U2)"\/"U2 = U2
proof
  let S be non void non empty ManySortedSign,
  U0 be non-empty MSAlgebra over S, U1,U2 be strict MSSubAlgebra of U0;
  reconsider u12= the Sorts of (U1 /\ U2), u2 = the Sorts of U2
  as MSSubset of U0 by Def10;
  u12 c= the Sorts of U0 & u2 c= the Sorts of U0 by PBOOLE:def 23;
  then u12 \/ u2 c= the Sorts of U0 by PBOOLE:18;
  then reconsider A=u12 \/ u2 as MSSubset of U0 by PBOOLE:def 23;
A1: (U1 /\ U2)"\/"U2=GenMSAlg(A) by Def19;
  u12 = (the Sorts of U1) /\ (the Sorts of U2) by Def17;
  then u12 c= u2 by PBOOLE:17;
  then A = u2 by PBOOLE:24;
  hence thesis by A1,Th23;
end;

begin

::
::  The Lattice of SubAlgebras of a Many Sorted Algebra.
::

definition
  let S be non void non empty ManySortedSign, U0 be MSAlgebra over S;
  func MSSub(U0) -> set means
  :Def20:
  for x holds x in it iff x is strict MSSubAlgebra of U0;
  existence
  proof
    reconsider X = {GenMSAlg(@A) where A is Element of SubSort(U0):
    not contradiction} as set;
    take X;
    let x;
    thus x in X implies x is strict MSSubAlgebra of U0
    proof
      assume x in X;
      then consider A be Element of SubSort(U0) such that
A1:   x = GenMSAlg(@A);
      thus thesis by A1;
    end;
    assume x is strict MSSubAlgebra of U0;
    then reconsider a = x as strict MSSubAlgebra of U0;
    reconsider A = the Sorts of a as MSSubset of U0 by Def10;
    A is opers_closed by Def10;
    then reconsider h = A as Element of SubSort(U0) by Th15;
    a = GenMSAlg(@h) by Th23;
    hence x in X;
  end;
  uniqueness
  proof
    defpred P[set] means $1 is strict MSSubAlgebra of U0;
    for X1,X2 being set st (for x being set holds x in X1 iff P[x]) &
    (for x being set holds x in X2 iff P[x]) holds X1 = X2 from
    XBOOLE_0:sch 3;
    hence thesis;
  end;
end;

registration
  let S be non void non empty ManySortedSign, U0 be MSAlgebra over S;
  cluster MSSub(U0) -> non empty;
  coherence
  proof
    consider x being strict MSSubAlgebra of U0;
    x in MSSub U0 by Def20;
    hence thesis;
  end;
end;

definition
  let S be non void non empty ManySortedSign,
  U0 be non-empty MSAlgebra over S;
  func MSAlg_join(U0) -> BinOp of (MSSub(U0)) means
  :Def21:
  for x,y be Element of MSSub(U0) holds
  for U1,U2 be strict MSSubAlgebra of U0 st x = U1 & y = U2 holds
  it.(x,y) = U1 "\/" U2;
  existence
  proof
    defpred P[(Element of MSSub(U0)),(Element of MSSub(U0)),
    Element of MSSub(U0)] means
    for U1,U2 be strict MSSubAlgebra of U0 st $1=U1 & $2=U2
    holds $3=U1 "\/" U2;
A1: for x,y being Element of MSSub(U0)
    ex z being Element of MSSub(U0) st P[x,y,z]
    proof
      let x,y be Element of MSSub(U0);
      reconsider U1=x, U2=y as strict MSSubAlgebra of U0 by Def20;
      reconsider z =U1"\/"U2 as Element of MSSub(U0) by Def20;
      take z;
      thus thesis;
    end;
    consider o be BinOp of MSSub(U0) such that
A2: for a,b be Element of MSSub(U0) holds P[a,b,o.(a,b)] from BINOP_1:sch 3
    (A1);
    take o;
    thus thesis by A2;
  end;
  uniqueness
  proof
    let o1,o2 be BinOp of (MSSub(U0));
    assume
A3: (for x,y be Element of MSSub(U0) holds
    for U1,U2 be strict MSSubAlgebra of U0 st x=U1 & y=U2
    holds o1.(x,y)=U1 "\/" U2) & (for x,y be Element of MSSub(U0) holds
    for U1,U2 be strict MSSubAlgebra of U0 st x=U1 & y=U2 holds
    o2.(x,y) = U1 "\/" U2);
    for x be Element of MSSub(U0) for y be Element of MSSub(U0) holds
    o1.(x,y) = o2.(x,y)
    proof
      let x,y be Element of MSSub(U0);
      reconsider U1=x,U2=y as strict MSSubAlgebra of U0 by Def20;
      o1.(x,y) = U1"\/" U2 & o2.(x,y) = U1"\/" U2 by A3;
      hence thesis;
    end;
    hence thesis by BINOP_1:2;
  end;
end;

definition
  let S be non void non empty ManySortedSign,
  U0 be non-empty MSAlgebra over S;
  func MSAlg_meet(U0) -> BinOp of (MSSub(U0)) means
  :Def22:
  for x,y be Element of MSSub(U0) holds
  for U1,U2 be strict MSSubAlgebra of U0 st x = U1 & y = U2 holds
  it.(x,y) = U1 /\ U2;
  existence
  proof
    defpred P[(Element of MSSub(U0)),(Element of MSSub(U0)),
    Element of MSSub(U0)] means
    for U1,U2 be strict MSSubAlgebra of U0 st $1=U1 & $2=U2 holds $3=U1 /\ U2;
A1: for x,y being Element of MSSub(U0)
    ex z being Element of MSSub(U0) st P[x,y,z]
    proof
      let x,y be Element of MSSub(U0);
      reconsider U1=x, U2=y as strict MSSubAlgebra of U0 by Def20;
      reconsider z =U1 /\ U2 as Element of MSSub(U0) by Def20;
      take z;
      thus thesis;
    end;
    consider o be BinOp of MSSub(U0) such that
A2: for a,b be Element of MSSub(U0) holds P[a,b,o.(a,b)] from BINOP_1:sch 3
    (A1);
    take o;
    thus thesis by A2;
  end;
  uniqueness
  proof
    let o1,o2 be BinOp of MSSub(U0);
    assume
A3: (for x,y be Element of MSSub(U0) holds
    for U1,U2 be strict MSSubAlgebra of U0 st x=U1 & y=U2
    holds o1.(x,y)=U1 /\ U2) & (for x,y be Element of MSSub(U0) holds
    for U1,U2 be strict MSSubAlgebra of U0 st x=U1 & y=U2 holds
    o2.(x,y) = U1 /\ U2);
    for x be Element of MSSub(U0) for y be Element of MSSub(U0) holds
    o1.(x,y) = o2.(x,y)
    proof
      let x,y be Element of MSSub(U0);
      reconsider U1=x,U2=y as strict MSSubAlgebra of U0 by Def20;
      o1.(x,y) = U1 /\ U2 & o2.(x,y) = U1 /\ U2 by A3;
      hence thesis;
    end;
    hence thesis by BINOP_1:2;
  end;
end;

reserve U0 for non-empty MSAlgebra over S;

theorem Th30:
  MSAlg_join(U0) is commutative
proof
  set o = MSAlg_join(U0);
  for x,y be Element of MSSub(U0) holds o.(x,y)=o.(y,x)
  proof
    let x,y be Element of MSSub(U0);
    reconsider U1=x,U2=y as strict MSSubAlgebra of U0 by Def20;
A1: o.(x,y) = U1 "\/" U2 & o.(y,x) = U2 "\/" U1 by Def21;
    set B=(the Sorts of U1) \/ (the Sorts of U2);
    the Sorts of U1 is MSSubset of U0 &
    the Sorts of U2 is MSSubset of U0 by Def10;
    then the Sorts of U1 c=the Sorts of U0 &
    the Sorts of U2 c=the Sorts of U0 by PBOOLE:def 23;
    then B c= the Sorts of U0 by PBOOLE:18;
    then reconsider B as MSSubset of U0 by PBOOLE:def 23;
    U1"\/" U2 = GenMSAlg(B) & U2"\/"U1 = GenMSAlg(B) by Def19;
    hence thesis by A1;
  end;
  hence thesis by BINOP_1:def 2;
end;

theorem Th31:
  MSAlg_join(U0) is associative
proof
  set o = MSAlg_join(U0);
  for x,y,z be Element of MSSub(U0) holds o.(x,o.(y,z))=o.(o.(x,y),z)
  proof
    let x,y,z be Element of MSSub(U0);
    reconsider U1=x,U2=y,U3=z as strict MSSubAlgebra of U0 by Def20;
    o.(y,z)=U2"\/"U3 & o.(x,y)=U1"\/"U2 by Def21;
    then
A1: o.(x,o.(y,z)) = U1 "\/" (U2"\/"U3) & o.(o.(x,y),z) = (U1"\/"U2) "\/"
    U3 by Def21;
    set B=(the Sorts of U1) \/ ((the Sorts of U2) \/ (the Sorts of U3));
    the Sorts of U1 is MSSubset of U0 & the Sorts of U2 is MSSubset of U0 &
    the Sorts of U3 is MSSubset of U0 by Def10;
    then
A2: the Sorts of U1 c=the Sorts of U0 & the Sorts of U2 c=the Sorts of U0 &
    the Sorts of U3 c=the Sorts of U0 by PBOOLE:def 23;
    then
A3: (the Sorts of U2) \/ (the Sorts of U3) c= the Sorts of U0 by PBOOLE:18;
A4: (the Sorts of U1) \/ (the Sorts of U2) c= the Sorts of U0 by A2,PBOOLE:18;
    reconsider C =(the Sorts of U2) \/ (the Sorts of U3)
    as MSSubset of U0 by A3,PBOOLE:def 23;
    reconsider D=(the Sorts of U1) \/ (the Sorts of U2)
    as MSSubset of U0 by A4,PBOOLE:def 23;
    B c= the Sorts of U0 by A2,A3,PBOOLE:18;
    then reconsider B as MSSubset of U0 by PBOOLE:def 23;
A5: U1"\/" (U2"\/"U3) = U1 "\/"(GenMSAlg(C)) by Def19
      .=(GenMSAlg(C)) "\/" U1 by Th27
      .= GenMSAlg(B) by Th25;
A6: B= D \/ (the Sorts of U3) by PBOOLE:34;
    (U1"\/"U2)"\/"U3 = GenMSAlg(D)"\/" U3 by Def19
      .= GenMSAlg(B) by A6,Th25;
    hence thesis by A1,A5;
  end;
  hence thesis by BINOP_1:def 3;
end;

theorem Th32:
  for S be non void non empty ManySortedSign, U0 be non-empty MSAlgebra over S
  holds MSAlg_meet(U0) is commutative
proof
  let S be non void non empty ManySortedSign,
  U0 be non-empty MSAlgebra over S;
  set o = MSAlg_meet(U0);
  for x,y be Element of MSSub(U0) holds o.(x,y)=o.(y,x)
  proof
    let x,y be Element of MSSub(U0);
    reconsider U1=x,U2=y as strict MSSubAlgebra of U0 by Def20;
A1: o.(x,y) = U1 /\ U2 & o.(y,x) = U2 /\ U1 by Def22;
    the Sorts of(U2 /\ U1) = (the Sorts of U2) /\ (the Sorts of U1) &
    for B2 be MSSubset of U0 st B2=the Sorts of (U2/\U1) holds
    B2 is opers_closed & the Charact of (U2/\U1) = Opers(U0,B2) by Def17;
    hence thesis by A1,Def17;
  end;
  hence thesis by BINOP_1:def 2;
end;

theorem Th33:
  for S be non void non empty ManySortedSign, U0 be non-empty MSAlgebra over S
  holds MSAlg_meet(U0) is associative
proof
  let S be non void non empty ManySortedSign,
  U0 be non-empty MSAlgebra over S;
  set o = MSAlg_meet(U0);
  for x,y,z be Element of MSSub(U0) holds o.(x,o.(y,z))=o.(o.(x,y),z)
  proof
    let x,y,z be Element of MSSub(U0);
    reconsider U1=x,U2=y,U3=z as strict MSSubAlgebra of U0 by Def20;
    reconsider u23 = U2 /\ U3,u12 =U1 /\ U2 as Element of MSSub(U0) by Def20;
A1: o.(x,o.(y,z)) =o.(x,u23) by Def22
      .= U1/\(U2 /\ U3) by Def22;
A2: o.(o.(x,y),z) = o.(u12,z) by Def22
      .=(U1 /\ U2) /\ U3 by Def22;
A3: the Sorts of (U1/\U2)=(the Sorts of U1) /\ (the Sorts of U2) by Def17;
    the Sorts of(U2 /\ U3) = (the Sorts of U2) /\ (the Sorts of U3) by Def17;
    then
A4: the Sorts of (U1 /\ (U2 /\ U3))
    =(the Sorts of U1) /\ ((the Sorts of U2)/\(the Sorts of U3)) &
    (for B be MSSubset of U0 st B=the Sorts of (U1/\(U2/\U3)) holds
    B is opers_closed & the Charact of (U1/\(U2/\U3)) = Opers(U0,B)) by Def17;
    then reconsider C = (the Sorts of U1) /\ ((the Sorts of U2)/\(the Sorts of
    U3)) as MSSubset of U0 by Def10;
    C =((the Sorts of U1)/\(the Sorts of U2)) /\ (the Sorts of U3)
    by PBOOLE:35;
    hence thesis by A1,A2,A3,A4,Def17;
  end;
  hence thesis by BINOP_1:def 3;
end;

definition
  let S be non void non empty ManySortedSign,
  U0 be non-empty MSAlgebra over S;
  func MSSubAlLattice(U0) -> strict Lattice equals
  LattStr (# MSSub(U0), MSAlg_join(U0), MSAlg_meet(U0) #);
  coherence
  proof
    set L = LattStr (# MSSub(U0), MSAlg_join(U0), MSAlg_meet(U0) #);
A1: for a,b being Element of L holds a"\/"b = b"\/"a
    proof
      let a,b be Element of L;
      MSAlg_join(U0) is commutative by Th30;
      hence a"\/"b =b"\/"a by BINOP_1:def 2;
    end;
A2: for a,b,c being Element of L holds a"\/"(b"\/"c) = (a"\/"b)"\/"c
    proof
      let a,b,c be Element of L;
      MSAlg_join(U0) is associative by Th31;
      hence a"\/"(b"\/"c) =(a"\/"b)"\/"c by BINOP_1:def 3;
    end;
A3: for a,b being Element of L holds (a"/\"b)"\/"b = b
    proof
      let a,b be Element of L;
      reconsider x=a,y=b as Element of MSSub(U0);
      (MSAlg_join(U0)).((MSAlg_meet(U0)).(x,y),y)= y
      proof
        reconsider U1= x,U2=y as strict MSSubAlgebra of U0 by Def20;
        (MSAlg_meet(U0)).(x,y) = U1 /\ U2 by Def22;
        hence (MSAlg_join(U0)).((MSAlg_meet(U0)).(x,y),y)
        = ((U1 /\ U2)"\/"U2) by Def21
          .=y by Th29;
      end;
      hence (a"/\"b)"\/"b = b;
    end;
A4: for a,b being Element of L holds a"/\"b = b"/\"a
    proof
      let a,b be Element of L;
      MSAlg_meet(U0) is commutative by Th32;
      hence a"/\"b =b"/\"a by BINOP_1:def 2;
    end;
A5: for a,b,c being Element of L holds a"/\"(b"/\"c) = (a"/\"b)"/\"c
    proof
      let a,b,c be Element of L;
      MSAlg_meet(U0) is associative by Th33;
      hence a"/\"(b"/\"c) =(a"/\"b)"/\"c by BINOP_1:def 3;
    end;
    for a,b being Element of L holds a"/\"(a"\/"b)=a
    proof
      let a,b be Element of L;
      reconsider x=a,y=b as Element of MSSub(U0);
      (MSAlg_meet(U0)).(x,(MSAlg_join(U0)).(x,y))= x
      proof
        reconsider U1= x,U2=y as strict MSSubAlgebra of U0 by Def20;
        (MSAlg_join(U0)).(x,y) = U1"\/"U2 by Def21;
        hence (MSAlg_meet(U0)).(x,(MSAlg_join(U0)).(x,y))
        = (U1 /\( U1"\/"U2)) by Def22
          .=x by Th28;
      end;
      hence a"/\"(a"\/"b) = a;
    end;
    then L is strict join-commutative join-associative meet-absorbing
    meet-commutative meet-associative join-absorbing
    by A1,A2,A3,A4,A5,LATTICES:def 4,def 5,def 6,def 7,def 8,def 9;
    hence L is strict Lattice;
  end;
end;

theorem Th34:
  for S be non void non empty ManySortedSign, U0 be non-empty MSAlgebra over S
  holds MSSubAlLattice(U0) is bounded
proof
  let S be non void non empty ManySortedSign,
  U0 be non-empty MSAlgebra over S;
  set L = MSSubAlLattice(U0);
  thus L is lower-bounded
  proof
    set C = Constants(U0);
    reconsider G = GenMSAlg(C) as Element of MSSub(U0) by Def20;
    reconsider G1 = G as Element of L;
    take G1;
    let a be Element of L;
    reconsider a1 = a as Element of MSSub(U0);
    reconsider a2 = a1 as strict MSSubAlgebra of U0 by Def20;
    thus G1 "/\" a = GenMSAlg(C) /\ a2 by Def22
      .= G1 by Th24;
    hence thesis;
  end;
  thus L is upper-bounded
  proof
    reconsider B = the Sorts of U0 as MSSubset of U0 by PBOOLE:def 23;
    reconsider G = GenMSAlg(B) as Element of MSSub(U0) by Def20;
    reconsider G1 = G as Element of L;
    take G1;
    let a be Element of L;
    reconsider a1 = a as Element of MSSub(U0);
    reconsider a2 = a1 as strict MSSubAlgebra of U0 by Def20;
    thus G1"\/"a = GenMSAlg(B)"\/"a2 by Def21
      .= G1 by Th26;
    hence thesis;
  end;
end;

registration
  let S be non void non empty ManySortedSign,
  U0 be non-empty MSAlgebra over S;
  cluster MSSubAlLattice(U0) -> bounded;
  coherence by Th34;
end;

theorem
  for S be non void non empty ManySortedSign, U0 be non-empty MSAlgebra over S
  holds Bottom (MSSubAlLattice(U0)) = GenMSAlg(Constants(U0))
proof
  let S be non void non empty ManySortedSign,
  U0 be non-empty MSAlgebra over S;
  set L = MSSubAlLattice(U0);
  set C = Constants(U0);
  reconsider G = GenMSAlg(C) as Element of MSSub(U0) by Def20;
  reconsider G1 = G as Element of L;
  now
    let a be Element of L;
    reconsider a1 = a as Element of MSSub(U0);
    reconsider a2 = a1 as strict MSSubAlgebra of U0 by Def20;
    thus G1 "/\" a = GenMSAlg(C) /\ a2 by Def22
      .= G1 by Th24;
    hence a "/\" G1 = G1;
  end;
  hence thesis by LATTICES:def 16;
end;

theorem Th36:
  for S be non void non empty ManySortedSign,
  U0 be non-empty MSAlgebra over S,
  B be MSSubset of U0 st B = the Sorts of U0 holds
  Top (MSSubAlLattice(U0)) = GenMSAlg(B)
proof
  let S be non void non empty ManySortedSign,
  U0 be non-empty MSAlgebra over S, B be MSSubset of U0;
  assume
A1: B = the Sorts of U0;
  set L = MSSubAlLattice(U0);
  reconsider G = GenMSAlg(B) as Element of MSSub(U0) by Def20;
  reconsider G1 = G as Element of L;
  now
    let a be Element of L;
    reconsider a1 = a as Element of MSSub(U0);
    reconsider a2 = a1 as strict MSSubAlgebra of U0 by Def20;
    thus G1"\/"a = GenMSAlg(B)"\/"a2 by Def21
      .= G1 by A1,Th26;
    hence a "\/" G1 = G1;
  end;
  hence thesis by LATTICES:def 17;
end;

theorem
  for S be non void non empty ManySortedSign,
  U0 be strict non-empty MSAlgebra over S holds Top (MSSubAlLattice(U0)) = U0
proof
  let S be non void non empty ManySortedSign,
  U0 be strict non-empty MSAlgebra over S;
  reconsider B = the Sorts of U0 as MSSubset of U0 by PBOOLE:def 23;
  thus Top (MSSubAlLattice(U0)) = GenMSAlg(B) by Th36
    .= U0 by Th22;
end;

theorem
  for S being non void non empty ManySortedSign,
  U0 being MSAlgebra over S holds
  MSAlgebra (#the Sorts of U0,the Charact of U0#) is MSSubAlgebra of U0
  by Lm1;

canceled;

theorem
  for S being non void non empty ManySortedSign, U0 being MSAlgebra over S,
  A being MSSubset of U0 holds the Sorts of U0 in SubSort(A) by Lm2;

theorem
  for S being non void non empty ManySortedSign, U0 being MSAlgebra over S,
  A being MSSubset of U0 holds SubSort(A) c= SubSort(U0)
proof
  let S be non void non empty ManySortedSign, U0 be MSAlgebra over S,
  A be MSSubset of U0;
  let x be set such that
A1: x in SubSort(A);
A2: x in Funcs(the carrier of S, bool (Union (the Sorts of U0))) &
  x is MSSubset of U0 & for B be MSSubset of U0 st
  B = x holds B is opers_closed & Constants(U0) c= B & A c= B by A1,Def11;
  for B be MSSubset of U0 st B = x holds B is opers_closed by A1,Def11;
  hence x in SubSort(U0) by A2,Def12;
end;

