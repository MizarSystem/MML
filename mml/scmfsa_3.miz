:: Computation in { \bf SCM_FSA }
::  by Andrzej Trybulec and Yatsuka Nakamura
::
:: Received February 7, 1996
:: Copyright (c) 1996 Association of Mizar Users

environ

 vocabularies SCMFSA_2, AMI_1, INT_1, AMI_3, RELAT_1, FUNCT_4, FUNCOP_1, AMI_2,
      BOOLE, FUNCT_1, AMI_5, ABSVALUE, FINSEQ_1, FINSEQ_2, CARD_3, CAT_1,
      ARYTM_1, NAT_1, FINSEQ_4, ARYTM, SCMNORM, ZF_REFLE;
 notations TARSKI, XBOOLE_0, SUBSET_1, NUMBERS, XCMPLX_0, INT_2,
      RELAT_1, FUNCT_1, PARTFUN1, FUNCT_4, INT_1, NAT_1, DOMAIN_1, STRUCT_0,
      FUNCOP_1, FINSEQ_1, FINSEQ_2, CARD_3,
      SCMNORM, AMI_1, AMI_2, AMI_3, FUNCT_7,
      SCMFSA_2, XXREAL_0;
 constructors PARTFUN1, DOMAIN_1, XXREAL_0, NAT_1, INT_2, AMI_5, SCMFSA_2,
      SCMNORM;
 registrations XBOOLE_0, SETFAM_1, RELAT_1, FUNCT_1, FRAENKEL, NUMBERS,
      XREAL_0, INT_1, FINSEQ_1, CARD_3, STRUCT_0, AMI_1, AMI_3, AMI_5,
      SCMFSA_2, FINSET_1, ORDINAL1, SCMNORM, CARD_1;
 requirements NUMERALS, REAL, SUBSET, BOOLE, ARITHM;
 definitions AMI_1, AMI_3, FUNCOP_1, SCMFSA_2, SCMNORM;
 theorems AMI_1, AMI_3, GRFUNC_1, NAT_1, FUNCOP_1, TARSKI, FUNCT_4, FUNCT_1,
      FINSET_1, ZFMISC_1, INT_1, RELAT_1, AMI_5, SCMFSA_2, SCMFSA_1, ABSVALUE,
      FINSEQ_2, XBOOLE_0, XBOOLE_1, CARD_3, AMI_2, ORDINAL1;

begin

reserve k for Element of NAT,
  da,db for Int-Location,
  fa for FinSeq-Location;

theorem
  not IC SCM+FSA in Int-Locations
proof
  assume IC SCM+FSA in Int-Locations;
  then IC SCM+FSA is Int-Location by SCMFSA_2:11;
  then ObjectKind IC SCM+FSA = INT by SCMFSA_2:26;
  hence contradiction by AMI_1:def 11,SCMFSA_1:13;
end;

theorem
  not IC SCM+FSA in FinSeq-Locations
proof
  assume IC SCM+FSA in FinSeq-Locations;
  then IC SCM+FSA is FinSeq-Location by SCMFSA_2:12;
  then ObjectKind IC SCM+FSA = INT* by SCMFSA_2:27;
  hence contradiction by AMI_1:def 11,SCMFSA_1:13;
end;

theorem
  for i being Instruction of SCM+FSA, I being Instruction of SCM st i = I
  for s being State of SCM+FSA, S being State of SCM st
  S = s|(the carrier of SCM) +* ((NAT) --> I)
  holds Exec(i,s) = s +*Exec(I,S) +* s|NAT by SCMFSA_2:75;

theorem Th4:
  for s1,s2 being State of SCM+FSA st
  (s1 | (Int-Locations \/ FinSeq-Locations \/ {IC SCM+FSA}))
  = (s2 | (Int-Locations \/ FinSeq-Locations \/ {IC SCM+FSA}))
  for l being Instruction of SCM+FSA holds
  Exec (l,s1) | (Int-Locations \/ FinSeq-Locations \/ {IC SCM+FSA})
  = Exec (l,s2) | (Int-Locations \/ FinSeq-Locations \/ {IC SCM+FSA})
proof
  let s1,s2 be State of SCM+FSA such that
A1: s1 | (Int-Locations \/ FinSeq-Locations \/ {IC SCM+FSA})
  = s2 | (Int-Locations \/ FinSeq-Locations \/ {IC SCM+FSA});
  let l be Instruction of SCM+FSA;
  IC SCM+FSA in {IC SCM+FSA} by TARSKI:def 1;
  then
A2: IC SCM+FSA in (Int-Locations \/ FinSeq-Locations \/
  {IC SCM+FSA}) by XBOOLE_0:def 2;
A3: Int-Locations \/ FinSeq-Locations \/ {IC SCM+FSA}
  c= the carrier of SCM+FSA;
  then (Int-Locations \/ FinSeq-Locations \/
  {IC SCM+FSA}) c= dom s1 by AMI_1:79;
  then
A4: IC SCM+FSA in
  dom (s1 | (Int-Locations \/ FinSeq-Locations \/ {IC SCM+FSA}))
  by A2,RELAT_1:91;
  (Int-Locations \/ FinSeq-Locations \/ {IC SCM+FSA}) c= dom s2
  by A3,AMI_1:79;
  then
A5: IC SCM+FSA in
  dom (s2 | (Int-Locations \/ FinSeq-Locations \/ {IC SCM+FSA}))
  by A2,RELAT_1:91;
A6: IC s1 = (s2 |
  (Int-Locations \/ FinSeq-Locations \/ {IC SCM+FSA})).IC SCM+FSA
  by A1,A4,FUNCT_1:70
    .= IC s2 by A5,FUNCT_1:70;
A7: dom Exec(l,s1) = the carrier of SCM+FSA by AMI_1:79;
A8: dom Exec(l,s2) = the carrier of SCM+FSA by AMI_1:79;
A9: dom Exec(l,s1) = dom Exec(l,s2) by A7,AMI_1:79;
A10: Int-Locations \/ FinSeq-Locations c= (Int-Locations \/ FinSeq-Locations \/
  {IC SCM+FSA}) by XBOOLE_1:7;
A11: InsCode l <= 11+1 by SCMFSA_2:35;
A12: InsCode l <= 10+1 implies InsCode l <= 10 or InsCode l = 11 by NAT_1:8;
A13: InsCode l <= 9+1 implies InsCode l <= 8+1 or InsCode l = 10 by NAT_1:8;
  per cases by A11,A12,A13,NAT_1:8;
  suppose InsCode l <= 8;
    then reconsider I = l as Instruction of SCM by SCMFSA_2:34;
    reconsider S1 = s1|(the carrier of SCM) +* ((NAT) --> I),
    S2 = s2|(the carrier of SCM) +* ((NAT) --> I)
    as State of SCM by SCMFSA_2:73;
A14: dom((NAT) --> I) = NAT by FUNCOP_1:19;
    now
      assume IC SCM in NAT;
      then reconsider l = IC SCM as Instruction-Location of SCM by AMI_1:def 4;
      l = IC SCM;
      hence contradiction by AMI_1:48;
    end;
    then NAT misses {IC SCM} by ZFMISC_1:56;
    then NAT misses SCM-Data-Loc \/ {IC SCM} by AMI_2:29,XBOOLE_1:70;
    then
A15: ((NAT) --> I)|(SCM-Data-Loc \/ {IC SCM}) = {} by A14,RELAT_1:95;
A16: SCM-Data-Loc c= Int-Locations \/ FinSeq-Locations by XBOOLE_1:7;
A17: S1 | (SCM-Data-Loc \/ {IC SCM})
    = s1|(the carrier of SCM) | (SCM-Data-Loc \/
    {IC SCM}) +* {} by A15,FUNCT_4:75
      .= s1|(the carrier of SCM) | (SCM-Data-Loc \/ {IC SCM}) by FUNCT_4:22
      .= s1|(SCM-Data-Loc \/ {IC SCM}) by AMI_5:23,RELAT_1:103,XBOOLE_1:7
      .= s1|(Int-Locations \/ FinSeq-Locations \/ {IC SCM+FSA})
    |(SCM-Data-Loc \/ {IC SCM}) by A16,AMI_3:4,RELAT_1:103,SCMFSA_2:7,
    XBOOLE_1:9

.= s2|(SCM-Data-Loc \/ {IC SCM}) by A1,A16,AMI_3:4,RELAT_1:103,SCMFSA_2:7,
    XBOOLE_1:9
      .= s2|(the carrier of SCM) | (SCM-Data-Loc \/ {IC SCM}) by AMI_5:23,
    RELAT_1:103,XBOOLE_1:7
      .= s2|(the carrier of SCM) | (SCM-Data-Loc \/
    {IC SCM}) +* {} by FUNCT_4:22
      .= S2 | (SCM-Data-Loc \/ {IC SCM}) by A15,FUNCT_4:75;
A18: (the carrier of SCM) /\ FinSeq-Locations = {} by SCMFSA_1:33,XBOOLE_0:def
    7;
    now
      assume IC SCM+FSA in NAT;
      then reconsider l = IC SCM+FSA as Instruction-Location of SCM+FSA
      by AMI_1:def 4;
      l = IC SCM+FSA;
      hence contradiction by AMI_1:48;
    end;
    then
A19: NAT misses {IC SCM+FSA} by ZFMISC_1:56;
    (NAT)
    misses Int-Locations \/ FinSeq-Locations by SCMFSA_2:13,14,XBOOLE_1:70;
    then NAT misses Int-Locations \/ FinSeq-Locations \/ {IC SCM+FSA}
    by A19,XBOOLE_1:70;
    then
A20: (NAT) /\ (Int-Locations \/ FinSeq-Locations \/ {IC SCM+FSA}) = {}
    by XBOOLE_0:def 7;
A21: s1|(NAT) | (Int-Locations \/ FinSeq-Locations \/ {IC SCM+FSA})
    = s1|((NAT) /\ (Int-Locations \/ FinSeq-Locations \/
    {IC SCM+FSA})) by RELAT_1:100
      .= {} by A20,RELAT_1:110;
    dom Exec(I,S1) /\ FinSeq-Locations = {} by A18,AMI_1:79;
    then dom Exec(I,S1) misses FinSeq-Locations by XBOOLE_0:def 7;
    then
A22: Exec(I,S1)|FinSeq-Locations = {} by RELAT_1:95;
A23: Exec(I,S1) | (Int-Locations \/ FinSeq-Locations \/ {IC SCM+FSA})
    = Exec(I,S1) | (Int-Locations \/ FinSeq-Locations)
           +* Exec(I,S1) |{IC SCM+FSA} by FUNCT_4:83
      .= DataPart Exec(I,S1) +* {} +* Exec(I,S1) |{IC SCM+FSA}
    by A22,FUNCT_4:83,AMI_3:72
      .= DataPart Exec(I,S1) +* Exec(I,S1) |{IC SCM+FSA} by FUNCT_4:22
      .= Exec(I,S1) | (SCM-Data-Loc \/ {IC SCM})
    by AMI_3:4,FUNCT_4:83,SCMFSA_2:7,AMI_3:72;
A24: s2|(NAT) | (Int-Locations \/ FinSeq-Locations \/ {IC SCM+FSA})
    = s2|((NAT) /\ (Int-Locations \/ FinSeq-Locations \/
    {IC SCM+FSA})) by RELAT_1:100
      .= {} by A20,RELAT_1:110;
    dom Exec(I,S2) /\ FinSeq-Locations = {} by A18,AMI_1:79;
    then dom Exec(I,S2) misses FinSeq-Locations by XBOOLE_0:def 7;
    then
A25: Exec(I,S2)|FinSeq-Locations = {} by RELAT_1:95;
A26: Exec(I,S2) | (Int-Locations \/ FinSeq-Locations \/ {IC SCM+FSA})
    = Exec(I,S2)|(Int-Locations \/ FinSeq-Locations)
          +* Exec(I,S2) |{IC SCM+FSA} by FUNCT_4:83
      .= DataPart Exec(I,S2) +* {} +* Exec(I,S2) |{IC SCM+FSA}
    by A25,FUNCT_4:83,AMI_3:72
      .= DataPart Exec(I,S2) +* Exec(I,S2) |{IC SCM+FSA} by FUNCT_4:22
      .= Exec(I,S2) | (SCM-Data-Loc \/ {IC SCM})
    by AMI_3:4,FUNCT_4:83,SCMFSA_2:7,AMI_3:72;
    thus Exec (l,s1) | (Int-Locations \/ FinSeq-Locations \/ {IC SCM+FSA})
    = (s1 +*Exec(I,S1) +* s1|NAT)
    | (Int-Locations \/ FinSeq-Locations \/ {IC SCM+FSA}) by SCMFSA_2:75
      .= (s1 +*Exec(I,S1))
    | (Int-Locations \/ FinSeq-Locations \/ {IC SCM+FSA})
    +* {} by A21,FUNCT_4:75
      .= (s1 +*Exec(I,S1))
    | (Int-Locations \/ FinSeq-Locations \/ {IC SCM+FSA}) by FUNCT_4:22
      .= (s1 | (Int-Locations \/ FinSeq-Locations \/ {IC SCM+FSA}))
    +* Exec(I,S1) | (SCM-Data-Loc \/ {IC SCM}) by A23,FUNCT_4:75
      .= (s2 | (Int-Locations \/ FinSeq-Locations \/ {IC SCM+FSA}))
    +* Exec(I,S2) | (SCM-Data-Loc \/ {IC SCM}) by A1,A17,AMI_5:58
      .= (s2 +*Exec(I,S2))
    | (Int-Locations \/ FinSeq-Locations \/ {IC SCM+FSA}) by A26,FUNCT_4:75
      .= (s2 +*Exec(I,S2))
    | (Int-Locations \/ FinSeq-Locations \/ {IC SCM+FSA}) +* {} by FUNCT_4:22
      .= (s2 +*Exec(I,S2) +* s2|NAT)
    | (Int-Locations \/ FinSeq-Locations \/ {IC SCM+FSA}) by A24,FUNCT_4:75
      .= Exec (l,s2) | (Int-Locations \/ FinSeq-Locations \/ {IC SCM+FSA})
    by SCMFSA_2:75;
  end;
  suppose InsCode l = 9;
    then consider da,db,fa such that
A27: l = db:=(fa,da) by SCMFSA_2:62;
    db in Int-Locations by SCMFSA_2:9;
    then db in Int-Locations \/ FinSeq-Locations by XBOOLE_0:def 2;
    then
A28: Int-Locations \/ FinSeq-Locations =
    Int-Locations \/ FinSeq-Locations \/ {db} by ZFMISC_1:46
      .= (Int-Locations \/ FinSeq-Locations \ {db} ) \/ {db} by XBOOLE_1:39;
A29: dom ((Exec (l,s1)) | (Int-Locations \/ FinSeq-Locations \ {db}))
    = (Int-Locations \/ FinSeq-Locations \ {db}) by A7,RELAT_1:91;
A30: dom ((Exec (l,s2)) | (Int-Locations \/ FinSeq-Locations \ {db}))
    = (Int-Locations \/ FinSeq-Locations \ {db}) by A8,RELAT_1:91;
    for x being set st x in ((Int-Locations \/ FinSeq-Locations) \ {db})
    holds (Exec (l,s1) | (Int-Locations \/ FinSeq-Locations \ {db})).x
    = (Exec (l,s2) | (Int-Locations \/ FinSeq-Locations \ {db})).x
    proof
      let x be set;
      assume
A31:  x in ((Int-Locations \/ FinSeq-Locations) \ {db});
      then
A32:  x in Int-Locations \/ FinSeq-Locations by XBOOLE_0:def 4;
A33:  not x in {db} by A31,XBOOLE_0:def 4;
      per cases by A32,XBOOLE_0:def 2;
      suppose x in Int-Locations;
        then reconsider a = x as Int-Location by SCMFSA_2:11;
A34:    a <> db by A33,TARSKI:def 1;
A35:    a in (Int-Locations \/ FinSeq-Locations \/ {IC SCM+FSA}) by A32,
        XBOOLE_0:def 2;
        thus (Exec (l,s1) | (Int-Locations \/ FinSeq-Locations \ {db})).x
        = (Exec (l,s1)).a by A31,FUNCT_1:72
          .= s1.a by A27,A34,SCMFSA_2:98
          .= (s1 | (Int-Locations \/ FinSeq-Locations \/ {IC SCM+FSA})).a
        by A35,FUNCT_1:72
          .= s2.a by A1,A35,FUNCT_1:72
          .= (Exec (l,s2)).a by A27,A34,SCMFSA_2:98
          .= (Exec (l,s2) | (Int-Locations \/ FinSeq-Locations \ {db})).x
        by A31,FUNCT_1:72;
      end;
      suppose x in FinSeq-Locations;
        then reconsider a = x as FinSeq-Location by SCMFSA_2:12;
A36:    a in (Int-Locations \/ FinSeq-Locations \/ {IC SCM+FSA}) by A32,
        XBOOLE_0:def 2;
        thus (Exec (l,s1) | (Int-Locations \/ FinSeq-Locations \ {db})).x
        = (Exec (l,s1)).a by A31,FUNCT_1:72
          .= s1.a by A27,SCMFSA_2:98
          .= (s1 | (Int-Locations \/ FinSeq-Locations \/ {IC SCM+FSA})).a
        by A36,FUNCT_1:72
          .= s2.a by A1,A36,FUNCT_1:72
          .= (Exec (l,s2)).a by A27,SCMFSA_2:98
          .= (Exec (l,s2) | (Int-Locations \/ FinSeq-Locations \ {db})).x
        by A31,FUNCT_1:72;
      end;
    end;
    then
A37: Exec (l,s1) | (Int-Locations \/ FinSeq-Locations \ {db} )
    = Exec (l,s2) | (Int-Locations \/ FinSeq-Locations \ {db} )
    by A29,A30,FUNCT_1:9;
    da in Int-Locations by SCMFSA_2:9;
    then
A38: da in Int-Locations \/ FinSeq-Locations by XBOOLE_0:def 2;
    consider k1 being Element of NAT such that
A39: k1 = abs(s1.da) and
A40: Exec(l, s1).db = (s1.fa)/.k1 by A27,SCMFSA_2:98;
    consider k2 being Element of NAT such that
A41: k2 = abs(s2.da) and
A42: Exec(l, s2).db = (s2.fa)/.k2 by A27,SCMFSA_2:98;
A43: s1.da = (s1 | (Int-Locations \/ FinSeq-Locations \/ {IC SCM+FSA})).da
    by A10,A38,FUNCT_1:72
      .= s2.da by A1,A10,A38,FUNCT_1:72;
    fa in FinSeq-Locations by SCMFSA_2:10;
    then fa in Int-Locations \/ FinSeq-Locations by XBOOLE_0:def 2;
    then
A44: fa in (Int-Locations \/ FinSeq-Locations \/ {IC SCM+FSA}) by
    XBOOLE_0:def 2;
    then s1.fa = (s1 | (Int-Locations \/ FinSeq-Locations \/ {IC SCM+FSA})).fa
    by FUNCT_1:72
      .= s2.fa by A1,A44,FUNCT_1:72;
    then Exec (l,s1) | {db} = Exec(l,s2) | {db}
    by A9,A39,A40,A41,A42,A43,GRFUNC_1:90;
    then
A45: DataPart Exec (l,s1) = DataPart Exec (l,s2)
              by A28,A37,RELAT_1:185,SCMFSA_2:127;
    Exec (l,s1).IC SCM+FSA = Next IC s1 by A27,SCMFSA_2:98
      .= Exec (l,s2).IC SCM+FSA by A6,A27,SCMFSA_2:98;
    then Exec (l,s1) | {IC SCM+FSA} = Exec (l,s2) | {IC SCM+FSA} by A7,A8,
    GRFUNC_1:90;
    hence Exec (l,s1) | (Int-Locations \/ FinSeq-Locations \/ {IC SCM+FSA})
    = Exec (l,s2) | (Int-Locations \/ FinSeq-Locations \/ {IC SCM+FSA})
    by A45,RELAT_1:185,SCMFSA_2:127;
  end;
  suppose InsCode l = 10;
    then consider da,db,fa such that
A46: l = (fa,da):=db by SCMFSA_2:63;
    fa in FinSeq-Locations by SCMFSA_2:10;
    then fa in Int-Locations \/ FinSeq-Locations by XBOOLE_0:def 2;
    then
A47: Int-Locations \/ FinSeq-Locations =
    Int-Locations \/ FinSeq-Locations \/ {fa} by ZFMISC_1:46
      .= (Int-Locations \/ FinSeq-Locations \ {fa} ) \/ {fa} by XBOOLE_1:39;
A48: dom ((Exec (l,s1)) | (Int-Locations \/ FinSeq-Locations \ {fa}))
    = (Int-Locations \/ FinSeq-Locations \ {fa}) by A7,RELAT_1:91;
A49: dom ((Exec (l,s2)) | (Int-Locations \/ FinSeq-Locations \ {fa}))
    = (Int-Locations \/ FinSeq-Locations \ {fa}) by A8,RELAT_1:91;
    for x being set st x in ((Int-Locations \/ FinSeq-Locations) \ {fa})
    holds (Exec (l,s1) | (Int-Locations \/ FinSeq-Locations \ {fa})).x
    = (Exec (l,s2) | (Int-Locations \/ FinSeq-Locations \ {fa})).x
    proof
      let x be set;
      assume
A50:  x in ((Int-Locations \/ FinSeq-Locations) \ {fa});
      then
A51:  x in Int-Locations \/ FinSeq-Locations by XBOOLE_0:def 4;
A52:  not x in {fa} by A50,XBOOLE_0:def 4;
      per cases by A51,XBOOLE_0:def 2;
      suppose x in Int-Locations;
        then reconsider a = x as Int-Location by SCMFSA_2:11;
A53:    a in (Int-Locations \/ FinSeq-Locations \/ {IC SCM+FSA}) by A51,
        XBOOLE_0:def 2;
        thus (Exec (l,s1) | (Int-Locations \/ FinSeq-Locations \ {fa})).x
        = (Exec (l,s1)).a by A50,FUNCT_1:72
          .= s1.a by A46,SCMFSA_2:99
          .= (s1 | (Int-Locations \/ FinSeq-Locations \/ {IC SCM+FSA})).a
        by A53,FUNCT_1:72
          .= s2.a by A1,A53,FUNCT_1:72
          .= (Exec (l,s2)).a by A46,SCMFSA_2:99
          .= (Exec (l,s2) | (Int-Locations \/ FinSeq-Locations \ {fa})).x
        by A50,FUNCT_1:72;
      end;
      suppose x in FinSeq-Locations;
        then reconsider a = x as FinSeq-Location by SCMFSA_2:12;
A54:    a <> fa by A52,TARSKI:def 1;
A55:    a in (Int-Locations \/ FinSeq-Locations \/ {IC SCM+FSA}) by A51,
        XBOOLE_0:def 2;
        thus (Exec (l,s1) | (Int-Locations \/ FinSeq-Locations \ {fa})).x
        = (Exec (l,s1)).a by A50,FUNCT_1:72
          .= s1.a by A46,A54,SCMFSA_2:99
          .= (s1 | (Int-Locations \/ FinSeq-Locations \/ {IC SCM+FSA})).a
        by A55,FUNCT_1:72
          .= s2.a by A1,A55,FUNCT_1:72
          .= (Exec (l,s2)).a by A46,A54,SCMFSA_2:99
          .= (Exec (l,s2) | (Int-Locations \/ FinSeq-Locations \ {fa})).x
        by A50,FUNCT_1:72;
      end;
    end;
    then
A56: Exec (l,s1) | (Int-Locations \/ FinSeq-Locations \ {fa} )
    = Exec (l,s2) | (Int-Locations \/ FinSeq-Locations \ {fa} )
    by A48,A49,FUNCT_1:9;
    da in Int-Locations by SCMFSA_2:9;
    then
A57: da in Int-Locations \/ FinSeq-Locations by XBOOLE_0:def 2;
    consider k1 being Element of NAT such that
A58: k1 = abs(s1.da) and
A59: Exec(l, s1).fa = s1.fa+*(k1,s1.db) by A46,SCMFSA_2:99;
    consider k2 being Element of NAT such that
A60: k2 = abs(s2.da) and
A61: Exec(l, s2).fa = s2.fa+*(k2,s2.db) by A46,SCMFSA_2:99;
A62: s1.da = (s1 | (Int-Locations \/ FinSeq-Locations \/ {IC SCM+FSA})).da
    by A10,A57,FUNCT_1:72
      .= s2.da by A1,A10,A57,FUNCT_1:72;
    db in Int-Locations by SCMFSA_2:9;
    then
A63: db in Int-Locations \/ FinSeq-Locations by XBOOLE_0:def 2;
    then
A64: s1.db = (s1 | (Int-Locations \/ FinSeq-Locations \/ {IC SCM+FSA}) ).db
    by A10,FUNCT_1:72
      .= s2.db by A1,A10,A63,FUNCT_1:72;
    fa in FinSeq-Locations by SCMFSA_2:10;
    then fa in Int-Locations \/ FinSeq-Locations by XBOOLE_0:def 2;
    then
A65: fa in (Int-Locations \/ FinSeq-Locations \/ {IC SCM+FSA}) by
    XBOOLE_0:def 2;
    then s1.fa = (s1 | (Int-Locations \/ FinSeq-Locations \/ {IC SCM+FSA})).fa
    by FUNCT_1:72
      .= s2.fa by A1,A65,FUNCT_1:72;
    then Exec (l,s1) | {fa} = Exec(l,s2) | {fa} by A9,A58,A59,A60,A61,A62,A64,
    GRFUNC_1:90;
    then
A66: DataPart Exec (l,s1) = DataPart Exec (l,s2)
 by A47,A56,RELAT_1:185,SCMFSA_2:127;
    Exec (l,s1).IC SCM+FSA = Next IC s1 by A46,SCMFSA_2:99
      .= Exec (l,s2).IC SCM+FSA by A6,A46,SCMFSA_2:99;
    then Exec (l,s1) | {IC SCM+FSA} = Exec (l,s2) | {IC SCM+FSA} by A7,A8,
    GRFUNC_1:90;
    hence Exec (l,s1) | (Int-Locations \/ FinSeq-Locations \/ {IC SCM+FSA})
    = Exec (l,s2) | (Int-Locations \/ FinSeq-Locations \/ {IC SCM+FSA})
    by A66,RELAT_1:185,SCMFSA_2:127;
  end;
  suppose InsCode l = 11;
    then consider da,fa such that
A67: l = da:=len fa by SCMFSA_2:64;
    da in Int-Locations by SCMFSA_2:9;
    then da in Int-Locations \/ FinSeq-Locations by XBOOLE_0:def 2;
    then
A68: Int-Locations \/ FinSeq-Locations =
    Int-Locations \/ FinSeq-Locations \/ {da} by ZFMISC_1:46
      .= (Int-Locations \/ FinSeq-Locations \ {da} ) \/ {da} by XBOOLE_1:39;
A69: dom ((Exec (l,s1)) | (Int-Locations \/ FinSeq-Locations \ {da}))
    = (Int-Locations \/ FinSeq-Locations \ {da}) by A7,RELAT_1:91;
A70: dom ((Exec (l,s2)) | (Int-Locations \/ FinSeq-Locations \ {da}))
    = (Int-Locations \/ FinSeq-Locations \ {da}) by A8,RELAT_1:91;
    for x being set st x in ((Int-Locations \/ FinSeq-Locations) \ {da})
    holds (Exec (l,s1) | (Int-Locations \/ FinSeq-Locations \ {da})).x
    = (Exec (l,s2) | (Int-Locations \/ FinSeq-Locations \ {da})).x
    proof
      let x be set;
      assume
A71:  x in ((Int-Locations \/ FinSeq-Locations) \ {da});
      then
A72:  x in Int-Locations \/ FinSeq-Locations by XBOOLE_0:def 4;
A73:  not x in {da} by A71,XBOOLE_0:def 4;
      per cases by A72,XBOOLE_0:def 2;
      suppose x in Int-Locations;
        then reconsider a = x as Int-Location by SCMFSA_2:11;
A74:    a <> da by A73,TARSKI:def 1;
A75:    a in (Int-Locations \/ FinSeq-Locations \/ {IC SCM+FSA}) by A72,
        XBOOLE_0:def 2;
        thus (Exec (l,s1) | (Int-Locations \/ FinSeq-Locations \ {da})).x
        = (Exec (l,s1)).a by A71,FUNCT_1:72
          .= s1.a by A67,A74,SCMFSA_2:100
          .= (s1 | (Int-Locations \/ FinSeq-Locations \/ {IC SCM+FSA})).a
        by A75,FUNCT_1:72
          .= s2.a by A1,A75,FUNCT_1:72
          .= (Exec (l,s2)).a by A67,A74,SCMFSA_2:100
          .= (Exec (l,s2) | (Int-Locations \/ FinSeq-Locations \ {da})).x
        by A71,FUNCT_1:72;
      end;
      suppose x in FinSeq-Locations;
        then reconsider a = x as FinSeq-Location by SCMFSA_2:12;
A76:    a in (Int-Locations \/ FinSeq-Locations \/ {IC SCM+FSA}) by A72,
        XBOOLE_0:def 2;
        thus (Exec (l,s1) | (Int-Locations \/ FinSeq-Locations \ {da})).x
        = (Exec (l,s1)).a by A71,FUNCT_1:72
          .= s1.a by A67,SCMFSA_2:100
          .= (s1 | (Int-Locations \/ FinSeq-Locations \/ {IC SCM+FSA})).a
        by A76,FUNCT_1:72
          .= s2.a by A1,A76,FUNCT_1:72
          .= (Exec (l,s2)).a by A67,SCMFSA_2:100
          .= (Exec (l,s2) | (Int-Locations \/ FinSeq-Locations \ {da})).x
        by A71,FUNCT_1:72;
      end;
    end;
    then
A77: Exec (l,s1) | (Int-Locations \/ FinSeq-Locations \ {da} )
    = Exec (l,s2) | (Int-Locations \/ FinSeq-Locations \ {da} )
    by A69,A70,FUNCT_1:9;
    fa in FinSeq-Locations by SCMFSA_2:10;
    then fa in Int-Locations \/ FinSeq-Locations by XBOOLE_0:def 2;
    then
A78: fa in (Int-Locations \/ FinSeq-Locations \/ {IC SCM+FSA}) by
    XBOOLE_0:def 2;
    then s1.fa = (s1 | (Int-Locations \/ FinSeq-Locations \/ {IC SCM+FSA})).fa
    by FUNCT_1:72
      .= s2.fa by A1,A78,FUNCT_1:72;
    then Exec (l,s1).da = len(s2.fa) by A67,SCMFSA_2:100
      .= Exec (l,s2).da by A67,SCMFSA_2:100;
    then Exec (l,s1) | {da} = Exec(l,s2) | {da} by A7,A8,GRFUNC_1:90;
    then
A79: DataPart Exec (l,s1) = DataPart Exec (l,s2)
         by A68,A77,RELAT_1:185,SCMFSA_2:127;
    Exec (l,s1).IC SCM+FSA = Next IC s1 by A67,SCMFSA_2:100
      .= Exec (l,s2).IC SCM+FSA by A6,A67,SCMFSA_2:100;
    then Exec (l,s1) | {IC SCM+FSA} = Exec (l,s2) | {IC SCM+FSA} by A7,A8,
    GRFUNC_1:90;
    hence Exec (l,s1) | (Int-Locations \/ FinSeq-Locations \/ {IC SCM+FSA})
    = Exec (l,s2) | (Int-Locations \/ FinSeq-Locations \/ {IC SCM+FSA})
    by A79,RELAT_1:185,SCMFSA_2:127;
  end;
  suppose InsCode l = 12;
    then consider da,fa such that
A80: l = fa:=<0,...,0>da by SCMFSA_2:65;
    fa in FinSeq-Locations by SCMFSA_2:10;
    then fa in Int-Locations \/ FinSeq-Locations by XBOOLE_0:def 2;
    then
A81: Int-Locations \/ FinSeq-Locations =
    Int-Locations \/ FinSeq-Locations \/ {fa} by ZFMISC_1:46
      .= (Int-Locations \/ FinSeq-Locations \ {fa} ) \/ {fa} by XBOOLE_1:39;
A82: dom ((Exec (l,s1)) | (Int-Locations \/ FinSeq-Locations \ {fa}))
    = (Int-Locations \/ FinSeq-Locations \ {fa}) by A7,RELAT_1:91;
A83: dom ((Exec (l,s2)) | (Int-Locations \/ FinSeq-Locations \ {fa}))
    = (Int-Locations \/ FinSeq-Locations \ {fa}) by A8,RELAT_1:91;
    for x being set st x in ((Int-Locations \/ FinSeq-Locations) \ {fa})
    holds (Exec (l,s1) | (Int-Locations \/ FinSeq-Locations \ {fa})).x
    = (Exec (l,s2) | (Int-Locations \/ FinSeq-Locations \ {fa})).x
    proof
      let x be set;
      assume
A84:  x in ((Int-Locations \/ FinSeq-Locations) \ {fa});
      then
A85:  x in Int-Locations \/ FinSeq-Locations by XBOOLE_0:def 4;
A86:  not x in {fa} by A84,XBOOLE_0:def 4;
      per cases by A85,XBOOLE_0:def 2;
      suppose x in Int-Locations;
        then reconsider a = x as Int-Location by SCMFSA_2:11;
A87:    a in (Int-Locations \/ FinSeq-Locations \/ {IC SCM+FSA}) by A85,
        XBOOLE_0:def 2;
        thus (Exec (l,s1) | (Int-Locations \/ FinSeq-Locations \ {fa})).x
        = (Exec (l,s1)).a by A84,FUNCT_1:72
          .= s1.a by A80,SCMFSA_2:101
          .= (s1 | (Int-Locations \/ FinSeq-Locations \/ {IC SCM+FSA})).a
        by A87,FUNCT_1:72
          .= s2.a by A1,A87,FUNCT_1:72
          .= (Exec (l,s2)).a by A80,SCMFSA_2:101
          .= (Exec (l,s2) | (Int-Locations \/ FinSeq-Locations \ {fa})).x
        by A84,FUNCT_1:72;
      end;
      suppose x in FinSeq-Locations;
        then reconsider a = x as FinSeq-Location by SCMFSA_2:12;
A88:    a <> fa by A86,TARSKI:def 1;
A89:    a in (Int-Locations \/ FinSeq-Locations \/ {IC SCM+FSA}) by A85,
        XBOOLE_0:def 2;
        thus (Exec (l,s1) | (Int-Locations \/ FinSeq-Locations \ {fa})).x
        = (Exec (l,s1)).a by A84,FUNCT_1:72
          .= s1.a by A80,A88,SCMFSA_2:101
          .= (s1 | (Int-Locations \/ FinSeq-Locations \/ {IC SCM+FSA})).a
        by A89,FUNCT_1:72
          .= s2.a by A1,A89,FUNCT_1:72
          .= (Exec (l,s2)).a by A80,A88,SCMFSA_2:101
          .= (Exec (l,s2) | (Int-Locations \/ FinSeq-Locations \ {fa})).x
        by A84,FUNCT_1:72;
      end;
    end;
    then
A90: Exec (l,s1) | (Int-Locations \/ FinSeq-Locations \ {fa} )
    = Exec (l,s2) | (Int-Locations \/ FinSeq-Locations \ {fa} )
    by A82,A83,FUNCT_1:9;
    da in Int-Locations by SCMFSA_2:9;
    then
A91: da in Int-Locations \/ FinSeq-Locations by XBOOLE_0:def 2;
    consider k1 being Element of NAT such that
A92: k1 = abs(s1.da) and
A93: Exec(l, s1).fa = k1 |->0 by A80,SCMFSA_2:101;
    consider k2 being Element of NAT such that
A94: k2 = abs(s2.da) and
A95: Exec(l, s2).fa = k2 |->0 by A80,SCMFSA_2:101;
    s1.da = (s1 | (Int-Locations \/ FinSeq-Locations \/ {IC SCM+FSA})).da
    by A10,A91,FUNCT_1:72
      .= s2.da by A1,A10,A91,FUNCT_1:72;

then Exec (l,s1) | {fa} = Exec(l,s2) | {fa} by A9,A92,A93,A94,A95,GRFUNC_1:90;
    then
A96: DataPart Exec (l,s1) = DataPart Exec (l,s2)
         by A81,A90,RELAT_1:185,SCMFSA_2:127;
    Exec (l,s1).IC SCM+FSA = Next IC s1 by A80,SCMFSA_2:101
      .= Exec (l,s2).IC SCM+FSA by A6,A80,SCMFSA_2:101;
    then Exec (l,s1) | {IC SCM+FSA} = Exec (l,s2) | {IC SCM+FSA} by A7,A8,
    GRFUNC_1:90;
    hence Exec (l,s1) | (Int-Locations \/ FinSeq-Locations \/ {IC SCM+FSA})
    = Exec (l,s2) | (Int-Locations \/ FinSeq-Locations \/ {IC SCM+FSA})
    by A96,RELAT_1:185,SCMFSA_2:127;
  end;
end;

begin :: Finite partial states of SCM+FSA

canceled 5;

theorem
  for i being Instruction of SCM+FSA, s being State of SCM+FSA,
  p being preProgram of SCM+FSA holds
  Exec (i, s +* p) = Exec (i,s) +* p
proof
  let i be Instruction of SCM+FSA, s be State of SCM+FSA,
  p be preProgram of SCM+FSA;
A1: dom p c= NAT by AMI_1:def 40;
A2: Int-Locations \/ FinSeq-Locations misses
  NAT by SCMFSA_2:13,14,XBOOLE_1:70;
  now
    assume {IC SCM+FSA} meets NAT;
    then consider x being set such that
A3: x in {IC SCM+FSA} and
A4: x in NAT by XBOOLE_0:3;
    reconsider l = x as Instruction-Location of SCM+FSA by A4,AMI_1:def 4;
    l = IC SCM+FSA by A3,TARSKI:def 1;
    hence contradiction by AMI_1:48;
  end;
  then Int-Locations \/ FinSeq-Locations \/ {IC SCM+FSA} misses NAT
  by A2,XBOOLE_1:70;
  then
A5: Int-Locations \/ FinSeq-Locations \/ {IC SCM+FSA} misses dom p
  by A1,XBOOLE_1:63;
  then
A6: s|(Int-Locations \/ FinSeq-Locations \/ {IC SCM+FSA})
  = (s +* p) | (Int-Locations \/ FinSeq-Locations \/ {IC SCM+FSA})
  by FUNCT_4:76;
A7: (Exec(i,s) +* p)|(Int-Locations \/ FinSeq-Locations \/ {IC SCM+FSA})
  = Exec(i,s)|(Int-Locations \/ FinSeq-Locations \/ {IC SCM+FSA})
  by A5,FUNCT_4:76
    .= Exec(i,s +* p) |
  (Int-Locations \/ FinSeq-Locations \/ {IC SCM+FSA}) by A6,Th4;
A8: Exec (i, s +* p)|NAT = (s +* p)|NAT by AMI_1:117
    .= s |(NAT) +*
  p|NAT by FUNCT_4:75
    .= Exec (i,s) |(NAT) +* p|NAT by AMI_1:117
    .= (Exec (i, s) +* p)|NAT by FUNCT_4:75;
  thus Exec (i, s +* p)
  = Exec (i, s +* p)| dom(Exec (i, s +* p)) by RELAT_1:97
    .= Exec (i, s +* p)|
  (Int-Locations \/ FinSeq-Locations \/ {IC SCM+FSA} \/ NAT) by AMI_1:79
  ,SCMFSA_2:8
    .= (Exec (i, s) +* p)|
  (Int-Locations \/ FinSeq-Locations \/ {IC SCM+FSA})
  +* (Exec (i, s) +* p)|NAT by A7,A8,FUNCT_4:83
    .= (Exec (i,s) +* p)| the carrier of SCM+FSA by FUNCT_4:83,SCMFSA_2:8
    .= (Exec (i,s) +* p)| dom(Exec (i, s) +* p) by AMI_1:79
    .= Exec (i,s) +* p by RELAT_1:97;
end;

theorem
  for s being State of SCM+FSA, iloc being Instruction-Location of SCM+FSA,
  a being Int-Location holds s.a = (s +* Start-At iloc).a
proof
  let s be State of SCM+FSA, iloc be Instruction-Location of SCM+FSA,
  a be Int-Location;
A1: dom (Start-At iloc) = {IC SCM+FSA} by FUNCOP_1:19;
  a in the carrier of SCM+FSA;
  then a in dom s by AMI_1:79;
  then
A2: a in dom s \/ dom (Start-At iloc) by XBOOLE_0:def 2;
  a <> IC SCM+FSA by SCMFSA_2:81;
  then not a in {IC SCM+FSA} by TARSKI:def 1;
  hence s.a = (s +* Start-At iloc).a by A1,A2,FUNCT_4:def 1;
end;

theorem
  for s being State of SCM+FSA, iloc being Instruction-Location of SCM+FSA,
  a being FinSeq-Location holds s.a = (s +* Start-At iloc).a
proof
  let s be State of SCM+FSA, iloc be Instruction-Location of SCM+FSA,
  a be FinSeq-Location;
A1: dom (Start-At iloc) = {IC SCM+FSA} by FUNCOP_1:19;
  a in the carrier of SCM+FSA;
  then a in dom s by AMI_1:79;
  then
A2: a in dom s \/ dom (Start-At iloc) by XBOOLE_0:def 2;
  a <> IC SCM+FSA by SCMFSA_2:82;
  then not a in {IC SCM+FSA} by TARSKI:def 1;
  hence s.a = (s +* Start-At iloc).a by A1,A2,FUNCT_4:def 1;
end;

begin :: Autonomic finite partial states of SCM+FSA

definition
  let la be Int-Location;
  let a be Integer;
  redefine func la .--> a -> FinPartState of SCM+FSA;
  coherence
  proof
    a is Element of INT & ObjectKind la = INT by INT_1:def 2,SCMFSA_2:26;
    hence thesis by AMI_1:59;
  end;
end;

canceled;

theorem Th14:
  for p being autonomic FinPartState of SCM+FSA st DataPart p <> {}
  holds IC SCM+FSA in dom p
proof
  let p be autonomic FinPartState of SCM+FSA;
  assume DataPart p <> {};
  then
A1: dom DataPart p <> {};
  assume not IC SCM+FSA in dom p;
  then
A2: dom p misses {IC SCM+FSA} by ZFMISC_1:56;
  p is not autonomic
  proof
    consider d1 being Element of dom DataPart p;
A3: d1 in dom DataPart p by A1;
    dom DataPart p c= the carrier of SCM+FSA by AMI_1:80;
    then reconsider d1 as Element of SCM+FSA by A3;
A4: dom DataPart p c= Int-Locations \/ FinSeq-Locations
         by RELAT_1:87,SCMFSA_2:127;
    consider d2 being Element of Int-Locations \ dom p;
    not Int-Locations c= dom p;
    then
A5: Int-Locations \ dom p <> {} by XBOOLE_1:37;
    then d2 in Int-Locations by XBOOLE_0:def 4;
    then reconsider d2 as Int-Location by SCMFSA_2:11;
    consider il being Element of (NAT) \ dom p;
    not NAT c= dom p;
    then
A6: (NAT) \ dom p <> {} by XBOOLE_1:37;
    then il in NAT by XBOOLE_0:def 4;
    then reconsider il as Instruction-Location of SCM+FSA by AMI_1:def 4;
    per cases by A3,A4,XBOOLE_0:def 2;
    suppose d1 in Int-Locations;
      then reconsider d1 as Int-Location by SCMFSA_2:11;
      set p1 = p +* ((il .--> (d1:=d2)) +* ( d2.--> 0) +* Start-At il);
      set p2 = p +* ((il .--> (d1:=d2)) +* ( d2.--> 1) +* Start-At il);
      consider s1 being State of SCM+FSA such that
A7:   p1 c= s1 by CARD_3:97;
      consider s2 being State of SCM+FSA such that
A8:   p2 c= s2 by CARD_3:97;
      take s1,s2;
      not d2 in dom p by A5,XBOOLE_0:def 4;
      then
A9:   dom p misses {d2} by ZFMISC_1:56;
      not il in dom p by A6,XBOOLE_0:def 4;
      then
A10:  dom p misses {il} by ZFMISC_1:56;
      dom ((il .--> (d1:=d2)) +* ( d2.--> 0) +* Start-At il)
      = dom((il .--> (d1:=d2)) +* ( d2.--> 0)) \/ dom(Start-At il)
      by FUNCT_4:def 1

.= dom((il .--> (d1:=d2)) +* ( d2.--> 0)) \/ {IC SCM+FSA} by FUNCOP_1:19
        .= dom(il .--> (d1:=d2)) \/ dom ( d2.--> 0) \/ {IC SCM+FSA}
      by FUNCT_4:def 1
        .= {il} \/ dom ( d2.--> 0) \/ {IC SCM+FSA} by FUNCOP_1:19
        .= {il} \/ {d2} \/ {IC SCM+FSA} by FUNCOP_1:19;
      then dom p /\ dom ((il .--> (d1:=d2)) +* ( d2.--> 0) +* Start-At il)
      = dom p /\ ({il} \/ {d2}) \/ dom p /\ {IC SCM+FSA} by XBOOLE_1:23
        .= dom p /\ ({il} \/ {d2}) \/ {} by A2,XBOOLE_0:def 7
        .= dom p /\ {il} \/ dom p /\ {d2} by XBOOLE_1:23
        .= dom p /\ {il} \/ {} by A9,XBOOLE_0:def 7
        .= {} by A10,XBOOLE_0:def 7;
      then dom p misses dom ((il .--> (d1:=d2)) +* ( d2.--> 0) +* Start-At il)
      by XBOOLE_0:def 7;
      then p c= p1 by FUNCT_4:33;
      hence p c= s1 by A7,XBOOLE_1:1;
      dom ((il .--> (d1:=d2)) +* ( d2.--> 1) +* Start-At il)
      = dom((il .--> (d1:=d2)) +* ( d2.--> 1)) \/ dom(Start-At il)
      by FUNCT_4:def 1

.= dom((il .--> (d1:=d2)) +* ( d2.--> 1)) \/ {IC SCM+FSA} by FUNCOP_1:19
        .= dom(il .--> (d1:=d2)) \/ dom ( d2.--> 1) \/ {IC SCM+FSA}
      by FUNCT_4:def 1
        .= {il} \/ dom ( d2.--> 1) \/ {IC SCM+FSA} by FUNCOP_1:19
        .= {il} \/ {d2} \/ {IC SCM+FSA} by FUNCOP_1:19;
      then dom p /\ dom ((il .--> (d1:=d2)) +* ( d2.--> 1) +* Start-At il)
      = dom p /\ ({il} \/ {d2}) \/ dom p /\ {IC SCM+FSA} by XBOOLE_1:23
        .= dom p /\ ({il} \/ {d2}) \/ {} by A2,XBOOLE_0:def 7
        .= dom p /\ {il} \/ dom p /\ {d2} by XBOOLE_1:23
        .= dom p /\ {il} \/ {} by A9,XBOOLE_0:def 7
        .= {} by A10,XBOOLE_0:def 7;
      then dom p misses dom ((il .--> (d1:=d2)) +* ( d2.--> 1) +* Start-At il)
      by XBOOLE_0:def 7;
      then p c= p2 by FUNCT_4:33;
      hence p c= s2 by A8,XBOOLE_1:1;
      take 1;
      DataPart p c= p by RELAT_1:88;
      then
A11:  dom DataPart p c= dom p by RELAT_1:25;
      dom  Computation(s1,1) = the carrier of SCM+FSA by AMI_1:79;
      then
A12:  dom ( Computation(s1,1)|dom p) = dom p by AMI_1:80,RELAT_1:91;
A13:  dom(Start-At il) = {IC SCM+FSA} by FUNCOP_1:19;
      then
A14:  IC SCM+FSA in dom (Start-At il) by TARSKI:def 1;
A15:  dom ((il .--> (d1:=d2)) +* ( d2.--> 0) +* Start-At il)
      = dom ((il .--> (d1:=d2)) +* ( d2.--> 0)) \/ dom(Start-At il)
      by FUNCT_4:def 1;
      then
A16:  IC SCM+FSA in dom ((il .--> (d1:=d2)) +* ( d2.--> 0) +* Start-At il)
      by A14,XBOOLE_0:def 2;
A17:  dom p1 = dom p \/ dom ((il .--> (d1:=d2)) +* ( d2.--> 0) +* Start-At il)
      by FUNCT_4:def 1;
      then IC SCM+FSA in dom p1 by A16,XBOOLE_0:def 2;
      then
A18:  IC s1 = p1.IC SCM+FSA by A7,GRFUNC_1:8
        .= ((il .--> (d1:=d2)) +* ( d2.--> 0) +* Start-At il).IC SCM+FSA
      by A16,FUNCT_4:14
        .= (Start-At il).IC SCM+FSA by A14,FUNCT_4:14
        .= il by FUNCOP_1:87;
      dom (il .--> (d1:=d2)) = {il} by FUNCOP_1:19;
      then
A19:  il in dom (il .--> (d1:=d2)) by TARSKI:def 1;
A20:  dom (d2 .--> 0) = {d2} by FUNCOP_1:19;
      il <> d2 by SCMFSA_2:84;
      then
A21:  not il in dom (d2 .--> 0) by A20,TARSKI:def 1;
A22:  dom ((il .--> (d1:=d2)) +* ( d2.--> 0))
      = dom (il .--> (d1:=d2)) \/ dom ( d2.--> 0) by FUNCT_4:def 1;
      then
A23:  il in dom ((il .--> (d1:=d2)) +* ( d2.--> 0)) by A19,XBOOLE_0: def 2;
      il <> IC SCM+FSA by AMI_1:48;
      then
A24:  not il in dom (Start-At il) by A13,TARSKI:def 1;
A25:  il in dom ((il .--> (d1:=d2)) +* ( d2.--> 0) +* Start-At il)
      by A15,A23,XBOOLE_0:def 2;
      then il in dom p1 by A17,XBOOLE_0:def 2;
      then
A26:  s1.il = p1.il by A7,GRFUNC_1:8
        .= ((il .--> (d1:=d2)) +* ( d2.--> 0) +* Start-At il).il
      by A25,FUNCT_4:14
        .= ((il .--> (d1:=d2)) +* ( d2.--> 0)).il by A24,FUNCT_4:12
        .= (il .--> (d1:=d2)).il by A21,FUNCT_4:12
        .=(d1:=d2) by FUNCOP_1:87;
A27:  d2 in dom (d2 .--> 0) by A20,TARSKI:def 1;
      then
A28:  d2 in dom ((il .--> (d1:=d2)) +* ( d2.--> 0)) by A22,XBOOLE_0: def 2;
      d2 <> IC SCM+FSA by SCMFSA_2:81;
      then
A29:  not d2 in dom (Start-At il) by A13,TARSKI:def 1;
A30:  d2 in dom ((il .--> (d1:=d2)) +* ( d2.--> 0) +* Start-At il)
      by A15,A28,XBOOLE_0:def 2;
      then d2 in dom p1 by A17,XBOOLE_0:def 2;
      then
A31:  s1.d2 = p1.d2 by A7,GRFUNC_1:8
        .= ((il .--> (d1:=d2)) +* ( d2.--> 0) +* Start-At il).d2
      by A30,FUNCT_4:14
        .= ((il .--> (d1:=d2)) +* ( d2.--> 0)).d2 by A29,FUNCT_4:12
        .= (d2.--> 0).d2 by A27,FUNCT_4:14
        .= 0 by FUNCOP_1:87;
       Computation(s1,0+1).d1 = (Following  Computation(s1,0)).d1 by
      AMI_1:14
        .= (Following s1).d1 by AMI_1:13
        .= 0 by A18,A26,A31,SCMFSA_2:89;
      then
A32:  ( Computation(s1,1)|dom p).d1 = 0 by A3,A11,A12,FUNCT_1:70;
      dom ( Computation(s2,1)) = the carrier of SCM+FSA by AMI_1:79;
      then
A33:  dom ( Computation(s2,1)|dom p) = dom p by AMI_1:80,RELAT_1:91;
A34:  dom(Start-At il) = {IC SCM+FSA} by FUNCOP_1:19;
      then
A35:  IC SCM+FSA in dom (Start-At il) by TARSKI:def 1;
A36:  dom ((il .--> (d1:=d2)) +* ( d2.--> 1) +* Start-At il)
      = dom ((il .--> (d1:=d2)) +* ( d2.--> 1)) \/ dom(Start-At il)
      by FUNCT_4:def 1;
      then
A37:  IC SCM+FSA in dom ((il .--> (d1:=d2)) +* ( d2.--> 1) +* Start-At il)
      by A35,XBOOLE_0:def 2;
A38:  dom p2 = dom p \/ dom ((il .--> (d1:=d2)) +* ( d2.--> 1) +* Start-At il)
      by FUNCT_4:def 1;
      then IC SCM+FSA in dom p2 by A37,XBOOLE_0:def 2;
      then
A39:  IC s2 = p2.IC SCM+FSA by A8,GRFUNC_1:8
        .= ((il .--> (d1:=d2)) +* ( d2.--> 1) +* Start-At il).IC SCM+FSA
      by A37,FUNCT_4:14
        .= (Start-At il).IC SCM+FSA by A35,FUNCT_4:14
        .= il by FUNCOP_1:87;
      dom (il .--> (d1:=d2)) = {il} by FUNCOP_1:19;
      then
A40:  il in dom (il .--> (d1:=d2)) by TARSKI:def 1;
A41:  dom (d2 .--> 1) = {d2} by FUNCOP_1:19;
      il <> d2 by SCMFSA_2:84;
      then
A42:  not il in dom (d2 .--> 1) by A41,TARSKI:def 1;
A43:  dom ((il .--> (d1:=d2)) +* ( d2.--> 1))
      = dom (il .--> (d1:=d2)) \/ dom ( d2.--> 1) by FUNCT_4:def 1;
      then
A44:  il in dom ((il .--> (d1:=d2)) +* ( d2.--> 1)) by A40,XBOOLE_0: def 2;
      il <> IC SCM+FSA by AMI_1:48;
      then
A45:  not il in dom (Start-At il) by A34,TARSKI:def 1;
A46:  il in dom ((il .--> (d1:=d2)) +* ( d2.--> 1) +* Start-At il)
      by A36,A44,XBOOLE_0:def 2;
      then il in dom p2 by A38,XBOOLE_0:def 2;
      then
A47:  s2.il = p2.il by A8,GRFUNC_1:8
        .= ((il .--> (d1:=d2)) +* ( d2.--> 1) +* Start-At il).il
      by A46,FUNCT_4:14
        .= ((il .--> (d1:=d2)) +* ( d2.--> 1)).il by A45,FUNCT_4:12
        .= (il .--> (d1:=d2)).il by A42,FUNCT_4:12
        .=(d1:=d2) by FUNCOP_1:87;
A48:  d2 in dom (d2 .--> 1) by A41,TARSKI:def 1;
      then
A49:  d2 in dom ((il .--> (d1:=d2)) +* ( d2.--> 1)) by A43,XBOOLE_0: def 2;
      d2 <> IC SCM+FSA by SCMFSA_2:81;
      then
A50:  not d2 in dom (Start-At il) by A34,TARSKI:def 1;
A51:  d2 in dom ((il .--> (d1:=d2)) +* ( d2.--> 1) +* Start-At il)
      by A36,A49,XBOOLE_0:def 2;
      then d2 in dom p2 by A38,XBOOLE_0:def 2;
      then
A52:  s2.d2 = p2.d2 by A8,GRFUNC_1:8
        .= ((il .--> (d1:=d2)) +* ( d2.--> 1) +* Start-At il).d2
      by A51,FUNCT_4:14
        .= ((il .--> (d1:=d2)) +* ( d2.--> 1)).d2 by A50,FUNCT_4:12
        .= (d2.--> 1).d2 by A48,FUNCT_4:14
        .= 1 by FUNCOP_1:87;
       Computation(s2,0+1).d1 = (Following  Computation(s2,0)).d1 by
      AMI_1:14
        .= (Following s2).d1 by AMI_1:13
        .= 1 by A39,A47,A52,SCMFSA_2:89;
      hence  Computation(s1,1)|dom p <>  Computation(s2,1)|dom p by A3,A11,A32
      ,A33,FUNCT_1:70;
    end;
    suppose d1 in FinSeq-Locations;
      then reconsider d1 as FinSeq-Location by SCMFSA_2:12;

set p1 = p +* ((il .--> (d1:=<0,...,0>d2)) +* ( d2.--> 0) +* Start-At il);

set p2 = p +* ((il .--> (d1:=<0,...,0>d2)) +* ( d2.--> 1) +* Start-At il);
      consider s1 being State of SCM+FSA such that
A53:  p1 c= s1 by CARD_3:97;
      consider s2 being State of SCM+FSA such that
A54:  p2 c= s2 by CARD_3:97;
      take s1,s2;
      not d2 in dom p by A5,XBOOLE_0:def 4;
      then
A55:  dom p misses {d2} by ZFMISC_1:56;
      not il in dom p by A6,XBOOLE_0:def 4;
      then
A56:  dom p misses {il} by ZFMISC_1:56;
      dom ((il .--> (d1:=<0,...,0>d2)) +* ( d2.--> 0) +* Start-At il)
      = dom((il .--> (d1:=<0,...,0>d2)) +* ( d2.--> 0)) \/ dom(Start-At il)
      by FUNCT_4:def 1
        .= dom((il .--> (d1:=<0,...,0>d2)) +* ( d2.--> 0)) \/ {IC SCM+FSA}
      by FUNCOP_1:19
        .= dom(il .--> (d1:=<0,...,0>d2)) \/ dom ( d2.--> 0) \/ {IC SCM+FSA}
      by FUNCT_4:def 1
        .= {il} \/ dom ( d2.--> 0) \/ {IC SCM+FSA} by FUNCOP_1:19
        .= {il} \/ {d2} \/ {IC SCM+FSA} by FUNCOP_1:19;
      then dom p /\ dom ((il .--> (d1:=<0,...,0>d2)) +* ( d2.--> 0) +*
      Start-At
      il) = dom p /\ ({il} \/ {d2}) \/ dom p /\ {IC SCM+FSA} by XBOOLE_1:23
        .= dom p /\ ({il} \/ {d2}) \/ {} by A2,XBOOLE_0:def 7
        .= dom p /\ {il} \/ dom p /\ {d2} by XBOOLE_1:23
        .= dom p /\ {il} \/ {} by A55,XBOOLE_0:def 7
        .= {} by A56,XBOOLE_0:def 7;
      then dom p misses dom ((il .--> (d1:=<0,...,0>d2)) +*
      ( d2.--> 0) +* Start-At il) by XBOOLE_0:def 7;
      then p c= p1 by FUNCT_4:33;
      hence p c= s1 by A53,XBOOLE_1:1;
      dom ((il .--> (d1:=<0,...,0>d2)) +* ( d2.--> 1) +* Start-At il)
      = dom((il .--> (d1:=<0,...,0>d2)) +* ( d2.--> 1)) \/ dom(Start-At il)
      by FUNCT_4:def 1
        .= dom((il .--> (d1:=<0,...,0>d2)) +* ( d2.--> 1)) \/ {IC SCM+FSA}
      by FUNCOP_1:19
        .= dom(il .--> (d1:=<0,...,0>d2)) \/ dom ( d2.--> 1) \/ {IC SCM+FSA}
      by FUNCT_4:def 1
        .= {il} \/ dom ( d2.--> 1) \/ {IC SCM+FSA} by FUNCOP_1:19
        .= {il} \/ {d2} \/ {IC SCM+FSA} by FUNCOP_1:19;
      then dom p /\ dom ((il .--> (d1:=<0,...,0>d2)) +* ( d2.--> 1) +*
      Start-At
      il) = dom p /\ ({il} \/ {d2}) \/ dom p /\ {IC SCM+FSA} by XBOOLE_1:23
        .= dom p /\ ({il} \/ {d2}) \/ {} by A2,XBOOLE_0:def 7
        .= dom p /\ {il} \/ dom p /\ {d2} by XBOOLE_1:23
        .= dom p /\ {il} \/ {} by A55,XBOOLE_0:def 7
        .= {} by A56,XBOOLE_0:def 7;
      then dom p misses dom ((il .--> (d1:=<0,...,0>d2)) +*
      ( d2.--> 1) +* Start-At il) by XBOOLE_0:def 7;
      then p c= p2 by FUNCT_4:33;
      hence p c= s2 by A54,XBOOLE_1:1;
      take 1;
      DataPart p c= p by RELAT_1:88;
      then
A57:  dom DataPart p c= dom p by RELAT_1:25;
      dom  Computation(s1,1) = the carrier of SCM+FSA by AMI_1:79;
      then
A58:  dom ( Computation(s1,1)|dom p) = dom p by AMI_1:80,RELAT_1:91;
A59:  dom(Start-At il) = {IC SCM+FSA} by FUNCOP_1:19;
      then
A60:  IC SCM+FSA in dom (Start-At il) by TARSKI:def 1;
A61:  dom ((il .--> (d1:=<0,...,0>d2)) +* ( d2.--> 0) +* Start-At il)
      = dom ((il .--> (d1:=<0,...,0>d2)) +* ( d2.--> 0)) \/ dom(Start-At il)
      by FUNCT_4:def 1;
      then
A62:  IC SCM+FSA in
      dom ((il .--> (d1:=<0,...,0>d2)) +* ( d2.--> 0) +* Start-At il)
      by A60,XBOOLE_0:def 2;
A63:  dom p1 = dom p \/
      dom ((il .--> (d1:=<0,...,0>d2)) +* ( d2.--> 0) +* Start-At il)
      by FUNCT_4:def 1;
      then IC SCM+FSA in dom p1 by A62,XBOOLE_0:def 2;
      then
A64:  IC s1 = p1.IC SCM+FSA by A53,GRFUNC_1:8
        .= ((il .--> (d1:=<0,...,0>d2)) +*
      ( d2.--> 0) +* Start-At il).IC SCM+FSA by A62,FUNCT_4:14
        .= (Start-At il).IC SCM+FSA by A60,FUNCT_4:14
        .= il by FUNCOP_1:87;
      dom (il .--> (d1:=<0,...,0>d2)) = {il} by FUNCOP_1:19;
      then
A65:  il in dom (il .--> (d1:=<0,...,0>d2)) by TARSKI:def 1;
A66:  dom (d2 .--> 0) = {d2} by FUNCOP_1:19;
      il <> d2 by SCMFSA_2:84;
      then
A67:  not il in dom (d2 .--> 0) by A66,TARSKI:def 1;
A68:  dom ((il .--> (d1:=<0,...,0>d2)) +* ( d2.--> 0))
      = dom (il .--> (d1:=<0,...,0>d2)) \/ dom ( d2.--> 0) by FUNCT_4:def 1;
      then
A69:  il in dom ((il .--> (d1:=<0,...,0>d2)) +* ( d2.--> 0)) by A65,
      XBOOLE_0:def 2;
      il <> IC SCM+FSA by AMI_1:48;
      then
A70:  not il in dom (Start-At il) by A59,TARSKI:def 1;
A71:  il in dom ((il .--> (d1:=<0,...,0>d2)) +* ( d2.--> 0) +* Start-At il)
      by A61,A69,XBOOLE_0:def 2;
      then il in dom p1 by A63,XBOOLE_0:def 2;
      then
A72:  s1.il = p1.il by A53,GRFUNC_1:8
        .= ((il .--> (d1:=<0,...,0>d2)) +* ( d2.--> 0) +* Start-At il).il
      by A71,FUNCT_4:14
        .= ((il .--> (d1:=<0,...,0>d2)) +* ( d2.--> 0)).il by A70,FUNCT_4:12
        .= (il .--> (d1:=<0,...,0>d2)).il by A67,FUNCT_4:12
        .=(d1:=<0,...,0>d2) by FUNCOP_1:87;
A73:  d2 in dom (d2 .--> 0) by A66,TARSKI:def 1;
      then
A74:  d2 in dom ((il .--> (d1:=<0,...,0>d2)) +* ( d2.--> 0)) by A68,
      XBOOLE_0:def 2;
      d2 <> IC SCM+FSA by SCMFSA_2:81;
      then
A75:  not d2 in dom (Start-At il) by A59,TARSKI:def 1;
A76:  d2 in dom ((il .--> (d1:=<0,...,0>d2)) +* ( d2.--> 0) +* Start-At il)
      by A61,A74,XBOOLE_0:def 2;
      then d2 in dom p1 by A63,XBOOLE_0:def 2;
      then
A77:  s1.d2 = p1.d2 by A53,GRFUNC_1:8
        .= ((il .--> (d1:=<0,...,0>d2)) +* ( d2.--> 0) +* Start-At il).d2
      by A76,FUNCT_4:14
        .= ((il .--> (d1:=<0,...,0>d2)) +* ( d2.--> 0)).d2 by A75,FUNCT_4:12
        .= (d2.--> 0).d2 by A73,FUNCT_4:14
        .= 0 by FUNCOP_1:87;
      consider k such that
A78:  k = abs(s1.d2) and
A79:  Exec(d1:=<0,...,0>d2, s1).d1 = k |-> 0 by SCMFSA_2:101;
A80:  k |-> 0 = 0 |-> 0 by A77,A78,ABSVALUE:7
        .= {} by FINSEQ_2:72;
       Computation(s1,0+1).d1 = (Following  Computation(s1,0)).d1 by
      AMI_1:14
        .= (Following s1).d1 by AMI_1:13
        .= {} by A64,A72,A79,A80;
      then
A81:  ( Computation(s1,1)|dom p).d1 = {} by A3,A57,A58,FUNCT_1:70;
      dom ( Computation(s2,1)) = the carrier of SCM+FSA by AMI_1:79;
      then
A82:  dom ( Computation(s2,1)|dom p) = dom p by AMI_1:80,RELAT_1:91;
A83:  dom(Start-At il) = {IC SCM+FSA} by FUNCOP_1:19;
      then
A84:  IC SCM+FSA in dom (Start-At il) by TARSKI:def 1;
A85:  dom ((il .--> (d1:=<0,...,0>d2)) +* ( d2.--> 1) +* Start-At il)
      = dom ((il .--> (d1:=<0,...,0>d2)) +* ( d2.--> 1)) \/ dom(Start-At il)
      by FUNCT_4:def 1;
      then
A86:  IC SCM+FSA in
      dom ((il .--> (d1:=<0,...,0>d2)) +* ( d2.--> 1) +* Start-At il)
      by A84,XBOOLE_0:def 2;
A87:  dom p2 = dom p \/
      dom ((il .--> (d1:=<0,...,0>d2)) +* ( d2.--> 1) +* Start-At il)
      by FUNCT_4:def 1;
      then IC SCM+FSA in dom p2 by A86,XBOOLE_0:def 2;
      then
A88:  IC s2 = p2.IC SCM+FSA by A54,GRFUNC_1:8
        .= ((il .--> (d1:=<0,...,0>d2)) +*
      ( d2.--> 1) +* Start-At il).IC SCM+FSA by A86,FUNCT_4:14
        .= (Start-At il).IC SCM+FSA by A84,FUNCT_4:14
        .= il by FUNCOP_1:87;
      dom (il .--> (d1:=<0,...,0>d2)) = {il} by FUNCOP_1:19;
      then
A89:  il in dom (il .--> (d1:=<0,...,0>d2)) by TARSKI:def 1;
A90:  dom (d2 .--> 1) = {d2} by FUNCOP_1:19;
      il <> d2 by SCMFSA_2:84;
      then
A91:  not il in dom (d2 .--> 1) by A90,TARSKI:def 1;
A92:  dom ((il .--> (d1:=<0,...,0>d2)) +* ( d2.--> 1))
      = dom (il .--> (d1:=<0,...,0>d2)) \/ dom ( d2.--> 1) by FUNCT_4:def 1;
      then
A93:  il in dom ((il .--> (d1:=<0,...,0>d2)) +* ( d2.--> 1)) by A89,
      XBOOLE_0:def 2;
      il <> IC SCM+FSA by AMI_1:48;
      then
A94:  not il in dom (Start-At il) by A83,TARSKI:def 1;
A95:  il in dom ((il .--> (d1:=<0,...,0>d2)) +* ( d2.--> 1) +* Start-At il)
      by A85,A93,XBOOLE_0:def 2;
      then il in dom p2 by A87,XBOOLE_0:def 2;
      then
A96:  s2.il = p2.il by A54,GRFUNC_1:8
        .= ((il .--> (d1:=<0,...,0>d2)) +* ( d2.--> 1) +* Start-At il).il
      by A95,FUNCT_4:14
        .= ((il .--> (d1:=<0,...,0>d2)) +* ( d2.--> 1)).il by A94,FUNCT_4:12
        .= (il .--> (d1:=<0,...,0>d2)).il by A91,FUNCT_4:12
        .=(d1:=<0,...,0>d2) by FUNCOP_1:87;
A97:  d2 in dom (d2 .--> 1) by A90,TARSKI:def 1;
      then
A98:  d2 in
      dom ((il .--> (d1:=<0,...,0>d2)) +* ( d2.--> 1)) by A92,XBOOLE_0:def 2;
      d2 <> IC SCM+FSA by SCMFSA_2:81;
      then
A99:  not d2 in dom (Start-At il) by A83,TARSKI:def 1;
A100: d2 in dom ((il .--> (d1:=<0,...,0>d2)) +* ( d2.--> 1) +* Start-At il)
      by A85,A98,XBOOLE_0:def 2;
      then d2 in dom p2 by A87,XBOOLE_0:def 2;
      then
A101: s2.d2 = p2.d2 by A54,GRFUNC_1:8
        .= ((il .--> (d1:=<0,...,0>d2)) +* ( d2.--> 1) +* Start-At il).d2
      by A100,FUNCT_4:14
        .= ((il .--> (d1:=<0,...,0>d2)) +* ( d2.--> 1)).d2 by A99,FUNCT_4:12
        .= (d2.--> 1).d2 by A97,FUNCT_4:14
        .= 1 by FUNCOP_1:87;
      consider k such that
A102: k = abs(s2.d2) and
A103: Exec(d1:=<0,...,0>d2, s2).d1 = k |-> 0 by SCMFSA_2:101;
A104: k |-> 0 = 1 |-> 0 by A101,A102,ABSVALUE:def 1
        .= <*0*> by FINSEQ_2:73;
       Computation(s2,0+1).d1 = (Following  Computation(s2,0)).d1 by
      AMI_1:14
        .= (Following s2).d1 by AMI_1:13
        .= <*0*> by A88,A96,A103,A104;
      hence  Computation(s1,1)|dom p <>  Computation(s2,1)|dom p by A3,A57,A81
      ,A82,FUNCT_1:70;
    end;
  end;
  hence contradiction;
end;

registration
  cluster autonomic non programmed FinPartState of SCM+FSA;
  existence
  proof
    set P = (IC SCM+FSA, insloc 0)-->(insloc 0, halt SCM+FSA);
    P = Start-At(insloc 0)+*((insloc 0) .--> halt SCM+FSA) by FUNCT_4:def 4;
    then reconsider P as FinPartState of SCM+FSA;
    take P;
A1: ObjectKind insloc 0 = the Instructions of SCM+FSA by AMI_1:def 14;
    ObjectKind IC SCM+FSA = NAT by AMI_1:def 11;
    hence P is autonomic by A1,AMI_1:67;
    now
A2:   dom P = { IC SCM+FSA, insloc 0 } by FUNCT_4:65;
      then
A3:   IC SCM+FSA in dom P by TARSKI:def 2;
      assume dom P c= NAT;
      then reconsider l = IC SCM+FSA as Instruction-Location of SCM+FSA
      by A3,AMI_1:def 4;
      l in dom P by A2,TARSKI:def 2;
      hence contradiction by AMI_1:48;
    end;
    hence P is non programmed by AMI_1:def 40;
  end;
end;

theorem Th15:
  for p being autonomic non programmed FinPartState of SCM+FSA
  holds IC SCM+FSA in dom p
proof
  let p be autonomic non programmed FinPartState of SCM+FSA;
A1: not dom p c= NAT by AMI_1:def 40;
  dom p = dom p /\ the carrier of SCM+FSA by AMI_1:80,XBOOLE_1:28
    .= dom p /\
  (Int-Locations \/ FinSeq-Locations \/ {IC SCM+FSA}) \/ dom p /\ NAT
  by SCMFSA_2:8,XBOOLE_1:23;
  then dom p /\ (Int-Locations \/ FinSeq-Locations \/ {IC SCM+FSA}) <> {}
  by A1,XBOOLE_1:17;
  then
A2: dom p /\ {IC SCM+FSA} \/
  dom p /\ (Int-Locations \/ FinSeq-Locations) <> {} by XBOOLE_1:23;
  per cases by A2;
  suppose dom p /\ {IC SCM+FSA} <> {};
    then dom p meets {IC SCM+FSA} by XBOOLE_0:def 7;
    hence IC SCM+FSA in dom p by ZFMISC_1:56;
  end;
  suppose dom p /\ (Int-Locations \/ FinSeq-Locations) <> {};
    then DataPart p <> {} by RELAT_1:60,90,SCMFSA_2:127;
    hence IC SCM+FSA in dom p by Th14;
  end;
end;

theorem
  for p being autonomic FinPartState of SCM+FSA st IC SCM+FSA in dom p
  holds IC p in dom p
proof
  let p be autonomic FinPartState of SCM+FSA;
  assume
A1: IC SCM+FSA in dom p;
  assume
A2: not IC p in dom p;
  set il = IC p;
  set p1 = p +* ((il .--> goto insloc 0));
  set p2 = p +* ((il .--> goto insloc 1));
  consider s1 being State of SCM+FSA such that
A3: p1 c= s1 by CARD_3:97;
  consider s2 being State of SCM+FSA such that
A4: p2 c= s2 by CARD_3:97;
  p is not autonomic
  proof
A5: dom (il .--> (goto insloc 1)) = {il} by FUNCOP_1:19;
A6: dom (il .--> (goto insloc 0)) = {il} by FUNCOP_1:19;
    take s1,s2;
    dom p misses {il} by A2,ZFMISC_1:56;
    then
A7: p c= p1 & p c= p2 by A5,A6,FUNCT_4:33;
    hence p c= s1 & p c= s2 by A3,A4,XBOOLE_1:1;
    take 1;
A8: il in dom (il .--> (goto insloc 1)) by A5,TARSKI:def 1;
A9: il in dom (il .--> (goto insloc 0)) by A6,TARSKI:def 1;
    dom p1 = dom p \/ dom ((il .--> goto insloc 0)) by FUNCT_4:def 1;
    then il in dom p1 by A9,XBOOLE_0:def 2;
    then
A10: s1.il = p1.il by A3,GRFUNC_1:8
      .= ((il .--> goto insloc 0)).il by A9,FUNCT_4:14
      .= goto insloc 0 by FUNCOP_1:87;
    dom p2 = dom p \/ dom ((il .--> goto insloc 1)) by FUNCT_4:def 1;
    then il in dom p2 by A8,XBOOLE_0:def 2;
    then
A11: s2.il = p2.il by A4,GRFUNC_1:8
      .= ((il .--> goto insloc 1)).il by A8,FUNCT_4:14
      .= goto insloc 1 by FUNCOP_1:87;
A12: (Following s1).IC SCM+FSA
    = Exec (goto insloc 0,s1).IC SCM+FSA by A1,A3,A7,A10,AMI_1:97,XBOOLE_1: 1
      .= insloc 0 by SCMFSA_2:95;
A13: (Following s2).IC SCM+FSA
    = Exec (goto insloc 1,s2).IC SCM+FSA by A1,A4,A7,A11,AMI_1:97,XBOOLE_1: 1
      .= insloc 1 by SCMFSA_2:95;
    assume
A14:  Computation(s1,1)|dom p =  Computation(s2,1)|dom p;
A15: (Following(s1))|dom p
    = (Following ( Computation(s1,0)))|dom p by AMI_1:13
      .=  Computation(s1,0+1)|dom p by AMI_1:14
      .= (Following ( Computation(s2,0)))|dom p by A14, AMI_1:14
      .= (Following(s2))|dom p by AMI_1:13;
    insloc 0 = ((Following(s1))|dom p).IC SCM+FSA by A1,A12, FUNCT_1:72
      .= insloc 1 by A1,A13,A15,FUNCT_1:72;
    hence contradiction;
  end;
  hence contradiction;
end;

theorem Th17:
  for p being autonomic non programmed FinPartState of SCM+FSA,
  s being State of SCM+FSA st p c= s for i being Element of NAT
  holds IC  Computation(s,i) in dom ProgramPart(p)
proof
  let p be autonomic non programmed FinPartState of SCM+FSA,
  s be State of SCM+FSA such that
A1: p c= s;
  let i be Element of NAT;
  set Csi =  Computation(s,i);
  set loc = IC Csi;
  reconsider ll = loc as Element of NAT by ORDINAL1:def 13;
  set loc1 = insloc(ll+1);
  assume
A3: not IC  Computation(s,i) in dom ProgramPart(p);
A4: loc in NAT by AMI_1:def 4;
  loc in dom ProgramPart p iff loc in dom p /\ NAT by FUNCT_1:68;
  then
A5: not loc in dom p by A3,A4,XBOOLE_0:def 3;
  set p1 = p +* (loc .--> goto loc);
  set p2 = p +* (loc .--> goto loc1);
A6: dom p1 = dom p \/ dom (loc .--> goto loc) &
  dom p2 = dom p \/ dom (loc .--> goto loc1) by FUNCT_4:def 1;
A7: dom (loc .--> goto loc) = {loc} &
  dom (loc .--> goto loc1) = {loc} by FUNCOP_1:19;
  then
A8: loc in dom (loc .--> goto loc) &
  loc in dom (loc .--> goto loc1) by TARSKI:def 1;
  then
A9: loc in dom p1 & loc in dom p2 by A6,XBOOLE_0:def 2;
  consider s1 being State of SCM+FSA such that
A10: p1 c= s1 by CARD_3:97;
  consider s2 being State of SCM+FSA such that
A11: p2 c= s2 by CARD_3:97;
  set Cs1i =  Computation(s1,i);
  set Cs2i =  Computation(s2,i);
  p is not autonomic
  proof
    take s1, s2;
    dom s1 = the carrier of SCM+FSA & dom s2 = the carrier of SCM+FSA
    by AMI_1:79;
    then
A12: dom p c= dom s1 & dom p c= dom s2 by AMI_1:80;
    now
      let x be set;
      assume
A13:  x in dom p;
      then dom p misses dom (loc .--> goto loc) &
      x in dom p1 by A5,A6,A7,XBOOLE_0:def 2,ZFMISC_1:56;
      then p.x = p1.x & p1.x = s1.x by A10,A13,FUNCT_4:17,GRFUNC_1:8;
      hence p.x = s1.x;
    end;
    hence
A14: p c= s1 by A12,GRFUNC_1:8;
    now
      let x be set;
      assume
A15:  x in dom p;
      then dom p misses dom (loc .--> goto loc1) &
      x in dom p2 by A5,A6,A7,XBOOLE_0:def 2,ZFMISC_1:56;
      then p.x = p2.x & p2.x = s2.x by A11,A15,FUNCT_4:17,GRFUNC_1:8;
      hence p.x = s2.x;
    end;
    hence
A16: p c= s2 by A12,GRFUNC_1:8;
    (loc .--> goto loc).loc = goto loc &
    (loc .--> goto loc1).loc = goto loc1 by FUNCOP_1:87;
    then p1.loc = goto loc & p2.loc = goto loc1 by A8,FUNCT_4:14;
    then
A17: s1.loc = goto loc & s2.loc = goto loc1 by A9,A10,A11,GRFUNC_1:8;
    take k = i+1;
    set Cs1k =  Computation(s1,k);
    set Cs2k =  Computation(s2,k);
A18: Cs1k = Following Cs1i by AMI_1:14
      .= Exec (CurInstr Cs1i, Cs1i);
A19: Cs2k = Following Cs2i by AMI_1:14
      .= Exec (CurInstr Cs2i, Cs2i);
A20: Cs1i.loc = goto loc & Cs2i.loc = goto loc1 by A17,AMI_1:54;
A21: (Cs1i|dom p) = (Csi|dom p) by A1,A14,AMI_1:def 25;
A22: Cs1i.IC SCM+FSA = (Cs1i|dom p).IC SCM+FSA &
    Csi.IC SCM+FSA = (Csi|dom p).IC SCM+FSA by Th15,FUNCT_1:72;
    (Cs1i|dom p) = (Cs2i|dom p) by A14,A16,AMI_1:def 25;
    then Cs1i.IC SCM+FSA = loc & Cs2i.IC SCM+FSA = loc
    by A21,A22,Th15,FUNCT_1:72;
    then
A23: Cs1k.IC SCM+FSA = loc & Cs2k.IC SCM+FSA = loc1 by A18,A19,A20,
    SCMFSA_2:95;
    (Cs1k|dom p).IC SCM+FSA = Cs1k.IC SCM+FSA &
    (Cs2k|dom p).IC SCM+FSA = Cs2k.IC SCM+FSA by Th15,FUNCT_1:72;
    hence Cs1k|dom p <> Cs2k|dom p by A23;
  end;
  hence contradiction;
end;

theorem Th18:
  for p being autonomic non programmed FinPartState of SCM+FSA,
  s1, s2 being State of SCM+FSA st p c= s1 & p c= s2
  for i being Element of NAT
  holds IC  Computation(s1,i) = IC  Computation(s2,i) &
  CurInstr ( Computation(s1,i)) = CurInstr ( Computation(s2,i))
proof
  let p be autonomic non programmed FinPartState of SCM+FSA,
  s1, s2 be State of SCM+FSA such that
A1: p c= s1 & p c= s2;
  let i be Element of NAT;
  set I = CurInstr ( Computation(s1,i));
  set Cs1i =  Computation(s1,i);
  set Cs2i =  Computation(s2,i); thus
A2: IC Cs1i = IC Cs2i
  proof
    assume
A3: IC  Computation(s1,i) <> IC  Computation(s2,i);
    (Cs1i|dom p).IC SCM+FSA = Cs1i.IC SCM+FSA &
    (Cs2i|dom p).IC SCM+FSA = Cs2i.IC SCM+FSA by Th15,FUNCT_1:72;
    hence contradiction by A1,A3,AMI_1:def 25;
  end;
  thus I = CurInstr ( Computation(s2,i))
  proof
    assume
A4: I <> CurInstr ( Computation(s2,i));
A5: IC Cs1i in dom ProgramPart p & IC Cs2i in dom ProgramPart p by A1,Th17;
    ProgramPart p c= p by RELAT_1:88;
    then dom ProgramPart p c= dom p by GRFUNC_1:8;

then (Cs1i|dom p).IC Cs1i = Cs1i.IC Cs1i & (Cs2i|dom p).IC Cs2i = Cs2i.IC Cs2i
    by A5,FUNCT_1:72;
    hence contradiction by A1,A2,A4,AMI_1:def 25;
  end;
end;

theorem
  for p being autonomic non programmed FinPartState of SCM+FSA,
  s1, s2 being State of SCM+FSA st p c= s1 & p c= s2
  for i being Element of NAT, da, db being Int-Location
  st CurInstr ( Computation(s1,i)) = da := db & da in dom p
  holds  Computation(s1,i).db =  Computation(s2,i).db
proof
  let p be autonomic non programmed FinPartState of SCM+FSA,
  s1, s2 be State of SCM+FSA such that
A1: p c= s1 & p c= s2;
  let i be Element of NAT, da, db be Int-Location;
  set I = CurInstr ( Computation(s1,i));
  set Cs1i =  Computation(s1,i);
  set Cs2i =  Computation(s2,i);
A2: I = CurInstr ( Computation(s2,i)) by A1,Th18;
  set Cs1i1 =  Computation(s1,i+1);
  set Cs2i1 =  Computation(s2,i+1);
A3: Cs1i1 = Following Cs1i by AMI_1:14
    .= Exec (CurInstr Cs1i, Cs1i);
A4: Cs2i1 = Following Cs2i by AMI_1:14
    .= Exec (CurInstr Cs2i, Cs2i);
A5: da in dom p implies (Cs1i1|dom p).da = Cs1i1.da &
  (Cs2i1|dom p).da = Cs2i1.da by FUNCT_1:72;
  assume
A6: I = da := db & da in dom p &
   Computation(s1,i).db <>  Computation(s2,i).db;
  then Cs1i1.da = Cs1i.db & Cs2i1.da = Cs2i.db by A2,A3,A4,SCMFSA_2:89;
  hence contradiction by A1,A5,A6,AMI_1:def 25;
end;

theorem
  for p being autonomic non programmed FinPartState of SCM+FSA,
  s1, s2 being State of SCM+FSA st p c= s1 & p c= s2
  for i being Element of NAT, da, db being Int-Location
  st CurInstr ( Computation(s1,i)) = AddTo(da, db) & da in dom p
  holds  Computation(s1,i).da +  Computation(s1,i).db
  =  Computation(s2,i).da +  Computation(s2,i).db
proof
  let p be autonomic non programmed FinPartState of SCM+FSA,
  s1, s2 be State of SCM+FSA such that
A1: p c= s1 & p c= s2;
  let i be Element of NAT, da, db be Int-Location;
  set I = CurInstr ( Computation(s1,i));
  set Cs1i =  Computation(s1,i);
  set Cs2i =  Computation(s2,i);
A2: I = CurInstr ( Computation(s2,i)) by A1,Th18;
  set Cs1i1 =  Computation(s1,i+1);
  set Cs2i1 =  Computation(s2,i+1);
A3: Cs1i1 = Following Cs1i by AMI_1:14
    .= Exec (CurInstr Cs1i, Cs1i);
A4: Cs2i1 = Following Cs2i by AMI_1:14
    .= Exec (CurInstr Cs2i, Cs2i);
A5: da in dom p implies (Cs1i1|dom p).da = Cs1i1.da &
  (Cs2i1|dom p).da = Cs2i1.da by FUNCT_1:72;
  assume
A6: I = AddTo(da, db) & da in dom p &
   Computation(s1,i).da +  Computation(s1,i).db
  <>  Computation(s2,i).da +  Computation(s2,i).db;
  then Cs1i1.da = Cs1i.da + Cs1i.db & Cs2i1.da = Cs2i.da + Cs2i.db
  by A2,A3,A4,SCMFSA_2:90;
  hence contradiction by A1,A5,A6,AMI_1:def 25;
end;

theorem
  for p being autonomic non programmed FinPartState of SCM+FSA,
  s1, s2 being State of SCM+FSA st p c= s1 & p c= s2
  for i being Element of NAT, da, db being Int-Location
  st CurInstr ( Computation(s1,i)) = SubFrom(da, db) & da in dom p
  holds  Computation(s1,i).da -  Computation(s1,i).db
  =  Computation(s2,i).da -  Computation(s2,i).db
proof
  let p be autonomic non programmed FinPartState of SCM+FSA,
  s1, s2 be State of SCM+FSA such that
A1: p c= s1 & p c= s2;
  let i be Element of NAT, da, db be Int-Location;
  set I = CurInstr ( Computation(s1,i));
  set Cs1i =  Computation(s1,i);
  set Cs2i =  Computation(s2,i);
A2: I = CurInstr ( Computation(s2,i)) by A1,Th18;
  set Cs1i1 =  Computation(s1,i+1);
  set Cs2i1 =  Computation(s2,i+1);
A3: Cs1i1 = Following Cs1i by AMI_1:14
    .= Exec (CurInstr Cs1i, Cs1i);
A4: Cs2i1 = Following Cs2i by AMI_1:14
    .= Exec (CurInstr Cs2i, Cs2i);
A5: da in dom p implies (Cs1i1|dom p).da = Cs1i1.da &
  (Cs2i1|dom p).da = Cs2i1.da by FUNCT_1:72;
  assume
A6: I = SubFrom(da, db) & da in dom p &
   Computation(s1,i).da -  Computation(s1,i).db
  <>  Computation(s2,i).da -  Computation(s2,i).db;
  then Cs1i1.da = Cs1i.da - Cs1i.db & Cs2i1.da = Cs2i.da - Cs2i.db
  by A2,A3,A4,SCMFSA_2:91;
  hence contradiction by A1,A5,A6,AMI_1:def 25;
end;

theorem
  for p being autonomic non programmed FinPartState of SCM+FSA,
  s1, s2 being State of SCM+FSA st p c= s1 & p c= s2
  for i being Element of NAT, da, db being Int-Location
  st CurInstr ( Computation(s1,i)) = MultBy(da, db) & da in dom p
  holds  Computation(s1,i).da *  Computation(s1,i).db
  =  Computation(s2,i).da *  Computation(s2,i).db
proof
  let p be autonomic non programmed FinPartState of SCM+FSA,
  s1, s2 be State of SCM+FSA such that
A1: p c= s1 & p c= s2;
  let i be Element of NAT, da, db be Int-Location;
  set I = CurInstr ( Computation(s1,i));
  set Cs1i =  Computation(s1,i);
  set Cs2i =  Computation(s2,i);
A2: I = CurInstr ( Computation(s2,i)) by A1,Th18;
  set Cs1i1 =  Computation(s1,i+1);
  set Cs2i1 =  Computation(s2,i+1);
A3: Cs1i1 = Following Cs1i by AMI_1:14
    .= Exec (CurInstr Cs1i, Cs1i);
A4: Cs2i1 = Following Cs2i by AMI_1:14
    .= Exec (CurInstr Cs2i, Cs2i);
A5: da in dom p implies (Cs1i1|dom p).da = Cs1i1.da &
  (Cs2i1|dom p).da = Cs2i1.da by FUNCT_1:72;
  assume
A6: I = MultBy(da, db) & da in dom p &
   Computation(s1,i).da *  Computation(s1,i).db
  <>  Computation(s2,i).da *  Computation(s2,i).db;
  then Cs1i1.da = Cs1i.da * Cs1i.db & Cs2i1.da = Cs2i.da * Cs2i.db
  by A2,A3,A4,SCMFSA_2:92;
  hence contradiction by A1,A5,A6,AMI_1:def 25;
end;

theorem
  for p being autonomic non programmed FinPartState of SCM+FSA,
  s1, s2 being State of SCM+FSA st p c= s1 & p c= s2
  for i being Element of NAT, da, db being Int-Location
  st CurInstr ( Computation(s1,i)) = Divide(da, db) & da in dom p & da <> db
  holds  Computation(s1,i).da div  Computation(s1,i).db
  =  Computation(s2,i).da div  Computation(s2,i).db
proof
  let p be autonomic non programmed FinPartState of SCM+FSA,
  s1, s2 be State of SCM+FSA such that
A1: p c= s1 & p c= s2;
  let i be Element of NAT, da, db be Int-Location;
  set I = CurInstr ( Computation(s1,i));
  set Cs1i =  Computation(s1,i);
  set Cs2i =  Computation(s2,i);
A2: I = CurInstr ( Computation(s2,i)) by A1,Th18;
  set Cs1i1 =  Computation(s1,i+1);
  set Cs2i1 =  Computation(s2,i+1);
A3: Cs1i1 = Following Cs1i by AMI_1:14
    .= Exec (CurInstr Cs1i, Cs1i);
A4: Cs2i1 = Following Cs2i by AMI_1:14
    .= Exec (CurInstr Cs2i, Cs2i);
A5: da in dom p implies (Cs1i1|dom p).da = Cs1i1.da &
  (Cs2i1|dom p).da = Cs2i1.da by FUNCT_1:72;
  assume
A6: I = Divide(da, db) & da in dom p & da <> db &
   Computation(s1,i).da div  Computation(s1,i).db
  <>  Computation(s2,i).da div  Computation(s2,i).db;
  then Cs1i1.da = Cs1i.da div Cs1i.db & Cs2i1.da = Cs2i.da div Cs2i.db
  by A2,A3,A4,SCMFSA_2:93;
  hence contradiction by A1,A5,A6,AMI_1:def 25;
end;

theorem
  for p being autonomic non programmed FinPartState of SCM+FSA,
  s1, s2 being State of SCM+FSA st p c= s1 & p c= s2
  for i being Element of NAT, da, db being Int-Location
  st CurInstr ( Computation(s1,i)) = Divide(da, db) & db in dom p & da <> db
  holds  Computation(s1,i).da mod  Computation(s1,i).db
  =  Computation(s2,i).da mod  Computation(s2,i).db
proof
  let p be autonomic non programmed FinPartState of SCM+FSA,
  s1, s2 be State of SCM+FSA such that
A1: p c= s1 & p c= s2;
  let i be Element of NAT, da, db be Int-Location;
  set I = CurInstr ( Computation(s1,i));
  set Cs1i =  Computation(s1,i);
  set Cs2i =  Computation(s2,i);
A2: I = CurInstr ( Computation(s2,i)) by A1,Th18;
  set Cs1i1 =  Computation(s1,i+1);
  set Cs2i1 =  Computation(s2,i+1);
A3: Cs1i1 = Following Cs1i by AMI_1:14
    .= Exec (CurInstr Cs1i, Cs1i);
A4: Cs2i1 = Following Cs2i by AMI_1:14
    .= Exec (CurInstr Cs2i, Cs2i);
  assume
A5: I = Divide(da, db) & db in dom p & da <> db &
   Computation(s1,i).da mod  Computation(s1,i).db
  <>  Computation(s2,i).da mod  Computation(s2,i).db;
  then
A6: (Cs1i1|dom p).db = Cs1i1.db & (Cs2i1|dom p).db = Cs2i1.db by FUNCT_1 :72;
  Cs1i1.db = Cs1i.da mod Cs1i.db & Cs2i1.db = Cs2i.da mod Cs2i.db
  by A2,A3,A4,A5,SCMFSA_2:93;
  hence contradiction by A1,A5,A6,AMI_1:def 25;
end;

theorem
  for p being autonomic non programmed FinPartState of SCM+FSA,
  s1, s2 being State of SCM+FSA st p c= s1 & p c= s2
  for i being Element of NAT, da being Int-Location,
  loc being Instruction-Location of SCM+FSA
  st CurInstr ( Computation(s1,i)) = da=0_goto loc &
  loc <> Next (IC  Computation(s1,i))
  holds ( Computation(s1,i).da = 0 iff  Computation(s2,i).da = 0)
proof
  let p be autonomic non programmed FinPartState of SCM+FSA,
  s1, s2 be State of SCM+FSA such that
A1: p c= s1 & p c= s2;
  let i be Element of NAT, da be Int-Location,
  loc be Instruction-Location of SCM+FSA;
  set I = CurInstr ( Computation(s1,i));
  set Cs1i =  Computation(s1,i);
  set Cs2i =  Computation(s2,i);
A2: I = CurInstr ( Computation(s2,i)) by A1,Th18;
  set Cs1i1 =  Computation(s1,i+1);
  set Cs2i1 =  Computation(s2,i+1);
A3: Cs1i1 = Following Cs1i by AMI_1:14
    .= Exec (CurInstr Cs1i, Cs1i);
A4: Cs2i1 = Following Cs2i by AMI_1:14
    .= Exec (CurInstr Cs2i, Cs2i);
A5: (Cs1i1|dom p).IC SCM+FSA = Cs1i1.IC SCM+FSA &
  (Cs2i1|dom p).IC SCM+FSA = Cs2i1.IC SCM+FSA by Th15,FUNCT_1:72;
A6: (Cs1i1|dom p) = (Cs2i1|dom p) by A1,AMI_1:def 25;
  assume
A7: I = da=0_goto loc & loc <> Next (IC  Computation(s1,i));
A8: now
    assume  Computation(s1,i).da = 0 &  Computation(s2,i).da <> 0;
    then Cs1i1.IC SCM+FSA = loc & Cs2i1.IC SCM+FSA = Next IC Cs2i
    by A2,A3,A4,A7,SCMFSA_2:96;
    hence contradiction by A1,A5,A6,A7,Th18;
  end;
  now
    assume  Computation(s2,i).da = 0 &  Computation(s1,i).da <> 0;
    then Cs2i1.IC SCM+FSA = loc & Cs1i1.IC SCM+FSA = Next IC Cs1i
    by A2,A3,A4,A7,SCMFSA_2:96;
    hence contradiction by A1,A5,A7,AMI_1:def 25;
  end;
  hence  Computation(s1,i).da = 0 iff  Computation(s2,i).da = 0 by A8;
end;

theorem
  for p being autonomic non programmed FinPartState of SCM+FSA,
  s1, s2 being State of SCM+FSA st p c= s1 & p c= s2
  for i being Element of NAT, da being Int-Location,
  loc being Instruction-Location of SCM+FSA
  st CurInstr ( Computation(s1,i)) = da>0_goto loc &
  loc <> Next (IC  Computation(s1,i))
  holds ( Computation(s1,i).da > 0 iff  Computation(s2,i).da > 0)
proof
  let p be autonomic non programmed FinPartState of SCM+FSA,
  s1, s2 be State of SCM+FSA such that
A1: p c= s1 & p c= s2;
  let i be Element of NAT, da be Int-Location,
  loc be Instruction-Location of SCM+FSA;
  set I = CurInstr ( Computation(s1,i));
  set Cs1i =  Computation(s1,i);
  set Cs2i =  Computation(s2,i);
A2: IC Cs1i = IC Cs2i by A1,Th18;
A3: I = CurInstr ( Computation(s2,i)) by A1,Th18;
  set Cs1i1 =  Computation(s1,i+1);
  set Cs2i1 =  Computation(s2,i+1);
A4: Cs1i1 = Following Cs1i by AMI_1:14
    .= Exec (CurInstr Cs1i, Cs1i);
A5: Cs2i1 = Following Cs2i by AMI_1:14
    .= Exec (CurInstr Cs2i, Cs2i);
A6: (Cs1i1|dom p).IC SCM+FSA = Cs1i1.IC SCM+FSA &
  (Cs2i1|dom p).IC SCM+FSA = Cs2i1.IC SCM+FSA by Th15,FUNCT_1:72;
A7: (Cs1i1|dom p) = (Cs2i1|dom p) by A1,AMI_1:def 25;
  assume
A8: I = da>0_goto loc & loc <> Next (IC  Computation(s1,i));
A9: now
    assume
A10:  Computation(s1,i).da > 0 &  Computation(s2,i).da <= 0;
    then Cs1i1.IC SCM+FSA = loc by A4,A8,SCMFSA_2:97;
    hence contradiction by A2,A3,A5,A6,A7,A8,A10,SCMFSA_2:97;
  end;
  now
    assume
A11:  Computation(s2,i).da > 0 &  Computation(s1,i).da <= 0;
    then Cs2i1.IC SCM+FSA = loc by A3,A5,A8,SCMFSA_2:97;
    hence contradiction by A4,A6,A7,A8,A11,SCMFSA_2:97;
  end;
  hence  Computation(s1,i).da > 0 iff  Computation(s2,i).da > 0 by A9;
end;

theorem
  for p being autonomic non programmed FinPartState of SCM+FSA,
  s1, s2 being State of SCM+FSA st p c= s1 & p c= s2
  for i being Element of NAT, da, db being Int-Location,
  f being FinSeq-Location
  st CurInstr ( Computation(s1,i)) = da := (f,db) & da in dom p
  for k1,k2 being Element of NAT st
  k1 = abs( Computation(s1,i).db) & k2 = abs( Computation(s2,i).db) holds
  ( Computation(s1,i).f)/.k1 = ( Computation(s2,i).f)/.k2
proof
  let p be autonomic non programmed FinPartState of SCM+FSA,
  s1, s2 be State of SCM+FSA such that
A1: p c= s1 & p c= s2;
  let i be Element of NAT, da, db be Int-Location, f be FinSeq-Location;
  set I = CurInstr ( Computation(s1,i));
  set Cs1i =  Computation(s1,i);
  set Cs2i =  Computation(s2,i);
  set Cs1i1 =  Computation(s1,i+1);
  set Cs2i1 =  Computation(s2,i+1);
A2: Cs1i1 = Following Cs1i by AMI_1:14
    .= Exec (CurInstr Cs1i, Cs1i);
A3: Cs2i1 = Following Cs2i by AMI_1:14
    .= Exec (CurInstr Cs2i, Cs2i);
A4: da in dom p implies (Cs1i1|dom p).da = Cs1i1.da &
  (Cs2i1|dom p).da = Cs2i1.da by FUNCT_1:72;
A5: Cs1i1|dom p = Cs2i1|dom p by A1,AMI_1:def 25;
  assume
A6: I = da := (f,db) & da in dom p;
  let i1,i2 be Element of NAT such that
A7: i1 = abs( Computation(s1,i).db) & i2 = abs( Computation(s2,i).db) and
A8: ( Computation(s1,i).f)/.i1 <> ( Computation(s2,i).f)/.i2;
  consider k1 being Element of NAT such that
A9: k1 = abs(Cs1i.db) & Exec(I, Cs1i).da = (Cs1i.f)/.k1 by A6,SCMFSA_2:98;
  consider k2 being Element of NAT such that
A10: k2 = abs(Cs2i.db) & Exec(I, Cs2i).da = (Cs2i.f)/.k2 by A6,SCMFSA_2:98;
  thus contradiction by A1,A2,A3,A4,A5,A6,A7,A8,A9,A10,Th18;
end;

theorem
  for p being autonomic non programmed FinPartState of SCM+FSA,
  s1, s2 being State of SCM+FSA st p c= s1 & p c= s2
  for i being Element of NAT, da, db being Int-Location,
  f being FinSeq-Location
  st CurInstr ( Computation(s1,i)) = (f,db):=da & f in dom p
  for k1,k2 being Element of NAT st
  k1 = abs( Computation(s1,i).db) & k2 = abs( Computation(s2,i).db)
  holds  Computation(s1,i).f+*(k1, Computation(s1,i).da)
  =  Computation(s2,i).f+*(k2, Computation(s2,i).da)
proof
  let p be autonomic non programmed FinPartState of SCM+FSA,
  s1, s2 be State of SCM+FSA such that
A1: p c= s1 & p c= s2;
  let i be Element of NAT, da, db be Int-Location, f be FinSeq-Location;
  set I = CurInstr ( Computation(s1,i));
  set Cs1i =  Computation(s1,i);
  set Cs2i =  Computation(s2,i);
  set Cs1i1 =  Computation(s1,i+1);
  set Cs2i1 =  Computation(s2,i+1);
A2: Cs1i1 = Following Cs1i by AMI_1:14
    .= Exec (CurInstr Cs1i, Cs1i);
A3: Cs2i1 = Following Cs2i by AMI_1:14
    .= Exec (CurInstr Cs2i, Cs2i);
A4: f in dom p implies (Cs1i1|dom p).f = Cs1i1.f &
  (Cs2i1|dom p).f = Cs2i1.f by FUNCT_1:72;
A5: Cs1i1|dom p = Cs2i1|dom p by A1,AMI_1:def 25;
  assume that
A6: I = (f,db):=da & f in dom p;
  let i1, i2 be Element of NAT such that
A7: i1 = abs(Cs1i.db) & i2 = abs(Cs2i.db) and
A8: Cs1i.f+*(i1,Cs1i.da) <> Cs2i.f+*(i2,Cs2i.da);
  consider k1 being Element of NAT such that
A9: k1 = abs(Cs1i.db) &
  Exec(I, Cs1i).f = Cs1i.f+*(k1,Cs1i.da) by A6,SCMFSA_2:99;
  consider k2 being Element of NAT such that
A10: k2 = abs(Cs2i.db) &
  Exec(I, Cs2i).f = Cs2i.f+*(k2,Cs2i.da) by A6,SCMFSA_2:99;
  thus contradiction by A1,A2,A3,A4,A5,A6,A7,A8,A9,A10,Th18;
end;

theorem
  for p being autonomic non programmed FinPartState of SCM+FSA,
  s1, s2 being State of SCM+FSA st p c= s1 & p c= s2
  for i being Element of NAT, da being Int-Location, f being FinSeq-Location
  st CurInstr ( Computation(s1,i)) = da :=len f & da in dom p holds
  len( Computation(s1,i).f) = len( Computation(s2,i).f)
proof
  let p be autonomic non programmed FinPartState of SCM+FSA,
  s1, s2 be State of SCM+FSA such that
A1: p c= s1 & p c= s2;
  let i be Element of NAT, da be Int-Location, f be FinSeq-Location;
  set I = CurInstr ( Computation(s1,i));
  set Cs1i =  Computation(s1,i);
  set Cs2i =  Computation(s2,i);
  set Cs1i1 =  Computation(s1,i+1);
  set Cs2i1 =  Computation(s2,i+1);
A2: Cs1i1 = Following Cs1i by AMI_1:14
    .= Exec (CurInstr Cs1i, Cs1i);
A3: Cs2i1 = Following Cs2i by AMI_1:14
    .= Exec (CurInstr Cs2i, Cs2i);
A4: da in dom p implies (Cs1i1|dom p).da = Cs1i1.da &
  (Cs2i1|dom p).da = Cs2i1.da by FUNCT_1:72;
A5: Cs1i1|dom p = Cs2i1|dom p by A1,AMI_1:def 25;
  assume that
A6: I = da :=len f & da in dom p and
A7: len( Computation(s1,i).f) <> len( Computation(s2,i).f);
A8: Exec(I, Cs1i).da = len(Cs1i.f) by A6,SCMFSA_2:100;
  Exec(I, Cs2i).da = len(Cs2i.f) by A6,SCMFSA_2:100;
  hence contradiction by A1,A2,A3,A4,A5,A6,A7,A8,Th18;
end;

theorem
  for p being autonomic non programmed FinPartState of SCM+FSA,
  s1, s2 being State of SCM+FSA st p c= s1 & p c= s2
  for i being Element of NAT, da being Int-Location, f being FinSeq-Location
  st CurInstr ( Computation(s1,i)) = f:=<0,...,0>da & f in dom p
  for k1,k2 being Element of NAT st
  k1 = abs( Computation(s1,i).da) & k2 = abs( Computation(s2,i).da)
  holds k1 |-> 0 = k2 |-> 0
proof
  let p be autonomic non programmed FinPartState of SCM+FSA,
  s1, s2 be State of SCM+FSA such that
A1: p c= s1 & p c= s2;
  let i be Element of NAT, da be Int-Location, f be FinSeq-Location;
  set I = CurInstr ( Computation(s1,i));
  set Cs1i =  Computation(s1,i);
  set Cs2i =  Computation(s2,i);
  set Cs1i1 =  Computation(s1,i+1);
  set Cs2i1 =  Computation(s2,i+1);
A2: Cs1i1 = Following Cs1i by AMI_1:14
    .= Exec (CurInstr Cs1i, Cs1i);
A3: Cs2i1 = Following Cs2i by AMI_1:14
    .= Exec (CurInstr Cs2i, Cs2i);
A4: f in dom p implies (Cs1i1|dom p).f = Cs1i1.f &
  (Cs2i1|dom p).f = Cs2i1.f by FUNCT_1:72;
A5: Cs1i1|dom p = Cs2i1|dom p by A1,AMI_1:def 25;
  assume that
A6: I = f:=<0,...,0>da & f in dom p;
  let i1, i2 be Element of NAT such that
A7: i1 = abs(Cs1i.da) & i2 = abs(Cs2i.da) and
A8: i1 |-> 0 <> i2 |->0;
  consider k1 being Element of NAT such that
A9: k1 = abs(Cs1i.da) & Exec(I, Cs1i).f = k1|->0 by A6,SCMFSA_2:101;
  consider k2 being Element of NAT such that
A10: k2 = abs(Cs2i.da) & Exec(I, Cs2i).f = k2|->0 by A6,SCMFSA_2:101;
  thus contradiction by A1,A2,A3,A4,A5,A6,A7,A8,A9,A10,Th18;
end;

