:: Computation in { \bf SCM_FSA }
::  by Andrzej Trybulec and Yatsuka Nakamura
::
:: Received February 7, 1996
:: Copyright (c) 1996 Association of Mizar Users

environ

 vocabularies SCMFSA_2, AMI_1, INT_1, AMI_3, RELAT_1, FUNCT_4, FUNCOP_1, AMI_2,
      BOOLE, FUNCT_1, AMI_5, ABSVALUE, FINSEQ_1, FINSEQ_2, CAT_1, ARYTM_1,
      NAT_1, FINSEQ_4, ARYTM, SCMNORM;
 notations TARSKI, XBOOLE_0, SUBSET_1, NUMBERS, XCMPLX_0, INT_2, RELAT_1,
      FUNCT_1, PARTFUN1, FUNCT_4, INT_1, NAT_1, DOMAIN_1, STRUCT_0, FUNCOP_1,
      FINSEQ_1, FINSEQ_2, SCMNORM, AMI_1, AMI_2, AMI_3, FUNCT_7, SCMFSA_2,
      XXREAL_0;
 constructors PARTFUN1, DOMAIN_1, XXREAL_0, NAT_1, INT_2, AMI_5, SCMFSA_2,
      SCMNORM, RELSET_1, SCMFSA_1;
 registrations XBOOLE_0, SETFAM_1, RELAT_1, FUNCT_1, NUMBERS, XREAL_0, INT_1,
      FINSEQ_1, CARD_3, STRUCT_0, AMI_1, AMI_3, AMI_5, SCMFSA_2, FINSET_1,
      ORDINAL1, SCMNORM;
 requirements NUMERALS, REAL, SUBSET, BOOLE, ARITHM;
 definitions AMI_1, AMI_3, FUNCOP_1, SCMFSA_2, SCMNORM;
 theorems AMI_1, AMI_3, GRFUNC_1, NAT_1, FUNCOP_1, TARSKI, FUNCT_4, FUNCT_1,
      ZFMISC_1, INT_1, RELAT_1, AMI_5, SCMFSA_2, SCMFSA_1, ABSVALUE, FINSEQ_2,
      XBOOLE_0, XBOOLE_1, CARD_3, AMI_2, ORDINAL1, NUMBERS;

begin

reserve k for Element of NAT,
  da,db for Int-Location,
  fa for FinSeq-Location;

theorem
  not IC SCM+FSA in Int-Locations
proof
  assume
  IC SCM+FSA in Int-Locations;
  then IC SCM+FSA is Int-Location by SCMFSA_2:11;
  then ObjectKind IC SCM+FSA = INT by SCMFSA_2:26;
  hence contradiction by AMI_1:def 11,NUMBERS:27;
end;

theorem
  not IC SCM+FSA in FinSeq-Locations
proof
  assume
  IC SCM+FSA in FinSeq-Locations;
  then IC SCM+FSA is FinSeq-Location by SCMFSA_2:12;
  then ObjectKind IC SCM+FSA = INT* by SCMFSA_2:27;
  hence contradiction by AMI_1:def 11,SCMFSA_1:13;
end;

theorem
  for i being Instruction of SCM+FSA, I being Instruction of SCM st i =
  I for s being State of SCM+FSA, S being State of SCM st S = s|(the carrier of
SCM) +* ((NAT) --> I) holds Exec(i,s) = s +*Exec(I,S) +* s|NAT by SCMFSA_2:75;

theorem Th4:
  for s1,s2 being State of SCM+FSA st (s1 | (Int-Locations \/
  FinSeq-Locations \/ {IC SCM+FSA})) = (s2 | (Int-Locations \/ FinSeq-Locations
  \/ {IC SCM+FSA})) for l being Instruction of SCM+FSA holds Exec (l,s1) | (
  Int-Locations \/ FinSeq-Locations \/ {IC SCM+FSA}) = Exec (l,s2) | (
  Int-Locations \/ FinSeq-Locations \/ {IC SCM+FSA})
proof
  IC SCM+FSA in {IC SCM+FSA} by TARSKI:def 1;
  then
A1: IC SCM+FSA in (Int-Locations \/ FinSeq-Locations \/ {IC SCM+FSA}) by
  XBOOLE_0:def 3;
  let s1,s2 be State of SCM+FSA such that
A2: s1 | (Int-Locations \/ FinSeq-Locations \/ {IC SCM+FSA}) = s2 | (
  Int-Locations \/ FinSeq-Locations \/ {IC SCM+FSA});
A3: Int-Locations \/ FinSeq-Locations \/ {IC SCM+FSA} c= the carrier of
  SCM+FSA;
  then (Int-Locations \/ FinSeq-Locations \/ {IC SCM+FSA}) c= dom s2 by
  AMI_1:79;
  then
A4: IC SCM+FSA in dom (s2 | (Int-Locations \/ FinSeq-Locations \/ {IC
  SCM+FSA})) by A1,RELAT_1:91;
  (Int-Locations \/ FinSeq-Locations \/ {IC SCM+FSA}) c= dom s1 by A3,
  AMI_1:79;
  then IC SCM+FSA in dom (s1 | (Int-Locations \/ FinSeq-Locations \/ {IC
  SCM+FSA})) by A1,RELAT_1:91;
  then
A5: IC s1 = (s2 | (Int-Locations \/ FinSeq-Locations \/ {IC SCM+FSA})).IC
  SCM+FSA by A2,FUNCT_1:70
    .= IC s2 by A4,FUNCT_1:70;
  let l be Instruction of SCM+FSA;
A6: dom Exec(l,s2) = the carrier of SCM+FSA by AMI_1:79;
A7: InsCode l <= 9+1 implies InsCode l <= 8+1 or InsCode l = 10 by NAT_1:8;
A8: InsCode l <= 10+1 implies InsCode l <= 10 or InsCode l = 11 by NAT_1:8;
A9: InsCode l <= 11+1 by SCMFSA_2:35;
A10: dom Exec(l,s1) = the carrier of SCM+FSA by AMI_1:79;
  then
A11: dom Exec(l,s1) = dom Exec(l,s2) by AMI_1:79;
A12: Int-Locations \/ FinSeq-Locations c= (Int-Locations \/ FinSeq-Locations
  \/ {IC SCM+FSA}) by XBOOLE_1:7;
  per cases by A9,A8,A7,NAT_1:8;
  suppose
    InsCode l <= 8;
    then reconsider I = l as Instruction of SCM by SCMFSA_2:34;
    reconsider S1 = s1|(the carrier of SCM) +* ((NAT) --> I), S2 = s2|(the
    carrier of SCM) +* ((NAT) --> I) as State of SCM by SCMFSA_2:73;
A13: SCM-Data-Loc c= Int-Locations \/ FinSeq-Locations by XBOOLE_1:7;
    now
      assume
      IC SCM+FSA in NAT;
      then reconsider l = IC SCM+FSA as Instruction-Location of SCM+FSA by
      AMI_1:def 4;
      l = IC SCM+FSA;
      hence contradiction by AMI_1:48;
    end;
    then
A14: NAT misses {IC SCM+FSA} by ZFMISC_1:56;
    (NAT) misses Int-Locations \/ FinSeq-Locations by SCMFSA_2:13,14,
    XBOOLE_1:70;
    then NAT misses Int-Locations \/ FinSeq-Locations \/ {IC SCM+FSA} by A14,
    XBOOLE_1:70;
    then
A15: (NAT) /\ (Int-Locations \/ FinSeq-Locations \/ {IC SCM+FSA}) = {} by
    XBOOLE_0:def 7;
    now
      assume
      IC SCM in NAT;
      then reconsider l = IC SCM as Instruction-Location of SCM by
      AMI_1:def 4;
      l = IC SCM;
      hence contradiction by AMI_1:48;
    end;
    then NAT misses {IC SCM} by ZFMISC_1:56;
    then dom((NAT) --> I) = NAT & NAT misses SCM-Data-Loc \/ {IC SCM} by
    AMI_2:29,FUNCOP_1:19,XBOOLE_1:70;
    then
A16: ((NAT) --> I)|(SCM-Data-Loc \/ {IC SCM}) = {} by RELAT_1:95;
    then
A17: S1 | (SCM-Data-Loc \/ {IC SCM}) = s1|(the carrier of SCM) | (
    SCM-Data-Loc \/ {IC SCM}) +* {} by FUNCT_4:75
      .= s1|(the carrier of SCM) | (SCM-Data-Loc \/ {IC SCM}) by FUNCT_4:22
      .= s1|(SCM-Data-Loc \/ {IC SCM}) by AMI_5:23,RELAT_1:103,XBOOLE_1:7
      .= s1|(Int-Locations \/ FinSeq-Locations \/ {IC SCM+FSA}) |(
    SCM-Data-Loc \/ {IC SCM}) by A13,AMI_3:4,RELAT_1:103,SCMFSA_2:7 ,XBOOLE_1:9
      .= s2|(SCM-Data-Loc \/ {IC SCM}) by A2,A13,AMI_3:4,RELAT_1:103,
    SCMFSA_2:7 ,XBOOLE_1:9
      .= s2|(the carrier of SCM) | (SCM-Data-Loc \/ {IC SCM}) by AMI_5:23 ,
    RELAT_1:103,XBOOLE_1:7
      .= s2|(the carrier of SCM) | (SCM-Data-Loc \/ {IC SCM}) +* {} by
    FUNCT_4:22
      .= S2 | (SCM-Data-Loc \/ {IC SCM}) by A16,FUNCT_4:75;
A18: (the carrier of SCM) /\ FinSeq-Locations = {} by SCMFSA_1:33 ,
    XBOOLE_0:def 7;
    then dom Exec(I,S1) /\ FinSeq-Locations = {} by AMI_1:79;
    then dom Exec(I,S1) misses FinSeq-Locations by XBOOLE_0:def 7;
    then
A19: Exec(I,S1)|FinSeq-Locations = {} by RELAT_1:95;
A20: Exec(I,S1) | (Int-Locations \/ FinSeq-Locations \/ {IC SCM+FSA}) =
Exec(I,S1) | (Int-Locations \/ FinSeq-Locations) +* Exec(I,S1) |{IC SCM+FSA} by
    FUNCT_4:83
      .= DataPart Exec(I,S1) +* {} +* Exec(I,S1) |{IC SCM+FSA} by A19,AMI_3:
    72,FUNCT_4:83
      .= DataPart Exec(I,S1) +* Exec(I,S1) |{IC SCM+FSA} by FUNCT_4:22
      .= Exec(I,S1) | (SCM-Data-Loc \/ {IC SCM}) by AMI_3:4,72,FUNCT_4:83,
    SCMFSA_2:7;
A21: s1|(NAT) | (Int-Locations \/ FinSeq-Locations \/ {IC SCM+FSA}) = s1|(
(NAT) /\ (Int-Locations \/ FinSeq-Locations \/ {IC SCM+FSA})) by RELAT_1:100
      .= {} by A15;
    dom Exec(I,S2) /\ FinSeq-Locations = {} by A18,AMI_1:79;
    then dom Exec(I,S2) misses FinSeq-Locations by XBOOLE_0:def 7;
    then
A22: Exec(I,S2)|FinSeq-Locations = {} by RELAT_1:95;
A23: Exec(I,S2) | (Int-Locations \/ FinSeq-Locations \/ {IC SCM+FSA}) =
Exec(I,S2)|(Int-Locations \/ FinSeq-Locations) +* Exec(I,S2) |{IC SCM+FSA} by
    FUNCT_4:83
      .= DataPart Exec(I,S2) +* {} +* Exec(I,S2) |{IC SCM+FSA} by A22,AMI_3:
    72,FUNCT_4:83
      .= DataPart Exec(I,S2) +* Exec(I,S2) |{IC SCM+FSA} by FUNCT_4:22
      .= Exec(I,S2) | (SCM-Data-Loc \/ {IC SCM}) by AMI_3:4,72,FUNCT_4:83,
    SCMFSA_2:7;
A24: s2|(NAT) | (Int-Locations \/ FinSeq-Locations \/ {IC SCM+FSA}) = s2|(
(NAT) /\ (Int-Locations \/ FinSeq-Locations \/ {IC SCM+FSA})) by RELAT_1:100
      .= {} by A15;
    thus Exec (l,s1) | (Int-Locations \/ FinSeq-Locations \/ {IC SCM+FSA}) = (
s1 +*Exec(I,S1) +* s1|NAT) | (Int-Locations \/ FinSeq-Locations \/ {IC SCM+FSA}
    ) by SCMFSA_2:75
      .= (s1 +*Exec(I,S1)) | (Int-Locations \/ FinSeq-Locations \/ {IC
    SCM+FSA}) +* {} by A21,FUNCT_4:75
      .= (s1 +*Exec(I,S1)) | (Int-Locations \/ FinSeq-Locations \/ {IC
    SCM+FSA}) by FUNCT_4:22
      .= (s1 | (Int-Locations \/ FinSeq-Locations \/ {IC SCM+FSA})) +* Exec(
    I,S1) | (SCM-Data-Loc \/ {IC SCM}) by A20,FUNCT_4:75
      .= (s2 | (Int-Locations \/ FinSeq-Locations \/ {IC SCM+FSA})) +* Exec(
    I,S2) | (SCM-Data-Loc \/ {IC SCM}) by A2,A17,AMI_5:58
      .= (s2 +*Exec(I,S2)) | (Int-Locations \/ FinSeq-Locations \/ {IC
    SCM+FSA}) by A23,FUNCT_4:75
      .= (s2 +*Exec(I,S2)) | (Int-Locations \/ FinSeq-Locations \/ {IC
    SCM+FSA}) +* {} by FUNCT_4:22
      .= (s2 +*Exec(I,S2) +* s2|NAT) | (Int-Locations \/ FinSeq-Locations \/
    {IC SCM+FSA}) by A24,FUNCT_4:75
      .= Exec (l,s2) | (Int-Locations \/ FinSeq-Locations \/ {IC SCM+FSA})
    by SCMFSA_2:75;
  end;
  suppose
    InsCode l = 9;
    then consider da,db,fa such that
A25: l = db:=(fa,da) by SCMFSA_2:62;
A26: for x being set st x in ((Int-Locations \/ FinSeq-Locations) \ {db})
holds (Exec (l,s1) | (Int-Locations \/ FinSeq-Locations \ {db})).x = (Exec (l,
    s2) | (Int-Locations \/ FinSeq-Locations \ {db})).x
    proof
      let x be set;
      assume
A27:  x in ((Int-Locations \/ FinSeq-Locations) \ {db});
      then
A28:  x in Int-Locations \/ FinSeq-Locations by XBOOLE_0:def 5;
A29:  not x in {db} by A27,XBOOLE_0:def 5;
      per cases by A28,XBOOLE_0:def 3;
      suppose
        x in Int-Locations;
        then reconsider a = x as Int-Location by SCMFSA_2:11;
A30:    a <> db by A29,TARSKI:def 1;
A31:    a in (Int-Locations \/ FinSeq-Locations \/ {IC SCM+FSA}) by A28,
        XBOOLE_0:def 3;
        thus (Exec (l,s1) | (Int-Locations \/ FinSeq-Locations \ {db})).x = (
        Exec (l,s1)).a by A27,FUNCT_1:72
          .= s1.a by A25,A30,SCMFSA_2:98
          .= (s1 | (Int-Locations \/ FinSeq-Locations \/ {IC SCM+FSA})).a by
        A31,FUNCT_1:72
          .= s2.a by A2,A31,FUNCT_1:72
          .= (Exec (l,s2)).a by A25,A30,SCMFSA_2:98
          .= (Exec (l,s2) | (Int-Locations \/ FinSeq-Locations \ {db})).x by
        A27,FUNCT_1:72;
      end;
      suppose
        x in FinSeq-Locations;
        then reconsider a = x as FinSeq-Location by SCMFSA_2:12;
A32:    a in (Int-Locations \/ FinSeq-Locations \/ {IC SCM+FSA}) by A28,
        XBOOLE_0:def 3;
        thus (Exec (l,s1) | (Int-Locations \/ FinSeq-Locations \ {db})).x = (
        Exec (l,s1)).a by A27,FUNCT_1:72
          .= s1.a by A25,SCMFSA_2:98
          .= (s1 | (Int-Locations \/ FinSeq-Locations \/ {IC SCM+FSA})).a by
        A32,FUNCT_1:72
          .= s2.a by A2,A32,FUNCT_1:72
          .= (Exec (l,s2)).a by A25,SCMFSA_2:98
          .= (Exec (l,s2) | (Int-Locations \/ FinSeq-Locations \ {db})).x by
        A27,FUNCT_1:72;
      end;
    end;
    dom ((Exec (l,s1)) | (Int-Locations \/ FinSeq-Locations \ {db})) = (
    Int-Locations \/ FinSeq-Locations \ {db}) & dom ((Exec (l,s2)) | (
Int-Locations \/ FinSeq-Locations \ {db})) = (Int-Locations \/ FinSeq-Locations
    \ {db}) by A10,A6,RELAT_1:91;
    then
A33: Exec (l,s1) | (Int-Locations \/ FinSeq-Locations \ {db} ) = Exec (l,
    s2) | (Int-Locations \/ FinSeq-Locations \ {db} ) by A26,FUNCT_1:9;
    db in Int-Locations by SCMFSA_2:9;
    then db in Int-Locations \/ FinSeq-Locations by XBOOLE_0:def 3;
    then
A34: Int-Locations \/ FinSeq-Locations = Int-Locations \/ FinSeq-Locations
    \/ {db} by ZFMISC_1:46
      .= (Int-Locations \/ FinSeq-Locations \ {db} ) \/ {db} by XBOOLE_1:39;
    Exec (l,s1).IC SCM+FSA = Next IC s1 by A25,SCMFSA_2:98
      .= Exec (l,s2).IC SCM+FSA by A5,A25,SCMFSA_2:98;
    then
A35: Exec (l,s1) | {IC SCM+FSA} = Exec (l,s2) | {IC SCM+FSA} by A10,A6,
    GRFUNC_1:90;
A36: (ex k1 being Element of NAT st k1 = abs(s1.da) & Exec(l, s1).db = (s1
.fa)/. k1 )& ex k2 being Element of NAT st k2 = abs(s2.da) & Exec(l, s2).db = (
    s2. fa)/.k2 by A25,SCMFSA_2:98;
    fa in FinSeq-Locations by SCMFSA_2:10;
    then fa in Int-Locations \/ FinSeq-Locations by XBOOLE_0:def 3;
    then
A37: fa in (Int-Locations \/ FinSeq-Locations \/ {IC SCM+FSA}) by
    XBOOLE_0:def 3;
    then
A38: s1.fa = (s1 | (Int-Locations \/ FinSeq-Locations \/ {IC SCM+FSA})).fa
    by FUNCT_1:72
      .= s2.fa by A2,A37,FUNCT_1:72;
    da in Int-Locations by SCMFSA_2:9;
    then
A39: da in Int-Locations \/ FinSeq-Locations by XBOOLE_0:def 3;
    then
    s1.da = (s1 | (Int-Locations \/ FinSeq-Locations \/ {IC SCM+FSA})).da
    by A12,FUNCT_1:72
      .= s2.da by A2,A12,A39,FUNCT_1:72;
    then Exec (l,s1) | {db} = Exec(l,s2) | {db} by A11,A36,
    A38,GRFUNC_1:90;
    then DataPart Exec (l,s1) = DataPart Exec (l,s2) by A34,A33,RELAT_1:
    185,SCMFSA_2:127;
    hence thesis by A35,RELAT_1:185,SCMFSA_2:127;
  end;
  suppose
    InsCode l = 10;
    then consider da,db,fa such that
A40: l = (fa,da):=db by SCMFSA_2:63;
A41: for x being set st x in ((Int-Locations \/ FinSeq-Locations) \ {fa})
holds (Exec (l,s1) | (Int-Locations \/ FinSeq-Locations \ {fa})).x = (Exec (l,
    s2) | (Int-Locations \/ FinSeq-Locations \ {fa})).x
    proof
      let x be set;
      assume
A42:  x in ((Int-Locations \/ FinSeq-Locations) \ {fa});
      then
A43:  x in Int-Locations \/ FinSeq-Locations by XBOOLE_0:def 5;
A44:  not x in {fa} by A42,XBOOLE_0:def 5;
      per cases by A43,XBOOLE_0:def 3;
      suppose
        x in Int-Locations;
        then reconsider a = x as Int-Location by SCMFSA_2:11;
A45:    a in (Int-Locations \/ FinSeq-Locations \/ {IC SCM+FSA}) by A43,
        XBOOLE_0:def 3;
        thus (Exec (l,s1) | (Int-Locations \/ FinSeq-Locations \ {fa})).x = (
        Exec (l,s1)).a by A42,FUNCT_1:72
          .= s1.a by A40,SCMFSA_2:99
          .= (s1 | (Int-Locations \/ FinSeq-Locations \/ {IC SCM+FSA})).a by
        A45,FUNCT_1:72
          .= s2.a by A2,A45,FUNCT_1:72
          .= (Exec (l,s2)).a by A40,SCMFSA_2:99
          .= (Exec (l,s2) | (Int-Locations \/ FinSeq-Locations \ {fa})).x by
        A42,FUNCT_1:72;
      end;
      suppose
        x in FinSeq-Locations;
        then reconsider a = x as FinSeq-Location by SCMFSA_2:12;
A46:    a <> fa by A44,TARSKI:def 1;
A47:    a in (Int-Locations \/ FinSeq-Locations \/ {IC SCM+FSA}) by A43,
        XBOOLE_0:def 3;
        thus (Exec (l,s1) | (Int-Locations \/ FinSeq-Locations \ {fa})).x = (
        Exec (l,s1)).a by A42,FUNCT_1:72
          .= s1.a by A40,A46,SCMFSA_2:99
          .= (s1 | (Int-Locations \/ FinSeq-Locations \/ {IC SCM+FSA})).a by
        A47,FUNCT_1:72
          .= s2.a by A2,A47,FUNCT_1:72
          .= (Exec (l,s2)).a by A40,A46,SCMFSA_2:99
          .= (Exec (l,s2) | (Int-Locations \/ FinSeq-Locations \ {fa})).x by
        A42,FUNCT_1:72;
      end;
    end;
    dom ((Exec (l,s1)) | (Int-Locations \/ FinSeq-Locations \ {fa})) = (
    Int-Locations \/ FinSeq-Locations \ {fa}) & dom ((Exec (l,s2)) | (
Int-Locations \/ FinSeq-Locations \ {fa})) = (Int-Locations \/ FinSeq-Locations
    \ {fa}) by A10,A6,RELAT_1:91;
    then
A48: Exec (l,s1) | (Int-Locations \/ FinSeq-Locations \ {fa} ) = Exec (l,
    s2) | (Int-Locations \/ FinSeq-Locations \ {fa} ) by A41,FUNCT_1:9;
    fa in FinSeq-Locations by SCMFSA_2:10;
    then fa in Int-Locations \/ FinSeq-Locations by XBOOLE_0:def 3;
    then
A49: Int-Locations \/ FinSeq-Locations = Int-Locations \/ FinSeq-Locations
    \/ {fa} by ZFMISC_1:46
      .= (Int-Locations \/ FinSeq-Locations \ {fa} ) \/ {fa} by XBOOLE_1:39;
    fa in FinSeq-Locations by SCMFSA_2:10;
    then fa in Int-Locations \/ FinSeq-Locations by XBOOLE_0:def 3;
    then
A50: fa in (Int-Locations \/ FinSeq-Locations \/ {IC SCM+FSA}) by
    XBOOLE_0:def 3;
    then
A51: s1.fa = (s1 | (Int-Locations \/ FinSeq-Locations \/ {IC SCM+FSA})).fa
    by FUNCT_1:72
      .= s2.fa by A2,A50,FUNCT_1:72;
    db in Int-Locations by SCMFSA_2:9;
    then
A52: db in Int-Locations \/ FinSeq-Locations by XBOOLE_0:def 3;
    then
A53: s1.db = (s1 | (Int-Locations \/ FinSeq-Locations \/ {IC SCM+FSA}) ).
    db by A12,FUNCT_1:72
      .= s2.db by A2,A12,A52,FUNCT_1:72;
    Exec (l,s1).IC SCM+FSA = Next IC s1 by A40,SCMFSA_2:99
      .= Exec (l,s2).IC SCM+FSA by A5,A40,SCMFSA_2:99;
    then
A54: Exec (l,s1) | {IC SCM+FSA} = Exec (l,s2) | {IC SCM+FSA} by A10,A6,
    GRFUNC_1:90;
A55: (ex k1 being Element of NAT st k1 = abs(s1.da) & Exec(l, s1).fa = s1.
fa+*(k1,s1.db) )& ex k2 being Element of NAT st k2 = abs(s2.da) & Exec(l, s2).
    fa = s2.fa+*(k2,s2.db) by A40,SCMFSA_2:99;
    da in Int-Locations by SCMFSA_2:9;
    then
A56: da in Int-Locations \/ FinSeq-Locations by XBOOLE_0:def 3;
    then
    s1.da = (s1 | (Int-Locations \/ FinSeq-Locations \/ {IC SCM+FSA})).da
    by A12,FUNCT_1:72
      .= s2.da by A2,A12,A56,FUNCT_1:72;
    then Exec (l,s1) | {fa} = Exec(l,s2) | {fa} by A11,A55,A53,A51,
    GRFUNC_1:90;
    then DataPart Exec (l,s1) = DataPart Exec (l,s2) by A49,A48,RELAT_1:
    185,SCMFSA_2:127;
    hence thesis by A54,RELAT_1:185,SCMFSA_2:127;
  end;
  suppose
    InsCode l = 11;
    then consider da,fa such that
A57: l = da:=len fa by SCMFSA_2:64;
    fa in FinSeq-Locations by SCMFSA_2:10;
    then fa in Int-Locations \/ FinSeq-Locations by XBOOLE_0:def 3;
    then
A58: fa in (Int-Locations \/ FinSeq-Locations \/ {IC SCM+FSA}) by
    XBOOLE_0:def 3;
    then s1.fa = (s1 | (Int-Locations \/ FinSeq-Locations \/ {IC SCM+FSA})).
    fa by FUNCT_1:72
      .= s2.fa by A2,A58,FUNCT_1:72;
    then Exec (l,s1).da = len(s2.fa) by A57,SCMFSA_2:100
      .= Exec (l,s2).da by A57,SCMFSA_2:100;
    then
A59: Exec (l,s1) | {da} = Exec(l,s2) | {da} by A10,A6,GRFUNC_1:90;
    da in Int-Locations by SCMFSA_2:9;
    then da in Int-Locations \/ FinSeq-Locations by XBOOLE_0:def 3;
    then
A60: Int-Locations \/ FinSeq-Locations = Int-Locations \/
    FinSeq-Locations \/ {da} by ZFMISC_1:46
      .= (Int-Locations \/ FinSeq-Locations \ {da} ) \/ {da} by XBOOLE_1:39;
A61: for x being set st x in ((Int-Locations \/ FinSeq-Locations) \ {da})
holds (Exec (l,s1) | (Int-Locations \/ FinSeq-Locations \ {da})).x = (Exec (l,
    s2) | (Int-Locations \/ FinSeq-Locations \ {da})).x
    proof
      let x be set;
      assume
A62:  x in ((Int-Locations \/ FinSeq-Locations) \ {da});
      then
A63:  x in Int-Locations \/ FinSeq-Locations by XBOOLE_0:def 5;
A64:  not x in {da} by A62,XBOOLE_0:def 5;
      per cases by A63,XBOOLE_0:def 3;
      suppose
        x in Int-Locations;
        then reconsider a = x as Int-Location by SCMFSA_2:11;
A65:    a <> da by A64,TARSKI:def 1;
A66:    a in (Int-Locations \/ FinSeq-Locations \/ {IC SCM+FSA}) by A63
        , XBOOLE_0:def 3;
        thus (Exec (l,s1) | (Int-Locations \/ FinSeq-Locations \ {da})).x = (
        Exec (l,s1)).a by A62,FUNCT_1:72
          .= s1.a by A57,A65,SCMFSA_2:100
          .= (s1 | (Int-Locations \/ FinSeq-Locations \/ {IC SCM+FSA})).a by
        A66,FUNCT_1:72
          .= s2.a by A2,A66,FUNCT_1:72
          .= (Exec (l,s2)).a by A57,A65,SCMFSA_2:100
          .= (Exec (l,s2) | (Int-Locations \/ FinSeq-Locations \ {da})).x by
        A62,FUNCT_1:72;
      end;
      suppose
        x in FinSeq-Locations;
        then reconsider a = x as FinSeq-Location by SCMFSA_2:12;
A67:    a in (Int-Locations \/ FinSeq-Locations \/ {IC SCM+FSA}) by A63
        , XBOOLE_0:def 3;
        thus (Exec (l,s1) | (Int-Locations \/ FinSeq-Locations \ {da})).x = (
        Exec (l,s1)).a by A62,FUNCT_1:72
          .= s1.a by A57,SCMFSA_2:100
          .= (s1 | (Int-Locations \/ FinSeq-Locations \/ {IC SCM+FSA})).a by
        A67,FUNCT_1:72
          .= s2.a by A2,A67,FUNCT_1:72
          .= (Exec (l,s2)).a by A57,SCMFSA_2:100
          .= (Exec (l,s2) | (Int-Locations \/ FinSeq-Locations \ {da})).x by
        A62,FUNCT_1:72;
      end;
    end;
    Exec (l,s1).IC SCM+FSA = Next IC s1 by A57,SCMFSA_2:100
      .= Exec (l,s2).IC SCM+FSA by A5,A57,SCMFSA_2:100;
    then
A68: Exec (l,s1) | {IC SCM+FSA} = Exec (l,s2) | {IC SCM+FSA} by A10,A6,
    GRFUNC_1:90;
    dom ((Exec (l,s1)) | (Int-Locations \/ FinSeq-Locations \ {da})) = (
    Int-Locations \/ FinSeq-Locations \ {da}) & dom ((Exec (l,s2)) | (
Int-Locations \/ FinSeq-Locations \ {da})) = (Int-Locations \/ FinSeq-Locations
    \ {da}) by A10,A6,RELAT_1:91;
    then Exec (l,s1) | (Int-Locations \/ FinSeq-Locations \ {da} ) = Exec (l,
    s2) | (Int-Locations \/ FinSeq-Locations \ {da} ) by A61,FUNCT_1:9;
    then DataPart Exec (l,s1) = DataPart Exec (l,s2) by A60,A59,
    RELAT_1:185,SCMFSA_2:127;
    hence thesis by A68,RELAT_1:185,SCMFSA_2:127;
  end;
  suppose
    InsCode l = 12;
    then consider da,fa such that
A69: l = fa:=<0,...,0>da by SCMFSA_2:65;
A70: for x being set st x in ((Int-Locations \/ FinSeq-Locations) \ {fa})
holds (Exec (l,s1) | (Int-Locations \/ FinSeq-Locations \ {fa})).x = (Exec (l,
    s2) | (Int-Locations \/ FinSeq-Locations \ {fa})).x
    proof
      let x be set;
      assume
A71:  x in ((Int-Locations \/ FinSeq-Locations) \ {fa});
      then
A72:  x in Int-Locations \/ FinSeq-Locations by XBOOLE_0:def 5;
A73:  not x in {fa} by A71,XBOOLE_0:def 5;
      per cases by A72,XBOOLE_0:def 3;
      suppose
        x in Int-Locations;
        then reconsider a = x as Int-Location by SCMFSA_2:11;
A74:    a in (Int-Locations \/ FinSeq-Locations \/ {IC SCM+FSA}) by A72
        , XBOOLE_0:def 3;
        thus (Exec (l,s1) | (Int-Locations \/ FinSeq-Locations \ {fa})).x = (
        Exec (l,s1)).a by A71,FUNCT_1:72
          .= s1.a by A69,SCMFSA_2:101
          .= (s1 | (Int-Locations \/ FinSeq-Locations \/ {IC SCM+FSA})).a by
        A74,FUNCT_1:72
          .= s2.a by A2,A74,FUNCT_1:72
          .= (Exec (l,s2)).a by A69,SCMFSA_2:101
          .= (Exec (l,s2) | (Int-Locations \/ FinSeq-Locations \ {fa})).x by
        A71,FUNCT_1:72;
      end;
      suppose
        x in FinSeq-Locations;
        then reconsider a = x as FinSeq-Location by SCMFSA_2:12;
A75:    a <> fa by A73,TARSKI:def 1;
A76:    a in (Int-Locations \/ FinSeq-Locations \/ {IC SCM+FSA}) by A72
        , XBOOLE_0:def 3;
        thus (Exec (l,s1) | (Int-Locations \/ FinSeq-Locations \ {fa})).x = (
        Exec (l,s1)).a by A71,FUNCT_1:72
          .= s1.a by A69,A75,SCMFSA_2:101
          .= (s1 | (Int-Locations \/ FinSeq-Locations \/ {IC SCM+FSA})).a by
        A76,FUNCT_1:72
          .= s2.a by A2,A76,FUNCT_1:72
          .= (Exec (l,s2)).a by A69,A75,SCMFSA_2:101
          .= (Exec (l,s2) | (Int-Locations \/ FinSeq-Locations \ {fa})).x by
        A71,FUNCT_1:72;
      end;
    end;
    dom ((Exec (l,s1)) | (Int-Locations \/ FinSeq-Locations \ {fa})) = (
    Int-Locations \/ FinSeq-Locations \ {fa}) & dom ((Exec (l,s2)) | (
Int-Locations \/ FinSeq-Locations \ {fa})) = (Int-Locations \/ FinSeq-Locations
    \ {fa}) by A10,A6,RELAT_1:91;
    then
A77: Exec (l,s1) | (Int-Locations \/ FinSeq-Locations \ {fa} ) = Exec (l,
    s2) | (Int-Locations \/ FinSeq-Locations \ {fa} ) by A70,FUNCT_1:9;
    fa in FinSeq-Locations by SCMFSA_2:10;
    then fa in Int-Locations \/ FinSeq-Locations by XBOOLE_0:def 3;
    then
A78: Int-Locations \/ FinSeq-Locations = Int-Locations \/
    FinSeq-Locations \/ {fa} by ZFMISC_1:46
      .= (Int-Locations \/ FinSeq-Locations \ {fa} ) \/ {fa} by XBOOLE_1:39;
    Exec (l,s1).IC SCM+FSA = Next IC s1 by A69,SCMFSA_2:101
      .= Exec (l,s2).IC SCM+FSA by A5,A69,SCMFSA_2:101;
    then
A79: Exec (l,s1) | {IC SCM+FSA} = Exec (l,s2) | {IC SCM+FSA} by A10,A6,
    GRFUNC_1:90;
A80: (ex k1 being Element of NAT st k1 = abs(s1.da) & Exec(l, s1).fa = k1
|->0 )& ex k2 being Element of NAT st k2 = abs(s2.da) & Exec(l, s2).fa = k2 |->
    0 by A69,SCMFSA_2:101;
    da in Int-Locations by SCMFSA_2:9;
    then
A81: da in Int-Locations \/ FinSeq-Locations by XBOOLE_0:def 3;
    then s1.da = (s1 | (Int-Locations \/ FinSeq-Locations \/ {IC SCM+FSA})).
    da by A12,FUNCT_1:72
      .= s2.da by A2,A12,A81,FUNCT_1:72;
    then Exec (l,s1) | {fa} = Exec(l,s2) | {fa} by A11,A80,GRFUNC_1:90;
    then DataPart Exec (l,s1) = DataPart Exec (l,s2) by A78,A77,
    RELAT_1:185,SCMFSA_2:127;
    hence thesis by A79,RELAT_1:185,SCMFSA_2:127;
  end;
end;

begin :: Finite partial states of SCM+FSA

canceled 5;

theorem
  for i being Instruction of SCM+FSA, s being State of SCM+FSA, p being
  preProgram of SCM+FSA holds Exec (i, s +* p) = Exec (i,s) +* p
proof
  let i be Instruction of SCM+FSA, s be State of SCM+FSA, p be preProgram of
  SCM+FSA;
A1: now
    assume
    {IC SCM+FSA} meets NAT;
    then consider x being set such that
A2: x in {IC SCM+FSA} and
A3: x in NAT by XBOOLE_0:3;
    reconsider l = x as Instruction-Location of SCM+FSA by A3,AMI_1:def 4;
    l = IC SCM+FSA by A2,TARSKI:def 1;
    hence contradiction by AMI_1:48;
  end;
  Int-Locations \/ FinSeq-Locations misses NAT by SCMFSA_2:13,14,XBOOLE_1:
  70;
  then
  dom p c= NAT & Int-Locations \/ FinSeq-Locations \/ {IC SCM+FSA} misses
  NAT by A1,RELAT_1:def 18,XBOOLE_1:70;
  then
A4: Int-Locations \/ FinSeq-Locations \/ {IC SCM+FSA} misses dom p by
  XBOOLE_1:63;
  then
A5: s|(Int-Locations \/ FinSeq-Locations \/ {IC SCM+FSA}) = (s +* p) | (
  Int-Locations \/ FinSeq-Locations \/ {IC SCM+FSA}) by FUNCT_4:76;
A6: (Exec(i,s) +* p)|(Int-Locations \/ FinSeq-Locations \/ {IC SCM+FSA}) =
Exec(i,s)|(Int-Locations \/ FinSeq-Locations \/ {IC SCM+FSA}) by A4,FUNCT_4:76
    .= Exec(i,s +* p) | (Int-Locations \/ FinSeq-Locations \/ {IC SCM+FSA})
  by A5,Th4;
A7: Exec (i, s +* p)|NAT = (s +* p)|NAT by AMI_1:117
    .= s |(NAT) +* p|NAT by FUNCT_4:75
    .= Exec (i,s) |(NAT) +* p|NAT by AMI_1:117
    .= (Exec (i, s) +* p)|NAT by FUNCT_4:75;
  thus Exec (i, s +* p) = Exec (i, s +* p)| dom(Exec (i, s +* p)) by RELAT_1:
  97
    .= Exec (i, s +* p)| (Int-Locations \/ FinSeq-Locations \/ {IC SCM+FSA}
  \/ NAT) by AMI_1:79 ,SCMFSA_2:8
    .= (Exec (i, s) +* p)| (Int-Locations \/ FinSeq-Locations \/ {IC SCM+FSA
  }) +* (Exec (i, s) +* p)|NAT by A6,A7,FUNCT_4:83
    .= (Exec (i,s) +* p)| the carrier of SCM+FSA by FUNCT_4:83,SCMFSA_2:8
    .= (Exec (i,s) +* p)| dom(Exec (i, s) +* p) by AMI_1:79
    .= Exec (i,s) +* p by RELAT_1:97;
end;

theorem
  for s being State of SCM+FSA, iloc being Instruction-Location of
  SCM+FSA, a being Int-Location holds s.a = (s +* Start-At iloc).a
proof
  let s be State of SCM+FSA, iloc be Instruction-Location of SCM+FSA, a be
  Int-Location;
  a in the carrier of SCM+FSA;
  then a in dom s by AMI_1:79;
  then
A1: dom (Start-At iloc) = {IC SCM+FSA} & a in dom s \/ dom (Start-At iloc)
  by FUNCOP_1:19,XBOOLE_0:def 3;
  a <> IC SCM+FSA by SCMFSA_2:81;
  then not a in {IC SCM+FSA} by TARSKI:def 1;
  hence thesis by A1,FUNCT_4:def 1;
end;

theorem
  for s being State of SCM+FSA, iloc being Instruction-Location of
  SCM+FSA, a being FinSeq-Location holds s.a = (s +* Start-At iloc).a
proof
  let s be State of SCM+FSA, iloc be Instruction-Location of SCM+FSA, a be
  FinSeq-Location;
  a in the carrier of SCM+FSA;
  then a in dom s by AMI_1:79;
  then
A1: dom (Start-At iloc) = {IC SCM+FSA} & a in dom s \/ dom (Start-At iloc)
  by FUNCOP_1:19,XBOOLE_0:def 3;
  a <> IC SCM+FSA by SCMFSA_2:82;
  then not a in {IC SCM+FSA} by TARSKI:def 1;
  hence thesis by A1,FUNCT_4:def 1;
end;

begin :: Autonomic finite partial states of SCM+FSA

definition
  let la be Int-Location;
  let a be Integer;
  redefine func la .--> a -> FinPartState of SCM+FSA;
  coherence
  proof
    a is Element of INT & ObjectKind la = INT by INT_1:def 2,SCMFSA_2:26;
    hence thesis by AMI_1:59;
  end;
end;

canceled;

theorem Th14:
  for p being autonomic FinPartState of SCM+FSA st DataPart p <>
  {} holds IC SCM+FSA in dom p
proof
  let p be autonomic FinPartState of SCM+FSA;
  assume
  DataPart p <> {};
  then
A1: dom DataPart p <> {};
  assume
  not IC SCM+FSA in dom p;
  then
A2: dom p misses {IC SCM+FSA} by ZFMISC_1:56;
  p is not autonomic
  proof
    consider il being Element of (NAT) \ dom p;
    consider d2 being Element of Int-Locations \ dom p;
    consider d1 being Element of dom DataPart p;
A3: dom DataPart p c= Int-Locations \/ FinSeq-Locations by RELAT_1:87,
    SCMFSA_2:127;
    not NAT c= dom p;
    then
A4: (NAT) \ dom p <> {} by XBOOLE_1:37;
    then il in NAT by XBOOLE_0:def 5;
    then reconsider il as Instruction-Location of SCM+FSA by AMI_1:def 4;
    not Int-Locations c= dom p;
    then
A5: Int-Locations \ dom p <> {} by XBOOLE_1:37;
    then d2 in Int-Locations by XBOOLE_0:def 5;
    then reconsider d2 as Int-Location by SCMFSA_2:11;
A6: d1 in dom DataPart p by A1;
    dom DataPart p c= the carrier of SCM+FSA by AMI_1:80;
    then reconsider d1 as Element of SCM+FSA by A6;
    per cases by A6,A3,XBOOLE_0:def 3;
    suppose
      d1 in Int-Locations;
      then reconsider d1 as Int-Location by SCMFSA_2:11;
      set p1 = p +* ((il .--> (d1:=d2)) +* ( d2.--> 0) +* Start-At il);
      set p2 = p +* ((il .--> (d1:=d2)) +* ( d2.--> 1) +* Start-At il);
      consider s1 being State of SCM+FSA such that
A7:   p1 c= s1 by CARD_3:97;
      not il in dom p by A4,XBOOLE_0:def 5;
      then
A8:   dom p misses {il} by ZFMISC_1:56;
      not d2 in dom p by A5,XBOOLE_0:def 5;
      then
A9:   dom p misses {d2} by ZFMISC_1:56;
      consider s2 being State of SCM+FSA such that
A10:  p2 c= s2 by CARD_3:97;
      take s1,s2;
      dom ((il .--> (d1:=d2)) +* ( d2.--> 0) +* Start-At il) = dom((il
      .--> (d1:=d2)) +* ( d2.--> 0)) \/ dom(Start-At il) by FUNCT_4:def 1
        .= dom((il .--> (d1:=d2)) +* ( d2.--> 0)) \/ {IC SCM+FSA} by
      FUNCOP_1:19
        .= dom(il .--> (d1:=d2)) \/ dom ( d2.--> 0) \/ {IC SCM+FSA} by
      FUNCT_4:def 1
        .= {il} \/ dom ( d2.--> 0) \/ {IC SCM+FSA} by FUNCOP_1:19
        .= {il} \/ {d2} \/ {IC SCM+FSA} by FUNCOP_1:19;
      then dom p /\ dom ((il .--> (d1:=d2)) +* ( d2.--> 0) +* Start-At il) =
      dom p /\ ({il} \/ {d2}) \/ dom p /\ {IC SCM+FSA} by XBOOLE_1:23
        .= dom p /\ ({il} \/ {d2}) \/ {} by A2,XBOOLE_0:def 7
        .= dom p /\ {il} \/ dom p /\ {d2} by XBOOLE_1:23
        .= dom p /\ {il} \/ {} by A9,XBOOLE_0:def 7
        .= {} by A8,XBOOLE_0:def 7;
      then
      dom p misses dom ((il .--> (d1:=d2)) +* ( d2.--> 0) +* Start-At il)
      by XBOOLE_0:def 7;
      then p c= p1 by FUNCT_4:33;
      hence p c= s1 by A7,XBOOLE_1:1;
      dom ((il .--> (d1:=d2)) +* ( d2.--> 1) +* Start-At il) = dom((il
      .--> (d1:=d2)) +* ( d2.--> 1)) \/ dom(Start-At il) by FUNCT_4:def 1
        .= dom((il .--> (d1:=d2)) +* ( d2.--> 1)) \/ {IC SCM+FSA} by
      FUNCOP_1:19
        .= dom(il .--> (d1:=d2)) \/ dom ( d2.--> 1) \/ {IC SCM+FSA} by
      FUNCT_4:def 1
        .= {il} \/ dom ( d2.--> 1) \/ {IC SCM+FSA} by FUNCOP_1:19
        .= {il} \/ {d2} \/ {IC SCM+FSA} by FUNCOP_1:19;
      then dom p /\ dom ((il .--> (d1:=d2)) +* ( d2.--> 1) +* Start-At il) =
      dom p /\ ({il} \/ {d2}) \/ dom p /\ {IC SCM+FSA} by XBOOLE_1:23
        .= dom p /\ ({il} \/ {d2}) \/ {} by A2,XBOOLE_0:def 7
        .= dom p /\ {il} \/ dom p /\ {d2} by XBOOLE_1:23
        .= dom p /\ {il} \/ {} by A9,XBOOLE_0:def 7
        .= {} by A8,XBOOLE_0:def 7;
      then
      dom p misses dom ((il .--> (d1:=d2)) +* ( d2.--> 1) +* Start-At il)
      by XBOOLE_0:def 7;
      then p c= p2 by FUNCT_4:33;
      hence p c= s2 by A10,XBOOLE_1:1;
      take 1;
A11:  dom ((il .--> (d1:=d2)) +* ( d2.--> 1) +* Start-At il) = dom ((il
      .--> (d1:=d2)) +* ( d2.--> 1)) \/ dom(Start-At il) by FUNCT_4:def 1;
      dom ( Computation(s2,1)) = the carrier of SCM+FSA by AMI_1:79;
      then
A12:  dom ( Computation(s2,1)|dom p) = dom p by AMI_1:80,RELAT_1:91;
A13:  dom ((il .--> (d1:=d2)) +* ( d2.--> 1)) = dom (il .--> (d1:=d2)) \/
      dom ( d2.--> 1) by FUNCT_4:def 1;
A14:  dom ((il .--> (d1:=d2)) +* ( d2.--> 0) +* Start-At il) = dom ((il
      .--> (d1:=d2)) +* ( d2.--> 0)) \/ dom(Start-At il) by FUNCT_4:def 1;
A15:  dom p1 = dom p \/ dom ((il .--> (d1:=d2)) +* ( d2.--> 0) +*
      Start-At il) by FUNCT_4:def 1;
A16:  dom(Start-At il) = {IC SCM+FSA} by FUNCOP_1:19;
      then
A17:  IC SCM+FSA in dom (Start-At il) by TARSKI:def 1;
      then
A18:  IC SCM+FSA in dom ((il .--> (d1:=d2)) +* ( d2.--> 0) +* Start-At il
      ) by A14,XBOOLE_0:def 3;
      then IC SCM+FSA in dom p1 by A15,XBOOLE_0:def 3;
      then
A19:  IC s1 = p1.IC SCM+FSA by A7,GRFUNC_1:8
        .= ((il .--> (d1:=d2)) +* ( d2.--> 0) +* Start-At il).IC SCM+FSA by
      A18,FUNCT_4:14
        .= (Start-At il).IC SCM+FSA by A17,FUNCT_4:14
        .= il by FUNCOP_1:87;
      il <> IC SCM+FSA by AMI_1:48;
      then
A20:  not il in dom (Start-At il) by A16,TARSKI:def 1;
A21:  dom ((il .--> (d1:=d2)) +* ( d2.--> 0)) = dom (il .--> (d1:=d2)) \/
      dom ( d2.--> 0) by FUNCT_4:def 1;
      d2 <> IC SCM+FSA by SCMFSA_2:81;
      then
A22:  not d2 in dom (Start-At il) by A16,TARSKI:def 1;
A23:  dom (d2 .--> 0) = {d2} by FUNCOP_1:19;
      then
A24:  d2 in dom (d2 .--> 0) by TARSKI:def 1;
      then d2 in dom ((il .--> (d1:=d2)) +* ( d2.--> 0)) by A21,
      XBOOLE_0:
      def 3;
      then
A25:  d2 in dom ((il .--> (d1:=d2)) +* ( d2.--> 0) +* Start-At il) by A14
      ,XBOOLE_0:def 3;
      then d2 in dom p1 by A15,XBOOLE_0:def 3;
      then
A26:  s1.d2 = p1.d2 by A7,GRFUNC_1:8
        .= ((il .--> (d1:=d2)) +* ( d2.--> 0) +* Start-At il).d2 by A25,
      FUNCT_4:14
        .= ((il .--> (d1:=d2)) +* ( d2.--> 0)).d2 by A22,FUNCT_4:12
        .= (d2.--> 0).d2 by A24,FUNCT_4:14
        .= 0 by FUNCOP_1:87;
      il <> d2 by SCMFSA_2:84;
      then
A27:  not il in dom (d2 .--> 0) by A23,TARSKI:def 1;
      dom (il .--> (d1:=d2)) = {il} by FUNCOP_1:19;
      then il in dom (il .--> (d1:=d2)) by TARSKI:def 1;
      then il in dom ((il .--> (d1:=d2)) +* ( d2.--> 0)) by
      A21, XBOOLE_0:
      def 3;
      then
A28:  il in dom ((il .--> (d1:=d2)) +* ( d2.--> 0) +* Start-At il) by A14
      ,XBOOLE_0:def 3;
      then il in dom p1 by A15,XBOOLE_0:def 3;
      then
A29:  s1.il = p1.il by A7,GRFUNC_1:8
        .= ((il .--> (d1:=d2)) +* ( d2.--> 0) +* Start-At il).il by A28,
      FUNCT_4:14
        .= ((il .--> (d1:=d2)) +* ( d2.--> 0)).il by A20,FUNCT_4:12
        .= (il .--> (d1:=d2)).il by A27,FUNCT_4:12
        .=(d1:=d2) by FUNCOP_1:87;
      dom Computation(s1,1) = the carrier of SCM+FSA by AMI_1:79;
      then
A30:  dom ( Computation(s1,1)|dom p) = dom p by AMI_1:80,RELAT_1:91;
A31:  dom p2 = dom p \/ dom ((il .--> (d1:=d2)) +* ( d2.--> 1) +*
      Start-At il) by FUNCT_4:def 1;
A32:  dom(Start-At il) = {IC SCM+FSA} by FUNCOP_1:19;
      then
A33:  IC SCM+FSA in dom (Start-At il) by TARSKI:def 1;
      then
A34:  IC SCM+FSA in dom ((il .--> (d1:=d2)) +* ( d2.--> 1) +* Start-At il
      ) by A11,XBOOLE_0:def 3;
      then IC SCM+FSA in dom p2 by A31,XBOOLE_0:def 3;
      then
A35:  IC s2 = p2.IC SCM+FSA by A10,GRFUNC_1:8
        .= ((il .--> (d1:=d2)) +* ( d2.--> 1) +* Start-At il).IC SCM+FSA by
      A34,FUNCT_4:14
        .= (Start-At il).IC SCM+FSA by A33,FUNCT_4:14
        .= il by FUNCOP_1:87;
      d2 <> IC SCM+FSA by SCMFSA_2:81;
      then
A36:  not d2 in dom (Start-At il) by A32,TARSKI:def 1;
A37:  dom (d2 .--> 1) = {d2} by FUNCOP_1:19;
      then
A38:  d2 in dom (d2 .--> 1) by TARSKI:def 1;
      then d2 in dom ((il .--> (d1:=d2)) +* ( d2.--> 1)) by A13,
      XBOOLE_0:
      def 3;
      then
A39:  d2 in dom ((il .--> (d1:=d2)) +* ( d2.--> 1) +* Start-At il) by A11
      ,XBOOLE_0:def 3;
      then d2 in dom p2 by A31,XBOOLE_0:def 3;
      then
A40:  s2.d2 = p2.d2 by A10,GRFUNC_1:8
        .= ((il .--> (d1:=d2)) +* ( d2.--> 1) +* Start-At il).d2 by A39,
      FUNCT_4:14
        .= ((il .--> (d1:=d2)) +* ( d2.--> 1)).d2 by A36,FUNCT_4:12
        .= (d2.--> 1).d2 by A38,FUNCT_4:14
        .= 1 by FUNCOP_1:87;
      il <> IC SCM+FSA by AMI_1:48;
      then
A41:  not il in dom (Start-At il) by A32,TARSKI:def 1;
      il <> d2 by SCMFSA_2:84;
      then
A42:  not il in dom (d2 .--> 1) by A37,TARSKI:def 1;
      dom (il .--> (d1:=d2)) = {il} by FUNCOP_1:19;
      then il in dom (il .--> (d1:=d2)) by TARSKI:def 1;
      then il in dom ((il .--> (d1:=d2)) +* ( d2.--> 1)) by
      A13, XBOOLE_0:
      def 3;
      then
A43:  il in dom ((il .--> (d1:=d2)) +* ( d2.--> 1) +* Start-At il) by A11
      ,XBOOLE_0:def 3;
      then il in dom p2 by A31,XBOOLE_0:def 3;
      then
A44:  s2.il = p2.il by A10,GRFUNC_1:8
        .= ((il .--> (d1:=d2)) +* ( d2.--> 1) +* Start-At il).il by A43,
      FUNCT_4:14
        .= ((il .--> (d1:=d2)) +* ( d2.--> 1)).il by A41,FUNCT_4:12
        .= (il .--> (d1:=d2)).il by A42,FUNCT_4:12
        .=(d1:=d2) by FUNCOP_1:87;
A45:  Computation(s2,0+1).d1 = (Following Computation(s2,0)).d1 by AMI_1:
      14
        .= (Following s2).d1 by AMI_1:13
        .= 1 by A35,A44,A40,SCMFSA_2:89;
      DataPart p c= p by RELAT_1:88;
      then
A46:  dom DataPart p c= dom p by RELAT_1:25;
      Computation(s1,0+1).d1 = (Following Computation(s1,0)).d1 by AMI_1:
      14
        .= (Following s1).d1 by AMI_1:13
        .= 0 by A19,A29,A26,SCMFSA_2:89;
      then ( Computation(s1,1)|dom p).d1 = 0 by A6,A46,A30,FUNCT_1:70;
      hence Computation(s1,1)|dom p <> Computation(s2,1)|dom p by A6,A46,
      A12,A45,FUNCT_1:70;
    end;
    suppose
      d1 in FinSeq-Locations;
      then reconsider d1 as FinSeq-Location by SCMFSA_2:12;
      set p1 = p +* ((il .--> (d1:=<0,...,0>d2)) +* ( d2.--> 0) +* Start-At il
      );
      set p2 = p +* ((il .--> (d1:=<0,...,0>d2)) +* ( d2.--> 1) +* Start-At il
      );
      consider s1 being State of SCM+FSA such that
A47:  p1 c= s1 by CARD_3:97;
      not il in dom p by A4,XBOOLE_0:def 5;
      then
A48:  dom p misses {il} by ZFMISC_1:56;
A49:  dom ((il .--> (d1:=<0,...,0>d2)) +* ( d2.--> 0) +* Start-At il) =
dom ((il .--> (d1:=<0,...,0>d2)) +* ( d2.--> 0)) \/ dom(Start-At il) by FUNCT_4
      :def 1;
      consider k such that
A50:  k = abs(s1.d2) and
A51:  Exec(d1:=<0,...,0>d2, s1).d1 = k |-> 0 by SCMFSA_2:101;
A52:  dom ((il .--> (d1:=<0,...,0>d2)) +* ( d2.--> 0)) = dom (il .--> (
      d1:=<0,...,0>d2)) \/ dom ( d2.--> 0) by FUNCT_4:def 1;
A53:  dom p1 = dom p \/ dom ((il .--> (d1:=<0,...,0>d2)) +* ( d2.--> 0)
      +* Start-At il) by FUNCT_4:def 1;
A54:  dom(Start-At il) = {IC SCM+FSA} by FUNCOP_1:19;
      then
A55:  IC SCM+FSA in dom (Start-At il) by TARSKI:def 1;
      then
A56:  IC SCM+FSA in dom ((il .--> (d1:=<0,...,0>d2)) +* ( d2.--> 0) +*
      Start-At il) by A49,XBOOLE_0:def 3;
      then IC SCM+FSA in dom p1 by A53,XBOOLE_0:def 3;
      then
A57:  IC s1 = p1.IC SCM+FSA by A47,GRFUNC_1:8
        .= ((il .--> (d1:=<0,...,0>d2)) +* ( d2.--> 0) +* Start-At il).IC
      SCM+FSA by A56,FUNCT_4:14
        .= (Start-At il).IC SCM+FSA by A55,FUNCT_4:14
        .= il by FUNCOP_1:87;
      il <> IC SCM+FSA by AMI_1:48;
      then
A58:  not il in dom (Start-At il) by A54,TARSKI:def 1;
      consider s2 being State of SCM+FSA such that
A59:  p2 c= s2 by CARD_3:97;
      d2 <> IC SCM+FSA by SCMFSA_2:81;
      then
A60:  not d2 in dom (Start-At il) by A54,TARSKI:def 1;
A61:  dom (d2 .--> 0) = {d2} by FUNCOP_1:19;
      then
A62:  d2 in dom (d2 .--> 0) by TARSKI:def 1;
      then d2 in dom ((il .--> (d1:=<0,...,0>d2)) +* ( d2.--> 0)) by A52,
      XBOOLE_0:def 3;
      then
A63:  d2 in dom ((il .--> (d1:=<0,...,0>d2)) +* ( d2.--> 0) +* Start-At
      il) by A49,XBOOLE_0:def 3;
      then d2 in dom p1 by A53,XBOOLE_0:def 3;
      then s1.d2 = p1.d2 by A47,GRFUNC_1:8
        .= ((il .--> (d1:=<0,...,0>d2)) +* ( d2.--> 0) +* Start-At il).d2 by
      A63,FUNCT_4:14
        .= ((il .--> (d1:=<0,...,0>d2)) +* ( d2.--> 0)).d2 by A60,FUNCT_4:
      12
        .= (d2.--> 0).d2 by A62,FUNCT_4:14
        .= 0 by FUNCOP_1:87;
      then
A64:  k |-> 0 = 0 |-> 0 by A50,ABSVALUE:7
        .= {} by FINSEQ_2:72;
      not d2 in dom p by A5,XBOOLE_0:def 5;
      then
A65:  dom p misses {d2} by ZFMISC_1:56;
      il <> d2 by SCMFSA_2:84;
      then
A66:  not il in dom (d2 .--> 0) by A61,TARSKI:def 1;
      dom (il .--> (d1:=<0,...,0>d2)) = {il} by FUNCOP_1:19;
      then il in dom (il .--> (d1:=<0,...,0>d2)) by TARSKI:def 1;
      then il in dom ((il .--> (d1:=<0,...,0>d2)) +* ( d2.--> 0)) by
      A52,XBOOLE_0:def 3;
      then
A67:  il in dom ((il .--> (d1:=<0,...,0>d2)) +* ( d2.--> 0) +* Start-At
      il) by A49,XBOOLE_0:def 3;
      then il in dom p1 by A53,XBOOLE_0:def 3;
      then
A68:  s1.il = p1.il by A47,GRFUNC_1:8
        .= ((il .--> (d1:=<0,...,0>d2)) +* ( d2.--> 0) +* Start-At il).il by
      A67,FUNCT_4:14
        .= ((il .--> (d1:=<0,...,0>d2)) +* ( d2.--> 0)).il by A58,FUNCT_4:
      12
        .= (il .--> (d1:=<0,...,0>d2)).il by A66,FUNCT_4:12
        .=(d1:=<0,...,0>d2) by FUNCOP_1:87;
      dom Computation(s1,1) = the carrier of SCM+FSA by AMI_1:79;
      then
A69:  dom ( Computation(s1,1)|dom p) = dom p by AMI_1:80,RELAT_1:91;
A70:  dom ((il .--> (d1:=<0,...,0>d2)) +* ( d2.--> 1)) = dom (il .--> (
      d1:=<0,...,0>d2)) \/ dom ( d2.--> 1) by FUNCT_4:def 1;
      consider k such that
A71:  k = abs(s2.d2) and
A72:  Exec(d1:=<0,...,0>d2, s2).d1 = k |-> 0 by SCMFSA_2:101;
A73:  dom p2 = dom p \/ dom ((il .--> (d1:=<0,...,0>d2)) +* ( d2.--> 1)
      +* Start-At il) by FUNCT_4:def 1;
      take s1,s2;
      dom ((il .--> (d1:=<0,...,0>d2)) +* ( d2.--> 0) +* Start-At il) =
dom((il .--> (d1:=<0,...,0>d2)) +* ( d2.--> 0)) \/ dom(Start-At il) by FUNCT_4:
      def 1
        .= dom((il .--> (d1:=<0,...,0>d2)) +* ( d2.--> 0)) \/ {IC SCM+FSA}
      by FUNCOP_1:19
        .= dom(il .--> (d1:=<0,...,0>d2)) \/ dom ( d2.--> 0) \/ {IC SCM+FSA}
      by FUNCT_4:def 1
        .= {il} \/ dom ( d2.--> 0) \/ {IC SCM+FSA} by FUNCOP_1:19
        .= {il} \/ {d2} \/ {IC SCM+FSA} by FUNCOP_1:19;
      then dom p /\ dom ((il .--> (d1:=<0,...,0>d2)) +* ( d2.--> 0) +*
Start-At il) = dom p /\ ({il} \/ {d2}) \/ dom p /\ {IC SCM+FSA} by XBOOLE_1
      :23
        .= dom p /\ ({il} \/ {d2}) \/ {} by A2,XBOOLE_0:def 7
        .= dom p /\ {il} \/ dom p /\ {d2} by XBOOLE_1:23
        .= dom p /\ {il} \/ {} by A65,XBOOLE_0:def 7
        .= {} by A48,XBOOLE_0:def 7;
      then dom p misses dom ((il .--> (d1:=<0,...,0>d2)) +* ( d2.--> 0) +*
      Start-At il) by XBOOLE_0:def 7;
      then p c= p1 by FUNCT_4:33;
      hence p c= s1 by A47,XBOOLE_1:1;
      dom ((il .--> (d1:=<0,...,0>d2)) +* ( d2.--> 1) +* Start-At il) =
dom((il .--> (d1:=<0,...,0>d2)) +* ( d2.--> 1)) \/ dom(Start-At il) by FUNCT_4:
      def 1
        .= dom((il .--> (d1:=<0,...,0>d2)) +* ( d2.--> 1)) \/ {IC SCM+FSA}
      by FUNCOP_1:19
        .= dom(il .--> (d1:=<0,...,0>d2)) \/ dom ( d2.--> 1) \/ {IC SCM+FSA}
      by FUNCT_4:def 1
        .= {il} \/ dom ( d2.--> 1) \/ {IC SCM+FSA} by FUNCOP_1:19
        .= {il} \/ {d2} \/ {IC SCM+FSA} by FUNCOP_1:19;
      then dom p /\ dom ((il .--> (d1:=<0,...,0>d2)) +* ( d2.--> 1) +*
      Start-At il) = dom p /\ ({il} \/ {d2}) \/ dom p /\ {IC SCM+FSA} by
      XBOOLE_1:23
        .= dom p /\ ({il} \/ {d2}) \/ {} by A2,XBOOLE_0:def 7
        .= dom p /\ {il} \/ dom p /\ {d2} by XBOOLE_1:23
        .= dom p /\ {il} \/ {} by A65,XBOOLE_0:def 7
        .= {} by A48,XBOOLE_0:def 7;
      then dom p misses dom ((il .--> (d1:=<0,...,0>d2)) +* ( d2.--> 1) +*
      Start-At il) by XBOOLE_0:def 7;
      then p c= p2 by FUNCT_4:33;
      hence p c= s2 by A59,XBOOLE_1:1;
      take 1;
A74:  dom ((il .--> (d1:=<0,...,0>d2)) +* ( d2.--> 1) +* Start-At il) =
dom ((il .--> (d1:=<0,...,0>d2)) +* ( d2.--> 1)) \/ dom(Start-At il) by FUNCT_4
      :def 1;
A75:  dom(Start-At il) = {IC SCM+FSA} by FUNCOP_1:19;
      then
A76:  IC SCM+FSA in dom (Start-At il) by TARSKI:def 1;
      then
A77:  IC SCM+FSA in dom ((il .--> (d1:=<0,...,0>d2)) +* ( d2.--> 1) +*
      Start-At il) by A74,XBOOLE_0:def 3;
      then IC SCM+FSA in dom p2 by A73,XBOOLE_0:def 3;
      then
A78:  IC s2 = p2.IC SCM+FSA by A59,GRFUNC_1:8
        .= ((il .--> (d1:=<0,...,0>d2)) +* ( d2.--> 1) +* Start-At il).IC
      SCM+FSA by A77,FUNCT_4:14
        .= (Start-At il).IC SCM+FSA by A76,FUNCT_4:14
        .= il by FUNCOP_1:87;
      d2 <> IC SCM+FSA by SCMFSA_2:81;
      then
A79:  not d2 in dom (Start-At il) by A75,TARSKI:def 1;
A80:  dom (d2 .--> 1) = {d2} by FUNCOP_1:19;
      then
A81:  d2 in dom (d2 .--> 1) by TARSKI:def 1;
      then d2 in dom ((il .--> (d1:=<0,...,0>d2)) +* ( d2.--> 1)) by A70,
      XBOOLE_0:def 3;
      then
A82:  d2 in dom ((il .--> (d1:=<0,...,0>d2)) +* ( d2.--> 1) +* Start-At
      il) by A74,XBOOLE_0:def 3;
      then d2 in dom p2 by A73,XBOOLE_0:def 3;
      then s2.d2 = p2.d2 by A59,GRFUNC_1:8
        .= ((il .--> (d1:=<0,...,0>d2)) +* ( d2.--> 1) +* Start-At il).d2 by
      A82,FUNCT_4:14
        .= ((il .--> (d1:=<0,...,0>d2)) +* ( d2.--> 1)).d2 by A79,FUNCT_4:
      12
        .= (d2.--> 1).d2 by A81,FUNCT_4:14
        .= 1 by FUNCOP_1:87;
      then
A83:  k |-> 0 = 1 |-> 0 by A71,ABSVALUE:def 1
        .= <*0*> by FINSEQ_2:73;
      il <> IC SCM+FSA by AMI_1:48;
      then
A84:  not il in dom (Start-At il) by A75,TARSKI:def 1;
      il <> d2 by SCMFSA_2:84;
      then
A85:  not il in dom (d2 .--> 1) by A80,TARSKI:def 1;
      dom (il .--> (d1:=<0,...,0>d2)) = {il} by FUNCOP_1:19;
      then il in dom (il .--> (d1:=<0,...,0>d2)) by TARSKI:def 1;
      then il in dom ((il .--> (d1:=<0,...,0>d2)) +* ( d2.--> 1)) by
      A70,XBOOLE_0:def 3;
      then
A86:  il in dom ((il .--> (d1:=<0,...,0>d2)) +* ( d2.--> 1) +* Start-At
      il) by A74,XBOOLE_0:def 3;
      then il in dom p2 by A73,XBOOLE_0:def 3;
      then
A87:  s2.il = p2.il by A59,GRFUNC_1:8
        .= ((il .--> (d1:=<0,...,0>d2)) +* ( d2.--> 1) +* Start-At il).il by
      A86,FUNCT_4:14
        .= ((il .--> (d1:=<0,...,0>d2)) +* ( d2.--> 1)).il by A84,FUNCT_4:
      12
        .= (il .--> (d1:=<0,...,0>d2)).il by A85,FUNCT_4:12
        .=(d1:=<0,...,0>d2) by FUNCOP_1:87;
A88:  Computation(s2,0+1).d1 = (Following Computation(s2,0)).d1 by AMI_1
      :14
        .= (Following s2).d1 by AMI_1:13
        .= <*0*> by A78,A87,A72,A83;
      dom ( Computation(s2,1)) = the carrier of SCM+FSA by AMI_1:79;
      then
A89:  dom ( Computation(s2,1)|dom p) = dom p by AMI_1:80,RELAT_1:91;
      DataPart p c= p by RELAT_1:88;
      then
A90:  dom DataPart p c= dom p by RELAT_1:25;
      Computation(s1,0+1).d1 = (Following Computation(s1,0)).d1 by AMI_1
      :14
        .= (Following s1).d1 by AMI_1:13
        .= {} by A57,A68,A51,A64;
      then ( Computation(s1,1)|dom p).d1 = {} by A6,A90,A69,FUNCT_1:70;
      hence Computation(s1,1)|dom p <> Computation(s2,1)|dom p by A6,A90,
      A89,A88,FUNCT_1:70;
    end;
  end;
  hence contradiction;
end;

registration
  cluster autonomic non NAT-defined FinPartState of SCM+FSA;
  existence
  proof
    set P = (IC SCM+FSA, insloc 0)-->(insloc 0, halt SCM+FSA);
    P = Start-At(insloc 0)+*((insloc 0) .--> halt SCM+FSA) by FUNCT_4:def
    4;
    then reconsider P as FinPartState of SCM+FSA;
    take P;
    ObjectKind insloc 0 = the Instructions of SCM+FSA & ObjectKind IC
    SCM+FSA = NAT by AMI_1:def 11,def 14;
    hence P is autonomic by AMI_1:67;
    now
      assume
A1:   dom P c= NAT;
A2:   dom P = { IC SCM+FSA, insloc 0 } by FUNCT_4:65;
      then IC SCM+FSA in dom P by TARSKI:def 2;
      then reconsider l = IC SCM+FSA as Instruction-Location of SCM+FSA by A1,
      AMI_1:def 4;
      l in dom P by A2,TARSKI:def 2;
      hence contradiction by AMI_1:48;
    end;
    hence thesis by RELAT_1:def 18;
  end;
end;

theorem Th15:
  for p being autonomic non NAT-defined FinPartState of SCM+FSA
  holds IC SCM+FSA in dom p
proof
  let p be autonomic non NAT-defined FinPartState of SCM+FSA;
A1: dom p = dom p /\ the carrier of SCM+FSA by AMI_1:80,XBOOLE_1:28
    .= dom p /\ (Int-Locations \/ FinSeq-Locations \/ {IC SCM+FSA}) \/ dom p
  /\ NAT by SCMFSA_2:8,XBOOLE_1:23;
  not dom p c= NAT by RELAT_1:def 18;
  then dom p /\ (Int-Locations \/ FinSeq-Locations \/ {IC SCM+FSA}) <> {} by
  A1,XBOOLE_1:17;
  then
A2: dom p /\ {IC SCM+FSA} \/ dom p /\ (Int-Locations \/ FinSeq-Locations) <>
  {} by XBOOLE_1:23;
  per cases by A2;
  suppose
    dom p /\ {IC SCM+FSA} <> {};
    then dom p meets {IC SCM+FSA} by XBOOLE_0:def 7;
    hence thesis by ZFMISC_1:56;
  end;
  suppose
    dom p /\ (Int-Locations \/ FinSeq-Locations) <> {};
    then DataPart p <> {} by RELAT_1:60,90,SCMFSA_2:127;
    hence thesis by Th14;
  end;
end;

theorem
  for p being autonomic FinPartState of SCM+FSA st IC SCM+FSA in dom p
  holds IC p in dom p
proof
  let p be autonomic FinPartState of SCM+FSA;
  assume
A1: IC SCM+FSA in dom p;
  set il = IC p;
  set p1 = p +* ((il .--> goto insloc 0));
  set p2 = p +* ((il .--> goto insloc 1));
  consider s1 being State of SCM+FSA such that
A2: p1 c= s1 by CARD_3:97;
  consider s2 being State of SCM+FSA such that
A3: p2 c= s2 by CARD_3:97;
  assume
A4: not IC p in dom p;
  p is not autonomic
  proof
    take s1,s2;
A5: dom (il .--> (goto insloc 1)) = {il} by FUNCOP_1:19;
    then
A6: il in dom (il .--> (goto insloc 1)) by TARSKI:def 1;
A7: dom p misses {il} by A4,ZFMISC_1:56;
    then
A8: p c= p2 by A5,FUNCT_4:33;
    dom p2 = dom p \/ dom ((il .--> goto insloc 1)) by FUNCT_4:def 1;
    then il in dom p2 by A6,XBOOLE_0:def 3;
    then s2.il = p2.il by A3,GRFUNC_1:8
      .= ((il .--> goto insloc 1)).il by A6,FUNCT_4:14
      .= goto insloc 1 by FUNCOP_1:87;
    then
A9: (Following s2).IC SCM+FSA = Exec (goto insloc 1,s2).IC SCM+FSA by A1,
    A3,A8,AMI_1:97,XBOOLE_1:1
      .= insloc 1 by SCMFSA_2:95;
A10: dom (il .--> (goto insloc 0)) = {il} by FUNCOP_1:19;
    then
A11: il in dom (il .--> (goto insloc 0)) by TARSKI:def 1;
A12: p c= p1 by A10,A7,FUNCT_4:33;
    hence p c= s1 & p c= s2 by A2,A3,A8,XBOOLE_1:1;
    take 1;
    assume
A13: Computation(s1,1)|dom p = Computation(s2,1)|dom p;
A14: (Following(s1))|dom p = (Following ( Computation(s1,0)))|dom p by
    AMI_1:13
      .= Computation(s1,0+1)|dom p by AMI_1:14
      .= (Following ( Computation(s2,0)))|dom p by A13,AMI_1:14
      .= (Following(s2))|dom p by AMI_1:13;
    dom p1 = dom p \/ dom ((il .--> goto insloc 0)) by FUNCT_4:def 1;
    then il in dom p1 by A11,XBOOLE_0:def 3;
    then s1.il = p1.il by A2,GRFUNC_1:8
      .= ((il .--> goto insloc 0)).il by A11,FUNCT_4:14
      .= goto insloc 0 by FUNCOP_1:87;
    then
    (Following s1).IC SCM+FSA = Exec (goto insloc 0,s1).IC SCM+FSA by A1,
    A2,A12,AMI_1:97,XBOOLE_1:1
      .= insloc 0 by SCMFSA_2:95;
    then insloc 0 = ((Following(s1))|dom p).IC SCM+FSA by A1,FUNCT_1:72
      .= insloc 1 by A1,A9,A14,FUNCT_1:72;
    hence contradiction;
  end;
  hence contradiction;
end;

theorem Th17:
  for p being autonomic non NAT-defined FinPartState of SCM+FSA, s
  being State of SCM+FSA st p c= s for i being Element of NAT holds IC
  Computation(s,i) in dom ProgramPart(p)
proof
  let p be autonomic non NAT-defined FinPartState of SCM+FSA, s be State of
  SCM+FSA such that
A1: p c= s;
  let i be Element of NAT;
  set Csi = Computation(s,i);
  set loc = IC Csi;
  reconsider ll = loc as Element of NAT by ORDINAL1:def 13;
  set loc1 = insloc(ll+1);
A2: loc in NAT by AMI_1:def 4;
A3: loc in dom ProgramPart p iff loc in dom p /\ NAT by RELAT_1:90;
  assume
  not IC Computation(s,i) in dom ProgramPart(p);
  then
A4: not loc in dom p by A2,A3,XBOOLE_0:def 4;
  set p2 = p +* (loc .--> goto loc1);
  set p1 = p +* (loc .--> goto loc);
A5: dom p1 = dom p \/ dom (loc .--> goto loc) by FUNCT_4:def 1;
A6: dom (loc .--> goto loc1) = {loc} by FUNCOP_1:19;
  then
A7: loc in dom (loc .--> goto loc1) by TARSKI:def 1;
A8: dom p2 = dom p \/ dom (loc .--> goto loc1) by FUNCT_4:def 1;
  then
A9: loc in dom p2 by A7,XBOOLE_0:def 3;
  consider s2 being State of SCM+FSA such that
A10: p2 c= s2 by CARD_3:97;
  set Cs2i = Computation(s2,i);
  consider s1 being State of SCM+FSA such that
A11: p1 c= s1 by CARD_3:97;
  set Cs1i = Computation(s1,i);
A12: dom (loc .--> goto loc) = {loc} by FUNCOP_1:19;
  then
A13: loc in dom (loc .--> goto loc) by TARSKI:def 1;
  then
A14: loc in dom p1 by A5,XBOOLE_0:def 3;
  p is not autonomic
  proof
A15: now
      let x be set;
      assume
A16:  x in dom p;
      dom p misses dom (loc .--> goto loc1) by A4,A6,ZFMISC_1:56;
      then
A17:  p.x = p2.x by A16,FUNCT_4:17;
      x in dom p2 by A8,A16,XBOOLE_0:def 3;
      hence p.x = s2.x by A10,A17,GRFUNC_1:8;
    end;
    (loc .--> goto loc1).loc = goto loc1 by FUNCOP_1:87;
    then p2.loc = goto loc1 by A7,FUNCT_4:14;
    then s2.loc = goto loc1 by A9,A10,GRFUNC_1:8;
    then
A18: Cs2i.loc = goto loc1 by AMI_1:54;
    (loc .--> goto loc).loc = goto loc by FUNCOP_1:87;
    then p1.loc = goto loc by A13,FUNCT_4:14;
    then s1.loc = goto loc by A14,A11,GRFUNC_1:8;
    then
A19: Cs1i.loc = goto loc by AMI_1:54;
    take s1, s2;
A20: now
      let x be set;
      assume
A21:  x in dom p;
      dom p misses dom (loc .--> goto loc) by A4,A12,ZFMISC_1:56;
      then
A22:  p.x = p1.x by A21,FUNCT_4:17;
      x in dom p1 by A5,A21,XBOOLE_0:def 3;
      hence p.x = s1.x by A11,A22,GRFUNC_1:8;
    end;
    dom s1 = the carrier of SCM+FSA by AMI_1:79;
    then dom p c= dom s1 by AMI_1:80;
    hence
A23: p c= s1 by A20,GRFUNC_1:8;
    then
A24: (Cs1i|dom p) = (Csi|dom p) by A1,AMI_1:def 25;
    dom s2 = the carrier of SCM+FSA by AMI_1:79;
    then dom p c= dom s2 by AMI_1:80;
    hence p c= s2 by A15,GRFUNC_1:8;
    then
A25: (Cs1i|dom p) = (Cs2i|dom p) by A23,AMI_1:def 25;
    take k = i+1;
    set Cs1k = Computation(s1,k);
A26: Cs1k = Following Cs1i by AMI_1:14
      .= Exec (CurInstr Cs1i, Cs1i);
A27: Csi.IC SCM+FSA = (Csi|dom p).IC SCM+FSA by Th15,FUNCT_1:72;
    then Cs1i.IC SCM+FSA = loc by A24,Th15,FUNCT_1:72;
    then
A28: Cs1k.IC SCM+FSA = loc by A26,A19,SCMFSA_2:95;
    set Cs2k = Computation(s2,k);
A29: Cs2k = Following Cs2i by AMI_1:14
      .= Exec (CurInstr Cs2i, Cs2i);
    Cs2i.IC SCM+FSA = loc by A24,A27,A25,Th15,FUNCT_1:72;
    then
A30: Cs2k.IC SCM+FSA = loc1 by A29,A18,SCMFSA_2:95;
    (Cs1k|dom p).IC SCM+FSA = Cs1k.IC SCM+FSA & (Cs2k|dom p).IC SCM+FSA =
    Cs2k. IC SCM+FSA by Th15,FUNCT_1:72;
    hence Cs1k|dom p <> Cs2k|dom p by A28,A30;
  end;
  hence contradiction;
end;

theorem Th18:
  for p being autonomic non NAT-defined FinPartState of SCM+FSA,
  s1, s2 being State of SCM+FSA st p c= s1 & p c= s2 for i being Element of NAT
holds IC Computation(s1,i) = IC Computation(s2,i) & CurInstr ( Computation(s1,i
  )) = CurInstr ( Computation(s2,i))
proof
  let p be autonomic non NAT-defined FinPartState of SCM+FSA, s1, s2 be State
  of SCM+FSA such that
A1: p c= s1 and
A2: p c= s2;
  let i be Element of NAT;
  set Cs1i = Computation(s1,i);
  set Cs2i = Computation(s2,i);
  thus
A3: IC Cs1i = IC Cs2i
  proof
    assume
A4: IC Computation(s1,i) <> IC Computation(s2,i);
    (Cs1i|dom p).IC SCM+FSA = Cs1i.IC SCM+FSA & (Cs2i|dom p).IC SCM+FSA =
    Cs2i. IC SCM+FSA by Th15,FUNCT_1:72;
    hence contradiction by A1,A2,A4,AMI_1:def 25;
  end;
  set I = CurInstr ( Computation(s1,i));
  thus I = CurInstr ( Computation(s2,i))
  proof
    ProgramPart p c= p by RELAT_1:88;
    then
A5: dom ProgramPart p c= dom p by GRFUNC_1:8;
    IC Cs2i in dom ProgramPart p by A2,Th17;
    then
A6: (Cs2i|dom p).IC Cs2i = Cs2i.IC Cs2i by A5,FUNCT_1:72;
    IC Cs1i in dom ProgramPart p by A1,Th17;
    then
A7: (Cs1i|dom p).IC Cs1i = Cs1i.IC Cs1i by A5,FUNCT_1:72;
    assume
    I <> CurInstr ( Computation(s2,i));
    hence contradiction by A1,A2,A3,A7,A6,AMI_1:def 25;
  end;
end;

theorem
  for p being autonomic non NAT-defined FinPartState of SCM+FSA, s1, s2
being State of SCM+FSA st p c= s1 & p c= s2 for i being Element of NAT, da, db
  being Int-Location st CurInstr ( Computation(s1,i)) = da := db & da in dom p
  holds Computation(s1,i).db = Computation(s2,i).db
proof
  let p be autonomic non NAT-defined FinPartState of SCM+FSA, s1, s2 be State
  of SCM+FSA such that
A1: p c= s1 & p c= s2;
  let i be Element of NAT, da, db be Int-Location;
  set I = CurInstr ( Computation(s1,i));
  set Cs1i = Computation(s1,i);
  set Cs2i = Computation(s2,i);
  set Cs1i1 = Computation(s1,i+1);
  set Cs2i1 = Computation(s2,i+1);
A2: Cs2i1 = Following Cs2i by AMI_1:14
    .= Exec (CurInstr Cs2i, Cs2i);
A3: da in dom p implies (Cs1i1|dom p).da = Cs1i1.da & (Cs2i1|dom p).da =
  Cs2i1.da by FUNCT_1:72;
  assume that
A4: I = da := db and
A5: da in dom p & Computation(s1,i).db <> Computation(s2,i).db;
  Cs1i1 = Following Cs1i by AMI_1:14
    .= Exec (CurInstr Cs1i, Cs1i);
  then
A6: Cs1i1.da = Cs1i.db by A4,SCMFSA_2:89;
  I = CurInstr ( Computation(s2,i)) by A1,Th18;
  then Cs2i1.da = Cs2i.db by A2,A4,SCMFSA_2:89;
  hence contradiction by A1,A3,A5,A6,AMI_1:def 25;
end;

theorem
  for p being autonomic non NAT-defined FinPartState of SCM+FSA, s1, s2
being State of SCM+FSA st p c= s1 & p c= s2 for i being Element of NAT, da, db
being Int-Location st CurInstr ( Computation(s1,i)) = AddTo(da, db) & da in dom
  p holds Computation(s1,i).da + Computation(s1,i).db = Computation(s2,i).da +
  Computation(s2,i).db
proof
  let p be autonomic non NAT-defined FinPartState of SCM+FSA, s1, s2 be State
  of SCM+FSA such that
A1: p c= s1 & p c= s2;
  let i be Element of NAT, da, db be Int-Location;
  set I = CurInstr ( Computation(s1,i));
  set Cs1i = Computation(s1,i);
  set Cs2i = Computation(s2,i);
  set Cs1i1 = Computation(s1,i+1);
  set Cs2i1 = Computation(s2,i+1);
A2: Cs2i1 = Following Cs2i by AMI_1:14
    .= Exec (CurInstr Cs2i, Cs2i);
A3: da in dom p implies (Cs1i1|dom p).da = Cs1i1.da & (Cs2i1|dom p).da =
  Cs2i1.da by FUNCT_1:72;
  assume that
A4: I = AddTo(da, db) and
A5: da in dom p & Computation(s1,i).da + Computation(s1,i).db <>
  Computation(s2, i).da + Computation(s2,i).db;
  Cs1i1 = Following Cs1i by AMI_1:14
    .= Exec (CurInstr Cs1i, Cs1i);
  then
A6: Cs1i1.da = Cs1i.da + Cs1i.db by A4,SCMFSA_2:90;
  I = CurInstr ( Computation(s2,i)) by A1,Th18;
  then Cs2i1.da = Cs2i.da + Cs2i.db by A2,A4,SCMFSA_2:90;
  hence contradiction by A1,A3,A5,A6,AMI_1:def 25;
end;

theorem
  for p being autonomic non NAT-defined FinPartState of SCM+FSA, s1, s2
being State of SCM+FSA st p c= s1 & p c= s2 for i being Element of NAT, da, db
  being Int-Location st CurInstr ( Computation(s1,i)) = SubFrom(da, db) & da in
dom p holds Computation(s1,i).da - Computation(s1,i).db = Computation(s2,i).da
  - Computation(s2,i).db
proof
  let p be autonomic non NAT-defined FinPartState of SCM+FSA, s1, s2 be State
  of SCM+FSA such that
A1: p c= s1 & p c= s2;
  let i be Element of NAT, da, db be Int-Location;
  set I = CurInstr ( Computation(s1,i));
  set Cs1i = Computation(s1,i);
  set Cs2i = Computation(s2,i);
  set Cs1i1 = Computation(s1,i+1);
  set Cs2i1 = Computation(s2,i+1);
A2: Cs2i1 = Following Cs2i by AMI_1:14
    .= Exec (CurInstr Cs2i, Cs2i);
A3: da in dom p implies (Cs1i1|dom p).da = Cs1i1.da & (Cs2i1|dom p).da =
  Cs2i1.da by FUNCT_1:72;
  assume that
A4: I = SubFrom(da, db) and
A5: da in dom p & Computation(s1,i).da - Computation(s1,i).db <>
  Computation(s2, i).da - Computation(s2,i).db;
  Cs1i1 = Following Cs1i by AMI_1:14
    .= Exec (CurInstr Cs1i, Cs1i);
  then
A6: Cs1i1.da = Cs1i.da - Cs1i.db by A4,SCMFSA_2:91;
  I = CurInstr ( Computation(s2,i)) by A1,Th18;
  then Cs2i1.da = Cs2i.da - Cs2i.db by A2,A4,SCMFSA_2:91;
  hence contradiction by A1,A3,A5,A6,AMI_1:def 25;
end;

theorem
  for p being autonomic non NAT-defined FinPartState of SCM+FSA, s1, s2
being State of SCM+FSA st p c= s1 & p c= s2 for i being Element of NAT, da, db
  being Int-Location st CurInstr ( Computation(s1,i)) = MultBy(da, db) & da in
dom p holds Computation(s1,i).da * Computation(s1,i).db = Computation(s2,i).da
  * Computation(s2,i).db
proof
  let p be autonomic non NAT-defined FinPartState of SCM+FSA, s1, s2 be State
  of SCM+FSA such that
A1: p c= s1 & p c= s2;
  let i be Element of NAT, da, db be Int-Location;
  set I = CurInstr ( Computation(s1,i));
  set Cs1i = Computation(s1,i);
  set Cs2i = Computation(s2,i);
  set Cs1i1 = Computation(s1,i+1);
  set Cs2i1 = Computation(s2,i+1);
A2: Cs2i1 = Following Cs2i by AMI_1:14
    .= Exec (CurInstr Cs2i, Cs2i);
A3: da in dom p implies (Cs1i1|dom p).da = Cs1i1.da & (Cs2i1|dom p).da =
  Cs2i1.da by FUNCT_1:72;
  assume that
A4: I = MultBy(da, db) and
A5: da in dom p & Computation(s1,i).da * Computation(s1,i).db <>
  Computation(s2, i).da * Computation(s2,i).db;
  Cs1i1 = Following Cs1i by AMI_1:14
    .= Exec (CurInstr Cs1i, Cs1i);
  then
A6: Cs1i1.da = Cs1i.da * Cs1i.db by A4,SCMFSA_2:92;
  I = CurInstr ( Computation(s2,i)) by A1,Th18;
  then Cs2i1.da = Cs2i.da * Cs2i.db by A2,A4,SCMFSA_2:92;
  hence contradiction by A1,A3,A5,A6,AMI_1:def 25;
end;

theorem
  for p being autonomic non NAT-defined FinPartState of SCM+FSA, s1, s2
being State of SCM+FSA st p c= s1 & p c= s2 for i being Element of NAT, da, db
  being Int-Location st CurInstr ( Computation(s1,i)) = Divide(da, db) & da in
  dom p & da <> db holds Computation(s1,i).da div Computation(s1,i).db =
  Computation(s2,i).da div Computation(s2,i).db
proof
  let p be autonomic non NAT-defined FinPartState of SCM+FSA, s1, s2 be State
  of SCM+FSA such that
A1: p c= s1 & p c= s2;
  let i be Element of NAT, da, db be Int-Location;
  set I = CurInstr ( Computation(s1,i));
  set Cs1i = Computation(s1,i);
  set Cs2i = Computation(s2,i);
  set Cs1i1 = Computation(s1,i+1);
  set Cs2i1 = Computation(s2,i+1);
A2: Cs2i1 = Following Cs2i by AMI_1:14
    .= Exec (CurInstr Cs2i, Cs2i);
A3: da in dom p implies (Cs1i1|dom p).da = Cs1i1.da & (Cs2i1|dom p).da =
  Cs2i1.da by FUNCT_1:72;
  assume that
A4: I = Divide(da, db) and
A5: da in dom p and
A6: da <> db and
A7: Computation(s1,i).da div Computation(s1,i).db <> Computation(s2,i).
  da div Computation(s2,i).db;
  Cs1i1 = Following Cs1i by AMI_1:14
    .= Exec (CurInstr Cs1i, Cs1i);
  then
A8: Cs1i1.da = Cs1i.da div Cs1i.db by A4,A6,SCMFSA_2:93;
  I = CurInstr ( Computation(s2,i)) by A1,Th18;
  then Cs2i1.da = Cs2i.da div Cs2i.db by A2,A4,A6,SCMFSA_2:93;
  hence contradiction by A1,A3,A5,A7,A8,AMI_1:def 25;
end;

theorem
  for p being autonomic non NAT-defined FinPartState of SCM+FSA, s1, s2
being State of SCM+FSA st p c= s1 & p c= s2 for i being Element of NAT, da, db
  being Int-Location st CurInstr ( Computation(s1,i)) = Divide(da, db) & db in
dom p holds Computation(s1,i).da mod Computation(s1,i).db = Computation(s2,i).
  da mod Computation(s2,i).db
proof
  let p be autonomic non NAT-defined FinPartState of SCM+FSA, s1, s2 be State
  of SCM+FSA such that
A1: p c= s1 & p c= s2;
  let i be Element of NAT, da, db be Int-Location;
  set I = CurInstr ( Computation(s1,i));
  set Cs1i = Computation(s1,i);
  set Cs2i = Computation(s2,i);
  set Cs1i1 = Computation(s1,i+1);
  set Cs2i1 = Computation(s2,i+1);
A2: Cs2i1 = Following Cs2i by AMI_1:14
    .= Exec (CurInstr Cs2i, Cs2i);
  assume that
A3: I = Divide(da, db) and
A4: db in dom p and
A5: Computation(s1,i).da mod Computation(s1,i).db <> Computation(s2,i).
  da mod Computation(s2,i).db;
A6: (Cs1i1|dom p).db = Cs1i1.db & (Cs2i1|dom p).db = Cs2i1.db by A4,FUNCT_1:
  72;
  Cs1i1 = Following Cs1i by AMI_1:14
    .= Exec (CurInstr Cs1i, Cs1i);
  then
A7: Cs1i1.db = Cs1i.da mod Cs1i.db by A3,SCMFSA_2:93;
  I = CurInstr ( Computation(s2,i)) by A1,Th18;
  then Cs2i1.db = Cs2i.da mod Cs2i.db by A2,A3,SCMFSA_2:93;
  hence contradiction by A1,A5,A6,A7,AMI_1:def 25;
end;

theorem
  for p being autonomic non NAT-defined FinPartState of SCM+FSA, s1, s2
  being State of SCM+FSA st p c= s1 & p c= s2 for i being Element of NAT, da
  being Int-Location, loc being Instruction-Location of SCM+FSA st CurInstr (
Computation(s1,i)) = da=0_goto loc & loc <> Next (IC Computation(s1,i)) holds (
  Computation(s1,i).da = 0 iff Computation(s2,i).da = 0)
proof
  let p be autonomic non NAT-defined FinPartState of SCM+FSA, s1, s2 be State
  of SCM+FSA such that
A1: p c= s1 & p c= s2;
  let i be Element of NAT, da be Int-Location, loc be Instruction-Location of
  SCM+FSA;
  set I = CurInstr ( Computation(s1,i));
  set Cs1i = Computation(s1,i);
  set Cs2i = Computation(s2,i);
  set Cs1i1 = Computation(s1,i+1);
  set Cs2i1 = Computation(s2,i+1);
A2: Cs1i1 = Following Cs1i by AMI_1:14
    .= Exec (CurInstr Cs1i, Cs1i);
A3: Cs2i1 = Following Cs2i by AMI_1:14
    .= Exec (CurInstr Cs2i, Cs2i);
A4: (Cs1i1|dom p).IC SCM+FSA = Cs1i1.IC SCM+FSA & (Cs2i1|dom p).IC SCM+FSA =
  Cs2i1.IC SCM+FSA by Th15,FUNCT_1:72;
  assume that
A5: I = da=0_goto loc and
A6: loc <> Next (IC Computation(s1,i));
A7: I = CurInstr ( Computation(s2,i)) by A1,Th18;
A8: now
    assume
    Computation(s2,i).da = 0 & Computation(s1,i).da <> 0;
    then
    Cs2i1.IC SCM+FSA = loc & Cs1i1.IC SCM+FSA = Next IC Cs1i by A7,A2,A3,
    A5,SCMFSA_2:96;
    hence contradiction by A1,A4,A6,AMI_1:def 25;
  end;
A9: (Cs1i1|dom p) = (Cs2i1|dom p) by A1,AMI_1:def 25;
  now
    assume
    Computation(s1,i).da = 0 & Computation(s2,i).da <> 0;
    then
    Cs1i1.IC SCM+FSA = loc & Cs2i1.IC SCM+FSA = Next IC Cs2i by A7,A2,A3,
    A5,SCMFSA_2:96;
    hence contradiction by A1,A4,A9,A6,Th18;
  end;
  hence thesis by A8;
end;

theorem
  for p being autonomic non NAT-defined FinPartState of SCM+FSA, s1, s2
  being State of SCM+FSA st p c= s1 & p c= s2 for i being Element of NAT, da
  being Int-Location, loc being Instruction-Location of SCM+FSA st CurInstr (
Computation(s1,i)) = da>0_goto loc & loc <> Next (IC Computation(s1,i)) holds (
  Computation(s1,i).da > 0 iff Computation(s2,i).da > 0)
proof
  let p be autonomic non NAT-defined FinPartState of SCM+FSA, s1, s2 be State
  of SCM+FSA such that
A1: p c= s1 & p c= s2;
  let i be Element of NAT, da be Int-Location, loc be Instruction-Location of
  SCM+FSA;
  set Cs1i1 = Computation(s1,i+1);
  set Cs2i1 = Computation(s2,i+1);
A2: (Cs1i1|dom p) = (Cs2i1|dom p) by A1,AMI_1:def 25;
  set Cs2i = Computation(s2,i);
  set Cs1i = Computation(s1,i);
  set I = CurInstr ( Computation(s1,i));
A3: Cs1i1 = Following Cs1i by AMI_1:14
    .= Exec (CurInstr Cs1i, Cs1i);
A4: (Cs1i1|dom p).IC SCM+FSA = Cs1i1.IC SCM+FSA & (Cs2i1|dom p).IC SCM+FSA =
  Cs2i1.IC SCM+FSA by Th15,FUNCT_1:72;
A5: Cs2i1 = Following Cs2i by AMI_1:14
    .= Exec (CurInstr Cs2i, Cs2i);
  assume that
A6: I = da>0_goto loc and
A7: loc <> Next (IC Computation(s1,i));
A8: I = CurInstr ( Computation(s2,i)) by A1,Th18;
A9: now
    assume that
A10: Computation(s2,i).da > 0 and
A11: Computation(s1,i).da <= 0;
    Cs2i1.IC SCM+FSA = loc by A8,A5,A6,A10,SCMFSA_2:97;
    hence contradiction by A3,A4,A2,A6,A7,A11,SCMFSA_2:97;
  end;
A12: IC Cs1i = IC Cs2i by A1,Th18;
  now
    assume that
A13: Computation(s1,i).da > 0 and
A14: Computation(s2,i).da <= 0;
    Cs1i1.IC SCM+FSA = loc by A3,A6,A13,SCMFSA_2:97;
    hence contradiction by A12,A8,A5,A4,A2,A6,A7,A14,SCMFSA_2:97;
  end;
  hence thesis by A9;
end;

theorem
  for p being autonomic non NAT-defined FinPartState of SCM+FSA, s1, s2
being State of SCM+FSA st p c= s1 & p c= s2 for i being Element of NAT, da, db
being Int-Location, f being FinSeq-Location st CurInstr ( Computation(s1,i)) =
  da := (f,db) & da in dom p for k1,k2 being Element of NAT st k1 = abs(
Computation(s1,i).db) & k2 = abs( Computation(s2,i).db) holds ( Computation(s1,
  i).f)/.k1 = ( Computation(s2,i).f)/.k2
proof
  let p be autonomic non NAT-defined FinPartState of SCM+FSA, s1, s2 be State
  of SCM+FSA such that
A1: p c= s1 & p c= s2;
  let i be Element of NAT, da, db be Int-Location, f be FinSeq-Location;
  set Cs1i1 = Computation(s1,i+1);
  set Cs2i1 = Computation(s2,i+1);
A2: Cs1i1|dom p = Cs2i1|dom p by A1,AMI_1:def 25;
  set Cs2i = Computation(s2,i);
  set Cs1i = Computation(s1,i);
  set I = CurInstr ( Computation(s1,i));
A3: Cs1i1 = Following Cs1i by AMI_1:14
    .= Exec (CurInstr Cs1i, Cs1i);
A4: da in dom p implies (Cs1i1|dom p).da = Cs1i1.da & (Cs2i1|dom p).da =
  Cs2i1.da by FUNCT_1:72;
A5: Cs2i1 = Following Cs2i by AMI_1:14
    .= Exec (CurInstr Cs2i, Cs2i);
  assume that
A6: I = da := (f,db) and
A7: da in dom p;
A8: (ex k1 being Element of NAT st k1 = abs(Cs1i.db) & Exec(I, Cs1i).da = (
Cs1i .f)/.k1 )& ex k2 being Element of NAT st k2 = abs(Cs2i.db) & Exec(I, Cs2i
  ). da = (Cs2i.f)/.k2 by A6,SCMFSA_2:98;
  let i1,i2 be Element of NAT;
  assume
  i1 = abs( Computation(s1,i).db) & i2 = abs( Computation(s2,i).db) &
  ( Computation(s1,i).f)/.i1 <> ( Computation(s2,i).f)/.i2;
  hence contradiction by A1,A3,A5,A4,A2,A7,A8,Th18;
end;

theorem
  for p being autonomic non NAT-defined FinPartState of SCM+FSA, s1, s2
being State of SCM+FSA st p c= s1 & p c= s2 for i being Element of NAT, da, db
being Int-Location, f being FinSeq-Location st CurInstr ( Computation(s1,i)) =
(f,db):=da & f in dom p for k1,k2 being Element of NAT st k1 = abs( Computation
  (s1,i).db) & k2 = abs( Computation(s2,i).db) holds Computation(s1,i).f+*(k1,
  Computation(s1,i).da) = Computation(s2,i).f+*(k2, Computation(s2,i).da)
proof
  let p be autonomic non NAT-defined FinPartState of SCM+FSA, s1, s2 be State
  of SCM+FSA such that
A1: p c= s1 & p c= s2;
  let i be Element of NAT, da, db be Int-Location, f be FinSeq-Location;
  set Cs1i1 = Computation(s1,i+1);
  set Cs2i1 = Computation(s2,i+1);
A2: Cs1i1|dom p = Cs2i1|dom p by A1,AMI_1:def 25;
  set Cs2i = Computation(s2,i);
  set Cs1i = Computation(s1,i);
  set I = CurInstr ( Computation(s1,i));
A3: Cs1i1 = Following Cs1i by AMI_1:14
    .= Exec (CurInstr Cs1i, Cs1i);
A4: f in dom p implies (Cs1i1|dom p).f = Cs1i1.f & (Cs2i1|dom p).f = Cs2i1.f
  by FUNCT_1:72;
A5: Cs2i1 = Following Cs2i by AMI_1:14
    .= Exec (CurInstr Cs2i, Cs2i);
  assume that
A6: I = (f,db):=da and
A7: f in dom p;
A8: (ex k1 being Element of NAT st k1 = abs(Cs1i.db) & Exec(I, Cs1i).f =
Cs1i.f +*(k1,Cs1i.da) )& ex k2 being Element of NAT st k2 = abs(Cs2i.db) & Exec
  (I, Cs2i).f = Cs2i.f+*(k2,Cs2i.da) by A6,SCMFSA_2:99;
  let i1, i2 be Element of NAT;
  assume
  i1 = abs(Cs1i.db) & i2 = abs(Cs2i.db) & Cs1i.f+*(i1,Cs1i.da) <> Cs2i
  .f+* (i2,Cs2i.da);
  hence contradiction by A1,A3,A5,A4,A2,A7,A8,Th18;
end;

theorem
  for p being autonomic non NAT-defined FinPartState of SCM+FSA, s1, s2
  being State of SCM+FSA st p c= s1 & p c= s2 for i being Element of NAT, da
being Int-Location, f being FinSeq-Location st CurInstr ( Computation(s1,i)) =
da :=len f & da in dom p holds len( Computation(s1,i).f) = len( Computation(s2,
  i).f)
proof
  let p be autonomic non NAT-defined FinPartState of SCM+FSA, s1, s2 be State
  of SCM+FSA such that
A1: p c= s1 & p c= s2;
  let i be Element of NAT, da be Int-Location, f be FinSeq-Location;
  set Cs1i1 = Computation(s1,i+1);
  set Cs2i1 = Computation(s2,i+1);
A2: Cs1i1|dom p = Cs2i1|dom p by A1,AMI_1:def 25;
  set Cs2i = Computation(s2,i);
  set Cs1i = Computation(s1,i);
  set I = CurInstr ( Computation(s1,i));
A3: Cs1i1 = Following Cs1i by AMI_1:14
    .= Exec (CurInstr Cs1i, Cs1i);
A4: da in dom p implies (Cs1i1|dom p).da = Cs1i1.da & (Cs2i1|dom p).da =
  Cs2i1.da by FUNCT_1:72;
A5: Cs2i1 = Following Cs2i by AMI_1:14
    .= Exec (CurInstr Cs2i, Cs2i);
  assume that
A6: I = da :=len f and
A7: da in dom p & len( Computation(s1,i).f) <> len( Computation(s2,i).f);
  Exec(I, Cs1i).da = len(Cs1i.f) & Exec(I, Cs2i).da = len(Cs2i.f) by A6,
  SCMFSA_2:100;
  hence contradiction by A1,A3,A5,A4,A2,A7,Th18;
end;

theorem
  for p being autonomic non NAT-defined FinPartState of SCM+FSA, s1, s2
  being State of SCM+FSA st p c= s1 & p c= s2 for i being Element of NAT, da
being Int-Location, f being FinSeq-Location st CurInstr ( Computation(s1,i)) =
  f:=<0,...,0>da & f in dom p for k1,k2 being Element of NAT st k1 = abs(
Computation(s1,i).da) & k2 = abs( Computation(s2,i).da) holds k1 |-> 0 = k2 |->
  0
proof
  let p be autonomic non NAT-defined FinPartState of SCM+FSA, s1, s2 be State
  of SCM+FSA such that
A1: p c= s1 & p c= s2;
  let i be Element of NAT, da be Int-Location, f be FinSeq-Location;
  set Cs1i1 = Computation(s1,i+1);
  set Cs2i1 = Computation(s2,i+1);
A2: Cs1i1|dom p = Cs2i1|dom p by A1,AMI_1:def 25;
  set Cs2i = Computation(s2,i);
  set Cs1i = Computation(s1,i);
  set I = CurInstr ( Computation(s1,i));
A3: Cs1i1 = Following Cs1i by AMI_1:14
    .= Exec (CurInstr Cs1i, Cs1i);
A4: f in dom p implies (Cs1i1|dom p).f = Cs1i1.f & (Cs2i1|dom p).f = Cs2i1.f
  by FUNCT_1:72;
A5: Cs2i1 = Following Cs2i by AMI_1:14
    .= Exec (CurInstr Cs2i, Cs2i);
  assume that
A6: I = f:=<0,...,0>da and
A7: f in dom p;
A8: (ex k1 being Element of NAT st k1 = abs(Cs1i.da) & Exec(I, Cs1i).f = k1
|->0 )& ex k2 being Element of NAT st k2 = abs(Cs2i.da) & Exec(I, Cs2i).f = k2
  |->0 by A6,SCMFSA_2:101;
  let i1, i2 be Element of NAT;
  assume
  i1 = abs(Cs1i.da) & i2 = abs(Cs2i.da) & i1 |-> 0 <> i2 |->0;
  hence contradiction by A1,A3,A5,A4,A2,A7,A8,Th18;
end;

