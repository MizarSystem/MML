:: The Construction and Computation of Conditional Statements for SCMPDS
::  by JingChao Chen
::
:: Received June 15, 1999
:: Copyright (c) 1999-2011 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies NUMBERS, SUBSET_1, SCMPDS_2, AMI_1, FSM_1, INT_1, AMI_2, RELAT_1,
      XBOOLE_0, GRAPHSP, XXREAL_0, CIRCUIT2, ARYTM_3, CARD_1, FUNCT_1, FUNCT_4,
      TARSKI, TURING_1, SCMFSA_7, SCMPDS_4, AMISTD_2, COMPLEX1, VALUED_1,
      SCMFSA6B, MSUALG_1, SCMPDS_5, SCMFSA8A, AMI_3, ARYTM_1, UNIALG_2,
      SCMFSA7B, SCMFSA8B, NAT_1, STRUCT_0, SCMPDS_6, ORDINAL1, PARTFUN1,
      SCMNORM, SCMFSA6C, COMPOS_1;
 notations TARSKI, XBOOLE_0, SUBSET_1, XCMPLX_0, RELAT_1, FUNCT_1, CARD_1,
      PARTFUN1, AFINSQ_1, VALUED_1, NUMBERS, COMPLEX1, FUNCT_4, INT_1, NAT_1,
      STRUCT_0, MEMSTR_0, COMPOS_1, EXTPRO_1, AMI_2, FUNCT_7, SCMPDS_2,
      SCMPDS_4, SCMPDS_5, XXREAL_0;
 constructors XXREAL_0, REAL_1, INT_2, SCMPDS_4, SCMPDS_5, VALUED_1, AMI_2,
      FUNCT_4, MEMSTR_0, SCMPDS_1, PRE_POLY, RELSET_1;
 registrations SETFAM_1, FUNCT_1, NUMBERS, XXREAL_0, XREAL_0, NAT_1, INT_1,
      SCMPDS_2, SCMPDS_4, SCMPDS_5, ORDINAL1, XBOOLE_0, MEMSTR_0, VALUED_1,
      AFINSQ_1, COMPOS_1, EXTPRO_1, PBOOLE, FUNCT_4, RELAT_1;
 requirements NUMERALS, REAL, SUBSET, BOOLE, ARITHM;
 definitions FUNCOP_1, COMPOS_1, EXTPRO_1, SCMPDS_4, SCMPDS_5, MEMSTR_0;
 theorems NAT_1, TARSKI, FUNCT_4, FUNCT_1, INT_1, SCMPDS_2, ABSVALUE, GRFUNC_1,
      SCMPDS_4, SCMPDS_5, XBOOLE_1, XREAL_1, ORDINAL1, FUNCOP_1, XXREAL_0,
      VALUED_1, PARTFUN1, MEMSTR_0, AFINSQ_1, COMPOS_1, EXTPRO_1, PBOOLE,
      RELAT_1;
 schemes NAT_1;

begin :: Preliminaries

reserve m,n for Element of NAT,
  a for Int_position,
  i,j for Instruction of SCMPDS,
  s,s1,s2 for State of SCMPDS,
  k1 for Integer,
  loc for Element of NAT,
  I,J,K for Program of SCMPDS;
set A = NAT;
set D = SCM-Data-Loc;

Lm1: (Stop SCMPDS). 0 = halt SCMPDS by AFINSQ_1:34;
Lm2:  0 in dom Stop SCMPDS by COMPOS_1:3;

reserve P,P1,P2 for Instruction-Sequence of SCMPDS;

canceled 5;

theorem Th15:
  card (i ';' I)= card I + 1
proof
  thus card (i ';' I) = card (Load i ';' I)
    .=card (Load i) + card I by AFINSQ_1:17
    .=card I+1 by COMPOS_1:54;
end;

theorem Th16:
  (i ';' I). 0=i
proof
  i ';' I=Load i ';' I &  0 in dom Load i by COMPOS_1:50;
  hence (i ';' I). 0 =(Load i). 0 by AFINSQ_1:def 3
    .=i by COMPOS_1:52;
end;

canceled 3;

theorem Th22:
  CurInstr(P +* stop(i ';' I),Initialize s) = i
proof
  set iI=i ';' I, P3 = P +* stop(i ';' I);
A2:  0 in dom Load i by COMPOS_1:50;
  card iI=card I +1 by Th15;
  then
A3:  0 in dom iI by AFINSQ_1:66;
   iI c= stop iI by AFINSQ_1:74;
   then dom iI c= dom stop iI by RELAT_1:11;
   then
B3:  0 in dom stop iI by A3;
A4:  (P +* stop(i ';' I))/.IC (Initialize s)
     = (P +* stop(i ';' I)).IC (Initialize s) by PBOOLE:143;
  P3.0 = (P +* stop(i ';' I)). 0
    .= (stop iI). 0 by B3,FUNCT_4:13
    .= iI. 0 by A3,COMPOS_1:63
    .=(Load i ';' I). 0
    .=(Load i). 0 by A2,AFINSQ_1:def 3
    .=i by COMPOS_1:52;
  hence thesis by A4,MEMSTR_0:47;
end;

theorem Th23:
  for s being State of SCMPDS,m1,m2 being Element of NAT st IC s=
   m1 holds ICplusConst(s,m2)= m1+m2
proof
  let s be State of SCMPDS,m1,m2 be Element of NAT;
   ex m st m = IC s & ICplusConst(s,m2) = abs(m+m2) by SCMPDS_2:def 18;
  hence thesis by ABSVALUE:def 1;
end;

theorem Th24:
  for I,J being Program of SCMPDS holds Shift(stop J,card I) c=
  stop(I ';' J)
proof
  let I,J be Program of SCMPDS;
  stop(I ';' J) =I ';' J ';' Stop SCMPDS
    .=I ';' (J ';' Stop SCMPDS) by AFINSQ_1:27
    .=I ';' (stop J);
  then stop(I ';' J) = I +* Shift(stop J, card I);
  hence thesis by FUNCT_4:25;
end;

canceled;

theorem
  for s being 0-started State of SCMPDS, i being No-StopCode parahalting
Instruction of SCMPDS,J being parahalting shiftable Program of SCMPDS, a being
  Int_position
     holds IExec(i ';' J,P,s).a = IExec(J,P,Initialize Exec(i,s)).a
proof
  let s be 0-started State of SCMPDS,
      i be No-StopCode parahalting Instruction of SCMPDS,
  J be parahalting shiftable Program of SCMPDS, a be Int_position;
  thus IExec(i ';' J,P,s).a = IExec(Load i ';' J,P,s).a
    .= IExec(J,P,Initialize IExec(Load i,P,s)).a by SCMPDS_5:35
    .= IExec(J,P,Initialize Exec(i,s)).a by SCMPDS_5:40;
end;

theorem
  for a being Int_position,k1,k2 being Integer holds (a,k1)
  <>0_goto k2 <> halt SCMPDS
proof
  let a be Int_position,k1,k2 be Integer;
  InsCode ((a,k1)<>0_goto k2) = 4 by SCMPDS_2:16;
  hence thesis by SCMPDS_2:12,81;
end;

theorem
  for a being Int_position,k1,k2 being Integer
   holds (a,k1) <=0_goto k2 <> halt SCMPDS
proof
  let a be Int_position,k1,k2 be Integer;
  InsCode ((a,k1)<=0_goto k2) = 5 by SCMPDS_2:17;
  hence thesis by SCMPDS_2:12,81;
end;

theorem
  for a being Int_position,k1,k2 being Integer
   holds (a,k1) >=0_goto k2 <> halt SCMPDS
proof
  let a be Int_position,k1,k2 be Integer;
  InsCode ((a,k1)>=0_goto k2) = 6 by SCMPDS_2:18;
  hence thesis by SCMPDS_2:12,81;
end;

definition
  let k1;
  func Goto k1 -> Program of SCMPDS equals
  Load goto k1;
  coherence;
end;

registration
  let n be Element of NAT;
  cluster goto (n+1) -> No-StopCode;
  correctness by SCMPDS_5:21;
  cluster goto -(n+1) -> No-StopCode;
  correctness
  proof
    -(n+1) <> 0;
    hence thesis by SCMPDS_5:21;
  end;
end;

registration
  let n be Element of NAT;
  cluster Goto (n+1) -> halt-free;
  correctness;
  cluster Goto -(n+1) -> halt-free;
  correctness;
end;



theorem Th33:
   0 in dom Goto k1 & (Goto k1). 0 = goto k1 by AFINSQ_1:34,65;

begin :: The predicates of is_closed_on and is_halting_on

definition
  let I be Program of SCMPDS;
  let s be State of SCMPDS;
  let P;
  pred I is_closed_on s,P means
  :Def2:
  for k being Element of NAT holds
   IC Comput(P+*stop I,Initialize s,k) in dom stop I;
  pred I is_halting_on s,P means
  :Def3:
  P+*stop I halts_on Initialize s;
end;

theorem Th34:
  for I being Program of SCMPDS holds I is paraclosed iff
  for s being State of SCMPDS, P holds I is_closed_on s,P
proof
  let I be Program of SCMPDS;
  hereby
    assume
A1: I is paraclosed;
    let s be State of SCMPDS;
    let P;
    stop I c= P +* stop I by FUNCT_4:25;
    then for n holds
     IC Comput(P+*stop I,Initialize s,n)
      in dom stop I by A1,SCMPDS_4:def 6;
    hence I is_closed_on s,P by Def2;
  end;
  assume
A2: for s being State of SCMPDS,P holds I is_closed_on s,P;
    let s be 0-started State of SCMPDS;
    let k be Element of NAT;
    let P;
A3:  Initialize s = s by MEMSTR_0:44;
    assume stop I c= P;
    then
A4: P = P +* stop I by FUNCT_4:98;
    I is_closed_on s,P by A2;
    hence IC Comput(P,s,k) in dom stop I by A3,A4,Def2;
end;

theorem Th35:
  for I being Program of SCMPDS holds I is parahalting iff
   for s being State of SCMPDS,P holds I is_halting_on s,P
proof
  let I be Program of SCMPDS;
  hereby
    assume
A1: I is parahalting;
    let s be State of SCMPDS, P;
    stop I c= P+*stop I by FUNCT_4:25;
    then
    P+*stop I halts_on Initialize s by A1,SCMPDS_4:def 7;
    hence I is_halting_on s,P by Def3;
  end;
  assume
A2: for s being State of SCMPDS, P holds I is_halting_on s,P;
    let s be 0-started State of SCMPDS, P;
A3:  Initialize s = s by MEMSTR_0:44;
    assume stop I c= P;
    then
A4: P = P +* stop I by FUNCT_4:98;
    I is_halting_on s,P by A2;
    hence P halts_on s by A4,Def3,A3;
end;

theorem Th36:
  for s1,s2 being State of SCMPDS, I being Program of SCMPDS st
  DataPart s1 = DataPart s2 holds I is_closed_on s1,P1
   implies I is_closed_on s2,P2
proof
  let s1,s2 be State of SCMPDS,I be Program of SCMPDS;
  set pI=stop I, S1 = Initialize s1, S2 = Initialize s2,
   E1 = P1 +* pI, E2 = P2 +* pI;
  assume
A3: DataPart s1 = DataPart s2;
A4: Comput(E2,S2,0) = Initialize s2 by EXTPRO_1:2;
A5: Comput(E1,S1,0) = Initialize s1 by EXTPRO_1:2;
  then
A6: DataPart Comput(E1,S1,0) = DataPart s1 by MEMSTR_0:45
    .= DataPart Comput(E2,S2,0) by A3,A4,MEMSTR_0:45;
  defpred P[Element of NAT] means IC Comput(E1,S1,$1) = IC Comput(E2,S2,$1)
   & CurInstr(E1,Comput(E1,S1,$1)) = CurInstr(E2,Comput(E2,S2,$1))
   & DataPart Comput(E1,S1,$1) = DataPart Comput(E2,S2,$1);
A7:  0 in dom pI by COMPOS_1:36;
  assume
A10: I is_closed_on s1,P1;
A11: now
    let k be Element of NAT;
A13: Comput(E2,S2,k+1) = Following(E2,Comput(E2,S2,k)) by EXTPRO_1:3;
    assume
A14: P[k];
    then
A15: for a holds Comput(E1,S1,k).a = Comput(E2,S2,k).
a by SCMPDS_4:8;
    pI c= P2 +* pI by FUNCT_4:25;
    then
A16: pI c= E2;
A17: IC Comput(E1,S1,k+1) in dom pI by A10,Def2;
A19: Comput(E1,S1,k+1) = Following(E1,Comput(E1,S1,k)) by EXTPRO_1:3;
    Comput(E1,S1,k) =  Comput(E2,S2,k) by A14,A15,SCMPDS_4:2;
     then
XX:  Comput(E1,S1,k+1) =  Comput(E2,S2,k+1) by A14,A13,A19;
   then
A20:  Comput(E1,S1,k+1)
     =  Comput(E2,S2,k+1);
A21: IC Comput(E1,S1,k+1) = IC Comput(E2,S2,k+1) by XX;
A22
:  E1/.IC Comput(E1,S1,k+1)
 = E1.IC Comput(E1,S1,k+1) by PBOOLE:143;
A23:  E2/.IC Comput(E2,S2,k+1)
 = E2.IC Comput(E2,S2,k+1) by PBOOLE:143;
    pI c= P1 +* pI by FUNCT_4:25;
    then pI c= E1;
    then CurInstr(E1,Comput(E1,S1,k+1))
     = pI.IC Comput(E1,S1,k+1) by A17,A22,GRFUNC_1:2
      .= CurInstr(E2,Comput(E2,S2,k+1))
       by A16,A21,A17,A23,GRFUNC_1:2;
    hence P[k+1] by A20;
  end;
A25: IC Comput(E2,S2,0) = IC S2 by A4
    .=  0 by MEMSTR_0:def 8;
A26: E1/.IC Comput(E1,S1,0)
 = E1.IC Comput(E1,S1,0) by PBOOLE:143;
A27: E2/.IC Comput(E2,S2,0)
 = E2.IC Comput(E2,S2,0) by PBOOLE:143;
A28: IC Comput(E1,S1,0) = IC S1
by A5
    .=  0 by MEMSTR_0:def 8;
  then CurInstr(E1,Comput(E1,S1,0))
     = pI. 0 by A7,A26,FUNCT_4:13
    .= CurInstr(E2,Comput(E2,S2,0)) by A25,A7,A27,FUNCT_4:13;
  then
A29: P[0] by A28,A25,A6;
  now
    let k be Element of NAT;
A30: for k being Element of NAT holds P[k] from NAT_1:sch 1(A29,A11);
    IC Comput(E1,S1,k) in dom pI by A10,Def2;
    hence IC Comput(E2,S2,k) in dom pI by A30;
  end;
  hence thesis by Def2;
end;

theorem
  for s1,s2 being State of SCMPDS,I being Program of SCMPDS st DataPart
  s1 = DataPart s2 holds I is_closed_on s1,P1 & I is_halting_on s1,P1
   implies I is_closed_on s2,P2 & I is_halting_on s2,P2
proof
  let s1,s2 be State of SCMPDS,I be Program of SCMPDS;
  set pI=stop I, S1 = Initialize s1, S2 = Initialize s2,
    E1 = P1 +* pI, E2 = P2 +* pI;
  defpred P[Element of NAT] means
   IC Comput(E1,S1,$1) = IC Comput(E2,S2,$1) &
   CurInstr(E1,Comput(E1,S1,$1)) = CurInstr(E2,Comput(E2,S2,$1))
    & DataPart
  Comput(E1,S1,$1) = DataPart Comput(E2,S2,$1);
A3: Comput(E1,S1,0) = Initialize s1 by EXTPRO_1:2;
A4: Comput(E2,S2,0) = Initialize s2 by EXTPRO_1:2;
  assume DataPart s1 = DataPart s2;
  then
A5:  Comput(E1,S1,0) =  Comput(E2,S2,0) by A3,A4,MEMSTR_0:80;
A6:  0 in dom pI by COMPOS_1:36;
  assume
A9: I is_closed_on s1,P1;
A10: now
    let k be Element of NAT;
A12: Comput(E2,S2,k+1) = Following(E2,Comput(E2,S2,k)) by EXTPRO_1:3;
    assume
A13: P[k];
    then for a holds Comput(E1,S1,k).a = Comput(E2,S2,k).a by SCMPDS_4:8;
    then
A14:  Comput(E1,S1,k) =  Comput(E2,S2,k) by A13,SCMPDS_4:2;
A15: pI c= E2 by FUNCT_4:25;
A16: IC Comput(E1,S1,k+1) in dom pI by A9,Def2;
 Comput(E1,S1,k+1) = Following(E1,Comput(E1,S1,k)) by EXTPRO_1:3;
    then
B18:  Comput(E1,S1,k+1) =  Comput(E2,S2,k+1) by A13,A14,A12;
    then
A18: IC Comput(E1,S1,k+1) = IC Comput(E2,S2,k+1);
A19: E1/.IC Comput(E1,S1,k+1)
 = E1.IC Comput(E1,S1,k+1) by PBOOLE:143;
A20: E2/.IC Comput(E2,S2,k+1)
 = E2.IC Comput(E2,S2,k+1) by PBOOLE:143;
    pI c= E1 by FUNCT_4:25;
    then CurInstr(E1,Comput(E1,S1,k+1))
     = pI.IC Comput(E1,S1,k+1) by A16,A19,GRFUNC_1:2
      .= CurInstr(E2,Comput(E2,S2,k+1))
       by A15,A18,A16,A20,GRFUNC_1:2;
    hence P[k+1] by B18;
  end;
A24: IC Comput(E2,S2,0) = IC S2 by A4
    .=  0 by MEMSTR_0:def 8;
  assume
  I is_halting_on s1,P1;
  then P1 +* pI halts_on Initialize s1 by Def3;
  then consider m such that
A25: CurInstr(E1,Comput(E1,S1,m)) = halt SCMPDS by EXTPRO_1:29;
A26: E1/.IC Comput(E1,S1,0) = E1.IC Comput(E1,S1,0) by PBOOLE:143;
A27: E2/.IC Comput(E2,S2,0) = E2.IC Comput(E2,S2,0) by PBOOLE:143;
 IC Comput(E1,S1,0) = IC S1 by A3
    .=  0 by MEMSTR_0:def 8;
  then CurInstr(E1,Comput(E1,S1,0))
     = pI. 0 by A6,A26,FUNCT_4:13
    .= CurInstr(E2,Comput(E2,S2,0)) by A24,A6,A27,FUNCT_4:13;
  then
A29: P[0] by A5;
  now
    let k be Element of NAT;
A30: for k being Element of NAT holds P[k] from NAT_1:sch 1(A29,A10);
    IC Comput(E1,S1,k) in dom pI by A9,Def2;
    hence IC Comput(E2,S2,k) in dom pI by A30;
  end;
  hence I is_closed_on s2,P2 by Def2;
  for k being Element of NAT holds P[k] from NAT_1:sch 1(A29,A10);
  then CurInstr(E2,Comput(E2,S2,m))
   = halt SCMPDS by A25;
  then P2 +* pI halts_on Initialize s2 by EXTPRO_1:29;
  hence thesis by Def3;
end;

theorem Th38:
  for s being State of SCMPDS, I,J being Program of SCMPDS holds I
  is_closed_on s,P iff I is_closed_on Initialize s,P+*J
proof
  let s be State of SCMPDS,I,J be Program of SCMPDS;
  DataPart s = DataPart Initialize s by MEMSTR_0:45;
  hence thesis by Th36;
end;

theorem Th39:
 for s being 0-started State of SCMPDS
  for I,J being Program of SCMPDS
   st I is_closed_on s,P & I is_halting_on s,P
  holds (for k being Element of NAT
    st k <= LifeSpan(P +* stop I,s) holds
     IC Comput(P +* stop I,s,k) = IC Comput(P +* stop(I ';' J),s,k)) &
      DataPart Comput(P +* stop I,s,LifeSpan(P +* stop I,s)) =
    DataPart Comput(P +* stop(I ';' J),s,LifeSpan(P +* stop I,s))
proof
 let s be 0-started State of SCMPDS;
  let I,J be Program of SCMPDS;
  assume
A1: I is_closed_on s,P;
I: Initialize s = s by MEMSTR_0:44;
  set pI=stop I, pIJ=stop (I ';' J), P1 = P +* pI;
  defpred X[Element of NAT] means $1 <= LifeSpan(P1,s) implies
     Comput(P1, s,$1) = Comput(P1 +* pIJ, s,$1);
  assume I is_halting_on s,P;
  then
A4: P1 halts_on s by Def3,I;
A6: for m st X[m] holds X[m+1]
  proof
    set JS=J ';' Stop SCMPDS, E2 = P1 +* pIJ;
    let m;
    assume
A7: m <= LifeSpan(P1,s) implies Comput(P1, s,m) =  Comput(P1 +* pIJ, s,m);
A8: pIJ c= E2 by FUNCT_4:25;
A10: Comput(P1,s,m+1) = Following(P1,Comput(P1,s,m)) by EXTPRO_1:3;
A11: pIJ =I ';' J ';' Stop SCMPDS
      .=I ';' JS by AFINSQ_1:27;
    dom(I ';' JS) = dom (I +* Shift(JS, card I))
      .= dom I \/ dom Shift(JS, card I) by FUNCT_4:def 1;
    then
A12: dom I c= dom(I ';' JS) by XBOOLE_1:7;
A14: Comput(E2,s,m+1) = Following(E2,Comput(E2,s,m)) by EXTPRO_1:3;
A15: IC Comput(P1,s,m) in dom pI by A1,Def2,I;
A16: P1/.IC Comput(P1,s,m)
 = P1.IC Comput(P1,s,m) by PBOOLE:143;
    pI c= P1 by FUNCT_4:25;
    then
A18: CurInstr(P1,Comput(P1,s,m))
 = pI.IC (Comput(P1,s,m)) by A15,A16,GRFUNC_1:2;
    assume
A19: m+1 <= LifeSpan(P1,s);
    then m < LifeSpan(P1,s) by NAT_1:13;
    then pI.IC(Comput(P1,s,m)) <> halt SCMPDS by A4,A18,EXTPRO_1:def 15;
    then
A20: IC Comput(P1,s,m) in dom I by A15,COMPOS_1:51;
A21: E2/.IC Comput(E2,s,m)
 = E2.IC Comput(E2,s,m) by PBOOLE:143;
    CurInstr(P1,Comput(P1,s,m))
    = (I ';' Stop SCMPDS).IC (Comput(P1,s,m)) by A18
      .=I.IC (Comput(P1,s,m)) by A20,AFINSQ_1:def 3
      .=pIJ.IC(Comput(P1,s,m)) by A20,A11,AFINSQ_1:def 3
      .=E2.IC(Comput(P1,s,m)) by A8,A20,A11,A12,GRFUNC_1:2
      .= CurInstr(E2,Comput(E2,s,m))
       by A7,A19,A21,NAT_1:13;
    hence thesis by A7,A19,A10,A14,NAT_1:13;
  end;
  Comput(P1, s,0) = s &
  Comput(P1 +* pIJ, s,0) = s by EXTPRO_1:2;
  then
A23: X[0];
A24: for m holds X[m] from NAT_1:sch 1(A23,A6);
A25: P +* pI +* pIJ = P +* (pI +* pIJ) by FUNCT_4:14
            .= P +* pIJ by SCMPDS_5:14;
  thus for k being Element of NAT st k <= LifeSpan(P1,s)
   holds IC Comput(P1,s,k) =IC Comput(P +* pIJ, s,k) by A24,A25;
   Comput(P +* stop I, s, LifeSpan(P +* stop I,s)) =
   Comput(P +* stop(I ';' J),s,(LifeSpan(P +* stop I,s))) by A25,A24;
  hence
   DataPart Comput(P +* stop I, s, (LifeSpan(P +* stop I,s))) =
   DataPart Comput(P +* stop(I ';' J), s,(LifeSpan(P +* stop I,s)));
end;

theorem Th40:
  for I being Program of SCMPDS,k be Element of NAT st I
  is_closed_on s,P & I is_halting_on s,P &
    k < LifeSpan(P +* stop I,Initialize s)
  holds IC Comput(P +* stop I,Initialize s,k) in dom I
proof
  let I be Program of SCMPDS,k be Element of NAT;
  set ss= Initialize s, PP = P +* stop I,
      m=LifeSpan(PP,ss), Sp =Stop SCMPDS;
  assume that
A2: I is_closed_on s,P and
A3: I is_halting_on s,P and
A4: k < m;
  set Sk= Comput(PP, ss,k), Ik=IC Sk;
A5: Ik in dom stop(I) by A2,Def2;
  reconsider n = Ik as Element of NAT;
A6: stop I c= PP by FUNCT_4:25;
A7: PP halts_on ss by A3,Def3;
A8: now
A9: PP/.IC Sk = PP.IC Sk by PBOOLE:143;
    assume
A11: n = card I;
    CurInstr(PP,Sk) =PP.Ik by A9
      .=(stop I).(0+n) by A5,A6,GRFUNC_1:2
      .=halt SCMPDS by A11,Lm1,Lm2,AFINSQ_1:def 3;
    hence contradiction by A4,A7,EXTPRO_1:def 15;
  end;
  card stop I=card I + 1 by COMPOS_1:55;
  then n < card I + 1 by A5,AFINSQ_1:66;
  then n <= card I by INT_1:7;
  then n < card I by A8,XXREAL_0:1;
  hence thesis by AFINSQ_1:66;
end;

theorem Th41:
  for I,J being Program of SCMPDS,
      s being 0-started State of SCMPDS, k being
  Element of NAT st I is_closed_on s,P & I is_halting_on s,P &
   k < LifeSpan(P +* stop I,s)
 holds CurInstr(P +* stop I, Comput(P +* stop I, s,k)) =
  CurInstr(P +* stop(I ';' J),Comput(P +* stop(I ';' J),s,k))
proof
  let I,J be Program of SCMPDS,
      s be 0-started State of SCMPDS,k be Element of NAT;
  set P1 = P +* stop I, P2 = P +* stop(I ';' J);
  set s3= Comput(P1, s,k), s4= Comput(P2, s,k),
      P3 = P1, P4 = P2,
SS=Stop SCMPDS;
  assume that
A3: I is_closed_on s,P and
A4: I is_halting_on s,P & k < LifeSpan(P1,s);
I: Initialize s = s by MEMSTR_0:44;
    then
A5: IC s3 in dom I by A3,A4,Th40;
A6: IC s3= IC s4 by A3,A4,Th39;
A7: IC s3 in dom stop(I) by A3,Def2,I;
A8: dom stop I c= dom stop (I ';' J) & stop (I ';' J) c= P2 by FUNCT_4:25
,SCMPDS_5:13;
A9: stop I c= P1 by FUNCT_4:25;
A10: stop (I ';' J) = I ';' J ';' SS
    .=I ';' (J ';' SS) by AFINSQ_1:27;
A11: P3/.IC s3 = P3.IC s3 by PBOOLE:143;
A12:  P4/.IC s4 = P4.IC s4 by PBOOLE:143;
  thus CurInstr(P1,s3) =P1.IC s3 by A11
    .=(stop I).IC s3 by A7,A9,GRFUNC_1:2
    .=I.IC s3 by A5,AFINSQ_1:def 3
    .=(stop (I ';' J)).IC s3 by A5,A10,AFINSQ_1:def 3
    .=P2.IC s4 by A6,A7,A8,GRFUNC_1:2
    .=CurInstr(P2,s4) by A12;
end;

theorem Th42: ::SCMPDS_5:32
  for I being halt-free Program of SCMPDS,s being State of
  SCMPDS, k being Element of NAT st I is_closed_on s,P &
  I is_halting_on s,P & k <
  LifeSpan(P +* stop I,Initialize s)
   holds
  CurInstr(P +* stop I,Comput(P +* stop I,Initialize s,k)) <> halt SCMPDS
proof
  let I be halt-free Program of SCMPDS,s be State of SCMPDS, k be Element of
  NAT;
  set ss=Initialize s, PP = P +* stop I,
      s2= Comput(PP, ss,k), P2 = PP;
  assume
  I is_closed_on s,P & I is_halting_on s,P & k < LifeSpan(PP,ss);
  then
A2: IC s2 in dom I by Th40;
A3:  P2/.IC s2 = P2.IC s2 by PBOOLE:143;
XX: stop I c= PP by FUNCT_4:25;
   I c= stop I by AFINSQ_1:74;
  then I c= PP by XX,XBOOLE_1:1;
  then CurInstr(P2,s2)=I.IC s2 by A2,A3,GRFUNC_1:2;
  hence thesis by A2,COMPOS_1:def 25;
end;

theorem Th43:
  for I being halt-free Program of SCMPDS,s being State of
  SCMPDS st I is_closed_on s,P & I is_halting_on s,P
  holds IC Comput(P +* stop I, Initialize s,
    LifeSpan(P +* stop I,Initialize s)) =  card I
proof
  let I be halt-free Program of SCMPDS,s be State of SCMPDS;
  set s1=Initialize s, P1 = P +* stop I;
  assume that
A2: I is_closed_on s,P and
A3: I is_halting_on s,P;
  set Css= Comput(P1, s1,LifeSpan(P1,s1));
  reconsider n = IC Css as Element of NAT;
XX: stop I c= P1 by FUNCT_4:25;
   I c= stop I by AFINSQ_1:74;
   then
A4: I c= P1 by XX,XBOOLE_1:1;
A5: P1 halts_on s1 by A3,Def3;
  now
A7: P1/.IC Css = P1.IC Css by PBOOLE:143;
    assume
A8: IC Css in dom I;
    then I.IC Css=P1.IC Css by A4,GRFUNC_1:2
      .=CurInstr(P1,Css) by A7
      .=halt SCMPDS by A5,EXTPRO_1:def 15;
    hence contradiction by A8,COMPOS_1:def 25;
  end;
  then
A9: n >= card I by AFINSQ_1:66;
A10: card stop I =card I + 1 by COMPOS_1:55;
  IC Css in dom stop(I) by A2,Def2;
  then n < card I + 1 by A10,AFINSQ_1:66;
  then n <= card I by NAT_1:13;
  then IC Comput(P1, s1,LifeSpan(P1,s1)) = card I by A9,XXREAL_0:1;
  hence thesis;
end;

Lm3:
 for I being halt-free Program of SCMPDS, J being Program of SCMPDS,
     s being 0-started State of SCMPDS
     st I is_closed_on s,P & I is_halting_on s,P
  holds IC Comput(P +* stop (I ';' Goto (card J + 1) ';' J ),
s, (LifeSpan(P +* stop I,s) + 1)) =
(card I + card J + 1) &
DataPart Comput(P +* stop I, s,
 (LifeSpan(P +* stop I,s)))
 = DataPart Comput(P +* stop (I ';' Goto(card J +
1) ';' J), s,
(LifeSpan(P +* stop I,s) + 1)) &
(for k being Element of
NAT st k <= LifeSpan(P +* stop I,s)
 holds CurInstr(P +*stop (I ';' Goto (card J + 1) ';' J ),
   Comput(P +*stop (I ';' Goto (card J + 1) ';' J ),
   s,k)) <> halt SCMPDS) &
 IC Comput(P +* stop (I ';' Goto (card J + 1) ';' J), s,
 LifeSpan(P +* stop I,s))
  =  card I &
 P +* stop (I ';' Goto (card J + 1) ';' J)
  halts_on s &
 LifeSpan(P +* stop (I ';' Goto (
card J + 1) ';' J),s) = LifeSpan(P +* stop I,s) + 1

proof
  let I be halt-free Program of SCMPDS, J be Program of SCMPDS,
      s be 0-started State of SCMPDS;
  assume
A1: I is_closed_on s,P;
  set G1=Goto (card J + 1), SS = Stop SCMPDS, J2 = G1 ';' J ';' SS, IJ=I ';'
G1 ';' J, pJ=stop IJ, s1 = s, P1 = P +* stop I,
  s2 = s;
  reconsider P2 = P +* pJ
   as Instruction-Sequence of SCMPDS;
  assume
A4: I is_halting_on s,P;
I: Initialize s = s by MEMSTR_0:44;
  set sm= Comput(P2, s2,LifeSpan(P1,s1));
A5: IJ =I ';' (G1 ';' J) by AFINSQ_1:27;
  then
A6: IC Comput(P1, s1,LifeSpan(P1,s1)) =IC sm by A1,A4,Th39;
  then
A7: IC sm =  card I by A1,A4,Th43,I;
A8:  0 in dom G1 by Th33;
A9: J2. 0 = (G1 ';' (J ';' SS)). 0 by AFINSQ_1:27
    .=G1. 0 by A8,AFINSQ_1:def 3
    .=goto (card J + 1) by Th33;
  card (G1 ';' J) = card G1 + card J by AFINSQ_1:17
    .=1 + card J by COMPOS_1:54;
  then
A11: J2. (card J + 1)=J2.(0+card (G1 ';' J))
    .=halt SCMPDS by Lm1,Lm2,AFINSQ_1:def 3;
A12: card J2 = card (G1 ';' (J ';' SS)) by AFINSQ_1:27
    .=card G1 + card (J ';' SS) by AFINSQ_1:17
    .= 1 + card (J ';' SS) by COMPOS_1:54;
  then
A13:  0 in dom J2 by AFINSQ_1:66;
A14: pJ =I ';' G1 ';' J ';' SS
    .=I ';' (G1 ';' J) ';' SS by AFINSQ_1:27
    .=I ';' J2 by AFINSQ_1:27;
  then
A15: card pJ = card I + card J2 by AFINSQ_1:17;
  then card I + 0 < card pJ by XREAL_1:6;
  then
A16:  card I in dom pJ by AFINSQ_1:66;
A17: card SS = 1 by AFINSQ_1:33;
A18: card J2 = 1 + (card J + card SS) by A12,AFINSQ_1:17
    .= card J + (1 + card SS);
  then card J + 1 < card J2 by A17,XREAL_1:6;
  then
A19:  (card J + 1) in dom J2 by AFINSQ_1:66;
  card pJ = card I + card J + 1 + 1 by A15,A18,A17;
  then card I + card J + 1 < card pJ by NAT_1:13;
  then
A20:  (card I + card J + 1) in dom pJ by AFINSQ_1:66;

A21:  P2/.IC Comput(P2,s2,LifeSpan(P1,s1))
 = P2.IC Comput(P2,s2,LifeSpan(P1,s1)) by PBOOLE:143;
A23: CurInstr(P2,Comput(P2,s2,LifeSpan(P1,s1)))
 = P2.card I by A1,A4,A6,Th43,A21,I

    .= P2. card I
    .= pJ. card I by A16,FUNCT_4:13
    .= (I ';' J2).(0+card I) by A14
    .= goto (card J + 1) by A13,A9,AFINSQ_1:def 3;
A24: now
    let a;
    thus Comput(P2, s2,LifeSpan(P1,s1) + 1).a
       = (Following(P2,sm)).a by EXTPRO_1:3
      .= sm.a by A23,SCMPDS_2:54;
  end;
A25:  P2/.IC Comput(P2, s2,LifeSpan(P1,s1) + 1)
 = P2.IC Comput(P2, s2,LifeSpan(P1,s1) + 1)
 by PBOOLE:143;
  thus IC Comput(P +* pJ, s2,LifeSpan(P1,s1) + 1)
     = IC Following(P2,sm) by EXTPRO_1:3
    .= ICplusConst(sm,card J +1) by A23,SCMPDS_2:54
    .= (card I + (card J + 1)) by A7,Th23
    .= (card I + card J + 1);
  then
A27: CurInstr(P2,
       Comput(P2, s2,LifeSpan(P1,s1) + 1))
 = P2. (card I + card J
  + 1) by A25

    .= pJ. (card I + card J + 1) by A20,FUNCT_4:13
    .= (I ';' J2).(card I+(card J+1)) by A14
    .= halt SCMPDS by A19,A11,AFINSQ_1:def 3;
  DataPart Comput(P1, s1,LifeSpan(P1,s1)) = DataPart
sm by A1,A4,A5,Th39;

  hence DataPart Comput(P1, s1,LifeSpan(P1,s1)) =
DataPart Comput(P +* pJ, s2,LifeSpan(P1,s1) + 1)
by A24,SCMPDS_4:8;
  thus
A28:
   now
    let k be Element of NAT;
    assume
A30: k <= LifeSpan(P1,s1);
    per cases;
    suppose
A31:  k < LifeSpan(P1,s1);
      then CurInstr(P1,Comput(P1,s1,k)) <> halt SCMPDS by A1,A4,Th42,I;
      hence CurInstr(P +* pJ,Comput(P +* pJ,s2,k)) <> halt SCMPDS
       by A1,A4,A5,A31,Th41;

    end;
    suppose
      LifeSpan(P1,s1) <= k;
      then k = LifeSpan(P1,s1) by A30,XXREAL_0:1;
      hence CurInstr(P +* pJ,Comput(P +* pJ,s2,k)) <>
       halt SCMPDS by A23;
    end;
  end;
  thus IC Comput(P +* pJ,s2,LifeSpan(P1,s1))
   =  card I by A1,A4,A6,Th43,I;
  thus
A32: P +* pJ halts_on s2 by A27,EXTPRO_1:29;
  now
    let k be Element of NAT;
    assume
    CurInstr(P2,Comput(P2,s2,k))
     = halt SCMPDS;
    then LifeSpan(P1,s1) < k by A28;
    hence LifeSpan(P1,s1)+1 <= k by INT_1:7;
  end;
  hence thesis by A27,A32,EXTPRO_1:def 15;
end;

theorem Th44:
  for I,J being Program of SCMPDS,
      s being 0-started State of SCMPDS st I
  is_closed_on s,P & I is_halting_on s,P holds I ';' Goto (card J + 1) ';' J
  is_halting_on s,P & I ';' Goto (card J + 1) ';' J is_closed_on s,P
proof
  let I,J be Program of SCMPDS,s be 0-started State of SCMPDS;
  set G = Goto (card J + 1), IJ = I ';' G ';' J, J2 = I ';' (G ';' J), pJ =
stop J2, pI =stop I, P1 = P +* pI, P2 = P +* pJ,
  m=LifeSpan(P1,s), SS=Stop SCMPDS,
  s3= Comput(P1, s,m), s4= Comput(P2, s,m),
  P3= P1, P4 = P2;
I: Initialize s = s by MEMSTR_0:44;
A3: IJ=I ';' (G ';' J) by AFINSQ_1:27;
XX: I c= stop I by AFINSQ_1:74;
  pI c= P3 by FUNCT_4:25;
  then
A5: I c= P3 by XX,XBOOLE_1:1;
A6: dom pI c= dom pJ by SCMPDS_5:13;
  set JS=G ';' J ';' SS;
  reconsider n = IC s3 as Element of NAT;
A7: card pI=card I + 1 by COMPOS_1:55;
  assume
A8: I is_closed_on s,P;
  then IC s3 in dom pI by Def2,I;
  then n < card I + 1 by A7,AFINSQ_1:66;
  then
A9: n <= card I by INT_1:7;
A10: pJ c= P2 by FUNCT_4:25;
A11: pJ =I ';' (G ';' J) ';' SS
    .=I ';' JS by AFINSQ_1:27;
  then I c= pJ by AFINSQ_1:74;
  then I c= P2 by A10,XBOOLE_1:1;
  then
A12: I c= P4;
  assume
A13: I is_halting_on s,P;
  then
A14: P1 halts_on s by Def3,I;
A15: P3/.IC s3
 = P3.IC s3 by PBOOLE:143;
A16:  P4/.IC s4
 = P4.IC s4 by PBOOLE:143;
  per cases;
  suppose
    IC s3 <>  card I;
    then n < card I by A9,XXREAL_0:1;
    then
A17: IC s3 in dom I by AFINSQ_1:66;
A20: halt SCMPDS=CurInstr(P1,s3) by A14,EXTPRO_1:def 15
      .=I.IC s3 by A5,A17,A15,GRFUNC_1:2
      .=P4.IC s3 by A12,A17,GRFUNC_1:2
      .=CurInstr(P4,s4) by A8,A13,Th39,A16;
    then
A21: P2 halts_on s by EXTPRO_1:29;
    hence IJ is_halting_on s,P by A3,Def3,I;
    now
      let k be Element of NAT;
      set C1k=IC Comput(P1, s,k), C2k=IC Comput(P2
, s,k);
      per cases;
      suppose
A22:    k <= m;
        C1k in dom pI by A8,Def2,I;
        then C1k in dom pJ by A6;
        hence C2k in dom pJ by A8,A13,A22,Th39;
      end;
      suppose
A23:    k > m;
        set m2=LifeSpan(P2,s);
A24:    m2 <= m by A20,A21,EXTPRO_1:def 15;
        then C2k=IC Comput(P2, s,m2) by A21,A23,EXTPRO_1:25,XXREAL_0:2
          .=IC Comput(P1, s,m2) by A8,A13,A24,Th39;
        then C2k in dom pI by A8,Def2,I;
        hence C2k in dom pJ by A6;
      end;
    end;
    hence thesis by A3,Def2,I;
  end;
  suppose
A25: IC s3 = card I;
    then
A26: IC s4= card I by A8,A13,Th39;
A27:  0 in dom G by Th33;
A28: card Stop SCMPDS = 1 by AFINSQ_1:33;
A29: JS =G ';' (J ';' SS) by AFINSQ_1:27;
    then
A30: card JS =card G + card (J ';' SS) by AFINSQ_1:17
      .= 1 + card (J ';' SS) by COMPOS_1:54
      .= card J + 1 + 1 by A28,AFINSQ_1:17;
    then
A31:  0 in dom JS by AFINSQ_1:66;
    card J + 1 < card JS by A30,NAT_1:13;
    then
A32:  (card J + 1) in dom JS by AFINSQ_1:66;
    card pJ = card I + (card J + (1 + 1)) by A11,A30,AFINSQ_1:17
      .= card I + card J + 1 + 1;
    then
A33: card I + card J + 1 < card pJ by NAT_1:13;
    then
A34:  (card I + card J + 1) in dom pJ by AFINSQ_1:66;
A35:  P4/.IC s4
 = P4.IC s4 by PBOOLE:143;
    card pJ = card I + card JS by A11,AFINSQ_1:17;
    then card I + 0 < card pJ by XREAL_1:6;
    then
A36:  card I in dom pJ by AFINSQ_1:66;
A37: CurInstr(P4,s4)= P4. card I by A8,A13,A25,Th39,A35
      .= P2. card I
      .= (I ';' JS).(0+card I) by A11,A10,A36,GRFUNC_1:2
      .= JS. 0 by A31,AFINSQ_1:def 3
      .=G. 0 by A29,A27,AFINSQ_1:def 3
      .=goto (card J + 1) by Th33;
    card (G ';' J) = card G + card J by AFINSQ_1:17
      .=1 + card J by COMPOS_1:54;
    then
A38: JS. (card J + 1)=JS.(0+card (G ';' J))
      .=halt SCMPDS by Lm1,Lm2,AFINSQ_1:def 3;
A39:  P2/.IC Comput(P2,s,m+1) = P2.IC Comput(P2,s,m+1) by PBOOLE:143;
A42: IC Comput(P2, s,m + 1) = IC Following(P2,s4) by EXTPRO_1:3
      .= ICplusConst(s4,card J +1) by A37,SCMPDS_2:54
      .= (card I + (card J + 1)) by A26,Th23
      .= (card I + card J + 1);
    then
A43: CurInstr(P2,Comput(P2,s,m+1))
 = P2. (card I + card J + 1) by A39
      .= (I ';' JS).(card I+(card J+1)) by A11,A10,A34,GRFUNC_1:2
      .= halt SCMPDS by A32,A38,AFINSQ_1:def 3;
    then
A44: P2 halts_on s by EXTPRO_1:29;
    hence IJ is_halting_on s,P by A3,Def3,I;
    now
      let k be Element of NAT;
      set C1k=IC Comput(P1, s,k), C2k=IC Comput(P2, s,k);
      per cases;
      suppose
A45:    k <= m;
        C1k in dom pI by A8,Def2,I;
        then C1k in dom pJ by A6;
        hence C2k in dom pJ by A8,A13,A45,Th39;
      end;
      suppose
A46:    k > m;
        set m2=LifeSpan(P2,s);
A47:    m2 <= m+1 by A43,A44,EXTPRO_1:def 15;
        k >= m+1 by A46,INT_1:7;
        then C2k=IC Comput(P2, s,m2) by A44,A47,EXTPRO_1:25,XXREAL_0:2
          .= (card I + card J + 1) by A42,A44,A47,EXTPRO_1:25;
        hence C2k in dom pJ by A33,AFINSQ_1:66;
      end;
    end;
    hence thesis by A3,Def2,I;
  end;
end;

theorem Th45:
 for s1 being 0-started State of SCMPDS
  for I being shiftable Program of SCMPDS
    st stop I c= P1 & I is_closed_on s1,P1
  for n being Element of NAT st
   Shift(stop I,n) c= P2 & IC
  s2 =  n & DataPart s1 = DataPart s2 for i being Element of NAT holds IC
Comput(P1, s1,i) + n = IC Comput(P2, s2,i) &
 CurInstr(P1,Comput(P1,s1,i)) = CurInstr(P2,Comput(P2,s2,i)) &
  DataPart Comput(P1, s1,i) = DataPart Comput(P2, s2,i)
proof
 let s1 be 0-started State of SCMPDS;
  let I be shiftable Program of SCMPDS;
  set SI=stop I;
  assume that
A1: SI c= P1 and
A2: I is_closed_on s1,P1;
A0: Initialize s1 = s1 by MEMSTR_0:44;
  let n be Element of NAT;
  defpred P[Element of NAT] means IC Comput(P1,s1,$1) + n = IC
    Comput(P2,s2,$1) & CurInstr(P1,Comput(P1,s1,$1))
   = CurInstr(P2,Comput(P2,s2,$1)) &
  DataPart Comput(P1,s1,$1) = DataPart Comput(P2,s2,$1);
  assume that
A5: Shift(SI,n) c= P2 and
A6: IC s2 =  n and
A7: DataPart s1 = DataPart s2;
  let i be Element of NAT;
A8: DataPart Comput(P1,s1,0) = DataPart s2 by A7,EXTPRO_1:2
    .= DataPart Comput(P2,s2,0) by EXTPRO_1:2;
A9:  0 in dom SI by COMPOS_1:36;
  then
A10:  (0 + n) in dom Shift(SI,n) by VALUED_1:24;
A12: P1.IC s1 = P1.IC Initialize s1 by A0
    .= P1. 0 by MEMSTR_0:def 8
    .= SI. 0 by A1,A9,GRFUNC_1:2;
A14: P1= P1 +* SI by A1,FUNCT_4:98;
A15: for k being Element of NAT st P[k] holds P[k + 1]
  proof
    let k be Element of NAT;
    assume
A16: P[k];
    reconsider m = IC Comput(P1,s1,k) as Element of NAT;
    set i = CurInstr(P1,Comput(P1,s1,k));
A18: Comput(P1,s1,k+1) = Following(P1,Comput(P1,s1,k)) by EXTPRO_1:3;
    reconsider l = IC Comput(P1,s1,k+1) as Element of NAT;
A19: IC Comput(P1,s1,k+1) in dom SI by A2,A14,Def2,A0;
    then
A20: l+n in dom Shift(SI,n) by VALUED_1:24;
A22: Comput(P2,s2,k+1) = Following(P2,Comput(P2,s2,k)) by EXTPRO_1:3;
A23: IC Comput(P1,s1,k) in dom SI by A2,A14,Def2,A0;
A24 : P1/.IC Comput(P1,s1,k) = P1.IC Comput(P1,s1,k) by PBOOLE:143;
A25: i = P1.IC Comput(P1,s1,k) by A24
      .= SI.IC Comput(P1,s1,k) by A1,A23,GRFUNC_1:2;
    then
A26: InsCode i <> 1 & InsCode i <> 3 by A23,SCMPDS_4:def 9;
A27: i valid_at m by A23,A25,SCMPDS_4:def 9;
    hence
A28: IC Comput(P1,s1,k+1) + n = IC Comput(P2,s2,k+1)
by A16,A18,A22,A26,SCMPDS_4:28;
A29: P1/.IC Comput(P1,s1,k+1)
 = P1.IC Comput(P1,s1,k+1) by PBOOLE:143;
A30: P2/.IC Comput(P2,s2,k+1)
 = P2.IC Comput(P2,s2,k+1) by PBOOLE:143;
    CurInstr(P1,Comput(P1,s1,k+1)) = P1.l by A29
      .= SI.l by A1,A19,GRFUNC_1:2
      .= SI.l;
    hence CurInstr(P1,Comput(P1,s1,k+1))
     = Shift(SI,n).(IC Comput(P2,s2,k+1))
    by A28,A19,VALUED_1:def 12
      .= P2.IC Comput(P2,s2,k+1) by A5,A28,A20,GRFUNC_1:2
      .= CurInstr(P2,Comput(P2,s2,k+1))
       by A30;
    thus thesis by A16,A18,A22,A26,A27,SCMPDS_4:28;
  end;
A31: IC Comput(P1,s1,0) = IC s1 by EXTPRO_1:2
    .= IC Initialize s1 by A0
    .=  0 by MEMSTR_0:def 8;
A32: Comput(P1,s1,0) = s1 by EXTPRO_1:2;
A33: Comput(P2,s2,0) = s2 by EXTPRO_1:2;
A34:  P2/.IC s2 = P2.IC s2 by PBOOLE:143;
A35:  P1/.IC s1 = P1.IC s1 by PBOOLE:143;
  CurInstr(P1,Comput(P1,s1,0))
   = CurInstr(P1,s1) by A32
    .= Shift(SI,n).(0 + n) by A9,A12,A35,VALUED_1:def 12
    .= CurInstr(P2,s2) by A5,A6,A10,A34,GRFUNC_1:2
    .= CurInstr(P2,Comput(P2,s2,0))
     by A33;
  then
A36: P[0] by A6,A31,A8,EXTPRO_1:2;
  for k being Element of NAT holds P[k] from NAT_1:sch 1(A36,A15);
  hence thesis;
end;

theorem Th46: ::SCMFSA8A:61
  for s being 0-started State of SCMPDS,I being halt-free Program of SCMPDS,
      J being Program of SCMPDS st I is_closed_on s,P & I is_halting_on s,P
  holds IC IExec(I ';' Goto (card J + 1) ';' J,P,s)
   = card I + card J + 1
proof
  let s be 0-started State of SCMPDS,
      I be halt-free Program of SCMPDS, J be Program of
  SCMPDS;
  set
   m= LifeSpan(P +* stop I,Initialize s)+1,
   G=Goto (card J + 1),
   P2 = P +* stop (I ';' G ';' J);
I: Initialize s = s by MEMSTR_0:44;
  assume
A1: I is_closed_on s,P & I is_halting_on s,P;
  then P2 halts_on s & LifeSpan(P2,s) = m by Lm3,I;
  then IC Result(P2,s) = IC Comput(P2, s,m) by EXTPRO_1:23
    .= card I + card J + 1 by A1,Lm3,I;
  hence thesis;
end;

theorem Th47: ::SCMFSA8A:62
  for s being 0-started State of SCMPDS,I being halt-free Program of
SCMPDS, J being Program of SCMPDS st I is_closed_on s,P & I is_halting_on s,P
 holds
  IExec(I ';' Goto (card J + 1) ';' J,P,s)
   = IExec(I,P,s) +* Start-At((card I + card J + 1),SCMPDS)
proof
  let s be 0-started State of SCMPDS,
      I be halt-free Program of SCMPDS, J be Program of
  SCMPDS;
  set P1 = P +* stop I,
      m= LifeSpan(P1,s)+1, G=Goto (card J + 1),
  P2 = P +* stop (I ';' G ';' J),
  l=  (card I + card J + 1);
  assume that
A1: I is_closed_on s,P and
A2: I is_halting_on s,P;
  Initialize s = s by MEMSTR_0:44;
  then
A3: P1 halts_on s by A2,Def3;
  P2 halts_on s & LifeSpan(P2,s) = m
   by A1,A2,Lm3;
  then
A4: Result(P2,s) = Comput(P2, s,m) by EXTPRO_1:23;
  then DataPart Result(P2,s) = DataPart Comput(P1,s,LifeSpan(P1,s))
by A1,A2,Lm3;
  then
A5: DataPart Result(P2,s) = DataPart Result(P1,s) by A3,EXTPRO_1:23
    .= DataPart(Result(P1,s) +* Start-At(l,SCMPDS)) by MEMSTR_0:79;
  IC Result(P2,s) = l by A1,A2,A4,Lm3
    .= IC(Result(P1,s) +* Start-At(l,SCMPDS)) by FUNCT_4:113;
  then
A6:  Result(P2,s) = (Result(P1,s) +* Start-At(l,SCMPDS)) by A5,MEMSTR_0:78;
  thus IExec(I ';' G ';' J,P,s) = Result(P2,s)
    .= Result(P1,s) +* (Start-At(l,SCMPDS)) by A6
    .= IExec(I,P,s) +* Start-At(l,SCMPDS);
end;

theorem Th48:
  for s being State of SCMPDS,I being halt-free Program of
  SCMPDS st I is_closed_on s,P & I is_halting_on s,P
   holds IC IExec(I,P,Initialize s) = card I
proof
  let s be State of SCMPDS,I be halt-free Program of SCMPDS;
  set s1=Initialize s, P1 = P +* stop I;
  assume that
A2: I is_closed_on s,P and
A3: I is_halting_on s,P;
A4: P1 halts_on s1 by A3,Def3;
  thus IC IExec(I,P,Initialize s) = IC Result(P1,s1)
    .= IC Comput(P1, s1,LifeSpan(P1,s1)) by A4,EXTPRO_1:23
    .= card I by A2,A3,Th43;
end;

begin :: The construction of conditional statements

definition
  let a be Int_position,k be Integer;
  let I,J be Program of SCMPDS;
  func if=0(a,k,I,J) -> Program of SCMPDS equals
  (a,k)<>0_goto (card I +2) ';' I ';' Goto (card J+1) ';' J;
  coherence;
  func if>0(a,k,I,J) -> Program of SCMPDS equals
  (a,k)<=0_goto (card I +2) ';'
  I ';' Goto (card J+1) ';' J;
  coherence;
  func if<0(a,k,I,J) -> Program of SCMPDS equals
  (a,k)>=0_goto (card I +2) ';'
  I ';' Goto (card J+1) ';' J;
  coherence;
end;

definition
  let a be Int_position,k be Integer;
  let I be Program of SCMPDS;
  func if=0(a,k,I) -> Program of SCMPDS equals
  (a,k)<>0_goto (card I +1) ';' I;
  coherence;
  func if<>0(a,k,I) -> Program of SCMPDS equals
  (a,k)<>0_goto 2 ';' goto (card
  I+1) ';' I;
  coherence;
  func if>0(a,k,I) -> Program of SCMPDS equals
  (a,k)<=0_goto (card I +1) ';' I;
  coherence;
  func if<=0(a,k,I) -> Program of SCMPDS equals
  (a,k)<=0_goto 2 ';' goto (card
  I+1) ';' I;
  coherence;
  func if<0(a,k,I) -> Program of SCMPDS equals
  (a,k)>=0_goto (card I +1) ';' I;
  coherence;
  func if>=0(a,k,I) -> Program of SCMPDS equals
  (a,k)>=0_goto 2 ';' goto (card
  I+1) ';' I;
  coherence;
end;

Lm4: card (i ';' I ';' Goto n ';' J) = card I + card J +2
proof
  set G=Goto n;

  thus card (i ';' I ';' G ';' J) =card (i ';' I ';' G) + card J by AFINSQ_1:17

    .=card (i ';' I) + card G + card J by AFINSQ_1:17
    .=card (i ';' I) + 1 + card J by COMPOS_1:54
    .=card I +1 +1 +card J by Th15
    .=card I + card J +2;
end;

begin :: The computation of "if var=0 then block1 else block2"

theorem
  card if=0(a,k1,I,J) = card I + card J + 2 by Lm4;

theorem
   0 in dom if=0(a,k1,I,J) &  1 in dom if=0(a,k1,I,J)
proof
  set ci=card if=0(a,k1,I,J);
  ci=card I + card J +2 by Lm4;
  then 2 <= ci by NAT_1:12;
  then 1 < ci by XXREAL_0:2;
  hence thesis by AFINSQ_1:66;
end;

Lm5: (i ';' I ';' J ';' K). 0=i
proof
A1:  0 in dom Load i by COMPOS_1:50;
  i ';' I ';' J ';' K =i ';' (I ';' J) ';' K by SCMPDS_4:14
    .=i ';' (I ';' J ';' K) by SCMPDS_4:14
    .=Load i ';' (I ';' J ';' K);
  hence (i ';' I ';' J ';' K). 0 =(Load i). 0 by A1,AFINSQ_1:def 3
    .=i by COMPOS_1:52;
end;

theorem
  if=0(a,k1,I,J). 0 = (a,k1)<>0_goto (card I + 2) by Lm5;

Lm6: Shift(stop I,1) c= P +* stop(i ';' I)
proof
  set pI=stop I, iI=i ';' I, piI=stop iI, P3=P+*piI;
  card Load i=1 & iI=(Load i) ';' I by COMPOS_1:54;
  then
A1: Shift(pI,1) c= piI by Th24;
  piI c= P3 by FUNCT_4:25;
  then Shift(pI,1) c= P3 by A1,XBOOLE_1:1;
  hence thesis;
end;

Lm7: Shift(stop I,2) c= P+* stop(i ';' j ';' I)
proof
  set pI=stop I, pjI=stop (i ';' j ';' I), P3=P+*pjI;
  card (i ';' j)=card (Load i ';' Load j)
    .=card Load i + card Load j by AFINSQ_1:17
    .=1+ card Load j by COMPOS_1:54
    .=1+1 by COMPOS_1:54;
  then
A2: Shift(pI,2) c= pjI by Th24;
  pjI c= P3 by FUNCT_4:25;
  then Shift(pI,2) c= P3 by A2,XBOOLE_1:1;
  hence thesis;
end;

theorem Th52:
  for s being 0-started State of SCMPDS, I,J being shiftable Program of
  SCMPDS, a being Int_position,k1 being Integer st s.DataLoc(s.a,k1)= 0 & I
is_closed_on s,P & I is_halting_on s,P holds if=0(a,k1,I,J) is_closed_on s,P
 & if=0(a,k1,I,J) is_halting_on s,P
proof
  let s be 0-started State of SCMPDS, I,J be shiftable Program of SCMPDS, a be
  Int_position,k1 be Integer;
  set b=DataLoc(s.a,k1);
  assume
A1: s.b = 0;
  set i = (a,k1)<>0_goto (card I + 2);
  set G=Goto (card J+1);
  set I2 = I ';' G ';' J, IF=if=0(a,k1,I,J), pIF=stop IF,
   pI2=stop I2, P2 = P +* pI2, P3 = P +* pIF,
  s4 = Comput(P3,s,1),
  P4 = P3;
I: Initialize s = s by MEMSTR_0:44;
   then
A4: IC s = 0 by MEMSTR_0:47;
A6: IF = i ';' (I ';' G) ';' J by SCMPDS_4:14
    .= i ';' I2 by SCMPDS_4:14;
  then
A7: Shift(pI2,1) c= P4 by Lm6;
A8: Comput(P3, s,0 + 1) = Following(P3,Comput(P3,s,0)) by EXTPRO_1:3
    .= Following(P3,s) by EXTPRO_1:2
    .= Exec(i,s) by A6,Th22,I;
  for a holds s.a= s4.a by A8,SCMPDS_2:55;
  then
A10: DataPart s = DataPart s4 by SCMPDS_4:8;
  s.DataLoc(s.a,k1)=s.b
    .=0 by A1;
  then
A11: IC s4 = succ IC s by A8,SCMPDS_2:55
    .= (0+1) by A4;
A12:  0 in dom pIF by COMPOS_1:36;
  assume
A13: I is_closed_on s,P;
  assume
A14: I is_halting_on s,P;
  then I2 is_halting_on s,P by A13,Th44;
  then
A15: P2 halts_on s by Def3,I;
A16: I2 is_closed_on s,P by A13,A14,Th44;
  then
A17: Start-At(0,SCMPDS) c= s & I2 is_closed_on s,P2 by Th38,FUNCT_4:25,I;
A18: card pIF = card IF +1 by COMPOS_1:55
    .= card I2 +1+1 by A6,Th15;
UU:  stop I2 c= P2 by FUNCT_4:25;
  now
    let k be Element of NAT;
    per cases;
    suppose
      0 < k;
      then consider k1 being Nat such that
A19:  k1 + 1 = k by NAT_1:6;
      reconsider k1 as Element of NAT by ORDINAL1:def 12;
      reconsider m = IC Comput(P2, s,k1) as Element of NAT;
A20:  card pIF = card pI2+1 by A18,COMPOS_1:55;
       m in dom pI2 by A16,Def2,I;
      then m < card pI2 by AFINSQ_1:66;
      then
A21:  m+1 < card pIF by A20,XREAL_1:6;
     IC Comput(P3,s,k) = IC Comput(P3, s4,k1) by A19,EXTPRO_1:4
        .= m + 1 by A17,A7,A11,A10,Th45,UU;
      hence IC Comput(P3,s,k) in dom pIF by A21,AFINSQ_1:66;
    end;
    suppose
      k = 0;
      hence IC Comput(P3,s,k) in dom pIF by A12,A4,EXTPRO_1:2;
    end;
  end;
  hence IF is_closed_on s,P by Def2,I;
A24: Comput(P3,s,LifeSpan(P2,s)+1)
 = Comput(P3,Comput(P3,s,1),LifeSpan(P2
,s))
by EXTPRO_1:4;
  CurInstr(P3,Comput(P3,s,LifeSpan(P2,s)+1))
   =CurInstr(P4,Comput(P4,s4,LifeSpan(P2,s))) by A24
    .=CurInstr(P2,Comput(P2,s,LifeSpan(P2,s))) by A17,A7,A11,A10,Th45,UU
    .= halt SCMPDS by A15,EXTPRO_1:def 15;
  then P3 halts_on s by EXTPRO_1:29;
  hence thesis by Def3,I;
end;

theorem Th53:
  for s being State of SCMPDS,I being Program of SCMPDS,J being
shiftable Program of SCMPDS,a being Int_position,k1 being Integer st s.DataLoc(
  s.a,k1)<> 0 & J is_closed_on s,P & J is_halting_on s,P holds if=0(a,k1,I,J)
  is_closed_on s,P & if=0(a,k1,I,J) is_halting_on s,P
proof
  let s be State of SCMPDS,I be Program of SCMPDS, J be shiftable Program of
  SCMPDS, a be Int_position,k1 be Integer;
  set b=DataLoc(s.a,k1);
  set pJ=stop J, s1 = Initialize s, P1 = P +* pJ,
  IF=if=0(a,k1,I,J), pIF=
  stop IF, s3 = Initialize s, P3 = P +* pIF,
  s4 = Comput(P3,s3,1), P4 = P3;
  set i = (a,k1)<>0_goto (card I + 2);
  set G =Goto (card J+1), iG=i ';' I ';' G;
A3: IF = i ';' (I ';' G) ';' J by SCMPDS_4:14
    .= i ';' (I ';' G ';' J) by SCMPDS_4:14;
A4: Comput(P3, s3,0 + 1) = Following(P3,Comput(P3,s3,0)) by EXTPRO_1:3
    .= Following(P3,s3) by EXTPRO_1:2
    .= Exec(i,s3) by A3,Th22;
A5: not b in dom Start-At(0,SCMPDS) by SCMPDS_4:18;
  not a in dom Start-At(0,SCMPDS) by SCMPDS_4:18;
  then
A6: s3.DataLoc(s3.a,k1)=s3.b by FUNCT_4:11
    .= s.b by A5,FUNCT_4:11;
A7: IC s3 = 0 by MEMSTR_0:47;
  assume
  s.b <> 0;
  then
A8: IC s4 = ICplusConst(s3,card I + 2) by A4,A6,SCMPDS_2:55
    .= (0+(card I + 2)) by A7,Th23;
  assume
A9: J is_closed_on s,P;
  then
A10: Start-At(0,SCMPDS) c= s1 & J is_closed_on s1,P1 by Th38,FUNCT_4:25;
A11: pIF c= P3 by FUNCT_4:25;
A12: card iG = card (i ';' I) + card G by AFINSQ_1:17
    .=card (i ';' I) + 1 by COMPOS_1:54
    .=card I +1 +1 by Th15
    .=card I +(1 +1);
  then Shift(pJ,card I+2) c= pIF by Th24;
  then
A13: Shift(pJ,card I+2) c= P4 by A11,XBOOLE_1:1;
  assume
  J is_halting_on s,P;
  then
A14: P1 halts_on s1 by Def3;
  for a holds s1.a = s4.a by A4,SCMPDS_2:55;
  then
A16: DataPart s1 = DataPart s4 by SCMPDS_4:8;
UU:  pJ c= P1 by FUNCT_4:25;
  now
    let k be Element of NAT;
    per cases;
    suppose
      0 < k;
      then consider k1 being Nat such that
A17:  k1 + 1 = k by NAT_1:6;
      reconsider k1 as Element of NAT by ORDINAL1:def 12;
      reconsider m = IC Comput(P1, s1,k1) as Element of NAT;
       m in dom pJ by A9,Def2;
      then m < card pJ by AFINSQ_1:66;
      then
A18:  m + (card I + 2) < card pJ + (card I + 2) by XREAL_1:6;
A19:  card pJ = card J + 1 by COMPOS_1:55;
A20:  card pIF = card IF+1 by COMPOS_1:55
        .=card I +2 +card J +1 by A12,AFINSQ_1:17
        .=card I +2 + card pJ by A19;
      IC Comput(P3,s3,k) = IC Comput(P3, s4,k1) by A17,EXTPRO_1:4
        .=  (m + (card I + 2)) by A10,A16,A13,A8,Th45,UU;
      hence IC Comput(P3,s3,k) in dom pIF by A20,A18,AFINSQ_1:66;
    end;
    suppose
      k = 0;
      then Comput(P3,s3,k) = s3 by EXTPRO_1:2;
      hence IC Comput(P3,s3,k) in dom pIF by A7,COMPOS_1:36;
    end;
  end;
  hence IF is_closed_on s,P by Def2;
A23: Comput(P3,s3,LifeSpan(P1,s1)+1)
= Comput(P3,Comput(P3,s3,1),LifeSpan(P1,
s1))
 by EXTPRO_1:4;
  CurInstr(P3,
  Comput(P3,s3,LifeSpan(P1,s1)+1))
   =CurInstr(P4,
   Comput(P4,s4,LifeSpan(P1,s1))) by A23
    .=CurInstr(P1,
    Comput(P1,s1,LifeSpan(P1,s1))) by A10,A16,A13,A8,Th45,UU
    .= halt SCMPDS by A14,EXTPRO_1:def 15;
  then P3 halts_on s3 by EXTPRO_1:29;
  hence thesis by Def3;
end;

theorem Th54:
  for s being 0-started State of SCMPDS,I being halt-free shiftable
Program of SCMPDS, J being shiftable Program of SCMPDS,a being Int_position,k1
  being Integer st s.DataLoc(s.a,k1)= 0 & I is_closed_on s,P &
  I is_halting_on s,P
holds IExec(if=0(a,k1,I,J),P,s)
 = IExec(I,P,s) +* Start-At((card I + card J+ 2),SCMPDS)
proof
  let s be 0-started State of SCMPDS,
      I be halt-free shiftable Program of SCMPDS, J be
  shiftable Program of SCMPDS,a be Int_position,k1 be Integer;
  set b=DataLoc(s.a,k1);
  assume
A1: s.b = 0;
  set i = (a,k1)<>0_goto (card I + 2);
  set G=Goto (card J+1);
  set I2 = I ';' G ';' J, IF=if=0(a,k1,I,J), pI2=
stop I2, s2 = s, s3 = s,
  P2 = P +* pI2, P3 = P +* stop IF,
  s4 = Comput(P3,s3,1), P4 = P3;
I: Initialize s = s by MEMSTR_0:44;
  then
A4: IC s3 = 0 by MEMSTR_0:47;
A6: IF = i ';' (I ';' G) ';' J by SCMPDS_4:14
    .= i ';' I2 by SCMPDS_4:14;
  then
A7: Shift(pI2,1) c= P4 by Lm6;
A8: Comput(P3, s3,0 + 1) = Following(P3,Comput(P3,s3,0)) by EXTPRO_1:3
    .= Following(P3,s3) by EXTPRO_1:2
    .= Exec(i,s3) by A6,Th22,I;
  s3.DataLoc(s3.a,k1)=s3.b
    .=0 by A1;
  then
A9: IC s4 = succ IC s3 by A8,SCMPDS_2:55
    .= (0+1) by A4;
  for a holds s2.a = s4.a by A8,SCMPDS_2:55;
  then
A11: DataPart s2 = DataPart s4 by SCMPDS_4:8;
  set SAl= Start-At((card I + card J + 2),SCMPDS);
  assume
A13: I is_closed_on s,P;
  assume
A14: I is_halting_on s,P;
  then I2 is_halting_on s,P by A13,Th44;
  then
A15: P2 halts_on s2 by Def3,I;
  I2 is_closed_on s,P by A13,A14,Th44;
  then
A16: Start-At(0,SCMPDS) c= s2 & I2 is_closed_on s2,P2 by Th38,FUNCT_4:25,I;
UU:  stop I2 c= P2 by FUNCT_4:25;
A18: Comput(P3,s3,LifeSpan(P2,s2)+1)
 = Comput(P3,Comput(P3,s3,1),LifeSpan(P2,s2))
 by EXTPRO_1:4;
A21: CurInstr(P3,
Comput(P3,s3,LifeSpan(P2,s2)+1))
 =CurInstr(P3,
 Comput(P3,s4,LifeSpan(P2,s2))) by A18
    .=CurInstr(P2,
    Comput(P2,s2,LifeSpan(P2,s2))) by A16,A7,A9,A11,Th45,UU
    .= halt SCMPDS by A15,EXTPRO_1:def 15;
  then
A22: P3 halts_on s3 by EXTPRO_1:29;
A23: CurInstr(P3,s3) = i by A6,Th22,I;
  now
    let l be Element of NAT;
    assume
A24: l < LifeSpan(P2,s2) + 1;
A25: Comput(P3,s3,0) = s3 by EXTPRO_1:2;
    per cases;
    suppose
      l = 0;
      then CurInstr(P3,Comput(P3,s3,l)) =
      CurInstr(P3,s3)
       by A25;
      hence CurInstr(P3,Comput(P3,s3,l)) <>
      halt SCMPDS by A23;
    end;
    suppose
      l <> 0;
      then consider n be Nat such that
A26:  l = n + 1 by NAT_1:6;
      reconsider n as Element of NAT by ORDINAL1:def 12;
A27:  n < LifeSpan(P2,s2) by A24,A26,XREAL_1:6;
      assume
A28:  CurInstr(P3,Comput(P3,s3,l)) = halt SCMPDS;
A32: Comput(P3,s3,n+1)
 = Comput(P3,Comput(P3,s3,1),n) by EXTPRO_1:4;
      CurInstr(P2,Comput(P2,s2,n))
       = CurInstr(P3,Comput(P3,s4,n))
       by A16,A7,A9,A11,Th45,UU
        .= halt SCMPDS by A26,A28,A32;
      hence contradiction by A15,A27,EXTPRO_1:def 15;
    end;
  end;
  then for l be Element of NAT st CurInstr(P3,
  Comput(P3,s3,l)) = halt SCMPDS
  holds LifeSpan(P2,s2) + 1 <= l;
  then
A33: LifeSpan(P3,s3) = LifeSpan(P2,s2) + 1 by A21,A22,EXTPRO_1:def 15;
A35: DataPart Result(P2,s2) = DataPart Comput(P2, s2
,LifeSpan(P2,s2)) by A15,EXTPRO_1:23
    .= DataPart Comput(P3, s4,LifeSpan(P2,s2)) by A16,A7,A9,A11,Th45,UU
    .= DataPart Comput(P3, s3,LifeSpan(P2,s2) + 1)
by EXTPRO_1:4
    .= DataPart Result(P3,s3) by A22,A33,EXTPRO_1:23;
A36: now
    let x be set;
A37: dom SAl = {IC SCMPDS} by FUNCOP_1:13;
    assume
A38: x in dom IExec(IF,P,s);
    per cases by A38,SCMPDS_4:6;
    suppose
A39:  x is Int_position;
      then x <> IC SCMPDS by SCMPDS_2:43;
      then
A40:  not x in dom SAl by A37,TARSKI:def 1;
      thus IExec(IF,P,s).x = (Result(P3,s3)).x
        .= (Result(P2,s2)).x by A35,A39,SCMPDS_4:8
        .= IExec(I2,P,s).x
        .= (IExec(I2,P,s) +* SAl).x by A40,FUNCT_4:11;
    end;
    suppose
A42:  x = IC SCMPDS;
A44:  IC Result(P2,s2) = IC IExec(I2,P,s)
        .=  (card I + card J + 1) by A13,A14,Th46;
A45:  x in dom SAl by A37,A42,TARSKI:def 1;
      thus IExec(IF,P,s).x = (Result(P3,s3)).x
        .= Comput(P3, s3,LifeSpan(P2,s2) + 1).x by A22,A33,EXTPRO_1:23
        .= IC Comput(P3, s4,LifeSpan(P2,s2)) by A42,EXTPRO_1:4
        .= IC Comput(P2, s2,LifeSpan(P2,s2)) + 1
        by A16,A7,A9,A11,Th45,UU
        .= IC Result(P2,s2) + 1 by A15,EXTPRO_1:23
        .= IC Start-At ((card I + card J + 1) + 1,SCMPDS)
        by A44,FUNCOP_1:72
        .= (IExec(I2,P,s) +* SAl).x by A42,A45,FUNCT_4:13;
    end;
  end;
  dom IExec(IF,P,s) = the carrier of SCMPDS by PARTFUN1:def 2
    .= dom (IExec(I2,P,s) +* SAl) by PARTFUN1:def 2;
  hence IExec(IF,P,s) = IExec(I2,P,s) +* SAl by A36,FUNCT_1:2
    .= IExec(I,P,s) +* Start-At((card I+card J+1),SCMPDS)
     +* Start-At((card I + card J + 2),SCMPDS) by A13,A14,Th47
    .= IExec(I,P,s) +* SAl by MEMSTR_0:36;
end;

theorem Th55:
  for s being State of SCMPDS,I being Program of SCMPDS,J being
  halt-free shiftable Program of SCMPDS,a being Int_position,k1 being Integer
  st s.DataLoc(s.a,k1)<> 0 & J is_closed_on s,P & J is_halting_on s,P
   holds IExec(if=0(a,k1,I,J),P,Initialize s) = IExec(J,P,Initialize s) +*
  Start-At((card I + card J + 2),SCMPDS)
proof
  let s be State of SCMPDS,I be Program of SCMPDS,J be halt-free shiftable
  Program of SCMPDS,a be Int_position,k1 be Integer;
  set b=DataLoc(s.a,k1);
  set pJ=stop J, s1 = Initialize s, P1 = P +* pJ,
  P2 = P +* pJ,
  IF=if=0(a,k1,I,J), pIF=
  stop IF, s3 = Initialize s, P3 = P +* pIF,
  s4 = Comput(P3,s3,1), P4 = P3;
  set i = (a,k1)<>0_goto (card I + 2);
  set G =Goto (card J+1), iG=i ';' I ';' G;
  set SAl=Start-At((card I+card J+2),SCMPDS);
A3: IF = i ';' (I ';' G) ';' J by SCMPDS_4:14
    .= i ';' (I ';' G ';' J) by SCMPDS_4:14;
A4: Comput(P3, s3,0 + 1) = Following(P3,Comput(P3,s3,0)) by EXTPRO_1:3
    .= Following(P3,s3) by EXTPRO_1:2
    .= Exec(i,s3) by A3,Th22;
A5: not b in dom Start-At(0,SCMPDS) by SCMPDS_4:18;
  not a in dom Start-At(0,SCMPDS) by SCMPDS_4:18;
  then
A6: s3.DataLoc(s3.a,k1)=s3.b by FUNCT_4:11
    .= s.b by A5,FUNCT_4:11;
A7: IC s3 = 0 by MEMSTR_0:47;
  assume
  s.b <> 0;
  then
A9: IC s4 = ICplusConst(s3,card I + 2) by A4,A6,SCMPDS_2:55
    .= (0+(card I + 2)) by A7,Th23;
  for a holds s1.a= s4.a by A4,SCMPDS_2:55;
  then
A11: DataPart s1 = DataPart s4 by SCMPDS_4:8;
  card iG = card (i ';' I) + card G by AFINSQ_1:17
    .=card (i ';' I) + 1 by COMPOS_1:54
    .=card I +1 +1 by Th15
    .=card I +(1 +1);
  then
A12: Shift(pJ,card I+2) c= pIF by Th24;
  pIF c= P3 by FUNCT_4:25;
  then Shift(pJ,card I+2) c= P3 by A12,XBOOLE_1:1;
  then
A13: Shift(pJ,card I+2) c= P4;
  assume
A14: J is_closed_on s,P;
  then
A15: Start-At(0,SCMPDS) c= s1 & J is_closed_on s1,P1 by Th38,FUNCT_4:25;
UU:  stop J c= P1 by FUNCT_4:25;
  assume
A16: J is_halting_on s,P;
  then
A17: P1 halts_on s1 by Def3;
A19: Comput(P3,s3,LifeSpan(P1,s1)+1) =
Comput(P3,Comput(P3,s3,1),LifeSpan(P1,s1
))
 by EXTPRO_1:4;
A22: CurInstr(P3,
Comput(P3,s3,LifeSpan(P1,s1)+1))
 =CurInstr(P3,
 Comput(P3,s4,LifeSpan(P1,s1))) by A19
    .=CurInstr(P1,
    Comput(P1,s1,LifeSpan(P1,s1))) by A15,A13,A9,A11,Th45,UU
    .= halt SCMPDS by A17,EXTPRO_1:def 15;
  then
A23: P3 halts_on s3 by EXTPRO_1:29;
A24: CurInstr(P3,s3) = i by A3,Th22;
  now
    let l be Element of NAT;
    assume
A25: l < LifeSpan(P1,s1) + 1;
A26: Comput(P3,s3,0) = s3 by EXTPRO_1:2;
    per cases;
    suppose
      l = 0;
      then CurInstr(P3,Comput(P3,s3,l))
       = CurInstr(P3,s3)
       by A26;
      hence CurInstr(P3,Comput(P3,s3,l)) <>
       halt SCMPDS by A24;
    end;
    suppose
      l <> 0;
      then consider n be Nat such that
A27:  l = n + 1 by NAT_1:6;
      reconsider n as Element of NAT by ORDINAL1:def 12;
A28:  n < LifeSpan(P1,s1) by A25,A27,XREAL_1:6;
      assume
A29:  CurInstr(P3,Comput(P3,s3,l)) = halt SCMPDS;
A31: Comput(P3,s3,n+1) =
Comput(P3,Comput(P3,s3,1),n) by EXTPRO_1:4;
      CurInstr(P1,Comput(P1,
s1,n))
       = CurInstr(P3,
      Comput(P3,s4,n)) by A15,A13,A9,A11,Th45,UU
        .= halt SCMPDS by A27,A29,A31;
      hence contradiction by A17,A28,EXTPRO_1:def 15;
    end;
  end;
  then for l be Element of NAT st CurInstr(P3,
  Comput(P3,s3,l)) = halt SCMPDS
  holds LifeSpan(P1,s1) + 1 <= l;
  then
A34: LifeSpan(P3,s3) = LifeSpan(P1,s1) + 1 by A22,A23,EXTPRO_1:def 15;
A35: DataPart Result(P1,s1) = DataPart Comput(P1, s1
,LifeSpan(P1,s1)) by A17,EXTPRO_1:23
    .= DataPart Comput(P3, s4,LifeSpan(P1,s1))
    by A15,A13,A9,A11,Th45,UU
    .= DataPart Comput(P3, s3,LifeSpan(P1,s1) + 1)
    by EXTPRO_1:4
    .= DataPart Result(P3,s3) by A23,A34,EXTPRO_1:23;
A36: now
    let x be set;
A37: dom SAl = {IC SCMPDS} by FUNCOP_1:13;
    assume
A38: x in dom IExec(IF,P,Initialize s);
    per cases by A38,SCMPDS_4:6;
    suppose
A39:  x is Int_position;
      then x <> IC SCMPDS by SCMPDS_2:43;
      then
A40:  not x in dom SAl by A37,TARSKI:def 1;
      thus IExec(IF,P,Initialize s).x = (Result(P3,s3)).x
        .= (Result(P1,s1)).x by A35,A39,SCMPDS_4:8
        .= IExec(J,P,Initialize s).x
        .= (IExec(J,P,Initialize s) +* SAl).x by A40,FUNCT_4:11;
    end;
    suppose
A42:  x = IC SCMPDS;
A44:  IC Result(P1,s1) = IC IExec(J,P,Initialize s)
        .=  (card J) by A14,A16,Th48;
A46:  x in dom SAl by A37,A42,TARSKI:def 1;
      thus IExec(IF,P,Initialize s).x = (Result(P3,s3)).x
        .= Comput(P3, s3,LifeSpan(P1,s1) + 1).x by A23,A34,EXTPRO_1:23
        .= IC Comput(P3, s4,LifeSpan(P1,s1)) by A42,EXTPRO_1:4
        .= IC Comput(P1, s1,LifeSpan(P1,s1)) + (card I + 2)
               by A15,A13,A9,A11,Th45,UU
        .= IC Result(P1,s1) + (card I + 2) by A17,EXTPRO_1:23
        .= IC Start-At (card J + (card I + 2),SCMPDS) by A44,FUNCOP_1:72
        .= (IExec(J,P,Initialize s) +* SAl).x by A42,A46,FUNCT_4:13;
    end;
  end;
  dom IExec(IF,P,Initialize s) = the carrier of SCMPDS by PARTFUN1:def 2
    .= dom (IExec(J,P,Initialize s) +* SAl) by PARTFUN1:def 2;
  hence thesis by A36,FUNCT_1:2;
end;

registration
  let I,J be shiftable parahalting Program of SCMPDS, a be Int_position,k1 be
  Integer;
  cluster if=0(a,k1,I,J) -> shiftable parahalting;
  correctness
  proof
    set i = (a,k1)<>0_goto (card I + 2), G =Goto (card J+1);
    set IF=if=0(a,k1,I,J);
    reconsider IJ=I ';' G ';' J as shiftable Program of SCMPDS;
    thus IF is shiftable;
      let s be 0-started State of SCMPDS;
      let P be Instruction-Sequence of SCMPDS;
A1:  Initialize s = s by MEMSTR_0:44;
      assume stop IF c= P;
      then
A2:   P = P +* stop IF by FUNCT_4:98;
A3:   J is_closed_on s,P & J is_halting_on s,P by Th34,Th35;
A4:   I is_closed_on s,P & I is_halting_on s,P by Th34,Th35;
      per cases;
      suppose
        s.DataLoc(s.a,k1)= 0;
        then IF is_halting_on s,P by A4,Th52;
        hence P halts_on s by A1,A2,Def3;
      end;
      suppose
        s.DataLoc(s.a,k1) <> 0;
        then IF is_halting_on s,P by A3,Th53;
        hence P halts_on s by A1,A2,Def3;
      end;
  end;
end;

registration
  let I,J be halt-free Program of SCMPDS, a be Int_position,k1 be Integer;
  cluster if=0(a,k1,I,J) -> halt-free;
  coherence;
end;

theorem
  for s being 0-started State of SCMPDS,I,J being halt-free shiftable
  parahalting Program of SCMPDS,a being Int_position,k1 being Integer holds IC
  IExec(if=0(a,k1,I,J),P,s) = card I + card J + 2
proof
  let s be 0-started State of SCMPDS,
      I,J be halt-free shiftable parahalting Program of
  SCMPDS,a be Int_position,k1 be Integer;
  set IF=if=0(a,k1,I,J);
A1: J is_closed_on s,P & J is_halting_on s,P by Th34,Th35;
A2: I is_closed_on s,P & I is_halting_on s,P by Th34,Th35;
I: Initialize s = s by MEMSTR_0:44;
  hereby
    per cases;
    suppose
      s.DataLoc(s.a,k1) = 0;
      then
      IExec(IF,P,s) = IExec(I,P,s) +* Start-At((card I+card J+2),SCMPDS)
      by A2,Th54;
      hence thesis by FUNCT_4:113;
    end;
    suppose
      s.DataLoc(s.a,k1) <> 0;
      then
      IExec(IF,P,s) = IExec(J,P,s) +* Start-At((card I+card J+2),SCMPDS)
      by A1,Th55,I;
      hence thesis by FUNCT_4:113;
    end;
  end;
end;

theorem
  for s being 0-started State of SCMPDS,I being halt-free shiftable parahalting
  Program of SCMPDS,J being shiftable Program of SCMPDS,a,b being Int_position,
  k1 being Integer st s.DataLoc(s.a,k1)= 0 holds
   IExec(if=0(a,k1,I,J),P,s).b = IExec(I,P,s).b
proof
  let s be 0-started State of SCMPDS,
      I be halt-free shiftable parahalting Program of
  SCMPDS,J be shiftable Program of SCMPDS,a,b be Int_position, k1 be Integer;
  assume
A1: s.DataLoc(s.a,k1)=0;
A2: not b in dom Start-At((card I+card J+2),SCMPDS) by SCMPDS_4:18;
  I is_closed_on s,P & I is_halting_on s,P by Th34,Th35;
  then
  IExec(if=0(a,k1,I,J),P,s) = IExec(I,P,s)
   +* Start-At((card I + card J + 2),SCMPDS) by A1,Th54;
  hence thesis by A2,FUNCT_4:11;
end;

theorem
  for s being State of SCMPDS,I being Program of SCMPDS,J being
  halt-free parahalting shiftable Program of SCMPDS,a,b being Int_position,k1
being Integer st s.DataLoc(s.a,k1)<> 0 holds
 IExec(if=0(a,k1,I,J),P,Initialize s).b = IExec(J,P,Initialize s).b
proof
  let s be State of SCMPDS,I be Program of SCMPDS,J be halt-free parahalting
  shiftable Program of SCMPDS,a,b be Int_position, k1 be Integer;
  assume
A1: s.DataLoc(s.a,k1)<>0;
A2: not b in dom Start-At((card I+card J+2),SCMPDS) by SCMPDS_4:18;
  J is_closed_on s,P & J is_halting_on s,P by Th34,Th35;
  then
  IExec(if=0(a,k1,I,J),P,Initialize s)
   = IExec(J,P,Initialize s) +* Start-At((card I + card J
  + 2),SCMPDS) by A1,Th55;
  hence thesis by A2,FUNCT_4:11;
end;

begin :: The computation of "if var=0 then block"

theorem
  card if=0(a,k1,I) = card I + 1 by Th15;

theorem
   0 in dom if=0(a,k1,I)
proof
  set ci=card if=0(a,k1,I);
  ci=card I + 1 by Th15;
  hence thesis by AFINSQ_1:66;
end;

theorem
  if=0(a,k1,I). 0 = (a,k1)<>0_goto (card I + 1) by Th16;

theorem Th62:
  for s being State of SCMPDS, I being shiftable Program of SCMPDS
  , a being Int_position,k1 being Integer st s.DataLoc(s.a,k1)= 0 & I
is_closed_on s,P & I is_halting_on s,P holds if=0(a,k1,I) is_closed_on s,P
 & if=0(a,k1,I) is_halting_on s,P
proof
  let s be State of SCMPDS, I be shiftable Program of SCMPDS, a be
  Int_position,k1 be Integer;
  set b=DataLoc(s.a,k1);
  assume
A1: s.b = 0;
  set i = (a,k1)<>0_goto (card I + 1);
  set IF=if=0(a,k1,I), pIF=stop IF, pI=stop I,
  s2 = Initialize s, s3 = Initialize s,
  P2 = P +* pI, P3 = P +* pIF,
  s4 = Comput(P3,s3,1), P4 = P3;
A4: IC s3 = 0 by MEMSTR_0:47;
A5: not b in dom Start-At(0,SCMPDS) by SCMPDS_4:18;
A6: Comput(P3, s3,0 + 1) = Following(P3,Comput(P3,s3,0)) by EXTPRO_1:3
    .= Following(P3,s3) by EXTPRO_1:2
    .= Exec(i,s3) by Th22;
  for a holds s2.a = s4.a by A6,SCMPDS_2:55;
  then
A8: DataPart s2 = DataPart s4 by SCMPDS_4:8;
  not a in dom Start-At(0,SCMPDS) by SCMPDS_4:18;
  then s3.DataLoc(s3.a,k1)=s3.b by FUNCT_4:11
    .=0 by A1,A5,FUNCT_4:11;
  then
A9: IC s4 = succ IC s3 by A6,SCMPDS_2:55
    .= (0+1) by A4;
  assume
A10: I is_closed_on s,P;
  then
A11: I is_closed_on s2,P2 by Th38;
  assume
  I is_halting_on s,P;
  then
A12: P2 halts_on s2 by Def3;
A13:  0 in dom pIF by COMPOS_1:36;
A14: Start-At(0,SCMPDS) c= s2 & Shift(pI,1) c= P4 by Lm6,FUNCT_4:25;
UU:  stop I c= P2 by FUNCT_4:25;
A15: card pIF = card IF +1 by COMPOS_1:55
    .= card I +1+1 by Th15;
  now
    let k be Element of NAT;
    per cases;
    suppose
      0 < k;
      then consider k1 being Nat such that
A16:  k1 + 1 = k by NAT_1:6;
      reconsider k1 as Element of NAT by ORDINAL1:def 12;
      reconsider m = IC Comput(P2, s2,k1) as Element of NAT;
A17:  card pIF = card pI+1 by A15,COMPOS_1:55;
       m in dom pI by A10,Def2;
      then m < card pI by AFINSQ_1:66;
      then
A18:  m+1 < card pIF by A17,XREAL_1:6;
      IC Comput(P3,s3,k) = IC Comput(P3, s4,k1) by A16,EXTPRO_1:4
        .=  (m + 1) by A11,A14,A9,A8,Th45,UU;
      hence IC Comput(P3,s3,k) in dom pIF by A18,AFINSQ_1:66;
    end;
    suppose
      k = 0;
      hence IC Comput(P3,s3,k) in dom pIF by A13,A4,EXTPRO_1:2;
    end;
  end;
  hence IF is_closed_on s,P by Def2;
A21: Comput(P3,s3,LifeSpan(P2,s2)+1)
 = Comput(P3,Comput(P3,s3,1),LifeSpan(P2
,s2))
 by EXTPRO_1:4;
  CurInstr(P3,
  Comput(P3,s3,LifeSpan(P2,s2)+1))
   =CurInstr(P3,
   Comput(P3,s4,LifeSpan(P2,s2))) by A21
    .=CurInstr(P2,
    Comput(P2,s2,LifeSpan(P2,s2))) by A11,A14,A9,A8,Th45,UU
    .= halt SCMPDS by A12,EXTPRO_1:def 15;
  then P3 halts_on s3 by EXTPRO_1:29;
  hence thesis by Def3;
end;

theorem Th63:
  for s being State of SCMPDS,I being Program of SCMPDS, a being
  Int_position, k1 being Integer st s.DataLoc(s.a,k1)<> 0 holds if=0(a,k1,I)
  is_closed_on s,P & if=0(a,k1,I) is_halting_on s,P
proof
  let s be State of SCMPDS,I be Program of SCMPDS, a be Int_position,k1 be
  Integer;
  set b=DataLoc(s.a,k1);
  assume
A1: s.b <> 0;
  set i = (a,k1)<>0_goto (card I + 1);
  set IF=if=0(a,k1,I), pIF=stop IF, s3 = Initialize s,
  P3 = P +* pIF,
  s4 = Comput(P3,s3,1), P4 = P3;
A4: IC s3 = 0 by MEMSTR_0:47;
A5: not b in dom Start-At(0,SCMPDS) by SCMPDS_4:18;
  not a in dom Start-At(0,SCMPDS) by SCMPDS_4:18;
  then
A6: s3.DataLoc(s3.a,k1)=s3.b by FUNCT_4:11
    .= s.b by A5,FUNCT_4:11;
  Comput(P3, s3,0 + 1) = Following(P3,Comput(P3,s3,0)) by EXTPRO_1:3
    .= Following(P3,s3) by EXTPRO_1:2
    .= Exec(i,s3) by Th22;
  then
A7: IC s4 = ICplusConst(s3,card I + 1) by A1,A6,SCMPDS_2:55
    .= (0+(card I + 1)) by A4,Th23;
A8: card IF=card I+1 by Th15;
  then
A9: (card I+1) in dom pIF by COMPOS_1:64;
A10:  P3/.IC s4
 = P3.IC s4 by PBOOLE:143;
  pIF c= P3 by FUNCT_4:25;
  then pIF c= P4;
  then P4.(card I+1) = pIF.(card I+1) by A9,GRFUNC_1:2
    .=halt SCMPDS by A8,COMPOS_1:64;
  then
A11: CurInstr(P3,s4) = halt SCMPDS by A7,A10;
  now
    let k be Element of NAT;
    per cases;
    suppose
      0 < k;
      then 1+0 <= k by INT_1:7;
      hence IC Comput(P3,s3,k) in dom pIF by A9,A7,A11,EXTPRO_1:5;
    end;
    suppose
      k = 0;
      then Comput(P3,s3,k) = s3 by EXTPRO_1:2;
      hence IC Comput(P3,s3,k) in dom pIF by A4,COMPOS_1:36;
    end;
  end;
  hence IF is_closed_on s,P by Def2;
  P3 halts_on s3 by A11,EXTPRO_1:29;
  hence thesis by Def3;
end;

theorem Th64:
  for s being State of SCMPDS,I being halt-free shiftable
Program of SCMPDS, a being Int_position,k1 being Integer st s.DataLoc(s.a,k1)=
0 & I is_closed_on s,P & I is_halting_on s,P holds
 IExec(if=0(a,k1,I),P,Initialize s) = IExec(I,P,Initialize s)
  +* Start-At((card I+1),SCMPDS)
proof
  let s be State of SCMPDS,I be halt-free shiftable Program of SCMPDS, a be
  Int_position,k1 be Integer;
  set b=DataLoc(s.a,k1);
  assume
A1: s.b = 0;
  set i = (a,k1)<>0_goto (card I + 1);
  set IF=if=0(a,k1,I), pI=stop I, pIF = stop IF,
  s2 = Initialize s, P2 = P +* pI,
  s3 = Initialize s, P3 = P +* pIF,
  s4 = Comput(P3, s3,1), P4 = P3;
A4: IC s3 = 0 by MEMSTR_0:47;
A5: not b in dom Start-At(0,SCMPDS) by SCMPDS_4:18;
A6: Comput(P3, s3,0 + 1) = Following(P3,Comput(P3,s3,0)) by EXTPRO_1:3
    .= Following(P3,s3) by EXTPRO_1:2
    .= Exec(i,s3) by Th22;
  not a in dom Start-At(0,SCMPDS) by SCMPDS_4:18;
  then s3.DataLoc(s3.a,k1)=s3.b by FUNCT_4:11
    .=0 by A1,A5,FUNCT_4:11;
  then
A7: IC s4 = succ IC s3 by A6,SCMPDS_2:55
    .= (0+1) by A4;
  for a holds s2.a = s4.a by A6,SCMPDS_2:55;
  then
A9: DataPart s2 = DataPart s4 by SCMPDS_4:8;
  assume
A10: I is_closed_on s,P;
  then
A11: I is_closed_on s2,P2 by Th38;
  set SAl=Start-At((card I+1),SCMPDS);
A13: Start-At(0,SCMPDS) c= s2 & Shift(pI,1) c= P4 by Lm6,FUNCT_4:25;
UU:  stop I c= P2 by FUNCT_4:25;
  assume
A14: I is_halting_on s,P;
  then
A15: P2 halts_on s2 by Def3;
A17: Comput(P3,s3,LifeSpan(P2,s2)+1)
 = Comput(P3,Comput(P3,s3,1),LifeSpan(P2
,s2))
by EXTPRO_1:4;
A20: CurInstr(P3,
Comput(P3,s3,LifeSpan(P2,s2)+1))
 =CurInstr(P3,
 Comput(P3,s4,LifeSpan(P2,s2))) by A17
    .=CurInstr(P2,
    Comput(P2,s2,LifeSpan(P2,s2))) by A11,A13,A7,A9,Th45,UU
    .= halt SCMPDS by A15,EXTPRO_1:def 15;
  then
A21: P3 halts_on s3 by EXTPRO_1:29;
A22: CurInstr(P3,s3) = i by Th22;
  now
    let l be Element of NAT;
    assume
A23: l < LifeSpan(P2,s2) + 1;
A24: Comput(P3,s3,0) = s3 by EXTPRO_1:2;
    per cases;
    suppose
      l = 0;
      then CurInstr(P3,Comput(P3,s3,l))
       = CurInstr(P3,s3)
       by A24;
      hence CurInstr(P3,Comput(P3,s3,l)) <>
       halt SCMPDS by A22;
    end;
    suppose
      l <> 0;
      then consider n be Nat such that
A25:  l = n + 1 by NAT_1:6;
      reconsider n as Element of NAT by ORDINAL1:def 12;
A26:  n < LifeSpan(P2,s2) by A23,A25,XREAL_1:6;
      assume
A27:  CurInstr(P3,Comput(P3,s3,l)) = halt SCMPDS;
A31: Comput(P3,s3,n+1)
 = Comput(P3,Comput(P3,s3,1),n) by EXTPRO_1:4;
      CurInstr(P2,Comput(P2,s2,n)) =
      CurInstr(P3,Comput(P3,s4,n)) by A11,A13,A7,A9,Th45,UU
        .= halt SCMPDS by A25,A27,A31;
      hence contradiction by A15,A26,EXTPRO_1:def 15;
    end;
  end;
  then for l be Element of NAT st CurInstr(P3,
  Comput(P3,s3,l)) = halt SCMPDS
  holds LifeSpan(P2,s2) + 1 <= l;
  then
A32: LifeSpan(P3,s3) = LifeSpan(P2,s2) + 1 by A20,A21,EXTPRO_1:def 15;
A34: DataPart Result(P2,s2) = DataPart Comput(P2, s2
,LifeSpan(P2,s2)) by A15,EXTPRO_1:23
    .= DataPart Comput(P3, s4,LifeSpan(P2,s2)) by A11,A13,A7,A9,Th45,UU
    .= DataPart Comput(P3, s3,LifeSpan(P2,s2) + 1)
by EXTPRO_1:4
    .= DataPart Result(P3,s3) by A21,A32,EXTPRO_1:23;
A35: now
    let x be set;
A36: dom SAl = {IC SCMPDS} by FUNCOP_1:13;
    assume
A37: x in dom IExec(IF,P,Initialize s);
    per cases by A37,SCMPDS_4:6;
    suppose
A38:  x is Int_position;
      then x <> IC SCMPDS by SCMPDS_2:43;
      then
A39:  not x in dom SAl by A36,TARSKI:def 1;
      thus IExec(IF,P,Initialize s).x = (Result(P3,s3)).x
        .= (Result(P2,s2)).x by A34,A38,SCMPDS_4:8
        .= IExec(I,P,Initialize s).x
        .= (IExec(I,P,Initialize s) +* SAl).x by A39,FUNCT_4:11;
    end;
    suppose
A41:  x = IC SCMPDS;
A43:  IC Result(P2,s2) = IC IExec(I,P,Initialize s)
        .=  card I by A10,A14,Th48;
A44:  x in dom SAl by A36,A41,TARSKI:def 1;
      thus IExec(IF,P,Initialize s).x = (Result(P3,s3)).x
        .= Comput(P3, s3,LifeSpan(P2,s2) + 1).x by A21,A32,EXTPRO_1:23
        .= IC Comput(P3, s4,LifeSpan(P2,s2)) by A41,EXTPRO_1:4
        .= IC Comput(P2, s2,LifeSpan(P2,s2)) + 1
        by A11,A13,A7,A9,Th45,UU
        .= IC Result(P2,s2) + 1 by A15,EXTPRO_1:23
        .= IC Start-At((card I+1),SCMPDS) by A43,FUNCOP_1:72
        .= (IExec(I,P,Initialize s) +* SAl).x by A41,A44,FUNCT_4:13;
    end;
  end;
  dom IExec(IF,P,Initialize s) = the carrier of SCMPDS by PARTFUN1:def 2
    .= dom (IExec(I,P,Initialize s) +* SAl) by PARTFUN1:def 2;
  hence thesis by A35,FUNCT_1:2;
end;

theorem Th65:
  for s being State of SCMPDS,I being Program of SCMPDS,a being
Int_position, k1 being Integer st s.DataLoc(s.a,k1)<> 0
 holds IExec(if=0(a,k1,I),P,Initialize s) = s +* Start-At((card I+1),SCMPDS)
proof
  let s be State of SCMPDS,I be Program of SCMPDS,a be Int_position, k1 be
  Integer;
  set b=DataLoc(s.a,k1);
  set IF=if=0(a,k1,I), pIF=stop IF,
  s3 = Initialize s, P3 = P +* pIF,
  s4 = Comput(P3, s3,1), P4 = P3;
  set i = (a,k1)<>0_goto (card I + 1);
  set SAl=Start-At((card I+1),SCMPDS);
A2: IC s3 = 0 by MEMSTR_0:47;
A3: not b in dom Start-At(0,SCMPDS) by SCMPDS_4:18;
  not a in dom Start-At(0,SCMPDS) by SCMPDS_4:18;
  then
A4: s3.DataLoc(s3.a,k1)=s3.b by FUNCT_4:11
    .= s.b by A3,FUNCT_4:11;
A5: Comput(P3, s3,0 + 1) = Following(P3,Comput(P3,s3,0)) by EXTPRO_1:3
    .= Following(P3,s3) by EXTPRO_1:2
    .= Exec(i,s3) by Th22;
  assume
  s.b <> 0;
  then
A6: IC s4 = ICplusConst(s3,card I + 1) by A5,A4,SCMPDS_2:55
    .= (0+(card I + 1)) by A2,Th23;
A7: pIF c= P4 by FUNCT_4:25;
A8:  P3/.IC s4
 = P3.IC s4 by PBOOLE:143;
A10: card IF=card I+1 by Th15;
  then (card I+1) in dom pIF by COMPOS_1:64;
  then P4.(card I+1) = pIF.(card I+1) by A7,GRFUNC_1:2
    .=halt SCMPDS by A10,COMPOS_1:64;
  then
A11: CurInstr(P3,s4) = halt SCMPDS by A6,A8;
  then
A12: P3 halts_on s3 by EXTPRO_1:29;
A13: CurInstr(P3,s3) = i by Th22;
  now
    let l be Element of NAT;
A14: Comput(P3,s3,0) = s3 by EXTPRO_1:2;
    assume
    l < 1;
    then l <1+0;
    then l=0 by NAT_1:13;
    then CurInstr(P3,Comput(P3,s3,l))
     = CurInstr(P3,s3) by A14;
    hence CurInstr(P3,Comput(P3,s3,l))
     <> halt SCMPDS by A13;
  end;
  then for l be Element of NAT st CurInstr(P3,
  Comput(P3,s3,l)) = halt SCMPDS
  holds 1 <= l;
  then LifeSpan(P3,s3) = 1 by A11,A12,EXTPRO_1:def 15;
  then
A15: s4 = Result(P3,s3) by A12,EXTPRO_1:23;
A17: now
A18: dom SAl = {IC SCMPDS} by FUNCOP_1:13;
    let x be set;
    assume
A19: x in dom IExec(IF,P,Initialize s);
    per cases by A19,SCMPDS_4:6;
    suppose
A20:  x is Int_position;
      then x <> IC SCMPDS by SCMPDS_2:43;
      then
A21:  not x in dom SAl by A18,TARSKI:def 1;
TT:   not x in dom Start-At(0,SCMPDS) by A20,SCMPDS_4:18;
      thus IExec(IF,P,Initialize s).x = s4.x by A15
        .= s3.x by A5,A20,SCMPDS_2:55
        .= s.x by TT,FUNCT_4:11
        .= (s +* SAl).x by A21,FUNCT_4:11;
    end;
    suppose
A22:  x = IC SCMPDS;
      hence IExec(IF,P,Initialize s).x = (card I + 1) by A6,A15
        .= (s +* SAl).x by A22,FUNCT_4:113;
    end;
  end;
  dom IExec(IF,P,Initialize s) = the carrier of SCMPDS by PARTFUN1:def 2
    .= dom (s +* SAl) by PARTFUN1:def 2;
  hence thesis by A17,FUNCT_1:2;
end;

registration
  let I be shiftable parahalting Program of SCMPDS, a be Int_position,k1 be
  Integer;
  cluster if=0(a,k1,I) -> shiftable parahalting;
  correctness
  proof
    set i = (a,k1)<>0_goto (card I +1);
    set IF=if=0(a,k1,I);
    thus IF is shiftable;
      let s be 0-started State of SCMPDS;
      let P be Instruction-Sequence of SCMPDS;
A1:  Initialize s = s by MEMSTR_0:44;
      assume
      stop IF c= P;
      then
A2:   P = P +* stop IF by FUNCT_4:98;
A3:   I is_closed_on s,P & I is_halting_on s,P by Th34,Th35;
      per cases;
      suppose
        s.DataLoc(s.a,k1)= 0;
        then IF is_halting_on s,P by A3,Th62;
        hence P halts_on s by A1,A2,Def3;
      end;
      suppose
        s.DataLoc(s.a,k1) <> 0;
        then IF is_halting_on s,P by Th63;
        hence P halts_on s by A1,A2,Def3;
      end;
  end;
end;

registration
  let I be halt-free Program of SCMPDS, a be Int_position,k1 be Integer;
  cluster if=0(a,k1,I) -> halt-free;
  coherence;
end;

theorem
  for s being 0-started State of SCMPDS,
     I being halt-free shiftable parahalting Program of SCMPDS,
     a being Int_position,k1 being Integer
 holds IC IExec(if=0(a,k1,I),P,s) = card I + 1
proof
  let s be 0-started State of SCMPDS,
      I be halt-free shiftable parahalting Program of
  SCMPDS,a be Int_position,k1 be Integer;
  set IF=if=0(a,k1,I);
A1: I is_closed_on s,P & I is_halting_on s,P by Th34,Th35;
I: Initialize s = s by MEMSTR_0:44;
  per cases;
  suppose
    s.DataLoc(s.a,k1) = 0;
    then IExec(IF,P,s) =IExec(I,P,s) +* Start-At((card I+1),SCMPDS)
    by A1,Th64,I;
    hence thesis by FUNCT_4:113;
  end;
  suppose
    s.DataLoc(s.a,k1) <> 0;
    then IExec(IF,P,s) =s +* Start-At((card I+1),SCMPDS) by Th65,I;
    hence thesis by FUNCT_4:113;
  end;
end;

theorem
  for s being State of SCMPDS,
      I being halt-free shiftable parahalting
Program of SCMPDS,a,b being Int_position,k1 being Integer st s.DataLoc(s.a,k1)=
  0 holds IExec(if=0(a,k1,I),P,Initialize s).b = IExec(I,P,Initialize s).b
proof
  let s be State of SCMPDS,I be halt-free shiftable parahalting Program of
  SCMPDS,a,b be Int_position,k1 be Integer;
  assume
A1: s.DataLoc(s.a,k1)=0;
A2: not b in dom Start-At((card I+1),SCMPDS) by SCMPDS_4:18;
  I is_closed_on s,P & I is_halting_on s,P by Th34,Th35;
  then IExec(if=0(a,k1,I),P,Initialize s) = IExec(I,P,Initialize s)
   +* Start-At((card I+1),SCMPDS)
  by A1,Th64;
  hence thesis by A2,FUNCT_4:11;
end;

theorem
  for s being State of SCMPDS,I being Program of SCMPDS,a,b being
Int_position, k1 being Integer st s.DataLoc(s.a,k1)<> 0
 holds IExec(if=0(a,k1,I),P,Initialize s).b = s.b
proof
  let s be State of SCMPDS,I be Program of SCMPDS,a,b be Int_position, k1 be
  Integer;
  assume
  s.DataLoc(s.a,k1)<>0;
  then
A1: IExec(if=0(a,k1,I),P,Initialize s) = s +* Start-At((card I+1),SCMPDS)
         by Th65;
  not b in dom Start-At((card I+1),SCMPDS) by SCMPDS_4:18;
  hence thesis by A1,FUNCT_4:11;
end;

Lm8: card (i ';' j ';' I)=card I+2
proof
  thus card (i ';' j ';' I) =card (i ';' (j ';' I)) by SCMPDS_4:16
    .=card (j ';' I)+1 by Th15
    .=card I+1+1 by Th15
    .=card I+2;
end;

begin :: The computation of "if var<>0 then block"

theorem
  card if<>0(a,k1,I) = card I + 2 by Lm8;

Lm9:  0 in dom (i ';' j ';' I) &  1 in dom (i ';' j ';' I)
proof
  set ci=card (i ';' j ';' I);
  ci=card I + 2 by Lm8;
  then 2 <= ci by NAT_1:11;
  then 1 < ci by XXREAL_0:2;
  hence thesis by AFINSQ_1:66;
end;

theorem
   0 in dom if<>0(a,k1,I) &  1 in dom if<>0(a,k1,I) by Lm9;

Lm10: (i ';' j ';' I). 0=i & (i ';' j ';' I). 1=j
proof
  set jI=j ';' I;
A1: i ';' j ';' I =i ';' jI by SCMPDS_4:16
    .=Load i ';' jI;
   0 in dom Load i by COMPOS_1:50;
  hence (i ';' j ';' I). 0 =(Load i). 0 by A1,AFINSQ_1:def 3
    .=i by COMPOS_1:52;
A2:  0 in dom Load j by COMPOS_1:50;
  card jI=card I+1 by Th15;
  then
A3: card Load i=1 &  0 in dom jI by AFINSQ_1:66,COMPOS_1:54;
  thus (i ';' j ';' I). 1 =(Load i ';' jI). (0+1) by A1
    .=jI. 0 by A3,AFINSQ_1:def 3
    .=(Load j ';' I). 0
    .=(Load j). 0 by A2,AFINSQ_1:def 3
    .=j by COMPOS_1:52;
end;

theorem
  if<>0(a,k1,I). 0 = (a,k1)<>0_goto 2 & if<>0(a,k1,I). 1 =
  goto (card I + 1) by Lm10;

theorem Th72:
  for s being State of SCMPDS, I being shiftable Program of SCMPDS
  , a being Int_position,k1 being Integer st s.DataLoc(s.a,k1)<>0 & I
is_closed_on s,P & I is_halting_on s,P holds if<>0(a,k1,I) is_closed_on s,P
 & if<>0(a
  ,k1,I) is_halting_on s,P
proof
  let s be State of SCMPDS, I be shiftable Program of SCMPDS, a be
  Int_position,k1 be Integer;
  set b=DataLoc(s.a,k1);
  set IF=if<>0(a,k1,I), pIF=stop IF, pI=stop I,
  s2 = Initialize s, P2 = P +* pI,
  s3 = Initialize s, P3 = P +* pIF,
  s4 = Comput(P3,s3,1), P4 = P3;
  set i = (a,k1)<>0_goto 2, j = goto (card I + 1);
A3: IF = i ';' (j ';' I) by SCMPDS_4:16;
A4: Comput(P3, s3,0 + 1) = Following(P3,Comput(P3,s3,0)) by EXTPRO_1:3
    .= Following(P3,s3) by EXTPRO_1:2
    .= Exec(i,s3) by A3,Th22;
  for a holds s2.a = s4.a by A4,SCMPDS_2:55;
  then
A6: DataPart s2 = DataPart s4 by SCMPDS_4:8;
A7: not b in dom Start-At(0,SCMPDS) by SCMPDS_4:18;
  not a in dom Start-At(0,SCMPDS) by SCMPDS_4:18;
  then
A8: s3.DataLoc(s3.a,k1)=s3.b by FUNCT_4:11
    .= s.b by A7,FUNCT_4:11;
A9: IC s3 = 0 by MEMSTR_0:47;
  assume
  s.b <> 0;
  then
A10: IC s4 = ICplusConst(s3,2) by A4,A8,SCMPDS_2:55
    .= (0+2) by A9,Th23;
  assume
A11: I is_closed_on s,P;
  then
A12: I is_closed_on s2,P2 by Th38;
  assume
  I is_halting_on s,P;
  then
A13: P2 halts_on s2 by Def3;
A14: Start-At(0,SCMPDS) c= s2 & Shift(pI,2) c= P4 by Lm7,FUNCT_4:25;
UU:  stop I c= P2 by FUNCT_4:25;
A15:  0 in dom pIF by COMPOS_1:36;
  now
    let k be Element of NAT;
    per cases;
    suppose
      0 < k;
      then consider k1 being Nat such that
A16:  k1 + 1 = k by NAT_1:6;
      reconsider k1 as Element of NAT by ORDINAL1:def 12;
      reconsider m = IC Comput(P2, s2,k1) as Element of NAT;
A17:  card pIF = 1+ card IF by COMPOS_1:55
        .= 1+(card I +2) by Lm8
        .= 1+card I +2
        .=card pI+2 by COMPOS_1:55;
       m in dom pI by A11,Def2;
      then m < card pI by AFINSQ_1:66;
      then
A18:  m+2 < card pIF by A17,XREAL_1:6;
      IC Comput(P3,s3,k) = IC Comput(P3, s4,k1) by A16,EXTPRO_1:4
        .=  (m + 2) by A12,A14,A10,A6,Th45,UU;
      hence IC Comput(P3,s3,k) in dom pIF by A18,AFINSQ_1:66;
    end;
    suppose
      k = 0;
      hence IC Comput(P3,s3,k) in dom pIF by A15,A9,EXTPRO_1:2;
    end;
  end;
  hence IF is_closed_on s,P by Def2;
A21: Comput(P3,s3,LifeSpan(P2,s2)+1)
= Comput(P3,Comput(P3,s3,1),LifeSpan(P2,
s2))
by EXTPRO_1:4;
  CurInstr(P3,
  Comput(P3,s3,LifeSpan(P2,s2)+1))
   =CurInstr(P3,
   Comput(P3,s4,LifeSpan(P2,s2))) by A21
    .=CurInstr(P2,
    Comput(P2,s2,LifeSpan(P2,s2))) by A12,A14,A10,A6,Th45,UU
    .= halt SCMPDS by A13,EXTPRO_1:def 15;
  then P3 halts_on s3 by EXTPRO_1:29;
  hence thesis by Def3;
end;

theorem Th73:
  for s being State of SCMPDS,I being Program of SCMPDS, a being
  Int_position, k1 being Integer st s.DataLoc(s.a,k1)= 0 holds if<>0(a,k1,I)
  is_closed_on s,P & if<>0(a,k1,I) is_halting_on s,P
proof
  let s be State of SCMPDS,I be Program of SCMPDS, a be Int_position,k1 be
  Integer;
  set b=DataLoc(s.a,k1);
  assume
A1: s.b = 0;
  set IF=if<>0(a,k1,I), pIF=stop IF, s3 = Initialize s,
  P3 = P +* pIF,
  s4 = Comput(P3,s3,1), s5 = Comput(P3,s3,2), P4 = P3, P5 = P3;
A3: not b in dom Start-At(0,SCMPDS) by SCMPDS_4:18;
  not a in dom Start-At(0,SCMPDS) by SCMPDS_4:18;
  then
A4: s3.DataLoc(s3.a,k1)=s3.b by FUNCT_4:11
    .=0 by A1,A3,FUNCT_4:11;
A6: pIF c= P4 by FUNCT_4:25;
  set i = (a,k1)<>0_goto 2, j = goto (card I + 1);
A7: IF =i ';' (j ';' I) by SCMPDS_4:16;
A8: IC s3 = 0 by MEMSTR_0:47;
  Comput(P3, s3,0 + 1) = Following(P3,Comput(P3,s3,0)) by EXTPRO_1:3
    .= Following(P3,s3) by EXTPRO_1:2
    .= Exec(i,s3) by A7,Th22;
  then
A9: IC s4 = succ IC s3 by A4,SCMPDS_2:55
    .= (0+1) by A8;
A10:  1 in dom IF by Lm9;
  then  1 in dom pIF by COMPOS_1:62;
  then
A11: P4. 1 = pIF. 1 by A6,GRFUNC_1:2
    .=IF. 1 by A10,COMPOS_1:63
    .=j by Lm10;
A12: card IF=card I+2 by Lm8;
  then
A13: (card I+2) in dom pIF by COMPOS_1:64;
A14:  P3/.IC s4
 = P3.IC s4 by PBOOLE:143;
  Comput(P3, s3,1 + 1) = Following(P3,s4) by EXTPRO_1:3
    .= Exec(j,s4) by A9,A11,A14;
  then
A16: IC s5 = ICplusConst(s4,card I+1) by SCMPDS_2:54
    .= (card I+1+1) by A9,Th23
    .= (card I+(1+1));
A17:  (P3)/.IC s5
 = P3.IC s5 by PBOOLE:143;
  pIF c= P5 by FUNCT_4:25;
  then P5.(card I+2) = pIF.(card I+2) by A13,GRFUNC_1:2
    .=halt SCMPDS by A12,COMPOS_1:64;
  then
A19: CurInstr(P3,s5) = halt SCMPDS by A16,A17;
  now
    let k be Element of NAT;
A20: k = 0 or 0 + 1 <= k by INT_1:7;
    per cases by A20,XXREAL_0:1;
    suppose
      k = 0;
      then Comput(P3,s3,k) = s3 by EXTPRO_1:2;
      hence IC Comput(P3,s3,k) in dom pIF by A8,COMPOS_1:36;
    end;
    suppose
      k = 1;
      hence IC Comput(P3,s3,k) in dom pIF by A10,A9,COMPOS_1:62;
    end;
    suppose
      1 < k;
      then 1+1 <= k by INT_1:7;
      hence IC Comput(P3,s3,k) in dom pIF
      by A13,A16,A19,EXTPRO_1:5;
    end;
  end;
  hence IF is_closed_on s,P by Def2;
  P3 halts_on s3 by A19,EXTPRO_1:29;
  hence thesis by Def3;
end;

theorem Th74:
  for s being State of SCMPDS,I being halt-free shiftable
  Program of SCMPDS, a being Int_position,k1 being Integer st s.DataLoc(s.a,k1)
  <> 0 & I is_closed_on s,P & I is_halting_on s,P
   holds IExec(if<>0(a,k1,I),P,Initialize s) =
  IExec(I,P,Initialize s) +* Start-At((card I+2),SCMPDS)
proof
  let s be State of SCMPDS,I be halt-free shiftable Program of SCMPDS, a be
  Int_position,k1 be Integer;
  set b=DataLoc(s.a,k1);
  set IF=if<>0(a,k1,I), pI=stop I, pIF = stop IF,
   s2 = Initialize s, P2 = P +* pI,
   s3 = Initialize s,
   P3 = P +* pIF,
   s4 = Comput(P3, s3,1), P4 = P3;
  set i = (a,k1)<>0_goto 2, j = goto (card I + 1);
  set SAl=Start-At((card I+2),SCMPDS);
A3: IF=i ';' (j ';' I) by SCMPDS_4:16;
A4: Comput(P3, s3,0 + 1) = Following(P3,Comput(P3,s3,0)) by EXTPRO_1:3
    .= Following(P3,s3) by EXTPRO_1:2
    .= Exec(i,s3) by A3,Th22;
A5: not b in dom Start-At(0,SCMPDS) by SCMPDS_4:18;
  not a in dom Start-At(0,SCMPDS) by SCMPDS_4:18;
  then
A6: s3.DataLoc(s3.a,k1)=s3.b by FUNCT_4:11
    .= s.b by A5,FUNCT_4:11;
A7: IC s3 = 0 by MEMSTR_0:47;
A8: Start-At(0,SCMPDS) c= s2 & Shift(pI,2) c= P4 by Lm7,FUNCT_4:25;
UU:  stop I c= P2 by FUNCT_4:25;
  for a holds s2.a = s4.a by A4,SCMPDS_2:55;
  then
A10: DataPart s2 = DataPart s4 by SCMPDS_4:8;
  assume
  s.b <> 0;
  then
A11: IC s4 = ICplusConst(s3,2) by A4,A6,SCMPDS_2:55
    .= (0+2) by A7,Th23;
  assume
A13: I is_closed_on s,P;
  then
A14: I is_closed_on s2,P2 by Th38;
  assume
A15: I is_halting_on s,P;
  then
A16: P2 halts_on s2 by Def3;
A18: Comput(P3,s3,LifeSpan(P2,s2)+1)
 = Comput(P3,Comput(P3,s3,1),LifeSpan(P2
,s2))
by EXTPRO_1:4;
A21: CurInstr(P3,
Comput(P3,s3,LifeSpan(P2,s2)+1))
 =CurInstr(P3,
 Comput(P3,s4,LifeSpan(P2,s2))) by A18
    .=CurInstr(P2,
    Comput(P2,s2,LifeSpan(P2,s2))) by A14,A8,A11,A10,Th45,UU
    .= halt SCMPDS by A16,EXTPRO_1:def 15;
  then
A22: P3 halts_on s3 by EXTPRO_1:29;
A23: CurInstr(P3,s3) = i by A3,Th22;
  now
    let l be Element of NAT;
    assume
A24: l < LifeSpan(P2,s2) + 1;
A25: Comput(P3,s3,0) = s3 by EXTPRO_1:2;
    per cases;
    suppose
      l = 0;
      then CurInstr(P3,Comput(P3,s3,l))
       = CurInstr(P3,s3)
       by A25;
      hence CurInstr(P3,Comput(P3,s3,l))
       <> halt SCMPDS by A23;
    end;
    suppose
      l <> 0;
      then consider n be Nat such that
A26:  l = n + 1 by NAT_1:6;
      reconsider n as Element of NAT by ORDINAL1:def 12;
A27:  n < LifeSpan(P2,s2) by A24,A26,XREAL_1:6;
      assume
A28:  CurInstr(P3,Comput(P3,s3,l)) = halt SCMPDS;
A32: Comput(P3,s3,n+1)
= Comput(P3,Comput(P3,s3,1),n) by EXTPRO_1:4;
      CurInstr(P2,Comput(P2,s2,n)) =
      CurInstr(P3,Comput(P3,s4,n)) by A14,A8,A11,A10,Th45,UU
        .= halt SCMPDS by A26,A28,A32;
      hence contradiction by A16,A27,EXTPRO_1:def 15;
    end;
  end;
  then for l be Element of NAT st CurInstr(P3,
  Comput(P3,s3,l)) = halt SCMPDS
  holds LifeSpan(P2,s2) + 1 <= l;
  then
A33: LifeSpan(P3,s3) = LifeSpan(P2,s2) + 1 by A21,A22,EXTPRO_1:def 15;
A35: DataPart Result(P2,s2) = DataPart Comput(P2, s2
,LifeSpan(P2,s2)) by A16,EXTPRO_1:23
    .= DataPart Comput(P3, s4,LifeSpan(P2,s2)) by A14,A8,A11,A10,Th45,UU
    .= DataPart Comput(P3, s3,LifeSpan(P2,s2) + 1)
by EXTPRO_1:4
    .= DataPart Result(P3,s3) by A22,A33,EXTPRO_1:23;
A36: now
    let x be set;
A37: dom Start-At((card I+2),SCMPDS) = {IC SCMPDS} by FUNCOP_1:13;
    assume
A38: x in dom IExec(IF,P,Initialize s);
    per cases by A38,SCMPDS_4:6;
    suppose
A39:  x is Int_position;
      then x <> IC SCMPDS by SCMPDS_2:43;
      then
A40:  not x in dom SAl by A37,TARSKI:def 1;
      thus IExec(IF,P,Initialize s).x = (Result(P3,s3)).x
        .= (Result(P2,s2)).x by A35,A39,SCMPDS_4:8
        .= IExec(I,P,Initialize s).x
        .= (IExec(I,P,Initialize s) +* SAl).x by A40,FUNCT_4:11;
    end;
    suppose
A42:  x = IC SCMPDS;
A44:  IC Result(P2,s2) = IC IExec(I,P,Initialize s)
        .=  card I by A13,A15,Th48;
A45:  x in dom SAl by A37,A42,TARSKI:def 1;
      thus IExec(IF,P,Initialize s).x = (Result(P3,s3)).x
        .= Comput(P3, s3,LifeSpan(P2,s2) + 1).x by A22,A33,EXTPRO_1:23
        .= IC Comput(P3, s4,LifeSpan(P2,s2)) by A42,EXTPRO_1:4
        .= IC Comput(P2, s2,LifeSpan(P2,s2)) + 2
        by A14,A8,A11,A10,Th45,UU
        .= IC Result(P2,s2) + 2 by A16,EXTPRO_1:23
        .= IC SAl by A44,FUNCOP_1:72
        .= (IExec(I,P,Initialize s) +* SAl).x by A42,A45,FUNCT_4:13;
    end;
  end;
  dom IExec(IF,P,Initialize s) = the carrier of SCMPDS by PARTFUN1:def 2
    .= dom (IExec(I,P,Initialize s) +* Start-At((card I+2),SCMPDS))
     by PARTFUN1:def 2;
  hence thesis by A36,FUNCT_1:2;
end;

theorem Th75:
  for s being State of SCMPDS,I being Program of SCMPDS,a being
Int_position, k1 being Integer st s.DataLoc(s.a,k1)= 0
 holds IExec(if<>0(a,k1,I),P,Initialize s) = s +* Start-At((card I+2),SCMPDS)
proof
  let s be State of SCMPDS,I be Program of SCMPDS,a be Int_position, k1 be
  Integer;
  set b=DataLoc(s.a,k1);
  assume
A1: s.b = 0;
  set SAl=Start-At((card I+2),SCMPDS);
  set i = (a,k1)<>0_goto 2, j = goto (card I + 1);
  set IF=if<>0(a,k1,I), pIF=stop IF, s3 = Initialize s,
  P3 = P +* pIF,
  s4 = Comput(P3,s3,1), s5 = Comput(P3,s3,2), P4 = P3, P5 = P3;
A3: IF =i ';' (j ';' I) by SCMPDS_4:16;
A4: pIF c= P3 by FUNCT_4:25;
  then
A5: pIF c= P4;
A6: pIF c= P5 by A4;
A7: not b in dom Start-At(0,SCMPDS) by SCMPDS_4:18;
A8: IC s3 = 0 by MEMSTR_0:47;
A9: Comput(P3, s3,0 + 1) = Following(P3,Comput(P3,s3,0)) by EXTPRO_1:3
    .= Following(P3,s3) by EXTPRO_1:2
    .= Exec(i,s3) by A3,Th22;
  not a in dom Start-At(0,SCMPDS) by SCMPDS_4:18;
  then s3.DataLoc(s3.a,k1)=s3.b by FUNCT_4:11
    .=0 by A1,A7,FUNCT_4:11;
  then
A10: IC s4 = succ IC s3 by A9,SCMPDS_2:55
    .= (0+1) by A8;
A11:  1 in dom IF by Lm9;
  then  1 in dom pIF by COMPOS_1:62;
  then
A12: P4.1 = pIF. 1 by A5,GRFUNC_1:2
    .=IF. 1 by A11,COMPOS_1:63
    .=j by Lm10;
A13:  P3/.IC s4
 = P3.IC s4 by PBOOLE:143;
A15: Comput(P3, s3,1 + 1) = Following(P3,s4) by EXTPRO_1:3
    .= Exec(j,s4) by A10,A12,A13;
  then
A16: IC s5 = ICplusConst(s4,card I+1) by SCMPDS_2:54
    .= (card I+1+1) by A10,Th23
    .= (card I+(1+1));
A17:  (P3)/.IC s5
 = P3.IC s5 by PBOOLE:143;
A19: card IF=card I+2 by Lm8;
  then (card I+2) in dom pIF by COMPOS_1:64;
  then P5.(card I+2) = pIF.(card I+2) by A6,GRFUNC_1:2
    .=halt SCMPDS by A19,COMPOS_1:64;
  then
A20: CurInstr(P3,s5) = halt SCMPDS by A16,A17;
  then
A21: P3 halts_on s3 by EXTPRO_1:29;
A22: CurInstr(P3,s3) = i by A3,Th22;
  now
    let l be Element of NAT;
    assume
    l < 1+1;
    then
A23: l <= 1 by NAT_1:13;
A24: Comput(P3,s3,0) = s3 by EXTPRO_1:2;
A25: P3/.IC Comput(P3,s3,l)
 = P3.IC Comput(P3,s3,l) by PBOOLE:143;
    per cases by A23,NAT_1:25;
    suppose
      l=0;
      then CurInstr(P3,Comput(P3,s3,l))
       = CurInstr(P3,s3)
       by A24;
      hence CurInstr(P3,Comput(P3,s3,l))
       <> halt SCMPDS by A22;
    end;
    suppose
      l=1;
      hence CurInstr(P3,Comput(P3,s3,l))
       <> halt SCMPDS by A10,A12,A25;
    end;
  end;
  then for l be Element of NAT st CurInstr(P3,
  Comput(P3,s3,l)) = halt SCMPDS
  holds 2 <= l;
  then LifeSpan(P3,s3) = 2 by A20,A21,EXTPRO_1:def 15;
  then
A27: s5 = Result(P3,s3) by A21,EXTPRO_1:23;
A29: now
A30: dom SAl = {IC SCMPDS} by FUNCOP_1:13;
    let x be set;
    assume
A31: x in dom IExec(IF,P,Initialize s);
    per cases by A31,SCMPDS_4:6;
    suppose
A32:  x is Int_position;
      then x <> IC SCMPDS by SCMPDS_2:43;
      then
A33:  not x in dom SAl by A30,TARSKI:def 1;
TT:   not x in dom Start-At(0,SCMPDS) by A32,SCMPDS_4:18;
      thus IExec(IF,P,Initialize s).x = s5.x by A27
        .= s4.x by A15,A32,SCMPDS_2:54
        .= s3.x by A9,A32,SCMPDS_2:55
        .= s.x by TT,FUNCT_4:11
        .= (s +* SAl).x by A33,FUNCT_4:11;
    end;
    suppose
A34:  x = IC SCMPDS;
      hence IExec(IF,P,Initialize s).x = (card I + 2) by A16,A27
        .= (s +* Start-At((card I+2),SCMPDS)).x by A34,FUNCT_4:113;
    end;
  end;
  dom IExec(IF,P,Initialize s) = the carrier of SCMPDS by PARTFUN1:def 2
    .= dom (s +* SAl) by PARTFUN1:def 2;
  hence thesis by A29,FUNCT_1:2;
end;

registration
  let I be shiftable parahalting Program of SCMPDS, a be Int_position,k1 be
  Integer;
  cluster if<>0(a,k1,I) -> shiftable parahalting;
  correctness
  proof
    set i = (a,k1)<>0_goto 2, j = goto (card I + 1);
    set IF=if<>0(a,k1,I), pIF = stop IF;
    thus IF is shiftable;
      let s be 0-started State of SCMPDS;
      let P be Instruction-Sequence of SCMPDS;
A1:  Initialize s = s by MEMSTR_0:44;
      assume pIF c= P;
      then
A2:   P = P +* stop IF by FUNCT_4:98;
A3:   I is_closed_on s,P & I is_halting_on s,P by Th34,Th35;
      per cases;
      suppose
        s.DataLoc(s.a,k1)<>0;
        then IF is_halting_on s,P by A3,Th72;
        hence P halts_on s by A1,A2,Def3;
      end;
      suppose
        s.DataLoc(s.a,k1) = 0;
        then IF is_halting_on s,P by Th73;
        hence P halts_on s by A1,A2,Def3;
      end;
  end;
end;

registration
  let I be halt-free Program of SCMPDS, a be Int_position,k1 be Integer;
  cluster if<>0(a,k1,I) -> halt-free;
  coherence;
end;

theorem
  for s being State of SCMPDS,I being halt-free shiftable parahalting
Program of SCMPDS,a being Int_position,k1 being Integer
 holds IC IExec(if<>0(a,k1,I),P,Initialize s) = card I + 2
proof
  let s be State of SCMPDS,I be halt-free shiftable parahalting Program of
  SCMPDS,a be Int_position,k1 be Integer;
  set IF=if<>0(a,k1,I);
A1: I is_closed_on s,P & I is_halting_on s,P by Th34,Th35;
  per cases;
  suppose
    s.DataLoc(s.a,k1) <> 0;
    then IExec(IF,P,Initialize s) =IExec(I,P,Initialize s)
     +* Start-At((card I+2),SCMPDS)
    by A1,Th74;
    hence thesis by FUNCT_4:113;
  end;
  suppose
    s.DataLoc(s.a,k1) = 0;
    then IExec(IF,P,Initialize s) =s +* Start-At((card I+2),SCMPDS) by Th75;
    hence thesis by FUNCT_4:113;
  end;
end;

theorem
  for s being State of SCMPDS,I being halt-free shiftable parahalting
Program of SCMPDS,a,b being Int_position,k1 being Integer st s.DataLoc(s.a,k1)
  <> 0 holds IExec(if<>0(a,k1,I),P,Initialize s).b
   = IExec(I,P,Initialize s).b
proof
  let s be State of SCMPDS,I be halt-free shiftable parahalting Program of
  SCMPDS,a,b be Int_position,k1 be Integer;
  assume
A1: s.DataLoc(s.a,k1)<>0;
A2: not b in dom Start-At((card I+2),SCMPDS) by SCMPDS_4:18;
  I is_closed_on s,P & I is_halting_on s,P by Th34,Th35;
  then IExec(if<>0(a,k1,I),P,Initialize s) = IExec(I,P,Initialize s)
   +* Start-At((card I+2),SCMPDS)
   by A1,Th74;
  hence thesis by A2,FUNCT_4:11;
end;

theorem
  for s being State of SCMPDS,I being Program of SCMPDS,a,b being
Int_position, k1 being Integer st s.DataLoc(s.a,k1)= 0
 holds IExec(if<>0(a,k1,I),P,Initialize s).b = s.b
proof
  let s be State of SCMPDS,I be Program of SCMPDS,a,b be Int_position, k1 be
  Integer;
  assume
  s.DataLoc(s.a,k1)=0;
  then
A1: IExec(if<>0(a,k1,I),P,Initialize s)
 = s +* Start-At((card I+2),SCMPDS) by Th75;
  not b in dom Start-At((card I+2),SCMPDS) by SCMPDS_4:18;
  hence thesis by A1,FUNCT_4:11;
end;

begin :: The computation of "if var>0 then block1 else block2"

theorem
  card if>0(a,k1,I,J) = card I + card J + 2 by Lm4;

theorem
   0 in dom if>0(a,k1,I,J) &  1 in dom if>0(a,k1,I,J)
proof
  set ci=card if>0(a,k1,I,J);
  ci=card I + card J +2 by Lm4;
  then 2 <= ci by NAT_1:12;
  then 1 < ci by XXREAL_0:2;
  hence thesis by AFINSQ_1:66;
end;

theorem
  if>0(a,k1,I,J). 0 = (a,k1)<=0_goto (card I + 2) by Lm5;

theorem Th82:
  for s being 0-started State of SCMPDS, I,J being shiftable Program of
  SCMPDS, a being Int_position,k1 being Integer st s.DataLoc(s.a,k1)>0 & I
is_closed_on s,P & I is_halting_on s,P holds if>0(a,k1,I,J) is_closed_on s,P
 & if>0(a,k1,I,J) is_halting_on s,P
proof
  let s be 0-started State of SCMPDS, I,J be shiftable Program of SCMPDS, a be
  Int_position,k1 be Integer;
  set b=DataLoc(s.a,k1);
  set G=Goto (card J+1);
  set I2 = I ';' G ';' J, IF=if>0(a,k1,I,J), pIF=stop IF,
   pI2=stop I2, s2 = Initialize s, P2 = P +* pI2,
   P3 = P +* pIF,
   s4 = Comput(P3,s,1), P4 = P3;
  set i = (a,k1)<=0_goto (card I + 2);
A3:  0 in dom pIF by COMPOS_1:36;
I: Initialize s = s by MEMSTR_0:44;
   then
A4: IC s = 0 by MEMSTR_0:47;
A7: IF = i ';' (I ';' G) ';' J by SCMPDS_4:14
    .= i ';' I2 by SCMPDS_4:14;
  then
A8: Shift(pI2,1) c= P4 by Lm6;
A9: Comput(P3, s,0 + 1) = Following(P3,Comput(P3,s,0)) by EXTPRO_1:3
    .= Following(P3,s) by EXTPRO_1:2
    .= Exec(i,s) by A7,Th22,I;
  for a holds s2.a = s4.a by A9,SCMPDS_2:56,I;
  then
A11: DataPart s2 = DataPart s4 by SCMPDS_4:8;
  assume
  s.b > 0;
  then
A12: IC s4 = succ IC s by A9,SCMPDS_2:56
    .= (0+1) by A4;
  assume
A13: I is_closed_on s,P;
  assume
A14: I is_halting_on s,P;
  then
A15: I2 is_closed_on s,P by A13,Th44;
  then
A16: Start-At(0,SCMPDS) c= s2 & I2 is_closed_on s2,P2 by Th38,FUNCT_4:25;
UU:  stop I2 c= P2 by FUNCT_4:25;
  I2 is_halting_on s,P by A13,A14,Th44;
  then
A17: P2 halts_on s2 by Def3;
A18: card pIF = card IF +1 by COMPOS_1:55
    .= card I2 +1+1 by A7,Th15;
  now
    let k be Element of NAT;
    per cases;
    suppose
      0 < k;
      then consider k1 being Nat such that
A19:  k1 + 1 = k by NAT_1:6;
      reconsider k1 as Element of NAT by ORDINAL1:def 12;
      reconsider m = IC Comput(P2, s2,k1) as Element of NAT;
A20:  card pIF = card pI2+1 by A18,COMPOS_1:55;
       m in dom pI2 by A15,Def2;
      then m < card pI2 by AFINSQ_1:66;
      then
A21:  m+1 < card pIF by A20,XREAL_1:6;
      IC Comput(P3,s,k) = IC Comput(P3, s4,k1) by A19,EXTPRO_1:4
        .=  (m + 1) by A16,A8,A12,A11,Th45,UU;
      hence IC Comput(P3,s,k) in dom pIF by A21,AFINSQ_1:66;
    end;
    suppose
      k = 0;
      hence IC Comput(P3,s,k) in dom pIF by A3,A4,EXTPRO_1:2;
    end;
  end;
  hence IF is_closed_on s,P by Def2,I;
A24: Comput(P3,s,LifeSpan(P2,s2)+1)
    = Comput(P3,Comput(P3,s,1),LifeSpan(P2,s2)) by EXTPRO_1:4;
  CurInstr(P3,Comput(P3,s,LifeSpan(P2,s2)+1))
   =CurInstr(P3,Comput(P3,s4,LifeSpan(P2,s2))) by A24
    .=CurInstr(P2,
    Comput(P2,s2,LifeSpan(P2,s2))) by A16,A8,A12,A11,Th45,UU
    .= halt SCMPDS by A17,EXTPRO_1:def 15;
  then P3 halts_on s by EXTPRO_1:29;
  hence thesis by Def3,I;
end;

theorem Th83:
  for s being State of SCMPDS,I being Program of SCMPDS,J being
shiftable Program of SCMPDS,a being Int_position,k1 being Integer st s.DataLoc(
  s.a,k1) <= 0 & J is_closed_on s,P & J is_halting_on s,P holds if>0(a,k1,I,J)
  is_closed_on s,P & if>0(a,k1,I,J) is_halting_on s,P
proof
  let s be State of SCMPDS,I be Program of SCMPDS, J be shiftable Program of
  SCMPDS, a be Int_position,k1 be Integer;
  set b=DataLoc(s.a,k1);
  set pJ=stop J, s1 = Initialize s, P1 = P +* pJ,
  IF=if>0(a,k1,I,J), pIF=
  stop IF, s3 = Initialize s, P3 = P +* pIF,
  s4 = Comput(P3,s3,1), P4 = P3;
  set i = (a,k1)<=0_goto (card I + 2);
  set G =Goto (card J+1), iG=i ';' I ';' G;
A3: IF = i ';' (I ';' G) ';' J by SCMPDS_4:14
    .= i ';' (I ';' G ';' J) by SCMPDS_4:14;
A4: Comput(P3, s3,0 + 1) = Following(P3,Comput(P3,s3,0)) by EXTPRO_1:3
    .= Following(P3,s3) by EXTPRO_1:2
    .= Exec(i,s3) by A3,Th22;
A5: not b in dom Start-At(0,SCMPDS) by SCMPDS_4:18;
  not a in dom Start-At(0,SCMPDS) by SCMPDS_4:18;
  then
A6: s3.DataLoc(s3.a,k1)=s3.b by FUNCT_4:11
    .= s.b by A5,FUNCT_4:11;
A7: IC s3 = 0 by MEMSTR_0:47;
  assume
  s.b <= 0;
  then
A8: IC s4 = ICplusConst(s3,card I + 2) by A4,A6,SCMPDS_2:56
    .= (0+(card I + 2)) by A7,Th23;
  assume
A9: J is_closed_on s,P;
  then
A10: Start-At(0,SCMPDS) c= s1 & J is_closed_on s1,P1 by Th38,FUNCT_4:25;
UU:  stop J c= P1 by FUNCT_4:25;
A11: pIF c= P3 by FUNCT_4:25;
A12: card iG = card (i ';' I) + card G by AFINSQ_1:17
    .=card (i ';' I) + 1 by COMPOS_1:54
    .=card I +1 +1 by Th15
    .=card I +(1 +1);
  then Shift(pJ,card I+2) c= pIF by Th24;
  then
A13: Shift(pJ,card I+2) c= P4 by A11,XBOOLE_1:1;
  assume
  J is_halting_on s,P;
  then
A14: P1 halts_on s1 by Def3;
  for a holds s1.a = s4.a by A4,SCMPDS_2:56;
  then
A16: DataPart s1 = DataPart s4 by SCMPDS_4:8;
  now
    let k be Element of NAT;
    per cases;
    suppose
      0 < k;
      then consider k1 being Nat such that
A17:  k1 + 1 = k by NAT_1:6;
      reconsider k1 as Element of NAT by ORDINAL1:def 12;
      reconsider m = IC Comput(P1, s1,k1) as Element of NAT;
       m in dom pJ by A9,Def2;
      then m < card pJ by AFINSQ_1:66;
      then
A18:  m + (card I + 2) < card pJ + (card I + 2) by XREAL_1:6;
A19:  card pJ = card J + 1 by COMPOS_1:55;
A20:  card pIF = card IF+1 by COMPOS_1:55
        .=card I +2 +card J +1 by A12,AFINSQ_1:17
        .=card I +2 + card pJ by A19;
      IC Comput(P3,s3,k) = IC Comput(P3, s4,k1) by A17,EXTPRO_1:4
        .=  (m + (card I + 2)) by A10,A16,A13,A8,Th45,UU;
      hence IC Comput(P3,s3,k) in dom pIF by A20,A18,AFINSQ_1:66;
    end;
    suppose
      k = 0;
      then Comput(P3,s3,k) = s3 by EXTPRO_1:2;
      hence IC Comput(P3,s3,k) in dom pIF by A7,COMPOS_1:36;
    end;
  end;
  hence IF is_closed_on s,P by Def2;
A23: Comput(P3,s3,LifeSpan(P1,s1)+1)
 = Comput(P3,Comput(P3,s3,1),LifeSpan(P1
,s1))
 by EXTPRO_1:4;
  CurInstr(P3,
  Comput(P3,s3,LifeSpan(P1,s1)+1))
   =CurInstr(P3,
   Comput(P3,s4,LifeSpan(P1,s1))) by A23
    .=CurInstr(P1,
    Comput(P1,s1,LifeSpan(P1,s1))) by A10,A16,A13,A8,Th45,UU
    .= halt SCMPDS by A14,EXTPRO_1:def 15;
  then P3 halts_on s3 by EXTPRO_1:29;
  hence thesis by Def3;
end;

theorem Th84:
  for s being 0-started State of SCMPDS,I being halt-free shiftable
Program of SCMPDS, J being shiftable Program of SCMPDS,a being Int_position,k1
  being Integer st s.DataLoc(s.a,k1) > 0 & I is_closed_on s,P &
  I is_halting_on s,P
holds IExec(if>0(a,k1,I,J),P,s) = IExec(I,P,s)
 +* Start-At((card I + card J + 2),SCMPDS)
proof
  let s be 0-started State of SCMPDS,
      I be halt-free shiftable Program of SCMPDS, J be
  shiftable Program of SCMPDS,a be Int_position,k1 be Integer;
  set b=DataLoc(s.a,k1);
  set G=Goto (card J+1);
  set I2 = I ';' G ';' J, IF=if>0(a,k1,I,J), pIF = stop IF,
      pI2= stop I2, P2 = P +* pI2,
      P3 = P +* pIF, s4 = Comput(P3,s,1), P4 = P3;
  set i = (a,k1)<=0_goto (card I + 2);
  set SAl= Start-At((card I+card J+2),SCMPDS);
I: Initialize s = s by MEMSTR_0:44;
  then
A3: IC s = 0 by MEMSTR_0:47;
A7: IF = i ';' (I ';' G) ';' J by SCMPDS_4:14
    .= i ';' I2 by SCMPDS_4:14;
  then
A8: Shift(pI2,1) c= P4 by Lm6;
A9: Comput(P3, s,0 + 1) = Following(P3,Comput(P3,s,0)) by EXTPRO_1:3
    .= Following(P3,s) by EXTPRO_1:2
    .= Exec(i,s) by A7,Th22,I;
  assume
  s.b > 0;
  then
A10: IC s4 = succ IC s by A9,SCMPDS_2:56
    .= (0+1) by A3;
  for a holds s.a = s4.a by A9,SCMPDS_2:56;
  then
A12: DataPart s = DataPart s4 by SCMPDS_4:8;
  assume
A13: I is_closed_on s,P;
  assume
A14: I is_halting_on s,P;
  then I2 is_halting_on s,P by A13,Th44;
  then
A15: P2 halts_on s by Def3,I;
  I2 is_closed_on s,P by A13,A14,Th44;
  then
A16: Start-At(0,SCMPDS) c= s & I2 is_closed_on s,P2 by Th38,FUNCT_4:25,I;
UU:  stop I2 c= P2 by FUNCT_4:25;
A18: Comput(P3,s,LifeSpan(P2,s)+1)
= Comput(P3,Comput(P3,s,1),LifeSpan(P2,
s))
 by EXTPRO_1:4;
A21: CurInstr(P3,
Comput(P3,s,LifeSpan(P2,s)+1))
 =CurInstr(P3,
 Comput(P3,s4,LifeSpan(P2,s))) by A18
    .=CurInstr(P2,
    Comput(P2,s,LifeSpan(P2,s))) by A16,A8,A10,A12,Th45,UU
    .= halt SCMPDS by A15,EXTPRO_1:def 15;
  then
A22: P3 halts_on s by EXTPRO_1:29;
A23: CurInstr(P3,s) = i by A7,Th22,I;
  now
    let l be Element of NAT;
    assume
A24: l < LifeSpan(P2,s) + 1;
A25: Comput(P3,s,0) = s by EXTPRO_1:2;
    per cases;
    suppose
      l = 0;
      then CurInstr(P3,Comput(P3,s,l))
       = CurInstr(P3,s)
       by A25;
      hence CurInstr(P3,Comput(P3,s,l))
       <> halt SCMPDS by A23;
    end;
    suppose
      l <> 0;
      then consider n be Nat such that
A26:  l = n + 1 by NAT_1:6;
      reconsider n as Element of NAT by ORDINAL1:def 12;
A27:  n < LifeSpan(P2,s) by A24,A26,XREAL_1:6;
      assume
A28:  CurInstr(P3,Comput(P3,s,l)) = halt SCMPDS;
A32: Comput(P3,s,n+1)
 = Comput(P3,Comput(P3,s,1),n) by EXTPRO_1:4;
      CurInstr(P2,Comput(P2,s,n)) =
      CurInstr(P3,Comput(P3,s4,n)) by A16,A8,A10,A12,Th45,UU
        .= halt SCMPDS by A26,A28,A32;
      hence contradiction by A15,A27,EXTPRO_1:def 15;
    end;
  end;
  then for l be Element of NAT st CurInstr(P3,
  Comput(P3,s,l)) = halt SCMPDS
  holds LifeSpan(P2,s) + 1 <= l;
  then
A33: LifeSpan(P3,s) = LifeSpan(P2,s) + 1 by A21,A22,EXTPRO_1:def 15;
A35: DataPart Result(P2,s) = DataPart Comput(P2, s
,LifeSpan(P2,s)) by A15,EXTPRO_1:23
    .= DataPart Comput(P3, s4,LifeSpan(P2,s))
    by A16,A8,A10,A12,Th45,UU
    .= DataPart Comput(P3, s,LifeSpan(P2,s) + 1)
by EXTPRO_1:4
    .= DataPart Result(P3,s) by A22,A33,EXTPRO_1:23;
A36: now
    let x be set;
A37: dom SAl = {IC SCMPDS} by FUNCOP_1:13;
    assume
A38: x in dom IExec(IF,P,s);
    per cases by A38,SCMPDS_4:6;
    suppose
A39:  x is Int_position;
      then x <> IC SCMPDS by SCMPDS_2:43;
      then
A40:  not x in dom SAl by A37,TARSKI:def 1;
      thus IExec(IF,P,s).x = (Result(P3,s)).x
        .= (Result(P2,s)).x by A35,A39,SCMPDS_4:8
        .= IExec(I2,P,s).x
        .= (IExec(I2,P,s) +* SAl).x by A40,FUNCT_4:11;
    end;
    suppose
A42:  x = IC SCMPDS;
A44:  IC Result(P2,s) = IC IExec(I2,P,s)
        .=  (card I + card J + 1) by A13,A14,Th46;
A45:  x in dom SAl by A37,A42,TARSKI:def 1;
      thus IExec(IF,P,s).x = (Result(P3,s)).x
        .= Comput(P3, s,LifeSpan(P2,s) + 1).x by A22,A33,EXTPRO_1:23
        .= IC Comput(P3, s4,LifeSpan(P2,s)) by A42,EXTPRO_1:4
        .= IC Comput(P2, s,LifeSpan(P2,s)) + 1 by A16,A8,A10,A12,Th45,UU
        .= IC Result(P2,s) + 1 by A15,EXTPRO_1:23
        .= IC Start-At(((card I + card J + 1) + 1),SCMPDS) by A44,FUNCOP_1:72
        .= (IExec(I2,P,s) +* SAl).x by A42,A45,FUNCT_4:13;
    end;
  end;
  dom IExec(IF,P,s) = the carrier of SCMPDS by PARTFUN1:def 2
    .= dom (IExec(I2,P,s) +* SAl) by PARTFUN1:def 2;
  hence IExec(IF,P,s) = IExec(I2,P,s) +* SAl
     by A36,FUNCT_1:2
    .= IExec(I,P,s) +* Start-At((card I + card J + 1),SCMPDS) +*
     Start-At(
   (card I + card J + 2),SCMPDS) by A13,A14,Th47
    .= IExec(I,P,s) +* SAl by MEMSTR_0:36;
end;

theorem Th85:
  for s being 0-started State of SCMPDS,I being Program of SCMPDS,J being
  halt-free shiftable Program of SCMPDS,a being Int_position,k1 being Integer
  st s.DataLoc(s.a,k1) <= 0 & J is_closed_on s,P & J is_halting_on s,P
   holds IExec(if>0(a,k1,I,J),P,s)
    = IExec(J,P,s) +* Start-At((card I+card J+2),SCMPDS)
proof
  let s be 0-started State of SCMPDS,I be Program of SCMPDS,
      J be halt-free shiftable
  Program of SCMPDS,a be Int_position,k1 be Integer;
I: Initialize s = s by MEMSTR_0:44;
  set b=DataLoc(s.a,k1);
  set pJ=stop J, s1 = s, P1 = P +* pJ,
  IF=if>0(a,k1,I,J), pIF=
  stop IF, s3 = s, P3 = P +* pIF,
  s4 = Comput(P3,s3,1), P4 = P3;
  set i = (a,k1)<=0_goto (card I + 2);
  set G =Goto (card J+1), iG=i ';' I ';' G;
  set SAl=Start-At((card I+card J+2),SCMPDS);
A3: IF = i ';' (I ';' G) ';' J by SCMPDS_4:14
    .= i ';' (I ';' G ';' J) by SCMPDS_4:14;
A4: Comput(P3, s3,0 + 1) = Following(P3,Comput(P3,s3,0)) by EXTPRO_1:3
    .= Following(P3,s3) by EXTPRO_1:2
    .= Exec(i,s3) by A3,Th22,I;
A7: IC s3 = 0 by MEMSTR_0:47,I;
  assume
  s.b <= 0;
  then
A9: IC s4 = ICplusConst(s3,card I + 2) by A4,SCMPDS_2:56
    .= (0+(card I + 2)) by A7,Th23;
  for a holds s1.a= s4.a by A4,SCMPDS_2:56;
  then
A11: DataPart s1 = DataPart s4 by SCMPDS_4:8;
  card iG = card (i ';' I) + card G by AFINSQ_1:17
    .=card (i ';' I) + 1 by COMPOS_1:54
    .=card I +1 +1 by Th15
    .=card I +(1 +1);
  then
A12: Shift(pJ,card I+2) c= pIF by Th24;
  pIF c= P3 by FUNCT_4:25;
  then
A13: Shift(pJ,card I+2) c= P4 by A12,XBOOLE_1:1;
  assume
A14: J is_closed_on s,P;
  then
A15: Start-At(0,SCMPDS) c= s1 & J is_closed_on s1,P1 by Th38,FUNCT_4:25,I;
UU:  stop J c= P1 by FUNCT_4:25;
  assume
A16: J is_halting_on s,P;
  then
A17: P1 halts_on s1 by Def3,I;
A19: Comput(P3,s3,LifeSpan(P1,s1)+1)
 = Comput(P3,Comput(P3,s3,1),LifeSpan(P1
,s1))
 by EXTPRO_1:4;
A22: CurInstr(P3,
Comput(P3,s3,LifeSpan(P1,s1)+1))
 =CurInstr(P3,
 Comput(P3,s4,LifeSpan(P1,s1))) by A19
    .=CurInstr(P1,
    Comput(P1,s1,LifeSpan(P1,s1))) by A15,A13,A9,A11,Th45,UU
    .= halt SCMPDS by A17,EXTPRO_1:def 15;
  then
A23: P3 halts_on s3 by EXTPRO_1:29;
A24: CurInstr(P3,s3) = i by A3,Th22,I;
  now
    let l be Element of NAT;
    assume
A25: l < LifeSpan(P1,s1) + 1;
A26: Comput(P3,s3,0) = s3 by EXTPRO_1:2;
    per cases;
    suppose
      l = 0;
      then CurInstr(P3,Comput(P3,s3,l))
       = CurInstr(P3,s3)
       by A26;
      hence CurInstr(P3,Comput(P3,s3,l))
       <> halt SCMPDS by A24;
    end;
    suppose
      l <> 0;
      then consider n be Nat such that
A27:  l = n + 1 by NAT_1:6;
      reconsider n as Element of NAT by ORDINAL1:def 12;
A28:  n < LifeSpan(P1,s1) by A25,A27,XREAL_1:6;
      assume
A29:  CurInstr(P3,Comput(P3,s3,l)) = halt SCMPDS;
A31: Comput(P3,s3,n+1)
 = Comput(P3,Comput(P3,s3,1),n) by EXTPRO_1:4;
      CurInstr(P1,Comput(P1,s1,n))
       = CurInstr(P3,
      Comput(P3,s4,n)) by A15,A13,A9,A11,Th45,UU
        .= halt SCMPDS by A27,A29,A31;
      hence contradiction by A17,A28,EXTPRO_1:def 15;
    end;
  end;
  then for l be Element of NAT st CurInstr(P3,
  Comput(P3,s3,l)) = halt SCMPDS
  holds LifeSpan(P1,s1) + 1 <= l;
  then
A34: LifeSpan(P3,s3) = LifeSpan(P1,s1) + 1 by A22,A23,EXTPRO_1:def 15;
A35: DataPart Result(P1,s1) = DataPart Comput(P1, s1
,LifeSpan(P1,s1)) by A17,EXTPRO_1:23
    .= DataPart Comput(P3, s4,LifeSpan(P1,s1))
    by A15,A13,A9,A11,Th45,UU
    .= DataPart Comput(P3, s3,LifeSpan(P1,s1) + 1)
by EXTPRO_1:4
    .= DataPart Result(P3,s3) by A23,A34,EXTPRO_1:23;
A36: now
    let x be set;
A37: dom SAl = {IC SCMPDS} by FUNCOP_1:13;
    assume
A38: x in dom IExec(IF,P,s);
    per cases by A38,SCMPDS_4:6;
    suppose
A39:  x is Int_position;
      then x <> IC SCMPDS by SCMPDS_2:43;
      then
A40:  not x in dom SAl by A37,TARSKI:def 1;
      thus IExec(IF,P,s).x = (Result(P3,s3)).x
        .= (Result(P1,s1)).x by A35,A39,SCMPDS_4:8
        .= IExec(J,P,s).x
        .= (IExec(J,P,s) +* SAl).x by A40,FUNCT_4:11;
    end;
    suppose
A42:  x = IC SCMPDS;
A44:  IC Result(P1,s1) = IC IExec(J,P,s)
        .=  (card J) by A14,A16,Th48,I;
A45:  x in dom SAl by A37,A42,TARSKI:def 1;
      thus IExec(IF,P,s).x = (Result(P3,s3)).x
        .= Comput(P3, s3,LifeSpan(P1,s1) + 1).x by A23,A34,EXTPRO_1:23
        .= IC Comput(P3, s4,LifeSpan(P1,s1)) by A42,EXTPRO_1:4
        .= IC Comput(P1, s1,LifeSpan(P1,s1)) + (card
I + 2) by A15,A13,A9,A11,Th45,UU
        .= IC Result(P1,s1) + (card I + 2) by A17,EXTPRO_1:23
        .= IC Start-At (card J + (card I + 2),SCMPDS) by A44,FUNCOP_1:72
        .= (IExec(J,P,s) +* SAl).x by A42,A45,FUNCT_4:13;
    end;
  end;
  dom IExec(IF,P,s) = the carrier of SCMPDS by PARTFUN1:def 2
    .= dom (IExec(J,P,s) +* SAl) by PARTFUN1:def 2;
  hence thesis by A36,FUNCT_1:2;
end;

registration
  let I,J be shiftable parahalting Program of SCMPDS, a be Int_position,k1 be
  Integer;
  cluster if>0(a,k1,I,J) -> shiftable parahalting;
  correctness
  proof
    set i = (a,k1)<=0_goto (card I + 2), G =Goto (card J+1);
    set IF=if>0(a,k1,I,J), pIF = stop IF;
    reconsider IJ=I ';' G ';' J as shiftable Program of SCMPDS;
    thus IF is shiftable;
      let s be 0-started State of SCMPDS;
      let P be Instruction-Sequence of SCMPDS;
A1:  Initialize s = s by MEMSTR_0:44;
      assume pIF c= P;
      then
A2:   P = P +* stop IF by FUNCT_4:98;
A3:   J is_closed_on s,P & J is_halting_on s,P by Th34,Th35;
A4:   I is_closed_on s,P & I is_halting_on s,P by Th34,Th35;
      per cases;
      suppose
        s.DataLoc(s.a,k1) > 0;
        then IF is_halting_on s,P by A4,Th82;
        hence P halts_on s by A1,A2,Def3;
      end;
      suppose
        s.DataLoc(s.a,k1) <= 0;
        then IF is_halting_on s,P by A3,Th83;
        hence P halts_on s by A1,A2,Def3;
      end;
  end;
end;

registration
  let I,J be halt-free Program of SCMPDS, a be Int_position,k1 be Integer;
  cluster if>0(a,k1,I,J) -> halt-free;
  coherence;
end;

theorem
  for s being 0-started State of SCMPDS,I,J being halt-free shiftable
  parahalting Program of SCMPDS,a being Int_position,k1 being Integer holds IC
  IExec(if>0(a,k1,I,J),P,s) = card I + card J + 2
proof
  let s be 0-started State of SCMPDS,
      I,J be halt-free shiftable parahalting Program of SCMPDS,
      a be Int_position,k1 be Integer;
  set IF=if>0(a,k1,I,J);
A1: I is_closed_on s,P & I is_halting_on s,P by Th34,Th35;
A2: J is_closed_on s,P & J is_halting_on s,P by Th34,Th35;
  per cases;
  suppose
    s.DataLoc(s.a,k1) > 0;
    then IExec(IF,P,s) = IExec(I,P,s) +* Start-At((card I+card J+2),SCMPDS)
    by A1,Th84;
    hence thesis by FUNCT_4:113;
  end;
  suppose
    s.DataLoc(s.a,k1) <= 0;
    then IExec(IF,P,s) = IExec(J,P,s) +* Start-At((card I+card J+2),SCMPDS)
    by A2,Th85;
    hence thesis by FUNCT_4:113;
  end;
end;

theorem
  for s being 0-started State of SCMPDS,I being halt-free shiftable parahalting
  Program of SCMPDS,J being shiftable Program of SCMPDS,a,b being Int_position,
k1 being Integer st s.DataLoc(s.a,k1)>0 holds
 IExec(if>0(a,k1,I,J),P,s).b = IExec(I,P,s).b
proof
  let s be 0-started State of SCMPDS,
      I be halt-free shiftable parahalting Program of
  SCMPDS,J be shiftable Program of SCMPDS,a,b be Int_position, k1 be Integer;
  assume
A1: s.DataLoc(s.a,k1)>0;
A2: not b in dom Start-At((card I+card J+2),SCMPDS) by SCMPDS_4:18;
  I is_closed_on s,P & I is_halting_on s,P by Th34,Th35;
  then
  IExec(if>0(a,k1,I,J),P,s) = IExec(I,P,s)
   +* Start-At((card I + card J + 2),SCMPDS) by A1,Th84;
  hence thesis by A2,FUNCT_4:11;
end;

theorem
  for s being 0-started State of SCMPDS,I being Program of SCMPDS,J being
  halt-free parahalting shiftable Program of SCMPDS,a,b being Int_position,k1
being Integer st s.DataLoc(s.a,k1) <= 0 holds
 IExec(if>0(a,k1,I,J),P,s).b = IExec(J,P,s).b
proof
  let s be 0-started State of SCMPDS,I be Program of SCMPDS,
      J be halt-free parahalting
  shiftable Program of SCMPDS,a,b be Int_position, k1 be Integer;
  set IF=if>0(a,k1,I,J);
  assume
A1: s.DataLoc(s.a,k1) <= 0;
A2: not b in dom Start-At((card I+card J+2),SCMPDS) by SCMPDS_4:18;
  J is_closed_on s,P & J is_halting_on s,P by Th34,Th35;
  then IExec(IF,P,s) =IExec(J,P,s) +* Start-At((card I+card J+2),SCMPDS)
  by A1,Th85;
  hence thesis by A2,FUNCT_4:11;
end;

begin :: The computation of "if var>0 then block"

theorem
  card if>0(a,k1,I) = card I + 1 by Th15;

theorem
   0 in dom if>0(a,k1,I)
proof
  set ci=card if>0(a,k1,I);
  ci=card I + 1 by Th15;
  hence thesis by AFINSQ_1:66;
end;

theorem
  if>0(a,k1,I). 0 = (a,k1)<=0_goto (card I + 1) by Th16;

theorem Th92:
  for s being State of SCMPDS, I being shiftable Program of SCMPDS
  , a being Int_position,k1 being Integer st s.DataLoc(s.a,k1)> 0 & I
is_closed_on s,P & I is_halting_on s,P holds if>0(a,k1,I) is_closed_on s,P
 & if>0(a,
  k1,I) is_halting_on s,P
proof
  let s be State of SCMPDS, I be shiftable Program of SCMPDS, a be
  Int_position,k1 be Integer;
  set b=DataLoc(s.a,k1);
  set IF=if>0(a,k1,I), pIF=stop IF, pI=stop I,
   s2 = Initialize s, s3 = Initialize s,
   P2 = P +* pI, P3 = P +* pIF,
   s4 = Comput(P3,s3,1), P4 = P3;
  set i = (a,k1)<=0_goto (card I + 1);
A3:  0 in dom pIF by COMPOS_1:36;
A4: IC s3 = 0 by MEMSTR_0:47;
A5: not b in dom Start-At(0,SCMPDS) by SCMPDS_4:18;
  not a in dom Start-At(0,SCMPDS) by SCMPDS_4:18;
  then
A6: s3.DataLoc(s3.a,k1)=s3.b by FUNCT_4:11
    .= s.b by A5,FUNCT_4:11;
A7: Comput(P3, s3,0 + 1) = Following(P3,Comput(P3,s3,0)) by EXTPRO_1:3
    .= Following(P3,s3) by EXTPRO_1:2
    .= Exec(i,s3) by Th22;
  for a holds s2.a = s4.a by A7,SCMPDS_2:56;
  then
A9: DataPart s2 = DataPart s4 by SCMPDS_4:8;
  assume
  s.b > 0;
  then
A10: IC s4 = succ IC s3 by A7,A6,SCMPDS_2:56
    .= (0+1) by A4;
  assume
A11: I is_closed_on s,P;
  then
A12: I is_closed_on s2,P2 by Th38;
  assume
  I is_halting_on s,P;
  then
A13: P2 halts_on s2 by Def3;
A14: Start-At(0,SCMPDS) c= s2 & Shift(pI,1) c= P4 by Lm6,FUNCT_4:25;
UU:  stop I c= P2 by FUNCT_4:25;
A15: card pIF = card IF +1 by COMPOS_1:55
    .= card I +1+1 by Th15;
  now
    let k be Element of NAT;
    per cases;
    suppose
      0 < k;
      then consider k1 being Nat such that
A16:  k1 + 1 = k by NAT_1:6;
      reconsider k1 as Element of NAT by ORDINAL1:def 12;
      reconsider m = IC Comput(P2, s2,k1) as Element of NAT;
A17:  card pIF = card pI+1 by A15,COMPOS_1:55;
       m in dom pI by A11,Def2;
      then m < card pI by AFINSQ_1:66;
      then
A18:  m+1 < card pIF by A17,XREAL_1:6;
      IC Comput(P3,s3,k) = IC Comput(P3, s4,k1) by A16,EXTPRO_1:4
        .=  (m + 1) by A12,A14,A10,A9,Th45,UU;
      hence IC Comput(P3,s3,k) in dom pIF by A18,AFINSQ_1:66;
    end;
    suppose
      k = 0;
      hence IC Comput(P3,s3,k) in dom pIF by A3,A4,EXTPRO_1:2;
    end;
  end;
  hence IF is_closed_on s,P by Def2;
A21: Comput(P3,s3,LifeSpan(P2,s2)+1)
 = Comput(P3,Comput(P3,s3,1),LifeSpan(P2
,s2))
 by EXTPRO_1:4;
  CurInstr(P3,
  Comput(P3,s3,LifeSpan(P2,s2)+1))
   =CurInstr(P3,Comput(P3,s4,LifeSpan(P2,s2))) by A21
    .=CurInstr(P2,Comput(P2,s2,LifeSpan(P2,s2))) by A12,A14,A10,A9,Th45,UU
    .= halt SCMPDS by A13,EXTPRO_1:def 15;
  then P3 halts_on s3 by EXTPRO_1:29;
  hence thesis by Def3;
end;

theorem Th93:
  for s being State of SCMPDS,I being Program of SCMPDS, a being
  Int_position, k1 being Integer st s.DataLoc(s.a,k1) <= 0 holds if>0(a,k1,I)
  is_closed_on s,P & if>0(a,k1,I) is_halting_on s,P
proof
  let s be State of SCMPDS,I be Program of SCMPDS, a be Int_position,k1 be
  Integer;
  set b=DataLoc(s.a,k1);
  assume
A1: s.b <= 0;
  set i = (a,k1)<=0_goto (card I + 1);
  set IF=if>0(a,k1,I), pIF=stop IF, s3 = Initialize s,
  P3 = P +* pIF,
  s4 = Comput(P3,s3,1), P4 = P3;
A3: IC s3 = 0 by MEMSTR_0:47;
A4: not b in dom Start-At(0,SCMPDS) by SCMPDS_4:18;
  not a in dom Start-At(0,SCMPDS) by SCMPDS_4:18;
  then
A5: s3.DataLoc(s3.a,k1)=s3.b by FUNCT_4:11
    .= s.b by A4,FUNCT_4:11;
  Comput(P3, s3,0 + 1) = Following(P3,Comput(P3,s3,0)) by EXTPRO_1:3
    .= Following(P3,s3) by EXTPRO_1:2
    .= Exec(i,s3) by Th22;
  then
A6: IC s4 = ICplusConst(s3,card I + 1) by A1,A5,SCMPDS_2:56
    .= (0+(card I + 1)) by A3,Th23;
A7: card IF=card I+1 by Th15;
  then
A8: (card I+1) in dom pIF by COMPOS_1:64;
A9:  P3/.IC s4
 = P3.IC s4 by PBOOLE:143;
  pIF c= P3 by FUNCT_4:25;
  then pIF c= P4;
  then P4.(card I+1) = pIF.(card I+1) by A8,GRFUNC_1:2
    .=halt SCMPDS by A7,COMPOS_1:64;
  then
A10: CurInstr(P3,s4) = halt SCMPDS by A6,A9;
  now
    let k be Element of NAT;
    per cases;
    suppose
      0 < k;
      then 1+0 <= k by INT_1:7;
      hence IC Comput(P3,s3,k) in dom pIF by A8,A6,A10,EXTPRO_1:5;
    end;
    suppose
      k = 0;
      then Comput(P3,s3,k) = s3 by EXTPRO_1:2;
      hence IC Comput(P3,s3,k) in dom pIF by A3,COMPOS_1:36;
    end;
  end;
  hence IF is_closed_on s,P by Def2;
  P3 halts_on s3 by A10,EXTPRO_1:29;
  hence thesis by Def3;
end;

theorem Th94:
  for s being State of SCMPDS,I being halt-free shiftable
Program of SCMPDS, a being Int_position,k1 being Integer st s.DataLoc(s.a,k1)>
0 & I is_closed_on s,P & I is_halting_on s,P
 holds IExec(if>0(a,k1,I),P,Initialize s) = IExec(I,P,Initialize s)
  +* Start-At((card I+1),SCMPDS)
proof
  let s be State of SCMPDS,I be halt-free shiftable Program of SCMPDS, a be
  Int_position,k1 be Integer;
  set b=DataLoc(s.a,k1);
  set IF=if>0(a,k1,I), pI=stop I, pIF = stop IF,
   s2 = Initialize s, s3 = Initialize s,
   P2 = P +* pI, P3 = P +* pIF,
   s4 = Comput(P3, s3,1), P4 = P3;
  set i = (a,k1)<=0_goto (card I + 1);
  set SAl=Start-At((card I+1),SCMPDS);
A3: IC s3 = 0 by MEMSTR_0:47;
A4: not b in dom Start-At(0,SCMPDS) by SCMPDS_4:18;
  not a in dom Start-At(0,SCMPDS) by SCMPDS_4:18;
  then
A5: s3.DataLoc(s3.a,k1)=s3.b by FUNCT_4:11
    .= s.b by A4,FUNCT_4:11;
A6: Comput(P3, s3,0 + 1) = Following(P3,Comput(P3,s3,0)) by EXTPRO_1:3
    .= Following(P3,s3) by EXTPRO_1:2
    .= Exec(i,s3) by Th22;
  assume
  s.b > 0;
  then
A7: IC s4 = succ IC s3 by A6,A5,SCMPDS_2:56
    .= (0+1) by A3;
  for a holds s2.a = s4.a by A6,SCMPDS_2:56;
  then
A9: DataPart s2 = DataPart s4 by SCMPDS_4:8;
  assume
A10: I is_closed_on s,P;
  then
A11: I is_closed_on s2,P2 by Th38;
A13: Start-At(0,SCMPDS) c= s2 & Shift(pI,1) c= P4 by Lm6,FUNCT_4:25;
UU:  stop I c= P2 by FUNCT_4:25;
  assume
A14: I is_halting_on s,P;
  then
A15: P2 halts_on s2 by Def3;
A17: Comput(P3,s3,LifeSpan(P2,s2)+1)
 = Comput(P3,Comput(P3,s3,1),LifeSpan(P2,s2))
by EXTPRO_1:4;
A20: CurInstr(P3,Comput(P3,s3,LifeSpan(P2,s2)+1))
     =CurInstr(P3,Comput(P3,s4,LifeSpan(P2,s2))) by A17
    .=CurInstr(P2,Comput(P2,s2,LifeSpan(P2,s2))) by A11,A13,A7,A9,Th45,UU
    .= halt SCMPDS by A15,EXTPRO_1:def 15;
  then
A21: P3 halts_on s3 by EXTPRO_1:29;
A22: CurInstr(P3,s3) = i by Th22;
  now
    let l be Element of NAT;
    assume
A23: l < LifeSpan(P2,s2) + 1;
A24: Comput(P3,s3,0) = s3 by EXTPRO_1:2;
    per cases;
    suppose
      l = 0;
      then CurInstr(P3,Comput(P3,s3,l))
       = CurInstr(P3,s3)
       by A24;
      hence CurInstr(P3,Comput(P3,s3,l))
       <> halt SCMPDS by A22;
    end;
    suppose
      l <> 0;
      then consider n be Nat such that
A25:  l = n + 1 by NAT_1:6;
      reconsider n as Element of NAT by ORDINAL1:def 12;
A26:  n < LifeSpan(P2,s2) by A23,A25,XREAL_1:6;
      assume
A27:  CurInstr(P3,Comput(P3,
s3,l)) = halt SCMPDS;
A29: Comput(P3,s3,n+1)
 = Comput(P3,Comput(P3,s3,1),n) by EXTPRO_1:4;
      CurInstr(P2,Comput(P2,s2,n)) =
      CurInstr(P3,Comput(P3,s4,n)) by A11,A13,A7,A9,Th45,UU
        .= halt SCMPDS by A25,A27,A29;
      hence contradiction by A15,A26,EXTPRO_1:def 15;
    end;
  end;
  then for l be Element of NAT st CurInstr(P3,
  Comput(P3,s3,l)) = halt SCMPDS
  holds LifeSpan(P2,s2) + 1 <= l;
  then
A32: LifeSpan(P3,s3) = LifeSpan(P2,s2) + 1 by A20,A21,EXTPRO_1:def 15;
A34: DataPart Result(P2,s2) = DataPart Comput(P2,s2,
LifeSpan(P2,s2)) by A15,EXTPRO_1:23
    .= DataPart Comput(P3, s4,LifeSpan(P2,s2)) by A11,A13,A7,A9,Th45,UU
    .= DataPart Comput(P3, s3,LifeSpan(P2,s2) + 1)
by EXTPRO_1:4
    .= DataPart Result(P3,s3) by A21,A32,EXTPRO_1:23;
A35: now
    let x be set;
A36: dom SAl = {IC SCMPDS} by FUNCOP_1:13;
    assume
A37: x in dom IExec(IF,P,Initialize s);
    per cases by A37,SCMPDS_4:6;
    suppose
A38:  x is Int_position;
      then x <> IC SCMPDS by SCMPDS_2:43;
      then
A39:  not x in dom SAl by A36,TARSKI:def 1;
      thus IExec(IF,P,Initialize s).x = (Result(P3,s3)).x
        .= (Result(P2,s2)).x by A34,A38,SCMPDS_4:8
        .= IExec(I,P,Initialize s).x
        .= (IExec(I,P,Initialize s) +* SAl).x by A39,FUNCT_4:11;
    end;
    suppose
A41:  x = IC SCMPDS;
A43:  IC Result(P2,s2) = IC IExec(I,P,Initialize s)
        .=  card I by A10,A14,Th48;
A44:  x in dom SAl by A36,A41,TARSKI:def 1;
      thus IExec(IF,P,Initialize s).x = (Result(P3,s3)).x
        .= Comput(P3, s3,LifeSpan(P2,s2) + 1).x by A21,A32,EXTPRO_1:23
        .= IC Comput(P3, s4,LifeSpan(P2,s2)) by A41,EXTPRO_1:4
        .= IC Comput(P2, s2,LifeSpan(P2,s2)) + 1
        by A11,A13,A7,A9,Th45,UU
        .= IC Result(P2,s2) + 1 by A15,EXTPRO_1:23
        .= IC SAl by A43,FUNCOP_1:72
        .= (IExec(I,P,Initialize s) +* SAl).x by A41,A44,FUNCT_4:13;
    end;
  end;
  dom IExec(IF,P,Initialize s) = the carrier of SCMPDS by PARTFUN1:def 2
    .= dom (IExec(I,P,Initialize s) +* SAl) by PARTFUN1:def 2;
  hence thesis by A35,FUNCT_1:2;
end;

theorem Th95:
  for s being State of SCMPDS,I being Program of SCMPDS,a being
Int_position, k1 being Integer st s.DataLoc(s.a,k1) <= 0
 holds IExec(if>0(a,k1,I),P,Initialize s) = s +* Start-At((card I+1),SCMPDS)
proof
  let s be State of SCMPDS,I be Program of SCMPDS,a be Int_position, k1 be
  Integer;
  set b=DataLoc(s.a,k1);
  set IF=if>0(a,k1,I), pIF=stop IF, s3 = Initialize s,
  P3 = P +* pIF,
  s4 = Comput(P3, s3,1), P4 = P3;
  set i = (a,k1)<=0_goto (card I + 1);
  set SAl=Start-At((card I+1),SCMPDS);
A2: IC s3 = 0 by MEMSTR_0:47;
A3: not b in dom Start-At(0,SCMPDS) by SCMPDS_4:18;
  not a in dom Start-At(0,SCMPDS) by SCMPDS_4:18;
  then
A4: s3.DataLoc(s3.a,k1)=s3.b by FUNCT_4:11
    .= s.b by A3,FUNCT_4:11;
A5: Comput(P3, s3,0 + 1) = Following(P3,Comput(P3,s3,0)) by EXTPRO_1:3
    .= Following(P3,s3) by EXTPRO_1:2
    .= Exec(i,s3) by Th22;
  assume
  s.b <= 0;
  then
A6: IC s4 = ICplusConst(s3,card I + 1) by A5,A4,SCMPDS_2:56
    .= (0+(card I + 1)) by A2,Th23;
  pIF c= P3 by FUNCT_4:25;
  then
A7: pIF c= P4;
A8:  P3/.IC s4
 = P3.IC s4 by PBOOLE:143;
A10: card IF=card I+1 by Th15;
  then (card I+1) in dom pIF by COMPOS_1:64;
  then P4.(card I+1) = pIF.(card I+1) by A7,GRFUNC_1:2
    .=halt SCMPDS by A10,COMPOS_1:64;
  then
A11: CurInstr(P3,s4) = halt SCMPDS by A6,A8;
  then
A12: P3 halts_on s3 by EXTPRO_1:29;
A13: CurInstr(P3,s3) = i by Th22;
  now
    let l be Element of NAT;
A14: Comput(P3,s3,0) = s3 by EXTPRO_1:2;
    assume
    l < 1;
    then l <1+0;
    then l=0 by NAT_1:13;
    then CurInstr(P3,Comput(P3,s3,l))
     = CurInstr(P3,s3) by A14;
    hence CurInstr(P3,Comput(P3,s3,l))
     <> halt SCMPDS by A13;
  end;
  then for l be Element of NAT st CurInstr(P3,
  Comput(P3,s3,l)) = halt SCMPDS
  holds 1 <= l;
  then LifeSpan(P3,s3) = 1 by A11,A12,EXTPRO_1:def 15;
  then
A15: s4 = Result(P3,s3) by A12,EXTPRO_1:23;
A17: now
A18: dom SAl = {IC SCMPDS} by FUNCOP_1:13;
    let x be set;
    assume
A19: x in dom IExec(IF,P,Initialize s);
    per cases by A19,SCMPDS_4:6;
    suppose
A20:  x is Int_position;
      then x <> IC SCMPDS by SCMPDS_2:43;
      then
A21:  not x in dom SAl by A18,TARSKI:def 1;
TT:   not x in dom Start-At(0,SCMPDS) by A20,SCMPDS_4:18;
      thus IExec(IF,P,Initialize s).x = s4.x by A15
        .= s3.x by A5,A20,SCMPDS_2:56
        .= s.x by TT,FUNCT_4:11
        .= (s +* SAl).x by A21,FUNCT_4:11;
    end;
    suppose
A22:  x = IC SCMPDS;
      hence IExec(IF,P,Initialize s).x = (card I + 1) by A6,A15
        .= (s +* SAl).x by A22,FUNCT_4:113;
    end;
  end;
  dom IExec(IF,P,Initialize s) = the carrier of SCMPDS by PARTFUN1:def 2
    .= dom (s +* SAl) by PARTFUN1:def 2;
  hence thesis by A17,FUNCT_1:2;
end;

registration
  let I be shiftable parahalting Program of SCMPDS, a be Int_position,k1 be
  Integer;
  cluster if>0(a,k1,I) -> shiftable parahalting;
  correctness
  proof
    set i = (a,k1)<=0_goto (card I +1);
    set IF=if>0(a,k1,I), pIF = stop IF;
    thus IF is shiftable;
      let s be 0-started State of SCMPDS;
      let P be Instruction-Sequence of SCMPDS;
A1:  Initialize s = s by MEMSTR_0:44;
      assume pIF c= P;
      then
A2:   P = P +* stop IF by FUNCT_4:98;
A3:   I is_closed_on s,P & I is_halting_on s,P by Th34,Th35;
      per cases;
      suppose
        s.DataLoc(s.a,k1) > 0;
        then IF is_halting_on s,P by A3,Th92;
        hence P halts_on s by A2,Def3,A1;
      end;
      suppose
        s.DataLoc(s.a,k1) <= 0;
        then IF is_halting_on s,P by Th93;
        hence P halts_on s by A2,Def3,A1;
      end;
  end;
end;

registration
  let I be halt-free Program of SCMPDS, a be Int_position,k1 be Integer;
  cluster if>0(a,k1,I) -> halt-free;
  coherence;
end;

theorem
  for s being 0-started State of SCMPDS,
      I being halt-free shiftable parahalting Program of SCMPDS,
      a being Int_position,k1 being Integer
 holds IC IExec(if>0(a,k1,I),P,s) = card I + 1
proof
  let s be 0-started State of SCMPDS,
      I be halt-free shiftable parahalting Program of
  SCMPDS,a be Int_position,k1 be Integer;
  set IF=if>0(a,k1,I);
A1: I is_closed_on s,P & I is_halting_on s,P by Th34,Th35;
I: Initialize s = s by MEMSTR_0:44;
  per cases;
  suppose
    s.DataLoc(s.a,k1) > 0;
    then IExec(IF,P,s) =IExec(I,P,s) +* Start-At((card I+1),SCMPDS)
    by A1,Th94,I;
    hence thesis by FUNCT_4:113;
  end;
  suppose
    s.DataLoc(s.a,k1) <= 0;
    then IExec(IF,P,s) =s +* Start-At((card I+1),SCMPDS) by Th95,I;
    hence thesis by FUNCT_4:113;
  end;
end;

theorem
  for s being State of SCMPDS,I being halt-free shiftable parahalting
Program of SCMPDS,a,b being Int_position,k1 being Integer st s.DataLoc(s.a,k1)>
  0 holds IExec(if>0(a,k1,I),P,Initialize s).b = IExec(I,P,Initialize s).b
proof
  let s be State of SCMPDS,I be halt-free shiftable parahalting Program of
  SCMPDS,a,b be Int_position,k1 be Integer;
  assume
A1: s.DataLoc(s.a,k1) > 0;
A2: not b in dom Start-At((card I+1),SCMPDS) by SCMPDS_4:18;
  I is_closed_on s,P & I is_halting_on s,P by Th34,Th35;
  then IExec(if>0(a,k1,I),P,Initialize s) = IExec(I,P,Initialize s)
   +* Start-At((card I+1),SCMPDS)
  by A1,Th94;
  hence thesis by A2,FUNCT_4:11;
end;

theorem
  for s being State of SCMPDS,I being Program of SCMPDS,a,b being
Int_position, k1 being Integer st s.DataLoc(s.a,k1) <= 0
 holds IExec(if>0(a,k1,I),P,Initialize s).b = s.b
proof
  let s be State of SCMPDS,I be Program of SCMPDS,a,b be Int_position, k1 be
  Integer;
  assume
  s.DataLoc(s.a,k1) <= 0;
  then
A1: IExec(if>0(a,k1,I),P,Initialize s) = s +* Start-At((card I+1),SCMPDS)
 by Th95;
  not b in dom Start-At((card I+1),SCMPDS) by SCMPDS_4:18;
  hence thesis by A1,FUNCT_4:11;
end;

begin :: The computation of "if var<=0 then block"

theorem
  card if<=0(a,k1,I) = card I + 2 by Lm8;

theorem
   0 in dom if<=0(a,k1,I) &  1 in dom if<=0(a,k1,I) by Lm9;

theorem
  if<=0(a,k1,I). 0 = (a,k1)<=0_goto 2 & if<=0(a,k1,I). 1 =
  goto (card I + 1) by Lm10;

theorem Th102:
  for s being State of SCMPDS, I being shiftable Program of
  SCMPDS, a being Int_position,k1 being Integer st s.DataLoc(s.a,k1) <= 0 & I
is_closed_on s,P & I is_halting_on s,P holds if<=0(a,k1,I) is_closed_on s,P
 & if<=0(a
  ,k1,I) is_halting_on s,P
proof
  let s be State of SCMPDS, I be shiftable Program of SCMPDS, a be
  Int_position,k1 be Integer;
  set b=DataLoc(s.a,k1);
  set IF=if<=0(a,k1,I), pIF=stop IF, pI=stop I,
   s2 = Initialize s, s3 = Initialize s,
   P2 = P +* pI, P3 = P +* pIF,
   s4 = Comput(P3,s3,1), P4 = P3;
  set i = (a,k1)<=0_goto 2, j = goto (card I + 1);
UU:  stop I c= P2 by FUNCT_4:25;
A3: IF = i ';' (j ';' I) by SCMPDS_4:16;
A4: Comput(P3, s3,0 + 1) = Following(P3,Comput(P3,s3,0)) by EXTPRO_1:3
    .= Following(P3,s3) by EXTPRO_1:2
    .= Exec(i,s3) by A3,Th22;
  for a holds s2.a = s4.a by A4,SCMPDS_2:56;
  then
A6: DataPart s2 = DataPart s4 by SCMPDS_4:8;
A7: not b in dom Start-At(0,SCMPDS) by SCMPDS_4:18;
  not a in dom Start-At(0,SCMPDS) by SCMPDS_4:18;
  then
A8: s3.DataLoc(s3.a,k1)=s3.b by FUNCT_4:11
    .= s.b by A7,FUNCT_4:11;
A9: IC s3 = 0 by MEMSTR_0:47;
  assume
  s.b <= 0;
  then
A10: IC s4 = ICplusConst(s3,2) by A4,A8,SCMPDS_2:56
    .= (0+2) by A9,Th23;
  assume
A11: I is_closed_on s,P;
  then
A12: I is_closed_on s2,P2 by Th38;
  assume
  I is_halting_on s,P;
  then
A13: P2 halts_on s2 by Def3;
A14: Start-At(0,SCMPDS) c= s2 & Shift(pI,2) c= P4 by Lm7,FUNCT_4:25;
A15:  0 in dom pIF by COMPOS_1:36;
  now
    let k be Element of NAT;
    per cases;
    suppose
      0 < k;
      then consider k1 being Nat such that
A16:  k1 + 1 = k by NAT_1:6;
      reconsider k1 as Element of NAT by ORDINAL1:def 12;
      reconsider m = IC Comput(P2, s2,k1) as Element of NAT;
A17:  card pIF = 1+ card IF by COMPOS_1:55
        .= 1+(card I +2) by Lm8
        .= 1+card I +2
        .=card pI+2 by COMPOS_1:55;
       m in dom pI by A11,Def2;
      then m < card pI by AFINSQ_1:66;
      then
A18:  m+2 < card pIF by A17,XREAL_1:6;
      IC Comput(P3,s3,k) = IC Comput(P3, s4,k1) by A16,EXTPRO_1:4
        .=  (m + 2) by A12,A14,A10,A6,Th45,UU;
      hence IC Comput(P3,s3,k) in dom pIF by A18,AFINSQ_1:66;
    end;
    suppose
      k = 0;
      hence IC Comput(P3,s3,k) in dom pIF by A15,A9,EXTPRO_1:2;
    end;
  end;
  hence IF is_closed_on s,P by Def2;
A21: Comput(P3,s3,LifeSpan(P2,s2)+1)
 = Comput(P3,Comput(P3,s3,1),LifeSpan(P2
,s2))
by EXTPRO_1:4;
  CurInstr(P3,
  Comput(P3,s3,LifeSpan(P2,s2)+1))
   =CurInstr(P3,
   Comput(P3,s4,LifeSpan(P2,s2))) by A21
    .=CurInstr(P2,
    Comput(P2,s2,LifeSpan(P2,s2))) by A12,A14,A10,A6,Th45,UU
    .= halt SCMPDS by A13,EXTPRO_1:def 15;
  then P3 halts_on s3 by EXTPRO_1:29;
  hence thesis by Def3;
end;

theorem Th103:
  for s being State of SCMPDS,I being Program of SCMPDS, a being
  Int_position, k1 being Integer st s.DataLoc(s.a,k1) > 0 holds if<=0(a,k1,I)
  is_closed_on s,P & if<=0(a,k1,I) is_halting_on s,P
proof
  let s be State of SCMPDS,I be Program of SCMPDS, a be Int_position,k1 be
  Integer;
  set b=DataLoc(s.a,k1);
  assume
A1: s.b > 0;
  set i = (a,k1)<=0_goto 2, j = goto (card I + 1);
  set IF=if<=0(a,k1,I), pIF=stop IF, s3 = Initialize s,
  P3 = P +* pIF,
  s4 = Comput(P3,s3,1), s5 = Comput(P3,s3,2), P4 = P3, P5 = P3;
A3: IF =i ';' (j ';' I) by SCMPDS_4:16;
A4: not b in dom Start-At(0,SCMPDS) by SCMPDS_4:18;
  not a in dom Start-At(0,SCMPDS) by SCMPDS_4:18;
  then
A5: s3.DataLoc(s3.a,k1)=s3.b by FUNCT_4:11
    .= s.b by A4,FUNCT_4:11;
A6: IC s3 = 0 by MEMSTR_0:47;
  Comput(P3, s3,0 + 1) = Following(P3,Comput(P3,s3,0)) by EXTPRO_1:3
    .= Following(P3,s3) by EXTPRO_1:2
    .= Exec(i,s3) by A3,Th22;
  then
A7: IC s4 = succ IC s3 by A1,A5,SCMPDS_2:56
    .= (0+1) by A6;
A8: pIF c= P3 by FUNCT_4:25;
  then
A9: pIF c= P4;
A10:  1 in dom IF by Lm9;
  then  1 in dom pIF by COMPOS_1:62;
  then
A11: P4. 1 = pIF. 1 by A9,GRFUNC_1:2
    .=IF. 1 by A10,COMPOS_1:63
    .=j by Lm10;
A12: card IF=card I+2 by Lm8;
  then
A13: (card I+2) in dom pIF by COMPOS_1:64;
A14:  P3/.IC s4
 = P3.IC s4 by PBOOLE:143;
  Comput(P3, s3,1 + 1) = Following(P3,s4) by EXTPRO_1:3
    .= Exec(j,s4) by A7,A11,A14;
  then
A16: IC s5 = ICplusConst(s4,card I+1) by SCMPDS_2:54
    .= (card I+1+1) by A7,Th23
    .= (card I+(1+1));
A17:  (P3)/.IC s5
 = P3.IC s5 by PBOOLE:143;
  pIF c= P5 by A8;
  then P5.(card I+2) = pIF.(card I+2) by A13,GRFUNC_1:2
    .=halt SCMPDS by A12,COMPOS_1:64;
  then
A19: CurInstr(P3,s5) = halt SCMPDS by A16,A17;
  now
    let k be Element of NAT;
A20: k = 0 or 0 + 1 <= k by INT_1:7;
    per cases by A20,XXREAL_0:1;
    suppose
      k = 0;
      then Comput(P3,s3,k) = s3 by EXTPRO_1:2;
      hence IC Comput(P3,s3,k) in dom pIF by A6,COMPOS_1:36;
    end;
    suppose
      k = 1;
      hence IC Comput(P3,s3,k) in dom pIF by A10,A7,COMPOS_1:62;
    end;
    suppose
      1 < k;
      then 1+1 <= k by INT_1:7;
      hence IC Comput(P3,s3,k) in dom pIF
      by A13,A16,A19,EXTPRO_1:5;
    end;
  end;
  hence IF is_closed_on s,P by Def2;
  P3 halts_on s3 by A19,EXTPRO_1:29;
  hence thesis by Def3;
end;

theorem Th104:
  for s being State of SCMPDS,I being halt-free shiftable
  Program of SCMPDS, a being Int_position,k1 being Integer st s.DataLoc(s.a,k1)
  <= 0 & I is_closed_on s,P & I is_halting_on s,P
   holds IExec(if<=0(a,k1,I),P,Initialize s) =
  IExec(I,P,Initialize s) +* Start-At((card I+2),SCMPDS)
proof
  let s be State of SCMPDS,I be halt-free shiftable Program of SCMPDS, a be
  Int_position,k1 be Integer;
  set b=DataLoc(s.a,k1);
  set IF=if<=0(a,k1,I), pIF = stop IF, pI = stop I,
   s2 = Initialize s, s3 = Initialize s,
   P2 = P +* pI, P3 = P +* pIF,
   s4 = Comput(P3, s3,1), P4 = P3;
  set i = (a,k1)<=0_goto 2, j = goto (card I + 1);
  set SAl=Start-At((card I+2),SCMPDS);
UU:  stop I c= P2 by FUNCT_4:25;
A3: IF=i ';' (j ';' I) by SCMPDS_4:16;
A4: Comput(P3, s3,0 + 1) = Following(P3,Comput(P3,s3,0)) by EXTPRO_1:3
    .= Following(P3,s3) by EXTPRO_1:2
    .= Exec(i,s3) by A3,Th22;
A5: not b in dom Start-At(0,SCMPDS) by SCMPDS_4:18;
  not a in dom Start-At(0,SCMPDS) by SCMPDS_4:18;
  then
A6: s3.DataLoc(s3.a,k1)=s3.b by FUNCT_4:11
    .= s.b by A5,FUNCT_4:11;
A7: IC s3 = 0 by MEMSTR_0:47;
A8: Start-At(0,SCMPDS) c= s2 & Shift(pI,2) c= P4 by Lm7,FUNCT_4:25;
  for a holds s2.a = s4.a by A4,SCMPDS_2:56;
  then
A10: DataPart s2 = DataPart s4 by SCMPDS_4:8;
  assume
  s.b <= 0;
  then
A11: IC s4 = ICplusConst(s3,2) by A4,A6,SCMPDS_2:56
    .= (0+2) by A7,Th23;
  assume
A13: I is_closed_on s,P;
  then
A14: I is_closed_on s2,P2 by Th38;
  assume
A15: I is_halting_on s,P;
  then
A16: P2 halts_on s2 by Def3;
A18: Comput(P3,s3,LifeSpan(P2,s2)+1)
 = Comput(P3,Comput(P3,s3,1),LifeSpan(P2
,s2))
by EXTPRO_1:4;
A21: CurInstr(P3,
Comput(P3,s3,LifeSpan(P2,s2)+1))
 =CurInstr(P3,
 Comput(P3,s4,LifeSpan(P2,s2))) by A18
    .=CurInstr(P2,
    Comput(P2,s2,LifeSpan(P2,s2))) by A14,A8,A11,A10,Th45,UU
    .= halt SCMPDS by A16,EXTPRO_1:def 15;
  then
A22: P3 halts_on s3 by EXTPRO_1:29;
A23: CurInstr(P3,s3) = i by A3,Th22;
  now
    let l be Element of NAT;
    assume
A24: l < LifeSpan(P2,s2) + 1;
A25: Comput(P3,s3,0) = s3 by EXTPRO_1:2;
    per cases;
    suppose
      l = 0;
      then CurInstr(P3,Comput(P3,s3,l))
       = CurInstr(P3,s3)
       by A25;
      hence CurInstr(P3,Comput(P3,s3,l))
       <> halt SCMPDS by A23;
    end;
    suppose
      l <> 0;
      then consider n be Nat such that
A26:  l = n + 1 by NAT_1:6;
      reconsider n as Element of NAT by ORDINAL1:def 12;
A27:  n < LifeSpan(P2,s2) by A24,A26,XREAL_1:6;
      assume
A28:  CurInstr(P3,Comput(P3,s3,l)) = halt SCMPDS;
A30: Comput(P3,s3,n+1)
 = Comput(P3,Comput(P3,s3,1),n) by EXTPRO_1:4;
      CurInstr(P2,Comput(P2,s2,n)) =
      CurInstr(P3,Comput(P3,s4,n))
       by A14,A8,A11,A10,Th45,UU
        .= halt SCMPDS by A26,A28,A30;
      hence contradiction by A16,A27,EXTPRO_1:def 15;
    end;
  end;
  then for l be Element of NAT st CurInstr(P3,
  Comput(P3,s3,l)) = halt SCMPDS
  holds LifeSpan(P2,s2) + 1 <= l;
  then
A33: LifeSpan(P3,s3) = LifeSpan(P2,s2) + 1 by A21,A22,EXTPRO_1:def 15;
A35: DataPart Result(P2,s2) = DataPart Comput(P2,s2,
LifeSpan(P2,s2)) by A16,EXTPRO_1:23
    .= DataPart Comput(P3, s4,LifeSpan(P2,s2)) by A14,A8,A11,A10,Th45,UU
    .= DataPart Comput(P3, s3,LifeSpan(P2,s2) + 1)
by EXTPRO_1:4
    .= DataPart Result(P3,s3) by A22,A33,EXTPRO_1:23;
A36: now
    let x be set;
A37: dom Start-At((card I+2),SCMPDS) = {IC SCMPDS} by FUNCOP_1:13;
    assume
A38: x in dom IExec(IF,P,Initialize s);
    per cases by A38,SCMPDS_4:6;
    suppose
A39:  x is Int_position;
      then x <> IC SCMPDS by SCMPDS_2:43;
      then
A40:  not x in dom SAl by A37,TARSKI:def 1;
      thus IExec(IF,P,Initialize s).x = (Result(P3,s3)).x
        .= (Result(P2,s2)).x by A35,A39,SCMPDS_4:8
        .= IExec(I,P,Initialize s).x
        .= (IExec(I,P,Initialize s) +* SAl).x by A40,FUNCT_4:11;
    end;
    suppose
A42:  x = IC SCMPDS;
A44:  IC Result(P2,s2) = IC IExec(I,P,Initialize s)
        .=  card I by A13,A15,Th48;
A45:  x in dom SAl by A37,A42,TARSKI:def 1;
      thus IExec(IF,P,Initialize s).x = (Result(P3,s3)).x
        .= Comput(P3, s3,LifeSpan(P2,s2) + 1).x by A22,A33,EXTPRO_1:23
        .= IC Comput(P3, s4,LifeSpan(P2,s2)) by A42,EXTPRO_1:4
        .= IC Comput(P2, s2,LifeSpan(P2,s2)) + 2
        by A14,A8,A11,A10,Th45,UU
        .= IC Result(P2,s2) + 2 by A16,EXTPRO_1:23
        .= IC SAl by A44,FUNCOP_1:72
        .= (IExec(I,P,Initialize s) +* SAl).x by A42,A45,FUNCT_4:13;
    end;
  end;
  dom IExec(IF,P,Initialize s) = the carrier of SCMPDS by PARTFUN1:def 2
    .= dom (IExec(I,P,Initialize s)
     +* Start-At((card I+2),SCMPDS)) by PARTFUN1:def 2;
  hence thesis by A36,FUNCT_1:2;
end;

theorem Th105:
  for s being State of SCMPDS,I being Program of SCMPDS,a being
Int_position, k1 being Integer st s.DataLoc(s.a,k1) > 0
 holds IExec(if<=0(a,k1,I),P,Initialize s)
  = s +* Start-At((card I+2),SCMPDS)
proof
  let s be State of SCMPDS,I be Program of SCMPDS,a be Int_position, k1 be
  Integer;
  set b=DataLoc(s.a,k1);
  set IF=if<=0(a,k1,I), pIF=stop IF, s3 = Initialize s,
  P3 = P +* pIF,
  s4 = Comput(P3,s3,1), s5 = Comput(P3,s3,2), P4 = P3, P5 = P3;
  set i = (a,k1)<=0_goto 2, j = goto (card I + 1);
  set SAl=Start-At((card I+2),SCMPDS);
A2: IF =i ';' (j ';' I) by SCMPDS_4:16;
A3: not b in dom Start-At(0,SCMPDS) by SCMPDS_4:18;
  not a in dom Start-At(0,SCMPDS) by SCMPDS_4:18;
  then
A4: s3.DataLoc(s3.a,k1)=s3.b by FUNCT_4:11
    .= s.b by A3,FUNCT_4:11;
A5: IC s3 = 0 by MEMSTR_0:47;
A6: pIF c= P3 by FUNCT_4:25;
  then
A7: pIF c= P4;
A8: pIF c= P5 by A6;
A9: Comput(P3, s3,0 + 1) = Following(P3,Comput(P3,s3,0)) by EXTPRO_1:3
    .= Following(P3,s3) by EXTPRO_1:2
    .= Exec(i,s3) by A2,Th22;
  assume
  s.b > 0;
  then
A10: IC s4 = succ IC s3 by A9,A4,SCMPDS_2:56
    .= (0+1) by A5;
A11:  1 in dom IF by Lm9;
  then  1 in dom pIF by COMPOS_1:62;
  then
A12: P4.1 = pIF. 1 by A7,GRFUNC_1:2
    .=IF. 1 by A11,COMPOS_1:63
    .=j by Lm10;
A13:  P3/.IC s4
 = P3.IC s4 by PBOOLE:143;
A15: Comput(P3, s3,1 + 1) = Following(P3,s4) by EXTPRO_1:3
    .= Exec(j,s4) by A10,A12,A13;
  then
A16: IC s5 = ICplusConst(s4,card I+1) by SCMPDS_2:54
    .= (card I+1+1) by A10,Th23
    .= (card I+(1+1));
A17:  (P3)/.IC s5
 = P3.IC s5 by PBOOLE:143;
A19: card IF=card I+2 by Lm8;
  then (card I+2) in dom pIF by COMPOS_1:64;
  then P5.(card I+2) = pIF.(card I+2) by A8,GRFUNC_1:2
    .=halt SCMPDS by A19,COMPOS_1:64;
  then
A20: CurInstr(P3,s5) = halt SCMPDS by A16,A17;
  then
A21: P3 halts_on s3 by EXTPRO_1:29;
A22: CurInstr(P3,s3) = i by A2,Th22;
  now
    let l be Element of NAT;
    assume
    l < 1+1;
    then
A23: l <= 1 by NAT_1:13;
A24: Comput(P3,s3,0) = s3 by EXTPRO_1:2;
A25: P3/.IC Comput(P3,s3,l)
 = P3.IC Comput(P3,s3,l) by PBOOLE:143;
    per cases by A23,NAT_1:25;
    suppose
      l=0;
      then CurInstr(P3,Comput(P3,s3,l))
       = CurInstr(P3,s3)
       by A24;
      hence CurInstr(P3,Comput(P3,s3,l))
       <> halt SCMPDS by A22;
    end;
    suppose
      l=1;
      hence CurInstr(P3,Comput(P3,s3,l))
       <> halt SCMPDS by A10,A12,A25;
    end;
  end;
  then for l be Element of NAT st CurInstr(P3,
  Comput(P3,s3,l)) = halt SCMPDS
  holds 2 <= l;
  then LifeSpan(P3,s3) = 2 by A20,A21,EXTPRO_1:def 15;
  then
A27: s5 = Result(P3,s3) by A21,EXTPRO_1:23;
A29: now
A30: dom SAl = {IC SCMPDS} by FUNCOP_1:13;
    let x be set;
    assume
A31: x in dom IExec(IF,P,Initialize s);
    per cases by A31,SCMPDS_4:6;
    suppose
A32:  x is Int_position;
      then x <> IC SCMPDS by SCMPDS_2:43;
      then
A33:  not x in dom SAl by A30,TARSKI:def 1;
TT:   not x in dom Start-At(0,SCMPDS) by A32,SCMPDS_4:18;
      thus IExec(IF,P,Initialize s).x = s5.x by A27
        .= s4.x by A15,A32,SCMPDS_2:54
        .= s3.x by A9,A32,SCMPDS_2:56
        .= s.x by TT,FUNCT_4:11
        .= (s +* SAl).x by A33,FUNCT_4:11;
    end;
    suppose
A34:  x = IC SCMPDS;
      hence IExec(IF,P,Initialize s).x = (card I + 2) by A16,A27
        .= (s +* Start-At((card I+2),SCMPDS)).x by A34,FUNCT_4:113;
    end;
  end;
  dom IExec(IF,P,Initialize s) = the carrier of SCMPDS by PARTFUN1:def 2
    .= dom (s +* SAl) by PARTFUN1:def 2;
  hence thesis by A29,FUNCT_1:2;
end;

registration
  let I be shiftable parahalting Program of SCMPDS, a be Int_position,k1 be
  Integer;
  cluster if<=0(a,k1,I) -> shiftable parahalting;
  correctness
  proof
    set i = (a,k1)<=0_goto 2, j = goto (card I + 1);
    set IF=if<=0(a,k1,I), pIF = stop IF;
    thus IF is shiftable;
      let s be 0-started State of SCMPDS;
      let P be Instruction-Sequence of SCMPDS;
A1:  Initialize s = s by MEMSTR_0:44;
      assume pIF c= P;
      then
A2:   P = P +* stop IF by FUNCT_4:98;
A3:   I is_closed_on s,P & I is_halting_on s,P by Th34,Th35;
      per cases;
      suppose
        s.DataLoc(s.a,k1) <= 0;
        then IF is_halting_on s,P by A3,Th102;
        hence P halts_on s by A2,Def3,A1;
      end;
      suppose
        s.DataLoc(s.a,k1) > 0;
        then IF is_halting_on s,P by Th103;
        hence P halts_on s by A2,Def3,A1;
      end;
  end;
end;

registration
  let I be halt-free Program of SCMPDS, a be Int_position,k1 be Integer;
  cluster if<=0(a,k1,I) -> halt-free;
  coherence;
end;

theorem
  for s being 0-started State of SCMPDS,
      I being halt-free shiftable parahalting
Program of SCMPDS,a being Int_position,k1 being Integer
 holds IC IExec(if<=0(a,k1,I),P,s) = card I + 2
proof
  let s be 0-started State of SCMPDS,
  I be halt-free shiftable parahalting Program of
  SCMPDS,a be Int_position,k1 be Integer;
  set IF=if<=0(a,k1,I);
A1: I is_closed_on s,P & I is_halting_on s,P by Th34,Th35;
I: Initialize s = s by MEMSTR_0:44;
  per cases;
  suppose
    s.DataLoc(s.a,k1) <= 0;
    then IExec(IF,P,s) =IExec(I,P,s) +* Start-At((card I+2),SCMPDS)
    by A1,Th104,I;
    hence thesis by FUNCT_4:113;
  end;
  suppose
    s.DataLoc(s.a,k1) > 0;
    then IExec(IF,P,s) =s +* Start-At((card I+2),SCMPDS) by Th105,I;
    hence thesis by FUNCT_4:113;
  end;
end;

theorem
  for s being State of SCMPDS,I being halt-free shiftable parahalting
Program of SCMPDS,a,b being Int_position,k1 being Integer st s.DataLoc(s.a,k1)
  <= 0 holds IExec(if<=0(a,k1,I),P,Initialize s).b = IExec(I,P,Initialize s).b
proof
  let s be State of SCMPDS,I be halt-free shiftable parahalting Program of
  SCMPDS,a,b be Int_position,k1 be Integer;
  assume
A1: s.DataLoc(s.a,k1) <= 0;
A2: not b in dom Start-At((card I+2),SCMPDS) by SCMPDS_4:18;
  I is_closed_on s,P & I is_halting_on s,P by Th34,Th35;
  then IExec(if<=0(a,k1,I),P,Initialize s) = IExec(I,P,Initialize s)
   +* Start-At((card I+2),SCMPDS)
   by A1,Th104;
  hence thesis by A2,FUNCT_4:11;
end;

theorem
  for s being State of SCMPDS,I being Program of SCMPDS,a,b being
Int_position, k1 being Integer st s.DataLoc(s.a,k1) > 0
 holds IExec(if<=0(a,k1,I),P,Initialize s).b = s.b
proof
  let s be State of SCMPDS,I be Program of SCMPDS,a,b be Int_position, k1 be
  Integer;
  assume
  s.DataLoc(s.a,k1) > 0;
  then
A1: IExec(if<=0(a,k1,I),P,Initialize s) = s +* Start-At((card I+2),SCMPDS)
 by Th105;
  not b in dom Start-At((card I+2),SCMPDS) by SCMPDS_4:18;
  hence thesis by A1,FUNCT_4:11;
end;

begin :: The computation of "if var<0 then block1 else block2"

theorem
  card if<0(a,k1,I,J) = card I + card J + 2 by Lm4;

theorem
   0 in dom if<0(a,k1,I,J) &  1 in dom if<0(a,k1,I,J)
proof
  set ci=card if<0(a,k1,I,J);
  ci=card I + card J +2 by Lm4;
  then 2 <= ci by NAT_1:12;
  then 1 < ci by XXREAL_0:2;
  hence thesis by AFINSQ_1:66;
end;

theorem
  if<0(a,k1,I,J). 0 = (a,k1)>=0_goto (card I + 2) by Lm5;

theorem Th112:
  for s being 0-started State of SCMPDS, I,J being shiftable Program of
  SCMPDS, a being Int_position,k1 being Integer st s.DataLoc(s.a,k1)<0 & I
is_closed_on s,P & I is_halting_on s,P holds if<0(a,k1,I,J) is_closed_on s,P
 & if<0(a
  ,k1,I,J) is_halting_on s,P
proof
  let s be 0-started State of SCMPDS, I,J be shiftable Program of SCMPDS, a be
  Int_position,k1 be Integer;
  set b=DataLoc(s.a,k1);
  set G=Goto (card J+1);
  set I2 = I ';' G ';' J, IF=if<0(a,k1,I,J), pIF=stop IF,
   pI2=stop I2, P2 = P +* pI2, P3 = P +* pIF,
   s4 = Comput(P3,s,1), P4 = P3;
  set i = (a,k1)>=0_goto (card I + 2);
A3:  0 in dom pIF by COMPOS_1:36;
I: Initialize s = s by MEMSTR_0:44;
  then
A4: IC s = 0 by MEMSTR_0:47;
A7: IF = i ';' (I ';' G) ';' J by SCMPDS_4:14
    .= i ';' I2 by SCMPDS_4:14;
  then
A8: Shift(pI2,1) c= P4 by Lm6;
A9: Comput(P3, s,0 + 1) = Following(P3,Comput(P3,s,0)) by EXTPRO_1:3
    .= Following(P3,s) by EXTPRO_1:2
    .= Exec(i,s) by A7,Th22,I;
  for a holds s.a = s4.a by A9,SCMPDS_2:57;
  then
A11: DataPart s = DataPart s4 by SCMPDS_4:8;
  assume
  s.b < 0;
  then
A12: IC s4 = succ IC s by A9,SCMPDS_2:57
    .= (0+1) by A4;
  assume
A13: I is_closed_on s,P;
  assume
A14: I is_halting_on s,P;
  then
A15: I2 is_closed_on s,P by A13,Th44;
  then
A16: Start-At(0,SCMPDS) c= s & I2 is_closed_on s,P2 by Th38,FUNCT_4:25,I;
UU:  stop I2 c= P2 by FUNCT_4:25;
  I2 is_halting_on s,P by A13,A14,Th44;
  then
A17: P2 halts_on s by Def3,I;
A18: card pIF = card IF +1 by COMPOS_1:55
    .= card I2 +1+1 by A7,Th15;
  now
    let k be Element of NAT;
    per cases;
    suppose
      0 < k;
      then consider k1 being Nat such that
A19:  k1 + 1 = k by NAT_1:6;
      reconsider k1 as Element of NAT by ORDINAL1:def 12;
      reconsider m = IC Comput(P2, s,k1) as Element of NAT;
A20:  card pIF = card pI2+1 by A18,COMPOS_1:55;
       m in dom pI2 by A15,Def2,I;
      then m < card pI2 by AFINSQ_1:66;
      then
A21:  m+1 < card pIF by A20,XREAL_1:6;
      IC Comput(P3,s,k) = IC Comput(P3, s4,k1) by A19,EXTPRO_1:4
        .=  (m + 1) by A16,A8,A12,A11,Th45,UU;
      hence IC Comput(P3,s,k) in dom pIF by A21,AFINSQ_1:66;
    end;
    suppose
      k = 0;
      hence IC Comput(P3,s,k) in dom pIF by A3,A4,EXTPRO_1:2;
    end;
  end;
  hence IF is_closed_on s,P by Def2,I;
A24: Comput(P3,s,LifeSpan(P2,s)+1)
 = Comput(P3,Comput(P3,s,1),LifeSpan(P2,s))
 by EXTPRO_1:4;
  CurInstr(P3,
  Comput(P3,s,LifeSpan(P2,s)+1))
   =CurInstr(P3,Comput(P3,s4,LifeSpan(P2,s))) by A24
    .=CurInstr(P2,Comput(P2,s,LifeSpan(P2,s))) by A16,A8,A12,A11,Th45,UU
    .= halt SCMPDS by A17,EXTPRO_1:def 15;
  then P3 halts_on s by EXTPRO_1:29;
  hence thesis by Def3,I;
end;

theorem Th113:
  for s being State of SCMPDS,I being Program of SCMPDS,J being
shiftable Program of SCMPDS,a being Int_position,k1 being Integer st s.DataLoc(
  s.a,k1) >= 0 & J is_closed_on s,P & J is_halting_on s,P holds if<0(a,k1,I,J)
  is_closed_on s,P & if<0(a,k1,I,J) is_halting_on s,P
proof
  let s be State of SCMPDS,I be Program of SCMPDS, J be shiftable Program of
  SCMPDS, a be Int_position,k1 be Integer;
  set b=DataLoc(s.a,k1);
  set pJ=stop J, s1 = Initialize s, P1 = P +* pJ,
  IF=if<0(a,k1,I,J), pIF=
  stop IF, s3 = Initialize s, P3 = P +* pIF,
  s4 = Comput(P3,s3,1), P4 = P3;
  set i = (a,k1)>=0_goto (card I + 2);
  set G =Goto (card J+1), iG=i ';' I ';' G;
A3: IF = i ';' (I ';' G) ';' J by SCMPDS_4:14
    .= i ';' (I ';' G ';' J) by SCMPDS_4:14;
A4: Comput(P3, s3,0 + 1) = Following(P3,Comput(P3,s3,0)) by EXTPRO_1:3
    .= Following(P3,s3) by EXTPRO_1:2
    .= Exec(i,s3) by A3,Th22;
A5: not b in dom Start-At(0,SCMPDS) by SCMPDS_4:18;
  not a in dom Start-At(0,SCMPDS) by SCMPDS_4:18;
  then
A6: s3.DataLoc(s3.a,k1)=s3.b by FUNCT_4:11
    .= s.b by A5,FUNCT_4:11;
A7: IC s3 = 0 by MEMSTR_0:47;
  assume
  s.b >= 0;
  then
A8: IC s4 = ICplusConst(s3,card I + 2) by A4,A6,SCMPDS_2:57
    .= (0+(card I + 2)) by A7,Th23;
  assume
A9: J is_closed_on s,P;
  then
A10: Start-At(0,SCMPDS) c= s1 & J is_closed_on s1,P1 by Th38,FUNCT_4:25;
UU:  stop J c= P1 by FUNCT_4:25;
A11: pIF c= P3 by FUNCT_4:25;
A12: card iG = card (i ';' I) + card G by AFINSQ_1:17
    .=card (i ';' I) + 1 by COMPOS_1:54
    .=card I +1 +1 by Th15
    .=card I +(1 +1);
  then Shift(pJ,card I+2) c= pIF by Th24;
  then Shift(pJ,card I+2) c= P3 by A11,XBOOLE_1:1;
  then
A13: Shift(pJ,card I+2) c= P4;
  assume
  J is_halting_on s,P;
  then
A14: P1 halts_on s1 by Def3;
  for a holds s1.a = s4.a by A4,SCMPDS_2:57;
  then
A16: DataPart s1 = DataPart s4 by SCMPDS_4:8;
  now
    let k be Element of NAT;
    per cases;
    suppose
      0 < k;
      then consider k1 being Nat such that
A17:  k1 + 1 = k by NAT_1:6;
      reconsider k1 as Element of NAT by ORDINAL1:def 12;
      reconsider m = IC Comput(P1, s1,k1) as Element of NAT;
       m in dom pJ by A9,Def2;
      then m < card pJ by AFINSQ_1:66;
      then
A18:  m + (card I + 2) < card pJ + (card I + 2) by XREAL_1:6;
A19:  card pJ = card J + 1 by COMPOS_1:55;
A20:  card pIF = card IF+1 by COMPOS_1:55
        .=card I +2 +card J +1 by A12,AFINSQ_1:17
        .=card I +2 + card pJ by A19;
      IC Comput(P3,s3,k) = IC Comput(P3, s4,k1) by A17,EXTPRO_1:4
        .=  (m + (card I + 2)) by A10,A16,A13,A8,Th45,UU;
      hence IC Comput(P3,s3,k) in dom pIF by A20,A18,AFINSQ_1:66;
    end;
    suppose
      k = 0;
      then Comput(P3,s3,k) = s3 by EXTPRO_1:2;
      hence IC Comput(P3,s3,k) in dom pIF by A7,COMPOS_1:36;
    end;
  end;
  hence IF is_closed_on s,P by Def2;
A23: Comput(P3,s3,LifeSpan(P1,s1)+1)
 = Comput(P3,Comput(P3,s3,1),LifeSpan(P1,s1)) by EXTPRO_1:4;
  CurInstr(P3,
  Comput(P3,s3,LifeSpan(P1,s1)+1))
   =CurInstr(P3,Comput(P3,s4,LifeSpan(P1,s1))) by A23
    .=CurInstr(P1,Comput(P1,s1,LifeSpan(P1,s1))) by A10,A16,A13,A8,Th45,UU
    .= halt SCMPDS by A14,EXTPRO_1:def 15;
  then P3 halts_on s3 by EXTPRO_1:29;
  hence thesis by Def3;
end;

theorem Th114:
  for s being 0-started State of SCMPDS,I being halt-free shiftable
Program of SCMPDS, J being shiftable Program of SCMPDS,a being Int_position,k1
  being Integer st s.DataLoc(s.a,k1) < 0 & I is_closed_on s,P
   & I is_halting_on s,P
holds IExec(if<0(a,k1,I,J),P,s) = IExec(I,P,s)
 +* Start-At((card I + card J+ 2),SCMPDS)
proof
  let s be 0-started State of SCMPDS,
      I be halt-free shiftable Program of SCMPDS, J be
  shiftable Program of SCMPDS,a be Int_position,k1 be Integer;
  set b=DataLoc(s.a,k1);
  set G=Goto (card J+1);
  set I2 = I ';' G ';' J, IF=if<0(a,k1,I,J), pIF = stop IF,
      pI2=stop I2, P2 = P +* pI2, P3 = P +* pIF,
s4 = Comput(P3,s,1), P4 = P3;
  set i = (a,k1)>=0_goto (card I + 2);
  set SAl= Start-At((card I+card J+2),SCMPDS);
I: Initialize s = s by MEMSTR_0:44;
  then
A3: IC s = 0 by MEMSTR_0:47;
A7: IF = i ';' (I ';' G) ';' J by SCMPDS_4:14
    .= i ';' I2 by SCMPDS_4:14;
  then
A8: Shift(pI2,1) c= P4 by Lm6;
A9: Comput(P3, s,0 + 1) = Following(P3,Comput(P3,s,0)) by EXTPRO_1:3
    .= Following(P3,s) by EXTPRO_1:2
    .= Exec(i,s) by A7,Th22,I;
  assume
  s.b < 0;
  then
A10: IC s4 = succ IC s by A9,SCMPDS_2:57
    .= (0+1) by A3;
  for a holds s.a = s4.a by A9,SCMPDS_2:57;
  then
A12: DataPart s = DataPart s4 by SCMPDS_4:8;
  assume
A13: I is_closed_on s,P;
  assume
A14: I is_halting_on s,P;
  then I2 is_halting_on s,P by A13,Th44;
  then
A15: P2 halts_on s by Def3,I;
  I2 is_closed_on s,P by A13,A14,Th44;
  then
A16: Start-At(0,SCMPDS) c= s & I2 is_closed_on s,P2 by Th38,FUNCT_4:25,I;
UU:  stop I2 c= P2 by FUNCT_4:25;
A18: Comput(P3,s,LifeSpan(P2,s)+1)
 = Comput(P3,Comput(P3,s,1),LifeSpan(P2
,s))
 by EXTPRO_1:4;
A21: CurInstr(P3,Comput(P3,s,LifeSpan(P2,s)+1))
     =CurInstr(P3,Comput(P3,s4,LifeSpan(P2,s))) by A18
    .=CurInstr(P2,Comput(P2,s,LifeSpan(P2,s))) by A16,A8,A10,A12,Th45,UU
    .= halt SCMPDS by A15,EXTPRO_1:def 15;
  then
A22: P3 halts_on s by EXTPRO_1:29;
A23: CurInstr(P3,s) = i by A7,Th22,I;
  now
    let l be Element of NAT;
    assume
A24: l < LifeSpan(P2,s) + 1;
A25: Comput(P3,s,0) = s by EXTPRO_1:2;
    per cases;
    suppose
      l = 0;
      then CurInstr(P3,Comput(P3,s,l))
       = CurInstr(P3,s)
       by A25;
      hence CurInstr(P3,Comput(P3,s,l))
       <> halt SCMPDS by A23;
    end;
    suppose
      l <> 0;
      then consider n be Nat such that
A26:  l = n + 1 by NAT_1:6;
      reconsider n as Element of NAT by ORDINAL1:def 12;
A27:  n < LifeSpan(P2,s) by A24,A26,XREAL_1:6;
      assume
A28:  CurInstr(P3,Comput(P3,s,l)) = halt SCMPDS;
A30: Comput(P3,s,n+1)
 = Comput(P3,Comput(P3,s,1),n) by EXTPRO_1:4;
      CurInstr(P2,Comput(P2,s,n)) =
      CurInstr(P3,Comput(P3,s4,n)) by A16,A8,A10,A12,Th45,UU
        .= halt SCMPDS by A26,A28,A30;
      hence contradiction by A15,A27,EXTPRO_1:def 15;
    end;
  end;
  then for l be Element of NAT st CurInstr(P3,
  Comput(P3,s,l)) = halt SCMPDS
  holds LifeSpan(P2,s) + 1 <= l;
  then
A33: LifeSpan(P3,s) = LifeSpan(P2,s) + 1 by A21,A22,EXTPRO_1:def 15;
A35: DataPart Result(P2,s) = DataPart Comput(P2,s,
LifeSpan(P2,s)) by A15,EXTPRO_1:23
    .= DataPart Comput(P3, s4,LifeSpan(P2,s))
    by A16,A8,A10,A12,Th45,UU
    .= DataPart Comput(P3, s,LifeSpan(P2,s) + 1)
by EXTPRO_1:4
    .= DataPart Result(P3,s) by A22,A33,EXTPRO_1:23;
A36: now
    let x be set;
A37: dom SAl = {IC SCMPDS} by FUNCOP_1:13;
    assume
A38: x in dom IExec(IF,P,s);
    per cases by A38,SCMPDS_4:6;
    suppose
A39:  x is Int_position;
      then x <> IC SCMPDS by SCMPDS_2:43;
      then
A40:  not x in dom SAl by A37,TARSKI:def 1;
      thus IExec(IF,P,s).x = (Result(P3,s)).x
        .= (Result(P2,s)).x by A35,A39,SCMPDS_4:8
        .= IExec(I2,P,s).x
        .= (IExec(I2,P,s) +* SAl).x by A40,FUNCT_4:11;
    end;
    suppose
A42:  x = IC SCMPDS;
A44:  IC Result(P2,s) = IC IExec(I2,P,s)
        .=  (card I + card J + 1) by A13,A14,Th46;
A45:  x in dom SAl by A37,A42,TARSKI:def 1;
      thus IExec(IF,P,s).x = (Result(P3,s)).x
        .= Comput(P3, s,LifeSpan(P2,s) + 1).x by A22,A33,EXTPRO_1:23
        .= IC Comput(P3, s4,LifeSpan(P2,s)) by A42,EXTPRO_1:4
        .= IC Comput(P2, s,LifeSpan(P2,s)) + 1 by A16,A8,A10,A12,Th45,UU
        .= IC Result(P2,s) + 1 by A15,EXTPRO_1:23
        .= IC Start-At ((card I + card J + 1) + 1,SCMPDS)
        by A44,FUNCOP_1:72
        .= (IExec(I2,P,s) +* SAl).x by A42,A45,FUNCT_4:13;
    end;
  end;
  dom IExec(IF,P,s) = the carrier of SCMPDS by PARTFUN1:def 2
    .= dom (IExec(I2,P,s) +* SAl) by PARTFUN1:def 2;
  hence IExec(IF,P,s) = IExec(I2,P,s) +* SAl
            by A36,FUNCT_1:2
    .= IExec(I,P,s) +* Start-At((card I + card J + 1),SCMPDS) +*
    Start-At(
   (card I + card J + 2),SCMPDS) by A13,A14,Th47
    .= IExec(I,P,s) +* SAl by MEMSTR_0:36;
end;

theorem Th115:
  for s being State of SCMPDS,I being Program of SCMPDS,J being
  halt-free shiftable Program of SCMPDS,a being Int_position,k1 being Integer
  st s.DataLoc(s.a,k1) >= 0 & J is_closed_on s,P & J is_halting_on s,P
   holds IExec(if<0(a,k1,I,J),P,Initialize s)
    = IExec(J,P,Initialize s) +* Start-At((card I+card J+2),SCMPDS)
proof
  let s be State of SCMPDS,I be Program of SCMPDS,J be halt-free shiftable
  Program of SCMPDS,a be Int_position,k1 be Integer;
  set b=DataLoc(s.a,k1);
  set pJ=stop J, s1 = Initialize s, P1 = P +* pJ,
  IF=if<0(a,k1,I,J), pIF=
  stop IF, s3 = Initialize s, P3 = P +* pIF,
  s4 = Comput(P3,s3,1), P4 = P3;
  set i = (a,k1)>=0_goto (card I + 2);
  set G =Goto (card J+1), iG=i ';' I ';' G;
  set SAl=Start-At((card I+card J+2),SCMPDS);
A3: IF = i ';' (I ';' G) ';' J by SCMPDS_4:14
    .= i ';' (I ';' G ';' J) by SCMPDS_4:14;
A4: Comput(P3, s3,0 + 1) = Following(P3,Comput(P3,s3,0)) by EXTPRO_1:3
    .= Following(P3,s3) by EXTPRO_1:2
    .= Exec(i,s3) by A3,Th22;
A5: not b in dom Start-At(0,SCMPDS) by SCMPDS_4:18;
  not a in dom Start-At(0,SCMPDS) by SCMPDS_4:18;
  then
A6: s3.DataLoc(s3.a,k1)=s3.b by FUNCT_4:11
    .= s.b by A5,FUNCT_4:11;
A7: IC s3 = 0 by MEMSTR_0:47;
  assume
  s.b >= 0;
  then
A9: IC s4 = ICplusConst(s3,card I + 2) by A4,A6,SCMPDS_2:57
    .= (0+(card I + 2)) by A7,Th23;
  for a holds s1.a = s4.a by A4,SCMPDS_2:57;
  then
A11: DataPart s1 = DataPart s4 by SCMPDS_4:8;
  card iG = card (i ';' I) + card G by AFINSQ_1:17
    .=card (i ';' I) + 1 by COMPOS_1:54
    .=card I +1 +1 by Th15
    .=card I +(1 +1);
  then
A12: Shift(pJ,card I+2) c= pIF by Th24;
  pIF c= P3 by FUNCT_4:25;
  then Shift(pJ,card I+2) c= P3 by A12,XBOOLE_1:1;
  then
A13: Shift(pJ,card I+2) c= P4;
  assume
A14: J is_closed_on s,P;
  then
A15: Start-At(0,SCMPDS) c= s1 & J is_closed_on s1,P1 by Th38,FUNCT_4:25;
UU:  stop J c= P1 by FUNCT_4:25;
  assume
A16: J is_halting_on s,P;
  then
A17: P1 halts_on s1 by Def3;
A19: Comput(P3,s3,LifeSpan(P1,s1)+1)
 = Comput(P3,Comput(P3,s3,1),LifeSpan(P1
,s1))
by EXTPRO_1:4;
A22: CurInstr(P3,Comput(P3,s3,LifeSpan(P1,s1)+1))
     =CurInstr(P3,Comput(P3,s4,LifeSpan(P1,s1))) by A19
    .=CurInstr(P1,Comput(P1,s1,LifeSpan(P1,s1))) by A15,A13,A9,A11,Th45,UU
    .= halt SCMPDS by A17,EXTPRO_1:def 15;
  then
A23: P3 halts_on s3 by EXTPRO_1:29;
A24: CurInstr(P3,s3) = i by A3,Th22;
  now
    let l be Element of NAT;
    assume
A25: l < LifeSpan(P1,s1) + 1;
A26: Comput(P3,s3,0) = s3 by EXTPRO_1:2;
    per cases;
    suppose
      l = 0;
      then CurInstr(P3,Comput(P3,s3,l))
       = CurInstr(P3,s3)
       by A26;
      hence CurInstr(P3,Comput(P3,s3,l))
       <> halt SCMPDS by A24;
    end;
    suppose
      l <> 0;
      then consider n be Nat such that
A27:  l = n + 1 by NAT_1:6;
      reconsider n as Element of NAT by ORDINAL1:def 12;
A28:  n < LifeSpan(P1,s1) by A25,A27,XREAL_1:6;
      assume
A29:  CurInstr(P3,Comput(P3,s3,l)) = halt SCMPDS;
A31: Comput(P3,s3,n+1)
 = Comput(P3,Comput(P3,s3,1),n) by EXTPRO_1:4;
      CurInstr(P1,Comput(P1,s1,n))
       = CurInstr(P3,
      Comput(P3,s4,n)) by A15,A13,A9,A11,Th45,UU
        .= halt SCMPDS by A27,A29,A31;
      hence contradiction by A17,A28,EXTPRO_1:def 15;
    end;
  end;
  then for l be Element of NAT st CurInstr(P3,
  Comput(P3,s3,l)) = halt SCMPDS
  holds LifeSpan(P1,s1) + 1 <= l;
  then
A34: LifeSpan(P3,s3) = LifeSpan(P1,s1) + 1 by A22,A23,EXTPRO_1:def 15;
A36: DataPart Result(P1,s1) = DataPart Comput(P1, s1
,LifeSpan(P1,s1)) by A17,EXTPRO_1:23
    .= DataPart Comput(P3, s4,LifeSpan(P1,s1))
    by A15,A13,A9,A11,Th45,UU
    .= DataPart Comput(P3, s3,LifeSpan(P1,s1) + 1)
by EXTPRO_1:4
    .= DataPart Result(P3,s3) by A23,A34,EXTPRO_1:23;
A37: now
    let x be set;
A38: dom SAl = {IC SCMPDS} by FUNCOP_1:13;
    assume
A39: x in dom IExec(IF,P,Initialize s);
    per cases by A39,SCMPDS_4:6;
    suppose
A40:  x is Int_position;
      then x <> IC SCMPDS by SCMPDS_2:43;
      then
A41:  not x in dom SAl by A38,TARSKI:def 1;
      thus IExec(IF,P,Initialize s).x = (Result(P3,s3)).x
        .= (Result(P1,s1)).x by A36,A40,SCMPDS_4:8
        .= IExec(J,P,Initialize s).x
        .= (IExec(J,P,Initialize s) +* SAl).x by A41,FUNCT_4:11;
    end;
    suppose
A43:  x = IC SCMPDS;
A45:  IC Result(P1,s1) = IC IExec(J,P,Initialize s)
        .=  (card J) by A14,A16,Th48;
A46:  x in dom SAl by A38,A43,TARSKI:def 1;
      thus IExec(IF,P,Initialize s).x = (Result(P3,s3)).x
        .= Comput(P3, s3,LifeSpan(P1,s1) + 1).x by A23,A34,EXTPRO_1:23
        .= IC Comput(P3, s4,LifeSpan(P1,s1)) by A43,EXTPRO_1:4
        .= IC Comput(P1, s1,LifeSpan(P1,s1)) + (card
I + 2) by A15,A13,A9,A11,Th45,UU
        .= IC Result(P1,s1) + (card I + 2) by A17,EXTPRO_1:23
        .= IC Start-At (card J + (card I + 2),SCMPDS) by A45,FUNCOP_1:72
        .= (IExec(J,P,Initialize s) +* SAl).x by A43,A46,FUNCT_4:13;
    end;
  end;
  dom IExec(IF,P,Initialize s) = the carrier of SCMPDS by PARTFUN1:def 2
    .= dom (IExec(J,P,Initialize s) +* SAl) by PARTFUN1:def 2;
  hence thesis by A37,FUNCT_1:2;
end;

registration
  let I,J be shiftable parahalting Program of SCMPDS, a be Int_position,k1 be
  Integer;
  cluster if<0(a,k1,I,J) -> shiftable parahalting;
  correctness
  proof
    set i = (a,k1)>=0_goto (card I + 2), G =Goto (card J+1);
    set IF=if<0(a,k1,I,J), pIF = stop IF;
    reconsider IJ=I ';' G ';' J as shiftable Program of SCMPDS;
    thus IF is shiftable;
      let s be 0-started State of SCMPDS;
      let P be Instruction-Sequence of SCMPDS;
A1:  Initialize s = s by MEMSTR_0:44;
      assume pIF c= P;
      then
A2:   P = P +* stop IF by FUNCT_4:98;
A3:   J is_closed_on s,P & J is_halting_on s,P by Th34,Th35;
A4:   I is_closed_on s,P & I is_halting_on s,P by Th34,Th35;
      per cases;
      suppose
        s.DataLoc(s.a,k1) < 0;
        then IF is_halting_on s,P by A4,Th112;
        hence P halts_on s by A2,Def3,A1;
      end;
      suppose
        s.DataLoc(s.a,k1) >= 0;
        then IF is_halting_on s,P by A3,Th113;
        hence P halts_on s by A2,Def3,A1;
      end;
  end;
end;

registration
  let I,J be halt-free Program of SCMPDS, a be Int_position,k1 be Integer;
  cluster if<0(a,k1,I,J) -> halt-free;
  coherence;
end;

theorem
  for s being 0-started State of SCMPDS,I,J being halt-free shiftable
  parahalting Program of SCMPDS,a being Int_position,k1 being Integer holds IC
  IExec(if<0(a,k1,I,J),P,s) = card I + card J + 2
proof
  let s be 0-started State of SCMPDS,
      I,J be halt-free shiftable parahalting Program of
  SCMPDS,a be Int_position,k1 be Integer;
  set IF=if<0(a,k1,I,J);
A1: I is_closed_on s,P & I is_halting_on s,P by Th34,Th35;
A2: J is_closed_on s,P & J is_halting_on s,P by Th34,Th35;
I: Initialize s = s by MEMSTR_0:44;
  per cases;
  suppose
    s.DataLoc(s.a,k1) < 0;
    then IExec(IF,P,s) = IExec(I,P,s) +* Start-At((card I+card J+2),SCMPDS)
    by A1,Th114;
    hence thesis by FUNCT_4:113;
  end;
  suppose
    s.DataLoc(s.a,k1) >= 0;
    then IExec(IF,P,s) = IExec(J,P,s) +* Start-At((card I+card J+2),SCMPDS)
    by A2,Th115,I;
    hence thesis by FUNCT_4:113;
  end;
end;

theorem
  for s being 0-started State of SCMPDS,I being halt-free shiftable parahalting
  Program of SCMPDS,J being shiftable Program of SCMPDS,a,b being Int_position,
k1 being Integer st s.DataLoc(s.a,k1)<0
 holds IExec(if<0(a,k1,I,J),P,s).b
 = IExec(I,P,s).b
proof
  let s be 0-started State of SCMPDS,
      I be halt-free shiftable parahalting Program of
  SCMPDS,J be shiftable Program of SCMPDS,a,b be Int_position, k1 be Integer;
  assume
A1: s.DataLoc(s.a,k1)<0;
A2: not b in dom Start-At((card I+card J+2),SCMPDS) by SCMPDS_4:18;
  I is_closed_on s,P & I is_halting_on s,P by Th34,Th35;
  then
  IExec(if<0(a,k1,I,J),P,s) = IExec(I,P,s)
   +* Start-At((card I + card J + 2),SCMPDS) by A1,Th114;
  hence thesis by A2,FUNCT_4:11;
end;

theorem
  for s being State of SCMPDS,I being Program of SCMPDS,J being
  halt-free parahalting shiftable Program of SCMPDS,a,b being Int_position,k1
being Integer st s.DataLoc(s.a,k1) >= 0
 holds IExec(if<0(a,k1,I,J),P,Initialize s).b = IExec(J,P,Initialize s).b
proof
  let s be State of SCMPDS,I be Program of SCMPDS,J be halt-free parahalting
  shiftable Program of SCMPDS,a,b be Int_position, k1 be Integer;
  set IF=if<0(a,k1,I,J);
  assume
A1: s.DataLoc(s.a,k1) >= 0;
A2: not b in dom Start-At((card I+card J+2),SCMPDS) by SCMPDS_4:18;
  J is_closed_on s,P & J is_halting_on s,P by Th34,Th35;
  then IExec(IF,P,Initialize s) =IExec(J,P,Initialize s)
   +* Start-At((card I+card J+2),SCMPDS)
  by A1,Th115;
  hence thesis by A2,FUNCT_4:11;
end;

begin :: The computation of "if var<0 then block"

theorem
  card if<0(a,k1,I) = card I + 1 by Th15;

theorem
   0 in dom if<0(a,k1,I)
proof
  set ci=card if<0(a,k1,I);
  ci=card I + 1 by Th15;
  hence thesis by AFINSQ_1:66;
end;

theorem
  if<0(a,k1,I). 0 = (a,k1)>=0_goto (card I + 1) by Th16;

theorem Th122:
  for s being State of SCMPDS, I being shiftable Program of
  SCMPDS, a being Int_position,k1 being Integer st s.DataLoc(s.a,k1) < 0 & I
is_closed_on s,P & I is_halting_on s,P holds if<0(a,k1,I) is_closed_on s,P
 & if<0(a,
  k1,I) is_halting_on s,P
proof
  let s be State of SCMPDS, I be shiftable Program of SCMPDS, a be
  Int_position,k1 be Integer;
  set b=DataLoc(s.a,k1);
  set IF=if<0(a,k1,I), pIF=stop IF, pI=stop I,
   s2 = Initialize s, s3 = Initialize s,
   P2 = P +* pI, P3 = P +* pIF,
   s4 = Comput(P3,s3,1), P4 = P3;
  set i = (a,k1)>=0_goto (card I + 1);
UU:  stop I c= P2 by FUNCT_4:25;
A3:  0 in dom pIF by COMPOS_1:36;
A4: IC s3 = 0 by MEMSTR_0:47;
A5: not b in dom Start-At(0,SCMPDS) by SCMPDS_4:18;
  not a in dom Start-At(0,SCMPDS) by SCMPDS_4:18;
  then
A6: s3.DataLoc(s3.a,k1)=s3.b by FUNCT_4:11
    .= s.b by A5,FUNCT_4:11;
A7: Comput(P3, s3,0 + 1) = Following(P3,Comput(P3,s3,0)) by EXTPRO_1:3
    .= Following(P3,s3) by EXTPRO_1:2
    .= Exec(i,s3) by Th22;
  for a holds s2.a = s4.a by A7,SCMPDS_2:57;
  then
A9: DataPart s2 = DataPart s4 by SCMPDS_4:8;
  assume
  s.b < 0;
  then
A10: IC s4 = succ IC s3 by A7,A6,SCMPDS_2:57
    .= (0+1) by A4;
  assume
A11: I is_closed_on s,P;
  then
A12: I is_closed_on s2,P2 by Th38;
  assume
  I is_halting_on s,P;
  then
A13: P2 halts_on s2 by Def3;
A14: Start-At(0,SCMPDS) c= s2 & Shift(pI,1) c= P4 by Lm6,FUNCT_4:25;
A15: card pIF = card IF +1 by COMPOS_1:55
    .= card I +1+1 by Th15;
  now
    let k be Element of NAT;
    per cases;
    suppose
      0 < k;
      then consider k1 being Nat such that
A16:  k1 + 1 = k by NAT_1:6;
      reconsider k1 as Element of NAT by ORDINAL1:def 12;
      reconsider m = IC Comput(P2, s2,k1) as Element of NAT;
A17:  card pIF = card pI+1 by A15,COMPOS_1:55;
       m in dom pI by A11,Def2;
      then m < card pI by AFINSQ_1:66;
      then
A18:  m+1 < card pIF by A17,XREAL_1:6;
      IC Comput(P3,s3,k) = IC Comput(P3, s4,k1) by A16,EXTPRO_1:4
        .=  (m + 1) by A12,A14,A10,A9,Th45,UU;
      hence IC Comput(P3,s3,k) in dom pIF by A18,AFINSQ_1:66;
    end;
    suppose
      k = 0;
      hence IC Comput(P3,s3,k) in dom pIF by A3,A4,EXTPRO_1:2;
    end;
  end;
  hence IF is_closed_on s,P by Def2;
A21: Comput(P3,s3,LifeSpan(P2,s2)+1)
 = Comput(P3,Comput(P3,s3,1),LifeSpan(P2
,s2))
by EXTPRO_1:4;
  CurInstr(P3,
  Comput(P3,s3,LifeSpan(P2,s2)+1))
   =CurInstr(P3,
   Comput(P3,s4,LifeSpan(P2,s2))) by A21
    .=CurInstr(P2,
    Comput(P2,s2,LifeSpan(P2,s2))) by A12,A14,A10,A9,Th45,UU
    .= halt SCMPDS by A13,EXTPRO_1:def 15;
  then P3 halts_on s3 by EXTPRO_1:29;
  hence thesis by Def3;
end;

theorem Th123:
  for s being State of SCMPDS,I being Program of SCMPDS, a being
  Int_position, k1 being Integer st s.DataLoc(s.a,k1) >= 0 holds if<0(a,k1,I)
  is_closed_on s,P & if<0(a,k1,I) is_halting_on s,P
proof
  let s be State of SCMPDS,I be Program of SCMPDS, a be Int_position,k1 be
  Integer;
  set b=DataLoc(s.a,k1);
  assume
A1: s.b >= 0;
  set i = (a,k1)>=0_goto (card I + 1);
  set IF=if<0(a,k1,I), pIF=stop IF, s3 = Initialize s,
  P3 = P +* pIF,
  s4 = Comput(P3,s3,1), P4 = P3;
A3: IC s3 = 0 by MEMSTR_0:47;
A4: not b in dom Start-At(0,SCMPDS) by SCMPDS_4:18;
  not a in dom Start-At(0,SCMPDS) by SCMPDS_4:18;
  then
A5: s3.DataLoc(s3.a,k1)=s3.b by FUNCT_4:11
    .= s.b by A4,FUNCT_4:11;
  Comput(P3, s3,0 + 1) = Following(P3,Comput(P3,s3,0)) by EXTPRO_1:3
    .= Following(P3,s3) by EXTPRO_1:2
    .= Exec(i,s3) by Th22;
  then
A6: IC s4 = ICplusConst(s3,card I + 1) by A1,A5,SCMPDS_2:57
    .= (0+(card I + 1)) by A3,Th23;
A7: card IF=card I+1 by Th15;
  then
A8: (card I+1) in dom pIF by COMPOS_1:64;
A9:  P3/.IC s4
 = P3.IC s4 by PBOOLE:143;
  pIF c= P3 by FUNCT_4:25;
  then pIF c= P4;
  then P4.(card I+1) = pIF.(card I+1) by A8,GRFUNC_1:2
    .=halt SCMPDS by A7,COMPOS_1:64;
  then
A11: CurInstr(P3,s4) = halt SCMPDS by A6,A9;
  now
    let k be Element of NAT;
    per cases;
    suppose
      0 < k;
      then 1+0 <= k by INT_1:7;
      hence IC Comput(P3,s3,k) in dom pIF by A8,A6,A11,EXTPRO_1:5;
    end;
    suppose
      k = 0;
      then Comput(P3,s3,k) = s3 by EXTPRO_1:2;
      hence IC Comput(P3,s3,k) in dom pIF by A3,COMPOS_1:36;
    end;
  end;
  hence IF is_closed_on s,P by Def2;
  P3 halts_on s3 by A11,EXTPRO_1:29;
  hence thesis by Def3;
end;

theorem Th124:
  for s being State of SCMPDS,I being halt-free shiftable
Program of SCMPDS, a being Int_position,k1 being Integer st s.DataLoc(s.a,k1) <
0 & I is_closed_on s,P & I is_halting_on s,P
 holds IExec(if<0(a,k1,I),P,Initialize s) = IExec(I,P,Initialize s)
  +* Start-At((card I+1),SCMPDS)
proof
  let s be State of SCMPDS,I be halt-free shiftable Program of SCMPDS, a be
  Int_position,k1 be Integer;
  set b=DataLoc(s.a,k1);
  set IF=if<0(a,k1,I), pIF = stop IF, pI=stop I,
   s2 = Initialize s, s3 = Initialize s,
   P2 = P +* pI, P3 = P +* pIF,
   s4 = Comput(P3, s3,1), P4 = P3;
  set i = (a,k1)>=0_goto (card I + 1);
  set SAl=Start-At((card I+1),SCMPDS);
UU:  stop I c= P2 by FUNCT_4:25;
A3: IC s3 = 0 by MEMSTR_0:47;
A4: not b in dom Start-At(0,SCMPDS) by SCMPDS_4:18;
  not a in dom Start-At(0,SCMPDS) by SCMPDS_4:18;
  then
A5: s3.DataLoc(s3.a,k1)=s3.b by FUNCT_4:11
    .= s.b by A4,FUNCT_4:11;
A6: Comput(P3, s3,0 + 1) = Following(P3,Comput(P3,s3,0)) by EXTPRO_1:3
    .= Following(P3,s3) by EXTPRO_1:2
    .= Exec(i,s3) by Th22;
  assume
  s.b < 0;
  then
A7: IC s4 = succ IC s3 by A6,A5,SCMPDS_2:57
    .= (0+1) by A3;
  for a holds s2.a = s4.a by A6,SCMPDS_2:57;
  then
A9: DataPart s2 = DataPart s4 by SCMPDS_4:8;
  assume
A10: I is_closed_on s,P;
  then
A11: I is_closed_on s2,P2 by Th38;
A13: Start-At(0,SCMPDS) c= s2 & Shift(pI,1) c= P4 by Lm6,FUNCT_4:25;
  assume
A14: I is_halting_on s,P;
  then
A15: P2 halts_on s2 by Def3;
A17: Comput(P3,s3,LifeSpan(P2,s2)+1)
= Comput(P3,Comput(P3,s3,1),LifeSpan(P2,
s2))
 by EXTPRO_1:4;
A20: CurInstr(P3,
Comput(P3,s3,LifeSpan(P2,s2)+1))
 =CurInstr(P3,
 Comput(P3,s4,LifeSpan(P2,s2))) by A17
    .=CurInstr(P2,
    Comput(P2,s2,LifeSpan(P2,s2))) by A11,A13,A7,A9,Th45,UU
    .= halt SCMPDS by A15,EXTPRO_1:def 15;
  then
A21: P3 halts_on s3 by EXTPRO_1:29;
A22: CurInstr(P3,s3) = i by Th22;
  now
    let l be Element of NAT;
    assume
A23: l < LifeSpan(P2,s2) + 1;
A24: Comput(P3,s3,0) = s3 by EXTPRO_1:2;
    per cases;
    suppose
      l = 0;
      then CurInstr(P3,Comput(P3,s3,l))
       = CurInstr(P3,s3)
       by A24;
      hence CurInstr(P3,Comput(P3,s3,l))
       <> halt SCMPDS by A22;
    end;
    suppose
      l <> 0;
      then consider n be Nat such that
A25:  l = n + 1 by NAT_1:6;
      reconsider n as Element of NAT by ORDINAL1:def 12;
A26:  n < LifeSpan(P2,s2) by A23,A25,XREAL_1:6;
      assume
A27:  CurInstr(P3,Comput(P3,s3,l)) = halt SCMPDS;
A29: Comput(P3,s3,n+1)
 = Comput(P3,Comput(P3,s3,1),n) by EXTPRO_1:4;
      CurInstr(P2,Comput(P2,s2,n)) =
      CurInstr(P3,Comput(P3,s4,n)) by A11,A13,A7,A9,Th45,UU
        .= halt SCMPDS by A25,A27,A29;
      hence contradiction by A15,A26,EXTPRO_1:def 15;
    end;
  end;
  then for l be Element of NAT st CurInstr(P3,
  Comput(P3,s3,l)) = halt SCMPDS
  holds LifeSpan(P2,s2) + 1 <= l;
  then
A32: LifeSpan(P3,s3) = LifeSpan(P2,s2) + 1 by A20,A21,EXTPRO_1:def 15;
A34: DataPart Result(P2,s2) = DataPart Comput(P2,s2,
LifeSpan(P2,s2)) by A15,EXTPRO_1:23
    .= DataPart Comput(P3, s4,LifeSpan(P2,s2)) by A11,A13,A7,A9,Th45,UU
    .= DataPart Comput(P3, s3,LifeSpan(P2,s2) + 1)
by EXTPRO_1:4
    .= DataPart Result(P3,s3) by A21,A32,EXTPRO_1:23;
A35: now
    let x be set;
A36: dom SAl = {IC SCMPDS} by FUNCOP_1:13;
    assume
A37: x in dom IExec(IF,P,Initialize s);
    per cases by A37,SCMPDS_4:6;
    suppose
A38:  x is Int_position;
      then x <> IC SCMPDS by SCMPDS_2:43;
      then
A39:  not x in dom SAl by A36,TARSKI:def 1;
      thus IExec(IF,P,Initialize s).x = (Result(P3,s3)).x
        .= (Result(P2,s2)).x by A34,A38,SCMPDS_4:8
        .= IExec(I,P,Initialize s).x
        .= (IExec(I,P,Initialize s) +* SAl).x by A39,FUNCT_4:11;
    end;
    suppose
A41:  x = IC SCMPDS;
A43:  IC Result(P2,s2) = IC IExec(I,P,Initialize s)
        .=  card I by A10,A14,Th48;
A44:  x in dom SAl by A36,A41,TARSKI:def 1;
      thus IExec(IF,P,Initialize s).x = (Result(P3,s3)).x
        .= Comput(P3, s3,LifeSpan(P2,s2) + 1).x by A21,A32,EXTPRO_1:23
        .= IC Comput(P3, s4,LifeSpan(P2,s2)) by A41,EXTPRO_1:4
        .= IC Comput(P2, s2,LifeSpan(P2,s2)) + 1
        by A11,A13,A7,A9,Th45,UU
        .= IC Result(P2,s2) + 1 by A15,EXTPRO_1:23
        .= IC SAl by A43,FUNCOP_1:72
        .= (IExec(I,P,Initialize s) +* SAl).x by A41,A44,FUNCT_4:13;
    end;
  end;
  dom IExec(IF,P,Initialize s) = the carrier of SCMPDS by PARTFUN1:def 2
    .= dom (IExec(I,P,Initialize s) +* SAl) by PARTFUN1:def 2;
  hence thesis by A35,FUNCT_1:2;
end;

theorem Th125:
  for s being State of SCMPDS,I being Program of SCMPDS,a being
Int_position, k1 being Integer st s.DataLoc(s.a,k1) >= 0
 holds IExec(if<0(a,k1,I),P,Initialize s) = s +* Start-At((card I+1),SCMPDS)
proof
  let s be State of SCMPDS,I be Program of SCMPDS,a be Int_position, k1 be
  Integer;
  set b=DataLoc(s.a,k1);
  set IF=if<0(a,k1,I), pIF=stop IF, s3 = Initialize s,
  P3 = P +* pIF,
  s4 = Comput(P3, s3,1), P4 = P3;
  set i = (a,k1)>=0_goto (card I + 1);
  set SAl=Start-At((card I+1),SCMPDS);
A2: IC s3 = 0 by MEMSTR_0:47;
A3: not b in dom Start-At(0,SCMPDS) by SCMPDS_4:18;
  not a in dom Start-At(0,SCMPDS) by SCMPDS_4:18;
  then
A4: s3.DataLoc(s3.a,k1)=s3.b by FUNCT_4:11
    .= s.b by A3,FUNCT_4:11;
A5: Comput(P3, s3,0 + 1) = Following(P3,Comput(P3,s3,0)) by EXTPRO_1:3
    .= Following(P3,s3) by EXTPRO_1:2
    .= Exec(i,s3) by Th22;
  assume
  s.b >= 0;
  then
A6: IC s4 = ICplusConst(s3,card I + 1) by A5,A4,SCMPDS_2:57
    .= (0+(card I + 1)) by A2,Th23;
  pIF c= P3 by FUNCT_4:25;
  then
A7: pIF c= P4;
A8:  P3/.IC s4
 = P3.IC s4 by PBOOLE:143;
A10: card IF=card I+1 by Th15;
  then (card I+1) in dom pIF by COMPOS_1:64;
  then P4.(card I+1) = pIF.(card I+1) by A7,GRFUNC_1:2
    .=halt SCMPDS by A10,COMPOS_1:64;
  then
A11: CurInstr(P3,s4) = halt SCMPDS by A6,A8;
  then
A12: P3 halts_on s3 by EXTPRO_1:29;
A13: CurInstr(P3,s3) = i by Th22;
  now
    let l be Element of NAT;
A14: Comput(P3,s3,0) = s3 by EXTPRO_1:2;
    assume
    l < 1;
    then l <1+0;
    then l=0 by NAT_1:13;
    then CurInstr(P3,Comput(P3,s3,l))
     = CurInstr(P3,s3) by A14;
    hence CurInstr(P3,Comput(P3,s3,l))
     <> halt SCMPDS by A13;
  end;
  then for l be Element of NAT st CurInstr(P3,
  Comput(P3,s3,l)) = halt SCMPDS
  holds 1 <= l;
  then LifeSpan(P3,s3) = 1 by A11,A12,EXTPRO_1:def 15;
  then
A15: s4 = Result(P3,s3) by A12,EXTPRO_1:23;
A17: now
A18: dom SAl = {IC SCMPDS} by FUNCOP_1:13;
    let x be set;
    assume
A19: x in dom IExec(IF,P,Initialize s);
    per cases by A19,SCMPDS_4:6;
    suppose
A20:  x is Int_position;
      then x <> IC SCMPDS by SCMPDS_2:43;
      then
A21:  not x in dom SAl by A18,TARSKI:def 1;
TT:   not x in dom Start-At(0,SCMPDS) by A20,SCMPDS_4:18;
      thus IExec(IF,P,Initialize s).x = s4.x by A15
        .= s3.x by A5,A20,SCMPDS_2:57
        .= s.x by TT,FUNCT_4:11
        .= (s +* SAl).x by A21,FUNCT_4:11;
    end;
    suppose
A22:  x = IC SCMPDS;
      hence IExec(IF,P,Initialize s).x = (card I + 1) by A6,A15
        .= (s +* SAl).x by A22,FUNCT_4:113;
    end;
  end;
  dom IExec(IF,P,Initialize s) = the carrier of SCMPDS by PARTFUN1:def 2
    .= dom (s +* SAl) by PARTFUN1:def 2;
  hence thesis by A17,FUNCT_1:2;
end;

registration
  let I be shiftable parahalting Program of SCMPDS, a be Int_position,k1 be
  Integer;
  cluster if<0(a,k1,I) -> shiftable parahalting;
  correctness
  proof
    set i = (a,k1)>=0_goto (card I +1);
    set IF=if<0(a,k1,I), pIF = stop IF;
    thus IF is shiftable;
      let s be 0-started State of SCMPDS;
      let P be Instruction-Sequence of SCMPDS;
A1:  Initialize s = s by MEMSTR_0:44;
      assume pIF c= P;
      then
A2:   P = P +* stop IF by FUNCT_4:98;
A3:   I is_closed_on s,P & I is_halting_on s,P by Th34,Th35;
      per cases;
      suppose
        s.DataLoc(s.a,k1) < 0;
        then IF is_halting_on s,P by A3,Th122;
        hence P halts_on s by A2,Def3,A1;
      end;
      suppose
        s.DataLoc(s.a,k1) >= 0;
        then IF is_halting_on s,P by Th123;
        hence P halts_on s by A2,Def3,A1;
      end;
  end;
end;

registration
  let I be halt-free Program of SCMPDS, a be Int_position,k1 be Integer;
  cluster if<0(a,k1,I) -> halt-free;
  coherence;
end;

theorem
  for s being State of SCMPDS,I being halt-free shiftable parahalting
Program of SCMPDS,a being Int_position,k1 being Integer
 holds IC IExec(if<0(a,k1,I),P,Initialize s) = card I + 1
proof
  let s be State of SCMPDS,I be halt-free shiftable parahalting Program of
  SCMPDS,a be Int_position,k1 be Integer;
  set IF=if<0(a,k1,I);
A1: I is_closed_on s,P & I is_halting_on s,P by Th34,Th35;
  per cases;
  suppose
    s.DataLoc(s.a,k1) < 0;
    then IExec(IF,P,Initialize s) =IExec(I,P,Initialize s)
     +* Start-At((card I+1),SCMPDS)
    by A1,Th124;
    hence thesis by FUNCT_4:113;
  end;
  suppose
    s.DataLoc(s.a,k1) >= 0;
    then IExec(IF,P,Initialize s) =s +* Start-At((card I+1),SCMPDS) by Th125;
    hence thesis by FUNCT_4:113;
  end;
end;

theorem
  for s being State of SCMPDS,I being halt-free shiftable parahalting
Program of SCMPDS,a,b being Int_position,k1 being Integer st s.DataLoc(s.a,k1)
  < 0 holds IExec(if<0(a,k1,I),P,Initialize s).b = IExec(I,P,Initialize s).b
proof
  let s be State of SCMPDS,I be halt-free shiftable parahalting Program of
  SCMPDS,a,b be Int_position,k1 be Integer;
  assume
A1: s.DataLoc(s.a,k1) < 0;
A2: not b in dom Start-At((card I+1),SCMPDS) by SCMPDS_4:18;
  I is_closed_on s,P & I is_halting_on s,P by Th34,Th35;
  then IExec(if<0(a,k1,I),P,Initialize s) = IExec(I,P,Initialize s)
   +* Start-At((card I+1),SCMPDS)
  by A1,Th124;
  hence thesis by A2,FUNCT_4:11;
end;

theorem
  for s being State of SCMPDS,I being Program of SCMPDS,a,b being
Int_position, k1 being Integer st s.DataLoc(s.a,k1) >= 0
 holds IExec(if<0(a,k1,I),P,Initialize s).b = s.b
proof
  let s be State of SCMPDS,I be Program of SCMPDS,a,b be Int_position, k1 be
  Integer;
  assume
  s.DataLoc(s.a,k1) >= 0;
  then
A1: IExec(if<0(a,k1,I),P,Initialize s) = s +* Start-At((card I+1),SCMPDS)
      by Th125;
  not b in dom Start-At((card I+1),SCMPDS) by SCMPDS_4:18;
  hence thesis by A1,FUNCT_4:11;
end;

begin :: The computation of "if var>=0 then block"

theorem
  card if>=0(a,k1,I) = card I + 2 by Lm8;

theorem
   0 in dom if>=0(a,k1,I) &  1 in dom if>=0(a,k1,I) by Lm9;

theorem
  if>=0(a,k1,I). 0 = (a,k1)>=0_goto 2 & if>=0(a,k1,I). 1 =
  goto (card I + 1) by Lm10;

theorem Th132:
  for s being State of SCMPDS, I being shiftable Program of
  SCMPDS, a being Int_position,k1 being Integer st s.DataLoc(s.a,k1) >= 0 & I
is_closed_on s,P & I is_halting_on s,P holds if>=0(a,k1,I) is_closed_on s,P
 & if>=0(a
  ,k1,I) is_halting_on s,P
proof
  let s be State of SCMPDS, I be shiftable Program of SCMPDS, a be
  Int_position,k1 be Integer;
  set b=DataLoc(s.a,k1);
  set IF=if>=0(a,k1,I), pIF=stop IF, pI=stop I,
   s2 = Initialize s, s3 = Initialize s,
   P2 = P +* pI, P3 = P +* pIF,
   s4 = Comput(P3,s3,1), P4 = P3;
  set i = (a,k1)>=0_goto 2, j = goto (card I + 1);
UU:  stop I c= P2 by FUNCT_4:25;
A3: IF = i ';' (j ';' I) by SCMPDS_4:16;
A4: Comput(P3, s3,0 + 1) = Following(P3,Comput(P3,s3,0)) by EXTPRO_1:3
    .= Following(P3,s3) by EXTPRO_1:2
    .= Exec(i,s3) by A3,Th22;
  for a holds s2.a = s4.a by A4,SCMPDS_2:57;
  then
A6: DataPart s2 = DataPart s4 by SCMPDS_4:8;
A7: not b in dom Start-At(0,SCMPDS) by SCMPDS_4:18;
  not a in dom Start-At(0,SCMPDS) by SCMPDS_4:18;
  then
A8: s3.DataLoc(s3.a,k1)=s3.b by FUNCT_4:11
    .= s.b by A7,FUNCT_4:11;
A9: IC s3 = 0 by MEMSTR_0:47;
  assume
  s.b >= 0;
  then
A10: IC s4 = ICplusConst(s3,2) by A4,A8,SCMPDS_2:57
    .= (0+2) by A9,Th23;
  assume
A11: I is_closed_on s,P;
  then
A12: I is_closed_on s2,P2 by Th38;
  assume
  I is_halting_on s,P;
  then
A13: P2 halts_on s2 by Def3;
A14: Start-At(0,SCMPDS) c= s2 & Shift(pI,2) c= P4 by Lm7,FUNCT_4:25;
A15:  0 in dom pIF by COMPOS_1:36;
  now
    let k be Element of NAT;
    per cases;
    suppose
      0 < k;
      then consider k1 being Nat such that
A16:  k1 + 1 = k by NAT_1:6;
      reconsider k1 as Element of NAT by ORDINAL1:def 12;
      reconsider m = IC Comput(P2, s2,k1) as Element of NAT;
A17:  card pIF = 1+ card IF by COMPOS_1:55
        .= 1+(card I +2) by Lm8
        .= 1+card I +2
        .=card pI+2 by COMPOS_1:55;
       m in dom pI by A11,Def2;
      then m < card pI by AFINSQ_1:66;
      then
A18:  m+2 < card pIF by A17,XREAL_1:6;
      IC Comput(P3,s3,k) = IC Comput(P3, s4,k1) by A16,EXTPRO_1:4
        .=  (m + 2) by A12,A14,A10,A6,Th45,UU;
      hence IC Comput(P3,s3,k) in dom pIF by A18,AFINSQ_1:66;
    end;
    suppose
      k = 0;
      hence IC Comput(P3,s3,k) in dom pIF by A15,A9,EXTPRO_1:2;
    end;
  end;
  hence IF is_closed_on s,P by Def2;
A21: Comput(P3,s3,LifeSpan(P2,s2)+1)
 = Comput(P3,Comput(P3,s3,1),LifeSpan(P2
,s2))
by EXTPRO_1:4;
  CurInstr(P3,
  Comput(P3,s3,LifeSpan(P2,s2)+1))
   =CurInstr(P3,
   Comput(P3,s4,LifeSpan(P2,s2))) by A21
    .=CurInstr(P2,
    Comput(P2,s2,LifeSpan(P2,s2))) by A12,A14,A10,A6,Th45,UU
    .= halt SCMPDS by A13,EXTPRO_1:def 15;
  then P3 halts_on s3 by EXTPRO_1:29;
  hence thesis by Def3;
end;

theorem Th133:
  for s being State of SCMPDS,I being Program of SCMPDS, a being
  Int_position, k1 being Integer st s.DataLoc(s.a,k1) < 0 holds if>=0(a,k1,I)
  is_closed_on s,P & if>=0(a,k1,I) is_halting_on s,P
proof
  let s be State of SCMPDS,I be Program of SCMPDS, a be Int_position,k1 be
  Integer;
  set b=DataLoc(s.a,k1);
  assume
A1: s.b < 0;
  set i = (a,k1)>=0_goto 2, j = goto (card I + 1);
  set IF=if>=0(a,k1,I), pIF=stop IF, s3 = Initialize s,
  P3 = P +* pIF,
  s4 = Comput(P3,s3,1), s5 = Comput(P3,s3,2), P4 = P3, P5 = P3;
A3: IF =i ';' (j ';' I) by SCMPDS_4:16;
A4: not b in dom Start-At(0,SCMPDS) by SCMPDS_4:18;
  not a in dom Start-At(0,SCMPDS) by SCMPDS_4:18;
  then
A5: s3.DataLoc(s3.a,k1)=s3.b by FUNCT_4:11
    .= s.b by A4,FUNCT_4:11;
A6: IC s3 = 0 by MEMSTR_0:47;
  Comput(P3, s3,0 + 1) = Following(P3,Comput(P3,s3,0)) by EXTPRO_1:3
    .= Following(P3,s3) by EXTPRO_1:2
    .= Exec(i,s3) by A3,Th22;
  then
A7: IC s4 = succ IC s3 by A1,A5,SCMPDS_2:57
    .= (0+1) by A6;
A8: pIF c= P3 by FUNCT_4:25;
  then
A9: pIF c= P4;
A10:  1 in dom IF by Lm9;
  then  1 in dom pIF by COMPOS_1:62;
  then
A11: P4.1 = pIF. 1 by A9,GRFUNC_1:2
    .=IF. 1 by A10,COMPOS_1:63
    .=j by Lm10;
A12: card IF=card I+2 by Lm8;
  then
A13: (card I+2) in dom pIF by COMPOS_1:64;
A14:  P3/.IC s4 = P3.IC s4 by PBOOLE:143;
  Comput(P3, s3,1 + 1) = Following(P3,s4) by EXTPRO_1:3
    .= Exec(j,s4) by A7,A11,A14;
  then
A16: IC s5 = ICplusConst(s4,card I+1) by SCMPDS_2:54
    .= (card I+1+1) by A7,Th23
    .= (card I+(1+1));
A17:  (P3)/.IC s5
 = P3.IC s5 by PBOOLE:143;
  pIF c= P5 by A8;
  then P5.(card I+2) = pIF.(card I+2) by A13,GRFUNC_1:2
    .=halt SCMPDS by A12,COMPOS_1:64;
  then
A19: CurInstr(P3,s5) = halt SCMPDS by A16,A17;
  now
    let k be Element of NAT;
A20: k = 0 or 0 + 1 <= k by INT_1:7;
    per cases by A20,XXREAL_0:1;
    suppose
      k = 0;
      then Comput(P3,s3,k) = s3 by EXTPRO_1:2;
      hence IC Comput(P3,s3,k) in dom pIF by A6,COMPOS_1:36;
    end;
    suppose
      k = 1;
      hence IC Comput(P3,s3,k) in dom pIF by A10,A7,COMPOS_1:62;
    end;
    suppose
      1 < k;
      then 1+1 <= k by INT_1:7;
      hence IC Comput(P3,s3,k) in dom pIF
      by A13,A16,A19,EXTPRO_1:5;
    end;
  end;
  hence IF is_closed_on s,P by Def2;
  P3 halts_on s3 by A19,EXTPRO_1:29;
  hence thesis by Def3;
end;

theorem Th134:
  for s being State of SCMPDS,I being halt-free shiftable
  Program of SCMPDS, a being Int_position,k1 being Integer st s.DataLoc(s.a,k1)
  >= 0 & I is_closed_on s,P & I is_halting_on s,P
   holds IExec(if>=0(a,k1,I),P,Initialize s) =
  IExec(I,P,Initialize s) +* Start-At((card I+2),SCMPDS)
proof
  let s be State of SCMPDS,I be halt-free shiftable Program of SCMPDS, a be
  Int_position,k1 be Integer;
  set b=DataLoc(s.a,k1);
  set IF=if>=0(a,k1,I), pIF = stop IF, pI=stop I,
   s2 = Initialize s, s3 = Initialize s,
   P2 = P +* pI, P3 = P +* pIF,
   s4 = Comput(P3, s3,1), P4 = P3;
  set i = (a,k1)>=0_goto 2, j = goto (card I + 1);
  set SAl=Start-At((card I+2),SCMPDS);
A3: IF=i ';' (j ';' I) by SCMPDS_4:16;
UU:  stop I c= P2 by FUNCT_4:25;
A4: Comput(P3, s3,0 + 1) = Following(P3,Comput(P3,s3,0)) by EXTPRO_1:3
    .= Following(P3,s3) by EXTPRO_1:2
    .= Exec(i,s3) by A3,Th22;
A5: not b in dom Start-At(0,SCMPDS) by SCMPDS_4:18;
  not a in dom Start-At(0,SCMPDS) by SCMPDS_4:18;
  then
A6: s3.DataLoc(s3.a,k1)=s3.b by FUNCT_4:11
    .= s.b by A5,FUNCT_4:11;
A7: IC s3 = 0 by MEMSTR_0:47;
A8: Start-At(0,SCMPDS) c= s2 & Shift(pI,2) c= P4 by Lm7,FUNCT_4:25;
  for a holds s2.a = s4.a by A4,SCMPDS_2:57;
  then
A10: DataPart s2 = DataPart s4 by SCMPDS_4:8;
  assume
  s.b >= 0;
  then
A11: IC s4 = ICplusConst(s3,2) by A4,A6,SCMPDS_2:57
    .= (0+2) by A7,Th23;
  assume
A13: I is_closed_on s,P;
  then
A14: I is_closed_on s2,P2 by Th38;
  assume
A15: I is_halting_on s,P;
  then
A16: P2 halts_on s2 by Def3;
A18: Comput(P3,s3,LifeSpan(P2,s2)+1)
 = Comput(P3,Comput(P3,s3,1),LifeSpan(P2
,s2))
 by EXTPRO_1:4;
A21: CurInstr(P3,
Comput(P3,s3,LifeSpan(P2,s2)+1))
 =CurInstr(P3,
 Comput(P3,s4,LifeSpan(P2,s2))) by A18
    .=CurInstr(P2,
    Comput(P2,s2,LifeSpan(P2,s2)))
     by A14,A8,A11,A10,Th45,UU
    .= halt SCMPDS by A16,EXTPRO_1:def 15;
  then
A22: P3 halts_on s3 by EXTPRO_1:29;
A23: CurInstr(P3,s3) = i by A3,Th22;
  now
    let l be Element of NAT;
    assume
A24: l < LifeSpan(P2,s2) + 1;
A25: Comput(P3,s3,0) = s3 by EXTPRO_1:2;
    per cases;
    suppose
      l = 0;
      then CurInstr(P3,Comput(P3,s3,l))
       = CurInstr(P3,s3)
      by A25;
      hence CurInstr(P3,Comput(
P3,s3,l))
       <> halt SCMPDS by A23;
    end;
    suppose
      l <> 0;
      then consider n be Nat such that
A26:  l = n + 1 by NAT_1:6;
      reconsider n as Element of NAT by ORDINAL1:def 12;
A27:  n < LifeSpan(P2,s2) by A24,A26,XREAL_1:6;
      assume
A28:  CurInstr(P3,Comput(P3,
s3,l)) = halt SCMPDS;
A30: Comput(P3,s3,n+1)
 = Comput(P3,Comput(P3,s3,1),n) by EXTPRO_1:4;
      CurInstr(P2,Comput(P2,s2,n))
       = CurInstr(P3,Comput(P3,s4,n))
       by A14,A8,A11,A10,Th45,UU
        .= halt SCMPDS by A26,A28,A30;
      hence contradiction by A16,A27,EXTPRO_1:def 15;
    end;
  end;
  then for l be Element of NAT st CurInstr(P3,
  Comput(P3,s3,l)) = halt SCMPDS
  holds LifeSpan(P2,s2) + 1 <= l;
  then
A33: LifeSpan(P3,s3) = LifeSpan(P2,s2) + 1 by A21,A22,EXTPRO_1:def 15;
A35: DataPart Result(P2,s2) = DataPart Comput(P2,s2,
LifeSpan(P2,s2)) by A16,EXTPRO_1:23
    .= DataPart Comput(P3, s4,LifeSpan(P2,s2)) by A14,A8,A11,A10,Th45,UU
    .= DataPart Comput(P3, s3,LifeSpan(P2,s2) + 1)
by EXTPRO_1:4
    .= DataPart Result(P3,s3) by A22,A33,EXTPRO_1:23;
A36: now
    let x be set;
A37: dom Start-At((card I+2),SCMPDS) = {IC SCMPDS} by FUNCOP_1:13;
    assume
A38: x in dom IExec(IF,P,Initialize s);
    per cases by A38,SCMPDS_4:6;
    suppose
A39:  x is Int_position;
      then x <> IC SCMPDS by SCMPDS_2:43;
      then
A40:  not x in dom SAl by A37,TARSKI:def 1;
      thus IExec(IF,P,Initialize s).x = (Result(P3,s3)).x
        .= (Result(P2,s2)).x by A35,A39,SCMPDS_4:8
        .= IExec(I,P,Initialize s).x
        .= (IExec(I,P,Initialize s) +* SAl).x by A40,FUNCT_4:11;
    end;
    suppose
A42:  x = IC SCMPDS;
A44:  IC Result(P2,s2) = IC IExec(I,P,Initialize s)
        .=  card I by A13,A15,Th48;
A45:  x in dom SAl by A37,A42,TARSKI:def 1;
      thus IExec(IF,P,Initialize s).x = (Result(P3,s3)).x
        .= Comput(P3, s3,LifeSpan(P2,s2) + 1).x by A22,A33,EXTPRO_1:23
        .= IC Comput(P3, s4,LifeSpan(P2,s2)) by A42,EXTPRO_1:4
        .= IC Comput(P2, s2,LifeSpan(P2,s2)) + 2
        by A14,A8,A11,A10,Th45,UU
        .= IC Result(P2,s2) + 2 by A16,EXTPRO_1:23
        .= IC SAl by A44,FUNCOP_1:72
        .= (IExec(I,P,Initialize s) +* SAl).x by A42,A45,FUNCT_4:13;
    end;
  end;
  dom IExec(IF,P,Initialize s) = the carrier of SCMPDS by PARTFUN1:def 2
    .= dom (IExec(I,P,Initialize s)
     +* Start-At((card I+2),SCMPDS)) by PARTFUN1:def 2;
  hence thesis by A36,FUNCT_1:2;
end;

theorem Th135:
  for s being State of SCMPDS,I being Program of SCMPDS,a being
Int_position, k1 being Integer st s.DataLoc(s.a,k1) < 0
 holds IExec(if>=0(a,k1,I),P,Initialize s) = s +* Start-At((card I+2),SCMPDS)
proof
  let s be State of SCMPDS,I be Program of SCMPDS,a be Int_position, k1 be
  Integer;
  set b=DataLoc(s.a,k1);
  set IF=if>=0(a,k1,I), pIF=stop IF, s3 = Initialize s,
  P3 = P +* pIF,
  s4 = Comput(P3,s3,1), s5 = Comput(P3,s3,2), P4 = P3, P5 = P3;
  set i = (a,k1)>=0_goto 2, j = goto (card I + 1);
  set SAl=Start-At((card I+2),SCMPDS);
A2: IF =i ';' (j ';' I) by SCMPDS_4:16;
A3: not b in dom Start-At(0,SCMPDS) by SCMPDS_4:18;
  not a in dom Start-At(0,SCMPDS) by SCMPDS_4:18;
  then
A4: s3.DataLoc(s3.a,k1)=s3.b by FUNCT_4:11
    .= s.b by A3,FUNCT_4:11;
A5: IC s3 = 0 by MEMSTR_0:47;
A6: pIF c= P3 by FUNCT_4:25;
  then
A7: pIF c= P4;
A8: pIF c= P5 by A6;
A9: Comput(P3, s3,0 + 1) = Following(P3,Comput(P3,s3,0)) by EXTPRO_1:3
    .= Following(P3,s3) by EXTPRO_1:2
    .= Exec(i,s3) by A2,Th22;
  assume
  s.b < 0;
  then
A10: IC s4 = succ IC s3 by A9,A4,SCMPDS_2:57
    .= (0+1) by A5;
A11:  1 in dom IF by Lm9;
  then  1 in dom pIF by COMPOS_1:62;
  then
A12: P4.1 = pIF. 1 by A7,GRFUNC_1:2
    .=IF. 1 by A11,COMPOS_1:63
    .=j by Lm10;
A13:  P3/.IC s4 = P3.IC s4 by PBOOLE:143;
A15: Comput(P3, s3,1 + 1) = Following(P3,s4) by EXTPRO_1:3
    .= Exec(j,s4) by A10,A12,A13;
  then
A16: IC s5 = ICplusConst(s4,card I+1) by SCMPDS_2:54
    .= (card I+1+1) by A10,Th23
    .= (card I+(1+1));
A17:  (P3)/.IC s5
 = P3.IC s5 by PBOOLE:143;
A19: card IF=card I+2 by Lm8;
  then (card I+2) in dom pIF by COMPOS_1:64;
  then P5.(card I+2) = pIF.(card I+2) by A8,GRFUNC_1:2
    .=halt SCMPDS by A19,COMPOS_1:64;
  then
A20: CurInstr(P3,s5) = halt SCMPDS by A16,A17;
  then
A21: P3 halts_on s3 by EXTPRO_1:29;
A22: CurInstr(P3,s3) = i by A2,Th22;
  now
    let l be Element of NAT;
    assume
    l < 1+1;
    then
A23: l <= 1 by NAT_1:13;
A24: Comput(P3,s3,0) = s3 by EXTPRO_1:2;
A25: P3/.IC Comput(P3,s3,l)
 = P3.IC Comput(P3,s3,l) by PBOOLE:143;
    per cases by A23,NAT_1:25;
    suppose
      l=0;
      then CurInstr(P3,Comput(P3,s3,l))
       = CurInstr(P3,s3)
       by A24;
      hence CurInstr(P3,Comput(P3,s3,l))
       <> halt SCMPDS by A22;
    end;
    suppose
      l=1;
      hence CurInstr(P3,Comput(P3,s3,l))
       <> halt SCMPDS by A10,A12,A25;
    end;
  end;
  then for l be Element of NAT st CurInstr(P3,
  Comput(P3,s3,l)) = halt SCMPDS
  holds 2 <= l;
  then LifeSpan(P3,s3) = 2 by A20,A21,EXTPRO_1:def 15;
  then
A27: s5 = Result(P3,s3) by A21,EXTPRO_1:23;
A29: now
A30: dom SAl = {IC SCMPDS} by FUNCOP_1:13;
    let x be set;
    assume
A31: x in dom IExec(IF,P,Initialize s);
    per cases by A31,SCMPDS_4:6;
    suppose
A32:  x is Int_position;
      then x <> IC SCMPDS by SCMPDS_2:43;
      then
A33:  not x in dom SAl by A30,TARSKI:def 1;
TT:   not x in dom Start-At(0,SCMPDS) by A32,SCMPDS_4:18;
      thus IExec(IF,P,Initialize s).x = s5.x by A27
        .= s4.x by A15,A32,SCMPDS_2:54
        .= s3.x by A9,A32,SCMPDS_2:57
        .= s.x by TT,FUNCT_4:11
        .= (s +* SAl).x by A33,FUNCT_4:11;
    end;
    suppose
A34:  x = IC SCMPDS;
      hence IExec(IF,P,Initialize s).x = (card I + 2) by A16,A27
        .= (s +* Start-At((card I+2),SCMPDS)).x by A34,FUNCT_4:113;
    end;
  end;
  dom IExec(IF,P,Initialize s) = the carrier of SCMPDS by PARTFUN1:def 2
    .= dom (s +* SAl) by PARTFUN1:def 2;
  hence thesis by A29,FUNCT_1:2;
end;

registration
  let I be shiftable parahalting Program of SCMPDS, a be Int_position,k1 be
  Integer;
  cluster if>=0(a,k1,I) -> shiftable parahalting;
  correctness
  proof
    set i = (a,k1)>=0_goto 2, j = goto (card I + 1);
    set IF=if>=0(a,k1,I), pIF = stop IF;
    thus IF is shiftable;
      let s be 0-started State of SCMPDS;
      let P be Instruction-Sequence of SCMPDS;
A1:  Initialize s = s by MEMSTR_0:44;
      assume pIF c= P;
      then
A2:   P = P +* stop IF by FUNCT_4:98;
A3:   I is_closed_on s,P & I is_halting_on s,P by Th34,Th35;
      per cases;
      suppose
        s.DataLoc(s.a,k1) >= 0;
        then IF is_halting_on s,P by A3,Th132;
        hence P halts_on s by A2,Def3,A1;
      end;
      suppose
        s.DataLoc(s.a,k1) < 0;
        then IF is_halting_on s,P by Th133;
        hence P halts_on s by A2,Def3,A1;
      end;
  end;
end;

registration
  let I be halt-free Program of SCMPDS, a be Int_position,k1 be Integer;
  cluster if>=0(a,k1,I) -> halt-free;
  coherence;
end;

theorem
  for s being 0-started State of SCMPDS,I being halt-free shiftable parahalting
Program of SCMPDS,a being Int_position,k1 being Integer
 holds IC IExec(if>=0(a,k1,I),P,s) = card I + 2
proof
  let s be 0-started State of SCMPDS,
      I be halt-free shiftable parahalting Program of
  SCMPDS,a be Int_position,k1 be Integer;
  set IF=if>=0(a,k1,I);
A1: I is_closed_on s,P & I is_halting_on s,P by Th34,Th35;
I: Initialize s = s by MEMSTR_0:44;
  per cases;
  suppose
    s.DataLoc(s.a,k1) >= 0;
    then IExec(IF,P,s) =IExec(I,P,s) +* Start-At((card I+2),SCMPDS)
    by A1,Th134,I;
    hence thesis by FUNCT_4:113;
  end;
  suppose
    s.DataLoc(s.a,k1) < 0;
    then IExec(IF,P,s) =s +* Start-At((card I+2),SCMPDS) by Th135,I;
    hence thesis by FUNCT_4:113;
  end;
end;

theorem
  for s being State of SCMPDS,I being halt-free shiftable parahalting
Program of SCMPDS,a,b being Int_position,k1 being Integer st s.DataLoc(s.a,k1)
  >= 0 holds IExec(if>=0(a,k1,I),P,Initialize s).b = IExec(I,P,Initialize s).b
proof
  let s be State of SCMPDS,I be halt-free shiftable parahalting Program of
  SCMPDS,a,b be Int_position,k1 be Integer;
  assume
A1: s.DataLoc(s.a,k1) >= 0;
A2: not b in dom Start-At((card I+2),SCMPDS) by SCMPDS_4:18;
  I is_closed_on s,P & I is_halting_on s,P by Th34,Th35;
  then IExec(if>=0(a,k1,I),P,Initialize s) = IExec(I,P,Initialize s)
   +* Start-At((card I+2),SCMPDS)
   by A1,Th134;
  hence thesis by A2,FUNCT_4:11;
end;

theorem
  for s being State of SCMPDS,I being Program of SCMPDS,a,b being
Int_position, k1 being Integer st s.DataLoc(s.a,k1) < 0
 holds IExec(if>=0(a,k1,I),P,Initialize s).b = s.b
proof
  let s be State of SCMPDS,I be Program of SCMPDS,a,b be Int_position, k1 be
  Integer;
  assume
  s.DataLoc(s.a,k1) < 0;
  then
A1: IExec(if>=0(a,k1,I),P,Initialize s) = s +* Start-At((card I+2),SCMPDS)
 by Th135;
  not b in dom Start-At((card I+2),SCMPDS) by SCMPDS_4:18;
  hence thesis by A1,FUNCT_4:11;
end;

theorem
  for s being State of SCMPDS,I being Program of SCMPDS
   holds I is_closed_on s,P iff I is_closed_on Initialize s,P
proof let s be State of SCMPDS,I being Program of SCMPDS;
 thus I is_closed_on s,P implies I is_closed_on Initialize s,P
  proof assume for k being Element of NAT holds
   IC Comput(P+*stop I,Initialize s,k)
    in dom stop I;
   hence for k being Element of NAT holds
   IC Comput(P +* stop I,
   Initialize Initialize s,k)
    in dom stop I;
  end;
  assume for k being Element of NAT holds
   IC Comput(P +* stop I,
   Initialize Initialize s,k)
    in dom stop I;
  hence for k being Element of NAT holds
   IC Comput(P+*stop I,Initialize s,k)
    in dom stop I;
end;

theorem
  for s being State of SCMPDS,I being Program of SCMPDS
   holds I is_halting_on s,P iff I is_halting_on Initialize s,P
proof let s be State of SCMPDS,I be Program of SCMPDS;
 thus I is_halting_on s,P implies I is_halting_on Initialize s,P
  proof
   assume P+*stop I halts_on Initialize s;
   hence P +* stop I
    halts_on Initialize Initialize s;
  end;
 assume P +* stop I
    halts_on Initialize Initialize s;
 hence P+*stop I halts_on Initialize s;
end;

