:: The Construction and Computation of Conditional Statements for SCMPDS
::  by JingChao Chen
::
:: Received June 15, 1999
:: Copyright (c) 1999-2011 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies NUMBERS, SUBSET_1, SCMPDS_2, AMI_1, FSM_1, INT_1, AMI_2, RELAT_1,
      XBOOLE_0, GRAPHSP, XXREAL_0, CIRCUIT2, ARYTM_3, CARD_1, FUNCT_1,
      FUNCT_4, TARSKI, TURING_1, SCMFSA_7, SCMPDS_4, AMISTD_2,
      COMPLEX1, VALUED_1, SCMFSA6B, MSUALG_1, SCMPDS_5, SCMFSA8A, AMI_3,
      ARYTM_1, UNIALG_2, SCMFSA7B, SCMFSA8B, NAT_1, STRUCT_0,
      SCMPDS_6, ORDINAL1, PARTFUN1, SCMNORM, SCMFSA6C, PBOOLE;
 notations TARSKI, XBOOLE_0, SUBSET_1, XCMPLX_0, RELAT_1, FUNCT_1, CARD_1,
      PARTFUN1, AFINSQ_1, VALUED_1, NUMBERS, COMPLEX1, FUNCT_4, INT_1, NAT_1,
      PBOOLE, STRUCT_0, COMPOS_1, EXTPRO_1,
      AMI_2, FUNCT_7, SCMPDS_2, SCMPDS_4,
      SCMPDS_5, XXREAL_0;
 constructors XXREAL_0, REAL_1, INT_2, SCMPDS_4, SCMPDS_5, VALUED_1, AMI_2;
 registrations SETFAM_1, FUNCT_1, NUMBERS, XXREAL_0, XREAL_0, NAT_1, INT_1,
      SCMPDS_2, SCMPDS_4, SCMPDS_5, ORDINAL1, XBOOLE_0,
      VALUED_1, AFINSQ_1, COMPOS_1, EXTPRO_1, PBOOLE, FUNCT_4, RELAT_1;
 requirements NUMERALS, REAL, SUBSET, BOOLE, ARITHM;
 definitions FUNCOP_1, COMPOS_1, EXTPRO_1, SCMPDS_4, SCMPDS_5;
 theorems NAT_1, TARSKI, FUNCT_4, FUNCT_1, INT_1, SCMPDS_2, SCMPDS_3,
      ABSVALUE, GRFUNC_1, SCMPDS_4, SCMPDS_5, XBOOLE_0, XBOOLE_1, XREAL_1,
      ORDINAL1, FUNCOP_1, XXREAL_0, AMI_2, VALUED_1, PARTFUN1,
      AFINSQ_1, COMPOS_1, EXTPRO_1, PBOOLE, RELAT_1;
 schemes NAT_1;

begin :: Preliminaries

reserve m,n for Element of NAT,
  a for Int_position,
  i,j for Instruction of SCMPDS,
  s,s1,s2 for State of SCMPDS,
  k1 for Integer,
  loc for Element of NAT,
  I,J,K for Program of SCMPDS;
set A = NAT;
set D = SCM-Data-Loc;

Lm1: (Stop SCMPDS). 0 = halt SCMPDS by AFINSQ_1:38;
Lm2:  0 in dom Stop SCMPDS by COMPOS_1:45;

canceled;

reserve P,P1,P2 for (the Instructions of SCMPDS)-valued ManySortedSet of NAT;

theorem Th2:
  for s being State of SCMPDS st P halts_on s for k being Element
  of NAT st LifeSpan(P,s) <= k
   holds CurInstr(P, Comput(P,s,k)) = halt SCMPDS
proof
  let s be State of SCMPDS;
  assume
  P halts_on s;
  then
A1: CurInstr(P,
  Comput(P,s,LifeSpan(P,s)))
 = halt SCMPDS by EXTPRO_1:def 14;
  let k be Element of NAT;
  assume
   LifeSpan(P,s) <= k;
   then
 Comput(P,s,LifeSpan(P,s)) = Comput(P,s,
k) by A1,EXTPRO_1:6;

  hence thesis by A1;
end;

theorem Th3:
  for s being State of SCMPDS st P halts_on s for k being Element
of NAT st LifeSpan(P,s) <= k holds IC Comput(P,s,k) =
IC Comput(P,s,LifeSpan(P,s))
proof
  let s be State of SCMPDS;
  defpred P[Element of NAT] means LifeSpan(P,s) <= $1 implies IC
Comput(P,s,$1)
 = IC Comput(P,s,LifeSpan(P,s));
  assume
A1: P halts_on s;
A2: now
    let k be Element of NAT;
    assume
A3: P[k];
    now
      assume
A4:   LifeSpan(P,s) <= k + 1;
      per cases by A4,XXREAL_0:1;
      suppose
        k + 1 = LifeSpan(P,s);
        hence IC Comput(P,s,k+1) = IC Comput(P,s,
LifeSpan(P,s));
      end;
      suppose
A5:     k + 1 > LifeSpan(P,s);
        then
A6:     LifeSpan(P,s) <= k by NAT_1:13;
        thus IC Comput(P,s,k+1) =
        IC Following(P,Comput(P,s,k))
         by EXTPRO_1:4
          .= IC Exec(halt SCMPDS,Comput(P,s,k)) by A1,A6,Th2
          .= IC Comput(P,s,LifeSpan(P,s)) by A3,A5,
EXTPRO_1:def 3,NAT_1:13;
      end;
    end;
    hence P[k + 1];
  end;
  let k be Element of NAT;
  assume
A7: LifeSpan(P,s) <= k;
A8: P[0];
  for k being Element of NAT holds P[k] from NAT_1:sch 1(A8,A2);
  hence thesis by A7;
end;

theorem Th4:
  for s1,s2 being State of SCMPDS holds NPP s1 = NPP s2 iff
  IC s1 = IC s2 & DataPart s1 = DataPart s2
proof
  let s1,s2 be State of SCMPDS;
  thus NPP s1 = NPP s2 implies IC s1 = IC s2 & DataPart s1 = DataPart
  s2 by COMPOS_1:138,230;
  assume that
A1: IC s1 = IC s2 and
A2: DataPart s1 = DataPart s2;
  for a being Int_position holds s1.a = s2.a by A2,SCMPDS_4:23;
  hence thesis by A1,SCMPDS_4:11;
end;

canceled 2;

theorem Th7:
  for s being State of SCMPDS, l being Element of NAT
  holds DataPart s = DataPart(s +* Start-At(l,SCMPDS))
proof
  let s be State of SCMPDS;
  let l be Element of NAT;
  now
    let x be set;
    assume
    x in dom Start-At(l,SCMPDS);
    then x in {IC SCMPDS} by FUNCOP_1:19;
    hence not x in D by SCMPDS_3:6,TARSKI:def 1;
  end;
  then dom Start-At(l,SCMPDS) misses D by XBOOLE_0:3;
  hence thesis by FUNCT_4:76,SCMPDS_2:100;
end;

canceled 4;

theorem Th12:
  for s1,s2 be State of SCMPDS,I,J be Program of SCMPDS holds
  DataPart s1 = DataPart s2 implies
   NPP Initialize s1 = NPP Initialize s2
proof
  let s1,s2 be State of SCMPDS,I,J be Program of SCMPDS;
  assume
A1: DataPart s1 = DataPart s2;
  set S1 = Initialize s1, S2 = Initialize s2;
A4: IC S1 =  0 & IC S2 =  0 by COMPOS_1:223;
  DataPart S1 = DataPart s1 by COMPOS_1:80
    .= DataPart S2 by A1,COMPOS_1:80;
  hence thesis by A4,Th4;
end;

canceled 2;

theorem Th15:
  card (i ';' I)= card I + 1
proof
  thus card (i ';' I) = card (Load i ';' I)
    .=card (Load i) + card I by AFINSQ_1:20
    .=card I+1 by SCMPDS_5:6;
end;

theorem Th16:
  (i ';' I). 0=i
proof
  i ';' I=Load i ';' I &  0 in dom Load i by SCMPDS_5:2;
  hence (i ';' I). 0 =(Load i). 0 by AFINSQ_1:def 4
    .=i by SCMPDS_5:4;
end;

canceled;

theorem Th18:
  loc in dom I implies loc in dom (stop I)
proof
  dom I c= dom (I ';' Stop SCMPDS) by AFINSQ_1:24;
  then
A1: dom I c= dom stop I;
  assume
  loc in dom I;
  hence thesis by A1;
end;

theorem Th19:
  loc in dom I implies (stop I).loc=I.loc
proof
  assume
A1: loc in dom I;
  thus (stop I).loc =(I ';' Stop SCMPDS).loc
    .=I.loc by A1,AFINSQ_1:def 4;
end;

theorem Th20:
  loc in dom I implies (stop I).loc=I.loc
proof
  assume
A1: loc in dom I;
  thus (stop I).loc=(stop I).loc
    .=I.loc by A1,Th19;
end;

canceled;

theorem Th22:
  CurInstr(P +* stop(i ';' I),Initialize s) = i
proof
  set iI=i ';' I, s3=s+*Initialize stop iI, P3 = P +* stop(i ';' I);
A2:  0 in dom Load i by SCMPDS_5:2;
  card iI=card I +1 by Th15;
  then
A3:  0 in dom iI by AFINSQ_1:70;
   iI c= stop iI by AFINSQ_1:78;
   then dom iI c= dom stop iI by RELAT_1:25;
   then
B3:  0 in dom stop iI by A3;
A4:  (P +* stop(i ';' I))/.IC (Initialize s)
     = (P +* stop(i ';' I)).IC (Initialize s) by PBOOLE:158;
  P3.0 = (P +* stop(i ';' I)). 0
    .= (stop iI). 0 by B3,FUNCT_4:14
    .= iI. 0 by A3,Th20
    .=(Load i ';' I). 0
    .=(Load i). 0 by A2,AFINSQ_1:def 4
    .=i by SCMPDS_5:4;
  hence thesis by A4,COMPOS_1:223;
end;

theorem Th23:
  for s being State of SCMPDS,m1,m2 being Element of NAT st IC s=
   m1 holds ICplusConst(s,m2)= (m1+m2)
proof
  let s be State of SCMPDS,m1,m2 be Element of NAT;
A1: ex m st m = IC s & ICplusConst(s,m2) = abs(m+m2) by SCMPDS_2:def 20;
  assume
  IC s= m1;
  hence thesis by A1,ABSVALUE:def 1;
end;

theorem Th24:
  for I,J being Program of SCMPDS holds Shift(stop J,card I) c=
  stop(I ';' J)
proof
  let I,J be Program of SCMPDS;
  stop(I ';' J) =I ';' J ';' Stop SCMPDS
    .=I ';' (J ';' Stop SCMPDS) by AFINSQ_1:30
    .=I ';' (stop J);
  then stop(I ';' J) = I +* Shift(stop J, card I);
  hence thesis by FUNCT_4:26;
end;

theorem Th25:
  card I in dom stop I & (stop I).card I = halt SCMPDS
proof
  set SS=Stop SCMPDS;
  set pI=stop I;
  card pI=card I+1 by SCMPDS_5:7;
  then card I <card pI by XREAL_1:31;
  hence (card I) in dom pI by AFINSQ_1:70;
  pI.(0+card I) =halt SCMPDS by Lm1,Lm2,AFINSQ_1:def 4;
  hence thesis;
end;

theorem Th26:
  for x,l being Element of NAT holds IExec(J,P,s).x
  = (IExec(I,P,s) +* Start-At(l,SCMPDS)).x
proof
  let x,l be Element of NAT;
  dom Start-At(l,SCMPDS) = {IC SCMPDS} & x <> IC SCMPDS
  by COMPOS_1:3,FUNCOP_1:19;
  then
A1: not x in dom Start-At(l,SCMPDS) by TARSKI:def 1;
    dom ProgramPart s = NAT by COMPOS_1:34;
    then
B2: x in dom(s|A);
  thus IExec(J,P,s).x = (Result(P +* stop J,Initialize s) +* (s|A)).x
    .=(s | A).x by FUNCT_4:14,B2
    .= (Result(P +* stop I,Initialize s) +* s | A).x by FUNCT_4:14,B2
    .= IExec(I,P,s).x
    .= (IExec(I,P,s) +* Start-At(l,SCMPDS)).x by A1,FUNCT_4:12;
end;

theorem Th27:
  for x,l being Element of NAT holds IExec(I,P,s).x
  = (s +* Start-At(l,SCMPDS)).x
proof
  let x,l be Element of NAT;
  dom Start-At(l,SCMPDS) = {IC SCMPDS} & x <> IC SCMPDS
  by COMPOS_1:3,FUNCOP_1:19;
  then
A1: not x in dom Start-At(l,SCMPDS) by TARSKI:def 1;
    dom ProgramPart s = NAT by COMPOS_1:34;
    then
B2: x in dom(s|A);
  thus IExec(I,P,s).x = (Result(P +* stop I,
     Initialize s) +* s | A).x
    .=(s | A).x by FUNCT_4:14,B2
    .= s.x by FUNCT_1:72
    .= (s+* Start-At(l,SCMPDS)).x by A1,FUNCT_4:12;
end;

theorem
  for s being 0-started State of SCMPDS, i being No-StopCode parahalting
Instruction of SCMPDS,J being parahalting shiftable Program of SCMPDS, a being
  Int_position holds IExec(i ';' J,P,s).a = IExec(J,P,Exec(i,Initialize s)).a
proof
  let s be 0-started State of SCMPDS,
      i be No-StopCode parahalting Instruction of SCMPDS,
  J be parahalting shiftable Program of SCMPDS, a be Int_position;
  thus IExec(i ';' J,P,s).a = IExec(Load i ';' J,P,s).a
    .= IExec(J,P,IExec(Load i,P,s)).a by SCMPDS_5:39
    .= IExec(J,P,Exec(i,Initialize s)).a by SCMPDS_5:45;
end;

theorem
  for a being Int_position,k1,k2 being Integer holds (a,k1)
  <>0_goto k2 <> halt SCMPDS
proof
  let a be Int_position,k1,k2 be Integer;
  InsCode ((a,k1)<>0_goto k2) = 4 by SCMPDS_2:25;
  hence thesis by SCMPDS_2:21,93;
end;

theorem
  for a being Int_position,k1,k2 being Integer holds (a,k1)
  <=0_goto k2 <> halt SCMPDS
proof
  let a be Int_position,k1,k2 be Integer;
  InsCode ((a,k1)<=0_goto k2) = 5 by SCMPDS_2:26;
  hence thesis by SCMPDS_2:21,93;
end;

theorem
  for a being Int_position,k1,k2 being Integer holds (a,k1)
  >=0_goto k2 <> halt SCMPDS
proof
  let a be Int_position,k1,k2 be Integer;
  InsCode ((a,k1)>=0_goto k2) = 6 by SCMPDS_2:27;
  hence thesis by SCMPDS_2:21,93;
end;

definition
  let k1;
  func Goto k1 -> Program of SCMPDS equals
  Load goto k1;
  coherence;
end;

registration
  let n be Element of NAT;
  cluster goto (n+1) -> No-StopCode;
  correctness by SCMPDS_5:25;
  cluster goto -(n+1) -> No-StopCode;
  correctness
  proof
    -(n+1) <> 0;
    hence thesis by SCMPDS_5:25;
  end;
end;

registration
  let n be Element of NAT;
  cluster Goto (n+1) -> halt-free;
  correctness;
  cluster Goto -(n+1) -> halt-free;
  correctness;
end;

canceled;

theorem Th33:
   0 in dom Goto k1 & (Goto k1). 0 = goto k1 by AFINSQ_1:38,69;

begin :: The predicates of is_closed_on and is_halting_on

definition
  let I be Program of SCMPDS;
  let s be State of SCMPDS;
  let P;
  pred I is_closed_on s,P means
  :Def2:
  for k being Element of NAT holds
   IC Comput(P+*stop I,Initialize s,k)
    in dom stop I;
  pred I is_halting_on s,P means
  :Def3:
  P+*stop I halts_on Initialize s;
end;

theorem Th34:
  for I being Program of SCMPDS holds I is paraclosed iff
  for s being State of SCMPDS, P holds I is_closed_on s,P
proof
  let I be Program of SCMPDS;
  hereby
    assume
A1: I is paraclosed;
    let s be State of SCMPDS;
    let P;
    stop I c= P +* stop I by FUNCT_4:26;
    then for n holds
     IC Comput(P+*stop I,Initialize s,n)
      in dom stop I by A1,SCMPDS_4:def 9;
    hence I is_closed_on s,P by Def2;
  end;
  assume
A2: for s being State of SCMPDS,P holds I is_closed_on s,P;
    let s be 0-started State of SCMPDS;
    let k be Element of NAT;
    let P;
A3:  Initialize s = s by COMPOS_1:78;
    assume stop I c= P;
    then
A4: P = P +* stop I by FUNCT_4:104;
    I is_closed_on s,P by A2;
    hence IC Comput(P,s,k) in dom stop I by A3,A4,Def2;
end;

theorem Th35:
  for I being Program of SCMPDS holds I is parahalting iff for s
  being State of SCMPDS,P holds I is_halting_on s,P
proof
  let I be Program of SCMPDS;
  hereby
    assume
A1: I is parahalting;
    let s be State of SCMPDS, P;
    P+*stop I halts_on Initialize s
     by A1,FUNCT_4:26,SCMPDS_4:def 10;
    hence I is_halting_on s,P by Def3;
  end;
  assume
A2: for s being State of SCMPDS, P holds I is_halting_on s,P;
    let s be 0-started State of SCMPDS, P;
A3:  Initialize s = s by COMPOS_1:78;
    assume
    stop I c= P;
    then
A4: P = P +* stop I by FUNCT_4:104;
    I is_halting_on s,P by A2;
    hence P halts_on s by A4,Def3,A3;
end;

theorem Th36:
  for s1,s2 being State of SCMPDS, I being Program of SCMPDS st
  DataPart s1 = DataPart s2 holds I is_closed_on s1,P1
   implies I is_closed_on s2,P2
proof
  let s1,s2 be State of SCMPDS,I be Program of SCMPDS;
  set pI=stop I, S1 = Initialize s1, S2 = Initialize s2,
   E1 = P1 +* pI, E2 = P2 +* pI;
  assume
A3: DataPart s1 = DataPart s2;
A4: Comput(E2,S2,0) = Initialize s2 by EXTPRO_1:3;
A5: Comput(E1,S1,0) = Initialize s1 by EXTPRO_1:3;
  then
A6: DataPart Comput(E1,S1,0) = DataPart s1 by COMPOS_1:80
    .= DataPart Comput(E2,S2,0) by A3,A4,COMPOS_1:80;
  defpred P[Element of NAT] means IC Comput(E1,S1,$1) = IC Comput(
E2,S2,$1
  ) & CurInstr(E1,Comput(E1,S1,$1))
   = CurInstr(E2,Comput(E2,
S2,$1)) & DataPart
  Comput(E1,S1,$1) = DataPart Comput(E2,S2,$1);
A7:  0 in dom pI by COMPOS_1:135;
  assume
A10: I is_closed_on s1,P1;
A11: now
    let k be Element of NAT;
A13: Comput(E2,S2,k+1) = Following(E2,Comput(E2,S2,k)) by EXTPRO_1:4
      .= Exec(CurInstr(E2,Comput(E2,S2,k)),Comput(E2,S2,k));
    assume
A14: P[k];
    then
A15: for a holds Comput(E1,S1,k).a = Comput(E2,S2,k).
a by SCMPDS_4:23;
    pI c= P2 +* pI by FUNCT_4:26;
    then
A16: pI c= E2;
A17: IC Comput(E1,S1,k+1) in dom pI by A10,Def2;
A19: Comput(E1,S1,k+1) = Following(E1,Comput(E1,S1,k)) by EXTPRO_1:4
      .= Exec(CurInstr(E1,Comput(E1,S1,k)),Comput(E1,S1,k));
   NPP Comput(E1,S1,k) = NPP Comput(E2,S2,k)
     by A14,A15,SCMPDS_4:11;
     then
XX: NPP Comput(E1,S1,k+1) = NPP Comput(E2,S2,k+1)
          by A14,A13,A19,SCMPDS_4:15;
   then
A20: NPP Comput(E1,S1,k+1)
     = NPP Comput(E2,S2,k+1);
A21: IC Comput(E1,S1,k+1) = IC Comput(E2,S2,k+1) by
XX,COMPOS_1:230;
A22
:  E1/.IC Comput(E1,S1,k+1)
 = E1.IC Comput(E1,S1,k+1) by
PBOOLE:158;
A23:  E2/.IC Comput(E2,S2,k+1)
 = E2.IC Comput(E2,S2,k+1) by
PBOOLE:158;
    pI c= P1 +* pI by FUNCT_4:26;
    then pI c= E1;
    then CurInstr(E1,Comput(E1,S1,k+1))
     = pI.IC Comput(E1,S1,k+1) by A17,A22,GRFUNC_1:8
      .= CurInstr(E2,Comput(E2,S2,k+1))
       by A16,A21,A17,A23,GRFUNC_1:8;
    hence P[k+1] by A20,COMPOS_1:138,230;
  end;
A25: IC Comput(E2,S2,0) = IC S2 by A4
    .=  0 by COMPOS_1:def 16;
A26: E1/.IC Comput(E1,S1,0)
 = E1.IC Comput(E1,S1,0) by PBOOLE:158;
A27: E2/.IC Comput(E2,S2,0)
 = E2.IC Comput(E2,S2,0) by PBOOLE:158;
A28: IC Comput(E1,S1,0) = IC S1
by A5
    .=  0 by COMPOS_1:def 16;
  then CurInstr(E1,Comput(E1,S1,0))
     = pI. 0 by A7,A26,FUNCT_4:14
    .= CurInstr(E2,Comput(E2,S2,0)) by A25,A7,A27,FUNCT_4:14;
  then
A29: P[0] by A28,A25,A6;
  now
    let k be Element of NAT;
A30: for k being Element of NAT holds P[k] from NAT_1:sch 1(A29,A11);
    IC Comput(E1,S1,k) in dom pI by A10,Def2;
    hence IC Comput(E2,S2,k) in dom pI by A30;
  end;
  hence thesis by Def2;
end;

theorem
  for s1,s2 being State of SCMPDS,I being Program of SCMPDS st DataPart
  s1 = DataPart s2 holds I is_closed_on s1,P1 & I is_halting_on s1,P1
   implies I
  is_closed_on s2,P2 & I is_halting_on s2,P2
proof
  let s1,s2 be State of SCMPDS,I be Program of SCMPDS;
  set pI=stop I, S1 = Initialize s1, S2 = Initialize s2,
    E1 = P1 +* pI, E2 = P2 +* pI;
  defpred P[Element of NAT] means
   IC Comput(E1,S1,$1) = IC Comput(E2,S2,$1) &
   CurInstr(E1,Comput(E1,S1,$1)) = CurInstr(E2,Comput(E2,S2,$1))
    & DataPart
  Comput(E1,S1,$1) = DataPart Comput(E2,S2,$1);
A3: Comput(E1,S1,0) = Initialize s1 by EXTPRO_1:3;
A4: Comput(E2,S2,0) = Initialize s2 by EXTPRO_1:3;
  assume
  DataPart s1 = DataPart s2;
  then
A5: NPP Comput(E1,S1,0) = NPP Comput(E2,S2,0) by A3,A4,Th12;
A6:  0 in dom pI by COMPOS_1:135;
  assume
A9: I is_closed_on s1,P1;
A10: now
    let k be Element of NAT;
A12: Comput(E2,S2,k+1) = Following(E2,Comput(E2,S2,k)) by EXTPRO_1:4
      .= Exec(CurInstr(E2,Comput(E2,S2,k)),
      Comput(E2,S2,k));
    assume
A13: P[k];
    then for a holds Comput(E1,S1,k).a = Comput(E2,S2
,k).a by SCMPDS_4:23;
    then
A14: NPP Comput(E1,S1,k) = NPP Comput(E2,S2,k)
by A13,SCMPDS_4:11;
A15: pI c= E2 by FUNCT_4:26;
A16: IC Comput(E1,S1,k+1) in dom pI by A9,Def2;
 Comput(E1,S1,k+1) = Following(E1,
Comput(E1,S1,k))
 by EXTPRO_1:4
      .= Exec(CurInstr(E1,Comput(E1,S1,k)),
      Comput(E1,S1,k));
    then
B18: NPP Comput(E1,S1,k+1) = NPP Comput(E2,S2,k+1)
by A13,A14,A12,SCMPDS_4:15;
    then
A18: IC Comput(E1,S1,k+1) = IC Comput(E2,S2,k+1) by
COMPOS_1:230;
A19: E1/.IC Comput(E1,S1,k+1)
 = E1.IC Comput(E1,S1,k+1) by
PBOOLE:158;
A20: E2/.IC Comput(E2,S2,k+1)
 = E2.IC Comput(E2,S2,k+1) by
PBOOLE:158;
    pI c= E1 by FUNCT_4:26;
    then CurInstr(E1,Comput(E1,S1,k+1))
     = pI.IC Comput(E1,S1,k+1) by A16,A19,GRFUNC_1:8
      .= CurInstr(E2,Comput(E2,S2,k+1))
       by A15,A18,A16,A20,GRFUNC_1:8;
    hence P[k+1] by A18,B18,COMPOS_1:138;
  end;
A24: IC Comput(E2,S2,0) = IC S2 by A4
    .=  0 by COMPOS_1:def 16;
  assume
  I is_halting_on s1,P1;
  then P1 +* pI halts_on Initialize s1 by Def3;
  then consider m such that
A25: CurInstr(E1,Comput(E1,S1,m))
 = halt SCMPDS by EXTPRO_1:30;
A26: E1/.IC Comput(E1,S1,0)
 = E1.IC Comput(E1,S1,0) by PBOOLE:158;
A27: E2/.IC Comput(E2,S2,0)
 = E2.IC Comput(E2,S2,0) by PBOOLE:158;
A28: IC Comput(E1,S1,0) = IC S1
        by A3
    .=  0 by COMPOS_1:def 16;
  then CurInstr(E1,Comput(E1,S1,0))
     = pI. 0 by A6,A26,FUNCT_4:14
    .= CurInstr(E2,Comput(E2,S2,0))
     by A24,A6,A27,FUNCT_4:14;
  then
A29: P[0] by A28,A24,A5,COMPOS_1:138;
  now
    let k be Element of NAT;
A30: for k being Element of NAT holds P[k] from NAT_1:sch 1(A29,A10);
    IC Comput(E1,S1,k) in dom pI by A9,Def2;
    hence IC Comput(E2,S2,k) in dom pI by A30;
  end;
  hence I is_closed_on s2,P2 by Def2;
  for k being Element of NAT holds P[k] from NAT_1:sch 1(A29,A10);
  then CurInstr(E2,Comput(E2,S2,m))
   = halt SCMPDS by A25;
  then P2 +* pI halts_on Initialize s2 by EXTPRO_1:30;
  hence thesis by Def3;
end;

theorem Th38:
  for s being State of SCMPDS, I,J being Program of SCMPDS holds I
  is_closed_on s,P iff I is_closed_on Initialize s,P+*J
proof
  let s be State of SCMPDS,I,J be Program of SCMPDS;
  DataPart s = DataPart(Initialize s) by COMPOS_1:80;
  hence thesis by Th36;
end;

theorem Th39:
  for I,J being Program of SCMPDS,s being State of SCMPDS st I
  is_closed_on s,P & I is_halting_on s,P
  holds (for k being Element of NAT
    st k <= LifeSpan(P +* stop I,Initialize s)
     holds IC Comput(P +* stop I,Initialize s,k)
      = IC Comput(P +* stop(I ';' J),Initialize s,k)) &
      DataPart Comput(P +* stop I,Initialize s,
        LifeSpan(P +* stop I,Initialize s)) =
    DataPart Comput(P +* stop(I ';' J),Initialize s,
      LifeSpan(P +* stop I,Initialize s))
proof
  let I,J be Program of SCMPDS,s be State of SCMPDS;
  assume
A1: I is_closed_on s,P;
  set pI=stop I, pIJ=stop (I ';' J),
  s1=Initialize s, P1 = P +* pI, IL=NAT;
  defpred X[Element of NAT] means $1 <= LifeSpan(P1,s1) implies
    NPP Comput(P1, s1,$1)
     = NPP  Comput(P1 +* pIJ, Initialize s1,$1);
  assume I is_halting_on s,P;
  then
A4: P1 halts_on s1 by Def3;
A6: for m st X[m] holds X[m+1]
  proof
    set JS=J ';' Stop SCMPDS;
    set S1 = s1, S2 = Initialize s1,
    E1 = P1, E2 = P1 +* pIJ;
    let m;
    assume
A7: m <= LifeSpan(P1,s1) implies
 NPP Comput(P1, s1,m)
  = NPP Comput(P1 +* pIJ, Initialize s1,m);
A8: pIJ c= E2 by FUNCT_4:26;
A10: Comput(E1,S1,m+1) = Following(E1,Comput(E1,S1,m)) by EXTPRO_1:4
      .= Exec(CurInstr(E1,Comput(E1,S1,m)),Comput(E1,S1,m));
A11: pIJ =I ';' J ';' Stop SCMPDS
      .=I ';' JS by AFINSQ_1:30;
    dom(I ';' JS) = dom (I +* Shift(JS, card I))
      .= dom I \/ dom Shift(JS, card I) by FUNCT_4:def 1;
    then
A12: dom I c= dom(I ';' JS) by XBOOLE_1:7;
A14: Comput(E2,S2,m+1) = Following(E2,Comput(E2,S2,m)) by EXTPRO_1:4
      .= Exec(CurInstr(E2,Comput(E2,S2,m)),Comput(E2,S2,m));
A15: IC Comput(E1,S1,m) in dom pI by A1,Def2;
A16: E1/.IC Comput(E1,S1,m)
 = E1.IC Comput(E1,S1,m) by PBOOLE:158;
    pI c= E1 by FUNCT_4:26;
    then
A18: CurInstr(E1,Comput(E1,S1,m))
 = pI.IC (Comput(E1,S1,m)) by A15,A16,GRFUNC_1:8;
    assume
A19: m+1 <= LifeSpan(P1,s1);
    then m < LifeSpan(P1,s1) by NAT_1:13;
    then pI.IC(Comput(E1,S1,m)) <> halt SCMPDS by A4,A18,
EXTPRO_1:def 14;
    then
A20: IC Comput(E1,S1,m) in dom I by A15,SCMPDS_5:3;
A21: E2/.IC Comput(E2,S2,m)
 = E2.IC Comput(E2,S2,m) by PBOOLE:158;
    CurInstr(E1,Comput(E1,S1,m))
    = (I ';' Stop SCMPDS).IC (Comput(E1,S1,m)) by A18
      .=I.IC (Comput(E1,S1,m)) by A20,AFINSQ_1:def 4
      .=pIJ.IC(Comput(E1,S1,m)) by A20,A11,AFINSQ_1:def 4
      .=E2.IC(Comput(E1,S1,m)) by A8
,A20,A11,A12,GRFUNC_1:8
      .= CurInstr(E2,Comput(E2,S2,m))
       by A7,A19,A21,COMPOS_1:230,NAT_1:13;
    hence thesis by A7,A19,A10,A14,NAT_1:13,SCMPDS_4:15;
  end;
  Comput(P1, s1,0) = s1 &
  Comput(P1 +* pIJ, s1,0) = Initialize s1 by EXTPRO_1:3;
  then
A23: X[0];
A24: for m holds X[m] from NAT_1:sch 1(A23,A6);

A25: P +* pI +* pIJ = P +* (pI +* pIJ) by FUNCT_4:15
            .= P +* pIJ by SCMPDS_5:17;
  hereby let k be Element of NAT such that
Z:  k <= LifeSpan(P1,s1);
   NPP Comput(P1,s1,k)
    =NPP Comput(P +* pIJ, Initialize s,k)
    by A24,A25,Z;
   hence IC Comput(P1,s1,k)
    =IC Comput(P +* pIJ, Initialize s,k)
    by COMPOS_1:230;
  end;
    NPP
Comput(P +* stop I, (Initialize s), LifeSpan(P +* stop I,Initialize s)) =
  NPP Comput(P +* stop(I ';' J),
   Initialize s,
   (LifeSpan(P +* stop I,Initialize s)))
  by A25,A24;
  hence
   DataPart Comput(P +* stop I, Initialize s, (
    LifeSpan(P +* stop I,Initialize s))) =
   DataPart Comput(P +* stop(I ';' J), Initialize s,
    (LifeSpan(P +* stop I,Initialize s)))
  by COMPOS_1:138;
end;

theorem Th40:
  for I being Program of SCMPDS,k be Element of NAT st I
  is_closed_on s,P & I is_halting_on s,P &
    k < LifeSpan(P +* stop I,Initialize s)
  holds IC Comput(P +* stop I,Initialize s,k) in dom I
proof
  let I be Program of SCMPDS,k be Element of NAT;
  set ss= Initialize s, PP = P +* stop I,
      m=LifeSpan(PP,ss), Sp =Stop SCMPDS;
  assume that
A2: I is_closed_on s,P and
A3: I is_halting_on s,P and
A4: k < m;
  set Sk= Comput(PP, ss,k), Ik=IC Sk;
A5: Ik in dom stop(I) by A2,Def2;
  reconsider n = Ik as Element of NAT;
A6: stop I c= PP by FUNCT_4:26;
A7: PP halts_on ss by A3,Def3;
A8: now
A9: PP/.IC Sk = PP.IC Sk by PBOOLE:158;
    assume
A11: n = card I;
    CurInstr(PP,Sk) =PP.Ik by A9
      .=(stop I).(0+n) by A5,A6,GRFUNC_1:8
      .=halt SCMPDS by A11,Lm1,Lm2,AFINSQ_1:def 4;
    hence contradiction by A4,A7,EXTPRO_1:def 14;
  end;
  card stop I=card I + 1 by SCMPDS_5:7;
  then n < card I + 1 by A5,AFINSQ_1:70;
  then n <= card I by INT_1:20;
  then n < card I by A8,XXREAL_0:1;
  hence thesis by AFINSQ_1:70;
end;

theorem Th41:
  for I,J being Program of SCMPDS,s being State of SCMPDS, k being
  Element of NAT st I is_closed_on s,P & I is_halting_on s,P &
   k < LifeSpan(P +* stop I,Initialize s)
 holds CurInstr(P +* stop I, Comput(P +* stop I, Initialize s,k)) =
  CurInstr(P +* stop(I ';' J),Comput(P +* stop(I ';' J),Initialize s,k))
proof
  let I,J be Program of SCMPDS,s be State of SCMPDS,k be Element of NAT;
  set s1=Initialize s, s2=Initialize s,
      P1 = P +* stop I, P2 = P +* stop(I ';' J);
  set s3= Comput(P1, s1,k), s4= Comput(P2, s2,k),
      P3 = P1, P4 = P2,
SS=Stop SCMPDS;
  assume that
A3: I is_closed_on s,P and
A4: I is_halting_on s,P & k < LifeSpan(P1,s1);
A5: IC s3 in dom I by A3,A4,Th40;
A6: IC s3= IC s4 by A3,A4,Th39;
A7: IC s3 in dom stop(I) by A3,Def2;
A8: dom stop I c= dom stop (I ';' J) & stop (I ';' J) c= P2 by SCMPDS_5:16
,FUNCT_4:26;
A9: stop I c= P1 by FUNCT_4:26;
A10: stop (I ';' J) = I ';' J ';' SS
    .=I ';' (J ';' SS) by AFINSQ_1:30;
A11: P3/.IC s3
 = P3.IC s3 by PBOOLE:158;
A12:  P4/.IC s4
 = P4.IC s4 by PBOOLE:158;
  thus CurInstr(P1,s3) =P1.IC s3 by A11
    .=(stop I).IC s3 by A7,A9,GRFUNC_1:8
    .=I.IC s3 by A5,AFINSQ_1:def 4
    .=(stop (I ';' J)).IC s3 by A5,A10,AFINSQ_1:def 4
    .=P2.IC s4 by A6,A7,A8,GRFUNC_1:8
    .=CurInstr(P2,s4) by A12;
end;

theorem Th42: ::SCMPDS_5:32
  for I being halt-free Program of SCMPDS,s being State of
  SCMPDS, k being Element of NAT st I is_closed_on s,P &
  I is_halting_on s,P & k <
  LifeSpan(P +* stop I,Initialize s)
   holds
  CurInstr(P +* stop I,Comput(P +* stop I,Initialize s,k)) <> halt SCMPDS
proof
  let I be halt-free Program of SCMPDS,s be State of SCMPDS, k be Element of
  NAT;
  set ss=Initialize s, PP = P +* stop I,
      s2= Comput(PP, ss,k), P2 = PP;
  assume
  I is_closed_on s,P & I is_halting_on s,P & k < LifeSpan(PP,ss);
  then
A2: IC s2 in dom I by Th40;
A3:  P2/.IC s2 = P2.IC s2 by PBOOLE:158;
XX: stop I c= PP by FUNCT_4:26;
   I c= stop I by AFINSQ_1:78;
  then I c= PP by XX,XBOOLE_1:1;
  then CurInstr(P2,s2)=I.IC s2 by A2,A3,GRFUNC_1:8;
  hence thesis by A2,SCMPDS_5:def 3;
end;

theorem Th43:
  for I being halt-free Program of SCMPDS,s being State of
  SCMPDS st I is_closed_on s,P & I is_halting_on s,P
  holds IC Comput(P +* stop I, Initialize s,
    LifeSpan(P +* stop I,Initialize s)) =  card I
proof
  let I be halt-free Program of SCMPDS,s be State of SCMPDS;
  set s1=Initialize s, P1 = P +* stop I;
  assume that
A2: I is_closed_on s,P and
A3: I is_halting_on s,P;
  set Css= Comput(P1, s1,LifeSpan(P1,s1));
  reconsider n = IC Css as Element of NAT;
XX: stop I c= P1 by FUNCT_4:26;
   I c= stop I by AFINSQ_1:78;
   then
A4: I c= P1 by XX,XBOOLE_1:1;
A5: P1 halts_on s1 by A3,Def3;
  now
A7: P1/.IC Css = P1.IC Css by PBOOLE:158;
    assume
A8: IC Css in dom I;
    then I.IC Css=P1.IC Css by A4,GRFUNC_1:8
      .=CurInstr(P1,Css) by A7
      .=halt SCMPDS by A5,EXTPRO_1:def 14;
    hence contradiction by A8,SCMPDS_5:def 3;
  end;
  then
A9: n >= card I by AFINSQ_1:70;
A10: card stop I =card I + 1 by SCMPDS_5:7;
  IC Css in dom stop(I) by A2,Def2;
  then n < card I + 1 by A10,AFINSQ_1:70;
  then n <= card I by NAT_1:13;
  then IC Comput(P1, s1,LifeSpan(P1,s1)) = card I by A9,XXREAL_0:1;
  hence thesis;
end;

Lm3:
 for I being halt-free Program of SCMPDS, J being Program of SCMPDS,
     s being State of SCMPDS st I is_closed_on s,P & I is_halting_on s,P
  holds IC Comput(P +* stop (I ';' Goto (card J + 1) ';' J ),
Initialize s, (LifeSpan(P +* stop I,Initialize s) + 1)) =
(card I + card J + 1) &
DataPart Comput(P +* stop I, Initialize s,
 (LifeSpan(P +* stop I,Initialize s)))
 = DataPart Comput(P +* stop (I ';' Goto(card J +
1) ';' J), Initialize s,
(LifeSpan(P +* stop I,Initialize s) + 1)) &
(for k being Element of
NAT st k <= LifeSpan(P +* stop I,Initialize s)
 holds CurInstr(P +*stop (I ';' Goto (card J + 1) ';' J ),
   Comput(P +*stop (I ';' Goto (card J + 1) ';' J ),
   Initialize s,k)) <> halt SCMPDS) &
 IC Comput(P +* stop (I ';' Goto (card J + 1) ';' J), Initialize s,
 LifeSpan(P +* stop I,Initialize s))
  =  card I &
 P +* stop (I ';' Goto (card J + 1) ';' J)
  halts_on Initialize s &
 LifeSpan(P +* stop (I ';' Goto (
card J + 1) ';' J),Initialize s) = LifeSpan(P +* stop I,Initialize s) + 1

proof
  let I be halt-free Program of SCMPDS, J be Program of SCMPDS, s be State
  of SCMPDS;
  assume
A1: I is_closed_on s,P;
  set G1=Goto (card J + 1), SS = Stop SCMPDS, J2 = G1 ';' J ';' SS, IJ=I ';'
G1 ';' J, pJ=stop IJ, s1 = Initialize s, P1 = P +* stop I,
  s2 = Initialize s;
  reconsider P2 = P +* pJ
   as (the Instructions of SCMPDS)-valued ManySortedSet of NAT;
  assume
A4: I is_halting_on s,P;
  set sm= Comput(P2, s2,LifeSpan(P1,s1));
A5: IJ =I ';' (G1 ';' J) by AFINSQ_1:30;
  then
A6: IC Comput(P1, s1,LifeSpan(P1,s1)) =IC sm by A1,A4
,Th39;
  then
A7: IC sm =  card I by A1,A4,Th43;
A8:  0 in dom G1 by Th33;
A9: J2. 0 = (G1 ';' (J ';' SS)). 0 by AFINSQ_1:30
    .=G1. 0 by A8,AFINSQ_1:def 4
    .=goto (card J + 1) by Th33;
  card (G1 ';' J) = card G1 + card J by AFINSQ_1:20
    .=1 + card J by SCMPDS_5:6;
  then
A11: J2. (card J + 1)=J2.(0+card (G1 ';' J))
    .=halt SCMPDS by Lm1,Lm2,AFINSQ_1:def 4;
A12: card J2 = card (G1 ';' (J ';' SS)) by AFINSQ_1:30
    .=card G1 + card (J ';' SS) by AFINSQ_1:20
    .= 1 + card (J ';' SS) by SCMPDS_5:6;
  then
A13:  0 in dom J2 by AFINSQ_1:70;
A14: pJ =I ';' G1 ';' J ';' SS
    .=I ';' (G1 ';' J) ';' SS by AFINSQ_1:30
    .=I ';' J2 by AFINSQ_1:30;
  then
A15: card pJ = card I + card J2 by AFINSQ_1:20;
  then card I + 0 < card pJ by XREAL_1:8;
  then
A16:  card I in dom pJ by AFINSQ_1:70;
A17: card SS = 1 by COMPOS_1:46;
A18: card J2 = 1 + (card J + card SS) by A12,AFINSQ_1:20
    .= card J + (1 + card SS);
  then card J + 1 < card J2 by A17,XREAL_1:8;
  then
A19:  (card J + 1) in dom J2 by AFINSQ_1:70;
  card pJ = card I + card J + 1 + 1 by A15,A18,A17;
  then card I + card J + 1 < card pJ by NAT_1:13;
  then
A20:  (card I + card J + 1) in dom pJ by AFINSQ_1:70;

A21:  P2/.IC Comput(P2,s2,LifeSpan(P1,s1))
 = P2.IC Comput(P2,s2,LifeSpan(P1,s1)) by PBOOLE:158;
A23: CurInstr(P2,Comput(P2,s2,LifeSpan(P1,s1)))
 = P2.card I by A1,A4,A6,Th43,A21

    .= P2. card I
    .= pJ. card I by A16,FUNCT_4:14
    .= (I ';' J2).(0+card I) by A14
    .= goto (card J + 1) by A13,A9,AFINSQ_1:def 4;
A24: now
    let a;
    thus Comput(P2, s2,LifeSpan(P1,s1) + 1).a = (Following(P2,sm)).a
    by EXTPRO_1:4
      .= sm.a by A23,SCMPDS_2:66;
  end;
A25:  P2/.IC Comput(P2, s2,LifeSpan(P1,s1) + 1)
 = P2.IC Comput(P2, s2,LifeSpan(P1,s1) + 1)
 by PBOOLE:158;
  thus IC Comput(P +* pJ, s2,LifeSpan(P1,s1) + 1) = IC
Following(P2,sm)
   by EXTPRO_1:4
    .= ICplusConst(sm,card J +1) by A23,SCMPDS_2:66
    .= (card I + (card J + 1)) by A7,Th23
    .= (card I + card J + 1);
  then
A27: CurInstr(P2,
       Comput(P2, s2,LifeSpan(P1,s1) + 1))
 = P2. (card I + card J
  + 1) by A25

    .= pJ. (card I + card J + 1) by A20,FUNCT_4:14
    .= (I ';' J2).(card I+(card J+1)) by A14
    .= halt SCMPDS by A19,A11,AFINSQ_1:def 4;
  DataPart Comput(P1, s1,LifeSpan(P1,s1)) = DataPart
sm by A1,A4,A5,Th39;

  hence DataPart Comput(P1, s1,LifeSpan(P1,s1)) =
DataPart Comput(P +* pJ, s2,LifeSpan(P1,s1) + 1)
by A24,SCMPDS_4:23;

  thus
A28:
   now
    let k be Element of NAT;
    assume
A30: k <= LifeSpan(P1,s1);
    per cases;
    suppose
A31:  k < LifeSpan(P1,s1);
      then CurInstr(P1,Comput(P1,s1,k))
       <> halt SCMPDS by A1,A4,Th42;

      hence CurInstr(P +* pJ,Comput(P +* pJ,s2,k)) <>
       halt SCMPDS by A1,A4,A5,A31,Th41;

    end;
    suppose
      LifeSpan(P1,s1) <= k;
      then k = LifeSpan(P1,s1) by A30,XXREAL_0:1;
      hence CurInstr(P +* pJ,Comput(P +* pJ,s2,k)) <>
       halt SCMPDS by A23;
    end;
  end;
  thus IC Comput(P +* pJ,s2,LifeSpan(P1,s1))
   =  card I by A1,A4,A6,Th43;
  thus
A32: P +* pJ halts_on s2 by A27,EXTPRO_1:30;
  now
    let k be Element of NAT;
    assume
    CurInstr(P2,Comput(P2,s2,k))
     = halt SCMPDS;
    then LifeSpan(P1,s1) < k by A28;
    hence LifeSpan(P1,s1)+1 <= k by INT_1:20;
  end;
  hence thesis by A27,A32,EXTPRO_1:def 14;
end;

theorem Th44:
  for I,J being Program of SCMPDS,s being State of SCMPDS st I
  is_closed_on s,P & I is_halting_on s,P holds I ';' Goto (card J + 1) ';' J
  is_halting_on s,P & I ';' Goto (card J + 1) ';' J is_closed_on s,P
proof
  let I,J be Program of SCMPDS,s be State of SCMPDS;
  set G = Goto (card J + 1), IJ = I ';' G ';' J, J2 = I ';' (G ';' J), pJ =
stop J2, pI =stop I, s1 = Initialize s, s2 = Initialize s,
  P1 = P +* pI, P2 = P +* pJ,
  m=LifeSpan(P1,s1), SS=Stop SCMPDS,
  s3= Comput(P1, s1,m), s4= Comput(P2, s2,m),
  P3= P1, P4 = P2;
A3: IJ=I ';' (G ';' J) by AFINSQ_1:30;
XX: I c= stop I by AFINSQ_1:78;
  pI c= P3 by FUNCT_4:26;
  then
A5: I c= P3 by XX,XBOOLE_1:1;
A6: dom pI c= dom pJ by SCMPDS_5:16;
  set JS=G ';' J ';' SS;
  reconsider n = IC s3 as Element of NAT;
A7: card pI=card I + 1 by SCMPDS_5:7;
  assume
A8: I is_closed_on s,P;
  then IC s3 in dom pI by Def2;
  then n < card I + 1 by A7,AFINSQ_1:70;
  then
A9: n <= card I by INT_1:20;
A10: pJ c= P2 by FUNCT_4:26;
A11: pJ =I ';' (G ';' J) ';' SS
    .=I ';' JS by AFINSQ_1:30;
  then I c= pJ by AFINSQ_1:78;
  then I c= P2 by A10,XBOOLE_1:1;
  then
A12: I c= P4;
  assume
A13: I is_halting_on s,P;
  then
A14: P1 halts_on s1 by Def3;
A15: P3/.IC s3
 = P3.IC s3 by PBOOLE:158;
A16:  P4/.IC s4
 = P4.IC s4 by PBOOLE:158;
  per cases;
  suppose
    IC s3 <>  card I;
    then n < card I by A9,XXREAL_0:1;
    then
A17: IC s3 in dom I by AFINSQ_1:70;
A20: halt SCMPDS=CurInstr(P1,s3) by A14,EXTPRO_1:def 14
      .=I.IC s3 by A5,A17,A15,GRFUNC_1:8
      .=P4.IC s3 by A12,A17,GRFUNC_1:8
      .=CurInstr(P4,s4) by A8,A13,Th39,A16;
    then
A21: P2 halts_on s2 by EXTPRO_1:30;
    hence IJ is_halting_on s,P by A3,Def3;
    now
      let k be Element of NAT;
      set C1k=IC Comput(P1, s1,k), C2k=IC Comput(P2
, s2,k);
      per cases;
      suppose
A22:    k <= m;
        C1k in dom pI by A8,Def2;
        then C1k in dom pJ by A6;
        hence C2k in dom pJ by A8,A13,A22,Th39;
      end;
      suppose
A23:    k > m;
        set m2=LifeSpan(P2,s2);
A24:    m2 <= m by A20,A21,EXTPRO_1:def 14;
        then C2k=IC Comput(P2, s2,m2) by A21,A23,Th3,XXREAL_0:2
          .=IC Comput(P1, s1,m2) by A8,A13,A24,Th39;
        then C2k in dom pI by A8,Def2;
        hence C2k in dom pJ by A6;
      end;
    end;
    hence thesis by A3,Def2;
  end;
  suppose
A25: IC s3 = card I;
    then
A26: IC s4= card I by A8,A13,Th39;
A27:  0 in dom G by Th33;
A28: card Stop SCMPDS = 1 by COMPOS_1:46;
A29: JS =G ';' (J ';' SS) by AFINSQ_1:30;
    then
A30: card JS =card G + card (J ';' SS) by AFINSQ_1:20
      .= 1 + card (J ';' SS) by SCMPDS_5:6
      .= card J + 1 + 1 by A28,AFINSQ_1:20;
    then
A31:  0 in dom JS by AFINSQ_1:70;
    card J + 1 < card JS by A30,NAT_1:13;
    then
A32:  (card J + 1) in dom JS by AFINSQ_1:70;
    card pJ = card I + (card J + (1 + 1)) by A11,A30,AFINSQ_1:20
      .= card I + card J + 1 + 1;
    then
A33: card I + card J + 1 < card pJ by NAT_1:13;
    then
A34:  (card I + card J + 1) in dom pJ by AFINSQ_1:70;
A35:  P4/.IC s4
 = P4.IC s4 by PBOOLE:158;
    card pJ = card I + card JS by A11,AFINSQ_1:20;
    then card I + 0 < card pJ by XREAL_1:8;
    then
A36:  card I in dom pJ by AFINSQ_1:70;
A37: CurInstr(P4,s4)= P4. card I by A8,A13,A25,Th39,A35
      .= P2. card I
      .= (I ';' JS).(0+card I) by A11,A10,A36,GRFUNC_1:8
      .= JS. 0 by A31,AFINSQ_1:def 4
      .=G. 0 by A29,A27,AFINSQ_1:def 4
      .=goto (card J + 1) by Th33;
    card (G ';' J) = card G + card J by AFINSQ_1:20
      .=1 + card J by SCMPDS_5:6;
    then
A38: JS. (card J + 1)=JS.(0+card (G ';' J))
      .=halt SCMPDS by Lm1,Lm2,AFINSQ_1:def 4;
A39:  P2/.IC Comput(P2,s2,m+1)
 = P2.IC Comput(P2,s2,m+1) by
PBOOLE:158;
A42: IC Comput(P2, s2,m + 1) = IC Following(P2,s4)
by EXTPRO_1:4
      .= ICplusConst(s4,card J +1) by A37,SCMPDS_2:66
      .= (card I + (card J + 1)) by A26,Th23
      .= (card I + card J + 1);
    then
A43: CurInstr(P2,Comput(P2,s2,m+1))
 = P2. (card I + card J + 1) by A39
      .= (I ';' JS).(card I+(card J+1)) by A11,A10,A34,GRFUNC_1:8
      .= halt SCMPDS by A32,A38,AFINSQ_1:def 4;
    then
A44: P2 halts_on s2 by EXTPRO_1:30;
    hence IJ is_halting_on s,P by A3,Def3;
    now
      let k be Element of NAT;
      set C1k=IC Comput(P1, s1,k), C2k=IC Comput(P2
, s2,k);
      per cases;
      suppose
A45:    k <= m;
        C1k in dom pI by A8,Def2;
        then C1k in dom pJ by A6;
        hence C2k in dom pJ by A8,A13,A45,Th39;
      end;
      suppose
A46:    k > m;
        set m2=LifeSpan(P2,s2);
A47:    m2 <= m+1 by A43,A44,EXTPRO_1:def 14;
        k >= m+1 by A46,INT_1:20;
        then C2k=IC Comput(P2, s2,m2) by A44,A47,Th3,XXREAL_0:2
          .= (card I + card J + 1) by A42,A44,A47,Th3;
        hence C2k in dom pJ by A33,AFINSQ_1:70;
      end;
    end;
    hence thesis by A3,Def2;
  end;
end;

theorem Th45:
  for I being shiftable Program of SCMPDS st
   Start-At(0,SCMPDS) c= s1 & stop I c= P1 & I is_closed_on s1,P1
  for n being Element of NAT st
   Shift(stop I,n) c= P2 & IC
  s2 =  n & DataPart s1 = DataPart s2 for i being Element of NAT holds IC
Comput(P1, s1,i) + n = IC Comput(P2, s2,i) &
 CurInstr(P1,Comput(P1,s1,i)) = CurInstr(P2,Comput(P2,s2,i)) &
  DataPart Comput(P1, s1,i) = DataPart Comput(P2, s2,i)
proof
  let I be shiftable Program of SCMPDS;
  set SI=stop I;
  assume that
Z: Start-At(0,SCMPDS) c= s1 and
A1: SI c= P1 and
A2: I is_closed_on s1,P1;
A0: Initialize s1 = s1 by Z,FUNCT_4:104;
  set S1 = s1, S2 = s2, E1 = P1, E2 = P2;
  let n be Element of NAT;
  defpred P[Element of NAT] means IC Comput(E1,S1,$1) + n = IC
Comput(E2,
  S2,$1) & CurInstr(E1,Comput(E1,S1,$1))
   = CurInstr(E2,Comput(E2,S2,$1)) &
  DataPart Comput(E1,S1,$1) = DataPart Comput(E2,S2,
$1);
  assume that
A5: Shift(SI,n) c= P2 and
A6: IC s2 =  n and
A7: DataPart s1 = DataPart s2;
  let i be Element of NAT;
A8: DataPart Comput(E1,S1,0) = DataPart s2 by A7,EXTPRO_1:3
    .= DataPart Comput(E2,S2,0) by EXTPRO_1:3;
A9:  0 in dom SI by COMPOS_1:135;
  then
A10:  (0 + n) in dom Shift(SI,n) by VALUED_1:25;
A12: P1.IC s1 = P1.IC Initialize s1 by A0
    .= P1. 0 by COMPOS_1:def 16
    .= SI. 0 by A1,A9,GRFUNC_1:8
    .= SI. 0;
A14: P1= P1 +* SI by A1,FUNCT_4:104;
A15: for k being Element of NAT st P[k] holds P[k + 1]
  proof
    let k be Element of NAT;
    assume
A16: P[k];
    reconsider m = IC Comput(E1,S1,k) as Element of NAT;
    set i = CurInstr(E1,Comput(
E1,S1,k));
A18: Comput(E1,S1,k+1) = Following(E1,Comput(E1,S1,k)) by EXTPRO_1:4
      .= Exec(CurInstr(E1,Comput(E1,S1,k)),
      Comput(E1,S1,k));
    reconsider l = IC Comput(E1,S1,k+1) as Element of NAT;
A19: IC Comput(E1,S1,k+1) in dom SI by A2,A14,Def2,A0;
    then
A20: l+n in dom Shift(SI,n) by VALUED_1:25;
A22: Comput(E2,S2,k+1) = Following(E2,Comput(E2,S2,k)) by EXTPRO_1:4
      .= Exec(CurInstr(E2,Comput(
E2,S2,k)),
      Comput(E2,S2,k));
A23: IC Comput(E1,S1,k) in dom SI by A2,A14,Def2,A0;
A24 : E1/.IC Comput(E1,S1,k)
 = E1.IC Comput(E1,S1,k) by PBOOLE:158;
A25: i = P1.IC Comput(E1,S1,k) by A24
      .= SI.IC Comput(E1,S1,k)
       by A1,A23,GRFUNC_1:8
      .= SI.IC Comput(E1,S1,k);
    then
A26: InsCode i <> 1 & InsCode i <> 3 by A23,SCMPDS_4:def 12;
A27: i valid_at m by A23,A25,SCMPDS_4:def 12;
    hence
A28: IC Comput(E1,S1,k+1) + n = IC Comput(E2,S2,k+1)
by A16,A18,A22,A26,SCMPDS_4:83;
A29: E1/.IC Comput(E1,S1,k+1)
 = E1.IC Comput(E1,S1,k+1) by
PBOOLE:158;
A30: E2/.IC Comput(E2,S2,k+1)
 = E2.IC Comput(E2,S2,k+1) by
PBOOLE:158;
    CurInstr(E1,Comput(E1,
S1,k+1)) = P1.l
     by A29
      .= SI.l by A1,A19,GRFUNC_1:8
      .= SI.l;
    hence CurInstr(E1,Comput(
E1,S1,k+1))
     = Shift(SI,n).(IC Comput(E2,S2,k+1))
    by A28,A19,VALUED_1:def 12
      .= P2.IC Comput(E2,S2,k+1) by A5,A28,A20,GRFUNC_1:8
      .= CurInstr(E2,Comput(E2,S2,k+1))
       by A30;
    thus thesis by A16,A18,A22,A26,A27,SCMPDS_4:83;
  end;
A31: IC Comput(E1,S1,0) = IC s1 by EXTPRO_1:3
    .= IC Initialize s1 by A0
    .=  0 by COMPOS_1:def 16;
A32: Comput(E1,S1,0) = S1 by EXTPRO_1:3;
A33: Comput(E2,S2,0) = S2 by EXTPRO_1:3;
A34:  P2/.IC s2
 = P2.IC s2 by PBOOLE:158;
A35:  P1/.IC s1
 = P1.IC s1 by PBOOLE:158;
  CurInstr(E1,Comput(E1,S1,0))
   = CurInstr(P1,s1) by A32
    .= Shift(SI,n).(0 + n) by A9,A12,A35,VALUED_1:def 12
    .= CurInstr(P2,s2) by A5,A6,A10,A34,GRFUNC_1:8
    .= CurInstr(E2,Comput(E2
,S2,0))
     by A33;
  then
A36: P[0] by A6,A31,A8,EXTPRO_1:3;
  for k being Element of NAT holds P[k] from NAT_1:sch 1(A36,A15);
  hence thesis;
end;

theorem Th46: ::SCMFSA8A:61
  for s being State of SCMPDS,I being halt-free Program of SCMPDS,
      J being Program of SCMPDS st I is_closed_on s,P & I is_halting_on s,P
  holds IC IExec(I ';' Goto (card J + 1) ';' J,P,s) = (card I + card J + 1)
proof
  let s be State of SCMPDS,I be halt-free Program of SCMPDS, J be Program of
  SCMPDS;
  set
   m= LifeSpan(P +* stop I,Initialize s)+1,
   G=Goto (card J + 1),
   s2 = Initialize s,
   P2 = P +* stop (I ';' G ';' J);
  assume
A1: I is_closed_on s,P & I is_halting_on s,P;
  then P2 halts_on s2 & LifeSpan(P2,s2) = m by Lm3;
  then IC Result(P2,s2) = IC Comput(P2, s2,m) by EXTPRO_1:23
    .=  (card I + card J + 1) by A1,Lm3;
  hence thesis by SCMPDS_5:22;
end;

theorem Th47: ::SCMFSA8A:62
  for s being State of SCMPDS,I being halt-free Program of
SCMPDS, J being Program of SCMPDS st I is_closed_on s,P & I is_halting_on s,P
 holds
IExec(I ';' Goto (card J + 1) ';' J,P,s) = IExec(I,P,s) +* Start-At((card I
  + card J + 1),SCMPDS)
proof
  let s be State of SCMPDS,I be halt-free Program of SCMPDS, J be Program of
  SCMPDS;
  set s1= Initialize s, P1 = P +* stop I,
      m= LifeSpan(P1,s1)+1, G=Goto (card J + 1), s2 =
  Initialize s,
  P2 = P +* stop (I ';' G ';' J),
  l=  (card I + card J + 1);
  assume that
A1: I is_closed_on s,P and
A2: I is_halting_on s,P;
A3: P1 halts_on s1 by A2,Def3;
  P2 halts_on s2 & LifeSpan(P2,s2) = m
   by A1,A2,Lm3;
  then
A4: Result(P2,s2) = Comput(P2, s2,m) by EXTPRO_1:23;
  then DataPart Result(P2,s2) = DataPart Comput(P1,s1,LifeSpan(P1,s1))
by A1,A2,Lm3;
  then
A5: DataPart Result(P2,s2) = DataPart Result(P1,s1) by A3,EXTPRO_1:23
    .= DataPart(Result(P1,s1) +* Start-At(l,SCMPDS)) by Th7;
  IC Result(P2,s2) = l by A1,A2,A4,Lm3
    .= IC(Result(P1,s1) +* Start-At(l,SCMPDS)) by FUNCT_4:121;
  then
A6: NPP Result(P2,s2) = NPP(Result(P1,s1) +* Start-At(l,SCMPDS)) by A5,Th4;
  dom ProgramPart s = A by COMPOS_1:34;
  then
A7: Result(P2,s2) +* s|A
  = Result(P1,s1) +* Start-At(l,SCMPDS) +* s|A
    by A6,COMPOS_1:238;
A8: dom(s|A) misses dom Start-At(l,SCMPDS) by COMPOS_1:130;
  thus IExec(I ';' G ';' J,P,s) = Result(P2,s2) +* s | A
    .= Result(P1,s1) +* (Start-At(l,SCMPDS) +* s | A) by A7,FUNCT_4:15
    .= Result(P1,s1) +* (s | A +* Start-At(l,SCMPDS)) by A8,FUNCT_4:36
    .= Result(P1,s1) +* s | A +* Start-At(l,SCMPDS) by FUNCT_4:15
    .= IExec(I,P,s) +* Start-At(l,SCMPDS);
end;

theorem Th48:
  for s being State of SCMPDS,I being halt-free Program of
  SCMPDS st I is_closed_on s,P & I is_halting_on s,P holds IC IExec(I,P,s) =
  card I
proof
  let s be State of SCMPDS,I be halt-free Program of SCMPDS;
  set s1=Initialize s, P1 = P +* stop I;
  assume that
A2: I is_closed_on s,P and
A3: I is_halting_on s,P;
A4: P1 halts_on s1 by A3,Def3;
  thus IC IExec(I,P,s) = IC Result(P1,s1) by SCMPDS_5:22
    .= IC Comput(P1, s1,LifeSpan(P1,s1)) by A4,
EXTPRO_1:23
    .= card I by A2,A3,Th43;
end;

begin :: The construction of conditional statements

definition
  let a be Int_position,k be Integer;
  let I,J be Program of SCMPDS;
  func if=0(a,k,I,J) -> Program of SCMPDS equals
  (a,k)<>0_goto (card I +2) ';'
  I ';' Goto (card J+1) ';' J;
  coherence;
  func if>0(a,k,I,J) -> Program of SCMPDS equals
  (a,k)<=0_goto (card I +2) ';'
  I ';' Goto (card J+1) ';' J;
  coherence;
  func if<0(a,k,I,J) -> Program of SCMPDS equals
  (a,k)>=0_goto (card I +2) ';'
  I ';' Goto (card J+1) ';' J;
  coherence;
end;

definition
  let a be Int_position,k be Integer;
  let I be Program of SCMPDS;
  func if=0(a,k,I) -> Program of SCMPDS equals
  (a,k)<>0_goto (card I +1) ';' I;
  coherence;
  func if<>0(a,k,I) -> Program of SCMPDS equals
  (a,k)<>0_goto 2 ';' goto (card
  I+1) ';' I;
  coherence;
  func if>0(a,k,I) -> Program of SCMPDS equals
  (a,k)<=0_goto (card I +1) ';' I;
  coherence;
  func if<=0(a,k,I) -> Program of SCMPDS equals
  (a,k)<=0_goto 2 ';' goto (card
  I+1) ';' I;
  coherence;
  func if<0(a,k,I) -> Program of SCMPDS equals
  (a,k)>=0_goto (card I +1) ';' I;
  coherence;
  func if>=0(a,k,I) -> Program of SCMPDS equals
  (a,k)>=0_goto 2 ';' goto (card
  I+1) ';' I;
  coherence;
end;

Lm4: card (i ';' I ';' Goto n ';' J) = card I + card J +2
proof
  set G=Goto n;

  thus card (i ';' I ';' G ';' J) =card (i ';' I ';' G) + card J by AFINSQ_1:20

    .=card (i ';' I) + card G + card J by AFINSQ_1:20
    .=card (i ';' I) + 1 + card J by SCMPDS_5:6
    .=card I +1 +1 +card J by Th15
    .=card I + card J +2;
end;

begin :: The computation of "if var=0 then block1 else block2"

theorem
  card if=0(a,k1,I,J) = card I + card J + 2 by Lm4;

theorem
   0 in dom if=0(a,k1,I,J) &  1 in dom if=0(a,k1,I,J)
proof
  set ci=card if=0(a,k1,I,J);
  ci=card I + card J +2 by Lm4;
  then 2 <= ci by NAT_1:12;
  then 1 < ci by XXREAL_0:2;
  hence thesis by AFINSQ_1:70;
end;

Lm5: (i ';' I ';' J ';' K). 0=i
proof
A1:  0 in dom Load i by SCMPDS_5:2;
  i ';' I ';' J ';' K =i ';' (I ';' J) ';' K by SCMPDS_4:50
    .=i ';' (I ';' J ';' K) by SCMPDS_4:50
    .=Load i ';' (I ';' J ';' K);
  hence (i ';' I ';' J ';' K). 0 =(Load i). 0 by A1,AFINSQ_1:def 4
    .=i by SCMPDS_5:4;
end;

theorem
  if=0(a,k1,I,J). 0 = (a,k1)<>0_goto (card I + 2) by Lm5;

Lm6: Shift(stop I,1) c= P +* stop(i ';' I)
proof
  set pI=stop I, iI=i ';' I, piI=stop iI, P3=P+*piI;
  card Load i=1 & iI=(Load i) ';' I by SCMPDS_5:6;
  then
A1: Shift(pI,1) c= piI by Th24;
  piI c= P3 by FUNCT_4:26;
  then Shift(pI,1) c= P3 by A1,XBOOLE_1:1;
  hence thesis;
end;

Lm7: Shift(stop I,2) c= P+* stop(i ';' j ';' I)
proof
  set pI=stop I, pjI=stop (i ';' j ';' I), P3=P+*pjI;
  card (i ';' j)=card (Load i ';' Load j)
    .=card Load i + card Load j by AFINSQ_1:20
    .=1+ card Load j by SCMPDS_5:6
    .=1+1 by SCMPDS_5:6;
  then
A2: Shift(pI,2) c= pjI by Th24;
  pjI c= P3 by FUNCT_4:26;
  then Shift(pI,2) c= P3 by A2,XBOOLE_1:1;
  hence thesis;
end;

theorem Th52:
  for s being State of SCMPDS, I,J being shiftable Program of
  SCMPDS, a being Int_position,k1 being Integer st s.DataLoc(s.a,k1)= 0 & I
is_closed_on s,P & I is_halting_on s,P holds if=0(a,k1,I,J) is_closed_on s,P
 & if=0(a,k1,I,J) is_halting_on s,P
proof
  let s be State of SCMPDS, I,J be shiftable Program of SCMPDS, a be
  Int_position,k1 be Integer;
  set b=DataLoc(s.a,k1);
  assume
A1: s.b = 0;
  set i = (a,k1)<>0_goto (card I + 2);
  set G=Goto (card J+1);
  set I2 = I ';' G ';' J, IF=if=0(a,k1,I,J), pIF=stop IF,
   pI2=stop I2, s2 = Initialize s, P2 = P +* pI2,
  s3 = Initialize s, P3 = P +* pIF,
  s4 = Comput(P3,s3,1),
  P4 = P3;
A4: IC s3 = 0 by COMPOS_1:223;
A5: not b in dom Start-At(0,SCMPDS) by SCMPDS_4:59;
A6: IF = i ';' (I ';' G) ';' J by SCMPDS_4:50
    .= i ';' I2 by SCMPDS_4:50;
  then
A7: Shift(pI2,1) c= P4 by Lm6;
A8: Comput(P3, s3,0 + 1) = Following(P3,
Comput(P3,s3,0)) by EXTPRO_1:4
    .= Following(P3,s3) by EXTPRO_1:3
    .= Exec(i,s3) by A6,Th22;
  now
    let a;
    thus s2.a = s3.a
      .= s4.a by A8,SCMPDS_2:67;
  end;
  then
A10: DataPart s2 = DataPart s4 by SCMPDS_4:23;
  not a in dom Start-At(0,SCMPDS) by SCMPDS_4:59;
  then s3.DataLoc(s3.a,k1)=s3.b by FUNCT_4:12
    .=0 by A1,A5,FUNCT_4:12;
  then
A11: IC s4 = succ IC s3 by A8,SCMPDS_2:67
    .= (0+1) by A4;
A12:  0 in dom pIF by COMPOS_1:135;
  assume
A13: I is_closed_on s,P;
  assume
A14: I is_halting_on s,P;
  then I2 is_halting_on s,P by A13,Th44;
  then
A15: P2 halts_on s2 by Def3;
A16: I2 is_closed_on s,P by A13,A14,Th44;
  then
A17: Start-At(0,SCMPDS) c= s2 & I2 is_closed_on s2,P2 by Th38,FUNCT_4:26;
A18: card pIF = card IF +1 by SCMPDS_5:7
    .= card I2 +1+1 by A6,Th15;
UU:  stop I2 c= P2 by FUNCT_4:26;
  now
    let k be Element of NAT;
    per cases;
    suppose
      0 < k;
      then consider k1 being Nat such that
A19:  k1 + 1 = k by NAT_1:6;
      reconsider k1 as Element of NAT by ORDINAL1:def 13;
      reconsider m = IC Comput(P2, s2,k1) as Element of NAT;
A20:  card pIF = card pI2+1 by A18,SCMPDS_5:7;
       m in dom pI2 by A16,Def2;
      then m < card pI2 by AFINSQ_1:70;
      then
A21:  m+1 < card pIF by A20,XREAL_1:8;
     IC Comput(P3,s3,k) = IC Comput(P3, s4,k1) by A19,EXTPRO_1:5
        .= m + 1 by A17,A7,A11,A10,Th45,UU;
      hence IC Comput(P3,s3,k) in dom pIF by A21,AFINSQ_1:70;
    end;
    suppose
      k = 0;
      hence IC Comput(P3,s3,k) in dom pIF by A12,A4,EXTPRO_1:3;
    end;
  end;
  hence IF is_closed_on s,P by Def2;
A24: Comput(P3,s3,LifeSpan(P2,s2)+1)
 = Comput(P3,Comput(P3,s3,1),LifeSpan(P2
,s2))
by EXTPRO_1:5;
  CurInstr(P3,Comput(P3,s3,LifeSpan(P2,s2)+1))
   =CurInstr(P4,Comput(P4,s4,LifeSpan(P2,s2))) by A24
    .=CurInstr(P2,Comput(P2,s2,LifeSpan(P2,s2))) by A17,A7,A11,A10
,Th45,UU
    .= halt SCMPDS by A15,EXTPRO_1:def 14;
  then P3 halts_on s3 by EXTPRO_1:30;
  hence thesis by Def3;
end;

theorem Th53:
  for s being State of SCMPDS,I being Program of SCMPDS,J being
shiftable Program of SCMPDS,a being Int_position,k1 being Integer st s.DataLoc(
  s.a,k1)<> 0 & J is_closed_on s,P & J is_halting_on s,P holds if=0(a,k1,I,J)
  is_closed_on s,P & if=0(a,k1,I,J) is_halting_on s,P
proof
  let s be State of SCMPDS,I be Program of SCMPDS, J be shiftable Program of
  SCMPDS, a be Int_position,k1 be Integer;
  set b=DataLoc(s.a,k1);
  set pJ=stop J, s1 = Initialize s, P1 = P +* pJ,
  IF=if=0(a,k1,I,J), pIF=
  stop IF, s3 = Initialize s, P3 = P +* pIF,
  s4 = Comput(P3,s3,1), P4 = P3;
  set i = (a,k1)<>0_goto (card I + 2);
  set G =Goto (card J+1), iG=i ';' I ';' G;
A3: IF = i ';' (I ';' G) ';' J by SCMPDS_4:50
    .= i ';' (I ';' G ';' J) by SCMPDS_4:50;
A4: Comput(P3, s3,0 + 1) = Following(P3,
Comput(P3,s3,0)) by EXTPRO_1:4
    .= Following(P3,s3) by EXTPRO_1:3
    .= Exec(i,s3) by A3,Th22;
A5: not b in dom Start-At(0,SCMPDS) by SCMPDS_4:59;
  not a in dom Start-At(0,SCMPDS) by SCMPDS_4:59;
  then
A6: s3.DataLoc(s3.a,k1)=s3.b by FUNCT_4:12
    .= s.b by A5,FUNCT_4:12;
A7: IC s3 = 0 by COMPOS_1:223;
  assume
  s.b <> 0;
  then
A8: IC s4 = ICplusConst(s3,card I + 2) by A4,A6,SCMPDS_2:67
    .= (0+(card I + 2)) by A7,Th23;
  assume
A9: J is_closed_on s,P;
  then
A10: Start-At(0,SCMPDS) c= s1 & J is_closed_on s1,P1 by Th38,FUNCT_4:26;
A11: pIF c= P3 by FUNCT_4:26;
A12: card iG = card (i ';' I) + card G by AFINSQ_1:20
    .=card (i ';' I) + 1 by SCMPDS_5:6
    .=card I +1 +1 by Th15
    .=card I +(1 +1);
  then Shift(pJ,card I+2) c= pIF by Th24;
  then
A13: Shift(pJ,card I+2) c= P4 by A11,XBOOLE_1:1;
  assume
  J is_halting_on s,P;
  then
A14: P1 halts_on s1 by Def3;
  now
    let a;
    thus s1.a = s3.a
      .= s4.a by A4,SCMPDS_2:67;
  end;
  then
A16: DataPart s1 = DataPart s4 by SCMPDS_4:23;
UU:  pJ c= P1 by FUNCT_4:26;
  now
    let k be Element of NAT;
    per cases;
    suppose
      0 < k;
      then consider k1 being Nat such that
A17:  k1 + 1 = k by NAT_1:6;
      reconsider k1 as Element of NAT by ORDINAL1:def 13;
      reconsider m = IC Comput(P1, s1,k1) as Element of NAT;
       m in dom pJ by A9,Def2;
      then m < card pJ by AFINSQ_1:70;
      then
A18:  m + (card I + 2) < card pJ + (card I + 2) by XREAL_1:8;
A19:  card pJ = card J + 1 by SCMPDS_5:7;
A20:  card pIF = card IF+1 by SCMPDS_5:7
        .=card I +2 +card J +1 by A12,AFINSQ_1:20
        .=card I +2 + card pJ by A19;
      IC Comput(P3,s3,k) = IC Comput(P3, s4,k1) by
A17,EXTPRO_1:5
        .=  (m + (card I + 2)) by A10,A16,A13,A8,Th45,UU;
      hence IC Comput(P3,s3,k) in dom pIF by A20,A18,AFINSQ_1:70;
    end;
    suppose
      k = 0;
      then Comput(P3,s3,k) = s3 by EXTPRO_1:3;
      hence IC Comput(P3,s3,k) in dom pIF by A7,COMPOS_1:135;
    end;
  end;
  hence IF is_closed_on s,P by Def2;
A23: Comput(P3,s3,LifeSpan(P1,s1)+1)
= Comput(P3,Comput(P3,s3,1),LifeSpan(P1,
s1))
 by EXTPRO_1:5;
  CurInstr(P3,
  Comput(P3,s3,LifeSpan(P1,s1)+1))
   =CurInstr(P4,
   Comput(P4,s4,LifeSpan(P1,s1))) by A23
    .=CurInstr(P1,
    Comput(P1,s1,LifeSpan(P1,s1))) by A10,A16,A13,A8
,Th45,UU
    .= halt SCMPDS by A14,EXTPRO_1:def 14;
  then P3 halts_on s3 by EXTPRO_1:30;
  hence thesis by Def3;
end;

theorem Th54:
  for s being State of SCMPDS,I being halt-free shiftable
Program of SCMPDS, J being shiftable Program of SCMPDS,a being Int_position,k1
  being Integer st s.DataLoc(s.a,k1)= 0 & I is_closed_on s,P &
  I is_halting_on s,P
holds IExec(if=0(a,k1,I,J),P,s) = IExec(I,P,s) +* Start-At((card I + card J
  + 2),SCMPDS)
proof
  let s be State of SCMPDS,I be halt-free shiftable Program of SCMPDS, J be
  shiftable Program of SCMPDS,a be Int_position,k1 be Integer;
  set b=DataLoc(s.a,k1);
  assume
A1: s.b = 0;
  set i = (a,k1)<>0_goto (card I + 2);
  set G=Goto (card J+1);
  set I2 = I ';' G ';' J, IF=if=0(a,k1,I,J), pI2=
stop I2, s2 = Initialize s, s3 = Initialize s,
  P2 = P +* pI2, P3 = P +* stop IF,
  s4 = Comput(P3,s3,1), P4 = P3;
A4: IC s3 = 0 by COMPOS_1:223;
A5: not b in dom Start-At(0,SCMPDS) by SCMPDS_4:59;
A6: IF = i ';' (I ';' G) ';' J by SCMPDS_4:50
    .= i ';' I2 by SCMPDS_4:50;
  then
A7: Shift(pI2,1) c= P4 by Lm6;
A8: Comput(P3, s3,0 + 1) = Following(P3,Comput(P3,s3,0)) by EXTPRO_1:4
    .= Following(P3,s3) by EXTPRO_1:3
    .= Exec(i,s3) by A6,Th22;
  not a in dom Start-At(0,SCMPDS) by SCMPDS_4:59;
  then s3.DataLoc(s3.a,k1)=s3.b by FUNCT_4:12
    .=0 by A1,A5,FUNCT_4:12;
  then
A9: IC s4 = succ IC s3 by A8,SCMPDS_2:67
    .= (0+1) by A4;
  now
    let a;
    thus s2.a = s3.a
      .= s4.a by A8,SCMPDS_2:67;
  end;
  then
A11: DataPart s2 = DataPart s4 by SCMPDS_4:23;
A12: dom ProgramPart s = A by COMPOS_1:34;
  set SAl= Start-At((card I + card J + 2),SCMPDS);
  assume
A13: I is_closed_on s,P;
  assume
A14: I is_halting_on s,P;
  then I2 is_halting_on s,P by A13,Th44;
  then
A15: P2 halts_on s2 by Def3;
  I2 is_closed_on s,P by A13,A14,Th44;
  then
A16: Start-At(0,SCMPDS) c= s2 & I2 is_closed_on s2,P2 by Th38,FUNCT_4:26;
UU:  stop I2 c= P2 by FUNCT_4:26;
A18: Comput(P3,s3,LifeSpan(P2,s2)+1)
 = Comput(P3,Comput(P3,s3,1),LifeSpan(P2,s2))
 by EXTPRO_1:5;
A21: CurInstr(P3,
Comput(P3,s3,LifeSpan(P2,s2)+1))
 =CurInstr(P3,
 Comput(P3,s4,LifeSpan(P2,s2))) by A18
    .=CurInstr(P2,
    Comput(P2,s2,LifeSpan(P2,s2))) by A16,A7,A9,A11
,Th45,UU
    .= halt SCMPDS by A15,EXTPRO_1:def 14;
  then
A22: P3 halts_on s3 by EXTPRO_1:30;
A23: CurInstr(P3,s3) = i by A6,Th22;
  now
    let l be Element of NAT;
    assume
A24: l < LifeSpan(P2,s2) + 1;
A25: Comput(P3,s3,0) = s3 by EXTPRO_1:3;
    per cases;
    suppose
      l = 0;
      then CurInstr(P3,Comput(P3,s3,l)) =
      CurInstr(P3,s3)
       by A25;
      hence CurInstr(P3,Comput(P3,s3,l)) <>
      halt SCMPDS by A23;
    end;
    suppose
      l <> 0;
      then consider n be Nat such that
A26:  l = n + 1 by NAT_1:6;
      reconsider n as Element of NAT by ORDINAL1:def 13;
A27:  n < LifeSpan(P2,s2) by A24,A26,XREAL_1:8;
      assume
A28:  CurInstr(P3,Comput(P3,s3,l)) = halt SCMPDS;
A32: Comput(P3,s3,n+1)
 = Comput(P3,Comput(P3,s3,1),n) by EXTPRO_1:5;
      CurInstr(P2,Comput(P2,s2,n))
       = CurInstr(P3,Comput(P3,s4,n))
       by A16,A7,A9,A11,Th45,UU
        .= halt SCMPDS by A26,A28,A32;
      hence contradiction by A15,A27,EXTPRO_1:def 14;
    end;
  end;
  then for l be Element of NAT st CurInstr(P3,
  Comput(P3,s3,l)) = halt SCMPDS
  holds LifeSpan(P2,s2) + 1 <= l;
  then
A33: LifeSpan(P3,s3) = LifeSpan(P2,s2) + 1 by A21,A22
,EXTPRO_1:def 14;
A35: DataPart Result(P2,s2) = DataPart Comput(P2, s2
,LifeSpan(P2,s2)) by A15,EXTPRO_1:23
    .= DataPart Comput(P3, s4,LifeSpan(P2,s2)) by A16
,A7,A9,A11,Th45,UU
    .= DataPart Comput(P3, s3,LifeSpan(P2,s2) + 1)
by EXTPRO_1:5
    .= DataPart Result(P3,s3) by A22,A33,EXTPRO_1:23;
A36: now
    let x be set;
A37: dom SAl = {IC SCMPDS} by FUNCOP_1:19;
    assume
A38: x in dom IExec(IF,P,s);
    per cases by A38,SCMPDS_4:20;
    suppose
A39:  x is Int_position;
      then x <> IC SCMPDS by SCMPDS_2:52;
      then
A40:  not x in dom SAl by A37,TARSKI:def 1;
A41: not x in dom (s | A) by A12,A39,SCMPDS_2:53;
      hence IExec(IF,P,s).x = (Result(P3,s3)).x by FUNCT_4:12
        .= (Result(P2,s2)).x by A35,A39,SCMPDS_4:23
        .= IExec(I2,P,s).x by A41,FUNCT_4:12
        .= (IExec(I2,P,s) +* SAl).x by A40,FUNCT_4:12;
    end;
    suppose
A42:  x = IC SCMPDS;
A43: not x in dom (s | A) by A12,A42,COMPOS_1:3;
      then
A44:  IC Result(P2,s2) = IC IExec(I2,P,s) by A42,FUNCT_4:12
        .=  (card I + card J + 1) by A13,A14,Th46;
A45:  x in dom SAl by A37,A42,TARSKI:def 1;
      thus IExec(IF,P,s).x = (Result(P3,s3)).x by A43,FUNCT_4:12
        .= Comput(P3, s3,LifeSpan(P2,s2) + 1).x by
A22,A33,EXTPRO_1:23
        .= IC Comput(P3, s4,LifeSpan(P2,s2)) by A42,
EXTPRO_1:5
        .= IC Comput(P2, s2,LifeSpan(P2,s2)) + 1
        by A16,A7,A9,A11,Th45,UU
        .= IC Result(P2,s2) + 1 by A15,EXTPRO_1:23
        .= IC Start-At ((card I + card J + 1) + 1,SCMPDS)
        by A44,FUNCOP_1:87
        .= (IExec(I2,P,s) +* SAl).x by A42,A45,FUNCT_4:14;
    end;
    suppose
      x is Element of NAT;
      hence IExec(IF,P,s).x = (IExec(I2,P,s) +* SAl).x by Th26;
    end;
  end;
  dom IExec(IF,P,s) = the carrier of SCMPDS by PARTFUN1:def 4
    .= dom (IExec(I2,P,s) +* SAl) by PARTFUN1:def 4;
  hence IExec(IF,P,s) = IExec(I2,P,s) +* SAl by A36,FUNCT_1:9
    .= IExec(I,P,s) +* Start-At((card I+card J+1),SCMPDS) +* Start-At(
   (card I + card J + 2),SCMPDS) by A13,A14,Th47
    .= IExec(I,P,s) +* SAl by COMPOS_1:199;
end;

theorem Th55:
  for s being State of SCMPDS,I being Program of SCMPDS,J being
  halt-free shiftable Program of SCMPDS,a being Int_position,k1 being Integer
  st s.DataLoc(s.a,k1)<> 0 & J is_closed_on s,P & J is_halting_on s,P
   holds IExec(if=0(a,k1,I,J),P,s) = IExec(J,P,s) +*
  Start-At((card I + card J + 2),SCMPDS)
proof
  let s be State of SCMPDS,I be Program of SCMPDS,J be halt-free shiftable
  Program of SCMPDS,a be Int_position,k1 be Integer;
  set b=DataLoc(s.a,k1);
  set pJ=stop J, s1 = Initialize s, P1 = P +* pJ,
  P2 = P +* pJ,
  IF=if=0(a,k1,I,J), pIF=
  stop IF, s3 = Initialize s, P3 = P +* pIF,
  s4 = Comput(P3,s3,1), P4 = P3;
  set i = (a,k1)<>0_goto (card I + 2);
  set G =Goto (card J+1), iG=i ';' I ';' G;
  set SAl=Start-At((card I+card J+2),SCMPDS);
A3: IF = i ';' (I ';' G) ';' J by SCMPDS_4:50
    .= i ';' (I ';' G ';' J) by SCMPDS_4:50;
A4: Comput(P3, s3,0 + 1) = Following(P3,
Comput(P3,s3,0)) by EXTPRO_1:4
    .= Following(P3,s3) by EXTPRO_1:3
    .= Exec(i,s3) by A3,Th22;
A5: not b in dom Start-At(0,SCMPDS) by SCMPDS_4:59;
  not a in dom Start-At(0,SCMPDS) by SCMPDS_4:59;
  then
A6: s3.DataLoc(s3.a,k1)=s3.b by FUNCT_4:12
    .= s.b by A5,FUNCT_4:12;
A7: IC s3 = 0 by COMPOS_1:223;
A8: dom ProgramPart s = A by COMPOS_1:34;
  assume
  s.b <> 0;
  then
A9: IC s4 = ICplusConst(s3,card I + 2) by A4,A6,SCMPDS_2:67
    .= (0+(card I + 2)) by A7,Th23;
  now
    let a;
    thus s1.a = s3.a
      .= s4.a by A4,SCMPDS_2:67;
  end;
  then
A11: DataPart s1 = DataPart s4 by SCMPDS_4:23;
  card iG = card (i ';' I) + card G by AFINSQ_1:20
    .=card (i ';' I) + 1 by SCMPDS_5:6
    .=card I +1 +1 by Th15
    .=card I +(1 +1);
  then
A12: Shift(pJ,card I+2) c= pIF by Th24;
  pIF c= P3 by FUNCT_4:26;
  then Shift(pJ,card I+2) c= P3 by A12,XBOOLE_1:1;
  then
A13: Shift(pJ,card I+2) c= P4;
  assume
A14: J is_closed_on s,P;
  then
A15: Start-At(0,SCMPDS) c= s1 & J is_closed_on s1,P1 by Th38,FUNCT_4:26;
UU:  stop J c= P1 by FUNCT_4:26;
  assume
A16: J is_halting_on s,P;
  then
A17: P1 halts_on s1 by Def3;
A19: Comput(P3,s3,LifeSpan(P1,s1)+1) =
Comput(P3,Comput(P3,s3,1),LifeSpan(P1,s1
))
 by EXTPRO_1:5;
A22: CurInstr(P3,
Comput(P3,s3,LifeSpan(P1,s1)+1))
 =CurInstr(P3,
 Comput(P3,s4,LifeSpan(P1,s1))) by A19
    .=CurInstr(P1,
    Comput(P1,s1,LifeSpan(P1,s1))) by A15,A13,A9,A11
,Th45,UU
    .= halt SCMPDS by A17,EXTPRO_1:def 14;
  then
A23: P3 halts_on s3 by EXTPRO_1:30;
A24: CurInstr(P3,s3) = i by A3,Th22;
  now
    let l be Element of NAT;
    assume
A25: l < LifeSpan(P1,s1) + 1;
A26: Comput(P3,s3,0) = s3 by EXTPRO_1:3;
    per cases;
    suppose
      l = 0;
      then CurInstr(P3,Comput(P3,s3,l))
       = CurInstr(P3,s3)
       by A26;
      hence CurInstr(P3,Comput(P3,s3,l)) <>
       halt SCMPDS by A24;
    end;
    suppose
      l <> 0;
      then consider n be Nat such that
A27:  l = n + 1 by NAT_1:6;
      reconsider n as Element of NAT by ORDINAL1:def 13;
A28:  n < LifeSpan(P1,s1) by A25,A27,XREAL_1:8;
      assume
A29:  CurInstr(P3,Comput(P3,s3,l)) = halt SCMPDS;
A31: Comput(P3,s3,n+1) =
Comput(P3,Comput(P3,s3,1),n) by EXTPRO_1:5;
      CurInstr(P1,Comput(P1,
s1,n))
       = CurInstr(P3,
      Comput(P3,s4,n)) by A15,A13,A9,A11,Th45,UU
        .= halt SCMPDS by A27,A29,A31;
      hence contradiction by A17,A28,EXTPRO_1:def 14;
    end;
  end;
  then for l be Element of NAT st CurInstr(P3,
  Comput(P3,s3,l)) = halt SCMPDS
  holds LifeSpan(P1,s1) + 1 <= l;
  then
A34: LifeSpan(P3,s3) = LifeSpan(P1,s1) + 1 by A22,A23
,EXTPRO_1:def 14;
A35: DataPart Result(P1,s1) = DataPart Comput(P1, s1
,LifeSpan(P1,s1)) by A17,EXTPRO_1:23
    .= DataPart Comput(P3, s4,LifeSpan(P1,s1))
    by A15,A13,A9,A11,Th45,UU
    .= DataPart Comput(P3, s3,LifeSpan(P1,s1) + 1)
    by EXTPRO_1:5
    .= DataPart Result(P3,s3) by A23,A34,EXTPRO_1:23;
A36: now
    let x be set;
A37: dom SAl = {IC SCMPDS} by FUNCOP_1:19;
    assume
A38: x in dom IExec(IF,P,s);
    per cases by A38,SCMPDS_4:20;
    suppose
A39:  x is Int_position;
      then x <> IC SCMPDS by SCMPDS_2:52;
      then
A40:  not x in dom SAl by A37,TARSKI:def 1;
A41: not x in dom (s | A) by A8,A39,SCMPDS_2:53;
      hence IExec(IF,P,s).x = (Result(P3,s3)).x by FUNCT_4:12
        .= (Result(P1,s1)).x by A35,A39,SCMPDS_4:23
        .= IExec(J,P,s).x by A41,FUNCT_4:12
        .= (IExec(J,P,s) +* SAl).x by A40,FUNCT_4:12;
    end;
    suppose
A42:  x = IC SCMPDS;
A43: not x in dom (s | A) by A8,A42,COMPOS_1:3;
      then
A44:  IC Result(P1,s1) = IC IExec(J,P,s) by A42,FUNCT_4:12
        .=  (card J) by A14,A16,Th48;
A46:  x in dom SAl by A37,A42,TARSKI:def 1;
      thus IExec(IF,P,s).x = (Result(P3,s3)).x by A43,FUNCT_4:12
        .= Comput(P3, s3,LifeSpan(P1,s1) + 1).x by
A23,A34,EXTPRO_1:23
        .= IC Comput(P3, s4,LifeSpan(P1,s1)) by A42,
EXTPRO_1:5
        .= IC Comput(P1, s1,LifeSpan(P1,s1)) + (card
I + 2) by A15,A13,A9,A11,Th45,UU
        .= IC Result(P1,s1) + (card I + 2) by A17,EXTPRO_1:23
        .= IC Start-At (card J + (card I + 2),SCMPDS) by A44,
FUNCOP_1:87
        .= (IExec(J,P,s) +* SAl).x by A42,A46,FUNCT_4:14;
    end;
    suppose
      x is Element of NAT;
      hence IExec(IF,P,s).x = (IExec(J,P,s) +* SAl).x by Th26;
    end;
  end;
  dom IExec(IF,P,s) = the carrier of SCMPDS by PARTFUN1:def 4
    .= dom (IExec(J,P,s) +* SAl) by PARTFUN1:def 4;
  hence thesis by A36,FUNCT_1:9;
end;

registration
  let I,J be shiftable parahalting Program of SCMPDS, a be Int_position,k1 be
  Integer;
  cluster if=0(a,k1,I,J) -> shiftable parahalting;
  correctness
  proof
    set i = (a,k1)<>0_goto (card I + 2), G =Goto (card J+1);
    set IF=if=0(a,k1,I,J), IsIF=Initialize stop IF;
    reconsider IJ=I ';' G ';' J as shiftable Program of SCMPDS;
    thus IF is shiftable;
      let s be 0-started State of SCMPDS;
      let P be (the Instructions of SCMPDS)-valued ManySortedSet of NAT;
A1:  Initialize s = s by COMPOS_1:78;
      assume stop IF c= P;
      then
A2:   P = P +* stop IF by FUNCT_4:104;
A3:   J is_closed_on s,P & J is_halting_on s,P by Th34,Th35;
A4:   I is_closed_on s,P & I is_halting_on s,P by Th34,Th35;
      per cases;
      suppose
        s.DataLoc(s.a,k1)= 0;
        then IF is_halting_on s,P by A4,Th52;
        hence P halts_on s by A1,A2,Def3;
      end;
      suppose
        s.DataLoc(s.a,k1) <> 0;
        then IF is_halting_on s,P by A3,Th53;
        hence P halts_on s by A1,A2,Def3;
      end;
  end;
end;

registration
  let I,J be halt-free Program of SCMPDS, a be Int_position,k1 be Integer;
  cluster if=0(a,k1,I,J) -> halt-free;
  coherence;
end;

theorem
  for s being State of SCMPDS,I,J being halt-free shiftable
  parahalting Program of SCMPDS,a being Int_position,k1 being Integer holds IC
  IExec(if=0(a,k1,I,J),P,s) =  (card I + card J + 2)
proof
  let s be State of SCMPDS,I,J be halt-free shiftable parahalting Program of
  SCMPDS,a be Int_position,k1 be Integer;
  set IF=if=0(a,k1,I,J);
A1: J is_closed_on s,P & J is_halting_on s,P by Th34,Th35;
A2: I is_closed_on s,P & I is_halting_on s,P by Th34,Th35;
  hereby
    per cases;
    suppose
      s.DataLoc(s.a,k1) = 0;
      then
      IExec(IF,P,s) = IExec(I,P,s) +* Start-At((card I+card J+2),SCMPDS)
      by A2,Th54;
      hence thesis by FUNCT_4:121;
    end;
    suppose
      s.DataLoc(s.a,k1) <> 0;
      then
      IExec(IF,P,s) = IExec(J,P,s) +* Start-At((card I+card J+2),SCMPDS)
      by A1,Th55;
      hence thesis by FUNCT_4:121;
    end;
  end;
end;

theorem
  for s being State of SCMPDS,I being halt-free shiftable parahalting
  Program of SCMPDS,J being shiftable Program of SCMPDS,a,b being Int_position,
  k1 being Integer st s.DataLoc(s.a,k1)= 0 holds IExec(if=0(a,k1,I,J),P,s).b =
  IExec(I,P,s).b
proof
  let s be State of SCMPDS,I be halt-free shiftable parahalting Program of
  SCMPDS,J be shiftable Program of SCMPDS,a,b be Int_position, k1 be Integer;
  assume
A1: s.DataLoc(s.a,k1)=0;
A2: not b in dom Start-At((card I+card J+2),SCMPDS) by SCMPDS_4:59;
  I is_closed_on s,P & I is_halting_on s,P by Th34,Th35;
  then
  IExec(if=0(a,k1,I,J),P,s) = IExec(I,P,s) +* Start-At((card I + card J
  + 2),SCMPDS) by A1,Th54;
  hence thesis by A2,FUNCT_4:12;
end;

theorem
  for s being State of SCMPDS,I being Program of SCMPDS,J being
  halt-free parahalting shiftable Program of SCMPDS,a,b being Int_position,k1
being Integer st s.DataLoc(s.a,k1)<> 0 holds IExec(if=0(a,k1,I,J),P,s).b
 = IExec(J,P,s).b
proof
  let s be State of SCMPDS,I be Program of SCMPDS,J be halt-free parahalting
  shiftable Program of SCMPDS,a,b be Int_position, k1 be Integer;
  assume
A1: s.DataLoc(s.a,k1)<>0;
A2: not b in dom Start-At((card I+card J+2),SCMPDS) by SCMPDS_4:59;
  J is_closed_on s,P & J is_halting_on s,P by Th34,Th35;
  then
  IExec(if=0(a,k1,I,J),P,s) = IExec(J,P,s) +* Start-At((card I + card J
  + 2),SCMPDS) by A1,Th55;
  hence thesis by A2,FUNCT_4:12;
end;

begin :: The computation of "if var=0 then block"

theorem
  card if=0(a,k1,I) = card I + 1 by Th15;

theorem
   0 in dom if=0(a,k1,I)
proof
  set ci=card if=0(a,k1,I);
  ci=card I + 1 by Th15;
  hence thesis by AFINSQ_1:70;
end;

theorem
  if=0(a,k1,I). 0 = (a,k1)<>0_goto (card I + 1) by Th16;

theorem Th62:
  for s being State of SCMPDS, I being shiftable Program of SCMPDS
  , a being Int_position,k1 being Integer st s.DataLoc(s.a,k1)= 0 & I
is_closed_on s,P & I is_halting_on s,P holds if=0(a,k1,I) is_closed_on s,P
 & if=0(a,
  k1,I) is_halting_on s,P
proof
  let s be State of SCMPDS, I be shiftable Program of SCMPDS, a be
  Int_position,k1 be Integer;
  set b=DataLoc(s.a,k1);
  assume
A1: s.b = 0;
  set i = (a,k1)<>0_goto (card I + 1);
  set IF=if=0(a,k1,I), pIF=stop IF, pI=stop I,
  s2 = Initialize s, s3 = Initialize s,
  P2 = P +* pI, P3 = P +* pIF,
  s4 = Comput(P3,s3,1), P4 = P3;
A4: IC s3 = 0 by COMPOS_1:223;
A5: not b in dom Start-At(0,SCMPDS) by SCMPDS_4:59;
A6: Comput(P3, s3,0 + 1) = Following(P3,
Comput(P3,s3,0)) by EXTPRO_1:4
    .= Following(P3,s3) by EXTPRO_1:3
    .= Exec(i,s3) by Th22;
  now
    let a;
    thus s2.a = s3.a
      .= s4.a by A6,SCMPDS_2:67;
  end;
  then
A8: DataPart s2 = DataPart s4 by SCMPDS_4:23;
  not a in dom Start-At(0,SCMPDS) by SCMPDS_4:59;
  then s3.DataLoc(s3.a,k1)=s3.b by FUNCT_4:12
    .=0 by A1,A5,FUNCT_4:12;
  then
A9: IC s4 = succ IC s3 by A6,SCMPDS_2:67
    .= (0+1) by A4;
  assume
A10: I is_closed_on s,P;
  then
A11: I is_closed_on s2,P2 by Th38;
  assume
  I is_halting_on s,P;
  then
A12: P2 halts_on s2 by Def3;
A13:  0 in dom pIF by COMPOS_1:135;
A14: Start-At(0,SCMPDS) c= s2 & Shift(pI,1) c= P4 by Lm6,FUNCT_4:26;
UU:  stop I c= P2 by FUNCT_4:26;
A15: card pIF = card IF +1 by SCMPDS_5:7
    .= card I +1+1 by Th15;
  now
    let k be Element of NAT;
    per cases;
    suppose
      0 < k;
      then consider k1 being Nat such that
A16:  k1 + 1 = k by NAT_1:6;
      reconsider k1 as Element of NAT by ORDINAL1:def 13;
      reconsider m = IC Comput(P2, s2,k1) as Element of NAT;
A17:  card pIF = card pI+1 by A15,SCMPDS_5:7;
       m in dom pI by A10,Def2;
      then m < card pI by AFINSQ_1:70;
      then
A18:  m+1 < card pIF by A17,XREAL_1:8;
      IC Comput(P3,s3,k) = IC Comput(P3, s4,k1) by
A16,EXTPRO_1:5
        .=  (m + 1) by A11,A14,A9,A8,Th45,UU;
      hence IC Comput(P3,s3,k) in dom pIF by A18,AFINSQ_1:70;
    end;
    suppose
      k = 0;
      hence IC Comput(P3,s3,k) in dom pIF by A13,A4,EXTPRO_1:3;
    end;
  end;
  hence IF is_closed_on s,P by Def2;
A21: Comput(P3,s3,LifeSpan(P2,s2)+1)
 = Comput(P3,Comput(P3,s3,1),LifeSpan(P2
,s2))
 by EXTPRO_1:5;
  CurInstr(P3,
  Comput(P3,s3,LifeSpan(P2,s2)+1))
   =CurInstr(P3,
   Comput(P3,s4,LifeSpan(P2,s2))) by A21
    .=CurInstr(P2,
    Comput(P2,s2,LifeSpan(P2,s2))) by A11,A14,A9,A8
,Th45,UU
    .= halt SCMPDS by A12,EXTPRO_1:def 14;
  then P3 halts_on s3 by EXTPRO_1:30;
  hence thesis by Def3;
end;

theorem Th63:
  for s being State of SCMPDS,I being Program of SCMPDS, a being
  Int_position, k1 being Integer st s.DataLoc(s.a,k1)<> 0 holds if=0(a,k1,I)
  is_closed_on s,P & if=0(a,k1,I) is_halting_on s,P
proof
  let s be State of SCMPDS,I be Program of SCMPDS, a be Int_position,k1 be
  Integer;
  set b=DataLoc(s.a,k1);
  assume
A1: s.b <> 0;
  set i = (a,k1)<>0_goto (card I + 1);
  set IF=if=0(a,k1,I), pIF=stop IF, s3 = Initialize s,
  P3 = P +* pIF,
  s4 = Comput(P3,s3,1), P4 = P3;
A4: IC s3 = 0 by COMPOS_1:223;
A5: not b in dom Start-At(0,SCMPDS) by SCMPDS_4:59;
  not a in dom Start-At(0,SCMPDS) by SCMPDS_4:59;
  then
A6: s3.DataLoc(s3.a,k1)=s3.b by FUNCT_4:12
    .= s.b by A5,FUNCT_4:12;
  Comput(P3, s3,0 + 1) = Following(P3,
  Comput(P3,s3,0)) by EXTPRO_1:4
    .= Following(P3,s3) by EXTPRO_1:3
    .= Exec(i,s3) by Th22;
  then
A7: IC s4 = ICplusConst(s3,card I + 1) by A1,A6,SCMPDS_2:67
    .= (0+(card I + 1)) by A4,Th23;
A8: card IF=card I+1 by Th15;
  then
A9: (card I+1) in dom pIF by Th25;
A10:  P3/.IC s4
 = P3.IC s4 by PBOOLE:158;
  pIF c= P3 by FUNCT_4:26;
  then pIF c= P4;
  then P4.(card I+1) = pIF.(card I+1) by A9,GRFUNC_1:8
    .=halt SCMPDS by A8,Th25;
  then
A11: CurInstr(P3,s4) = halt SCMPDS by A7,A10;
  now
    let k be Element of NAT;
    per cases;
    suppose
      0 < k;
      then 1+0 <= k by INT_1:20;
      hence IC Comput(P3,s3,k) in dom pIF by A9,A7,A11,
EXTPRO_1:6;
    end;
    suppose
      k = 0;
      then Comput(P3,s3,k) = s3 by EXTPRO_1:3;
      hence IC Comput(P3,s3,k) in dom pIF by A4,COMPOS_1:135;
    end;
  end;
  hence IF is_closed_on s,P by Def2;
  P3 halts_on s3 by A11,EXTPRO_1:30;
  hence thesis by Def3;
end;

theorem Th64:
  for s being State of SCMPDS,I being halt-free shiftable
Program of SCMPDS, a being Int_position,k1 being Integer st s.DataLoc(s.a,k1)=
0 & I is_closed_on s,P & I is_halting_on s,P holds
 IExec(if=0(a,k1,I),P,s) = IExec(I,P,s) +* Start-At((card I+1),SCMPDS)
proof
  let s be State of SCMPDS,I be halt-free shiftable Program of SCMPDS, a be
  Int_position,k1 be Integer;
  set b=DataLoc(s.a,k1);
  assume
A1: s.b = 0;
  set i = (a,k1)<>0_goto (card I + 1);
  set IF=if=0(a,k1,I), pI=stop I, pIF = stop IF,
  s2 = Initialize s, P2 = P +* pI,
  s3 = Initialize s, P3 = P +* pIF,
  s4 = Comput(P3, s3,1), P4 = P3;
A4: IC s3 = 0 by COMPOS_1:223;
A5: not b in dom Start-At(0,SCMPDS) by SCMPDS_4:59;
A6: Comput(P3, s3,0 + 1) = Following(P3,
Comput(P3,s3,0)) by EXTPRO_1:4
    .= Following(P3,s3) by EXTPRO_1:3
    .= Exec(i,s3) by Th22;
  not a in dom Start-At(0,SCMPDS) by SCMPDS_4:59;
  then s3.DataLoc(s3.a,k1)=s3.b by FUNCT_4:12
    .=0 by A1,A5,FUNCT_4:12;
  then
A7: IC s4 = succ IC s3 by A6,SCMPDS_2:67
    .= (0+1) by A4;
  now
    let a;
    thus s2.a = s3.a
      .= s4.a by A6,SCMPDS_2:67;
  end;
  then
A9: DataPart s2 = DataPart s4 by SCMPDS_4:23;
  assume
A10: I is_closed_on s,P;
  then
A11: I is_closed_on s2,P2 by Th38;
  set SAl=Start-At((card I+1),SCMPDS);
A12: dom ProgramPart s = A by COMPOS_1:34;
A13: Start-At(0,SCMPDS) c= s2 & Shift(pI,1) c= P4 by Lm6,FUNCT_4:26;
UU:  stop I c= P2 by FUNCT_4:26;
  assume
A14: I is_halting_on s,P;
  then
A15: P2 halts_on s2 by Def3;
A17: Comput(P3,s3,LifeSpan(P2,s2)+1)
 = Comput(P3,Comput(P3,s3,1),LifeSpan(P2
,s2))
by EXTPRO_1:5;
A20: CurInstr(P3,
Comput(P3,s3,LifeSpan(P2,s2)+1))
 =CurInstr(P3,
 Comput(P3,s4,LifeSpan(P2,s2))) by A17
    .=CurInstr(P2,
    Comput(P2,s2,LifeSpan(P2,s2))) by A11,A13,A7,A9
,Th45,UU
    .= halt SCMPDS by A15,EXTPRO_1:def 14;
  then
A21: P3 halts_on s3 by EXTPRO_1:30;
A22: CurInstr(P3,s3) = i by Th22;
  now
    let l be Element of NAT;
    assume
A23: l < LifeSpan(P2,s2) + 1;
A24: Comput(P3,s3,0) = s3 by EXTPRO_1:3;
    per cases;
    suppose
      l = 0;
      then CurInstr(P3,Comput(P3,s3,l))
       = CurInstr(P3,s3)
       by A24;
      hence CurInstr(P3,Comput(P3,s3,l)) <>
       halt SCMPDS by A22;
    end;
    suppose
      l <> 0;
      then consider n be Nat such that
A25:  l = n + 1 by NAT_1:6;
      reconsider n as Element of NAT by ORDINAL1:def 13;
A26:  n < LifeSpan(P2,s2) by A23,A25,XREAL_1:8;
      assume
A27:  CurInstr(P3,Comput(P3,s3,l)) = halt SCMPDS;
A31: Comput(P3,s3,n+1)
 = Comput(P3,Comput(P3,s3,1),n) by EXTPRO_1:5;
      CurInstr(P2,Comput(P2,s2,n)) =
      CurInstr(P3,Comput(P3,s4,n)) by A11,A13,A7,A9
,Th45,UU
        .= halt SCMPDS by A25,A27,A31;
      hence contradiction by A15,A26,EXTPRO_1:def 14;
    end;
  end;
  then for l be Element of NAT st CurInstr(P3,
  Comput(P3,s3,l)) = halt SCMPDS
  holds LifeSpan(P2,s2) + 1 <= l;
  then
A32: LifeSpan(P3,s3) = LifeSpan(P2,s2) + 1 by A20,A21
,EXTPRO_1:def 14;
A34: DataPart Result(P2,s2) = DataPart Comput(P2, s2
,LifeSpan(P2,s2)) by A15,EXTPRO_1:23
    .= DataPart Comput(P3, s4,LifeSpan(P2,s2)) by A11
,A13,A7,A9,Th45,UU
    .= DataPart Comput(P3, s3,LifeSpan(P2,s2) + 1)
by EXTPRO_1:5
    .= DataPart Result(P3,s3) by A21,A32,EXTPRO_1:23;
A35: now
    let x be set;
A36: dom SAl = {IC SCMPDS} by FUNCOP_1:19;
    assume
A37: x in dom IExec(IF,P,s);
    per cases by A37,SCMPDS_4:20;
    suppose
A38:  x is Int_position;
      then x <> IC SCMPDS by SCMPDS_2:52;
      then
A39:  not x in dom SAl by A36,TARSKI:def 1;
A40: not x in dom (s | A) by A12,A38,SCMPDS_2:53;
      hence IExec(IF,P,s).x = (Result(P3,s3)).x by FUNCT_4:12
        .= (Result(P2,s2)).x by A34,A38,SCMPDS_4:23
        .= IExec(I,P,s).x by A40,FUNCT_4:12
        .= (IExec(I,P,s) +* SAl).x by A39,FUNCT_4:12;
    end;
    suppose
A41:  x = IC SCMPDS;
A42: not x in dom (s | A) by A12,A41,COMPOS_1:3;
      then
A43:  IC Result(P2,s2) = IC IExec(I,P,s) by A41,FUNCT_4:12
        .=  card I by A10,A14,Th48;
A44:  x in dom SAl by A36,A41,TARSKI:def 1;
      thus IExec(IF,P,s).x = (Result(P3,s3)).x by A42,FUNCT_4:12
        .= Comput(P3, s3,LifeSpan(P2,s2) + 1).x by
A21,A32,EXTPRO_1:23
        .= IC Comput(P3, s4,LifeSpan(P2,s2)) by A41,
EXTPRO_1:5
        .= IC Comput(P2, s2,LifeSpan(P2,s2)) + 1
        by A11,A13,A7,A9,Th45,UU
        .= IC Result(P2,s2) + 1 by A15,EXTPRO_1:23
        .= IC Start-At((card I+1),SCMPDS) by A43,FUNCOP_1:87
        .= (IExec(I,P,s) +* SAl).x by A41,A44,FUNCT_4:14;
    end;
    suppose
      x is Element of NAT;
      hence IExec(IF,P,s).x = (IExec(I,P,s) +* SAl).x by Th26;
    end;
  end;
  dom IExec(IF,P,s) = the carrier of SCMPDS by PARTFUN1:def 4
    .= dom (IExec(I,P,s) +* SAl) by PARTFUN1:def 4;
  hence thesis by A35,FUNCT_1:9;
end;

theorem Th65:
  for s being State of SCMPDS,I being Program of SCMPDS,a being
Int_position, k1 being Integer st s.DataLoc(s.a,k1)<> 0
 holds IExec(if=0(a,k1,I),P,s) = s +* Start-At((card I+1),SCMPDS)
proof
  let s be State of SCMPDS,I be Program of SCMPDS,a be Int_position, k1 be
  Integer;
  set b=DataLoc(s.a,k1);
  set IF=if=0(a,k1,I), pIF=stop IF,
  s3 = Initialize s, P3 = P +* pIF,
  s4 = Comput(P3, s3,1), P4 = P3;
  set i = (a,k1)<>0_goto (card I + 1);
  set SAl=Start-At((card I+1),SCMPDS);
A2: IC s3 = 0 by COMPOS_1:223;
A3: not b in dom Start-At(0,SCMPDS) by SCMPDS_4:59;
  not a in dom Start-At(0,SCMPDS) by SCMPDS_4:59;
  then
A4: s3.DataLoc(s3.a,k1)=s3.b by FUNCT_4:12
    .= s.b by A3,FUNCT_4:12;
A5: Comput(P3, s3,0 + 1) = Following(P3,
Comput(P3,s3,0)) by EXTPRO_1:4
    .= Following(P3,s3) by EXTPRO_1:3
    .= Exec(i,s3) by Th22;
  assume
  s.b <> 0;
  then
A6: IC s4 = ICplusConst(s3,card I + 1) by A5,A4,SCMPDS_2:67
    .= (0+(card I + 1)) by A2,Th23;
A7: pIF c= P4 by FUNCT_4:26;
A8:  P3/.IC s4
 = P3.IC s4 by PBOOLE:158;
A10: card IF=card I+1 by Th15;
  then (card I+1) in dom pIF by Th25;
  then P4.(card I+1) = pIF.(card I+1) by A7,GRFUNC_1:8
    .=halt SCMPDS by A10,Th25;
  then
A11: CurInstr(P3,s4) = halt SCMPDS by A6,A8;
  then
A12: P3 halts_on s3 by EXTPRO_1:30;
A13: CurInstr(P3,s3) = i by Th22;
  now
    let l be Element of NAT;
A14: Comput(P3,s3,0) = s3 by EXTPRO_1:3;
    assume
    l < 1;
    then l <1+0;
    then l=0 by NAT_1:13;
    then CurInstr(P3,Comput(P3,s3,l))
     = CurInstr(P3,s3) by A14;
    hence CurInstr(P3,Comput(P3,s3,l))
     <> halt SCMPDS by A13;
  end;
  then for l be Element of NAT st CurInstr(P3,
  Comput(P3,s3,l)) = halt SCMPDS
  holds 1 <= l;
  then LifeSpan(P3,s3) = 1 by A11,A12,EXTPRO_1:def 14;
  then
A15: s4 = Result(P3,s3) by A12,EXTPRO_1:23;
A16: dom ProgramPart s = A by COMPOS_1:34;
A17: now
A18: dom SAl = {IC SCMPDS} by FUNCOP_1:19;
    let x be set;
    assume
A19: x in dom IExec(IF,P,s);
    per cases by A19,SCMPDS_4:20;
    suppose
A20:  x is Int_position;
      then x <> IC SCMPDS by SCMPDS_2:52;
      then
A21:  not x in dom SAl by A18,TARSKI:def 1;
TT:   not x in dom Start-At(0,SCMPDS) by A20,SCMPDS_4:59;
      not x in dom (s | A) by A16,A20,SCMPDS_2:53;
      hence IExec(IF,P,s).x = s4.x by A15,FUNCT_4:12
        .= s3.x by A5,A20,SCMPDS_2:67
        .= s.x by TT,FUNCT_4:12
        .= (s +* SAl).x by A21,FUNCT_4:12;
    end;
    suppose
A22:  x = IC SCMPDS;
      not x in dom (s | A) by A16,A22,COMPOS_1:3;
      hence IExec(IF,P,s).x = (card I + 1) by A6,A15,A22,FUNCT_4:12
        .= (s +* SAl).x by A22,FUNCT_4:121;
    end;
    suppose
      x is Element of NAT;
      hence IExec(IF,P,s).x = (s +* SAl).x by Th27;
    end;
  end;
  dom IExec(IF,P,s) = the carrier of SCMPDS by PARTFUN1:def 4
    .= dom (s +* SAl) by PARTFUN1:def 4;
  hence thesis by A17,FUNCT_1:9;
end;

registration
  let I be shiftable parahalting Program of SCMPDS, a be Int_position,k1 be
  Integer;
  cluster if=0(a,k1,I) -> shiftable parahalting;
  correctness
  proof
    set i = (a,k1)<>0_goto (card I +1);
    set IF=if=0(a,k1,I), IsIF=Initialize stop IF;
    thus IF is shiftable;
      let s be 0-started State of SCMPDS;
      let P be (the Instructions of SCMPDS)-valued ManySortedSet of NAT;
A1:  Initialize s = s by COMPOS_1:78;
      assume
      stop IF c= P;
      then
A2:   P = P +* stop IF by FUNCT_4:104;
A3:   I is_closed_on s,P & I is_halting_on s,P by Th34,Th35;
      per cases;
      suppose
        s.DataLoc(s.a,k1)= 0;
        then IF is_halting_on s,P by A3,Th62;
        hence P halts_on s by A1,A2,Def3;
      end;
      suppose
        s.DataLoc(s.a,k1) <> 0;
        then IF is_halting_on s,P by Th63;
        hence P halts_on s by A1,A2,Def3;
      end;
  end;
end;

registration
  let I be halt-free Program of SCMPDS, a be Int_position,k1 be Integer;
  cluster if=0(a,k1,I) -> halt-free;
  coherence;
end;

theorem
  for s being State of SCMPDS,I being halt-free shiftable parahalting
Program of SCMPDS,a being Int_position,k1 being Integer
 holds IC IExec(if=0(a,k1,I),P,s) =  (card I + 1)
proof
  let s be State of SCMPDS,I be halt-free shiftable parahalting Program of
  SCMPDS,a be Int_position,k1 be Integer;
  set IF=if=0(a,k1,I);
A1: I is_closed_on s,P & I is_halting_on s,P by Th34,Th35;
  per cases;
  suppose
    s.DataLoc(s.a,k1) = 0;
    then IExec(IF,P,s) =IExec(I,P,s) +* Start-At((card I+1),SCMPDS)
    by A1,Th64;
    hence thesis by FUNCT_4:121;
  end;
  suppose
    s.DataLoc(s.a,k1) <> 0;
    then IExec(IF,P,s) =s +* Start-At((card I+1),SCMPDS) by Th65;
    hence thesis by FUNCT_4:121;
  end;
end;

theorem
  for s being State of SCMPDS,I being halt-free shiftable parahalting
Program of SCMPDS,a,b being Int_position,k1 being Integer st s.DataLoc(s.a,k1)=
  0 holds IExec(if=0(a,k1,I),P,s).b = IExec(I,P,s).b
proof
  let s be State of SCMPDS,I be halt-free shiftable parahalting Program of
  SCMPDS,a,b be Int_position,k1 be Integer;
  assume
A1: s.DataLoc(s.a,k1)=0;
A2: not b in dom Start-At((card I+1),SCMPDS) by SCMPDS_4:59;
  I is_closed_on s,P & I is_halting_on s,P by Th34,Th35;
  then IExec(if=0(a,k1,I),P,s) = IExec(I,P,s) +* Start-At((card I+1),SCMPDS)
  by A1,Th64;
  hence thesis by A2,FUNCT_4:12;
end;

theorem
  for s being State of SCMPDS,I being Program of SCMPDS,a,b being
Int_position, k1 being Integer st s.DataLoc(s.a,k1)<> 0
 holds IExec(if=0(a,k1,I),P,s).b = s.b
proof
  let s be State of SCMPDS,I be Program of SCMPDS,a,b be Int_position, k1 be
  Integer;
  assume
  s.DataLoc(s.a,k1)<>0;
  then
A1: IExec(if=0(a,k1,I),P,s) = s +* Start-At((card I+1),SCMPDS) by Th65;
  not b in dom Start-At((card I+1),SCMPDS) by SCMPDS_4:59;
  hence thesis by A1,FUNCT_4:12;
end;

Lm8: card (i ';' j ';' I)=card I+2
proof
  thus card (i ';' j ';' I) =card (i ';' (j ';' I)) by SCMPDS_4:52
    .=card (j ';' I)+1 by Th15
    .=card I+1+1 by Th15
    .=card I+2;
end;

begin :: The computation of "if var<>0 then block"

theorem
  card if<>0(a,k1,I) = card I + 2 by Lm8;

Lm9:  0 in dom (i ';' j ';' I) &  1 in dom (i ';' j ';' I)
proof
  set ci=card (i ';' j ';' I);
  ci=card I + 2 by Lm8;
  then 2 <= ci by NAT_1:11;
  then 1 < ci by XXREAL_0:2;
  hence thesis by AFINSQ_1:70;
end;

theorem
   0 in dom if<>0(a,k1,I) &  1 in dom if<>0(a,k1,I) by Lm9;

Lm10: (i ';' j ';' I). 0=i & (i ';' j ';' I). 1=j
proof
  set jI=j ';' I;
A1: i ';' j ';' I =i ';' jI by SCMPDS_4:52
    .=Load i ';' jI;
   0 in dom Load i by SCMPDS_5:2;
  hence (i ';' j ';' I). 0 =(Load i). 0 by A1,AFINSQ_1:def 4
    .=i by SCMPDS_5:4;
A2:  0 in dom Load j by SCMPDS_5:2;
  card jI=card I+1 by Th15;
  then
A3: card Load i=1 &  0 in dom jI by AFINSQ_1:70,SCMPDS_5:6;
  thus (i ';' j ';' I). 1 =(Load i ';' jI). (0+1) by A1
    .=jI. 0 by A3,AFINSQ_1:def 4
    .=(Load j ';' I). 0
    .=(Load j). 0 by A2,AFINSQ_1:def 4
    .=j by SCMPDS_5:4;
end;

theorem
  if<>0(a,k1,I). 0 = (a,k1)<>0_goto 2 & if<>0(a,k1,I). 1 =
  goto (card I + 1) by Lm10;

theorem Th72:
  for s being State of SCMPDS, I being shiftable Program of SCMPDS
  , a being Int_position,k1 being Integer st s.DataLoc(s.a,k1)<>0 & I
is_closed_on s,P & I is_halting_on s,P holds if<>0(a,k1,I) is_closed_on s,P
 & if<>0(a
  ,k1,I) is_halting_on s,P
proof
  let s be State of SCMPDS, I be shiftable Program of SCMPDS, a be
  Int_position,k1 be Integer;
  set b=DataLoc(s.a,k1);
  set IF=if<>0(a,k1,I), pIF=stop IF, pI=stop I,
  s2 = Initialize s, P2 = P +* pI,
  s3 = Initialize s, P3 = P +* pIF,
  s4 = Comput(P3,s3,1), P4 = P3;
  set i = (a,k1)<>0_goto 2, j = goto (card I + 1);
A3: IF = i ';' (j ';' I) by SCMPDS_4:52;
A4: Comput(P3, s3,0 + 1) = Following(P3,
Comput(P3,s3,0)) by EXTPRO_1:4
    .= Following(P3,s3) by EXTPRO_1:3
    .= Exec(i,s3) by A3,Th22;
  now
    let a;
    thus s2.a = s3.a
      .= s4.a by A4,SCMPDS_2:67;
  end;
  then
A6: DataPart s2 = DataPart s4 by SCMPDS_4:23;
A7: not b in dom Start-At(0,SCMPDS) by SCMPDS_4:59;
  not a in dom Start-At(0,SCMPDS) by SCMPDS_4:59;
  then
A8: s3.DataLoc(s3.a,k1)=s3.b by FUNCT_4:12
    .= s.b by A7,FUNCT_4:12;
A9: IC s3 = 0 by COMPOS_1:223;
  assume
  s.b <> 0;
  then
A10: IC s4 = ICplusConst(s3,2) by A4,A8,SCMPDS_2:67
    .= (0+2) by A9,Th23;
  assume
A11: I is_closed_on s,P;
  then
A12: I is_closed_on s2,P2 by Th38;
  assume
  I is_halting_on s,P;
  then
A13: P2 halts_on s2 by Def3;
A14: Start-At(0,SCMPDS) c= s2 & Shift(pI,2) c= P4 by Lm7,FUNCT_4:26;
UU:  stop I c= P2 by FUNCT_4:26;
A15:  0 in dom pIF by COMPOS_1:135;
  now
    let k be Element of NAT;
    per cases;
    suppose
      0 < k;
      then consider k1 being Nat such that
A16:  k1 + 1 = k by NAT_1:6;
      reconsider k1 as Element of NAT by ORDINAL1:def 13;
      reconsider m = IC Comput(P2, s2,k1) as Element of NAT;
A17:  card pIF = 1+ card IF by SCMPDS_5:7
        .= 1+(card I +2) by Lm8
        .= 1+card I +2
        .=card pI+2 by SCMPDS_5:7;
       m in dom pI by A11,Def2;
      then m < card pI by AFINSQ_1:70;
      then
A18:  m+2 < card pIF by A17,XREAL_1:8;
      IC Comput(P3,s3,k) = IC Comput(P3, s4,k1) by
A16,EXTPRO_1:5
        .=  (m + 2) by A12,A14,A10,A6,Th45,UU;
      hence IC Comput(P3,s3,k) in dom pIF by A18,AFINSQ_1:70;
    end;
    suppose
      k = 0;
      hence IC Comput(P3,s3,k) in dom pIF by A15,A9,EXTPRO_1:3;
    end;
  end;
  hence IF is_closed_on s,P by Def2;
A21: Comput(P3,s3,LifeSpan(P2,s2)+1)
= Comput(P3,Comput(P3,s3,1),LifeSpan(P2,
s2))
by EXTPRO_1:5;
  CurInstr(P3,
  Comput(P3,s3,LifeSpan(P2,s2)+1))
   =CurInstr(P3,
   Comput(P3,s4,LifeSpan(P2,s2))) by A21
    .=CurInstr(P2,
    Comput(P2,s2,LifeSpan(P2,s2))) by A12,A14,A10,A6
,Th45,UU
    .= halt SCMPDS by A13,EXTPRO_1:def 14;
  then P3 halts_on s3 by EXTPRO_1:30;
  hence thesis by Def3;
end;

theorem Th73:
  for s being State of SCMPDS,I being Program of SCMPDS, a being
  Int_position, k1 being Integer st s.DataLoc(s.a,k1)= 0 holds if<>0(a,k1,I)
  is_closed_on s,P & if<>0(a,k1,I) is_halting_on s,P
proof
  let s be State of SCMPDS,I be Program of SCMPDS, a be Int_position,k1 be
  Integer;
  set b=DataLoc(s.a,k1);
  assume
A1: s.b = 0;
  set IF=if<>0(a,k1,I), pIF=stop IF, s3 = Initialize s,
  P3 = P +* pIF,
  s4 = Comput(P3,s3,1), s5 = Comput(P3,s3,2), P4 = P3, P5 = P3;
A3: not b in dom Start-At(0,SCMPDS) by SCMPDS_4:59;
  not a in dom Start-At(0,SCMPDS) by SCMPDS_4:59;
  then
A4: s3.DataLoc(s3.a,k1)=s3.b by FUNCT_4:12
    .=0 by A1,A3,FUNCT_4:12;
A6: pIF c= P4 by FUNCT_4:26;
  set i = (a,k1)<>0_goto 2, j = goto (card I + 1);
A7: IF =i ';' (j ';' I) by SCMPDS_4:52;
A8: IC s3 = 0 by COMPOS_1:223;
  Comput(P3, s3,0 + 1) = Following(P3,
  Comput(P3,s3,0)) by EXTPRO_1:4
    .= Following(P3,s3) by EXTPRO_1:3
    .= Exec(i,s3) by A7,Th22;
  then
A9: IC s4 = succ IC s3 by A4,SCMPDS_2:67
    .= (0+1) by A8;
A10:  1 in dom IF by Lm9;
  then  1 in dom pIF by Th18;
  then
A11: P4. 1 = pIF. 1 by A6,GRFUNC_1:8
    .=IF. 1 by A10,Th19
    .=j by Lm10;
A12: card IF=card I+2 by Lm8;
  then
A13: (card I+2) in dom pIF by Th25;
A14:  P3/.IC s4
 = P3.IC s4 by PBOOLE:158;
  Comput(P3, s3,1 + 1) = Following(P3,s4) by
EXTPRO_1:4
    .= Exec(j,s4) by A9,A11,A14;
  then
A16: IC s5 = ICplusConst(s4,card I+1) by SCMPDS_2:66
    .= (card I+1+1) by A9,Th23
    .= (card I+(1+1));
A17:  (P3)/.IC s5
 = P3.IC s5 by PBOOLE:158;
  pIF c= P5 by FUNCT_4:26;
  then P5.(card I+2) = pIF.(card I+2) by A13,GRFUNC_1:8
    .=halt SCMPDS by A12,Th25;
  then
A19: CurInstr(P3,s5) = halt SCMPDS by A16,A17;
  now
    let k be Element of NAT;
A20: k = 0 or 0 + 1 <= k by INT_1:20;
    per cases by A20,XXREAL_0:1;
    suppose
      k = 0;
      then Comput(P3,s3,k) = s3 by EXTPRO_1:3;
      hence IC Comput(P3,s3,k) in dom pIF by A8,COMPOS_1:135;
    end;
    suppose
      k = 1;
      hence IC Comput(P3,s3,k) in dom pIF by A10,A9,Th18;
    end;
    suppose
      1 < k;
      then 1+1 <= k by INT_1:20;
      hence IC Comput(P3,s3,k) in dom pIF
      by A13,A16,A19,EXTPRO_1:6;
    end;
  end;
  hence IF is_closed_on s,P by Def2;
  P3 halts_on s3 by A19,EXTPRO_1:30;
  hence thesis by Def3;
end;

theorem Th74:
  for s being State of SCMPDS,I being halt-free shiftable
  Program of SCMPDS, a being Int_position,k1 being Integer st s.DataLoc(s.a,k1)
  <> 0 & I is_closed_on s,P & I is_halting_on s,P
   holds IExec(if<>0(a,k1,I),P,s) =
  IExec(I,P,s) +* Start-At((card I+2),SCMPDS)
proof
  let s be State of SCMPDS,I be halt-free shiftable Program of SCMPDS, a be
  Int_position,k1 be Integer;
  set b=DataLoc(s.a,k1);
  set IF=if<>0(a,k1,I), pI=stop I, pIF = stop IF,
   s2 = Initialize s, P2 = P +* pI,
   s3 = Initialize s,
   P3 = P +* pIF,
   s4 = Comput(P3, s3,1), P4 = P3;
  set i = (a,k1)<>0_goto 2, j = goto (card I + 1);
  set SAl=Start-At((card I+2),SCMPDS);
A3: IF=i ';' (j ';' I) by SCMPDS_4:52;
A4: Comput(P3, s3,0 + 1) = Following(P3,
Comput(P3,s3,0)) by EXTPRO_1:4
    .= Following(P3,s3) by EXTPRO_1:3
    .= Exec(i,s3) by A3,Th22;
A5: not b in dom Start-At(0,SCMPDS) by SCMPDS_4:59;
  not a in dom Start-At(0,SCMPDS) by SCMPDS_4:59;
  then
A6: s3.DataLoc(s3.a,k1)=s3.b by FUNCT_4:12
    .= s.b by A5,FUNCT_4:12;
A7: IC s3 = 0 by COMPOS_1:223;
A8: Start-At(0,SCMPDS) c= s2 & Shift(pI,2) c= P4 by Lm7,FUNCT_4:26;
UU:  stop I c= P2 by FUNCT_4:26;
  now
    let a;
    thus s2.a = s3.a
      .= s4.a by A4,SCMPDS_2:67;
  end;
  then
A10: DataPart s2 = DataPart s4 by SCMPDS_4:23;
  assume
  s.b <> 0;
  then
A11: IC s4 = ICplusConst(s3,2) by A4,A6,SCMPDS_2:67
    .= (0+2) by A7,Th23;
A12: dom ProgramPart s = A by COMPOS_1:34;
  assume
A13: I is_closed_on s,P;
  then
A14: I is_closed_on s2,P2 by Th38;
  assume
A15: I is_halting_on s,P;
  then
A16: P2 halts_on s2 by Def3;
A18: Comput(P3,s3,LifeSpan(P2,s2)+1)
 = Comput(P3,Comput(P3,s3,1),LifeSpan(P2
,s2))
by EXTPRO_1:5;
A21: CurInstr(P3,
Comput(P3,s3,LifeSpan(P2,s2)+1))
 =CurInstr(P3,
 Comput(P3,s4,LifeSpan(P2,s2))) by A18
    .=CurInstr(P2,
    Comput(P2,s2,LifeSpan(P2,s2))) by A14,A8,A11,A10
,Th45,UU
    .= halt SCMPDS by A16,EXTPRO_1:def 14;
  then
A22: P3 halts_on s3 by EXTPRO_1:30;
A23: CurInstr(P3,s3) = i by A3,Th22;
  now
    let l be Element of NAT;
    assume
A24: l < LifeSpan(P2,s2) + 1;
A25: Comput(P3,s3,0) = s3 by EXTPRO_1:3;
    per cases;
    suppose
      l = 0;
      then CurInstr(P3,Comput(P3,s3,l))
       = CurInstr(P3,s3)
       by A25;
      hence CurInstr(P3,Comput(P3,s3,l))
       <> halt SCMPDS by A23;
    end;
    suppose
      l <> 0;
      then consider n be Nat such that
A26:  l = n + 1 by NAT_1:6;
      reconsider n as Element of NAT by ORDINAL1:def 13;
A27:  n < LifeSpan(P2,s2) by A24,A26,XREAL_1:8;
      assume
A28:  CurInstr(P3,Comput(P3,s3,l)) = halt SCMPDS;
A32: Comput(P3,s3,n+1)
= Comput(P3,Comput(P3,s3,1),n) by EXTPRO_1:5;
      CurInstr(P2,Comput(P2,s2,n)) =
      CurInstr(P3,Comput(P3,s4,n)) by A14,A8,A11,A10
,Th45,UU
        .= halt SCMPDS by A26,A28,A32;
      hence contradiction by A16,A27,EXTPRO_1:def 14;
    end;
  end;
  then for l be Element of NAT st CurInstr(P3,
  Comput(P3,s3,l)) = halt SCMPDS
  holds LifeSpan(P2,s2) + 1 <= l;
  then
A33: LifeSpan(P3,s3) = LifeSpan(P2,s2) + 1 by A21,A22
,EXTPRO_1:def 14;
A35: DataPart Result(P2,s2) = DataPart Comput(P2, s2
,LifeSpan(P2,s2)) by A16,EXTPRO_1:23
    .= DataPart Comput(P3, s4,LifeSpan(P2,s2)) by A14
,A8,A11,A10,Th45,UU
    .= DataPart Comput(P3, s3,LifeSpan(P2,s2) + 1)
by EXTPRO_1:5
    .= DataPart Result(P3,s3) by A22,A33,EXTPRO_1:23;
A36: now
    let x be set;
A37: dom Start-At((card I+2),SCMPDS) = {IC SCMPDS} by FUNCOP_1:19;
    assume
A38: x in dom IExec(IF,P,s);
    per cases by A38,SCMPDS_4:20;
    suppose
A39:  x is Int_position;
      then x <> IC SCMPDS by SCMPDS_2:52;
      then
A40:  not x in dom SAl by A37,TARSKI:def 1;
A41: not x in dom (s | A) by A12,A39,SCMPDS_2:53;
      hence IExec(IF,P,s).x = (Result(P3,s3)).x by FUNCT_4:12
        .= (Result(P2,s2)).x by A35,A39,SCMPDS_4:23
        .= IExec(I,P,s).x by A41,FUNCT_4:12
        .= (IExec(I,P,s) +* SAl).x by A40,FUNCT_4:12;
    end;
    suppose
A42:  x = IC SCMPDS;
A43: not x in dom (s | A) by A12,A42,COMPOS_1:3;
      then
A44:  IC Result(P2,s2) = IC IExec(I,P,s) by A42,FUNCT_4:12
        .=  card I by A13,A15,Th48;
A45:  x in dom SAl by A37,A42,TARSKI:def 1;
      thus IExec(IF,P,s).x = (Result(P3,s3)).x by A43,FUNCT_4:12
        .= Comput(P3, s3,LifeSpan(P2,s2) + 1).x by
A22,A33,EXTPRO_1:23
        .= IC Comput(P3, s4,LifeSpan(P2,s2)) by A42,
EXTPRO_1:5
        .= IC Comput(P2, s2,LifeSpan(P2,s2)) + 2
        by A14,A8,A11,A10,Th45,UU
        .= IC Result(P2,s2) + 2 by A16,EXTPRO_1:23
        .= IC SAl by A44,FUNCOP_1:87
        .= (IExec(I,P,s) +* SAl).x by A42,A45,FUNCT_4:14;
    end;
    suppose
      x is Element of NAT;
      hence IExec(IF,P,s).x = (IExec(I,P,s) +* SAl).x by Th26;
    end;
  end;
  dom IExec(IF,P,s) = the carrier of SCMPDS by PARTFUN1:def 4
    .= dom (IExec(I,P,s) +* Start-At((card I+2),SCMPDS)) by PARTFUN1:def 4;
  hence thesis by A36,FUNCT_1:9;
end;

theorem Th75:
  for s being State of SCMPDS,I being Program of SCMPDS,a being
Int_position, k1 being Integer st s.DataLoc(s.a,k1)= 0
 holds IExec(if<>0(a,k1,I),P,s) = s +* Start-At((card I+2),SCMPDS)
proof
  let s be State of SCMPDS,I be Program of SCMPDS,a be Int_position, k1 be
  Integer;
  set b=DataLoc(s.a,k1);
  assume
A1: s.b = 0;
  set SAl=Start-At((card I+2),SCMPDS);
  set i = (a,k1)<>0_goto 2, j = goto (card I + 1);
  set IF=if<>0(a,k1,I), pIF=stop IF, s3 = Initialize s,
  P3 = P +* pIF,
  s4 = Comput(P3,s3,1), s5 = Comput(P3,s3,2), P4 = P3, P5 = P3;
A3: IF =i ';' (j ';' I) by SCMPDS_4:52;
A4: pIF c= P3 by FUNCT_4:26;
  then
A5: pIF c= P4;
A6: pIF c= P5 by A4;
A7: not b in dom Start-At(0,SCMPDS) by SCMPDS_4:59;
A8: IC s3 = 0 by COMPOS_1:223;
A9: Comput(P3, s3,0 + 1) = Following(P3,
Comput(P3,s3,0)) by EXTPRO_1:4
    .= Following(P3,s3) by EXTPRO_1:3
    .= Exec(i,s3) by A3,Th22;
  not a in dom Start-At(0,SCMPDS) by SCMPDS_4:59;
  then s3.DataLoc(s3.a,k1)=s3.b by FUNCT_4:12
    .=0 by A1,A7,FUNCT_4:12;
  then
A10: IC s4 = succ IC s3 by A9,SCMPDS_2:67
    .= (0+1) by A8;
A11:  1 in dom IF by Lm9;
  then  1 in dom pIF by Th18;
  then
A12: P4.1 = pIF. 1 by A5,GRFUNC_1:8
    .=IF. 1 by A11,Th19
    .=j by Lm10;
A13:  P3/.IC s4
 = P3.IC s4 by PBOOLE:158;
A15: Comput(P3, s3,1 + 1) = Following(P3,s4) by
EXTPRO_1:4
    .= Exec(j,s4) by A10,A12,A13;
  then
A16: IC s5 = ICplusConst(s4,card I+1) by SCMPDS_2:66
    .= (card I+1+1) by A10,Th23
    .= (card I+(1+1));
A17:  (P3)/.IC s5
 = P3.IC s5 by PBOOLE:158;
A19: card IF=card I+2 by Lm8;
  then (card I+2) in dom pIF by Th25;
  then P5.(card I+2) = pIF.(card I+2) by A6,GRFUNC_1:8
    .=halt SCMPDS by A19,Th25;
  then
A20: CurInstr(P3,s5) = halt SCMPDS by A16,A17;
  then
A21: P3 halts_on s3 by EXTPRO_1:30;
A22: CurInstr(P3,s3) = i by A3,Th22;
  now
    let l be Element of NAT;
    assume
    l < 1+1;
    then
A23: l <= 1 by NAT_1:13;
A24: Comput(P3,s3,0) = s3 by EXTPRO_1:3;
A25: P3/.IC Comput(P3,s3,l)
 = P3.IC Comput(P3,s3,l) by PBOOLE:158;
    per cases by A23,NAT_1:26;
    suppose
      l=0;
      then CurInstr(P3,Comput(P3,s3,l))
       = CurInstr(P3,s3)
       by A24;
      hence CurInstr(P3,Comput(P3,s3,l))
       <> halt SCMPDS by A22;
    end;
    suppose
      l=1;
      hence CurInstr(P3,Comput(P3,s3,l))
       <> halt SCMPDS by A10,A12,A25;
    end;
  end;
  then for l be Element of NAT st CurInstr(P3,
  Comput(P3,s3,l)) = halt SCMPDS
  holds 2 <= l;
  then LifeSpan(P3,s3) = 2 by A20,A21,EXTPRO_1:def 14;
  then
A27: s5 = Result(P3,s3) by A21,EXTPRO_1:23;
A28: dom ProgramPart s = A by COMPOS_1:34;
A29: now
A30: dom SAl = {IC SCMPDS} by FUNCOP_1:19;
    let x be set;
    assume
A31: x in dom IExec(IF,P,s);
    per cases by A31,SCMPDS_4:20;
    suppose
A32:  x is Int_position;
      then x <> IC SCMPDS by SCMPDS_2:52;
      then
A33:  not x in dom SAl by A30,TARSKI:def 1;
TT:   not x in dom Start-At(0,SCMPDS) by A32,SCMPDS_4:59;
      not x in dom (s | A) by A28,A32,SCMPDS_2:53;
      hence IExec(IF,P,s).x = s5.x by A27,FUNCT_4:12
        .= s4.x by A15,A32,SCMPDS_2:66
        .= s3.x by A9,A32,SCMPDS_2:67
        .= s.x by TT,FUNCT_4:12
        .= (s +* SAl).x by A33,FUNCT_4:12;
    end;
    suppose
A34:  x = IC SCMPDS;
      not x in dom (s | A) by A28,A34,COMPOS_1:3;
      hence IExec(IF,P,s).x = (card I + 2) by A16,A27,A34,FUNCT_4:12
        .= (s +* Start-At((card I+2),SCMPDS)).x by A34,FUNCT_4:121;
    end;
    suppose
      x is Element of NAT;
      hence IExec(IF,P,s).x = (s +* SAl).x by Th27;
    end;
  end;
  dom IExec(IF,P,s) = the carrier of SCMPDS by PARTFUN1:def 4
    .= dom (s +* SAl) by PARTFUN1:def 4;
  hence thesis by A29,FUNCT_1:9;
end;

registration
  let I be shiftable parahalting Program of SCMPDS, a be Int_position,k1 be
  Integer;
  cluster if<>0(a,k1,I) -> shiftable parahalting;
  correctness
  proof
    set i = (a,k1)<>0_goto 2, j = goto (card I + 1);
    set IF=if<>0(a,k1,I), pIF = stop IF;
    thus IF is shiftable;
      let s be 0-started State of SCMPDS;
      let P be (the Instructions of SCMPDS)-valued ManySortedSet of NAT;
A1:  Initialize s = s by COMPOS_1:78;
      assume pIF c= P;
      then
A2:   P = P +* stop IF by FUNCT_4:104;
A3:   I is_closed_on s,P & I is_halting_on s,P by Th34,Th35;
      per cases;
      suppose
        s.DataLoc(s.a,k1)<>0;
        then IF is_halting_on s,P by A3,Th72;
        hence P halts_on s by A1,A2,Def3;
      end;
      suppose
        s.DataLoc(s.a,k1) = 0;
        then IF is_halting_on s,P by Th73;
        hence P halts_on s by A1,A2,Def3;
      end;
  end;
end;

registration
  let I be halt-free Program of SCMPDS, a be Int_position,k1 be Integer;
  cluster if<>0(a,k1,I) -> halt-free;
  coherence;
end;

theorem
  for s being State of SCMPDS,I being halt-free shiftable parahalting
Program of SCMPDS,a being Int_position,k1 being Integer
 holds IC IExec(if<>0(a,k1,I),P,s) =  (card I + 2)
proof
  let s be State of SCMPDS,I be halt-free shiftable parahalting Program of
  SCMPDS,a be Int_position,k1 be Integer;
  set IF=if<>0(a,k1,I);
A1: I is_closed_on s,P & I is_halting_on s,P by Th34,Th35;
  per cases;
  suppose
    s.DataLoc(s.a,k1) <> 0;
    then IExec(IF,P,s) =IExec(I,P,s) +* Start-At((card I+2),SCMPDS)
    by A1,Th74;
    hence thesis by FUNCT_4:121;
  end;
  suppose
    s.DataLoc(s.a,k1) = 0;
    then IExec(IF,P,s) =s +* Start-At((card I+2),SCMPDS) by Th75;
    hence thesis by FUNCT_4:121;
  end;
end;

theorem
  for s being State of SCMPDS,I being halt-free shiftable parahalting
Program of SCMPDS,a,b being Int_position,k1 being Integer st s.DataLoc(s.a,k1)
  <> 0 holds IExec(if<>0(a,k1,I),P,s).b = IExec(I,P,s).b
proof
  let s be State of SCMPDS,I be halt-free shiftable parahalting Program of
  SCMPDS,a,b be Int_position,k1 be Integer;
  assume
A1: s.DataLoc(s.a,k1)<>0;
A2: not b in dom Start-At((card I+2),SCMPDS) by SCMPDS_4:59;
  I is_closed_on s,P & I is_halting_on s,P by Th34,Th35;
  then IExec(if<>0(a,k1,I),P,s) = IExec(I,P,s) +* Start-At((card I+2),SCMPDS)
   by A1,Th74;
  hence thesis by A2,FUNCT_4:12;
end;

theorem
  for s being State of SCMPDS,I being Program of SCMPDS,a,b being
Int_position, k1 being Integer st s.DataLoc(s.a,k1)= 0
 holds IExec(if<>0(a,k1,I),P,s).b = s.b
proof
  let s be State of SCMPDS,I be Program of SCMPDS,a,b be Int_position, k1 be
  Integer;
  assume
  s.DataLoc(s.a,k1)=0;
  then
A1: IExec(if<>0(a,k1,I),P,s) = s +* Start-At((card I+2),SCMPDS) by Th75;
  not b in dom Start-At((card I+2),SCMPDS) by SCMPDS_4:59;
  hence thesis by A1,FUNCT_4:12;
end;

begin :: The computation of "if var>0 then block1 else block2"

theorem
  card if>0(a,k1,I,J) = card I + card J + 2 by Lm4;

theorem
   0 in dom if>0(a,k1,I,J) &  1 in dom if>0(a,k1,I,J)
proof
  set ci=card if>0(a,k1,I,J);
  ci=card I + card J +2 by Lm4;
  then 2 <= ci by NAT_1:12;
  then 1 < ci by XXREAL_0:2;
  hence thesis by AFINSQ_1:70;
end;

theorem
  if>0(a,k1,I,J). 0 = (a,k1)<=0_goto (card I + 2) by Lm5;

theorem Th82:
  for s being State of SCMPDS, I,J being shiftable Program of
  SCMPDS, a being Int_position,k1 being Integer st s.DataLoc(s.a,k1)>0 & I
is_closed_on s,P & I is_halting_on s,P holds if>0(a,k1,I,J) is_closed_on s,P
 & if>0(a
  ,k1,I,J) is_halting_on s,P
proof
  let s be State of SCMPDS, I,J be shiftable Program of SCMPDS, a be
  Int_position,k1 be Integer;
  set b=DataLoc(s.a,k1);
  set G=Goto (card J+1);
  set I2 = I ';' G ';' J, IF=if>0(a,k1,I,J), pIF=stop IF,
   pI2=stop I2, s2 = Initialize s, P2 = P +* pI2,
   s3 = Initialize s,
   P3 = P +* pIF,
   s4 = Comput(P3,s3,1), P4 = P3;
  set i = (a,k1)<=0_goto (card I + 2);
A3:  0 in dom pIF by COMPOS_1:135;
A4: IC s3 = 0 by COMPOS_1:223;
A5: not b in dom Start-At(0,SCMPDS) by SCMPDS_4:59;
  not a in dom Start-At(0,SCMPDS) by SCMPDS_4:59;
  then
A6: s3.DataLoc(s3.a,k1)=s3.b by FUNCT_4:12
    .= s.b by A5,FUNCT_4:12;
A7: IF = i ';' (I ';' G) ';' J by SCMPDS_4:50
    .= i ';' I2 by SCMPDS_4:50;
  then
A8: Shift(pI2,1) c= P4 by Lm6;
A9: Comput(P3, s3,0 + 1) = Following(P3,
Comput(P3,s3,0)) by EXTPRO_1:4
    .= Following(P3,s3) by EXTPRO_1:3
    .= Exec(i,s3) by A7,Th22;
  now
    let a;
    thus s2.a = s3.a
      .= s4.a by A9,SCMPDS_2:68;
  end;
  then
A11: DataPart s2 = DataPart s4 by SCMPDS_4:23;
  assume
  s.b > 0;
  then
A12: IC s4 = succ IC s3 by A9,A6,SCMPDS_2:68
    .= (0+1) by A4;
  assume
A13: I is_closed_on s,P;
  assume
A14: I is_halting_on s,P;
  then
A15: I2 is_closed_on s,P by A13,Th44;
  then
A16: Start-At(0,SCMPDS) c= s2 & I2 is_closed_on s2,P2 by Th38,FUNCT_4:26;
UU:  stop I2 c= P2 by FUNCT_4:26;
  I2 is_halting_on s,P by A13,A14,Th44;
  then
A17: P2 halts_on s2 by Def3;
A18: card pIF = card IF +1 by SCMPDS_5:7
    .= card I2 +1+1 by A7,Th15;
  now
    let k be Element of NAT;
    per cases;
    suppose
      0 < k;
      then consider k1 being Nat such that
A19:  k1 + 1 = k by NAT_1:6;
      reconsider k1 as Element of NAT by ORDINAL1:def 13;
      reconsider m = IC Comput(P2, s2,k1) as Element of NAT;
A20:  card pIF = card pI2+1 by A18,SCMPDS_5:7;
       m in dom pI2 by A15,Def2;
      then m < card pI2 by AFINSQ_1:70;
      then
A21:  m+1 < card pIF by A20,XREAL_1:8;
      IC Comput(P3,s3,k) = IC Comput(P3, s4,k1) by A19,EXTPRO_1:5
        .=  (m + 1) by A16,A8,A12,A11,Th45,UU;
      hence IC Comput(P3,s3,k) in dom pIF by A21,AFINSQ_1:70;
    end;
    suppose
      k = 0;
      hence IC Comput(P3,s3,k) in dom pIF by A3,A4,EXTPRO_1:3;
    end;
  end;
  hence IF is_closed_on s,P by Def2;
A24: Comput(P3,s3,LifeSpan(P2,s2)+1)
 = Comput(P3,Comput(P3,s3,1),LifeSpan(P2
,s2))
 by EXTPRO_1:5;
  CurInstr(P3,
  Comput(P3,s3,LifeSpan(P2,s2)+1))
   =CurInstr(P3,
   Comput(P3,s4,LifeSpan(P2,s2))) by A24
    .=CurInstr(P2,
    Comput(P2,s2,LifeSpan(P2,s2))) by A16,A8,A12,A11
,Th45,UU
    .= halt SCMPDS by A17,EXTPRO_1:def 14;
  then P3 halts_on s3 by EXTPRO_1:30;
  hence thesis by Def3;
end;

theorem Th83:
  for s being State of SCMPDS,I being Program of SCMPDS,J being
shiftable Program of SCMPDS,a being Int_position,k1 being Integer st s.DataLoc(
  s.a,k1) <= 0 & J is_closed_on s,P & J is_halting_on s,P holds if>0(a,k1,I,J)
  is_closed_on s,P & if>0(a,k1,I,J) is_halting_on s,P
proof
  let s be State of SCMPDS,I be Program of SCMPDS, J be shiftable Program of
  SCMPDS, a be Int_position,k1 be Integer;
  set b=DataLoc(s.a,k1);
  set pJ=stop J, s1 = Initialize s, P1 = P +* pJ,
  IF=if>0(a,k1,I,J), pIF=
  stop IF, s3 = Initialize s, P3 = P +* pIF,
  s4 = Comput(P3,s3,1), P4 = P3;
  set i = (a,k1)<=0_goto (card I + 2);
  set G =Goto (card J+1), iG=i ';' I ';' G;
A3: IF = i ';' (I ';' G) ';' J by SCMPDS_4:50
    .= i ';' (I ';' G ';' J) by SCMPDS_4:50;
A4: Comput(P3, s3,0 + 1) = Following(P3,
Comput(P3,s3,0)) by EXTPRO_1:4
    .= Following(P3,s3) by EXTPRO_1:3
    .= Exec(i,s3) by A3,Th22;
A5: not b in dom Start-At(0,SCMPDS) by SCMPDS_4:59;
  not a in dom Start-At(0,SCMPDS) by SCMPDS_4:59;
  then
A6: s3.DataLoc(s3.a,k1)=s3.b by FUNCT_4:12
    .= s.b by A5,FUNCT_4:12;
A7: IC s3 = 0 by COMPOS_1:223;
  assume
  s.b <= 0;
  then
A8: IC s4 = ICplusConst(s3,card I + 2) by A4,A6,SCMPDS_2:68
    .= (0+(card I + 2)) by A7,Th23;
  assume
A9: J is_closed_on s,P;
  then
A10: Start-At(0,SCMPDS) c= s1 & J is_closed_on s1,P1 by Th38,FUNCT_4:26;
UU:  stop J c= P1 by FUNCT_4:26;
A11: pIF c= P3 by FUNCT_4:26;
A12: card iG = card (i ';' I) + card G by AFINSQ_1:20
    .=card (i ';' I) + 1 by SCMPDS_5:6
    .=card I +1 +1 by Th15
    .=card I +(1 +1);
  then Shift(pJ,card I+2) c= pIF by Th24;
  then
A13: Shift(pJ,card I+2) c= P4 by A11,XBOOLE_1:1;
  assume
  J is_halting_on s,P;
  then
A14: P1 halts_on s1 by Def3;
  now
    let a;
    thus s1.a = s3.a
      .= s4.a by A4,SCMPDS_2:68;
  end;
  then
A16: DataPart s1 = DataPart s4 by SCMPDS_4:23;
  now
    let k be Element of NAT;
    per cases;
    suppose
      0 < k;
      then consider k1 being Nat such that
A17:  k1 + 1 = k by NAT_1:6;
      reconsider k1 as Element of NAT by ORDINAL1:def 13;
      reconsider m = IC Comput(P1, s1,k1) as Element of NAT;
       m in dom pJ by A9,Def2;
      then m < card pJ by AFINSQ_1:70;
      then
A18:  m + (card I + 2) < card pJ + (card I + 2) by XREAL_1:8;
A19:  card pJ = card J + 1 by SCMPDS_5:7;
A20:  card pIF = card IF+1 by SCMPDS_5:7
        .=card I +2 +card J +1 by A12,AFINSQ_1:20
        .=card I +2 + card pJ by A19;
      IC Comput(P3,s3,k) = IC Comput(P3, s4,k1) by
A17,EXTPRO_1:5
        .=  (m + (card I + 2)) by A10,A16,A13,A8,Th45,UU;
      hence IC Comput(P3,s3,k) in dom pIF by A20,A18,AFINSQ_1:70;
    end;
    suppose
      k = 0;
      then Comput(P3,s3,k) = s3 by EXTPRO_1:3;
      hence IC Comput(P3,s3,k) in dom pIF by A7,COMPOS_1:135;
    end;
  end;
  hence IF is_closed_on s,P by Def2;
A23: Comput(P3,s3,LifeSpan(P1,s1)+1)
 = Comput(P3,Comput(P3,s3,1),LifeSpan(P1
,s1))
 by EXTPRO_1:5;
  CurInstr(P3,
  Comput(P3,s3,LifeSpan(P1,s1)+1))
   =CurInstr(P3,
   Comput(P3,s4,LifeSpan(P1,s1))) by A23
    .=CurInstr(P1,
    Comput(P1,s1,LifeSpan(P1,s1))) by A10,A16,A13,A8
,Th45,UU
    .= halt SCMPDS by A14,EXTPRO_1:def 14;
  then P3 halts_on s3 by EXTPRO_1:30;
  hence thesis by Def3;
end;

theorem Th84:
  for s being State of SCMPDS,I being halt-free shiftable
Program of SCMPDS, J being shiftable Program of SCMPDS,a being Int_position,k1
  being Integer st s.DataLoc(s.a,k1) > 0 & I is_closed_on s,P &
  I is_halting_on s,P
holds IExec(if>0(a,k1,I,J),P,s) = IExec(I,P,s) +* Start-At((card I + card J
  + 2),SCMPDS)
proof
  let s be State of SCMPDS,I be halt-free shiftable Program of SCMPDS, J be
  shiftable Program of SCMPDS,a be Int_position,k1 be Integer;
  set b=DataLoc(s.a,k1);
  set G=Goto (card J+1);
  set I2 = I ';' G ';' J, IF=if>0(a,k1,I,J), pIF = stop IF, pI2=
stop I2, s2 = Initialize s, P2 = P +* pI2,
s3 = Initialize s,
      P3 = P +* pIF,
s4 = Comput(P3,s3,1), P4 = P3;
  set i = (a,k1)<=0_goto (card I + 2);
  set SAl= Start-At((card I+card J+2),SCMPDS);
A3: IC s3 = 0 by COMPOS_1:223;
A4: not b in dom Start-At(0,SCMPDS) by SCMPDS_4:59;
  not a in dom Start-At(0,SCMPDS) by SCMPDS_4:59;
  then
A5: s3.DataLoc(s3.a,k1)=s3.b by FUNCT_4:12
    .= s.b by A4,FUNCT_4:12;
A6: dom ProgramPart s = A by COMPOS_1:34;
A7: IF = i ';' (I ';' G) ';' J by SCMPDS_4:50
    .= i ';' I2 by SCMPDS_4:50;
  then
A8: Shift(pI2,1) c= P4 by Lm6;
A9: Comput(P3, s3,0 + 1) = Following(P3,
Comput(P3,s3,0)) by EXTPRO_1:4
    .= Following(P3,s3) by EXTPRO_1:3
    .= Exec(i,s3) by A7,Th22;
  assume
  s.b > 0;
  then
A10: IC s4 = succ IC s3 by A9,A5,SCMPDS_2:68
    .= (0+1) by A3;
  now
    let a;
    thus s2.a = s3.a
      .= s4.a by A9,SCMPDS_2:68;
  end;
  then
A12: DataPart s2 = DataPart s4 by SCMPDS_4:23;
  assume
A13: I is_closed_on s,P;
  assume
A14: I is_halting_on s,P;
  then I2 is_halting_on s,P by A13,Th44;
  then
A15: P2 halts_on s2 by Def3;
  I2 is_closed_on s,P by A13,A14,Th44;
  then
A16: Start-At(0,SCMPDS) c= s2 & I2 is_closed_on s2,P2 by Th38,FUNCT_4:26;
UU:  stop I2 c= P2 by FUNCT_4:26;
A18: Comput(P3,s3,LifeSpan(P2,s2)+1)
= Comput(P3,Comput(P3,s3,1),LifeSpan(P2,
s2))
 by EXTPRO_1:5;
A21: CurInstr(P3,
Comput(P3,s3,LifeSpan(P2,s2)+1))
 =CurInstr(P3,
 Comput(P3,s4,LifeSpan(P2,s2))) by A18
    .=CurInstr(P2,
    Comput(P2,s2,LifeSpan(P2,s2))) by A16,A8,A10,A12
,Th45,UU
    .= halt SCMPDS by A15,EXTPRO_1:def 14;
  then
A22: P3 halts_on s3 by EXTPRO_1:30;
A23: CurInstr(P3,s3) = i by A7,Th22;
  now
    let l be Element of NAT;
    assume
A24: l < LifeSpan(P2,s2) + 1;
A25: Comput(P3,s3,0) = s3 by EXTPRO_1:3;
    per cases;
    suppose
      l = 0;
      then CurInstr(P3,Comput(P3,s3,l))
       = CurInstr(P3,s3)
       by A25;
      hence CurInstr(P3,Comput(P3,s3,l))
       <> halt SCMPDS by A23;
    end;
    suppose
      l <> 0;
      then consider n be Nat such that
A26:  l = n + 1 by NAT_1:6;
      reconsider n as Element of NAT by ORDINAL1:def 13;
A27:  n < LifeSpan(P2,s2) by A24,A26,XREAL_1:8;
      assume
A28:  CurInstr(P3,Comput(P3,s3,l)) = halt SCMPDS;
A32: Comput(P3,s3,n+1)
 = Comput(P3,Comput(P3,s3,1),n) by EXTPRO_1:5;
      CurInstr(P2,Comput(P2,s2,n)) =
      CurInstr(P3,Comput(P3,s4,n)) by A16,A8,A10,A12
,Th45,UU
        .= halt SCMPDS by A26,A28,A32;
      hence contradiction by A15,A27,EXTPRO_1:def 14;
    end;
  end;
  then for l be Element of NAT st CurInstr(P3,
  Comput(P3,s3,l)) = halt SCMPDS
  holds LifeSpan(P2,s2) + 1 <= l;
  then
A33: LifeSpan(P3,s3) = LifeSpan(P2,s2) + 1 by A21,A22
,EXTPRO_1:def 14;
A35: DataPart Result(P2,s2) = DataPart Comput(P2, s2
,LifeSpan(P2,s2)) by A15,EXTPRO_1:23
    .= DataPart Comput(P3, s4,LifeSpan(P2,s2))
    by A16,A8,A10,A12,Th45,UU
    .= DataPart Comput(P3, s3,LifeSpan(P2,s2) + 1)
by EXTPRO_1:5
    .= DataPart Result(P3,s3) by A22,A33,EXTPRO_1:23;
A36: now
    let x be set;
A37: dom SAl = {IC SCMPDS} by FUNCOP_1:19;
    assume
A38: x in dom IExec(IF,P,s);
    per cases by A38,SCMPDS_4:20;
    suppose
A39:  x is Int_position;
      then x <> IC SCMPDS by SCMPDS_2:52;
      then
A40:  not x in dom SAl by A37,TARSKI:def 1;
A41: not x in dom (s | A) by A6,A39,SCMPDS_2:53;
      hence IExec(IF,P,s).x = (Result(P3,s3)).x by FUNCT_4:12
        .= (Result(P2,s2)).x by A35,A39,SCMPDS_4:23
        .= IExec(I2,P,s).x by A41,FUNCT_4:12
        .= (IExec(I2,P,s) +* SAl).x by A40,FUNCT_4:12;
    end;
    suppose
A42:  x = IC SCMPDS;
A43: not x in dom (s | A) by A6,A42,COMPOS_1:3;
      then
A44:  IC Result(P2,s2) = IC IExec(I2,P,s) by A42,FUNCT_4:12
        .=  (card I + card J + 1) by A13,A14,Th46;
A45:  x in dom SAl by A37,A42,TARSKI:def 1;
      thus IExec(IF,P,s).x = (Result(P3,s3)).x by A43,FUNCT_4:12
        .= Comput(P3, s3,LifeSpan(P2,s2) + 1).x by
A22,A33,EXTPRO_1:23
        .= IC Comput(P3, s4,LifeSpan(P2,s2)) by A42,
EXTPRO_1:5
        .= IC Comput(P2, s2,LifeSpan(P2,s2)) + 1 by
A16,A8,A10,A12,Th45,UU
        .= IC Result(P2,s2) + 1 by A15,EXTPRO_1:23
        .= IC Start-At(((card I + card J + 1) + 1),SCMPDS) by A44,FUNCOP_1:87
        .= (IExec(I2,P,s) +* SAl).x by A42,A45,FUNCT_4:14;
    end;
    suppose
      x is Element of NAT;
      hence IExec(IF,P,s).x = (IExec(I2,P,s) +* SAl).x by Th26;
    end;
  end;
  dom IExec(IF,P,s) = the carrier of SCMPDS by PARTFUN1:def 4
    .= dom (IExec(I2,P,s) +* SAl) by PARTFUN1:def 4;
  hence IExec(IF,P,s) = IExec(I2,P,s) +* SAl by A36,FUNCT_1:9
    .= IExec(I,P,s) +* Start-At((card I + card J + 1),SCMPDS) +*
     Start-At(
   (card I + card J + 2),SCMPDS) by A13,A14,Th47
    .= IExec(I,P,s) +* SAl by COMPOS_1:199;
end;

theorem Th85:
  for s being State of SCMPDS,I being Program of SCMPDS,J being
  halt-free shiftable Program of SCMPDS,a being Int_position,k1 being Integer
  st s.DataLoc(s.a,k1) <= 0 & J is_closed_on s,P & J is_halting_on s,P
   holds IExec(if>0(a,k1,I,J),P,s)
    = IExec(J,P,s) +* Start-At((card I+card J+2),SCMPDS)
proof
  let s be State of SCMPDS,I be Program of SCMPDS,J be halt-free shiftable
  Program of SCMPDS,a be Int_position,k1 be Integer;
  set b=DataLoc(s.a,k1);
  set pJ=stop J, s1 = Initialize s, P1 = P +* pJ,
  IF=if>0(a,k1,I,J), pIF=
  stop IF, s3 = Initialize s, P3 = P +* pIF,
  s4 = Comput(P3,s3,1), P4 = P3;
  set i = (a,k1)<=0_goto (card I + 2);
  set G =Goto (card J+1), iG=i ';' I ';' G;
  set SAl=Start-At((card I+card J+2),SCMPDS);
A3: IF = i ';' (I ';' G) ';' J by SCMPDS_4:50
    .= i ';' (I ';' G ';' J) by SCMPDS_4:50;
A4: Comput(P3, s3,0 + 1) = Following(P3,
Comput(P3,s3,0)) by EXTPRO_1:4
    .= Following(P3,s3) by EXTPRO_1:3
    .= Exec(i,s3) by A3,Th22;
A5: not b in dom Start-At(0,SCMPDS) by SCMPDS_4:59;
  not a in dom Start-At(0,SCMPDS) by SCMPDS_4:59;
  then
A6: s3.DataLoc(s3.a,k1)=s3.b by FUNCT_4:12
    .= s.b by A5,FUNCT_4:12;
A7: IC s3 = 0 by COMPOS_1:223;
A8: dom ProgramPart s = A by COMPOS_1:34;
  assume
  s.b <= 0;
  then
A9: IC s4 = ICplusConst(s3,card I + 2) by A4,A6,SCMPDS_2:68
    .= (0+(card I + 2)) by A7,Th23;
  now
    let a;
    thus s1.a = s3.a
      .= s4.a by A4,SCMPDS_2:68;
  end;
  then
A11: DataPart s1 = DataPart s4 by SCMPDS_4:23;
  card iG = card (i ';' I) + card G by AFINSQ_1:20
    .=card (i ';' I) + 1 by SCMPDS_5:6
    .=card I +1 +1 by Th15
    .=card I +(1 +1);
  then
A12: Shift(pJ,card I+2) c= pIF by Th24;
  pIF c= P3 by FUNCT_4:26;
  then
A13: Shift(pJ,card I+2) c= P4 by A12,XBOOLE_1:1;
  assume
A14: J is_closed_on s,P;
  then
A15: Start-At(0,SCMPDS) c= s1 & J is_closed_on s1,P1 by Th38,FUNCT_4:26;
UU:  stop J c= P1 by FUNCT_4:26;
  assume
A16: J is_halting_on s,P;
  then
A17: P1 halts_on s1 by Def3;
A19: Comput(P3,s3,LifeSpan(P1,s1)+1)
 = Comput(P3,Comput(P3,s3,1),LifeSpan(P1
,s1))
 by EXTPRO_1:5;
A22: CurInstr(P3,
Comput(P3,s3,LifeSpan(P1,s1)+1))
 =CurInstr(P3,
 Comput(P3,s4,LifeSpan(P1,s1))) by A19
    .=CurInstr(P1,
    Comput(P1,s1,LifeSpan(P1,s1))) by A15,A13,A9,A11
,Th45,UU
    .= halt SCMPDS by A17,EXTPRO_1:def 14;
  then
A23: P3 halts_on s3 by EXTPRO_1:30;
A24: CurInstr(P3,s3) = i by A3,Th22;
  now
    let l be Element of NAT;
    assume
A25: l < LifeSpan(P1,s1) + 1;
A26: Comput(P3,s3,0) = s3 by EXTPRO_1:3;
    per cases;
    suppose
      l = 0;
      then CurInstr(P3,Comput(P3,s3,l))
       = CurInstr(P3,s3)
       by A26;
      hence CurInstr(P3,Comput(P3,s3,l))
       <> halt SCMPDS by A24;
    end;
    suppose
      l <> 0;
      then consider n be Nat such that
A27:  l = n + 1 by NAT_1:6;
      reconsider n as Element of NAT by ORDINAL1:def 13;
A28:  n < LifeSpan(P1,s1) by A25,A27,XREAL_1:8;
      assume
A29:  CurInstr(P3,Comput(P3,s3,l)) = halt SCMPDS;
A31: Comput(P3,s3,n+1)
 = Comput(P3,Comput(P3,s3,1),n) by EXTPRO_1:5;
      CurInstr(P1,Comput(P1,s1,n))
       = CurInstr(P3,
      Comput(P3,s4,n)) by A15,A13,A9,A11,Th45,UU
        .= halt SCMPDS by A27,A29,A31;
      hence contradiction by A17,A28,EXTPRO_1:def 14;
    end;
  end;
  then for l be Element of NAT st CurInstr(P3,
  Comput(P3,s3,l)) = halt SCMPDS
  holds LifeSpan(P1,s1) + 1 <= l;
  then
A34: LifeSpan(P3,s3) = LifeSpan(P1,s1) + 1 by A22,A23
,EXTPRO_1:def 14;
A35: DataPart Result(P1,s1) = DataPart Comput(P1, s1
,LifeSpan(P1,s1)) by A17,EXTPRO_1:23
    .= DataPart Comput(P3, s4,LifeSpan(P1,s1))
    by A15,A13,A9,A11,Th45,UU
    .= DataPart Comput(P3, s3,LifeSpan(P1,s1) + 1)
by EXTPRO_1:5
    .= DataPart Result(P3,s3) by A23,A34,EXTPRO_1:23;
A36: now
    let x be set;
A37: dom SAl = {IC SCMPDS} by FUNCOP_1:19;
    assume
A38: x in dom IExec(IF,P,s);
    per cases by A38,SCMPDS_4:20;
    suppose
A39:  x is Int_position;
      then x <> IC SCMPDS by SCMPDS_2:52;
      then
A40:  not x in dom SAl by A37,TARSKI:def 1;
A41: not x in dom (s | A) by A8,A39,SCMPDS_2:53;
      hence IExec(IF,P,s).x = (Result(P3,s3)).x by FUNCT_4:12
        .= (Result(P1,s1)).x by A35,A39,SCMPDS_4:23
        .= IExec(J,P,s).x by A41,FUNCT_4:12
        .= (IExec(J,P,s) +* SAl).x by A40,FUNCT_4:12;
    end;
    suppose
A42:  x = IC SCMPDS;
A43: not x in dom (s | A) by A8,A42,COMPOS_1:3;
      then
A44:  IC Result(P1,s1) = IC IExec(J,P,s) by A42,FUNCT_4:12
        .=  (card J) by A14,A16,Th48;
A45:  x in dom SAl by A37,A42,TARSKI:def 1;
      thus IExec(IF,P,s).x = (Result(P3,s3)).x by A43,FUNCT_4:12
        .= Comput(P3, s3,LifeSpan(P1,s1) + 1).x by
A23,A34,EXTPRO_1:23
        .= IC Comput(P3, s4,LifeSpan(P1,s1)) by A42,
EXTPRO_1:5
        .= IC Comput(P1, s1,LifeSpan(P1,s1)) + (card
I + 2) by A15,A13,A9,A11,Th45,UU
        .= IC Result(P1,s1) + (card I + 2) by A17,EXTPRO_1:23
        .= IC Start-At (card J + (card I + 2),SCMPDS) by A44,FUNCOP_1:87
        .= (IExec(J,P,s) +* SAl).x by A42,A45,FUNCT_4:14;
    end;
    suppose
      x is Element of NAT;
      hence IExec(IF,P,s).x = (IExec(J,P,s) +* SAl).x by Th26;
    end;
  end;
  dom IExec(IF,P,s) = the carrier of SCMPDS by PARTFUN1:def 4
    .= dom (IExec(J,P,s) +* SAl) by PARTFUN1:def 4;
  hence thesis by A36,FUNCT_1:9;
end;

registration
  let I,J be shiftable parahalting Program of SCMPDS, a be Int_position,k1 be
  Integer;
  cluster if>0(a,k1,I,J) -> shiftable parahalting;
  correctness
  proof
    set i = (a,k1)<=0_goto (card I + 2), G =Goto (card J+1);
    set IF=if>0(a,k1,I,J), pIF = stop IF;
    reconsider IJ=I ';' G ';' J as shiftable Program of SCMPDS;
    thus IF is shiftable;
      let s be 0-started State of SCMPDS;
      let P be (the Instructions of SCMPDS)-valued ManySortedSet of NAT;
A1:  Initialize s = s by COMPOS_1:78;
      assume pIF c= P;
      then
A2:   P = P +* stop IF by FUNCT_4:104;
A3:   J is_closed_on s,P & J is_halting_on s,P by Th34,Th35;
A4:   I is_closed_on s,P & I is_halting_on s,P by Th34,Th35;
      per cases;
      suppose
        s.DataLoc(s.a,k1) > 0;
        then IF is_halting_on s,P by A4,Th82;
        hence P halts_on s by A1,A2,Def3;
      end;
      suppose
        s.DataLoc(s.a,k1) <= 0;
        then IF is_halting_on s,P by A3,Th83;
        hence P halts_on s by A1,A2,Def3;
      end;
  end;
end;

registration
  let I,J be halt-free Program of SCMPDS, a be Int_position,k1 be Integer;
  cluster if>0(a,k1,I,J) -> halt-free;
  coherence;
end;

theorem
  for s being State of SCMPDS,I,J being halt-free shiftable
  parahalting Program of SCMPDS,a being Int_position,k1 being Integer holds IC
  IExec(if>0(a,k1,I,J),P,s) =  (card I + card J + 2)
proof
  let s be State of SCMPDS,I,J be halt-free shiftable parahalting Program of
  SCMPDS,a be Int_position,k1 be Integer;
  set IF=if>0(a,k1,I,J);
A1: I is_closed_on s,P & I is_halting_on s,P by Th34,Th35;
A2: J is_closed_on s,P & J is_halting_on s,P by Th34,Th35;
  per cases;
  suppose
    s.DataLoc(s.a,k1) > 0;
    then IExec(IF,P,s) = IExec(I,P,s) +* Start-At((card I+card J+2),SCMPDS)
    by A1,Th84;
    hence thesis by FUNCT_4:121;
  end;
  suppose
    s.DataLoc(s.a,k1) <= 0;
    then IExec(IF,P,s) = IExec(J,P,s) +* Start-At((card I+card J+2),SCMPDS)
    by A2,Th85;
    hence thesis by FUNCT_4:121;
  end;
end;

theorem
  for s being State of SCMPDS,I being halt-free shiftable parahalting
  Program of SCMPDS,J being shiftable Program of SCMPDS,a,b being Int_position,
k1 being Integer st s.DataLoc(s.a,k1)>0 holds
 IExec(if>0(a,k1,I,J),P,s).b = IExec(I,P,s).b
proof
  let s be State of SCMPDS,I be halt-free shiftable parahalting Program of
  SCMPDS,J be shiftable Program of SCMPDS,a,b be Int_position, k1 be Integer;
  assume
A1: s.DataLoc(s.a,k1)>0;
A2: not b in dom Start-At((card I+card J+2),SCMPDS) by SCMPDS_4:59;
  I is_closed_on s,P & I is_halting_on s,P by Th34,Th35;
  then
  IExec(if>0(a,k1,I,J),P,s) = IExec(I,P,s) +* Start-At((card I + card J
  + 2),SCMPDS) by A1,Th84;
  hence thesis by A2,FUNCT_4:12;
end;

theorem
  for s being State of SCMPDS,I being Program of SCMPDS,J being
  halt-free parahalting shiftable Program of SCMPDS,a,b being Int_position,k1
being Integer st s.DataLoc(s.a,k1) <= 0 holds
 IExec(if>0(a,k1,I,J),P,s).b = IExec(J,P,s).b
proof
  let s be State of SCMPDS,I be Program of SCMPDS,J be halt-free parahalting
  shiftable Program of SCMPDS,a,b be Int_position, k1 be Integer;
  set IF=if>0(a,k1,I,J);
  assume
A1: s.DataLoc(s.a,k1) <= 0;
A2: not b in dom Start-At((card I+card J+2),SCMPDS) by SCMPDS_4:59;
  J is_closed_on s,P & J is_halting_on s,P by Th34,Th35;
  then IExec(IF,P,s) =IExec(J,P,s) +* Start-At((card I+card J+2),SCMPDS)
  by A1,Th85;
  hence thesis by A2,FUNCT_4:12;
end;

begin :: The computation of "if var>0 then block"

theorem
  card if>0(a,k1,I) = card I + 1 by Th15;

theorem
   0 in dom if>0(a,k1,I)
proof
  set ci=card if>0(a,k1,I);
  ci=card I + 1 by Th15;
  hence thesis by AFINSQ_1:70;
end;

theorem
  if>0(a,k1,I). 0 = (a,k1)<=0_goto (card I + 1) by Th16;

theorem Th92:
  for s being State of SCMPDS, I being shiftable Program of SCMPDS
  , a being Int_position,k1 being Integer st s.DataLoc(s.a,k1)> 0 & I
is_closed_on s,P & I is_halting_on s,P holds if>0(a,k1,I) is_closed_on s,P
 & if>0(a,
  k1,I) is_halting_on s,P
proof
  let s be State of SCMPDS, I be shiftable Program of SCMPDS, a be
  Int_position,k1 be Integer;
  set b=DataLoc(s.a,k1);
  set IF=if>0(a,k1,I), pIF=stop IF, pI=stop I,
   s2 = Initialize s, s3 = Initialize s,
   P2 = P +* pI, P3 = P +* pIF,
   s4 = Comput(P3,s3,1), P4 = P3;
  set i = (a,k1)<=0_goto (card I + 1);
A3:  0 in dom pIF by COMPOS_1:135;
A4: IC s3 = 0 by COMPOS_1:223;
A5: not b in dom Start-At(0,SCMPDS) by SCMPDS_4:59;
  not a in dom Start-At(0,SCMPDS) by SCMPDS_4:59;
  then
A6: s3.DataLoc(s3.a,k1)=s3.b by FUNCT_4:12
    .= s.b by A5,FUNCT_4:12;
A7: Comput(P3, s3,0 + 1) = Following(P3,
Comput(P3,s3,0)) by EXTPRO_1:4
    .= Following(P3,s3) by EXTPRO_1:3
    .= Exec(i,s3) by Th22;
  now
    let a;
    thus s2.a = s3.a
      .= s4.a by A7,SCMPDS_2:68;
  end;
  then
A9: DataPart s2 = DataPart s4 by SCMPDS_4:23;
  assume
  s.b > 0;
  then
A10: IC s4 = succ IC s3 by A7,A6,SCMPDS_2:68
    .= (0+1) by A4;
  assume
A11: I is_closed_on s,P;
  then
A12: I is_closed_on s2,P2 by Th38;
  assume
  I is_halting_on s,P;
  then
A13: P2 halts_on s2 by Def3;
A14: Start-At(0,SCMPDS) c= s2 & Shift(pI,1) c= P4 by Lm6,FUNCT_4:26;
UU:  stop I c= P2 by FUNCT_4:26;
A15: card pIF = card IF +1 by SCMPDS_5:7
    .= card I +1+1 by Th15;
  now
    let k be Element of NAT;
    per cases;
    suppose
      0 < k;
      then consider k1 being Nat such that
A16:  k1 + 1 = k by NAT_1:6;
      reconsider k1 as Element of NAT by ORDINAL1:def 13;
      reconsider m = IC Comput(P2, s2,k1) as Element of NAT;
A17:  card pIF = card pI+1 by A15,SCMPDS_5:7;
       m in dom pI by A11,Def2;
      then m < card pI by AFINSQ_1:70;
      then
A18:  m+1 < card pIF by A17,XREAL_1:8;
      IC Comput(P3,s3,k) = IC Comput(P3, s4,k1) by
A16,EXTPRO_1:5
        .=  (m + 1) by A12,A14,A10,A9,Th45,UU;
      hence IC Comput(P3,s3,k) in dom pIF by A18,AFINSQ_1:70;
    end;
    suppose
      k = 0;
      hence IC Comput(P3,s3,k) in dom pIF by A3,A4,EXTPRO_1:3;
    end;
  end;
  hence IF is_closed_on s,P by Def2;
A21: Comput(P3,s3,LifeSpan(P2,s2)+1)
 = Comput(P3,Comput(P3,s3,1),LifeSpan(P2
,s2))
 by EXTPRO_1:5;
  CurInstr(P3,
  Comput(P3,s3,LifeSpan(P2,s2)+1))
   =CurInstr(P3,Comput(P3,s4,LifeSpan(P2,s2))) by A21
    .=CurInstr(P2,Comput(P2,s2,LifeSpan(P2,s2))) by A12,A14,A10,A9
,Th45,UU
    .= halt SCMPDS by A13,EXTPRO_1:def 14;
  then P3 halts_on s3 by EXTPRO_1:30;
  hence thesis by Def3;
end;

theorem Th93:
  for s being State of SCMPDS,I being Program of SCMPDS, a being
  Int_position, k1 being Integer st s.DataLoc(s.a,k1) <= 0 holds if>0(a,k1,I)
  is_closed_on s,P & if>0(a,k1,I) is_halting_on s,P
proof
  let s be State of SCMPDS,I be Program of SCMPDS, a be Int_position,k1 be
  Integer;
  set b=DataLoc(s.a,k1);
  assume
A1: s.b <= 0;
  set i = (a,k1)<=0_goto (card I + 1);
  set IF=if>0(a,k1,I), pIF=stop IF, s3 = Initialize s,
  P3 = P +* pIF,
  s4 = Comput(P3,s3,1), P4 = P3;
A3: IC s3 = 0 by COMPOS_1:223;
A4: not b in dom Start-At(0,SCMPDS) by SCMPDS_4:59;
  not a in dom Start-At(0,SCMPDS) by SCMPDS_4:59;
  then
A5: s3.DataLoc(s3.a,k1)=s3.b by FUNCT_4:12
    .= s.b by A4,FUNCT_4:12;
  Comput(P3, s3,0 + 1) = Following(P3,
  Comput(P3,s3,0)) by EXTPRO_1:4
    .= Following(P3,s3) by EXTPRO_1:3
    .= Exec(i,s3) by Th22;
  then
A6: IC s4 = ICplusConst(s3,card I + 1) by A1,A5,SCMPDS_2:68
    .= (0+(card I + 1)) by A3,Th23;
A7: card IF=card I+1 by Th15;
  then
A8: (card I+1) in dom pIF by Th25;
A9:  P3/.IC s4
 = P3.IC s4 by PBOOLE:158;
  pIF c= P3 by FUNCT_4:26;
  then pIF c= P4;
  then P4.(card I+1) = pIF.(card I+1) by A8,GRFUNC_1:8
    .=halt SCMPDS by A7,Th25;
  then
A10: CurInstr(P3,s4) = halt SCMPDS by A6,A9;
  now
    let k be Element of NAT;
    per cases;
    suppose
      0 < k;
      then 1+0 <= k by INT_1:20;
      hence IC Comput(P3,s3,k) in dom pIF by A8,A6,A10,
EXTPRO_1:6;
    end;
    suppose
      k = 0;
      then Comput(P3,s3,k) = s3 by EXTPRO_1:3;
      hence IC Comput(P3,s3,k) in dom pIF by A3,COMPOS_1:135;
    end;
  end;
  hence IF is_closed_on s,P by Def2;
  P3 halts_on s3 by A10,EXTPRO_1:30;
  hence thesis by Def3;
end;

theorem Th94:
  for s being State of SCMPDS,I being halt-free shiftable
Program of SCMPDS, a being Int_position,k1 being Integer st s.DataLoc(s.a,k1)>
0 & I is_closed_on s,P & I is_halting_on s,P
 holds IExec(if>0(a,k1,I),P,s) = IExec(I,P,s) +* Start-At((card I+1),SCMPDS)
proof
  let s be State of SCMPDS,I be halt-free shiftable Program of SCMPDS, a be
  Int_position,k1 be Integer;
  set b=DataLoc(s.a,k1);
  set IF=if>0(a,k1,I), pI=stop I, pIF = stop IF,
   s2 = Initialize s, s3 = Initialize s,
   P2 = P +* pI, P3 = P +* pIF,
   s4 = Comput(P3, s3,1), P4 = P3;
  set i = (a,k1)<=0_goto (card I + 1);
  set SAl=Start-At((card I+1),SCMPDS);
A3: IC s3 = 0 by COMPOS_1:223;
A4: not b in dom Start-At(0,SCMPDS) by SCMPDS_4:59;
  not a in dom Start-At(0,SCMPDS) by SCMPDS_4:59;
  then
A5: s3.DataLoc(s3.a,k1)=s3.b by FUNCT_4:12
    .= s.b by A4,FUNCT_4:12;
A6: Comput(P3, s3,0 + 1) = Following(P3,
Comput(P3,s3,0)) by EXTPRO_1:4
    .= Following(P3,s3) by EXTPRO_1:3
    .= Exec(i,s3) by Th22;
  assume
  s.b > 0;
  then
A7: IC s4 = succ IC s3 by A6,A5,SCMPDS_2:68
    .= (0+1) by A3;
  now
    let a;
    thus s2.a = s3.a
      .= s4.a by A6,SCMPDS_2:68;
  end;
  then
A9: DataPart s2 = DataPart s4 by SCMPDS_4:23;
  assume
A10: I is_closed_on s,P;
  then
A11: I is_closed_on s2,P2 by Th38;
A12: dom ProgramPart s = A by COMPOS_1:34;
A13: Start-At(0,SCMPDS) c= s2 & Shift(pI,1) c= P4 by Lm6,FUNCT_4:26;
UU:  stop I c= P2 by FUNCT_4:26;
  assume
A14: I is_halting_on s,P;
  then
A15: P2 halts_on s2 by Def3;
A17: Comput(P3,s3,LifeSpan(P2,s2)+1)
 = Comput(P3,Comput(P3,s3,1),LifeSpan(P2
,s2))
by EXTPRO_1:5;
A20: CurInstr(P3,
Comput(P3,s3,LifeSpan(P2,s2)+1))
 =CurInstr(P3,
 Comput(P3,s4,LifeSpan(P2,s2))) by A17
    .=CurInstr(P2,
    Comput(P2,s2,LifeSpan(P2,s2))) by A11,A13,A7,A9
,Th45,UU
    .= halt SCMPDS by A15,EXTPRO_1:def 14;
  then
A21: P3 halts_on s3 by EXTPRO_1:30;
A22: CurInstr(P3,s3) = i by Th22;
  now
    let l be Element of NAT;
    assume
A23: l < LifeSpan(P2,s2) + 1;
A24: Comput(P3,s3,0) = s3 by EXTPRO_1:3;
    per cases;
    suppose
      l = 0;
      then CurInstr(P3,Comput(P3,s3,l))
       = CurInstr(P3,s3)
       by A24;
      hence CurInstr(P3,Comput(P3,s3,l))
       <> halt SCMPDS by A22;
    end;
    suppose
      l <> 0;
      then consider n be Nat such that
A25:  l = n + 1 by NAT_1:6;
      reconsider n as Element of NAT by ORDINAL1:def 13;
A26:  n < LifeSpan(P2,s2) by A23,A25,XREAL_1:8;
      assume
A27:  CurInstr(P3,Comput(P3,
s3,l)) = halt SCMPDS;
A29: Comput(P3,s3,n+1)
 = Comput(P3,Comput(P3,s3,1),n) by EXTPRO_1:5;
      CurInstr(P2,Comput(P2,s2,n)) =
      CurInstr(P3,Comput(P3,s4,n)) by A11,A13,A7,A9,Th45,UU
        .= halt SCMPDS by A25,A27,A29;
      hence contradiction by A15,A26,EXTPRO_1:def 14;
    end;
  end;
  then for l be Element of NAT st CurInstr(P3,
  Comput(P3,s3,l)) = halt SCMPDS
  holds LifeSpan(P2,s2) + 1 <= l;
  then
A32: LifeSpan(P3,s3) = LifeSpan(P2,s2) + 1 by A20,A21
,EXTPRO_1:def 14;
A34: DataPart Result(P2,s2) = DataPart Comput(P2,s2,
LifeSpan(P2,s2)) by A15,EXTPRO_1:23
    .= DataPart Comput(P3, s4,LifeSpan(P2,s2)) by A11
,A13,A7,A9,Th45,UU
    .= DataPart Comput(P3, s3,LifeSpan(P2,s2) + 1)
by EXTPRO_1:5
    .= DataPart Result(P3,s3) by A21,A32,EXTPRO_1:23;
A35: now
    let x be set;
A36: dom SAl = {IC SCMPDS} by FUNCOP_1:19;
    assume
A37: x in dom IExec(IF,P,s);
    per cases by A37,SCMPDS_4:20;
    suppose
A38:  x is Int_position;
      then x <> IC SCMPDS by SCMPDS_2:52;
      then
A39:  not x in dom SAl by A36,TARSKI:def 1;
A40: not x in dom (s | A) by A12,A38,SCMPDS_2:53;
      hence IExec(IF,P,s).x = (Result(P3,s3)).x by FUNCT_4:12
        .= (Result(P2,s2)).x by A34,A38,SCMPDS_4:23
        .= IExec(I,P,s).x by A40,FUNCT_4:12
        .= (IExec(I,P,s) +* SAl).x by A39,FUNCT_4:12;
    end;
    suppose
A41:  x = IC SCMPDS;
A42: not x in dom (s | A) by A12,A41,COMPOS_1:3;
      then
A43:  IC Result(P2,s2) = IC IExec(I,P,s) by A41,FUNCT_4:12
        .=  card I by A10,A14,Th48;
A44:  x in dom SAl by A36,A41,TARSKI:def 1;
      thus IExec(IF,P,s).x = (Result(P3,s3)).x by A42,FUNCT_4:12
        .= Comput(P3, s3,LifeSpan(P2,s2) + 1).x by
A21,A32,EXTPRO_1:23
        .= IC Comput(P3, s4,LifeSpan(P2,s2)) by A41,
EXTPRO_1:5
        .= IC Comput(P2, s2,LifeSpan(P2,s2)) + 1
        by A11,A13,A7,A9,Th45,UU
        .= IC Result(P2,s2) + 1 by A15,EXTPRO_1:23
        .= IC SAl by A43,FUNCOP_1:87
        .= (IExec(I,P,s) +* SAl).x by A41,A44,FUNCT_4:14;
    end;
    suppose
      x is Element of NAT;
      hence IExec(IF,P,s).x = (IExec(I,P,s) +* SAl).x by Th26;
    end;
  end;
  dom IExec(IF,P,s) = the carrier of SCMPDS by PARTFUN1:def 4
    .= dom (IExec(I,P,s) +* SAl) by PARTFUN1:def 4;
  hence thesis by A35,FUNCT_1:9;
end;

theorem Th95:
  for s being State of SCMPDS,I being Program of SCMPDS,a being
Int_position, k1 being Integer st s.DataLoc(s.a,k1) <= 0
 holds IExec(if>0(a,k1,I),P,s) = s +* Start-At((card I+1),SCMPDS)
proof
  let s be State of SCMPDS,I be Program of SCMPDS,a be Int_position, k1 be
  Integer;
  set b=DataLoc(s.a,k1);
  set IF=if>0(a,k1,I), pIF=stop IF, s3 = Initialize s,
  P3 = P +* pIF,
  s4 = Comput(P3, s3,1), P4 = P3;
  set i = (a,k1)<=0_goto (card I + 1);
  set SAl=Start-At((card I+1),SCMPDS);
A2: IC s3 = 0 by COMPOS_1:223;
A3: not b in dom Start-At(0,SCMPDS) by SCMPDS_4:59;
  not a in dom Start-At(0,SCMPDS) by SCMPDS_4:59;
  then
A4: s3.DataLoc(s3.a,k1)=s3.b by FUNCT_4:12
    .= s.b by A3,FUNCT_4:12;
A5: Comput(P3, s3,0 + 1) = Following(P3,
Comput(P3,s3,0)) by EXTPRO_1:4
    .= Following(P3,s3) by EXTPRO_1:3
    .= Exec(i,s3) by Th22;
  assume
  s.b <= 0;
  then
A6: IC s4 = ICplusConst(s3,card I + 1) by A5,A4,SCMPDS_2:68
    .= (0+(card I + 1)) by A2,Th23;
  pIF c= P3 by FUNCT_4:26;
  then
A7: pIF c= P4;
A8:  P3/.IC s4
 = P3.IC s4 by PBOOLE:158;
A10: card IF=card I+1 by Th15;
  then (card I+1) in dom pIF by Th25;
  then P4.(card I+1) = pIF.(card I+1) by A7,GRFUNC_1:8
    .=halt SCMPDS by A10,Th25;
  then
A11: CurInstr(P3,s4) = halt SCMPDS by A6,A8;
  then
A12: P3 halts_on s3 by EXTPRO_1:30;
A13: CurInstr(P3,s3) = i by Th22;
  now
    let l be Element of NAT;
A14: Comput(P3,s3,0) = s3 by EXTPRO_1:3;
    assume
    l < 1;
    then l <1+0;
    then l=0 by NAT_1:13;
    then CurInstr(P3,Comput(P3,s3,l))
     = CurInstr(P3,s3) by A14;
    hence CurInstr(P3,Comput(P3,s3,l))
     <> halt SCMPDS by A13;
  end;
  then for l be Element of NAT st CurInstr(P3,
  Comput(P3,s3,l)) = halt SCMPDS
  holds 1 <= l;
  then LifeSpan(P3,s3) = 1 by A11,A12,EXTPRO_1:def 14;
  then
A15: s4 = Result(P3,s3) by A12,EXTPRO_1:23;
A16: dom ProgramPart s = A by COMPOS_1:34;
A17: now
A18: dom SAl = {IC SCMPDS} by FUNCOP_1:19;
    let x be set;
    assume
A19: x in dom IExec(IF,P,s);
    per cases by A19,SCMPDS_4:20;
    suppose
A20:  x is Int_position;
      then x <> IC SCMPDS by SCMPDS_2:52;
      then
A21:  not x in dom SAl by A18,TARSKI:def 1;
TT:   not x in dom Start-At(0,SCMPDS) by A20,SCMPDS_4:59;
      not x in dom (s | A) by A16,A20,SCMPDS_2:53;
      hence IExec(IF,P,s).x = s4.x by A15,FUNCT_4:12
        .= s3.x by A5,A20,SCMPDS_2:68
        .= s.x by TT,FUNCT_4:12
        .= (s +* SAl).x by A21,FUNCT_4:12;
    end;
    suppose
A22:  x = IC SCMPDS;
      not x in dom (s | A) by A16,A22,COMPOS_1:3;
      hence IExec(IF,P,s).x = (card I + 1) by A6,A15,A22,FUNCT_4:12
        .= (s +* SAl).x by A22,FUNCT_4:121;
    end;
    suppose
      x is Element of NAT;
      hence IExec(IF,P,s).x = (s +* SAl).x by Th27;
    end;
  end;
  dom IExec(IF,P,s) = the carrier of SCMPDS by PARTFUN1:def 4
    .= dom (s +* SAl) by PARTFUN1:def 4;
  hence thesis by A17,FUNCT_1:9;
end;

registration
  let I be shiftable parahalting Program of SCMPDS, a be Int_position,k1 be
  Integer;
  cluster if>0(a,k1,I) -> shiftable parahalting;
  correctness
  proof
    set i = (a,k1)<=0_goto (card I +1);
    set IF=if>0(a,k1,I), pIF = stop IF;
    thus IF is shiftable;
      let s be 0-started State of SCMPDS;
      let P be (the Instructions of SCMPDS)-valued ManySortedSet of NAT;
A1:  Initialize s = s by COMPOS_1:78;
      assume pIF c= P;
      then
A2:   P = P +* stop IF by FUNCT_4:104;
A3:   I is_closed_on s,P & I is_halting_on s,P by Th34,Th35;
      per cases;
      suppose
        s.DataLoc(s.a,k1) > 0;
        then IF is_halting_on s,P by A3,Th92;
        hence P halts_on s by A2,Def3,A1;
      end;
      suppose
        s.DataLoc(s.a,k1) <= 0;
        then IF is_halting_on s,P by Th93;
        hence P halts_on s by A2,Def3,A1;
      end;
  end;
end;

registration
  let I be halt-free Program of SCMPDS, a be Int_position,k1 be Integer;
  cluster if>0(a,k1,I) -> halt-free;
  coherence;
end;

theorem
  for s being State of SCMPDS,I being halt-free shiftable parahalting
Program of SCMPDS,a being Int_position,k1 being Integer
 holds IC IExec(if>0(a,k1,I),P,s) =  (card I + 1)
proof
  let s be State of SCMPDS,I be halt-free shiftable parahalting Program of
  SCMPDS,a be Int_position,k1 be Integer;
  set IF=if>0(a,k1,I);
A1: I is_closed_on s,P & I is_halting_on s,P by Th34,Th35;
  per cases;
  suppose
    s.DataLoc(s.a,k1) > 0;
    then IExec(IF,P,s) =IExec(I,P,s) +* Start-At((card I+1),SCMPDS)
    by A1,Th94;
    hence thesis by FUNCT_4:121;
  end;
  suppose
    s.DataLoc(s.a,k1) <= 0;
    then IExec(IF,P,s) =s +* Start-At((card I+1),SCMPDS) by Th95;
    hence thesis by FUNCT_4:121;
  end;
end;

theorem
  for s being State of SCMPDS,I being halt-free shiftable parahalting
Program of SCMPDS,a,b being Int_position,k1 being Integer st s.DataLoc(s.a,k1)>
  0 holds IExec(if>0(a,k1,I),P,s).b = IExec(I,P,s).b
proof
  let s be State of SCMPDS,I be halt-free shiftable parahalting Program of
  SCMPDS,a,b be Int_position,k1 be Integer;
  assume
A1: s.DataLoc(s.a,k1) > 0;
A2: not b in dom Start-At((card I+1),SCMPDS) by SCMPDS_4:59;
  I is_closed_on s,P & I is_halting_on s,P by Th34,Th35;
  then IExec(if>0(a,k1,I),P,s) = IExec(I,P,s) +* Start-At((card I+1),SCMPDS)
  by A1,Th94;
  hence thesis by A2,FUNCT_4:12;
end;

theorem
  for s being State of SCMPDS,I being Program of SCMPDS,a,b being
Int_position, k1 being Integer st s.DataLoc(s.a,k1) <= 0
 holds IExec(if>0(a,k1,I),P,s).b = s.b
proof
  let s be State of SCMPDS,I be Program of SCMPDS,a,b be Int_position, k1 be
  Integer;
  assume
  s.DataLoc(s.a,k1) <= 0;
  then
A1: IExec(if>0(a,k1,I),P,s) = s +* Start-At((card I+1),SCMPDS) by Th95;
  not b in dom Start-At((card I+1),SCMPDS) by SCMPDS_4:59;
  hence thesis by A1,FUNCT_4:12;
end;

begin :: The computation of "if var<=0 then block"

theorem
  card if<=0(a,k1,I) = card I + 2 by Lm8;

theorem
   0 in dom if<=0(a,k1,I) &  1 in dom if<=0(a,k1,I) by Lm9;

theorem
  if<=0(a,k1,I). 0 = (a,k1)<=0_goto 2 & if<=0(a,k1,I). 1 =
  goto (card I + 1) by Lm10;

theorem Th102:
  for s being State of SCMPDS, I being shiftable Program of
  SCMPDS, a being Int_position,k1 being Integer st s.DataLoc(s.a,k1) <= 0 & I
is_closed_on s,P & I is_halting_on s,P holds if<=0(a,k1,I) is_closed_on s,P
 & if<=0(a
  ,k1,I) is_halting_on s,P
proof
  let s be State of SCMPDS, I be shiftable Program of SCMPDS, a be
  Int_position,k1 be Integer;
  set b=DataLoc(s.a,k1);
  set IF=if<=0(a,k1,I), pIF=stop IF, pI=stop I,
   s2 = Initialize s, s3 = Initialize s,
   P2 = P +* pI, P3 = P +* pIF,
   s4 = Comput(P3,s3,1), P4 = P3;
  set i = (a,k1)<=0_goto 2, j = goto (card I + 1);
UU:  stop I c= P2 by FUNCT_4:26;
A3: IF = i ';' (j ';' I) by SCMPDS_4:52;
A4: Comput(P3, s3,0 + 1) = Following(P3,
Comput(P3,s3,0)) by EXTPRO_1:4
    .= Following(P3,s3) by EXTPRO_1:3
    .= Exec(i,s3) by A3,Th22;
  now
    let a;
    thus s2.a = s3.a
      .= s4.a by A4,SCMPDS_2:68;
  end;
  then
A6: DataPart s2 = DataPart s4 by SCMPDS_4:23;
A7: not b in dom Start-At(0,SCMPDS) by SCMPDS_4:59;
  not a in dom Start-At(0,SCMPDS) by SCMPDS_4:59;
  then
A8: s3.DataLoc(s3.a,k1)=s3.b by FUNCT_4:12
    .= s.b by A7,FUNCT_4:12;
A9: IC s3 = 0 by COMPOS_1:223;
  assume
  s.b <= 0;
  then
A10: IC s4 = ICplusConst(s3,2) by A4,A8,SCMPDS_2:68
    .= (0+2) by A9,Th23;
  assume
A11: I is_closed_on s,P;
  then
A12: I is_closed_on s2,P2 by Th38;
  assume
  I is_halting_on s,P;
  then
A13: P2 halts_on s2 by Def3;
A14: Start-At(0,SCMPDS) c= s2 & Shift(pI,2) c= P4 by Lm7,FUNCT_4:26;
A15:  0 in dom pIF by COMPOS_1:135;
  now
    let k be Element of NAT;
    per cases;
    suppose
      0 < k;
      then consider k1 being Nat such that
A16:  k1 + 1 = k by NAT_1:6;
      reconsider k1 as Element of NAT by ORDINAL1:def 13;
      reconsider m = IC Comput(P2, s2,k1) as Element of NAT;
A17:  card pIF = 1+ card IF by SCMPDS_5:7
        .= 1+(card I +2) by Lm8
        .= 1+card I +2
        .=card pI+2 by SCMPDS_5:7;
       m in dom pI by A11,Def2;
      then m < card pI by AFINSQ_1:70;
      then
A18:  m+2 < card pIF by A17,XREAL_1:8;
      IC Comput(P3,s3,k) = IC Comput(P3, s4,k1) by
A16,EXTPRO_1:5
        .=  (m + 2) by A12,A14,A10,A6,Th45,UU;
      hence IC Comput(P3,s3,k) in dom pIF by A18,AFINSQ_1:70;
    end;
    suppose
      k = 0;
      hence IC Comput(P3,s3,k) in dom pIF by A15,A9,EXTPRO_1:3;
    end;
  end;
  hence IF is_closed_on s,P by Def2;
A21: Comput(P3,s3,LifeSpan(P2,s2)+1)
 = Comput(P3,Comput(P3,s3,1),LifeSpan(P2
,s2))
by EXTPRO_1:5;
  CurInstr(P3,
  Comput(P3,s3,LifeSpan(P2,s2)+1))
   =CurInstr(P3,
   Comput(P3,s4,LifeSpan(P2,s2))) by A21
    .=CurInstr(P2,
    Comput(P2,s2,LifeSpan(P2,s2))) by A12,A14,A10,A6
,Th45,UU
    .= halt SCMPDS by A13,EXTPRO_1:def 14;
  then P3 halts_on s3 by EXTPRO_1:30;
  hence thesis by Def3;
end;

theorem Th103:
  for s being State of SCMPDS,I being Program of SCMPDS, a being
  Int_position, k1 being Integer st s.DataLoc(s.a,k1) > 0 holds if<=0(a,k1,I)
  is_closed_on s,P & if<=0(a,k1,I) is_halting_on s,P
proof
  let s be State of SCMPDS,I be Program of SCMPDS, a be Int_position,k1 be
  Integer;
  set b=DataLoc(s.a,k1);
  assume
A1: s.b > 0;
  set i = (a,k1)<=0_goto 2, j = goto (card I + 1);
  set IF=if<=0(a,k1,I), pIF=stop IF, s3 = Initialize s,
  P3 = P +* pIF,
  s4 = Comput(P3,s3,1), s5 = Comput(P3,s3,2), P4 = P3, P5 = P3;
A3: IF =i ';' (j ';' I) by SCMPDS_4:52;
A4: not b in dom Start-At(0,SCMPDS) by SCMPDS_4:59;
  not a in dom Start-At(0,SCMPDS) by SCMPDS_4:59;
  then
A5: s3.DataLoc(s3.a,k1)=s3.b by FUNCT_4:12
    .= s.b by A4,FUNCT_4:12;
A6: IC s3 = 0 by COMPOS_1:223;
  Comput(P3, s3,0 + 1) = Following(P3,
  Comput(P3,s3,0)) by EXTPRO_1:4
    .= Following(P3,s3) by EXTPRO_1:3
    .= Exec(i,s3) by A3,Th22;
  then
A7: IC s4 = succ IC s3 by A1,A5,SCMPDS_2:68
    .= (0+1) by A6;
A8: pIF c= P3 by FUNCT_4:26;
  then
A9: pIF c= P4;
A10:  1 in dom IF by Lm9;
  then  1 in dom pIF by Th18;
  then
A11: P4. 1 = pIF. 1 by A9,GRFUNC_1:8
    .=IF. 1 by A10,Th19
    .=j by Lm10;
A12: card IF=card I+2 by Lm8;
  then
A13: (card I+2) in dom pIF by Th25;
A14:  P3/.IC s4
 = P3.IC s4 by PBOOLE:158;
  Comput(P3, s3,1 + 1) = Following(P3,s4) by
EXTPRO_1:4
    .= Exec(j,s4) by A7,A11,A14;
  then
A16: IC s5 = ICplusConst(s4,card I+1) by SCMPDS_2:66
    .= (card I+1+1) by A7,Th23
    .= (card I+(1+1));
A17:  (P3)/.IC s5
 = P3.IC s5 by PBOOLE:158;
  pIF c= P5 by A8;
  then P5.(card I+2) = pIF.(card I+2) by A13,GRFUNC_1:8
    .=halt SCMPDS by A12,Th25;
  then
A19: CurInstr(P3,s5) = halt SCMPDS by A16,A17;
  now
    let k be Element of NAT;
A20: k = 0 or 0 + 1 <= k by INT_1:20;
    per cases by A20,XXREAL_0:1;
    suppose
      k = 0;
      then Comput(P3,s3,k) = s3 by EXTPRO_1:3;
      hence IC Comput(P3,s3,k) in dom pIF by A6,COMPOS_1:135;
    end;
    suppose
      k = 1;
      hence IC Comput(P3,s3,k) in dom pIF by A10,A7,Th18;
    end;
    suppose
      1 < k;
      then 1+1 <= k by INT_1:20;
      hence IC Comput(P3,s3,k) in dom pIF
      by A13,A16,A19,EXTPRO_1:6;
    end;
  end;
  hence IF is_closed_on s,P by Def2;
  P3 halts_on s3 by A19,EXTPRO_1:30;
  hence thesis by Def3;
end;

theorem Th104:
  for s being State of SCMPDS,I being halt-free shiftable
  Program of SCMPDS, a being Int_position,k1 being Integer st s.DataLoc(s.a,k1)
  <= 0 & I is_closed_on s,P & I is_halting_on s,P
   holds IExec(if<=0(a,k1,I),P,s) =
  IExec(I,P,s) +* Start-At((card I+2),SCMPDS)
proof
  let s be State of SCMPDS,I be halt-free shiftable Program of SCMPDS, a be
  Int_position,k1 be Integer;
  set b=DataLoc(s.a,k1);
  set IF=if<=0(a,k1,I), pIF = stop IF, pI = stop I,
   s2 = Initialize s, s3 = Initialize s,
   P2 = P +* pI, P3 = P +* pIF,
   s4 = Comput(P3, s3,1), P4 = P3;
  set i = (a,k1)<=0_goto 2, j = goto (card I + 1);
  set SAl=Start-At((card I+2),SCMPDS);
UU:  stop I c= P2 by FUNCT_4:26;
A3: IF=i ';' (j ';' I) by SCMPDS_4:52;
A4: Comput(P3, s3,0 + 1) = Following(P3,
Comput(P3,s3,0)) by EXTPRO_1:4
    .= Following(P3,s3) by EXTPRO_1:3
    .= Exec(i,s3) by A3,Th22;
A5: not b in dom Start-At(0,SCMPDS) by SCMPDS_4:59;
  not a in dom Start-At(0,SCMPDS) by SCMPDS_4:59;
  then
A6: s3.DataLoc(s3.a,k1)=s3.b by FUNCT_4:12
    .= s.b by A5,FUNCT_4:12;
A7: IC s3 = 0 by COMPOS_1:223;
A8: Start-At(0,SCMPDS) c= s2 & Shift(pI,2) c= P4 by Lm7,FUNCT_4:26;
  now
    let a;
    thus s2.a = s3.a
      .= s4.a by A4,SCMPDS_2:68;
  end;
  then
A10: DataPart s2 = DataPart s4 by SCMPDS_4:23;
  assume
  s.b <= 0;
  then
A11: IC s4 = ICplusConst(s3,2) by A4,A6,SCMPDS_2:68
    .= (0+2) by A7,Th23;
A12: dom ProgramPart s = A by COMPOS_1:34;
  assume
A13: I is_closed_on s,P;
  then
A14: I is_closed_on s2,P2 by Th38;
  assume
A15: I is_halting_on s,P;
  then
A16: P2 halts_on s2 by Def3;
A18: Comput(P3,s3,LifeSpan(P2,s2)+1)
 = Comput(P3,Comput(P3,s3,1),LifeSpan(P2
,s2))
by EXTPRO_1:5;
A21: CurInstr(P3,
Comput(P3,s3,LifeSpan(P2,s2)+1))
 =CurInstr(P3,
 Comput(P3,s4,LifeSpan(P2,s2))) by A18
    .=CurInstr(P2,
    Comput(P2,s2,LifeSpan(P2,s2))) by A14,A8,A11,A10
,Th45,UU
    .= halt SCMPDS by A16,EXTPRO_1:def 14;
  then
A22: P3 halts_on s3 by EXTPRO_1:30;
A23: CurInstr(P3,s3) = i by A3,Th22;
  now
    let l be Element of NAT;
    assume
A24: l < LifeSpan(P2,s2) + 1;
A25: Comput(P3,s3,0) = s3 by EXTPRO_1:3;
    per cases;
    suppose
      l = 0;
      then CurInstr(P3,Comput(P3,s3,l))
       = CurInstr(P3,s3)
       by A25;
      hence CurInstr(P3,Comput(P3,s3,l))
       <> halt SCMPDS by A23;
    end;
    suppose
      l <> 0;
      then consider n be Nat such that
A26:  l = n + 1 by NAT_1:6;
      reconsider n as Element of NAT by ORDINAL1:def 13;
A27:  n < LifeSpan(P2,s2) by A24,A26,XREAL_1:8;
      assume
A28:  CurInstr(P3,Comput(P3,s3,l)) = halt SCMPDS;
A30: Comput(P3,s3,n+1)
 = Comput(P3,Comput(P3,s3,1),n) by EXTPRO_1:5;
      CurInstr(P2,Comput(P2,s2,n)) =
      CurInstr(P3,Comput(P3,s4,n))
       by A14,A8,A11,A10,Th45,UU
        .= halt SCMPDS by A26,A28,A30;
      hence contradiction by A16,A27,EXTPRO_1:def 14;
    end;
  end;
  then for l be Element of NAT st CurInstr(P3,
  Comput(P3,s3,l)) = halt SCMPDS
  holds LifeSpan(P2,s2) + 1 <= l;
  then
A33: LifeSpan(P3,s3) = LifeSpan(P2,s2) + 1 by A21,A22
,EXTPRO_1:def 14;
A35: DataPart Result(P2,s2) = DataPart Comput(P2,s2,
LifeSpan(P2,s2)) by A16,EXTPRO_1:23
    .= DataPart Comput(P3, s4,LifeSpan(P2,s2)) by A14
,A8,A11,A10,Th45,UU
    .= DataPart Comput(P3, s3,LifeSpan(P2,s2) + 1)
by EXTPRO_1:5
    .= DataPart Result(P3,s3) by A22,A33,EXTPRO_1:23;
A36: now
    let x be set;
A37: dom Start-At((card I+2),SCMPDS) = {IC SCMPDS} by FUNCOP_1:19;
    assume
A38: x in dom IExec(IF,P,s);
    per cases by A38,SCMPDS_4:20;
    suppose
A39:  x is Int_position;
      then x <> IC SCMPDS by SCMPDS_2:52;
      then
A40:  not x in dom SAl by A37,TARSKI:def 1;
A41: not x in dom (s | A) by A12,A39,SCMPDS_2:53;
      hence IExec(IF,P,s).x = (Result(P3,s3)).x by FUNCT_4:12
        .= (Result(P2,s2)).x by A35,A39,SCMPDS_4:23
        .= IExec(I,P,s).x by A41,FUNCT_4:12
        .= (IExec(I,P,s) +* SAl).x by A40,FUNCT_4:12;
    end;
    suppose
A42:  x = IC SCMPDS;
A43: not x in dom (s | A) by A12,A42,COMPOS_1:3;
      then
A44:  IC Result(P2,s2) = IC IExec(I,P,s) by A42,FUNCT_4:12
        .=  card I by A13,A15,Th48;
A45:  x in dom SAl by A37,A42,TARSKI:def 1;
      thus IExec(IF,P,s).x = (Result(P3,s3)).x by A43,FUNCT_4:12
        .= Comput(P3, s3,LifeSpan(P2,s2) + 1).x by
A22,A33,EXTPRO_1:23
        .= IC Comput(P3, s4,LifeSpan(P2,s2)) by A42,
EXTPRO_1:5
        .= IC Comput(P2, s2,LifeSpan(P2,s2)) + 2
        by A14,A8,A11,A10,Th45,UU
        .= IC Result(P2,s2) + 2 by A16,EXTPRO_1:23
        .= IC SAl by A44,FUNCOP_1:87
        .= (IExec(I,P,s) +* SAl).x by A42,A45,FUNCT_4:14;
    end;
    suppose
      x is Element of NAT;
      hence IExec(IF,P,s).x = (IExec(I,P,s) +* SAl).x by Th26;
    end;
  end;
  dom IExec(IF,P,s) = the carrier of SCMPDS by PARTFUN1:def 4
    .= dom (IExec(I,P,s) +* Start-At((card I+2),SCMPDS)) by PARTFUN1:def 4;
  hence thesis by A36,FUNCT_1:9;
end;

theorem Th105:
  for s being State of SCMPDS,I being Program of SCMPDS,a being
Int_position, k1 being Integer st s.DataLoc(s.a,k1) > 0
 holds IExec(if<=0(a,k1,I),P,s) = s +* Start-At((card I+2),SCMPDS)
proof
  let s be State of SCMPDS,I be Program of SCMPDS,a be Int_position, k1 be
  Integer;
  set b=DataLoc(s.a,k1);
  set IF=if<=0(a,k1,I), pIF=stop IF, s3 = Initialize s,
  P3 = P +* pIF,
  s4 = Comput(P3,s3,1), s5 = Comput(P3,s3,2), P4 = P3, P5 = P3;
  set i = (a,k1)<=0_goto 2, j = goto (card I + 1);
  set SAl=Start-At((card I+2),SCMPDS);
A2: IF =i ';' (j ';' I) by SCMPDS_4:52;
A3: not b in dom Start-At(0,SCMPDS) by SCMPDS_4:59;
  not a in dom Start-At(0,SCMPDS) by SCMPDS_4:59;
  then
A4: s3.DataLoc(s3.a,k1)=s3.b by FUNCT_4:12
    .= s.b by A3,FUNCT_4:12;
A5: IC s3 = 0 by COMPOS_1:223;
A6: pIF c= P3 by FUNCT_4:26;
  then
A7: pIF c= P4;
A8: pIF c= P5 by A6;
A9: Comput(P3, s3,0 + 1) = Following(P3,
Comput(P3,s3,0)) by EXTPRO_1:4
    .= Following(P3,s3) by EXTPRO_1:3
    .= Exec(i,s3) by A2,Th22;
  assume
  s.b > 0;
  then
A10: IC s4 = succ IC s3 by A9,A4,SCMPDS_2:68
    .= (0+1) by A5;
A11:  1 in dom IF by Lm9;
  then  1 in dom pIF by Th18;
  then
A12: P4.1 = pIF. 1 by A7,GRFUNC_1:8
    .=IF. 1 by A11,Th19
    .=j by Lm10;
A13:  P3/.IC s4
 = P3.IC s4 by PBOOLE:158;
A15: Comput(P3, s3,1 + 1) = Following(P3,s4) by
EXTPRO_1:4
    .= Exec(j,s4) by A10,A12,A13;
  then
A16: IC s5 = ICplusConst(s4,card I+1) by SCMPDS_2:66
    .= (card I+1+1) by A10,Th23
    .= (card I+(1+1));
A17:  (P3)/.IC s5
 = P3.IC s5 by PBOOLE:158;
A19: card IF=card I+2 by Lm8;
  then (card I+2) in dom pIF by Th25;
  then P5.(card I+2) = pIF.(card I+2) by A8,GRFUNC_1:8
    .=halt SCMPDS by A19,Th25;
  then
A20: CurInstr(P3,s5) = halt SCMPDS by A16,A17;
  then
A21: P3 halts_on s3 by EXTPRO_1:30;
A22: CurInstr(P3,s3) = i by A2,Th22;
  now
    let l be Element of NAT;
    assume
    l < 1+1;
    then
A23: l <= 1 by NAT_1:13;
A24: Comput(P3,s3,0) = s3 by EXTPRO_1:3;
A25: P3/.IC Comput(P3,s3,l)
 = P3.IC Comput(P3,s3,l) by PBOOLE:158;
    per cases by A23,NAT_1:26;
    suppose
      l=0;
      then CurInstr(P3,Comput(P3,s3,l))
       = CurInstr(P3,s3)
       by A24;
      hence CurInstr(P3,Comput(P3,s3,l))
       <> halt SCMPDS by A22;
    end;
    suppose
      l=1;
      hence CurInstr(P3,Comput(P3,s3,l))
       <> halt SCMPDS by A10,A12,A25;
    end;
  end;
  then for l be Element of NAT st CurInstr(P3,
  Comput(P3,s3,l)) = halt SCMPDS
  holds 2 <= l;
  then LifeSpan(P3,s3) = 2 by A20,A21,EXTPRO_1:def 14;
  then
A27: s5 = Result(P3,s3) by A21,EXTPRO_1:23;
A28: dom ProgramPart s = A by COMPOS_1:34;
A29: now
A30: dom SAl = {IC SCMPDS} by FUNCOP_1:19;
    let x be set;
    assume
A31: x in dom IExec(IF,P,s);
    per cases by A31,SCMPDS_4:20;
    suppose
A32:  x is Int_position;
      then x <> IC SCMPDS by SCMPDS_2:52;
      then
A33:  not x in dom SAl by A30,TARSKI:def 1;
TT:   not x in dom Start-At(0,SCMPDS) by A32,SCMPDS_4:59;
      not x in dom (s | A) by A28,A32,SCMPDS_2:53;
      hence IExec(IF,P,s).x = s5.x by A27,FUNCT_4:12
        .= s4.x by A15,A32,SCMPDS_2:66
        .= s3.x by A9,A32,SCMPDS_2:68
        .= s.x by TT,FUNCT_4:12
        .= (s +* SAl).x by A33,FUNCT_4:12;
    end;
    suppose
A34:  x = IC SCMPDS;
      not x in dom (s | A) by A28,A34,COMPOS_1:3;
      hence IExec(IF,P,s).x = (card I + 2) by A16,A27,A34,FUNCT_4:12
        .= (s +* Start-At((card I+2),SCMPDS)).x by A34,FUNCT_4:121;
    end;
    suppose
      x is Element of NAT;
      hence IExec(IF,P,s).x = (s +* SAl).x by Th27;
    end;
  end;
  dom IExec(IF,P,s) = the carrier of SCMPDS by PARTFUN1:def 4
    .= dom (s +* SAl) by PARTFUN1:def 4;
  hence thesis by A29,FUNCT_1:9;
end;

registration
  let I be shiftable parahalting Program of SCMPDS, a be Int_position,k1 be
  Integer;
  cluster if<=0(a,k1,I) -> shiftable parahalting;
  correctness
  proof
    set i = (a,k1)<=0_goto 2, j = goto (card I + 1);
    set IF=if<=0(a,k1,I), pIF = stop IF;
    thus IF is shiftable;
      let s be 0-started State of SCMPDS;
      let P be (the Instructions of SCMPDS)-valued ManySortedSet of NAT;
A1:  Initialize s = s by COMPOS_1:78;
      assume pIF c= P;
      then
A2:   P = P +* stop IF by FUNCT_4:104;
A3:   I is_closed_on s,P & I is_halting_on s,P by Th34,Th35;
      per cases;
      suppose
        s.DataLoc(s.a,k1) <= 0;
        then IF is_halting_on s,P by A3,Th102;
        hence P halts_on s by A2,Def3,A1;
      end;
      suppose
        s.DataLoc(s.a,k1) > 0;
        then IF is_halting_on s,P by Th103;
        hence P halts_on s by A2,Def3,A1;
      end;
  end;
end;

registration
  let I be halt-free Program of SCMPDS, a be Int_position,k1 be Integer;
  cluster if<=0(a,k1,I) -> halt-free;
  coherence;
end;

theorem
  for s being State of SCMPDS,I being halt-free shiftable parahalting
Program of SCMPDS,a being Int_position,k1 being Integer
 holds IC IExec(if<=0(a,k1,I),P,s) =  (card I + 2)
proof
  let s be State of SCMPDS,I be halt-free shiftable parahalting Program of
  SCMPDS,a be Int_position,k1 be Integer;
  set IF=if<=0(a,k1,I);
A1: I is_closed_on s,P & I is_halting_on s,P by Th34,Th35;
  per cases;
  suppose
    s.DataLoc(s.a,k1) <= 0;
    then IExec(IF,P,s) =IExec(I,P,s) +* Start-At((card I+2),SCMPDS)
    by A1,Th104;
    hence thesis by FUNCT_4:121;
  end;
  suppose
    s.DataLoc(s.a,k1) > 0;
    then IExec(IF,P,s) =s +* Start-At((card I+2),SCMPDS) by Th105;
    hence thesis by FUNCT_4:121;
  end;
end;

theorem
  for s being State of SCMPDS,I being halt-free shiftable parahalting
Program of SCMPDS,a,b being Int_position,k1 being Integer st s.DataLoc(s.a,k1)
  <= 0 holds IExec(if<=0(a,k1,I),P,s).b = IExec(I,P,s).b
proof
  let s be State of SCMPDS,I be halt-free shiftable parahalting Program of
  SCMPDS,a,b be Int_position,k1 be Integer;
  assume
A1: s.DataLoc(s.a,k1) <= 0;
A2: not b in dom Start-At((card I+2),SCMPDS) by SCMPDS_4:59;
  I is_closed_on s,P & I is_halting_on s,P by Th34,Th35;
  then IExec(if<=0(a,k1,I),P,s) = IExec(I,P,s) +* Start-At((card I+2),SCMPDS)
   by A1,Th104;
  hence thesis by A2,FUNCT_4:12;
end;

theorem
  for s being State of SCMPDS,I being Program of SCMPDS,a,b being
Int_position, k1 being Integer st s.DataLoc(s.a,k1) > 0
 holds IExec(if<=0(a,k1,I),P,s).b = s.b
proof
  let s be State of SCMPDS,I be Program of SCMPDS,a,b be Int_position, k1 be
  Integer;
  assume
  s.DataLoc(s.a,k1) > 0;
  then
A1: IExec(if<=0(a,k1,I),P,s) = s +* Start-At((card I+2),SCMPDS) by Th105;
  not b in dom Start-At((card I+2),SCMPDS) by SCMPDS_4:59;
  hence thesis by A1,FUNCT_4:12;
end;

begin :: The computation of "if var<0 then block1 else block2"

theorem
  card if<0(a,k1,I,J) = card I + card J + 2 by Lm4;

theorem
   0 in dom if<0(a,k1,I,J) &  1 in dom if<0(a,k1,I,J)
proof
  set ci=card if<0(a,k1,I,J);
  ci=card I + card J +2 by Lm4;
  then 2 <= ci by NAT_1:12;
  then 1 < ci by XXREAL_0:2;
  hence thesis by AFINSQ_1:70;
end;

theorem
  if<0(a,k1,I,J). 0 = (a,k1)>=0_goto (card I + 2) by Lm5;

theorem Th112:
  for s being State of SCMPDS, I,J being shiftable Program of
  SCMPDS, a being Int_position,k1 being Integer st s.DataLoc(s.a,k1)<0 & I
is_closed_on s,P & I is_halting_on s,P holds if<0(a,k1,I,J) is_closed_on s,P
 & if<0(a
  ,k1,I,J) is_halting_on s,P
proof
  let s be State of SCMPDS, I,J be shiftable Program of SCMPDS, a be
  Int_position,k1 be Integer;
  set b=DataLoc(s.a,k1);
  set G=Goto (card J+1);
  set I2 = I ';' G ';' J, IF=if<0(a,k1,I,J), pIF=stop IF,
   pI2=stop I2, s2 = Initialize s, s3 = Initialize s,
   P2 = P +* pI2, P3 = P +* pIF,
   s4 = Comput(P3,s3,1), P4 = P3;
  set i = (a,k1)>=0_goto (card I + 2);
A3:  0 in dom pIF by COMPOS_1:135;
A4: IC s3 = 0 by COMPOS_1:223;
A5: not b in dom Start-At(0,SCMPDS) by SCMPDS_4:59;
  not a in dom Start-At(0,SCMPDS) by SCMPDS_4:59;
  then
A6: s3.DataLoc(s3.a,k1)=s3.b by FUNCT_4:12
    .= s.b by A5,FUNCT_4:12;
A7: IF = i ';' (I ';' G) ';' J by SCMPDS_4:50
    .= i ';' I2 by SCMPDS_4:50;
  then
A8: Shift(pI2,1) c= P4 by Lm6;
A9: Comput(P3, s3,0 + 1) = Following(P3,
Comput(P3,s3,0)) by EXTPRO_1:4
    .= Following(P3,s3) by EXTPRO_1:3
    .= Exec(i,s3) by A7,Th22;
  now
    let a;
    thus s2.a = s3.a
      .= s4.a by A9,SCMPDS_2:69;
  end;
  then
A11: DataPart s2 = DataPart s4 by SCMPDS_4:23;
  assume
  s.b < 0;
  then
A12: IC s4 = succ IC s3 by A9,A6,SCMPDS_2:69
    .= (0+1) by A4;
  assume
A13: I is_closed_on s,P;
  assume
A14: I is_halting_on s,P;
  then
A15: I2 is_closed_on s,P by A13,Th44;
  then
A16: Start-At(0,SCMPDS) c= s2 & I2 is_closed_on s2,P2 by Th38,FUNCT_4:26;
UU:  stop I2 c= P2 by FUNCT_4:26;
  I2 is_halting_on s,P by A13,A14,Th44;
  then
A17: P2 halts_on s2 by Def3;
A18: card pIF = card IF +1 by SCMPDS_5:7
    .= card I2 +1+1 by A7,Th15;
  now
    let k be Element of NAT;
    per cases;
    suppose
      0 < k;
      then consider k1 being Nat such that
A19:  k1 + 1 = k by NAT_1:6;
      reconsider k1 as Element of NAT by ORDINAL1:def 13;
      reconsider m = IC Comput(P2, s2,k1) as Element of NAT;
A20:  card pIF = card pI2+1 by A18,SCMPDS_5:7;
       m in dom pI2 by A15,Def2;
      then m < card pI2 by AFINSQ_1:70;
      then
A21:  m+1 < card pIF by A20,XREAL_1:8;
      IC Comput(P3,s3,k) = IC Comput(P3, s4,k1) by
A19,EXTPRO_1:5
        .=  (m + 1) by A16,A8,A12,A11,Th45,UU;
      hence IC Comput(P3,s3,k) in dom pIF by A21,AFINSQ_1:70;
    end;
    suppose
      k = 0;
      hence IC Comput(P3,s3,k) in dom pIF by A3,A4,EXTPRO_1:3;
    end;
  end;
  hence IF is_closed_on s,P by Def2;
A24: Comput(P3,s3,LifeSpan(P2,s2)+1)
 = Comput(P3,Comput(P3,s3,1),LifeSpan(P2
,s2))
 by EXTPRO_1:5;
  CurInstr(P3,
  Comput(P3,s3,LifeSpan(P2,s2)+1))
   =CurInstr(P3,
   Comput(P3,s4,LifeSpan(P2,s2))) by A24
    .=CurInstr(P2,
    Comput(P2,s2,LifeSpan(P2,s2))) by A16,A8,A12,A11
,Th45,UU
    .= halt SCMPDS by A17,EXTPRO_1:def 14;
  then P3 halts_on s3 by EXTPRO_1:30;
  hence thesis by Def3;
end;

theorem Th113:
  for s being State of SCMPDS,I being Program of SCMPDS,J being
shiftable Program of SCMPDS,a being Int_position,k1 being Integer st s.DataLoc(
  s.a,k1) >= 0 & J is_closed_on s,P & J is_halting_on s,P holds if<0(a,k1,I,J)
  is_closed_on s,P & if<0(a,k1,I,J) is_halting_on s,P
proof
  let s be State of SCMPDS,I be Program of SCMPDS, J be shiftable Program of
  SCMPDS, a be Int_position,k1 be Integer;
  set b=DataLoc(s.a,k1);
  set pJ=stop J, s1 = Initialize s, P1 = P +* pJ,
  IF=if<0(a,k1,I,J), pIF=
  stop IF, s3 = Initialize s, P3 = P +* pIF,
  s4 = Comput(P3,s3,1), P4 = P3;
  set i = (a,k1)>=0_goto (card I + 2);
  set G =Goto (card J+1), iG=i ';' I ';' G;
A3: IF = i ';' (I ';' G) ';' J by SCMPDS_4:50
    .= i ';' (I ';' G ';' J) by SCMPDS_4:50;
A4: Comput(P3, s3,0 + 1) = Following(P3,
Comput(P3,s3,0)) by EXTPRO_1:4
    .= Following(P3,s3) by EXTPRO_1:3
    .= Exec(i,s3) by A3,Th22;
A5: not b in dom Start-At(0,SCMPDS) by SCMPDS_4:59;
  not a in dom Start-At(0,SCMPDS) by SCMPDS_4:59;
  then
A6: s3.DataLoc(s3.a,k1)=s3.b by FUNCT_4:12
    .= s.b by A5,FUNCT_4:12;
A7: IC s3 = 0 by COMPOS_1:223;
  assume
  s.b >= 0;
  then
A8: IC s4 = ICplusConst(s3,card I + 2) by A4,A6,SCMPDS_2:69
    .= (0+(card I + 2)) by A7,Th23;
  assume
A9: J is_closed_on s,P;
  then
A10: Start-At(0,SCMPDS) c= s1 & J is_closed_on s1,P1 by Th38,FUNCT_4:26;
UU:  stop J c= P1 by FUNCT_4:26;
A11: pIF c= P3 by FUNCT_4:26;
A12: card iG = card (i ';' I) + card G by AFINSQ_1:20
    .=card (i ';' I) + 1 by SCMPDS_5:6
    .=card I +1 +1 by Th15
    .=card I +(1 +1);
  then Shift(pJ,card I+2) c= pIF by Th24;
  then Shift(pJ,card I+2) c= P3 by A11,XBOOLE_1:1;
  then
A13: Shift(pJ,card I+2) c= P4;
  assume
  J is_halting_on s,P;
  then
A14: P1 halts_on s1 by Def3;
  now
    let a;
    thus s1.a = s3.a
      .= s4.a by A4,SCMPDS_2:69;
  end;
  then
A16: DataPart s1 = DataPart s4 by SCMPDS_4:23;
  now
    let k be Element of NAT;
    per cases;
    suppose
      0 < k;
      then consider k1 being Nat such that
A17:  k1 + 1 = k by NAT_1:6;
      reconsider k1 as Element of NAT by ORDINAL1:def 13;
      reconsider m = IC Comput(P1, s1,k1) as Element of NAT;
       m in dom pJ by A9,Def2;
      then m < card pJ by AFINSQ_1:70;
      then
A18:  m + (card I + 2) < card pJ + (card I + 2) by XREAL_1:8;
A19:  card pJ = card J + 1 by SCMPDS_5:7;
A20:  card pIF = card IF+1 by SCMPDS_5:7
        .=card I +2 +card J +1 by A12,AFINSQ_1:20
        .=card I +2 + card pJ by A19;
      IC Comput(P3,s3,k) = IC Comput(P3, s4,k1) by
A17,EXTPRO_1:5
        .=  (m + (card I + 2)) by A10,A16,A13,A8,Th45,UU;
      hence IC Comput(P3,s3,k) in dom pIF by A20,A18,AFINSQ_1:70;
    end;
    suppose
      k = 0;
      then Comput(P3,s3,k) = s3 by EXTPRO_1:3;
      hence IC Comput(P3,s3,k) in dom pIF by A7,COMPOS_1:135;
    end;
  end;
  hence IF is_closed_on s,P by Def2;
A23: Comput(P3,s3,LifeSpan(P1,s1)+1)
 = Comput(P3,Comput(P3,s3,1),LifeSpan(P1
,s1))
by EXTPRO_1:5;
  CurInstr(P3,
  Comput(P3,s3,LifeSpan(P1,s1)+1))
   =CurInstr(P3,
   Comput(P3,s4,LifeSpan(P1,s1))) by A23
    .=CurInstr(P1,
    Comput(P1,s1,LifeSpan(P1,s1))) by A10,A16,A13,A8
,Th45,UU
    .= halt SCMPDS by A14,EXTPRO_1:def 14;
  then P3 halts_on s3 by EXTPRO_1:30;
  hence thesis by Def3;
end;

theorem Th114:
  for s being State of SCMPDS,I being halt-free shiftable
Program of SCMPDS, J being shiftable Program of SCMPDS,a being Int_position,k1
  being Integer st s.DataLoc(s.a,k1) < 0 & I is_closed_on s,P
   & I is_halting_on s,P
holds IExec(if<0(a,k1,I,J),P,s) = IExec(I,P,s) +* Start-At((card I + card J
  + 2),SCMPDS)
proof
  let s be State of SCMPDS,I be halt-free shiftable Program of SCMPDS, J be
  shiftable Program of SCMPDS,a be Int_position,k1 be Integer;
  set b=DataLoc(s.a,k1);
  set G=Goto (card J+1);
  set I2 = I ';' G ';' J, IF=if<0(a,k1,I,J), pIF = stop IF, pI2=
stop I2, s2 = Initialize s, P2 = P +* pI2,
s3 = Initialize s, P3 = P +* pIF,
s4 = Comput(P3,s3,1), P4 = P3;
  set i = (a,k1)>=0_goto (card I + 2);
  set SAl= Start-At((card I+card J+2),SCMPDS);
A3: IC s3 = 0 by COMPOS_1:223;
A4: not b in dom Start-At(0,SCMPDS) by SCMPDS_4:59;
  not a in dom Start-At(0,SCMPDS) by SCMPDS_4:59;
  then
A5: s3.DataLoc(s3.a,k1)=s3.b by FUNCT_4:12
    .= s.b by A4,FUNCT_4:12;
A6: dom ProgramPart s = A by COMPOS_1:34;
A7: IF = i ';' (I ';' G) ';' J by SCMPDS_4:50
    .= i ';' I2 by SCMPDS_4:50;
  then
A8: Shift(pI2,1) c= P4 by Lm6;
A9: Comput(P3, s3,0 + 1) = Following(P3,
Comput(P3,s3,0)) by EXTPRO_1:4
    .= Following(P3,s3) by EXTPRO_1:3
    .= Exec(i,s3) by A7,Th22;
  assume
  s.b < 0;
  then
A10: IC s4 = succ IC s3 by A9,A5,SCMPDS_2:69
    .= (0+1) by A3;
  now
    let a;
    thus s2.a = s3.a
      .= s4.a by A9,SCMPDS_2:69;
  end;
  then
A12: DataPart s2 = DataPart s4 by SCMPDS_4:23;
  assume
A13: I is_closed_on s,P;
  assume
A14: I is_halting_on s,P;
  then I2 is_halting_on s,P by A13,Th44;
  then
A15: P2 halts_on s2 by Def3;
  I2 is_closed_on s,P by A13,A14,Th44;
  then
A16: Start-At(0,SCMPDS) c= s2 & I2 is_closed_on s2,P2 by Th38,FUNCT_4:26;
UU:  stop I2 c= P2 by FUNCT_4:26;
A18: Comput(P3,s3,LifeSpan(P2,s2)+1)
 = Comput(P3,Comput(P3,s3,1),LifeSpan(P2
,s2))
 by EXTPRO_1:5;
A21: CurInstr(P3,
Comput(P3,s3,LifeSpan(P2,s2)+1))
 =CurInstr(P3,
 Comput(P3,s4,LifeSpan(P2,s2))) by A18
    .=CurInstr(P2,
    Comput(P2,s2,LifeSpan(P2,s2))) by A16,A8,A10,A12
,Th45,UU
    .= halt SCMPDS by A15,EXTPRO_1:def 14;
  then
A22: P3 halts_on s3 by EXTPRO_1:30;
A23: CurInstr(P3,s3) = i by A7,Th22;
  now
    let l be Element of NAT;
    assume
A24: l < LifeSpan(P2,s2) + 1;
A25: Comput(P3,s3,0) = s3 by EXTPRO_1:3;
    per cases;
    suppose
      l = 0;
      then CurInstr(P3,Comput(P3,s3,l))
       = CurInstr(P3,s3)
       by A25;
      hence CurInstr(P3,Comput(P3,s3,l))
       <> halt SCMPDS by A23;
    end;
    suppose
      l <> 0;
      then consider n be Nat such that
A26:  l = n + 1 by NAT_1:6;
      reconsider n as Element of NAT by ORDINAL1:def 13;
A27:  n < LifeSpan(P2,s2) by A24,A26,XREAL_1:8;
      assume
A28:  CurInstr(P3,Comput(P3,s3,l)) = halt SCMPDS;
A30: Comput(P3,s3,n+1)
 = Comput(P3,Comput(P3,s3,1),n) by EXTPRO_1:5;
      CurInstr(P2,Comput(P2,s2,n)) =
      CurInstr(P3,Comput(P3,s4,n)) by A16,A8,A10,A12
,Th45,UU
        .= halt SCMPDS by A26,A28,A30;
      hence contradiction by A15,A27,EXTPRO_1:def 14;
    end;
  end;
  then for l be Element of NAT st CurInstr(P3,
  Comput(P3,s3,l)) = halt SCMPDS
  holds LifeSpan(P2,s2) + 1 <= l;
  then
A33: LifeSpan(P3,s3) = LifeSpan(P2,s2) + 1 by A21,A22
,EXTPRO_1:def 14;
A35: DataPart Result(P2,s2) = DataPart Comput(P2,s2,
LifeSpan(P2,s2)) by A15,EXTPRO_1:23
    .= DataPart Comput(P3, s4,LifeSpan(P2,s2))
    by A16,A8,A10,A12,Th45,UU
    .= DataPart Comput(P3, s3,LifeSpan(P2,s2) + 1)
by EXTPRO_1:5
    .= DataPart Result(P3,s3) by A22,A33,EXTPRO_1:23;
A36: now
    let x be set;
A37: dom SAl = {IC SCMPDS} by FUNCOP_1:19;
    assume
A38: x in dom IExec(IF,P,s);
    per cases by A38,SCMPDS_4:20;
    suppose
A39:  x is Int_position;
      then x <> IC SCMPDS by SCMPDS_2:52;
      then
A40:  not x in dom SAl by A37,TARSKI:def 1;
A41: not x in dom (s | A) by A6,A39,SCMPDS_2:53;
      hence IExec(IF,P,s).x = (Result(P3,s3)).x by FUNCT_4:12
        .= (Result(P2,s2)).x by A35,A39,SCMPDS_4:23
        .= IExec(I2,P,s).x by A41,FUNCT_4:12
        .= (IExec(I2,P,s) +* SAl).x by A40,FUNCT_4:12;
    end;
    suppose
A42:  x = IC SCMPDS;
A43: not x in dom (s | A) by A6,A42,COMPOS_1:3;
      then
A44:  IC Result(P2,s2) = IC IExec(I2,P,s) by A42,FUNCT_4:12
        .=  (card I + card J + 1) by A13,A14,Th46;
A45:  x in dom SAl by A37,A42,TARSKI:def 1;
      thus IExec(IF,P,s).x = (Result(P3,s3)).x by A43,FUNCT_4:12
        .= Comput(P3, s3,LifeSpan(P2,s2) + 1).x by
A22,A33,EXTPRO_1:23
        .= IC Comput(P3, s4,LifeSpan(P2,s2)) by A42,
EXTPRO_1:5
        .= IC Comput(P2, s2,LifeSpan(P2,s2)) + 1 by
A16,A8,A10,A12,Th45,UU
        .= IC Result(P2,s2) + 1 by A15,EXTPRO_1:23
        .= IC Start-At ((card I + card J + 1) + 1,SCMPDS)
        by A44,FUNCOP_1:87
        .= (IExec(I2,P,s) +* SAl).x by A42,A45,FUNCT_4:14;
    end;
    suppose
      x is Element of NAT;
      hence IExec(IF,P,s).x = (IExec(I2,P,s) +* SAl).x by Th26;
    end;
  end;
  dom IExec(IF,P,s) = the carrier of SCMPDS by PARTFUN1:def 4
    .= dom (IExec(I2,P,s) +* SAl) by PARTFUN1:def 4;
  hence IExec(IF,P,s) = IExec(I2,P,s) +* SAl by A36,FUNCT_1:9
    .= IExec(I,P,s) +* Start-At((card I + card J + 1),SCMPDS) +*
    Start-At(
   (card I + card J + 2),SCMPDS) by A13,A14,Th47
    .= IExec(I,P,s) +* SAl by COMPOS_1:199;
end;

theorem Th115:
  for s being State of SCMPDS,I being Program of SCMPDS,J being
  halt-free shiftable Program of SCMPDS,a being Int_position,k1 being Integer
  st s.DataLoc(s.a,k1) >= 0 & J is_closed_on s,P & J is_halting_on s,P
   holds IExec(if<0(a,k1,I,J),P,s)
    = IExec(J,P,s) +* Start-At((card I+card J+2),SCMPDS)
proof
  let s be State of SCMPDS,I be Program of SCMPDS,J be halt-free shiftable
  Program of SCMPDS,a be Int_position,k1 be Integer;
  set b=DataLoc(s.a,k1);
  set pJ=stop J, s1 = Initialize s, P1 = P +* pJ,
  IF=if<0(a,k1,I,J), pIF=
  stop IF, s3 = Initialize s, P3 = P +* pIF,
  s4 = Comput(P3,s3,1), P4 = P3;
  set i = (a,k1)>=0_goto (card I + 2);
  set G =Goto (card J+1), iG=i ';' I ';' G;
  set SAl=Start-At((card I+card J+2),SCMPDS);
A3: IF = i ';' (I ';' G) ';' J by SCMPDS_4:50
    .= i ';' (I ';' G ';' J) by SCMPDS_4:50;
A4: Comput(P3, s3,0 + 1) = Following(P3,
Comput(P3,s3,0)) by EXTPRO_1:4
    .= Following(P3,s3) by EXTPRO_1:3
    .= Exec(i,s3) by A3,Th22;
A5: not b in dom Start-At(0,SCMPDS) by SCMPDS_4:59;
  not a in dom Start-At(0,SCMPDS) by SCMPDS_4:59;
  then
A6: s3.DataLoc(s3.a,k1)=s3.b by FUNCT_4:12
    .= s.b by A5,FUNCT_4:12;
A7: IC s3 = 0 by COMPOS_1:223;
A8: dom ProgramPart s = A by COMPOS_1:34;
  assume
  s.b >= 0;
  then
A9: IC s4 = ICplusConst(s3,card I + 2) by A4,A6,SCMPDS_2:69
    .= (0+(card I + 2)) by A7,Th23;
  now
    let a;
    thus s1.a = s3.a
      .= s4.a by A4,SCMPDS_2:69;
  end;
  then
A11: DataPart s1 = DataPart s4 by SCMPDS_4:23;
  card iG = card (i ';' I) + card G by AFINSQ_1:20
    .=card (i ';' I) + 1 by SCMPDS_5:6
    .=card I +1 +1 by Th15
    .=card I +(1 +1);
  then
A12: Shift(pJ,card I+2) c= pIF by Th24;
  pIF c= P3 by FUNCT_4:26;
  then Shift(pJ,card I+2) c= P3 by A12,XBOOLE_1:1;
  then
A13: Shift(pJ,card I+2) c= P4;
  assume
A14: J is_closed_on s,P;
  then
A15: Start-At(0,SCMPDS) c= s1 & J is_closed_on s1,P1 by Th38,FUNCT_4:26;
UU:  stop J c= P1 by FUNCT_4:26;
  assume
A16: J is_halting_on s,P;
  then
A17: P1 halts_on s1 by Def3;
A19: Comput(P3,s3,LifeSpan(P1,s1)+1)
 = Comput(P3,Comput(P3,s3,1),LifeSpan(P1
,s1))
by EXTPRO_1:5;
A22: CurInstr(P3,
Comput(P3,s3,LifeSpan(P1,s1)+1))
 =CurInstr(P3,
 Comput(P3,s4,LifeSpan(P1,s1))) by A19
    .=CurInstr(P1,
    Comput(P1,s1,LifeSpan(P1,s1))) by A15,A13,A9,A11
,Th45,UU
    .= halt SCMPDS by A17,EXTPRO_1:def 14;
  then
A23: P3 halts_on s3 by EXTPRO_1:30;
A24: CurInstr(P3,s3) = i by A3,Th22;
  now
    let l be Element of NAT;
    assume
A25: l < LifeSpan(P1,s1) + 1;
A26: Comput(P3,s3,0) = s3 by EXTPRO_1:3;
    per cases;
    suppose
      l = 0;
      then CurInstr(P3,Comput(P3,s3,l))
       = CurInstr(P3,s3)
       by A26;
      hence CurInstr(P3,Comput(P3,s3,l))
       <> halt SCMPDS by A24;
    end;
    suppose
      l <> 0;
      then consider n be Nat such that
A27:  l = n + 1 by NAT_1:6;
      reconsider n as Element of NAT by ORDINAL1:def 13;
A28:  n < LifeSpan(P1,s1) by A25,A27,XREAL_1:8;
      assume
A29:  CurInstr(P3,Comput(P3,s3,l)) = halt SCMPDS;
A31: Comput(P3,s3,n+1)
 = Comput(P3,Comput(P3,s3,1),n) by EXTPRO_1:5;
      CurInstr(P1,Comput(P1,s1,n))
       = CurInstr(P3,
      Comput(P3,s4,n)) by A15,A13,A9,A11,Th45,UU
        .= halt SCMPDS by A27,A29,A31;
      hence contradiction by A17,A28,EXTPRO_1:def 14;
    end;
  end;
  then for l be Element of NAT st CurInstr(P3,
  Comput(P3,s3,l)) = halt SCMPDS
  holds LifeSpan(P1,s1) + 1 <= l;
  then
A34: LifeSpan(P3,s3) = LifeSpan(P1,s1) + 1 by A22,A23
,EXTPRO_1:def 14;
A36: DataPart Result(P1,s1) = DataPart Comput(P1, s1
,LifeSpan(P1,s1)) by A17,EXTPRO_1:23
    .= DataPart Comput(P3, s4,LifeSpan(P1,s1))
    by A15,A13,A9,A11,Th45,UU
    .= DataPart Comput(P3, s3,LifeSpan(P1,s1) + 1)
by EXTPRO_1:5
    .= DataPart Result(P3,s3) by A23,A34,EXTPRO_1:23;
A37: now
    let x be set;
A38: dom SAl = {IC SCMPDS} by FUNCOP_1:19;
    assume
A39: x in dom IExec(IF,P,s);
    per cases by A39,SCMPDS_4:20;
    suppose
A40:  x is Int_position;
      then x <> IC SCMPDS by SCMPDS_2:52;
      then
A41:  not x in dom SAl by A38,TARSKI:def 1;
A42: not x in dom (s | A) by A8,A40,SCMPDS_2:53;
      hence IExec(IF,P,s).x = (Result(P3,s3)).x by FUNCT_4:12
        .= (Result(P1,s1)).x by A36,A40,SCMPDS_4:23
        .= IExec(J,P,s).x by A42,FUNCT_4:12
        .= (IExec(J,P,s) +* SAl).x by A41,FUNCT_4:12;
    end;
    suppose
A43:  x = IC SCMPDS;
A44: not x in dom (s | A) by A8,A43,COMPOS_1:3;
      then
A45:  IC Result(P1,s1) = IC IExec(J,P,s) by A43,FUNCT_4:12
        .=  (card J) by A14,A16,Th48;
A46:  x in dom SAl by A38,A43,TARSKI:def 1;
      thus IExec(IF,P,s).x = (Result(P3,s3)).x by A44,FUNCT_4:12
        .= Comput(P3, s3,LifeSpan(P1,s1) + 1).x by
A23,A34,EXTPRO_1:23
        .= IC Comput(P3, s4,LifeSpan(P1,s1)) by A43,
EXTPRO_1:5
        .= IC Comput(P1, s1,LifeSpan(P1,s1)) + (card
I + 2) by A15,A13,A9,A11,Th45,UU
        .= IC Result(P1,s1) + (card I + 2) by A17,EXTPRO_1:23
        .= IC Start-At (card J + (card I + 2),SCMPDS) by A45,FUNCOP_1:87
        .= (IExec(J,P,s) +* SAl).x by A43,A46,FUNCT_4:14;
    end;
    suppose
      x is Element of NAT;
      hence IExec(IF,P,s).x = (IExec(J,P,s) +* SAl).x by Th26;
    end;
  end;
  dom IExec(IF,P,s) = the carrier of SCMPDS by PARTFUN1:def 4
    .= dom (IExec(J,P,s) +* SAl) by PARTFUN1:def 4;
  hence thesis by A37,FUNCT_1:9;
end;

registration
  let I,J be shiftable parahalting Program of SCMPDS, a be Int_position,k1 be
  Integer;
  cluster if<0(a,k1,I,J) -> shiftable parahalting;
  correctness
  proof
    set i = (a,k1)>=0_goto (card I + 2), G =Goto (card J+1);
    set IF=if<0(a,k1,I,J), pIF = stop IF;
    reconsider IJ=I ';' G ';' J as shiftable Program of SCMPDS;
    thus IF is shiftable;
      let s be 0-started State of SCMPDS;
      let P be (the Instructions of SCMPDS)-valued ManySortedSet of NAT;
A1:  Initialize s = s by COMPOS_1:78;
      assume pIF c= P;
      then
A2:   P = P +* stop IF by FUNCT_4:104;
A3:   J is_closed_on s,P & J is_halting_on s,P by Th34,Th35;
A4:   I is_closed_on s,P & I is_halting_on s,P by Th34,Th35;
      per cases;
      suppose
        s.DataLoc(s.a,k1) < 0;
        then IF is_halting_on s,P by A4,Th112;
        hence P halts_on s by A2,Def3,A1;
      end;
      suppose
        s.DataLoc(s.a,k1) >= 0;
        then IF is_halting_on s,P by A3,Th113;
        hence P halts_on s by A2,Def3,A1;
      end;
  end;
end;

registration
  let I,J be halt-free Program of SCMPDS, a be Int_position,k1 be Integer;
  cluster if<0(a,k1,I,J) -> halt-free;
  coherence;
end;

theorem
  for s being State of SCMPDS,I,J being halt-free shiftable
  parahalting Program of SCMPDS,a being Int_position,k1 being Integer holds IC
  IExec(if<0(a,k1,I,J),P,s) =  (card I + card J + 2)
proof
  let s be State of SCMPDS,I,J be halt-free shiftable parahalting Program of
  SCMPDS,a be Int_position,k1 be Integer;
  set IF=if<0(a,k1,I,J);
A1: I is_closed_on s,P & I is_halting_on s,P by Th34,Th35;
A2: J is_closed_on s,P & J is_halting_on s,P by Th34,Th35;
  per cases;
  suppose
    s.DataLoc(s.a,k1) < 0;
    then IExec(IF,P,s) = IExec(I,P,s) +* Start-At((card I+card J+2),SCMPDS)
    by A1,Th114;
    hence thesis by FUNCT_4:121;
  end;
  suppose
    s.DataLoc(s.a,k1) >= 0;
    then IExec(IF,P,s) = IExec(J,P,s) +* Start-At((card I+card J+2),SCMPDS)
    by A2,Th115;
    hence thesis by FUNCT_4:121;
  end;
end;

theorem
  for s being State of SCMPDS,I being halt-free shiftable parahalting
  Program of SCMPDS,J being shiftable Program of SCMPDS,a,b being Int_position,
k1 being Integer st s.DataLoc(s.a,k1)<0 holds IExec(if<0(a,k1,I,J),P,s).b
 = IExec(I,P,s).b
proof
  let s be State of SCMPDS,I be halt-free shiftable parahalting Program of
  SCMPDS,J be shiftable Program of SCMPDS,a,b be Int_position, k1 be Integer;
  assume
A1: s.DataLoc(s.a,k1)<0;
A2: not b in dom Start-At((card I+card J+2),SCMPDS) by SCMPDS_4:59;
  I is_closed_on s,P & I is_halting_on s,P by Th34,Th35;
  then
  IExec(if<0(a,k1,I,J),P,s) = IExec(I,P,s) +* Start-At((card I + card J
  + 2),SCMPDS) by A1,Th114;
  hence thesis by A2,FUNCT_4:12;
end;

theorem
  for s being State of SCMPDS,I being Program of SCMPDS,J being
  halt-free parahalting shiftable Program of SCMPDS,a,b being Int_position,k1
being Integer st s.DataLoc(s.a,k1) >= 0
 holds IExec(if<0(a,k1,I,J),P,s).b = IExec(J,P,s).b
proof
  let s be State of SCMPDS,I be Program of SCMPDS,J be halt-free parahalting
  shiftable Program of SCMPDS,a,b be Int_position, k1 be Integer;
  set IF=if<0(a,k1,I,J);
  assume
A1: s.DataLoc(s.a,k1) >= 0;
A2: not b in dom Start-At((card I+card J+2),SCMPDS) by SCMPDS_4:59;
  J is_closed_on s,P & J is_halting_on s,P by Th34,Th35;
  then IExec(IF,P,s) =IExec(J,P,s) +* Start-At((card I+card J+2),SCMPDS)
  by A1,Th115;
  hence thesis by A2,FUNCT_4:12;
end;

begin :: The computation of "if var<0 then block"

theorem
  card if<0(a,k1,I) = card I + 1 by Th15;

theorem
   0 in dom if<0(a,k1,I)
proof
  set ci=card if<0(a,k1,I);
  ci=card I + 1 by Th15;
  hence thesis by AFINSQ_1:70;
end;

theorem
  if<0(a,k1,I). 0 = (a,k1)>=0_goto (card I + 1) by Th16;

theorem Th122:
  for s being State of SCMPDS, I being shiftable Program of
  SCMPDS, a being Int_position,k1 being Integer st s.DataLoc(s.a,k1) < 0 & I
is_closed_on s,P & I is_halting_on s,P holds if<0(a,k1,I) is_closed_on s,P
 & if<0(a,
  k1,I) is_halting_on s,P
proof
  let s be State of SCMPDS, I be shiftable Program of SCMPDS, a be
  Int_position,k1 be Integer;
  set b=DataLoc(s.a,k1);
  set IF=if<0(a,k1,I), pIF=stop IF, pI=stop I,
   s2 = Initialize s, s3 = Initialize s,
   P2 = P +* pI, P3 = P +* pIF,
   s4 = Comput(P3,s3,1), P4 = P3;
  set i = (a,k1)>=0_goto (card I + 1);
UU:  stop I c= P2 by FUNCT_4:26;
A3:  0 in dom pIF by COMPOS_1:135;
A4: IC s3 = 0 by COMPOS_1:223;
A5: not b in dom Start-At(0,SCMPDS) by SCMPDS_4:59;
  not a in dom Start-At(0,SCMPDS) by SCMPDS_4:59;
  then
A6: s3.DataLoc(s3.a,k1)=s3.b by FUNCT_4:12
    .= s.b by A5,FUNCT_4:12;
A7: Comput(P3, s3,0 + 1) = Following(P3,
Comput(P3,s3,0)) by EXTPRO_1:4
    .= Following(P3,s3) by EXTPRO_1:3
    .= Exec(i,s3) by Th22;
  now
    let a;
    thus s2.a = s3.a
      .= s4.a by A7,SCMPDS_2:69;
  end;
  then
A9: DataPart s2 = DataPart s4 by SCMPDS_4:23;
  assume
  s.b < 0;
  then
A10: IC s4 = succ IC s3 by A7,A6,SCMPDS_2:69
    .= (0+1) by A4;
  assume
A11: I is_closed_on s,P;
  then
A12: I is_closed_on s2,P2 by Th38;
  assume
  I is_halting_on s,P;
  then
A13: P2 halts_on s2 by Def3;
A14: Start-At(0,SCMPDS) c= s2 & Shift(pI,1) c= P4 by Lm6,FUNCT_4:26;
A15: card pIF = card IF +1 by SCMPDS_5:7
    .= card I +1+1 by Th15;
  now
    let k be Element of NAT;
    per cases;
    suppose
      0 < k;
      then consider k1 being Nat such that
A16:  k1 + 1 = k by NAT_1:6;
      reconsider k1 as Element of NAT by ORDINAL1:def 13;
      reconsider m = IC Comput(P2, s2,k1) as Element of NAT;
A17:  card pIF = card pI+1 by A15,SCMPDS_5:7;
       m in dom pI by A11,Def2;
      then m < card pI by AFINSQ_1:70;
      then
A18:  m+1 < card pIF by A17,XREAL_1:8;
      IC Comput(P3,s3,k) = IC Comput(P3, s4,k1) by
A16,EXTPRO_1:5
        .=  (m + 1) by A12,A14,A10,A9,Th45,UU;
      hence IC Comput(P3,s3,k) in dom pIF by A18,AFINSQ_1:70;
    end;
    suppose
      k = 0;
      hence IC Comput(P3,s3,k) in dom pIF by A3,A4,EXTPRO_1:3;
    end;
  end;
  hence IF is_closed_on s,P by Def2;
A21: Comput(P3,s3,LifeSpan(P2,s2)+1)
 = Comput(P3,Comput(P3,s3,1),LifeSpan(P2
,s2))
by EXTPRO_1:5;
  CurInstr(P3,
  Comput(P3,s3,LifeSpan(P2,s2)+1))
   =CurInstr(P3,
   Comput(P3,s4,LifeSpan(P2,s2))) by A21
    .=CurInstr(P2,
    Comput(P2,s2,LifeSpan(P2,s2))) by A12,A14,A10,A9
,Th45,UU
    .= halt SCMPDS by A13,EXTPRO_1:def 14;
  then P3 halts_on s3 by EXTPRO_1:30;
  hence thesis by Def3;
end;

theorem Th123:
  for s being State of SCMPDS,I being Program of SCMPDS, a being
  Int_position, k1 being Integer st s.DataLoc(s.a,k1) >= 0 holds if<0(a,k1,I)
  is_closed_on s,P & if<0(a,k1,I) is_halting_on s,P
proof
  let s be State of SCMPDS,I be Program of SCMPDS, a be Int_position,k1 be
  Integer;
  set b=DataLoc(s.a,k1);
  assume
A1: s.b >= 0;
  set i = (a,k1)>=0_goto (card I + 1);
  set IF=if<0(a,k1,I), pIF=stop IF, s3 = Initialize s,
  P3 = P +* pIF,
  s4 = Comput(P3,s3,1), P4 = P3;
A3: IC s3 = 0 by COMPOS_1:223;
A4: not b in dom Start-At(0,SCMPDS) by SCMPDS_4:59;
  not a in dom Start-At(0,SCMPDS) by SCMPDS_4:59;
  then
A5: s3.DataLoc(s3.a,k1)=s3.b by FUNCT_4:12
    .= s.b by A4,FUNCT_4:12;
  Comput(P3, s3,0 + 1) = Following(P3,
  Comput(P3,s3,0)) by EXTPRO_1:4
    .= Following(P3,s3) by EXTPRO_1:3
    .= Exec(i,s3) by Th22;
  then
A6: IC s4 = ICplusConst(s3,card I + 1) by A1,A5,SCMPDS_2:69
    .= (0+(card I + 1)) by A3,Th23;
A7: card IF=card I+1 by Th15;
  then
A8: (card I+1) in dom pIF by Th25;
A9:  P3/.IC s4
 = P3.IC s4 by PBOOLE:158;
  pIF c= P3 by FUNCT_4:26;
  then pIF c= P4;
  then P4.(card I+1) = pIF.(card I+1) by A8,GRFUNC_1:8
    .=halt SCMPDS by A7,Th25;
  then
A11: CurInstr(P3,s4) = halt SCMPDS by A6,A9;
  now
    let k be Element of NAT;
    per cases;
    suppose
      0 < k;
      then 1+0 <= k by INT_1:20;
      hence IC Comput(P3,s3,k) in dom pIF by A8,A6,A11,EXTPRO_1:6;
    end;
    suppose
      k = 0;
      then Comput(P3,s3,k) = s3 by EXTPRO_1:3;
      hence IC Comput(P3,s3,k) in dom pIF by A3,COMPOS_1:135;
    end;
  end;
  hence IF is_closed_on s,P by Def2;
  P3 halts_on s3 by A11,EXTPRO_1:30;
  hence thesis by Def3;
end;

theorem Th124:
  for s being State of SCMPDS,I being halt-free shiftable
Program of SCMPDS, a being Int_position,k1 being Integer st s.DataLoc(s.a,k1) <
0 & I is_closed_on s,P & I is_halting_on s,P
 holds IExec(if<0(a,k1,I),P,s) = IExec(I,P,s) +* Start-At((card I+1),SCMPDS)
proof
  let s be State of SCMPDS,I be halt-free shiftable Program of SCMPDS, a be
  Int_position,k1 be Integer;
  set b=DataLoc(s.a,k1);
  set IF=if<0(a,k1,I), pIF = stop IF, pI=stop I,
   s2 = Initialize s, s3 = Initialize s,
   P2 = P +* pI, P3 = P +* pIF,
   s4 = Comput(P3, s3,1), P4 = P3;
  set i = (a,k1)>=0_goto (card I + 1);
  set SAl=Start-At((card I+1),SCMPDS);
UU:  stop I c= P2 by FUNCT_4:26;
A3: IC s3 = 0 by COMPOS_1:223;
A4: not b in dom Start-At(0,SCMPDS) by SCMPDS_4:59;
  not a in dom Start-At(0,SCMPDS) by SCMPDS_4:59;
  then
A5: s3.DataLoc(s3.a,k1)=s3.b by FUNCT_4:12
    .= s.b by A4,FUNCT_4:12;
A6: Comput(P3, s3,0 + 1) = Following(P3,
Comput(P3,s3,0)) by EXTPRO_1:4
    .= Following(P3,s3) by EXTPRO_1:3
    .= Exec(i,s3) by Th22;
  assume
  s.b < 0;
  then
A7: IC s4 = succ IC s3 by A6,A5,SCMPDS_2:69
    .= (0+1) by A3;
  now
    let a;
    thus s2.a = s3.a
      .= s4.a by A6,SCMPDS_2:69;
  end;
  then
A9: DataPart s2 = DataPart s4 by SCMPDS_4:23;
  assume
A10: I is_closed_on s,P;
  then
A11: I is_closed_on s2,P2 by Th38;
A12: dom ProgramPart s = A by COMPOS_1:34;
A13: Start-At(0,SCMPDS) c= s2 & Shift(pI,1) c= P4 by Lm6,FUNCT_4:26;
  assume
A14: I is_halting_on s,P;
  then
A15: P2 halts_on s2 by Def3;
A17: Comput(P3,s3,LifeSpan(P2,s2)+1)
= Comput(P3,Comput(P3,s3,1),LifeSpan(P2,
s2))
 by EXTPRO_1:5;
A20: CurInstr(P3,
Comput(P3,s3,LifeSpan(P2,s2)+1))
 =CurInstr(P3,
 Comput(P3,s4,LifeSpan(P2,s2))) by A17
    .=CurInstr(P2,
    Comput(P2,s2,LifeSpan(P2,s2))) by A11,A13,A7,A9
,Th45,UU
    .= halt SCMPDS by A15,EXTPRO_1:def 14;
  then
A21: P3 halts_on s3 by EXTPRO_1:30;
A22: CurInstr(P3,s3) = i by Th22;
  now
    let l be Element of NAT;
    assume
A23: l < LifeSpan(P2,s2) + 1;
A24: Comput(P3,s3,0) = s3 by EXTPRO_1:3;
    per cases;
    suppose
      l = 0;
      then CurInstr(P3,Comput(P3,s3,l))
       = CurInstr(P3,s3)
       by A24;
      hence CurInstr(P3,Comput(P3,s3,l))
       <> halt SCMPDS by A22;
    end;
    suppose
      l <> 0;
      then consider n be Nat such that
A25:  l = n + 1 by NAT_1:6;
      reconsider n as Element of NAT by ORDINAL1:def 13;
A26:  n < LifeSpan(P2,s2) by A23,A25,XREAL_1:8;
      assume
A27:  CurInstr(P3,Comput(P3,s3,l)) = halt SCMPDS;
A29: Comput(P3,s3,n+1)
 = Comput(P3,Comput(P3,s3,1),n) by EXTPRO_1:5;
      CurInstr(P2,Comput(P2,s2,n)) =
      CurInstr(P3,Comput(P3,s4,n)) by A11,A13,A7,A9
,Th45,UU
        .= halt SCMPDS by A25,A27,A29;
      hence contradiction by A15,A26,EXTPRO_1:def 14;
    end;
  end;
  then for l be Element of NAT st CurInstr(P3,
  Comput(P3,s3,l)) = halt SCMPDS
  holds LifeSpan(P2,s2) + 1 <= l;
  then
A32: LifeSpan(P3,s3) = LifeSpan(P2,s2) + 1 by A20,A21
,EXTPRO_1:def 14;
A34: DataPart Result(P2,s2) = DataPart Comput(P2,s2,
LifeSpan(P2,s2)) by A15,EXTPRO_1:23
    .= DataPart Comput(P3, s4,LifeSpan(P2,s2)) by A11
,A13,A7,A9,Th45,UU
    .= DataPart Comput(P3, s3,LifeSpan(P2,s2) + 1)
by EXTPRO_1:5
    .= DataPart Result(P3,s3) by A21,A32,EXTPRO_1:23;
A35: now
    let x be set;
A36: dom SAl = {IC SCMPDS} by FUNCOP_1:19;
    assume
A37: x in dom IExec(IF,P,s);
    per cases by A37,SCMPDS_4:20;
    suppose
A38:  x is Int_position;
      then x <> IC SCMPDS by SCMPDS_2:52;
      then
A39:  not x in dom SAl by A36,TARSKI:def 1;
A40: not x in dom (s | A) by A12,A38,SCMPDS_2:53;
      hence IExec(IF,P,s).x = (Result(P3,s3)).x by FUNCT_4:12
        .= (Result(P2,s2)).x by A34,A38,SCMPDS_4:23
        .= IExec(I,P,s).x by A40,FUNCT_4:12
        .= (IExec(I,P,s) +* SAl).x by A39,FUNCT_4:12;
    end;
    suppose
A41:  x = IC SCMPDS;
A42: not x in dom (s | A) by A12,A41,COMPOS_1:3;
      then
A43:  IC Result(P2,s2) = IC IExec(I,P,s) by A41,FUNCT_4:12
        .=  card I by A10,A14,Th48;
A44:  x in dom SAl by A36,A41,TARSKI:def 1;
      thus IExec(IF,P,s).x = (Result(P3,s3)).x by A42,FUNCT_4:12
        .= Comput(P3, s3,LifeSpan(P2,s2) + 1).x by
A21,A32,EXTPRO_1:23
        .= IC Comput(P3, s4,LifeSpan(P2,s2)) by A41,
EXTPRO_1:5
        .= IC Comput(P2, s2,LifeSpan(P2,s2)) + 1
        by A11,A13,A7,A9,Th45,UU
        .= IC Result(P2,s2) + 1 by A15,EXTPRO_1:23
        .= IC SAl by A43,FUNCOP_1:87
        .= (IExec(I,P,s) +* SAl).x by A41,A44,FUNCT_4:14;
    end;
    suppose
      x is Element of NAT;
      hence IExec(IF,P,s).x = (IExec(I,P,s) +* SAl).x by Th26;
    end;
  end;
  dom IExec(IF,P,s) = the carrier of SCMPDS by PARTFUN1:def 4
    .= dom (IExec(I,P,s) +* SAl) by PARTFUN1:def 4;
  hence thesis by A35,FUNCT_1:9;
end;

theorem Th125:
  for s being State of SCMPDS,I being Program of SCMPDS,a being
Int_position, k1 being Integer st s.DataLoc(s.a,k1) >= 0
 holds IExec(if<0(a,k1,I),P,s) = s +* Start-At((card I+1),SCMPDS)
proof
  let s be State of SCMPDS,I be Program of SCMPDS,a be Int_position, k1 be
  Integer;
  set b=DataLoc(s.a,k1);
  set IF=if<0(a,k1,I), pIF=stop IF, s3 = Initialize s,
  P3 = P +* pIF,
  s4 = Comput(P3, s3,1), P4 = P3;
  set i = (a,k1)>=0_goto (card I + 1);
  set SAl=Start-At((card I+1),SCMPDS);
A2: IC s3 = 0 by COMPOS_1:223;
A3: not b in dom Start-At(0,SCMPDS) by SCMPDS_4:59;
  not a in dom Start-At(0,SCMPDS) by SCMPDS_4:59;
  then
A4: s3.DataLoc(s3.a,k1)=s3.b by FUNCT_4:12
    .= s.b by A3,FUNCT_4:12;
A5: Comput(P3, s3,0 + 1) = Following(P3,
Comput(P3,s3,0)) by EXTPRO_1:4
    .= Following(P3,s3) by EXTPRO_1:3
    .= Exec(i,s3) by Th22;
  assume
  s.b >= 0;
  then
A6: IC s4 = ICplusConst(s3,card I + 1) by A5,A4,SCMPDS_2:69
    .= (0+(card I + 1)) by A2,Th23;
  pIF c= P3 by FUNCT_4:26;
  then
A7: pIF c= P4;
A8:  P3/.IC s4
 = P3.IC s4 by PBOOLE:158;
A10: card IF=card I+1 by Th15;
  then (card I+1) in dom pIF by Th25;
  then P4.(card I+1) = pIF.(card I+1) by A7,GRFUNC_1:8
    .=halt SCMPDS by A10,Th25;
  then
A11: CurInstr(P3,s4) = halt SCMPDS by A6,A8;
  then
A12: P3 halts_on s3 by EXTPRO_1:30;
A13: CurInstr(P3,s3) = i by Th22;
  now
    let l be Element of NAT;
A14: Comput(P3,s3,0) = s3 by EXTPRO_1:3;
    assume
    l < 1;
    then l <1+0;
    then l=0 by NAT_1:13;
    then CurInstr(P3,Comput(P3,s3,l))
     = CurInstr(P3,s3) by A14;
    hence CurInstr(P3,Comput(P3,s3,l))
     <> halt SCMPDS by A13;
  end;
  then for l be Element of NAT st CurInstr(P3,
  Comput(P3,s3,l)) = halt SCMPDS
  holds 1 <= l;
  then LifeSpan(P3,s3) = 1 by A11,A12,EXTPRO_1:def 14;
  then
A15: s4 = Result(P3,s3) by A12,EXTPRO_1:23;
A16: dom ProgramPart s = A by COMPOS_1:34;
A17: now
A18: dom SAl = {IC SCMPDS} by FUNCOP_1:19;
    let x be set;
    assume
A19: x in dom IExec(IF,P,s);
    per cases by A19,SCMPDS_4:20;
    suppose
A20:  x is Int_position;
      then x <> IC SCMPDS by SCMPDS_2:52;
      then
A21:  not x in dom SAl by A18,TARSKI:def 1;
TT:   not x in dom Start-At(0,SCMPDS) by A20,SCMPDS_4:59;
      not x in dom (s | A) by A16,A20,SCMPDS_2:53;
      hence IExec(IF,P,s).x = s4.x by A15,FUNCT_4:12
        .= s3.x by A5,A20,SCMPDS_2:69
        .= s.x by TT,FUNCT_4:12
        .= (s +* SAl).x by A21,FUNCT_4:12;
    end;
    suppose
A22:  x = IC SCMPDS;
      not x in dom (s | A) by A16,A22,COMPOS_1:3;
      hence IExec(IF,P,s).x = (card I + 1) by A6,A15,A22,FUNCT_4:12
        .= (s +* SAl).x by A22,FUNCT_4:121;
    end;
    suppose
      x is Element of NAT;
      hence IExec(IF,P,s).x = (s +* SAl).x by Th27;
    end;
  end;
  dom IExec(IF,P,s) = the carrier of SCMPDS by PARTFUN1:def 4
    .= dom (s +* SAl) by PARTFUN1:def 4;
  hence thesis by A17,FUNCT_1:9;
end;

registration
  let I be shiftable parahalting Program of SCMPDS, a be Int_position,k1 be
  Integer;
  cluster if<0(a,k1,I) -> shiftable parahalting;
  correctness
  proof
    set i = (a,k1)>=0_goto (card I +1);
    set IF=if<0(a,k1,I), pIF = stop IF;
    thus IF is shiftable;
      let s be 0-started State of SCMPDS;
      let P be (the Instructions of SCMPDS)-valued ManySortedSet of NAT;
A1:  Initialize s = s by COMPOS_1:78;
      assume pIF c= P;
      then
A2:   P = P +* stop IF by FUNCT_4:104;
A3:   I is_closed_on s,P & I is_halting_on s,P by Th34,Th35;
      per cases;
      suppose
        s.DataLoc(s.a,k1) < 0;
        then IF is_halting_on s,P by A3,Th122;
        hence P halts_on s by A2,Def3,A1;
      end;
      suppose
        s.DataLoc(s.a,k1) >= 0;
        then IF is_halting_on s,P by Th123;
        hence P halts_on s by A2,Def3,A1;
      end;
  end;
end;

registration
  let I be halt-free Program of SCMPDS, a be Int_position,k1 be Integer;
  cluster if<0(a,k1,I) -> halt-free;
  coherence;
end;

theorem
  for s being State of SCMPDS,I being halt-free shiftable parahalting
Program of SCMPDS,a being Int_position,k1 being Integer
 holds IC IExec(if<0(a,k1,I),P,s) =  (card I + 1)
proof
  let s be State of SCMPDS,I be halt-free shiftable parahalting Program of
  SCMPDS,a be Int_position,k1 be Integer;
  set IF=if<0(a,k1,I);
A1: I is_closed_on s,P & I is_halting_on s,P by Th34,Th35;
  per cases;
  suppose
    s.DataLoc(s.a,k1) < 0;
    then IExec(IF,P,s) =IExec(I,P,s) +* Start-At((card I+1),SCMPDS)
    by A1,Th124;
    hence thesis by FUNCT_4:121;
  end;
  suppose
    s.DataLoc(s.a,k1) >= 0;
    then IExec(IF,P,s) =s +* Start-At((card I+1),SCMPDS) by Th125;
    hence thesis by FUNCT_4:121;
  end;
end;

theorem
  for s being State of SCMPDS,I being halt-free shiftable parahalting
Program of SCMPDS,a,b being Int_position,k1 being Integer st s.DataLoc(s.a,k1)
  < 0 holds IExec(if<0(a,k1,I),P,s).b = IExec(I,P,s).b
proof
  let s be State of SCMPDS,I be halt-free shiftable parahalting Program of
  SCMPDS,a,b be Int_position,k1 be Integer;
  assume
A1: s.DataLoc(s.a,k1) < 0;
A2: not b in dom Start-At((card I+1),SCMPDS) by SCMPDS_4:59;
  I is_closed_on s,P & I is_halting_on s,P by Th34,Th35;
  then IExec(if<0(a,k1,I),P,s) = IExec(I,P,s) +* Start-At((card I+1),SCMPDS)
  by A1,Th124;
  hence thesis by A2,FUNCT_4:12;
end;

theorem
  for s being State of SCMPDS,I being Program of SCMPDS,a,b being
Int_position, k1 being Integer st s.DataLoc(s.a,k1) >= 0
 holds IExec(if<0(a,k1,I),P,s).b = s.b
proof
  let s be State of SCMPDS,I be Program of SCMPDS,a,b be Int_position, k1 be
  Integer;
  assume
  s.DataLoc(s.a,k1) >= 0;
  then
A1: IExec(if<0(a,k1,I),P,s) = s +* Start-At((card I+1),SCMPDS) by Th125;
  not b in dom Start-At((card I+1),SCMPDS) by SCMPDS_4:59;
  hence thesis by A1,FUNCT_4:12;
end;

begin :: The computation of "if var>=0 then block"

theorem
  card if>=0(a,k1,I) = card I + 2 by Lm8;

theorem
   0 in dom if>=0(a,k1,I) &  1 in dom if>=0(a,k1,I) by Lm9;

theorem
  if>=0(a,k1,I). 0 = (a,k1)>=0_goto 2 & if>=0(a,k1,I). 1 =
  goto (card I + 1) by Lm10;

theorem Th132:
  for s being State of SCMPDS, I being shiftable Program of
  SCMPDS, a being Int_position,k1 being Integer st s.DataLoc(s.a,k1) >= 0 & I
is_closed_on s,P & I is_halting_on s,P holds if>=0(a,k1,I) is_closed_on s,P
 & if>=0(a
  ,k1,I) is_halting_on s,P
proof
  let s be State of SCMPDS, I be shiftable Program of SCMPDS, a be
  Int_position,k1 be Integer;
  set b=DataLoc(s.a,k1);
  set IF=if>=0(a,k1,I), pIF=stop IF, pI=stop I,
   s2 = Initialize s, s3 = Initialize s,
   P2 = P +* pI, P3 = P +* pIF,
   s4 = Comput(P3,s3,1), P4 = P3;
  set i = (a,k1)>=0_goto 2, j = goto (card I + 1);
UU:  stop I c= P2 by FUNCT_4:26;
A3: IF = i ';' (j ';' I) by SCMPDS_4:52;
A4: Comput(P3, s3,0 + 1) = Following(P3,
Comput(P3,s3,0)) by EXTPRO_1:4
    .= Following(P3,s3) by EXTPRO_1:3
    .= Exec(i,s3) by A3,Th22;
  now
    let a;
    thus s2.a = s3.a
      .= s4.a by A4,SCMPDS_2:69;
  end;
  then
A6: DataPart s2 = DataPart s4 by SCMPDS_4:23;
A7: not b in dom Start-At(0,SCMPDS) by SCMPDS_4:59;
  not a in dom Start-At(0,SCMPDS) by SCMPDS_4:59;
  then
A8: s3.DataLoc(s3.a,k1)=s3.b by FUNCT_4:12
    .= s.b by A7,FUNCT_4:12;
A9: IC s3 = 0 by COMPOS_1:223;
  assume
  s.b >= 0;
  then
A10: IC s4 = ICplusConst(s3,2) by A4,A8,SCMPDS_2:69
    .= (0+2) by A9,Th23;
  assume
A11: I is_closed_on s,P;
  then
A12: I is_closed_on s2,P2 by Th38;
  assume
  I is_halting_on s,P;
  then
A13: P2 halts_on s2 by Def3;
A14: Start-At(0,SCMPDS) c= s2 & Shift(pI,2) c= P4 by Lm7,FUNCT_4:26;
A15:  0 in dom pIF by COMPOS_1:135;
  now
    let k be Element of NAT;
    per cases;
    suppose
      0 < k;
      then consider k1 being Nat such that
A16:  k1 + 1 = k by NAT_1:6;
      reconsider k1 as Element of NAT by ORDINAL1:def 13;
      reconsider m = IC Comput(P2, s2,k1) as Element of NAT;
A17:  card pIF = 1+ card IF by SCMPDS_5:7
        .= 1+(card I +2) by Lm8
        .= 1+card I +2
        .=card pI+2 by SCMPDS_5:7;
       m in dom pI by A11,Def2;
      then m < card pI by AFINSQ_1:70;
      then
A18:  m+2 < card pIF by A17,XREAL_1:8;
      IC Comput(P3,s3,k) = IC Comput(P3, s4,k1) by
A16,EXTPRO_1:5
        .=  (m + 2) by A12,A14,A10,A6,Th45,UU;
      hence IC Comput(P3,s3,k) in dom pIF by A18,AFINSQ_1:70;
    end;
    suppose
      k = 0;
      hence IC Comput(P3,s3,k) in dom pIF by A15,A9,EXTPRO_1:3;
    end;
  end;
  hence IF is_closed_on s,P by Def2;
A21: Comput(P3,s3,LifeSpan(P2,s2)+1)
 = Comput(P3,Comput(P3,s3,1),LifeSpan(P2
,s2))
by EXTPRO_1:5;
  CurInstr(P3,
  Comput(P3,s3,LifeSpan(P2,s2)+1))
   =CurInstr(P3,
   Comput(P3,s4,LifeSpan(P2,s2))) by A21
    .=CurInstr(P2,
    Comput(P2,s2,LifeSpan(P2,s2))) by A12,A14,A10,A6
,Th45,UU
    .= halt SCMPDS by A13,EXTPRO_1:def 14;
  then P3 halts_on s3 by EXTPRO_1:30;
  hence thesis by Def3;
end;

theorem Th133:
  for s being State of SCMPDS,I being Program of SCMPDS, a being
  Int_position, k1 being Integer st s.DataLoc(s.a,k1) < 0 holds if>=0(a,k1,I)
  is_closed_on s,P & if>=0(a,k1,I) is_halting_on s,P
proof
  let s be State of SCMPDS,I be Program of SCMPDS, a be Int_position,k1 be
  Integer;
  set b=DataLoc(s.a,k1);
  assume
A1: s.b < 0;
  set i = (a,k1)>=0_goto 2, j = goto (card I + 1);
  set IF=if>=0(a,k1,I), pIF=stop IF, s3 = Initialize s,
  P3 = P +* pIF,
  s4 = Comput(P3,s3,1), s5 = Comput(P3,s3,2), P4 = P3, P5 = P3;
A3: IF =i ';' (j ';' I) by SCMPDS_4:52;
A4: not b in dom Start-At(0,SCMPDS) by SCMPDS_4:59;
  not a in dom Start-At(0,SCMPDS) by SCMPDS_4:59;
  then
A5: s3.DataLoc(s3.a,k1)=s3.b by FUNCT_4:12
    .= s.b by A4,FUNCT_4:12;
A6: IC s3 = 0 by COMPOS_1:223;
  Comput(P3, s3,0 + 1) = Following(P3,
  Comput(P3,s3,0)) by EXTPRO_1:4
    .= Following(P3,s3) by EXTPRO_1:3
    .= Exec(i,s3) by A3,Th22;
  then
A7: IC s4 = succ IC s3 by A1,A5,SCMPDS_2:69
    .= (0+1) by A6;
A8: pIF c= P3 by FUNCT_4:26;
  then
A9: pIF c= P4;
A10:  1 in dom IF by Lm9;
  then  1 in dom pIF by Th18;
  then
A11: P4.1 = pIF. 1 by A9,GRFUNC_1:8
    .=IF. 1 by A10,Th19
    .=j by Lm10;
A12: card IF=card I+2 by Lm8;
  then
A13: (card I+2) in dom pIF by Th25;
A14:  P3/.IC s4
 = P3.IC s4 by PBOOLE:158;
  Comput(P3, s3,1 + 1) = Following(P3,s4) by
EXTPRO_1:4
    .= Exec(j,s4) by A7,A11,A14;
  then
A16: IC s5 = ICplusConst(s4,card I+1) by SCMPDS_2:66
    .= (card I+1+1) by A7,Th23
    .= (card I+(1+1));
A17:  (P3)/.IC s5
 = P3.IC s5 by PBOOLE:158;
  pIF c= P5 by A8;
  then P5.(card I+2) = pIF.(card I+2) by A13,GRFUNC_1:8
    .=halt SCMPDS by A12,Th25;
  then
A19: CurInstr(P3,s5) = halt SCMPDS by A16,A17;
  now
    let k be Element of NAT;
A20: k = 0 or 0 + 1 <= k by INT_1:20;
    per cases by A20,XXREAL_0:1;
    suppose
      k = 0;
      then Comput(P3,s3,k) = s3 by EXTPRO_1:3;
      hence IC Comput(P3,s3,k) in dom pIF by A6,COMPOS_1:135;
    end;
    suppose
      k = 1;
      hence IC Comput(P3,s3,k) in dom pIF by A10,A7,Th18;
    end;
    suppose
      1 < k;
      then 1+1 <= k by INT_1:20;
      hence IC Comput(P3,s3,k) in dom pIF
      by A13,A16,A19,EXTPRO_1:6;
    end;
  end;
  hence IF is_closed_on s,P by Def2;
  P3 halts_on s3 by A19,EXTPRO_1:30;
  hence thesis by Def3;
end;

theorem Th134:
  for s being State of SCMPDS,I being halt-free shiftable
  Program of SCMPDS, a being Int_position,k1 being Integer st s.DataLoc(s.a,k1)
  >= 0 & I is_closed_on s,P & I is_halting_on s,P
   holds IExec(if>=0(a,k1,I),P,s) =
  IExec(I,P,s) +* Start-At((card I+2),SCMPDS)
proof
  let s be State of SCMPDS,I be halt-free shiftable Program of SCMPDS, a be
  Int_position,k1 be Integer;
  set b=DataLoc(s.a,k1);
  set IF=if>=0(a,k1,I), pIF = stop IF, pI=stop I,
   s2 = Initialize s, s3 = Initialize s,
   P2 = P +* pI, P3 = P +* pIF,
   s4 = Comput(P3, s3,1), P4 = P3;
  set i = (a,k1)>=0_goto 2, j = goto (card I + 1);
  set SAl=Start-At((card I+2),SCMPDS);
A3: IF=i ';' (j ';' I) by SCMPDS_4:52;
UU:  stop I c= P2 by FUNCT_4:26;
A4: Comput(P3, s3,0 + 1) = Following(P3,
Comput(P3,s3,0)) by EXTPRO_1:4
    .= Following(P3,s3) by EXTPRO_1:3
    .= Exec(i,s3) by A3,Th22;
A5: not b in dom Start-At(0,SCMPDS) by SCMPDS_4:59;
  not a in dom Start-At(0,SCMPDS) by SCMPDS_4:59;
  then
A6: s3.DataLoc(s3.a,k1)=s3.b by FUNCT_4:12
    .= s.b by A5,FUNCT_4:12;
A7: IC s3 = 0 by COMPOS_1:223;
A8: Start-At(0,SCMPDS) c= s2 & Shift(pI,2) c= P4 by Lm7,FUNCT_4:26;
  now
    let a;
    thus s2.a = s3.a
      .= s4.a by A4,SCMPDS_2:69;
  end;
  then
A10: DataPart s2 = DataPart s4 by SCMPDS_4:23;
  assume
  s.b >= 0;
  then
A11: IC s4 = ICplusConst(s3,2) by A4,A6,SCMPDS_2:69
    .= (0+2) by A7,Th23;
A12: dom ProgramPart s = A by COMPOS_1:34;
  assume
A13: I is_closed_on s,P;
  then
A14: I is_closed_on s2,P2 by Th38;
  assume
A15: I is_halting_on s,P;
  then
A16: P2 halts_on s2 by Def3;
A18: Comput(P3,s3,LifeSpan(P2,s2)+1)
 = Comput(P3,Comput(P3,s3,1),LifeSpan(P2
,s2))
 by EXTPRO_1:5;
A21: CurInstr(P3,
Comput(P3,s3,LifeSpan(P2,s2)+1))
 =CurInstr(P3,
 Comput(P3,s4,LifeSpan(P2,s2))) by A18
    .=CurInstr(P2,
    Comput(P2,s2,LifeSpan(P2,s2)))
     by A14,A8,A11,A10,Th45,UU
    .= halt SCMPDS by A16,EXTPRO_1:def 14;
  then
A22: P3 halts_on s3 by EXTPRO_1:30;
A23: CurInstr(P3,s3) = i by A3,Th22;
  now
    let l be Element of NAT;
    assume
A24: l < LifeSpan(P2,s2) + 1;
A25: Comput(P3,s3,0) = s3 by EXTPRO_1:3;
    per cases;
    suppose
      l = 0;
      then CurInstr(P3,Comput(P3,s3,l))
       = CurInstr(P3,s3)
      by A25;
      hence CurInstr(P3,Comput(
P3,s3,l))
       <> halt SCMPDS by A23;
    end;
    suppose
      l <> 0;
      then consider n be Nat such that
A26:  l = n + 1 by NAT_1:6;
      reconsider n as Element of NAT by ORDINAL1:def 13;
A27:  n < LifeSpan(P2,s2) by A24,A26,XREAL_1:8;
      assume
A28:  CurInstr(P3,Comput(P3,
s3,l)) = halt SCMPDS;
A30: Comput(P3,s3,n+1)
 = Comput(P3,Comput(P3,s3,1),n) by EXTPRO_1:5;
      CurInstr(P2,Comput(P2,s2,n))
       = CurInstr(P3,Comput(P3,s4,n))
       by A14,A8,A11,A10,Th45,UU
        .= halt SCMPDS by A26,A28,A30;
      hence contradiction by A16,A27,EXTPRO_1:def 14;
    end;
  end;
  then for l be Element of NAT st CurInstr(P3,
  Comput(P3,s3,l)) = halt SCMPDS
  holds LifeSpan(P2,s2) + 1 <= l;
  then
A33: LifeSpan(P3,s3) = LifeSpan(P2,s2) + 1 by A21,A22
,EXTPRO_1:def 14;
A35: DataPart Result(P2,s2) = DataPart Comput(P2,s2,
LifeSpan(P2,s2)) by A16,EXTPRO_1:23
    .= DataPart Comput(P3, s4,LifeSpan(P2,s2)) by A14
,A8,A11,A10,Th45,UU
    .= DataPart Comput(P3, s3,LifeSpan(P2,s2) + 1)
by EXTPRO_1:5
    .= DataPart Result(P3,s3) by A22,A33,EXTPRO_1:23;
A36: now
    let x be set;
A37: dom Start-At((card I+2),SCMPDS) = {IC SCMPDS} by FUNCOP_1:19;
    assume
A38: x in dom IExec(IF,P,s);
    per cases by A38,SCMPDS_4:20;
    suppose
A39:  x is Int_position;
      then x <> IC SCMPDS by SCMPDS_2:52;
      then
A40:  not x in dom SAl by A37,TARSKI:def 1;
A41: not x in dom (s | A) by A12,A39,SCMPDS_2:53;
      hence IExec(IF,P,s).x = (Result(P3,s3)).x by FUNCT_4:12
        .= (Result(P2,s2)).x by A35,A39,SCMPDS_4:23
        .= IExec(I,P,s).x by A41,FUNCT_4:12
        .= (IExec(I,P,s) +* SAl).x by A40,FUNCT_4:12;
    end;
    suppose
A42:  x = IC SCMPDS;
A43: not x in dom (s | A) by A12,A42,COMPOS_1:3;
      then
A44:  IC Result(P2,s2) = IC IExec(I,P,s) by A42,FUNCT_4:12
        .=  card I by A13,A15,Th48;
A45:  x in dom SAl by A37,A42,TARSKI:def 1;
      thus IExec(IF,P,s).x = (Result(P3,s3)).x by A43,FUNCT_4:12
        .= Comput(P3, s3,LifeSpan(P2,s2) + 1).x by
A22,A33,EXTPRO_1:23
        .= IC Comput(P3, s4,LifeSpan(P2,s2)) by A42,
EXTPRO_1:5
        .= IC Comput(P2, s2,LifeSpan(P2,s2)) + 2
        by A14,A8,A11,A10,Th45,UU
        .= IC Result(P2,s2) + 2 by A16,EXTPRO_1:23
        .= IC SAl by A44,FUNCOP_1:87
        .= (IExec(I,P,s) +* SAl).x by A42,A45,FUNCT_4:14;
    end;
    suppose
      x is Element of NAT;
      hence IExec(IF,P,s).x = (IExec(I,P,s) +* SAl).x by Th26;
    end;
  end;
  dom IExec(IF,P,s) = the carrier of SCMPDS by PARTFUN1:def 4
    .= dom (IExec(I,P,s) +* Start-At((card I+2),SCMPDS)) by PARTFUN1:def 4;
  hence thesis by A36,FUNCT_1:9;
end;

theorem Th135:
  for s being State of SCMPDS,I being Program of SCMPDS,a being
Int_position, k1 being Integer st s.DataLoc(s.a,k1) < 0
 holds IExec(if>=0(a,k1,I),P,s) = s +* Start-At((card I+2),SCMPDS)
proof
  let s be State of SCMPDS,I be Program of SCMPDS,a be Int_position, k1 be
  Integer;
  set b=DataLoc(s.a,k1);
  set IF=if>=0(a,k1,I), pIF=stop IF, s3 = Initialize s,
  P3 = P +* pIF,
  s4 = Comput(P3,s3,1), s5 = Comput(P3,s3,2), P4 = P3, P5 = P3;
  set i = (a,k1)>=0_goto 2, j = goto (card I + 1);
  set SAl=Start-At((card I+2),SCMPDS);
A2: IF =i ';' (j ';' I) by SCMPDS_4:52;
A3: not b in dom Start-At(0,SCMPDS) by SCMPDS_4:59;
  not a in dom Start-At(0,SCMPDS) by SCMPDS_4:59;
  then
A4: s3.DataLoc(s3.a,k1)=s3.b by FUNCT_4:12
    .= s.b by A3,FUNCT_4:12;
A5: IC s3 = 0 by COMPOS_1:223;
A6: pIF c= P3 by FUNCT_4:26;
  then
A7: pIF c= P4;
A8: pIF c= P5 by A6;
A9: Comput(P3, s3,0 + 1) = Following(P3,
Comput(P3,s3,0)) by EXTPRO_1:4
    .= Following(P3,s3) by EXTPRO_1:3
    .= Exec(i,s3) by A2,Th22;
  assume
  s.b < 0;
  then
A10: IC s4 = succ IC s3 by A9,A4,SCMPDS_2:69
    .= (0+1) by A5;
A11:  1 in dom IF by Lm9;
  then  1 in dom pIF by Th18;
  then
A12: P4.1 = pIF. 1 by A7,GRFUNC_1:8
    .=IF. 1 by A11,Th19
    .=j by Lm10;
A13:  P3/.IC s4
 = P3.IC s4 by PBOOLE:158;
A15: Comput(P3, s3,1 + 1) = Following(P3,s4) by
EXTPRO_1:4
    .= Exec(j,s4) by A10,A12,A13;
  then
A16: IC s5 = ICplusConst(s4,card I+1) by SCMPDS_2:66
    .= (card I+1+1) by A10,Th23
    .= (card I+(1+1));
A17:  (P3)/.IC s5
 = P3.IC s5 by PBOOLE:158;
A19: card IF=card I+2 by Lm8;
  then (card I+2) in dom pIF by Th25;
  then P5.(card I+2) = pIF.(card I+2) by A8,GRFUNC_1:8
    .=halt SCMPDS by A19,Th25;
  then
A20: CurInstr(P3,s5) = halt SCMPDS by A16,A17;
  then
A21: P3 halts_on s3 by EXTPRO_1:30;
A22: CurInstr(P3,s3) = i by A2,Th22;
  now
    let l be Element of NAT;
    assume
    l < 1+1;
    then
A23: l <= 1 by NAT_1:13;
A24: Comput(P3,s3,0) = s3 by EXTPRO_1:3;
A25: P3/.IC Comput(P3,s3,l)
 = P3.IC Comput(P3,s3,l) by PBOOLE:158;
    per cases by A23,NAT_1:26;
    suppose
      l=0;
      then CurInstr(P3,Comput(P3,s3,l))
       = CurInstr(P3,s3)
       by A24;
      hence CurInstr(P3,Comput(P3,s3,l))
       <> halt SCMPDS by A22;
    end;
    suppose
      l=1;
      hence CurInstr(P3,Comput(P3,s3,l))
       <> halt SCMPDS by A10,A12,A25;
    end;
  end;
  then for l be Element of NAT st CurInstr(P3,
  Comput(P3,s3,l)) = halt SCMPDS
  holds 2 <= l;
  then LifeSpan(P3,s3) = 2 by A20,A21,EXTPRO_1:def 14;
  then
A27: s5 = Result(P3,s3) by A21,EXTPRO_1:23;
A28: dom ProgramPart s = A by COMPOS_1:34;
A29: now
A30: dom SAl = {IC SCMPDS} by FUNCOP_1:19;
    let x be set;
    assume
A31: x in dom IExec(IF,P,s);
    per cases by A31,SCMPDS_4:20;
    suppose
A32:  x is Int_position;
      then x <> IC SCMPDS by SCMPDS_2:52;
      then
A33:  not x in dom SAl by A30,TARSKI:def 1;
TT:   not x in dom Start-At(0,SCMPDS) by A32,SCMPDS_4:59;
      not x in dom (s | A) by A28,A32,SCMPDS_2:53;
      hence IExec(IF,P,s).x = s5.x by A27,FUNCT_4:12
        .= s4.x by A15,A32,SCMPDS_2:66
        .= s3.x by A9,A32,SCMPDS_2:69
        .= s.x by TT,FUNCT_4:12
        .= (s +* SAl).x by A33,FUNCT_4:12;
    end;
    suppose
A34:  x = IC SCMPDS;
      not x in dom (s | A) by A28,A34,COMPOS_1:3;
      hence IExec(IF,P,s).x = (card I + 2) by A16,A27,A34,FUNCT_4:12
        .= (s +* Start-At((card I+2),SCMPDS)).x by A34,FUNCT_4:121;
    end;
    suppose
      x is Element of NAT;
      hence IExec(IF,P,s).x = (s +* SAl).x by Th27;
    end;
  end;
  dom IExec(IF,P,s) = the carrier of SCMPDS by PARTFUN1:def 4
    .= dom (s +* SAl) by PARTFUN1:def 4;
  hence thesis by A29,FUNCT_1:9;
end;

registration
  let I be shiftable parahalting Program of SCMPDS, a be Int_position,k1 be
  Integer;
  cluster if>=0(a,k1,I) -> shiftable parahalting;
  correctness
  proof
    set i = (a,k1)>=0_goto 2, j = goto (card I + 1);
    set IF=if>=0(a,k1,I), pIF = stop IF;
    thus IF is shiftable;
      let s be 0-started State of SCMPDS;
      let P be (the Instructions of SCMPDS)-valued ManySortedSet of NAT;
A1:  Initialize s = s by COMPOS_1:78;
      assume pIF c= P;
      then
A2:   P = P +* stop IF by FUNCT_4:104;
A3:   I is_closed_on s,P & I is_halting_on s,P by Th34,Th35;
      per cases;
      suppose
        s.DataLoc(s.a,k1) >= 0;
        then IF is_halting_on s,P by A3,Th132;
        hence P halts_on s by A2,Def3,A1;
      end;
      suppose
        s.DataLoc(s.a,k1) < 0;
        then IF is_halting_on s,P by Th133;
        hence P halts_on s by A2,Def3,A1;
      end;
  end;
end;

registration
  let I be halt-free Program of SCMPDS, a be Int_position,k1 be Integer;
  cluster if>=0(a,k1,I) -> halt-free;
  coherence;
end;

theorem
  for s being State of SCMPDS,I being halt-free shiftable parahalting
Program of SCMPDS,a being Int_position,k1 being Integer
 holds IC IExec(if>=0(a,k1,I),P,s) =  (card I + 2)
proof
  let s be State of SCMPDS,I be halt-free shiftable parahalting Program of
  SCMPDS,a be Int_position,k1 be Integer;
  set IF=if>=0(a,k1,I);
A1: I is_closed_on s,P & I is_halting_on s,P by Th34,Th35;
  per cases;
  suppose
    s.DataLoc(s.a,k1) >= 0;
    then IExec(IF,P,s) =IExec(I,P,s) +* Start-At((card I+2),SCMPDS)
    by A1,Th134;
    hence thesis by FUNCT_4:121;
  end;
  suppose
    s.DataLoc(s.a,k1) < 0;
    then IExec(IF,P,s) =s +* Start-At((card I+2),SCMPDS) by Th135;
    hence thesis by FUNCT_4:121;
  end;
end;

theorem
  for s being State of SCMPDS,I being halt-free shiftable parahalting
Program of SCMPDS,a,b being Int_position,k1 being Integer st s.DataLoc(s.a,k1)
  >= 0 holds IExec(if>=0(a,k1,I),P,s).b = IExec(I,P,s).b
proof
  let s be State of SCMPDS,I be halt-free shiftable parahalting Program of
  SCMPDS,a,b be Int_position,k1 be Integer;
  assume
A1: s.DataLoc(s.a,k1) >= 0;
A2: not b in dom Start-At((card I+2),SCMPDS) by SCMPDS_4:59;
  I is_closed_on s,P & I is_halting_on s,P by Th34,Th35;
  then IExec(if>=0(a,k1,I),P,s) = IExec(I,P,s) +* Start-At((card I+2),SCMPDS)
   by A1,Th134;
  hence thesis by A2,FUNCT_4:12;
end;

theorem
  for s being State of SCMPDS,I being Program of SCMPDS,a,b being
Int_position, k1 being Integer st s.DataLoc(s.a,k1) < 0
 holds IExec(if>=0(a,k1,I),P,s).b = s.b
proof
  let s be State of SCMPDS,I be Program of SCMPDS,a,b be Int_position, k1 be
  Integer;
  assume
  s.DataLoc(s.a,k1) < 0;
  then
A1: IExec(if>=0(a,k1,I),P,s) = s +* Start-At((card I+2),SCMPDS) by Th135;
  not b in dom Start-At((card I+2),SCMPDS) by SCMPDS_4:59;
  hence thesis by A1,FUNCT_4:12;
end;

theorem
  for s being State of SCMPDS,I being Program of SCMPDS
   holds I is_closed_on s,P iff I is_closed_on Initialize s,P
proof let s be State of SCMPDS,I being Program of SCMPDS;
 thus I is_closed_on s,P implies I is_closed_on Initialize s,P
  proof assume for k being Element of NAT holds
   IC Comput(P+*stop I,Initialize s,k)
    in dom stop I;
   hence for k being Element of NAT holds
   IC Comput(P +* stop I,
   Initialize Initialize s,k)
    in dom stop I;
  end;
  assume for k being Element of NAT holds
   IC Comput(P +* stop I,
   Initialize Initialize s,k)
    in dom stop I;
  hence for k being Element of NAT holds
   IC Comput(P+*stop I,Initialize s,k)
    in dom stop I;
end;

theorem
  for s being State of SCMPDS,I being Program of SCMPDS
   holds I is_halting_on s,P iff I is_halting_on Initialize s,P
proof let s be State of SCMPDS,I be Program of SCMPDS;
 thus I is_halting_on s,P implies I is_halting_on Initialize s,P
  proof
   assume P+*stop I halts_on Initialize s;
   hence P +* stop I
    halts_on Initialize Initialize s;
  end;
 assume P +* stop I
    halts_on Initialize Initialize s;
 hence P+*stop I halts_on Initialize s;
end;

