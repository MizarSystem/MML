:: The Construction and Computation of Conditional Statements for SCMPDS
::  by JingChao Chen
::
:: Received June 15, 1999
:: Copyright (c) 1999 Association of Mizar Users

environ

 vocabularies NUMBERS, SUBSET_1, SCMPDS_2, AMI_1, FSM_1, INT_1, AMI_2, RELAT_1,
      XBOOLE_0, GRAPHSP, XXREAL_0, CIRCUIT2, ARYTM_3, CARD_1, FUNCT_7, FUNCT_1,
      SCMFSA6A, FUNCT_4, TARSKI, TURING_1, SCMFSA_7, SCMPDS_4, AMISTD_2,
      COMPLEX1, VALUED_1, SCMFSA6B, MSUALG_1, SCMPDS_5, SCMFSA8A, AMI_3,
      ARYTM_1, UNIALG_2, SCMFSA7B, GLIB_000, SCMFSA8B, NAT_1,
      STRUCT_0, SCMPDS_6, ORDINAL1, PARTFUN1, SCMNORM, AFINSQ_1;
 notations TARSKI, XBOOLE_0, SUBSET_1, SETFAM_1, XCMPLX_0, RELAT_1, FUNCT_1,
      CARD_1, PARTFUN1, AFINSQ_1, VALUED_1,
      NUMBERS, COMPLEX1, FUNCT_4, INT_1, NAT_1, STRUCT_0, AMI_1, SCMNORM,
      AMI_2, FUNCT_7, SCMPDS_2, SCMPDS_4, SCMPDS_5, XXREAL_0;
 constructors XXREAL_0, REAL_1, NAT_1, INT_2, SCM_1, SCMPDS_4, SCMPDS_5,
      SCMNORM, SCMPDS_3, AFINSQ_1, VALUED_1;
 registrations SETFAM_1, FUNCT_1, RELSET_1, NUMBERS, XXREAL_0, XREAL_0, NAT_1,
      INT_1, CARD_3, AMI_1, SCMPDS_2, SCMPDS_4, SCMPDS_5, ORDINAL1, XBOOLE_0,
      SCMNORM, VALUED_1, AFINSQ_1;
 requirements NUMERALS, REAL, SUBSET, BOOLE, ARITHM;
 definitions FUNCOP_1, AMI_1, AMI_3, SCMNORM;
 theorems AMI_1, NAT_1, TARSKI, FUNCT_4, FUNCT_1, INT_1, SCMPDS_2, SCMPDS_3,
      ABSVALUE, GRFUNC_1, SCMPDS_4, SCMPDS_5, XBOOLE_0, XBOOLE_1,
      XREAL_1, ORDINAL1, FUNCOP_1, XXREAL_0, FUNCT_7, AMI_2, VALUED_1,
      PARTFUN1, SCMNORM, AFINSQ_1;
 schemes NAT_1;

begin :: Preliminaries

reserve m,n for Element of NAT,
  a for Int_position,
  i,j for Instruction of
  SCMPDS,
  s,s1,s2 for State of SCMPDS,
  k1 for Integer,
  loc for
  Element of NAT,
  I,J,K for Program of SCMPDS;
set A = NAT;
set D = SCM-Data-Loc;

JJ: (Stop SCMPDS). 0 = halt SCMPDS by AFINSQ_1:38;
KK:  0 in dom Stop SCMPDS by SCMNORM:2;

canceled;

theorem Th2:
  for s being State of SCMPDS st ProgramPart s halts_on s for k being Element
  of NAT st LifeSpan(ProgramPart(s),s) <= k
   holds CurInstr(ProgramPart (s), Comput(ProgramPart(s),s,k))
        = halt SCMPDS
proof
  let s be State of SCMPDS;
  assume
  ProgramPart s halts_on s;
  then
A1: CurInstr(ProgramPart s,
  Comput(ProgramPart (s),s,LifeSpan(ProgramPart(s),s)))
 = halt SCMPDS by AMI_1:def 46;
  let k be Element of NAT;
  assume
   LifeSpan(ProgramPart(s),s) <= k;
   then
 Comput(ProgramPart(s),s,LifeSpan(ProgramPart(s),s)) = Comput(ProgramPart(s),s,
k) by A1,AMI_1:52;

  hence thesis by A1;
end;

theorem Th3:
  for s being State of SCMPDS st ProgramPart s halts_on s for k being Element
of NAT st LifeSpan(ProgramPart(s),s) <= k holds IC Comput(ProgramPart(s),s,k) =
IC Comput(ProgramPart(s),s,LifeSpan(ProgramPart s,s))
proof
  let s be State of SCMPDS;
  defpred P[Element of NAT] means LifeSpan(ProgramPart(s),s) <= $1 implies IC
Comput(ProgramPart(s),s,$1)
 = IC Comput(ProgramPart(s),s,LifeSpan(ProgramPart(s),s));
  assume
A1: ProgramPart s halts_on s;
A2: now
    let k be Element of NAT;
    assume
A3: P[k];
    now
      assume
A4:   LifeSpan(ProgramPart(s),s) <= k + 1;
      per cases by A4,XXREAL_0:1;
      suppose
        k + 1 = LifeSpan(ProgramPart(s),s);
        hence IC Comput(ProgramPart(s),s,k+1) = IC Comput(ProgramPart(s),s,
LifeSpan(ProgramPart(s),s));
      end;
      suppose
A5:     k + 1 > LifeSpan(ProgramPart(s),s);
        then
A6:     LifeSpan(ProgramPart(s),s) <= k by NAT_1:13;
        thus IC Comput(ProgramPart(s),s,k+1) =
        IC Following(ProgramPart s,Comput(ProgramPart(
s),s,k))
         by AMI_1:14
          .= IC Exec(halt SCMPDS,Comput(ProgramPart(s),s,k)) by A1,A6,Th2
          .= IC Comput(ProgramPart(s),s,LifeSpan(ProgramPart(s),s)) by A3,A5,
AMI_1:def 8,NAT_1:13;
      end;
    end;
    hence P[k + 1];
  end;
  let k be Element of NAT;
  assume
A7: LifeSpan(ProgramPart(s),s) <= k;
A8: P[0];
  for k being Element of NAT holds P[k] from NAT_1:sch 1(A8,A2);
  hence thesis by A7;
end;

theorem Th4:
  for s1,s2 being State of SCMPDS holds s1,s2 equal_outside NAT iff
  IC s1 = IC s2 & DataPart s1 = DataPart s2
proof
  let s1,s2 be State of SCMPDS;
  thus s1,s2 equal_outside NAT implies IC s1 = IC s2 & DataPart s1 = DataPart
  s2 by AMI_1:121,SCMPDS_4:24;
  assume that
A1: IC s1 = IC s2 and
A2: DataPart s1 = DataPart s2;
  for a being Int_position holds s1.a = s2.a by A2,SCMPDS_4:23;
  hence thesis by A1,SCMPDS_4:11;
end;

theorem
  for s being State of SCMPDS, I being Program of SCMPDS holds
  Initialized s +* Initialized I = s +* Initialized I
proof
  set SA0=Start-At( 0,SCMPDS);
  let s be State of SCMPDS,I be Program of SCMPDS;
A1: dom I misses dom SA0 by SCMPDS_4:54;
  thus Initialized s +* Initialized I = s +* SA0 +* Initialized I by
SCMPDS_5:def 4
    .= s +* SA0 +* (I +* SA0) by SCMPDS_4:def 2
    .= s +* SA0 +* I +* SA0 by FUNCT_4:15
    .= s +* (SA0 +* I) +* SA0 by FUNCT_4:15
    .= s +* (I +* SA0) +* SA0 by A1,FUNCT_4:36
    .= s +* I +* SA0 +* SA0 by FUNCT_4:15
    .= s +* I +* (SA0 +* SA0) by FUNCT_4:15
    .= s +* (I +* SA0) by FUNCT_4:15
    .= s +* Initialized I by SCMPDS_4:def 2;
end;

theorem
  for I being Program of SCMPDS, l being Element of NAT
  holds I c= I +* Start-At(l,SCMPDS)
proof
  let I be Program of SCMPDS,l be Element of NAT;
  reconsider n = l as Element of NAT;
  dom I misses dom Start-At(l,SCMPDS) by SCMPDS_4:54;
  hence thesis by FUNCT_4:33;
end;

theorem Th7:
  for s being State of SCMPDS, l being Element of NAT
  holds DataPart s = DataPart(s +* Start-At(l,SCMPDS))
proof
  let s be State of SCMPDS;
  let l be Element of NAT;
  now
    let x be set;
    assume
    x in dom Start-At(l,SCMPDS);
    then x in {IC SCMPDS} by FUNCOP_1:19;
    hence not x in D by SCMPDS_3:6,TARSKI:def 1;
  end;
  then dom Start-At(l,SCMPDS) misses D by XBOOLE_0:3;
  hence thesis by FUNCT_4:94,SCMPDS_2:100;
end;

theorem Th8:
  for s being State of SCMPDS,I being Program of SCMPDS, l being
Element of NAT holds DataPart s = DataPart(s +* (I +* Start-At(
  l,SCMPDS)))
proof
  let s be State of SCMPDS,I be Program of SCMPDS;
  let l be Element of NAT;
  now
    let x be set;
    assume
    x in dom (I +* Start-At(l,SCMPDS));
    then x in dom I \/ dom Start-At(l,SCMPDS) by FUNCT_4:def 1;
    then x in dom I or x in dom Start-At(l,SCMPDS) by XBOOLE_0:def 3;
    then
A1: x in dom I or x in {IC SCMPDS} by FUNCOP_1:19;
    per cases by A1,TARSKI:def 1;
    suppose
A2:   x in dom I;
      thus not x in D by A2,AMI_2:29,XBOOLE_0:3;
    end;
    suppose
      x = IC SCMPDS;
      hence not x in D by SCMPDS_3:6;
    end;
  end;
  then dom (I +* Start-At(l,SCMPDS)) misses D by XBOOLE_0:3;
  hence thesis by FUNCT_4:94,SCMPDS_2:100;
end;

theorem Th9:
  for s being State of SCMPDS,I being Program of SCMPDS holds
  DataPart s = DataPart(s +* Initialized I)
proof
  let s be State of SCMPDS,I be Program of SCMPDS;
  Initialized I =I +* Start-At( 0,SCMPDS) by SCMPDS_4:def 2;
  hence thesis by Th8;
end;

theorem Th10:
  for s being State of SCMPDS, l being Element of NAT
  holds dom ProgramPart s misses dom Start-At(l,SCMPDS)
proof
  let s be State of SCMPDS,l be Element of NAT;
  now
    let x be set;
    assume
    x in dom ProgramPart s;
    then x is Element of NAT by AMI_1:143;
    then x is Element of NAT;
    then x <> IC SCMPDS by AMI_1:48;
    then not x in {IC SCMPDS} by TARSKI:def 1;
    hence not x in dom Start-At(l,SCMPDS) by FUNCOP_1:19;
  end;
  hence thesis by XBOOLE_0:3;
end;

theorem
  for s being State of SCMPDS, I,J being Program of SCMPDS, l being
  Element of NAT holds s +* (I +* Start-At(l,SCMPDS)),
  s +* (J +*
  Start-At(l,SCMPDS)) equal_outside NAT
proof
  let s be State of SCMPDS,I,J be Program of SCMPDS;
  let l be Element of NAT;
A1: now
    let a;
A2: not a in dom (I +* Start-At(l,SCMPDS)) by SCMPDS_4:61;
    not a in dom (J +* Start-At(l,SCMPDS)) by SCMPDS_4:61;
    hence (s +* (J +* Start-At(l,SCMPDS))).a = s.a by FUNCT_4:12
      .= (s +* (I +* Start-At(l,SCMPDS))).a by A2,FUNCT_4:12;
  end;
  IC (s +* (J +* Start-At(l,SCMPDS))) = IC (s +* J +* Start-At(l,SCMPDS))
  by FUNCT_4:15
    .= l by FUNCT_4:121
    .= IC (s +* I +* Start-At(l,SCMPDS)) by FUNCT_4:121
    .= IC (s +* (I +* Start-At(l,SCMPDS))) by FUNCT_4:15;
  hence thesis by A1,SCMPDS_4:11;
end;

theorem Th12:
  for s1,s2 be State of SCMPDS,I,J be Program of SCMPDS holds
  DataPart s1 = DataPart s2 implies s1 +* Initialized I, s2 +* Initialized J
  equal_outside NAT
proof
  let s1,s2 be State of SCMPDS,I,J be Program of SCMPDS;
  assume
A1: DataPart s1 = DataPart s2;
  set II=Initialized I, S1 = s1 +* II, IJ=Initialized J, S2 = s2 +* IJ;
A2: IC S1 =  0 & IC S2 =  0 by FUNCT_4:26,SCMPDS_5:18;
  DataPart S1 = DataPart s1 by Th9
    .= DataPart S2 by A1,Th9;
  hence thesis by A2,Th4;
end;

canceled;

theorem Th14:
  for s being State of SCMPDS, l1,l2 being Element of NAT
  holds s +* Start-At(l1,SCMPDS) +* Start-At(l2,SCMPDS) =
  s +* Start-At(l2,SCMPDS)
proof
  let s be State of SCMPDS;
  let l1,l2 be Element of NAT;
A1: dom Start-At(l1,SCMPDS) = {IC SCMPDS} by FUNCOP_1:19
    .= dom Start-At(l2,SCMPDS) by FUNCOP_1:19;
  thus s +* Start-At(l1,SCMPDS) +* Start-At(l2,SCMPDS) =
  s +* (Start-At(l1,SCMPDS) +* Start-At(l2,SCMPDS)) by FUNCT_4:15
    .= s +* Start-At(l2,SCMPDS) by A1,FUNCT_4:20;
end;

theorem Th15:
  card (i ';' I)= card I + 1
proof
  thus card (i ';' I) = card (Load i ';' I) by SCMPDS_4:def 4
    .=card (Load i) + card I by SCMPDS_4:45
    .=card I+1 by SCMPDS_5:6;
end;

theorem Th16:
  (i ';' I). 0=i
proof
  i ';' I=Load i ';' I &  0 in dom Load i by SCMPDS_4:def 4,SCMPDS_5:2;
  hence (i ';' I). 0 =(Load i). 0 by SCMPDS_4:37
    .=i by SCMPDS_5:4;
end;

theorem Th17:
  I c= Initialized stop I
proof
  set pI=stop I;
  pI= I ';' Stop SCMPDS by SCMPDS_4:def 7;
  then
A1: I c= pI by SCMPDS_4:40;
  pI c= Initialized pI by SCMPDS_4:9;
  hence thesis by A1,XBOOLE_1:1;
end;

theorem Th18:
  loc in dom I implies loc in dom (stop I)
proof
  dom I c= dom (I ';' Stop SCMPDS) by SCMPDS_4:39;
  then
A1: dom I c= dom stop I by SCMPDS_4:def 7;
  assume
  loc in dom I;
  hence thesis by A1;
end;

theorem Th19:
  loc in dom I implies (stop I).loc=I.loc
proof
  assume
A1: loc in dom I;
  thus (stop I).loc =(I ';' Stop SCMPDS).loc by SCMPDS_4:def 7
    .=I.loc by A1,SCMPDS_4:37;
end;

theorem Th20:
  loc in dom I implies (Initialized stop I).loc=I.loc
proof
  assume
A1: loc in dom I;
  then loc in dom stop (I) by Th18;
  hence (Initialized stop I).loc=(stop I).loc by SCMPDS_4:33
    .=I.loc by A1,Th19;
end;

theorem
  IC (s+* Initialized I)= 0 by FUNCT_4:26,SCMPDS_5:18;

theorem Th22:
  CurInstr(ProgramPart(s+* Initialized stop(i ';' I)),
  s+* Initialized stop(i ';' I)) = i
proof
  set iI=i ';' I, IsiI=Initialized stop iI, s3=s+*IsiI;
A1:  0 in dom Load i by SCMPDS_5:2;
  card iI=card I +1 by Th15;
  then
A2:  0 in dom iI by AFINSQ_1:70;
Y:  (ProgramPart (s+* Initialized stop(i ';' I)))/.
IC (s+* Initialized stop(i ';' I))
 = (s+* Initialized stop(i ';' I)).IC (s+* Initialized stop(i ';' I))
 by AMI_1:150;
  iI c= IsiI by Th17;
  then dom iI c= dom IsiI by GRFUNC_1:8;
  then s3. 0 = IsiI. 0 by A2,FUNCT_4:14
    .= iI. 0 by A2,Th20
    .=(Load i ';' I). 0 by SCMPDS_4:def 4
    .=(Load i). 0 by A1,SCMPDS_4:37
    .=i by SCMPDS_5:4;
  hence thesis by Y,FUNCT_4:26,SCMPDS_5:18;
end;

theorem Th23:
  for s being State of SCMPDS,m1,m2 being Element of NAT st IC s=
   m1 holds ICplusConst(s,m2)= (m1+m2)
proof
  let s be State of SCMPDS,m1,m2 be Element of NAT;
A1: ex m st m = IC s & ICplusConst(s,m2) = abs(m+m2) by SCMPDS_2:def 20;
  assume
  IC s= m1;
  hence thesis by A1,ABSVALUE:def 1;
end;

theorem Th24:
  for I,J being Program of SCMPDS holds Shift(stop J,card I) c=
  stop(I ';' J)
proof
  let I,J be Program of SCMPDS;
  stop(I ';' J) =I ';' J ';' Stop SCMPDS by SCMPDS_4:def 7
    .=I ';' (J ';' Stop SCMPDS) by SCMPDS_4:46
    .=I ';' (stop J) by SCMPDS_4:def 7;
  then stop(I ';' J) = I +* Shift(stop J, card I) by SCMPDS_4:def 3;
  hence thesis by FUNCT_4:26;
end;

theorem Th25:
  (card I) in dom (stop I) & (stop I).(card I) = halt
  SCMPDS
proof
  set SS=Stop SCMPDS;
  set pI=stop I;
  card pI=card I+1 by SCMPDS_5:7;
  then card I <card pI by XREAL_1:31;
  hence (card I) in dom pI by AFINSQ_1:70;
  pI=I ';' SS by SCMPDS_4:def 7;
  then pI.(0+card I) =halt SCMPDS by JJ,KK,SCMPDS_4:38;
  hence thesis;
end;

theorem Th26:
  for x,l being Element of NAT holds IExec(J,s).x
  = (IExec(I,s) +* Start-At(l,SCMPDS)).x
proof
  let x,l be Element of NAT;
  dom Start-At(l,SCMPDS) = {IC SCMPDS} & x <> IC SCMPDS
  by AMI_1:48,FUNCOP_1:19;
  then
A1: not x in dom Start-At(l,SCMPDS) by TARSKI:def 1;
A2: dom ProgramPart s = A & x in NAT by AMI_1:143;
  thus IExec(J,s).x = (Result(ProgramPart(s+*Initialized stop J),s+*Initialized
stop J) +* s | A).x by SCMPDS_4:def 8
    .=(s | A).x by A2,FUNCT_4:14
    .= (Result(ProgramPart(s+*Initialized stop I),s+*Initialized stop I) +* s |
A).x by A2,FUNCT_4:14
    .= IExec(I,s).x by SCMPDS_4:def 8
    .= (IExec(I,s) +* Start-At(l,SCMPDS)).x by A1,FUNCT_4:12;
end;

theorem Th27:
  for x,l being Element of NAT holds IExec(I,s).x
  = (s +* Start-At(l,SCMPDS)).x
proof
  let x,l be Element of NAT;
  dom Start-At(l,SCMPDS) = {IC SCMPDS} & x <> IC SCMPDS
  by AMI_1:48,FUNCOP_1:19;
  then
A2: not x in dom Start-At(l,SCMPDS) by TARSKI:def 1;
A3: dom ProgramPart s = A by AMI_1:143;
  thus IExec(I,s).x = (Result(ProgramPart(s+*Initialized stop I),s+*Initialized
stop I) +* s | A).x by SCMPDS_4:def 8
    .=(s | A).x by A3,FUNCT_4:14
    .= s.x by FUNCT_1:72
    .= (s+* Start-At(l,SCMPDS)).x by A2,FUNCT_4:12;
end;

theorem
  for s being State of SCMPDS, i being No-StopCode parahalting
Instruction of SCMPDS,J being parahalting shiftable Program of SCMPDS, a being
  Int_position holds IExec(i ';' J,s).a = IExec(J,Exec(i,Initialized s)).a
proof
  let s be State of SCMPDS,i be No-StopCode parahalting Instruction of SCMPDS,
  J be parahalting shiftable Program of SCMPDS, a be Int_position;
  thus IExec(i ';' J,s).a = IExec(Load i ';' J,s).a by SCMPDS_4:def 4
    .= IExec(J,IExec(Load i,s)).a by SCMPDS_5:39
    .= IExec(J,Exec(i,Initialized s)).a by SCMPDS_5:45;
end;

theorem Th29:
  for a being Int_position,k1,k2 being Integer holds (a,k1)
  <>0_goto k2 <> halt SCMPDS
proof
  let a be Int_position,k1,k2 be Integer;
  InsCode ((a,k1)<>0_goto k2) = 4 by SCMPDS_2:25;
  hence thesis by SCMPDS_2:21,93;
end;

theorem Th30:
  for a being Int_position,k1,k2 being Integer holds (a,k1)
  <=0_goto k2 <> halt SCMPDS
proof
  let a be Int_position,k1,k2 be Integer;
  InsCode ((a,k1)<=0_goto k2) = 5 by SCMPDS_2:26;
  hence thesis by SCMPDS_2:21,93;
end;

theorem Th31:
  for a being Int_position,k1,k2 being Integer holds (a,k1)
  >=0_goto k2 <> halt SCMPDS
proof
  let a be Int_position,k1,k2 be Integer;
  InsCode ((a,k1)>=0_goto k2) = 6 by SCMPDS_2:27;
  hence thesis by SCMPDS_2:21,93;
end;

definition
  let k1;
  func Goto k1 -> Program of SCMPDS equals
  Load (goto k1);
  coherence;
end;

registration
  let n be Element of NAT;
  cluster goto (n+1) -> No-StopCode;
  correctness by SCMPDS_5:25;
  cluster goto -(n+1) -> No-StopCode;
  correctness
  proof
    -(n+1) <> 0;
    hence thesis by SCMPDS_5:25;
  end;
end;

registration
  let n be Element of NAT;
  cluster Goto (n+1) -> halt-free;
  correctness;
  cluster Goto -(n+1) -> halt-free;
  correctness;
end;

canceled;

theorem Th33:
   0 in dom Goto k1 & (Goto k1). 0 = goto k1
proof
  Goto k1 = <%goto k1%> by SCMPDS_4:def 1;
  hence thesis by AFINSQ_1:38,69;
end;

begin :: The predicates of is_closed_on and is_halting_on

definition
  let I be Program of SCMPDS;
  let s be State of SCMPDS;
  pred I is_closed_on s means
  :Def2:
  for k being Element of NAT holds IC
  Comput(ProgramPart(s+*Initialized stop I),s+*Initialized stop I,k) in dom
stop I;
  pred I is_halting_on s means
  :Def3:
  ProgramPart(s+*Initialized stop I) halts_on s+*Initialized stop I;
end;

theorem Th34:
  for I being Program of SCMPDS holds I is paraclosed iff for s
  being State of SCMPDS holds I is_closed_on s
proof
  let I be Program of SCMPDS;
  set IsI=Initialized stop(I);
  hereby
    assume
A1: I is paraclosed;
    let s be State of SCMPDS;
    IsI c= s +* IsI by FUNCT_4:26;
    then for n holds IC Comput(ProgramPart(s+*IsI),s+*IsI,n) in dom stop I by
A1,SCMPDS_4:def 9;
    hence I is_closed_on s by Def2;
  end;
  assume
A2: for s being State of SCMPDS holds I is_closed_on s;
  now
    let s be State of SCMPDS;
    let k be Element of NAT;
    assume
    IsI c= s;
    then
A3: s = s +* IsI by FUNCT_4:79;
    I is_closed_on s by A2;
    hence IC Comput(ProgramPart(s),s,k) in dom stop I by A3,Def2;
  end;
  hence thesis by SCMPDS_4:def 9;
end;

theorem Th35:
  for I being Program of SCMPDS holds I is parahalting iff for s
  being State of SCMPDS holds I is_halting_on s
proof
  let I be Program of SCMPDS;
  set IsI=Initialized stop(I);
  hereby
    assume
A1: I is parahalting;
    let s be State of SCMPDS;
    ProgramPart(s+*IsI) halts_on s+*IsI by A1,FUNCT_4:26,SCMPDS_4:63;
    hence I is_halting_on s by Def3;
  end;
  assume
A2: for s being State of SCMPDS holds I is_halting_on s;
  now
    let s be State of SCMPDS;
    assume
    IsI c= s;
    then
A3: s = s +* IsI by FUNCT_4:79;
    I is_halting_on s by A2;
    hence ProgramPart s halts_on s by A3,Def3;
  end;
  then IsI is halting by AMI_1:def 26;
  hence thesis by SCMPDS_4:def 10;
end;

theorem Th36:
  for s1,s2 being State of SCMPDS, I being Program of SCMPDS st
  DataPart s1 = DataPart s2 holds I is_closed_on s1 implies I is_closed_on s2
proof
  let s1,s2 be State of SCMPDS,I be Program of SCMPDS;
  set pI=stop I, IsI=Initialized pI, S1 = s1 +* IsI, S2 = s2 +* IsI;
  assume
A1: DataPart s1 = DataPart s2;
A2: Comput(ProgramPart(S2),S2,0) = s2 +* IsI by AMI_1:13;
A3: Comput(ProgramPart(S1),S1,0) = s1 +* IsI by AMI_1:13;
  then
A4: DataPart Comput(ProgramPart(S1),S1,0) = DataPart s1 by Th9
    .= DataPart Comput(ProgramPart(S2),S2,0) by A1,A2,Th9;
  defpred P[Element of NAT] means IC Comput(ProgramPart(S1),S1,$1) = IC Comput(
ProgramPart(S2),S2,$1
  ) & CurInstr(ProgramPart Comput(ProgramPart(S1),S1,$1),Comput(ProgramPart(S1)
,S1,$1))
   = CurInstr(ProgramPart Comput(ProgramPart(S2),S2,$1),Comput(ProgramPart(S2),
S2,$1)) & DataPart
  Comput(ProgramPart(S1),S1,$1) = DataPart Comput(ProgramPart(S2),S2,$1);
A5:  0 in dom pI by SCMPDS_4:75;
A6: pI c= IsI by SCMPDS_4:9;
  then
A7: dom pI c= dom IsI by GRFUNC_1:8;
  assume
A8: I is_closed_on s1;
A9: now
    let k be Element of NAT;
T: ProgramPart S2 = ProgramPart Comput(ProgramPart(
S2),S2,k)
by AMI_1:123;
A10: Comput(ProgramPart(S2),S2,k+1) = Following(ProgramPart S2,
Comput(ProgramPart(S2),S2,k)) by AMI_1:14
      .= Exec(CurInstr(ProgramPart Comput(ProgramPart(S2),S2,k),Comput(
ProgramPart(S2),S2,k)),
      Comput(ProgramPart(S2),S2,k)) by T;
    assume
A11: P[k];
    then
A12: for a holds Comput(ProgramPart(S1),S1,k).a = Comput(ProgramPart(S2),S2,k).
a by SCMPDS_4:23;
    IsI c= s2 +* IsI by FUNCT_4:26;
    then pI c= s2 +* IsI by A6,XBOOLE_1:1;
    then
A13: pI c= Comput(ProgramPart(S2),S2,k+1) by AMI_1:81;
A14: IC Comput(ProgramPart(S1),S1,k+1) in dom pI by A8,Def2;
T: ProgramPart S1 = ProgramPart Comput(ProgramPart(
S1),S1,k)
by AMI_1:123;
A15: Comput(ProgramPart(S1),S1,k+1) = Following(ProgramPart S1,
Comput(ProgramPart(S1),S1,k)) by AMI_1:14
      .= Exec(CurInstr(ProgramPart Comput(ProgramPart(S1),S1,k),Comput(
ProgramPart(S1),S1,k)),
      Comput(ProgramPart(S1),S1,k)) by T;
    then
A16: Comput(ProgramPart(S1),S1,k+1),Comput(ProgramPart(S2),S2,k+1)
equal_outside NAT by A11,A12,A10,SCMPDS_4:11,15;
    Comput(ProgramPart(S1),S1,k),Comput(ProgramPart(S2),S2,k) equal_outside A
by A11,A12,SCMPDS_4:11;
    then
A17: IC Comput(ProgramPart(S1),S1,k+1) = IC Comput(ProgramPart(S2),S2,k+1) by
A11,A15,A10,AMI_1:121,SCMPDS_4:15;
Y:  (ProgramPart Comput(ProgramPart(S1),S1,k+1))/.IC Comput(ProgramPart(S1),S1,
k+1)
 = Comput(ProgramPart(S1),S1,k+1).IC Comput(ProgramPart(S1),S1,k+1) by
AMI_1:150;
Z:  (ProgramPart Comput(ProgramPart(S2),S2,k+1))/.IC Comput(ProgramPart(S2),S2,
k+1)
 = Comput(ProgramPart(S2),S2,k+1).IC Comput(ProgramPart(S2),S2,k+1) by
AMI_1:150;
    IsI c= s1 +* IsI by FUNCT_4:26;
    then pI c= s1 +* IsI by A6,XBOOLE_1:1;
    then pI c= Comput(ProgramPart(S1),S1,k+1) by AMI_1:81;
    then CurInstr(ProgramPart Comput(ProgramPart(S1),S1,k+1),Comput(ProgramPart
(S1),S1,k+1))
     = pI.IC Comput(ProgramPart(S1),S1,k+1) by A14,Y,GRFUNC_1:8
      .= CurInstr(ProgramPart Comput(ProgramPart(S2),S2,k+1),Comput(ProgramPart
(S2),S2,k+1))
       by A13,A17,A14,Z,GRFUNC_1:8;
    hence P[k+1] by A16,AMI_1:121,SCMPDS_4:24;
  end;
A18: IC SCMPDS in dom IsI by SCMPDS_4:7;
  then
A19: IC Comput(ProgramPart(S2),S2,0) = IsI.IC SCMPDS by A2,FUNCT_4:14
    .=  0 by SCMPDS_4:29;
Y:  (ProgramPart Comput(ProgramPart(S1),S1,0))/.IC Comput(ProgramPart(S1),S1,0)
 = Comput(ProgramPart(S1),S1,0).IC Comput(ProgramPart(S1),S1,0) by AMI_1:150;
Z:  (ProgramPart Comput(ProgramPart(S2),S2,0))/.IC Comput(ProgramPart(S2),S2,0)
 = Comput(ProgramPart(S2),S2,0).IC Comput(ProgramPart(S2),S2,0) by AMI_1:150;
A20: IC Comput(ProgramPart(S1),S1,0) = IsI.IC SCMPDS by A18,A3,FUNCT_4:14
    .=  0 by SCMPDS_4:29;
  then CurInstr(ProgramPart Comput(ProgramPart(S1),S1,0),Comput(ProgramPart(S1)
,S1,0)) = IsI. 0
   by A3,A7,A5,Y,FUNCT_4:14
    .= CurInstr(ProgramPart Comput(ProgramPart(S2),S2,0),Comput(ProgramPart(S2)
,S2,0))
     by A2,A19,A7,A5,Z,FUNCT_4:14;
  then
A21: P[0] by A20,A19,A4;
  now
    let k be Element of NAT;
A22: for k being Element of NAT holds P[k] from NAT_1:sch 1(A21,A9);
    IC Comput(ProgramPart(S1),S1,k) in dom pI by A8,Def2;
    hence IC Comput(ProgramPart(S2),S2,k) in dom pI by A22;
  end;
  hence thesis by Def2;
end;

theorem
  for s1,s2 being State of SCMPDS,I being Program of SCMPDS st DataPart
  s1 = DataPart s2 holds I is_closed_on s1 & I is_halting_on s1 implies I
  is_closed_on s2 & I is_halting_on s2
proof
  let s1,s2 be State of SCMPDS,I be Program of SCMPDS;
  set pI=stop I, IsI=Initialized pI, S1 = s1 +* IsI, S2 = s2 +* IsI;
  defpred P[Element of NAT] means IC Comput(ProgramPart(S1),S1,$1) = IC Comput(
ProgramPart(S2),S2,$1
  ) & CurInstr(ProgramPart (S1),Comput(ProgramPart(S1),S1,$1))
   = CurInstr(ProgramPart (S2),Comput(ProgramPart(S2),S2,$1))
    & DataPart
  Comput(ProgramPart(S1),S1,$1) = DataPart Comput(ProgramPart(S2),S2,$1);
A1: Comput(ProgramPart(S1),S1,0) = s1 +* IsI by AMI_1:13;
A2: Comput(ProgramPart(S2),S2,0) = s2 +* IsI by AMI_1:13;
  assume
  DataPart s1 = DataPart s2;
  then
A3: Comput(ProgramPart(S1),S1,0),Comput(ProgramPart(S2),S2,0) equal_outside A
by A1,A2,Th12;
A4:  0 in dom pI by SCMPDS_4:75;
A5: pI c= IsI by SCMPDS_4:9;
  then
A6: dom pI c= dom IsI by GRFUNC_1:8;
  assume
A7: I is_closed_on s1;
A8: now
    let k be Element of NAT;
T: ProgramPart S2 = ProgramPart Comput(ProgramPart(S2),S2,k)
by AMI_1:123;
A9: Comput(ProgramPart(S2),S2,k+1) = Following(ProgramPart S2,
Comput(ProgramPart(S2),S2,k)) by AMI_1:14
      .= Exec(CurInstr(ProgramPart Comput(ProgramPart(S2),S2,k),Comput(
ProgramPart(S2),S2,k)),
      Comput(ProgramPart(S2),S2,k)) by T;
    assume
A10: P[k];
    then for a holds Comput(ProgramPart(S1),S1,k).a = Comput(ProgramPart(S2),S2
,k).a by SCMPDS_4:23;
    then
A11: Comput(ProgramPart(S1),S1,k),Comput(ProgramPart(S2),S2,k) equal_outside A
by A10,SCMPDS_4:11;
    IsI c= s2 +* IsI by FUNCT_4:26;
    then pI c= s2 +* IsI by A5,XBOOLE_1:1;
    then
A12: pI c= Comput(ProgramPart(S2),S2,k+1) by AMI_1:81;
A13: IC Comput(ProgramPart(S1),S1,k+1) in dom pI by A7,Def2;
S: ProgramPart S1 = ProgramPart Comput(ProgramPart(S1),S1,k)
by AMI_1:123;
A14: Comput(ProgramPart(S1),S1,k+1) = Following(ProgramPart S1,
Comput(ProgramPart(S1),S1,k))
 by AMI_1:14
      .= Exec(CurInstr(ProgramPart (S1),Comput(ProgramPart(S1),S1,k)),
      Comput(ProgramPart(S1),S1,k));
    then
A15: IC Comput(ProgramPart(S1),S1,k+1) = IC Comput(ProgramPart(S2),S2,k+1) by
A10,A11,A9,T,S,AMI_1:121,SCMPDS_4:15;
Y:  (ProgramPart Comput(ProgramPart(S1),S1,k+1))/.IC Comput(ProgramPart(S1),S1,
k+1)
 = Comput(ProgramPart(S1),S1,k+1).IC Comput(ProgramPart(S1),S1,k+1) by
AMI_1:150;
Z:  (ProgramPart Comput(ProgramPart(S2),S2,k+1))/.IC Comput(ProgramPart(S2),S2,
k+1)
 = Comput(ProgramPart(S2),S2,k+1).IC Comput(ProgramPart(S2),S2,k+1) by
AMI_1:150;
TX1: ProgramPart S1 = ProgramPart Comput(ProgramPart(S1),S1,k+1)
by AMI_1:123;
TX2: ProgramPart S2 = ProgramPart Comput(ProgramPart(S2),S2,k+1)
by AMI_1:123;
    IsI c= s1 +* IsI by FUNCT_4:26;
    then pI c= s1 +* IsI by A5,XBOOLE_1:1;
    then pI c= Comput(ProgramPart(S1),S1,k+1) by AMI_1:81;
    then CurInstr(ProgramPart S1,Comput(ProgramPart(S1),S1,k+1))
     = pI.IC Comput(ProgramPart(S1),S1,k+1) by A13,Y,TX1,GRFUNC_1:8
      .= CurInstr(ProgramPart S2,Comput(ProgramPart(S2),S2,k+1))
       by A12,A15,A13,Z,TX2,GRFUNC_1:8;
    hence P[k+1] by A10,A11,A14,A9,A15,TX1,TX2,S,T,SCMPDS_4:15,24;
  end;
A16: IC SCMPDS in dom IsI by SCMPDS_4:7;
  then
A17: IC Comput(ProgramPart(S2),S2,0) = IsI.IC SCMPDS by A2,FUNCT_4:14
    .=  0 by SCMPDS_4:29;
  assume
  I is_halting_on s1;
  then ProgramPart(s1+*IsI) halts_on s1+*IsI by Def3;
  then consider m such that
A18: CurInstr(ProgramPart S1,Comput(ProgramPart(S1),S1,m))
 = halt SCMPDS by AMI_1:146;
Y:  (ProgramPart Comput(ProgramPart(S1),S1,0))/.IC Comput(ProgramPart(S1),S1,0)
 = Comput(ProgramPart(S1),S1,0).IC Comput(ProgramPart(S1),S1,0) by AMI_1:150;
Z:  (ProgramPart Comput(ProgramPart(S2),S2,0))/.IC Comput(ProgramPart(S2),S2,0)
 = Comput(ProgramPart(S2),S2,0).IC Comput(ProgramPart(S2),S2,0) by AMI_1:150;
A19: IC Comput(ProgramPart(S1),S1,0) = IsI.IC SCMPDS by A16,A1,FUNCT_4:14
    .=  0 by SCMPDS_4:29;
  then CurInstr(ProgramPart S1,Comput(ProgramPart(S1),S1,0))
   = IsI. 0 by A1,A6,A4,Y,FUNCT_4:14
    .= CurInstr(ProgramPart S2,Comput(ProgramPart(S2),S2,0))
     by A2,A17,A6,A4,Z,FUNCT_4:14;
  then
A20: P[0] by A19,A17,A3,SCMPDS_4:24;
  now
    let k be Element of NAT;
A21: for k being Element of NAT holds P[k] from NAT_1:sch 1(A20,A8);
    IC Comput(ProgramPart(S1),S1,k) in dom pI by A7,Def2;
    hence IC Comput(ProgramPart(S2),S2,k) in dom pI by A21;
  end;
  hence I is_closed_on s2 by Def2;
  for k being Element of NAT holds P[k] from NAT_1:sch 1(A20,A8);
  then CurInstr(ProgramPart S2,Comput(ProgramPart(S2),S2,m))
   = halt SCMPDS by A18;
  then ProgramPart(s2+*IsI) halts_on s2+*IsI by AMI_1:146;
  hence thesis by Def3;
end;

theorem Th38:
  for s being State of SCMPDS, I,J being Program of SCMPDS holds I
  is_closed_on s iff I is_closed_on s +* Initialized J
proof
  let s be State of SCMPDS,I,J be Program of SCMPDS;
  DataPart s = DataPart(s +* Initialized J) by Th9;
  hence thesis by Th36;
end;

theorem Th39:
  for I,J being Program of SCMPDS,s being State of SCMPDS st I
  is_closed_on s & I is_halting_on s holds (for k being Element of NAT st k <=
LifeSpan(ProgramPart(s +* Initialized stop I),s +* Initialized stop I) holds IC
Comput(ProgramPart( (s +*
Initialized stop
  I)), (s +* Initialized stop
  I),k) = IC Comput(ProgramPart( (s +* Initialized stop (I ';' J))), (s +*
Initialized stop (I ';' J)),k)) & DataPart
Comput(ProgramPart( (s +* Initialized stop I)), (s +* Initialized stop I), (
LifeSpan(ProgramPart(s +* Initialized stop I),s +* Initialized stop I))) =
  DataPart Comput(ProgramPart( (s +* Initialized stop (I ';' J))), (s +*
Initialized stop (I ';' J)), (LifeSpan(ProgramPart(s +*
  Initialized stop I),s +*
  Initialized stop I)))
proof
  let I,J be Program of SCMPDS,s be State of SCMPDS;
  assume
A1: I is_closed_on s;
  set pI=stop I, IsI=Initialized pI, pIJ=stop (I ';' J), IsJ=Initialized pIJ,
  s1=s +* IsI, IL=NAT;
A2: s1 +* IsJ = s1 +* pIJ by FUNCT_4:26,SCMPDS_4:34;
  defpred X[Element of NAT] means $1 <= LifeSpan(ProgramPart(s1),s1) implies
Comput(ProgramPart(
s1), s1,$1
  ), Comput(ProgramPart( (s1+*IsJ)), (s1+*IsJ),$1) equal_outside IL;
  assume
  I is_halting_on s;
  then
A3: ProgramPart s1 halts_on s1 by Def3;
A4: IsI=pI +* Start-At( 0,SCMPDS) & IsI c= s1
by FUNCT_4:26,SCMPDS_4:def 2;
A5: for m st X[m] holds X[m+1]
  proof
    set JS=J ';' Stop SCMPDS;
    set S1 = s1, S2 = s1 +* IsJ;
    let m;
    assume
A6: m <= LifeSpan(ProgramPart(s1),s1) implies Comput(ProgramPart( s1), s1,m),
Comput(ProgramPart
( (s1+*IsJ
    )), (s1+*IsJ
    ),m) equal_outside IL;
A7: pIJ c= Comput(ProgramPart(S2),S2,m) by A2,AMI_1:81,FUNCT_4:26;
T: ProgramPart S1 = ProgramPart Comput(ProgramPart(S1),S1,m)
by AMI_1:123;
A8: Comput(ProgramPart(S1),S1,m+1) =
Following(ProgramPart S1,Comput(ProgramPart(S1),S1,m)
)
 by AMI_1:14
      .= Exec(CurInstr(ProgramPart Comput(ProgramPart(S1),S1,m),Comput(
ProgramPart(S1),S1,m)),
      Comput(ProgramPart(S1),S1,m)) by T;
A9: pIJ =I ';' J ';' Stop SCMPDS by SCMPDS_4:def 7
      .=I ';' JS by SCMPDS_4:46;
    dom(I ';' JS) = dom (I +* Shift(JS, card I)) by SCMPDS_4:def 3
      .= dom I \/ dom Shift(JS, card I) by FUNCT_4:def 1;
    then
A10: dom I c= dom(I ';' JS) by XBOOLE_1:7;
T: ProgramPart S2 = ProgramPart Comput(ProgramPart(S2),S2,m)
by AMI_1:123;
A11: Comput(ProgramPart(S2),S2,m+1) =
Following(ProgramPart S2,Comput(ProgramPart(S2),S2,m)
)
 by AMI_1:14
      .= Exec(CurInstr(ProgramPart Comput(ProgramPart(S2),S2,m),Comput(
ProgramPart(S2),S2,m)),
      Comput(ProgramPart(S2),S2,m)) by T;
A12: IC Comput(ProgramPart(S1),S1,m) in dom pI by A1,Def2;
Y:  (ProgramPart Comput(ProgramPart(S1),S1,m))/.IC Comput(ProgramPart(S1),S1,m)
 = Comput(ProgramPart(S1),S1,m).IC Comput(ProgramPart(S1),S1,m) by AMI_1:150;
TX1: ProgramPart S1 = ProgramPart Comput(ProgramPart(S1),S1,m)
by AMI_1:123;
    dom pI misses dom Start-At( 0,SCMPDS) by SCMPDS_4:54;
    then pI c= pI +* Start-At( 0,SCMPDS) by FUNCT_4:33;
    then pI c= s1 by A4,XBOOLE_1:1;
    then pI c= Comput(ProgramPart(S1),S1,m) by AMI_1:81;
    then
A13: CurInstr(ProgramPart S1,Comput(ProgramPart(S1),
S1,m))
 = pI.IC (Comput(ProgramPart(S1),S1,m)) by A12,Y,TX1,GRFUNC_1:8;
    assume
A14: m+1 <= LifeSpan(ProgramPart(s1),s1);
    then m < LifeSpan(ProgramPart(s1),s1) by NAT_1:13;
    then pI.IC(Comput(ProgramPart(S1),S1,m)) <> halt SCMPDS by A3,A13,
AMI_1:def 46;
    then
A15: IC Comput(ProgramPart(S1),S1,m) in dom I by A12,SCMPDS_5:3;
Y:  (ProgramPart Comput(ProgramPart(S2),S2,m))/.IC Comput(ProgramPart(S2),S2,m)
 = Comput(ProgramPart(S2),S2,m).IC Comput(ProgramPart(S2),S2,m) by AMI_1:150;
    CurInstr(ProgramPart Comput(ProgramPart(S1),S1,m),Comput(ProgramPart(S1),S1
,m))
    = (I ';' Stop SCMPDS).IC (Comput(ProgramPart(S1),S1,m
    )) by A13,TX1,SCMPDS_4:def 7
      .=I.IC (Comput(ProgramPart(S1),S1,m)) by A15,SCMPDS_4:37
      .=pIJ.IC(Comput(ProgramPart(S1),S1,m)) by A15,A9,SCMPDS_4:37
      .=(Comput(ProgramPart(S2),S2,m)).IC(Comput(ProgramPart(S1),S1,m)) by A7
,A15,A9,A10,GRFUNC_1:8
      .= CurInstr(ProgramPart Comput(ProgramPart(S2),S2,m),Comput(ProgramPart(
S2),S2,m))
       by A6,A14,Y,AMI_1:121,NAT_1:13;
    hence thesis by A6,A14,A8,A11,NAT_1:13,SCMPDS_4:15;
  end;
  Comput(ProgramPart( s1), s1,0) = s1 & Comput(ProgramPart( (s1+*IsJ)), (s1+*
IsJ),0) = s1+*IsJ by AMI_1:13;
  then
A16: X[0] by A2,FUNCT_7:132;
A17: for m holds X[m] from NAT_1:sch 1(A16,A5);
A18: s1+*IsJ=s +* (IsI +* IsJ) by FUNCT_4:15
    .=s+*IsJ by SCMPDS_5:17;
  hence
  for k be Element of NAT st k <= LifeSpan(ProgramPart(s1),s1) holds IC Comput(
ProgramPart( s1),
s1,k)
  =IC Comput(ProgramPart( (s +* IsJ)), (s +* IsJ),k) by A17,AMI_1:121;
  thus thesis by A18,A17,SCMPDS_4:24;
  set m=LifeSpan(ProgramPart(s1),s1);
end;

theorem Th40:
  for I being Program of SCMPDS,k be Element of NAT st I
  is_closed_on s & I is_halting_on s & k < LifeSpan(ProgramPart(s +*
Initialized stop(I)),s +* Initialized stop(I))
  holds IC Comput(ProgramPart( (s +* Initialized stop(I))), (s +* Initialized
stop(I)),k) in dom I
proof
  let I be Program of SCMPDS,k be Element of NAT;
  set IsI=Initialized stop(I), ss= s +* IsI, m=LifeSpan(ProgramPart(ss),ss), Sp
=Stop SCMPDS;
  assume that
A1: I is_closed_on s and
A2: I is_halting_on s and
A3: k < m;
  set Sk= Comput(ProgramPart( ss), ss,k), Ik=IC Sk;
A4: Ik in dom stop(I) by A1,Def2;
  reconsider n = Ik as Element of NAT;
A5: stop I = I ';' Sp by SCMPDS_4:def 7;
  IsI c= ss & stop I c= IsI by FUNCT_4:26,SCMPDS_4:9;
  then
A6: stop I c= ss by XBOOLE_1:1;
A7: ProgramPart ss halts_on ss by A2,Def3;
A8: now
Y:  (ProgramPart Sk)/.IC Sk
 = Sk.IC Sk by AMI_1:150;
TX: ProgramPart ss = ProgramPart Sk
by AMI_1:123;
    assume
A9: n = card I;
    CurInstr(ProgramPart Sk,Sk) =ss.Ik by Y,AMI_1:54
      .=(stop I).(0+n) by A4,A6,GRFUNC_1:8
      .=halt SCMPDS by A5,A9,JJ,KK,SCMPDS_4:38;
    hence contradiction by A3,A7,TX,AMI_1:def 46;
  end;
  card stop I=card I + 1 by SCMPDS_5:7;
  then n < card I + 1 by A4,AFINSQ_1:70;
  then n <= card I by INT_1:20;
  then n < card I by A8,XXREAL_0:1;
  hence thesis by AFINSQ_1:70;
end;

theorem Th41:
  for I,J being Program of SCMPDS,s being State of SCMPDS, k being
  Element of NAT st I is_closed_on s & I is_halting_on s & k < LifeSpan(
ProgramPart(s +* Initialized stop I),s +* Initialized stop I)
 holds CurInstr(ProgramPart (s +* Initialized stop I),
      Comput(ProgramPart(s +* Initialized stop I), (s +* Initialized stop I)
,k)) =
  CurInstr(ProgramPart (s +* Initialized stop (I ';' J)),
Comput(ProgramPart(s +* Initialized stop (I ';' J)), (s +* Initialized
stop (I ';' J)),k))
proof
  let I,J be Program of SCMPDS,s be State of SCMPDS,k be Element of NAT;
  set IsI=Initialized stop I, IsJ=Initialized stop (I ';' J), s1=s+*IsI, s2=s
  +*IsJ;
  set s3= Comput(ProgramPart( s1), s1,k), s4= Comput(ProgramPart( s2), s2,k),
SS=Stop SCMPDS;
  assume that
A1: I is_closed_on s and
A2: I is_halting_on s & k < LifeSpan(ProgramPart(s1),s1);
A3: IC s3 in dom I by A1,A2,Th40;
A4: IC s3= IC s4 by A1,A2,Th39;
A5: stop I = I ';' SS by SCMPDS_4:def 7;
A6: IC s3 in dom stop(I) by A1,Def2;
  IsJ c= s2 & stop (I ';' J) c= IsJ by FUNCT_4:26,SCMPDS_4:9;
  then
A7: dom stop I c= dom stop (I ';' J) & stop (I ';' J) c= s2 by SCMPDS_5:16
,XBOOLE_1:1;
  IsI c= s1 & stop I c= IsI by FUNCT_4:26,SCMPDS_4:9;
  then
A8: stop I c= s1 by XBOOLE_1:1;
A9: stop (I ';' J) = I ';' J ';' SS by SCMPDS_4:def 7
    .=I ';' (J ';' SS) by SCMPDS_4:46;
Y:  (ProgramPart s3)/.IC s3
 = s3.IC s3 by AMI_1:150;
Z:  (ProgramPart s4)/.IC s4
 = s4.IC s4 by AMI_1:150;
TX: ProgramPart s1 = ProgramPart s3
by AMI_1:123;
SX: ProgramPart s2 = ProgramPart s4
by AMI_1:123;
  thus CurInstr(ProgramPart s1,s3) =s1.IC s3 by Y,TX,AMI_1:54
    .=(stop I).IC s3 by A6,A8,GRFUNC_1:8
    .=I.IC s3 by A3,A5,SCMPDS_4:37
    .=(stop (I ';' J)).IC s3 by A3,A9,SCMPDS_4:37
    .=s2.IC s4 by A4,A6,A7,GRFUNC_1:8
    .=CurInstr(ProgramPart s2,s4) by Z,SX,AMI_1:54;
end;

theorem Th42: ::SCMPDS_5:32
  for I being halt-free Program of SCMPDS,s being State of
  SCMPDS, k being Element of NAT st I is_closed_on s & I is_halting_on s & k <
  LifeSpan(ProgramPart(s +* Initialized stop I),s +* Initialized stop I)
   holds CurInstr(ProgramPart Comput(ProgramPart( (s +*
  Initialized stop I)), (s +*
  Initialized stop I),k),Comput(ProgramPart( (s +*
  Initialized stop I)), (s +*
  Initialized stop I),k)) <> halt SCMPDS
proof
  let I be halt-free Program of SCMPDS,s be State of SCMPDS, k be Element of
  NAT;
  set IsI=Initialized stop(I), ss=s +* IsI, s2= Comput(ProgramPart( ss), ss,k);
  assume
  I is_closed_on s & I is_halting_on s & k < LifeSpan(ProgramPart(ss),ss);
  then
A1: IC s2 in dom I by Th40;
Y:  (ProgramPart s2)/.IC s2
 = s2.IC s2 by AMI_1:150;
  IsI c= ss & I c= IsI by Th17,FUNCT_4:26;
  then I c= ss by XBOOLE_1:1;
  then I c= s2 by AMI_1:81;
  then CurInstr(ProgramPart s2,s2)=I.IC s2 by A1,Y,GRFUNC_1:8;
  hence thesis by A1,SCMPDS_5:def 3;
end;

theorem Th43:
  for I being halt-free Program of SCMPDS,s being State of
  SCMPDS st I is_closed_on s & I is_halting_on s holds IC Comput(ProgramPart( (
s +*
  Initialized stop I)), (s +*
  Initialized stop I), LifeSpan(ProgramPart(s +* Initialized stop I),s +*
Initialized stop I)) =  card I
proof
  let I be halt-free Program of SCMPDS,s be State of SCMPDS;
  set IsI=Initialized stop(I), s1=s +* IsI;
  assume that
A1: I is_closed_on s and
A2: I is_halting_on s;
  set Css= Comput(ProgramPart( s1), s1,LifeSpan(ProgramPart(s1),s1));
  reconsider n = IC Css as Element of NAT;
  IsI c= s1 & I c= IsI by Th17,FUNCT_4:26;
  then
A3: I c= s1 by XBOOLE_1:1;
A4: ProgramPart s1 halts_on s1 by A2,Def3;
TX: ProgramPart Css = ProgramPart s1
by AMI_1:123;
  now
Y:  (ProgramPart Css)/.IC Css
 = Css.IC Css by AMI_1:150;
    assume
A5: IC Css in dom I;
    then I.IC Css=s1.IC Css by A3,GRFUNC_1:8
      .=CurInstr(ProgramPart Css,Css) by Y,AMI_1:54
      .=halt SCMPDS by A4,TX,AMI_1:def 46;
    hence contradiction by A5,SCMPDS_5:def 3;
  end;
  then
A6: n >= card I by AFINSQ_1:70;
A7: card stop I =card I + 1 by SCMPDS_5:7;
  IC Css in dom stop(I) by A1,Def2;
  then n < card I + 1 by A7,AFINSQ_1:70;
  then n <= card I by NAT_1:13;
  hence thesis by A6,XXREAL_0:1;
end;

Lm2: for I being halt-free Program of SCMPDS, J being Program of SCMPDS, s
being State of SCMPDS st I is_closed_on s & I is_halting_on s
holds IC
Comput(ProgramPart( (s +* Initialized stop ( I ';' Goto (card J + 1) ';' J ))),
(s +* Initialized stop ( I ';' Goto (card J + 1) ';' J )), (
LifeSpan(ProgramPart(s +* Initialized stop I),s +* Initialized stop I) + 1)) =
(card I + card J + 1) &
DataPart Comput(ProgramPart( (s +* Initialized stop I)), (s +* Initialized stop
I), (LifeSpan(ProgramPart(s +* Initialized
stop I),s +* Initialized
stop I))) = DataPart Comput(ProgramPart( (s +* Initialized stop (I ';' Goto (
card J +
1) ';' J))), (s +* Initialized stop (I ';' Goto (card J +
1) ';' J)), (LifeSpan(ProgramPart(s +* Initialized stop I),s +* Initialized
stop I) + 1)) &
(for k being Element of
NAT st k <= LifeSpan(ProgramPart(s +* Initialized stop I),s +* Initialized stop
I)
 holds CurInstr(ProgramPart (s
+*Initialized stop (I ';' Goto (card J + 1) ';' J )),
Comput(ProgramPart( (s
+*Initialized stop (I ';' Goto (card J + 1) ';' J ))), (s
+*Initialized stop (I ';' Goto (card J + 1) ';' J )),k))
 <> halt SCMPDS) &
 IC
Comput(ProgramPart( (s +* Initialized stop (I ';' Goto (card J + 1) ';' J))), (
s +* Initialized stop (I ';' Goto (card J + 1) ';' J)), (LifeSpan(ProgramPart(s
+* Initialized stop I),s +* Initialized stop I))) =  card I &
 ProgramPart(s +* Initialized stop (I ';' Goto (card J + 1) ';' J))
  halts_on s +* Initialized stop (I ';' Goto (card J + 1) ';' J) &
 LifeSpan(ProgramPart(s +* Initialized stop (I ';' Goto (
card J + 1) ';' J)),s +* Initialized stop (I ';' Goto (
card J + 1) ';' J)) = LifeSpan(ProgramPart(s +* Initialized stop I),s +*
Initialized stop I) + 1

proof
  let I be halt-free Program of SCMPDS, J be Program of SCMPDS, s be State
  of SCMPDS;
  assume
A1: I is_closed_on s;
  set G1=Goto (card J + 1), SS = Stop SCMPDS, J2 = G1 ';' J ';' SS, IJ=I ';'
G1 ';' J, pJ=stop IJ, IsJ=Initialized pJ, s1 = s +* Initialized stop I, s2 = s
  +* IsJ;
  assume
A2: I is_halting_on s;
  set sm= Comput(ProgramPart( s2), s2,LifeSpan(ProgramPart(s1),s1));
A3: IJ =I ';' (G1 ';' J) by SCMPDS_4:46;
  then
A4: IC Comput(ProgramPart( s1), s1,LifeSpan(ProgramPart(s1),s1)) =IC sm by A1
,A2,Th39;
  then
A5: IC sm =  card I by A1,A2,Th43;
A6:  0 in dom G1 by Th33;
A7: J2. 0 = (G1 ';' (J ';' SS)). 0 by SCMPDS_4:46
    .=G1. 0 by A6,SCMPDS_4:37
    .=goto (card J + 1) by Th33;
  pJ c= IsJ by SCMPDS_4:9;
  then
A8: dom pJ c= dom IsJ by GRFUNC_1:8;
  card (G1 ';' J) = card G1 + card J by SCMPDS_4:45
    .=1 + card J by SCMPDS_5:6;
  then
A9: J2. (card J + 1)=J2.(0+card (G1 ';' J))
    .=halt SCMPDS by JJ,KK,SCMPDS_4:38;
A10: card J2 = card (G1 ';' (J ';' SS)) by SCMPDS_4:46
    .=card G1 + card (J ';' SS) by SCMPDS_4:45
    .= 1 + card (J ';' SS) by SCMPDS_5:6;
  then
A11:  0 in dom J2 by AFINSQ_1:70;
A12: pJ =I ';' G1 ';' J ';' SS by SCMPDS_4:def 7
    .=I ';' (G1 ';' J) ';' SS by SCMPDS_4:46
    .=I ';' J2 by SCMPDS_4:46;
  then
A13: card pJ = card I + card J2 by SCMPDS_4:45;
  then card I + 0 < card pJ by A10,XREAL_1:8;
  then
A14:  card I in dom pJ by AFINSQ_1:70;
X: card SS = 1 by SCMNORM:3;
A15: card J2 = 1 + (card J + card SS) by A10,SCMPDS_4:45
    .= card J + (1 + card SS);
  then card J + 1 < card J2 by X,XREAL_1:8;
  then
A16:  (card J + 1) in dom J2 by AFINSQ_1:70;
  card pJ = card I + card J + 1 + 1 by A13,A15,X;
  then card I + card J + 1 < card pJ by NAT_1:13;
  then
A17:  (card I + card J + 1) in dom pJ by AFINSQ_1:70;

Y:  (ProgramPart Comput(ProgramPart(s2),s2,LifeSpan(ProgramPart(s1),s1)))/.IC
Comput(ProgramPart
(s2),s2,LifeSpan(ProgramPart(s1),s1))
 = Comput(ProgramPart(s2),s2,LifeSpan(ProgramPart(s1),s1)).IC Comput(
ProgramPart(s2),s2,LifeSpan(ProgramPart s1,
s1)) by AMI_1:150;
TX: ProgramPart s2 = ProgramPart
Comput(ProgramPart(s2),s2,LifeSpan(ProgramPart(s1),s1
))
by AMI_1:123;
A18: CurInstr(ProgramPart s2,
Comput(ProgramPart(s2),s2,LifeSpan(ProgramPart(s1),s1)))
 = Comput(ProgramPart(s2),s2,LifeSpan(ProgramPart(s1),s1)).
   card I by A1,A2,A4,Th43,Y,TX

    .= s2. card I by AMI_1:54
    .= IsJ. card I by A8,A14,FUNCT_4:14
    .= (I ';' J2).(0+card I) by A12,A14,SCMPDS_4:33
    .= goto (card J + 1) by A11,A7,SCMPDS_4:38;
A19: now
    let a;
    thus Comput(ProgramPart( s2), s2,LifeSpan(ProgramPart(s1),s1) + 1).a = (
Following(
ProgramPart s2,sm)).a
    by AMI_1:14
      .= sm.a by A18,SCMPDS_2:66;
  end;
Y:  (ProgramPart Comput(ProgramPart( s2), s2,LifeSpan(ProgramPart(s1),s1) + 1))
/.
IC Comput(ProgramPart( s2), s2,LifeSpan(ProgramPart(s1),s1) + 1)
 = Comput(ProgramPart( s2), s2,LifeSpan(ProgramPart(s1),s1) + 1).IC Comput(
ProgramPart( s2), s2,
LifeSpan(ProgramPart(s1),s1) + 1)
 by AMI_1:150;
TX2: ProgramPart s2 = ProgramPart
Comput(ProgramPart( s2),s2,LifeSpan(ProgramPart(s1),s1) + 1)
by AMI_1:123;
  thus IC Comput(ProgramPart( s2), s2,LifeSpan(ProgramPart(s1),s1) + 1) = IC
Following(
ProgramPart s2,sm)
   by AMI_1:14
    .= ICplusConst(sm,card J +1) by A18,SCMPDS_2:66
    .= (card I + (card J + 1)) by A5,Th23
    .= (card I + card J + 1);

  then
A20: CurInstr(ProgramPart s2,
       Comput(ProgramPart( s2), s2,LifeSpan(ProgramPart(s1),s1) + 1))
 = s2. (card I + card J
  + 1) by Y,TX2,AMI_1:54

    .= IsJ. (card I + card J + 1) by A8,A17,FUNCT_4:14
    .= (I ';' J2).(card I+(card J+1)) by A12,A17,SCMPDS_4:33
    .= halt SCMPDS by A16,A9,SCMPDS_4:38;
  DataPart Comput(ProgramPart( s1), s1,LifeSpan(ProgramPart(s1),s1)) = DataPart
sm by A1,A2,A3,Th39;

  hence DataPart Comput(ProgramPart( s1), s1,LifeSpan(ProgramPart(s1),s1)) =
DataPart Comput(ProgramPart( s2), s2,LifeSpan(ProgramPart(s1),s1) + 1)
by A19,SCMPDS_4:23;

  thus
A21:
   now
    let k be Element of NAT;
TX1: ProgramPart s1 = ProgramPart Comput(ProgramPart(s1),s1,k)
by AMI_1:123;
    assume
A22: k <= LifeSpan(ProgramPart(s1),s1);
    per cases;
    suppose
A23:  k < LifeSpan(ProgramPart(s1),s1);
      then CurInstr(ProgramPart s1,Comput(ProgramPart(s1),s1,k))
       <> halt SCMPDS by A1,A2,Th42,TX1;

      hence CurInstr(ProgramPart s2,Comput(ProgramPart(s2),s2,k)) <>
       halt SCMPDS by A1,A2,A3,A23,Th41;

    end;
    suppose
      LifeSpan(ProgramPart(s1),s1) <= k;
      then k = LifeSpan(ProgramPart(s1),s1) by A22,XXREAL_0:1;
      hence CurInstr(ProgramPart s2,Comput(ProgramPart(s2),s2,k)) <>
       halt SCMPDS by A18,SCMPDS_2:85;
    end;
  end;
  thus IC Comput(ProgramPart(s2),s2,LifeSpan(ProgramPart(s1),s1))
   =  card I by A1,A2,A4,Th43;
  thus
A24: ProgramPart s2 halts_on s2 by A20,AMI_1:146;
  now
    let k be Element of NAT;
    assume
    CurInstr(ProgramPart (s2),Comput(ProgramPart(s2),s2,k))
     = halt SCMPDS;
    then LifeSpan(ProgramPart(s1),s1) < k by A21;
    hence LifeSpan(ProgramPart(s1),s1)+1 <= k by INT_1:20;
  end;
  hence thesis by A20,A24,AMI_1:def 46;
end;

theorem Th44:
  for I,J being Program of SCMPDS,s being State of SCMPDS st I
  is_closed_on s & I is_halting_on s holds I ';' Goto (card J + 1) ';' J
  is_halting_on s & I ';' Goto (card J + 1) ';' J is_closed_on s
proof
  let I,J be Program of SCMPDS,s be State of SCMPDS;
  set G = Goto (card J + 1), IJ = I ';' G ';' J, J2 = I ';' (G ';' J), pJ =
stop J2, IsJ=Initialized pJ, pI =stop I, IsI=Initialized pI, s1 = s +* IsI, s2
  = s +* IsJ, m=LifeSpan(ProgramPart(s1),s1), SS=Stop SCMPDS, s3= Comput(
ProgramPart( s1), s1,m)
, s4=
  Comput(ProgramPart( s2), s2,m);
A1: IJ=I ';' (G ';' J) by SCMPDS_4:46;
  I c= I ';' SS by SCMPDS_4:40;
  then
A2: I c= pI by SCMPDS_4:def 7;
  IsI c= s1 & pI c= IsI by FUNCT_4:26,SCMPDS_4:9;
  then pI c= s1 by XBOOLE_1:1;
  then I c= s1 by A2,XBOOLE_1:1;
  then
A3: I c= s3 by AMI_1:81;
A4: dom pI c= dom pJ by SCMPDS_5:16;
  set JS=G ';' J ';' SS;
  reconsider n = IC s3 as Element of NAT;
A5: card pI=card I + 1 by SCMPDS_5:7;
  assume
A6: I is_closed_on s;
  then IC s3 in dom pI by Def2;
  then n < card I + 1 by A5,AFINSQ_1:70;
  then
A7: n <= card I by INT_1:20;
  IsJ c= s2 & pJ c= IsJ by FUNCT_4:26,SCMPDS_4:9;
  then
A8: pJ c= s2 by XBOOLE_1:1;
A9: pJ =I ';' (G ';' J) ';' SS by SCMPDS_4:def 7
    .=I ';' JS by SCMPDS_4:46;
  then I c= pJ by SCMPDS_4:40;
  then I c= s2 by A8,XBOOLE_1:1;
  then
A10: I c= s4 by AMI_1:81;
  assume
A11: I is_halting_on s;
  then
A12: ProgramPart s1 halts_on s1 by Def3;
Y:  (ProgramPart s3)/.IC s3
 = s3.IC s3 by AMI_1:150;
Z:  (ProgramPart s4)/.IC s4
 = s4.IC s4 by AMI_1:150;
  per cases;
  suppose
    IC s3 <>  card I;
    then n < card I by A7,XXREAL_0:1;
    then
A13: IC s3 in dom I by AFINSQ_1:70;
TX1: ProgramPart s1 = ProgramPart s3
by AMI_1:123;
TX2: ProgramPart s2 = ProgramPart s4
by AMI_1:123;
A14: halt SCMPDS=CurInstr(ProgramPart s1,s3) by A12,AMI_1:def 46
      .=I.IC s3 by A3,A13,Y,TX1,GRFUNC_1:8
      .=s4.IC s3 by A10,A13,GRFUNC_1:8
      .=CurInstr(ProgramPart s4,s4) by A6,A11,Th39,Z;
    then
A15: ProgramPart s2 halts_on s2 by TX2,AMI_1:146;
    hence IJ is_halting_on s by A1,Def3;
    now
      let k be Element of NAT;
      set C1k=IC Comput(ProgramPart( s1), s1,k), C2k=IC Comput(ProgramPart( s2)
, s2,k);
      per cases;
      suppose
A16:    k <= m;
        C1k in dom pI by A6,Def2;
        then C1k in dom pJ by A4;
        hence C2k in dom pJ by A6,A11,A16,Th39;
      end;
      suppose
A17:    k > m;
        set m2=LifeSpan(ProgramPart(s2),s2);
A18:    m2 <= m by A14,A15,TX2,AMI_1:def 46;
        then C2k=IC Comput(ProgramPart( s2), s2,m2) by A15,A17,Th3,XXREAL_0:2
          .=IC Comput(ProgramPart( s1), s1,m2) by A6,A11,A18,Th39;
        then C2k in dom pI by A6,Def2;
        hence C2k in dom pJ by A4;
      end;
    end;
    hence thesis by A1,Def2;
  end;
  suppose
A19: IC s3 = card I;
    then
A20: IC s4= card I by A6,A11,Th39;
A21:  0 in dom G by Th33;
LL: card Stop SCMPDS = 1 by SCMNORM:3;
A22: JS =G ';' (J ';' SS) by SCMPDS_4:46;
    then
A23: card JS =card G + card (J ';' SS) by SCMPDS_4:45
      .= 1 + card (J ';' SS) by SCMPDS_5:6
      .= card J + 1 + 1 by LL,SCMPDS_4:45;
    then
A24:  0 in dom JS by AFINSQ_1:70;
    card J + 1 < card JS by A23,NAT_1:13;
    then
A25:  (card J + 1) in dom JS by AFINSQ_1:70;
    card pJ = card I + (card J + (1 + 1)) by A9,A23,SCMPDS_4:45
      .= card I + card J + 1 + 1;
    then
A26: card I + card J + 1 < card pJ by NAT_1:13;
    then
A27:  (card I + card J + 1) in dom pJ by AFINSQ_1:70;
Y:  (ProgramPart s4)/.IC s4
 = s4.IC s4 by AMI_1:150;
    card pJ = card I + card JS by A9,SCMPDS_4:45;
    then card I + 0 < card pJ by A23,XREAL_1:8;
    then
A28:  card I in dom pJ by AFINSQ_1:70;
A29: CurInstr(ProgramPart s4,s4)= s4. card I by A6,A11,A19,Th39,Y
      .= s2. card I by AMI_1:54
      .= (I ';' JS).(0+card I) by A9,A8,A28,GRFUNC_1:8
      .= JS. 0 by A24,SCMPDS_4:38
      .=G. 0 by A22,A21,SCMPDS_4:37
      .=goto (card J + 1) by Th33;
    card (G ';' J) = card G + card J by SCMPDS_4:45
      .=1 + card J by SCMPDS_5:6;
    then
A30: JS. (card J + 1)=JS.(0+card (G ';' J))
      .=halt SCMPDS by JJ,KK,SCMPDS_4:38;
Y:  (ProgramPart Comput(ProgramPart(s2),s2,m+1))/.IC Comput(ProgramPart(s2),s2,
m+1)
 = Comput(ProgramPart(s2),s2,m+1).IC Comput(ProgramPart(s2),s2,m+1) by
AMI_1:150;
T: ProgramPart s2 = ProgramPart s4
by AMI_1:123;
TX2: ProgramPart s2 = ProgramPart Comput(ProgramPart(s2),s2,m+1)
by AMI_1:123;
A31: IC Comput(ProgramPart( s2), s2,m + 1) = IC Following(ProgramPart s2,s4)
by AMI_1:14
      .= ICplusConst(s4,card J +1) by A29,T,SCMPDS_2:66
      .= (card I + (card J + 1)) by A20,Th23
      .= (card I + card J + 1);
    then
A32: CurInstr(ProgramPart s2,Comput(ProgramPart(s2),s2,m+1))
 = s2. (card I + card J + 1) by Y,TX2,AMI_1:54
      .= (I ';' JS).(card I+(card J+1)) by A9,A8,A27,GRFUNC_1:8
      .= halt SCMPDS by A25,A30,SCMPDS_4:38;
    then
A33: ProgramPart s2 halts_on s2 by AMI_1:146;
    hence IJ is_halting_on s by A1,Def3;
    now
      let k be Element of NAT;
      set C1k=IC Comput(ProgramPart( s1), s1,k), C2k=IC Comput(ProgramPart( s2)
, s2,k);
      per cases;
      suppose
A34:    k <= m;
        C1k in dom pI by A6,Def2;
        then C1k in dom pJ by A4;
        hence C2k in dom pJ by A6,A11,A34,Th39;
      end;
      suppose
A35:    k > m;
        set m2=LifeSpan(ProgramPart(s2),s2);
A36:    m2 <= m+1 by A32,A33,AMI_1:def 46;
        k >= m+1 by A35,INT_1:20;
        then C2k=IC Comput(ProgramPart( s2), s2,m2) by A33,A36,Th3,XXREAL_0:2
          .= (card I + card J + 1) by A31,A33,A36,Th3;
        hence C2k in dom pJ by A26,AFINSQ_1:70;
      end;
    end;
    hence thesis by A1,Def2;
  end;
end;

theorem Th45:
  for I being shiftable Program of SCMPDS st Initialized stop I c=
s1 & I is_closed_on s1 for n being Element of NAT st Shift(stop I,n) c= s2 & IC
  s2 =  n & DataPart s1 = DataPart s2 for i being Element of NAT holds IC
Comput(ProgramPart( s1), s1,i) + n = IC Comput(ProgramPart( s2), s2,i) &
 CurInstr(ProgramPart Comput(ProgramPart(s1),s1,i),Comput(ProgramPart(s1),s1,i)
)
  = CurInstr(ProgramPart Comput(ProgramPart(s2),s2,i),Comput(ProgramPart(s2),s2
,i)) &
  DataPart Comput(ProgramPart( s1), s1,i) = DataPart
  Comput(ProgramPart( s2), s2,i)
proof
  let I be shiftable Program of SCMPDS;
  set SI=stop I, II = Initialized SI;
  assume that
A1: II c= s1 and
A2: I is_closed_on s1;
  set S1 = s1, S2 = s2;
  let n be Element of NAT;
  II= SI +* Start-At( 0,SCMPDS) & dom SI misses
  dom Start-At( 0,SCMPDS) by SCMPDS_4:54,def 2;
  then
A3: SI c= II by FUNCT_4:33;
  then
A4: dom SI c= dom II by GRFUNC_1:8;
  defpred P[Element of NAT] means IC Comput(ProgramPart(S1),S1,$1) + n = IC
Comput(ProgramPart(
  S2),
  S2,$1) & CurInstr(ProgramPart Comput(ProgramPart(S1),S1,$1),Comput(
ProgramPart(S1),S1,$1))
   = CurInstr(ProgramPart Comput(ProgramPart(S2),S2,$1),Comput(ProgramPart(S2),
S2,$1)) &
  DataPart Comput(ProgramPart(S1),S1,$1) = DataPart Comput(ProgramPart(S2),S2,
$1);
  assume that
A5: Shift(SI,n) c= s2 and
A6: IC s2 =  n and
A7: DataPart s1 = DataPart s2;
  let i be Element of NAT;
A8: DataPart Comput(ProgramPart(S1),S1,0) = DataPart s2 by A7,AMI_1:13
    .= DataPart Comput(ProgramPart(S2),S2,0) by AMI_1:13;
A9:  0 in dom SI by SCMPDS_4:75;
  then
A10:  (0 + n) in dom Shift(SI,n) by VALUED_1:25;
A11: IC SCMPDS in dom II by SCMPDS_4:7;
  then
A12: s1.IC s1 = s1.((II).IC SCMPDS) by A1,GRFUNC_1:8
    .= s1. 0 by SCMPDS_4:29
    .= II. 0 by A1,A4,A9,GRFUNC_1:8
    .= SI. 0 by A3,A9,GRFUNC_1:8;
A13: s1=s1 +* II by A1,FUNCT_4:79;
A14: for k being Element of NAT st P[k] holds P[k + 1]
  proof
    let k be Element of NAT;
    assume
A15: P[k];
    reconsider m = IC Comput(ProgramPart(S1),S1,k) as Element of NAT;
    set i = CurInstr(ProgramPart Comput(ProgramPart(S1),S1,k),Comput(
ProgramPart(S1),S1,k));
T: ProgramPart S1 = ProgramPart Comput(ProgramPart(
S1),S1,k)
by AMI_1:123;
A16: Comput(ProgramPart(S1),S1,k+1) = Following(ProgramPart S1,
Comput(ProgramPart(S1),S1,k))
 by AMI_1:14
      .= Exec(CurInstr(ProgramPart Comput(ProgramPart(S1),S1,k),Comput(
ProgramPart(S1),S1,k)),
      Comput(ProgramPart(S1),S1,k)) by T;
    reconsider l = IC Comput(ProgramPart(S1),S1,k+1) as Element of NAT;
A18: IC Comput(ProgramPart(S1),S1,k+1) in dom SI by A2,A13,Def2;
    then
A19: l+n in dom Shift(SI,n) by VALUED_1:25;
T: ProgramPart S2 = ProgramPart Comput(ProgramPart(S2),S2,k)
by AMI_1:123;
A20: Comput(ProgramPart(S2),S2,k+1) =
Following(ProgramPart S2,Comput(ProgramPart(S2),S2,k)
)
 by AMI_1:14
      .= Exec(CurInstr(ProgramPart Comput(ProgramPart(S2),S2,k),Comput(
ProgramPart(S2),S2,k)),
      Comput(ProgramPart(S2),S2,k)) by T;
A21: IC Comput(ProgramPart(S1),S1,k) in dom SI by A2,A13,Def2;
Y:  (ProgramPart Comput(ProgramPart(S1),S1,k))/.IC Comput(ProgramPart(S1),S1,k)
 = Comput(ProgramPart(S1),S1,k).IC Comput(ProgramPart(S1),S1,k) by AMI_1:150;
A22: i = s1.IC Comput(ProgramPart(S1),S1,k) by Y,AMI_1:54
      .= II.IC Comput(ProgramPart(S1),S1,k) by A1,A4,A21,GRFUNC_1:8
      .= SI.IC Comput(ProgramPart(S1),S1,k) by A3,A21,GRFUNC_1:8;
    then
A23: InsCode i <> 1 & InsCode i <> 3 by A21,SCMPDS_4:def 12;
A24: i valid_at m by A21,A22,SCMPDS_4:def 12;
    hence
A25: IC Comput(ProgramPart(S1),S1,k+1) + n = IC Comput(ProgramPart(S2),S2,k+1)
by A15,A16,A20,A23,SCMPDS_4:83;
Y:  (ProgramPart Comput(ProgramPart(S1),S1,k+1))/.IC Comput(ProgramPart(S1),S1,
k+1)
 = Comput(ProgramPart(S1),S1,k+1).IC Comput(ProgramPart(S1),S1,k+1) by
AMI_1:150;
Z:  (ProgramPart Comput(ProgramPart(S2),S2,k+1))/.IC Comput(ProgramPart(S2),S2,
k+1)
 = Comput(ProgramPart(S2),S2,k+1).IC Comput(ProgramPart(S2),S2,k+1) by
AMI_1:150;
    CurInstr(ProgramPart Comput(ProgramPart(S1),S1,k+1),Comput(ProgramPart(S1),
S1,k+1)) = s1.l
     by Y,AMI_1:54
      .= II.l by A1,A4,A18,GRFUNC_1:8
      .= SI.l by A3,A18,GRFUNC_1:8;
    hence CurInstr(ProgramPart Comput(ProgramPart(S1),S1,k+1),Comput(
ProgramPart(S1),S1,k+1))
     = Shift(SI,n).(IC Comput(ProgramPart(S2),S2,k+1))
    by A25,A18,VALUED_1:def 12
      .= s2.IC Comput(ProgramPart(S2),S2,k+1) by A5,A25,A19,GRFUNC_1:8
      .= CurInstr(ProgramPart Comput(ProgramPart(S2),S2,k+1),Comput(ProgramPart
(S2),S2,k+1))
       by Z,AMI_1:54;
    thus thesis by A15,A16,A20,A23,A24,SCMPDS_4:83;
  end;
A26: IC Comput(ProgramPart(S1),S1,0) = s1.IC SCMPDS by AMI_1:13
    .= II.IC SCMPDS by A1,A11,GRFUNC_1:8
    .=  0 by SCMPDS_4:29;
u: Comput(ProgramPart(S1),S1,0) = S1 by AMI_1:13;
v: Comput(ProgramPart(S2),S2,0) = S2 by AMI_1:13;
Y:  (ProgramPart s2)/.IC s2
 = s2.IC s2 by AMI_1:150;
Z:  (ProgramPart s1)/.IC s1
 = s1.IC s1 by AMI_1:150;
  CurInstr(ProgramPart Comput(ProgramPart(S1),S1,0),Comput(ProgramPart(S1),S1,0
))
   = CurInstr(ProgramPart s1,s1) by u
    .= Shift(SI,n).( 0 + n) by A9,A12,Z,VALUED_1:def 12
    .= CurInstr(ProgramPart s2,s2) by A5,A6,A10,Y,GRFUNC_1:8
    .= CurInstr(ProgramPart Comput(ProgramPart(S2),S2,0),Comput(ProgramPart(S2)
,S2,0))
     by v;
  then
A27: P[0] by A6,A26,A8,AMI_1:13;
  for k being Element of NAT holds P[k] from NAT_1:sch 1(A27,A14);
  hence thesis;
end;

theorem Th46: ::SCMFSA8A:61
  for s being State of SCMPDS,I being halt-free Program of
SCMPDS, J being Program of SCMPDS st I is_closed_on s & I is_halting_on s holds
  IC IExec(I ';' Goto (card J + 1) ';' J,s) = (card I + card J + 1)
proof
  let s be State of SCMPDS,I be halt-free Program of SCMPDS, J be Program of
  SCMPDS;
  set m= LifeSpan(ProgramPart(s +* Initialized stop I),s +* Initialized stop I)
+1, G=Goto (card J + 1), s2 = s +*
  Initialized stop (I ';' G ';' J);
  assume
A1: I is_closed_on s & I is_halting_on s;
  then ProgramPart s2 halts_on s2 & LifeSpan(ProgramPart(s2),s2) = m by Lm2;
  then IC Result(ProgramPart(s2),s2) = IC Comput(ProgramPart( s2), s2,m) by
AMI_1:122
    .=  (card I + card J + 1) by A1,Lm2;
  hence thesis by SCMPDS_5:22;
end;

theorem Th47: ::SCMFSA8A:62
  for s being State of SCMPDS,I being halt-free Program of
SCMPDS, J being Program of SCMPDS st I is_closed_on s & I is_halting_on s holds
IExec(I ';' Goto (card J + 1) ';' J,s) = IExec(I,s) +* Start-At( (card I
  + card J + 1),SCMPDS)
proof
  let s be State of SCMPDS,I be halt-free Program of SCMPDS, J be Program of
  SCMPDS;
  set s1= s +* Initialized stop I, m= LifeSpan(ProgramPart(s1),s1)+1, G=Goto (
card J + 1), s2 =
  s +* Initialized stop (I ';' G ';' J), l=  (card I + card J + 1);
  assume that
A1: I is_closed_on s and
A2: I is_halting_on s;
A3: ProgramPart s1 halts_on s1 by A2,Def3;
  ProgramPart s2 halts_on s2 & LifeSpan(ProgramPart(s2),s2) = m by A1,A2,Lm2;
  then
A4: Result(ProgramPart(s2),s2) = Comput(ProgramPart( s2), s2,m) by AMI_1:122;
  then DataPart Result(ProgramPart(s2),s2) = DataPart Comput(ProgramPart( s1),
s1,LifeSpan(ProgramPart(s1),s1))
by A1,A2,Lm2;
  then
A5: DataPart Result(ProgramPart(s2),s2) = DataPart Result(ProgramPart(s1),s1)
by A3,AMI_1:122
    .= DataPart(Result(ProgramPart(s1),s1) +* Start-At(l,SCMPDS)) by Th7;
  IC Result(ProgramPart(s2),s2) = l by A1,A2,A4,Lm2
    .= IC (Result(ProgramPart(s1),s1) +* Start-At(l,SCMPDS)) by FUNCT_4:121;
  then
A6: Result(ProgramPart(s2),s2),Result(ProgramPart(s1),s1) +* Start-At(l,SCMPDS)
equal_outside A by A5,Th4;
  dom ProgramPart s = A by AMI_1:143;
  then
A7: Result(ProgramPart(s2),s2) +* s | A = Result(ProgramPart(s1),s1) +*
Start-At(l,SCMPDS) +* s | A
by A6,FUNCT_7:108;
A8: dom ProgramPart s misses dom Start-At(l,SCMPDS) by Th10;
  thus IExec(I ';' G ';' J,s) = Result(ProgramPart(s2),s2) +* s | A by
SCMPDS_4:def 8
    .= Result(ProgramPart(s1),s1) +* (Start-At(l,SCMPDS) +* s | A) by A7,
FUNCT_4:15
    .= Result(ProgramPart(s1),s1) +* (s | A +* Start-At(l,SCMPDS)) by A8,
FUNCT_4:36
    .= Result(ProgramPart(s1),s1) +* s | A +* Start-At(l,SCMPDS) by FUNCT_4:15
    .= IExec(I,s) +* Start-At(l,SCMPDS) by SCMPDS_4:def 8;
end;

theorem Th48:
  for s being State of SCMPDS,I being halt-free Program of
  SCMPDS st I is_closed_on s & I is_halting_on s holds IC IExec(I,s) =
  card I
proof
  let s be State of SCMPDS,I be halt-free Program of SCMPDS;
  set s1=s+*Initialized stop(I);
  assume that
A1: I is_closed_on s and
A2: I is_halting_on s;
A3: ProgramPart s1 halts_on s1 by A2,Def3;
  thus IC IExec(I,s) = IC Result(ProgramPart(s1),s1) by SCMPDS_5:22
    .= IC Comput(ProgramPart( s1), s1,LifeSpan(ProgramPart(s1),s1)) by A3,
AMI_1:122
    .= card I by A1,A2,Th43;
end;

begin :: The construction of conditional statements

definition
  let a be Int_position,k be Integer;
  let I,J be Program of SCMPDS;
  func if=0(a,k,I,J) -> Program of SCMPDS equals
  (a,k)<>0_goto (card I +2) ';'
  I ';' Goto (card J+1) ';' J;
  coherence;
  func if>0(a,k,I,J) -> Program of SCMPDS equals
  (a,k)<=0_goto (card I +2) ';'
  I ';' Goto (card J+1) ';' J;
  coherence;
  func if<0(a,k,I,J) -> Program of SCMPDS equals
  (a,k)>=0_goto (card I +2) ';'
  I ';' Goto (card J+1) ';' J;
  coherence;
end;

definition
  let a be Int_position,k be Integer;
  let I be Program of SCMPDS;
  func if=0(a,k,I) -> Program of SCMPDS equals
  (a,k)<>0_goto (card I +1) ';' I;
  coherence;
  func if<>0(a,k,I) -> Program of SCMPDS equals
  (a,k)<>0_goto 2 ';' goto (card
  I+1) ';' I;
  coherence;
  func if>0(a,k,I) -> Program of SCMPDS equals
  (a,k)<=0_goto (card I +1) ';' I;
  coherence;
  func if<=0(a,k,I) -> Program of SCMPDS equals
  (a,k)<=0_goto 2 ';' goto (card
  I+1) ';' I;
  coherence;
  func if<0(a,k,I) -> Program of SCMPDS equals
  (a,k)>=0_goto (card I +1) ';' I;
  coherence;
  func if>=0(a,k,I) -> Program of SCMPDS equals
  (a,k)>=0_goto 2 ';' goto (card
  I+1) ';' I;
  coherence;
end;

Lm3: card (i ';' I ';' Goto n ';' J) = card I + card J +2
proof
  set G=Goto n;

  thus card (i ';' I ';' G ';' J) =card (i ';' I ';' G) + card J by SCMPDS_4:45

    .=card (i ';' I) + card G + card J by SCMPDS_4:45
    .=card (i ';' I) + 1 + card J by SCMPDS_5:6
    .=card I +1 +1 +card J by Th15
    .=card I + card J +2;
end;

begin :: The computation of "if var=0 then block1 else block2"

theorem
  card if=0(a,k1,I,J) = card I + card J + 2 by Lm3;

theorem
   0 in dom if=0(a,k1,I,J) &  1 in dom if=0(a,k1,I,J)
proof
  set ci=card if=0(a,k1,I,J);
  ci=card I + card J +2 by Lm3;
  then 2 <= ci by NAT_1:12;
  then 1 < ci by XXREAL_0:2;
  hence thesis by AFINSQ_1:70;
end;

Lm4: (i ';' I ';' J ';' K). 0=i
proof
A1:  0 in dom Load i by SCMPDS_5:2;
  i ';' I ';' J ';' K =i ';' (I ';' J) ';' K by SCMPDS_4:50
    .=i ';' (I ';' J ';' K) by SCMPDS_4:50
    .=Load i ';' (I ';' J ';' K) by SCMPDS_4:def 4;
  hence (i ';' I ';' J ';' K). 0 =(Load i). 0 by A1,SCMPDS_4:37
    .=i by SCMPDS_5:4;
end;

theorem
  if=0(a,k1,I,J). 0 = (a,k1)<>0_goto (card I + 2) by Lm4;

Lm5: Shift(stop I,1) c= Comput(ProgramPart( (s+* Initialized stop(i ';' I))), (
s+* Initialized stop(i ';' I)),n)
proof
  set pI=stop I, iI=i ';' I, piI=stop iI, IsiI=Initialized piI, s3=s+*IsiI;
  card Load i=1 & iI=(Load i) ';' I by SCMPDS_4:def 4,SCMPDS_5:6;
  then
A1: Shift(pI,1) c= piI by Th24;
  piI c= s3 by FUNCT_4:26,SCMPDS_4:57;
  then Shift(pI,1) c= s3 by A1,XBOOLE_1:1;
  hence thesis by AMI_1:81;
end;

Lm6: Shift(stop I,2) c= Comput(ProgramPart( (s+* Initialized stop(i ';' j ';' I
))), (s+* Initialized stop(i ';' j ';' I)),n)
proof
  set pI=stop I, pjI=stop (i ';' j ';' I), IsjI=Initialized pjI, s3=s+*IsjI;
  card (i ';' j)=card (Load i ';' Load j) by SCMPDS_4:def 6
    .=card Load i + card Load j by SCMPDS_4:45
    .=1+ card Load j by SCMPDS_5:6
    .=1+1 by SCMPDS_5:6;
  then
A1: Shift(pI,2) c= pjI by Th24;
  pjI c= s3 by FUNCT_4:26,SCMPDS_4:57;
  then Shift(pI,2) c= s3 by A1,XBOOLE_1:1;
  hence thesis by AMI_1:81;
end;

theorem Th52:
  for s being State of SCMPDS, I,J being shiftable Program of
  SCMPDS, a being Int_position,k1 being Integer st s.DataLoc(s.a,k1)= 0 & I
is_closed_on s & I is_halting_on s holds if=0(a,k1,I,J) is_closed_on s & if=0(a
  ,k1,I,J) is_halting_on s
proof
  let s be State of SCMPDS, I,J be shiftable Program of SCMPDS, a be
  Int_position,k1 be Integer;
  set b=DataLoc(s.a,k1);
  assume
A1: s.b = 0;
  set i = (a,k1)<>0_goto (card I + 2);
  set G=Goto (card J+1);
  set I2 = I ';' G ';' J, IF=if=0(a,k1,I,J), pIF=stop IF, IsIF=Initialized pIF
  , pI2=stop I2, II2= Initialized pI2, s2 = s +* II2, s3 = s +* IsIF, s4 =
  Comput(ProgramPart(s3),s3,1);
A2: IC s3 = 0 by FUNCT_4:26,SCMPDS_5:18;
A3: not b in dom IsIF by SCMPDS_4:31;
A4: IF = i ';' (I ';' G) ';' J by SCMPDS_4:50
    .= i ';' I2 by SCMPDS_4:50;
  then
A5: Shift(pI2,1) c= s4 by Lm5;
A6: Comput(ProgramPart( s3), s3,0 + 1) = Following(ProgramPart s3,
Comput(ProgramPart(s3),s3,0)) by AMI_1:14
    .= Following(ProgramPart s3,s3) by AMI_1:13
    .= Exec(i,s3) by A4,Th22;
A7: DataPart s2 = DataPart s3 by SCMPDS_4:24,36;
  now
    let a;
    thus s2.a = s3.a by A7,SCMPDS_4:23
      .= s4.a by A6,SCMPDS_2:67;
  end;
  then
A8: DataPart s2 = DataPart s4 by SCMPDS_4:23;
  not a in dom IsIF by SCMPDS_4:31;
  then s3.DataLoc(s3.a,k1)=s3.b by FUNCT_4:12
    .=0 by A1,A3,FUNCT_4:12;
  then
A9: IC s4 = succ IC s3 by A6,SCMPDS_2:67
    .= (0+1) by A2;
A10:  0 in dom pIF by SCMPDS_4:75;
  assume
A11: I is_closed_on s;
  assume
A12: I is_halting_on s;
  then I2 is_halting_on s by A11,Th44;
  then
A13: ProgramPart s2 halts_on s2 by Def3;
A14: I2 is_closed_on s by A11,A12,Th44;
  then
A15: II2 c= s2 & I2 is_closed_on s2 by Th38,FUNCT_4:26;
A16: card pIF = card IF +1 by SCMPDS_5:7
    .= card I2 +1+1 by A4,Th15;
  now
    let k be Element of NAT;
    per cases;
    suppose
      0 < k;
      then consider k1 being Nat such that
A17:  k1 + 1 = k by NAT_1:6;
      reconsider k1 as Element of NAT by ORDINAL1:def 13;
      reconsider m = IC Comput(ProgramPart( s2), s2,k1) as Element of NAT;
A18:  card pIF = card pI2+1 by A16,SCMPDS_5:7;
       m in dom pI2 by A14,Def2;
      then m < card pI2 by AFINSQ_1:70;
      then
A19:  m+1 < card pIF by A18,XREAL_1:8;
T: ProgramPart s3 = ProgramPart s4
by AMI_1:123;
      IC Comput(ProgramPart(s3),s3,k) = IC Comput(ProgramPart( s3), s4,k1) by
A17,AMI_1:51
        .=  (m + 1) by A15,A5,A9,A8,Th45,T;
      hence IC Comput(ProgramPart(s3),s3,k) in dom pIF by A19,AFINSQ_1:70;
    end;
    suppose
      k = 0;
      hence IC Comput(ProgramPart(s3),s3,k) in dom pIF by A10,A2,AMI_1:13;
    end;
  end;
  hence IF is_closed_on s by Def2;
T: ProgramPart s3 = ProgramPart Comput(
ProgramPart(s3),s3,1)
by AMI_1:123;
x: Comput(ProgramPart(s3),s3,LifeSpan(ProgramPart(s2),s2)+1)
 = Comput(ProgramPart(s3),Comput(ProgramPart(s3),s3,1),LifeSpan(ProgramPart(s2)
,s2))
by AMI_1:51;
TX4: ProgramPart s4 = ProgramPart
Comput(ProgramPart(s4),s4,LifeSpan(ProgramPart(s2),s2)
)
by AMI_1:123;
TX2: ProgramPart s2 = ProgramPart
Comput(ProgramPart(s2),s2,LifeSpan(ProgramPart(s2),
s2))
by AMI_1:123;
  CurInstr(ProgramPart s3,
  Comput(ProgramPart(s3),s3,LifeSpan(ProgramPart(s2),s2)+1))
   =CurInstr(ProgramPart s4,
   Comput(ProgramPart(s4),s4,LifeSpan(ProgramPart(s2),s2)))
    by x,T
    .=CurInstr(ProgramPart s2,
    Comput(ProgramPart(s2),s2,LifeSpan(ProgramPart(s2),s2))) by A15,A5,A9,A8
,Th45,TX2,TX4
    .= halt SCMPDS by A13,AMI_1:def 46;
  then ProgramPart s3 halts_on s3 by AMI_1:146;
  hence thesis by Def3;
end;

theorem Th53:
  for s being State of SCMPDS,I being Program of SCMPDS,J being
shiftable Program of SCMPDS,a being Int_position,k1 being Integer st s.DataLoc(
  s.a,k1)<> 0 & J is_closed_on s & J is_halting_on s holds if=0(a,k1,I,J)
  is_closed_on s & if=0(a,k1,I,J) is_halting_on s
proof
  let s be State of SCMPDS,I be Program of SCMPDS, J be shiftable Program of
  SCMPDS, a be Int_position,k1 be Integer;
  set b=DataLoc(s.a,k1);
  set pJ=stop J, IsJ=Initialized pJ, s1 = s +* IsJ, IF=if=0(a,k1,I,J), pIF=
  stop IF, IsIF=Initialized pIF, s3 = s +* IsIF, s4 = Comput(ProgramPart(s3),s3
,1);
  set i = (a,k1)<>0_goto (card I + 2);
  set G =Goto (card J+1), iG=i ';' I ';' G;
A1: IF = i ';' (I ';' G) ';' J by SCMPDS_4:50
    .= i ';' (I ';' G ';' J) by SCMPDS_4:50;
A2: Comput(ProgramPart( s3), s3,0 + 1) = Following(ProgramPart s3,
Comput(ProgramPart(s3),s3,0)) by AMI_1:14
    .= Following(ProgramPart s3,s3) by AMI_1:13
    .= Exec(i,s3) by A1,Th22;
A3: not b in dom IsIF by SCMPDS_4:31;
  not a in dom IsIF by SCMPDS_4:31;
  then
A4: s3.DataLoc(s3.a,k1)=s3.b by FUNCT_4:12
    .= s.b by A3,FUNCT_4:12;
A5: IC s3 = 0 by FUNCT_4:26,SCMPDS_5:18;
  assume
  s.b <> 0;
  then
A6: IC s4 = ICplusConst(s3,card I + 2) by A2,A4,SCMPDS_2:67
    .= (0+(card I + 2)) by A5,Th23;
  assume
A7: J is_closed_on s;
  then
A8: IsJ c= s1 & J is_closed_on s1 by Th38,FUNCT_4:26;
A9: pIF c= s3 by FUNCT_4:26,SCMPDS_4:57;
A10: card iG = card (i ';' I) + card G by SCMPDS_4:45
    .=card (i ';' I) + 1 by SCMPDS_5:6
    .=card I +1 +1 by Th15
    .=card I +(1 +1);
  then Shift(pJ,card I+2) c= pIF by Th24;
  then Shift(pJ,card I+2) c= s3 by A9,XBOOLE_1:1;
  then
A11: Shift(pJ,card I+2) c= s4 by AMI_1:81;
  assume
  J is_halting_on s;
  then
A12: ProgramPart s1 halts_on s1 by Def3;
A13: DataPart s1 = DataPart s3 by SCMPDS_4:24,36;
  now
    let a;
    thus s1.a = s3.a by A13,SCMPDS_4:23
      .= s4.a by A2,SCMPDS_2:67;
  end;
  then
A14: DataPart s1 = DataPart s4 by SCMPDS_4:23;
  now
    let k be Element of NAT;
    per cases;
    suppose
      0 < k;
      then consider k1 being Nat such that
A15:  k1 + 1 = k by NAT_1:6;
      reconsider k1 as Element of NAT by ORDINAL1:def 13;
      reconsider m = IC Comput(ProgramPart( s1), s1,k1) as Element of NAT;
       m in dom pJ by A7,Def2;
      then m < card pJ by AFINSQ_1:70;
      then
A16:  m + (card I + 2) < card pJ + (card I + 2) by XREAL_1:8;
A17:  card pJ = card J + 1 by SCMPDS_5:7;
A18:  card pIF = card IF+1 by SCMPDS_5:7
        .=card I +2 +card J +1 by A10,SCMPDS_4:45
        .=card I +2 + card pJ by A17;
T: ProgramPart s3 = ProgramPart s4
by AMI_1:123;
      IC Comput(ProgramPart(s3),s3,k) = IC Comput(ProgramPart( s3), s4,k1) by
A15,AMI_1:51
        .=  (m + (card I + 2)) by A8,A14,A11,A6,Th45,T;
      hence IC Comput(ProgramPart(s3),s3,k) in dom pIF by A18,A16,AFINSQ_1:70;
    end;
    suppose
      k = 0;
      then Comput(ProgramPart(s3),s3,k) = s3 by AMI_1:13;
      hence IC Comput(ProgramPart(s3),s3,k) in dom pIF by A5,SCMPDS_4:75;
    end;
  end;
  hence IF is_closed_on s by Def2;
T: ProgramPart s3 = ProgramPart Comput(
ProgramPart(s3),s3,1)
by AMI_1:123;
x: Comput(ProgramPart(s3),s3,LifeSpan(ProgramPart(s1),s1)+1)
= Comput(ProgramPart(s3),Comput(ProgramPart(s3),s3,1),LifeSpan(ProgramPart(s1),
s1))
 by AMI_1:51;
TX4: ProgramPart s4 = ProgramPart
Comput(ProgramPart(s4),s4,LifeSpan(ProgramPart(s1),s1)
)
by AMI_1:123;
TX1: ProgramPart s1 = ProgramPart
Comput(ProgramPart(s1),s1,LifeSpan(ProgramPart(s1),
s1))
by AMI_1:123;
  CurInstr(ProgramPart s3,
  Comput(ProgramPart(s3),s3,LifeSpan(ProgramPart(s1),s1)+1))
   =CurInstr(ProgramPart s4,
   Comput(ProgramPart(s4),s4,LifeSpan(ProgramPart(s1),s1))) by x,T
    .=CurInstr(ProgramPart s1,
    Comput(ProgramPart(s1),s1,LifeSpan(ProgramPart(s1),s1))) by A8,A14,A11,A6
,Th45,TX1,TX4
    .= halt SCMPDS by A12,AMI_1:def 46;
  then ProgramPart s3 halts_on s3 by AMI_1:146;
  hence thesis by Def3;
end;

theorem Th54:
  for s being State of SCMPDS,I being halt-free shiftable
Program of SCMPDS, J being shiftable Program of SCMPDS,a being Int_position,k1
  being Integer st s.DataLoc(s.a,k1)= 0 & I is_closed_on s & I is_halting_on s
holds IExec(if=0(a,k1,I,J),s) = IExec(I,s) +* Start-At( (card I + card J
  + 2),SCMPDS)
proof
  let s be State of SCMPDS,I be halt-free shiftable Program of SCMPDS, J be
  shiftable Program of SCMPDS,a be Int_position,k1 be Integer;
  set b=DataLoc(s.a,k1);
  assume
A1: s.b = 0;
  set i = (a,k1)<>0_goto (card I + 2);
  set G=Goto (card J+1);
  set I2 = I ';' G ';' J, IF=if=0(a,k1,I,J), IsIF=Initialized stop IF, pI2=
stop I2, II2= Initialized pI2, s2 = s +* II2, s3 = s +* IsIF, s4 = Comput(
ProgramPart(
  s3),
  s3,1);
A2: IC s3 = 0 by FUNCT_4:26,SCMPDS_5:18;
A3: not b in dom IsIF by SCMPDS_4:31;
A4: IF = i ';' (I ';' G) ';' J by SCMPDS_4:50
    .= i ';' I2 by SCMPDS_4:50;
  then
A5: Shift(pI2,1) c= s4 by Lm5;
A6: Comput(ProgramPart( s3), s3,0 + 1) = Following(ProgramPart s3,
Comput(ProgramPart(s3),s3,0)) by AMI_1:14
    .= Following(ProgramPart s3,s3) by AMI_1:13
    .= Exec(i,s3) by A4,Th22;
  not a in dom IsIF by SCMPDS_4:31;
  then s3.DataLoc(s3.a,k1)=s3.b by FUNCT_4:12
    .=0 by A1,A3,FUNCT_4:12;
  then
A7: IC s4 = succ IC s3 by A6,SCMPDS_2:67
    .= (0+1) by A2;
A8: DataPart s2 = DataPart s3 by SCMPDS_4:24,36;
  now
    let a;
    thus s2.a = s3.a by A8,SCMPDS_4:23
      .= s4.a by A6,SCMPDS_2:67;
  end;
  then
A9: DataPart s2 = DataPart s4 by SCMPDS_4:23;
A10: dom ProgramPart s = A by AMI_1:143;
  set SAl= Start-At( (card I + card J + 2),SCMPDS);
  assume
A11: I is_closed_on s;
  assume
A12: I is_halting_on s;
  then I2 is_halting_on s by A11,Th44;
  then
A13: ProgramPart s2 halts_on s2 by Def3;
  I2 is_closed_on s by A11,A12,Th44;
  then
A14: II2 c= s2 & I2 is_closed_on s2 by Th38,FUNCT_4:26;
T: ProgramPart s3 = ProgramPart Comput(
ProgramPart(s3),s3,1)
by AMI_1:123;
x: Comput(ProgramPart(s3),s3,LifeSpan(ProgramPart(s2),s2)+1)
 = Comput(ProgramPart(s3),Comput(ProgramPart(s3),s3,1),LifeSpan(ProgramPart(s2)
,s2))
 by AMI_1:51;
TX4: ProgramPart s4 = ProgramPart
Comput(ProgramPart(s4),s4,LifeSpan(ProgramPart(s2),s2))
by AMI_1:123;
TX2: ProgramPart s2 = ProgramPart
Comput(ProgramPart(s2),s2,LifeSpan(ProgramPart(s2),
s2))
by AMI_1:123;
A15: CurInstr(ProgramPart s3,
Comput(ProgramPart(s3),s3,LifeSpan(ProgramPart(s2),s2)+1))
 =CurInstr(ProgramPart s4,
 Comput(ProgramPart(s4),s4,LifeSpan(ProgramPart(s2),s2))) by x,T
    .=CurInstr(ProgramPart s2,
    Comput(ProgramPart(s2),s2,LifeSpan(ProgramPart(s2),s2))) by A14,A5,A7,A9
,Th45,TX2,TX4
    .= halt SCMPDS by A13,AMI_1:def 46;
  then
A16: ProgramPart s3 halts_on s3 by AMI_1:146;
A17: CurInstr(ProgramPart s3,s3) = i by A4,Th22;
  now
    let l be Element of NAT;
    assume
A18: l < LifeSpan(ProgramPart(s2),s2) + 1;
u: Comput(ProgramPart(s3),s3,0) = s3 by AMI_1:13;
    per cases;
    suppose
      l = 0;
      then CurInstr(ProgramPart s3,Comput(ProgramPart(s3),s3,l)) =
      CurInstr(ProgramPart s3,s3)
       by u;
      hence CurInstr(ProgramPart (s3),Comput(ProgramPart(s3),s3,l)) <>
      halt SCMPDS by A17,Th29;
    end;
    suppose
      l <> 0;
      then consider n be Nat such that
A19:  l = n + 1 by NAT_1:6;
      reconsider n as Element of NAT by ORDINAL1:def 13;
A20:  n < LifeSpan(ProgramPart(s2),s2) by A18,A19,XREAL_1:8;
      assume
A21:  CurInstr(ProgramPart (s3),Comput(ProgramPart(s3),s3,l)) = halt SCMPDS;
T: ProgramPart s3 = ProgramPart Comput(ProgramPart(s3),
s3,1)
by AMI_1:123;
TX2: ProgramPart s2 = ProgramPart Comput(ProgramPart(s2),s2,n)
by AMI_1:123;
TX4: ProgramPart s4 = ProgramPart Comput(ProgramPart(s4),s4,n)
by AMI_1:123;
x: Comput(ProgramPart(s3),s3,n+1)
 = Comput(ProgramPart(s3),Comput(ProgramPart(s3),s3,1),n) by AMI_1:51;
      CurInstr(ProgramPart s2,Comput(ProgramPart(s2),s2,n))
       = CurInstr(ProgramPart s4,Comput(ProgramPart(s4),s4,n))
       by A14,A5,A7,A9,TX2,TX4,Th45
        .= halt SCMPDS by A19,A21,x,T;
      hence contradiction by A13,A20,AMI_1:def 46;
    end;
  end;
  then for l be Element of NAT st CurInstr(ProgramPart (s3),
  Comput(ProgramPart(s3),s3,l)) = halt SCMPDS
  holds LifeSpan(ProgramPart(s2),s2) + 1 <= l;
  then
A22: LifeSpan(ProgramPart(s3),s3) = LifeSpan(ProgramPart(s2),s2) + 1 by A15,A16
,AMI_1:def 46;
T: ProgramPart s3 = ProgramPart s4
by AMI_1:123;
A23: DataPart Result(ProgramPart(s2),s2) = DataPart Comput(ProgramPart( s2), s2
,LifeSpan(ProgramPart(s2),s2)) by A13,AMI_1:122
    .= DataPart Comput(ProgramPart( s3), s4,LifeSpan(ProgramPart(s2),s2)) by
A14,A5,A7,A9,Th45,T
    .= DataPart Comput(ProgramPart( s3), s3,LifeSpan(ProgramPart(s2),s2) + 1)
by AMI_1:51
    .= DataPart Result(ProgramPart(s3),s3) by A16,A22,AMI_1:122;
A24: now
    let x be set;
A25: IExec(I2,s) = Result(ProgramPart(s2),s2) +* s | A by SCMPDS_4:def 8;
A26: IExec(IF,s) = Result(ProgramPart(s3),s3) +* s | A by SCMPDS_4:def 8;
A27: dom SAl = {IC SCMPDS} by FUNCOP_1:19;
    assume
A28: x in dom IExec(IF,s);
    per cases by A28,SCMPDS_4:20;
    suppose
A29:  x is Int_position;
      then x <> IC SCMPDS by SCMPDS_2:52;
      then
A30:  not x in dom SAl by A27,TARSKI:def 1;
A31: not x in dom (s | A) by A10,A29,SCMPDS_2:53;
      hence IExec(IF,s).x = (Result(ProgramPart(s3),s3)).x by A26,FUNCT_4:12
        .= (Result(ProgramPart(s2),s2)).x by A23,A29,SCMPDS_4:23
        .= IExec(I2,s).x by A25,A31,FUNCT_4:12
        .= (IExec(I2,s) +* SAl).x by A30,FUNCT_4:12;
    end;
    suppose
A32:  x = IC SCMPDS;
A33: not x in dom (s | A) by A10,A32,AMI_1:48;
      then
A34:  IC Result(ProgramPart(s2),s2) = IC IExec(I2,s) by A25,A32,FUNCT_4:12
        .=  (card I + card J + 1) by A11,A12,Th46;
A35:  x in dom SAl by A27,A32,TARSKI:def 1;
T: ProgramPart s3 = ProgramPart s4
by AMI_1:123;
      thus IExec(IF,s).x = (Result(ProgramPart(s3),s3)).x by A26,A33,FUNCT_4:12
        .= Comput(ProgramPart( s3), s3,LifeSpan(ProgramPart(s2),s2) + 1).x by
A16,A22,AMI_1:122
        .= IC Comput(ProgramPart( s3), s4,LifeSpan(ProgramPart(s2),s2)) by A32,
AMI_1:51
        .= IC Comput(ProgramPart( s2), s2,LifeSpan(ProgramPart(s2),s2)) + 1
        by A14,A5,A7,A9,Th45,T
        .= IC Result(ProgramPart(s2),s2) + 1 by A13,AMI_1:122
        .= (Start-At ( (card I + card J + 1) + 1,SCMPDS)).IC SCMPDS
        by A34,FUNCOP_1:87
        .= (IExec(I2,s) +* SAl).x by A32,A35,FUNCT_4:14;
    end;
    suppose
      x is Element of NAT;
      hence IExec(IF,s).x = (IExec(I2,s) +* SAl).x by Th26;
    end;
  end;
  dom IExec(IF,s) = the carrier of SCMPDS by PARTFUN1:def 4
    .= dom (IExec(I2,s) +* SAl) by PARTFUN1:def 4;
  hence IExec(IF,s) = IExec(I2,s) +* SAl by A24,FUNCT_1:9
    .= IExec(I,s) +* Start-At((card I+card J+1),SCMPDS) +* Start-At(
   (card I + card J + 2),SCMPDS) by A11,A12,Th47
    .= IExec(I,s) +* SAl by Th14;
end;

theorem Th55:
  for s being State of SCMPDS,I being Program of SCMPDS,J being
  halt-free shiftable Program of SCMPDS,a being Int_position,k1 being Integer
  st s.DataLoc(s.a,k1)<> 0 & J is_closed_on s & J is_halting_on s holds IExec(
  if=0(a,k1,I,J),s) = IExec(J,s) +*
  Start-At( (card I + card J + 2),SCMPDS)
proof
  let s be State of SCMPDS,I be Program of SCMPDS,J be halt-free shiftable
  Program of SCMPDS,a be Int_position,k1 be Integer;
  set b=DataLoc(s.a,k1);
  set pJ=stop J, IsJ=Initialized pJ, s1 = s +* IsJ, IF=if=0(a,k1,I,J), pIF=
  stop IF, IsIF=Initialized pIF, s3 = s +* IsIF, s4 = Comput(ProgramPart( s3),
s3,1);
  set i = (a,k1)<>0_goto (card I + 2);
  set G =Goto (card J+1), iG=i ';' I ';' G;
  set SAl=Start-At((card I+card J+2),SCMPDS);
A1: IF = i ';' (I ';' G) ';' J by SCMPDS_4:50
    .= i ';' (I ';' G ';' J) by SCMPDS_4:50;
A2: Comput(ProgramPart( s3), s3,0 + 1) = Following(ProgramPart s3,
Comput(ProgramPart(s3),s3,0)) by AMI_1:14
    .= Following(ProgramPart s3,s3) by AMI_1:13
    .= Exec(i,s3) by A1,Th22;
A3: not b in dom IsIF by SCMPDS_4:31;
  not a in dom IsIF by SCMPDS_4:31;
  then
A4: s3.DataLoc(s3.a,k1)=s3.b by FUNCT_4:12
    .= s.b by A3,FUNCT_4:12;
A5: IC s3 = 0 by FUNCT_4:26,SCMPDS_5:18;
A6: dom ProgramPart s = A by AMI_1:143;
  assume
  s.b <> 0;
  then
A7: IC s4 = ICplusConst(s3,card I + 2) by A2,A4,SCMPDS_2:67
    .= (0+(card I + 2)) by A5,Th23;
A8: DataPart s1 = DataPart s3 by SCMPDS_4:24,36;
  now
    let a;
    thus s1.a = s3.a by A8,SCMPDS_4:23
      .= s4.a by A2,SCMPDS_2:67;
  end;
  then
A9: DataPart s1 = DataPart s4 by SCMPDS_4:23;
  card iG = card (i ';' I) + card G by SCMPDS_4:45
    .=card (i ';' I) + 1 by SCMPDS_5:6
    .=card I +1 +1 by Th15
    .=card I +(1 +1);
  then
A10: Shift(pJ,card I+2) c= pIF by Th24;
  pIF c= s3 by FUNCT_4:26,SCMPDS_4:57;
  then Shift(pJ,card I+2) c= s3 by A10,XBOOLE_1:1;
  then
A11: Shift(pJ,card I+2) c= s4 by AMI_1:81;
  assume
A12: J is_closed_on s;
  then
A13: IsJ c= s1 & J is_closed_on s1 by Th38,FUNCT_4:26;
  assume
A14: J is_halting_on s;
  then
A15: ProgramPart s1 halts_on s1 by Def3;
T: ProgramPart s3 = ProgramPart Comput(
ProgramPart(s3),s3,1)
by AMI_1:123;
x: Comput(ProgramPart(s3),s3,LifeSpan(ProgramPart(s1),s1)+1) =
Comput(ProgramPart(s3),Comput(ProgramPart(s3),s3,1),LifeSpan(ProgramPart(s1),s1
))
 by AMI_1:51;
TX4: ProgramPart s4 =
ProgramPart Comput(ProgramPart(s4),s4,LifeSpan(ProgramPart(s1),s1))
by AMI_1:123;
TX1: ProgramPart s1 = ProgramPart
Comput(ProgramPart(s1),s1,LifeSpan(ProgramPart(s1),
s1))
by AMI_1:123;
A16: CurInstr(ProgramPart s3,
Comput(ProgramPart(s3),s3,LifeSpan(ProgramPart(s1),s1)+1))
 =CurInstr(ProgramPart s4,
 Comput(ProgramPart(s4),s4,LifeSpan(ProgramPart(s1),s1))) by x,T
    .=CurInstr(ProgramPart s1,
    Comput(ProgramPart(s1),s1,LifeSpan(ProgramPart(s1),s1))) by A13,A11,A7,A9
,Th45,TX1,TX4
    .= halt SCMPDS by A15,AMI_1:def 46;
  then
A17: ProgramPart s3 halts_on s3 by AMI_1:146;
A18: CurInstr(ProgramPart s3,s3) = i by A1,Th22;
  now
    let l be Element of NAT;
    assume
A19: l < LifeSpan(ProgramPart(s1),s1) + 1;
u: Comput(ProgramPart(s3),s3,0) = s3 by AMI_1:13;
    per cases;
    suppose
      l = 0;
      then CurInstr(ProgramPart s3,Comput(ProgramPart(s3),s3,l))
       = CurInstr(ProgramPart s3,s3)
       by u;
      hence CurInstr(ProgramPart (s3),Comput(ProgramPart(s3),s3,l)) <>
       halt SCMPDS by A18,Th29;
    end;
    suppose
      l <> 0;
      then consider n be Nat such that
A20:  l = n + 1 by NAT_1:6;
      reconsider n as Element of NAT by ORDINAL1:def 13;
A21:  n < LifeSpan(ProgramPart(s1),s1) by A19,A20,XREAL_1:8;
      assume
A22:  CurInstr(ProgramPart (s3),Comput(ProgramPart(s3),s3,l)) = halt SCMPDS;
T: ProgramPart s3 = ProgramPart Comput(ProgramPart(s3),s3,1)
by AMI_1:123;
x: Comput(ProgramPart(s3),s3,n+1) =
Comput(ProgramPart(s3),Comput(ProgramPart(s3),s3,1),n) by AMI_1:51;
TX1: ProgramPart s1 = ProgramPart Comput(ProgramPart(s1),s1,n)
by AMI_1:123;
TX4: ProgramPart s4 = ProgramPart Comput(ProgramPart(s4),s4,n)
by AMI_1:123;
      CurInstr(ProgramPart s1,Comput(ProgramPart(s1),
s1,n))
       = CurInstr(ProgramPart s4,
      Comput(ProgramPart(s4),s4,n)) by A13,A11,A7,A9,Th45,TX1,TX4
        .= halt SCMPDS by A20,A22,x,T;
      hence contradiction by A15,A21,AMI_1:def 46;
    end;
  end;
  then for l be Element of NAT st CurInstr(ProgramPart (s3),
  Comput(ProgramPart(s3),s3,l)) = halt SCMPDS
  holds LifeSpan(ProgramPart(s1),s1) + 1 <= l;
  then
A23: LifeSpan(ProgramPart(s3),s3) = LifeSpan(ProgramPart(s1),s1) + 1 by A16,A17
,AMI_1:def 46;
A24: DataPart Result(ProgramPart(s1),s1) = DataPart Comput(ProgramPart( s1), s1
,LifeSpan(ProgramPart(s1),s1)) by A15,AMI_1:122
    .= DataPart Comput(ProgramPart( s3), s4,LifeSpan(ProgramPart(s1),s1))
    by A13,A11,A7,A9,Th45,T
    .= DataPart Comput(ProgramPart( s3), s3,LifeSpan(ProgramPart(s1),s1) + 1)
    by AMI_1:51
    .= DataPart Result(ProgramPart(s3),s3) by A17,A23,AMI_1:122;
A25: now
    let x be set;
A26: IExec(J,s) = Result(ProgramPart(s1),s1) +* s | A by SCMPDS_4:def 8;
A27: IExec(IF,s) = Result(ProgramPart(s3),s3) +* s | A by SCMPDS_4:def 8;
A28: dom SAl = {IC SCMPDS} by FUNCOP_1:19;
    assume
A29: x in dom IExec(IF,s);
    per cases by A29,SCMPDS_4:20;
    suppose
A30:  x is Int_position;
      then x <> IC SCMPDS by SCMPDS_2:52;
      then
A31:  not x in dom SAl by A28,TARSKI:def 1;
A32: not x in dom (s | A) by A6,A30,SCMPDS_2:53;
      hence IExec(IF,s).x = (Result(ProgramPart(s3),s3)).x by A27,FUNCT_4:12
        .= (Result(ProgramPart(s1),s1)).x by A24,A30,SCMPDS_4:23
        .= IExec(J,s).x by A26,A32,FUNCT_4:12
        .= (IExec(J,s) +* SAl).x by A31,FUNCT_4:12;
    end;
    suppose
A33:  x = IC SCMPDS;
A34: not x in dom (s | A) by A6,A33,AMI_1:48;
      then
A35:  IC Result(ProgramPart(s1),s1) = IC IExec(J,s) by A26,A33,FUNCT_4:12
        .=  (card J) by A12,A14,Th48;
T: ProgramPart s3 = ProgramPart s4
by AMI_1:123;
A36:  x in dom SAl by A28,A33,TARSKI:def 1;
      thus IExec(IF,s).x = (Result(ProgramPart(s3),s3)).x by A27,A34,FUNCT_4:12
        .= Comput(ProgramPart( s3), s3,LifeSpan(ProgramPart(s1),s1) + 1).x by
A17,A23,AMI_1:122
        .= IC Comput(ProgramPart( s3), s4,LifeSpan(ProgramPart(s1),s1)) by A33,
AMI_1:51
        .= IC Comput(ProgramPart( s1), s1,LifeSpan(ProgramPart(s1),s1)) + (card
I + 2) by A13,A11,A7,A9,Th45,T
        .= IC Result(ProgramPart(s1),s1) + (card I + 2) by A15,AMI_1:122
        .= (Start-At ( card J + (card I + 2),SCMPDS)).IC SCMPDS by A35,
FUNCOP_1:87
        .= (IExec(J,s) +* SAl).x by A33,A36,FUNCT_4:14;
    end;
    suppose
      x is Element of NAT;
      hence IExec(IF,s).x = (IExec(J,s) +* SAl).x by Th26;
    end;
  end;
  dom IExec(IF,s) = the carrier of SCMPDS by PARTFUN1:def 4
    .= dom (IExec(J,s) +* SAl) by PARTFUN1:def 4;
  hence thesis by A25,FUNCT_1:9;
end;

registration
  let I,J be shiftable parahalting Program of SCMPDS, a be Int_position,k1 be
  Integer;
  cluster if=0(a,k1,I,J) -> shiftable parahalting;
  correctness
  proof
    set i = (a,k1)<>0_goto (card I + 2), G =Goto (card J+1);
    set IF=if=0(a,k1,I,J), IsIF=Initialized stop IF;
    reconsider IJ=I ';' G ';' J as shiftable Program of SCMPDS;
    IF =i ';' (I ';' G) ';' J by SCMPDS_4:50
      .=i ';' IJ by SCMPDS_4:50
      .=Load i ';' IJ by SCMPDS_4:def 4;
    hence IF is shiftable;
    now
      let s be State of SCMPDS;
      assume
      IsIF c= s;
      then
A1:   s = s +* IsIF by FUNCT_4:79;
A2:   J is_closed_on s & J is_halting_on s by Th34,Th35;
A3:   I is_closed_on s & I is_halting_on s by Th34,Th35;
      per cases;
      suppose
        s.DataLoc(s.a,k1)= 0;
        then IF is_halting_on s by A3,Th52;
        hence ProgramPart s halts_on s by A1,Def3;
      end;
      suppose
        s.DataLoc(s.a,k1) <> 0;
        then IF is_halting_on s by A2,Th53;
        hence ProgramPart s halts_on s by A1,Def3;
      end;
    end;
    then IsIF is halting by AMI_1:def 26;
    hence thesis by SCMPDS_4:def 10;
  end;
end;

registration
  let I,J be halt-free Program of SCMPDS, a be Int_position,k1 be Integer;
  cluster if=0(a,k1,I,J) -> halt-free;
  coherence;
end;

theorem
  for s being State of SCMPDS,I,J being halt-free shiftable
  parahalting Program of SCMPDS,a being Int_position,k1 being Integer holds IC
  IExec(if=0(a,k1,I,J),s) =  (card I + card J + 2)
proof
  let s be State of SCMPDS,I,J be halt-free shiftable parahalting Program of
  SCMPDS,a be Int_position,k1 be Integer;
  set IF=if=0(a,k1,I,J);
A1: J is_closed_on s & J is_halting_on s by Th34,Th35;
A2: I is_closed_on s & I is_halting_on s by Th34,Th35;
  hereby
    per cases;
    suppose
      s.DataLoc(s.a,k1) = 0;
      then
      IExec(IF,s) = IExec(I,s) +* Start-At((card I+card J+2),SCMPDS)
      by A2,Th54;
      hence thesis by FUNCT_4:121;
    end;
    suppose
      s.DataLoc(s.a,k1) <> 0;
      then
      IExec(IF,s) = IExec(J,s) +* Start-At((card I+card J+2),SCMPDS)
      by A1,Th55;
      hence thesis by FUNCT_4:121;
    end;
  end;
end;

theorem
  for s being State of SCMPDS,I being halt-free shiftable parahalting
  Program of SCMPDS,J being shiftable Program of SCMPDS,a,b being Int_position,
  k1 being Integer st s.DataLoc(s.a,k1)= 0 holds IExec(if=0(a,k1,I,J),s).b =
  IExec(I,s).b
proof
  let s be State of SCMPDS,I be halt-free shiftable parahalting Program of
  SCMPDS,J be shiftable Program of SCMPDS,a,b be Int_position, k1 be Integer;
  assume
A1: s.DataLoc(s.a,k1)=0;
A2: not b in dom Start-At((card I+card J+2),SCMPDS) by SCMPDS_4:59;
  I is_closed_on s & I is_halting_on s by Th34,Th35;
  then
  IExec(if=0(a,k1,I,J),s) = IExec(I,s) +* Start-At( (card I + card J
  + 2),SCMPDS) by A1,Th54;
  hence thesis by A2,FUNCT_4:12;
end;

theorem
  for s being State of SCMPDS,I being Program of SCMPDS,J being
  halt-free parahalting shiftable Program of SCMPDS,a,b being Int_position,k1
being Integer st s.DataLoc(s.a,k1)<> 0 holds IExec(if=0(a,k1,I,J),s).b = IExec(
  J,s).b
proof
  let s be State of SCMPDS,I be Program of SCMPDS,J be halt-free parahalting
  shiftable Program of SCMPDS,a,b be Int_position, k1 be Integer;
  assume
A1: s.DataLoc(s.a,k1)<>0;
A2: not b in dom Start-At((card I+card J+2),SCMPDS) by SCMPDS_4:59;
  J is_closed_on s & J is_halting_on s by Th34,Th35;
  then
  IExec(if=0(a,k1,I,J),s) = IExec(J,s) +* Start-At( (card I + card J
  + 2),SCMPDS) by A1,Th55;
  hence thesis by A2,FUNCT_4:12;
end;

begin :: The computation of "if var=0 then block"

theorem
  card if=0(a,k1,I) = card I + 1 by Th15;

theorem
   0 in dom if=0(a,k1,I)
proof
  set ci=card if=0(a,k1,I);
  ci=card I + 1 by Th15;
  hence thesis by AFINSQ_1:70;
end;

theorem
  if=0(a,k1,I). 0 = (a,k1)<>0_goto (card I + 1) by Th16;

theorem Th62:
  for s being State of SCMPDS, I being shiftable Program of SCMPDS
  , a being Int_position,k1 being Integer st s.DataLoc(s.a,k1)= 0 & I
is_closed_on s & I is_halting_on s holds if=0(a,k1,I) is_closed_on s & if=0(a,
  k1,I) is_halting_on s
proof
  let s be State of SCMPDS, I be shiftable Program of SCMPDS, a be
  Int_position,k1 be Integer;
  set b=DataLoc(s.a,k1);
  assume
A1: s.b = 0;
  set i = (a,k1)<>0_goto (card I + 1);
  set IF=if=0(a,k1,I), pIF=stop IF, IsIF=Initialized pIF, pI=stop I, IsI=
  Initialized pI, s2 = s +* IsI, s3 = s +* IsIF, s4 = Comput(ProgramPart(s3),s3
,1);
A2: IC s3 = 0 by FUNCT_4:26,SCMPDS_5:18;
A3: not b in dom IsIF by SCMPDS_4:31;
A4: Comput(ProgramPart( s3), s3,0 + 1) = Following(ProgramPart s3,
Comput(ProgramPart(s3),s3,0)) by AMI_1:14
    .= Following(ProgramPart s3,s3) by AMI_1:13
    .= Exec(i,s3) by Th22;
A5: DataPart s2 = DataPart s3 by SCMPDS_4:24,36;
  now
    let a;
    thus s2.a = s3.a by A5,SCMPDS_4:23
      .= s4.a by A4,SCMPDS_2:67;
  end;
  then
A6: DataPart s2 = DataPart s4 by SCMPDS_4:23;
  not a in dom IsIF by SCMPDS_4:31;
  then s3.DataLoc(s3.a,k1)=s3.b by FUNCT_4:12
    .=0 by A1,A3,FUNCT_4:12;
  then
A7: IC s4 = succ IC s3 by A4,SCMPDS_2:67
    .= (0+1) by A2;
  assume
A8: I is_closed_on s;
  then
A9: I is_closed_on s2 by Th38;
  assume
  I is_halting_on s;
  then
A10: ProgramPart s2 halts_on s2 by Def3;
A11:  0 in dom pIF by SCMPDS_4:75;
A12: IsI c= s2 & Shift(pI,1) c= s4 by Lm5,FUNCT_4:26;
A13: card pIF = card IF +1 by SCMPDS_5:7
    .= card I +1+1 by Th15;
  now
    let k be Element of NAT;
    per cases;
    suppose
      0 < k;
      then consider k1 being Nat such that
A14:  k1 + 1 = k by NAT_1:6;
      reconsider k1 as Element of NAT by ORDINAL1:def 13;
      reconsider m = IC Comput(ProgramPart( s2), s2,k1) as Element of NAT;
A15:  card pIF = card pI+1 by A13,SCMPDS_5:7;
       m in dom pI by A8,Def2;
      then m < card pI by AFINSQ_1:70;
      then
A16:  m+1 < card pIF by A15,XREAL_1:8;
T: ProgramPart s3 = ProgramPart s4
by AMI_1:123;
      IC Comput(ProgramPart(s3),s3,k) = IC Comput(ProgramPart( s3), s4,k1) by
A14,AMI_1:51
        .=  (m + 1) by A9,A12,A7,A6,Th45,T;
      hence IC Comput(ProgramPart(s3),s3,k) in dom pIF by A16,AFINSQ_1:70;
    end;
    suppose
      k = 0;
      hence IC Comput(ProgramPart(s3),s3,k) in dom pIF by A11,A2,AMI_1:13;
    end;
  end;
  hence IF is_closed_on s by Def2;
T: ProgramPart s3 = ProgramPart Comput(
ProgramPart(s3),s3,1)
by AMI_1:123;
x: Comput(ProgramPart(s3),s3,LifeSpan(ProgramPart(s2),s2)+1)
 = Comput(ProgramPart(s3),Comput(ProgramPart(s3),s3,1),LifeSpan(ProgramPart(s2)
,s2))
 by AMI_1:51;
TX4: ProgramPart s4 = ProgramPart
Comput(ProgramPart(s4),s4,LifeSpan(ProgramPart(s2),s2)
)
by AMI_1:123;
TX2: ProgramPart s2 = ProgramPart
Comput(ProgramPart(s2),s2,LifeSpan(ProgramPart(s2),
s2))
by AMI_1:123;
  CurInstr(ProgramPart s3,
  Comput(ProgramPart(s3),s3,LifeSpan(ProgramPart(s2),s2)+1))
   =CurInstr(ProgramPart s4,
   Comput(ProgramPart(s4),s4,LifeSpan(ProgramPart(s2),s2))) by x,T
    .=CurInstr(ProgramPart s2,
    Comput(ProgramPart(s2),s2,LifeSpan(ProgramPart(s2),s2))) by A9,A12,A7,A6
,Th45,TX4,TX2
    .= halt SCMPDS by A10,AMI_1:def 46;
  then ProgramPart s3 halts_on s3 by AMI_1:146;
  hence thesis by Def3;
end;

theorem Th63:
  for s being State of SCMPDS,I being Program of SCMPDS, a being
  Int_position, k1 being Integer st s.DataLoc(s.a,k1)<> 0 holds if=0(a,k1,I)
  is_closed_on s & if=0(a,k1,I) is_halting_on s
proof
  let s be State of SCMPDS,I be Program of SCMPDS, a be Int_position,k1 be
  Integer;
  set b=DataLoc(s.a,k1);
  assume
A1: s.b <> 0;
  set i = (a,k1)<>0_goto (card I + 1);
  set IF=if=0(a,k1,I), pIF=stop IF, IsIF=Initialized pIF, s3 = s +* IsIF, s4 =
  Comput(ProgramPart(s3),s3,1);
TX: ProgramPart s4 = ProgramPart s3
by AMI_1:123;
A2: IC s3 = 0 by FUNCT_4:26,SCMPDS_5:18;
A3: not b in dom IsIF by SCMPDS_4:31;
  not a in dom IsIF by SCMPDS_4:31;
  then
A4: s3.DataLoc(s3.a,k1)=s3.b by FUNCT_4:12
    .= s.b by A3,FUNCT_4:12;
  Comput(ProgramPart( s3), s3,0 + 1) = Following(ProgramPart s3,
  Comput(ProgramPart(s3),s3,0)) by AMI_1:14
    .= Following(ProgramPart s3,s3) by AMI_1:13
    .= Exec(i,s3) by Th22;
  then
A5: IC s4 = ICplusConst(s3,card I + 1) by A1,A4,SCMPDS_2:67
    .= (0+(card I + 1)) by A2,Th23;
A6: card IF=card I+1 by Th15;
  then
A7: (card I+1) in dom pIF by Th25;
Y:  (ProgramPart s4)/.IC s4
 = s4.IC s4 by AMI_1:150;
  IsIF c= s3 by FUNCT_4:26;
  then pIF c= s4 by AMI_1:81,SCMPDS_4:57;
  then s4.(card I+1) = pIF.(card I+1) by A7,GRFUNC_1:8
    .=halt SCMPDS by A6,Th25;
  then
A8: CurInstr(ProgramPart s4,s4) = halt SCMPDS by A5,Y;
  now
    let k be Element of NAT;
    per cases;
    suppose
      0 < k;
      then 1+0 <= k by INT_1:20;
      hence IC Comput(ProgramPart(s3),s3,k) in dom pIF by A7,A5,A8,TX,AMI_1:52;
    end;
    suppose
      k = 0;
      then Comput(ProgramPart(s3),s3,k) = s3 by AMI_1:13;
      hence IC Comput(ProgramPart(s3),s3,k) in dom pIF by A2,SCMPDS_4:75;
    end;
  end;
  hence IF is_closed_on s by Def2;
  ProgramPart s3 halts_on s3 by A8,TX,AMI_1:146;
  hence thesis by Def3;
end;

theorem Th64:
  for s being State of SCMPDS,I being halt-free shiftable
Program of SCMPDS, a being Int_position,k1 being Integer st s.DataLoc(s.a,k1)=
0 & I is_closed_on s & I is_halting_on s holds IExec(if=0(a,k1,I),s) = IExec(I,
  s) +* Start-At((card I+1),SCMPDS)
proof
  let s be State of SCMPDS,I be halt-free shiftable Program of SCMPDS, a be
  Int_position,k1 be Integer;
  set b=DataLoc(s.a,k1);
  assume
A1: s.b = 0;
  set i = (a,k1)<>0_goto (card I + 1);
  set IF=if=0(a,k1,I), IsIF=Initialized stop IF, pI=stop I, IsI= Initialized
  pI, s2 = s +* IsI, s3 = s +* IsIF, s4 = Comput(ProgramPart( s3), s3,1);
A2: IC s3 = 0 by FUNCT_4:26,SCMPDS_5:18;
A3: not b in dom IsIF by SCMPDS_4:31;
A4: Comput(ProgramPart( s3), s3,0 + 1) = Following(ProgramPart s3,
Comput(ProgramPart(s3),s3,0)) by AMI_1:14
    .= Following(ProgramPart s3,s3) by AMI_1:13
    .= Exec(i,s3) by Th22;
  not a in dom IsIF by SCMPDS_4:31;
  then s3.DataLoc(s3.a,k1)=s3.b by FUNCT_4:12
    .=0 by A1,A3,FUNCT_4:12;
  then
A5: IC s4 = succ IC s3 by A4,SCMPDS_2:67
    .= (0+1) by A2;
A6: DataPart s2 = DataPart s3 by SCMPDS_4:24,36;
  now
    let a;
    thus s2.a = s3.a by A6,SCMPDS_4:23
      .= s4.a by A4,SCMPDS_2:67;
  end;
  then
A7: DataPart s2 = DataPart s4 by SCMPDS_4:23;
  assume
A8: I is_closed_on s;
  then
A9: I is_closed_on s2 by Th38;
  set SAl=Start-At((card I+1),SCMPDS);
A10: dom ProgramPart s = A by AMI_1:143;
A11: IsI c= s2 & Shift(pI,1) c= s4 by Lm5,FUNCT_4:26;
  assume
A12: I is_halting_on s;
  then
A13: ProgramPart s2 halts_on s2 by Def3;
T: ProgramPart s3 = ProgramPart Comput(
ProgramPart(s3),s3,1)
by AMI_1:123;
x: Comput(ProgramPart(s3),s3,LifeSpan(ProgramPart(s2),s2)+1)
 = Comput(ProgramPart(s3),Comput(ProgramPart(s3),s3,1),LifeSpan(ProgramPart(s2)
,s2))
by AMI_1:51;
TX4: ProgramPart s4 =
ProgramPart Comput(ProgramPart(s4),s4,LifeSpan(ProgramPart(s2),s2))
by AMI_1:123;
TX2: ProgramPart s2 = ProgramPart
Comput(ProgramPart(s2),s2,LifeSpan(ProgramPart(s2),
s2))
by AMI_1:123;
A14: CurInstr(ProgramPart s3,
Comput(ProgramPart(s3),s3,LifeSpan(ProgramPart(s2),s2)+1))
 =CurInstr(ProgramPart s4,
 Comput(ProgramPart(s4),s4,LifeSpan(ProgramPart(s2),s2))) by x,T
    .=CurInstr(ProgramPart s2,
    Comput(ProgramPart(s2),s2,LifeSpan(ProgramPart(s2),s2))) by A9,A11,A5,A7
,Th45,TX4,TX2
    .= halt SCMPDS by A13,AMI_1:def 46;
  then
A15: ProgramPart s3 halts_on s3 by AMI_1:146;
A16: CurInstr(ProgramPart s3,s3) = i by Th22;
  now
    let l be Element of NAT;
    assume
A17: l < LifeSpan(ProgramPart(s2),s2) + 1;
u: Comput(ProgramPart(s3),s3,0) = s3 by AMI_1:13;
    per cases;
    suppose
      l = 0;
      then CurInstr(ProgramPart (s3),Comput(ProgramPart(s3),s3,l))
       = CurInstr(ProgramPart s3,s3)
       by u;
      hence CurInstr(ProgramPart (s3),Comput(ProgramPart(s3),s3,l)) <>
       halt SCMPDS by A16,Th29;
    end;
    suppose
      l <> 0;
      then consider n be Nat such that
A18:  l = n + 1 by NAT_1:6;
      reconsider n as Element of NAT by ORDINAL1:def 13;
A19:  n < LifeSpan(ProgramPart(s2),s2) by A17,A18,XREAL_1:8;
      assume
A20:  CurInstr(ProgramPart s3,Comput(ProgramPart(s3),s3,l)) = halt SCMPDS;
T: ProgramPart s3 = ProgramPart Comput(ProgramPart(s3),s3,1)
by AMI_1:123;
TX2: ProgramPart s2 = ProgramPart Comput(ProgramPart(s2),s2,n)
by AMI_1:123;
TX4: ProgramPart s4 = ProgramPart Comput(ProgramPart(s4),s4,n)
by AMI_1:123;
x: Comput(ProgramPart(s3),s3,n+1)
 = Comput(ProgramPart(s3),Comput(ProgramPart(s3),s3,1),n) by AMI_1:51;
      CurInstr(ProgramPart s2,Comput(ProgramPart(s2),s2,n)) =
      CurInstr(ProgramPart s4,Comput(ProgramPart(s4),s4,n)) by A9,A11,A5,A7
,Th45,TX4,TX2
        .= halt SCMPDS by A18,A20,x,T;
      hence contradiction by A13,A19,AMI_1:def 46;
    end;
  end;
  then for l be Element of NAT st CurInstr(ProgramPart (s3),
  Comput(ProgramPart(s3),s3,l)) = halt SCMPDS
  holds LifeSpan(ProgramPart(s2),s2) + 1 <= l;
  then
A21: LifeSpan(ProgramPart(s3),s3) = LifeSpan(ProgramPart(s2),s2) + 1 by A14,A15
,AMI_1:def 46;
T: ProgramPart s3 = ProgramPart s4
by AMI_1:123;
A22: DataPart Result(ProgramPart(s2),s2) = DataPart Comput(ProgramPart( s2), s2
,LifeSpan(ProgramPart(s2),s2)) by A13,AMI_1:122
    .= DataPart Comput(ProgramPart( s3), s4,LifeSpan(ProgramPart(s2),s2)) by A9
,A11,A5,A7,Th45,T
    .= DataPart Comput(ProgramPart( s3), s3,LifeSpan(ProgramPart(s2),s2) + 1)
by AMI_1:51
    .= DataPart Result(ProgramPart(s3),s3) by A15,A21,AMI_1:122;
A23: now
    let x be set;
A24: IExec(I,s) = Result(ProgramPart(s2),s2) +* s | A by SCMPDS_4:def 8;
A25: IExec(IF,s) = Result(ProgramPart(s3),s3) +* s | A by SCMPDS_4:def 8;
A26: dom SAl = {IC SCMPDS} by FUNCOP_1:19;
    assume
A27: x in dom IExec(IF,s);
    per cases by A27,SCMPDS_4:20;
    suppose
A28:  x is Int_position;
      then x <> IC SCMPDS by SCMPDS_2:52;
      then
A29:  not x in dom SAl by A26,TARSKI:def 1;
A30: not x in dom (s | A) by A10,A28,SCMPDS_2:53;
      hence IExec(IF,s).x = (Result(ProgramPart(s3),s3)).x by A25,FUNCT_4:12
        .= (Result(ProgramPart(s2),s2)).x by A22,A28,SCMPDS_4:23
        .= IExec(I,s).x by A24,A30,FUNCT_4:12
        .= (IExec(I,s) +* SAl).x by A29,FUNCT_4:12;
    end;
    suppose
A31:  x = IC SCMPDS;
A32: not x in dom (s | A) by A10,A31,AMI_1:48;
      then
A33:  IC Result(ProgramPart(s2),s2) = IC IExec(I,s) by A24,A31,FUNCT_4:12
        .=  card I by A8,A12,Th48;
A34:  x in dom SAl by A26,A31,TARSKI:def 1;
T: ProgramPart s3 = ProgramPart s4
by AMI_1:123;
      thus IExec(IF,s).x = (Result(ProgramPart(s3),s3)).x by A25,A32,FUNCT_4:12
        .= Comput(ProgramPart( s3), s3,LifeSpan(ProgramPart(s2),s2) + 1).x by
A15,A21,AMI_1:122
        .= IC Comput(ProgramPart( s3), s4,LifeSpan(ProgramPart(s2),s2)) by A31,
AMI_1:51
        .= IC Comput(ProgramPart( s2), s2,LifeSpan(ProgramPart(s2),s2)) + 1
        by A9,A11,A5,A7,Th45,T
        .= IC Result(ProgramPart(s2),s2) + 1 by A13,AMI_1:122
        .= (Start-At((card I+1),SCMPDS)).IC SCMPDS by A33,FUNCOP_1:87
        .= (IExec(I,s) +* SAl).x by A31,A34,FUNCT_4:14;
    end;
    suppose
      x is Element of NAT;
      hence IExec(IF,s).x = (IExec(I,s) +* SAl).x by Th26;
    end;
  end;
  dom IExec(IF,s) = the carrier of SCMPDS by PARTFUN1:def 4
    .= dom (IExec(I,s) +* SAl) by PARTFUN1:def 4;
  hence thesis by A23,FUNCT_1:9;
end;

theorem Th65:
  for s being State of SCMPDS,I being Program of SCMPDS,a being
Int_position, k1 being Integer st s.DataLoc(s.a,k1)<> 0 holds IExec(if=0(a,k1,I
  ),s) = s +* Start-At((card I+1),SCMPDS)
proof
  let s be State of SCMPDS,I be Program of SCMPDS,a be Int_position, k1 be
  Integer;
  set b=DataLoc(s.a,k1);
  set IF=if=0(a,k1,I), pIF=stop IF, IsIF=Initialized pIF, s3 = s +* IsIF, s4 =
  Comput(ProgramPart( s3), s3,1);
  set i = (a,k1)<>0_goto (card I + 1);
  set SAl=Start-At((card I+1),SCMPDS);
A1: IC s3 = 0 by FUNCT_4:26,SCMPDS_5:18;
A2: not b in dom IsIF by SCMPDS_4:31;
  not a in dom IsIF by SCMPDS_4:31;
  then
A3: s3.DataLoc(s3.a,k1)=s3.b by FUNCT_4:12
    .= s.b by A2,FUNCT_4:12;
A4: Comput(ProgramPart( s3), s3,0 + 1) = Following(ProgramPart s3,
Comput(ProgramPart(s3),s3,0)) by AMI_1:14
    .= Following(ProgramPart s3,s3) by AMI_1:13
    .= Exec(i,s3) by Th22;
  assume
  s.b <> 0;
  then
A5: IC s4 = ICplusConst(s3,card I + 1) by A4,A3,SCMPDS_2:67
    .= (0+(card I + 1)) by A1,Th23;
  IsIF c= s3 by FUNCT_4:26;
  then
A6: pIF c= s4 by AMI_1:81,SCMPDS_4:57;
Y:  (ProgramPart s4)/.IC s4
 = s4.IC s4 by AMI_1:150;
TX: ProgramPart s3 = ProgramPart s4
by AMI_1:123;
A7: card IF=card I+1 by Th15;
  then (card I+1) in dom pIF by Th25;
  then s4.(card I+1) = pIF.(card I+1) by A6,GRFUNC_1:8
    .=halt SCMPDS by A7,Th25;
  then
A8: CurInstr(ProgramPart s3,s4) = halt SCMPDS by A5,Y,TX;
  then
A9: ProgramPart s3 halts_on s3 by AMI_1:146;
A10: CurInstr(ProgramPart s3,s3) = i by Th22;
  now
    let l be Element of NAT;
u: Comput(ProgramPart(s3),s3,0) = s3 by AMI_1:13;
    assume
    l < 1;
    then l <1+0;
    then l=0 by NAT_1:13;
    then CurInstr(ProgramPart s3,Comput(ProgramPart(s3),s3,l))
     = CurInstr(ProgramPart s3,s3) by u;
    hence CurInstr(ProgramPart (s3),Comput(ProgramPart(s3),s3,l))
     <> halt SCMPDS by A10,Th29;
  end;
  then for l be Element of NAT st CurInstr(ProgramPart (s3),
  Comput(ProgramPart(s3),s3,l)) = halt SCMPDS
  holds 1 <= l;
  then LifeSpan(ProgramPart(s3),s3) = 1 by A8,A9,AMI_1:def 46;
  then
A11: s4 = Result(ProgramPart(s3),s3) by A9,AMI_1:122;
A12: dom ProgramPart s = A by AMI_1:143;
A13: now
A14: dom SAl = {IC SCMPDS} by FUNCOP_1:19;
    let x be set;
A15: IExec(IF,s) = Result(ProgramPart(s3),s3) +* s | A by SCMPDS_4:def 8;
    assume
A16: x in dom IExec(IF,s);
    per cases by A16,SCMPDS_4:20;
    suppose
A17:  x is Int_position;
      then x <> IC SCMPDS by SCMPDS_2:52;
      then
A18:  not x in dom SAl by A14,TARSKI:def 1;
      not x in dom (s | A) by A12,A17,SCMPDS_2:53;
      hence IExec(IF,s).x = s4.x by A11,A15,FUNCT_4:12
        .= s3.x by A4,A17,SCMPDS_2:67
        .= s.x by A17,SCMPDS_5:19
        .= (s +* SAl).x by A18,FUNCT_4:12;
    end;
    suppose
A19:  x = IC SCMPDS;
      not x in dom (s | A) by A12,A19,AMI_1:48;
      hence IExec(IF,s).x = (card I + 1) by A5,A11,A15,A19,FUNCT_4:12
        .= (s +* SAl).x by A19,FUNCT_4:121;
    end;
    suppose
      x is Element of NAT;
      hence IExec(IF,s).x = (s +* SAl).x by Th27;
    end;
  end;
  dom IExec(IF,s) = the carrier of SCMPDS by PARTFUN1:def 4
    .= dom (s +* SAl) by PARTFUN1:def 4;
  hence thesis by A13,FUNCT_1:9;
end;

registration
  let I be shiftable parahalting Program of SCMPDS, a be Int_position,k1 be
  Integer;
  cluster if=0(a,k1,I) -> shiftable parahalting;
  correctness
  proof
    set i = (a,k1)<>0_goto (card I +1);
    set IF=if=0(a,k1,I), IsIF=Initialized stop IF;
    IF =Load i ';' I by SCMPDS_4:def 4;
    hence IF is shiftable;
    now
      let s be State of SCMPDS;
      assume
      IsIF c= s;
      then
A1:   s = s +* IsIF by FUNCT_4:79;
A2:   I is_closed_on s & I is_halting_on s by Th34,Th35;
      per cases;
      suppose
        s.DataLoc(s.a,k1)= 0;
        then IF is_halting_on s by A2,Th62;
        hence ProgramPart s halts_on s by A1,Def3;
      end;
      suppose
        s.DataLoc(s.a,k1) <> 0;
        then IF is_halting_on s by Th63;
        hence ProgramPart s halts_on s by A1,Def3;
      end;
    end;
    then IsIF is halting by AMI_1:def 26;
    hence thesis by SCMPDS_4:def 10;
  end;
end;

registration
  let I be halt-free Program of SCMPDS, a be Int_position,k1 be Integer;
  cluster if=0(a,k1,I) -> halt-free;
  coherence;
end;

theorem
  for s being State of SCMPDS,I being halt-free shiftable parahalting
Program of SCMPDS,a being Int_position,k1 being Integer holds IC IExec(if=0(a,
  k1,I),s) =  (card I + 1)
proof
  let s be State of SCMPDS,I be halt-free shiftable parahalting Program of
  SCMPDS,a be Int_position,k1 be Integer;
  set IF=if=0(a,k1,I);
A1: I is_closed_on s & I is_halting_on s by Th34,Th35;
  per cases;
  suppose
    s.DataLoc(s.a,k1) = 0;
    then IExec(IF,s) =IExec(I,s) +* Start-At((card I+1),SCMPDS)
    by A1,Th64;
    hence thesis by FUNCT_4:121;
  end;
  suppose
    s.DataLoc(s.a,k1) <> 0;
    then IExec(IF,s) =s +* Start-At((card I+1),SCMPDS) by Th65;
    hence thesis by FUNCT_4:121;
  end;
end;

theorem
  for s being State of SCMPDS,I being halt-free shiftable parahalting
Program of SCMPDS,a,b being Int_position,k1 being Integer st s.DataLoc(s.a,k1)=
  0 holds IExec(if=0(a,k1,I),s).b = IExec(I,s).b
proof
  let s be State of SCMPDS,I be halt-free shiftable parahalting Program of
  SCMPDS,a,b be Int_position,k1 be Integer;
  assume
A1: s.DataLoc(s.a,k1)=0;
A2: not b in dom Start-At((card I+1),SCMPDS) by SCMPDS_4:59;
  I is_closed_on s & I is_halting_on s by Th34,Th35;
  then IExec(if=0(a,k1,I),s) = IExec(I,s) +* Start-At((card I+1),SCMPDS)
  by A1,Th64;
  hence thesis by A2,FUNCT_4:12;
end;

theorem
  for s being State of SCMPDS,I being Program of SCMPDS,a,b being
Int_position, k1 being Integer st s.DataLoc(s.a,k1)<> 0 holds IExec(if=0(a,k1,I
  ),s).b = s.b
proof
  let s be State of SCMPDS,I be Program of SCMPDS,a,b be Int_position, k1 be
  Integer;
  assume
  s.DataLoc(s.a,k1)<>0;
  then
A1: IExec(if=0(a,k1,I),s) = s +* Start-At((card I+1),SCMPDS) by Th65;
  not b in dom Start-At((card I+1),SCMPDS) by SCMPDS_4:59;
  hence thesis by A1,FUNCT_4:12;
end;

Lm8: card (i ';' j ';' I)=card I+2
proof
  thus card (i ';' j ';' I) =card (i ';' (j ';' I)) by SCMPDS_4:52
    .=card (j ';' I)+1 by Th15
    .=card I+1+1 by Th15
    .=card I+2;
end;

begin :: The computation of "if var<>0 then block"

theorem
  card if<>0(a,k1,I) = card I + 2 by Lm8;

Lm9:  0 in dom (i ';' j ';' I) &  1 in dom (i ';' j ';' I)
proof
  set ci=card (i ';' j ';' I);
  ci=card I + 2 by Lm8;
  then 2 <= ci by NAT_1:11;
  then 1 < ci by XXREAL_0:2;
  hence thesis by AFINSQ_1:70;
end;

theorem
   0 in dom if<>0(a,k1,I) &  1 in dom if<>0(a,k1,I) by Lm9;

Lm10: (i ';' j ';' I). 0=i & (i ';' j ';' I). 1=j
proof
  set jI=j ';' I;
A1: i ';' j ';' I =i ';' jI by SCMPDS_4:52
    .=Load i ';' jI by SCMPDS_4:def 4;
   0 in dom Load i by SCMPDS_5:2;
  hence (i ';' j ';' I). 0 =(Load i). 0 by A1,SCMPDS_4:37
    .=i by SCMPDS_5:4;
A2:  0 in dom Load j by SCMPDS_5:2;
  card jI=card I+1 by Th15;
  then
A3: card Load i=1 &  0 in dom jI by AFINSQ_1:70,SCMPDS_5:6;
  thus (i ';' j ';' I). 1 =(Load i ';' jI). (0+1) by A1
    .=jI. 0 by A3,SCMPDS_4:38
    .=(Load j ';' I). 0 by SCMPDS_4:def 4
    .=(Load j). 0 by A2,SCMPDS_4:37
    .=j by SCMPDS_5:4;
end;

theorem
  if<>0(a,k1,I). 0 = (a,k1)<>0_goto 2 & if<>0(a,k1,I). 1 =
  goto (card I + 1) by Lm10;

theorem Th72:
  for s being State of SCMPDS, I being shiftable Program of SCMPDS
  , a being Int_position,k1 being Integer st s.DataLoc(s.a,k1)<>0 & I
is_closed_on s & I is_halting_on s holds if<>0(a,k1,I) is_closed_on s & if<>0(a
  ,k1,I) is_halting_on s
proof
  let s be State of SCMPDS, I be shiftable Program of SCMPDS, a be
  Int_position,k1 be Integer;
  set b=DataLoc(s.a,k1);
  set IF=if<>0(a,k1,I), pIF=stop IF, IsIF=Initialized pIF, pI=stop I, IsI=
  Initialized pI, s2 = s +* IsI, s3 = s +* IsIF, s4 = Comput(ProgramPart(s3),s3
,1);
  set i = (a,k1)<>0_goto 2, j = goto (card I + 1);
A1: IF = i ';' (j ';' I) by SCMPDS_4:52;
A2: Comput(ProgramPart( s3), s3,0 + 1) = Following(ProgramPart s3,
Comput(ProgramPart(s3),s3,0)) by AMI_1:14
    .= Following(ProgramPart s3,s3) by AMI_1:13
    .= Exec(i,s3) by A1,Th22;
A3: DataPart s2 = DataPart s3 by SCMPDS_4:24,36;
  now
    let a;
    thus s2.a = s3.a by A3,SCMPDS_4:23
      .= s4.a by A2,SCMPDS_2:67;
  end;
  then
A4: DataPart s2 = DataPart s4 by SCMPDS_4:23;
A5: not b in dom IsIF by SCMPDS_4:31;
  not a in dom IsIF by SCMPDS_4:31;
  then
A6: s3.DataLoc(s3.a,k1)=s3.b by FUNCT_4:12
    .= s.b by A5,FUNCT_4:12;
A7: IC s3 = 0 by FUNCT_4:26,SCMPDS_5:18;
  assume
  s.b <> 0;
  then
A8: IC s4 = ICplusConst(s3,2) by A2,A6,SCMPDS_2:67
    .= (0+2) by A7,Th23;
  assume
A9: I is_closed_on s;
  then
A10: I is_closed_on s2 by Th38;
  assume
  I is_halting_on s;
  then
A11: ProgramPart s2 halts_on s2 by Def3;
A12: IsI c= s2 & Shift(pI,2) c= s4 by Lm6,FUNCT_4:26;
A13:  0 in dom pIF by SCMPDS_4:75;
  now
    let k be Element of NAT;
    per cases;
    suppose
      0 < k;
      then consider k1 being Nat such that
A14:  k1 + 1 = k by NAT_1:6;
      reconsider k1 as Element of NAT by ORDINAL1:def 13;
      reconsider m = IC Comput(ProgramPart( s2), s2,k1) as Element of NAT;
A15:  card pIF = 1+ card IF by SCMPDS_5:7
        .= 1+(card I +2) by Lm8
        .= 1+card I +2
        .=card pI+2 by SCMPDS_5:7;
       m in dom pI by A9,Def2;
      then m < card pI by AFINSQ_1:70;
      then
A16:  m+2 < card pIF by A15,XREAL_1:8;
T: ProgramPart s3 = ProgramPart s4
by AMI_1:123;
      IC Comput(ProgramPart(s3),s3,k) = IC Comput(ProgramPart( s3), s4,k1) by
A14,AMI_1:51
        .=  (m + 2) by A10,A12,A8,A4,Th45,T;
      hence IC Comput(ProgramPart(s3),s3,k) in dom pIF by A16,AFINSQ_1:70;
    end;
    suppose
      k = 0;
      hence IC Comput(ProgramPart(s3),s3,k) in dom pIF by A13,A7,AMI_1:13;
    end;
  end;
  hence IF is_closed_on s by Def2;
T: ProgramPart s3 = ProgramPart Comput(
ProgramPart(s3),s3,1)
by AMI_1:123;
x: Comput(ProgramPart(s3),s3,LifeSpan(ProgramPart(s2),s2)+1)
= Comput(ProgramPart(s3),Comput(ProgramPart(s3),s3,1),LifeSpan(ProgramPart(s2),
s2))
by AMI_1:51;
TX4: ProgramPart s4 = ProgramPart
Comput(ProgramPart(s4),s4,LifeSpan(ProgramPart(s2),s2)
)
by AMI_1:123;
TX2: ProgramPart s2 = ProgramPart
Comput(ProgramPart(s2),s2,LifeSpan(ProgramPart(s2),
s2))
by AMI_1:123;
  CurInstr(ProgramPart s3,
  Comput(ProgramPart(s3),s3,LifeSpan(ProgramPart(s2),s2)+1))
   =CurInstr(ProgramPart s4,
   Comput(ProgramPart(s4),s4,LifeSpan(ProgramPart(s2),s2))) by x,T
    .=CurInstr(ProgramPart s2,
    Comput(ProgramPart(s2),s2,LifeSpan(ProgramPart(s2),s2))) by A10,A12,A8,A4
,Th45,TX2,TX4
    .= halt SCMPDS by A11,AMI_1:def 46;
  then ProgramPart s3 halts_on s3 by AMI_1:146;
  hence thesis by Def3;
end;

theorem Th73:
  for s being State of SCMPDS,I being Program of SCMPDS, a being
  Int_position, k1 being Integer st s.DataLoc(s.a,k1)= 0 holds if<>0(a,k1,I)
  is_closed_on s & if<>0(a,k1,I) is_halting_on s
proof
  let s be State of SCMPDS,I be Program of SCMPDS, a be Int_position,k1 be
  Integer;
  set b=DataLoc(s.a,k1);
  assume
A1: s.b = 0;
  set IF=if<>0(a,k1,I), pIF=stop IF, IsIF=Initialized pIF, s3 = s +* IsIF, s4
  = Comput(ProgramPart(s3),s3,1), s5 = Comput(ProgramPart(s3),s3,2);
A2: not b in dom IsIF by SCMPDS_4:31;
  not a in dom IsIF by SCMPDS_4:31;
  then
A3: s3.DataLoc(s3.a,k1)=s3.b by FUNCT_4:12
    .=0 by A1,A2,FUNCT_4:12;
A4: IsIF c= s3 by FUNCT_4:26;
  then
A5: pIF c= s4 by AMI_1:81,SCMPDS_4:57;
  set i = (a,k1)<>0_goto 2, j = goto (card I + 1);
A6: IF =i ';' (j ';' I) by SCMPDS_4:52;
A7: IC s3 = 0 by FUNCT_4:26,SCMPDS_5:18;
  Comput(ProgramPart( s3), s3,0 + 1) = Following(ProgramPart s3,
  Comput(ProgramPart(s3),s3,0)) by AMI_1:14
    .= Following(ProgramPart s3,s3) by AMI_1:13
    .= Exec(i,s3) by A6,Th22;
  then
A8: IC s4 = succ IC s3 by A3,SCMPDS_2:67
    .= (0+1) by A7;
A9:  1 in dom IF by Lm9;
  then  1 in dom pIF by Th18;
  then
A10: s4. 1 = pIF. 1 by A5,GRFUNC_1:8
    .=IF. 1 by A9,Th19
    .=j by Lm10;
A11: card IF=card I+2 by Lm8;
  then
A12: (card I+2) in dom pIF by Th25;
Y:  (ProgramPart s4)/.IC s4
 = s4.IC s4 by AMI_1:150;
T: ProgramPart s3 = ProgramPart s4
by AMI_1:123;
  Comput(ProgramPart( s3), s3,1 + 1) = Following(ProgramPart s3,s4) by AMI_1:14
    .= Exec(j,s4) by A8,A10,Y,T;
  then
A13: IC s5 = ICplusConst(s4,card I+1) by SCMPDS_2:66
    .= (card I+1+1) by A8,Th23
    .= (card I+(1+1));
Y:  (ProgramPart s5)/.IC s5
 = s5.IC s5 by AMI_1:150;
TX: ProgramPart s3 = ProgramPart s5
by AMI_1:123;
  pIF c= s5 by A4,AMI_1:81,SCMPDS_4:57;
  then s5.(card I+2) = pIF.(card I+2) by A12,GRFUNC_1:8
    .=halt SCMPDS by A11,Th25;
  then
A14: CurInstr(ProgramPart s3,s5) = halt SCMPDS by A13,Y,TX;
  now
    let k be Element of NAT;
A15: k = 0 or 0 + 1 <= k by INT_1:20;
    per cases by A15,XXREAL_0:1;
    suppose
      k = 0;
      then Comput(ProgramPart(s3),s3,k) = s3 by AMI_1:13;
      hence IC Comput(ProgramPart(s3),s3,k) in dom pIF by A7,SCMPDS_4:75;
    end;
    suppose
      k = 1;
      hence IC Comput(ProgramPart(s3),s3,k) in dom pIF by A9,A8,Th18;
    end;
    suppose
      1 < k;
      then 1+1 <= k by INT_1:20;
      hence IC Comput(ProgramPart(s3),s3,k) in dom pIF
      by A12,A13,A14,AMI_1:52;
    end;
  end;
  hence IF is_closed_on s by Def2;
  ProgramPart s3 halts_on s3 by A14,AMI_1:146;
  hence thesis by Def3;
end;

theorem Th74:
  for s being State of SCMPDS,I being halt-free shiftable
  Program of SCMPDS, a being Int_position,k1 being Integer st s.DataLoc(s.a,k1)
  <> 0 & I is_closed_on s & I is_halting_on s holds IExec(if<>0(a,k1,I),s) =
  IExec(I,s) +* Start-At((card I+2),SCMPDS)
proof
  let s be State of SCMPDS,I be halt-free shiftable Program of SCMPDS, a be
  Int_position,k1 be Integer;
  set b=DataLoc(s.a,k1);
  set IF=if<>0(a,k1,I), IsIF=Initialized stop IF, pI=stop I, IsI= Initialized
  pI, s2 = s +* IsI, s3 = s +* IsIF, s4 = Comput(ProgramPart( s3), s3,1);
  set i = (a,k1)<>0_goto 2, j = goto (card I + 1);
  set SAl=Start-At((card I+2),SCMPDS);
A1: IF=i ';' (j ';' I) by SCMPDS_4:52;
A2: Comput(ProgramPart( s3), s3,0 + 1) = Following(ProgramPart s3,
Comput(ProgramPart(s3),s3,0)) by AMI_1:14
    .= Following(ProgramPart s3,s3) by AMI_1:13
    .= Exec(i,s3) by A1,Th22;
A3: not b in dom IsIF by SCMPDS_4:31;
  not a in dom IsIF by SCMPDS_4:31;
  then
A4: s3.DataLoc(s3.a,k1)=s3.b by FUNCT_4:12
    .= s.b by A3,FUNCT_4:12;
A5: IC s3 = 0 by FUNCT_4:26,SCMPDS_5:18;
A6: IsI c= s2 & Shift(pI,2) c= s4 by Lm6,FUNCT_4:26;
A7: DataPart s2 = DataPart s3 by SCMPDS_4:24,36;
  now
    let a;
    thus s2.a = s3.a by A7,SCMPDS_4:23
      .= s4.a by A2,SCMPDS_2:67;
  end;
  then
A8: DataPart s2 = DataPart s4 by SCMPDS_4:23;
  assume
  s.b <> 0;
  then
A9: IC s4 = ICplusConst(s3,2) by A2,A4,SCMPDS_2:67
    .= (0+2) by A5,Th23;
A10: dom ProgramPart s = A by AMI_1:143;
  assume
A11: I is_closed_on s;
  then
A12: I is_closed_on s2 by Th38;
  assume
A13: I is_halting_on s;
  then
A14: ProgramPart s2 halts_on s2 by Def3;
T: ProgramPart s3 = ProgramPart Comput(
ProgramPart(s3),s3,1)
by AMI_1:123;
x: Comput(ProgramPart(s3),s3,LifeSpan(ProgramPart(s2),s2)+1)
 = Comput(ProgramPart(s3),Comput(ProgramPart(s3),s3,1),LifeSpan(ProgramPart(s2)
,s2))
by AMI_1:51;
TX4: ProgramPart s4 = ProgramPart
Comput(ProgramPart(s4),s4,LifeSpan(ProgramPart(s2),s2))
by AMI_1:123;
TX2: ProgramPart s2 = ProgramPart
Comput(ProgramPart(s2),s2,LifeSpan(ProgramPart(s2),
s2))
by AMI_1:123;
A15: CurInstr(ProgramPart s3,
Comput(ProgramPart(s3),s3,LifeSpan(ProgramPart(s2),s2)+1))
 =CurInstr(ProgramPart s4,
 Comput(ProgramPart(s4),s4,LifeSpan(ProgramPart(s2),s2))) by x,T
    .=CurInstr(ProgramPart s2,
    Comput(ProgramPart(s2),s2,LifeSpan(ProgramPart(s2),s2))) by A12,A6,A9,A8
,Th45,TX2,TX4
    .= halt SCMPDS by A14,AMI_1:def 46;
  then
A16: ProgramPart s3 halts_on s3 by AMI_1:146;
A17: CurInstr(ProgramPart s3,s3) = i by A1,Th22;
  now
    let l be Element of NAT;
    assume
A18: l < LifeSpan(ProgramPart(s2),s2) + 1;
u: Comput(ProgramPart(s3),s3,0) = s3 by AMI_1:13;
    per cases;
    suppose
      l = 0;
      then CurInstr(ProgramPart s3,Comput(ProgramPart(s3),s3,l))
       = CurInstr(ProgramPart s3,s3)
       by u;
      hence CurInstr(ProgramPart (s3),Comput(ProgramPart(s3),s3,l))
       <> halt SCMPDS by A17,Th29;
    end;
    suppose
      l <> 0;
      then consider n be Nat such that
A19:  l = n + 1 by NAT_1:6;
      reconsider n as Element of NAT by ORDINAL1:def 13;
A20:  n < LifeSpan(ProgramPart(s2),s2) by A18,A19,XREAL_1:8;
      assume
A21:  CurInstr(ProgramPart (s3),Comput(ProgramPart(s3),s3,l)) = halt SCMPDS;
T: ProgramPart s3 = ProgramPart Comput(ProgramPart(s3),
s3,1)
by AMI_1:123;
TX2: ProgramPart s2 = ProgramPart Comput(ProgramPart(s2),s2,n)
by AMI_1:123;
TX4: ProgramPart s4 = ProgramPart Comput(ProgramPart(s4),s4,n)
by AMI_1:123;
x: Comput(ProgramPart(s3),s3,n+1)
= Comput(ProgramPart(s3),Comput(ProgramPart(s3),s3,1),n) by AMI_1:51;
      CurInstr(ProgramPart s2,Comput(ProgramPart(s2),s2,n)) =
      CurInstr(ProgramPart s4,Comput(ProgramPart(s4),s4,n)) by A12,A6,A9,A8
,Th45,TX2,TX4
        .= halt SCMPDS by A19,A21,x,T;
      hence contradiction by A14,A20,AMI_1:def 46;
    end;
  end;
  then for l be Element of NAT st CurInstr(ProgramPart (s3),
  Comput(ProgramPart(s3),s3,l)) = halt SCMPDS
  holds LifeSpan(ProgramPart(s2),s2) + 1 <= l;
  then
A22: LifeSpan(ProgramPart(s3),s3) = LifeSpan(ProgramPart(s2),s2) + 1 by A15,A16
,AMI_1:def 46;
T: ProgramPart s3 = ProgramPart s4
by AMI_1:123;
A23: DataPart Result(ProgramPart(s2),s2) = DataPart Comput(ProgramPart( s2), s2
,LifeSpan(ProgramPart(s2),s2)) by A14,AMI_1:122
    .= DataPart Comput(ProgramPart( s3), s4,LifeSpan(ProgramPart(s2),s2)) by
A12,A6,A9,A8,Th45,T
    .= DataPart Comput(ProgramPart( s3), s3,LifeSpan(ProgramPart(s2),s2) + 1)
by AMI_1:51
    .= DataPart Result(ProgramPart(s3),s3) by A16,A22,AMI_1:122;
A24: now
    let x be set;
A25: IExec(I,s) = Result(ProgramPart(s2),s2) +* s | A by SCMPDS_4:def 8;
A26: IExec(IF,s) = Result(ProgramPart(s3),s3) +* s | A by SCMPDS_4:def 8;
A27: dom Start-At((card I+2),SCMPDS) = {IC SCMPDS} by FUNCOP_1:19;
    assume
A28: x in dom IExec(IF,s);
    per cases by A28,SCMPDS_4:20;
    suppose
A29:  x is Int_position;
      then x <> IC SCMPDS by SCMPDS_2:52;
      then
A30:  not x in dom SAl by A27,TARSKI:def 1;
A31: not x in dom (s | A) by A10,A29,SCMPDS_2:53;
      hence IExec(IF,s).x = (Result(ProgramPart(s3),s3)).x by A26,FUNCT_4:12
        .= (Result(ProgramPart(s2),s2)).x by A23,A29,SCMPDS_4:23
        .= IExec(I,s).x by A25,A31,FUNCT_4:12
        .= (IExec(I,s) +* SAl).x by A30,FUNCT_4:12;
    end;
    suppose
A32:  x = IC SCMPDS;
A33: not x in dom (s | A) by A10,A32,AMI_1:48;
      then
A34:  IC Result(ProgramPart(s2),s2) = IC IExec(I,s) by A25,A32,FUNCT_4:12
        .=  card I by A11,A13,Th48;
A35:  x in dom SAl by A27,A32,TARSKI:def 1;
T: ProgramPart s3 = ProgramPart s4
by AMI_1:123;
      thus IExec(IF,s).x = (Result(ProgramPart(s3),s3)).x by A26,A33,FUNCT_4:12
        .= Comput(ProgramPart( s3), s3,LifeSpan(ProgramPart(s2),s2) + 1).x by
A16,A22,AMI_1:122
        .= IC Comput(ProgramPart( s3), s4,LifeSpan(ProgramPart(s2),s2)) by A32,
AMI_1:51
        .= IC Comput(ProgramPart( s2), s2,LifeSpan(ProgramPart(s2),s2)) + 2
        by A12,A6,A9,A8,Th45,T
        .= IC Result(ProgramPart(s2),s2) + 2 by A14,AMI_1:122
        .= SAl.IC SCMPDS by A34,FUNCOP_1:87
        .= (IExec(I,s) +* SAl).x by A32,A35,FUNCT_4:14;
    end;
    suppose
      x is Element of NAT;
      hence IExec(IF,s).x = (IExec(I,s) +* SAl).x by Th26;
    end;
  end;
  dom IExec(IF,s) = the carrier of SCMPDS by PARTFUN1:def 4
    .= dom (IExec(I,s) +* Start-At((card I+2),SCMPDS)) by PARTFUN1:def 4;
  hence thesis by A24,FUNCT_1:9;
end;

theorem Th75:
  for s being State of SCMPDS,I being Program of SCMPDS,a being
Int_position, k1 being Integer st s.DataLoc(s.a,k1)= 0 holds IExec(if<>0(a,k1,I
  ),s) = s +* Start-At((card I+2),SCMPDS)
proof
  let s be State of SCMPDS,I be Program of SCMPDS,a be Int_position, k1 be
  Integer;
  set b=DataLoc(s.a,k1);
  assume
A1: s.b = 0;
  set SAl=Start-At((card I+2),SCMPDS);
  set i = (a,k1)<>0_goto 2, j = goto (card I + 1);
  set IF=if<>0(a,k1,I), pIF=stop IF, IsIF=Initialized pIF, s3 = s +* IsIF, s4
  = Comput(ProgramPart(s3),s3,1), s5 = Comput(ProgramPart(s3),s3,2);
A2: IF =i ';' (j ';' I) by SCMPDS_4:52;
A3: IsIF c= s3 by FUNCT_4:26;
  then
A4: pIF c= s4 by AMI_1:81,SCMPDS_4:57;
A5: pIF c= s5 by A3,AMI_1:81,SCMPDS_4:57;
A6: not b in dom IsIF by SCMPDS_4:31;
A7: IC s3 = 0 by FUNCT_4:26,SCMPDS_5:18;
A8: Comput(ProgramPart( s3), s3,0 + 1) = Following(ProgramPart s3,
Comput(ProgramPart(s3),s3,0)) by AMI_1:14
    .= Following(ProgramPart s3,s3) by AMI_1:13
    .= Exec(i,s3) by A2,Th22;
  not a in dom IsIF by SCMPDS_4:31;
  then s3.DataLoc(s3.a,k1)=s3.b by FUNCT_4:12
    .=0 by A1,A6,FUNCT_4:12;
  then
A9: IC s4 = succ IC s3 by A8,SCMPDS_2:67
    .= (0+1) by A7;
A10:  1 in dom IF by Lm9;
  then  1 in dom pIF by Th18;
  then
A11: s4. 1 = pIF. 1 by A4,GRFUNC_1:8
    .=IF. 1 by A10,Th19
    .=j by Lm10;
Y:  (ProgramPart s4)/.IC s4
 = s4.IC s4 by AMI_1:150;
T: ProgramPart s3 = ProgramPart s4
by AMI_1:123;
A12: Comput(ProgramPart( s3), s3,1 + 1) = Following(ProgramPart s3,s4) by
AMI_1:14
    .= Exec(j,s4) by A9,A11,Y,T;
  then
A13: IC s5 = ICplusConst(s4,card I+1) by SCMPDS_2:66
    .= (card I+1+1) by A9,Th23
    .= (card I+(1+1));
Y:  (ProgramPart s5)/.IC s5
 = s5.IC s5 by AMI_1:150;
TX: ProgramPart s3 = ProgramPart s5
by AMI_1:123;
A14: card IF=card I+2 by Lm8;
  then (card I+2) in dom pIF by Th25;
  then s5.(card I+2) = pIF.(card I+2) by A5,GRFUNC_1:8
    .=halt SCMPDS by A14,Th25;
  then
A15: CurInstr(ProgramPart s3,s5) = halt SCMPDS by A13,Y,TX;
  then
A16: ProgramPart s3 halts_on s3 by AMI_1:146;
A17: CurInstr(ProgramPart s3,s3) = i by A2,Th22;
  now
    let l be Element of NAT;
    assume
    l < 1+1;
    then
A18: l <= 1 by NAT_1:13;
u: Comput(ProgramPart(s3),s3,0) = s3 by AMI_1:13;
Y:  (ProgramPart Comput(ProgramPart(s3),s3,l))/.IC Comput(ProgramPart(s3),s3,l)
 = Comput(ProgramPart(s3),s3,l).IC Comput(ProgramPart(s3),s3,l) by AMI_1:150;
TX3: ProgramPart s3 = ProgramPart Comput(ProgramPart(s3),s3,l)
by AMI_1:123;
    per cases by A18,NAT_1:26;
    suppose
      l=0;
      then CurInstr(ProgramPart s3,Comput(ProgramPart(s3),s3,l))
       = CurInstr(ProgramPart s3,s3)
       by u;
      hence CurInstr(ProgramPart (s3),Comput(ProgramPart(s3),s3,l))
       <> halt SCMPDS by A17,Th29;
    end;
    suppose
      l=1;
      hence CurInstr(ProgramPart (s3),Comput(ProgramPart(s3),s3,l))
       <> halt SCMPDS by A9,A11,Y,TX3,SCMPDS_2:85;
    end;
  end;
  then for l be Element of NAT st CurInstr(ProgramPart (s3),
  Comput(ProgramPart(s3),s3,l)) = halt SCMPDS
  holds 2 <= l;
  then LifeSpan(ProgramPart(s3),s3) = 2 by A15,A16,AMI_1:def 46;
  then
A19: s5 = Result(ProgramPart(s3),s3) by A16,AMI_1:122;
A20: dom ProgramPart s = A by AMI_1:143;
A21: now
A22: dom SAl = {IC SCMPDS} by FUNCOP_1:19;
    let x be set;
A23: IExec(IF,s) = Result(ProgramPart(s3),s3) +* s | A by SCMPDS_4:def 8;
    assume
A24: x in dom IExec(IF,s);
    per cases by A24,SCMPDS_4:20;
    suppose
A25:  x is Int_position;
      then x <> IC SCMPDS by SCMPDS_2:52;
      then
A26:  not x in dom SAl by A22,TARSKI:def 1;
      not x in dom (s | A) by A20,A25,SCMPDS_2:53;
      hence IExec(IF,s).x = s5.x by A19,A23,FUNCT_4:12
        .= s4.x by A12,A25,SCMPDS_2:66
        .= s3.x by A8,A25,SCMPDS_2:67
        .= s.x by A25,SCMPDS_5:19
        .= (s +* SAl).x by A26,FUNCT_4:12;
    end;
    suppose
A27:  x = IC SCMPDS;
      not x in dom (s | A) by A20,A27,AMI_1:48;
      hence IExec(IF,s).x = (card I + 2) by A13,A19,A23,A27,FUNCT_4:12
        .= (s +* Start-At((card I+2),SCMPDS)).x by A27,FUNCT_4:121;
    end;
    suppose
      x is Element of NAT;
      hence IExec(IF,s).x = (s +* SAl).x by Th27;
    end;
  end;
  dom IExec(IF,s) = the carrier of SCMPDS by PARTFUN1:def 4
    .= dom (s +* SAl) by PARTFUN1:def 4;
  hence thesis by A21,FUNCT_1:9;
end;

registration
  let I be shiftable parahalting Program of SCMPDS, a be Int_position,k1 be
  Integer;
  cluster if<>0(a,k1,I) -> shiftable parahalting;
  correctness
  proof
    set i = (a,k1)<>0_goto 2, j = goto (card I + 1);
    set IF=if<>0(a,k1,I), IsIF=Initialized stop IF;
    IF =Load i ';' Load j ';' I by SCMPDS_4:def 6;
    hence IF is shiftable;
    now
      let s be State of SCMPDS;
      assume
      IsIF c= s;
      then
A1:   s = s +* IsIF by FUNCT_4:79;
A2:   I is_closed_on s & I is_halting_on s by Th34,Th35;
      per cases;
      suppose
        s.DataLoc(s.a,k1)<>0;
        then IF is_halting_on s by A2,Th72;
        hence ProgramPart s halts_on s by A1,Def3;
      end;
      suppose
        s.DataLoc(s.a,k1) = 0;
        then IF is_halting_on s by Th73;
        hence ProgramPart s halts_on s by A1,Def3;
      end;
    end;
    then IsIF is halting by AMI_1:def 26;
    hence thesis by SCMPDS_4:def 10;
  end;
end;

registration
  let I be halt-free Program of SCMPDS, a be Int_position,k1 be Integer;
  cluster if<>0(a,k1,I) -> halt-free;
  coherence;
end;

theorem
  for s being State of SCMPDS,I being halt-free shiftable parahalting
Program of SCMPDS,a being Int_position,k1 being Integer holds IC IExec(if<>0(a,
  k1,I),s) =  (card I + 2)
proof
  let s be State of SCMPDS,I be halt-free shiftable parahalting Program of
  SCMPDS,a be Int_position,k1 be Integer;
  set IF=if<>0(a,k1,I);
A1: I is_closed_on s & I is_halting_on s by Th34,Th35;
  per cases;
  suppose
    s.DataLoc(s.a,k1) <> 0;
    then IExec(IF,s) =IExec(I,s) +* Start-At((card I+2),SCMPDS)
    by A1,Th74;
    hence thesis by FUNCT_4:121;
  end;
  suppose
    s.DataLoc(s.a,k1) = 0;
    then IExec(IF,s) =s +* Start-At((card I+2),SCMPDS) by Th75;
    hence thesis by FUNCT_4:121;
  end;
end;

theorem
  for s being State of SCMPDS,I being halt-free shiftable parahalting
Program of SCMPDS,a,b being Int_position,k1 being Integer st s.DataLoc(s.a,k1)
  <> 0 holds IExec(if<>0(a,k1,I),s).b = IExec(I,s).b
proof
  let s be State of SCMPDS,I be halt-free shiftable parahalting Program of
  SCMPDS,a,b be Int_position,k1 be Integer;
  assume
A1: s.DataLoc(s.a,k1)<>0;
A2: not b in dom Start-At((card I+2),SCMPDS) by SCMPDS_4:59;
  I is_closed_on s & I is_halting_on s by Th34,Th35;
  then IExec(if<>0(a,k1,I),s) = IExec(I,s) +* Start-At((card I+2),SCMPDS)
   by A1,Th74;
  hence thesis by A2,FUNCT_4:12;
end;

theorem
  for s being State of SCMPDS,I being Program of SCMPDS,a,b being
Int_position, k1 being Integer st s.DataLoc(s.a,k1)= 0 holds IExec(if<>0(a,k1,I
  ),s).b = s.b
proof
  let s be State of SCMPDS,I be Program of SCMPDS,a,b be Int_position, k1 be
  Integer;
  assume
  s.DataLoc(s.a,k1)=0;
  then
A1: IExec(if<>0(a,k1,I),s) = s +* Start-At((card I+2),SCMPDS) by Th75;
  not b in dom Start-At((card I+2),SCMPDS) by SCMPDS_4:59;
  hence thesis by A1,FUNCT_4:12;
end;

begin :: The computation of "if var>0 then block1 else block2"

theorem
  card if>0(a,k1,I,J) = card I + card J + 2 by Lm3;

theorem
   0 in dom if>0(a,k1,I,J) &  1 in dom if>0(a,k1,I,J)
proof
  set ci=card if>0(a,k1,I,J);
  ci=card I + card J +2 by Lm3;
  then 2 <= ci by NAT_1:12;
  then 1 < ci by XXREAL_0:2;
  hence thesis by AFINSQ_1:70;
end;

theorem
  if>0(a,k1,I,J). 0 = (a,k1)<=0_goto (card I + 2) by Lm4;

theorem Th82:
  for s being State of SCMPDS, I,J being shiftable Program of
  SCMPDS, a being Int_position,k1 being Integer st s.DataLoc(s.a,k1)>0 & I
is_closed_on s & I is_halting_on s holds if>0(a,k1,I,J) is_closed_on s & if>0(a
  ,k1,I,J) is_halting_on s
proof
  let s be State of SCMPDS, I,J be shiftable Program of SCMPDS, a be
  Int_position,k1 be Integer;
  set b=DataLoc(s.a,k1);
  set G=Goto (card J+1);
  set I2 = I ';' G ';' J, IF=if>0(a,k1,I,J), pIF=stop IF, IsIF=Initialized pIF
  , pI2=stop I2, II2= Initialized pI2, s2 = s +* II2, s3 = s +* IsIF, s4 =
  Comput(ProgramPart(s3),s3,1);
  set i = (a,k1)<=0_goto (card I + 2);
A1:  0 in dom pIF by SCMPDS_4:75;
A2: IC s3 = 0 by FUNCT_4:26,SCMPDS_5:18;
A3: not b in dom IsIF by SCMPDS_4:31;
  not a in dom IsIF by SCMPDS_4:31;
  then
A4: s3.DataLoc(s3.a,k1)=s3.b by FUNCT_4:12
    .= s.b by A3,FUNCT_4:12;
A5: IF = i ';' (I ';' G) ';' J by SCMPDS_4:50
    .= i ';' I2 by SCMPDS_4:50;
  then
A6: Shift(pI2,1) c= s4 by Lm5;
A7: Comput(ProgramPart( s3), s3,0 + 1) = Following(ProgramPart s3,
Comput(ProgramPart(s3),s3,0)) by AMI_1:14
    .= Following(ProgramPart s3,s3) by AMI_1:13
    .= Exec(i,s3) by A5,Th22;
A8: DataPart s2 = DataPart s3 by SCMPDS_4:24,36;
  now
    let a;
    thus s2.a = s3.a by A8,SCMPDS_4:23
      .= s4.a by A7,SCMPDS_2:68;
  end;
  then
A9: DataPart s2 = DataPart s4 by SCMPDS_4:23;
  assume
  s.b > 0;
  then
A10: IC s4 = succ IC s3 by A7,A4,SCMPDS_2:68
    .= (0+1) by A2;
  assume
A11: I is_closed_on s;
  assume
A12: I is_halting_on s;
  then
A13: I2 is_closed_on s by A11,Th44;
  then
A14: II2 c= s2 & I2 is_closed_on s2 by Th38,FUNCT_4:26;
  I2 is_halting_on s by A11,A12,Th44;
  then
A15: ProgramPart s2 halts_on s2 by Def3;
A16: card pIF = card IF +1 by SCMPDS_5:7
    .= card I2 +1+1 by A5,Th15;
  now
    let k be Element of NAT;
    per cases;
    suppose
      0 < k;
      then consider k1 being Nat such that
A17:  k1 + 1 = k by NAT_1:6;
      reconsider k1 as Element of NAT by ORDINAL1:def 13;
      reconsider m = IC Comput(ProgramPart( s2), s2,k1) as Element of NAT;
A18:  card pIF = card pI2+1 by A16,SCMPDS_5:7;
       m in dom pI2 by A13,Def2;
      then m < card pI2 by AFINSQ_1:70;
      then
A19:  m+1 < card pIF by A18,XREAL_1:8;
T: ProgramPart s3 = ProgramPart s4
by AMI_1:123;
      IC Comput(ProgramPart(s3),s3,k) = IC Comput(ProgramPart( s3), s4,k1) by
A17,AMI_1:51
        .=  (m + 1) by A14,A6,A10,A9,Th45,T;
      hence IC Comput(ProgramPart(s3),s3,k) in dom pIF by A19,AFINSQ_1:70;
    end;
    suppose
      k = 0;
      hence IC Comput(ProgramPart(s3),s3,k) in dom pIF by A1,A2,AMI_1:13;
    end;
  end;
  hence IF is_closed_on s by Def2;
T: ProgramPart s3 = ProgramPart Comput(
ProgramPart(s3),s3,1)
by AMI_1:123;
x: Comput(ProgramPart(s3),s3,LifeSpan(ProgramPart(s2),s2)+1)
 = Comput(ProgramPart(s3),Comput(ProgramPart(s3),s3,1),LifeSpan(ProgramPart(s2)
,s2))
 by AMI_1:51;
TX4: ProgramPart s4 = ProgramPart
Comput(ProgramPart(s4),s4,LifeSpan(ProgramPart(s2),s2)
)
by AMI_1:123;
TX2: ProgramPart s2 = ProgramPart
Comput(ProgramPart(s2),s2,LifeSpan(ProgramPart(s2),
s2))
by AMI_1:123;
  CurInstr(ProgramPart s3,
  Comput(ProgramPart(s3),s3,LifeSpan(ProgramPart(s2),s2)+1))
   =CurInstr(ProgramPart s4,
   Comput(ProgramPart(s4),s4,LifeSpan(ProgramPart(s2),s2))) by x,T
    .=CurInstr(ProgramPart s2,
    Comput(ProgramPart(s2),s2,LifeSpan(ProgramPart(s2),s2))) by A14,A6,A10,A9
,Th45,TX2,TX4
    .= halt SCMPDS by A15,AMI_1:def 46;
  then ProgramPart s3 halts_on s3 by AMI_1:146;
  hence thesis by Def3;
end;

theorem Th83:
  for s being State of SCMPDS,I being Program of SCMPDS,J being
shiftable Program of SCMPDS,a being Int_position,k1 being Integer st s.DataLoc(
  s.a,k1) <= 0 & J is_closed_on s & J is_halting_on s holds if>0(a,k1,I,J)
  is_closed_on s & if>0(a,k1,I,J) is_halting_on s
proof
  let s be State of SCMPDS,I be Program of SCMPDS, J be shiftable Program of
  SCMPDS, a be Int_position,k1 be Integer;
  set b=DataLoc(s.a,k1);
  set pJ=stop J, IsJ=Initialized pJ, s1 = s +* IsJ, IF=if>0(a,k1,I,J), pIF=
  stop IF, IsIF=Initialized pIF, s3 = s +* IsIF, s4 = Comput(ProgramPart(s3),s3
,1);
  set i = (a,k1)<=0_goto (card I + 2);
  set G =Goto (card J+1), iG=i ';' I ';' G;
A1: IF = i ';' (I ';' G) ';' J by SCMPDS_4:50
    .= i ';' (I ';' G ';' J) by SCMPDS_4:50;
A2: Comput(ProgramPart( s3), s3,0 + 1) = Following(ProgramPart s3,
Comput(ProgramPart(s3),s3,0)) by AMI_1:14
    .= Following(ProgramPart s3,s3) by AMI_1:13
    .= Exec(i,s3) by A1,Th22;
A3: not b in dom IsIF by SCMPDS_4:31;
  not a in dom IsIF by SCMPDS_4:31;
  then
A4: s3.DataLoc(s3.a,k1)=s3.b by FUNCT_4:12
    .= s.b by A3,FUNCT_4:12;
A5: IC s3 = 0 by FUNCT_4:26,SCMPDS_5:18;
  assume
  s.b <= 0;
  then
A6: IC s4 = ICplusConst(s3,card I + 2) by A2,A4,SCMPDS_2:68
    .= (0+(card I + 2)) by A5,Th23;
  assume
A7: J is_closed_on s;
  then
A8: IsJ c= s1 & J is_closed_on s1 by Th38,FUNCT_4:26;
A9: pIF c= s3 by FUNCT_4:26,SCMPDS_4:57;
A10: card iG = card (i ';' I) + card G by SCMPDS_4:45
    .=card (i ';' I) + 1 by SCMPDS_5:6
    .=card I +1 +1 by Th15
    .=card I +(1 +1);
  then Shift(pJ,card I+2) c= pIF by Th24;
  then Shift(pJ,card I+2) c= s3 by A9,XBOOLE_1:1;
  then
A11: Shift(pJ,card I+2) c= s4 by AMI_1:81;
  assume
  J is_halting_on s;
  then
A12: ProgramPart s1 halts_on s1 by Def3;
A13: DataPart s1 = DataPart s3 by SCMPDS_4:24,36;
  now
    let a;
    thus s1.a = s3.a by A13,SCMPDS_4:23
      .= s4.a by A2,SCMPDS_2:68;
  end;
  then
A14: DataPart s1 = DataPart s4 by SCMPDS_4:23;
  now
    let k be Element of NAT;
    per cases;
    suppose
      0 < k;
      then consider k1 being Nat such that
A15:  k1 + 1 = k by NAT_1:6;
      reconsider k1 as Element of NAT by ORDINAL1:def 13;
      reconsider m = IC Comput(ProgramPart( s1), s1,k1) as Element of NAT;
       m in dom pJ by A7,Def2;
      then m < card pJ by AFINSQ_1:70;
      then
A16:  m + (card I + 2) < card pJ + (card I + 2) by XREAL_1:8;
A17:  card pJ = card J + 1 by SCMPDS_5:7;
A18:  card pIF = card IF+1 by SCMPDS_5:7
        .=card I +2 +card J +1 by A10,SCMPDS_4:45
        .=card I +2 + card pJ by A17;
T: ProgramPart s3 = ProgramPart s4
by AMI_1:123;
      IC Comput(ProgramPart(s3),s3,k) = IC Comput(ProgramPart( s3), s4,k1) by
A15,AMI_1:51
        .=  (m + (card I + 2)) by A8,A14,A11,A6,Th45,T;
      hence IC Comput(ProgramPart(s3),s3,k) in dom pIF by A18,A16,AFINSQ_1:70;
    end;
    suppose
      k = 0;
      then Comput(ProgramPart(s3),s3,k) = s3 by AMI_1:13;
      hence IC Comput(ProgramPart(s3),s3,k) in dom pIF by A5,SCMPDS_4:75;
    end;
  end;
  hence IF is_closed_on s by Def2;
T: ProgramPart s3 = ProgramPart Comput(
ProgramPart(s3),s3,1)
by AMI_1:123;
x: Comput(ProgramPart(s3),s3,LifeSpan(ProgramPart(s1),s1)+1)
 = Comput(ProgramPart(s3),Comput(ProgramPart(s3),s3,1),LifeSpan(ProgramPart(s1)
,s1))
 by AMI_1:51;
TX4: ProgramPart s4 = ProgramPart
Comput(ProgramPart(s4),s4,LifeSpan(ProgramPart(s1),s1)
)
by AMI_1:123;
TX1: ProgramPart s1 = ProgramPart
Comput(ProgramPart(s1),s1,LifeSpan(ProgramPart(s1),
s1))
by AMI_1:123;
  CurInstr(ProgramPart s3,
  Comput(ProgramPart(s3),s3,LifeSpan(ProgramPart(s1),s1)+1))
   =CurInstr(ProgramPart s4,
   Comput(ProgramPart(s4),s4,LifeSpan(ProgramPart(s1),s1))) by x,T
    .=CurInstr(ProgramPart s1,
    Comput(ProgramPart(s1),s1,LifeSpan(ProgramPart(s1),s1))) by A8,A14,A11,A6
,Th45,TX1,TX4
    .= halt SCMPDS by A12,AMI_1:def 46;
  then ProgramPart s3 halts_on s3 by AMI_1:146;
  hence thesis by Def3;
end;

theorem Th84:
  for s being State of SCMPDS,I being halt-free shiftable
Program of SCMPDS, J being shiftable Program of SCMPDS,a being Int_position,k1
  being Integer st s.DataLoc(s.a,k1) > 0 & I is_closed_on s & I is_halting_on s
holds IExec(if>0(a,k1,I,J),s) = IExec(I,s) +* Start-At( (card I + card J
  + 2),SCMPDS)
proof
  let s be State of SCMPDS,I be halt-free shiftable Program of SCMPDS, J be
  shiftable Program of SCMPDS,a be Int_position,k1 be Integer;
  set b=DataLoc(s.a,k1);
  set G=Goto (card J+1);
  set I2 = I ';' G ';' J, IF=if>0(a,k1,I,J), IsIF=Initialized stop IF, pI2=
stop I2, II2= Initialized pI2, s2 = s +* II2, s3 = s +* IsIF, s4 = Comput(
ProgramPart(
  s3),
  s3,1);
  set i = (a,k1)<=0_goto (card I + 2);
  set SAl= Start-At((card I+card J+2),SCMPDS);
A1: IC s3 = 0 by FUNCT_4:26,SCMPDS_5:18;
A2: not b in dom IsIF by SCMPDS_4:31;
  not a in dom IsIF by SCMPDS_4:31;
  then
A3: s3.DataLoc(s3.a,k1)=s3.b by FUNCT_4:12
    .= s.b by A2,FUNCT_4:12;
A4: dom ProgramPart s = A by AMI_1:143;
A5: IF = i ';' (I ';' G) ';' J by SCMPDS_4:50
    .= i ';' I2 by SCMPDS_4:50;
  then
A6: Shift(pI2,1) c= s4 by Lm5;
A7: Comput(ProgramPart( s3), s3,0 + 1) = Following(ProgramPart s3,
Comput(ProgramPart(s3),s3,0)) by AMI_1:14
    .= Following(ProgramPart s3,s3) by AMI_1:13
    .= Exec(i,s3) by A5,Th22;
  assume
  s.b > 0;
  then
A8: IC s4 = succ IC s3 by A7,A3,SCMPDS_2:68
    .= (0+1) by A1;
A9: DataPart s2 = DataPart s3 by SCMPDS_4:24,36;
  now
    let a;
    thus s2.a = s3.a by A9,SCMPDS_4:23
      .= s4.a by A7,SCMPDS_2:68;
  end;
  then
A10: DataPart s2 = DataPart s4 by SCMPDS_4:23;
  assume
A11: I is_closed_on s;
  assume
A12: I is_halting_on s;
  then I2 is_halting_on s by A11,Th44;
  then
A13: ProgramPart s2 halts_on s2 by Def3;
  I2 is_closed_on s by A11,A12,Th44;
  then
A14: II2 c= s2 & I2 is_closed_on s2 by Th38,FUNCT_4:26;
T: ProgramPart s3 = ProgramPart Comput(
ProgramPart(s3),s3,1)
by AMI_1:123;
x: Comput(ProgramPart(s3),s3,LifeSpan(ProgramPart(s2),s2)+1)
= Comput(ProgramPart(s3),Comput(ProgramPart(s3),s3,1),LifeSpan(ProgramPart(s2),
s2))
 by AMI_1:51;
TX4: ProgramPart s4 = ProgramPart
Comput(ProgramPart(s4),s4,LifeSpan(ProgramPart(s2),s2))
by AMI_1:123;
TX2: ProgramPart s2 = ProgramPart
Comput(ProgramPart(s2),s2,LifeSpan(ProgramPart(s2),
s2))
by AMI_1:123;
A15: CurInstr(ProgramPart s3,
Comput(ProgramPart(s3),s3,LifeSpan(ProgramPart(s2),s2)+1))
 =CurInstr(ProgramPart s4,
 Comput(ProgramPart(s4),s4,LifeSpan(ProgramPart(s2),s2))) by x,T
    .=CurInstr(ProgramPart s2,
    Comput(ProgramPart(s2),s2,LifeSpan(ProgramPart(s2),s2))) by A14,A6,A8,A10
,Th45,TX2,TX4
    .= halt SCMPDS by A13,AMI_1:def 46;
  then
A16: ProgramPart s3 halts_on s3 by AMI_1:146;
A17: CurInstr(ProgramPart s3,s3) = i by A5,Th22;
  now
    let l be Element of NAT;
    assume
A18: l < LifeSpan(ProgramPart(s2),s2) + 1;
u: Comput(ProgramPart(s3),s3,0) = s3 by AMI_1:13;
    per cases;
    suppose
      l = 0;
      then CurInstr(ProgramPart s3,Comput(ProgramPart(s3),s3,l))
       = CurInstr(ProgramPart s3,s3)
       by u;
      hence CurInstr(ProgramPart (s3),Comput(ProgramPart(s3),s3,l))
       <> halt SCMPDS by A17,Th30;
    end;
    suppose
      l <> 0;
      then consider n be Nat such that
A19:  l = n + 1 by NAT_1:6;
      reconsider n as Element of NAT by ORDINAL1:def 13;
A20:  n < LifeSpan(ProgramPart(s2),s2) by A18,A19,XREAL_1:8;
      assume
A21:  CurInstr(ProgramPart (s3),Comput(ProgramPart(s3),s3,l)) = halt SCMPDS;
T: ProgramPart s3 = ProgramPart Comput(ProgramPart(s3),s3,1)
by AMI_1:123;
TX2: ProgramPart s2 = ProgramPart Comput(ProgramPart(s2),s2,n)
by AMI_1:123;
TX4: ProgramPart s4 = ProgramPart Comput(ProgramPart(s4),s4,n)
by AMI_1:123;
x: Comput(ProgramPart(s3),s3,n+1)
 = Comput(ProgramPart(s3),Comput(ProgramPart(s3),s3,1),n) by AMI_1:51;
      CurInstr(ProgramPart s2,Comput(ProgramPart(s2),s2,n)) =
      CurInstr(ProgramPart s4,Comput(ProgramPart(s4),s4,n)) by A14,A6,A8,A10
,Th45,TX2,TX4
        .= halt SCMPDS by A19,A21,x,T;
      hence contradiction by A13,A20,AMI_1:def 46;
    end;
  end;
  then for l be Element of NAT st CurInstr(ProgramPart (s3),
  Comput(ProgramPart(s3),s3,l)) = halt SCMPDS
  holds LifeSpan(ProgramPart(s2),s2) + 1 <= l;
  then
A22: LifeSpan(ProgramPart(s3),s3) = LifeSpan(ProgramPart(s2),s2) + 1 by A15,A16
,AMI_1:def 46;
T: ProgramPart s3 = ProgramPart s4
by AMI_1:123;
A23: DataPart Result(ProgramPart(s2),s2) = DataPart Comput(ProgramPart( s2), s2
,LifeSpan(ProgramPart(s2),s2)) by A13,AMI_1:122
    .= DataPart Comput(ProgramPart( s3), s4,LifeSpan(ProgramPart(s2),s2))
    by A14,A6,A8,A10,Th45,T
    .= DataPart Comput(ProgramPart( s3), s3,LifeSpan(ProgramPart(s2),s2) + 1)
by AMI_1:51
    .= DataPart Result(ProgramPart(s3),s3) by A16,A22,AMI_1:122;
A24: now
    let x be set;
A25: IExec(I2,s) = Result(ProgramPart(s2),s2) +* s | A by SCMPDS_4:def 8;
A26: IExec(IF,s) = Result(ProgramPart(s3),s3) +* s | A by SCMPDS_4:def 8;
A27: dom SAl = {IC SCMPDS} by FUNCOP_1:19;
    assume
A28: x in dom IExec(IF,s);
    per cases by A28,SCMPDS_4:20;
    suppose
A29:  x is Int_position;
      then x <> IC SCMPDS by SCMPDS_2:52;
      then
A30:  not x in dom SAl by A27,TARSKI:def 1;
A31: not x in dom (s | A) by A4,A29,SCMPDS_2:53;
      hence IExec(IF,s).x = (Result(ProgramPart(s3),s3)).x by A26,FUNCT_4:12
        .= (Result(ProgramPart(s2),s2)).x by A23,A29,SCMPDS_4:23
        .= IExec(I2,s).x by A25,A31,FUNCT_4:12
        .= (IExec(I2,s) +* SAl).x by A30,FUNCT_4:12;
    end;
    suppose
A32:  x = IC SCMPDS;
A33: not x in dom (s | A) by A4,A32,AMI_1:48;
      then
A34:  IC Result(ProgramPart(s2),s2) = IC IExec(I2,s) by A25,A32,FUNCT_4:12
        .=  (card I + card J + 1) by A11,A12,Th46;
A35:  x in dom SAl by A27,A32,TARSKI:def 1;
T: ProgramPart s3 = ProgramPart s4
by AMI_1:123;
      thus IExec(IF,s).x = (Result(ProgramPart(s3),s3)).x by A26,A33,FUNCT_4:12
        .= Comput(ProgramPart( s3), s3,LifeSpan(ProgramPart(s2),s2) + 1).x by
A16,A22,AMI_1:122
        .= IC Comput(ProgramPart( s3), s4,LifeSpan(ProgramPart(s2),s2)) by A32,
AMI_1:51
        .= IC Comput(ProgramPart( s2), s2,LifeSpan(ProgramPart(s2),s2)) + 1 by
A14,A6,A8,A10,Th45,T
        .= IC Result(ProgramPart(s2),s2) + 1 by A13,AMI_1:122
        .= (Start-At(( (card I + card J + 1) + 1),SCMPDS)).IC SCMPDS
        by A34,FUNCOP_1:87
        .= (IExec(I2,s) +* SAl).x by A32,A35,FUNCT_4:14;
    end;
    suppose
      x is Element of NAT;
      hence IExec(IF,s).x = (IExec(I2,s) +* SAl).x by Th26;
    end;
  end;
  dom IExec(IF,s) = the carrier of SCMPDS by PARTFUN1:def 4
    .= dom (IExec(I2,s) +* SAl) by PARTFUN1:def 4;
  hence IExec(IF,s) = IExec(I2,s) +* SAl by A24,FUNCT_1:9
    .= IExec(I,s) +* Start-At( (card I + card J + 1),SCMPDS) +*
     Start-At(
   (card I + card J + 2),SCMPDS) by A11,A12,Th47
    .= IExec(I,s) +* SAl by Th14;
end;

theorem Th85:
  for s being State of SCMPDS,I being Program of SCMPDS,J being
  halt-free shiftable Program of SCMPDS,a being Int_position,k1 being Integer
  st s.DataLoc(s.a,k1) <= 0 & J is_closed_on s & J is_halting_on s holds IExec(
  if>0(a,k1,I,J),s) = IExec(J,s) +* Start-At((card I+card J+2),SCMPDS)
proof
  let s be State of SCMPDS,I be Program of SCMPDS,J be halt-free shiftable
  Program of SCMPDS,a be Int_position,k1 be Integer;
  set b=DataLoc(s.a,k1);
  set pJ=stop J, IsJ=Initialized pJ, s1 = s +* IsJ, IF=if>0(a,k1,I,J), pIF=
  stop IF, IsIF=Initialized pIF, s3 = s +* IsIF, s4 = Comput(ProgramPart( s3),
s3,1);
  set i = (a,k1)<=0_goto (card I + 2);
  set G =Goto (card J+1), iG=i ';' I ';' G;
  set SAl=Start-At((card I+card J+2),SCMPDS);
A1: IF = i ';' (I ';' G) ';' J by SCMPDS_4:50
    .= i ';' (I ';' G ';' J) by SCMPDS_4:50;
A2: Comput(ProgramPart( s3), s3,0 + 1) = Following(ProgramPart s3,
Comput(ProgramPart(s3),s3,0)) by AMI_1:14
    .= Following(ProgramPart s3,s3) by AMI_1:13
    .= Exec(i,s3) by A1,Th22;
A3: not b in dom IsIF by SCMPDS_4:31;
  not a in dom IsIF by SCMPDS_4:31;
  then
A4: s3.DataLoc(s3.a,k1)=s3.b by FUNCT_4:12
    .= s.b by A3,FUNCT_4:12;
A5: IC s3 = 0 by FUNCT_4:26,SCMPDS_5:18;
A6: dom ProgramPart s = A by AMI_1:143;
  assume
  s.b <= 0;
  then
A7: IC s4 = ICplusConst(s3,card I + 2) by A2,A4,SCMPDS_2:68
    .= (0+(card I + 2)) by A5,Th23;
A8: DataPart s1 = DataPart s3 by SCMPDS_4:24,36;
  now
    let a;
    thus s1.a = s3.a by A8,SCMPDS_4:23
      .= s4.a by A2,SCMPDS_2:68;
  end;
  then
A9: DataPart s1 = DataPart s4 by SCMPDS_4:23;
  card iG = card (i ';' I) + card G by SCMPDS_4:45
    .=card (i ';' I) + 1 by SCMPDS_5:6
    .=card I +1 +1 by Th15
    .=card I +(1 +1);
  then
A10: Shift(pJ,card I+2) c= pIF by Th24;
  pIF c= s3 by FUNCT_4:26,SCMPDS_4:57;
  then Shift(pJ,card I+2) c= s3 by A10,XBOOLE_1:1;
  then
A11: Shift(pJ,card I+2) c= s4 by AMI_1:81;
  assume
A12: J is_closed_on s;
  then
A13: IsJ c= s1 & J is_closed_on s1 by Th38,FUNCT_4:26;
  assume
A14: J is_halting_on s;
  then
A15: ProgramPart s1 halts_on s1 by Def3;
T: ProgramPart s3 = ProgramPart Comput(
ProgramPart(s3),s3,1)
by AMI_1:123;
x: Comput(ProgramPart(s3),s3,LifeSpan(ProgramPart(s1),s1)+1)
 = Comput(ProgramPart(s3),Comput(ProgramPart(s3),s3,1),LifeSpan(ProgramPart(s1)
,s1))
 by AMI_1:51;
TX1: ProgramPart s1 = ProgramPart
Comput(ProgramPart(s1),s1,LifeSpan(ProgramPart(s1),
s1))
by AMI_1:123;
TX3: ProgramPart s3 = ProgramPart
Comput(ProgramPart(s3),s3,LifeSpan(ProgramPart(s1),s1
)+1)
by AMI_1:123;
A16: CurInstr(ProgramPart s3,
Comput(ProgramPart(s3),s3,LifeSpan(ProgramPart(s1),s1)+1))
 =CurInstr(ProgramPart Comput(ProgramPart(s4),s4,LifeSpan(ProgramPart(s1),s1)),
 Comput(ProgramPart(s4),s4,LifeSpan(ProgramPart(s1),s1))) by x,T,TX3
    .=CurInstr(ProgramPart s1,
    Comput(ProgramPart(s1),s1,LifeSpan(ProgramPart(s1),s1))) by A13,A11,A7,A9
,Th45,TX1
    .= halt SCMPDS by A15,AMI_1:def 46;
  then
A17: ProgramPart s3 halts_on s3 by AMI_1:146;
A18: CurInstr(ProgramPart s3,s3) = i by A1,Th22;
  now
    let l be Element of NAT;
    assume
A19: l < LifeSpan(ProgramPart(s1),s1) + 1;
u: Comput(ProgramPart(s3),s3,0) = s3 by AMI_1:13;
    per cases;
    suppose
      l = 0;
      then CurInstr(ProgramPart (s3),Comput(ProgramPart(s3),s3,l))
       = CurInstr(ProgramPart s3,s3)
       by u;
      hence CurInstr(ProgramPart (s3),Comput(ProgramPart(s3),s3,l))
       <> halt SCMPDS by A18,Th30;
    end;
    suppose
      l <> 0;
      then consider n be Nat such that
A20:  l = n + 1 by NAT_1:6;
      reconsider n as Element of NAT by ORDINAL1:def 13;
A21:  n < LifeSpan(ProgramPart(s1),s1) by A19,A20,XREAL_1:8;
      assume
A22:  CurInstr(ProgramPart s3,Comput(ProgramPart(s3),s3,l)) = halt SCMPDS;
T: ProgramPart s3 = ProgramPart Comput(ProgramPart(s3),
s3,1)
by AMI_1:123;
x: Comput(ProgramPart(s3),s3,n+1)
 = Comput(ProgramPart(s3),Comput(ProgramPart(s3),s3,1),n) by AMI_1:51;
TX1: ProgramPart s1 = ProgramPart Comput(ProgramPart(s1),s1,n)
by AMI_1:123;
TX4: ProgramPart s4 = ProgramPart Comput(ProgramPart(s4),s4,n)
by AMI_1:123;
      CurInstr(ProgramPart s1,Comput(ProgramPart(s1),s1,n))
       = CurInstr(ProgramPart s4,
      Comput(ProgramPart(s4),s4,n)) by A13,A11,A7,TX1,TX4,A9,Th45
        .= halt SCMPDS by A20,A22,x,T;
      hence contradiction by A15,A21,AMI_1:def 46;
    end;
  end;
  then for l be Element of NAT st CurInstr(ProgramPart (s3),
  Comput(ProgramPart(s3),s3,l)) = halt SCMPDS
  holds LifeSpan(ProgramPart(s1),s1) + 1 <= l;
  then
A23: LifeSpan(ProgramPart(s3),s3) = LifeSpan(ProgramPart(s1),s1) + 1 by A16,A17
,AMI_1:def 46;
A24: DataPart Result(ProgramPart(s1),s1) = DataPart Comput(ProgramPart( s1), s1
,LifeSpan(ProgramPart(s1),s1)) by A15,AMI_1:122
    .= DataPart Comput(ProgramPart( s4), s4,LifeSpan(ProgramPart(s1),s1))
    by A13,A11,A7,A9,Th45
    .= DataPart Comput(ProgramPart( s3), s3,LifeSpan(ProgramPart(s1),s1) + 1)
by T,AMI_1:51
    .= DataPart Result(ProgramPart(s3),s3) by A17,A23,AMI_1:122;
A25: now
    let x be set;
A26: IExec(J,s) = Result(ProgramPart(s1),s1) +* s | A by SCMPDS_4:def 8;
A27: IExec(IF,s) = Result(ProgramPart(s3),s3) +* s | A by SCMPDS_4:def 8;
A28: dom SAl = {IC SCMPDS} by FUNCOP_1:19;
    assume
A29: x in dom IExec(IF,s);
    per cases by A29,SCMPDS_4:20;
    suppose
A30:  x is Int_position;
      then x <> IC SCMPDS by SCMPDS_2:52;
      then
A31:  not x in dom SAl by A28,TARSKI:def 1;
A32: not x in dom (s | A) by A6,A30,SCMPDS_2:53;
      hence IExec(IF,s).x = (Result(ProgramPart(s3),s3)).x by A27,FUNCT_4:12
        .= (Result(ProgramPart(s1),s1)).x by A24,A30,SCMPDS_4:23
        .= IExec(J,s).x by A26,A32,FUNCT_4:12
        .= (IExec(J,s) +* SAl).x by A31,FUNCT_4:12;
    end;
    suppose
A33:  x = IC SCMPDS;
A34: not x in dom (s | A) by A6,A33,AMI_1:48;
      then
A35:  IC Result(ProgramPart(s1),s1) = IC IExec(J,s) by A26,A33,FUNCT_4:12
        .=  (card J) by A12,A14,Th48;
A36:  x in dom SAl by A28,A33,TARSKI:def 1;
T: ProgramPart s3 = ProgramPart s4
by AMI_1:123;
      thus IExec(IF,s).x = (Result(ProgramPart(s3),s3)).x by A27,A34,FUNCT_4:12
        .= Comput(ProgramPart( s3), s3,LifeSpan(ProgramPart(s1),s1) + 1).x by
A17,A23,AMI_1:122
        .= IC Comput(ProgramPart( s3), s4,LifeSpan(ProgramPart(s1),s1)) by A33,
AMI_1:51
        .= IC Comput(ProgramPart( s1), s1,LifeSpan(ProgramPart(s1),s1)) + (card
I + 2) by A13,A11,A7,A9,Th45,T
        .= IC Result(ProgramPart(s1),s1) + (card I + 2) by A15,AMI_1:122
        .= (Start-At ( card J + (card I + 2),SCMPDS)).IC SCMPDS by A35,
FUNCOP_1:87
        .= (IExec(J,s) +* SAl).x by A33,A36,FUNCT_4:14;
    end;
    suppose
      x is Element of NAT;
      hence IExec(IF,s).x = (IExec(J,s) +* SAl).x by Th26;
    end;
  end;
  dom IExec(IF,s) = the carrier of SCMPDS by PARTFUN1:def 4
    .= dom (IExec(J,s) +* SAl) by PARTFUN1:def 4;
  hence thesis by A25,FUNCT_1:9;
end;

registration
  let I,J be shiftable parahalting Program of SCMPDS, a be Int_position,k1 be
  Integer;
  cluster if>0(a,k1,I,J) -> shiftable parahalting;
  correctness
  proof
    set i = (a,k1)<=0_goto (card I + 2), G =Goto (card J+1);
    set IF=if>0(a,k1,I,J), IsIF=Initialized stop IF;
    reconsider IJ=I ';' G ';' J as shiftable Program of SCMPDS;
    IF =i ';' (I ';' G) ';' J by SCMPDS_4:50
      .=i ';' IJ by SCMPDS_4:50
      .=Load i ';' IJ by SCMPDS_4:def 4;
    hence IF is shiftable;
    now
      let s be State of SCMPDS;
      assume
      IsIF c= s;
      then
A1:   s = s +* IsIF by FUNCT_4:79;
A2:   J is_closed_on s & J is_halting_on s by Th34,Th35;
A3:   I is_closed_on s & I is_halting_on s by Th34,Th35;
      per cases;
      suppose
        s.DataLoc(s.a,k1) > 0;
        then IF is_halting_on s by A3,Th82;
        hence ProgramPart s halts_on s by A1,Def3;
      end;
      suppose
        s.DataLoc(s.a,k1) <= 0;
        then IF is_halting_on s by A2,Th83;
        hence ProgramPart s halts_on s by A1,Def3;
      end;
    end;
    then IsIF is halting by AMI_1:def 26;
    hence thesis by SCMPDS_4:def 10;
  end;
end;

registration
  let I,J be halt-free Program of SCMPDS, a be Int_position,k1 be Integer;
  cluster if>0(a,k1,I,J) -> halt-free;
  coherence;
end;

theorem
  for s being State of SCMPDS,I,J being halt-free shiftable
  parahalting Program of SCMPDS,a being Int_position,k1 being Integer holds IC
  IExec(if>0(a,k1,I,J),s) =  (card I + card J + 2)
proof
  let s be State of SCMPDS,I,J be halt-free shiftable parahalting Program of
  SCMPDS,a be Int_position,k1 be Integer;
  set IF=if>0(a,k1,I,J);
A1: I is_closed_on s & I is_halting_on s by Th34,Th35;
A2: J is_closed_on s & J is_halting_on s by Th34,Th35;
  per cases;
  suppose
    s.DataLoc(s.a,k1) > 0;
    then IExec(IF,s) = IExec(I,s) +* Start-At((card I+card J+2),SCMPDS)
    by A1,Th84;
    hence thesis by FUNCT_4:121;
  end;
  suppose
    s.DataLoc(s.a,k1) <= 0;
    then IExec(IF,s) = IExec(J,s) +* Start-At((card I+card J+2),SCMPDS)
    by A2,Th85;
    hence thesis by FUNCT_4:121;
  end;
end;

theorem
  for s being State of SCMPDS,I being halt-free shiftable parahalting
  Program of SCMPDS,J being shiftable Program of SCMPDS,a,b being Int_position,
k1 being Integer st s.DataLoc(s.a,k1)>0 holds IExec(if>0(a,k1,I,J),s).b = IExec
  (I,s).b
proof
  let s be State of SCMPDS,I be halt-free shiftable parahalting Program of
  SCMPDS,J be shiftable Program of SCMPDS,a,b be Int_position, k1 be Integer;
  assume
A1: s.DataLoc(s.a,k1)>0;
A2: not b in dom Start-At((card I+card J+2),SCMPDS) by SCMPDS_4:59;
  I is_closed_on s & I is_halting_on s by Th34,Th35;
  then
  IExec(if>0(a,k1,I,J),s) = IExec(I,s) +* Start-At( (card I + card J
  + 2),SCMPDS) by A1,Th84;
  hence thesis by A2,FUNCT_4:12;
end;

theorem
  for s being State of SCMPDS,I being Program of SCMPDS,J being
  halt-free parahalting shiftable Program of SCMPDS,a,b being Int_position,k1
being Integer st s.DataLoc(s.a,k1) <= 0 holds IExec(if>0(a,k1,I,J),s).b = IExec
  (J,s).b
proof
  let s be State of SCMPDS,I be Program of SCMPDS,J be halt-free parahalting
  shiftable Program of SCMPDS,a,b be Int_position, k1 be Integer;
  set IF=if>0(a,k1,I,J);
  assume
A1: s.DataLoc(s.a,k1) <= 0;
A2: not b in dom Start-At((card I+card J+2),SCMPDS) by SCMPDS_4:59;
  J is_closed_on s & J is_halting_on s by Th34,Th35;
  then IExec(IF,s) =IExec(J,s) +* Start-At((card I+card J+2),SCMPDS)
  by A1,Th85;
  hence thesis by A2,FUNCT_4:12;
end;

begin :: The computation of "if var>0 then block"

theorem
  card if>0(a,k1,I) = card I + 1 by Th15;

theorem
   0 in dom if>0(a,k1,I)
proof
  set ci=card if>0(a,k1,I);
  ci=card I + 1 by Th15;
  hence thesis by AFINSQ_1:70;
end;

theorem
  if>0(a,k1,I). 0 = (a,k1)<=0_goto (card I + 1) by Th16;

theorem Th92:
  for s being State of SCMPDS, I being shiftable Program of SCMPDS
  , a being Int_position,k1 being Integer st s.DataLoc(s.a,k1)> 0 & I
is_closed_on s & I is_halting_on s holds if>0(a,k1,I) is_closed_on s & if>0(a,
  k1,I) is_halting_on s
proof
  let s be State of SCMPDS, I be shiftable Program of SCMPDS, a be
  Int_position,k1 be Integer;
  set b=DataLoc(s.a,k1);
  set IF=if>0(a,k1,I), pIF=stop IF, IsIF=Initialized pIF, pI=stop I, IsI=
  Initialized pI, s2 = s +* IsI, s3 = s +* IsIF, s4 = Comput(ProgramPart(s3),s3
,1);
  set i = (a,k1)<=0_goto (card I + 1);
A1:  0 in dom pIF by SCMPDS_4:75;
A2: IC s3 = 0 by FUNCT_4:26,SCMPDS_5:18;
A3: not b in dom IsIF by SCMPDS_4:31;
  not a in dom IsIF by SCMPDS_4:31;
  then
A4: s3.DataLoc(s3.a,k1)=s3.b by FUNCT_4:12
    .= s.b by A3,FUNCT_4:12;
A5: Comput(ProgramPart( s3), s3,0 + 1) = Following(ProgramPart s3,
Comput(ProgramPart(s3),s3,0)) by AMI_1:14
    .= Following(ProgramPart s3,s3) by AMI_1:13
    .= Exec(i,s3) by Th22;
A6: DataPart s2 = DataPart s3 by SCMPDS_4:24,36;
  now
    let a;
    thus s2.a = s3.a by A6,SCMPDS_4:23
      .= s4.a by A5,SCMPDS_2:68;
  end;
  then
A7: DataPart s2 = DataPart s4 by SCMPDS_4:23;
  assume
  s.b > 0;
  then
A8: IC s4 = succ IC s3 by A5,A4,SCMPDS_2:68
    .= (0+1) by A2;
  assume
A9: I is_closed_on s;
  then
A10: I is_closed_on s2 by Th38;
  assume
  I is_halting_on s;
  then
A11: ProgramPart s2 halts_on s2 by Def3;
A12: IsI c= s2 & Shift(pI,1) c= s4 by Lm5,FUNCT_4:26;
A13: card pIF = card IF +1 by SCMPDS_5:7
    .= card I +1+1 by Th15;
  now
    let k be Element of NAT;
    per cases;
    suppose
      0 < k;
      then consider k1 being Nat such that
A14:  k1 + 1 = k by NAT_1:6;
      reconsider k1 as Element of NAT by ORDINAL1:def 13;
      reconsider m = IC Comput(ProgramPart( s2), s2,k1) as Element of NAT;
A15:  card pIF = card pI+1 by A13,SCMPDS_5:7;
       m in dom pI by A9,Def2;
      then m < card pI by AFINSQ_1:70;
      then
A16:  m+1 < card pIF by A15,XREAL_1:8;
T: ProgramPart s3 = ProgramPart s4
by AMI_1:123;
      IC Comput(ProgramPart(s3),s3,k) = IC Comput(ProgramPart( s3), s4,k1) by
A14,AMI_1:51
        .=  (m + 1) by A10,A12,A8,A7,Th45,T;
      hence IC Comput(ProgramPart(s3),s3,k) in dom pIF by A16,AFINSQ_1:70;
    end;
    suppose
      k = 0;
      hence IC Comput(ProgramPart(s3),s3,k) in dom pIF by A1,A2,AMI_1:13;
    end;
  end;
  hence IF is_closed_on s by Def2;
T: ProgramPart s3 = ProgramPart Comput(
ProgramPart(s3),s3,1)
by AMI_1:123;
x: Comput(ProgramPart(s3),s3,LifeSpan(ProgramPart(s2),s2)+1)
 = Comput(ProgramPart(s3),Comput(ProgramPart(s3),s3,1),LifeSpan(ProgramPart(s2)
,s2))
 by AMI_1:51;
TX4: ProgramPart s4 = ProgramPart
Comput(ProgramPart(s4),s4,LifeSpan(ProgramPart(s2),s2)
)
by AMI_1:123;
TX2: ProgramPart s2 = ProgramPart
Comput(ProgramPart(s2),s2,LifeSpan(ProgramPart(s2),
s2))
by AMI_1:123;
  CurInstr(ProgramPart s3,
  Comput(ProgramPart(s3),s3,LifeSpan(ProgramPart(s2),s2)+1))
   =CurInstr(ProgramPart s4,
   Comput(ProgramPart(s4),s4,LifeSpan(ProgramPart(s2),s2))) by x,T
    .=CurInstr(ProgramPart s2,
    Comput(ProgramPart(s2),s2,LifeSpan(ProgramPart(s2),s2))) by A10,A12,A8,A7
,Th45,TX2,TX4
    .= halt SCMPDS by A11,AMI_1:def 46;
  then ProgramPart s3 halts_on s3 by AMI_1:146;
  hence thesis by Def3;
end;

theorem Th93:
  for s being State of SCMPDS,I being Program of SCMPDS, a being
  Int_position, k1 being Integer st s.DataLoc(s.a,k1) <= 0 holds if>0(a,k1,I)
  is_closed_on s & if>0(a,k1,I) is_halting_on s
proof
  let s be State of SCMPDS,I be Program of SCMPDS, a be Int_position,k1 be
  Integer;
  set b=DataLoc(s.a,k1);
  assume
A1: s.b <= 0;
  set i = (a,k1)<=0_goto (card I + 1);
  set IF=if>0(a,k1,I), pIF=stop IF, IsIF=Initialized pIF, s3 = s +* IsIF, s4 =
  Comput(ProgramPart(s3),s3,1);
A2: IC s3 = 0 by FUNCT_4:26,SCMPDS_5:18;
A3: not b in dom IsIF by SCMPDS_4:31;
  not a in dom IsIF by SCMPDS_4:31;
  then
A4: s3.DataLoc(s3.a,k1)=s3.b by FUNCT_4:12
    .= s.b by A3,FUNCT_4:12;
  Comput(ProgramPart( s3), s3,0 + 1) = Following(ProgramPart s3,
  Comput(ProgramPart(s3),s3,0)) by AMI_1:14
    .= Following(ProgramPart s3,s3) by AMI_1:13
    .= Exec(i,s3) by Th22;
  then
A5: IC s4 = ICplusConst(s3,card I + 1) by A1,A4,SCMPDS_2:68
    .= (0+(card I + 1)) by A2,Th23;
A6: card IF=card I+1 by Th15;
  then
A7: (card I+1) in dom pIF by Th25;
Y:  (ProgramPart s4)/.IC s4
 = s4.IC s4 by AMI_1:150;
  IsIF c= s3 by FUNCT_4:26;
  then pIF c= s4 by AMI_1:81,SCMPDS_4:57;
  then s4.(card I+1) = pIF.(card I+1) by A7,GRFUNC_1:8
    .=halt SCMPDS by A6,Th25;
  then
A8: CurInstr(ProgramPart s4,s4) = halt SCMPDS by A5,Y;
TX: ProgramPart s3 = ProgramPart s4
by AMI_1:123;
  now
    let k be Element of NAT;
    per cases;
    suppose
      0 < k;
      then 1+0 <= k by INT_1:20;
      hence IC Comput(ProgramPart(s3),s3,k) in dom pIF by A7,A5,A8,TX,AMI_1:52;
    end;
    suppose
      k = 0;
      then Comput(ProgramPart(s3),s3,k) = s3 by AMI_1:13;
      hence IC Comput(ProgramPart(s3),s3,k) in dom pIF by A2,SCMPDS_4:75;
    end;
  end;
  hence IF is_closed_on s by Def2;
  ProgramPart s3 halts_on s3 by A8,TX,AMI_1:146;
  hence thesis by Def3;
end;

theorem Th94:
  for s being State of SCMPDS,I being halt-free shiftable
Program of SCMPDS, a being Int_position,k1 being Integer st s.DataLoc(s.a,k1)>
0 & I is_closed_on s & I is_halting_on s holds IExec(if>0(a,k1,I),s) = IExec(I,
  s) +* Start-At((card I+1),SCMPDS)
proof
  let s be State of SCMPDS,I be halt-free shiftable Program of SCMPDS, a be
  Int_position,k1 be Integer;
  set b=DataLoc(s.a,k1);
  set IF=if>0(a,k1,I), IsIF=Initialized stop IF, pI=stop I, IsI= Initialized
  pI, s2 = s +* IsI, s3 = s +* IsIF, s4 = Comput(ProgramPart( s3), s3,1);
  set i = (a,k1)<=0_goto (card I + 1);
  set SAl=Start-At((card I+1),SCMPDS);
A1: IC s3 = 0 by FUNCT_4:26,SCMPDS_5:18;
A2: not b in dom IsIF by SCMPDS_4:31;
  not a in dom IsIF by SCMPDS_4:31;
  then
A3: s3.DataLoc(s3.a,k1)=s3.b by FUNCT_4:12
    .= s.b by A2,FUNCT_4:12;
A4: Comput(ProgramPart( s3), s3,0 + 1) = Following(ProgramPart s3,
Comput(ProgramPart(s3),s3,0)) by AMI_1:14
    .= Following(ProgramPart s3,s3) by AMI_1:13
    .= Exec(i,s3) by Th22;
  assume
  s.b > 0;
  then
A5: IC s4 = succ IC s3 by A4,A3,SCMPDS_2:68
    .= (0+1) by A1;
A6: DataPart s2 = DataPart s3 by SCMPDS_4:24,36;
  now
    let a;
    thus s2.a = s3.a by A6,SCMPDS_4:23
      .= s4.a by A4,SCMPDS_2:68;
  end;
  then
A7: DataPart s2 = DataPart s4 by SCMPDS_4:23;
  assume
A8: I is_closed_on s;
  then
A9: I is_closed_on s2 by Th38;
A10: dom ProgramPart s = A by AMI_1:143;
A11: IsI c= s2 & Shift(pI,1) c= s4 by Lm5,FUNCT_4:26;
  assume
A12: I is_halting_on s;
  then
A13: ProgramPart s2 halts_on s2 by Def3;
T: ProgramPart s3 = ProgramPart Comput(
ProgramPart(s3),s3,1)
by AMI_1:123;
x: Comput(ProgramPart(s3),s3,LifeSpan(ProgramPart(s2),s2)+1)
 = Comput(ProgramPart(s3),Comput(ProgramPart(s3),s3,1),LifeSpan(ProgramPart(s2)
,s2))
by AMI_1:51;
TX4: ProgramPart s4 = ProgramPart
Comput(ProgramPart(s4),s4,LifeSpan(ProgramPart(s2),s2))
by AMI_1:123;
TX2: ProgramPart s2 = ProgramPart
Comput(ProgramPart(s2),s2,LifeSpan(ProgramPart(s2),
s2))
by AMI_1:123;
A14: CurInstr(ProgramPart s3,
Comput(ProgramPart(s3),s3,LifeSpan(ProgramPart(s2),s2)+1))
 =CurInstr(ProgramPart s4,
 Comput(ProgramPart(s4),s4,LifeSpan(ProgramPart(s2),s2))) by x,T
    .=CurInstr(ProgramPart s2,
    Comput(ProgramPart(s2),s2,LifeSpan(ProgramPart(s2),s2))) by A9,A11,A5,A7
,Th45,TX2,TX4
    .= halt SCMPDS by A13,AMI_1:def 46;
  then
A15: ProgramPart s3 halts_on s3 by AMI_1:146;
A16: CurInstr(ProgramPart s3,s3) = i by Th22;
  now
    let l be Element of NAT;
    assume
A17: l < LifeSpan(ProgramPart(s2),s2) + 1;
u: Comput(ProgramPart(s3),s3,0) = s3 by AMI_1:13;
    per cases;
    suppose
      l = 0;
      then CurInstr(ProgramPart (s3),Comput(ProgramPart(s3),s3,l))
       = CurInstr(ProgramPart s3,s3)
       by u;
      hence CurInstr(ProgramPart (s3),Comput(ProgramPart(s3),s3,l))
       <> halt SCMPDS by A16,Th30;
    end;
    suppose
      l <> 0;
      then consider n be Nat such that
A18:  l = n + 1 by NAT_1:6;
      reconsider n as Element of NAT by ORDINAL1:def 13;
A19:  n < LifeSpan(ProgramPart(s2),s2) by A17,A18,XREAL_1:8;
      assume
A20:  CurInstr(ProgramPart s3,Comput(ProgramPart(s3),
s3,l)) = halt SCMPDS;
T: ProgramPart s3 = ProgramPart Comput(ProgramPart(s3),
s3,1)
by AMI_1:123;
x: Comput(ProgramPart(s3),s3,n+1)
 = Comput(ProgramPart(s3),Comput(ProgramPart(s3),s3,1),n) by AMI_1:51;
TX2: ProgramPart s2 = ProgramPart Comput(ProgramPart(s2),s2,n)
by AMI_1:123;
TX4: ProgramPart s4 = ProgramPart Comput(ProgramPart(s4),s4,n)
by AMI_1:123;
      CurInstr(ProgramPart s2,Comput(ProgramPart(s2),
s2,n)) =
      CurInstr(ProgramPart s4,Comput(ProgramPart(s4),
s4,n)) by A9,A11,A5,A7,TX2,TX4,Th45
        .= halt SCMPDS by A18,A20,x,T;
      hence contradiction by A13,A19,AMI_1:def 46;
    end;
  end;
  then for l be Element of NAT st CurInstr(ProgramPart (s3),
  Comput(ProgramPart(s3),s3,l)) = halt SCMPDS
  holds LifeSpan(ProgramPart(s2),s2) + 1 <= l;
  then
A21: LifeSpan(ProgramPart(s3),s3) = LifeSpan(ProgramPart(s2),s2) + 1 by A14,A15
,AMI_1:def 46;
T: ProgramPart s3 = ProgramPart s4
by AMI_1:123;
A22: DataPart Result(ProgramPart(s2),s2) = DataPart Comput(ProgramPart(s2),s2,
LifeSpan(ProgramPart(s2),s2)) by A13,AMI_1:122
    .= DataPart Comput(ProgramPart( s3), s4,LifeSpan(ProgramPart(s2),s2)) by A9
,A11,A5,A7,Th45,T
    .= DataPart Comput(ProgramPart( s3), s3,LifeSpan(ProgramPart(s2),s2) + 1)
by AMI_1:51
    .= DataPart Result(ProgramPart(s3),s3) by A15,A21,AMI_1:122;
A23: now
    let x be set;
A24: IExec(I,s) = Result(ProgramPart(s2),s2) +* s | A by SCMPDS_4:def 8;
A25: IExec(IF,s) = Result(ProgramPart(s3),s3) +* s | A by SCMPDS_4:def 8;
A26: dom SAl = {IC SCMPDS} by FUNCOP_1:19;
    assume
A27: x in dom IExec(IF,s);
    per cases by A27,SCMPDS_4:20;
    suppose
A28:  x is Int_position;
      then x <> IC SCMPDS by SCMPDS_2:52;
      then
A29:  not x in dom SAl by A26,TARSKI:def 1;
A30: not x in dom (s | A) by A10,A28,SCMPDS_2:53;
      hence IExec(IF,s).x = (Result(ProgramPart(s3),s3)).x by A25,FUNCT_4:12
        .= (Result(ProgramPart(s2),s2)).x by A22,A28,SCMPDS_4:23
        .= IExec(I,s).x by A24,A30,FUNCT_4:12
        .= (IExec(I,s) +* SAl).x by A29,FUNCT_4:12;
    end;
    suppose
A31:  x = IC SCMPDS;
A32: not x in dom (s | A) by A10,A31,AMI_1:48;
      then
A33:  IC Result(ProgramPart(s2),s2) = IC IExec(I,s) by A24,A31,FUNCT_4:12
        .=  card I by A8,A12,Th48;
A34:  x in dom SAl by A26,A31,TARSKI:def 1;
T: ProgramPart s3 = ProgramPart s4
by AMI_1:123;
      thus IExec(IF,s).x = (Result(ProgramPart(s3),s3)).x by A25,A32,FUNCT_4:12
        .= Comput(ProgramPart( s3), s3,LifeSpan(ProgramPart(s2),s2) + 1).x by
A15,A21,AMI_1:122
        .= IC Comput(ProgramPart( s3), s4,LifeSpan(ProgramPart(s2),s2)) by A31,
AMI_1:51
        .= IC Comput(ProgramPart( s2), s2,LifeSpan(ProgramPart(s2),s2)) + 1
        by A9,A11,A5,A7,Th45,T
        .= IC Result(ProgramPart(s2),s2) + 1 by A13,AMI_1:122
        .= SAl.IC SCMPDS by A33,FUNCOP_1:87
        .= (IExec(I,s) +* SAl).x by A31,A34,FUNCT_4:14;
    end;
    suppose
      x is Element of NAT;
      hence IExec(IF,s).x = (IExec(I,s) +* SAl).x by Th26;
    end;
  end;
  dom IExec(IF,s) = the carrier of SCMPDS by PARTFUN1:def 4
    .= dom (IExec(I,s) +* SAl) by PARTFUN1:def 4;
  hence thesis by A23,FUNCT_1:9;
end;

theorem Th95:
  for s being State of SCMPDS,I being Program of SCMPDS,a being
Int_position, k1 being Integer st s.DataLoc(s.a,k1) <= 0 holds IExec(if>0(a,k1,
  I),s) = s +* Start-At((card I+1),SCMPDS)
proof
  let s be State of SCMPDS,I be Program of SCMPDS,a be Int_position, k1 be
  Integer;
  set b=DataLoc(s.a,k1);
  set IF=if>0(a,k1,I), pIF=stop IF, IsIF=Initialized pIF, s3 = s +* IsIF, s4 =
  Comput(ProgramPart( s3), s3,1);
  set i = (a,k1)<=0_goto (card I + 1);
  set SAl=Start-At((card I+1),SCMPDS);
A1: IC s3 = 0 by FUNCT_4:26,SCMPDS_5:18;
A2: not b in dom IsIF by SCMPDS_4:31;
  not a in dom IsIF by SCMPDS_4:31;
  then
A3: s3.DataLoc(s3.a,k1)=s3.b by FUNCT_4:12
    .= s.b by A2,FUNCT_4:12;
A4: Comput(ProgramPart( s3), s3,0 + 1) = Following(ProgramPart s3,
Comput(ProgramPart(s3),s3,0)) by AMI_1:14
    .= Following(ProgramPart s3,s3) by AMI_1:13
    .= Exec(i,s3) by Th22;
  assume
  s.b <= 0;
  then
A5: IC s4 = ICplusConst(s3,card I + 1) by A4,A3,SCMPDS_2:68
    .= (0+(card I + 1)) by A1,Th23;
  IsIF c= s3 by FUNCT_4:26;
  then
A6: pIF c= s4 by AMI_1:81,SCMPDS_4:57;
Y:  (ProgramPart s4)/.IC s4
 = s4.IC s4 by AMI_1:150;
TX: ProgramPart s3 = ProgramPart s4
by AMI_1:123;
A7: card IF=card I+1 by Th15;
  then (card I+1) in dom pIF by Th25;
  then s4.(card I+1) = pIF.(card I+1) by A6,GRFUNC_1:8
    .=halt SCMPDS by A7,Th25;
  then
A8: CurInstr(ProgramPart s3,s4) = halt SCMPDS by A5,Y,TX;
  then
A9: ProgramPart s3 halts_on s3 by AMI_1:146;
A10: CurInstr(ProgramPart s3,s3) = i by Th22;
  now
    let l be Element of NAT;
u: Comput(ProgramPart(s3),s3,0) = s3 by AMI_1:13;
    assume
    l < 1;
    then l <1+0;
    then l=0 by NAT_1:13;
    then CurInstr(ProgramPart s3,Comput(ProgramPart(s3),s3,l))
     = CurInstr(ProgramPart s3,s3) by u;
    hence CurInstr(ProgramPart (s3),Comput(ProgramPart(s3),s3,l))
     <> halt SCMPDS by A10,Th30;
  end;
  then for l be Element of NAT st CurInstr(ProgramPart (s3),
  Comput(ProgramPart(s3),s3,l)) = halt SCMPDS
  holds 1 <= l;
  then LifeSpan(ProgramPart(s3),s3) = 1 by A8,A9,AMI_1:def 46;
  then
A11: s4 = Result(ProgramPart(s3),s3) by A9,AMI_1:122;
A12: dom ProgramPart s = A by AMI_1:143;
A13: now
A14: dom SAl = {IC SCMPDS} by FUNCOP_1:19;
    let x be set;
A15: IExec(IF,s) = Result(ProgramPart(s3),s3) +* s | A by SCMPDS_4:def 8;
    assume
A16: x in dom IExec(IF,s);
    per cases by A16,SCMPDS_4:20;
    suppose
A17:  x is Int_position;
      then x <> IC SCMPDS by SCMPDS_2:52;
      then
A18:  not x in dom SAl by A14,TARSKI:def 1;
      not x in dom (s | A) by A12,A17,SCMPDS_2:53;
      hence IExec(IF,s).x = s4.x by A11,A15,FUNCT_4:12
        .= s3.x by A4,A17,SCMPDS_2:68
        .= s.x by A17,SCMPDS_5:19
        .= (s +* SAl).x by A18,FUNCT_4:12;
    end;
    suppose
A19:  x = IC SCMPDS;
      not x in dom (s | A) by A12,A19,AMI_1:48;
      hence IExec(IF,s).x = (card I + 1) by A5,A11,A15,A19,FUNCT_4:12
        .= (s +* SAl).x by A19,FUNCT_4:121;
    end;
    suppose
      x is Element of NAT;
      hence IExec(IF,s).x = (s +* SAl).x by Th27;
    end;
  end;
  dom IExec(IF,s) = the carrier of SCMPDS by PARTFUN1:def 4
    .= dom (s +* SAl) by PARTFUN1:def 4;
  hence thesis by A13,FUNCT_1:9;
end;

registration
  let I be shiftable parahalting Program of SCMPDS, a be Int_position,k1 be
  Integer;
  cluster if>0(a,k1,I) -> shiftable parahalting;
  correctness
  proof
    set i = (a,k1)<=0_goto (card I +1);
    set IF=if>0(a,k1,I), IsIF=Initialized stop IF;
    IF =Load i ';' I by SCMPDS_4:def 4;
    hence IF is shiftable;
    now
      let s be State of SCMPDS;
      assume
      IsIF c= s;
      then
A1:   s = s +* IsIF by FUNCT_4:79;
A2:   I is_closed_on s & I is_halting_on s by Th34,Th35;
      per cases;
      suppose
        s.DataLoc(s.a,k1) > 0;
        then IF is_halting_on s by A2,Th92;
        hence ProgramPart s halts_on s by A1,Def3;
      end;
      suppose
        s.DataLoc(s.a,k1) <= 0;
        then IF is_halting_on s by Th93;
        hence ProgramPart s halts_on s by A1,Def3;
      end;
    end;
    then IsIF is halting by AMI_1:def 26;
    hence thesis by SCMPDS_4:def 10;
  end;
end;

registration
  let I be halt-free Program of SCMPDS, a be Int_position,k1 be Integer;
  cluster if>0(a,k1,I) -> halt-free;
  coherence;
end;

theorem
  for s being State of SCMPDS,I being halt-free shiftable parahalting
Program of SCMPDS,a being Int_position,k1 being Integer holds IC IExec(if>0(a,
  k1,I),s) =  (card I + 1)
proof
  let s be State of SCMPDS,I be halt-free shiftable parahalting Program of
  SCMPDS,a be Int_position,k1 be Integer;
  set IF=if>0(a,k1,I);
A1: I is_closed_on s & I is_halting_on s by Th34,Th35;
  per cases;
  suppose
    s.DataLoc(s.a,k1) > 0;
    then IExec(IF,s) =IExec(I,s) +* Start-At((card I+1),SCMPDS)
    by A1,Th94;
    hence thesis by FUNCT_4:121;
  end;
  suppose
    s.DataLoc(s.a,k1) <= 0;
    then IExec(IF,s) =s +* Start-At((card I+1),SCMPDS) by Th95;
    hence thesis by FUNCT_4:121;
  end;
end;

theorem
  for s being State of SCMPDS,I being halt-free shiftable parahalting
Program of SCMPDS,a,b being Int_position,k1 being Integer st s.DataLoc(s.a,k1)>
  0 holds IExec(if>0(a,k1,I),s).b = IExec(I,s).b
proof
  let s be State of SCMPDS,I be halt-free shiftable parahalting Program of
  SCMPDS,a,b be Int_position,k1 be Integer;
  assume
A1: s.DataLoc(s.a,k1) > 0;
A2: not b in dom Start-At((card I+1),SCMPDS) by SCMPDS_4:59;
  I is_closed_on s & I is_halting_on s by Th34,Th35;
  then IExec(if>0(a,k1,I),s) = IExec(I,s) +* Start-At((card I+1),SCMPDS)
  by A1,Th94;
  hence thesis by A2,FUNCT_4:12;
end;

theorem
  for s being State of SCMPDS,I being Program of SCMPDS,a,b being
Int_position, k1 being Integer st s.DataLoc(s.a,k1) <= 0 holds IExec(if>0(a,k1,
  I),s).b = s.b
proof
  let s be State of SCMPDS,I be Program of SCMPDS,a,b be Int_position, k1 be
  Integer;
  assume
  s.DataLoc(s.a,k1) <= 0;
  then
A1: IExec(if>0(a,k1,I),s) = s +* Start-At((card I+1),SCMPDS) by Th95;
  not b in dom Start-At((card I+1),SCMPDS) by SCMPDS_4:59;
  hence thesis by A1,FUNCT_4:12;
end;

begin :: The computation of "if var<=0 then block"

theorem
  card if<=0(a,k1,I) = card I + 2 by Lm8;

theorem
   0 in dom if<=0(a,k1,I) &  1 in dom if<=0(a,k1,I) by Lm9;

theorem
  if<=0(a,k1,I). 0 = (a,k1)<=0_goto 2 & if<=0(a,k1,I). 1 =
  goto (card I + 1) by Lm10;

theorem Th102:
  for s being State of SCMPDS, I being shiftable Program of
  SCMPDS, a being Int_position,k1 being Integer st s.DataLoc(s.a,k1) <= 0 & I
is_closed_on s & I is_halting_on s holds if<=0(a,k1,I) is_closed_on s & if<=0(a
  ,k1,I) is_halting_on s
proof
  let s be State of SCMPDS, I be shiftable Program of SCMPDS, a be
  Int_position,k1 be Integer;
  set b=DataLoc(s.a,k1);
  set IF=if<=0(a,k1,I), pIF=stop IF, IsIF=Initialized pIF, pI=stop I, IsI=
  Initialized pI, s2 = s +* IsI, s3 = s +* IsIF, s4 = Comput(ProgramPart(s3),s3
,1);
  set i = (a,k1)<=0_goto 2, j = goto (card I + 1);
A1: IF = i ';' (j ';' I) by SCMPDS_4:52;
A2: Comput(ProgramPart( s3), s3,0 + 1) = Following(ProgramPart s3,
Comput(ProgramPart(s3),s3,0)) by AMI_1:14
    .= Following(ProgramPart s3,s3) by AMI_1:13
    .= Exec(i,s3) by A1,Th22;
A3: DataPart s2 = DataPart s3 by SCMPDS_4:24,36;
  now
    let a;
    thus s2.a = s3.a by A3,SCMPDS_4:23
      .= s4.a by A2,SCMPDS_2:68;
  end;
  then
A4: DataPart s2 = DataPart s4 by SCMPDS_4:23;
A5: not b in dom IsIF by SCMPDS_4:31;
  not a in dom IsIF by SCMPDS_4:31;
  then
A6: s3.DataLoc(s3.a,k1)=s3.b by FUNCT_4:12
    .= s.b by A5,FUNCT_4:12;
A7: IC s3 = 0 by FUNCT_4:26,SCMPDS_5:18;
  assume
  s.b <= 0;
  then
A8: IC s4 = ICplusConst(s3,2) by A2,A6,SCMPDS_2:68
    .= (0+2) by A7,Th23;
  assume
A9: I is_closed_on s;
  then
A10: I is_closed_on s2 by Th38;
  assume
  I is_halting_on s;
  then
A11: ProgramPart s2 halts_on s2 by Def3;
A12: IsI c= s2 & Shift(pI,2) c= s4 by Lm6,FUNCT_4:26;
A13:  0 in dom pIF by SCMPDS_4:75;
  now
    let k be Element of NAT;
    per cases;
    suppose
      0 < k;
      then consider k1 being Nat such that
A14:  k1 + 1 = k by NAT_1:6;
      reconsider k1 as Element of NAT by ORDINAL1:def 13;
      reconsider m = IC Comput(ProgramPart( s2), s2,k1) as Element of NAT;
A15:  card pIF = 1+ card IF by SCMPDS_5:7
        .= 1+(card I +2) by Lm8
        .= 1+card I +2
        .=card pI+2 by SCMPDS_5:7;
       m in dom pI by A9,Def2;
      then m < card pI by AFINSQ_1:70;
      then
A16:  m+2 < card pIF by A15,XREAL_1:8;
T: ProgramPart s3 = ProgramPart s4
by AMI_1:123;
      IC Comput(ProgramPart(s3),s3,k) = IC Comput(ProgramPart( s3), s4,k1) by
A14,AMI_1:51
        .=  (m + 2) by A10,A12,A8,A4,Th45,T;
      hence IC Comput(ProgramPart(s3),s3,k) in dom pIF by A16,AFINSQ_1:70;
    end;
    suppose
      k = 0;
      hence IC Comput(ProgramPart(s3),s3,k) in dom pIF by A13,A7,AMI_1:13;
    end;
  end;
  hence IF is_closed_on s by Def2;
T: ProgramPart s3 = ProgramPart Comput(
ProgramPart(s3),s3,1)
by AMI_1:123;
x: Comput(ProgramPart(s3),s3,LifeSpan(ProgramPart(s2),s2)+1)
 = Comput(ProgramPart(s3),Comput(ProgramPart(s3),s3,1),LifeSpan(ProgramPart(s2)
,s2))
by AMI_1:51;
TX4: ProgramPart s4 = ProgramPart
Comput(ProgramPart(s4),s4,LifeSpan(ProgramPart(s2),s2)
)
by AMI_1:123;
TX2: ProgramPart s2 = ProgramPart
Comput(ProgramPart(s2),s2,LifeSpan(ProgramPart(s2),
s2))
by AMI_1:123;
  CurInstr(ProgramPart s3,
  Comput(ProgramPart(s3),s3,LifeSpan(ProgramPart(s2),s2)+1))
   =CurInstr(ProgramPart s4,
   Comput(ProgramPart(s4),s4,LifeSpan(ProgramPart(s2),s2))) by x,T
    .=CurInstr(ProgramPart s2,
    Comput(ProgramPart(s2),s2,LifeSpan(ProgramPart(s2),s2))) by A10,A12,A8,A4
,Th45,TX2,TX4
    .= halt SCMPDS by A11,AMI_1:def 46;
  then ProgramPart s3 halts_on s3 by AMI_1:146;
  hence thesis by Def3;
end;

theorem Th103:
  for s being State of SCMPDS,I being Program of SCMPDS, a being
  Int_position, k1 being Integer st s.DataLoc(s.a,k1) > 0 holds if<=0(a,k1,I)
  is_closed_on s & if<=0(a,k1,I) is_halting_on s
proof
  let s be State of SCMPDS,I be Program of SCMPDS, a be Int_position,k1 be
  Integer;
  set b=DataLoc(s.a,k1);
  assume
A1: s.b > 0;
  set i = (a,k1)<=0_goto 2, j = goto (card I + 1);
  set IF=if<=0(a,k1,I), pIF=stop IF, IsIF=Initialized pIF, s3 = s +* IsIF, s4
  = Comput(ProgramPart(s3),s3,1), s5 = Comput(ProgramPart(s3),s3,2);
A2: IF =i ';' (j ';' I) by SCMPDS_4:52;
A3: not b in dom IsIF by SCMPDS_4:31;
  not a in dom IsIF by SCMPDS_4:31;
  then
A4: s3.DataLoc(s3.a,k1)=s3.b by FUNCT_4:12
    .= s.b by A3,FUNCT_4:12;
A5: IC s3 = 0 by FUNCT_4:26,SCMPDS_5:18;
  Comput(ProgramPart( s3), s3,0 + 1) = Following(ProgramPart s3,
  Comput(ProgramPart(s3),s3,0)) by AMI_1:14
    .= Following(ProgramPart s3,s3) by AMI_1:13
    .= Exec(i,s3) by A2,Th22;
  then
A6: IC s4 = succ IC s3 by A1,A4,SCMPDS_2:68
    .= (0+1) by A5;
A7: IsIF c= s3 by FUNCT_4:26;
  then
A8: pIF c= s4 by AMI_1:81,SCMPDS_4:57;
A9:  1 in dom IF by Lm9;
  then  1 in dom pIF by Th18;
  then
A10: s4. 1 = pIF. 1 by A8,GRFUNC_1:8
    .=IF. 1 by A9,Th19
    .=j by Lm10;
A11: card IF=card I+2 by Lm8;
  then
A12: (card I+2) in dom pIF by Th25;
Y:  (ProgramPart s4)/.IC s4
 = s4.IC s4 by AMI_1:150;
T: ProgramPart s3 = ProgramPart s4
by AMI_1:123;
  Comput(ProgramPart( s3), s3,1 + 1) = Following(ProgramPart s3,s4) by AMI_1:14
    .= Exec(j,s4) by A6,A10,Y,T;
  then
A13: IC s5 = ICplusConst(s4,card I+1) by SCMPDS_2:66
    .= (card I+1+1) by A6,Th23
    .= (card I+(1+1));
Y:  (ProgramPart s5)/.IC s5
 = s5.IC s5 by AMI_1:150;
TX: ProgramPart s3 = ProgramPart s5
by AMI_1:123;
  pIF c= s5 by A7,AMI_1:81,SCMPDS_4:57;
  then s5.(card I+2) = pIF.(card I+2) by A12,GRFUNC_1:8
    .=halt SCMPDS by A11,Th25;
  then
A14: CurInstr(ProgramPart s3,s5) = halt SCMPDS by A13,Y,TX;
  now
    let k be Element of NAT;
A15: k = 0 or 0 + 1 <= k by INT_1:20;
    per cases by A15,XXREAL_0:1;
    suppose
      k = 0;
      then Comput(ProgramPart(s3),s3,k) = s3 by AMI_1:13;
      hence IC Comput(ProgramPart(s3),s3,k) in dom pIF by A5,SCMPDS_4:75;
    end;
    suppose
      k = 1;
      hence IC Comput(ProgramPart(s3),s3,k) in dom pIF by A9,A6,Th18;
    end;
    suppose
      1 < k;
      then 1+1 <= k by INT_1:20;
      hence IC Comput(ProgramPart(s3),s3,k) in dom pIF
      by A12,A13,A14,AMI_1:52;
    end;
  end;
  hence IF is_closed_on s by Def2;
  ProgramPart s3 halts_on s3 by A14,AMI_1:146;
  hence thesis by Def3;
end;

theorem Th104:
  for s being State of SCMPDS,I being halt-free shiftable
  Program of SCMPDS, a being Int_position,k1 being Integer st s.DataLoc(s.a,k1)
  <= 0 & I is_closed_on s & I is_halting_on s holds IExec(if<=0(a,k1,I),s) =
  IExec(I,s) +* Start-At((card I+2),SCMPDS)
proof
  let s be State of SCMPDS,I be halt-free shiftable Program of SCMPDS, a be
  Int_position,k1 be Integer;
  set b=DataLoc(s.a,k1);
  set IF=if<=0(a,k1,I), IsIF=Initialized stop IF, pI=stop I, IsI= Initialized
  pI, s2 = s +* IsI, s3 = s +* IsIF, s4 = Comput(ProgramPart( s3), s3,1);
  set i = (a,k1)<=0_goto 2, j = goto (card I + 1);
  set SAl=Start-At((card I+2),SCMPDS);
A1: IF=i ';' (j ';' I) by SCMPDS_4:52;
A2: Comput(ProgramPart( s3), s3,0 + 1) = Following(ProgramPart s3,
Comput(ProgramPart(s3),s3,0)) by AMI_1:14
    .= Following(ProgramPart s3,s3) by AMI_1:13
    .= Exec(i,s3) by A1,Th22;
A3: not b in dom IsIF by SCMPDS_4:31;
  not a in dom IsIF by SCMPDS_4:31;
  then
A4: s3.DataLoc(s3.a,k1)=s3.b by FUNCT_4:12
    .= s.b by A3,FUNCT_4:12;
A5: IC s3 = 0 by FUNCT_4:26,SCMPDS_5:18;
A6: IsI c= s2 & Shift(pI,2) c= s4 by Lm6,FUNCT_4:26;
A7: DataPart s2 = DataPart s3 by SCMPDS_4:24,36;
  now
    let a;
    thus s2.a = s3.a by A7,SCMPDS_4:23
      .= s4.a by A2,SCMPDS_2:68;
  end;
  then
A8: DataPart s2 = DataPart s4 by SCMPDS_4:23;
  assume
  s.b <= 0;
  then
A9: IC s4 = ICplusConst(s3,2) by A2,A4,SCMPDS_2:68
    .= (0+2) by A5,Th23;
A10: dom ProgramPart s = A by AMI_1:143;
  assume
A11: I is_closed_on s;
  then
A12: I is_closed_on s2 by Th38;
  assume
A13: I is_halting_on s;
  then
A14: ProgramPart s2 halts_on s2 by Def3;
T: ProgramPart s3 = ProgramPart Comput(
ProgramPart(s3),s3,1)
by AMI_1:123;
x: Comput(ProgramPart(s3),s3,LifeSpan(ProgramPart(s2),s2)+1)
 = Comput(ProgramPart(s3),Comput(ProgramPart(s3),s3,1),LifeSpan(ProgramPart(s2)
,s2))
by AMI_1:51;
TX4: ProgramPart s4 = ProgramPart
Comput(ProgramPart(s4),s4,LifeSpan(ProgramPart(s2),s2))
by AMI_1:123;
TX2: ProgramPart s2 = ProgramPart
Comput(ProgramPart(s2),s2,LifeSpan(ProgramPart(s2),
s2))
by AMI_1:123;
A15: CurInstr(ProgramPart s3,
Comput(ProgramPart(s3),s3,LifeSpan(ProgramPart(s2),s2)+1))
 =CurInstr(ProgramPart s4,
 Comput(ProgramPart(s4),s4,LifeSpan(ProgramPart(s2),s2))) by x,T
    .=CurInstr(ProgramPart s2,
    Comput(ProgramPart(s2),s2,LifeSpan(ProgramPart(s2),s2))) by A12,A6,A9,A8
,Th45,TX2,TX4
    .= halt SCMPDS by A14,AMI_1:def 46;
  then
A16: ProgramPart s3 halts_on s3 by AMI_1:146;
A17: CurInstr(ProgramPart s3,s3) = i by A1,Th22;
  now
    let l be Element of NAT;
    assume
A18: l < LifeSpan(ProgramPart(s2),s2) + 1;
u: Comput(ProgramPart(s3),s3,0) = s3 by AMI_1:13;
    per cases;
    suppose
      l = 0;
      then CurInstr(ProgramPart s3,Comput(ProgramPart(s3),s3,l))
       = CurInstr(ProgramPart s3,s3)
       by u;
      hence CurInstr(ProgramPart (s3),Comput(ProgramPart(s3),s3,l))
       <> halt SCMPDS by A17,Th30;
    end;
    suppose
      l <> 0;
      then consider n be Nat such that
A19:  l = n + 1 by NAT_1:6;
      reconsider n as Element of NAT by ORDINAL1:def 13;
A20:  n < LifeSpan(ProgramPart(s2),s2) by A18,A19,XREAL_1:8;
      assume
A21:  CurInstr(ProgramPart (s3),Comput(ProgramPart(s3),s3,l)) = halt SCMPDS;
T: ProgramPart s3 = ProgramPart Comput(ProgramPart(s3),
s3,1)
by AMI_1:123;
x: Comput(ProgramPart(s3),s3,n+1)
 = Comput(ProgramPart(s3),Comput(ProgramPart(s3),s3,1),n) by AMI_1:51;
TX2: ProgramPart s2 = ProgramPart Comput(ProgramPart(s2),s2,n)
by AMI_1:123;
TX4: ProgramPart s4 = ProgramPart Comput(ProgramPart(s4),s4,n)
by AMI_1:123;
      CurInstr(ProgramPart s2,Comput(ProgramPart(s2),s2,n)) =
      CurInstr(ProgramPart s4,Comput(ProgramPart(s4),s4,n))
       by A12,A6,A9,A8,Th45,TX2,TX4
        .= halt SCMPDS by A19,A21,x,T;
      hence contradiction by A14,A20,AMI_1:def 46;
    end;
  end;
  then for l be Element of NAT st CurInstr(ProgramPart (s3),
  Comput(ProgramPart(s3),s3,l)) = halt SCMPDS
  holds LifeSpan(ProgramPart(s2),s2) + 1 <= l;
  then
A22: LifeSpan(ProgramPart(s3),s3) = LifeSpan(ProgramPart(s2),s2) + 1 by A15,A16
,AMI_1:def 46;
T: ProgramPart s3 = ProgramPart s4
by AMI_1:123;
A23: DataPart Result(ProgramPart(s2),s2) = DataPart Comput(ProgramPart(s2),s2,
LifeSpan(ProgramPart(s2),s2)) by A14,AMI_1:122
    .= DataPart Comput(ProgramPart( s3), s4,LifeSpan(ProgramPart(s2),s2)) by
A12,A6,A9,A8,Th45,T
    .= DataPart Comput(ProgramPart( s3), s3,LifeSpan(ProgramPart(s2),s2) + 1)
by AMI_1:51
    .= DataPart Result(ProgramPart(s3),s3) by A16,A22,AMI_1:122;
A24: now
    let x be set;
A25: IExec(I,s) = Result(ProgramPart(s2),s2) +* s | A by SCMPDS_4:def 8;
A26: IExec(IF,s) = Result(ProgramPart(s3),s3) +* s | A by SCMPDS_4:def 8;
A27: dom Start-At((card I+2),SCMPDS) = {IC SCMPDS} by FUNCOP_1:19;
    assume
A28: x in dom IExec(IF,s);
    per cases by A28,SCMPDS_4:20;
    suppose
A29:  x is Int_position;
      then x <> IC SCMPDS by SCMPDS_2:52;
      then
A30:  not x in dom SAl by A27,TARSKI:def 1;
A31: not x in dom (s | A) by A10,A29,SCMPDS_2:53;
      hence IExec(IF,s).x = (Result(ProgramPart(s3),s3)).x by A26,FUNCT_4:12
        .= (Result(ProgramPart(s2),s2)).x by A23,A29,SCMPDS_4:23
        .= IExec(I,s).x by A25,A31,FUNCT_4:12
        .= (IExec(I,s) +* SAl).x by A30,FUNCT_4:12;
    end;
    suppose
A32:  x = IC SCMPDS;
A33: not x in dom (s | A) by A10,A32,AMI_1:48;
      then
A34:  IC Result(ProgramPart(s2),s2) = IC IExec(I,s) by A25,A32,FUNCT_4:12
        .=  card I by A11,A13,Th48;
A35:  x in dom SAl by A27,A32,TARSKI:def 1;
T: ProgramPart s3 = ProgramPart s4
by AMI_1:123;
      thus IExec(IF,s).x = (Result(ProgramPart(s3),s3)).x by A26,A33,FUNCT_4:12
        .= Comput(ProgramPart( s3), s3,LifeSpan(ProgramPart(s2),s2) + 1).x by
A16,A22,AMI_1:122
        .= IC Comput(ProgramPart( s3), s4,LifeSpan(ProgramPart(s2),s2)) by A32,
AMI_1:51
        .= IC Comput(ProgramPart( s2), s2,LifeSpan(ProgramPart(s2),s2)) + 2
        by A12,A6,A9,A8,Th45,T
        .= IC Result(ProgramPart(s2),s2) + 2 by A14,AMI_1:122
        .= SAl.IC SCMPDS by A34,FUNCOP_1:87
        .= (IExec(I,s) +* SAl).x by A32,A35,FUNCT_4:14;
    end;
    suppose
      x is Element of NAT;
      hence IExec(IF,s).x = (IExec(I,s) +* SAl).x by Th26;
    end;
  end;
  dom IExec(IF,s) = the carrier of SCMPDS by PARTFUN1:def 4
    .= dom (IExec(I,s) +* Start-At((card I+2),SCMPDS)) by PARTFUN1:def 4;
  hence thesis by A24,FUNCT_1:9;
end;

theorem Th105:
  for s being State of SCMPDS,I being Program of SCMPDS,a being
Int_position, k1 being Integer st s.DataLoc(s.a,k1) > 0 holds IExec(if<=0(a,k1,
  I),s) = s +* Start-At((card I+2),SCMPDS)
proof
  let s be State of SCMPDS,I be Program of SCMPDS,a be Int_position, k1 be
  Integer;
  set b=DataLoc(s.a,k1);
  set IF=if<=0(a,k1,I), pIF=stop IF, IsIF=Initialized pIF, s3 = s +* IsIF, s4
  = Comput(ProgramPart(s3),s3,1), s5 = Comput(ProgramPart(s3),s3,2);
  set i = (a,k1)<=0_goto 2, j = goto (card I + 1);
  set SAl=Start-At((card I+2),SCMPDS);
A1: IF =i ';' (j ';' I) by SCMPDS_4:52;
A2: not b in dom IsIF by SCMPDS_4:31;
  not a in dom IsIF by SCMPDS_4:31;
  then
A3: s3.DataLoc(s3.a,k1)=s3.b by FUNCT_4:12
    .= s.b by A2,FUNCT_4:12;
A4: IC s3 = 0 by FUNCT_4:26,SCMPDS_5:18;
A5: IsIF c= s3 by FUNCT_4:26;
  then
A6: pIF c= s4 by AMI_1:81,SCMPDS_4:57;
A7: pIF c= s5 by A5,AMI_1:81,SCMPDS_4:57;
A8: Comput(ProgramPart( s3), s3,0 + 1) = Following(ProgramPart s3,
Comput(ProgramPart(s3),s3,0)) by AMI_1:14
    .= Following(ProgramPart s3,s3) by AMI_1:13
    .= Exec(i,s3) by A1,Th22;
  assume
  s.b > 0;
  then
A9: IC s4 = succ IC s3 by A8,A3,SCMPDS_2:68
    .= (0+1) by A4;
A10:  1 in dom IF by Lm9;
  then  1 in dom pIF by Th18;
  then
A11: s4. 1 = pIF. 1 by A6,GRFUNC_1:8
    .=IF. 1 by A10,Th19
    .=j by Lm10;
Y:  (ProgramPart s4)/.IC s4
 = s4.IC s4 by AMI_1:150;
T: ProgramPart s3 = ProgramPart s4
by AMI_1:123;
A12: Comput(ProgramPart( s3), s3,1 + 1) = Following(ProgramPart s3,s4) by
AMI_1:14
    .= Exec(j,s4) by A9,A11,Y,T;
  then
A13: IC s5 = ICplusConst(s4,card I+1) by SCMPDS_2:66
    .= (card I+1+1) by A9,Th23
    .= (card I+(1+1));
Y:  (ProgramPart s5)/.IC s5
 = s5.IC s5 by AMI_1:150;
TX: ProgramPart s3 = ProgramPart s5
by AMI_1:123;
A14: card IF=card I+2 by Lm8;
  then (card I+2) in dom pIF by Th25;
  then s5.(card I+2) = pIF.(card I+2) by A7,GRFUNC_1:8
    .=halt SCMPDS by A14,Th25;
  then
A15: CurInstr(ProgramPart s3,s5) = halt SCMPDS by A13,Y,TX;
  then
A16: ProgramPart s3 halts_on s3 by AMI_1:146;
A17: CurInstr(ProgramPart s3,s3) = i by A1,Th22;
  now
    let l be Element of NAT;
    assume
    l < 1+1;
    then
A18: l <= 1 by NAT_1:13;
u: Comput(ProgramPart(s3),s3,0) = s3 by AMI_1:13;
Y:  (ProgramPart Comput(ProgramPart(s3),s3,l))/.IC Comput(ProgramPart(s3),s3,l)
 = Comput(ProgramPart(s3),s3,l).IC Comput(ProgramPart(s3),s3,l) by AMI_1:150;
TX3: ProgramPart s3 = ProgramPart Comput(ProgramPart(s3),s3,l)
by AMI_1:123;
    per cases by A18,NAT_1:26;
    suppose
      l=0;
      then CurInstr(ProgramPart s3,Comput(ProgramPart
(s3),s3,l))
       = CurInstr(ProgramPart s3,s3)
       by u;
      hence CurInstr(ProgramPart (s3),Comput(ProgramPart(s3),s3,l))
       <> halt SCMPDS by A17,Th30;
    end;
    suppose
      l=1;
      hence CurInstr(ProgramPart (s3),Comput(ProgramPart(s3),s3,l))
       <> halt SCMPDS by A9,A11,Y,TX3,SCMPDS_2:85;
    end;
  end;
  then for l be Element of NAT st CurInstr(ProgramPart (s3),
  Comput(ProgramPart(s3),s3,l)) = halt SCMPDS
  holds 2 <= l;
  then LifeSpan(ProgramPart(s3),s3) = 2 by A15,A16,AMI_1:def 46;
  then
A19: s5 = Result(ProgramPart(s3),s3) by A16,AMI_1:122;
A20: dom ProgramPart s = A by AMI_1:143;
A21: now
A22: dom SAl = {IC SCMPDS} by FUNCOP_1:19;
    let x be set;
A23: IExec(IF,s) = Result(ProgramPart(s3),s3) +* s | A by SCMPDS_4:def 8;
    assume
A24: x in dom IExec(IF,s);
    per cases by A24,SCMPDS_4:20;
    suppose
A25:  x is Int_position;
      then x <> IC SCMPDS by SCMPDS_2:52;
      then
A26:  not x in dom SAl by A22,TARSKI:def 1;
      not x in dom (s | A) by A20,A25,SCMPDS_2:53;
      hence IExec(IF,s).x = s5.x by A19,A23,FUNCT_4:12
        .= s4.x by A12,A25,SCMPDS_2:66
        .= s3.x by A8,A25,SCMPDS_2:68
        .= s.x by A25,SCMPDS_5:19
        .= (s +* SAl).x by A26,FUNCT_4:12;
    end;
    suppose
A27:  x = IC SCMPDS;
      not x in dom (s | A) by A20,A27,AMI_1:48;
      hence IExec(IF,s).x = (card I + 2) by A13,A19,A23,A27,FUNCT_4:12
        .= (s +* Start-At((card I+2),SCMPDS)).x by A27,FUNCT_4:121;
    end;
    suppose
      x is Element of NAT;
      hence IExec(IF,s).x = (s +* SAl).x by Th27;
    end;
  end;
  dom IExec(IF,s) = the carrier of SCMPDS by PARTFUN1:def 4
    .= dom (s +* SAl) by PARTFUN1:def 4;
  hence thesis by A21,FUNCT_1:9;
end;

registration
  let I be shiftable parahalting Program of SCMPDS, a be Int_position,k1 be
  Integer;
  cluster if<=0(a,k1,I) -> shiftable parahalting;
  correctness
  proof
    set i = (a,k1)<=0_goto 2, j = goto (card I + 1);
    set IF=if<=0(a,k1,I), IsIF=Initialized stop IF;
    IF =Load i ';' Load j ';' I by SCMPDS_4:def 6;
    hence IF is shiftable;
    now
      let s be State of SCMPDS;
      assume
      IsIF c= s;
      then
A1:   s = s +* IsIF by FUNCT_4:79;
A2:   I is_closed_on s & I is_halting_on s by Th34,Th35;
      per cases;
      suppose
        s.DataLoc(s.a,k1) <= 0;
        then IF is_halting_on s by A2,Th102;
        hence ProgramPart s halts_on s by A1,Def3;
      end;
      suppose
        s.DataLoc(s.a,k1) > 0;
        then IF is_halting_on s by Th103;
        hence ProgramPart s halts_on s by A1,Def3;
      end;
    end;
    then IsIF is halting by AMI_1:def 26;
    hence thesis by SCMPDS_4:def 10;
  end;
end;

registration
  let I be halt-free Program of SCMPDS, a be Int_position,k1 be Integer;
  cluster if<=0(a,k1,I) -> halt-free;
  coherence;
end;

theorem
  for s being State of SCMPDS,I being halt-free shiftable parahalting
Program of SCMPDS,a being Int_position,k1 being Integer holds IC IExec(if<=0(a,
  k1,I),s) =  (card I + 2)
proof
  let s be State of SCMPDS,I be halt-free shiftable parahalting Program of
  SCMPDS,a be Int_position,k1 be Integer;
  set IF=if<=0(a,k1,I);
A1: I is_closed_on s & I is_halting_on s by Th34,Th35;
  per cases;
  suppose
    s.DataLoc(s.a,k1) <= 0;
    then IExec(IF,s) =IExec(I,s) +* Start-At((card I+2),SCMPDS)
    by A1,Th104;
    hence thesis by FUNCT_4:121;
  end;
  suppose
    s.DataLoc(s.a,k1) > 0;
    then IExec(IF,s) =s +* Start-At((card I+2),SCMPDS) by Th105;
    hence thesis by FUNCT_4:121;
  end;
end;

theorem
  for s being State of SCMPDS,I being halt-free shiftable parahalting
Program of SCMPDS,a,b being Int_position,k1 being Integer st s.DataLoc(s.a,k1)
  <= 0 holds IExec(if<=0(a,k1,I),s).b = IExec(I,s).b
proof
  let s be State of SCMPDS,I be halt-free shiftable parahalting Program of
  SCMPDS,a,b be Int_position,k1 be Integer;
  assume
A1: s.DataLoc(s.a,k1) <= 0;
A2: not b in dom Start-At((card I+2),SCMPDS) by SCMPDS_4:59;
  I is_closed_on s & I is_halting_on s by Th34,Th35;
  then IExec(if<=0(a,k1,I),s) = IExec(I,s) +* Start-At((card I+2),SCMPDS)
   by A1,Th104;
  hence thesis by A2,FUNCT_4:12;
end;

theorem
  for s being State of SCMPDS,I being Program of SCMPDS,a,b being
Int_position, k1 being Integer st s.DataLoc(s.a,k1) > 0 holds IExec(if<=0(a,k1,
  I),s).b = s.b
proof
  let s be State of SCMPDS,I be Program of SCMPDS,a,b be Int_position, k1 be
  Integer;
  assume
  s.DataLoc(s.a,k1) > 0;
  then
A1: IExec(if<=0(a,k1,I),s) = s +* Start-At((card I+2),SCMPDS) by Th105;
  not b in dom Start-At((card I+2),SCMPDS) by SCMPDS_4:59;
  hence thesis by A1,FUNCT_4:12;
end;

begin :: The computation of "if var<0 then block1 else block2"

theorem
  card if<0(a,k1,I,J) = card I + card J + 2 by Lm3;

theorem
   0 in dom if<0(a,k1,I,J) &  1 in dom if<0(a,k1,I,J)
proof
  set ci=card if<0(a,k1,I,J);
  ci=card I + card J +2 by Lm3;
  then 2 <= ci by NAT_1:12;
  then 1 < ci by XXREAL_0:2;
  hence thesis by AFINSQ_1:70;
end;

theorem
  if<0(a,k1,I,J). 0 = (a,k1)>=0_goto (card I + 2) by Lm4;

theorem Th112:
  for s being State of SCMPDS, I,J being shiftable Program of
  SCMPDS, a being Int_position,k1 being Integer st s.DataLoc(s.a,k1)<0 & I
is_closed_on s & I is_halting_on s holds if<0(a,k1,I,J) is_closed_on s & if<0(a
  ,k1,I,J) is_halting_on s
proof
  let s be State of SCMPDS, I,J be shiftable Program of SCMPDS, a be
  Int_position,k1 be Integer;
  set b=DataLoc(s.a,k1);
  set G=Goto (card J+1);
  set I2 = I ';' G ';' J, IF=if<0(a,k1,I,J), pIF=stop IF, IsIF=Initialized pIF
  , pI2=stop I2, II2= Initialized pI2, s2 = s +* II2, s3 = s +* IsIF, s4 =
  Comput(ProgramPart(s3),s3,1);
  set i = (a,k1)>=0_goto (card I + 2);
A1:  0 in dom pIF by SCMPDS_4:75;
A2: IC s3 = 0 by FUNCT_4:26,SCMPDS_5:18;
A3: not b in dom IsIF by SCMPDS_4:31;
  not a in dom IsIF by SCMPDS_4:31;
  then
A4: s3.DataLoc(s3.a,k1)=s3.b by FUNCT_4:12
    .= s.b by A3,FUNCT_4:12;
A5: IF = i ';' (I ';' G) ';' J by SCMPDS_4:50
    .= i ';' I2 by SCMPDS_4:50;
  then
A6: Shift(pI2,1) c= s4 by Lm5;
A7: Comput(ProgramPart( s3), s3,0 + 1) = Following(ProgramPart s3,
Comput(ProgramPart(s3),s3,0)) by AMI_1:14
    .= Following(ProgramPart s3,s3) by AMI_1:13
    .= Exec(i,s3) by A5,Th22;
A8: DataPart s2 = DataPart s3 by SCMPDS_4:24,36;
  now
    let a;
    thus s2.a = s3.a by A8,SCMPDS_4:23
      .= s4.a by A7,SCMPDS_2:69;
  end;
  then
A9: DataPart s2 = DataPart s4 by SCMPDS_4:23;
  assume
  s.b < 0;
  then
A10: IC s4 = succ IC s3 by A7,A4,SCMPDS_2:69
    .= (0+1) by A2;
  assume
A11: I is_closed_on s;
  assume
A12: I is_halting_on s;
  then
A13: I2 is_closed_on s by A11,Th44;
  then
A14: II2 c= s2 & I2 is_closed_on s2 by Th38,FUNCT_4:26;
  I2 is_halting_on s by A11,A12,Th44;
  then
A15: ProgramPart s2 halts_on s2 by Def3;
A16: card pIF = card IF +1 by SCMPDS_5:7
    .= card I2 +1+1 by A5,Th15;
  now
    let k be Element of NAT;
    per cases;
    suppose
      0 < k;
      then consider k1 being Nat such that
A17:  k1 + 1 = k by NAT_1:6;
      reconsider k1 as Element of NAT by ORDINAL1:def 13;
      reconsider m = IC Comput(ProgramPart( s2), s2,k1) as Element of NAT;
A18:  card pIF = card pI2+1 by A16,SCMPDS_5:7;
       m in dom pI2 by A13,Def2;
      then m < card pI2 by AFINSQ_1:70;
      then
A19:  m+1 < card pIF by A18,XREAL_1:8;
T: ProgramPart s3 = ProgramPart s4
by AMI_1:123;
      IC Comput(ProgramPart(s3),s3,k) = IC Comput(ProgramPart( s3), s4,k1) by
A17,AMI_1:51
        .=  (m + 1) by A14,A6,A10,A9,Th45,T;
      hence IC Comput(ProgramPart(s3),s3,k) in dom pIF by A19,AFINSQ_1:70;
    end;
    suppose
      k = 0;
      hence IC Comput(ProgramPart(s3),s3,k) in dom pIF by A1,A2,AMI_1:13;
    end;
  end;
  hence IF is_closed_on s by Def2;
T: ProgramPart s3 = ProgramPart Comput(
ProgramPart(s3),s3,1)
by AMI_1:123;
x: Comput(ProgramPart(s3),s3,LifeSpan(ProgramPart(s2),s2)+1)
 = Comput(ProgramPart(s3),Comput(ProgramPart(s3),s3,1),LifeSpan(ProgramPart(s2)
,s2))
 by AMI_1:51;
TX4: ProgramPart s4 = ProgramPart
Comput(ProgramPart(s4),s4,LifeSpan(ProgramPart(s2),s2)
)
by AMI_1:123;
TX2: ProgramPart s2 = ProgramPart
Comput(ProgramPart(s2),s2,LifeSpan(ProgramPart(s2),
s2))
by AMI_1:123;
  CurInstr(ProgramPart s3,
  Comput(ProgramPart(s3),s3,LifeSpan(ProgramPart(s2),s2)+1))
   =CurInstr(ProgramPart s4,
   Comput(ProgramPart(s4),s4,LifeSpan(ProgramPart(s2),s2))) by x,T
    .=CurInstr(ProgramPart s2,
    Comput(ProgramPart(s2),s2,LifeSpan(ProgramPart(s2),s2))) by A14,A6,A10,A9
,Th45,TX2,TX4
    .= halt SCMPDS by A15,AMI_1:def 46;
  then ProgramPart s3 halts_on s3 by AMI_1:146;
  hence thesis by Def3;
end;

theorem Th113:
  for s being State of SCMPDS,I being Program of SCMPDS,J being
shiftable Program of SCMPDS,a being Int_position,k1 being Integer st s.DataLoc(
  s.a,k1) >= 0 & J is_closed_on s & J is_halting_on s holds if<0(a,k1,I,J)
  is_closed_on s & if<0(a,k1,I,J) is_halting_on s
proof
  let s be State of SCMPDS,I be Program of SCMPDS, J be shiftable Program of
  SCMPDS, a be Int_position,k1 be Integer;
  set b=DataLoc(s.a,k1);
  set pJ=stop J, IsJ=Initialized pJ, s1 = s +* IsJ, IF=if<0(a,k1,I,J), pIF=
  stop IF, IsIF=Initialized pIF, s3 = s +* IsIF, s4 = Comput(ProgramPart(s3),s3
,1);
  set i = (a,k1)>=0_goto (card I + 2);
  set G =Goto (card J+1), iG=i ';' I ';' G;
A1: IF = i ';' (I ';' G) ';' J by SCMPDS_4:50
    .= i ';' (I ';' G ';' J) by SCMPDS_4:50;
A2: Comput(ProgramPart( s3), s3,0 + 1) = Following(ProgramPart s3,
Comput(ProgramPart(s3),s3,0)) by AMI_1:14
    .= Following(ProgramPart s3,s3) by AMI_1:13
    .= Exec(i,s3) by A1,Th22;
A3: not b in dom IsIF by SCMPDS_4:31;
  not a in dom IsIF by SCMPDS_4:31;
  then
A4: s3.DataLoc(s3.a,k1)=s3.b by FUNCT_4:12
    .= s.b by A3,FUNCT_4:12;
A5: IC s3 = 0 by FUNCT_4:26,SCMPDS_5:18;
  assume
  s.b >= 0;
  then
A6: IC s4 = ICplusConst(s3,card I + 2) by A2,A4,SCMPDS_2:69
    .= (0+(card I + 2)) by A5,Th23;
  assume
A7: J is_closed_on s;
  then
A8: IsJ c= s1 & J is_closed_on s1 by Th38,FUNCT_4:26;
A9: pIF c= s3 by FUNCT_4:26,SCMPDS_4:57;
A10: card iG = card (i ';' I) + card G by SCMPDS_4:45
    .=card (i ';' I) + 1 by SCMPDS_5:6
    .=card I +1 +1 by Th15
    .=card I +(1 +1);
  then Shift(pJ,card I+2) c= pIF by Th24;
  then Shift(pJ,card I+2) c= s3 by A9,XBOOLE_1:1;
  then
A11: Shift(pJ,card I+2) c= s4 by AMI_1:81;
  assume
  J is_halting_on s;
  then
A12: ProgramPart s1 halts_on s1 by Def3;
A13: DataPart s1 = DataPart s3 by SCMPDS_4:24,36;
  now
    let a;
    thus s1.a = s3.a by A13,SCMPDS_4:23
      .= s4.a by A2,SCMPDS_2:69;
  end;
  then
A14: DataPart s1 = DataPart s4 by SCMPDS_4:23;
  now
    let k be Element of NAT;
    per cases;
    suppose
      0 < k;
      then consider k1 being Nat such that
A15:  k1 + 1 = k by NAT_1:6;
      reconsider k1 as Element of NAT by ORDINAL1:def 13;
      reconsider m = IC Comput(ProgramPart( s1), s1,k1) as Element of NAT;
       m in dom pJ by A7,Def2;
      then m < card pJ by AFINSQ_1:70;
      then
A16:  m + (card I + 2) < card pJ + (card I + 2) by XREAL_1:8;
A17:  card pJ = card J + 1 by SCMPDS_5:7;
A18:  card pIF = card IF+1 by SCMPDS_5:7
        .=card I +2 +card J +1 by A10,SCMPDS_4:45
        .=card I +2 + card pJ by A17;
T: ProgramPart s3 = ProgramPart s4
by AMI_1:123;
      IC Comput(ProgramPart(s3),s3,k) = IC Comput(ProgramPart( s3), s4,k1) by
A15,AMI_1:51
        .=  (m + (card I + 2)) by A8,A14,A11,A6,Th45,T;
      hence IC Comput(ProgramPart(s3),s3,k) in dom pIF by A18,A16,AFINSQ_1:70;
    end;
    suppose
      k = 0;
      then Comput(ProgramPart(s3),s3,k) = s3 by AMI_1:13;
      hence IC Comput(ProgramPart(s3),s3,k) in dom pIF by A5,SCMPDS_4:75;
    end;
  end;
  hence IF is_closed_on s by Def2;
T: ProgramPart s3 = ProgramPart Comput(
ProgramPart(s3),s3,1)
by AMI_1:123;
x: Comput(ProgramPart(s3),s3,LifeSpan(ProgramPart(s1),s1)+1)
 = Comput(ProgramPart(s3),Comput(ProgramPart(s3),s3,1),LifeSpan(ProgramPart(s1)
,s1))
by AMI_1:51;
TX4: ProgramPart s4 = ProgramPart
Comput(ProgramPart(s4),s4,LifeSpan(ProgramPart(s1),s1)
)
by AMI_1:123;
TX1: ProgramPart s1 = ProgramPart
Comput(ProgramPart(s1),s1,LifeSpan(ProgramPart(s1),
s1))
by AMI_1:123;
  CurInstr(ProgramPart s3,
  Comput(ProgramPart(s3),s3,LifeSpan(ProgramPart(s1),s1)+1))
   =CurInstr(ProgramPart s4,
   Comput(ProgramPart(s4),s4,LifeSpan(ProgramPart(s1),s1))) by x,T
    .=CurInstr(ProgramPart s1,
    Comput(ProgramPart(s1),s1,LifeSpan(ProgramPart(s1),s1))) by A8,A14,A11,A6
,Th45,TX1,TX4
    .= halt SCMPDS by A12,AMI_1:def 46;
  then ProgramPart s3 halts_on s3 by AMI_1:146;
  hence thesis by Def3;
end;

theorem Th114:
  for s being State of SCMPDS,I being halt-free shiftable
Program of SCMPDS, J being shiftable Program of SCMPDS,a being Int_position,k1
  being Integer st s.DataLoc(s.a,k1) < 0 & I is_closed_on s & I is_halting_on s
holds IExec(if<0(a,k1,I,J),s) = IExec(I,s) +* Start-At( (card I + card J
  + 2),SCMPDS)
proof
  let s be State of SCMPDS,I be halt-free shiftable Program of SCMPDS, J be
  shiftable Program of SCMPDS,a be Int_position,k1 be Integer;
  set b=DataLoc(s.a,k1);
  set G=Goto (card J+1);
  set I2 = I ';' G ';' J, IF=if<0(a,k1,I,J), IsIF=Initialized stop IF, pI2=
stop I2, II2= Initialized pI2, s2 = s +* II2, s3 = s +* IsIF, s4 = Comput(
ProgramPart(
  s3),
  s3,1);
  set i = (a,k1)>=0_goto (card I + 2);
  set SAl= Start-At((card I+card J+2),SCMPDS);
A1: IC s3 = 0 by FUNCT_4:26,SCMPDS_5:18;
A2: not b in dom IsIF by SCMPDS_4:31;
  not a in dom IsIF by SCMPDS_4:31;
  then
A3: s3.DataLoc(s3.a,k1)=s3.b by FUNCT_4:12
    .= s.b by A2,FUNCT_4:12;
A4: dom ProgramPart s = A by AMI_1:143;
A5: IF = i ';' (I ';' G) ';' J by SCMPDS_4:50
    .= i ';' I2 by SCMPDS_4:50;
  then
A6: Shift(pI2,1) c= s4 by Lm5;
A7: Comput(ProgramPart( s3), s3,0 + 1) = Following(ProgramPart s3,
Comput(ProgramPart(s3),s3,0)) by AMI_1:14
    .= Following(ProgramPart s3,s3) by AMI_1:13
    .= Exec(i,s3) by A5,Th22;
  assume
  s.b < 0;
  then
A8: IC s4 = succ IC s3 by A7,A3,SCMPDS_2:69
    .= (0+1) by A1;
A9: DataPart s2 = DataPart s3 by SCMPDS_4:24,36;
  now
    let a;
    thus s2.a = s3.a by A9,SCMPDS_4:23
      .= s4.a by A7,SCMPDS_2:69;
  end;
  then
A10: DataPart s2 = DataPart s4 by SCMPDS_4:23;
  assume
A11: I is_closed_on s;
  assume
A12: I is_halting_on s;
  then I2 is_halting_on s by A11,Th44;
  then
A13: ProgramPart s2 halts_on s2 by Def3;
  I2 is_closed_on s by A11,A12,Th44;
  then
A14: II2 c= s2 & I2 is_closed_on s2 by Th38,FUNCT_4:26;
T: ProgramPart s3 = ProgramPart Comput(
ProgramPart(s3),s3,1)
by AMI_1:123;
x: Comput(ProgramPart(s3),s3,LifeSpan(ProgramPart(s2),s2)+1)
 = Comput(ProgramPart(s3),Comput(ProgramPart(s3),s3,1),LifeSpan(ProgramPart(s2)
,s2))
 by AMI_1:51;
TX4: ProgramPart s4 = ProgramPart
Comput(ProgramPart(s4),s4,LifeSpan(ProgramPart(s2),s2))
by AMI_1:123;
TX2: ProgramPart s2 = ProgramPart
Comput(ProgramPart(s2),s2,LifeSpan(ProgramPart(s2),
s2))
by AMI_1:123;
A15: CurInstr(ProgramPart s3,
Comput(ProgramPart(s3),s3,LifeSpan(ProgramPart(s2),s2)+1))
 =CurInstr(ProgramPart s4,
 Comput(ProgramPart(s4),s4,LifeSpan(ProgramPart(s2),s2))) by x,T
    .=CurInstr(ProgramPart s2,
    Comput(ProgramPart(s2),s2,LifeSpan(ProgramPart(s2),s2))) by A14,A6,A8,A10
,Th45,TX2,TX4
    .= halt SCMPDS by A13,AMI_1:def 46;
  then
A16: ProgramPart s3 halts_on s3 by AMI_1:146;
A17: CurInstr(ProgramPart s3,s3) = i by A5,Th22;
  now
    let l be Element of NAT;
    assume
A18: l < LifeSpan(ProgramPart(s2),s2) + 1;
u: Comput(ProgramPart(s3),s3,0) = s3 by AMI_1:13;
    per cases;
    suppose
      l = 0;
      then CurInstr(ProgramPart s3,Comput(ProgramPart(s3),s3,l))
       = CurInstr(ProgramPart s3,s3)
       by u;
      hence CurInstr(ProgramPart (s3),Comput(ProgramPart(s3),s3,l))
       <> halt SCMPDS by A17,Th31;
    end;
    suppose
      l <> 0;
      then consider n be Nat such that
A19:  l = n + 1 by NAT_1:6;
      reconsider n as Element of NAT by ORDINAL1:def 13;
A20:  n < LifeSpan(ProgramPart(s2),s2) by A18,A19,XREAL_1:8;
      assume
A21:  CurInstr(ProgramPart (s3),Comput(ProgramPart(s3),s3,l)) = halt SCMPDS;
T: ProgramPart s3 = ProgramPart Comput(ProgramPart(s3),s3,1)
by AMI_1:123;
x: Comput(ProgramPart(s3),s3,n+1)
 = Comput(ProgramPart(s3),Comput(ProgramPart(s3),s3,1),n) by AMI_1:51;
TX2: ProgramPart s2 = ProgramPart Comput(ProgramPart(s2),s2,n)
by AMI_1:123;
TX4: ProgramPart s4 = ProgramPart Comput(ProgramPart(s4),s4,n)
by AMI_1:123;
      CurInstr(ProgramPart s2,Comput(ProgramPart(s2),s2,n)) =
      CurInstr(ProgramPart s4,Comput(ProgramPart(s4),s4,n)) by A14,A6,A8,A10
,Th45,TX2,TX4
        .= halt SCMPDS by A19,A21,x,T;
      hence contradiction by A13,A20,AMI_1:def 46;
    end;
  end;
  then for l be Element of NAT st CurInstr(ProgramPart (s3),
  Comput(ProgramPart(s3),s3,l)) = halt SCMPDS
  holds LifeSpan(ProgramPart(s2),s2) + 1 <= l;
  then
A22: LifeSpan(ProgramPart(s3),s3) = LifeSpan(ProgramPart(s2),s2) + 1 by A15,A16
,AMI_1:def 46;
T: ProgramPart s3 = ProgramPart s4
by AMI_1:123;
A23: DataPart Result(ProgramPart(s2),s2) = DataPart Comput(ProgramPart(s2),s2,
LifeSpan(ProgramPart(s2),s2)) by A13,AMI_1:122
    .= DataPart Comput(ProgramPart( s3), s4,LifeSpan(ProgramPart(s2),s2))
    by A14,A6,A8,A10,Th45,T
    .= DataPart Comput(ProgramPart( s3), s3,LifeSpan(ProgramPart(s2),s2) + 1)
by AMI_1:51
    .= DataPart Result(ProgramPart(s3),s3) by A16,A22,AMI_1:122;
A24: now
    let x be set;
A25: IExec(I2,s) = Result(ProgramPart(s2),s2) +* s | A by SCMPDS_4:def 8;
A26: IExec(IF,s) = Result(ProgramPart(s3),s3) +* s | A by SCMPDS_4:def 8;
A27: dom SAl = {IC SCMPDS} by FUNCOP_1:19;
    assume
A28: x in dom IExec(IF,s);
    per cases by A28,SCMPDS_4:20;
    suppose
A29:  x is Int_position;
      then x <> IC SCMPDS by SCMPDS_2:52;
      then
A30:  not x in dom SAl by A27,TARSKI:def 1;
A31: not x in dom (s | A) by A4,A29,SCMPDS_2:53;
      hence IExec(IF,s).x = (Result(ProgramPart(s3),s3)).x by A26,FUNCT_4:12
        .= (Result(ProgramPart(s2),s2)).x by A23,A29,SCMPDS_4:23
        .= IExec(I2,s).x by A25,A31,FUNCT_4:12
        .= (IExec(I2,s) +* SAl).x by A30,FUNCT_4:12;
    end;
    suppose
A32:  x = IC SCMPDS;
A33: not x in dom (s | A) by A4,A32,AMI_1:48;
      then
A34:  IC Result(ProgramPart(s2),s2) = IC IExec(I2,s) by A25,A32,FUNCT_4:12
        .=  (card I + card J + 1) by A11,A12,Th46;
A35:  x in dom SAl by A27,A32,TARSKI:def 1;
T: ProgramPart s3 = ProgramPart s4
by AMI_1:123;
      thus IExec(IF,s).x = (Result(ProgramPart(s3),s3)).x by A26,A33,FUNCT_4:12
        .= Comput(ProgramPart( s3), s3,LifeSpan(ProgramPart(s2),s2) + 1).x by
A16,A22,AMI_1:122
        .= IC Comput(ProgramPart( s3), s4,LifeSpan(ProgramPart(s2),s2)) by A32,
AMI_1:51
        .= IC Comput(ProgramPart( s2), s2,LifeSpan(ProgramPart(s2),s2)) + 1 by
A14,A6,A8,A10,Th45,T
        .= IC Result(ProgramPart(s2),s2) + 1 by A13,AMI_1:122
        .= (Start-At ( (card I + card J + 1) + 1,SCMPDS)).IC SCMPDS
        by A34,FUNCOP_1:87
        .= (IExec(I2,s) +* SAl).x by A32,A35,FUNCT_4:14;
    end;
    suppose
      x is Element of NAT;
      hence IExec(IF,s).x = (IExec(I2,s) +* SAl).x by Th26;
    end;
  end;
  dom IExec(IF,s) = the carrier of SCMPDS by PARTFUN1:def 4
    .= dom (IExec(I2,s) +* SAl) by PARTFUN1:def 4;
  hence IExec(IF,s) = IExec(I2,s) +* SAl by A24,FUNCT_1:9
    .= IExec(I,s) +* Start-At( (card I + card J + 1),SCMPDS) +*
    Start-At(
   (card I + card J + 2),SCMPDS) by A11,A12,Th47
    .= IExec(I,s) +* SAl by Th14;
end;

theorem Th115:
  for s being State of SCMPDS,I being Program of SCMPDS,J being
  halt-free shiftable Program of SCMPDS,a being Int_position,k1 being Integer
  st s.DataLoc(s.a,k1) >= 0 & J is_closed_on s & J is_halting_on s holds IExec(
  if<0(a,k1,I,J),s) = IExec(J,s) +* Start-At((card I+card J+2),SCMPDS)
proof
  let s be State of SCMPDS,I be Program of SCMPDS,J be halt-free shiftable
  Program of SCMPDS,a be Int_position,k1 be Integer;
  set b=DataLoc(s.a,k1);
  set pJ=stop J, IsJ=Initialized pJ, s1 = s +* IsJ, IF=if<0(a,k1,I,J), pIF=
  stop IF, IsIF=Initialized pIF, s3 = s +* IsIF, s4 = Comput(ProgramPart( s3),
s3,1);
  set i = (a,k1)>=0_goto (card I + 2);
  set G =Goto (card J+1), iG=i ';' I ';' G;
  set SAl=Start-At((card I+card J+2),SCMPDS);
A1: IF = i ';' (I ';' G) ';' J by SCMPDS_4:50
    .= i ';' (I ';' G ';' J) by SCMPDS_4:50;
A2: Comput(ProgramPart( s3), s3,0 + 1) = Following(ProgramPart s3,
Comput(ProgramPart(s3),s3,0)) by AMI_1:14
    .= Following(ProgramPart s3,s3) by AMI_1:13
    .= Exec(i,s3) by A1,Th22;
A3: not b in dom IsIF by SCMPDS_4:31;
  not a in dom IsIF by SCMPDS_4:31;
  then
A4: s3.DataLoc(s3.a,k1)=s3.b by FUNCT_4:12
    .= s.b by A3,FUNCT_4:12;
A5: IC s3 = 0 by FUNCT_4:26,SCMPDS_5:18;
A6: dom ProgramPart s = A by AMI_1:143;
  assume
  s.b >= 0;
  then
A7: IC s4 = ICplusConst(s3,card I + 2) by A2,A4,SCMPDS_2:69
    .= (0+(card I + 2)) by A5,Th23;
A8: DataPart s1 = DataPart s3 by SCMPDS_4:24,36;
  now
    let a;
    thus s1.a = s3.a by A8,SCMPDS_4:23
      .= s4.a by A2,SCMPDS_2:69;
  end;
  then
A9: DataPart s1 = DataPart s4 by SCMPDS_4:23;
  card iG = card (i ';' I) + card G by SCMPDS_4:45
    .=card (i ';' I) + 1 by SCMPDS_5:6
    .=card I +1 +1 by Th15
    .=card I +(1 +1);
  then
A10: Shift(pJ,card I+2) c= pIF by Th24;
  pIF c= s3 by FUNCT_4:26,SCMPDS_4:57;
  then Shift(pJ,card I+2) c= s3 by A10,XBOOLE_1:1;
  then
A11: Shift(pJ,card I+2) c= s4 by AMI_1:81;
  assume
A12: J is_closed_on s;
  then
A13: IsJ c= s1 & J is_closed_on s1 by Th38,FUNCT_4:26;
  assume
A14: J is_halting_on s;
  then
A15: ProgramPart s1 halts_on s1 by Def3;
T: ProgramPart s3 = ProgramPart Comput(
ProgramPart(s3),s3,1)
by AMI_1:123;
x: Comput(ProgramPart(s3),s3,LifeSpan(ProgramPart(s1),s1)+1)
 = Comput(ProgramPart(s3),Comput(ProgramPart(s3),s3,1),LifeSpan(ProgramPart(s1)
,s1))
by AMI_1:51;
TX4: ProgramPart s4 = ProgramPart
Comput(ProgramPart(s4),s4,LifeSpan(ProgramPart(s1),s1))
by AMI_1:123;
TX1: ProgramPart s1 = ProgramPart
Comput(ProgramPart(s1),s1,LifeSpan(ProgramPart(s1),
s1))
by AMI_1:123;
A16: CurInstr(ProgramPart s3,
Comput(ProgramPart(s3),s3,LifeSpan(ProgramPart(s1),s1)+1))
 =CurInstr(ProgramPart s4,
 Comput(ProgramPart(s4),s4,LifeSpan(ProgramPart(s1),s1))) by x,T
    .=CurInstr(ProgramPart s1,
    Comput(ProgramPart(s1),s1,LifeSpan(ProgramPart(s1),s1))) by A13,A11,A7,A9
,Th45,TX1,TX4
    .= halt SCMPDS by A15,AMI_1:def 46;
  then
A17: ProgramPart s3 halts_on s3 by AMI_1:146;
A18: CurInstr(ProgramPart s3,s3) = i by A1,Th22;
  now
    let l be Element of NAT;
    assume
A19: l < LifeSpan(ProgramPart(s1),s1) + 1;
u: Comput(ProgramPart(s3),s3,0) = s3 by AMI_1:13;
    per cases;
    suppose
      l = 0;
      then CurInstr(ProgramPart s3,Comput(ProgramPart(s3),s3,l))
       = CurInstr(ProgramPart s3,s3)
       by u;
      hence CurInstr(ProgramPart (s3),Comput(ProgramPart(s3),s3,l))
       <> halt SCMPDS by A18,Th31;
    end;
    suppose
      l <> 0;
      then consider n be Nat such that
A20:  l = n + 1 by NAT_1:6;
      reconsider n as Element of NAT by ORDINAL1:def 13;
A21:  n < LifeSpan(ProgramPart(s1),s1) by A19,A20,XREAL_1:8;
      assume
A22:  CurInstr(ProgramPart (s3),Comput(ProgramPart(s3),s3,l)) = halt SCMPDS;
T: ProgramPart s3 = ProgramPart Comput(ProgramPart(s3),
s3,1)
by AMI_1:123;
x: Comput(ProgramPart(s3),s3,n+1)
 = Comput(ProgramPart(s3),Comput(ProgramPart(s3),s3,1),n) by AMI_1:51;
TX1: ProgramPart s1 = ProgramPart Comput(ProgramPart(s1),s1,n)
by AMI_1:123;
TX4: ProgramPart s4 = ProgramPart Comput(ProgramPart(s4),s4,n)
by AMI_1:123;
      CurInstr(ProgramPart s1,Comput(ProgramPart(s1),
s1,n))
       = CurInstr(ProgramPart s4,
      Comput(ProgramPart(s4),s4,n)) by A13,A11,A7,A9,Th45,TX1,TX4
        .= halt SCMPDS by A20,A22,x,T;
      hence contradiction by A15,A21,AMI_1:def 46;
    end;
  end;
  then for l be Element of NAT st CurInstr(ProgramPart (s3),
  Comput(ProgramPart(s3),s3,l)) = halt SCMPDS
  holds LifeSpan(ProgramPart(s1),s1) + 1 <= l;
  then
A23: LifeSpan(ProgramPart(s3),s3) = LifeSpan(ProgramPart(s1),s1) + 1 by A16,A17
,AMI_1:def 46;
T: ProgramPart s3 = ProgramPart s4
by AMI_1:123;
A24: DataPart Result(ProgramPart(s1),s1) = DataPart Comput(ProgramPart( s1), s1
,LifeSpan(ProgramPart(s1),s1)) by A15,AMI_1:122
    .= DataPart Comput(ProgramPart( s3), s4,LifeSpan(ProgramPart(s1),s1))
    by A13,A11,A7,A9,Th45,T
    .= DataPart Comput(ProgramPart( s3), s3,LifeSpan(ProgramPart(s1),s1) + 1)
by AMI_1:51
    .= DataPart Result(ProgramPart(s3),s3) by A17,A23,AMI_1:122;
A25: now
    let x be set;
A26: IExec(J,s) = Result(ProgramPart(s1),s1) +* s | A by SCMPDS_4:def 8;
A27: IExec(IF,s) = Result(ProgramPart(s3),s3) +* s | A by SCMPDS_4:def 8;
A28: dom SAl = {IC SCMPDS} by FUNCOP_1:19;
    assume
A29: x in dom IExec(IF,s);
    per cases by A29,SCMPDS_4:20;
    suppose
A30:  x is Int_position;
      then x <> IC SCMPDS by SCMPDS_2:52;
      then
A31:  not x in dom SAl by A28,TARSKI:def 1;
A32: not x in dom (s | A) by A6,A30,SCMPDS_2:53;
      hence IExec(IF,s).x = (Result(ProgramPart(s3),s3)).x by A27,FUNCT_4:12
        .= (Result(ProgramPart(s1),s1)).x by A24,A30,SCMPDS_4:23
        .= IExec(J,s).x by A26,A32,FUNCT_4:12
        .= (IExec(J,s) +* SAl).x by A31,FUNCT_4:12;
    end;
    suppose
A33:  x = IC SCMPDS;
A34: not x in dom (s | A) by A6,A33,AMI_1:48;
      then
A35:  IC Result(ProgramPart(s1),s1) = IC IExec(J,s) by A26,A33,FUNCT_4:12
        .=  (card J) by A12,A14,Th48;
A36:  x in dom SAl by A28,A33,TARSKI:def 1;
T: ProgramPart s3 = ProgramPart s4
by AMI_1:123;
      thus IExec(IF,s).x = (Result(ProgramPart(s3),s3)).x by A27,A34,FUNCT_4:12
        .= Comput(ProgramPart( s3), s3,LifeSpan(ProgramPart(s1),s1) + 1).x by
A17,A23,AMI_1:122
        .= IC Comput(ProgramPart( s3), s4,LifeSpan(ProgramPart(s1),s1)) by A33,
AMI_1:51
        .= IC Comput(ProgramPart( s1), s1,LifeSpan(ProgramPart(s1),s1)) + (card
I + 2) by A13,A11,A7,A9,Th45,T
        .= IC Result(ProgramPart(s1),s1) + (card I + 2) by A15,AMI_1:122
        .= (Start-At ( card J + (card I + 2),SCMPDS)).IC SCMPDS by A35,
FUNCOP_1:87
        .= (IExec(J,s) +* SAl).x by A33,A36,FUNCT_4:14;
    end;
    suppose
      x is Element of NAT;
      hence IExec(IF,s).x = (IExec(J,s) +* SAl).x by Th26;
    end;
  end;
  dom IExec(IF,s) = the carrier of SCMPDS by PARTFUN1:def 4
    .= dom (IExec(J,s) +* SAl) by PARTFUN1:def 4;
  hence thesis by A25,FUNCT_1:9;
end;

registration
  let I,J be shiftable parahalting Program of SCMPDS, a be Int_position,k1 be
  Integer;
  cluster if<0(a,k1,I,J) -> shiftable parahalting;
  correctness
  proof
    set i = (a,k1)>=0_goto (card I + 2), G =Goto (card J+1);
    set IF=if<0(a,k1,I,J), IsIF=Initialized stop IF;
    reconsider IJ=I ';' G ';' J as shiftable Program of SCMPDS;
    IF =i ';' (I ';' G) ';' J by SCMPDS_4:50
      .=i ';' IJ by SCMPDS_4:50
      .=Load i ';' IJ by SCMPDS_4:def 4;
    hence IF is shiftable;
    now
      let s be State of SCMPDS;
      assume
      IsIF c= s;
      then
A1:   s = s +* IsIF by FUNCT_4:79;
A2:   J is_closed_on s & J is_halting_on s by Th34,Th35;
A3:   I is_closed_on s & I is_halting_on s by Th34,Th35;
      per cases;
      suppose
        s.DataLoc(s.a,k1) < 0;
        then IF is_halting_on s by A3,Th112;
        hence ProgramPart s halts_on s by A1,Def3;
      end;
      suppose
        s.DataLoc(s.a,k1) >= 0;
        then IF is_halting_on s by A2,Th113;
        hence ProgramPart s halts_on s by A1,Def3;
      end;
    end;
    then IsIF is halting by AMI_1:def 26;
    hence thesis by SCMPDS_4:def 10;
  end;
end;

registration
  let I,J be halt-free Program of SCMPDS, a be Int_position,k1 be Integer;
  cluster if<0(a,k1,I,J) -> halt-free;
  coherence;
end;

theorem
  for s being State of SCMPDS,I,J being halt-free shiftable
  parahalting Program of SCMPDS,a being Int_position,k1 being Integer holds IC
  IExec(if<0(a,k1,I,J),s) =  (card I + card J + 2)
proof
  let s be State of SCMPDS,I,J be halt-free shiftable parahalting Program of
  SCMPDS,a be Int_position,k1 be Integer;
  set IF=if<0(a,k1,I,J);
A1: I is_closed_on s & I is_halting_on s by Th34,Th35;
A2: J is_closed_on s & J is_halting_on s by Th34,Th35;
  per cases;
  suppose
    s.DataLoc(s.a,k1) < 0;
    then IExec(IF,s) = IExec(I,s) +* Start-At((card I+card J+2),SCMPDS)
    by A1,Th114;
    hence thesis by FUNCT_4:121;
  end;
  suppose
    s.DataLoc(s.a,k1) >= 0;
    then IExec(IF,s) = IExec(J,s) +* Start-At((card I+card J+2),SCMPDS)
    by A2,Th115;
    hence thesis by FUNCT_4:121;
  end;
end;

theorem
  for s being State of SCMPDS,I being halt-free shiftable parahalting
  Program of SCMPDS,J being shiftable Program of SCMPDS,a,b being Int_position,
k1 being Integer st s.DataLoc(s.a,k1)<0 holds IExec(if<0(a,k1,I,J),s).b = IExec
  (I,s).b
proof
  let s be State of SCMPDS,I be halt-free shiftable parahalting Program of
  SCMPDS,J be shiftable Program of SCMPDS,a,b be Int_position, k1 be Integer;
  assume
A1: s.DataLoc(s.a,k1)<0;
A2: not b in dom Start-At((card I+card J+2),SCMPDS) by SCMPDS_4:59;
  I is_closed_on s & I is_halting_on s by Th34,Th35;
  then
  IExec(if<0(a,k1,I,J),s) = IExec(I,s) +* Start-At( (card I + card J
  + 2),SCMPDS) by A1,Th114;
  hence thesis by A2,FUNCT_4:12;
end;

theorem
  for s being State of SCMPDS,I being Program of SCMPDS,J being
  halt-free parahalting shiftable Program of SCMPDS,a,b being Int_position,k1
being Integer st s.DataLoc(s.a,k1) >= 0 holds IExec(if<0(a,k1,I,J),s).b = IExec
  (J,s).b
proof
  let s be State of SCMPDS,I be Program of SCMPDS,J be halt-free parahalting
  shiftable Program of SCMPDS,a,b be Int_position, k1 be Integer;
  set IF=if<0(a,k1,I,J);
  assume
A1: s.DataLoc(s.a,k1) >= 0;
A2: not b in dom Start-At((card I+card J+2),SCMPDS) by SCMPDS_4:59;
  J is_closed_on s & J is_halting_on s by Th34,Th35;
  then IExec(IF,s) =IExec(J,s) +* Start-At((card I+card J+2),SCMPDS)
  by A1,Th115;
  hence thesis by A2,FUNCT_4:12;
end;

begin :: The computation of "if var<0 then block"

theorem
  card if<0(a,k1,I) = card I + 1 by Th15;

theorem
   0 in dom if<0(a,k1,I)
proof
  set ci=card if<0(a,k1,I);
  ci=card I + 1 by Th15;
  hence thesis by AFINSQ_1:70;
end;

theorem
  if<0(a,k1,I). 0 = (a,k1)>=0_goto (card I + 1) by Th16;

theorem Th122:
  for s being State of SCMPDS, I being shiftable Program of
  SCMPDS, a being Int_position,k1 being Integer st s.DataLoc(s.a,k1) < 0 & I
is_closed_on s & I is_halting_on s holds if<0(a,k1,I) is_closed_on s & if<0(a,
  k1,I) is_halting_on s
proof
  let s be State of SCMPDS, I be shiftable Program of SCMPDS, a be
  Int_position,k1 be Integer;
  set b=DataLoc(s.a,k1);
  set IF=if<0(a,k1,I), pIF=stop IF, IsIF=Initialized pIF, pI=stop I, IsI=
  Initialized pI, s2 = s +* IsI, s3 = s +* IsIF, s4 = Comput(ProgramPart(s3),s3
,1);
  set i = (a,k1)>=0_goto (card I + 1);
A1:  0 in dom pIF by SCMPDS_4:75;
A2: IC s3 = 0 by FUNCT_4:26,SCMPDS_5:18;
A3: not b in dom IsIF by SCMPDS_4:31;
  not a in dom IsIF by SCMPDS_4:31;
  then
A4: s3.DataLoc(s3.a,k1)=s3.b by FUNCT_4:12
    .= s.b by A3,FUNCT_4:12;
A5: Comput(ProgramPart( s3), s3,0 + 1) = Following(ProgramPart s3,
Comput(ProgramPart(s3),s3,0)) by AMI_1:14
    .= Following(ProgramPart s3,s3) by AMI_1:13
    .= Exec(i,s3) by Th22;
A6: DataPart s2 = DataPart s3 by SCMPDS_4:24,36;
  now
    let a;
    thus s2.a = s3.a by A6,SCMPDS_4:23
      .= s4.a by A5,SCMPDS_2:69;
  end;
  then
A7: DataPart s2 = DataPart s4 by SCMPDS_4:23;
  assume
  s.b < 0;
  then
A8: IC s4 = succ IC s3 by A5,A4,SCMPDS_2:69
    .= (0+1) by A2;
  assume
A9: I is_closed_on s;
  then
A10: I is_closed_on s2 by Th38;
  assume
  I is_halting_on s;
  then
A11: ProgramPart s2 halts_on s2 by Def3;
A12: IsI c= s2 & Shift(pI,1) c= s4 by Lm5,FUNCT_4:26;
A13: card pIF = card IF +1 by SCMPDS_5:7
    .= card I +1+1 by Th15;
  now
    let k be Element of NAT;
    per cases;
    suppose
      0 < k;
      then consider k1 being Nat such that
A14:  k1 + 1 = k by NAT_1:6;
      reconsider k1 as Element of NAT by ORDINAL1:def 13;
      reconsider m = IC Comput(ProgramPart( s2), s2,k1) as Element of NAT;
A15:  card pIF = card pI+1 by A13,SCMPDS_5:7;
       m in dom pI by A9,Def2;
      then m < card pI by AFINSQ_1:70;
      then
A16:  m+1 < card pIF by A15,XREAL_1:8;
T: ProgramPart s3 = ProgramPart s4
by AMI_1:123;
      IC Comput(ProgramPart(s3),s3,k) = IC Comput(ProgramPart( s3), s4,k1) by
A14,AMI_1:51
        .=  (m + 1) by A10,A12,A8,A7,Th45,T;
      hence IC Comput(ProgramPart(s3),s3,k) in dom pIF by A16,AFINSQ_1:70;
    end;
    suppose
      k = 0;
      hence IC Comput(ProgramPart(s3),s3,k) in dom pIF by A1,A2,AMI_1:13;
    end;
  end;
  hence IF is_closed_on s by Def2;
T: ProgramPart s3 = ProgramPart Comput(
ProgramPart(s3),s3,1)
by AMI_1:123;
x: Comput(ProgramPart(s3),s3,LifeSpan(ProgramPart(s2),s2)+1)
 = Comput(ProgramPart(s3),Comput(ProgramPart(s3),s3,1),LifeSpan(ProgramPart(s2)
,s2))
by AMI_1:51;
TX4: ProgramPart s4 = ProgramPart
Comput(ProgramPart(s4),s4,LifeSpan(ProgramPart(s2),s2)
)
by AMI_1:123;
TX2: ProgramPart s2 = ProgramPart
Comput(ProgramPart(s2),s2,LifeSpan(ProgramPart(s2),
s2))
by AMI_1:123;
  CurInstr(ProgramPart s3,
  Comput(ProgramPart(s3),s3,LifeSpan(ProgramPart(s2),s2)+1))
   =CurInstr(ProgramPart s4,
   Comput(ProgramPart(s4),s4,LifeSpan(ProgramPart(s2),s2))) by x,T
    .=CurInstr(ProgramPart s2,
    Comput(ProgramPart(s2),s2,LifeSpan(ProgramPart(s2),s2))) by A10,A12,A8,A7
,Th45,TX2,TX4
    .= halt SCMPDS by A11,AMI_1:def 46;
  then ProgramPart s3 halts_on s3 by AMI_1:146;
  hence thesis by Def3;
end;

theorem Th123:
  for s being State of SCMPDS,I being Program of SCMPDS, a being
  Int_position, k1 being Integer st s.DataLoc(s.a,k1) >= 0 holds if<0(a,k1,I)
  is_closed_on s & if<0(a,k1,I) is_halting_on s
proof
  let s be State of SCMPDS,I be Program of SCMPDS, a be Int_position,k1 be
  Integer;
  set b=DataLoc(s.a,k1);
  assume
A1: s.b >= 0;
  set i = (a,k1)>=0_goto (card I + 1);
  set IF=if<0(a,k1,I), pIF=stop IF, IsIF=Initialized pIF, s3 = s +* IsIF, s4 =
  Comput(ProgramPart(s3),s3,1);
A2: IC s3 = 0 by FUNCT_4:26,SCMPDS_5:18;
A3: not b in dom IsIF by SCMPDS_4:31;
  not a in dom IsIF by SCMPDS_4:31;
  then
A4: s3.DataLoc(s3.a,k1)=s3.b by FUNCT_4:12
    .= s.b by A3,FUNCT_4:12;
  Comput(ProgramPart( s3), s3,0 + 1) = Following(ProgramPart s3,
  Comput(ProgramPart(s3),s3,0)) by AMI_1:14
    .= Following(ProgramPart s3,s3) by AMI_1:13
    .= Exec(i,s3) by Th22;
  then
A5: IC s4 = ICplusConst(s3,card I + 1) by A1,A4,SCMPDS_2:69
    .= (0+(card I + 1)) by A2,Th23;
A6: card IF=card I+1 by Th15;
  then
A7: (card I+1) in dom pIF by Th25;
Y:  (ProgramPart s4)/.IC s4
 = s4.IC s4 by AMI_1:150;
TX: ProgramPart s3 = ProgramPart s4
by AMI_1:123;
  IsIF c= s3 by FUNCT_4:26;
  then pIF c= s4 by AMI_1:81,SCMPDS_4:57;
  then s4.(card I+1) = pIF.(card I+1) by A7,GRFUNC_1:8
    .=halt SCMPDS by A6,Th25;
  then
A8: CurInstr(ProgramPart s3,s4) = halt SCMPDS by A5,Y,TX;
  now
    let k be Element of NAT;
    per cases;
    suppose
      0 < k;
      then 1+0 <= k by INT_1:20;
      hence IC Comput(ProgramPart(s3),s3,k) in dom pIF by A7,A5,A8,AMI_1:52;
    end;
    suppose
      k = 0;
      then Comput(ProgramPart(s3),s3,k) = s3 by AMI_1:13;
      hence IC Comput(ProgramPart(s3),s3,k) in dom pIF by A2,SCMPDS_4:75;
    end;
  end;
  hence IF is_closed_on s by Def2;
  ProgramPart s3 halts_on s3 by A8,AMI_1:146;
  hence thesis by Def3;
end;

theorem Th124:
  for s being State of SCMPDS,I being halt-free shiftable
Program of SCMPDS, a being Int_position,k1 being Integer st s.DataLoc(s.a,k1) <
0 & I is_closed_on s & I is_halting_on s holds IExec(if<0(a,k1,I),s) = IExec(I,
  s) +* Start-At((card I+1),SCMPDS)
proof
  let s be State of SCMPDS,I be halt-free shiftable Program of SCMPDS, a be
  Int_position,k1 be Integer;
  set b=DataLoc(s.a,k1);
  set IF=if<0(a,k1,I), IsIF=Initialized stop IF, pI=stop I, IsI= Initialized
  pI, s2 = s +* IsI, s3 = s +* IsIF, s4 = Comput(ProgramPart( s3), s3,1);
  set i = (a,k1)>=0_goto (card I + 1);
  set SAl=Start-At((card I+1),SCMPDS);
A1: IC s3 = 0 by FUNCT_4:26,SCMPDS_5:18;
A2: not b in dom IsIF by SCMPDS_4:31;
  not a in dom IsIF by SCMPDS_4:31;
  then
A3: s3.DataLoc(s3.a,k1)=s3.b by FUNCT_4:12
    .= s.b by A2,FUNCT_4:12;
A4: Comput(ProgramPart( s3), s3,0 + 1) = Following(ProgramPart s3,
Comput(ProgramPart(s3),s3,0)) by AMI_1:14
    .= Following(ProgramPart s3,s3) by AMI_1:13
    .= Exec(i,s3) by Th22;
  assume
  s.b < 0;
  then
A5: IC s4 = succ IC s3 by A4,A3,SCMPDS_2:69
    .= (0+1) by A1;
A6: DataPart s2 = DataPart s3 by SCMPDS_4:24,36;
  now
    let a;
    thus s2.a = s3.a by A6,SCMPDS_4:23
      .= s4.a by A4,SCMPDS_2:69;
  end;
  then
A7: DataPart s2 = DataPart s4 by SCMPDS_4:23;
  assume
A8: I is_closed_on s;
  then
A9: I is_closed_on s2 by Th38;
A10: dom ProgramPart s = A by AMI_1:143;
A11: IsI c= s2 & Shift(pI,1) c= s4 by Lm5,FUNCT_4:26;
  assume
A12: I is_halting_on s;
  then
A13: ProgramPart s2 halts_on s2 by Def3;
T: ProgramPart s3 = ProgramPart Comput(
ProgramPart(s3),s3,1)
by AMI_1:123;
x: Comput(ProgramPart(s3),s3,LifeSpan(ProgramPart(s2),s2)+1)
= Comput(ProgramPart(s3),Comput(ProgramPart(s3),s3,1),LifeSpan(ProgramPart(s2),
s2))
 by AMI_1:51;
TX4: ProgramPart s4 = ProgramPart
Comput(ProgramPart(s4),s4,LifeSpan(ProgramPart(s2),s2))
by AMI_1:123;
TX2: ProgramPart s2 = ProgramPart
Comput(ProgramPart(s2),s2,LifeSpan(ProgramPart(s2),
s2))
by AMI_1:123;
A14: CurInstr(ProgramPart s3,
Comput(ProgramPart(s3),s3,LifeSpan(ProgramPart(s2),s2)+1))
 =CurInstr(ProgramPart s4,
 Comput(ProgramPart(s4),s4,LifeSpan(ProgramPart(s2),s2))) by x,T
    .=CurInstr(ProgramPart s2,
    Comput(ProgramPart(s2),s2,LifeSpan(ProgramPart(s2),s2))) by A9,A11,A5,A7
,Th45,TX2,TX4
    .= halt SCMPDS by A13,AMI_1:def 46;
  then
A15: ProgramPart s3 halts_on s3 by AMI_1:146;
A16: CurInstr(ProgramPart s3,s3) = i by Th22;
  now
    let l be Element of NAT;
    assume
A17: l < LifeSpan(ProgramPart(s2),s2) + 1;
u: Comput(ProgramPart(s3),s3,0) = s3 by AMI_1:13;
    per cases;
    suppose
      l = 0;
      then CurInstr(ProgramPart s3,Comput(ProgramPart(s3),s3,l))
       = CurInstr(ProgramPart s3,s3)
       by u;
      hence CurInstr(ProgramPart (s3),Comput(ProgramPart(s3),s3,l))
       <> halt SCMPDS by A16,Th31;
    end;
    suppose
      l <> 0;
      then consider n be Nat such that
A18:  l = n + 1 by NAT_1:6;
      reconsider n as Element of NAT by ORDINAL1:def 13;
A19:  n < LifeSpan(ProgramPart(s2),s2) by A17,A18,XREAL_1:8;
      assume
A20:  CurInstr(ProgramPart (s3),Comput(ProgramPart(s3),s3,l)) = halt SCMPDS;
T: ProgramPart s3 = ProgramPart Comput(ProgramPart(s3),
s3,1)
by AMI_1:123;
x: Comput(ProgramPart(s3),s3,n+1)
 = Comput(ProgramPart(s3),Comput(ProgramPart(s3),s3,1),n) by AMI_1:51;
TX2: ProgramPart s2 = ProgramPart Comput(ProgramPart(s2),s2,n)
by AMI_1:123;
TX4: ProgramPart s4 = ProgramPart Comput(ProgramPart(s4),s4,n)
by AMI_1:123;
      CurInstr(ProgramPart s2,Comput(ProgramPart(s2),s2,n)) =
      CurInstr(ProgramPart s4,Comput(ProgramPart(s4),s4,n)) by A9,A11,A5,A7
,Th45,TX2,TX4
        .= halt SCMPDS by A18,A20,x,T;
      hence contradiction by A13,A19,AMI_1:def 46;
    end;
  end;
  then for l be Element of NAT st CurInstr(ProgramPart (s3),
  Comput(ProgramPart(s3),s3,l)) = halt SCMPDS
  holds LifeSpan(ProgramPart(s2),s2) + 1 <= l;
  then
A21: LifeSpan(ProgramPart(s3),s3) = LifeSpan(ProgramPart(s2),s2) + 1 by A14,A15
,AMI_1:def 46;
T: ProgramPart s3 = ProgramPart s4
by AMI_1:123;
A22: DataPart Result(ProgramPart(s2),s2) = DataPart Comput(ProgramPart(s2),s2,
LifeSpan(ProgramPart(s2),s2)) by A13,AMI_1:122
    .= DataPart Comput(ProgramPart( s3), s4,LifeSpan(ProgramPart(s2),s2)) by A9
,A11,A5,A7,Th45,T
    .= DataPart Comput(ProgramPart( s3), s3,LifeSpan(ProgramPart(s2),s2) + 1)
by AMI_1:51
    .= DataPart Result(ProgramPart(s3),s3) by A15,A21,AMI_1:122;
A23: now
    let x be set;
A24: IExec(I,s) = Result(ProgramPart(s2),s2) +* s | A by SCMPDS_4:def 8;
A25: IExec(IF,s) = Result(ProgramPart(s3),s3) +* s | A by SCMPDS_4:def 8;
A26: dom SAl = {IC SCMPDS} by FUNCOP_1:19;
    assume
A27: x in dom IExec(IF,s);
    per cases by A27,SCMPDS_4:20;
    suppose
A28:  x is Int_position;
      then x <> IC SCMPDS by SCMPDS_2:52;
      then
A29:  not x in dom SAl by A26,TARSKI:def 1;
A30: not x in dom (s | A) by A10,A28,SCMPDS_2:53;
      hence IExec(IF,s).x = (Result(ProgramPart(s3),s3)).x by A25,FUNCT_4:12
        .= (Result(ProgramPart(s2),s2)).x by A22,A28,SCMPDS_4:23
        .= IExec(I,s).x by A24,A30,FUNCT_4:12
        .= (IExec(I,s) +* SAl).x by A29,FUNCT_4:12;
    end;
    suppose
A31:  x = IC SCMPDS;
A32: not x in dom (s | A) by A10,A31,AMI_1:48;
      then
A33:  IC Result(ProgramPart(s2),s2) = IC IExec(I,s) by A24,A31,FUNCT_4:12
        .=  card I by A8,A12,Th48;
A34:  x in dom SAl by A26,A31,TARSKI:def 1;
T: ProgramPart s3 = ProgramPart s4
by AMI_1:123;
      thus IExec(IF,s).x = (Result(ProgramPart(s3),s3)).x by A25,A32,FUNCT_4:12
        .= Comput(ProgramPart( s3), s3,LifeSpan(ProgramPart(s2),s2) + 1).x by
A15,A21,AMI_1:122
        .= IC Comput(ProgramPart( s3), s4,LifeSpan(ProgramPart(s2),s2)) by A31,
AMI_1:51
        .= IC Comput(ProgramPart( s2), s2,LifeSpan(ProgramPart(s2),s2)) + 1
        by A9,A11,A5,A7,Th45,T
        .= IC Result(ProgramPart(s2),s2) + 1 by A13,AMI_1:122
        .= SAl.IC SCMPDS by A33,FUNCOP_1:87
        .= (IExec(I,s) +* SAl).x by A31,A34,FUNCT_4:14;
    end;
    suppose
      x is Element of NAT;
      hence IExec(IF,s).x = (IExec(I,s) +* SAl).x by Th26;
    end;
  end;
  dom IExec(IF,s) = the carrier of SCMPDS by PARTFUN1:def 4
    .= dom (IExec(I,s) +* SAl) by PARTFUN1:def 4;
  hence thesis by A23,FUNCT_1:9;
end;

theorem Th125:
  for s being State of SCMPDS,I being Program of SCMPDS,a being
Int_position, k1 being Integer st s.DataLoc(s.a,k1) >= 0 holds IExec(if<0(a,k1,
  I),s) = s +* Start-At((card I+1),SCMPDS)
proof
  let s be State of SCMPDS,I be Program of SCMPDS,a be Int_position, k1 be
  Integer;
  set b=DataLoc(s.a,k1);
  set IF=if<0(a,k1,I), pIF=stop IF, IsIF=Initialized pIF, s3 = s +* IsIF, s4 =
  Comput(ProgramPart( s3), s3,1);
  set i = (a,k1)>=0_goto (card I + 1);
  set SAl=Start-At((card I+1),SCMPDS);
A1: IC s3 = 0 by FUNCT_4:26,SCMPDS_5:18;
A2: not b in dom IsIF by SCMPDS_4:31;
  not a in dom IsIF by SCMPDS_4:31;
  then
A3: s3.DataLoc(s3.a,k1)=s3.b by FUNCT_4:12
    .= s.b by A2,FUNCT_4:12;
A4: Comput(ProgramPart( s3), s3,0 + 1) = Following(ProgramPart s3,
Comput(ProgramPart(s3),s3,0)) by AMI_1:14
    .= Following(ProgramPart s3,s3) by AMI_1:13
    .= Exec(i,s3) by Th22;
  assume
  s.b >= 0;
  then
A5: IC s4 = ICplusConst(s3,card I + 1) by A4,A3,SCMPDS_2:69
    .= (0+(card I + 1)) by A1,Th23;
  IsIF c= s3 by FUNCT_4:26;
  then
A6: pIF c= s4 by AMI_1:81,SCMPDS_4:57;
Y:  (ProgramPart s4)/.IC s4
 = s4.IC s4 by AMI_1:150;
TX: ProgramPart s3 = ProgramPart s4
by AMI_1:123;
A7: card IF=card I+1 by Th15;
  then (card I+1) in dom pIF by Th25;
  then s4.(card I+1) = pIF.(card I+1) by A6,GRFUNC_1:8
    .=halt SCMPDS by A7,Th25;
  then
A8: CurInstr(ProgramPart s3,s4) = halt SCMPDS by A5,Y,TX;
  then
A9: ProgramPart s3 halts_on s3 by AMI_1:146;
A10: CurInstr(ProgramPart s3,s3) = i by Th22;
  now
    let l be Element of NAT;
u: Comput(ProgramPart(s3),s3,0) = s3 by AMI_1:13;
    assume
    l < 1;
    then l <1+0;
    then l=0 by NAT_1:13;
    then CurInstr(ProgramPart s3,Comput(ProgramPart(s3),s3,l))
     = CurInstr(ProgramPart s3,s3) by u;
    hence CurInstr(ProgramPart (s3),Comput(ProgramPart(
s3),s3,l))
     <> halt SCMPDS by A10,Th31;
  end;
  then for l be Element of NAT st CurInstr(ProgramPart (s3),
  Comput(ProgramPart(s3),s3,l)) = halt SCMPDS
  holds 1 <= l;
  then LifeSpan(ProgramPart(s3),s3) = 1 by A8,A9,AMI_1:def 46;
  then
A11: s4 = Result(ProgramPart(s3),s3) by A9,AMI_1:122;
A12: dom ProgramPart s = A by AMI_1:143;
A13: now
A14: dom SAl = {IC SCMPDS} by FUNCOP_1:19;
    let x be set;
A15: IExec(IF,s) = Result(ProgramPart(s3),s3) +* s | A by SCMPDS_4:def 8;
    assume
A16: x in dom IExec(IF,s);
    per cases by A16,SCMPDS_4:20;
    suppose
A17:  x is Int_position;
      then x <> IC SCMPDS by SCMPDS_2:52;
      then
A18:  not x in dom SAl by A14,TARSKI:def 1;
      not x in dom (s | A) by A12,A17,SCMPDS_2:53;
      hence IExec(IF,s).x = s4.x by A11,A15,FUNCT_4:12
        .= s3.x by A4,A17,SCMPDS_2:69
        .= s.x by A17,SCMPDS_5:19
        .= (s +* SAl).x by A18,FUNCT_4:12;
    end;
    suppose
A19:  x = IC SCMPDS;
      not x in dom (s | A) by A12,A19,AMI_1:48;
      hence IExec(IF,s).x = (card I + 1) by A5,A11,A15,A19,FUNCT_4:12
        .= (s +* SAl).x by A19,FUNCT_4:121;
    end;
    suppose
      x is Element of NAT;
      hence IExec(IF,s).x = (s +* SAl).x by Th27;
    end;
  end;
  dom IExec(IF,s) = the carrier of SCMPDS by PARTFUN1:def 4
    .= dom (s +* SAl) by PARTFUN1:def 4;
  hence thesis by A13,FUNCT_1:9;
end;

registration
  let I be shiftable parahalting Program of SCMPDS, a be Int_position,k1 be
  Integer;
  cluster if<0(a,k1,I) -> shiftable parahalting;
  correctness
  proof
    set i = (a,k1)>=0_goto (card I +1);
    set IF=if<0(a,k1,I), IsIF=Initialized stop IF;
    IF =Load i ';' I by SCMPDS_4:def 4;
    hence IF is shiftable;
    now
      let s be State of SCMPDS;
      assume
      IsIF c= s;
      then
A1:   s = s +* IsIF by FUNCT_4:79;
A2:   I is_closed_on s & I is_halting_on s by Th34,Th35;
      per cases;
      suppose
        s.DataLoc(s.a,k1) < 0;
        then IF is_halting_on s by A2,Th122;
        hence ProgramPart s halts_on s by A1,Def3;
      end;
      suppose
        s.DataLoc(s.a,k1) >= 0;
        then IF is_halting_on s by Th123;
        hence ProgramPart s halts_on s by A1,Def3;
      end;
    end;
    then IsIF is halting by AMI_1:def 26;
    hence thesis by SCMPDS_4:def 10;
  end;
end;

registration
  let I be halt-free Program of SCMPDS, a be Int_position,k1 be Integer;
  cluster if<0(a,k1,I) -> halt-free;
  coherence;
end;

theorem
  for s being State of SCMPDS,I being halt-free shiftable parahalting
Program of SCMPDS,a being Int_position,k1 being Integer holds IC IExec(if<0(a,
  k1,I),s) =  (card I + 1)
proof
  let s be State of SCMPDS,I be halt-free shiftable parahalting Program of
  SCMPDS,a be Int_position,k1 be Integer;
  set IF=if<0(a,k1,I);
A1: I is_closed_on s & I is_halting_on s by Th34,Th35;
  per cases;
  suppose
    s.DataLoc(s.a,k1) < 0;
    then IExec(IF,s) =IExec(I,s) +* Start-At((card I+1),SCMPDS)
    by A1,Th124;
    hence thesis by FUNCT_4:121;
  end;
  suppose
    s.DataLoc(s.a,k1) >= 0;
    then IExec(IF,s) =s +* Start-At((card I+1),SCMPDS) by Th125;
    hence thesis by FUNCT_4:121;
  end;
end;

theorem
  for s being State of SCMPDS,I being halt-free shiftable parahalting
Program of SCMPDS,a,b being Int_position,k1 being Integer st s.DataLoc(s.a,k1)
  < 0 holds IExec(if<0(a,k1,I),s).b = IExec(I,s).b
proof
  let s be State of SCMPDS,I be halt-free shiftable parahalting Program of
  SCMPDS,a,b be Int_position,k1 be Integer;
  assume
A1: s.DataLoc(s.a,k1) < 0;
A2: not b in dom Start-At((card I+1),SCMPDS) by SCMPDS_4:59;
  I is_closed_on s & I is_halting_on s by Th34,Th35;
  then IExec(if<0(a,k1,I),s) = IExec(I,s) +* Start-At((card I+1),SCMPDS)
  by A1,Th124;
  hence thesis by A2,FUNCT_4:12;
end;

theorem
  for s being State of SCMPDS,I being Program of SCMPDS,a,b being
Int_position, k1 being Integer st s.DataLoc(s.a,k1) >= 0 holds IExec(if<0(a,k1,
  I),s).b = s.b
proof
  let s be State of SCMPDS,I be Program of SCMPDS,a,b be Int_position, k1 be
  Integer;
  assume
  s.DataLoc(s.a,k1) >= 0;
  then
A1: IExec(if<0(a,k1,I),s) = s +* Start-At((card I+1),SCMPDS) by Th125;
  not b in dom Start-At((card I+1),SCMPDS) by SCMPDS_4:59;
  hence thesis by A1,FUNCT_4:12;
end;

begin :: The computation of "if var>=0 then block"

theorem
  card if>=0(a,k1,I) = card I + 2 by Lm8;

theorem
   0 in dom if>=0(a,k1,I) &  1 in dom if>=0(a,k1,I) by Lm9;

theorem
  if>=0(a,k1,I). 0 = (a,k1)>=0_goto 2 & if>=0(a,k1,I). 1 =
  goto (card I + 1) by Lm10;

theorem Th132:
  for s being State of SCMPDS, I being shiftable Program of
  SCMPDS, a being Int_position,k1 being Integer st s.DataLoc(s.a,k1) >= 0 & I
is_closed_on s & I is_halting_on s holds if>=0(a,k1,I) is_closed_on s & if>=0(a
  ,k1,I) is_halting_on s
proof
  let s be State of SCMPDS, I be shiftable Program of SCMPDS, a be
  Int_position,k1 be Integer;
  set b=DataLoc(s.a,k1);
  set IF=if>=0(a,k1,I), pIF=stop IF, IsIF=Initialized pIF, pI=stop I, IsI=
  Initialized pI, s2 = s +* IsI, s3 = s +* IsIF, s4 = Comput(ProgramPart(s3),s3
,1);
  set i = (a,k1)>=0_goto 2, j = goto (card I + 1);
A1: IF = i ';' (j ';' I) by SCMPDS_4:52;
A2: Comput(ProgramPart( s3), s3,0 + 1) = Following(ProgramPart s3,
Comput(ProgramPart(s3),s3,0)) by AMI_1:14
    .= Following(ProgramPart s3,s3) by AMI_1:13
    .= Exec(i,s3) by A1,Th22;
A3: DataPart s2 = DataPart s3 by SCMPDS_4:24,36;
  now
    let a;
    thus s2.a = s3.a by A3,SCMPDS_4:23
      .= s4.a by A2,SCMPDS_2:69;
  end;
  then
A4: DataPart s2 = DataPart s4 by SCMPDS_4:23;
A5: not b in dom IsIF by SCMPDS_4:31;
  not a in dom IsIF by SCMPDS_4:31;
  then
A6: s3.DataLoc(s3.a,k1)=s3.b by FUNCT_4:12
    .= s.b by A5,FUNCT_4:12;
A7: IC s3 = 0 by FUNCT_4:26,SCMPDS_5:18;
  assume
  s.b >= 0;
  then
A8: IC s4 = ICplusConst(s3,2) by A2,A6,SCMPDS_2:69
    .= (0+2) by A7,Th23;
  assume
A9: I is_closed_on s;
  then
A10: I is_closed_on s2 by Th38;
  assume
  I is_halting_on s;
  then
A11: ProgramPart s2 halts_on s2 by Def3;
A12: IsI c= s2 & Shift(pI,2) c= s4 by Lm6,FUNCT_4:26;
A13:  0 in dom pIF by SCMPDS_4:75;
  now
    let k be Element of NAT;
    per cases;
    suppose
      0 < k;
      then consider k1 being Nat such that
A14:  k1 + 1 = k by NAT_1:6;
      reconsider k1 as Element of NAT by ORDINAL1:def 13;
      reconsider m = IC Comput(ProgramPart( s2), s2,k1) as Element of NAT;
A15:  card pIF = 1+ card IF by SCMPDS_5:7
        .= 1+(card I +2) by Lm8
        .= 1+card I +2
        .=card pI+2 by SCMPDS_5:7;
       m in dom pI by A9,Def2;
      then m < card pI by AFINSQ_1:70;
      then
A16:  m+2 < card pIF by A15,XREAL_1:8;
T: ProgramPart s3 = ProgramPart s4
by AMI_1:123;
      IC Comput(ProgramPart(s3),s3,k) = IC Comput(ProgramPart( s3), s4,k1) by
A14,AMI_1:51
        .=  (m + 2) by A10,A12,A8,A4,Th45,T;
      hence IC Comput(ProgramPart(s3),s3,k) in dom pIF by A16,AFINSQ_1:70;
    end;
    suppose
      k = 0;
      hence IC Comput(ProgramPart(s3),s3,k) in dom pIF by A13,A7,AMI_1:13;
    end;
  end;
  hence IF is_closed_on s by Def2;
T: ProgramPart s3 = ProgramPart Comput(
ProgramPart(s3),s3,1)
by AMI_1:123;
x: Comput(ProgramPart(s3),s3,LifeSpan(ProgramPart(s2),s2)+1)
 = Comput(ProgramPart(s3),Comput(ProgramPart(s3),s3,1),LifeSpan(ProgramPart(s2)
,s2))
by AMI_1:51;
TX4: ProgramPart s4 = ProgramPart
Comput(ProgramPart(s4),s4,LifeSpan(ProgramPart(s2),s2)
)
by AMI_1:123;
TX2: ProgramPart s2 = ProgramPart
Comput(ProgramPart(s2),s2,LifeSpan(ProgramPart(s2),
s2))
by AMI_1:123;
  CurInstr(ProgramPart s3,
  Comput(ProgramPart(s3),s3,LifeSpan(ProgramPart(s2),s2)+1))
   =CurInstr(ProgramPart s4,
   Comput(ProgramPart(s4),s4,LifeSpan(ProgramPart(s2),s2))) by x,T
    .=CurInstr(ProgramPart s2,
    Comput(ProgramPart(s2),s2,LifeSpan(ProgramPart(s2),s2))) by A10,A12,A8,A4
,Th45,TX2,TX4
    .= halt SCMPDS by A11,AMI_1:def 46;
  then ProgramPart s3 halts_on s3 by AMI_1:146;
  hence thesis by Def3;
end;

theorem Th133:
  for s being State of SCMPDS,I being Program of SCMPDS, a being
  Int_position, k1 being Integer st s.DataLoc(s.a,k1) < 0 holds if>=0(a,k1,I)
  is_closed_on s & if>=0(a,k1,I) is_halting_on s
proof
  let s be State of SCMPDS,I be Program of SCMPDS, a be Int_position,k1 be
  Integer;
  set b=DataLoc(s.a,k1);
  assume
A1: s.b < 0;
  set i = (a,k1)>=0_goto 2, j = goto (card I + 1);
  set IF=if>=0(a,k1,I), pIF=stop IF, IsIF=Initialized pIF, s3 = s +* IsIF, s4
  = Comput(ProgramPart(s3),s3,1), s5 = Comput(ProgramPart(s3),s3,2);
A2: IF =i ';' (j ';' I) by SCMPDS_4:52;
A3: not b in dom IsIF by SCMPDS_4:31;
  not a in dom IsIF by SCMPDS_4:31;
  then
A4: s3.DataLoc(s3.a,k1)=s3.b by FUNCT_4:12
    .= s.b by A3,FUNCT_4:12;
A5: IC s3 = 0 by FUNCT_4:26,SCMPDS_5:18;
  Comput(ProgramPart( s3), s3,0 + 1) = Following(ProgramPart s3,
  Comput(ProgramPart(s3),s3,0)) by AMI_1:14
    .= Following(ProgramPart s3,s3) by AMI_1:13
    .= Exec(i,s3) by A2,Th22;
  then
A6: IC s4 = succ IC s3 by A1,A4,SCMPDS_2:69
    .= (0+1) by A5;
A7: IsIF c= s3 by FUNCT_4:26;
  then
A8: pIF c= s4 by AMI_1:81,SCMPDS_4:57;
A9:  1 in dom IF by Lm9;
  then  1 in dom pIF by Th18;
  then
A10: s4. 1 = pIF. 1 by A8,GRFUNC_1:8
    .=IF. 1 by A9,Th19
    .=j by Lm10;
A11: card IF=card I+2 by Lm8;
  then
A12: (card I+2) in dom pIF by Th25;
Y:  (ProgramPart s4)/.IC s4
 = s4.IC s4 by AMI_1:150;
T: ProgramPart s3 = ProgramPart s4
by AMI_1:123;
  Comput(ProgramPart( s3), s3,1 + 1) = Following(ProgramPart s3,s4) by AMI_1:14
    .= Exec(j,s4) by A6,A10,Y,T;
  then
A13: IC s5 = ICplusConst(s4,card I+1) by SCMPDS_2:66
    .= (card I+1+1) by A6,Th23
    .= (card I+(1+1));
Y:  (ProgramPart s5)/.IC s5
 = s5.IC s5 by AMI_1:150;
TX: ProgramPart s3 = ProgramPart s5
by AMI_1:123;
  pIF c= s5 by A7,AMI_1:81,SCMPDS_4:57;
  then s5.(card I+2) = pIF.(card I+2) by A12,GRFUNC_1:8
    .=halt SCMPDS by A11,Th25;
  then
A14: CurInstr(ProgramPart s3,s5) = halt SCMPDS by A13,Y,TX;
  now
    let k be Element of NAT;
A15: k = 0 or 0 + 1 <= k by INT_1:20;
    per cases by A15,XXREAL_0:1;
    suppose
      k = 0;
      then Comput(ProgramPart(s3),s3,k) = s3 by AMI_1:13;
      hence IC Comput(ProgramPart(s3),s3,k) in dom pIF by A5,SCMPDS_4:75;
    end;
    suppose
      k = 1;
      hence IC Comput(ProgramPart(s3),s3,k) in dom pIF by A9,A6,Th18;
    end;
    suppose
      1 < k;
      then 1+1 <= k by INT_1:20;
      hence IC Comput(ProgramPart(s3),s3,k) in dom pIF
      by A12,A13,A14,AMI_1:52;
    end;
  end;
  hence IF is_closed_on s by Def2;
  ProgramPart s3 halts_on s3 by A14,AMI_1:146;
  hence thesis by Def3;
end;

theorem Th134:
  for s being State of SCMPDS,I being halt-free shiftable
  Program of SCMPDS, a being Int_position,k1 being Integer st s.DataLoc(s.a,k1)
  >= 0 & I is_closed_on s & I is_halting_on s holds IExec(if>=0(a,k1,I),s) =
  IExec(I,s) +* Start-At((card I+2),SCMPDS)
proof
  let s be State of SCMPDS,I be halt-free shiftable Program of SCMPDS, a be
  Int_position,k1 be Integer;
  set b=DataLoc(s.a,k1);
  set IF=if>=0(a,k1,I), IsIF=Initialized stop IF, pI=stop I, IsI= Initialized
  pI, s2 = s +* IsI, s3 = s +* IsIF, s4 = Comput(ProgramPart( s3), s3,1);
  set i = (a,k1)>=0_goto 2, j = goto (card I + 1);
  set SAl=Start-At((card I+2),SCMPDS);
A1: IF=i ';' (j ';' I) by SCMPDS_4:52;
A2: Comput(ProgramPart( s3), s3,0 + 1) = Following(ProgramPart s3,
Comput(ProgramPart(s3),s3,0)) by AMI_1:14
    .= Following(ProgramPart s3,s3) by AMI_1:13
    .= Exec(i,s3) by A1,Th22;
A3: not b in dom IsIF by SCMPDS_4:31;
  not a in dom IsIF by SCMPDS_4:31;
  then
A4: s3.DataLoc(s3.a,k1)=s3.b by FUNCT_4:12
    .= s.b by A3,FUNCT_4:12;
A5: IC s3 = 0 by FUNCT_4:26,SCMPDS_5:18;
A6: IsI c= s2 & Shift(pI,2) c= s4 by Lm6,FUNCT_4:26;
A7: DataPart s2 = DataPart s3 by SCMPDS_4:24,36;
  now
    let a;
    thus s2.a = s3.a by A7,SCMPDS_4:23
      .= s4.a by A2,SCMPDS_2:69;
  end;
  then
A8: DataPart s2 = DataPart s4 by SCMPDS_4:23;
  assume
  s.b >= 0;
  then
A9: IC s4 = ICplusConst(s3,2) by A2,A4,SCMPDS_2:69
    .= (0+2) by A5,Th23;
A10: dom ProgramPart s = A by AMI_1:143;
  assume
A11: I is_closed_on s;
  then
A12: I is_closed_on s2 by Th38;
  assume
A13: I is_halting_on s;
  then
A14: ProgramPart s2 halts_on s2 by Def3;
T: ProgramPart s3 = ProgramPart Comput(
ProgramPart(s3),s3,1)
by AMI_1:123;
x: Comput(ProgramPart(s3),s3,LifeSpan(ProgramPart(s2),s2)+1)
 = Comput(ProgramPart(s3),Comput(ProgramPart(s3),s3,1),LifeSpan(ProgramPart(s2)
,s2))
 by AMI_1:51;
TX4: ProgramPart s4 = ProgramPart
Comput(ProgramPart(s4),s4,LifeSpan(ProgramPart(s2),s2))
by AMI_1:123;
TX2: ProgramPart s2 = ProgramPart
Comput(ProgramPart(s2),s2,LifeSpan(ProgramPart(s2),
s2))
by AMI_1:123;
A15: CurInstr(ProgramPart s3,
Comput(ProgramPart(s3),s3,LifeSpan(ProgramPart(s2),s2)+1))
 =CurInstr(ProgramPart s4,
 Comput(ProgramPart(s4),s4,LifeSpan(ProgramPart(s2),s2))) by x,T
    .=CurInstr(ProgramPart s2,
    Comput(ProgramPart(s2),s2,LifeSpan(ProgramPart(s2),s2)))
     by A12,A6,A9,A8,Th45,TX2,TX4
    .= halt SCMPDS by A14,AMI_1:def 46;
  then
A16: ProgramPart s3 halts_on s3 by AMI_1:146;
A17: CurInstr(ProgramPart s3,s3) = i by A1,Th22;
  now
    let l be Element of NAT;
    assume
A18: l < LifeSpan(ProgramPart(s2),s2) + 1;
u: Comput(ProgramPart(s3),s3,0) = s3 by AMI_1:13;
    per cases;
    suppose
      l = 0;
      then CurInstr(ProgramPart s3,Comput(ProgramPart(s3),s3,l))
       = CurInstr(ProgramPart s3,s3)
      by u;
      hence CurInstr(ProgramPart (s3),Comput(
ProgramPart(s3),s3,l))
       <> halt SCMPDS by A17,Th31;
    end;
    suppose
      l <> 0;
      then consider n be Nat such that
A19:  l = n + 1 by NAT_1:6;
      reconsider n as Element of NAT by ORDINAL1:def 13;
A20:  n < LifeSpan(ProgramPart(s2),s2) by A18,A19,XREAL_1:8;
      assume
A21:  CurInstr(ProgramPart (s3),Comput(ProgramPart(s3),
s3,l)) = halt SCMPDS;
T: ProgramPart s3 = ProgramPart Comput(ProgramPart(s3),
s3,1)
by AMI_1:123;
x: Comput(ProgramPart(s3),s3,n+1)
 = Comput(ProgramPart(s3),Comput(ProgramPart(s3),s3,1),n) by AMI_1:51;
TX2: ProgramPart s2 = ProgramPart Comput(ProgramPart(s2),s2,n)
by AMI_1:123;
TX4: ProgramPart s4 = ProgramPart Comput(ProgramPart(s4),s4,n)
by AMI_1:123;
      CurInstr(ProgramPart s2,Comput(ProgramPart(s2),s2,n))
       = CurInstr(ProgramPart s4,Comput(ProgramPart(s4),s4,n))
       by A12,A6,A9,A8,Th45,TX2,TX4
        .= halt SCMPDS by A19,A21,x,T;
      hence contradiction by A14,A20,AMI_1:def 46;
    end;
  end;
  then for l be Element of NAT st CurInstr(ProgramPart (s3),
  Comput(ProgramPart(s3),s3,l)) = halt SCMPDS
  holds LifeSpan(ProgramPart(s2),s2) + 1 <= l;
  then
A22: LifeSpan(ProgramPart(s3),s3) = LifeSpan(ProgramPart(s2),s2) + 1 by A15,A16
,AMI_1:def 46;
T: ProgramPart s3 = ProgramPart s4
by AMI_1:123;
A23: DataPart Result(ProgramPart(s2),s2) = DataPart Comput(ProgramPart(s2),s2,
LifeSpan(ProgramPart(s2),s2)) by A14,AMI_1:122
    .= DataPart Comput(ProgramPart( s3), s4,LifeSpan(ProgramPart(s2),s2)) by
A12,A6,A9,A8,Th45,T
    .= DataPart Comput(ProgramPart( s3), s3,LifeSpan(ProgramPart(s2),s2) + 1)
by AMI_1:51
    .= DataPart Result(ProgramPart(s3),s3) by A16,A22,AMI_1:122;
A24: now
    let x be set;
A25: IExec(I,s) = Result(ProgramPart(s2),s2) +* s | A by SCMPDS_4:def 8;
A26: IExec(IF,s) = Result(ProgramPart(s3),s3) +* s | A by SCMPDS_4:def 8;
A27: dom Start-At((card I+2),SCMPDS) = {IC SCMPDS} by FUNCOP_1:19;
    assume
A28: x in dom IExec(IF,s);
    per cases by A28,SCMPDS_4:20;
    suppose
A29:  x is Int_position;
      then x <> IC SCMPDS by SCMPDS_2:52;
      then
A30:  not x in dom SAl by A27,TARSKI:def 1;
A31: not x in dom (s | A) by A10,A29,SCMPDS_2:53;
      hence IExec(IF,s).x = (Result(ProgramPart(s3),s3)).x by A26,FUNCT_4:12
        .= (Result(ProgramPart(s2),s2)).x by A23,A29,SCMPDS_4:23
        .= IExec(I,s).x by A25,A31,FUNCT_4:12
        .= (IExec(I,s) +* SAl).x by A30,FUNCT_4:12;
    end;
    suppose
A32:  x = IC SCMPDS;
A33: not x in dom (s | A) by A10,A32,AMI_1:48;
      then
A34:  IC Result(ProgramPart(s2),s2) = IC IExec(I,s) by A25,A32,FUNCT_4:12
        .=  card I by A11,A13,Th48;
A35:  x in dom SAl by A27,A32,TARSKI:def 1;
T: ProgramPart s3 = ProgramPart s4
by AMI_1:123;
      thus IExec(IF,s).x = (Result(ProgramPart(s3),s3)).x by A26,A33,FUNCT_4:12
        .= Comput(ProgramPart( s3), s3,LifeSpan(ProgramPart(s2),s2) + 1).x by
A16,A22,AMI_1:122
        .= IC Comput(ProgramPart( s3), s4,LifeSpan(ProgramPart(s2),s2)) by A32,
AMI_1:51
        .= IC Comput(ProgramPart( s2), s2,LifeSpan(ProgramPart(s2),s2)) + 2
        by A12,A6,A9,A8,Th45,T
        .= IC Result(ProgramPart(s2),s2) + 2 by A14,AMI_1:122
        .= SAl.IC SCMPDS by A34,FUNCOP_1:87
        .= (IExec(I,s) +* SAl).x by A32,A35,FUNCT_4:14;
    end;
    suppose
      x is Element of NAT;
      hence IExec(IF,s).x = (IExec(I,s) +* SAl).x by Th26;
    end;
  end;
  dom IExec(IF,s) = the carrier of SCMPDS by PARTFUN1:def 4
    .= dom (IExec(I,s) +* Start-At((card I+2),SCMPDS)) by PARTFUN1:def 4;
  hence thesis by A24,FUNCT_1:9;
end;

theorem Th135:
  for s being State of SCMPDS,I being Program of SCMPDS,a being
Int_position, k1 being Integer st s.DataLoc(s.a,k1) < 0 holds IExec(if>=0(a,k1,
  I),s) = s +* Start-At((card I+2),SCMPDS)
proof
  let s be State of SCMPDS,I be Program of SCMPDS,a be Int_position, k1 be
  Integer;
  set b=DataLoc(s.a,k1);
  set IF=if>=0(a,k1,I), pIF=stop IF, IsIF=Initialized pIF, s3 = s +* IsIF, s4
  = Comput(ProgramPart(s3),s3,1), s5 = Comput(ProgramPart(s3),s3,2);
  set i = (a,k1)>=0_goto 2, j = goto (card I + 1);
  set SAl=Start-At((card I+2),SCMPDS);
A1: IF =i ';' (j ';' I) by SCMPDS_4:52;
A2: not b in dom IsIF by SCMPDS_4:31;
  not a in dom IsIF by SCMPDS_4:31;
  then
A3: s3.DataLoc(s3.a,k1)=s3.b by FUNCT_4:12
    .= s.b by A2,FUNCT_4:12;
A4: IC s3 = 0 by FUNCT_4:26,SCMPDS_5:18;
A5: IsIF c= s3 by FUNCT_4:26;
  then
A6: pIF c= s4 by AMI_1:81,SCMPDS_4:57;
A7: pIF c= s5 by A5,AMI_1:81,SCMPDS_4:57;
A8: Comput(ProgramPart( s3), s3,0 + 1) = Following(ProgramPart s3,
Comput(ProgramPart(s3),s3,0)) by AMI_1:14
    .= Following(ProgramPart s3,s3) by AMI_1:13
    .= Exec(i,s3) by A1,Th22;
  assume
  s.b < 0;
  then
A9: IC s4 = succ IC s3 by A8,A3,SCMPDS_2:69
    .= (0+1) by A4;
A10:  1 in dom IF by Lm9;
  then  1 in dom pIF by Th18;
  then
A11: s4. 1 = pIF. 1 by A6,GRFUNC_1:8
    .=IF. 1 by A10,Th19
    .=j by Lm10;
Y:  (ProgramPart s4)/.IC s4
 = s4.IC s4 by AMI_1:150;
T: ProgramPart s3 = ProgramPart s4
by AMI_1:123;
A12: Comput(ProgramPart( s3), s3,1 + 1) = Following(ProgramPart s3,s4) by
AMI_1:14
    .= Exec(j,s4) by A9,A11,Y,T;
  then
A13: IC s5 = ICplusConst(s4,card I+1) by SCMPDS_2:66
    .= (card I+1+1) by A9,Th23
    .= (card I+(1+1));
Y:  (ProgramPart s5)/.IC s5
 = s5.IC s5 by AMI_1:150;
TX: ProgramPart s3 = ProgramPart s5
by AMI_1:123;
A14: card IF=card I+2 by Lm8;
  then (card I+2) in dom pIF by Th25;
  then s5.(card I+2) = pIF.(card I+2) by A7,GRFUNC_1:8
    .=halt SCMPDS by A14,Th25;
  then
A15: CurInstr(ProgramPart s3,s5) = halt SCMPDS by A13,Y,TX;
  then
A16: ProgramPart s3 halts_on s3 by AMI_1:146;
A17: CurInstr(ProgramPart s3,s3) = i by A1,Th22;
  now
    let l be Element of NAT;
    assume
    l < 1+1;
    then
A18: l <= 1 by NAT_1:13;
u: Comput(ProgramPart(s3),s3,0) = s3 by AMI_1:13;
Y:  (ProgramPart Comput(ProgramPart(s3),s3,l))/.IC Comput(ProgramPart(s3),s3,l)
 = Comput(ProgramPart(s3),s3,l).IC Comput(ProgramPart(s3),s3,l) by AMI_1:150;
TX: ProgramPart s3 = ProgramPart Comput(ProgramPart(s3),s3,l)
by AMI_1:123;
    per cases by A18,NAT_1:26;
    suppose
      l=0;
      then CurInstr(ProgramPart s3,Comput(ProgramPart(s3),s3,l))
       = CurInstr(ProgramPart s3,s3)
       by u;
      hence CurInstr(ProgramPart (s3),Comput(ProgramPart(s3),s3,l))
       <> halt SCMPDS by A17,Th31;
    end;
    suppose
      l=1;
      hence CurInstr(ProgramPart (s3),Comput(ProgramPart(s3),s3,l))
       <> halt SCMPDS by A9,A11,Y,TX,SCMPDS_2:85;
    end;
  end;
  then for l be Element of NAT st CurInstr(ProgramPart (s3),
  Comput(ProgramPart(s3),s3,l)) = halt SCMPDS
  holds 2 <= l;
  then LifeSpan(ProgramPart(s3),s3) = 2 by A15,A16,AMI_1:def 46;
  then
A19: s5 = Result(ProgramPart(s3),s3) by A16,AMI_1:122;
A20: dom ProgramPart s = A by AMI_1:143;
A21: now
A22: dom SAl = {IC SCMPDS} by FUNCOP_1:19;
    let x be set;
A23: IExec(IF,s) = Result(ProgramPart(s3),s3) +* s | A by SCMPDS_4:def 8;
    assume
A24: x in dom IExec(IF,s);
    per cases by A24,SCMPDS_4:20;
    suppose
A25:  x is Int_position;
      then x <> IC SCMPDS by SCMPDS_2:52;
      then
A26:  not x in dom SAl by A22,TARSKI:def 1;
      not x in dom (s | A) by A20,A25,SCMPDS_2:53;
      hence IExec(IF,s).x = s5.x by A19,A23,FUNCT_4:12
        .= s4.x by A12,A25,SCMPDS_2:66
        .= s3.x by A8,A25,SCMPDS_2:69
        .= s.x by A25,SCMPDS_5:19
        .= (s +* SAl).x by A26,FUNCT_4:12;
    end;
    suppose
A27:  x = IC SCMPDS;
      not x in dom (s | A) by A20,A27,AMI_1:48;
      hence IExec(IF,s).x = (card I + 2) by A13,A19,A23,A27,FUNCT_4:12
        .= (s +* Start-At((card I+2),SCMPDS)).x by A27,FUNCT_4:121;
    end;
    suppose
      x is Element of NAT;
      hence IExec(IF,s).x = (s +* SAl).x by Th27;
    end;
  end;
  dom IExec(IF,s) = the carrier of SCMPDS by PARTFUN1:def 4
    .= dom (s +* SAl) by PARTFUN1:def 4;
  hence thesis by A21,FUNCT_1:9;
end;

registration
  let I be shiftable parahalting Program of SCMPDS, a be Int_position,k1 be
  Integer;
  cluster if>=0(a,k1,I) -> shiftable parahalting;
  correctness
  proof
    set i = (a,k1)>=0_goto 2, j = goto (card I + 1);
    set IF=if>=0(a,k1,I), IsIF=Initialized stop IF;
    IF =Load i ';' Load j ';' I by SCMPDS_4:def 6;
    hence IF is shiftable;
    now
      let s be State of SCMPDS;
      assume
      IsIF c= s;
      then
A1:   s = s +* IsIF by FUNCT_4:79;
A2:   I is_closed_on s & I is_halting_on s by Th34,Th35;
      per cases;
      suppose
        s.DataLoc(s.a,k1) >= 0;
        then IF is_halting_on s by A2,Th132;
        hence ProgramPart s halts_on s by A1,Def3;
      end;
      suppose
        s.DataLoc(s.a,k1) < 0;
        then IF is_halting_on s by Th133;
        hence ProgramPart s halts_on s by A1,Def3;
      end;
    end;
    then IsIF is halting by AMI_1:def 26;
    hence thesis by SCMPDS_4:def 10;
  end;
end;

registration
  let I be halt-free Program of SCMPDS, a be Int_position,k1 be Integer;
  cluster if>=0(a,k1,I) -> halt-free;
  coherence;
end;

theorem
  for s being State of SCMPDS,I being halt-free shiftable parahalting
Program of SCMPDS,a being Int_position,k1 being Integer holds IC IExec(if>=0(a,
  k1,I),s) =  (card I + 2)
proof
  let s be State of SCMPDS,I be halt-free shiftable parahalting Program of
  SCMPDS,a be Int_position,k1 be Integer;
  set IF=if>=0(a,k1,I);
A1: I is_closed_on s & I is_halting_on s by Th34,Th35;
  per cases;
  suppose
    s.DataLoc(s.a,k1) >= 0;
    then IExec(IF,s) =IExec(I,s) +* Start-At((card I+2),SCMPDS)
    by A1,Th134;
    hence thesis by FUNCT_4:121;
  end;
  suppose
    s.DataLoc(s.a,k1) < 0;
    then IExec(IF,s) =s +* Start-At((card I+2),SCMPDS) by Th135;
    hence thesis by FUNCT_4:121;
  end;
end;

theorem
  for s being State of SCMPDS,I being halt-free shiftable parahalting
Program of SCMPDS,a,b being Int_position,k1 being Integer st s.DataLoc(s.a,k1)
  >= 0 holds IExec(if>=0(a,k1,I),s).b = IExec(I,s).b
proof
  let s be State of SCMPDS,I be halt-free shiftable parahalting Program of
  SCMPDS,a,b be Int_position,k1 be Integer;
  assume
A1: s.DataLoc(s.a,k1) >= 0;
A2: not b in dom Start-At((card I+2),SCMPDS) by SCMPDS_4:59;
  I is_closed_on s & I is_halting_on s by Th34,Th35;
  then IExec(if>=0(a,k1,I),s) = IExec(I,s) +* Start-At((card I+2),SCMPDS)
   by A1,Th134;
  hence thesis by A2,FUNCT_4:12;
end;

theorem
  for s being State of SCMPDS,I being Program of SCMPDS,a,b being
Int_position, k1 being Integer st s.DataLoc(s.a,k1) < 0 holds IExec(if>=0(a,k1,
  I),s).b = s.b
proof
  let s be State of SCMPDS,I be Program of SCMPDS,a,b be Int_position, k1 be
  Integer;
  assume
  s.DataLoc(s.a,k1) < 0;
  then
A1: IExec(if>=0(a,k1,I),s) = s +* Start-At((card I+2),SCMPDS) by Th135;
  not b in dom Start-At((card I+2),SCMPDS) by SCMPDS_4:59;
  hence thesis by A1,FUNCT_4:12;
end;

