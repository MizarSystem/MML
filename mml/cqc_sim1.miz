:: Similarity of Formulae
::  by Agata Darmochwa{\l} and Andrzej Trybulec
::
:: Received November 22, 1991
:: Copyright (c) 1991 Association of Mizar Users

environ

 vocabularies NUMBERS, FUNCT_1, RELAT_1, FUNCT_4, FUNCOP_1, TARSKI, XBOOLE_0,
      SUBSET_1, CQC_LANG, QC_LANG1, ZF_LANG, REALSET1, XXREAL_0, FINSEQ_1,
      XBOOLEAN, CLASSES2, BVFUNC_2, NAT_1, ARYTM_3, CARD_1, FUNCT_2, MARGREL1,
      FINSUB_1, ZFMISC_1, FINSET_1, ZF_LANG1, RCOMP_1, PARTFUN1, SETWISEO,
      SETFAM_1, CQC_SIM1;
 notations TARSKI, XBOOLE_0, ZFMISC_1, SUBSET_1, NUMBERS, DOMAIN_1, MCART_1,
      SETFAM_1, RELAT_1, FUNCT_1, FUNCT_2, BINOP_1, PARTFUN1, XXREAL_0,
      FUNCOP_1, FINSEQ_1, FINSET_1, FINSUB_1, NAT_1, SETWISEO, QC_LANG1,
      QC_LANG2, QC_LANG3, CQC_LANG, FUNCT_4, RECDEF_1, SEQ_4;
 constructors SETFAM_1, PARTFUN1, BINOP_1, DOMAIN_1, FUNCT_4, SETWISEO,
      XXREAL_0, NAT_1, RECDEF_1, SEQ_4, QC_LANG3, CQC_LANG, XXREAL_2, RELSET_1;
 registrations XBOOLE_0, SUBSET_1, FUNCT_1, ORDINAL1, FUNCT_2, FINSUB_1,
      XXREAL_0, NAT_1, MEMBERED, FINSEQ_1, QC_LANG1, CQC_LANG, VALUED_0,
      FINSET_1, FUNCOP_1, XXREAL_2, RELSET_1, CARD_1;
 requirements NUMERALS, REAL, BOOLE, SUBSET;
 definitions TARSKI, XBOOLE_0, BINOP_1, QC_LANG3, SUBSET_1, RELAT_1, FUNCOP_1;
 theorems ZFMISC_1, DOMAIN_1, FINSEQ_1, CQC_LANG, QC_LANG1, PARTFUN1, QC_LANG3,
      MCART_1, FUNCT_1, FUNCT_2, NAT_1, TARSKI, FUNCOP_1, FUNCT_4, FINSEQ_2,
      SETFAM_1, QC_LANG2, RELAT_1, RELSET_1, FINSEQ_3, XBOOLE_0, XBOOLE_1,
      XXREAL_0, XXREAL_2, CARD_1;
 schemes CQC_LANG, FUNCT_2, CLASSES1, NAT_1, FRAENKEL, CARD_3, QC_LANG1,
      WELLORD2, BINOP_1;

begin

theorem Th1:
  for x,y being set, f being Function holds Im(f+*(x .--> y),x) = { y}
proof
  let x,y be set, f be Function;
  now
    let u be set;
    thus u in (f+*(x .--> y)).:{x} implies u = y
    proof
      assume u in (f+*(x .--> y)).:{x};
      then consider z being set such that
      z in dom(f+*(x .--> y)) and
A1:   z in {x} and
A2:   u = (f+*(x .--> y)).z by FUNCT_1:def 12;
      z in dom(x .--> y) by A1,FUNCOP_1:19;
      then u = (x .--> y).z by A2,FUNCT_4:14;
      hence thesis by A1,FUNCOP_1:13;
    end;
A3: x in {x} by TARSKI:def 1;
    then
A4: x in dom(x .--> y) by FUNCOP_1:19;
    then
A5: x in dom(f+*(x .--> y)) by FUNCT_4:13;
    (x .--> y).x = y by A3,FUNCOP_1:13;
    then y = (f+*(x .--> y)).x by A4,FUNCT_4:14;
    hence u = y implies u in (f+*(x .--> y)).:{x} by A3,A5, FUNCT_1:def
    12;
  end;
  hence thesis by TARSKI:def 1;
end;

theorem Th2:
  for K,L being set for x,y being set, f being Function holds (f+*(
  L --> y)).:K c= f.:K \/ {y}
proof
  let K,L be set, x,y be set, f be Function, z be set;
  assume z in (f+*(L --> y)).:K;
  then consider u being set such that
A1: u in dom(f+*(L --> y)) and
A2: u in K and
A3: z = (f+*(L --> y)).u by FUNCT_1:def 12;
A4: dom(L --> y) = L by FUNCOP_1:19;
  now
    per cases;
    case
A5:   u in L;
      then z = (L --> y).u by A3,A4,FUNCT_4:14;
      then z = y by A5,FUNCOP_1:13;
      hence z in {y} by TARSKI:def 1;
    end;
    case
A6:   not u in L;
      then
A7:   z = f.u by A3,A4,FUNCT_4:12;
      u in dom f by A1,A4,A6,FUNCT_4:13;
      hence z in f.:K by A2,A7,FUNCT_1:def 12;
    end;
  end;
  hence thesis by XBOOLE_0:def 3;
end;

theorem Th3:
  for x,y being set, g being Function, A being set holds (g +* (x
  .--> y)).:(A \ {x}) = g.:(A \ {x})
proof
  let x,y be set, g be Function, A be set;
  thus (g +* (x .--> y)).:(A \ {x}) c= g.:(A \ {x})
  proof
    let u be set;
A1: dom(x .--> y) = {x} by FUNCOP_1:19;
    assume u in (g +* (x .--> y)).:(A \ {x});
    then consider z being set such that
A2: z in dom(g +* (x .--> y)) and
A3: z in A \ {x} and
A4: u = (g +* (x .--> y)).z by FUNCT_1:def 12;
A5: not z in {x} by A3,XBOOLE_0:def 5;
    then
A6: z in dom g by A2,A1,FUNCT_4:13;
    u = g.z by A4,A5,A1,FUNCT_4:12;
    hence thesis by A3,A6,FUNCT_1:def 12;
  end;
  let u be set;
  assume u in g.:(A \ {x});
  then consider z being set such that
A7: z in dom g and
A8: z in A \ {x} and
A9: u = g.z by FUNCT_1:def 12;
  not z in {x} by A8,XBOOLE_0:def 5;
  then not z in dom(x .--> y) by FUNCOP_1:19;
  then
A10: u = (g +* (x .--> y)).z by A9,FUNCT_4:12;
  z in dom(g +* (x .--> y)) by A7,FUNCT_4:13;
  hence thesis by A8,A10,FUNCT_1:def 12;
end;

theorem Th4:
  for x,y being set for g being Function for A being set st not y
in g.:(A \ {x}) holds (g +* (x .--> y)).:(A \ {x}) = (g +* (x .--> y)).:A \ {y}
proof
  let x,y be set, g be Function, A be set;
  assume
A1: not y in g.:(A \ {x});
  thus (g +* (x .--> y)).:(A \ {x}) c= (g +* (x .--> y)).:A \ {y}
  proof
    let u be set;
A2: dom(x .--> y) = {x} by FUNCOP_1:19;
    assume
A3: u in (g +* (x .--> y)).:(A \ {x});
    then consider z being set such that
A4: z in dom(g +* (x .--> y)) and
A5: z in A \ {x} and
A6: u = (g +* (x .--> y)).z by FUNCT_1:def 12;
A7: not z in {x} by A5,XBOOLE_0:def 5;
    then
A8: z in dom g by A4,A2,FUNCT_4:13;
    u = g.z by A6,A7,A2,FUNCT_4:12;
    then u <> y by A1,A5,A8,FUNCT_1:def 12;
    then
A9: not u in {y} by TARSKI:def 1;
    (g +* (x .--> y)).:(A \ {x}) c= (g +* (x .--> y)).: A by RELAT_1:156;
    hence thesis by A3,A9,XBOOLE_0:def 5;
  end;
  let u be set;
  assume
A10: u in (g +* (x .--> y)).:A \ {y};
  then consider z being set such that
A11: z in dom(g +* (x .--> y)) and
A12: z in A and
A13: u = (g +* (x .--> y)).z by FUNCT_1:def 12;
  now
    assume
A14: z in {x};
    then z in dom(x .--> y) by FUNCOP_1:19;
    then u = (x .--> y).z by A13,FUNCT_4:14;
    then u = y by A14,FUNCOP_1:13;
    then u in {y} by TARSKI:def 1;
    hence contradiction by A10,XBOOLE_0:def 5;
  end;
  then z in A \ {x} by A12,XBOOLE_0:def 5;
  hence thesis by A11,A13,FUNCT_1:def 12;
end;

reserve p,q,r,s for Element of CQC-WFF,
  x for Element of bound_QC-variables,
  i ,j,k,l,m,n for Element of NAT,
  a,b,e for set,
  ll for CQC-variable_list of k,
  P for QC-pred_symbol of k;

theorem Th5:
  p is atomic implies ex k,P,ll st p = P!ll
proof
  assume p is atomic;
  then consider
  k being Element of NAT, P being (QC-pred_symbol of k), ll being
  QC-variable_list of k such that
A1: p = P!ll by QC_LANG1:def 17;
A2: { ll.m : 1 <= m & m <= len ll & ll.m in fixed_QC-variables } = {} by A1,
  CQC_LANG:17;
  { ll.i : 1 <= i & i <= len ll & ll.i in free_QC-variables } = {} by A1,
  CQC_LANG:17;
  then ll is CQC-variable_list of k by A2,CQC_LANG:15;
  hence thesis by A1;
end;

theorem
  p is negative implies ex q st p = 'not' q
proof
  assume p is negative;
  then consider r being Element of QC-WFF such that
A1: p = 'not' r by QC_LANG1:def 18;
  r is Element of CQC-WFF by A1,CQC_LANG:18;
  hence thesis by A1;
end;

theorem
  p is conjunctive implies ex q,r st p = q '&' r
proof
  assume p is conjunctive;
  then consider q, r being Element of QC-WFF such that
A1: p = q '&' r by QC_LANG1:def 19;
A2: r is Element of CQC-WFF by A1,CQC_LANG:19;
  q is Element of CQC-WFF by A1,CQC_LANG:19;
  hence thesis by A1,A2;
end;

theorem
  p is universal implies ex x,q st p = All(x,q)
proof
  assume p is universal;
  then consider x being bound_QC-variable, q being Element of QC-WFF such that
A1: p = All(x,q) by QC_LANG1:def 20;
  q is Element of CQC-WFF by A1,CQC_LANG:23;
  hence thesis by A1;
end;

theorem Th9:
  for l being FinSequence holds rng l = { l.i : 1 <= i & i <= len l }
proof
  let l be FinSequence;
  thus rng l c= { l.i : 1 <= i & i <= len l }
  proof
    let a;
    assume a in rng l;
    then consider x being set such that
A1: x in dom l and
A2: a = l.x by FUNCT_1:def 5;
    reconsider k = x as Element of NAT by A1;
A3: k <= len l by A1,FINSEQ_3:27;
    1 <= k by A1,FINSEQ_3:27;
    hence thesis by A2,A3;
  end;
  thus { l.i : 1 <= i & i <= len l } c= rng l
  proof
    let a;
    assume a in { l.i : 1 <= i & i <= len l };
    then consider k being Element of NAT such that
A4: a = l.k and
A5: 1 <= k and
A6: k <= len l;
    k in dom l by A5,A6,FINSEQ_3:27;
    hence thesis by A4,FUNCT_1:def 5;
  end;
end;

scheme
  QCFuncExN { D() -> non empty set, V() -> Element of D(), A(set) -> Element
of D(), N(set,set) -> Element of D(), C(set,set,set) -> Element of D(), Q(set,
set) -> Element of D()} : ex F being Function of QC-WFF, D() st F.VERUM = V() &
  for p being Element of QC-WFF holds (p is atomic implies F.p = A(p)) & (p is
negative implies F.p = N(F.the_argument_of p,p)) & (p is conjunctive implies F.
  p = C(F.the_left_argument_of p, F.the_right_argument_of p, p)) & (p is
  universal implies F.p = Q(F.the_scope_of p, p)) proof
  defpred Pfn[Function of QC-WFF, D(), Nat] means for p being Element of
  QC-WFF st len @p <= $2 holds (p = VERUM implies $1.p = V()) & (p is atomic
implies $1.p = A(p)) & (p is negative implies $1.p = N($1.the_argument_of p, p)
  ) & (p is conjunctive implies $1.p = C($1.the_left_argument_of p, $1.
the_right_argument_of p, p)) & (p is universal implies $1.p = Q($1.the_scope_of
  p, p));
  defpred Pfgp[Element of D(), Function of QC-WFF, D(), Element of QC-WFF]
  means ($3 = VERUM implies $1 = V()) & ($3 is atomic implies $1 = A($3)) & ($3
  is negative implies $1 = N($2.the_argument_of $3, $3)) & ($3 is conjunctive
implies $1 = C($2.the_left_argument_of $3, $2.the_right_argument_of $3, $3)) &
  ($3 is universal implies $1 = Q($2.the_scope_of $3,$3));
  defpred S[Element of NAT] means ex F being Function of QC-WFF, D() st Pfn[F,
  $1];
A1: for n be Element of NAT st S[n] holds S[n+1]
  proof
    let n be Element of NAT;
    given F being Function of QC-WFF, D() such that
A2: Pfn[F, n];
    defpred P[Element of QC-WFF,Element of D()] means (len @$1 <> n+1 implies
    $2 = F.$1) & (len @$1 = n+1 implies Pfgp[$2, F, $1]);
A3: for x being Element of QC-WFF ex y being Element of D() st P[x,y]
    proof
      let p be Element of QC-WFF;
      now
        per cases by QC_LANG1:33;
        case
          len @p <> n+1;
          take y = F.p;
          thus y =F.p;
        end;
        case
A4:       len @p = n+1 & p = VERUM;
          take y = V();
          thus Pfgp[y, F, p] by A4,QC_LANG1:51;
        end;
        case
A5:       len @p = n+1 & p is atomic;
          take y = A(p);
          thus Pfgp[y, F, p] by A5,QC_LANG1:51;
        end;
        case
A6:       len @p = n+1 & p is negative;
          take y = N(F.the_argument_of p, p);
          thus Pfgp[y, F, p] by A6,QC_LANG1:51;
        end;
        case
A7:       len @p = n+1 & p is conjunctive;
          take y = C(F.the_left_argument_of p, F.the_right_argument_of p, p);
          thus Pfgp[y, F, p] by A7,QC_LANG1:51;
        end;
        case
A8:       len @p = n+1 & p is universal;
          take y = Q(F.the_scope_of p, p);
          thus Pfgp[y, F, p] by A8,QC_LANG1:51;
        end;
      end;
      hence thesis;
    end;
    consider G being Function of QC-WFF, D() such that
A9: for p being Element of QC-WFF holds P[p,G.p] from FUNCT_2:sch 3 (
    A3);
    take H = G;
    thus Pfn[H, n+1]
    proof
      let p be Element of QC-WFF such that
A10:  len @p <= n+1;
      thus p = VERUM implies H.p = V()
      proof
        now
          per cases;
          suppose
A11:        len @p <> n+1;
            then
A12:        H.p = F.p by A9;
            len @p <= n by A10,A11,NAT_1:8;
            hence thesis by A2,A12;
          end;
          suppose
            len @p = n+1;
            hence thesis by A9;
          end;
        end;
        hence thesis;
      end;
      thus p is atomic implies H.p = A(p)
      proof
        now
          per cases;
          suppose
A13:        len @p <> n+1;
            then
A14:        H.p = F.p by A9;
            len @p <= n by A10,A13,NAT_1:8;
            hence thesis by A2,A14;
          end;
          suppose
            len @p = n+1;
            hence thesis by A9;
          end;
        end;
        hence thesis;
      end;
      thus p is negative implies H.p = N(H.the_argument_of p,p)
      proof
        assume
A15:    p is negative;
        then len @the_argument_of p <> n+1 by A10,QC_LANG1:45;
        then
A16:    H.the_argument_of p = F.the_argument_of p by A9;
        now
          per cases;
          suppose
A17:        len @p <> n+1;
            then
A18:        H.p = F.p by A9;
            len @p <= n by A10,A17,NAT_1:8;
            hence thesis by A2,A15,A16,A18;
          end;
          suppose
            len @p = n+1;
            hence thesis by A9,A15,A16;
          end;
        end;
        hence thesis;
      end;
      thus p is conjunctive implies H.p = C(H.the_left_argument_of p, H.
      the_right_argument_of p, p)
      proof
        assume
A19:    p is conjunctive;
        then len @the_right_argument_of p <> n+1 by A10,QC_LANG1:46;
        then
A20:    H.the_right_argument_of p = F.the_right_argument_of p by A9;
        len @the_left_argument_of p <> n+1 by A10,A19,QC_LANG1:46;
        then
A21:    H.the_left_argument_of p = F.the_left_argument_of p by A9;
        now
          per cases;
          suppose
A22:        len @p <> n+1;
            then
A23:        H.p = F.p by A9;
            len @p <= n by A10,A22,NAT_1:8;
            hence thesis by A2,A19,A21,A20,A23;
          end;
          suppose
            len @p = n+1;
            hence thesis by A9,A19,A21,A20;
          end;
        end;
        hence thesis;
      end;
      thus p is universal implies H.p = Q(H.the_scope_of p, p)
      proof
        assume
A24:    p is universal;
        then len @the_scope_of p <> n+1 by A10,QC_LANG1:47;
        then
A25:    H.the_scope_of p = F.the_scope_of p by A9;
        now
          per cases;
          suppose
A26:        len @p <> n+1;
            then
A27:        H.p = F.p by A9;
            len @p <= n by A10,A26,NAT_1:8;
            hence thesis by A2,A24,A25,A27;
          end;
          suppose
            len @p = n+1;
            hence thesis by A9,A24,A25;
          end;
        end;
        hence thesis;
      end;
    end;
  end;
  defpred Qfn[set, set] means ex p being Element of QC-WFF st p = $1 & for g
  being Function of QC-WFF, D() st Pfn[g, len @p] holds $2 = g.p;
A28: S[0]
  proof
    set F =the  Function of QC-WFF, D();
    take F;
    thus thesis by QC_LANG1:34;
  end;
A29: for n being Element of NAT holds S[n] from NAT_1:sch 1 (A28, A1);
A30: for x being set st x in QC-WFF ex y being set st Qfn[x, y]
  proof
    let x be set;
    assume x in QC-WFF;
    then reconsider x9 = x as Element of QC-WFF;
    consider F being Function of QC-WFF, D() such that
A31: Pfn[F, len @x9] by A29;
    take F.x, x9;
    thus x = x9;
    let G be Function of QC-WFF, D() such that
A32: Pfn[G, len @x9];
    defpred Prop[Element of QC-WFF] means len @$1 <= len@x9 implies F.$1 = G.
    $1;
A33: now
      let p be Element of QC-WFF;
      thus p is atomic implies Prop[p]
      proof
        assume that
A34:    p is atomic and
A35:    len @p <= len@x9;
        thus F.p = A(p) by A31,A34,A35
          .= G.p by A32,A34,A35;
      end;
      thus Prop[VERUM]
      proof
        assume
A36:    len @VERUM <= len @x9;
        hence F.VERUM = V() by A31
          .= G.VERUM by A32,A36;
      end;
      thus p is negative & Prop[the_argument_of p] implies Prop[p]
      proof
        assume that
A37:    p is negative and
A38:    Prop[the_argument_of p] and
A39:    len @p <= len @x9;
        len @the_argument_of p < len @p by A37,QC_LANG1:45;
        hence F.p = N(G.the_argument_of p, p) by A31,A37,A38,A39, XXREAL_0:
        2
          .= G.p by A32,A37,A39;
      end;
      thus p is conjunctive & Prop[the_left_argument_of p] & Prop[
      the_right_argument_of p] implies Prop[p]
      proof
        assume that
A40:    p is conjunctive and
A41:    Prop[the_left_argument_of p] and
A42:    Prop[the_right_argument_of p] and
A43:    len @p <= len @x9;
A44:    len @the_right_argument_of p < len @p by A40,QC_LANG1:46;
        len @the_left_argument_of p < len @p by A40,QC_LANG1:46;
        hence F.p = C(G.the_left_argument_of p, G.the_right_argument_of p, p)
        by A31,A40,A41,A42,A43,A44,XXREAL_0:2
          .= G.p by A32,A40,A43;
      end;
      thus p is universal & Prop[the_scope_of p] implies Prop[p]
      proof
        assume that
A45:    p is universal and
A46:    Prop[the_scope_of p] and
A47:    len @p <= len @x9;
        len @the_scope_of p < len @p by A45,QC_LANG1:47;
        hence F.p = Q(G.the_scope_of p, p) by A31,A45,A46,A47, XXREAL_0
        :2
          .= G.p by A32,A45,A47;
      end;
    end;
    for p being Element of QC-WFF holds Prop[p] from QC_LANG1:sch 2 (A33
    );
    hence thesis;
  end;
  consider F being Function such that
A48: dom F = QC-WFF and
A49: for x being set st x in QC-WFF holds Qfn[x, F.x] from CLASSES1:sch
  1 (A30);
  rng F c= D()
  proof
    let y be set;
    assume y in rng F;
    then consider x being set such that
A50: x in QC-WFF and
A51: y = F.x by A48,FUNCT_1:def 5;
    consider p being Element of QC-WFF such that
    p = x and
A52: for g being Function of QC-WFF, D() st Pfn[g, len @p] holds y =
    g.p by A49,A50,A51;
    consider G being Function of QC-WFF, D() such that
A53: Pfn[G, len @p] by A29;
    y = G.p by A52,A53;
    hence thesis;
  end;
  then reconsider F as Function of QC-WFF, D() by A48,FUNCT_2:def 1 ,RELSET_1
  :11;
  consider p1 being Element of QC-WFF such that
A54: p1 = VERUM and
A55: for g being Function of QC-WFF, D() st Pfn[g, len @p1] holds F.
  VERUM = g.p1 by A49;
  take F;
  consider G being Function of QC-WFF, D() such that
A56: Pfn[G, len @p1] by A29;
  F.VERUM = G.VERUM by A54,A55,A56;
  hence F.VERUM = V() by A54,A56;
  let p be Element of QC-WFF;
  consider p1 being Element of QC-WFF such that
A57: p1 = p and
A58: for g being Function of QC-WFF, D() st Pfn[g, len @p1] holds F.p =
  g.p1 by A49;
  consider G being Function of QC-WFF, D() such that
A59: Pfn[G, len @p1] by A29;
  set p9 = the_scope_of p;
A60: ex p1 being Element of QC-WFF st p1 = p9 & for g being Function of
  QC-WFF, D() st Pfn[g, len @p1] holds F.p9 = g.p1 by A49;
A61: F.p = G.p by A57,A58,A59;
  hence p is atomic implies F.p = A(p) by A57,A59;
A62: for k being Element of NAT st k < len @p holds Pfn[G, k]
  proof
    let k be Element of NAT;
    assume
A63: k < len @p;
    let p9 be Element of QC-WFF;
    assume len @p9 <= k;
    then len @p9 <= len@p by A63,XXREAL_0:2;
    hence thesis by A57,A59;
  end;
  thus p is negative implies F.p = N(F.the_argument_of p, p)
  proof
    set p9 = the_argument_of p;
    set k = len @p9;
A64: ex p1 being Element of QC-WFF st p1 = p9 & for g being Function of
    QC-WFF, D() st Pfn[g, len @p1] holds F.p9 = g.p1 by A49;
    assume
A65: p is negative;
    then k < len @p by QC_LANG1:45;
    then Pfn[G, k] by A62;
    then F.p9 = G.p9 by A64;
    hence thesis by A57,A59,A61,A65;
  end;
  thus p is conjunctive implies F.p = C(F.the_left_argument_of p, F.
  the_right_argument_of p, p)
  proof
    set p99 = the_right_argument_of p;
    set p9 = the_left_argument_of p;
    set k9 = len @p9;
    set k99 = len @p99;
A66: ex p2 being Element of QC-WFF st p2 = p99 & for g being Function of
    QC-WFF, D() st Pfn[g, len @p2] holds F.p99 = g.p2 by A49;
    assume
A67: p is conjunctive;
    then k9 < len @p by QC_LANG1:46;
    then
A68: Pfn[G, k9] by A62;
    k99 < len @p by A67,QC_LANG1:46;
    then Pfn[G, k99] by A62;
    then
A69: F.p99 = G.p99 by A66;
    ex p1 being Element of QC-WFF st p1 = p9 & for g being Function of
    QC-WFF, D() st Pfn[g, len @p1] holds F.p9 = g.p1 by A49;
    then F.p9 = G.p9 by A68;
    hence thesis by A57,A59,A61,A67,A69;
  end;
  set k = len @p9;
  assume
A70: p is universal;
  then k < len @p by QC_LANG1:47;
  then Pfn[G, k] by A62;
  then F.p9 = G.p9 by A60;
  hence thesis by A57,A59,A61,A70;
end;

scheme
  CQCF2FuncEx { D, E() -> non empty set, V() -> Element of Funcs(D(),E()), A(
set,set,set) -> Element of Funcs(D(),E()), N(set,set) -> Element of Funcs(D(),E
()), C(set,set,set,set) -> Element of Funcs(D(),E()), Q(set,set,set) -> Element
of Funcs(D(),E()) }: ex F being Function of CQC-WFF, Funcs(D(),E()) st F.VERUM
= V() & (for k for l being CQC-variable_list of k for P being QC-pred_symbol of
k holds F.(P!l) = A(k,P,l)) & for r,s,x holds F.('not' r) = N(F.r,r) & F.(r '&'
  s) = C(F.r,F.s,r,s) & F.All(x,r) = Q(x,F.r,r) proof
  deffunc q(set,Element of QC-WFF) = Q(bound_in $2,$1,the_scope_of $2);
  deffunc c(set,set,Element of QC-WFF) = C($1,$2, the_left_argument_of $3,
  the_right_argument_of $3);
  deffunc n(set,Element of QC-WFF) = N($1,the_argument_of $2);
  deffunc a(Element of QC-WFF) = A(the_arity_of the_pred_symbol_of $1,
  the_pred_symbol_of $1,the_arguments_of $1);
  consider F being Function of QC-WFF, Funcs(D(),E()) such that
A1: F.VERUM = V() & for p being Element of QC-WFF holds (p is atomic
implies F.p = a(p)) & (p is negative implies F.p = n(F.the_argument_of p,p)) &
  (p is conjunctive implies F.p = c(F.the_left_argument_of p,F.
the_right_argument_of p,p)) & (p is universal implies F.p = q(F.the_scope_of p,
  p)) from QCFuncExN;
  reconsider G = F|CQC-WFF as Function of CQC-WFF,Funcs(D(),E()) by FUNCT_2:38;
  take G;
  thus G.VERUM = V() by A1,FUNCT_1:72;
  thus for k for l being CQC-variable_list of k for P being QC-pred_symbol of
  k holds G.(P!l) = A(k,P,l)
  proof
    let k;
    let l be CQC-variable_list of k;
    let P be QC-pred_symbol of k;
A2: the_arity_of P = k by QC_LANG1:35;
A3: P!l is atomic by QC_LANG1:def 17;
    then
A4: the_arguments_of (P!l) = l by QC_LANG1:def 22;
A5: the_pred_symbol_of (P!l) = P by A3,QC_LANG1:def 21;
    thus G.(P!l) = F.(P!l) by FUNCT_1:72
      .= A(k,P,l) by A1,A3,A4,A5,A2;
  end;
  let r,s,x;
  set r9 = G.r, s9 = G.s;
A6: r9 = F.r by FUNCT_1:72;
A7: 'not' r is negative by QC_LANG1:def 18;
  then
A8: the_argument_of 'not' r = r by QC_LANG1:def 23;
  thus G.('not' r) = F.('not' r) by FUNCT_1:72
    .= N(r9,r) by A1,A6,A7,A8;
A9: s9 = F.s by FUNCT_1:72;
A10: r '&' s is conjunctive by QC_LANG1:def 19;
  then
A11: the_left_argument_of(r '&' s) = r by QC_LANG1:def 24;
A12: the_right_argument_of(r '&' s) = s by A10,QC_LANG1:def 25;
  thus G.(r '&' s) = F.(r '&' s) by FUNCT_1:72
    .= C(r9,s9,r,s) by A1,A6,A9,A10,A11,A12;
A13: All(x,r) is universal by QC_LANG1:def 20;
  then
A14: bound_in All(x,r) = x by QC_LANG1:def 26;
A15: the_scope_of All(x,r) = r by A13,QC_LANG1:def 27;
  thus G.All(x,r) = F.All(x,r) by FUNCT_1:72
    .= Q(x,r9,r) by A1,A6,A13,A14,A15;
end;

scheme
  CQCF2FUniq { D, E() -> non empty set, F1, F2() -> Function of CQC-WFF,Funcs(
D(),E()), V() -> Function of D(),E(), A(set,set,set) -> Function of D(),E(), N(
set,set) -> Function of D(),E(), C(set,set,set,set) -> Function of D(),E(), Q(
  set,set,set) -> Function of D(),E() }: F1() = F2()
provided
A1: F1().VERUM = V() and
A2: for k,ll,P holds F1().(P!ll) = A(k,P,ll) and
A3: for r,s,x holds F1().('not' r) = N(F1().r,r) & F1().(r '&' s) = C(F1
().r,F1().s,r,s) & F1().All(x,r) = Q(x,F1().r,r) and
A4: F2().VERUM = V() and
A5: for k,ll,P holds F2().(P!ll) = A(k,P,ll) and
A6: for r,s,x holds F2().('not' r) = N(F2().r,r) & F2().(r '&' s) = C(F2
().r,F2().s,r,s) & F2().All(x,r) = Q(x,F2().r,r)
proof
  defpred P[set] means F1().$1 = F2().$1;
A7: for r,s,x,k,ll,P holds P[VERUM] & P[P!ll] & (P[r] implies P['not' r]) &
  (P[r] & P[s] implies P[r '&' s]) & (P[r] implies P[All(x, r)])
  proof
    let r,s,x,k,ll,P;
    thus F1().VERUM = F2().VERUM by A1,A4;
    F1().(P!ll) = A(k,P,ll) by A2;
    hence F1().(P!ll) = F2().(P!ll) by A5;
    F1().('not' r) = N(F1().r,r) by A3;
    hence F1().r = F2().r implies F1().('not' r) = F2().('not' r) by A6;
    F1().(r '&' s) = C(F1().r,F1().s,r,s) by A3;
    hence F1().r = F2().r & F1().s = F2().s implies F1().(r '&' s) = F2().(r
    '&' s) by A6;
    F1().All(x,r) = Q(x,F1().r,r) by A3;
    hence thesis by A6;
  end;
  P[r] from CQC_LANG:sch 1(A7);
  hence thesis by FUNCT_2:113;
end;

theorem Th10:
  p is_subformula_of 'not' p
proof
  p is_proper_subformula_of 'not' p by QC_LANG2:86;
  hence thesis by QC_LANG2:def 22;
end;

theorem Th11:
  p is_subformula_of p '&' q & q is_subformula_of p '&' q
proof
A1: q is_proper_subformula_of p '&' q by QC_LANG2:89;
  p is_proper_subformula_of p '&' q by QC_LANG2:89;
  hence thesis by A1,QC_LANG2:def 22;
end;

theorem Th12:
  p is_subformula_of All(x,p)
proof
  p is_proper_subformula_of All(x,p) by QC_LANG2:91;
  hence thesis by QC_LANG2:def 22;
end;

theorem Th13:
  for l being CQC-variable_list of k, i st 1<=i & i<=len l holds l
  .i in bound_QC-variables
proof
  let l be CQC-variable_list of k, i;
  assume that
A1: 1<=i and
A2: i<=len l;
  i in dom l by A1,A2,FINSEQ_3:27;
  then
A3: l.i in rng l by FUNCT_1:def 5;
  rng l c= bound_QC-variables by RELAT_1:def 19;
  hence thesis by A3;
end;

definition
  let D be non empty set, f be Function of D, CQC-WFF;
  func NEGATIVE f -> Element of Funcs(D, CQC-WFF) means
  :Def1:
  for a being
  Element of D for p being Element of CQC-WFF st p=f.a holds it.a = 'not' p;
  existence
  proof
    defpred P[set,set] means for p being Element of CQC-WFF st p=f.$1 holds $2
    = 'not' p;
A1: for e being Element of D ex u being Element of CQC-WFF st P[e,u]
    proof
      let e be Element of D;
      reconsider p = f.e as Element of CQC-WFF;
      take 'not' p;
      thus thesis;
    end;
    consider F being Function of D,CQC-WFF such that
A2: for e being Element of D holds P[e,F.e] from FUNCT_2:sch 3(A1);
    F is Element of Funcs(D,CQC-WFF) by FUNCT_2:11;
    hence thesis by A2;
  end;
  uniqueness
  proof
    let F,G be Element of Funcs(D,CQC-WFF);
    assume
A3: for a being Element of D holds for p being Element of CQC-WFF st p
    =f.a holds F.a = 'not' p;
    assume
A4: for a being Element of D holds for p being Element of CQC-WFF st p
    =f.a holds G.a = 'not' p;
    for a being Element of D holds F.a = G.a
    proof
      let a be Element of D;
      consider p such that
A5:   p=f.a;
      thus F.a = 'not' p by A3,A5
        .=G.a by A4,A5;
    end;
    hence F=G by FUNCT_2:113;
  end;
end;

reserve f,h for Element of Funcs(bound_QC-variables,bound_QC-variables),
  K,L for Finite_Subset of bound_QC-variables;

definition
  let f,g be Function of [:NAT,Funcs(bound_QC-variables,bound_QC-variables):],
  CQC-WFF, n be Element of NAT;
  func CON(f,g,n) -> Element of Funcs([:NAT,Funcs(bound_QC-variables,
  bound_QC-variables):], CQC-WFF) means
  :Def2:
  for k,h,p,q st p = f.(k,h) & q = g .(k+n,h) holds it.(k,h) = p '&' q;
  existence
  proof
    defpred P[Element of NAT,set,set] means for p,q st p = f.[$1,$2] & q = g.[
    $1+n,$2] holds $3 = p '&' q;
A1: for k,h ex u being Element of CQC-WFF st P[k,h,u]
    proof
      let k,h;
      reconsider p=f.([k,h]) as Element of CQC-WFF;
      reconsider q=g.([k+n,h]) as Element of CQC-WFF;
      take p '&' q;
      let p1,q1 be Element of CQC-WFF;
      assume that
A2:   p1=f.[k,h] and
A3:   q1=g.[k+n,h];
      thus thesis by A2,A3;
    end;
    consider F being Function of [:NAT,Funcs(bound_QC-variables,
    bound_QC-variables):],CQC-WFF such that
A4: for k,h holds P[k,h,F.(k,h)] from BINOP_1:sch 3(A1);
    reconsider F as Element of Funcs([:NAT,Funcs(bound_QC-variables,
    bound_QC-variables):],CQC-WFF) by FUNCT_2:11;
    take F;
    let k,h,p,q;
    assume that
A5: p = f.(k,h) and
A6: q = g.(k+n,h);
    thus thesis by A4,A5,A6;
  end;
  uniqueness
  proof
    let F,G be Element of Funcs([:NAT,Funcs(bound_QC-variables,
    bound_QC-variables):],CQC-WFF);
    assume
A7: for k,h,p,q holds p = f.(k,h) & q = g.(k+n,h) implies F.(k,h) = p '&' q;
    assume
A8: for k,h,p,q holds p = f.(k,h) & q = g.(k+n,h) implies G.(k,h) = p '&' q;
    for a being Element of [:NAT,Funcs(bound_QC-variables,
    bound_QC-variables):] holds F.a = G.a
    proof
      let a be Element of [:NAT,Funcs(bound_QC-variables,bound_QC-variables):];
      consider k being Element of NAT, h being Element of Funcs(
      bound_QC-variables,bound_QC-variables) such that
A9:   a=[k,h] by DOMAIN_1:9;
      reconsider q=g.(k+n,h) as Element of CQC-WFF;
      reconsider p=f.(k,h) as Element of CQC-WFF;
      F.(k,h) = p '&' q by A7
        .=G.(k,h) by A8;
      hence thesis by A9;
    end;
    hence F=G by FUNCT_2:113;
  end;
end;

Lm1: h+*(x .--> x.k) is Function of bound_QC-variables,bound_QC-variables
proof
A1: rng (h+*(x .--> x.k)) c= rng h \/ rng(x .--> x.k) by FUNCT_4:18;
A2: rng(x .--> x.k) c= bound_QC-variables by RELAT_1:def 19;
  rng h c= bound_QC-variables by RELAT_1:def 19;
  then
A3: rng h \/ rng(x .--> x.k) c= bound_QC-variables by A2,XBOOLE_1:8;
  dom (h+*(x .--> x.k)) = dom h \/ dom({x}-->x.k) by FUNCT_4:def 1
    .= dom h \/ {x} by FUNCOP_1:19
    .= bound_QC-variables \/ {x} by FUNCT_2:67
    .= bound_QC-variables by ZFMISC_1:46;
  hence thesis by A1,A3,FUNCT_2:4,XBOOLE_1:1;
end;

definition
  let f be Function of [:NAT,Funcs(bound_QC-variables,bound_QC-variables):],
  CQC-WFF, x be bound_QC-variable;
  func UNIVERSAL(x,f) -> Element of Funcs([:NAT,Funcs(bound_QC-variables,
  bound_QC-variables):],CQC-WFF) means
  :Def3:
  for k,h,p st p = f.(k+1,h +* (x .--> x.k)) holds it.(k,h) = All(x.k,p);
  existence
  proof
    defpred P[Element of NAT, Element of Funcs(bound_QC-variables,
bound_QC-variables),set] means for p st p=f.[$1+1,$2+*({x} --> x.$1)] holds $3=
    All(x.$1,p);
A1: for k,h ex u being Element of CQC-WFF st P[k,h,u]
    proof
      let k,h;
      reconsider h2=h+*(x .--> x.k) as Function of bound_QC-variables,
      bound_QC-variables by Lm1;
      reconsider h2 as Element of Funcs(bound_QC-variables,bound_QC-variables)
      by FUNCT_2:11;
      reconsider q=f.([k+1,h2]) as Element of CQC-WFF;
      take All(x.k,q);
      thus thesis;
    end;
    consider F being Function of [:NAT,Funcs(bound_QC-variables,
    bound_QC-variables):],CQC-WFF such that
A2: for k,h holds P[k,h,F.(k,h)] from BINOP_1:sch 3(A1);
    reconsider F as Element of Funcs([:NAT,Funcs(bound_QC-variables,
    bound_QC-variables):],CQC-WFF) by FUNCT_2:11;
    take F;
    let k,h,p;
    assume p=f.(k+1,h+*(x .--> x.k));
    hence thesis by A2;
  end;
  uniqueness
  proof
    let F,G be Element of Funcs([:NAT,Funcs(bound_QC-variables,
    bound_QC-variables):],CQC-WFF);
    assume
A3: for k,h,p st p = f.(k+1,h +* (x .--> x.k)) holds F.(k,h) = All(x.k ,p);
    assume
A4: for k,h,p st p = f.(k+1,h +* (x .--> x.k)) holds G.(k,h) = All(x.k ,p);
    for a being Element of [:NAT,Funcs(bound_QC-variables,
    bound_QC-variables):] holds F.a = G.a
    proof
      let a be Element of [:NAT,Funcs(bound_QC-variables,bound_QC-variables):];
      consider k being Element of NAT, h being Element of Funcs(
      bound_QC-variables,bound_QC-variables) such that
A5:   a=[k,h] by DOMAIN_1:9;
      reconsider h2=h+*(x .--> x.k) as Function of bound_QC-variables,
      bound_QC-variables by Lm1;
      reconsider h2 as Element of Funcs(bound_QC-variables,bound_QC-variables)
      by FUNCT_2:11;
      reconsider p=f.(k+1,h2) as Element of CQC-WFF;
      F.(k,h) = All(x.k,p) by A3
        .= G.(k,h) by A4;
      hence thesis by A5;
    end;
    hence F=G by FUNCT_2:113;
  end;
end;

Lm2: for f being CQC-variable_list of k holds f is FinSequence of
bound_QC-variables
proof
  let f be CQC-variable_list of k;
  rng f c= bound_QC-variables by RELAT_1:def 19;
  hence thesis by FINSEQ_1:def 4;
end;

definition
  let k;
  let l be CQC-variable_list of k;
  let f be Element of Funcs(bound_QC-variables,bound_QC-variables);
  redefine func f*l -> CQC-variable_list of k;
  coherence
  proof
    reconsider l9=l as FinSequence of bound_QC-variables by Lm2;
    reconsider h=f*l9 as FinSequence of bound_QC-variables by FINSEQ_2:36;
    len h = len l9 by FINSEQ_2:37
      .= k by CARD_1:def 13;
    hence thesis by CARD_1:def 13,FINSEQ_2:27;
  end;
end;

definition
  let k;
  let P be QC-pred_symbol of k, l be CQC-variable_list of k;
  func ATOMIC(P,l) -> Element of Funcs([:NAT,Funcs(bound_QC-variables,
  bound_QC-variables):], CQC-WFF) means
  :Def4:
  for n,h holds it.(n,h) = P!(h*l);
  existence
  proof
    deffunc f(set,Element of Funcs(bound_QC-variables,bound_QC-variables)) = P
    !($2*l);
    consider f being Function of [:NAT,Funcs(bound_QC-variables,
    bound_QC-variables):], CQC-WFF such that
A1: for n,h holds f.(n,h) = f(n,h) from BINOP_1:sch 4;
    f is Element of Funcs([:NAT,Funcs(bound_QC-variables,
    bound_QC-variables):], CQC-WFF) by FUNCT_2:11;
    hence thesis by A1;
  end;
  uniqueness
  proof
    let F,G be Element of Funcs([:NAT,Funcs(bound_QC-variables,
    bound_QC-variables):],CQC-WFF);
    assume
A2: for n,h holds F.(n,h) = P!(h*l);
    assume
A3: for n,h holds G.(n,h) = P!(h*l);
    for a being Element of [:NAT,Funcs(bound_QC-variables,
    bound_QC-variables):] holds F.a = G.a
    proof
      let a be Element of [:NAT,Funcs(bound_QC-variables,bound_QC-variables):];
      consider k being Element of NAT, f being Element of Funcs(
      bound_QC-variables,bound_QC-variables) such that
A4:   a=[k,f] by DOMAIN_1:9;
      F.(k,f) = P!(f*l) by A2
        .=G.(k,f) by A3;
      hence thesis by A4;
    end;
    hence F=G by FUNCT_2:113;
  end;
end;

deffunc A(set,set,set) = 0;
deffunc N(Element of NAT) = $1;
deffunc C(Element of NAT,Element of NAT) = $1 + $2;
deffunc Q(set,Element of NAT) = $2 + 1;

definition
  let p;
  func QuantNbr(p) -> Element of NAT means
  :Def5:
  ex F being Function of
  CQC-WFF, NAT st it = F.p & F.VERUM = 0 & for r,s,x,k for l being
CQC-variable_list of k for P being QC-pred_symbol of k holds F.(P!l) = 0 & F.(
  'not' r) = F.r & F.(r '&' s) = F.r + F.s & F.All(x,r) = F.r + 1;
  correctness
  proof
    thus (ex d being Element of NAT st ex F being Function of CQC-WFF, NAT st
d = F.p & F.VERUM = 0 & for r,s,x,k for l being CQC-variable_list of k for P
being QC-pred_symbol of k holds F.(P!l) = A(k,P,l) & F.('not' r) = N(F.r) & F.(
r '&' s) = C(F.r,F.s) & F.All(x,r) = Q(x,F.r) ) & for d1,d2 being Element of
NAT st (ex F being Function of CQC-WFF, NAT st d1 = F.p & F.VERUM = 0 & for r,s
,x,k for l being CQC-variable_list of k for P being QC-pred_symbol of k holds F
.(P!l) = A(k,P,l) & F.('not' r) = N(F.r) & F.(r '&' s) = C(F.r,F.s) & F.All(x,r
) = Q(x,F.r) ) & (ex F being Function of CQC-WFF, NAT st d2 = F.p & F.VERUM = 0
& for r,s,x,k for l being CQC-variable_list of k for P being QC-pred_symbol of
k holds F.(P!l) = A(k,P,l) & F.('not' r) = N(F.r) & F.(r '&' s) = C(F.r,F.s) &
    F.All(x,r) = Q(x,F.r) ) holds d1 = d2 from CQC_LANG:sch 4;
  end;
end;

definition
  let f be Function of CQC-WFF, Funcs([:NAT,Funcs(bound_QC-variables,
  bound_QC-variables):],CQC-WFF), x be Element of CQC-WFF;
  redefine func f.x -> Element of Funcs([:NAT,Funcs(bound_QC-variables,
  bound_QC-variables):],CQC-WFF);
  coherence
  proof
    thus f.x is Element of Funcs([:NAT,Funcs(bound_QC-variables,
    bound_QC-variables):],CQC-WFF);
  end;
end;

definition
  func SepFunc -> Function of CQC-WFF, Funcs([:NAT,Funcs(bound_QC-variables,
  bound_QC-variables):],CQC-WFF) means
  :Def6:
  it.VERUM = [:NAT,Funcs(
  bound_QC-variables,bound_QC-variables):] --> VERUM & (for k for l being
CQC-variable_list of k for P being QC-pred_symbol of k holds it.(P!l) = ATOMIC(
P,l)) & for r,s,x holds it.('not' r) = NEGATIVE(it.r) & it.(r '&' s) = CON(it.r
  ,it.s,QuantNbr(r)) & it.All(x,r) = UNIVERSAL(x,it.r);
  existence
  proof
    deffunc A(Element of NAT, QC-pred_symbol of $1, CQC-variable_list of $1) =
    ATOMIC($2,$3);
    set D = [:NAT,Funcs(bound_QC-variables,bound_QC-variables):];
    deffunc N(Function of D, CQC-WFF, set) = NEGATIVE $1;
    deffunc C(Function of D,CQC-WFF, Function of D,CQC-WFF, Element of CQC-WFF
    ,set) = CON($1,$2,QuantNbr($3));
    deffunc Q(Element of bound_QC-variables, Function of D,CQC-WFF, set) =
    UNIVERSAL($1,$2);
    reconsider V = D --> VERUM as Function of D,CQC-WFF;
    reconsider V as Element of Funcs(D,CQC-WFF) by FUNCT_2:11;
    consider F being Function of CQC-WFF,Funcs(D,CQC-WFF) such that
A1: F.VERUM = V and
A2: for k for l being CQC-variable_list of k for P being
    QC-pred_symbol of k holds F.(P!l) = A(k,P,l) and
A3: for r,s,x holds F.('not' r) = N(F.r,r) & F.(r '&' s) = C(F.r,F.s,r
    ,s) & F.All(x,r) = Q(x,F.r,r) from CQCF2FuncEx;
    take F;
    thus thesis by A1,A2,A3;
  end;
  uniqueness
  proof
    deffunc A(Element of NAT, QC-pred_symbol of $1, CQC-variable_list of $1) =
    ATOMIC($2,$3);
    set D = [:NAT,Funcs(bound_QC-variables,bound_QC-variables):];
    deffunc N(Function of D, CQC-WFF, set) = NEGATIVE $1;
    deffunc C(Function of D,CQC-WFF, Function of D,CQC-WFF, Element of CQC-WFF
    ,set) = CON($1,$2,QuantNbr($3));
    deffunc Q(Element of bound_QC-variables, Function of D,CQC-WFF, set) =
    UNIVERSAL($1,$2);
    reconsider V = D --> VERUM as Function of D,CQC-WFF;
    let F,G be Function of CQC-WFF,Funcs(D,CQC-WFF) such that
A4: F.VERUM = D --> VERUM and
A5: for k,ll,P holds F.(P!ll) = A(k,P,ll) and
A6: for r,s,x holds F.('not' r) = N(F.r,r) & F.(r '&' s) = C(F.r,F.s,r
    ,s) & F.All(x,r) = Q(x,F.r,r) and
A7: G.VERUM = D --> VERUM and
A8: for k,ll,P holds G.(P!ll) = A(k,P,ll) and
A9: for r,s,x holds G.('not' r) = N(G.r,r) & G.(r '&' s) = C(G.r,G.s,
    r,s) & G.All(x,r) = Q(x,G.r,r);
A10: G.VERUM = V by A7;
A11: F.VERUM = V by A4;
    thus F = G from CQCF2FUniq(A11,A5,A6,A10,A8,A9);
  end;
end;

definition
  let p,k,f;
  func SepFunc (p,k,f) -> Element of CQC-WFF equals
  (SepFunc.p).[k,f];
  correctness;
end;

deffunc F(Element of CQC-WFF) = QuantNbr($1);

theorem
  QuantNbr(VERUM) = 0
proof
A1: for d being Element of NAT holds d = F(p) iff ex F being Function of
  CQC-WFF, NAT st d = F.p & F.VERUM = 0 & for r,s,x,k for l being
CQC-variable_list of k for P being QC-pred_symbol of k holds F.(P!l) = A(k,P,l)
  & F.('not' r) = N(F.r) & F.(r '&' s) = C(F.r,F.s) & F.All(x,r) = Q(x,F.r) by
  Def5;
  thus F(VERUM) = 0 from CQC_LANG:sch 5(A1);
end;

theorem
  QuantNbr(P!ll) = 0
proof
A1: for d being Element of NAT holds d = F(p) iff ex F being Function of
  CQC-WFF, NAT st d = F.p & F.VERUM = 0 & for r,s,x,k for l being
CQC-variable_list of k for P being QC-pred_symbol of k holds F.(P!l) = A(k,P,l)
  & F.('not' r) = N(F.r) & F.(r '&' s) = C(F.r,F.s) & F.All(x,r) = Q(x,F.r) by
  Def5;
  thus F(P!ll) = A(k,P,ll) from CQC_LANG:sch 6(A1);
end;

theorem
  QuantNbr('not' p) = QuantNbr(p)
proof
A1: for p being Element of CQC-WFF, d being Element of NAT holds d = F(p)
iff ex F being Function of CQC-WFF, NAT st d = F.p & F.VERUM = 0 & for r,s,x,k
for l being CQC-variable_list of k for P being QC-pred_symbol of k holds F.(P!l
) = A(k,P,l) & F.('not' r) = N(F.r) & F.(r '&' s) = C(F.r,F.s) & F.All(x,r) = Q
  (x,F.r) by Def5;
  thus F('not' p) = N(F(p)) from CQC_LANG:sch 7(A1);
end;

theorem
  QuantNbr(p '&' q) = QuantNbr(p) + QuantNbr(q)
proof
A1: for p being Element of CQC-WFF, d being Element of NAT holds d = F(p)
iff ex F being Function of CQC-WFF, NAT st d = F.p & F.VERUM = 0 & for r,s,x,k
for l being CQC-variable_list of k for P being QC-pred_symbol of k holds F.(P!l
) = A(k,P,l) & F.('not' r) = N(F.r) & F.(r '&' s) = C(F.r,F.s) & F.All(x,r) = Q
  (x,F.r) by Def5;
  thus F(p '&' q) = C(F(p), F(q)) from CQC_LANG:sch 8(A1);
end;

theorem
  QuantNbr(All(x,p)) = QuantNbr(p) + 1
proof
A1: for p being Element of CQC-WFF, d being Element of NAT holds d = F(p)
iff ex F being Function of CQC-WFF, NAT st d = F.p & F.VERUM = 0 & for r,s,x,k
for l being CQC-variable_list of k for P being QC-pred_symbol of k holds F.(P!l
) = A(k,P,l) & F.('not' r) = N(F.r) & F.(r '&' s) = C(F.r,F.s) & F.All(x,r) = Q
  (x,F.r) by Def5;
  thus F(All(x,p)) = Q(x,F(p)) from CQC_LANG:sch 9(A1);
end;

canceled;

theorem Th20:
  for p being Element of QC-WFF holds still_not-bound_in p is finite
proof
  defpred P[Element of QC-WFF] means still_not-bound_in $1 is finite;
A1: for p being Element of QC-WFF holds (p is atomic implies P[p]) & P[VERUM
] & (p is negative & P[the_argument_of p] implies P[p]) & (p is conjunctive & P
  [the_left_argument_of p] & P[the_right_argument_of p] implies P[p]) & (p is
  universal & P[the_scope_of p] implies P[p])
  proof
    let p be Element of QC-WFF;
    thus p is atomic implies still_not-bound_in p is finite
    proof
      deffunc F(set) = (the_arguments_of p).$1;
      defpred B[Element of NAT] means 1 <= $1 & $1 <= len the_arguments_of p;
      defpred A[Element of NAT] means 1 <= $1 & $1 <= len the_arguments_of p &
      (the_arguments_of p).$1 in bound_QC-variables;
A2:   for k st A[k] holds B[k];
A3:   { F(k) : A[k] } c= { F(n) : B[n]} from FRAENKEL:sch 1(A2);
      assume p is atomic;
      then still_not-bound_in p = still_not-bound_in the_arguments_of p by
      QC_LANG3:8
        .= variables_in(the_arguments_of p,bound_QC-variables) by QC_LANG3:6
        .= { (the_arguments_of p).k : 1 <= k & k <= len the_arguments_of p &
      (the_arguments_of p).k in bound_QC-variables };
      then still_not-bound_in p c= rng (the_arguments_of p) by A3,Th9;
      hence thesis;
    end;
    thus still_not-bound_in VERUM is finite by QC_LANG3:7;
    thus p is negative & still_not-bound_in the_argument_of p is finite
    implies still_not-bound_in p is finite by QC_LANG3:10;
    thus p is conjunctive & still_not-bound_in the_left_argument_of p is
    finite & still_not-bound_in the_right_argument_of p is finite implies
    still_not-bound_in p is finite
    proof
      assume that
A4:   p is conjunctive and
A5:   still_not-bound_in the_left_argument_of p is finite and
A6:   still_not-bound_in the_right_argument_of p is finite;
      still_not-bound_in p = (still_not-bound_in the_left_argument_of p)
      \/ (still_not-bound_in the_right_argument_of p) by A4,QC_LANG3:13;
      hence thesis by A5,A6;
    end;
    assume that
A7: p is universal and
A8: still_not-bound_in the_scope_of p is finite;
    still_not-bound_in p = (still_not-bound_in the_scope_of p) \ {
    bound_in p} by A7,QC_LANG3:15;
    hence thesis by A8;
  end;
  thus for p being Element of QC-WFF holds P[p] from QC_LANG1:sch 2(A1 );
end;

scheme
  MaxFinDomElem {D()->non empty set, X()->set, P[set,set] }: ex x being
Element of D() st x in X() & for y being Element of D() st y in X() holds P[x,y
  ]
provided
A1: X() is finite & X() <> {} & X() c= D() and
A2: for x,y being Element of D() holds P[x,y] or P[y,x] and
A3: for x,y,z being Element of D() st P[x,y] & P[y,z] holds P[x,z]
proof
  reconsider X = X() as finite set by A1;
A4: X <> {} by A1;
  defpred R[set,set] means not $1 in X or ($2 in X & P[$1,$2]);
A5: for x,y,z being set st R[x,y] & R[y,z] holds R[x,z] by A1,A3;
A6: for x,y being set holds R[x,y] or R[y,x] by A1,A2;
  consider x being set such that
A7: x in X and
A8: for y being set st y in X holds R[x,y] from CARD_3:sch 3(A4,A6,A5);
  reconsider x as Element of D() by A1,A7;
  take x;
  thus x in X() by A7;
  let y be Element of D();
  assume y in X();
  hence thesis by A7,A8;
end;

definition
  let p;
  canceled;
  func NBI p -> Subset of NAT equals
  {k: for i st k<=i holds not x.i in
  still_not-bound_in p};
  coherence
  proof
    defpred P[Element of NAT] means for i st $1<=i holds not x.i in
    still_not-bound_in p;
    {k: P[k]} c= NAT from FRAENKEL:sch 10;
    hence thesis;
  end;
end;

registration
  let p;
  cluster NBI p -> non empty;
  coherence
  proof
    set A = {k: for i st k<=i holds not x.i in still_not-bound_in p};
    ex k st k in A
    proof
      now
        per cases;
        suppose
          still_not-bound_in p = {};
          then 0<=i implies not x.i in still_not-bound_in p;
          then
          0 in {k: for i st k<=i holds not x.i in still_not-bound_in p};
          hence thesis;
        end;
        suppose
A1:       still_not-bound_in p <> {};
          defpred P[Element of NAT] means x.$1 in still_not-bound_in p;
          defpred R[set,set] means for n st n=$2 holds x.n=$1;
A2:       {l: P[l]} c= NAT from FRAENKEL:sch 10;
A3:       for e st e in still_not-bound_in p ex b st b in NAT & R[e,b]
          proof
            let e;
            assume e in still_not-bound_in p;
            then reconsider e as bound_QC-variable;
            consider i such that
A4:         x.i = e by QC_LANG3:36;
            reconsider i as set;
            take i;
            thus thesis by A4;
          end;
          consider f being Function such that
A5:       dom f = still_not-bound_in p & rng f c= NAT and
A6:       for e st e in still_not-bound_in p holds R[e,f.e] from
          WELLORD2:sch 1(A3);
          reconsider f as Function of still_not-bound_in p, NAT by A5,FUNCT_2
          :def 1,RELSET_1:11;
A7:       now
            let y be set;
            thus y in rng f implies y in {k: x.k in still_not-bound_in p}
            proof
              assume y in rng f;
              then consider x being set such that
A8:           x in dom f and
A9:           y = f.x by FUNCT_1:def 5;
              reconsider n=f.x as Element of NAT;
              x.n in still_not-bound_in p by A5,A6,A8;
              hence thesis by A9;
            end;
            assume y in {k: x.k in still_not-bound_in p};
            then consider k such that
A10:        y=k and
A11:        x.k in still_not-bound_in p;
            reconsider a=x.k as Element of still_not-bound_in p by A11;
            reconsider n=f.a as Element of NAT;
            x.n = x.k by A6,A11;
            then n=k by ZFMISC_1:33;
            hence y in rng f by A5,A10,A11,FUNCT_1:def 5;
          end;
          set x =the  Element of still_not-bound_in p;
          reconsider x as bound_QC-variable by A1,TARSKI:def 3;
          consider i such that
A12:      x.i = x by QC_LANG3:36;
A13:      ex a st a in {k: x.k in still_not-bound_in p}
          proof
            take i;
            thus thesis by A1,A12;
          end;
          defpred R[Element of NAT,Element of NAT] means $2 <= $1;
A14:      for k,l holds R[k,l] or R[l,k];
A15:      for k,l,m st R[k,l] & R[l,m] holds R[k,m] by XXREAL_0:2;
          still_not-bound_in p is finite by Th20;
          then
A16:      {k: x.k in still_not-bound_in p} is finite & {n: x.n in
still_not-bound_in p} <> {} & {l: x.l in still_not-bound_in p} c= NAT by A13,
          A2,A7,TARSKI:2;
          consider m such that
          m in {k: x.k in still_not-bound_in p} and
A17:      for k st k in {n: x.n in still_not-bound_in p} holds R[m,k]
          from MaxFinDomElem(A16,A14,A15);
          now
            take n=m+1;
            thus n=m+1;
            let i;
            assume that
A18:        m+1<=i and
A19:        x.i in still_not-bound_in p;
            i in {l: x.l in still_not-bound_in p} by A19;
            then i<=m by A17;
            hence contradiction by A18,NAT_1:13;
          end;
          then m+1 in A;
          hence thesis;
        end;
      end;
      hence thesis;
    end;
    hence thesis;
  end;
end;

definition
  let p;
  func index p -> Element of NAT equals
  min NBI p;
  coherence;
end;

theorem Th21:
  index p = 0 iff p is closed
proof
  thus index p = 0 implies p is closed
  proof
    assume index p = 0;
    then 0 in NBI p by XXREAL_2:def 7;
    then
A1: ex k st k=0 & for i st k<=i holds not x.i in still_not-bound_in p;
    now
      set a =the  Element of still_not-bound_in p;
      assume
A2:   still_not-bound_in p <> {};
      then reconsider a as bound_QC-variable by TARSKI:def 3;
      ex i st x.i = a by QC_LANG3:36;
      hence contradiction by A1,A2;
    end;
    hence thesis by QC_LANG1:def 30;
  end;
  assume p is closed;
  then 0<=i implies not x.i in still_not-bound_in p by QC_LANG1:def 30;
  then 0 in NBI p;
  hence thesis by XXREAL_2:def 7;
end;

theorem Th22:
  x.i in still_not-bound_in p implies i < index p
proof
  assume
A1: x.i in still_not-bound_in p;
  now
    min NBI p in NBI p by XXREAL_2:def 7;
    then
A2: ex k st k = min NBI p & for i st k<=i holds not x.i in
    still_not-bound_in p;
    assume min (NBI p) <= i;
    hence contradiction by A1,A2;
  end;
  hence thesis;
end;

theorem Th23:
  index VERUM = 0 by Th21,QC_LANG3:24;

theorem Th24:
  index ('not' p) = index p
proof
  still_not-bound_in p = still_not-bound_in 'not' p by QC_LANG3:11;
  hence thesis;
end;

theorem
  index p <= index(p '&' q) & index q <= index(p '&' q)
proof
A1: still_not-bound_in(p '&' q) = (still_not-bound_in p) \/ (
  still_not-bound_in q) by QC_LANG3:14;
A2: NBI(p '&' q) c= NBI q
  proof
    let e be set;
    assume e in NBI(p '&' q);
    then consider k such that
A3: k = e and
A4: for i st k<=i holds not x.i in still_not-bound_in p '&' q;
    now
      let i;
      assume
A5:   k<=i;
      still_not-bound_in q c= still_not-bound_in p '&' q by A1,XBOOLE_1:7;
      hence not x.i in still_not-bound_in q by A4,A5;
    end;
    hence thesis by A3;
  end;
  NBI(p '&' q) c= NBI p
  proof
    let e be set;
    assume e in NBI(p '&' q);
    then consider k such that
A6: k = e and
A7: for i st k<=i holds not x.i in still_not-bound_in p '&' q;
    now
      let i;
      assume
A8:   k<=i;
      still_not-bound_in p c= still_not-bound_in p '&' q by A1,XBOOLE_1:7;
      hence not x.i in still_not-bound_in p by A7,A8;
    end;
    hence thesis by A6;
  end;
  hence thesis by A2,XXREAL_2:60;
end;

definition
  let X be set;
  redefine func id X -> Element of Funcs(X,X);
  coherence
  proof
    id X is Function of X,X;
    hence thesis by FUNCT_2:12;
  end;
end;

definition
  let p;
  func SepVar(p) -> Element of CQC-WFF equals
  SepFunc(p, index p, id(
  bound_QC-variables));
  coherence;
end;

theorem
  SepVar VERUM = VERUM
proof
  index VERUM = 0 by Th21,QC_LANG3:24;
  hence SepVar VERUM = ([:NAT,Funcs(bound_QC-variables,bound_QC-variables):]
  --> VERUM). [0,id bound_QC-variables] by Def6
    .= VERUM by FUNCOP_1:13;
end;

scheme
  CQCInd{ P[set] }: for r holds P[r]
provided
A1: P[VERUM] and
A2: for k for l being CQC-variable_list of k for P being QC-pred_symbol
of k holds P[P!l] and
A3: for r st P[r] holds P['not' r] and
A4: for r,s st P[r] & P[s] holds P[r '&' s] and
A5: for r,x st P[r] holds P[All(x, r)]
proof
A6: for r,s,x,k for l being CQC-variable_list of k for P being
QC-pred_symbol of k holds P[VERUM] & P[P!l] & (P[r] implies P['not' r]) & (P[r]
  & P[s] implies P[r '&' s]) & (P[r] implies P[All(x, r)]) by A1,A2,A3,A4,A5;
  thus for r holds P[r] from CQC_LANG:sch 1(A6);
end;

theorem Th27:
  SepVar(P!ll) = P!ll
proof
A1: dom ll = dom ll;
  rng ll c= bound_QC-variables by RELAT_1:def 19;
  then reconsider lf = ll as PartFunc of NAT,bound_QC-variables by
  A1,RELSET_1:
  11;
A2: id bound_QC-variables*lf = ll by PARTFUN1:37;
  thus SepVar (P!ll) = ATOMIC(P,ll).(index (P!ll),(id bound_QC-variables)) by
  Def6
    .= P!ll by A2,Def4;
end;

theorem
  p is atomic implies SepVar p = p
proof
  assume p is atomic;
  then ex k, P, ll st p = P!ll by Th5;
  hence thesis by Th27;
end;

theorem Th29:
  SepVar 'not' p = 'not' SepVar p
proof
  reconsider FP=SepFunc.p as Function of [:NAT,Funcs(bound_QC-variables,
  bound_QC-variables):],CQC-WFF;
  thus SepVar 'not' p = (NEGATIVE FP).[index ('not' p),id bound_QC-variables]
  by Def6
    .= (NEGATIVE FP).[index p,(id bound_QC-variables)] by Th24
    .= 'not' SepVar p by Def1;
end;

theorem
  p is negative & q = the_argument_of p implies SepVar p = 'not' SepVar q
proof
  assume that
A1: p is negative and
A2: q = the_argument_of p;
  p = 'not' q by A1,A2,QC_LANG1:def 23;
  hence thesis by Th29;
end;

definition
  let p;
  let X be Subset of [:CQC-WFF,NAT,Fin bound_QC-variables, Funcs(
  bound_QC-variables,bound_QC-variables):];
  pred X is_Sep-closed_on p means
  :Def12:
  [p,index p, {}.bound_QC-variables,id
(bound_QC-variables)] in X & (for q,k,K,f holds ['not' q,k,K,f] in X implies [q
,k,K,f] in X) & (for q,r,k,K,f holds [q '&' r,k,K,f] in X implies [q,k,K,f] in
X & [r,k+QuantNbr(q),K,f] in X) & for q,x,k,K,f st [All(x,q),k,K,f] in X holds
  [q,k+1,K \/ {x}, f+*(x .--> x.k)] in X;
end;

definition
  let p;
  func SepQuadruples p -> Subset of [:CQC-WFF,NAT,Fin bound_QC-variables,
  Funcs(bound_QC-variables,bound_QC-variables):] means
  :Def13:
  it
is_Sep-closed_on p & for D being Subset of [:CQC-WFF,NAT,Fin bound_QC-variables
, Funcs(bound_QC-variables,bound_QC-variables):] st D is_Sep-closed_on p holds
  it c= D;
  existence
  proof
    set S = [:CQC-WFF,NAT,Fin bound_QC-variables, Funcs(bound_QC-variables,
    bound_QC-variables):];
    set A = { X where X is Subset of S : X is_Sep-closed_on p };
    A c= bool S
    proof
      let a;
      assume a in A;
      then ex X being Subset of S st X = a & X is_Sep-closed_on p;
      hence thesis;
    end;
    then reconsider A as Subset-Family of S;
    take X = meet A;
    set B=[#](S);
    B is_Sep-closed_on p
    proof
      thus [p,index p,{}.bound_QC-variables,id(bound_QC-variables)] in B by
      MCART_1:84;
      thus for q,k,K,f holds ['not' q,k,K,f] in B implies [q,k,K,f] in B by
      MCART_1:84;
      thus for q,r,k,K,f holds [q '&' r,k,K,f] in B implies [q,k,K,f] in B & [
      r,k+QuantNbr(q),K,f] in B by MCART_1:84;
      let q,x,k,K,f such that
      [All(x,q),k,K,f] in B;
A1:   rng (f+*(x .--> x.k)) c= rng f \/ rng (x .--> x.k) by FUNCT_4:18;
A2:   rng (x .--> x.k) = {x.k} by FUNCOP_1:14;
A3:   bound_QC-variables \/ {x.k} = bound_QC-variables by ZFMISC_1:46;
      rng f c= bound_QC-variables by RELAT_1:def 19;
      then rng f \/ rng(x .--> x.k) c= bound_QC-variables by A2,A3,
      XBOOLE_1:9;
      then
A4:   rng (f+*(x .--> x.k)) c= bound_QC-variables by A1,XBOOLE_1:1;
      dom(f+*(x .--> x.k)) = dom f \/ dom (x .--> x.k) by FUNCT_4:def 1
        .= bound_QC-variables \/ dom(x .--> x.k) by FUNCT_2:def 1
        .= bound_QC-variables \/ {x} by FUNCOP_1:19
        .= bound_QC-variables by ZFMISC_1:46;
      then f+*(x .--> x.k) is Function of bound_QC-variables,
      bound_QC-variables by A4,FUNCT_2:def 1 ,RELSET_1:11;
      then reconsider
      ff = f+*(x .--> x.k) as Element of Funcs(bound_QC-variables,
      bound_QC-variables) by FUNCT_2:11;
      [q,k+1,K \/ {.x .}, ff] in B by MCART_1:84;
      hence thesis;
    end;
    then
A5: B in A;
    for Y being set st Y in A holds [p,index p,{}.bound_QC-variables,id(
    bound_QC-variables)] in Y
    proof
      let Y be set;
      assume Y in A;
      then ex X being Subset of S st X = Y & X is_Sep-closed_on p;
      hence thesis by Def12;
    end;
    hence
    [p,index p, {}.bound_QC-variables,id(bound_QC-variables)] in X by A5
    ,SETFAM_1:def 1;
    thus for q,k,K,f holds ['not' q,k,K,f] in X implies [q,k,K,f] in X
    proof
      let q,k,K,f such that
A6:   ['not' q,k,K,f] in X;
      for Y being set st Y in A holds [q,k,K,f] in Y
      proof
        let Y be set;
        assume
A7:     Y in A;
        then
A8:     ex X being Subset of S st X = Y & X is_Sep-closed_on p;
        ['not' q,k,K,f] in Y by A6,A7,SETFAM_1:def 1;
        hence thesis by A8,Def12;
      end;
      hence thesis by A5,SETFAM_1:def 1;
    end;
    thus for q,r,k,K,f holds [q '&' r,k,K,f] in X implies [q,k,K,f] in X & [r,
    k+QuantNbr(q),K,f] in X
    proof
      let q,r,k,K,f such that
A9:   [q '&' r,k,K,f] in X;
      for Y being set st Y in A holds [q,k,K,f] in Y
      proof
        let Y be set;
        assume
A10:    Y in A;
        then
A11:    ex X being Subset of S st X = Y & X is_Sep-closed_on p;
        [q '&' r,k,K,f] in Y by A9,A10,SETFAM_1:def 1;
        hence thesis by A11,Def12;
      end;
      hence [q,k,K,f] in X by A5,SETFAM_1:def 1;
      for Y being set st Y in A holds [r,k+QuantNbr(q),K,f] in Y
      proof
        let Y be set;
        assume
A12:    Y in A;
        then
A13:    ex X being Subset of S st X = Y & X is_Sep-closed_on p;
        [q '&' r,k,K,f] in Y by A9,A12,SETFAM_1:def 1;
        hence thesis by A13,Def12;
      end;
      hence thesis by A5,SETFAM_1:def 1;
    end;
    thus for q,x,k,K,f st [All(x,q),k,K,f] in X holds [q,k+1,K \/ {x}, f+*(x
    .--> x.k)] in X
    proof
      let q,x,k,K,f such that
A14:  [All(x,q),k,K,f] in X;
      for Y being set st Y in A holds [q,k+1,K \/ {x},f+*(x .--> x.k)] in Y
      proof
        let Y be set;
        assume
A15:    Y in A;
        then
A16:    ex X being Subset of S st X = Y & X is_Sep-closed_on p;
        [All(x,q),k,K,f] in Y by A14,A15,SETFAM_1:def 1;
        hence thesis by A16,Def12;
      end;
      hence thesis by A5,SETFAM_1:def 1;
    end;
    let D be Subset of S;
    assume D is_Sep-closed_on p;
    then D in A;
    hence thesis by SETFAM_1:4;
  end;
  uniqueness
  proof
    let D1,D2 be Subset of [:CQC-WFF,NAT,Fin bound_QC-variables, Funcs(
    bound_QC-variables,bound_QC-variables):];
    assume that
A17: D1 is_Sep-closed_on p and
A18: for D being Subset of [:CQC-WFF,NAT,Fin bound_QC-variables, Funcs
(bound_QC-variables,bound_QC-variables):] st D is_Sep-closed_on p holds D1 c= D
    and
A19: D2 is_Sep-closed_on p and
A20: for D being Subset of [:CQC-WFF,NAT,Fin bound_QC-variables, Funcs
(bound_QC-variables,bound_QC-variables):] st D is_Sep-closed_on p holds D2 c= D
    ;
    thus D1 c= D2 & D2 c= D1 by A17,A18,A19,A20;
  end;
end;

theorem Th31:
  [p,index p,{}.bound_QC-variables,id(bound_QC-variables)] in SepQuadruples(p)
proof
  SepQuadruples(p) is_Sep-closed_on p by Def13;
  hence thesis by Def12;
end;

theorem Th32:
  for q,k,K,f st ['not' q,k,K,f] in SepQuadruples p holds [q,k,K,f
  ] in SepQuadruples p
proof
  SepQuadruples(p) is_Sep-closed_on p by Def13;
  hence thesis by Def12;
end;

theorem Th33:
  for q,r,k,K,f st [q '&' r,k,K,f] in SepQuadruples p holds [q,k,K
  ,f] in SepQuadruples p & [r,k+QuantNbr(q),K,f] in SepQuadruples p
proof
  SepQuadruples(p) is_Sep-closed_on p by Def13;
  hence thesis by Def12;
end;

theorem Th34:
  for q,x,k,K,f st [All(x,q),k,K,f] in SepQuadruples p holds [q,k+
  1,K \/ {x}, f+*(x .--> x.k)] in SepQuadruples p
proof
  SepQuadruples(p) is_Sep-closed_on p by Def13;
  hence thesis by Def12;
end;

theorem Th35:
  [q,k,K,f] in SepQuadruples p implies [q,k,K,f] = [p,index p,{}.
bound_QC-variables,id bound_QC-variables] or ['not' q,k,K,f] in SepQuadruples p
or (ex r st [q '&' r, k, K,f] in SepQuadruples p) or (ex r,l st k = l+QuantNbr
  r & [r '&' q,l,K,f] in SepQuadruples p) or ex x,l,h st l+1 = k & h +*({x} -->
  x.l) = f & ([All(x,q),l,K,h] in SepQuadruples p or [All(x,q),l,K\{x},h] in
  SepQuadruples p)
proof
  assume that
A1: [q,k,K,f] in SepQuadruples p and
A2: [q,k,K,f] <> [p,index p,{}.bound_QC-variables,id bound_QC-variables] and
A3: not ['not' q,k,K,f] in SepQuadruples p and
A4: not ex r st [q '&' r, k, K,f] in SepQuadruples p and
A5: not ex r,l st k = l+QuantNbr r & [r '&' q,l,K,f] in SepQuadruples p and
A6: not ex x,l,h st l+1 = k & h +*({x} --> x.l) = f & ([All(x,q),l,K,h]
  in SepQuadruples p or [All(x,q),l,K\{x},h] in SepQuadruples p);
  reconsider Y = SepQuadruples p \ {[q,k,K,f]} as Subset of [:CQC-WFF,NAT,Fin
  bound_QC-variables, Funcs(bound_QC-variables,bound_QC-variables):];
A7: SepQuadruples(p) is_Sep-closed_on p by Def13;
A8: for q,k,K,f holds ['not' q,k,K,f] in Y implies [q,k,K,f] in Y
  proof
    let s,l,L,h;
    assume
A9: ['not' s,l,L,h] in Y;
    then s <> q or l <> k or L <> K or f <> h by A3,XBOOLE_0:def 5;
    then
A10: [s,l,L,h] <> [q,k,K,f] by MCART_1:33;
    ['not' s,l,L,h] in SepQuadruples p by A9,XBOOLE_0:def 5;
    then [s,l,L,h] in SepQuadruples p by A7,Def12;
    hence thesis by A10,ZFMISC_1:64;
  end;
A11: for q,r,k,K,f holds [q '&' r,k,K,f] in Y implies [q,k,K,f] in Y & [r,k+
  QuantNbr(q),K,f] in Y
  proof
    let s,r,l,L,h;
    assume [s '&' r,l,L,h] in Y;
    then
A12: [s '&' r,l,L,h] in SepQuadruples p by XBOOLE_0:def 5;
    then s <> q or l <> k or L <> K or f <> h by A4;
    then
A13: [s,l,L,h] <> [q,k,K,f] by MCART_1:33;
    [s,l,L,h] in SepQuadruples p by A7,A12,Def12;
    hence [s,l,L,h] in Y by A13,ZFMISC_1:64;
    r <> q or L <> K or f <> h or l+QuantNbr(s) <> k by A5,A12;
    then
A14: [r,l+QuantNbr(s),L,h] <> [q,k,K,f] by MCART_1:33;
    [r,l+QuantNbr(s),L,h] in SepQuadruples p by A7,A12,Def12;
    hence thesis by A14,ZFMISC_1:64;
  end;
A15: Y c= SepQuadruples p by XBOOLE_1:36;
A16: for q,x,k,K,f st [All(x,q),k,K,f] in Y holds [q,k+1,K \/ {x}, f+*(x
  .--> x.k)] in Y
  proof
    let s,x,l,L,h;
    assume
A17: [All(x,s),l,L,h] in Y;
    now
      assume that
A18:  not [All(x,q),l,K,h] in SepQuadruples p and
A19:  not [All(x,q),l,K\{x},h] in SepQuadruples p;
A20:  s <> q or L <> K & L <> K \ {x} by A17,A18,A19,XBOOLE_0:def 5;
      assume
A21:  s = q;
A22:  x in L or not x in L;
      assume
A23:  L \/ {x} = K;
      then K \ {x} = L \ {x} by XBOOLE_1:40;
      hence contradiction by A20,A21,A23,A22,ZFMISC_1:46,65;
    end;
    then s<>q or l+1<>k or L \/ {x} <> K or f <> h+*({x} --> x.l) by A6;
    then
A24: [s,l+1,L \/ {x}, h+*(x .--> x.l)] <> [q,k,K,f] by MCART_1:33;
    [All(x,s),l,L,h] in SepQuadruples p by A17,XBOOLE_0:def 5;
    then [s,l+1,L \/ {x}, h+*(x .--> x.l)] in SepQuadruples p by A7,
    Def12;
    hence thesis by A24,ZFMISC_1:64;
  end;
  [p,index p, {}.bound_QC-variables,id(bound_QC-variables)] in
  SepQuadruples p by A7,Def12;
  then [p,index p, {}.bound_QC-variables,id(bound_QC-variables)] in Y by A2,
  ZFMISC_1:64;
  then Y is_Sep-closed_on p by A8,A11,A16,Def12;
  then SepQuadruples p c= Y by Def13;
  then Y = SepQuadruples p by A15,XBOOLE_0:def 10;
  hence contradiction by A1,ZFMISC_1:65;
end;

scheme
  Sepregression{p()-> Element of CQC-WFF, P[set,set,set,set] }: for q,k,K,f st
  [q,k,K,f] in SepQuadruples p() holds P[q,k,K,f]
provided
A1: P[p(),index p(),{}.bound_QC-variables,id bound_QC-variables] and
A2: for q,k,K,f st ['not' q,k,K,f] in SepQuadruples p() & P['not' q,k,K,
f] holds P[q,k,K,f] and
A3: for q,r,k,K,f st [q '&' r, k, K,f] in SepQuadruples p() & P[q '&' r,
k, K,f] holds P[q,k,K,f] & P[r,k+QuantNbr(q),K,f] and
A4: for q,x,k,K,f st [All(x,q),k,K,f] in SepQuadruples p() & P[All(x,q),
k,K,f] holds P[q,k+1,K \/ {x},f+*(x .--> x.k)]
proof
  set Y = { [p,k,K,f] : P[p,k,K,f] };
  reconsider X = SepQuadruples p() /\ Y as Subset of [:CQC-WFF,NAT,Fin
  bound_QC-variables, Funcs(bound_QC-variables,bound_QC-variables):];
A5: SepQuadruples p() is_Sep-closed_on p() by Def13;
  X is_Sep-closed_on p()
  proof
A6: [p(),index p(),{}.bound_QC-variables,id bound_QC-variables] in Y by A1;
    [p(),index p(),{}.bound_QC-variables,id(bound_QC-variables)] in
    SepQuadruples p() by Th31;
    hence
    [p(),index p(), {}.bound_QC-variables,id(bound_QC-variables)] in X by
    A6,XBOOLE_0:def 4;
    thus for q,k,K,f holds ['not' q,k,K,f] in X implies [q,k,K,f] in X
    proof
      let q,k,K,f;
      assume
A7:   ['not' q,k,K,f] in X;
      then
A8:   ['not' q,k,K,f] in SepQuadruples p() by XBOOLE_0:def 4;
      ['not' q,k,K,f] in Y by A7,XBOOLE_0:def 4;
      then consider p,i,h,L such that
A9:   ['not' q,k,K,f] = [p,i,L,h] and
A10:  P[p,i,L,h];
A11:  k = i by A9,MCART_1:33;
A12:  f = h by A9,MCART_1:33;
A13:  K = L by A9,MCART_1:33;
      'not' q = p by A9,MCART_1:33;
      then P[q,k,K,f] by A2,A8,A10,A11,A13,A12;
      then
A14:  [q,k,K,f] in Y;
      [q,k,K,f] in SepQuadruples p() by A5,A8,Def12;
      hence thesis by A14,XBOOLE_0:def 4;
    end;
    thus for q,r,k,K,f holds [q '&' r,k,K,f] in X implies [q,k,K,f] in X & [r,
    k+QuantNbr(q),K,f] in X
    proof
      let q,r,k,K,f;
      assume
A15:  [q '&' r,k,K,f] in X;
      then
A16:  [q '&' r,k,K,f] in SepQuadruples p() by XBOOLE_0:def 4;
      then
A17:  [r,k+QuantNbr(q),K,f] in SepQuadruples p() by A5,Def12;
      [q '&' r,k,K,f] in Y by A15,XBOOLE_0:def 4;
      then consider p,i,h,L such that
A18:  [q '&' r,k,K,f] = [p,i,L,h] and
A19:  P[p,i,L,h];
A20:  k = i by A18,MCART_1:33;
A21:  f = h by A18,MCART_1:33;
A22:  K = L by A18,MCART_1:33;
A23:  q '&' r = p by A18,MCART_1:33;
      then P[q,k,K,f] by A3,A16,A19,A20,A22,A21;
      then
A24:  [q,k,K,f] in Y;
      P[r,k+QuantNbr(q),K,f] by A3,A16,A19,A23,A20,A22,A21;
      then
A25:  [r,k+QuantNbr(q),K,f] in Y;
      [q,k,K,f] in SepQuadruples p() by A5,A16,Def12;
      hence thesis by A24,A25,A17,XBOOLE_0:def 4;
    end;
    let q,x,k,K,f;
    assume
A26: [All(x,q),k,K,f] in X;
    then
A27: [All(x,q),k,K,f] in SepQuadruples p() by XBOOLE_0:def 4;
    f+*(x .--> x.k) is Function of bound_QC-variables, bound_QC-variables
    by Lm1;
    then reconsider
    g = f+*(x .--> x.k) as Element of Funcs(bound_QC-variables,
    bound_QC-variables) by FUNCT_2:11;
    [All(x,q),k,K,f] in Y by A26,XBOOLE_0:def 4;
    then consider p,i,h,L such that
A28: [All(x,q),k,K,f] = [p,i,L,h] and
A29: P[p,i,L,h];
A30: k = i by A28,MCART_1:33;
A31: f = h by A28,MCART_1:33;
A32: K = L by A28,MCART_1:33;
    All(x,q) = p by A28,MCART_1:33;
    then P[q,k+1,K \/ {x},g] by A4,A27,A29,A30,A32,A31;
    then
A33: [q,k+1,K \/ {.x .},f+*(x .--> x.k)] in Y;
    [q,k+1,K \/ {x},f+*(x .--> x.k)] in SepQuadruples p() by A5,A27,Def12;
    hence thesis by A33,XBOOLE_0:def 4;
  end;
  then
A34: SepQuadruples p() c= X by Def13;
  let q,k,K,f;
  assume [q,k,K,f] in SepQuadruples p();
  then [q,k,K,f] in Y by A34,XBOOLE_0:def 4;
  then consider p,i,h,L such that
A35: [q,k,K,f] = [p,i,L,h] and
A36: P[p,i,L,h];
A37: k = i by A35,MCART_1:33;
A38: K = L by A35,MCART_1:33;
  q = p by A35,MCART_1:33;
  hence thesis by A35,A36,A37,A38,MCART_1:33;
end;

theorem Th36:
  for q,k,K,f holds [q,k,K,f] in SepQuadruples p implies q is_subformula_of p
proof
  defpred P[Element of CQC-WFF,set,set,set] means $1 is_subformula_of p;
A1: now
    let q,k,K,f such that
    ['not' q,k,K,f] in SepQuadruples p;
    q is_subformula_of 'not' q by Th10;
    hence P['not' q,k,K,f] implies P[q,k,K,f] by QC_LANG2:77;
  end;
A2: now
    let q,x,k,K,f such that
    [All(x,q),k,K,f] in SepQuadruples p;
    q is_subformula_of All(x,q) by Th12;
    hence P[All(x,q),k,K,f] implies P[q,k+1,K \/ {x},f+*(x .--> x.k)] by
    QC_LANG2:77;
  end;
A3: now
    let q,r,k,K,f such that
    [q '&' r, k, K,f] in SepQuadruples p;
A4: r is_subformula_of q '&'r by Th11;
    q is_subformula_of q '&'r by Th11;
    hence P[q '&' r,k,K,f] implies P[q,k,K,f] & P[r,k+QuantNbr(q),K,f] by A4
    ,QC_LANG2:77;
  end;
A5: P[p,index p,{}.bound_QC-variables,id bound_QC-variables];
  thus for q,k,K,f st [q,k,K,f] in SepQuadruples p holds P[q,k,K,f] from
  Sepregression(A5,A1,A3,A2);
end;

theorem
  SepQuadruples VERUM = { [VERUM,0,{}.bound_QC-variables,id
  bound_QC-variables] }
proof
  now
    let x be set;
    thus x in SepQuadruples VERUM implies x = [VERUM,0,{}.bound_QC-variables,
    id bound_QC-variables]
    proof
      assume
A1:   x in SepQuadruples VERUM;
      then consider q,k,K,f such that
A2:   x = [q,k,K,f] by DOMAIN_1:31;
A3:   now
        given x,l,h such that
        l+1 = k and
        h +*({x} --> x.l) = f and
A4:     [All(x,q),l,K,h] in SepQuadruples VERUM or [All(x,q),l,K\{.x
        .},h] in SepQuadruples VERUM;
        All(x,q) is_subformula_of VERUM by A4,Th36;
        then All(x,q) = VERUM by QC_LANG2:99;
        hence contradiction by QC_LANG1:51,def 20;
      end;
A5:   now
        given r,l such that
        k = l+QuantNbr r and
A6:     [r '&' q,l,K,f] in SepQuadruples VERUM;
        r '&' q is_subformula_of VERUM by A6,Th36;
        then r '&' q = VERUM by QC_LANG2:99;
        hence contradiction by QC_LANG1:51,def 19;
      end;
A7:   now
        given r such that
A8:     [q '&' r, k, K,f] in SepQuadruples VERUM;
        q '&' r is_subformula_of VERUM by A8,Th36;
        then q '&' r = VERUM by QC_LANG2:99;
        hence contradiction by QC_LANG1:51,def 19;
      end;
      now
        assume ['not' q,k,K,f] in SepQuadruples VERUM;
        then 'not' q is_subformula_of VERUM by Th36;
        then 'not' q = VERUM by QC_LANG2:99;
        hence contradiction by QC_LANG1:51,def 18;
      end;
      hence thesis by A1,A2,A7,A5,A3,Th23,Th35;
    end;
    thus x = [VERUM,0,{}.bound_QC-variables,id bound_QC-variables] implies x
    in SepQuadruples VERUM by Th23,Th31;
  end;
  hence thesis by TARSKI:def 1;
end;

theorem
  for k for l being CQC-variable_list of k for P being QC-pred_symbol of
  k holds SepQuadruples(P!l) = { [P!l,index(P!l),{}.bound_QC-variables,id
  bound_QC-variables] }
proof
  let k;
  let l be CQC-variable_list of k;
  let P be QC-pred_symbol of k;
A1: P!l is atomic by QC_LANG1:def 17;
  now
    let x be set;
    thus x in SepQuadruples(P!l) implies x = [P!l,index(P!l),{}.
    bound_QC-variables,id bound_QC-variables]
    proof
      assume
A2:   x in SepQuadruples(P!l);
      then consider q,k,K,f such that
A3:   x = [q,k,K,f] by DOMAIN_1:31;
A4:   now
        given x,i,h such that
        i+1 = k and
        h +*({x} --> x.i) = f and
A5:     [All(x,q),i,K,h] in SepQuadruples(P!l) or [All(x,q),i,K\{.x
        .},h] in SepQuadruples(P!l);
        All(x,q) is_subformula_of P!l by A5,Th36;
        then All(x,q) = P!l by QC_LANG2:100;
        then P!l is universal by QC_LANG1:def 20;
        hence contradiction by A1,QC_LANG1:51;
      end;
A6:   now
        given r,i such that
        k = i+QuantNbr r and
A7:     [r '&' q,i,K,f] in SepQuadruples(P!l);
        r '&' q is_subformula_of P!l by A7,Th36;
        then r '&' q = P!l by QC_LANG2:100;
        then P!l is conjunctive by QC_LANG1:def 19;
        hence contradiction by A1,QC_LANG1:51;
      end;
A8:   now
        given r such that
A9:     [q '&' r, k, K,f] in SepQuadruples(P!l);
        q '&' r is_subformula_of P!l by A9,Th36;
        then q '&' r = P!l by QC_LANG2:100;
        then P!l is conjunctive by QC_LANG1:def 19;
        hence contradiction by A1,QC_LANG1:51;
      end;
      now
        assume ['not' q,k,K,f] in SepQuadruples(P!l);
        then 'not' q is_subformula_of P!l by Th36;
        then 'not' q = P!l by QC_LANG2:100;
        then P!l is negative by QC_LANG1:def 18;
        hence contradiction by A1,QC_LANG1:51;
      end;
      hence thesis by A2,A3,A8,A6,A4,Th35;
    end;
    thus x = [P!l,index(P!l),{}.bound_QC-variables,id bound_QC-variables]
    implies x in SepQuadruples(P!l) by Th31;
  end;
  hence thesis by TARSKI:def 1;
end;

theorem Th39:
  for q,k,K,f st [q,k,K,f] in SepQuadruples p holds
  still_not-bound_in q c= still_not-bound_in p \/ K
proof
  deffunc f(QC-formula) = still_not-bound_in $1;
  defpred P[QC-formula,set, set, set] means f($1) c= f(p) \/ $3;
A1: for q,k,K,f st ['not' q,k,K,f] in SepQuadruples p & P['not' q,k,K,f]
  holds P[q,k,K,f] by QC_LANG3:11;
A2: now
    let q,r,k,K,f such that
    [q '&' r, k, K,f] in SepQuadruples p and
A3: P[q '&' r,k,K,f];
A4: still_not-bound_in q '&' r = still_not-bound_in q \/
    still_not-bound_in r by QC_LANG3:14;
    then
A5: still_not-bound_in r c= still_not-bound_in q '&' r by XBOOLE_1:7;
    still_not-bound_in q c= still_not-bound_in q '&' r by A4,XBOOLE_1:7;
    hence P[q,k,K,f] & P[r,k+QuantNbr(q),K,f] by A3,A5,XBOOLE_1:1;
  end;
A6: now
    let q,x,k,K,f such that
    [All(x,q),k,K,f] in SepQuadruples p and
A7: P[All(x,q),k,K,f];
    still_not-bound_in All(x,q) = still_not-bound_in q \ {x} by QC_LANG3:
    16;
    then still_not-bound_in q c= still_not-bound_in p \/ K \/ {x} by A7,
    XBOOLE_1:44;
    hence P[q,k+1,K \/ {x},f+*(x .--> x.k)] by XBOOLE_1:4;
  end;
A8: P[p,index p,{}.bound_QC-variables,id bound_QC-variables];
  thus for q,k,K,f st [q,k,K,f] in SepQuadruples p holds P[q,k,K,f] from
  Sepregression(A8,A1,A2,A6);
end;

theorem Th40:
  [q,m,K,f] in SepQuadruples p & x.i in f.:K implies i < m
proof
  defpred P[Element of CQC-WFF,Element of NAT, Finite_Subset of
  bound_QC-variables,Function] means for i holds x.i in $4.:$3 implies i < $2;
A1: for q,k,K,f st ['not' q,k,K,f] in SepQuadruples p & P['not' q,k,K,f]
  holds P[q,k,K,f];
A2: now
    let q,r,k,K,f;
    assume [q '&' r, k, K,f] in SepQuadruples p;
    assume
A3: P[q '&' r, k, K,f];
    hence P[q,k,K,f];
    thus P[r,k+QuantNbr(q),K,f]
    proof
      let i;
A4:   k <= k + QuantNbr(q) by NAT_1:11;
      assume x.i in f.:K;
      hence thesis by A3,A4,XXREAL_0:2;
    end;
  end;
A5: now
    let q,x,k,K,f such that
    [All(x,q),k,K,f] in SepQuadruples p;
    assume
A6: P[All(x,q),k,K,f];
    thus P[q,k+1,K \/ {.x .},f+*(x .--> x.k)]
    proof
      let i;
      assume x.i in (f+*(x .--> x.k)).:(K \/ {x});
      then x.i in (f+*(x .--> x.k)).:K \/ (f+*(x .--> x.k)).: {x} by
      RELAT_1:153;
      then
A7:   x.i in (f+*(x .--> x.k)).:K or x.i in Im(f+*(x .--> x.k),x) by
      XBOOLE_0:def 3;
      (f+*(x .--> x.k)).:K c= f.:K \/ {x.k} by Th2;
      then x.i in f.:K or x.i in {x.k} by A7,Th1,XBOOLE_0:def 3;
      then i < k or x.i = x.k by A6,TARSKI:def 1;
      then i <= k by ZFMISC_1:33;
      hence thesis by NAT_1:13;
    end;
  end;
A8: P[p, index p,{}.bound_QC-variables,id bound_QC-variables] by RELAT_1:149;
  for q,k,K,f st [q,k,K,f] in SepQuadruples p holds P[q,k,K,f] from
  Sepregression(A8,A1,A2,A5);
  hence thesis;
end;

theorem
  [q,m,K,f] in SepQuadruples p implies not x.m in f.:K by Th40;

theorem Th42:
  [q,m,K,f] in SepQuadruples p & x.i in f.:still_not-bound_in p implies i < m
proof
  defpred P[Element of CQC-WFF,Element of NAT, Finite_Subset of
bound_QC-variables,Function] means for i holds x.i in $4.:still_not-bound_in p
  implies i < $2;
A1: now
    let q,r,k,K,f;
    assume [q '&' r, k, K,f] in SepQuadruples p;
    assume
A2: P[q '&' r, k, K,f];
    hence P[q,k,K,f];
    thus P[r,k+QuantNbr(q),K,f]
    proof
      let i;
A3:   k <= k + QuantNbr(q) by NAT_1:11;
      assume x.i in f.:still_not-bound_in p;
      hence thesis by A2,A3,XXREAL_0:2;
    end;
  end;
A4: P[p,index p,{}.bound_QC-variables,id bound_QC-variables]
  proof
    let i;
    assume
A5: x.i in (id bound_QC-variables).:still_not-bound_in p;
    (id bound_QC-variables).:still_not-bound_in p = still_not-bound_in p
    by FUNCT_1:162;
    hence thesis by A5,Th22;
  end;
A6: now
    let q,x,k,K,f such that
    [All(x,q),k,K,f] in SepQuadruples p;
    assume
A7: P[All(x,q),k,K,f];
    thus P[q,k+1,K \/ {.x .},f+*(x .--> x.k)]
    proof
      let i;
      assume
A8:   x.i in (f+*(x .--> x.k)).:still_not-bound_in p;
      (f+*(x .--> x.k)).:still_not-bound_in p c= f.:(still_not-bound_in p
      ) \/ {x.k} by Th2;
      then x.i in f.:still_not-bound_in p or x.i in {x.k} by
      A8, XBOOLE_0
      :def 3;
      then i < k or x.i = x.k by A7,TARSKI:def 1;
      then i <= k by ZFMISC_1:33;
      hence thesis by NAT_1:13;
    end;
  end;
A9: for q,k,K,f st ['not' q,k,K,f] in SepQuadruples p & P['not' q,k,K,f]
  holds P[q,k,K,f];
  for q,k,K,f st [q,k,K,f] in SepQuadruples p holds P[q,k,K,f] from
  Sepregression(A4,A9,A1,A6);
  hence thesis;
end;

theorem Th43:
  [q,m,K,f] in SepQuadruples p & x.i in f.:still_not-bound_in q implies i < m
proof
  assume that
A1: [q,m,K,f] in SepQuadruples p and
A2: x.i in f.:still_not-bound_in q;
  f.:still_not-bound_in q c= f.: (still_not-bound_in p \/ K) by A1,Th39,
  RELAT_1:156;
  then x.i in f.:(still_not-bound_in p \/ K) by A2;
  then x.i in f.:still_not-bound_in p \/ f.:K by RELAT_1:153;
  then x.i in f.:still_not-bound_in p or x.i in f.:K by XBOOLE_0:def 3;
  hence thesis by A1,Th40,Th42;
end;

theorem
  [q,m,K,f] in SepQuadruples p implies not x.m in f.:(still_not-bound_in
  q) by Th43;

theorem Th45:
  still_not-bound_in p = still_not-bound_in SepVar p
proof
  defpred P[Element of CQC-WFF] means for k,K,f st [$1,k,K,f] in SepQuadruples
  p holds f.:(still_not-bound_in $1) = still_not-bound_in ((SepFunc.$1 qua
Element of Funcs([:NAT,Funcs(bound_QC-variables,bound_QC-variables):], CQC-WFF)
  ). ([k,f]qua Element of [:NAT,Funcs(bound_QC-variables,bound_QC-variables):])
  qua Element of CQC-WFF);
A1: [p,index p,{}.bound_QC-variables,id bound_QC-variables] in
  SepQuadruples p by Th31;
A2: now
    let r;
    reconsider g = SepFunc.r as Function of [:NAT,Funcs(bound_QC-variables,
    bound_QC-variables):], CQC-WFF;
    assume
A3: P[r];
A4: SepFunc.('not' r) = NEGATIVE(g) by Def6;
    thus P['not' r]
    proof
      let m,K,f;
      assume ['not' r,m,K,f] in SepQuadruples p;
      then
A5:   [r,m,K,f] in SepQuadruples p by Th32;
      set mf = [m,f];
      reconsider r9 = g.mf as Element of CQC-WFF;
A6:   still_not-bound_in r9 = still_not-bound_in 'not' r9 by QC_LANG3:11;
A7:   still_not-bound_in r = still_not-bound_in 'not' r by QC_LANG3:11;
      (NEGATIVE g).mf = 'not' r9 by Def1;
      hence thesis by A4,A3,A7,A6,A5;
    end;
  end;
A8: now
    let k;
    let l be CQC-variable_list of k;
    let P be QC-pred_symbol of k;
    thus P[P!l]
    proof
      let m,K,f such that
      [P!l,m,K,f] in SepQuadruples p;
      set fl = f*l;
A9:   f.:{ l.i : 1 <= i & i <= len l & l.i in bound_QC-variables } = { (
      fl).j : 1 <= j & j <= len fl & fl.j in bound_QC-variables }
      proof
A10:    len fl = k by CARD_1:def 13
          .= len l by CARD_1:def 13;
        thus f.:{ l.i : 1 <= i & i <= len l & l.i in bound_QC-variables } c= {
        fl.j : 1 <= j & j <= len fl & fl.j in bound_QC-variables }
        proof
          let x be set;
          assume
          x in f.: { l.i : 1 <= i & i <= len l & l.i in bound_QC-variables };
          then consider y being set such that
A11:      y in dom f & y in { l.i : 1 <= i & i <= len l & l.i in
          bound_QC-variables } & x = f.y by FUNCT_1:def 12;
          consider i such that
A12:      y = l.i and
A13:      1 <= i and
A14:      i <= len l and
          l.i in bound_QC-variables by A11;
          i in dom l by A13,A14,FINSEQ_3:27;
          then
A15:      f.(l.i) = fl.i by FUNCT_1:23;
          fl.i in bound_QC-variables by A10,A13,A14,Th13;
          hence thesis by A10,A11,A12,A13,A14,A15;
        end;
        let x be set;
        assume x in {fl.i: 1 <= i & i <= len fl & fl.i in bound_QC-variables };
        then consider i such that
A16:    x = fl.i and
A17:    1 <= i and
A18:    i <= len fl and
        fl.i in bound_QC-variables;
        i in dom l by A10,A17,A18,FINSEQ_3:27;
        then
A19:    fl.i = f.(l.i) by FUNCT_1:23;
A20:    l.i in bound_QC-variables by A10,A17,A18,Th13;
        then
A21:    l.i in dom f by FUNCT_2:def 1;
        l.i in { l.j : 1 <= j & j <= len l & l.j in bound_QC-variables }
        by A10,A17,A18,A20;
        hence thesis by A16,A21,A19,FUNCT_1:def 12;
      end;
A22:  f.:still_not-bound_in (P!l) = f.:still_not-bound_in l by QC_LANG3:9
        .= f.:variables_in(l,bound_QC-variables) by QC_LANG3:6
        .= variables_in(fl,bound_QC-variables) by A9
        .= still_not-bound_in fl by QC_LANG3:6
        .= still_not-bound_in (P!fl) by QC_LANG3:9;
      ATOMIC(P,l).(m,f) = P!(f*l) by Def4;
      hence thesis by A22,Def6;
    end;
  end;
A23: now
    let r,x such that
A24: P[r];
    thus P[All(x, r)]
    proof
      reconsider g = SepFunc.r as Function of [:NAT,Funcs(bound_QC-variables,
      bound_QC-variables):], CQC-WFF;
      let m,K,f such that
A25:  [All(x,r),m,K,f] in SepQuadruples p;
A26:  [r,m+1,K \/ {.x .}, f+*(x .--> x.m)] in SepQuadruples p by A25,Th34;
      f+*(x .--> x.m) is Function of bound_QC-variables,
      bound_QC-variables by Lm1;
      then reconsider
      fm = f +* (x .--> x.m) as Element of Funcs(bound_QC-variables
      ,bound_QC-variables) by FUNCT_2:11;
      reconsider r99 = g.(m+1,fm) as Element of CQC-WFF;
A27:  UNIVERSAL(x,g).(m,f) = All(x.m,r99) by Def3;
A28:  still_not-bound_in All(x, r) = still_not-bound_in r \ {x} by
      QC_LANG3:16;
      then
A29:  not x.m in f.:(still_not-bound_in r \ {x}) by A25,Th43;
      thus f.:(still_not-bound_in All(x, r)) = fm.:(still_not-bound_in r \ {x}
      ) by A28,Th3
        .= fm.:(still_not-bound_in r) \ {x.m} by A29,Th4
        .= still_not-bound_in r99 \ {x.m} by A24,A26
        .= still_not-bound_in All(x.m,r99) by QC_LANG3:16
        .= still_not-bound_in ((SepFunc.(All(x, r)) qua Element of Funcs([:
      NAT,Funcs(bound_QC-variables,bound_QC-variables):], CQC-WFF)). ([m,f]qua
Element of [:NAT,Funcs(bound_QC-variables,bound_QC-variables):]) qua Element of
      CQC-WFF) by A27,Def6;
    end;
  end;
A30: now
    let r,s such that
A31: P[r] and
A32: P[s];
    thus P[r '&' s]
    proof
      reconsider g = SepFunc.r, h = SepFunc.s as Function of [:NAT,Funcs(
      bound_QC-variables,bound_QC-variables):], CQC-WFF;
      let m,K,f such that
A33:  [r '&' s, m, K, f] in SepQuadruples p;
      reconsider r9 = g.(m,f), s9 = h.(m+QuantNbr(r),f) as Element of CQC-WFF;
A34:  CON(g,h,QuantNbr(r)).(m,f) = r9 '&' s9 by Def2;
      [r,m,K,f] in SepQuadruples p by A33,Th33;
      then
A35:  f.:(still_not-bound_in r) = still_not-bound_in r9 by A31;
      [s,m+QuantNbr(r),K,f] in SepQuadruples p by A33,Th33;
      then
A36:  f.:(still_not-bound_in s) = still_not-bound_in s9 by A32;
      thus f.:(still_not-bound_in r '&' s) = f.:(still_not-bound_in r \/
      still_not-bound_in s) by QC_LANG3:14
        .= still_not-bound_in r9 \/ still_not-bound_in s9 by A35,A36,
      RELAT_1:153
        .= still_not-bound_in(r9 '&' s9) by QC_LANG3:14
        .= still_not-bound_in ((SepFunc.(r '&' s) qua Element of Funcs([:NAT
,Funcs(bound_QC-variables,bound_QC-variables):], CQC-WFF)). ([m,f] qua Element
of [:NAT,Funcs(bound_QC-variables,bound_QC-variables):]) qua Element of CQC-WFF
      ) by A34,Def6;
    end;
  end;
A37: SepFunc.VERUM = [:NAT,Funcs(bound_QC-variables,bound_QC-variables):] -->
  VERUM by Def6;
A38: P[VERUM]
  proof
    let k,K,f such that
    [VERUM,k,K,f] in SepQuadruples p;
    f.:still_not-bound_in VERUM = {} by QC_LANG3:7,RELAT_1:149;
    hence thesis by A37,FUNCOP_1:13,QC_LANG3:7;
  end;
A39: for q holds P[q] from CQCInd(A38,A8,A2,A30,A23);
  thus still_not-bound_in p = (id bound_QC-variables).:(still_not-bound_in p)
  by FUNCT_1:162
    .= still_not-bound_in SepVar p by A39,A1;
end;

theorem
  index p = index(SepVar p)
proof
  still_not-bound_in p = still_not-bound_in (SepVar p) by Th45;
  hence thesis;
end;

definition
  let p,q;
  pred p,q are_similar means
  :Def14:
  SepVar(p) = SepVar(q);
  reflexivity;
  symmetry;
end;

canceled 2;

theorem
  p,q are_similar & q,r are_similar implies p,r are_similar
proof
  assume that
A1: p,q are_similar and
A2: q,r are_similar;
A3: SepVar(q) = SepVar(r) by A2,Def14;
  SepVar(p) = SepVar(q) by A1,Def14;
  hence thesis by A3,Def14;
end;
