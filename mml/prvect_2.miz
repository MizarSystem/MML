:: The Product Space of Real Normed Spaces and Its Properties
::  by Noboru Endou , Yasunari Shidama and Keiichi Miyajima
::
:: Received July 9, 2007
:: Copyright (c) 2007 Association of Mizar Users

environ

 vocabularies PRE_TOPC, RLVECT_1, VECTSP_1, BINOP_1, FUNCT_1, FINSEQOP,
      ARYTM_1, RVSUM_1, EUCLID, RELAT_1, COMPLEX1, ABSVALUE, SQUARE_1, FUNCT_2,
      BOOLE, NORMSP_1, RSSPACE3, REAL_NS1, BHSP_3, SEQ_2, SEQ_1, FINSEQ_2,
      CARD_3, SETWISEO, FINSEQ_1, FUNCT_3, FUNCT_6, GROUP_2, PRVECT_1,
      PRVECT_2, ORDINAL2, ARYTM, STRUCT_0, ALGSTR_0;
 notations TARSKI, XBOOLE_0, ZFMISC_1, SUBSET_1, ORDINAL1, CARD_3, XXREAL_0,
      NUMBERS, XREAL_0, COMPLEX1, NAT_1, RELAT_1, FUNCT_1, RVSUM_1, STRUCT_0,
      ALGSTR_0, FUNCT_2, FUNCT_3, BINOP_1, REAL_1, SEQ_1, SEQ_2, RLVECT_1,
      VECTSP_1, SETWISEO, FINSEQ_1, FINSEQ_2, FINSEQOP, SQUARE_1, PRE_TOPC,
      EUCLID, PRVECT_1, NORMSP_1, RSSPACE3, LOPBAN_1, REAL_NS1;
 constructors FUNCT_3, FINSEQOP, REAL_1, SEQ_2, COMPLEX1, SQUARE_1, BINOP_2,
      SETWISEO, PRVECT_1, RSSPACE3, LOPBAN_1, REAL_NS1, SEQ_1;
 registrations FRAENKEL, STRUCT_0, FINSEQ_2, FINSEQ_1, CARD_3, RLVECT_1,
      PRVECT_1, XREAL_0, MEMBERED, NORMSP_1, REAL_NS1, ORDINAL1, FUNCT_1,
      FUNCT_2, RELAT_1, XBOOLE_0, NUMBERS, VALUED_0;
 requirements NUMERALS, BOOLE, SUBSET, ARITHM;
 definitions RLVECT_1, NORMSP_1, FINSEQ_2, EUCLID, STRUCT_0, SQUARE_1,
      ALGSTR_0;
 theorems BINOP_1, FUNCT_1, FUNCT_2, FINSEQ_1, FINSEQ_2, FINSEQ_3, FINSEQOP,
      FUNCOP_1, SETWISEO, TARSKI, CARD_3, RLVECT_1, RELAT_1, RVSUM_1, ABSVALUE,
      FVSUM_1, SEQ_1, SEQ_2, PRVECT_1, NORMSP_1, SQUARE_1, STRUCT_0, EUCLID,
      XREAL_1, LOPBAN_1, RSSPACE3, REAL_NS1, XXREAL_0;
 schemes FUNCT_1, BINOP_1, FUNCT_2, FINSEQ_1, PRVECT_1;

begin :: The Product Space of Real Linear Spaces

theorem
  for s,t be Real_Sequence, g be real number st
  for n be Element of NAT holds t.n = abs(s.n-g) holds
  (s is convergent & lim s = g) iff (t is convergent & lim t = 0)
proof
  let s,t be Real_Sequence, g be real number;
  assume
A1: for n be Element of NAT holds t.n=abs(s.n-g);
  hereby
    assume
A2: s is convergent & lim s = g;
A3: now
      let r be real number;
      assume 0 < r;
      then consider n be Element of NAT such that
A4:   for m be Element of NAT st n<=m holds abs(s.m-g) < r by A2,SEQ_2:def 7;
      take n;
      now
        let m be Element of NAT;
        assume n<=m;
        then abs (abs(s.m-g)) < r by A4;
        hence abs(t.m-0) < r by A1;
      end;
      hence for m be Element of NAT st n<=m holds abs(t.m-0)< r;
    end;
    hence t is convergent by SEQ_2:def 6;
    hence lim t = 0 by A3,SEQ_2:def 7;
  end;
  assume
A5: t is convergent & lim t = 0;
A6: now
    let r be real number;
    assume 0 < r;
    then consider n be Element of NAT such that
A7: for m be Element of NAT st n<=m holds abs(t.m-0) < r by A5,SEQ_2:def 7;
    take n;
    now
      let m be Element of NAT;
      assume n<=m;
      then abs(t.m-0) < r by A7;
      then abs(abs(s.m-g)) < r by A1;
      hence abs(s.m-g) < r;
    end;
    hence for m be Element of NAT st n <= m holds abs(s.m-g) < r;
  end;
  hence s is convergent by SEQ_2:def 6;
  hence lim s = g by A6,SEQ_2:def 7;
end;

theorem Th2:
  for x,y be FinSequence of REAL st len x = len y &
  for i be Element of NAT st i in Seg len x holds 0 <= x.i & x.i <= y.i
  holds |.x.| <= |.y.|
proof
  let x,y be FinSequence of REAL such that
A1: len x = len y &
  for i be Element of NAT st i in Seg len x holds 0 <= x.i & x.i <= y.i;
A2: for i be Nat st i in Seg len x holds (sqr x).i <= (sqr y).i
  proof
    let i be Nat;
    assume i in Seg len x;
    then
A3: 0 <= x.i & x.i <= y.i by A1;
    (x.i)^2=(sqr x).i & (y.i)^2=(sqr y).i by RVSUM_1:78;
    hence thesis by A3,SQUARE_1:77;
  end;
A4: Seg len sqr x = dom sqr x & Seg len sqr y = dom sqr y by FINSEQ_1:def 3;
  dom sqr x = dom x & dom sqr y = dom y by RVSUM_1:77;
  then
A5: len sqr x = len x & len sqr y = len y by A4,FINSEQ_1:def 3;
  sqr x is Element of (len sqr x)-tuples_on REAL &
  sqr y is Element of (len sqr y)-tuples_on REAL by FINSEQ_2:110;
  then
A6: Sum sqr x <= Sum sqr y by A1,A2,A5,RVSUM_1:112;
  0 <= Sum sqr x by RVSUM_1:116;
  hence |.x.| <= |.y.| by A6,SQUARE_1:94;
end;

theorem Th3:
  for F be FinSequence of REAL st
  for i be Element of NAT st i in dom F holds F.i = 0 holds Sum F = 0
proof
  let F be FinSequence of REAL;
  assume
A1: for i be Element of NAT st i in dom F holds 0 = F.i;
  set i = len F;
  set R1 = i|-> 0;
  reconsider R2 = F as Element of i-tuples_on REAL by FINSEQ_2:110;
A2: Seg len F = dom F by FINSEQ_1:def 3;
  len R1 = i by FINSEQ_2:69;
  then
A3: dom R1 = dom R2 by FINSEQ_3:31;
  now
    let j be Nat;
    assume
A4: j in Seg i;
    then R1.j = 0 by FUNCOP_1:13;
    hence R1.j = R2.j by A1,A2,A4;
  end;
  then R1 = R2 by A2,A3,FINSEQ_1:17;
  hence thesis by RVSUM_1:111;
end;

definition
  let f be Function;
  let X be set;
  mode MultOps of X,f -> Function means
    :Def1:
    dom it = dom f &
    for i being set st i in dom f holds it.i is Function of [:X,f.i:],f.i;
  existence
  proof
    deffunc F(set) = pr2(X,f.$1);
    consider g being Function such that
A1: dom g = dom f &
    for x be set st x in dom f holds g.x = F(x) from FUNCT_1:sch 3;
    take g;
    thus dom g = dom f by A1;
    let i be set;
    assume i in dom f;
    then g.i = pr2(X,f.i) by A1;
    hence thesis;
  end;
end;

registration
  let F be Domain-Sequence;
  let X be set;
  cluster -> FinSequence-like MultOps of X,F;
  coherence
  proof
    let f be MultOps of X,F;
    dom F = dom f & dom F = Seg len F by Def1,FINSEQ_1:def 3;
    hence thesis by FINSEQ_1:def 2;
  end;
end;

theorem Th4:
  for X be set, F be Domain-Sequence, p be FinSequence holds
  (p is MultOps of X,F iff len p = len F &
  for i be set st i in dom F holds p.i is Function of [:X,F.i:],F.i)
proof
  let X be set;
  let F be Domain-Sequence;
  let p be FinSequence;
  dom p = dom F iff len p = len F by FINSEQ_3:31;
  hence thesis by Def1;
end;

definition
  let F be Domain-Sequence;
  let X be set;
  let p be MultOps of X,F;
  let i be Element of dom F;
  redefine func p.i -> Function of [:X,F.i:],F.i;
  coherence by Th4;
end;

theorem Th5:
  for X be non empty set, F be Domain-Sequence,
  f,g being Function of [:X,product F:],product F st
  for x be Element of X, d being Element of product F,
  i being Element of dom F holds (f.(x,d)).i = (g.(x,d)).i holds f = g
proof
  let X be non empty set;
  let F be Domain-Sequence;
  let f,g being Function of [:X,product F:],product F such that
A1: for x be Element of X, d being Element of product F,
  i being Element of dom F holds (f.(x,d)).i = (g.(x,d)).i;
  now
    let x be Element of X,d being Element of product F;
    dom(f.(x,d)) = dom F & dom(g.(x,d)) = dom F &
    for v be set st v in dom F holds (f.(x,d)).v = (g.(x,d)).v
    by A1,CARD_3:18;
    hence f.(x,d) = g.(x,d) by FUNCT_1:9;
  end;
  hence thesis by BINOP_1:2;
end;

definition
  let F be Domain-Sequence;
  let X be non empty set;
  let p be MultOps of X,F;
  func [:p:] -> Function of [:X,product F:],product F means
  :Def2:
  for x be Element of X, d being Element of product F,
  i being Element of dom F holds (it.(x,d)).i = (p.i).(x,d.i);
  existence
  proof
    defpred Q[Element of X,Element of product F,Element of product F] means
    for i being Element of dom F holds $3.i = (p.i).($1,$2.i);
A1: for x be Element of X,d being Element of product F
    ex z being Element of product F st Q[x,d,z]
    proof
      let x be Element of X, d be Element of product F;
      defpred P[set,set] means
      ex i be Element of dom F st $1 =i & $2 = (p.i).(x,d.i);
A2:   for x,z1,z2 being set st x in dom F & P[x,z1] & P[x,z2] holds z1 = z2;
A3:   for w be set st w in dom F ex z be set st P[w,z]
      proof
        let w be set;
        assume w in dom F;
        then reconsider i = w as Element of dom F;
        take (p.i).(x,d.i);
        thus thesis;
      end;
      consider z being Function such that
A4:   dom z = dom F &
      for w being set st w in dom F holds P[w,z.w] from FUNCT_1:sch 2(A2,A3);
      now
        let w be set;
        assume w in dom F;
        then ex i be Element of dom F st w = i & z.w = (p.i).(x,d.i) by A4;
        hence z.w in F.w;
      end;
      then reconsider z' = z as Element of product F by A4,CARD_3:18;
      take z';
      let i be Element of dom F;
      ex j being Element of dom F st j = i & z.i = (p.j).(x,d.j) by A4;
      hence thesis;
    end;
    thus ex P being Function of [:X,product F:],product F st
    for x be Element of X, d being Element of product F holds
    Q[x,d,P.(x,d)] from BINOP_1:sch 3(A1);
  end;
  uniqueness
  proof
    let P,Q be Function of [:X,product F:],product F such that
A5: for x be Element of X, f being Element of product F,
    i being Element of dom F holds (P.(x,f)).i = (p.i).(x,f.i) and
A6: for x be Element of X, f being Element of product F,
    i being Element of dom F holds (Q.(x,f)).i = (p.i).(x,f.i);
    now
      let x be Element of X, f being Element of product F;
      let i be Element of dom F;
      (P.(x,f)).i = (p.i).(x,f.i) by A5;
      hence (P.(x,f)).i = (Q.(x,f)).i by A6;
    end;
    hence thesis by Th5;
  end;
end;

definition
  let R be Relation;
  attr R is RealLinearSpace-yielding means
  :Def3:
  for S be set st S in rng R holds S is RealLinearSpace;
end;

registration
  cluster non empty RealLinearSpace-yielding FinSequence;
  existence
  proof
    consider S be RealLinearSpace;
    take <*S*>;
    thus <*S*> is non empty;
    let x be set;
    assume
A1: x in rng <*S*> & not x is RealLinearSpace;
    then x in {S} by FINSEQ_1:55;
    hence contradiction by A1,TARSKI:def 1;
  end;
end;

definition
  mode RealLinearSpace-Sequence is
    non empty RealLinearSpace-yielding FinSequence;
end;

definition
  let G be RealLinearSpace-Sequence;
  let j be Element of dom G;
  redefine func G.j -> RealLinearSpace;
  coherence
  proof
    G.j in rng G by FUNCT_1:def 5;
    hence thesis by Def3;
  end;
end;

definition
  let G be RealLinearSpace-Sequence;
  func carr G -> Domain-Sequence means
  :Def4:
  len it = len G &
  for j be Element of dom G holds it.j = the carrier of G.j;
  existence
  proof
    defpred P[set,set] means
    ex j' being Element of dom G st j' = $1 & $2 = the carrier of G.j';
A2: for j being Nat st j in Seg len G ex x be set st P[j,x]
    proof
      let j be Nat;
      assume j in Seg len G;
      then reconsider j' = j as Element of dom G by FINSEQ_1:def 3;
      take the carrier of G.j';
      thus thesis;
    end;
    consider p being FinSequence such that
A3: dom p = Seg len G & for j being Nat st j in Seg len G holds P[j,p.j]
    from FINSEQ_1:sch 1(A2);
A4: dom G = Seg len G by FINSEQ_1:def 3;
    consider i being Element of dom G;
    dom p = dom G by A3,FINSEQ_1:def 3;
    then
A5: [i,p.i] in p & p = p by FUNCT_1:def 4;
    now
      assume {} in rng p;
      then consider x be set such that
A6:   x in dom p & {} = p.x by FUNCT_1:def 5;
      reconsider x as Element of NAT by A6;
      ex x' being Element of dom G st x' = x & p.x = the carrier of G.x'
      by A3,A6;
      hence contradiction by A6;
    end;
    then reconsider q = p as Domain-Sequence by A5,RELAT_1:def 9;
    take q;
    thus len q = len G by A3,FINSEQ_1:def 3;
    let j be Element of dom G;
    reconsider k = j as Element of NAT;
    ex n being Element of dom G st n = k & q.k = the carrier of G.n by A3,A4;
    hence thesis;
  end;
  uniqueness
  proof
    let f,h be Domain-Sequence such that
A7: len f = len G & for j be Element of dom G holds f.j = the carrier of G.j
    and
A8: len h = len G & for j be Element of dom G holds h.j = the carrier of G.j;
    reconsider f' = f,h' = h as FinSequence;
A9: dom f' = Seg len f' & dom h' = Seg len h' by FINSEQ_1:def 3;
    now
      let j be Nat;
      assume j in dom f';
      then reconsider j' = j as Element of dom G by A7,FINSEQ_3:31;
      f'.j = the carrier of G.j' by A7;
      hence f'.j = h'.j by A8;
    end;
    hence f = h by A7,A8,A9,FINSEQ_1:17;
  end;
end;

definition
  let G be RealLinearSpace-Sequence, j be Element of dom carr G;
  redefine func G.j -> RealLinearSpace;
  coherence
  proof
    dom G = Seg len G & Seg len(carr G) = dom carr G by FINSEQ_1:def 3;
    then reconsider j' = j as Element of dom G by Def4;
    G.j' is RealLinearSpace;
    hence thesis;
  end;
end;

definition
  let G be RealLinearSpace-Sequence;
  func addop G -> BinOps of carr G means
  :Def5:
  len it = len carr G &
  for j be Element of dom carr G holds it.j = the addF of G.j;
  existence
  proof
    deffunc F(Element of dom carr G) = the addF of G.$1;
    consider p being non empty FinSequence such that
A1: len p = len carr G &
    for j be Element of dom carr G holds p.j = F(j) from PRVECT_1:sch 1;
    now
      let j be Element of dom carr G;
      len G = len carr G by Def4;
      then reconsider k = j as Element of dom G by FINSEQ_3:31;
      p.j = the addF of G.j & the carrier of G.k = (carr G).k by A1,Def4;
      hence p.j is BinOp of (carr G).j;
    end;
    then reconsider p' = p as BinOps of carr G by A1,PRVECT_1:19;
    take p';
    thus thesis by A1;
  end;
  uniqueness
  proof
    let f,h be BinOps of carr G;
    assume that
A2: len f = len carr G &
    for j be Element of dom carr G holds f.j = the addF of G.j and
A3: len h = len carr G &
    for j be Element of dom carr G holds h.j = the addF of G.j;
    reconsider f' = f,h' = h as FinSequence;
A4: dom f' = Seg len f' & dom h' = Seg len h' by FINSEQ_1:def 3;
    now
      let i be Nat;
      assume i in dom f';
      then reconsider i' = i as Element of dom carr G by A2,FINSEQ_3:31;
      f'.i = the addF of G.i' by A2;
      hence f'.i = h'.i by A3;
    end;
    hence f = h by A2,A3,A4,FINSEQ_1:17;
  end;
  func complop G -> UnOps of carr G means
  :Def6:
  len it = len carr G & for j be Element of dom carr G holds it.j = comp G.j;
  existence
  proof
    deffunc F(Element of dom carr G) = comp G.$1;
    consider p being non empty FinSequence such that
A5: len p = len carr G &
    for j be Element of dom carr G holds p.j = F(j) from PRVECT_1:sch 1;
    now
      let j be Element of dom carr G;
      len G = len (carr G) by Def4;
      then reconsider k = j as Element of dom G by FINSEQ_3:31;
      p.j = comp G.j & the carrier of G.k = (carr G).k by A5,Def4;
      hence p.j is UnOp of (carr G).j;
    end;
    then reconsider p' = p as UnOps of carr G by A5,PRVECT_1:20;
    take p';
    thus thesis by A5;
  end;
  uniqueness
  proof
    let f,h be UnOps of carr G;
    assume that
A6: len f = len carr G &
    for j be Element of dom carr G holds f.j = comp G.j and
A7: len h = len carr G & for j be Element of dom carr G holds h.j = comp G.j;
    reconsider f' = f,h' = h as FinSequence;
A8: dom f' = Seg len f' & dom h' = Seg len h' by FINSEQ_1:def 3;
    now
      let i be Nat;
      assume i in dom f';
      then reconsider i' = i as Element of dom carr G by A6,FINSEQ_3:31;
      f.i = comp G.i' by A6;
      hence f.i = h.i by A7;
    end;
    hence f = h by A6,A7,A8,FINSEQ_1:17;
  end;
  func zeros G -> Element of product carr G means
  :Def7:
  for j be Element of dom carr G holds it.j = the ZeroF of G.j;
  existence
  proof
    deffunc F(Element of dom carr G) = the ZeroF of G.$1;
    consider p being non empty FinSequence such that
A9: len p = len carr G &
    for j be Element of dom carr G holds p.j = F(j) from PRVECT_1:sch 1;
A10: dom G = Seg len G & dom (carr G) = Seg len (carr G) & len G = len carr G &
    dom p = Seg len p by Def4,FINSEQ_1:def 3;
    now
      let i be set;
      assume i in dom (carr G);
      then reconsider x = i as Element of dom carr G;
      reconsider x' = x as Element of dom G by A10;
      p.x = the ZeroF of G.x & (carr G).x' = the carrier of G.x' by A9,Def4;
      hence p.i in (carr G).i;
    end;
    then reconsider t = p as Element of product (carr G) by A9,A10,CARD_3:18;
    take t;
    thus thesis by A9;
  end;
  uniqueness
  proof
    let f,h be Element of product carr G;
    assume that
A11: for j be Element of dom carr G holds f.j = the ZeroF of G.j and
A12: for j be Element of dom carr G holds h.j = the ZeroF of G.j;
    reconsider f' = f, h' = h as Function;
A13: dom f' = dom carr G & dom h' = dom carr G by CARD_3:18;
    now
      let x be set;
      assume x in dom carr G;
      then reconsider i = x as Element of dom carr G;
      thus f'.x = the ZeroF of G.i by A11
        .= h'.x by A12;
    end;
    hence thesis by A13,FUNCT_1:9;
  end;
  func multop G -> MultOps of REAL,carr G means
  :Def8:
  len it = len carr G &
  for j be Element of dom carr G holds it.j = the Mult of G.j;
  existence
  proof
    deffunc F(Element of dom carr G) = the Mult of G.$1;
    consider p being non empty FinSequence such that
A14: len p = len carr G &
    for j be Element of dom carr G holds p.j = F(j) from PRVECT_1:sch 1;
    now
      let ai be set;
      assume ai in dom carr G;
      then reconsider i=ai as Element of dom carr G;
      len G = len(carr G) by Def4;
      then reconsider j = i as Element of dom G by FINSEQ_3:31;
      p.i = the Mult of G.i & the carrier of G.j = (carr G).j by A14,Def4;
      hence p.ai is Function of [:REAL,(carr G).ai:],(carr G).ai;
    end;
    then reconsider p' = p as MultOps of REAL, carr G by A14,Th4;
    take p';
    thus thesis by A14;
  end;
  uniqueness
  proof
    let f,h be MultOps of REAL, carr G;
    assume that
A15: len f = len carr G &
    for j be Element of dom carr G holds f.j = the Mult of G.j and
A16: len h = len carr G &
    for j be Element of dom carr G holds h.j = the Mult of G.j;
    reconsider f' = f,h' = h as FinSequence;
A17: dom f' = Seg len f' & dom h' = Seg len h' by FINSEQ_1:def 3;
    now
      let i be Nat;
      assume i in dom f';
      then reconsider i' = i as Element of dom carr G by A15,FINSEQ_3:31;
      f'.i = the Mult of G.i' by A15;
      hence f'.i = h'.i by A16;
    end;
    hence f = h by A15,A16,A17,FINSEQ_1:17;
  end;
end;

definition
  let G be RealLinearSpace-Sequence;
  func product G -> strict non empty RLSStruct equals
  RLSStruct(# product carr G,zeros G,[:addop G :],[:multop G:] #);
  coherence;
end;

Lm1: for LS be non empty addLoopStr st
the addF of LS is commutative associative holds LS is Abelian add-associative
proof
  let LS be non empty addLoopStr;
  deffunc ad(addLoopStr) = the addF of $1;
  assume that
A1: ad(LS) is commutative and
A2: ad(LS) is associative;
  for x,y be Element of LS holds x+y = y+x by A1,BINOP_1:def 2;
  hence LS is Abelian by RLVECT_1:def 5;
  for x,y,z be Element of LS holds x+y+z = x+(y+z) by A2,BINOP_1:def 3;
  hence thesis by RLVECT_1:def 6;
end;

Lm2: for LS be non empty addLoopStr st
the ZeroF of LS is_a_unity_wrt the addF of LS holds LS is right_zeroed
proof
  let LS be non empty addLoopStr;
  assume
A1: the ZeroF of LS is_a_unity_wrt the addF of LS;
  let x be Element of LS;
  thus x + 0.LS = x by A1,BINOP_1:11;
end;

Lm3: for G be RealLinearSpace-Sequence holds
for v1,w1 be Element of product carr G, i be Element of dom carr G holds
([:addop G:].(v1,w1)).i = (the addF of G.i).(v1.i,w1.i) &
for vi,wi be VECTOR of G.i st vi=v1.i & wi=w1.i holds
([:addop G:].(v1,w1)).i = vi+wi
proof
  let G be RealLinearSpace-Sequence;
  let v1,w1 be Element of product carr G;
  let i be Element of dom carr G;
  ([:addop G:].(v1,w1)).i = ((addop G).i).(v1.i,w1.i) by PRVECT_1:def 10;
  hence thesis by Def5;
end;

Lm4: for G be RealLinearSpace-Sequence, r be Real,
v be Element of product carr G, i be Element of dom carr G holds
([:multop G:].(r,v)).i = (the Mult of G.i).(r,v.i) &
for vi be VECTOR of G.i st vi=v.i holds ([:multop G:].(r,v)).i = r*vi
proof
  let G be RealLinearSpace-Sequence;
  let r be Real,v be Element of product carr G;
  let i be Element of dom carr G;
  ([:multop G:].(r,v)).i = ((multop G).i).(r,v.i) by Def2;
  hence thesis by Def8;
end;

Lm5: for G be RealLinearSpace-Sequence holds product G is RealLinearSpace-like
proof
  let G be RealLinearSpace-Sequence;
  deffunc ad(addLoopStr) = the addF of $1;
  reconsider GS =
  RLSStruct(# product carr G,zeros G,[:addop G:],[:multop G:] #)
  as non empty RLSStruct;
  dom G = Seg len G by FINSEQ_1:def 3;
  then dom G = Seg len carr G by Def4;
  then
A1: dom G = dom carr G by FINSEQ_1:def 3;
  now
    let a,b be Real;
    let v,w be VECTOR of GS;
    reconsider v1=v, w1=w as Element of product carr G;
A2: dom([:multop G:].(a,[:addop G:].(v1,w1))) = dom carr G &
    dom([:addop G:].([:multop G:].(a,v1),[:multop G:].(a,w1))) = dom carr G &
    dom([:multop G:].(a+b,v1)) = dom carr G &
    dom([:addop G:].([:multop G:].(a,v1),[:multop G:].(b,v1))) = dom carr G &
    dom([:multop G:].(a*b,v1)) = dom carr G &
    dom([:multop G:].(a,[:multop G:].(b,v1))) = dom carr G &
    dom([:multop G:].(1,v1)) = dom carr G & dom v1 = dom carr G by CARD_3:18;
    now
      let x be set;
      assume x in dom carr G;
      then reconsider i = x as Element of dom carr G;
      reconsider vi=v1.i, wi=w1.i as VECTOR of G.i by A1,Def4;
      ([:multop G:].(a,[:addop G:].(v1,w1))).i
      = (the Mult of G.i).(a,([:addop G:].(v1,w1)).i) by Lm4
        .= a*(vi+wi) by Lm3
        .= a*vi+a*wi by RLVECT_1:def 9
        .= ad(G.i).(([:multop G:].(a,v1)).i,a*wi) by Lm4
        .= ad(G.i).(([:multop G:].(a,v1)).i,([:multop G:].(a,w1)).i) by Lm4;
      hence ([:multop G:].(a,[:addop G:].(v1,w1))).x
      =([:addop G:].([:multop G:].(a,v1),[:multop G:].(a,w1))).x by Lm3;
    end;
    hence a * (v + w) = a * v + a * w by A2,FUNCT_1:9;
    now
      let x be set;
      assume x in dom carr G;
      then reconsider i = x as Element of dom carr G;
      reconsider vi=v1.i as VECTOR of G.i by A1,Def4;
      ([:multop G:].(a+b,v1)).i = (a+b)*vi by Lm4
        .= a*vi+b*vi by RLVECT_1:def 9
        .= ad(G.i).(([:multop G:].(a,v1)).i,b*vi) by Lm4
        .= ad(G.i).(([:multop G:].(a,v1)).i,([:multop G:].(b,v1)).i) by Lm4;
      hence ([:multop G:].((a+b),v1)).x
      =([:addop G:].([:multop G:].(a,v1),[:multop G:].(b,v1))).x by Lm3;
    end;
    hence (a + b) * v = a * v + b * v by A2,FUNCT_1:9;
    now
      let x be set;
      assume x in dom carr G;
      then reconsider i = x as Element of dom carr G;
      reconsider vi=v1.i as VECTOR of G.i by A1,Def4;
      ([:multop G:].(a*b,v1)).i = (a*b)*vi by Lm4
        .=a*(b*vi) by RLVECT_1:def 9
        .=(the Mult of G.i).(a,([:multop G:].(b,v1)).i) by Lm4;
      hence ([:multop G:].((a*b),v1)).x
      = ([:multop G:].(a,[:multop G:].(b,v1))).x by Lm4;
    end;
    hence a * b * v = a * (b * v) by A2,FUNCT_1:9;
    now
      let x be set;
      assume x in dom carr G;
      then reconsider i = x as Element of dom carr G;
      reconsider vi=v1.i as VECTOR of G.i by A1,Def4;
      ( [:multop G:].(1,v1)).x = 1*vi by Lm4;
      hence ([:multop G:].(1,v1)).x =v1.x by RLVECT_1:def 9;
    end;
    hence 1 * v = v by A2,FUNCT_1:9;
  end;
  hence thesis by RLVECT_1:def 9;
end;

registration
  let G be RealLinearSpace-Sequence;
  cluster product G -> Abelian add-associative right_zeroed
    right_complementable RealLinearSpace-like;
  coherence
  proof
    deffunc ad(addLoopStr) = the addF of $1;
    deffunc car(1-sorted) = the carrier of $1;
    reconsider GS = RLSStruct(# product carr G,zeros G,
      [:addop G:],[:multop G:] #) as non empty RLSStruct;
A1: now
      let i be Element of dom carr G;
      dom G = Seg len G by FINSEQ_1:def 3
        .= Seg len carr G by Def4
        .= dom carr G by FINSEQ_1:def 3;
      hence (carr G).i = car(G.i) by Def4;
    end;
    now
      let i be Element of dom carr G;
      (addop G).i = ad(G.i) & (carr G).i = car(G.i) by A1,Def5;
      hence (addop G).i is commutative by FVSUM_1:2;
    end;
    then
A2: [:addop G:] is commutative by PRVECT_1:25;
    now
      let i be Element of dom carr G;
      (addop G).i = ad(G.i) & (carr G).i = car(G.i) by A1,Def5;
      hence (addop G).i is associative by FVSUM_1:3;
    end;
    then
A3: [:addop G:] is associative by PRVECT_1:26;
    deffunc zr(addLoopStr) = the ZeroF of $1;
    now
      let i be Element of dom carr G;
A4:   (addop G).i = ad(G.i) & (zeros G).i = zr(G.i) & (carr G).i = car(G.i)
      by A1,Def5,Def7;
      (zeros G).i = 0.(G.i) by Def7;
      hence (zeros G).i is_a_unity_wrt (addop G).i by A4,PRVECT_1:3;
    end;
    then
A5: zeros G is_a_unity_wrt [:addop G:] by PRVECT_1:27;
    GS is right_complementable
    proof
      let x be Element of GS;
      reconsider y = (Frege complop G).x as Element of GS by FUNCT_2:7;
      take y;
      now
        let i be Element of dom carr G;
        0.(G.i) = zr(G.i);
        then zr(G.i) is_a_unity_wrt ad(G.i) & (carr G).i = car(G.i) &
        (addop G).i = ad(G.i) & (complop G).i = comp G.i
        by A1,Def5,Def6,PRVECT_1:3;
        hence (complop G).i is_an_inverseOp_wrt (addop G).i &
        (addop G).i has_a_unity by PRVECT_1:4,SETWISEO:def 2;
      end;
      then Frege complop G is_an_inverseOp_wrt [:addop G:] by PRVECT_1:28;
      then [:addop G:].(x,y) = the_unity_wrt [:addop G:] by FINSEQOP:def 1;
      hence thesis by A5,BINOP_1:def 8;
    end;
    hence thesis by A2,A3,A5,Lm1,Lm2,Lm5;
  end;
end;

begin :: The Product Space of Real Normed Spaces

definition
  let R be Relation;
  attr R is RealNormSpace-yielding means
  :Def10:
  for x be set st x in rng R holds x is RealNormSpace;
end;

registration
  cluster non empty RealNormSpace-yielding FinSequence;
  existence
  proof
    consider A be RealNormSpace;
    take <*A*>;
    thus <*A*> is non empty;
    let x be set;
    assume
A1: x in rng <*A*> & not x is RealNormSpace;
    then x in {A} by FINSEQ_1:55;
    hence contradiction by A1,TARSKI:def 1;
  end;
end;

definition
  mode RealNormSpace-Sequence is non empty RealNormSpace-yielding FinSequence;
end;

definition
  let G be RealNormSpace-Sequence;
  let j be Element of dom G;
  redefine func G.j -> RealNormSpace;
  coherence
  proof
    G.j in rng G by FUNCT_1:def 5;
    hence thesis by Def10;
  end;
end;

Lm6: for g be RealNormSpace-yielding FinSequence holds
g is RealLinearSpace-yielding
proof
  let g be RealNormSpace-yielding FinSequence;
  for x be set st x in rng g holds x is RealLinearSpace by Def10;
  hence g is RealLinearSpace-yielding by Def3;
end;

registration
  cluster RealNormSpace-yielding -> RealLinearSpace-yielding FinSequence;
  coherence by Lm6;
end;

definition
  let G be RealNormSpace-Sequence;
  let x be Element of product carr G;
  func normsequence(G,x) -> Element of REAL len G means
  :Def11:
  len it = len G &
  for j be Element of dom G holds it.j=(the norm of G.j).(x.j);
  existence
  proof
    deffunc F(Element of dom G) = (the norm of G.$1).(x.$1);
    consider f being Function of dom G,REAL such that
A1: for j being Element of dom G holds f.j = F(j) from FUNCT_2:sch 4;
    dom f = dom G by FUNCT_2:def 1;
    then
A2: dom f = Seg len G by FINSEQ_1:def 3;
    then
A3: f is FinSequence by FINSEQ_1:def 2;
    rng f c= REAL;
    then reconsider f as FinSequence of REAL by A3,FINSEQ_1:def 4;
A4: len f = len G by A2,FINSEQ_1:def 3;
    f in REAL* by FINSEQ_1:def 11;
    then f in (len G)-tuples_on REAL by A4;
    then reconsider f as Element of REAL (len G);
    take f;
    thus len f = len G by FINSEQ_2:109;
    let j be Element of dom G;
    thus f.j = (the norm of G.j).(x.j) by A1;
  end;
  uniqueness
  proof
    let f,g be Element of REAL len G;
    assume that
A5: len f = len G &
    for j being Element of dom G holds f.j = (the norm of G.j).(x.j) and
A6: len g = len G &
    for j being Element of dom G holds g.j = (the norm of G.j).(x.j);
    now
      let j be Nat;
      assume j in Seg len G;
      then reconsider j1=j as Element of dom G by FINSEQ_1:def 3;
      f.j = (the norm of G.j1).(x.j1) by A5;
      hence f.j = g.j by A6;
    end;
    hence thesis by FINSEQ_2:139;
  end;
end;

definition
  let G be RealNormSpace-Sequence;
  func productnorm G ->
  Function of product carr (G qua RealLinearSpace-Sequence),REAL means
  :Def12:
  for x being Element of product carr G holds it.x = |.normsequence(G,x).|;
  existence
  proof
    deffunc F(Element of product carr G) = |.normsequence(G,$1).|;
    consider f being Function of product carr G, REAL such that
A1: for x being Element of product carr G holds f.x = F(x) from FUNCT_2:sch 4;
    take f;
    let x be Element of product carr G;
    thus f.x = |.normsequence(G,x).| by A1;
  end;
  uniqueness
  proof
    let f,g be Function of product carr G,REAL;
    assume that
A2: for x being Element of product carr G holds f.x = |.normsequence(G,x).| and
A3: for x being Element of product carr G holds g.x = |.normsequence(G,x).|;
    now
      let x be Element of product carr G;
      f.x = |.normsequence(G,x).| by A2;
      hence f.x = g.x by A3;
    end;
    hence thesis by FUNCT_2:113;
  end;
end;

definition
  let G be RealNormSpace-Sequence;
  func product G -> strict non empty NORMSTR means
  :Def13:
  the RLSStruct of it = product (G qua RealLinearSpace-Sequence) &
  the norm of it = productnorm G;
  existence
  proof
    reconsider G0=NORMSTR(# product carr G,zeros G,[:addop G :],[:multop G:],
      productnorm G #) as strict non empty NORMSTR;
    take G0;
    thus thesis;
  end;
  uniqueness;
end;

reserve G for RealNormSpace-Sequence;

theorem Th6:
  product G = NORMSTR(# product carr G,zeros G,[:addop G:],[:multop G:],
    productnorm G #)
proof
  the RLSStruct of product G
  = product(G qua RealLinearSpace-Sequence) by Def13;
  hence thesis by Def13;
end;

theorem Th7:
  for x be VECTOR of product G, y be Element of product carr G st
  x = y holds ||.x.|| = |.normsequence(G,y).|
proof
  let x be VECTOR of product G;
  let y be Element of product carr G;
  assume
A1: x=y;
  product G = NORMSTR(# product carr G,zeros G,[:addop G:],
    [:multop G:],productnorm G #) by Th6;
  hence ||.x.|| = |.normsequence(G,y).| by A1,Def12;
end;

theorem Th8:
  for x,y,z be Element of product carr G, i be Element of NAT st
  i in dom x & z = [:addop G :].(x,y) holds
  normsequence(G,z).i <= (normsequence(G,x) + normsequence(G,y)).i
proof
  let x,y,z be Element of product carr G, i be Element of NAT such that
A1: i in dom x & z = [: addop G :].(x,y);
  reconsider i0=i as Element of dom (carr G) by A1,CARD_3:18;
A2: z.i0 = ((addop G).i0).(x.i0,y.i0) by A1,PRVECT_1:def 10;
  dom G = Seg len G by FINSEQ_1:def 3
    .= Seg len carr G by Def4
    .= dom carr G by FINSEQ_1:def 3;
  then reconsider i0=i as Element of dom G by A1,CARD_3:18;
A3: dom x = dom(carr G) by CARD_3:18;
  (carr G).i0 = the carrier of G.i0 by Def4;
  then reconsider xi0=x.i0,yi0=y.i0,zi0=z.i0 as Element of G.i0 by A1,A3,
  CARD_3:18;
  ||.zi0.|| = ||.xi0+yi0.|| by A2,Def5;
  then
A4: ||.zi0.|| <= ||.xi0.|| + ||.yi0.|| by NORMSP_1:def 2;
A5: (the norm of G.i0).yi0 = normsequence(G,y).i0 &
  (the norm of G.i0).zi0 = normsequence(G,z).i0 by Def11;
  normsequence(G,x).i0 + normsequence(G,y).i0
  = (normsequence(G,x) + normsequence(G,y)).i0 by RVSUM_1:27;
  hence thesis by A4,A5,Def11;
end;

theorem Th9:
  for x be Element of product carr G, i be Element of NAT st
  i in dom x holds 0 <= normsequence(G,x).i
proof
  let x be Element of product carr G, i be Element of NAT such that
A1: i in dom x;
A2: dom x = dom carr G by CARD_3:18;
  dom G = Seg len G by FINSEQ_1:def 3
    .= Seg len carr G by Def4
    .= dom carr G by FINSEQ_1:def 3;
  then reconsider i0=i as Element of dom G by A1,CARD_3:18;
  (carr G).i0 = the carrier of G.i0 by Def4;
  then reconsider xi0=x.i0 as Element of G.i0 by A1,A2,CARD_3:18;
  0<= ||.xi0.|| by NORMSP_1:8;
  hence 0 <= normsequence(G,x).i by Def11;
end;

Lm7: product G is RealNormSpace-like
proof
  let x,y being Point of product G, a be Real;
  reconsider n = len G as Element of NAT;
A1: product G = NORMSTR(# product carr G,zeros G,[:addop G:],
    [:multop G:],productnorm G #) by Th6;
A2: len G = len carr G by Def4;
A3: ||.x.|| = 0 implies x = 0.(product G)
  proof
    assume
A4: ||.x.|| = 0;
    reconsider z=x as Element of product carr G by A1;
    now
      let i be Element of dom carr G;
      ||.x.|| = |.normsequence(G,z).| by Th7;
      then
A5:   normsequence(G,z) = 0*n by A4,EUCLID:11;
      dom carr G = Seg len carr G by FINSEQ_1:def 3;
      then dom carr G = Seg len G by Def4;
      then
A6:   normsequence(G,z).i = 0 by A5,FUNCOP_1:13;
      reconsider i0 = i as Element of dom G by A2,FINSEQ_3:31;
      (carr G).i0 = the carrier of G.i0 by Def4;
      then reconsider zzi0=z.i0 as Element of G.i0 by CARD_3:18;
      ||.(zzi0).|| = 0 by A6,Def11;
      then z.i = 0.(G.i) by NORMSP_1:def 2;
      hence z.i = the ZeroF of (G.i);
    end;
    hence x = 0.(product G) by A1,Def7;
  end;
A7: x = 0.(product G) implies ||.x.|| = 0
  proof
    assume
A8: x = 0.(product G);
    reconsider z=x as Element of product carr G by A1;
A9: for i be Element of dom carr G holds normsequence(G,z).i = 0
    proof
      let i be Element of dom carr G;
      reconsider i0 = i as Element of dom G by A2,FINSEQ_3:31;
      (carr G).i0 = the carrier of G.i0 by Def4;
      then reconsider zi0=z.i0 as Element of G.i0 by CARD_3:18;
      z.i = 0.(G.i) by A1,A8,Def7;
      then ||.zi0.|| = 0;
      hence normsequence(G,z).i = 0 by Def11;
    end;
    for i be Element of NAT st i in dom (sqr normsequence(G,z))
    holds (sqr normsequence(G,z)).i = 0
    proof
      let i be Element of NAT;
      assume
A10:  i in dom sqr normsequence(G,z);
      len normsequence(G,z) = len G by Def11;
      then
A11:  dom normsequence(G,z) = dom G by FINSEQ_3:31;
      dom carr G = dom G by A2,FINSEQ_3:31;
      then dom sqr normsequence(G,z) = dom carr G by A11,RVSUM_1:77;
      then (normsequence(G,z).i)^2 = 0 by A9,A10,SQUARE_1:60;
      hence (sqr normsequence(G,z)).i = 0 by RVSUM_1:78;
    end;
    then |.normsequence(G,z).| = 0 by Th3,SQUARE_1:82;
    hence ||.x.|| = 0 by Th7;
  end;
  reconsider z=x as Element of product carr G by A1;
  reconsider ax=a * x as Element of product carr G by A1;
A12: len normsequence(G,ax) = n & len (abs(a) * normsequence(G,z)) = n
  by FINSEQ_2:109;
  then
X: dom normsequence(G,ax) = Seg n by FINSEQ_1:def 3;
  for i be Nat st i in dom normsequence(G,ax) holds
  normsequence(G,ax).i = (abs(a) * normsequence(G,z)).i
  proof
    let i be Nat;
    assume i in dom normsequence(G,ax);
    then reconsider i0 = i as Element of dom G by FINSEQ_1:def 3,X;
    (carr G).i0 = the carrier of G.i0 & dom carr G = dom G
    by A2,Def4,FINSEQ_3:31;
    then reconsider axi0=ax.i0, zi0 = z.i0 as Element of G.i0 by CARD_3:18;
    reconsider i1 = i0 as Element of dom carr G by A2,FINSEQ_3:31;
    ( [:multop G:].(a,z)).i1 = ((multop G).i1).(a,zi0) by Def2;
    then axi0 = a * zi0 by A1,Def8;
    then ||.axi0.|| = abs(a) * ||. zi0 .|| by NORMSP_1:def 2;
    then ||.axi0.|| = abs(a) * normsequence(G,z).i0 by Def11;
    then ||.axi0.|| = (abs(a) * normsequence(G,z)).i0 by RVSUM_1:66;
    hence thesis by Def11;
  end;
  then |.normsequence(G,ax).| = |.abs(a)*normsequence(G,z).|
  by A12,FINSEQ_2:10;
  then
A13: |.normsequence(G,ax).| = abs(abs a) * |.normsequence(G,z).| by EUCLID:14;
  reconsider z = x + y as Element of product carr G by A1;
  reconsider xx = x, yy = y as Element of product carr G by A1;
A14: ||.x + y.|| = |.normsequence(G,z).| & ||.x.|| = |.normsequence(G,xx).| &
  ||.y.|| = |.normsequence(G,yy).| by Th7;
A15: len normsequence(G,z) = n by Def11;
  then
A16: len normsequence(G,z)
  = len (normsequence(G,xx)+ normsequence(G,yy)) by FINSEQ_2:109;
  for i be Element of NAT st i in Seg n holds 0 <= normsequence(G,z).i &
  normsequence(G,z).i <= (normsequence(G,xx)+ normsequence(G,yy)).i
  proof
    let i be Element of NAT such that
A17: i in Seg n;
A18: Seg n = dom G by FINSEQ_1:def 3;
A19: dom carr G = dom G by A2,FINSEQ_3:31;
    then
A20: i in dom z by A17,A18,CARD_3:18;
    dom xx = dom carr G by CARD_3:18;
    hence thesis by A1,A17,A18,A19,A20,Th8,Th9;
  end;
  then
A21: |.normsequence(G,z).| <= |.normsequence(G,xx)+ normsequence(G,yy).|
  by A15,A16,Th2;
  |.normsequence(G,xx)+ normsequence(G,yy).|
  <= |.normsequence(G,xx).| + |.normsequence(G,yy).| by EUCLID:15;
  hence thesis by A3,A7,A13,A14,A21,Th7,XXREAL_0:2;
end;

registration
  let G be RealNormSpace-Sequence;
  cluster product G -> RealNormSpace-like RealLinearSpace-like
    Abelian add-associative right_zeroed right_complementable;
  coherence
  proof
    reconsider G1=G as RealLinearSpace-Sequence;
A1: the RLSStruct of product G = product (G qua RealLinearSpace-Sequence)
    by Def13;
A2: product G is Abelian
    proof
      let v,w be VECTOR of product G;
      reconsider v1=v,w1=w as VECTOR of product G1 by A1;
      v+w =v1+w1 by A1;
      then v+w =w1+v1;
      hence thesis by A1;
    end;
A3: product G is add-associative
    proof
      let v,w,x be VECTOR of product G;
      reconsider v1=v,w1=w,x1=x as VECTOR of product G1 by A1;
      (v+w)+x = (v1+w1)+x1 by A1;
      then (v+w)+x =v1+(w1+x1) by RLVECT_1:def 6;
      hence thesis by A1;
    end;
A4: product G is right_zeroed
    proof
      let v be VECTOR of product G;
      reconsider v1=v as VECTOR of product G1 by A1;
      v+0.product G = v1+0.product G1 by A1;
      hence v+0.product G = v by RLVECT_1:def 7;
    end;
A5: product G is right_complementable
    proof
      let v be VECTOR of product G;
      reconsider v1=v as VECTOR of product G1 by A1;
      reconsider w=-v1 as VECTOR of product G by A1;
      take w;
      v+w = v1-v1 by A1;
      then v+w = 0.product G1 by RLVECT_1:28;
      hence v+w = 0.product G by A1;
    end;
    product G is RealLinearSpace-like
    proof
A6:   now
        let a be Real;
        let v,w be VECTOR of product G;
        reconsider v1=v,w1=w as VECTOR of product G1 by A1;
        a * (v + w) = a * (v1 + w1) by A1;
        then a * (v + w) =a * v1 + a * w1 by RLVECT_1:def 9;
        hence a * (v + w) = a*v +a*w by A1;
      end;
A7:   now
        let a,b be Real, v be VECTOR of product G;
        reconsider v1=v as VECTOR of product G1 by A1;
        (a+b) * v = (a+b) * v1 by A1;
        then (a+b) * v = a * v1 + b * v1 by RLVECT_1:def 9;
        hence (a+b) * v =a*v +b*v by A1;
      end;
A8:   now
        let a,b be Real, v be VECTOR of product G;
        reconsider v1=v as VECTOR of product G1 by A1;
        (a*b) * v = (a*b) * v1 by A1;
        then (a*b) * v = a * (b * v1) by RLVECT_1:def 9;
        hence (a*b) * v = a*(b*v) by A1;
      end;
      now
        let v be VECTOR of product G;
        reconsider v1=v as VECTOR of product G1 by A1;
        1 * v = 1 * v1 by A1;
        hence 1 * v = v by RLVECT_1:def 9;
      end;
      hence thesis by A6,A7,A8,RLVECT_1:def 9;
    end;
    hence thesis by A2,A3,A4,A5,Lm7;
  end;
end;

theorem Th10:
  for G be RealNormSpace-Sequence,
  i be Element of dom G, x be Point of product G,
  y be Element of product carr G, xi be Point of G.i st
  y = x & xi = y.i holds ||.xi.|| <= ||.x.||
proof
  let G be RealNormSpace-Sequence, i be Element of dom G,
  x be Point of product G, y be Element of product carr G, xi be Point of G.i;
  reconsider n = len G as Element of NAT;
  assume
A1: y=x & xi=y.i;
  then
A2: ||.x.|| = |.normsequence(G,y).| by Th7;
A3: (normsequence(G,y).i)^2 = (sqr normsequence(G,y)).i by RVSUM_1:78;
A4: 0 <= (normsequence(G,y).i)^2 by XREAL_1:65;
A5: dom G = Seg n by FINSEQ_1:def 3;
  for i be Element of NAT st i in Seg n holds 0 <= (sqr normsequence(G,y)).i
  proof
    let i be Element of NAT such that i in Seg n;
    (normsequence(G,y).i)^2 >= 0 by XREAL_1:65;
    hence thesis by RVSUM_1:78;
  end;
  then
A6: (sqr normsequence(G,y)).i <= Sum sqr normsequence(G,y) by A5,REAL_NS1:7;
  ||.xi.|| = normsequence(G,y).i by A1,Def11;
  then sqrt ((sqr normsequence(G,y)).i) = normsequence(G,y).i
  by A3,NORMSP_1:8,SQUARE_1:89;
  then ||.xi.|| = sqrt ((sqr normsequence(G,y)).i) by A1,Def11;
  hence ||.xi.|| <= ||.x.|| by A2,A3,A4,A6,SQUARE_1:94;
end;

Lm8: for RNS be RealNormSpace, S be sequence of RNS, g be Point of RNS holds
(S is convergent & lim S = g) iff
(||.S - g.|| is convergent & lim ||.S - g.|| = 0)
proof
  let RNS be RealNormSpace, S be sequence of RNS, g be Point of RNS;
  now
    assume
A1: ||.S - g.|| is convergent & lim ||.S - g.|| = 0;
A2: now
      let r be Real;
      reconsider p=r as real number;
      assume 0 < r;
      then consider n be Element of NAT such that
A3:   for m be Element of NAT st n<=m holds abs (||.S - g.||.m-0) < p
      by A1,SEQ_2:def 7;
      take n;
      now
        let m be Element of NAT;
        assume n<=m;
        then abs (||.S - g.||.m-0) < p by A3;
        then abs ||.(S - g).m.|| < p by NORMSP_1:def 10;
        then
A4:     abs ||.S.m - g.|| < p by NORMSP_1:def 7;
        0 <= ||.S.m - g.|| by NORMSP_1:8;
        hence ||.S.m - g.|| < p by A4,ABSVALUE:def 1;
      end;
      hence for m be Element of NAT st n<=m holds ||.S.m - g.|| < r;
    end;
    hence S is convergent by NORMSP_1:def 9;
    hence lim S = g by A2,NORMSP_1:def 11;
  end;
  hence thesis by NORMSP_1:41;
end;

theorem Th11:
  for G be RealNormSpace-Sequence, i be Element of dom G,
  x,y be Point of product G, xi,yi be Point of G.i,
  zx,zy be Element of product carr G st
  xi=zx.i & zx=x & yi=zy.i & zy=y holds ||.yi - xi.|| <= ||.y - x.||
proof
  let G be RealNormSpace-Sequence, i be Element of dom G,
  x,y be Point of product G, xi,yi be Point of G.i,
  zx,zy be Element of product carr G;
  assume
A1: xi=zx.i & zx=x & yi=zy.i & zy=y;
A2: product G =
  NORMSTR(# product carr G,zeros G,[:addop G:],[:multop G:],productnorm G #)
  by Th6;
  then reconsider mzx =-x as Element of product carr G;
  reconsider zyi = zy.i, zxi = zx.i as Element of G.i by A1;
  len G = len carr G by Def4;
  then
A3: dom G = dom carr G by FINSEQ_3:31;
  -x = (-1) * x by RLVECT_1:29;
  then
A4: mzx.i = (-1) * zxi by A1,A2,A3,Lm4;
  then reconsider mzxi = mzx.i as Element of G.i;
  reconsider zyMm = y-x as Element of product carr G by A2;
  zyMm.i =zyi+mzxi by A1,A2,A3,Lm3;
  then zyMm.i =zyi+-zxi by A4,RLVECT_1:29;
  hence ||.yi - xi.|| <= ||.y - x.|| by A1,Th10;
end;

theorem
  for G be RealNormSpace-Sequence, seq be sequence of (product G),
  x0 be Point of product G, y0 be Element of product carr G st
  x0 = y0 & seq is convergent & lim seq=x0 holds for i be Element of dom G
  ex seqi be sequence of G.i st seqi is convergent & y0.i = lim seqi &
  for m be Element of NAT holds
  ex seqm be Element of product carr G st seqm= seq.m & seqi.m=seqm.i
proof
  let G be RealNormSpace-Sequence, seq be sequence of (product G),
  x0 be Point of product G, y0 be Element of product carr G;
  assume
A1: x0 = y0 & seq is convergent & lim seq=x0;
  let i be Element of dom G;
  defpred P1[Element of NAT,Element of G.i] means
  ex seqm be Element of product carr G st seqm = seq.$1 & $2 = seqm.i;
  len G = len carr G by Def4;
  then
A2: dom G = dom carr G by FINSEQ_3:31;
A3: for x being Element of NAT ex y being Element of G.i st P1[x,y]
  proof
    let x be Element of NAT;
    product G = NORMSTR(# product carr G,zeros G,[:addop G:],
      [:multop G:],productnorm G #) by Th6;
    then consider seqm be Element of product carr G such that
A4: seqm =seq.x;
    take y = seqm.i;
    (carr G).i = the carrier of G.i by Def4;
    hence thesis by A2,A4,CARD_3:18;
  end;
  ex f be Function of NAT,the carrier of G.i st
  for x being Element of NAT holds P1[x,f.x] from FUNCT_2:sch 3(A3);
  then consider seqi be sequence of G.i such that
A5: for m be Element of NAT holds
  ex seqm be Element of product carr G st seqm= seq.m & seqi.m=seqm.i;
  take seqi;
  y0.i in (carr G).i by A2,CARD_3:18;
  then reconsider x0i=y0.i as Point of G.i by Def4;
A6: for r be Real st 0 < r ex m be Element of NAT st
  for n be Element of NAT st m <= n holds ||.seqi.n - x0i.|| < r
  proof
    let r be Real;
    assume r > 0;
    then consider k be Element of NAT such that
A7: for n be Element of NAT st k <= n holds ||.seq.n - x0.|| < r
    by A1,NORMSP_1:def 11;
    now
      let n be Element of NAT;
      assume n >= k;
      then
A8:   ||.(seq.n) - x0.|| < r by A7;
      ex seqn be Element of product carr G st
      seqn = seq.n & seqi.n = seqn.i by A5;
      then ||. seqi.n - x0i.|| <= ||. seq.n - x0.|| by A1,Th11;
      hence ||.(seqi.n) - x0i.|| < r by A8,XXREAL_0:2;
    end;
    hence thesis;
  end;
  then seqi is convergent by NORMSP_1:def 9;
  hence thesis by A5,A6,NORMSP_1:def 11;
end;

theorem Th13:
  for G be RealNormSpace-Sequence, seq be sequence of (product G),
  x0 be Point of product G, y0 be Element of product carr G st x0=y0 &
  for i be Element of dom G ex seqi be sequence of G.i st
  seqi is convergent & y0.i = lim seqi & for m be Element of NAT holds
  ex seqm be Element of product carr G st seqm= seq.m & seqi.m=seqm.i holds
  seq is convergent & lim seq=x0
proof
  let G be RealNormSpace-Sequence, seq be sequence of (product G),
  x0 be Point of product G, y0 be Element of product carr G;
  assume
A1: x0=y0 & for i be Element of dom G ex seqi be sequence of G.i st
  seqi is convergent & y0.i = lim seqi & for m be Element of NAT holds
  ex seqm be Element of product carr G st seqm= seq.m & seqi.m=seqm.i;
  reconsider I = len G as Element of NAT;
A2: product G = NORMSTR(# product carr G,zeros G,
    [:addop G:],[:multop G:],productnorm G #) by Th6;
  defpred PP[Element of dom G, set] means
  ex rseqi be Real_Sequence, seqi be sequence of G.$1 st
  rseqi=$2 & seqi is convergent & rseqi is convergent &
  lim rseqi=0 & rseqi=||.seqi-lim seqi.|| & for m be Element of NAT holds
  ex seqm be Element of product carr G st seqm= seq.m & seqi.m=seqm.$1;
A3: for i be Element of dom G
  ex yyseqi be Element of Funcs(NAT,REAL) st PP[i,yyseqi]
  proof
    let i be Element of dom G;
    consider seqi be sequence of G.i such that
A4: seqi is convergent & y0.i = lim seqi & for m be Element of NAT holds
    ex Sm be Element of product carr G st Sm= seq.m & seqi.m=Sm.i by A1;
    set rseqi=||.seqi-lim seqi.||;
A5: rseqi is convergent & lim rseqi=0 by A4,Lm8;
    rseqi is Element of Funcs(NAT,REAL) by FUNCT_2:11;
    hence thesis by A4,A5;
  end;
  consider yyseq be Function of (dom G),Funcs(NAT,REAL) such that
A6: for i be Element of dom G holds PP[i,yyseq.i] from FUNCT_2:sch 3(A3);
  defpred PQ[Element of NAT,Element of (REAL I)] means
  for i be Element of dom G holds (yyseq.i).$1 = $2.i;
A7: for k be Element of NAT ex yseqk be Element of (REAL I) st PQ[k,yseqk]
  proof
    let k be Element of NAT;
    defpred PPF[set,set] means
    ex i be Element of dom G st i=$1 & $2 = (yyseq.i).k;
A9: for k be Nat st k in Seg I ex x be set st PPF[k,x]
    proof
      let j be Nat;
      assume j in Seg I;
      then reconsider i=j as Element of dom G by FINSEQ_1:def 3;
      take (yyseq.i).k;
      thus thesis;
    end;
    consider yseqk be FinSequence such that
A10: dom yseqk = Seg I & for j be Nat st j in Seg I holds
    PPF[j,yseqk.j] from FINSEQ_1:sch 1(A9);
    now
      let j be Nat;
      assume j in dom yseqk;
      then consider i be Element of dom G such that
A11:  i=j & yseqk.j= (yyseq.i).k by A10;
      yyseq.i is Function of NAT,REAL by FUNCT_2:121;
      hence yseqk.j in REAL by A11,FUNCT_2:7;
    end;
    then reconsider yyy=yseqk as FinSequence of REAL by FINSEQ_2:14;
    yyy is Element of (len yyy)-tuples_on REAL by FINSEQ_2:110;
    then reconsider yseqk as Element of (REAL I) by A10,FINSEQ_1:def 3;
    now
      let j be Element of dom G;
      j in dom G;
      then j in Seg I by FINSEQ_1:def 3;
      then ex i be Element of dom G st i=j & yseqk.j= (yyseq.i).k by A10;
      hence yseqk.j= (yyseq.j).k;
    end;
    hence thesis;
  end;
  consider yseq be Function of NAT,REAL I such that
A12: for k be Element of NAT holds PQ[k,yseq.k] from FUNCT_2:sch 3(A7);
  the carrier of REAL-NS I = REAL I by REAL_NS1:def 4;
  then reconsider xseq=yseq as sequence of REAL-NS I;
A13: xseq = yseq;
  now
    let i0 be Element of NAT;
    assume
A14: i0 in Seg I;
    then reconsider i=i0 as Element of dom G by FINSEQ_1:def 3;
    take i;
    consider rseqi be Real_Sequence, seqi be sequence of G.i such that
A15: rseqi=yyseq.i & seqi is convergent & rseqi is convergent &
    lim rseqi=0 & rseqi=||.seqi-lim seqi.|| & for m be Element of NAT holds
    ex seqm be Element of product carr G st seqm= seq.m & seqi.m=seqm.i by A6;
    take rseqi,seqi;
    thus (for k be Element of NAT holds rseqi.k = (yseq.k).i0) &
    i=i0 & seqi is convergent & rseqi is convergent &
    lim rseqi=(0*I).i & rseqi=||.seqi-lim seqi.|| &
    for m be Element of NAT holds ex seqm be Element of product carr G st
    seqm= seq.m & seqi.m=seqm.i by A12,A14,A15,FUNCOP_1:13;
  end;
  then consider xseq be sequence of REAL-NS I,
  yseq be Function of NAT,REAL I such that
A16: xseq=yseq & for i0 be Element of NAT st i0 in Seg I
  ex i be Element of dom G, rseqi be Real_Sequence, seqi be sequence of G.i st
  (for k be Element of NAT holds rseqi.k = (yseq.k).i0) &
  i=i0 & seqi is convergent & rseqi is convergent &
  lim rseqi=(0*I).i & rseqi=||.seqi-lim seqi.|| &
  for m be Element of NAT holds ex seqm be Element of product carr G st
  seqm= seq.m & seqi.m=seqm.i by A13;
A17: for i be Element of NAT st i in Seg I ex rseqi be Real_Sequence st
  (for k be Element of NAT holds rseqi.k = (yseq.k).i) &
  rseqi is convergent & (0*I).i = lim rseqi
  proof
    let i0 be Element of NAT;
    assume i0 in Seg I;
    then ex i be Element of dom G, rseqi be Real_Sequence,
    seqi be sequence of G.i st
    (for k be Element of NAT holds rseqi.k = (yseq.k).i0) &
    i=i0 & seqi is convergent & rseqi is convergent &
    lim rseqi=(0*I).i & rseqi=||.seqi-lim seqi.|| &
    for m be Element of NAT holds ex seqm be Element of product carr G st
    seqm= seq.m & seqi.m=seqm.i by A16;
    hence thesis;
  end;
  (0*I) = 0.(REAL-NS I) by REAL_NS1:def 4;
  then
A18: xseq is convergent & lim xseq = 0.(REAL-NS I) by A16,A17,REAL_NS1:11;
  ||.xseq-0.(REAL-NS I).|| =||.seq-x0.||
  proof
    now
      let x be set;
      assume x in NAT;
      then reconsider i=x as Element of NAT;
      reconsider seqimx0 = seq.i-x0 as Element of product carr G by A2;
A19:  yseq.i = normsequence(G,seqimx0)
      proof
        len (yseq.i)= I by EUCLID:2;
        then len (yseq.i) = len normsequence(G,seqimx0) by Def11;
        then
A20:    dom (yseq.i) = dom normsequence(G,seqimx0) by FINSEQ_3:31;
        now
          let k be Nat;
          assume
A21:      k in dom normsequence(G,seqimx0);
A22:      len G= len normsequence(G,seqimx0) by Def11;
          then reconsider k0=k as Element of dom G by A21,FINSEQ_3:31;
          consider seqk0 be sequence of G.k0 such that
A23:      seqk0 is convergent & y0.k0 = lim seqk0 &
          for m be Element of NAT holds
          ex seqm0 be Element of product carr G st
          seqm0= seq.m & seqk0.m=seqm0.k0 by A1;
          k in Seg I by A21,A22,FINSEQ_1:def 3;
          then consider k1 be Element of dom G, rseqk1i be Real_Sequence,
          seqk1i be sequence of G.k1 such that
A24:      (for j be Element of NAT holds rseqk1i.j = (yseq.j).k) &
          k1=k & seqk1i is convergent & rseqk1i is convergent &
          lim rseqk1i=(0*I).k1 & rseqk1i=||.seqk1i-lim seqk1i.|| &
          for m be Element of NAT holds
          ex seqk1m be Element of product carr G st
          seqk1m= seq.m & seqk1i.m=seqk1m.k1 by A16;
          now
            let x be set;
            assume x in NAT;
            then reconsider m = x as Element of NAT;
A25:        ex seqk1m be Element of product carr G st
            seqk1m= seq.m & seqk1i.m=seqk1m.k1 by A24;
            ex seqm0 be Element of product carr G st
            seqm0= seq.m & seqk0.m = seqm0.k0 by A23;
            hence seqk1i.x = seqk0.x by A24,A25;
          end;
          then
A26:      seqk1i=seqk0 by A24,FUNCT_2:18;
          consider seqm0 be Element of product carr G such that
A27:      seqm0= seq.i & seqk0.i=seqm0.k0 by A23;
          reconsider mx0=-x0 as Element of product carr G by A2;
          len G = len carr G by Def4;
          then
A28:      dom G = dom carr G by FINSEQ_3:31;
          -x0 = (-1) * x0 by RLVECT_1:29;
          then mx0.k0 = (-1)*(lim seqk0) by A1,A2,A23,A28,Lm4;
          then -(lim seqk0) = mx0.k0 by RLVECT_1:29;
          then
A29:      seqimx0.k0 = seqk0.i - lim seqk0 by A2,A27,A28,Lm3;
          thus (normsequence(G,seqimx0)).k
          = (the norm of G.k0).(seqimx0.k0) by Def11
            .= ||.(seqk0 -lim seqk0).i .|| by A29,NORMSP_1:def 7
            .= (||.seqk1i - (lim seqk1i).||).i by A24,A26,NORMSP_1:def 10
            .= (yseq.i).k by A24;
        end;
        hence thesis by A20,FINSEQ_1:17;
      end;
      thus ||.xseq-0.(REAL-NS I).||.x
      =||.(xseq-0.(REAL-NS I)).i .|| by NORMSP_1:def 10
        .=||.xseq.i-0.(REAL-NS I).|| by NORMSP_1:def 7
        .=||.xseq.i.|| by RLVECT_1:26
        .=|.yseq.i.| by A16,REAL_NS1:1
        .=||.seq.i -x0.|| by A19,Th7
        .=||.(seq -x0).i.|| by NORMSP_1:def 7
        .=||.seq-x0.||.x by NORMSP_1:def 10;
    end;
    hence thesis by SEQ_1:8;
  end;
  then ||.seq-x0.|| is convergent & lim ||.seq-x0.|| =0 by A18,Lm8;
  hence thesis by Lm8;
end;

theorem
  for G be RealNormSpace-Sequence st
  for i be Element of dom G holds G.i is complete holds product G is complete
proof
  let G be RealNormSpace-Sequence such that
A1: for i be Element of dom G holds G.i is complete;
  reconsider I = len G as Element of NAT;
A2: product G = NORMSTR(# product carr G,zeros G,[:addop G:],
    [:multop G:],productnorm(G) #) by Th6;
  for seq be sequence of (product G) holds
  seq is Cauchy_sequence_by_Norm implies seq is convergent
  proof
    let seq be sequence of product G;
    assume
A3: seq is Cauchy_sequence_by_Norm;
    defpred PPG[Nat,set] means ex i be Element of dom G st i=$1 &
    ex seqi be sequence of G.i st seqi is convergent & $2 = lim seqi &
    for m be Element of NAT holds
    ex seqm be Element of product carr G st seqm= seq.m & seqi.m=seqm.i;
A11: for k be Nat st k in Seg I ex x be set st PPG[k,x]
    proof
      let k be Nat;
      assume k in Seg I;
      then reconsider i=k as Element of dom G by FINSEQ_1:def 3;
      defpred P1[Element of NAT,Element of G.i] means
      ex seqm be Element of product carr G st seqm = seq.$1 & $2 = seqm.i;
A12:  for x being Element of NAT ex y being Element of G.i st P1[x,y]
      proof
        let x be Element of NAT;
        consider seqm be Element of product carr G such that
A13:    seqm =seq.x by A2;
        take y = seqm.i;
        len G = len carr G by Def4;
        then
A14:    dom G = dom carr G by FINSEQ_3:31;
        (carr G).i = the carrier of G.i by Def4;
        hence thesis by A13,A14,CARD_3:18;
      end;
      ex f be Function of NAT,the carrier of G.i st
      for x being Element of NAT holds P1[x,f.x] from FUNCT_2:sch 3(A12);
      then consider seqi be sequence of G.i such that
A15:  for m be Element of NAT holds ex seqm be Element of product carr G st
      seqm= seq.m & seqi.m=seqm.i;
A16:  G.i is complete by A1;
      take x = lim seqi;
      now
        let r1 be Real such that
A17:    r1 > 0;
        reconsider r=r1 as Element of REAL;
        consider k be Element of NAT such that
A18:    for n,m be Element of NAT st n >= k & m >= k holds
        ||. seq.n - seq.m .|| < r by A3,A17,RSSPACE3:10;
        now
          let n,m be Element of NAT;
          assume n >= k & m >= k;
          then
A19:      ||. seq.n - seq.m .|| < r by A18;
A20:      ex seqm be Element of product carr G st
          seqm = seq.m & seqi.m = seqm.i by A15;
          ex seqn be Element of product carr G st
          seqn = seq.n & seqi.n = seqn.i by A15;
          then ||. seqi.n - seqi.m .||<= ||. seq.n - seq.m .|| by A20,Th11;
          hence ||. seqi.n - seqi.m .|| < r1 by A19,XXREAL_0:2;
        end;
        hence ex k be Element of NAT st for n, m be Element of NAT st
        n >= k & m >= k holds ||. seqi.n - seqi.m .|| < r1;
      end;
      then seqi is Cauchy_sequence_by_Norm by RSSPACE3:10;
      then seqi is convergent & for m be Element of NAT holds
      ex seqm be Element of product carr G st
      seqm= seq.m & seqi.m=seqm.i by A15,A16,LOPBAN_1:def 16;
      hence thesis;
    end;
    consider yy0 be FinSequence such that
A21: dom yy0 = Seg I & for j be Nat st j in Seg I holds PPG[j,yy0.j]
    from FINSEQ_1:sch 1(A11);
    yy0 is Element of product carr G
    proof
      len yy0 = I by A21,FINSEQ_1:def 3;
      then
A22:  len yy0 = len carr G & len yy0 = len G by Def4;
A23:  dom yy0 = Seg len G & dom carr G = Seg len carr G &
      len G = len carr G by A21,Def4,FINSEQ_1:def 3;
      now
        let i be set;
        assume i in dom carr G;
        then reconsider x = i as Element of dom carr G;
        reconsider x as Element of dom G by A22,FINSEQ_3:31;
        reconsider j =x as Element of NAT;
        j in dom G;
        then j in Seg I by FINSEQ_1:def 3;
        then ex i0 be Element of dom G st
        i0=j & ex seqi be sequence of G.i0 st
        seqi is convergent & yy0.j = lim seqi & for m be Element of NAT holds
        ex seqm be Element of product carr G st
        seqm= seq.m & seqi.m=seqm.i0 by A21;
        then yy0.x in the carrier of G.x;
        hence yy0.i in (carr G).i by Def4;
      end;
      hence thesis by A23,CARD_3:18;
    end;
    then reconsider y0=yy0 as Element of product carr G;
    reconsider x0 =y0 as Point of product G by A2;
A24: x0 = y0;
    now
      let i be Element of dom G;
      i in dom G;
      then
A25:  i in Seg I by FINSEQ_1:def 3;
      reconsider j=i as Element of NAT;
      consider i0 be Element of dom G such that
A26:  i0=j & ex seqi be sequence of G.i0 st
      seqi is convergent & yy0.j = lim seqi & for m be Element of NAT holds
      ex seqm be Element of product carr G
      st seqm= seq.m & seqi.m=seqm.i0 by A21,A25;
      consider seqi be sequence of G.i0 such that
A27:  seqi is convergent & yy0.j = lim seqi & for m be Element of NAT holds
      ex seqm be Element of product carr G
      st seqm = seq.m & seqi.m=seqm.i0 by A26;
      reconsider seqi as sequence of G.i by A26;
      take seqi;
      thus seqi is convergent & y0.i = lim seqi &
      for m be Element of NAT holds ex seqm be Element of product carr G st
      seqm= seq.m & seqi.m=seqm.i by A26,A27;
    end;
    hence thesis by A24,Th13;
  end;
  hence thesis by LOPBAN_1:def 16;
end;

