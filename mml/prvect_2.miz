:: The Product Space of Real Normed Spaces and Its Properties
::  by Noboru Endou , Yasunari Shidama and Keiichi Miyajima
::
:: Received July 9, 2007
:: Copyright (c) 2007 Association of Mizar Users

environ

 vocabularies SEQ_1, XREAL_0, ORDINAL1, SUBSET_1, NUMBERS, FUNCT_1, COMPLEX1,
      ARYTM_1, SEQ_2, ORDINAL2, CARD_1, ARYTM_3, XXREAL_0, FINSEQ_1, NAT_1,
      RVSUM_1, SQUARE_1, RELAT_1, CARD_3, FINSEQ_2, ZFMISC_1, MCART_1,
      PRVECT_1, XBOOLE_0, RLVECT_1, GROUP_2, STRUCT_0, ALGSTR_0, BINOP_1,
      VECTSP_1, REAL_1, SUPINF_2, FUNCT_6, FINSEQOP, SETWISEO, NORMSP_1,
      TARSKI, PRE_TOPC, EUCLID, FUNCT_2, REAL_NS1, REWRITE1, RSSPACE3,
      PRVECT_2;
 notations TARSKI, XBOOLE_0, ZFMISC_1, SUBSET_1, ORDINAL1, CARD_3, XCMPLX_0,
      XXREAL_0, NUMBERS, XREAL_0, COMPLEX1, NAT_1, RELAT_1, FUNCT_1, RVSUM_1,
      STRUCT_0, ALGSTR_0, FUNCT_2, FUNCT_3, BINOP_1, REAL_1, SEQ_1, SEQ_2,
      RLVECT_1, VECTSP_1, SETWISEO, FINSEQ_1, FINSEQ_2, FINSEQOP, SQUARE_1,
      PRE_TOPC, EUCLID, PRVECT_1, NORMSP_1, RSSPACE3, LOPBAN_1, REAL_NS1;
 constructors FUNCT_3, FINSEQOP, REAL_1, SEQ_2, COMPLEX1, SQUARE_1, BINOP_2,
      SETWISEO, PRVECT_1, RSSPACE3, LOPBAN_1, REAL_NS1, SEQ_1, RVSUM_1,
      NORMSP_1, RELSET_1;
 registrations STRUCT_0, FINSEQ_2, FINSEQ_1, CARD_3, RLVECT_1, PRVECT_1,
      XREAL_0, MEMBERED, NORMSP_1, REAL_NS1, ORDINAL1, FUNCT_1, FUNCT_2,
      RELAT_1, XBOOLE_0, NUMBERS, VALUED_0;
 requirements NUMERALS, BOOLE, SUBSET, ARITHM;
 definitions RLVECT_1, NORMSP_1, FINSEQ_2, EUCLID, STRUCT_0, SQUARE_1,
      ALGSTR_0;
 theorems BINOP_1, FUNCT_1, FUNCT_2, FINSEQ_1, FINSEQ_2, FINSEQ_3, FINSEQOP,
      FUNCOP_1, SETWISEO, TARSKI, CARD_3, RLVECT_1, RELAT_1, RVSUM_1, ABSVALUE,
      FVSUM_1, SEQ_2, PRVECT_1, NORMSP_1, SQUARE_1, EUCLID, XREAL_1, LOPBAN_1,
      RSSPACE3, REAL_NS1, XXREAL_0, VALUED_1, XREAL_0;
 schemes FUNCT_1, BINOP_1, FUNCT_2, FINSEQ_1, PRVECT_1, CLASSES1;

begin :: The Product Space of Real Linear Spaces

theorem
  for s,t be Real_Sequence, g be real number st for n be Element of NAT
holds t.n = abs(s.n-g) holds s is convergent & lim s = g iff t is convergent &
  lim t = 0
proof
  let s,t be Real_Sequence, g be real number;
  assume
A1: for n be Element of NAT holds t.n=abs(s.n-g);
  hereby
    assume
A2: s is convergent & lim s = g;
A3: now
      let r be real number;
      assume
      0 < r;
      then consider n be Element of NAT such that
A4:   for m be Element of NAT st n<=m holds abs(s.m-g) < r by A2,
      SEQ_2:def 7;
      take n;
      now
        let m be Element of NAT;
        assume
        n<=m;
        then abs (abs(s.m-g)) < r by A4;
        hence abs(t.m-0) < r by A1;
      end;
      hence for m be Element of NAT st n<=m holds abs(t.m-0)< r;
    end;
    hence t is convergent by SEQ_2:def 6;
    hence lim t = 0 by A3,SEQ_2:def 7;
  end;
  assume
A5: t is convergent & lim t = 0;
A6: now
    let r be real number;
    assume
    0 < r;
    then consider n be Element of NAT such that
A7: for m be Element of NAT st n<=m holds abs(t.m-0) < r by A5,
    SEQ_2:def 7;
    take n;
    now
      let m be Element of NAT;
      assume
      n<=m;
      then abs(t.m-0) < r by A7;
      then abs(abs(s.m-g)) < r by A1;
      hence abs(s.m-g) < r;
    end;
    hence for m be Element of NAT st n <= m holds abs(s.m-g) < r;
  end;
  hence s is convergent by SEQ_2:def 6;
  hence thesis by A6,SEQ_2:def 7;
end;

theorem Th2:
  for x,y be FinSequence of REAL st len x = len y & for i be
Element of NAT st i in Seg len x holds 0 <= x.i & x.i <= y.i holds |.x.| <= |.y
  .|
proof
  let x,y be FinSequence of REAL such that
A1: len x = len y and
A2: for i be Element of NAT st i in Seg len x holds 0 <= x.i & x.i <= y.
  i;
A3: for i be Nat st i in Seg len x holds (sqr x).i <= (sqr y).i
  proof
    let i be Nat;
    assume
    i in Seg len x;
    then
A4: 0 <= x.i & x.i <= y.i by A2;
    (x.i)^2=(sqr x).i & (y.i)^2=(sqr y).i by VALUED_1:11;
    hence thesis by A4,SQUARE_1:77;
  end;
  Seg len sqr y = dom sqr y & dom sqr y = dom y by FINSEQ_1:def 3,VALUED_1
  :11;
  then
A5: len sqr y = len y by FINSEQ_1:def 3;
  Seg len sqr x = dom sqr x & dom sqr x = dom x by FINSEQ_1:def 3,VALUED_1
  :11;
  then
A6: len sqr x = len x by FINSEQ_1:def 3;
A7: 0 <= Sum sqr x by RVSUM_1:116;
  sqr x is Element of (len sqr x)-tuples_on REAL & sqr y is Element of (
  len sqr y)-tuples_on REAL by FINSEQ_2:110;
  hence thesis by A1,A3,A6,A5,A7,RVSUM_1:112,SQUARE_1:94;
end;

theorem Th3:
  for F be FinSequence of REAL st for i be Element of NAT st i in
  dom F holds F.i = 0 holds Sum F = 0
proof
  let F be FinSequence of REAL;
  set i = len F;
  set R1 = i|-> 0;
  reconsider R2 = F as Element of i-tuples_on REAL by FINSEQ_2:110;
A1: Seg len F = dom F by FINSEQ_1:def 3;
  assume
A2: for i be Element of NAT st i in dom F holds 0 = F.i;
A3: now
    let j be Nat;
    assume
A4: j in Seg i;
    then R1.j = 0 by FUNCOP_1:13;
    hence R1.j = R2.j by A2,A1,A4;
  end;
  len R1 = i by FINSEQ_1:def 18;
  then dom R1 = dom R2 by FINSEQ_3:31;
  then R1 = R2 by A1,A3,FINSEQ_1:17;
  hence thesis by RVSUM_1:111;
end;

definition
  let f be Function;
  let X be set;
  mode MultOps of X,f -> Function means
    :Def1:
    dom it = dom f & for i being
    set st i in dom f holds it.i is Function of [:X,f.i:],f.i;
  existence
  proof
    deffunc F(set) = pr2(X,f.$1);
    consider g being Function such that
A1: dom g = dom f & for x be set st x in dom f holds g.x = F(x) from
    FUNCT_1:sch 3;
    take g;
    thus dom g = dom f by A1;
    let i be set;
    assume
    i in dom f;
    then g.i = pr2(X,f.i) by A1;
    hence thesis;
  end;
end;

registration
  let F be Domain-Sequence;
  let X be set;
  cluster -> FinSequence-like MultOps of X,F;
  coherence
  proof
    let f be MultOps of X,F;
    dom F = dom f & dom F = Seg len F by Def1,FINSEQ_1:def 3;
    hence thesis by FINSEQ_1:def 2;
  end;
end;

theorem Th4:
  for X be set, F be Domain-Sequence, p be FinSequence holds (p is
  MultOps of X,F iff len p = len F & for i be set st i in dom F holds p.i is
  Function of [:X,F.i:],F.i)
proof
  let X be set;
  let F be Domain-Sequence;
  let p be FinSequence;
  dom p = dom F iff len p = len F by FINSEQ_3:31;
  hence thesis by Def1;
end;

definition
  let F be Domain-Sequence;
  let X be set;
  let p be MultOps of X,F;
  let i be Element of dom F;
  redefine func p.i -> Function of [:X,F.i:],F.i;
  coherence by Th4;
end;

theorem Th5:
  for X be non empty set, F be Domain-Sequence, f,g being Function
  of [:X,product F:],product F st for x be Element of X, d being Element of
product F, i being Element of dom F holds (f.(x,d)).i = (g.(x,d)).i holds f = g
proof
  let X be non empty set;
  let F be Domain-Sequence;
  let f,g being Function of [:X,product F:],product F such that
A1: for x be Element of X, d being Element of product F, i being Element
  of dom F holds (f.(x,d)).i = (g.(x,d)).i;
  now
    let x be Element of X,d being Element of product F;
A2: dom(f.(x,d)) = dom F & dom(g.(x,d)) = dom F by CARD_3:18;
    for v be set st v in dom F holds (f.(x,d)).v = (g.(x,d)).v by A1;
    hence f.(x,d) = g.(x,d) by A2,FUNCT_1:9;
  end;
  hence thesis by BINOP_1:2;
end;

definition
  let F be Domain-Sequence;
  let X be non empty set;
  let p be MultOps of X,F;
  func [:p:] -> Function of [:X,product F:],product F means
  :Def2:
  for x be
Element of X, d being Element of product F, i being Element of dom F holds (it.
  (x,d)).i = (p.i).(x,d.i);
  existence
  proof
    defpred Q[Element of X,Element of product F,Element of product F] means
    for i being Element of dom F holds $3.i = (p.i).($1,$2.i);
A1: for x be Element of X,d being Element of product F ex z being Element
    of product F st Q[x,d,z]
    proof
      let x be Element of X, d be Element of product F;
      defpred P[set,set] means ex i be Element of dom F st $1 =i & $2 = (p.i).
      (x,d.i);
A2:   for w be set st w in dom F ex z be set st P[w,z]
      proof
        let w be set;
        assume
        w in dom F;
        then reconsider i = w as Element of dom F;
        take (p.i).(x,d.i);
        thus thesis;
      end;
      consider z being Function such that
A3:   dom z = dom F & for w being set st w in dom F holds P[w,z.w]
      from CLASSES1:sch 1(A2);
      now
        let w be set;
        assume
        w in dom F;
        then ex i be Element of dom F st w = i & z.w = (p.i).(x,d.i) by A3;
        hence z.w in F.w;
      end;
      then reconsider z9 = z as Element of product F by A3,CARD_3:18;
      take z9;
      let i be Element of dom F;
      ex j being Element of dom F st j = i & z.i = (p.j).(x,d.j) by A3;
      hence thesis;
    end;
    thus ex P being Function of [:X,product F:],product F st for x be Element
of X, d being Element of product F holds Q[x,d,P.(x,d)] from BINOP_1:sch 3(A1);
  end;
  uniqueness
  proof
    let P,Q be Function of [:X,product F:],product F such that
A4: for x be Element of X, f being Element of product F, i being
    Element of dom F holds (P.(x,f)).i = (p.i).(x,f.i) and
A5: for x be Element of X, f being Element of product F, i being
    Element of dom F holds (Q.(x,f)).i = (p.i).(x,f.i);
    now
      let x be Element of X, f being Element of product F;
      let i be Element of dom F;
      (P.(x,f)).i = (p.i).(x,f.i) by A4;
      hence (P.(x,f)).i = (Q.(x,f)).i by A5;
    end;
    hence thesis by Th5;
  end;
end;

definition
  let R be Relation;
  attr R is RealLinearSpace-yielding means
  :Def3:
  for S be set st S in rng R
  holds S is RealLinearSpace;
end;

registration
  cluster non empty RealLinearSpace-yielding FinSequence;
  existence
  proof
    consider S be RealLinearSpace;
    take <*S*>;
    thus <*S*> is non empty;
    let x be set;
    assume that
A1: x in rng <*S*> and
A2: not x is RealLinearSpace;
    x in {S} by A1,FINSEQ_1:55;
    hence contradiction by A2,TARSKI:def 1;
  end;
end;

definition
  mode RealLinearSpace-Sequence is non empty RealLinearSpace-yielding
    FinSequence;
end;

definition
  let G be RealLinearSpace-Sequence;
  let j be Element of dom G;
  redefine func G.j -> RealLinearSpace;
  coherence
  proof
    G.j in rng G by FUNCT_1:def 5;
    hence thesis by Def3;
  end;
end;

definition
  let G be RealLinearSpace-Sequence;
  func carr G -> Domain-Sequence means
  :Def4:
  len it = len G & for j be
  Element of dom G holds it.j = the carrier of G.j;
  existence
  proof
    consider i being Element of dom G;
    defpred P[set,set] means ex j9 being Element of dom G st j9 = $1 & $2 =
    the carrier of G.j9;
A1: for j being Nat st j in Seg len G ex x be set st P[j,x]
    proof
      let j be Nat;
      assume
      j in Seg len G;
      then reconsider j9 = j as Element of dom G by FINSEQ_1:def 3;
      take the carrier of G.j9;
      thus thesis;
    end;
    consider p being FinSequence such that
A2: dom p = Seg len G & for j being Nat st j in Seg len G holds P[j,p.
    j] from FINSEQ_1:sch 1(A1);
    now
      assume
      {} in rng p;
      then consider x be set such that
A3:   x in dom p and
A4:   {} = p.x by FUNCT_1:def 5;
      reconsider x as Element of NAT by A3;
      ex x9 being Element of dom G st x9 = x & p.x = the carrier of G.x9
      by A2,A3;
      hence contradiction by A4;
    end;
    then reconsider q = p as Domain-Sequence by A2,
    FINSEQ_1:def 3,RELAT_1:def 9;
    take q;
    thus len q = len G by A2,FINSEQ_1:def 3;
    let j be Element of dom G;
    reconsider k = j as Element of NAT;
    dom G = Seg len G by FINSEQ_1:def 3;
    then
    ex n being Element of dom G st n = k & q.k = the carrier of G.n by A2;
    hence thesis;
  end;
  uniqueness
  proof
    let f,h be Domain-Sequence such that
A5: len f = len G and
A6: for j be Element of dom G holds f.j = the carrier of G.j and
A7: len h = len G and
A8: for j be Element of dom G holds h.j = the carrier of G.j;
    reconsider f9 = f,h9 = h as FinSequence;
A9: now
      let j be Nat;
      assume
      j in dom f9;
      then reconsider j9 = j as Element of dom G by A5,FINSEQ_3:31;
      f9.j = the carrier of G.j9 by A6;
      hence f9.j = h9.j by A8;
    end;
    dom f9 = Seg len f9 & dom h9 = Seg len h9 by FINSEQ_1:def 3;
    hence thesis by A5,A7,A9,FINSEQ_1:17;
  end;
end;

definition
  let G be RealLinearSpace-Sequence, j be Element of dom carr G;
  redefine func G.j -> RealLinearSpace;
  coherence
  proof
    dom G = Seg len G & Seg len(carr G) = dom carr G by FINSEQ_1:def 3;
    then reconsider j9 = j as Element of dom G by Def4;
    G.j9 is RealLinearSpace;
    hence thesis;
  end;
end;

definition
  let G be RealLinearSpace-Sequence;
  func addop G -> BinOps of carr G means
  :Def5:
  len it = len carr G & for j be
  Element of dom carr G holds it.j = the addF of G.j;
  existence
  proof
    deffunc F(Element of dom carr G) = the addF of G.$1;
    consider p being non empty FinSequence such that
A1: len p = len carr G & for j be Element of dom carr G holds p.j = F(
    j) from PRVECT_1:sch 1;
    now
      let j be Element of dom carr G;
      len G = len carr G by Def4;
      then reconsider k = j as Element of dom G by FINSEQ_3:31;
      p.j = the addF of G.j & the carrier of G.k = (carr G).k by A1,Def4;
      hence p.j is BinOp of (carr G).j;
    end;
    then reconsider p9 = p as BinOps of carr G by A1,PRVECT_1:19;
    take p9;
    thus thesis by A1;
  end;
  uniqueness
  proof
    let f,h be BinOps of carr G;
    assume that
A2: len f = len carr G and
A3: for j be Element of dom carr G holds f.j = the addF of G.j and
A4: len h = len carr G and
A5: for j be Element of dom carr G holds h.j = the addF of G.j;
    reconsider f9 = f,h9 = h as FinSequence;
A6: now
      let i be Nat;
      assume
      i in dom f9;
      then reconsider i9 = i as Element of dom carr G by A2,FINSEQ_3:31;
      f9.i = the addF of G.i9 by A3;
      hence f9.i = h9.i by A5;
    end;
    dom f9 = Seg len f9 & dom h9 = Seg len h9 by FINSEQ_1:def 3;
    hence thesis by A2,A4,A6,FINSEQ_1:17;
  end;
  func complop G -> UnOps of carr G means
  :Def6:
  len it = len carr G & for j
  be Element of dom carr G holds it.j = comp G.j;
  existence
  proof
    deffunc F(Element of dom carr G) = comp G.$1;
    consider p being non empty FinSequence such that
A7: len p = len carr G & for j be Element of dom carr G holds p.j = F
    (j) from PRVECT_1:sch 1;
    now
      let j be Element of dom carr G;
      len G = len (carr G) by Def4;
      then reconsider k = j as Element of dom G by FINSEQ_3:31;
      p.j = comp G.j & the carrier of G.k = (carr G).k by A7,Def4;
      hence p.j is UnOp of (carr G).j;
    end;
    then reconsider p9 = p as UnOps of carr G by A7,PRVECT_1:20;
    take p9;
    thus thesis by A7;
  end;
  uniqueness
  proof
    let f,h be UnOps of carr G;
    assume that
A8: len f = len carr G and
A9: for j be Element of dom carr G holds f.j = comp G.j and
A10: len h = len carr G and
A11: for j be Element of dom carr G holds h.j = comp G.j;
    reconsider f9 = f,h9 = h as FinSequence;
A12: now
      let i be Nat;
      assume
      i in dom f9;
      then reconsider i9 = i as Element of dom carr G by A8,FINSEQ_3:31;
      f.i = comp G.i9 by A9;
      hence f.i = h.i by A11;
    end;
    dom f9 = Seg len f9 & dom h9 = Seg len h9 by FINSEQ_1:def 3;
    hence thesis by A8,A10,A12,FINSEQ_1:17;
  end;
  func zeros G -> Element of product carr G means
  :Def7:
  for j be Element of
  dom carr G holds it.j = the ZeroF of G.j;
  existence
  proof
    deffunc F(Element of dom carr G) = the ZeroF of G.$1;
    consider p being non empty FinSequence such that
A13: len p = len carr G & for j be Element of dom carr G holds p.j = F
    (j) from PRVECT_1:sch 1;
A14: dom (carr G) = Seg len (carr G) by FINSEQ_1:def 3;
A15: dom G = Seg len G by FINSEQ_1:def 3;
A16: now
      let i be set;
      assume
      i in dom (carr G);
      then reconsider x = i as Element of dom carr G;
      reconsider x9 = x as Element of dom G by A15,A14,Def4;
      p.x = the ZeroF of G.x & (carr G).x9 = the carrier of G.x9 by A13,
      Def4;
      hence p.i in (carr G).i;
    end;
    dom p = Seg len p by FINSEQ_1:def 3;
    then reconsider t = p as Element of product (carr G) by A13,A14,
    A16, CARD_3
    :18;
    take t;
    thus thesis by A13;
  end;
  uniqueness
  proof
    let f,h be Element of product carr G;
    assume that
A17: for j be Element of dom carr G holds f.j = the ZeroF of G.j and
A18: for j be Element of dom carr G holds h.j = the ZeroF of G.j;
    reconsider f9 = f, h9 = h as Function;
A19: now
      let x be set;
      assume
      x in dom carr G;
      then reconsider i = x as Element of dom carr G;
      thus f9.x = the ZeroF of G.i by A17
        .= h9.x by A18;
    end;
    dom f9 = dom carr G & dom h9 = dom carr G by CARD_3:18;
    hence thesis by A19,FUNCT_1:9;
  end;
  func multop G -> MultOps of REAL,carr G means
  :Def8:
  len it = len carr G &
  for j be Element of dom carr G holds it.j = the Mult of G.j;
  existence
  proof
    deffunc F(Element of dom carr G) = the Mult of G.$1;
    consider p being non empty FinSequence such that
A20: len p = len carr G & for j be Element of dom carr G holds p.j = F
    (j) from PRVECT_1:sch 1;
    now
      let ai be set;
      assume
      ai in dom carr G;
      then reconsider i=ai as Element of dom carr G;
      len G = len(carr G) by Def4;
      then reconsider j = i as Element of dom G by FINSEQ_3:31;
      p.i = the Mult of G.i & the carrier of G.j = (carr G).j by A20,Def4;
      hence p.ai is Function of [:REAL,(carr G).ai:],(carr G).ai;
    end;
    then reconsider p9 = p as MultOps of REAL, carr G by A20,Th4;
    take p9;
    thus thesis by A20;
  end;
  uniqueness
  proof
    let f,h be MultOps of REAL, carr G;
    assume that
A21: len f = len carr G and
A22: for j be Element of dom carr G holds f.j = the Mult of G.j and
A23: len h = len carr G and
A24: for j be Element of dom carr G holds h.j = the Mult of G.j;
    reconsider f9 = f,h9 = h as FinSequence;
A25: now
      let i be Nat;
      assume
      i in dom f9;
      then reconsider i9 = i as Element of dom carr G by A21,FINSEQ_3:31;
      f9.i = the Mult of G.i9 by A22;
      hence f9.i = h9.i by A24;
    end;
    dom f9 = Seg len f9 & dom h9 = Seg len h9 by FINSEQ_1:def 3;
    hence thesis by A21,A23,A25,FINSEQ_1:17;
  end;
end;

definition
  let G be RealLinearSpace-Sequence;
  func product G -> strict non empty RLSStruct equals
  RLSStruct(# product carr
    G,zeros G,[:addop G :],[:multop G:] #);
  coherence;
end;

Lm1: for LS be non empty addLoopStr st the addF of LS is commutative
associative holds LS is Abelian add-associative

proof
  deffunc ad(addLoopStr) = the addF of $1;
  let LS be non empty addLoopStr;
  assume that
A1: ad(LS) is commutative and
A2: ad(LS) is associative;
  for x,y be Element of LS holds x+y = y+x by A1,BINOP_1:def 2;
  hence LS is Abelian by RLVECT_1:def 5;
  for x,y,z be Element of LS holds x+y+z = x+(y+z) by A2,BINOP_1:def 3;
  hence thesis by RLVECT_1:def 6;
end;

Lm2: for LS be non empty addLoopStr st the ZeroF of LS is_a_unity_wrt the addF
of LS holds LS is right_zeroed

proof
  let LS be non empty addLoopStr;
  assume
A1: the ZeroF of LS is_a_unity_wrt the addF of LS;
  let x be Element of LS;
  thus thesis by A1,BINOP_1:11;
end;

Lm3: for G be RealLinearSpace-Sequence holds for v1,w1 be Element of product
carr G, i be Element of dom carr G holds ([:addop G:].(v1,w1)).i = (the addF of
G.i).(v1.i,w1.i) & for vi,wi be VECTOR of G.i st vi=v1.i & wi=w1.i holds ([:
addop G:].(v1,w1)).i = vi+wi

proof
  let G be RealLinearSpace-Sequence;
  let v1,w1 be Element of product carr G;
  let i be Element of dom carr G;
  ([:addop G:].(v1,w1)).i = ((addop G).i).(v1.i,w1.i) by PRVECT_1:def 10;
  hence thesis by Def5;
end;

Lm4: for G be RealLinearSpace-Sequence, r be Real, v be Element of product
carr G, i be Element of dom carr G holds ([:multop G:].(r,v)).i = (the Mult of
G.i).(r,v.i) & for vi be VECTOR of G.i st vi=v.i holds ([:multop G:].(r,v)).i =
r*vi

proof
  let G be RealLinearSpace-Sequence;
  let r be Real,v be Element of product carr G;
  let i be Element of dom carr G;
  ([:multop G:].(r,v)).i = ((multop G).i).(r,v.i) by Def2;
  hence thesis by Def8;
end;

Lm5: for G be RealLinearSpace-Sequence holds product G is RealLinearSpace-like
proof
  deffunc ad(addLoopStr) = the addF of $1;
  let G be RealLinearSpace-Sequence;

  reconsider GS = RLSStruct(# product carr G,zeros G,[:addop G:],[:multop G:]
  #) as non empty RLSStruct;

  dom G = Seg len G by FINSEQ_1:def 3;
  then dom G = Seg len carr G by Def4;
  then
A1: dom G = dom carr G by FINSEQ_1:def 3;
  now
    let a1,b1 be real number;
    reconsider a=a1,b=b1 as Real by XREAL_0:def 1;
    let v,w be VECTOR of GS;
    reconsider v1=v, w1=w as Element of product carr G;
A2: now
      let x be set;
      assume
      x in dom carr G;
      then reconsider i = x as Element of dom carr G;
      reconsider vi=v1.i as VECTOR of G.i by A1,Def4;
      ( [:multop G:].(1,v1)).x = 1*vi by Lm4;
      hence ([:multop G:].(1,v1)).x =v1.x by RLVECT_1:def 9;
    end;
A3: now
      let x be set;
      assume
      x in dom carr G;
      then reconsider i = x as Element of dom carr G;
      reconsider vi=v1.i as VECTOR of G.i by A1,Def4;
      ([:multop G:].(a+b,v1)).i = (a+b)*vi by Lm4
        .= a*vi+b*vi by RLVECT_1:def 9
        .= ad(G.i).(([:multop G:].(a,v1)).i,b*vi) by Lm4
        .= ad(G.i).(([:multop G:].(a,v1)).i,([:multop G:].(b,v1)).i) by Lm4;

      hence ([:multop G:].((a+b),v1)).x =([:addop G:].([:multop G:].(a,v1),[:
      multop G:].(b,v1))).x by Lm3;

    end;
A4: now
      let x be set;
      assume
      x in dom carr G;
      then reconsider i = x as Element of dom carr G;
      reconsider vi=v1.i, wi=w1.i as VECTOR of G.i by A1,Def4;

      ([:multop G:].(a,[:addop G:].(v1,w1))).i = (the Mult of G.i).(a,([:
      addop G:].(v1,w1)).i) by Lm4

        .= a*(vi+wi) by Lm3
        .= a*vi+a*wi by RLVECT_1:def 9
        .= ad(G.i).(([:multop G:].(a,v1)).i,a*wi) by Lm4
        .= ad(G.i).(([:multop G:].(a,v1)).i,([:multop G:].(a,w1)).i) by Lm4;

      hence ([:multop G:].(a,[:addop G:].(v1,w1))).x =([:addop G:].([:multop G
      :].(a,v1),[:multop G:].(a,w1))).x by Lm3;

    end;

    dom([:multop G:].(a,[:addop G:].(v1,w1))) = dom carr G & dom([:addop G
    :].([: multop G:].(a,v1),[:multop G:].(a,w1))) = dom carr G by CARD_3:18;

    hence a1 * (v + w) = a1 * v + a1 * w by A4,FUNCT_1:9;
A5: now
      let x be set;
      assume
      x in dom carr G;
      then reconsider i = x as Element of dom carr G;
      reconsider vi=v1.i as VECTOR of G.i by A1,Def4;
      ([:multop G:].(a*b,v1)).i = (a*b)*vi by Lm4
        .=a*(b*vi) by RLVECT_1:def 9
        .=(the Mult of G.i).(a,([:multop G:].(b,v1)).i) by Lm4;

      hence
      ([:multop G:].((a*b),v1)).x = ([:multop G:].(a,[:multop G:].(b,v1))
      ).x by Lm4;

    end;

    dom([:multop G:].(a+b,v1)) = dom carr G & dom([:addop G:].([:multop G
    :].(a, v1),[:multop G:].(b,v1))) = dom carr G by CARD_3:18;

    hence (a1 + b1) * v = a1 * v + b1 * v by A3,FUNCT_1:9;

    dom([:multop G:].(a*b,v1)) = dom carr G & dom([:multop G:].(a,[:multop
    G:].( b,v1))) = dom carr G by CARD_3:18;

    hence a1 * b1 * v = a1 * (b1 * v) by A5,FUNCT_1:9;

    dom([:multop G:].(1,v1)) = dom carr G & dom v1 = dom carr G by CARD_3:
    18;

    hence 1 * v = v by A2,FUNCT_1:9;
  end;
  hence thesis by RLVECT_1:def 9;
end;

registration
  let G be RealLinearSpace-Sequence;
  cluster product G -> Abelian add-associative right_zeroed
    right_complementable RealLinearSpace-like;
  coherence
  proof
    deffunc zr(addLoopStr) = the ZeroF of $1;
    reconsider GS = RLSStruct(# product carr G,zeros G, [:addop G:],[:multop G
      :] #) as non empty RLSStruct;
    deffunc car(1-sorted) = the carrier of $1;
    deffunc ad(addLoopStr) = the addF of $1;
A1: now
      let i be Element of dom carr G;
      dom G = Seg len G by FINSEQ_1:def 3
        .= Seg len carr G by Def4
        .= dom carr G by FINSEQ_1:def 3;
      hence (carr G).i = car(G.i) by Def4;
    end;
    now
      let i be Element of dom carr G;
      (addop G).i = ad(G.i) & (carr G).i = car(G.i) by A1,Def5;
      hence (addop G).i is associative by FVSUM_1:3;
    end;
    then
A2: [:addop G:] is associative by PRVECT_1:26;
    now
      let i be Element of dom carr G;
A3:   (zeros G).i = 0.(G.i) by Def7;
      (addop G).i = ad(G.i) & (carr G).i = car(G.i) by A1,Def5;
      hence (zeros G).i is_a_unity_wrt (addop G).i by A3,PRVECT_1:3;
    end;
    then
A4: zeros G is_a_unity_wrt [:addop G:] by PRVECT_1:27;
A5: GS is right_complementable
    proof
      let x be Element of GS;
      reconsider y = (Frege complop G).x as Element of GS by FUNCT_2:7;
      take y;
      now
        let i be Element of dom carr G;
        0.(G.i) = zr(G.i);
        then
A6:     zr(G.i) is_a_unity_wrt ad(G.i) by PRVECT_1:3;
A7:     (complop G).i = comp G.i by Def6;
        (carr G).i = car(G.i) & (addop G).i = ad(G.i) by A1,Def5;
        hence (complop G).i is_an_inverseOp_wrt (addop G).i & (addop G).i is
        having_a_unity by A6,A7,PRVECT_1:4,SETWISEO:def 2;
      end;
      then Frege complop G is_an_inverseOp_wrt [:addop G:] by
      PRVECT_1:28;
      then [:addop G:].(x,y) = the_unity_wrt [:addop G:] by
      FINSEQOP:def 1;
      hence thesis by A4,BINOP_1:def 8;
    end;
    now
      let i be Element of dom carr G;
      (addop G).i = ad(G.i) & (carr G).i = car(G.i) by A1,Def5;
      hence (addop G).i is commutative by FVSUM_1:2;
    end;
    then [:addop G:] is commutative by PRVECT_1:25;
    hence thesis by A2,A4,A5,Lm1,Lm2,Lm5;
  end;
end;

begin :: The Product Space of Real Normed Spaces

definition
  let R be Relation;
  attr R is RealNormSpace-yielding means
  :Def10:
  for x be set st x in rng R
  holds x is RealNormSpace;
end;

registration
  cluster non empty RealNormSpace-yielding FinSequence;
  existence
  proof
    consider A be RealNormSpace;
    take <*A*>;
    thus <*A*> is non empty;
    let x be set;
    assume that
A1: x in rng <*A*> and
A2: not x is RealNormSpace;
    x in {A} by A1,FINSEQ_1:55;
    hence contradiction by A2,TARSKI:def 1;
  end;
end;

definition
  mode RealNormSpace-Sequence is non empty RealNormSpace-yielding FinSequence;
end;

definition
  let G be RealNormSpace-Sequence;
  let j be Element of dom G;
  redefine func G.j -> RealNormSpace;
  coherence
  proof
    G.j in rng G by FUNCT_1:def 5;
    hence thesis by Def10;
  end;
end;

Lm6: for g be RealNormSpace-yielding FinSequence holds g is
RealLinearSpace-yielding

proof
  let g be RealNormSpace-yielding FinSequence;
  for x be set st x in rng g holds x is RealLinearSpace by Def10;
  hence thesis by Def3;
end;

registration
  cluster RealNormSpace-yielding -> RealLinearSpace-yielding FinSequence;
  coherence by Lm6;
end;

definition
  let G be RealNormSpace-Sequence;
  let x be Element of product carr G;
  func normsequence(G,x) -> Element of REAL len G means
  :Def11:
  len it = len G
  & for j be Element of dom G holds it.j=(the norm of G.j).(x.j);
  existence
  proof
    deffunc F(Element of dom G) = (the norm of G.$1).(x.$1);
    consider f being Function of dom G,REAL such that
A1: for j being Element of dom G holds f.j = F(j) from FUNCT_2:sch 4;
A2: rng f c= REAL;
    dom f = dom G by FUNCT_2:def 1;
    then
A3: dom f = Seg len G by FINSEQ_1:def 3;
    then f is FinSequence by FINSEQ_1:def 2;
    then reconsider f as FinSequence of REAL by A2,FINSEQ_1:def 4;
A4: f in REAL* by FINSEQ_1:def 11;
    len f = len G by A3,FINSEQ_1:def 3;
    then f in (len G)-tuples_on REAL by A4;
    then reconsider f as Element of REAL (len G);
    take f;
    thus len f = len G by FINSEQ_1:def 18;
    let j be Element of dom G;
    thus thesis by A1;
  end;
  uniqueness
  proof
    let f,g be Element of REAL len G;
    assume that
    len f = len G and
A5: for j being Element of dom G holds f.j = (the norm of G.j).(x.j) and
    len g = len G and
A6: for j being Element of dom G holds g.j = (the norm of G.j).(x.j);
    now
      let j be Nat;
      assume
      j in Seg len G;
      then reconsider j1=j as Element of dom G by FINSEQ_1:def 3;
      f.j = (the norm of G.j1).(x.j1) by A5;
      hence f.j = g.j by A6;
    end;
    hence thesis by FINSEQ_2:139;
  end;
end;

definition
  let G be RealNormSpace-Sequence;
  func productnorm G -> Function of product carr (G qua
  RealLinearSpace-Sequence),REAL means
  :Def12:
  for x being Element of product
  carr G holds it.x = |.normsequence(G,x).|;
  existence
  proof
    deffunc F(Element of product carr G) = |.normsequence(G,$1).|;
    consider f being Function of product carr G, REAL such that
A1: for x being Element of product carr G holds f.x = F(x) from
    FUNCT_2:sch 4;
    take f;
    let x be Element of product carr G;
    thus thesis by A1;
  end;
  uniqueness
  proof
    let f,g be Function of product carr G,REAL;
    assume that
A2: for x being Element of product carr G holds f.x = |.normsequence(G
    ,x).| and
A3: for x being Element of product carr G holds g.x = |.normsequence(G
    ,x).|;
    now
      let x be Element of product carr G;
      f.x = |.normsequence(G,x).| by A2;
      hence f.x = g.x by A3;
    end;
    hence thesis by FUNCT_2:113;
  end;
end;

definition
  let G be RealNormSpace-Sequence;
  func product G -> strict non empty NORMSTR means
  :Def13:
  the RLSStruct of it
  = product (G qua RealLinearSpace-Sequence) & the norm of it = productnorm G;
  existence
  proof
    reconsider G0=NORMSTR(# product carr G,zeros G,[:addop G :],[:multop G:],
      productnorm G #) as strict non empty NORMSTR;
    take G0;
    thus thesis;
  end;
  uniqueness;
end;

reserve G for RealNormSpace-Sequence;

theorem Th6:
  product G = NORMSTR(# product carr G,zeros G,[:addop G:],[:multop
    G:], productnorm G #)
proof
  the RLSStruct of product G = product(G qua RealLinearSpace-Sequence) by
  Def13;
  hence thesis by Def13;
end;

theorem Th7:
  for x be VECTOR of product G, y be Element of product carr G st x
  = y holds ||.x.|| = |.normsequence(G,y).|
proof
  let x be VECTOR of product G;
  let y be Element of product carr G;
  assume
A1: x=y;
  product G = NORMSTR(# product carr G,zeros G,[:addop G:], [:multop G:],
    productnorm G #) by Th6;
  hence thesis by A1,Def12;
end;

theorem Th8:
  for x,y,z be Element of product carr G, i be Element of NAT st i
in dom x & z = [:addop G :].(x,y) holds normsequence(G,z).i <= (normsequence(G,
  x) + normsequence(G,y)).i
proof
  let x,y,z be Element of product carr G, i be Element of NAT such that
A1: i in dom x and
A2: z = [: addop G :].(x,y);
  reconsider i0=i as Element of dom (carr G) by A1,CARD_3:18;
A3: z.i0 = ((addop G).i0).(x.i0,y.i0) by A2,PRVECT_1:def 10;
  dom G = Seg len G by FINSEQ_1:def 3
    .= Seg len carr G by Def4
    .= dom carr G by FINSEQ_1:def 3;
  then reconsider i0=i as Element of dom G by A1,CARD_3:18;
  dom x = dom(carr G) & (carr G).i0 = the carrier of G.i0 by Def4,CARD_3:
  18;
  then reconsider xi0=x.i0,yi0=y.i0,zi0=z.i0 as Element of G.i0 by A1,
  CARD_3:18;
  ||.zi0.|| = ||.xi0+yi0.|| by A3,Def5;
  then
A4: ||.zi0.|| <= ||.xi0.|| + ||.yi0.|| by NORMSP_1:def 2;
A5: normsequence(G,x).i0 + normsequence(G,y).i0 = (normsequence(G,x) +
  normsequence(G,y)).i0 by RVSUM_1:27;
  (the norm of G.i0).yi0 = normsequence(G,y).i0 & (the norm of G.i0).zi0 =
  normsequence(G,z).i0 by Def11;
  hence thesis by A4,A5,Def11;
end;

theorem Th9:
  for x be Element of product carr G, i be Element of NAT st i in
  dom x holds 0 <= normsequence(G,x).i
proof
  let x be Element of product carr G, i be Element of NAT such that
A1: i in dom x;
  dom G = Seg len G by FINSEQ_1:def 3
    .= Seg len carr G by Def4
    .= dom carr G by FINSEQ_1:def 3;
  then reconsider i0=i as Element of dom G by A1,CARD_3:18;
  dom x = dom carr G & (carr G).i0 = the carrier of G.i0 by Def4,CARD_3:18;
  then reconsider xi0=x.i0 as Element of G.i0 by A1,CARD_3:18;
  0<= ||.xi0.|| by NORMSP_1:8;
  hence thesis by Def11;
end;

Lm7: product G is RealNormSpace-like
proof
  let x,y being Point of product G, a be Real;
  reconsider n = len G as Element of NAT;

A1: product G = NORMSTR(# product carr G,zeros G,[:addop G:], [:multop G:],
    productnorm G #) by Th6;

  then reconsider z=x as Element of product carr G;
  reconsider xx = x, yy = y as Element of product carr G by A1;
  reconsider ax=a * x as Element of product carr G by A1;

A2: ||.y.|| = |.normsequence(G,yy).| & |.normsequence(G,xx)+ normsequence(G
  ,yy) .| <= |.normsequence(G,xx).| + |.normsequence(G,yy).| by Th7,EUCLID:15;

A3: len G = len carr G by Def4;
A4: ||.x.|| = 0 implies x = 0.(product G)
  proof
    reconsider z=x as Element of product carr G by A1;
    assume
A5: ||.x.|| = 0;
    now
      let i be Element of dom carr G;
      reconsider i0 = i as Element of dom G by A3,FINSEQ_3:31;
      dom carr G = Seg len carr G by FINSEQ_1:def 3;
      then
A6:   dom carr G = Seg len G by Def4;
      (carr G).i0 = the carrier of G.i0 by Def4;
      then reconsider zzi0=z.i0 as Element of G.i0 by CARD_3:18;
      ||.x.|| = |.normsequence(G,z).| by Th7;
      then normsequence(G,z) = 0*n by A5,EUCLID:11;
      then normsequence(G,z).i = 0 by A6,FUNCOP_1:13;
      then ||.(zzi0).|| = 0 by Def11;
      then z.i = 0.(G.i) by NORMSP_1:def 2;
      hence z.i = the ZeroF of (G.i);
    end;
    hence thesis by A1,Def7;
  end;
A7: len normsequence(G,ax) = n by FINSEQ_1:def 18;
  then
A8: dom normsequence(G,ax) = Seg n by FINSEQ_1:def 3;

A9: for i be Nat st i in dom normsequence(G,ax) holds normsequence(G,ax).i
  = (abs(a) * normsequence(G,z)).i

  proof
    let i be Nat;
    assume
    i in dom normsequence(G,ax);
    then reconsider i0 = i as Element of dom G by A8,FINSEQ_1:def 3;
    reconsider i1 = i0 as Element of dom carr G by A3,FINSEQ_3:31;

    (carr G).i0 = the carrier of G.i0 & dom carr G = dom G by A3,Def4,
    FINSEQ_3:31;

    then reconsider axi0=ax.i0, zi0 = z.i0 as Element of G.i0 by CARD_3:18;
    ( [:multop G:].(a,z)).i1 = ((multop G).i1).(a,zi0) by Def2;
    then axi0 = a * zi0 by A1,Def8;
    then ||.axi0.|| = abs(a) * ||. zi0 .|| by NORMSP_1:def 2;
    then ||.axi0.|| = abs(a) * normsequence(G,z).i0 by Def11;
    then ||.axi0.|| = (abs(a) * normsequence(G,z)).i0 by RVSUM_1:66;
    hence thesis by Def11;
  end;
  len (abs(a) * normsequence(G,z)) = n by FINSEQ_1:def 18;

  then |.normsequence(G,ax).| = |.abs(a)*normsequence(G,z).| by A7,A9,
  FINSEQ_2:10;

  then
A10: |.normsequence(G,ax).| = abs(abs a) * |.normsequence(G,z).| by
  EUCLID:14;

  reconsider z = x + y as Element of product carr G by A1;

A11: for i be Element of NAT st i in Seg n holds 0 <= normsequence(G,z).i &
  normsequence(G,z).i <= (normsequence(G,xx)+ normsequence(G,yy)).i

  proof
A12: dom xx = dom carr G by CARD_3:18;
A13: Seg n = dom G & dom carr G = dom G by A3,FINSEQ_1:def 3,FINSEQ_3:31;
    let i be Element of NAT such that
A14: i in Seg n;
    i in dom z by A14,A13,CARD_3:18;
    hence thesis by A1,A14,A13,A12,Th8,Th9;
  end;
A15: len normsequence(G,z) = n by Def11;

  then
  len normsequence(G,z) = len (normsequence(G,xx)+ normsequence(G,yy)) by
  FINSEQ_1:def 18;

  then
A16: |.normsequence(G,z).| <= |.normsequence(G,xx)+ normsequence(G,yy).| by
  A15,A11,Th2;

A17: x = 0.(product G) implies ||.x.|| = 0
  proof
    reconsider z=x as Element of product carr G by A1;
    assume
A18: x = 0.(product G);
A19: for i be Element of dom carr G holds normsequence(G,z).i = 0
    proof
      let i be Element of dom carr G;
      reconsider i0 = i as Element of dom G by A3,FINSEQ_3:31;
      (carr G).i0 = the carrier of G.i0 by Def4;
      then reconsider zi0=z.i0 as Element of G.i0 by CARD_3:18;
      z.i = 0.(G.i) by A1,A18,Def7;
      then ||.zi0.|| = 0;
      hence thesis by Def11;
    end;

    for i be Element of NAT st i in dom (sqr normsequence(G,z)) holds (
    sqr normsequence(G,z)).i = 0

    proof
      let i be Element of NAT;
      assume
A20:  i in dom sqr normsequence(G,z);
      len normsequence(G,z) = len G by Def11;
      then
A21:  dom normsequence(G,z) = dom G by FINSEQ_3:31;
      dom carr G = dom G by A3,FINSEQ_3:31;
      then dom sqr normsequence(G,z) = dom carr G by A21,VALUED_1:11;
      then (normsequence(G,z).i)^2 = 0^2 by A19,A20;
      hence thesis by VALUED_1:11;
    end;
    then |.normsequence(G,z).| = 0 by Th3,SQUARE_1:82;
    hence thesis by Th7;
  end;

  ||.x + y.|| = |.normsequence(G,z).| & ||.x.|| = |.normsequence(G,xx).|
  by Th7;

  hence thesis by A4,A17,A10,A16,A2,Th7,XXREAL_0:2;
end;

registration
  let G be RealNormSpace-Sequence;
  cluster product G -> RealNormSpace-like RealLinearSpace-like Abelian
    add-associative right_zeroed right_complementable;
  coherence
  proof
    reconsider G1=G as RealLinearSpace-Sequence;
A1: the RLSStruct of product G = product (G qua RealLinearSpace-Sequence)
    by Def13;
A2: now
      let v be VECTOR of product G;
      reconsider v1=v as VECTOR of product G1 by A1;
      1 * v = 1 * v1 by A1;
      hence 1 * v = v by RLVECT_1:def 9;
    end;
A3: product G is right_complementable
    proof
      let v be VECTOR of product G;
      reconsider v1=v as VECTOR of product G1 by A1;
      reconsider w=-v1 as VECTOR of product G by A1;
      take w;
      v+w = v1-v1 by A1;
      then v+w = 0.product G1 by RLVECT_1:28;
      hence thesis by A1;
    end;
A4: now
      let a be real number;
      let v,w be VECTOR of product G;
      reconsider v1=v,w1=w as VECTOR of product G1 by A1;
      a * (v + w) = a * (v1 + w1) by A1;
      then a * (v + w) =a * v1 + a * w1 by RLVECT_1:def 9;
      hence a * (v + w) = a*v +a*w by A1;
    end;
A5: now
      let a,b be real number, v be VECTOR of product G;
      reconsider v1=v as VECTOR of product G1 by A1;
      (a*b) * v = (a*b) * v1 by A1;
      then (a*b) * v = a * (b * v1) by RLVECT_1:def 9;
      hence (a*b) * v = a*(b*v) by A1;
    end;
A6: now
      let a,b be real number, v be VECTOR of product G;
      reconsider v1=v as VECTOR of product G1 by A1;
      (a+b) * v = (a+b) * v1 by A1;
      then (a+b) * v = a * v1 + b * v1 by RLVECT_1:def 9;
      hence (a+b) * v =a*v +b*v by A1;
    end;
A7: product G is add-associative
    proof
      let v,w,x be VECTOR of product G;
      reconsider v1=v,w1=w,x1=x as VECTOR of product G1 by A1;
      (v+w)+x = (v1+w1)+x1 by A1;
      then (v+w)+x =v1+(w1+x1) by RLVECT_1:def 6;
      hence thesis by A1;
    end;
A8: product G is Abelian
    proof
      let v,w be VECTOR of product G;
      reconsider v1=v,w1=w as VECTOR of product G1 by A1;
      v+w =v1+w1 by A1;
      then v+w =w1+v1;
      hence thesis by A1;
    end;
    product G is right_zeroed
    proof
      let v be VECTOR of product G;
      reconsider v1=v as VECTOR of product G1 by A1;
      v+0.product G = v1+0.product G1 by A1;
      hence thesis by RLVECT_1:def 7;
    end;
    hence thesis by A8,A7,A3,A4,A6,A5,A2,Lm7,RLVECT_1:def 9;
  end;
end;

theorem Th10:
  for G be RealNormSpace-Sequence, i be Element of dom G, x be
Point of product G, y be Element of product carr G, xi be Point of G.i st y = x
  & xi = y.i holds ||.xi.|| <= ||.x.||
proof
  let G be RealNormSpace-Sequence, i be Element of dom G, x be Point of
  product G, y be Element of product carr G, xi be Point of G.i;
  reconsider n = len G as Element of NAT;
  assume that
A1: y=x and
A2: xi=y.i;
A3: (normsequence(G,y).i)^2 = (sqr normsequence(G,y)).i by VALUED_1:11;
A4: for i be Element of NAT st i in Seg n holds 0 <= (sqr normsequence(G,y))
  .i
  proof
    let i be Element of NAT such that
    i in Seg n;
    (normsequence(G,y).i)^2 >= 0 by XREAL_1:65;
    hence thesis by VALUED_1:11;
  end;
  dom G = Seg n by FINSEQ_1:def 3;
  then
A5: 0 <= (normsequence(G,y).i)^2 & (sqr normsequence(G,y)).i <= Sum sqr
  normsequence(G,y) by A4,REAL_NS1:7,XREAL_1:65;
  ||.xi.|| = normsequence(G,y).i by A2,Def11;
  then sqrt ((sqr normsequence(G,y)).i) = normsequence(G,y).i by A3,
  NORMSP_1:8,SQUARE_1:89;
  then
A6: ||.xi.|| = sqrt ((sqr normsequence(G,y)).i) by A2,Def11;
  ||.x.|| = |.normsequence(G,y).| by A1,Th7;
  hence thesis by A3,A5,A6,SQUARE_1:94;
end;

Lm8: for RNS be RealNormSpace, S be sequence of RNS, g be Point of RNS holds S
is convergent & lim S = g iff ||.S - g.|| is convergent & lim ||.S - g.|| = 0

proof
  let RNS be RealNormSpace, S be sequence of RNS, g be Point of RNS;
  now
    assume
A1: ||.S - g.|| is convergent & lim ||.S - g.|| = 0;
A2: now
      let r be Real;
      reconsider p=r as real number;
      assume
      0 < r;
      then consider n be Element of NAT such that

A3:   for m be Element of NAT st n<=m holds abs (||.S - g.||.m-0) < p
      by A1,SEQ_2:def 7;

      take n;
      now
        let m be Element of NAT;
        assume
        n<=m;
        then abs (||.S - g.||.m-0) < p by A3;
        then abs ||.(S - g).m.|| < p by NORMSP_1:def 10;
        then
A4:     abs ||.S.m - g.|| < p by NORMSP_1:def 7;
        0 <= ||.S.m - g.|| by NORMSP_1:8;
        hence ||.S.m - g.|| < p by A4,ABSVALUE:def 1;
      end;
      hence for m be Element of NAT st n<=m holds ||.S.m - g.|| < r;
    end;
    hence S is convergent by NORMSP_1:def 9;
    hence lim S = g by A2,NORMSP_1:def 11;
  end;
  hence thesis by NORMSP_1:41;
end;

theorem Th11:
  for G be RealNormSpace-Sequence, i be Element of dom G, x,y be
  Point of product G, xi,yi be Point of G.i, zx,zy be Element of product carr G
  st xi=zx.i & zx=x & yi=zy.i & zy=y holds ||.yi - xi.|| <= ||.y - x.||
proof
  let G be RealNormSpace-Sequence, i be Element of dom G, x,y be Point of
  product G, xi,yi be Point of G.i, zx,zy be Element of product carr G;
  assume that
A1: xi=zx.i and
A2: zx=x and
A3: yi=zy.i and
A4: zy=y;
  reconsider zyi = zy.i, zxi = zx.i as Element of G.i by A1,A3;
A5: product G = NORMSTR(# product carr G,zeros G,[:addop G:],[:multop G:],
    productnorm G #) by Th6;
  then reconsider mzx =-x as Element of product carr G;
  len G = len carr G by Def4;
  then
A6: dom G = dom carr G by FINSEQ_3:31;
  -x = (-1) * x by RLVECT_1:29;
  then
A7: mzx.i = (-1) * zxi by A2,A5,A6,Lm4;
  then reconsider mzxi = mzx.i as Element of G.i;
  reconsider zyMm = y-x as Element of product carr G by A5;
  zyMm.i =zyi+mzxi by A4,A5,A6,Lm3;
  then zyMm.i =zyi+-zxi by A7,RLVECT_1:29;
  hence thesis by A1,A3,Th10;
end;

theorem
  for G be RealNormSpace-Sequence, seq be sequence of (product G), x0 be
  Point of product G, y0 be Element of product carr G st x0 = y0 & seq is
convergent & lim seq=x0 holds for i be Element of dom G ex seqi be sequence of
G.i st seqi is convergent & y0.i = lim seqi & for m be Element of NAT holds ex
  seqm be Element of product carr G st seqm= seq.m & seqi.m=seqm.i
proof
  let G be RealNormSpace-Sequence, seq be sequence of (product G), x0 be Point
  of product G, y0 be Element of product carr G;
  assume that
A1: x0 = y0 and
A2: seq is convergent & lim seq=x0;
  let i be Element of dom G;
  defpred P1[Element of NAT,Element of G.i] means ex seqm be Element of
  product carr G st seqm = seq.$1 & $2 = seqm.i;
  len G = len carr G by Def4;
  then
A3: dom G = dom carr G by FINSEQ_3:31;
  then y0.i in (carr G).i by CARD_3:18;
  then reconsider x0i=y0.i as Point of G.i by Def4;
A4: for x being Element of NAT ex y being Element of G.i st P1[x,y]
  proof
    let x be Element of NAT;
    product G = NORMSTR(# product carr G,zeros G,[:addop G:], [:multop G:]
      ,productnorm G #) by Th6;
    then consider seqm be Element of product carr G such that
A5: seqm =seq.x;
    take y = seqm.i;
    (carr G).i = the carrier of G.i by Def4;
    hence thesis by A3,A5,CARD_3:18;
  end;
  ex f be Function of NAT,the carrier of G.i st for x being Element of NAT
  holds P1[x,f.x] from FUNCT_2:sch 3(A4);
  then consider seqi be sequence of G.i such that
A6: for m be Element of NAT holds ex seqm be Element of product carr G
  st seqm= seq.m & seqi.m=seqm.i;
  take seqi;
A7: for r be Real st 0 < r ex m be Element of NAT st for n be Element of
  NAT st m <= n holds ||.seqi.n - x0i.|| < r
  proof
    let r be Real;
    assume
    r > 0;
    then consider k be Element of NAT such that
A8: for n be Element of NAT st k <= n holds ||.seq.n - x0.|| < r by
    A2,NORMSP_1:def 11;
    now
      let n be Element of NAT;
      assume
      n >= k;
      then
A9:   ||.(seq.n) - x0.|| < r by A8;
      ex seqn be Element of product carr G st seqn = seq.n & seqi.n =
      seqn.i by A6;
      then ||. seqi.n - x0i.|| <= ||. seq.n - x0.|| by A1,Th11;
      hence ||.(seqi.n) - x0i.|| < r by A9,XXREAL_0:2;
    end;
    hence thesis;
  end;
  then seqi is convergent by NORMSP_1:def 9;
  hence thesis by A6,A7,NORMSP_1:def 11;
end;

theorem Th13:
  for G be RealNormSpace-Sequence, seq be sequence of (product G),
  x0 be Point of product G, y0 be Element of product carr G st x0=y0 & for i be
Element of dom G ex seqi be sequence of G.i st seqi is convergent & y0.i = lim
  seqi & for m be Element of NAT holds ex seqm be Element of product carr G st
  seqm= seq.m & seqi.m=seqm.i holds seq is convergent & lim seq=x0
proof
  let G be RealNormSpace-Sequence, seq be sequence of (product G), x0 be Point
  of product G, y0 be Element of product carr G;
  assume that
A1: x0=y0 and
A2: for i be Element of dom G ex seqi be sequence of G.i st seqi is
convergent & y0.i = lim seqi & for m be Element of NAT holds ex seqm be Element
  of product carr G st seqm= seq.m & seqi.m=seqm.i;
  defpred PP[Element of dom G, set] means ex rseqi be Real_Sequence, seqi be
  sequence of G.$1 st rseqi=$2 & seqi is convergent & rseqi is convergent & lim
rseqi=0 & rseqi=||.seqi-lim seqi.|| & for m be Element of NAT holds ex seqm be
  Element of product carr G st seqm= seq.m & seqi.m=seqm.$1;
A3: for i be Element of dom G ex yyseqi be Element of Funcs(NAT,REAL) st PP[
  i,yyseqi]
  proof
    let i be Element of dom G;
    consider seqi be sequence of G.i such that
A4: seqi is convergent and
    y0.i = lim seqi and
A5: for m be Element of NAT holds ex Sm be Element of product carr G
    st Sm= seq.m & seqi.m=Sm.i by A2;
    set rseqi=||.seqi-lim seqi.||;
A6: rseqi is Element of Funcs(NAT,REAL) by FUNCT_2:11;
    rseqi is convergent & lim rseqi=0 by A4,Lm8;
    hence thesis by A4,A5,A6;
  end;
  consider yyseq be Function of (dom G),Funcs(NAT,REAL) such that
A7: for i be Element of dom G holds PP[i,yyseq.i] from FUNCT_2:sch 3(A3);
  reconsider I = len G as Element of NAT;
  defpred PQ[Element of NAT,Element of (REAL I)] means for i be Element of dom
  G holds (yyseq.i).$1 = $2.i;
A8: for k be Element of NAT ex yseqk be Element of (REAL I) st PQ[k,yseqk]
  proof
    let k be Element of NAT;
    defpred PPF[set,set] means ex i be Element of dom G st i=$1 & $2 = (yyseq.
    i).k;
A9: for k be Nat st k in Seg I ex x be set st PPF[k,x]
    proof
      let j be Nat;
      assume
      j in Seg I;
      then reconsider i=j as Element of dom G by FINSEQ_1:def 3;
      take (yyseq.i).k;
      thus thesis;
    end;
    consider yseqk be FinSequence such that
A10: dom yseqk = Seg I & for j be Nat st j in Seg I holds PPF[j,yseqk.
    j] from FINSEQ_1:sch 1(A9);
    now
      let j be Nat;
      assume
      j in dom yseqk;
      then consider i be Element of dom G such that
      i=j and
A11:  yseqk.j= (yyseq.i).k by A10;
      yyseq.i is Function of NAT,REAL by FUNCT_2:121;
      hence yseqk.j in REAL by A11,FUNCT_2:7;
    end;
    then reconsider yyy=yseqk as FinSequence of REAL by FINSEQ_2:14;
    yyy is Element of (len yyy)-tuples_on REAL by FINSEQ_2:110;
    then reconsider yseqk as Element of (REAL I) by A10,FINSEQ_1:def 3;
    now
      let j be Element of dom G;
      j in dom G;
      then j in Seg I by FINSEQ_1:def 3;
      then ex i be Element of dom G st i=j & yseqk.j= (yyseq.i).k by A10;
      hence yseqk.j= (yyseq.j).k;
    end;
    hence thesis;
  end;
  consider yseq be Function of NAT,REAL I such that
A12: for k be Element of NAT holds PQ[k,yseq.k] from FUNCT_2:sch 3(A8);
A13: now
    let i0 be Element of NAT;
    assume
A14: i0 in Seg I;
    then reconsider i=i0 as Element of dom G by FINSEQ_1:def 3;
    take i;
    consider rseqi be Real_Sequence, seqi be sequence of G.i such that
A15: rseqi=yyseq.i & seqi is convergent & rseqi is convergent & lim
rseqi= 0 &( rseqi=||.seqi-lim seqi.|| & for m be Element of NAT holds ex seqm
    be Element of product carr G st seqm= seq.m & seqi.m=seqm.i) by A7;
    take rseqi,seqi;
    thus (for k be Element of NAT holds rseqi.k = (yseq.k).i0) & i=i0 & seqi
    is convergent & rseqi is convergent & lim rseqi=(0*I).i & rseqi=||.seqi-lim
seqi.|| & for m be Element of NAT holds ex seqm be Element of product carr G st
    seqm= seq.m & seqi.m=seqm.i by A12,A14,A15,FUNCOP_1:13;
  end;
  the carrier of REAL-NS I = REAL I by REAL_NS1:def 4;
  then reconsider xseq=yseq as sequence of REAL-NS I;
  xseq = yseq;
  then consider
  xseq be sequence of REAL-NS I, yseq be Function of NAT,REAL I such
  that
A16: xseq=yseq and
A17: for i0 be Element of NAT st i0 in Seg I ex i be Element of dom G,
  rseqi be Real_Sequence, seqi be sequence of G.i st (for k be Element of NAT
holds rseqi.k = (yseq.k).i0) & i=i0 & seqi is convergent & rseqi is convergent
& lim rseqi=(0*I).i & rseqi=||.seqi-lim seqi.|| & for m be Element of NAT holds
  ex seqm be Element of product carr G st seqm= seq.m & seqi.m=seqm.i by A13;
A18: for i be Element of NAT st i in Seg I ex rseqi be Real_Sequence st (for
k be Element of NAT holds rseqi.k = (yseq.k).i) & rseqi is convergent & (0*I).i
  = lim rseqi
  proof
    let i0 be Element of NAT;
    assume
    i0 in Seg I;
    then
    ex i be Element of dom G, rseqi be Real_Sequence, seqi be sequence of
G.i st (for k be Element of NAT holds rseqi.k = (yseq.k).i0) & i=i0 & seqi is
convergent & rseqi is convergent & lim rseqi=(0*I).i & rseqi=||.seqi-lim seqi
    .|| & for m be Element of NAT holds ex seqm be Element of product carr G st
    seqm= seq.m & seqi.m=seqm.i by A17;
    hence thesis;
  end;
A19: product G = NORMSTR(# product carr G,zeros G, [:addop G:],[:multop G:],
    productnorm G #) by Th6;
  now
    let x be set;
    assume
    x in NAT;
    then reconsider i=x as Element of NAT;
    reconsider seqimx0 = seq.i-x0 as Element of product carr G by A19;
A20: now
      reconsider mx0=-x0 as Element of product carr G by A19;
      let k be Nat;
      assume
A21:  k in dom normsequence(G,seqimx0);
A22:  len G= len normsequence(G,seqimx0) by Def11;
      then reconsider k0=k as Element of dom G by A21,FINSEQ_3:31;
      k in Seg I by A21,A22,FINSEQ_1:def 3;
      then consider
      k1 be Element of dom G, rseqk1i be Real_Sequence, seqk1i be
      sequence of G.k1 such that
A23:  for j be Element of NAT holds rseqk1i.j = (yseq.j).k and
A24:  k1=k and
      seqk1i is convergent and
      rseqk1i is convergent and
      lim rseqk1i=(0*I).k1 and
A25:  rseqk1i=||.seqk1i-lim seqk1i.|| and
A26:  for m be Element of NAT holds ex seqk1m be Element of product
      carr G st seqk1m= seq.m & seqk1i.m=seqk1m.k1 by A17;
      consider seqk0 be sequence of G.k0 such that
      seqk0 is convergent and
A27:  y0.k0 = lim seqk0 and
A28:  for m be Element of NAT holds ex seqm0 be Element of product
      carr G st seqm0= seq.m & seqk0.m=seqm0.k0 by A2;
A29:  ex seqm0 be Element of product carr G st seqm0= seq.i & seqk0.i=
      seqm0.k0 by A28;
      now
        let x be set;
        assume
        x in NAT;
        then reconsider m = x as Element of NAT;
        ( ex seqk1m be Element of product carr G st seqk1m= seq.m &
seqk1i.m=seqk1m.k1) & ex seqm0 be Element of product carr G st seqm0= seq.m &
        seqk0.m = seqm0.k0 by A28,A26;
        hence seqk1i.x = seqk0.x by A24;
      end;
      then
A30:  seqk1i=seqk0 by A24,FUNCT_2:18;
      len G = len carr G by Def4;
      then
A31:  dom G = dom carr G by FINSEQ_3:31;
      -x0 = (-1) * x0 by RLVECT_1:29;
      then mx0.k0 = (-1)*(lim seqk0) by A1,A19,A27,A31,Lm4;
      then -(lim seqk0) = mx0.k0 by RLVECT_1:29;
      then
A32:  seqimx0.k0 = seqk0.i - lim seqk0 by A19,A29,A31,Lm3;
      thus (normsequence(G,seqimx0)).k = (the norm of G.k0).(seqimx0.k0) by
      Def11
        .= ||.(seqk0 -lim seqk0).i .|| by A32,NORMSP_1:def 7
        .= (||.seqk1i - (lim seqk1i).||).i by A24,A30,NORMSP_1:def 10
        .= (yseq.i).k by A23,A25;
    end;
    len (yseq.i)= I by FINSEQ_1:def 18;
    then len (yseq.i) = len normsequence(G,seqimx0) by Def11;
    then dom (yseq.i) = dom normsequence(G,seqimx0) by FINSEQ_3:31;
    then
A33: yseq.i = normsequence(G,seqimx0) by A20,FINSEQ_1:17;
    thus ||.xseq-0.(REAL-NS I).||.x =||.(xseq-0.(REAL-NS I)).i .|| by NORMSP_1
    :def 10
      .=||.xseq.i-0.(REAL-NS I).|| by NORMSP_1:def 7
      .=||.xseq.i.|| by RLVECT_1:26
      .=|.yseq.i.| by A16,REAL_NS1:1
      .=||.seq.i -x0.|| by A33,Th7
      .=||.(seq -x0).i.|| by NORMSP_1:def 7
      .=||.seq-x0.||.x by NORMSP_1:def 10;
  end;
  then
A34: ||.xseq-0.(REAL-NS I).|| =||.seq-x0.|| by FUNCT_2:18;
  (0*I) = 0.(REAL-NS I) by REAL_NS1:def 4;
  then xseq is convergent & lim xseq = 0.(REAL-NS I) by A16,A18,REAL_NS1:
  11;
  then ||.seq-x0.|| is convergent & lim ||.seq-x0.|| =0 by A34,Lm8;
  hence thesis by Lm8;
end;

theorem
  for G be RealNormSpace-Sequence st for i be Element of dom G holds G.i
  is complete holds product G is complete
proof
  let G be RealNormSpace-Sequence such that
A1: for i be Element of dom G holds G.i is complete;
  reconsider I = len G as Element of NAT;
A2: product G = NORMSTR(# product carr G,zeros G,[:addop G:], [:multop G:],
    productnorm(G) #) by Th6;
  for seq be sequence of (product G) holds seq is Cauchy_sequence_by_Norm
  implies seq is convergent
  proof
    let seq be sequence of product G;
    defpred PPG[Nat,set] means ex i be Element of dom G st i=$1 & ex seqi be
sequence of G.i st seqi is convergent & $2 = lim seqi & for m be Element of NAT
    holds ex seqm be Element of product carr G st seqm= seq.m & seqi.m=seqm.i;
    assume
A3: seq is Cauchy_sequence_by_Norm;
A4: for k be Nat st k in Seg I ex x be set st PPG[k,x]
    proof
      let k be Nat;
      assume
      k in Seg I;
      then reconsider i=k as Element of dom G by FINSEQ_1:def 3;
      defpred P1[Element of NAT,Element of G.i] means ex seqm be Element of
      product carr G st seqm = seq.$1 & $2 = seqm.i;
A5:   for x being Element of NAT ex y being Element of G.i st P1[x,y]
      proof
        let x be Element of NAT;
        consider seqm be Element of product carr G such that
A6:     seqm =seq.x by A2;
        len G = len carr G by Def4;
        then
A7:     dom G = dom carr G by FINSEQ_3:31;
        take y = seqm.i;
        (carr G).i = the carrier of G.i by Def4;
        hence thesis by A6,A7,CARD_3:18;
      end;
      ex f be Function of NAT,the carrier of G.i st for x being Element
      of NAT holds P1[x,f.x] from FUNCT_2:sch 3(A5);
      then consider seqi be sequence of G.i such that
A8:   for m be Element of NAT holds ex seqm be Element of product
      carr G st seqm= seq.m & seqi.m=seqm.i;
      take x = lim seqi;
      now
        let r1 be Real such that
A9:     r1 > 0;
        reconsider r=r1 as Element of REAL;
        consider k be Element of NAT such that
A10:    for n,m be Element of NAT st n >= k & m >= k holds ||. seq.n
        - seq.m .|| < r by A3,A9,RSSPACE3:10;
        now
          let n,m be Element of NAT;
          assume
          n >= k & m >= k;
          then
A11:      ||. seq.n - seq.m .|| < r by A10;
          ( ex seqm be Element of product carr G st seqm = seq.m & seqi.m
= seqm.i)& ex seqn be Element of product carr G st seqn = seq.n & seqi.n = seqn
          .i by A8;
          then ||. seqi.n - seqi.m .||<= ||. seq.n - seq.m .|| by Th11;
          hence ||. seqi.n - seqi.m .|| < r1 by A11,XXREAL_0:2;
        end;
        hence ex k be Element of NAT st for n, m be Element of NAT st n >= k &
        m >= k holds ||. seqi.n - seqi.m .|| < r1;
      end;
      then
A12:  seqi is Cauchy_sequence_by_Norm by RSSPACE3:10;
      G.i is complete by A1;
      then seqi is convergent by A12,LOPBAN_1:def 16;
      hence thesis by A8;
    end;
    consider yy0 be FinSequence such that
A13: dom yy0 = Seg I & for j be Nat st j in Seg I holds PPG[j,yy0.j]
    from FINSEQ_1:sch 1(A4);
A14: len yy0 = I by A13,FINSEQ_1:def 3;
    then
A15: len yy0 = len carr G by Def4;
A16: now
      let i be set;
      assume
      i in dom carr G;
      then reconsider x = i as Element of dom carr G;
      reconsider x as Element of dom G by A14,A15,FINSEQ_3:31;
      reconsider j =x as Element of NAT;
      j in dom G;
      then j in Seg I by FINSEQ_1:def 3;
      then ex i0 be Element of dom G st i0=j & ex seqi be sequence of G.i0 st
seqi is convergent & yy0.j = lim seqi & for m be Element of NAT holds ex seqm
      be Element of product carr G st seqm= seq.m & seqi.m=seqm.i0 by A13;
      then yy0.x in the carrier of G.x;
      hence yy0.i in (carr G).i by Def4;
    end;
    dom carr G = Seg len carr G & len G = len carr G by Def4,FINSEQ_1:def
    3;
    then reconsider y0=yy0 as Element of product carr G by A13,A16,CARD_3:18;
A17: now
      let i be Element of dom G;
      reconsider j=i as Element of NAT;
      i in dom G;
      then i in Seg I by FINSEQ_1:def 3;
      then consider i0 be Element of dom G such that
A18:  i0=j and
A19:  ex seqi be sequence of G.i0 st seqi is convergent & yy0.j = lim
seqi & for m be Element of NAT holds ex seqm be Element of product carr G st
      seqm= seq.m & seqi.m=seqm.i0 by A13;
      consider seqi be sequence of G.i0 such that
A20:  seqi is convergent & yy0.j = lim seqi & for m be Element of NAT
holds ex seqm be Element of product carr G st seqm = seq.m & seqi.m=seqm.i0 by
      A19;
      reconsider seqi as sequence of G.i by A18;
      take seqi;
      thus seqi is convergent & y0.i = lim seqi & for m be Element of NAT
holds ex seqm be Element of product carr G st seqm= seq.m & seqi.m=seqm.i by
      A18,A20;
    end;
    reconsider x0 =y0 as Point of product G by A2;
    x0 = y0;
    hence thesis by A17,Th13;
  end;
  hence thesis by LOPBAN_1:def 16;
end;

