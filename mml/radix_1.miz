:: Definitions of Radix-2k Signed-Digit number and its adder algorithm
::  by Yoshinori Fujisawa and Yasushi Fuwa
::
:: Received September 7, 1999
:: Copyright (c) 1999 Association of Mizar Users

environ

 vocabularies INT_1, NAT_1, ARYTM_1, ARYTM_3, POWER, MIDSP_3, FINSEQ_1,
      FUNCT_1, RELAT_1, RLVECT_1, RADIX_1, FINSEQ_4, GROUP_1;
 notations TARSKI, XBOOLE_0, SUBSET_1, NUMBERS, XCMPLX_0, INT_1, NAT_1,
      FUNCT_1, POWER, FINSEQ_1, FINSEQ_4, BINARITH, TREES_4, WSIERP_1,
      XXREAL_0, MESFUNC1;
 constructors XXREAL_0, NAT_1, MEMBERED, FINSEQ_4, FINSOP_1, POWER, BINARITH,
      WSIERP_1;
 registrations INT_1, RELSET_1, FINSET_1, XREAL_0, MEMBERED, XXREAL_0, NAT_1;
 requirements REAL, NUMERALS, SUBSET, BOOLE, ARITHM;
 definitions TARSKI, RVSUM_1;
 theorems REAL_2, REAL_1, NAT_1, NAT_2, INT_1, FINSEQ_1, EULER_1, BINARITH,
      PREPOWER, POWER, RVSUM_1, FINSEQ_2, FINSEQ_4, TARSKI, FUNCT_1, PEPIN,
      FINSEQ_5, JORDAN3, NEWTON, XCMPLX_1, XREAL_1, XXREAL_0, FINSOP_1,
      ORDINAL1;
 schemes NAT_1, FINSEQ_2;

begin :: Some Useful Theorems

reserve k,m,n for Nat,
        i1,i2,i3 for Integer,
        e for set;

canceled;

theorem Th2:
n mod k = k - 1 implies (n+1) mod k = 0
proof
  per cases;
  suppose A1: k <> 0;
  assume A2: n mod k = k-1;
     k >= 1 by A1,NAT_1:39;
  then k - 1 >= 0 by XREAL_1:50;
  then reconsider K = k - 1 as Element of NAT by INT_1:16;
    K + 1 = k - 0;
  then (n+1) mod k = k mod k by A2,NAT_1:74;
  hence thesis by NAT_1:77;
  end;
  suppose k=0;
  hence thesis by NAT_1:def 2;
end;
end;

theorem Th3:
  k <> 0 & n mod k < k - 1 implies (n+1) mod k = (n mod k) + 1
proof
  assume k <> 0 & n mod k < k - 1;
  then A1:(n mod k) + 1 < k by XREAL_1:22;
     (n+1) mod k = ((n mod k)+1) mod k by NAT_1:74;
  hence thesis by A1,NAT_1:76;
end;

theorem Th4:
  m <> 0 implies (k mod (m*n)) mod n = k mod n
proof
  assume A1:m <> 0;
  per cases;
  suppose A2: n <> 0;
  reconsider k' = k, m' = m, n' = n as Integer;
A3:m'*n' <> 0 by A1,A2,XCMPLX_1:6;
  k mod (m*n) = k' mod (m'*n') by NEWTON:101;
  hence (k mod (m*n)) mod n = (k' mod (m'*n')) mod n' by NEWTON:101
            .= (k' - (k' div (m'*n'))*(m'*n')) mod n' by A3,INT_1:def 8
            .= (k' + (-(m'*(k' div m'*n')))*n') mod n'
            .= k' mod n' by EULER_1:13
            .= k mod n by NEWTON:101;
  end;
  suppose A4: n = 0;
  hence (k mod (m*n)) mod n = 0 by NAT_1:def 2
      .= k mod n by A4,NAT_1:def 2;
end;
end;

theorem
     k <> 0 implies (n+1) mod k = 0 or (n+1) mod k = (n mod k) + 1
proof
  assume A1:k <> 0;
  then k >= 1 by NAT_1:39;
  then k - 1 >= 0 by XREAL_1:50;
  then reconsider K = k - 1 as Element of NAT by INT_1:16;
     k > 0 by A1;
  then n mod k < k - 1 + 1 by NAT_1:46;
  then A2:n mod k <= K by NAT_1:38;
  per cases by A2,XXREAL_0:1;
  suppose n mod k < k - 1;
  hence thesis by A1,Th3;
  end;
  suppose n mod k = k - 1;
  hence thesis by Th2;
end;
end;

reserve i,k,m,n,p,x,y for Element of NAT;

theorem Th6:
  i <> 0 & k <> 0 implies (n mod (i |^ k)) div (i |^ (k -'1)) < i
proof
  assume A1:i <> 0 & k <> 0;
  then A2:i > 0;
  then i |^ k > 0 by PREPOWER:13;
  then A3:n mod (i |^ k) < (i |^ k) by NAT_1:46;
  set I1 = i |^ (k -'1);
  set T = n mod (i |^ k);
  A4:I1 > 0 by A2,PREPOWER:13;
  A5:I1 <> 0 by A2,PREPOWER:13;
     i |^ k = i*(i |^ (k -'1)) by A1,PEPIN:27;
  then T mod I1 = n mod I1 by A1,Th4
               .= n - I1*(n div I1) by A4,NEWTON:77;
  then T = I1*(T div I1) + (n - I1*(n div I1)) by A4,NAT_1:47;
  then I1*(T div I1) + (n - I1*(n div I1)) < i*I1 by A1,A3,PEPIN:27;
  then (I1*(T div I1) + n - I1*(n div I1))/I1 < i*I1/I1 by A4,REAL_1:73;
  then I1*(T div I1)/I1 + n/I1 - I1*(n div I1)/I1 < i*I1/I1
                                            by XCMPLX_1:125;
  then (T div I1) + n/I1 - I1*(n div I1)/I1 < i*I1/I1 by A5,XCMPLX_1:90
;
  then (T div I1) + n/I1 - (n div I1) < i*I1/I1 by A5,XCMPLX_1:90;
  then A6:(T div I1) + n/I1 - (n div I1) < i by A5,XCMPLX_1:90;
  reconsider n' = n , I'1 = I1 as Integer;
  A7:n div I1 = n' div I'1 by NEWTON:101
               .= [\n/I1/] by INT_1:def 7;
     [\n/I1/] <= n/I1 by INT_1:def 4;
  then (T div I1) + [\n/I1/] <= (T div I1) + n/I1 by XREAL_1:8;
  then (T div I1) + [\n/I1/] - [\n/I1/] <= (T div I1) + n/I1 - (n div I1)
                                                         by A7,XREAL_1:11;
  hence thesis by A6,XXREAL_0:2;
end;

theorem Th7:
  k <= n implies m |^ k divides m |^ n
proof
  assume k <= n;
  then consider t being Nat such that
    A1:n = k + t by NAT_1:28;
    reconsider t as Element of NAT by ORDINAL1:def 13;
     m |^ n = (m |^ k)*(m |^ t) by A1,NEWTON:13;
  hence thesis by NAT_1:def 3;
end;

theorem
  i2 > 0 & i3 >= 0 implies (i1 mod (i2*i3)) mod i3 = i1 mod i3
proof
  assume A1:i2 > 0 & i3 >= 0;
  per cases by A1;
  suppose i3 > 0;
then i2*i3 <> 0 by A1,XCMPLX_1:6;
  then (i1 mod (i2*i3)) mod i3
             = (i1 - (i1 div (i2*i3))*(i2*i3)) mod i3 by INT_1:def 8
            .= (i1 + (-(i2*(i1 div i2*i3)))*i3) mod i3;
  hence thesis by EULER_1:13;
  end;
  suppose A2:i3 = 0;
  then (i1 mod (i2*i3)) mod i3 = 0 by INT_1:def 8;
  hence thesis by A2,INT_1:def 8;
end;
end;

begin :: Definition for Radix-2^k, k-SD

definition let n be Nat;
  func Radix(n) -> Element of NAT equals
    2 to_power n;
correctness
proof
   defpred P[Nat] means 2 to_power $1 is Element of NAT;
A1:n is Element of NAT by ORDINAL1:def 13;
A2:P[0] by POWER:29;
A3:for m be Element of NAT st P[m] holds P[m+1]
   proof
     let m be Element of NAT;
     assume 2 to_power m is Element of NAT;
     then reconsider k = 2 to_power m as Element of NAT;
     2 to_power (m+1) = 2 to_power m * 2 to_power 1 by POWER:32
                     .= k * 2 by POWER:30;
     hence thesis;
   end;
   for m be Element of NAT holds P[m] from NAT_1:sch 1(A2,A3);
   hence 2 to_power n is Element of NAT by A1;
 end;
end;

definition let k;
  func k-SD -> set equals
    {e where e is Element of INT:e <= Radix(k)-1 & e >= -Radix(k)+1};
  correctness;
end;

theorem Th9:
  Radix(n) <> 0 by POWER:39;

Lm1:
  for k be Element of NAT st k >= 2 holds Radix(k) >= 2 + 2
proof
  defpred P[Element of NAT] means Radix($1) >= 2+2;
     Radix(2) = 2 to_power (1+1)
          .= 2 to_power 1 * 2 to_power 1 by POWER:32
          .= 2 * 2 to_power 1 by POWER:30
          .= 2 * 2 by POWER:30;
  then A1:P[2];
  A2:for kk be Element of NAT st kk >= 2 & P[kk]
      holds P[kk+1]
  proof
    let kk be Element of NAT;
    assume kk >= 2;
    assume A3:Radix(kk) >= 2 + 2;
       Radix(kk+1) = 2 to_power kk * 2 to_power 1 by POWER:32
               .= Radix(kk) * 2 by POWER:30;
    then Radix(kk+1) >= Radix(kk) by REAL_2:144;
    hence thesis by A3,XXREAL_0:2;
  end;
     for k be Element of NAT st k >= 2 holds P[k] from NAT_1:sch 9(A1,A2);
  hence thesis;
end;

theorem Th10:
  for e holds e in 0-SD iff e = 0
proof
  let e be set;
    Radix(0) = 1 by POWER:29;
then A1:0-SD = {w where w is Element of INT:w <= 0 & w >= 0};
  hereby assume e in 0-SD;
    then consider b be Element of INT such that
      A2:e = b and
      A3:b <= 0 & b >= 0 by A1;
    thus e = 0 by A2,A3;
  end;
  assume
A4:  e = 0;
  then e is Element of INT by INT_1:def 2;
  hence thesis by A1,A4;
end;

theorem
     0-SD = {0} by Th10,TARSKI:def 1;

theorem Th12:
  k-SD c= (k+1)-SD
proof
  let e be set;
  assume A1:e in k-SD;
  consider g being Element of INT such that
    A2:e = g and
    A3:g <= Radix(k)-1 and
    A4:g >= -Radix(k)+1 by A1;
     k < k+1 by NAT_1:38;
  then 2 to_power k < 2 to_power (k+1) by POWER:44;
  then A5:Radix(k) < Radix(k+1);
  then Radix(k)-1 < Radix(k+1)-1 by XREAL_1:11;
  then A6:g <= Radix(k+1)-1 by A3,XXREAL_0:2;
     -Radix(k) > -Radix(k+1) by A5,XREAL_1:26;
  then -Radix(k)+1 > -Radix(k+1)+1 by XREAL_1:8;
  then g >= -Radix(k+1)+1 by A4,XXREAL_0:2;
  hence thesis by A2,A6;
end;

theorem Th13:
  e in k-SD implies e is Integer
proof
  assume A1:e in k-SD;
  consider t be Element of INT such that
    A2:e = t and
       t <= Radix(k)-1 & t >= -Radix(k)+1 by A1;
  thus thesis by A2;
end;

theorem Th14:
  k-SD c= INT
proof
  let e be set;
  assume e in k-SD;
  then e is Integer by Th13;
  hence thesis by INT_1:def 2;
end;

theorem Th15:
  i1 in k-SD implies i1 <= Radix(k)-1 & i1 >= -Radix(k)+1
proof
  assume A1:i1 in k-SD;
  consider i be Element of INT such that
    A2:i = i1 and
    A3:i <= Radix(k)-1 & i >= -Radix(k)+1 by A1;
  thus thesis by A2,A3;
end;

theorem Th16:
  0 in k-SD
proof
  defpred P[Element of NAT] means 0 in $1-SD;
  A1: P[0] by Th10;
  A2:for k being Element of NAT st P[k] holds P[k+1]
  proof
    let kk be Element of NAT;
    assume A3:0 in kk-SD;
       kk-SD c= (kk+1)-SD by Th12;
    hence thesis by A3;
  end;
     for k being Element of NAT holds P[k] from NAT_1:sch 1(A1,A2);
  hence thesis;
end;

registration let k;
  cluster k-SD -> non empty;
  coherence by Th16;
end;

definition let k;
  redefine func k-SD -> non empty Subset of INT;
  coherence by Th14;
end;

begin :: Functions for generating Radix-2^k SD numbers from natural numbers
      :: and natural numbers from Radix-2^k SD numbers

reserve a for Tuple of n,(k-SD);

canceled;

theorem Th18:
  i in Seg n implies a.i is Element of k-SD
proof
  assume A1:i in Seg n;
     len a = n by FINSEQ_2:109;
  then i in dom a by A1,FINSEQ_1:def 3;
  then a.i in rng a & rng a c= k-SD by FINSEQ_1:def 4,FUNCT_1:def 5;
  hence thesis;
end;

definition let i,k,n be Element of NAT, x be Tuple of n,(k-SD);
  func DigA(x,i) -> Integer equals
  :Def3:
    x.i if i in Seg n,
    0 if i = 0;
coherence
  proof
       i in Seg n implies x.i is Integer
    proof
      assume i in Seg n;
      then x.i is Element of k-SD by Th18;
      hence thesis by INT_1:def 2;
    end;
    hence thesis;
  end;
  consistency by FINSEQ_1:3;
end;

definition let i,k,n be Element of NAT, x be Tuple of n,(k-SD);
  func DigB(x,i) -> Element of INT equals

    DigA(x,i);
  coherence by INT_1:def 2;
end;

theorem Th19:
  i in Seg n implies DigA(a,i) is Element of k-SD
proof
  assume A1:i in Seg n;
  then a.i = DigA(a,i) by Def3;
  hence thesis by A1,Th18;
end;

theorem Th20:
  for x be Tuple of 1,INT st x/.1 = m holds x = <*m*>
proof
  let x be Tuple of 1,INT;
  assume A1:x/.1 = m;
  A2:len x = 1 by FINSEQ_2:109;
  then x/.1 = x.1 by FINSEQ_4:24;
  hence thesis by A1,A2,FINSEQ_1:57;
end;

definition let i,k,n be Element of NAT, x be Tuple of n,(k-SD);
  func SubDigit(x,i,k) -> Element of INT equals

    (Radix(k) |^ (i -'1))*DigB(x,i);
coherence by INT_1:def 2;
end;

definition let n,k be Element of NAT, x be Tuple of n,(k-SD);
  func DigitSD(x) -> Tuple of n,INT means
  :Def6:
    for i be Element of NAT st i in Seg n holds it/.i = SubDigit(x,i,k);
existence
  proof
    deffunc F(Element of NAT)=SubDigit(x,$1,k);
    consider z being FinSequence of INT such that
      A1:len z = n and
      A2:for j be Element of NAT st j in Seg n holds z.j = F(j)
                                                 from FINSEQ_2:sch 1;
    reconsider z as Tuple of n,INT by A1,FINSEQ_2:110;
    take z;
    let i;
    assume A3:i in Seg n;
    then i in dom z by A1,FINSEQ_1:def 3;
    hence z/.i = z.i by FINSEQ_4:def 4
                .= SubDigit(x,i,k) by A2,A3;
  end;
uniqueness
  proof
    let k1,k2 be Tuple of n,INT such that
      A4:for i be Element of NAT st i in Seg n holds k1/.i = SubDigit(x,i,k)
       and
      A5:for i be Element of NAT st i in Seg n holds k2/.i = SubDigit(x,i,k);
    A6:len k1 = n & len k2 = n by FINSEQ_2:109;
       now let j be Element of NAT;
      assume A7:j in Seg n;
      then A8:j in dom k1 & j in dom k2 by A6,FINSEQ_1:def 3;
      then k1.j = k1/.j by FINSEQ_4:def 4
               .= SubDigit(x,j,k) by A4,A7
               .= k2/.j by A5,A7
               .= k2.j by A8,FINSEQ_4:def 4;
      hence k1.j = k2.j;
    end;
    hence k1 = k2 by A6,FINSEQ_2:10;
  end;
end;

definition let n,k be Element of NAT, x be Tuple of n,(k-SD);
  func SDDec(x) -> Integer equals

    Sum DigitSD(x);
coherence;
end;

definition let i,k,x be Element of NAT;
  func DigitDC(x,i,k) -> Element of k-SD equals

    (x mod (Radix(k) |^ i)) div (Radix(k) |^ (i -'1));
coherence
  proof
    set T = Radix(k) |^ i;
    set S = Radix(k) |^ (i -'1);
    A1:Radix(k) <> 0 by Th9;
    then A2:Radix(k) >= 1 by NAT_1:39;
       T <> 0 by A2,PREPOWER:19;
    then A3:T > 0;
       S <> 0 by A2,PREPOWER:19;
    then A4:S > 0;
    then A5:0 div S = 0 by NAT_1:80;
    defpred P[Element of NAT] means ($1 mod T) div S is Element of k-SD;
       0 in k-SD by Th16;
    then A6: P[0] by A3,A5,NAT_1:76;
    A7:for x being Element of NAT st P[x] holds P[(x+1)]
    proof
      let xx be Element of NAT;
      assume (xx mod T) div S is Element of k-SD;
      set X = ((xx+1) mod T) div S;
      Radix(k)-1 >= 0 by A2,XREAL_1:50;
      then reconsider R = Radix(k)-1 as Element of NAT by INT_1:16;
        per cases;
        suppose A8:i = 0;
          Radix(k) |^ i = Radix(k) to_power i by A1,POWER:46
                       .= 1 by A8,POWER:29;
          then ((xx+1) mod T) = (((xx+1)*1) mod 1)
                             .= 0 by NAT_1:63;
          then X = 0 by A4,NAT_1:80;
          hence thesis by Th16;
        end;
        suppose i > 0;
          then X < Radix(k) - 1 + 1 by A1,Th6;
          then A9:X <= R by NAT_1:38;
 A10:  X is Element of INT by INT_1:def 2;
             -1 >= -Radix(k) by A2,XREAL_1:26;
          then 0 >= -Radix(k)+1 by REAL_2:109;
          then X in k-SD by A9,A10;
          hence thesis;
      end;
    end;
    for x being Element of NAT holds P[x] from NAT_1:sch 1(A6,A7);
    hence thesis;
  end;
end;

definition let k,n,x be Element of NAT;
  func DecSD(x,n,k) -> Tuple of n,(k-SD) means
  :Def9:
    for i be Element of NAT st i in Seg n holds DigA(it,i) = DigitDC(x,i,k);
existence
  proof
    deffunc F(Element of NAT)=DigitDC(x,$1,k);
    consider z being FinSequence of k-SD such that
      A1: len z = n and
      A2: for j be Element of NAT st j in Seg n holds z.j = F(j)
                                                 from FINSEQ_2:sch 1;
    reconsider z as Tuple of n,(k-SD) by A1,FINSEQ_2:110;
    take z;
    let i;
    assume A3:i in Seg n;
    hence DigA(z,i) = z.i by Def3
                 .= DigitDC(x,i,k) by A2,A3;
  end;
uniqueness
  proof
    let k1,k2 be Tuple of n,(k-SD) such that
      A4:for i be Element of NAT st i in Seg n
       holds DigA(k1,i) = DigitDC(x,i,k)
       and
      A5:for i be Element of NAT st i in Seg n
       holds DigA(k2,i) = DigitDC(x,i,k);
    A6:len k1 = n & len k2 = n by FINSEQ_2:109;
       now let j be Element of NAT;
      assume A7:j in Seg n;
      then k1.j = DigA(k1,j) by Def3
               .= DigitDC(x,j,k) by A4,A7
               .= DigA(k2,j) by A5,A7
               .= k2.j by A7,Def3;
      hence k1.j = k2.j;
    end;
    hence k1 = k2 by A6,FINSEQ_2:10;
  end;
end;

begin :: Definition for carry & data components of Addition

definition let x be Integer;
  func SD_Add_Carry(x) -> Integer equals
  :Def10:
    1 if x > 2,
    -1 if x < -2
    otherwise 0;
coherence;
consistency;
end;

theorem Th21:
  SD_Add_Carry(0) = 0 by Def10;

Lm2:
  for x be Integer holds -1 <= SD_Add_Carry(x) & SD_Add_Carry(x) <= 1
proof
  let x be Integer;
  per cases;
  suppose A1:x < -2;
    thus thesis by A1,Def10;
  end;
  suppose -2 <= x & x <= 2;
    then SD_Add_Carry(x) = 0 by Def10;
    hence thesis;
  end;
  suppose A2:x > 2;
    thus thesis by A2,Def10;
end;
end;

definition let x be Integer, k be Element of NAT;
  func SD_Add_Data(x,k) -> Integer equals

    x - SD_Add_Carry(x)*Radix(k);
  coherence;
end;

theorem
     SD_Add_Data(0,k) = 0 by Th21;

theorem Th23:
  k >= 2 & i1 in k-SD & i2 in k-SD implies
    -Radix(k)+2 <= SD_Add_Data(i1+i2,k) & SD_Add_Data(i1+i2,k) <= Radix(k)-2
proof
  assume A1:k >= 2 & i1 in k-SD & i2 in k-SD;
  then A2:-Radix(k)+1 <= i1 & i1 <= Radix(k)-1 &
             -Radix(k)+1 <= i2 & i2 <= Radix(k)-1 by Th15;
  set z = i1+i2;
  A3: -Radix(k)+1 + (-Radix(k)+1) <= z &
      z <= Radix(k)-1 + (Radix(k)-1) by A2,XREAL_1:9;
  per cases;
  suppose A4:z < -2;
    then SD_Add_Carry(z) = -1 by Def10;
    then A5:SD_Add_Data(z,k) = z + Radix(k);
       -Radix(k)+1 + (1 + -Radix(k)) <= z by A2,XREAL_1:9;
    then A6: (-Radix(k)+(1+1))-Radix(k) <= z;
       z + Radix(k) < -2 + Radix(k) by A4,XREAL_1:8;
    hence thesis by A5,A6,XREAL_1:22;
  end;
  suppose A7:-2 <= z & z <= 2;
    then SD_Add_Carry(z) = 0 by Def10;
    then A8:SD_Add_Data(z,k) = z;
    A9: Radix(k) >= 2+2 by A1,Lm1;
    then A10:Radix(k)-2 >= 2 by XREAL_1:21;
       -Radix(k) <= -(2+2) by A9,XREAL_1:26;
    then -Radix(k) <= -2 + -2;
    then -Radix(k) - -2 <= -2 by XREAL_1:22;
    hence thesis by A7,A8,A10,XXREAL_0:2;
  end;
  suppose A11:z > 2;
    then SD_Add_Carry(z) = 1 by Def10;
    then A12:SD_Add_Data(z,k) = z - Radix(k);
    A13: z <= Radix(k)-1 -1 + Radix(k) by A3;
       z - Radix(k) > 2 - Radix(k) by A11,XREAL_1:11;
    hence thesis by A12,A13,XREAL_1:22;
end;
end;

begin :: Definition for checking whether or not a natural number can be
      :: expressed as n digits Radix-2^k SD number

definition let n,x,k be Element of NAT;
  pred x is_represented_by n,k means
  :Def12:
    x < (Radix(k) |^ n);
end;

theorem Th24:
  m is_represented_by 1,k implies DigA(DecSD(m,1,k),1) = m
proof
  assume m is_represented_by 1,k;
  then A1:m < Radix(k) |^ 1 by Def12;
     1 in Seg 1 by FINSEQ_1:3;
  hence DigA(DecSD(m,1,k),1)
          = DigitDC(m,1,k) by Def9
         .= (m mod (Radix(k) |^ 1)) div (Radix(k) |^ 0) by BINARITH:51
         .= (m mod (Radix(k) |^ 1)) div 1 by NEWTON:9
         .= m mod (Radix(k) |^ 1) by NAT_2:6
         .= m by A1,NAT_1:76;
end;

theorem
     for n st n >= 1 holds
    for m st m is_represented_by n,k holds m = SDDec(DecSD(m,n,k))
proof
  defpred P[Element of NAT] means
    for m st m is_represented_by $1,k holds m = SDDec(DecSD(m,$1,k));
  A1:P[1]
  proof
    let m;
    assume A2:m is_represented_by 1,k;
    A3:1 in Seg 1 by FINSEQ_1:3;
       SubDigit(DecSD(m,1,k),1,k) = (Radix(k) |^ 0)*DigB(DecSD(m,1,k),1)
                                                               by BINARITH:51
                              .= 1*DigB(DecSD(m,1,k),1) by NEWTON:9
                              .= m by A2,Th24;
    then A4:(DigitSD(DecSD(m,1,k)))/.1 = m by A3,Def6;
A5: m is Element of INT by INT_1:def 2;
    then reconsider M = <*m*> as FinSequence of INT by FINSEQ_1:95;
    thus SDDec(DecSD(m,1,k)) = Sum M by A4,Th20
                       .= m by A5,FINSOP_1:12;
  end;
A6:for u be Element of NAT st u >= 1 & P[u] holds P[u+1]
  proof
    let u be Element of NAT;
    assume A7:u >= 1 & P[u];
    p is_represented_by (u+1),k implies p = SDDec(DecSD(p,(u+1),k))
    proof
      assume p is_represented_by (u+1),k;
      then A8:p < Radix(k) |^ (u+1) by Def12;
      set R = Radix(k) |^ u;
      Radix(k) <> 0 by Th9;
      then R <> 0 by PREPOWER:12;
      then A9:R > 0;
      then A10:p = R*(p div R) + (p mod R) by NAT_1:47;
      set M = p mod R;
      set N = R*(p div R);
      M < R by A9,NAT_1:46;
      then M is_represented_by u,k by Def12;
      then A11:p = SDDec(DecSD(M,u,k)) + N by A7,A10;
      N is Element of INT by INT_1:def 2;
      then reconsider NN = <*N*> as FinSequence of INT by FINSEQ_1:95;
      reconsider DD = DigitSD(DecSD(M,u,k)) as FinSequence of INT;
      A12:p = Sum (DD^NN) by  A11,RVSUM_1:104;
      set I = u + 1;
      A13:I -' 1 = u by BINARITH:39;
      then A14:p div R
                 = DigitDC(p,(u+1),k) by A8,NAT_1:76;
A15:1 <= u+1 & u+1 <= u+1 by NAT_1:37;
      then A16:u+1 in Seg (u+1) by FINSEQ_1:3;
      A17:u+1 <= len (DigitSD(DecSD(p,(u+1),k))) by FINSEQ_2:109;
      A18:N = SubDigit(DecSD(p,(u+1),k),(u+1),k) by A13,A14,A16,Def9
            .= (DigitSD(DecSD(p,(u+1),k)))/.(u+1) by A16,Def6
            .= DigitSD(DecSD(p,(u+1),k)).(u+1) by A15,A17,FINSEQ_4:24;
      DigitSD(DecSD(M,u,k))^<*N*> = DigitSD(DecSD(p,(u+1),k))
      proof
        A19:N is Element of INT by INT_1:def 2;
        set z0 = DigitSD(DecSD(M,u,k));
        reconsider z1 = <*N*> as FinSequence of INT by A19,FINSEQ_1:95;
        reconsider DD = DigitSD(DecSD(p,(u+1),k)) as FinSequence of INT;
        reconsider z = z0^z1 as FinSequence of INT;
        A20:len z = len (DigitSD(DecSD(M,u,k))) + len <*N*> by FINSEQ_1:35
                 .= u + len <*N*> by FINSEQ_2:109
                 .= u + 1 by FINSEQ_1:56;
        A21:len DD = u+1 by FINSEQ_2:109;
           for i be Element of NAT st 1 <= i & i <= len z holds z/.i = DD/.i
        proof
          let i be Element of NAT;
          assume 1 <= i & i <= len z;
          then A22:i in Seg (u+1) by A20,FINSEQ_1:3;
          per cases by A22,FINSEQ_2:8;
          suppose A23:i in Seg u;
            A24:M mod (Radix(k) |^ i) = p mod (Radix(k) |^ i)
            proof
              i <= u by A23,FINSEQ_1:3;
              then Radix(k) |^ i divides Radix(k) |^ u by Th7;
              then consider t being Nat such that
          A25:Radix(k) |^ u = (Radix(k) |^ i)*t by NAT_1:def 3;
              Radix(k) <> 0 by Th9;
              then t <> 0 by A25,PREPOWER:12;
              hence thesis by A25,Th4;
            end;
            len z0 = u by FINSEQ_2:109;
            then A26:i in dom z0 by A23,FINSEQ_1:def 3;
            then A27:(z0^z1).i
              = DigitSD(DecSD(M,u,k)).i by FINSEQ_1:def 7
             .= (DigitSD(DecSD(M,u,k)))/.i by A26,FINSEQ_4:def 4
             .= SubDigit(DecSD(M,u,k),i,k) by A23,Def6
             .= (Radix(k) |^ (i -'1))*DigitDC(M,i,k) by A23,Def9
             .= (Radix(k) |^ (i -'1))*((p mod (Radix(k) |^ i))
                         div (Radix(k) |^ (i -'1))) by A24;
            len DD = u+1 by FINSEQ_2:109;
            then A28:i in dom DD by A22,FINSEQ_1:def 3;
            then A29:DD.i = (DigitSD(DecSD(p,(u+1),k)))/.i by FINSEQ_4:def 4
             .= SubDigit(DecSD(p,(u+1),k),i,k) by A22,Def6
             .= (Radix(k) |^ (i -'1))*DigitDC(p,i,k) by A22,Def9
             .= (Radix(k) |^ (i -'1))*((p mod (Radix(k) |^ i))
                         div (Radix(k) |^ (i -'1)));
            A30:DD.i = DD/.i by A28,FINSEQ_4:def 4;
            i in dom (z0^z1) by A20,A22,FINSEQ_1:def 3;
          hence thesis by A27,A29,A30,FINSEQ_4:def 4;
          end;
          suppose A31:i = u+1;
            hence z/.i = z.(u+1) by A15,A20,FINSEQ_4:24
                   .= (z0^z1).(len z0 + 1) by FINSEQ_2:109
                   .= DigitSD(DecSD(p,(u+1),k)).(u+1) by A18,FINSEQ_1:59
                   .= DD/.i by A15,A17,A31,FINSEQ_4:24;
        end;
        end;
        hence thesis by A20,A21,FINSEQ_5:14;
      end;
      hence thesis by A12;
    end;
    hence thesis;
  end;
  for u be Element of NAT st u >= 1 holds P[u] from NAT_1:sch 9(A1,A6);
  hence thesis;
end;

theorem Th26:
  k >= 2 & m is_represented_by 1,k & n is_represented_by 1,k implies
    SD_Add_Carry(DigA(DecSD(m,1,k),1)+DigA(DecSD(n,1,k),1)) = SD_Add_Carry(m+n)
proof
  assume A1:k >= 2 & m is_represented_by 1,k & n is_represented_by 1,k;
  then SD_Add_Carry(DigA(DecSD(m,1,k),1)+DigA(DecSD(n,1,k),1))
    = SD_Add_Carry(m + DigA(DecSD(n,1,k),1)) by Th24
   .= SD_Add_Carry(m + n) by A1,Th24;
  hence thesis;
end;

Lm3:
  for i st i in Seg n holds
    DigA(DecSD(m,n+1,k),i)=DigA(DecSD((m mod (Radix(k) |^ n)),n,k),i)
proof
  let i;
  assume A1:i in Seg n;
  then A2:1 <= i & i <= n by FINSEQ_1:3;
  then i <= n+1 by NAT_1:37;
  then A3:i in Seg (n+1) by A2,FINSEQ_1:3;
     Radix(k) |^ i divides Radix(k) |^ n by A2,Th7;
  then consider t be Nat such that
    A4:Radix(k) |^ n = (Radix(k) |^ i)*t by NAT_1:def 3;
     Radix(k) <> 0 by Th9;
  then t <> 0 by A4,PREPOWER:12;
  then A5:(m mod (Radix(k) |^ n)) mod (Radix(k) |^ i)
         = m mod (Radix(k) |^ i) by A4,Th4;
     DigA(DecSD((m mod (Radix(k) |^ n)),n,k),i)
         = DigitDC((m mod (Radix(k) |^ n)),i,k) by A1,Def9
        .= DigitDC(m,i,k) by A5
        .= DigA(DecSD(m,n+1,k),i) by A3,Def9;
  hence thesis;
end;

theorem Th27:
  m is_represented_by (n+1),k implies
    DigA(DecSD(m,(n+1),k),n+1) = m div (Radix(k) |^ n)
proof
  assume A1:m is_represented_by (n+1),k;
  A2: n+1 in Seg (n+1) by FINSEQ_1:5;
  A3:m < Radix(k) |^ (n+1) by A1,Def12;
     DigA(DecSD(m,(n+1),k),n+1)
    = DigitDC(m,n+1,k) by A2,Def9
   .= m div (Radix(k) |^ ((n+1) -'1)) by A3,NAT_1:76
   .= m div (Radix(k) |^ n) by BINARITH:39;
  hence thesis;
end;

begin :: Definition for Addition operation for a high-speed adder algorithm
      :: on Radix-2^k SD number

definition let k,i,n be Element of NAT, x,y be Tuple of n,(k-SD);
  assume A1:i in Seg n & k >= 2;
  func Add(x,y,i,k) -> Element of k-SD equals
  :Def13:
    SD_Add_Data(DigA(x,i)+DigA(y,i),k)
      + SD_Add_Carry(DigA(x,i -'1)+DigA(y,i -'1));
coherence
  proof
    set SDD = SD_Add_Data(DigA(x,i)+DigA(y,i),k);
    set SDC = SD_Add_Carry(DigA(x,i -'1)+DigA(y,i -'1));
    A2:DigA(x,i) is Element of k-SD by A1,Th19;
       DigA(y,i) is Element of k-SD by A1,Th19;
    then A3:-Radix(k)+2 <= SDD & SDD <= Radix(k)-2 by A1,A2,Th23;
A4: SDD + SDC is Element of INT by INT_1:def 2;
       -1 <= SDC & SDC <= 1 by Lm2;
    then -Radix(k)+2 +(-1) <= SDD + SDC & SDD + SDC <= Radix(k)-2 + 1
                                                            by A3,XREAL_1:9;
    then SDD + SDC in k-SD by A4;
    hence thesis;
  end;
end;

definition let n,k be Element of NAT,x,y be Tuple of n,(k-SD);
  func x '+' y -> Tuple of n,(k-SD) means
  :Def14:
    for i st i in Seg n holds DigA(it,i) = Add(x,y,i,k);
existence
  proof
    deffunc F(Element of NAT)= Add(x,y,$1,k);
    consider z being FinSequence of (k-SD) such that
      A1: len z = n and
      A2: for j be Element of NAT st j in Seg n holds z.j = F(j)
       from FINSEQ_2:sch 1;
    reconsider z as Tuple of n,(k-SD) by A1,FINSEQ_2:110;
    take z;
    let i;
    assume A3:i in Seg n;
    hence DigA(z,i) = z.i by Def3
                 .= Add(x,y,i,k) by A2,A3;
  end;
uniqueness
  proof
    let k1,k2 be Tuple of n,(k-SD) such that
      A4:for i be Element of NAT st i in Seg n holds DigA(k1,i) = Add(x,y,i,k)
       and
      A5:for i be Element of NAT st i in Seg n holds DigA(k2,i) = Add(x,y,i,k);
    A6:len k1 = n & len k2 = n by FINSEQ_2:109;
       now let j be Element of NAT;
      assume A7:j in Seg n;
      then k1.j = DigA(k1,j) by Def3
          .= Add(x,y,j,k) by A4,A7
          .= DigA(k2,j) by A5,A7
          .= k2.j by A7,Def3;
      hence k1.j = k2.j;
    end;
    hence k1 = k2 by A6,FINSEQ_2:10;
  end;
end;

theorem Th28:
  k >= 2 & m is_represented_by 1,k & n is_represented_by 1,k implies
    SDDec(DecSD(m,1,k)'+'DecSD(n,1,k)) = SD_Add_Data(m+n,k)
proof
  assume A1:k >= 2 & m is_represented_by 1,k & n is_represented_by 1,k;
  set M = DecSD(m,1,k);
  set N = DecSD(n,1,k);

  A2:1 in Seg 1 by FINSEQ_1:3;
  then A3:DigA((M '+' N),1)
    = Add(M,N,1,k) by Def14
   .= SD_Add_Data(DigA(M,1)+DigA(N,1),k)
       + SD_Add_Carry(DigA(M,1 -'1)+DigA(N,1 -'1)) by A1,A2,Def13
   .= SD_Add_Data(DigA(M,1)+DigA(N,1),k)
       + SD_Add_Carry(DigA(M,0)+DigA(N,1 -'1)) by BINARITH:51
   .= SD_Add_Data(DigA(M,1)+DigA(N,1),k) + SD_Add_Carry(DigA(M,0)+DigA(N,0))
                                                               by BINARITH:51
   .= SD_Add_Data(DigA(M,1)+DigA(N,1),k) + SD_Add_Carry(0+DigA(N,0)) by Def3
   .= SD_Add_Data(DigA(M,1)+DigA(N,1),k) + 0 by Def3,Th21
   .= SD_Add_Data(m+DigA(N,1),k) by A1,Th24
   .= SD_Add_Data(m+n,k) by A1,Th24;
  A4:(DigitSD(M '+' N))/.1 = SubDigit((M '+' N),1,k) by A2,Def6
                       .= (Radix(k) |^ 0)*DigA((M '+' N),1) by BINARITH:51
                       .= 1*DigA((M '+' N),1) by NEWTON:9
                       .= SD_Add_Data(m+n,k) by A3;
  A5:len (DigitSD(M '+' N)) = 1 by FINSEQ_2:109;
     1 in Seg 1 by FINSEQ_1:3;
  then 1 in dom DigitSD(M '+' N) by A5,FINSEQ_1:def 3;
  then A6:DigitSD(M '+' N).1 = SD_Add_Data(m+n,k) by A4,FINSEQ_4:def 4;
  reconsider w = SD_Add_Data(m+n,k) as Element of INT by INT_1:def 2;
     SDDec(M '+' N) = Sum <*w*> by A5,A6,FINSEQ_1:57
                .= SD_Add_Data(m+n,k) by RVSUM_1:103;
  hence thesis;
end;

theorem
     for n st n >= 1 holds
    for k,x,y st
      k >= 2 & x is_represented_by n,k & y is_represented_by n,k holds
        x + y = (SDDec(DecSD(x,n,k) '+' DecSD(y,n,k)))
          + (Radix(k) |^ n)*
            SD_Add_Carry(DigA(DecSD(x,n,k),n)+DigA(DecSD(y,n,k),n))
proof
  defpred P[Element of NAT] means
    for k,x,y be Element of NAT st
      k >= 2 & x is_represented_by $1,k & y is_represented_by $1,k holds
        x + y = (SDDec(DecSD(x,$1,k) '+' DecSD(y,$1,k)))+(Radix(k) |^ $1)*
                 SD_Add_Carry(DigA(DecSD(x,$1,k),$1)+DigA(DecSD(y,$1,k),$1));

A1:P[1]
  proof
    let k,x,y be Element of NAT;
    assume A2:k >= 2 & x is_represented_by 1,k & y is_represented_by 1,k;
    then A3:SDDec(DecSD(x,1,k)'+'DecSD(y,1,k))
         = SD_Add_Data(x + y,k) by Th28;
    A4:SD_Add_Carry(DigA(DecSD(x,1,k),1)+DigA(DecSD(y,1,k),1))
         = SD_Add_Carry(x+y) by A2,Th26;
    SD_Add_Data(x + y,k) + SD_Add_Carry(x+y)*Radix(k)
           = x + y - 0;
    hence thesis by A3,A4,NEWTON:10;
  end;

  A5:for n be Element of NAT st n >= 1 & P[n] holds P[n+1]
  proof
    let n be Element of NAT;
    assume A6:n >= 1 & P[n];
    then n <> 0;
    then A7: n in Seg n by FINSEQ_1:5;
    A8: n+1 in Seg (n+1) by FINSEQ_1:5;
    let k,x,y be Element of NAT;
    assume A9:k >= 2 &
           x is_represented_by (n+1),k & y is_represented_by (n+1),k;
    set x1 = x div (Radix(k) |^ n);
    set xn = x mod (Radix(k) |^ n);
    set y1 = y div (Radix(k) |^ n);
    set yn = y mod (Radix(k) |^ n);
    set z = DecSD(x,(n+1),k) '+' DecSD(y,(n+1),k);
    set zn = DecSD(xn,n,k) '+' DecSD(yn,n,k);

    A10:DigA(DecSD(y,(n+1),k),n+1) = y1 by A9,Th27;

       Radix(k) <> 0 by Th9;
    then Radix(k) > 0;
    then A11:(Radix(k) |^ n) > 0 by PREPOWER:13;
    then A12:x = (x div (Radix(k) |^ n))*(Radix(k) |^ n)
                          + (x mod (Radix(k) |^ n)) by NAT_1:47;

       xn < Radix(k) |^ n & yn < Radix(k) |^ n by A11,NAT_1:46;
    then A13:xn is_represented_by n,k & yn is_represented_by n,k by Def12;
    A14:DigitSD(z) = DigitSD(zn)^<*SubDigit(z,n+1,k)*>
    proof
      A15:len DigitSD(z) = n+1 by FINSEQ_2:109;
      A16:len DigitSD(zn) = n by FINSEQ_2:109;
      A17:len <*SubDigit(z,n+1,k)*> = 1 by FINSEQ_1:56;
         len (DigitSD(zn)^<*SubDigit(z,n+1,k)*>)
         = len DigitSD(zn) + len <*SubDigit(z,n+1,k)*> by FINSEQ_1:35
        .= n+1 by A17,FINSEQ_2:109;
      then A18:len DigitSD(z) = len (DigitSD(zn)^<*SubDigit(z,n+1,k)*>)
                                                            by FINSEQ_2:109;

         for i st 1 <= i & i <= len DigitSD(z) holds
         (DigitSD(z)).i = ((DigitSD(zn))^<*SubDigit(z,n+1,k)*>).i
      proof
        let i;
        assume A19:1 <= i & i <= len DigitSD(z);
        then A20:i <= n+1 by FINSEQ_2:109;
        then A21:i in Seg (n+1) by A19,FINSEQ_1:3;
then A22:      i in dom DigitSD(z) by A15,FINSEQ_1:def 3;
        A23:i -'1 = i - 1 by A19,BINARITH:50;
        per cases by A21,FINSEQ_2:8;
        suppose A24:i in Seg n;
          then A25:i in dom DigitSD(zn) by A16,FINSEQ_1:def 3;
          then A26:((DigitSD(zn))^<*SubDigit(z,n+1,k)*>).i
             = DigitSD(zn).i by FINSEQ_1:def 7
            .= (DigitSD(zn))/.i by A25,FINSEQ_4:def 4
            .= SubDigit(zn,i,k) by A24,Def6
            .= (Radix(k) |^ (i -'1))
                *Add(DecSD(xn,n,k),DecSD(yn,n,k),i,k) by A24,Def14
            .= (Radix(k) |^ (i -'1))
               *(SD_Add_Data(DigA(DecSD(xn,n,k),i)
               + DigA(DecSD(yn,n,k),i),k)
               + SD_Add_Carry(DigA(DecSD(xn,n,k),i -'1)
               + DigA(DecSD(yn,n,k),i -'1))) by A9,A24,Def13;
          A27:DigitSD(z).i
             = (DigitSD(z))/.i by A22,FINSEQ_4:def 4
            .= SubDigit(z,i,k) by A21,Def6
            .= (Radix(k) |^ (i -'1))
                *Add(DecSD(x,(n+1),k),DecSD(y,(n+1),k),i,k) by A21,Def14
            .= (Radix(k) |^ (i -'1))
               *(SD_Add_Data(DigA(DecSD(x,(n+1),k),i)
               + DigA(DecSD(y,(n+1),k),i),k)
               + SD_Add_Carry(DigA(DecSD(x,(n+1),k),i -'1)
               + DigA(DecSD(y,(n+1),k),i -'1))) by A9,A21,Def13;
             now per cases by A19,XXREAL_0:1;
            suppose A28:i = 1;
              then A29:((DigitSD(zn))^<*SubDigit(z,n+1,k)*>).i
                = (Radix(k) |^ (i -'1))
                  *(SD_Add_Data(DigA(DecSD(xn,n,k),i)
                  + DigA(DecSD(yn,n,k),i),k)
                  + SD_Add_Carry(DigA(DecSD(xn,n,k),i -'1)
                  + DigA(DecSD(yn,n,k),0))) by A26,BINARITH:51
               .= (Radix(k) |^ (i -'1))
                  *(SD_Add_Data(DigA(DecSD(xn,n,k),i)
                  + DigA(DecSD(yn,n,k),i),k)
                  + SD_Add_Carry(DigA(DecSD(xn,n,k),0)
                  + DigA(DecSD(yn,n,k),0))) by A28,BINARITH:51
               .= (Radix(k) |^ (i -'1))
                  *(SD_Add_Data(DigA(DecSD(xn,n,k),i)
                  + DigA(DecSD(yn,n,k),i),k)
                  + SD_Add_Carry(DigA(DecSD(xn,n,k),0)
                  + 0)) by Def3
               .= (Radix(k) |^ (i -'1))
                  *(SD_Add_Data(DigA(DecSD(xn,n,k),i)
                  + DigA(DecSD(yn,n,k),i),k)+0) by Def3,Th21;
                 DigitSD(z).i
               = (Radix(k) |^ (i -'1))
                  *(SD_Add_Data(DigA(DecSD(x,(n+1),k),i)
                  + DigA(DecSD(y,(n+1),k),i),k)
                  + SD_Add_Carry(DigA(DecSD(x,(n+1),k),i -'1)
                  + DigA(DecSD(y,(n+1),k),0))) by A27,A28,BINARITH:51
               .= (Radix(k) |^ (i -'1))
                  *(SD_Add_Data(DigA(DecSD(x,(n+1),k),i)
                  + DigA(DecSD(y,(n+1),k),i),k)
                  + SD_Add_Carry(DigA(DecSD(x,(n+1),k),0)
                  + DigA(DecSD(y,(n+1),k),0))) by A28,BINARITH:51
               .= (Radix(k) |^ (i -'1))
                  *(SD_Add_Data(DigA(DecSD(x,(n+1),k),i)
                  + DigA(DecSD(y,(n+1),k),i),k)
                  + SD_Add_Carry(DigA(DecSD(x,(n+1),k),0)
                  + 0)) by Def3
               .= (Radix(k) |^ (i -'1))
                  *(SD_Add_Data(DigA(DecSD(x,(n+1),k),i)
                  + DigA(DecSD(y,(n+1),k),i),k)+0) by Def3,Th21
               .= (Radix(k) |^ (i -'1))
                  *(SD_Add_Data(DigA(DecSD(xn,n,k),i)
                  + DigA(DecSD(y,(n+1),k),i),k)) by A24,Lm3
               .= (Radix(k) |^ (i -'1))
                  *(SD_Add_Data(DigA(DecSD(xn,n,k),i)
                  + DigA(DecSD(yn,n,k),i),k)) by A24,Lm3;
            hence thesis by A29;
            end;
            suppose i > 1;
              then A30:i -'1 >= 1 by JORDAN3:12;
                 i - 1 <= n by A20,XREAL_1:22;
              then A31:i -'1 in Seg n by A23,A30,FINSEQ_1:3;
                 DigitSD(z).i
               = (Radix(k) |^ (i -'1))
                  *(SD_Add_Data(DigA(DecSD(xn,n,k),i)
                  + DigA(DecSD(y,(n+1),k),i),k)
                  + SD_Add_Carry(DigA(DecSD(x,(n+1),k),i -'1)
                  + DigA(DecSD(y,(n+1),k),i -'1))) by A24,A27,Lm3
               .= (Radix(k) |^ (i -'1))
                  *(SD_Add_Data(DigA(DecSD(xn,n,k),i)
                  + DigA(DecSD(yn,n,k),i),k)
                  + SD_Add_Carry(DigA(DecSD(x,(n+1),k),i -'1)
                  + DigA(DecSD(y,(n+1),k),i -'1))) by A24,Lm3
               .= (Radix(k) |^ (i -'1))
                  *(SD_Add_Data(DigA(DecSD(xn,n,k),i)
                  + DigA(DecSD(yn,n,k),i),k)
                  + SD_Add_Carry(DigA(DecSD(xn,n,k),i -'1)
                  + DigA(DecSD(y,(n+1),k),i -'1))) by A31,Lm3
               .= (Radix(k) |^ (i -'1))
                  *(SD_Add_Data(DigA(DecSD(xn,n,k),i)
                  + DigA(DecSD(yn,n,k),i),k)
                  + SD_Add_Carry(DigA(DecSD(xn,n,k),i -'1)
                  + DigA(DecSD(yn,n,k),i -'1))) by A31,Lm3;
            hence thesis by A26;
          end;
          end;
        hence thesis;
        end;
        suppose A32:i = n+1;
          then ((DigitSD(zn))^<*SubDigit(z,n+1,k)*>).i
         = ((DigitSD(zn))^<*SubDigit(z,n+1,k)*>).((len (DigitSD(zn)))+1)
                                                     by FINSEQ_2:109
        .= SubDigit(z,n+1,k) by FINSEQ_1:59
        .= (DigitSD(z))/.(n+1) by A8,Def6
        .= DigitSD(z).(n+1) by A22,A32,FINSEQ_4:def 4;
        hence thesis by A32;
      end;
      end;
      hence thesis by A18,FINSEQ_1:18;
    end;

    A33:DigitSD(zn) is FinSequence of INT;
    A34:SubDigit(z,n+1,k) = (Radix(k) |^ n)*DigB(z,(n+1)) by BINARITH:39;

       SDDec(z)
      = (Radix(k) |^ n)*DigB(z,(n+1)) + Sum DigitSD(zn) by  A14,
A33,A34,RVSUM_1:104
     .= Add(DecSD(x,(n+1),k),DecSD(y,(n+1),k),(n+1),k)*(Radix(k) |^ n)
        + Sum DigitSD(zn) by A8,Def14
     .= (SD_Add_Data(DigA(DecSD(x,(n+1),k),(n+1))
        + DigA(DecSD(y,(n+1),k),(n+1)),k)
        + SD_Add_Carry(DigA(DecSD(x,(n+1),k),(n+1)-'1)
        + DigA(DecSD(y,(n+1),k),(n+1)-'1)))*(Radix(k) |^ n)
        + Sum DigitSD(zn) by A8,A9,Def13
     .= (SD_Add_Data(DigA(DecSD(x,(n+1),k),(n+1))
        + DigA(DecSD(y,(n+1),k),(n+1)),k)
        + SD_Add_Carry(DigA(DecSD(x,(n+1),k),(n+1)-'1)
        + DigA(DecSD(y,(n+1),k),n)))*(Radix(k) |^ n)
        + Sum DigitSD(zn) by BINARITH:39
     .= (SD_Add_Data(DigA(DecSD(x,(n+1),k),(n+1))
        + DigA(DecSD(y,(n+1),k),(n+1)),k)
        + SD_Add_Carry(DigA(DecSD(x,(n+1),k),n)
        + DigA(DecSD(y,(n+1),k),n)))*(Radix(k) |^ n)
        + Sum DigitSD(zn) by BINARITH:39
     .= (SD_Add_Data(DigA(DecSD(x,(n+1),k),(n+1))
        + DigA(DecSD(y,(n+1),k),(n+1)),k)
        + SD_Add_Carry(DigA(DecSD(xn,n,k),n)
        + DigA(DecSD(y,(n+1),k),n)))*(Radix(k) |^ n)
        + Sum DigitSD(zn) by A7,Lm3
     .= (SD_Add_Data(DigA(DecSD(x,(n+1),k),(n+1))
        + DigA(DecSD(y,(n+1),k),(n+1)),k)
        + SD_Add_Carry(DigA(DecSD(xn,n,k),n)
        + DigA(DecSD(yn,n,k),n)))*(Radix(k) |^ n)
        + Sum DigitSD(zn) by A7,Lm3
     .= (SD_Add_Data(x1+y1,k)+ SD_Add_Carry(DigA(DecSD(xn,n,k),n)
        + DigA(DecSD(yn,n,k),n)))*(Radix(k) |^ n)
        + Sum DigitSD(zn) by A9,A10,Th27
     .= SD_Add_Data(x1+y1,k)*(Radix(k) |^ n)
        + (SD_Add_Carry(DigA(DecSD(xn,n,k),n)+DigA(DecSD(yn,n,k),n))
        *(Radix(k) |^ n)+(SDDec(DecSD(xn,n,k)'+'DecSD(yn,n,k))))
     .= SD_Add_Data(x1+y1,k)*(Radix(k) |^ n) + (xn + yn) by A6,A9,A13
     .= SD_Add_Data(x1+y1,k)*(Radix(k) |^ n) + xn + yn;
    then SDDec(z) + SD_Add_Carry(x1+y1)*(Radix(k) |^ (n+1))
        = SD_Add_Data(x1+y1,k)*(Radix(k) |^ n)
              + SD_Add_Carry(x1+y1)*(Radix(k) |^ (n+1))+ xn + yn
        .= SD_Add_Data(x1+y1,k)*(Radix(k) |^ n)
              + SD_Add_Carry(x1+y1)*((Radix(k) |^ n)*Radix(k)) + xn + yn
                                                        by NEWTON:11
        .= (x1*(Radix(k) |^ n) + xn) + (y1*(Radix(k) |^ n) + yn)
        .= x + y by A11,A12,NAT_1:47;
    hence thesis by A9,A10,Th27;
  end;
     for n be Element of NAT st n >= 1 holds P[n] from NAT_1:sch 9(A1,A5);
  hence thesis;
end;

