:: Definitions of Radix-2k Signed-Digit number and its adder algorithm
::  by Yoshinori Fujisawa and Yasushi Fuwa
::
:: Received September 7, 1999
:: Copyright (c) 1999 Association of Mizar Users

environ

 vocabularies INT_1, NAT_1, ARYTM_1, ARYTM_3, POWER, MIDSP_3, FINSEQ_1,
      FUNCT_1, RELAT_1, RLVECT_1, RADIX_1, FINSEQ_4, GROUP_1, ARYTM;
 notations TARSKI, XBOOLE_0, SUBSET_1, NUMBERS, XCMPLX_0, INT_1, NAT_1, NAT_D,
      FUNCT_1, PARTFUN1, NEWTON, POWER, FINSEQ_1, BINARITH, TREES_4, GR_CY_1,
      XXREAL_0, MESFUNC1;
 constructors PARTFUN1, REAL_1, NAT_1, NAT_D, FINSOP_1, NEWTON, POWER,
      MESFUNC1, BINARITH, WSIERP_1, GR_CY_1, BINOP_2, RELSET_1;
 registrations RELSET_1, FINSET_1, NUMBERS, XXREAL_0, XREAL_0, NAT_1, INT_1,
      MEMBERED, NEWTON, XBOOLE_0, VALUED_0, POWER, FINSEQ_2;
 requirements REAL, NUMERALS, SUBSET, BOOLE, ARITHM;
 definitions TARSKI, RVSUM_1;
 theorems NAT_1, NAT_2, INT_1, FINSEQ_1, EULER_1, PREPOWER, POWER, RVSUM_1,
      FINSEQ_2, FINSEQ_4, TARSKI, FUNCT_1, PEPIN, FINSEQ_5, NEWTON, XCMPLX_1,
      XREAL_1, XXREAL_0, FINSOP_1, ORDINAL1, NAT_D, PARTFUN1;
 schemes NAT_1, FINSEQ_2;

begin :: Some Useful Theorems

reserve k,m,n for Nat,
  i1,i2,i3 for Integer,
  e for set;

canceled;

theorem Th2:
  n mod k = k - 1 implies (n+1) mod k = 0
proof
  per cases;
  suppose
A1: k <> 0;
    assume
A2: n mod k = k-1;
    k >= 1 by A1,NAT_1:14;
    then reconsider K = k - 1 as Element of NAT by INT_1:16,XREAL_1:50;
    K + 1 = k - 0;
    then (n+1) mod k = k mod k by A2,NAT_D:22;
    hence thesis by NAT_D:25;
  end;
  suppose k=0;
    hence thesis;
  end;
end;

theorem Th3:
  k <> 0 & n mod k < k - 1 implies (n+1) mod k = (n mod k) + 1
proof
  assume k <> 0 & n mod k < k - 1;
  then
A1: (n mod k) + 1 < k by XREAL_1:22;
  (n+1) mod k = ((n mod k)+1) mod k by NAT_D:22;
  hence thesis by A1,NAT_D:24;
end;

theorem Th4:
  m <> 0 implies (k mod (m*n)) mod n = k mod n
proof
  assume
A1: m <> 0;
  per cases;
  suppose
A2: n <> 0;
    reconsider k' = k, m' = m, n' = n as Integer;
    m'*n' <> 0 by A1,A2,XCMPLX_1:6;
    hence (k mod (m*n)) mod n = (k' - (k' div (m'*n'))*(m'*n')) mod n' by
INT_1:def 8
      .= (k' + (-(m'*(k' div m'*n')))*n') mod n'
      .= k mod n by EULER_1:13;
  end;
  suppose
A3: n = 0;
    hence (k mod (m*n)) mod n = 0 by NAT_D:def 2
      .= k mod n by A3,NAT_D:def 2;
  end;
end;

theorem
  k <> 0 implies (n+1) mod k = 0 or (n+1) mod k = (n mod k) + 1
proof
  assume
A1: k <> 0;
  then k >= 1 by NAT_1:14;
  then reconsider K = k - 1 as Element of NAT by INT_1:16,XREAL_1:50;
  k > 0 by A1;
  then n mod k < k - 1 + 1 by NAT_D:1;
  then
A2: n mod k <= K by NAT_1:13;
  per cases by A2,XXREAL_0:1;
  suppose n mod k < k - 1;
    hence thesis by A1,Th3;
  end;
  suppose n mod k = k - 1;
    hence thesis by Th2;
  end;
end;

reserve i,k,m,n,p,x,y for Nat;

theorem Th6:
  i <> 0 & k <> 0 implies (n mod (i |^ k)) div (i |^ (k -'1)) < i
proof
  assume
A1: i <> 0 & k <> 0;
  then
A2: i > 0;
  then
A3: n mod (i |^ k) < (i |^ k) by NAT_D:1,PREPOWER:13;
  reconsider n,i,k as Element of NAT by ORDINAL1:def 13;
  set I1 = i |^ (k -'1);
  set T = n mod (i |^ k);
A4: I1 > 0 by A2,PREPOWER:13;
A5: I1 <> 0 by A2,PREPOWER:13;
  i |^ k = i*(i |^ (k -'1)) by A1,PEPIN:27;
  then T mod I1 = n mod I1 by A1,Th4
    .= n - I1*(n div I1) by A2,NEWTON:77,PREPOWER:13;
  then T = I1*(T div I1) + (n - I1*(n div I1)) by A2,NAT_D:2,PREPOWER:13;
  then I1*(T div I1) + (n - I1*(n div I1)) < i*I1 by A1,A3,PEPIN:27;
  then (I1*(T div I1) + n - I1*(n div I1))/I1 < i*I1/I1 by A4,XREAL_1:76;
  then I1*(T div I1)/I1 + n/I1 - I1*(n div I1)/I1 < i*I1/I1 by XCMPLX_1:125;
  then (T div I1) + n/I1 - I1*(n div I1)/I1 < i*I1/I1 by A5,XCMPLX_1:90;
  then (T div I1) + n/I1 - (n div I1) < i*I1/I1 by A5,XCMPLX_1:90;
  then
A6: (T div I1) + n/I1 - (n div I1) < i by A5,XCMPLX_1:90;
A7: n div I1 = [\n/I1/] by INT_1:def 7;
  [\n/I1/] <= n/I1 by INT_1:def 4;
  then (T div I1) + [\n/I1/] <= (T div I1) + n/I1 by XREAL_1:8;
  then (T div I1) + [\n/I1/] - [\n/I1/] <= (T div I1) + n/I1 - (n div I1)
  by A7,XREAL_1:11;
  hence thesis by A6,XXREAL_0:2;
end;

theorem Th7:
  k <= n implies m |^ k divides m |^ n
proof
  assume k <= n;
  then consider t being Nat such that
A1: n = k + t by NAT_1:10;
  reconsider t as Element of NAT by ORDINAL1:def 13;
  m |^ n = (m |^ k)*(m |^ t) by A1,NEWTON:13;
  hence thesis by NAT_D:def 3;
end;

theorem
  i2 > 0 & i3 >= 0 implies (i1 mod (i2*i3)) mod i3 = i1 mod i3
proof
  assume
A1: i2 > 0 & i3 >= 0;
  per cases by A1;
  suppose i3 > 0;
    then i2*i3 <> 0 by A1,XCMPLX_1:6;
    then (i1 mod (i2*i3)) mod i3
    = (i1 - (i1 div (i2*i3))*(i2*i3)) mod i3 by INT_1:def 8
      .= (i1 + (-(i2*(i1 div i2*i3)))*i3) mod i3;
    hence thesis by EULER_1:13;
  end;
  suppose
A2: i3 = 0;
    then (i1 mod (i2*i3)) mod i3 = 0 by INT_1:def 8;
    hence thesis by A2,INT_1:def 8;
  end;
end;

begin :: Definition for Radix-2^k, k-SD

definition
  let n be Nat;
  func Radix(n) -> Element of NAT equals

  2 to_power n;
  correctness by ORDINAL1:def 13;
end;

definition
  let k be Nat;
  func k-SD -> set equals
  {e where e is Element of INT:e <= Radix(k)-1 & e >= -Radix(k)+1};
  correctness;
end;

Lm1: for k be Nat st k >= 2 holds Radix(k) >= 2 + 2
proof
  let k;
  defpred P[Nat] means Radix($1) >= 2+2;
  Radix(2) = 2 to_power (1+1)
    .= 2 to_power 1 * 2 to_power 1 by POWER:32
    .= 2 * 2 to_power 1 by POWER:30
    .= 2 * 2 by POWER:30;
  then
A1: P[2];
A2: for kk be Nat st kk >= 2 & P[kk] holds P[kk+1]
  proof
    let kk be Nat;
    assume kk >= 2;
    assume
A3: Radix(kk) >= 2 + 2;
    Radix(kk+1) = 2 to_power kk * 2 to_power 1 by POWER:32
      .= Radix(kk) * 2 by POWER:30;
    then Radix(kk+1) >= Radix(kk) by XREAL_1:157;
    hence thesis by A3,XXREAL_0:2;
  end;
  for k be Nat st k >= 2 holds P[k] from NAT_1:sch 8(A1,A2);
  hence thesis;
end;

canceled;

theorem Th10:
  for e holds e in 0-SD iff e = 0
proof
  let e be set;
A1: Radix(0) = 1 by POWER:29;
  hereby
    assume e in 0-SD;
    then consider b be Element of INT such that
A2: e = b and
A3: b <= 0 & b >= 0 by A1;
    thus e = 0 by A2,A3;
  end;
  assume
A4: e = 0;
  then e is Element of INT by INT_1:def 2;
  hence thesis by A1,A4;
end;

theorem
  0-SD = {0} by Th10,TARSKI:def 1;

theorem Th12:
  k-SD c= (k+1)-SD
proof
  let e be set;
  assume e in k-SD;
  then consider g being Element of INT such that
A1: e = g and
A2: g <= Radix(k)-1 and
A3: g >= -Radix(k)+1;
  k < k+1 by NAT_1:13;
  then
A4: 2 to_power k < 2 to_power (k+1) by POWER:44;
  then Radix(k)-1 < Radix(k+1)-1 by XREAL_1:11;
  then
A5: g <= Radix(k+1)-1 by A2,XXREAL_0:2;
  -Radix(k) > -Radix(k+1) by A4,XREAL_1:26;
  then -Radix(k)+1 > -Radix(k+1)+1 by XREAL_1:8;
  then g >= -Radix(k+1)+1 by A3,XXREAL_0:2;
  hence thesis by A1,A5;
end;

theorem Th13:
  e in k-SD implies e is Integer
proof
  assume e in k-SD;
  then consider t be Element of INT such that
A1: e = t and t <= Radix(k)-1 & t >= -Radix(k)+1;
  thus thesis by A1;
end;

theorem Th14:
  k-SD c= INT
proof
  let e be set;
  assume e in k-SD;
  then e is Integer by Th13;
  hence thesis by INT_1:def 2;
end;

theorem Th15:
  i1 in k-SD implies i1 <= Radix(k)-1 & i1 >= -Radix(k)+1
proof
  assume i1 in k-SD;
  then consider i be Element of INT such that
A1: i = i1 and
A2: i <= Radix(k)-1 & i >= -Radix(k)+1;
  thus thesis by A1,A2;
end;

theorem Th16:
  0 in k-SD
proof
  defpred P[Nat] means 0 in $1-SD;
A1: P[0] by Th10;
A2: for k being Nat st P[k] holds P[k+1]
  proof
    let kk be Nat;
    assume
A3: 0 in kk-SD;
    kk-SD c= (kk+1)-SD by Th12;
    hence thesis by A3;
  end;
  for k being Nat holds P[k] from NAT_1:sch 2(A1,A2);
  hence thesis;
end;

registration
  let k be Nat;
  cluster k-SD -> non empty;
  coherence by Th16;
end;

definition
  let k be Nat;
  redefine func k-SD -> non empty Subset of INT;
  coherence by Th14;
end;

begin :: Functions for generating Radix-2^k SD numbers from natural numbers

:: and natural numbers from Radix-2^k SD numbers

reserve a for Tuple of n,(k-SD);

canceled;

theorem Th18:
  i in Seg n implies a.i is Element of k-SD
proof
  assume
A1: i in Seg n;
  len a = n by FINSEQ_1:def 18;
  then i in dom a by A1,FINSEQ_1:def 3;
  then a.i in rng a & rng a c= k-SD by FINSEQ_1:def 4,FUNCT_1:def 5;
  hence thesis;
end;

definition
  let i,k,n be Nat, x be Tuple of n,(k-SD);
  func DigA(x,i) -> Integer equals
  :Def3:
  x.i if i in Seg n, 0 if i = 0;
  coherence;
  consistency by FINSEQ_1:3;
end;

definition
  let i,k,n be Nat, x be Tuple of n,(k-SD);
  func DigB(x,i) -> Element of INT equals

  DigA(x,i);
  coherence by INT_1:def 2;
end;

theorem Th19:
  i in Seg n implies DigA(a,i) is Element of k-SD
proof
  assume
A1: i in Seg n;
  then a.i = DigA(a,i) by Def3;
  hence thesis by A1,Th18;
end;

theorem Th20:
  for x be Tuple of 1,INT st x/.1 = m holds x = <*m*>
proof
  let x be Tuple of 1,INT;
  assume
A1: x/.1 = m;
A2: len x = 1 by FINSEQ_1:def 18;
  then x/.1 = x.1 by FINSEQ_4:24;
  hence thesis by A1,A2,FINSEQ_1:57;
end;

definition
  let i,k,n be Nat, x be Tuple of n,(k-SD);
  func SubDigit(x,i,k) -> Element of INT equals
  (Radix(k) |^ (i -'1))*DigB(x,i);
  coherence by INT_1:def 2;
end;

definition
  let n,k be Nat, x be Tuple of n,(k-SD);
  func DigitSD(x) -> Tuple of n,INT means
  :Def6:
  for i be Nat st i in Seg n holds it/.i = SubDigit(x,i,k);
  existence
  proof
    deffunc F(Nat)=SubDigit(x,$1,k);
    consider z being FinSequence of INT such that
A1: len z = n and
A2: for j be Nat st j in dom z holds z.j = F(j) from FINSEQ_2:sch 1;
A3: dom z = Seg n by A1,FINSEQ_1:def 3;
    reconsider z as Tuple of n,INT by A1,FINSEQ_2:110;
    take z;
    let i be Nat;
    assume
A4: i in Seg n;
    then i in dom z by A1,FINSEQ_1:def 3;
    hence z/.i = z.i by PARTFUN1:def 8
      .= SubDigit(x,i,k) by A2,A4,A3;
  end;
  uniqueness
  proof
    let k1,k2 be Tuple of n,INT such that
A5: for i be Nat st i in Seg n holds k1/.i = SubDigit(x,i,k) and
A6: for i be Nat st i in Seg n holds k2/.i = SubDigit(x,i,k);
A7: len k1 = n & len k2 = n by FINSEQ_1:def 18;
X: dom k1 = Seg n by A7,FINSEQ_1:def 3;
    now
      let j be Nat;
      assume
A8:   j in dom k1;
      then
A9:   j in dom k1 & j in dom k2 by A7,X,FINSEQ_1:def 3;
      then k1.j = k1/.j by PARTFUN1:def 8
        .= SubDigit(x,j,k) by A5,A8,X
        .= k2/.j by A6,A8,X
        .= k2.j by A9,PARTFUN1:def 8;
      hence k1.j = k2.j;
    end;
    hence thesis by A7,FINSEQ_2:10;
  end;
end;

definition
  let n,k be Nat, x be Tuple of n,(k-SD);
  func SDDec(x) -> Integer equals

  Sum DigitSD(x);
  coherence;
end;

definition
  let i,k,x be Nat;
  func DigitDC(x,i,k) -> Element of k-SD equals
  (x mod (Radix(k) |^ i)) div (Radix(k) |^ (i -'1));
  coherence
  proof
    reconsider i,k as Element of NAT by ORDINAL1:def 13;
    set T = Radix(k) |^ i;
    set S = Radix(k) |^ (i -'1);
A1: Radix(k) <> 0 by POWER:39;
    then
A2: Radix(k) >= 1 by NAT_1:14;
A3: T > 0 by A1,NAT_1:14,PREPOWER:19;
A4: S > 0 by A1,NAT_1:14,PREPOWER:19;
    then
A5: 0 div S = 0 by NAT_D:27;
    defpred P[Nat] means ($1 mod T) div S is Element of k-SD;
    0 in k-SD by Th16;
    then
A6: P[0] by A3,A5,NAT_D:24;
A7: for x being Nat st P[x] holds P[(x+1)]
    proof
      let xx be Nat;
      assume (xx mod T) div S is Element of k-SD;
      set X = ((xx+1) mod T) div S;
      reconsider R = Radix(k)-1 as Element of NAT by A2,INT_1:16,XREAL_1:50;
      per cases;
      suppose
A8:     i = 0;
        Radix(k) |^ i = Radix(k) to_power i
          .= 1 by A8,POWER:29;
        then ((xx+1) mod T) = (((xx+1)*1) mod 1)
          .= 0 by NAT_D:13;
        then X = 0 by A4,NAT_D:27;
        hence thesis by Th16;
      end;
      suppose i > 0;
        then X < Radix(k) - 1 + 1 by A1,Th6;
        then
A9:     X <= R by NAT_1:13;
A10:    X is Element of INT by INT_1:def 2;
        -1 >= -Radix(k) by A2,XREAL_1:26;
        then 0 >= -Radix(k)+1 by XREAL_1:61;
        then X in k-SD by A9,A10;
        hence thesis;
      end;
    end;
    for x being Nat holds P[x] from NAT_1:sch 2(A6,A7);
    hence thesis;
  end;
end;

definition
  let k,n,x be Nat;
  func DecSD(x,n,k) -> Tuple of n,(k-SD) means
  :Def9:
  for i be Nat st i in Seg n holds DigA(it,i) = DigitDC(x,i,k);
  existence
  proof
    deffunc F(Nat)=DigitDC(x,$1,k);
    consider z being FinSequence of k-SD such that
A1: len z = n and
A2: for j be Nat st j in dom z holds z.j = F(j) from FINSEQ_2:sch 1;
A3: dom z = Seg n by A1,FINSEQ_1:def 3;
    reconsider z as Tuple of n,(k-SD) by A1,FINSEQ_2:110;
    take z;
    let i;
    assume
A4: i in Seg n;
    hence DigA(z,i) = z.i by Def3
      .= DigitDC(x,i,k) by A2,A4,A3;
  end;
  uniqueness
  proof
    let k1,k2 be Tuple of n,(k-SD) such that
A5: for i be Nat st i in Seg n holds DigA(k1,i) = DigitDC(x,i,k) and
A6: for i be Nat st i in Seg n holds DigA(k2,i) = DigitDC(x,i,k);
A7: len k1 = n & len k2 = n by FINSEQ_1:def 18;
X: dom k1 = Seg n by A7,FINSEQ_1:def 3;
    now
      let j be Nat;
      assume
A8:   j in dom k1;
      then k1.j = DigA(k1,j) by Def3,X
        .= DigitDC(x,j,k) by A5,A8,X
        .= DigA(k2,j) by A6,A8,X
        .= k2.j by A8,Def3,X;
      hence k1.j = k2.j;
    end;
    hence thesis by A7,FINSEQ_2:10;
  end;
end;

begin :: Definition for carry & data components of Addition

definition
  let x be Integer;
  func SD_Add_Carry(x) -> Integer equals
  :Def10:
  1 if x > 2, -1 if x < -2
  otherwise 0;
  coherence;
  consistency;
end;

theorem Th21:
  SD_Add_Carry(0) = 0 by Def10;

Lm2: for x be Integer holds -1 <= SD_Add_Carry(x) & SD_Add_Carry(x) <= 1
proof
  let x be Integer;
  per cases;
  suppose x < -2;
    hence thesis by Def10;
  end;
  suppose -2 <= x & x <= 2;
    hence thesis by Def10;
  end;
  suppose x > 2;
    hence thesis by Def10;
  end;
end;

definition
  let x be Integer, k be Nat;
  func SD_Add_Data(x,k) -> Integer equals

  x - SD_Add_Carry(x)*Radix(k);
  coherence;
end;

theorem
  SD_Add_Data(0,k) = 0 by Th21;

theorem Th23:
  k >= 2 & i1 in k-SD & i2 in k-SD implies
  -Radix(k)+2 <= SD_Add_Data(i1+i2,k) & SD_Add_Data(i1+i2,k) <= Radix(k)-2
proof
  assume
A1: k >= 2 & i1 in k-SD & i2 in k-SD;
  then
A2: -Radix(k)+1 <= i1 & i1 <= Radix(k)-1 &
  -Radix(k)+1 <= i2 & i2 <= Radix(k)-1 by Th15;
  set z = i1+i2;
A3: -Radix(k)+1 + (-Radix(k)+1) <= z &
  z <= Radix(k)-1 + (Radix(k)-1) by A2,XREAL_1:9;
  per cases;
  suppose
A4: z < -2;
    then
A5: SD_Add_Carry(z) = -1 by Def10;
    -Radix(k)+1 + (1 + -Radix(k)) <= z by A2,XREAL_1:9;
    then
A6: (-Radix(k)+(1+1))-Radix(k) <= z;
    z + Radix(k) < -2 + Radix(k) by A4,XREAL_1:8;
    hence thesis by A5,A6,XREAL_1:22;
  end;
  suppose
A7: -2 <= z & z <= 2;
    then
A8: SD_Add_Carry(z) = 0 by Def10;
A9: Radix(k) >= 2+2 by A1,Lm1;
    then
A10: Radix(k)-2 >= 2 by XREAL_1:21;
    -Radix(k) <= -(2+2) by A9,XREAL_1:26;
    then -Radix(k) <= -2 + -2;
    then -Radix(k) - -2 <= -2 by XREAL_1:22;
    hence thesis by A7,A8,A10,XXREAL_0:2;
  end;
  suppose
A11: z > 2;
    then
A12: SD_Add_Carry(z) = 1 by Def10;
A13: z <= Radix(k)-1 -1 + Radix(k) by A3;
    z - Radix(k) > 2 - Radix(k) by A11,XREAL_1:11;
    hence thesis by A12,A13,XREAL_1:22;
  end;
end;

begin :: Definition for checking whether or not a natural number can be

:: expressed as n digits Radix-2^k SD number

definition
  let n,x,k be Nat;
  pred x is_represented_by n,k means
  :Def12:
  x < (Radix(k) |^ n);
end;

theorem Th24:
  m is_represented_by 1,k implies DigA(DecSD(m,1,k),1) = m
proof
  assume m is_represented_by 1,k;
  then
A1: m < Radix(k) |^ 1 by Def12;
  1 in Seg 1 by FINSEQ_1:3;
  hence DigA(DecSD(m,1,k),1) = DigitDC(m,1,k) by Def9
    .= (m mod (Radix(k) |^ 1)) div (Radix(k) |^ 0) by XREAL_1:234
    .= (m mod (Radix(k) |^ 1)) div 1 by NEWTON:9
    .= m mod (Radix(k) |^ 1) by NAT_2:6
    .= m by A1,NAT_D:24;
end;

theorem
  for n st n >= 1 holds
  for m st m is_represented_by n,k holds m = SDDec(DecSD(m,n,k))
proof
  let n;
  defpred P[Nat] means
  for m st m is_represented_by $1,k holds m = SDDec(DecSD(m,$1,k));
A1: P[1]
  proof
    let m;
    assume
A2: m is_represented_by 1,k;
A3: 1 in Seg 1 by FINSEQ_1:3;
    SubDigit(DecSD(m,1,k),1,k) = (Radix(k) |^ 0)*DigB(DecSD(m,1,k),1)
    by XREAL_1:234
      .= 1*DigB(DecSD(m,1,k),1) by NEWTON:9
      .= m by A2,Th24;
    then
A4: (DigitSD(DecSD(m,1,k)))/.1 = m by A3,Def6;
A5: m is Element of INT by INT_1:def 2;
    then reconsider M = <*m*> as FinSequence of INT by FINSEQ_1:95;
    thus SDDec(DecSD(m,1,k)) = Sum M by A4,Th20
      .= m by A5,FINSOP_1:12;
  end;
A6: for u be Nat st u >= 1 & P[u] holds P[u+1]
  proof
    let u be Nat;
    assume
A7: u >= 1 & P[u];
    p is_represented_by (u+1),k implies p = SDDec(DecSD(p,(u+1),k))
    proof
      assume p is_represented_by (u+1),k;
      then
A8:   p < Radix(k) |^ (u+1) by Def12;
      set R = Radix(k) |^ u;
      Radix(k) <> 0 by POWER:39;
      then R <> 0 by PREPOWER:12;
      then
A9:   R > 0;
      then
A10:  p = R*(p div R) + (p mod R) by NAT_D:2;
      set M = p mod R;
      set N = R*(p div R);
      M < R by A9,NAT_D:1;
      then M is_represented_by u,k by Def12;
      then
A11:  p = SDDec(DecSD(M,u,k)) + N by A7,A10;
      set I = u + 1;
A12:  I -' 1 = u by NAT_D:34;
      then
A13:  p div R = DigitDC(p,(u+1),k) by A8,NAT_D:24;
A14:  1 <= u+1 & u+1 <= u+1 by NAT_1:12;
      then
A15:  u+1 in Seg (u+1) by FINSEQ_1:3;
A16:  u+1 <= len (DigitSD(DecSD(p,(u+1),k))) by FINSEQ_1:def 18;
A17:  N = SubDigit(DecSD(p,(u+1),k),(u+1),k) by A12,A13,A15,Def9
        .= (DigitSD(DecSD(p,(u+1),k)))/.(u+1) by A15,Def6
        .= DigitSD(DecSD(p,(u+1),k)).(u+1) by A16,FINSEQ_4:24,NAT_1:12;
      DigitSD(DecSD(M,u,k))^<*N*> = DigitSD(DecSD(p,(u+1),k))
      proof
A18:    N is Element of INT by INT_1:def 2;
        set z0 = DigitSD(DecSD(M,u,k));
        reconsider z1 = <*N*> as FinSequence of INT by A18,FINSEQ_1:95;
        reconsider DD = DigitSD(DecSD(p,(u+1),k)) as FinSequence of INT;
        reconsider z = z0^z1 as FinSequence of INT;
A19:    len z = len (DigitSD(DecSD(M,u,k))) + len <*N*> by FINSEQ_1:35
          .= u + len <*N*> by FINSEQ_1:def 18
          .= u + 1 by FINSEQ_1:56;
A20:    len DD = u+1 by FINSEQ_1:def 18;
        for i be Nat st 1 <= i & i <= len z holds z/.i = DD/.i
        proof
          let i be Nat;
          assume 1 <= i & i <= len z;
          then
A21:      i in Seg (u+1) by A19,FINSEQ_1:3;
          per cases by A21,FINSEQ_2:8;
          suppose
A22:        i in Seg u;
A23:        M mod (Radix(k) |^ i) = p mod (Radix(k) |^ i)
            proof
              i <= u by A22,FINSEQ_1:3;
              then Radix(k) |^ i divides Radix(k) |^ u by Th7;
              then consider t being Nat such that
A24:          Radix(k) |^ u = (Radix(k) |^ i)*t by NAT_D:def 3;
              Radix(k) <> 0 by POWER:39;
              then t <> 0 by A24,PREPOWER:12;
              hence thesis by A24,Th4;
            end;
            len z0 = u by FINSEQ_1:def 18;
            then
A25:        i in dom z0 by A22,FINSEQ_1:def 3;
            then
A26:        (z0^z1).i = DigitSD(DecSD(M,u,k)).i by FINSEQ_1:def 7
              .= (DigitSD(DecSD(M,u,k)))/.i by A25,PARTFUN1:def 8
              .= SubDigit(DecSD(M,u,k),i,k) by A22,Def6
              .= (Radix(k) |^ (i -'1))*DigitDC(M,i,k) by A22,Def9
              .= (Radix(k) |^ (i -'1))*((p mod (Radix(k) |^ i))
            div (Radix(k) |^ (i -'1))) by A23;
            len DD = u+1 by FINSEQ_1:def 18;
            then
A27:        i in dom DD by A21,FINSEQ_1:def 3;
            then
A28:        DD.i = (DigitSD(DecSD(p,(u+1),k)))/.i by PARTFUN1:def 8
              .= SubDigit(DecSD(p,(u+1),k),i,k) by A21,Def6
              .= (Radix(k) |^ (i -'1))*DigitDC(p,i,k) by A21,Def9
              .= (Radix(k) |^ (i -'1))*((p mod (Radix(k) |^ i))
            div (Radix(k) |^ (i -'1)));
A29:        DD.i = DD/.i by A27,PARTFUN1:def 8;
            i in dom (z0^z1) by A19,A21,FINSEQ_1:def 3;
            hence thesis by A26,A28,A29,PARTFUN1:def 8;
          end;
          suppose
A30:        i = u+1;
            hence z/.i = z.(u+1) by A14,A19,FINSEQ_4:24
              .= (z0^z1).(len z0 + 1) by FINSEQ_1:def 18
              .= DigitSD(DecSD(p,(u+1),k)).(u+1) by A17,FINSEQ_1:59
              .= DD/.i by A16,A30,FINSEQ_4:24,NAT_1:12;
          end;
        end;
        hence thesis by A19,A20,FINSEQ_5:14;
      end;
      hence thesis by A11,RVSUM_1:104;
    end;
    hence thesis;
  end;
  for u be Nat st u >= 1 holds P[u] from NAT_1:sch 8(A1,A6);
  hence thesis;
end;

theorem Th26:
  k >= 2 & m is_represented_by 1,k & n is_represented_by 1,k implies
  SD_Add_Carry(DigA(DecSD(m,1,k),1)+DigA(DecSD(n,1,k),1)) = SD_Add_Carry(m+n)
proof
  assume
A1: k >= 2 & m is_represented_by 1,k & n is_represented_by 1,k;
  then SD_Add_Carry(DigA(DecSD(m,1,k),1)+DigA(DecSD(n,1,k),1))
  = SD_Add_Carry(m + DigA(DecSD(n,1,k),1)) by Th24
    .= SD_Add_Carry(m + n) by A1,Th24;
  hence thesis;
end;

Lm3: for i st i in Seg n holds
DigA(DecSD(m,n+1,k),i)=DigA(DecSD((m mod (Radix(k) |^ n)),n,k),i)
proof
  let i;
  assume
A1: i in Seg n;
  then
A2: 1 <= i & i <= n by FINSEQ_1:3;
  then i <= n+1 by NAT_1:12;
  then
A3: i in Seg (n+1) by A2,FINSEQ_1:3;
  Radix(k) |^ i divides Radix(k) |^ n by A2,Th7;
  then consider t be Nat such that
A4: Radix(k) |^ n = (Radix(k) |^ i)*t by NAT_D:def 3;
  Radix(k) <> 0 by POWER:39;
  then
A5: t <> 0 by A4,PREPOWER:12;
  DigA(DecSD((m mod (Radix(k) |^ n)),n,k),i)
  = DigitDC((m mod (Radix(k) |^ n)),i,k) by A1,Def9
    .= DigitDC(m,i,k) by A4,A5,Th4
    .= DigA(DecSD(m,n+1,k),i) by A3,Def9;
  hence thesis;
end;

theorem Th27:
  m is_represented_by (n+1),k implies
  DigA(DecSD(m,(n+1),k),n+1) = m div (Radix(k) |^ n)
proof
  assume
A1: m is_represented_by (n+1),k;
A2: n+1 in Seg (n+1) by FINSEQ_1:5;
A3: m < Radix(k) |^ (n+1) by A1,Def12;
  DigA(DecSD(m,(n+1),k),n+1) = DigitDC(m,n+1,k) by A2,Def9
    .= m div (Radix(k) |^ ((n+1) -'1)) by A3,NAT_D:24
    .= m div (Radix(k) |^ n) by NAT_D:34;
  hence thesis;
end;

begin :: Definition for Addition operation for a high-speed adder algorithm

:: on Radix-2^k SD number

definition
  let k,i,n be Nat, x,y be Tuple of n,(k-SD);
  assume
A1: i in Seg n & k >= 2;
  func Add(x,y,i,k) -> Element of k-SD equals
  :Def13:
  SD_Add_Data(DigA(x,i)+DigA(y,i),k)
  + SD_Add_Carry(DigA(x,i -'1)+DigA(y,i -'1));
  coherence
  proof
    set SDD = SD_Add_Data(DigA(x,i)+DigA(y,i),k);
    set SDC = SD_Add_Carry(DigA(x,i -'1)+DigA(y,i -'1));
A2: DigA(x,i) is Element of k-SD by A1,Th19;
    DigA(y,i) is Element of k-SD by A1,Th19;
    then
A3: -Radix(k)+2 <= SDD & SDD <= Radix(k)-2 by A1,A2,Th23;
A4: SDD + SDC is Element of INT by INT_1:def 2;
    -1 <= SDC & SDC <= 1 by Lm2;
    then -Radix(k)+2 +(-1) <= SDD + SDC & SDD + SDC <= Radix(k)-2 + 1
    by A3,XREAL_1:9;
    then SDD + SDC in k-SD by A4;
    hence thesis;
  end;
end;

definition
  let n,k be Nat,x,y be Tuple of n,(k-SD);
  func x '+' y -> Tuple of n,(k-SD) means
  :Def14:
  for i st i in Seg n holds DigA(it,i) = Add(x,y,i,k);
  existence
  proof
    deffunc F(Nat)= Add(x,y,$1,k);
    consider z being FinSequence of (k-SD) such that
A1: len z = n and
A2: for j be Nat st j in dom z holds z.j = F(j) from FINSEQ_2:sch 1;
A3: dom z = Seg n by A1,FINSEQ_1:def 3;
    reconsider z as Tuple of n,(k-SD) by A1,FINSEQ_2:110;
    take z;
    let i;
    assume
A4: i in Seg n;
    hence DigA(z,i) = z.i by Def3
      .= Add(x,y,i,k) by A2,A4,A3;
  end;
  uniqueness
  proof
    let k1,k2 be Tuple of n,(k-SD) such that
A5: for i st i in Seg n holds DigA(k1,i) = Add(x,y,i,k) and
A6: for i st i in Seg n holds DigA(k2,i) = Add(x,y,i,k);
A7: len k1 = n & len k2 = n by FINSEQ_1:def 18;
X: dom k1 = Seg n by A7,FINSEQ_1:def 3;
    now
      let j be Nat;
      assume
A8:   j in dom k1;
      then k1.j = DigA(k1,j) by Def3,X
        .= Add(x,y,j,k) by A5,A8,X
        .= DigA(k2,j) by A6,A8,X
        .= k2.j by A8,Def3,X;
      hence k1.j = k2.j;
    end;
    hence thesis by A7,FINSEQ_2:10;
  end;
end;

theorem Th28:
  k >= 2 & m is_represented_by 1,k & n is_represented_by 1,k implies
  SDDec(DecSD(m,1,k)'+'DecSD(n,1,k)) = SD_Add_Data(m+n,k)
proof
  assume
A1: k >= 2 & m is_represented_by 1,k & n is_represented_by 1,k;
  set M = DecSD(m,1,k);
  set N = DecSD(n,1,k);
A2: 1 in Seg 1 by FINSEQ_1:3;
  then
A3: DigA((M '+' N),1) = Add(M,N,1,k) by Def14
    .= SD_Add_Data(DigA(M,1)+DigA(N,1),k)
  + SD_Add_Carry(DigA(M,1 -'1)+DigA(N,1 -'1)) by A1,A2,Def13
    .= SD_Add_Data(DigA(M,1)+DigA(N,1),k)
  + SD_Add_Carry(DigA(M,0)+DigA(N,1 -'1)) by XREAL_1:234
    .= SD_Add_Data(DigA(M,1)+DigA(N,1),k) + SD_Add_Carry(DigA(M,0)+DigA(N,0))
  by XREAL_1:234
    .= SD_Add_Data(DigA(M,1)+DigA(N,1),k) + SD_Add_Carry(0+DigA(N,0)) by Def3
    .= SD_Add_Data(DigA(M,1)+DigA(N,1),k) + 0 by Def3,Th21
    .= SD_Add_Data(m+DigA(N,1),k) by A1,Th24
    .= SD_Add_Data(m+n,k) by A1,Th24;
A4: (DigitSD(M '+' N))/.1 = SubDigit((M '+' N),1,k) by A2,Def6
    .= (Radix(k) |^ 0)*DigA((M '+' N),1) by XREAL_1:234
    .= 1*DigA((M '+' N),1) by NEWTON:9
    .= SD_Add_Data(m+n,k) by A3;
A5: len (DigitSD(M '+' N)) = 1 by FINSEQ_1:def 18;
  1 in Seg 1 by FINSEQ_1:3;
  then 1 in dom DigitSD(M '+' N) by A5,FINSEQ_1:def 3;
  then
A6: DigitSD(M '+' N).1 = SD_Add_Data(m+n,k) by A4,PARTFUN1:def 8;
  reconsider w = SD_Add_Data(m+n,k) as Element of INT by INT_1:def 2;
  SDDec(M '+' N) = Sum <*w*> by A5,A6,FINSEQ_1:57
    .= SD_Add_Data(m+n,k) by RVSUM_1:103;
  hence thesis;
end;

theorem
  for n st n >= 1 holds for k,x,y st
  k >= 2 & x is_represented_by n,k & y is_represented_by n,k holds
  x + y = (SDDec(DecSD(x,n,k) '+' DecSD(y,n,k))) + (Radix(k) |^ n)*
  SD_Add_Carry(DigA(DecSD(x,n,k),n)+DigA(DecSD(y,n,k),n))
proof
  let n;
  assume
A1: n >= 1;
  defpred P[Nat] means for k,x,y be Nat st
  k >= 2 & x is_represented_by $1,k & y is_represented_by $1,k holds
  x + y = (SDDec(DecSD(x,$1,k) '+' DecSD(y,$1,k)))+(Radix(k) |^ $1)*
  SD_Add_Carry(DigA(DecSD(x,$1,k),$1)+DigA(DecSD(y,$1,k),$1));
A2: P[1]
  proof
    let k,x,y be Nat;
    assume
A3: k >= 2 & x is_represented_by 1,k & y is_represented_by 1,k;
    then
A4: SDDec(DecSD(x,1,k)'+'DecSD(y,1,k)) = SD_Add_Data(x + y,k) by Th28;
A5: SD_Add_Carry(DigA(DecSD(x,1,k),1)+DigA(DecSD(y,1,k),1))
    = SD_Add_Carry(x+y) by A3,Th26;
    SD_Add_Data(x + y,k) + SD_Add_Carry(x+y)*Radix(k) = x + y - 0;
    hence thesis by A4,A5,NEWTON:10;
  end;
A6: for n be Nat st n >= 1 & P[n] holds P[n+1]
  proof
    let n be Nat;
    assume
A7: n >= 1 & P[n];
    then
A8: n in Seg n by FINSEQ_1:5;
A9: n+1 in Seg (n+1) by FINSEQ_1:5;
    let k,x,y be Nat;
    assume
A10: k >= 2 & x is_represented_by (n+1),k & y is_represented_by (n+1),k;
    set x1 = x div (Radix(k) |^ n);
    set xn = x mod (Radix(k) |^ n);
    set y1 = y div (Radix(k) |^ n);
    set yn = y mod (Radix(k) |^ n);
    set z = DecSD(x,(n+1),k) '+' DecSD(y,(n+1),k);
    set zn = DecSD(xn,n,k) '+' DecSD(yn,n,k);
A11: DigA(DecSD(y,(n+1),k),n+1) = y1 by A10,Th27;
A12: Radix(k) > 0 by POWER:39;
    then
A13: x = (x div (Radix(k) |^ n))*(Radix(k) |^ n)
    + (x mod (Radix(k) |^ n)) by NAT_D:2,PREPOWER:13;
    xn < Radix(k) |^ n & yn < Radix(k) |^ n by A12,NAT_D:1,PREPOWER:13;
    then
A14: xn is_represented_by n,k & yn is_represented_by n,k by Def12;
A15: DigitSD(z) = DigitSD(zn)^<*SubDigit(z,n+1,k)*>
    proof
A16:  len DigitSD(z) = n+1 by FINSEQ_1:def 18;
A17:  len DigitSD(zn) = n by FINSEQ_1:def 18;
A18:  len <*SubDigit(z,n+1,k)*> = 1 by FINSEQ_1:56;
      len (DigitSD(zn)^<*SubDigit(z,n+1,k)*>)
      = len DigitSD(zn) + len <*SubDigit(z,n+1,k)*> by FINSEQ_1:35
        .= n+1 by A18,FINSEQ_1:def 18;
      then
A19:  len DigitSD(z) = len (DigitSD(zn)^<*SubDigit(z,n+1,k)*>)
      by FINSEQ_1:def 18;
      for i be Nat st 1 <= i & i <= len DigitSD(z) holds
      (DigitSD(z)).i = ((DigitSD(zn))^<*SubDigit(z,n+1,k)*>).i
      proof
        let i be Nat;
        assume
A20:    1 <= i & i <= len DigitSD(z);
        then
A21:    i <= n+1 by FINSEQ_1:def 18;
        then
A22:    i in Seg (n+1) by A20,FINSEQ_1:3;
        then
A23:    i in dom DigitSD(z) by A16,FINSEQ_1:def 3;
A24:    i -'1 = i - 1 by A20,XREAL_1:235;
        per cases by A22,FINSEQ_2:8;
        suppose
A25:      i in Seg n;
          then
A26:      i in dom DigitSD(zn) by A17,FINSEQ_1:def 3;
          then
A27:      ((DigitSD(zn))^<*SubDigit(z,n+1,k)*>).i
          = DigitSD(zn).i by FINSEQ_1:def 7
            .= (DigitSD(zn))/.i by A26,PARTFUN1:def 8
            .= SubDigit(zn,i,k) by A25,Def6
            .= (Radix(k) |^ (i -'1))
          *Add(DecSD(xn,n,k),DecSD(yn,n,k),i,k) by A25,Def14
            .= (Radix(k) |^ (i -'1)) *(SD_Add_Data(DigA(DecSD(xn,n,k),i)
          + DigA(DecSD(yn,n,k),i),k) + SD_Add_Carry(DigA(DecSD(xn,n,k),i -'1)
          + DigA(DecSD(yn,n,k),i -'1))) by A10,A25,Def13;
A28:      DigitSD(z).i = (DigitSD(z))/.i by A23,PARTFUN1:def 8
            .= SubDigit(z,i,k) by A22,Def6
            .= (Radix(k) |^ (i -'1))
          *Add(DecSD(x,(n+1),k),DecSD(y,(n+1),k),i,k) by A22,Def14
            .= (Radix(k) |^ (i -'1)) *(SD_Add_Data(DigA(DecSD(x,(n+1),k),i)
          + DigA(DecSD(y,(n+1),k),i),k)
          + SD_Add_Carry(DigA(DecSD(x,(n+1),k),i -'1)
          + DigA(DecSD(y,(n+1),k),i -'1))) by A10,A22,Def13;
          now per cases by A20,XXREAL_0:1;
            suppose
A29:          i = 1;
              then
A30:          ((DigitSD(zn))^<*SubDigit(z,n+1,k)*>).i = ( Radix(k) |^ (i -'1))
              *(SD_Add_Data(DigA(DecSD(xn,n,k),i) + DigA(DecSD(yn,n,k),i),k)
              + SD_Add_Carry(DigA(DecSD(xn,n,k),i -'1)
              + DigA(DecSD(yn,n,k),0))) by A27,XREAL_1:234
                .= (Radix(k) |^ (i -'1)) *(SD_Add_Data(DigA(DecSD(xn,n,k),i)
              + DigA(DecSD(yn,n,k),i),k) + SD_Add_Carry(DigA(DecSD(xn,n,k),0)
              + DigA(DecSD(yn,n,k),0))) by A29,XREAL_1:234
                .= (Radix(k) |^ (i -'1)) *(SD_Add_Data(DigA(DecSD(xn,n,k),i)
              + DigA(DecSD(yn,n,k),i),k) + SD_Add_Carry(DigA(DecSD(xn,n,k),0)
              + 0)) by Def3
                .= (Radix(k) |^ (i -'1))
              *(SD_Add_Data(DigA(DecSD(xn,n,k),i)
              + DigA(DecSD(yn,n,k),i),k)+0) by Def3,Th21;
              DigitSD(z).i = (Radix(k) |^ (i -'1))
              *(SD_Add_Data(DigA(DecSD(x,(n+1),k),i)
              + DigA(DecSD(y,(n+1),k),i),k)
              + SD_Add_Carry(DigA(DecSD(x,(n+1),k),i -'1)
              + DigA(DecSD(y,(n+1),k),0))) by A28,A29,XREAL_1:234
                .= (Radix(k) |^ (i -'1))
              *(SD_Add_Data(DigA(DecSD(x,(n+1),k),i)
              + DigA(DecSD(y,(n+1),k),i),k)
              + SD_Add_Carry(DigA(DecSD(x,(n+1),k),0)
              + DigA(DecSD(y,(n+1),k),0))) by A29,XREAL_1:234
                .= (Radix(k) |^ (i -'1))
              *(SD_Add_Data(DigA(DecSD(x,(n+1),k),i)
              + DigA(DecSD(y,(n+1),k),i),k)
              + SD_Add_Carry(DigA(DecSD(x,(n+1),k),0) + 0)) by Def3
                .= (Radix(k) |^ (i -'1))
              *(SD_Add_Data(DigA(DecSD(x,(n+1),k),i)
              + DigA(DecSD(y,(n+1),k),i),k)+0) by Def3,Th21
                .= (Radix(k) |^ (i -'1)) *(SD_Add_Data(DigA(DecSD(xn,n,k),i)
              + DigA(DecSD(y,(n+1),k),i),k)) by A25,Lm3
                .= (Radix(k) |^ (i -'1)) *(SD_Add_Data(DigA(DecSD(xn,n,k),i)
              + DigA(DecSD(yn,n,k),i),k)) by A25,Lm3;
              hence thesis by A30;
            end;
            suppose i > 1;
              then
A31:          i -'1 >= 1 by NAT_D:49;
              i - 1 <= n by A21,XREAL_1:22;
              then
A32:          i -'1 in Seg n by A24,A31,FINSEQ_1:3;
              DigitSD(z).i = (Radix(k) |^ (i -'1))
              *(SD_Add_Data(DigA(DecSD(xn,n,k),i)
              + DigA(DecSD(y,(n+1),k),i),k)
              + SD_Add_Carry(DigA(DecSD(x,(n+1),k),i -'1)
              + DigA(DecSD(y,(n+1),k),i -'1))) by A25,A28,Lm3
                .= (Radix(k) |^ (i -'1)) *(SD_Add_Data(DigA(DecSD(xn,n,k),i)
              + DigA(DecSD(yn,n,k),i),k)
              + SD_Add_Carry(DigA(DecSD(x,(n+1),k),i -'1)
              + DigA(DecSD(y,(n+1),k),i -'1))) by A25,Lm3
                .= (Radix(k) |^ (i -'1)) *(SD_Add_Data(DigA(DecSD(xn,n,k),i)
              + DigA(DecSD(yn,n,k),i),k)
              + SD_Add_Carry(DigA(DecSD(xn,n,k),i -'1)
              + DigA(DecSD(y,(n+1),k),i -'1))) by A32,Lm3
                .= (Radix(k) |^ (i -'1)) *(SD_Add_Data(DigA(DecSD(xn,n,k),i)
              + DigA(DecSD(yn,n,k),i),k)
              + SD_Add_Carry(DigA(DecSD(xn,n,k),i -'1)
              + DigA(DecSD(yn,n,k),i -'1))) by A32,Lm3;
              hence thesis by A27;
            end;
          end;
          hence thesis;
        end;
        suppose
A33:      i = n+1;
          then ((DigitSD(zn))^<*SubDigit(z,n+1,k)*>).i
          = ((DigitSD(zn))^<*SubDigit(z,n+1,k)*>).((len (DigitSD(zn)))+1)
          by FINSEQ_1:def 18
            .= SubDigit(z,n+1,k) by FINSEQ_1:59
            .= (DigitSD(z))/.(n+1) by A9,Def6
            .= DigitSD(z).(n+1) by A23,A33,PARTFUN1:def 8;
          hence thesis by A33;
        end;
      end;
      hence thesis by A19,FINSEQ_1:18;
    end;
    SubDigit(z,n+1,k) = (Radix(k) |^ n)*DigB(z,(n+1)) by NAT_D:34;
    then SDDec(z)
    = (Radix(k) |^ n)*DigB(z,(n+1)) + Sum DigitSD(zn) by A15,RVSUM_1:104
      .= Add(DecSD(x,(n+1),k),DecSD(y,(n+1),k),(n+1),k)*(Radix(k) |^ n)
    + Sum DigitSD(zn) by A9,Def14
      .= (SD_Add_Data(DigA(DecSD(x,(n+1),k),(n+1))
    + DigA(DecSD(y,(n+1),k),(n+1)),k)
    + SD_Add_Carry(DigA(DecSD(x,(n+1),k),(n+1)-'1)
    + DigA(DecSD(y,(n+1),k),(n+1)-'1)))*(Radix(k) |^ n)
    + Sum DigitSD(zn) by A9,A10,Def13
      .= (SD_Add_Data(DigA(DecSD(x,(n+1),k),(n+1))
    + DigA(DecSD(y,(n+1),k),(n+1)),k)
    + SD_Add_Carry(DigA(DecSD(x,(n+1),k),(n+1)-'1)
    + DigA(DecSD(y,(n+1),k),n)))*(Radix(k) |^ n)
    + Sum DigitSD(zn) by NAT_D:34
      .= (SD_Add_Data(DigA(DecSD(x,(n+1),k),(n+1))
    + DigA(DecSD(y,(n+1),k),(n+1)),k) + SD_Add_Carry(DigA(DecSD(x,(n+1),k),n)
    + DigA(DecSD(y,(n+1),k),n)))*(Radix(k) |^ n)
    + Sum DigitSD(zn) by NAT_D:34
      .= (SD_Add_Data(DigA(DecSD(x,(n+1),k),(n+1))
    + DigA(DecSD(y,(n+1),k),(n+1)),k) + SD_Add_Carry(DigA(DecSD(xn,n,k),n)
    + DigA(DecSD(y,(n+1),k),n)))*(Radix(k) |^ n) + Sum DigitSD(zn) by A8,Lm3
      .= (SD_Add_Data(DigA(DecSD(x,(n+1),k),(n+1))
    + DigA(DecSD(y,(n+1),k),(n+1)),k) + SD_Add_Carry(DigA(DecSD(xn,n,k),n)
    + DigA(DecSD(yn,n,k),n)))*(Radix(k) |^ n) + Sum DigitSD(zn) by A8,Lm3
      .= (SD_Add_Data(x1+y1,k)+ SD_Add_Carry(DigA(DecSD(xn,n,k),n)
    + DigA(DecSD(yn,n,k),n)))*(Radix(k) |^ n)
    + Sum DigitSD(zn) by A10,A11,Th27
      .= SD_Add_Data(x1+y1,k)*(Radix(k) |^ n)
    + (SD_Add_Carry(DigA(DecSD(xn,n,k),n)+DigA(DecSD(yn,n,k),n))
    *(Radix(k) |^ n)+(SDDec(DecSD(xn,n,k)'+'DecSD(yn,n,k))))
      .= SD_Add_Data(x1+y1,k)*(Radix(k) |^ n) + (xn + yn) by A7,A10,A14
      .= SD_Add_Data(x1+y1,k)*(Radix(k) |^ n) + xn + yn;
    then SDDec(z) + SD_Add_Carry(x1+y1)*(Radix(k) |^ (n+1))
    = SD_Add_Data(x1+y1,k)*(Radix(k) |^ n)
    + SD_Add_Carry(x1+y1)*(Radix(k) |^ (n+1))+ xn + yn
      .= SD_Add_Data(x1+y1,k)*(Radix(k) |^ n)
    + SD_Add_Carry(x1+y1)*((Radix(k) |^ n)*Radix(k)) + xn + yn by NEWTON:11
      .= (x1*(Radix(k) |^ n) + xn) + (y1*(Radix(k) |^ n) + yn)
      .= x + y by A12,A13,NAT_D:2,PREPOWER:13;
    hence thesis by A10,A11,Th27;
  end;
  for n be Nat st n >= 1 holds P[n] from NAT_1:sch 8(A2,A6);
  hence thesis by A1;
end;

