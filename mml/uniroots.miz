:: Primitive Roots of Unity and Cyclotomic Polynomials
::  by Broderick Arneson and Piotr Rudnicki
::
:: Received December 30, 2003
:: Copyright (c) 2003 Association of Mizar Users

environ

 vocabularies ARYTM_1, ARYTM, SQUARE_1, ARYTM_3, FINSEQ_1, RELAT_1, FUNCT_1,
      RLVECT_1, BOOLE, FINSEQ_2, FINSEQ_4, HAHNBAN1, COMPLEX1, BINOP_1,
      VECTSP_1, NORMSP_1, COMPLFLD, GROUP_1, REALSET1, POWER, POLYNOM1, INT_1,
      INT_2, NAT_1, RAT_1, TARSKI, CARD_1, CARD_3, ALGSEQ_1, POLYNOM3,
      POLYNOM2, FUNCT_4, VECTSP_2, COMPTRIG, ABSVALUE, POLYNOM5, UNIROOTS,
      COMPLSP1, SIN_COS, PREPOWER, FINSET_1, SGRAPH1, MOD_2, GRAPH_2, ANPROJ_1,
      GROUP_2, UPROOTS, XCMPLX_0;
 notations TARSKI, XBOOLE_0, SUBSET_1, REALSET1, NUMBERS, ARYTM_0, XCMPLX_0,
      XREAL_0, ZFMISC_1, XXREAL_0, COMPLEX1, REAL_1, SQUARE_1, INT_1, INT_2,
      NAT_1, NAT_D, PREPOWER, POWER, RLVECT_1, VECTSP_2, BINOP_1, RELAT_1,
      FUNCT_1, PARTFUN1, FUNCT_2, FINSEQ_1, RAT_1, FINSEQ_2, FINSOP_1,
      DOMAIN_1, FINSET_1, STRUCT_0, VECTSP_1, GROUP_4, BINARITH, RVSUM_1,
      ALGSEQ_1, COMPLFLD, HAHNBAN1, POLYNOM3, POLYNOM4, POLYNOM5, COMPTRIG,
      CARD_1, GROUP_2, NEWTON, GROUP_1, MOD_2, GRAPH_2, ORDINAL1, BINOP_2,
      POLYNOM1, FVSUM_1, UPROOTS, SIN_COS;
 constructors WELLORD2, BINOP_1, ARYTM_0, REAL_1, SQUARE_1, NAT_D, FINSEQOP,
      FINSOP_1, RVSUM_1, PREPOWER, POWER, REALSET1, BINARITH, SIN_COS, GROUP_4,
      MOD_2, MATRIX_2, HAHNBAN1, GRAPH_2, POLYNOM4, POLYNOM5, UPROOTS;
 registrations XBOOLE_0, RELAT_1, FUNCT_1, ORDINAL1, FINSET_1, NUMBERS,
      XCMPLX_0, XXREAL_0, XREAL_0, NAT_1, INT_1, BINOP_2, CARD_1, MEMBERED,
      FINSEQ_1, SEQ_1, FINSEQ_2, RVSUM_1, REALSET1, SIN_COS, WSIERP_1,
      STRUCT_0, GROUP_1, VECTSP_1, COMPLFLD, QUOFIELD, POLYNOM1, POLYNOM3,
      POLYNOM5;
 requirements NUMERALS, BOOLE, SUBSET, ARITHM, REAL;
 definitions TARSKI, GROUP_1, XBOOLE_0, BINOP_1, REALSET1, SQUARE_1, HAHNBAN1,
      POLYNOM3, FINSEQ_2, COMPLEX1, GROUP_4, RLVECT_1;
 theorems GROUP_1, CARD_1, FINSEQ_1, ZFMISC_1, NAT_1, FUNCT_1, FUNCT_2,
      RELAT_1, TARSKI, XBOOLE_0, XBOOLE_1, VECTSP_1, PREPOWER, COMPTRIG,
      COMPLFLD, BINOP_1, REAL_1, XCMPLX_1, COMPLEX1, HAHNBAN1, SIN_COS, POWER,
      REAL_2, SIN_COS2, POLYNOM5, BINARITH, INT_1, COMPLEX2, XCMPLX_0, XREAL_0,
      SQUARE_1, RVSUM_1, FVSUM_1, FINSEQ_3, FINSEQ_2, FINSEQ_4, POLYNOM4,
      INT_2, ABSVALUE, WSIERP_1, NAT_2, PEPIN, POLYNOM3, COMPUT_1, NORMSP_1,
      FUNCT_7, ALGSEQ_1, RLVECT_1, NEWTON, POLYNOM2, FINSET_1, CARD_4,
      POLYNOM1, MATRIX_3, VECTSP_2, MOD_2, CARD_2, GRAPH_2, FINSEQ_5, UPROOTS,
      RELSET_1, GROUP_2, BINOP_2, XREAL_1, XXREAL_0, GROUP_4, FUNCOP_1,
      ORDINAL1, FINSOP_1, NAT_D, STRUCT_0, PARTFUN1;
 schemes NAT_1, FUNCT_2, FINSEQ_1, POLYNOM2;

begin :: Preliminaries

theorem Th1:
  for n being Element of NAT holds n = 0 or n = 1 or n >= 2
proof let n be Element of NAT;
A1: 0 < n implies 0+1 <= n by NAT_1:13;
  per cases by A1,REAL_1:def 5;
  suppose n = 0;  hence thesis;
  end;
  suppose n = 1; hence thesis;
  end;
  suppose 1 < n; then 1+1 <= n by NAT_1:13; hence thesis;
end;
end;

Lm1:
for k being Element of NAT holds k is non empty iff 1 <= k
proof let k be Element of NAT;
  hereby assume k is non empty; then 0 < k;
    then 0+1 <= k by NAT_1:13;
   hence 1 <= k;
  end;
  assume 1 <= k;
  hence thesis;
end;

scheme CompIndNE { P[non empty Nat] } :
 for k being non empty Element of NAT holds P[k]
provided
A1: for k being non empty Element of NAT
    st for n being non empty Element of NAT st n < k holds P[n]
     holds P[k]
proof
 defpred R[Nat] means ex m being non empty Element of NAT
 st m = $1 & P[m];
A2: now let k be Nat such that
   A3: k>=1 and
   A4: for n being Nat st n>=1 & n<k holds R[n];
       reconsider m = k as non empty Element of NAT by A3,ORDINAL1:def 13;
            now let n be non empty Element of NAT such that
       A5: n < m;                n >= 1 by Lm1; then R[n] by A4,A5;
        hence P[n];
       end; then P[m] by A1;
    hence R[k];
   end;
A6: for k being Nat st k>=1 holds R[k] from NAT_1:sch 9(A2);
   let k be non empty Element of NAT;
     k >= 1 by Lm1;
    then ex m being non empty Element of NAT st m = k & P[m] by A6;
   hence P[k];
end;

theorem Th2:
for f being FinSequence st 1 <= len f holds f | Seg 1 = <*f.1*>
proof let f be FinSequence such that
A1: 1 <= len f;
   reconsider f1 = f | Seg 1 as FinSequence by FINSEQ_1:19;
        Seg 1 c= Seg len f by A1,FINSEQ_1:7; then Seg 1 c= dom f by
FINSEQ_1:def 3;
   then dom f1 = Seg 1 by RELAT_1:91;
then A2: len f1 = 1 by FINSEQ_1:def 3;
     0+1 in Seg 1 by FINSEQ_1:6; then (f | Seg 1).1 = f.1 by FUNCT_1:72;
  hence f | Seg 1 = <*f.1*> by A2,FINSEQ_1:57;
end;

Lm2:
for f being FinSequence, n, i being Element of NAT
 st i <= n holds (f|Seg n)|Seg i = f|Seg i
proof let f be FinSequence, n, i be Element of NAT; assume i <= n;
  then Seg i c= Seg n by FINSEQ_1:7;
  hence (f|Seg n)|Seg i = f|Seg i by RELAT_1:103;
end;

theorem Th3:
for f being FinSequence of F_Complex, g being FinSequence of REAL
 st len f = len g & for i being Element of NAT st i in dom f
 holds |. f/.i .| = g.i
  holds |. Product f .| = Product g
proof
set FC = F_Complex;
set cFC = the carrier of F_Complex;
let f be FinSequence of F_Complex, g be FinSequence of REAL such that
A1: len f = len g and
A2: for i being Element of NAT st i in dom f holds |. f/.i .| = g.i;
   defpred P[Element of NAT] means
   for f being FinSequence of F_Complex, g being FinSequence of REAL
    st len f = len g & (for i being Element of NAT st i in dom f
    holds |. f/.i .| = g.i) &
       $1 = len f holds |. Product f .| = Product g;
A3: P[0] proof
     let f be FinSequence of F_Complex, g be FinSequence of REAL such that
    A4: len f = len g and
            for i being Element of NAT st i in dom f holds |. f/.i .| = g.i and
    A5: 0 = len f;
    reconsider Pf = Product f as Element of COMPLEX by COMPLFLD:def 1;
             f = <*>(the carrier of F_Complex) by A5,FINSEQ_1:32;
         then Product f = 1r by COMPLFLD:10,GROUP_4:11;
     hence |.Product f.|
       = Product g by A4,A5,COMPLEX1:134,FINSEQ_1:32,RVSUM_1:124;
    end;
A6: for i being Element of NAT st P[i] holds P[i+1]
proof let i being Element of NAT such that
    A7: P[i];
     let f be FinSequence of FC, g be FinSequence of REAL such that
    A8: len f = len g and
    A9: for i being Element of NAT st i in dom f holds |. f/.i .| = g.i and
    A10: i+1 = len f;
       consider f1 being FinSequence of FC, c being Element of cFC such that
    A11: f = f1^<*c*> by A10,FINSEQ_2:22;
       consider g1 being FinSequence of REAL, r being Real such that
    A12: g = g1^<*r*> by A8,A10,FINSEQ_2:22;
A13:    Product f = Product f1 * c by A11,GROUP_4:9;
       reconsider Pf1c = Product f1 * c as Element of COMPLEX
          by COMPLFLD:def 1;
       reconsider Pf1 = Product f1 as Element of COMPLEX by COMPLFLD:def 1;
       reconsider cc = c as Element of COMPLEX by COMPLFLD:def 1;
    A14: Product g = Product g1 * r by A12,RVSUM_1:126;
    A15: len f = len f1 + len <*c*> by A11,FINSEQ_1:35
      .= len f1 + 1 by FINSEQ_1:56;
    A16: len g = len g1 + len <*r*> by A12,FINSEQ_1:35
             .= len g1 + 1 by FINSEQ_1:56;
    then A17: dom f1 = dom g1 by A8,A15,FINSEQ_3:31;
    A18: now let i be Element of NAT; assume
       A19: i in dom f1;  A20: dom f1 c= dom f by A11,FINSEQ_1:39;
       f1/.i = f1.i by A19,PARTFUN1:def 8 .= f.i by A11,A19,FINSEQ_1:def 7
                .= f/.i by A19,A20,PARTFUN1:def 8;
        hence |. f1/.i .| = g.i by A9,A19,A20
           .= g1.i by A12,A17,A19,FINSEQ_1:def 7;
       end;
     f <> {} by A10,FINSEQ_1:25;
    then A21: len f in dom f by FINSEQ_5:6;
    then A22: f/.len f = f.len f by PARTFUN1:def 8 .= c by A11,A15,FINSEQ_1:59;
     g.len f = r by A8,A12,A16,FINSEQ_1:59;
    then A23: |.cc.| = r by A9,A21,A22;
    thus |. Product f .| = |. Pf1 .|*|.cc.| by A13,COMPLEX1:151
       .= Product g by A7,A8,A10,A14,A15,A16,A18,A23;
    end;
     for i being Element of NAT holds P[i] from NAT_1:sch 1(A3,A6);
  hence |. Product f .| = Product g by A1,A2;
end;

theorem Th4:
for s being non empty finite Subset of F_Complex,
    x being Element of F_Complex,
    r being FinSequence of REAL st len r = card s &
 for i being Element of NAT, c being Element of F_Complex
  st i in dom r & c = (canFS(s)).i holds r.i = |.x-c.|
  holds |.eval(poly_with_roots((s,1)-bag),x).| = Product(r)
proof
set FC = F_Complex;
set cFC = the carrier of F_Complex;
let s be non empty finite Subset of FC, x being Element of FC,
          r being FinSequence of REAL such that
A1: len r = card s and
A2: for i being Element of NAT, c being Element of FC
    st i in dom r & c = (canFS(s)).i holds r.i = |.x-c.|;
        len canFS(s) = card s by UPROOTS:def 1;
then A3: dom canFS(s) = Seg card s by FINSEQ_1:def 3;
A4: dom r = Seg card s by A1,FINSEQ_1:def 3;
   defpred P[set,set] means
   ex c being Element of FC st
    c = (canFS(s)).$1 & $2 = eval(<% -c, 1_F_Complex %>,x);
A5: for k being Element of NAT st k in Seg card s
ex y being Element of FC st P[k,y]
    proof let k be Element of NAT such that
    A6: k in Seg card s;        set c = (canFS(s)).k;
             c in s by A3,A6,FINSEQ_2:13; then reconsider c as Element of FC;
        reconsider fi = eval(<% -c, 1_F_Complex %>,x) as Element of FC;
     take fi, c;     thus thesis;
    end;
   consider f being FinSequence of FC such that
A7: dom f = Seg card s and
A8: for k being Element of NAT st k in Seg card s holds P[k,f/.k]
from POLYNOM2:sch 1(A5)
;
A9: now let i being Element of NAT, c be Element of FC such that
   A10: i in dom f and
   A11: c = (canFS(s)).i;
       consider c1 being Element of FC such that
   A12: c1 = (canFS(s)).i and
   A13: f/.i = eval(<% -c1, 1_F_Complex %>,x) by A7,A8,A10;
     thus f.i = eval(<% -c, 1_F_Complex %>,x) by A10,A11,A12,A13,PARTFUN1:def 8
;
   end;
A14: len f = len r by A1,A7,FINSEQ_1:def 3;
then A15: eval(poly_with_roots((s,1)-bag),x) = Product(f)
      by A1,A9,UPROOTS:69;
        for i being Element of NAT st i in dom f holds |. f/.i .| = r.i proof
    let i be Element of NAT; assume
   A16: i in dom f;
       set c = (canFS(s)).i;       c in s by A3,A7,A16,FINSEQ_2:13;
       then reconsider c = (canFS(s)).i as Element of FC;
   A17: f.i = eval(<% -c, 1_F_Complex %>,x) by A9,A16;
       reconsider xc = x, cc = c as Element of COMPLEX by COMPLFLD:def 1;
            f/.i = f.i by A16,PARTFUN1:def 8
    .= -c + x by A17,POLYNOM5:48     .= x-c;
     hence |. f/.i .| = r.i by A2,A4,A7,A16;
   end;
  hence |.eval(poly_with_roots((s,1)-bag),x).| = Product(r) by A14,A15,Th3;
end;

theorem Th5:
for f being FinSequence of F_Complex
 st for i being Element of NAT st i in dom f holds f.i is integer
  holds Sum f is integer
proof set FC = F_Complex; let f be FinSequence of FC; assume
A1: for i being Element of NAT st i in dom f holds f.i is integer;
   defpred P[Element of NAT] means
   for f being FinSequence of FC
    st len f = $1 & for i being Element of NAT st i in dom f
    holds f.i is integer
     holds Sum f is integer;
A2: P[0] proof let f be FinSequence of FC; assume len f = 0;
       then f = <*>(the carrier of F_Complex) by FINSEQ_1:32;
    hence thesis by COMPLFLD:9,RLVECT_1:60;
   end;
A3: for n being Element of NAT st P[n] holds P[n+1]
 proof let n be Element of NAT such that
  A4: P[n];
      let f being FinSequence of FC; assume that
  A5: len f = n+1 and
  A6: for i being Element of NAT st i in dom f holds f.i is integer;
      consider g being FinSequence of FC, c being Element of FC such that
  A7: f = g^<*c*> by A5,FINSEQ_2:22;
          A8: len f = len g + len <*c*> by A7,FINSEQ_1:35
      .= len g +1 by FINSEQ_1:57;
  A9: now let i be Element of NAT; assume
      A10: i in dom g; A11: dom g c= dom f by A7,FINSEQ_1:39;
               f.i = g.i by A7,A10,FINSEQ_1:def 7;
       hence g.i is integer by A6,A10,A11;
      end;
      reconsider Sgc = Sum g, cc = c as Element of COMPLEX by COMPLFLD:def 1;
0+1 <= len f by A5,NAT_1:13;
      then len f in dom f by FINSEQ_3:27;
  then f.(len f) is integer by A6;
      then reconsider Sgi = Sgc, ci = cc as Integer by A4,A5,A7,A8,A9,
FINSEQ_1:59;
           Sum f = Sum g + Sum <*c*> by A7,RLVECT_1:58
      .= Sgi + ci by RLVECT_1:61;
     hence Sum f is integer;
    end;
A12: for n being Element of NAT holds P[n] from NAT_1:sch 1(A2,A3);
        len f is Element of NAT;
  hence Sum f is integer by A1,A12;
end;

canceled;

theorem
 for x, y being Element of F_Complex, r1, r2 being Real
 st r1=x & r2=y holds r1*r2 = x*y & r1+r2=x+y;

theorem Th8:
for q being Real st q is Integer & q > 0
for r being Element of F_Complex
 st |.r.| = 1 & r <> [**1,0**] holds |.[**q, 0**] - r.| > q - 1
proof let q be Real such that
A1: q is Integer & q > 0;
    let r be Element of F_Complex such that
A2: |.r.| = 1 and A3: r <> [**1,0**];
    set a = Re r; set b = Im r;
A4: a^2 + b^2 = 1 by A2,COMPTRIG:7,SQUARE_1:59;
         now assume A5: a = 1;
        then b = 0 by A4,XCMPLX_1:6;
      hence contradiction by A3,A5,COMPLEX1:29;
    end; then a <> 1 & a <= 1 by A2,COMPLEX1:140;
then A6: a < 1 by REAL_1:def 5;
A7: Re[**q-a,-b**] = q-a & Im[**q-a,-b**] = -b by COMPLEX1:28;
         2*q > 0 by A1,REAL_2:122; then 2*q > 2*q*a by A6,REAL_2:145;
    then -2*q*a > -2*q by XREAL_1:26; then -2*q + q^2 < -2*q*a + q^2
by XREAL_1:10;
then A8: q^2 - 2*q*a + 1 > q^2 - 2*q + 1 by XREAL_1:10;
    reconsider qc = [**q, 0**] as Element of F_Complex;
A9: |.qc - r.| >= 0 by COMPLEX1:132;
        (|.qc - r.|)^2 = |.[**q, 0**] - [**a, b**].|^2 by COMPLEX1:29
    .= |.[**q - a, 0-b**].|^2 by POLYNOM5:6
    .= (q-a)^2 + b^2 by A7,COMPTRIG:7
    .= q^2 - 2*q*a + 1 by A4;
     then (|.qc - r.|)^2 > (q - 1)^2 by A8;
  hence thesis by A9,SQUARE_1:118;
end;

theorem Th9:
for ps being non empty FinSequence of REAL, x being Real
 st x >= 1 & for i being Element of NAT st i in dom ps holds ps.i > x
  holds Product(ps) > x
proof let ps be non empty FinSequence of REAL, x be Real such that
A1: x >= 1 & for j being Element of NAT st j in dom ps holds ps.j > x;
A2: len ps <> 0 by FINSEQ_1:25;
    consider ps1 being FinSequence, y being set such that
A3: ps = ps1^<*y*> by FINSEQ_1:63;
         len ps = len ps1 + len <*y*> by A3,FINSEQ_1:35;
then A4: len ps = len ps1 + 1 by FINSEQ_1:56;
         <*y*> is FinSequence of REAL by A3,FINSEQ_1:50;
    then rng <*y*> c= REAL by FINSEQ_1:def 4; then {y} c= REAL by FINSEQ_1:55
;
    then reconsider y2=y as Real by ZFMISC_1:37;
A5: ps.(len ps) = y2 by A3,A4,FINSEQ_1:59;
         len ps in Seg len ps by A2,FINSEQ_1:5;
    then A6: len ps in dom ps by FINSEQ_1:def 3;
    reconsider q=ps1 as FinSequence of REAL by A3,FINSEQ_1:50;
A7: for j being Element of NAT st j in dom q holds q.j > x
    proof let j be Element of NAT such that A8: j in dom q;
    A9: dom q c= dom ps by A3,FINSEQ_1:39;       ps.j = q.j by A3,A8,
FINSEQ_1:def 7;
      hence thesis by A1,A8,A9;
    end;
    defpred P[Element of NAT] means
     for f being FinSequence of REAL st len f = $1 &
      for j being Element of NAT st j in dom f holds f.j > x
      holds Product(f)*y2 > x;
A10: P[0] proof let f be FinSequence of REAL such that A11: len f = 0 and
             for j being Element of NAT st j in dom f holds f.j > x;
             Product f = 1 by A11,FINSEQ_1:32,RVSUM_1:124;
      hence thesis by A1,A5,A6;
    end;
A12: for k being Element of NAT st P[k] holds P[k+1]
    proof let k be Element of NAT such that
    A13: P[k];
        let f be FinSequence of REAL such that
    A14: len f = k+1 and A15: for j being Element of NAT st j in dom f
    holds f.j > x;
             f <> {} by A14,FINSEQ_1:25;
        then consider v being FinSequence, w being set such that
    A16: f=v^<*w*> by FINSEQ_1:63;
        reconsider f1=v, f2=<*w*> as FinSequence of REAL by A16,FINSEQ_1:50;
             k + 1 = len f1 + len f2 by A14,A16,FINSEQ_1:35;
        then A17: k + 1 = len f1 + 1 by FINSEQ_1:56;
             for j being Element of NAT st j in dom f1 holds f1.j > x
        proof let j be Element of NAT such that A18: j in dom f1;
        A19: dom f1 c= dom f by A16,FINSEQ_1:39;
                f.j = f1.j by A16,A18,FINSEQ_1:def 7;
          hence thesis by A15,A18,A19;
        end;
    then A20: Product f1*y2 > x by A13,A17;
             rng f2 c= REAL; then {w} c= REAL by FINSEQ_1:55;
        then reconsider m=w as Real by ZFMISC_1:37;
    A21: f.(len f) = m by A14,A16,A17,FINSEQ_1:59;
             len f in Seg len f by A14,FINSEQ_1:5;
    then len f in dom f by FINSEQ_1:def 3;
    then A22: m > x by A15,A21;
   then m > 1 by A1,XXREAL_0:2;
   then A23: x*m > x by A1,REAL_2:144;
             Product f = Product f1 * m by A16,RVSUM_1:126;
        then Product f*y2 = (Product f1 * y2) * m;
        then Product f*y2 > x*m by A1,A20,A22,XREAL_1:70;
      hence thesis by A23,XXREAL_0:2;
    end;
A24: for k being Element of NAT holds P[k] from NAT_1:sch 1(A10,A12);
        len q = len q; then Product(q)*y2 > x by A7,A24;
  hence thesis by A3,RVSUM_1:126;
end;

theorem Th10:
for n being Element of NAT
holds 1_F_Complex = (power F_Complex).(1_F_Complex,n)
proof let n be Element of NAT;
 1_F_Complex = [** 1, 0 **] by COMPLFLD:10;
   then (power F_Complex).(1_F_Complex,n) = [** 1 to_power n,0 **] by
HAHNBAN1:37
.= 1_F_Complex by COMPLFLD:10,POWER:31;
  hence thesis;
end;

theorem Th11:
for n, i being Element of NAT holds
  cos((2*PI*i)/n) = cos((2*PI*(i mod n))/n) &
  sin((2*PI*i)/n) = sin((2*PI*(i mod n))/n)
proof let n, i be Element of NAT;
    set j = i div n;
    per cases;
    suppose A1:n <> 0;
    then n > 0;
    then i = n*j + (i mod n) by NAT_D:2;
then A2:  (2*PI*i)/n = (2*PI*(n*j) + 2*PI*(i mod n))/n
              .= (2*PI*(n*j))/(n*1) + (2*PI*(i mod n))/n by XCMPLX_1:63
              .= (2*PI)/n*(n*j)/1 + (2*PI*(i mod n))/n by XCMPLX_1:84
              .= (2*PI)*(1/n)*(n*j) + (2*PI*(i mod n))/n by XCMPLX_1:100
              .= (2*PI)*((1/n)*(j*n)) + (2*PI*(i mod n))/n
              .= (2*PI)*(j*1) + (2*PI*(i mod n))/n by A1,XCMPLX_1:91
              .= 2*PI*j + (2*PI*(i mod n))/n;
then A3:  cos((2*PI*i)/n)
    = (cos(2*PI*j + 0)) * (cos((2*PI*(i mod n))/n)) -
       (sin(2*PI*j + 0)) * (sin((2*PI*(i mod n))/n)) by SIN_COS:80
    .= (cos.(2*PI*j + 0)) * (cos((2*PI*(i mod n))/n)) -
       (sin(2*PI*j + 0)) * (sin((2*PI*(i mod n))/n)) by SIN_COS:def 23
    .= (cos.(2*PI*j + 0)) * (cos((2*PI*(i mod n))/n)) -
       (sin.(2*PI*j + 0)) * (sin((2*PI*(i mod n))/n)) by SIN_COS:def 21
    .= (cos.0) * (cos((2*PI*(i mod n))/n)) -
       (sin.(2*PI*j + 0)) * (sin((2*PI*(i mod n))/n)) by SIN_COS2:11
    .= (cos.0) * (cos((2*PI*(i mod n))/n)) -
       (sin.0) * (sin((2*PI*(i mod n))/n)) by SIN_COS2:10
    .= cos((2*PI*(i mod n))/n) by SIN_COS:33;
      sin((2*PI*i)/n)
    = (sin(2*PI*j + 0)) * (cos((2*PI*(i mod n))/n)) +
       (cos(2*PI*j + 0)) * (sin((2*PI*(i mod n))/n)) by A2,SIN_COS:80
    .= (sin.(2*PI*j + 0)) * (cos((2*PI*(i mod n))/n)) +
       (cos(2*PI*j + 0)) * (sin((2*PI*(i mod n))/n)) by SIN_COS:def 21
    .= (sin.(2*PI*j + 0)) * (cos((2*PI*(i mod n))/n)) +
       (cos.(2*PI*j + 0)) * (sin((2*PI*(i mod n))/n)) by SIN_COS:def 23
    .= (sin.0) * (cos((2*PI*(i mod n))/n)) +
       (cos.(2*PI*j + 0)) * (sin((2*PI*(i mod n))/n)) by SIN_COS2:10
    .= (sin.0) * (cos((2*PI*(i mod n))/n)) +
       (cos.0) * (sin((2*PI*(i mod n))/n)) by SIN_COS2:11
    .= sin((2*PI*(i mod n))/n) by SIN_COS:33;
      hence thesis by A3;
    end;
    suppose n = 0;
      then (2*PI*i)/n = 0 & (2*PI*(i mod n))/n = 0 by XCMPLX_1:49;
      hence thesis;
    end;
end;

theorem Th12:
for n, i being Element of NAT holds
   [** cos((2*PI*i)/n), sin((2*PI*i)/n)**] =
   [** cos((2*PI*(i mod n))/n), sin((2*PI*(i mod n))/n) **]
proof let n, i be Element of NAT;
       [** cos((2*PI*i)/n), sin((2*PI*i)/n)**]
    = [** cos((2*PI*(i mod n))/n), sin((2*PI*i)/n)**] by Th11
   .= [** cos((2*PI*(i mod n))/n), sin((2*PI*(i mod n))/n) **] by Th11;
  hence thesis;
end;

theorem Th13:
for n, i, j being Element of NAT holds
[** cos((2*PI*i)/n),sin((2*PI*i)/n) **]*[** cos((2*PI*j)/n),sin((2*PI*j)/n) **]
 = [** cos((2*PI*((i+j) mod n))/n), sin((2*PI*((i+j)mod n))/n)**]
proof let n, i, j be Element of NAT;
A1:  (2*PI*i)/n + (2*PI*j)/n = (2*PI*i + 2*PI*j)/n by XCMPLX_1:63
    .= (2*PI*(i+j))/n;
then A2:  cos((2*PI*i)/n) * cos((2*PI*j)/n) - sin((2*PI*i)/n) * sin((2*PI*j)/n)
     = cos((2*PI*(i+j))/n) by SIN_COS:80;
      cos((2*PI*i)/n) * sin((2*PI*j)/n) + cos((2*PI*j)/n) * sin((2*PI*i)/n)
     = sin((2*PI*(i+j))/n) by A1,SIN_COS:80;
    then [** cos((2*PI*i)/n), sin((2*PI*i)/n) **] *
    [** cos((2*PI*j)/n), sin((2*PI*j)/n) **]
     = [** cos((2*PI*(i+j))/n), sin((2*PI*(i+j))/n) **] by A2
    .= [** cos((2*PI*((i+j) mod n))/n), sin((2*PI*((i+j) mod n))/n)**] by Th12;
  hence thesis;
end;

theorem Th14:
for L being unital associative (non empty HGrStr),
    x being Element of L, n,m being Element of NAT
 holds (power L).(x,n*m) = (power L).((power L).(x,n),m)
proof let L be unital associative (non empty HGrStr),
          x be Element of L, n be Element of NAT;
  defpred P[Element of NAT] means
   (power L).(x,n*$1) = (power L).((power L).(x,n),$1);
  set pL = power L;
       pL.(x,n*0) = 1_L by GROUP_1:def 8 .= pL.(pL.(x,n),0) by GROUP_1:def 8;
then A1: P[0];
A2: for m being Element of NAT st P[m] holds P[m+1]
proof let m be Element of NAT such that
    A3: P[m];
     thus pL.(x,n*(m+1)) = pL.(x,n*m+n*1)
     .= pL.(x,n*m)*pL.(x,n) by POLYNOM2:2
     .= pL.(pL.(x,n),m+1) by A3,GROUP_1:def 8;
    end;
 thus for m being Element of NAT holds P[m] from NAT_1:sch 1(A1,A2);
end;

theorem Th15:
for n being Element of NAT, x being Element of F_Complex st x is Integer
  holds (power F_Complex).(x,n) is Integer
proof let n be Element of NAT, x be Element of F_Complex such that
A1: x is Integer;
    defpred P[Element of NAT] means (power F_Complex).(x,$1) is Integer;
A2: P[0] by COMPLFLD:10,GROUP_1:def 8;
A3: now let k be Element of NAT such that
    A4: P[k];
        reconsider i1=x as Integer by A1;
        reconsider i2=(power F_Complex).(x,k) as Integer by A4;
         (power F_Complex).(x,k)*x = i1*i2;
      hence P[k+1] by GROUP_1:def 8;
    end;
         for k being Element of NAT holds P[k] from NAT_1:sch 1(A2,A3);
  hence thesis;
end;

theorem Th16:
for F being FinSequence of F_Complex
 st for i being Element of NAT st i in dom F holds F.i is Integer
  holds Sum F is Integer
proof let G be FinSequence of F_Complex such that
A1: for i being Element of NAT st i in dom G holds G.i is Integer;
    defpred P[Element of NAT] means
    for F being FinSequence of F_Complex st
      len F = $1 & for i being Element of NAT st i in dom F
      holds F.i is Integer
         holds Sum F is Integer;
A2: P[0] proof let F be FinSequence of F_Complex such that
    A3: len F = 0 & for i being Element of NAT st i in dom F
    holds F.i is Integer;
             0-tuples_on the carrier of F_Complex = {{}} & F = {}
          by A3,COMPUT_1:8,FINSEQ_1:25;
        then F is Element of 0-tuples_on the carrier of F_Complex by
TARSKI:def 1;
      hence thesis by COMPLFLD:9,FVSUM_1:93;
    end;
A4: for k being Element of NAT st P[k] holds P[k+1]
proof let k be Element of NAT such that
    A5: P[k];
        let F be FinSequence of F_Complex such that
    A6: len F = k+1 & for i being Element of NAT st i in dom F
    holds F.i is Integer;
      F <> {} by A6,FINSEQ_1:25;
        then consider G being FinSequence, x being set such that
    A7: F = G^<*x*> by FINSEQ_1:63;
        reconsider f1=G as FinSequence of F_Complex by A7,FINSEQ_1:50;
        reconsider f2=<*x*> as FinSequence of F_Complex by A7,FINSEQ_1:50;
             k + 1 = len f1 + len f2 by A6,A7,FINSEQ_1:35;
        then A8: k + 1 = len f1 + 1 by FINSEQ_1:56;
    A9: for j being Element of NAT st j in dom f1 holds f1.j is Integer
        proof let j be Element of NAT such that A10: j in dom f1;
        A11: dom f1 c= dom F by A7,FINSEQ_1:39;
                 F.j = f1.j by A7,A10,FINSEQ_1:def 7;
          hence thesis by A6,A10,A11;
        end;
             rng f2 c= the carrier of F_Complex by FINSEQ_1:def 4;
        then {x} c= the carrier of F_Complex by FINSEQ_1:55;
        then reconsider m=x as Element of F_Complex by ZFMISC_1:37;
    A12: F.(len F) = m by A6,A7,A8,FINSEQ_1:59;
             len F in Seg len F by A6,FINSEQ_1:5;
        then len F in dom F by FINSEQ_1:def 3;
        then reconsider i2 = m as Integer by A6,A12;
        reconsider i1 = Sum f1 as Integer by A5,A8,A9;
             Sum F = Sum f1 + m by A7,FVSUM_1:87; then Sum F = i1 + i2;
     hence thesis;
    end;
A13: for k being Element of NAT holds P[k] from NAT_1:sch 1(A2,A4);
         len G = len G;
  hence thesis by A1,A13;
end;

Lm3: Z3 is finite by MOD_2:def 23,STRUCT_0:def 11;

registration
  cluster finite Field;
  existence by Lm3,MOD_2:37;
  cluster finite Skew-Field;
  existence by Lm3,MOD_2:37;
end;

begin :: Multiplicative group of a skew field

definition
  let R be Skew-Field;
  func MultGroup R -> strict Group means  :Def1:
    the carrier of it = (the carrier of R) \ {0.R} &
    the mult of it = (the mult of R)||the carrier of it;
  existence proof
   set cR = the carrier of R; set ccs = (the carrier of R) \ {0.R};
        0.R <> 1_R by VECTSP_1:def 21; then A1: not 1_R in {0.R} by
TARSKI:def 1;
   then reconsider ccs as non empty set by XBOOLE_0:def 4;
   set mcs = (the mult of R)||ccs;
     [:ccs,ccs:] c= [:cR,cR:] proof let x be set; assume x in [:ccs,ccs:];
     then consider a,b being set such that
   A2: a in ccs & b in ccs and
   A3: x =[a,b] by ZFMISC_1:def 2;
      thus x in [:cR,cR:] by A2,A3,ZFMISC_1:def 2;
   end;
   then reconsider mcs as Function of [:ccs,ccs:],cR by FUNCT_2:38;
        rng mcs c= ccs proof let y be set; assume y in rng mcs;
    then consider x being set such that
   A4: x in dom mcs and
   A5: y = mcs.x by FUNCT_1:def 5;
   A6: dom mcs = [:ccs,ccs:] by FUNCT_2:def 1;
       then consider a,b being set such that
   A7: a in ccs & b in ccs and
   A8: x = [a,b] by A4,ZFMISC_1:def 2;
   reconsider a,b as Element of cR by A7;
            not a in {0.R} & not b in {0.R} by A7,XBOOLE_0:def 4;
       then a <> 0.R & b <> 0.R by TARSKI:def 1;
       then a*b <> 0.R by VECTSP_2:47; then A9: not a*b in {0.R} by
TARSKI:def 1;
            mcs.x = a*b by A4,A6,A8,FUNCT_1:72;
    hence y in ccs by A5,A9,XBOOLE_0:def 4;
   end;
   then reconsider mcs as BinOp of ccs by FUNCT_2:8;
   reconsider cs = HGrStr (# ccs, mcs #) as non empty HGrStr;
   set ccs1 = the carrier of cs;
A10: now let a,b be Element of cR, c,d be Element of ccs1 such that
   A11: a=c & b=d;
    [c,d] in [:ccs,ccs:] by ZFMISC_1:def 2;
    hence a*b= c*d by A11,FUNCT_1:72;
   end;
A12: cs is associative proof let x,y,z be Element of ccs1;
        x in ccs1 & y in ccs1 & z in ccs1;
    then reconsider x'=x,y'=y,z'=z as Element of cR;
    A13: x'*y'=x*y by A10;   A14: y'*z'=y*z by A10;
    thus (x*y)*z = (x'*y')*z' by A10,A13 .= x'*(y'*z') by GROUP_1:def 4
      .= x*(y*z) by A10,A14;
   end;
      cs is Group-like proof
      reconsider e = 1_R as Element of ccs1 by A1,XBOOLE_0:def 4;
      take e; let h be Element of ccs1;
       h in ccs; then reconsider h'=h as Scalar of R;
      thus h * e = h'*(1_R) by A10 .= h by VECTSP_1:def 13;
      thus e * h = (1_R)*h' by A10 .= h by VECTSP_1:def 19;
           not h in {0.R} by XBOOLE_0:def 4;
      then A15: h <> 0.R by TARSKI:def 1; then h'" <> 0.R by VECTSP_2:48;
      then not h'" in {0.R} by TARSKI:def 1;
      then reconsider g=h'" as Element of ccs1 by XBOOLE_0:def 4;
      take g;
      thus h * g = h'*h'" by A10 .= e by A15,VECTSP_2:43;
      thus g * h = h'"*h' by A10 .= e by A15,VECTSP_2:43;
   end;
   hence thesis by A12;
  end;
  uniqueness;
end;

canceled;

theorem :: WEDDWITT
     for R being Skew-Field
 holds the carrier of R = (the carrier of MultGroup R) \/ {0.R}
proof let R being Skew-Field;
   (the carrier of R)\{0.R} = the carrier of MultGroup R by Def1;
  hence the carrier of R = (the carrier of MultGroup R) \/ {0.R}
  by XBOOLE_1:45;
end;

theorem Th19:
for R being Skew-Field,
    a, b being Element of R, c, d being Element of MultGroup R
 st a = c & b = d holds c*d = a*b
proof let R be Skew-Field, a, b be Element of R,
         c,d be Element of MultGroup R such that
A1: a = c and
A2: b = d;
   set cMGR = the carrier of MultGroup R;
A3: [c,d] in [:cMGR,cMGR:] by ZFMISC_1:def 2;
  thus c*d = ((the mult of R)||cMGR).(c,d) by Def1
  .= a*b by A1,A2,A3,FUNCT_1:72;
end;

theorem Th20:
for R being Skew-Field holds 1_R = 1_MultGroup R
proof let R be Skew-Field;
A1: the carrier of MultGroup R = (the carrier of R) \ {0.R} by Def1;
        0.R <> 1_R by VECTSP_1:def 21;
   then not 1_R in {0.R} by TARSKI:def 1;
  then reconsider uR = 1_R as Element of MultGroup R by A1,XBOOLE_0:def 4;
       now let h be Element of MultGroup R;
    reconsider g = h as Element of R by A1,XBOOLE_0:def 4;
         g * 1_R = g by VECTSP_1:def 13;
   hence h * uR = h by Th19;
         1_R * g = g by VECTSP_1:def 19;
   hence uR * h = h by Th19;
  end;
 hence 1_R = 1_MultGroup R by GROUP_1:def 5;
end;

registration let R be finite Skew-Field;
  cluster MultGroup R -> finite;
  correctness proof
           the carrier of MultGroup R = (the carrier of R) \ {0.R} by Def1;
    hence thesis by STRUCT_0:def 11;
  end;
end;

theorem :: WEDDWITT
     for R being finite Skew-Field
  holds ord MultGroup R = card (the carrier of R) - 1
proof let R be finite Skew-Field;   set G = MultGroup R;
         the carrier of G = (the carrier of R) \ {0.R} by Def1;
    then card the carrier of G = card (the carrier of R) - card {0.R}
       by CARD_2:63;
    then card the carrier of G = card (the carrier of R) - 1 by CARD_1:79;
  hence thesis by GROUP_1:def 15;
end;

theorem Th22:
for R being Skew-Field, s being set
  st s in the carrier of MultGroup R holds s in the carrier of R
proof let R be Skew-Field, s be set; assume
         s in the carrier of MultGroup R;
    then s in (the carrier of R) \ {0.R} by Def1;
  hence thesis;
end;

theorem
   for R being Skew-Field holds the carrier of MultGroup R c= the carrier of R
proof let R be Skew-Field, s be set; assume s in the carrier of MultGroup R;
    then s in (the carrier of R) \ {0.R} by Def1;
  hence thesis;
end;

begin :: Roots of 1

definition let n be non empty Element of NAT;
  func n-roots_of_1 -> Subset of F_Complex equals
        { x where x is Element of F_Complex : x is CRoot of n,1_F_Complex };
  coherence proof
 set H = { x where x is Element of F_Complex : x is CRoot of n,1_F_Complex };
           for x being set st x in H holds x in the carrier of F_Complex
      proof let x be set such that A1: x in H;
               ex y being Element of F_Complex st
          y=x & y is CRoot of n,1_F_Complex by A1;
        hence thesis;
      end;
    hence thesis by TARSKI:def 3;
  end;
end;

theorem Th24:
for n being non empty Element of NAT, x being Element of  F_Complex
  holds x in n-roots_of_1 iff x is CRoot of n,1_F_Complex
proof let n be non empty Element of NAT, x be Element of F_Complex;
    hereby assume x in n-roots_of_1;
        then consider y being Element of F_Complex such that
    A1:  y=x and A2: y is CRoot of n,1_F_Complex;
      thus x is CRoot of n,1_F_Complex by A1,A2;
    end;
  thus thesis;
end;

theorem Th25:
for n being non empty Element of NAT holds 1_F_Complex in n-roots_of_1
proof let n be non empty Element of NAT;
         1_F_Complex = (power F_Complex).(1_F_Complex,n) by Th10;
    then 1_F_Complex is CRoot of n,1_F_Complex by COMPLFLD:def 2;
  hence thesis;
end;

theorem Th26:
for n being non empty Element of NAT, x being Element of F_Complex
 st x in n-roots_of_1 holds |.x.| = 1
proof let n be non empty Element of NAT, x be Element of F_Complex such that
A1:  x in n-roots_of_1;
    reconsider z = 1_F_Complex as Element of F_Complex;
A2:  now assume x = 0.F_Complex;
then (power F_Complex).(x,n) <> 1_F_Complex
              by COMPLFLD:9,10,VECTSP_1:95;
       then not x is CRoot of n, 1_F_Complex by COMPLFLD:def 2;
     hence contradiction by A1,Th24;
    end;
         x is CRoot of n,(1_F_Complex) by A1,Th24;
    then (power F_Complex).(x,n) = 1_F_Complex by COMPLFLD:def 2;
then A3:  1 = |.x.| to_power n by A2,COMPLFLD:97,POLYNOM5:8;
A4: |.x.| > 0 by A2,COMPLFLD:96;
   assume
A5: |.x.| <> 1;
   per cases by A5,REAL_1:def 5;
   suppose A6: |.x.| < 1;     reconsider n' = n as Rational;
        |.x.| #Q n' < 1 by A4,A6,PREPOWER:76;
       then |.x.| |^ n < 1 by A4,PREPOWER:60;
    hence contradiction by A3,A4,POWER:46;
   end;
   suppose |.x.| > 1;
    hence contradiction by A3,POWER:40;
end;
end;

theorem Th27:
for n being non empty Element of NAT for x being Element of F_Complex
 holds x in n-roots_of_1
  iff ex k being Element of NAT st x = [** cos((2*PI*k)/n), sin((2*PI*k)/n) **]
proof let n be non empty Element of NAT, x be Element of F_Complex;
    reconsider z = 1_F_Complex as Element of F_Complex;
    hereby assume A1: x in n-roots_of_1;
     A2:  now assume x = 0.F_Complex;
            then (power F_Complex).(x,n) <> 1_F_Complex
               by COMPLFLD:9,10,VECTSP_1:95;
            then not x is CRoot of n, 1_F_Complex by COMPLFLD:def 2;
           hence contradiction by A1,Th24;
         end;
     then A3: x = |.x.|*cos (Arg x) + |.x.|*sin (Arg x) * <i> &
        0 <= Arg x & Arg x < 2*PI by COMPLFLD:9,COMPTRIG:def 1;
     A4: x = [**|.x.|*cos (Arg x),|.x.|*sin (Arg x)**] by A2,COMPLFLD:9
,COMPTRIG:def 1;
         x is CRoot of n,(1_F_Complex) by A1,Th24;
        then (power F_Complex).(x,n) = 1_F_Complex by COMPLFLD:def 2;
     then A5: 1 = |.x.| to_power n by A2,COMPLFLD:97,POLYNOM5:8;
         A6: now assume A7: |.x.| <> 1;
        A8: |.x.| > 0 by A2,COMPLFLD:96;
         per cases by A7,REAL_1:def 5;
         suppose A9: |.x.| < 1;
           reconsider n' = n as Rational;
            |.x.| #Q n' < 1 by A8,A9,PREPOWER:76;
           then |.x.| |^ n < 1 by A8,PREPOWER:60;
          hence contradiction by A5,A8,POWER:46;
         end;
         suppose |.x.| > 1;
          hence contradiction by A5,POWER:40;
         end;
         end;
        reconsider z = x as Element of COMPLEX by XCMPLX_0:def 2;
         n >= 0+1 by NAT_1:13;
        then A10:      |.z.| to_power n = |.z.| |^ n by POWER:47;
A11:      z|^n = (|.z.| |^ n)*cos (n*Arg z)+(|.z.| |^ n)*sin (n*Arg z)*<i>
               by COMPTRIG:72;
             x is CRoot of n,(1_F_Complex) by A1,Th24;
        then (power F_Complex).(x,n) = [** 1, 0 **] by COMPLFLD:10,def 2;
        then A12: z |^n = [** 1, 0 **] by COMPLFLD:112;
     then A13: cos(n*Arg x) = 1 & sin(n*Arg x) = 0 by A5,A10,A11,COMPLEX1:163;
        set d = (n*Arg x)*(1/(2*PI));        set m = [\d/];
        consider r being real number such that
     A14: r = (2*PI) * (-[\ ((n*Arg x)/(2*PI)) /]) + (n*Arg x) &
        0 <= r & r < (2*PI) by COMPLEX2:2,COMPTRIG:21;
        set a = ((2*PI) * [\ ((n*Arg x)/(2*PI)) /]);
         0 <= n*Arg x by A3,REAL_2:121;
     then A15: 0 <= (n*Arg x)/(2*PI) by COMPTRIG:21,REAL_2:125;
        set m2 = [\ ((n*Arg x)/(2*PI))/];
           A16: 0+-1 <= (n*Arg x)/(2*PI) +-1 by A15,XREAL_1:9;
             (n*Arg x)/(2*PI)-1 < m2 by INT_1:def 4;
        then not m2 <= -1 by A16,XXREAL_0:2;
        then -1+1 <= m2 by INT_1:20;
        then reconsider m = [\ ((n*Arg x)/(2*PI)) /] as Element of NAT
        by INT_1:16;
     A17: cos(n*Arg x)  = cos.(2*PI*m + r) by A14,SIN_COS:def 23 .= cos.(r) by
SIN_COS2:11
       .= cos(r) by SIN_COS:def 23;
             sin(n*Arg x)  = sin.(2*PI*m + r) by A14,SIN_COS:def 21 .= sin.(r)
by SIN_COS2:10
       .= sin(r) by SIN_COS:def 21;
     then r = 0 or r = PI by A13,A14,COMPTRIG:33; then (n*Arg x)/(n
*1) = (2*PI*m)/n by A5,A10,A11,A12,A14,A17,COMPLEX1:163,SIN_COS:82;
        then ((n/n)*Arg x)/1 = (2*PI*m)/n by XCMPLX_1:84;
        then (Arg x)/1 = (2*PI*m)/n by XCMPLX_1:89;
    hence ex k being Element of NAT st x=[**cos((2*PI*k)/n),sin((2*PI*k)/n)**]
     by A4,A6;
    end;
     now
        given k being Element of NAT such that
     A18: x = [**cos((2*PI*k)/n),sin((2*PI*k)/n)**];
        set 1F = Arg 1_F_Complex;
         0+1<=n by NAT_1:13;
     then A19: n-root 1 = 1 by POWER:7;
        reconsider z = 1_F_Complex as Element of COMPLEX by XCMPLX_0:def 2;
         x = (n-root |.z.|) * cos((1F + 2*PI*k)/n) +
                (n-root |.z.|) * sin((1F + 2*PI*k)/n) *<i> by A18,A19,
COMPLFLD:10,97,COMPTRIG:57;
        then x is CRoot of n,z by COMPTRIG:75;
      hence x in n-roots_of_1;
    end;
  hence thesis;
end;

theorem Th28:
for n being non empty Element of NAT for x,y being Element of COMPLEX
 st x in n-roots_of_1 & y in n-roots_of_1 holds x*y in n-roots_of_1
proof let n be non empty Element of NAT;
  let x,y be Element of COMPLEX such that
A1: x in n-roots_of_1 and
A2: y in n-roots_of_1;
   reconsider a=x as Element of F_Complex by COMPLFLD:def 1;
   reconsider b=y as Element of F_Complex by COMPLFLD:def 1;
   reconsider c = x*y as Element of F_Complex by COMPLFLD:def 1;
   consider i being Element of NAT such that
A3: a = [** cos((2*PI*i)/n), sin((2*PI*i)/n) **] by A1,Th27;
   consider j being Element of NAT such that
A4: b = [** cos((2*PI*j)/n), sin((2*PI*j)/n) **] by A2,Th27;
      a*b=[** cos((2*PI*((i+j) mod n))/n),sin((2*PI*((i+j)mod n))/n)**] by A3
,A4,Th13;
 hence thesis by Th27;
end;

theorem Th29:
for n being non empty Element of NAT holds
 n-roots_of_1 =
 {[**cos((2*PI*k)/n),sin((2*PI*k)/n)**] where k is Element of NAT: k < n }
proof let n be non empty Element of NAT;
  set X={[**cos((2*PI*k)/n),sin((2*PI*k)/n)**]
  where k is Element of NAT: k < n };
       now let x be set;
  hereby assume A1: x in n-roots_of_1;
     then reconsider a=x as Element of F_Complex;
     consider k being Element of NAT such that
  A2: a = [** cos((2*PI*k)/n), sin((2*PI*k)/n) **] by A1,Th27;
  A3: a = [** cos((2*PI*(k mod n))/n), sin((2*PI*(k mod n))/n) **] by A2,Th12;
       k mod n < n by NAT_D:1;
   hence x in X by A3;
  end;
  assume x in X; then ex k being Element of NAT st
         x = [**cos((2*PI*k)/n),sin((2*PI*k)/n)**] & k < n;
  hence x in n-roots_of_1 by Th27;
 end;
 hence thesis by TARSKI:2;
end;

theorem Th30:
for n being non empty Element of NAT holds Card (n-roots_of_1) = n
proof let n be non empty Element of NAT;
 set X = {[**cos((2*PI*k)/n),sin((2*PI*k)/n)**]
 where k is Element of NAT: k < n };
A1: X = n-roots_of_1 by Th29;
 defpred P[set, set] means ex j being Element of NAT st j=$1 &
                       $2=[**cos((2*PI*(j-'1))/n),sin((2*PI*(j-'1))/n)**];
     [**cos((2*PI*0)/n),sin((2*PI*0)/n)**] in X;
    then reconsider Y = X as non empty set;
A2: for x being set st x in Seg n ex y being set st y in Y & P[x,y]
    proof let x be set such that A3: x in Seg n;
        reconsider a=x as Element of NAT by A3;
    A4: 1 <= a & a <= n by A3,FINSEQ_1:3; then a < n+1 by NAT_1:13;
        then a-1 < n+1-1 by REAL_1:92;
    then A5: a-'1 < n by A4,BINARITH:50;
        consider b being Element of NAT such that A6: b = a-'1;
        set yy = [**cos((2*PI*b)/n),sin((2*PI*b)/n)**];
             [**cos((2*PI*b)/n),sin((2*PI*b)/n)**] in X by A5,A6;
      hence thesis by A6;
    end;
    consider F being Function of Seg n, Y such that
A7: for x being set st x in Seg n holds P[x,F.x] from FUNCT_2:sch 1(A2);
A8:  dom F = Seg n by FUNCT_2:def 1;
     for c being set st c in X ex x being set st x in Seg n & c = F.x
    proof let c be set such that A9: c in X;
        consider k being Element of NAT such that
    A10: c = [**cos((2*PI*k)/n),sin((2*PI*k)/n)**] & k < n by A9;
          0+1<=k+1 by XREAL_1:9;
        then 1<= k+1 & k+1 <= n by A10,INT_1:20;
    then A11: k+1 in Seg n by FINSEQ_1:3;
        then consider j being Element of NAT such that A12: j=k+1 &
        F.(k+1) = [**cos((2*PI*(j-'1))/n),sin((2*PI*(j-'1))/n)**] by A7;
             k+1-'1 = k by BINARITH:39;
      hence thesis by A10,A11,A12;
    end;
then A13:  rng F = X by FUNCT_2:16;
    for x1,x2 being set st x1 in dom F & x2 in dom F & F.x1=F.x2 holds x1= x2
    proof let x1,x2 be set such that
    A14: x1 in dom F & x2 in dom F & F.x1 = F.x2;
    A15: x1 in Seg n & x2 in Seg n by A14,FUNCT_2:def 1;
        then consider j being Element of NAT such that
    A16: j=x1 & F.x1 = [**cos((2*PI*(j-'1))/n),sin((2*PI*(j-'1))/n)**] by A7;
        consider k being Element of NAT such that
    A17: k=x2 & F.x2 = [**cos((2*PI*(k-'1))/n),sin((2*PI*(k-'1))/n)**] by A7
,A15;
    A18: cos((2*PI*(j-'1))/n) = cos((2*PI*(k-'1))/n)  &
        sin((2*PI*(j-'1))/n) = sin((2*PI*(k-'1))/n)
         by A14,A16,A17,COMPLEX1:163;
    A19: 1 <= j & j <= n by A15,A16,FINSEQ_1:3;
    A20: 1 <= k & k <= n by A15,A17,FINSEQ_1:3;
             j-1 < j by XREAL_1:148; then j-1 < n by A19,XXREAL_0:2;
    then A21: j-'1 < n by A19,BINARITH:50;
             k-1 < k by XREAL_1:148; then k-1 < n by A20,XXREAL_0:2;
    then A22: k-'1 < n by A20,BINARITH:50;
        set a1 = (2*PI*(j-'1))/n; set a2 = (2*PI*(k-'1))/n;
        A23: 0 <= 2*PI*(j-'1) by COMPTRIG:21,REAL_2:121;
             (j-'1)/n < n/n by A21,REAL_1:73; then (j-'1)/n < 1 by XCMPLX_1:60;
        then (j-'1)/n*(2*PI) < 1*(2*PI) by COMPTRIG:21,XREAL_1:70;
    then A24: 0 <= a1 & a1 < 2*PI by A23,REAL_2:125,XCMPLX_1:75;
           A25: 0 <= 2*PI*(k-'1) by COMPTRIG:21,REAL_2:121;
             (k-'1)/n < n/n by A22,REAL_1:73; then (k-'1)/n < 1 by XCMPLX_1:60;
        then (k-'1)/n*(2*PI) < 1*(2*PI) by COMPTRIG:21,XREAL_1:70;
    then 0 <= a2 & a2 < 2*PI by A25,REAL_2:125,XCMPLX_1:75;
        then a1 = a2 by A18,A24,COMPLEX2:12;
        then (2*PI*(j-'1))/n*n = 2*PI*(k-'1) by XCMPLX_1:88;
        then (2*PI)*(j-'1) = (2*PI)*(k-'1) by XCMPLX_1:88;
        then j-'1 = k-'1 by COMPTRIG:21,XCMPLX_1:5; then j = k-'1+1
by A19,BINARITH:53;
      hence thesis by A16,A17,A20,BINARITH:53;
    end; then F is one-to-one by FUNCT_1:def 8;
    then Seg n, F.:(Seg n) are_equipotent by A8,CARD_1:60;
    then Seg n, rng F are_equipotent by A8,RELAT_1:146;
    then Card (Seg n) = Card X by A13,CARD_1:21;
 hence Card (n-roots_of_1) = n by A1,FINSEQ_1:78;
end;

registration let n be non empty Element of NAT;
  cluster n-roots_of_1 -> non empty;
  correctness by Th25;
  cluster n-roots_of_1 -> finite;
  correctness proof Card (n-roots_of_1) = n by Th30;
   hence thesis by CARD_4:1;
  end;
end;

theorem Th31:
for n, ni being non empty Element of NAT
 st ni divides n holds ni-roots_of_1 c= n-roots_of_1
proof let n,ni be non empty Element of NAT such that A1: ni divides n;
   consider k being Nat such that A2: n = ni*k by A1,NAT_D:def 3;
   reconsider k as Element of NAT by ORDINAL1:def 13;
        for x being set st x in ni-roots_of_1 holds x in n-roots_of_1
   proof let x be set such that A3: x in ni-roots_of_1;
       reconsider y=x as Element of F_Complex by A3;
            y is CRoot of ni,1_F_Complex by A3,Th24;
       then 1_F_Complex = (power F_Complex).(y, ni) by COMPLFLD:def 2;
       then 1_F_Complex=(power F_Complex).((power F_Complex).(y,ni),k) by Th10;
       then 1_F_Complex = (power F_Complex).(y,n) by A2,Th14;
        then y is CRoot of n,1_F_Complex by COMPLFLD:def 2;
     hence thesis;
   end;
 hence thesis by TARSKI:def 3;
end;

theorem Th32:
for R being Skew-Field, x being Element of MultGroup R, y being Element of R
 st y = x
  for k being Element of NAT
  holds (power (MultGroup R)).(x,k) = (power R).(y,k)
proof let R be Skew-Field,
          x be Element of MultGroup R, y be Element of R such that
A1: y = x;
  defpred P[Element of NAT] means
   (power (MultGroup R)).(x,$1) = (power R).(y,$1);
A2: (power (MultGroup R)).(x,0) = 1_MultGroup R by GROUP_1:def 8;
 (power R).(y,0) = 1_R by GROUP_1:def 8;
then A3: P[0] by A2,Th20;
A4: for k be Element of NAT st P[k] holds P[k+1]
proof let k be Element of NAT such that
    A5: P[k];
     thus (power (MultGroup R)).(x,k+1)
        = (power (MultGroup R)).(x,k) * x by GROUP_1:def 8
       .= (power R).(y,k) * y by A1,A5,Th19
       .= (power R).(y,k+1) by GROUP_1:def 8;
    end;
 thus for k be Element of NAT holds P[k] from NAT_1:sch 1(A3,A4);
end;

theorem Th33:
for n being non empty Element of NAT, x being Element of MultGroup F_Complex
 st x in n-roots_of_1 holds x is_not_of_order_0
proof
 set FC = F_Complex;
 set cMGFC = the carrier of MultGroup F_Complex;
 set MGFC = MultGroup F_Complex;
let n be non empty Element of NAT, x be Element of cMGFC such that
A1:  x in n-roots_of_1;
    consider c being Element of FC such that
A2: c = x and
A3: c is CRoot of n,1_FC by A1;
A4: 1_MGFC = 1_FC by Th20;
        (power FC).(c,n) = 1_FC by A3,COMPLFLD:def 2;
    then x |^ n = 1_MGFC by A2,A4,Th32;
 hence x is_not_of_order_0 by GROUP_1:def 11;
end;

theorem Th34:
for n being non empty Element of NAT, k being Element of NAT,
x being Element of MultGroup F_Complex
 st x = [** cos((2*PI*k)/n), sin((2*PI*k)/n) **] holds ord x = n div (k gcd n)
proof let n be non empty Element of NAT, k be Element of NAT;
    let x be Element of MultGroup F_Complex such that
A1: x = [** cos((2*PI*k)/n), sin((2*PI*k)/n) **];
A2: (k gcd n) divides n by INT_2:32;
         abs(n) > 0 by ABSVALUE:def 1;
    then A3: abs(n) hcf abs(k) > 0 by NEWTON:71;
then A4: n gcd k > 0 by INT_2:def 3;
    reconsider kgn=(k gcd n) as Element of NAT by A3,INT_2:def 3;
A5: kgn <= n by A2,NAT_D:7;
    consider vn being Nat such that
A6: n = kgn * vn by A2,NAT_D:def 3;
   reconsider vn as Element of NAT by ORDINAL1:def 13;
     k gcd n divides k by INT_2:31;
    then consider i being Nat such that
A7: k = kgn * i by NAT_D:def 3;
   reconsider i as Element of NAT by ORDINAL1:def 13;
A8: now assume n div kgn = 0; then n = kgn * 0 + (n mod kgn) by A4,NAT_D:2;
      hence contradiction by A4,A5,NAT_D:1;
    end;
    A9: n = kgn * vn + 0 by A6;
then A10: n div kgn = vn by A4,NAT_D:def 1;
    reconsider y=x as Element of F_Complex by Th22;
A11: 2*PI*k/n*vn = (2*PI*(kgn * i))/(n / vn) by A7,XCMPLX_1:83
               .= (2*PI*(kgn * i)*vn)/n by XCMPLX_1:78
               .= (2*PI*i)*n/n by A6
               .= 2*PI*i + 0 by XCMPLX_1:90;
A12:     now assume vn is empty;
        hence contradiction by A6;
       end;
A13:   x |^ (n div kgn)
       = (power F_Complex).(y, vn) by A10,Th32
      .= y |^ vn by A12,COMPLFLD:112
      .= [**cos((2*PI*k)/n*vn), sin((2*PI*k)/n*vn) **] by A1,COMPTRIG:71
      .= [**cos(0), sin(2*PI*i + 0)**] by A11,COMPLEX2:10
      .= 1+0*<i> by COMPLEX2:9,SIN_COS:34
      .= 1_MultGroup F_Complex by Th20,COMPLFLD:10;
         x in n-roots_of_1 by A1,Th27;
        then A14: x is_not_of_order_0 by Th33;
         for m being Nat st x |^ m = 1_MultGroup F_Complex & m <> 0
       holds n div kgn <= m
    proof let m be Nat such that
    A15: x |^ m = 1_MultGroup F_Complex and A16: m <> 0;
    A17: 0 < m by A16;
    reconsider m as Element of NAT by ORDINAL1:def 13;
             now assume A18: m < vn;
               now assume k*m mod n = 0;
            then A19: n divides k*m by PEPIN:6;
                consider a,b being Integer such that
            A20: k = kgn*a & n = kgn*b and
            A21: a,b are_relative_prime by INT_2:38;
                     0 <= b proof assume 0 > b; then kgn*b < 0*b
by A4,XREAL_1:71;
                 hence contradiction by A20;
                end;
                then reconsider bi=b as Element of NAT by INT_1:16;
                     0 <= a proof assume 0 > a; then kgn*a < 0*a
by A4,XREAL_1:71;
                 hence contradiction by A20;
                end;
                then reconsider ai=a as Element of NAT by INT_1:16;
            A22: m < bi by A4,A10,A18,A20,NAT_D:18;
                consider j being Nat such that
            A23: k*m = n*j by A19,NAT_D:def 3;
                     m*a*kgn = j*(b*kgn) by A20,A23;
                then m*a = ((j*b)*kgn)/kgn by A4,XCMPLX_1:90;
                then m*a = j*b by A4,XCMPLX_1:90;
                then bi divides m*ai by NAT_D:def 3;
                then b divides m by A21,INT_2:40;
              hence contradiction by A17,A22,NAT_D:7;
            end;
        then A24: 0 < (k*m mod n) & (k*m mod n) < n by NAT_D:1;
        A25: 2*PI*k/n*m = (2*PI*k)/(n / m) by XCMPLX_1:83
                      .= (2*PI*k*m)/n by XCMPLX_1:78;
A26:      now assume m is empty;
         hence contradiction by A16;
        end;
        A27: x |^ m = (power F_Complex).(y, m) by Th32
          .= y |^ m by A26,COMPLFLD:112
          .= [**cos((2*PI*(k*m))/n), sin((2*PI*k*m)/n) **] by A1,A25,
COMPTRIG:71
          .= [**cos((2*PI*(k*m mod n))/n),
                sin((2*PI*(k*m mod n))/n)**] by Th12;
                 1_MultGroup F_Complex
              = [**1, 0**] by Th20,COMPLFLD:10;
         then A28: cos((2*PI*(k*m mod n))/n) = 1 by A15,A27,COMPLEX1:163;
                  2*PI*0 < 2*PI*(k*m mod n) by A24,COMPTRIG:21,XREAL_1:70;
         then A29: 0/n < 2*PI*(k*m mod n)/n by REAL_1:73;
                  2*PI*(k*m mod n) < 2*PI*n by A24,COMPTRIG:21,XREAL_1:70;
             then 2*PI*(k*m mod n)/n < 2*PI*n/n by REAL_1:73;
             then 2*PI*(k*m mod n)/n < 2*PI by XCMPLX_1:90;
          hence contradiction by A28,A29,COMPTRIG:79;
        end;
      hence thesis by A4,A9,NAT_D:def 1;
    end;
  hence thesis by A8,A13,A14,GROUP_1:def 12;
end;

theorem Th35:
for n being non empty Element of NAT
 holds n-roots_of_1 c= the carrier of MultGroup F_Complex
proof
 set FC = F_Complex;
 set cFC = the carrier of F_Complex;
 set cMGFC = the carrier of MultGroup F_Complex;
let n be non empty Element of NAT;
 let a be set; assume a in n-roots_of_1;
 then consider x being Element of F_Complex such that
A1: a = x and
A2: x is CRoot of n,1_F_Complex;
    (power FC).(x,n) = 1_FC by A2,COMPLFLD:def 2;
then A3: x <> 0.FC by COMPLFLD:9,10,VECTSP_1:95;
A4: cMGFC = cFC \ {0.FC} by Def1;
        not x in {0.FC} by A3,TARSKI:def 1;
 hence a in cMGFC by A1,A4,XBOOLE_0:def 4;
end;

theorem
    for n being non empty Element of NAT
 holds ex x being Element of MultGroup F_Complex st ord x = n
proof let n be non empty Element of NAT;
    set x = [** cos((2*PI*1)/n), sin((2*PI*1)/n) **];
A1: n-roots_of_1 c= the carrier of MultGroup F_Complex by Th35;
         x in n-roots_of_1 by Th27;
    then reconsider y=x as Element of MultGroup F_Complex by A1;
A2: ord y = n div (1 gcd n) by Th34;
         1 gcd n = 1 by WSIERP_1:13;
    then ord y = n by A2,NAT_2:6;
  hence thesis;
end;

theorem Th37:
for n being non empty Element of NAT, x being Element of MultGroup F_Complex
 holds ord x divides n iff x in n-roots_of_1
proof let n be non empty Element of NAT, x be Element of MultGroup F_Complex;
 set FC = F_Complex;
 set MGFC = MultGroup F_Complex;
   reconsider c = x as Element of FC by Th22;
A1: 1_MGFC = 1_FC by Th20;
 hereby assume
      ord x divides n; then consider k being Nat such that
 A2: n = (ord x)*k by NAT_D:def 3;
    x |^ ord x = 1_MGFC by GROUP_1:82;
      then (x |^ (ord x)) |^ k = 1_MGFC by GROUP_1:61;
     then x |^ n = 1_MGFC by A2,GROUP_1:50;
     then (power FC).(c, n) = 1_FC by A1,Th32;
     then c is CRoot of n,1_FC by COMPLFLD:def 2;
   hence x in n-roots_of_1;
 end;
 assume x in n-roots_of_1; then consider c being Element of FC such that
 A3: c = x and
 A4: c is CRoot of n,1_FC;
          (power FC).(c,n) = 1_FC by A4,COMPLFLD:def 2;
     then x |^ n = 1_MGFC by A1,A3,Th32;
 hence ord x divides n by GROUP_1:86;
end;

theorem Th38:
for n being non empty Element of NAT holds
n-roots_of_1 = { x where x is Element of MultGroup F_Complex : ord x divides n}
proof let n be non empty Element of NAT;
 set R = { a where a is Element of F_Complex : a is CRoot of n,1_F_Complex };
 set S = {x where x is Element of MultGroup F_Complex : ord x divides n};
 set MGFC = MultGroup F_Complex;
 set cMGFC = the carrier of MultGroup F_Complex;
A1: n-roots_of_1 = R;
then A2: R c= cMGFC by Th35;
       now let a be set;
   hereby assume
   A3: a in R; then reconsider x = a as Element of MGFC by A2;
     ord x divides n by A1,A3,Th37;
    hence a in S;
   end;
   assume a in S; then ex x being Element of MGFC st a = x & ord x
divides n;
    hence a in R by A1,Th37;
  end;
  hence n-roots_of_1 = S by TARSKI:2;
end;

theorem Th39:
for n being non empty Element of NAT, x being set
 holds x in n-roots_of_1
   iff ex y being Element of MultGroup F_Complex st x = y & ord y divides n
proof let n be non empty Element of NAT, x be set;
  set cMGFC = the carrier of MultGroup F_Complex;
  set MGFC = MultGroup F_Complex;
A1: n-roots_of_1 c= cMGFC by Th35;
  hereby assume
  A2: x in n-roots_of_1; then reconsider a = x as Element of MGFC by A1;
          ord a divides n by A2,Th37;
   hence ex y being Element of MultGroup F_Complex st x = y & ord y divides
n;
  end;
  thus thesis by Th37;
end;

definition let n be non empty Element of NAT;
  func n-th_roots_of_1 -> strict Group means  :Def3:
    the carrier of it = n-roots_of_1 &
    the mult of it = (the mult of F_Complex)||(n-roots_of_1);
  existence proof
      set mru = (the mult of F_Complex)||(n-roots_of_1);
      set X = [: n-roots_of_1, n-roots_of_1:];
A1: multcomplex = the mult of F_Complex by COMPLFLD:def 1;
           n-roots_of_1 c= the carrier of F_Complex;
      then n-roots_of_1 c= COMPLEX by COMPLFLD:def 1;
      then X c= [:COMPLEX, COMPLEX:] by ZFMISC_1:119;
  then A2:  X c= dom multcomplex by FUNCT_2:def 1;
           dom mru = dom multcomplex /\ X by A1,RELAT_1:90;
  then A3:  dom mru = X by A2,XBOOLE_1:28;
          for x being set st x in X holds mru.x in n-roots_of_1
      proof let x be set such that A4: x in X;
          consider a,b being set such that
      A5: [a,b] = x by A4,RELAT_1:def 1;
      A6: a in n-roots_of_1 & b in n-roots_of_1
          by A4,A5,ZFMISC_1:106;
          then reconsider a as Element of COMPLEX by COMPLFLD:def 1;
          reconsider b as Element of COMPLEX by A6,COMPLFLD:def 1;
      A7: multcomplex.(a,b) = a*b by BINOP_2:def 5;
               mru.[a,b] = multcomplex.[a,b] by A1,A3,A4,A5,FUNCT_1:70;
        hence thesis by A5,A6,A7,Th28;
      end;
      then reconsider uM = mru as BinOp of n-roots_of_1 by A3,FUNCT_2:5;
   A8:rng uM c= n-roots_of_1 by RELSET_1:12;

      set H = HGrStr(# n-roots_of_1, uM #);
   A9: for r,s,t being Element of H
      holds (r * s) * t = r * (s * t)
      proof let r,s,t be Element of H;
               r in the carrier of F_Complex & s in the carrier of F_Complex
&
          t in the carrier of F_Complex by TARSKI:def 3;
      then A10: r is Element of COMPLEX & s is Element of COMPLEX &
          t is Element of COMPLEX by COMPLFLD:def 1;
          set mc = multcomplex;
      A11: [r,s] in dom mru & [s,t] in dom mru by A3,ZFMISC_1:106;
      then A12: mru.[r,s] = mc.[r,s] & mru.[s,t] = mc.[s,t] by A1,FUNCT_1:70;
               mru.[s,t] in rng mru by A11,FUNCT_1:12;
          then [r,mru.[s,t]] in dom mru by A3,A8,ZFMISC_1:106;
      then A13: mru.[r,mru.[s,t]] = mc.(r,mc.(s,t)) by A1,A12,FUNCT_1:70;
               mru.[r,s] in rng mru by A11,FUNCT_1:12;
          then [mru.[r,s],t] in dom mru by A3,A8,ZFMISC_1:106;
          then mru.[mru.[r,s],t] = mc.(mc.(r,s),t) by A1,A12,FUNCT_1:70;
        hence thesis by A10,A13,BINOP_1:def 3;
      end;
      reconsider 1F = 1_F_Complex as Element of H by Th25;
  A14: 1_F_Complex
        = [** cos((2*PI*0)/n), sin((2*PI*0)/n) **]
                      by COMPLFLD:10,SIN_COS:34;
           for s1 being Element of H holds s1*1F = s1 & 1F*s1 = s1 &
        ex s2 being Element of H
           st s1 * s2 = 1_F_Complex & s2 * s1 = 1_F_Complex
      proof let s1 be Element of H;
      A15:  s1*1F = s1 & 1F*s1 = s1
          proof
              reconsider e1=s1 as Element of F_Complex by TARSKI:def 3;
              consider k being Element of NAT such that
          A16: e1 = [** cos((2*PI*k)/n), sin((2*PI*k)/n) **] by Th27;
          A17: e1*1_F_Complex
               = [** cos((2*PI*((k+0) mod n))/n),
                     sin((2*PI*((k+0) mod n))/n) **] by A14,A16,Th13
              .= s1 by A16,Th12;
          A18: 1_F_Complex*e1
              = [** cos((2*PI*((k+0) mod n))/n),
                     sin((2*PI*((k+0) mod n))/n) **] by A14,A16,Th13
              .= s1 by A16,Th12;
                  A19: [s1,1F] in dom mru by A3,ZFMISC_1:106;
                   [1F,s1] in dom mru by A3,ZFMISC_1:106;
           hence thesis by A17,A18,A19,FUNCT_1:70;
          end;
               ex s2 being Element of H
            st s1 * s2 = 1_F_Complex & s2 * s1 = 1_F_Complex
          proof
                  s1 in the carrier of F_Complex by TARSKI:def 3;
              then consider k being Element of NAT such that
          A20: s1 = [** cos((2*PI*k)/n), sin((2*PI*k)/n) **] by Th27;
              reconsider e1=[**cos((2*PI*k)/n),sin((2*PI*k)/n)**]
              as Element of F_Complex;
                   ex j being Element of NAT st (k+j) mod n = 0
              proof
                  set r = (k mod n);
              A21: k = n*(k div n) + r by NAT_D:2;
                   r < n by NAT_D:1;
                  then consider j being Nat such that
              A22: r+j = n by NAT_1:10;
              A23: j in NAT by ORDINAL1:def 13;
                 (k+j) mod n = (((k div n)+1)*n) mod n by A21,A22;
                then (k+j) mod n = 0 by NAT_D:13;
                hence thesis by A23;
              end; then consider j being Element of NAT such that
              A24: (k+j) mod n = 0;
              set ss2 = [**cos((2*PI*j)/n),sin((2*PI*j)/n)**];
              reconsider s2=ss2 as Element of H by Th27;
              reconsider e2=s2 as Element of F_Complex;
              A25: e1*e2 = [** cos((2*PI*((j+k) mod n))/n),
                          sin((2*PI*((j+k) mod n))/n) **] by Th13;
                   [s1,s2] in dom mru by A3,ZFMISC_1:106;
          then A26: s1*s2 = 1_F_Complex by A20,A24,A25,COMPLFLD:10,FUNCT_1:70
,SIN_COS:34;
              A27: e2*e1 = [** cos((2*PI*((j+k) mod n))/n),
                          sin((2*PI*((j+k) mod n))/n) **] by Th13;
                   [s2,s1] in dom mru by A3,ZFMISC_1:106;
              then s2*s1 = 1_F_Complex by A20,A24,A27,COMPLFLD:10,FUNCT_1:70
,SIN_COS:34;
            hence thesis by A26;
          end;
        hence thesis by A15;
      end;
      then H is Group by A9,GROUP_1:5;
    hence thesis;
  end;
  uniqueness;
end;

theorem
     for n being non empty Element of NAT
 holds n-th_roots_of_1 is Subgroup of MultGroup F_Complex
proof let n be non empty Element of NAT;
  set nth = n-th_roots_of_1; set cnth = the carrier of nth;
  set FC = F_Complex;
  set cMGFC = the carrier of MultGroup F_Complex;
  set MGFC = MultGroup F_Complex;
A1: the carrier of nth = n-roots_of_1 by Def3;
then A2: the carrier of nth c= the carrier of MGFC by Th35;
A3: the mult of nth = (the mult of FC)||(n-roots_of_1) by Def3;
A4: the mult of MGFC = (the mult of FC)||cMGFC by Def1;
        [:cnth,cnth:] c= [:cMGFC, cMGFC:] by A2,ZFMISC_1:119;
   then the mult of nth = (the mult of MGFC)||cnth by A1,A3,A4,RELAT_1:103;
 hence n-th_roots_of_1 is Subgroup of MGFC by A2,GROUP_2:def 5;
end;

begin :: The unital polynomial x^n -1

definition let n be non empty Nat,
L be left_unital (non empty doubleLoopStr);
 func unital_poly(L,n) -> Polynomial of L equals
   0_.(L)+*(0,-(1_L))+*(n,1_L);
  coherence proof set p = 0_.(L)+*(0,-(1_L))+*(n,1_L);
  A1: for i being Nat st i <> 0 & i <> n holds p.i = 0.L
      proof let i be Nat such that A2: i <> 0 & i <> n;
A3:     i in NAT by ORDINAL1:def 13;
         set q = 0_.(L)+*(0,-(1_L));
        q+*(n,1_L).i = q.i by A2,FUNCT_7:34 .= (0_.(L)).i by A2,FUNCT_7:34
           .= 0.L by FUNCOP_1:13,A3;
        hence thesis;
      end;
      for i being Nat st i >= n+1 holds p.i = 0.L
      proof let i be Nat such that A3: i >= n+1;
               now assume A4: i = n;
                  n + 0 < n + 1 by XREAL_1:10;
            hence contradiction by A3,A4;
          end;
        hence p.i = 0.L by A1,A3;
      end;
    hence p is Polynomial of L by ALGSEQ_1:def 2;
  end;
end;

 Lm4:
unital_poly(F_Complex,1) = <%-1_F_Complex, 1_F_Complex %> by POLYNOM5:def 4;

canceled;

theorem Th42:
for L being left_unital (non empty doubleLoopStr)
for n being non empty Element of NAT
  holds unital_poly(L,n).0 = -1_L & unital_poly(L,n).n = 1_L
proof let L be left_unital (non empty doubleLoopStr),
n be non empty Element of NAT;
    set p = 0_.(L)+*(0,-(1_L));
         p is sequence of L & n in NAT;
    then A1: n in dom p by NORMSP_1:17;
    set q = 0_.(L)+*(n,1_L);
    A2: unital_poly(L,n) = q+*(0,-(1_L)) by FUNCT_7:35;
         q is sequence of L & 0 in NAT;
    then 0 in dom q by NORMSP_1:17;
  hence thesis by A1,A2,FUNCT_7:33;
end;

theorem Th43:
for L being left_unital (non empty doubleLoopStr)
for n being non empty Nat, i being Nat st i <> 0 & i <> n
  holds unital_poly(L,n).i = 0.L
proof let L be left_unital (non empty doubleLoopStr),
n be non empty Nat;
    let i be Nat such that A1: i <> 0 & i <> n;
A2: i in NAT by ORDINAL1:def 13;
    set p = 0_.(L)+*(0,-(1_L));
         p+*(n,1_L).i = p.i by A1,FUNCT_7:34
       .= (0_.(L)).i by A1,FUNCT_7:34     .= 0.L by FUNCOP_1:13,A2;
  hence thesis;
end;

theorem Th44:
for L being non degenerated well-unital (non empty doubleLoopStr),
    n being non empty Element of NAT
 holds len unital_poly(L,n) = n+1
proof let L be non degenerated well-unital (non empty doubleLoopStr);
    let n be non empty Element of NAT;
    for i being Nat st i >= n+1 holds unital_poly(L,n).i=0.L
    proof let i be Nat such that A1: i >= n+1;
      now assume A2: i = n;       n + 0 < n + 1 by XREAL_1:10;
        hence contradiction by A1,A2;
      end;
      hence unital_poly(L,n).i = 0.L by A1,Th43;
    end;
then A3: n+1 is_at_least_length_of unital_poly(L,n) by ALGSEQ_1:def 3;
         for m being Nat st m is_at_least_length_of unital_poly(L,n)
      holds n+1 <= m
    proof let m be Nat such that
    A4: m is_at_least_length_of unital_poly(L,n);
             now assume m < n+1;
        then m <= n by NAT_1:13;
             then unital_poly(L,n).(n) = 0.L &
            unital_poly(L,n).(n) = 1_L by A4,Th42,ALGSEQ_1:def 3;
          hence contradiction by VECTSP_1:def 21;
        end;
      hence thesis;
    end;
  hence thesis by A3,ALGSEQ_1:def 4;
end;

registration
  let L be non degenerated well-unital (non empty doubleLoopStr),
      n be non empty Element of NAT;
 cluster unital_poly(L,n) -> non-zero;
 correctness proof
       len unital_poly(L,n) = n+1 by Th44;
   hence thesis by UPROOTS:19;
 end;
end;

theorem Th45:
for n being non empty Element of NAT for x being Element of F_Complex
  holds eval(unital_poly(F_Complex,n), x) = (power F_Complex).(x,n) - 1
proof let n be non empty Element of NAT, x be Element of F_Complex;
    set p = unital_poly(F_Complex,n);
    consider F being FinSequence of F_Complex such that
A1: eval(p,x) = Sum F and A2: len F = len p and
A3: for i being Element of NAT st i in dom F
      holds F.i = p.(i-'1) * (power F_Complex).(x,i-'1) by POLYNOM4:def 2;
       A4: 0+1 < n+1 by XREAL_1:10;
then A5: 1 < len F by A2,Th44;
A6: len F=n+1 by A2,Th44; then len F -1=n;
then A7: len F -'1 = n by A4,BINARITH:50;
    set null = (len F-'1) |-> (0.F_Complex);
A8: null is Element of (len F-'1)-tuples_on the carrier of F_Complex
    by FINSEQ_2:132;
A9: Sum null = 0.F_Complex by MATRIX_3:13;
A10: len null = len F -'1 by FINSEQ_2:69;
A11: for i being Element of NAT st i in dom null holds null.i = 0.F_Complex
    proof let i be Element of NAT such that A12: i in dom null;
             i in Seg (len F-'1) by A12,FUNCOP_1:19;
      hence null.i = 0.F_Complex by FUNCOP_1:13;
    end;
    set xn = (power F_Complex).(x,n);
    reconsider zt = (power F_Complex).(x,n) as Element of COMPLEX
         by COMPLFLD:def 1;
    reconsider 1f = -1_F_Complex as Element of COMPLEX by COMPLFLD:def 1;
         len F - 1 + 1 = len F;
then A13: len F-'1+1 = len F by A5,BINARITH:50;
    set tR1 = <*-1_F_Complex*>^null;
    set tR2 = null^<*xn*>;
A14: len tR1 = len F & len tR2 = len F proof
             len tR1 = len <*-1_F_Complex*> + len null by FINSEQ_1:35;
       hence len tR1 = len F by A10,A13,FINSEQ_1:56;
             len tR2 = len null + len <*xn*> by FINSEQ_1:35;
       hence len tR2 = len F by A10,A13,FINSEQ_1:56;
    end;
    reconsider R1=tR1 as Element of
    (len F)-tuples_on the carrier of F_Complex by A8,A13,FINSEQ_2:127;
    reconsider R2=tR2 as Element of
    (len F)-tuples_on the carrier of F_Complex by A8,A13,FINSEQ_2:127;
A15: R1.1 = -1_F_Complex &
    for i being Element of NAT st i <> 1 & i in dom R1 holds R1.i = 0.F_Complex
    proof thus R1.1 = -1_F_Complex by FINSEQ_1:58;
      for i being Nat st i <> 1 & i in dom R1
            holds R1.i = 0.F_Complex
        proof let i be Nat such that A16: i <> 1 and
        A17: i in dom R1;
        A18: dom <*-1_F_Complex*> = Seg 1 by FINSEQ_1:def 8;
                 now assume i in dom <*-1_F_Complex*>;
                then 1<=i & i<=1 by A18,FINSEQ_1:3;
                hence contradiction by A16,XXREAL_0:1;
            end; then consider j being Nat such that
        A19: j in dom null & i = len <*-1_F_Complex*> + j by A17,FINSEQ_1:38;
                 null.j = 0.F_Complex by A11,A19;
          hence R1.i = 0.F_Complex by A19,FINSEQ_1:def 7;
        end;
      hence thesis;
    end;
A20: R2.(len F) = (power F_Complex).(x,n) &
    for i being Element of NAT st i in dom R2 & i <> len F
    holds R2.i = 0.F_Complex
    proof
      thus R2.(len F) = (power F_Complex).(x,n) by A10,A13,FINSEQ_1:59;
             for i being Element of NAT st i in dom R2 & i <> len F
            holds R2.i = 0.
F_Complex
        proof let i be Element of NAT such that A21: i in dom R2 & i <> len F;
            A22: dom R2 = Seg len F by A14,FINSEQ_1:def 3;
        then 1 <= i & i <= len F by A21,FINSEQ_1:3;
            then i < len F-'1+1 by A13,A21,REAL_1:def 5;
            then 1 <= i & i <= len F-'1 by A21,A22,FINSEQ_1:3,NAT_1:13;
            then i in Seg (len F-'1) by FINSEQ_1:3;
        then A23: i in dom null by A10,FINSEQ_1:def 3;
            then R2.i = null.i by FINSEQ_1:def 7;
          hence R2.i = 0.F_Complex by A11,A23;
        end;
      hence thesis;
    end;
        A24: Sum R1 = -1_F_Complex + 0.F_Complex by A9,FVSUM_1:89;
        A25: Sum R2 = 0.F_Complex + xn by A9,FVSUM_1:87;
A26: dom F = Seg len F by FINSEQ_1:def 3;
     A27: len R1 = len F & len R2 = len F by FINSEQ_2:109;
then A28: dom R1 = Seg len F & dom R2 = Seg len F by FINSEQ_1:def 3;
    A29: len (R1+R2) = len F by FINSEQ_2:109;
then A30: dom (R1+R2) = Seg len F by FINSEQ_1:def 3;
         1 - 1 = 0;
then A31: 1 -'1 = 0 by BINARITH:50;
A32: p.0 = -1_F_Complex by Th42;
         for k being Nat st k in dom (R1+R2) holds (R1+R2).k = F.k
    proof let k be Nat such that A33: k in dom (R1+R2);
    A34: k in Seg len F by A29,A33,FINSEQ_1:def 3;
    A35: k in dom F & k in dom R1 & k in dom R2 by A27,A30,A33,FINSEQ_1:def 3;
    A36: 1 <= k & k <= len F by A30,A33,FINSEQ_1:3;
    A37: (-1_F_Complex)*(1_F_Complex) = -1_F_Complex by COMPLFLD:10;
         now per cases;
        suppose A38: k = 1;
        then A39: F.1 = p.0 * (power F_Complex).(x,0) by A3,A31,A35
               .= -1_F_Complex by A32,A37,GROUP_1:def 8;
                 R2.k = 0.F_Complex by A5,A20,A28,A34,A38;
            then (R1+R2).1 = (-1_F_Complex)+0.F_Complex by A15,A33,A38,
FVSUM_1:21;
        hence (R1+R2).k = F.k by A38,A39,COMPLFLD:9;
        end;
        suppose A40: k <> 1;       now per cases;
            suppose A41: k = len F;
                     len F <> 0 by A2,A4,Th44;
                then len F in dom F by A26,FINSEQ_1:5;
            then A42: F.(len F) = p.(len F-'1)*(power F_Complex).(x,len F-'1)
by A3
                         .= 1_F_Complex*(power F_Complex).(x,n) by A7,Th42
                         .= (power F_Complex).(x,n) by VECTSP_1:def 19;
                 R1.(len F) = 0.F_Complex by A5,A15,A28,A34,A41;
                then (R1+R2).(len F) = 0.F_Complex + (power F_Complex).(x,
n)
                                  by A20,A33,A41,FVSUM_1:21
             .= (power F_Complex).(x,n) by COMPLFLD:9;
            hence (R1+R2).k = F.k by A41,A42;
            end;
            suppose A43: k <> len F;
                     1 < k by A36,A40,REAL_1:def 5; then 1+-1 < k+-1 by
XREAL_1:10;
                then 1-1 < k-1;
            then A44: 0 < k-'1 by A36,BINARITH:50;
                     now assume k-'1 = n; then k - 1 = n by A36,BINARITH:50;
                    hence contradiction by A6,A43;
                end;
                then p.(k-'1) = 0.F_Complex by A44,Th43;
                then A45: F.k = 0.F_Complex * (power F_Complex).(x,k-'1) by A3
,A35;
                     R1.k = 0.F_Complex & R2.k = 0.F_Complex by A15,A20,A28,A34
,A40,A43;
                then (R1+R2).k = 0.F_Complex + 0.F_Complex by A33,FVSUM_1:21;
            hence (R1+R2).k = F.k by A45,COMPLFLD:9;
         end;
         end;
       hence (R1+R2).k = F.k;
      end;
      end;
     hence (R1+R2).k = F.k;
    end;
then A46: (R1+R2) = F by A26,A30,FINSEQ_1:17;
    reconsider z2=1_F_Complex as Element of COMPLEX by COMPLFLD:def 1;
A47: -z2 = -1_F_Complex by COMPLFLD:4;
         Sum F = -1_F_Complex+(power F_Complex).(x,n) by A24,A25,A46,COMPLFLD:9
,FVSUM_1:95;
  hence thesis by A1,A47,COMPLFLD:10;
end;

theorem Th46:
for n being non empty Element of NAT
holds Roots unital_poly(F_Complex, n) = n-roots_of_1
proof let n be non empty Element of NAT;
      now let x be set;  set p = unital_poly(F_Complex,n);
  hereby
   assume A1: x in Roots p;
     then reconsider x' = x as Element of F_Complex;
          x' is_a_root_of p by A1,POLYNOM5:def 9;
     then 0.F_Complex = eval(p,x') by POLYNOM5:def 6
     .= (power F_Complex).(x',n) - 1 by Th45;
     then x' is CRoot of n, 1_F_Complex by COMPLFLD:9,10,def 2;
   hence x in n-roots_of_1;
  end;
  assume A2: x in n-roots_of_1;
   then reconsider x' = x as Element of F_Complex;
        x' is CRoot of n, 1_F_Complex by A2,Th24;
   then (power F_Complex).(x',n) = 1 by COMPLFLD:10,def 2;
   then (power F_Complex).(x',n) - 1 = 0c;
   then eval(p,x') = 0.F_Complex by Th45,COMPLFLD:9;
      then x' is_a_root_of p by POLYNOM5:def 6;
  hence x in Roots unital_poly(F_Complex,n) by POLYNOM5:def 9;
 end;
 hence Roots unital_poly(F_Complex,n) = n-roots_of_1 by TARSKI:2;
end;

theorem Th47:
for n being Element of NAT, z being Element of F_Complex
 st z is Real ex x being Real st x = z & (power F_Complex).(z,n) = x |^ n
proof let n be Element of NAT;
    let z be Element of F_Complex such that A1: z is Real;
    reconsider x=z as Real by A1;
    per cases;
    suppose A2: x = 0;
    then A3: z = 0.F_Complex by COMPLFLD:def 1;
     thus thesis proof
     per cases;
     suppose A4: n = 0;
       then (power F_Complex).(z,n) = 1 by COMPLFLD:10,GROUP_1:def 8
         .= x |^ n by A4,NEWTON:9;
      hence thesis;
     end;
     suppose A5: n > 0;
     then A6: n >= 0+1 by NAT_1:13;
            (power F_Complex).(z,n) = 0.F_Complex by A3,A5,VECTSP_1:95
        .= x|^n by A2,A6,COMPLFLD:9,NEWTON:16;
      hence thesis;
     end;
     end;
    end;
    suppose A7: x <> 0;
    defpred P[Element of NAT] means (power F_Complex).(z,$1) = x |^ $1;
         (power F_Complex).(z,0) = 1r by COMPLFLD:10,GROUP_1:def 8
        .= x #Z 0 by PREPOWER:44
        .= x |^ 0 by PREPOWER:46;
then A8: P[0];
A9: for n being Element of NAT st P[n] holds P[n+1]
    proof let n be Element of NAT such that
    A10: P[n];
             (power F_Complex).(z,n+1)
           = (power F_Complex).(z,n)*z by GROUP_1:def 8
          .= (x #Z n) * x by A10,PREPOWER:46
          .= (x#Z n) * (x #Z 1) by PREPOWER:45.= (x #Z (n+1)) by A7,PREPOWER:54
          .= (x |^ (n+1)) by PREPOWER:46;
      hence thesis;
    end;
         for n being Element of NAT holds P[n] from NAT_1:sch 1(A8,A9);
    then (power F_Complex).(z,n) = x |^ n;
  hence thesis;
end;
end;

theorem Th48:
for n being non empty Element of NAT for x being Real
ex y being Element of F_Complex
 st y = x & eval(unital_poly(F_Complex,n),y) = (x |^ n) - 1
proof let n be non empty Element of NAT, x be Real;
A1: x = x+0*<i>
     .= [*x,0*] by COMPLEX1:27;
    reconsider y=[*x,0*] as Element of F_Complex by COMPLFLD:def 1;
    consider x2 being Real such that
A2: x2 = y & (power F_Complex).(y,n) = x2 |^ n by A1,Th47;
         eval(unital_poly(F_Complex,n),y) = (x |^ n) - 1 by A1,A2,Th45;
  hence thesis by A1;
end;

theorem Th49:
for n being non empty Element of NAT
 holds BRoots unital_poly(F_Complex, n) = (n-roots_of_1, 1)-bag
proof let n being non empty Element of NAT;
set p = unital_poly(F_Complex, n);
A1: Roots p = n-roots_of_1 by Th46;
A2: support BRoots p = Roots p by UPROOTS:def 9;
A3: degree BRoots p = len p -' 1 by UPROOTS:61 .= n+1 -'1 by Th44
   .= n by BINARITH:39;
     card (n-roots_of_1) = n by Th30;
 hence BRoots unital_poly(F_Complex, n) = (n-roots_of_1, 1)-bag
     by A1,A2,A3,UPROOTS:15;
end;

theorem Th50:
for n being non empty Element of NAT
 holds unital_poly(F_Complex, n) = poly_with_roots((n-roots_of_1, 1)-bag)
proof let n be non empty Element of NAT;  set p = unital_poly(F_Complex, n);
     len p = n+1 by Th44;
then p.(len p-'1) = p.n by BINARITH:39 .= 1_F_Complex by Th42;
  hence unital_poly(F_Complex, n)
   = poly_with_roots BRoots unital_poly(F_Complex, n) by UPROOTS:67
  .= poly_with_roots((n-roots_of_1, 1)-bag) by Th49;
end;

theorem Th51:
for n being non empty Element of NAT, i being Element of F_Complex
 st i is Integer holds eval(unital_poly(F_Complex, n), i) is Integer
proof let n be non empty Element of NAT;
    let i be Element of F_Complex such that A1: i is Integer;
    reconsider j = i as Integer by A1;
         i is Real by A1,XREAL_0:def 1;
    then consider y being Element of F_Complex such that
A2: y = i and A3: eval(unital_poly(F_Complex,n),y) = (j |^ n) - 1 by Th48;
  thus eval(unital_poly(F_Complex,n),i) is Integer by A2,A3;
end;

begin :: Cyclotomic Polynomials

definition let d be non empty Nat;
 func cyclotomic_poly d -> Polynomial of F_Complex means :Def5:
   ex s being non empty finite Subset of F_Complex
    st s = { y where y is Element of MultGroup F_Complex : ord y = d } &
       it = poly_with_roots((s,1)-bag);
 existence proof
 reconsider d as non empty Element of NAT by ORDINAL1:def 13;
   set cMGFC = the carrier of MultGroup F_Complex;
   defpred P[Element of cMGFC] means ord $1 = d;
   set s = { y where y is Element of cMGFC : P[y]};
   set x = [** cos((2*PI*1)/d), sin((2*PI*1)/d) **];
A1: cMGFC = (the carrier of F_Complex) \ {0.F_Complex} by Def1;
        x <> 0.F_Complex proof assume  x = 0.F_Complex;
        then 0+0*<i> = cos((2*PI*1)/d)+(sin((2*PI*1)/d))*<i> by COMPLFLD:9;
     then cos((2*PI*1)/d) = 0 & sin((2*PI*1)/d) = 0 by COMPLEX1:163;
    hence contradiction by COMPLEX2:11;
   end; then not x in {0.F_Complex} by TARSKI:def 1;
   then reconsider x as Element of cMGFC by A1,XBOOLE_0:def 4;
   reconsider i = d as Integer;
    1 gcd i = 1 by WSIERP_1:13;
        then ord x = d div 1 by Th34
         .= d by NAT_2:6;
   then A2: x in s;
A3: d-roots_of_1 = {y where y is Element of cMGFC : ord y divides d} by Th38;
       s c= d-roots_of_1 proof let a be set; assume a in s;
      then consider y being Element of cMGFC such that
   A4: a = y and
   A5: ord y = d;
     thus a in d-roots_of_1 by A3,A4,A5;
   end;
   then reconsider s as non empty finite Subset of F_Complex
  by A2,FINSET_1:13,XBOOLE_1:1;
   take poly_with_roots((s,1)-bag);
   thus thesis;
 end;
 uniqueness;
end;

theorem Th52:
cyclotomic_poly(1) = <%-1_F_Complex, 1_F_Complex %>
proof
 set cMGFC = the carrier of MultGroup F_Complex;
consider s being non empty finite Subset of F_Complex such that
A1: s = { y where y is Element of cMGFC : ord y = 1 } and
A2: cyclotomic_poly(1) = poly_with_roots((s,1)-bag) by Def5;
A3: 1-roots_of_1 = {x where x is Element of cMGFC : ord x divides 1} by Th38;
        now let x be set;
    hereby assume x in s;
    then consider x1 being Element of cMGFC such that
   A4: x = x1 and
   A5: ord x1 = 1 by A1;
     thus x in 1-roots_of_1 by A3,A4,A5;
    end;
    assume x in 1-roots_of_1;
    then consider x1 being Element of cMGFC such that
   A6: x = x1 and
   A7: ord x1 divides 1 by A3;
     ord x1 = 1 by A7,WSIERP_1:20;
    hence x in s by A1,A6;
   end;
then s = 1-roots_of_1 by TARSKI:2;
  hence cyclotomic_poly(1)
    = <%-1_F_Complex, 1_F_Complex %> by A2,Lm4,Th50;
end;

theorem Th53:
  for n being non empty Element of NAT,
    f being FinSequence of (the carrier of Polynom-Ring F_Complex)
 st len f = n &
    for i being non empty Element of NAT st i in dom f
     holds (not i divides n implies f.i = <%1_F_Complex%>) &
           (i divides n implies f.i = cyclotomic_poly(i))
  holds unital_poly(F_Complex,n) = Product(f)
proof let n be non empty Element of NAT,
          f be FinSequence of (the carrier of Polynom-Ring F_Complex) such that
A1: len f = n and
A2: for i being non empty Element of NAT st i in dom f holds
      (not i divides n implies f.i = <%1_F_Complex%>) &
      (i divides n implies f.i = cyclotomic_poly(i));
   A3: 0+1 <= n by NAT_1:13;
   set nr1 = n-roots_of_1;
A4: nr1 = {x where x is Element of MultGroup F_Complex :
                    ord x divides n} by Th38;
   set b = (nr1, 1)-bag;
   defpred P[Nat,set] means
   for fi being FinSequence of (the carrier of Polynom-Ring F_Complex)
      st fi = f|Seg $1 holds $2 = Product(fi);
A5: now let i being Nat; assume i in Seg len f;
        set fi = f|Seg i;
        reconsider fi = f|Seg i as FinSequence of
           (the carrier of Polynom-Ring F_Complex) by FINSEQ_1:23;
        set x = Product fi;   take x;   thus P[i,x];
    end;
   consider F being FinSequence of Polynom-Ring F_Complex such that
         dom F = Seg len f and
A6: for i being Nat st i in Seg len f holds P[i,F.i]
from FINSEQ_1:sch 5(A5);
   deffunc MG(Nat) =
   {y where y is Element of MultGroup F_Complex : y in nr1 & ord y <= $1 };
  set cMGFC = the carrier of MultGroup F_Complex;
A7: now let i be Element of NAT;
       MG(i) c= nr1 proof let x be set; assume x in MG(i);
         then ex y being Element of cMGFC st x = y & y in nr1 & ord y <= i;
        hence x in nr1;
       end;
    hence MG(i) is finite Subset of F_Complex by FINSET_1:13,XBOOLE_1:1;
   end;
   defpred R[Element of NAT] means
   ex t being finite Subset of F_Complex
     st t =  MG($1) & F.$1 = poly_with_roots((t,1)-bag);
A8: R[1] proof  reconsider t = MG(1) as finite Subset of F_Complex by A7;
          take t; thus t = MG(1);
          set b = (t,1)-bag;
    A9: 1 in Seg len f by A1,A3,FINSEQ_1:3;
    A10: 1 in dom f by A1,A3,FINSEQ_3:27;
        reconsider f1 = f|Seg 1 as
         FinSequence of (the carrier of Polynom-Ring F_Complex) by FINSEQ_1:23;
    A11: f1 = <*f.1*> by A1,A3,Th2;
             1 in dom f by A9,FINSEQ_1:def 3;
        then reconsider fd1 = f.1 as
           Element of (the carrier of Polynom-Ring F_Complex) by FINSEQ_2:13;
    A12: 1 divides n by NAT_D:6;
             F.1 = Product <*fd1*> by A6,A9,A11 .= fd1 by FINSOP_1:12
           .= cyclotomic_poly(1) by A2,A10,A12;
        then consider sB being non empty finite Subset of F_Complex such that
    A13: sB = { y where y is Element of cMGFC : ord y = 1 } and
    A14: F.1 = poly_with_roots((sB,1)-bag) by Def5;
             now let x be set;
          hereby assume x in MG(1);
              then consider y being Element of cMGFC such that
          A15: x = y and
          A16: y in nr1 and
          A17: ord y <= 1;
                  y is_not_of_order_0 by A16,Th33;
              then ord y <> 0 by GROUP_1:def 12;
              then 0 < ord y; then 0+1 <= ord y by NAT_1:13;
              then ord y = 1 by A17,XXREAL_0:1;
           hence x in sB by A13,A15;
          end;
          assume x in sB; then consider y being Element of cMGFC such that
          A18: x = y and
          A19: ord y = 1 by A13;
                   ord y divides n by A19,NAT_D:6; then y in nr1 by A4;
          hence x in MG(1) by A18,A19;
        end;
     hence F.1 = poly_with_roots(b) by A14,TARSKI:2;
    end;
A20: for i being Element of NAT st 1 <= i & i < len f holds R[i] implies R[i+1]
proof
     let i be Element of NAT such that
    A21: 1 <= i & i < len f and
    A22: R[i];
    A23: i in Seg len f by A21,FINSEQ_1:3;
    A24: 1 <= i+1 & i+1 <= len f by A21,NAT_1:13;
    then A25: i+1 in Seg len f by FINSEQ_1:3;
    then A26: i+1 in dom f by FINSEQ_1:def 3;
        consider sb being finite Subset of F_Complex such that
    A27: sb = MG(i) and
    A28: F.i = poly_with_roots((sb,1)-bag) by A22;
        set b = (sb, 1)-bag;
        reconsider sB = MG(i+1) as finite Subset of F_Complex by A7;
        take sB; thus sB = MG(i+1);
        set B = (sB,1)-bag;
        reconsider fi = f|Seg i as
         FinSequence of (the carrier of Polynom-Ring F_Complex) by FINSEQ_1:23;
    A29: F.i = Product fi by A6,A23;
        reconsider fi1 = f|Seg (i+1) as
         FinSequence of (the carrier of Polynom-Ring F_Complex) by FINSEQ_1:23;
             i <= i+1 by NAT_1:12;
    then A30: fi = fi1 | Seg i by Lm2;
             i+1 = min(i+1,len f) by A24,XXREAL_0:def 8;
    then A31: len fi1 = i+1 by FINSEQ_2:24;
              i+1 in Seg (i+1) by FINSEQ_1:6;
    then A32: (f|Seg (i+1)).(i+1) = f.(i+1) by FUNCT_1:72;
        then reconsider fi1d1 = fi1.(i+1) as
        Element of (the carrier of Polynom-Ring F_Complex) by A26,FINSEQ_2:13;
      reconsider fi1d1p = fi1d1 as Polynomial of F_Complex by POLYNOM3:def 12;
             fi1 = fi ^ <* fi1d1 *> by A30,A31,FINSEQ_3:61;
    then A33: Product fi1 = Product fi * fi1d1 by GROUP_4:9
           .= (poly_with_roots b) *' fi1d1p by A28,A29,POLYNOM3:def 12;
        per cases;
        suppose A34: not (i+1) divides n;
            set eb = EmptyBag the carrier of F_Complex;
                 now let x be set;
             hereby assume x in sB; then consider y being
               Element of MultGroup F_Complex such that
             A35: x = y and
             A36: y in nr1 and
             A37: ord y <= i+1;
                     ord y divides n by A36,Th37;
                  then ord y < i+1 by A34,A37,REAL_1:def 5; then ord y
<= i by NAT_1:13;
              hence x in sb by A27,A35,A36;
             end;
             assume x in sb; then consider y being Element of cMGFC such
that
             A38: x = y and
             A39: y in nr1 and
             A40: ord y <= i by A27;       ord y <= i+1 by A40,NAT_1:12;
             hence x in sB by A38,A39;
            end; then A41: sB = sb by TARSKI:2;
                f.(i+1) = <%1_F_Complex%> by A2,A26,A34
                  .= poly_with_roots(eb) by UPROOTS:62;
         hence F.(i+1) = (poly_with_roots b)*' poly_with_roots(eb) by A6,A25
,A32,A33
           .= poly_with_roots (b+eb) by UPROOTS:66
   .= poly_with_roots(B) by A41,POLYNOM1:57;
        end;
        suppose A42: i+1 divides n;
           consider scb being non empty finite Subset of F_Complex such that
        A43: scb = {y where y is Element of cMGFC : ord y = i+1 } and
        A44: cyclotomic_poly(i+1) = poly_with_roots((scb,1)-bag) by Def5;
            set cb = (scb,1)-bag;
        A45: f.(i+1) = poly_with_roots(cb) by A2,A26,A42,A44;
                 now let x be set;
              hereby assume x in sB;
                then consider y being Element of cMGFC such that
            A46: x = y and
            A47: y in nr1 and
            A48: ord y <= i+1;
                     ord y <= i or ord y = i+1 by A48,NAT_1:8;
                then y in sb or y in scb by A27,A43,A47;
               hence x in sb \/ scb by A46,XBOOLE_0:def 2;
              end;
              assume A49: x in sb \/ scb;
              per cases by A49,XBOOLE_0:def 2;
              suppose x in sb; then consider y being Element of cMGFC
such that
            A50: x = y and
            A51: y in nr1 and
            A52: ord y <= i by A27;
                     ord y <= i+1 by A52,NAT_1:12;
               hence x in sB by A50,A51;
              end;
              suppose x in scb; then consider y being Element of cMGFC
such that
            A53: x = y and
            A54: ord y = i+1 by A43;
                y in nr1 by A4,A42,A54;
               hence x in sB by A53,A54;
            end;
            end;
        then A55: sB = sb \/ scb by TARSKI:2;
             A56: sb misses scb proof assume sb /\ scb <> {};
                then consider x being set such that
            A57: x in sb /\ scb by XBOOLE_0:def 1;
            A58: x in sb & x in scb by A57,XBOOLE_0:def 3;
                then consider y1 being Element of cMGFC such that
            A59: x = y1 and y1 in nr1 and
            A60: ord y1 <= i by A27;
                consider y2 being Element of cMGFC such that
            A61: x = y2 and
            A62: ord y2 = i+1 by A43,A58;
             thus contradiction by A59,A60,A61,A62,NAT_1:13;
            end;
         thus F.(i+1)
            = (poly_with_roots b)*' poly_with_roots(cb) by A6,A25,A32,A33,A45
           .= poly_with_roots (b+cb) by UPROOTS:66
.= poly_with_roots(B) by A55,A56,UPROOTS:12;
     end;
     end;
A63: for i being Element of NAT st 1 <= i & i <= len f holds R[i]
from POLYNOM2:sch 4
(A8,A20);
    reconsider sB = MG(n) as finite Subset of F_Complex by A7;
    set B = (sB,1)-bag;
        now let x be set;
    hereby assume A64: x in nr1;
     then consider y being Element of MultGroup F_Complex such that
    A65: x = y and
    A66: ord y divides n by A4;
             ord y <= n by A66,NAT_D:7;
     hence x in sB by A64,A65;
    end;
    assume x in sB; then ex y being Element of MultGroup F_Complex st
        y = x & y in nr1 & ord y <= n;
    hence x in nr1;
   end;
then A67: nr1 = sB by TARSKI:2;
     consider t being finite Subset of F_Complex such that
A68: t = MG(len f) and
A69: F.len f = poly_with_roots((t,1)-bag) by A1,A3,A63;
A70: f = f|Seg len f by FINSEQ_3:55;   A71: len f in Seg len f by A1,FINSEQ_1:5
;
 thus unital_poly(F_Complex,n) = poly_with_roots(b) by Th50
   .= Product(f) by A1,A6,A67,A68,A69,A70,A71;
end;

theorem Th54:
for n being non empty Element of NAT
 ex f being FinSequence of (the carrier of Polynom-Ring F_Complex),
    p being Polynomial of F_Complex
   st p = Product(f) & dom f = Seg n &
     (for i being non empty Element of NAT st i in Seg n holds
       (not i divides n or i = n implies f.i = <%1_F_Complex%>) &
       (i divides n & i <> n implies f.i = cyclotomic_poly(i)))  &
     unital_poly(F_Complex,n) = (cyclotomic_poly n)*'p
proof let n be non empty Element of NAT;
 set cPRFC = the carrier of Polynom-Ring F_Complex;
A1: 1 <= n by UPROOTS:1;
  defpred P[set,set] means
   ex i being non empty Element of NAT st i = $1 &
      (not i divides n implies $2 = <%1_F_Complex%>) &
      (i divides n implies $2 = cyclotomic_poly(i));
A2: for k being Element of NAT st k in Seg n
ex x being Element of cPRFC st P[k,x]
    proof let k be Element of NAT such that
    A3: k in Seg n;
        reconsider i = k as non empty Element of NAT by A3,FINSEQ_1:3;
     per cases;
     suppose A4: not i divides n;
         reconsider FC1 = <%1_F_Complex%> as Element of cPRFC
            by POLYNOM3:def 12;
       take FC1; take i; thus i = k; thus thesis by A4;
     end;
     suppose A5: i divides n;
         reconsider FC1 = cyclotomic_poly(i) as Element of cPRFC
            by POLYNOM3:def 12;
       take FC1; take i; thus i = k; thus thesis by A5;
    end;
    end;
   consider f being FinSequence of cPRFC such that
A6: dom f = Seg n and
A7: for k being Element of NAT st k in Seg n holds P[k,f/.k]
from POLYNOM2:sch 1(A2);
   consider m being Nat such that
A8: n = m+1 by NAT_1:6;
A9: m in NAT by ORDINAL1:def 13;
A10: len f = n by A6,FINSEQ_1:def 3;
A11: now let i be non empty Element of NAT; assume
   A12: i in dom f; then consider j being non empty Element of NAT such that
   A13: j = i and
   A14: (not j divides n implies f/.i = <%1_F_Complex%>) &
       (j divides n implies f/.i = cyclotomic_poly(j)) by A6,A7;
        1 <= i & i <= n by A6,A12,FINSEQ_1:3;
    hence (not i divides n implies f.i = <%1_F_Complex%>) &
         (i divides n implies f.i = cyclotomic_poly(i))
          by A10,A13,A14,FINSEQ_4:24;
   end;
then A15: unital_poly(F_Complex,n) = Product(f) by A10,Th53;
   reconsider fm = f|Seg m as FinSequence of cPRFC by FINSEQ_1:23;
   reconsider Pfm = Product fm as Polynomial of F_Complex by POLYNOM3:def 12;
   A16: m <= n by A8,NAT_1:13;
then A17: dom fm = Seg m by A10,FINSEQ_1:21;
A18: len fm = m by A10,A16,FINSEQ_1:21;
A19: n in Seg n by A1,FINSEQ_1:3;
then A20: f.n = cyclotomic_poly n by A6,A11;
    reconsider fn = f|Seg n as FinSequence of cPRFC by FINSEQ_1:23;
A21:  f = fn by A10,FINSEQ_2:23
     .= fm^<*cyclotomic_poly n*> by A6,A8,A9,A19,A20,FINSEQ_5:11;
   reconsider FC1 = <%1_F_Complex %> as Element of cPRFC by POLYNOM3:def 12;
        <* FC1 *> is FinSequence of cPRFC;
   then reconsider h = fm^<* <%1_F_Complex %> *> as FinSequence of cPRFC
     by FINSEQ_1:96;
   reconsider p = Product(h) as Polynomial of F_Complex by POLYNOM3:def 12;
   take h, p;
   thus p = Product(h);
          len <* <%1_F_Complex %> *> = 1 by FINSEQ_1:57;
   hence dom h = Seg n by A8,A18,FINSEQ_1:def 7;
   thus for i being non empty Element of NAT st i in Seg n holds
       (not i divides n or i = n implies h.i = <%1_F_Complex%>) &
       (i divides n & i <> n implies h.i = cyclotomic_poly(i)) proof
       let i be non empty Element of NAT; assume
   A22: i in Seg n;
       per cases;
       suppose A23: i in Seg m;
       then A24: fm.i = f.i by FUNCT_1:72;
            A25: i <= m by A23,FINSEQ_1:3;
            h.i = fm.i by A17,A23,FINSEQ_1:def 7;
         hence (not i divides n or i = n implies h.i = <%1_F_Complex%>) &
              (i divides n & i <> n implies h.i = cyclotomic_poly(i))
                          by A6,A8,A11,A22,A24,A25,NAT_1:13;
       end;
       suppose not i in Seg m;
           then not (1 <= i & i <= m) & 1 <= i & i <= n by A22,FINSEQ_1:3;
           then A26: n <= i & i <= n by A8,NAT_1:13;
                1 in Seg 1 by FINSEQ_1:3;
           then 1 in dom <* <%1_F_Complex %> *> by FINSEQ_1:55;
           then h.n = <* <%1_F_Complex %> *>.1 by A8,A18,FINSEQ_1:def 7
              .= <%1_F_Complex%> by FINSEQ_1:57;
         hence not i divides n or i = n implies h.i = <%1_F_Complex%> by A26,
XXREAL_0:1;
         thus i divides n & i <> n implies h.i = cyclotomic_poly(i) by A26,
XXREAL_0:1;
   end;
   end;
   reconsider p1 = <%1_F_Complex %> as Element of cPRFC by POLYNOM3:def 12;
A27: Product(h) = Product(fm) * p1 by GROUP_4:9
             .= Pfm *' <%1_F_Complex %> by POLYNOM3:def 12
             .= Product(fm) by UPROOTS:34;
   reconsider cpn = cyclotomic_poly n as Element of cPRFC by POLYNOM3:def 12;
        Product(f) = Product(fm) * cpn by A21,GROUP_4:9;
  hence unital_poly(F_Complex,n) = (cyclotomic_poly n)*'p
      by A15,A27,POLYNOM3:def 12;
end;

theorem Th55:
for d being non empty Element of NAT, i being Element of NAT
  holds ((cyclotomic_poly d).0 = 1 or (cyclotomic_poly d).0 = -1) &
        (cyclotomic_poly d).i is integer
proof set cFC = the carrier of F_Complex;
  set cPRFC = the carrier of Polynom-Ring F_Complex;
A1: -1_F_Complex = -1 by COMPLFLD:4,10;
  deffunc cp(non empty Element of NAT) = cyclotomic_poly($1);
  defpred P[non empty Element of NAT] means
  (cp($1).0 = 1 or cp($1).0 = -1) & for i being Element of NAT
  holds cp($1).i is integer;
A2: now let k be non empty Element of NAT such that
   A3: for n being non empty Element of NAT st n < k holds P[n];
   A4: 1 <= k by Lm1;
    per cases by A4,REAL_1:def 5;
    suppose A5: k = 1;
             now let i be Element of NAT;
         per cases by Th1;
         suppose i = 0;  hence cp(k).i is integer by A1,A5,Th52,POLYNOM5:39;
         end;
         suppose i = 1;  hence cp(k).i is integer by A5,Th52,COMPLFLD:10
,POLYNOM5:39;
         end;
         suppose i >= 2;
          hence cp(k).i is integer by A5,Th52,COMPLFLD:9,POLYNOM5:39;
        end;
        end;
     hence P[k] by A1,A5,Th52,POLYNOM5:39;
    end;
    suppose A6: k > 1;
       consider f being FinSequence of cPRFC,
                p being Polynomial of F_Complex such that
    A7: p = Product(f) and
    A8: dom f = Seg k and
    A9: for i being non empty Element of NAT st i in Seg k holds
          (not i divides k or i = k implies f.i = <%1_F_Complex%>) &
          (i divides k & i <> k implies f.i = cp(i)) and
    A10: unital_poly(F_Complex,k) = (cyclotomic_poly k)*'p by Th54;
    A11:  k = len f by A8,FINSEQ_1:def 3;
    then A12:  k in Seg len f by FINSEQ_1:5;
        defpred G[Nat,set] means
        ex g being FinSequence of cPRFC, p being Polynomial of F_Complex
         st g = f | Seg $1 & p = Product(g) & $2 = p & (p.0 = 1 or p.0 = -1) &
            for j being Element of NAT holds p.j is integer;
A13: for l being Nat, y1, y2 being set
     st l in Seg len f & G[l,y1] & G[l,y2] holds y1=y2;
    defpred H[Element of NAT] means $1 in Seg len f implies
    ex x being set st G[$1,x];
A14: H[0] by FINSEQ_1:3;
A15: for l being Element of NAT st H[l] holds H[l+1]
proof let l be Element of NAT; assume
    A16: H[l]; assume
    A17: l+1 in Seg len f;
     per cases;
     suppose A18: l = 0;
       reconsider l1 = l+1 as non empty Element of NAT;
       reconsider g = f | Seg (l+1) as FinSequence of cPRFC by FINSEQ_1:23;
       reconsider p = Product(g) as Polynomial of F_Complex by POLYNOM3:def 12;
      take p;      take g;      take p;
      thus g = f | Seg (l+1) & p = Product(g) & p = p;
         reconsider fl1 = f.(l+1) as Element of cPRFC by A8,A11,A17,FINSEQ_2:13
;
              <*>cPRFC = f | Seg 0 by FINSEQ_1:93;
         then g = (<*>cPRFC)^<*f.(l+1)*> by A8,A11,A17,A18,FINSEQ_5:11
          .= <*f.(l+1)*> by FINSEQ_1:47;
     then A19: p = fl1 by FINSOP_1:12;
              1 divides k & 1 <> k by A6,NAT_D:6;
     then A20: f.1 = cp(1) by A9,A11,A17,A18;
      hence (p.0 = 1 or p.0 = -1) by A1,A18,A19,Th52,POLYNOM5:39;
      let j be Element of NAT;
      thus p.j is integer proof
       per cases by Th1;
       suppose j = 0;
        hence thesis by A1,A18,A19,A20,Th52,POLYNOM5:39;
       end;
       suppose j = 1;
        hence thesis by A18,A19,A20,Th52,COMPLFLD:10,POLYNOM5:39
;
       end;
       suppose j >= 2;
        hence thesis by A18,A19,A20,Th52,COMPLFLD:9,POLYNOM5:39;
      end;
      end;
     end;
     suppose 0 < l;
     then A21: 0+1 <= l by NAT_1:13;
     A22: l+1 <= len f by A17,FINSEQ_1:3;
              l <= l+1 by NAT_1:12; then l <= len f by A22,XXREAL_0:2;
         then consider x being set such that
     A23: G[l,x] by A16,A21,FINSEQ_1:3;
         consider g being FinSequence of cPRFC,
                  p being Polynomial of F_Complex such that
     A24: g = f | Seg l and
     A25: p = Product(g) and x = p and
     A26: (p.0 = 1 or p.0 = -1) and
     A27: for j being Element of NAT holds p.j is integer by A23;
         reconsider g1 = f | Seg (l+1) as FinSequence of cPRFC by FINSEQ_1:23;
         reconsider p1 = Product(g1) as Polynomial of F_Complex
                      by POLYNOM3:def 12;
      take p1;      take g1;      take p1;
      thus g1 = f | Seg (l+1) & p1 = Product(g1) & p1 = p1;
           reconsider fl1 = f.(l+1) as Element of cPRFC by A8,A11,A17,
FINSEQ_2:13;
           reconsider fl1p = fl1 as Polynomial of F_Complex
                      by POLYNOM3:def 12;
                g1 = g^<*fl1*> by A8,A11,A17,A24,FINSEQ_5:11;
           then Product g1 = (Product g) * fl1 by GROUP_4:9;
      then A28:  p1 = p *' fl1p by A25,POLYNOM3:def 12;
           reconsider m1 = -1 as Element of COMPLEX by XCMPLX_0:def 2;
      thus thesis proof
       per cases;
       suppose not (l+1) divides k or (l+1) = k;
       then A29: fl1p = <%1_F_Complex%> by A9,A11,A17;
           consider r be FinSequence of F_Complex such that
       A30: len r = 0+1 and
       A31: p1.0 = Sum r and
       A32: for m be Element of NAT st m in dom r
       holds r.m = p.(m-'1) * fl1p.(0+1-'m)
               by A28,POLYNOM3:def 11;
                1 in dom r by A30,FINSEQ_3:27;
           then reconsider r1 = r.1 as Element of F_Complex by FINSEQ_2:13;
                r = <*r1*> by A30,FINSEQ_1:57;
       then A33: p1.0 = r1 by A31,RLVECT_1:61;
                1 in dom r by A30,FINSEQ_3:27;
       then A34: p1.0 = p.(1-'1) * fl1p.(0+1-'1) by A32,A33
             .= p.(0+1-'1) * fl1p.(0) by BINARITH:39
             .= p.0 * fl1p.(0) by BINARITH:39
             .= p.0 * 1_F_Complex by A29,POLYNOM5:33;
           thus (p1.0 = 1 or p1.0 = -1) proof
            per cases by A26;
             suppose p.0 = 1;
              hence thesis by A34,COMPLFLD:10;
             end;
             suppose p.0 = -1;
              hence thesis by A34,COMPLFLD:10;
            end;
            end;
        let j be Element of NAT;
           consider r be FinSequence of F_Complex such that
                len r = j+1 and
       A35: p1.j = Sum r and
       A36: for m be Element of NAT st m in dom r
       holds r.m = p.(m-'1) * fl1p.(j+1-'m)
               by A28,POLYNOM3:def 11;
               for i being Element of NAT st i in dom r holds r.i is integer
              proof
             let i be Element of NAT; assume
           A37: i in dom r;
                 reconsider pi1 = p.(i-'1) as Integer by A27;
                 set j1i = j+1-'i;
                      now j1i = 0 or j1i > 0;
                 then A38: j1i = 0 or j1i >= 0+1 by NAT_1:13;
                   per cases by A38;
                   case j1i = 0;
                    hence fl1p.j1i = 1 by A29,COMPLFLD:10,POLYNOM5:33;
                   end;
                   case j1i >= 1;
                    hence fl1p.j1i = 0 by A29,COMPLFLD:9,POLYNOM5:33;
                 end;
                 end;
                 then reconsider fl1pj1i = fl1p.(j+1-'i) as Integer;
                 reconsider pi1c = pi1, fl1pj1ic = fl1pj1i
                   as Element of COMPLEX by XCMPLX_0:def 2;
                    r.i = p.(i-'1) * fl1p.(j+1-'i) by A36,A37
                  .= pi1 * fl1pj1i;
             hence r.i is integer;
           end;
         hence thesis by A35,Th5;
       end;
       suppose A39: (l+1) divides k & (l+1) <> k;
       then A40: fl1p = cp(l+1) by A9,A11,A17;
        l+1 <= k by A39,NAT_D:7;
       then A41: l+1 < k by A39,REAL_1:def 5;
           consider r be FinSequence of F_Complex such that
       A42: len r = 0+1 and
       A43: p1.0 = Sum r and
       A44: for m be Element of NAT st m in dom r
       holds r.m = p.(m-'1) * fl1p.(0+1-'m)
               by A28,POLYNOM3:def 11;
                1 in dom r by A42,FINSEQ_3:27;
           then reconsider r1 = r.1 as
               Element of F_Complex by FINSEQ_2:13;
           reconsider fl1p0 = fl1p.0 as Integer by A3,A40,A41;
                r = <*r1*> by A42,FINSEQ_1:57;
       then A45: p1.0 = r1 by A43,RLVECT_1:61;
                1 in dom r by A42,FINSEQ_3:27;
       then A46: p1.0 = p.(1-'1) * fl1p.(0+1-'1) by A44,A45
             .= p.(0+1-'1) * fl1p.0 by BINARITH:39
             .= p.0 * fl1p.0 by BINARITH:39;
       A47: fl1p0 = 1 or fl1p0 = m1 by A3,A40,A41;
           thus (p1.0 = 1 or p1.0 = -1) proof
            per cases by A26;
             suppose p.0 = 1;
              hence thesis by A3,A40,A41,A46;
             end;
             suppose p.0 = -1;
              hence thesis by A46,A47;
            end;
            end;
        let j be Element of NAT;
           consider r be FinSequence of F_Complex such that
                len r = j+1 and
       A48: p1.j = Sum r and
       A49: for m be Element of NAT st m in dom r
       holds r.m = p.(m-'1) * fl1p.(j+1-'m)
               by A28,POLYNOM3:def 11;
               for i being Element of NAT st i in dom r holds r.i is integer
              proof
             let i be Element of NAT; assume
           A50: i in dom r;
                 reconsider pi1 = p.(i-'1) as Integer by A27;
                 set j1i = j+1-'i;
                 reconsider fl1pj1i = fl1p.(j+1-'i) as Integer by A3,A40,A41;
                 reconsider pi1c = pi1, fl1pj1ic = fl1pj1i
                   as Element of COMPLEX by XCMPLX_0:def 2;
                    r.i = p.(i-'1) * fl1p.(j+1-'i) by A49,A50
                  .= pi1 * fl1pj1i;
             hence r.i is integer;
           end;
         hence thesis by A48,Th5;
      end;
      end;
    end;
    end;
         for l being Element of NAT holds H[l] from NAT_1:sch 1(A14,A15);
then A51: for l being Nat st l in Seg len f
ex x being set st G[l,x] by ORDINAL1:def 13;
        consider F being FinSequence such that
             dom F = Seg len f and
    A52: for i being Nat st i in Seg len f holds G[i,F.i]
    from FINSEQ_1:sch 1
(A13,A51);
        consider g being FinSequence of cPRFC,
                 p1 being Polynomial of F_Complex such that
    A53: g = f | Seg k & p1 = Product(g) & F.k = p1 and
    A54: (p1.0 = 1 or p1.0 = -1) & for j being Element of NAT
    holds p1.j is integer
           by A12,A52;
    A55: p = p1 by A7,A11,A53,FINSEQ_3:55;
        consider r be FinSequence of cFC such that
    A56: len r = 0+1 and
    A57: unital_poly(F_Complex,k).0 = Sum r and
    A58: for l be Element of NAT st l in dom r
    holds r.l = p.(l-'1) * (cp(k).(0+1-'l))
          by A10,POLYNOM3:def 11;
    A59: 0+1-'1 = 0 by BINARITH:39;
    A60: 1 in dom r by A56,FINSEQ_3:27;
        then reconsider r1 = r.1 as Element of cFC by FINSEQ_2:13;
             r = <*r1*> by A56,FINSEQ_1:57;
        then A61: Sum r = r.1 by RLVECT_1:61
             .= p.0 * (cp(k).0) by A58,A59,A60;
    A62: cp(k).0 = 1 or cp(k).0 = -1 proof
         per cases by A7,A11,A53,A54,FINSEQ_3:55;
         suppose p.0 = 1;
          hence thesis by A1,A57,A61,Th42;
         end;
         suppose p.0 = -1;
             then -1_F_Complex = (-1_F_Complex) * cp(k).0 by A1,A57,A61,Th42
          .= -1_F_Complex * cp(k).0 by VECTSP_1:41
          .= - cp(k).0 by VECTSP_1:def 19;
          hence thesis by COMPLFLD:10,RLVECT_1:31;
        end;
        end;
        defpred C[Nat] means cp(k).$1 is integer;
     A63: now let m be Nat; assume
       A64: for n being Nat st n < m holds C[n];
       reconsider m1 = m as Element of NAT by ORDINAL1:def 13;
           consider r be FinSequence of cFC such that
       A65: len r = m+1 and
       A66: unital_poly(F_Complex,k).m = Sum r and
       A67: for l be Element of NAT st l in dom r
       holds r.l = p.(l-'1) * (cp(k).(m1+1-'l))
               by A10,POLYNOM3:def 11;
       A68: 1 <= len r by A65,NAT_1:11;
       then A69: (1,1)-cut r ^ (1+1,len r)-cut r = r by GRAPH_2:9;
       A70: 1 in dom r by A68,FINSEQ_3:27;
           then reconsider r1 = r.1 as Element of cFC by FINSEQ_2:13;
           reconsider r1c = r1 as Element of COMPLEX by COMPLFLD:def 1;
       A71: (1,1)-cut r = <*r1*> by A68,GRAPH_2:6;
           set s = (1+1,len r)-cut r;
       A72: Sum r = r1 + Sum s by A69,A71,FVSUM_1:89;
           reconsider Src = Sum r as Element of COMPLEX by COMPLFLD:def 1;
            now
            per cases;
            suppose m1 = 0;
             hence Src is integer by A1,A66,Th42;
            end;
            suppose m1 = k;
             hence Src is integer by A66,Th42,COMPLFLD:10;
            end;
            suppose m1 <> 0 & m1 <> k;
             hence Src is integer by A66,Th43,COMPLFLD:9;
           end;
           end;
           then reconsider Sr = Src as Integer;
           reconsider Ssc = Sum s as Element of COMPLEX by COMPLFLD:def 1;
            now let i be Element of NAT; assume
           A73: i in dom s;
           per cases;
           suppose len r < 2;
            then s = {} by GRAPH_2:def 1;
              then 1 <= i & i <= 0 by A73,CARD_1:47,FINSEQ_3:27;
             hence s.i is integer;
           end;
           suppose
           A74: 1+1 <= len r;
               then A75: len s +(1+1) = len r + 1 by GRAPH_2:def 1;
            per cases;
            suppose m = 0;
             hence s.i is integer by A65,A74;
            end;
            suppose A76: m > 0;
            A77: 1 <= i & i <= len s by A73,FINSEQ_3:27;
             i <> 0 by A73,FINSEQ_3:27;
            then consider i1 being Nat such that
            A78: i = i1+1 by NAT_1:6;
             i1 < len s by A77,A78,NAT_1:13;
            then A79: s.i = r.(1+1+i1) by A74,A78,GRAPH_2:def 1
                   .= r.(1+i) by A78;
                     i <> 0 & m <> 0 by A73,A76,FINSEQ_3:27;
                then m-'i < m by NAT_2:11;
                then reconsider cpkmi = cp(k).(m-'i) as Integer by A64;
                reconsider ppi = p.i as Integer by A54,A55;
                reconsider cpkmic = cp(k).(m-'i), ppic = p.i
                   as Element of COMPLEX  by COMPLFLD:def 1;
                reconsider ppi = p.i as Integer by A54,A55;
                     1 <= i+1 & i+1 <= len s +1 by A77,NAT_1:11,XREAL_1:8;
                then 1+i in dom r by A75,FINSEQ_3:27;
                then r.(1+i) = p.(1+i-'1) * cp(k).(m+1-'(1+i)) by A67
                       .= p.(i+1-'1) * cp(k).(m+1-'1-'i) by POLYNOM1:3
                       .= p.i * cp(k).(m+1-'1-'i) by BINARITH:39
                       .= ppi *cpkmi by BINARITH:39;
             hence s.i is integer by A79;
           end;
           end;
           end;
           then reconsider Ss = Ssc as Integer by Th5;  r1c = Sr -Ss by A72;
           then reconsider r1i = r1 as Integer;
       A80: r1i = p.(1-'1) * cp(k).(m+1-'1) by A67,A70
              .= p.0 * cp(k).m1 by A59,BINARITH:39;
         per cases by A7,A11,A53,A54,FINSEQ_3:55;
         suppose p.0 = 1;
          hence C[m] by A80;
         end;
         suppose p.0 = -1;
             then r1 = (-1_F_Complex) * cp(k).m1 by A80,COMPLFLD:4,10
          .= -1_F_Complex * cp(k).m1 by VECTSP_1:41
          .= - cp(k).m1 by VECTSP_1:def 19;
           then 0.F_Complex = - cp(k).m1 + - r1 by RLVECT_1:def 10
            .= -r1 - cp(k).m1;
          then - r1 = cp(k).m by VECTSP_1:66; then - r1i = cp(k).m by
COMPLFLD:4;
          hence C[m];
         end;
         end;
         for i being Nat holds C[i] from NAT_1:sch 4(A63);
     hence P[k] by A62;
   end;
   end;
      for d being non empty Element of NAT holds P[d] from CompIndNE(A2);
 hence thesis;
end;

theorem Th56:  :: WEDDWITT
for d being non empty Element of NAT, z being Element of F_Complex
 st z is Integer holds eval(cyclotomic_poly(d),z) is Integer
proof let d be non empty Element of NAT,z be Element of F_Complex such that
A1: z is Integer;     set phi = cyclotomic_poly(d);
    consider F being FinSequence of F_Complex such that
A2: eval(phi,z) = Sum F and len F = len phi and
A3: for i being Element of NAT st i in dom F holds
      F.i = phi.(i-'1) * (power F_Complex).(z,i-'1) by POLYNOM4:def 2;
         for i being Element of NAT st i in dom F holds F.i is Integer
    proof let i be Element of NAT such that A4: i in dom F;
        reconsider i1 = phi.(i-'1) as Integer by Th55;
        reconsider i2 = (power F_Complex).(z,i-'1) as Integer by A1,Th15;
             F.i = phi.(i-'1) * (power F_Complex).(z,i-'1) by A3,A4;
        then F.i = i1*i2;
      hence thesis;
    end;
  hence thesis by A2,Th16;
end;

theorem Th57:
for n, ni being non empty Element of NAT,
    f being FinSequence of (the carrier of Polynom-Ring F_Complex),
    s being finite Subset of F_Complex
 st s = {y where y is Element of MultGroup F_Complex :
              ord y divides n & not ord y divides ni & ord y <> n} &
  dom f = Seg n &
  for i being non empty Element of NAT st i in dom f holds
   (not i divides n or i divides ni or i = n implies f.i = <%1_F_Complex%>) &
   (i divides n & not i divides ni & i <> n implies f.i = cyclotomic_poly(i))
 holds Product(f) = poly_with_roots((s,1)-bag)
proof let n, ni be non empty Element of NAT;
  set cPRFC = the carrier of Polynom-Ring F_Complex;
  set cMGFC = the carrier of MultGroup F_Complex;
      let f be FinSequence of cPRFC, s be finite Subset of F_Complex such that
A1: s = {y where y is Element of cMGFC:
              ord y divides n & not ord y divides ni & ord y <> n} and
A2: dom f = Seg n and
A3: for i being non empty Element of NAT st i in dom f holds
   (not i divides n or i divides ni or i = n implies f.i = <%1_F_Complex%>) &
   (i divides n & not i divides ni & i <> n implies f.i = cyclotomic_poly(i));
A4: len f = n by A2,FINSEQ_1:def 3;
A5: 0+1 <= n by NAT_1:13;
   set b = (s,1)-bag;
   defpred P[Nat,set] means
   for fi being FinSequence of cPRFC st fi = f|Seg $1 holds $2 = Product(fi);
A6: now let i being Nat; assume i in Seg len f;
        set fi = f|Seg i;
        reconsider fi = f|Seg i as FinSequence of cPRFC by FINSEQ_1:23;
        set x = Product fi;   take x;   thus P[i,x];
    end;
   consider F being FinSequence of cPRFC such that
         dom F = Seg len f and
A7: for i being Nat st i in Seg len f holds P[i,F.i]
from FINSEQ_1:sch 5(A6);
   deffunc MG(Nat)
    = {y where y is Element of cMGFC : y in s & ord y <= $1 };
A8: now let i be Element of NAT;
       MG(i) c= s proof let x be set; assume x in MG(i);
         then ex y being Element of cMGFC st x = y & y in s & ord y <= i;
        hence x in s;
       end;
    hence MG(i) is finite Subset of F_Complex by FINSET_1:13,XBOOLE_1:1;
   end;
   defpred R[Element of NAT] means
   ex t being finite Subset of F_Complex
    st t = MG($1) & F.$1 = poly_with_roots((t,1)-bag);
A9: R[1] proof
         reconsider t = MG(1) as finite Subset of F_Complex by A8;
     take t;
     thus t = MG(1);
    A10: 1 in Seg len f by A4,A5,FINSEQ_1:3;
    A11: 1 in dom f by A4,A5,FINSEQ_3:27;
        reconsider f1 = f|Seg 1 as  FinSequence of cPRFC by FINSEQ_1:23;
    A12: f1 = <*f.1*> by A4,A5,Th2;
             1 in dom f by A10,FINSEQ_1:def 3;
        then reconsider fd1 = f.1 as Element of cPRFC by FINSEQ_2:13;
    A13: 1 divides ni by NAT_D:6;
             now assume t is non empty; then consider x being set such
that
        A14: x in t by XBOOLE_0:def 1;
            consider y being Element of cMGFC such that x = y and
        A15: y in s and
        A16: ord y <= 1 by A14;
            consider y1 being Element of cMGFC such that
        A17: y = y1 and
        A18: ord y1 divides n & not ord y1 divides ni & ord y1 <> n by A1,A15;
                 now assume ord y1 = 0;
                then consider u being Nat such that
            A19: n = 0 * u by A18,NAT_D:def 3;
              thus contradiction by A19;
            end; then 0 < ord y1;
            then 0+1 <= ord y1 by NAT_1:13;
         hence contradiction by A13,A16,A17,A18,XXREAL_0:1;
        end;
        then A20: (t,1)-bag = EmptyBag the carrier of F_Complex by UPROOTS:11;
              F.1 = Product <*fd1*> by A7,A10,A12 .= fd1 by FINSOP_1:12
           .= <%1_F_Complex%> by A3,A11,A13;
     hence thesis by A20,UPROOTS:62;
    end;
A21: for i being Element of NAT st 1 <= i & i < len f
holds R[i] implies R[i+1]
proof
     let i be Element of NAT such that
    A22: 1 <= i & i < len f and
    A23: R[i];
    A24: i in Seg len f by A22,FINSEQ_1:3;
    A25: 1 <= i+1 & i+1 <= len f by A22,NAT_1:13;
    then A26: i+1 in Seg len f by FINSEQ_1:3;
    then A27: i+1 in dom f by FINSEQ_1:def 3;
        reconsider fi = f|Seg i as
         FinSequence of (the carrier of Polynom-Ring F_Complex) by FINSEQ_1:23;
    A28: F.i = Product fi by A7,A24;
        reconsider fi1 = f|Seg (i+1) as
         FinSequence of (the carrier of Polynom-Ring F_Complex) by FINSEQ_1:23;
    A29: F.(i+1) = Product fi1 by A7,A26;
             i <= i+1 by NAT_1:12;
    then A30: fi = fi1 | Seg i by Lm2;
             i+1 = min(i+1,len f) by A25,XXREAL_0:def 8;
    then A31: len fi1 = i+1 by FINSEQ_2:24;
              i+1 in Seg (i+1) by FINSEQ_1:6;
    then A32: (f|Seg (i+1)).(i+1) = f.(i+1) by FUNCT_1:72;
        then reconsider fi1d1 = fi1.(i+1) as
        Element of (the carrier of Polynom-Ring F_Complex) by A27,FINSEQ_2:13;
      reconsider fi1d1p = fi1d1 as Polynomial of F_Complex by POLYNOM3:def 12;
             fi1 = fi ^ <* fi1d1 *> by A30,A31,FINSEQ_3:61;
    then A33: Product fi1 = Product fi * fi1d1 by GROUP_4:9;
        consider sb being finite Subset of F_Complex such that
    A34: sb = MG(i) and
    A35: F.i = poly_with_roots((sb,1)-bag) by A23;
        set b = (sb, 1)-bag;
    A36: Product fi1=(poly_with_roots b)*' fi1d1p by A28,A33,A35,
POLYNOM3:def 12;
      reconsider sB = MG(i+1) as finite Subset of F_Complex by A8;
      take sB;   thus sB = MG(i+1);
      set B = (sB, 1)-bag;
    per cases;
        suppose A37: not (i+1) divides n or (i+1) divides ni or i+1 = n;
            A38: now let x be set;
             hereby assume x in sB; then consider y being
               Element of MultGroup F_Complex such that
             A39: x = y and
             A40: y in s and
             A41: ord y <= i+1;
                     ex y1 being Element of cMGFC st y = y1 & ord y1 divides
n
                       & not ord y1 divides ni & ord y1 <> n by A1,A40;
   then ord y < i+1 by A37,A41,REAL_1:def 5;
                then ord y <= i by NAT_1:13;
              hence x in sb by A34,A39,A40;
             end;
             assume x in sb; then consider y being
                 Element of MultGroup F_Complex such that
             A42: x = y and
             A43: y in s and
             A44: ord y <= i by A34;       ord y <= i+1 by A44,NAT_1:12;
             hence x in sB by A42,A43;
            end;
                 f.(i+1) = <%1_F_Complex%> by A3,A27,A37;
            then F.(i+1) = (poly_with_roots b) by A29,A32,A36,UPROOTS:34
                   .= poly_with_roots(B) by A38,TARSKI:2;
            hence thesis;
        end;
        suppose A45: (i+1) divides n & not (i+1) divides ni & (i+1) <> n;
        consider scb being non empty finite Subset of F_Complex such that
        A46: scb = { y where y is Element of cMGFC : ord y = i+1 } and
        A47: cyclotomic_poly(i+1) = poly_with_roots((scb,1)-bag) by Def5;
             set cb = (scb,1)-bag;
        A48: f.(i+1) = poly_with_roots(cb) by A3,A27,A45,A47;
                 now let x be set;
              hereby assume x in sB;
                then consider y being Element of cMGFC such that
            A49: x = y and A50: y in s and A51: ord y <= i+1;
                     ord y <= i or ord y = i+1 by A51,NAT_1:8;
                then y in sb or y in scb by A34,A46,A50;
               hence x in sb \/ scb by A49,XBOOLE_0:def 2;
              end;
              assume A52: x in sb \/ scb;
              per cases by A52,XBOOLE_0:def 2;
              suppose x in sb; then consider y being Element of cMGFC
such that
            A53: x = y and A54: y in s and A55: ord y <= i by A34;
                     ord y <= i+1 by A55,NAT_1:12;
               hence x in sB by A53,A54;
              end;
              suppose x in scb; then consider y being Element of cMGFC
such that
            A56: x = y and A57: ord y = i+1 by A46;      y in s by A1,A45,A57;
               hence x in sB by A56,A57;
            end;
            end;
        then A58: sB = sb \/ scb by TARSKI:2;
            A59: sb misses scb proof assume sb /\ scb <> {};
                then consider x being set such that
            A60: x in sb /\ scb by XBOOLE_0:def 1;
            A61: x in sb & x in scb by A60,XBOOLE_0:def 3;
                then consider y1 being Element of cMGFC such that
            A62: x = y1 and y1 in s and
            A63: ord y1 <= i by A34;
                consider y2 being Element of cMGFC such that
            A64: x = y2 and
            A65: ord y2 = i+1 by A46,A61;
             thus contradiction by A62,A63,A64,A65,NAT_1:13;
            end;
               F.(i+1)
            = (poly_with_roots b)*' poly_with_roots(cb) by A7,A26,A32,A36,A48
           .= poly_with_roots (b+cb) by UPROOTS:66
           .= poly_with_roots(B) by A58,A59,UPROOTS:12;
         hence thesis;
     end;
     end;
A66: for i being Element of NAT st 1 <= i & i <= len f holds R[i]
from POLYNOM2:sch 4
(A9,A21);
   reconsider sB = MG(n) as finite Subset of F_Complex by A8;
   set B = (sB,1)-bag;
        now let x be set;
    hereby assume A67: x in s;
       then consider y being Element of MultGroup F_Complex such that
    A68: x = y and
    A69: ord y divides n and not ord y divides ni & ord y <> n by A1;
             ord y <= n by A69,NAT_D:7;
     hence x in sB by A67,A68;
    end;
    assume x in sB;
      then ex y being Element of MultGroup F_Complex st
           y = x & y in s & ord y <= n;
    hence x in s;
   end;
then A70: s = sB by TARSKI:2;
A71: f = f|Seg len f by FINSEQ_3:55;
   consider S being finite Subset of F_Complex such that
A72: S = MG(len f) and
A73: F.len f = poly_with_roots((S,1)-bag) by A4,A5,A66;
        len f in Seg len f by A4,FINSEQ_1:5;
 hence thesis by A4,A7,A70,A71,A72,A73;
end;

theorem Th58:
for n, ni being non empty Element of NAT st ni < n & ni divides n
ex f being FinSequence of (the carrier of Polynom-Ring F_Complex),
    p being Polynomial of F_Complex
 st p = Product(f) & dom f = Seg n &
  (for i being non empty Element of NAT st i in Seg n holds
   (not i divides n or i divides ni or i = n implies f.i = <%1_F_Complex%>) &
   (i divides n & not i divides ni & i <> n implies f.i = cyclotomic_poly(i)))
 & unital_poly(F_Complex,n) = unital_poly(F_Complex,ni)*'(cyclotomic_poly n)*'p
proof let n, ni being non empty Element of NAT such that
A1: ni < n and
A2: ni divides n;
   set cPRFC = the carrier of Polynom-Ring F_Complex;
   set cMGFC = the carrier of MultGroup F_Complex;
   defpred P[set,set] means
   ex d being non empty Nat st $1 = d &
   (not d divides n or d divides ni or d = n implies $2 = <%1_F_Complex%>) &
   (d divides n & not d divides ni & d <> n implies $2 = cyclotomic_poly(d));
A3: now let i be Nat; assume A4: i in Seg n;
    then A5: i is non empty by FINSEQ_1:3;
     per cases;
     suppose A6: not i divides n or i divides ni or i = n;
            <%1_F_Complex%> is Element of cPRFC by POLYNOM3:def 12;
      hence ex x being Element of cPRFC st P[i,x] by A5,A6;
     end;
     suppose A7: i divides n & not i divides ni & i <> n;
      reconsider i' = i as non empty Element of NAT by A4,FINSEQ_1:3;
           cyclotomic_poly(i')
      is Element of cPRFC by POLYNOM3:def 12;
      hence ex x being Element of cPRFC st P[i,x] by A7;
    end;
    end;
   consider f being FinSequence of cPRFC such that
   A8: dom f = Seg n and
A9: for i being Nat st i in Seg n holds P[i,f.i]
from FINSEQ_1:sch 5(A3);
A10: now let i be non empty Element of NAT; assume i in Seg n;
        then ex d being non empty Nat st i = d &
 (not d divides n or d divides ni or d = n implies f.i = <%1_F_Complex%>) &
 (d divides n & not d divides ni & d<>n implies f.i = cyclotomic_poly(d)) by A9
;
     hence (not i divides n or i divides ni or i = n
        implies f.i = <%1_F_Complex%>) &
         (i divides n & not i divides ni & i <> n
           implies f.i = cyclotomic_poly(i));
    end;
   take f;
   set rbp = {y where y is Element of cMGFC:
              ord y divides n & not ord y divides ni & ord y <> n};
A11: rbp c= n-roots_of_1 proof let x be set; assume x in rbp;
      then ex y being Element of cMGFC st
       x = y & ord y divides n & not ord y divides ni & ord y <> n;
     hence x in n-roots_of_1 by Th37;
    end;
A12: ni-roots_of_1 c= n-roots_of_1 by A2,Th31;
A13: n-roots_of_1 c= cMGFC by Th35;
   reconsider rbp as finite Subset of F_Complex by A11,FINSET_1:13,XBOOLE_1:1;
   set bp = (rbp,1)-bag;
     Product(f) = poly_with_roots(bp) by A8,A10,Th57;
   then reconsider p = Product(f) as Polynomial of F_Complex;
   take p;
   thus p = Product(f);
   thus dom f = Seg n by A8;
   thus for i being non empty Element of NAT st i in Seg n holds
         (not i divides n or i divides ni or i = n
           implies f.i = <%1_F_Complex%>) &
         (i divides n & not i divides ni & i <> n
           implies f.i = cyclotomic_poly(i)) by A10;
   set b = (n-roots_of_1, 1)-bag, bi = (ni-roots_of_1, 1)-bag;
   consider rbn being non empty finite Subset of F_Complex such that
A14: rbn = {y where y is Element of cMGFC: ord y = n } and
A15: cyclotomic_poly(n) = poly_with_roots((rbn,1)-bag) by Def5;
   set bn = (rbn,1)-bag;
   set rbibn = (ni-roots_of_1) \/ rbn;
    reconsider rbibn as finite Subset of F_Complex;
    set bibn = (rbibn, 1)-bag;
         ni-roots_of_1 misses rbn proof assume ni-roots_of_1 /\ rbn <>
{};
        then consider x being set such that
    A16: x in ni-roots_of_1 /\ rbn by XBOOLE_0:def 1;
    A17: x in ni-roots_of_1 & x in rbn by A16,XBOOLE_0:def 3;
        then consider y being Element of cMGFC such that
    A18: x = y and
    A19: ord y divides ni by Th39;
        consider y1 being Element of cMGFC such that
    A20: x = y1 and
    A21: ord y1 = n by A14,A17;
      thus contradiction by A1,A18,A19,A20,A21,NAT_D:7;
    end;
then A22: bi + bn = (ni-roots_of_1 \/ rbn, 1)-bag by UPROOTS:12;
A23: unital_poly(F_Complex,ni) = poly_with_roots(bi) by Th50;
        now let x be set;
     hereby assume A24: x in n-roots_of_1;
       then reconsider y = x as Element of cMGFC by A13;
     A25: ord y divides n by A24,Th37;
      per cases;
      suppose ord y = n;
        then y in rbn by A14; then y in rbibn by XBOOLE_0:def 2;
       hence x in rbibn \/ rbp by XBOOLE_0:def 2;
      end;
      suppose ord y <> n & not ord y divides ni; then y in rbp by A25
;
       hence x in rbibn \/ rbp by XBOOLE_0:def 2;
      end;
      suppose ord y <> n & ord y divides ni;
         then x in ni-roots_of_1 by Th37;
         then x in rbibn by XBOOLE_0:def 2;
       hence x in rbibn \/ rbp by XBOOLE_0:def 2;
     end;
     end;
     assume x in rbibn \/ rbp;
       then A26: x in rbibn or x in rbp by XBOOLE_0:def 2;
      per cases by A26,XBOOLE_0:def 2;
      suppose x in ni-roots_of_1;
       hence x in n-roots_of_1 by A12;
      end;
      suppose x in rbn;
        then consider y being Element of cMGFC such that
      A27: x = y & ord y = n by A14;
       thus x in n-roots_of_1 by A27,Th37;
      end;
      suppose x in rbp;
         then consider y being Element of cMGFC such that
       A28: x = y & ord y divides n & not ord y divides ni & ord y <> n;
       thus x in n-roots_of_1 by A28,Th37;
   end;
   end;
then A29: n-roots_of_1 = rbibn \/ rbp by TARSKI:2;
        rbibn misses rbp proof assume rbibn /\ rbp <> {};
      then consider x being set such that
   A30: x in rbibn /\ rbp by XBOOLE_0:def 1;
       A31: x in rbibn & x in rbp by A30,XBOOLE_0:def 3;
       then consider y being Element of cMGFC such that
   A32: x = y and
   A33: ord y divides n & not ord y divides ni & ord y <> n;
       per cases by A31,XBOOLE_0:def 2;
       suppose x in ni-roots_of_1;
          then ex y being Element of cMGFC st x = y & ord y divides ni by Th39
;
        hence contradiction by A32,A33;
       end;
       suppose x in rbn;
          then ex y being Element of cMGFC st x = y & ord y = n by A14;
        hence contradiction by A32,A33;
    end;
    end;
then A34: b = bibn+bp by A29,UPROOTS:12;
        unital_poly(F_Complex,n) = poly_with_roots(b) by Th50
    .= (poly_with_roots bibn) *' poly_with_roots(bp) by A34,UPROOTS:66
    .= unital_poly(F_Complex,ni)*'(cyclotomic_poly n)*'poly_with_roots(bp)
       by A15,A22,A23,UPROOTS:66;
 hence thesis by A8,A10,Th57;
end;

theorem Th59:
for i being Integer, c being Element of F_Complex,
    f being FinSequence of (the carrier of Polynom-Ring F_Complex),
    p being Polynomial of F_Complex
 st p = Product(f) & c = i &
    for i being non empty Element of NAT st i in dom f
     holds f.i = <%1_F_Complex%> or f.i = cyclotomic_poly(i)
  holds eval(p,c) is integer
proof let i be Integer, c be Element of F_Complex,
      f being FinSequence of (the carrier of Polynom-Ring F_Complex),
      p being Polynomial of F_Complex such that
A1: p = Product(f) and
A2: c = i and
A3: for i being non empty Element of NAT st i in dom f
     holds f.i = <%1_F_Complex%> or f.i = cyclotomic_poly(i);
A4: eval(1_.F_Complex,c)
      = 1 by COMPLFLD:10,POLYNOM4:21;
A5: 1_.(F_Complex) = 1_F_Complex * 1_.(F_Complex) by POLYNOM5:28
                      .= <%1_F_Complex%> by POLYNOM5:30;
  per cases;
  suppose len f = 0; then f = <*>(the carrier of Polynom-Ring
F_Complex) by FINSEQ_1:32;
       then p = 1_Polynom-Ring F_Complex by A1,GROUP_4:11
       .= 1.Polynom-Ring F_Complex;
     hence eval(p,c) is integer by A4,POLYNOM3:def 12;
  end;
  suppose A6: 0 < len f;
then A7: 0+1 <= len f by NAT_1:13;
   defpred P[Nat,set] means
   for fi being FinSequence of (the carrier of Polynom-Ring F_Complex)
      st fi = f|Seg $1 holds $2 = Product(fi);
   A8: now let i be Nat; assume i in Seg len f;
        set fi = f|Seg i;
        reconsider fi = f|Seg i as FinSequence of
           (the carrier of Polynom-Ring F_Complex) by FINSEQ_1:23;
        set x = Product fi;   take x;   thus P[i,x];
       end;
   consider F being FinSequence of (the carrier of Polynom-Ring F_Complex)
   such that dom F = Seg len f and
A9: for i being Nat st i in Seg len f holds P[i,F.i]
from FINSEQ_1:sch 5(A8);
A10: 1 in Seg len f by A7,FINSEQ_1:3;
A11: len f in Seg len f by A6,FINSEQ_1:5;
   defpred R[Element of NAT] means
   ex r being Polynomial of F_Complex st r = F.$1 & eval(r,c) is integer;
A12: R[1] proof
      reconsider f1 = f | Seg 1 as
        FinSequence of (the carrier of Polynom-Ring F_Complex) by FINSEQ_1:23;
    A13: f1 = <*f.1*> by A7,Th2;
    A14: 1 in dom f by A10,FINSEQ_1:def 3;
        then reconsider fd1 = f.1 as
           Element of (the carrier of Polynom-Ring F_Complex) by FINSEQ_2:13;
      reconsider fd1 as Polynomial of F_Complex by POLYNOM3:def 12;
      take fd1;
      thus fd1 = Product f1 by A13,FINSOP_1:12 .= F.1 by A9,A10;
      per cases by A3,A14;
      suppose f.1 = <%1_F_Complex%>;
       hence eval(fd1,c) is integer by A5,COMPLFLD:10,POLYNOM4:21;
      end;
      suppose f.1 = cyclotomic_poly(1);
       hence eval(fd1,c) is integer by A2,Th56;
    end;
    end;
A15: now let i be Element of NAT such that
    A16: 1 <= i and
    A17: i < len f; assume R[i];
        then consider r being Polynomial of F_Complex such that
    A18: r = F.i and
    A19: eval(r,c) is integer;
    A20: i in Seg len f by A16,A17,FINSEQ_1:3;
    A21: 1 <= i+1 & i+1 <= len f by A16,A17,NAT_1:13;
    then A22: i+1 in Seg len f by FINSEQ_1:3;
    then A23: i+1 in dom f by FINSEQ_1:def 3;
        reconsider fi = f|Seg i as
         FinSequence of (the carrier of Polynom-Ring F_Complex) by FINSEQ_1:23;
        reconsider fi1 = f|Seg (i+1) as
         FinSequence of (the carrier of Polynom-Ring F_Complex) by FINSEQ_1:23;
             i <= i+1 by NAT_1:12;
    then A24: fi = fi1 | Seg i by Lm2;
             i+1 = min(i+1,len f) by A21,XXREAL_0:def 8;
    then A25: len fi1 = i+1 by FINSEQ_2:24;
         A26: i+1 in Seg (i+1) by FINSEQ_1:6;
    then A27: (f|Seg (i+1)).(i+1) = f.(i+1) by FUNCT_1:72;
        then reconsider fi1d1 = fi1.(i+1) as
        Element of (the carrier of Polynom-Ring F_Complex) by A23,FINSEQ_2:13;
      reconsider fi1d1p = fi1d1 as Polynomial of F_Complex by POLYNOM3:def 12;
             fi1 = fi ^ <* fi1d1 *> by A24,A25,FINSEQ_3:61;
    then A28: Product fi1 = Product fi * fi1d1 by GROUP_4:9;
        reconsider pfi1 = Product fi1, pfi = Product fi
               as Polynomial of F_Complex by POLYNOM3:def 12;
        thus R[i+1] proof
        take pfi1;
        thus pfi1 = F.(i+1) by A9,A22;
        reconsider epfi = eval(pfi,c), efi1d1p = eval(fi1d1p,c)
             as Element of COMPLEX by COMPLFLD:def 1;
        reconsider iepfi = epfi as Integer by A9,A18,A19,A20;
             now reconsider i1 = i+1 as non empty Element of NAT;
         per cases by A3,A23;
         suppose f.i1 = <%1_F_Complex%>;
          hence eval(fi1d1p,c) is integer by A4,A5,A26,FUNCT_1:72;
        end;
        suppose f.i1 = cyclotomic_poly(i1);
         hence eval(fi1d1p,c) is integer by A2,A27,Th56;
        end;
        end;
        then reconsider iefi1d1p = efi1d1p as Integer;
             pfi1 = pfi *' fi1d1p by A28,POLYNOM3:def 12;
        then eval(pfi1, c) = eval(pfi,c) * eval(fi1d1p,c) by POLYNOM4:27
                      .= iepfi * iefi1d1p;
      hence eval(pfi1, c) is integer;
      end;
    end;
     for i being Element of NAT st 1 <= i & i <= len f holds R[i]
    from POLYNOM2:sch 4
(A12,A15);
    then consider r being Polynomial of F_Complex such that
A29:  r = F.len f and
A30:  eval(r,c) is integer by A7;
        f = f|Seg len f by FINSEQ_3:55;
 hence eval(p,c) is integer by A1,A9,A11,A29,A30;
end;
end;

theorem Th60:
for n being non empty Element of NAT, j, k, q being Integer,
qc being Element of F_Complex
 st qc = q &
    j = eval(cyclotomic_poly(n),qc) & k = eval(unital_poly(F_Complex, n),qc)
  holds j divides k
proof let n be non empty Element of NAT, j,k,q being Integer,
          qc being Element of F_Complex such that
A1: qc = q and
A2: j = eval(cyclotomic_poly(n),qc) and
A3: k = eval(unital_poly(F_Complex, n),qc);
   set jfc = eval(cyclotomic_poly(n),qc);
   reconsider jc = jfc as Element of COMPLEX by COMPLFLD:def 1;
  per cases by UPROOTS:1;
  suppose n = 1;
   hence thesis by A2,A3,Th52,POLYNOM5:def 4;
  end;
  suppose A4: n > 1;
            1 divides n by NAT_D:6;
       then consider f being FinSequence of (the carrier of Polynom-Ring
F_Complex),
                p being Polynomial of F_Complex such that
  A5: p = Product(f) and
  A6: dom f = Seg n and
  A7: for i being non empty Element of NAT st i in Seg n holds
       (not i divides n or i divides 1 or i = n
          implies f.i = <%1_F_Complex%>) &
       (i divides n & not i divides 1 & i <> n
          implies f.i = cyclotomic_poly(i))  and
  A8: unital_poly(F_Complex,n)
      = unital_poly(F_Complex,1)*'(cyclotomic_poly n)*'p by A4,Th58;
      set epfc = eval(p,qc);
           now let i be non empty Element of NAT; assume
       A9: i in dom f;
        per cases;
        suppose not i divides n or i divides 1 or i = n;
        hence f.i = <%1_F_Complex%> or f.i = cyclotomic_poly(i) by A6,A7,A9;
        end;
        suppose i divides n & not i divides 1 & i <> n;
        hence f.i = <%1_F_Complex%> or f.i = cyclotomic_poly(i) by A6,A7,A9;
      end;
      end;
      then reconsider ep = epfc as Integer by A1,A5,Th59;
      reconsider epc = epfc as Element of COMPLEX by COMPLFLD:def 1;
      set eup1fc = eval(unital_poly(F_Complex,1),qc);
      reconsider eup1 = eup1fc as Integer by A1,Th51;
      reconsider eup1c = eup1fc as Element of COMPLEX by COMPLFLD:def 1;
           k = eval((unital_poly(F_Complex,1)*'cyclotomic_poly(n)),qc) * epfc
          by A3,A8,POLYNOM4:27;
  then k = eup1fc * jfc * epfc by POLYNOM4:27;
      then k = eup1 * ep * j by A2;
  hence j divides k by INT_1:def 9;
end;
end;

theorem Th61:
for n,ni being non empty Element of NAT, q being Integer
st ni < n & ni divides n
for qc being Element of F_Complex st qc = q
for j,k,l being Integer
 st j = eval(cyclotomic_poly(n),qc) &
    k = eval(unital_poly(F_Complex, n),qc) &
    l = eval(unital_poly(F_Complex, ni),qc)
  holds j divides (k div l)
proof let n,ni be non empty Element of NAT, q being Integer such that
A1: ni < n & ni divides n;
    let qc be Element of F_Complex such that A2: qc = q;
    let j,k,l be Integer such that
A3: j = eval(cyclotomic_poly(n),qc) and
A4:k = eval(unital_poly(F_Complex,n),qc) and
A5:l = eval(unital_poly(F_Complex,ni),qc);
    set ttt = (unital_poly(F_Complex,ni)*'cyclotomic_poly(n));
    consider f being FinSequence of (the carrier of Polynom-Ring F_Complex),
             p being Polynomial of F_Complex such that
A6:  p = Product(f) and
A7: dom f = Seg n and
A8: (for i being non empty Element of NAT st i in Seg n holds
       (not i divides n or i divides ni or i = n
          implies f.i = <%1_F_Complex%>) &
       (i divides n & not i divides ni & i <> n
          implies f.i = cyclotomic_poly(i)))   and
A9: unital_poly(F_Complex,n) = ttt *' p by A1,Th58;
    A10: eval(unital_poly(F_Complex,n),qc) =
      eval(ttt,qc) * eval(p,qc) by A9,POLYNOM4:27;
         now let i being non empty Element of NAT such that
    A11: i in dom f;
     per cases;
     suppose not i divides n or i divides ni or i = n;
      hence f.i = <%1_F_Complex%> or f.i = cyclotomic_poly(i) by A7,A8,A11;
      end;
      suppose i divides n & not i divides ni & i <> n;
      hence f.i = <%1_F_Complex%> or f.i = cyclotomic_poly(i) by A7,A8,A11;
    end;
    end;
    then eval(p,qc) is integer by A2,A6,Th59;
    then consider m being Integer such that
A12: m = eval(p,qc);
    reconsider jc = j, lc = l, mc = m as Element of COMPLEX by XCMPLX_0:def 2;
    reconsider jcf = jc, lcf = lc, mcf = mc as Element of F_Complex by
COMPLFLD:def 1;
A13: k = lcf*jcf*mcf by A3,A4,A5,A10,A12,POLYNOM4:27 .= l*j*m;
     now per cases;
    suppose A14:l <> 0;
           k = l*(j*m) by A13; then l divides k by INT_1:def 9;
      then k/l is integer by A14,WSIERP_1:22; then [\ k/l /] = k/l
by INT_1:47;
      then k div l = (j*m)*l/l by A13,INT_1:def 7; then k div l = j*m by A14,
XCMPLX_1:90;
     hence j divides (k div l) by INT_1:def 9;
    end;
    suppose l = 0; then k div l = 0 by INT_1:75;
     hence j divides (k div l) by INT_2:16;
    end;
    end;
  hence thesis;
end;

theorem
     for n,q being non empty Element of NAT, qc being Element of F_Complex
    st qc = q
for j being Integer st j = eval(cyclotomic_poly(n),qc)
 holds j divides (q |^ n - 1)
proof let n,q be non empty Element of NAT;
    let qc be Element of F_Complex such that A1: qc = q;
    let j be Integer such that A2: j = eval(cyclotomic_poly(n),qc);
    reconsider ni=n as non empty Element of NAT;
    consider k,l being Integer;
    consider y1 being Element of F_Complex such that
A3: y1 = q & eval(unital_poly(F_Complex,n),y1) = (q |^ n) - 1 by Th48;
  thus thesis by A1,A2,A3,Th60;
end;

theorem
     for n,ni,q being non empty Element of NAT st ni < n & ni divides n
for qc being Element of F_Complex st qc = q
for j being Integer st j = eval(cyclotomic_poly(n),qc)
  holds j divides ((q |^ n - 1) div (q |^ ni - 1))
proof
    let n,ni,q be non empty Element of NAT such that A1: ni < n & ni divides n;
    let qc be Element of F_Complex such that A2: qc = q;
    let j be Integer such that A3: j = eval(cyclotomic_poly(n),qc);
    consider k,l being Integer;
    consider y1 being Element of F_Complex such that
A4: y1 = q & eval(unital_poly(F_Complex,n),y1) = (q |^ n) - 1 by Th48;
    consider y2 being Element of F_Complex such that
A5: y2=q & eval(unital_poly(F_Complex,ni),y2) = (q |^ ni) - 1 by Th48;
  thus thesis by A1,A2,A3,A4,A5,Th61;
end;

theorem
   for n being non empty Element of NAT st 1 < n
for q being Element of NAT st 1 < q
for qc being Element of F_Complex st qc = q
for i being Integer st i = eval(cyclotomic_poly(n),qc) holds abs(i) > q - 1
proof let n be non empty Element of NAT such that A1: 1 < n;
   set cMGFC = the carrier of MultGroup F_Complex;
   set MGFC = MultGroup F_Complex;
    let q be Element of NAT such that A2: 1 < q;
    let qc be Element of F_Complex such that A3: qc = q;
    let i be Integer such that A4: i = eval(cyclotomic_poly(n),qc);
    reconsider qi=q as Integer;
         1+1 <= qi by A2,INT_1:20; then A5: 1+1+-1 <= qi +-1 by XREAL_1:9;
     q in COMPLEX by XCMPLX_0:def 2;
    then reconsider qc1=q+0*<i> as Element of F_Complex by COMPLFLD:def 1;
    consider ir being Real;
     ir in COMPLEX by XCMPLX_0:def 2;
   then reconsider qc2=ir+0*<i> as Element of F_Complex by COMPLFLD:def 1;
    consider S being non empty finite Subset of F_Complex such that
A6: S = {y where y is Element of cMGFC : ord y = n} and
A7: cyclotomic_poly(n) = poly_with_roots((S,1)-bag) by Def5;
         rng canFS(S) = S by UPROOTS:5;
    then reconsider fs = canFS(S) as FinSequence of F_Complex
      by FINSEQ_1:def 4;
A8: rng fs = S by UPROOTS:5;
A9: len fs = card S by UPROOTS:def 1;
    consider nth being Element of MGFC;         fs <> {} by A8,FINSEQ_1:27;
then A10: len fs <> 0 by FINSEQ_1:25;
    deffunc F(set) = |.qc - fs/.$1.|;
    consider p1 being FinSequence such that
A11: len p1 = len fs &
for i being Nat st i in Seg len fs holds p1.i = F(i)
from FINSEQ_1:sch 2;
A12: for i being Element of NAT, c being Element of F_Complex
      st i in dom p1 & c = (canFS(S)).i holds p1.i = |.qc - c.|
    proof let i be Element of NAT, c being Element of F_Complex such that
    A13: i in dom p1 and
    A14: c = (canFS(S)).i;
             i in dom fs by A11,A13,FINSEQ_3:31;
    then A15: fs/.i = (canFS(S)).i by PARTFUN1:def 8;
             i in Seg len p1 by A13,FINSEQ_1:def 3;
      hence thesis by A11,A14,A15;
    end;
         for x being set st x in rng p1 holds x in REAL
    proof let x be set such that A16: x in rng p1;
        consider i being Nat such that
    A17: i in dom p1 and A18: p1.i = x by A16,FINSEQ_2:11;
     i in dom fs by A11,A17,FINSEQ_3:31; then fs/.i = (canFS(S)).i
    by PARTFUN1:def 8;
        then x = |.qc - fs/.i.| by A12,A17,A18;
      hence thesis;
    end; then rng p1 c= REAL by TARSKI:def 3;
    then reconsider ps=p1 as non empty FinSequence of REAL
        by A10,A11,FINSEQ_1:25,def 4;
A19: |.eval(cyclotomic_poly(n),qc).| = Product(ps) by A7,A9,A11,A12,Th4;
         for i being Element of NAT st i in dom ps holds ps.i > q - 1
    proof let i be Element of NAT such that A20: i in dom ps;
       i in dom fs by A11,A20,FINSEQ_3:31; then fs/.i = (canFS(S)).i
      by PARTFUN1:def 8;
    then A21: ps.i = |.[**q,0**] - fs/.i.| by A3,A12,A20;
    A22: i in dom fs by A11,A20,FINSEQ_3:31;
        then fs.i in rng fs by FUNCT_1:12; then fs/.i in rng fs by A22,
PARTFUN1:def 8;
        then consider y being Element of MGFC such that
    A23: fs/.i = y and
    A24: ord y = n by A6,A8;
             fs/.i in n-roots_of_1 by A23,A24,Th37;
    then A25: |.fs/.i.| = 1 by Th26;
            now assume A26: fs/.i = [**1,0**];
                1_MultGroup F_Complex = [**1, 0**] by Th20,COMPLFLD:10;
          hence contradiction by A1,A23,A24,A26,GROUP_1:84;
        end;
      hence thesis by A2,A21,A25,Th8;
    end;
  hence abs(i) > q - 1 by A4,A5,A19,Th9;
end;

