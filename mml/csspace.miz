:: Complex Linear Space of Complex Sequences
::  by Noboru Endou
::
:: Received January 26, 2004
:: Copyright (c) 2004 Association of Mizar Users

environ

 vocabularies RLVECT_1, FUNCT_1, ARYTM_1, RELAT_1, ABSVALUE, ORDINAL2, BINOP_1,
      SQUARE_1, FUNCT_2, RLSUB_1, SEQ_1, SEQ_2, SERIES_1, BHSP_1, SUPINF_2,
      RSSPACE, CLVECT_1, COMSEQ_1, COMPLEX1, PROB_2, ARYTM_3, CSSPACE,
      CFUNCT_1, PRE_TOPC, NORMSP_1, METRIC_1, SEQM_3, XCMPLX_0, FUNCOP_1,
      REALSET1, NAT_1, STRUCT_0;
 notations TARSKI, XBOOLE_0, SUBSET_1, PRE_TOPC, RELAT_1, DOMAIN_1, FUNCT_1,
      FUNCT_2, FUNCOP_1, SEQ_1, BINOP_1, REALSET1, STRUCT_0, ZFMISC_1, NUMBERS,
      XCMPLX_0, XXREAL_0, REAL_1, SQUARE_1, COMPLEX1, COMSEQ_1, CFUNCT_1,
      COMSEQ_2, COMSEQ_3, SERIES_1, NAT_1, RLVECT_1, NORMSP_1, BHSP_1,
      CLVECT_1;
 constructors PARTFUN1, BINOP_1, FUNCOP_1, REAL_1, SQUARE_1, NAT_1, SEQ_1,
      COMSEQ_1, COMSEQ_2, SERIES_1, COMSEQ_3, REALSET1, BHSP_1, CLVECT_1;
 registrations XBOOLE_0, SUBSET_1, FUNCT_1, ORDINAL1, RELSET_1, FUNCT_2,
      NUMBERS, XCMPLX_0, XXREAL_0, MEMBERED, COMPLEX1, COMSEQ_1, COMSEQ_2,
      REALSET1, STRUCT_0, CLVECT_1;
 requirements SUBSET, REAL, BOOLE, NUMERALS, ARITHM;
 definitions TARSKI, RLVECT_1, CLVECT_1, STRUCT_0, NORMSP_1, REALSET1,
      SQUARE_1, BINOP_1;
 theorems XBOOLE_0, STRUCT_0, RELAT_1, SQUARE_1, TARSKI, ABSVALUE, ZFMISC_1,
      SEQ_1, SERIES_1, COMSEQ_3, FUNCT_1, FUNCT_2, RLVECT_1, BINOP_1, XCMPLX_0,
      COMSEQ_1, CLVECT_1, COMPLEX1, COMSEQ_2, NORMSP_1, FUNCOP_1, XREAL_1,
      XXREAL_0, BHSP_1;
 schemes NAT_1, BINOP_1, XBOOLE_0, BINOP_2;

begin

definition
 func the_set_of_ComplexSequences -> non empty set means :Def1:
  for x being set holds x in it iff x is Complex_Sequence;
  existence
  proof
    defpred P[set] means $1 is Complex_Sequence;
    consider IT being set such that
A1:  for x being set holds x in IT
      iff x in Funcs(NAT,COMPLEX) & P[x] from XBOOLE_0:sch 1;
        IT is non empty
    proof
      consider zeroseq be Complex_Sequence;
          zeroseq in Funcs(NAT,COMPLEX) by FUNCT_2:11;
      hence thesis by A1;
    end;
    then reconsider IT as non empty set;
    take IT;
        for x being set holds x is Complex_Sequence implies x in IT
    proof
      let x be set;
      assume
A2:   x is Complex_Sequence;
      then x in Funcs(NAT,COMPLEX) by FUNCT_2:11;
      hence thesis by A1,A2;
    end;
    hence thesis by A1;
  end;
  uniqueness
  proof
    let X1,X2 be non empty set;
    assume that
A3: for x being set holds x in X1 iff x is Complex_Sequence and
A4: for x being set holds x in X2 iff x is Complex_Sequence;
A5: X1 c= X2
    proof
      let x be set;
      assume x in X1;
      then x is Complex_Sequence by A3;
      hence thesis by A4;
    end;
        X2 c= X1
    proof
      let x be set;
      assume x in X2;
      then x is Complex_Sequence by A4;
      hence thesis by A3;
    end;
    hence thesis by A5,XBOOLE_0:def 10;
  end;
end;

definition let z be set such that
A1:z in the_set_of_ComplexSequences;
 func seq_id(z) -> Complex_Sequence equals :Def2:
  z;
coherence by A1,Def1;
end;

definition let z be set such that
A1:z in COMPLEX;
 func C_id(z) -> Complex equals :Def3:
  z;
coherence by A1;
end;

theorem Th1:
ex ADD be BinOp of the_set_of_ComplexSequences st
  (for a,b being Element of the_set_of_ComplexSequences holds
    ADD.(a,b) = seq_id(a)+seq_id(b)) & ADD is commutative associative
proof
   defpred P[Element of the_set_of_ComplexSequences,
             Element of the_set_of_ComplexSequences,
             Element of the_set_of_ComplexSequences] means
   $3=seq_id($1)+seq_id($2);
A1:for x,y being Element of the_set_of_ComplexSequences
      ex z being Element of the_set_of_ComplexSequences st P[x,y,z]
   proof
     let x,y be Element of the_set_of_ComplexSequences;
       seq_id(x)+seq_id(y) is Element of the_set_of_ComplexSequences by Def1;
     hence thesis;
   end;
     ex ADD be BinOp of the_set_of_ComplexSequences st
     for a,b being Element of the_set_of_ComplexSequences holds
       P[a,b,ADD.(a,b)] from BINOP_1:sch 3(A1);
   then consider ADD be BinOp of the_set_of_ComplexSequences such that
A2:for a,b being Element of the_set_of_ComplexSequences holds
     ADD.(a,b) = seq_id(a)+seq_id(b);
A3:ADD is commutative
   proof
       now
       let a,b being Element of the_set_of_ComplexSequences;
       thus ADD.(a,b) = seq_id(a)+seq_id(b) by A2
                     .= ADD.(b,a) by A2;
     end;
     hence thesis by BINOP_1:def 2;
   end;
     ADD is associative
   proof
       now
       let a,b,c be Element of the_set_of_ComplexSequences;
A4:    seq_id(ADD.(b,c)) = ADD.(b,c) by Def2
                        .=seq_id(b)+seq_id(c) by A2;
A5:    seq_id(a)+seq_id(b) = ADD.(a,b) by A2
                          .=seq_id(ADD.(a,b)) by Def2;
       thus ADD.(a,ADD.(b,c)) = seq_id(a)+seq_id(ADD.(b,c)) by A2
                .= (seq_id(a)+seq_id(b))+seq_id(c) by A4,COMSEQ_1:9
                .= ADD.(ADD.(a,b),c) by A2,A5;
     end;
     hence thesis by BINOP_1:def 3;
   end;
   hence thesis by A2,A3;
end;

theorem Th2:
ex f be Function of [: COMPLEX, the_set_of_ComplexSequences :],
  the_set_of_ComplexSequences st
   for r,x be set st r in COMPLEX & x in the_set_of_ComplexSequences
      holds f.(r,x) = C_id(r) (#) seq_id(x)
proof
   deffunc F(set,set) = C_id($1) (#) seq_id($2);
A1:for r,x be set st r in COMPLEX & x in the_set_of_ComplexSequences holds
   F(r,x) in the_set_of_ComplexSequences by Def1;
     ex f be Function of
     [:COMPLEX, the_set_of_ComplexSequences:], the_set_of_ComplexSequences st
       for r,x be set st r in COMPLEX & x in the_set_of_ComplexSequences holds
         f.(r,x) = F(r,x) from BINOP_1:sch 2(A1);
   hence thesis;
end;

definition
 func l_add -> BinOp of the_set_of_ComplexSequences means :Def4:
  for a,b being Element of the_set_of_ComplexSequences holds
   it.(a,b) = seq_id(a)+seq_id(b);
existence by Th1;
uniqueness
proof
   deffunc O(Element of the_set_of_ComplexSequences,
   Element of the_set_of_ComplexSequences)=seq_id($1)+seq_id($2);
     for o1,o2 being BinOp of the_set_of_ComplexSequences st
    (for a,b being Element of the_set_of_ComplexSequences
      holds o1.(a,b) = O(a,b)) &
    (for a,b being Element of the_set_of_ComplexSequences
      holds o2.(a,b) = O(a,b))
   holds o1 = o2 from BINOP_2:sch 2;
   hence thesis;
   end;
end;

definition
 func l_mult -> Function of [:COMPLEX,the_set_of_ComplexSequences:],
  the_set_of_ComplexSequences means :Def5:
   for z,x be set st z in COMPLEX & x in the_set_of_ComplexSequences
      holds it.(z,x) = C_id(z)(#)seq_id(x);
existence by Th2;
uniqueness
proof
   let mult1,mult2 be Function of [:COMPLEX,the_set_of_ComplexSequences:],
   the_set_of_ComplexSequences such that
A1:for z,x be set st z in COMPLEX & x in the_set_of_ComplexSequences
    holds mult1.(z,x) = C_id(z)(#)seq_id(x)
   and
A2:for z,x be set st z in COMPLEX & x in the_set_of_ComplexSequences
    holds mult2.(z,x) = C_id(z)(#)seq_id(x);
     for z being Element of COMPLEX
    for x being Element of the_set_of_ComplexSequences holds
     mult1.(z,x) = mult2.(z,x)
   proof
     let z being Element of COMPLEX;
     let x being Element of the_set_of_ComplexSequences;
     thus mult1.(z,x) = C_id(z)(#)seq_id(x) by A1
                     .= mult2.(z,x) by A2;
   end;
   hence thesis by BINOP_1:2;
end;
end;

definition
 func CZeroseq -> Element of the_set_of_ComplexSequences means :Def6:
  for n be Element of NAT holds (seq_id it).n=0c;
existence
proof
    reconsider zeroseq = NAT --> 0c as Complex_Sequence by FUNCOP_1:57;
A1: for n be Element of NAT holds zeroseq.n=0c by FUNCOP_1:13;
A2: zeroseq in the_set_of_ComplexSequences by Def1;
   then seq_id(zeroseq) = zeroseq by Def2;
   hence thesis by A1,A2;
end;
uniqueness
proof
   let x,y be Element of the_set_of_ComplexSequences such that
A3:for n be Element of NAT holds (seq_id(x)).n=0c and
A4:for n be Element of NAT holds (seq_id(y)).n=0c;
A5:for s be Element of NAT holds (seq_id(x)).s = (seq_id(y)).s
   proof
     let s be Element of NAT;
       (seq_id y).s = 0c by A4;
     hence thesis by A3;
   end;
     x=seq_id(x) by Def2 .=seq_id(y) by A5,COMSEQ_1:6;
hence thesis by Def2;
end;
end;

theorem Th3:
for x being Complex_Sequence holds seq_id x = x
proof
   let x be Complex_Sequence;
     x in the_set_of_ComplexSequences by Def1;
   hence seq_id(x) = x by Def2;
end;

theorem Th4:
for v,w being VECTOR of
 CLSStruct(#the_set_of_ComplexSequences,CZeroseq,l_add,l_mult#) holds
  v + w = seq_id(v)+seq_id(w)
proof
   let v,w being VECTOR of
   CLSStruct (# the_set_of_ComplexSequences,CZeroseq, l_add,l_mult #);
   thus v + w =seq_id(v)+seq_id(w) by Def4;
end;

theorem Th5:
for z being Complex,
 v being VECTOR of
  CLSStruct(# the_set_of_ComplexSequences,CZeroseq,l_add,l_mult #) holds
   z * v = z(#)seq_id(v)
proof
   let z be Complex;
   let v be VECTOR of
   CLSStruct(# the_set_of_ComplexSequences,CZeroseq, l_add,l_mult #);
   thus z*v = l_mult.(z,v)
           .= C_id(z)(#)seq_id(v) by Def5
           .= z(#)seq_id(v) by Def3;
end;

registration
 cluster CLSStruct(# the_set_of_ComplexSequences,CZeroseq,l_add,l_mult #)
   -> Abelian;
coherence
proof
   let v,w being VECTOR of
   CLSStruct(# the_set_of_ComplexSequences,CZeroseq,l_add,l_mult #);
     v + w = seq_id(v)+seq_id(w) by Th4;
   hence thesis by Th4;
end;
end;

Lm1:
 for u,v being VECTOR of
 CLSStruct(# the_set_of_ComplexSequences,CZeroseq,l_add,l_mult #) holds
  u + v = v + u;

theorem Th6:
for u,v,w being VECTOR of
 CLSStruct(# the_set_of_ComplexSequences,CZeroseq,l_add,l_mult #) holds
  (u + v) + w = u + (v + w)
proof
   let u,v,w be VECTOR of
   CLSStruct(# the_set_of_ComplexSequences,CZeroseq,l_add,l_mult #);
     (u+v) + w = seq_id(u+v)+seq_id(w) by Th4
           .= seq_id(seq_id(u)+seq_id(v)) + seq_id(w) by Th4
           .= (seq_id(u)+seq_id(v)) + seq_id(w) by Th3
           .= seq_id(u)+(seq_id(v)+seq_id(w)) by COMSEQ_1:9
           .= seq_id(u)+seq_id(seq_id(v)+seq_id(w)) by Th3
           .= seq_id(u) + seq_id(v+w) by Th4;
   hence thesis by Th4;
end;

theorem Th7:
for v being VECTOR of
 CLSStruct(# the_set_of_ComplexSequences,CZeroseq,l_add,l_mult #) holds
  v + 0.CLSStruct(# the_set_of_ComplexSequences,CZeroseq,l_add,l_mult #) = v
proof
   let v being VECTOR of
    CLSStruct(# the_set_of_ComplexSequences,CZeroseq,l_add,l_mult #);
   set V=CLSStruct(# the_set_of_ComplexSequences,CZeroseq,l_add,l_mult #);
A1:v + 0.V = seq_id(v)+seq_id(CZeroseq) by Th4;
     for s being Element of NAT holds
    (seq_id(v)+seq_id(CZeroseq)).s=(seq_id(v)).s
   proof
     let s be Element of NAT;
       (seq_id(v)+seq_id(CZeroseq)).s
          = (seq_id(v)).s+(seq_id(CZeroseq)).s by COMSEQ_1:def 4
         .= (seq_id(v)).s + 0c by Def6;
     hence thesis;
   end;
   hence v + 0.V=seq_id(v) by A1,COMSEQ_1:6 .=v by Def2;
end;

theorem Th8:
for v being VECTOR of
  CLSStruct(# the_set_of_ComplexSequences,CZeroseq,l_add,l_mult #)
  ex w being VECTOR of
    CLSStruct(# the_set_of_ComplexSequences,CZeroseq,l_add,l_mult #) st
    v + w = 0.CLSStruct(# the_set_of_ComplexSequences,CZeroseq,l_add,l_mult #)
proof
   let v be VECTOR of
     CLSStruct(# the_set_of_ComplexSequences,CZeroseq,l_add,l_mult #);
   set V = CLSStruct(# the_set_of_ComplexSequences,CZeroseq,l_add,l_mult #);
   reconsider w=-seq_id(v) as VECTOR of V by Def1;
     v+w=CZeroseq
   proof
A1:  v+w = seq_id(v)+seq_id(w) by Th4
        .= seq_id(v)+(-seq_id(v)) by Th3;
       for s being Element of NAT holds
       (seq_id(v)+(-seq_id(v)) ).s=(seq_id(CZeroseq)).s
     proof
       let s be Element of NAT;
         (seq_id(v)+(-seq_id(v))).s
         = (seq_id(v)).s+(-seq_id(v)).s by COMSEQ_1:def 4
        .= (seq_id(v)).s + (-((seq_id(v)).s)) by COMSEQ_1:def 9
        .= (seq_id(CZeroseq)).s by Def6;
       hence thesis;
     end;
     then seq_id(v)+(-seq_id(v)) = seq_id(CZeroseq) by COMSEQ_1:6
      .=CZeroseq by Def2;
     hence thesis by A1;
   end;
   hence thesis;
end;

theorem Th9:
for z being Complex, v,w being VECTOR of
 CLSStruct(# the_set_of_ComplexSequences,CZeroseq,l_add,l_mult #) holds
  z * (v + w) = z * v + z * w
proof
   let z be Complex;
   let v,w being VECTOR of
     CLSStruct(# the_set_of_ComplexSequences,CZeroseq,l_add,l_mult #);
A1:z * (v + w) = z(#)seq_id(v + w) by Th5
              .= z(#)seq_id(seq_id(v) + seq_id(w)) by Th4
              .= z(#)(seq_id(v) + seq_id(w)) by Th3
              .= z(#)seq_id(v) + z(#)seq_id(w) by COMSEQ_1:19;
     z*v + z*w = seq_id(z*v)+seq_id(z*w) by Th4
            .=seq_id(z(#)seq_id(v)) + seq_id(z*w) by Th5
            .=seq_id(z(#)seq_id(v)) + seq_id(z(#)seq_id(w)) by Th5
            .=z(#)seq_id(v) + seq_id(z(#)seq_id(w)) by Th3
            .=z(#)seq_id(v) + z(#)seq_id(w) by Th3;
   hence thesis by A1;
end;

theorem Th10:
for z1,z2 being Complex, v being VECTOR of
 CLSStruct(# the_set_of_ComplexSequences,CZeroseq,l_add,l_mult #) holds
  (z1 + z2) * v = z1 * v + z2 * v
proof
   let z1,z2 be Complex;
   let v being VECTOR of
    CLSStruct(# the_set_of_ComplexSequences,CZeroseq,l_add,l_mult #);
A1:(z1+z2)(#)seq_id(v) =z1(#)seq_id(v)+z2(#)seq_id(v)
   proof
       for s being Element of NAT holds
     ((z1+z2)(#)seq_id(v)).s=(z1(#)seq_id(v)+z2(#)seq_id(v)).s
     proof
       let s be Element of NAT;
           ((z1+z2)(#)seq_id(v)).s = (z1+z2)*(seq_id(v)).s by COMSEQ_1:def 7
          .= z1*((seq_id(v)).s)+z2*((seq_id(v)).s)
          .= (z1(#)seq_id(v)).s+z2*(seq_id(v)).s by COMSEQ_1:def 7
          .= (z1(#)seq_id(v)).s+(z2(#)seq_id(v)).s by COMSEQ_1:def 7;
       hence thesis by COMSEQ_1:def 4;
     end;
     hence (z1+z2)(#)seq_id(v)=z1(#)seq_id(v)+z2(#)seq_id(v) by COMSEQ_1:6;
   end;
     z1*v + z2*v = seq_id(z1*v)+seq_id(z2*v) by Th4
          .=seq_id(z1(#)seq_id(v)) + seq_id(z2*v) by Th5
          .=seq_id(z1(#)seq_id(v)) + seq_id(z2(#)seq_id(v)) by Th5
          .=z1(#)seq_id(v) + seq_id(z2(#)seq_id(v)) by Th3
          .=z1(#)seq_id(v) + z2(#)seq_id(v) by Th3;
   hence thesis by A1,Th5;
end;

theorem Th11:
for z1,z2 be Complex, v being VECTOR of
 CLSStruct(# the_set_of_ComplexSequences,CZeroseq,l_add,l_mult #) holds
  (z1 * z2) * v = z1 * (z2 * v)
proof
   let z1,z2 be Complex;
   let v being VECTOR of
    CLSStruct(# the_set_of_ComplexSequences,CZeroseq,l_add,l_mult #);
       (z1 * z2) * v =(z1*z2)(#)seq_id(v) by Th5
                .=z1(#)(z2(#)seq_id(v)) by COMSEQ_1:20
                .=z1(#)seq_id(z2(#)seq_id(v)) by Th3
                .=z1(#)seq_id(z2*v) by Th5;
   hence thesis by Th5;
end;

theorem Th12:
for v being VECTOR of
 CLSStruct(# the_set_of_ComplexSequences,CZeroseq,l_add,l_mult #) holds
  1r * v = v
proof
   let v being VECTOR of
    CLSStruct(# the_set_of_ComplexSequences,CZeroseq,l_add,l_mult #);
       1r * v =1r(#)seq_id(v) by Th5 .=seq_id(v) by COMSEQ_1:24;
   hence thesis by Def2;
end;

definition
  func Linear_Space_of_ComplexSequences -> ComplexLinearSpace equals
   CLSStruct (# the_set_of_ComplexSequences, CZeroseq, l_add, l_mult #);
  correctness by Lm1,Th6,Th7,Th8,Th9,Th10,Th11,Th12,CLVECT_1:1;
end;

definition
let X be ComplexLinearSpace;
let X1 be Subset of X such that
A1:X1 is linearly-closed & X1 is non empty;
func Add_(X1,X) -> BinOp of X1 equals :Def8:
  (the add of X)||X1;
correctness
proof
A2:[:X1,X1:] c= [:the carrier of X,the carrier of X:] by ZFMISC_1:119;
A3:dom (the add of X)
     = [:the carrier of X,the carrier of X:] by FUNCT_2:def 1;
then A4:dom ((the add of X)||X1) =[:X1,X1:] by A2,RELAT_1:91;
     for z be set st z in [:X1,X1:] holds ((the add of X)||X1).z in X1
   proof
     let z be set such that
A5:  z in [:X1,X1:];
     consider r,x  be set such that
A6:  r in X1 & x in X1 & z=[r,x] by A5,ZFMISC_1:def 2;
     reconsider y=x,r1=r as VECTOR of X by A6;
       [r,x] in dom ((the add of X)||X1) by A2,A3,A5,A6,RELAT_1:91;
     then ((the add of X)||X1).z
        = r1+y by A6,FUNCT_1:70;
     hence thesis by A1,A6,CLVECT_1:def 3;
   end;
   hence thesis by A4,FUNCT_2:5;
end;
end;

definition
let X be ComplexLinearSpace;
let X1 be Subset of X such that
A1: X1 is linearly-closed & X1 is non empty;
func Mult_(X1,X) -> Function of [:COMPLEX,X1:], X1 equals :Def9:
(the Mult of X) | [:COMPLEX,X1:];
correctness
proof
A2:[:COMPLEX,X1:] c= [:COMPLEX,the carrier of X:] by ZFMISC_1:118;
A3: dom (the Mult of X) = [:COMPLEX,the carrier of X:] by FUNCT_2:def 1;
then A4: dom ((the Mult of X) | [:COMPLEX,X1:]) =[:COMPLEX,X1:] by A2,
RELAT_1:91;
       for z be set st z in [:COMPLEX,X1:] holds
     ((the Mult of X) | [:COMPLEX,X1:]).z in X1
   proof
     let z be set such that
A5:  z in [:COMPLEX,X1:];
     consider r,x  be set such that
A6:  r in COMPLEX & x in X1 & z=[r,x] by A5,ZFMISC_1:def 2;
     reconsider y=x as VECTOR of X by A6;
     reconsider r as Complex by A6;
    [r,x] in dom ((the Mult of X) | [:COMPLEX,X1:]) by A2,A3,A5,A6,RELAT_1:91;
     then ((the Mult of X) | [:COMPLEX,X1:]).z
       = r*y by A6,FUNCT_1:70;
     hence thesis by A1,A6,CLVECT_1:def 3;
   end;
   hence thesis by A4,FUNCT_2:5;
end;
end;

definition
let X be ComplexLinearSpace, X1 be Subset of X such that
A1: X1 is linearly-closed & X1 is non empty;
func Zero_(X1,X) -> Element of X1 equals :Def10:
  0.X;
correctness
proof
   consider v be Element of X1;
       v in X1 by A1;
   then reconsider v as Element of X;
       v-v=0.X by RLVECT_1:28;
   hence thesis by A1,CLVECT_1:23;
end;
end;

theorem Th13:
for V be ComplexLinearSpace, V1 be Subset of V
 st V1 is linearly-closed & V1 is non empty holds
  CLSStruct (# V1,Zero_(V1,V), Add_(V1,V),Mult_(V1,V) #) is Subspace of V
proof
   let V be ComplexLinearSpace;
   let V1 be Subset of V such that
A1:V1 is linearly-closed & V1 is non empty;
A2:Zero_(V1,V) = 0.V by A1,Def10;
A3:Add_(V1,V)= (the add of V)||V1 by A1,Def8;
       Mult_(V1,V) = (the Mult of V) | [:COMPLEX,V1:] by A1,Def9;
   hence thesis by A1,A2,A3,CLVECT_1:44;
end;

definition
 func the_set_of_l2ComplexSequences -> Subset of
  Linear_Space_of_ComplexSequences means :Def11:
  it is non empty &
  for x being set holds x in it iff
  (x in the_set_of_ComplexSequences &
  |.seq_id(x).|(#)|.seq_id(x).| is summable);
existence
proof
   defpred P[set] means |.seq_id($1).|(#)|.seq_id($1).| is summable;
   consider IT being set such that
A1:for x being set holds x in IT
    iff x in the_set_of_ComplexSequences & P[x] from XBOOLE_0:sch 1;
A2:IT is non empty
   proof
       |.seq_id(CZeroseq).|(#)|.seq_id(CZeroseq).| is summable
     proof
       reconsider rseq=|.seq_id(CZeroseq).|(#)|.seq_id(CZeroseq).|
                        as Real_Sequence;
         now let n be Element of NAT;
         thus rseq.n =(|.seq_id(CZeroseq).|).n  * (|.seq_id(CZeroseq).|).n
                                                               by SEQ_1:12
                    .=(|.seq_id(CZeroseq).|).n * |.(seq_id(CZeroseq)).n.|
                    by COMSEQ_1:def 14
                    .=(|.seq_id(CZeroseq).|).n * 0 by Def6,COMPLEX1:130
                    .=0;
       end;
       then rseq is absolutely_summable by COMSEQ_3:3;
       hence thesis by SERIES_1:40;
     end;
     hence thesis by A1;
   end;
     IT is Subset of the_set_of_ComplexSequences
   proof
       for x be set st x in IT holds x in the_set_of_ComplexSequences by A1;
     hence thesis by TARSKI:def 3;
   end;
   hence thesis by A1,A2;
end;
uniqueness
proof
   let X1,X2 be Subset of Linear_Space_of_ComplexSequences;
   assume that
A3:X1 is non empty &
    for x being set holds x in X1 iff
     (x in the_set_of_ComplexSequences &
      |.seq_id(x).|(#)|.seq_id(x).| is summable)
   and
A4:X2 is non empty &
    for x being set holds x in X2 iff
     (x in the_set_of_ComplexSequences &
      |.seq_id(x).|(#)|.seq_id(x).| is summable);
A5: X1 c= X2
    proof
      let x be set;
      assume x in X1;
      then x in the_set_of_ComplexSequences
        & |.seq_id(x).|(#)|.seq_id(x).| is summable by A3;
      hence thesis by A4;
    end;
        X2 c= X1
    proof
      let x be set;
      assume x in X2;
      then x in the_set_of_ComplexSequences
        & |.seq_id(x).|(#)|.seq_id(x).| is summable by A4;
      hence thesis by A3;
    end;
    hence thesis by A5,XBOOLE_0:def 10;
  end;
end;

theorem Th14:
the_set_of_l2ComplexSequences is linearly-closed &
 the_set_of_l2ComplexSequences is non empty
proof
   set W = the_set_of_l2ComplexSequences;
A1:for v,u be VECTOR of Linear_Space_of_ComplexSequences st
    v in the_set_of_l2ComplexSequences &
    u in the_set_of_l2ComplexSequences
     holds v + u in the_set_of_l2ComplexSequences
   proof
     let v,u be VECTOR of Linear_Space_of_ComplexSequences such that
A2:  v in W & u in W;
       |.seq_id(v+u).|(#)|.seq_id(v+u).| is summable
     proof
A3:    |.seq_id(v).|(#)|.seq_id(v).| is summable by A2,Def11;
A4:    |.seq_id(u).|(#)|.seq_id(u).| is summable by A2,Def11;
       set p = |.seq_id(v).|(#)|.seq_id(v).|;
       set q = |.seq_id(u).|(#)|.seq_id(u).|;
       set r = |.seq_id(v+u).|(#)|.seq_id(v+u).|;
A5:    2(#)p is summable by A3,SERIES_1:13;
         2(#)q is summable by A4,SERIES_1:13;
then A6:    2(#)p+2(#)q is summable by A5,SERIES_1:10;
A7:    for n be Element of NAT holds 0<=r.n
       proof
         let n be Element of NAT;
           r.n=(|.seq_id(v+u).|).n * (|.seq_id(v+u).|).n by SEQ_1:12;
         hence thesis by XREAL_1:65;
       end;
         for n be Element of NAT holds r.n <=(2(#)p+2(#)q).n
       proof
         let n be Element of NAT;
         set s = |.seq_id(v).|;
         set t = |.seq_id(u).|;
         reconsider sn=s.n, tn=t.n as Real;
A8:      seq_id(v+u)=seq_id(seq_id(v)+seq_id(u)) by Th4
                    .=seq_id(v)+seq_id(u) by Th3;
           (|.seq_id(v+u).|).n = |.(seq_id(v+u)).n .| by COMSEQ_1:def 14
                          .= |.(seq_id(v)).n  + (seq_id(u)).n.|
            by A8,COMSEQ_1:def 4;
         then (|.seq_id(v+u).|).n <= |.(seq_id(v)).n.| + |.(seq_id(u)).n.|
            by COMPLEX1:142;
         then (|.seq_id(v+u).|).n
            <= s.n + |.((seq_id(u)).n).| by COMSEQ_1:def 14;
then A9:      (|.seq_id(v+u).|).n <= s.n + t.n by COMSEQ_1:def 14;
           0 <= |.(seq_id(v+u)).n.| by COMPLEX1:132;
         then 0 <= (|.seq_id(v+u).|).n by COMSEQ_1:def 14;
then A10:     ((|.seq_id(v+u).|).n)^2 <= (s.n + t.n)^2 by A9,SQUARE_1:77;
           r.n = ((|.seq_id(v+u).|).n)^2 by SEQ_1:12;
then A11:     r.n <= sn^2 + 2*sn*tn + tn^2 by A10;
           (2(#)p+2(#)q).n=(2(#)p).n +(2(#)q).n by SEQ_1:11
                       .= 2*p.n + (2(#)q).n by SEQ_1:13
                       .= 2*p.n + 2*q.n by SEQ_1:13
                       .= 2*(s.n*s.n) + 2*q.n by SEQ_1:12
                       .= 2*sn^2 + 2*tn^2 by SEQ_1:12;
then A12:     (2(#)p+2(#)q).n - (sn^2 + 2*sn*tn + tn^2)
          = (sn-tn)^2;
           0 <= (sn-tn)^2 by XREAL_1:65;
         then 0 + (sn^2 + 2*sn*tn + tn^2) <= (2(#)p+2(#)q).n by A12,XREAL_1:21;
         hence thesis by A11,XXREAL_0:2;
       end;
       hence thesis by A6,A7,SERIES_1:24;
     end;
     hence v+u in W by Def11;
   end;
     for z be Complex for v be VECTOR of Linear_Space_of_ComplexSequences
    st v in W holds z * v in W
   proof
     let z be Complex;
     let v be VECTOR of Linear_Space_of_ComplexSequences such that
A13: v in W;
       |.seq_id(z*v).|(#)|.seq_id(z*v).| is summable
     proof
A14:   |.seq_id(v).|(#)|.seq_id(v).| is summable by A13,Def11;
         seq_id(z*v)=seq_id(z(#)seq_id(v)) by Th5
                 .=z(#)seq_id(v) by Th3;
       then |.seq_id(z*v).| = |.z.|(#)|.seq_id(v).| by COMSEQ_1:53;
       then |.seq_id(z*v).|(#)|.seq_id(z*v).|
            =|.z.|(#)(|.z.|(#)|.seq_id(v).|(#) |.seq_id(v).|) by SEQ_1:26
           .=|.z.|(#)(|.z.|(#)(|.seq_id(v).|(#)|.seq_id(v).|)) by SEQ_1:26
           .=(|.z.|*|.z.|)(#)(|.seq_id(v).|(#)|.seq_id(v).|) by SEQ_1:31;
       hence thesis by A14,SERIES_1:13;
     end;
     hence z*v in W by Def11;
   end;
   hence thesis by A1,Def11,CLVECT_1:def 3;
end;

theorem
  CLSStruct(# the_set_of_l2ComplexSequences,
  Zero_(the_set_of_l2ComplexSequences,Linear_Space_of_ComplexSequences),
  Add_(the_set_of_l2ComplexSequences,Linear_Space_of_ComplexSequences),
  Mult_(the_set_of_l2ComplexSequences,Linear_Space_of_ComplexSequences) #)
is Subspace of Linear_Space_of_ComplexSequences by Th13,Th14;

theorem Th16:
CLSStruct (# the_set_of_l2ComplexSequences,
  Zero_(the_set_of_l2ComplexSequences,Linear_Space_of_ComplexSequences),
  Add_(the_set_of_l2ComplexSequences,Linear_Space_of_ComplexSequences),
  Mult_(the_set_of_l2ComplexSequences,Linear_Space_of_ComplexSequences) #)
is ComplexLinearSpace by Th13,Th14;

theorem
  the carrier of Linear_Space_of_ComplexSequences = the_set_of_ComplexSequences
&
(for x be set holds
  x is Element of Linear_Space_of_ComplexSequences
  iff x is Complex_Sequence ) &
(for x be set holds x is VECTOR of Linear_Space_of_ComplexSequences
  iff x is Complex_Sequence ) &
(for u be VECTOR of Linear_Space_of_ComplexSequences
  holds u =seq_id(u) ) &
(for u,v be VECTOR of Linear_Space_of_ComplexSequences
  holds u+v =seq_id(u)+seq_id(v) ) &
( for z be Complex for u be VECTOR of Linear_Space_of_ComplexSequences
  holds z*u =z(#)seq_id(u) ) by Def1,Def2,Th4,Th5;

begin  :: Unitary space with complex coefficient

definition
 struct(CLSStruct) CUNITSTR (# carrier -> set,
         ZeroF -> Element of the carrier,
          add -> BinOp of the carrier,
         Mult -> Function of [:COMPLEX, the carrier:], the carrier,
       scalar -> Function of [: the carrier, the carrier :], COMPLEX #);
end;

registration
 cluster non empty strict CUNITSTR;
existence
proof
   consider D being non empty set, Z being Element of D,
            a being BinOp of D,
            m being Function of [:COMPLEX, D:], D,
            s being Function of [: D,D:],COMPLEX;
   take CUNITSTR (#D,Z,a,m,s#);
   thus the carrier of CUNITSTR (#D,Z,a,m,s#) is non empty;
   thus thesis;
   end;
end;

registration
  let D be non empty set, Z be Element of D,
      a be BinOp of D,m be Function of [:COMPLEX, D:], D,
      s be Function of [: D,D:],COMPLEX;
  cluster CUNITSTR (#D,Z,a,m,s#) -> non empty;
 coherence
  proof
   thus the carrier of CUNITSTR (#D,Z,a,m,s#) is non empty;
  end;
end;

reserve X for non empty CUNITSTR;
reserve a, b for Complex;
reserve x, y for Point of X;

deffunc 0'(CUNITSTR) = 0.$1;

definition let X; let x, y;
  func x .|. y -> Complex equals
 (the scalar of X).(x,y);
correctness;
end;

consider V0 being ComplexLinearSpace;
Lm2:the carrier of (0).V0 = {0.V0} by CLVECT_1:def 5;
 reconsider
  nilfunc = [: the carrier of (0).V0 , the carrier of (0).V0 :] --> 0c
  as Function of
   [: the carrier of (0).V0 , the carrier of (0).V0 :], COMPLEX by FUNCOP_1:57;
Lm3:for x, y being VECTOR of (0).V0 holds
     nilfunc.[x,y] = 0c by FUNCOP_1:13;

 0.V0 in the carrier of (0).V0 by Lm2,TARSKI:def 1;
 then
Lm4:nilfunc.[0.V0,0.V0] = 0c by Lm3;

Lm5:for u being VECTOR of (0).V0 holds
     0 <= Re(nilfunc.[u,u]) & Im(nilfunc.[u,u]) = 0
proof
   let u be VECTOR of (0).V0;
     u = 0.V0 by Lm2,TARSKI:def 1;
   hence thesis by Lm4,COMPLEX1:12;
end;

Lm6:for u, v being VECTOR of (0).V0 holds nilfunc.[u,v] = (nilfunc.[v,u])*'
proof
   let u, v be VECTOR of (0).V0;
     u = 0.V0 & v = 0.V0 by Lm2,TARSKI:def 1;
   hence thesis by Lm4,COMPLEX1:113;
end;

Lm7:for u, v, w being VECTOR of (0).V0 holds
     nilfunc.[u+v,w] = nilfunc.[u,w] + nilfunc.[v,w]
proof
   let u, v, w be VECTOR of (0).V0;
A1:u = 0.V0 & v = 0.V0 & w = 0.V0 by Lm2,TARSKI:def 1;
     u+v = 0.V0 by Lm2,TARSKI:def 1;
   hence thesis by A1,Lm4;
end;

Lm8:for u,v being VECTOR of (0).V0, a holds
  nilfunc.[a*u,v] = a * nilfunc.[u,v]
proof
   let u , v be VECTOR of (0).V0;
   let a;
A1:u = 0.V0 & v = 0.V0 by Lm2,TARSKI:def 1;
     a*u = 0.V0 by Lm2,TARSKI:def 1;
   hence thesis by A1,Lm4;
end;
set X0 = CUNITSTR(# the carrier of (0).V0,0.((0).V0),the add of (0).V0,
                  the Mult of (0).V0, nilfunc #);

Lm9:now
   let x , y , z be Point of X0;
   let a;
   thus x .|. x = 0c iff x = 0'(X0)
   proof
       0'(X0) = 0.V0 by CLVECT_1:31;
     hence thesis by Lm2,Lm4,TARSKI:def 1;
   end;
   thus 0 <= Re(x .|. x) & 0 = Im(x .|. x) by Lm5;
   thus x .|. y = (y .|. x)*' by Lm6;
   thus (x+y) .|. z = x .|. z + y .|. z
   proof
     reconsider u = x , v = y , w = z as VECTOR of (0).V0;
     (x+y) .|. z = nilfunc.[u+v,w] &
     x .|. z = nilfunc.[u,w] &
     y .|. z = nilfunc.[v,w];
     hence thesis by Lm7;
   end;
   thus (a*x) .|. y = a * ( x .|. y )
   proof
     reconsider u = x , v = y as VECTOR of (0).V0;
     (a*x) .|. y = nilfunc.[a*u,v] &
     x .|. y = nilfunc.[u,v];
     hence thesis by Lm8;
   end;
end;

definition let IT be non empty CUNITSTR;
  attr IT is ComplexUnitarySpace-like means :Def13:
  for x,y,w being Point of IT, a holds
    ( x .|. x = 0 iff x = 0.IT ) &
    0 <= Re(x .|. x) & 0 = Im(x .|. x) &
    x .|. y = (y .|. x)*' &
    (x+y) .|. w = x .|. w + y .|. w &
    (a*x) .|. y = a * ( x .|. y );
end;

registration
 cluster ComplexUnitarySpace-like ComplexLinearSpace-like Abelian
   add-associative right_zeroed right_complementable strict
   (non empty CUNITSTR);
existence
proof
   take X0;
   thus X0 is ComplexUnitarySpace-like by Def13,Lm9;
A1: for x,y be VECTOR of X0 for x',y' be VECTOR of (0).V0
     st x = x' & y = y' holds x + y = x' + y' &
     for a holds a * x = a * x';
   thus X0 is ComplexLinearSpace-like
   proof
     thus for a for v,w being VECTOR of X0 holds a * (v + w) = a * v + a * w
     proof
       let a;
       let v,w be VECTOR of X0;
       reconsider v'= v, w' = w as VECTOR of (0).V0;
       thus a * (v + w) = a *( v' + w')
                        .= a * v' + a * w' by CLVECT_1:def 2
                        .= a * v + a * w;
     end;
     thus for a,b for v being VECTOR of X0 holds (a+ b) * v = a* v + b * v
     proof
       let a,b;
       let v be VECTOR of X0;
       reconsider v'= v as VECTOR of (0).V0;
       thus (a + b) * v = (a + b) * v'
                       .= a * v' + b * v' by CLVECT_1:def 2
                       .= a * v + b * v;
     end;
     thus for a,b for v being VECTOR of X0 holds (a * b) * v = a * (b * v)
     proof
       let a,b;
       let v be VECTOR of X0;
       reconsider v'= v as VECTOR of (0).V0;
       thus (a * b) * v = (a * b) * v'
                       .= a * (b * v') by CLVECT_1:def 2
                       .= a * (b * v);
     end;
     let v be VECTOR of X0;
     reconsider v'= v as VECTOR of (0).V0;
     thus 1r * v = 1r * v' .= v by CLVECT_1:def 2;
   end;
   thus for v,w being VECTOR of X0 holds v + w = w + v
   proof
     let v,w be VECTOR of X0;
     reconsider v'= v , w'= w as VECTOR of (0).V0;
     thus v + w = w'+ v' by A1 .= w + v;
   end;
   thus for u,v,w being VECTOR of X0 holds (u + v) + w = u + (v + w)
   proof
     let u,v,w be VECTOR of X0;
     reconsider u'= u, v'= v, w'= w as VECTOR of (0).V0;
     thus (u + v) + w = (u' + v') + w'
                     .= u' + (v' + w') by RLVECT_1:def 6
                     .= u + (v + w);
   end;
   thus for v being VECTOR of X0 holds v + 0.X0 = v
   proof
     let v be VECTOR of X0;
     reconsider v'= v as VECTOR of (0).V0;
     thus v + 0.X0 = v'+ 0.(0).V0 .=v by RLVECT_1:10;
   end;
   thus for v being VECTOR of X0
       ex w being VECTOR of X0 st v + w = 0.X0
   proof
     let v be VECTOR of X0;
     reconsider v'= v as VECTOR of (0).V0;
     consider w' be VECTOR of (0).V0 such that
A2: v' + w' = 0.(0).V0 by RLVECT_1:def 8;
     reconsider w = w' as VECTOR of X0;
     take w;
     thus v + w = 0.X0 by A2;
   end;
   thus thesis;
end;
end;

definition
 mode ComplexUnitarySpace is ComplexUnitarySpace-like ComplexLinearSpace-like
  Abelian add-associative right_zeroed right_complementable
   (non empty CUNITSTR);
end;

reserve X for ComplexUnitarySpace;
reserve x, y, z, u, v for Point of X;

theorem
  (0.X).|.(0.X) = 0 by Def13;

theorem Th19:
x.|.(y+z) = x.|.y + x.|.z
proof
   thus x.|.(y+z) = ((y+z).|.x)*' by Def13
         .= (y.|.x + z.|.x)*' by Def13
         .= (y.|.x)*' + (z.|.x)*' by COMPLEX1:118
         .= x.|.y + (z.|.x)*' by Def13
         .= x.|.y + x.|.z by Def13;
end;

theorem Th20:
x.|.(a*y) = (a*') * x.|.y
proof
   thus x.|.(a*y) = ((a*y).|.x)*' by Def13
                 .= (a*(y.|.x))*' by Def13
                 .= (a*') * (y.|.x)*' by COMPLEX1:121
                 .= (a*') * (x.|.y) by Def13;
end;

theorem Th21:
(a*x).|.y = x.|.((a*')*y)
proof
     (a*x) .|. y = a * x .|. y by Def13
              .= (a*')*' * (y.|.x)*' by Def13
              .= ((a*')*(y.|.x))*' by COMPLEX1:121
              .= (((a*')*y).|.x)*' by Def13;
   hence thesis by Def13;
end;

theorem Th22:
(a*x + b*y).|.z = a * x.|.z + b * y.|.z
proof
     (a*x+b*y) .|. z = (a*x) .|. z + (b*y) .|. z by Def13
                  .= a * x .|. z + (b*y) .|. z by Def13;
   hence thesis by Def13;
end;

theorem Th23:
x.|.(a*y + b*z) = (a*') * x.|.y + (b*') * x.|.z
proof
     x.|.(a*y + b*z) = ((a*y + b*z).|.x)*' by Def13
                  .= ( a * y.|.x + b * z.|.x )*' by Th22
                  .= ( a * y.|.x )*' + ( b * z.|.x )*' by COMPLEX1:118
                  .= (a*') * (y.|.x)*' + ( b * z.|.x )*' by COMPLEX1:121
                  .= (a*') * (y.|.x)*' + (b*') * (z.|.x)*' by COMPLEX1:121
                  .= (a*') * x.|.y + (b*') * (z.|.x)*' by Def13;
   hence thesis by Def13;
end;

theorem Th24:
(-x) .|. y = x .|. (-y)
proof
     (-x) .|. y = ((-1r)*x) .|. y by CLVECT_1:4
             .= x.|.( (-(1r))*' * y) by Th21
             .= x.|.( (-1r) * y) by COMPLEX1:115,119;
   hence thesis by CLVECT_1:4;
end;

theorem Th25:
(-x).|.y = - x.|.y
proof
     (-x) .|. y = ((-1r)*x) .|. y by CLVECT_1:4
             .= (-1) * x .|. y by Def13,COMPLEX1:def 7;
   hence thesis;
end;

theorem Th26:
x.|.(-y) = - x.|.y
proof
     x.|.(-y) = (-x).|.y by Th24;
   hence thesis by Th25;
end;

theorem Th27:
(-x).|.(-y) = x.|.y
proof
     (-x).|.(-y) = - x.|.(-y) by Th25
                .= - ( - x .|. y ) by Th26;
   hence thesis;
end;

theorem Th28:
(x-y).|.z = x.|.z - y.|.z
proof
     (x - y) .|. z = x .|. z + (-y) .|. z by Def13
                .= x .|. z + ( - y .|. z ) by Th25;
   hence thesis;
end;

theorem Th29:
x.|.(y-z) = x.|.y - x.|.z
proof
     x .|. (y - z) = x .|. y + x .|. (-z) by Th19
                .= x .|. y + ( - x .|. z ) by Th26;
   hence thesis;
end;

theorem
  (x-y).|.(u-v) = x.|.u - x.|.v - y.|.u + y.|.v
proof
     (x - y) .|. (u - v) = x .|. (u - v) - y .|. (u - v) by Th28
                      .= ( x .|. u - x .|. v ) - y .|. (u - v) by Th29
                      .= ( x .|. u - x .|. v ) - ( y .|. u - y .|. v ) by Th29;
   hence thesis;
end;

theorem Th31:
(0.X).|.x = 0
proof
     0'(X) .|. x = (x + (-x)) .|. x by RLVECT_1:16
              .= x .|. x + (-x) .|. x by Def13
              .= x .|. x + ( - x .|. x ) by Th25;
   hence thesis;
end;

theorem Th32:
x.|.0.X = 0
proof
     x.|.0.X = ((0.X).|.x)*' by Def13
          .= 0c by Th31,COMPLEX1:113;
   hence thesis;
end;

theorem Th33:
(x+y).|.(x+y) = x.|.x + x.|.y + y.|.x + y.|.y
proof
     (x+y).|.(x+y) = x.|.(x+y) + y.|.(x+y) by Def13
                   .= (x.|.x + x.|.y) + y.|.(x+y) by Th19
                   .= (x.|.x + x.|.y) + (y.|.x + y.|.y) by Th19;
  hence thesis;
end;

theorem
  (x+y).|.(x-y) = x.|.x - x.|.y + y.|.x - y.|.y
proof
     (x + y) .|. (x - y) = x .|. (x - y) + y .|. (x - y) by Def13
                   .= (x .|. x - x .|. y) + y .|. (x - y) by Th29
                   .= (x .|. x - x .|. y) + (y .|. x - y .|. y) by Th29
                   .= (x.|.x - x.|.y) + y.|.x + -y.|.y;
   hence thesis;
end;

theorem Th35:
(x-y).|.(x-y) = x.|.x - x.|.y - y.|.x + y.|.y
proof
     (x - y) .|. (x - y) = x .|. (x - y) - y .|. (x - y) by Th28
                   .= x .|. x - x .|. y - y .|. (x - y) by Th29
                   .= x.|.x - x.|.y - ( y.|.x - y.|.y ) by Th29;
  hence thesis;
end;

Lm10:
for p,q being Complex, x,y being Point of X holds
 (p*x + q*y).|.(p*x + q*y)
   = p*p*' *(x.|.x) + p*q*' *(x.|.y) + p*' *q*(y.|.x) + q*q*' *(y.|.y)
proof
   let p,q be Complex;
   let x,y being Point of X;
     (p*x+q*y).|.(p*x+q*y)
     = p * (x.|.(p*x + q*y)) + q * (y.|.(p*x + q*y)) by Th22
    .= p * (p*' *(x.|.x) + q*' *(x.|.y)) + q * (y.|.(p*x + q*y)) by Th23
    .= p*p*' *(x.|.x) + p*q*' *(x.|.y) + (q * (p*' *(y.|.x) + q*' *(y.|.y)))
        by Th23
    .= p*p*' *(x.|.x) + p*q*' *(x.|.y) + (q*p*' *(y.|.x) + q*q*' *(y.|.y));
   hence thesis;
end;

theorem Th36:
|.(x.|.x).| = Re(x.|.x)
proof
  Re (x.|.x) >= 0 & Im (x.|.x) = 0 by Def13;
     then |.Re(x.|.x)+Im(x.|.x)*<i>.| = Re (x.|.x) by ABSVALUE:def 1;
    hence thesis by COMPLEX1:29;
end;

theorem Th37:  ::Schwarz's inequality
|.(x.|.y).| <= sqrt|.(x.|.x).| * sqrt|.(y.|.y).|
proof
A1:y = 0'(X) implies |.(x.|.y).| <= sqrt|.(x.|.x).| * sqrt|.(y.|.y).|
   proof
     assume
A2:  y = 0'(X);
      then y.|.y = 0c by Def13;
     hence thesis by A2,Th32,COMPLEX1:130,SQUARE_1:82;
   end;
     y <> 0'(X) implies |.(x.|.y).| <= sqrt|.(x.|.x).| * sqrt|.(y.|.y).|
   proof
     assume y <> 0'(X);
then A3:  y.|.y <> 0c by Def13;
     reconsider c1 = |.(y.|.y).|+0*<i> as Element of COMPLEX by XCMPLX_0:def 2;
     set c2 = -(x.|.y);
A4: Re (y.|.y) >= 0 & Im (y.|.y) = 0 by Def13;
     then |.Re(y.|.y)+Im(y.|.y)*<i>.| = Re (y.|.y) by ABSVALUE:def 1;
     then A5: |.(y.|.y).| = Re (y.|.y) by COMPLEX1:29;
then A6: (y.|.y) = c1 by A4,COMPLEX1:29;
       ((c1*x+c2*y).|.(c1*x+c2*y))
      = c1*c1*' *(x.|.x) + c1*c2*' *(x.|.y)
       +c1*' *c2*(y.|.x) + c2*c2*' *(y.|.y) by Lm10
     .= c1*(c1*' *(x.|.x)) + c1*(c2*' *(x.|.y))
       +c1*' *(c2*(y.|.x)) + c1*(c2*c2*') by A4,A5,COMPLEX1:29
     .= c1*(c1*' *(x.|.x) + c2*' *(x.|.y))
       +c1*(c2*(y.|.x)) + c1*(c2*c2*') by A6,Def13
     .= c1*(c1*' *(x.|.x) + c2*' *(x.|.y) + c2*(y.|.x) + c2*c2*')
     .= c1*(c1*(x.|.x) + (x.|.y)*c2*' + c2*(y.|.x) + c2*c2*') by A6,Def13
     .= c1*(c1*(x.|.x) + c2*(y.|.x));
then A7: Re( c1*(c1*(x.|.x) + c2*(y.|.x)) ) >= 0 &
     Im( c1*(c1*(x.|.x) + c2*(y.|.x)) ) = 0 by Def13;
       Re( c1*(c1*(x.|.x) + c2*(y.|.x)) )
       = Re c1 * Re (c1*(x.|.x) + c2*(y.|.x))
       - Im c1 * Im (c1*(x.|.x) + c2*(y.|.x)) by COMPLEX1:24
      .= Re c1 * Re (c1*(x.|.x) + c2*(y.|.x))
       - 0 * Im (c1*(x.|.x) + c2*(y.|.x)) by COMPLEX1:28
      .= Re c1 * Re (c1*(x.|.x) + c2*(y.|.x));
then A8: Re c1 >= 0 & Re (c1*(x.|.x) + c2*(y.|.x)) >= 0 or
     Re c1 <= 0 & Re (c1*(x.|.x) + c2*(y.|.x)) <= 0 by A7,SQUARE_1:25;
       |.(y.|.y).| <> 0 by A3,COMPLEX1:131;
then A9: Re (c1*(x.|.x)) + Re (c2*(y.|.x)) >= 0 by A4,A5,A8,COMPLEX1:29,
19;
      Re (c2*(y.|.x)) = Re (-(x.|.y)*(y.|.x))
                    .= - Re(x.|.y * y.|.x) by COMPLEX1:34
                    .= - Re((x.|.y) * (x.|.y)*') by Def13;
     then Re (c1*(x.|.x)) - Re((x.|.y) * (x.|.y)*') >= 0 by A9;
then A10: Re (c1*(x.|.x)) >= Re((x.|.y) * (x.|.y)*') + 0 by XREAL_1:21;
A11: Re((x.|.y) * (x.|.y)*') = (Re(x.|.y))^2 + (Im(x.|.y))^2
       by COMPLEX1:126;
       (Re(x.|.y))^2 >= 0 & (Im(x.|.y))^2 >= 0 by XREAL_1:65;
then A12: Re((x.|.y) * (x.|.y)*') >= 0 + 0 by A11,XREAL_1:9;
     then abs(Re((x.|.y) * (x.|.y)*')) = Re((x.|.y) * (x.|.y)*')
       by ABSVALUE:def 1;
then A13: abs(Re (c1*(x.|.x))) >= abs(Re((x.|.y) * (x.|.y)*'))
       by A10,A12,ABSVALUE:def 1;
  Im c1 = 0 & Im(x.|.x) = 0 by A4,A5,Def13,COMPLEX1:29;
then A14: Im(c1*(x.|.x)) = Re c1 * 0 + Re (x.|.x)*0 by COMPLEX1:24;
then A15: Im(c1*(x.|.x)) = 0 & Im((x.|.y) * (x.|.y)*') = 0 by COMPLEX1:126;
       |.c1*(x.|.x).| = abs(Re (c1*(x.|.x))) by A14,COMPLEX1:136;
     then |.c1*(x.|.x).| >= |.(x.|.y)*(x.|.y)*' .| by A13,A15,COMPLEX1:136;
     then |.(x.|.x).|*|.(y.|.y).| >= |.(x.|.y)*(x.|.y)*'.| by A6,COMPLEX1:151;
     then |.(x.|.x).|*|.(y.|.y).| >= |.(x.|.y).|*|.(x.|.y)*'.| by COMPLEX1:151
;
     then |.(x.|.x).|*|.(y.|.y).| >= |.(x.|.y).|*|.(x.|.y).| by COMPLEX1:139;
then A16: |.(x.|.x).|*|.(y.|.y).| >= |.(x.|.y).|^2;
       |.(x.|.y).|^2 >= 0 by XREAL_1:65;
then A17: sqrt(|.(x.|.x).|*|.(y.|.y).|) >= sqrt(|.(x.|.y).|^2)
       by A16,SQUARE_1:94;
A18: |.(x.|.x).| >= 0 & |.(y.|.y).| >= 0 & |.(x.|.y).| >= 0
       by COMPLEX1:132;
     then sqrt|.(x.|.x).| * sqrt|.(y.|.y).| >= sqrt(|.(x.|.y).|^2)
       by A17,SQUARE_1:97;
     hence thesis by A18,SQUARE_1:89;
   end;
   hence thesis by A1;
end;

definition let X; let x, y;
  pred x, y are_orthogonal means :Def14:
   x .|. y = 0;
  symmetry by Def13,COMPLEX1:113;
end;

theorem
  x, y are_orthogonal implies x, - y are_orthogonal
proof
  assume x, y are_orthogonal;
  then - x .|. y = - 0 by Def14;
  then x .|. (-y) = 0 by Th26;
  hence thesis by Def14;
end;

theorem
  x, y are_orthogonal implies -x, y are_orthogonal
proof
  assume x, y are_orthogonal;
  then - x .|. y = - 0 by Def14;
  then (-x) .|. y = 0 by Th25;
  hence thesis by Def14;
end;

theorem
  x, y are_orthogonal implies -x, -y are_orthogonal
proof
  assume x, y are_orthogonal;
  then x .|. y = 0 by Def14;
  then (-x) .|. (-y) = 0 by Th27;
  hence thesis by Def14;
end;

theorem
  x, 0.X are_orthogonal
proof
     (0.X).|.x = 0 by Th31;
   hence thesis by Def14;
end;

theorem
  x,y are_orthogonal implies (x+y).|.(x+y) = x.|.x + y.|.y
proof
   assume A1:x, y are_orthogonal;
then A2:x .|. y = 0c by Def14;
 y .|. x = 0c by A1,Def14;
   then (x + y) .|. (x + y) = x.|.x + 0c + y.|.y by A2,Th33;
   hence thesis;
end;

theorem
  x,y are_orthogonal implies (x-y).|.(x-y) = x.|.x + y.|.y
proof
   assume A1:x,y are_orthogonal;
then A2:x.|.y = 0 by Def14;
     (x-y).|.(x-y) = x.|.x - x.|.y - y.|.x + y.|.y by Th35
                .= x.|.x + y.|.y - 0 by A1,A2,Def14;
  hence thesis;
end;

definition let X, x;
  func ||.x.|| -> Real equals
  sqrt |.(x.|.x).|;
 correctness;
end;

theorem Th44:
||.x.|| = 0 iff x = 0.X
proof
   thus ||.x.|| = 0 implies x = 0'(X)
   proof
     assume ||.x.|| = 0;
then A1:  sqrt |.(x.|.x).| = 0;
       0 <= Re (x.|.x) by Def13;
     then 0 <= |.(x.|.x).| by Th36;
     then |.(x.|.x).| = 0 by A1,SQUARE_1:92;
     then x.|.x = 0c by COMPLEX1:131;
     hence thesis by Def13;
   end;
   assume x = 0'(X);
   then x.|.x = 0c by Def13;
   hence thesis by COMPLEX1:130,SQUARE_1:82;
end;

theorem Th45:
||.a * x.|| = |.a.| * ||.x.||
proof
A1:0 <= |.a*a.| by COMPLEX1:132;
     0 <= Re (x.|.x) by Def13;
then A2:0 <= |.(x.|.x).| by Th36;
A3:0 <= |.a.| by COMPLEX1:132;
     ||.a*x.|| = sqrt |.(a*(x.|.(a*x))).| by Def13
            .= sqrt |.(a*(a*' *(x.|.x))).| by Th20
            .= sqrt |.((a*a*')*(x.|.x)).|
            .= sqrt (|.(a*a*').|*|.(x.|.x).|) by COMPLEX1:151
            .= sqrt (|.a*a.| * |.(x.|.x).|) by COMPLEX1:155
            .= sqrt |.a*a.| * sqrt |.(x.|.x).| by A1,A2,SQUARE_1:97
            .= sqrt (|.a.|^2) * sqrt |.(x.|.x).| by COMPLEX1:151
            .= |.a.| * sqrt |.(x.|.x).| by A3,SQUARE_1:89;
   hence thesis;
end;

theorem Th46:
0 <= ||.x.||
proof
     0 <= Re(x.|.x) by Def13;
   then 0 <= |.(x.|.x).| by Th36;
   then 0 <= sqrt |.(x.|.x).| by SQUARE_1:def 4;
   hence thesis;
end;

theorem Th47:
|.(x.|.y).| <= ||.x.|| * ||.y.|| by Th37;

theorem Th48:
||.x + y.|| <= ||.x.|| + ||.y.||
proof
A1:||.x + y.|| >= 0 by Th46;
     Re ((x+y).|.(x+y)) >= 0 by Def13;
then A2:|.((x + y).|.(x + y)).| >= 0 by Th36;
A3:||.x + y.||^2 >= 0 by XREAL_1:65;
     sqrt ||.x + y.||^2 = sqrt |.((x + y).|.(x + y)).| by A1,SQUARE_1:89;
   then A4: ||.x + y.||^2 = |.((x + y).|.(x + y)).| by A2,A3,SQUARE_1:96;
A5:Re(x.|.x + x.|.y + y.|.x + y.|.y)
    = Re(x.|.x + x.|.y + y.|.x) + Re(y.|.y) by COMPLEX1:19
   .= Re(x.|.x + x.|.y) + Re(y.|.x) + Re(y.|.y) by COMPLEX1:19
   .= Re(x.|.x) + Re(x.|.y) + Re(y.|.x) + Re(y.|.y) by COMPLEX1:19
   .= |.(x.|.x).| + Re(x.|.y) + Re(y.|.x) + Re(y.|.y) by Th36
   .= |.(x.|.x).| + Re(x.|.y) + Re(y.|.x) + |.(y.|.y).| by Th36;
    A6: Re(x.|.y) = Re((x.|.y)*') by COMPLEX1:112 .= Re(y.|.x) by Def13;
A7:Im(x.|.x + x.|.y + y.|.x + y.|.y)
    = Im(x.|.x + x.|.y + y.|.x) + Im(y.|.y) by COMPLEX1:19
   .= Im(x.|.x + x.|.y) + Im(y.|.x) + Im(y.|.y) by COMPLEX1:19
   .= Im(x.|.x) + Im(x.|.y) + Im(y.|.x) + Im(y.|.y) by COMPLEX1:19
   .= 0 + Im(x.|.y) + Im(y.|.x) + Im(y.|.y) by Def13
   .= Im(x.|.y) + Im(y.|.x) + 0 by Def13;
     -Im(x.|.y) = Im((x.|.y)*') by COMPLEX1:112 .= Im(y.|.x) by Def13;
then A8:Im(x.|.x + x.|.y + y.|.x + y.|.y)
    = 0 by A7;
     Re(x.|.x + x.|.y + y.|.x + y.|.y)
    = Re((x + y).|.(x + y)) by Th33;
then A9:Re(x.|.x + x.|.y + y.|.x + y.|.y) >= 0 by Def13;
     (x.|.x + x.|.y + y.|.x + y.|.y)
    = Re(x.|.x + x.|.y + y.|.x + y.|.y)+0*<i> by A8,COMPLEX1:29;
   then |.(x.|.x + x.|.y + y.|.x + y.|.y).|
    = |.(x.|.x).| + 2*Re(x.|.y) + |.(y.|.y).| by A5,A6,A9,ABSVALUE:def 1;
then A10:||.x + y.||^2 = 2*Re(x.|.y) + (|.(x.|.x).| + |.(y.|.y).|) by A4,Th33;
     |.(x.|.x).| >= 0 by COMPLEX1:132;
   then (sqrt |.(x.|.x).|)^2 = |.(x.|.x).| by SQUARE_1:def 4;
then A11:|.(x.|.x).| = ||.x.||^2;
     |.(y.|.y).| >= 0 by COMPLEX1:132;
   then (sqrt |.(y.|.y).|)^2 = |.(y.|.y).| by SQUARE_1:def 4;
then A12:|.(y.|.y).| = ||.y.||^2;
     Re(x.|.y) <= |.(x.|.y).| & |.(x.|.y).| <= ||.x.||*||.y.||
     by Th47,COMPLEX1:140;
   then Re(x.|.y) <= ||.x.||*||.y.|| by XXREAL_0:2;
   then 2*Re(x.|.y) <= 2*(||.x.||*||.y.||) by XREAL_1:66;
   then ||.x + y.||^2 <= 2*(||.x.||*||.y.||) + (||.x.||^2 + |.(y.|.y).|)
     by A10,A11,XREAL_1:8;
   then ||.x + y.||^2 <= ||.x.||^2 + 2*||.x.||*||.y.|| + ||.y.||^2
     by A12;
then A13:||.x + y.||^2 <= (||.x.|| + ||.y.||)^2;
     ||.x.|| >= 0 & ||.y.|| >= 0 by Th46;
   then ||.x.|| + ||.y.|| >= 0 + 0 by XREAL_1:9;
   hence thesis by A13,SQUARE_1:78;
end;

theorem Th49:
||.-x.|| = ||.x.||
proof
     ||.-x.|| = ||.(-1r) * x.|| by CLVECT_1:4
           .= |.-1r.| * ||.x.|| by Th45
           .= |.1r.| * ||.x.|| by COMPLEX1:138;
   hence thesis by COMPLEX1:134;
end;

theorem Th50:
||.x.|| - ||.y.|| <= ||.x - y.||
proof
     (x - y) + y = x - (y - y) by RLVECT_1:43
              .= x - 0'(X) by RLVECT_1:28
              .= x by RLVECT_1:26;
   then ||.x.|| <= ||.x - y.|| + ||.y.|| by Th48;
   hence thesis by XREAL_1:22;
end;

theorem
  abs(||.x.|| - ||.y.||) <= ||.x - y.||
proof
A1:||.x.|| - ||.y.|| <= ||.x - y.|| by Th50;
     (y - x) + x = y - (x - x) by RLVECT_1:43
              .= y - 0'(X) by RLVECT_1:28
              .= y by RLVECT_1:26;
   then ||.y.|| <= ||.y - x.|| + ||.x.|| by Th48;
   then ||.y.|| - ||.x.|| <= ||.y - x.|| by XREAL_1:22;
   then ||.y.|| - ||.x.|| <= ||.(-x) + y.||;
   then ||.y.|| - ||.x.|| <= ||.-(x - y).|| by RLVECT_1:47;
   then ||.y.|| - ||.x.|| <= ||.x - y.|| by Th49;
   then -(||.x - y.||) <= -(||.y.|| - ||.x.||) by XREAL_1:26;
   then -(||.x - y.||) <= ||.x.|| - ||.y.||;
   hence thesis by A1,ABSVALUE:12;
end;

definition let X, x, y;
 func dist(x,y) -> Real equals
  ||.x - y.||;
 correctness;
end;

theorem Th52:
dist(x,y) = dist(y,x)
proof
  thus dist(x,y) = ||.-(y-x).|| by RLVECT_1:47
              .= dist(y,x) by Th49;
end;

definition let X, x, y;
  redefine func dist(x,y);
  commutativity by Th52;
end;

theorem Th53:
  dist(x,x) = 0
proof
  thus dist(x,x) = ||.0'(X).|| by RLVECT_1:28
              .= 0 by Th44;
end;

theorem
  dist(x,z) <= dist(x,y) + dist(y,z)
proof
         dist(x,z) = ||.(x-z)+0'(X).|| by RLVECT_1:10
              .= ||.(x-z)+(y-y).|| by RLVECT_1:28
              .= ||.x-(z-(y-y)).|| by RLVECT_1:43
              .= ||.x-(y+(z-y)).|| by RLVECT_1:43
              .= ||.(x-y)-(z-y).|| by RLVECT_1:41
              .= ||.(x-y)+(y-z).|| by RLVECT_1:47;
     then dist(x,z) <= ||.x-y.|| + ||.y-z.|| by Th48;
     then dist(x,z) <= dist(x,y) + ||.y-z.||;
     hence thesis;
end;

theorem Th55:
x <> y iff dist(x,y) <> 0
proof
     thus x <> y implies dist(x,y) <> 0
     proof
          assume that
     A1:   x <> y and
     A2:   dist(x,y) = 0;
              ||.x-y.|| = 0 by A2;
          then x - y = 0'(X) by Th44;
          hence contradiction by A1,RLVECT_1:35;
     end;
     thus thesis by Th53;
end;

theorem Th56:
  dist(x,y) >= 0 by Th46;

theorem
    x <> y iff dist(x,y) > 0
proof
  thus x <> y implies dist(x,y) > 0
  proof
    assume x <> y;
    then dist(x,y) <> 0 by Th55;
    hence thesis by Th56;
  end;
  thus thesis by Th53;
end;

theorem
  dist(x,y) = sqrt |.((x-y) .|. (x-y)).|;

theorem
  dist(x + y,u + v) <= dist(x,u) + dist(y,v)
proof
         dist(x + y,u + v) = ||.((-u) + (-v)) + (x + y).|| by
RLVECT_1:45
  .= ||.x + ((-u) + (-v)) + y.|| by RLVECT_1:def 6
  .= ||.x - u + (-v) + y.|| by RLVECT_1:def 6
  .= ||.x - u + (y - v).|| by RLVECT_1:def 6;
     then dist(x + y,u + v) <= ||.x - u.|| + ||.y - v.|| by Th48;
     then dist(x + y,u + v) <= dist(x,u) + ||.y - v.||;
     hence thesis;
end;

theorem
  dist(x - y,u - v) <= dist(x,u) + dist(y,v)
proof
         dist(x - y,u - v) = ||.((x - y) - u) + v.|| by RLVECT_1:43
  .= ||.(x - (u + y)) + v.|| by RLVECT_1:41
  .= ||.((x - u) - y) + v.|| by RLVECT_1:41
  .= ||.(x - u) - (y - v).|| by RLVECT_1:43
  .= ||.(x - u) + -(y - v).||;
     then dist(x - y,u - v) <= ||.x - u.|| + ||.-(y - v).|| by Th48;
     then dist(x - y,u - v) <= ||.x - u.|| + ||.y - v.|| by Th49;
     then dist(x - y,u - v) <= dist(x,u) + ||.y - v.||;
     hence thesis;
end;

theorem
  dist(x - z, y - z) = dist(x,y)
proof
     thus dist(x - z,y - z) = ||.((x - z) - y) + z.|| by RLVECT_1:43
  .= ||.(x - (y + z)) + z.|| by RLVECT_1:41
  .= ||.((x - y) - z) + z.|| by RLVECT_1:41
  .= ||.(x - y) - (z - z).|| by RLVECT_1:43
  .= ||.(x - y) - 0'(X).|| by RLVECT_1:28
  .= dist(x,y) by RLVECT_1:26;
end;

theorem
  dist(x - z,y - z) <= dist(z,x) + dist(z,y)
proof
         dist(x - z,y - z) = ||.(x - z) + (z - y).|| by RLVECT_1:47
  .= ||.-(z - x) + (z - y).|| by RLVECT_1:47;
     then dist(x - z,y - z) <= ||.-(z - x).|| + ||.z - y.|| by Th48;
     then dist(x - z,y - z) <= ||.z - x.|| + ||.z - y.|| by Th49;
     then dist(x - z,y - z) <= dist(z,x) + ||.z - y.||;
     hence thesis;
end;

reserve seq, seq1, seq2, seq3 for sequence of X;
reserve k, n, m for Element of NAT;

definition
  canceled 2;
end;

theorem Th63:
seq1 + seq2 = seq2 + seq1
proof
     now let n;
     thus (seq1 + seq2).n = seq2.n + seq1.n by NORMSP_1:def 5
                    .= (seq2 + seq1).n by NORMSP_1:def 5;
   end;
   hence thesis by FUNCT_2:113;
end;

definition let X, seq1, seq2;
 redefine func seq1 + seq2;
 commutativity by Th63;
end;

theorem
  seq1 + (seq2 + seq3) = (seq1 + seq2) + seq3
proof
         now let n;
     thus
         (seq1 + (seq2 + seq3)).n = seq1.n + (seq2 + seq3).n by NORMSP_1:def 5
  .= seq1.n + (seq2.n + seq3.n) by NORMSP_1:def 5
  .= (seq1.n + seq2.n) + seq3.n by RLVECT_1:def 6
  .= (seq1 + seq2).n + seq3.n by NORMSP_1:def 5
  .= ((seq1 + seq2) + seq3).n by NORMSP_1:def 5;
     end;
     hence thesis by FUNCT_2:113;
end;

theorem
  seq1 is constant & seq2 is constant & seq = seq1 + seq2 implies
 seq is constant
proof
     assume that
A1:   seq1 is constant and
A2:   seq2 is constant and
A3:   seq = seq1 + seq2;
     consider x such that
A4:   for n holds seq1.n = x by A1,NORMSP_1:def 4;
     consider y such that
A5:   for n holds seq2.n = y by A2,NORMSP_1:def 4;
     take z = x + y;
         now let n;
     thus seq.n = seq1.n + seq2.n by A3,NORMSP_1:def 5
          .= x + seq2.n by A4
          .= z by A5;
     end;
     hence thesis;
end;

theorem
  seq1 is constant & seq2 is constant & seq = seq1 - seq2 implies
 seq is constant
proof
     assume that
A1:   seq1 is constant and
A2:   seq2 is constant and
A3:   seq = seq1 - seq2;
     consider x such that
A4:   for n holds seq1.n = x by A1,NORMSP_1:def 4;
     consider y such that
A5:   for n holds seq2.n = y by A2,NORMSP_1:def 4;
     take z = x - y;
         now let n;
     thus seq.n = seq1.n - seq2.n by A3,NORMSP_1:def 6
          .= x - seq2.n by A4
          .= z by A5;
     end;
     hence thesis;
end;

theorem
  seq1 is constant & seq = a * seq1 implies seq is constant
proof
     assume that
A1:   seq1 is constant and
A2:   seq = a * seq1;
     consider x such that
A3:   for n holds seq1.n = x by A1,NORMSP_1:def 4;
     take z = a * x;
         now let n;
     thus seq.n = a * seq1.n by A2,CLVECT_1:def 14
          .= z by A3;
     end;
     hence thesis;
end;

theorem Th68:
seq is constant iff for n holds seq.n = seq.(n + 1)
proof
     thus seq is constant implies for n holds seq.n=seq.(n + 1)
     proof
          assume seq is constant;
          then ex x st rng seq = {x} by NORMSP_1:27;
          hence thesis by NORMSP_1:21;
     end;
     assume for n holds seq.n = seq.(n + 1);
     then for n, k holds seq.n = seq.(n + k) by NORMSP_1:22;
     then for n, m holds seq.n = seq.m by NORMSP_1:23;
     hence ex x st for n holds seq.n = x by NORMSP_1:24;
end;

theorem Th69:
seq is constant iff for n , k holds seq.n = seq.(n + k)
proof
     thus seq is constant implies for n , k holds seq.n = seq.(n + k)
     proof
          assume seq is constant;
          then for n holds seq.n=seq.(n+1) by Th68;
          hence thesis by NORMSP_1:22;
     end;
     assume for n, k holds seq.n = seq.(n + k);
     then for n, m holds seq.n = seq.m by NORMSP_1:23;
     hence ex x st for n holds seq.n = x by NORMSP_1:24;
end;

theorem
  seq is constant iff for n, m holds seq.n = seq.m
proof
     thus seq is constant implies for n, m holds seq.n = seq.m
     proof
          assume seq is constant;
          then for n, k holds seq.n = seq.(n + k) by Th69;
          hence thesis by NORMSP_1:23;
     end;
     assume for n, m holds seq.n = seq.m;
     hence ex x st for n holds seq.n = x by NORMSP_1:24;
end;

theorem
  seq1 - seq2 = seq1 + -seq2
proof
    now let n;
     thus (seq1 - seq2).n = seq1.n - seq2.n by NORMSP_1:def 6
                    .= seq1.n + (-seq2).n by BHSP_1:def 10
                    .= (seq1 + -seq2).n by NORMSP_1:def 5;
  end;
  hence thesis by FUNCT_2:113;
end;

theorem
  seq = seq + 0.X
proof
         now let n;
     thus (seq + 0'(X)).n = seq.n + 0'(X) by BHSP_1:def 12
                    .= seq.n by RLVECT_1:10;
     end;
     hence thesis by FUNCT_2:113;
end;

theorem
  a * (seq1 + seq2) = a * seq1 + a * seq2
proof
         now let n;
     thus (a * (seq1 + seq2)).n = a * (seq1 + seq2).n by CLVECT_1:def 14
                          .= a * (seq1.n + seq2.n) by NORMSP_1:def 5
                          .= a * seq1.n + a * seq2.n by CLVECT_1:def 2
                          .= (a * seq1).n + a * seq2.n by CLVECT_1:def 14
                          .= (a * seq1).n + (a * seq2).n by CLVECT_1:def 14
                          .= (a * seq1 + a * seq2).n by NORMSP_1:def 5;
     end;
     hence thesis by FUNCT_2:113;
end;

theorem
  (a + b) * seq = a * seq + b * seq
proof
         now let n;
     thus ((a + b) * seq).n = (a + b) * seq.n by CLVECT_1:def 14
                      .= a * seq.n + b * seq.n by CLVECT_1:def 2
                      .= (a * seq).n + b * seq.n by CLVECT_1:def 14
                      .= (a * seq).n + (b * seq).n by CLVECT_1:def 14
                      .= (a * seq + b * seq).n by NORMSP_1:def 5;
     end;
     hence thesis by FUNCT_2:113;
end;

theorem
  (a * b) * seq = a * (b * seq)
proof
         now let n;
     thus ((a * b) * seq).n = (a * b) * seq.n by CLVECT_1:def 14
                      .= a * (b * seq.n) by CLVECT_1:def 2
                      .= a * (b * seq).n by CLVECT_1:def 14
                      .= (a * (b * seq)).n by CLVECT_1:def 14;
     end;
     hence thesis by FUNCT_2:113;
end;

theorem
  1r * seq = seq
proof
    now let n;
     thus (1r * seq).n = 1r * seq.n by CLVECT_1:def 14
                .= seq.n by CLVECT_1:def 2;
  end;
  hence thesis by FUNCT_2:113;
end;

theorem
  (-1r) * seq = - seq
proof
         now let n;
     thus ((-1r) * seq).n = (-1r) * seq.n by CLVECT_1:def 14
                   .= - seq.n by CLVECT_1:4
                   .= (-seq).n by BHSP_1:def 10;
     end;
     hence thesis by FUNCT_2:113;
end;

theorem
  seq - x = seq + -x
proof
         now let n;
     thus (seq - x).n = seq.n - x by NORMSP_1:def 7
                .= (seq + -x).n by BHSP_1:def 12;
     end;
     hence thesis by FUNCT_2:113;
end;

theorem
  seq1 - seq2 = - (seq2 - seq1)
proof
         now let n;
     thus (seq1 - seq2).n = seq1.n - seq2.n by NORMSP_1:def 6
                    .= - (seq2.n - seq1.n) by RLVECT_1:47
                    .= - (seq2 - seq1).n by NORMSP_1:def 6
                    .= (- (seq2 - seq1)).n by BHSP_1:def 10;
     end;
     hence thesis by FUNCT_2:113;
end;

theorem
  seq = seq - 0.X
proof
         now let n;
     thus (seq - 0'(X)).n = seq.n - 0'(X) by NORMSP_1:def 7
                    .= seq.n by RLVECT_1:26;
     end;
     hence thesis by FUNCT_2:113;
end;

theorem
  seq = - ( - seq )
proof
    now let n;
     thus (- ( - seq )).n = - (- seq).n by BHSP_1:def 10
                    .= - ( - seq.n) by BHSP_1:def 10
                    .= seq.n by RLVECT_1:30;
  end;
  hence thesis by FUNCT_2:113;
end;

theorem
  seq1 - (seq2 + seq3) = (seq1 - seq2) - seq3
proof
    now let n;
     thus
         (seq1 - (seq2 + seq3)).n = seq1.n - (seq2 + seq3).n by NORMSP_1:def 6
                             .= seq1.n - (seq2.n + seq3.n) by NORMSP_1:def 5
                             .= (seq1.n - seq2.n) - seq3.n by RLVECT_1:41
                             .= (seq1 - seq2).n - seq3.n by NORMSP_1:def 6
                             .= ((seq1 - seq2) - seq3).n by NORMSP_1:def 6;
  end;
  hence thesis by FUNCT_2:113;
end;

theorem
  (seq1 + seq2) - seq3 = seq1 + (seq2 - seq3)
proof
         now let n;
     thus
         ((seq1 + seq2) - seq3).n = (seq1 + seq2).n - seq3.n by NORMSP_1:def 6
                             .= (seq1.n + seq2.n) - seq3.n by NORMSP_1:def 5
                             .= seq1.n + (seq2.n - seq3.n) by RLVECT_1:def 6
                             .= seq1.n + (seq2 - seq3).n by NORMSP_1:def 6
                             .= (seq1 + (seq2 - seq3)).n by NORMSP_1:def 5;
     end;
     hence thesis by FUNCT_2:113;
end;

theorem
  seq1 - (seq2 - seq3) = (seq1 - seq2) + seq3
proof
   now let n;
  thus
      (seq1 - (seq2 - seq3)).n = seq1.n - (seq2 - seq3).n by NORMSP_1:def 6
                          .= seq1.n - (seq2.n - seq3.n) by NORMSP_1:def 6
                          .= (seq1.n - seq2.n) + seq3.n by RLVECT_1:43
                          .= (seq1 - seq2).n + seq3.n by NORMSP_1:def 6
                          .= ((seq1 - seq2) + seq3).n by NORMSP_1:def 5;
  end;
  hence thesis by FUNCT_2:113;
end;

theorem
    a * (seq1 - seq2) = a * seq1 - a * seq2
proof
    now let n;
    thus
        (a * (seq1 - seq2)).n = a * (seq1 - seq2).n by CLVECT_1:def 14
                          .= a * (seq1.n - seq2.n) by NORMSP_1:def 6
                          .= a * seq1.n - a * seq2.n by CLVECT_1:10
                          .= (a * seq1).n - a * seq2.n by CLVECT_1:def 14
                          .= (a * seq1).n - (a * seq2).n by CLVECT_1:def 14
                          .= (a * seq1 - a * seq2).n by NORMSP_1:def 6;
  end;
  hence thesis by FUNCT_2:113;
end;

begin :: Complex unitary space of complex sequence

theorem Th86:
ex f be Function of
 [: the_set_of_l2ComplexSequences, the_set_of_l2ComplexSequences :], COMPLEX st
 (for x,y be set st
  x in the_set_of_l2ComplexSequences & y in the_set_of_l2ComplexSequences
   holds f.(x,y) = Sum(seq_id(x)(#)(seq_id(y))*') )
proof
   set X = the_set_of_l2ComplexSequences;
   deffunc F(set,set) = Sum(seq_id($1)(#)(seq_id($2))*');
A1:for x,y being set st x in X & y in X holds F(x,y) in COMPLEX;
     ex f being Function of [:X,X:],COMPLEX st
    for x,y being set st x in X & y in X holds
     f.(x,y) = F(x,y) from BINOP_1:sch 2(A1);
  hence thesis;
end;

definition
func cl_scalar -> Function of
 [:the_set_of_l2ComplexSequences, the_set_of_l2ComplexSequences:], COMPLEX
means
   (for x,y be set st
  x in the_set_of_l2ComplexSequences & y in the_set_of_l2ComplexSequences
   holds it.(x,y) = Sum(seq_id(x)(#)(seq_id(y))*'));
existence by Th86;
uniqueness
proof
   set X = the_set_of_l2ComplexSequences;
   let scalar1, scalar2 be Function of [: X, X :], COMPLEX such that
A1:(for x,y be set st x in X & y in X holds
     scalar1.(x,y) = Sum(seq_id(x)(#)(seq_id(y))*')) and
A2:(for x,y be set st x in X & y in X holds
     scalar2.(x,y) = Sum(seq_id(x)(#)(seq_id(y))*'));
     for x, y be set st x in X & y in X holds scalar1.(x,y) = scalar2.(x,y)
   proof
     let x,y be set such that
A3:  x in X & y in X;
     thus scalar1.(x,y) = Sum(seq_id(x)(#)(seq_id(y))*') by A1,A3
                       .= scalar2.(x,y) by A2,A3;
   end;
   hence thesis by BINOP_1:1;
end;
end;

registration
 cluster CUNITSTR (# the_set_of_l2ComplexSequences,
    Zero_(the_set_of_l2ComplexSequences,Linear_Space_of_ComplexSequences),
    Add_(the_set_of_l2ComplexSequences,Linear_Space_of_ComplexSequences),
    Mult_(the_set_of_l2ComplexSequences,Linear_Space_of_ComplexSequences),
    cl_scalar #) -> non empty;
coherence
proof
     the_set_of_l2ComplexSequences is non empty by Def11;
   hence thesis by STRUCT_0:def 1;
   end;
end;

definition
func Complex_l2_Space -> non empty CUNITSTR equals
 CUNITSTR (# the_set_of_l2ComplexSequences,
   Zero_(the_set_of_l2ComplexSequences,Linear_Space_of_ComplexSequences),
   Add_(the_set_of_l2ComplexSequences,Linear_Space_of_ComplexSequences),
   Mult_(the_set_of_l2ComplexSequences,Linear_Space_of_ComplexSequences),
   cl_scalar #);
correctness;
end;

theorem Th87:
for l be CUNITSTR st
 the CLSStruct of l is ComplexLinearSpace holds l is ComplexLinearSpace
proof
   let l be CUNITSTR such that
A1: the CLSStruct of l is ComplexLinearSpace;
     the carrier of l is non empty by A1,STRUCT_0:def 1;
   then reconsider l as non empty CLSStruct by STRUCT_0:def 1;
   reconsider l0=CLSStruct (# the carrier of l, 0.l, the add of l,
        the Mult of l #) as ComplexLinearSpace by A1;
A2:for v,w being VECTOR of l holds v + w = w + v
   proof
     let v,w be VECTOR of l;
     reconsider v1=v as VECTOR of l0;
     reconsider w1=w as VECTOR of l0;
     thus v+w =v1+w1
             .= w +v by RLVECT_1:def 3;
   end;
A3:for u,v,w being VECTOR of l holds (u + v) + w = u + (v + w)
   proof
     let u,v,w be VECTOR of l;
     reconsider u1=u as VECTOR of l0;
     reconsider v1=v as VECTOR of l0;
     reconsider w1=w as VECTOR of l0;
     thus (u + v) + w
        = (u1+v1)+w1
       .= u1+(v1+w1) by RLVECT_1:def 6
       .= u+(v+w);
   end;
A4:for v being VECTOR of l holds v + 0.l = v
   proof
     let v be VECTOR of l;
     reconsider v1=v as VECTOR of l0;
     thus v+0.l= v1 + 0.l0
              .= v by RLVECT_1:def 7;
   end;

A5:for v being VECTOR of l ex w being VECTOR of l st v + w = 0.l
   proof
     let v be VECTOR of l;
     reconsider v1=v as VECTOR of l0;
     consider w1 being VECTOR of l0 such that
A6:  v1 + w1 = 0.l0 by RLVECT_1:def 8;
     reconsider w = w1 as VECTOR of l;
A7:  v+w = 0.l by A6;
     take w;
     thus thesis by A7;
   end;

A8:for z being Complex for v,w being VECTOR of l holds
         z * (v + w) = z * v + z * w
   proof
     let z be Complex;
     let v,w be VECTOR of l;
     reconsider v1=v, w1=w as VECTOR of l0;
     thus z*(v+w) =z*(v1+w1)
        .=z*v1+z*w1 by CLVECT_1:def 2
       .= z*v +z*w;
   end;

A9:for z1,z2 be Complex for v being VECTOR of l holds
     (z1 + z2) * v = z1 * v + z2 * v
   proof
     let z1,z2 be Complex;
     let v be VECTOR of l;
     reconsider v1=v as VECTOR of l0;
     thus (z1+z2)*v =(z1+z2)*v1
       .=z1*v1+z2*v1 by CLVECT_1:def 2
       .= z1*v +z2*v;
   end;

A10:for z1,z2 be Complex, v being VECTOR of l holds
     (z1 * z2) * v = z1 * (z2 * v)
   proof
     let z1,z2 be Complex;
     let v be VECTOR of l;
     reconsider v1=v as VECTOR of l0;
     thus (z1*z2)*v =(z1*z2)*v1
       .=z1*(z2*v1) by CLVECT_1:def 2
       .= z1*(z2*v);
   end;
     for v being VECTOR of l holds 1r * v = v
   proof
     let v be VECTOR of l;
     reconsider v1=v as VECTOR of l0;
     thus 1r*v= 1r*v1
            .= v by CLVECT_1:def 2;
   end;
   hence thesis by A2,A3,A4,A5,A8,A9,A10,CLVECT_1:1;
end;

theorem
  for seq be Complex_Sequence st (for n be Element of NAT holds seq.n=0c) holds
  seq is summable & Sum seq = 0c
proof
   let seq be Complex_Sequence such that
A1:for n be Element of NAT holds seq.n=0c;
A2:for m be Element of NAT holds Partial_Sums (seq).m = 0c
   proof
     let m be Element of NAT;
     defpred P[Element of NAT] means seq.$1 = (Partial_Sums seq).$1;
A3:  P[0] by COMSEQ_3:def 7;
A4:  for k be Element of NAT st P[k] holds P[k+1]
     proof
       let k be Element of NAT such that
A5:    seq.k = (Partial_Sums (seq)).k;
       thus seq.(k+1) = 0c + (seq).(k+1)
                     .= seq.k + seq.(k+1) by A1
                     .= (Partial_Sums seq).(k+1) by A5,COMSEQ_3:def 7;
     end;
       for n be Element of NAT holds P[n] from NAT_1:sch 1(A3,A4);
     hence (Partial_Sums (seq)).m = seq.m .= 0c by A1;
   end;
     Sum seq = 0c & seq is summable
   proof
A6:  for p be Real st 0<p
      ex n be Element of NAT st
       for m be Element of NAT st n<=m holds |.((Partial_Sums seq).m-0c).|<p
     proof
       let p be Real such that
A7:    0<p;
       take 0;
       let m be Element of NAT such that 0<=m;
       thus |.((Partial_Sums (seq)).m-0c).|<p by A2,A7,COMPLEX1:130;
     end;
then A8:  Partial_Sums (seq) is convergent by COMSEQ_2:def 4;
     then lim (Partial_Sums (seq)) = 0c by A6,COMSEQ_2:def 5;
     hence thesis by A8,COMSEQ_3:def 8,def 10;
   end;
   hence thesis;
end;

registration
 cluster Complex_l2_Space -> Abelian add-associative right_zeroed
    right_complementable ComplexLinearSpace-like;
  coherence by Th16,Th87;
end;
