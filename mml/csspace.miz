:: Complex Linear Space of Complex Sequences
::  by Noboru Endou
::
:: Received January 26, 2004
:: Copyright (c) 2004 Association of Mizar Users

environ

 vocabularies RLVECT_1, FUNCT_1, ARYTM_1, RELAT_1, ABSVALUE, ORDINAL2, BINOP_1,
      SQUARE_1, FUNCT_2, RLSUB_1, SEQ_1, SEQ_2, SERIES_1, BHSP_1, SUPINF_2,
      RSSPACE, CLVECT_1, COMSEQ_1, COMPLEX1, PROB_2, ARYTM_3, CSSPACE,
      CFUNCT_1, PRE_TOPC, NORMSP_1, METRIC_1, SEQM_3, XCMPLX_0, FUNCOP_1;
 notations TARSKI, XBOOLE_0, SUBSET_1, PRE_TOPC, RELAT_1, DOMAIN_1, FUNCT_1,
      FUNCT_2, FUNCOP_1,
      SEQ_1, BINOP_1, STRUCT_0, ZFMISC_1, NUMBERS, XCMPLX_0, XREAL_0,
      REAL_1, SQUARE_1, COMPLEX1, COMSEQ_1, CFUNCT_1, COMSEQ_2, COMSEQ_3,
      SERIES_1, NAT_1, RLVECT_1, NORMSP_1, CLVECT_1;
 constructors REAL_1, NAT_1, DOMAIN_1, SQUARE_1, SEQ_2, SERIES_1, PREPOWER,
      PARTFUN1, BINOP_1, MEMBERED, CLVECT_1, COMSEQ_1, COMPLEX1, FINSEQ_4,
      COMSEQ_3, COMSEQ_2, COMPLEX2, ARYTM_0, NORMSP_1, BINOP_2, FUNCOP_1;
 registrations RELSET_1, STRUCT_0, SEQ_1, XREAL_0, MEMBERED, CLVECT_1, FUNCT_1,
      COMPLEX1, ORDINAL2, COMSEQ_1, COMSEQ_2, SUBSET_1, XCMPLX_0, FUNCOP_1;
 requirements SUBSET, REAL, BOOLE, NUMERALS, ARITHM;
 definitions TARSKI, RLVECT_1, CLVECT_1, STRUCT_0, NORMSP_1;
 theorems XBOOLE_0, STRUCT_0, RELAT_1, SQUARE_1, TARSKI, ABSVALUE, ZFMISC_1,
      REAL_1, SEQ_1, SERIES_1, COMSEQ_3, FUNCT_1, FUNCT_2, RLVECT_1, BINOP_1,
      XCMPLX_0, COMSEQ_1, CLVECT_1, COMPLEX1, COMSEQ_2, AXIOMS, NORMSP_1,
      FUNCOP_1;
 schemes NAT_1, BINOP_1, XBOOLE_0, BINOP_2, FUNCT_2, COMSEQ_1;

begin

definition
 func the_set_of_ComplexSequences -> non empty set means :Def1:
  for x being set holds x in it iff x is Complex_Sequence;
  existence
  proof
    defpred P[set] means $1 is Complex_Sequence;
    consider IT being set such that
A1:  for x being set holds x in IT
      iff x in Funcs(NAT,COMPLEX) & P[x] from XBOOLE_0:sch 1;
        IT is non empty
    proof
      consider zeroseq be Complex_Sequence;
          zeroseq in Funcs(NAT,COMPLEX) by FUNCT_2:11;
      hence thesis by A1;
    end;
    then reconsider IT as non empty set;
    take IT;
        for x being set holds x is Complex_Sequence implies x in IT
    proof
      let x be set;
      assume
A2:   x is Complex_Sequence;
      then x in Funcs(NAT,COMPLEX) by FUNCT_2:11;
      hence thesis by A1,A2;
    end;
    hence thesis by A1;
  end;
  uniqueness
  proof
    let X1,X2 be non empty set;
    assume that
A3: for x being set holds x in X1 iff x is Complex_Sequence and
A4: for x being set holds x in X2 iff x is Complex_Sequence;
A5: X1 c= X2
    proof
      let x be set;
      assume x in X1;
      then x is Complex_Sequence by A3;
      hence thesis by A4;
    end;
        X2 c= X1
    proof
      let x be set;
      assume x in X2;
      then x is Complex_Sequence by A4;
      hence thesis by A3;
    end;
    hence thesis by A5,XBOOLE_0:def 10;
  end;
end;

definition let z be set such that
A1:z in the_set_of_ComplexSequences;
 func seq_id(z) -> Complex_Sequence equals :Def2:
  z;
coherence by A1,Def1;
end;

definition let z be set such that
A1:z in COMPLEX;
 func C_id(z) -> Complex equals :Def3:
  z;
coherence by A1;
end;

theorem Th1:
ex ADD be BinOp of the_set_of_ComplexSequences st
  (for a,b being Element of the_set_of_ComplexSequences holds
    ADD.(a,b) = seq_id(a)+seq_id(b)) & ADD is commutative associative
proof
   defpred P[Element of the_set_of_ComplexSequences,
             Element of the_set_of_ComplexSequences,
             Element of the_set_of_ComplexSequences] means
   $3=seq_id($1)+seq_id($2);
A1:for x,y being Element of the_set_of_ComplexSequences
      ex z being Element of the_set_of_ComplexSequences st P[x,y,z]
   proof
     let x,y be Element of the_set_of_ComplexSequences;
       seq_id(x)+seq_id(y) is Element of the_set_of_ComplexSequences by Def1;
     hence thesis;
   end;
     ex ADD be BinOp of the_set_of_ComplexSequences st
     for a,b being Element of the_set_of_ComplexSequences holds
       P[a,b,ADD.(a,b)] from BINOP_1:sch 1(A1);
   then consider ADD be BinOp of the_set_of_ComplexSequences such that
A2:for a,b being Element of the_set_of_ComplexSequences holds
     ADD.(a,b) = seq_id(a)+seq_id(b);
A3:ADD is commutative
   proof
       now
       let a,b being Element of the_set_of_ComplexSequences;
       thus ADD.(a,b) = seq_id(a)+seq_id(b) by A2
                     .= ADD.(b,a) by A2;
     end;
     hence thesis by BINOP_1:def 2;
   end;
     ADD is associative
   proof
       now
       let a,b,c be Element of the_set_of_ComplexSequences;
A4:    seq_id(ADD.(b,c)) = ADD.(b,c) by Def2
                        .=seq_id(b)+seq_id(c) by A2;
A5:    seq_id(a)+seq_id(b) = ADD.(a,b) by A2
                          .=seq_id(ADD.(a,b)) by Def2;
       thus ADD.(a,ADD.(b,c)) = seq_id(a)+seq_id(ADD.(b,c)) by A2
                .= (seq_id(a)+seq_id(b))+seq_id(c) by A4,COMSEQ_1:9
                .= ADD.(ADD.(a,b),c) by A2,A5;
     end;
     hence thesis by BINOP_1:def 3;
   end;
   hence thesis by A2,A3;
end;

theorem Th2:
ex f be Function of [: COMPLEX, the_set_of_ComplexSequences :],
  the_set_of_ComplexSequences st
   for r,x be set st r in COMPLEX & x in the_set_of_ComplexSequences
      holds f.[r,x] = C_id(r) (#) seq_id(x)
proof
   deffunc F(set,set) = C_id($1) (#) seq_id($2);
A1:for r,x be set st r in COMPLEX & x in the_set_of_ComplexSequences holds
   F(r,x) in the_set_of_ComplexSequences by Def1;
     ex f be Function of
     [:COMPLEX, the_set_of_ComplexSequences:], the_set_of_ComplexSequences st
       for r,x be set st r in COMPLEX & x in the_set_of_ComplexSequences holds
         f.[r,x] = F(r,x) from FUNCT_2:sch 6(A1);
   hence thesis;
end;

definition
 func l_add -> BinOp of the_set_of_ComplexSequences means :Def4:
  for a,b being Element of the_set_of_ComplexSequences holds
   it.(a,b) = seq_id(a)+seq_id(b);
existence by Th1;
uniqueness
proof
   deffunc O(Element of the_set_of_ComplexSequences,
   Element of the_set_of_ComplexSequences)=seq_id($1)+seq_id($2);
     for o1,o2 being BinOp of the_set_of_ComplexSequences st
    (for a,b being Element of the_set_of_ComplexSequences
      holds o1.(a,b) = O(a,b)) &
    (for a,b being Element of the_set_of_ComplexSequences
      holds o2.(a,b) = O(a,b))
   holds o1 = o2 from BINOP_2:sch 2;
   hence thesis;
   end;
end;

definition
 func l_mult -> Function of [:COMPLEX,the_set_of_ComplexSequences:],
  the_set_of_ComplexSequences means :Def5:
   for z,x be set st z in COMPLEX & x in the_set_of_ComplexSequences
      holds it.[z,x] = C_id(z)(#)seq_id(x);
existence by Th2;
uniqueness
proof
   let mult1,mult2 be Function of [:COMPLEX,the_set_of_ComplexSequences:],
   the_set_of_ComplexSequences such that
A1:for z,x be set st z in COMPLEX & x in the_set_of_ComplexSequences
    holds mult1.[z,x] = C_id(z)(#)seq_id(x)
   and
A2:for z,x be set st z in COMPLEX & x in the_set_of_ComplexSequences
    holds mult2.[z,x] = C_id(z)(#)seq_id(x);
     for z being Element of COMPLEX
    for x being Element of the_set_of_ComplexSequences holds
     mult1.(z,x) = mult2.(z,x)
   proof
     let z being Element of COMPLEX;
     let x being Element of the_set_of_ComplexSequences;
     thus mult1.(z,x) = mult1.[z,x] by BINOP_1:def 1
                     .= C_id(z)(#)seq_id(x) by A1
                     .= mult2.[z,x] by A2
                     .= mult2.(z,x) by BINOP_1:def 1;
   end;
   hence thesis by BINOP_1:2;
end;
end;

definition
 func CZeroseq -> Element of the_set_of_ComplexSequences means :Def6:
  for n be Nat holds (seq_id it).n=0c;
existence
proof
    reconsider zeroseq = NAT --> 0c as Complex_Sequence by FUNCOP_1:57;
A1: for n be Nat holds zeroseq.n=0c by FUNCOP_1:13;
A2:zeroseq is Element of the_set_of_ComplexSequences by Def1;
A2: zeroseq in the_set_of_ComplexSequences by Def1;
   then seq_id(zeroseq) = zeroseq by Def2;
   hence thesis by A1,A2;
end;
uniqueness
proof
   let x,y be Element of the_set_of_ComplexSequences such that
A3:for n be Nat holds (seq_id(x)).n=0c and
A4:for n be Nat holds (seq_id(y)).n=0c;
A5:for s be Nat holds (seq_id(x)).s = (seq_id(y)).s
   proof
     let s be Nat;
       (seq_id y).s = 0c by A4;
     hence thesis by A3;
   end;
     x=seq_id(x) by Def2 .=seq_id(y) by A5,COMSEQ_1:6;
hence thesis by Def2;
end;
end;

theorem Th3:
for x being Complex_Sequence holds seq_id x = x
proof
   let x be Complex_Sequence;
     x in the_set_of_ComplexSequences by Def1;
   hence seq_id(x) = x by Def2;
end;

theorem Th4:
for v,w being VECTOR of
 CLSStruct(#the_set_of_ComplexSequences,CZeroseq,l_add,l_mult#) holds
  v + w = seq_id(v)+seq_id(w)
proof
   let v,w being VECTOR of
   CLSStruct (# the_set_of_ComplexSequences,CZeroseq, l_add,l_mult #);
   thus v + w = l_add.[v,w] by RLVECT_1:def 3
      .=l_add.(v,w) by BINOP_1:def 1
      .=seq_id(v)+seq_id(w) by Def4;
end;

theorem Th5:
for z being Complex,
 v being VECTOR of
  CLSStruct(# the_set_of_ComplexSequences,CZeroseq,l_add,l_mult #) holds
   z * v = z(#)seq_id(v)
proof
   let z be Complex;
   let v be VECTOR of
   CLSStruct(# the_set_of_ComplexSequences,CZeroseq, l_add,l_mult #);
   thus z*v = l_mult.[z,v] by CLVECT_1:def 1
           .= C_id(z)(#)seq_id(v) by Def5
           .= z(#)seq_id(v) by Def3;
end;

registration
 cluster CLSStruct(# the_set_of_ComplexSequences,CZeroseq,l_add,l_mult #)
   -> Abelian;
coherence
proof
   let v,w being VECTOR of
   CLSStruct(# the_set_of_ComplexSequences,CZeroseq,l_add,l_mult #);
     v + w = seq_id(v)+seq_id(w) by Th4;
   hence thesis by Th4;
end;
end;

Lm1:
 for u,v being VECTOR of
 CLSStruct(# the_set_of_ComplexSequences,CZeroseq,l_add,l_mult #) holds
  u + v = v + u;

theorem Th6:
for u,v,w being VECTOR of
 CLSStruct(# the_set_of_ComplexSequences,CZeroseq,l_add,l_mult #) holds
  (u + v) + w = u + (v + w)
proof
   let u,v,w be VECTOR of
   CLSStruct(# the_set_of_ComplexSequences,CZeroseq,l_add,l_mult #);
     (u+v) + w = seq_id(u+v)+seq_id(w) by Th4
           .= seq_id(seq_id(u)+seq_id(v)) + seq_id(w) by Th4
           .= (seq_id(u)+seq_id(v)) + seq_id(w) by Th3
           .= seq_id(u)+(seq_id(v)+seq_id(w)) by COMSEQ_1:9
           .= seq_id(u)+seq_id(seq_id(v)+seq_id(w)) by Th3
           .= seq_id(u) + seq_id(v+w) by Th4;
   hence thesis by Th4;
end;

theorem Th7:
for v being VECTOR of
 CLSStruct(# the_set_of_ComplexSequences,CZeroseq,l_add,l_mult #) holds
  v + 0.CLSStruct(# the_set_of_ComplexSequences,CZeroseq,l_add,l_mult #) = v
proof
   let v being VECTOR of
    CLSStruct(# the_set_of_ComplexSequences,CZeroseq,l_add,l_mult #);
   set V=CLSStruct(# the_set_of_ComplexSequences,CZeroseq,l_add,l_mult #);
A1:v + 0.V = seq_id(v)+seq_id(0.V) by Th4
          .= seq_id(v)+seq_id(CZeroseq) by RLVECT_1:def 2;
     for s being Nat holds
    (seq_id(v)+seq_id(CZeroseq)).s=(seq_id(v)).s
   proof
     let s be Nat;
       (seq_id(v)+seq_id(CZeroseq)).s
          = (seq_id(v)).s+(seq_id(CZeroseq)).s by COMSEQ_1:def 4
         .= (seq_id(v)).s + 0c by Def6;
     hence thesis by COMPLEX1:def 6;
   end;
   hence v + 0.V=seq_id(v) by A1,COMSEQ_1:6 .=v by Def2;
end;

theorem Th8:
for v being VECTOR of
  CLSStruct(# the_set_of_ComplexSequences,CZeroseq,l_add,l_mult #)
  ex w being VECTOR of
    CLSStruct(# the_set_of_ComplexSequences,CZeroseq,l_add,l_mult #) st
    v + w = 0.CLSStruct(# the_set_of_ComplexSequences,CZeroseq,l_add,l_mult #)
proof
   let v be VECTOR of
     CLSStruct(# the_set_of_ComplexSequences,CZeroseq,l_add,l_mult #);
   set V = CLSStruct(# the_set_of_ComplexSequences,CZeroseq,l_add,l_mult #);
A1:0.V = CZeroseq by RLVECT_1:def 2;
   reconsider w=-seq_id(v) as VECTOR of V by Def1;
     v+w=CZeroseq
   proof
A2:  v+w = seq_id(v)+seq_id(w) by Th4
        .= seq_id(v)+(-seq_id(v)) by Th3;
       for s being Nat holds
       (seq_id(v)+(-seq_id(v)) ).s=(seq_id(CZeroseq)).s
     proof
       let s be Nat;
         (seq_id(v)+(-seq_id(v))).s
         = (seq_id(v)).s+(-seq_id(v)).s by COMSEQ_1:def 4
        .= (seq_id(v)).s + (-((seq_id(v)).s)) by COMSEQ_1:def 9
        .= 0
        .= (seq_id(CZeroseq)).s by Def6;
       hence thesis;
     end;
     then seq_id(v)+(-seq_id(v)) = seq_id(CZeroseq) by COMSEQ_1:6
      .=CZeroseq by Def2;
     hence thesis by A2;
   end;
   hence thesis by A1;
end;

theorem Th9:
for z being Complex, v,w being VECTOR of
 CLSStruct(# the_set_of_ComplexSequences,CZeroseq,l_add,l_mult #) holds
  z * (v + w) = z * v + z * w
proof
   let z be Complex;
   let v,w being VECTOR of
     CLSStruct(# the_set_of_ComplexSequences,CZeroseq,l_add,l_mult #);
A1:z * (v + w) = z(#)seq_id(v + w) by Th5
              .= z(#)seq_id(seq_id(v) + seq_id(w)) by Th4
              .= z(#)(seq_id(v) + seq_id(w)) by Th3
              .= z(#)seq_id(v) + z(#)seq_id(w) by COMSEQ_1:19;
     z*v + z*w = seq_id(z*v)+seq_id(z*w) by Th4
            .=seq_id(z(#)seq_id(v)) + seq_id(z*w) by Th5
            .=seq_id(z(#)seq_id(v)) + seq_id(z(#)seq_id(w)) by Th5
            .=z(#)seq_id(v) + seq_id(z(#)seq_id(w)) by Th3
            .=z(#)seq_id(v) + z(#)seq_id(w) by Th3;
   hence thesis by A1;
end;

theorem Th10:
for z1,z2 being Complex, v being VECTOR of
 CLSStruct(# the_set_of_ComplexSequences,CZeroseq,l_add,l_mult #) holds
  (z1 + z2) * v = z1 * v + z2 * v
proof
   let z1,z2 be Complex;
   let v being VECTOR of
    CLSStruct(# the_set_of_ComplexSequences,CZeroseq,l_add,l_mult #);
A1:(z1+z2)(#)seq_id(v) =z1(#)seq_id(v)+z2(#)seq_id(v)
   proof
       for s being Nat holds
     ((z1+z2)(#)seq_id(v)).s=(z1(#)seq_id(v)+z2(#)seq_id(v)).s
     proof
       let s be Nat;
           ((z1+z2)(#)seq_id(v)).s = (z1+z2)*(seq_id(v)).s by COMSEQ_1:def 7
          .= z1*((seq_id(v)).s)+z2*((seq_id(v)).s)
          .= (z1(#)seq_id(v)).s+z2*(seq_id(v)).s by COMSEQ_1:def 7
          .= (z1(#)seq_id(v)).s+(z2(#)seq_id(v)).s by COMSEQ_1:def 7;
       hence thesis by COMSEQ_1:def 4;
     end;
     hence (z1+z2)(#)seq_id(v)=z1(#)seq_id(v)+z2(#)seq_id(v) by COMSEQ_1:6;
   end;
     z1*v + z2*v = seq_id(z1*v)+seq_id(z2*v) by Th4
          .=seq_id(z1(#)seq_id(v)) + seq_id(z2*v) by Th5
          .=seq_id(z1(#)seq_id(v)) + seq_id(z2(#)seq_id(v)) by Th5
          .=z1(#)seq_id(v) + seq_id(z2(#)seq_id(v)) by Th3
          .=z1(#)seq_id(v) + z2(#)seq_id(v) by Th3;
   hence thesis by A1,Th5;
end;

theorem Th11:
for z1,z2 be Complex, v being VECTOR of
 CLSStruct(# the_set_of_ComplexSequences,CZeroseq,l_add,l_mult #) holds
  (z1 * z2) * v = z1 * (z2 * v)
proof
   let z1,z2 be Complex;
   let v being VECTOR of
    CLSStruct(# the_set_of_ComplexSequences,CZeroseq,l_add,l_mult #);
       (z1 * z2) * v =(z1*z2)(#)seq_id(v) by Th5
                .=z1(#)(z2(#)seq_id(v)) by COMSEQ_1:20
                .=z1(#)seq_id(z2(#)seq_id(v)) by Th3
                .=z1(#)seq_id(z2*v) by Th5;
   hence thesis by Th5;
end;

theorem Th12:
for v being VECTOR of
 CLSStruct(# the_set_of_ComplexSequences,CZeroseq,l_add,l_mult #) holds
  1r * v = v
proof
   let v being VECTOR of
    CLSStruct(# the_set_of_ComplexSequences,CZeroseq,l_add,l_mult #);
       1r * v =1r(#)seq_id(v) by Th5 .=seq_id(v) by COMSEQ_1:24;
   hence thesis by Def2;
end;

definition
  func Linear_Space_of_ComplexSequences -> ComplexLinearSpace equals :Def7:
   CLSStruct (# the_set_of_ComplexSequences, CZeroseq, l_add, l_mult #);
  correctness by Lm1,Th6,Th7,Th8,Th9,Th10,Th11,Th12,CLVECT_1:1;
end;

definition
let X be ComplexLinearSpace;
let X1 be Subset of X such that
A1:X1 is lineary-closed & X1 is non empty;
func Add_(X1,X) -> BinOp of X1 equals :Def8:
  (the add of X) | [:X1,X1:];
correctness
proof
A2:[:X1,X1:] c= [:the carrier of X,the carrier of X:] by ZFMISC_1:119;
A3:dom (the add of X)
     = [:the carrier of X,the carrier of X:] by FUNCT_2:def 1;
then A4:dom ((the add of X) | [:X1,X1:]) =[:X1,X1:] by A2,RELAT_1:91;
     for z be set st z in [:X1,X1:] holds ((the add of X) | [:X1,X1:]).z in X1
   proof
     let z be set such that
A5:  z in [:X1,X1:];
     consider r,x  be set such that
A6:  r in X1 & x in X1 & z=[r,x] by A5,ZFMISC_1:def 2;
     reconsider y=x,r1=r as VECTOR of X by A6;
       [r,x] in dom ((the add of X) | [:X1,X1:]) by A2,A3,A5,A6,RELAT_1:91;
     then ((the add of X) | [:X1,X1:]).z
        = (the add of X).[r,x] by A6,FUNCT_1:70
       .= r1+y by RLVECT_1:def 3;
     hence thesis by A1,A6,CLVECT_1:def 3;
   end;
   hence thesis by A4,FUNCT_2:5;
end;
end;

definition
let X be ComplexLinearSpace;
let X1 be Subset of X such that
A1: X1 is lineary-closed & X1 is non empty;
func Mult_(X1,X) -> Function of [:COMPLEX,X1:], X1 equals :Def9:
(the Mult of X) | [:COMPLEX,X1:];
correctness
proof
A2:[:COMPLEX,X1:] c= [:COMPLEX,the carrier of X:] by ZFMISC_1:118;
A3: dom (the Mult of X) = [:COMPLEX,the carrier of X:] by FUNCT_2:def 1;
then A4: dom ((the Mult of X) | [:COMPLEX,X1:]) =[:COMPLEX,X1:] by A2,
RELAT_1:91;
       for z be set st z in [:COMPLEX,X1:] holds
     ((the Mult of X) | [:COMPLEX,X1:]).z in X1
   proof
     let z be set such that
A5:  z in [:COMPLEX,X1:];
     consider r,x  be set such that
A6:  r in COMPLEX & x in X1 & z=[r,x] by A5,ZFMISC_1:def 2;
     reconsider y=x as VECTOR of X by A6;
     reconsider r as Complex by A6;
    [r,x] in dom ((the Mult of X) | [:COMPLEX,X1:]) by A2,A3,A5,A6,RELAT_1:91;
     then ((the Mult of X) | [:COMPLEX,X1:]).z
       = (the Mult of X).[r,x] by A6,FUNCT_1:70
      .= r*y by CLVECT_1:def 1;
     hence thesis by A1,A6,CLVECT_1:def 3;
   end;
   hence thesis by A4,FUNCT_2:5;
end;
end;

definition
let X be ComplexLinearSpace, X1 be Subset of X such that
A1: X1 is lineary-closed & X1 is non empty;
func Zero_(X1,X) -> Element of X1 equals :Def10:
  0.X;
correctness
proof
   consider v be Element of X1;
       v in X1 by A1;
   then reconsider v as Element of X;
       v-v=0.X by RLVECT_1:28;
   hence thesis by A1,CLVECT_1:23;
end;
end;

theorem Th13:
for V be ComplexLinearSpace, V1 be Subset of V
 st V1 is lineary-closed & V1 is non empty holds
  CLSStruct (# V1,Zero_(V1,V), Add_(V1,V),Mult_(V1,V) #) is Subspace of V
proof
   let V be ComplexLinearSpace;
   let V1 be Subset of V such that
A1:V1 is lineary-closed & V1 is non empty;
A2:Zero_(V1,V) = 0.V by A1,Def10;
A3:Add_(V1,V)= (the add of V) | [:V1,V1:] by A1,Def8;
       Mult_(V1,V) = (the Mult of V) | [:COMPLEX,V1:] by A1,Def9;
   hence thesis by A1,A2,A3,CLVECT_1:44;
end;

definition
 func the_set_of_l2ComplexSequences -> Subset of
  Linear_Space_of_ComplexSequences means :Def11:
  it is non empty &
  for x being set holds x in it iff
  (x in the_set_of_ComplexSequences &
  |.seq_id(x).|(#)|.seq_id(x).| is summable);
existence
proof
   defpred P[set] means |.seq_id($1).|(#)|.seq_id($1).| is summable;
   consider IT being set such that
A1:for x being set holds x in IT
    iff x in the_set_of_ComplexSequences & P[x] from XBOOLE_0:sch 1;
A2:IT is non empty
   proof
       |.seq_id(CZeroseq).|(#)|.seq_id(CZeroseq).| is summable
     proof
       reconsider rseq=|.seq_id(CZeroseq).|(#)|.seq_id(CZeroseq).|
                        as Real_Sequence;
         now let n be Nat;
         thus rseq.n =(|.seq_id(CZeroseq).|).n  * (|.seq_id(CZeroseq).|).n
                                                               by SEQ_1:12
                    .=(|.seq_id(CZeroseq).|).n * |.(seq_id(CZeroseq)).n.|
                    by COMSEQ_1:def 14
                    .=(|.seq_id(CZeroseq).|).n * 0 by Def6,COMPLEX1:130
                    .=0;
       end;
       then rseq is absolutely_summable by COMSEQ_3:3;
       hence thesis by SERIES_1:40;
     end;
     hence thesis by A1;
   end;
     IT is Subset of the_set_of_ComplexSequences
   proof
       for x be set st x in IT holds x in the_set_of_ComplexSequences by A1;
     hence thesis by TARSKI:def 3;
   end;
   hence thesis by A1,A2,Def7;
end;
uniqueness
proof
   let X1,X2 be Subset of Linear_Space_of_ComplexSequences;
   assume that
A3:X1 is non empty &
    for x being set holds x in X1 iff
     (x in the_set_of_ComplexSequences &
      |.seq_id(x).|(#)|.seq_id(x).| is summable)
   and
A4:X2 is non empty &
    for x being set holds x in X2 iff
     (x in the_set_of_ComplexSequences &
      |.seq_id(x).|(#)|.seq_id(x).| is summable);
A5: X1 c= X2
    proof
      let x be set;
      assume x in X1;
      then x in the_set_of_ComplexSequences
        & |.seq_id(x).|(#)|.seq_id(x).| is summable by A3;
      hence thesis by A4;
    end;
        X2 c= X1
    proof
      let x be set;
      assume x in X2;
      then x in the_set_of_ComplexSequences
        & |.seq_id(x).|(#)|.seq_id(x).| is summable by A4;
      hence thesis by A3;
    end;
    hence thesis by A5,XBOOLE_0:def 10;
  end;
end;

theorem Th14:
the_set_of_l2ComplexSequences is lineary-closed &
 the_set_of_l2ComplexSequences is non empty
proof
   set W = the_set_of_l2ComplexSequences;
A1:for v,u be VECTOR of Linear_Space_of_ComplexSequences st
    v in the_set_of_l2ComplexSequences &
    u in the_set_of_l2ComplexSequences
     holds v + u in the_set_of_l2ComplexSequences
   proof
     let v,u be VECTOR of Linear_Space_of_ComplexSequences such that
A2:  v in W & u in W;
       |.seq_id(v+u).|(#)|.seq_id(v+u).| is summable
     proof
A3:    |.seq_id(v).|(#)|.seq_id(v).| is summable by A2,Def11;
A4:    |.seq_id(u).|(#)|.seq_id(u).| is summable by A2,Def11;
       set p = |.seq_id(v).|(#)|.seq_id(v).|;
       set q = |.seq_id(u).|(#)|.seq_id(u).|;
       set r = |.seq_id(v+u).|(#)|.seq_id(v+u).|;
A5:    2(#)p is summable by A3,SERIES_1:13;
         2(#)q is summable by A4,SERIES_1:13;
then A6:    2(#)p+2(#)q is summable by A5,SERIES_1:10;
A7:    for n be Nat holds 0<=r.n
       proof
         let n be Nat;
           r.n=(|.seq_id(v+u).|).n * (|.seq_id(v+u).|).n by SEQ_1:12;
         hence thesis by REAL_1:93;
       end;
         for n be Nat holds r.n <=(2(#)p+2(#)q).n
       proof
         let n be Nat;
         set s = |.seq_id(v).|;
         set t = |.seq_id(u).|;
         reconsider sn=s.n, tn=t.n as Real;
A8:      seq_id(v+u)=seq_id(seq_id(v)+seq_id(u)) by Def7,Th4
                    .=seq_id(v)+seq_id(u) by Th3;
           (|.seq_id(v+u).|).n = |.(seq_id(v+u)).n .| by COMSEQ_1:def 14
                          .= |.(seq_id(v)).n  + (seq_id(u)).n.|
            by A8,COMSEQ_1:def 4;
         then (|.seq_id(v+u).|).n <= |.(seq_id(v)).n.| + |.(seq_id(u)).n.|
            by COMPLEX1:142;
         then (|.seq_id(v+u).|).n
            <= s.n + |.((seq_id(u)).n).| by COMSEQ_1:def 14;
then A9:      (|.seq_id(v+u).|).n <= s.n + t.n by COMSEQ_1:def 14;
           0 <= |.(seq_id(v+u)).n.| by COMPLEX1:132;
         then 0 <= (|.seq_id(v+u).|).n by COMSEQ_1:def 14;
then A10:     ((|.seq_id(v+u).|).n)^2 <= (s.n + t.n)^2 by A9,SQUARE_1:77;
           r.n = (|.seq_id(v+u).|).n * (|.seq_id(v+u).|).n by SEQ_1:12
            .= ((|.seq_id(v+u).|).n)^2 by SQUARE_1:def 3;
then A11:     r.n <= sn^2 + 2*sn*tn + tn^2 by A10,SQUARE_1:63;
           (2(#)p+2(#)q).n=(2(#)p).n +(2(#)q).n by SEQ_1:11
                       .= 2*p.n + (2(#)q).n by SEQ_1:13
                       .= 2*p.n + 2*q.n by SEQ_1:13
                       .= 2*(s.n*s.n) + 2*q.n by SEQ_1:12
                       .= 2*(s.n*s.n) + 2*(t.n*t.n) by SEQ_1:12
                       .= 2*sn^2 + 2*(t.n*t.n) by SQUARE_1:def 3
                       .= 2*sn^2 + 2*tn^2 by SQUARE_1:def 3;
then A12:     (2(#)p+2(#)q).n - (sn^2 + 2*sn*tn + tn^2)
          = sn^2 - 2*sn*tn + (tn^2 + tn^2 - tn^2)
         .= (sn-tn)^2 by SQUARE_1:64;
           0 <= (sn-tn)^2 by SQUARE_1:72;
         then 0 + (sn^2 + 2*sn*tn + tn^2) <= (2(#)p+2(#)q).n by A12,REAL_1:84;
         hence thesis by A11,AXIOMS:22;
       end;
       hence thesis by A6,A7,SERIES_1:24;
     end;
     hence v+u in W by Def7,Def11;
   end;
     for z be Complex for v be VECTOR of Linear_Space_of_ComplexSequences
    st v in W holds z * v in W
   proof
     let z be Complex;
     let v be VECTOR of Linear_Space_of_ComplexSequences such that
A13: v in W;
       |.seq_id(z*v).|(#)|.seq_id(z*v).| is summable
     proof
A14:   |.seq_id(v).|(#)|.seq_id(v).| is summable by A13,Def11;
         seq_id(z*v)=seq_id(z(#)seq_id(v)) by Def7,Th5
                 .=z(#)seq_id(v) by Th3;
       then |.seq_id(z*v).| = |.z.|(#)|.seq_id(v).| by COMSEQ_1:53;
       then |.seq_id(z*v).|(#)|.seq_id(z*v).|
            =|.z.|(#)(|.z.|(#)|.seq_id(v).|(#) |.seq_id(v).|) by SEQ_1:26
           .=|.z.|(#)(|.z.|(#)(|.seq_id(v).|(#)|.seq_id(v).|)) by SEQ_1:26
           .=(|.z.|*|.z.|)(#)(|.seq_id(v).|(#)|.seq_id(v).|) by SEQ_1:31;
       hence thesis by A14,SERIES_1:13;
     end;
     hence z*v in W by Def7,Def11;
   end;
   hence thesis by A1,Def11,CLVECT_1:def 3;
end;

theorem
  CLSStruct(# the_set_of_l2ComplexSequences,
  Zero_(the_set_of_l2ComplexSequences,Linear_Space_of_ComplexSequences),
  Add_(the_set_of_l2ComplexSequences,Linear_Space_of_ComplexSequences),
  Mult_(the_set_of_l2ComplexSequences,Linear_Space_of_ComplexSequences) #)
is Subspace of Linear_Space_of_ComplexSequences by Th13,Th14;

theorem Th16:
CLSStruct (# the_set_of_l2ComplexSequences,
  Zero_(the_set_of_l2ComplexSequences,Linear_Space_of_ComplexSequences),
  Add_(the_set_of_l2ComplexSequences,Linear_Space_of_ComplexSequences),
  Mult_(the_set_of_l2ComplexSequences,Linear_Space_of_ComplexSequences) #)
is ComplexLinearSpace by Th13,Th14;

theorem
  the carrier of Linear_Space_of_ComplexSequences = the_set_of_ComplexSequences
&
(for x be set holds
  x is Element of Linear_Space_of_ComplexSequences
  iff x is Complex_Sequence ) &
(for x be set holds x is VECTOR of Linear_Space_of_ComplexSequences
  iff x is Complex_Sequence ) &
(for u be VECTOR of Linear_Space_of_ComplexSequences
  holds u =seq_id(u) ) &
(for u,v be VECTOR of Linear_Space_of_ComplexSequences
  holds u+v =seq_id(u)+seq_id(v) ) &
( for z be Complex for u be VECTOR of Linear_Space_of_ComplexSequences
  holds z*u =z(#)seq_id(u) ) by Def1,Def2,Def7,Th4,Th5;

begin  :: Unitary space with complex coefficient

definition
 struct(CLSStruct) CUNITSTR (# carrier -> set,
         Zero -> Element of the carrier,
          add -> BinOp of the carrier,
         Mult -> Function of [:COMPLEX, the carrier:], the carrier,
       scalar -> Function of [: the carrier, the carrier :], COMPLEX #);
end;

registration
 cluster non empty strict CUNITSTR;
existence
proof
   consider D being non empty set, Z being Element of D,
            a being BinOp of D,
            m being Function of [:COMPLEX, D:], D,
            s being Function of [: D,D:],COMPLEX;
   take CUNITSTR (#D,Z,a,m,s#);
   thus the carrier of CUNITSTR (#D,Z,a,m,s#) is non empty;
   thus thesis;
   end;
end;

registration
  let D be non empty set, Z be Element of D,
      a be BinOp of D,m be Function of [:COMPLEX, D:], D,
      s be Function of [: D,D:],COMPLEX;
  cluster CUNITSTR (#D,Z,a,m,s#) -> non empty;
 coherence
  proof
   thus the carrier of CUNITSTR (#D,Z,a,m,s#) is non empty;
  end;
end;

reserve X for non empty CUNITSTR;
reserve a, b for Complex;
reserve x, y for Point of X;

deffunc 0'(CUNITSTR) = 0.$1;

definition let X; let x, y;
  func x .|. y -> Complex equals
:Def12: (the scalar of X).[x,y];
correctness;
end;

consider V0 being ComplexLinearSpace;
Lm2:the carrier of (0).V0 = {0.V0} by CLVECT_1:def 5;
 reconsider
  nil_func = [: the carrier of (0).V0 , the carrier of (0).V0 :] --> 0c
  as Function of
   [: the carrier of (0).V0 , the carrier of (0).V0 :], COMPLEX by FUNCOP_1:57;
Lm3:for x, y being VECTOR of (0).V0 holds
     nil_func.[x,y] = 0c by FUNCOP_1:13;

 0.V0 in the carrier of (0).V0 by Lm2,TARSKI:def 1;
 then
Lm4:nil_func.[0.V0,0.V0] = 0c by Lm3;

Lm5:for u being VECTOR of (0).V0 holds
     0 <= Re(nil_func.[u,u]) & Im(nil_func.[u,u]) = 0
proof
   let u be VECTOR of (0).V0;
     u = 0.V0 by Lm2,TARSKI:def 1;
   hence thesis by Lm4,COMPLEX1:12;
end;

Lm6:for u, v being VECTOR of (0).V0 holds nil_func.[u,v] = (nil_func.[v,u])*'
proof
   let u, v be VECTOR of (0).V0;
     u = 0.V0 & v = 0.V0 by Lm2,TARSKI:def 1;
   hence thesis by Lm4,COMPLEX1:113;
end;

Lm7:for u, v, w being VECTOR of (0).V0 holds
     nil_func.[u+v,w] = nil_func.[u,w] + nil_func.[v,w]
proof
   let u, v, w be VECTOR of (0).V0;
A1:u = 0.V0 & v = 0.V0 & w = 0.V0 by Lm2,TARSKI:def 1;
     u+v = 0.V0 by Lm2,TARSKI:def 1;
   hence thesis by A1,Lm4,COMPLEX1:def 6;
end;

Lm8:for u,v being VECTOR of (0).V0, a holds
  nil_func.[a*u,v] = a * nil_func.[u,v]
proof
   let u , v be VECTOR of (0).V0;
   let a;
A1:u = 0.V0 & v = 0.V0 by Lm2,TARSKI:def 1;
     a*u = 0.V0 by Lm2,TARSKI:def 1;
   hence thesis by A1,Lm4,COMPLEX1:def 6;
end;
set X0 = CUNITSTR(# the carrier of (0).V0,the Zero of (0).V0,the add of (0).V0,
                  the Mult of (0).V0, nil_func #);

Lm9:now
   let x , y , z be Point of X0;
   let a;
   thus x .|. x = 0c iff x = 0'(X0)
   proof
       0'(X0) = the Zero of X0 by RLVECT_1:def 2
           .= 0.(0).V0 by RLVECT_1:def 2
           .= 0.V0 by CLVECT_1:31;
     hence thesis by Def12,Lm2,Lm4,TARSKI:def 1;
   end;
   thus 0 <= Re(x .|. x) & 0 = Im(x .|. x)
   proof
     reconsider u = x as VECTOR of (0).V0;
       x .|. x = nil_func.[u,u] by Def12;
     hence thesis by Lm5;
   end;
   thus x .|. y = (y .|. x)*'
   proof
     reconsider u = x , v = y as VECTOR of (0).V0;
       x .|. y = nil_func.[u,v] &
     y .|. x = nil_func.[v,u] by Def12;
     hence thesis by Lm6;
   end;
   thus (x+y) .|. z = x .|. z + y .|. z
   proof
     reconsider u = x , v = y , w = z as VECTOR of (0).V0;
       x + y = (the add of X0).[x,y] by RLVECT_1:def 3
          .= u + v by RLVECT_1:def 3;
     then (x+y) .|. z = nil_func.[u+v,w] &
     x .|. z = nil_func.[u,w] &
     y .|. z = nil_func.[v,w] by Def12;
     hence thesis by Lm7;
   end;
   thus (a*x) .|. y = a * ( x .|. y )
   proof
     reconsider u = x , v = y as VECTOR of (0).V0;
       a * x = (the Mult of X0).[a,u] by CLVECT_1:def 1
          .= a * u by CLVECT_1:def 1;
     then (a*x) .|. y = nil_func.[a*u,v] &
     x .|. y = nil_func.[u,v] by Def12;
     hence thesis by Lm8;
   end;
end;

definition let IT be non empty CUNITSTR;
  attr IT is ComplexUnitarySpace-like means :Def13:
  for x,y,w being Point of IT, a holds
    ( x .|. x = 0 iff x = 0.IT ) &
    0 <= Re(x .|. x) & 0 = Im(x .|. x) &
    x .|. y = (y .|. x)*' &
    (x+y) .|. w = x .|. w + y .|. w &
    (a*x) .|. y = a * ( x .|. y );
end;

registration
 cluster ComplexUnitarySpace-like ComplexLinearSpace-like Abelian
   add-associative right_zeroed right_complementable strict
   (non empty CUNITSTR);
existence
proof
   take X0;
   thus X0 is ComplexUnitarySpace-like by Def13,Lm9;
A1:now
     let x,y be VECTOR of X0;
     let x',y' be VECTOR of (0).V0;
     assume
A2:  x = x' & y = y';
     hence x + y = (the add of X0).[x',y'] by RLVECT_1:def 3
                .= x' + y' by RLVECT_1:def 3;
     let a;
     thus a * x = (the Mult of X0).[a,x'] by A2,CLVECT_1:def 1
               .= a * x' by CLVECT_1:def 1;
   end;
A3:0.X0 = the Zero of X0 by RLVECT_1:def 2
       .= 0.(0).V0 by RLVECT_1:def 2;
   thus X0 is ComplexLinearSpace-like
   proof
     thus for a for v,w being VECTOR of X0 holds a * (v + w) = a * v + a * w
     proof
       let a;
       let v,w be VECTOR of X0;
       reconsider v'= v, w' = w as VECTOR of (0).V0;
A4:    a * v' = a * v by A1;
A5:    a * w' = a * w by A1;
         v + w = v'+ w' by A1;
       hence a * (v + w) = a *( v' + w') by A1
                        .= a * v' + a * w' by CLVECT_1:def 2
                        .= a * v + a * w by A1,A4,A5;
     end;
     thus for a,b for v being VECTOR of X0 holds (a+ b) * v = a* v + b * v
     proof
       let a,b;
       let v be VECTOR of X0;
       reconsider v'= v as VECTOR of (0).V0;
A6:    a * v' = a * v by A1;
A7:    b * v' = b * v by A1;
       thus (a + b) * v = (a + b) * v' by A1
                       .= a * v' + b * v' by CLVECT_1:def 2
                       .= a * v + b * v by A1,A6,A7;
     end;
     thus for a,b for v being VECTOR of X0 holds (a * b) * v = a * (b * v)
     proof
       let a,b;
       let v be VECTOR of X0;
       reconsider v'= v as VECTOR of (0).V0;
A8:    b * v' = b * v by A1;
       thus (a * b) * v = (a * b) * v' by A1
                       .= a * (b * v') by CLVECT_1:def 2
                       .= a * (b * v) by A1,A8;
     end;
     let v be VECTOR of X0;
     reconsider v'= v as VECTOR of (0).V0;
     thus 1r * v = 1r * v' by A1 .= v by CLVECT_1:def 2;
   end;
   thus for v,w being VECTOR of X0 holds v + w = w + v
   proof
     let v,w be VECTOR of X0;
     reconsider v'= v , w'= w as VECTOR of (0).V0;
     thus v + w = w'+ v' by A1 .= w + v by A1;
   end;
   thus for u,v,w being VECTOR of X0 holds (u + v) + w = u + (v + w)
   proof
     let u,v,w be VECTOR of X0;
     reconsider u'= u, v'= v, w'= w as VECTOR of (0).V0;
A9:  u + v = u'+ v' by A1;
A10: v + w = v' + w' by A1;
     thus (u + v) + w = (u' + v') + w' by A1,A9
                     .= u' + (v' + w') by RLVECT_1:def 6
                     .= u + (v + w) by A1,A10;
   end;
   thus for v being VECTOR of X0 holds v + 0.X0 = v
   proof
     let v be VECTOR of X0;
     reconsider v'= v as VECTOR of (0).V0;
     thus v + 0.X0 = v'+ 0.(0).V0 by A1,A3 .=v by RLVECT_1:10;
   end;
   thus for v being VECTOR of X0
       ex w being VECTOR of X0 st v + w = 0.X0
   proof
     let v be VECTOR of X0;
     reconsider v'= v as VECTOR of (0).V0;
     consider w' be VECTOR of (0).V0 such that
A11: v' + w' = 0.(0).V0 by RLVECT_1:def 8;
     reconsider w = w' as VECTOR of X0;
     take w;
     thus v + w = 0.X0 by A1,A3,A11;
   end;
   thus thesis;
end;
end;

definition
 mode ComplexUnitarySpace is ComplexUnitarySpace-like ComplexLinearSpace-like
  Abelian add-associative right_zeroed right_complementable
   (non empty CUNITSTR);
end;

reserve X for ComplexUnitarySpace;
reserve x, y, z, u, v for Point of X;

theorem
  (0.X).|.(0.X) = 0 by Def13;

theorem Th19:
x.|.(y+z) = x.|.y + x.|.z
proof
   thus x.|.(y+z) = ((y+z).|.x)*' by Def13
         .= (y.|.x + z.|.x)*' by Def13
         .= (y.|.x)*' + (z.|.x)*' by COMPLEX1:118
         .= x.|.y + (z.|.x)*' by Def13
         .= x.|.y + x.|.z by Def13;
end;

theorem Th20:
x.|.(a*y) = (a*') * x.|.y
proof
   thus x.|.(a*y) = ((a*y).|.x)*' by Def13
                 .= (a*(y.|.x))*' by Def13
                 .= (a*') * (y.|.x)*' by COMPLEX1:121
                 .= (a*') * (x.|.y) by Def13;
end;

theorem Th21:
(a*x).|.y = x.|.((a*')*y)
proof
     (a*x) .|. y = a * x .|. y by Def13
              .= (a*')*' * (y.|.x)*' by Def13
              .= ((a*')*(y.|.x))*' by COMPLEX1:121
              .= (((a*')*y).|.x)*' by Def13;
   hence thesis by Def13;
end;

theorem Th22:
(a*x + b*y).|.z = a * x.|.z + b * y.|.z
proof
     (a*x+b*y) .|. z = (a*x) .|. z + (b*y) .|. z by Def13
                  .= a * x .|. z + (b*y) .|. z by Def13;
   hence thesis by Def13;
end;

theorem Th23:
x.|.(a*y + b*z) = (a*') * x.|.y + (b*') * x.|.z
proof
     x.|.(a*y + b*z) = ((a*y + b*z).|.x)*' by Def13
                  .= ( a * y.|.x + b * z.|.x )*' by Th22
                  .= ( a * y.|.x )*' + ( b * z.|.x )*' by COMPLEX1:118
                  .= (a*') * (y.|.x)*' + ( b * z.|.x )*' by COMPLEX1:121
                  .= (a*') * (y.|.x)*' + (b*') * (z.|.x)*' by COMPLEX1:121
                  .= (a*') * x.|.y + (b*') * (z.|.x)*' by Def13;
   hence thesis by Def13;
end;

theorem Th24:
(-x) .|. y = x .|. (-y)
proof
     (-x) .|. y = ((-1r)*x) .|. y by CLVECT_1:4
             .= x.|.( (-(1r))*' * y) by Th21
             .= x.|.( (-1r) * y) by COMPLEX1:115,119;
   hence thesis by CLVECT_1:4;
end;

theorem Th25:
(-x).|.y = - x.|.y
proof
     (-x) .|. y = ((-1r)*x) .|. y by CLVECT_1:4
             .= (-1) * x .|. y by Def13,COMPLEX1:def 7;
   hence thesis;
end;

theorem Th26:
x.|.(-y) = - x.|.y
proof
     x.|.(-y) = (-x).|.y by Th24;
   hence thesis by Th25;
end;

theorem Th27:
(-x).|.(-y) = x.|.y
proof
     (-x).|.(-y) = - x.|.(-y) by Th25
                .= - ( - x .|. y ) by Th26;
   hence thesis;
end;

theorem Th28:
(x-y).|.z = x.|.z - y.|.z
proof
     (x - y) .|. z = (x + (-y)) .|. z by RLVECT_1:def 11
                .= x .|. z + (-y) .|. z by Def13
                .= x .|. z + ( - y .|. z ) by Th25;
   hence thesis;
end;

theorem Th29:
x.|.(y-z) = x.|.y - x.|.z
proof
     x .|. (y - z) = x .|. (y + (-z)) by RLVECT_1:def 11
                .= x .|. y + x .|. (-z) by Th19
                .= x .|. y + ( - x .|. z ) by Th26;
   hence thesis;
end;

theorem
  (x-y).|.(u-v) = x.|.u - x.|.v - y.|.u + y.|.v
proof
     (x - y) .|. (u - v) = x .|. (u - v) - y .|. (u - v) by Th28
                      .= ( x .|. u - x .|. v ) - y .|. (u - v) by Th29
                      .= ( x .|. u - x .|. v ) - ( y .|. u - y .|. v ) by Th29;
   hence thesis;
end;

theorem Th31:
(0.X).|.x = 0
proof
     0'(X) .|. x = (x + (-x)) .|. x by RLVECT_1:16
              .= x .|. x + (-x) .|. x by Def13
              .= x .|. x + ( - x .|. x ) by Th25;
   hence thesis;
end;

theorem Th32:
x.|.0.X = 0
proof
     x.|.0.X = ((0.X).|.x)*' by Def13
          .= 0c by Th31,COMPLEX1:113;
   hence thesis;
end;

theorem Th33:
(x+y).|.(x+y) = x.|.x + x.|.y + y.|.x + y.|.y
proof
     (x+y).|.(x+y) = x.|.(x+y) + y.|.(x+y) by Def13
                   .= (x.|.x + x.|.y) + y.|.(x+y) by Th19
                   .= (x.|.x + x.|.y) + (y.|.x + y.|.y) by Th19;
  hence thesis;
end;

theorem
  (x+y).|.(x-y) = x.|.x - x.|.y + y.|.x - y.|.y
proof
     (x + y) .|. (x - y) = x .|. (x - y) + y .|. (x - y) by Def13
                   .= (x .|. x - x .|. y) + y .|. (x - y) by Th29
                   .= (x .|. x - x .|. y) + (y .|. x - y .|. y) by Th29
                   .= (x.|.x - x.|.y) + y.|.x + -y.|.y;
   hence thesis;
end;

theorem Th35:
(x-y).|.(x-y) = x.|.x - x.|.y - y.|.x + y.|.y
proof
     (x - y) .|. (x - y) = x .|. (x - y) - y .|. (x - y) by Th28
                   .= x .|. x - x .|. y - y .|. (x - y) by Th29
                   .= x.|.x - x.|.y - ( y.|.x - y.|.y ) by Th29;
  hence thesis;
end;

Lm10:
for p,q being Complex, x,y being Point of X holds
 (p*x + q*y).|.(p*x + q*y)
   = p*p*' *(x.|.x) + p*q*' *(x.|.y) + p*' *q*(y.|.x) + q*q*' *(y.|.y)
proof
   let p,q be Complex;
   let x,y being Point of X;
     (p*x+q*y).|.(p*x+q*y)
     = p * (x.|.(p*x + q*y)) + q * (y.|.(p*x + q*y)) by Th22
    .= p * (p*' *(x.|.x) + q*' *(x.|.y)) + q * (y.|.(p*x + q*y)) by Th23
    .= p*p*' *(x.|.x) + p*q*' *(x.|.y) + (q * (p*' *(y.|.x) + q*' *(y.|.y)))
        by Th23
    .= p*p*' *(x.|.x) + p*q*' *(x.|.y) + (q*p*' *(y.|.x) + q*q*' *(y.|.y));
   hence thesis;
end;

theorem Th36:
|.(x.|.x).| = Re(x.|.x)
proof
  Re (x.|.x) >= 0 & Im (x.|.x) = 0 by Def13;
     then |.Re(x.|.x)+Im(x.|.x)*<i>.| = Re (x.|.x) by ABSVALUE:def 1;
    hence thesis by COMPLEX1:29;
end;

theorem Th37:  ::Schwarz's inequality
|.(x.|.y).| <= sqrt|.(x.|.x).| * sqrt|.(y.|.y).|
proof
A1:y = 0'(X) implies |.(x.|.y).| <= sqrt|.(x.|.x).| * sqrt|.(y.|.y).|
   proof
     assume
A2:  y = 0'(X);
      then y.|.y = 0c by Def13;
     hence thesis by A2,Th32,COMPLEX1:130,SQUARE_1:82;
   end;
     y <> 0'(X) implies |.(x.|.y).| <= sqrt|.(x.|.x).| * sqrt|.(y.|.y).|
   proof
     assume y <> 0'(X);
then A3:  y.|.y <> 0c by Def13;
     reconsider c1 = |.(y.|.y).|+0*<i> as Element of COMPLEX by XCMPLX_0:def 2;
     set c2 = -(x.|.y);
A4: Re (y.|.y) >= 0 & Im (y.|.y) = 0 by Def13;
     then |.Re(y.|.y)+Im(y.|.y)*<i>.| = Re (y.|.y) by ABSVALUE:def 1;
     then A5: |.(y.|.y).| = Re (y.|.y) by COMPLEX1:29;
then A6: (y.|.y) = c1 by A4,COMPLEX1:29;
       ((c1*x+c2*y).|.(c1*x+c2*y))
      = c1*c1*' *(x.|.x) + c1*c2*' *(x.|.y)
       +c1*' *c2*(y.|.x) + c2*c2*' *(y.|.y) by Lm10
     .= c1*(c1*' *(x.|.x)) + c1*(c2*' *(x.|.y))
       +c1*' *(c2*(y.|.x)) + c1*(c2*c2*') by A4,A5,COMPLEX1:29
     .= c1*(c1*' *(x.|.x) + c2*' *(x.|.y))
       +c1*(c2*(y.|.x)) + c1*(c2*c2*') by A6,Def13
     .= c1*(c1*' *(x.|.x) + c2*' *(x.|.y) + c2*(y.|.x) + c2*c2*')
     .= c1*(c1*(x.|.x) + (x.|.y)*c2*' + c2*(y.|.x) + c2*c2*') by A6,Def13
     .= c1*(c1*(x.|.x) + c2*(y.|.x));
then A7: Re( c1*(c1*(x.|.x) + c2*(y.|.x)) ) >= 0 &
     Im( c1*(c1*(x.|.x) + c2*(y.|.x)) ) = 0 by Def13;
       Re( c1*(c1*(x.|.x) + c2*(y.|.x)) )
       = Re c1 * Re (c1*(x.|.x) + c2*(y.|.x))
       - Im c1 * Im (c1*(x.|.x) + c2*(y.|.x)) by COMPLEX1:24
      .= Re c1 * Re (c1*(x.|.x) + c2*(y.|.x))
       - 0 * Im (c1*(x.|.x) + c2*(y.|.x)) by COMPLEX1:28
      .= Re c1 * Re (c1*(x.|.x) + c2*(y.|.x));
then A8: Re c1 >= 0 & Re (c1*(x.|.x) + c2*(y.|.x)) >= 0 or
     Re c1 <= 0 & Re (c1*(x.|.x) + c2*(y.|.x)) <= 0 by A7,SQUARE_1:25;
       |.(y.|.y).| <> 0 by A3,COMPLEX1:131;
then A9: Re (c1*(x.|.x)) + Re (c2*(y.|.x)) >= 0 by A4,A5,A8,COMPLEX1:29,19;
      Re (c2*(y.|.x)) = Re (-(x.|.y)*(y.|.x))
                    .= - Re(x.|.y * y.|.x) by COMPLEX1:34
                    .= - Re((x.|.y) * (x.|.y)*') by Def13;
     then Re (c1*(x.|.x)) - Re((x.|.y) * (x.|.y)*') >= 0 by A9;
then A10: Re (c1*(x.|.x)) >= Re((x.|.y) * (x.|.y)*') + 0 by REAL_1:84;
A11: Re((x.|.y) * (x.|.y)*') = (Re(x.|.y))^2 + (Im(x.|.y))^2
       by COMPLEX1:126;
       (Re(x.|.y))^2 >= 0 & (Im(x.|.y))^2 >= 0 by SQUARE_1:72;
then A12: Re((x.|.y) * (x.|.y)*') >= 0 + 0 by A11,REAL_1:55;
     then abs(Re((x.|.y) * (x.|.y)*')) = Re((x.|.y) * (x.|.y)*')
       by ABSVALUE:def 1;
then A13: abs(Re (c1*(x.|.x))) >= abs(Re((x.|.y) * (x.|.y)*'))
       by A10,A12,ABSVALUE:def 1;
  Im c1 = 0 & Im(x.|.x) = 0 by A4,A5,Def13,COMPLEX1:29;
then A14: Im(c1*(x.|.x)) = Re c1 * 0 + Re (x.|.x)*0 by COMPLEX1:24;
then A15: Im(c1*(x.|.x)) = 0 & Im((x.|.y) * (x.|.y)*') = 0 by COMPLEX1:126;
       |.c1*(x.|.x).| = abs(Re (c1*(x.|.x))) by A14,COMPLEX1:136;
     then |.c1*(x.|.x).| >= |.(x.|.y)*(x.|.y)*' .| by A13,A15,COMPLEX1:136;
     then |.(x.|.x).|*|.(y.|.y).| >= |.(x.|.y)*(x.|.y)*'.| by A6,COMPLEX1:151;
     then |.(x.|.x).|*|.(y.|.y).| >= |.(x.|.y).|*|.(x.|.y)*'.| by COMPLEX1:151
;
     then |.(x.|.x).|*|.(y.|.y).| >= |.(x.|.y).|*|.(x.|.y).| by COMPLEX1:139;
then A16: |.(x.|.x).|*|.(y.|.y).| >= |.(x.|.y).|^2 by SQUARE_1:def 3;
       |.(x.|.y).|^2 >= 0 by SQUARE_1:72;
then A17: sqrt(|.(x.|.x).|*|.(y.|.y).|) >= sqrt(|.(x.|.y).|^2)
       by A16,SQUARE_1:94;
A18: |.(x.|.x).| >= 0 & |.(y.|.y).| >= 0 & |.(x.|.y).| >= 0
       by COMPLEX1:132;
     then sqrt|.(x.|.x).| * sqrt|.(y.|.y).| >= sqrt(|.(x.|.y).|^2)
       by A17,SQUARE_1:97;
     hence thesis by A18,SQUARE_1:89;
   end;
   hence thesis by A1;
end;

definition let X; let x, y;
  pred x, y are_orthogonal means :Def14:
   x .|. y = 0;
  symmetry by Def13,COMPLEX1:113;
end;

theorem
  x, y are_orthogonal implies x, - y are_orthogonal
proof
  assume x, y are_orthogonal;
  then - x .|. y = - 0 by Def14;
  then x .|. (-y) = 0 by Th26;
  hence thesis by Def14;
end;

theorem
  x, y are_orthogonal implies -x, y are_orthogonal
proof
  assume x, y are_orthogonal;
  then - x .|. y = - 0 by Def14;
  then (-x) .|. y = 0 by Th25;
  hence thesis by Def14;
end;

theorem
  x, y are_orthogonal implies -x, -y are_orthogonal
proof
  assume x, y are_orthogonal;
  then x .|. y = 0 by Def14;
  then (-x) .|. (-y) = 0 by Th27;
  hence thesis by Def14;
end;

theorem
  x, 0.X are_orthogonal
proof
     (0.X).|.x = 0 by Th31;
   hence thesis by Def14;
end;

theorem
  x,y are_orthogonal implies (x+y).|.(x+y) = x.|.x + y.|.y
proof
   assume A1:x, y are_orthogonal;
then A2:x .|. y = 0c by Def14;
 y .|. x = 0c by A1,Def14;
   then (x + y) .|. (x + y) = x.|.x + 0c + 0c + y.|.y by A2,Th33
                      .= x.|.x + 0c + y.|.y by COMPLEX1:def 6;
   hence thesis by COMPLEX1:def 6;
end;

theorem
  x,y are_orthogonal implies (x-y).|.(x-y) = x.|.x + y.|.y
proof
   assume A1:x,y are_orthogonal;
then A2:x.|.y = 0 by Def14;
     (x-y).|.(x-y) = x.|.x - x.|.y - y.|.x + y.|.y by Th35
                .= x.|.x + y.|.y - 0 by A1,A2,Def14;
  hence thesis;
end;

definition let X, x;
  func ||.x.|| -> Real equals
:Def15:  sqrt |.(x.|.x).|;
 correctness;
end;

theorem Th44:
||.x.|| = 0 iff x = 0.X
proof
   thus ||.x.|| = 0 implies x = 0'(X)
   proof
     assume ||.x.|| = 0;
then A1:  sqrt |.(x.|.x).| = 0 by Def15;
       0 <= Re (x.|.x) by Def13;
     then 0 <= |.(x.|.x).| by Th36;
     then |.(x.|.x).| = 0 by A1,SQUARE_1:92;
     then x.|.x = 0c by COMPLEX1:131;
     hence thesis by Def13;
   end;
   assume x = 0'(X);
   then x.|.x = 0c by Def13;
   hence thesis by Def15,COMPLEX1:130,SQUARE_1:82;
end;

theorem Th45:
||.a * x.|| = |.a.| * ||.x.||
proof
A1:0 <= |.a*a.| by COMPLEX1:132;
     0 <= Re (x.|.x) by Def13;
then A2:0 <= |.(x.|.x).| by Th36;
A3:0 <= |.a.| by COMPLEX1:132;
     ||.a*x.|| = sqrt |.((a*x).|.(a*x)).| by Def15
            .= sqrt |.(a*(x.|.(a*x))).| by Def13
            .= sqrt |.(a*(a*' *(x.|.x))).| by Th20
            .= sqrt |.((a*a*')*(x.|.x)).|
            .= sqrt (|.(a*a*').|*|.(x.|.x).|) by COMPLEX1:151
            .= sqrt (|.a*a.| * |.(x.|.x).|) by COMPLEX1:155
            .= sqrt |.a*a.| * sqrt |.(x.|.x).| by A1,A2,SQUARE_1:97
            .= sqrt (|.a.|*|.a.|) * sqrt |.(x.|.x).| by COMPLEX1:151
            .= sqrt (|.a.|^2) * sqrt |.(x.|.x).| by SQUARE_1:def 3
            .= |.a.| * sqrt |.(x.|.x).| by A3,SQUARE_1:89;
   hence thesis by Def15;
end;

theorem Th46:
0 <= ||.x.||
proof
     0 <= Re(x.|.x) by Def13;
   then 0 <= |.(x.|.x).| by Th36;
   then 0 <= sqrt |.(x.|.x).| by SQUARE_1:def 4;
   hence thesis by Def15;
end;

theorem Th47:
|.(x.|.y).| <= ||.x.|| * ||.y.||
proof
     |.(x.|.y).| <= sqrt |.(x.|.x).| * sqrt |.(y.|.y).| by Th37;
   then |.(x.|.y).| <= ||.x.|| * sqrt |.(y.|.y).| by Def15;
   hence thesis by Def15;
end;

theorem Th48:
||.x + y.|| <= ||.x.|| + ||.y.||
proof
A1:||.x + y.|| = sqrt |.((x + y).|.(x + y)).| by Def15;
A2:||.x + y.|| >= 0 by Th46;
     Re ((x+y).|.(x+y)) >= 0 by Def13;
then A3:|.((x + y).|.(x + y)).| >= 0 by Th36;
A4:||.x + y.||^2 >= 0 by SQUARE_1:72;
     sqrt ||.x + y.||^2 = sqrt |.((x + y).|.(x + y)).| by A1,A2,SQUARE_1:89;
   then A5: ||.x + y.||^2 = |.((x + y).|.(x + y)).| by A3,A4,SQUARE_1:96;
A6:Re(x.|.x + x.|.y + y.|.x + y.|.y)
    = Re(x.|.x + x.|.y + y.|.x) + Re(y.|.y) by COMPLEX1:19
   .= Re(x.|.x + x.|.y) + Re(y.|.x) + Re(y.|.y) by COMPLEX1:19
   .= Re(x.|.x) + Re(x.|.y) + Re(y.|.x) + Re(y.|.y) by COMPLEX1:19
   .= |.(x.|.x).| + Re(x.|.y) + Re(y.|.x) + Re(y.|.y) by Th36
   .= |.(x.|.x).| + Re(x.|.y) + Re(y.|.x) + |.(y.|.y).| by Th36;
    A7: Re(x.|.y) = Re((x.|.y)*') by COMPLEX1:112 .= Re(y.|.x) by Def13;
A8:Im(x.|.x + x.|.y + y.|.x + y.|.y)
    = Im(x.|.x + x.|.y + y.|.x) + Im(y.|.y) by COMPLEX1:19
   .= Im(x.|.x + x.|.y) + Im(y.|.x) + Im(y.|.y) by COMPLEX1:19
   .= Im(x.|.x) + Im(x.|.y) + Im(y.|.x) + Im(y.|.y) by COMPLEX1:19
   .= 0 + Im(x.|.y) + Im(y.|.x) + Im(y.|.y) by Def13
   .= Im(x.|.y) + Im(y.|.x) + 0 by Def13;
     -Im(x.|.y) = Im((x.|.y)*') by COMPLEX1:112 .= Im(y.|.x) by Def13;
then A9:Im(x.|.x + x.|.y + y.|.x + y.|.y)
    = 0 by A8,XCMPLX_0:def 6;
     Re(x.|.x + x.|.y + y.|.x + y.|.y)
    = Re((x + y).|.(x + y)) by Th33;
then A10:Re(x.|.x + x.|.y + y.|.x + y.|.y) >= 0 by Def13;
     (x.|.x + x.|.y + y.|.x + y.|.y)
    = Re(x.|.x + x.|.y + y.|.x + y.|.y)+0*<i> by A9,COMPLEX1:29;
   then |.(x.|.x + x.|.y + y.|.x + y.|.y).|
    = |.(x.|.x).| + 2*Re(x.|.y) + |.(y.|.y).| by A6,A7,A10,ABSVALUE:def 1;
then A11:||.x + y.||^2 = 2*Re(x.|.y) + (|.(x.|.x).| + |.(y.|.y).|) by A5,Th33;
     |.(x.|.x).| >= 0 by COMPLEX1:132;
   then (sqrt |.(x.|.x).|)^2 = |.(x.|.x).| by SQUARE_1:def 4;
then A12:|.(x.|.x).| = ||.x.||^2 by Def15;
     |.(y.|.y).| >= 0 by COMPLEX1:132;
   then (sqrt |.(y.|.y).|)^2 = |.(y.|.y).| by SQUARE_1:def 4;
then A13:|.(y.|.y).| = ||.y.||^2 by Def15;
     Re(x.|.y) <= |.(x.|.y).| & |.(x.|.y).| <= ||.x.||*||.y.||
     by Th47,COMPLEX1:140;
   then Re(x.|.y) <= ||.x.||*||.y.|| by AXIOMS:22;
   then 2*Re(x.|.y) <= 2*(||.x.||*||.y.||) by AXIOMS:25;
   then ||.x + y.||^2 <= 2*(||.x.||*||.y.||) + (||.x.||^2 + |.(y.|.y).|)
     by A11,A12,AXIOMS:24;
   then ||.x + y.||^2 <= ||.x.||^2 + 2*||.x.||*||.y.|| + ||.y.||^2
     by A13;
then A14:||.x + y.||^2 <= (||.x.|| + ||.y.||)^2 by SQUARE_1:63;
     ||.x.|| >= 0 & ||.y.|| >= 0 by Th46;
   then ||.x.|| + ||.y.|| >= 0 + 0 by REAL_1:55;
   hence thesis by A14,SQUARE_1:78;
end;

theorem Th49:
||.-x.|| = ||.x.||
proof
     ||.-x.|| = ||.(-1r) * x.|| by CLVECT_1:4
           .= |.-1r.| * ||.x.|| by Th45
           .= |.1r.| * ||.x.|| by COMPLEX1:138;
   hence thesis by COMPLEX1:134;
end;

theorem Th50:
||.x.|| - ||.y.|| <= ||.x - y.||
proof
     (x - y) + y = x - (y - y) by RLVECT_1:43
              .= x - 0'(X) by RLVECT_1:28
              .= x by RLVECT_1:26;
   then ||.x.|| <= ||.x - y.|| + ||.y.|| by Th48;
   hence thesis by REAL_1:86;
end;

theorem
  abs(||.x.|| - ||.y.||) <= ||.x - y.||
proof
A1:||.x.|| - ||.y.|| <= ||.x - y.|| by Th50;
     (y - x) + x = y - (x - x) by RLVECT_1:43
              .= y - 0'(X) by RLVECT_1:28
              .= y by RLVECT_1:26;
   then ||.y.|| <= ||.y - x.|| + ||.x.|| by Th48;
   then ||.y.|| - ||.x.|| <= ||.y - x.|| by REAL_1:86;
   then ||.y.|| - ||.x.|| <= ||.(-x) + y.|| by RLVECT_1:def 11;
   then ||.y.|| - ||.x.|| <= ||.-(x - y).|| by RLVECT_1:47;
   then ||.y.|| - ||.x.|| <= ||.x - y.|| by Th49;
   then -(||.x - y.||) <= -(-(||.x.|| - ||.y.||)) by REAL_1:50;
   hence thesis by A1,ABSVALUE:12;
end;

definition let X, x, y;
 func dist(x,y) -> Real equals
:Def16:  ||.x - y.||;
 correctness;
end;

theorem Th52:
dist(x,y) = dist(y,x)
proof
  thus dist(x,y) = ||.x-y.|| by Def16
              .= ||.(-y)+x.|| by RLVECT_1:def 11
              .= ||.-(y-x).|| by RLVECT_1:47
              .= ||.y-x.|| by Th49
              .= dist(y,x) by Def16;
end;

definition let X, x, y;
  redefine func dist(x,y);
  commutativity by Th52;
end;

theorem Th53:
  dist(x,x) = 0
proof
  thus dist(x,x) = ||.x-x.|| by Def16
              .= ||.0'(X).|| by RLVECT_1:28
              .= 0 by Th44;
end;

theorem
  dist(x,z) <= dist(x,y) + dist(y,z)
proof
         dist(x,z) = ||.x-z.|| by Def16
              .= ||.(x-z)+0'(X).|| by RLVECT_1:10
              .= ||.(x-z)+(y-y).|| by RLVECT_1:28
              .= ||.x-(z-(y-y)).|| by RLVECT_1:43
              .= ||.x-(y+(z-y)).|| by RLVECT_1:43
              .= ||.(x-y)-(z-y).|| by RLVECT_1:41
              .= ||.(x-y)+-(z-y).|| by RLVECT_1:def 11
              .= ||.(x-y)+(y+(-z)).|| by RLVECT_1:47
              .= ||.(x-y)+(y-z).|| by RLVECT_1:def 11;
     then dist(x,z) <= ||.x-y.|| + ||.y-z.|| by Th48;
     then dist(x,z) <= dist(x,y) + ||.y-z.|| by Def16;
     hence thesis by Def16;
end;

theorem Th55:
x <> y iff dist(x,y) <> 0
proof
     thus x <> y implies dist(x,y) <> 0
     proof
          assume that
     A1:   x <> y and
     A2:   dist(x,y) = 0;
              ||.x-y.|| = 0 by A2,Def16;
          then x - y = 0'(X) by Th44;
          hence contradiction by A1,RLVECT_1:35;
     end;
     thus thesis by Th53;
end;

theorem Th56:
  dist(x,y) >= 0
proof
    dist(x,y) = ||.x-y.|| by Def16;
  hence thesis by Th46;
end;

theorem
    x <> y iff dist(x,y) > 0
proof
  thus x <> y implies dist(x,y) > 0
  proof
    assume x <> y;
    then dist(x,y) <> 0 by Th55;
    hence thesis by Th56;
  end;
  thus thesis by Th53;
end;

theorem
  dist(x,y) = sqrt |.((x-y) .|. (x-y)).|
proof
      dist(x,y) = ||.x-y.|| by Def16;
     hence thesis by Def15;
end;

theorem
  dist(x + y,u + v) <= dist(x,u) + dist(y,v)
proof
         dist(x + y,u + v) = ||.(x + y) - (u + v).|| by Def16
  .= ||.x + (y - (u + v)).|| by RLVECT_1:42
  .= ||.x + (-(u + v) + y).|| by RLVECT_1:def 11
  .= ||.-(u + v) + (x + y).|| by RLVECT_1:def 6
  .= ||.((-u) + (-v)) + (x + y).|| by RLVECT_1:45
  .= ||.x + ((-u) + (-v)) + y.|| by RLVECT_1:def 6
  .= ||.(x + (-u)) + (-v) + y.|| by RLVECT_1:def 6
  .= ||.x - u + (-v) + y.|| by RLVECT_1:def 11
  .= ||.x - u + (y + -v).|| by RLVECT_1:def 6
  .= ||.x - u + (y - v).|| by RLVECT_1:def 11;
     then dist(x + y,u + v) <= ||.x - u.|| + ||.y - v.|| by Th48;
     then dist(x + y,u + v) <= dist(x,u) + ||.y - v.|| by Def16;
     hence thesis by Def16;
end;

theorem
  dist(x - y,u - v) <= dist(x,u) + dist(y,v)
proof
         dist(x - y,u - v) = ||.(x - y) - (u - v).|| by Def16
  .= ||.((x - y) - u) + v.|| by RLVECT_1:43
  .= ||.(x - (u + y)) + v.|| by RLVECT_1:41
  .= ||.((x - u) - y) + v.|| by RLVECT_1:41
  .= ||.(x - u) - (y - v).|| by RLVECT_1:43
  .= ||.(x - u) + -(y - v).|| by RLVECT_1:def 11;
     then dist(x - y,u - v) <= ||.x - u.|| + ||.-(y - v).|| by Th48;
     then dist(x - y,u - v) <= ||.x - u.|| + ||.y - v.|| by Th49;
     then dist(x - y,u - v) <= dist(x,u) + ||.y - v.|| by Def16;
     hence thesis by Def16;
end;

theorem
  dist(x - z, y - z) = dist(x,y)
proof
     thus dist(x - z,y - z) = ||.(x - z) - (y -z).|| by Def16
  .= ||.((x - z) - y) + z.|| by RLVECT_1:43
  .= ||.(x - (y + z)) + z.|| by RLVECT_1:41
  .= ||.((x - y) - z) + z.|| by RLVECT_1:41
  .= ||.(x - y) - (z - z).|| by RLVECT_1:43
  .= ||.(x - y) - 0'(X).|| by RLVECT_1:28
  .= ||.x - y.|| by RLVECT_1:26
  .= dist(x,y) by Def16;
end;

theorem
  dist(x - z,y - z) <= dist(z,x) + dist(z,y)
proof
         dist(x - z,y - z) = ||.(x - z) - (y - z).|| by Def16
  .= ||.(x - z) + -(y - z).|| by RLVECT_1:def 11
  .= ||.(x - z) + (z +(-y)).|| by RLVECT_1:47
  .= ||.(x - z) + (z - y).|| by RLVECT_1:def 11
  .= ||.((-z) + x) + (z - y).|| by RLVECT_1:def 11
  .= ||.-(z - x) + (z - y).|| by RLVECT_1:47;
     then dist(x - z,y - z) <= ||.-(z - x).|| + ||.z - y.|| by Th48;
     then dist(x - z,y - z) <= ||.z - x.|| + ||.z - y.|| by Th49;
     then dist(x - z,y - z) <= dist(z,x) + ||.z - y.|| by Def16;
     hence thesis by Def16;
end;

reserve seq, seq1, seq2, seq3 for sequence of X;
reserve k, n, m for Nat;
reserve f for Function;
reserve d, s, t for set;

definition let X; let seq;
 func - seq -> sequence of X means
:Def17: for n holds it.n = - seq.n;
existence
proof
  deffunc F(Nat) = -seq.$1;
    ex seq be sequence of X st for n holds seq.n = F(n) from FUNCT_2:sch 4;
  hence thesis;
end;
uniqueness
  proof
    let seq1, seq2 such that
    A1:  for n holds seq1.n = - seq.n and
    A2:  for n holds seq2.n = - seq.n;
        now let n;
          seq1.n = - seq.n by A1;
      hence seq1.n = seq2.n by A2;
    end;
    hence seq1 = seq2 by FUNCT_2:113;
  end;
end;

definition let X; let seq; let x;
 func seq + x -> sequence of X means :Def18:
  for n holds it.n = seq.n + x;
existence
proof
  deffunc F(Nat) = seq.$1 + x;
    ex seq be sequence of X st for n holds seq.n = F(n) from FUNCT_2:sch 4;
  hence thesis;
end;
uniqueness
proof
     let seq1, seq2;
     assume that
A1:  ( for n holds seq1.n = seq.n + x ) and
A2:  ( for n holds seq2.n = seq.n + x );
         for n holds seq1.n = seq2.n
     proof
          let n;
            seq1.n = seq.n + x by A1;
          hence thesis by A2;
     end;
    hence thesis by FUNCT_2:113;
end;
end;

theorem Th63:
seq1 + seq2 = seq2 + seq1
proof
     now let n;
     thus (seq1 + seq2).n = seq2.n + seq1.n by CLVECT_1:def 11
                    .= (seq2 + seq1).n by CLVECT_1:def 11;
   end;
   hence thesis by FUNCT_2:113;
end;

definition let X, seq1, seq2;
 redefine func seq1 + seq2;
 commutativity by Th63;
end;

theorem
  seq1 + (seq2 + seq3) = (seq1 + seq2) + seq3
proof
         now let n;
     thus
         (seq1 + (seq2 + seq3)).n = seq1.n + (seq2 + seq3).n by CLVECT_1:def 11
  .= seq1.n + (seq2.n + seq3.n) by CLVECT_1:def 11
  .= (seq1.n + seq2.n) + seq3.n by RLVECT_1:def 6
  .= (seq1 + seq2).n + seq3.n by CLVECT_1:def 11
  .= ((seq1 + seq2) + seq3).n by CLVECT_1:def 11;
     end;
     hence thesis by FUNCT_2:113;
end;

theorem
  seq1 is constant & seq2 is constant & seq = seq1 + seq2 implies
 seq is constant
proof
     assume that
A1:   seq1 is constant and
A2:   seq2 is constant and
A3:   seq = seq1 + seq2;
     consider x such that
A4:   for n holds seq1.n = x by A1,NORMSP_1:def 4;
     consider y such that
A5:   for n holds seq2.n = y by A2,NORMSP_1:def 4;
     take z = x + y;
         now let n;
     thus seq.n = seq1.n + seq2.n by A3,CLVECT_1:def 11
          .= x + seq2.n by A4
          .= z by A5;
     end;
     hence thesis;
end;

theorem
  seq1 is constant & seq2 is constant & seq = seq1 - seq2 implies
 seq is constant
proof
     assume that
A1:   seq1 is constant and
A2:   seq2 is constant and
A3:   seq = seq1 - seq2;
     consider x such that
A4:   for n holds seq1.n = x by A1,NORMSP_1:def 4;
     consider y such that
A5:   for n holds seq2.n = y by A2,NORMSP_1:def 4;
     take z = x - y;
         now let n;
     thus seq.n = seq1.n - seq2.n by A3,CLVECT_1:def 12
          .= x - seq2.n by A4
          .= z by A5;
     end;
     hence thesis;
end;

theorem
  seq1 is constant & seq = a * seq1 implies seq is constant
proof
     assume that
A1:   seq1 is constant and
A2:   seq = a * seq1;
     consider x such that
A3:   for n holds seq1.n = x by A1,NORMSP_1:def 4;
     take z = a * x;
         now let n;
     thus seq.n = a * seq1.n by A2,CLVECT_1:def 14
          .= z by A3;
     end;
     hence thesis;
end;

theorem Th68:
seq is constant iff for n holds seq.n = seq.(n + 1)
proof
     thus seq is constant implies for n holds seq.n=seq.(n + 1)
     proof
          assume seq is constant;
          then ex x st rng seq = {x} by NORMSP_1:27;
          hence thesis by NORMSP_1:21;
     end;
     assume for n holds seq.n = seq.(n + 1);
     then for n, k holds seq.n = seq.(n + k) by NORMSP_1:22;
     then for n, m holds seq.n = seq.m by NORMSP_1:23;
     hence ex x st for n holds seq.n = x by NORMSP_1:24;
end;

theorem Th69:
seq is constant iff for n , k holds seq.n = seq.(n + k)
proof
     thus seq is constant implies for n , k holds seq.n = seq.(n + k)
     proof
          assume seq is constant;
          then for n holds seq.n=seq.(n+1) by Th68;
          hence thesis by NORMSP_1:22;
     end;
     assume for n, k holds seq.n = seq.(n + k);
     then for n, m holds seq.n = seq.m by NORMSP_1:23;
     hence ex x st for n holds seq.n = x by NORMSP_1:24;
end;

theorem
  seq is constant iff for n, m holds seq.n = seq.m
proof
     thus seq is constant implies for n, m holds seq.n = seq.m
     proof
          assume seq is constant;
          then for n, k holds seq.n = seq.(n + k) by Th69;
          hence thesis by NORMSP_1:23;
     end;
     assume for n, m holds seq.n = seq.m;
     hence ex x st for n holds seq.n = x by NORMSP_1:24;
end;

theorem
  seq1 - seq2 = seq1 + -seq2
proof
    now let n;
     thus (seq1 - seq2).n = seq1.n - seq2.n by CLVECT_1:def 12
                    .= seq1.n + -seq2.n by RLVECT_1:def 11
                    .= seq1.n + (-seq2).n by Def17
                    .= (seq1 + -seq2).n by CLVECT_1:def 11;
  end;
  hence thesis by FUNCT_2:113;
end;

theorem
  seq = seq + 0.X
proof
         now let n;
     thus (seq + 0'(X)).n = seq.n + 0'(X) by Def18
                    .= seq.n by RLVECT_1:10;
     end;
     hence thesis by FUNCT_2:113;
end;

theorem
  a * (seq1 + seq2) = a * seq1 + a * seq2
proof
         now let n;
     thus (a * (seq1 + seq2)).n = a * (seq1 + seq2).n by CLVECT_1:def 14
                          .= a * (seq1.n + seq2.n) by CLVECT_1:def 11
                          .= a * seq1.n + a * seq2.n by CLVECT_1:def 2
                          .= (a * seq1).n + a * seq2.n by CLVECT_1:def 14
                          .= (a * seq1).n + (a * seq2).n by CLVECT_1:def 14
                          .= (a * seq1 + a * seq2).n by CLVECT_1:def 11;
     end;
     hence thesis by FUNCT_2:113;
end;

theorem
  (a + b) * seq = a * seq + b * seq
proof
         now let n;
     thus ((a + b) * seq).n = (a + b) * seq.n by CLVECT_1:def 14
                      .= a * seq.n + b * seq.n by CLVECT_1:def 2
                      .= (a * seq).n + b * seq.n by CLVECT_1:def 14
                      .= (a * seq).n + (b * seq).n by CLVECT_1:def 14
                      .= (a * seq + b * seq).n by CLVECT_1:def 11;
     end;
     hence thesis by FUNCT_2:113;
end;

theorem
  (a * b) * seq = a * (b * seq)
proof
         now let n;
     thus ((a * b) * seq).n = (a * b) * seq.n by CLVECT_1:def 14
                      .= a * (b * seq.n) by CLVECT_1:def 2
                      .= a * (b * seq).n by CLVECT_1:def 14
                      .= (a * (b * seq)).n by CLVECT_1:def 14;
     end;
     hence thesis by FUNCT_2:113;
end;

theorem
  1r * seq = seq
proof
    now let n;
     thus (1r * seq).n = 1r * seq.n by CLVECT_1:def 14
                .= seq.n by CLVECT_1:def 2;
  end;
  hence thesis by FUNCT_2:113;
end;

theorem
  (-1r) * seq = - seq
proof
         now let n;
     thus ((-1r) * seq).n = (-1r) * seq.n by CLVECT_1:def 14
                   .= - seq.n by CLVECT_1:4
                   .= (-seq).n by Def17;
     end;
     hence thesis by FUNCT_2:113;
end;

theorem
  seq - x = seq + -x
proof
         now let n;
     thus (seq - x).n = seq.n - x by CLVECT_1:def 13
                .= seq.n + -x by RLVECT_1:def 11
                .= (seq + -x).n by Def18;
     end;
     hence thesis by FUNCT_2:113;
end;

theorem
  seq1 - seq2 = - (seq2 - seq1)
proof
         now let n;
     thus (seq1 - seq2).n = seq1.n - seq2.n by CLVECT_1:def 12
                    .= -seq2.n + seq1.n by RLVECT_1:def 11
                    .= - (seq2.n - seq1.n) by RLVECT_1:47
                    .= - (seq2 - seq1).n by CLVECT_1:def 12
                    .= (- (seq2 - seq1)).n by Def17;
     end;
     hence thesis by FUNCT_2:113;
end;

theorem
  seq = seq - 0.X
proof
         now let n;
     thus (seq - 0'(X)).n = seq.n - 0'(X) by CLVECT_1:def 13
                    .= seq.n by RLVECT_1:26;
     end;
     hence thesis by FUNCT_2:113;
end;

theorem
  seq = - ( - seq )
proof
    now let n;
     thus (- ( - seq )).n = - (- seq).n by Def17
                    .= - ( - seq.n) by Def17
                    .= seq.n by RLVECT_1:30;
  end;
  hence thesis by FUNCT_2:113;
end;

theorem
  seq1 - (seq2 + seq3) = (seq1 - seq2) - seq3
proof
    now let n;
     thus
         (seq1 - (seq2 + seq3)).n = seq1.n - (seq2 + seq3).n by CLVECT_1:def 12
                             .= seq1.n - (seq2.n + seq3.n) by CLVECT_1:def 11
                             .= (seq1.n - seq2.n) - seq3.n by RLVECT_1:41
                             .= (seq1 - seq2).n - seq3.n by CLVECT_1:def 12
                             .= ((seq1 - seq2) - seq3).n by CLVECT_1:def 12;
  end;
  hence thesis by FUNCT_2:113;
end;

theorem
  (seq1 + seq2) - seq3 = seq1 + (seq2 - seq3)
proof
         now let n;
     thus
         ((seq1 + seq2) - seq3).n = (seq1 + seq2).n - seq3.n by CLVECT_1:def 12
                             .= (seq1.n + seq2.n) - seq3.n by CLVECT_1:def 11
                             .= seq1.n + (seq2.n - seq3.n) by RLVECT_1:42
                             .= seq1.n + (seq2 - seq3).n by CLVECT_1:def 12
                             .= (seq1 + (seq2 - seq3)).n by CLVECT_1:def 11;
     end;
     hence thesis by FUNCT_2:113;
end;

theorem
  seq1 - (seq2 - seq3) = (seq1 - seq2) + seq3
proof
   now let n;
  thus
      (seq1 - (seq2 - seq3)).n = seq1.n - (seq2 - seq3).n by CLVECT_1:def 12
                          .= seq1.n - (seq2.n - seq3.n) by CLVECT_1:def 12
                          .= (seq1.n - seq2.n) + seq3.n by RLVECT_1:43
                          .= (seq1 - seq2).n + seq3.n by CLVECT_1:def 12
                          .= ((seq1 - seq2) + seq3).n by CLVECT_1:def 11;
  end;
  hence thesis by FUNCT_2:113;
end;

theorem
    a * (seq1 - seq2) = a * seq1 - a * seq2
proof
    now let n;
    thus
        (a * (seq1 - seq2)).n = a * (seq1 - seq2).n by CLVECT_1:def 14
                          .= a * (seq1.n - seq2.n) by CLVECT_1:def 12
                          .= a * seq1.n - a * seq2.n by CLVECT_1:10
                          .= (a * seq1).n - a * seq2.n by CLVECT_1:def 14
                          .= (a * seq1).n - (a * seq2).n by CLVECT_1:def 14
                          .= (a * seq1 - a * seq2).n by CLVECT_1:def 12;
  end;
  hence thesis by FUNCT_2:113;
end;

begin :: Complex unitary space of complex sequence

theorem Th86:
ex f be Function of
 [: the_set_of_l2ComplexSequences, the_set_of_l2ComplexSequences :], COMPLEX st
 (for x,y be set st
  x in the_set_of_l2ComplexSequences & y in the_set_of_l2ComplexSequences
   holds f.[x,y] = Sum(seq_id(x)(#)(seq_id(y))*') )
proof
   set X = the_set_of_l2ComplexSequences;
   deffunc F(set,set) = Sum(seq_id($1)(#)(seq_id($2))*');
A1:for x,y being set st x in X & y in X holds F(x,y) in COMPLEX;
     ex f being Function of [:X,X:],COMPLEX st
    for x,y being set st x in X & y in X holds
     f.[x,y] = F(x,y) from FUNCT_2:sch 6(A1);
  hence thesis;
end;

definition
func cl_scalar -> Function of
 [:the_set_of_l2ComplexSequences, the_set_of_l2ComplexSequences:], COMPLEX
means
   (for x,y be set st
  x in the_set_of_l2ComplexSequences & y in the_set_of_l2ComplexSequences
   holds it.[x,y] = Sum(seq_id(x)(#)(seq_id(y))*'));
existence by Th86;
uniqueness
proof
   set X = the_set_of_l2ComplexSequences;
   let scalar1, scalar2 be Function of [: X, X :], COMPLEX such that
A1:(for x,y be set st x in X & y in X holds
     scalar1.[x,y] = Sum(seq_id(x)(#)(seq_id(y))*')) and
A2:(for x,y be set st x in X & y in X holds
     scalar2.[x,y] = Sum(seq_id(x)(#)(seq_id(y))*'));
     for x, y be set st x in X & y in X holds scalar1.[x,y] = scalar2.[x,y]
   proof
     let x,y be set such that
A3:  x in X & y in X;
     thus scalar1.[x,y] = Sum(seq_id(x)(#)(seq_id(y))*') by A1,A3
                       .= scalar2.[x,y] by A2,A3;
   end;
   hence thesis by FUNCT_2:118;
end;
end;

registration
 cluster CUNITSTR (# the_set_of_l2ComplexSequences,
    Zero_(the_set_of_l2ComplexSequences,Linear_Space_of_ComplexSequences),
    Add_(the_set_of_l2ComplexSequences,Linear_Space_of_ComplexSequences),
    Mult_(the_set_of_l2ComplexSequences,Linear_Space_of_ComplexSequences),
    cl_scalar #) -> non empty;
coherence
proof
     the_set_of_l2ComplexSequences is non empty by Def11;
   hence thesis by STRUCT_0:def 1;
   end;
end;

definition
func Complex_l2_Space -> non empty CUNITSTR equals :Def20:
 CUNITSTR (# the_set_of_l2ComplexSequences,
   Zero_(the_set_of_l2ComplexSequences,Linear_Space_of_ComplexSequences),
   Add_(the_set_of_l2ComplexSequences,Linear_Space_of_ComplexSequences),
   Mult_(the_set_of_l2ComplexSequences,Linear_Space_of_ComplexSequences),
   cl_scalar #);
correctness;
end;

theorem Th87:
for l be CUNITSTR st
CLSStruct (# the carrier of l, the Zero of l, the add of l,
 the Mult of l #) is ComplexLinearSpace holds l is ComplexLinearSpace
proof
   let l be CUNITSTR such that
A1:CLSStruct (# the carrier of l, the Zero of l, the add of l,
     the Mult of l #) is ComplexLinearSpace;
     the carrier of l is non empty by A1,STRUCT_0:def 1;
   then reconsider l as non empty CLSStruct by STRUCT_0:def 1;
   reconsider l0=CLSStruct (# the carrier of l, the Zero of l, the add of l,
        the Mult of l #) as ComplexLinearSpace by A1;
A2:for v,w being VECTOR of l holds v + w = w + v
   proof
     let v,w be VECTOR of l;
     reconsider v1=v as VECTOR of l0;
     reconsider w1=w as VECTOR of l0;
     thus v+w = (the add of l).[v1,w1] by RLVECT_1:def 3
             .=v1+w1 by RLVECT_1:def 3
             .= (the add of l).[w1,v1] by RLVECT_1:def 3
             .= w +v by RLVECT_1:def 3;
   end;
A3:for u,v,w being VECTOR of l holds (u + v) + w = u + (v + w)
   proof
     let u,v,w be VECTOR of l;
     reconsider u1=u as VECTOR of l0;
     reconsider v1=v as VECTOR of l0;
     reconsider w1=w as VECTOR of l0;
     thus (u + v) + w
        = (the add of l).[(u+v),w] by RLVECT_1:def 3
       .= (the add of l).[(the add of l).[u,v],w] by RLVECT_1:def 3
       .= (the add of l).[(u1+v1),w] by RLVECT_1:def 3
       .= (u1+v1)+w1 by RLVECT_1:def 3
       .= u1+(v1+w1) by RLVECT_1:def 6
       .= (the add of l).[u1,(v1+w1)] by RLVECT_1:def 3
       .= (the add of l).[u1,(the add of l).[v1,w1]] by RLVECT_1:def 3
       .= (the add of l).[u,(v+w)] by RLVECT_1:def 3
       .= u+(v+w) by RLVECT_1:def 3;
   end;
A4:for v being VECTOR of l holds v + 0.l = v
   proof
     let v be VECTOR of l;
     reconsider v1=v as VECTOR of l0;
A5:  0.l=the Zero of l by RLVECT_1:def 2
       .=0.l0 by RLVECT_1:def 2;
     thus v+0.l=(the add of l).[v,0.l] by RLVECT_1:def 3
              .= v1 + 0.l0 by A5,RLVECT_1:def 3
              .= v by RLVECT_1:def 7;
   end;

A6:for v being VECTOR of l ex w being VECTOR of l st v + w = 0.l
   proof
     let v be VECTOR of l;
     reconsider v1=v as VECTOR of l0;
A7:  0.l = the Zero of l by RLVECT_1:def 2
        .= 0.l0 by RLVECT_1:def 2;
     consider w1 being VECTOR of l0 such that
A8:  v1 + w1 = 0.l0 by RLVECT_1:def 8;
     reconsider w = w1 as VECTOR of l;
A9:  v+w = (the add of l).[v,w] by RLVECT_1:def 3
        .= 0.l by A7,A8,RLVECT_1:def 3;
     take w;
     thus thesis by A9;
   end;

A10:for z being Complex for v,w being VECTOR of l holds
         z * (v + w) = z * v + z * w
   proof
     let z be Complex;
     let v,w be VECTOR of l;
     reconsider v1=v, w1=w as VECTOR of l0;
     thus z*(v+w) = (the Mult of l).[z,(v+w)] by CLVECT_1:def 1
        .= (the Mult of l).[z,(the add of l).[v1,w1]] by RLVECT_1:def 3
        .= (the Mult of l).[z,(v1+w1)] by RLVECT_1:def 3
        .=z*(v1+w1) by CLVECT_1:def 1
        .=z*v1+z*w1 by CLVECT_1:def 2
       .=(the add of l).[z*v1,z*w1] by RLVECT_1:def 3
       .=(the add of l).[(the Mult of l).[z,v1],z*w1] by CLVECT_1:def 1
       .=(the add of l).[(the Mult of l).[z,v1],
                (the Mult of l).[z,w1]] by CLVECT_1:def 1
       .=(the add of l).[z*v, (the Mult of l).[z,w]] by CLVECT_1:def 1
       .=(the add of l).[z*v, z*w] by CLVECT_1:def 1
       .= z*v +z*w by RLVECT_1:def 3;
   end;

A11:for z1,z2 be Complex for v being VECTOR of l holds
     (z1 + z2) * v = z1 * v + z2 * v
   proof
     let z1,z2 be Complex;
     let v be VECTOR of l;
     reconsider v1=v as VECTOR of l0;
     thus (z1+z2)*v = (the Mult of l).[(z1+z2),v] by CLVECT_1:def 1
       .=(z1+z2)*v1 by CLVECT_1:def 1
       .=z1*v1+z2*v1 by CLVECT_1:def 2
       .=(the add of l).[z1*v1,z2*v1] by RLVECT_1:def 3
       .=(the add of l).[(the Mult of l).[z1,v1],z2*v1] by CLVECT_1:def 1
       .=(the add of l).[(the Mult of l).[z1,v1],
                (the Mult of l).[z2,v1]] by CLVECT_1:def 1
       .=(the add of l).[z1*v, (the Mult of l).[z2,v]] by CLVECT_1:def 1
       .=(the add of l).[z1*v, z2*v] by CLVECT_1:def 1
       .= z1*v +z2*v by RLVECT_1:def 3;
   end;

A12:for z1,z2 be Complex, v being VECTOR of l holds
     (z1 * z2) * v = z1 * (z2 * v)
   proof
     let z1,z2 be Complex;
     let v be VECTOR of l;
     reconsider v1=v as VECTOR of l0;
     thus (z1*z2)*v = (the Mult of l).[z1*z2,v] by CLVECT_1:def 1
       .=(z1*z2)*v1 by CLVECT_1:def 1
       .=z1*(z2*v1) by CLVECT_1:def 2
       .=(the Mult of l).[z1,z2*v1] by CLVECT_1:def 1
       .=(the Mult of l).[z1,(the Mult of l).[z2,v1]] by CLVECT_1:def 1
       .=(the Mult of l).[z1,z2*v] by CLVECT_1:def 1
       .= z1*(z2*v) by CLVECT_1:def 1;
   end;
     for v being VECTOR of l holds 1r * v = v
   proof
     let v be VECTOR of l;
     reconsider v1=v as VECTOR of l0;
     thus 1r*v= (the Mult of l).[1r,v] by CLVECT_1:def 1
            .= 1r*v1 by CLVECT_1:def 1
            .= v by CLVECT_1:def 2;
   end;
   hence thesis by A2,A3,A4,A6,A10,A11,A12,CLVECT_1:1;
end;

theorem
  for seq be Complex_Sequence st (for n be Nat holds seq.n=0c) holds
  seq is summable & Sum seq = 0c
proof
   let seq be Complex_Sequence such that
A1:for n be Nat holds seq.n=0c;
A2:for m be Nat holds Partial_Sums (seq).m = 0c
   proof
     let m be Nat;
     defpred P[Nat] means seq.$1 = (Partial_Sums seq).$1;
A3:  P[0] by COMSEQ_3:def 7;
A4:  for k be Nat st P[k] holds P[k+1]
     proof
       let k be Nat such that
A5:    seq.k = (Partial_Sums (seq)).k;
       thus seq.(k+1) = 0c + (seq).(k+1) by COMPLEX1:def 6
                     .= seq.k + seq.(k+1) by A1
                     .= (Partial_Sums seq).(k+1) by A5,COMSEQ_3:def 7;
     end;
       for n be Nat holds P[n] from NAT_1:sch 1(A3,A4);
     hence (Partial_Sums (seq)).m = seq.m .= 0c by A1;
   end;
     Sum seq = 0c & seq is summable
   proof
A6:  for p be Real st 0<p
      ex n be Nat st
       for m be Nat st n<=m holds |.((Partial_Sums seq).m-0c).|<p
     proof
       let p be Real such that
A7:    0<p;
       take 0;
       let m be Nat such that 0<=m;
       thus |.((Partial_Sums (seq)).m-0c).|<p by A2,A7,COMPLEX1:130;
     end;
then A8:  Partial_Sums (seq) is convergent by COMSEQ_2:def 4;
     then lim (Partial_Sums (seq)) = 0c by A6,COMSEQ_2:def 5;
     hence thesis by A8,COMSEQ_3:def 8,def 10;
   end;
   hence thesis;
end;

registration
 cluster Complex_l2_Space -> Abelian add-associative right_zeroed
    right_complementable ComplexLinearSpace-like;
  coherence by Def20,Th16,Th87;
end;
