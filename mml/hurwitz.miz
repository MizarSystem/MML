:: Schur's Theorem on the Stability of Networks
::  by Agnieszka Rowi\'nska-Schwarzweller and Christoph Schwarzweller
::
:: Received October 19, 2006
:: Copyright (c) 2006 Association of Mizar Users

environ

 vocabularies ARYTM_3, GROUP_1, POLYNOM2, COMPLFLD, POLYNOM1, ARYTM_1, FUNCT_1,
      FINSEQ_1, COMPLEX1, FUNCT_4, POLYNOM3, RELAT_1, RLVECT_1, NORMSP_1,
      BOOLE, VECTSP_1, BINOP_1, ALGSEQ_1, FUNCOP_1, LATTICES, FINSEQ_4,
      POLYNOM5, NAT_1, XCMPLX_0, SQUARE_1, SGRAPH1, INT_1, VECTSP_2, ALGSTR_2,
      HURWITZ, ARYTM, ALGSTR_0, CAT_1;
 notations TARSKI, XBOOLE_0, SUBSET_1, RELAT_1, NUMBERS, XCMPLX_0, ALGSTR_0,
      VECTSP_2, FUNCT_1, PARTFUN1, FUNCT_2, NAT_1, NAT_D, XXREAL_0, SEQ_1,
      GROUP_1, INT_1, FUNCOP_1, RLVECT_1, POLYNOM1, COMPLEX1, COMPLFLD,
      FINSEQ_1, BINOP_1, BINARITH, NORMSP_1, BHSP_1, ALGSEQ_1, FUNCT_4,
      POLYNOM3, POLYNOM4, RELSET_1, POLYNOM5, STRUCT_0, VECTSP_1, SQUARE_1;
 constructors BINOP_1, REAL_1, SQUARE_1, FINSOP_1, BINARITH, VECTSP_2,
      ALGSTR_1, BHSP_1, POLYNOM1, POLYNOM4, POLYNOM5, SEQ_1, BINOP_2, NAT_D,
      RELSET_1;
 registrations XBOOLE_0, ORDINAL1, RELSET_1, XCMPLX_0, XXREAL_0, XREAL_0,
      SQUARE_1, NAT_1, INT_1, MEMBERED, FINSEQ_1, STRUCT_0, VECTSP_1, COMPLFLD,
      ALGSTR_1, GCD_1, POLYNOM3, POLYNOM4, POLYNOM5, FUNCT_4, FUNCOP_1;
 requirements NUMERALS, SUBSET, REAL, BOOLE, ARITHM;
 definitions FINSEQ_1, POLYNOM3, COMPLEX1, SQUARE_1, FUNCOP_1;
 theorems GROUP_1, VECTSP_1, ALGSEQ_1, NAT_1, FUNCT_1, FUNCT_2, XREAL_1,
      SQUARE_1, VECTSP_2, INT_1, FINSEQ_1, RLVECT_1, POLYNOM4, TARSKI, FUNCT_4,
      POLYNOM3, XBOOLE_1, POLYNOM2, FUNCOP_1, XCMPLX_1, XCMPLX_0, COMPLFLD,
      POLYNOM5, XXREAL_0, ALGSTR_1, COMPLEX1, FINSEQ_2, POLYNOM1, FINSEQ_3,
      BHSP_1, NORMSP_1, ORDINAL1, PARTFUN1, XREAL_0, NAT_D;
 schemes NAT_1, FUNCT_2, FINSEQ_1;

begin :: Preliminaries

Lm1: for L being add-associative right_zeroed right_complementable
(non empty addLoopStr) for F being FinSequence of L for G being FinSequence
for k being Nat st G = F|(Seg k) & len F = k + 1 holds
G is FinSequence of L & dom G c= dom F & len G = k & F = G ^ <*F/.(k+1)*>
proof
  let L be add-associative right_zeroed right_complementable
  (non empty addLoopStr);
  let F be FinSequence of L;
  let G1 be FinSequence;
  let k be Nat;
  assume
A1: G1 = F|(Seg k) & len F = k + 1;
  reconsider G = G1 as FinSequence;
A2: k <= len F by A1,NAT_1:13;
  then
A3: len G = k by A1,FINSEQ_1:21;
  now
    let u be set;
    assume u in rng G;
    then consider x being set such that
A4: x in dom G & G.x = u by FUNCT_1:def 5;
    reconsider x' = x as Element of NAT by A4;
A5: 1 <= x' & x' <= len G by A4,FINSEQ_3:27;
    then x' <= len F by A1,A3,NAT_1:12;
    then
A6: x in dom F by A5,FINSEQ_3:27;
    G.x = F.x by A1,A4,FUNCT_1:70
      .= F/.x by A6,PARTFUN1:def 8;
    hence u in the carrier of L by A4;
  end;
  then
A7: rng G c= the carrier of L by TARSKI:def 3;
  then reconsider G as FinSequence of L by FINSEQ_1:def 4;
  thus G1 is FinSequence of L by A7,FINSEQ_1:def 4;
A8: dom(G^<*F/.(k+1)*>) = Seg(len G + len <*F/.(k+1)*>) by FINSEQ_1:def 7
    .= Seg(k+1) by A3,FINSEQ_1:57
    .= dom F by A1,FINSEQ_1:def 3;
  hence dom G1 c= dom F by FINSEQ_1:39;
  thus len G1 = k by A1,A2,FINSEQ_1:21;
  now
    let j be Nat;
    assume
A9: j in dom F;
    per cases;
    suppose
A10:  j in dom G;
      hence F.j = G.j by A1,FUNCT_1:70
        .= (G^<*F/.(k+1)*>).j by A10,FINSEQ_1:def 7;
    end;
    suppose
A11:  not j in dom G;
A12:  j = k + 1
      proof
        dom F = Seg len F by FINSEQ_1:def 3;
        then
A13:    1 <= j & j <= k + 1 by A1,A9,FINSEQ_1:3;
        now
          assume j < k + 1;
          then j <= k by NAT_1:13;
          then j in Seg k by A9,A13;
          hence contradiction by A1,A2,A11,FINSEQ_1:21;
        end;
        hence thesis by A13,XXREAL_0:1;
      end;
      dom <*F/.(k+1)*> = {1} by FINSEQ_1:4,55;
      then 1 in dom <*F/.(k+1)*> by TARSKI:def 1;
      hence (G^<*F/.(k+1)*>).j = <*F/.(k+1)*>.1 by A3,A12,FINSEQ_1:def 7
        .= F/.(k+1) by FINSEQ_1:57
        .= F.j by A9,A12,PARTFUN1:def 8;
    end;
  end;
  hence thesis by A8,FINSEQ_1:17;
end;

theorem Th1:
  for L being add-associative right_zeroed right_complementable
  associative commutative well-unital distributive
  almost_left_invertible (non empty doubleLoopStr)
  for x being Element of L st x <> 0.L holds -(x") = (-x)"
proof
  let L be add-associative right_zeroed right_complementable
  associative commutative well-unital distributive
  almost_left_invertible (non empty doubleLoopStr);
  let x be Element of L;
  assume
A1: x <> 0.L;
A2: now
    assume -x = 0.L;
    then --x = 0.L by RLVECT_1:25;
    hence contradiction by A1,RLVECT_1:30;
  end;
  (-x) * (-(x")) = -((-x) * x") by VECTSP_1:40
    .= -(-(x * x")) by VECTSP_1:40
    .= -(- 1_L) by A1,VECTSP_1:def 22
    .= 1_L by RLVECT_1:30;
  hence thesis by A2,VECTSP_1:def 22;
end;

theorem Th2:
  for L being add-associative right_zeroed right_complementable
  associative commutative well-unital almost_left_invertible
  distributive non degenerated (non empty doubleLoopStr)
  for k being Element of NAT holds power(L).(-1_L,k) <> 0.L
proof
  let L be add-associative right_zeroed right_complementable
  associative commutative well-unital almost_left_invertible
  distributive non degenerated (non empty doubleLoopStr), k be Element of NAT;
  defpred P[Nat] means power(L).(-1_L,$1) <> 0.L;
A1: P[0] by GROUP_1:def 8;
A2: now
    let k be Element of NAT;
    assume
A3: P[k];
A4: power(L).(-1_L,k+1) = power(L).(-1_L,k) * (-1_L) by GROUP_1:def 8;
    now
      assume
A5:   -1_L = 0.L;
      1_L = 1_L * 1_L by VECTSP_1:def 13
        .= (-1_L) * (-1_L) by VECTSP_1:42
        .= 0.L by A5,VECTSP_1:36;
      hence contradiction;
    end;
    hence P[k+1] by A3,A4,VECTSP_1:44;
  end;
  for k be Element of NAT holds P[k] from NAT_1:sch 1(A1,A2);
  hence thesis;
end;

theorem Th3:
  for L being associative well-unital (non empty multLoopStr)
  for x being Element of L for k1,k2 being Element of NAT
  holds power(L).(x,k1) * power(L).(x,k2) = power(L).(x,k1+k2)
proof
  let L be associative well-unital (non empty multLoopStr), x be Element of L,
  k1,k2 be Element of NAT;
  defpred P[Nat] means ex j being Element of NAT st j = $1 &
  power(L).(x,k1) * power(L).(x,j) = power(L).(x,k1+j);
  1_L = 1.L;
  then power(L).(x,k1) * power(L).(x,0) = power(L).(x,k1) * 1.L by
  GROUP_1:def 8
    .= power(L).(x,k1+0) by VECTSP_1:def 13;
  then
A1: P[0];
A2: now
    let j be Element of NAT;
    assume
A3: P[j];
    power(L).(x,k1) * power(L).(x,j+1)
    = power(L).(x,k1) * (power(L).(x,j) * x) by GROUP_1:def 8
      .= (power(L).(x,k1) * power(L).(x,j)) * x by GROUP_1:def 4
      .= power(L).(x,(k1+j)+1) by A3,GROUP_1:def 8
      .= power(L).(x,k1+(j+1));
    hence P[j+1];
  end;
  for k be Element of NAT holds P[k] from NAT_1:sch 1(A1,A2);
  then consider j be Element of NAT such that
A4: j = k2 & power(L).(x,k1) * power(L).(x,j) = power(L).(x,k1+j);
  thus thesis by A4;
end;

Lm2: Im(1_F_Complex) = 0 & Im(-1_F_Complex) = 0 & Im(0.F_Complex) = 0
proof
  thus Im(1_F_Complex) = 0 by COMPLEX1:15,COMPLFLD:10;
  -1_F_Complex = -1r by COMPLFLD:4,10;
  hence Im(-1_F_Complex) = -0 by COMPLEX1:15,34
    .= 0;
  thus thesis by COMPLEX1:12,COMPLFLD:9;
end;

Lm3: for z being Element of F_Complex st Im(z) = 0 holds z*' = z
proof
  let z be Element of F_Complex;
  assume
A1: Im(z) = 0;
  the carrier of F_Complex = COMPLEX by COMPLFLD:def 1;
  hence thesis by A1,COMPLEX1:124;
end;

theorem Th4:
  for L being add-associative right_zeroed right_complementable
  well-unital distributive (non empty doubleLoopStr)
  for k being Element of NAT
  holds power(L).(-1_L,2*k) = 1_L & power(L).(-1_L,2*k+1) = -1_L
proof
  let L be add-associative right_zeroed right_complementable well-unital
  distributive(non empty doubleLoopStr), k be Element of NAT;
  defpred P[Nat] means
  power(L).(-1_L,2*$1) = 1_L & power(L).(-1_L,2*$1+1) = -1_L;
  power(L).(-1_L,2*0+1) = power(L).(-1_L,0) * (-1_L) by GROUP_1:def 8
    .= 1_L * (-1_L) by GROUP_1:def 8
    .= -1_L by VECTSP_1:def 19;
  then
A1: P[0] by GROUP_1:def 8;
A2: now
    let k be Element of NAT;
    assume
A3: P[k];
A4: power(L).(-1_L,2*(k+1)) = power(L).(-1_L,(2*k+1)+1)
      .= power(L).(-1_L,2*k+1) * (-1_L) by GROUP_1:def 8
      .= - (1_L * (-1_L)) by A3,VECTSP_1:41
      .= - (- 1_L) by VECTSP_1:def 19
      .= 1_L by RLVECT_1:30;
    power(L).(-1_L,2*(k+1)+1)
    = power(L).(-1_L,2*(k+1)) * (-1_L) by GROUP_1:def 8
      .= - (1_L) by A4,VECTSP_1:def 19;
    hence P[k+1] by A4;
  end;
  for k be Element of NAT holds P[k] from NAT_1:sch 1(A1,A2);
  hence thesis;
end;

theorem Th5:
  for z being Element of F_Complex for k being Element of NAT
  holds (power(F_Complex).(z,k))*' = power(F_Complex).(z*',k)
proof
  let z be Element of F_Complex, k be Element of NAT;
  defpred P[Nat] means ex j be Element of NAT st j = $1 &
  (power(F_Complex).(z,j))*' = power(F_Complex).(z*',j);
  (power(F_Complex).(z,0))*' = (1_F_Complex)*' by GROUP_1:def 8
    .= 1_F_Complex by Lm2,Lm3
    .= power(F_Complex).(z*',0) by GROUP_1:def 8;
  then
A1: P[0];
A2: now
    let k be Element of NAT;
    assume
A3: P[k];
    (power(F_Complex).(z,k+1))*'
    = (power(F_Complex).(z,k) * z)*' by GROUP_1:def 8
      .= (power(F_Complex).(z*',k)) * (z*') by A3,COMPLFLD:90
      .= power(F_Complex).(z*',k+1) by GROUP_1:def 8;
    hence P[k+1];
  end;
  for k be Element of NAT holds P[k] from NAT_1:sch 1(A1,A2);
  then consider j being Element of NAT such that
A4: j = k & (power(F_Complex).(z,j))*' = power(F_Complex).(z*',j);
  thus thesis by A4;
end;

theorem Th6:
  for F,G being FinSequence of F_Complex st len G = len F &
  for i being Element of NAT st i in dom G holds G/.i = (F/.i)*'
  holds Sum G = (Sum F)*'
proof
  let F,G be FinSequence of F_Complex;
  assume
A1: len G = len F &
  for i being Element of NAT st i in dom G holds G/.i = (F/.i)*';
  defpred P[Nat] means for F,G being FinSequence of F_Complex
  st len G = len F & len F = $1 &
  for i being Element of NAT st i in dom G holds G/.i = (F/.i)*'
  holds Sum G = (Sum F)*';
  now
    let F,G be FinSequence of F_Complex;
    assume
A2: len F = len G &
    len F = 0 & for i being Element of NAT st i in dom G holds G/.i=(F/.i)*';
    then F = <*>(the carrier of F_Complex) by FINSEQ_1:32;
    then Sum(F) = 0.F_Complex by RLVECT_1:60;
    then
A3: Sum(F) = (0.F_Complex)*' by Lm2,Lm3;
    G = <*>(the carrier of F_Complex) by A2,FINSEQ_1:32;
    hence Sum G = Sum(F)*' by A3,RLVECT_1:60;
  end;
  then
A4: P[0];
A5: now
    let k be Element of NAT;
    assume
A6: P[k];
    now
      let F,G be FinSequence of F_Complex;
      assume
A7:   len F = len G & len F
      = k+1 & for i being Element of NAT st i in dom G holds G/.i=(F/.i)*';
      set F1 = F|(Seg k);
      reconsider F1 as FinSequence by FINSEQ_1:19;
      reconsider F1 as FinSequence of F_Complex by A7,Lm1;
      set G1 = G|(Seg k);
      reconsider G1 as FinSequence by FINSEQ_1:19;
      reconsider G1 as FinSequence of F_Complex by A7,Lm1;
A8:   len G1 = k & len F1 = k by A7,Lm1;
A9:   F = F1^<*F/.(k+1)*> & G = G1^<*G/.(k+1)*> by A7,Lm1;
A10:  dom G = Seg len F by A7,FINSEQ_1:def 3
        .= dom F by FINSEQ_1:def 3;
A11:  dom G1 = Seg len F1 by A8,FINSEQ_1:def 3
        .= dom F1 by FINSEQ_1:def 3;
A12:  now
        let i be Element of NAT;
        assume
A13:    i in dom G1;
A14:    dom G1 c= dom G by A7,Lm1;
        then
A15:    F/.i = F.i by A10,A13,PARTFUN1:def 8
          .= F1.i by A9,A11,A13,FINSEQ_1:def 7
          .= F1/.i by A11,A13,PARTFUN1:def 8;
        thus G1/.i = G1.i by A13,PARTFUN1:def 8
          .= G.i by A9,A13,FINSEQ_1:def 7
          .= G/.i by A13,A14,PARTFUN1:def 8
          .= (F1/.i)*' by A7,A13,A14,A15;
      end;
      1 <= k + 1 by NAT_1:11;
      then
A16:  k + 1 in dom G by A7,FINSEQ_3:27;
      thus (Sum F)*' = (Sum F1 + Sum<*F/.(k+1)*>)*' by A9,RLVECT_1:58
        .= (Sum F1)*' + (Sum<*F/.(k+1)*>)*' by COMPLFLD:87
        .= Sum G1 + (Sum<*F/.(k+1)*>)*' by A6,A8,A12
        .= Sum G1 + (F/.(k+1))*' by RLVECT_1:61
        .= Sum G1 + G/.(k+1) by A7,A16
        .= Sum G1 + Sum<*G/.(k+1)*> by RLVECT_1:61
        .= Sum G by A9,RLVECT_1:58;
    end;
    hence P[k+1];
  end;
  for k be Element of NAT holds P[k] from NAT_1:sch 1(A4,A5);
  hence thesis by A1;
end;

theorem Th7:
  for L being add-associative right_zeroed right_complementable
  Abelian (non empty addLoopStr), F1,F2 being FinSequence of L
  st len F1 = len F2 &
  for i being Element of NAT st i in dom F1 holds F1/.i = -(F2/.i)
  holds Sum F1 = - Sum F2
proof
  let L be add-associative right_zeroed right_complementable Abelian
  (non empty addLoopStr), F1,F2 being FinSequence of L;
  assume
A1: len F1 = len F2 &
  (for i being Element of NAT st i in dom F1 holds F1/.i = -(F2/.i));
  defpred P[Nat] means for F1,F2 being FinSequence of L st len F1 = $1
  & len F1 = len F2 & for i being Element of NAT st i in dom F1
  holds F1/.i = -(F2/.i) holds Sum F1 = - Sum F2;
  now
    let f,g be FinSequence of L;
    assume len f = 0 & len f = len g &
    (for i being Element of NAT st i in dom f holds f/.i = -(g/.i));
    then
A2: f = <*>(the carrier of L) & g = <*>(the carrier of L) by FINSEQ_1:32;
    hence Sum f = 0.L by RLVECT_1:60
      .= - 0.L by RLVECT_1:25
      .= -(Sum g) by A2,RLVECT_1:60;
  end;
  then
A3: P[0];
A4: now
    let k be Element of NAT;
    assume
A5: P[k];
    now
      let f,g be FinSequence of L;
      assume
A6:   len f = k+1 & len f = len g &
      (for i being Element of NAT st i in dom f holds f/.i = -(g/.i));
      set f1 = f|(Seg k), g1 = g|(Seg k);
      reconsider f1, g1 as FinSequence by FINSEQ_1:19;
      reconsider f1,g1 as FinSequence of L by A6,Lm1;
A7:   len f1 = k & len g1 = k by A6,Lm1;
A8:   f = f1^<*f/.(k+1)*> by A6,Lm1;
A9:   g = g1^<*g/.(k+1)*> by A6,Lm1;
A10:  dom f1 = Seg len g1 by A7,FINSEQ_1:def 3
        .= dom g1 by FINSEQ_1:def 3;
A11:  now
        let i be Element of NAT;
        assume
A12:    i in dom f1;
A13:    dom f1 c= dom f & dom g1 c= dom g by A6,Lm1;
        then
A14:    g/.i = g.i by A10,A12,PARTFUN1:def 8
          .= g1.i by A9,A10,A12,FINSEQ_1:def 7
          .= g1/.i by A10,A12,PARTFUN1:def 8;
        thus f1/.i = f1.i by A12,PARTFUN1:def 8
          .= f.i by A8,A12,FINSEQ_1:def 7
          .= f/.i by A12,A13,PARTFUN1:def 8
          .= -(g1/.i) by A6,A12,A13,A14;
      end;
      1 <= k + 1 by NAT_1:11;
      then
A15:  k+1 in dom f by A6,FINSEQ_3:27;
      thus Sum f = Sum f1 + Sum <*f/.(k+1)*> by A8,RLVECT_1:58
        .= -(Sum g1) + Sum <*f/.(k+1)*> by A5,A7,A11
        .= -(Sum g1) + f/.(k+1) by RLVECT_1:61
        .= -(Sum g1) + -(g/.(k+1)) by A6,A15
        .= -(Sum g1 + g/.(k+1)) by RLVECT_1:45
        .= -(Sum g1 + Sum<*g/.(k+1)*>) by RLVECT_1:61
        .= -Sum g by A9,RLVECT_1:58;
    end;
    hence P[k+1];
  end;
  for k being Element of NAT holds P[k] from NAT_1:sch 1(A3,A4);
  hence thesis by A1;
end;

theorem Th8:
  for L being add-associative right_zeroed right_complementable distributive
  (non empty doubleLoopStr) for x being Element of L
  for F being FinSequence of L holds x * Sum(F) = Sum(x*F)
proof
  let L be add-associative right_zeroed right_complementable distributive
  (non empty doubleLoopStr);
  let x be Element of L;
  let F be FinSequence of L;
  defpred P[Nat] means for x being Element of L, F being FinSequence of L
  st len F = $1 holds x * Sum(F) = Sum(x*F);
  now
    let x be Element of L, F be FinSequence of L;
    assume
A1: len F = 0;
    then F = <*>the carrier of L by FINSEQ_1:32;
    then Sum(F) = 0.L by RLVECT_1:60;
    then
A2: x * Sum(F) = 0.L by VECTSP_1:36;
    Seg(len(x*F)) = dom(x*F) by FINSEQ_1:def 3
      .= dom F by POLYNOM1:def 2
      .= Seg len F by FINSEQ_1:def 3;
    then len(x*F) = 0 by A1;
    then (x*F) = <*>the carrier of L by FINSEQ_1:32;
    hence x * Sum(F) = Sum(x*F) by A2,RLVECT_1:60;
  end;
  then
A3: P[0];
A4: now
    let k be Element of NAT;
    assume
A5: P[k];
    now
      let x be Element of L;
      let F be FinSequence of L;
      assume
A6:   len F = k+1;
      set G = F|(Seg k);
      reconsider G as FinSequence by FINSEQ_1:19;
      reconsider G as FinSequence of L by A6,Lm1;
A7:   len G = k by A6,Lm1;
A8:   F = G^<*F/.(k+1)*> by A6,Lm1;
      thus x * Sum(F) = x * Sum(G^<*F/.(k+1)*>) by A6,Lm1
        .= x * (Sum G + Sum<*F/.(k+1)*>) by RLVECT_1:58
        .= x * Sum G + x * Sum<*F/.(k+1)*> by VECTSP_1:def 11
        .= Sum(x * G) + x * Sum<*F/.(k+1)*> by A5,A7
        .= Sum(x * G) + x * F/.(k+1) by RLVECT_1:61
        .= Sum(x * G) + Sum(<*x*F/.(k+1)*>) by RLVECT_1:61
        .= Sum(x * G) + Sum(x*<*F/.(k+1)*>) by POLYNOM1:21
        .= Sum((x * G)^(x*<*F/.(k+1)*>)) by RLVECT_1:58
        .= Sum(x*F) by A8,POLYNOM1:23;
    end;
    hence P[k+1];
  end;
A9: for k be Element of NAT holds P[k] from NAT_1:sch 1(A3,A4);
  consider n be Element of NAT such that
A10: len F = n;
  thus thesis by A9,A10;
end;

begin :: More about Polynomials

Lm4: for L being add-associative right_zeroed
right_complementable (non empty addLoopStr)
for p being Polynomial of L holds -(-p) = p
proof
  let L be add-associative right_zeroed right_complementable
  (non empty addLoopStr);
  let p be Polynomial of L;
A1: len p = len(-p) by POLYNOM4:11
    .= len(-(-p)) by POLYNOM4:11;
  now
    let x be Nat;
    assume x < len p;
A2: x in NAT by ORDINAL1:def 13;
    hence (-(-p)).x = -((-p)).x by BHSP_1:def 10
      .= -(-(p.x)) by A2,BHSP_1:def 10
      .= p.x by RLVECT_1:30;
  end;
  hence thesis by A1,ALGSEQ_1:28;
end;

theorem Th9:
  for L being add-associative right_zeroed right_complementable
  (non empty addLoopStr) holds -0_.(L) = 0_.(L)
proof
  let L be add-associative right_zeroed right_complementable
  (non empty addLoopStr);
  set e = 0_.(L), f = - 0_.(L);
A1: len f = len e by POLYNOM4:11;
  for x being Nat st x < len e holds e.x = f.x by POLYNOM4:6;
  hence thesis by A1,ALGSEQ_1:28;
end;

Lm5: for L being add-associative right_complementable right_zeroed
distributive (non empty doubleLoopStr), p being Polynomial of L
for f being Element of Polynom-Ring(L) holds f = p implies -f = -p
proof
  let L be add-associative right_complementable right_zeroed
  distributive (non empty doubleLoopStr), p be Polynomial of L;
  let f be Element of Polynom-Ring(L);
  assume
A1: f = p;
  reconsider x = -p as Element of Polynom-Ring(L) by POLYNOM3:def 12;
  reconsider x as Element of Polynom-Ring(L);
  f + x = p - p by A1,POLYNOM3:def 12
    .= 0_.(L) by POLYNOM3:30
    .= 0.(Polynom-Ring(L)) by POLYNOM3:def 12;
  then f = - x by RLVECT_1:19;
  hence thesis by RLVECT_1:30;
end;

theorem
  for L being add-associative right_zeroed right_complementable
  (non empty addLoopStr) for p being Polynomial of L holds -(-p) = p by Lm4;

theorem Th11:
  for L being add-associative right_zeroed right_complementable
  Abelian distributive (non empty doubleLoopStr)
  for p1,p2 being Polynomial of L holds -(p1 + p2) = (-p1) + (-p2)
proof
  let L be add-associative right_zeroed right_complementable distributive
  Abelian (non empty doubleLoopStr);
  let p1,p2 be Polynomial of L;
  reconsider p1'=p1,p2'=p2 as Element of Polynom-Ring(L) by POLYNOM3:def 12;
  p1 + p2 = p1' + p2' by POLYNOM3:def 12;
  then
A1: -(p1+p2)=-(p1'+p2') by Lm5;
A2: -p1=-p1' & -p2=-p2' by Lm5;
  -(p1'+p2') = -p1'+-p2' by RLVECT_1:45;
  hence thesis by A1,A2,POLYNOM3:def 12;
end;

theorem Th12:
  for L being add-associative right_zeroed right_complementable distributive
  Abelian (non empty doubleLoopStr) for p1,p2 being Polynomial of L
  holds -(p1 *' p2) = (-p1) *' p2 & -(p1 *' p2) = p1 *' (-p2)
proof
  let L be add-associative right_zeroed right_complementable distributive
  Abelian (non empty doubleLoopStr);
  let p1,p2 be Polynomial of L;
  reconsider p1'=p1,p2'=p2 as Element of Polynom-Ring(L) by POLYNOM3:def 12;
  p1*'p2= p1'*p2' by POLYNOM3:def 12;
  then
A1: -(p1*'p2)=-(p1'*p2') by Lm5;
  -p1 = -p1' by Lm5;
  then (-p1) *' p2 = (-p1') * p2' by POLYNOM3:def 12;
  hence -(p1 *' p2) = (-p1) *' p2 by A1,VECTSP_1:41;
  -p2 = -p2' by Lm5;
  then p1 *' (-p2) = p1' * (-p2') by POLYNOM3:def 12;
  hence thesis by A1,VECTSP_1:40;
end;

definition
  let L be add-associative right_zeroed right_complementable distributive
  (non empty doubleLoopStr);
  let F be FinSequence of Polynom-Ring(L);
  let i be Element of NAT;
  func Coeff(F,i) -> FinSequence of L means
  :Def1:
  len it = len F & for j being Element of NAT st j in dom it
  ex p being Polynomial of L st p = F.j & it.j = p.i;
  existence
  proof
    defpred P[set,set] means
    ex p being Polynomial of L st p = F.$1 & $2 = p.i;
A1: for k being Nat st k in Seg(len F)
    ex x being Element of the carrier of L st P[k,x]
    proof
      let k be Nat;
      assume k in Seg len F;
      then
A2:   k in dom F by FINSEQ_1:def 3;
      reconsider t = F/.k as Polynomial of L by POLYNOM3:def 12;
      take t.i;
      take t;
      thus t = F.k by A2,PARTFUN1:def 8; thus thesis;
    end;
    consider G being FinSequence of L such that
A3: dom G = Seg len F & for k being Nat
    st k in Seg len F holds P[k,G.k] from FINSEQ_1:sch 5(A1);
    take G;
    thus len G = len F by A3,FINSEQ_1:def 3; thus thesis by A3;
  end;
  uniqueness
  proof
    let z1,z2 be FinSequence of L;
    assume
A4: len z1 = len F & for j being Element of NAT st j in dom z1
    ex p being Polynomial of L st p = F.j & z1.j = p.i;
    assume
A5: len z2 = len F & for j being Element of NAT st j in dom z2
    ex p being Polynomial of L st p = F.j & z2.j = p.i;
A6: dom z1 = Seg len F by A4,FINSEQ_1:def 3
      .= dom z2 by A5,FINSEQ_1:def 3;
    now
      let k be Nat;
      assume
A7:   k in dom z1;
      then consider p1 being Polynomial of L such that
A8:   p1 = F.k & z1.k = p1.i by A4;
      consider p2 being Polynomial of L such that
A9:   p2 = F.k & z2.k = p2.i by A5,A6,A7;
      thus z1.k = z2.k by A8,A9;
    end;
    hence thesis by A6,FINSEQ_1:17;
  end;
end;

theorem Th13:
  for L being add-associative right_zeroed right_complementable distributive
  (non empty doubleLoopStr) for p being Polynomial of L
  for F being FinSequence of Polynom-Ring(L) st p = Sum F
  for i being Element of NAT holds p.i = Sum Coeff(F,i)
proof
  let L be add-associative right_zeroed right_complementable distributive
  (non empty doubleLoopStr), p be Polynomial of L;
  let F be FinSequence of Polynom-Ring(L);
  assume
A1: p = Sum F;
  let i be Element of NAT;
  defpred P[Nat] means for p being Polynomial of L
  for F being FinSequence of Polynom-Ring(L) st p = Sum F & len F = $1
  for i being Element of NAT holds p.i = Sum Coeff(F,i);
  now
    let p be Polynomial of L;
    let F be FinSequence of Polynom-Ring(L);
    assume
A2: p = Sum F & len F = 0;
    let i be Element of NAT;
    F = <*>(the carrier of Polynom-Ring(L)) by A2,FINSEQ_1:32;
    then Sum F = 0.(Polynom-Ring(L)) by RLVECT_1:60;
    then p = 0_.(L) by A2,POLYNOM3:def 12;
    then
A3: p.i = 0.L by FUNCOP_1:13;
    len Coeff(F,i) = 0 by A2,Def1;
    then Coeff(F,i) = <*>(the carrier of L) by FINSEQ_1:32;
    hence p.i = Sum Coeff(F,i) by A3,RLVECT_1:60;
  end;
  then
A4: P[0];
A5: now
    let k be Element of NAT;
    assume
A6: P[k];
    now
      let p be Polynomial of L;
      let F be FinSequence of Polynom-Ring(L);
      assume
A7:   p = Sum F & len F = k+1;
      let i be Element of NAT;
      set G = F|(Seg k);
      reconsider G as FinSequence by FINSEQ_1:19;
      reconsider G as FinSequence of Polynom-Ring(L) by A7,Lm1;
      reconsider pg = Sum G as Polynomial of L by POLYNOM3:def 12;
      reconsider rf = F/.(k+1) as Polynomial of L by POLYNOM3:def 12;
A8:   len G = k by A7,Lm1;
A9:   k <= len F by A7,NAT_1:13;
A10:  F = G^<*F/.(k+1)*> by A7,Lm1;
      len(Coeff(G,i)^<*rf.i*>) = len Coeff(G,i) + len <*rf.i*> by FINSEQ_1:35
        .= len Coeff(G,i) + 1 by FINSEQ_1:56
        .= k + 1 by A8,Def1
        .= len Coeff(F,i) by A7,Def1;
      then
A11:  dom Coeff(F,i) = Seg(len(Coeff(G,i)^<*rf.i*>)) by FINSEQ_1:def 3
        .= dom(Coeff(G,i)^<*rf.i*>) by FINSEQ_1:def 3;
      now
        let j be Nat;
        assume
A12:    j in dom Coeff(F,i);
A13:    dom Coeff(G,i) = Seg(len(Coeff(G,i))) by FINSEQ_1:def 3
          .= Seg len G by Def1
          .= dom G by FINSEQ_1:def 3;
        per cases;
        suppose
A14:      j in dom Coeff(G,i);
          then
A15:      (Coeff(G,i)^<*rf.i*>).j = Coeff(G,i).j by FINSEQ_1:def 7;
          consider p1 being Polynomial of L such that
A16:      p1 = G.j & Coeff(G,i).j = p1.i by A14,Def1;
          consider p being Polynomial of L such that
A17:      p = F.j & Coeff(F,i).j = p.i by A12,Def1;
          thus Coeff(F,i).j = (Coeff(G,i)^<*rf.i*>).j
          by A13,A14,A15,A16,A17,FUNCT_1:70;
        end;
        suppose
A18:      not j in dom Coeff(G,i);
A19:      j = k + 1
          proof
            dom Coeff(F,i) = Seg(len Coeff(F,i)) by FINSEQ_1:def 3
              .= Seg len F by Def1;
            then
A20:        1 <= j & j <= k + 1 by A7,A12,FINSEQ_1:3;
            now
              assume j < k + 1;
              then j <= k by NAT_1:13;
              then j in Seg k by A12,A20;
              hence contradiction by A9,A13,A18,FINSEQ_1:21;
            end;
            hence thesis by A20,XXREAL_0:1;
          end;
A21:      len Coeff(G,i) = k by A8,Def1;
          dom <*rf.i*> = {1} by FINSEQ_1:4,55;
          then 1 in dom <*rf.i*> by TARSKI:def 1;
          then
A22:      (Coeff(G,i)^<*rf.i*>).j = <*rf.i*>.1 by A19,A21,FINSEQ_1:def 7
            .= rf.i by FINSEQ_1:57;
          consider p being Polynomial of L such that
A23:      p = F.j & Coeff(F,i).j = p.i by A12,Def1;
          1 <= k + 1 by NAT_1:11;
          then k + 1 in dom F by A7,FINSEQ_3:27;
          hence Coeff(F,i).j = (Coeff(G,i)^<*rf.i*>).j
          by A19,A22,A23,PARTFUN1:def 8;
        end;
      end;
      then
A24:  Coeff(F,i) = Coeff(G,i)^<*rf.i*> by A11,FINSEQ_1:17;
      Sum F = Sum G + Sum <*F/.(k+1)*> by A10,RLVECT_1:58
        .= Sum G + F/.(k+1) by RLVECT_1:61
        .= pg + rf by POLYNOM3:def 12;
      hence p.i = pg.i + rf.i by A7,NORMSP_1:def 5
        .= Sum Coeff(G,i) + rf.i by A6,A8
        .= Sum Coeff(G,i) + Sum <*rf.i*> by RLVECT_1:61
        .= Sum Coeff(F,i) by A24,RLVECT_1:58;
    end;
    hence P[k+1];
  end;
A25: for k being Element of NAT holds P[k] from NAT_1:sch 1(A4,A5);
  consider m being Nat such that
A26: len F = m;
  thus thesis by A1,A25,A26;
end;

Lm6: for L being add-associative right_zeroed right_complementable distributive
Abelian (non empty doubleLoopStr) for p1,p2 being Polynomial of L
for p2' being Element of Polynom-Ring(L) st p2' = p2
for F being FinSequence of Polynom-Ring(L) st p1 = Sum F
holds p2 *' p1 = Sum(p2'*F)
proof
  let L be add-associative right_zeroed right_complementable distributive
  Abelian (non empty doubleLoopStr), p1,p2 be Polynomial of L;
  let p2' be Element of Polynom-Ring(L);
  assume
A1: p2' = p2;
  let F be FinSequence of Polynom-Ring(L);
  assume
A2: p1 = Sum F;
  reconsider p1' = p1 as Element of Polynom-Ring(L) by POLYNOM3:def 12;
  p2' * p1' = Sum(p2'*F) by A2,Th8;
  hence thesis by A1,POLYNOM3:def 12;
end;

theorem Th14:
  for L being associative (non empty doubleLoopStr)
  for p being Polynomial of L
  for x1, x2 being Element of L holds x1 * (x2 * p) = (x1 * x2) * p
proof
  let L be associative (non empty doubleLoopStr), p being Polynomial of L;
  let x1, x2 be Element of L;
  set f = x1 * (x2 * p), g = (x1 * x2) * p;
A1: dom f = NAT by FUNCT_2:def 1
    .= dom g by FUNCT_2:def 1;
  now
    let i' be set;
    assume i' in dom f;
    then reconsider i = i' as Element of NAT;
    f.i = x1*(x2*p).i by POLYNOM5:def 3
      .= x1*(x2*p.i) by POLYNOM5:def 3
      .= (x1*x2)*p.i by GROUP_1:def 4
      .= g.i by POLYNOM5:def 3;
    hence f.i' = g.i';
  end;
  hence thesis by A1,FUNCT_1:9;
end;

theorem Th15:
  for L being add-associative right_zeroed right_complementable
  left-distributive (non empty doubleLoopStr) for p being Polynomial of L
  for x being Element of L holds - (x * p) = (-x) * p
proof
  let L be add-associative right_zeroed right_complementable
  left-distributive (non empty doubleLoopStr), p be Polynomial of L;
  let x be Element of L;
  set f = - (x * p), g = (-x) * p;
A1: dom f = NAT by FUNCT_2:def 1
    .= dom g by FUNCT_2:def 1;
  now
    let i' be set;
    assume i' in dom f;
    then reconsider i = i' as Element of NAT;
    f.i = -((x*p).i) by BHSP_1:def 10
      .= -(x*p.i) by POLYNOM5:def 3
      .= (-x)*p.i by VECTSP_1:41
      .= g.i by POLYNOM5:def 3;
    hence f.i' = g.i';
  end;
  hence thesis by A1,FUNCT_1:9;
end;

theorem Th16:
  for L being add-associative right_zeroed right_complementable
  right-distributive (non empty doubleLoopStr) for p being Polynomial of L
  for x being Element of L holds - (x * p) = x * (-p)
proof
  let L be add-associative right_zeroed right_complementable
  right-distributive (non empty doubleLoopStr), p be Polynomial of L;
  let x be Element of L;
  set f = - (x * p), g = x * (-p);
A1: dom f = NAT by FUNCT_2:def 1
    .= dom g by FUNCT_2:def 1;
  now
    let i' be set;
    assume i' in dom f;
    then reconsider i = i' as Element of NAT;
    f.i = -((x*p).i) by BHSP_1:def 10
      .= -(x*p.i) by POLYNOM5:def 3
      .= x*(-p.i) by VECTSP_1:40
      .= x*((-p).i) by BHSP_1:def 10
      .= g.i by POLYNOM5:def 3;
    hence f.i' = g.i';
  end;
  hence thesis by A1,FUNCT_1:9;
end;

theorem Th17:
  for L being left-distributive (non empty doubleLoopStr)
  for p being Polynomial of L
  for x1, x2 being Element of L holds (x1 + x2) * p = x1 * p + x2 * p
proof
  let L be left-distributive (non empty doubleLoopStr), p be Polynomial of L;
  let x1,x2 be Element of L;
  set f = (x1 + x2) * p, g = x1 * p + x2 * p;
A1: dom f = NAT by FUNCT_2:def 1
    .= dom g by FUNCT_2:def 1;
  now
    let i' be set;
    assume i' in dom f;
    then reconsider i = i' as Element of NAT;
    f.i = (x1+x2)*p.i by POLYNOM5:def 3
      .= x1*p.i+x2*p.i by VECTSP_1:def 12
      .= (x1*p).i+x2*p.i by POLYNOM5:def 3
      .= (x1*p).i+(x2*p).i by POLYNOM5:def 3
      .= g.i by NORMSP_1:def 5;
    hence f.i' = g.i';
  end;
  hence thesis by A1,FUNCT_1:9;
end;

theorem Th18:
  for L being right-distributive (non empty doubleLoopStr)
  for p1, p2 being Polynomial of L
  for x being Element of L holds x * (p1 + p2) = (x * p1) + (x * p2)
proof
  let L be right-distributive (non empty doubleLoopStr),
  p1,p2 be Polynomial of L;
  let x be Element of L;
  set f = x * (p1 + p2), g = (x * p1) + (x * p2);
A1: dom f = NAT by FUNCT_2:def 1
    .= dom g by FUNCT_2:def 1;
  now
    let i' be set;
    assume i' in dom f;
    then reconsider i = i' as Element of NAT;
    f.i = x*(p1+p2).i by POLYNOM5:def 3
      .= x*(p1.i+p2.i) by NORMSP_1:def 5
      .= x*p1.i+x*p2.i by VECTSP_1:def 11
      .= (x*p1).i+x*p2.i by POLYNOM5:def 3
      .= (x*p1).i+(x*p2).i by POLYNOM5:def 3
      .= g.i by NORMSP_1:def 5;
    hence f.i' = g.i';
  end;
  hence thesis by A1,FUNCT_1:9;
end;

theorem Th19:
  for L being add-associative right_zeroed right_complementable distributive
  commutative associative (non empty doubleLoopStr)
  for p1,p2 being Polynomial of L
  for x being Element of L holds p1 *' (x * p2) = x * (p1 *' p2)
proof
  let L be add-associative right_zeroed right_complementable distributive
  commutative associative (non empty doubleLoopStr), p1,p2 be Polynomial of L;
  let x be Element of L;
  set f = p1 *' (x * p2), g = x * (p1 *' p2);
A1: dom f = NAT by FUNCT_2:def 1
    .= dom g by FUNCT_2:def 1;
  now
    let i' be set;
    assume i' in dom f;
    then reconsider i = i' as Element of NAT;
    consider rf being FinSequence of L such that
A2: len rf = i+1 & f.i = Sum rf & for k be Element of NAT st k in dom rf
    holds rf.k = p1.(k-'1) * (x*p2).(i+1-'k) by POLYNOM3:def 11;
    consider rp being FinSequence of L such that
A3: len
    rp = i+1 & (p1*'p2).i = Sum rp & for k be Element of NAT st k in dom rp
    holds rp.k = p1.(k-'1) * p2.(i+1-'k) by POLYNOM3:def 11;
A4: Seg(len(x*rp)) = dom(x*rp) by FINSEQ_1:def 3
      .= dom rp by POLYNOM1:def 2
      .= Seg len rp by FINSEQ_1:def 3;
    then
A5: len(x*rp) = len rf by A2,A3,FINSEQ_1:8;
A6: dom(x*rp) = Seg len rf by A2,A3,A4,FINSEQ_1:def 3
      .= dom rf by FINSEQ_1:def 3;
A7: dom(x*rp) = dom rp by POLYNOM1:def 2;
A8: now
      let j be Nat;
      assume 1 <= j & j <= len rf;
      then
A9:   j in dom rf by FINSEQ_3:27;
      then
A10:  rp/.j = rp.j by A6,A7,PARTFUN1:def 8;
      thus (x*rp).j = (x*rp)/.j by A6,A9,PARTFUN1:def 8
        .= x * (rp/.j) by A6,A7,A9,POLYNOM1:def 2
        .= x * (p1.(j-'1) * p2.(i+1-'j)) by A3,A6,A7,A9,A10
        .= p1.(j-'1) * (x * p2.(i+1-'j)) by GROUP_1:def 4
        .= p1.(j-'1) * (x*p2).(i+1-'j) by POLYNOM5:def 3
        .= rf.j by A2,A9;
    end;
    g.i = x * Sum rp by A3,POLYNOM5:def 3
      .= Sum(x * rp) by Th8
      .= f.i by A2,A5,A8,FINSEQ_1:18;
    hence f.i' = g.i';
  end;
  hence thesis by A1,FUNCT_1:9;
end;

definition
  let L be non empty ZeroStr;
  let p be Polynomial of L;
  func degree p -> Integer equals

  len p - 1;
  coherence;
end;

notation
  let L be non empty ZeroStr;
  let p be Polynomial of L;
  synonym deg p for degree p;
end;

Lm7: for L being non empty ZeroStr, s being AlgSequence of L
holds len(s) > 0 implies s.(len(s)-1) <> 0.L
proof
  let L be non empty ZeroStr, s be AlgSequence of L;
  assume len(s) > 0;
  then len(s) >= 0 + 1 by NAT_1:13;
  then len(s) - 1 >= 1 - 1 by XREAL_1:11;
  then reconsider l = len(s) - 1 as Element of NAT by INT_1:16;
  assume
A1: s.(len(s)-1) = 0.L;
  now
    let i be Nat;
    assume
A2: i >= l;
    per cases by A2,XXREAL_0:1;
    suppose i = l;
      hence s.i = 0.L by A1;
    end;
    suppose i > l;
      then i >= l + 1 by NAT_1:13;
      hence s.i = 0.L by ALGSEQ_1:22;
    end;
  end;
  then
A3: l is_at_least_length_of s by ALGSEQ_1:def 3;
  len(s) < len(s) + 1 by NAT_1:13;
  then len(s) - 1 < len(s) + 1 - 1 by XREAL_1:11;
  hence contradiction by A3,ALGSEQ_1:def 4;
end;

theorem Th20:
  for L being non empty ZeroStr
  for p being Polynomial of L holds deg p = -1 iff p = 0_.(L)
proof
  let L be non empty ZeroStr;
  let p be Polynomial of L;
  now
    assume p = 0_.(L);
    then len p = 0 by POLYNOM4:6;
    hence deg p = -1;
  end;
  hence thesis by POLYNOM4:8;
end;

Lm8: for L being non empty ZeroStr, p being Polynomial of L
holds deg p <> - 1 implies p.deg(p) <> 0.L
proof
  let L be non empty ZeroStr, p be Polynomial of L;
  assume deg p <> -1;
  then len p <> 0;
  then len p > 0;
  hence thesis by Lm7;
end;

Lm9: for L being non empty ZeroStr for p being Polynomial of L
holds deg p is Element of NAT iff p <> 0_.(L)
proof
  let L be non empty ZeroStr;
  let p be Polynomial of L;
  now
    assume p <> 0_.(L);
    then len p <> 0 by POLYNOM4:8;
    then len p > 0;
    then len p + 1 > 0 + 1 by XREAL_1:8;
    then len p >= 1 by NAT_1:13;
    then len p - 1 >= 1 - 1 by XREAL_1:11;
    hence deg(p) is Element of NAT by INT_1:16;
  end;
  hence thesis by Th20;
end;

theorem
  for L being add-associative right_zeroed right_complementable
  (non empty addLoopStr) for p1,p2 being Polynomial of L st deg p1 <> deg p2
  holds deg(p1 + p2) = max(deg(p1),deg(p2))
proof
  let L be add-associative right_zeroed right_complementable
  (non empty addLoopStr);
  let p1,p2 be Polynomial of L;
  assume deg p1 <> deg p2;
  then
A1: deg(p1+p2) = max(len(p1),len(p2)) - 1 by POLYNOM4:10;
  per cases by XXREAL_0:16;
  suppose
A2: max(len(p1),len(p2)) = len(p1);
    then len p2 <= len p1 by XXREAL_0:25;
    then deg p2 <= deg p1 by XREAL_1:11;
    hence thesis by A1,A2,XXREAL_0:def 10;
  end;
  suppose
A3: max(len(p1),len(p2)) = len(p2);
    then len p1 <= len p2 by XXREAL_0:25;
    then deg p1 <= deg p2 by XREAL_1:11;
    hence thesis by A1,A3,XXREAL_0:def 10;
  end;
end;

Lm10: for L being non empty ZeroStr, p being Polynomial of L holds deg p >= -1
proof
  let L be non empty ZeroStr, p be Polynomial of L;
  per cases;
  suppose p = 0_.(L);
    hence thesis by Th20;
  end;
  suppose p <> 0_.(L);
    hence thesis by Lm9;
  end;
end;

theorem Th22:
  for L being add-associative right_zeroed right_complementable
  Abelian (non empty addLoopStr)
  for p1,p2 being Polynomial of L holds deg(p1 + p2) <= max(deg(p1),deg(p2))
proof
  let L be add-associative right_zeroed right_complementable
  Abelian (non empty addLoopStr);
  let p1,p2 be Polynomial of L;
  per cases;
  suppose
A1: p1 = 0_.(L);
    then deg(p1) = -1 by Th20;
    then
A2: deg(p2) >= deg(p1) by Lm10;
    deg(p1 + p2) = deg(p2) by A1,POLYNOM3:29
      .= max(deg(p1),deg(p2)) by A2,XXREAL_0:def 10;
    hence thesis;
  end;
  suppose
A3: p2 = 0_.(L);
    then deg(p2) = -1 by Th20;
    then
A4: deg(p1) >= deg(p2) by Lm10;
    deg(p1 + p2) = deg(p1) by A3,POLYNOM3:29
      .= max(deg(p1),deg(p2)) by A4,XXREAL_0:def 10;
    hence thesis;
  end;
  suppose p1 <> 0_.(L) & p2 <> 0_.(L);
    then deg(p1) is Element of NAT & deg(p2) is Element of NAT by Lm9;
    then reconsider m = max(deg(p1),deg(p2)) as Element of NAT by XXREAL_0:16;
    for k being Nat st k >= m+1 holds (p1+p2).k = 0.L
    proof
      let k be Nat;
      assume
A5:   k >= m + 1;
A6:   k in NAT by ORDINAL1:def 13;
      deg(p1) <= m & deg(p2) <= m by XXREAL_0:25;
      then deg(p1) + 1 <= m + 1 & deg(p2) + 1 <= m + 1 by XREAL_1:8;
      then p1.k = 0.L & p2.k = 0.L by A5,ALGSEQ_1:22,XXREAL_0:2;
      hence (p1+p2).k = 0.L + 0.L by A6,NORMSP_1:def 5
        .= 0.L by RLVECT_1:def 7;
    end;
    then m+1 is_at_least_length_of (p1+p2) by ALGSEQ_1:def 3;
    then len(p1+p2)<=m+1 by ALGSEQ_1:def 4;
    then len(p1+p2)-1<=m+1-1 by XREAL_1:11;
    hence thesis;
  end;
end;

theorem Th23:
  for L being add-associative right_zeroed right_complementable distributive
  commutative associative well-unital domRing-like (non empty doubleLoopStr)
  for p1,p2 being Polynomial of L st p1 <> 0_.(L) & p2 <> 0_.(L)
  holds deg(p1 *' p2) = deg(p1) + deg(p2)
proof
  let L be add-associative right_zeroed right_complementable distributive
  commutative associative well-unital domRing-like (non empty doubleLoopStr);
  let p1,p2 be Polynomial of L;
  assume
A1: p1 <> 0_.(L) & p2 <> 0_.(L);
A2: dom p1 = NAT & dom p2 = NAT by FUNCT_2:def 1;
  deg p1 is Element of NAT & deg p2 is Element of NAT by A1,Lm9;
  then
A3: p1/.(deg(p1)) = p1.(deg(p1)) & p2/.(deg(p2)) = p2.(deg(p2))
  by A2,PARTFUN1:def 8;
  len p1 <> 0 & len p2 <> 0 by A1,POLYNOM4:8;
  then len p1 > 0 & len p2 > 0;
  then len p1 + 1 > 0 + 1 & len p2 + 1 > 0 + 1 by XREAL_1:8;
  then len p1 >= 1 & len p2 >= 1 by NAT_1:13;
  then len p1 - 1 >= 1 - 1 & len p2 - 1 >= 1 - 1 by XREAL_1:11;
  then
A4: p1/.(deg(p1)) = p1.(len p1-'1) &
  p2/.(deg(p2)) = p2.(len p2-'1) by A3,XREAL_0:def 2;
  deg p1 <> -1 & deg p2 <> -1 by A1,Th20;
  then p1/.(deg(p1)) <> 0.L & p2/.(deg(p2)) <> 0.L by A3,Lm8;
  then p1.(len p1 -'1) * p2.(len p2 -'1) <> 0.L by A4,VECTSP_2:def 5;
  hence deg(p1*'p2) = (len p1 + len p2 - 1)-1 by POLYNOM4:13
    .= deg p1 + deg p2;
end;

theorem Th24:
  for L being add-associative right_zeroed right_complementable unital
  (non empty doubleLoopStr)
  for p being Polynomial of L st deg p = 0 holds not(p is with_roots)
proof
  let L be add-associative right_zeroed right_complementable unital
  (non empty doubleLoopStr), p be Polynomial of L;
  assume
A1: deg p = 0;
  then
A2: p = <%p.0%> by ALGSEQ_1:def 6;
  now
    assume p is with_roots;
    then consider x be Element of L such that
A3: x is_a_root_of p by POLYNOM5:def 7;
    0.L = eval(p,x) by A3,POLYNOM5:def 6
      .= p.0 by A2,POLYNOM5:38;
    hence contradiction by A1,A2,ALGSEQ_1:31;
  end;
  hence thesis;
end;

Lm11: for L being unital (non empty doubleLoopStr)
for z be Element of L, k be Element of NAT st k <> 0
holds (0_.(L) +* (0,k)-->(-power(L).(z,k),1_L)).0 = -power(L).(z,k) &
(0_.(L) +* (0,k)-->(-power(L).(z,k),1_L)).k = 1_L
proof
  let L be unital (non empty doubleLoopStr);
  let z be Element of L;
  let k be Element of NAT;
  assume
A1: k <> 0;
  set t = 0_.(L) +* (0,k)-->(-power(L).(z,k),1_L),
  f = (0,k)-->(-power(L).(z,k),1_L), a = -power(L).(z,k);
A2: dom f = {0,k} by FUNCT_4:65;
A3: dom(0_.(L)) = NAT by FUNCT_2:def 1;
  now
    let u be set;
    assume u in {0,k};
    then u = 0 or u = k by TARSKI:def 2;
    hence u in NAT;
  end;
  then {0,k} c= NAT by TARSKI:def 3;
  then
A4: dom(0_.(L)) \/ dom(f) = NAT by A2,A3,XBOOLE_1:12;
  0 in dom f by A2,TARSKI:def 2;
  hence t.0 = f.0 by A4,FUNCT_4:def 1
    .= a by A1,FUNCT_4:66;
  k in dom f by A2,TARSKI:def 2;
  hence t.k = f.k by A4,FUNCT_4:def 1
    .= 1_L by FUNCT_4:66;
end;

Lm12: for L being unital (non empty doubleLoopStr)
for z being Element of L, k be Element of NAT,i being Nat st i <> 0 & i <> k
holds (0_.(L) +* (0,k)-->(-power(L).(z,k),1_L)).i = 0.L
proof
  let L be unital (non empty doubleLoopStr);
  let z be Element of L, k be Element of NAT,i be Nat;
  assume
A1: i <> 0 & i <> k;
  set t = 0_.(L) +* (0,k)-->(-power(L).(z,k),1_L),
  f = (0,k)-->(-power(L).(z,k),1_L);
A2: dom f = {0,k} by FUNCT_4:65;
A3: dom(0_.(L)) = NAT by FUNCT_2:def 1;
  now
    let u be set;
    assume u in {0,k};
    then u = 0 or u = k by TARSKI:def 2;
    hence u in NAT;
  end;
  then {0,k} c= NAT by TARSKI:def 3;
  then
A4: dom(0_.(L)) \/ dom(f) = NAT by A2,A3,XBOOLE_1:12;
A5: i in NAT by ORDINAL1:def 13;
  not(i in dom f) by A1,TARSKI:def 2;
  hence t.i = (0_.(L)).i by A4,A5,FUNCT_4:def 1
    .= 0.L by A5,FUNCOP_1:13;
end;

:: the polynomials x^k - z^k

definition
  let L be unital (non empty doubleLoopStr);
  let z be Element of L;
  let k be Element of NAT;
  func rpoly(k,z) -> Polynomial of L equals
  0_.(L) +* (0,k)-->(-power(L).(z,k),1_L);
  coherence
  proof
    set f = (0,k)-->(-power(L).(z,k),1_L);
    set p = 0_.(L) +* (0,k)-->(-power(L).(z,k),1_L);
    set a = -power(L).(z,k);
A1: k in {k} by TARSKI:def 1;
    then
A2: k in dom({k} --> 1_L) by FUNCOP_1:19;
A3: dom f = {0,k} by FUNCT_4:65;
A4: dom(0_.(L)) = NAT by FUNCT_2:def 1;
    now
      let u be set;
      assume u in {0,k};
      then u = 0 or u = k by TARSKI:def 2;
      hence u in NAT;
    end;
    then {0,k} c= NAT by TARSKI:def 3;
    then dom(0_.(L)) \/ dom(f) = NAT by A3,A4,XBOOLE_1:12;
    then
A5: dom p = NAT by FUNCT_4:def 1;
    now
      let x' be set;
      assume x' in NAT;
      then reconsider x = x' as Element of NAT;
      per cases;
      suppose
A6:     k = 0 & x = 0;
        then x in dom f by A3,TARSKI:def 2;
        then p.x = f.x by FUNCT_4:14
          .= ((0 .--> a) +* (k .--> 1_L)).x by FUNCT_4:def 4
          .= (k .--> 1_L).x by A2,A6,FUNCT_4:14
          .= 1_L by A1,A6,FUNCOP_1:13;
        hence p.x' in the carrier of L;
      end;
      suppose x = 0 & k <> 0;
        then p.x = -power(L).(z,k) by Lm11;
        hence p.x' in the carrier of L;
      end;
      suppose x = k & k <> 0;
        then p.x = 1_L by Lm11;
        hence p.x' in the carrier of L;
      end;
      suppose x <> 0 & x <> k;
        then p.x = 0.L by Lm12;
        hence p.x' in the carrier of L;
      end;
    end;
    then reconsider p as Function of NAT,the carrier of L by A5,FUNCT_2:5;
    reconsider p as sequence of L;
    now
      let i be Nat;
      assume i >= k + 1;
      then i <> 0 & i <> k by NAT_1:13;
      hence p.i = 0.L by Lm12;
    end;
    then reconsider p as AlgSequence of L by ALGSEQ_1:def 2;
    p is Polynomial of L;
    hence thesis;
  end;
end;

theorem
  for L being unital (non empty doubleLoopStr) for z being Element of L
  for k being Element of NAT st k <> 0
  holds rpoly(k,z).0 = -power(L).(z,k) & rpoly(k,z).k = 1_L by Lm11;

theorem
  for L being unital (non empty doubleLoopStr) for z being Element of L
  for i,k being Element of NAT st i <> 0 & i <> k holds
  rpoly(k,z).i = 0.L by Lm12;

theorem Th27:
  for L being well-unital non degenerated (non empty doubleLoopStr)
  for z being Element of L for k being Element of NAT holds deg rpoly(k,z) = k
proof
  let L be well-unital non degenerated (non empty doubleLoopStr);
  let z be Element of L;
  let k be Element of NAT;
  set t = rpoly(k,z);
  set f = (0,k)-->(-power(L).(z,k),1_L);
  set a = -power(L).(z,k);
  per cases;
  suppose
A1: k = 0;
    now
      let i be Nat;
A2:   i in NAT by ORDINAL1:def 13;
      assume i >= 1;
      then not(i in dom f) by A1,TARSKI:def 2;
      hence t.i = (0_.(L)).i by FUNCT_4:12
        .= 0.L by A2,FUNCOP_1:13;
    end;
    then
A3: 1 is_at_least_length_of t by ALGSEQ_1:def 3;
    now
      let m be Nat;
      assume
A4:   m is_at_least_length_of t;
      now
        assume m < 1;
        then
A5:     m = 0 by NAT_1:14;
A6:     k in {k} by TARSKI:def 1;
        then
A7:     k in dom({k}-->1_L) by FUNCOP_1:19;
        dom f = {0,k} by FUNCT_4:65;
        then 0 in dom f by TARSKI:def 2;
        then t.0 = f.0 by FUNCT_4:14
          .= ((0 .-->a)+*(k.-->1_L)).0 by FUNCT_4:def 4
          .= (0 .--> 1_L).0 by A1,A7,FUNCT_4:14
          .= 1_L by A1,A6,FUNCOP_1:13;
        hence contradiction by A4,A5,ALGSEQ_1:def 3;
      end;
      hence 1 <= m;
    end;
    then len rpoly(k,z) = 1 by A3,ALGSEQ_1:def 4;
    hence thesis by A1;
  end;
  suppose
A8: k <> 0;
    now
      let i be Nat;
      assume i >= k+1;
      then i > k by NAT_1:13;
      hence t.i = 0.L by Lm12;
    end;
    then
A9: (k+1) is_at_least_length_of t by ALGSEQ_1:def 3;
    now
      let m be Nat;
      assume
A10:  m is_at_least_length_of t;
      now
        assume m < k + 1;
        then
A11:    m <= k by NAT_1:13;
        t.k = 1_L by A8,Lm11;
        hence contradiction by A10,A11,ALGSEQ_1:def 3;
      end;
      hence k+1 <= m;
    end;
    then len rpoly(k,z) = k + 1 by A9,ALGSEQ_1:def 4;
    hence thesis;
  end;
end;

theorem Th28:
  for L being add-associative right_zeroed right_complementable well-unital
  commutative associative distributive almost_left_invertible
  non degenerated (non empty doubleLoopStr) for p being Polynomial of L
  holds deg(p) = 1 iff ex x,z being Element of L st
  x <> 0.L & p = x * rpoly(1,z)
proof
  let L be add-associative right_zeroed right_complementable well-unital
  commutative associative distributive almost_left_invertible non degenerated
  (non empty doubleLoopStr), p be Polynomial of L;
A1: now
    given x,z being Element of L such that
A2: x <> 0.L & p = x * rpoly(1,z);
    thus deg p = deg rpoly(1,z) by A2,POLYNOM5:26
      .= 1 by Th27;
  end;
  now
    assume
A3: deg(p) = 1;
    then
A4: len p = 1 + 1;
    set x = p.1, z = (-p.0)*(p.1)";
    set f = x * rpoly(1,z);
A5: x <> 0.L by A4,ALGSEQ_1:25;
A6: len f = deg(rpoly(1,z)) + 1 by A4,ALGSEQ_1:25,POLYNOM5:26
      .= 1+1 by Th27
      .= len p by A3;
    now
      let k be Nat;
      assume k < len p;
      then k < 1+1 by A3;
      then
A7:   k <= 1 by NAT_1:13;
      per cases by A7,XXREAL_0:1;
      suppose
A8:     k = 1;
        hence f.k = x * rpoly(1,z).1 by POLYNOM5:def 3
          .= x * 1_L by Lm11
          .= p.k by A8,VECTSP_1:def 13;
      end;
      suppose k < 1;
        then
A9:     k = 0 by NAT_1:14;
        hence f.k = x * rpoly(1,z).0 by POLYNOM5:def 3
          .= x * (-(power(L).(z,1+0))) by Lm11
          .= x * (-(power(L).(z,0) * z)) by GROUP_1:def 8
          .= x * (-(1_L * z)) by GROUP_1:def 8
          .= x * (- z) by VECTSP_1:def 19
          .= p.1 * (-(-(p.0*(p.1)"))) by VECTSP_1:41
          .= p.1 * (p.0*(p.1)") by RLVECT_1:30
          .= (p.1 * (p.1)") * p.0 by GROUP_1:def 4
          .= 1_L * p.0 by A5,VECTSP_1:def 22
          .= p.k by A9,VECTSP_1:def 19;
      end;
    end;
    then p = f by A6,ALGSEQ_1:28;
    hence ex x,z being Element of L st x <> 0.L & p = x * rpoly(1,z) by A4,
    ALGSEQ_1:25;
  end;
  hence thesis by A1;
end;

theorem Th29:
  for L being add-associative right_zeroed right_complementable
  Abelian well-unital non degenerated (non empty doubleLoopStr)
  for x,z being Element of L holds eval(rpoly(1,z),x) = x - z
proof
  let L be add-associative right_zeroed right_complementable
  Abelian well-unital non degenerated (non empty doubleLoopStr),
  x,z be Element of L;
  set p = rpoly(1,z);
  consider F be FinSequence of L such that
A1: eval(p,x) = Sum F & len F = len p & for n be Element of NAT st n in dom F
  holds F.n = p.(n-'1) * (power L).(x,n-'1) by POLYNOM4:def 2;
A2: deg p = 1 by Th27;
  then
A3: F = <*F.1,F.2*> by A1,FINSEQ_1:61
    .= <*F.1*>^<*F.2*>;
A4: 1-'1 = 1-1 by XREAL_0:def 2;
  1 in Seg len F by A1,A2,FINSEQ_1:4;
  then 1 in dom F by FINSEQ_1:def 3;
  then
A5: F.1 = p.0* (power L).(x,1-'1) by A1,A4
    .= p.0 * 1_L by A4,GROUP_1:def 8
    .= p.0 by VECTSP_1:def 13
    .= -power(L).(z,1+0) by Lm11
    .= -(power(L).(z,0) * z) by GROUP_1:def 8
    .= -(1_L * z) by GROUP_1:def 8
    .= -z by VECTSP_1:def 19;
A6: 2-'1 = 2-1 by XREAL_0:def 2;
  2 in Seg(len F) by A1,A2;
  then 2 in dom F by FINSEQ_1:def 3;
  then F.2 = p.1* (power L).(x,1+0) by A1,A6
    .= p.1* ((power L).(x,0) * x) by GROUP_1:def 8
    .= p.1* (1_L * x) by GROUP_1:def 8
    .= p.1* x by VECTSP_1:def 19
    .= 1_L * x by Lm11
    .= x by VECTSP_1:def 19;
  hence eval(p,x) = Sum(<*-z*>) + Sum(<*x*>) by A1,A3,A5,RLVECT_1:58
    .= Sum(<*-z*>) + x by RLVECT_1:61
    .= -z + x by RLVECT_1:61
    .= x - z by RLVECT_1:def 12;
end;

theorem Th30:
  for L being add-associative right_zeroed right_complementable
  well-unital Abelian non degenerated (non empty doubleLoopStr)
  for z being Element of L holds z is_a_root_of rpoly(1,z)
proof
  let L be Abelian well-unital add-associative right_zeroed non degenerated
  right_complementable (non empty doubleLoopStr), z be Element of L;
  eval(rpoly(1,z),z) = z - z by Th29
    .= 0.L by RLVECT_1:28;
  hence thesis by POLYNOM5:def 6;
end;

:: the polynomials x^(k-1) + x^(k-2)*z + x^(k-3)*z^2 + ... + x*z^(k-2) + z^(k-1)

definition
  let L be well-unital (non empty doubleLoopStr);
  let z be Element of L;
  let k be Nat;
  func qpoly(k,z) -> Polynomial of L means
  :Def4:
  (for i being Nat st i < k holds it.i = power(L).(z,k-i-1)) &
  (for i being Nat st i >= k holds it.i = 0.L);
  existence
  proof
    defpred P[set,set] means ex n being Element of NAT st n = $1 &
    (n < k implies $2 = power(L).(z,k-n-1)) & (n >= k implies $2 = 0.L);
A1: for x being set st x in NAT
    ex y being set st y in the carrier of L & P[x,y]
    proof
      let u be set;
      assume u in NAT;
      then reconsider u' = u as Element of NAT;
      thus ex y being set st y in the carrier of L & P[u,y]
      proof
        per cases;
        suppose
A2:       u' < k;
          take y = power(L).(z,k-u'-1);
          reconsider ku = k - u' as Element of NAT by A2,INT_1:18;
          k - k < ku by A2,XREAL_1:12;
          then 0 + 1 < ku + 1 by XREAL_1:8;
          then 1 <= k-u' by NAT_1:13;
          then reconsider m = k-u'-1 as Element of NAT by INT_1:18;
          power(L).(z,m) in the carrier of L;
          hence thesis by A2;
        end;
        suppose
A3:       u' >= k;
          take y = 0.L;
          thus thesis by A3;
        end;
      end;
    end;
    consider f being Function of NAT,the carrier of L such that
A4: for x being set st x in NAT holds P[x,f.x] from FUNCT_2:sch 1(A1);
    reconsider f as sequence of L;
A5: for i being Nat st i >= k holds f.i = 0.L
    proof
      let i be Nat;
      assume
A6:   i >= k;
      i in NAT by ORDINAL1:def 13;
      then consider n being Element of NAT such that
A7:   n = i & (n < k implies f.i = power(L).(z,k-n-1)) &
      (n >= k implies f.i = 0.L) by A4;
      thus thesis by A6,A7;
    end;
    then reconsider p = f as AlgSequence of L by ALGSEQ_1:def 2;
    take p;
    now
      let i be Nat;
      assume
A8:   i < k;
      i in NAT by ORDINAL1:def 13;
      then consider n being Element of NAT such that
A9:   n = i & (n < k implies f.i = power(L).(z,k-n-1)) &
      (n >= k implies f.i = 0.L) by A4;
      thus p.i = power(L).(z,k-i-1) by A8,A9;
    end;
    hence thesis by A5;
  end;
  uniqueness
  proof
    let z1,z2 be AlgSequence of L;
    assume
A10: (for i being Nat st i < k holds z1.i = power(L).(z,k-i-1)) &
    (for i being Nat st i >= k holds z1.i = 0.L);
    assume
A11: (for i being Nat st i < k holds z2.i = power(L).(z,k-i-1)) &
    (for i being Nat st i >= k holds z2.i = 0.L);
A12: dom z1 = NAT by FUNCT_2:def 1
      .= dom z2 by FUNCT_2:def 1;
    now
      let x be set;
      assume x in dom z1;
      then reconsider x' = x as Element of NAT;
      per cases;
      suppose
A13:    x' < k;
        hence z1.x = power(L).(z,k-x'-1) by A10
          .= z2.x by A11,A13;
      end;
      suppose
A14:    x' >= k;
        hence z1.x = 0.L by A10
          .= z2.x by A11,A14;
      end;
    end;
    hence z1 = z2 by A12,FUNCT_1:9;
  end;
end;

theorem
  for L being well-unital non degenerated (non empty doubleLoopStr)
  for z being Element of L
  for k being Element of NAT st k >= 1 holds deg qpoly(k,z) = k - 1
proof
  let L be well-unital non degenerated (non empty doubleLoopStr);
  let z be Element of L;
  let k be Element of NAT;
  assume k >= 1;
  then k - 1 >= 1 - 1 by XREAL_1:11;
  then reconsider k' = k - 1 as Element of NAT by INT_1:16;
  set p = qpoly(k,z);
  for i being Nat st i >= k holds p.i = 0.L by Def4;
  then
A1: k is_at_least_length_of p by ALGSEQ_1:def 3;
A2: k - k' - 1 = 0;
  k - 1 < k - 0 by XREAL_1:12;
  then p.(k-1) = power(L).(z,0) by A2,Def4
    .= 1_L by GROUP_1:def 8;
  then
A3: p.(k-1) <> 0.L;
  now
    let m be Nat;
    assume
A4: m is_at_least_length_of p;
    now
      assume k > m;
      then k' + 1 > m;
      then k' >= m by NAT_1:13;
      hence contradiction by A3,A4,ALGSEQ_1:def 3;
    end;
    hence k <= m;
  end;
  hence thesis by A1,ALGSEQ_1:def 4;
end;

theorem Th32:
  for L being add-associative right_zeroed right_complementable
  left-distributive well-unital commutative (non empty doubleLoopStr)
  for z being Element of L for k being Element of NAT st k > 1 holds
  rpoly(1,z) *' qpoly(k,z) = rpoly(k,z)
proof
  let L be add-associative right_zeroed right_complementable
  left-distributive well-unital commutative (non empty doubleLoopStr);
  let z be Element of L, k be Element of NAT;
  assume
A1: k > 1;
  then reconsider k1 = k - 1 as Element of NAT by INT_1:18;
  k1 + 1 = k;
  then
A2: k1 <= k by INT_1:19;
  k1 <> k;
  then
A3: k1 < k by A2,XXREAL_0:1;
  set p = rpoly(1,z) *' qpoly(k,z), u = rpoly(k,z);
A4: dom p = NAT by FUNCT_2:def 1
    .= dom u by FUNCT_2:def 1;
  now
    let i' be set;
    assume i' in dom p;
    then reconsider i = i' as Element of NAT;
    consider fp being FinSequence of L such that
A5: len fp = i+1 & p.i = Sum fp & for j be Element of NAT st j in dom fp
    holds fp.j = rpoly(1,z).(j-'1) * qpoly(k,z).(i+1-'j) by POLYNOM3:def 11;
A6: 0 + 1 = 1 & 1 - 1 >= 0;
A7: 2 - 1 >= 0;
    len fp >= 1 by A5,NAT_1:11;
    then 1 in Seg(len fp);
    then
A8: 1 in dom fp by FINSEQ_1:def 3;
    then
A9: fp/.1 = fp.1 by PARTFUN1:def 8
      .= rpoly(1,z).(1-'1) * qpoly(k,z).(i+1-'1) by A5,A8
      .= rpoly(1,z).0 * qpoly(k,z).(i+1-'1) by A6,XREAL_0:def 2
      .= (-power(L).(z,1)) * qpoly(k,z).(i+1-'1) by Lm11
      .= (-power(L).(z,0)*z) * qpoly(k,z).(i+1-'1) by A6,GROUP_1:def 8
      .= (-(1_L*z)) * qpoly(k,z).(i+1-'1) by GROUP_1:def 8
      .= (-z) * qpoly(k,z).(i+1-'1) by VECTSP_1:def 19
      .= (-z) * qpoly(k,z).i by NAT_D:34;
A10: i + 1 - 2 = i - 1;
A11: now
      assume i <> 0;
      then i > 0;
      then
A12:  i + 1 > 0 + 1 by XREAL_1:10;
      then i >= 1 by NAT_1:13;
      then reconsider i1 = i-1 as Element of NAT by INT_1:18;
      len fp >= 1+1 by A5,A12,NAT_1:13;
      then 2 in Seg(len fp);
      then
A13:  2 in dom fp by FINSEQ_1:def 3;
      then
A14:  fp.2 = rpoly(1,z).(2-'1) * qpoly(k,z).(i+1-'2) by A5
        .= rpoly(1,z).1 * qpoly(k,z).(i+1-'2) by A7,XREAL_0:def 2
        .= 1_L * qpoly(k,z).(i+1-'2) by Lm11
        .= qpoly(k,z).(i+1-'2) by VECTSP_1:def 19
        .= qpoly(k,z).i1 by A10,XREAL_0:def 2;
      thus fp/.2 = fp.2 by A13,PARTFUN1:def 8
        .= qpoly(k,z).(i-'1) by A14,XREAL_0:def 2;
    end;
A15: now
      let j be Element of NAT;
      assume
A16:  j in dom fp & j <> 1 & j <> 2;
      then
A17:  j in Seg(len fp) by FINSEQ_1:def 3;
A18:  fp.j = rpoly(1,z).(j-'1) * qpoly(k,z).(i+1-'j) by A5,A16;
      now
        assume
A19:    j-'1 = 0 or j-'1 = 1;
        per cases;
        suppose j-1 >= 0;
          then j-'1 = j - 1 by XREAL_0:def 2;
          hence contradiction by A16,A19;
        end;
        suppose j-1 < 0;
          then j-1+1 < 0 + 1 by XREAL_1:10;
          hence contradiction by A17,FINSEQ_1:3;
        end;
      end;
      then rpoly(1,z).(j-'1) = 0.L by Lm12;
      hence fp.j = 0.L by A18,VECTSP_1:39;
    end;
A20: now
      assume i <> 0;
      then i > 0;
      then
A21:  i+1 > 0+1 by XREAL_1:10;
      then
A22:  i >= 1 by NAT_1:13;
      consider g1,g2 being FinSequence of L such that
A23:  len g1 = 1 & len g2 = i & fp = g1 ^ g2 by A5,FINSEQ_2:26;
      1 in Seg len g2 by A22,A23;
      then
A24:  1 in dom g2 by FINSEQ_1:def 3;
A25:  1 + 1 = 2;
      1+1 <= len fp by A5,A21,NAT_1:13;
      then 2 in Seg(len fp);
      then
A26:  2 in dom fp by FINSEQ_1:def 3;
      now
        let i be Element of NAT;
        assume
A27:    i in dom g2 & i <> 1;
        then
A28:    i in Seg(len g2) by FINSEQ_1:def 3;
        then
A29:    1 <= i & i <= len g2 by FINSEQ_1:3;
        then
A30:    g2.i = fp.(i+1) by A23,FINSEQ_1:86;
        len fp = 1 + len g2 by A23,FINSEQ_1:35;
        then 1 <= i + 1 & i + 1 <= len fp by A29,NAT_1:11,XREAL_1:8;
        then i + 1 in Seg(len fp);
        then
A31:    i+1 in dom fp by FINSEQ_1:def 3;
        i+1<>0+1 & i+1<>2 by A27,A28,FINSEQ_1:3;
        then fp.(i+1)=0.L by A15,A31;
        hence g2/.i = 0.L by A27,A30,PARTFUN1:def 8;
      end;
      then
A32:  Sum g2 = g2/.1 by A24,POLYNOM2:5
        .= g2.1 by A24,PARTFUN1:def 8
        .= fp.2 by A22,A23,A25,FINSEQ_1:86
        .= fp/.2 by A26,PARTFUN1:def 8;
A33:  g1 = <*g1.1*> by A23,FINSEQ_1:57
        .= <*fp.1*> by A23,FINSEQ_1:85
        .= <*fp/.1*> by A8,PARTFUN1:def 8;
      thus p.i = Sum(g1) + fp/.2 by A5,A23,A32,RLVECT_1:58
        .= fp/.1 + fp/.2 by A33,RLVECT_1:61;
    end;
    per cases by XXREAL_0:1;
    suppose
A34:  i < k;
      per cases;
      suppose
A35:    i = 0;
A36:    k-0-1 = k1 & k1 + 1 = k;
        fp = <*fp.1*> by A5,A35,FINSEQ_1:57
          .= <*fp/.1*> by A8,PARTFUN1:def 8;
        hence p.i' = (-z) * qpoly(k,z).0 by A5,A9,A35,RLVECT_1:61
          .= (-z) * power(L).(z,k1) by A36,Def4
          .= -(z* power(L).(z,k1)) by VECTSP_1:41
          .= - power(L).(z,k) by A36,GROUP_1:def 8
          .= u.i' by A1,A35,Lm11;
      end;
      suppose
A37:    i > 0;
        then i + 1 > 0 + 1 by XREAL_1:8;
        then i >= 1 by NAT_1:13;
        then i - 1 >= 1 - 1 by XREAL_1:11;
        then
A38:    i -' 1 = i - 1 by XREAL_0:def 2;
        k - i > i - i by A34,XREAL_1:11;
        then reconsider ki = k - i as Element of NAT by INT_1:16;
        ki > i - i by A34,XREAL_1:11;
        then ki + 1 > 0 + 1 by XREAL_1:8;
        then ki >= 1 by NAT_1:13;
        then reconsider ki1 = k-i-1 as Element of NAT by INT_1:18;
A39:    k- (i-'1) - 1 = k - i by A38;
        k-1 < k-0 by XREAL_1:12;
        then i-1 < k-1 & k-1 < k by A34,XREAL_1:11;
        then
A40:    i - 1 < k by XXREAL_0:2;
A41:    ki1 + 1 = ki;
        thus p.i' = ((-z)*power(L).(z,ki1))+qpoly(k,z).(i-'1)
        by A9,A11,A20,A34,A37,Def4
          .= ((-z) * power(L).(z,ki1)) + power(L).(z,ki) by A39,A40,Def4
          .= (-(z * power(L).(z,ki1))) + power(L).(z,ki) by VECTSP_1:41
          .= - power(L).(z,ki) + power(L).(z,ki) by A41,GROUP_1:def 8
          .= 0.L by RLVECT_1:16
          .= u.i' by A34,A37,Lm12;
      end;
    end;
    suppose
A42:  i = k;
      then i - 1 >= 1 - 1 by A1,XREAL_1:11;
      then
A43:  i -' 1 = i - 1 by XREAL_0:def 2;
A44:  k - k1 - 1 = 0;
      fp/.1 = (-z) * 0.L by A9,A42,Def4
        .= 0.L by VECTSP_1:36;
      hence p.i' = qpoly(k,z).(k1) by A11,A20,A42,A43,ALGSTR_1:def 5
        .= power(L).(z,0) by A3,A44,Def4
        .= 1_L by GROUP_1:def 8
        .= u.i' by A1,A42,Lm11;
    end;
    suppose
A45:  i > k;
      then i + 1 > 0 + 1 by XREAL_1:8;
      then i >= 1 by NAT_1:13;
      then i - 1 >= 1 - 1 by XREAL_1:11;
      then
A46:  i -' 1 = i - 1 by XREAL_0:def 2;
      i >= k+1 by A45,NAT_1:13;
      then
A47:  i - 1 >= k + 1 - 1 by XREAL_1:11;
      fp/.1 = (-z) * 0.L by A9,A45,Def4
        .= 0.L by VECTSP_1:36;
      hence p.i' = qpoly(k,z).(i-'1) by A11,A20,A45,ALGSTR_1:def 5
        .= 0.L by A46,A47,Def4
        .= u.i' by A45,Lm12;
    end;
  end;
  hence thesis by A4,FUNCT_1:9;
end;

theorem Th33:
  for L being Abelian add-associative right_zeroed right_complementable
  well-unital associative distributive commutative (non empty doubleLoopStr)
  for p being Polynomial of L for z being Element of L st z is_a_root_of p
  ex s being Polynomial of L st p = rpoly(1,z) *' s
proof

let L be Abelian add-associative right_zeroed right_complementable well-unital
  distributive associative commutative (non empty doubleLoopStr);
  let p be Polynomial of L;
  let z be Element of L;
  assume
A1: z is_a_root_of p;
  set m = len p;
  per cases;
  suppose m = 0;
    then
A2: p = 0_.(L) by POLYNOM4:8;
    take s = 0_.(L); thus thesis by A2,POLYNOM3:35;
  end;
  suppose
A3: m > 0;
    then m >= 0+1 by NAT_1:13;
    then reconsider m1 = m - 1 as Element of NAT by INT_1:18;
A4: m1 + 1 = m;
A5: now
      assume m1 < 1;
      then deg p = 0 by NAT_1:14;
      then not(p is with_roots) by Th24;
      hence contradiction by A1,POLYNOM5:def 7;
    end;
    defpred Pq[set,set] means ($1 = 1 & $2 = p.1 * 1_.(L)) or
    ($1 <> 1 & ex u being Element of L st
    ex b being Element of NAT st u = p.$1 & b = $1 & $2 = u*qpoly(b,z));
A6: for k being Nat st k in Seg(m1) ex x being Element
    of the carrier of Polynom-Ring(L) st Pq[k,x]
    proof
      let k be Nat;
      assume k in Seg(m1);
      then
A7:   1 <= k & k <= m1 by FINSEQ_1:3;
A8:   dom p = NAT by FUNCT_2:def 1;
      per cases by A7,XXREAL_0:1;
      suppose
A9:     k = 1;
        reconsider t = p.1 * 1_.(L) as Element of
        the carrier of Polynom-Ring(L) by POLYNOM3:def 12;
        take t; thus thesis by A9;
      end;
      suppose
A10:    k > 1;
        reconsider t = p/.k * qpoly(k,z) as Element of
        the carrier of Polynom-Ring(L) by POLYNOM3:def 12;
        take t;
        Pq[k,t]
        proof ex u being Element of L st
          ex b being Element of NAT st u = p.k & b = k & t = u*qpoly(b,z)
          proof
            reconsider b = k as Element of NAT by ORDINAL1:def 13;
            take p/.k;
            take b;
            b in NAT;
            hence thesis by A8,PARTFUN1:def 8;
          end;
          hence thesis by A10;
        end;
        hence thesis;
      end;
    end;
    consider hs being FinSequence of Polynom-Ring(L) such that
A11: dom hs = Seg m1 & for k being Nat st k in Seg(m1)
    holds Pq[k,hs.k] from FINSEQ_1:sch 5(A6);
A12: len hs = m1 & hs.1 = p.1*1_.(L) & for i being Element of NAT
    st 1 < i & i <= m-1 holds hs.i = p.i * qpoly(i,z)
    proof thus len hs = m1 by A11,FINSEQ_1:def 3;
      1 in Seg m1 by A5;
      hence hs.1 = p.1 * 1_.(L) by A11;
      now
        let i be Element of NAT;
        assume
A13:    1 < i & i <= m-1;
        then i in Seg m1;
        then consider u being Element of L such that
A14:    ex b being Element of NAT
        st u = p.i & b = i & hs.i = u*qpoly(b,z) by A11,A13;
        consider b being Element of NAT such that
A15:    u = p.i & b = i & hs.i = u*qpoly(b,z) by A14;
        thus hs.i = p.i * qpoly(i,z) by A15;
      end;
      hence thesis;
    end;
    defpred Pr[set,set] means ex u being Element of L st
    ex b being Element of NAT st u = p.$1 & b = $1 & $2 = u * rpoly(b,z);
A16: for k being Nat st k in Seg(m1) ex x being Element
    of the carrier of Polynom-Ring(L) st Pr[k,x]
    proof
      let k be Nat;
      assume k in Seg(m1);
      then reconsider k1=k as Element of NAT;
      reconsider t = p/.k * rpoly(k1,z) as Element of
      the carrier of Polynom-Ring(L) by POLYNOM3:def 12;
      take t;
      take p/.k;
      take k1;
A17:  dom p = NAT by FUNCT_2:def 1;
      k1 in NAT;
      hence thesis by A17,PARTFUN1:def 8;
    end;
    consider h being FinSequence of Polynom-Ring(L) such that
A18: dom h = Seg m1 & for k being Nat st k in Seg(m1)
    holds Pr[k,h.k] from FINSEQ_1:sch 5(A16);
A19: len h = m1 & for i being Element of NAT st 1 <= i & i <= m1
    holds h.i = p.i * rpoly(i,z)
    proof thus len h = m1 by A18,FINSEQ_1:def 3;
      now
        let k be Element of NAT;
        assume 1 <= k & k <= m1;
        then k in Seg(m1);
        then consider u being Element of L such that
A20:    ex
        b being Element of NAT st u = p.k & b = k & h.k = u*rpoly(b,z) by A18;
        consider b being Element of NAT such that
A21:    u = p.k & b = k & h.k = u*rpoly(b,z) by A20;
        thus h.k = p.k * rpoly(k,z) by A21;
      end;
      hence thesis;
    end;
    set s = Sum hs, rs = Sum h;
    reconsider s, rs as Polynomial of L by POLYNOM3:def 12;
    take s;
A22: rpoly(1,z) *' s = rs
    proof
A23:  dom(rpoly(1,z) *' s) = NAT by FUNCT_2:def 1
        .= dom rs by FUNCT_2:def 1;
      now
        let i' be set;
        assume i' in dom rs;
        reconsider r1z = rpoly(1,z) as Element of Polynom-Ring(L)
        by POLYNOM3:def 12;
A24:    dom(r1z * hs) = dom h by A11,A18,POLYNOM1:def 2;
        now
          let k be Nat;
          assume
A25:      k in dom h;
          then k in Seg m1 by A19,FINSEQ_1:def 3;
          then
A26:      1 <= k & k <= m1 by FINSEQ_1:3;
          per cases by A26,XXREAL_0:1;
          suppose
A27:        k = 1;
            then
A28:        hs/.k = p.1*1_.(L) by A11,A12,A18,A25,PARTFUN1:def 8;
            thus (r1z*hs).k = (r1z*hs)/.k by A24,A25,PARTFUN1:def 8
              .= r1z * hs/.k by A11,A18,A25,POLYNOM1:def 2
              .= rpoly(1,z) *' (p.1 * 1_.(L)) by A28,POLYNOM3:def 12
              .= p.1 * (rpoly(1,z) *' 1_.(L)) by Th19
              .= p.1 * rpoly(1,z) by POLYNOM3:36
              .= h.k by A19,A26,A27;
          end;
          suppose
A29:        k > 1;
            reconsider k1 = k as Element of NAT by A25;
A30:        hs/.k = hs.k by A11,A18,A25,PARTFUN1:def 8
              .= p.k1 * qpoly(k1,z) by A12,A26,A29;
            thus (r1z*hs).k = (r1z*hs)/.k by A24,A25,PARTFUN1:def 8
              .= r1z * hs/.k by A11,A18,A25,POLYNOM1:def 2
              .= rpoly(1,z) *' (p.k1*qpoly(k1,z)) by A30,POLYNOM3:def 12
              .= p.k1 * (rpoly(1,z) *' qpoly(k1,z)) by Th19
              .= p.k1 * rpoly(k1,z) by A29,Th32
              .= h.k by A19,A26;
          end;
        end;
        then r1z * hs = h by A24,FINSEQ_1:17;
        hence rs.i' = (rpoly(1,z) *' s).i' by Lm6;
      end;
      hence thesis by A23,FUNCT_1:9;
    end;
A31: now
      let i be Element of NAT;
      assume
A32:  i > 0 & i < len p;
      then i + 1 > 0 + 1 by XREAL_1:10;
      then
A33:  i >= 1 by NAT_1:13;
      i < m1 + 1 by A32;
      then
A34:  i <= m1 by NAT_1:13;
      then
A35:  i in Seg len h by A19,A33;
      set co = Coeff(h,i);
A36:  dom h = Seg len h by FINSEQ_1:def 3
        .= Seg len co by Def1
        .= dom co by FINSEQ_1:def 3;
      then
A37:  i in dom co by A35,FINSEQ_1:def 3;
      now
        let i' be Element of NAT;
        assume
A38:    i' in dom co & i' <> i;
        then consider ci being Polynomial of L such that
A39:    ci = h.i' & co.i' = ci.i by Def1;
        i' in Seg m1 by A19,A36,A38,FINSEQ_1:def 3;
        then 1 <= i' & i' <= m-1 by FINSEQ_1:3;
        then co.i' = (p.i' * rpoly(i',z)).i by A19,A39
          .= p.i' * rpoly(i',z).i by POLYNOM5:def 3
          .= p.i' * 0.L by A32,A38,Lm12
          .= 0.L by VECTSP_1:36;
        hence co/.i' = 0.L by A38,PARTFUN1:def 8;
      end;
      then
A40:  Sum co = co/.i by A37,POLYNOM2:5
        .= co.i by A37,PARTFUN1:def 8;
      consider cc being Polynomial of L such that
A41:  cc = h.i & co.i = cc.i by A37,Def1;
      h.i = p.i * rpoly(i,z) by A19,A33,A34;
      hence rs.i = (p.i * rpoly(i,z)).i by A40,A41,Th13;
    end;
A42: now
      let i be Element of NAT;
      assume
A43:  i >= len p;
      set co = Coeff(h,i);
A44:  dom h = Seg(len h) by FINSEQ_1:def 3
        .= Seg(len co) by Def1
        .= dom co by FINSEQ_1:def 3;
      now
        let j be Element of NAT;
        assume
A45:    j in dom co;
        then consider ci being Polynomial of L such that
A46:    ci = h.j & co.j = ci.i by Def1;
        j in Seg(m1) by A19,A44,A45,FINSEQ_1:def 3;
        then
A47:    1 <= j & j <= m1 by FINSEQ_1:3;
        then
A48:    j <> i by A4,A43,NAT_1:16,XXREAL_0:2;
        thus co.j = (p.j * rpoly(j,z)).i by A19,A46,A47
          .= p.j * rpoly(j,z).i by POLYNOM5:def 3
          .= p.j * 0.L by A3,A43,A48,Lm12
          .= 0.L by VECTSP_1:36;
      end;
      then Sum co = 0.L by POLYNOM3:1;
      hence rs.i = 0.L by Th13;
    end;
    rs = p
    proof
A49:  dom p = NAT by FUNCT_2:def 1
        .= dom rs by FUNCT_2:def 1;
      now
        let i' be set;
        assume i' in dom p;
        then reconsider i = i' as Element of NAT;
        per cases;
        suppose
A50:      i = 0;
          consider evp being FinSequence of L such that
A51:      eval(p,z) = Sum evp & len evp = len p &
          for n being Element of NAT st n in dom evp holds evp.n =
          p.(n-'1) * (power L).(z,n-'1) by POLYNOM4:def 2;
A52:      Sum evp = 0.L by A1,A51,POLYNOM5:def 6;
          set co = Coeff(h,0);
A53:      dom h = Seg len h by FINSEQ_1:def 3
            .= Seg len co by Def1
            .= dom co by FINSEQ_1:def 3;
A54:      now
            let j be Element of NAT;
            assume
A55:        j in dom co;
            then consider ci being Polynomial of L such that
A56:        ci = h.j & co.j = ci.i by A50,Def1;
            reconsider aj = -power(L).(z,j) as Element of L;
            j in Seg(m1) by A19,A53,A55,FINSEQ_1:def 3;
            then
A57:        1 <= j & j <= m1 by FINSEQ_1:3;
            hence co.j = (p.j * rpoly(j,z)).i by A19,A56
              .= p.j * rpoly(j,z).i by POLYNOM5:def 3
              .= p.j * aj by A50,A57,Lm11
              .= -(p.j * power(L).(z,j)) by VECTSP_1:40;
          end;
          set cop = <*-(p.0)*> ^ co;
A58:      len cop = len <*-(p.0)*> + len co by FINSEQ_1:35
            .= 1 + len co by FINSEQ_1:56;
          then
A59:      len cop = 1 + len h by Def1
            .= len evp by A19,A51;
          then
A60:      dom cop = Seg(len evp) by FINSEQ_1:def 3
            .= dom evp by FINSEQ_1:def 3;
          now
            let j be Element of NAT;
            assume
A61:        j in dom cop;
            then
A62:        j in Seg len cop by FINSEQ_1:def 3;
            then
A63:        1 <= j & j <= len cop by FINSEQ_1:3;
A64:        dom <*-(p.0)*> = {1} by FINSEQ_1:4,55;
A65:        evp/.j = evp.j by A60,A61,PARTFUN1:def 8
              .= p.(j-'1) * (power L).(z,j-'1) by A51,A60,A61;
            per cases by A63,XXREAL_0:1;
            suppose
A66:          j = 1;
              then j in dom <*-(p.0)*> by A64,TARSKI:def 1;
              then
A67:          cop.j = <*-(p.0)*>.j by FINSEQ_1:def 7
                .= -(p.0) by A66,FINSEQ_1:57;
              j -' 1 = 1 - 1 by A66,XREAL_0:def 2;
              then evp/.j = p.0 * 1_L by A65,GROUP_1:def 8
                .= p.0 by VECTSP_1:def 13;
              hence cop/.j = - evp/.j by A61,A67,PARTFUN1:def 8;
            end;
            suppose
A68:          j > 1;
              then reconsider j1 = j - 1 as Element of NAT by INT_1:18;
              1 < j1 + 1 by A68;
              then
A69:          1 <= j1 by NAT_1:13;
              j1 <= len cop - 1 by A63,XREAL_1:11;
              then j1 in Seg(len co) by A58,A69;
              then
A70:          j1 in dom co by FINSEQ_1:def 3;
              len<*-(p.0)*> < j&j <= len cop by A62,A68,FINSEQ_1:3,57;
              then
A71:          cop.j = co.(j - len <*-(p.0)*>) by FINSEQ_1:37
                .= co.(j - 1) by FINSEQ_1:57
                .= -(p.j1 * power(L).(z,j1)) by A54,A70;
              j-1 >= 1-1 by A68,XREAL_1:11;
              then j-'1 = j-1 by XREAL_0:def 2;
              hence cop/.j = - evp/.j by A61,A65,A71,PARTFUN1:def 8;
            end;
          end;
          then - Sum evp = Sum cop by A59,Th7
            .= Sum <*-(p.0)*> + Sum co by RLVECT_1:58
            .= -(p.0) + Sum co by RLVECT_1:61;
          then 0.L = -(p.0) + Sum co by A52,RLVECT_1:25;
          then p.0 = p.0 + (-(p.0) + Sum co) by ALGSTR_1:def 5
            .= (p.0 + -(p.0)) + Sum co by RLVECT_1:def 6
            .= 0.L + Sum co by RLVECT_1:16
            .= Sum co by ALGSTR_1:def 5;
          hence p.i' = rs.i' by A50,Th13;
        end;
        suppose
A72:      i > 0;
          per cases;
          suppose
A73:        i >= len p;
            hence rs.i' = 0.L by A42
              .= p.i' by A73,ALGSEQ_1:22;
          end;
          suppose i < len p;
            hence rs.i' = (p.i * rpoly(i,z)).i by A31,A72
              .= p.i * rpoly(i,z).i by POLYNOM5:def 3
              .= p.i * 1_L by A72,Lm11
              .= p.i' by VECTSP_1:def 13;
          end;
        end;
      end;
      hence thesis by A49,FUNCT_1:9;
    end;
    hence thesis by A22;
  end;
end;

begin :: Division of Polynomials

definition
  let L be Abelian add-associative right_zeroed right_complementable
  well-unital associative commutative distributive
  almost_left_invertible (non empty doubleLoopStr);
  let p,s be Polynomial of L such that
A1: s <> 0_.(L);
  func p div s -> Polynomial of L means
  :Def5:
  ex t being Polynomial of L st p = it *' s + t & deg t < deg s;
  existence
  proof
    set M = { p - u *' s where u is Polynomial of L : 1 = 1 };
    defpred P[Nat] means ex t being Polynomial of L st t in M & len t = $1;
    p = p + 0_.(L) by POLYNOM3:29
      .= p + -0_.(L) by Th9
      .= p - ((0_.(L)) *' s) by POLYNOM4:5;
    then p in M;
    then ex t being Polynomial of L st t in M & len t = len p;
    then
A2: ex k being Nat st P[k];
    consider k being Nat such that
A3: P[k] & for n being Nat st P[n] holds k <= n from NAT_1:sch 5(A2);
    consider f being Polynomial of L such that
A4: f in M & len f = k by A3;
    consider g being Polynomial of L such that
A5: f = p - g *' s & 1 = 1 by A4;
    take g;
A6: g *' s + (p - g *' s) = (g *' s + -(g *' s)) + p by POLYNOM3:26
      .= (g *' s - g *' s ) + p
      .= 0_.(L) + p by POLYNOM3:30
      .= p by POLYNOM3:29;
    len s <> 0 by A1,POLYNOM4:8;
    then
A7: len s > 0;
    then
A8: s.(len(s)-1) <> 0.L by Lm7;
    len s + 1 > 0 + 1 by A7,XREAL_1:8;
    then len s >= 1 by NAT_1:13;
    then
A9: len s - 1 >= 1 - 1 by XREAL_1:11;
    then
A10: s.(len s-'1) <> 0.L by A8,XREAL_0:def 2;
    per cases;
    suppose f = 0_.(L);
      then
A11:  deg(f) = -1 by Th20;
      reconsider s' = deg s as Nat by A1,Lm9;
      s' >= 0;
      hence thesis by A5,A6,A11;
    end;
    suppose f <> 0_.(L);
      then len f <> 0 by POLYNOM4:8;
      then len f > 0;
      then len f + 1 > 0 + 1 by XREAL_1:8;
      then len f >= 1 by NAT_1:13;
      then
A12:  len f - 1 >= 1 - 1 by XREAL_1:11;
      then reconsider k' = len f - 1 as Element of NAT by INT_1:16;
      dom f = NAT by FUNCT_2:def 1;
      then
A13:  k' in dom f;
A14:  k = k' + 1 by A4;
      now
        assume deg f >= deg s;
        then reconsider degn = deg(f) - deg(s) as Element of NAT by INT_1:18;
        set al = f.(len f -' 1) * (s.(len s -' 1))";
        set g1 = 0_.(L)+*({degn} --> al);
A15:    dom({degn} --> al) = {degn} by FUNCOP_1:19;
A16:    degn in {degn} by TARSKI:def 1;
A17:    dom(0_.(L)) = NAT by FUNCT_2:def 1;
        now
          let u be set;
          assume u in {degn};
          then u = degn by TARSKI:def 1;
          hence u in NAT;
        end;
        then {degn} c= NAT by TARSKI:def 3;
        then dom(0_.(L))\/dom({degn}-->al) = NAT by A15,A17,XBOOLE_1:12;
        then
A18:    dom g1 = NAT by FUNCT_4:def 1;
        now
          let x' be set;
          assume x' in NAT;
          then reconsider x = x' as Element of NAT;
          per cases;
          suppose
A19:        x in dom({degn} --> al);
            then x = degn by TARSKI:def 1;
            then g1.x = ({degn} --> al).degn by A19,FUNCT_4:14
              .= al by A16,FUNCOP_1:13;
            hence g1.x' in the carrier of L;
          end;
          suppose not x in dom({degn} --> al);
            then g1.x = (0_.(L)).x by FUNCT_4:12
              .= 0.L by FUNCOP_1:13;
            hence g1.x' in the carrier of L;
          end;
        end;
        then reconsider g1 as sequence of L by A18,FUNCT_2:5;
A20:    degn in {degn} by TARSKI:def 1;
        then degn in dom({degn} --> al) by FUNCOP_1:19;
        then
A21:    g1.degn = ({degn} --> al).degn by FUNCT_4:14
          .= al by A20,FUNCOP_1:13;
A22:    for j being Nat st j <> degn holds g1.j = 0.L
        proof
          let j be Nat;
A23:      j in NAT by ORDINAL1:def 13;
          assume
A24:      j <> degn;
          not(j in dom({degn} --> al)) by A24,TARSKI:def 1;
          hence g1.j = (0_.(L)).j by FUNCT_4:12
            .= 0.L by A23,FUNCOP_1:13;
        end;
        ex l being Nat st for i being Nat st i>=l holds g1.i = 0.L
        proof
          take l = degn + 1;
          now
            let i be Nat;
            assume i >= l;
            then i <> degn by NAT_1:13;
            hence g1.i = 0.L by A22;
          end;
          hence thesis;
        end;
        then reconsider g1 as Polynomial of L by ALGSEQ_1:def 2;
        set s1 = p - (g + g1) *' s;
A25:    s1 in M;
        now
          let i be Nat;
A26:      i in NAT by ORDINAL1:def 13;
          assume
A27:      i >= k';
A28:      s1 - f = (p + -(g + g1) *' s) + (-p + -(-(g *' s))) by A5,Th11
            .= ((p + -(g + g1) *' s) + -p) + -(-(g *' s)) by POLYNOM3:26
            .= ((p - p) + -(g + g1) *' s) + -(-(g *' s)) by POLYNOM3:26
            .= (0_.(L) + -(g+g1) *' s) + -(-(g*'s)) by POLYNOM3:30
            .= (-(g + g1) *' s) + -(-(g *' s)) by POLYNOM3:29
            .= ((-(g + g1)) *' s) + -(-(g *' s)) by Th12
            .= ((-g + -g1) *' s) + -(-(g *' s)) by Th11
            .= (((-g) + (-g1)) *' s) + g *' s by Lm4
            .= ((-g) *' s + (-g1) *' s) + g *' s by POLYNOM3:33
            .= (-g1) *' s + ((-g) *' s + g *' s) by POLYNOM3:26
            .= (-g1) *' s + (g *' s - g *' s) by Th12
            .= (-g1) *' s + 0_.(L) by POLYNOM3:30
            .= (-g1) *' s by POLYNOM3:29
            .= -(g1 *' s) by Th12;
A29:      s1 = s1 + 0_.(L) by POLYNOM3:29
            .= s1 + (f - f) by POLYNOM3:30
            .= (s1 + -f) + f by POLYNOM3:26
            .= f - g1 *' s by A28;
A30:      dom f = NAT & dom(g1 *' s) = NAT by FUNCT_2:def 1;
A31:      s1.i = f.i + (-(g1 *' s)).i by A26,A29,NORMSP_1:def 5
            .= f.i + -(g1 *' s).i by A26,BHSP_1:def 10
            .= f/.i + -(g1 *' s).i by A26,A30,PARTFUN1:def 8
            .= f/.i + -(g1 *' s)/.i by A26,A30,PARTFUN1:def 8;
          consider sf being FinSequence of L such that
A32:      len sf = i+1 & (g1 *' s).i = Sum sf &
          for m being Element of NAT st m in dom sf
          holds sf.m = g1.(m-'1) * s.(i+1-'m) by A26,POLYNOM3:def 11;
A33:      dom sf = Seg(len sf) by FINSEQ_1:def 3;
          degn + 1 = k - deg(s) by A4;
          then
A34:      degn + 1 <= k by A9,XREAL_1:45;
A35:      now
            let m be Nat;
            assume
A36:        m in dom sf & m <> degn + 1;
            then 1 <= m & m <= len sf by A33,FINSEQ_1:3;
            then m - 1 >= 1 - 1 by XREAL_1:11;
            then m-'1 = m-1 by XREAL_0:def 2;
            then (m-'1) <> degn by A36;
            hence g1.(m-'1) = 0.L by A22;
          end;
A37:      now
            let i' be Element of NAT;
            assume
A38:        i' in dom sf & i' <> degn + 1;
            then sf.i' = g1.(i'-'1) * s.(i+1-'i') by A32
              .= 0.L * s.(i+1-'i') by A35,A38
              .= 0.L by VECTSP_1:39;
            hence sf/.i' = 0.L by A38,PARTFUN1:def 8;
          end;
A39:      i + 1 >= k by A14,A27,XREAL_1:8;
          then
A40:      i + 1 >= degn + 1 by A34,XXREAL_0:2;
A41:      i + 1 - (degn + 1) is Element of NAT by A34,A39,INT_1:18,XXREAL_0:2;
A42:      i in NAT by ORDINAL1:def 13;
          1 <= degn + 1 by NAT_1:11;
          then
A43:      degn + 1 in dom sf by A32,A33,A40;
          then
A44:      Sum sf = sf/.(degn + 1) by A37,POLYNOM2:5
            .= sf.(degn+1) by A43,PARTFUN1:def 8
            .= g1.(degn+1-'1) * s.(i+1-'(degn+1)) by A32,A43
            .= al * s.(i+1-'(degn+1)) by A21,NAT_D:34;
          per cases by A27,XXREAL_0:1;
          suppose
A45:        i > k';
            then i + 1 > k' + 1 by XREAL_1:8;
            then i >= len f by NAT_1:13;
            then f.i = 0.L by ALGSEQ_1:22;
            then
A46:        f/.i = 0.L by A30,A42,PARTFUN1:def 8;
A47:        i+1-'(degn+1) = i - k' + (len(s)-1) by A41,XREAL_0:def 2;
            reconsider e = i - k' as Element of NAT by A45,INT_1:18;
            i - k' > k' - k' by A45,XREAL_1:11;
            then e + 1 > 0 + 1 by XREAL_1:8;
            then e >= 1 by NAT_1:13;
            then i - k' - 1 >= 1 - 1 by XREAL_1:11;
            then (i - k' - 1) + len(s) >= 0 + len(s) by XREAL_1:8;
            then s.(i+1-'(degn+1)) = 0.L by A47,ALGSEQ_1:22;
            then Sum sf = 0.L by A44,VECTSP_1:36;
            hence s1.i = 0.L + -(0.L) by A30,A31,A32,A42,A46,PARTFUN1:def 8
              .= 0.L + 0.L by RLVECT_1:25
              .= 0.L by RLVECT_1:def 7;
          end;
          suppose
A48:        i = k';
            (i+1)-'(degn+1) = i + 1 - (degn + 1) by A41,XREAL_0:def 2
              .= len s -' 1 by A9,A48,XREAL_0:def 2;
            then Sum sf = f.(len f-'1) * ((s.(len s-'1))" * s.(len s-'1))
            by A44,GROUP_1:def 4
              .= f.(len f-'1) * 1_L by A10,VECTSP_1:def 22
              .= f.(len f-'1) by VECTSP_1:def 13
              .= f.(len f-1) by A12,XREAL_0:def 2
              .= f/.(len f-1) by A13,PARTFUN1:def 8;
            hence s1.i = f/.(len f-1)+-(f/.(len f-1))
            by A30,A31,A32,A48,PARTFUN1:def 8
              .= 0.L by RLVECT_1:16;
          end;
        end;
        then k' is_at_least_length_of s1 by ALGSEQ_1:def 3;
        then len(s1) <= k' by ALGSEQ_1:def 4;
        then len(s1) < k by A14,NAT_1:13;
        hence contradiction by A3,A25;
      end;
      hence thesis by A5,A6;
    end;
  end;
  uniqueness
  proof
    let f1,f2 be Polynomial of L;
    given t1 being Polynomial of L such that
A49: p = f1*'s+t1 & deg t1 < deg s;
    given t2 being Polynomial of L such that
A50: p = f2*'s+t2 & deg t2 < deg s;
    f2 *' s = f2 *' s + 0_.(L) by POLYNOM3:29
      .= f2 *' s + (t2 - t2) by POLYNOM3:30
      .= (f1 *' s + t1) + -t2 by A49,A50,POLYNOM3:26;
    then
A51: f2 *' s - f1 *' s = (f1 *' s + (t1 + -t2)) + -(f1 *' s) by POLYNOM3:26
      .= (t1 + -t2) + (f1 *' s -(f1 *' s)) by POLYNOM3:26
      .= (t1 + -t2) + 0_.(L) by POLYNOM3:30
      .= t1 - t2 by POLYNOM3:29;
A52: (f2 - f1) *' s = f2 *' s + (-f1) *' s by POLYNOM3:33
      .= f2 *' s - f1*' s by Th12;
    now
      assume
A53:  f1 <> f2;
A54:  now
        assume f2 - f1 = 0_.(L);
        then f1 = (f2 + -f1) + f1 by POLYNOM3:29
          .= f2 + (f1 - f1) by POLYNOM3:26
          .= f2 + 0_.(L) by POLYNOM3:30;
        hence contradiction by A53,POLYNOM3:29;
      end;
      then reconsider d = deg(f2-f1), degs = deg(s) as Nat by A1,Lm9;
A55:  deg(t1-t2) = d + degs by A1,A51,A52,A54,Th23;
      deg(t1-t2) <= max(deg(t1),deg(-t2)) by Th22;
      then
A56:  deg(t1-t2) <= max(deg(t1),deg(t2)) by POLYNOM4:11;
      deg(t1-t2) < degs
      proof
        per cases by XXREAL_0:16;
        suppose max(deg(t1),deg(t2))=deg(t1);
          hence thesis by A49,A56,XXREAL_0:2;
        end;
        suppose max(deg(t1),deg(t2))=deg(t2);
          hence thesis by A50,A56,XXREAL_0:2;
        end;
      end;
      hence contradiction by A55,NAT_1:11;
    end;
    hence thesis;
  end;
end;

definition
  let L be Abelian add-associative right_zeroed right_complementable
  well-unital associative commutative distributive
  almost_left_invertible (non empty doubleLoopStr);
  let p,s be Polynomial of L;
  func p mod s -> Polynomial of L equals

  p - (p div s) *' s;
  coherence;
end;

definition
  let L be Abelian add-associative right_zeroed right_complementable
  well-unital associative commutative distributive
  almost_left_invertible (non empty doubleLoopStr);
  let p,s be Polynomial of L;
  pred s divides p means
  :Def7:
  p mod s = 0_.(L);
end;

theorem Th34:
  for L being Abelian add-associative right_zeroed right_complementable
  well-unital associative commutative distributive
  almost_left_invertible (non empty doubleLoopStr)
  for p,s being Polynomial of L st s <> 0_.(L)
  holds s divides p iff ex t being Polynomial of L st t *' s = p
proof
  let L be Abelian add-associative right_zeroed right_complementable
  well-unital associative commutative distributive
  almost_left_invertible (non empty doubleLoopStr);
  let p,s be Polynomial of L;
  assume
A1: s <> 0_.(L);
A2: now
    assume
A3: s divides p;
    consider t being Polynomial of L such that
A4: p = (p div s) *' s + t & deg t < deg s by A1,Def5;
    p mod s = t + ((p div s) *' s - ((p div s) *' s)) by A4,POLYNOM3:26
      .= t + 0_.(L) by POLYNOM3:30
      .= t by POLYNOM3:29;
    then t = 0_.(L) by A3,Def7;
    then p = (p div s) *' s by A4,POLYNOM3:29;
    hence ex t being Polynomial of L st t *' s = p;
  end;
  now
    given t being Polynomial of L such that
A5: t *' s = p;
A6: p = t *' s + 0_.(L) by A5,POLYNOM3:29;
    deg(s) - 0 > 0 - 1 by A1,Lm9;
    then deg 0_.(L) < deg s by Th20;
    then p div s = t by A6,Def5;
    then p mod s = 0_.(L) by A5,POLYNOM3:30;
    hence s divides p by Def7;
  end;
  hence thesis by A2;
end;

theorem
  for L being Abelian add-associative right_zeroed right_complementable
  well-unital associative commutative distributive
  almost_left_invertible non degenerated (non empty doubleLoopStr)
  for p being Polynomial of L
  for z being Element of L st z is_a_root_of p holds rpoly(1,z) divides p
proof
  let L be Abelian add-associative right_zeroed right_complementable
  well-unital associative commutative distributive almost_left_invertible
  non degenerated (non empty doubleLoopStr), p be Polynomial of L;
  let z be Element of L;
  assume z is_a_root_of p;
  then consider s being Polynomial of L such that
A1: p = rpoly(1,z) *' s by Th33;
  rpoly(1,z).1 = 1_L by Lm11;
  then rpoly(1,z) <> 0_.(L) by FUNCOP_1:13;
  hence thesis by A1,Th34;
end;

theorem
  for L being Abelian add-associative right_zeroed right_complementable
  well-unital associative commutative distributive
  almost_left_invertible non degenerated (non empty doubleLoopStr)
  for p being Polynomial of L
  for z being Element of L st p <> 0_.(L) & z is_a_root_of p
  holds deg(p div rpoly(1,z)) = deg(p) - 1
proof
  let L be Abelian add-associative right_zeroed right_complementable
  well-unital associative commutative distributive
  almost_left_invertible non degenerated (non empty doubleLoopStr),
  p be Polynomial of L;
  let z be Element of L;
  assume
A1: p <> 0_.(L) & z is_a_root_of p;
  then consider s being Polynomial of L such that
A2: p = rpoly(1,z) *' s by Th33;
A3: s <> 0_.(L) by A1,A2,POLYNOM3:35;
A4: rpoly(1,z) <> 0_.(L) by A1,A2,POLYNOM4:5;
  then
A5: deg p = deg(rpoly(1,z)) + deg(s) by A2,A3,Th23
    .= 1 + deg(s) by Th27;
  ex t being Polynomial of L st
  p = s *' rpoly(1,z) + t & deg t < deg rpoly(1,z)
  proof
    take t = 0_.(L); thus s *' rpoly(1,z) + t = p by A2,POLYNOM3:29;
    deg t = -1 by Th20;
    hence thesis by Th27;
  end;
  hence thesis by A4,A5,Def5;
end;

begin :: Schur's Theorem

definition
  let f be Polynomial of F_Complex;
  attr f is Hurwitz means
  :Def8:
  for z being Element of F_Complex st z is_a_root_of f holds Re(z) < 0;
end;

theorem
  0_.(F_Complex) is non Hurwitz
proof
  eval(0_.(F_Complex),1_F_Complex) = 0.F_Complex by POLYNOM4:20;
  then 1_F_Complex is_a_root_of 0_.(F_Complex) by POLYNOM5:def 6;
  hence thesis by Def8,COMPLEX1:15,COMPLFLD:10;
end;

theorem
  for x being Element of F_Complex st x <> 0.F_Complex
  holds x * 1_.(F_Complex) is Hurwitz
proof
  let x be Element of F_Complex;
  assume
A1: x <> 0.F_Complex;
  set p = x * 1_.(F_Complex);
  now
    let z be Element of F_Complex;
    assume z is_a_root_of p;
    then
A2: eval(p,z) = 0.F_Complex by POLYNOM5:def 6;
    eval(p,z) = x * eval(1_.(F_Complex),z) by POLYNOM5:31
      .= x * 1_F_Complex by POLYNOM4:21;
    hence Re(z) < 0 by A1,A2,VECTSP_1:def 13;
  end;
  hence thesis by Def8;
end;

theorem Th39:
  for x,z being Element of F_Complex st x <> 0.F_Complex
  holds x * rpoly(1,z) is Hurwitz iff Re(z) < 0
proof
  let x,z be Element of F_Complex;
  assume
A1: x <> 0.F_Complex;
  set p = x * rpoly(1,z);
A2: now
    assume
A3: x * rpoly(1,z) is Hurwitz;
    eval(p,z) = x * eval(rpoly(1,z),z) by POLYNOM5:31
      .= x * (z - z) by Th29
      .= x * 0.F_Complex by RLVECT_1:28
      .= 0.F_Complex by VECTSP_1:36;
    then z is_a_root_of p by POLYNOM5:def 6;
    hence Re(z) < 0 by A3,Def8;
  end;
  now
    assume
A4: Re(z) < 0;
    now
      let y be Element of F_Complex;
      assume y is_a_root_of p;
      then 0.F_Complex = eval(p,y) by POLYNOM5:def 6
        .= x * eval(rpoly(1,z),y) by POLYNOM5:31
        .= x * (y - z) by Th29;
      then y - z = 0.F_Complex by A1,VECTSP_1:44;
      hence Re(y) < 0 by A4,RLVECT_1:35;
    end;
    hence p is Hurwitz by Def8;
  end;
  hence thesis by A2;
end;

theorem Th40:
  for f being Polynomial of F_Complex
  for z being Element of F_Complex st z <> 0.F_Complex
  holds f is Hurwitz iff z * f is Hurwitz
proof
  let f be Polynomial of F_Complex;
  let z be Element of F_Complex;
  assume
A1: z <> 0.F_Complex;
A2: now
    assume
A3: f is Hurwitz;
    now
      let x be Element of F_Complex;
      assume x is_a_root_of (z*f);
      then 0.F_Complex = eval(z*f,x) by POLYNOM5:def 6
        .= z * eval(f,x) by POLYNOM5:31;
      then eval(f,x) = 0.F_Complex by A1,VECTSP_1:44;
      then x is_a_root_of f by POLYNOM5:def 6;
      hence Re(x) < 0 by A3,Def8;
    end;
    hence z*f is Hurwitz by Def8;
  end;
  now
    assume
A4: z*f is Hurwitz;
    now
      let x be Element of F_Complex;
      assume
A5:   x is_a_root_of f;
      eval(z*f,x) = z * eval(f,x) by POLYNOM5:31
        .= z * 0.F_Complex by A5,POLYNOM5:def 6
        .= 0.F_Complex by VECTSP_1:36;
      then x is_a_root_of (z*f) by POLYNOM5:def 6;
      hence Re(x) < 0 by A4,Def8;
    end;
    hence f is Hurwitz by Def8;
  end;
  hence thesis by A2;
end;

Lm13: for f,g,h being Polynomial of F_Complex st f = g *' h
for x being Element of F_Complex
holds (x is_a_root_of g or x is_a_root_of h) implies x is_a_root_of f
proof
  let f,g,h be Polynomial of F_Complex;
  assume
A1: f = g *' h;
  let x be Element of F_Complex;
  assume
A2: x is_a_root_of g or x is_a_root_of h;
A3: eval(f,x) = eval(g,x) * eval(h,x) by A1,POLYNOM4:27;
  per cases by A2;
  suppose x is_a_root_of g;
    then eval(g,x) = 0.F_Complex by POLYNOM5:def 6;
    then eval(f,x) = 0.F_Complex by A3,VECTSP_1:39;
    hence thesis by POLYNOM5:def 6;
  end;
  suppose x is_a_root_of h;
    then eval(h,x) = 0.F_Complex by POLYNOM5:def 6;
    then eval(f,x) = 0.F_Complex by A3,VECTSP_1:36;
    hence thesis by POLYNOM5:def 6;
  end;
end;

theorem Th41:
  for f,g being Polynomial of F_Complex
  holds f *' g is Hurwitz iff (f is Hurwitz & g is Hurwitz)
proof
  let f,g be Polynomial of F_Complex;
A1: now
    assume
A2: f*'g is Hurwitz;
    now
      let z be Element of F_Complex;
      assume z is_a_root_of f;
      then z is_a_root_of (f*'g) by Lm13;
      hence Re(z) < 0 by A2,Def8;
    end;
    hence f is Hurwitz by Def8;
    now
      let z be Element of F_Complex;
      assume z is_a_root_of g;
      then z is_a_root_of (f*'g) by Lm13;
      hence Re(z) < 0 by A2,Def8;
    end;
    hence g is Hurwitz by Def8;
  end;
  now
    assume
A3: f is Hurwitz & g is Hurwitz;
    now
      let z be Element of F_Complex;
      assume z is_a_root_of f*'g;
      then
A4:   0.F_Complex = eval(f*'g,z) by POLYNOM5:def 6
        .= eval(f,z) * eval(g,z) by POLYNOM4:27;
      per cases by A4,VECTSP_1:44;
      suppose eval(f,z)=0.F_Complex;
        then z is_a_root_of f by POLYNOM5:def 6;
        hence Re(z) < 0 by A3,Def8;
      end;
      suppose eval(g,z)=0.F_Complex;
        then z is_a_root_of g by POLYNOM5:def 6;
        hence Re(z) < 0 by A3,Def8;
      end;
    end;
    hence f*'g is Hurwitz by Def8;
  end;
  hence thesis by A1;
end;

definition
  let f be Polynomial of F_Complex;
  func f*' -> Polynomial of F_Complex means
  :Def9:
  for i being Element of NAT holds
  it.i = power(F_Complex).(-1_F_Complex,i) * (f.i)*';
  existence
  proof
    defpred P[set,set] means ex n being Element of NAT st n = $1 &
    $2 = power(F_Complex).(-1_F_Complex,n) * (f.n)*';
A1: for x being set st x in NAT
    ex y being set st y in the carrier of F_Complex & P[x,y]
    proof
      let u be set;
      assume u in NAT;
      then reconsider u' = u as Element of NAT;
      take power(F_Complex).(-1_F_Complex,u') * (f.u')*';
      thus thesis;
    end;
    consider g being Function of NAT,the carrier of F_Complex such that
A2: for x being set st x in NAT holds P[x,g.x] from FUNCT_2:sch 1(A1);
    reconsider g as sequence of F_Complex;
    ex n being Nat st for i being Nat st i >= n holds g.i = 0.F_Complex
    proof
      take n = len f;
      now
        let i be Nat;
        reconsider i1=i as Element of NAT by ORDINAL1:def 13;
        assume
A3:     i >= n;
        consider m being Element of NAT such that
A4:     m = i1 & g.i1 = power(F_Complex).(-1_F_Complex,m) * (f.m)*' by A2;
        thus g.i = power(F_Complex).(-1_F_Complex,i1) * (0.F_Complex)*'
        by A3,A4,ALGSEQ_1:22
          .= 0.F_Complex by COMPLFLD:83,VECTSP_1:36;
      end;
      hence thesis;
    end;
    then reconsider p = g as AlgSequence of F_Complex by ALGSEQ_1:def 2;
    take p;
    now
      let i be Element of NAT;
      consider n being Element of NAT such that
A5:   n = i & p.i = power(F_Complex).(-1_F_Complex,n) * (f.n)*' by A2;
      thus p.i = power(F_Complex).(-1_F_Complex,i) * (f.i)*' by A5;
    end;
    hence thesis;
  end;
  uniqueness
  proof
    let z1,z2 be AlgSequence of F_Complex;
    assume
A6: for i being Element of NAT holds
    z1.i = power(F_Complex).(-1_F_Complex,i) * (f.i)*';
    assume
A7: for i being Element of NAT holds
    z2.i = power(F_Complex).(-1_F_Complex,i) * (f.i)*';
A8: dom z1 = NAT by FUNCT_2:def 1
      .= dom z2 by FUNCT_2:def 1;
    now
      let x be set;
      assume x in dom z1;
      then reconsider x' = x as Element of NAT;
      thus z1.x = power(F_Complex).(-1_F_Complex,x') * (f.x')*' by A6
        .= z2.x by A7;
    end;
    hence z1 = z2 by A8,FUNCT_1:9;
  end;
end;

theorem Th42:
  for f being Polynomial of F_Complex holds deg(f*') = deg(f)
proof
  let f be Polynomial of F_Complex;
A1: for k being Nat holds f.k = 0.F_Complex iff (f*').k = 0.F_Complex
  proof
    let k be Nat;
    reconsider k1 = k as Element of NAT by ORDINAL1:def 13;
    hereby
      assume f.k = 0.F_Complex;
      hence (f*').k = power(F_Complex).(-1_F_Complex,k1) * 0.F_Complex by Def9,
      COMPLFLD:83
        .= 0.F_Complex by VECTSP_1:36;
    end;
    assume (f*').k = 0.F_Complex;
    then
A2: 0.F_Complex = power(F_Complex).(-1_F_Complex,k1) * ((f.k)*') by Def9;
    power(F_Complex).(-1_F_Complex,k1) <> 0.F_Complex by Th2;
    then (f.k)*' = 0.F_Complex by A2,VECTSP_1:44;
    hence thesis by COMPLEX1:113,COMPLFLD:9;
  end;
  now
    let i be Nat;
    assume i >= len f;
    then f.i = 0.F_Complex by ALGSEQ_1:22;
    hence (f*').i = 0.F_Complex by A1;
  end;
  then len f is_at_least_length_of (f*') by ALGSEQ_1:def 3;
  then
A3: len f >= len (f*') by ALGSEQ_1:def 4;
  now
    assume
A4: len f > len(f*');
    then len f + 1 > 0 + 1 by XREAL_1:8;
    then len f >= 1 by NAT_1:13;
    then reconsider l = len(f)-1 as Element of NAT by INT_1:18;
    l + 1 > len(f*') by A4;
    then l >= len(f*') by NAT_1:13;
    then
A5: (f*').l = 0.F_Complex by ALGSEQ_1:22;
    len f = l + 1;
    then f.l <> 0.F_Complex by ALGSEQ_1:25;
    hence contradiction by A1,A5;
  end;
  hence thesis by A3,XXREAL_0:1;
end;

theorem Th43:
  for f being Polynomial of F_Complex holds (f*')*' = f
proof
  let f be Polynomial of F_Complex;
  set g = (f*')*';
A1: dom g = NAT by FUNCT_2:def 1
    .= dom f by FUNCT_2:def 1;
  now
    let k' be set;
    assume k' in dom g;
    then reconsider k = k' as Element of NAT;
    g.k = power(F_Complex).(-1_F_Complex,k) * ((f*').k)*' by Def9
      .= power(F_Complex).(-1_F_Complex,k) *
    (power(F_Complex).(-1_F_Complex,k) * (f.k)*')*' by Def9
      .= power(F_Complex).(-1_F_Complex,k) *
    ((power(F_Complex).(-1_F_Complex,k))*' * ((f.k)*')*') by COMPLFLD:90
      .= (power(F_Complex).(-1_F_Complex,k) *
    (power(F_Complex).(-1_F_Complex,k))*') * f.k
      .= (power(F_Complex).(-1_F_Complex,k) *
    power(F_Complex).((-1_F_Complex)*',k)) * f.k by Th5
      .= (power(F_Complex).(-1_F_Complex,k) *
    power(F_Complex).(-1_F_Complex,k)) * f.k by Lm2,Lm3
      .= power(F_Complex).(-1_F_Complex,k+k) * f.k by Th3
      .= power(F_Complex).(-1_F_Complex,2*k) * f.k
      .= 1_F_Complex * f.k by Th4;
    hence g.k' = f.k' by VECTSP_1:def 19;
  end;
  hence thesis by A1,FUNCT_1:9;
end;

theorem Th44:
  for f being Polynomial of F_Complex
  for z being Element of F_Complex holds (z * f)*' = (z*') * (f*')
proof
  let f be Polynomial of F_Complex;
  let x be Element of F_Complex;
  set g1 = x * f, g2 = (x*') * (f*');
A1: dom(g1*') = NAT by FUNCT_2:def 1
    .= dom g2 by FUNCT_2:def 1;
  now
    let k' be set;
    assume k' in dom(g1*');
    then reconsider k = k' as Element of NAT;
    g1.k = x * f.k by POLYNOM5:def 3;
    then (g1*').k = power(F_Complex).(-1_F_Complex,k) * (x * f.k)*' by Def9
      .= power(F_Complex).(-1_F_Complex,k) * ((x*') * ((f.k)*'))
    by COMPLFLD:90
      .= (x*') * (power(F_Complex).(-1_F_Complex,k) * ((f.k)*'))
      .= (x*') * (f*').k by Def9;
    hence (g1*').k' = g2.k' by POLYNOM5:def 3;
  end;
  hence thesis by A1,FUNCT_1:9;
end;

theorem Th45:
  for f being Polynomial of F_Complex holds (-f)*' = -(f*')
proof
  let f be Polynomial of F_Complex;
  set h1 = -f;
A1: dom(h1*') = NAT by FUNCT_2:def 1
    .= dom(-(f*')) by FUNCT_2:def 1;
  now
    let k' be set;
    assume k' in dom(h1*');
    then reconsider k = k' as Element of NAT;
    h1.k = -f.k by BHSP_1:def 10;
    then (h1*').k = power(F_Complex).(-1_F_Complex,k) * (-f.k)*' by Def9
      .= power(F_Complex).(-1_F_Complex,k) * (-((f.k)*')) by COMPLFLD:88
      .= -(power(F_Complex).(-1_F_Complex,k) * ((f.k)*')) by VECTSP_1:40
      .= -((f*').k) by Def9;
    hence (h1*').k' = (-(f*')).k' by BHSP_1:def 10;
  end;
  hence thesis by A1,FUNCT_1:9;
end;

theorem Th46:
  for f,g being Polynomial of F_Complex holds (f + g)*' = (f*') + (g*')
proof
  let f,g be Polynomial of F_Complex;
  set h1 = f+g;
A1: dom(h1*') = NAT by FUNCT_2:def 1
    .= dom((f*') + (g*')) by FUNCT_2:def 1;
  now
    let k' be set;
    assume k' in dom(h1*');
    then reconsider k = k' as Element of NAT;
    h1.k = f.k + g.k by NORMSP_1:def 5;
    then (h1*').k = power(F_Complex).(-1_F_Complex,k) * (f.k + g.k)*' by Def9
      .= power(F_Complex).(-1_F_Complex,k) * ((f.k)*' + (g.k)*') by COMPLFLD:87
      .= (power(F_Complex).(-1_F_Complex,k) * (f.k)*') +
    (power(F_Complex).(-1_F_Complex,k) * (g.k)*')
      .= (f*').k + (power(F_Complex).(-1_F_Complex,k) * (g.k)*') by Def9
      .= (f*').k + (g*').k by Def9;
    hence (h1*').k' = ((f*') + (g*')).k' by NORMSP_1:def 5;
  end;
  hence thesis by A1,FUNCT_1:9;
end;

theorem Th47:
  for f,g being Polynomial of F_Complex holds (f *' g)*' = (f*') *' (g*')
proof
  let f,g be Polynomial of F_Complex;
  set h1 = f*'g;
A1: dom(h1*') = NAT by FUNCT_2:def 1
    .= dom((f*') *' (g*')) by FUNCT_2:def 1;
  now
    let k' be set;
    assume k' in dom(h1*');
    then reconsider k = k' as Element of NAT;
    consider s being FinSequence of F_Complex such that
A2: len s = k+1 & h1.k = Sum s &
    for j be Element of NAT st j in dom s holds s.j = f.(j-'1) * g.(k+1-'j)
    by POLYNOM3:def 11;
    consider t being FinSequence of F_Complex such that
A3: len t = k+1 & ((f*') *' (g*')).k = Sum t & for j be Element of NAT
    st j in dom t holds t.j = (f*').(j-'1) * (g*').(k+1-'j)
    by POLYNOM3:def 11;
A4: dom s = Seg(len t) by A2,A3,FINSEQ_1:def 3
      .= dom t by FINSEQ_1:def 3;
A5: now
      let j be Element of NAT;
      assume
A6:   j in dom t;
      then j in Seg(len t) by FINSEQ_1:def 3;
      then 1 <= j & j <= k+1 by A3,FINSEQ_1:3;
      then
A7:   k + 1 - j >= j - j & j - 1 >= 1 - 1 by XREAL_1:11;
      then
A8:   (j-'1) + (k+1-'j) = j-1 + (k+1-'j) by XREAL_0:def 2
        .= j - 1 + (k + 1 - j) by A7,XREAL_0:def 2
        .= k;
      s.j = s/.j by A4,A6,PARTFUN1:def 8;
      then
A9:   (s/.j)*' = (f.(j-'1) * g.(k+1-'j))*' by A2,A4,A6;
      thus t.j = (f*').(j-'1) * (g*').(k+1-'j) by A3,A6
        .= (power(F_Complex).(-1_F_Complex,j-'1) * (f.(j-'1))*') *
      (g*').(k+1-'j) by Def9
        .= (power(F_Complex).(-1_F_Complex,j-'1) * (f.(j-'1))*') *
      (power(F_Complex).(-1_F_Complex,k+1-'j) * (g.(k+1-'j))*') by Def9
        .= (power(F_Complex).(-1_F_Complex,j-'1) *
      power(F_Complex).(-1_F_Complex,k+1-'j)) *
      (((f.(j-'1))*') * (g.(k+1-'j))*')
        .= power(F_Complex).(-1_F_Complex,k) *
      (((f.(j-'1))*') * (g.(k+1-'j))*') by A8,Th3
        .= power(F_Complex).(-1_F_Complex,k) * (s/.j)*' by A9,COMPLFLD:90;
    end;
    defpred P[set,set] means $2 = (s/.$1)*';
A10: for j being Nat st j in Seg(len s)
    ex x being Element of F_Complex st P[j,x];
    consider u being FinSequence of F_Complex such that
A11: dom u = Seg(len s) & for j being Nat
    st j in Seg(len s) holds P[j,u.j] from FINSEQ_1:sch 5(A10);
A12: len u = len s &
    for j be Element of NAT st j in dom u holds u/.j = (s/.j)*'
    proof
      thus len u = len s by A11,FINSEQ_1:def 3;
      now
        let j be Element of NAT;
        assume
A13:    j in dom u;
        hence u/.j = u.j by PARTFUN1:def 8
          .= (s/.j)*' by A11,A13;
      end;
      hence thesis;
    end;
    then
A14: dom u = Seg(len t) by A2,A3,FINSEQ_1:def 3
      .= dom t by FINSEQ_1:def 3;
A15: power(F_Complex).(-1_F_Complex,k) * u = t
    proof
      set b = power(F_Complex).(-1_F_Complex,k);
      set a = b * u;
A16:  dom a = dom u by POLYNOM1:def 2;
      now
        let j be Nat;
        assume
A17:    j in dom t;
        hence a.j = a/.j by A14,A16,PARTFUN1:def 8
          .= b * u/.j by A14,A17,POLYNOM1:def 2
          .= b * (s/.j)*' by A12,A14,A17
          .= t.j by A5,A17;
      end;
      hence thesis by A14,A16,FINSEQ_1:17;
    end;
    Sum u = (Sum s)*' by A12,Th6;
    then (h1*').k = power(F_Complex).(-1_F_Complex,k) * (Sum u) by A2,Def9
      .= ((f*') *' (g*')).k by A3,A15,Th8;
    hence (h1*').k' = ((f*') *' (g*')).k';
  end;
  hence thesis by A1,FUNCT_1:9;
end;

Lm14: for x,xv being Element of COMPLEX
for u,v,uv,vv being Element of REAL st x = u+v*<i> & xv = uv+vv*<i>
holds |.x + (xv*').|^2 - |.x - xv.|^2 = 4 * u * uv
proof
  let x,xv be Element of COMPLEX, u,v,uv,vv be Element of REAL;
  assume
A1: x = u+v*<i> & xv = uv+vv*<i>;
A2: |.(x + xv*').|
  = sqrt((Re(x) + Re(xv*'))^2 + (Im (x + xv*'))^2) by COMPLEX1:19
    .= sqrt((u + Re(xv*'))^2 + (Im (x + xv*'))^2) by A1,COMPLEX1:28
    .= sqrt((u + Re(xv))^2 + (Im (x + xv*'))^2) by COMPLEX1:112
    .= sqrt((u + uv)^2 + (Im (x + xv*'))^2) by A1,COMPLEX1:28
    .= sqrt((u + uv)^2 + (Im(x) + Im(xv*'))^2) by COMPLEX1:19
    .= sqrt((u + uv)^2 + (v + Im(xv*'))^2) by A1,COMPLEX1:28
    .= sqrt((u + uv)^2 + (v + -Im(xv))^2) by COMPLEX1:112
    .= sqrt((u + uv)^2 + (v + -vv)^2) by A1,COMPLEX1:28;
  (u + uv)^2 >= 0 & (v + -vv)^2 >= 0 by XREAL_1:65;
  then (u + uv)^2 + (v + -vv)^2 >= 0+0;
  then
A3: |.(x + xv*').|^2 = (u + uv)^2 + (v + -vv)^2 by A2,SQUARE_1:def 4;
A4: |.(x - xv).| = sqrt(((Re x)-(Re xv))^2 + (Im (x - xv))^2) by COMPLEX1:48
    .= sqrt((u-(Re xv))^2 + (Im (x - xv))^2) by A1,COMPLEX1:28
    .= sqrt((u-uv)^2 + (Im (x - xv))^2) by A1,COMPLEX1:28
    .= sqrt((u-uv)^2 + (Im(x) - Im(xv))^2) by COMPLEX1:48
    .= sqrt((u-uv)^2 + (v - Im(xv))^2) by A1,COMPLEX1:28
    .= sqrt((u-uv)^2 + (v-vv)^2) by A1,COMPLEX1:28;
  (u - uv)^2 >= 0 & (v -vv)^2 >= 0 by XREAL_1:65;
  then
A5: (u - uv)^2 + (v -vv)^2 >= 0+0;
  ((u + uv)^2 + (v + -vv)^2) - ((u - uv)^2 + (v-vv)^2) = 4 * u * uv;
  hence thesis by A3,A4,A5,SQUARE_1:def 4;
end;

Lm15: for x,xv being Element of COMPLEX
for u,v,uv,vv being Element of REAL st x = u+v*<i> & xv = uv+vv*<i>
& uv < 0 holds (u < 0 implies |.(x - xv).| < |.(x + xv*').|) &
(u > 0 implies |.(x - xv).| > |.(x + xv*').|) &
(u = 0 implies |.(x - xv).| = |.(x + xv*').|)
proof
  let x,xv be Element of COMPLEX, u,v,uv,vv be Element of REAL;
  assume
A1: x = u+v*<i> & xv = uv+vv*<i> & uv < 0;
  now
    assume u < 0;
    then u * uv > 0 * uv by A1;
    then 4 * (u * uv) > 4 * 0;
    then 4 * u * uv > 0;
    then |.x + (xv*').|^2 - |.x - xv.|^2 > 0 by A1,Lm14;
    then
A2: (|.x + (xv*').|^2 - |.x - xv.|^2) + |.x - xv.|^2 >
    0 + |.x - xv.|^2 by XREAL_1:8;
    0 <= |.x + (xv*').| & 0 <= |.x - xv.| by COMPLEX1:132;
    hence |.(x + xv*').| > |.(x - xv).| by A2,XREAL_1:68;
  end;
  hence u < 0 implies |.(x - xv).| < |.(x + xv*').|;
  now
    assume u > 0;
    then u * uv < 0 * uv by A1;
    then 4 * (u * uv) < 4 * 0;
    then 4 * u * uv < 0;
    then |.x + (xv*').|^2 - |.x - xv.|^2 < 0 by A1,Lm14;
    then
A3: (|.x + (xv*').|^2 - |.x - xv.|^2) + |.x - xv.|^2 <
    0 + |.x - xv.|^2 by XREAL_1:8;
    0 <= |.x + (xv*').| & 0 <= |.x - xv.| by COMPLEX1:132;
    hence |.(x + xv*').| < |.(x - xv).| by A3,XREAL_1:68;
  end;
  hence u > 0 implies |.(x - xv).| > |.(x + xv*').|;
  now
    assume u = 0;
    then 4 * u * uv = 0;
    then
A4: |.x + (xv*').|^2 - |.x - xv.|^2 = 0 by A1,Lm14;
    now
      assume
A5:   |.(x - xv).| <> |.(x + xv*').|;
      per cases by A5,XXREAL_0:1;
      suppose |.(x - xv).| > |.(x + xv*').|;
        hence contradiction by A4,COMPLEX1:132,SQUARE_1:78;
      end;
      suppose |.(x - xv).| < |.(x + xv*').|;
        hence contradiction by A4,COMPLEX1:132,SQUARE_1:78;
      end;
    end;
    hence |.(x - xv).| = |.(x + xv*').|;
  end;
  hence thesis;
end;

theorem Th48:
  for x,z being Element of F_Complex holds eval(rpoly(1,z)*',x) = -x - (z*')
proof
  let x,z be Element of F_Complex;
  set p = rpoly(1,z)*';
  consider F be FinSequence of F_Complex such that
A1: eval(p,x) = Sum F & len F = len p & for n be Element of NAT st n in dom F
  holds F.n = p.(n-'1) * (power F_Complex).(x,n-'1) by POLYNOM4:def 2;
A2: deg p = deg rpoly(1,z) by Th42
    .= 1 by Th27;
  then
A3: len p = 1 + 1;
A4: F = <*F.1,F.2*> by A1,A2,FINSEQ_1:61
    .= <*F.1*>^<*F.2*>;
A5: 1-'1 = 1-1 by XREAL_0:def 2;
A6: rpoly(1,z).0 = -power(F_Complex).(z,1+0) by Lm11
    .= -(power(F_Complex).(z,0) * z) by GROUP_1:def 8
    .= -(1_F_Complex * z) by GROUP_1:def 8
    .= -z by VECTSP_1:def 19;
  1 in Seg(len F) by A1,A3;
  then 1 in dom F by FINSEQ_1:def 3;
  then
A7: F.1 = p.0 * (power F_Complex).(x,0) by A1,A5
    .= p.0 * 1_F_Complex by GROUP_1:def 8
    .= p.0 by VECTSP_1:def 13
    .= power(F_Complex).(-1_F_Complex,0) * (-z)*' by A6,Def9
    .= 1_F_Complex * (-z)*' by GROUP_1:def 8
    .= (-z)*' by VECTSP_1:def 19
    .= -(z*') by COMPLFLD:88;
A8: 2-'1 = 2-1 by XREAL_0:def 2;
  2 in Seg(len F) by A1,A2;
  then 2 in dom F by FINSEQ_1:def 3;
  then F.2 = p.1 * (power F_Complex).(x,1+0) by A1,A8
    .= p.1 * ((power F_Complex).(x,0) * x) by GROUP_1:def 8
    .= p.1 * (1_F_Complex * x) by GROUP_1:def 8
    .= p.1 * x by VECTSP_1:def 19
    .= (power(F_Complex).(-1_F_Complex,1) * (rpoly(1,z).1)*') * x by Def9
    .= (power(F_Complex).(-1_F_Complex,1) * (1_F_Complex)) * x by Lm11,
  COMPLFLD:85
    .= power(F_Complex).(-1_F_Complex,1+0) * x by VECTSP_1:def 13
    .= (power(F_Complex).(-1_F_Complex,0) * (-1_F_Complex)) * x
  by GROUP_1:def 8
    .= (1_F_Complex * (-1_F_Complex)) * x by GROUP_1:def 8
    .= (-(1_F_Complex)) * x by VECTSP_1:def 13
    .= -(1_F_Complex * x) by VECTSP_1:41
    .= -x by VECTSP_1:def 19;
  hence eval(p,x) = Sum(<*-(z*')*>) + Sum(<*-x*>) by A1,A4,A7,RLVECT_1:58
    .= Sum(<*-(z*')*>) + -x by RLVECT_1:61
    .= -(z*') + -x by RLVECT_1:61
    .= -x - (z*') by RLVECT_1:def 12;
end;

theorem Th49:
  for f being Polynomial of F_Complex st f is Hurwitz
  for x being Element of F_Complex st Re(x) >= 0 holds 0 < |.eval(f,x).|
proof
  let f be Polynomial of F_Complex;
  assume
A1: f is Hurwitz;
  let x be Element of F_Complex;
  assume
A2: Re(x) >= 0;
  now
    assume eval(f,x) = 0.F_Complex;
    then x is_a_root_of f by POLYNOM5:def 6;
    hence contradiction by A1,A2,Def8;
  end;
  hence thesis by COMPLEX1:133,COMPLFLD:9;
end;

theorem Th50:
  for f being Polynomial of F_Complex st deg(f) >= 1 & f is Hurwitz
  for x being Element of F_Complex
  holds (Re(x) < 0 implies |.eval(f,x).| < |.eval(f*',x).|) &
  (Re(x) > 0 implies |.eval(f,x).| > |.eval(f*',x).|) &
  (Re(x) = 0 implies |.eval(f,x).| = |.eval(f*',x).|)
proof
  let f be Polynomial of F_Complex;
  assume
A1: deg(f) >= 1 & f is Hurwitz;
  let x be Element of F_Complex;
  defpred P[Nat] means
  for f being Polynomial of F_Complex st deg(f) >= 1 & f is Hurwitz
  & deg(f) = $1 for x being Element of F_Complex
  holds (Re(x) < 0 implies |.eval(f,x).| < |.eval(f*',x).|) &
  (Re(x) > 0 implies |.eval(f,x).| > |.eval(f*',x).|) &
  (Re(x) = 0 implies |.eval(f,x).| = |.eval(f*',x).|);
A2: P[0];
A3: now
    let y,z be Element of F_Complex;
    assume
A4: rpoly(1,z) is Hurwitz;
    assume
A5: Re(y) < 0;
    z is_a_root_of rpoly(1,z) by Th30;
    then
A6: Re(z) < 0 by A4,Def8;
    reconsider y' = y, z' = z as Element of COMPLEX by COMPLFLD:def 1;
A7: -y = -y' & -z = -z' by COMPLFLD:4;
    y - z = eval(rpoly(1,z),y) & eval(rpoly(1,z)*',y) = (-y) - (z*')
    by Th29,Th48;
    then
A8: y - z = eval(rpoly(1,z),y) &
    eval(rpoly(1,z)*',y) = (-y') - (z'*') by A7,COMPLFLD:5;
    y = Re(y) + Im(y) * <i> & z = Re(z) + Im(z) * <i> by COMPLEX1:29;
    then
A9: |.y' - z'.| < |.y' + (z'*').| by A5,A6,Lm15;
    |.(y' + (z'*')).| = |.-(y' + (z'*')).| by COMPLEX1:138;
    hence |.eval(rpoly(1,z),y).| < |.eval((rpoly(1,z))*',y).|
    by A8,A9,COMPLFLD:5;
  end;
A10: now
    let a,y,z be Element of F_Complex;
    assume
A11: rpoly(1,z) is Hurwitz & a <> 0.F_Complex;
    assume
A12: Re(y) < 0;
A13: |.a.| > 0 by A11,COMPLEX1:133,COMPLFLD:9;
A14: |.eval(a*rpoly(1,z),y).| = |.a * eval(rpoly(1,z),y).| by POLYNOM5:31
      .= |.a.| * |.eval(rpoly(1,z),y).| by COMPLEX1:151;
    |.a.| * |.eval((rpoly(1,z))*',y).|
    = |.a*'.| * |.eval((rpoly(1,z))*',y).| by COMPLEX1:139
      .= |.a*' * eval((rpoly(1,z))*',y).| by COMPLEX1:151
      .= |.eval((a*')*(rpoly(1,z))*',y).| by POLYNOM5:31
      .= |.eval((a*rpoly(1,z))*',y).| by Th44;
    hence |.eval(a*rpoly(1,z),y).|<|.eval((a*rpoly(1,z))*',y).|
    by A3,A11,A12,A13,A14,XREAL_1:70;
  end;
A15: now
    let y,z be Element of F_Complex;
    assume
A16: rpoly(1,z) is Hurwitz;
    assume
A17: Re(y) > 0;
    z is_a_root_of rpoly(1,z) by Th30;
    then
A18: Re(z) < 0 by A16,Def8;
    reconsider y' = y, z' = z as Element of COMPLEX by COMPLFLD:def 1;
A19: -y = -y' & -z = -z' by COMPLFLD:4;
    y - z = eval(rpoly(1,z),y) & eval(rpoly(1,z)*',y) = (-y) - (z*')
    by Th29,Th48;
    then
A20: y - z = eval(rpoly(1,z),y) &
    eval(rpoly(1,z)*',y) = (-y') - (z'*') by A19,COMPLFLD:5;
    y = Re(y) + Im(y) * <i> & z = Re(z) + Im(z) * <i> by COMPLEX1:29;
    then
A21: |.y' - z'.| > |.y' + (z'*').| by A17,A18,Lm15;
    |.(y' + (z'*')).| = |.-(y' + (z'*')).| by COMPLEX1:138;
    hence |.eval(rpoly(1,z),y).| > |.eval((rpoly(1,z))*',y).|
    by A20,A21,COMPLFLD:5;
  end;
A22: now
    let a,y,z be Element of F_Complex;
    assume
A23: rpoly(1,z) is Hurwitz & a <> 0.F_Complex;
    assume
A24: Re(y) > 0;
A25: |.a.| > 0 by A23,COMPLEX1:133,COMPLFLD:9;
A26: |.eval(a*rpoly(1,z),y).| = |.a * eval(rpoly(1,z),y).| by POLYNOM5:31
      .= |.a.| * |.eval(rpoly(1,z),y).| by COMPLEX1:151;
    |.a.| * |.eval((rpoly(1,z))*',y).|
    = |.a*'.| * |.eval((rpoly(1,z))*',y).| by COMPLEX1:139
      .= |.a*' * eval((rpoly(1,z))*',y).| by COMPLEX1:151
      .= |.eval((a*')*(rpoly(1,z))*',y).| by POLYNOM5:31
      .= |.eval((a*rpoly(1,z))*',y).| by Th44;
    hence |.eval(a*rpoly(1,z),y).|>|.eval((a*rpoly(1,z))*',y).|
    by A15,A23,A24,A25,A26,XREAL_1:70;
  end;
A27: now
    let y,z be Element of F_Complex;
    assume
A28: rpoly(1,z) is Hurwitz;
    assume
A29: Re(y) = 0;
    z is_a_root_of rpoly(1,z) by Th30;
    then
A30: Re(z) < 0 by A28,Def8;
    reconsider y' = y, z' = z as Element of COMPLEX by COMPLFLD:def 1;
A31: -y = -y' & -z = -z' by COMPLFLD:4;
    y - z = eval(rpoly(1,z),y) & eval(rpoly(1,z)*',y) = (-y) - (z*')
    by Th29,Th48;
    then
A32: y - z = eval(rpoly(1,z),y) &
    eval(rpoly(1,z)*',y) = (-y') - (z'*') by A31,COMPLFLD:5;
    y = Re(y) + Im(y) * <i> & z = Re(z) + Im(z) * <i> by COMPLEX1:29;
    then
A33: |.y' - z'.| = |.y' + (z'*').| by A29,A30,Lm15;
    |.(y' + (z'*')).| = |.-(y' + (z'*')).| by COMPLEX1:138;
    hence |.eval(rpoly(1,z),y).| = |.eval((rpoly(1,z))*',y).|
    by A32,A33,COMPLFLD:5;
  end;
A34: now
    let a,y,z be Element of F_Complex;
    assume
A35: rpoly(1,z) is Hurwitz & a <> 0.F_Complex;
    assume
A36: Re(y) = 0;
A37: |.eval(a*rpoly(1,z),y).| = |.a * eval(rpoly(1,z),y).| by POLYNOM5:31
      .= |.a.| * |.eval(rpoly(1,z),y).| by COMPLEX1:151;
    |.a.| * |.eval((rpoly(1,z))*',y).|
    = |.a*'.| * |.eval((rpoly(1,z))*',y).| by COMPLEX1:139
      .= |.a*' * eval((rpoly(1,z))*',y).| by COMPLEX1:151
      .= |.eval((a*')*(rpoly(1,z))*',y).| by POLYNOM5:31
      .= |.eval((a*rpoly(1,z))*',y).| by Th44;
    hence |.eval(a*rpoly(1,z),y).| = |.eval((a*rpoly(1,z))*',y).|
    by A27,A35,A36,A37;
  end;
A38: now
    let k be Element of NAT;
    assume
A39: P[k];
    now
      let f be Polynomial of F_Complex;
      assume
A40:  deg(f) >= 1 & f is Hurwitz & deg(f) = k+1;
      let x be Element of F_Complex;
      per cases by A40,XXREAL_0:1;
      suppose k+1 = 1;
        then consider z1,z2 being Element of F_Complex such that
A41:    z1 <> 0.F_Complex & f = z1 * rpoly(1,z2) by A40,Th28;
        rpoly(1,z2) is Hurwitz by A40,A41,Th40;
        hence (Re(x) < 0 implies |.eval(f,x).| < |.eval(f*',x).|) &
        (Re(x) > 0 implies |.eval(f,x).| > |.eval(f*',x).|) &
        (Re(x) = 0 implies |.eval(f,x).| = |.eval(f*',x).|)
        by A10,A22,A34,A41;
      end;
      suppose
A42:    k+1 > 1;
A43:    k + 1 + 1 > k + 1 + 0 by XREAL_1:8;
        then len f > 1 by A40,XXREAL_0:2;
        then f is with_roots by POLYNOM5:75;
        then consider z being Element of F_Complex such that
A44:    z is_a_root_of f by POLYNOM5:def 7;
        consider f1 being Polynomial of F_Complex such that
A45:    f = rpoly(1,z) *' f1 by A44,Th33;
A46:    f <> 0_.(F_Complex) by A40,A43,POLYNOM4:6;
        then
A47:    rpoly(1,z) <> 0_.(F_Complex) by A45,POLYNOM3:35;
        f1 <> 0_.(F_Complex) by A45,A46,POLYNOM3:35;
        then
A48:    deg f = deg(rpoly(1,z)) + deg(f1) by A45,A47,Th23
          .= 1 + deg(f1) by Th27;
A49:    f1 is Hurwitz & rpoly(1,z) is Hurwitz by A40,A45,Th41;
A50:    k >= 1 by A42,NAT_1:13;
A51:    now
          assume
A52:      Re(x) < 0;
          reconsider r' = eval(rpoly(1,z),x), e' = eval(f1,x)
          as Element of COMPLEX by COMPLFLD:def 1;
          reconsider r1' = eval(rpoly(1,z)*',x), e1' = eval(f1*',x)
          as Element of COMPLEX by COMPLFLD:def 1;
A53:      |.e'.| < |.e1'.| & |.r'.| < |.r1'.|by A3,A39,A40,A48,A49,A50,A52;
A54:      0 <= |.e'.| & 0 <= |.r'.| by COMPLEX1:132;
          then
A55:      |.r1'.| * |.e'.| < |.r1'.| * |.e1'.| by A53,XREAL_1:70;
          |.r'.| * |.e'.| <= |.r1'.| * |.e'.| by A53,A54,XREAL_1:66;
          then |.r'.| * |.e'.| < |.r1'.| * |.e1'.| by A55,XXREAL_0:2;
          then |.r' * e'.| < |.r1'.| * |.e1'.| by COMPLEX1:151;
          then
A56:      |.eval(rpoly(1,z),x) * eval(f1,x).| <
          |.eval((rpoly(1,z))*',x) * eval(f1*',x).| by COMPLEX1:151;
          eval(rpoly(1,z),x) * eval(f1,x) = eval(rpoly(1,z)*'f1,x) &
          eval(rpoly(1,z)*',x) * eval(f1*',x) =
          eval((rpoly(1,z)*')*'((f1)*'),x) by POLYNOM4:27;
          hence |.eval(f,x).| < |.eval(f*',x).| by A45,A56,Th47;
        end;
A57:    now
          assume
A58:      Re(x) > 0;
          reconsider r' = eval(rpoly(1,z),x), e' = eval(f1,x)
          as Element of COMPLEX by COMPLFLD:def 1;
          reconsider r1' = eval(rpoly(1,z)*',x), e1' = eval(f1*',x)
          as Element of COMPLEX by COMPLFLD:def 1;
A59:      |.e'.| > |.e1'.| & |.r'.| > |.r1'.|by A15,A39,A40,A48,A49,A50,A58;
A60:      0 <= |.e1'.| & 0 <= |.r1'.| by COMPLEX1:132;
          then
A61:      |.r'.| * |.e'.| > |.r1'.| * |.e'.| by A59,XREAL_1:70;
          |.r1'.| * |.e'.| >= |.r1'.| * |.e1'.| by A59,A60,XREAL_1:66;
          then |.r'.| * |.e'.| > |.r1'.| * |.e1'.| by A61,XXREAL_0:2;
          then |.r' * e'.| > |.r1'.| * |.e1'.| by COMPLEX1:151;
          then
A62:      |.eval(rpoly(1,z),x) * eval(f1,x).| >
          |.eval((rpoly(1,z))*',x) * eval(f1*',x).| by COMPLEX1:151;
          eval(rpoly(1,z),x) * eval(f1,x) = eval(rpoly(1,z)*'f1,x) &
          eval(rpoly(1,z)*',x) * eval(f1*',x) =
          eval((rpoly(1,z)*')*'((f1)*'),x) by POLYNOM4:27;
          hence |.eval(f,x).| > |.eval(f*',x).| by A45,A62,Th47;
        end;
        now
          assume
A63:      Re(x) = 0;
          then
A64:      |.eval(f1,x).| = |.eval(f1*',x).| by A39,A40,A48,A49,A50;
          reconsider r' = eval(rpoly(1,z),x), e' = eval(f1,x)
          as Element of COMPLEX by COMPLFLD:def 1;
          reconsider r1' = eval(rpoly(1,z)*',x), e1' = eval(f1*',x)
          as Element of COMPLEX by COMPLFLD:def 1;
          |.r'.| * |.e'.| = |.r1'.| * |.e1'.| by A27,A49,A63,A64;
          then |.r' * e'.| = |.r1'.| * |.e1'.| by COMPLEX1:151;
          then
A65:      |.eval(rpoly(1,z),x) * eval(f1,x).| =
          |.eval((rpoly(1,z))*',x) * eval(f1*',x).| by COMPLEX1:151;
          eval(rpoly(1,z),x) * eval(f1,x) = eval(rpoly(1,z)*'f1,x) &
          eval(rpoly(1,z)*',x) * eval(f1*',x) =
          eval((rpoly(1,z)*')*'((f1)*'),x) by POLYNOM4:27;
          hence |.eval(f,x).| = |.eval(f*',x).| by A45,A65,Th47;
        end;
        hence (Re(x) < 0 implies |.eval(f,x).| < |.eval(f*',x).|) &
        (Re(x) > 0 implies |.eval(f,x).| > |.eval(f*',x).|) &
        (Re(x) = 0 implies |.eval(f,x).| = |.eval(f*',x).|) by A51,A57;
      end;
    end;
    hence P[k+1];
  end;
A66: for k be Element of NAT holds P[k] from NAT_1:sch 1(A2,A38);
  f <> 0_.(F_Complex) by A1,Th20;
  then deg f is Element of NAT by Lm9;
  then consider j be Element of NAT such that
A67: deg(f) = j;
  thus thesis by A1,A66,A67;
end;

definition
  let f be Polynomial of F_Complex;
  let z be Element of F_Complex;
  func F*(f,z) -> Polynomial of F_Complex equals
  eval(f*',z) * f - eval(f,z) * f*';
  coherence;
end;

theorem Th51:
  for a,b being Element of F_Complex st |.a.| > |.b.|
  for f being Polynomial of F_Complex st deg(f) >= 1
  holds f is Hurwitz iff a * f - b * (f*') is Hurwitz
proof
  let a,b be Element of F_Complex;
  assume
A1: |.a.| > |.b.|;
  let f be Polynomial of F_Complex;
  assume
A2: deg(f) >= 1;
  set g = a * f - b * f*';
A3: 0 < |.a.| by A1,COMPLEX1:132;
  then
A4: a <> 0.F_Complex by COMPLEX1:133,COMPLFLD:9;
  per cases;
  suppose b = 0.F_Complex;
    then g = a * f - 0_.(F_Complex) by POLYNOM5:27
      .= a * f + 0_.(F_Complex) by Th9
      .= a * f by POLYNOM3:29;
    hence thesis by A4,Th40;
  end;
  suppose
A5: b <> 0.F_Complex;
    then
A6: 0 < |.b.| by COMPLEX1:133,COMPLFLD:9;
A7: now
      assume
A8:   f is Hurwitz;
      now
        let z be Element of F_Complex;
        assume z is_a_root_of g;
        then
A9:     0.F_Complex = eval(a * f - b * f*',z) by POLYNOM5:def 6
          .= eval(a * f,z) - eval(b * f*',z) by POLYNOM4:24
          .= a * eval(f,z) - eval(b * f*',z) by POLYNOM5:31
          .= a * eval(f,z) - b * eval(f*',z) by POLYNOM5:31;
        now
          assume
A10:      Re(z) >= 0;
A11:      |.a.| * |.eval(f,z).| = |.a * eval(f,z).| by COMPLEX1:151;
A12:      |.b.| * |.eval(f*',z).| = |.b * eval(f*',z).| by COMPLEX1:151;
A13:      0 <= |.b.| by COMPLEX1:132;
          per cases by A10;
          suppose Re(z) = 0;
            then |.eval(f,z).|=|.eval(f*',z).| & |.eval(f,z).|>0 by A2,A8,Th49
            ,Th50;
            then |.a.|*|.eval(f,z).| > |.b.|*|.eval(f*',z).| by A1,XREAL_1:70;
            hence contradiction by A9,A11,A12,VECTSP_1:66;
          end;
          suppose Re(z) > 0;
            then
A14:        |.eval(f,z).| > |.eval(f*',z).| by A2,A8,Th50;
            then |.eval(f,z).| > 0 by COMPLEX1:132;
            then
A15:        |.a.| * |.eval(f,z).| > |.b.| * |.eval(f,z).| by A1,XREAL_1:70;
            |.b.|*|.eval(f,z).| >= |.b.|*|.eval(f*',z).| by A13,A14,XREAL_1:66;
            hence contradiction by A9,A11,A12,A15,VECTSP_1:66;
          end;
        end;
        hence Re(z) < 0;
      end;
      hence g is Hurwitz by Def8;
    end;
A16: g*' = (a * f)*' + (-(b * f*'))*' by Th46
      .= (a * f)*' + - ((b * f*')*') by Th45
      .= ((a*') * (f*')) + - ((b * f*')*') by Th44
      .= ((a*') * (f*')) + - ((b*') * ((f*')*')) by Th44
      .= ((a*') * (f*')) + - ((b*') * f) by Th43;
    reconsider a'=a, b'=b as Element of COMPLEX by COMPLFLD:def 1;
    (|.a.|^2 - |.b.|^2)" in COMPLEX by XCMPLX_0:def 2;
    then reconsider zz = (|.a.|^2 - |.b.|^2)" as Element of F_Complex by
    COMPLFLD:def 1;
    set a1 = (a*') * zz, b1 = - b * zz;
    reconsider a1' = a1, b1' = b1 as Element of COMPLEX by COMPLFLD:def 1;
A17: now
      let z be Element of COMPLEX;
A18:  Re(z*z*') = (Re z)^2 + (Im z)^2 & Im(z*z*') = 0 by COMPLEX1:126;
A19:  Re(z*z*') +(Im(z*z*')) * <i> = (z*z*') by COMPLEX1:29;
      (Re z)^2 >= 0 & (Im z)^2 >= 0 by XREAL_1:65;
      then (Re z)^2 + (Im z)^2 >= 0 + 0;
      hence z*' * z = |.z.|^2 by A18,A19,SQUARE_1:def 4;
    end;
    then
A20: b'*' * b' = |.b'.|^2 & a'*' * a' = |.a'.|^2;
A21: (a'*' * a') * (b'") - (b'*') = (|.a'.|^2 * (b'") - (b'*')) * 1 by A17
      .= (|.a'.|^2 * (b'")-(b'*')) * (b'*b'") by A5,COMPLFLD:9,XCMPLX_0:def 7
      .= ((|.a'.|^2 * ((b'") * b')) - |.b'.|^2) * b'" by A20
      .= (|.a'.|^2 * 1 - |.b'.|^2) * b'" by A5,COMPLFLD:9,XCMPLX_0:def 7;
    b * f*' + g = a * f + (-(b * f*') + b * f*') by POLYNOM3:26
      .= a * f + (b * f*' - b * f*')
      .= a * f + 0_.(F_Complex) by POLYNOM3:30;
    then
A22: a * f - g = (b * f*' + g) - g by POLYNOM3:29
      .= b * f*' + (g - g) by POLYNOM3:26
      .= b * f*' + 0_.(F_Complex) by POLYNOM3:30;
    f*' = (1_F_Complex) * (f*') by POLYNOM5:28
      .= (b" * b) * (f*') by A5,VECTSP_1:def 22
      .= b" * (b * (f*')) by Th14
      .= b" * (a * f - g) by A22,POLYNOM3:29;

then g*' = ((a*')*((b" * (a * f))+(b" * (-g)))) + (-((b*') * f)) by A16,Th18
      .= ((a*') * (b" * (a * f)) + ((a*') * (b" * (-g)))) + (-((b*') * f))
    by Th18
      .= (a*') * (b" * (-g)) + ((a*') * (b" * (a * f)) + (-((b*') * f)))
    by POLYNOM3:26
      .= (a*') * (b" * (-g)) + ((a*') * ((b" * a) * f) + (-((b*') * f)))
    by Th14
      .= (a*') * (b" * (-g)) + (((a*') * (b" * a)) * f + (-((b*') * f)))
    by Th14
      .= (a*') * (b" * (-g)) + (((a*') * (b" * a)) * f + ((-b*') * f))
    by Th15
      .= (a*') * (b" * (-g)) + (((a*') * (b" * a)) + -(b*')) * f by Th17
      .= ((a*') * b") * (-g) + (((a*') * (b" * a)) + -(b*')) * f by Th14;
    then
A23: g*' + -((a*') * b") * (-g) = (((a*') * (b" * a)) + -(b*')) * f +
    (((a*') * b") * (-g) - ((a*') * b") * (-g)) by POLYNOM3:26
      .= (((a*') * (b" * a)) + -(b*')) * f + 0_.(F_Complex) by POLYNOM3:30;
    (b'") = b" by A5,COMPLFLD:7;
    then
A24: (a'*' * a') * (b'") - (b'*') = (a*' * a) * (b") - (b*') by COMPLFLD:5;
    |.a'.|*|.b'.| > |.b'.|*|.b'.| by A1,A6,XREAL_1:70;
    then
A25: |.a'.|^2 - |.b'.|^2 <> 0 by A1,A3,XREAL_1:70;
    then
A26: (|.a'.|^2 - |.b'.|^2)" <> 0;
    b'" <> 0 by A5,COMPLFLD:9;
    then
A27: (((a*') * (b" * a)) + -(b*')) <> 0.F_Complex
    by A21,A24,A25,COMPLFLD:9,RLVECT_1:def 12;
    b1' = -b' * (|.a.|^2 - |.b.|^2)" by COMPLFLD:4
      .= (-b') * (|.a.|^2 - |.b.|^2)";
    then
A28: b1' <> 0 by A5,A26,COMPLFLD:9;
A29: now
      assume -b1 = 0.F_Complex;
      then -(-b1) = 0.F_Complex by RLVECT_1:25;
      hence contradiction by A28,COMPLFLD:9,RLVECT_1:30;
    end;
A30: now
      assume
A31:  b1" = 0.F_Complex;
      b1" * b1 = 1_F_Complex by A28,COMPLFLD:9,VECTSP_1:def 22;
      hence contradiction by A31,VECTSP_1:36;
    end;
A32: now
      assume -(b1") = 0.F_Complex;
      then -(-b1") = 0.F_Complex by RLVECT_1:25;
      hence contradiction by A30,RLVECT_1:30;
    end;
A33: b1' = -(b' * (|.a.|^2 - |.b.|^2)") by COMPLFLD:4;
A34: -((a'*' * a') * (b'") - (b'*'))"
    = -((|.a'.|^2 - |.b'.|^2)" * (b'")") by A21,XCMPLX_1:205
      .= b1' by COMPLFLD:4;
A35: (a'*') * (b'" * a') = (a*') * (b" * a) by A5,COMPLFLD:7;
A36: -(b'*') = -(b*') by COMPLFLD:4;
    -b1 = -b1' by COMPLFLD:4;
    then
A37: (-b1')" = (-b1)" by A29,COMPLFLD:7
      .= -(b1)" by A28,Th1,COMPLFLD:9;
A38: (-(b1"))" = -((b1)")" by A30,Th1
      .= -b1 by A28,COMPLFLD:9,VECTSP_1:73;
    b1" = b1'" by A28,COMPLFLD:7,9;
    then -(b1") = -(b1'") by COMPLFLD:4;
    then (-(b1"))" = (-(b1'"))" by A32,COMPLFLD:7;
    then
A39: (-(b1'"))" * ((a'*') * b'")
    = (--(b' * (|.a.|^2 - |.b.|^2)")) * ((a'*') * b'") by A33,A38,COMPLFLD:4
      .= (b' * (b'")) * ((|.a.|^2 - |.b.|^2)") * (a'*')
      .= 1 * ((|.a.|^2 - |.b.|^2)") * (a'*') by A5,COMPLFLD:9,XCMPLX_0:def 7
      .= a1';
A40: ((a*') * b") = ((a'*') * b'") by A5,COMPLFLD:7;
    b1" = b1'" by A28,COMPLFLD:7,9;
    then -(b1") = -(b1'") by COMPLFLD:4;
    then
A41: ((-(b1"))") * ((a*') * b") = a1 by A32,A39,A40,COMPLFLD:7;
A42: f = (1_F_Complex) * f by POLYNOM5:28
      .= ((-(b1"))" * (-(b1"))) * f by A27,A34,A35,A36,A37,VECTSP_1:def 22
      .= (-(b1"))" * ((-(b1")) * f) by Th14

.= (-(b1"))" * (g*' + -((a*') * b") * (-g)) by A23,A34,A35,A36,A37,POLYNOM3:29
      .= (-(b1"))" * g*' + (-(b1"))" * (-((a*') * b") * (-g)) by Th18
      .= (-(b1"))" * g*' + (-(b1"))" * (((a*') * b") * (--g)) by Th16
      .= (-(b1"))" * g*' + (-(b1"))" * (((a*') * b") * g) by Lm4
      .= (-(b1"))" * g*' + a1 * g by A41,Th14
      .= ((-b1)")" * g*' + a1 * g by A28,Th1,COMPLFLD:9
      .= (-b1) * g*' + a1 * g by A29,VECTSP_1:73
      .= -(b1 * g*') + a1 * g by Th15;
A43: |.a1.| = |.a*'.| * |.(|.a.|^2 - |.b.|^2)".| by COMPLEX1:151
      .= |.a.| * |.(|.a.|^2 - |.b.|^2)".| by COMPLEX1:139;
A44: |.b1.| = |.-(b * (|.a.|^2 - |.b.|^2)").| by COMPLFLD:4
      .= |.b * (|.a.|^2 - |.b.|^2)".| by COMPLEX1:138
      .= |.b.| * |.(|.a.|^2 - |.b.|^2)".| by COMPLEX1:151;
A45: |.a.| * |.a.| > |.b.| * |.a.| by A1,A3,XREAL_1:70;
    |.b.| * |.a.| > |.b.| * |.b.| by A1,A6,XREAL_1:70;
    then |.a.|^2 > |.b.| * |.b.| by A45,XXREAL_0:2;
    then |.a.|^2 - |.b.|^2 > |.b.|^2 - |.b.|^2 by XREAL_1:11;
    then
A46: (|.a.|^2 - |.b.|^2)" > 0;
    then |. (|.a.|^2 - |.b.|^2)" .| > 0 by COMPLEX1:133;
    then
A47: |.a1.| > |.b1.| by A1,A43,A44,XREAL_1:70;
A48: now
      assume b1' = 0.F_Complex;
      then (- b) * zz = 0.F_Complex by VECTSP_1:41;
      then -b = 0.F_Complex by A46,COMPLFLD:9;
      then b = - 0.F_Complex by RLVECT_1:30;
      hence contradiction by A5,RLVECT_1:25;
    end;
    |.a1.| > 0 by A47,COMPLEX1:132;
    then
A49: a1 <> 0.F_Complex & b1 <> 0.F_Complex by A48,COMPLEX1:133,COMPLFLD:9;
    deg f <= max(deg(a1 * g),deg(-(b1 * g*'))) by A42,Th22;
    then deg f <= max(deg(a1 * g),deg(b1 * g*')) by POLYNOM4:11;
    then deg f <= max(deg(g),deg(b1 * g*')) by A49,POLYNOM5:26;
    then deg f <= max(deg(g),deg(g*')) by A48,POLYNOM5:26;
    then deg f <= max(deg(g),deg(g)) by Th42;
    then
A50: deg(g) >= 1 by A2,XXREAL_0:2;
    now
      assume
A51:  g is Hurwitz;
      now
        let z be Element of F_Complex;
        assume z is_a_root_of f;
        then
A52:    0.F_Complex = eval(a1 * g - b1 * g*',z) by A42,POLYNOM5:def 6
          .= eval(a1 * g,z) - eval(b1 * g*',z) by POLYNOM4:24
          .= a1 * eval(g,z) - eval(b1 * g*',z) by POLYNOM5:31
          .= a1 * eval(g,z) - b1 * eval(g*',z) by POLYNOM5:31;
        now
          assume
A53:      Re(z) >= 0;
A54:      |.a1.| * |.eval(g,z).| = |.a1 * eval(g,z).| by COMPLEX1:151;
A55:      |.b1.| * |.eval(g*',z).| = |.b1 * eval(g*',z).| by COMPLEX1:151;
A56:      0 <= |.b1.| by COMPLEX1:132;
          per cases by A53;
          suppose Re(z) = 0;

then |.eval(g,z).|=|.eval(g*',z).| & |.eval(g,z).|>0 by A50,A51,Th49,Th50;

then |.a1.|*|.eval(g,z).| > |.b1.|*|.eval(g*',z).| by A47,XREAL_1:70;
            hence contradiction by A52,A54,A55,VECTSP_1:66;
          end;
          suppose Re(z) > 0;
            then
A57:        |.eval(g,z).| > |.eval(g*',z).| by A50,A51,Th50;
            then |.eval(g,z).| > 0 by COMPLEX1:132;
            then
A58:        |.a1.| * |.eval(g,z).| > |.b1.| * |.eval(g,z).| by A47,XREAL_1:70;

|.b1.|*|.eval(g,z).| >= |.b1.|*|.eval(g*',z).| by A56,A57,XREAL_1:66;
            hence contradiction by A52,A54,A55,A58,VECTSP_1:66;
          end;
        end;
        hence Re(z) < 0;
      end;
      hence f is Hurwitz by Def8;
    end;
    hence thesis by A7;
  end;
end;

theorem Th52:
  for f being Polynomial of F_Complex st deg(f) >= 1
  for rho being Element of F_Complex st Re(rho) < 0
  holds f is Hurwitz implies F*(f,rho) div rpoly(1,rho) is Hurwitz
proof
  let f be Polynomial of F_Complex;
  assume
A1: deg(f) >= 1;
  let rho be Element of F_Complex;
  assume
A2: Re(rho) < 0;
  assume
A3: f is Hurwitz;
  then
A4: |.eval(f,rho).| < |.eval(f*',rho).| by A1,A2,Th50;
  reconsider ef = eval(f,rho), ef1 = eval(f*',rho) as Element of F_Complex;
A5: ef1 * f - ef * (f*') is Hurwitz by A1,A3,A4,Th51;
  eval(ef1 * f - ef * (f*'),rho)
  = eval(ef1*f,rho) - eval(ef*(f*'),rho) by POLYNOM4:24
    .= ef1 * eval(f,rho) - eval(ef*(f*'),rho) by POLYNOM5:31
    .= ef1 * eval(f,rho) - ef * eval((f*'),rho) by POLYNOM5:31
    .= 0.F_Complex by RLVECT_1:28;
  then rho is_a_root_of (ef1 * f - ef * (f*')) by POLYNOM5:def 6;
  then consider s being Polynomial of F_Complex such that
A6: ef1 * f - ef * (f*') = rpoly(1,rho) *' s by Th33;
A7: s is Hurwitz by A5,A6,Th41;
A8: ef1 * f - ef * (f*') = s *' rpoly(1,rho) + 0_.(F_Complex) by A6,POLYNOM3:29
  ;
  -1 < deg rpoly(1,rho) by Th27;
  then deg 0_.(F_Complex) < deg rpoly(1,rho) by Th20;
  hence thesis by A7,A8,Def5;
end;

theorem
  for f being Polynomial of F_Complex st deg(f) >= 1
  holds (ex rho being Element of F_Complex
  st Re(rho) < 0 & |.eval(f,rho).| >= |.eval(f*',rho).|)
  implies f is non Hurwitz by Th50;

theorem
  for f being Polynomial of F_Complex st deg(f) >= 1
  for rho being Element of F_Complex
  st Re(rho) < 0 & |.eval(f,rho).| < |.eval(f*',rho).|
  holds f is Hurwitz iff F*(f,rho) div rpoly(1,rho) is Hurwitz
proof
  let f be Polynomial of F_Complex;
  assume
A1: deg(f) >= 1;
  let rho be Element of F_Complex;
  assume
A2: Re(rho) < 0 & |.eval(f,rho).| < |.eval(f*',rho).|;
  reconsider ef = eval(f,rho), ef1 = eval(f*',rho) as Element of F_Complex;
  now
    assume
A3: F*(f,rho) div rpoly(1,rho) is Hurwitz;
    eval(ef1 * f - ef * (f*'),rho)
    = eval(ef1*f,rho) - eval(ef*(f*'),rho) by POLYNOM4:24
      .= ef1 * eval(f,rho) - eval(ef*(f*'),rho) by POLYNOM5:31
      .= ef1 * eval(f,rho) - ef * eval((f*'),rho) by POLYNOM5:31
      .= 0.F_Complex by RLVECT_1:28;
    then rho is_a_root_of (ef1 * f - ef * (f*')) by POLYNOM5:def 6;
    then consider t being Polynomial of F_Complex such that
A4: F*(f,rho) = rpoly(1,rho) *' t by Th33;
A5: F*(f,rho) = rpoly(1,rho) *' t + 0_.(F_Complex) by A4,POLYNOM3:29;
    -1 < deg rpoly(1,rho) by Th27;
    then deg 0_.(F_Complex) < deg rpoly(1,rho) by Th20;
    then
A6: F*(f,rho) = (F*(f,rho) div rpoly(1,rho)) *' rpoly(1,rho) by A4,A5,Def5;
    (1_F_Complex) * rpoly(1,rho) is Hurwitz by A2,Th39;
    then rpoly(1,rho) is Hurwitz by POLYNOM5:28;
    then F*(f,rho) is Hurwitz by A3,A6,Th41;
    hence f is Hurwitz by A1,A2,Th51;
  end;
  hence thesis by A1,A2,Th52;
end;

