:: On the Instructions of { \bf SCM+FSA }
::  by Artur Korni{\l}owicz
::
:: Received May 8, 2001
:: Copyright (c) 2001 Association of Mizar Users

environ

 vocabularies AMI_3, SCMFSA_2, AMI_1, ORDINAL2, ARYTM, FUNCT_1, FUNCT_4, CAT_1,
      FINSEQ_1, RELAT_1, BOOLE, INT_1, FUNCOP_1, SCMFSA_1, AMI_2, GR_CY_1,
      AMISTD_2, MCART_1, AMI_5, FINSEQ_4, AMISTD_1, SETFAM_1, REALSET1, TARSKI,
      SGRAPH1, GOBOARD5, FRECHET, ARYTM_1, NAT_1, ABSVALUE, FINSEQ_2, UNIALG_1,
      CARD_5, CARD_3, RELOC, FUNCT_7;
 notations TARSKI, XBOOLE_0, ENUMSET1, SUBSET_1, MCART_1, SETFAM_1, RELAT_1,
      FUNCT_1, PARTFUN1, FUNCT_2, REALSET1, ORDINAL1, XCMPLX_0, INT_1,
      FUNCOP_1, FINSEQ_1, FINSEQ_2, FUNCT_4, COMPLEX1, CARD_1, CARD_3, FUNCT_7,
      XXREAL_0, AMI_1, SCMNORM, AMI_2, AMI_3, SCMFSA_1, SCMFSA_2, SCMFSA_3,
      AMISTD_1, AMISTD_2;
 constructors XXREAL_0, REAL_1, NAT_1, NAT_D, INT_2, FINSEQ_4, REALSET1,
      PRALG_2, AMI_5, SCMFSA_1, SCMFSA_3, AMISTD_2, VALUED_1, PARTFUN1, SEQ_1,
      SCMNORM, RELSET_1;
 registrations XBOOLE_0, SETFAM_1, RELAT_1, FUNCT_1, ORDINAL1, FUNCOP_1,
      NUMBERS, XREAL_0, NAT_1, INT_1, FINSEQ_1, AMI_1, AMI_5, SCMFSA_2,
      AMISTD_2, RELSET_1, CARD_3, FUNCT_2, REALSET1, ZFMISC_1, AMI_3;
 requirements NUMERALS, BOOLE, SUBSET, REAL, ARITHM;
 definitions TARSKI, FUNCT_1, FUNCT_2, SCMFSA_2, AMISTD_1, AMISTD_2, XBOOLE_0,
      FUNCOP_1, SCMFSA_1, AMI_1, AMI_3, CARD_3, NAT_1;
 theorems TARSKI, NAT_1, AMI_1, AMI_3, FUNCT_4, FUNCT_1, FUNCT_2, FUNCOP_1,
      SETFAM_1, AMISTD_1, MCART_1, FINSEQ_1, FINSEQ_3, AMISTD_2, FUNCT_7,
      CARD_3, SCMFSA6A, SCMFSA_2, INT_1, ENUMSET1, BVFUNC14, ABSVALUE, GROUP_7,
      FINSEQ_2, XBOOLE_0, XBOOLE_1, NAT_D, RELAT_1, ZFMISC_1, AMI_5, PARTFUN1,
      ORDINAL1;
 schemes FUNCT_2;

begin

reserve a, b, d1, d2, d3, d4 for Int-Location,
  A, B for Data-Location,
  f, f1,
  f2, f3 for FinSeq-Location,
  il, i1, i2 for Instruction-Location of SCM+FSA,
  L
  for Instruction-Location of SCM,
  I for Instruction of SCM+FSA,
  s for State of
  SCM+FSA,
  T for InsType of SCM+FSA,
  k for natural number;

definition
  let la, lb be Int-Location, a, b be Integer;
  redefine func (la,lb) --> (a,b) -> FinPartState of SCM+FSA;
  coherence
  proof
A1: ObjectKind lb = INT by SCMFSA_2:26;
A2: ObjectKind la = INT by SCMFSA_2:26;
A3: b is Element of INT by INT_1:def 2;
    a is Element of INT by INT_1:def 2;
    hence thesis by A3,A2,A1,AMI_1:58;
  end;
end;

canceled 2;

theorem Th3:
  not a in NAT
proof
  a in SCM+FSA-Data-Loc by SCMFSA_2:def 4;
  hence thesis by SCMFSA_2:13,XBOOLE_0:3;
end;

theorem Th4:
  not f in NAT
proof
  f in SCM+FSA-Data*-Loc by SCMFSA_2:def 5;
  hence thesis by SCMFSA_2:14,XBOOLE_0:3;
end;

theorem Th5:
  SCM+FSA-Data-Loc <> NAT
proof
  consider a being Int-Location;
A1: a in SCM+FSA-Data-Loc by SCMFSA_2:def 4;
  assume
  not thesis;
  hence thesis by A1,Th3;
end;

theorem Th6:
  SCM+FSA-Data*-Loc <> NAT
proof
  consider f being FinSeq-Location;
A1: f in SCM+FSA-Data*-Loc by SCMFSA_2:def 5;
  assume
  not thesis;
  hence thesis by A1,Th4;
end;

theorem Th7:
  for o being Object of SCM+FSA holds o = IC SCM+FSA or o in NAT or
  o is Int-Location or o is FinSeq-Location
proof
  let o be Object of SCM+FSA;
  o in Int-Locations \/ FinSeq-Locations \/ {IC SCM+FSA} or o in NAT by
SCMFSA_2:8,XBOOLE_0:def 3;
  then
  o in Int-Locations \/ FinSeq-Locations or o in {IC SCM+FSA} or o in NAT
  by XBOOLE_0:def 3;
  then
  o in Int-Locations or o in FinSeq-Locations or o in {IC SCM+FSA} or o in
  NAT by XBOOLE_0:def 3;
  hence thesis by SCMFSA_2:11,12,TARSKI:def 1;
end;

canceled;

theorem Th9:
  a := b = [1, <* a,b *>]
proof
  ex A,B st a = A & b = B & a := b = A:=B by SCMFSA_2:def 11;
  hence thesis;
end;

theorem Th10:
  AddTo(a,b) = [2, <* a,b *>]
proof
  ex A,B st a = A & b = B & AddTo(a,b) = AddTo(A,B) by SCMFSA_2:def 12;
  hence thesis;
end;

theorem Th11:
  SubFrom(a,b) = [3, <* a,b *>]
proof
  ex A,B st a = A & b = B & SubFrom(a,b) = SubFrom(A,B) by SCMFSA_2:def 13;
  hence thesis;
end;

theorem Th12:
  MultBy(a,b) = [4, <* a,b *>]
proof
  ex A,B st a = A & b = B & MultBy(a,b) = MultBy(A,B) by SCMFSA_2:def 14;
  hence thesis;
end;

theorem Th13:
  Divide(a,b) = [5, <* a,b *>]
proof
  ex A,B st a = A & b = B & Divide(a,b) = Divide(A,B) by SCMFSA_2:def 15;
  hence thesis;
end;

theorem Th14:
  goto il = [6, <* il *>]
proof
  ex L st L = il & goto il = goto L by SCMFSA_2:def 16;
  hence thesis;
end;

theorem Th15:
  a=0_goto il = [7, <* il,a *>]
proof
  ex A, L st A = a & L = il & A=0_goto L = a=0_goto il by SCMFSA_2:def 17;
  hence thesis;
end;

theorem Th16:
  a>0_goto il = [8, <* il,a *>]
proof
  ex A, L st A = a & L = il & A>0_goto L = a>0_goto il by SCMFSA_2:def 18;
  hence thesis;
end;

Lm1: for x, y being set st x in dom <*y*> holds x = 1
proof
  let x, y be set;
  assume
  x in dom <*y*>;
  then x in Seg 1 by FINSEQ_1:def 8;
  hence thesis by FINSEQ_1:4,TARSKI:def 1;
end;

Lm2: for x, y, z being set st x in dom <*y,z*> holds x = 1 or x = 2
proof
  let x, y, z be set;
  assume
  x in dom <*y,z*>;
  then x in Seg 2 by FINSEQ_3:29;
  hence thesis by FINSEQ_1:4,TARSKI:def 2;
end;

Lm3: for x, y, z, t being set st x in dom <*y,z,t*> holds x = 1 or x = 2 or x
= 3

proof
  let x, y, z, t be set;
  assume
  x in dom <*y,z,t*>;
  then x in Seg 3 by FINSEQ_3:30;
  hence thesis by ENUMSET1:def 1,FINSEQ_3:1;
end;

reserve J,K for Element of Segm 13,
  b,c,c1 for Element of SCM+FSA-Data-Loc,
  f,
  f1 for Element of SCM+FSA-Data*-Loc;

Lm4: T = 0 or T = 1 or T = 2 or T = 3 or T = 4 or T = 5 or T = 6 or T = 7 or T
= 8 or T = 9 or T = 10 or T = 11 or T = 12

proof
  consider y being set such that
A1: [T,y] in the Instructions of SCM+FSA by RELAT_1:def 4;

A2: [T,y] in SCM-Instr \/ { [J,<*c,f,b*>] : J in {9,10} } or [T,y] in { [K,
  <*c1,f1*>] : K in {11,12} } by A1,XBOOLE_0:def 3;

  per cases by A2,XBOOLE_0:def 3;
  suppose
    [T,y] in SCM-Instr;
    then reconsider I = [T,y] as Instruction of SCM;
    T = InsCode I by MCART_1:7;
    hence thesis by AMI_5:36,NAT_1:33;
  end;
  suppose
    [T,y] in { [J,<*c,f,b*>] : J in {9,10} };
    then ex J,c,b,f st [T,y] = [J,<*c,f,b*>] & J in {9,10};
    then T in {9,10} by ZFMISC_1:33;
    hence thesis by TARSKI:def 2;
  end;
  suppose
    [T,y] in { [K,<*c1,f1*>] : K in {11,12} };
    then ex K,c1,f1 st [T,y] = [K,<*c1,f1*>] & K in {11,12};
    then T in {11,12} by ZFMISC_1:33;
    hence thesis by TARSKI:def 2;
  end;
end;

theorem Th17:
  AddressPart halt SCM+FSA = {} by AMI_3:71,MCART_1:def 2,SCMFSA_2:123;

reserve a, b, d1, d2, d3, d4 for Int-Location,
  A, B for Data-Location,
  f, f1,
  f2, f3 for FinSeq-Location;

theorem Th18:
  AddressPart (a:=b) = <*a,b*>
proof
  thus AddressPart (a:=b) = [ 1, <*a,b*>]`2 by Th9
    .= <*a,b*> by MCART_1:def 2;
end;

theorem Th19:
  AddressPart AddTo(a,b) = <*a,b*>
proof
  thus AddressPart AddTo(a,b) = [ 2, <*a,b*>]`2 by Th10
    .= <*a,b*> by MCART_1:def 2;
end;

theorem Th20:
  AddressPart SubFrom(a,b) = <*a,b*>
proof
  thus AddressPart SubFrom(a,b) = [ 3, <*a,b*>]`2 by Th11
    .= <*a,b*> by MCART_1:def 2;
end;

theorem Th21:
  AddressPart MultBy(a,b) = <*a,b*>
proof
  thus AddressPart MultBy(a,b) = [ 4, <*a,b*>]`2 by Th12
    .= <*a,b*> by MCART_1:def 2;
end;

theorem Th22:
  AddressPart Divide(a,b) = <*a,b*>
proof
  thus AddressPart Divide(a,b) = [ 5, <*a,b*>]`2 by Th13
    .= <*a,b*> by MCART_1:def 2;
end;

theorem Th23:
  AddressPart goto i1 = <*i1*>
proof
  thus AddressPart goto i1 = [ 6, <*i1*>]`2 by Th14
    .= <*i1*> by MCART_1:def 2;
end;

theorem Th24:
  AddressPart (a=0_goto i1) = <*i1,a*>
proof
  thus AddressPart (a=0_goto i1) = [ 7, <*i1,a*>]`2 by Th15
    .= <*i1,a*> by MCART_1:def 2;
end;

theorem Th25:
  AddressPart (a>0_goto i1) = <*i1,a*>
proof
  thus AddressPart (a>0_goto i1) = [ 8, <*i1,a*>]`2 by Th16
    .= <*i1,a*> by MCART_1:def 2;
end;

theorem
  AddressPart (b:=(f,a)) = <*b,f,a*> by MCART_1:def 2;

theorem
  AddressPart ((f,a):=b) = <*b,f,a*> by MCART_1:def 2;

theorem
  AddressPart (a:=len f) = <*a,f*> by MCART_1:def 2;

theorem
  AddressPart (f:=<0,...,0>a) = <*a,f*> by MCART_1:def 2;

theorem Th30:
  T = 0 implies AddressParts T = {0}
proof
  assume
A1: T = 0;
  hereby
    let a be set;
    assume
    a in AddressParts T;
    then consider I such that
A2: a = AddressPart I and
A3: InsCode I = T;
    I = halt SCM+FSA by A1,A3,SCMFSA_2:122;
    hence a in {0} by A2,Th17,TARSKI:def 1;
  end;
  let a be set;
  assume
  a in {0};
  then a = 0 by TARSKI:def 1;
  hence thesis by A1,Th17,SCMFSA_2:124;
end;

registration
  let T;
  cluster AddressParts T -> non empty;
  coherence
  proof
    consider a, b, i1, f;
A1: InsCode (a:=b) = 1 by SCMFSA_2:42;
A2: InsCode AddTo(a,b) = 2 by SCMFSA_2:43;
A3: InsCode MultBy(a,b) = 4 by SCMFSA_2:45;
A4: InsCode SubFrom(a,b) = 3 by SCMFSA_2:44;
A5: InsCode (a >0_goto i1) = 8 by SCMFSA_2:49;
A6: InsCode (a =0_goto i1) = 7 by SCMFSA_2:48;
A7: InsCode goto i1 = 6 by SCMFSA_2:47;
A8: InsCode Divide(a,b) = 5 by SCMFSA_2:46;
A9: InsCode (f:=<0,...,0>a) = 12 by SCMFSA_2:53;
A10: InsCode (a:=len f) = 11 by SCMFSA_2:52;
A11: InsCode ((f,a):=b) = 10 by SCMFSA_2:51;
A12: InsCode (b:=(f,a)) = 9 by SCMFSA_2:50;
    T = 0 or T = 1 or T = 2 or T = 3 or T = 4 or T = 5 or T = 6 or T = 7
    or T = 8 or T = 9 or T = 10 or T = 11 or T = 12 by Lm4;
    then AddressPart halt SCM+FSA in AddressParts T or AddressPart (a:=b) in
    AddressParts T or AddressPart AddTo(a,b) in AddressParts T or AddressPart
SubFrom(a,b) in AddressParts T or AddressPart MultBy(a,b) in AddressParts T or
    AddressPart Divide(a,b) in AddressParts T or AddressPart goto i1 in
AddressParts T or AddressPart (a =0_goto i1) in AddressParts T or AddressPart (
a >0_goto i1) in AddressParts T or AddressPart (b:=(f,a)) in AddressParts T or
    AddressPart ((f,a):=b) in AddressParts T or AddressPart (a:=len f) in
AddressParts T or AddressPart (f:=<0,...,0>a) in AddressParts T by A1,A2,A4,A3
,A8,A7,A6,A5,A12,A11,A10,A9,SCMFSA_2:124;
    hence thesis;
  end;
end;

theorem Th31:
  T = 1 implies dom product" AddressParts T = {1,2}
proof
  consider a, b;
  assume
A1: T = 1;
A2: AddressPart (a:=b) = <*a,b*> by Th18;
  hereby
    let x be set;
    InsCode (a:=b) = 1 by SCMFSA_2:42;
    then
A3: AddressPart (a:=b) in AddressParts T by A1;
    assume
    x in dom product" AddressParts T;
    then x in dom AddressPart (a:=b) by A3,CARD_3:def 13;
    hence x in {1,2} by A2,FINSEQ_1:4,FINSEQ_3:29;
  end;
  let x be set;
  assume
A4: x in {1,2};
  for f being Function st f in AddressParts T holds x in dom f
  proof
    let f be Function;
    assume
    f in AddressParts T;
    then consider I being Instruction of SCM+FSA such that
A5: f = AddressPart I and
A6: InsCode I = T;
    consider d1, d2 such that
A7: I = d1:=d2 by A1,A6,SCMFSA_2:54;
    f = <*d1,d2*> by A5,A7,Th18;
    hence thesis by A4,FINSEQ_1:4,FINSEQ_3:29;
  end;
  hence thesis by CARD_3:def 13;
end;

theorem Th32:
  T = 2 implies dom product" AddressParts T = {1,2}
proof
  consider a, b;
  assume
A1: T = 2;
A2: AddressPart AddTo(a,b) = <*a,b*> by Th19;
  hereby
    let x be set;
    InsCode AddTo(a,b) = 2 by SCMFSA_2:43;
    then
A3: AddressPart AddTo(a,b) in AddressParts T by A1;
    assume
    x in dom product" AddressParts T;
    then x in dom AddressPart AddTo(a,b) by A3,CARD_3:def 13;
    hence x in {1,2} by A2,FINSEQ_1:4,FINSEQ_3:29;
  end;
  let x be set;
  assume
A4: x in {1,2};
  for f being Function st f in AddressParts T holds x in dom f
  proof
    let f be Function;
    assume
    f in AddressParts T;
    then consider I being Instruction of SCM+FSA such that
A5: f = AddressPart I and
A6: InsCode I = T;
    consider d1, d2 such that
A7: I = AddTo(d1,d2) by A1,A6,SCMFSA_2:55;
    f = <*d1,d2*> by A5,A7,Th19;
    hence thesis by A4,FINSEQ_1:4,FINSEQ_3:29;
  end;
  hence thesis by CARD_3:def 13;
end;

theorem Th33:
  T = 3 implies dom product" AddressParts T = {1,2}
proof
  consider a, b;
  assume
A1: T = 3;
A2: AddressPart SubFrom(a,b) = <*a,b*> by Th20;
  hereby
    let x be set;
    InsCode SubFrom(a,b) = 3 by SCMFSA_2:44;
    then
A3: AddressPart SubFrom(a,b) in AddressParts T by A1;
    assume
    x in dom product" AddressParts T;
    then x in dom AddressPart SubFrom(a,b) by A3,CARD_3:def 13;
    hence x in {1,2} by A2,FINSEQ_1:4,FINSEQ_3:29;
  end;
  let x be set;
  assume
A4: x in {1,2};
  for f being Function st f in AddressParts T holds x in dom f
  proof
    let f be Function;
    assume
    f in AddressParts T;
    then consider I being Instruction of SCM+FSA such that
A5: f = AddressPart I and
A6: InsCode I = T;
    consider d1, d2 such that
A7: I = SubFrom(d1,d2) by A1,A6,SCMFSA_2:56;
    f = <*d1,d2*> by A5,A7,Th20;
    hence thesis by A4,FINSEQ_1:4,FINSEQ_3:29;
  end;
  hence thesis by CARD_3:def 13;
end;

theorem Th34:
  T = 4 implies dom product" AddressParts T = {1,2}
proof
  consider a, b;
  assume
A1: T = 4;
A2: AddressPart MultBy(a,b) = <*a,b*> by Th21;
  hereby
    let x be set;
    InsCode MultBy(a,b) = 4 by SCMFSA_2:45;
    then
A3: AddressPart MultBy(a,b) in AddressParts T by A1;
    assume
    x in dom product" AddressParts T;
    then x in dom AddressPart MultBy(a,b) by A3,CARD_3:def 13;
    hence x in {1,2} by A2,FINSEQ_1:4,FINSEQ_3:29;
  end;
  let x be set;
  assume
A4: x in {1,2};
  for f being Function st f in AddressParts T holds x in dom f
  proof
    let f be Function;
    assume
    f in AddressParts T;
    then consider I being Instruction of SCM+FSA such that
A5: f = AddressPart I and
A6: InsCode I = T;
    consider d1, d2 such that
A7: I = MultBy(d1,d2) by A1,A6,SCMFSA_2:57;
    f = <*d1,d2*> by A5,A7,Th21;
    hence thesis by A4,FINSEQ_1:4,FINSEQ_3:29;
  end;
  hence thesis by CARD_3:def 13;
end;

theorem Th35:
  T = 5 implies dom product" AddressParts T = {1,2}
proof
  consider a, b;
  assume
A1: T = 5;
A2: AddressPart Divide(a,b) = <*a,b*> by Th22;
  hereby
    let x be set;
    InsCode Divide(a,b) = 5 by SCMFSA_2:46;
    then
A3: AddressPart Divide(a,b) in AddressParts T by A1;
    assume
    x in dom product" AddressParts T;
    then x in dom AddressPart Divide(a,b) by A3,CARD_3:def 13;
    hence x in {1,2} by A2,FINSEQ_1:4,FINSEQ_3:29;
  end;
  let x be set;
  assume
A4: x in {1,2};
  for f being Function st f in AddressParts T holds x in dom f
  proof
    let f be Function;
    assume
    f in AddressParts T;
    then consider I being Instruction of SCM+FSA such that
A5: f = AddressPart I and
A6: InsCode I = T;
    consider d1, d2 such that
A7: I = Divide(d1,d2) by A1,A6,SCMFSA_2:58;
    f = <*d1,d2*> by A5,A7,Th22;
    hence thesis by A4,FINSEQ_1:4,FINSEQ_3:29;
  end;
  hence thesis by CARD_3:def 13;
end;

theorem Th36:
  T = 6 implies dom product" AddressParts T = {1}
proof
  consider i1;
  assume
A1: T = 6;
A2: AddressPart goto i1 = <*i1*> by Th23;
  hereby
    let x be set;
    InsCode goto i1 = 6 by SCMFSA_2:47;
    then
A3: AddressPart goto i1 in AddressParts T by A1;
    assume
    x in dom product" AddressParts T;
    then x in dom AddressPart goto i1 by A3,CARD_3:def 13;
    hence x in {1} by A2,FINSEQ_1:4,def 8;
  end;
  let x be set;
  assume
A4: x in {1};
  for f being Function st f in AddressParts T holds x in dom f
  proof
    let f be Function;
    assume
    f in AddressParts T;
    then consider I being Instruction of SCM+FSA such that
A5: f = AddressPart I and
A6: InsCode I = T;
    consider i1 such that
A7: I = goto i1 by A1,A6,SCMFSA_2:59;
    f = <*i1*> by A5,A7,Th23;
    hence thesis by A4,FINSEQ_1:4,def 8;
  end;
  hence thesis by CARD_3:def 13;
end;

theorem Th37:
  T = 7 implies dom product" AddressParts T = {1,2}
proof
  consider i1, a;
  assume
A1: T = 7;
A2: AddressPart (a =0_goto i1) = <*i1,a*> by Th24;
  hereby
    let x be set;
    InsCode (a =0_goto i1) = 7 by SCMFSA_2:48;
    then
A3: AddressPart (a =0_goto i1) in AddressParts T by A1;
    assume
    x in dom product" AddressParts T;
    then x in dom AddressPart (a =0_goto i1) by A3,CARD_3:def 13;
    hence x in {1,2} by A2,FINSEQ_1:4,FINSEQ_3:29;
  end;
  let x be set;
  assume
A4: x in {1,2};
  for f being Function st f in AddressParts T holds x in dom f
  proof
    let f be Function;
    assume
    f in AddressParts T;
    then consider I being Instruction of SCM+FSA such that
A5: f = AddressPart I and
A6: InsCode I = T;
    consider i1, a such that
A7: I = a =0_goto i1 by A1,A6,SCMFSA_2:60;
    f = <*i1,a*> by A5,A7,Th24;
    hence thesis by A4,FINSEQ_1:4,FINSEQ_3:29;
  end;
  hence thesis by CARD_3:def 13;
end;

theorem Th38:
  T = 8 implies dom product" AddressParts T = {1,2}
proof
  consider i1, a;
  assume
A1: T = 8;
A2: AddressPart (a >0_goto i1) = <*i1,a*> by Th25;
  hereby
    let x be set;
    InsCode (a >0_goto i1) = 8 by SCMFSA_2:49;
    then
A3: AddressPart (a >0_goto i1) in AddressParts T by A1;
    assume
    x in dom product" AddressParts T;
    then x in dom AddressPart (a >0_goto i1) by A3,CARD_3:def 13;
    hence x in {1,2} by A2,FINSEQ_1:4,FINSEQ_3:29;
  end;
  let x be set;
  assume
A4: x in {1,2};
  for f being Function st f in AddressParts T holds x in dom f
  proof
    let f be Function;
    assume
    f in AddressParts T;
    then consider I being Instruction of SCM+FSA such that
A5: f = AddressPart I and
A6: InsCode I = T;
    consider i1, a such that
A7: I = a >0_goto i1 by A1,A6,SCMFSA_2:61;
    f = <*i1,a*> by A5,A7,Th25;
    hence thesis by A4,FINSEQ_1:4,FINSEQ_3:29;
  end;
  hence thesis by CARD_3:def 13;
end;

theorem Th39:
  T = 9 implies dom product" AddressParts T = {1,2,3}
proof
  consider a, b, f;
  assume
A1: T = 9;
A2: AddressPart (b:=(f,a)) = <*b,f,a*> by MCART_1:def 2;
  hereby
    let x be set;
    InsCode (b:=(f,a)) = 9 by SCMFSA_2:50;
    then
A3: AddressPart (b:=(f,a)) in AddressParts T by A1;
    assume
    x in dom product" AddressParts T;
    then x in dom AddressPart (b:=(f,a)) by A3,CARD_3:def 13;
    hence x in {1,2,3} by A2,FINSEQ_3:1,30;
  end;
  let x be set;
  assume
A4: x in {1,2,3};
  for g being Function st g in AddressParts T holds x in dom g
  proof
    let g be Function;
    assume
    g in AddressParts T;
    then consider I being Instruction of SCM+FSA such that
A5: g = AddressPart I and
A6: InsCode I = T;
    consider a, b, f such that
A7: I = b:=(f,a) by A1,A6,SCMFSA_2:62;
    g = <*b,f,a*> by A5,A7,MCART_1:def 2;
    hence thesis by A4,FINSEQ_3:1,30;
  end;
  hence thesis by CARD_3:def 13;
end;

theorem Th40:
  T = 10 implies dom product" AddressParts T = {1,2,3}
proof
  consider a, b, f;
  assume
A1: T = 10;
A2: AddressPart ((f,a):=b) = <*b,f,a*> by MCART_1:def 2;
  hereby
    let x be set;
    InsCode ((f,a):=b) = 10 by SCMFSA_2:51;
    then
A3: AddressPart ((f,a):=b) in AddressParts T by A1;
    assume
    x in dom product" AddressParts T;
    then x in dom AddressPart ((f,a):=b) by A3,CARD_3:def 13;
    hence x in {1,2,3} by A2,FINSEQ_3:1,30;
  end;
  let x be set;
  assume
A4: x in {1,2,3};
  for g being Function st g in AddressParts T holds x in dom g
  proof
    let g be Function;
    assume
    g in AddressParts T;
    then consider I being Instruction of SCM+FSA such that
A5: g = AddressPart I and
A6: InsCode I = T;
    consider a, b, f such that
A7: I = (f,a):=b by A1,A6,SCMFSA_2:63;
    g = <*b,f,a*> by A5,A7,MCART_1:def 2;
    hence thesis by A4,FINSEQ_3:1,30;
  end;
  hence thesis by CARD_3:def 13;
end;

theorem Th41:
  T = 11 implies dom product" AddressParts T = {1,2}
proof
  consider a, f;
  assume
A1: T = 11;
A2: AddressPart (a:=len f) = <*a,f*> by MCART_1:def 2;
  hereby
    let x be set;
    InsCode (a:=len f) = 11 by SCMFSA_2:52;
    then
A3: AddressPart (a:=len f) in AddressParts T by A1;
    assume
    x in dom product" AddressParts T;
    then x in dom AddressPart (a:=len f) by A3,CARD_3:def 13;
    hence x in {1,2} by A2,FINSEQ_1:4,FINSEQ_3:29;
  end;
  let x be set;
  assume
A4: x in {1,2};
  for g being Function st g in AddressParts T holds x in dom g
  proof
    let g be Function;
    assume
    g in AddressParts T;
    then consider I being Instruction of SCM+FSA such that
A5: g = AddressPart I and
A6: InsCode I = T;
    consider a, f such that
A7: I = a:=len f by A1,A6,SCMFSA_2:64;
    g = <*a,f*> by A5,A7,MCART_1:def 2;
    hence thesis by A4,FINSEQ_1:4,FINSEQ_3:29;
  end;
  hence thesis by CARD_3:def 13;
end;

theorem Th42:
  T = 12 implies dom product" AddressParts T = {1,2}
proof
  consider a, f;
  assume
A1: T = 12;
A2: AddressPart (f:=<0,...,0>a) = <*a,f*> by MCART_1:def 2;
  hereby
    let x be set;
    InsCode (f:=<0,...,0>a) = 12 by SCMFSA_2:53;
    then
A3: AddressPart (f:=<0,...,0>a) in AddressParts T by A1;
    assume
    x in dom product" AddressParts T;
    then x in dom AddressPart (f:=<0,...,0>a) by A3,CARD_3:def 13;
    hence x in {1,2} by A2,FINSEQ_1:4,FINSEQ_3:29;
  end;
  let x be set;
  assume
A4: x in {1,2};
  for g being Function st g in AddressParts T holds x in dom g
  proof
    let g be Function;
    assume
    g in AddressParts T;
    then consider I being Instruction of SCM+FSA such that
A5: g = AddressPart I and
A6: InsCode I = T;
    consider a, f such that
A7: I = f:=<0,...,0>a by A1,A6,SCMFSA_2:65;
    g = <*a,f*> by A5,A7,MCART_1:def 2;
    hence thesis by A4,FINSEQ_1:4,FINSEQ_3:29;
  end;
  hence thesis by CARD_3:def 13;
end;

theorem Th43:
  (product" AddressParts InsCode (a:=b)).1 = SCM+FSA-Data-Loc
proof
A1: InsCode (a:=b) = 1 by SCMFSA_2:42;
  dom product" AddressParts InsCode (a:=b) = {1,2} by Th31,SCMFSA_2:42;
  then
A2: 1 in dom product" AddressParts InsCode (a:=b) by TARSKI:def 2;
  hereby
    let x be set;
    assume
    x in (product" AddressParts InsCode (a:=b)).1;
    then x in pi(AddressParts InsCode (a:=b),1) by A2,CARD_3:def 13;
    then consider f being Function such that
A3: f in AddressParts InsCode (a:=b) and
A4: f.1 = x by CARD_3:def 6;
    consider I being Instruction of SCM+FSA such that
A5: f = AddressPart I and
A6: InsCode I = InsCode (a:=b) by A3;
    consider d1, d2 such that
A7: I = d1:=d2 by A6,SCMFSA_2:42,54;
    x = <*d1,d2*>.1 by A4,A5,A7,Th18
      .= d1 by FINSEQ_1:61;
    hence x in SCM+FSA-Data-Loc by SCMFSA_2:def 4;
  end;
  let x be set;
  assume
  x in SCM+FSA-Data-Loc;
  then reconsider x as Int-Location by SCMFSA_2:28;
  InsCode (x:=b) = 1 by SCMFSA_2:42;
  then AddressPart (x:=b) in AddressParts InsCode (a:=b) by A1;
  then
A8: (AddressPart (x:=b)).1 in pi (AddressParts InsCode (a:=b),1) by
CARD_3:def 6;
  (AddressPart (x:=b)).1 = <*x,b*>.1 by Th18
    .= x by FINSEQ_1:61;
  hence thesis by A2,A8,CARD_3:def 13;
end;

theorem Th44:
  (product" AddressParts InsCode (a:=b)).2 = SCM+FSA-Data-Loc
proof
A1: InsCode (a:=b) = 1 by SCMFSA_2:42;
  dom product" AddressParts InsCode (a:=b) = {1,2} by Th31,SCMFSA_2:42;
  then
A2: 2 in dom product" AddressParts InsCode (a:=b) by TARSKI:def 2;
  hereby
    let x be set;
    assume
    x in (product" AddressParts InsCode (a:=b)).2;
    then x in pi(AddressParts InsCode (a:=b),2) by A2,CARD_3:def 13;
    then consider f being Function such that
A3: f in AddressParts InsCode (a:=b) and
A4: f.2 = x by CARD_3:def 6;
    consider I being Instruction of SCM+FSA such that
A5: f = AddressPart I and
A6: InsCode I = InsCode (a:=b) by A3;
    consider d1, d2 such that
A7: I = d1:=d2 by A6,SCMFSA_2:42,54;
    x = <*d1,d2*>.2 by A4,A5,A7,Th18
      .= d2 by FINSEQ_1:61;
    hence x in SCM+FSA-Data-Loc by SCMFSA_2:def 4;
  end;
  let x be set;
  assume
  x in SCM+FSA-Data-Loc;
  then reconsider x as Int-Location by SCMFSA_2:28;
  InsCode (a:=x) = 1 by SCMFSA_2:42;
  then AddressPart (a:=x) in AddressParts InsCode (a:=b) by A1;
  then
A8: (AddressPart (a:=x)).2 in pi (AddressParts InsCode (a:=b),2) by
CARD_3:def 6;
  (AddressPart (a:=x)).2 = <*a,x*>.2 by Th18
    .= x by FINSEQ_1:61;
  hence thesis by A2,A8,CARD_3:def 13;
end;

theorem Th45:
  (product" AddressParts InsCode AddTo(a,b)).1 = SCM+FSA-Data-Loc
proof
A1: InsCode AddTo(a,b) = 2 by SCMFSA_2:43;
  dom product" AddressParts InsCode AddTo(a,b) = {1,2} by Th32,SCMFSA_2:43;
  then
A2: 1 in dom product" AddressParts InsCode AddTo(a,b) by TARSKI:def 2;
  hereby
    let x be set;
    assume
    x in (product" AddressParts InsCode AddTo(a,b)).1;
    then x in pi(AddressParts InsCode AddTo(a,b),1) by A2,CARD_3:def 13;
    then consider f being Function such that
A3: f in AddressParts InsCode AddTo(a,b) and
A4: f.1 = x by CARD_3:def 6;
    consider I being Instruction of SCM+FSA such that
A5: f = AddressPart I and
A6: InsCode I = InsCode AddTo(a,b) by A3;
    consider d1, d2 such that
A7: I = AddTo(d1,d2) by A6,SCMFSA_2:43,55;
    x = <*d1,d2*>.1 by A4,A5,A7,Th19
      .= d1 by FINSEQ_1:61;
    hence x in SCM+FSA-Data-Loc by SCMFSA_2:def 4;
  end;
  let x be set;
  assume
  x in SCM+FSA-Data-Loc;
  then reconsider x as Int-Location by SCMFSA_2:28;
  InsCode AddTo(x,b) = 2 by SCMFSA_2:43;
  then AddressPart AddTo(x,b) in AddressParts InsCode AddTo(a,b) by A1;
  then
A8: (AddressPart AddTo(x,b)).1 in pi(AddressParts InsCode AddTo(a,b),1) by
CARD_3:def 6;
  (AddressPart AddTo(x,b)).1 = <*x,b*>.1 by Th19
    .= x by FINSEQ_1:61;
  hence thesis by A2,A8,CARD_3:def 13;
end;

theorem Th46:
  (product" AddressParts InsCode AddTo(a,b)).2 = SCM+FSA-Data-Loc
proof
A1: InsCode AddTo(a,b) = 2 by SCMFSA_2:43;
  dom product" AddressParts InsCode AddTo(a,b) = {1,2} by Th32,SCMFSA_2:43;
  then
A2: 2 in dom product" AddressParts InsCode AddTo(a,b) by TARSKI:def 2;
  hereby
    let x be set;
    assume
    x in (product" AddressParts InsCode AddTo(a,b)).2;
    then x in pi(AddressParts InsCode AddTo(a,b),2) by A2,CARD_3:def 13;
    then consider f being Function such that
A3: f in AddressParts InsCode AddTo(a,b) and
A4: f.2 = x by CARD_3:def 6;
    consider I being Instruction of SCM+FSA such that
A5: f = AddressPart I and
A6: InsCode I = InsCode AddTo(a,b) by A3;
    consider d1, d2 such that
A7: I = AddTo(d1,d2) by A6,SCMFSA_2:43,55;
    x = <*d1,d2*>.2 by A4,A5,A7,Th19
      .= d2 by FINSEQ_1:61;
    hence x in SCM+FSA-Data-Loc by SCMFSA_2:def 4;
  end;
  let x be set;
  assume
  x in SCM+FSA-Data-Loc;
  then reconsider x as Int-Location by SCMFSA_2:28;
  InsCode AddTo(a,x) = 2 by SCMFSA_2:43;
  then AddressPart AddTo(a,x) in AddressParts InsCode AddTo(a,b) by A1;
  then
A8: (AddressPart AddTo(a,x)).2 in pi(AddressParts InsCode AddTo(a,b),2) by
CARD_3:def 6;
  (AddressPart AddTo(a,x)).2 = <*a,x*>.2 by Th19
    .= x by FINSEQ_1:61;
  hence thesis by A2,A8,CARD_3:def 13;
end;

theorem Th47:
  (product" AddressParts InsCode SubFrom(a,b)).1 =
  SCM+FSA-Data-Loc
proof
A1: InsCode SubFrom(a,b) = 3 by SCMFSA_2:44;
  dom product" AddressParts InsCode SubFrom(a,b) = {1,2} by Th33,SCMFSA_2:44;
  then
A2: 1 in dom product" AddressParts InsCode SubFrom(a,b) by TARSKI:def 2;
  hereby
    let x be set;
    assume
    x in (product" AddressParts InsCode SubFrom(a,b)).1;
    then x in pi(AddressParts InsCode SubFrom(a,b),1) by A2,CARD_3:def 13;
    then consider f being Function such that
A3: f in AddressParts InsCode SubFrom(a,b) and
A4: f.1 = x by CARD_3:def 6;
    consider I being Instruction of SCM+FSA such that
A5: f = AddressPart I and
A6: InsCode I = InsCode SubFrom(a,b) by A3;
    consider d1, d2 such that
A7: I = SubFrom(d1,d2) by A6,SCMFSA_2:44,56;
    x = <*d1,d2*>.1 by A4,A5,A7,Th20
      .= d1 by FINSEQ_1:61;
    hence x in SCM+FSA-Data-Loc by SCMFSA_2:def 4;
  end;
  let x be set;
  assume
  x in SCM+FSA-Data-Loc;
  then reconsider x as Int-Location by SCMFSA_2:28;
  InsCode SubFrom(x,b) = 3 by SCMFSA_2:44;
  then AddressPart SubFrom(x,b) in AddressParts InsCode SubFrom(a,b) by A1;
  then
A8: (AddressPart SubFrom(x,b)).1 in pi(AddressParts InsCode SubFrom( a,b ),
  1) by CARD_3:def 6;
  (AddressPart SubFrom(x,b)).1 = <*x,b*>.1 by Th20
    .= x by FINSEQ_1:61;
  hence thesis by A2,A8,CARD_3:def 13;
end;

theorem Th48:
  (product" AddressParts InsCode SubFrom(a,b)).2 =
  SCM+FSA-Data-Loc
proof
A1: InsCode SubFrom(a,b) = 3 by SCMFSA_2:44;
  dom product" AddressParts InsCode SubFrom(a,b) = {1,2} by Th33,SCMFSA_2:44;
  then
A2: 2 in dom product" AddressParts InsCode SubFrom(a,b) by TARSKI:def 2;
  hereby
    let x be set;
    assume
    x in (product" AddressParts InsCode SubFrom(a,b)).2;
    then x in pi(AddressParts InsCode SubFrom(a,b),2) by A2,CARD_3:def 13;
    then consider f being Function such that
A3: f in AddressParts InsCode SubFrom(a,b) and
A4: f.2 = x by CARD_3:def 6;
    consider I being Instruction of SCM+FSA such that
A5: f = AddressPart I and
A6: InsCode I = InsCode SubFrom(a,b) by A3;
    consider d1, d2 such that
A7: I = SubFrom(d1,d2) by A6,SCMFSA_2:44,56;
    x = <*d1,d2*>.2 by A4,A5,A7,Th20
      .= d2 by FINSEQ_1:61;
    hence x in SCM+FSA-Data-Loc by SCMFSA_2:def 4;
  end;
  let x be set;
  assume
  x in SCM+FSA-Data-Loc;
  then reconsider x as Int-Location by SCMFSA_2:28;
  InsCode SubFrom(a,x) = 3 by SCMFSA_2:44;
  then AddressPart SubFrom(a,x) in AddressParts InsCode SubFrom(a,b) by A1;
  then
A8: (AddressPart SubFrom(a,x)).2 in pi(AddressParts InsCode SubFrom( a,b ),
  2) by CARD_3:def 6;
  (AddressPart SubFrom(a,x)).2 = <*a,x*>.2 by Th20
    .= x by FINSEQ_1:61;
  hence thesis by A2,A8,CARD_3:def 13;
end;

theorem Th49:
  (product" AddressParts InsCode MultBy(a,b)).1 = SCM+FSA-Data-Loc
proof
A1: InsCode MultBy(a,b) = 4 by SCMFSA_2:45;
  dom product" AddressParts InsCode MultBy(a,b) = {1,2} by Th34,SCMFSA_2:45;
  then
A2: 1 in dom product" AddressParts InsCode MultBy(a,b) by TARSKI:def 2;
  hereby
    let x be set;
    assume
    x in (product" AddressParts InsCode MultBy(a,b)).1;
    then x in pi(AddressParts InsCode MultBy(a,b),1) by A2,CARD_3:def 13;
    then consider f being Function such that
A3: f in AddressParts InsCode MultBy(a,b) and
A4: f.1 = x by CARD_3:def 6;
    consider I being Instruction of SCM+FSA such that
A5: f = AddressPart I and
A6: InsCode I = InsCode MultBy(a,b) by A3;
    consider d1, d2 such that
A7: I = MultBy(d1,d2) by A6,SCMFSA_2:45,57;
    x = <*d1,d2*>.1 by A4,A5,A7,Th21
      .= d1 by FINSEQ_1:61;
    hence x in SCM+FSA-Data-Loc by SCMFSA_2:def 4;
  end;
  let x be set;
  assume
  x in SCM+FSA-Data-Loc;
  then reconsider x as Int-Location by SCMFSA_2:28;
  InsCode MultBy(x,b) = 4 by SCMFSA_2:45;
  then AddressPart MultBy(x,b) in AddressParts InsCode MultBy(a,b) by A1;
  then
A8: (AddressPart MultBy(x,b)).1 in pi(AddressParts InsCode MultBy(a, b), 1)
  by CARD_3:def 6;
  (AddressPart MultBy(x,b)).1 = <*x,b*>.1 by Th21
    .= x by FINSEQ_1:61;
  hence thesis by A2,A8,CARD_3:def 13;
end;

theorem Th50:
  (product" AddressParts InsCode MultBy(a,b)).2 = SCM+FSA-Data-Loc
proof
A1: InsCode MultBy(a,b) = 4 by SCMFSA_2:45;
  dom product" AddressParts InsCode MultBy(a,b) = {1,2} by Th34,SCMFSA_2:45;
  then
A2: 2 in dom product" AddressParts InsCode MultBy(a,b) by TARSKI:def 2;
  hereby
    let x be set;
    assume
    x in (product" AddressParts InsCode MultBy(a,b)).2;
    then x in pi(AddressParts InsCode MultBy(a,b),2) by A2,CARD_3:def 13;
    then consider f being Function such that
A3: f in AddressParts InsCode MultBy(a,b) and
A4: f.2 = x by CARD_3:def 6;
    consider I being Instruction of SCM+FSA such that
A5: f = AddressPart I and
A6: InsCode I = InsCode MultBy(a,b) by A3;
    consider d1, d2 such that
A7: I = MultBy(d1,d2) by A6,SCMFSA_2:45,57;
    x = <*d1,d2*>.2 by A4,A5,A7,Th21
      .= d2 by FINSEQ_1:61;
    hence x in SCM+FSA-Data-Loc by SCMFSA_2:def 4;
  end;
  let x be set;
  assume
  x in SCM+FSA-Data-Loc;
  then reconsider x as Int-Location by SCMFSA_2:28;
  InsCode MultBy(a,x) = 4 by SCMFSA_2:45;
  then AddressPart MultBy(a,x) in AddressParts InsCode MultBy(a,b) by A1;
  then
A8: (AddressPart MultBy(a,x)).2 in pi(AddressParts InsCode MultBy(a, b), 2)
  by CARD_3:def 6;
  (AddressPart MultBy(a,x)).2 = <*a,x*>.2 by Th21
    .= x by FINSEQ_1:61;
  hence thesis by A2,A8,CARD_3:def 13;
end;

theorem Th51:
  (product" AddressParts InsCode Divide(a,b)).1 = SCM+FSA-Data-Loc
proof
A1: InsCode Divide(a,b) = 5 by SCMFSA_2:46;
  dom product" AddressParts InsCode Divide(a,b) = {1,2} by Th35,SCMFSA_2:46;
  then
A2: 1 in dom product" AddressParts InsCode Divide(a,b) by TARSKI:def 2;
  hereby
    let x be set;
    assume
    x in (product" AddressParts InsCode Divide(a,b)).1;
    then x in pi(AddressParts InsCode Divide(a,b),1) by A2,CARD_3:def 13;
    then consider f being Function such that
A3: f in AddressParts InsCode Divide(a,b) and
A4: f.1 = x by CARD_3:def 6;
    consider I being Instruction of SCM+FSA such that
A5: f = AddressPart I and
A6: InsCode I = InsCode Divide(a,b) by A3;
    consider d1, d2 such that
A7: I = Divide(d1,d2) by A6,SCMFSA_2:46,58;
    x = <*d1,d2*>.1 by A4,A5,A7,Th22
      .= d1 by FINSEQ_1:61;
    hence x in SCM+FSA-Data-Loc by SCMFSA_2:def 4;
  end;
  let x be set;
  assume
  x in SCM+FSA-Data-Loc;
  then reconsider x as Int-Location by SCMFSA_2:28;
  InsCode Divide(x,b) = 5 by SCMFSA_2:46;
  then AddressPart Divide(x,b) in AddressParts InsCode Divide(a,b) by A1;
  then
A8: (AddressPart Divide(x,b)).1 in pi(AddressParts InsCode Divide(a, b), 1)
  by CARD_3:def 6;
  (AddressPart Divide(x,b)).1 = <*x,b*>.1 by Th22
    .= x by FINSEQ_1:61;
  hence thesis by A2,A8,CARD_3:def 13;
end;

theorem Th52:
  (product" AddressParts InsCode Divide(a,b)).2 = SCM+FSA-Data-Loc
proof
A1: InsCode Divide(a,b) = 5 by SCMFSA_2:46;
  dom product" AddressParts InsCode Divide(a,b) = {1,2} by Th35,SCMFSA_2:46;
  then
A2: 2 in dom product" AddressParts InsCode Divide(a,b) by TARSKI:def 2;
  hereby
    let x be set;
    assume
    x in (product" AddressParts InsCode Divide(a,b)).2;
    then x in pi(AddressParts InsCode Divide(a,b),2) by A2,CARD_3:def 13;
    then consider f being Function such that
A3: f in AddressParts InsCode Divide(a,b) and
A4: f.2 = x by CARD_3:def 6;
    consider I being Instruction of SCM+FSA such that
A5: f = AddressPart I and
A6: InsCode I = InsCode Divide(a,b) by A3;
    consider d1, d2 such that
A7: I = Divide(d1,d2) by A6,SCMFSA_2:46,58;
    x = <*d1,d2*>.2 by A4,A5,A7,Th22
      .= d2 by FINSEQ_1:61;
    hence x in SCM+FSA-Data-Loc by SCMFSA_2:def 4;
  end;
  let x be set;
  assume
  x in SCM+FSA-Data-Loc;
  then reconsider x as Int-Location by SCMFSA_2:28;
  InsCode Divide(a,x) = 5 by SCMFSA_2:46;
  then AddressPart Divide(a,x) in AddressParts InsCode Divide(a,b) by A1;
  then
A8: (AddressPart Divide(a,x)).2 in pi(AddressParts InsCode Divide(a, b), 2)
  by CARD_3:def 6;
  (AddressPart Divide(a,x)).2 = <*a,x*>.2 by Th22
    .= x by FINSEQ_1:61;
  hence thesis by A2,A8,CARD_3:def 13;
end;

theorem Th53:
  (product" AddressParts InsCode goto i1).1 = NAT
proof
  dom product" AddressParts InsCode goto i1 = {1} by Th36,SCMFSA_2:47;
  then
A1: 1 in dom product" AddressParts InsCode goto i1 by TARSKI:def 1;
  hereby
    let x be set;
    assume
    x in (product" AddressParts InsCode goto i1).1;
    then x in pi(AddressParts InsCode goto i1,1) by A1,CARD_3:93;
    then consider g being Function such that
A2: g in AddressParts InsCode goto i1 and
A3: x = g.1 by CARD_3:def 6;
    consider I being Instruction of SCM+FSA such that
A4: g = AddressPart I and
A5: InsCode I = InsCode goto i1 by A2;
    consider i2 such that
A6: I = goto i2 by A5,SCMFSA_2:47,59;
    g = <*i2*> by A4,A6,Th23;
    then x = i2 by A3,FINSEQ_1:def 8;
    hence x in NAT by AMI_1:def 4;
  end;
  let x be set;
  assume
  x in NAT;
  then reconsider x as Instruction-Location of SCM+FSA by AMI_1:def 4;
A7: <*x*>.1 = x by FINSEQ_1:def 8;
  InsCode goto i1 = 6 by SCMFSA_2:47;
  then
A8: InsCode goto i1 = InsCode goto x by SCMFSA_2:47;
  AddressPart goto x = <*x*> by Th23;
  then <*x*> in AddressParts InsCode goto i1 by A8;
  then x in pi(AddressParts InsCode goto i1,1) by A7,CARD_3:def 6;
  hence thesis by A1,CARD_3:93;
end;

theorem Th54:
  (product" AddressParts InsCode (a =0_goto i1)).1 = NAT
proof
  dom product" AddressParts InsCode (a =0_goto i1) = {1,2} by Th37,SCMFSA_2:48;
  then
A1: 1 in dom product" AddressParts InsCode (a =0_goto i1) by TARSKI:def 2;
  hereby
    let x be set;
    assume
    x in (product" AddressParts InsCode (a =0_goto i1)).1;
    then x in pi(AddressParts InsCode (a =0_goto i1),1) by A1,CARD_3:93;
    then consider g being Function such that
A2: g in AddressParts InsCode (a =0_goto i1) and
A3: x = g.1 by CARD_3:def 6;
    consider I being Instruction of SCM+FSA such that
A4: g = AddressPart I and
A5: InsCode I = InsCode (a =0_goto i1) by A2;
    consider i2, b such that
A6: I = b =0_goto i2 by A5,SCMFSA_2:48,60;
    g = <*i2,b*> by A4,A6,Th24;
    then x = i2 by A3,FINSEQ_1:61;
    hence x in NAT by AMI_1:def 4;
  end;
  let x be set;
  assume
  x in NAT;
  then reconsider x as Instruction-Location of SCM+FSA by AMI_1:def 4;
A7: <*x,a*>.1 = x by FINSEQ_1:61;
  InsCode (a =0_goto i1) = 7 by SCMFSA_2:48;
  then
A8: InsCode (a =0_goto i1) = InsCode (a =0_goto x) by SCMFSA_2:48;
  AddressPart (a =0_goto x) = <*x,a*> by Th24;
  then <*x,a*> in AddressParts InsCode (a =0_goto i1) by A8;
  then x in pi(AddressParts InsCode (a =0_goto i1),1) by A7,CARD_3:def 6;
  hence thesis by A1,CARD_3:93;
end;

theorem Th55:
  (product" AddressParts InsCode (a =0_goto i1)).2 =
  SCM+FSA-Data-Loc
proof
A1: InsCode (a =0_goto i1) = 7 by SCMFSA_2:48;
  dom product" AddressParts InsCode (a =0_goto i1) = {1,2} by Th37,SCMFSA_2:48;
  then
A2: 2 in dom product" AddressParts InsCode (a =0_goto i1) by TARSKI:def 2;
  hereby
    let x be set;
    assume
    x in (product" AddressParts InsCode (a =0_goto i1)).2;
    then x in pi(AddressParts InsCode (a =0_goto i1),2) by A2,CARD_3:def 13;
    then consider f being Function such that
A3: f in AddressParts InsCode (a =0_goto i1) and
A4: f.2 = x by CARD_3:def 6;
    consider I being Instruction of SCM+FSA such that
A5: f = AddressPart I and
A6: InsCode I = InsCode (a =0_goto i1) by A3;
    consider i2, b such that
A7: I = b =0_goto i2 by A6,SCMFSA_2:48,60;
    x = <*i2,b*>.2 by A4,A5,A7,Th24
      .= b by FINSEQ_1:61;
    hence x in SCM+FSA-Data-Loc by SCMFSA_2:def 4;
  end;
  let x be set;
  assume
  x in SCM+FSA-Data-Loc;
  then reconsider x as Int-Location by SCMFSA_2:28;
  InsCode (x =0_goto i1) = 7 by SCMFSA_2:48;
  then
  AddressPart (x =0_goto i1) in AddressParts InsCode (a =0_goto i1) by A1;
  then
A8: (AddressPart (x =0_goto i1)).2 in pi(AddressParts InsCode (a =0_goto i1
  ),2) by CARD_3:def 6;
  (AddressPart (x =0_goto i1)).2 = <*i1,x*>.2 by Th24
    .= x by FINSEQ_1:61;
  hence thesis by A2,A8,CARD_3:def 13;
end;

theorem Th56:
  (product" AddressParts InsCode (a >0_goto i1)).1 = NAT
proof
  dom product" AddressParts InsCode (a >0_goto i1) = {1,2} by Th38,SCMFSA_2:49;
  then
A1: 1 in dom product" AddressParts InsCode (a >0_goto i1) by TARSKI:def 2;
  hereby
    let x be set;
    assume
    x in (product" AddressParts InsCode (a >0_goto i1)).1;
    then x in pi(AddressParts InsCode (a >0_goto i1),1) by A1,CARD_3:93;
    then consider g being Function such that
A2: g in AddressParts InsCode (a >0_goto i1) and
A3: x = g.1 by CARD_3:def 6;
    consider I being Instruction of SCM+FSA such that
A4: g = AddressPart I and
A5: InsCode I = InsCode (a >0_goto i1) by A2;
    consider i2, b such that
A6: I = b >0_goto i2 by A5,SCMFSA_2:49,61;
    g = <*i2,b*> by A4,A6,Th25;
    then x = i2 by A3,FINSEQ_1:61;
    hence x in NAT by AMI_1:def 4;
  end;
  let x be set;
  assume
  x in NAT;
  then reconsider x as Instruction-Location of SCM+FSA by AMI_1:def 4;
A7: <*x,a*>.1 = x by FINSEQ_1:61;
  InsCode (a >0_goto i1) = 8 by SCMFSA_2:49;
  then
A8: InsCode (a >0_goto i1) = InsCode (a >0_goto x) by SCMFSA_2:49;
  AddressPart (a >0_goto x) = <*x,a*> by Th25;
  then <*x,a*> in AddressParts InsCode (a >0_goto i1) by A8;
  then x in pi(AddressParts InsCode (a >0_goto i1),1) by A7,CARD_3:def 6;
  hence thesis by A1,CARD_3:93;
end;

theorem Th57:
  (product" AddressParts InsCode (a >0_goto i1)).2 =
  SCM+FSA-Data-Loc
proof
A1: InsCode (a >0_goto i1) = 8 by SCMFSA_2:49;
  dom product" AddressParts InsCode (a >0_goto i1) = {1,2} by Th38,SCMFSA_2:49;
  then
A2: 2 in dom product" AddressParts InsCode (a >0_goto i1) by TARSKI:def 2;
  hereby
    let x be set;
    assume
    x in (product" AddressParts InsCode (a >0_goto i1)).2;
    then x in pi(AddressParts InsCode (a >0_goto i1),2) by A2,CARD_3:def 13;
    then consider f being Function such that
A3: f in AddressParts InsCode (a >0_goto i1) and
A4: f.2 = x by CARD_3:def 6;
    consider I being Instruction of SCM+FSA such that
A5: f = AddressPart I and
A6: InsCode I = InsCode (a >0_goto i1) by A3;
    consider i2, b such that
A7: I = b >0_goto i2 by A6,SCMFSA_2:49,61;
    x = <*i2,b*>.2 by A4,A5,A7,Th25
      .= b by FINSEQ_1:61;
    hence x in SCM+FSA-Data-Loc by SCMFSA_2:def 4;
  end;
  let x be set;
  assume
  x in SCM+FSA-Data-Loc;
  then reconsider x as Int-Location by SCMFSA_2:28;
  InsCode (x >0_goto i1) = 8 by SCMFSA_2:49;
  then
  AddressPart (x >0_goto i1) in AddressParts InsCode (a >0_goto i1) by A1;
  then
A8: (AddressPart (x >0_goto i1)).2 in pi(AddressParts InsCode (a >0_goto i1
  ),2) by CARD_3:def 6;
  (AddressPart (x >0_goto i1)).2 = <*i1,x*>.2 by Th25
    .= x by FINSEQ_1:61;
  hence thesis by A2,A8,CARD_3:def 13;
end;

theorem Th58:
  (product" AddressParts InsCode (b:=(f,a))).1 = SCM+FSA-Data-Loc
proof
  dom product" AddressParts InsCode (b:=(f,a)) = {1,2,3} by Th39,SCMFSA_2:50;
  then
A1: 1 in dom product" AddressParts InsCode (b:=(f,a)) by ENUMSET1:def 1;
  hereby
    let x be set;
    assume
    x in (product" AddressParts InsCode (b:=(f,a))).1;
    then x in pi(AddressParts InsCode (b:=(f,a)),1) by A1,CARD_3:93;
    then consider g being Function such that
A2: g in AddressParts InsCode (b:=(f,a)) and
A3: x = g.1 by CARD_3:def 6;
    consider I being Instruction of SCM+FSA such that
A4: g = AddressPart I and
A5: InsCode I = InsCode (b:=(f,a)) by A2;
    consider a, b, f such that
A6: I = b:=(f,a) by A5,SCMFSA_2:50,62;
    g = <*b,f,a*> by A4,A6,MCART_1:def 2;
    then x = b by A3,FINSEQ_1:62;
    hence x in SCM+FSA-Data-Loc by SCMFSA_2:def 4;
  end;
  let x be set;
  assume
  x in SCM+FSA-Data-Loc;
  then reconsider x as Int-Location by SCMFSA_2:28;
A7: <*x,f,a*>.1 = x by FINSEQ_1:62;
  InsCode (b:=(f,a)) = 9 by SCMFSA_2:50;
  then
A8: InsCode (b:=(f,a)) = InsCode (x:=(f,a)) by SCMFSA_2:50;
  AddressPart (x:=(f,a)) = <*x,f,a*> by MCART_1:def 2;
  then <*x,f,a*> in AddressParts InsCode (b:=(f,a)) by A8;
  then x in pi(AddressParts InsCode (b:=(f,a)),1) by A7,CARD_3:def 6;
  hence thesis by A1,CARD_3:93;
end;

theorem Th59:
  (product" AddressParts InsCode (b:=(f,a))).2 = SCM+FSA-Data*-Loc
proof
  dom product" AddressParts InsCode (b:=(f,a)) = {1,2,3} by Th39,SCMFSA_2:50;
  then
A1: 2 in dom product" AddressParts InsCode (b:=(f,a)) by ENUMSET1:def 1;
  hereby
    let x be set;
    assume
    x in (product" AddressParts InsCode (b:=(f,a))).2;
    then x in pi(AddressParts InsCode (b:=(f,a)),2) by A1,CARD_3:93;
    then consider g being Function such that
A2: g in AddressParts InsCode (b:=(f,a)) and
A3: x = g.2 by CARD_3:def 6;
    consider I being Instruction of SCM+FSA such that
A4: g = AddressPart I and
A5: InsCode I = InsCode (b:=(f,a)) by A2;
    consider a, b, f such that
A6: I = b:=(f,a) by A5,SCMFSA_2:50,62;
    g = <*b,f,a*> by A4,A6,MCART_1:def 2;
    then x = f by A3,FINSEQ_1:62;
    hence x in SCM+FSA-Data*-Loc by SCMFSA_2:def 5;
  end;
  let x be set;
  assume
  x in SCM+FSA-Data*-Loc;
  then reconsider x as FinSeq-Location by SCMFSA_2:29;
A7: <*b,x,a*>.2 = x by FINSEQ_1:62;
  InsCode (b:=(f,a)) = 9 by SCMFSA_2:50;
  then
A8: InsCode (b:=(f,a)) = InsCode (b:=(x,a)) by SCMFSA_2:50;
  AddressPart (b:=(x,a)) = <*b,x,a*> by MCART_1:def 2;
  then <*b,x,a*> in AddressParts InsCode (b:=(f,a)) by A8;
  then x in pi(AddressParts InsCode (b:=(f,a)),2) by A7,CARD_3:def 6;
  hence thesis by A1,CARD_3:93;
end;

theorem Th60:
  (product" AddressParts InsCode (b:=(f,a))).3 = SCM+FSA-Data-Loc
proof
  dom product" AddressParts InsCode (b:=(f,a)) = {1,2,3} by Th39,SCMFSA_2:50;
  then
A1: 3 in dom product" AddressParts InsCode (b:=(f,a)) by ENUMSET1:def 1;
  hereby
    let x be set;
    assume
    x in (product" AddressParts InsCode (b:=(f,a))).3;
    then x in pi(AddressParts InsCode (b:=(f,a)),3) by A1,CARD_3:93;
    then consider g being Function such that
A2: g in AddressParts InsCode (b:=(f,a)) and
A3: x = g.3 by CARD_3:def 6;
    consider I being Instruction of SCM+FSA such that
A4: g = AddressPart I and
A5: InsCode I = InsCode (b:=(f,a)) by A2;
    consider a, b, f such that
A6: I = b:=(f,a) by A5,SCMFSA_2:50,62;
    g = <*b,f,a*> by A4,A6,MCART_1:def 2;
    then x = a by A3,FINSEQ_1:62;
    hence x in SCM+FSA-Data-Loc by SCMFSA_2:def 4;
  end;
  let x be set;
  assume
  x in SCM+FSA-Data-Loc;
  then reconsider x as Int-Location by SCMFSA_2:28;
A7: <*b,f,x*>.3 = x by FINSEQ_1:62;
  InsCode (b:=(f,a)) = 9 by SCMFSA_2:50;
  then
A8: InsCode (b:=(f,a)) = InsCode (b:=(f,x)) by SCMFSA_2:50;
  AddressPart (b:=(f,x)) = <*b,f,x*> by MCART_1:def 2;
  then <*b,f,x*> in AddressParts InsCode (b:=(f,a)) by A8;
  then x in pi(AddressParts InsCode (b:=(f,a)),3) by A7,CARD_3:def 6;
  hence thesis by A1,CARD_3:93;
end;

theorem Th61:
  (product" AddressParts InsCode ((f,a):=b)).1 = SCM+FSA-Data-Loc
proof
  dom product" AddressParts InsCode ((f,a):=b) = {1,2,3} by Th40,SCMFSA_2:51;
  then
A1: 1 in dom product" AddressParts InsCode ((f,a):=b) by ENUMSET1:def 1;
  hereby
    let x be set;
    assume
    x in (product" AddressParts InsCode ((f,a):=b)).1;
    then x in pi(AddressParts InsCode ((f,a):=b),1) by A1,CARD_3:93;
    then consider g being Function such that
A2: g in AddressParts InsCode ((f,a):=b) and
A3: x = g.1 by CARD_3:def 6;
    consider I being Instruction of SCM+FSA such that
A4: g = AddressPart I and
A5: InsCode I = InsCode ((f,a):=b) by A2;
    consider a, b, f such that
A6: I = (f,a):=b by A5,SCMFSA_2:51,63;
    g = <*b,f,a*> by A4,A6,MCART_1:def 2;
    then x = b by A3,FINSEQ_1:62;
    hence x in SCM+FSA-Data-Loc by SCMFSA_2:def 4;
  end;
  let x be set;
  assume
  x in SCM+FSA-Data-Loc;
  then reconsider x as Int-Location by SCMFSA_2:28;
A7: <*x,f,a*>.1 = x by FINSEQ_1:62;
  InsCode ((f,a):=b) = 10 by SCMFSA_2:51;
  then
A8: InsCode ((f,a):=b) = InsCode ((f,a):=x) by SCMFSA_2:51;
  AddressPart ((f,a):=x) = <*x,f,a*> by MCART_1:def 2;
  then <*x,f,a*> in AddressParts InsCode ((f,a):=b) by A8;
  then x in pi(AddressParts InsCode ((f,a):=b),1) by A7,CARD_3:def 6;
  hence thesis by A1,CARD_3:93;
end;

theorem Th62:
  (product" AddressParts InsCode ((f,a):=b)).2 = SCM+FSA-Data*-Loc
proof
  dom product" AddressParts InsCode ((f,a):=b) = {1,2,3} by Th40,SCMFSA_2:51;
  then
A1: 2 in dom product" AddressParts InsCode ((f,a):=b) by ENUMSET1:def 1;
  hereby
    let x be set;
    assume
    x in (product" AddressParts InsCode ((f,a):=b)).2;
    then x in pi(AddressParts InsCode ((f,a):=b),2) by A1,CARD_3:93;
    then consider g being Function such that
A2: g in AddressParts InsCode ((f,a):=b) and
A3: x = g.2 by CARD_3:def 6;
    consider I being Instruction of SCM+FSA such that
A4: g = AddressPart I and
A5: InsCode I = InsCode ((f,a):=b) by A2;
    consider a, b, f such that
A6: I = (f,a):=b by A5,SCMFSA_2:51,63;
    g = <*b,f,a*> by A4,A6,MCART_1:def 2;
    then x = f by A3,FINSEQ_1:62;
    hence x in SCM+FSA-Data*-Loc by SCMFSA_2:def 5;
  end;
  let x be set;
  assume
  x in SCM+FSA-Data*-Loc;
  then reconsider x as FinSeq-Location by SCMFSA_2:29;
A7: <*b,x,a*>.2 = x by FINSEQ_1:62;
  InsCode ((f,a):=b) = 10 by SCMFSA_2:51;
  then
A8: InsCode ((f,a):=b) = InsCode ((x,a):=b) by SCMFSA_2:51;
  AddressPart ((x,a):=b) = <*b,x,a*> by MCART_1:def 2;
  then <*b,x,a*> in AddressParts InsCode ((f,a):=b) by A8;
  then x in pi(AddressParts InsCode ((f,a):=b),2) by A7,CARD_3:def 6;
  hence thesis by A1,CARD_3:93;
end;

theorem Th63:
  (product" AddressParts InsCode ((f,a):=b)).3 = SCM+FSA-Data-Loc
proof
  dom product" AddressParts InsCode ((f,a):=b) = {1,2,3} by Th40,SCMFSA_2:51;
  then
A1: 3 in dom product" AddressParts InsCode ((f,a):=b) by ENUMSET1:def 1;
  hereby
    let x be set;
    assume
    x in (product" AddressParts InsCode ((f,a):=b)).3;
    then x in pi(AddressParts InsCode ((f,a):=b),3) by A1,CARD_3:93;
    then consider g being Function such that
A2: g in AddressParts InsCode ((f,a):=b) and
A3: x = g.3 by CARD_3:def 6;
    consider I being Instruction of SCM+FSA such that
A4: g = AddressPart I and
A5: InsCode I = InsCode ((f,a):=b) by A2;
    consider a, b, f such that
A6: I = (f,a):=b by A5,SCMFSA_2:51,63;
    g = <*b,f,a*> by A4,A6,MCART_1:def 2;
    then x = a by A3,FINSEQ_1:62;
    hence x in SCM+FSA-Data-Loc by SCMFSA_2:def 4;
  end;
  let x be set;
  assume
  x in SCM+FSA-Data-Loc;
  then reconsider x as Int-Location by SCMFSA_2:28;
A7: <*b,f,x*>.3 = x by FINSEQ_1:62;
  InsCode ((f,a):=b) = 10 by SCMFSA_2:51;
  then
A8: InsCode ((f,a):=b) = InsCode ((f,x):=b) by SCMFSA_2:51;
  AddressPart ((f,x):=b) = <*b,f,x*> by MCART_1:def 2;
  then <*b,f,x*> in AddressParts InsCode ((f,a):=b) by A8;
  then x in pi(AddressParts InsCode ((f,a):=b),3) by A7,CARD_3:def 6;
  hence thesis by A1,CARD_3:93;
end;

theorem Th64:
  (product" AddressParts InsCode (a:=len f)).1 = SCM+FSA-Data-Loc
proof
  dom product" AddressParts InsCode (a:=len f) = {1,2} by Th41,SCMFSA_2:52;
  then
A1: 1 in dom product" AddressParts InsCode (a:=len f) by TARSKI:def 2;
  hereby
    let x be set;
    assume
    x in (product" AddressParts InsCode (a:=len f)).1;
    then x in pi(AddressParts InsCode (a:=len f),1) by A1,CARD_3:93;
    then consider g being Function such that
A2: g in AddressParts InsCode (a:=len f) and
A3: x = g.1 by CARD_3:def 6;
    consider I being Instruction of SCM+FSA such that
A4: g = AddressPart I and
A5: InsCode I = InsCode (a:=len f) by A2;
    consider a, f such that
A6: I = a:=len f by A5,SCMFSA_2:52,64;
    g = <*a,f*> by A4,A6,MCART_1:def 2;
    then x = a by A3,FINSEQ_1:61;
    hence x in SCM+FSA-Data-Loc by SCMFSA_2:def 4;
  end;
  let x be set;
  assume
  x in SCM+FSA-Data-Loc;
  then reconsider x as Int-Location by SCMFSA_2:28;
A7: <*x,f*>.1 = x by FINSEQ_1:61;
  InsCode (a:=len f) = 11 by SCMFSA_2:52;
  then
A8: InsCode (x:=len f) = InsCode (a:=len f) by SCMFSA_2:52;
  AddressPart (x:=len f) = <*x,f*> by MCART_1:def 2;
  then <*x,f*> in AddressParts InsCode (a:=len f) by A8;
  then x in pi(AddressParts InsCode (a:=len f),1) by A7,CARD_3:def 6;
  hence thesis by A1,CARD_3:93;
end;

theorem Th65:
  (product" AddressParts InsCode (a:=len f)).2 = SCM+FSA-Data*-Loc
proof
  dom product" AddressParts InsCode (a:=len f) = {1,2} by Th41,SCMFSA_2:52;
  then
A1: 2 in dom product" AddressParts InsCode (a:=len f) by TARSKI:def 2;
  hereby
    let x be set;
    assume
    x in (product" AddressParts InsCode (a:=len f)).2;
    then x in pi(AddressParts InsCode (a:=len f),2) by A1,CARD_3:def 13;
    then consider g being Function such that
A2: g in AddressParts InsCode (a:=len f) and
A3: g.2 = x by CARD_3:def 6;
    consider I being Instruction of SCM+FSA such that
A4: g = AddressPart I and
A5: InsCode I = InsCode (a:=len f) by A2;
    consider a, f such that
A6: I = a:=len f by A5,SCMFSA_2:52,64;
    x = <*a,f*>.2 by A3,A4,A6,MCART_1:def 2
      .= f by FINSEQ_1:61;
    hence x in SCM+FSA-Data*-Loc by SCMFSA_2:def 5;
  end;
  let x be set;
  assume
  x in SCM+FSA-Data*-Loc;
  then reconsider x as FinSeq-Location by SCMFSA_2:29;
A7: <*a,x*>.2 = x by FINSEQ_1:61;
  InsCode (a:=len f) = 11 by SCMFSA_2:52;
  then
A8: InsCode (a:=len x) = InsCode (a:=len f) by SCMFSA_2:52;
  AddressPart (a:=len x) = <*a,x*> by MCART_1:def 2;
  then <*a,x*> in AddressParts InsCode (a:=len f) by A8;
  then x in pi(AddressParts InsCode (a:=len f),2) by A7,CARD_3:def 6;
  hence thesis by A1,CARD_3:93;
end;

theorem Th66:
  (product" AddressParts InsCode (f:=<0,...,0>a)).1 =
  SCM+FSA-Data-Loc
proof
  dom product" AddressParts InsCode (f:=<0,...,0>a) = {1,2} by Th42,SCMFSA_2:53
;
  then
A1: 1 in dom product" AddressParts InsCode (f:=<0,...,0>a) by TARSKI:def 2;
  hereby
    let x be set;
    assume
    x in (product" AddressParts InsCode (f:=<0,...,0>a)).1;
    then x in pi(AddressParts InsCode (f:=<0,...,0>a),1) by A1,CARD_3:93;
    then consider g being Function such that
A2: g in AddressParts InsCode (f:=<0,...,0>a) and
A3: x = g.1 by CARD_3:def 6;
    consider I being Instruction of SCM+FSA such that
A4: g = AddressPart I and
A5: InsCode I = InsCode (f:=<0,...,0>a) by A2;
    consider a, f such that
A6: I = f:=<0,...,0>a by A5,SCMFSA_2:53,65;
    g = <*a,f*> by A4,A6,MCART_1:def 2;
    then x = a by A3,FINSEQ_1:61;
    hence x in SCM+FSA-Data-Loc by SCMFSA_2:def 4;
  end;
  let x be set;
  assume
  x in SCM+FSA-Data-Loc;
  then reconsider x as Int-Location by SCMFSA_2:28;
A7: <*x,f*>.1 = x by FINSEQ_1:61;
  InsCode (f:=<0,...,0>a) = 12 by SCMFSA_2:53;
  then
A8: InsCode (f:=<0,...,0>x) = InsCode (f:=<0,...,0>a) by SCMFSA_2:53;
  AddressPart (f:=<0,...,0>x) = <*x,f*> by MCART_1:def 2;
  then <*x,f*> in AddressParts InsCode (f:=<0,...,0>a) by A8;
  then x in pi(AddressParts InsCode (f:=<0,...,0>a),1) by A7,CARD_3:def 6;
  hence thesis by A1,CARD_3:93;
end;

theorem Th67:
  (product" AddressParts InsCode (f:=<0,...,0>a)).2 =
  SCM+FSA-Data*-Loc
proof
  dom product" AddressParts InsCode (f:=<0,...,0>a) = {1,2} by Th42,SCMFSA_2:53
;
  then
A1: 2 in dom product" AddressParts InsCode (f:=<0,...,0>a) by TARSKI:def 2;
  hereby
    let x be set;
    assume
    x in (product" AddressParts InsCode (f:=<0,...,0>a)).2;
    then x in pi (AddressParts InsCode (f:=<0,...,0>a),2) by A1,CARD_3:def 13;
    then consider g being Function such that
A2: g in AddressParts InsCode (f:=<0,...,0>a) and
A3: g.2 = x by CARD_3:def 6;
    consider I being Instruction of SCM+FSA such that
A4: g = AddressPart I and
A5: InsCode I = InsCode (f:=<0,...,0>a) by A2;
    consider a, f such that
A6: I = f:=<0,...,0>a by A5,SCMFSA_2:53,65;
    x = <*a,f*>.2 by A3,A4,A6,MCART_1:def 2
      .= f by FINSEQ_1:61;
    hence x in SCM+FSA-Data*-Loc by SCMFSA_2:def 5;
  end;
  let x be set;
  assume
  x in SCM+FSA-Data*-Loc;
  then reconsider x as FinSeq-Location by SCMFSA_2:29;
A7: <*a,x*>.2 = x by FINSEQ_1:61;
  InsCode (f:=<0,...,0>a) = 12 by SCMFSA_2:53;
  then
A8: InsCode (x:=<0,...,0>a) = InsCode (f:=<0,...,0>a) by SCMFSA_2:53;
  AddressPart (x:=<0,...,0>a) = <*a,x*> by MCART_1:def 2;
  then <*a,x*> in AddressParts InsCode (f:=<0,...,0>a) by A8;
  then x in pi(AddressParts InsCode (f:=<0,...,0>a),2) by A7,CARD_3:def 6;
  hence thesis by A1,CARD_3:93;
end;

Lm5: for l being Instruction-Location of SCM+FSA, i being Instruction of
SCM+FSA holds (for s being State of SCM+FSA st IC s = l & s.l = i holds Exec(i,
s).IC SCM+FSA = Next IC s) implies NIC(i, l) = {Next l}

proof
  consider t being State of SCM+FSA;
  let l be Instruction-Location of SCM+FSA, i be Instruction of SCM+FSA;
  reconsider I = i as Element of ObjectKind l by AMI_1:def 14;
  assume

A1: for s being State of SCM+FSA st IC s = l & s.l = i holds Exec(i, s).
  IC SCM+FSA = Next IC s;

  hereby
    let x be set;
    assume
    x in NIC(i,l);

    then
    ex s being State of SCM+FSA st x = IC Following s & IC s = l & s.l
    = i;

    then x = Next l by A1;
    hence x in {Next l} by TARSKI:def 1;
  end;
  l in NAT by AMI_1:def 4;
  then reconsider il1 = l as Element of ObjectKind IC SCM+FSA by AMI_1:def 11;
  let x be set;
  set u = t+*((IC SCM+FSA, l)-->(il1, I));
A2: u.l = i by AMI_1:129;
  assume
  x in {Next l};
  then
A3: x = Next l by TARSKI:def 1;
A4: IC u = l by AMI_1:129;
  then IC Following u = Next l by A1,A2;
  hence thesis by A3,A4,A2;
end;

Lm6: for i being Instruction of SCM+FSA holds (for l being
Instruction-Location of SCM+FSA holds NIC(i,l)={Next l}) implies JUMP i is
empty

proof
  reconsider p=0, q=1 as Element of NAT;
  let i be Instruction of SCM+FSA;
  assume
A1: for l being Instruction-Location of SCM+FSA holds NIC(i,l)={Next l};

  set X = { NIC(i,f) where f is Instruction-Location of SCM+FSA: not
  contradiction };

  reconsider p, q as Instruction-Location of SCM+FSA by AMI_1:def 4;
  assume
  not thesis;
  then consider x being set such that
A2: x in meet X by XBOOLE_0:def 1;
  NIC(i,p) = {Next p} by A1;
  then {Next p} in X;
  then x in {Next p} by A2,SETFAM_1:def 1;
  then
A3: x = Next p by TARSKI:def 1;
  NIC(i,q) = {Next q} by A1;
  then {Next q} in X;
  then x in {Next q} by A2,SETFAM_1:def 1;
  hence contradiction by A3,TARSKI:def 1;
end;

theorem Th68:
  NIC(halt SCM+FSA, il) = {il}
proof
  now
    let x be set;
A1: now
      il in NAT by AMI_1:def 4;
      then reconsider il1 = il as Element of ObjectKind IC SCM+FSA by
AMI_1:def 11;
      reconsider I = halt SCM+FSA as Element of ObjectKind il by AMI_1:def 14;
      consider t being State of SCM+FSA;
      assume
A2:   x = il;
      set u = t+*((IC SCM+FSA, il)-->(il1, I));
A3:   IC u = il by AMI_1:129;
      dom ((IC SCM+FSA, il)-->(il1, I)) = {IC SCM+FSA, il} by FUNCT_4:65;
      then
A4:   IC SCM+FSA in dom ((IC SCM+FSA, il)-->(il1, I)) by TARSKI:def 2;
A5:   u.il = halt SCM+FSA by AMI_1:129;
      then IC Following u = u.IC SCM+FSA by A3,AMI_1:def 8
        .= ((IC SCM+FSA, il)-->(il1, I)).IC SCM+FSA by A4,FUNCT_4:14
        .= il by AMI_1:48,FUNCT_4:66;
      hence x in {IC Following s : IC s = il & s.il=halt SCM+FSA} by A2,A5,A3;
    end;
    now
      assume
      x in {IC Following s : IC s = il & s.il=halt SCM+FSA};
      then ex s being State of SCM+FSA st x = IC Following s & IC s = il &
      s.il = halt SCM+FSA;
      hence x = il by AMI_1:def 8;
    end;
    hence x in {il} iff x in {IC Following s : IC s = il & s.il=halt SCM+FSA}
    by A1,TARSKI:def 1;
  end;
  hence thesis by TARSKI:2;
end;

registration
  cluster JUMP halt SCM+FSA -> empty;
  coherence;
end;

theorem Th69:
  NIC(a := b, il) = {Next il}
proof
  set i = a:=b;
  for s being State of SCM+FSA st IC s = il & s.il = i holds Exec(i,s).IC
  SCM+FSA = Next IC s by SCMFSA_2:89;
  hence thesis by Lm5;
end;

registration
  let a, b;
  cluster JUMP (a := b) -> empty;
  coherence
  proof
    for l being Instruction-Location of SCM+FSA holds NIC(a:=b,l)={Next l}
    by Th69;
    hence thesis by Lm6;
  end;
end;

theorem Th70:
  NIC(AddTo(a,b), il) = {Next il}
proof
  set i = AddTo(a,b);
  for s being State of SCM+FSA st IC s = il & s.il = i holds Exec(i,s).IC
  SCM+FSA = Next IC s by SCMFSA_2:90;
  hence thesis by Lm5;
end;

registration
  let a, b;
  cluster JUMP AddTo(a, b) -> empty;
  coherence
  proof
    for l being Instruction-Location of SCM+FSA holds NIC(AddTo(a,b),l)={
    Next l } by Th70;
    hence thesis by Lm6;
  end;
end;

theorem Th71:
  NIC(SubFrom(a,b), il) = {Next il}
proof
  set i = SubFrom(a,b);
  for s being State of SCM+FSA st IC s = il & s.il = i holds Exec(i,s).IC
  SCM+FSA = Next IC s by SCMFSA_2:91;
  hence thesis by Lm5;
end;

registration
  let a, b;
  cluster JUMP SubFrom(a, b) -> empty;
  coherence
  proof
    for l being Instruction-Location of SCM+FSA holds NIC(SubFrom(a,b),l)=
    {Next l} by Th71;
    hence thesis by Lm6;
  end;
end;

theorem Th72:
  NIC(MultBy(a,b), il) = {Next il}
proof
  set i = MultBy(a,b);
  for s being State of SCM+FSA st IC s = il & s.il = i holds Exec(i,s).IC
  SCM+FSA = Next IC s by SCMFSA_2:92;
  hence thesis by Lm5;
end;

registration
  let a, b;
  cluster JUMP MultBy(a,b) -> empty;
  coherence
  proof
    for l being Instruction-Location of SCM+FSA holds NIC(MultBy(a,b),l)={
    Next l } by Th72;
    hence thesis by Lm6;
  end;
end;

theorem Th73:
  NIC(Divide(a,b), il) = {Next il}
proof
  set i = Divide(a,b);
  for s being State of SCM+FSA st IC s = il & s.il = i holds Exec(i,s).IC
  SCM+FSA = Next IC s by SCMFSA_2:93;
  hence thesis by Lm5;
end;

registration
  let a, b;
  cluster JUMP Divide(a,b) -> empty;
  coherence
  proof
    for l being Instruction-Location of SCM+FSA holds NIC(Divide(a,b),l)={
    Next l } by Th73;
    hence thesis by Lm6;
  end;
end;

theorem Th74:
  NIC(goto i1, il) = {i1}
proof
  now
    let x be set;
A1: now
      il in NAT by AMI_1:def 4;
      then reconsider il1 = il as Element of ObjectKind IC SCM+FSA by
AMI_1:def 11;
      reconsider I = goto i1 as Element of ObjectKind il by AMI_1:def 14;
      consider t being State of SCM+FSA;
      assume
A2:   x = i1;
      set u = t+*((IC SCM+FSA, il)-->(il1, I));
A3:   u.il = goto i1 by AMI_1:129;
A4:   IC u = il by AMI_1:129;
      then IC Following u = i1 by A3,SCMFSA_2:95;
      hence x in {IC Following s : IC s = il & s.il=goto i1} by A2,A4,A3;
    end;
    now
      assume
      x in {IC Following s : IC s = il & s.il=goto i1};
      then ex s being State of SCM+FSA st x = IC Following s & IC s = il &
      s.il = goto i1;
      hence x = i1 by SCMFSA_2:95;
    end;
    hence
    x in {i1} iff x in {IC Following s : IC s = il & s.il=goto i1} by A1,
TARSKI:def 1;
  end;
  hence thesis by TARSKI:2;
end;

theorem Th75:
  JUMP goto i1 = {i1}
proof
  set X = { NIC(goto i1, il) : not contradiction };
  now
    let x be set;
    hereby
      set il1 = insloc 1;
A1:   NIC(goto i1, il1) in X;
      assume
      x in meet X;
      then x in NIC(goto i1, il1) by A1,SETFAM_1:def 1;
      hence x in {i1} by Th74;
    end;
    assume
    x in {i1};
    then
A2: x = i1 by TARSKI:def 1;
A3: now
      let Y be set;
      assume
      Y in X;
      then consider il being Instruction-Location of SCM+FSA such that
A4:   Y = NIC(goto i1, il);
      NIC(goto i1, il) = {i1} by Th74;
      hence i1 in Y by A4,TARSKI:def 1;
    end;
    NIC(goto i1, i1) in X;
    hence x in meet X by A2,A3,SETFAM_1:def 1;
  end;
  hence thesis by TARSKI:2;
end;

registration
  let i1;
  cluster JUMP goto i1 -> non empty trivial;
  coherence
  proof
    JUMP goto i1 = {i1} by Th75;
    hence thesis;
  end;
end;

theorem Th76:
  NIC(a=0_goto i1, il) = {i1, Next il}
proof
  consider t being State of SCM+FSA;
  hereby
    let x be set;
    assume
    x in NIC(a=0_goto i1, il);
    then consider s being State of SCM+FSA such that
A1: x = IC Following s and
A2: IC s = il and
A3: s.il = a=0_goto i1;
    per cases;
    suppose
      s.a = 0;
      then x = i1 by A1,A2,A3,SCMFSA_2:96;
      hence x in {i1, Next il} by TARSKI:def 2;
    end;
    suppose
      s.a <> 0;
      then x = Next il by A1,A2,A3,SCMFSA_2:96;
      hence x in {i1, Next il} by TARSKI:def 2;
    end;
  end;
  let x be set;
  reconsider I = a=0_goto i1 as Element of ObjectKind il by AMI_1:def 14;
A4: IC SCM+FSA <> a by SCMFSA_2:81;
  il in NAT by AMI_1:def 4;
  then reconsider il1 = il as Element of ObjectKind IC SCM+FSA by AMI_1:def 11;
  set u = t+*((IC SCM+FSA, il)-->(il1, I));
  il in NAT by AMI_1:def 4;
  then
A5: a <> il by Th3;
  assume
A6: x in {i1, Next il};
  per cases by A6,TARSKI:def 2;
  suppose
A7: x = i1;
    set v = u+*(a .--> 0);
A8: dom (a .--> 0) = {a} by FUNCOP_1:19;
    then not IC SCM+FSA in dom (a .--> 0) by A4,TARSKI:def 1;
    then
A9: IC v = IC u by FUNCT_4:12
      .= il by AMI_1:129;
    not il in dom (a .--> 0) by A5,A8,TARSKI:def 1;
    then
A10: v.il = u.il by FUNCT_4:12
      .= I by AMI_1:129;
    a in dom (a .--> 0) by A8,TARSKI:def 1;
    then v.a = (a .--> 0).a by FUNCT_4:14
      .= 0 by FUNCOP_1:87;
    then IC Following v = i1 by A9,A10,SCMFSA_2:96;
    hence thesis by A7,A9,A10;
  end;
  suppose
A11: x = Next il;
    set v = u+*(a .--> 1);
A12: dom (a .--> 1) = {a} by FUNCOP_1:19;
    then not IC SCM+FSA in dom (a .--> 1) by A4,TARSKI:def 1;
    then
A13: IC v = IC u by FUNCT_4:12
      .= il by AMI_1:129;
    not il in dom (a .--> 1) by A5,A12,TARSKI:def 1;
    then
A14: v.il = u.il by FUNCT_4:12
      .= I by AMI_1:129;
    a in dom (a .--> 1) by A12,TARSKI:def 1;
    then v.a = (a .--> 1).a by FUNCT_4:14
      .= 1 by FUNCOP_1:87;
    then IC Following v = Next il by A13,A14,SCMFSA_2:96;
    hence thesis by A11,A13,A14;
  end;
end;

theorem Th77:
  JUMP (a=0_goto i1) = {i1}
proof
  set X = { NIC(a=0_goto i1, il) : not contradiction };
  now
    let x be set;
A1: now
      let Y be set;
      assume
      Y in X;
      then consider il being Instruction-Location of SCM+FSA such that
A2:   Y = NIC(a=0_goto i1, il);
      NIC(a=0_goto i1, il) = {i1, Next il} by Th76;
      hence i1 in Y by A2,TARSKI:def 2;
    end;
    hereby
      set il1 = insloc 1, il2 = insloc 2;
      assume
A3:   x in meet X;
A4:   NIC(a=0_goto i1, il2) = {i1, Next il2} by Th76;
      NIC(a=0_goto i1, il2) in X;
      then x in NIC(a=0_goto i1, il2) by A3,SETFAM_1:def 1;
      then
A5:   x = i1 or x = Next il2 by A4,TARSKI:def 2;
A6:   NIC(a=0_goto i1, il1) = {i1, Next il1} by Th76;
      NIC(a=0_goto i1, il1) in X;
      then x in NIC(a=0_goto i1, il1) by A3,SETFAM_1:def 1;
      then x = i1 or x = Next il1 by A6,TARSKI:def 2;
      hence x in {i1} by A5,TARSKI:def 1;
    end;
    assume
    x in {i1};
    then
A7: x = i1 by TARSKI:def 1;
    NIC(a=0_goto i1, i1) in X;
    hence x in meet X by A7,A1,SETFAM_1:def 1;
  end;
  hence thesis by TARSKI:2;
end;

registration
  let a, i1;
  cluster JUMP (a =0_goto i1) -> non empty trivial;
  coherence
  proof
    JUMP (a =0_goto i1) = {i1} by Th77;
    hence thesis;
  end;
end;

theorem Th78:
  NIC(a>0_goto i1, il) = {i1, Next il}
proof
  consider t being State of SCM+FSA;
  hereby
    let x be set;
    assume
    x in NIC(a>0_goto i1, il);
    then consider s being State of SCM+FSA such that
A1: x = IC Following s and
A2: IC s = il and
A3: s.il = a>0_goto i1;
    per cases;
    suppose
      s.a > 0;
      then x = i1 by A1,A2,A3,SCMFSA_2:97;
      hence x in {i1, Next il} by TARSKI:def 2;
    end;
    suppose
      s.a <= 0;
      then x = Next il by A1,A2,A3,SCMFSA_2:97;
      hence x in {i1, Next il} by TARSKI:def 2;
    end;
  end;
  let x be set;
  reconsider I = a>0_goto i1 as Element of ObjectKind il by AMI_1:def 14;
A4: IC SCM+FSA <> a by SCMFSA_2:81;
  il in NAT by AMI_1:def 4;
  then reconsider il1 = il as Element of ObjectKind IC SCM+FSA by AMI_1:def 11;
  set u = t+*((IC SCM+FSA, il)-->(il1, I));
  il in NAT by AMI_1:def 4;
  then
A5: a <> il by Th3;
  assume
A6: x in {i1, Next il};
  per cases by A6,TARSKI:def 2;
  suppose
A7: x = i1;
    set v = u+*(a .--> 1);
A8: dom (a .--> 1) = {a} by FUNCOP_1:19;
    then not IC SCM+FSA in dom (a .--> 1) by A4,TARSKI:def 1;
    then
A9: IC v = IC u by FUNCT_4:12
      .= il by AMI_1:129;
    not il in dom (a .--> 1) by A5,A8,TARSKI:def 1;
    then
A10: v.il = u.il by FUNCT_4:12
      .= I by AMI_1:129;
    a in dom (a .--> 1) by A8,TARSKI:def 1;
    then v.a = (a .--> 1).a by FUNCT_4:14
      .= 1 by FUNCOP_1:87;
    then IC Following v = i1 by A9,A10,SCMFSA_2:97;
    hence thesis by A7,A9,A10;
  end;
  suppose
A11: x = Next il;
    set v = u+*(a .--> 0);
A12: dom (a .--> 0) = {a} by FUNCOP_1:19;
    then not IC SCM+FSA in dom (a .--> 0) by A4,TARSKI:def 1;
    then
A13: IC v = IC u by FUNCT_4:12
      .= il by AMI_1:129;
    not il in dom (a .--> 0) by A5,A12,TARSKI:def 1;
    then
A14: v.il = u.il by FUNCT_4:12
      .= I by AMI_1:129;
    a in dom (a .--> 0) by A12,TARSKI:def 1;
    then v.a = (a .--> 0).a by FUNCT_4:14
      .= 0 by FUNCOP_1:87;
    then IC Following v = Next il by A13,A14,SCMFSA_2:97;
    hence thesis by A11,A13,A14;
  end;
end;

theorem Th79:
  JUMP (a>0_goto i1) = {i1}
proof
  set X = { NIC(a>0_goto i1, il) : not contradiction };
  now
    let x be set;
A1: now
      let Y be set;
      assume
      Y in X;
      then consider il being Instruction-Location of SCM+FSA such that
A2:   Y = NIC(a>0_goto i1, il);
      NIC(a>0_goto i1, il) = {i1, Next il} by Th78;
      hence i1 in Y by A2,TARSKI:def 2;
    end;
    hereby
      set il1 = insloc 1, il2 = insloc 2;
      assume
A3:   x in meet X;
A4:   NIC(a>0_goto i1, il2) = {i1, Next il2} by Th78;
      NIC(a>0_goto i1, il2) in X;
      then x in NIC(a>0_goto i1, il2) by A3,SETFAM_1:def 1;
      then
A5:   x = i1 or x = Next il2 by A4,TARSKI:def 2;
A6:   NIC(a>0_goto i1, il1) = {i1, Next il1} by Th78;
      NIC(a>0_goto i1, il1) in X;
      then x in NIC(a>0_goto i1, il1) by A3,SETFAM_1:def 1;
      then x = i1 or x = Next il1 by A6,TARSKI:def 2;
      hence x in {i1} by A5,TARSKI:def 1;
    end;
    assume
    x in {i1};
    then
A7: x = i1 by TARSKI:def 1;
    NIC(a>0_goto i1, i1) in X;
    hence x in meet X by A7,A1,SETFAM_1:def 1;
  end;
  hence thesis by TARSKI:2;
end;

registration
  let a, i1;
  cluster JUMP (a >0_goto i1) -> non empty trivial;
  coherence
  proof
    JUMP (a >0_goto i1) = {i1} by Th79;
    hence thesis;
  end;
end;

theorem Th80:
  NIC(a:=(f,b), il) = {Next il}
proof
  set i = a:=(f,b);
  for s being State of SCM+FSA st IC s = il & s.il = i holds Exec(i,s).IC
  SCM+FSA = Next IC s by SCMFSA_2:98;
  hence thesis by Lm5;
end;

registration
  let a, b, f;
  cluster JUMP (a:=(f,b)) -> empty;
  coherence
  proof
    for l being Instruction-Location of SCM+FSA holds NIC(a:=(f,b),l)={
    Next l} by Th80;
    hence thesis by Lm6;
  end;
end;

theorem Th81:
  NIC((f,b):=a, il) = {Next il}
proof
  set i = (f,b):=a;
  for s being State of SCM+FSA st IC s = il & s.il = i holds Exec(i,s).IC
  SCM+FSA = Next IC s by SCMFSA_2:99;
  hence thesis by Lm5;
end;

registration
  let a, b, f;
  cluster JUMP ((f,b):=a) -> empty;
  coherence
  proof
    for l being Instruction-Location of SCM+FSA holds NIC((f,b):=a,l)={
    Next l} by Th81;
    hence thesis by Lm6;
  end;
end;

theorem Th82:
  NIC(a:=len f, il) = {Next il}
proof
  set i = a:=len f;
  for s being State of SCM+FSA st IC s = il & s.il = i holds Exec(i,s).IC
  SCM+FSA = Next IC s by SCMFSA_2:100;
  hence thesis by Lm5;
end;

registration
  let a, f;
  cluster JUMP (a:=len f) -> empty;
  coherence
  proof
    for l being Instruction-Location of SCM+FSA holds NIC(a:=len f,l)={
    Next l} by Th82;
    hence thesis by Lm6;
  end;
end;

theorem Th83:
  NIC(f:=<0,...,0>a, il) = {Next il}
proof
  set i = f:=<0,...,0>a;
  for s being State of SCM+FSA st IC s = il & s.il = i holds Exec(i,s).IC
  SCM+FSA = Next IC s by SCMFSA_2:101;
  hence thesis by Lm5;
end;

registration
  let a, f;
  cluster JUMP (f:=<0,...,0>a) -> empty;
  coherence
  proof
    for l being Instruction-Location of SCM+FSA holds NIC(f:=<0,...,0>a,l)
    ={Next l} by Th83;
    hence thesis by Lm6;
  end;
end;

theorem Th84:
  SUCC il = {il, Next il}
proof
  set X = { NIC(I, il) \ JUMP I where I is Element of the Instructions of
  SCM+FSA: not contradiction };
  set N = {il, Next il};
  now
    let x be set;
    hereby
      assume
      x in union X;
      then consider Y being set such that
A1:   x in Y and
A2:   Y in X by TARSKI:def 4;
      consider i being Element of the Instructions of SCM+FSA such that
A3:   Y = NIC(i, il) \ JUMP i by A2;
      per cases by SCMFSA_2:120;
      suppose
        i = [0,{}];
        then x in {il} \ JUMP halt SCM+FSA by A1,A3,Th68,AMI_3:71,SCMFSA_2:123;
        then x = il by TARSKI:def 1;
        hence x in N by TARSKI:def 2;
      end;
      suppose
        ex a,b st i = a:=b;
        then consider a, b such that
A4:     i = a:=b;
        x in {Next il} \ JUMP (a:=b) by A1,A3,A4,Th69;
        then x = Next il by TARSKI:def 1;
        hence x in N by TARSKI:def 2;
      end;
      suppose
        ex a,b st i = AddTo(a,b);
        then consider a, b such that
A5:     i = AddTo(a,b);
        x in {Next il} \ JUMP AddTo(a,b) by A1,A3,A5,Th70;
        then x = Next il by TARSKI:def 1;
        hence x in N by TARSKI:def 2;
      end;
      suppose
        ex a,b st i = SubFrom(a,b);
        then consider a, b such that
A6:     i = SubFrom(a,b);
        x in {Next il} \ JUMP SubFrom(a,b) by A1,A3,A6,Th71;
        then x = Next il by TARSKI:def 1;
        hence x in N by TARSKI:def 2;
      end;
      suppose
        ex a,b st i = MultBy(a,b);
        then consider a, b such that
A7:     i = MultBy(a,b);
        x in {Next il} \ JUMP MultBy(a,b) by A1,A3,A7,Th72;
        then x = Next il by TARSKI:def 1;
        hence x in N by TARSKI:def 2;
      end;
      suppose
        ex a,b st i = Divide(a,b);
        then consider a, b such that
A8:     i = Divide(a,b);
        x in {Next il} \ JUMP Divide(a,b) by A1,A3,A8,Th73;
        then x = Next il by TARSKI:def 1;
        hence x in N by TARSKI:def 2;
      end;
      suppose
        ex i1 st i = goto i1;
        then consider i1 such that
A9:     i = goto i1;
        x in {i1} \ JUMP i by A1,A3,A9,Th74;
        then x in {i1} \ {i1} by A9,Th75;
        hence x in N by XBOOLE_1:37;
      end;
      suppose
        ex i1,a st i = a=0_goto i1;
        then consider i1, a such that
A10:    i = a=0_goto i1;
A11:    NIC(i, il) = {i1, Next il} by A10,Th76;
        x in NIC(i, il) by A1,A3,XBOOLE_0:def 5;
        then
A12:    x = i1 or x = Next il by A11,TARSKI:def 2;
        x in NIC(i, il) \ {i1} by A1,A3,A10,Th77;
        then not x in {i1} by XBOOLE_0:def 5;
        hence x in N by A12,TARSKI:def 1,def 2;
      end;
      suppose
        ex i1,a st i = a>0_goto i1;
        then consider i1, a such that
A13:    i = a>0_goto i1;
A14:    NIC(i, il) = {i1, Next il} by A13,Th78;
        x in NIC(i, il) by A1,A3,XBOOLE_0:def 5;
        then
A15:    x = i1 or x = Next il by A14,TARSKI:def 2;
        x in NIC(i, il) \ {i1} by A1,A3,A13,Th79;
        then not x in {i1} by XBOOLE_0:def 5;
        hence x in N by A15,TARSKI:def 1,def 2;
      end;
      suppose
        ex a,b,f st i = b:=(f,a);
        then consider a, b, f such that
A16:    i = b:=(f,a);
        x in {Next il} \ JUMP (b:=(f,a)) by A1,A3,A16,Th80;
        then x = Next il by TARSKI:def 1;
        hence x in N by TARSKI:def 2;
      end;
      suppose
        ex a,b,f st i = (f,a):=b;
        then consider a, b, f such that
A17:    i = (f,a):=b;
        x in {Next il} \ JUMP ((f,a):=b) by A1,A3,A17,Th81;
        then x = Next il by TARSKI:def 1;
        hence x in N by TARSKI:def 2;
      end;
      suppose
        ex a,f st i = a:=len f;
        then consider a, f such that
A18:    i = a:=len f;
        x in {Next il} \ JUMP (a:=len f) by A1,A3,A18,Th82;
        then x = Next il by TARSKI:def 1;
        hence x in N by TARSKI:def 2;
      end;
      suppose
        ex a,f st i = f:=<0,...,0>a;
        then consider a, f such that
A19:    i = f:=<0,...,0>a;
        x in {Next il} \ JUMP (f:=<0,...,0>a) by A1,A3,A19,Th83;
        then x = Next il by TARSKI:def 1;
        hence x in N by TARSKI:def 2;
      end;
    end;
    assume
A20: x in {il, Next il};
    per cases by A20,TARSKI:def 2;
    suppose
A21:  x = il;
      set i = halt SCM+FSA;
      NIC(i, il) \ JUMP i = {il} by Th68;
      then
A22:  {il} in X;
      x in {il} by A21,TARSKI:def 1;
      hence x in union X by A22,TARSKI:def 4;
    end;
    suppose
A23:  x = Next il;
      consider a, b being Int-Location;
      set i = AddTo(a,b);
      NIC(i, il) \ JUMP i = {Next il} by Th70;
      then
A24:  {Next il} in X;
      x in {Next il} by A23,TARSKI:def 1;
      hence x in union X by A24,TARSKI:def 4;
    end;
  end;
  hence thesis by TARSKI:2;
end;

theorem Th85:
  for f being IL-Function of NAT, SCM+FSA st for k being Element
  of NAT holds f.k = insloc k holds f is bijective & for k being Element of NAT
  holds f.(k+1) in SUCC (f.k) & for j being Element of NAT st f.j in SUCC (f.k)
  holds k <= j
proof
  let f be IL-Function of NAT, SCM+FSA such that
A1: for k being Element of NAT holds f.k = insloc k;
A2: f is one-to-one
  proof
    let x1, x2 be set such that
A3: x1 in dom f and
A4: x2 in dom f and
A5: f.x1 = f.x2;
    reconsider k1 = x1, k2 = x2 as Element of NAT by A3,A4,FUNCT_2:def 1;
A6: f.k2 = insloc k2 by A1;
    f.k1 = insloc k1 by A1;
    hence thesis by A5,A6;
  end;
A7: NAT c= rng f
  proof
    let x be set;
A8: dom f = NAT by FUNCT_2:def 1;
    assume
    x in NAT;
    then reconsider l=x as Instruction-Location of SCM+FSA by AMI_1:def 4;
    reconsider i = l as Element of NAT by ORDINAL1:def 13;
    insloc i = f.i by A1;
    hence thesis by A8,FUNCT_1:def 5;
  end;
  rng f c= NAT by RELAT_1:def 19;
  then rng f= NAT by A7,XBOOLE_0:def 10;
  then f is onto by FUNCT_2:def 3;
  hence f is bijective by A2;
  let k be Element of NAT;
A9: f.k = insloc k by A1;
  reconsider k1=k+1 as Element of NAT by ORDINAL1:def 13;
  f.k1 in NAT;
  then
A10: f.(k+1) = insloc (k+1) by A1;
A11: SUCC (f.k) = {f.k, Next (f.k)} by Th84;
  hence f.(k+1) in SUCC (f.k) by A10,A9,TARSKI:def 2;
A12: dom f = NAT by FUNCT_2:def 1;
  let j be Element of NAT;
  assume
A13: f.j in SUCC (f.k);
  per cases by A11,A13,TARSKI:def 2;
  suppose
    f.j = f.k;
    hence thesis by A2,A12,FUNCT_1:def 8;
  end;
  suppose
    f.j = Next (f.k);
    then j = k+1 by A2,A10,A9,A12,FUNCT_1:def 8;
    hence thesis by NAT_1:11;
  end;
end;

registration
  cluster SCM+FSA -> standard;
  coherence
  proof
    deffunc U(Element of NAT) = insloc $1;
A1: for k being Element of NAT holds U(k) is Element of NAT;
    consider f being Function of NAT, NAT such that
A2: for k being Element of NAT holds f.k = U(k) from FUNCT_2:sch 9(A1);
    reconsider f as IL-Function of NAT, SCM+FSA by AMI_1:def 36;
A3: for k being Element of NAT holds f.(k+1) in SUCC (f.k) & for j being
    Element of NAT st f.j in SUCC (f.k) holds k <= j by A2,Th85;
    f is bijective by A2,Th85;
    hence thesis by A3,AMISTD_1:19;
  end;
end;

theorem Th86:
  il.(SCM+FSA,k) = insloc k
proof
  deffunc U(Element of NAT) = insloc $1;
A1: for k being Element of NAT holds U(k) is Element of NAT;
  consider f being Function of NAT, NAT such that
A2: for k being Element of NAT holds f.k = U(k) from FUNCT_2:sch 9(A1);
  reconsider f as IL-Function of NAT, SCM+FSA by AMI_1:def 36;
A3: for k being Element of NAT holds f.(k+1) in SUCC (f.k) & for j being
  Element of NAT st f.j in SUCC (f.k) holds k <= j by A2,Th85;
A4: f is bijective by A2,Th85;
  ex f being IL-Function of NAT, SCM+FSA st f is bijective & (for m, n
  being Element of NAT holds m <= n iff f.m <= f.n) & insloc k = f.k
  proof
    take f;
    thus f is bijective by A2,Th85;
    thus for m, n being Element of NAT holds m <= n iff f.m <= f.n by A4,A3,
AMISTD_1:18;
    insloc k in NAT by AMI_1:def 4;
    hence thesis by A2;
  end;
  hence thesis by AMISTD_1:def 12;
end;

theorem Th87:
  Next il.(SCM+FSA,k) = il.(SCM+FSA,k+1)
proof
  thus Next il.(SCM+FSA,k) = Next insloc k by Th86
    .= k + 1
    .= insloc (k+1)
    .= il.(SCM+FSA,k+1) by Th86;
end;

theorem Th88:
  Next il = NextLoc il
proof
  Next il.(SCM+FSA,locnum il) = il.(SCM+FSA,locnum il+1) by Th87;
  hence thesis by AMISTD_1:def 13;
end;

registration
  cluster InsCode halt SCM+FSA -> jump-only InsType of SCM+FSA;
  coherence
  proof
    now
      let s be State of SCM+FSA, o be Object of SCM+FSA, I be Instruction of
      SCM+FSA;
      assume that
A1:   InsCode I = InsCode halt SCM+FSA and
      o <> IC SCM+FSA;
      I = halt SCM+FSA by A1,SCMFSA_2:122,124;
      hence Exec(I, s).o = s.o by AMI_1:def 8;
    end;
    hence thesis by AMISTD_1:def 3;
  end;
end;

registration
  cluster halt SCM+FSA -> jump-only;
  coherence
  proof
    thus InsCode halt SCM+FSA is jump-only;
  end;
end;

registration
  let i1;
  cluster InsCode goto i1 -> jump-only InsType of SCM+FSA;
  coherence
  proof
    set S = SCM+FSA;
    now
      let s be State of S, o be Object of S, I be Instruction of S;
      assume that
A1:   InsCode I = InsCode goto i1 and
A2:   o <> IC S;
A3:   ex i2 st I = goto i2 by A1,SCMFSA_2:47,59;
      per cases by A2,Th7;
      suppose
        o in NAT;
        then reconsider l=o as Instruction-Location of S by AMI_1:def 4;
        l=o;
        hence Exec(I, s).o = s.o by AMI_1:def 13;
      end;
      suppose
        o is Int-Location;
        hence Exec(I, s).o = s.o by A3,SCMFSA_2:95;
      end;
      suppose
        o is FinSeq-Location;
        hence Exec(I, s).o = s.o by A3,SCMFSA_2:95;
      end;
    end;
    hence thesis by AMISTD_1:def 3;
  end;
end;

registration
  let i1;
  cluster goto i1 -> jump-only non sequential non ins-loc-free;
  coherence
  proof
    thus InsCode goto i1 is jump-only;
    JUMP goto i1 <> {};
    hence goto i1 is non sequential by AMISTD_1:43;
    take 1;
    dom AddressPart goto i1 = dom <*i1*> by Th23
      .= {1} by FINSEQ_1:4,def 8;
    hence 1 in dom AddressPart goto i1 by TARSKI:def 1;
    thus thesis by Th53;
  end;
end;

registration
  let a, i1;
  cluster InsCode (a =0_goto i1) -> jump-only InsType of SCM+FSA;
  coherence
  proof
    set S = SCM+FSA;
    now
      let s be State of S, o be Object of S, I be Instruction of S;
      assume that
A1:   InsCode I = InsCode (a =0_goto i1) and
A2:   o <> IC S;
A3:   ex i2, b st I = b =0_goto i2 by A1,SCMFSA_2:48,60;
      per cases by A2,Th7;
      suppose
        o in NAT;
        then reconsider l=o as Instruction-Location of S by AMI_1:def 4;
        l=o;
        hence Exec(I, s).o = s.o by AMI_1:def 13;
      end;
      suppose
        o is Int-Location;
        hence Exec(I, s).o = s.o by A3,SCMFSA_2:96;
      end;
      suppose
        o is FinSeq-Location;
        hence Exec(I, s).o = s.o by A3,SCMFSA_2:96;
      end;
    end;
    hence thesis by AMISTD_1:def 3;
  end;
  cluster InsCode (a >0_goto i1) -> jump-only InsType of SCM+FSA;
  coherence
  proof
    set S = SCM+FSA;
    now
      let s be State of S, o be Object of S, I be Instruction of S;
      assume that
A4:   InsCode I = InsCode (a >0_goto i1) and
A5:   o <> IC S;
A6:   ex i2, b st I = b >0_goto i2 by A4,SCMFSA_2:49,61;
      per cases by A5,Th7;
      suppose
        o in NAT;
        then reconsider l=o as Instruction-Location of S by AMI_1:def 4;
        l=o;
        hence Exec(I, s).o = s.o by AMI_1:def 13;
      end;
      suppose
        o is Int-Location;
        hence Exec(I, s).o = s.o by A6,SCMFSA_2:97;
      end;
      suppose
        o is FinSeq-Location;
        hence Exec(I, s).o = s.o by A6,SCMFSA_2:97;
      end;
    end;
    hence thesis by AMISTD_1:def 3;
  end;
end;

registration
  let a, i1;
  cluster a =0_goto i1 -> jump-only non sequential non ins-loc-free;
  coherence
  proof
    thus InsCode (a =0_goto i1) is jump-only;
    JUMP (a =0_goto i1) <> {};
    hence a =0_goto i1 is non sequential by AMISTD_1:43;
    take 1;
    dom AddressPart (a =0_goto i1) = dom <*i1,a*> by Th24
      .= {1,2} by FINSEQ_1:4,FINSEQ_3:29;
    hence 1 in dom AddressPart (a =0_goto i1) by TARSKI:def 2;
    thus thesis by Th54;
  end;
  cluster a >0_goto i1 -> jump-only non sequential non ins-loc-free;
  coherence
  proof
    thus InsCode (a >0_goto i1) is jump-only;
    JUMP (a >0_goto i1) <> {};
    hence a >0_goto i1 is non sequential by AMISTD_1:43;
    take 1;
    dom AddressPart (a >0_goto i1) = dom <*i1,a*> by Th25
      .= {1,2} by FINSEQ_1:4,FINSEQ_3:29;
    hence 1 in dom AddressPart (a >0_goto i1) by TARSKI:def 2;
    thus thesis by Th56;
  end;
end;

Lm7: intloc 0 <> intloc 1 by AMI_3:52;

registration
  let a, b;
  cluster InsCode (a:=b) -> non jump-only InsType of SCM+FSA;
  coherence
  proof
    consider w being State of SCM+FSA;
    set t = w+*((intloc 0, intloc 1)-->(0,1));
A1: InsCode (a:=b) = 1 by SCMFSA_2:42
      .= InsCode (intloc 0:=intloc 1) by SCMFSA_2:42;
A2: intloc 0 <> IC SCM+FSA by SCMFSA_2:81;
A3: dom ((intloc 0, intloc 1)-->(0,1)) = {intloc 0, intloc 1} by FUNCT_4:65;
    then
A4: intloc 1 in dom ((intloc 0, intloc 1)-->(0,1)) by TARSKI:def 2;
    intloc 0 in dom ((intloc 0, intloc 1)-->(0,1)) by A3,TARSKI:def 2;
    then
A5: t.intloc 0 = (intloc 0, intloc 1)-->(0,1).intloc 0 by FUNCT_4:14
      .= 0 by AMI_3:52,FUNCT_4:66;
    Exec((intloc 0:=intloc 1), t).intloc 0 = t.intloc 1 by SCMFSA_2:89
      .= (intloc 0, intloc 1)-->(0,1).intloc 1 by A4,FUNCT_4:14
      .= 1 by FUNCT_4:66;
    hence thesis by A1,A2,A5,AMISTD_1:def 3;
  end;
  cluster InsCode AddTo(a,b) -> non jump-only InsType of SCM+FSA;
  coherence
  proof
    consider w being State of SCM+FSA;
    set t = w+*((intloc 0, intloc 1)-->(0,1));
A6: InsCode AddTo(a,b) = 2 by SCMFSA_2:43
      .= InsCode AddTo(intloc 0, intloc 1) by SCMFSA_2:43;
A7: dom ((intloc 0, intloc 1)-->(0,1)) = {intloc 0, intloc 1} by FUNCT_4:65;
    then intloc 0 in dom ((intloc 0, intloc 1)-->(0,1)) by TARSKI:def 2;
    then
A8: t.intloc 0 = (intloc 0, intloc 1)-->(0,1).intloc 0 by FUNCT_4:14
      .= 0 by AMI_3:52,FUNCT_4:66;
A9: intloc 0 <> IC SCM+FSA by SCMFSA_2:81;
    intloc 1 in dom ((intloc 0, intloc 1)-->(0,1)) by A7,TARSKI:def 2;
    then t.intloc 1 = (intloc 0, intloc 1)-->(0,1).intloc 1 by FUNCT_4:14
      .= 1 by FUNCT_4:66;
    then Exec(AddTo(intloc 0, intloc 1), t).intloc 0 = 0+1 by A8,SCMFSA_2:90;
    hence thesis by A6,A9,A8,AMISTD_1:def 3;
  end;
  cluster InsCode SubFrom(a,b) -> non jump-only InsType of SCM+FSA;
  coherence
  proof
    consider w being State of SCM+FSA;
    set t = w+*((intloc 0, intloc 1)-->(0,1));
A10: InsCode SubFrom(a,b) = 3 by SCMFSA_2:44
      .= InsCode SubFrom(intloc 0, intloc 1) by SCMFSA_2:44;
A11: dom ((intloc 0, intloc 1)-->(0,1)) = {intloc 0, intloc 1} by FUNCT_4:65;
    then intloc 0 in dom ((intloc 0, intloc 1)-->(0,1)) by TARSKI:def 2;
    then
A12: t.intloc 0 = (intloc 0, intloc 1)-->(0,1).intloc 0 by FUNCT_4:14
      .= 0 by AMI_3:52,FUNCT_4:66;
A13: intloc 0 <> IC SCM+FSA by SCMFSA_2:81;
    intloc 1 in dom ((intloc 0, intloc 1)-->(0,1)) by A11,TARSKI:def 2;
    then
A14: t.intloc 1 = (intloc 0, intloc 1)-->(0,1).intloc 1 by FUNCT_4:14
      .= 1 by FUNCT_4:66;
    Exec(SubFrom(intloc 0, intloc 1), t).intloc 0 = t.intloc 0 - t.intloc
    1 by SCMFSA_2:91
      .= -1 by A12,A14;
    hence thesis by A10,A13,A12,AMISTD_1:def 3;
  end;
  cluster InsCode MultBy(a,b) -> non jump-only InsType of SCM+FSA;
  coherence
  proof
    consider w being State of SCM+FSA;
    set t = w+*((intloc 0, intloc 1)-->(1,0));
A15: InsCode MultBy(a,b) = 4 by SCMFSA_2:45
      .= InsCode MultBy(intloc 0, intloc 1) by SCMFSA_2:45;
A16: dom ((intloc 0, intloc 1)-->(1,0)) = {intloc 0, intloc 1} by FUNCT_4:65;
    then intloc 0 in dom ((intloc 0, intloc 1)-->(1,0)) by TARSKI:def 2;
    then
A17: t.intloc 0 = (intloc 0, intloc 1)-->(1,0).intloc 0 by FUNCT_4:14
      .= 1 by AMI_3:52,FUNCT_4:66;
A18: intloc 0 <> IC SCM+FSA by SCMFSA_2:81;
    intloc 1 in dom ((intloc 0, intloc 1)-->(1,0)) by A16,TARSKI:def 2;
    then
A19: t.intloc 1 = (intloc 0, intloc 1)-->(1,0).intloc 1 by FUNCT_4:14
      .= 0 by FUNCT_4:66;
    Exec(MultBy(intloc 0, intloc 1), t).intloc 0 = t.intloc 0 * t.intloc
    1 by SCMFSA_2:92
      .= 0 by A19;
    hence thesis by A15,A18,A17,AMISTD_1:def 3;
  end;
  cluster InsCode Divide(a,b) -> non jump-only InsType of SCM+FSA;
  coherence
  proof
    consider w being State of SCM+FSA;
    set t = w+*((intloc 0, intloc 1)-->(7,3));
A20: InsCode Divide(a,b) = 5 by SCMFSA_2:46
      .= InsCode Divide(intloc 0, intloc 1) by SCMFSA_2:46;
A21: dom ((intloc 0, intloc 1)-->(7,3)) = {intloc 0, intloc 1} by FUNCT_4:65;
    then intloc 0 in dom ((intloc 0, intloc 1)-->(7,3)) by TARSKI:def 2;
    then
A22: t.intloc 0 = (intloc 0, intloc 1)-->(7,3).intloc 0 by FUNCT_4:14
      .= 7 by AMI_3:52,FUNCT_4:66;
A23: 7 = 2 * 3 + 1;
A24: intloc 0 <> IC SCM+FSA by SCMFSA_2:81;
    intloc 1 in dom ((intloc 0, intloc 1)-->(7,3)) by A21,TARSKI:def 2;
    then t.intloc 1 = (intloc 0, intloc 1)-->(7,3).intloc 1 by FUNCT_4:14
      .= 3 by FUNCT_4:66;
    then Exec(Divide(intloc 0, intloc 1), t).intloc 0 = 7 div (3 qua Element
    of NAT) by A22,Lm7,SCMFSA_2:93
      .= 2 by A23,NAT_D:def 1;
    hence thesis by A20,A24,A22,AMISTD_1:def 3;
  end;
end;

registration
  let a, b;
  cluster a:=b -> non jump-only sequential;
  coherence
  proof
    thus InsCode (a:=b) is not jump-only;
    let s be State of SCM+FSA;
    Next IC s = NextLoc IC s by Th88;
    hence thesis by SCMFSA_2:89;
  end;
  cluster AddTo(a,b) -> non jump-only sequential;
  coherence
  proof
    thus InsCode AddTo(a,b) is not jump-only;
    let s be State of SCM+FSA;
    Next IC s = NextLoc IC s by Th88;
    hence thesis by SCMFSA_2:90;
  end;
  cluster SubFrom(a,b) -> non jump-only sequential;
  coherence
  proof
    thus InsCode SubFrom(a,b) is not jump-only;
    let s be State of SCM+FSA;
    Next IC s = NextLoc IC s by Th88;
    hence thesis by SCMFSA_2:91;
  end;
  cluster MultBy(a,b) -> non jump-only sequential;
  coherence
  proof
    thus InsCode MultBy(a,b) is not jump-only;
    let s be State of SCM+FSA;
    Next IC s = NextLoc IC s by Th88;
    hence thesis by SCMFSA_2:92;
  end;
  cluster Divide(a,b) -> non jump-only sequential;
  coherence
  proof
    thus InsCode Divide(a,b) is not jump-only;
    let s be State of SCM+FSA;
    Next IC s = NextLoc IC s by Th88;
    hence thesis by SCMFSA_2:93;
  end;
end;

Lm8: fsloc 0 <> intloc 0 by SCMFSA_2:126;

Lm9: fsloc 0 <> intloc 1 by SCMFSA_2:126;

registration
  let a, b, f;
  cluster InsCode (b:=(f,a)) -> non jump-only InsType of SCM+FSA;
  coherence
  proof
    ObjectKind intloc 1 = INT by SCMFSA_2:26;
    then reconsider E = 1 as Element of ObjectKind intloc 1 by INT_1:def 1;
    ObjectKind intloc 0 = INT by SCMFSA_2:26;
    then reconsider D = 1 as Element of ObjectKind intloc 0 by INT_1:def 1;
    reconsider DWA = 2 as Element of INT by INT_1:def 1;
    consider w being State of SCM+FSA;
A1: intloc 0 <> IC SCM+FSA by SCMFSA_2:81;
    <*DWA*> in INT* by FINSEQ_1:def 11;
    then reconsider F = <*2*> as Element of ObjectKind fsloc 0 by SCMFSA_2:27;
    set t = w+*(fsloc 0 .--> F)+*(intloc 0 .--> D)+*(intloc 1 .--> E);
A2: t.intloc 0 = D by AMI_3:52,BVFUNC14:15;
A3: t.fsloc 0 = F by Lm8,Lm9,FUNCT_7:116;
    then dom (t.fsloc 0) = {1} by FINSEQ_1:4,def 8;
    then
A4: 1 in dom (t.fsloc 0) by TARSKI:def 1;
    consider k being Element of NAT such that
A5: k = abs( t.intloc 1 ) and
A6: Exec((intloc 0):=(fsloc 0, intloc 1), t).intloc 0 = (t.fsloc 0)
    /. k by SCMFSA_2:98;
    t.intloc 1 = E by FUNCT_7:96;
    then k = 1 by A5,ABSVALUE:def 1;
    then
A7: Exec(intloc 0:=(fsloc 0, intloc 1), t).intloc 0 = (t.fsloc 0).1 by A6,A4,
PARTFUN1:def 8
      .= 2 by A3,FINSEQ_1:def 8;
    InsCode (b:=(f,a)) = 9 by SCMFSA_2:50
      .= InsCode ((intloc 0):=(fsloc 0, intloc 1)) by SCMFSA_2:50;
    hence thesis by A1,A2,A7,AMISTD_1:def 3;
  end;
  cluster InsCode ((f,a):=b) -> non jump-only InsType of SCM+FSA;
  coherence
  proof
    ObjectKind intloc 0 = INT by SCMFSA_2:26;
    then reconsider D = 1 as Element of ObjectKind intloc 0 by INT_1:def 1;
    reconsider DWA = 2 as Element of INT by INT_1:def 1;
    consider w being State of SCM+FSA;
A8: InsCode ((f,a):=b) = 10 by SCMFSA_2:51
      .= InsCode ((fsloc 0, intloc 1):=(intloc 0)) by SCMFSA_2:51;
    ObjectKind intloc 1 = INT by SCMFSA_2:26;
    then reconsider E = 1 as Element of ObjectKind intloc 1 by INT_1:def 1;
A9: fsloc 0 <> IC SCM+FSA by SCMFSA_2:82;
    <*DWA*> in INT* by FINSEQ_1:def 11;
    then reconsider F = <*2*> as Element of ObjectKind fsloc 0 by SCMFSA_2:27;
    set t = w+*(fsloc 0 .--> F)+*(intloc 0 .--> D)+*(intloc 1 .--> E);
    consider k being Element of NAT such that
A10: k = abs( t.intloc 1 ) and
A11: Exec((fsloc 0, intloc 1):=(intloc 0), t).fsloc 0 = (t.fsloc 0) +*
    (k,t.intloc 0) by SCMFSA_2:99;
    t.intloc 1 = E by FUNCT_7:96;
    then
A12: k = 1 by A10,ABSVALUE:def 1;
A13: F <> <*D*> by FINSEQ_1:97;
A14: t.fsloc 0 = F by Lm8,Lm9,FUNCT_7:116;
    t.intloc 0 = D by AMI_3:52,BVFUNC14:15;
    then Exec((fsloc 0, intloc 1):=intloc 0, t).fsloc 0 = <*D*> by A14,A11,A12,
FUNCT_7:97;
    hence thesis by A8,A9,A14,A13,AMISTD_1:def 3;
  end;
end;

registration
  let a, b, f;
  cluster b:=(f,a) -> non jump-only sequential;
  coherence
  proof
    thus InsCode (b:=(f,a)) is not jump-only;
    let s be State of SCM+FSA;
    Next IC s = NextLoc IC s by Th88;
    hence thesis by SCMFSA_2:98;
  end;
  cluster (f,a):=b -> non jump-only sequential;
  coherence
  proof
    thus InsCode ((f,a):=b) is not jump-only;
    let s be State of SCM+FSA;
    Next IC s = NextLoc IC s by Th88;
    hence thesis by SCMFSA_2:99;
  end;
end;

registration
  let a, f;
  cluster InsCode (a:=len f) -> non jump-only InsType of SCM+FSA;
  coherence
  proof
    ObjectKind intloc 0 = INT by SCMFSA_2:26;
    then reconsider D = 3 as Element of ObjectKind intloc 0 by INT_1:def 1;
    reconsider DWA = 2 as Element of INT by INT_1:def 1;
    consider w being State of SCM+FSA;
A1: InsCode (a:=len f) = 11 by SCMFSA_2:52
      .= InsCode (intloc 0:=len fsloc 0) by SCMFSA_2:52;
    <*DWA*> in INT* by FINSEQ_1:def 11;
    then reconsider F = <*2*> as Element of ObjectKind fsloc 0 by SCMFSA_2:27;
    set t = w+*(fsloc 0 .--> F)+*(intloc 0 .--> D);
A2: t.fsloc 0 = F by BVFUNC14:15,SCMFSA_2:126;
A3: t.intloc 0 = D by FUNCT_7:96;
A4: intloc 0 <> IC SCM+FSA by SCMFSA_2:81;
    Exec(intloc 0 :=len fsloc 0, t).intloc 0 = len (t.fsloc 0) by SCMFSA_2:100
      .= 1 by A2,FINSEQ_1:56;
    hence thesis by A1,A4,A3,AMISTD_1:def 3;
  end;
  cluster InsCode (f:=<0,...,0>a) -> non jump-only InsType of SCM+FSA;
  coherence
  proof
    ObjectKind intloc 0 = INT by SCMFSA_2:26;
    then reconsider D = 1 as Element of ObjectKind intloc 0 by INT_1:def 1;
    reconsider DWA = 2 as Element of INT by INT_1:def 1;
    consider w being State of SCM+FSA;
A5: fsloc 0 <> IC SCM+FSA by SCMFSA_2:82;
    <*DWA*> in INT* by FINSEQ_1:def 11;
    then reconsider F = <*2*> as Element of ObjectKind fsloc 0 by SCMFSA_2:27;
    set t = w+*(fsloc 0 .--> F)+*(intloc 0 .--> D);
A6: t.fsloc 0 = F by BVFUNC14:15,SCMFSA_2:126;
A7: F <> <*0*> by FINSEQ_1:97;
    consider k being Element of NAT such that
A8: k = abs( t.intloc 0 ) and
A9: Exec(fsloc 0:=<0,...,0>intloc 0, t).fsloc 0 = k |-> 0 by SCMFSA_2:101;
    t.intloc 0 = D by FUNCT_7:96;
    then k = 1 by A8,ABSVALUE:def 1;
    then
A10: Exec(fsloc 0:=<0,...,0>intloc 0, t).fsloc 0 = <*0*> by A9,FINSEQ_2:73;
    InsCode (f:=<0,...,0>a) = 12 by SCMFSA_2:53
      .= InsCode (fsloc 0:=<0,...,0>intloc 0) by SCMFSA_2:53;
    hence thesis by A5,A6,A7,A10,AMISTD_1:def 3;
  end;
end;

registration
  let a, f;
  cluster a:=len f -> non jump-only sequential;
  coherence
  proof
    thus InsCode (a:=len f) is not jump-only;
    let s be State of SCM+FSA;
    Next IC s = NextLoc IC s by Th88;
    hence thesis by SCMFSA_2:100;
  end;
  cluster f:=<0,...,0>a -> non jump-only sequential;
  coherence
  proof
    thus InsCode (f:=<0,...,0>a) is not jump-only;
    let s be State of SCM+FSA;
    Next IC s = NextLoc IC s by Th88;
    hence thesis by SCMFSA_2:101;
  end;
end;

registration
  cluster SCM+FSA -> homogeneous with_explicit_jumps without_implicit_jumps;
  coherence
  proof
    thus SCM+FSA is homogeneous
    proof
      let I, J be Instruction of SCM+FSA such that
A1:   InsCode I = InsCode J;
A2:   J = [0,{}] or (ex a,b st J = a:=b) or (ex a,b st J = AddTo(a,b)) or
(ex a,b st J = SubFrom(a,b)) or (ex a,b st J = MultBy(a,b)) or (ex a,b st J =
Divide(a,b)) or (ex i1 st J = goto i1) or (ex i1,a st J = a=0_goto i1) or (ex
i1,a st J = a>0_goto i1) or (ex b,a,f st J = a:=(f,b)) or (ex a,b,f st J = (f,a
):=b) or (ex a,f st J = a:=len f) or ex a,f st J = f:=<0,...,0>a by
SCMFSA_2:120;
      per cases by SCMFSA_2:120;
      suppose
        I = [0,{}];
        hence thesis by A1,A2,AMI_3:71,SCMFSA_2:47,48,49,123,124;
      end;
      suppose
        ex a,b st I = a:=b;
        then consider a, b such that
A3:     I = a:=b;
A4:     InsCode I = 1 by A3,SCMFSA_2:42;
        now
          per cases by SCMFSA_2:120;
          suppose
            J = [0,{}];
            hence thesis by A1,A3,AMI_3:71,SCMFSA_2:123;
          end;
          suppose
            ex a,b st J = a:=b;
            then consider d1, d2 such that
A5:         J = d1:=d2;
            thus dom AddressPart I = dom <*a,b*> by A3,Th18
              .= Seg 2 by FINSEQ_3:29
              .= dom <*d1,d2*> by FINSEQ_3:29
              .= dom AddressPart J by A5,Th18;
          end;
          suppose
            (ex a,b st J = AddTo(a,b)) or (ex a,b st J = SubFrom(a,b)
) or (ex a,b st J = MultBy(a,b)) or (ex a,b st J = Divide(a,b)) or (ex i1 st J
= goto i1) or (ex i1,a st J = a=0_goto i1) or (ex i1,a st J = a>0_goto i1) or (
ex b,a,f st J = a:=(f,b)) or (ex a,b,f st J = (f,a):=b) or (ex a,f st J = a
            :=len f) or ex a,f st J = f:=<0,...,0>a;
            hence thesis by A1,A4,SCMFSA_2:43,44,45,46,47,48,49,50,51,52,53;
          end;
        end;
        hence thesis;
      end;
      suppose
        ex a,b st I = AddTo(a,b);
        then consider a, b such that
A6:     I = AddTo(a,b);
A7:     InsCode I = 2 by A6,SCMFSA_2:43;
        now
          per cases by SCMFSA_2:120;
          suppose
            J = [0,{}];
            hence thesis by A1,A6,AMI_3:71,SCMFSA_2:123;
          end;
          suppose
            ex a,b st J = AddTo(a,b);
            then consider d1, d2 such that
A8:         J = AddTo(d1,d2);
            thus dom AddressPart I = dom <*a,b*> by A6,Th19
              .= Seg 2 by FINSEQ_3:29
              .= dom <*d1,d2*> by FINSEQ_3:29
              .= dom AddressPart J by A8,Th19;
          end;
          suppose
            (ex a,b st J = a:=b) or (ex a,b st J = SubFrom(a,b)) or (
ex a,b st J = MultBy(a,b)) or (ex a,b st J = Divide(a,b)) or (ex i1 st J = goto
i1) or (ex i1,a st J = a=0_goto i1) or (ex i1,a st J = a>0_goto i1) or (ex b,a,
f st J = a:=(f,b)) or (ex a,b,f st J = (f,a):=b) or (ex a,f st J = a:=len f) or
            ex a,f st J = f:=<0,...,0>a;
            hence thesis by A1,A7,SCMFSA_2:42,44,45,46,47,48,49,50,51,52,53;
          end;
        end;
        hence thesis;
      end;
      suppose
        ex a,b st I = SubFrom(a,b);
        then consider a, b such that
A9:     I = SubFrom(a,b);
A10:    InsCode I = 3 by A9,SCMFSA_2:44;
        now
          per cases by SCMFSA_2:120;
          suppose
            J = [0,{}];
            hence thesis by A1,A9,AMI_3:71,SCMFSA_2:123;
          end;
          suppose
            ex a,b st J = SubFrom(a,b);
            then consider d1, d2 such that
A11:        J = SubFrom(d1,d2);
            thus dom AddressPart I = dom <*a,b*> by A9,Th20
              .= Seg 2 by FINSEQ_3:29
              .= dom <*d1,d2*> by FINSEQ_3:29
              .= dom AddressPart J by A11,Th20;
          end;
          suppose
            (ex a,b st J = a:=b) or (ex a,b st J = AddTo(a,b)) or (ex
a,b st J = MultBy(a,b)) or (ex a,b st J = Divide(a,b)) or (ex i1 st J = goto i1
) or (ex i1,a st J = a=0_goto i1) or (ex i1,a st J = a>0_goto i1) or (ex b,a,f
st J = a:=(f,b)) or (ex a,b,f st J = (f,a):=b) or (ex a,f st J = a:=len f) or
            ex a,f st J = f:=<0,...,0>a;
            hence thesis by A1,A10,SCMFSA_2:42,43,45,46,47,48,49,50,51,52,53;
          end;
        end;
        hence thesis;
      end;
      suppose
        ex a,b st I = MultBy(a,b);
        then consider a, b such that
A12:    I = MultBy(a,b);
A13:    InsCode I = 4 by A12,SCMFSA_2:45;
        now
          per cases by SCMFSA_2:120;
          suppose
            J = [0,{}];
            hence thesis by A1,A12,AMI_3:71,SCMFSA_2:123;
          end;
          suppose
            ex a,b st J = MultBy(a,b);
            then consider d1, d2 such that
A14:        J = MultBy(d1,d2);
            thus dom AddressPart I = dom <*a,b*> by A12,Th21
              .= Seg 2 by FINSEQ_3:29
              .= dom <*d1,d2*> by FINSEQ_3:29
              .= dom AddressPart J by A14,Th21;
          end;
          suppose
            (ex a,b st J = a:=b) or (ex a,b st J = AddTo(a,b)) or (ex
a,b st J = SubFrom(a,b)) or (ex a,b st J = Divide(a,b)) or (ex i1 st J = goto
i1) or (ex i1,a st J = a=0_goto i1) or (ex i1,a st J = a>0_goto i1) or (ex b,a,
f st J = a:=(f,b)) or (ex a,b,f st J = (f,a):=b) or (ex a,f st J = a:=len f) or
            ex a,f st J = f:=<0,...,0>a;
            hence thesis by A1,A13,SCMFSA_2:42,43,44,46,47,48,49,50,51,52,53;
          end;
        end;
        hence thesis;
      end;
      suppose
        ex a,b st I = Divide(a,b);
        then consider a, b such that
A15:    I = Divide(a,b);
A16:    InsCode I = 5 by A15,SCMFSA_2:46;
        now
          per cases by SCMFSA_2:120;
          suppose
            J = [0,{}];
            hence thesis by A1,A15,AMI_3:71,SCMFSA_2:123;
          end;
          suppose
            ex a,b st J = Divide(a,b);
            then consider d1, d2 such that
A17:        J = Divide(d1,d2);
            thus dom AddressPart I = dom <*a,b*> by A15,Th22
              .= Seg 2 by FINSEQ_3:29
              .= dom <*d1,d2*> by FINSEQ_3:29
              .= dom AddressPart J by A17,Th22;
          end;
          suppose
            (ex a,b st J = a:=b) or (ex a,b st J = AddTo(a,b)) or (ex
a,b st J = SubFrom(a,b)) or (ex a,b st J = MultBy(a,b)) or (ex i1 st J = goto
i1) or (ex i1,a st J = a=0_goto i1) or (ex i1,a st J = a>0_goto i1) or (ex b,a,
f st J = a:=(f,b)) or (ex a,b,f st J = (f,a):=b) or (ex a,f st J = a:=len f) or
            ex a,f st J = f:=<0,...,0>a;
            hence thesis by A1,A16,SCMFSA_2:42,43,44,45,47,48,49,50,51,52,53;
          end;
        end;
        hence thesis;
      end;
      suppose
        ex i1 st I = goto i1;
        then consider i1 such that
A18:    I = goto i1;
A19:    InsCode I = 6 by A18,SCMFSA_2:47;
        now
          per cases by SCMFSA_2:120;
          suppose
            J = [0,{}];
            hence thesis by A1,A18,AMI_3:71,SCMFSA_2:47,123,124;
          end;
          suppose
            ex i2 st J = goto i2;
            then consider i2 such that
A20:        J = goto i2;
            thus dom AddressPart I = dom <*i1*> by A18,Th23
              .= Seg 1 by FINSEQ_1:def 8
              .= dom <*i2*> by FINSEQ_1:def 8
              .= dom AddressPart J by A20,Th23;
          end;
          suppose
            (ex a,b st J = a:=b) or (ex a,b st J = AddTo(a,b)) or (ex
a,b st J = SubFrom(a,b)) or (ex a,b st J = MultBy(a,b)) or (ex a,b st J =
Divide(a,b)) or (ex i1,a st J = a=0_goto i1) or (ex i1,a st J = a>0_goto i1) or
(ex b,a,f st J = a:=(f,b)) or (ex a,b,f st J = (f,a):=b) or (ex a,f st J = a
            :=len f) or ex a,f st J = f:=<0,...,0>a;
            hence thesis by A1,A19,SCMFSA_2:42,43,44,45,46,48,49,50,51,52,53;
          end;
        end;
        hence thesis;
      end;
      suppose
        ex i1,a st I = a=0_goto i1;
        then consider a, i1 such that
A21:    I = a=0_goto i1;
A22:    InsCode I = 7 by A21,SCMFSA_2:48;
        now
          per cases by SCMFSA_2:120;
          suppose
            J = [0,{}];
            hence thesis by A1,A21,AMI_3:71,SCMFSA_2:48,123,124;
          end;
          suppose
            ex i2,d1 st J = d1 =0_goto i2;
            then consider d1, i2 such that
A23:        J = d1 =0_goto i2;
            thus dom AddressPart I = dom <*i1,a*> by A21,Th24
              .= Seg 2 by FINSEQ_3:29
              .= dom <*i2,d1*> by FINSEQ_3:29
              .= dom AddressPart J by A23,Th24;
          end;
          suppose
            (ex a,b st J = a:=b) or (ex a,b st J = AddTo(a,b)) or (ex
a,b st J = SubFrom(a,b)) or (ex a,b st J = MultBy(a,b)) or (ex a,b st J =
Divide(a,b)) or (ex i1 st J = goto i1) or (ex i1,a st J = a>0_goto i1) or (ex b
,a,f st J = a:=(f,b)) or (ex a,b,f st J = (f,a):=b) or (ex a,f st J = a:=len f)
            or ex a,f st J = f:=<0,...,0>a;
            hence thesis by A1,A22,SCMFSA_2:42,43,44,45,46,47,49,50,51,52,53;
          end;
        end;
        hence thesis;
      end;
      suppose
        ex i1,a st I = a>0_goto i1;
        then consider a, i1 such that
A24:    I = a>0_goto i1;
A25:    InsCode I = 8 by A24,SCMFSA_2:49;
        now
          per cases by SCMFSA_2:120;
          suppose
            J = [0,{}];
            hence thesis by A1,A24,AMI_3:71,SCMFSA_2:49,123,124;
          end;
          suppose
            ex i2,d1 st J = d1 >0_goto i2;
            then consider d1, i2 such that
A26:        J = d1 >0_goto i2;
            thus dom AddressPart I = dom <*i1,a*> by A24,Th25
              .= Seg 2 by FINSEQ_3:29
              .= dom <*i2,d1*> by FINSEQ_3:29
              .= dom AddressPart J by A26,Th25;
          end;
          suppose
            (ex a,b st J = a:=b) or (ex a,b st J = AddTo(a,b)) or (ex
a,b st J = SubFrom(a,b)) or (ex a,b st J = MultBy(a,b)) or (ex a,b st J =
Divide(a,b)) or (ex i1 st J = goto i1) or (ex i1,a st J = a=0_goto i1) or (ex b
,a,f st J = a:=(f,b)) or (ex a,b,f st J = (f,a):=b) or (ex a,f st J = a:=len f)
            or ex a,f st J = f:=<0,...,0>a;
            hence thesis by A1,A25,SCMFSA_2:42,43,44,45,46,47,48,50,51,52,53;
          end;
        end;
        hence thesis;
      end;
      suppose
        ex a,b,f st I = b:=(f,a);
        then consider a, b, f such that
A27:    I = b:=(f,a);
A28:    InsCode I = 9 by A27,SCMFSA_2:50;
        now
          per cases by SCMFSA_2:120;
          suppose
            J = [0,{}];
            hence thesis by A1,A27,AMI_3:71,SCMFSA_2:123;
          end;
          suppose
            ex a,b,f st J = b:=(f,a);
            then consider d1, d2, f1 such that
A29:        J = d2:=(f1,d1);
            thus dom AddressPart I = dom <*b,f,a*> by A27,MCART_1:def 2
              .= Seg 3 by FINSEQ_3:30
              .= dom <*d2,f1,d1*> by FINSEQ_3:30
              .= dom AddressPart J by A29,MCART_1:def 2;
          end;
          suppose
            (ex a,b st J = a:=b) or (ex a,b st J = AddTo(a,b)) or (ex
a,b st J = SubFrom(a,b)) or (ex a,b st J = MultBy(a,b)) or (ex a,b st J =
Divide(a,b)) or (ex i1 st J = goto i1) or (ex i1,a st J = a=0_goto i1) or (ex
i1,a st J = a>0_goto i1) or (ex a,b,f st J = (f,a):=b) or (ex a,f st J = a:=len
            f) or ex a,f st J = f:=<0,...,0>a;
            hence thesis by A1,A28,SCMFSA_2:42,43,44,45,46,47,48,49,51,52,53;
          end;
        end;
        hence thesis;
      end;
      suppose
        ex a,b,f st I = (f,a):=b;
        then consider a, b, f such that
A30:    I = (f,a):=b;
A31:    InsCode I = 10 by A30,SCMFSA_2:51;
        now
          per cases by SCMFSA_2:120;
          suppose
            J = [0,{}];
            hence thesis by A1,A30,AMI_3:71,SCMFSA_2:123;
          end;
          suppose
            ex a,b,f st J = (f,a):=b;
            then consider d1, d2, f1 such that
A32:        J = (f1,d1):=d2;
            thus dom AddressPart I = dom <*b,f,a*> by A30,MCART_1:def 2
              .= Seg 3 by FINSEQ_3:30
              .= dom <*d2,f1,d1*> by FINSEQ_3:30
              .= dom AddressPart J by A32,MCART_1:def 2;
          end;
          suppose
            (ex a,b st J = a:=b) or (ex a,b st J = AddTo(a,b)) or (ex
a,b st J = SubFrom(a,b)) or (ex a,b st J = MultBy(a,b)) or (ex a,b st J =
Divide(a,b)) or (ex i1 st J = goto i1) or (ex i1,a st J = a=0_goto i1) or (ex
i1,a st J = a>0_goto i1) or (ex a,b,f st J = b:=(f,a)) or (ex a,f st J = a:=len
            f) or ex a,f st J = f:=<0,...,0>a;
            hence thesis by A1,A31,SCMFSA_2:42,43,44,45,46,47,48,49,50,52,53;
          end;
        end;
        hence thesis;
      end;
      suppose
        ex a,f st I = a:=len f;
        then consider a, f such that
A33:    I = a:=len f;
A34:    InsCode I = 11 by A33,SCMFSA_2:52;
        now
          per cases by SCMFSA_2:120;
          suppose
            J = [0,{}];
            hence thesis by A1,A33,AMI_3:71,SCMFSA_2:123;
          end;
          suppose
            ex a,f st J = a:=len f;
            then consider d1, f1 such that
A35:        J = d1:=len f1;
            thus dom AddressPart I = dom <*a,f*> by A33,MCART_1:def 2
              .= Seg 2 by FINSEQ_3:29
              .= dom <*d1,f1*> by FINSEQ_3:29
              .= dom AddressPart J by A35,MCART_1:def 2;
          end;
          suppose
            (ex a,b st J = a:=b) or (ex a,b st J = AddTo(a,b)) or (ex
a,b st J = SubFrom(a,b)) or (ex a,b st J = MultBy(a,b)) or (ex a,b st J =
Divide(a,b)) or (ex i1 st J = goto i1) or (ex i1,a st J = a=0_goto i1) or (ex
i1,a st J = a>0_goto i1) or (ex a,b,f st J = b:=(f,a)) or (ex a,b,f st J = (f,a
            ):=b) or ex a,f st J = f:=<0,...,0>a;
            hence thesis by A1,A34,SCMFSA_2:42,43,44,45,46,47,48,49,50,51,53;
          end;
        end;
        hence thesis;
      end;
      suppose
        ex a,f st I = f:=<0,...,0>a;
        then consider a, f such that
A36:    I = f:=<0,...,0>a;
A37:    InsCode I = 12 by A36,SCMFSA_2:53;
        now
          per cases by SCMFSA_2:120;
          suppose
            J = [0,{}];
            hence thesis by A1,A36,AMI_3:71,SCMFSA_2:123;
          end;
          suppose
            ex a,f st J = f:=<0,...,0>a;
            then consider d1, f1 such that
A38:        J = f1:=<0,...,0>d1;
            thus dom AddressPart I = dom <*a,f*> by A36,MCART_1:def 2
              .= Seg 2 by FINSEQ_3:29
              .= dom <*d1,f1*> by FINSEQ_3:29
              .= dom AddressPart J by A38,MCART_1:def 2;
          end;
          suppose
            (ex a,b st J = a:=b) or (ex a,b st J = AddTo(a,b)) or (ex
a,b st J = SubFrom(a,b)) or (ex a,b st J = MultBy(a,b)) or (ex a,b st J =
Divide(a,b)) or (ex i1 st J = goto i1) or (ex i1,a st J = a=0_goto i1) or (ex
i1,a st J = a>0_goto i1) or (ex a,b,f st J = b:=(f,a)) or (ex a,b,f st J = (f,a
            ):=b) or ex a,f st J = a:=len f;
            hence thesis by A1,A37,SCMFSA_2:42,43,44,45,46,47,48,49,50,51,52;
          end;
        end;
        hence thesis;
      end;
    end;
    thus SCM+FSA is with_explicit_jumps
    proof
      let I be Instruction of SCM+FSA;
      let f be set such that
A39:  f in JUMP I;
      per cases by SCMFSA_2:120;
      suppose
        I = [0,{}];
        hence thesis by A39,AMI_3:71,SCMFSA_2:123;
      end;
      suppose
        ex a,b st I = a:=b;
        hence thesis by A39;
      end;
      suppose
        ex a,b st I = AddTo(a,b);
        hence thesis by A39;
      end;
      suppose
        ex a,b st I = SubFrom(a,b);
        hence thesis by A39;
      end;
      suppose
        ex a,b st I = MultBy(a,b);
        hence thesis by A39;
      end;
      suppose
        ex a,b st I = Divide(a,b);
        hence thesis by A39;
      end;
      suppose
A40:    ex i1 st I = goto i1;
        take 1;
        consider i1 such that
A41:    I = goto i1 by A40;
A42:    AddressPart goto i1 = <*i1*> by Th23;
        dom <*i1*> = Seg 1 by FINSEQ_1:def 8;
        hence 1 in dom AddressPart I by A41,A42,FINSEQ_1:4,TARSKI:def 1;
        JUMP goto i1 = {i1} by Th75;
        then f = i1 by A39,A41,TARSKI:def 1;
        hence
        f = (AddressPart I).1 & (product" AddressParts InsCode I).1 = NAT
        by A41,A42,Th53,FINSEQ_1:def 8;
      end;
      suppose
A43:    ex i1,a st I = a=0_goto i1;
        take 1;
        consider a, i1 such that
A44:    I = a=0_goto i1 by A43;
A45:    AddressPart (a=0_goto i1) = <*i1,a*> by Th24;
        dom <*i1,a*> = Seg 2 by FINSEQ_3:29;
        hence 1 in dom AddressPart I by A44,A45,FINSEQ_1:4,TARSKI:def 2;
        JUMP (a=0_goto i1) = {i1} by Th77;
        then f = i1 by A39,A44,TARSKI:def 1;
        hence
        f = (AddressPart I).1 & (product" AddressParts InsCode I).1 = NAT
        by A44,A45,Th54,FINSEQ_1:61;
      end;
      suppose
A46:    ex i1,a st I = a>0_goto i1;
        take 1;
        consider a, i1 such that
A47:    I = a>0_goto i1 by A46;
A48:    AddressPart (a>0_goto i1) = <*i1,a*> by Th25;
        dom <*i1,a*> = Seg 2 by FINSEQ_3:29;
        hence 1 in dom AddressPart I by A47,A48,FINSEQ_1:4,TARSKI:def 2;
        JUMP (a>0_goto i1) = {i1} by Th79;
        then f = i1 by A39,A47,TARSKI:def 1;
        hence
        f = (AddressPart I).1 & (product" AddressParts InsCode I).1 = NAT
        by A47,A48,Th56,FINSEQ_1:61;
      end;
      suppose
        ex a,b,f st I = b:=(f,a);
        hence thesis by A39;
      end;
      suppose
        ex a,b,f st I = (f,a):=b;
        hence thesis by A39;
      end;
      suppose
        ex a,f st I = a:=len f;
        hence thesis by A39;
      end;
      suppose
        ex a,f st I = f:=<0,...,0>a;
        hence thesis by A39;
      end;
    end;
    let I be Instruction of SCM+FSA;
    let f be set;
    given k being set such that
A49: k in dom AddressPart I and
A50: f = (AddressPart I).k and
A51: (product" AddressParts InsCode I).k = NAT;
    per cases by SCMFSA_2:120;
    suppose
      I = [0,{}];
      then dom AddressPart I = dom {} by MCART_1:def 2;
      hence thesis by A49;
    end;
    suppose
      ex a,b st I = a:=b;
      then consider a, b such that
A52:  I = a:=b;
      k in dom <*a,b*> by A49,A52,Th18;
      then k = 1 or k = 2 by Lm2;
      hence thesis by A51,A52,Th5,Th43,Th44;
    end;
    suppose
      ex a,b st I = AddTo(a,b);
      then consider a, b such that
A53:  I = AddTo(a,b);
      k in dom <*a,b*> by A49,A53,Th19;
      then k = 1 or k = 2 by Lm2;
      hence thesis by A51,A53,Th5,Th45,Th46;
    end;
    suppose
      ex a,b st I = SubFrom(a,b);
      then consider a, b such that
A54:  I = SubFrom(a,b);
      k in dom <*a,b*> by A49,A54,Th20;
      then k = 1 or k = 2 by Lm2;
      hence thesis by A51,A54,Th5,Th47,Th48;
    end;
    suppose
      ex a,b st I = MultBy(a,b);
      then consider a, b such that
A55:  I = MultBy(a,b);
      k in dom <*a,b*> by A49,A55,Th21;
      then k = 1 or k = 2 by Lm2;
      hence thesis by A51,A55,Th5,Th49,Th50;
    end;
    suppose
      ex a,b st I = Divide(a,b);
      then consider a, b such that
A56:  I = Divide(a,b);
      k in dom <*a,b*> by A49,A56,Th22;
      then k = 1 or k = 2 by Lm2;
      hence thesis by A51,A56,Th5,Th51,Th52;
    end;
    suppose
      ex i1 st I = goto i1;
      then consider i1 such that
A57:  I = goto i1;
A58:  AddressPart I = <*i1*> by A57,Th23;
      then k = 1 by A49,Lm1;
      then
A59:  f = i1 by A50,A58,FINSEQ_1:def 8;
      JUMP I = {i1} by A57,Th75;
      hence thesis by A59,TARSKI:def 1;
    end;
    suppose
      ex i1,a st I = a=0_goto i1;
      then consider a, i1 such that
A60:  I = a=0_goto i1;
A61:  AddressPart I = <*i1,a*> by A60,Th24;
      then k = 1 or k = 2 by A49,Lm2;
      then
A62:  f = i1 by A50,A51,A60,A61,Th5,Th55,FINSEQ_1:61;
      JUMP I = {i1} by A60,Th77;
      hence thesis by A62,TARSKI:def 1;
    end;
    suppose
      ex i1,a st I = a>0_goto i1;
      then consider a, i1 such that
A63:  I = a>0_goto i1;
A64:  AddressPart I = <*i1,a*> by A63,Th25;
      then k = 1 or k = 2 by A49,Lm2;
      then
A65:  f = i1 by A50,A51,A63,A64,Th5,Th57,FINSEQ_1:61;
      JUMP I = {i1} by A63,Th79;
      hence thesis by A65,TARSKI:def 1;
    end;
    suppose
      ex a,b,f st I = b:=(f,a);
      then consider a, b, f such that
A66:  I = b:=(f,a);
      k in dom <*b,f,a*> by A49,A66,MCART_1:def 2;
      then k = 1 or k = 2 or k = 3 by Lm3;
      hence thesis by A51,A66,Th5,Th6,Th58,Th59,Th60;
    end;
    suppose
      ex a,b,f st I = (f,a):=b;
      then consider a, b, f such that
A67:  I = (f,a):=b;
      k in dom <*b,f,a*> by A49,A67,MCART_1:def 2;
      then k = 1 or k = 2 or k = 3 by Lm3;
      hence thesis by A51,A67,Th5,Th6,Th61,Th62,Th63;
    end;
    suppose
      ex a,f st I = a:=len f;
      then consider a, f such that
A68:  I = a:=len f;
      k in dom <*a,f*> by A49,A68,MCART_1:def 2;
      then k = 1 or k = 2 by Lm2;
      hence thesis by A51,A68,Th5,Th6,Th64,Th65;
    end;
    suppose
      ex a,f st I = f:=<0,...,0>a;
      then consider a, f such that
A69:  I = f:=<0,...,0>a;
      k in dom <*a,f*> by A49,A69,MCART_1:def 2;
      then k = 1 or k = 2 by Lm2;
      hence thesis by A51,A69,Th5,Th6,Th66,Th67;
    end;
  end;
end;

registration
  cluster SCM+FSA -> regular;
  coherence
  proof
    let T be InsType of SCM+FSA;
    per cases by Lm4;
    suppose
A1:   T = 0;
      reconsider f = {} as Function;
      take f;
      thus thesis by A1,Th30,CARD_3:19;
    end;
    suppose
A2:   T = 1;
      take product" AddressParts T;
      thus AddressParts T c= product product" AddressParts T by CARD_3:94;
      let x be set;
      assume
      x in product product" AddressParts T;
      then consider f being Function such that
A3:   x = f and
A4:   dom f = dom product" AddressParts T and
A5:   for k being set st k in dom product" AddressParts T holds f.k in
      (product" AddressParts T).k by CARD_3:def 5;
A6:   dom product" AddressParts T = {1,2} by A2,Th31;
      then
A7:   1 in dom product" AddressParts T by TARSKI:def 2;
      then f.1 in (product" AddressParts T).1 by A5;
      then f.1 in pi(AddressParts T,1) by A7,CARD_3:def 13;
      then consider g being Function such that
A8:   g in AddressParts T and
A9:   g.1 = f.1 by CARD_3:def 6;
      consider I being Instruction of SCM+FSA such that
A10:  g = AddressPart I and
A11:  InsCode I = T by A8;
      consider d1, b such that
A12:  I = d1:=b by A2,A11,SCMFSA_2:54;
A13:  2 in dom product" AddressParts T by A6,TARSKI:def 2;
      then f.2 in (product" AddressParts T).2 by A5;
      then f.2 in pi(AddressParts T,2) by A13,CARD_3:def 13;
      then consider h being Function such that
A14:  h in AddressParts T and
A15:  h.2 = f.2 by CARD_3:def 6;
      consider J being Instruction of SCM+FSA such that
A16:  h = AddressPart J and
A17:  InsCode J = T by A14;
      consider a, d2 such that
A18:  J = a:=d2 by A2,A17,SCMFSA_2:54;
A19:  h = <*a,d2*> by A16,A18,Th18;
A20:  g = <*d1,b*> by A10,A12,Th18;
A21:  for k being set st k in {1,2} holds <*d1,d2*>.k = f.k
      proof
        let k be set;
        assume
A22:    k in {1,2};
        per cases by A22,TARSKI:def 2;
        suppose
A23:      k = 1;
          <*d1,d2*>.1 = d1 by FINSEQ_1:61
            .= f.1 by A9,A20,FINSEQ_1:61;
          hence thesis by A23;
        end;
        suppose
A24:      k = 2;
          <*d1,d2*>.2 = d2 by FINSEQ_1:61
            .= f.2 by A15,A19,FINSEQ_1:61;
          hence thesis by A24;
        end;
      end;
      dom <*d1,d2*> = {1,2} by FINSEQ_1:4,FINSEQ_3:29;
      then
A25:  <*d1,d2*> = f by A4,A6,A21,FUNCT_1:9;
A26:  InsCode (d1:=d2) = 1 by SCMFSA_2:42;
      AddressPart (d1:=d2) = <*d1,d2*> by Th18;
      hence thesis by A2,A3,A25,A26;
    end;
    suppose
A27:  T = 2;
      take product" AddressParts T;
      thus AddressParts T c= product product" AddressParts T by CARD_3:94;
      let x be set;
      assume
      x in product product" AddressParts T;
      then consider f being Function such that
A28:  x = f and
A29:  dom f = dom product" AddressParts T and
A30:  for k being set st k in dom product" AddressParts T holds f.k
      in (product" AddressParts T).k by CARD_3:def 5;
A31:  dom product" AddressParts T = {1,2} by A27,Th32;
      then
A32:  1 in dom product" AddressParts T by TARSKI:def 2;
      then f.1 in (product" AddressParts T).1 by A30;
      then f.1 in pi(AddressParts T,1) by A32,CARD_3:def 13;
      then consider g being Function such that
A33:  g in AddressParts T and
A34:  g.1 = f.1 by CARD_3:def 6;
      consider I being Instruction of SCM+FSA such that
A35:  g = AddressPart I and
A36:  InsCode I = T by A33;
      consider d1, b such that
A37:  I = AddTo(d1,b) by A27,A36,SCMFSA_2:55;
A38:  2 in dom product" AddressParts T by A31,TARSKI:def 2;
      then f.2 in (product" AddressParts T).2 by A30;
      then f.2 in pi(AddressParts T,2) by A38,CARD_3:def 13;
      then consider h being Function such that
A39:  h in AddressParts T and
A40:  h.2 = f.2 by CARD_3:def 6;
      consider J being Instruction of SCM+FSA such that
A41:  h = AddressPart J and
A42:  InsCode J = T by A39;
      consider a, d2 such that
A43:  J = AddTo(a,d2) by A27,A42,SCMFSA_2:55;
A44:  h = <*a,d2*> by A41,A43,Th19;
A45:  g = <*d1,b*> by A35,A37,Th19;
A46:  for k being set st k in {1,2} holds <*d1,d2*>.k = f.k
      proof
        let k be set;
        assume
A47:    k in {1,2};
        per cases by A47,TARSKI:def 2;
        suppose
A48:      k = 1;
          <*d1,d2*>.1 = d1 by FINSEQ_1:61
            .= f.1 by A34,A45,FINSEQ_1:61;
          hence thesis by A48;
        end;
        suppose
A49:      k = 2;
          <*d1,d2*>.2 = d2 by FINSEQ_1:61
            .= f.2 by A40,A44,FINSEQ_1:61;
          hence thesis by A49;
        end;
      end;
      dom <*d1,d2*> = {1,2} by FINSEQ_1:4,FINSEQ_3:29;
      then
A50:  <*d1,d2*> = f by A29,A31,A46,FUNCT_1:9;
A51:  InsCode AddTo(d1,d2) = 2 by SCMFSA_2:43;
      AddressPart AddTo(d1,d2) = <*d1,d2*> by Th19;
      hence thesis by A27,A28,A50,A51;
    end;
    suppose
A52:  T = 3;
      take product" AddressParts T;
      thus AddressParts T c= product product" AddressParts T by CARD_3:94;
      let x be set;
      assume
      x in product product" AddressParts T;
      then consider f being Function such that
A53:  x = f and
A54:  dom f = dom product" AddressParts T and
A55:  for k being set st k in dom product" AddressParts T holds f.k
      in (product" AddressParts T).k by CARD_3:def 5;
A56:  dom product" AddressParts T = {1,2} by A52,Th33;
      then
A57:  1 in dom product" AddressParts T by TARSKI:def 2;
      then f.1 in (product" AddressParts T).1 by A55;
      then f.1 in pi(AddressParts T,1) by A57,CARD_3:def 13;
      then consider g being Function such that
A58:  g in AddressParts T and
A59:  g.1 = f.1 by CARD_3:def 6;
      consider I being Instruction of SCM+FSA such that
A60:  g = AddressPart I and
A61:  InsCode I = T by A58;
      consider d1, b such that
A62:  I = SubFrom(d1,b) by A52,A61,SCMFSA_2:56;
A63:  2 in dom product" AddressParts T by A56,TARSKI:def 2;
      then f.2 in (product" AddressParts T).2 by A55;
      then f.2 in pi(AddressParts T,2) by A63,CARD_3:def 13;
      then consider h being Function such that
A64:  h in AddressParts T and
A65:  h.2 = f.2 by CARD_3:def 6;
      consider J being Instruction of SCM+FSA such that
A66:  h = AddressPart J and
A67:  InsCode J = T by A64;
      consider a, d2 such that
A68:  J = SubFrom(a,d2) by A52,A67,SCMFSA_2:56;
A69:  h = <*a,d2*> by A66,A68,Th20;
A70:  g = <*d1,b*> by A60,A62,Th20;
A71:  for k being set st k in {1,2} holds <*d1,d2*>.k = f.k
      proof
        let k be set;
        assume
A72:    k in {1,2};
        per cases by A72,TARSKI:def 2;
        suppose
A73:      k = 1;
          <*d1,d2*>.1 = d1 by FINSEQ_1:61
            .= f.1 by A59,A70,FINSEQ_1:61;
          hence thesis by A73;
        end;
        suppose
A74:      k = 2;
          <*d1,d2*>.2 = d2 by FINSEQ_1:61
            .= f.2 by A65,A69,FINSEQ_1:61;
          hence thesis by A74;
        end;
      end;
      dom <*d1,d2*> = {1,2} by FINSEQ_1:4,FINSEQ_3:29;
      then
A75:  <*d1,d2*> = f by A54,A56,A71,FUNCT_1:9;
A76:  InsCode SubFrom(d1,d2) = 3 by SCMFSA_2:44;
      AddressPart SubFrom(d1,d2) = <*d1,d2*> by Th20;
      hence thesis by A52,A53,A75,A76;
    end;
    suppose
A77:  T = 4;
      take product" AddressParts T;
      thus AddressParts T c= product product" AddressParts T by CARD_3:94;
      let x be set;
      assume
      x in product product" AddressParts T;
      then consider f being Function such that
A78:  x = f and
A79:  dom f = dom product" AddressParts T and
A80:  for k being set st k in dom product" AddressParts T holds f.k
      in (product" AddressParts T).k by CARD_3:def 5;
A81:  dom product" AddressParts T = {1,2} by A77,Th34;
      then
A82:  1 in dom product" AddressParts T by TARSKI:def 2;
      then f.1 in (product" AddressParts T).1 by A80;
      then f.1 in pi(AddressParts T,1) by A82,CARD_3:def 13;
      then consider g being Function such that
A83:  g in AddressParts T and
A84:  g.1 = f.1 by CARD_3:def 6;
      consider I being Instruction of SCM+FSA such that
A85:  g = AddressPart I and
A86:  InsCode I = T by A83;
      consider d1, b such that
A87:  I = MultBy(d1,b) by A77,A86,SCMFSA_2:57;
A88:  2 in dom product" AddressParts T by A81,TARSKI:def 2;
      then f.2 in (product" AddressParts T).2 by A80;
      then f.2 in pi(AddressParts T,2) by A88,CARD_3:def 13;
      then consider h being Function such that
A89:  h in AddressParts T and
A90:  h.2 = f.2 by CARD_3:def 6;
      consider J being Instruction of SCM+FSA such that
A91:  h = AddressPart J and
A92:  InsCode J = T by A89;
      consider a, d2 such that
A93:  J = MultBy(a,d2) by A77,A92,SCMFSA_2:57;
A94:  h = <*a,d2*> by A91,A93,Th21;
A95:  g = <*d1,b*> by A85,A87,Th21;
A96:  for k being set st k in {1,2} holds <*d1,d2*>.k = f.k
      proof
        let k be set;
        assume
A97:    k in {1,2};
        per cases by A97,TARSKI:def 2;
        suppose
A98:      k = 1;
          <*d1,d2*>.1 = d1 by FINSEQ_1:61
            .= f.1 by A84,A95,FINSEQ_1:61;
          hence thesis by A98;
        end;
        suppose
A99:      k = 2;
          <*d1,d2*>.2 = d2 by FINSEQ_1:61
            .= f.2 by A90,A94,FINSEQ_1:61;
          hence thesis by A99;
        end;
      end;
      dom <*d1,d2*> = {1,2} by FINSEQ_1:4,FINSEQ_3:29;
      then
A100: <*d1,d2*> = f by A79,A81,A96,FUNCT_1:9;
A101: InsCode MultBy(d1,d2) = 4 by SCMFSA_2:45;
      AddressPart MultBy(d1,d2) = <*d1,d2*> by Th21;
      hence thesis by A77,A78,A100,A101;
    end;
    suppose
A102: T = 5;
      take product" AddressParts T;
      thus AddressParts T c= product product" AddressParts T by CARD_3:94;
      let x be set;
      assume
      x in product product" AddressParts T;
      then consider f being Function such that
A103: x = f and
A104: dom f = dom product" AddressParts T and
A105: for k being set st k in dom product" AddressParts T holds f.k
      in (product" AddressParts T).k by CARD_3:def 5;
A106: dom product" AddressParts T = {1,2} by A102,Th35;
      then
A107: 1 in dom product" AddressParts T by TARSKI:def 2;
      then f.1 in (product" AddressParts T).1 by A105;
      then f.1 in pi(AddressParts T,1) by A107,CARD_3:def 13;
      then consider g being Function such that
A108: g in AddressParts T and
A109: g.1 = f.1 by CARD_3:def 6;
      consider I being Instruction of SCM+FSA such that
A110: g = AddressPart I and
A111: InsCode I = T by A108;
      consider d1, b such that
A112: I = Divide(d1,b) by A102,A111,SCMFSA_2:58;
A113: 2 in dom product" AddressParts T by A106,TARSKI:def 2;
      then f.2 in (product" AddressParts T).2 by A105;
      then f.2 in pi(AddressParts T,2) by A113,CARD_3:def 13;
      then consider h being Function such that
A114: h in AddressParts T and
A115: h.2 = f.2 by CARD_3:def 6;
      consider J being Instruction of SCM+FSA such that
A116: h = AddressPart J and
A117: InsCode J = T by A114;
      consider a, d2 such that
A118: J = Divide(a,d2) by A102,A117,SCMFSA_2:58;
A119: h = <*a,d2*> by A116,A118,Th22;
A120: g = <*d1,b*> by A110,A112,Th22;
A121: for k being set st k in {1,2} holds <*d1,d2*>.k = f.k
      proof
        let k be set;
        assume
A122:   k in {1,2};
        per cases by A122,TARSKI:def 2;
        suppose
A123:     k = 1;
          <*d1,d2*>.1 = d1 by FINSEQ_1:61
            .= f.1 by A109,A120,FINSEQ_1:61;
          hence thesis by A123;
        end;
        suppose
A124:     k = 2;
          <*d1,d2*>.2 = d2 by FINSEQ_1:61
            .= f.2 by A115,A119,FINSEQ_1:61;
          hence thesis by A124;
        end;
      end;
      dom <*d1,d2*> = {1,2} by FINSEQ_1:4,FINSEQ_3:29;
      then
A125: <*d1,d2*> = f by A104,A106,A121,FUNCT_1:9;
A126: InsCode Divide(d1,d2) = 5 by SCMFSA_2:46;
      AddressPart Divide(d1,d2) = <*d1,d2*> by Th22;
      hence thesis by A102,A103,A125,A126;
    end;
    suppose
A127: T = 6;
      take product" AddressParts T;
      thus AddressParts T c= product product" AddressParts T by CARD_3:94;
      let x be set;
      assume
      x in product product" AddressParts T;
      then consider f being Function such that
A128: x = f and
A129: dom f = dom product" AddressParts T and
A130: for k being set st k in dom product" AddressParts T holds f.k
      in (product" AddressParts T).k by CARD_3:def 5;
A131: dom product" AddressParts T = {1} by A127,Th36;
      then
A132: 1 in dom product" AddressParts T by TARSKI:def 1;
      then f.1 in (product" AddressParts T).1 by A130;
      then f.1 in pi(AddressParts T,1) by A132,CARD_3:def 13;
      then consider g being Function such that
A133: g in AddressParts T and
A134: g.1 = f.1 by CARD_3:def 6;
      consider I being Instruction of SCM+FSA such that
A135: g = AddressPart I and
A136: InsCode I = T by A133;
      consider i1 such that
A137: I = goto i1 by A127,A136,SCMFSA_2:59;
A138: for k being set st k in {1} holds <*i1*>.k = f.k
      proof
        let k be set;
        assume
        k in {1};
        then k = 1 by TARSKI:def 1;
        hence thesis by A134,A135,A137,Th23;
      end;
      dom <*i1*> = {1} by FINSEQ_1:4,def 8;
      then
A139: <*i1*> = f by A129,A131,A138,FUNCT_1:9;
A140: InsCode goto i1 = 6 by SCMFSA_2:47;
      AddressPart goto i1 = <*i1*> by Th23;
      hence thesis by A127,A128,A139,A140;
    end;
    suppose
A141: T = 7;
      take product" AddressParts T;
      thus AddressParts T c= product product" AddressParts T by CARD_3:94;
      let x be set;
      assume
      x in product product" AddressParts T;
      then consider f being Function such that
A142: x = f and
A143: dom f = dom product" AddressParts T and
A144: for k being set st k in dom product" AddressParts T holds f.k
      in (product" AddressParts T).k by CARD_3:def 5;
A145: dom product" AddressParts T = {1,2} by A141,Th37;
      then
A146: 1 in dom product" AddressParts T by TARSKI:def 2;
      then f.1 in (product" AddressParts T).1 by A144;
      then f.1 in pi(AddressParts T,1) by A146,CARD_3:def 13;
      then consider g being Function such that
A147: g in AddressParts T and
A148: g.1 = f.1 by CARD_3:def 6;
      consider I being Instruction of SCM+FSA such that
A149: g = AddressPart I and
A150: InsCode I = T by A147;
      consider i1, d1 such that
A151: I = d1 =0_goto i1 by A141,A150,SCMFSA_2:60;
A152: 2 in dom product" AddressParts T by A145,TARSKI:def 2;
      then f.2 in (product" AddressParts T).2 by A144;
      then f.2 in pi(AddressParts T,2) by A152,CARD_3:def 13;
      then consider h being Function such that
A153: h in AddressParts T and
A154: h.2 = f.2 by CARD_3:def 6;
      consider J being Instruction of SCM+FSA such that
A155: h = AddressPart J and
A156: InsCode J = T by A153;
      consider i2, d2 such that
A157: J = d2 =0_goto i2 by A141,A156,SCMFSA_2:60;
A158: h = <*i2,d2*> by A155,A157,Th24;
A159: g = <*i1,d1*> by A149,A151,Th24;
A160: for k being set st k in {1,2} holds <*i1,d2*>.k = f.k
      proof
        let k be set;
        assume
A161:   k in {1,2};
        per cases by A161,TARSKI:def 2;
        suppose
A162:     k = 1;
          <*i1,d2*>.1 = i1 by FINSEQ_1:61
            .= f.1 by A148,A159,FINSEQ_1:61;
          hence thesis by A162;
        end;
        suppose
A163:     k = 2;
          <*i1,d2*>.2 = d2 by FINSEQ_1:61
            .= f.2 by A154,A158,FINSEQ_1:61;
          hence thesis by A163;
        end;
      end;
      dom <*i1,d2*> = {1,2} by FINSEQ_1:4,FINSEQ_3:29;
      then
A164: <*i1,d2*> = f by A143,A145,A160,FUNCT_1:9;
A165: InsCode (d2 =0_goto i1) = 7 by SCMFSA_2:48;
      AddressPart (d2 =0_goto i1) = <*i1,d2*> by Th24;
      hence thesis by A141,A142,A164,A165;
    end;
    suppose
A166: T = 8;
      take product" AddressParts T;
      thus AddressParts T c= product product" AddressParts T by CARD_3:94;
      let x be set;
      assume
      x in product product" AddressParts T;
      then consider f being Function such that
A167: x = f and
A168: dom f = dom product" AddressParts T and
A169: for k being set st k in dom product" AddressParts T holds f.k
      in (product" AddressParts T).k by CARD_3:def 5;
A170: dom product" AddressParts T = {1,2} by A166,Th38;
      then
A171: 1 in dom product" AddressParts T by TARSKI:def 2;
      then f.1 in (product" AddressParts T).1 by A169;
      then f.1 in pi(AddressParts T,1) by A171,CARD_3:def 13;
      then consider g being Function such that
A172: g in AddressParts T and
A173: g.1 = f.1 by CARD_3:def 6;
      consider I being Instruction of SCM+FSA such that
A174: g = AddressPart I and
A175: InsCode I = T by A172;
      consider i1, d1 such that
A176: I = d1 >0_goto i1 by A166,A175,SCMFSA_2:61;
A177: 2 in dom product" AddressParts T by A170,TARSKI:def 2;
      then f.2 in (product" AddressParts T).2 by A169;
      then f.2 in pi(AddressParts T,2) by A177,CARD_3:def 13;
      then consider h being Function such that
A178: h in AddressParts T and
A179: h.2 = f.2 by CARD_3:def 6;
      consider J being Instruction of SCM+FSA such that
A180: h = AddressPart J and
A181: InsCode J = T by A178;
      consider i2, d2 such that
A182: J = d2 >0_goto i2 by A166,A181,SCMFSA_2:61;
A183: h = <*i2,d2*> by A180,A182,Th25;
A184: g = <*i1,d1*> by A174,A176,Th25;
A185: for k being set st k in {1,2} holds <*i1,d2*>.k = f.k
      proof
        let k be set;
        assume
A186:   k in {1,2};
        per cases by A186,TARSKI:def 2;
        suppose
A187:     k = 1;
          <*i1,d2*>.1 = i1 by FINSEQ_1:61
            .= f.1 by A173,A184,FINSEQ_1:61;
          hence thesis by A187;
        end;
        suppose
A188:     k = 2;
          <*i1,d2*>.2 = d2 by FINSEQ_1:61
            .= f.2 by A179,A183,FINSEQ_1:61;
          hence thesis by A188;
        end;
      end;
      dom <*i1,d2*> = {1,2} by FINSEQ_1:4,FINSEQ_3:29;
      then
A189: <*i1,d2*> = f by A168,A170,A185,FUNCT_1:9;
A190: InsCode (d2 >0_goto i1) = 8 by SCMFSA_2:49;
      AddressPart (d2 >0_goto i1) = <*i1,d2*> by Th25;
      hence thesis by A166,A167,A189,A190;
    end;
    suppose
A191: T = 9;
      take product" AddressParts T;
      thus AddressParts T c= product product" AddressParts T by CARD_3:94;
      let x be set;
      assume
      x in product product" AddressParts T;
      then consider f being Function such that
A192: x = f and
A193: dom f = dom product" AddressParts T and
A194: for k being set st k in dom product" AddressParts T holds f.k
      in (product" AddressParts T).k by CARD_3:def 5;
A195: dom product" AddressParts T = {1,2,3} by A191,Th39;
      then
A196: 1 in dom product" AddressParts T by ENUMSET1:def 1;
      then f.1 in (product" AddressParts T).1 by A194;
      then f.1 in pi(AddressParts T,1) by A196,CARD_3:def 13;
      then consider g being Function such that
A197: g in AddressParts T and
A198: g.1 = f.1 by CARD_3:def 6;
      consider I being Instruction of SCM+FSA such that
A199: g = AddressPart I and
A200: InsCode I = T by A197;
      consider a, b, f1 such that
A201: I = b:=(f1,a) by A191,A200,SCMFSA_2:62;
A202: 3 in dom product" AddressParts T by A195,ENUMSET1:def 1;
      then f.3 in (product" AddressParts T).3 by A194;
      then f.3 in pi(AddressParts T,3) by A202,CARD_3:def 13;
      then consider z being Function such that
A203: z in AddressParts T and
A204: z.3 = f.3 by CARD_3:def 6;
      consider K being Instruction of SCM+FSA such that
A205: z = AddressPart K and
A206: InsCode K = T by A203;
      consider d3, d4, f3 such that
A207: K = d4:=(f3,d3) by A191,A206,SCMFSA_2:62;
A208: 2 in dom product" AddressParts T by A195,ENUMSET1:def 1;
      then f.2 in (product" AddressParts T).2 by A194;
      then f.2 in pi(AddressParts T,2) by A208,CARD_3:def 13;
      then consider h being Function such that
A209: h in AddressParts T and
A210: h.2 = f.2 by CARD_3:def 6;
      consider J being Instruction of SCM+FSA such that
A211: h = AddressPart J and
A212: InsCode J = T by A209;
      consider d1, d2, f2 such that
A213: J = d2:=(f2,d1) by A191,A212,SCMFSA_2:62;
A214: z = <*d4,f3,d3*> by A205,A207,MCART_1:def 2;
A215: h = <*d2,f2,d1*> by A211,A213,MCART_1:def 2;
A216: g = <*b,f1,a*> by A199,A201,MCART_1:def 2;
A217: for k being set st k in {1,2,3} holds <*b,f2,d3*>.k = f.k
      proof
        let k be set;
        assume
A218:   k in {1,2,3};
        per cases by A218,ENUMSET1:def 1;
        suppose
A219:     k = 1;
          <*b,f2,d3*>.1 = b by FINSEQ_1:62
            .= f.1 by A198,A216,FINSEQ_1:62;
          hence thesis by A219;
        end;
        suppose
A220:     k = 2;
          <*b,f2,d3*>.2 = f2 by FINSEQ_1:62
            .= f.2 by A210,A215,FINSEQ_1:62;
          hence thesis by A220;
        end;
        suppose
A221:     k = 3;
          <*b,f2,d3*>.3 = d3 by FINSEQ_1:62
            .= f.3 by A204,A214,FINSEQ_1:62;
          hence thesis by A221;
        end;
      end;
      dom <*b,f2,d3*> = {1,2,3} by FINSEQ_3:1,30;
      then
A222: <*b,f2,d3*> = f by A193,A195,A217,FUNCT_1:9;
A223: AddressPart (b:=(f2,d3)) = <*b,f2,d3*> by MCART_1:def 2;
      InsCode (b:=(f2,d3)) = 9 by SCMFSA_2:50;
      hence thesis by A191,A192,A222,A223;
    end;
    suppose
A224: T = 10;
      take product" AddressParts T;
      thus AddressParts T c= product product" AddressParts T by CARD_3:94;
      let x be set;
      assume
      x in product product" AddressParts T;
      then consider f being Function such that
A225: x = f and
A226: dom f = dom product" AddressParts T and
A227: for k being set st k in dom product" AddressParts T holds f.k
      in (product" AddressParts T).k by CARD_3:def 5;
A228: dom product" AddressParts T = {1,2,3} by A224,Th40;
      then
A229: 1 in dom product" AddressParts T by ENUMSET1:def 1;
      then f.1 in (product" AddressParts T).1 by A227;
      then f.1 in pi(AddressParts T,1) by A229,CARD_3:def 13;
      then consider g being Function such that
A230: g in AddressParts T and
A231: g.1 = f.1 by CARD_3:def 6;
      consider I being Instruction of SCM+FSA such that
A232: g = AddressPart I and
A233: InsCode I = T by A230;
      consider a, b, f1 such that
A234: I = (f1,a):=b by A224,A233,SCMFSA_2:63;
A235: 3 in dom product" AddressParts T by A228,ENUMSET1:def 1;
      then f.3 in (product" AddressParts T).3 by A227;
      then f.3 in pi(AddressParts T,3) by A235,CARD_3:def 13;
      then consider z being Function such that
A236: z in AddressParts T and
A237: z.3 = f.3 by CARD_3:def 6;
      consider K being Instruction of SCM+FSA such that
A238: z = AddressPart K and
A239: InsCode K = T by A236;
      consider d3, d4, f3 such that
A240: K = (f3,d3):=d4 by A224,A239,SCMFSA_2:63;
A241: 2 in dom product" AddressParts T by A228,ENUMSET1:def 1;
      then f.2 in (product" AddressParts T).2 by A227;
      then f.2 in pi(AddressParts T,2) by A241,CARD_3:def 13;
      then consider h being Function such that
A242: h in AddressParts T and
A243: h.2 = f.2 by CARD_3:def 6;
      consider J being Instruction of SCM+FSA such that
A244: h = AddressPart J and
A245: InsCode J = T by A242;
      consider d1, d2, f2 such that
A246: J = (f2,d1):=d2 by A224,A245,SCMFSA_2:63;
A247: z = <*d4,f3,d3*> by A238,A240,MCART_1:def 2;
A248: h = <*d2,f2,d1*> by A244,A246,MCART_1:def 2;
A249: g = <*b,f1,a*> by A232,A234,MCART_1:def 2;
A250: for k being set st k in {1,2,3} holds <*b,f2,d3*>.k = f.k
      proof
        let k be set;
        assume
A251:   k in {1,2,3};
        per cases by A251,ENUMSET1:def 1;
        suppose
A252:     k = 1;
          <*b,f2,d3*>.1 = b by FINSEQ_1:62
            .= f.1 by A231,A249,FINSEQ_1:62;
          hence thesis by A252;
        end;
        suppose
A253:     k = 2;
          <*b,f2,d3*>.2 = f2 by FINSEQ_1:62
            .= f.2 by A243,A248,FINSEQ_1:62;
          hence thesis by A253;
        end;
        suppose
A254:     k = 3;
          <*b,f2,d3*>.3 = d3 by FINSEQ_1:62
            .= f.3 by A237,A247,FINSEQ_1:62;
          hence thesis by A254;
        end;
      end;
      dom <*b,f2,d3*> = {1,2,3} by FINSEQ_3:1,30;
      then
A255: <*b,f2,d3*> = f by A226,A228,A250,FUNCT_1:9;
A256: AddressPart ((f2,d3):=b) = <*b,f2,d3*> by MCART_1:def 2;
      InsCode ((f2,d3):=b) = 10 by SCMFSA_2:51;
      hence thesis by A224,A225,A255,A256;
    end;
    suppose
A257: T = 11;
      take product" AddressParts T;
      thus AddressParts T c= product product" AddressParts T by CARD_3:94;
      let x be set;
      assume
      x in product product" AddressParts T;
      then consider f being Function such that
A258: x = f and
A259: dom f = dom product" AddressParts T and
A260: for k being set st k in dom product" AddressParts T holds f.k
      in (product" AddressParts T).k by CARD_3:def 5;
A261: dom product" AddressParts T = {1,2} by A257,Th41;
      then
A262: 1 in dom product" AddressParts T by TARSKI:def 2;
      then f.1 in (product" AddressParts T).1 by A260;
      then f.1 in pi(AddressParts T,1) by A262,CARD_3:def 13;
      then consider g being Function such that
A263: g in AddressParts T and
A264: g.1 = f.1 by CARD_3:def 6;
      consider I being Instruction of SCM+FSA such that
A265: g = AddressPart I and
A266: InsCode I = T by A263;
      consider a, f1 such that
A267: I = a:=len f1 by A257,A266,SCMFSA_2:64;
A268: 2 in dom product" AddressParts T by A261,TARSKI:def 2;
      then f.2 in (product" AddressParts T).2 by A260;
      then f.2 in pi(AddressParts T,2) by A268,CARD_3:def 13;
      then consider h being Function such that
A269: h in AddressParts T and
A270: h.2 = f.2 by CARD_3:def 6;
      consider J being Instruction of SCM+FSA such that
A271: h = AddressPart J and
A272: InsCode J = T by A269;
      consider b, f2 such that
A273: J = b:=len f2 by A257,A272,SCMFSA_2:64;
A274: h = <*b,f2*> by A271,A273,MCART_1:def 2;
A275: g = <*a,f1*> by A265,A267,MCART_1:def 2;
A276: for k being set st k in {1,2} holds <*a,f2*>.k = f.k
      proof
        let k be set;
        assume
A277:   k in {1,2};
        per cases by A277,TARSKI:def 2;
        suppose
A278:     k = 1;
          <*a,f2*>.1 = a by FINSEQ_1:61
            .= f.1 by A264,A275,FINSEQ_1:61;
          hence thesis by A278;
        end;
        suppose
A279:     k = 2;
          <*a,f2*>.2 = f2 by FINSEQ_1:61
            .= f.2 by A270,A274,FINSEQ_1:61;
          hence thesis by A279;
        end;
      end;
      dom <*a,f2*> = {1,2} by FINSEQ_1:4,FINSEQ_3:29;
      then
A280: <*a,f2*> = f by A259,A261,A276,FUNCT_1:9;
A281: AddressPart (a:=len f2) = <*a,f2*> by MCART_1:def 2;
      InsCode (a:=len f2) = 11 by SCMFSA_2:52;
      hence thesis by A257,A258,A280,A281;
    end;
    suppose
A282: T = 12;
      take product" AddressParts T;
      thus AddressParts T c= product product" AddressParts T by CARD_3:94;
      let x be set;
      assume
      x in product product" AddressParts T;
      then consider f being Function such that
A283: x = f and
A284: dom f = dom product" AddressParts T and
A285: for k being set st k in dom product" AddressParts T holds f.k
      in (product" AddressParts T).k by CARD_3:def 5;
A286: dom product" AddressParts T = {1,2} by A282,Th42;
      then
A287: 1 in dom product" AddressParts T by TARSKI:def 2;
      then f.1 in (product" AddressParts T).1 by A285;
      then f.1 in pi(AddressParts T,1) by A287,CARD_3:def 13;
      then consider g being Function such that
A288: g in AddressParts T and
A289: g.1 = f.1 by CARD_3:def 6;
      consider I being Instruction of SCM+FSA such that
A290: g = AddressPart I and
A291: InsCode I = T by A288;
      consider a, f1 such that
A292: I = f1:=<0,...,0>a by A282,A291,SCMFSA_2:65;
A293: 2 in dom product" AddressParts T by A286,TARSKI:def 2;
      then f.2 in (product" AddressParts T).2 by A285;
      then f.2 in pi(AddressParts T,2) by A293,CARD_3:def 13;
      then consider h being Function such that
A294: h in AddressParts T and
A295: h.2 = f.2 by CARD_3:def 6;
      consider J being Instruction of SCM+FSA such that
A296: h = AddressPart J and
A297: InsCode J = T by A294;
      consider b, f2 such that
A298: J = f2:=<0,...,0>b by A282,A297,SCMFSA_2:65;
A299: h = <*b,f2*> by A296,A298,MCART_1:def 2;
A300: g = <*a,f1*> by A290,A292,MCART_1:def 2;
A301: for k being set st k in {1,2} holds <*a,f2*>.k = f.k
      proof
        let k be set;
        assume
A302:   k in {1,2};
        per cases by A302,TARSKI:def 2;
        suppose
A303:     k = 1;
          <*a,f2*>.1 = a by FINSEQ_1:61
            .= f.1 by A289,A300,FINSEQ_1:61;
          hence thesis by A303;
        end;
        suppose
A304:     k = 2;
          <*a,f2*>.2 = f2 by FINSEQ_1:61
            .= f.2 by A295,A299,FINSEQ_1:61;
          hence thesis by A304;
        end;
      end;
      dom <*a,f2*> = {1,2} by FINSEQ_1:4,FINSEQ_3:29;
      then
A305: <*a,f2*> = f by A284,A286,A301,FUNCT_1:9;
A306: AddressPart (f2:=<0,...,0>a) = <*a,f2 *> by MCART_1:def 2;
      InsCode (f2:=<0,...,0>a) = 12 by SCMFSA_2:53;
      hence thesis by A282,A283,A305,A306;
    end;
  end;
end;

theorem Th89:
  IncAddr(goto i1,k) = goto il.(SCM+FSA, locnum i1 + k)
proof
A1: InsCode IncAddr(goto i1,k) = InsCode goto i1 by AMISTD_2:def 14
    .= 6 by SCMFSA_2:47
    .= InsCode goto il.(SCM+FSA, locnum i1 + k) by SCMFSA_2:47;
A2: dom AddressPart IncAddr(goto i1,k) = dom AddressPart goto i1 by
AMISTD_2:def 14;
A3: for x being set st x in dom AddressPart goto i1 holds (AddressPart
  IncAddr(goto i1,k)).x = (AddressPart goto il.(SCM+FSA, locnum i1 + k)).x
  proof
    let x be set;
    assume
A4: x in dom AddressPart goto i1;
    then x in dom <*i1*> by Th23;
    then
A5: x = 1 by Lm1;
    then (product" AddressParts InsCode goto i1).x = NAT by Th53;
    then consider f being Instruction-Location of SCM+FSA such that
A6: f = (AddressPart goto i1).x and
A7: (AddressPart IncAddr(goto i1,k)).x = il.(SCM+FSA,k + locnum f) by A4,
AMISTD_2:def 14;
    f = <*i1*>.x by A6,Th23
      .= i1 by A5,FINSEQ_1:def 8;
    hence
    (AddressPart IncAddr(goto i1,k)).x = <*il.(SCM+FSA, locnum i1 + k)*>.
    x by A5,A7,FINSEQ_1:def 8
      .= (AddressPart goto il.(SCM+FSA, locnum i1 + k)).x by Th23;
  end;
  dom AddressPart goto il.(SCM+FSA, locnum i1 + k) = dom <*il.(SCM+FSA,
  locnum i1 + k)*> by Th23
    .= Seg 1 by FINSEQ_1:def 8
    .= dom <*i1*> by FINSEQ_1:def 8
    .= dom AddressPart goto i1 by Th23;
  hence thesis by A1,A2,A3,FUNCT_1:9,MCART_1:95;
end;

theorem Th90:
  IncAddr(a=0_goto i1,k) = a=0_goto il.(SCM+FSA, locnum i1 + k)
proof
A1: InsCode IncAddr(a=0_goto i1,k) = InsCode (a=0_goto i1) by AMISTD_2:def 14
    .= 7 by SCMFSA_2:48
    .= InsCode (a=0_goto il.(SCM+FSA, locnum i1 + k)) by SCMFSA_2:48;
A2: dom AddressPart IncAddr(a=0_goto i1,k) = dom AddressPart (a=0_goto i1)
  by AMISTD_2:def 14;
A3: for x being set st x in dom AddressPart (a=0_goto i1) holds (AddressPart
IncAddr(a=0_goto i1,k)).x = (AddressPart (a=0_goto il.(SCM+FSA, locnum i1 + k))
  ).x
  proof
    let x be set;
    assume
A4: x in dom AddressPart (a=0_goto i1);
    then
A5: x in dom <*i1,a*> by Th24;
    per cases by A5,Lm2;
    suppose
A6:   x = 1;
      then (product" AddressParts InsCode (a=0_goto i1)).x = NAT by Th54;
      then consider f being Instruction-Location of SCM+FSA such that
A7:   f = (AddressPart (a=0_goto i1)).x and
A8:   (AddressPart IncAddr(a=0_goto i1,k)).x = il.(SCM+FSA,k + locnum
      f) by A4,AMISTD_2:def 14;
      f = <*i1,a*>.x by A7,Th24
        .= i1 by A6,FINSEQ_1:61;
      hence
      (AddressPart IncAddr(a=0_goto i1,k)).x = <*il.(SCM+FSA, locnum i1 +
      k),a*>.x by A6,A8,FINSEQ_1:61
        .= (AddressPart (a=0_goto il.(SCM+FSA, locnum i1 + k))).x by Th24;
    end;
    suppose
A9:   x = 2;
      then (product" AddressParts InsCode (a=0_goto i1)).x <> NAT by Th5,Th55;
      hence
      (AddressPart IncAddr(a=0_goto i1,k)).x = (AddressPart (a=0_goto i1)
      ).x by A4,AMISTD_2:def 14
        .= <*i1,a*>.x by Th24
        .= a by A9,FINSEQ_1:61
        .= <*il.(SCM+FSA, locnum i1 + k),a*>.x by A9,FINSEQ_1:61
        .= (AddressPart (a=0_goto il.(SCM+FSA, locnum i1 + k))).x by Th24;
    end;
  end;
  dom AddressPart (a=0_goto il.(SCM+FSA, locnum i1 + k)) = dom <*il.(
  SCM+FSA, locnum i1 + k), a*> by Th24
    .= Seg 2 by FINSEQ_3:29
    .= dom <*i1,a*> by FINSEQ_3:29
    .= dom AddressPart (a=0_goto i1) by Th24;
  hence thesis by A1,A2,A3,FUNCT_1:9,MCART_1:95;
end;

theorem Th91:
  IncAddr(a>0_goto i1,k) = a>0_goto il.(SCM+FSA, locnum i1 + k)
proof
A1: InsCode IncAddr(a>0_goto i1,k) = InsCode (a>0_goto i1) by AMISTD_2:def 14
    .= 8 by SCMFSA_2:49
    .= InsCode (a>0_goto il.(SCM+FSA, locnum i1 + k)) by SCMFSA_2:49;
A2: dom AddressPart IncAddr(a>0_goto i1,k) = dom AddressPart (a>0_goto i1)
  by AMISTD_2:def 14;
A3: for x being set st x in dom AddressPart (a>0_goto i1) holds (AddressPart
IncAddr(a>0_goto i1,k)).x = (AddressPart (a>0_goto il.(SCM+FSA, locnum i1 + k))
  ).x
  proof
    let x be set;
    assume
A4: x in dom AddressPart (a>0_goto i1);
    then
A5: x in dom <*i1,a*> by Th25;
    per cases by A5,Lm2;
    suppose
A6:   x = 1;
      then (product" AddressParts InsCode (a>0_goto i1)).x = NAT by Th56;
      then consider f being Instruction-Location of SCM+FSA such that
A7:   f = (AddressPart (a>0_goto i1)).x and
A8:   (AddressPart IncAddr(a>0_goto i1,k)).x = il.(SCM+FSA,k + locnum
      f) by A4,AMISTD_2:def 14;
      f = <*i1,a*>.x by A7,Th25
        .= i1 by A6,FINSEQ_1:61;
      hence
      (AddressPart IncAddr(a>0_goto i1,k)).x = <*il.(SCM+FSA, locnum i1 +
      k),a*>.x by A6,A8,FINSEQ_1:61
        .= (AddressPart (a>0_goto il.(SCM+FSA, locnum i1 + k))).x by Th25;
    end;
    suppose
A9:   x = 2;
      then (product" AddressParts InsCode (a>0_goto i1)).x <> NAT by Th5,Th57;
      hence
      (AddressPart IncAddr(a>0_goto i1,k)).x = (AddressPart (a>0_goto i1)
      ).x by A4,AMISTD_2:def 14
        .= <*i1,a*>.x by Th25
        .= a by A9,FINSEQ_1:61
        .= <*il.(SCM+FSA, locnum i1 + k),a*>.x by A9,FINSEQ_1:61
        .= (AddressPart (a>0_goto il.(SCM+FSA, locnum i1 + k))).x by Th25;
    end;
  end;
  dom AddressPart (a>0_goto il.(SCM+FSA, locnum i1 + k)) = dom <*il.(
  SCM+FSA, locnum i1 + k), a*> by Th25
    .= Seg 2 by FINSEQ_3:29
    .= dom <*i1,a*> by FINSEQ_3:29
    .= dom AddressPart (a>0_goto i1) by Th25;
  hence thesis by A1,A2,A3,FUNCT_1:9,MCART_1:95;
end;

registration
  cluster SCM+FSA -> IC-good Exec-preserving;
  coherence
  proof
    thus SCM+FSA is IC-good
    proof
      let I be Instruction of SCM+FSA;
      per cases by SCMFSA_2:120;
      suppose
        I = [0,{}];
        hence thesis by AMI_3:71,SCMFSA_2:123;
      end;
      suppose
        ex a,b st I = a:=b;
        hence thesis;
      end;
      suppose
        ex a,b st I = AddTo(a,b);
        hence thesis;
      end;
      suppose
        ex a,b st I = SubFrom(a,b);
        hence thesis;
      end;
      suppose
        ex a,b st I = MultBy(a,b);
        hence thesis;
      end;
      suppose
        ex a,b st I = Divide(a,b);
        hence thesis;
      end;
      suppose
A1:     ex i1 st I = goto i1;
        let k be natural number, s1, s2 be State of SCM+FSA such that
        s2 = s1 +* (IC SCM+FSA .--> (IC s1 + k));
        consider i1 such that
A2:     I = goto i1 by A1;
        IC Exec(I,s1) = i1 by A2,SCMFSA_2:95;
        hence IC Exec(I,s1) + k = IC Exec(goto il.(SCM+FSA, locnum i1 + k),s2)
        by SCMFSA_2:95
          .= IC Exec(IncAddr(I,k), s2) by A2,Th89;
      end;
      suppose
        ex i1,a st I = a=0_goto i1;
        then consider a, i1 such that
A3:     I = a=0_goto i1;
        let k be natural number, s1, s2 be State of SCM+FSA such that
A4:     s2 = s1 +* (IC SCM+FSA .--> (IC s1 + k));
A5:     dom (IC SCM+FSA .--> (IC s1 + k)) = {IC SCM+FSA} by FUNCOP_1:19;
        a <> IC SCM+FSA by SCMFSA_2:81;
        then not a in dom (IC SCM+FSA .--> (IC s1 + k)) by A5,TARSKI:def 1;
        then
A6:     s1.a = s2.a by A4,FUNCT_4:12;
        now
          per cases;
          suppose
A7:         s1.a = 0;
            then IC Exec(I,s1) = i1 by A3,SCMFSA_2:96;
            hence
            IC Exec(I,s1) + k = IC Exec(a=0_goto il.(SCM+FSA, locnum i1 +
            k),s2) by A6,A7,SCMFSA_2:96
              .= IC Exec(IncAddr(I,k), s2) by A3,Th90;
          end;
          suppose
A8:         s1.a <> 0;
            dom (IC SCM+FSA .--> (IC s1 + k)) = {IC SCM+FSA} by FUNCOP_1:19;
            then IC SCM+FSA in dom (IC SCM+FSA .--> (IC s1 + k)) by
TARSKI:def 1;
            then
A9:         IC s2 = (IC SCM+FSA .--> (IC s1 + k)).IC SCM+FSA by A4,FUNCT_4:14
              .= il.(SCM+FSA,locnum IC s1 + k) by FUNCOP_1:87;
A10:        IC Exec(I,s1) = Next IC s1 by A3,A8,SCMFSA_2:96
              .= NextLoc IC s1 by Th88
              .= il.(SCM+FSA,locnum IC s1 + 1);
            IC Exec(I, s2) = Next IC s2 by A3,A6,A8,SCMFSA_2:96
              .= NextLoc IC s2 by Th88
              .= il.(SCM+FSA,locnum IC s1 + k + 1) by A9,AMISTD_1:def 13
              .= il.(SCM+FSA,locnum IC s1 + 1 + k);
            hence IC Exec(I,s1) + k = Exec(I,s2).IC SCM+FSA by A10,
AMISTD_1:def 13
              .= Next IC s2 by A3,A6,A8,SCMFSA_2:96
              .= IC Exec(a=0_goto il.(SCM+FSA, locnum i1 + k),s2) by A6,A8,
SCMFSA_2:96
              .= IC Exec(IncAddr(I,k), s2) by A3,Th90;
          end;
        end;
        hence thesis;
      end;
      suppose
        ex i1,a st I = a>0_goto i1;
        then consider a, i1 such that
A11:    I = a>0_goto i1;
        let k be natural number, s1, s2 be State of SCM+FSA such that
A12:    s2 = s1 +* (IC SCM+FSA .--> (IC s1 + k));
A13:    dom (IC SCM+FSA .--> (IC s1 + k)) = {IC SCM+FSA} by FUNCOP_1:19;
        a <> IC SCM+FSA by SCMFSA_2:81;
        then not a in dom (IC SCM+FSA .--> (IC s1 + k)) by A13,TARSKI:def 1;
        then
A14:    s1.a = s2.a by A12,FUNCT_4:12;
        now
          per cases;
          suppose
A15:        s1.a > 0;
            then IC Exec(I,s1) = i1 by A11,SCMFSA_2:97;
            hence
            IC Exec(I,s1) + k = IC Exec(a>0_goto il.(SCM+FSA, locnum i1 +
            k),s2) by A14,A15,SCMFSA_2:97
              .= IC Exec(IncAddr(I,k), s2) by A11,Th91;
          end;
          suppose
A16:        s1.a <= 0;
            dom (IC SCM+FSA .--> (IC s1 + k)) = {IC SCM+FSA} by FUNCOP_1:19;
            then IC SCM+FSA in dom (IC SCM+FSA .--> (IC s1 + k)) by
TARSKI:def 1;
            then
A17:        IC s2 = (IC SCM+FSA .--> (IC s1 + k)).IC SCM+FSA by A12,FUNCT_4:14
              .= il.(SCM+FSA,locnum IC s1 + k) by FUNCOP_1:87;
A18:        IC Exec(I,s1) = Next IC s1 by A11,A16,SCMFSA_2:97
              .= NextLoc IC s1 by Th88
              .= il.(SCM+FSA,locnum IC s1 + 1);
            IC Exec(I, s2) = Next IC s2 by A11,A14,A16,SCMFSA_2:97
              .= NextLoc IC s2 by Th88
              .= il.(SCM+FSA,locnum IC s1 + k + 1) by A17,AMISTD_1:def 13
              .= il.(SCM+FSA,locnum IC s1 + 1 + k);
            hence IC Exec(I,s1) + k = Exec(I,s2).IC SCM+FSA by A18,
AMISTD_1:def 13
              .= Next IC s2 by A11,A14,A16,SCMFSA_2:97
              .= IC Exec(a>0_goto il.(SCM+FSA, locnum i1 + k),s2) by A14,A16,
SCMFSA_2:97
              .= IC Exec(IncAddr(I,k), s2) by A11,Th91;
          end;
        end;
        hence thesis;
      end;
      suppose
        ex a,b,f st I = b:=(f,a);
        hence thesis;
      end;
      suppose
        ex a,b,f st I = (f,a):=b;
        hence thesis;
      end;
      suppose
        ex a,f st I = a:=len f;
        hence thesis;
      end;
      suppose
        ex a,f st I = f:=<0,...,0>a;
        hence thesis;
      end;
    end;
    let I be Instruction of SCM+FSA;
    let s1, s2 be State of SCM+FSA;
    assume
    s1,s2 equal_outside NAT;
    hence thesis by SCMFSA6A:32;
  end;
end;

