:: On the Instructions of { \bf SCM+FSA }
::  by Artur Korni{\l}owicz
::
:: Received May 8, 2001
:: Copyright (c) 2001 Association of Mizar Users

environ

 vocabularies NUMBERS, SCMFSA_2, AMI_3, AMI_1, FSM_1, ORDINAL1, INT_1,
      FUNCOP_1, SUBSET_1, SCMFSA_1, CAT_1, XBOOLE_0, GRAPHSP, FINSEQ_1,
      RELAT_1, CARD_1, AMI_2, MCART_1, AMISTD_2, CARD_3, FUNCT_1, AMISTD_1,
      CIRCUIT2, FUNCT_4, SETFAM_1, ZFMISC_1, XXREAL_0, TARSKI, FUNCT_2,
      ARYTM_3, GOBOARD5, FRECHET, ARYTM_1, COMPLEX1, PARTFUN1, FINSEQ_2,
      UNIALG_1, CARD_5, FUNCT_7, RECDEF_2, NAT_1, VALUED_1, VALUED_0, STRUCT_0,
      SCMNORM;
 notations TARSKI, XBOOLE_0, ENUMSET1, SUBSET_1, MCART_1, SETFAM_1, RELAT_1,
      ZFMISC_1,
      FUNCT_1, PARTFUN1, FUNCT_2, REALSET1, ORDINAL1, XCMPLX_0, INT_1,
      FUNCOP_1, FINSEQ_1, FINSEQ_2, FUNCT_4, COMPLEX1, CARD_1, CARD_3, FUNCT_7,
      XXREAL_0, NAT_1, RECDEF_2, VALUED_0, VALUED_1,
      STRUCT_0, COMPOS_1, AMI_1, AMI_2, AMI_3,
      SCMFSA_1, SCMFSA_2, SCMFSA_3, AMISTD_1,
      AMISTD_2;
 constructors XXREAL_0, REAL_1, NAT_D, FINSEQ_4, REALSET1, AMI_5, SCMFSA_3,
      AMISTD_2, SEQ_1, RELSET_1, RECDEF_2, VALUED_1, VALUED_0;
 registrations XBOOLE_0, SETFAM_1, RELAT_1, FUNCT_1, ORDINAL1, FUNCOP_1,
      NUMBERS, XREAL_0, NAT_1, INT_1, FINSEQ_1, AMI_1, SCMFSA_2, AMISTD_2,
      RELSET_1, CARD_3, FUNCT_2, ZFMISC_1, AMI_3, FUNCT_4, VALUED_0, VALUED_1,
      COMPOS_1;
 requirements NUMERALS, BOOLE, SUBSET, REAL, ARITHM;
 definitions TARSKI, FUNCT_1, SCMFSA_2, AMISTD_1, AMISTD_2, XBOOLE_0, FUNCOP_1,
      SCMFSA_1, COMPOS_1, AMI_1, AMI_3, CARD_3, NAT_1, MCART_1, FUNCT_7;
 theorems TARSKI, NAT_1, AMI_1, AMI_3, FUNCT_4, FUNCT_1, FUNCT_2, FUNCOP_1,
      SETFAM_1, AMISTD_1, MCART_1, FINSEQ_1, FINSEQ_3, AMISTD_2, FUNCT_7,
      CARD_3, SCMFSA_2, INT_1, ENUMSET1, BVFUNC14, ABSVALUE,
      FINSEQ_2, XBOOLE_0, XBOOLE_1, NAT_D, RELAT_1, ZFMISC_1, AMI_5, PARTFUN1,
      ORDINAL1, PBOOLE, RECDEF_2, AMI_6, VALUED_1, COMPOS_1;
 schemes FUNCT_2;

begin

reserve a, b, d1, d2, d3, d4 for Int-Location,
  A, B for Data-Location,
  f, f1, f2, f3 for FinSeq-Location,
  il, i1, i2 for Element of NAT,
  L for Element of NAT,
  I for Instruction of SCM+FSA,
  s,s1,s2 for State of SCM+FSA,
  T for InsType of SCM+FSA,
  k for natural number;

definition
  let la, lb be Int-Location, a, b be Integer;
  redefine func (la,lb) --> (a,b) -> FinPartState of SCM+FSA;
  coherence
  proof
A1: ObjectKind lb = INT by SCMFSA_2:26;
A2: ObjectKind la = INT by SCMFSA_2:26;
A3: b is Element of INT by INT_1:def 2;
    a is Element of INT by INT_1:def 2;
    hence thesis by A3,A2,A1,COMPOS_1:4;
  end;
end;

canceled 2;

theorem Th3:
  not a in NAT
proof
  a in SCM+FSA-Data-Loc by SCMFSA_2:def 4;
  hence thesis by SCMFSA_2:13,XBOOLE_0:3;
end;

theorem Th4:
  not f in NAT
proof
  f in SCM+FSA-Data*-Loc by SCMFSA_2:def 5;
  hence thesis by SCMFSA_2:14,XBOOLE_0:3;
end;

theorem
  SCM+FSA-Data-Loc <> NAT
proof
  consider a being Int-Location;
A1: a in SCM+FSA-Data-Loc by SCMFSA_2:def 4;
  assume not thesis;
  hence thesis by A1,Th3;
end;

theorem
  SCM+FSA-Data*-Loc <> NAT
proof
  consider f being FinSeq-Location;
A1: f in SCM+FSA-Data*-Loc by SCMFSA_2:def 5;
  assume not thesis;
  hence thesis by A1,Th4;
end;

theorem Th7:
  for o being Object of SCM+FSA holds o = IC SCM+FSA or o in NAT or
  o is Int-Location or o is FinSeq-Location
proof
  let o be Object of SCM+FSA;
  o in Int-Locations \/ FinSeq-Locations \/ {IC SCM+FSA} or o in NAT by
SCMFSA_2:8,XBOOLE_0:def 3;
  then
  o in Int-Locations \/ FinSeq-Locations or o in {IC SCM+FSA} or o in NAT
  by XBOOLE_0:def 3;
  then
  o in Int-Locations or o in FinSeq-Locations or o in {IC SCM+FSA} or o in
  NAT by XBOOLE_0:def 3;
  hence thesis by SCMFSA_2:11,12,TARSKI:def 1;
end;

canceled;

theorem Th9:
  a := b = [1,{},<*a,b*>]
proof
  ex A,B st a = A & b = B & a := b = A:=B by SCMFSA_2:def 11;
  hence thesis;
end;

theorem Th10:
  AddTo(a,b) = [2,{},<*a,b*>]
proof
  ex A,B st a = A & b = B & AddTo(a,b) = AddTo(A,B) by SCMFSA_2:def 12;
  hence thesis;
end;

theorem Th11:
  SubFrom(a,b) = [3,{},<* a,b *>]
proof
  ex A,B st a = A & b = B & SubFrom(a,b) = SubFrom(A,B) by SCMFSA_2:def 13;
  hence thesis;
end;

theorem Th12:
  MultBy(a,b) = [4,{},<* a,b *>]
proof
  ex A,B st a = A & b = B & MultBy(a,b) = MultBy(A,B) by SCMFSA_2:def 14;
  hence thesis;
end;

theorem Th13:
  Divide(a,b) = [5,{},<* a,b *>]
proof
  ex A,B st a = A & b = B & Divide(a,b) = Divide(A,B) by SCMFSA_2:def 15;
  hence thesis;
end;

canceled;

theorem Th15:
  a=0_goto il = [7, <* il*>,<*a *>]
proof
  ex A st A = a & A=0_goto il = a=0_goto il by SCMFSA_2:def 17;
  hence thesis;
end;

theorem Th16:
  a>0_goto il = [8, <* il*>,<*a *>]
proof
  ex A st A = a & A>0_goto il = a>0_goto il by SCMFSA_2:def 18;
  hence thesis;
end;

reserve J,K for Element of Segm 13,
  b,c,c1 for Element of SCM+FSA-Data-Loc,
  f,
  f1 for Element of SCM+FSA-Data*-Loc;

Lm4: T = 0 or T = 1 or T = 2 or T = 3 or T = 4 or T = 5 or T = 6 or T = 7 or T
= 8 or T = 9 or T = 10 or T = 11 or T = 12

proof
  consider y being set such that
B1: [T,y] in proj1 the Instructions of SCM+FSA by RELAT_1:def 4;
  consider x being set such that
A1: [[T,y],x] in the Instructions of SCM+FSA by B1,RELAT_1:def 4;
   reconsider I = [T,y,x] as Instruction of SCM+FSA by A1;
A2: [T,y,x] in SCM-Instr \/ { [J,{},<*c,f,b*>] : J in {9,10} }
 or [T,y,x] in { [K,{},<*c1,f1*>] : K in {11,12} } by A1,XBOOLE_0:def 3;

  per cases by A2,XBOOLE_0:def 3;
  suppose
    [T,y,x] in SCM-Instr;
    then reconsider I = [T,y,x] as Instruction of SCM;
    T = InsCode I by RECDEF_2:def 1;
    hence thesis by AMI_6:7;
  end;
  suppose
    [T,y,x] in { [J,{},<*c,f,b*>] : J in {9,10} };
    then ex J,c,b,f st [T,y,x] = [J,{},<*c,f,b*>] & J in {9,10};
    then T in {9,10} by MCART_1:28;
    hence thesis by TARSKI:def 2;
  end;
  suppose
    [T,y,x] in { [K,{},<*c1,f1*>] : K in {11,12} };
    then ex K,c1,f1 st [T,y,x] = [K,{},<*c1,f1*>] & K in {11,12};
    then T in {11,12} by MCART_1:28;
    hence thesis by TARSKI:def 2;
  end;
end;

theorem Th17:
  JumpPart halt SCM+FSA = {} by AMI_3:71,RECDEF_2:def 2,SCMFSA_2:123;

reserve a, b, d1, d2, d3, d4 for Int-Location,
  A, B for Data-Location,
  f, f1,
  f2, f3 for FinSeq-Location;

theorem Th18:
  JumpPart (a:=b) = {}
proof
  thus JumpPart (a:=b) = [ 1,{}, <*a,b*>]`2_3 by Th9
    .= {} by RECDEF_2:def 2;
end;

theorem Th19:
  JumpPart AddTo(a,b) = {}
proof
  thus JumpPart AddTo(a,b) = [ 2,{}, <*a,b*>]`2_3 by Th10
    .= {} by RECDEF_2:def 2;
end;

theorem Th20:
  JumpPart SubFrom(a,b) = {}
proof
  thus JumpPart SubFrom(a,b) = [ 3,{}, <*a,b*>]`2_3 by Th11
    .= {} by RECDEF_2:def 2;
end;

theorem Th21:
  JumpPart MultBy(a,b) = {}
proof
  thus JumpPart MultBy(a,b) = [ 4,{}, <*a,b*>]`2_3 by Th12
    .= {} by RECDEF_2:def 2;
end;

theorem Th22:
  JumpPart Divide(a,b) = {}
proof
  thus JumpPart Divide(a,b) = [ 5,{}, <*a,b*>]`2_3 by Th13
    .= {} by RECDEF_2:def 2;
end;

canceled;

theorem Th24:
  JumpPart (a=0_goto i1) = <*i1*>
proof
  thus JumpPart (a=0_goto i1) = [ 7,<*i1*>,<*a*>]`2_3 by Th15
    .= <*i1*> by RECDEF_2:def 2;
end;

theorem Th25:
  JumpPart (a>0_goto i1) = <*i1*>
proof
  thus JumpPart (a>0_goto i1) = [ 8,<*i1*>,<*a*>]`2_3 by Th16
    .= <*i1*> by RECDEF_2:def 2;
end;

theorem Th26:
  JumpPart (b:=(f,a)) = {} by RECDEF_2:def 2;

theorem Th27:
  JumpPart ((f,a):=b) = {} by RECDEF_2:def 2;

theorem Th28:
  JumpPart (a:=len f) = {} by RECDEF_2:def 2;

theorem Th29:
  JumpPart (f:=<0,...,0>a) = {} by RECDEF_2:def 2;

theorem Th30:
  T = 0 implies JumpParts T = {0}
proof
  assume
A1: T = 0;
  hereby
    let a be set;
    assume a in JumpParts T;
    then consider I such that
A2: a = JumpPart I and
A3: InsCode I = T;
    I = halt SCM+FSA by A1,A3,SCMFSA_2:122;
    hence a in {0} by A2,Th17,TARSKI:def 1;
  end;
  let a be set;
  assume a in {0};
  then a = 0 by TARSKI:def 1;
  hence thesis by A1,Th17,SCMFSA_2:124;
end;

theorem Th31:
  T = 1 implies JumpParts T = {{}}
proof
  assume
A1: T = 1;
  hereby
    let x be set;
    assume x in JumpParts T;
     then consider I being Instruction of SCM+FSA such that
W1:   x = JumpPart I and
W2:   InsCode I = T;
     consider a,b such that
W3:   I = a:=b by A1,W2,SCMFSA_2:54;
     x = {} by W1,Th18,W3;
    hence x in {{}} by TARSKI:def 1;
  end;
  set a = the Int-Location;
  let x be set;
  assume x in {{}};
   then x = {} by TARSKI:def 1;
   then
X:  x = JumpPart(a:= a) by Th18;
    InsCode(a:= a) = 1 by SCMFSA_2:42;
  hence thesis by X,A1;
end;

theorem Th32:
  T = 2 implies JumpParts T = {{}}
proof
  assume
A1: T = 2;
  hereby
    let x be set;
    assume x in JumpParts T;
     then consider I being Instruction of SCM+FSA such that
W1:   x = JumpPart I and
W2:   InsCode I = T;
     consider a,b such that
W3:   I = AddTo(a,b) by A1,W2,SCMFSA_2:55;
     x = {} by W1,Th19,W3;
    hence x in {{}} by TARSKI:def 1;
  end;
  set a = the Int-Location;
  let x be set;
  assume x in {{}};
   then x = {} by TARSKI:def 1;
   then
X:  x = JumpPart AddTo(a,a) by Th19;
    InsCode AddTo(a,a) = 2 by SCMFSA_2:43;
  hence thesis by X,A1;
end;

theorem Th33:
  T = 3 implies JumpParts T = {{}}
proof
  assume
A1: T = 3;
  hereby
    let x be set;
    assume x in JumpParts T;
     then consider I being Instruction of SCM+FSA such that
W1:   x = JumpPart I and
W2:  InsCode I = T;
     consider a,b such that
W3:   I = SubFrom(a,b) by A1,W2,SCMFSA_2:56;
     x = {} by W1,Th20,W3;
    hence x in {{}} by TARSKI:def 1;
  end;
  set a = the Int-Location;
  let x be set;
  assume x in {{}};
   then x = {} by TARSKI:def 1;
   then
X:  x = JumpPart SubFrom(a,a) by Th20;
    InsCode SubFrom(a,a) = 3 by SCMFSA_2:44;
  hence thesis by X,A1;
end;

theorem Th34:
  T = 4 implies JumpParts T = {{}}
proof
  assume
A1: T = 4;
  hereby
    let x be set;
    assume x in JumpParts T;
     then consider I being Instruction of SCM+FSA such that
W1:   x = JumpPart I and
W2:   InsCode I = T;
     consider a,b such that
W3:   I = MultBy(a,b) by A1,W2,SCMFSA_2:57;
     x = {} by W1,Th21,W3;
    hence x in {{}} by TARSKI:def 1;
  end;
  set a = the Int-Location;
  let x be set;
  assume x in {{}};
   then x = {} by TARSKI:def 1;
   then
X:  x = JumpPart MultBy(a,a) by Th21;
    InsCode MultBy(a,a) = 4 by SCMFSA_2:45;
  hence thesis by X,A1;
end;

theorem Th35:
  T = 5 implies JumpParts T = {{}}
proof
  assume
A1: T = 5;
  hereby
    let x be set;
    assume x in JumpParts T;
     then consider I being Instruction of SCM+FSA such that
W1:   x = JumpPart I and
W2:   InsCode I = T;
     consider a,b such that
W3:   I = Divide(a,b) by A1,W2,SCMFSA_2:58;
     x = {} by W1,Th22,W3;
    hence x in {{}} by TARSKI:def 1;
  end;
  set a = the Int-Location;
  let x be set;
  assume x in {{}};
   then x = {} by TARSKI:def 1;
   then
X:  x = JumpPart Divide(a,a) by Th22;
    InsCode Divide(a,a) = 5 by SCMFSA_2:46;
  hence thesis by X,A1;
end;

theorem Th36:
  T = 6 implies dom product" JumpParts T = {1}
proof
  consider i1;
  assume
A1: T = 6;
A2: JumpPart goto i1 = <*i1*> by RECDEF_2:def 2;
  hereby
    let x be set;
    InsCode goto i1 = 6 by SCMFSA_2:47;
    then
A3: JumpPart goto i1 in JumpParts T by A1;
    assume x in dom product" JumpParts T;
    then x in dom JumpPart goto i1 by A3,CARD_3:def 13;
    hence x in {1} by A2,FINSEQ_1:4,def 8;
  end;
  let x be set;
  assume
A4: x in {1};
  for f being Function st f in JumpParts T holds x in dom f
  proof
    let f be Function;
    assume f in JumpParts T;
    then consider I being Instruction of SCM+FSA such that
A5: f = JumpPart I and
A6: InsCode I = T;
    consider i1 such that
A7: I = goto i1 by A1,A6,SCMFSA_2:59;
     f = <*i1*> by A5,A7,RECDEF_2:def 2;
    hence thesis by A4,FINSEQ_1:4,def 8;
  end;
  hence thesis by CARD_3:def 13;
end;

theorem Th37:
  T = 7 implies dom product" JumpParts T = {1}
proof
  consider i1, a;
  assume
A1: T = 7;
A2: JumpPart (a =0_goto i1) = <*i1*> by Th24;
  hereby
    let x be set;
    InsCode (a =0_goto i1) = 7 by SCMFSA_2:48;
    then
A3: JumpPart (a =0_goto i1) in JumpParts T by A1;
    assume x in dom product" JumpParts T;
    then x in dom JumpPart (a =0_goto i1) by A3,CARD_3:def 13;
    hence x in {1} by A2,FINSEQ_1:4,55;
  end;
  let x be set;
  assume
A4: x in {1};
  for f being Function st f in JumpParts T holds x in dom f
  proof
    let f be Function;
    assume f in JumpParts T;
    then consider I being Instruction of SCM+FSA such that
A5: f = JumpPart I and
A6: InsCode I = T;
    consider i1, a such that
A7: I = a =0_goto i1 by A1,A6,SCMFSA_2:60;
    f = <*i1*> by A5,A7,Th24;
    hence thesis by A4,FINSEQ_1:4,55;
  end;
  hence thesis by CARD_3:def 13;
end;

theorem Th38:
  T = 8 implies dom product" JumpParts T = {1}
proof
  consider i1, a;
  assume
A1: T = 8;
A2: JumpPart (a >0_goto i1) = <*i1*> by Th25;
  hereby
    let x be set;
    InsCode (a >0_goto i1) = 8 by SCMFSA_2:49;
    then
A3: JumpPart (a >0_goto i1) in JumpParts T by A1;
    assume x in dom product" JumpParts T;
    then x in dom JumpPart (a >0_goto i1) by A3,CARD_3:def 13;
    hence x in {1} by A2,FINSEQ_1:4,55;
  end;
  let x be set;
  assume
A4: x in {1};
  for f being Function st f in JumpParts T holds x in dom f
  proof
    let f be Function;
    assume f in JumpParts T;
    then consider I being Instruction of SCM+FSA such that
A5: f = JumpPart I and
A6: InsCode I = T;
    consider i1, a such that
A7: I = a >0_goto i1 by A1,A6,SCMFSA_2:61;
    f = <*i1*> by A5,A7,Th25;
    hence thesis by A4,FINSEQ_1:4,55;
  end;
  hence thesis by CARD_3:def 13;
end;

theorem Th39:
  T = 9 implies JumpParts T = {{}}
proof
  assume
A1: T = 9;
  hereby
    let x be set;
    assume x in JumpParts T;
     then consider I being Instruction of SCM+FSA such that
W1:   x = JumpPart I and
W2:   InsCode I = T;
     consider a,b,f such that
W3:   I = b:=(f,a) by A1,W2,SCMFSA_2:62;
     x = {} by W1,Th26,W3;
    hence x in {{}} by TARSKI:def 1;
  end;
  set a = the Int-Location, f = the FinSeq-Location;
  let x be set;
  assume x in {{}};
   then x = {} by TARSKI:def 1;
   then
X:  x = JumpPart(a:=(f,a)) by Th26;
    InsCode(a:=(f,a)) = 9 by SCMFSA_2:50;
  hence thesis by X,A1;
end;

theorem Th40:
  T = 10 implies JumpParts T = {{}}
proof
  assume
A1: T = 10;
  hereby
    let x be set;
    assume x in JumpParts T;
     then consider I being Instruction of SCM+FSA such that
W1:   x = JumpPart I and
W2:   InsCode I = T;
     consider a,b,f such that
W3:   I = (f,a):=b by A1,W2,SCMFSA_2:63;
     x = {} by W1,Th27,W3;
    hence x in {{}} by TARSKI:def 1;
  end;
  set a = the Int-Location, f = the FinSeq-Location;
  let x be set;
  assume x in {{}};
   then x = {} by TARSKI:def 1;
   then
X:  x = JumpPart((f,a):=a) by Th27;
    InsCode((f,a):=a) = 10 by SCMFSA_2:51;
  hence thesis by X,A1;
end;

theorem Th41:
  T = 11 implies JumpParts T = {{}}
proof
  assume
A1: T = 11;
  hereby
    let x be set;
    assume x in JumpParts T;
     then consider I being Instruction of SCM+FSA such that
W1:   x = JumpPart I and
W2:  InsCode I = T;
     consider a,f such that
W3:   I = a:=len f by A1,W2,SCMFSA_2:64;
     x = {} by W1,Th28,W3;
    hence x in {{}} by TARSKI:def 1;
  end;
  set a = the Int-Location, f = the FinSeq-Location;
  let x be set;
  assume x in {{}};
   then x = {} by TARSKI:def 1;
   then
X:  x = JumpPart(a:=len f) by Th28;
    InsCode(a:=len f) = 11 by SCMFSA_2:52;
  hence thesis by X,A1;
end;

theorem Th42:
  T = 12 implies JumpParts T = {{}}
proof
  assume
A1: T = 12;
  hereby
    let x be set;
    assume x in JumpParts T;
     then consider I being Instruction of SCM+FSA such that
W1:   x = JumpPart I and
W2:   InsCode I = T;
     consider a,f such that
W3:   I = f:=<0,...,0>a by A1,W2,SCMFSA_2:65;
     x = {} by W1,Th29,W3;
    hence x in {{}} by TARSKI:def 1;
  end;
  set a = the Int-Location, f = the FinSeq-Location;
  let x be set;
  assume x in {{}};
   then x = {} by TARSKI:def 1;
   then
X:  x = JumpPart(f:=<0,...,0>a) by Th29;
    InsCode(f:=<0,...,0>a) = 12 by SCMFSA_2:53;
  hence thesis by X,A1;
end;

canceled 10;

theorem Th53:
  (product" JumpParts InsCode goto i1).1 = NAT
proof
  dom product" JumpParts InsCode goto i1 = {1} by Th36,SCMFSA_2:47;
  then
A1: 1 in dom product" JumpParts InsCode goto i1 by TARSKI:def 1;
  hereby
    let x be set;
    assume x in (product" JumpParts InsCode goto i1).1;
    then x in pi(JumpParts InsCode goto i1,1) by A1,CARD_3:93;
    then consider g being Function such that
A2: g in JumpParts InsCode goto i1 and
A3: x = g.1 by CARD_3:def 6;
    consider I being Instruction of SCM+FSA such that
A4: g = JumpPart I and
A5: InsCode I = InsCode goto i1 by A2;
    consider i2 such that
A6: I = goto i2 by A5,SCMFSA_2:47,59;
    g = <*i2*> by A4,A6,RECDEF_2:def 2;
    then x = i2 by A3,FINSEQ_1:def 8;
    hence x in NAT;
  end;
  let x be set;
  assume x in NAT;
  then reconsider x as Element of NAT;
A7: <*x*>.1 = x by FINSEQ_1:def 8;
  InsCode goto i1 = 6 by SCMFSA_2:47;
  then
A8: InsCode goto i1 = InsCode goto x by SCMFSA_2:47;
  JumpPart goto x = <*x*> by RECDEF_2:def 2;
  then <*x*> in JumpParts InsCode goto i1 by A8;
  then x in pi(JumpParts InsCode goto i1,1) by A7,CARD_3:def 6;
  hence thesis by A1,CARD_3:93;
end;

theorem Th54:
  (product" JumpParts InsCode (a =0_goto i1)).1 = NAT
proof
  dom product" JumpParts InsCode (a =0_goto i1) = {1} by Th37,SCMFSA_2:48;
  then
A1: 1 in dom product" JumpParts InsCode (a =0_goto i1) by TARSKI:def 1;
  hereby
    let x be set;
    assume x in (product" JumpParts InsCode (a =0_goto i1)).1;
    then x in pi(JumpParts InsCode (a =0_goto i1),1) by A1,CARD_3:93;
    then consider g being Function such that
A2: g in JumpParts InsCode (a =0_goto i1) and
A3: x = g.1 by CARD_3:def 6;
    consider I being Instruction of SCM+FSA such that
A4: g = JumpPart I and
A5: InsCode I = InsCode (a =0_goto i1) by A2;
    consider i2, b such that
A6: I = b =0_goto i2 by A5,SCMFSA_2:48,60;
    g = <*i2*> by A4,A6,Th24;
    then x = i2 by A3,FINSEQ_1:57;
    hence x in NAT;
  end;
  let x be set;
  assume x in NAT;
  then reconsider x as Element of NAT;
A7: <*x*>.1 = x by FINSEQ_1:57;
  InsCode (a =0_goto i1) = 7 by SCMFSA_2:48;
  then
A8: InsCode (a =0_goto i1) = InsCode (a =0_goto x) by SCMFSA_2:48;
  JumpPart (a =0_goto x) = <*x*> by Th24;
  then <*x*> in JumpParts InsCode (a =0_goto i1) by A8;
  then x in pi(JumpParts InsCode (a =0_goto i1),1) by A7,CARD_3:def 6;
  hence thesis by A1,CARD_3:93;
end;

canceled;


theorem Th56:
  (product" JumpParts InsCode (a >0_goto i1)).1 = NAT
proof
  dom product" JumpParts InsCode (a >0_goto i1) = {1} by Th38,SCMFSA_2:49;
  then
A1: 1 in dom product" JumpParts InsCode (a >0_goto i1) by TARSKI:def 1;
  hereby
    let x be set;
    assume x in (product" JumpParts InsCode (a >0_goto i1)).1;
    then x in pi(JumpParts InsCode (a >0_goto i1),1) by A1,CARD_3:93;
    then consider g being Function such that
A2: g in JumpParts InsCode (a >0_goto i1) and
A3: x = g.1 by CARD_3:def 6;
    consider I being Instruction of SCM+FSA such that
A4: g = JumpPart I and
A5: InsCode I = InsCode (a >0_goto i1) by A2;
    consider i2, b such that
A6: I = b >0_goto i2 by A5,SCMFSA_2:49,61;
    g = <*i2*> by A4,A6,Th25;
    then x = i2 by A3,FINSEQ_1:57;
    hence x in NAT;
  end;
  let x be set;
  assume x in NAT;
  then reconsider x as Element of NAT;
A7: <*x*>.1 = x by FINSEQ_1:57;
  InsCode (a >0_goto i1) = 8 by SCMFSA_2:49;
  then
A8: InsCode (a >0_goto i1) = InsCode (a >0_goto x) by SCMFSA_2:49;
  JumpPart (a >0_goto x) = <*x*> by Th25;
  then <*x*> in JumpParts InsCode (a >0_goto i1) by A8;
  then x in pi(JumpParts InsCode (a >0_goto i1),1) by A7,CARD_3:def 6;
  hence thesis by A1,CARD_3:93;
end;

canceled 11;

Lm5: for l being Element of NAT, i being Instruction of
SCM+FSA holds (for s being State of SCM+FSA st IC s = l & s.l = i holds Exec(i,
s).IC SCM+FSA = succ IC s) implies NIC(i, l) = {succ l}

proof
  consider t being State of SCM+FSA;
  let l be Element of NAT, i be Instruction of SCM+FSA;
  reconsider I = i as Element of (the Object-Kind of SCM+FSA).l
   by COMPOS_1:def 8;
  assume

A1: for s being State of SCM+FSA st IC s = l & s.l = i holds Exec(i, s).
  IC SCM+FSA = succ IC s;

  hereby
    let x be set;
    assume x in NIC(i,l);

    then
    consider s being Element of product the Object-Kind of SCM+FSA
    such that
W:     x = IC Following(ProgramPart s,s) & IC s = l & (ProgramPart s)/.l
    = i;

  (ProgramPart s)/.l = s.l by COMPOS_1:38;
    then x = succ l by A1,W;
    hence x in {succ l} by TARSKI:def 1;
  end;
  reconsider il1 = l as Element of ObjectKind IC SCM+FSA by COMPOS_1:def 6;
  let x be set;
  reconsider n = il1 as Element of NAT;
  reconsider p = (IC SCM+FSA, l)-->(il1, I) as PartState of SCM+FSA
   by COMPOS_1:37;
  reconsider u = t+*p
     as Element of product the Object-Kind of SCM+FSA by PBOOLE:155;
A2: u.n = i by AMI_1:129;
X:  (ProgramPart u)/.l = u.l by COMPOS_1:38;
  assume x in {succ l};
  then
A3: x = succ l by TARSKI:def 1;
A4: IC u = n by AMI_1:129;
  then IC Following(ProgramPart u,u) = succ l by A1,A2,X;
  hence thesis by A3,A4,A2,X;
end;

Lm6: for i being Instruction of SCM+FSA holds (for l being
Element of NAT holds NIC(i,l)={succ l}) implies JUMP i is
empty

proof
  reconsider p=0, q=1 as Element of NAT;
  let i be Instruction of SCM+FSA;
  assume
A1: for l being Element of NAT holds NIC(i,l)={succ l};

  set X = { NIC(i,f) where f is Element of NAT: not
  contradiction };

  reconsider p, q as Element of NAT;
  assume not thesis;
  then consider x being set such that
A2: x in meet X by XBOOLE_0:def 1;
  NIC(i,p) = {succ p} by A1;
  then {succ p} in X;
  then x in {succ p} by A2,SETFAM_1:def 1;
  then
A3: x = succ p by TARSKI:def 1;
  NIC(i,q) = {succ q} by A1;
  then {succ q} in X;
  then x in {succ q} by A2,SETFAM_1:def 1;
  hence contradiction by A3,TARSKI:def 1;
end;

theorem Th68:
  NIC(halt SCM+FSA, il) = {il}
proof
  now
    let x be set;
A1: now
      reconsider il1 = il as Element of ObjectKind IC SCM+FSA by COMPOS_1:def 6
;
      reconsider I = halt SCM+FSA as Element of (the Object-Kind of SCM+FSA).il
       by COMPOS_1:def 8;
      reconsider n = il1 as Element of NAT;
      consider t being State of SCM+FSA;
      assume
A2:   x = il;
  reconsider p = (IC SCM+FSA, il)-->(il1, I) as PartState of SCM+FSA
   by COMPOS_1:37;
      reconsider u = t+*p
        as Element of product the Object-Kind of SCM+FSA by PBOOLE:155;
A3:   IC u = n by AMI_1:129;
      dom ((IC SCM+FSA, il)-->(il1, I)) = {IC SCM+FSA, il} by FUNCT_4:65;
      then
A4:   IC SCM+FSA in dom ((IC SCM+FSA, il)-->(il1, I)) by TARSKI:def 2;
X:  (ProgramPart u)/.il = u.il by COMPOS_1:38;
A5:   u.n = halt SCM+FSA by AMI_1:129;
      then IC Following(ProgramPart u,u) = u.IC SCM+FSA by A3,X,AMI_1:def 8
        .= ((IC SCM+FSA, il)-->(il1, I)).IC SCM+FSA by A4,FUNCT_4:14
        .= il by COMPOS_1:3,FUNCT_4:66;
      hence x in {IC Following(ProgramPart s,s)
       where s is Element of product the Object-Kind of SCM+FSA
       : IC s = il & (ProgramPart s)/.il=halt SCM+FSA} by A2,A5,A3,X;
    end;
    now
      assume x in {IC Following(ProgramPart s,s)
       where s is Element of product the Object-Kind of SCM+FSA
       : IC s = il & (ProgramPart s)/.il=halt SCM+FSA};
      then ex s being Element of product the Object-Kind of SCM+FSA
        st x = IC Following(ProgramPart s,s) & IC s = il &
      (ProgramPart s)/.il = halt SCM+FSA;
      hence x = il by AMI_1:def 8;
    end;
    hence x in {il} iff x in {IC Following(ProgramPart s,s)
       where s is Element of product the Object-Kind of SCM+FSA
     : IC s = il & (ProgramPart s)/.il=halt SCM+FSA}
    by A1,TARSKI:def 1;
  end;
  hence thesis by TARSKI:2;
end;

registration
  cluster JUMP halt SCM+FSA -> empty;
  coherence;
end;

theorem Th69:
  NIC(a := b, il) = {succ il}
proof
  set i = a:=b;
  for s being State of SCM+FSA st IC s = il & s.il = i holds Exec(i,s).IC
  SCM+FSA = succ IC s by SCMFSA_2:89;
  hence thesis by Lm5;
end;

registration
  let a, b;
  cluster JUMP (a := b) -> empty;
  coherence
  proof
    for l being Element of NAT holds NIC(a:=b,l)={succ l}
    by Th69;
    hence thesis by Lm6;
  end;
end;

theorem Th70:
  NIC(AddTo(a,b), il) = {succ il}
proof
  set i = AddTo(a,b);
  for s being State of SCM+FSA st IC s = il & s.il = i holds Exec(i,s).IC
  SCM+FSA = succ IC s by SCMFSA_2:90;
  hence thesis by Lm5;
end;

registration
  let a, b;
  cluster JUMP AddTo(a, b) -> empty;
  coherence
  proof
    for l being Element of NAT holds NIC(AddTo(a,b),l)={
    succ l } by Th70;
    hence thesis by Lm6;
  end;
end;

theorem Th71:
  NIC(SubFrom(a,b), il) = {succ il}
proof
  set i = SubFrom(a,b);
  for s being State of SCM+FSA st IC s = il & s.il = i holds Exec(i,s).IC
  SCM+FSA = succ IC s by SCMFSA_2:91;
  hence thesis by Lm5;
end;

registration
  let a, b;
  cluster JUMP SubFrom(a, b) -> empty;
  coherence
  proof
    for l being Element of NAT holds NIC(SubFrom(a,b),l)=
    {succ l} by Th71;
    hence thesis by Lm6;
  end;
end;

theorem Th72:
  NIC(MultBy(a,b), il) = {succ il}
proof
  set i = MultBy(a,b);
  for s being State of SCM+FSA st IC s = il & s.il = i holds Exec(i,s).IC
  SCM+FSA = succ IC s by SCMFSA_2:92;
  hence thesis by Lm5;
end;

registration
  let a, b;
  cluster JUMP MultBy(a,b) -> empty;
  coherence
  proof
    for l being Element of NAT holds NIC(MultBy(a,b),l)={
    succ l } by Th72;
    hence thesis by Lm6;
  end;
end;

theorem Th73:
  NIC(Divide(a,b), il) = {succ il}
proof
  set i = Divide(a,b);
  for s being State of SCM+FSA st IC s = il & s.il = i holds Exec(i,s).IC
  SCM+FSA = succ IC s by SCMFSA_2:93;
  hence thesis by Lm5;
end;

registration
  let a, b;
  cluster JUMP Divide(a,b) -> empty;
  coherence
  proof
    for l being Element of NAT holds NIC(Divide(a,b),l)={
    succ l } by Th73;
    hence thesis by Lm6;
  end;
end;

theorem Th74:
  NIC(goto i1, il) = {i1}
proof
  now
    let x be set;
A1: now
      reconsider il1 = il as Element of ObjectKind IC SCM+FSA by COMPOS_1:def 6
;
      reconsider n = il1 as Element of NAT;
      reconsider I = goto i1 as Element of (the Object-Kind of SCM+FSA).il
       by COMPOS_1:def 8;
      consider t being State of SCM+FSA;
      assume
A2:   x = i1;
  reconsider p = (IC SCM+FSA, il)-->(il1, I) as PartState of SCM+FSA
   by COMPOS_1:37;
      reconsider u = t+*p
        as Element of product the Object-Kind of SCM+FSA by PBOOLE:155;
A3:   u.n = goto i1 by AMI_1:129;
X:  (ProgramPart u)/.il = u.il by COMPOS_1:38;
A4:   IC u = n by AMI_1:129;
      then IC Following(ProgramPart u,u) = i1 by A3,X,SCMFSA_2:95;
      hence x in {IC Following(ProgramPart s,s)
       where s is Element of product the Object-Kind of SCM+FSA
       : IC s = il & (ProgramPart s)/.il=goto i1} by A2,A4,A3,X;
    end;
    now
      assume x in {IC Following(ProgramPart s,s)
       where s is Element of product the Object-Kind of SCM+FSA
       : IC s = il & (ProgramPart s)/.il=goto i1};
      then ex s being Element of product the Object-Kind of SCM+FSA
       st x = IC Following(ProgramPart s,s) & IC s = il &
      (ProgramPart s)/.il = goto i1;
      hence x = i1 by SCMFSA_2:95;
    end;
    hence
    x in {i1} iff x in {IC Following(ProgramPart s,s)
       where s is Element of product the Object-Kind of SCM+FSA
     : IC s = il & (ProgramPart s)/.il=goto i1} by A1,TARSKI:def 1;
  end;
  hence thesis by TARSKI:2;
end;

theorem Th75:
  JUMP goto i1 = {i1}
proof
  set X = { NIC(goto i1, il) : not contradiction };
  now
    let x be set;
    hereby
      set il1 =  1;
A1:   NIC(goto i1, il1) in X;
      assume x in meet X;
      then x in NIC(goto i1, il1) by A1,SETFAM_1:def 1;
      hence x in {i1} by Th74;
    end;
    assume x in {i1};
    then
A2: x = i1 by TARSKI:def 1;
A3: now
      let Y be set;
      assume Y in X;
      then consider il being Element of NAT such that
A4:   Y = NIC(goto i1, il);
      NIC(goto i1, il) = {i1} by Th74;
      hence i1 in Y by A4,TARSKI:def 1;
    end;
    NIC(goto i1, i1) in X;
    hence x in meet X by A2,A3,SETFAM_1:def 1;
  end;
  hence thesis by TARSKI:2;
end;

registration
  let i1;
  cluster JUMP goto i1 -> non empty trivial;
  coherence
  proof
    JUMP goto i1 = {i1} by Th75;
    hence thesis;
  end;
end;

theorem Th76:
  NIC(a=0_goto i1, il) = {i1, succ il}
proof
  consider t being State of SCM+FSA;
  hereby
    let x be set;
    assume x in NIC(a=0_goto i1, il);
    then consider s being Element of product the Object-Kind of SCM+FSA
    such that
A1: x = IC Following(ProgramPart s,s) and
A2: IC s = il and
A3: (ProgramPart s)/.il = a=0_goto i1;
    per cases;
    suppose
      s.a = 0;
      then x = i1 by A1,A2,A3,SCMFSA_2:96;
      hence x in {i1, succ il} by TARSKI:def 2;
    end;
    suppose
      s.a <> 0;
      then x = succ il by A1,A2,A3,SCMFSA_2:96;
      hence x in {i1, succ il} by TARSKI:def 2;
    end;
  end;
  let x be set;
  reconsider I = a=0_goto i1 as Element of (the Object-Kind of SCM+FSA).il
   by COMPOS_1:def 8;
A4: IC SCM+FSA <> a by SCMFSA_2:81;
  reconsider il1 = il as Element of ObjectKind IC SCM+FSA by COMPOS_1:def 6;
  reconsider p = (IC SCM+FSA, il)-->(il1, I) as PartState of SCM+FSA
   by COMPOS_1:37;
  reconsider u = t+*p as State of SCM+FSA;
A5: a <> il by Th3;
    reconsider n = il as Element of NAT;
  assume
A6: x in {i1, succ il};
  per cases by A6,TARSKI:def 2;
  suppose
A7: x = i1;
    reconsider v = u+*(a .--> 0)
     as Element of product the Object-Kind of SCM+FSA by PBOOLE:155;
A8: dom (a .--> 0) = {a} by FUNCOP_1:19;
    then not IC SCM+FSA in dom (a .--> 0) by A4,TARSKI:def 1;
    then
A9: IC v = IC u by FUNCT_4:12
      .= n by AMI_1:129;
U:    not il in dom (a .--> 0) by A5,A8,TARSKI:def 1;
A10: (ProgramPart v)/.il = v.il by COMPOS_1:38
  .= u.n by U,FUNCT_4:12
      .= I by AMI_1:129;
    a in dom (a .--> 0) by A8,TARSKI:def 1;
    then v.a = (a .--> 0).a by FUNCT_4:14
      .= 0 by FUNCOP_1:87;
    then IC Following(ProgramPart v,v) = i1 by A9,A10,SCMFSA_2:96;
    hence thesis by A7,A9,A10;
  end;
  suppose
A11: x = succ il;
    reconsider v = u+*(a .--> 1)
     as Element of product the Object-Kind of SCM+FSA by PBOOLE:155;
A12: dom (a .--> 1) = {a} by FUNCOP_1:19;
    then not IC SCM+FSA in dom (a .--> 1) by A4,TARSKI:def 1;
    then
A13: IC v = IC u by FUNCT_4:12
      .= n by AMI_1:129;
U:    not il in dom (a .--> 1) by A5,A12,TARSKI:def 1;
A14: (ProgramPart v)/.il = v.il by COMPOS_1:38
.= u.n by U,FUNCT_4:12
      .= I by AMI_1:129;
    a in dom (a .--> 1) by A12,TARSKI:def 1;
    then v.a = (a .--> 1).a by FUNCT_4:14
      .= 1 by FUNCOP_1:87;
    then IC Following(ProgramPart v,v) = succ il by A13,A14,SCMFSA_2:96;
    hence thesis by A11,A13,A14;
  end;
end;

theorem Th77:
  JUMP (a=0_goto i1) = {i1}
proof
  set X = { NIC(a=0_goto i1, il) : not contradiction };
  now
    let x be set;
A1: now
      let Y be set;
      assume Y in X;
      then consider il being Element of NAT such that
A2:   Y = NIC(a=0_goto i1, il);
      NIC(a=0_goto i1, il) = {i1, succ il} by Th76;
      hence i1 in Y by A2,TARSKI:def 2;
    end;
    hereby
      set il1 =  1, il2 =  2;
      assume
A3:   x in meet X;
A4:   NIC(a=0_goto i1, il2) = {i1, succ il2} by Th76;
      NIC(a=0_goto i1, il2) in X;
      then x in NIC(a=0_goto i1, il2) by A3,SETFAM_1:def 1;
      then
A5:   x = i1 or x = succ il2 by A4,TARSKI:def 2;
A6:   NIC(a=0_goto i1, il1) = {i1, succ il1} by Th76;
      NIC(a=0_goto i1, il1) in X;
      then x in NIC(a=0_goto i1, il1) by A3,SETFAM_1:def 1;
      then x = i1 or x = succ il1 by A6,TARSKI:def 2;
      hence x in {i1} by A5,TARSKI:def 1;
    end;
    assume x in {i1};
    then
A7: x = i1 by TARSKI:def 1;
    NIC(a=0_goto i1, i1) in X;
    hence x in meet X by A7,A1,SETFAM_1:def 1;
  end;
  hence thesis by TARSKI:2;
end;

registration
  let a, i1;
  cluster JUMP (a =0_goto i1) -> non empty trivial;
  coherence
  proof
    JUMP (a =0_goto i1) = {i1} by Th77;
    hence thesis;
  end;
end;

theorem Th78:
  NIC(a>0_goto i1, il) = {i1, succ il}
proof
  consider t being State of SCM+FSA;
  hereby
    let x be set;
    assume x in NIC(a>0_goto i1, il);
    then consider s being Element of product the Object-Kind of SCM+FSA
    such that
A1: x = IC Following(ProgramPart s,s) and
A2: IC s = il and
A3: (ProgramPart s)/.il = a>0_goto i1;
    per cases;
    suppose
      s.a > 0;
      then x = i1 by A1,A2,A3,SCMFSA_2:97;
      hence x in {i1, succ il} by TARSKI:def 2;
    end;
    suppose
      s.a <= 0;
      then x = succ il by A1,A2,A3,SCMFSA_2:97;
      hence x in {i1, succ il} by TARSKI:def 2;
    end;
  end;
  let x be set;
  reconsider I = a>0_goto i1 as Element of (the Object-Kind of SCM+FSA).il
   by COMPOS_1:def 8;
A4: IC SCM+FSA <> a by SCMFSA_2:81;
  reconsider il1 = il as Element of ObjectKind IC SCM+FSA by COMPOS_1:def 6;
  reconsider n = il as Element of NAT;
  reconsider p = (IC SCM+FSA, il)-->(il1, I) as PartState of SCM+FSA
   by COMPOS_1:37;
  reconsider u = t+*p as State of SCM+FSA;
A5: a <> il by Th3;
  assume
A6: x in {i1, succ il};
  per cases by A6,TARSKI:def 2;
  suppose
A7: x = i1;
    reconsider  v = u+*(a .--> 1)
       as Element of product the Object-Kind of SCM+FSA by PBOOLE:155;
A8: dom (a .--> 1) = {a} by FUNCOP_1:19;
    then not IC SCM+FSA in dom (a .--> 1) by A4,TARSKI:def 1;
    then
A9: IC v = IC u by FUNCT_4:12
      .= n by AMI_1:129;
U:    not il in dom (a .--> 1) by A5,A8,TARSKI:def 1;
A10: (ProgramPart v)/.il = v.il by COMPOS_1:38
.= u.n by U,FUNCT_4:12
      .= I by AMI_1:129;
    a in dom (a .--> 1) by A8,TARSKI:def 1;
    then v.a = (a .--> 1).a by FUNCT_4:14
      .= 1 by FUNCOP_1:87;
    then IC Following(ProgramPart v,v) = i1 by A9,A10,SCMFSA_2:97;
    hence thesis by A7,A9,A10;
  end;
  suppose
A11: x = succ il;
    reconsider v = u+*(a .--> 0)
      as Element of product the Object-Kind of SCM+FSA by PBOOLE:155;
A12: dom (a .--> 0) = {a} by FUNCOP_1:19;
    then not IC SCM+FSA in dom (a .--> 0) by A4,TARSKI:def 1;
    then
A13: IC v = IC u by FUNCT_4:12
      .= n by AMI_1:129;
U:    not il in dom (a .--> 0) by A5,A12,TARSKI:def 1;
A14: (ProgramPart v)/.il = v.il by COMPOS_1:38
.= u.n by U,FUNCT_4:12
      .= I by AMI_1:129;
    a in dom (a .--> 0) by A12,TARSKI:def 1;
    then v.a = (a .--> 0).a by FUNCT_4:14
      .= 0 by FUNCOP_1:87;
    then IC Following(ProgramPart v,v) = succ il by A13,A14,SCMFSA_2:97;
    hence thesis by A11,A13,A14;
  end;
end;

theorem Th79:
  JUMP (a>0_goto i1) = {i1}
proof
  set X = { NIC(a>0_goto i1, il) : not contradiction };
  now
    let x be set;
A1: now
      let Y be set;
      assume Y in X;
      then consider il being Element of NAT such that
A2:   Y = NIC(a>0_goto i1, il);
      NIC(a>0_goto i1, il) = {i1, succ il} by Th78;
      hence i1 in Y by A2,TARSKI:def 2;
    end;
    hereby
      set il1 =  1, il2 =  2;
      assume
A3:   x in meet X;
A4:   NIC(a>0_goto i1, il2) = {i1, succ il2} by Th78;
      NIC(a>0_goto i1, il2) in X;
      then x in NIC(a>0_goto i1, il2) by A3,SETFAM_1:def 1;
      then
A5:   x = i1 or x = succ il2 by A4,TARSKI:def 2;
A6:   NIC(a>0_goto i1, il1) = {i1, succ il1} by Th78;
      NIC(a>0_goto i1, il1) in X;
      then x in NIC(a>0_goto i1, il1) by A3,SETFAM_1:def 1;
      then x = i1 or x = succ il1 by A6,TARSKI:def 2;
      hence x in {i1} by A5,TARSKI:def 1;
    end;
    assume x in {i1};
    then
A7: x = i1 by TARSKI:def 1;
    NIC(a>0_goto i1, i1) in X;
    hence x in meet X by A7,A1,SETFAM_1:def 1;
  end;
  hence thesis by TARSKI:2;
end;

registration
  let a, i1;
  cluster JUMP (a >0_goto i1) -> non empty trivial;
  coherence
  proof
    JUMP (a >0_goto i1) = {i1} by Th79;
    hence thesis;
  end;
end;

theorem Th80:
  NIC(a:=(f,b), il) = {succ il}
proof
  set i = a:=(f,b);
  for s being State of SCM+FSA st IC s = il & s.il = i holds Exec(i,s).IC
  SCM+FSA = succ IC s by SCMFSA_2:98;
  hence thesis by Lm5;
end;

registration
  let a, b, f;
  cluster JUMP (a:=(f,b)) -> empty;
  coherence
  proof
    for l being Element of NAT holds NIC(a:=(f,b),l)={
    succ l} by Th80;
    hence thesis by Lm6;
  end;
end;

theorem Th81:
  NIC((f,b):=a, il) = {succ il}
proof
  set i = (f,b):=a;
  for s being State of SCM+FSA st IC s = il & s.il = i holds Exec(i,s).IC
  SCM+FSA = succ IC s by SCMFSA_2:99;
  hence thesis by Lm5;
end;

registration
  let a, b, f;
  cluster JUMP ((f,b):=a) -> empty;
  coherence
  proof
    for l being Element of NAT holds NIC((f,b):=a,l)={
    succ l} by Th81;
    hence thesis by Lm6;
  end;
end;

theorem Th82:
  NIC(a:=len f, il) = {succ il}
proof
  set i = a:=len f;
  for s being State of SCM+FSA st IC s = il & s.il = i holds Exec(i,s).IC
  SCM+FSA = succ IC s by SCMFSA_2:100;
  hence thesis by Lm5;
end;

registration
  let a, f;
  cluster JUMP (a:=len f) -> empty;
  coherence
  proof
    for l being Element of NAT holds NIC(a:=len f,l)={
    succ l} by Th82;
    hence thesis by Lm6;
  end;
end;

theorem Th83:
  NIC(f:=<0,...,0>a, il) = {succ il}
proof
  set i = f:=<0,...,0>a;
  for s being State of SCM+FSA st IC s = il & s.il = i holds Exec(i,s).IC
  SCM+FSA = succ IC s by SCMFSA_2:101;
  hence thesis by Lm5;
end;

registration
  let a, f;
  cluster JUMP (f:=<0,...,0>a) -> empty;
  coherence
  proof
    for l being Element of NAT holds NIC(f:=<0,...,0>a,l)
    ={succ l} by Th83;
    hence thesis by Lm6;
  end;
end;

theorem Th84:
  SUCC(il,SCM+FSA) = {il, succ il}
proof
  set X = { NIC(I, il) \ JUMP I where I is Element of the Instructions of
  SCM+FSA: not contradiction };
  set N = {il, succ il};
  now
    let x be set;
    hereby
      assume x in union X;
      then consider Y being set such that
A1:   x in Y and
A2:   Y in X by TARSKI:def 4;
      consider i being Element of the Instructions of SCM+FSA such that
A3:   Y = NIC(i, il) \ JUMP i by A2;
      per cases by SCMFSA_2:120;
      suppose
        i = [0,{},{}];
        then x in {il} \ JUMP halt SCM+FSA by A1,A3,Th68,AMI_3:71,SCMFSA_2:123;
        then x = il by TARSKI:def 1;
        hence x in N by TARSKI:def 2;
      end;
      suppose
        ex a,b st i = a:=b;
        then consider a, b such that
A4:     i = a:=b;
        x in {succ il} \ JUMP (a:=b) by A1,A3,A4,Th69;
        then x = succ il by TARSKI:def 1;
        hence x in N by TARSKI:def 2;
      end;
      suppose
        ex a,b st i = AddTo(a,b);
        then consider a, b such that
A5:     i = AddTo(a,b);
        x in {succ il} \ JUMP AddTo(a,b) by A1,A3,A5,Th70;
        then x = succ il by TARSKI:def 1;
        hence x in N by TARSKI:def 2;
      end;
      suppose
        ex a,b st i = SubFrom(a,b);
        then consider a, b such that
A6:     i = SubFrom(a,b);
        x in {succ il} \ JUMP SubFrom(a,b) by A1,A3,A6,Th71;
        then x = succ il by TARSKI:def 1;
        hence x in N by TARSKI:def 2;
      end;
      suppose
        ex a,b st i = MultBy(a,b);
        then consider a, b such that
A7:     i = MultBy(a,b);
        x in {succ il} \ JUMP MultBy(a,b) by A1,A3,A7,Th72;
        then x = succ il by TARSKI:def 1;
        hence x in N by TARSKI:def 2;
      end;
      suppose
        ex a,b st i = Divide(a,b);
        then consider a, b such that
A8:     i = Divide(a,b);
        x in {succ il} \ JUMP Divide(a,b) by A1,A3,A8,Th73;
        then x = succ il by TARSKI:def 1;
        hence x in N by TARSKI:def 2;
      end;
      suppose
        ex i1 st i = goto i1;
        then consider i1 such that
A9:     i = goto i1;
        x in {i1} \ JUMP i by A1,A3,A9,Th74;
        then x in {i1} \ {i1} by A9,Th75;
        hence x in N by XBOOLE_1:37;
      end;
      suppose
        ex i1,a st i = a=0_goto i1;
        then consider i1, a such that
A10:    i = a=0_goto i1;
A11:    NIC(i, il) = {i1, succ il} by A10,Th76;
        x in NIC(i, il) by A1,A3,XBOOLE_0:def 5;
        then
A12:    x = i1 or x = succ il by A11,TARSKI:def 2;
        x in NIC(i, il) \ {i1} by A1,A3,A10,Th77;
        then not x in {i1} by XBOOLE_0:def 5;
        hence x in N by A12,TARSKI:def 1,def 2;
      end;
      suppose
        ex i1,a st i = a>0_goto i1;
        then consider i1, a such that
A13:    i = a>0_goto i1;
A14:    NIC(i, il) = {i1, succ il} by A13,Th78;
        x in NIC(i, il) by A1,A3,XBOOLE_0:def 5;
        then
A15:    x = i1 or x = succ il by A14,TARSKI:def 2;
        x in NIC(i, il) \ {i1} by A1,A3,A13,Th79;
        then not x in {i1} by XBOOLE_0:def 5;
        hence x in N by A15,TARSKI:def 1,def 2;
      end;
      suppose
        ex a,b,f st i = b:=(f,a);
        then consider a, b, f such that
A16:    i = b:=(f,a);
        x in {succ il} \ JUMP (b:=(f,a)) by A1,A3,A16,Th80;
        then x = succ il by TARSKI:def 1;
        hence x in N by TARSKI:def 2;
      end;
      suppose
        ex a,b,f st i = (f,a):=b;
        then consider a, b, f such that
A17:    i = (f,a):=b;
        x in {succ il} \ JUMP ((f,a):=b) by A1,A3,A17,Th81;
        then x = succ il by TARSKI:def 1;
        hence x in N by TARSKI:def 2;
      end;
      suppose
        ex a,f st i = a:=len f;
        then consider a, f such that
A18:    i = a:=len f;
        x in {succ il} \ JUMP (a:=len f) by A1,A3,A18,Th82;
        then x = succ il by TARSKI:def 1;
        hence x in N by TARSKI:def 2;
      end;
      suppose
        ex a,f st i = f:=<0,...,0>a;
        then consider a, f such that
A19:    i = f:=<0,...,0>a;
        x in {succ il} \ JUMP (f:=<0,...,0>a) by A1,A3,A19,Th83;
        then x = succ il by TARSKI:def 1;
        hence x in N by TARSKI:def 2;
      end;
    end;
    assume
A20: x in {il, succ il};
    per cases by A20,TARSKI:def 2;
    suppose
A21:  x = il;
      set i = halt SCM+FSA;
      NIC(i, il) \ JUMP i = {il} by Th68;
      then
A22:  {il} in X;
      x in {il} by A21,TARSKI:def 1;
      hence x in union X by A22,TARSKI:def 4;
    end;
    suppose
A23:  x = succ il;
      consider a, b being Int-Location;
      set i = AddTo(a,b);
      NIC(i, il) \ JUMP i = {succ il} by Th70;
      then
A24:  {succ il} in X;
      x in {succ il} by A23,TARSKI:def 1;
      hence x in union X by A24,TARSKI:def 4;
    end;
  end;
  hence thesis by TARSKI:2;
end;

theorem Th85:
  for k being Element of NAT holds k+1 in SUCC(k,SCM+FSA) &
   for j being Element of NAT st j in SUCC(k,SCM+FSA) holds k <= j
proof
  let k be Element of NAT;
A11: SUCC(k,SCM+FSA) = {k, succ k} by Th84;
  hence k+1 in SUCC(k,SCM+FSA) by TARSKI:def 2;
  let j be Element of NAT;
  assume
A13: j in SUCC(k,SCM+FSA);
  per cases by A11,A13,TARSKI:def 2;
  suppose
    j = k;
    hence thesis;
  end;
  suppose
    j = succ k;
    hence thesis by NAT_1:11;
  end;
end;

registration
  cluster SCM+FSA -> standard;
  coherence by Th85,AMISTD_1:19;
end;

registration
  cluster InsCode halt SCM+FSA -> jump-only InsType of SCM+FSA;
  coherence
  proof
    now
      let s be State of SCM+FSA, o be Object of SCM+FSA, I be Instruction of
      SCM+FSA;
      assume that
A1:   InsCode I = InsCode halt SCM+FSA and
      o <> IC SCM+FSA;
      I = halt SCM+FSA by A1,SCMFSA_2:122,124;
      hence Exec(I, s).o = s.o by AMI_1:def 8;
    end;
    hence thesis by AMISTD_1:def 3;
  end;
end;

registration
  cluster halt SCM+FSA -> jump-only;
  coherence
  proof
    thus InsCode halt SCM+FSA is jump-only;
  end;
end;

registration
  let i1;
  cluster InsCode goto i1 -> jump-only InsType of SCM+FSA;
  coherence
  proof
    set S = SCM+FSA;
    now
      let s be State of S, o be Object of S, I be Instruction of S;
      assume that
A1:   InsCode I = InsCode goto i1 and
A2:   o <> IC S;
A3:   ex i2 st I = goto i2 by A1,SCMFSA_2:47,59;
      per cases by A2,Th7;
      suppose
        o in NAT;
        then reconsider l=o as Element of NAT;
        l=o;
        hence Exec(I, s).o = s.o by AMI_1:def 13;
      end;
      suppose
        o is Int-Location;
        hence Exec(I, s).o = s.o by A3,SCMFSA_2:95;
      end;
      suppose
        o is FinSeq-Location;
        hence Exec(I, s).o = s.o by A3,SCMFSA_2:95;
      end;
    end;
    hence thesis by AMISTD_1:def 3;
  end;
end;

registration
  let i1;
  cluster goto i1 -> jump-only non sequential non ins-loc-free;
  coherence
  proof
    thus InsCode goto i1 is jump-only;
    JUMP goto i1 <> {};
    hence goto i1 is non sequential by AMISTD_1:43;
    dom JumpPart goto i1 = dom <*i1*> by RECDEF_2:def 2
      .= {1} by FINSEQ_1:4,def 8;
   hence JumpPart goto i1 is not empty;
  end;
end;

registration
  let a, i1;
  cluster InsCode (a =0_goto i1) -> jump-only InsType of SCM+FSA;
  coherence
  proof
    set S = SCM+FSA;
    now
      let s be State of S, o be Object of S, I be Instruction of S;
      assume that
A1:   InsCode I = InsCode (a =0_goto i1) and
A2:   o <> IC S;
A3:   ex i2, b st I = b =0_goto i2 by A1,SCMFSA_2:48,60;
      per cases by A2,Th7;
      suppose
        o in NAT;
        then reconsider l=o as Element of NAT;
        l=o;
        hence Exec(I, s).o = s.o by AMI_1:def 13;
      end;
      suppose
        o is Int-Location;
        hence Exec(I, s).o = s.o by A3,SCMFSA_2:96;
      end;
      suppose
        o is FinSeq-Location;
        hence Exec(I, s).o = s.o by A3,SCMFSA_2:96;
      end;
    end;
    hence thesis by AMISTD_1:def 3;
  end;
  cluster InsCode (a >0_goto i1) -> jump-only InsType of SCM+FSA;
  coherence
  proof
    set S = SCM+FSA;
    now
      let s be State of S, o be Object of S, I be Instruction of S;
      assume that
A4:   InsCode I = InsCode (a >0_goto i1) and
A5:   o <> IC S;
A6:   ex i2, b st I = b >0_goto i2 by A4,SCMFSA_2:49,61;
      per cases by A5,Th7;
      suppose
        o in NAT;
        then reconsider l=o as Element of NAT;
        l=o;
        hence Exec(I, s).o = s.o by AMI_1:def 13;
      end;
      suppose
        o is Int-Location;
        hence Exec(I, s).o = s.o by A6,SCMFSA_2:97;
      end;
      suppose
        o is FinSeq-Location;
        hence Exec(I, s).o = s.o by A6,SCMFSA_2:97;
      end;
    end;
    hence thesis by AMISTD_1:def 3;
  end;
end;

registration
  let a, i1;
  cluster a =0_goto i1 -> jump-only non sequential non ins-loc-free;
  coherence
  proof
    thus InsCode (a =0_goto i1) is jump-only;
    JUMP (a =0_goto i1) <> {};
    hence a =0_goto i1 is non sequential by AMISTD_1:43;
    dom JumpPart (a =0_goto i1) = dom <*i1*> by Th24
      .= {1} by FINSEQ_1:4,55;
   hence JumpPart(a =0_goto i1) is not empty;
  end;
  cluster a >0_goto i1 -> jump-only non sequential non ins-loc-free;
  coherence
  proof
    thus InsCode (a >0_goto i1) is jump-only;
    JUMP (a >0_goto i1) <> {};
    hence a >0_goto i1 is non sequential by AMISTD_1:43;
    dom JumpPart (a >0_goto i1) = dom <*i1*> by Th25
      .= {1} by FINSEQ_1:4,55;
   hence JumpPart(a >0_goto i1) is not empty;
  end;
end;

Lm7: intloc 0 <> intloc 1 by AMI_3:52;

registration
  let a, b;
  cluster InsCode (a:=b) -> non jump-only InsType of SCM+FSA;
  coherence
  proof
    consider w being State of SCM+FSA;
    set t = w+*((intloc 0, intloc 1)-->(0,1));
A1: InsCode (a:=b) = 1 by SCMFSA_2:42
      .= InsCode (intloc 0:=intloc 1) by SCMFSA_2:42;
A2: intloc 0 <> IC SCM+FSA by SCMFSA_2:81;
A3: dom ((intloc 0, intloc 1)-->(0,1)) = {intloc 0, intloc 1} by FUNCT_4:65;
    then
A4: intloc 1 in dom ((intloc 0, intloc 1)-->(0,1)) by TARSKI:def 2;
    intloc 0 in dom ((intloc 0, intloc 1)-->(0,1)) by A3,TARSKI:def 2;
    then
A5: t.intloc 0 = (intloc 0, intloc 1)-->(0,1).intloc 0 by FUNCT_4:14
      .= 0 by AMI_3:52,FUNCT_4:66;
    Exec((intloc 0:=intloc 1), t).intloc 0 = t.intloc 1 by SCMFSA_2:89
      .= (intloc 0, intloc 1)-->(0,1).intloc 1 by A4,FUNCT_4:14
      .= 1 by FUNCT_4:66;
    hence thesis by A1,A2,A5,AMISTD_1:def 3;
  end;
  cluster InsCode AddTo(a,b) -> non jump-only InsType of SCM+FSA;
  coherence
  proof
    consider w being State of SCM+FSA;
    set t = w+*((intloc 0, intloc 1)-->(0,1));
A6: InsCode AddTo(a,b) = 2 by SCMFSA_2:43
      .= InsCode AddTo(intloc 0, intloc 1) by SCMFSA_2:43;
A7: dom ((intloc 0, intloc 1)-->(0,1)) = {intloc 0, intloc 1} by FUNCT_4:65;
    then intloc 0 in dom ((intloc 0, intloc 1)-->(0,1)) by TARSKI:def 2;
    then
A8: t.intloc 0 = (intloc 0, intloc 1)-->(0,1).intloc 0 by FUNCT_4:14
      .= 0 by AMI_3:52,FUNCT_4:66;
A9: intloc 0 <> IC SCM+FSA by SCMFSA_2:81;
    intloc 1 in dom ((intloc 0, intloc 1)-->(0,1)) by A7,TARSKI:def 2;
    then t.intloc 1 = (intloc 0, intloc 1)-->(0,1).intloc 1 by FUNCT_4:14
      .= 1 by FUNCT_4:66;
    then Exec(AddTo(intloc 0, intloc 1), t).intloc 0
     = (0 qua Nat)+1 by A8,SCMFSA_2:90;
    hence thesis by A6,A9,A8,AMISTD_1:def 3;
  end;
  cluster InsCode SubFrom(a,b) -> non jump-only InsType of SCM+FSA;
  coherence
  proof
    consider w being State of SCM+FSA;
    set t = w+*((intloc 0, intloc 1)-->(0,1));
A10: InsCode SubFrom(a,b) = 3 by SCMFSA_2:44
      .= InsCode SubFrom(intloc 0, intloc 1) by SCMFSA_2:44;
A11: dom ((intloc 0, intloc 1)-->(0,1)) = {intloc 0, intloc 1} by FUNCT_4:65;
    then intloc 0 in dom ((intloc 0, intloc 1)-->(0,1)) by TARSKI:def 2;
    then
A12: t.intloc 0 = (intloc 0, intloc 1)-->(0,1).intloc 0 by FUNCT_4:14
      .= 0 by AMI_3:52,FUNCT_4:66;
A13: intloc 0 <> IC SCM+FSA by SCMFSA_2:81;
    intloc 1 in dom ((intloc 0, intloc 1)-->(0,1)) by A11,TARSKI:def 2;
    then
A14: t.intloc 1 = (intloc 0, intloc 1)-->(0,1).intloc 1 by FUNCT_4:14
      .= 1 by FUNCT_4:66;
    Exec(SubFrom(intloc 0, intloc 1), t).intloc 0 = t.intloc 0 - t.intloc
    1 by SCMFSA_2:91
      .= -1 by A12,A14;
    hence thesis by A10,A13,A12,AMISTD_1:def 3;
  end;
  cluster InsCode MultBy(a,b) -> non jump-only InsType of SCM+FSA;
  coherence
  proof
    consider w being State of SCM+FSA;
    set t = w+*((intloc 0, intloc 1)-->(1,0));
A15: InsCode MultBy(a,b) = 4 by SCMFSA_2:45
      .= InsCode MultBy(intloc 0, intloc 1) by SCMFSA_2:45;
A16: dom ((intloc 0, intloc 1)-->(1,0)) = {intloc 0, intloc 1} by FUNCT_4:65;
    then intloc 0 in dom ((intloc 0, intloc 1)-->(1,0)) by TARSKI:def 2;
    then
A17: t.intloc 0 = (intloc 0, intloc 1)-->(1,0).intloc 0 by FUNCT_4:14
      .= 1 by AMI_3:52,FUNCT_4:66;
A18: intloc 0 <> IC SCM+FSA by SCMFSA_2:81;
    intloc 1 in dom ((intloc 0, intloc 1)-->(1,0)) by A16,TARSKI:def 2;
    then
A19: t.intloc 1 = (intloc 0, intloc 1)-->(1,0).intloc 1 by FUNCT_4:14
      .= 0 by FUNCT_4:66;
    Exec(MultBy(intloc 0, intloc 1), t).intloc 0 = t.intloc 0 * t.intloc
    1 by SCMFSA_2:92
      .= 0 by A19;
    hence thesis by A15,A18,A17,AMISTD_1:def 3;
  end;
  cluster InsCode Divide(a,b) -> non jump-only InsType of SCM+FSA;
  coherence
  proof
    consider w being State of SCM+FSA;
    set t = w+*((intloc 0, intloc 1)-->(7,3));
A20: InsCode Divide(a,b) = 5 by SCMFSA_2:46
      .= InsCode Divide(intloc 0, intloc 1) by SCMFSA_2:46;
A21: dom ((intloc 0, intloc 1)-->(7,3)) = {intloc 0, intloc 1} by FUNCT_4:65;
    then intloc 0 in dom ((intloc 0, intloc 1)-->(7,3)) by TARSKI:def 2;
    then
A22: t.intloc 0 = (intloc 0, intloc 1)-->(7,3).intloc 0 by FUNCT_4:14
      .= 7 by AMI_3:52,FUNCT_4:66;
A23: 7 = 2 * 3 + 1;
A24: intloc 0 <> IC SCM+FSA by SCMFSA_2:81;
    intloc 1 in dom ((intloc 0, intloc 1)-->(7,3)) by A21,TARSKI:def 2;
    then t.intloc 1 = (intloc 0, intloc 1)-->(7,3).intloc 1 by FUNCT_4:14
      .= 3 by FUNCT_4:66;
    then Exec(Divide(intloc 0, intloc 1), t).intloc 0 = 7 div (3 qua Element
    of NAT) by A22,Lm7,SCMFSA_2:93
      .= 2 by A23,NAT_D:def 1;
    hence thesis by A20,A24,A22,AMISTD_1:def 3;
  end;
end;

registration
  let a, b;
  cluster a:=b -> non jump-only sequential;
  coherence
  proof
    thus InsCode (a:=b) is not jump-only;
    let s be State of SCM+FSA;
    thus thesis by SCMFSA_2:89;
  end;
  cluster AddTo(a,b) -> non jump-only sequential;
  coherence
  proof
    thus InsCode AddTo(a,b) is not jump-only;
    let s be State of SCM+FSA;
    thus thesis by SCMFSA_2:90;
  end;
  cluster SubFrom(a,b) -> non jump-only sequential;
  coherence
  proof
    thus InsCode SubFrom(a,b) is not jump-only;
    let s be State of SCM+FSA;
    thus thesis by SCMFSA_2:91;
  end;
  cluster MultBy(a,b) -> non jump-only sequential;
  coherence
  proof
    thus InsCode MultBy(a,b) is not jump-only;
    let s be State of SCM+FSA;
    thus thesis by SCMFSA_2:92;
  end;
  cluster Divide(a,b) -> non jump-only sequential;
  coherence
  proof
    thus InsCode Divide(a,b) is not jump-only;
    let s be State of SCM+FSA;
    thus thesis by SCMFSA_2:93;
  end;
end;

Lm8: fsloc 0 <> intloc 0 by SCMFSA_2:126;

Lm9: fsloc 0 <> intloc 1 by SCMFSA_2:126;

registration
  let a, b, f;
  cluster InsCode (b:=(f,a)) -> non jump-only InsType of SCM+FSA;
  coherence
  proof
    ObjectKind intloc 1 = INT by SCMFSA_2:26;
    then reconsider E = 1 as Element of ObjectKind intloc 1 by INT_1:def 1;
    ObjectKind intloc 0 = INT by SCMFSA_2:26;
    then reconsider D = 1 as Element of ObjectKind intloc 0 by INT_1:def 1;
    reconsider DWA = 2 as Element of INT by INT_1:def 1;
    consider w being State of SCM+FSA;
A1: intloc 0 <> IC SCM+FSA by SCMFSA_2:81;
    <*DWA*> in INT* by FINSEQ_1:def 11;
    then reconsider F = <*2*> as Element of ObjectKind fsloc 0 by SCMFSA_2:27;
    set t = w+*(fsloc 0 .--> F)+*(intloc 0 .--> D)+*(intloc 1 .--> E);
A2: t.intloc 0 = D by AMI_3:52,BVFUNC14:15;
A3: t.fsloc 0 = F by Lm8,Lm9,FUNCT_7:116;
    then dom (t.fsloc 0) = {1} by FINSEQ_1:4,def 8;
    then
A4: 1 in dom (t.fsloc 0) by TARSKI:def 1;
    consider k being Element of NAT such that
A5: k = abs( t.intloc 1 ) and
A6: Exec((intloc 0):=(fsloc 0, intloc 1), t).intloc 0 = (t.fsloc 0)
    /. k by SCMFSA_2:98;
    t.intloc 1 = E by FUNCT_7:96;
    then k = 1 by A5,ABSVALUE:def 1;
    then
A7: Exec(intloc 0:=(fsloc 0, intloc 1), t).intloc 0 = (t.fsloc 0).1 by A6,A4,
PARTFUN1:def 8
      .= 2 by A3,FINSEQ_1:def 8;
    InsCode (b:=(f,a)) = 9 by SCMFSA_2:50
      .= InsCode ((intloc 0):=(fsloc 0, intloc 1)) by SCMFSA_2:50;
    hence thesis by A1,A2,A7,AMISTD_1:def 3;
  end;
  cluster InsCode ((f,a):=b) -> non jump-only InsType of SCM+FSA;
  coherence
  proof
    ObjectKind intloc 0 = INT by SCMFSA_2:26;
    then reconsider D = 1 as Element of ObjectKind intloc 0 by INT_1:def 1;
    reconsider DWA = 2 as Element of INT by INT_1:def 1;
    consider w being State of SCM+FSA;
A8: InsCode ((f,a):=b) = 10 by SCMFSA_2:51
      .= InsCode ((fsloc 0, intloc 1):=(intloc 0)) by SCMFSA_2:51;
    ObjectKind intloc 1 = INT by SCMFSA_2:26;
    then reconsider E = 1 as Element of ObjectKind intloc 1 by INT_1:def 1;
A9: fsloc 0 <> IC SCM+FSA by SCMFSA_2:82;
    <*DWA*> in INT* by FINSEQ_1:def 11;
    then reconsider F = <*2*> as Element of ObjectKind fsloc 0 by SCMFSA_2:27;
    set t = w+*(fsloc 0 .--> F)+*(intloc 0 .--> D)+*(intloc 1 .--> E);
    consider k being Element of NAT such that
A10: k = abs( t.intloc 1 ) and
A11: Exec((fsloc 0, intloc 1):=(intloc 0), t).fsloc 0 = (t.fsloc 0) +*
    (k,t.intloc 0) by SCMFSA_2:99;
    t.intloc 1 = E by FUNCT_7:96;
    then
A12: k = 1 by A10,ABSVALUE:def 1;
A13: F <> <*D*> by FINSEQ_1:97;
A14: t.fsloc 0 = F by Lm8,Lm9,FUNCT_7:116;
    t.intloc 0 = D by AMI_3:52,BVFUNC14:15;
    then Exec((fsloc 0, intloc 1):=intloc 0, t).fsloc 0 = <*D*> by A14,A11,A12,
FUNCT_7:97;
    hence thesis by A8,A9,A14,A13,AMISTD_1:def 3;
  end;
end;

registration
  let a, b, f;
  cluster b:=(f,a) -> non jump-only sequential;
  coherence
  proof
    thus InsCode (b:=(f,a)) is not jump-only;
    let s be State of SCM+FSA;
    thus thesis by SCMFSA_2:98;
  end;
  cluster (f,a):=b -> non jump-only sequential;
  coherence
  proof
    thus InsCode ((f,a):=b) is not jump-only;
    let s be State of SCM+FSA;
    thus thesis by SCMFSA_2:99;
  end;
end;

registration
  let a, f;
  cluster InsCode (a:=len f) -> non jump-only InsType of SCM+FSA;
  coherence
  proof
    ObjectKind intloc 0 = INT by SCMFSA_2:26;
    then reconsider D = 3 as Element of ObjectKind intloc 0 by INT_1:def 1;
    reconsider DWA = 2 as Element of INT by INT_1:def 1;
    consider w being State of SCM+FSA;
A1: InsCode (a:=len f) = 11 by SCMFSA_2:52
      .= InsCode (intloc 0:=len fsloc 0) by SCMFSA_2:52;
    <*DWA*> in INT* by FINSEQ_1:def 11;
    then reconsider F = <*2*> as Element of ObjectKind fsloc 0 by SCMFSA_2:27;
    set t = w+*(fsloc 0 .--> F)+*(intloc 0 .--> D);
A2: t.fsloc 0 = F by BVFUNC14:15,SCMFSA_2:126;
A3: t.intloc 0 = D by FUNCT_7:96;
A4: intloc 0 <> IC SCM+FSA by SCMFSA_2:81;
    Exec(intloc 0 :=len fsloc 0, t).intloc 0 = len (t.fsloc 0) by SCMFSA_2:100
      .= 1 by A2,FINSEQ_1:56;
    hence thesis by A1,A4,A3,AMISTD_1:def 3;
  end;
  cluster InsCode (f:=<0,...,0>a) -> non jump-only InsType of SCM+FSA;
  coherence
  proof
    ObjectKind intloc 0 = INT by SCMFSA_2:26;
    then reconsider D = 1 as Element of ObjectKind intloc 0 by INT_1:def 1;
    reconsider DWA = 2 as Element of INT by INT_1:def 1;
    consider w being State of SCM+FSA;
A5: fsloc 0 <> IC SCM+FSA by SCMFSA_2:82;
    <*DWA*> in INT* by FINSEQ_1:def 11;
    then reconsider F = <*2*> as Element of ObjectKind fsloc 0 by SCMFSA_2:27;
    set t = w+*(fsloc 0 .--> F)+*(intloc 0 .--> D);
A6: t.fsloc 0 = F by BVFUNC14:15,SCMFSA_2:126;
A7: F <> <*0*> by FINSEQ_1:97;
    consider k being Element of NAT such that
A8: k = abs( t.intloc 0 ) and
A9: Exec(fsloc 0:=<0,...,0>intloc 0, t).fsloc 0 = k |-> 0 by SCMFSA_2:101;
    t.intloc 0 = D by FUNCT_7:96;
    then k = 1 by A8,ABSVALUE:def 1;
    then
A10: Exec(fsloc 0:=<0,...,0>intloc 0, t).fsloc 0 = <*0*> by A9,FINSEQ_2:73;
    InsCode (f:=<0,...,0>a) = 12 by SCMFSA_2:53
      .= InsCode (fsloc 0:=<0,...,0>intloc 0) by SCMFSA_2:53;
    hence thesis by A5,A6,A7,A10,AMISTD_1:def 3;
  end;
end;

registration
  let a, f;
  cluster a:=len f -> non jump-only sequential;
  coherence
  proof
    thus InsCode (a:=len f) is not jump-only;
    let s be State of SCM+FSA;
    thus thesis by SCMFSA_2:100;
  end;
  cluster f:=<0,...,0>a -> non jump-only sequential;
  coherence
  proof
    thus InsCode (f:=<0,...,0>a) is not jump-only;
    let s be State of SCM+FSA;
    thus thesis by SCMFSA_2:101;
  end;
end;

registration
  cluster SCM+FSA -> homogeneous with_explicit_jumps without_implicit_jumps;
  coherence
  proof
    thus SCM+FSA is homogeneous
    proof
      let I, J be Instruction of SCM+FSA such that
A1:   InsCode I = InsCode J;
A2:   J = [0,{},{}] or (ex a,b st J = a:=b) or (ex a,b st J = AddTo(a,b)) or
(ex a,b st J = SubFrom(a,b)) or (ex a,b st J = MultBy(a,b)) or (ex a,b st J =
Divide(a,b)) or (ex i1 st J = goto i1) or (ex i1,a st J = a=0_goto i1) or (ex
i1,a st J = a>0_goto i1) or (ex b,a,f st J = a:=(f,b)) or (ex a,b,f st J = (f,a
):=b) or (ex a,f st J = a:=len f) or ex a,f st J = f:=<0,...,0>a by
SCMFSA_2:120;
      per cases by SCMFSA_2:120;
      suppose
        I = [0,{},{}];
        hence thesis by A1,A2,AMI_3:71,SCMFSA_2:47,48,49,123,124;
      end;
      suppose
        ex a,b st I = a:=b;
        then consider a, b such that
A3:     I = a:=b;
A4:     InsCode I = 1 by A3,SCMFSA_2:42;
        now
          per cases by SCMFSA_2:120;
          suppose
            J = [0,{},{}];
            hence thesis by A1,A3,AMI_3:71,SCMFSA_2:123;
          end;
          suppose
            ex a,b st J = a:=b;
            then consider d1, d2 such that
A5:         J = d1:=d2;
            thus dom JumpPart I = dom {} by A3,Th18
              .= dom JumpPart J by A5,Th18;
          end;
          suppose
            (ex a,b st J = AddTo(a,b)) or (ex a,b st J = SubFrom(a,b)
) or (ex a,b st J = MultBy(a,b)) or (ex a,b st J = Divide(a,b)) or (ex i1 st J
= goto i1) or (ex i1,a st J = a=0_goto i1) or (ex i1,a st J = a>0_goto i1) or (
ex b,a,f st J = a:=(f,b)) or (ex a,b,f st J = (f,a):=b) or (ex a,f st J = a
            :=len f) or ex a,f st J = f:=<0,...,0>a;
            hence thesis by A1,A4,SCMFSA_2:43,44,45,46,47,48,49,50,51,52,53;
          end;
        end;
        hence thesis;
      end;
      suppose
        ex a,b st I = AddTo(a,b);
        then consider a, b such that
A6:     I = AddTo(a,b);
A7:     InsCode I = 2 by A6,SCMFSA_2:43;
        now
          per cases by SCMFSA_2:120;
          suppose
            J = [0,{},{}];
            hence thesis by A1,A6,AMI_3:71,SCMFSA_2:123;
          end;
          suppose
            ex a,b st J = AddTo(a,b);
            then consider d1, d2 such that
A8:         J = AddTo(d1,d2);
            thus dom JumpPart I = dom {} by A6,Th19
              .= dom JumpPart J by A8,Th19;
          end;
          suppose
            (ex a,b st J = a:=b) or (ex a,b st J = SubFrom(a,b)) or (
ex a,b st J = MultBy(a,b)) or (ex a,b st J = Divide(a,b)) or (ex i1 st J = goto
i1) or (ex i1,a st J = a=0_goto i1) or (ex i1,a st J = a>0_goto i1) or (ex b,a,
f st J = a:=(f,b)) or (ex a,b,f st J = (f,a):=b) or (ex a,f st J = a:=len f) or
            ex a,f st J = f:=<0,...,0>a;
            hence thesis by A1,A7,SCMFSA_2:42,44,45,46,47,48,49,50,51,52,53;
          end;
        end;
        hence thesis;
      end;
      suppose
        ex a,b st I = SubFrom(a,b);
        then consider a, b such that
A9:     I = SubFrom(a,b);
A10:    InsCode I = 3 by A9,SCMFSA_2:44;
        now
          per cases by SCMFSA_2:120;
          suppose
            J = [0,{},{}];
            hence thesis by A1,A9,AMI_3:71,SCMFSA_2:123;
          end;
          suppose
            ex a,b st J = SubFrom(a,b);
            then consider d1, d2 such that
A11:        J = SubFrom(d1,d2);
            thus dom JumpPart I = dom {} by A9,Th20
              .= dom JumpPart J by A11,Th20;
          end;
          suppose
            (ex a,b st J = a:=b) or (ex a,b st J = AddTo(a,b)) or (ex
a,b st J = MultBy(a,b)) or (ex a,b st J = Divide(a,b)) or (ex i1 st J = goto i1
) or (ex i1,a st J = a=0_goto i1) or (ex i1,a st J = a>0_goto i1) or (ex b,a,f
st J = a:=(f,b)) or (ex a,b,f st J = (f,a):=b) or (ex a,f st J = a:=len f) or
            ex a,f st J = f:=<0,...,0>a;
            hence thesis by A1,A10,SCMFSA_2:42,43,45,46,47,48,49,50,51,52,53;
          end;
        end;
        hence thesis;
      end;
      suppose
        ex a,b st I = MultBy(a,b);
        then consider a, b such that
A12:    I = MultBy(a,b);
A13:    InsCode I = 4 by A12,SCMFSA_2:45;
        now
          per cases by SCMFSA_2:120;
          suppose
            J = [0,{},{}];
            hence thesis by A1,A12,AMI_3:71,SCMFSA_2:123;
          end;
          suppose
            ex a,b st J = MultBy(a,b);
            then consider d1, d2 such that
A14:        J = MultBy(d1,d2);
            thus dom JumpPart I = dom {} by A12,Th21
              .= dom JumpPart J by A14,Th21;
          end;
          suppose
            (ex a,b st J = a:=b) or (ex a,b st J = AddTo(a,b)) or (ex
a,b st J = SubFrom(a,b)) or (ex a,b st J = Divide(a,b)) or (ex i1 st J = goto
i1) or (ex i1,a st J = a=0_goto i1) or (ex i1,a st J = a>0_goto i1) or (ex b,a,
f st J = a:=(f,b)) or (ex a,b,f st J = (f,a):=b) or (ex a,f st J = a:=len f) or
            ex a,f st J = f:=<0,...,0>a;
            hence thesis by A1,A13,SCMFSA_2:42,43,44,46,47,48,49,50,51,52,53;
          end;
        end;
        hence thesis;
      end;
      suppose
        ex a,b st I = Divide(a,b);
        then consider a, b such that
A15:    I = Divide(a,b);
A16:    InsCode I = 5 by A15,SCMFSA_2:46;
        now
          per cases by SCMFSA_2:120;
          suppose
            J = [0,{},{}];
            hence thesis by A1,A15,AMI_3:71,SCMFSA_2:123;
          end;
          suppose
            ex a,b st J = Divide(a,b);
            then consider d1, d2 such that
A17:        J = Divide(d1,d2);
            thus dom JumpPart I = dom {} by A15,Th22
              .= dom JumpPart J by A17,Th22;
          end;
          suppose
            (ex a,b st J = a:=b) or (ex a,b st J = AddTo(a,b)) or (ex
a,b st J = SubFrom(a,b)) or (ex a,b st J = MultBy(a,b)) or (ex i1 st J = goto
i1) or (ex i1,a st J = a=0_goto i1) or (ex i1,a st J = a>0_goto i1) or (ex b,a,
f st J = a:=(f,b)) or (ex a,b,f st J = (f,a):=b) or (ex a,f st J = a:=len f) or
            ex a,f st J = f:=<0,...,0>a;
            hence thesis by A1,A16,SCMFSA_2:42,43,44,45,47,48,49,50,51,52,53;
          end;
        end;
        hence thesis;
      end;
      suppose
        ex i1 st I = goto i1;
        then consider i1 such that
A18:    I = goto i1;
A19:    InsCode I = 6 by A18,SCMFSA_2:47;
        now
          per cases by SCMFSA_2:120;
          suppose
            J = [0,{},{}];
            hence thesis by A1,A18,AMI_3:71,SCMFSA_2:47,123,124;
          end;
          suppose
            ex i2 st J = goto i2;
            then consider i2 such that
A20:        J = goto i2;
            thus dom JumpPart I = dom <*i1*> by A18,RECDEF_2:def 2
              .= Seg 1 by FINSEQ_1:def 8
              .= dom <*i2*> by FINSEQ_1:def 8
              .= dom JumpPart J by A20,RECDEF_2:def 2;
          end;
          suppose
            (ex a,b st J = a:=b) or (ex a,b st J = AddTo(a,b)) or (ex
a,b st J = SubFrom(a,b)) or (ex a,b st J = MultBy(a,b)) or (ex a,b st J =
Divide(a,b)) or (ex i1,a st J = a=0_goto i1) or (ex i1,a st J = a>0_goto i1) or
(ex b,a,f st J = a:=(f,b)) or (ex a,b,f st J = (f,a):=b) or (ex a,f st J = a
            :=len f) or ex a,f st J = f:=<0,...,0>a;
            hence thesis by A1,A19,SCMFSA_2:42,43,44,45,46,48,49,50,51,52,53;
          end;
        end;
        hence thesis;
      end;
      suppose
        ex i1,a st I = a=0_goto i1;
        then consider a, i1 such that
A21:    I = a=0_goto i1;
A22:    InsCode I = 7 by A21,SCMFSA_2:48;
        now
          per cases by SCMFSA_2:120;
          suppose
            J = [0,{},{}];
            hence thesis by A1,A21,AMI_3:71,SCMFSA_2:48,123,124;
          end;
          suppose
            ex i2,d1 st J = d1 =0_goto i2;
            then consider d1, i2 such that
A23:        J = d1 =0_goto i2;
            thus dom JumpPart I = dom <*i1*> by A21,Th24
              .= Seg 1 by FINSEQ_1:55
              .= dom <*i2*> by FINSEQ_1:55
              .= dom JumpPart J by A23,Th24;
          end;
          suppose
            (ex a,b st J = a:=b) or (ex a,b st J = AddTo(a,b)) or (ex
a,b st J = SubFrom(a,b)) or (ex a,b st J = MultBy(a,b)) or (ex a,b st J =
Divide(a,b)) or (ex i1 st J = goto i1) or (ex i1,a st J = a>0_goto i1) or (ex b
,a,f st J = a:=(f,b)) or (ex a,b,f st J = (f,a):=b) or (ex a,f st J = a:=len f)
            or ex a,f st J = f:=<0,...,0>a;
            hence thesis by A1,A22,SCMFSA_2:42,43,44,45,46,47,49,50,51,52,53;
          end;
        end;
        hence thesis;
      end;
      suppose
        ex i1,a st I = a>0_goto i1;
        then consider a, i1 such that
A24:    I = a>0_goto i1;
A25:    InsCode I = 8 by A24,SCMFSA_2:49;
        now
          per cases by SCMFSA_2:120;
          suppose
            J = [0,{},{}];
            hence thesis by A1,A24,AMI_3:71,SCMFSA_2:49,123,124;
          end;
          suppose
            ex i2,d1 st J = d1 >0_goto i2;
            then consider d1, i2 such that
A26:        J = d1 >0_goto i2;
            thus dom JumpPart I = dom <*i1*> by A24,Th25
              .= Seg 1 by FINSEQ_1:55
              .= dom <*i2*> by FINSEQ_1:55
              .= dom JumpPart J by A26,Th25;
          end;
          suppose
            (ex a,b st J = a:=b) or (ex a,b st J = AddTo(a,b)) or (ex
a,b st J = SubFrom(a,b)) or (ex a,b st J = MultBy(a,b)) or (ex a,b st J =
Divide(a,b)) or (ex i1 st J = goto i1) or (ex i1,a st J = a=0_goto i1) or (ex b
,a,f st J = a:=(f,b)) or (ex a,b,f st J = (f,a):=b) or (ex a,f st J = a:=len f)
            or ex a,f st J = f:=<0,...,0>a;
            hence thesis by A1,A25,SCMFSA_2:42,43,44,45,46,47,48,50,51,52,53;
          end;
        end;
        hence thesis;
      end;
      suppose
        ex a,b,f st I = b:=(f,a);
        then consider a, b, f such that
A27:    I = b:=(f,a);
A28:    InsCode I = 9 by A27,SCMFSA_2:50;
        now
          per cases by SCMFSA_2:120;
          suppose
            J = [0,{},{}];
            hence thesis by A1,A27,AMI_3:71,SCMFSA_2:123;
          end;
          suppose
            ex a,b,f st J = b:=(f,a);
            then consider d1, d2, f1 such that
A29:        J = d2:=(f1,d1);
            thus dom JumpPart I = dom {} by A27,RECDEF_2:def 2
              .= dom JumpPart J by A29,RECDEF_2:def 2;
          end;
          suppose
            (ex a,b st J = a:=b) or (ex a,b st J = AddTo(a,b)) or (ex
a,b st J = SubFrom(a,b)) or (ex a,b st J = MultBy(a,b)) or (ex a,b st J =
Divide(a,b)) or (ex i1 st J = goto i1) or (ex i1,a st J = a=0_goto i1) or (ex
i1,a st J = a>0_goto i1) or (ex a,b,f st J = (f,a):=b) or (ex a,f st J = a:=len
            f) or ex a,f st J = f:=<0,...,0>a;
            hence thesis by A1,A28,SCMFSA_2:42,43,44,45,46,47,48,49,51,52,53;
          end;
        end;
        hence thesis;
      end;
      suppose
        ex a,b,f st I = (f,a):=b;
        then consider a, b, f such that
A30:    I = (f,a):=b;
A31:    InsCode I = 10 by A30,SCMFSA_2:51;
        now
          per cases by SCMFSA_2:120;
          suppose
            J = [0,{},{}];
            hence thesis by A1,A30,AMI_3:71,SCMFSA_2:123;
          end;
          suppose
            ex a,b,f st J = (f,a):=b;
            then consider d1, d2, f1 such that
A32:        J = (f1,d1):=d2;
            thus dom JumpPart I = dom {} by A30,RECDEF_2:def 2
              .= dom JumpPart J by A32,RECDEF_2:def 2;
          end;
          suppose
            (ex a,b st J = a:=b) or (ex a,b st J = AddTo(a,b)) or (ex
a,b st J = SubFrom(a,b)) or (ex a,b st J = MultBy(a,b)) or (ex a,b st J =
Divide(a,b)) or (ex i1 st J = goto i1) or (ex i1,a st J = a=0_goto i1) or (ex
i1,a st J = a>0_goto i1) or (ex a,b,f st J = b:=(f,a)) or (ex a,f st J = a:=len
            f) or ex a,f st J = f:=<0,...,0>a;
            hence thesis by A1,A31,SCMFSA_2:42,43,44,45,46,47,48,49,50,52,53;
          end;
        end;
        hence thesis;
      end;
      suppose
        ex a,f st I = a:=len f;
        then consider a, f such that
A33:    I = a:=len f;
A34:    InsCode I = 11 by A33,SCMFSA_2:52;
        now
          per cases by SCMFSA_2:120;
          suppose
            J = [0,{},{}];
            hence thesis by A1,A33,AMI_3:71,SCMFSA_2:123;
          end;
          suppose
            ex a,f st J = a:=len f;
            then consider d1, f1 such that
A35:        J = d1:=len f1;
            thus dom JumpPart I = dom {} by A33,RECDEF_2:def 2
              .= dom JumpPart J by A35,RECDEF_2:def 2;
          end;
          suppose
            (ex a,b st J = a:=b) or (ex a,b st J = AddTo(a,b)) or (ex
a,b st J = SubFrom(a,b)) or (ex a,b st J = MultBy(a,b)) or (ex a,b st J =
Divide(a,b)) or (ex i1 st J = goto i1) or (ex i1,a st J = a=0_goto i1) or (ex
i1,a st J = a>0_goto i1) or (ex a,b,f st J = b:=(f,a)) or (ex a,b,f st J = (f,a
            ):=b) or ex a,f st J = f:=<0,...,0>a;
            hence thesis by A1,A34,SCMFSA_2:42,43,44,45,46,47,48,49,50,51,53;
          end;
        end;
        hence thesis;
      end;
      suppose
        ex a,f st I = f:=<0,...,0>a;
        then consider a, f such that
A36:    I = f:=<0,...,0>a;
A37:    InsCode I = 12 by A36,SCMFSA_2:53;
        now
          per cases by SCMFSA_2:120;
          suppose
            J = [0,{},{}];
            hence thesis by A1,A36,AMI_3:71,SCMFSA_2:123;
          end;
          suppose
            ex a,f st J = f:=<0,...,0>a;
            then consider d1, f1 such that
A38:        J = f1:=<0,...,0>d1;
            thus dom JumpPart I = dom {} by A36,RECDEF_2:def 2
              .= dom JumpPart J by A38,RECDEF_2:def 2;
          end;
          suppose
            (ex a,b st J = a:=b) or (ex a,b st J = AddTo(a,b)) or (ex
a,b st J = SubFrom(a,b)) or (ex a,b st J = MultBy(a,b)) or (ex a,b st J =
Divide(a,b)) or (ex i1 st J = goto i1) or (ex i1,a st J = a=0_goto i1) or (ex
i1,a st J = a>0_goto i1) or (ex a,b,f st J = b:=(f,a)) or (ex a,b,f st J = (f,a
            ):=b) or ex a,f st J = a:=len f;
            hence thesis by A1,A37,SCMFSA_2:42,43,44,45,46,47,48,49,50,51,52;
          end;
        end;
        hence thesis;
      end;
    end;
    thus SCM+FSA is with_explicit_jumps
    proof
      let I be Instruction of SCM+FSA;
      let f be set such that
A39:  f in JUMP I;
      per cases by SCMFSA_2:120;
      suppose
        I = [0,{},{}];
        hence thesis by A39,AMI_3:71,SCMFSA_2:123;
      end;
      suppose
        ex a,b st I = a:=b;
        hence thesis by A39;
      end;
      suppose
        ex a,b st I = AddTo(a,b);
        hence thesis by A39;
      end;
      suppose
        ex a,b st I = SubFrom(a,b);
        hence thesis by A39;
      end;
      suppose
        ex a,b st I = MultBy(a,b);
        hence thesis by A39;
      end;
      suppose
        ex a,b st I = Divide(a,b);
        hence thesis by A39;
      end;
      suppose
A40:    ex i1 st I = goto i1;
        consider i1 such that
A41:    I = goto i1 by A40;
A42:    JumpPart goto i1 = <*i1*> by RECDEF_2:def 2;
X:      rng<*i1*> = {i1} by FINSEQ_1:56;
        JUMP goto i1 = {i1} by Th75;
        then f = i1 by A39,A41,TARSKI:def 1;
        hence thesis by A41,A42,X,TARSKI:def 1;
      end;
      suppose
A43:    ex i1,a st I = a=0_goto i1;
        consider a, i1 such that
A44:    I = a=0_goto i1 by A43;
A45:    JumpPart (a=0_goto i1) = <*i1*> by Th24;
X:      rng<*i1*> = {i1} by FINSEQ_1:56;
        JUMP (a=0_goto i1) = {i1} by Th77;
        then f = i1 by A39,A44,TARSKI:def 1;
        hence thesis by A44,A45,X,TARSKI:def 1;
      end;
      suppose
A46:    ex i1,a st I = a>0_goto i1;
        consider a, i1 such that
A47:    I = a>0_goto i1 by A46;
A48:    JumpPart (a>0_goto i1) = <*i1*> by Th25;
X:      rng<*i1*> = {i1} by FINSEQ_1:56;
        JUMP (a>0_goto i1) = {i1} by Th79;
        then f = i1 by A39,A47,TARSKI:def 1;
        hence thesis by A47,A48,X,TARSKI:def 1;
      end;
      suppose
        ex a,b,f st I = b:=(f,a);
        hence thesis by A39;
      end;
      suppose
        ex a,b,f st I = (f,a):=b;
        hence thesis by A39;
      end;
      suppose
        ex a,f st I = a:=len f;
        hence thesis by A39;
      end;
      suppose
        ex a,f st I = f:=<0,...,0>a;
        hence thesis by A39;
      end;
    end;
    let I be Instruction of SCM+FSA;
    let f being set;
    assume f in rng JumpPart I;
    then consider k being set such that
A49: k in dom JumpPart I and
B49: f = (JumpPart I).k by FUNCT_1:def 5;
    per cases by SCMFSA_2:120;
    suppose
      I = [0,{},{}];
      then dom JumpPart I = dom {} by RECDEF_2:def 2;
      hence thesis by A49;
    end;
    suppose
      ex a,b st I = a:=b;
      then consider a, b such that
A52:  I = a:=b;
      k in dom {} by A49,A52,Th18;
      hence thesis;
    end;
    suppose
      ex a,b st I = AddTo(a,b);
      then consider a, b such that
A53:  I = AddTo(a,b);
      k in dom {} by A49,A53,Th19;
      hence thesis;
    end;
    suppose
      ex a,b st I = SubFrom(a,b);
      then consider a, b such that
A54:  I = SubFrom(a,b);
      k in dom {} by A49,A54,Th20;
      hence thesis;
    end;
    suppose
      ex a,b st I = MultBy(a,b);
      then consider a, b such that
A55:  I = MultBy(a,b);
      k in dom {} by A49,A55,Th21;
      hence thesis;
    end;
    suppose
      ex a,b st I = Divide(a,b);
      then consider a, b such that
A56:  I = Divide(a,b);
      k in dom {} by A49,A56,Th22;
      hence thesis;
    end;
    suppose
      ex i1 st I = goto i1;
      then consider i1 such that
A57:  I = goto i1;
A58:  JumpPart I = <*i1*> by A57,RECDEF_2:def 2;
      then k = 1 by A49,FINSEQ_1:111;
      then
A59:  f = i1 by A58,B49,FINSEQ_1:def 8;
      JUMP I = {i1} by A57,Th75;
      hence thesis by A59,TARSKI:def 1;
    end;
    suppose
      ex i1,a st I = a=0_goto i1;
      then consider a, i1 such that
A60:  I = a=0_goto i1;
A61:  JumpPart I = <*i1*> by A60,Th24;
      then k = 1 by A49,FINSEQ_1:111;
      then
A62:  f = i1 by A61,B49,FINSEQ_1:def 8;
      JUMP I = {i1} by A60,Th77;
      hence thesis by A62,TARSKI:def 1;
    end;
    suppose
      ex i1,a st I = a>0_goto i1;
      then consider a, i1 such that
A63:  I = a>0_goto i1;
A64:  JumpPart I = <*i1*> by A63,Th25;
      then k = 1 by A49,FINSEQ_1:111;
      then
A65:  f = i1 by A64,B49,FINSEQ_1:def 8;
      JUMP I = {i1} by A63,Th79;
      hence thesis by A65,TARSKI:def 1;
    end;
    suppose
      ex a,b,f st I = b:=(f,a);
      then consider a, b, f such that
A66:  I = b:=(f,a);
      k in dom {} by A49,A66,RECDEF_2:def 2;
      hence thesis;
    end;
    suppose
      ex a,b,f st I = (f,a):=b;
      then consider a, b, f such that
A67:  I = (f,a):=b;
      k in dom {} by A49,A67,RECDEF_2:def 2;
      hence thesis;
    end;
    suppose
      ex a,f st I = a:=len f;
      then consider a, f such that
A68:  I = a:=len f;
      k in dom {} by A49,A68,RECDEF_2:def 2;
      hence thesis;
    end;
    suppose
      ex a,f st I = f:=<0,...,0>a;
      then consider a, f such that
A69:  I = f:=<0,...,0>a;
      k in dom {} by A49,A69,RECDEF_2:def 2;
      hence thesis;
    end;
  end;
end;

registration
  cluster SCM+FSA -> regular J/A-independent;
  coherence
  proof
   thus SCM+FSA is regular
   proof
    let I be Instruction of SCM+FSA;
     set T = InsCode I;
X:   JumpPart I in JumpParts T;
    per cases by Lm4;
    suppose T = 0;
      then JumpParts T = {{}} by Th30;
      then JumpPart I = {} by X,TARSKI:def 1;
     hence thesis;
    end;
    suppose T = 1;
      then JumpParts T = {{}} by Th31;
      then JumpPart I = {} by X,TARSKI:def 1;
     hence thesis;
    end;
    suppose T = 2;
      then JumpParts T = {{}} by Th32;
      then JumpPart I = {} by X,TARSKI:def 1;
     hence thesis;
    end;
    suppose T = 3;
      then JumpParts T = {{}} by Th33;
      then JumpPart I = {} by X,TARSKI:def 1;
     hence thesis;
    end;
    suppose T = 4;
      then JumpParts T = {{}} by Th34;
      then JumpPart I = {} by X,TARSKI:def 1;
     hence thesis;
    end;
    suppose T = 5;
      then JumpParts T = {{}} by Th35;
      then JumpPart I = {} by X,TARSKI:def 1;
     hence thesis;
    end;
    suppose
A127: T = 6;
     then consider i2 such that
W:    I = goto i2 by SCMFSA_2:59;
     let k be set;
     assume
Z:      k in dom JumpPart I;
      for f being Function st f in JumpParts T holds k in dom f
       proof let f be Function;
        assume f in JumpParts T;
         then consider J being Instruction of SCM+FSA such that
W1:       f = JumpPart J and
W2:       InsCode J = T;
        thus k in dom f by Z,W1,W2,AMISTD_2:def 4;
       end;
      then k in dom product" JumpParts T by CARD_3:def 13;
      then k in {1} by A127,Th36;
      then k = 1 by TARSKI:def 1;
     hence (product" JumpParts InsCode I).k = NAT by W,Th53;
    end;
    suppose
A141: T = 7;
     then consider i1,a such that
W:    I = a=0_goto i1 by SCMFSA_2:60;
     let k be set;
     assume
Z:      k in dom JumpPart I;
      for f being Function st f in JumpParts T holds k in dom f
       proof let f be Function;
        assume f in JumpParts T;
         then consider J being Instruction of SCM+FSA such that
W1:       f = JumpPart J and
W2:       InsCode J = T;
        thus k in dom f by Z,W1,W2,AMISTD_2:def 4;
       end;
      then k in dom product" JumpParts T by CARD_3:def 13;
      then k in {1} by A141,Th37;
      then k = 1 by TARSKI:def 1;
     hence (product" JumpParts InsCode I).k = NAT by W,Th54;
    end;
    suppose
A166: T = 8;
     then consider i1,a such that
W:    I = a>0_goto i1 by SCMFSA_2:61;
     let k be set;
     assume
Z:      k in dom JumpPart I;
      for f being Function st f in JumpParts T holds k in dom f
       proof let f be Function;
        assume f in JumpParts T;
         then consider J being Instruction of SCM+FSA such that
W1:       f = JumpPart J and
W2:       InsCode J = T;
        thus k in dom f by Z,W1,W2,AMISTD_2:def 4;
       end;
      then k in dom product" JumpParts T by CARD_3:def 13;
      then k in {1} by A166,Th38;
      then k = 1 by TARSKI:def 1;
     hence (product" JumpParts InsCode I).k = NAT by W,Th56;
    end;
    suppose T = 9;
      then JumpParts T = {{}} by Th39;
      then JumpPart I = {} by X,TARSKI:def 1;
     hence thesis;
    end;
    suppose T = 10;
      then JumpParts T = {{}} by Th40;
      then JumpPart I = {} by X,TARSKI:def 1;
     hence thesis;
    end;
    suppose T = 11;
      then JumpParts T = {{}} by Th41;
      then JumpPart I = {} by X,TARSKI:def 1;
     hence thesis;
    end;
    suppose T = 12;
      then JumpParts T = {{}} by Th42;
      then JumpPart I = {} by X,TARSKI:def 1;
     hence thesis;
    end;
   end;
   let T be InsType of SCM+FSA,
       f1,f2 be Function, p be set such that
Z1: f1 in JumpParts T and
Z2: f2 in product product" JumpParts T and
Z3: [T,f1,p] in the Instructions of SCM+FSA;
    per cases by Lm4;
    suppose T = 0 or T = 1 or T = 2 or T = 3 or T = 4 or T = 5
       or T = 9 or T = 10 or T = 11 or T = 12;
     then
A:  JumpParts T = {0} by Th30,Th31,Th32,Th33,Th34,Th35,Th39,Th40,Th41,Th42;
     then f1 = 0 by Z1,TARSKI:def 1 .= f2 by Z2,A,CARD_3:19,156,TARSKI:def 1;
    hence [T,f2,p] in the Instructions of SCM+FSA by Z3;
    end;
    suppose
S:    T = 6;
    reconsider J = [T,f1,p] as Instruction of SCM+FSA by Z3;
SS: InsCode J = 6 by S,RECDEF_2:def 1;
    then consider i1 being Element of NAT such that
B7:  J = goto i1 by SCMFSA_2:59;
P:   p = {} by B7,MCART_1:28;
U1: dom f2 = dom product" JumpParts T  by Z2,CARD_3:18;
XX: dom f2 = {1} by S,U1,Th36;
    then 1 in dom f2 by TARSKI:def 1;
    then f2.1 in (product" JumpParts T).1 by U1,Z2,CARD_3:18;
    then reconsider l = f2.1 as Element of NAT by B7,S,SS,Th53;
    set I = [T,f2,{}];
    I = goto l by S,XX,FINSEQ_1:4,def 8;
    then  reconsider I as Instruction of SCM+FSA;
    f2 = JumpPart I by RECDEF_2:def 2;
    hence [T,f2,p] in the Instructions of SCM+FSA by P;
    end;
    suppose
S:    T = 7;
    reconsider J = [T,f1,p] as Instruction of SCM+FSA by Z3;
SS: InsCode J = T by RECDEF_2:def 1;
    then consider i1,a such that
B7:  J = a=0_goto i1 by S,SCMFSA_2:60;
    consider A being Data-Location such that
WW:  a = A & a=0_goto i1 = A=0_goto i1 by SCMFSA_2:def 17;
P:   p = <*a*> by B7,WW,MCART_1:28;
U1: dom f2 = dom product" JumpParts T  by Z2,CARD_3:18;
XX: dom f2 = {1} by S,U1,Th37;
    then 1 in dom f2 by TARSKI:def 1;
    then f2.1 in (product" JumpParts T).1 by U1,Z2,CARD_3:18;
    then reconsider l = f2.1 as Element of NAT by B7,SS,Th54;
    set I = [T,f2,p];
    f2 = <*l*> by XX,FINSEQ_1:4,def 8;
    then I = a=0_goto l by S,P,Th15;
    then reconsider I as Instruction of SCM+FSA;
A6: InsCode I = T by RECDEF_2:def 1;
    consider i2,b such that
A7: I = b=0_goto i2 by S,A6,SCMFSA_2:60;
    thus [T,f2,p] in the Instructions of SCM+FSA by A7;
    end;
    suppose
S:    T = 8;
    reconsider J = [T,f1,p] as Instruction of SCM+FSA by Z3;
SS: InsCode J = T by RECDEF_2:def 1;
    then consider i1,a such that
B7:  J = a>0_goto i1 by S,SCMFSA_2:61;
    consider A being Data-Location such that
WW:  a = A & a>0_goto i1 = A>0_goto i1 by SCMFSA_2:def 18;
P:   p = <*a*> by B7,WW,MCART_1:28;
U1: dom f2 = dom product" JumpParts T  by Z2,CARD_3:18;
XX: dom f2 = {1} by S,U1,Th38;
    then 1 in dom f2 by TARSKI:def 1;
    then f2.1 in (product" JumpParts T).1 by U1,Z2,CARD_3:18;
    then reconsider l = f2.1 as Element of NAT by B7,SS,Th56;
    set I = [T,f2,p];
    f2 = <*l*> by XX,FINSEQ_1:4,def 8;
    then I = a>0_goto l by S,P,Th16;
    then reconsider I as Instruction of SCM+FSA;
A6: InsCode I = T by RECDEF_2:def 1;
    consider i2,b such that
A7: I = b>0_goto i2 by S,A6,SCMFSA_2:61;
    thus [T,f2,p] in the Instructions of SCM+FSA by A7;
    end;
  end;
end;

canceled 2;

theorem Th89:
  IncAddr(goto i1,k) = goto (i1+ k)
proof
A1: InsCode IncAddr(goto i1,k) = InsCode goto i1 by AMISTD_2:def 14
    .= 6 by SCMFSA_2:47
    .= InsCode goto (i1+k) by SCMFSA_2:47;
B1: AddressPart IncAddr(goto i1,k) = AddressPart goto i1 by AMISTD_2:def 14
    .= {} by RECDEF_2:def 3
    .= AddressPart goto (i1+k) by RECDEF_2:def 3;
X1: JumpPart IncAddr(goto i1,k) = k + JumpPart goto i1
 by AMISTD_2:def 14;
    then
A2: dom JumpPart IncAddr(goto i1,k) = dom JumpPart goto i1
   by VALUED_1:def 2;
A3: for x being set st x in dom JumpPart goto i1 holds (JumpPart
  IncAddr(goto i1,k)).x = (JumpPart goto (i1+k)).x
  proof
    let x be set;
    assume
A4: x in dom JumpPart goto i1;
    then x in dom <*i1*> by RECDEF_2:def 2;
    then
A5: x = 1 by FINSEQ_1:111;
    then (product" JumpParts InsCode goto i1).x = NAT by Th53;
    set f = (JumpPart goto i1).x;
A7: (JumpPart IncAddr(goto i1,k)).x = k+f by A2,X1,A4,VALUED_1:def 2;
    f = <*i1*>.x by RECDEF_2:def 2
      .= i1 by A5,FINSEQ_1:def 8;
    hence
    (JumpPart IncAddr(goto i1,k)).x =
     <*(i1+k)*>.
    x by A5,A7,FINSEQ_1:def 8
      .= (JumpPart goto (i1+k)).x by RECDEF_2:def 2;
  end;
  dom JumpPart goto (i1+k)
   = dom <*(i1+k)*> by RECDEF_2:def 2
    .= Seg 1 by FINSEQ_1:def 8
    .= dom <*i1*> by FINSEQ_1:def 8
    .= dom JumpPart goto i1 by RECDEF_2:def 2;
   then JumpPart IncAddr(goto i1,k) = JumpPart goto(i1+k) by A2,A3,FUNCT_1:9;
  hence thesis by A1,B1,COMPOS_1:7;
end;

theorem Th90:
  IncAddr(a=0_goto i1,k) = a=0_goto (i1+k)
proof
A1: InsCode IncAddr(a=0_goto i1,k) = InsCode (a=0_goto i1) by AMISTD_2:def 14
    .= 7 by SCMFSA_2:48
    .= InsCode (a=0_goto (i1+k)) by SCMFSA_2:48;
X: a=0_goto i1 = [7, <* i1*>,<*a *>] by Th15;
Y: a=0_goto(i1+k) = [7, <* i1+k*>,<*a *>] by Th15;
B1: AddressPart IncAddr(a=0_goto i1,k)
     = AddressPart (a=0_goto i1) by AMISTD_2:def 14
    .= <*a*> by X,RECDEF_2:def 3
    .= AddressPart (a=0_goto (i1+k)) by Y,RECDEF_2:def 3;
X1: JumpPart IncAddr(a=0_goto i1,k) = k + JumpPart (a=0_goto i1)
  by AMISTD_2:def 14;
  then
A2: dom JumpPart IncAddr(a=0_goto i1,k) = dom JumpPart (a=0_goto i1)
  by VALUED_1:def 2;
A3: for x being set st x in dom JumpPart (a=0_goto i1) holds (JumpPart
IncAddr(a=0_goto i1,k)).x = (JumpPart (a=0_goto (i1+k))).x
  proof
    let x be set;
    assume
A4: x in dom JumpPart (a=0_goto i1);
    then
    x in dom <*i1*> by Th24;
     then
A6:   x = 1 by FINSEQ_1:111;
      then (product" JumpParts InsCode (a=0_goto i1)).x = NAT by Th54;
      set f = (JumpPart (a=0_goto i1)).x;
A8:   (JumpPart IncAddr(a=0_goto i1,k)).x = k+f by A2,X1,A4,VALUED_1:def 2;
      f = <*i1*>.x by Th24
        .= i1 by A6,FINSEQ_1:57;
      hence
      (JumpPart IncAddr(a=0_goto i1,k)).x =
       <*(i1+k)*>.x by A6,A8,FINSEQ_1:57
        .= (JumpPart (a=0_goto (i1+k))).x
         by Th24;
  end;
  dom JumpPart (a=0_goto (i1+k))
   = dom <*(i1+k)*> by Th24
    .= Seg 1 by FINSEQ_1:55
    .= dom <*i1*> by FINSEQ_1:55
    .= dom JumpPart (a=0_goto i1) by Th24;
   then JumpPart IncAddr(a=0_goto i1,k) = JumpPart (a=0_goto (i1+k))
     by A2,A3,FUNCT_1:9;
  hence thesis by A1,B1,COMPOS_1:7;
end;

theorem Th91:
  IncAddr(a>0_goto i1,k) = a>0_goto (i1+k)
proof
A1: InsCode IncAddr(a>0_goto i1,k) = InsCode (a>0_goto i1) by AMISTD_2:def 14
    .= 8 by SCMFSA_2:49
    .= InsCode (a>0_goto (i1+k)) by SCMFSA_2:49;
X: a>0_goto i1 = [8, <* i1*>,<*a *>] by Th16;
Y: a>0_goto(i1+k) = [8, <* i1+k*>,<*a *>] by Th16;
B1: AddressPart IncAddr(a>0_goto i1,k)
     = AddressPart (a>0_goto i1) by AMISTD_2:def 14
    .= <*a*> by X,RECDEF_2:def 3
    .= AddressPart (a>0_goto (i1+k)) by Y,RECDEF_2:def 3;
X1:  JumpPart IncAddr(a>0_goto i1,k) = k + JumpPart (a>0_goto i1)
  by AMISTD_2:def 14;
  then
A2: dom JumpPart IncAddr(a>0_goto i1,k) = dom JumpPart (a>0_goto i1)
  by VALUED_1:def 2;
A3: for x being set st x in dom JumpPart (a>0_goto i1) holds (JumpPart
IncAddr(a>0_goto i1,k)).x = (JumpPart (a>0_goto (i1+k))).x
  proof
    let x be set;
    assume
A4: x in dom JumpPart (a>0_goto i1);
    then x in dom <*i1*> by Th25;
     then
A6:   x = 1 by FINSEQ_1:111;
      then (product" JumpParts InsCode (a>0_goto i1)).x = NAT by Th56;
    set f = (JumpPart (a>0_goto i1)).1;
A8:   (JumpPart IncAddr(a>0_goto i1,k)).1 = k+f by A6,A2,X1,A4,VALUED_1:def 2;
      f = <*i1*>.x by Th25,A6
        .= i1 by A6,FINSEQ_1:57;
      hence
      (JumpPart IncAddr(a>0_goto i1,k)).x
       = <*(i1+k)*>.x by A6,A8,FINSEQ_1:57
        .= (JumpPart (a>0_goto (i1+k))).x by Th25;
  end;
  dom JumpPart (a>0_goto (i1+k)) =
   dom <*(i1+k)*> by Th25
    .= Seg 1 by FINSEQ_1:55
    .= dom <*i1*> by FINSEQ_1:55
    .= dom JumpPart (a>0_goto i1) by Th25;
   then JumpPart IncAddr(a>0_goto i1,k) = JumpPart (a>0_goto (i1+k))
     by A2,A3,FUNCT_1:9;
  hence thesis by A1,B1,COMPOS_1:7;
end;

registration
  cluster SCM+FSA -> IC-good;
  coherence
  proof
   let I be Instruction of SCM+FSA;
      per cases by SCMFSA_2:120;
      suppose
        I = [0,{},{}];
        hence thesis by AMI_3:71,SCMFSA_2:123;
      end;
      suppose
        ex a,b st I = a:=b;
        hence thesis;
      end;
      suppose
        ex a,b st I = AddTo(a,b);
        hence thesis;
      end;
      suppose
        ex a,b st I = SubFrom(a,b);
        hence thesis;
      end;
      suppose
        ex a,b st I = MultBy(a,b);
        hence thesis;
      end;
      suppose
        ex a,b st I = Divide(a,b);
        hence thesis;
      end;
      suppose
A1:     ex i1 st I = goto i1;
        let k be natural number, s1 be State of SCM+FSA;
        set s2 = IncrIC(s1,k);
        consider i1 such that
A2:     I = goto i1 by A1;
        IC Exec(I,s1) = i1 by A2,SCMFSA_2:95;
        hence IC Exec(I,s1) + k = IC Exec(goto (i1+k),s2) by SCMFSA_2:95
          .= IC Exec(IncAddr(I,k), s2) by A2,Th89;
      end;
      suppose
        ex i1,a st I = a=0_goto i1;
        then consider a, i1 such that
A3:     I = a=0_goto i1;
        let k be natural number, s1 be State of SCM+FSA;
        set s2 = IncrIC(s1,k);
A5:     dom (IC SCM+FSA .--> (IC s1 + k)) = {IC SCM+FSA}
by FUNCOP_1:19;
        a <> IC SCM+FSA by SCMFSA_2:81;
        then not a in dom (IC SCM+FSA .--> (IC s1 + k))
               by A5,TARSKI:def 1;
        then
A6:     s1.a = s2.a by FUNCT_4:12;
        now
          per cases;
          suppose
A7:         s1.a = 0;
            then IC Exec(I,s1) = i1 by A3,SCMFSA_2:96;
            hence
            IC Exec(I,s1) + k =
             IC Exec(a=0_goto (i1+k),s2)
              by A6,A7,SCMFSA_2:96
              .= IC Exec(IncAddr(I,k), s2) by A3,Th90;
          end;
          suppose
A8:         s1.a <> 0;
            dom (IC SCM+FSA .--> (IC s1 + k)) = {IC SCM+FSA}
            by FUNCOP_1:19;
            then IC SCM+FSA in dom (IC SCM+FSA .--> (IC s1 + k)) by
TARSKI:def 1;
            then
A9:         IC s2 = (IC SCM+FSA .--> (IC s1 + k)).IC SCM+FSA by FUNCT_4:14
              .= (IC s1+k)
              by FUNCOP_1:87;
A10:        IC Exec(I,s1) = succ IC s1 by A3,A8,SCMFSA_2:96
              .= IC s1 + 1;
            IC Exec(I, s2) = succ IC s2 by A3,A6,A8,SCMFSA_2:96
              .= IC s1 + k + 1 by A9;
            hence IC Exec(I,s1) + k
               = succ IC s2 by A3,A6,A8,A10,SCMFSA_2:96
              .= IC Exec(a=0_goto (i1+k),s2) by A6,A8,SCMFSA_2:96
              .= IC Exec(IncAddr(I,k), s2) by A3,Th90;
          end;
        end;
        hence thesis;
      end;
      suppose ex i1,a st I = a>0_goto i1;
        then consider a, i1 such that
A11:    I = a>0_goto i1;
        let k be natural number, s1 be State of SCM+FSA;
        set s2 = IncrIC(s1,k);
A13:    dom (IC SCM+FSA .--> (IC s1 + k)) = {IC SCM+FSA} by FUNCOP_1:19;
        a <> IC SCM+FSA by SCMFSA_2:81;
        then not a in dom (IC SCM+FSA .--> (IC s1 + k)) by A13,TARSKI:def 1;
        then
A14:    s1.a = s2.a by FUNCT_4:12;
        now
          per cases;
          suppose
A15:        s1.a > 0;
            then IC Exec(I,s1) = i1 by A11,SCMFSA_2:97;
            hence
            IC Exec(I,s1) + k
             = IC Exec(a>0_goto (i1+k),s2) by A14,A15,SCMFSA_2:97
              .= IC Exec(IncAddr(I,k), s2) by A11,Th91;
          end;
          suppose
A16:        s1.a <= 0;
            dom (IC SCM+FSA .--> (IC s1 + k)) = {IC SCM+FSA} by FUNCOP_1:19;
            then IC SCM+FSA in dom (IC SCM+FSA .--> (IC s1 + k))
             by TARSKI:def 1;
            then
A17:        IC s2 = (IC SCM+FSA .--> (IC s1 + k)).IC SCM+FSA by FUNCT_4:14
              .= (IC s1+k) by FUNCOP_1:87;
A18:        IC Exec(I,s1) = succ IC s1 by A11,A16,SCMFSA_2:97
              .= IC s1 + 1;
            IC Exec(I, s2) = succ IC s2 by A11,A14,A16,SCMFSA_2:97
              .= IC s1 + k + 1 by A17;
            hence IC Exec(I,s1) + k
               = succ IC s2 by A11,A14,A16,A18,SCMFSA_2:97
              .= IC Exec(a>0_goto (i1+k),s2) by A14,A16,SCMFSA_2:97
              .= IC Exec(IncAddr(I,k), s2) by A11,Th91;
          end;
        end;
        hence thesis;
      end;
      suppose
        ex a,b,f st I = b:=(f,a);
        hence thesis;
      end;
      suppose
        ex a,b,f st I = (f,a):=b;
        hence thesis;
      end;
      suppose
        ex a,f st I = a:=len f;
        hence thesis;
      end;
      suppose
        ex a,f st I = f:=<0,...,0>a;
        hence thesis;
      end;
  end;
end;

:: moved from SCMFSA6A, 2010.04.17, A.T.

theorem Th28:
  for s1,s2 being State of SCM+FSA st IC s1 = IC s2 & (for a being
Int-Location holds s1.a = s2.a) & for f being FinSeq-Location holds s1.f = s2.f
  holds s1,s2 equal_outside NAT
proof
  set A = NAT;
  let s1,s2 be State of SCM+FSA such that
A1: IC s1 = IC s2 and
A2: for a being Int-Location holds s1.a = s2.a and
A3: for f being FinSeq-Location holds s1.f = s2.f;
  not IC SCM+FSA in A by COMPOS_1:3;
  then Int-Locations \/ FinSeq-Locations misses A & {IC SCM+FSA} misses A by
SCMFSA_2:13,14,XBOOLE_1:70,ZFMISC_1:56;
  then
A4: Int-Locations \/ FinSeq-Locations \/ {IC SCM+FSA} misses A by XBOOLE_1:70;
A5: (the carrier of SCM+FSA) \ A = Int-Locations \/ FinSeq-Locations \/ {IC
  SCM+FSA} \ A by SCMFSA_2:8,XBOOLE_1:40
    .= Int-Locations \/ FinSeq-Locations \/ {IC SCM+FSA} by A4,XBOOLE_1:83;
A6: dom(s2|(dom s2 \ A)) = dom s2 /\ (dom s2 \ A) by RELAT_1:90
    .= dom s2 \ A by XBOOLE_1:28
    .= Int-Locations \/ FinSeq-Locations \/ {IC SCM+FSA} by A5,PARTFUN1:def 4;
A7: dom(s1|(dom s1 \ A)) = dom s1 /\ (dom s1 \ A) by RELAT_1:90
    .= dom s1 \ A by XBOOLE_1:28
    .= Int-Locations \/ FinSeq-Locations \/ {IC SCM+FSA} by A5,PARTFUN1:def 4;
  now
    let x be set;
    assume
A8: x in Int-Locations \/ FinSeq-Locations \/ {IC SCM+FSA};
    then
A9: x in Int-Locations \/ FinSeq-Locations or x in {IC SCM+FSA} by
XBOOLE_0:def 3;
    per cases by A9,XBOOLE_0:def 3;
    suppose
      x in Int-Locations;
      then
A10:  x is Int-Location by SCMFSA_2:11;
      thus (s1|(dom s1 \ A)).x = s1.x by A7,A8,FUNCT_1:70
        .= s2.x by A2,A10
        .= (s2|(dom s2 \ A)).x by A6,A8,FUNCT_1:70;
    end;
    suppose
      x in FinSeq-Locations;
      then
A11:  x is FinSeq-Location by SCMFSA_2:12;
      thus (s1|(dom s1 \ A)).x = s1.x by A7,A8,FUNCT_1:70
        .= s2.x by A3,A11
        .= (s2|(dom s2 \ A)).x by A6,A8,FUNCT_1:70;
    end;
    suppose
A12:  x in {IC SCM+FSA};
      thus (s1|(dom s1 \ A)).x = s1.x by A7,A8,FUNCT_1:70
        .= IC s1 by A12,TARSKI:def 1
        .= s2.x by A1,A12,TARSKI:def 1
        .= (s2|(dom s2 \ A)).x by A6,A8,FUNCT_1:70;
    end;
  end;
  hence s1|(dom s1 \ A) = s2|(dom s2 \ A) by A7,A6,FUNCT_1:9;
end;

theorem Th30:
  s1,s2 equal_outside NAT implies for a being Int-Location holds
  s1.a = s2.a
proof
  assume
A1: s1,s2 equal_outside NAT;
  let a be Int-Location;
  a in Int-Locations by SCMFSA_2:9;
  then
A2: not a in NAT by SCMFSA_2:13,XBOOLE_0:3;
  a in dom s2 by SCMFSA_2:66;
  then a in dom s2 \ NAT by A2,XBOOLE_0:def 5;
  then
A3: a in dom s2 /\ (dom s2 \ NAT) by XBOOLE_0:def 4;
  a in dom s1 by SCMFSA_2:66;
  then a in dom s1 \ NAT by A2,XBOOLE_0:def 5;
  then a in dom s1 /\ (dom s1 \ NAT) by XBOOLE_0:def 4;
  hence s1.a = (s1|(dom s1 \ NAT)).a by FUNCT_1:71
    .= (s2|(dom s2 \ NAT)).a by A1,FUNCT_7:def 2
    .= s2.a by A3,FUNCT_1:71;
end;

theorem Th31:
  s1,s2 equal_outside NAT implies for f being FinSeq-Location
  holds s1.f = s2.f
proof
  assume
A1: s1,s2 equal_outside NAT;
  let a be FinSeq-Location;
  a in FinSeq-Locations by SCMFSA_2:10;
  then
A2: not a in NAT by SCMFSA_2:14,XBOOLE_0:3;
  a in dom s2 by SCMFSA_2:67;
  then a in dom s2 \ NAT by A2,XBOOLE_0:def 5;
  then
A3: a in dom s2 /\ (dom s2 \ NAT) by XBOOLE_0:def 4;
  a in dom s1 by SCMFSA_2:67;
  then a in dom s1 \ NAT by A2,XBOOLE_0:def 5;
  then a in dom s1 /\ (dom s1 \ NAT) by XBOOLE_0:def 4;
  hence s1.a = (s1|(dom s1 \ NAT)).a by FUNCT_1:71
    .= (s2|(dom s2 \ NAT)).a by A1,FUNCT_7:def 2
    .= s2.a by A3,FUNCT_1:71;
end;

registration
  cluster SCM+FSA -> Exec-preserving;
  coherence
  proof
   let I be Instruction of SCM+FSA;
   let s1, s2 being State of SCM+FSA such that
A1:  s1, s2 equal_outside NAT;
A2: InsCode I <= 9+1 implies InsCode I <= 8+1 or InsCode I = 10 by NAT_1:8;
A3: InsCode I <= 10+1 implies InsCode I <= 10 or InsCode I = 11 by NAT_1:8;
A4: InsCode I <= 11+1 by SCMFSA_2:35;
  per cases by A4,A3,A2,NAT_1:8,33;
  suppose
    InsCode I = 0;
    then
A5: I = halt SCM+FSA by SCMFSA_2:122;
    then Exec(I,s1) = s1 by AMI_1:def 8;
    hence thesis by A1,A5,AMI_1:def 8;
  end;
  suppose
    InsCode I = 1;
    then consider da, db being Int-Location such that
A6: I = da := db by SCMFSA_2:54;
A7: now
      let c be Int-Location;
      per cases;
      suppose
A8:     c = da;
        hence Exec(I,s1).c = s1.db by A6,SCMFSA_2:89
          .= s2.db by A1,Th30
          .= Exec(I,s2).c by A6,A8,SCMFSA_2:89;
      end;
      suppose
A9:     c <> da;
        hence Exec(I,s1).c = s1.c by A6,SCMFSA_2:89
          .= s2.c by A1,Th30
          .= Exec(I,s2).c by A6,A9,SCMFSA_2:89;
      end;
    end;
A10: now
      let f be FinSeq-Location;
      thus Exec(I,s1).f = s1.f by A6,SCMFSA_2:89
        .= s2.f by A1,Th31
        .= Exec(I,s2).f by A6,SCMFSA_2:89;
    end;
    IC Exec(I,s1) = succ IC s1 by A6,SCMFSA_2:89
      .= succ IC s2 by A1,COMPOS_1:24
      .= IC Exec(I,s2) by A6,SCMFSA_2:89;
    hence thesis by A7,A10,Th28;
  end;
  suppose
    InsCode I = 2;
    then consider da, db being Int-Location such that
A11: I = AddTo(da, db) by SCMFSA_2:55;
A12: now
      let c be Int-Location;
      per cases;
      suppose
A13:    c = da;
        s1.da = s2.da & s1.db = s2.db by A1,Th30;
        hence Exec(I,s1).c = s2.da + s2.db by A11,A13,SCMFSA_2:90
          .= Exec(I,s2).c by A11,A13,SCMFSA_2:90;
      end;
      suppose
A14:    c <> da;
        hence Exec(I,s1).c = s1.c by A11,SCMFSA_2:90
          .= s2.c by A1,Th30
          .= Exec(I,s2).c by A11,A14,SCMFSA_2:90;
      end;
    end;
A15: now
      let f be FinSeq-Location;
      thus Exec(I,s1).f = s1.f by A11,SCMFSA_2:90
        .= s2.f by A1,Th31
        .= Exec(I,s2).f by A11,SCMFSA_2:90;
    end;
    IC Exec(I,s1) = succ IC s1 by A11,SCMFSA_2:90
      .= succ IC s2 by A1,COMPOS_1:24
      .= IC Exec(I,s2) by A11,SCMFSA_2:90;
    hence thesis by A12,A15,Th28;
  end;
  suppose
    InsCode I = 3;
    then consider da, db being Int-Location such that
A16: I = SubFrom(da, db) by SCMFSA_2:56;
A17: now
      let c be Int-Location;
      per cases;
      suppose
A18:    c = da;
        s1.da = s2.da & s1.db = s2.db by A1,Th30;
        hence Exec(I,s1).c = s2.da - s2.db by A16,A18,SCMFSA_2:91
          .= Exec(I,s2).c by A16,A18,SCMFSA_2:91;
      end;
      suppose
A19:    c <> da;
        hence Exec(I,s1).c = s1.c by A16,SCMFSA_2:91
          .= s2.c by A1,Th30
          .= Exec(I,s2).c by A16,A19,SCMFSA_2:91;
      end;
    end;
A20: now
      let f be FinSeq-Location;
      thus Exec(I,s1).f = s1.f by A16,SCMFSA_2:91
        .= s2.f by A1,Th31
        .= Exec(I,s2).f by A16,SCMFSA_2:91;
    end;
    IC Exec(I,s1) = succ IC s1 by A16,SCMFSA_2:91
      .= succ IC s2 by A1,COMPOS_1:24
      .= IC Exec(I,s2) by A16,SCMFSA_2:91;
    hence thesis by A17,A20,Th28;
  end;
  suppose
    InsCode I = 4;
    then consider da, db being Int-Location such that
A21: I = MultBy(da, db) by SCMFSA_2:57;
A22: now
      let c be Int-Location;
      per cases;
      suppose
A23:    c = da;
        s1.da = s2.da & s1.db = s2.db by A1,Th30;
        hence Exec(I,s1).c = s2.da * s2.db by A21,A23,SCMFSA_2:92
          .= Exec(I,s2).c by A21,A23,SCMFSA_2:92;
      end;
      suppose
A24:    c <> da;
        hence Exec(I,s1).c = s1.c by A21,SCMFSA_2:92
          .= s2.c by A1,Th30
          .= Exec(I,s2).c by A21,A24,SCMFSA_2:92;
      end;
    end;
A25: now
      let f be FinSeq-Location;
      thus Exec(I,s1).f = s1.f by A21,SCMFSA_2:92
        .= s2.f by A1,Th31
        .= Exec(I,s2).f by A21,SCMFSA_2:92;
    end;
    IC Exec(I,s1) = succ IC s1 by A21,SCMFSA_2:92
      .= succ IC s2 by A1,COMPOS_1:24
      .= IC Exec(I,s2) by A21,SCMFSA_2:92;
    hence thesis by A22,A25,Th28;
  end;
  suppose
    InsCode I = 5;
    then consider da, db being Int-Location such that
A26: I = Divide(da, db) by SCMFSA_2:58;
A27: now
      let c be Int-Location;
      per cases;
      suppose
A28:    c = db;
        s1.da = s2.da & s1.db = s2.db by A1,Th30;
        hence Exec(I,s1).c = s2.da mod s2.db by A26,A28,SCMFSA_2:93
          .= Exec(I,s2).c by A26,A28,SCMFSA_2:93;
      end;
      suppose
A29:    c = da & c <> db;
        s1.da = s2.da & s1.db = s2.db by A1,Th30;
        hence Exec(I,s1).c = s2.da div s2.db by A26,A29,SCMFSA_2:93
          .= Exec(I,s2).c by A26,A29,SCMFSA_2:93;
      end;
      suppose
A30:    c <> da & c <> db;
        hence Exec(I,s1).c = s1.c by A26,SCMFSA_2:93
          .= s2.c by A1,Th30
          .= Exec(I,s2).c by A26,A30,SCMFSA_2:93;
      end;
    end;
A31: now
      let f be FinSeq-Location;
      thus Exec(I,s1).f = s1.f by A26,SCMFSA_2:93
        .= s2.f by A1,Th31
        .= Exec(I,s2).f by A26,SCMFSA_2:93;
    end;
    IC Exec(I,s1) = succ IC s1 by A26,SCMFSA_2:93
      .= succ IC s2 by A1,COMPOS_1:24
      .= IC Exec(I,s2) by A26,SCMFSA_2:93;
    hence thesis by A27,A31,Th28;
  end;
  suppose
    InsCode I = 6;
    then consider loc being Element of NAT such that
A32: I = goto loc by SCMFSA_2:59;
A33: now
      let f be FinSeq-Location;
      thus Exec(I,s1).f = s1.f by A32,SCMFSA_2:95
        .= s2.f by A1,Th31
        .= Exec(I,s2).f by A32,SCMFSA_2:95;
    end;
A34: now
      let c be Int-Location;
      thus Exec(I,s1).c = s1.c by A32,SCMFSA_2:95
        .= s2.c by A1,Th30
        .= Exec(I,s2).c by A32,SCMFSA_2:95;
    end;
    IC Exec(I,s1) = loc by A32,SCMFSA_2:95
      .= IC Exec(I,s2) by A32,SCMFSA_2:95;
    hence thesis by A34,A33,Th28;
  end;
  suppose
    InsCode I = 7;
    then consider
    loc being Element of NAT, da being Int-Location
    such that
A35: I = da=0_goto loc by SCMFSA_2:60;
A36: now
      per cases;
      suppose
A37:    s1.da = 0;
        then
A38:    s2.da = 0 by A1,Th30;
        thus IC Exec(I,s1) = loc by A35,A37,SCMFSA_2:96
          .= IC Exec(I,s2) by A35,A38,SCMFSA_2:96;
      end;
      suppose
A39:    s1.da <> 0;
        then
A40:    s2.da <> 0 by A1,Th30;
        thus IC Exec(I,s1) = succ IC s1 by A35,A39,SCMFSA_2:96
          .= succ IC s2 by A1,COMPOS_1:24
          .= IC Exec(I,s2) by A35,A40,SCMFSA_2:96;
      end;
    end;
A41: now
      let f be FinSeq-Location;
      thus Exec(I,s1).f = s1.f by A35,SCMFSA_2:96
        .= s2.f by A1,Th31
        .= Exec(I,s2).f by A35,SCMFSA_2:96;
    end;
    now
      let c be Int-Location;
      thus Exec(I,s1).c = s1.c by A35,SCMFSA_2:96
        .= s2.c by A1,Th30
        .= Exec(I,s2).c by A35,SCMFSA_2:96;
    end;
    hence thesis by A41,A36,Th28;
  end;
  suppose
    InsCode I = 8;
    then consider
    loc being Element of NAT, da being Int-Location
    such that
A42: I = da>0_goto loc by SCMFSA_2:61;
A43: now
      per cases;
      suppose
A44:    s1.da > 0;
        then
A45:    s2.da > 0 by A1,Th30;
        thus IC Exec(I,s1) = loc by A42,A44,SCMFSA_2:97
          .= IC Exec(I,s2) by A42,A45,SCMFSA_2:97;
      end;
      suppose
A46:    s1.da <= 0;
        then
A47:    s2.da <= 0 by A1,Th30;
        thus IC Exec(I,s1) = succ IC s1 by A42,A46,SCMFSA_2:97
          .= succ IC s2 by A1,COMPOS_1:24
          .= IC Exec(I,s2) by A42,A47,SCMFSA_2:97;
      end;
    end;
A48: now
      let f be FinSeq-Location;
      thus Exec(I,s1).f = s1.f by A42,SCMFSA_2:97
        .= s2.f by A1,Th31
        .= Exec(I,s2).f by A42,SCMFSA_2:97;
    end;
    now
      let c be Int-Location;
      thus Exec(I,s1).c = s1.c by A42,SCMFSA_2:97
        .= s2.c by A1,Th30
        .= Exec(I,s2).c by A42,SCMFSA_2:97;
    end;
    hence thesis by A48,A43,Th28;
  end;
  suppose
    InsCode I = 9;
    then consider db, da being Int-Location, f being FinSeq-Location such that
A49: I = da := (f,db) by SCMFSA_2:62;
A50: now
      let c be Int-Location;
      per cases;
      suppose
A51:    c = da;
        then consider n being Element of NAT such that
A52:    n = abs(s2.db) and
A53:    Exec(da:=(f,db), s2).c = (s2.f)/.n by SCMFSA_2:98;
        consider m being Element of NAT such that
A54:    m = abs(s1.db) and
A55:    Exec(da:=(f,db), s1).c = (s1.f)/.m by A51,SCMFSA_2:98;
        m = n by A1,A54,A52,Th30;
        hence Exec(I,s1).c = Exec(I,s2).c by A1,A49,A55,A53,Th31;
      end;
      suppose
A56:    c <> da;
        hence Exec(I,s1).c = s1.c by A49,SCMFSA_2:98
          .= s2.c by A1,Th30
          .= Exec(I,s2).c by A49,A56,SCMFSA_2:98;
      end;
    end;
A57: now
      let f be FinSeq-Location;
      thus Exec(I,s1).f = s1.f by A49,SCMFSA_2:98
        .= s2.f by A1,Th31
        .= Exec(I,s2).f by A49,SCMFSA_2:98;
    end;
    IC Exec(I,s1) = succ IC s1 by A49,SCMFSA_2:98
      .= succ IC s2 by A1,COMPOS_1:24
      .= IC Exec(I,s2) by A49,SCMFSA_2:98;
    hence thesis by A50,A57,Th28;
  end;
  suppose
    InsCode I = 10;
    then consider db, da being Int-Location, f being FinSeq-Location such that
A58: I = (f,db):=da by SCMFSA_2:63;
A59: now
      let g be FinSeq-Location;
      per cases;
      suppose
A60:    g=f;
A61:    s1.da = s2.da by A1,Th30;
        consider n being Element of NAT such that
A62:    n = abs(s2.db) and
A63:    Exec((f,db):=da, s2).f = s2.f+*(n,s2.da) by SCMFSA_2:99;
        consider m being Element of NAT such that
A64:    m = abs(s1.db) and
A65:    Exec((f,db):=da, s1).f = s1.f+*(m,s1.da) by SCMFSA_2:99;
        m = n by A1,A64,A62,Th30;
        hence Exec(I,s1).g = Exec(I,s2).g by A1,A58,A60,A65,A63,A61,Th31;
      end;
      suppose
A66:    g<>f;
        hence Exec(I,s1).g = s1.g by A58,SCMFSA_2:99
          .= s2.g by A1,Th31
          .= Exec(I,s2).g by A58,A66,SCMFSA_2:99;
      end;
    end;
A67: now
      let c be Int-Location;
      thus Exec(I,s1).c = s1.c by A58,SCMFSA_2:99
        .= s2.c by A1,Th30
        .= Exec(I,s2).c by A58,SCMFSA_2:99;
    end;
    IC Exec(I,s1) = succ IC s1 by A58,SCMFSA_2:99
      .= succ IC s2 by A1,COMPOS_1:24
      .= IC Exec(I,s2) by A58,SCMFSA_2:99;
    hence thesis by A67,A59,Th28;
  end;
  suppose
    InsCode I = 11;
    then consider da being Int-Location, f being FinSeq-Location such that
A68: I = da :=len f by SCMFSA_2:64;
A69: now
      let c be Int-Location;
      per cases;
      suppose
A70:    c = da;
        hence Exec(I,s1).c = len(s1.f) by A68,SCMFSA_2:100
          .= len(s2.f) by A1,Th31
          .= Exec(I,s2).c by A68,A70,SCMFSA_2:100;
      end;
      suppose
A71:    c <> da;
        hence Exec(I,s1).c = s1.c by A68,SCMFSA_2:100
          .= s2.c by A1,Th30
          .= Exec(I,s2).c by A68,A71,SCMFSA_2:100;
      end;
    end;
A72: now
      let f be FinSeq-Location;
      thus Exec(I,s1).f = s1.f by A68,SCMFSA_2:100
        .= s2.f by A1,Th31
        .= Exec(I,s2).f by A68,SCMFSA_2:100;
    end;
    IC Exec(I,s1) = succ IC s1 by A68,SCMFSA_2:100
      .= succ IC s2 by A1,COMPOS_1:24
      .= IC Exec(I,s2) by A68,SCMFSA_2:100;
    hence thesis by A69,A72,Th28;
  end;
  suppose
    InsCode I = 12;
    then consider da being Int-Location, f being FinSeq-Location such that
A73: I = f:=<0,...,0>da by SCMFSA_2:65;
A74: now
      let g be FinSeq-Location;
      per cases;
      suppose
A75:    g = f;
        (ex m being Element of NAT st m = abs(s1.da) &
        Exec(f:=<0,...,0>da, s1).f = m |-> 0 )
        & ex n being Element of NAT st n = abs(s2.da) &
        Exec(f:=<0,...,0>da, s2).f = n |-> 0 by SCMFSA_2:101;
        hence Exec(I,s1).g = Exec(I,s2).g by A1,A73,A75,Th30;
      end;
      suppose
A76:    g <> f;
        hence Exec(I,s1).g = s1.g by A73,SCMFSA_2:101
          .= s2.g by A1,Th31
          .= Exec(I,s2).g by A73,A76,SCMFSA_2:101;
      end;
    end;
A77: now
      let c be Int-Location;
      thus Exec(I,s1).c = s1.c by A73,SCMFSA_2:101
        .= s2.c by A1,Th30
        .= Exec(I,s2).c by A73,SCMFSA_2:101;
    end;
    IC Exec(I,s1) = succ IC s1 by A73,SCMFSA_2:101
      .= succ IC s2 by A1,COMPOS_1:24
      .= IC Exec(I,s2) by A73,SCMFSA_2:101;
    hence thesis by A77,A74,Th28;
  end;
  end;
end;
