:: The Construction and Computation of For-loop Programs for SCMPDS
::  by JingChao Chen and Piotr Rudnicki
::
:: Received December 27, 1999
:: Copyright (c) 1999 Association of Mizar Users

environ

 vocabularies AMI_3, SCMPDS_2, AMI_1, INT_1, SCMPDS_4, AMI_2, SCMPDS_3,
      ARYTM_1, ABSVALUE, AMI_5, RELAT_1, BOOLE, FUNCT_1, RELOC, SCMFSA6A,
      FUNCT_4, CAT_1, CARD_1, SCMFSA_7, FUNCT_7, UNIALG_2, SCMFSA7B, SCM_1,
      SCMFSA6B, SCMPDS_5, SFMASTR3, SEMI_AF1, SCMP_GCD, FINSEQ_1, RLVECT_1,
      MATRIX_2, SCMPDS_7, ARYTM, AMISTD_2;
 notations TARSKI, XBOOLE_0, ENUMSET1, SUBSET_1, CARD_1, NUMBERS, XCMPLX_0,
      XXREAL_0, COMPLEX1, RELAT_1, FUNCT_1, FUNCT_4, INT_1, NAT_1, FUNCOP_1,
      STRUCT_0, AMI_1, SCMNORM, AMI_2, AMI_3, FUNCT_7, SCMPDS_2, SCMPDS_3,
      SCMPDS_4, SCMPDS_5, SCMPDS_6, SCMP_GCD, FINSEQ_1, WSIERP_1;
 constructors ENUMSET1, XXREAL_0, REAL_1, NAT_1, INT_2, WSIERP_1, SCM_1,
      SCMPDS_4, SCMPDS_5, SCMPDS_6, SCMP_GCD, SEQ_1, SCMNORM, SCMPDS_3;
 registrations SETFAM_1, FUNCT_1, ORDINAL1, RELSET_1, FUNCOP_1, FRAENKEL,
      NUMBERS, XXREAL_0, XREAL_0, NAT_1, INT_1, CARD_3, SCMPDS_2, SCMPDS_3,
      SCMPDS_4, SCMPDS_5, XBOOLE_0, VALUED_0, MEMBERED, SCMNORM;
 requirements REAL, NUMERALS, SUBSET, BOOLE, ARITHM;
 definitions FUNCOP_1, AMI_1, AMI_3, SCMPDS_2, SCMP_GCD, SCMPDS_4, SCMPDS_3,
      SCMNORM;
 theorems AMI_1, AMI_3, NAT_1, REAL_1, FUNCOP_1, TARSKI, FUNCT_4, FUNCT_1,
      INT_1, SCMPDS_2, FUNCT_7, SCMPDS_3, ABSVALUE, GRFUNC_1, SCMPDS_4,
      SCMPDS_5, SCMPDS_6, ENUMSET1, SCMP_GCD, LATTICE2, WSIERP_1, FINSEQ_1,
      RVSUM_1, RELAT_1, FINSEQ_3, XBOOLE_0, XBOOLE_1, XREAL_1, ORDINAL1,
      XXREAL_0, AMI_2, ZFMISC_1, FINSEQ_2, VALUED_1, SCMNORM, CARD_3;
 schemes NAT_1;

begin :: Preliminaries

reserve x for set,
  m,n for Element of NAT,
  a,b for Int_position,
  i,j,k for Instruction of SCMPDS,
  s,s1,s2 for State of SCMPDS,
  k1,k2 for Integer,
  loc,l for Instruction-Location of SCMPDS,
  I,J,K for Program of SCMPDS;
set A = NAT;
set D = SCM-Data-Loc;

theorem Th1:  ::SCMPDS_6:23
  for s being State of SCMPDS,m,n being Element of NAT st IC s=inspos m
  holds ICplusConst(s,n-m)=inspos n
proof
  let s be State of SCMPDS,m,n be Element of NAT;
  assume
A1: IC s=inspos m;
  consider k be Element of NAT such that
A2: k = IC s & ICplusConst(s,n-m) = abs(k+(n-m)) by SCMPDS_2:def 20;
  k=il.m by A1,A2
    .=m;
  hence ICplusConst(s,n-m) =il.n by A2,ABSVALUE:def 1
    .=inspos n;
end;

canceled 2;

theorem Th4: ::S8C_Th14
  IC s = inspos 0 implies Initialized s = s
proof
  assume
A1: IC s = inspos 0;
A2: IC SCMPDS in dom s by AMI_1:94;
  thus Initialized s = s +* (IC SCMPDS .--> inspos 0) by SCMPDS_5:def 4
    .= s by A1,A2,FUNCT_7:111;
end;

theorem Th5:
  IC s = inspos 0 implies s +* Initialized I = s +* I
proof
  set SA0=Start-At inspos 0;
  assume
A1: IC s = inspos 0;
A2: dom I misses dom SA0 by SCMPDS_4:54;
  Initialized s = s by A1,Th4;
  hence s +* I =s +* SA0 +* I by SCMPDS_5:def 4
    .= s +* (SA0 +* I) by FUNCT_4:15
    .= s +* Initialized I by A2,FUNCT_4:36;
end;

theorem Th6:
  Computation(s,n) | NAT = s | NAT
proof
  for x be Instruction-Location of SCMPDS holds
  Computation(s,n).x=s.x by AMI_1:54;
  hence Computation(s,n) | A = s | A by SCMPDS_4:21;
end;

theorem Th7:
  for s1,s2 being State of SCMPDS st
  IC s1= IC s2 & DataPart s1 = DataPart s2 & s1 | NAT = s2 | NAT
  holds s1=s2
proof
  let s1,s2 be State of SCMPDS;
  assume
A1: IC s1= IC s2 & DataPart s1 = DataPart s2 & s1 | A = s2 | A;
A2: dom s1 ={IC SCMPDS} \/ D \/ A by SCMPDS_4:19;
A3: dom s2 ={IC SCMPDS} \/ D \/ A by SCMPDS_4:19;
  then s1|{IC SCMPDS} = s2|{IC SCMPDS} by A1,A2,GRFUNC_1:90;
  then s1|({IC SCMPDS} \/ D) = s2| ({IC SCMPDS} \/ D)
   by A1,RELAT_1:185,SCMPDS_2:100;
  then s1|({IC SCMPDS} \/ D \/ A) = s2| ({IC SCMPDS} \/ D \/
  A) by A1,RELAT_1:185;
  hence s1=s2 | dom s2 by A2,A3,RELAT_1:97
    .=s2 by RELAT_1:97;
end;

theorem Th8: ::S8C_Th20
  for l being Nat holds l in dom I iff l in dom Initialized I
proof let l be Nat;
A1: (Initialized I) | A = I by SCMPDS_4:16;
A2: dom ((Initialized I) | NAT) c= dom Initialized I by RELAT_1:89;
A3: dom ((Initialized I) | A) = dom Initialized I /\ A by RELAT_1:90;
  thus l in dom I implies l in dom Initialized I by A1,A2;
A4: l in NAT by ORDINAL1:def 13;
  assume l in dom Initialized I;
  hence l in dom I by A1,A3,A4,XBOOLE_0:def 3;
end;

theorem  :: S8C_Th26
  x in dom I implies I.x = (s +* (I +* Start-At l)).x
proof
  assume
A1: x in dom I;
  dom I c= NAT by AMI_1:def 40;
  then reconsider y = x as Instruction-Location of SCMPDS by A1,AMI_1:def 4;
A2: not y in dom Start-At l by AMI_1:137;
  x in dom (I +* Start-At l) by A1,FUNCT_4:13;
  hence (s +* (I +* Start-At l)).x = (I +* Start-At l).x by FUNCT_4:14
    .= I.x by A2,FUNCT_4:12;
end;

theorem Th10:
  loc in dom I implies (s +* Initialized I).loc = I.loc
proof
  assume
A1: loc in dom I;
  set II = Initialized I;
A2: I c= II by SCMPDS_4:9;
  then dom I c= dom II by GRFUNC_1:8;
  hence (s +* II).loc = II.loc by A1,FUNCT_4:14
    .=I.loc by A1,A2,GRFUNC_1:8;
end;

theorem  :: S8C_TH28,SCMPDS_5:19,40
  (s +* (I +* Start-At l)).a = s.a
proof
  a in dom s & not a in dom (I +* Start-At l) by SCMPDS_2:49,SCMPDS_4:61;
  hence (s +* (I +* Start-At l)).a = s.a by FUNCT_4:12;
end;

theorem Th12:
  (s +* Start-At loc).IC SCMPDS = loc
proof thus
  (s +* Start-At loc).IC SCMPDS=IC (s +* Start-At loc)
    .=loc by AMI_1:111;
end;

canceled;

theorem
  (I ';' i ';' j).inspos card I =i by SCMP_GCD:11;

theorem Th15:
  i ';' I ';' j ';' k = i ';' (I ';' j ';' k)
proof
  thus i ';' I ';' j ';' k = i ';' (I ';' j) ';' k by SCMPDS_4:51
    .= i ';' (I ';' j ';' k) by SCMPDS_4:51;
end;

theorem Th16:
  Shift(J,card I) c= I ';' J ';' K
proof
  set IJ= I ';' J;
A1: Shift(J, card I) c= IJ by FUNCT_4:26;
  dom IJ misses dom Shift(K, card IJ) by SCMPDS_4:2;
  then IJ c= IJ ';' K by FUNCT_4:33;
  hence thesis by A1,XBOOLE_1:1;
end;

theorem Th17:
  I c= stop (I ';' J)
proof
  stop (I ';' J) =I ';' (J ';' Stop SCMPDS) by SCMPDS_4:46;
  hence I c= stop (I ';' J) by SCMPDS_4:40;
end;

theorem Th18:
  loc in dom I implies Shift(stop I,n).(loc+n)=Shift(I,n).(loc+n)
proof
  assume
A1: loc in dom I;
A2: dom I c= dom (stop I) by SCMPDS_4:39;
   reconsider l = loc as Element of NAT by ORDINAL1:def 13;
  thus Shift(I,n).(loc+n)=I.l by A1,VALUED_1:def 12
    .=(stop I).l by A1,SCMPDS_4:37
    .=Shift(stop I,n).(loc+n) by A1,A2,VALUED_1:def 12;
end;

theorem Th19:
  card I > 0 implies Shift(stop I,n).inspos n=Shift(I,n).inspos n
proof
  assume card I > 0;
  then
A1: inspos 0 in dom I by SCMPDS_4:1;
  thus Shift(stop I,n).inspos n=Shift(stop I,n).inspos(0+n)
    .=Shift(stop I,n).(inspos 0 +n)
    .=Shift(I,n).(inspos 0 +n) by A1,Th18
    .=Shift(I,n).inspos (0+n)
    .=Shift(I,n).inspos n;
end;

theorem  ::S8C_Th32
  for s being State of SCMPDS, i being Instruction of SCMPDS st
  InsCode i in {0,4,5,6} holds DataPart Exec(i,s) = DataPart s
proof
  let s be State of SCMPDS,i be Instruction of SCMPDS;
  assume
A1: InsCode i in {0,4,5,6};
  now
    let a be Int_position;
    per cases by A1,ENUMSET1:def 2;
    suppose InsCode i = 0;
      then ex k1 st i = goto k1 by SCMPDS_2:35;
      hence Exec(i,s).a = s.a by SCMPDS_2:66;
    end;
    suppose InsCode i = 4;
      then ex b,k1,k2 st i = (b,k1)<>0_goto k2 by SCMPDS_2:39;
      hence Exec(i,s).a = s.a by SCMPDS_2:67;
    end;
    suppose InsCode i = 5;
      then ex b,k1,k2 st i = (b,k1)<=0_goto k2 by SCMPDS_2:40;
      hence Exec(i,s).a = s.a by SCMPDS_2:68;
    end;
    suppose InsCode i = 6;
      then ex b,k1,k2 st i = (b,k1)>=0_goto k2 by SCMPDS_2:41;
      hence Exec(i,s).a = s.a by SCMPDS_2:69;
    end;
  end;
  hence thesis by SCMPDS_4:23;
end;

theorem
  for s,ss being State of SCMPDS
   holds (s +* ss | NAT) | SCM-Data-Loc = DataPart s
proof
  let s,ss be State of SCMPDS;
  dom (ss | A) = A by SCMPDS_6:1;
  hence thesis by AMI_2:29,FUNCT_4:76,SCMPDS_2:100;
end;

theorem  ::S8C_Th41
  for i being Instruction of SCMPDS holds rng Load i = {i} by FUNCOP_1:14;

theorem Th23:   ::SCMPDS_4:15
  IC s1 = IC s2 & DataPart s1 = DataPart s2 implies
  IC Exec(i,s1)=IC Exec(i,s2) &
  DataPart Exec(i,s1) = DataPart Exec(i,s2)
proof
  assume IC s1 = IC s2 & DataPart s1 = DataPart s2;
  then s1,s2 equal_outside A by SCMPDS_6:4;
  then Exec(i,s1),Exec(i,s2) equal_outside A by SCMPDS_4:15;
  hence thesis by SCMPDS_6:4;
end;

theorem Th24: ::S8C_43
  for s1,s2 being State of SCMPDS,I being Program of SCMPDS
  st I is_closed_on s1 &
  Initialized stop I c= s1 & Initialized stop I c= s2 &
  DataPart s1 = DataPart s2 for i being Element of NAT holds
  IC Computation(s1,i) = IC Computation(s2,i) &
  CurInstr Computation(s1,i) = CurInstr Computation(s2,i) &
  DataPart Computation(s1,i) = DataPart Computation(s2,i)
proof
  let s1,s2 be State of SCMPDS,I be Program of SCMPDS;
  set pI=stop I, IsI = Initialized pI;
  assume
A1: I is_closed_on s1 & IsI c= s1 & IsI c= s2 & DataPart s1 = DataPart s2;
  then
A2: s1=s1 +* IsI by FUNCT_4:79;
  defpred P[Element of NAT] means
  IC Computation(s1,$1) = IC Computation(s2,$1) &
  CurInstr (Computation(s1,$1)) = CurInstr (Computation(s2,$1)) &
  DataPart Computation(s1,$1) = DataPart Computation(s2,$1);
  pI c= IsI by SCMPDS_4:9;
  then
A3: dom pI c= dom IsI by GRFUNC_1:8;
  IC Computation(s1,0) in dom pI by A1,A2,SCMPDS_6:def 2;
  then
A4: IC s1 in dom pI by AMI_1:13;
A5: P[0]
  proof
A6: IC SCMPDS in dom IsI by SCMPDS_4:7;
    then
A7: IC s1 = IsI.IC SCMPDS by A1,GRFUNC_1:8
      .= IC s2 by A1,A6,GRFUNC_1:8;
    thus IC Computation(s1,0) =IC s1 by AMI_1:13
      .=IC Computation(s2,0) by A7,AMI_1:13;
A8: s1.IC s1 = IsI.IC s1 by A1,A3,A4,GRFUNC_1:8
      .= s2.IC s2 by A1,A3,A4,A7,GRFUNC_1:8;
    thus CurInstr (Computation(s1,0)) = CurInstr s1 by AMI_1:13
      .= CurInstr s2 by A8
      .= CurInstr (Computation(s2,0)) by AMI_1:13;
    thus DataPart Computation(s1,0) = DataPart s2 by A1,AMI_1:13
      .= DataPart Computation(s2,0) by AMI_1:13;
  end;
A9: for k being Element of NAT st P[k] holds P[k + 1]
  proof
    let k be Element of NAT;
    assume
A10: P[k];
    set i = CurInstr Computation(s1,k);
A11: Computation(s1,k+1) = Following Computation(s1,k) by AMI_1:14
      .= Exec(i,Computation(s1,k));
A12: Computation(s2,k+1) = Following Computation(s2,k) by AMI_1:14
      .= Exec(i,Computation(s2,k)) by A10;
    hence IC Computation(s1,k+1) = IC Computation(s2,k+1) by A10,A11,Th23;
A13: IC Computation(s1,k+1) in dom pI by A1,A2,SCMPDS_6:def 2;
    set l = IC Computation(s1,k+1);
    thus CurInstr Computation(s1,k+1) = s1.l by AMI_1:54
      .= IsI.l by A1,A3,A13,GRFUNC_1:8
      .= s2.l by A1,A3,A13,GRFUNC_1:8
      .= Computation(s2,k+1).l by AMI_1:54
      .=CurInstr Computation(s2,k+1) by A10,A11,A12,Th23;
    thus DataPart Computation(s1,k+1) = DataPart Computation(s2,k+1)
     by A10,A11,A12,Th23;
  end;
  thus for k being Element of NAT holds P[k] from NAT_1:sch 1(A5,A9);
end;

theorem Th25: ::S8C:100
  for s1,s2 being State of SCMPDS,I being Program of SCMPDS
  st I is_closed_on s1 &
  DataPart s1 = DataPart s2 holds for k being Element of NAT holds
  Computation(s1+*Initialized stop I,k),
  Computation(s2+*Initialized stop I,k) equal_outside NAT &
  CurInstr Computation(s1+*Initialized stop I,k) =
  CurInstr Computation(s2+*Initialized stop I,k)
proof
  let s1,s2 be State of SCMPDS,I be Program of SCMPDS;
  assume
A1: I is_closed_on s1;
  assume
A2: DataPart s1 = DataPart s2;
  set pI = stop I, IsI = Initialized stop I;
  set ss1 = s1 +* IsI;
  set ss2 = s2 +* IsI;
A3: pI c= IsI by SCMPDS_4:9;
  IsI c= ss1 by FUNCT_4:26;
  then
A4: pI c= ss1 by A3,XBOOLE_1:1;
  IsI c= ss2 by FUNCT_4:26;
  then
A5: pI c= ss2 by A3,XBOOLE_1:1;
  hereby
    let k be Element of NAT;
A6: ss1,ss2 equal_outside A by A2,SCMPDS_6:12;
A7: I is_closed_on s2 by A1,A2,SCMPDS_6:36;
    then for m st m < k holds IC Computation(ss2,m) in dom pI by
    SCMPDS_6:def 2;
    hence Computation(ss1,k),Computation(ss2,k) equal_outside A
    by A4,A5,A6,SCMPDS_4:67;
    then
A8: IC Computation(ss1,k) = IC Computation(ss2,k) by AMI_1:121;
A9: IC Computation(ss1,k) in dom pI by A1,SCMPDS_6:def 2;
A10: IC Computation(ss2,k) in dom pI by A7,SCMPDS_6:def 2;
    thus CurInstr Computation(ss2,k) = ss2.IC Computation(ss2,k) by AMI_1:54
      .= pI.IC Computation(ss2,k) by A5,A10,GRFUNC_1:8
      .= ss1.IC Computation(ss1,k) by A4,A8,A9,GRFUNC_1:8
      .= CurInstr Computation(ss1,k) by AMI_1:54;
  end;
end;

theorem Th26: ::SCMPDS_5:20
  for I being Program of SCMPDS st I is_closed_on s1 &
  Initialized stop I c= s1 & Initialized stop I c= s2 &
  s1,s2 equal_outside NAT holds for k being Element of NAT holds
  Computation(s1,k), Computation(s2,k) equal_outside NAT &
  CurInstr Computation(s1,k) = CurInstr Computation(s2,k)
proof
  let I be Program of SCMPDS;
  set iI=Initialized stop I;
  assume that
A1: I is_closed_on s1 and
A2: iI c= s1 and
A3: iI c= s2 and
A4: s1,s2 equal_outside A;
A5: s1=s1 +* iI by A2,FUNCT_4:79;
A6: s2=s2 +* iI by A3,FUNCT_4:79;
  DataPart s1 = DataPart s2 by A4,SCMPDS_6:4;
  hence thesis by A1,A5,A6,Th25;
end;

theorem  ::S8C:41,SCMPDS_5:21  ???
  for s1,s2 being State of SCMPDS,I being Program of SCMPDS st
  I is_closed_on s1 & I is_halting_on s1 &
  Initialized stop I c= s1 & Initialized stop I c= s2 &
  DataPart s1 = DataPart s2 holds LifeSpan s1 = LifeSpan s2
proof
  let s1,s2 be State of SCMPDS,I be Program of SCMPDS;
  set IsI = Initialized stop I;
  assume
A1: I is_closed_on s1 & I is_halting_on s1 &
  IsI c= s1 & IsI c= s2 & DataPart s1 = DataPart s2;
  then s1 = s1 +* IsI by FUNCT_4:79;
  then
A2: s1 is halting by A1,SCMPDS_6:def 3;
  then CurInstr Computation(s1,LifeSpan s1) = halt SCMPDS &
  for k being Element of NAT st CurInstr Computation(s1,k) = halt SCMPDS
  holds LifeSpan s1 <= k by AMI_1:def 46;
  then
A3: CurInstr Computation(s2,LifeSpan s1) = halt SCMPDS by A1,Th24;
  then
A4: s2 is halting by AMI_1:def 20;
  now
    let k be Element of NAT;
    assume CurInstr Computation(s2,k) = halt SCMPDS;
    then CurInstr Computation(s1,k) = halt SCMPDS by A1,Th24;
    hence LifeSpan s1 <= k by A2,AMI_1:def 46;
  end;
  hence LifeSpan s1 = LifeSpan s2 by A3,A4,AMI_1:def 46;
end;

theorem Th28: ::SCMPDS_5:21
  for I being Program of SCMPDS st I is_closed_on s1 & I is_halting_on s1 &
  Initialized stop I c= s1 & Initialized stop I c= s2 &
  s1,s2 equal_outside NAT holds LifeSpan s1 = LifeSpan s2 &
  Result s1, Result s2 equal_outside NAT
proof
  let I be Program of SCMPDS;
  set iI=Initialized stop I;
  assume that
A1: I is_closed_on s1 & I is_halting_on s1 and
A2: iI c= s1 and
A3: iI c= s2 and
A4: s1,s2 equal_outside A;
  s1=s1 +* iI by A2,FUNCT_4:79;
  then
A5: s1 is halting by A1,SCMPDS_6:def 3;
A6: now
    let l be Element of NAT;
    assume
A7: CurInstr Computation(s2,l) = halt SCMPDS;
    CurInstr Computation(s1,l) = CurInstr Computation(s2,l)
    by A1,A2,A3,A4,Th26;
    hence LifeSpan s1 <= l by A5,A7,AMI_1:def 46;
  end;
A8: CurInstr Computation(s2,LifeSpan s1)
  = CurInstr Computation(s1,LifeSpan s1) by A1,A2,A3,A4,Th26
    .= halt SCMPDS by A5,AMI_1:def 46;
A9: s2=s2 +* iI by A3,FUNCT_4:79;
  DataPart s1 = DataPart s2 by A4,SCMPDS_6:4;
  then I is_halting_on s2 by A1,SCMPDS_6:37;
  then
A10: s2 is halting by A9,SCMPDS_6:def 3;
  hence LifeSpan s1 = LifeSpan s2 by A6,A8,AMI_1:def 46;
  then
A11: Result s2 = Computation(s2,LifeSpan s1) by A10,AMI_1:122;
  Result s1 = Computation(s1,LifeSpan s1) by A5,AMI_1:122;
  hence Result s1, Result s2 equal_outside A by A1,A2,A3,A4,A11,Th26;
end;

theorem Th29: ::S8C_: 101
  for s1,s2 being State of SCMPDS,I being Program of SCMPDS
  st I is_closed_on s1 & I is_halting_on s1 &
  DataPart s1 = DataPart s2 holds
  LifeSpan (s1 +* Initialized stop I) = LifeSpan (s2 +* Initialized stop I) &
  Result (s1 +* Initialized stop I),Result (s2 +* Initialized stop I)
  equal_outside NAT
proof
  let s1,s2 be State of SCMPDS,I be Program of SCMPDS;
  assume
A1: I is_closed_on s1;
  assume
A2: I is_halting_on s1;
  assume
A3: DataPart s1 = DataPart s2;
  set IsI = Initialized stop I;
  set ss1 = s1 +* IsI;
  set ss2 = s2 +* IsI;
A4: ss1 is halting by A2,SCMPDS_6:def 3;
A5: now
    let l be Element of NAT;
    assume
A6: CurInstr Computation(ss2,l) = halt SCMPDS;
    CurInstr Computation(ss1,l) = CurInstr Computation(ss2,l) by A1,A3,Th25;
    hence LifeSpan ss1 <= l by A4,A6,AMI_1:def 46;
  end;
A7: CurInstr Computation(ss2,LifeSpan ss1)
  = CurInstr Computation(ss1,LifeSpan ss1) by A1,A3,Th25
    .= halt SCMPDS by A4,AMI_1:def 46;
  I is_halting_on s2 by A1,A2,A3,SCMPDS_6:37;
  then
A8: ss2 is halting by SCMPDS_6:def 3;
  hence LifeSpan ss1 = LifeSpan ss2 by A5,A7,AMI_1:def 46;
  then
A9: Result ss2 = Computation(ss2,LifeSpan ss1) by A8,AMI_1:122;
  Result ss1 = Computation(ss1,LifeSpan ss1) by A4,AMI_1:122;
  hence Result ss1, Result ss2 equal_outside NAT by A1,A3,A9,Th25;
end;

theorem  ::S8C:103
  for s1,s2 being State of SCMPDS,I being Program of SCMPDS
  st I is_closed_on s1 & I is_halting_on s1 &
  Initialized stop I c= s1 & Initialized stop I c= s2 &
  ex k being Element of NAT st Computation(s1,k),s2 equal_outside NAT holds
  Result s1,Result s2 equal_outside NAT
proof
  let s1,s2 be State of SCMPDS,I be Program of SCMPDS;
  set pI =stop I, IsI=Initialized pI;
  assume
A1: I is_closed_on s1;
  assume
A2: I is_halting_on s1;
  assume
A3: IsI c= s1;
  assume
A4: IsI c= s2;
  given k being Element of NAT such that
A5: Computation(s1,k),s2 equal_outside A;
  set s3 = Computation(s1,k);
A6: s2 = s2 +* IsI by A4,FUNCT_4:79;
  then IC s3 = IC (s2 +* IsI) by A5,AMI_1:121
    .= inspos 0 by SCMPDS_6:21;
  then IC SCMPDS in dom s3 & s3.IC SCMPDS = inspos 0 by AMI_1:94;
  then
A7: IC SCMPDS .--> inspos 0 c= s3 by FUNCOP_1:88;
A8: DataPart s3 = DataPart s2 by A5,SCMPDS_6:4;
  pI c= IsI by SCMPDS_4:9;
  then pI c= s1 by A3,XBOOLE_1:1;
  then pI c= s3 by AMI_1:86;
  then pI +* Start-At inspos 0 c= s3 by A7,FUNCT_4:92;
  then
A9: s3 = s3 +* IsI by FUNCT_4:79;
A10: s1 = s1 +* IsI by A3,FUNCT_4:79;
  now
    let n be Element of NAT;
    IC Computation(s3,n) = IC Computation(s1,k+n) by AMI_1:51;
    hence IC Computation(s3,n) in dom pI by A1,A10,SCMPDS_6:def 2;
  end;
  then
A11: I is_closed_on s3 by A9,SCMPDS_6:def 2;
A12: s1 is halting by A2,A10,SCMPDS_6:def 3;
  then consider n being Element of NAT such that
A13: CurInstr Computation(s1,n) = halt SCMPDS by AMI_1:def 20;
  CurInstr Computation(s3,n) = CurInstr Computation(s1,k+n) by AMI_1:51
    .= CurInstr Computation(s1,n) by A13,AMI_1:52,NAT_1:11;
  then s3 is halting by A13,AMI_1:def 20;
  then I is_halting_on s3 by A9,SCMPDS_6:def 3;
  then
A14: Result s3,Result s2 equal_outside A by A6,A8,A9,A11,Th29;
  consider k being Element of NAT such that
A15: CurInstr Computation(s1,k) = halt SCMPDS by A12,AMI_1:def 20;
  s1.IC Computation(s1,k) = halt SCMPDS by AMI_1:54,A15;
  hence Result s1,Result s2 equal_outside A by A14,AMI_1:57;
end;

registration
  let I be Program of SCMPDS;
  cluster Initialized I -> initial;
  correctness
  proof
    now
      let m,n be Nat;
      assume n in dom Initialized I;
      then
A1:   n in dom I by Th8;
      I c= Initialized I by SCMPDS_4:9;
      then
A2:   dom I c= dom Initialized I by GRFUNC_1:8;
      assume m < n;
      then m in dom I by A1,SCMNORM:def 1;
      hence m in dom Initialized I by A2;
    end;
    hence thesis by SCMNORM:def 1;
  end;
end;

theorem Th31: ::S8C_:87
  for s being State of SCMPDS,I being Program of SCMPDS,
  a being Int_position st
  I is_halting_on s holds
  IExec(I,s).a = Computation(s +* Initialized stop I,
  (LifeSpan (s +* Initialized stop I))).a
proof
  let s be State of SCMPDS,I be Program of SCMPDS, a be Int_position;
  set s1 = s +* Initialized stop I;
  assume I is_halting_on s;
  then
A1: s1 is halting by SCMPDS_6:def 3;
A2: dom (s | A)=A by SCMPDS_6:1;
  now
    assume a in dom (s | A);
    then reconsider l=a as Instruction-Location of SCMPDS by A2,AMI_1:def 4;
    l=a;
    hence contradiction by SCMPDS_2:53;
  end;
  hence IExec(I,s).a = (Result s1).a by FUNCT_4:12
    .= Computation(s1,LifeSpan s1).a by A1,AMI_1:122;
end;

theorem  ::S8C:88
  for s being State of SCMPDS,I being parahalting Program of SCMPDS,
  a being Int_position holds
  IExec(I,s).a = Computation (s +* Initialized stop I,
  (LifeSpan (s +* Initialized stop I))).a
proof
  let s be State of SCMPDS,I be parahalting Program of SCMPDS,
  a be Int_position;
  I is_halting_on s by SCMPDS_6:35;
  hence thesis by Th31;
end;

theorem Th33:
  for I being Program of SCMPDS,i being Element of NAT st
  Initialized stop I c= s & I is_closed_on s & I is_halting_on s &
  i < LifeSpan s holds IC Computation(s,i) in dom I
proof
  let I be Program of SCMPDS,i be Element of NAT;
  set sI = stop I, iI = Initialized sI, Ci = Computation(s,i), Lc = IC Ci;
  assume that
A1: iI c= s and
A2: I is_closed_on s and
A3: I is_halting_on s and
A4: i < LifeSpan s;
A5: s = s +* iI by A1,FUNCT_4:79;
  then
A6: Lc in dom sI by A2,SCMPDS_6:def 2;
  sI c= iI by SCMPDS_4:9;
  then
A7: sI c= s by A1,XBOOLE_1:1;
A8: s is halting by A3,A5,SCMPDS_6:def 3;
  now
    assume
A9: sI.Lc=halt SCMPDS;
    CurInstr Ci =s.Lc by AMI_1:54
      .=halt SCMPDS by A6,A7,A9,GRFUNC_1:8;
    hence contradiction by A4,A8,AMI_1:def 46;
  end;
  hence thesis by A6,SCMPDS_5:3;
end;

theorem Th34:  :: SP4_88
  for I being shiftable Program of SCMPDS st
  Initialized stop I c= s1 & I is_closed_on s1 & I is_halting_on s1
  for n being Element of NAT st Shift(I,n) c= s2 & card I > 0 &
  IC s2 = inspos n & DataPart s1 = DataPart s2
  for i being Element of NAT holds i < LifeSpan s1 implies
  IC Computation(s1,i) + n = IC Computation(s2,i) &
  CurInstr (Computation(s1,i)) = CurInstr (Computation(s2,i)) &
  DataPart Computation(s1,i) = DataPart Computation(s2,i)
proof
  let I be shiftable Program of SCMPDS;
  set SI=stop I, II=Initialized SI;
  assume
A1: II c= s1 & I is_closed_on s1 & I is_halting_on s1;
  let n be Element of NAT;
  assume that
A2: Shift(I,n) c= s2 and
A3: card I > 0 and
A4: IC s2 = inspos n and
A5: DataPart s1 = DataPart s2;
A6: s1=s1 +* II by A1,FUNCT_4:79;
  defpred P[Element of NAT] means $1 < LifeSpan s1 implies
  IC Computation(s1,$1) + n = IC Computation(s2,$1) &
  CurInstr (Computation(s1,$1)) = CurInstr (Computation(s2,$1)) &
  DataPart Computation(s1,$1) = DataPart Computation(s2,$1);
  dom SI misses dom Start-At inspos 0 by SCMPDS_4:54;
  then
A7: SI c= II by FUNCT_4:33;
  then
A8: dom SI c= dom II by GRFUNC_1:8;
A9: inspos 0 in dom I by A3,SCMPDS_4:1;
A10: inspos 0 in dom SI by SCMPDS_4:75;
A11: P[0]
  proof
    assume 0 < LifeSpan s1;
A12: IC SCMPDS in dom II by SCMPDS_4:7;
A13: inspos (0 + n) in dom Shift(I,n) by A9,VALUED_1:25;
    IC Computation(s1,0) = s1.IC SCMPDS by AMI_1:13
      .= II.IC SCMPDS by A1,A12,GRFUNC_1:8
      .= inspos 0 by SCMPDS_4:29;
    hence IC Computation(s1,0) + n = inspos (0 + n)
      .= IC Computation(s2,0) by A4,AMI_1:13;
A14: s1.IC s1 = s1.((II).IC SCMPDS) by A1,A12,GRFUNC_1:8
      .= s1.inspos 0 by SCMPDS_4:29
      .= II.inspos 0 by A1,A8,A10,GRFUNC_1:8
      .= SI.inspos 0 by A7,A10,GRFUNC_1:8;
    thus CurInstr (Computation(s1,0)) = CurInstr s1 by AMI_1:13
      .= Shift(SI,n).(inspos 0 + n) by A10,A14,VALUED_1:def 12
      .= Shift(SI,n).inspos (0 + n)
      .= Shift(I,n).inspos n by A3,Th19
      .= CurInstr s2 by A2,A4,A13,GRFUNC_1:8
      .= CurInstr (Computation(s2,0)) by AMI_1:13;
    thus DataPart Computation(s1,0) = DataPart s2 by A5,AMI_1:13
      .= DataPart Computation(s2,0) by AMI_1:13;
  end;
A15: for k being Element of NAT st P[k] holds P[k + 1]
  proof
    let k be Element of NAT;
    assume
A16: P[k];
    now
      assume
A17:  k+1 < LifeSpan s1;
A18:  k <= k+1 by NAT_1:11;
      set i = CurInstr Computation(s1,k);
A19:  Computation(s1,k+1) = Following Computation(s1,k) by AMI_1:14
        .= Exec(CurInstr Computation(s1,k),Computation(s1,k));
A20:  Computation(s2,k+1) = Following Computation(s2,k) by AMI_1:14
        .= Exec(CurInstr Computation(s2,k),Computation(s2,k));
A21:  IC Computation(s1,k) in dom SI by A1,A6,SCMPDS_6:def 2;
A22:  i = s1.IC Computation(s1,k) by AMI_1:54
        .= II.IC Computation(s1,k) by A1,A8,A21,GRFUNC_1:8
        .= SI.IC Computation(s1,k) by A7,A21,GRFUNC_1:8;
  reconsider m = IC Computation(s1,k) as Element of NAT by ORDINAL1:def 13;
A23:  IC Computation(s1,k) =inspos m;
A24:  InsCode i <> 1 & InsCode i <> 3 & i valid_at m
      by A21,A22,A23,SCMPDS_4:def 12;
      hence
A25:  IC Computation(s1,k+1) + n
      = IC Computation(s2,k+1)
      by A16,A17,A18,A19,A20,A23,SCMPDS_4:83,XXREAL_0:2;
      reconsider l = IC Computation(s1,k+1) as Element of NAT
      by ORDINAL1:def 13;
A26:  IC Computation(s1,k+1) in dom I by A1,A17,Th33;
A27:  IC Computation(s1,k+1) in dom SI by A1,A6,SCMPDS_6:def 2;
A28:  CurInstr Computation(s1,k+1) = s1.l by AMI_1:54
        .= II.l by A1,A8,A27,GRFUNC_1:8
        .= SI.l by A7,A27,GRFUNC_1:8;
A29:  l+n in dom Shift(I,n) by A26,VALUED_1:25;
      thus CurInstr Computation(s1,k+1) = Shift(SI,n).(l + n)
      by A27,A28,VALUED_1:def 12
        .= Shift(I,n).(IC Computation(s2,k+1)) by A25,A26,Th18
        .= s2.IC Computation(s2,k+1) by A2,A29,GRFUNC_1:8,A25
        .= CurInstr Computation(s2,k+1) by AMI_1:54;
      thus DataPart Computation(s1,k+1)
      = DataPart Computation(s2,k+1)
      by A16,A17,A18,A19,A20,A23,A24,SCMPDS_4:83
      ,XXREAL_0:2;
    end;
    hence P[k+1];
  end;
  let i be Element of NAT;
  for k being Element of NAT holds P[k] from NAT_1:sch 1(A11,A15);
  hence thesis;
end;

theorem Th35:
  for I being No-StopCode Program of SCMPDS st
  Initialized stop I c= s & I is_halting_on s & card I > 0 holds
  LifeSpan s > 0
proof
  let I be No-StopCode Program of SCMPDS;
  set II=Initialized stop I, si=s +* II;
  assume
A1: II c= s & I is_halting_on s & card I > 0;
  assume
A2: LifeSpan s <= 0;
A3: s=si by A1,FUNCT_4:79;
A4: LifeSpan s=0 by A2;
A5: si is halting by A1,SCMPDS_6:def 3;
A6: inspos 0 in dom I by A1,SCMPDS_4:1;
A7: I c= II by SCMPDS_6:17;
  then
A8: dom I c= dom II by GRFUNC_1:8;
  halt SCMPDS = CurInstr(Computation(si,0)) by A3,A4,A5,AMI_1:def 46
    .= CurInstr si by AMI_1:13
    .= s.inspos 0 by A3,SCMPDS_6:21
    .=II.inspos 0 by A1,A6,A8,GRFUNC_1:8
    .=I.inspos 0 by A6,A7,GRFUNC_1:8;
  hence contradiction by A6,SCMPDS_5:def 3;
end;

theorem Th36:
  for I being No-StopCode shiftable Program of SCMPDS st
  Initialized stop I c= s1 & I is_closed_on s1 & I is_halting_on s1
  for n being Element of NAT st Shift(I,n) c= s2 & card I > 0 &
  IC s2 = inspos n & DataPart s1 = DataPart s2 holds
  IC Computation(s2,LifeSpan s1) = inspos (card I + n) &
  DataPart Computation(s1,LifeSpan s1)
  = DataPart Computation(s2,LifeSpan s1)
proof
  let I be No-StopCode shiftable Program of SCMPDS;
  set II=Initialized stop I;
  assume
A1: II c= s1 & I is_closed_on s1 & I is_halting_on s1;
  let n be Element of NAT;
  assume that
A2: Shift(I,n) c= s2 and
A3: card I > 0 and
A4: IC s2 = inspos n and
A5: DataPart s1 = DataPart s2;
  1+0 <= LifeSpan s1 by A1,A3,Th35,INT_1:20;
  then consider i be Nat such that
A6: 1+i=LifeSpan s1 by NAT_1:10;
  reconsider i as Element of NAT by ORDINAL1:def 13;
  set i2=CurInstr Computation(s2,i);
A7: i < LifeSpan s1 by A6,XREAL_1:31;
  then
A8: IC Computation(s1,i) + n = IC Computation(s2,i) by A1,A2,A3,A4,A5,Th34;
  set L1=IC Computation(s1,i);
A9: L1 in dom I by A1,A6,Th33,XREAL_1:31;
A10: I c= II by SCMPDS_6:17;
  then
A11: dom I c= dom II by GRFUNC_1:8;
  i2=CurInstr Computation(s1,i) by A1,A2,A3,A4,A5,A7,Th34;
  then
A12: i2=s1.L1 by AMI_1:54
    .=II.L1 by A1,A9,A11,GRFUNC_1:8
    .=I.L1 by A9,A10,GRFUNC_1:8;
  reconsider m = L1 as Element of NAT by ORDINAL1:def 13;
A13: L1 =inspos m;
A14: InsCode i2 <> 1 & InsCode i2 <> 3 & i2 valid_at m
  by A9,A12,A13,SCMPDS_4:def 12;
  s1=s1 +* II by A1,FUNCT_4:79;
  then
A15: IC Computation(s1,i+1)=inspos card I by A1,A6,SCMPDS_6:43;
A16: Computation(s1,i+1) = Following Computation(s1,i) by AMI_1:14
    .= Exec(i2,Computation(s1,i)) by A1,A2,A3,A4,A5,A7,Th34;
A17: DataPart Computation(s1,i) = DataPart Computation(s2,i)
by A1,A2,A3,A4,A5,A7,Th34;
A18: Computation(s2,i+1) = Following Computation(s2,i) by AMI_1:14
    .=Exec(i2,Computation(s2,i));
  hence IC Computation(s2,LifeSpan s1) = inspos card I + n
  by A6,A8,A13,A14,A15,A16,A17,
  SCMPDS_4:83
    .= inspos (card I + n); thus
  DataPart Computation(s1,LifeSpan s1) =
   DataPart Computation(s2,LifeSpan s1) by A6
  ,A8,A13,A14,A16,A17,A18,SCMPDS_4:83;
end;

theorem Th37:
  for s being State of SCMPDS,I being Program of SCMPDS,n being Element of NAT
  st IC Computation(s+*Initialized I,n) = inspos 0
  holds Computation(s+*Initialized I,n) +* Initialized I
  =Computation(s+*Initialized I,n)
proof
  let s be State of SCMPDS,I be Program of SCMPDS,n be Element of NAT;
  set II=Initialized I, sn=Computation(s+*II,n);
  assume IC sn= inspos 0;
  then
A1: sn +* II = sn +* I by Th5;
A2: I c= I +* Start-At inspos 0 by SCMPDS_6:6;
  II c= s +* II by FUNCT_4:26;
  then I c= s +* II by A2,XBOOLE_1:1;
  then I c= sn by AMI_1:81;
  hence thesis by A1,FUNCT_4:79;
end;

theorem Th38:  ::SCMPDS_5:33
  for I being Program of SCMPDS,J being Program of SCMPDS,
  k being Element of NAT st I is_closed_on s & I is_halting_on s
  & k <= LifeSpan (s +* Initialized stop(I))
  holds Computation (s +* Initialized stop I,k),
  Computation (s +* ((I ';' J) +* Start-At inspos 0),k) equal_outside NAT
proof
  let I be Program of SCMPDS,J be Program of SCMPDS,k be Element of NAT;
  set SA0=Start-At inspos 0, spI= stop I;
  set s1 = s +* Initialized spI;
  set s2 = s +* ((I ';' J) +* SA0);
  set n=LifeSpan s1;
  assume
A1: I is_closed_on s & I is_halting_on s & k <= n;
A2: s1 =s +* spI +* SA0 by FUNCT_4:15
    .=s+*SA0+* spI by SCMPDS_4:62;
A3: s2 = s +* (I ';' J) +* SA0 by FUNCT_4:15
    .= s+*SA0+*(I ';' J) by SCMPDS_4:62;
  set IL=NAT;
A4: s +* SA0 +* spI, s +* SA0 equal_outside IL by AMI_1:120,FUNCT_7:28;
A5: s +* SA0, s +* SA0 +* (I ';' J) equal_outside IL by AMI_1:120;
  defpred X[Element of NAT] means
  $1 <= n implies Computation(s1,$1), Computation(s2,$1)
   equal_outside IL;
  Computation(s1,0) = s1 & Computation(s2,0) = s2 by AMI_1:13;
  then
A6: X[0] by A2,A3,A4,A5,FUNCT_7:29;
A7: for m being Element of NAT st X[m] holds X[m+1]
  proof
    let m be Element of NAT;
    assume
A8: m <= n implies
Computation(s1,m), Computation(s2,m) equal_outside IL;
    assume
A9: m+1 <= n;
    then
A10: m < n by NAT_1:13;
A11: Computation(s2,m+1) = Following Computation(s2,m) by AMI_1:14
      .= Exec(CurInstr Computation(s2,m),Computation(s2,m));
A12: Computation(s1,m+1) = Following Computation(s1,m) by AMI_1:14
      .= Exec(CurInstr Computation(s1,m),Computation(s1,m));
A13: IC Computation(s1,m) in dom spI by A1,SCMPDS_6:def 2;
A14: IC Computation(s1,m) in dom I by A1,A10,SCMPDS_6:40;
    then
A15: IC Computation(s1,m) in dom (I ';' J) by FUNCT_4:13;
    CurInstr Computation(s1,m) = s1.IC Computation(s1,m) by AMI_1:54
      .= spI.IC Computation(s1,m) by A2,A13,FUNCT_4:14
      .= I.IC Computation(s1,m) by A14,SCMPDS_4:37
      .= (I ';' J).IC Computation(s1,m) by A14,SCMPDS_4:37
      .= s2.IC Computation(s1,m) by A3,A15,FUNCT_4:14
      .= (Computation(s2,m)).IC Computation(s1,m) by AMI_1:54
      .=CurInstr Computation(s2,m) by A8,A9,AMI_1:121,NAT_1:13;
    hence Computation(s1,m+1),Computation(s2,m+1)
     equal_outside IL by A8,A9,A11,A12,NAT_1:13
    ,SCMPDS_4:15;
  end;
  for k being Element of NAT holds X[k] from NAT_1:sch 1(A6, A7);
  hence thesis by A1;
end;

theorem Th39:  ::SCMPDS_5:29
  for I,J being Program of SCMPDS,k be Element of NAT
  st I c= J & I is_closed_on s & I is_halting_on s &
  k <= LifeSpan (s +* Initialized stop(I)) holds
   Computation( (s +* Initialized J),k),
   Computation( (s +* Initialized stop(I)),k) equal_outside NAT
proof
  let I,J be Program of SCMPDS,k be Element of NAT;
  set IsI=Initialized stop(I), IL=NAT, m=LifeSpan (s +* IsI);
  assume that
A1: I c= J and
A2: I is_closed_on s and
A3: I is_halting_on s and
A4: k <= m;
  set iJ=Initialized J, s1 = s +* iJ, s2 = s +* IsI;
  defpred P[Element of NAT] means $1 <= m implies
  Computation(s1,$1),Computation(s2,$1) equal_outside IL;
A5: dom I c= dom J by A1,GRFUNC_1:8;
A6: P[0]
  proof
    assume 0 <= m;
A7: Computation(s1,0)=s +* iJ by AMI_1:13;
    Computation(s2,0)=s +* IsI by AMI_1:13;
    hence Computation(s1,0),Computation(s2,0)
    equal_outside IL by A7,SCMPDS_4:36;
  end;
A8: now
    let k be Element of NAT;
    assume
A9: P[k];
    now
      assume
A10:  k+1 <= m;
A11:  k < k+1 by XREAL_1:31;
      then k < m by A10,XXREAL_0:2;
      then
A12:  IC Computation(s2,k) in dom I by A2,A3,SCMPDS_6:40;
      then
A13:  IC Computation(s2,k) in dom (stop I) by FUNCT_4:13;
A14:  CurInstr Computation(s1,k) = (Computation(s1,k)).IC Computation(s2,k)
 by A9,A10,A11,AMI_1:121,XXREAL_0:2
        .= (s +* iJ).IC Computation(s2,k) by AMI_1:54
        .= J.IC Computation(s2,k) by A5,A12,Th10
        .= I.IC Computation(s2,k) by A1,A12,GRFUNC_1:8
        .= (stop I).IC Computation(s2,k) by A12,SCMPDS_4:37
        .= (s +* IsI).IC Computation(s2,k) by A13,Th10
        .= CurInstr Computation(s2,k) by AMI_1:54;
A15:  Computation(s1,k+1) = Following Computation(s1,k) by AMI_1:14
        .= Exec(CurInstr Computation(s1,k),Computation(s1,k));
      Computation(s2,k+1) = Following Computation(s2,k) by AMI_1:14
        .= Exec(CurInstr Computation(s2,k),Computation(s2,k));
      hence Computation(s1,k+1),Computation(s2,k+1)
       equal_outside IL
      by A9,A10,A11,A14,A15,SCMPDS_4:15,XXREAL_0:2;
    end;
    hence P[k+1];
  end;
  for k be Element of NAT holds P[k] from NAT_1:sch 1(A6,A8);
  hence thesis by A4;
end;

theorem Th40:
  for I,J being Program of SCMPDS,k be Element of NAT st
  k <= LifeSpan (s +* Initialized stop(I)) & I c= J
  & I is_closed_on s & I is_halting_on s
  holds IC  Computation( (s +* Initialized J),k) in dom stop I
proof
  let I,J be Program of SCMPDS,k be Element of NAT;
  set ss = s +* Initialized stop(I);
  set s1= Computation( (s +* Initialized J),k), s2= Computation( ss,k);
  assume
A1: k <= LifeSpan ss & I c= J & I is_closed_on s & I is_halting_on s;
  then IC s1 = IC s2 by Th39,AMI_1:121;
  hence IC s1 in dom stop(I) by A1,SCMPDS_6:def 2;
end;

theorem Th41:    ::SCMPDS_5:31
  for I,J being Program of SCMPDS st I c= J & I is_closed_on s &
  I is_halting_on s
  holds CurInstr  Computation( (s +* Initialized J),LifeSpan
  (s +* Initialized stop(I))) = halt SCMPDS
  or IC  Computation( (s +* Initialized J),LifeSpan
  (s +* Initialized stop(I))) = inspos card I
proof
  let I,J be Program of SCMPDS;
  set IsI=Initialized stop(I), ss = s +* IsI, m=LifeSpan ss;
  set s0=s +* Initialized J, s1= Computation( s0,m), s2= Computation( ss,m),
  Ik = IC s2;
  assume
A1: I c= J & I is_closed_on s & I is_halting_on s;
  then
A2: dom I c= dom J by GRFUNC_1:8;
A3: IsI c= ss by FUNCT_4:26;
A4: IC s1 = Ik by A1,Th39,AMI_1:121;
A5: Ik in dom stop(I) by A1,SCMPDS_6:def 2;
A6: ss is halting by A1,SCMPDS_6:def 3;
  stop I c= IsI by SCMPDS_4:9;
  then
A7: stop I c= ss by A3,XBOOLE_1:1;
  reconsider n = Ik as Element of NAT by ORDINAL1:def 13;
  card stop I = card I + 1 by SCMPDS_5:7;
  then n < card I + 1 by A5,SCMPDS_4:1;
  then
A9: n <= card I by INT_1:20;
  now per cases by A9,REAL_1:def 5;
    case n < card I;
      then
A10:  inspos n in dom I by SCMPDS_4:1;
      thus halt SCMPDS = CurInstr s2 by A6,AMI_1:def 46
        .= ss.Ik by AMI_1:54
        .= (stop I).Ik by A5,A7,GRFUNC_1:8
        .= I.Ik by A10,SCMPDS_4:37
        .= J.Ik by A1,A10,GRFUNC_1:8
        .= s0.IC s1 by A2,A4,A10,Th10
        .=CurInstr s1 by AMI_1:54;
    end;
    case n = card I;
      hence IC s1= inspos card I by A1,Th39,AMI_1:121;
    end;
  end;
  hence thesis;
end;

theorem Th42:
  for I,J being Program of SCMPDS st I is_halting_on s &
  J is_closed_on IExec(I,s) & J is_halting_on IExec(I,s) holds
  J is_closed_on  Computation( (s +* Initialized stop I),
  LifeSpan (s +* Initialized stop I)) &
  J is_halting_on  Computation( (s +* Initialized stop I),
  LifeSpan (s +* Initialized stop I))
proof
  let I,J be Program of SCMPDS;
  set s1= s +* Initialized stop I, sm = Computation(s1,LifeSpan s1),
  sE = IExec(I,s);
  assume
A1: I is_halting_on s & J is_closed_on sE & J is_halting_on sE;
A2: dom (s | A) = A by SCMPDS_6:1;
A3: s1 is halting by A1,SCMPDS_6:def 3;
  DataPart sE = DataPart Result s1 by A2,AMI_2:29,FUNCT_4:76,SCMPDS_2:100
    .= DataPart sm by A3,AMI_1:122;
  hence J is_closed_on sm & J is_halting_on sm by A1,SCMPDS_6:37;
end;

theorem Th43:
  for I being Program of SCMPDS,J being shiftable Program of SCMPDS st
  I is_closed_on s & I is_halting_on s &
  J is_closed_on IExec(I,s) & J is_halting_on IExec(I,s)
  holds (I ';'J) is_closed_on s & (I ';' J) is_halting_on s
proof
  let I be Program of SCMPDS,J be shiftable Program of SCMPDS;
  set sE=IExec(I,s);
  assume
A1: I is_closed_on s & I is_halting_on s &
  J is_closed_on sE & J is_halting_on sE;
  set IJ =I ';' J, sIJ = stop IJ, IsIJ = Initialized sIJ, spI = stop I,
  IsI = Initialized spI, ss=s +* IsIJ;
A2: ss = s +* ((I ';' (J ';' Stop SCMPDS)) +* Start-At inspos 0)
  by SCMPDS_4:46;
A3: sIJ c= ss by FUNCT_4:26,SCMPDS_4:57;
  set spJ = stop J, IsJ = Initialized spJ, s1 = s +* IsI, m1 = LifeSpan s1,
  sm =  Computation( s1,m1), s3 = sm +* IsJ, m3 = LifeSpan s3;
A4: DataPart s3 = DataPart Computation(s1,m1) +* DataPart IsJ by FUNCT_4:75;
A5: now
    let x be set;
    assume x in dom (DataPart IsJ);
    then
A6: x in dom IsJ /\ D by FUNCT_1:68,SCMPDS_2:100;
    then
A7: x in dom IsJ & x in D by XBOOLE_0:def 3;
    per cases by A7,SCMPDS_4:28;
    suppose
A8:   x in dom spJ;
      dom spJ c= A by AMI_1:def 40;
      then reconsider l=x as Instruction-Location of SCMPDS by A8,AMI_1:def 4;
      l=x;
      hence (DataPart IsJ).x = (DataPart Computation(s1,m1)).x
       by A7,SCMPDS_4:22;
    end;
    suppose x = IC SCMPDS;
      hence (DataPart IsJ).x = (DataPart Computation(s1,m1)).x by A6,SCMPDS_3:6
      ,XBOOLE_0:def 3;
    end;
  end;
A9: IsJ c= s3 by FUNCT_4:26;
  then dom IsJ c= dom s3 by GRFUNC_1:8;
  then
A10: dom IsJ c= the carrier of SCMPDS by AMI_1:79;
  dom (DataPart IsJ) = dom IsJ /\ D by RELAT_1:90,SCMPDS_2:100;
  then dom (DataPart IsJ) c= (the carrier of SCMPDS) /\ D by A10,XBOOLE_1:26;
  then dom (DataPart IsJ) c= dom sm /\ D by AMI_1:79;
  then dom (DataPart IsJ) c= dom (DataPart sm) by RELAT_1:90,SCMPDS_2:100;
  then DataPart IsJ c= DataPart sm by A5,GRFUNC_1:8;
  then
A11: DataPart sm = DataPart s3 by A4,LATTICE2:8;
  set s4 =  Computation( ss,m1);
A12: DataPart s4 = DataPart s3 by A1,A2,A11,Th38,SCMPDS_4:24;
A13: J is_closed_on sm & J is_halting_on sm by A1,Th42;
  then
A14: J is_closed_on s3 by SCMPDS_6:38;
A15: s3 is halting by A13,SCMPDS_6:def 3;
A16: dom stop I c= dom sIJ by SCMPDS_5:16;
  sIJ = I ';' (J ';' Stop SCMPDS) by SCMPDS_4:46
    .= I +* Shift(spJ, card I);
  then Shift(spJ, card I) c= sIJ by FUNCT_4:26;
  then Shift(spJ, card I) c= ss by A3,XBOOLE_1:1;
  then
A17: Shift(spJ, card I) c= s4 by AMI_1:81;
  now
    let k be Element of NAT;
    per cases;
    suppose k <= m1;
      then IC  Computation( ss,k) in dom stop I by A1,Th17,Th40;
      hence IC  Computation( ss,k) in dom sIJ by A16;
    end;
    suppose
A18:  k > m1;
A19:  IC s4 in dom spI by A1,Th17,Th40;
      hereby
        per cases by A1,Th17,Th41;
        suppose
A20:      IC s4 = inspos card I;
          consider ii be Nat such that
A21:      k=m1+ii by A18,NAT_1:10;
          reconsider ii as Element of NAT by ORDINAL1:def 13;
A22:      IC  Computation( s3,ii) + card I = IC  Computation( s4,ii)
          by A9,A12,A14,A17,A20,SCMPDS_6:45;
  reconsider nn = IC  Computation( s3,ii) as Element of NAT by ORDINAL1:def 13;
          inspos nn in dom spJ by A13,SCMPDS_6:def 2;
          then nn < card spJ by SCMPDS_4:1;
          then nn < card J+1 by SCMPDS_5:7;
          then
A24:      card I +nn < card I +(card J+1) by XREAL_1:8;
A25:      card sIJ=card IJ+1 by SCMPDS_5:7
            .=card I + card J+1 by SCMPDS_4:45;
          IC  Computation( ss,k)=inspos nn+card I by A21,A22,AMI_1: 51
            .=inspos (nn + card I);
          hence IC  Computation( ss,k) in dom sIJ by A24,A25,SCMPDS_4:1;
        end;
        suppose CurInstr s4 = halt SCMPDS;
          then IC  Computation( ss,k)=IC s4 by A18,AMI_1:52;
          hence IC  Computation( ss,k) in dom sIJ by A16,A19;
        end;
      end;
    end;
  end;
  hence (I ';'J) is_closed_on s by SCMPDS_6:def 2;
  per cases by A1,Th17,Th41;
  suppose CurInstr s4 = halt SCMPDS;
    then ss is halting by AMI_1:def 20;
    hence (I ';' J) is_halting_on s by SCMPDS_6:def 3;
  end;
  suppose IC s4 = inspos card I;
    then CurInstr  Computation( s3,m3) = CurInstr  Computation( s4,m3)
    by A9,A12,A14,A17,SCMPDS_6:45;
    then CurInstr  Computation( ss,m1+m3)
    = CurInstr  Computation( s3,m3) by AMI_1:51
      .= halt SCMPDS by A15,AMI_1:def 46;
    then ss is halting by AMI_1:def 20;
    hence (I ';' J) is_halting_on s by SCMPDS_6:def 3;
  end;
end;

theorem Th44: :: SCMPDS_5:30
  for I be No-StopCode Program of SCMPDS,J be Program of SCMPDS
  st I c= J & I is_closed_on s & I is_halting_on s holds
  IC  Computation( (s +* Initialized J),
  LifeSpan (s +* Initialized stop(I))) = inspos card I
proof
  let I be No-StopCode Program of SCMPDS,J be Program of SCMPDS;
  set s1 = s +* Initialized J, ss = s +* Initialized stop(I), m=LifeSpan ss;
  assume
A1: I c= J & I is_closed_on s & I is_halting_on s;
  hence IC  Computation( s1,m) =IC  Computation( ss,LifeSpan ss) by Th39,AMI_1:
  121
    .=inspos card I by A1,SCMPDS_6:43;
end;

theorem      ::SCMPDS_6:42
  for I being Program of SCMPDS,s being State of SCMPDS,
  k being Element of NAT st I is_halting_on s &
  k < LifeSpan (s +* Initialized stop I)
  holds CurInstr  Computation( (s +* Initialized stop I),k) <> halt SCMPDS
proof
  let I be Program of SCMPDS,s be State of SCMPDS,k be Element of NAT;
  set ss=s +* Initialized stop(I), m=LifeSpan ss;
  assume
A1: I is_halting_on s & k < m;
  then
A2: ss is halting by SCMPDS_6:def 3;
  assume CurInstr ( Computation( ss,k))=halt SCMPDS;
  hence thesis by A1,A2,AMI_1:def 46;
end;

theorem Th46:     ::SCMPDS_6:42
  for I,J being Program of SCMPDS,s being State of SCMPDS,
  k being Element of NAT
  st I is_closed_on s & I is_halting_on s &
  k < LifeSpan (s +* Initialized stop I)
  holds CurInstr  Computation( (s +* Initialized stop (I ';' J)),k)
  <> halt SCMPDS
proof
  let I,J be Program of SCMPDS,s be State of SCMPDS,k be Element of NAT;
  set s1=s +* Initialized stop I, s2=s +* Initialized stop (I ';' J),
  m=LifeSpan s1, s3=Computation(s2,k);
  assume
A1: I is_closed_on s & I is_halting_on s & k < m;
  then
A2: s1 is halting by SCMPDS_6:def 3;
  assume CurInstr s3 = halt SCMPDS;
  then CurInstr Computation(s1,k) = halt SCMPDS by A1,SCMPDS_6:41;
  hence thesis by A1,A2,AMI_1:def 46;
end;

Lm1: for I being No-StopCode Program of SCMPDS,J being
shiftable Program of SCMPDS,s,s1,s2 being State of SCMPDS
st I is_closed_on s & I is_halting_on s &
J is_closed_on IExec(I,s) & J is_halting_on IExec(I,s) &
s2=s +* Initialized stop (I ';' J) & s1=s +* Initialized stop I holds
IC Computation(s2,LifeSpan s1) = inspos card I &
DataPart Computation(s2,LifeSpan s1)  =
 DataPart(Computation(s1,LifeSpan s1) +* Initialized stop J) &
Shift(stop J,card I) c= Computation(s2,LifeSpan s1) &
LifeSpan s2 = LifeSpan s1 + LifeSpan (Result s1 +* Initialized stop J)
proof
  let I be No-StopCode Program of SCMPDS,J be shiftable Program of SCMPDS,
  s,s1,s2
  be State of SCMPDS;
  set IsI = Initialized stop I, spJ = stop J, IsJ = Initialized spJ,
  IJ = I ';' J, sIJ = stop IJ, IsIJ = Initialized sIJ, m1 = LifeSpan s1,
  sm =  Computation( s1,m1), s3 = sm +* IsJ;
  set m3 = LifeSpan s3, sE = IExec(I,s);
  assume
A1: I is_closed_on s & I is_halting_on s &
  J is_closed_on sE & J is_halting_on sE & s2=s +* IsIJ & s1=s +* IsI;
  then
A2: s2 = s +* ((I ';' (J ';' Stop SCMPDS)) +* Start-At inspos 0)
  by SCMPDS_4:46;
A3: IsIJ c= s2 by A1,FUNCT_4:26;
  sIJ c= IsIJ by SCMPDS_4:9;
  then
A4: sIJ c= s2 by A3,XBOOLE_1:1;
A5: DataPart s3 = DataPart Computation(s1,m1) +* DataPart IsJ by FUNCT_4:75;
A6: now
    let x be set;
    assume x in dom (DataPart IsJ);
    then
A7: x in dom IsJ /\ D by FUNCT_1:68,SCMPDS_2:100;
    then
A8: x in dom IsJ & x in D by XBOOLE_0:def 3;
    per cases by A8,SCMPDS_4:28;
    suppose
A9:   x in dom spJ;
      dom spJ c= A by AMI_1:def 40;
      then reconsider l=x as Instruction-Location of SCMPDS by A9,AMI_1:def 4;
      l=x;
      hence (DataPart IsJ).x = (DataPart Computation(s1,m1)).x
       by A8,SCMPDS_4:22;
    end;
    suppose x = IC SCMPDS;
      hence (DataPart IsJ).x = (DataPart Computation(s1,m1)).x by A7,SCMPDS_3:6
      ,XBOOLE_0:def 3;
    end;
  end;
A10: IsJ c= s3 by FUNCT_4:26;
  then dom IsJ c= dom s3 by GRFUNC_1:8;
  then
A11: dom IsJ c= the carrier of SCMPDS by AMI_1:79;
  dom (DataPart IsJ) = dom IsJ /\ D by RELAT_1:90,SCMPDS_2:100;
  then dom (DataPart IsJ) c= (the carrier of SCMPDS) /\ D by A11,XBOOLE_1:26;
  then dom (DataPart IsJ) c= dom ( Computation( s1,m1)) /\ D by AMI_1:79;
  then dom (DataPart IsJ) c= dom DataPart Computation(s1,m1)
   by RELAT_1:90,SCMPDS_2:100;
  then DataPart IsJ c=  DataPart Computation(s1,m1) by A6,GRFUNC_1:8;
  then
A12:  DataPart Computation(s1,m1) = DataPart s3 by A5,LATTICE2:8;
  set s4 =  Computation( s2,m1);
A13: J is_closed_on sm & J is_halting_on sm by A1,Th42;
  then
A14: J is_closed_on s3 by SCMPDS_6:38;
A15: s3 is halting by A13,SCMPDS_6:def 3; thus
A16: IC s4 = inspos card I by A1,Th17,Th44; thus
A17: DataPart s4 = DataPart s3 by A1,A2,A12,Th38,SCMPDS_4:24;
  reconsider m = m1 + m3 as Element of NAT;
  sIJ = I ';' (J ';' Stop SCMPDS) by SCMPDS_4:46
    .= I +* Shift(spJ, card I);
  then Shift(spJ, card I) c= sIJ by FUNCT_4:26;
  then Shift(spJ, card I) c= s2 by A4,XBOOLE_1:1;
  hence
A18: Shift(spJ, card I) c= s4 by AMI_1:81;
A19: now
    let k be Element of NAT;
    assume m1 + k < m;
    then
A20: k < m3 by XREAL_1:8;
    assume
A21: CurInstr  Computation( s2,m1+k) = halt SCMPDS;
    CurInstr  Computation( s3,k)
    = CurInstr  Computation( s4,k) by A10,A14,A16,A17,A18,SCMPDS_6:45
      .= halt SCMPDS by A21,AMI_1:51;
    hence contradiction by A15,A20,AMI_1:def 46;
  end;
  CurInstr  Computation( s3,m3) = CurInstr  Computation( s4,m3)
  by A10,A14,A16,A17,A18,SCMPDS_6:45;
  then CurInstr  Computation( s3,m3)
  = CurInstr  Computation( s2,m1+m3) by AMI_1:51;
  then
A22: CurInstr  Computation( s2,m) = halt SCMPDS by A15,AMI_1:def 46;
  now
    let k be Element of NAT;
    assume
A23: k < m;
    per cases;
    suppose k < m1;
      hence CurInstr Computation(s2,k) <> halt SCMPDS by A1,Th46;
    end;
    suppose m1 <= k;
      then consider kk being Nat such that
A24:  m1 + kk = k by NAT_1:10;
      reconsider kk as Element of NAT by ORDINAL1:def 13;
      m1+kk=k by A24;
      hence CurInstr Computation(s2,k) <> halt SCMPDS by A19,A23;
    end;
  end;
  then
A25: for k being Element of NAT st CurInstr Computation(s2,k) = halt SCMPDS
  holds m <= k;
  IJ is_halting_on s by A1,Th43;
  then s2 is halting by A1,SCMPDS_6:def 3;
  then
A26: LifeSpan s2 = m by A22,A25,AMI_1:def 46;
  s1 is halting by A1,SCMPDS_6:def 3;
  hence LifeSpan s2 = LifeSpan s1 + LifeSpan (Result s1 +* IsJ) by A26,
  AMI_1:122;
end;

theorem  ::SCMPDS_5:37
  for I being No-StopCode Program of SCMPDS,J being shiftable Program of SCMPDS
  st I is_closed_on s & I is_halting_on s &
  J is_closed_on IExec(I,s) & J is_halting_on IExec(I,s) holds
  LifeSpan (s +* Initialized stop (I ';' J))
  = LifeSpan (s +* Initialized stop I)
  + LifeSpan (Result (s +* Initialized stop I) +* Initialized stop J) by Lm1;

theorem Th48: :: SCMPDS_5:38
  for I being No-StopCode Program of SCMPDS,
  J being shiftable Program of SCMPDS st
  I is_closed_on s & I is_halting_on s &
  J is_closed_on IExec(I,s) & J is_halting_on IExec(I,s) holds
  IExec(I ';' J,s) =
  IExec(J,IExec(I,s)) +* Start-At (IC IExec(J,IExec(I,s)) + card I)
proof
  let I be No-StopCode Program of SCMPDS,J be shiftable Program of SCMPDS;
  set ps = s | A, IsI = Initialized stop I, IsJ = Initialized stop J,
  IJ = I ';' J, IsIJ =Initialized stop IJ, s1 = s +* IsI, m1 = LifeSpan s1,
  s2 = s +* IsIJ, s3 = Computation(s1,m1) +* IsJ, m3 = LifeSpan s3,
  sE = IExec(I,s);
  assume
A1: I is_closed_on s & I is_halting_on s &
  J is_closed_on sE & J is_halting_on sE;
  then
A2: s1 is halting by SCMPDS_6:def 3;
  IJ is_closed_on s & IJ is_halting_on s by A1,Th43;
  then
A3: s2 is halting by SCMPDS_6:def 3;
A4: IsJ c= s3 by FUNCT_4:26;
A5: J is_closed_on Computation(s1,m1) & J is_halting_on Computation(s1,m1)
by A1,Th42;
  then
A6: s3 is halting by SCMPDS_6:def 3;
  DataPart sE = DataPart(sE +* IsJ) by SCMPDS_6:9;
  then
A7: J is_closed_on sE +* IsJ & J is_halting_on sE +* IsJ by A1,SCMPDS_6: 37;
A8: dom ps = dom s /\ A by RELAT_1:90
    .= ({IC SCMPDS} \/ D \/ A) /\ A by SCMPDS_4:19
    .= A by XBOOLE_1:21;
A9: Computation(s1,m1) +* IsJ,
Computation(s1,m1) +* ps +* IsJ equal_outside dom ps by FUNCT_7:31,106;
  then
A10: Computation(s1,m1) +* ps +* IsJ, Computation(s1,m1) +* IsJ
equal_outside dom ps by FUNCT_7:28;
  Result (IExec(I,s) +* IsJ), Result s3 equal_outside A
  proof
A11: IsJ c= sE +* IsJ by FUNCT_4:26;
A12: IsJ c= s3 by FUNCT_4:26;
    IExec(I,s) = Computation(s1,m1) +* ps by A2,AMI_1:122;
    hence thesis by A7,A8,A10,A11,A12,Th28;
  end;
  then
A13: Result (IExec(I,s) +* IsJ) +* ps = Result s3 +* ps by A8,FUNCT_7: 108;
A14: s3 = Result s1 +* IsJ by A2,AMI_1:122;
A15: IExec(I ';' J,s) = Computation(s2,LifeSpan s2) +* ps by A3,AMI_1:122
    .= Computation(s2,m1+m3) +* ps by A1,A14,Lm1;
A16: IExec(I,s) | A = ps by CARD_3:99;
  then
A17: IExec(J,IExec(I,s)) = Computation(s3,m3) +* ps by A6,A13,AMI_1:122;
A18: IC Computation(s2,m1) = inspos card I &
  DataPart Computation(s2,m1) = DataPart(Computation(s1,m1) +* IsJ) &
  Shift(stop J,card I) c= Computation(s2,m1) by A1,Lm1;
  J is_closed_on s3 by A5,SCMPDS_6:38;
  then
A19: DataPart Computation( Computation(s2,m1),m3)
 = DataPart Computation(s3,m3) &
  IC  Computation( Computation(s2,m1),m3) = IC Computation(s3,m3) + card I
  by A4,A18,SCMPDS_6:45;
A20: DataPart IExec(I ';' J,s) = DataPart IExec(J,IExec(I,s))
  proof
    thus DataPart IExec(I ';' J,s) = DataPart Computation(s2,m1+m3)
    by A8,A15,AMI_2:29,FUNCT_4:76,SCMPDS_2:100
      .= DataPart Computation(s3,m3) by A19,AMI_1:51
      .= DataPart IExec(J,IExec(I,s))
       by A8,A17,AMI_2:29,FUNCT_4:76,SCMPDS_2:100;
  end;
  set R1=IExec(I,s) +* IsJ, R2=Result s1 +* IsJ;
  Result s1 = Computation(s1,m1) by A2,AMI_1:122;
  then
A21: Result s1 +* ps +* IsJ, Result s1 +* IsJ equal_outside A by A8
  ,A9,FUNCT_7:28;
A22: IsJ c= R1 by FUNCT_4:26;
  IsJ c= R2 by FUNCT_4:26;
  then
A23: IC Result (Result s1 +* IsJ)
  = IC Result (IExec(I,s) +* IsJ) by AMI_1:121,A7,A21,A22,Th28;
A24: IC IExec(I ';' J,s) = IC Result (s +* IsIJ) by SCMPDS_5:22
    .= IC Computation(s2,LifeSpan s2) by A3,AMI_1:122
    .= IC Computation(s2,m1+m3) by A1,A14,Lm1
    .= IC Computation(s3,m3) + card I by A19,AMI_1:51
    .= IC Result s3 + card I by A6,AMI_1:122
    .= IC Result (Result s1 +* IsJ) + card I by A2,AMI_1:122
    .= IC IExec(J,IExec(I,s)) + card I by A23,SCMPDS_5:22;
  hereby
A25: dom IExec(I ';' J,s) = the carrier of SCMPDS by AMI_1:79
      .= dom (IExec(J,IExec(I,s)) +*
    Start-At (IC IExec(J,IExec(I,s)) + card I)) by AMI_1:79;
    reconsider l = IC IExec(J,IExec(I,s)) + card I
    as Instruction-Location of SCMPDS;
A26: dom Start-At l = {IC SCMPDS} by FUNCOP_1:19;
    now
      let x be set;
      assume
A27:  x in dom IExec(I ';' J,s);
      per cases by A27,SCMPDS_4:20;
      suppose
A28:    x is Int_position;
        then
A29:    IExec(I ';' J,s).x = IExec(J,IExec(I,s)).x by A20,SCMPDS_4 :23;
        x <> IC SCMPDS by A28,SCMPDS_2:52;
        then not x in dom Start-At l by A26,TARSKI:def 1;
        hence IExec(I ';' J,s).x = (IExec(J,IExec(I,s)) +* Start-At
        (IC IExec(J,IExec(I,s)) + card I)).x by A29,FUNCT_4:12;
      end;
      suppose
A30:    x = IC SCMPDS;
        then x in {IC SCMPDS} by TARSKI:def 1;
        then
A31:    x in dom Start-At l by FUNCOP_1:19;
        thus IExec(I ';' J,s).x
        = (Start-At l).IC SCMPDS by A24,A30,FUNCOP_1:87
          .= (IExec(J,IExec(I,s)) +* Start-At
        (IC IExec(J,IExec(I,s)) + card I)).x by A30,A31,FUNCT_4:14;
      end;
      suppose
A32:    x is Instruction-Location of SCMPDS;
        IExec(I ';' J,s) | A = ps by CARD_3:99
          .= IExec(J,IExec(I,s)) | A by A16,CARD_3:99;
        then
A33:    IExec(I ';' J,s).x = IExec(J,IExec(I,s)).x by A32,SCMPDS_4 :21;
        x <> IC SCMPDS by A32,AMI_1:48;
        then not x in dom Start-At l by A26,TARSKI:def 1;
        hence IExec(I ';' J,s).x = (IExec(J,IExec(I,s)) +* Start-At
        (IC IExec(J,IExec(I,s)) + card I)).x by A33,FUNCT_4:12;
      end;
    end;
    hence thesis by A25,FUNCT_1:9;
  end;
end;

theorem Th49:  ::SCMPDS_5:39
  for I being No-StopCode Program of SCMPDS,
  J being shiftable Program of SCMPDS st
  I is_closed_on s & I is_halting_on s &
  J is_closed_on IExec(I,s) & J is_halting_on IExec(I,s)
  holds IExec(I ';' J, s).a = IExec(J,IExec(I,s)).a
proof
  let I be No-StopCode Program of SCMPDS,J be shiftable Program of SCMPDS;
  assume I is_closed_on s & I is_halting_on s &
  J is_closed_on IExec(I,s) & J is_halting_on IExec(I,s);
  then
A1: IExec(I ';' J,s) =
  IExec(J,IExec(I,s)) +* Start-At (IC IExec(J,IExec(I,s)) + card I) by Th48;
  not a in dom Start-At (IC IExec(J,IExec(I,s)) + card I) by SCMPDS_4:59;
  hence IExec(I ';' J, s).a = IExec(J,IExec(I,s)).a by A1,FUNCT_4:12;
end;

theorem Th50:  ::SCMPDS_5:46
  for I being No-StopCode Program of SCMPDS,j being parahalting
  shiftable Instruction of SCMPDS st I is_closed_on s & I is_halting_on s
  holds IExec(I ';' j, s).a = Exec(j, IExec(I, s)).a
proof
  let I be No-StopCode Program of SCMPDS,j be parahalting
  shiftable Instruction of SCMPDS;
  assume
A1: I is_closed_on s & I is_halting_on s;
  set Mj = Load j;
  for a holds (Initialized IExec(I,s)).a=IExec(I, s).a by SCMPDS_5:40;
  then
A2: DataPart Initialized IExec(I,s)
  = DataPart IExec(I, s) by SCMPDS_4:23;
A3: a in SCM-Data-Loc by SCMPDS_2:def 2;
A4: Mj is_closed_on IExec(I,s) by SCMPDS_6:34;
  Mj is_halting_on IExec(I,s) by SCMPDS_6:35;
  hence IExec(I ';' j, s).a = IExec(Mj,IExec(I,s)).a by A1,A4,Th49
    .= Exec(j, Initialized IExec(I,s)).a by SCMPDS_5:45
    .= (DataPart Exec(j, Initialized IExec(I,s))).a
     by A3,FUNCT_1:72,SCMPDS_2:100
    .= (DataPart Exec(j, IExec(I, s))).a by A2,SCMPDS_5:44
    .= Exec(j, IExec(I, s)).a by A3,FUNCT_1:72,SCMPDS_2:100;
end;

begin :: The construction of for-up loop program

:: while (a,i)<=0 do { I, (a,i)+=n }

definition
  let a be Int_position, i be Integer,n be Element of NAT;
  let I be Program of SCMPDS;
  func for-up(a,i,n,I) -> Program of SCMPDS equals

::Def02
  (a,i)>=0_goto (card I +3) ';' I ';' AddTo(a,i,n) ';' goto -(card I+2);
  coherence;
end;

begin :: The computation of for-up loop program

theorem Th51:
  for a be Int_position,i be Integer,n be Element of NAT,I be Program of SCMPDS
  holds card for-up(a,i,n,I)= card I +3
proof
  let a be Int_position,i be Integer,n be Element of NAT,
  I be Program of SCMPDS;
  set i1=(a,i)>=0_goto (card I +3), i2=AddTo(a,i,n);
  set I4=i1 ';' I, I5=I4 ';' i2;
  card I4=card I+1 by SCMPDS_6:15;
  then card I5=card I +1 +1 by SCMP_GCD:8
    .=card I+ (1+1);
  hence card for-up(a,i,n,I)=card I +2 +1 by SCMP_GCD:8
    .=card I + 3;
end;

Lm2: for a be Int_position,i be Integer,n be Element of NAT,
I be Program of SCMPDS
holds card stop for-up(a,i,n,I)= card I+4
proof
  let a be Int_position,i be Integer,n be Element of NAT,
  I be Program of SCMPDS;
  thus card stop for-up(a,i,n,I)= card for-up(a,i,n,I) +1 by SCMPDS_5:7
    .= card I +3+1 by Th51
    .= card I + 4;
end;

theorem Th52:
  for a be Int_position,i be Integer,n,m be Element of NAT,
  I be Program of SCMPDS
  holds m < card I+3 iff inspos m in dom for-up(a,i,n,I)
proof
  let a be Int_position,i be Integer,n,m be Element of NAT,
  I be Program of SCMPDS;
  card for-up(a,i,n,I)=card I + 3 by Th51;
  hence thesis by SCMPDS_4:1;
end;

theorem Th53:
  for a be Int_position,i be Integer,n be Element of NAT,
  I be Program of SCMPDS holds
  for-up(a,i,n,I).inspos 0=(a,i)>=0_goto (card I +3) &
  for-up(a,i,n,I).inspos (card I+1)=AddTo(a,i,n) &
  for-up(a,i,n,I).inspos (card I+2)=goto -(card I+2)
proof
  let a be Int_position,i be Integer,n be Element of NAT,
  I be Program of SCMPDS;
  set i1=(a,i)>=0_goto (card I +3), i2=AddTo(a,i,n), i3=goto -(card I+2);
  set I4=i1 ';' I, I5=I4 ';' i2;
A1: card I4=card I+1 by SCMPDS_6:15;
  then
A2: card I5=card I +1 +1 by SCMP_GCD:8
    .=card I+ (1+1);
  set J6=i2 ';' i3, J5=I ';' J6;
  set FLOOP=for-up(a,i,n,I);
  FLOOP=I4 ';' J6 by SCMPDS_4:49;
  then FLOOP=i1 ';' J5 by SCMPDS_4:50;
  hence FLOOP.inspos 0=i1 by SCMPDS_6:16;
  thus FLOOP.inspos(card I+1)=i2 by A1,SCMP_GCD:11;
  thus FLOOP.inspos(card I+2)=i3 by A2,SCMP_GCD:10;
end;

theorem Th54:
  for s being State of SCMPDS,I being Program of SCMPDS,a being Int_position,
  i being Integer,n be Element of NAT st s.DataLoc(s.a,i) >= 0 holds
  for-up(a,i,n,I) is_closed_on s & for-up(a,i,n,I) is_halting_on s
proof
  let s be State of SCMPDS,I be Program of SCMPDS,a be Int_position,
  i be Integer,n be Element of NAT;
  set d1=DataLoc(s.a,i);
  assume
A1: s.d1 >= 0;
  set FOR=for-up(a,i,n,I), pFOR=stop FOR, iFOR=Initialized pFOR,
  s3 = s +* iFOR,
  s4 = Computation(s3,1);
  set i1=(a,i)>=0_goto (card I+3), i2=AddTo(a,i,n), i3=goto -(card I+2);
A2: IC s3 =inspos 0 by SCMPDS_6:21;
A3: FOR = i1 ';' (I ';' i2 ';' i3) by Th15;
A4:  Computation( s3,0+1) = Following  Computation( s3,0) by AMI_1:14
    .= Following s3 by AMI_1:13
    .= Exec(i1,s3) by A3,SCMPDS_6:22;
A5: not d1 in dom iFOR & d1 in dom s by SCMPDS_2:49,SCMPDS_4:31;
  not a in dom iFOR & a in dom s by SCMPDS_2:49,SCMPDS_4:31;
  then
A6: s3.DataLoc(s3.a,i)=s3.d1 by FUNCT_4:12
    .= s.d1 by A5,FUNCT_4:12;
  iFOR c= s3 by FUNCT_4:26;
  then
A7: pFOR c= s4 by AMI_1:81,SCMPDS_4:57;
A8: card FOR=card I+3 by Th51;
  then
A9: inspos(card I+3) in dom pFOR by SCMPDS_6:25;
A10: IC s4 = ICplusConst(s3,(card I+3)) by A1,A4,A6,SCMPDS_2:69
    .= inspos(0+(card I+3)) by A2,SCMPDS_6:23;
  s4.inspos(card I+3) = pFOR.inspos(card I+3) by A7,A9,GRFUNC_1:8
    .=halt SCMPDS by A8,SCMPDS_6:25;
  then
A11: CurInstr s4 = halt SCMPDS by A10;
  now
    let k be Element of NAT;
    per cases;
    suppose 0 < k;
      then 1+0 <= k by INT_1:20;
      hence IC Computation(s3,k) in dom pFOR by A9,A10,A11,AMI_1:52;
    end;
    suppose k = 0;
      then Computation(s3,k) = s3 by AMI_1:13;
      hence IC Computation(s3,k) in dom pFOR by A2,SCMPDS_4:75;
    end;
  end;
  hence FOR is_closed_on s by SCMPDS_6:def 2;
  s3 is halting by A11,AMI_1:def 20;
  hence FOR is_halting_on s by SCMPDS_6:def 3;
end;

theorem Th55:
  for s being State of SCMPDS,I being Program of SCMPDS,a,c being Int_position,
  i being Integer,n be Element of NAT st s.DataLoc(s.a,i) >= 0 holds
  IExec(for-up(a,i,n,I),s) = s +* Start-At inspos (card I + 3)
proof
  let s be State of SCMPDS,I be Program of SCMPDS, a,c be Int_position,
  i be Integer,n be Element of NAT;
  set d1=DataLoc(s.a,i);
  assume
A1: s.d1 >= 0;
  set FOR=for-up(a,i,n,I), pFOR=stop FOR, iFOR=Initialized pFOR,
  s3 = s +* iFOR, s4 =  Computation( s3,1), i1=(a,i)>=0_goto (card I+3),
  i2=AddTo(a,i,n), i3=goto -(card I+2);
  set SAl=Start-At inspos (card I + 3);
A2: IC s3 =inspos 0 by SCMPDS_6:21;
A3: FOR = i1 ';' (I ';' i2 ';' i3) by Th15;
  then
A4: CurInstr s3 = i1 by SCMPDS_6:22;
A5:  Computation( s3,0+1) = Following  Computation( s3,0) by AMI_1:14
    .= Following s3 by AMI_1:13
    .= Exec(i1,s3) by A3,SCMPDS_6:22;
A6: not d1 in dom iFOR & d1 in dom s by SCMPDS_2:49,SCMPDS_4:31;
  not a in dom iFOR & a in dom s by SCMPDS_2:49,SCMPDS_4:31;
  then
A7: s3.DataLoc(s3.a,i)=s3.d1 by FUNCT_4:12
    .= s.d1 by A6,FUNCT_4:12;
A8: dom (s | A) = A by SCMPDS_6:1;
  iFOR c= s3 by FUNCT_4:26;
  then
A9: pFOR c= s4 by AMI_1:81,SCMPDS_4:57;
A10: card FOR=card I+3 by Th51;
  then
A11: inspos(card I+3) in dom pFOR by SCMPDS_6:25;
A12: IC s4 = ICplusConst(s3,(card I+3)) by A1,A5,A7,SCMPDS_2:69
    .= inspos(0+(card I+3)) by A2,SCMPDS_6:23;
  s4.inspos(card I+3) = pFOR.inspos(card I+3) by A9,A11,GRFUNC_1:8
    .=halt SCMPDS by A10,SCMPDS_6:25;
  then
A13: CurInstr s4 = halt SCMPDS by A12;
  then
A14: s3 is halting by AMI_1:def 20;
  now
    let l be Element of NAT;
    assume l < 0+1;
    then l <= 0 by NAT_1:13;
    then l=0;
    then CurInstr  Computation( s3,l) = CurInstr s3 by AMI_1:13;
    hence CurInstr  Computation( s3,l) <> halt SCMPDS by A4,SCMPDS_6:31;
  end;
  then for l be Element of NAT st CurInstr  Computation( s3,l) = halt SCMPDS
  holds 1 <= l;
  then LifeSpan s3 = 1 by A13,A14,AMI_1:def 46;
  then
A15: s4 = Result s3 by A14,AMI_1:122;
A16: dom IExec(FOR,s) = the carrier of SCMPDS by AMI_1:79
    .= dom (s +* SAl) by AMI_1:79;
  now
    let x be set;
    assume
A17: x in dom IExec(FOR,s);
A18: dom SAl = {IC SCMPDS} by FUNCOP_1:19;
    per cases by A17,SCMPDS_4:20;
    suppose
A19:  x is Int_position;
      then x <> IC SCMPDS by SCMPDS_2:52;
      then
A20:  not x in dom SAl by A18,TARSKI:def 1;
      now
        assume x in dom (s | A);
        then reconsider l=x as Instruction-Location of SCMPDS
        by A8,AMI_1:def 4;
        l=x;
        hence contradiction by A19,SCMPDS_2:53;
      end;
      hence IExec(FOR,s).x = s4.x by A15,FUNCT_4:12
        .= s3.x by A5,A19,SCMPDS_2:69
        .= s.x by A19,SCMPDS_5:19
        .= (s +* SAl).x by A20,FUNCT_4:12;
    end;
    suppose
A21:  x = IC SCMPDS;
      now
        assume x in dom (s | A);
        then reconsider l=x as Instruction-Location of SCMPDS
        by A8,AMI_1:def 4;
        l=x;
        hence contradiction by A21,AMI_1:48;
      end;
      hence IExec(FOR,s).x = inspos(card I + 3) by A15,FUNCT_4:12,A12,A21
        .= (s +* SAl).x by A21,Th12;
    end;
    suppose x is Instruction-Location of SCMPDS;
      hence IExec(FOR,s).x = (s +* SAl).x by SCMPDS_6:27;
    end;
  end;
  hence IExec(FOR,s) = s +* SAl by A16,FUNCT_1:9;
end;

theorem
  for s being State of SCMPDS,I being Program of SCMPDS,a being Int_position,
  i being Integer,n be Element of NAT st s.DataLoc(s.a,i) >= 0
  holds IC IExec(for-up(a,i,n,I),s) = inspos (card I + 3)
proof
  let s be State of SCMPDS,I be Program of SCMPDS,a be Int_position,
  i be Integer,n be Element of NAT;
  assume s.DataLoc(s.a,i) >= 0;
  then IExec(for-up(a,i,n,I),s) =s +* Start-At inspos (card I+ 3) by Th55;
  hence thesis by AMI_1:111;
end;

theorem
  for s being State of SCMPDS,I being Program of SCMPDS,a,b being Int_position,
  i being Integer,n be Element of NAT st s.DataLoc(s.a,i) >= 0
  holds IExec(for-up(a,i,n,I),s).b = s.b
proof
  let s be State of SCMPDS,I be Program of SCMPDS,a,b be Int_position,
  i be Integer,n be Element of NAT;
  assume s.DataLoc(s.a,i) >= 0;
  then
A1: IExec(for-up(a,i,n,I),s) = s +* Start-At inspos (card I + 3) by Th55;
  not b in dom Start-At inspos (card I + 3) by SCMPDS_4:59;
  hence IExec(for-up(a,i,n,I),s).b = s.b by A1,FUNCT_4:12;
end;

Lm3: for I being Program of SCMPDS,a being Int_position,i being Integer,
n be Element of NAT holds Shift(I,1) c= for-up(a,i,n,I)
proof
  let I be Program of SCMPDS,a be Int_position,i be Integer,
  n be Element of NAT;
  set i1=(a,i)>=0_goto (card I+3), i2=AddTo(a,i,n), i3=goto -(card I+2);
A1: card Load i1=1 by SCMPDS_5:6;
  for-up(a,i,n,I) = Load i1 ';' I ';' (i2 ';' i3) by SCMPDS_4:49;
  hence thesis by A1,Th16;
end;

theorem Th58:
  for s being State of SCMPDS,I being No-StopCode shiftable Program of SCMPDS,
  a be Int_position, i be Integer,n be Element of NAT,X be set
  st s.DataLoc(s.a,i) < 0 & not DataLoc(s.a,i) in X & n > 0 & card I > 0 &
  a <> DataLoc(s.a,i) & (for t be State of SCMPDS st
  (for x be Int_position st x in X holds t.x=s.x) & t.a=s.a
  holds IExec(I,t).a=t.a & IExec(I,t).DataLoc(s.a,i)=t.DataLoc(s.a,i) &
  I is_closed_on t & I is_halting_on t &
  for y be Int_position st y in X holds IExec(I,t).y=t.y) holds
  for-up(a,i,n,I) is_closed_on s & for-up(a,i,n,I) is_halting_on s
proof
  let s be State of SCMPDS,I be No-StopCode shiftable Program of SCMPDS,
  a be Int_position, i be Integer,n be Element of NAT,X be set;
  set b=DataLoc(s.a,i);
  set FOR=for-up(a,i,n,I), pFOR=stop FOR, iFOR=Initialized pFOR, pI=stop I,
  IsI= Initialized pI;
  set i1=(a,i)>=0_goto (card I+3), i2=AddTo(a,i,n), i3=goto -(card I+2);
  assume
A1: s.b < 0;
  assume
A2: not b in X;
  assume
A3: n > 0;
  assume
A4: card I > 0;
  assume
A5: a <> b;
  assume
A6: for t be State of SCMPDS st
  (for x be Int_position st x in X holds t.x=s.x) & t.a=s.a
  holds IExec(I,t).a=t.a & IExec(I,t).b=t.b
  & I is_closed_on t & I is_halting_on t &
  for y be Int_position st y in X holds IExec(I,t).y=t.y;
  defpred P[Element of NAT] means for t be State of SCMPDS st -t.b <= $1 &
  (for x be Int_position st x in X holds t.x=s.x) & t.a=s.a
  holds FOR is_closed_on t & FOR is_halting_on t;
A7: P[0]
  proof
    let t be State of SCMPDS;
    assume
A8: -t.b <= 0;
    assume for x be Int_position st x in X holds t.x=s.x;
    assume
A9: t.a=s.a;
    -t.b <= -0 by A8;
    then t.b >= 0 by XREAL_1:26;
    hence FOR is_closed_on t & FOR is_halting_on t by A9,Th54;
  end;
A10: for k be Element of NAT st P[k] holds P[k + 1]
  proof
    let k be Element of NAT;
    assume
A11: P[k];
    now
      let t be State of SCMPDS;
      assume
A12:  -t.b <= k+1;
      assume
A13:  for x be Int_position st x in X holds t.x=s.x;
      assume
A14:  t.a=s.a;
      per cases;
      suppose t.b >= 0;
        hence FOR is_closed_on t & FOR is_halting_on t by A14,Th54;
      end;
      suppose
A15:    t.b < 0;
        set t2 = t +* IsI, t3 = t +* iFOR,
        t4 = Computation(t3,1);
A16:    IExec(I,t).a=t.a & IExec(I,t).b=t.b
        & I is_closed_on t & I is_halting_on t &
        for y be Int_position st y in X holds IExec(I,t).y=t.y by A6,A13,A14;
A17:    IsI c= t2 by FUNCT_4:26;
A18:    t2 is halting by A16,SCMPDS_6:def 3;
        then t2 +* IsI is halting by A17,FUNCT_4:79;
        then
A19:    I is_halting_on t2 by SCMPDS_6:def 3;
A20:    I is_closed_on t2 by A16,SCMPDS_6:38;
A21:    inspos 0 in dom pFOR by SCMPDS_4:75;
A22:    IC t3 =inspos 0 by SCMPDS_6:21;
A23:    FOR = i1 ';' (I ';' i2 ';' i3) by Th15;
A24:     Computation( t3,0+1) = Following  Computation( t3,0) by
        AMI_1:14
          .= Following t3 by AMI_1:13
          .= Exec(i1,t3) by A23,SCMPDS_6:22;
A25:    not a in dom iFOR & a in dom t by SCMPDS_2:49,SCMPDS_4:31;
A26:    not b in dom iFOR & b in dom t by SCMPDS_2:49,SCMPDS_4:31;
        t3.DataLoc(t3.a,i)= t3.b by A14,A25,FUNCT_4:12
          .= t.b by A26,FUNCT_4:12;
        then
A27:    IC t4 = Next IC t3 by A15,A24,SCMPDS_2:69
          .= inspos(0+1) by A22;
A28:    DataPart t2 = DataPart t3 by SCMPDS_4:24,36;
        now
          let a;
          thus t2.a = t3.a by A28,SCMPDS_4:23
            .= t4.a by A24,SCMPDS_2:69;
        end;
        then
A29:    DataPart t2 = DataPart t4 by SCMPDS_4:23;
        set m2=LifeSpan t2, t5= Computation( t4,m2), l1=inspos (card I + 1);
A30:    dom (t | A) = A by SCMPDS_6:1;
A31:    now
          assume a in dom (t | A);
          then reconsider l=a as Instruction-Location of SCMPDS
          by A30,AMI_1:def 4;
          l=a;
          hence contradiction by SCMPDS_2:53;
        end;
A32:    now
          assume b in dom (t | A);
          then reconsider l=b as Instruction-Location of SCMPDS
          by A30,AMI_1:def 4;
          l=b;
          hence contradiction by SCMPDS_2:53;
        end;
        card I + 1 < card I + 3 by XREAL_1:8;
        then
A33:    l1 in dom FOR by Th52;
A34:    FOR c= iFOR by SCMPDS_6:17;
        iFOR c= t3 by FUNCT_4:26;
        then
A35:    FOR c= t3 by A34,XBOOLE_1:1;
        Shift(I,1) c= FOR by Lm3;
        then Shift(I,1) c= t3 by A35,XBOOLE_1:1;
        then
A36:    Shift(I,1) c= t4 by AMI_1:81;
        then
A37:     DataPart Computation( t2,m2) = DataPart t5
 by A4,A17,A19,A20,A27,A29,Th36;
        then
A38:    t5.a= Computation( t2,m2).a by SCMPDS_4:23
          .=(Result t2).a by A18,AMI_1:122
          .=s.a by A14,A16,A31,FUNCT_4:12;
A39:    t5.b= Computation( t2,m2).b by A37,SCMPDS_4:23
          .=(Result t2).b by A18,AMI_1:122
          .=t.b by A16,A32,FUNCT_4:12;
        set m3=m2 +1;
        set t6= Computation( t3,m3);
A40:    IC t5=l1 by A4,A17,A19,A20,A27,A29,A36,Th36;
A41:    t6=t5 by AMI_1:51;
        then
A42:    CurInstr t6=t5.l1 by A4,A17,A19,A20,A27,A29,A36,Th36
          .=t4.l1 by AMI_1:54
          .=t3.l1 by AMI_1:54
          .=FOR.l1 by A33,A35,GRFUNC_1:8
          .=i2 by Th53;
        set t7= Computation( t3,m3+1);
A43:    t7 = Following t6 by AMI_1:14
          .= Exec(i2,t6) by A42;
        then
A44:    IC t7=Next IC t6 by SCMPDS_2:60
          .=inspos(card I+1+1) by A40,A41,NAT_1:39
          .=inspos(card I+(1+1));
        DataLoc(t6.a,i)=b by A38,AMI_1:51;
        then
A45:    t7.a=t6.a by A5,A43,SCMPDS_2:60
          .=s.a by A38,AMI_1:51;
        set l2=inspos(card I+2);
        card I + 2 < card I + 3 by XREAL_1:8;
        then
A46:    l2 in dom FOR by Th52;
A47:    CurInstr t7=t3.l2 by A44,AMI_1:54
          .=FOR.l2 by A35,A46,GRFUNC_1:8
          .=i3 by Th53;
        set m5=m3+1+1, t8= Computation( t3,m5);
A48:    t8 = Following t7 by AMI_1:14
          .= Exec(i3,t7) by A47;
        then
A49:    IC t8=ICplusConst(t7,0-(card I+2)) by SCMPDS_2:66
          .=inspos 0 by A44,Th1;
A50:    t8.a=s.a by A45,A48,SCMPDS_2:66;
A51:    now
          let x be Int_position;
          assume
A52:      x in X;
A53:      now
            assume x in dom (t | A);
            then reconsider l=x as Instruction-Location of SCMPDS
            by A30,AMI_1:def 4;
            l=x;
            hence contradiction by SCMPDS_2:53;
          end;
          t5.x= Computation( t2,m2).x by A37,SCMPDS_4:23
            .=(Result t2).x by A18,AMI_1:122
            .=IExec(I,t).x by A53,FUNCT_4:12
            .=t.x by A6,A13,A14,A52
            .=s.x by A13,A52;
          then t7.x=s.x by A2,A38,A41,A43,A52,SCMPDS_2:60;
          hence t8.x=s.x by A48,SCMPDS_2:66;
        end;
A54:    t8.b=t7.b by A48,SCMPDS_2:66
          .=t.b+n by A38,A39,A41,A43,SCMPDS_2:60;
        -(-n) > 0 by A3;
        then -n < 0;
        then -n <= -1 by INT_1:21;
        then
A55:    -n-t.b <= -1-t.b by XREAL_1:11;
        -t.b-1 <= k by A12,XREAL_1:22;
        then
A56:    -n-t.b <= k by A55,XXREAL_0:2;
        -t8.b=-n-t.b by A54;
        then
A57:    FOR is_closed_on t8 & FOR is_halting_on t8 by A11,A50,A51, A56;
A58:    t8 +* iFOR=t8 by A49,Th37;
        now
          let k be Element of NAT;
          per cases;
          suppose k < m5;
            then k <= m3+1 by INT_1:20;
            then
A59:        k <= m3 or k=m3+1 by NAT_1:8;
            hereby
              per cases by A59,NAT_1:8;
              suppose
A60:            k <= m2;
                hereby
                  per cases;
                  suppose k=0;
                    hence IC  Computation( t3,k) in dom pFOR by A21,A22,
                    AMI_1:13;
                  end;
                  suppose k<>0;
                    then consider kn be Nat such that
A61:                k=kn+1 by NAT_1:6;
                    reconsider kn as Element of NAT by ORDINAL1:def 13;
                    kn < k by A61,XREAL_1:31;
                    then kn < m2 by A60,XXREAL_0:2;
                    then
A62:                IC  Computation( t2,kn) + 1 = IC Computation(t4,kn)
                    by A4,A17,A19,A20,A27,A29,A36,Th34;
A63:                IC  Computation( t2,kn) in dom pI by A16,SCMPDS_6:def 2;
  reconsider lm = IC  Computation( t2,kn) as Element of NAT by ORDINAL1:def 13;
                    lm < card pI by A63,SCMPDS_4:1;
                    then lm < card I+1 by SCMPDS_5:7;
                    then
A65:                lm+1 <= card I +1 by INT_1:20;
                    card I + 1 < card I + 4 by XREAL_1:8;
                    then lm+1 < card I +4 by A65,XXREAL_0:2;
                    then
A66:                lm+1 < card pFOR by Lm2;
                    IC  Computation( t3,k)=inspos lm +1 by A61,A62,
                    AMI_1:51
                      .=inspos (lm+1);
                    hence IC  Computation( t3,k) in dom pFOR by A66,SCMPDS_4:1;
                  end;
                end;
              end;
              suppose
A67:            k=m3;
                l1 in dom pFOR by A33,SCMPDS_6:18;
                hence IC  Computation( t3,k) in dom pFOR by A4,A17,A19,A20,A27
                ,A29,A36,A41,A67,Th36;
              end;
              suppose k=m3+1;
                hence IC  Computation( t3,k) in dom pFOR
                 by A44,A46,SCMPDS_6:18;
              end;
            end;
          end;
          suppose k >= m5;
            then consider nn be Nat such that
A68:        k=m5+nn by NAT_1:10;
            reconsider nn as Element of NAT by ORDINAL1:def 13;
            Computation(t3,k)= Computation( (t8 +* iFOR),nn)
            by A58,A68,AMI_1:51;
            hence IC  Computation( t3,k) in dom pFOR by A57,SCMPDS_6:def 2;
          end;
        end;
        hence FOR is_closed_on t by SCMPDS_6:def 2;
        t8 is halting by A57,A58,SCMPDS_6:def 3;
        then t3 is halting by AMI_1:93;
        hence FOR is_halting_on t by SCMPDS_6:def 3;
      end;
    end;
    hence P[k+1];
  end;
A69: for k being Element of NAT holds P[k] from NAT_1:sch 1(A7,A10);
  -s.b > 0 by A1,XREAL_1:60;
  then reconsider n=-s.b as Element of NAT by INT_1:16;
A70: P[n] by A69;
  for x be Int_position st x in X holds s.x=s.x;
  hence FOR is_closed_on s & FOR is_halting_on s by A70;
end;

theorem
  for s being State of SCMPDS,I being No-StopCode shiftable Program of SCMPDS,
  a be Int_position, i be Integer,n be Element of NAT,X be set
  st s.DataLoc(s.a,i) < 0 & not DataLoc(s.a,i) in X & n > 0 & card I > 0 &
  a <> DataLoc(s.a,i) & (for t be State of SCMPDS st
  (for x be Int_position st x in X holds t.x=s.x) & t.a=s.a
  holds IExec(I,t).a=t.a & IExec(I,t).DataLoc(s.a,i)=t.DataLoc(s.a,i) &
  I is_closed_on t & I is_halting_on t &
  for y be Int_position st y in X holds IExec(I,t).y=t.y) holds
  IExec(for-up(a,i,n,I),s) =
  IExec(for-up(a,i,n,I),IExec(I ';' AddTo(a,i,n),s))
proof
  let s be State of SCMPDS,I be No-StopCode shiftable Program of SCMPDS,
  a be Int_position, i be Integer,n be Element of NAT,X be set;
  set b=DataLoc(s.a,i);
  set FOR=for-up(a,i,n,I), iFOR=Initialized stop FOR, iI= Initialized stop I,
  s1= s +* iFOR,
  ps= s | A;
  set i1=(a,i)>=0_goto (card I+3), i2=AddTo(a,i,n), i3=goto -(card I+2);
  assume
A1: s.b < 0;
  assume
A2: not b in X;
  assume
A3: n > 0;
  assume
A4: card I > 0;
  assume
A5: a <> b;
  assume
A6: for t be State of SCMPDS st
  (for x be Int_position st x in X holds t.x=s.x) & t.a=s.a
  holds IExec(I,t).a=t.a & IExec(I,t).b=t.b
  & I is_closed_on t & I is_halting_on t &
  for y be Int_position st y in X holds IExec(I,t).y=t.y;
  then FOR is_halting_on s by A1,A2,A3,A4,A5,Th58;
  then
A7: s1 is halting by SCMPDS_6:def 3;
  set sI= s +* iI, m1=LifeSpan sI+3, J=I ';' AddTo(a,i,n),
  sJ=s +* Initialized stop J, s2=IExec(J,s) +* iFOR,
  m2=LifeSpan s2;
  set Es=IExec(J,s), bj=DataLoc(Es.a,i);
A8: (for x be Int_position st x in X holds s.x=s.x) & s.a=s.a;
  then
A9: I is_closed_on s & I is_halting_on s by A6;
A10: IExec(I, s).a=s.a by A6,A8;
A11: Es.a=Exec(i2, IExec(I, s)).a by A9,Th50
    .=s.a by A5,A10,SCMPDS_2:60;
A12: now
    per cases;
    suppose Es.bj >= 0;
      hence FOR is_halting_on Es by Th54;
    end;
    suppose
A13:  Es.bj<0;
      now
        let t be State of SCMPDS;
        assume
A14:    (for x be Int_position st x in X holds t.x=Es.x) & t.a=Es.a;
A15:    now
          let x be Int_position;
          assume
A16:      x in X;
          hence t.x=Es.x by A14
            .=Exec(i2, IExec(I, s)).x by A9,Th50
            .=IExec(I, s).x by A2,A10,A16,SCMPDS_2:60
            .=s.x by A6,A8,A16;
        end;
        hence IExec(I,t).a=t.a by A6,A11,A14;
        thus IExec(I,t).bj= t.bj by A6,A11,A14,A15;
        thus I is_closed_on t & I is_halting_on t &

for y be Int_position st y in X holds IExec(I,t).y=t.y by A6,A11,A14,A15;
      end;
      hence FOR is_halting_on Es by A2,A3,A4,A5,A11,A13,Th58;
    end;
  end;
  set s4 = Computation(s1,1);
A17: IExec(I,s).a=s.a & IExec(I,s).b=s.b by A6,A8;
A18: iI c= sI by FUNCT_4:26;
A19: sI is halting by A9,SCMPDS_6:def 3;
  then sI +* iI is halting by A18,FUNCT_4:79;
  then
A20: I is_halting_on sI by SCMPDS_6:def 3;
A21: I is_closed_on sI by A9,SCMPDS_6:38;
A22: IC s1 =inspos 0 by SCMPDS_6:21;
A23: FOR = i1 ';' (I ';' i2 ';' i3) by Th15;
A24:  Computation( s1,0+1) = Following  Computation( s1,0) by AMI_1:14
    .= Following s1 by AMI_1:13
    .= Exec(i1,s1) by A23,SCMPDS_6:22;
A25: not a in dom iFOR & a in dom s by SCMPDS_2:49,SCMPDS_4:31;
A26: not b in dom iFOR & b in dom s by SCMPDS_2:49,SCMPDS_4:31;
  s1.DataLoc(s1.a,i)=s1.b by A25,FUNCT_4:12
    .= s.b by A26,FUNCT_4:12;
  then
A27: IC s4 = Next IC s1 by A1,A24,SCMPDS_2:69
    .= inspos(0+1) by A22;
A28: DataPart sI = DataPart s1 by SCMPDS_4:24,36;
  now
    let a;
    thus sI.a = s1.a by A28,SCMPDS_4:23
      .= s4.a by A24,SCMPDS_2:69;
  end;
  then
A29: DataPart sI = DataPart s4 by SCMPDS_4:23;
  set mI=LifeSpan sI, s5= Computation( s4,mI), l1=inspos (card I + 1);
A30: dom (s | A) = A by SCMPDS_6:1;
A31: now
    assume a in dom (s | A);
    then reconsider l=a as Instruction-Location of SCMPDS by A30,AMI_1:def 4;
    l=a;
    hence contradiction by SCMPDS_2:53;
  end;
A32: now
    assume b in dom (s | A);
    then reconsider l=b as Instruction-Location of SCMPDS by A30,AMI_1:def 4;
    l=b;
    hence contradiction by SCMPDS_2:53;
  end;
  card I + 1 < card I + 3 by XREAL_1:8;
  then
A33: l1 in dom FOR by Th52;
A34: FOR c= iFOR by SCMPDS_6:17;
  iFOR c= s1 by FUNCT_4:26;
  then
A35: FOR c= s1 by A34,XBOOLE_1:1;
  Shift(I,1) c= FOR by Lm3;
  then Shift(I,1) c= s1 by A35,XBOOLE_1:1;
  then
A36: Shift(I,1) c= s4 by AMI_1:81;
  then
A37: DataPart Computation( sI,mI) = DataPart s5 by A4,A18,A20,A21,A27,A29,Th36;
  then
A38: s5.a= Computation( sI,mI).a by SCMPDS_4:23
    .=(Result sI).a by A19,AMI_1:122
    .=s.a by A17,A31,FUNCT_4:12;
A39: s5.b= Computation( sI,mI).b by A37,SCMPDS_4:23
    .=(Result sI).b by A19,AMI_1:122
    .=s.b by A17,A32,FUNCT_4:12;
  set m3=mI +1;
  set s6= Computation( s1,m3);
A40: IC s5=l1 by A4,A18,A20,A21,A27,A29,A36,Th36;
A41: s6=s5 by AMI_1:51;
  then
A42: CurInstr s6=s5.l1 by A4,A18,A20,A21,A27,A29,A36,Th36
    .=s4.l1 by AMI_1:54
    .=s1.l1 by AMI_1:54
    .=FOR.l1 by A33,A35,GRFUNC_1:8
    .=i2 by Th53;
  set s7= Computation( s1,m3+1);
A43: s7 = Following s6 by AMI_1:14
    .= Exec(i2,s6) by A42;
  then
A44: IC s7=Next IC s6 by SCMPDS_2:60
    .=inspos(card I+1+1) by A40,A41,NAT_1:39
    .=inspos(card I+(1+1));
  set l2=inspos(card I+2);
  card I + 2 < card I + 3 by XREAL_1:8;
  then
A45: l2 in dom FOR by Th52;
A46: CurInstr s7=s1.l2 by A44,AMI_1:54
    .=FOR.l2 by A35,A45,GRFUNC_1:8
    .=i3 by Th53;
  set m5=m3+1+1, s8= Computation( s1,m5);
A47: s8 = Following s7 by AMI_1:14
    .= Exec(i3,s7) by A46;
  then
A48: IC s8=ICplusConst(s7,0-(card I+2)) by SCMPDS_2:66
    .=inspos 0 by A44,Th1;
A49: s8.b=s7.b by A47,SCMPDS_2:66
    .=s.b+n by A38,A39,A41,A43,SCMPDS_2:60;
A50: b=DataLoc(IExec(I, s).a,i) by A6,A8;
A51: Es.b=Exec(i2, IExec(I, s)).b by A9,Th50
    .=IExec(I, s).b+n by A10,SCMPDS_2:60
    .=s.b+n by A6,A8;
  now
    let x be Int_position;
A52: not x in dom iFOR & x in dom IExec(J,s) by SCMPDS_2:49,SCMPDS_4:31;
    then
A53: s2.x=IExec(J,s).x by FUNCT_4:12;
    per cases;
    suppose x=b;
      hence s8.x=s2.x by A49,A51,A52,FUNCT_4:12;
    end;
    suppose
A54:  x<>b;
A55:  now
        assume x in dom (s | A);
        then reconsider l=x as Instruction-Location of SCMPDS
        by A30,AMI_1:def 4;
        l=x;
        hence contradiction by SCMPDS_2:53;
      end;
A56:  s5.x= Computation( sI,mI).x by A37,SCMPDS_4:23
        .=(Result sI).x by A19,AMI_1:122
        .=IExec(I,s).x by A55,FUNCT_4:12;
A57:  s7.x=s5.x by A38,A41,A43,A54,SCMPDS_2:60;
      Es.x=Exec(i2, IExec(I, s)).x by A9,Th50
        .=IExec(I, s).x by A50,A54,SCMPDS_2:60;
      hence s8.x=s2.x by A47,A53,A56,A57,SCMPDS_2:66;
    end;
  end;
  then
A58: DataPart s8 = DataPart s2 by SCMPDS_4:23;
A59: IC s2 =IC Computation(s1,m1) by A48,SCMPDS_6:21;
A60: s2 is halting by A12,SCMPDS_6:def 3;
A61: dom ps = dom s /\ A by RELAT_1:90
    .= ({IC SCMPDS} \/ D \/ A) /\ A by SCMPDS_4:19
    .= A by XBOOLE_1:21;
  s2 | A=(Result sJ +* ps)|A +* iFOR | A by FUNCT_4:75
    .= ps +* iFOR | A by A61,FUNCT_4:24
    .= s1 | A by FUNCT_4:75
    .= Computation(s1,m1) | A by Th6;
  then
A62: Computation(s1,m1)=s2 by A58,A59,Th7;
  then
A63: CurInstr Computation(s1,m1)=i1 by A23,SCMPDS_6:22;
  set m0=LifeSpan s1;
  m0 > m1 by A7,A63,SCMPDS_6:2,31;
  then consider nn be Nat such that
A64: m0=m1+nn by NAT_1:10;
  reconsider nn as Element of NAT by ORDINAL1:def 13;
A65: Computation(s1,m0) = Computation(s2,nn) by A62,A64,AMI_1:51;
  then CurInstr Computation(s2,nn) =halt SCMPDS by A7,AMI_1:def 46;
  then
A66: nn >= m2 by A60,AMI_1:def 46;
  Computation(s1,m1+m2) = Computation(s2,m2) by A62,AMI_1:51;
  then CurInstr Computation(s1,m1+m2) = halt SCMPDS by A60,AMI_1:def 46;
  then m1 + m2 >= m0 by A7,AMI_1:def 46;
  then m2 >= nn by A64,XREAL_1:8;
  then nn=m2 by A66,XXREAL_0:1;
  then
A67: Result s1 = Computation(s2,m2) by A7,A65,AMI_1:122;
  IExec(J,s) | A= ps by A61,FUNCT_4:24;
  hence IExec(FOR,s) = IExec(FOR,IExec(J,s)) by A60,A67,AMI_1:122;
end;

registration
  let I be shiftable Program of SCMPDS,
  a be Int_position,i be Integer,n be Element of NAT;
  cluster for-up(a,i,n,I) -> shiftable;
  correctness
  proof
    set FOR=for-up(a,i,n,I), i1= (a,i)>=0_goto (card I +3), i2= AddTo(a,i,n);
    set PF= Load i1 ';' I ';' i2;
    card PF=card (i1 ';' I) + 1 by SCMP_GCD:8
      .=card I + 1+1 by SCMPDS_6:15
      .=card I +(1+1);
    then card PF+ -(card I+2) =0;
    hence FOR is shiftable by SCMPDS_4:78;
  end;
end;

registration
  let I be No-StopCode Program of SCMPDS,
  a be Int_position,i be Integer,n be Element of NAT;
  cluster for-up(a,i,n,I) -> No-StopCode;
  correctness
  proof
    -(card I+2) <> 0;
    then reconsider i3=goto -(card I+2) as No-StopCode Instruction of SCMPDS
    by SCMPDS_5:25;
    for-up(a,i,n,I) = (a,i)>=0_goto (card I +3) ';' I ';' AddTo(a,i,n) ';' i3;
    hence thesis;
  end;
end;

begin :: The construction of  for-down loop program

:: while (a,i)>=0 do { I, (a,i)-=n }

definition
  let a be Int_position, i be Integer,n be Element of NAT;
  let I be Program of SCMPDS;
  func for-down(a,i,n,I) -> Program of SCMPDS equals

::Def03
  (a,i)<=0_goto (card I +3) ';' I ';' AddTo(a,i,-n) ';' goto -(card I+2);
  coherence;
end;

begin :: The computation of  for-down loop program

theorem Th60:
  for a be Int_position,i be Integer,n be Element of NAT,I be Program of SCMPDS
  holds card for-down(a,i,n,I)= card I +3
proof
  let a be Int_position,i be Integer,n be Element of NAT,
  I be Program of SCMPDS;
  set i1=(a,i)<=0_goto (card I +3), i2=AddTo(a,i,-n);
  set I4=i1 ';' I, I5=I4 ';' i2;
  card I4=card I+1 by SCMPDS_6:15;
  then card I5=card I +1 +1 by SCMP_GCD:8
    .=card I+ (1+1);
  hence card for-down(a,i,n,I)=card I +2 +1 by SCMP_GCD:8
    .=card I + 3;
end;

Lm4: for a be Int_position,i be Integer,n be Element of NAT,
I be Program of SCMPDS
holds card stop for-down(a,i,n,I)= card I+4
proof
  let a be Int_position,i be Integer,n be Element of NAT,
  I be Program of SCMPDS;
  thus card stop for-down(a,i,n,I)= card for-down(a,i,n,I) +1 by SCMPDS_5:7
    .= card I +3+1 by Th60
    .= card I + 4;
end;

theorem Th61:
  for a be Int_position,i be Integer,n,m be Element of NAT,
  I be Program of SCMPDS
  holds m < card I+3 iff inspos m in dom for-down(a,i,n,I)
proof
  let a be Int_position,i be Integer,n,m be Element of NAT,
  I be Program of SCMPDS;
  card for-down(a,i,n,I)=card I + 3 by Th60;
  hence thesis by SCMPDS_4:1;
end;

theorem Th62:
  for a be Int_position,i be Integer,n be Element of NAT,
  I be Program of SCMPDS holds
  for-down(a,i,n,I).inspos 0=(a,i)<=0_goto (card I +3) &
  for-down(a,i,n,I).inspos (card I+1)=AddTo(a,i,-n) &
  for-down(a,i,n,I).inspos (card I+2)=goto -(card I+2)
proof
  let a be Int_position,i be Integer,n be Element of NAT,
  I be Program of SCMPDS;
  set i1=(a,i)<=0_goto (card I +3), i2=AddTo(a,i,-n), i3=goto -(card I+2);
  set I4=i1 ';' I, I5=I4 ';' i2;
A1: card I4=card I+1 by SCMPDS_6:15;
  then
A2: card I5=card I +1 +1 by SCMP_GCD:8
    .=card I+ (1+1);
  set J6=i2 ';' i3, J5=I ';' J6;
  set FLOOP=for-down(a,i,n,I);
  FLOOP=I4 ';' J6 by SCMPDS_4:49;
  then FLOOP=i1 ';' J5 by SCMPDS_4:50;
  hence FLOOP.inspos 0=i1 by SCMPDS_6:16;
  thus FLOOP.inspos(card I+1)=i2 by A1,SCMP_GCD:11;
  thus FLOOP.inspos(card I+2)=i3 by A2,SCMP_GCD:10;
end;

theorem Th63:
  for s being State of SCMPDS,I being Program of SCMPDS,a being Int_position,
  i being Integer,n be Element of NAT st s.DataLoc(s.a,i) <= 0 holds
  for-down(a,i,n,I) is_closed_on s & for-down(a,i,n,I) is_halting_on s
proof
  let s be State of SCMPDS,I be Program of SCMPDS,a be Int_position,
  i be Integer,n be Element of NAT;
  set d1=DataLoc(s.a,i);
  assume
A1: s.d1 <= 0;
  set FOR=for-down(a,i,n,I), pFOR=stop FOR, iFOR=Initialized pFOR,
  s3 = s +* iFOR,
  s4 = Computation(s3,1);
  set i1=(a,i)<=0_goto (card I+3), i2=AddTo(a,i,-n), i3=goto -(card I+2);
A2: IC s3 =inspos 0 by SCMPDS_6:21;
A3: FOR = i1 ';' (I ';' i2 ';' i3) by Th15;
A4:  Computation( s3,0+1) = Following  Computation( s3,0) by AMI_1:14
    .= Following s3 by AMI_1:13
    .= Exec(i1,s3) by A3,SCMPDS_6:22;
A5: not d1 in dom iFOR & d1 in dom s by SCMPDS_2:49,SCMPDS_4:31;
  not a in dom iFOR & a in dom s by SCMPDS_2:49,SCMPDS_4:31;
  then
A6: s3.DataLoc(s3.a,i)=s3.d1 by FUNCT_4:12
    .= s.d1 by A5,FUNCT_4:12;
  iFOR c= s3 by FUNCT_4:26;
  then
A7: pFOR c= s4 by AMI_1:81,SCMPDS_4:57;
A8: card FOR=card I+3 by Th60;
  then
A9: inspos(card I+3) in dom pFOR by SCMPDS_6:25;
A10: IC s4 = ICplusConst(s3,(card I+3)) by A1,A4,A6,SCMPDS_2:68
    .= inspos(0+(card I+3)) by A2,SCMPDS_6:23;
  s4.inspos(card I+3) = pFOR.inspos(card I+3) by A7,A9,GRFUNC_1:8
    .=halt SCMPDS by A8,SCMPDS_6:25;
  then
A11: CurInstr s4 = halt SCMPDS by A10;
  now
    let k be Element of NAT;
    per cases;
    suppose 0 < k;
      then 1+0 <= k by INT_1:20;
      hence IC Computation(s3,k) in dom pFOR by A9,A10,A11,AMI_1:52;
    end;
    suppose k = 0;
      then Computation(s3,k) = s3 by AMI_1:13;
      hence IC Computation(s3,k) in dom pFOR by A2,SCMPDS_4:75;
    end;
  end;
  hence FOR is_closed_on s by SCMPDS_6:def 2;
  s3 is halting by A11,AMI_1:def 20;
  hence FOR is_halting_on s by SCMPDS_6:def 3;
end;

theorem Th64:
  for s being State of SCMPDS,I being Program of SCMPDS,a,c being Int_position,
  i being Integer,n be Element of NAT st s.DataLoc(s.a,i) <= 0 holds
  IExec(for-down(a,i,n,I),s) = s +* Start-At inspos (card I + 3)
proof
  let s be State of SCMPDS,I be Program of SCMPDS, a,c be Int_position,
  i be Integer,n be Element of NAT;
  set d1=DataLoc(s.a,i);
  assume
A1: s.d1 <= 0;
  set FOR=for-down(a,i,n,I), pFOR=stop FOR, iFOR=Initialized pFOR,
  s3 = s +* iFOR, s4 =  Computation( s3,1), i1=(a,i)<=0_goto (card I+3),
  i2=AddTo(a,i,-n), i3=goto -(card I+2);
  set SAl=Start-At inspos (card I + 3);
A2: IC s3 =inspos 0 by SCMPDS_6:21;
A3: FOR = i1 ';' (I ';' i2 ';' i3) by Th15;
  then
A4: CurInstr s3 = i1 by SCMPDS_6:22;
A5:  Computation( s3,0+1) = Following  Computation( s3,0) by AMI_1:14
    .= Following s3 by AMI_1:13
    .= Exec(i1,s3) by A3,SCMPDS_6:22;
A6: not d1 in dom iFOR & d1 in dom s by SCMPDS_2:49,SCMPDS_4:31;
  not a in dom iFOR & a in dom s by SCMPDS_2:49,SCMPDS_4:31;
  then
A7: s3.DataLoc(s3.a,i)=s3.d1 by FUNCT_4:12
    .= s.d1 by A6,FUNCT_4:12;
A8: dom (s | A) = A by SCMPDS_6:1;
  iFOR c= s3 by FUNCT_4:26;
  then
A9: pFOR c= s4 by AMI_1:81,SCMPDS_4:57;
A10: card FOR=card I+3 by Th60;
  then
A11: inspos(card I+3) in dom pFOR by SCMPDS_6:25;
A12: IC s4 = ICplusConst(s3,(card I+3)) by A1,A5,A7,SCMPDS_2:68
    .= inspos(0+(card I+3)) by A2,SCMPDS_6:23;
  s4.inspos(card I+3) = pFOR.inspos(card I+3) by A9,A11,GRFUNC_1:8
    .=halt SCMPDS by A10,SCMPDS_6:25;
  then
A13: CurInstr s4 = halt SCMPDS by A12;
  then
A14: s3 is halting by AMI_1:def 20;
  now
    let l be Element of NAT;
    assume l < 0+1;
    then l <= 0 by NAT_1:13;
    then l=0;
    then CurInstr  Computation( s3,l) = CurInstr s3 by AMI_1:13;
    hence CurInstr  Computation( s3,l) <> halt SCMPDS by A4,SCMPDS_6:30;
  end;
  then for l be Element of NAT st CurInstr  Computation( s3,l) = halt SCMPDS
  holds 1 <= l;
  then LifeSpan s3 = 1 by A13,A14,AMI_1:def 46;
  then
A15: s4 = Result s3 by A14,AMI_1:122;
A16: dom IExec(FOR,s) = the carrier of SCMPDS by AMI_1:79
    .= dom (s +* SAl) by AMI_1:79;
  now
    let x be set;
    assume
A17: x in dom IExec(FOR,s);
A18: dom SAl = {IC SCMPDS} by FUNCOP_1:19;
    per cases by A17,SCMPDS_4:20;
    suppose
A19:  x is Int_position;
      then x <> IC SCMPDS by SCMPDS_2:52;
      then
A20:  not x in dom SAl by A18,TARSKI:def 1;
      now
        assume x in dom (s | A);
        then reconsider l=x as Instruction-Location of SCMPDS
        by A8,AMI_1:def 4;
        l=x;
        hence contradiction by A19,SCMPDS_2:53;
      end;
      hence IExec(FOR,s).x = s4.x by A15,FUNCT_4:12
        .= s3.x by A5,A19,SCMPDS_2:68
        .= s.x by A19,SCMPDS_5:19
        .= (s +* SAl).x by A20,FUNCT_4:12;
    end;
    suppose
A21:  x = IC SCMPDS;
      now
        assume x in dom (s | A);
        then reconsider l=x as Instruction-Location of SCMPDS
        by A8,AMI_1:def 4;
        l=x;
        hence contradiction by A21,AMI_1:48;
      end;
      hence IExec(FOR,s).x = inspos(card I + 3) by A15,FUNCT_4:12,A12,A21
        .= (s +* SAl).x by A21,Th12;
    end;
    suppose x is Instruction-Location of SCMPDS;
      hence IExec(FOR,s).x = (s +* SAl).x by SCMPDS_6:27;
    end;
  end;
  hence IExec(FOR,s) = s +* SAl by A16,FUNCT_1:9;
end;

theorem
  for s being State of SCMPDS,I being Program of SCMPDS,a being Int_position,
  i being Integer,n be Element of NAT st s.DataLoc(s.a,i) <= 0
  holds IC IExec(for-down(a,i,n,I),s) = inspos (card I + 3)
proof
  let s be State of SCMPDS,I be Program of SCMPDS,a be Int_position,
  i be Integer,n be Element of NAT;
  assume s.DataLoc(s.a,i) <= 0;
  then IExec(for-down(a,i,n,I),s) =s +* Start-At inspos (card I+ 3) by Th64;
  hence thesis by AMI_1:111;
end;

theorem Th66:
  for s being State of SCMPDS,I being Program of SCMPDS,a,b being Int_position,
  i being Integer,n be Element of NAT st s.DataLoc(s.a,i) <= 0
  holds IExec(for-down(a,i,n,I),s).b = s.b
proof
  let s be State of SCMPDS,I be Program of SCMPDS,a,b be Int_position,
  i be Integer,n be Element of NAT;
  assume s.DataLoc(s.a,i) <= 0;
  then
A1: IExec(for-down(a,i,n,I),s) = s +* Start-At inspos (card I + 3) by Th64;
  not b in dom Start-At inspos (card I + 3) by SCMPDS_4:59;
  hence IExec(for-down(a,i,n,I),s).b = s.b by A1,FUNCT_4:12;
end;

Lm5: for I being Program of SCMPDS,a being Int_position,i being Integer,
n be Element of NAT holds Shift(I,1) c= for-down(a,i,n,I)
proof
  let I be Program of SCMPDS,a be Int_position,i be Integer,
  n be Element of NAT;
  set i1=(a,i)<=0_goto (card I+3), i2=AddTo(a,i,-n), i3=goto -(card I+2);
A1: card Load i1=1 by SCMPDS_5:6;
  for-down(a,i,n,I) = Load i1 ';' I ';' (i2 ';' i3) by SCMPDS_4:49;
  hence thesis by A1,Th16;
end;

theorem Th67:
  for s being State of SCMPDS,I being No-StopCode shiftable Program of SCMPDS,
  a be Int_position, i be Integer,n be Element of NAT,X be set
  st s.DataLoc(s.a,i) > 0 & not DataLoc(s.a,i) in X & n > 0 & card I > 0 &
  a <> DataLoc(s.a,i) & (for t be State of SCMPDS st
  (for x be Int_position st x in X holds t.x=s.x) & t.a=s.a
  holds IExec(I,t).a=t.a & IExec(I,t).DataLoc(s.a,i)=t.DataLoc(s.a,i) &
  I is_closed_on t & I is_halting_on t &
  for y be Int_position st y in X holds IExec(I,t).y=t.y) holds
  for-down(a,i,n,I) is_closed_on s & for-down(a,i,n,I) is_halting_on s
proof
  let s be State of SCMPDS,I be No-StopCode shiftable Program of SCMPDS,
  a be Int_position, i be Integer,n be Element of NAT,X be set;
  set b=DataLoc(s.a,i);
  set FOR=for-down(a,i,n,I), pFOR=stop FOR, iFOR=Initialized pFOR, pI=stop I,
  IsI= Initialized pI;
  set i1=(a,i)<=0_goto (card I+3), i2=AddTo(a,i,-n), i3=goto -(card I+2);
  assume
A1: s.b > 0;
  assume
A2: not b in X;
  assume
A3: n > 0;
  assume
A4: card I > 0;
  assume
A5: a <> b;
  assume
A6: for t be State of SCMPDS st
  (for x be Int_position st x in X holds t.x=s.x) & t.a=s.a
  holds IExec(I,t).a=t.a & IExec(I,t).b=t.b
  & I is_closed_on t & I is_halting_on t &
  for y be Int_position st y in X holds IExec(I,t).y=t.y;
  defpred P[Element of NAT] means for t be State of SCMPDS st t.b <= $1 &
  (for x be Int_position st x in X holds t.x=s.x) & t.a=s.a
  holds FOR is_closed_on t & FOR is_halting_on t;
A7: P[0] by Th63;
A8: for k be Element of NAT st P[k] holds P[k + 1]
  proof
    let k be Element of NAT;
    assume
A9: P[k];
    now
      let t be State of SCMPDS;
      assume
A10:  t.b <= k+1;
      assume
A11:  for x be Int_position st x in X holds t.x=s.x;
      assume
A12:  t.a=s.a;
      per cases;
      suppose t.b <= 0;
        hence FOR is_closed_on t & FOR is_halting_on t by A12,Th63;
      end;
      suppose
A13:    t.b > 0;
        set t2 = t +* IsI, t3 = t +* iFOR,
        t4 = Computation(t3,1);
A14:    IExec(I,t).a=t.a & IExec(I,t).b=t.b
        & I is_closed_on t & I is_halting_on t &
        for y be Int_position st y in X holds IExec(I,t).y=t.y by A6,A11,A12;
A15:    IsI c= t2 by FUNCT_4:26;
A16:    t2 is halting by A14,SCMPDS_6:def 3;
        then t2 +* IsI is halting by A15,FUNCT_4:79;
        then
A17:    I is_halting_on t2 by SCMPDS_6:def 3;
A18:    I is_closed_on t2 by A14,SCMPDS_6:38;
A19:    inspos 0 in dom pFOR by SCMPDS_4:75;
A20:    IC t3 =inspos 0 by SCMPDS_6:21;
A21:    FOR = i1 ';' (I ';' i2 ';' i3) by Th15;
A22:     Computation( t3,0+1) = Following  Computation( t3,0) by
        AMI_1:14
          .= Following t3 by AMI_1:13
          .= Exec(i1,t3) by A21,SCMPDS_6:22;
A23:    not a in dom iFOR & a in dom t by SCMPDS_2:49,SCMPDS_4:31;
A24:    not b in dom iFOR & b in dom t by SCMPDS_2:49,SCMPDS_4:31;
        t3.DataLoc(t3.a,i)= t3.b by A12,A23,FUNCT_4:12
          .= t.b by A24,FUNCT_4:12;
        then
A25:    IC t4 = Next IC t3 by A13,A22,SCMPDS_2:68
          .= inspos(0+1) by A20;
A26:    DataPart t2 = DataPart t3 by SCMPDS_4:24,36;
        now
          let a;
          thus t2.a = t3.a by A26,SCMPDS_4:23
            .= t4.a by A22,SCMPDS_2:68;
        end;
        then
A27:    DataPart t2 = DataPart t4 by SCMPDS_4:23;
        set m2=LifeSpan t2, t5= Computation( t4,m2), l1=inspos (card I + 1);
A28:    dom (t | A) = A by SCMPDS_6:1;
A29:    now
          assume a in dom (t | A);
          then reconsider l=a as Instruction-Location of SCMPDS
          by A28,AMI_1:def 4;
          l=a;
          hence contradiction by SCMPDS_2:53;
        end;
A30:    now
          assume b in dom (t | A);
          then reconsider l=b as Instruction-Location of SCMPDS
          by A28,AMI_1:def 4;
          l=b;
          hence contradiction by SCMPDS_2:53;
        end;
        card I + 1 < card I + 3 by XREAL_1:8;
        then
A31:    l1 in dom FOR by Th61;
A32:    FOR c= iFOR by SCMPDS_6:17;
        iFOR c= t3 by FUNCT_4:26;
        then
A33:    FOR c= t3 by A32,XBOOLE_1:1;
        Shift(I,1) c= FOR by Lm5;
        then Shift(I,1) c= t3 by A33,XBOOLE_1:1;
        then
A34:    Shift(I,1) c= t4 by AMI_1:81;
        then
A35:     DataPart Computation( t2,m2) = DataPart t5
                by A4,A15,A17,A18,A25,A27,Th36;
        then
A36:    t5.a= Computation( t2,m2).a by SCMPDS_4:23
          .=(Result t2).a by A16,AMI_1:122
          .=s.a by A12,A14,A29,FUNCT_4:12;
A37:    t5.b= Computation( t2,m2).b by A35,SCMPDS_4:23
          .=(Result t2).b by A16,AMI_1:122
          .=t.b by A14,A30,FUNCT_4:12;
        set m3=m2 +1;
        set t6= Computation( t3,m3);
A38:    IC t5=l1 by A4,A15,A17,A18,A25,A27,A34,Th36;
A39:    t6=t5 by AMI_1:51;
        then
A40:    CurInstr t6=t5.l1 by A4,A15,A17,A18,A25,A27,A34,Th36
          .=t4.l1 by AMI_1:54
          .=t3.l1 by AMI_1:54
          .=FOR.l1 by A31,A33,GRFUNC_1:8
          .=i2 by Th62;
        set t7= Computation( t3,m3+1);
A41:    t7 = Following t6 by AMI_1:14
          .= Exec(i2,t6) by A40;
        then
A42:    IC t7=Next IC t6 by SCMPDS_2:60
          .=inspos(card I+1+1) by A38,A39,NAT_1:39
          .=inspos(card I+(1+1));
        DataLoc(t6.a,i)=b by A36,AMI_1:51;
        then
A43:    t7.a=t6.a by A5,A41,SCMPDS_2:60
          .=s.a by A36,AMI_1:51;
        set l2=inspos(card I+2);
        card I + 2 < card I + 3 by XREAL_1:8;
        then
A44:    l2 in dom FOR by Th61;
A45:    CurInstr t7=t3.l2 by A42,AMI_1:54
          .=FOR.l2 by A33,A44,GRFUNC_1:8
          .=i3 by Th62;
        set m5=m3+1+1, t8= Computation( t3,m5);
A46:    t8 = Following t7 by AMI_1:14
          .= Exec(i3,t7) by A45;
        then
A47:    IC t8=ICplusConst(t7,0-(card I+2)) by SCMPDS_2:66
          .=inspos 0 by A42,Th1;
A48:    t8.a=s.a by A43,A46,SCMPDS_2:66;
A49:    now
          let x be Int_position;
          assume
A50:      x in X;
A51:      now
            assume x in dom (t | A);
            then reconsider l=x as Instruction-Location of SCMPDS
            by A28,AMI_1:def 4;
            l=x;
            hence contradiction by SCMPDS_2:53;
          end;
          t5.x= Computation( t2,m2).x by A35,SCMPDS_4:23
            .=(Result t2).x by A16,AMI_1:122
            .=IExec(I,t).x by A51,FUNCT_4:12
            .=t.x by A6,A11,A12,A50
            .=s.x by A11,A50;
          then t7.x=s.x by A2,A36,A39,A41,A50,SCMPDS_2:60;
          hence t8.x=s.x by A46,SCMPDS_2:66;
        end;
A52:    t8.b=t7.b by A46,SCMPDS_2:66
          .=t.b+ -n by A36,A37,A39,A41,SCMPDS_2:60;
        -(-n) > 0 by A3;
        then -n < 0;
        then -n <= -1 by INT_1:21;
        then
A53:    -n+t.b <= -1+t.b by XREAL_1:8;
        t.b-1 <= k by A10,XREAL_1:22;
        then -n+t.b <= k by A53,XXREAL_0:2;
        then
A54:    FOR is_closed_on t8 & FOR is_halting_on t8 by A9,A48,A49, A52;
A55:    t8 +* iFOR=t8 by A47,Th37;
        now
          let k be Element of NAT;
          per cases;
          suppose k < m5;
            then k <= m3+1 by INT_1:20;
            then
A56:        k <= m3 or k=m3+1 by NAT_1:8;
            hereby
              per cases by A56,NAT_1:8;
              suppose
A57:            k <= m2;
                hereby
                  per cases;
                  suppose k=0;
                    hence IC  Computation( t3,k) in dom pFOR by A19,A20,
                    AMI_1:13;
                  end;
                  suppose k<>0;
                    then consider kn be Nat such that
A58:                k=kn+1 by NAT_1:6;
                    reconsider kn as Element of NAT by ORDINAL1:def 13;
                    kn < k by A58,XREAL_1:31;
                    then kn < m2 by A57,XXREAL_0:2;
                    then
A59:                IC  Computation( t2,kn) + 1 = IC Computation(t4,kn)
                    by A4,A15,A17,A18,A25,A27,A34,Th34;
A60:                IC  Computation( t2,kn) in dom pI by A14,SCMPDS_6:def 2;
  reconsider lm = IC  Computation( t2,kn) as Element of NAT by ORDINAL1:def 13;
                    lm < card pI by A60,SCMPDS_4:1;
                    then lm < card I+1 by SCMPDS_5:7;
                    then
A62:                lm+1 <= card I +1 by INT_1:20;
                    card I + 1 < card I + 4 by XREAL_1:8;
                    then lm+1 < card I +4 by A62,XXREAL_0:2;
                    then
A63:                lm+1 < card pFOR by Lm4;
                    IC  Computation( t3,k)=inspos lm +1 by A58,A59,
                    AMI_1:51
                      .=inspos (lm+1);
                    hence IC  Computation( t3,k) in dom pFOR by A63,SCMPDS_4:1;
                  end;
                end;
              end;
              suppose
A64:            k=m3;
                l1 in dom pFOR by A31,SCMPDS_6:18;
                hence IC  Computation( t3,k) in dom pFOR by A4,A15,A17,A18,A25
                ,A27,A34,A39,A64,Th36;
              end;
              suppose k=m3+1;
                hence IC  Computation( t3,k) in dom pFOR
                 by A42,A44,SCMPDS_6:18;
              end;
            end;
          end;
          suppose k >= m5;
            then consider nn be Nat such that
A65:        k=m5+nn by NAT_1:10;
            reconsider nn as Element of NAT by ORDINAL1:def 13;
            Computation(t3,k)= Computation( (t8 +* iFOR),nn)
            by A55,A65,AMI_1:51;
            hence IC  Computation( t3,k) in dom pFOR by A54,SCMPDS_6:def 2;
          end;
        end;
        hence FOR is_closed_on t by SCMPDS_6:def 2;
        t8 is halting by A54,A55,SCMPDS_6:def 3;
        then t3 is halting by AMI_1:93;
        hence FOR is_halting_on t by SCMPDS_6:def 3;
      end;
    end;
    hence P[k+1];
  end;
A66: for k being Element of NAT holds P[k] from NAT_1:sch 1(A7,A8);
  reconsider n=s.b as Element of NAT by A1,INT_1:16;
A67: P[n] by A66;
  for x be Int_position st x in X holds s.x=s.x;
  hence FOR is_closed_on s & FOR is_halting_on s by A67;
end;

theorem Th68:
  for s being State of SCMPDS,I being No-StopCode shiftable Program of SCMPDS,
  a be Int_position, i be Integer,n be Element of NAT,X be set
  st s.DataLoc(s.a,i) > 0 & not DataLoc(s.a,i) in X & n > 0 & card I > 0 &
  a <> DataLoc(s.a,i) & (for t be State of SCMPDS st
  (for x be Int_position st x in X holds t.x=s.x) & t.a=s.a
  holds IExec(I,t).a=t.a & IExec(I,t).DataLoc(s.a,i)=t.DataLoc(s.a,i) &
  I is_closed_on t & I is_halting_on t &
  for y be Int_position st y in X holds IExec(I,t).y=t.y) holds
  IExec(for-down(a,i,n,I),s) =
  IExec(for-down(a,i,n,I),IExec(I ';' AddTo(a,i,-n),s))
proof
  let s be State of SCMPDS,I be No-StopCode shiftable Program of SCMPDS,
  a be Int_position, i be Integer,n be Element of NAT,X be set;
  set b=DataLoc(s.a,i);
  set FOR=for-down(a,i,n,I), iFOR=Initialized stop FOR,
  iI= Initialized stop I, s1= s +* iFOR,
  ps= s | A;
  set i1=(a,i)<=0_goto (card I+3), i2=AddTo(a,i,-n), i3=goto -(card I+2);
  assume
A1: s.b > 0;
  assume
A2: not b in X;
  assume
A3: n > 0;
  assume
A4: card I > 0;
  assume
A5: a <> b;
  assume
A6: for t be State of SCMPDS st
  (for x be Int_position st x in X holds t.x=s.x) & t.a=s.a
  holds IExec(I,t).a=t.a & IExec(I,t).b=t.b
  & I is_closed_on t & I is_halting_on t &
  for y be Int_position st y in X holds IExec(I,t).y=t.y;
  then FOR is_halting_on s by A1,A2,A3,A4,A5,Th67;
  then
A7: s1 is halting by SCMPDS_6:def 3;
  set sI= s +* iI, m1=LifeSpan sI+3, J=I ';' AddTo(a,i,-n),
  sJ=s +* Initialized stop J, s2=IExec(J,s) +* iFOR,
  m2=LifeSpan s2;
  set Es=IExec(J,s), bj=DataLoc(Es.a,i);
A8: (for x be Int_position st x in X holds s.x=s.x) & s.a=s.a;
  then
A9: I is_closed_on s & I is_halting_on s by A6;
A10: IExec(I, s).a=s.a by A6,A8;
A11: Es.a=Exec(i2, IExec(I, s)).a by A9,Th50
    .=s.a by A5,A10,SCMPDS_2:60;
A12: now
    per cases;
    suppose Es.bj <= 0;
      hence FOR is_halting_on Es by Th63;
    end;
    suppose
A13:  Es.bj > 0;
      now
        let t be State of SCMPDS;
        assume
A14:    (for x be Int_position st x in X holds t.x=Es.x) & t.a=Es.a;
A15:    now
          let x be Int_position;
          assume
A16:      x in X;
          hence t.x=Es.x by A14
            .=Exec(i2, IExec(I, s)).x by A9,Th50
            .=IExec(I, s).x by A2,A10,A16,SCMPDS_2:60
            .=s.x by A6,A8,A16;
        end;
        hence IExec(I,t).a=t.a by A6,A11,A14;
        thus IExec(I,t).bj= t.bj by A6,A11,A14,A15;
        thus I is_closed_on t & I is_halting_on t &

for y be Int_position st y in X holds IExec(I,t).y=t.y by A6,A11,A14,A15;
      end;
      hence FOR is_halting_on Es by A2,A3,A4,A5,A11,A13,Th67;
    end;
  end;
  set s4 = Computation(s1,1);
A17: IExec(I,s).a=s.a & IExec(I,s).b=s.b by A6,A8;
A18: iI c= sI by FUNCT_4:26;
A19: sI is halting by A9,SCMPDS_6:def 3;
  then sI +* iI is halting by A18,FUNCT_4:79;
  then
A20: I is_halting_on sI by SCMPDS_6:def 3;
A21: I is_closed_on sI by A9,SCMPDS_6:38;
A22: IC s1 =inspos 0 by SCMPDS_6:21;
A23: FOR = i1 ';' (I ';' i2 ';' i3) by Th15;
A24:  Computation( s1,0+1) = Following  Computation( s1,0) by AMI_1:14
    .= Following s1 by AMI_1:13
    .= Exec(i1,s1) by A23,SCMPDS_6:22;
A25: not a in dom iFOR & a in dom s by SCMPDS_2:49,SCMPDS_4:31;
A26: not b in dom iFOR & b in dom s by SCMPDS_2:49,SCMPDS_4:31;
  s1.DataLoc(s1.a,i)=s1.b by A25,FUNCT_4:12
    .= s.b by A26,FUNCT_4:12;
  then
A27: IC s4 = Next IC s1 by A1,A24,SCMPDS_2:68
    .= inspos(0+1) by A22;
A28: DataPart sI = DataPart s1 by SCMPDS_4:24,36;
  now
    let a;
    thus sI.a = s1.a by A28,SCMPDS_4:23
      .= s4.a by A24,SCMPDS_2:68;
  end;
  then
A29: DataPart sI = DataPart s4 by SCMPDS_4:23;
  set mI=LifeSpan sI, s5= Computation( s4,mI), l1=inspos (card I + 1);
A30: dom (s | A) = A by SCMPDS_6:1;
A31: now
    assume a in dom (s | A);
    then reconsider l=a as Instruction-Location of SCMPDS by A30,AMI_1:def 4;
    l=a;
    hence contradiction by SCMPDS_2:53;
  end;
A32: now
    assume b in dom (s | A);
    then reconsider l=b as Instruction-Location of SCMPDS by A30,AMI_1:def 4;
    l=b;
    hence contradiction by SCMPDS_2:53;
  end;
  card I + 1 < card I + 3 by XREAL_1:8;
  then
A33: l1 in dom FOR by Th61;
A34: FOR c= iFOR by SCMPDS_6:17;
  iFOR c= s1 by FUNCT_4:26;
  then
A35: FOR c= s1 by A34,XBOOLE_1:1;
  Shift(I,1) c= FOR by Lm5;
  then Shift(I,1) c= s1 by A35,XBOOLE_1:1;
  then
A36: Shift(I,1) c= s4 by AMI_1:81;
  then
A37:  DataPart Computation(sI,mI) = DataPart s5 by A4,A18,A20,A21,A27,A29,Th36;
  then
A38: s5.a= Computation( sI,mI).a by SCMPDS_4:23
    .=(Result sI).a by A19,AMI_1:122
    .=s.a by A17,A31,FUNCT_4:12;
A39: s5.b= Computation( sI,mI).b by A37,SCMPDS_4:23
    .=(Result sI).b by A19,AMI_1:122
    .=s.b by A17,A32,FUNCT_4:12;
  set m3=mI +1;
  set s6= Computation( s1,m3);
A40: IC s5=l1 by A4,A18,A20,A21,A27,A29,A36,Th36;
A41: s6=s5 by AMI_1:51;
  then
A42: CurInstr s6=s5.l1 by A4,A18,A20,A21,A27,A29,A36,Th36
    .=s4.l1 by AMI_1:54
    .=s1.l1 by AMI_1:54
    .=FOR.l1 by A33,A35,GRFUNC_1:8
    .=i2 by Th62;
  set s7= Computation( s1,m3+1);
A43: s7 = Following s6 by AMI_1:14
    .= Exec(i2,s6) by A42;
  then
A44: IC s7=Next IC s6 by SCMPDS_2:60
    .=inspos(card I+1+1) by A40,A41,NAT_1:39
    .=inspos(card I+(1+1));
  set l2=inspos(card I+2);
  card I + 2 < card I + 3 by XREAL_1:8;
  then
A45: l2 in dom FOR by Th61;
A46: CurInstr s7=s1.l2 by A44,AMI_1:54
    .=FOR.l2 by A35,A45,GRFUNC_1:8
    .=i3 by Th62;
  set m5=m3+1+1, s8= Computation( s1,m5);
A47: s8 = Following s7 by AMI_1:14
    .= Exec(i3,s7) by A46;
  then
A48: IC s8=ICplusConst(s7,0-(card I+2)) by SCMPDS_2:66
    .=inspos 0 by A44,Th1;
A49: s8.b=s7.b by A47,SCMPDS_2:66
    .=s.b+ -n by A38,A39,A41,A43,SCMPDS_2:60;
A50: b=DataLoc(IExec(I, s).a,i) by A6,A8;
A51: Es.b=Exec(i2, IExec(I, s)).b by A9,Th50
    .=IExec(I, s).b+ -n by A10,SCMPDS_2:60
    .=s.b+ -n by A6,A8;
  now
    let x be Int_position;
A52: not x in dom iFOR & x in dom IExec(J,s) by SCMPDS_2:49,SCMPDS_4:31;
    then
A53: s2.x=IExec(J,s).x by FUNCT_4:12;
    per cases;
    suppose x=b;
      hence s8.x=s2.x by A49,A51,A52,FUNCT_4:12;
    end;
    suppose
A54:  x<>b;
A55:  now
        assume x in dom (s | A);
        then reconsider l=x as Instruction-Location of SCMPDS
        by A30,AMI_1:def 4;
        l=x;
        hence contradiction by SCMPDS_2:53;
      end;
A56:  s5.x= Computation( sI,mI).x by A37,SCMPDS_4:23
        .=(Result sI).x by A19,AMI_1:122
        .=IExec(I,s).x by A55,FUNCT_4:12;
A57:  s7.x=s5.x by A38,A41,A43,A54,SCMPDS_2:60;
      Es.x=Exec(i2, IExec(I, s)).x by A9,Th50
        .=IExec(I, s).x by A50,A54,SCMPDS_2:60;
      hence s8.x=s2.x by A47,A53,A56,A57,SCMPDS_2:66;
    end;
  end;
  then
A58: DataPart s8 = DataPart s2 by SCMPDS_4:23;
A59: IC s2 =IC Computation(s1,m1) by A48,SCMPDS_6:21;
A60: s2 is halting by A12,SCMPDS_6:def 3;
A61: dom ps = dom s /\ A by RELAT_1:90
    .= ({IC SCMPDS} \/ D \/ A) /\ A by SCMPDS_4:19
    .= A by XBOOLE_1:21;
  s2 | A=(Result sJ +* ps)|A +* iFOR | A by FUNCT_4:75
    .= ps +* iFOR | A by A61,FUNCT_4:24
    .= s1 | A by FUNCT_4:75
    .= Computation(s1,m1) | A by Th6;
  then
A62: Computation(s1,m1)=s2 by A58,A59,Th7;
  then
A63: CurInstr Computation(s1,m1)=i1 by A23,SCMPDS_6:22;
  set m0=LifeSpan s1;
  m0 > m1 by A7,A63,SCMPDS_6:2,30;
  then consider nn be Nat such that
A64: m0=m1+nn by NAT_1:10;
  reconsider nn as Element of NAT by ORDINAL1:def 13;
A65: Computation(s1,m0) = Computation(s2,nn) by A62,A64,AMI_1:51;
  then CurInstr Computation(s2,nn) =halt SCMPDS by A7,AMI_1:def 46;
  then
A66: nn >= m2 by A60,AMI_1:def 46;
  Computation(s1,m1+m2) = Computation(s2,m2) by A62,AMI_1:51;
  then CurInstr Computation(s1,m1+m2) = halt SCMPDS by A60,AMI_1:def 46;
  then m1 + m2 >= m0 by A7,AMI_1:def 46;
  then m2 >= nn by A64,XREAL_1:8;
  then nn=m2 by A66,XXREAL_0:1;
  then
A67: Result s1 = Computation(s2,m2) by A7,A65,AMI_1:122;
  IExec(J,s) | A= ps by A61,FUNCT_4:24;
  hence IExec(FOR,s) = IExec(FOR,IExec(J,s)) by A60,A67,AMI_1:122;
end;

registration
  let I be shiftable Program of SCMPDS,
  a be Int_position,i be Integer,n be Element of NAT;
  cluster for-down(a,i,n,I) -> shiftable;
  correctness
  proof
    set FOR=for-down(a,i,n,I), i1= (a,i)<=0_goto (card I +3),
    i2= AddTo(a,i,-n);
    reconsider PF= Load i1 ';' I ';' i2 as shiftable Program of SCMPDS;
    card PF=card (i1 ';' I) + 1 by SCMP_GCD:8
      .=card I + 1+1 by SCMPDS_6:15
      .=card I +(1+1);
    then card PF+ -(card I+2) =0;
    hence FOR is shiftable by SCMPDS_4:78;
  end;
end;

registration
  let I be No-StopCode Program of SCMPDS,
  a be Int_position,i be Integer,n be Element of NAT;
  cluster for-down(a,i,n,I) -> No-StopCode;
  correctness
  proof
    -(card I+2) <> 0;
    then reconsider i3=goto -(card I+2) as No-StopCode Instruction of SCMPDS
    by SCMPDS_5:25;
    for-down(a,i,n,I) =
    (a,i)<=0_goto (card I +3) ';' I ';' AddTo(a,i,-n) ';' i3;
    hence thesis;
  end;
end;

begin :: Two Examples for Summing

:: n=Sum 1+1+...+1

definition
  let n be Element of NAT;
  func sum(n) -> Program of SCMPDS equals

::Def04
  (GBP:=0) ';' ((GBP,2):=n) ';' ((GBP,3):=0) ';'
  for-down(GBP,2,1, Load AddTo(GBP,3,1));
  coherence;
end;

theorem Th69:
  for s being State of SCMPDS st s.GBP=0 holds
  for-down(GBP,2,1, Load AddTo(GBP,3,1)) is_closed_on s &
  for-down(GBP,2,1, Load AddTo(GBP,3,1)) is_halting_on s
proof
  let s be State of SCMPDS;
  set I= Load AddTo(GBP,3,1);
  assume
A1: s.GBP=0;
  per cases;
  suppose s.DataLoc(s.GBP,2) <= 0;
    hence thesis by Th63;
  end;
  suppose
A2: s.DataLoc(s.GBP,2) > 0;
    DataLoc(s.GBP,2)=intpos(0+2) by A1,SCMP_GCD:5;
    then DataLoc(s.GBP,2) <> GBP by AMI_3:52;
    then
A3: not DataLoc(s.GBP,2) in {GBP} by TARSKI:def 1;
A4: card I= 1 by SCMPDS_5:6;
    now
      let t be State of SCMPDS;
      assume
A5:   (for x be Int_position st x in {GBP} holds t.x=s.x) & t.GBP=s.GBP;
      set t0=Initialized t;
      t0.GBP=0 by A1,A5,SCMPDS_5:40;
      then
A6:   DataLoc(t0.GBP,3)=intpos(0+3) by SCMP_GCD:5;
thus
A8:   IExec(I,t).GBP=Exec(AddTo(GBP,3,1),t0).GBP by SCMPDS_5:45
        .=t0.GBP by A6,SCMPDS_2:60,AMI_3:52
        .=t.GBP by SCMPDS_5:40;
      set cv=DataLoc(s.GBP,2);
B9:   cv=intpos(0+2) by A1,SCMP_GCD:5;
thus
      IExec(I,t).cv=Exec(AddTo(GBP,3,1),t0).cv by SCMPDS_5:45
        .=t0.cv by B9,SCMPDS_2:60,A6,AMI_3:52
        .=t.cv by SCMPDS_5:40; thus
      I is_closed_on t & I is_halting_on t by SCMPDS_6:34,35;
      hereby
        let y be Int_position;
        assume y in {GBP};
        then y=GBP by TARSKI:def 1;
        hence IExec(I,t).y=t.y by A8;
      end;
    end;
    hence thesis by A1,A2,A3,A4,Th67;
  end;
end;

theorem Th70:
  for s being State of SCMPDS,n be Element of NAT st s.GBP=0 & s.intpos 2=n &
  s.intpos 3=0 holds
  IExec(for-down(GBP,2,1, Load AddTo(GBP,3,1)),s).intpos 3=n
proof
  let s be State of SCMPDS,n be Element of NAT;
  set i= AddTo(GBP,3,1), I= Load i, FD= for-down(GBP,2,1, I), a=intpos 3;
  assume
A1: s.GBP=0 & s.intpos 2=n & s.a=0;
  defpred P[Element of NAT] means
  for s be State of SCMPDS st s.intpos 2=$1 & s.GBP=0
  holds IExec(FD,s).a=$1+s.a;
A2: P[0]
  proof
    let s be State of SCMPDS;
    assume
A3: s.intpos 2=0 & s.GBP=0;
    then DataLoc(s.GBP,2)=intpos(0+2) by SCMP_GCD:5;
    hence IExec(FD,s).a =0+s.a by A3,Th66;
  end;
A4: now
    let k be Element of NAT;
    assume
A5: P[k];
    now
      let s be State of SCMPDS;
      assume
A6:   s.intpos 2=k+1 & s.GBP=0;
      then
A7:   DataLoc(s.GBP,2)=intpos(0+2) by SCMP_GCD:5;
      GBP <> DataLoc(s.GBP,2) by A6,SCMP_GCD:5;
      then
A8:   not DataLoc(s.GBP,2) in {GBP} by TARSKI:def 1;
A9:   card I= 1 by SCMPDS_5:6;
A10:  now
        let t be State of SCMPDS;
        assume
A11:    ( for x be Int_position st x in {GBP} holds t.x=s.x) & t.GBP=s.GBP;
        set t0=Initialized t;
        t0.GBP=0 by A6,A11,SCMPDS_5:40;
        then
A12:    DataLoc(t0.GBP,3)=intpos(0+3) by SCMP_GCD:5;
thus
A14:    IExec(I,t).GBP=Exec(AddTo(GBP,3,1),t0).GBP by SCMPDS_5:45
          .=t0.GBP by A12,SCMPDS_2:60,AMI_3:52
          .=t.GBP by SCMPDS_5:40;
        set cv=DataLoc(s.GBP,2);
A15:    cv <> DataLoc(t0.GBP,3) by A6,A12,AMI_3:52,SCMP_GCD:5; thus
        IExec(I,t).cv=Exec(AddTo(GBP,3,1),t0).cv by SCMPDS_5:45
          .=t0.cv by A15,SCMPDS_2:60
          .=t.cv by SCMPDS_5:40; thus
        I is_closed_on t & I is_halting_on t by SCMPDS_6:34,35;
        hereby
          let y be Int_position;
          assume y in {GBP};
          then y=GBP by TARSKI:def 1;
          hence IExec(I,t).y=t.y by A14;
        end;
      end;
      set j=AddTo(GBP,2,-1), s0=Initialized s, s1=IExec(I, s),
      s2=IExec(I ';'j,s), l2=intpos 2;
A16:  s0.GBP=0 by A6,SCMPDS_5:40;
      then
A17:  DataLoc(s0.GBP,3)=intpos(0+3) by SCMP_GCD:5;
A20:  s1.GBP=Exec(i, s0).GBP by SCMPDS_5:45
        .=0 by A16,A17,SCMPDS_2:60,AMI_3:52;
      then
A21:  DataLoc(s1.GBP,2)=intpos(0+2) by SCMP_GCD:5;
A23:  s2.a=Exec(j, s1).a by SCMPDS_5:46
        .=s1.a by A21,SCMPDS_2:60,AMI_3:52
        .=Exec(i, s0).a by SCMPDS_5:45
        .=s0.a+1 by A17,SCMPDS_2:60
        .=s.a+1 by SCMPDS_5:40;
A24:  s2.l2=Exec(j, s1).l2 by SCMPDS_5:46
        .=s1.l2+ -1 by A21,SCMPDS_2:60
        .=Exec(i, s0).l2+-1 by SCMPDS_5:45
        .=s0.l2+ -1 by A17,AMI_3:52,SCMPDS_2:60
        .=k+1+-1 by A6,SCMPDS_5:40
        .=k;
A26:  s2.GBP=Exec(j, s1).GBP by SCMPDS_5:46
        .=0 by A20,A21,AMI_3:52,SCMPDS_2:60;
      thus IExec(FD,s).a =IExec(FD,s2).a by A6,A7,A8,A9,A10,Th68
        .=k+s2.a by A5,A24,A26
        .=k+1+s.a by A23;
    end;
    hence P[k+1];
  end;
  for k be Element of NAT holds P[k] from NAT_1:sch 1(A2,A4);
  hence IExec(FD,s).a=n+0 by A1
    .=n;
end;

theorem
  for s being State of SCMPDS,n be Element of NAT
  holds IExec(sum(n),s).intpos 3 =n
proof
  let s be State of SCMPDS,n be Element of NAT;
  set i1= GBP:=0, i2= (GBP,2):=n, i3= (GBP,3):=0, i4= AddTo(GBP,3,1),
  FD= for-down(GBP,2,1, Load i4), a = intpos 3, I2=i1 ';' i2, s1=IExec(I2, s),
  s2=Exec(i1, Initialized s), I3=I2 ';' i3, s3=IExec(I3,s);
A1: s2.GBP=0 by SCMPDS_2:57;
  then
A2: DataLoc(s2.GBP,2)=intpos(0+2) by SCMP_GCD:5;
A4: s1.GBP=Exec(i2, s2).GBP by SCMPDS_5:47
    .=0 by A1,A2,SCMPDS_2:58,AMI_3:52;
  then
A5: DataLoc(s1.GBP,3)=intpos(0+3) by SCMP_GCD:5;
A8: s3.a=Exec(i3,s1).a by SCMPDS_5:46
    .=0 by A5,SCMPDS_2:58;
A9: s3.GBP=Exec(i3,s1).GBP by SCMPDS_5:46
    .=0 by A4,A5,SCMPDS_2:58,AMI_3:52;
A10: s3.intpos 2=Exec(i3,s1).intpos 2 by SCMPDS_5:46
    .=s1.intpos 2 by A5,AMI_3:52,SCMPDS_2:58
    .=Exec(i2, s2).intpos 2 by SCMPDS_5:47
    .=n by A2,SCMPDS_2:58;
A11: I3 is_closed_on s & I3 is_halting_on s by SCMPDS_6:34,35;
  FD is_closed_on s3 & FD is_halting_on s3 by A9,Th69;
  hence IExec(sum(n),s).a = IExec(FD,s3).a by A11,Th49
    .= n by A8,A9,A10,Th70;
end;

:: sum=Sum x1+x2+...+x2

definition
  let sp,control,result,pp,pData be Element of NAT;
  func sum(sp,control,result,pp,pData) -> Program of SCMPDS equals

::Def05
  ((intpos sp,result):=0) ';' (intpos pp:=pData) ';'
  for-down(intpos sp,control,1, AddTo(intpos sp,result,intpos pData,0)
  ';' AddTo(intpos pp,0,1));
  coherence;
end;

theorem Th72:
  for s being State of SCMPDS,sp,cv,result,pp,pD be Element of NAT
  st s.intpos sp > sp & cv < result & s.intpos pp=pD &
  s.intpos sp+result < pp & pp <pD & pD < s.intpos pD holds
  for-down(intpos sp,cv,1, AddTo(intpos sp,result,intpos pD,0) ';'
  AddTo(intpos pp,0,1)) is_closed_on s &
  for-down(intpos sp,cv,1, AddTo(intpos sp,result,intpos pD,0) ';'
  AddTo(intpos pp,0,1)) is_halting_on s
proof
  let s be State of SCMPDS, sp,cv,fr,pp,pD be Element of NAT;
  set BP=intpos sp, PD=intpos pD, PP=intpos pp;
  assume
A1: s.BP > sp & cv < fr & s.PP=pD & s.BP+fr <pp & pp < pD & pD < s.PD;
  set i2= AddTo(BP,fr,PD,0), i3= AddTo(PP,0,1), I= i2 ';' i3;
  per cases;
  suppose s.DataLoc(s.BP,cv) <= 0;
    hence thesis by Th63;
  end;
  suppose
A2: s.DataLoc(s.BP,cv) > 0;
    reconsider n=s.BP as Element of NAT by A1,INT_1:16;
    n+cv <> sp by A1,NAT_1:11;
    then abs(n+cv) <> sp by ABSVALUE:def 1;
    then
A3: DataLoc(s.BP,cv) <> BP by ZFMISC_1:33;
A4: n+fr > n+cv by A1,XREAL_1:8;
    n+cv <> pp by A1,XREAL_1:8;
    then abs(n+cv) <> pp by ABSVALUE:def 1;
    then DataLoc(s.BP,cv) <> PP by ZFMISC_1:33;
    then
A5: not DataLoc(s.BP,cv) in {BP,PP} by A3,TARSKI:def 2;
A6: card I= 2 by SCMP_GCD:9;
    now
      let t be State of SCMPDS;
      assume
A7:   (for x be Int_position st x in {BP,PP} holds t.x=s.x) & t.BP=s.BP;
      set t0=Initialized t, t1=Exec(i2, t0);
A8:   DataLoc(t0.BP,fr)=DataLoc(n,fr) by A7,SCMPDS_5:40
        .=intpos(n+fr) by SCMP_GCD:5;
      then
A9:   abs(t0.BP+fr) = n+fr by ZFMISC_1:33;
      n+fr <> sp by A1,NAT_1:11;
      then DataLoc(t0.BP,fr) <> BP by A8,ZFMISC_1:33;
      then
A10:  t1.BP=t0.BP by SCMPDS_2:61
        .=t.BP by SCMPDS_5:40;
A11:  PP in {BP,PP} by TARSKI:def 2;
      DataLoc(t0.BP,fr) <> PP by A1,A8,ZFMISC_1:33;
      then
A12:  t1.PP=t0.PP by SCMPDS_2:61
        .=t.PP by SCMPDS_5:40;
      then t1.PP=pD by A1,A7,A11;
      then
A13:  DataLoc(t1.PP,0)=intpos (pD+0) by SCMP_GCD:5;
      then
A14:  abs(t1.PP+0) = pD by ZFMISC_1:33;
      n <= n+fr by NAT_1:11;
      then sp < n+fr by A1,XXREAL_0:2;
      then abs(t1.PP+0) <> sp by A1,A14,XXREAL_0:2;
      then
A15:  DataLoc(t1.PP,0) <> BP by ZFMISC_1:33; thus
A16:  IExec(I,t).BP=Exec(i3, t1).BP by SCMPDS_5:47
        .=t.BP by A10,A15,SCMPDS_2:60;
A17:  IExec(I,t).PP=Exec(i3, t1).PP by SCMPDS_5:47
        .=t.PP by A1,A12,A13,SCMPDS_2:60;
      set Dv=DataLoc(s.BP,cv);
      Dv=intpos(n+cv) by SCMP_GCD:5;
      then
A18:  abs(s.BP+cv) = n+cv by ZFMISC_1:33;
      then abs(t0.BP+fr) <> abs(s.BP+cv) by A1,A9;
      then
A19:  DataLoc(t0.BP,fr) <> Dv by ZFMISC_1:33;
      abs(t1.PP+0) <> abs(s.BP+cv) by A1,A4,A14,A18,XXREAL_0:2;
      then
A20:  DataLoc(t1.PP,0) <> Dv by ZFMISC_1:33; thus
      IExec(I,t).Dv=Exec(i3, t1).Dv by SCMPDS_5:47
        .=t1.Dv by A20,SCMPDS_2:60
        .=t0.Dv by A19,SCMPDS_2:61
        .=t.Dv by SCMPDS_5:40; thus
      I is_closed_on t & I is_halting_on t by SCMPDS_6:34,35;
      hereby
        let y be Int_position;
        assume
A21:    y in {BP,PP};
        per cases by A21,TARSKI:def 2;
        suppose y=BP;
          hence IExec(I,t).y=t.y by A16;
        end;
        suppose y=PP;
          hence IExec(I,t).y=t.y by A17;
        end;
      end;
    end;
    hence thesis by A2,A3,A5,A6,Th67;
  end;
end;

theorem Th73:
  for s being State of SCMPDS,sp,cv,result,pp,pD be Element of NAT,
  f be FinSequence of NAT st s.intpos sp > sp & cv < result & s.intpos pp=pD &
  s.intpos sp+result < pp & pp <pD & pD < s.intpos pD &
  s.DataLoc(s.intpos sp,result)=0 & len f = s.DataLoc(s.intpos sp,cv) &
  for k be Element of NAT st k < len f holds f.(k+1)=s.DataLoc(s.intpos pD,k)
  holds IExec(for-down(intpos sp,cv,1, AddTo(intpos sp,result,intpos pD,0)
  ';' AddTo(intpos pp,0,1)),s).DataLoc(s.intpos sp,result)=Sum f
proof
  let s be State of SCMPDS, sp,cv,fr,pp,pD be Element of NAT,
  f be FinSequence of NAT;
  set BP=intpos sp, PD=intpos pD, PP=intpos pp;
  assume
A1: s.BP > sp & cv < fr & s.PP=pD & s.BP+fr <pp
  & pp < pD & pD < s.PD & s.DataLoc(s.BP,fr)=0 & len f = s.DataLoc(s.BP,cv) &
  for k be Element of NAT st k < len f holds f.(k+1)=s.DataLoc(s.PD,k);
  set i2= AddTo(BP,fr,PD,0), i3= AddTo(PP,0,1), I= i2 ';' i3,
  FD= for-down(BP,cv,1,I), a=DataLoc(s.BP,fr);
  defpred P[Element of NAT] means
  for t be State of SCMPDS,f be FinSequence of NAT
  st t.BP=s.BP & t.PP=pD & pD < t.PD & len f = t.DataLoc(t.BP,cv) &
  len f=$1 & for k be Element of NAT st k < len f
  holds f.(k+1)=t.DataLoc(t.PD,k) holds IExec(FD,t).a=Sum f+t.a;
  now
    let t be State of SCMPDS,f be FinSequence of NAT;
    assume
A2: t.BP=s.BP & t.PP=pD & pD < t.PD & len f = t.DataLoc(t.BP,cv) & len f=0 &
    for k be Element of NAT st k < len f holds f.(k+1)=t.DataLoc(t.PD,k);
    then Sum f=0 by FINSEQ_1:32,RVSUM_1:102;
    hence IExec(FD,t).a =Sum f + t.a by A2,Th66;
  end;
  then
A3: P[0];
  reconsider n=s.BP as Element of NAT by A1,INT_1:16;
A4: n+fr > n+cv by A1,XREAL_1:8;
  then
A5: n+cv < pp by A1,XXREAL_0:2;
  n <= n+fr by NAT_1:11;
  then
A6: sp < n+fr by A1,XXREAL_0:2;
A7: n+cv < pD by A1,A5,XXREAL_0:2;
A8: n+fr < pD by A1,XXREAL_0:2;
A9: now
    let k be Element of NAT;
    assume
A10: P[k];
    now
      let t be State of SCMPDS,f be FinSequence of NAT;
      assume
A11:  t.BP=s.BP & t.PP=pD & pD < t.PD &
      len f = t.DataLoc(t.BP,cv) & len f=k+1 &
      for i be Element of NAT st i < len f holds f.(i+1)=t.DataLoc(t.PD,i);
      n+cv <> sp by A1,NAT_1:11;
      then abs(n+cv) <> sp by ABSVALUE:def 1;
      then
A12:  DataLoc(t.BP,cv) <> BP by A11,ZFMISC_1:33;
      n+cv <> pp by A1,XREAL_1:8;
      then abs(n+cv) <> pp by ABSVALUE:def 1;
      then DataLoc(s.BP,cv) <> PP by ZFMISC_1:33;
      then
A13:  not DataLoc(t.BP,cv) in {BP,PP} by A11,A12,TARSKI:def 2;
A14:  card I= 2 by SCMP_GCD:9;
A15:  now
        let u be State of SCMPDS;
        assume
A16:    ( for x be Int_position st x in {BP,PP} holds u.x=t.x) & u.BP=t.BP;
        set t0=Initialized u, t1=Exec(i2, t0);
A17:    DataLoc(t0.BP,fr)=DataLoc(n,fr) by A11,A16,SCMPDS_5:40
          .=intpos(n+fr) by SCMP_GCD:5;
        then
A18:    abs(t0.BP+fr) = n+fr by ZFMISC_1:33;
        then
A19:    t1.BP=t0.BP by A1,A17,SCMPDS_2:61
          .=u.BP by SCMPDS_5:40;
A20:    PP in {BP,PP} by TARSKI:def 2;
A21:    t1.PP=t0.PP by A1,A17,A18,SCMPDS_2:61
          .=u.PP by SCMPDS_5:40;
        then
A22:    t1.PP=pD by A11,A16,A20;
        then
A23:    DataLoc(t1.PP,0)=intpos (pD+0) by SCMP_GCD:5;
        then
A24:    abs(t1.PP+0)=pD+0 by ZFMISC_1:33;
        t1.PP+0 <> sp by A1,A6,A22,XXREAL_0:2;
        then abs(t1.PP+0) <> sp by A22,ABSVALUE:def 1;
        then
A25:    DataLoc(t1.PP,0) <> BP by ZFMISC_1:33; thus
A26:    IExec(I,u).BP=Exec(i3, t1).BP by SCMPDS_5:47
          .=u.BP by A19,A25,SCMPDS_2:60;
A27:    IExec(I,u).PP=Exec(i3, t1).PP by SCMPDS_5:47
          .=u.PP by A1,A21,A23,SCMPDS_2:60;
        set Dv=DataLoc(t.BP,cv);
        Dv=intpos(n+cv) by A11,SCMP_GCD:5;
        then
A28:    abs(t.BP+cv) = n+cv by ZFMISC_1:33;
        then abs(t0.BP+fr) <> abs(t.BP+cv) by A1,A18;
        then
A29:    DataLoc(t0.BP,fr) <> Dv by ZFMISC_1:33;
        abs(t1.PP+0) <> abs(t.BP+cv) by A1,A4,A24,A28,XXREAL_0:2;
        then
A30:    DataLoc(t1.PP,0) <> Dv by ZFMISC_1:33; thus
        IExec(I,u).Dv=Exec(i3, t1).Dv by SCMPDS_5:47
          .=t1.Dv by A30,SCMPDS_2:60
          .=t0.Dv by A29,SCMPDS_2:61
          .=u.Dv by SCMPDS_5:40; thus
        I is_closed_on u & I is_halting_on u by SCMPDS_6:34,35;
        hereby
          let y be Int_position;
          assume
A31:      y in {BP,PP};
          per cases by A31,TARSKI:def 2;
          suppose y=BP;
            hence IExec(I,u).y=u.y by A26;
          end;
          suppose y=PP;
            hence IExec(I,u).y=u.y by A27;
          end;
        end;
      end;
      set j=AddTo(BP,cv,-1), s2=IExec(I ';'j,t), g=Del(f,1);
      set t0=Initialized t, t1=Exec(i2, t0);
A32:  DataLoc(t0.BP,fr)=DataLoc(n,fr) by A11,SCMPDS_5:40
        .=intpos(n+fr) by SCMP_GCD:5;
      then
A33:  abs(t0.BP+fr) = n+fr by ZFMISC_1:33;
      then
A34:  t1.BP = t0.BP by A1,A32,SCMPDS_2:61
        .=t.BP by SCMPDS_5:40;
      t1.PP=t0.PP by A1,A32,A33,SCMPDS_2:61
        .=t.PP by SCMPDS_5:40;
      then
A35:  DataLoc(t1.PP,0)=intpos (pD+0) by A11,SCMP_GCD:5;
      then
A36:  abs(t1.PP+0)=pD+0 by ZFMISC_1:33;
      then abs(t1.PP+0) <> sp by A1,A6,XXREAL_0:2;
      then
A37:  DataLoc(t1.PP,0) <> BP by ZFMISC_1:33;
      set It=IExec(I,t);
A38:  It.BP=Exec(i3, t1).BP by SCMPDS_5:47
        .=t.BP by A34,A37,SCMPDS_2:60;
      then
A39:  DataLoc(It.BP,cv)=intpos(n+cv) by A11,SCMP_GCD:5;
      then
A40:  abs(It.BP+cv)=n+cv by ZFMISC_1:33;
      then abs(It.BP+cv) <> sp by A1,NAT_1:11;
      then
A41:  DataLoc(It.BP,cv) <> BP by ZFMISC_1:33;
A42:  s2.BP=Exec(j, It).BP by SCMPDS_5:46
        .=s.BP by A11,A38,A41,SCMPDS_2:60;
      1 <= k+1 by NAT_1:11;
      then 1 in Seg (k+1) by FINSEQ_1:3;
      then
A43:  1 in dom f by A11,FINSEQ_1:def 3;
      then
A44:  len g +1=len f by WSIERP_1:def 1;
A45:  DataLoc(s2.BP,cv)=intpos(n+cv) by A42,SCMP_GCD:5;
      abs(t1.PP+0) <> n+cv by A1,A4,A36,XXREAL_0:2;
      then
A46:  DataLoc(t1.PP,0) <> intpos(n+cv) by ZFMISC_1:33;
      abs(t0.BP+fr) <> n+cv by A1,A33;
      then
A47:  DataLoc(t0.BP,fr)<> intpos(n+cv) by ZFMISC_1:33;
A48:  It.intpos(n+cv)=Exec(i3, t1).intpos(n+cv) by SCMPDS_5:47
        .=t1.intpos(n+cv) by A46,SCMPDS_2:60
        .=t0.intpos(n+cv) by A47,SCMPDS_2:61
        .=t.intpos(n+cv) by SCMPDS_5:40
        .=k+1 by A11,SCMP_GCD:5;
A49:  s2.DataLoc(s2.BP,cv)=Exec(j, It).intpos(n+cv) by A45,SCMPDS_5:46
        .=It.intpos(n+cv)+ -1 by A39,SCMPDS_2:60
        .=len g by A11,A44,A48;
      1 <= len f by A11,NAT_1:11;
      then
A50:  1 in dom f by FINSEQ_3:27;
A51:  f.(0+1)=t.DataLoc(t.PD,0) by A11
        .=t0.DataLoc(t.PD,0) by SCMPDS_5:40
        .=t0.DataLoc(t0.PD,0) by SCMPDS_5:40;
A52:  a=intpos(n+fr) by SCMP_GCD:5;
      n+fr <> abs(It.BP+cv) by A1,A40;
      then
A53:  a <> DataLoc(It.BP,cv) by A52,ZFMISC_1:33;
A54:  It.a=Exec(i3, t1).a by SCMPDS_5:47
        .=t1.a by A1,A35,SCMPDS_2:60
        .=t0.a + f.1 by A32,A33,A51,SCMPDS_2:61
        .=t.a + f.1 by SCMPDS_5:40;
A55:  s2.a=Exec(j, It).a by SCMPDS_5:46
        .=f.1+t.a by A53,A54,SCMPDS_2:60;
      pp <> abs(It.BP+cv) by A1,A40,XREAL_1:8;
      then
A56:  PP <> DataLoc(It.BP,cv) by ZFMISC_1:33;
A57:  s2.PP=Exec(j, It).PP by SCMPDS_5:46
        .=It.PP by A56,SCMPDS_2:60
        .=Exec(i3, t1).PP by SCMPDS_5:47
        .=t1.PP by A1,A35,SCMPDS_2:60
        .=t0.PP by A1,A32,A33,SCMPDS_2:61
        .=pD by A11,SCMPDS_5:40;
      pD <> abs(It.BP+cv) by A1,A4,A40,XXREAL_0:2;
      then
A58:  PD <> DataLoc(It.BP,cv) by ZFMISC_1:33;
A59:  s2.PD=Exec(j, It).PD by SCMPDS_5:46
        .=It.PD by A58,SCMPDS_2:60
        .=Exec(i3, t1).PD by SCMPDS_5:47
        .=t1.PD+1 by A35,SCMPDS_2:60
        .=t0.PD+1 by A1,A32,A33,SCMPDS_2:61
        .=t.PD+1 by SCMPDS_5:40;
      then t.PD < s2.PD by XREAL_1:31;
      then
A60:  pD < s2.PD by A11,XXREAL_0:2;
A61:  now
        let i be Element of NAT;
        assume
A62:    i < len g;
        set SD=DataLoc(s2.PD,i);
        reconsider m=t.PD as Element of NAT by A11,INT_1:16;
        SD=intpos(m+1+i) by A59,SCMP_GCD:5
          .=intpos(m+(1+i));
        then
A63:    abs(s2.PD+i) = m+(1+i) by ZFMISC_1:33;
A64:    n+cv < m by A7,A11,XXREAL_0:2;
A65:    m <= m+(1+i) by NAT_1:11;
        abs(s2.PD+i) <> abs(It.BP+cv) by A40,A63,A64,NAT_1:11;
        then
A66:    SD <> DataLoc(It.BP,cv) by ZFMISC_1:33;
        abs(t1.PP+0) <> abs(s2.PD+i) by A11,A36,A63,NAT_1:11;
        then
A67:    DataLoc(t1.PP,0) <> SD by ZFMISC_1:33;
        abs(t0.BP+fr)<> abs(s2.PD+i)by A8,A11,A33,A63,A65,XXREAL_0:2;
        then
A68:    DataLoc(t0.BP,fr)<> SD by ZFMISC_1:33;
A69:    s2.SD=Exec(j, It).SD by SCMPDS_5:46
          .=It.SD by A66,SCMPDS_2:60
          .=Exec(i3, t1).SD by SCMPDS_5:47
          .=t1.SD by A67,SCMPDS_2:60
          .=t0.SD by A68,SCMPDS_2:61
          .=t.SD by SCMPDS_5:40;
A70:    i+1 < len g+1 by A62,XREAL_1:8;
        0+1 <= i+1 by XREAL_1:8;
        hence g.(i+1)=f.(i+1+1) by A43,WSIERP_1:def 1
          .=t.DataLoc(t.PD,i+1) by A11,A44,A70
          .=s2.SD by A63,A69;
      end;
X:      f is FinSequence of REAL by FINSEQ_2:27;
      thus IExec(FD,t).a =IExec(FD,s2).a by A11,A12,A13,A14,A15,Th68
        .=Sum g+s2.a by A10,A11,A42,A44,A49,A57,A60,A61
        .=Sum g+f.1+t.a by A55
        .=Sum f+t.a by A50,WSIERP_1:27,X;
    end;
    hence P[k+1];
  end;
  for k be Element of NAT holds P[k] from NAT_1:sch 1(A3,A9);
  hence IExec(FD,s).a=Sum f+0 by A1
    .=Sum f;
end;

theorem
  for s being State of SCMPDS,sp,cv,result,pp,pD be Element of NAT,
  f be FinSequence of NAT st
  s.intpos sp > sp & cv < result & s.intpos sp+result < pp
  & pp <pD & pD < s.intpos pD & len f = s.DataLoc(s.intpos sp,cv) &
  for k be Element of NAT st k < len f holds f.(k+1)=s.DataLoc(s.intpos pD,k)
  holds IExec(sum(sp,cv,result,pp,pD),s).DataLoc(s.intpos sp,result)=Sum f
proof
  let s be State of SCMPDS, sp,cv,fr,pp,pD be Element of NAT,
  f be FinSequence of NAT;
  set BP=intpos sp, PD=intpos pD, PP=intpos pp;
  assume
A1: s.BP > sp & cv < fr & s.BP+fr <pp
  & pp < pD & pD < s.PD & len f = s.DataLoc(s.BP,cv) &
  for k be Element of NAT st k < len f holds f.(k+1)=s.DataLoc(s.PD,k);
  set i0= (BP,fr):=0, i1= PP:=pD, Hi= i0 ';' i1, i2= AddTo(BP,fr,PD,0),
  i3= AddTo(PP,0,1), FD= for-down(BP,cv,1,i2 ';' i3), s2=IExec(Hi,s),
  s0=Initialized s, s1=Exec(i0, s0), a =DataLoc(s.BP,fr),
  a1=DataLoc(s2.BP,fr);
  reconsider n=s.BP as Element of NAT by A1,INT_1:16;
  n <= n+fr by NAT_1:12;
  then sp <> pp by A1,XXREAL_0:2;
  then
A2: BP <> PP by ZFMISC_1:33;
A3: DataLoc(s0.BP,fr)=DataLoc(n,fr) by SCMPDS_5:40
    .=intpos(n+fr) by SCMP_GCD:5;
  then
A4: abs(s0.BP+fr) = n+fr by ZFMISC_1:33;
  then abs(s0.BP+fr) <> sp by A1,NAT_1:12;
  then
A5: DataLoc(s0.BP,fr) <> BP by ZFMISC_1:33;
A6: s2.BP=Exec(i1, s1).BP by SCMPDS_5:47
    .=s1.BP by A2,SCMPDS_2:57
    .=s0.BP by A5,SCMPDS_2:58
    .=n by SCMPDS_5:40;
A7: s2.PP=Exec(i1, s1).PP by SCMPDS_5:47
    .=pD by SCMPDS_2:57;
A8: PD <> PP by A1,ZFMISC_1:33;
A9: n+fr < pD by A1,XXREAL_0:2;
A10: DataLoc(s0.BP,fr) <> PD by A1,A3,ZFMISC_1:33;
A11: s2.PD=Exec(i1, s1).PD by SCMPDS_5:47
    .=s1.PD by A8,SCMPDS_2:57
    .=s0.PD by A10,SCMPDS_2:58
    .=s.PD by SCMPDS_5:40;
A12: intpos(n+fr) <> PP by A1,ZFMISC_1:33;
A13: s2.DataLoc(s2.BP,fr)=s2.intpos(n+fr) by A6,SCMP_GCD:5
    .=Exec(i1, s1).intpos(n+fr) by SCMPDS_5:47
    .=s1.intpos(n+fr) by A12,SCMPDS_2:57
    .=0 by A3,SCMPDS_2:58;
  n+cv <> pp by A1,XREAL_1:8;
  then
A14: intpos(n+cv) <> PP by ZFMISC_1:33;
  abs(s0.BP+fr) <> n+cv by A1,A4;
  then
A15: DataLoc(s0.BP,fr) <> intpos(n+cv) by ZFMISC_1:33;
A16: s2.DataLoc(s2.BP,cv)=s2.intpos(n+cv) by A6,SCMP_GCD:5
    .=Exec(i1, s1).intpos(n+cv) by SCMPDS_5:47
    .=s1.intpos(n+cv) by A14,SCMPDS_2:57
    .=s0.intpos(n+cv) by A15,SCMPDS_2:58
    .=s.intpos(n+cv) by SCMPDS_5:40
    .=len f by A1,SCMP_GCD:5;
A17: now
    let k be Element of NAT;
    assume
A18: k < len f;
    reconsider m=s.PD as Element of NAT by A1,INT_1:16;
A19: pp < m by A1,XXREAL_0:2;
A20: m <= m + k by NAT_1:11;
    m+k <> pp by A19,NAT_1:11;
    then
A21: intpos(m+k) <> PP by ZFMISC_1:33;
    abs(s0.BP+fr) <> m+k by A1,A4,A9,A20,XXREAL_0:2;
    then
A22: DataLoc(s0.BP,fr) <> intpos(m+k) by ZFMISC_1:33;
    thus s2.DataLoc(s2.PD,k)=s2.intpos(m+k) by A11,SCMP_GCD:5
      .=Exec(i1, s1).intpos(m+k) by SCMPDS_5:47
      .=s1.intpos(m+k) by A21,SCMPDS_2:57
      .=s0.intpos(m+k) by A22,SCMPDS_2:58
      .=s.intpos(m+k) by SCMPDS_5:40
      .=s.DataLoc(s.PD,k) by SCMP_GCD:5
      .=f.(k+1) by A1,A18;
  end;
A23: Hi is_closed_on s & Hi is_halting_on s by SCMPDS_6:34,35;
  FD is_closed_on s2 & FD is_halting_on s2 by A1,A6,A7,A11,Th72;
  hence IExec(sum(sp,cv,fr,pp,pD),s).a = IExec(FD,s2).a1 by A6,A23,Th49
    .= Sum f by A1,A6,A7,A11,A13,A16,A17,Th73;
end;

