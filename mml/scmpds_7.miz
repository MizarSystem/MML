:: The Construction and Computation of For-loop Programs for SCMPDS
::  by JingChao Chen and Piotr Rudnicki
::
:: Received December 27, 1999
:: Copyright (c) 1999 Association of Mizar Users

environ

 vocabularies AMI_3, SCMPDS_2, AMI_1, INT_1, SCMPDS_4, AMI_2, SCMPDS_3,
      ARYTM_1, ABSVALUE, AMI_5, RELAT_1, BOOLE, FUNCT_1, RELOC, SCMFSA6A,
      FUNCT_4, CAT_1, CARD_1, SCMFSA_7, FUNCT_7, UNIALG_2, SCMFSA7B, SCM_1,
      SCMFSA6B, SCMPDS_5, SFMASTR3, SEMI_AF1, SCMP_GCD, FINSEQ_1, RLVECT_1,
      MATRIX_2, SCMPDS_7, ARYTM, AMISTD_2;
 notations TARSKI, XBOOLE_0, ENUMSET1, SUBSET_1, CARD_1, NUMBERS, XCMPLX_0,
      XXREAL_0, COMPLEX1, RELAT_1, FUNCT_1, FUNCT_4, INT_1, NAT_1, FUNCOP_1,
      STRUCT_0, AMI_1, SCMNORM, AMI_2, AMI_3, FUNCT_7, SCMPDS_2, SCMPDS_3,
      SCMPDS_4, SCMPDS_5, SCMPDS_6, SCMP_GCD, FINSEQ_1, WSIERP_1;
 constructors ENUMSET1, XXREAL_0, REAL_1, NAT_1, INT_2, WSIERP_1, SCM_1,
      SCMPDS_4, SCMPDS_5, SCMPDS_6, SCMP_GCD, SEQ_1, SCMNORM, SCMPDS_3;
 registrations SETFAM_1, FUNCT_1, ORDINAL1, RELSET_1, FUNCOP_1, NUMBERS,
      XXREAL_0, XREAL_0, NAT_1, INT_1, CARD_3, SCMPDS_2, SCMPDS_4, SCMPDS_5,
      XBOOLE_0, VALUED_0, SCMNORM, FINSEQ_1, CARD_1, VALUED_1;
 requirements REAL, NUMERALS, SUBSET, BOOLE, ARITHM;
 definitions FUNCOP_1, AMI_1, AMI_3, SCMPDS_2, SCMP_GCD, SCMPDS_4, SCMPDS_3,
      SCMNORM;
 theorems AMI_1, AMI_3, NAT_1, FUNCOP_1, TARSKI, FUNCT_4, FUNCT_1, INT_1,
      SCMPDS_2, FUNCT_7, SCMPDS_3, ABSVALUE, GRFUNC_1, SCMPDS_4, SCMPDS_5,
      SCMPDS_6, ENUMSET1, SCMP_GCD, LATTICE2, WSIERP_1, FINSEQ_1, RVSUM_1,
      RELAT_1, FINSEQ_3, XBOOLE_0, XBOOLE_1, XREAL_1, ORDINAL1, XXREAL_0,
      AMI_2, ZFMISC_1, FINSEQ_2, VALUED_1, SCMNORM, CARD_3;
 schemes NAT_1;

begin :: Preliminaries

reserve x for set,
  m,n for Element of NAT,
  a,b for Int_position,
  i,j,k for
  Instruction of SCMPDS,
  s,s1,s2 for State of SCMPDS,
  k1,k2 for Integer,
  loc,l
  for Instruction-Location of SCMPDS,
  I,J,K for Program of SCMPDS;
set A = NAT;
set D = SCM-Data-Loc;

theorem Th1: ::SCMPDS_6:23
  for s being State of SCMPDS,m,n being Element of NAT st IC s=
  inspos m holds ICplusConst(s,n-m)=inspos n
proof
  let s be State of SCMPDS,m,n be Element of NAT;
  consider k be Element of NAT such that
A1: k = IC s and
A2: ICplusConst(s,n-m) = abs(k+(n-m)) by SCMPDS_2:def 20;
  assume
  IC s=inspos m;
  then k=il.m by A1
    .=m;
  hence ICplusConst(s,n-m) =il.n by A2,ABSVALUE:def 1
    .=inspos n;
end;

canceled 2;

theorem Th4:
  IC s = inspos 0 implies Initialized s = s
proof
  assume
A1: IC s = inspos 0;
A2: IC SCMPDS in dom s by AMI_1:94;
  thus Initialized s = s +* (IC SCMPDS .--> inspos 0) by SCMPDS_5:def 4
    .= s by A1,A2,FUNCT_7:111;
end;

theorem Th5:
  IC s = inspos 0 implies s +* Initialized I = s +* I
proof
  set SA0=Start-At inspos 0;
A1: dom I misses dom SA0 by SCMPDS_4:54;
  assume
  IC s = inspos 0;
  then Initialized s = s by Th4;
  hence s +* I =s +* SA0 +* I by SCMPDS_5:def 4
    .= s +* (SA0 +* I) by FUNCT_4:15
    .= s +* Initialized I by A1,FUNCT_4:36;
end;

theorem Th6:
  Computation(s,n) | NAT = s | NAT
proof
  for x be Instruction-Location of SCMPDS holds Computation(s,n).x=s.x by
  AMI_1:54;
  hence thesis by SCMPDS_4:21;
end;

theorem Th7:
  for s1,s2 being State of SCMPDS st IC s1= IC s2 & DataPart s1 =
  DataPart s2 & s1 | NAT = s2 | NAT holds s1=s2
proof
  let s1,s2 be State of SCMPDS;
  assume that
A1: IC s1= IC s2 and
A2: DataPart s1 = DataPart s2 and
A3: s1 | A = s2 | A;
A4: dom s2 ={IC SCMPDS} \/ D \/ A by SCMPDS_4:19;
A5: dom s1 ={IC SCMPDS} \/ D \/ A by SCMPDS_4:19;
  then s1|{IC SCMPDS} = s2|{IC SCMPDS} by A1,A4,GRFUNC_1:90;
  then s1|({IC SCMPDS} \/ D) = s2| ({IC SCMPDS} \/ D) by A2,RELAT_1:185,
  SCMPDS_2:100;
  then s1|({IC SCMPDS} \/ D \/ A) = s2| ({IC SCMPDS} \/ D \/ A) by A3,
  RELAT_1:185;
  hence s1=s2 | dom s2 by A5,A4,RELAT_1:97
    .=s2 by RELAT_1:97;
end;

theorem Th8:
  for l being Nat holds l in dom I iff l in dom Initialized I
proof
  let l be Nat;
A1: (Initialized I) | A = I by SCMPDS_4:16;
  dom ((Initialized I) | NAT) c= dom Initialized I by RELAT_1:89;
  hence l in dom I implies l in dom Initialized I by A1;
A2: dom ((Initialized I) | A) = dom Initialized I /\ A by RELAT_1:90;
A3: l in NAT by ORDINAL1:def 13;
  assume
  l in dom Initialized I;
  hence thesis by A1,A2,A3,XBOOLE_0:def 4;
end;

theorem
  x in dom I implies I.x = (s +* (I +* Start-At l)).x
proof
  assume
A1: x in dom I;
  dom I c= NAT by RELAT_1:def 18;
  then reconsider y = x as Instruction-Location of SCMPDS by A1,AMI_1:def 4;
A2: not y in dom Start-At l by AMI_1:137;
  x in dom (I +* Start-At l) by A1,FUNCT_4:13;
  hence (s +* (I +* Start-At l)).x = (I +* Start-At l).x by FUNCT_4:14
    .= I.x by A2,FUNCT_4:12;
end;

theorem Th10:
  loc in dom I implies (s +* Initialized I).loc = I.loc
proof
  assume
A1: loc in dom I;
  set II = Initialized I;
A2: I c= II by SCMPDS_4:9;
  then dom I c= dom II by GRFUNC_1:8;
  hence (s +* II).loc = II.loc by A1,FUNCT_4:14
    .=I.loc by A1,A2,GRFUNC_1:8;
end;

theorem :: SCMPDS_5:19,40
  (s +* (I +* Start-At l)).a = s.a
proof
  not a in dom (I +* Start-At l) by SCMPDS_4:61;
  hence thesis by FUNCT_4:12;
end;

theorem Th12:
  (s +* Start-At loc).IC SCMPDS = loc
proof
  thus (s +* Start-At loc).IC SCMPDS=IC (s +* Start-At loc)
    .=loc by AMI_1:111;
end;

canceled;

theorem
  (I ';' i ';' j).inspos card I =i by SCMP_GCD:11;

theorem Th15:
  i ';' I ';' j ';' k = i ';' (I ';' j ';' k)
proof
  thus i ';' I ';' j ';' k = i ';' (I ';' j) ';' k by SCMPDS_4:51
    .= i ';' (I ';' j ';' k) by SCMPDS_4:51;
end;

theorem Th16:
  Shift(J,card I) c= I ';' J ';' K
proof
  set IJ= I ';' J;
  dom IJ misses dom Shift(K, card IJ) by SCMPDS_4:2;
  then
A1: IJ c= IJ ';' K by FUNCT_4:33;
  Shift(J, card I) c= IJ by FUNCT_4:26;
  hence thesis by A1,XBOOLE_1:1;
end;

theorem Th17:
  I c= stop (I ';' J)
proof
  stop (I ';' J) =I ';' (J ';' Stop SCMPDS) by SCMPDS_4:46;
  hence thesis by SCMPDS_4:40;
end;

theorem Th18:
  loc in dom I implies Shift(stop I,n).(loc+n)=Shift(I,n).(loc+n)
proof
A1: dom I c= dom (stop I) by SCMPDS_4:39;
  reconsider l = loc as Element of NAT by ORDINAL1:def 13;
  assume
A2: loc in dom I;
  hence Shift(I,n).(loc+n)=I.l by VALUED_1:def 12
    .=(stop I).l by A2,SCMPDS_4:37
    .=Shift(stop I,n).(loc+n) by A2,A1,VALUED_1:def 12;
end;

theorem Th19:
  card I > 0 implies Shift(stop I,n).inspos n=Shift(I,n).inspos n
proof
  assume
  card I > 0;
  then
A1: inspos 0 in dom I by SCMPDS_4:1;
  thus Shift(stop I,n).inspos n=Shift(stop I,n).inspos(0+n)
    .=Shift(stop I,n).(inspos 0 +n)
    .=Shift(I,n).(inspos 0 +n) by A1,Th18
    .=Shift(I,n).inspos (0+n)
    .=Shift(I,n).inspos n;
end;

theorem
  for s being State of SCMPDS, i being Instruction of SCMPDS st InsCode
  i in {0,4,5,6} holds DataPart Exec(i,s) = DataPart s
proof
  let s be State of SCMPDS,i be Instruction of SCMPDS;
  assume
A1: InsCode i in {0,4,5,6};
  now
    let a be Int_position;
    per cases by A1,ENUMSET1:def 2;
    suppose
      InsCode i = 0;
      then ex k1 st i = goto k1 by SCMPDS_2:35;
      hence Exec(i,s).a = s.a by SCMPDS_2:66;
    end;
    suppose
      InsCode i = 4;
      then ex b,k1,k2 st i = (b,k1)<>0_goto k2 by SCMPDS_2:39;
      hence Exec(i,s).a = s.a by SCMPDS_2:67;
    end;
    suppose
      InsCode i = 5;
      then ex b,k1,k2 st i = (b,k1)<=0_goto k2 by SCMPDS_2:40;
      hence Exec(i,s).a = s.a by SCMPDS_2:68;
    end;
    suppose
      InsCode i = 6;
      then ex b,k1,k2 st i = (b,k1)>=0_goto k2 by SCMPDS_2:41;
      hence Exec(i,s).a = s.a by SCMPDS_2:69;
    end;
  end;
  hence thesis by SCMPDS_4:23;
end;

theorem
  for s,ss being State of SCMPDS holds (s +* ss | NAT) | SCM-Data-Loc =
  DataPart s
proof
  let s,ss be State of SCMPDS;
  dom (ss | A) = A by SCMPDS_6:1;
  hence thesis by AMI_2:29,FUNCT_4:76,SCMPDS_2:100;
end;

theorem
  for i being Instruction of SCMPDS holds rng Load i = {i} by FUNCOP_1:
  14;

theorem Th23: ::SCMPDS_4:15
  IC s1 = IC s2 & DataPart s1 = DataPart s2 implies IC Exec(i,s1)=
  IC Exec(i,s2) & DataPart Exec(i,s1) = DataPart Exec(i,s2)
proof
  assume that
A1: IC s1 = IC s2 and
A2: DataPart s1 = DataPart s2;
  s1,s2 equal_outside A by A1,A2,SCMPDS_6:4;
  then Exec(i,s1),Exec(i,s2) equal_outside A by SCMPDS_4:15;
  hence thesis by SCMPDS_6:4;
end;

theorem Th24:
  for s1,s2 being State of SCMPDS,I being Program of SCMPDS st I
  is_closed_on s1 & Initialized stop I c= s1 & Initialized stop I c= s2 &
DataPart s1 = DataPart s2 for i being Element of NAT holds IC Computation(s1,i)
= IC Computation(s2,i) & CurInstr Computation(s1,i) = CurInstr Computation(s2,i
  ) & DataPart Computation(s1,i) = DataPart Computation(s2,i)
proof
  let s1,s2 be State of SCMPDS,I be Program of SCMPDS;
  set pI=stop I, IsI = Initialized pI;
  assume that
A1: I is_closed_on s1 and
A2: IsI c= s1 and
A3: IsI c= s2 and
A4: DataPart s1 = DataPart s2;
A5: IC SCMPDS in dom IsI by SCMPDS_4:7;
  then
A6: IC s1 = IsI.IC SCMPDS by A2,GRFUNC_1:8
    .= IC s2 by A3,A5,GRFUNC_1:8;
  defpred P[Element of NAT] means IC Computation(s1,$1) = IC Computation(s2,$1
  ) & CurInstr (Computation(s1,$1)) = CurInstr (Computation(s2,$1)) & DataPart
  Computation(s1,$1) = DataPart Computation(s2,$1);
  pI c= IsI by SCMPDS_4:9;
  then
A7: dom pI c= dom IsI by GRFUNC_1:8;
A8: s1=s1 +* IsI by A2,FUNCT_4:79;
  then IC Computation(s1,0) in dom pI by A1,SCMPDS_6:def 2;
  then
A9: IC s1 in dom pI by AMI_1:13;
  then
A10: s1.IC s1 = IsI.IC s1 by A2,A7,GRFUNC_1:8
    .= s2.IC s2 by A3,A7,A9,A6,GRFUNC_1:8;
A11: DataPart Computation(s1,0) = DataPart s2 by A4,AMI_1:13
    .= DataPart Computation(s2,0) by AMI_1:13;
A12: CurInstr (Computation(s1,0)) = CurInstr s1 by AMI_1:13
    .= CurInstr s2 by A10
    .= CurInstr (Computation(s2,0)) by AMI_1:13;
A13: for k being Element of NAT st P[k] holds P[k + 1]
  proof
    let k be Element of NAT;
    assume
A14: P[k];
    set l = IC Computation(s1,k+1);
A15: IC Computation(s1,k+1) in dom pI by A1,A8,SCMPDS_6:def 2;
    set i = CurInstr Computation(s1,k);
A16: Computation(s1,k+1) = Following Computation(s1,k) by AMI_1:14
      .= Exec(i,Computation(s1,k));
A17: Computation(s2,k+1) = Following Computation(s2,k) by AMI_1:14
      .= Exec(i,Computation(s2,k)) by A14;
    hence IC Computation(s1,k+1) = IC Computation(s2,k+1) by A14,A16, Th23;
    thus CurInstr Computation(s1,k+1) = s1.l by AMI_1:54
      .= IsI.l by A2,A7,A15,GRFUNC_1:8
      .= s2.l by A3,A7,A15,GRFUNC_1:8
      .= Computation(s2,k+1).l by AMI_1:54
      .=CurInstr Computation(s2,k+1) by A14,A16,A17,Th23;
    thus thesis by A14,A16,A17,Th23;
  end;
  IC Computation(s1,0) =IC s1 by AMI_1:13
    .=IC Computation(s2,0) by A6,AMI_1:13;
  then
A18: P[0] by A12,A11;
  thus for k being Element of NAT holds P[k] from NAT_1:sch 1(A18,A13);
end;

theorem Th25:
  for s1,s2 being State of SCMPDS,I being Program of SCMPDS st I
  is_closed_on s1 & DataPart s1 = DataPart s2 holds for k being Element of NAT
holds Computation(s1+*Initialized stop I,k), Computation(s2+*Initialized stop I
  ,k) equal_outside NAT & CurInstr Computation(s1+*Initialized stop I,k) =
  CurInstr Computation(s2+*Initialized stop I,k)
proof
  let s1,s2 be State of SCMPDS,I be Program of SCMPDS;
  assume
A1: I is_closed_on s1;
  set pI = stop I, IsI = Initialized stop I;
  set ss1 = s1 +* IsI;
  set ss2 = s2 +* IsI;
A2: pI c= IsI by SCMPDS_4:9;
  IsI c= ss2 by FUNCT_4:26;
  then
A3: pI c= ss2 by A2,XBOOLE_1:1;
  IsI c= ss1 by FUNCT_4:26;
  then
A4: pI c= ss1 by A2,XBOOLE_1:1;
  assume
A5: DataPart s1 = DataPart s2;
  hereby
    let k be Element of NAT;
A6: IC Computation(ss1,k) in dom pI by A1,SCMPDS_6:def 2;
A7: I is_closed_on s2 by A1,A5,SCMPDS_6:36;
    then
A8: for m st m < k holds IC Computation(ss2,m) in dom pI by
    SCMPDS_6:
    def 2;
    ss1,ss2 equal_outside A by A5,SCMPDS_6:12;
    hence Computation(ss1,k),Computation(ss2,k) equal_outside A by A4,A3,
    A8,SCMPDS_4:67;
    then
A9: IC Computation(ss1,k) = IC Computation(ss2,k) by AMI_1:121;
A10: IC Computation(ss2,k) in dom pI by A7,SCMPDS_6:def 2;
    thus CurInstr Computation(ss2,k) = ss2.IC Computation(ss2,k) by AMI_1:54
      .= pI.IC Computation(ss2,k) by A3,A10,GRFUNC_1:8
      .= ss1.IC Computation(ss1,k) by A4,A9,A6,GRFUNC_1:8
      .= CurInstr Computation(ss1,k) by AMI_1:54;
  end;
end;

theorem Th26: ::SCMPDS_5:20
  for I being Program of SCMPDS st I is_closed_on s1 & Initialized
  stop I c= s1 & Initialized stop I c= s2 & s1,s2 equal_outside NAT holds for k
  being Element of NAT holds Computation(s1,k), Computation(s2,k) equal_outside
  NAT & CurInstr Computation(s1,k) = CurInstr Computation(s2,k)
proof
  let I be Program of SCMPDS;
  set iI=Initialized stop I;
  assume that
A1: I is_closed_on s1 and
A2: iI c= s1 and
A3: iI c= s2 and
A4: s1,s2 equal_outside A;
A5: s2=s2 +* iI by A3,FUNCT_4:79;
A6: DataPart s1 = DataPart s2 by A4,SCMPDS_6:4;
  s1=s1 +* iI by A2,FUNCT_4:79;
  hence thesis by A1,A5,A6,Th25;
end;

theorem
  for s1,s2 being State of SCMPDS,I being Program of SCMPDS st I
  is_closed_on s1 & I is_halting_on s1 & Initialized stop I c= s1 & Initialized
  stop I c= s2 & DataPart s1 = DataPart s2 holds LifeSpan s1 = LifeSpan s2
proof
  let s1,s2 be State of SCMPDS,I be Program of SCMPDS;
  set IsI = Initialized stop I;
  assume that
A1: I is_closed_on s1 and
A2: I is_halting_on s1 and
A3: IsI c= s1 and
A4: IsI c= s2 and
A5: DataPart s1 = DataPart s2;
  s1 = s1 +* IsI by A3,FUNCT_4:79;
  then
A6: s1 is halting by A2,SCMPDS_6:def 3;
A7: now
    let k be Element of NAT;
    assume
    CurInstr Computation(s2,k) = halt SCMPDS;
    then CurInstr Computation(s1,k) = halt SCMPDS by A1,A3,A4,A5,Th24;
    hence LifeSpan s1 <= k by A6,AMI_1:def 46;
  end;
  CurInstr Computation(s1,LifeSpan s1) = halt SCMPDS by A6,AMI_1:def 46;
  then
A8: CurInstr Computation(s2,LifeSpan s1) = halt SCMPDS by A1,A3,A4,A5,
  Th24;
  then s2 is halting by AMI_1:def 20;
  hence thesis by A8,A7,AMI_1:def 46;
end;

theorem Th28: ::SCMPDS_5:21
  for I being Program of SCMPDS st I is_closed_on s1 & I
is_halting_on s1 & Initialized stop I c= s1 & Initialized stop I c= s2 & s1,s2
  equal_outside NAT holds LifeSpan s1 = LifeSpan s2 & Result s1, Result s2
  equal_outside NAT
proof
  let I be Program of SCMPDS;
  set iI=Initialized stop I;
  assume that
A1: I is_closed_on s1 and
A2: I is_halting_on s1 and
A3: iI c= s1 and
A4: iI c= s2 and
A5: s1,s2 equal_outside A;
  DataPart s1 = DataPart s2 by A5,SCMPDS_6:4;
  then
A6: I is_halting_on s2 by A1,A2,SCMPDS_6:37;
  s2=s2 +* iI by A4,FUNCT_4:79;
  then
A7: s2 is halting by A6,SCMPDS_6:def 3;
  s1=s1 +* iI by A3,FUNCT_4:79;
  then
A8: s1 is halting by A2,SCMPDS_6:def 3;
A9: now
    let l be Element of NAT;
    assume
A10: CurInstr Computation(s2,l) = halt SCMPDS;
    CurInstr Computation(s1,l) = CurInstr Computation(s2,l) by A1,A3,A4,
    A5,Th26;
    hence LifeSpan s1 <= l by A8,A10,AMI_1:def 46;
  end;
  CurInstr Computation(s2,LifeSpan s1) = CurInstr Computation(s1,LifeSpan
  s1) by A1,A3,A4,A5,Th26
    .= halt SCMPDS by A8,AMI_1:def 46;
  hence LifeSpan s1 = LifeSpan s2 by A9,A7,AMI_1:def 46;
  then
A11: Result s2 = Computation(s2,LifeSpan s1) by A7,AMI_1:122;
  Result s1 = Computation(s1,LifeSpan s1) by A8,AMI_1:122;
  hence thesis by A1,A3,A4,A5,A11,Th26;
end;

theorem Th29:
  for s1,s2 being State of SCMPDS,I being Program of SCMPDS st I
is_closed_on s1 & I is_halting_on s1 & DataPart s1 = DataPart s2 holds LifeSpan
  (s1 +* Initialized stop I) = LifeSpan (s2 +* Initialized stop I) & Result (s1
  +* Initialized stop I),Result (s2 +* Initialized stop I) equal_outside NAT
proof
  let s1,s2 be State of SCMPDS,I be Program of SCMPDS;
  assume
A1: I is_closed_on s1;
  set IsI = Initialized stop I;
  set ss1 = s1 +* IsI;
  set ss2 = s2 +* IsI;
  assume
A2: I is_halting_on s1;
  then
A3: ss1 is halting by SCMPDS_6:def 3;
  then
A4: Result ss1 = Computation(ss1,LifeSpan ss1) by AMI_1:122;
  assume
A5: DataPart s1 = DataPart s2;
  then I is_halting_on s2 by A1,A2,SCMPDS_6:37;
  then
A6: ss2 is halting by SCMPDS_6:def 3;
A7: now
    let l be Element of NAT;
    assume
A8: CurInstr Computation(ss2,l) = halt SCMPDS;
    CurInstr Computation(ss1,l) = CurInstr Computation(ss2,l) by A1,A5,
    Th25;
    hence LifeSpan ss1 <= l by A3,A8,AMI_1:def 46;
  end;
  CurInstr Computation(ss2,LifeSpan ss1) = CurInstr Computation(ss1,
  LifeSpan ss1) by A1,A5,Th25
    .= halt SCMPDS by A3,AMI_1:def 46;
  hence LifeSpan ss1 = LifeSpan ss2 by A7,A6,AMI_1:def 46;
  then Result ss2 = Computation(ss2,LifeSpan ss1) by A6,AMI_1:122;
  hence thesis by A1,A5,A4,Th25;
end;

theorem
  for s1,s2 being State of SCMPDS,I being Program of SCMPDS st I
  is_closed_on s1 & I is_halting_on s1 & Initialized stop I c= s1 & Initialized
stop I c= s2 & ex k being Element of NAT st Computation(s1,k),s2 equal_outside
  NAT holds Result s1,Result s2 equal_outside NAT
proof
  let s1,s2 be State of SCMPDS,I be Program of SCMPDS;
  set pI =stop I, IsI=Initialized pI;
  assume
A1: I is_closed_on s1;
  assume
A2: I is_halting_on s1;
  assume
A3: IsI c= s1;
  then
A4: s1 = s1 +* IsI by FUNCT_4:79;
  then
A5: s1 is halting by A2,SCMPDS_6:def 3;
  then consider n being Element of NAT such that
A6: CurInstr Computation(s1,n) = halt SCMPDS by AMI_1:def 20;
  assume
  IsI c= s2;
  then
A7: s2 = s2 +* IsI by FUNCT_4:79;
  given k being Element of NAT such that
A8: Computation(s1,k),s2 equal_outside A;
  set s3 = Computation(s1,k);
A9: IC SCMPDS in dom s3 by AMI_1:94;
  pI c= IsI by SCMPDS_4:9;
  then pI c= s1 by A3,XBOOLE_1:1;
  then
A10: pI c= s3 by AMI_1:86;
  IC s3 = IC (s2 +* IsI) by A8,A7,AMI_1:121
    .= inspos 0 by SCMPDS_6:21;
  then IC SCMPDS .--> inspos 0 c= s3 by A9,FUNCOP_1:88;
  then pI +* Start-At inspos 0 c= s3 by A10,FUNCT_4:92;
  then
A11: s3 = s3 +* IsI by FUNCT_4:79;
A12: now
    let n be Element of NAT;
    IC Computation(s3,n) = IC Computation(s1,k+n) by AMI_1:51;
    hence IC Computation(s3,n) in dom pI by A1,A4,SCMPDS_6:def 2;
  end;
  CurInstr Computation(s3,n) = CurInstr Computation(s1,k+n) by AMI_1:51
    .= CurInstr Computation(s1,n) by A6,AMI_1:52,NAT_1:11;
  then s3 is halting by A6,AMI_1:def 20;
  then
A13: I is_halting_on s3 by A11,SCMPDS_6:def 3;
A14: DataPart s3 = DataPart s2 by A8,SCMPDS_6:4;
  consider k being Element of NAT such that
A15: CurInstr Computation(s1,k) = halt SCMPDS by A5,AMI_1:def 20;
A16: s1.IC Computation(s1,k) = halt SCMPDS by A15,AMI_1:54;
  I is_closed_on s3 by A11,A12,SCMPDS_6:def 2;
  then Result s3,Result s2 equal_outside A by A7,A14,A11,A13,Th29;
  hence thesis by A16,AMI_1:57;
end;

registration
  let I be Program of SCMPDS;
  cluster Initialized I -> initial;
  correctness
  proof
    now
      let m,n be Nat;
      I c= Initialized I by SCMPDS_4:9;
      then
A1:   dom I c= dom Initialized I by GRFUNC_1:8;
      assume
      n in dom Initialized I;
      then
A2:   n in dom I by Th8;
      assume
      m < n;
      then m in dom I by A2,SCMNORM:def 1;
      hence m in dom Initialized I by A1;
    end;
    hence thesis by SCMNORM:def 1;
  end;
end;

theorem Th31:
  for s being State of SCMPDS,I being Program of SCMPDS, a being
  Int_position st I is_halting_on s holds IExec(I,s).a = Computation(s +*
  Initialized stop I, (LifeSpan (s +* Initialized stop I))).a
proof
  let s be State of SCMPDS,I be Program of SCMPDS, a be Int_position;
  set s1 = s +* Initialized stop I;
  assume
  I is_halting_on s;
  then
A1: s1 is halting by SCMPDS_6:def 3;
A2: dom (s | A)=A by SCMPDS_6:1;
  now
    assume
    a in dom (s | A);
    then reconsider l=a as Instruction-Location of SCMPDS by A2,AMI_1:def 4;
    l=a;
    hence contradiction by SCMPDS_2:53;
  end;
  hence IExec(I,s).a = (Result s1).a by FUNCT_4:12
    .= Computation(s1,LifeSpan s1).a by A1,AMI_1:122;
end;

theorem
  for s being State of SCMPDS,I being parahalting Program of SCMPDS, a
being Int_position holds IExec(I,s).a = Computation (s +* Initialized stop I, (
  LifeSpan (s +* Initialized stop I))).a
proof
  let s be State of SCMPDS,I be parahalting Program of SCMPDS, a be
  Int_position;
  I is_halting_on s by SCMPDS_6:35;
  hence thesis by Th31;
end;

theorem Th33:
  for I being Program of SCMPDS,i being Element of NAT st
Initialized stop I c= s & I is_closed_on s & I is_halting_on s & i < LifeSpan s
  holds IC Computation(s,i) in dom I
proof
  let I be Program of SCMPDS,i be Element of NAT;
  set sI = stop I, iI = Initialized sI, Ci = Computation(s,i), Lc = IC Ci;
  assume that
A1: iI c= s and
A2: I is_closed_on s and
A3: I is_halting_on s and
A4: i < LifeSpan s;
A5: s = s +* iI by A1,FUNCT_4:79;
  then
A6: Lc in dom sI by A2,SCMPDS_6:def 2;
  sI c= iI by SCMPDS_4:9;
  then
A7: sI c= s by A1,XBOOLE_1:1;
A8: s is halting by A3,A5,SCMPDS_6:def 3;
  now
    assume
A9: sI.Lc=halt SCMPDS;
    CurInstr Ci =s.Lc by AMI_1:54
      .=halt SCMPDS by A6,A7,A9,GRFUNC_1:8;
    hence contradiction by A4,A8,AMI_1:def 46;
  end;
  hence thesis by A6,SCMPDS_5:3;
end;

theorem Th34:
  for I being shiftable Program of SCMPDS st Initialized stop I c=
s1 & I is_closed_on s1 & I is_halting_on s1 for n being Element of NAT st Shift
  (I,n) c= s2 & card I > 0 & IC s2 = inspos n & DataPart s1 = DataPart s2 for i
  being Element of NAT holds i < LifeSpan s1 implies IC Computation(s1,i) + n =
IC Computation(s2,i) & CurInstr (Computation(s1,i)) = CurInstr (Computation(s2,
  i)) & DataPart Computation(s1,i) = DataPart Computation(s2,i)
proof
  let I be shiftable Program of SCMPDS;
  set SI=stop I, II=Initialized SI;
  assume that
A1: II c= s1 and
A2: I is_closed_on s1 and
A3: I is_halting_on s1;
  dom SI misses dom Start-At inspos 0 by SCMPDS_4:54;
  then
A4: SI c= II by FUNCT_4:33;
  then
A5: dom SI c= dom II by GRFUNC_1:8;
  let n be Element of NAT;
  assume that
A6: Shift(I,n) c= s2 and
A7: card I > 0 and
A8: IC s2 = inspos n and
A9: DataPart s1 = DataPart s2;
  defpred P[Element of NAT] means $1 < LifeSpan s1 implies IC Computation(s1,
  $1) + n = IC Computation(s2,$1) & CurInstr (Computation(s1,$1)) = CurInstr (
Computation(s2,$1)) & DataPart Computation(s1,$1) = DataPart Computation(s2,$1)
  ;
A10: s1=s1 +* II by A1,FUNCT_4:79;
A11: for k being Element of NAT st P[k] holds P[k + 1]
  proof
    let k be Element of NAT;
    assume
A12: P[k];
    now
      reconsider m = IC Computation(s1,k) as Element of NAT by ORDINAL1:def 13;
      set i = CurInstr Computation(s1,k);
A13:  k <= k+1 by NAT_1:11;
A14:  IC Computation(s1,k) =inspos m;
      reconsider l = IC Computation(s1,k+1) as Element of NAT by ORDINAL1:def
      13;
A15:  Computation(s1,k+1) = Following Computation(s1,k) by AMI_1:14
        .= Exec(CurInstr Computation(s1,k),Computation(s1,k));
      assume
A16:  k+1 < LifeSpan s1;
      then
A17:  IC Computation(s1,k+1) in dom I by A1,A2,A3,Th33;
      then
A18:  l+n in dom Shift(I,n) by VALUED_1:25;
A19:  Computation(s2,k+1) = Following Computation(s2,k) by AMI_1:14
        .= Exec(CurInstr Computation(s2,k),Computation(s2,k));
A20:  IC Computation(s1,k) in dom SI by A2,A10,SCMPDS_6:def 2;
A21:  i = s1.IC Computation(s1,k) by AMI_1:54
        .= II.IC Computation(s1,k) by A1,A5,A20,GRFUNC_1:8
        .= SI.IC Computation(s1,k) by A4,A20,GRFUNC_1:8;
      then
A22:  InsCode i <> 3 by A20,A14,SCMPDS_4:def 12;
A23:  IC Computation(s1,k+1) in dom SI by A2,A10,SCMPDS_6:def 2;
A24:  i valid_at m by A20,A21,A14,SCMPDS_4:def 12;
A25:  InsCode i <> 1 by A20,A21,A14,SCMPDS_4:def 12;
      hence
A26:  IC Computation(s1,k+1) + n = IC Computation(s2,k+1) by A12,A16
      ,A13,A15,A19,A14,A22,A24,SCMPDS_4:83,XXREAL_0:2;
      CurInstr Computation(s1,k+1) = s1.l by AMI_1:54
        .= II.l by A1,A5,A23,GRFUNC_1:8
        .= SI.l by A4,A23,GRFUNC_1:8;
      hence CurInstr Computation(s1,k+1) = Shift(SI,n).(l + n) by A23,
      VALUED_1:def 12
        .= Shift(I,n).(IC Computation(s2,k+1)) by A26,A17,Th18
        .= s2.IC Computation(s2,k+1) by A6,A26,A18,GRFUNC_1:8
        .= CurInstr Computation(s2,k+1) by AMI_1:54;
      thus DataPart Computation(s1,k+1) = DataPart Computation(s2,k+1) by A12,
      A16,A13,A15,A19,A14,A25,A22,A24,SCMPDS_4:83,XXREAL_0:2;
    end;
    hence thesis;
  end;
  let i be Element of NAT;
A27: inspos 0 in dom SI by SCMPDS_4:75;
A28: inspos 0 in dom I by A7,SCMPDS_4:1;
A29: P[0]
  proof
    assume
    0 < LifeSpan s1;
A30: inspos (0 + n) in dom Shift(I,n) by A28,VALUED_1:25;
A31: IC SCMPDS in dom II by SCMPDS_4:7;
    then
A32: s1.IC s1 = s1.((II).IC SCMPDS) by A1,GRFUNC_1:8
      .= s1.inspos 0 by SCMPDS_4:29
      .= II.inspos 0 by A1,A5,A27,GRFUNC_1:8
      .= SI.inspos 0 by A4,A27,GRFUNC_1:8;
    IC Computation(s1,0) = s1.IC SCMPDS by AMI_1:13
      .= II.IC SCMPDS by A1,A31,GRFUNC_1:8
      .= inspos 0 by SCMPDS_4:29;
    hence IC Computation(s1,0) + n = inspos (0 + n)
      .= IC Computation(s2,0) by A8,AMI_1:13;
    thus CurInstr (Computation(s1,0)) = CurInstr s1 by AMI_1:13
      .= Shift(SI,n).(inspos 0 + n) by A27,A32,VALUED_1:def 12
      .= Shift(SI,n).inspos (0 + n)
      .= Shift(I,n).inspos n by A7,Th19
      .= CurInstr s2 by A6,A8,A30,GRFUNC_1:8
      .= CurInstr (Computation(s2,0)) by AMI_1:13;
    thus DataPart Computation(s1,0) = DataPart s2 by A9,AMI_1:13
      .= DataPart Computation(s2,0) by AMI_1:13;
  end;
  for k being Element of NAT holds P[k] from NAT_1:sch 1(A29,A11);
  hence thesis;
end;

theorem Th35:
  for I being No-StopCode Program of SCMPDS st Initialized stop I
  c= s & I is_halting_on s & card I > 0 holds LifeSpan s > 0
proof
  let I be No-StopCode Program of SCMPDS;
  set II=Initialized stop I, si=s +* II;
  assume that
A1: II c= s and
A2: I is_halting_on s and
A3: card I > 0;
A4: s=si by A1,FUNCT_4:79;
  assume
  LifeSpan s <= 0;
  then
A5: LifeSpan s=0;
A6: I c= II by SCMPDS_6:17;
  then
A7: dom I c= dom II by GRFUNC_1:8;
A8: inspos 0 in dom I by A3,SCMPDS_4:1;
  si is halting by A2,SCMPDS_6:def 3;
  then halt SCMPDS = CurInstr(Computation(si,0)) by A4,A5,AMI_1:def 46
    .= CurInstr si by AMI_1:13
    .= s.inspos 0 by A4,SCMPDS_6:21
    .=II.inspos 0 by A1,A8,A7,GRFUNC_1:8
    .=I.inspos 0 by A8,A6,GRFUNC_1:8;
  hence contradiction by A8,SCMPDS_5:def 3;
end;

theorem Th36:
  for I being No-StopCode shiftable Program of SCMPDS st
  Initialized stop I c= s1 & I is_closed_on s1 & I is_halting_on s1 for n being
  Element of NAT st Shift(I,n) c= s2 & card I > 0 & IC s2 = inspos n & DataPart
  s1 = DataPart s2 holds IC Computation(s2,LifeSpan s1) = inspos (card I + n) &
  DataPart Computation(s1,LifeSpan s1) = DataPart Computation(s2,LifeSpan s1)
proof
  let I be No-StopCode shiftable Program of SCMPDS;
  set II=Initialized stop I;
  assume that
A1: II c= s1 and
A2: I is_closed_on s1 and
A3: I is_halting_on s1;
  let n be Element of NAT;
  assume that
A4: Shift(I,n) c= s2 and
A5: card I > 0 and
A6: IC s2 = inspos n and
A7: DataPart s1 = DataPart s2;
  1+0 <= LifeSpan s1 by A1,A3,A5,Th35,INT_1:20;
  then consider i be Nat such that
A8: 1+i=LifeSpan s1 by NAT_1:10;
  reconsider i as Element of NAT by ORDINAL1:def 13;
A9: i < LifeSpan s1 by A8,XREAL_1:31;
  then
A10: IC Computation(s1,i) + n = IC Computation(s2,i) by A1,A2,A3,A4,A5,A6,A7
  ,Th34;
  set L1=IC Computation(s1,i);
A11: L1 in dom I by A1,A2,A3,A8,Th33,XREAL_1:31;
  set i2=CurInstr Computation(s2,i);
A12: Computation(s1,i+1) = Following Computation(s1,i) by AMI_1:14
    .= Exec(i2,Computation(s1,i)) by A1,A2,A3,A4,A5,A6,A7,A9,Th34;
A13: I c= II by SCMPDS_6:17;
  then
A14: dom I c= dom II by GRFUNC_1:8;
A15: Computation(s2,i+1) = Following Computation(s2,i) by AMI_1:14
    .=Exec(i2,Computation(s2,i));
  reconsider m = L1 as Element of NAT by ORDINAL1:def 13;
A16: L1 =inspos m;
  i2=CurInstr Computation(s1,i) by A1,A2,A3,A4,A5,A6,A7,A9,Th34;
  then
A17: i2=s1.L1 by AMI_1:54
    .=II.L1 by A1,A11,A14,GRFUNC_1:8
    .=I.L1 by A11,A13,GRFUNC_1:8;
  then
A18: InsCode i2 <> 1 by A11,A16,SCMPDS_4:def 12;
A19: DataPart Computation(s1,i) = DataPart Computation(s2,i) by A1,A2,A3,A4,
  A5,A6,A7,A9,Th34;
A20: i2 valid_at m by A11,A17,A16,SCMPDS_4:def 12;
A21: InsCode i2 <> 3 by A11,A17,A16,SCMPDS_4:def 12;
  s1=s1 +* II by A1,FUNCT_4:79;
  then IC Computation(s1,i+1)=inspos card I by A2,A3,A8,SCMPDS_6:43;
  hence IC Computation(s2,LifeSpan s1) = inspos card I + n by A8,A10,A16,A18,
  A21,A20,A12,A19,A15,SCMPDS_4:83
    .= inspos (card I + n);
  thus thesis by A8,A10,A16,A18,A21,A20,A12,A19,A15,SCMPDS_4:83;
end;

theorem Th37:
  for s being State of SCMPDS,I being Program of SCMPDS,n being
  Element of NAT st IC Computation(s+*Initialized I,n) = inspos 0 holds
Computation(s+*Initialized I,n) +* Initialized I =Computation(s+*Initialized I,
  n)
proof
  let s be State of SCMPDS,I be Program of SCMPDS,n be Element of NAT;
  set II=Initialized I, sn=Computation(s+*II,n);
A1: II c= s +* II by FUNCT_4:26;
  I c= I +* Start-At inspos 0 by SCMPDS_6:6;
  then I c= s +* II by A1,XBOOLE_1:1;
  then
A2: I c= sn by AMI_1:81;
  assume
  IC sn= inspos 0;
  then sn +* II = sn +* I by Th5;
  hence thesis by A2,FUNCT_4:79;
end;

theorem Th38: ::SCMPDS_5:33
  for I being Program of SCMPDS,J being Program of SCMPDS, k being
  Element of NAT st I is_closed_on s & I is_halting_on s & k <= LifeSpan (s +*
Initialized stop(I)) holds Computation (s +* Initialized stop I,k), Computation
  (s +* ((I ';' J) +* Start-At inspos 0),k) equal_outside NAT
proof
  set IL=NAT;
  let I be Program of SCMPDS,J be Program of SCMPDS,k be Element of NAT;
  set SA0=Start-At inspos 0, spI= stop I;
  set s1 = s +* Initialized spI;
  set s2 = s +* ((I ';' J) +* SA0);
  set n=LifeSpan s1;
  assume that
A1: I is_closed_on s and
A2: I is_halting_on s and
A3: k <= n;
  defpred X[Element of NAT] means $1 <= n implies Computation(s1,$1),
  Computation(s2,$1) equal_outside IL;
A4: s2 = s +* (I ';' J) +* SA0 by FUNCT_4:15
    .= s+*SA0+*(I ';' J) by SCMPDS_4:62;
A5: s1 =s +* spI +* SA0 by FUNCT_4:15
    .=s+*SA0+* spI by SCMPDS_4:62;
A6: for m being Element of NAT st X[m] holds X[m+1]
  proof
    let m be Element of NAT;
    assume
A7: m <= n implies Computation(s1,m), Computation(s2,m) equal_outside
    IL;
A8: Computation(s1,m+1) = Following Computation(s1,m) by AMI_1:14
      .= Exec(CurInstr Computation(s1,m),Computation(s1,m));
A9: IC Computation(s1,m) in dom spI by A1,SCMPDS_6:def 2;
A10: Computation(s2,m+1) = Following Computation(s2,m) by AMI_1:14
      .= Exec(CurInstr Computation(s2,m),Computation(s2,m));
    assume
A11: m+1 <= n;
    then m < n by NAT_1:13;
    then
A12: IC Computation(s1,m) in dom I by A1,A2,SCMPDS_6:40;
    then
A13: IC Computation(s1,m) in dom (I ';' J) by FUNCT_4:13;
    CurInstr Computation(s1,m) = s1.IC Computation(s1,m) by AMI_1:54
      .= spI.IC Computation(s1,m) by A5,A9,FUNCT_4:14
      .= I.IC Computation(s1,m) by A12,SCMPDS_4:37
      .= (I ';' J).IC Computation(s1,m) by A12,SCMPDS_4:37
      .= s2.IC Computation(s1,m) by A4,A13,FUNCT_4:14
      .= (Computation(s2,m)).IC Computation(s1,m) by AMI_1:54
      .=CurInstr Computation(s2,m) by A7,A11,AMI_1:121,NAT_1:13;
    hence thesis by A7,A11,A10,A8,NAT_1:13,SCMPDS_4:15;
  end;
A14: Computation(s2,0) = s2 by AMI_1:13;
A15: Computation(s1,0) = s1 by AMI_1:13;
A16: s +* SA0, s +* SA0 +* (I ';' J) equal_outside IL by AMI_1:120;
  s +* SA0 +* spI, s +* SA0 equal_outside IL by AMI_1:120,FUNCT_7:28;
  then
A17: X[0] by A5,A4,A16,A15,A14,FUNCT_7:29;
  for k being Element of NAT holds X[k] from NAT_1:sch 1(A17, A6);
  hence thesis by A3;
end;

theorem Th39: ::SCMPDS_5:29
  for I,J being Program of SCMPDS,k be Element of NAT st I c= J &
I is_closed_on s & I is_halting_on s & k <= LifeSpan (s +* Initialized stop(I))
holds Computation( (s +* Initialized J),k), Computation( (s +* Initialized stop
  (I)),k) equal_outside NAT
proof
  let I,J be Program of SCMPDS,k be Element of NAT;
  set IsI=Initialized stop(I), IL=NAT, m=LifeSpan (s +* IsI);
  assume that
A1: I c= J and
A2: I is_closed_on s and
A3: I is_halting_on s and
A4: k <= m;
  set iJ=Initialized J, s1 = s +* iJ, s2 = s +* IsI;
  defpred P[Element of NAT] means $1 <= m implies Computation(s1,$1),
  Computation(s2,$1) equal_outside IL;
A5: dom I c= dom J by A1,GRFUNC_1:8;
A6: now
    let k be Element of NAT;
    assume
A7: P[k];
    now
A8:   Computation(s2,k+1) = Following Computation(s2,k) by AMI_1:14
        .= Exec(CurInstr Computation(s2,k),Computation(s2,k));
A9:   Computation(s1,k+1) = Following Computation(s1,k) by AMI_1:14
        .= Exec(CurInstr Computation(s1,k),Computation(s1,k));
A10:  k < k+1 by XREAL_1:31;
      assume
A11:  k+1 <= m;
      then k < m by A10,XXREAL_0:2;
      then
A12:  IC Computation(s2,k) in dom I by A2,A3,SCMPDS_6:40;
      then
A13:  IC Computation(s2,k) in dom (stop I) by FUNCT_4:13;
      CurInstr Computation(s1,k) = (Computation(s1,k)).IC Computation(s2,
      k) by A7,A11,A10,AMI_1:121,XXREAL_0:2
        .= (s +* iJ).IC Computation(s2,k) by AMI_1:54
        .= J.IC Computation(s2,k) by A5,A12,Th10
        .= I.IC Computation(s2,k) by A1,A12,GRFUNC_1:8
        .= (stop I).IC Computation(s2,k) by A12,SCMPDS_4:37
        .= (s +* IsI).IC Computation(s2,k) by A13,Th10
        .= CurInstr Computation(s2,k) by AMI_1:54;
      hence
      Computation(s1,k+1),Computation(s2,k+1) equal_outside IL by A7,A11
      ,A10,A9,A8,SCMPDS_4:15,XXREAL_0:2;
    end;
    hence P[k+1];
  end;
A14: P[0]
  proof
    assume
    0 <= m;
A15: Computation(s2,0)=s +* IsI by AMI_1:13;
    Computation(s1,0)=s +* iJ by AMI_1:13;
    hence thesis by A15,SCMPDS_4:36;
  end;
  for k be Element of NAT holds P[k] from NAT_1:sch 1(A14,A6);
  hence thesis by A4;
end;

theorem Th40:
  for I,J being Program of SCMPDS,k be Element of NAT st k <=
  LifeSpan (s +* Initialized stop(I)) & I c= J & I is_closed_on s & I
  is_halting_on s holds IC Computation( (s +* Initialized J),k) in dom stop I
proof
  let I,J be Program of SCMPDS,k be Element of NAT;
  set ss = s +* Initialized stop(I);
  set s1= Computation( (s +* Initialized J),k), s2= Computation( ss,k);
  assume that
A1: k <= LifeSpan ss and
A2: I c= J and
A3: I is_closed_on s and
A4: I is_halting_on s;
  IC s1 = IC s2 by A1,A2,A3,A4,Th39,AMI_1:121;
  hence thesis by A3,SCMPDS_6:def 2;
end;

theorem Th41: ::SCMPDS_5:31
  for I,J being Program of SCMPDS st I c= J & I is_closed_on s & I
is_halting_on s holds CurInstr Computation( (s +* Initialized J),LifeSpan (s +*
  Initialized stop(I))) = halt SCMPDS or IC Computation( (s +* Initialized J),
  LifeSpan (s +* Initialized stop(I))) = inspos card I
proof
  let I,J be Program of SCMPDS;
  set IsI=Initialized stop(I), ss = s +* IsI, m=LifeSpan ss;
  set s0=s +* Initialized J, s1= Computation( s0,m), s2= Computation( ss,m),
  Ik = IC s2;
  assume that
A1: I c= J and
A2: I is_closed_on s and
A3: I is_halting_on s;
A4: dom I c= dom J by A1,GRFUNC_1:8;
  reconsider n = Ik as Element of NAT by ORDINAL1:def 13;
A5: stop I c= IsI by SCMPDS_4:9;
  IsI c= ss by FUNCT_4:26;
  then
A6: stop I c= ss by A5,XBOOLE_1:1;
A7: ss is halting by A3,SCMPDS_6:def 3;
A8: Ik in dom stop(I) by A2,SCMPDS_6:def 2;
  card stop I = card I + 1 by SCMPDS_5:7;
  then n < card I + 1 by A8,SCMPDS_4:1;
  then
A9: n <= card I by INT_1:20;
A10: IC s1 = Ik by A1,A2,A3,Th39,AMI_1:121;
  now
    per cases by A9,XXREAL_0:1;
    case
      n < card I;
      then
A11:  inspos n in dom I by SCMPDS_4:1;
      thus halt SCMPDS = CurInstr s2 by A7,AMI_1:def 46
        .= ss.Ik by AMI_1:54
        .= (stop I).Ik by A8,A6,GRFUNC_1:8
        .= I.Ik by A11,SCMPDS_4:37
        .= J.Ik by A1,A11,GRFUNC_1:8
        .= s0.IC s1 by A4,A10,A11,Th10
        .=CurInstr s1 by AMI_1:54;
    end;
    case
      n = card I;
      hence IC s1= inspos card I by A1,A2,A3,Th39,AMI_1:121;
    end;
  end;
  hence thesis;
end;

theorem Th42:
  for I,J being Program of SCMPDS st I is_halting_on s & J
  is_closed_on IExec(I,s) & J is_halting_on IExec(I,s) holds J is_closed_on
Computation( (s +* Initialized stop I), LifeSpan (s +* Initialized stop I)) & J
  is_halting_on Computation( (s +* Initialized stop I), LifeSpan (s +*
  Initialized stop I))
proof
  let I,J be Program of SCMPDS;
  set s1= s +* Initialized stop I, sm = Computation(s1,LifeSpan s1), sE =
  IExec(I,s);
  assume that
A1: I is_halting_on s and
A2: J is_closed_on sE and
A3: J is_halting_on sE;
A4: s1 is halting by A1,SCMPDS_6:def 3;
  dom (s | A) = A by SCMPDS_6:1;
  then DataPart sE = DataPart Result s1 by
  AMI_2:29,FUNCT_4:76,SCMPDS_2:100
    .= DataPart sm by A4,AMI_1:122;
  hence thesis by A2,A3,SCMPDS_6:37;
end;

theorem Th43:
  for I being Program of SCMPDS,J being shiftable Program of
SCMPDS st I is_closed_on s & I is_halting_on s & J is_closed_on IExec(I,s) & J
  is_halting_on IExec(I,s) holds (I ';'J) is_closed_on s & (I ';' J)
  is_halting_on s
proof
  let I be Program of SCMPDS,J be shiftable Program of SCMPDS;
  set sE=IExec(I,s);
  assume that
A1: I is_closed_on s and
A2: I is_halting_on s and
A3: J is_closed_on sE and
A4: J is_halting_on sE;
  set IJ =I ';' J, sIJ = stop IJ, IsIJ = Initialized sIJ, spI = stop I, IsI =
  Initialized spI, ss=s +* IsIJ;
  set spJ = stop J, IsJ = Initialized spJ, s1 = s +* IsI, m1 = LifeSpan s1, sm
  = Computation( s1,m1), s3 = sm +* IsJ, m3 = LifeSpan s3;
A5: dom (DataPart IsJ) = dom IsJ /\ D by RELAT_1:90,SCMPDS_2:100;
  J is_halting_on sm by A2,A3,A4,Th42;
  then
A6: s3 is halting by SCMPDS_6:def 3;
A7: J is_closed_on sm by A2,A3,A4,Th42;
  then
A8: J is_closed_on s3 by SCMPDS_6:38;
A9: now
    let x be set;
    assume
    x in dom (DataPart IsJ);
    then
A10: x in dom IsJ /\ D by RELAT_1:90,SCMPDS_2:100;
    then
A11: x in dom IsJ by XBOOLE_0:def 4;
A12: x in D by A10,XBOOLE_0:def 4;
    per cases by A11,SCMPDS_4:28;
    suppose
A13:  x in dom spJ;
      dom spJ c= A by RELAT_1:def 18;
      then reconsider l=x as Instruction-Location of SCMPDS by A13,
      AMI_1:def 4;
      l=x;
      hence (DataPart IsJ).x = (DataPart Computation(s1,m1)).x by A12,
      SCMPDS_4:22;
    end;
    suppose
      x = IC SCMPDS;
      hence (DataPart IsJ).x = (DataPart Computation(s1,m1)).x by A10,
      SCMPDS_3:6,XBOOLE_0:def 4;
    end;
  end;
  set s4 = Computation( ss,m1);
A14: DataPart s3 = DataPart Computation(s1,m1) +* DataPart IsJ by FUNCT_4:75;
A15: IsJ c= s3 by FUNCT_4:26;
  then dom IsJ c= dom s3 by GRFUNC_1:8;
  then dom IsJ c= the carrier of SCMPDS by AMI_1:79;
  then dom (DataPart IsJ) c= (the carrier of SCMPDS) /\ D by
  A5, XBOOLE_1
  :26;
  then dom (DataPart IsJ) c= dom sm /\ D by AMI_1:79;
  then dom (DataPart IsJ) c= dom (DataPart sm) by
  RELAT_1:90,SCMPDS_2:100;
  then DataPart IsJ c= DataPart sm by A9,GRFUNC_1:8;
  then
A16: DataPart sm = DataPart s3 by A14,LATTICE2:8;
  ss = s +* ((I ';' (J ';' Stop SCMPDS)) +* Start-At inspos 0) by SCMPDS_4
  :46;
  then
A17: DataPart s4 = DataPart s3 by A1,A2,A16,Th38,SCMPDS_4:24;
  sIJ = I ';' (J ';' Stop SCMPDS) by SCMPDS_4:46
    .= I +* Shift(spJ, card I);
  then
A18: Shift(spJ, card I) c= sIJ by FUNCT_4:26;
  sIJ c= ss by FUNCT_4:26,SCMPDS_4:57;
  then Shift(spJ, card I) c= ss by A18,XBOOLE_1:1;
  then
A19: Shift(spJ, card I) c= s4 by AMI_1:81;
A20: dom stop I c= dom sIJ by SCMPDS_5:16;
  now
    let k be Element of NAT;
    per cases;
    suppose
      k <= m1;
      then IC Computation( ss,k) in dom stop I by A1,A2,Th17,Th40;
      hence IC Computation( ss,k) in dom sIJ by A20;
    end;
    suppose
A21:  k > m1;
A22:  IC s4 in dom spI by A1,A2,Th17,Th40;
      hereby
        per cases by A1,A2,Th17,Th41;
        suppose
A23:      IC s4 = inspos card I;
          consider ii be Nat such that
A24:      k=m1+ii by A21,NAT_1:10;
          reconsider ii as Element of NAT by ORDINAL1:def 13;
          reconsider nn = IC Computation( s3,ii) as Element of NAT by ORDINAL1
          :def 13;
          IC Computation( s3,ii) + card I = IC Computation( s4,ii) by A15
          ,A17,A8,A19,A23,SCMPDS_6:45;
          then
A25:      IC Computation( ss,k)=inspos nn+card I by A24,AMI_1:51
            .=inspos (nn + card I);
          inspos nn in dom spJ by A7,SCMPDS_6:def 2;
          then nn < card spJ by SCMPDS_4:1;
          then nn < card J+1 by SCMPDS_5:7;
          then
A26:      card I +nn < card I +(card J+1) by XREAL_1:8;
          card sIJ=card IJ+1 by SCMPDS_5:7
            .=card I + card J+1 by SCMPDS_4:45;
          hence IC Computation( ss,k) in dom sIJ by A26,A25,SCMPDS_4:1;
        end;
        suppose
          CurInstr s4 = halt SCMPDS;
          then IC Computation( ss,k)=IC s4 by A21,AMI_1:52;
          hence IC Computation( ss,k) in dom sIJ by A20,A22;
        end;
      end;
    end;
  end;
  hence (I ';'J) is_closed_on s by SCMPDS_6:def 2;
  per cases by A1,A2,Th17,Th41;
  suppose
    CurInstr s4 = halt SCMPDS;
    then ss is halting by AMI_1:def 20;
    hence thesis by SCMPDS_6:def 3;
  end;
  suppose
    IC s4 = inspos card I;
    then CurInstr Computation( s3,m3) = CurInstr Computation( s4,m3) by A15,
    A17,A8,A19,SCMPDS_6:45;
    then
    CurInstr Computation( ss,m1+m3) = CurInstr Computation( s3,m3) by AMI_1:51
      .= halt SCMPDS by A6,AMI_1:def 46;
    then ss is halting by AMI_1:def 20;
    hence thesis by SCMPDS_6:def 3;
  end;
end;

theorem Th44: :: SCMPDS_5:30
  for I be No-StopCode Program of SCMPDS,J be Program of SCMPDS st
  I c= J & I is_closed_on s & I is_halting_on s holds IC Computation( (s +*
  Initialized J), LifeSpan (s +* Initialized stop(I))) = inspos card I
proof
  let I be No-StopCode Program of SCMPDS,J be Program of SCMPDS;
  set s1 = s +* Initialized J, ss = s +* Initialized stop(I), m=LifeSpan ss;
  assume that
A1: I c= J and
A2: I is_closed_on s and
A3: I is_halting_on s;
  thus IC Computation( s1,m) =IC Computation( ss,LifeSpan ss) by A1,A2,A3,
  Th39,AMI_1:121
    .=inspos card I by A2,A3,SCMPDS_6:43;
end;

theorem ::SCMPDS_6:42
  for I being Program of SCMPDS,s being State of SCMPDS, k being Element
  of NAT st I is_halting_on s & k < LifeSpan (s +* Initialized stop I) holds
  CurInstr Computation( (s +* Initialized stop I),k) <> halt SCMPDS
proof
  let I be Program of SCMPDS,s be State of SCMPDS,k be Element of NAT;
  set ss=s +* Initialized stop(I), m=LifeSpan ss;
  assume that
A1: I is_halting_on s and
A2: k < m;
  assume
A3: CurInstr ( Computation( ss,k))=halt SCMPDS;
  ss is halting by A1,SCMPDS_6:def 3;
  hence thesis by A2,A3,AMI_1:def 46;
end;

theorem Th46: ::SCMPDS_6:42
  for I,J being Program of SCMPDS,s being State of SCMPDS, k being
  Element of NAT st I is_closed_on s & I is_halting_on s & k < LifeSpan (s +*
Initialized stop I) holds CurInstr Computation( (s +* Initialized stop (I ';' J
  )),k) <> halt SCMPDS
proof
  let I,J be Program of SCMPDS,s be State of SCMPDS,k be Element of NAT;
  set s1=s +* Initialized stop I, s2=s +* Initialized stop (I ';' J), m=
  LifeSpan s1, s3=Computation(s2,k);
  assume that
A1: I is_closed_on s and
A2: I is_halting_on s and
A3: k < m;
  assume
  CurInstr s3 = halt SCMPDS;
  then
A4: CurInstr Computation(s1,k) = halt SCMPDS by A1,A2,A3,SCMPDS_6:41;
  s1 is halting by A2,SCMPDS_6:def 3;
  hence thesis by A3,A4,AMI_1:def 46;
end;

Lm1: for I being No-StopCode Program of SCMPDS,J being shiftable Program of
SCMPDS,s,s1,s2 being State of SCMPDS st I is_closed_on s & I is_halting_on s &
J is_closed_on IExec(I,s) & J is_halting_on IExec(I,s) & s2=s +* Initialized
stop (I ';' J) & s1=s +* Initialized stop I holds IC Computation(s2,LifeSpan s1
) = inspos card I & DataPart Computation(s2,LifeSpan s1) = DataPart(Computation
(s1,LifeSpan s1) +* Initialized stop J) & Shift(stop J,card I) c= Computation(
s2,LifeSpan s1) & LifeSpan s2 = LifeSpan s1 + LifeSpan (Result s1 +*
Initialized stop J)

proof

  let I be No-StopCode Program of SCMPDS,J be shiftable Program of SCMPDS, s,
  s1,s2 be State of SCMPDS;

  set IsI = Initialized stop I, spJ = stop J, IsJ = Initialized spJ, IJ = I
  ';' J, sIJ = stop IJ, IsIJ = Initialized sIJ, m1 = LifeSpan s1, sm =
  Computation( s1,m1), s3 = sm +* IsJ;

  set m3 = LifeSpan s3, sE = IExec(I,s);
  assume that
A1: I is_closed_on s and
A2: I is_halting_on s and
A3: J is_closed_on sE and
A4: J is_halting_on sE and
A5: s2=s +* IsIJ and
A6: s1=s +* IsI;

A7: DataPart s3 = DataPart Computation(s1,m1) +* DataPart IsJ by FUNCT_4:75;

  set s4 = Computation( s2,m1);
  thus
A8: IC s4 = inspos card I by A1,A2,A5,A6,Th17,Th44;
A9: now
    let x be set;
    assume
    x in dom (DataPart IsJ);
    then
A10: x in dom IsJ /\ D by RELAT_1:90,SCMPDS_2:100;
    then
A11: x in dom IsJ by XBOOLE_0:def 4;
A12: x in D by A10,XBOOLE_0:def 4;
    per cases by A11,SCMPDS_4:28;
    suppose
A13:  x in dom spJ;
      dom spJ c= A by RELAT_1:def 18;
      then reconsider l=x as Instruction-Location of SCMPDS by A13,
      AMI_1:def 4;
      l=x;

      hence (DataPart IsJ).x = (DataPart Computation(s1,m1)).x by A12,
      SCMPDS_4:22;

    end;
    suppose
      x = IC SCMPDS;

      hence (DataPart IsJ).x = (DataPart Computation(s1,m1)).x by A10,
      SCMPDS_3:6,XBOOLE_0:def 4;

    end;
  end;
A14: dom (DataPart IsJ) = dom IsJ /\ D by RELAT_1:90,SCMPDS_2:100;
A15: IsJ c= s3 by FUNCT_4:26;
  then dom IsJ c= dom s3 by GRFUNC_1:8;
  then dom IsJ c= the carrier of SCMPDS by AMI_1:79;

  then dom (DataPart IsJ) c= (the carrier of SCMPDS) /\ D by
  A14, XBOOLE_1
  :26;

  then dom (DataPart IsJ) c= dom ( Computation( s1,m1)) /\ D by AMI_1:79;

  then dom (DataPart IsJ) c= dom DataPart Computation(s1,m1) by
  RELAT_1:90
  ,SCMPDS_2:100;

  then DataPart IsJ c= DataPart Computation(s1,m1) by A9,GRFUNC_1:8;
  then
A16: DataPart Computation(s1,m1) = DataPart s3 by A7,LATTICE2:8;

  s2 = s +* ((I ';' (J ';' Stop SCMPDS)) +* Start-At inspos 0) by A5,
  SCMPDS_4:46;

  hence
A17: DataPart s4 = DataPart s3 by A1,A2,A6,A16,Th38,SCMPDS_4:24;
  reconsider m = m1 + m3 as Element of NAT;
A18: sIJ c= IsIJ by SCMPDS_4:9;
  sIJ = I ';' (J ';' Stop SCMPDS) by SCMPDS_4:46
    .= I +* Shift(spJ, card I);
  then
A19: Shift(spJ, card I) c= sIJ by FUNCT_4:26;
  IsIJ c= s2 by A5,FUNCT_4:26;
  then sIJ c= s2 by A18,XBOOLE_1:1;
  then Shift(spJ, card I) c= s2 by A19,XBOOLE_1:1;
  hence
A20: Shift(spJ, card I) c= s4 by AMI_1:81;
  J is_halting_on sm by A2,A3,A4,A6,Th42;
  then
A21: s3 is halting by SCMPDS_6:def 3;
  J is_closed_on sm by A2,A3,A4,A6,Th42;
  then
A22: J is_closed_on s3 by SCMPDS_6:38;

  then CurInstr Computation( s3,m3) = CurInstr Computation( s4,m3) by A15,
  A8,A17,A20,SCMPDS_6:45;

  then CurInstr Computation( s3,m3) = CurInstr Computation( s2,m1+m3) by
  AMI_1:51;

  then
A23: CurInstr Computation( s2,m) = halt SCMPDS by A21,AMI_1:def 46;
A24: now
    let k be Element of NAT;
    assume
    m1 + k < m;
    then
A25: k < m3 by XREAL_1:8;
    assume
A26: CurInstr Computation( s2,m1+k) = halt SCMPDS;

    CurInstr Computation( s3,k) = CurInstr Computation( s4,k) by A15,A22,
    A8,A17,A20,SCMPDS_6:45

      .= halt SCMPDS by A26,AMI_1:51;
    hence contradiction by A21,A25,AMI_1:def 46;
  end;
  now
    let k be Element of NAT;
    assume
A27: k < m;
    per cases;
    suppose
      k < m1;
      hence CurInstr Computation(s2,k) <> halt SCMPDS by A1,A2,A5,A6, Th46;
    end;
    suppose
      m1 <= k;
      then consider kk being Nat such that
A28:  m1 + kk = k by NAT_1:10;
      reconsider kk as Element of NAT by ORDINAL1:def 13;
      m1+kk=k by A28;
      hence CurInstr Computation(s2,k) <> halt SCMPDS by A24,A27;
    end;
  end;

  then
A29: for k being Element of NAT st CurInstr Computation(s2,k) = halt SCMPDS
  holds m <= k;

A30: s1 is halting by A2,A6,SCMPDS_6:def 3;
  IJ is_halting_on s by A1,A2,A3,A4,Th43;
  then s2 is halting by A5,SCMPDS_6:def 3;
  then LifeSpan s2 = m by A23,A29,AMI_1:def 46;
  hence thesis by A30,AMI_1:122;
end;

theorem ::SCMPDS_5:37
  for I being No-StopCode Program of SCMPDS,J being shiftable Program of
SCMPDS st I is_closed_on s & I is_halting_on s & J is_closed_on IExec(I,s) & J
  is_halting_on IExec(I,s) holds LifeSpan (s +* Initialized stop (I ';' J)) =
LifeSpan (s +* Initialized stop I) + LifeSpan (Result (s +* Initialized stop I)
  +* Initialized stop J) by Lm1;

theorem Th48: :: SCMPDS_5:38
  for I being No-StopCode Program of SCMPDS, J being shiftable
  Program of SCMPDS st I is_closed_on s & I is_halting_on s & J is_closed_on
IExec(I,s) & J is_halting_on IExec(I,s) holds IExec(I ';' J,s) = IExec(J,IExec(
  I,s)) +* Start-At (IC IExec(J,IExec(I,s)) + card I)
proof
  let I be No-StopCode Program of SCMPDS,J be shiftable Program of SCMPDS;
  set ps = s | A, IsI = Initialized stop I, IsJ = Initialized stop J, IJ = I
  ';' J, IsIJ =Initialized stop IJ, s1 = s +* IsI, m1 = LifeSpan s1, s2 = s +*
  IsIJ, s3 = Computation(s1,m1) +* IsJ, m3 = LifeSpan s3, sE = IExec(I,s);
  assume that
A1: I is_closed_on s and
A2: I is_halting_on s and
A3: J is_closed_on sE and
A4: J is_halting_on sE;
A5: DataPart Computation(s2,m1) = DataPart(Computation(s1,m1) +* IsJ) by A1
  ,A2,A3,A4,Lm1;
  J is_closed_on Computation(s1,m1) by A2,A3,A4,Th42;
  then
A6: J is_closed_on s3 by SCMPDS_6:38;
A7: IsJ c= s3 by FUNCT_4:26;
A8: Shift(stop J,card I) c= Computation(s2,m1) by A1,A2,A3,A4,Lm1;
A9: IC Computation(s2,m1) = inspos card I by A1,A2,A3,A4,Lm1;
  then
A10: IC Computation( Computation(s2,m1),m3) = IC Computation(s3,m3) + card I
  by A7,A5,A8,A6,SCMPDS_6:45;
A11: DataPart Computation( Computation(s2,m1),m3) = DataPart Computation(s3,
  m3) by A7,A9,A5,A8,A6,SCMPDS_6:45;
A12: IsJ c= sE +* IsJ by FUNCT_4:26;
  set R1=IExec(I,s) +* IsJ, R2=Result s1 +* IsJ;
A13: dom ps = dom s /\ A by RELAT_1:90
    .= ({IC SCMPDS} \/ D \/ A) /\ A by SCMPDS_4:19
    .= A by XBOOLE_1:21;
A14: IsJ c= R2 by FUNCT_4:26;
A15: IsJ c= R1 by FUNCT_4:26;
A16: Computation(s1,m1) +* IsJ, Computation(s1,m1) +* ps +* IsJ
  equal_outside dom ps by FUNCT_7:31,106;
  then
A17: Computation(s1,m1) +* ps +* IsJ, Computation(s1,m1) +* IsJ
  equal_outside dom ps by FUNCT_7:28;
A18: s1 is halting by A2,SCMPDS_6:def 3;
  then
A19: s3 = Result s1 +* IsJ by AMI_1:122;
A20: DataPart sE = DataPart(sE +* IsJ) by SCMPDS_6:9;
  then
A21: J is_closed_on sE +* IsJ by A3,A4,SCMPDS_6:37;
A22: J is_halting_on sE +* IsJ by A3,A4,A20,SCMPDS_6:37;
  Result s1 = Computation(s1,m1) by A18,AMI_1:122;
  then Result s1 +* ps +* IsJ, Result s1 +* IsJ equal_outside A by A13,A16,
  FUNCT_7:28;
  then
A23: IC Result (Result s1 +* IsJ) = IC Result (IExec(I,s) +* IsJ) by A21,A22
  ,A15,A14,Th28,AMI_1:121;
A24: IsJ c= s3 by FUNCT_4:26;
A25: IExec(I,s) | A = ps by CARD_3:99;
  IJ is_halting_on s by A1,A2,A3,A4,Th43;
  then
A26: s2 is halting by SCMPDS_6:def 3;
  J is_halting_on Computation(s1,m1) by A2,A3,A4,Th42;
  then
A27: s3 is halting by SCMPDS_6:def 3;
  IExec(I,s) = Computation(s1,m1) +* ps by A18,AMI_1:122;
  then Result (IExec(I,s) +* IsJ), Result s3 equal_outside A by A21,A22,A13,
  A17,A12,A24,Th28;
  then Result (IExec(I,s) +* IsJ) +* ps = Result s3 +* ps by A13,
  FUNCT_7:
  108;
  then
A28: IExec(J,IExec(I,s)) = Computation(s3,m3) +* ps by A27,
  A25,AMI_1:122;
A29: IC IExec(I ';' J,s) = IC Result (s +* IsIJ) by SCMPDS_5:22
    .= IC Computation(s2,LifeSpan s2) by A26,AMI_1:122
    .= IC Computation(s2,m1+m3) by A1,A2,A3,A4,A19,Lm1
    .= IC Computation(s3,m3) + card I by A10,AMI_1:51
    .= IC Result s3 + card I by A27,AMI_1:122
    .= IC Result (Result s1 +* IsJ) + card I by A18,AMI_1:122
    .= IC IExec(J,IExec(I,s)) + card I by A23,SCMPDS_5:22;
  IExec(I ';' J,s) = Computation(s2,LifeSpan s2) +* ps by A26,AMI_1:122
    .= Computation(s2,m1+m3) +* ps by A1,A2,A3,A4,A19,Lm1;
  then
A30: DataPart IExec(I ';' J,s) = DataPart Computation(s2,m1+m3) by A13,
  AMI_2:29,FUNCT_4:76,SCMPDS_2:100
    .= DataPart Computation(s3,m3) by A11,AMI_1:51
    .= DataPart IExec(J,IExec(I,s)) by A13,A28,AMI_2:29,FUNCT_4:76,SCMPDS_2:
  100;
  hereby
    reconsider l = IC IExec(J,IExec(I,s)) + card I as Instruction-Location of
    SCMPDS;
A31: dom Start-At l = {IC SCMPDS} by FUNCOP_1:19;
A32: now
      let x be set;
      assume
A33:  x in dom IExec(I ';' J,s);
      per cases by A33,SCMPDS_4:20;
      suppose
A34:    x is Int_position;
        then x <> IC SCMPDS by SCMPDS_2:52;
        then
A35:    not x in dom Start-At l by A31,TARSKI:def 1;
        IExec(I ';' J,s).x = IExec(J,IExec(I,s)).x by A30,A34, SCMPDS_4:
        23;
        hence
        IExec(I ';' J,s).x = (IExec(J,IExec(I,s)) +* Start-At (IC IExec(J
        ,IExec(I,s)) + card I)).x by A35,FUNCT_4:12;
      end;
      suppose
A36:    x = IC SCMPDS;
        then x in {IC SCMPDS} by TARSKI:def 1;
        then
A37:    x in dom Start-At l by FUNCOP_1:19;
        thus IExec(I ';' J,s).x = (Start-At l).IC SCMPDS by A29,A36,FUNCOP_1:
        87
          .= (IExec(J,IExec(I,s)) +* Start-At (IC IExec(J,IExec(I,s)) + card
        I)).x by A36,A37,FUNCT_4:14;
      end;
      suppose
A38:    x is Instruction-Location of SCMPDS;
        then x <> IC SCMPDS by AMI_1:48;
        then
A39:    not x in dom Start-At l by A31,TARSKI:def 1;
        IExec(I ';' J,s) | A = ps by CARD_3:99
          .= IExec(J,IExec(I,s)) | A by A25,CARD_3:99;
        then IExec(I ';' J,s).x = IExec(J,IExec(I,s)).x by A38, SCMPDS_4:
        21;
        hence
        IExec(I ';' J,s).x = (IExec(J,IExec(I,s)) +* Start-At (IC IExec(J
        ,IExec(I,s)) + card I)).x by A39,FUNCT_4:12;
      end;
    end;
    dom IExec(I ';' J,s) = the carrier of SCMPDS by AMI_1:79
      .= dom (IExec(J,IExec(I,s)) +* Start-At (IC IExec(J,IExec(I,s)) + card
    I)) by AMI_1:79;
    hence thesis by A32,FUNCT_1:9;
  end;
end;

theorem Th49: ::SCMPDS_5:39
  for I being No-StopCode Program of SCMPDS, J being shiftable
  Program of SCMPDS st I is_closed_on s & I is_halting_on s & J is_closed_on
  IExec(I,s) & J is_halting_on IExec(I,s) holds IExec(I ';' J, s).a = IExec(J,
  IExec(I,s)).a
proof
  let I be No-StopCode Program of SCMPDS,J be shiftable Program of SCMPDS;
  assume that
A1: I is_closed_on s and
A2: I is_halting_on s and
A3: J is_closed_on IExec(I,s) and
A4: J is_halting_on IExec(I,s);
A5: not a in dom Start-At (IC IExec(J,IExec(I,s)) + card I) by SCMPDS_4:59;
  IExec(I ';' J,s) = IExec(J,IExec(I,s)) +* Start-At (IC IExec(J,IExec(I,s
  )) + card I) by A1,A2,A3,A4,Th48;
  hence thesis by A5,FUNCT_4:12;
end;

theorem Th50: ::SCMPDS_5:46
  for I being No-StopCode Program of SCMPDS,j being parahalting
  shiftable Instruction of SCMPDS st I is_closed_on s & I is_halting_on s holds
  IExec(I ';' j, s).a = Exec(j, IExec(I, s)).a
proof
  let I be No-StopCode Program of SCMPDS,j be parahalting shiftable
  Instruction of SCMPDS;
  assume that
A1: I is_closed_on s and
A2: I is_halting_on s;
  set Mj = Load j;
A3: a in SCM-Data-Loc by SCMPDS_2:def 2;
  for a holds (Initialized IExec(I,s)).a=IExec(I, s).a by SCMPDS_5:40;
  then
A4: DataPart Initialized IExec(I,s) = DataPart IExec(I, s) by
  SCMPDS_4:23;
A5: Mj is_halting_on IExec(I,s) by SCMPDS_6:35;
  Mj is_closed_on IExec(I,s) by SCMPDS_6:34;
  hence IExec(I ';' j, s).a = IExec(Mj,IExec(I,s)).a by A1,A2,A5,Th49
    .= Exec(j, Initialized IExec(I,s)).a by SCMPDS_5:45
    .= (DataPart Exec(j, Initialized IExec(I,s))).a by A3,FUNCT_1:72,
  SCMPDS_2:100
    .= (DataPart Exec(j, IExec(I, s))).a by A4,SCMPDS_5:44
    .= Exec(j, IExec(I, s)).a by A3,FUNCT_1:72,SCMPDS_2:100;
end;

begin :: The construction of for-up loop program

:: while (a,i)<=0 do { I, (a,i)+=n }

definition
  let a be Int_position, i be Integer,n be Element of NAT;
  let I be Program of SCMPDS;
  func for-up(a,i,n,I) -> Program of SCMPDS equals
  (a,i)>=0_goto (card I +3)
  ';' I ';' AddTo(a,i,n) ';' goto -(card I+2);
  coherence;
end;

begin :: The computation of for-up loop program

theorem Th51:
  for a be Int_position,i be Integer,n be Element of NAT,I be
  Program of SCMPDS holds card for-up(a,i,n,I)= card I +3
proof
  let a be Int_position,i be Integer,n be Element of NAT, I be Program of
  SCMPDS;
  set i1=(a,i)>=0_goto (card I +3), i2=AddTo(a,i,n);
  set I4=i1 ';' I, I5=I4 ';' i2;
  card I4=card I+1 by SCMPDS_6:15;
  then card I5=card I +1 +1 by SCMP_GCD:8
    .=card I+ (1+1);
  hence card for-up(a,i,n,I)=card I +2 +1 by SCMP_GCD:8
    .=card I + 3;
end;

Lm2: for a be Int_position,i be Integer,n be Element of NAT, I be Program of
SCMPDS holds card stop for-up(a,i,n,I)= card I+4

proof

  let a be Int_position,i be Integer,n be Element of NAT, I be Program of
  SCMPDS;

  thus card stop for-up(a,i,n,I)= card for-up(a,i,n,I) +1 by SCMPDS_5:7
    .= card I +3+1 by Th51
    .= card I + 4;
end;

theorem Th52:
  for a be Int_position,i be Integer,n,m be Element of NAT, I be
  Program of SCMPDS holds m < card I+3 iff inspos m in dom for-up(a,i,n,I)
proof
  let a be Int_position,i be Integer,n,m be Element of NAT, I be Program of
  SCMPDS;
  card for-up(a,i,n,I)=card I + 3 by Th51;
  hence thesis by SCMPDS_4:1;
end;

theorem Th53:
  for a be Int_position,i be Integer,n be Element of NAT, I be
  Program of SCMPDS holds for-up(a,i,n,I).inspos 0=(a,i)>=0_goto (card I +3) &
for-up(a,i,n,I).inspos (card I+1)=AddTo(a,i,n) & for-up(a,i,n,I).inspos (card I
  +2)=goto -(card I+2)
proof
  let a be Int_position,i be Integer,n be Element of NAT, I be Program of
  SCMPDS;
  set i1=(a,i)>=0_goto (card I +3), i2=AddTo(a,i,n), i3=goto -(card I+2);
  set I4=i1 ';' I, I5=I4 ';' i2;
  set J6=i2 ';' i3, J5=I ';' J6;
  set FLOOP=for-up(a,i,n,I);
  FLOOP=I4 ';' J6 by SCMPDS_4:49;
  then FLOOP=i1 ';' J5 by SCMPDS_4:50;
  hence FLOOP.inspos 0=i1 by SCMPDS_6:16;
A1: card I4=card I+1 by SCMPDS_6:15;
  hence FLOOP.inspos(card I+1)=i2 by SCMP_GCD:11;
  card I5=card I +1 +1 by A1,SCMP_GCD:8
    .=card I+ (1+1);
  hence thesis by SCMP_GCD:10;
end;

theorem Th54:
  for s being State of SCMPDS,I being Program of SCMPDS,a being
  Int_position, i being Integer,n be Element of NAT st s.DataLoc(s.a,i) >= 0
  holds for-up(a,i,n,I) is_closed_on s & for-up(a,i,n,I) is_halting_on s
proof
  let s be State of SCMPDS,I be Program of SCMPDS,a be Int_position, i be
  Integer,n be Element of NAT;
  set d1=DataLoc(s.a,i);
  assume
A1: s.d1 >= 0;
  set i1=(a,i)>=0_goto (card I+3), i2=AddTo(a,i,n), i3=goto -(card I+2);
  set FOR=for-up(a,i,n,I), pFOR=stop FOR, iFOR=Initialized pFOR, s3 = s +*
  iFOR, s4 = Computation(s3,1);
A2: IC s3 =inspos 0 by SCMPDS_6:21;
A3: not d1 in dom iFOR by SCMPDS_4:31;
  not a in dom iFOR by SCMPDS_4:31;
  then
A4: s3.DataLoc(s3.a,i)=s3.d1 by FUNCT_4:12
    .= s.d1 by A3,FUNCT_4:12;
A5: FOR = i1 ';' (I ';' i2 ';' i3) by Th15;
  Computation( s3,0+1) = Following Computation( s3,0) by AMI_1:14
    .= Following s3 by AMI_1:13
    .= Exec(i1,s3) by A5,SCMPDS_6:22;
  then
A6: IC s4 = ICplusConst(s3,(card I+3)) by A1,A4,SCMPDS_2:69
    .= inspos(0+(card I+3)) by A2,SCMPDS_6:23;
A7: card FOR=card I+3 by Th51;
  then
A8: inspos(card I+3) in dom pFOR by SCMPDS_6:25;
  iFOR c= s3 by FUNCT_4:26;
  then pFOR c= s4 by AMI_1:81,SCMPDS_4:57;
  then s4.inspos(card I+3) = pFOR.inspos(card I+3) by A8,GRFUNC_1:8
    .=halt SCMPDS by A7,SCMPDS_6:25;
  then
A9: CurInstr s4 = halt SCMPDS by A6;
  now
    let k be Element of NAT;
    per cases;
    suppose
      0 < k;
      then 1+0 <= k by INT_1:20;
      hence IC Computation(s3,k) in dom pFOR by A8,A6,A9,AMI_1:52;
    end;
    suppose
      k = 0;
      then Computation(s3,k) = s3 by AMI_1:13;
      hence IC Computation(s3,k) in dom pFOR by A2,SCMPDS_4:75;
    end;
  end;
  hence FOR is_closed_on s by SCMPDS_6:def 2;
  s3 is halting by A9,AMI_1:def 20;
  hence thesis by SCMPDS_6:def 3;
end;

theorem Th55:
  for s being State of SCMPDS,I being Program of SCMPDS,a,c being
  Int_position, i being Integer,n be Element of NAT st s.DataLoc(s.a,i) >= 0
  holds IExec(for-up(a,i,n,I),s) = s +* Start-At inspos (card I + 3)
proof
  let s be State of SCMPDS,I be Program of SCMPDS, a,c be Int_position, i be
  Integer,n be Element of NAT;
  set d1=DataLoc(s.a,i);
  set FOR=for-up(a,i,n,I), pFOR=stop FOR, iFOR=Initialized pFOR, s3 = s +*
iFOR, s4 = Computation( s3,1), i1=(a,i)>=0_goto (card I+3), i2=AddTo(a,i,n), i3
  =goto -(card I+2);
  set SAl=Start-At inspos (card I + 3);
A1: IC s3 =inspos 0 by SCMPDS_6:21;
A2: not d1 in dom iFOR by SCMPDS_4:31;
  iFOR c= s3 by FUNCT_4:26;
  then
A3: pFOR c= s4 by AMI_1:81,SCMPDS_4:57;
  not a in dom iFOR by SCMPDS_4:31;
  then
A4: s3.DataLoc(s3.a,i)=s3.d1 by FUNCT_4:12
    .= s.d1 by A2,FUNCT_4:12;
A5: FOR = i1 ';' (I ';' i2 ';' i3) by Th15;
A6: Computation( s3,0+1) = Following Computation( s3,0) by AMI_1:14
    .= Following s3 by AMI_1:13
    .= Exec(i1,s3) by A5,SCMPDS_6:22;
  assume
  s.d1 >= 0;
  then
A7: IC s4 = ICplusConst(s3,(card I+3)) by A6,A4,SCMPDS_2:69
    .= inspos(0+(card I+3)) by A1,SCMPDS_6:23;
A8: card FOR=card I+3 by Th51;
  then inspos(card I+3) in dom pFOR by SCMPDS_6:25;
  then s4.inspos(card I+3) = pFOR.inspos(card I+3) by A3,GRFUNC_1:8
    .=halt SCMPDS by A8,SCMPDS_6:25;
  then
A9: CurInstr s4 = halt SCMPDS by A7;
  then
A10: s3 is halting by AMI_1:def 20;
A11: CurInstr s3 = i1 by A5,SCMPDS_6:22;
  now
    let l be Element of NAT;
    assume
    l < 0+1;
    then l=0 by NAT_1:13;
    then CurInstr Computation( s3,l) = CurInstr s3 by AMI_1:13;
    hence CurInstr Computation( s3,l) <> halt SCMPDS by A11,SCMPDS_6:31;
  end;
  then for l be Element of NAT st CurInstr Computation( s3,l) = halt SCMPDS
  holds 1 <= l;
  then LifeSpan s3 = 1 by A9,A10,AMI_1:def 46;
  then
A12: s4 = Result s3 by A10,AMI_1:122;
A13: dom (s | A) = A by SCMPDS_6:1;
A14: now
    let x be set;
A15: dom SAl = {IC SCMPDS} by FUNCOP_1:19;
    assume
A16: x in dom IExec(FOR,s);
    per cases by A16,SCMPDS_4:20;
    suppose
A17:  x is Int_position;
      then x <> IC SCMPDS by SCMPDS_2:52;
      then
A18:  not x in dom SAl by A15,TARSKI:def 1;
      now
        assume
        x in dom (s | A);
        then reconsider l=x as Instruction-Location of SCMPDS by A13,AMI_1:def
        4;
        l=x;
        hence contradiction by A17,SCMPDS_2:53;
      end;
      hence IExec(FOR,s).x = s4.x by A12,FUNCT_4:12
        .= s3.x by A6,A17,SCMPDS_2:69
        .= s.x by A17,SCMPDS_5:19
        .= (s +* SAl).x by A18,FUNCT_4:12;
    end;
    suppose
A19:  x = IC SCMPDS;
      now
        assume
        x in dom (s | A);
        then reconsider l=x as Instruction-Location of SCMPDS by A13,AMI_1:def
        4;
        l=x;
        hence contradiction by A19,AMI_1:48;
      end;
      hence IExec(FOR,s).x = inspos(card I + 3) by A7,A12,A19, FUNCT_4:12
        .= (s +* SAl).x by A19,Th12;
    end;
    suppose
      x is Instruction-Location of SCMPDS;
      hence IExec(FOR,s).x = (s +* SAl).x by SCMPDS_6:27;
    end;
  end;
  dom IExec(FOR,s) = the carrier of SCMPDS by AMI_1:79
    .= dom (s +* SAl) by AMI_1:79;
  hence thesis by A14,FUNCT_1:9;
end;

theorem
  for s being State of SCMPDS,I being Program of SCMPDS,a being
  Int_position, i being Integer,n be Element of NAT st s.DataLoc(s.a,i) >= 0
  holds IC IExec(for-up(a,i,n,I),s) = inspos (card I + 3)
proof
  let s be State of SCMPDS,I be Program of SCMPDS,a be Int_position, i be
  Integer,n be Element of NAT;
  assume
  s.DataLoc(s.a,i) >= 0;
  then IExec(for-up(a,i,n,I),s) =s +* Start-At inspos (card I+ 3) by
  Th55;
  hence thesis by AMI_1:111;
end;

theorem
  for s being State of SCMPDS,I being Program of SCMPDS,a,b being
  Int_position, i being Integer,n be Element of NAT st s.DataLoc(s.a,i) >= 0
  holds IExec(for-up(a,i,n,I),s).b = s.b
proof
  let s be State of SCMPDS,I be Program of SCMPDS,a,b be Int_position, i be
  Integer,n be Element of NAT;
  assume
  s.DataLoc(s.a,i) >= 0;
  then
A1: IExec(for-up(a,i,n,I),s) = s +* Start-At inspos (card I + 3) by
  Th55;
  not b in dom Start-At inspos (card I + 3) by SCMPDS_4:59;
  hence thesis by A1,FUNCT_4:12;
end;

Lm3: for I being Program of SCMPDS,a being Int_position,i being Integer, n be
Element of NAT holds Shift(I,1) c= for-up(a,i,n,I)

proof

  let I be Program of SCMPDS,a be Int_position,i be Integer, n be Element of
  NAT;

  set i1=(a,i)>=0_goto (card I+3), i2=AddTo(a,i,n), i3=goto -(card I+2);
A1: for-up(a,i,n,I) = Load i1 ';' I ';' (i2 ';' i3) by SCMPDS_4:49;
  card Load i1=1 by SCMPDS_5:6;
  hence thesis by A1,Th16;
end;

theorem Th58:
  for s being State of SCMPDS,I being No-StopCode shiftable
Program of SCMPDS, a be Int_position, i be Integer,n be Element of NAT,X be set
  st s.DataLoc(s.a,i) < 0 & not DataLoc(s.a,i) in X & n > 0 & card I > 0 & a <>
DataLoc(s.a,i) & (for t be State of SCMPDS st (for x be Int_position st x in X
holds t.x=s.x) & t.a=s.a holds IExec(I,t).a=t.a & IExec(I,t).DataLoc(s.a,i)=t.
  DataLoc(s.a,i) & I is_closed_on t & I is_halting_on t & for y be Int_position
st y in X holds IExec(I,t).y=t.y) holds for-up(a,i,n,I) is_closed_on s & for-up
  (a,i,n,I) is_halting_on s
proof
  let s be State of SCMPDS,I be No-StopCode shiftable Program of SCMPDS, a be
  Int_position, i be Integer,n be Element of NAT,X be set;
  set b=DataLoc(s.a,i);
  set FOR=for-up(a,i,n,I), pFOR=stop FOR, iFOR=Initialized pFOR, pI=stop I,
  IsI= Initialized pI;
  set i1=(a,i)>=0_goto (card I+3), i2=AddTo(a,i,n), i3=goto -(card I+2);
  assume
A1: s.b < 0;
  defpred P[Element of NAT] means for t be State of SCMPDS st -t.b <= $1 & (
for x be Int_position st x in X holds t.x=s.x) & t.a=s.a holds FOR is_closed_on
  t & FOR is_halting_on t;
  assume
A2: not b in X;
  assume
A3: n > 0;
  assume
A4: card I > 0;
  assume
A5: a <> b;
  assume
A6: for t be State of SCMPDS st (for x be Int_position st x in X holds t
.x=s.x) & t.a=s.a holds IExec(I,t).a=t.a & IExec(I,t).b=t.b & I is_closed_on t
  & I is_halting_on t & for y be Int_position st y in X holds IExec(I,t).y=t.y;
A7: for k be Element of NAT st P[k] holds P[k + 1]
  proof
    let k be Element of NAT;
    assume
A8: P[k];
    now
      let t be State of SCMPDS;
      assume
A9:   -t.b <= k+1;
      assume
A10:  for x be Int_position st x in X holds t.x=s.x;
      assume
A11:  t.a=s.a;
      per cases;
      suppose
        t.b >= 0;
        hence FOR is_closed_on t & FOR is_halting_on t by A11,Th54;
      end;
      suppose
A12:    t.b < 0;
        set t2 = t +* IsI, t3 = t +* iFOR, t4 = Computation(t3,1);
A13:    IsI c= t2 by FUNCT_4:26;
A14:    dom (t | A) = A by SCMPDS_6:1;
A15:    now
          assume
          a in dom (t | A);
          then reconsider l=a as Instruction-Location of SCMPDS by A14,AMI_1:
          def 4;
          l=a;
          hence contradiction by SCMPDS_2:53;
        end;
A16:    FOR = i1 ';' (I ';' i2 ';' i3) by Th15;
A17:    Computation( t3,0+1) = Following Computation( t3,0) by AMI_1:14
          .= Following t3 by AMI_1:13
          .= Exec(i1,t3) by A16,SCMPDS_6:22;
A18:    DataPart t2 = DataPart t3 by SCMPDS_4:24,36;
        now
          let a;
          thus t2.a = t3.a by A18,SCMPDS_4:23
            .= t4.a by A17,SCMPDS_2:69;
        end;
        then
A19:    DataPart t2 = DataPart t4 by SCMPDS_4:23;
A20:    now
          assume
          b in dom (t | A);
          then reconsider l=b as Instruction-Location of SCMPDS by A14,AMI_1:
          def 4;
          l=b;
          hence contradiction by SCMPDS_2:53;
        end;
A21:    IExec(I,t).b=t.b by A6,A10,A11;
        -(-n) > 0 by A3;
        then -n < 0;
        then -n <= -1 by INT_1:21;
        then
A22:    -n-t.b <= -1-t.b by XREAL_1:11;
        -t.b-1 <= k by A9,XREAL_1:22;
        then
A23:    -n-t.b <= k by A22,XXREAL_0:2;
A24:    I is_closed_on t by A6,A10,A11;
        then
A25:    I is_closed_on t2 by SCMPDS_6:38;
A26:    not b in dom iFOR by SCMPDS_4:31;
        set m2=LifeSpan t2, t5= Computation( t4,m2), l1=inspos (card I + 1);
A27:    IC t3 =inspos 0 by SCMPDS_6:21;
        set m3=m2 +1;
        set t6= Computation( t3,m3);
        card I + 1 < card I + 3 by XREAL_1:8;
        then
A28:    l1 in dom FOR by Th52;
        set m5=m3+1+1, t8= Computation( t3,m5);
        set t7= Computation( t3,m3+1);
A29:    IExec(I,t).a=t.a by A6,A10,A11;
        set l2=inspos(card I+2);
A30:    inspos 0 in dom pFOR by SCMPDS_4:75;
        card I + 2 < card I + 3 by XREAL_1:8;
        then
A31:    l2 in dom FOR by Th52;
A32:    iFOR c= t3 by FUNCT_4:26;
        FOR c= iFOR by SCMPDS_6:17;
        then
A33:    FOR c= t3 by A32,XBOOLE_1:1;
        Shift(I,1) c= FOR by Lm3;
        then Shift(I,1) c= t3 by A33,XBOOLE_1:1;
        then
A34:    Shift(I,1) c= t4 by AMI_1:81;
        I is_halting_on t by A6,A10,A11;
        then
A35:    t2 is halting by SCMPDS_6:def 3;
        then t2 +* IsI is halting by A13,FUNCT_4:79;
        then
A36:    I is_halting_on t2 by SCMPDS_6:def 3;
        not a in dom iFOR by SCMPDS_4:31;
        then t3.DataLoc(t3.a,i)= t3.b by A11,FUNCT_4:12
          .= t.b by A26,FUNCT_4:12;
        then
A37:    IC t4 = Next IC t3 by A12,A17,SCMPDS_2:69
          .= inspos(0+1) by A27;
        then
A38:    IC t5=l1 by A4,A13,A36,A25,A19,A34,Th36;
A39:    t6=t5 by AMI_1:51;
        then
A40:    CurInstr t6=t5.l1 by A4,A13,A36,A25,A37,A19,A34,Th36
          .=t4.l1 by AMI_1:54
          .=t3.l1 by AMI_1:54
          .=FOR.l1 by A28,A33,GRFUNC_1:8
          .=i2 by Th53;
A41:    t7 = Following t6 by AMI_1:14
          .= Exec(i2,t6) by A40;
        then
A42:    IC t7=Next IC t6 by SCMPDS_2:60
          .=inspos(card I+1+1) by A38,A39,NAT_1:39
          .=inspos(card I+(1+1));
        then
A43:    CurInstr t7=t3.l2 by AMI_1:54
          .=FOR.l2 by A33,A31,GRFUNC_1:8
          .=i3 by Th53;
A44:    t8 = Following t7 by AMI_1:14
          .= Exec(i3,t7) by A43;
        then IC t8=ICplusConst(t7,0-(card I+2)) by SCMPDS_2:66
          .=inspos 0 by A42,Th1;
        then
A45:    t8 +* iFOR=t8 by Th37;
A46:    DataPart Computation( t2,m2) = DataPart t5 by A4,A13,A36,A25,A37,
        A19,A34,Th36;
        then
A47:    t5.a= Computation( t2,m2).a by SCMPDS_4:23
          .=(Result t2).a by A35,AMI_1:122
          .=s.a by A11,A29,A15,FUNCT_4:12;
        then DataLoc(t6.a,i)=b by AMI_1:51;
        then t7.a=t6.a by A5,A41,SCMPDS_2:60
          .=s.a by A47,AMI_1:51;
        then
A48:    t8.a=s.a by A44,SCMPDS_2:66;
A49:    now
          let x be Int_position;
          assume
A50:      x in X;
A51:      now
            assume
            x in dom (t | A);
            then reconsider l=x as Instruction-Location of SCMPDS by A14,
            AMI_1:
            def 4;
            l=x;
            hence contradiction by SCMPDS_2:53;
          end;
          t5.x= Computation( t2,m2).x by A46,SCMPDS_4:23
            .=(Result t2).x by A35,AMI_1:122
            .=IExec(I,t).x by A51,FUNCT_4:12
            .=t.x by A6,A10,A11,A50
            .=s.x by A10,A50;
          then t7.x=s.x by A2,A47,A39,A41,A50,SCMPDS_2:60;
          hence t8.x=s.x by A44,SCMPDS_2:66;
        end;
A52:    t5.b= Computation( t2,m2).b by A46,SCMPDS_4:23
          .=(Result t2).b by A35,AMI_1:122
          .=t.b by A21,A20,FUNCT_4:12;
        t8.b=t7.b by A44,SCMPDS_2:66
          .=t.b+n by A47,A52,A39,A41,SCMPDS_2:60;
        then
A53:    -t8.b=-n-t.b;
        then
A54:    FOR is_closed_on t8 by A8,A48,A49,A23;
        now
          let k be Element of NAT;
          per cases;
          suppose
            k < m5;
            then k <= m3+1 by INT_1:20;
            then
A55:        k <= m3 or k=m3+1 by NAT_1:8;
            hereby
              per cases by A55,NAT_1:8;
              suppose
A56:            k <= m2;
                hereby
                  per cases;
                  suppose
                    k=0;
                    hence IC Computation( t3,k) in dom pFOR by A30,A27,
                    AMI_1:13;
                  end;
                  suppose
                    k<>0;
                    then consider kn be Nat such that
A57:                k=kn+1 by NAT_1:6;
                    reconsider kn as Element of NAT by ORDINAL1:def 13;
                    reconsider lm = IC Computation( t2,kn) as Element of NAT
                    by ORDINAL1:def 13;
                    kn < k by A57,XREAL_1:31;
                    then kn < m2 by A56,XXREAL_0:2;
                    then IC Computation( t2,kn) + 1 = IC Computation(t4,kn)
                    by A4,A13,A36,A25,A37,A19,A34,Th34;
                    then
A58:                IC Computation( t3,k)=inspos lm +1 by A57,
                    AMI_1:51
                      .=inspos (lm+1);
                    IC Computation( t2,kn) in dom pI by A24,SCMPDS_6:def
                    2;
                    then lm < card pI by SCMPDS_4:1;
                    then lm < card I+1 by SCMPDS_5:7;
                    then
A59:                lm+1 <= card I +1 by INT_1:20;
                    card I + 1 < card I + 4 by XREAL_1:8;
                    then lm+1 < card I +4 by A59,XXREAL_0:2;
                    then lm+1 < card pFOR by Lm2;
                    hence IC Computation( t3,k) in dom pFOR by A58,
                    SCMPDS_4:1;
                  end;
                end;
              end;
              suppose
A60:            k=m3;
                l1 in dom pFOR by A28,SCMPDS_6:18;
                hence
                IC Computation( t3,k) in dom pFOR by A4,A13,A36,A25,A37,
                A19,A34,A39,A60,Th36;
              end;
              suppose
                k=m3+1;
                hence IC Computation( t3,k) in dom pFOR by A42,A31,
                SCMPDS_6:18;
              end;
            end;
          end;
          suppose
            k >= m5;
            then consider nn be Nat such that
A61:        k=m5+nn by NAT_1:10;
            reconsider nn as Element of NAT by ORDINAL1:def 13;
            Computation(t3,k)= Computation( (t8 +* iFOR),nn) by A45,A61
            ,AMI_1:51;
            hence IC Computation( t3,k) in dom pFOR by A54, SCMPDS_6:def 2;
          end;
        end;
        hence FOR is_closed_on t by SCMPDS_6:def 2;
        FOR is_halting_on t8 by A8,A48,A49,A23,A53;
        then t8 is halting by A45,SCMPDS_6:def 3;
        then t3 is halting by AMI_1:93;
        hence FOR is_halting_on t by SCMPDS_6:def 3;
      end;
    end;
    hence thesis;
  end;
  reconsider n=-s.b as Element of NAT by A1,INT_1:16;
A62: P[0]
  proof
    let t be State of SCMPDS;
    assume
    -t.b <= 0;
    then -t.b <= -0;
    then
A63: t.b >= 0 by XREAL_1:26;
    assume
    for x be Int_position st x in X holds t.x=s.x;
    assume
    t.a=s.a;
    hence thesis by A63,Th54;
  end;
  for k being Element of NAT holds P[k] from NAT_1:sch 1(A62,A7);
  then
A64: P[n];
  for x be Int_position st x in X holds s.x=s.x;
  hence thesis by A64;
end;

theorem
  for s being State of SCMPDS,I being No-StopCode shiftable Program of
  SCMPDS, a be Int_position, i be Integer,n be Element of NAT,X be set st s.
  DataLoc(s.a,i) < 0 & not DataLoc(s.a,i) in X & n > 0 & card I > 0 & a <>
DataLoc(s.a,i) & (for t be State of SCMPDS st (for x be Int_position st x in X
holds t.x=s.x) & t.a=s.a holds IExec(I,t).a=t.a & IExec(I,t).DataLoc(s.a,i)=t.
  DataLoc(s.a,i) & I is_closed_on t & I is_halting_on t & for y be Int_position
st y in X holds IExec(I,t).y=t.y) holds IExec(for-up(a,i,n,I),s) = IExec(for-up
  (a,i,n,I),IExec(I ';' AddTo(a,i,n),s))
proof
  let s be State of SCMPDS,I be No-StopCode shiftable Program of SCMPDS, a be
  Int_position, i be Integer,n be Element of NAT,X be set;
  set b=DataLoc(s.a,i);
  set FOR=for-up(a,i,n,I), iFOR=Initialized stop FOR, iI= Initialized stop I,
  s1= s +* iFOR, ps= s | A;
  set i1=(a,i)>=0_goto (card I+3), i2=AddTo(a,i,n), i3=goto -(card I+2);
  assume
A1: s.b < 0;
  set s4 = Computation(s1,1);
A2: IC s1 =inspos 0 by SCMPDS_6:21;
A3: not b in dom iFOR by SCMPDS_4:31;
  set m0=LifeSpan s1;
  set l2=inspos(card I+2);
  set sI= s +* iI, m1=LifeSpan sI+3, J=I ';' AddTo(a,i,n), sJ=s +* Initialized
  stop J, s2=IExec(J,s) +* iFOR, m2=LifeSpan s2;
  set Es=IExec(J,s), bj=DataLoc(Es.a,i);
A4: iI c= sI by FUNCT_4:26;
A5: dom (s | A) = A by SCMPDS_6:1;
A6: now
    assume
    a in dom (s | A);
    then reconsider l=a as Instruction-Location of SCMPDS by A5,AMI_1:def 4;
    l=a;
    hence contradiction by SCMPDS_2:53;
  end;
A7: now
    assume
    b in dom (s | A);
    then reconsider l=b as Instruction-Location of SCMPDS by A5,AMI_1:def 4;
    l=b;
    hence contradiction by SCMPDS_2:53;
  end;
A8: FOR = i1 ';' (I ';' i2 ';' i3) by Th15;
  set mI=LifeSpan sI, s5= Computation( s4,mI), l1=inspos (card I + 1);
  set m3=mI +1;
  set s6= Computation( s1,m3);
  set s7= Computation( s1,m3+1);
A9: iFOR c= s1 by FUNCT_4:26;
  FOR c= iFOR by SCMPDS_6:17;
  then
A10: FOR c= s1 by A9,XBOOLE_1:1;
  Shift(I,1) c= FOR by Lm3;
  then Shift(I,1) c= s1 by A10,XBOOLE_1:1;
  then
A11: Shift(I,1) c= s4 by AMI_1:81;
  card I + 2 < card I + 3 by XREAL_1:8;
  then
A12: l2 in dom FOR by Th52;
  set m5=m3+1+1, s8= Computation( s1,m5);
A13: dom ps = dom s /\ A by RELAT_1:90
    .= ({IC SCMPDS} \/ D \/ A) /\ A by SCMPDS_4:19
    .= A by XBOOLE_1:21;
  card I + 1 < card I + 3 by XREAL_1:8;
  then
A14: l1 in dom FOR by Th52;
  assume
A15: not b in X;
  assume
A16: n > 0;
  assume
A17: card I > 0;
  assume
A18: a <> b;
  assume
A19: for t be State of SCMPDS st (for x be Int_position st x in X holds t
.x=s.x) & t.a=s.a holds IExec(I,t).a=t.a & IExec(I,t).b=t.b & I is_closed_on t
  & I is_halting_on t & for y be Int_position st y in X holds IExec(I,t).y=t.y;
  then FOR is_halting_on s by A1,A15,A16,A17,A18,Th58;
  then
A20: s1 is halting by SCMPDS_6:def 3;
A21: for x be Int_position st x in X holds s.x=s.x;
  then
A22: IExec(I,s).b=s.b by A19;
A23: IExec(I, s).a=s.a by A19,A21;
A24: b=DataLoc(IExec(I, s).a,i) by A19,A21;
A25: IExec(I,s).a=s.a by A19,A21;
A26: Computation( s1,0+1) = Following Computation( s1,0) by AMI_1:14
    .= Following s1 by AMI_1:13
    .= Exec(i1,s1) by A8,SCMPDS_6:22;
  not a in dom iFOR by SCMPDS_4:31;
  then s1.DataLoc(s1.a,i)=s1.b by FUNCT_4:12
    .= s.b by A3,FUNCT_4:12;
  then
A27: IC s4 = Next IC s1 by A1,A26,SCMPDS_2:69
    .= inspos(0+1) by A2;
A28: DataPart sI = DataPart s1 by SCMPDS_4:24,36;
  now
    let a;
    thus sI.a = s1.a by A28,SCMPDS_4:23
      .= s4.a by A26,SCMPDS_2:69;
  end;
  then
A29: DataPart sI = DataPart s4 by SCMPDS_4:23;
A30: I is_halting_on s by A19,A21;
  then
A31: sI is halting by SCMPDS_6:def 3;
  then sI +* iI is halting by A4,FUNCT_4:79;
  then
A32: I is_halting_on sI by SCMPDS_6:def 3;
A33: I is_closed_on s by A19,A21;
  then
A34: Es.b=Exec(i2, IExec(I, s)).b by A30,Th50
    .=IExec(I, s).b+n by A23,SCMPDS_2:60
    .=s.b+n by A19,A21;
A35: I is_closed_on sI by A33,SCMPDS_6:38;
  then
A36: IC s5=l1 by A17,A4,A32,A27,A29,A11,Th36;
A37: s6=s5 by AMI_1:51;
  then
A38: CurInstr s6=s5.l1 by A17,A4,A32,A35,A27,A29,A11,Th36
    .=s4.l1 by AMI_1:54
    .=s1.l1 by AMI_1:54
    .=FOR.l1 by A14,A10,GRFUNC_1:8
    .=i2 by Th53;
A39: DataPart Computation( sI,mI) = DataPart s5 by A17,A4,A32,A35,A27,A29,
  A11,Th36;
  then
A40: s5.a= Computation( sI,mI).a by SCMPDS_4:23
    .=(Result sI).a by A31,AMI_1:122
    .=s.a by A25,A6,FUNCT_4:12;
A41: Es.a=Exec(i2, IExec(I, s)).a by A33,A30,Th50
    .=s.a by A18,A23,SCMPDS_2:60;
  now
    per cases;
    suppose
      Es.bj >= 0;
      hence FOR is_halting_on Es by Th54;
    end;
    suppose
A42:  Es.bj<0;
      now
        let t be State of SCMPDS;
        assume that
A43:    for x be Int_position st x in X holds t.x=Es.x and
A44:    t.a=Es.a;
A45:    now
          let x be Int_position;
          assume
A46:      x in X;
          hence t.x=Es.x by A43
            .=Exec(i2, IExec(I, s)).x by A33,A30,Th50
            .=IExec(I, s).x by A15,A23,A46,SCMPDS_2:60
            .=s.x by A19,A21,A46;
        end;
        hence IExec(I,t).a=t.a by A19,A41,A44;
        thus IExec(I,t).bj= t.bj by A19,A41,A44,A45;
        thus I is_closed_on t & I is_halting_on t & for y be Int_position st y
        in X holds IExec(I,t).y=t.y by A19,A41,A44,A45;
      end;
      hence FOR is_halting_on Es by A15,A16,A17,A18,A41,A42,Th58;
    end;
  end;
  then
A47: s2 is halting by SCMPDS_6:def 3;
A48: s7 = Following s6 by AMI_1:14
    .= Exec(i2,s6) by A38;
  then
A49: IC s7=Next IC s6 by SCMPDS_2:60
    .=inspos(card I+1+1) by A36,A37,NAT_1:39
    .=inspos(card I+(1+1));
  then
A50: CurInstr s7=s1.l2 by AMI_1:54
    .=FOR.l2 by A10,A12,GRFUNC_1:8
    .=i3 by Th53;
A51: s8 = Following s7 by AMI_1:14
    .= Exec(i3,s7) by A50;
  then IC s8=ICplusConst(s7,0-(card I+2)) by SCMPDS_2:66
    .=inspos 0 by A49,Th1;
  then
A52: IC s2 =IC Computation(s1,m1) by SCMPDS_6:21;
A53: s5.b= Computation( sI,mI).b by A39,SCMPDS_4:23
    .=(Result sI).b by A31,AMI_1:122
    .=s.b by A22,A7,FUNCT_4:12;
A54: s8.b=s7.b by A51,SCMPDS_2:66
    .=s.b+n by A40,A53,A37,A48,SCMPDS_2:60;
  now
    let x be Int_position;
A55: not x in dom iFOR by SCMPDS_4:31;
    then
A56: s2.x=IExec(J,s).x by FUNCT_4:12;
    per cases;
    suppose
      x=b;
      hence s8.x=s2.x by A54,A34,A55,FUNCT_4:12;
    end;
    suppose
A57:  x<>b;
A58:  now
        assume
        x in dom (s | A);
        then reconsider l=x as Instruction-Location of SCMPDS by A5,AMI_1:def
        4;
        l=x;
        hence contradiction by SCMPDS_2:53;
      end;
A59:  s5.x= Computation( sI,mI).x by A39,SCMPDS_4:23
        .=(Result sI).x by A31,AMI_1:122
        .=IExec(I,s).x by A58,FUNCT_4:12;
A60:  s7.x=s5.x by A40,A37,A48,A57,SCMPDS_2:60;
      Es.x=Exec(i2, IExec(I, s)).x by A33,A30,Th50
        .=IExec(I, s).x by A24,A57,SCMPDS_2:60;
      hence s8.x=s2.x by A51,A56,A59,A60,SCMPDS_2:66;
    end;
  end;
  then
A61: DataPart s8 = DataPart s2 by SCMPDS_4:23;
  s2 | A=(Result sJ +* ps)|A +* iFOR | A by FUNCT_4:75
    .= ps +* iFOR | A by A13,FUNCT_4:24
    .= s1 | A by FUNCT_4:75
    .= Computation(s1,m1) | A by Th6;
  then
A62: Computation(s1,m1)=s2 by A61,A52,Th7;
  then CurInstr Computation(s1,m1)=i1 by A8,SCMPDS_6:22;
  then m0 > m1 by A20,SCMPDS_6:2,31;
  then consider nn be Nat such that
A63: m0=m1+nn by NAT_1:10;
  reconsider nn as Element of NAT by ORDINAL1:def 13;
  Computation(s1,m1+m2) = Computation(s2,m2) by A62,AMI_1:51;
  then CurInstr Computation(s1,m1+m2) = halt SCMPDS by A47,AMI_1:def 46;
  then m1 + m2 >= m0 by A20,AMI_1:def 46;
  then
A64: m2 >= nn by A63,XREAL_1:8;
A65: Computation(s1,m0) = Computation(s2,nn) by A62,A63,AMI_1:51;
  then CurInstr Computation(s2,nn) =halt SCMPDS by A20,AMI_1:def 46;
  then nn >= m2 by A47,AMI_1:def 46;
  then nn=m2 by A64,XXREAL_0:1;
  then
A66: Result s1 = Computation(s2,m2) by A20,A65,AMI_1:122;
  IExec(J,s) | A= ps by A13,FUNCT_4:24;
  hence thesis by A47,A66,AMI_1:122;
end;

registration
  let I be shiftable Program of SCMPDS, a be Int_position,i be Integer,n be
  Element of NAT;
  cluster for-up(a,i,n,I) -> shiftable;
  correctness
  proof
    set FOR=for-up(a,i,n,I), i1= (a,i)>=0_goto (card I +3), i2= AddTo(a,i,n);
    set PF= Load i1 ';' I ';' i2;
    card PF=card (i1 ';' I) + 1 by SCMP_GCD:8
      .=card I + 1+1 by SCMPDS_6:15
      .=card I +(1+1);
    then card PF+ -(card I+2) =0;
    hence thesis by SCMPDS_4:78;
  end;
end;

registration
  let I be No-StopCode Program of SCMPDS, a be Int_position,i be Integer,n be
  Element of NAT;
  cluster for-up(a,i,n,I) -> No-StopCode;
  correctness
  proof
    -(card I+2) <> 0;
    then reconsider
    i3=goto -(card I+2) as No-StopCode Instruction of SCMPDS by
    SCMPDS_5:25;
    for-up(a,i,n,I) = (a,i)>=0_goto (card I +3) ';' I ';' AddTo(a,i,n) ';'
    i3;
    hence thesis;
  end;
end;

begin :: The construction of  for-down loop program

:: while (a,i)>=0 do { I, (a,i)-=n }

definition
  let a be Int_position, i be Integer,n be Element of NAT;
  let I be Program of SCMPDS;
  func for-down(a,i,n,I) -> Program of SCMPDS equals
  (a,i)<=0_goto (card I +3)
  ';' I ';' AddTo(a,i,-n) ';' goto -(card I+2);
  coherence;
end;

begin :: The computation of  for-down loop program

theorem Th60:
  for a be Int_position,i be Integer,n be Element of NAT,I be
  Program of SCMPDS holds card for-down(a,i,n,I)= card I +3
proof
  let a be Int_position,i be Integer,n be Element of NAT, I be Program of
  SCMPDS;
  set i1=(a,i)<=0_goto (card I +3), i2=AddTo(a,i,-n);
  set I4=i1 ';' I, I5=I4 ';' i2;
  card I4=card I+1 by SCMPDS_6:15;
  then card I5=card I +1 +1 by SCMP_GCD:8
    .=card I+ (1+1);
  hence card for-down(a,i,n,I)=card I +2 +1 by SCMP_GCD:8
    .=card I + 3;
end;

Lm4: for a be Int_position,i be Integer,n be Element of NAT, I be Program of
SCMPDS holds card stop for-down(a,i,n,I)= card I+4

proof

  let a be Int_position,i be Integer,n be Element of NAT, I be Program of
  SCMPDS;

  thus card stop for-down(a,i,n,I)= card for-down(a,i,n,I) +1 by SCMPDS_5:7
    .= card I +3+1 by Th60
    .= card I + 4;
end;

theorem Th61:
  for a be Int_position,i be Integer,n,m be Element of NAT, I be
  Program of SCMPDS holds m < card I+3 iff inspos m in dom for-down(a,i,n,I)
proof
  let a be Int_position,i be Integer,n,m be Element of NAT, I be Program of
  SCMPDS;
  card for-down(a,i,n,I)=card I + 3 by Th60;
  hence thesis by SCMPDS_4:1;
end;

theorem Th62:
  for a be Int_position,i be Integer,n be Element of NAT, I be
Program of SCMPDS holds for-down(a,i,n,I).inspos 0=(a,i)<=0_goto (card I +3) &
for-down(a,i,n,I).inspos (card I+1)=AddTo(a,i,-n) & for-down(a,i,n,I).inspos (
  card I+2)=goto -(card I+2)
proof
  let a be Int_position,i be Integer,n be Element of NAT, I be Program of
  SCMPDS;
  set i1=(a,i)<=0_goto (card I +3), i2=AddTo(a,i,-n), i3=goto -(card I+2);
  set I4=i1 ';' I, I5=I4 ';' i2;
  set J6=i2 ';' i3, J5=I ';' J6;
  set FLOOP=for-down(a,i,n,I);
  FLOOP=I4 ';' J6 by SCMPDS_4:49;
  then FLOOP=i1 ';' J5 by SCMPDS_4:50;
  hence FLOOP.inspos 0=i1 by SCMPDS_6:16;
A1: card I4=card I+1 by SCMPDS_6:15;
  hence FLOOP.inspos(card I+1)=i2 by SCMP_GCD:11;
  card I5=card I +1 +1 by A1,SCMP_GCD:8
    .=card I+ (1+1);
  hence thesis by SCMP_GCD:10;
end;

theorem Th63:
  for s being State of SCMPDS,I being Program of SCMPDS,a being
  Int_position, i being Integer,n be Element of NAT st s.DataLoc(s.a,i) <= 0
  holds for-down(a,i,n,I) is_closed_on s & for-down(a,i,n,I) is_halting_on s
proof
  let s be State of SCMPDS,I be Program of SCMPDS,a be Int_position, i be
  Integer,n be Element of NAT;
  set d1=DataLoc(s.a,i);
  assume
A1: s.d1 <= 0;
  set i1=(a,i)<=0_goto (card I+3), i2=AddTo(a,i,-n), i3=goto -(card I+2);
  set FOR=for-down(a,i,n,I), pFOR=stop FOR, iFOR=Initialized pFOR, s3 = s +*
  iFOR, s4 = Computation(s3,1);
A2: IC s3 =inspos 0 by SCMPDS_6:21;
A3: not d1 in dom iFOR by SCMPDS_4:31;
  not a in dom iFOR by SCMPDS_4:31;
  then
A4: s3.DataLoc(s3.a,i)=s3.d1 by FUNCT_4:12
    .= s.d1 by A3,FUNCT_4:12;
A5: FOR = i1 ';' (I ';' i2 ';' i3) by Th15;
  Computation( s3,0+1) = Following Computation( s3,0) by AMI_1:14
    .= Following s3 by AMI_1:13
    .= Exec(i1,s3) by A5,SCMPDS_6:22;
  then
A6: IC s4 = ICplusConst(s3,(card I+3)) by A1,A4,SCMPDS_2:68
    .= inspos(0+(card I+3)) by A2,SCMPDS_6:23;
A7: card FOR=card I+3 by Th60;
  then
A8: inspos(card I+3) in dom pFOR by SCMPDS_6:25;
  iFOR c= s3 by FUNCT_4:26;
  then pFOR c= s4 by AMI_1:81,SCMPDS_4:57;
  then s4.inspos(card I+3) = pFOR.inspos(card I+3) by A8,GRFUNC_1:8
    .=halt SCMPDS by A7,SCMPDS_6:25;
  then
A9: CurInstr s4 = halt SCMPDS by A6;
  now
    let k be Element of NAT;
    per cases;
    suppose
      0 < k;
      then 1+0 <= k by INT_1:20;
      hence IC Computation(s3,k) in dom pFOR by A8,A6,A9,AMI_1:52;
    end;
    suppose
      k = 0;
      then Computation(s3,k) = s3 by AMI_1:13;
      hence IC Computation(s3,k) in dom pFOR by A2,SCMPDS_4:75;
    end;
  end;
  hence FOR is_closed_on s by SCMPDS_6:def 2;
  s3 is halting by A9,AMI_1:def 20;
  hence thesis by SCMPDS_6:def 3;
end;

theorem Th64:
  for s being State of SCMPDS,I being Program of SCMPDS,a,c being
  Int_position, i being Integer,n be Element of NAT st s.DataLoc(s.a,i) <= 0
  holds IExec(for-down(a,i,n,I),s) = s +* Start-At inspos (card I + 3)
proof
  let s be State of SCMPDS,I be Program of SCMPDS, a,c be Int_position, i be
  Integer,n be Element of NAT;
  set d1=DataLoc(s.a,i);
  set FOR=for-down(a,i,n,I), pFOR=stop FOR, iFOR=Initialized pFOR, s3 = s +*
  iFOR, s4 = Computation( s3,1), i1=(a,i)<=0_goto (card I+3), i2=AddTo(a,i,-n),
  i3=goto -(card I+2);
  set SAl=Start-At inspos (card I + 3);
A1: IC s3 =inspos 0 by SCMPDS_6:21;
A2: not d1 in dom iFOR by SCMPDS_4:31;
  iFOR c= s3 by FUNCT_4:26;
  then
A3: pFOR c= s4 by AMI_1:81,SCMPDS_4:57;
  not a in dom iFOR by SCMPDS_4:31;
  then
A4: s3.DataLoc(s3.a,i)=s3.d1 by FUNCT_4:12
    .= s.d1 by A2,FUNCT_4:12;
A5: FOR = i1 ';' (I ';' i2 ';' i3) by Th15;
A6: Computation( s3,0+1) = Following Computation( s3,0) by AMI_1:14
    .= Following s3 by AMI_1:13
    .= Exec(i1,s3) by A5,SCMPDS_6:22;
  assume
  s.d1 <= 0;
  then
A7: IC s4 = ICplusConst(s3,(card I+3)) by A6,A4,SCMPDS_2:68
    .= inspos(0+(card I+3)) by A1,SCMPDS_6:23;
A8: card FOR=card I+3 by Th60;
  then inspos(card I+3) in dom pFOR by SCMPDS_6:25;
  then s4.inspos(card I+3) = pFOR.inspos(card I+3) by A3,GRFUNC_1:8
    .=halt SCMPDS by A8,SCMPDS_6:25;
  then
A9: CurInstr s4 = halt SCMPDS by A7;
  then
A10: s3 is halting by AMI_1:def 20;
A11: CurInstr s3 = i1 by A5,SCMPDS_6:22;
  now
    let l be Element of NAT;
    assume
    l < 0+1;
    then l=0 by NAT_1:13;
    then CurInstr Computation( s3,l) = CurInstr s3 by AMI_1:13;
    hence CurInstr Computation( s3,l) <> halt SCMPDS by A11,SCMPDS_6:30;
  end;
  then for l be Element of NAT st CurInstr Computation( s3,l) = halt SCMPDS
  holds 1 <= l;
  then LifeSpan s3 = 1 by A9,A10,AMI_1:def 46;
  then
A12: s4 = Result s3 by A10,AMI_1:122;
A13: dom (s | A) = A by SCMPDS_6:1;
A14: now
    let x be set;
A15: dom SAl = {IC SCMPDS} by FUNCOP_1:19;
    assume
A16: x in dom IExec(FOR,s);
    per cases by A16,SCMPDS_4:20;
    suppose
A17:  x is Int_position;
      then x <> IC SCMPDS by SCMPDS_2:52;
      then
A18:  not x in dom SAl by A15,TARSKI:def 1;
      now
        assume
        x in dom (s | A);
        then reconsider l=x as Instruction-Location of SCMPDS by A13,AMI_1:def
        4;
        l=x;
        hence contradiction by A17,SCMPDS_2:53;
      end;
      hence IExec(FOR,s).x = s4.x by A12,FUNCT_4:12
        .= s3.x by A6,A17,SCMPDS_2:68
        .= s.x by A17,SCMPDS_5:19
        .= (s +* SAl).x by A18,FUNCT_4:12;
    end;
    suppose
A19:  x = IC SCMPDS;
      now
        assume
        x in dom (s | A);
        then reconsider l=x as Instruction-Location of SCMPDS by A13,AMI_1:def
        4;
        l=x;
        hence contradiction by A19,AMI_1:48;
      end;
      hence IExec(FOR,s).x = inspos(card I + 3) by A7,A12,A19, FUNCT_4:12
        .= (s +* SAl).x by A19,Th12;
    end;
    suppose
      x is Instruction-Location of SCMPDS;
      hence IExec(FOR,s).x = (s +* SAl).x by SCMPDS_6:27;
    end;
  end;
  dom IExec(FOR,s) = the carrier of SCMPDS by AMI_1:79
    .= dom (s +* SAl) by AMI_1:79;
  hence thesis by A14,FUNCT_1:9;
end;

theorem
  for s being State of SCMPDS,I being Program of SCMPDS,a being
  Int_position, i being Integer,n be Element of NAT st s.DataLoc(s.a,i) <= 0
  holds IC IExec(for-down(a,i,n,I),s) = inspos (card I + 3)
proof
  let s be State of SCMPDS,I be Program of SCMPDS,a be Int_position, i be
  Integer,n be Element of NAT;
  assume
  s.DataLoc(s.a,i) <= 0;
  then IExec(for-down(a,i,n,I),s) =s +* Start-At inspos (card I+ 3) by
  Th64;
  hence thesis by AMI_1:111;
end;

theorem Th66:
  for s being State of SCMPDS,I being Program of SCMPDS,a,b being
  Int_position, i being Integer,n be Element of NAT st s.DataLoc(s.a,i) <= 0
  holds IExec(for-down(a,i,n,I),s).b = s.b
proof
  let s be State of SCMPDS,I be Program of SCMPDS,a,b be Int_position, i be
  Integer,n be Element of NAT;
  assume
  s.DataLoc(s.a,i) <= 0;
  then
A1: IExec(for-down(a,i,n,I),s) = s +* Start-At inspos (card I + 3) by
  Th64;
  not b in dom Start-At inspos (card I + 3) by SCMPDS_4:59;
  hence thesis by A1,FUNCT_4:12;
end;

Lm5: for I being Program of SCMPDS,a being Int_position,i being Integer, n be
Element of NAT holds Shift(I,1) c= for-down(a,i,n,I)

proof

  let I be Program of SCMPDS,a be Int_position,i be Integer, n be Element of
  NAT;

  set i1=(a,i)<=0_goto (card I+3), i2=AddTo(a,i,-n), i3=goto -(card I+2);
A1: for-down(a,i,n,I) = Load i1 ';' I ';' (i2 ';' i3) by SCMPDS_4:49;
  card Load i1=1 by SCMPDS_5:6;
  hence thesis by A1,Th16;
end;

theorem Th67:
  for s being State of SCMPDS,I being No-StopCode shiftable
Program of SCMPDS, a be Int_position, i be Integer,n be Element of NAT,X be set
  st s.DataLoc(s.a,i) > 0 & not DataLoc(s.a,i) in X & n > 0 & card I > 0 & a <>
DataLoc(s.a,i) & (for t be State of SCMPDS st (for x be Int_position st x in X
holds t.x=s.x) & t.a=s.a holds IExec(I,t).a=t.a & IExec(I,t).DataLoc(s.a,i)=t.
  DataLoc(s.a,i) & I is_closed_on t & I is_halting_on t & for y be Int_position
  st y in X holds IExec(I,t).y=t.y) holds for-down(a,i,n,I) is_closed_on s &
  for-down(a,i,n,I) is_halting_on s
proof
  let s be State of SCMPDS,I be No-StopCode shiftable Program of SCMPDS, a be
  Int_position, i be Integer,n be Element of NAT,X be set;
  set b=DataLoc(s.a,i);
  set FOR=for-down(a,i,n,I), pFOR=stop FOR, iFOR=Initialized pFOR, pI=stop I,
  IsI= Initialized pI;
  set i1=(a,i)<=0_goto (card I+3), i2=AddTo(a,i,-n), i3=goto -(card I+2);
  assume
A1: s.b > 0;
  defpred P[Element of NAT] means for t be State of SCMPDS st t.b <= $1 & (for
x be Int_position st x in X holds t.x=s.x) & t.a=s.a holds FOR is_closed_on t &
  FOR is_halting_on t;
  assume
A2: not b in X;
  assume
A3: n > 0;
  assume
A4: card I > 0;
  assume
A5: a <> b;
  assume
A6: for t be State of SCMPDS st (for x be Int_position st x in X holds t
.x=s.x) & t.a=s.a holds IExec(I,t).a=t.a & IExec(I,t).b=t.b & I is_closed_on t
  & I is_halting_on t & for y be Int_position st y in X holds IExec(I,t).y=t.y;
A7: for k be Element of NAT st P[k] holds P[k + 1]
  proof
    let k be Element of NAT;
    assume
A8: P[k];
    now
      let t be State of SCMPDS;
      assume
A9:   t.b <= k+1;
      assume
A10:  for x be Int_position st x in X holds t.x=s.x;
      assume
A11:  t.a=s.a;
      per cases;
      suppose
        t.b <= 0;
        hence FOR is_closed_on t & FOR is_halting_on t by A11,Th63;
      end;
      suppose
A12:    t.b > 0;
        set t2 = t +* IsI, t3 = t +* iFOR, t4 = Computation(t3,1);
A13:    IsI c= t2 by FUNCT_4:26;
A14:    dom (t | A) = A by SCMPDS_6:1;
A15:    now
          assume
          a in dom (t | A);
          then reconsider l=a as Instruction-Location of SCMPDS by A14,AMI_1:
          def 4;
          l=a;
          hence contradiction by SCMPDS_2:53;
        end;
A16:    FOR = i1 ';' (I ';' i2 ';' i3) by Th15;
A17:    Computation( t3,0+1) = Following Computation( t3,0) by AMI_1:14
          .= Following t3 by AMI_1:13
          .= Exec(i1,t3) by A16,SCMPDS_6:22;
A18:    DataPart t2 = DataPart t3 by SCMPDS_4:24,36;
        now
          let a;
          thus t2.a = t3.a by A18,SCMPDS_4:23
            .= t4.a by A17,SCMPDS_2:68;
        end;
        then
A19:    DataPart t2 = DataPart t4 by SCMPDS_4:23;
A20:    now
          assume
          b in dom (t | A);
          then reconsider l=b as Instruction-Location of SCMPDS by A14,AMI_1:
          def 4;
          l=b;
          hence contradiction by SCMPDS_2:53;
        end;
A21:    IExec(I,t).b=t.b by A6,A10,A11;
        -(-n) > 0 by A3;
        then -n < 0;
        then -n <= -1 by INT_1:21;
        then
A22:    -n+t.b <= -1+t.b by XREAL_1:8;
        t.b-1 <= k by A9,XREAL_1:22;
        then
A23:    -n+t.b <= k by A22,XXREAL_0:2;
A24:    I is_closed_on t by A6,A10,A11;
        then
A25:    I is_closed_on t2 by SCMPDS_6:38;
A26:    not b in dom iFOR by SCMPDS_4:31;
        set m2=LifeSpan t2, t5= Computation( t4,m2), l1=inspos (card I + 1);
A27:    IC t3 =inspos 0 by SCMPDS_6:21;
        set m3=m2 +1;
        set t6= Computation( t3,m3);
        card I + 1 < card I + 3 by XREAL_1:8;
        then
A28:    l1 in dom FOR by Th61;
        set m5=m3+1+1, t8= Computation( t3,m5);
        set t7= Computation( t3,m3+1);
A29:    IExec(I,t).a=t.a by A6,A10,A11;
        set l2=inspos(card I+2);
A30:    inspos 0 in dom pFOR by SCMPDS_4:75;
        card I + 2 < card I + 3 by XREAL_1:8;
        then
A31:    l2 in dom FOR by Th61;
A32:    iFOR c= t3 by FUNCT_4:26;
        FOR c= iFOR by SCMPDS_6:17;
        then
A33:    FOR c= t3 by A32,XBOOLE_1:1;
        Shift(I,1) c= FOR by Lm5;
        then Shift(I,1) c= t3 by A33,XBOOLE_1:1;
        then
A34:    Shift(I,1) c= t4 by AMI_1:81;
        I is_halting_on t by A6,A10,A11;
        then
A35:    t2 is halting by SCMPDS_6:def 3;
        then t2 +* IsI is halting by A13,FUNCT_4:79;
        then
A36:    I is_halting_on t2 by SCMPDS_6:def 3;
        not a in dom iFOR by SCMPDS_4:31;
        then t3.DataLoc(t3.a,i)= t3.b by A11,FUNCT_4:12
          .= t.b by A26,FUNCT_4:12;
        then
A37:    IC t4 = Next IC t3 by A12,A17,SCMPDS_2:68
          .= inspos(0+1) by A27;
        then
A38:    IC t5=l1 by A4,A13,A36,A25,A19,A34,Th36;
A39:    t6=t5 by AMI_1:51;
        then
A40:    CurInstr t6=t5.l1 by A4,A13,A36,A25,A37,A19,A34,Th36
          .=t4.l1 by AMI_1:54
          .=t3.l1 by AMI_1:54
          .=FOR.l1 by A28,A33,GRFUNC_1:8
          .=i2 by Th62;
A41:    t7 = Following t6 by AMI_1:14
          .= Exec(i2,t6) by A40;
        then
A42:    IC t7=Next IC t6 by SCMPDS_2:60
          .=inspos(card I+1+1) by A38,A39,NAT_1:39
          .=inspos(card I+(1+1));
        then
A43:    CurInstr t7=t3.l2 by AMI_1:54
          .=FOR.l2 by A33,A31,GRFUNC_1:8
          .=i3 by Th62;
A44:    t8 = Following t7 by AMI_1:14
          .= Exec(i3,t7) by A43;
        then IC t8=ICplusConst(t7,0-(card I+2)) by SCMPDS_2:66
          .=inspos 0 by A42,Th1;
        then
A45:    t8 +* iFOR=t8 by Th37;
A46:    DataPart Computation( t2,m2) = DataPart t5 by A4,A13,A36,A25,A37,
        A19,A34,Th36;
        then
A47:    t5.a= Computation( t2,m2).a by SCMPDS_4:23
          .=(Result t2).a by A35,AMI_1:122
          .=s.a by A11,A29,A15,FUNCT_4:12;
        then DataLoc(t6.a,i)=b by AMI_1:51;
        then t7.a=t6.a by A5,A41,SCMPDS_2:60
          .=s.a by A47,AMI_1:51;
        then
A48:    t8.a=s.a by A44,SCMPDS_2:66;
A49:    now
          let x be Int_position;
          assume
A50:      x in X;
A51:      now
            assume
            x in dom (t | A);
            then reconsider l=x as Instruction-Location of SCMPDS by A14,
            AMI_1:
            def 4;
            l=x;
            hence contradiction by SCMPDS_2:53;
          end;
          t5.x= Computation( t2,m2).x by A46,SCMPDS_4:23
            .=(Result t2).x by A35,AMI_1:122
            .=IExec(I,t).x by A51,FUNCT_4:12
            .=t.x by A6,A10,A11,A50
            .=s.x by A10,A50;
          then t7.x=s.x by A2,A47,A39,A41,A50,SCMPDS_2:60;
          hence t8.x=s.x by A44,SCMPDS_2:66;
        end;
A52:    t5.b= Computation( t2,m2).b by A46,SCMPDS_4:23
          .=(Result t2).b by A35,AMI_1:122
          .=t.b by A21,A20,FUNCT_4:12;
A53:    t8.b=t7.b by A44,SCMPDS_2:66
          .=t.b+ -n by A47,A52,A39,A41,SCMPDS_2:60;
        then
A54:    FOR is_closed_on t8 by A8,A48,A49,A23;
        now
          let k be Element of NAT;
          per cases;
          suppose
            k < m5;
            then k <= m3+1 by INT_1:20;
            then
A55:        k <= m3 or k=m3+1 by NAT_1:8;
            hereby
              per cases by A55,NAT_1:8;
              suppose
A56:            k <= m2;
                hereby
                  per cases;
                  suppose
                    k=0;
                    hence IC Computation( t3,k) in dom pFOR by A30,A27,
                    AMI_1:13;
                  end;
                  suppose
                    k<>0;
                    then consider kn be Nat such that
A57:                k=kn+1 by NAT_1:6;
                    reconsider kn as Element of NAT by ORDINAL1:def 13;
                    reconsider lm = IC Computation( t2,kn) as Element of NAT
                    by ORDINAL1:def 13;
                    kn < k by A57,XREAL_1:31;
                    then kn < m2 by A56,XXREAL_0:2;
                    then IC Computation( t2,kn) + 1 = IC Computation(t4,kn)
                    by A4,A13,A36,A25,A37,A19,A34,Th34;
                    then
A58:                IC Computation( t3,k)=inspos lm +1 by A57,
                    AMI_1:51
                      .=inspos (lm+1);
                    IC Computation( t2,kn) in dom pI by A24,SCMPDS_6:def
                    2;
                    then lm < card pI by SCMPDS_4:1;
                    then lm < card I+1 by SCMPDS_5:7;
                    then
A59:                lm+1 <= card I +1 by INT_1:20;
                    card I + 1 < card I + 4 by XREAL_1:8;
                    then lm+1 < card I +4 by A59,XXREAL_0:2;
                    then lm+1 < card pFOR by Lm4;
                    hence IC Computation( t3,k) in dom pFOR by A58,
                    SCMPDS_4:1;
                  end;
                end;
              end;
              suppose
A60:            k=m3;
                l1 in dom pFOR by A28,SCMPDS_6:18;
                hence
                IC Computation( t3,k) in dom pFOR by A4,A13,A36,A25,A37,
                A19,A34,A39,A60,Th36;
              end;
              suppose
                k=m3+1;
                hence IC Computation( t3,k) in dom pFOR by A42,A31,
                SCMPDS_6:18;
              end;
            end;
          end;
          suppose
            k >= m5;
            then consider nn be Nat such that
A61:        k=m5+nn by NAT_1:10;
            reconsider nn as Element of NAT by ORDINAL1:def 13;
            Computation(t3,k)= Computation( (t8 +* iFOR),nn) by A45,A61
            ,AMI_1:51;
            hence IC Computation( t3,k) in dom pFOR by A54, SCMPDS_6:def 2;
          end;
        end;
        hence FOR is_closed_on t by SCMPDS_6:def 2;
        FOR is_halting_on t8 by A8,A48,A49,A53,A23;
        then t8 is halting by A45,SCMPDS_6:def 3;
        then t3 is halting by AMI_1:93;
        hence FOR is_halting_on t by SCMPDS_6:def 3;
      end;
    end;
    hence thesis;
  end;
  reconsider n=s.b as Element of NAT by A1,INT_1:16;
A62: P[0] by Th63;
  for k being Element of NAT holds P[k] from NAT_1:sch 1(A62,A7);
  then
A63: P[n];
  for x be Int_position st x in X holds s.x=s.x;
  hence thesis by A63;
end;

theorem Th68:
  for s being State of SCMPDS,I being No-StopCode shiftable
Program of SCMPDS, a be Int_position, i be Integer,n be Element of NAT,X be set
  st s.DataLoc(s.a,i) > 0 & not DataLoc(s.a,i) in X & n > 0 & card I > 0 & a <>
DataLoc(s.a,i) & (for t be State of SCMPDS st (for x be Int_position st x in X
holds t.x=s.x) & t.a=s.a holds IExec(I,t).a=t.a & IExec(I,t).DataLoc(s.a,i)=t.
  DataLoc(s.a,i) & I is_closed_on t & I is_halting_on t & for y be Int_position
  st y in X holds IExec(I,t).y=t.y) holds IExec(for-down(a,i,n,I),s) = IExec(
  for-down(a,i,n,I),IExec(I ';' AddTo(a,i,-n),s))
proof
  let s be State of SCMPDS,I be No-StopCode shiftable Program of SCMPDS, a be
  Int_position, i be Integer,n be Element of NAT,X be set;
  set b=DataLoc(s.a,i);
  set FOR=for-down(a,i,n,I), iFOR=Initialized stop FOR, iI= Initialized stop I
  , s1= s +* iFOR, ps= s | A;
  set i1=(a,i)<=0_goto (card I+3), i2=AddTo(a,i,-n), i3=goto -(card I+2);
  assume
A1: s.b > 0;
  set s4 = Computation(s1,1);
A2: IC s1 =inspos 0 by SCMPDS_6:21;
A3: not b in dom iFOR by SCMPDS_4:31;
  set m0=LifeSpan s1;
  set l2=inspos(card I+2);
  set sI= s +* iI, m1=LifeSpan sI+3, J=I ';' AddTo(a,i,-n), sJ=s +*
  Initialized stop J, s2=IExec(J,s) +* iFOR, m2=LifeSpan s2;
  set Es=IExec(J,s), bj=DataLoc(Es.a,i);
A4: iI c= sI by FUNCT_4:26;
A5: dom (s | A) = A by SCMPDS_6:1;
A6: now
    assume
    a in dom (s | A);
    then reconsider l=a as Instruction-Location of SCMPDS by A5,AMI_1:def 4;
    l=a;
    hence contradiction by SCMPDS_2:53;
  end;
A7: now
    assume
    b in dom (s | A);
    then reconsider l=b as Instruction-Location of SCMPDS by A5,AMI_1:def 4;
    l=b;
    hence contradiction by SCMPDS_2:53;
  end;
A8: FOR = i1 ';' (I ';' i2 ';' i3) by Th15;
  set mI=LifeSpan sI, s5= Computation( s4,mI), l1=inspos (card I + 1);
  set m3=mI +1;
  set s6= Computation( s1,m3);
  set s7= Computation( s1,m3+1);
A9: iFOR c= s1 by FUNCT_4:26;
  FOR c= iFOR by SCMPDS_6:17;
  then
A10: FOR c= s1 by A9,XBOOLE_1:1;
  Shift(I,1) c= FOR by Lm5;
  then Shift(I,1) c= s1 by A10,XBOOLE_1:1;
  then
A11: Shift(I,1) c= s4 by AMI_1:81;
  card I + 2 < card I + 3 by XREAL_1:8;
  then
A12: l2 in dom FOR by Th61;
  set m5=m3+1+1, s8= Computation( s1,m5);
A13: dom ps = dom s /\ A by RELAT_1:90
    .= ({IC SCMPDS} \/ D \/ A) /\ A by SCMPDS_4:19
    .= A by XBOOLE_1:21;
  card I + 1 < card I + 3 by XREAL_1:8;
  then
A14: l1 in dom FOR by Th61;
  assume
A15: not b in X;
  assume
A16: n > 0;
  assume
A17: card I > 0;
  assume
A18: a <> b;
  assume
A19: for t be State of SCMPDS st (for x be Int_position st x in X holds t
.x=s.x) & t.a=s.a holds IExec(I,t).a=t.a & IExec(I,t).b=t.b & I is_closed_on t
  & I is_halting_on t & for y be Int_position st y in X holds IExec(I,t).y=t.y;
  then FOR is_halting_on s by A1,A15,A16,A17,A18,Th67;
  then
A20: s1 is halting by SCMPDS_6:def 3;
A21: for x be Int_position st x in X holds s.x=s.x;
  then
A22: IExec(I,s).b=s.b by A19;
A23: IExec(I, s).a=s.a by A19,A21;
A24: b=DataLoc(IExec(I, s).a,i) by A19,A21;
A25: IExec(I,s).a=s.a by A19,A21;
A26: Computation( s1,0+1) = Following Computation( s1,0) by AMI_1:14
    .= Following s1 by AMI_1:13
    .= Exec(i1,s1) by A8,SCMPDS_6:22;
  not a in dom iFOR by SCMPDS_4:31;
  then s1.DataLoc(s1.a,i)=s1.b by FUNCT_4:12
    .= s.b by A3,FUNCT_4:12;
  then
A27: IC s4 = Next IC s1 by A1,A26,SCMPDS_2:68
    .= inspos(0+1) by A2;
A28: DataPart sI = DataPart s1 by SCMPDS_4:24,36;
  now
    let a;
    thus sI.a = s1.a by A28,SCMPDS_4:23
      .= s4.a by A26,SCMPDS_2:68;
  end;
  then
A29: DataPart sI = DataPart s4 by SCMPDS_4:23;
A30: I is_halting_on s by A19,A21;
  then
A31: sI is halting by SCMPDS_6:def 3;
  then sI +* iI is halting by A4,FUNCT_4:79;
  then
A32: I is_halting_on sI by SCMPDS_6:def 3;
A33: I is_closed_on s by A19,A21;
  then
A34: Es.b=Exec(i2, IExec(I, s)).b by A30,Th50
    .=IExec(I, s).b+ -n by A23,SCMPDS_2:60
    .=s.b+ -n by A19,A21;
A35: I is_closed_on sI by A33,SCMPDS_6:38;
  then
A36: IC s5=l1 by A17,A4,A32,A27,A29,A11,Th36;
A37: s6=s5 by AMI_1:51;
  then
A38: CurInstr s6=s5.l1 by A17,A4,A32,A35,A27,A29,A11,Th36
    .=s4.l1 by AMI_1:54
    .=s1.l1 by AMI_1:54
    .=FOR.l1 by A14,A10,GRFUNC_1:8
    .=i2 by Th62;
A39: DataPart Computation(sI,mI) = DataPart s5 by A17,A4,A32,A35,A27,A29,A11
  ,Th36;
  then
A40: s5.a= Computation( sI,mI).a by SCMPDS_4:23
    .=(Result sI).a by A31,AMI_1:122
    .=s.a by A25,A6,FUNCT_4:12;
A41: Es.a=Exec(i2, IExec(I, s)).a by A33,A30,Th50
    .=s.a by A18,A23,SCMPDS_2:60;
  now
    per cases;
    suppose
      Es.bj <= 0;
      hence FOR is_halting_on Es by Th63;
    end;
    suppose
A42:  Es.bj > 0;
      now
        let t be State of SCMPDS;
        assume that
A43:    for x be Int_position st x in X holds t.x=Es.x and
A44:    t.a=Es.a;
A45:    now
          let x be Int_position;
          assume
A46:      x in X;
          hence t.x=Es.x by A43
            .=Exec(i2, IExec(I, s)).x by A33,A30,Th50
            .=IExec(I, s).x by A15,A23,A46,SCMPDS_2:60
            .=s.x by A19,A21,A46;
        end;
        hence IExec(I,t).a=t.a by A19,A41,A44;
        thus IExec(I,t).bj= t.bj by A19,A41,A44,A45;
        thus I is_closed_on t & I is_halting_on t & for y be Int_position st y
        in X holds IExec(I,t).y=t.y by A19,A41,A44,A45;
      end;
      hence FOR is_halting_on Es by A15,A16,A17,A18,A41,A42,Th67;
    end;
  end;
  then
A47: s2 is halting by SCMPDS_6:def 3;
A48: s7 = Following s6 by AMI_1:14
    .= Exec(i2,s6) by A38;
  then
A49: IC s7=Next IC s6 by SCMPDS_2:60
    .=inspos(card I+1+1) by A36,A37,NAT_1:39
    .=inspos(card I+(1+1));
  then
A50: CurInstr s7=s1.l2 by AMI_1:54
    .=FOR.l2 by A10,A12,GRFUNC_1:8
    .=i3 by Th62;
A51: s8 = Following s7 by AMI_1:14
    .= Exec(i3,s7) by A50;
  then IC s8=ICplusConst(s7,0-(card I+2)) by SCMPDS_2:66
    .=inspos 0 by A49,Th1;
  then
A52: IC s2 =IC Computation(s1,m1) by SCMPDS_6:21;
A53: s5.b= Computation( sI,mI).b by A39,SCMPDS_4:23
    .=(Result sI).b by A31,AMI_1:122
    .=s.b by A22,A7,FUNCT_4:12;
A54: s8.b=s7.b by A51,SCMPDS_2:66
    .=s.b+ -n by A40,A53,A37,A48,SCMPDS_2:60;
  now
    let x be Int_position;
A55: not x in dom iFOR by SCMPDS_4:31;
    then
A56: s2.x=IExec(J,s).x by FUNCT_4:12;
    per cases;
    suppose
      x=b;
      hence s8.x=s2.x by A54,A34,A55,FUNCT_4:12;
    end;
    suppose
A57:  x<>b;
A58:  now
        assume
        x in dom (s | A);
        then reconsider l=x as Instruction-Location of SCMPDS by A5,AMI_1:def
        4;
        l=x;
        hence contradiction by SCMPDS_2:53;
      end;
A59:  s5.x= Computation( sI,mI).x by A39,SCMPDS_4:23
        .=(Result sI).x by A31,AMI_1:122
        .=IExec(I,s).x by A58,FUNCT_4:12;
A60:  s7.x=s5.x by A40,A37,A48,A57,SCMPDS_2:60;
      Es.x=Exec(i2, IExec(I, s)).x by A33,A30,Th50
        .=IExec(I, s).x by A24,A57,SCMPDS_2:60;
      hence s8.x=s2.x by A51,A56,A59,A60,SCMPDS_2:66;
    end;
  end;
  then
A61: DataPart s8 = DataPart s2 by SCMPDS_4:23;
  s2 | A=(Result sJ +* ps)|A +* iFOR | A by FUNCT_4:75
    .= ps +* iFOR | A by A13,FUNCT_4:24
    .= s1 | A by FUNCT_4:75
    .= Computation(s1,m1) | A by Th6;
  then
A62: Computation(s1,m1)=s2 by A61,A52,Th7;
  then CurInstr Computation(s1,m1)=i1 by A8,SCMPDS_6:22;
  then m0 > m1 by A20,SCMPDS_6:2,30;
  then consider nn be Nat such that
A63: m0=m1+nn by NAT_1:10;
  reconsider nn as Element of NAT by ORDINAL1:def 13;
  Computation(s1,m1+m2) = Computation(s2,m2) by A62,AMI_1:51;
  then CurInstr Computation(s1,m1+m2) = halt SCMPDS by A47,AMI_1:def 46;
  then m1 + m2 >= m0 by A20,AMI_1:def 46;
  then
A64: m2 >= nn by A63,XREAL_1:8;
A65: Computation(s1,m0) = Computation(s2,nn) by A62,A63,AMI_1:51;
  then CurInstr Computation(s2,nn) =halt SCMPDS by A20,AMI_1:def 46;
  then nn >= m2 by A47,AMI_1:def 46;
  then nn=m2 by A64,XXREAL_0:1;
  then
A66: Result s1 = Computation(s2,m2) by A20,A65,AMI_1:122;
  IExec(J,s) | A= ps by A13,FUNCT_4:24;
  hence thesis by A47,A66,AMI_1:122;
end;

registration
  let I be shiftable Program of SCMPDS, a be Int_position,i be Integer,n be
  Element of NAT;
  cluster for-down(a,i,n,I) -> shiftable;
  correctness
  proof
    set FOR=for-down(a,i,n,I), i1= (a,i)<=0_goto (card I +3), i2= AddTo(a,i,-n
    );
    reconsider PF= Load i1 ';' I ';' i2 as shiftable Program of SCMPDS;
    card PF=card (i1 ';' I) + 1 by SCMP_GCD:8
      .=card I + 1+1 by SCMPDS_6:15
      .=card I +(1+1);
    then card PF+ -(card I+2) =0;
    hence thesis by SCMPDS_4:78;
  end;
end;

registration
  let I be No-StopCode Program of SCMPDS, a be Int_position,i be Integer,n be
  Element of NAT;
  cluster for-down(a,i,n,I) -> No-StopCode;
  correctness
  proof
    -(card I+2) <> 0;
    then reconsider
    i3=goto -(card I+2) as No-StopCode Instruction of SCMPDS by
    SCMPDS_5:25;
    for-down(a,i,n,I) = (a,i)<=0_goto (card I +3) ';' I ';' AddTo(a,i,-n)
    ';' i3;
    hence thesis;
  end;
end;

begin :: Two Examples for Summing

:: n=Sum 1+1+...+1

definition
  let n be Element of NAT;
  func sum(n) -> Program of SCMPDS equals
  (GBP:=0) ';' ((GBP,2):=n) ';' ((GBP,
  3):=0) ';' for-down(GBP,2,1, Load AddTo(GBP,3,1));
  coherence;
end;

theorem Th69:
  for s being State of SCMPDS st s.GBP=0 holds for-down(GBP,2,1,
  Load AddTo(GBP,3,1)) is_closed_on s & for-down(GBP,2,1, Load AddTo(GBP,3,1))
  is_halting_on s
proof
  set I= Load AddTo(GBP,3,1);
  let s be State of SCMPDS;
  assume
A1: s.GBP=0;
  per cases;
  suppose
    s.DataLoc(s.GBP,2) <= 0;
    hence thesis by Th63;
  end;
  suppose
A2: s.DataLoc(s.GBP,2) > 0;
A3: now
      set cv=DataLoc(s.GBP,2);
      let t be State of SCMPDS;
      assume that
      for x be Int_position st x in {GBP} holds t.x=s.x and
A4:   t.GBP=s.GBP;
      set t0=Initialized t;
      t0.GBP=0 by A1,A4,SCMPDS_5:40;
      then
A5:   DataLoc(t0.GBP,3)=intpos(0+3) by SCMP_GCD:5;
      thus
A6:   IExec(I,t).GBP=Exec(AddTo(GBP,3,1),t0).GBP by SCMPDS_5:45
        .=t0.GBP by A5,AMI_3:52,SCMPDS_2:60
        .=t.GBP by SCMPDS_5:40;
A7:   cv=intpos(0+2) by A1,SCMP_GCD:5;
      thus IExec(I,t).cv=Exec(AddTo(GBP,3,1),t0).cv by SCMPDS_5:45
        .=t0.cv by A5,A7,AMI_3:52,SCMPDS_2:60
        .=t.cv by SCMPDS_5:40;
      thus I is_closed_on t & I is_halting_on t by SCMPDS_6:34,35;
      hereby
        let y be Int_position;
        assume
        y in {GBP};
        then y=GBP by TARSKI:def 1;
        hence IExec(I,t).y=t.y by A6;
      end;
    end;
    DataLoc(s.GBP,2)=intpos(0+2) by A1,SCMP_GCD:5;
    then DataLoc(s.GBP,2) <> GBP by AMI_3:52;
    then
A8: not DataLoc(s.GBP,2) in {GBP} by TARSKI:def 1;
    hence thesis by A1,A2,A3,Th67;
  end;
end;

theorem Th70:
  for s being State of SCMPDS,n be Element of NAT st s.GBP=0 & s.
intpos 2=n & s.intpos 3=0 holds IExec(for-down(GBP,2,1, Load AddTo(GBP,3,1)),s)
  .intpos 3=n
proof
  set i= AddTo(GBP,3,1), I= Load i, FD= for-down(GBP,2,1, I), a=intpos 3;
  let s be State of SCMPDS,n be Element of NAT;
  assume that
A1: s.GBP=0 and
A2: s.intpos 2=n and
A3: s.a=0;
  defpred P[Element of NAT] means for s be State of SCMPDS st s.intpos 2=$1 &
  s.GBP=0 holds IExec(FD,s).a=$1+s.a;
A4: now
    let k be Element of NAT;
    assume
A5: P[k];
    now
A6:   card I= 1 by SCMPDS_5:6;
      let s be State of SCMPDS;
      assume that
A7:   s.intpos 2=k+1 and
A8:   s.GBP=0;
      GBP <> DataLoc(s.GBP,2) by A7,A8,SCMP_GCD:5;
      then
A9:   not DataLoc(s.GBP,2) in {GBP} by TARSKI:def 1;
A10:  now
        set cv=DataLoc(s.GBP,2);
        let t be State of SCMPDS;
        assume that
        for x be Int_position st x in {GBP} holds t.x=s.x and
A11:    t.GBP=s.GBP;
        set t0=Initialized t;
        t0.GBP=0 by A8,A11,SCMPDS_5:40;
        then
A12:    DataLoc(t0.GBP,3)=intpos(0+3) by SCMP_GCD:5;
        then
A13:    cv <> DataLoc(t0.GBP,3) by A7,A8,AMI_3:52,SCMP_GCD:5;
        thus
A14:    IExec(I,t).GBP=Exec(AddTo(GBP,3,1),t0).GBP by SCMPDS_5:45
          .=t0.GBP by A12,AMI_3:52,SCMPDS_2:60
          .=t.GBP by SCMPDS_5:40;
        thus IExec(I,t).cv=Exec(AddTo(GBP,3,1),t0).cv by SCMPDS_5:45
          .=t0.cv by A13,SCMPDS_2:60
          .=t.cv by SCMPDS_5:40;
        thus I is_closed_on t & I is_halting_on t by SCMPDS_6:34,35;
        hereby
          let y be Int_position;
          assume
          y in {GBP};
          then y=GBP by TARSKI:def 1;
          hence IExec(I,t).y=t.y by A14;
        end;
      end;
      set j=AddTo(GBP,2,-1), s0=Initialized s, s1=IExec(I, s), s2=IExec(I ';'j
      ,s), l2=intpos 2;
A15:  s0.GBP=0 by A8,SCMPDS_5:40;
      then
A16:  DataLoc(s0.GBP,3)=intpos(0+3) by SCMP_GCD:5;
A17:  s1.GBP=Exec(i, s0).GBP by SCMPDS_5:45
        .=0 by A15,A16,AMI_3:52,SCMPDS_2:60;
      then
A18:  DataLoc(s1.GBP,2)=intpos(0+2) by SCMP_GCD:5;
A19:  s2.l2=Exec(j, s1).l2 by SCMPDS_5:46
        .=s1.l2+ -1 by A18,SCMPDS_2:60
        .=Exec(i, s0).l2+-1 by SCMPDS_5:45
        .=s0.l2+ -1 by A16,AMI_3:52,SCMPDS_2:60
        .=k+1+-1 by A7,SCMPDS_5:40
        .=k;
A20:  s2.a=Exec(j, s1).a by SCMPDS_5:46
        .=s1.a by A18,AMI_3:52,SCMPDS_2:60
        .=Exec(i, s0).a by SCMPDS_5:45
        .=s0.a+1 by A16,SCMPDS_2:60
        .=s.a+1 by SCMPDS_5:40;
A21:  s2.GBP=Exec(j, s1).GBP by SCMPDS_5:46
        .=0 by A17,A18,AMI_3:52,SCMPDS_2:60;
      DataLoc(s.GBP,2)=intpos(0+2) by A8,SCMP_GCD:5;
      hence IExec(FD,s).a =IExec(FD,s2).a by A7,A8,A9,A10,Th68
        .=k+s2.a by A5,A19,A21
        .=k+1+s.a by A20;
    end;
    hence P[k+1];
  end;
A22: P[0]
  proof
    let s be State of SCMPDS;
    assume that
A23: s.intpos 2=0 and
A24: s.GBP=0;
    DataLoc(s.GBP,2)=intpos(0+2) by A24,SCMP_GCD:5;
    hence thesis by A23,Th66;
  end;
  for k be Element of NAT holds P[k] from NAT_1:sch 1(A22,A4);
  hence IExec(FD,s).a=n+0 by A1,A2,A3
    .=n;
end;

theorem
  for s being State of SCMPDS,n be Element of NAT holds IExec(sum(n),s).
  intpos 3 =n
proof
  let s be State of SCMPDS,n be Element of NAT;
  set i1= GBP:=0, i2= (GBP,2):=n, i3= (GBP,3):=0, i4= AddTo(GBP,3,1), FD=
  for-down(GBP,2,1, Load i4), a = intpos 3, I2=i1 ';' i2, s1=IExec(I2, s), s2=
  Exec(i1, Initialized s), I3=I2 ';' i3, s3=IExec(I3,s);
A1: I3 is_closed_on s by SCMPDS_6:34;
A2: I3 is_halting_on s by SCMPDS_6:35;
A3: s2.GBP=0 by SCMPDS_2:57;
  then
A4: DataLoc(s2.GBP,2)=intpos(0+2) by SCMP_GCD:5;
A5: s1.GBP=Exec(i2, s2).GBP by SCMPDS_5:47
    .=0 by A3,A4,AMI_3:52,SCMPDS_2:58;
  then
A6: DataLoc(s1.GBP,3)=intpos(0+3) by SCMP_GCD:5;
A7: s3.GBP=Exec(i3,s1).GBP by SCMPDS_5:46
    .=0 by A5,A6,AMI_3:52,SCMPDS_2:58;
  then
A8: FD is_halting_on s3 by Th69;
A9: s3.intpos 2=Exec(i3,s1).intpos 2 by SCMPDS_5:46
    .=s1.intpos 2 by A6,AMI_3:52,SCMPDS_2:58
    .=Exec(i2, s2).intpos 2 by SCMPDS_5:47
    .=n by A4,SCMPDS_2:58;
A10: s3.a=Exec(i3,s1).a by SCMPDS_5:46
    .=0 by A6,SCMPDS_2:58;
  FD is_closed_on s3 by A7,Th69;
  hence IExec(sum(n),s).a = IExec(FD,s3).a by A1,A2,A8,Th49
    .= n by A10,A7,A9,Th70;
end;

:: sum=Sum x1+x2+...+x2

definition
  let sp,control,result,pp,pData be Element of NAT;
  func sum(sp,control,result,pp,pData) -> Program of SCMPDS equals
  ((intpos sp
  ,result):=0) ';' (intpos pp:=pData) ';' for-down(intpos sp,control,1, AddTo(
  intpos sp,result,intpos pData,0) ';' AddTo(intpos pp,0,1));
  coherence;
end;

theorem Th72:
  for s being State of SCMPDS,sp,cv,result,pp,pD be Element of NAT
st s.intpos sp > sp & cv < result & s.intpos pp=pD & s.intpos sp+result < pp &
pp <pD & pD < s.intpos pD holds for-down(intpos sp,cv,1, AddTo(intpos sp,result
,intpos pD,0) ';' AddTo(intpos pp,0,1)) is_closed_on s & for-down(intpos sp,cv,
1, AddTo(intpos sp,result,intpos pD,0) ';' AddTo(intpos pp,0,1)) is_halting_on
  s
proof
  let s be State of SCMPDS, sp,cv,fr,pp,pD be Element of NAT;
  set BP=intpos sp, PD=intpos pD, PP=intpos pp;
  assume that
A1: s.BP > sp and
A2: cv < fr and
A3: s.PP=pD and
A4: s.BP+fr <pp and
A5: pp < pD and
A6: pD < s.PD;
  set i2= AddTo(BP,fr,PD,0), i3= AddTo(PP,0,1), I= i2 ';' i3;
  per cases;
  suppose
    s.DataLoc(s.BP,cv) <= 0;
    hence thesis by Th63;
  end;
  suppose
A7: s.DataLoc(s.BP,cv) > 0;
    reconsider n=s.BP as Element of NAT by A1,INT_1:16;
A8: card I= 2 by SCMP_GCD:9;
    n+cv <> sp by A1,NAT_1:11;
    then abs(n+cv) <> sp by ABSVALUE:def 1;
    then
A9: DataLoc(s.BP,cv) <> BP by ZFMISC_1:33;
A10: n+fr > n+cv by A2,XREAL_1:8;
A11: now
      set Dv=DataLoc(s.BP,cv);
      let t be State of SCMPDS;
      assume that
A12:  for x be Int_position st x in {BP,PP} holds t.x=s.x and
A13:  t.BP=s.BP;
      set t0=Initialized t, t1=Exec(i2, t0);
A14:  DataLoc(t0.BP,fr)=DataLoc(n,fr) by A13,SCMPDS_5:40
        .=intpos(n+fr) by SCMP_GCD:5;
      then DataLoc(t0.BP,fr) <> PP by A4,ZFMISC_1:33;
      then
A15:  t1.PP=t0.PP by SCMPDS_2:61
        .=t.PP by SCMPDS_5:40;
      n+fr <> sp by A1,NAT_1:11;
      then DataLoc(t0.BP,fr) <> BP by A14,ZFMISC_1:33;
      then
A16:  t1.BP=t0.BP by SCMPDS_2:61
        .=t.BP by SCMPDS_5:40;
      PP in {BP,PP} by TARSKI:def 2;
      then t1.PP=pD by A3,A12,A15;
      then
A17:  DataLoc(t1.PP,0)=intpos (pD+0) by SCMP_GCD:5;
      then
A18:  abs(t1.PP+0) = pD by ZFMISC_1:33;
      n <= n+fr by NAT_1:11;
      then sp < n+fr by A1,XXREAL_0:2;
      then abs(t1.PP+0) <> sp by A4,A5,A18,XXREAL_0:2;
      then
A19:  DataLoc(t1.PP,0) <> BP by ZFMISC_1:33;
      Dv=intpos(n+cv) by SCMP_GCD:5;
      then
A20:  abs(s.BP+cv) = n+cv by ZFMISC_1:33;
      then abs(t1.PP+0) <> abs(s.BP+cv) by A4,A5,A10,A18,XXREAL_0:2;
      then
A21:  DataLoc(t1.PP,0) <> Dv by ZFMISC_1:33;
      abs(t0.BP+fr) = n+fr by A14,ZFMISC_1:33;
      then abs(t0.BP+fr) <> abs(s.BP+cv) by A2,A20;
      then
A22:  DataLoc(t0.BP,fr) <> Dv by ZFMISC_1:33;
      thus
A23:  IExec(I,t).BP=Exec(i3, t1).BP by SCMPDS_5:47
        .=t.BP by A16,A19,SCMPDS_2:60;
      thus IExec(I,t).Dv=Exec(i3, t1).Dv by SCMPDS_5:47
        .=t1.Dv by A21,SCMPDS_2:60
        .=t0.Dv by A22,SCMPDS_2:61
        .=t.Dv by SCMPDS_5:40;
      thus I is_closed_on t & I is_halting_on t by SCMPDS_6:34,35;
A24:  IExec(I,t).PP=Exec(i3, t1).PP by SCMPDS_5:47
        .=t.PP by A3,A6,A15,A17,SCMPDS_2:60;
      hereby
        let y be Int_position;
        assume
A25:    y in {BP,PP};
        per cases by A25,TARSKI:def 2;
        suppose
          y=BP;
          hence IExec(I,t).y=t.y by A23;
        end;
        suppose
          y=PP;
          hence IExec(I,t).y=t.y by A24;
        end;
      end;
    end;
    n+cv <> pp by A2,A4,XREAL_1:8;
    then abs(n+cv) <> pp by ABSVALUE:def 1;
    then DataLoc(s.BP,cv) <> PP by ZFMISC_1:33;
    then not DataLoc(s.BP,cv) in {BP,PP} by A9,TARSKI:def 2;
    hence thesis by A7,A9,A8,A11,Th67;
  end;
end;

theorem Th73:
  for s being State of SCMPDS,sp,cv,result,pp,pD be Element of NAT
, f be FinSequence of NAT st s.intpos sp > sp & cv < result & s.intpos pp=pD &
  s.intpos sp+result < pp & pp <pD & pD < s.intpos pD & s.DataLoc(s.intpos sp,
result)=0 & len f = s.DataLoc(s.intpos sp,cv) & for k be Element of NAT st k <
len f holds f.(k+1)=s.DataLoc(s.intpos pD,k) holds IExec(for-down(intpos sp,cv,
1, AddTo(intpos sp,result,intpos pD,0) ';' AddTo(intpos pp,0,1)),s).DataLoc(s.
  intpos sp,result)=Sum f
proof
  let s be State of SCMPDS, sp,cv,fr,pp,pD be Element of NAT, f be FinSequence
  of NAT;
  set BP=intpos sp, PD=intpos pD, PP=intpos pp;
  assume that
A1: s.BP > sp and
A2: cv < fr and
A3: s.PP=pD and
A4: s.BP+fr <pp and
A5: pp < pD and
A6: pD < s.PD and
A7: s.DataLoc(s.BP,fr)=0 and
A8: len f = s.DataLoc(s.BP,cv) and
A9: for k be Element of NAT st k < len f holds f.(k+1)=s.DataLoc(s.PD,k);
  reconsider n=s.BP as Element of NAT by A1,INT_1:16;
A10: n+fr < pD by A4,A5,XXREAL_0:2;
  set i2= AddTo(BP,fr,PD,0), i3= AddTo(PP,0,1), I= i2 ';' i3, FD= for-down(BP,
  cv,1,I), a=DataLoc(s.BP,fr);
  defpred P[Element of NAT] means for t be State of SCMPDS,f be FinSequence of
NAT st t.BP=s.BP & t.PP=pD & pD < t.PD & len f = t.DataLoc(t.BP,cv) & len f=$1
  & for k be Element of NAT st k < len f holds f.(k+1)=t.DataLoc(t.PD,k) holds
  IExec(FD,t).a=Sum f+t.a;
  n <= n+fr by NAT_1:11;
  then
A11: sp < n+fr by A1,XXREAL_0:2;
A12: n+fr > n+cv by A2,XREAL_1:8;
  then n+cv < pp by A4,XXREAL_0:2;
  then
A13: n+cv < pD by A5,XXREAL_0:2;
A14: now
    let k be Element of NAT;
    assume
A15: P[k];
    now
      let t be State of SCMPDS,f be FinSequence of NAT;
      assume that
A16:  t.BP=s.BP and
A17:  t.PP=pD and
A18:  pD < t.PD and
A19:  len f = t.DataLoc(t.BP,cv) and
A20:  len f=k+1 and
A21:  for i be Element of NAT st i < len f holds f.(i+1)=t.DataLoc(t.
      PD,i );
A22:  f is FinSequence of REAL by FINSEQ_2:27;
A23:  now
        set Dv=DataLoc(t.BP,cv);
        let u be State of SCMPDS;
        assume that
A24:    for x be Int_position st x in {BP,PP} holds u.x=t.x and
A25:    u.BP=t.BP;
        set t0=Initialized u, t1=Exec(i2, t0);
A26:    DataLoc(t0.BP,fr)=DataLoc(n,fr) by A16,A25,SCMPDS_5:40
          .=intpos(n+fr) by SCMP_GCD:5;
        then
A27:    abs(t0.BP+fr) = n+fr by ZFMISC_1:33;
        then
A28:    t1.PP=t0.PP by A3,A5,A7,A26,SCMPDS_2:61
          .=u.PP by SCMPDS_5:40;
        PP in {BP,PP} by TARSKI:def 2;
        then
A29:    t1.PP=pD by A17,A24,A28;
        then t1.PP+0 <> sp by A4,A5,A11,XXREAL_0:2;
        then abs(t1.PP+0) <> sp by A29,ABSVALUE:def 1;
        then
A30:    DataLoc(t1.PP,0) <> BP by ZFMISC_1:33;
A31:    t1.BP=t0.BP by A1,A7,A26,A27,SCMPDS_2:61
          .=u.BP by SCMPDS_5:40;
        thus
A32:    IExec(I,u).BP=Exec(i3, t1).BP by SCMPDS_5:47
          .=u.BP by A31,A30,SCMPDS_2:60;
        Dv=intpos(n+cv) by A16,SCMP_GCD:5;
        then
A33:    abs(t.BP+cv) = n+cv by ZFMISC_1:33;
        then abs(t0.BP+fr) <> abs(t.BP+cv) by A2,A27;
        then
A34:    DataLoc(t0.BP,fr) <> Dv by ZFMISC_1:33;
A35:    DataLoc(t1.PP,0)=intpos (pD+0) by A29,SCMP_GCD:5;
        then abs(t1.PP+0)=pD+0 by ZFMISC_1:33;
        then abs(t1.PP+0) <> abs(t.BP+cv) by A4,A5,A12,A33,XXREAL_0:2;
        then
A36:    DataLoc(t1.PP,0) <> Dv by ZFMISC_1:33;
        thus IExec(I,u).Dv=Exec(i3, t1).Dv by SCMPDS_5:47
          .=t1.Dv by A36,SCMPDS_2:60
          .=t0.Dv by A34,SCMPDS_2:61
          .=u.Dv by SCMPDS_5:40;
        thus I is_closed_on u & I is_halting_on u by SCMPDS_6:34,35;
A37:    IExec(I,u).PP=Exec(i3, t1).PP by SCMPDS_5:47
          .=u.PP by A3,A6,A28,A35,SCMPDS_2:60;
        hereby
          let y be Int_position;
          assume
A38:      y in {BP,PP};
          per cases by A38,TARSKI:def 2;
          suppose
            y=BP;
            hence IExec(I,u).y=u.y by A32;
          end;
          suppose
            y=PP;
            hence IExec(I,u).y=u.y by A37;
          end;
        end;
      end;
A39:  a=intpos(n+fr) by SCMP_GCD:5;
A40:  card I= 2 by SCMP_GCD:9;
      set t0=Initialized t, t1=Exec(i2, t0);
      set j=AddTo(BP,cv,-1), s2=IExec(I ';'j,t), g=Del(f,1);
      set It=IExec(I,t);
A41:  DataLoc(t0.BP,fr)=DataLoc(n,fr) by A16,SCMPDS_5:40
        .=intpos(n+fr) by SCMP_GCD:5;
      then
A42:  abs(t0.BP+fr) = n+fr by ZFMISC_1:33;
      then
A43:  t1.BP = t0.BP by A1,A7,A41,SCMPDS_2:61
        .=t.BP by SCMPDS_5:40;
      t1.PP=t0.PP by A3,A5,A7,A41,A42,SCMPDS_2:61
        .=t.PP by SCMPDS_5:40;
      then
A44:  DataLoc(t1.PP,0)=intpos (pD+0) by A17,SCMP_GCD:5;
      then
A45:  abs(t1.PP+0)=pD+0 by ZFMISC_1:33;
      then abs(t1.PP+0) <> sp by A4,A5,A11,XXREAL_0:2;
      then
A46:  DataLoc(t1.PP,0) <> BP by ZFMISC_1:33;
A47:  It.BP=Exec(i3, t1).BP by SCMPDS_5:47
        .=t.BP by A43,A46,SCMPDS_2:60;
      then
A48:  DataLoc(It.BP,cv)=intpos(n+cv) by A16,SCMP_GCD:5;
      then
A49:  abs(It.BP+cv)=n+cv by ZFMISC_1:33;
      then pD <> abs(It.BP+cv) by A4,A5,A12,XXREAL_0:2;
      then
A50:  PD <> DataLoc(It.BP,cv) by ZFMISC_1:33;
A51:  f.(0+1)=t.DataLoc(t.PD,0) by A20,A21
        .=t0.DataLoc(t.PD,0) by SCMPDS_5:40
        .=t0.DataLoc(t0.PD,0) by SCMPDS_5:40;
      n+fr <> abs(It.BP+cv) by A2,A49;
      then
A52:  a <> DataLoc(It.BP,cv) by A39,ZFMISC_1:33;
A53:  It.a=Exec(i3, t1).a by SCMPDS_5:47
        .=t1.a by A6,A7,A44,SCMPDS_2:60
        .=t0.a + f.1 by A41,A42,A51,SCMPDS_2:61
        .=t.a + f.1 by SCMPDS_5:40;
A54:  s2.a=Exec(j, It).a by SCMPDS_5:46
        .=f.1+t.a by A52,A53,SCMPDS_2:60;
      n+cv <> sp by A1,NAT_1:11;
      then abs(n+cv) <> sp by ABSVALUE:def 1;
      then
A55:  DataLoc(t.BP,cv) <> BP by A16,ZFMISC_1:33;
A56:  s2.PD=Exec(j, It).PD by SCMPDS_5:46
        .=It.PD by A50,SCMPDS_2:60
        .=Exec(i3, t1).PD by SCMPDS_5:47
        .=t1.PD+1 by A44,SCMPDS_2:60
        .=t0.PD+1 by A6,A7,A41,A42,SCMPDS_2:61
        .=t.PD+1 by SCMPDS_5:40;
      then t.PD < s2.PD by XREAL_1:31;
      then
A57:  pD < s2.PD by A18,XXREAL_0:2;
      1 <= k+1 by NAT_1:11;
      then 1 in Seg (k+1) by FINSEQ_1:3;
      then
A58:  1 in dom f by A20,FINSEQ_1:def 3;
      then
A59:  len g +1=len f by WSIERP_1:def 1;
A60:  now
        reconsider m=t.PD as Element of NAT by A18,INT_1:16;
        let i be Element of NAT;
        set SD=DataLoc(s2.PD,i);
        assume
        i < len g;
        then
A61:    i+1 < len g+1 by XREAL_1:8;
        SD=intpos(m+1+i) by A56,SCMP_GCD:5
          .=intpos(m+(1+i));
        then
A62:    abs(s2.PD+i) = m+(1+i) by ZFMISC_1:33;
        then abs(t1.PP+0) <> abs(s2.PD+i) by A18,A45,NAT_1:11;
        then
A63:    DataLoc(t1.PP,0) <> SD by ZFMISC_1:33;
        m <= m+(1+i) by NAT_1:11;
        then abs(t0.BP+fr)<> abs(s2.PD+i)by A10,A18,A42,A62,XXREAL_0:2;
        then
A64:    DataLoc(t0.BP,fr)<> SD by ZFMISC_1:33;
        n+cv < m by A13,A18,XXREAL_0:2;
        then abs(s2.PD+i) <> abs(It.BP+cv) by A49,A62,NAT_1:11;
        then
A65:    SD <> DataLoc(It.BP,cv) by ZFMISC_1:33;
A66:    s2.SD=Exec(j, It).SD by SCMPDS_5:46
          .=It.SD by A65,SCMPDS_2:60
          .=Exec(i3, t1).SD by SCMPDS_5:47
          .=t1.SD by A63,SCMPDS_2:60
          .=t0.SD by A64,SCMPDS_2:61
          .=t.SD by SCMPDS_5:40;
        0+1 <= i+1 by XREAL_1:8;
        hence g.(i+1)=f.(i+1+1) by A58,WSIERP_1:def 1
          .=t.DataLoc(t.PD,i+1) by A21,A59,A61
          .=s2.SD by A62,A66;
      end;
      abs(t0.BP+fr) <> n+cv by A2,A42;
      then
A67:  DataLoc(t0.BP,fr)<> intpos(n+cv) by ZFMISC_1:33;
      abs(t1.PP+0) <> n+cv by A4,A5,A12,A45,XXREAL_0:2;
      then
A68:  DataLoc(t1.PP,0) <> intpos(n+cv) by ZFMISC_1:33;
A69:  It.intpos(n+cv)=Exec(i3, t1).intpos(n+cv) by SCMPDS_5:47
        .=t1.intpos(n+cv) by A68,SCMPDS_2:60
        .=t0.intpos(n+cv) by A67,SCMPDS_2:61
        .=t.intpos(n+cv) by SCMPDS_5:40
        .=k+1 by A16,A19,A20,SCMP_GCD:5;
      abs(It.BP+cv) <> sp by A1,A49,NAT_1:11;
      then
A70:  DataLoc(It.BP,cv) <> BP by ZFMISC_1:33;
A71:  s2.BP=Exec(j, It).BP by SCMPDS_5:46
        .=s.BP by A16,A47,A70,SCMPDS_2:60;
      then DataLoc(s2.BP,cv)=intpos(n+cv) by SCMP_GCD:5;
      then
A72:  s2.DataLoc(s2.BP,cv)=Exec(j, It).intpos(n+cv) by SCMPDS_5:46
        .=It.intpos(n+cv)+ -1 by A48,SCMPDS_2:60
        .=len g by A20,A59,A69;
      pp <> abs(It.BP+cv) by A2,A4,A49,XREAL_1:8;
      then
A73:  PP <> DataLoc(It.BP,cv) by ZFMISC_1:33;
A74:  s2.PP=Exec(j, It).PP by SCMPDS_5:46
        .=It.PP by A73,SCMPDS_2:60
        .=Exec(i3, t1).PP by SCMPDS_5:47
        .=t1.PP by A3,A6,A44,SCMPDS_2:60
        .=t0.PP by A3,A5,A7,A41,A42,SCMPDS_2:61
        .=pD by A17,SCMPDS_5:40;
      1 <= len f by A20,NAT_1:11;
      then
A75:  1 in dom f by FINSEQ_3:27;
      n+cv <> pp by A2,A4,XREAL_1:8;
      then abs(n+cv) <> pp by ABSVALUE:def 1;
      then DataLoc(s.BP,cv) <> PP by ZFMISC_1:33;
      then not DataLoc(t.BP,cv) in {BP,PP} by A16,A55,TARSKI:def 2;
      hence IExec(FD,t).a =IExec(FD,s2).a by A19,A20,A55,A40,A23,Th68
        .=Sum g+s2.a by A15,A20,A71,A59,A72,A74,A57,A60
        .=Sum g+f.1+t.a by A54
        .=Sum f+t.a by A75,A22,WSIERP_1:27;
    end;
    hence P[k+1];
  end;
  now
    let t be State of SCMPDS,f be FinSequence of NAT;
    assume that
    t.BP=s.BP and
    t.PP=pD and
    pD < t.PD and
A76: len f = t.DataLoc(t.BP,cv) and
A77: len f=0 and
    for k be Element of NAT st k < len f holds f.(k+1)=t.DataLoc(t.PD,k);
    f = <*>NAT by A77;
    then Sum f=0 by A77,RVSUM_1:102;
    hence IExec(FD,t).a =Sum f + t.a by A76,A77,Th66;
  end;
  then
A78: P[0];
  for k be Element of NAT holds P[k] from NAT_1:sch 1(A78,A14);
  hence IExec(FD,s).a=Sum f+0 by A3,A6,A7,A8,A9
    .=Sum f;
end;

theorem
  for s being State of SCMPDS,sp,cv,result,pp,pD be Element of NAT, f be
FinSequence of NAT st s.intpos sp > sp & cv < result & s.intpos sp+result < pp
  & pp <pD & pD < s.intpos pD & len f = s.DataLoc(s.intpos sp,cv) & for k be
Element of NAT st k < len f holds f.(k+1)=s.DataLoc(s.intpos pD,k) holds IExec(
  sum(sp,cv,result,pp,pD),s).DataLoc(s.intpos sp,result)=Sum f
proof
  let s be State of SCMPDS, sp,cv,fr,pp,pD be Element of NAT, f be FinSequence
  of NAT;
  set BP=intpos sp, PD=intpos pD, PP=intpos pp;
  assume that
A1: s.BP > sp and
A2: cv < fr and
A3: s.BP+fr <pp and
A4: pp < pD and
A5: pD < s.PD and
A6: len f = s.DataLoc(s.BP,cv) and
A7: for k be Element of NAT st k < len f holds f.(k+1)=s.DataLoc(s.PD,k);
  reconsider n=s.BP as Element of NAT by A1,INT_1:16;
A8: PD <> PP by A4,ZFMISC_1:33;
  set i0= (BP,fr):=0, i1= PP:=pD, Hi= i0 ';' i1, i2= AddTo(BP,fr,PD,0), i3=
AddTo(PP,0,1), FD= for-down(BP,cv,1,i2 ';' i3), s2=IExec(Hi,s), s0=Initialized
  s, s1=Exec(i0, s0), a =DataLoc(s.BP,fr), a1=DataLoc(s2.BP,fr);
A9: DataLoc(s0.BP,fr)=DataLoc(n,fr) by SCMPDS_5:40
    .=intpos(n+fr) by SCMP_GCD:5;
  then
A10: abs(s0.BP+fr) = n+fr by ZFMISC_1:33;
  then abs(s0.BP+fr) <> sp by A1,NAT_1:12;
  then
A11: DataLoc(s0.BP,fr) <> BP by ZFMISC_1:33;
A12: DataLoc(s0.BP,fr) <> PD by A3,A4,A9,ZFMISC_1:33;
A13: s2.PD=Exec(i1, s1).PD by SCMPDS_5:47
    .=s1.PD by A8,SCMPDS_2:57
    .=s0.PD by A12,SCMPDS_2:58
    .=s.PD by SCMPDS_5:40;
  n <= n+fr by NAT_1:12;
  then sp <> pp by A1,A3,XXREAL_0:2;
  then
A14: BP <> PP by ZFMISC_1:33;
A15: intpos(n+fr) <> PP by A3,ZFMISC_1:33;
A16: s2.BP=Exec(i1, s1).BP by SCMPDS_5:47
    .=s1.BP by A14,SCMPDS_2:57
    .=s0.BP by A11,SCMPDS_2:58
    .=n by SCMPDS_5:40;
  then
A17: s2.DataLoc(s2.BP,fr)=s2.intpos(n+fr) by SCMP_GCD:5
    .=Exec(i1, s1).intpos(n+fr) by SCMPDS_5:47
    .=s1.intpos(n+fr) by A15,SCMPDS_2:57
    .=0 by A9,SCMPDS_2:58;
A18: n+fr < pD by A3,A4,XXREAL_0:2;
A19: now
    reconsider m=s.PD as Element of NAT by A5,INT_1:16;
    let k be Element of NAT;
    assume
A20: k < len f;
    pp < m by A4,A5,XXREAL_0:2;
    then m+k <> pp by NAT_1:11;
    then
A21: intpos(m+k) <> PP by ZFMISC_1:33;
    m <= m + k by NAT_1:11;
    then abs(s0.BP+fr) <> m+k by A5,A10,A18,XXREAL_0:2;
    then
A22: DataLoc(s0.BP,fr) <> intpos(m+k) by ZFMISC_1:33;
    thus s2.DataLoc(s2.PD,k)=s2.intpos(m+k) by A13,SCMP_GCD:5
      .=Exec(i1, s1).intpos(m+k) by SCMPDS_5:47
      .=s1.intpos(m+k) by A21,SCMPDS_2:57
      .=s0.intpos(m+k) by A22,SCMPDS_2:58
      .=s.intpos(m+k) by SCMPDS_5:40
      .=s.DataLoc(s.PD,k) by SCMP_GCD:5
      .=f.(k+1) by A7,A20;
  end;
  abs(s0.BP+fr) <> n+cv by A2,A10;
  then
A23: DataLoc(s0.BP,fr) <> intpos(n+cv) by ZFMISC_1:33;
  n+cv <> pp by A2,A3,XREAL_1:8;
  then
A24: intpos(n+cv) <> PP by ZFMISC_1:33;
A25: Hi is_halting_on s by SCMPDS_6:35;
A26: Hi is_closed_on s by SCMPDS_6:34;
A27: s2.PP=Exec(i1, s1).PP by SCMPDS_5:47
    .=pD by SCMPDS_2:57;
  then
A28: FD is_halting_on s2 by A1,A2,A3,A4,A5,A16,A13,Th72;
A29: s2.DataLoc(s2.BP,cv)=s2.intpos(n+cv) by A16,SCMP_GCD:5
    .=Exec(i1, s1).intpos(n+cv) by SCMPDS_5:47
    .=s1.intpos(n+cv) by A24,SCMPDS_2:57
    .=s0.intpos(n+cv) by A23,SCMPDS_2:58
    .=s.intpos(n+cv) by SCMPDS_5:40
    .=len f by A6,SCMP_GCD:5;
  FD is_closed_on s2 by A1,A2,A3,A4,A5,A16,A27,A13,Th72;
  hence IExec(sum(sp,cv,fr,pp,pD),s).a = IExec(FD,s2).a1 by A16,A26,A25,
  A28,Th49
    .= Sum f by A1,A2,A3,A4,A5,A16,A27,A13,A17,A29,A19,Th73;
end;

