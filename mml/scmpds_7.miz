:: The Construction and Computation of For-loop Programs for SCMPDS
::  by JingChao Chen and Piotr Rudnicki
::
:: Received December 27, 1999
:: Copyright (c) 1999 Association of Mizar Users

environ

 vocabularies NUMBERS, SUBSET_1, SCMPDS_2, AMI_1, FSM_1, INT_1, AMI_2, ARYTM_1,
      COMPLEX1, ARYTM_3, CARD_1, RELAT_1, FUNCT_4, FUNCOP_1,
      XBOOLE_0, CIRCUIT2, FUNCT_1, NAT_1, TARSKI, TURING_1, VALUED_1, SCMPDS_4,
      AMISTD_2, XXREAL_0, AMI_3, SCMFSA_7, FUNCT_7, UNIALG_2, SCMFSA7B,
      GRAPHSP, MSUALG_1, SCMFSA6B, SCMPDS_5, STRUCT_0, SFMASTR3,
      SEMI_AF1, SCMP_GCD, FINSEQ_1, CARD_3, FINSEQ_3, SCMPDS_7, ORDINAL1,
      PARTFUN1, SCMNORM, SCMFSA6C;
 notations TARSKI, XBOOLE_0, ENUMSET1, SUBSET_1, CARD_1, NUMBERS, XCMPLX_0,
      XXREAL_0, COMPLEX1, RELAT_1, FUNCT_1, PARTFUN1, FUNCT_4, INT_1, NAT_1,
      FUNCOP_1, AFINSQ_1, VALUED_1, STRUCT_0, COMPOS_1, EXTPRO_1, AMI_1, AMI_2,
      FUNCT_7,
      SCMPDS_2, SCMPDS_4, SCMPDS_5, SCMPDS_6, SCMP_GCD, FINSEQ_1, WSIERP_1;
 constructors ENUMSET1, XXREAL_0, REAL_1, INT_2, WSIERP_1, SCM_1, SCMPDS_4,
      SCMPDS_5, SCMPDS_6, SCMP_GCD, SEQ_1, AMI_1, AMI_2;
 registrations SETFAM_1, FUNCT_1, ORDINAL1, RELSET_1, FUNCOP_1, NUMBERS,
      XXREAL_0, XREAL_0, NAT_1, INT_1, SCMPDS_2, SCMPDS_4, SCMPDS_5, XBOOLE_0,
      VALUED_0, FINSEQ_1, CARD_1, VALUED_1, AMI_1, FUNCT_4, COMPOS_1, AFINSQ_1,
      RELAT_1, EXTPRO_1;
 requirements REAL, NUMERALS, SUBSET, BOOLE, ARITHM;
 definitions FUNCOP_1, COMPOS_1, EXTPRO_1, AMI_1, AMI_3, SCMPDS_2, SCMP_GCD,
 SCMPDS_4,
      SCMPDS_5;
 theorems AMI_1, AMI_3, NAT_1, FUNCOP_1, TARSKI, FUNCT_4, FUNCT_1, INT_1,
      SCMPDS_2, FUNCT_7, SCMPDS_3, ABSVALUE, GRFUNC_1, SCMPDS_4, SCMPDS_5,
      SCMPDS_6, ENUMSET1, SCMP_GCD, LATTICE2, WSIERP_1, FINSEQ_1, RVSUM_1,
      RELAT_1, FINSEQ_3, XBOOLE_0, XBOOLE_1, XREAL_1, ORDINAL1, XXREAL_0,
      AMI_2, ZFMISC_1, FINSEQ_2, VALUED_1, PBOOLE, PARTFUN1, AFINSQ_1,
      COMPOS_1, EXTPRO_1;
 schemes NAT_1;

begin :: Preliminaries

reserve x for set,
  m,n for Element of NAT,
  a,b for Int_position,
  i,j,k for
  Instruction of SCMPDS,
  s,s1,s2 for State of SCMPDS,
  k1,k2 for Integer,
  loc,l
  for Element of NAT,
  I,J,K for Program of SCMPDS;
set A = NAT;
set D = SCM-Data-Loc;

theorem Th1: ::SCMPDS_6:23
  for s being State of SCMPDS,m,n being Element of NAT st IC s=
   m holds ICplusConst(s,n-m)= n
proof
  let s be State of SCMPDS,m,n be Element of NAT;
  consider k be Element of NAT such that
A1: k = IC s and
A2: ICplusConst(s,n-m) = abs(k+(n-m)) by SCMPDS_2:def 20;
  assume
  IC s= m;
  then k=m by A1
    .=m;
  hence ICplusConst(s,n-m) =n by A2,ABSVALUE:def 1
    .= n;
end;

canceled 5;

theorem Th7:
  for s1,s2 being State of SCMPDS st IC s1= IC s2 & DataPart s1 =
  DataPart s2 & ProgramPart s1 = ProgramPart s2 holds s1=s2
proof
  let s1,s2 be State of SCMPDS;
  assume that
A1: IC s1= IC s2 and
A2: DataPart s1 = DataPart s2 and
A3: ProgramPart s1 = ProgramPart s2;
A4: dom s2 ={IC SCMPDS} \/ D \/ A by SCMPDS_4:19;
A5: dom s1 ={IC SCMPDS} \/ D \/ A by SCMPDS_4:19;
  then s1|{IC SCMPDS} = s2|{IC SCMPDS} by A1,A4,GRFUNC_1:90;
  then s1|({IC SCMPDS} \/ D) = s2| ({IC SCMPDS} \/ D) by A2,RELAT_1:185
,SCMPDS_2:100;
  then s1|({IC SCMPDS} \/ D \/ A) = s2| ({IC SCMPDS} \/ D \/ A) by A3,
RELAT_1:185;
  hence s1=s2 | dom s2 by A5,A4,RELAT_1:97
    .=s2 by RELAT_1:97;
end;

canceled 7;

theorem Th15:
  i ';' I ';' j ';' k = i ';' (I ';' j ';' k)
proof
  thus i ';' I ';' j ';' k = i ';' (I ';' j) ';' k by SCMPDS_4:51
    .= i ';' (I ';' j ';' k) by SCMPDS_4:51;
end;

theorem Th16:
  Shift(J,card I) c= I ';' J ';' K
proof
  set IJ= I ';' J;
  dom IJ misses dom Shift(K, card IJ) by AFINSQ_1:76;
  then
A1: IJ c= IJ ';' K by FUNCT_4:33;
  Shift(J, card I) c= IJ by FUNCT_4:26;
  hence thesis by A1,XBOOLE_1:1;
end;

theorem Th17:
  I c= stop (I ';' J)
proof
  stop (I ';' J) =I ';' (J ';' Stop SCMPDS) by AFINSQ_1:30;
  hence thesis by AFINSQ_1:78;
end;

theorem Th18:
  loc in dom I implies Shift(stop I,n).(loc+n)=Shift(I,n).(loc+n)
proof
A1: dom I c= dom (stop I) by AFINSQ_1:24;
  reconsider l = loc as Element of NAT;
  assume
A2: loc in dom I;
  hence Shift(I,n).(loc+n)=I.l by VALUED_1:def 12
    .=(stop I).l by A2,AFINSQ_1:def 4
    .=Shift(stop I,n).(loc+n) by A2,A1,VALUED_1:def 12;
end;

theorem Th19:
  card I > 0 implies Shift(stop I,n). n=Shift(I,n). n
proof
  assume
  card I > 0;
  then
A1:  0 in dom I by AFINSQ_1:70;
  thus Shift(stop I,n). n=Shift(stop I,n).(0 qua Nat+n)
    .=Shift(stop I,n).( (0 qua Nat) +n)
    .=Shift(I,n).( 0 qua Nat +n) by A1,Th18
    .=Shift(I,n). (0 qua Nat+n)
    .=Shift(I,n). n;
end;

theorem
  for s being State of SCMPDS, i being Instruction of SCMPDS st InsCode
  i in {0,4,5,6} holds DataPart Exec(i,s) = DataPart s
proof
  let s be State of SCMPDS,i be Instruction of SCMPDS;
  assume
A1: InsCode i in {0,4,5,6};
  now
    let a be Int_position;
    per cases by A1,ENUMSET1:def 2;
    suppose
      InsCode i = 0;
      then ex k1 st i = goto k1 by SCMPDS_2:35;
      hence Exec(i,s).a = s.a by SCMPDS_2:66;
    end;
    suppose
      InsCode i = 4;
      then ex b,k1,k2 st i = (b,k1)<>0_goto k2 by SCMPDS_2:39;
      hence Exec(i,s).a = s.a by SCMPDS_2:67;
    end;
    suppose
      InsCode i = 5;
      then ex b,k1,k2 st i = (b,k1)<=0_goto k2 by SCMPDS_2:40;
      hence Exec(i,s).a = s.a by SCMPDS_2:68;
    end;
    suppose
      InsCode i = 6;
      then ex b,k1,k2 st i = (b,k1)>=0_goto k2 by SCMPDS_2:41;
      hence Exec(i,s).a = s.a by SCMPDS_2:69;
    end;
  end;
  hence thesis by SCMPDS_4:23;
end;

theorem :: ?!?
  for s,ss being State of SCMPDS holds (s +* ss | NAT) | SCM-Data-Loc =
  DataPart s
proof
  let s,ss be State of SCMPDS;
  dom ProgramPart ss = A by COMPOS_1:34;
  hence thesis by AMI_2:29,FUNCT_4:76,SCMPDS_2:100;
end;

canceled;

theorem Th23: ::SCMPDS_4:15
  IC s1 = IC s2 & DataPart s1 = DataPart s2 implies IC Exec(i,s1)=
  IC Exec(i,s2) & DataPart Exec(i,s1) = DataPart Exec(i,s2)
proof
  assume that
A1: IC s1 = IC s2 and
A2: DataPart s1 = DataPart s2;
  s1,s2 equal_outside A by A1,A2,SCMPDS_6:4;
  then Exec(i,s1),Exec(i,s2) equal_outside A by SCMPDS_4:15;
  hence thesis by SCMPDS_6:4;
end;

theorem Th24:
  for s1,s2 being State of SCMPDS,I being Program of SCMPDS st I
  is_closed_on s1 & Initialize stop I c= s1 & Initialize stop I c= s2 &
DataPart s1 = DataPart s2 for i being Element of NAT holds
  IC Comput(ProgramPart(s1),s1,i)
= IC Comput(ProgramPart(s2),s2,i) &
  CurInstr(ProgramPart (s1),Comput(ProgramPart(s1),s1,i))
 = CurInstr(ProgramPart (s2),Comput(ProgramPart(s2),s2,i)) &
  DataPart Comput(ProgramPart(s1),s1,i) = DataPart Comput(ProgramPart(s2),s2,i)
proof
  let s1,s2 be State of SCMPDS,I be Program of SCMPDS;
  set pI=stop I;
  assume that
A1: I is_closed_on s1 and
A2: Initialize pI c= s1 and
A3: Initialize pI c= s2 and
A4: DataPart s1 = DataPart s2;
A5: IC SCMPDS in dom Initialize pI by COMPOS_1:def 16;
  then
A6: IC s1 = (Initialize pI).IC SCMPDS by A2,GRFUNC_1:8
    .= IC s2 by A3,A5,GRFUNC_1:8;
  defpred P[Element of NAT] means IC Comput(ProgramPart(s1),s1,$1) = IC Comput(
ProgramPart(s2),s2,$1) &
  CurInstr(ProgramPart (s1),Comput(ProgramPart(s1),s1,$1)) =
  CurInstr(ProgramPart (s2),Comput(ProgramPart(s2),s2,$1)) &
  DataPart
  Comput(ProgramPart(s1),s1,$1) = DataPart Comput(ProgramPart(s2),s2,$1);
  pI c= Initialize pI by COMPOS_1:126;
  then
A7: dom pI c= dom Initialize pI by GRFUNC_1:8;
A8: s1 +* Initialize pI = Initialize s1 +* pI by COMPOS_1:125;
A9: s1=Initialize s1 +* pI by A2,A8,FUNCT_4:79;
  then IC Comput(ProgramPart(s1),s1,0) in dom pI by A1,SCMPDS_6:def 2;
  then
A10: IC s1 in dom pI by EXTPRO_1:3;
  then
A11: s1.IC s1 = (Initialize pI).IC s1 by A2,A7,GRFUNC_1:8
    .= s2.IC s2 by A3,A7,A10,A6,GRFUNC_1:8;
A12: DataPart Comput(ProgramPart(s1),s1,0) = DataPart s2 by A4,EXTPRO_1:3
    .= DataPart Comput(ProgramPart(s2),s2,0) by EXTPRO_1:3;
A13: Comput(ProgramPart(s1),s1,0) = s1 by EXTPRO_1:3;
A14: Comput(ProgramPart(s2),s2,0) = s2 by EXTPRO_1:3;
A15:  (ProgramPart s2)/.IC s2
 = s2.IC s2 by COMPOS_1:38;
A16:  (ProgramPart s1)/.IC s1
 = s1.IC s1 by COMPOS_1:38;
A17: CurInstr(ProgramPart (s1),Comput(ProgramPart(s1),s1,0))
     = CurInstr(ProgramPart s1,s1) by A13
    .= CurInstr(ProgramPart s2,s2) by A11,A15,A16
    .= CurInstr(ProgramPart (s2),Comput(ProgramPart(s2) ,s2,0)) by A14;
A18: for k being Element of NAT st P[k] holds P[k + 1]
  proof
    let k be Element of NAT;
    assume
A19: P[k];
    set l = IC Comput(ProgramPart(s1),s1,k+1);
A20: IC Comput(ProgramPart(s1),s1,k+1) in dom pI by A1,A9,SCMPDS_6:def 2;
    set i = CurInstr(ProgramPart Comput(ProgramPart(s1),s1,k),Comput(
ProgramPart(s1),s1,k));
A21: ProgramPart s1 = ProgramPart Comput(ProgramPart(s1),s1,k)
by AMI_1:123;
A22: ProgramPart s1 = ProgramPart Comput(ProgramPart(s1),s1,k+1)
by AMI_1:123;
A23: Comput(ProgramPart(s1),s1,k+1) = Following(ProgramPart s1,
Comput(ProgramPart(s1),s1,k)) by EXTPRO_1:4
      .= Exec(i,Comput(ProgramPart(s1),s1,k)) by A21;
A24: ProgramPart s2 = ProgramPart Comput(ProgramPart(s2),s2,k+1)
by AMI_1:123;
A25: Comput(ProgramPart(s2),s2,k+1) = Following(ProgramPart s2,
     Comput(ProgramPart(s2),s2,k)) by EXTPRO_1:4
      .= Exec(i,Comput(ProgramPart(s2),s2,k)) by A19,A21;
    hence IC Comput(ProgramPart(s1),s1,k+1) = IC Comput(ProgramPart(s2),s2,k+1)
by A19,A23,Th23;
A26
:  (ProgramPart Comput(ProgramPart(s1),s1,k+1))/.IC Comput(ProgramPart(s1),s1,
k+1)
 = Comput(ProgramPart(s1),s1,k+1).IC Comput(ProgramPart(s1),s1,k+1) by
COMPOS_1:38;
A27
:  (ProgramPart Comput(ProgramPart(s2),s2,k+1))/.IC Comput(ProgramPart(s2),s2,
k+1)
  = Comput(ProgramPart(s2),s2,k+1).IC Comput(ProgramPart(s2),s2,k+1) by
COMPOS_1:38;
    thus CurInstr(ProgramPart(s1),Comput(ProgramPart(s1),s1,k+1))
     = s1.l by A26,A22,AMI_1:54
      .= (Initialize pI).l by A2,A7,A20,GRFUNC_1:8
      .= s2.l by A3,A7,A20,GRFUNC_1:8
      .= Comput(ProgramPart(s2),s2,k+1).l by AMI_1:54
      .=CurInstr(ProgramPart (s2),Comput(ProgramPart(s2),s2,k+1))
      by A19,A23,A25,Th23,A27,A24;
    thus thesis by A19,A23,A25,Th23;
  end;
  IC Comput(ProgramPart(s1),s1,0) =IC s1 by EXTPRO_1:3
    .=IC Comput(ProgramPart(s2),s2,0) by A6,EXTPRO_1:3;
  then
A28: P[0] by A17,A12;
  thus for k being Element of NAT holds P[k] from NAT_1:sch 1(A28,A18);
end;

theorem Th25:
  for s1,s2 being State of SCMPDS,I being Program of SCMPDS
   st I is_closed_on s1 & DataPart s1 = DataPart s2
 for k being Element of NAT
  holds Comput(ProgramPart(Initialize s1+*stop I),Initialize s1+*stop I,k),
  Comput(ProgramPart(Initialize s2+*stop I),Initialize s2+*stop I
  ,k) equal_outside NAT &
  CurInstr(ProgramPart (Initialize s1+*stop I),
   Comput(ProgramPart(Initialize s1+*stop I),Initialize s1+*stop I,k)) =
  CurInstr(ProgramPart (Initialize s2+*stop I),
   Comput(ProgramPart(Initialize s2+*stop I),Initialize s2+*stop I,k))
proof
  let s1,s2 be State of SCMPDS,I be Program of SCMPDS;
  assume
A1: I is_closed_on s1;
  set pI = stop I;
  set ss1 = Initialize s1 +* stop I;
  set ss2 = Initialize s2 +* stop I;
A2: Initialize s1 +* stop I = s1 +* Initialize stop I by COMPOS_1:125;
A3: Initialize s2 +* stop I = s2 +* Initialize stop I by COMPOS_1:125;
A4: pI c= Initialize stop I by COMPOS_1:126;
  Initialize stop I c= ss2 by A3,FUNCT_4:26;
  then
A5: pI c= ss2 by A4,XBOOLE_1:1;
  Initialize stop I c= ss1 by A2,FUNCT_4:26;
  then
A6: pI c= ss1 by A4,XBOOLE_1:1;
  assume
A7: DataPart s1 = DataPart s2;
    let k be Element of NAT;
A8: IC Comput(ProgramPart(ss1),ss1,k) in dom pI by A1,SCMPDS_6:def 2;
A9: I is_closed_on s2 by A1,A7,SCMPDS_6:36;
    then
A10: for m st m < k holds IC Comput(ProgramPart(ss2),ss2,m) in dom pI by
SCMPDS_6:def 2;
    ss1,ss2 equal_outside A by A7,SCMPDS_6:12;
    hence Comput(ProgramPart(ss1),ss1,k),Comput(ProgramPart(ss2),ss2,k)
equal_outside A by A6,A5,A10,SCMPDS_4:67;
    then
A11: IC Comput(ProgramPart(ss1),ss1,k) = IC Comput(ProgramPart(ss2),ss2,k) by
COMPOS_1:24;
A12: IC Comput(ProgramPart(ss2),ss2,k) in dom pI by A9,SCMPDS_6:def 2;
A13:  (ProgramPart Comput(ProgramPart(ss2),ss2,k))/.IC Comput(ProgramPart(ss2),
ss2,k)
 = Comput(ProgramPart(ss2),ss2,k).IC Comput(ProgramPart(ss2),ss2,k) by
COMPOS_1:38;
A14:  (ProgramPart Comput(ProgramPart(ss1),ss1,k))/.IC Comput(ProgramPart(ss1),
ss1,k)
 = Comput(ProgramPart(ss1),ss1,k).IC Comput(ProgramPart(ss1),ss1,k) by
COMPOS_1:38;
A15: ProgramPart ss2 = ProgramPart Comput(ProgramPart(ss2),ss2,k)
by AMI_1:123;
A16: ProgramPart ss1 = ProgramPart Comput(ProgramPart(ss1),ss1,k)
by AMI_1:123;
    thus CurInstr(ProgramPart (ss2),Comput(ProgramPart(ss2),ss2,k))
     = ss2.IC Comput(ProgramPart(ss2),ss2,k) by A13,A15,AMI_1:54
      .= pI.IC Comput(ProgramPart(ss2),ss2,k) by A5,A12,GRFUNC_1:8
      .= ss1.IC Comput(ProgramPart(ss1),ss1,k) by A6,A11,A8,GRFUNC_1:8
      .= CurInstr(ProgramPart (ss1),Comput(ProgramPart(ss1),ss1,k))
       by A14,A16,AMI_1:54;
end;

theorem Th26: ::SCMPDS_5:20
  for I being Program of SCMPDS st I is_closed_on s1 & Initialize
  stop I c= s1 & Initialize stop I c= s2 & s1,s2 equal_outside NAT holds for k
  being Element of NAT holds Comput(ProgramPart(s1),s1,k), Comput(ProgramPart(
s2),s2,k) equal_outside
  NAT & CurInstr(ProgramPart (s1),Comput(ProgramPart(s1),s1,k))
   = CurInstr(ProgramPart (s2),Comput(ProgramPart(s2),s2,k))
proof
  let I be Program of SCMPDS;
  set iI=Initialize stop I;
A1: s1 +* iI = Initialize s1 +* stop I by COMPOS_1:125;
A2: s2 +* iI = Initialize s2 +* stop I by COMPOS_1:125;
  assume that
A3: I is_closed_on s1 and
A4: iI c= s1 and
A5: iI c= s2 and
A6: s1,s2 equal_outside A;
A7: s2=s2 +* iI by A5,FUNCT_4:79;
A8: DataPart s1 = DataPart s2 by A6,SCMPDS_6:4;
  s1=s1 +* iI by A4,FUNCT_4:79;
  hence thesis by A3,A7,A8,Th25,A1,A2;
end;

theorem
  for s1,s2 being State of SCMPDS,I being Program of SCMPDS st I
  is_closed_on s1 & I is_halting_on s1 & Initialize stop I c= s1 & Initialize
  stop I c= s2 & DataPart s1 = DataPart s2 holds LifeSpan(ProgramPart(s1),s1) =
LifeSpan(ProgramPart(s2),s2)
proof
  let s1,s2 be State of SCMPDS,I be Program of SCMPDS;
  assume that
A1: I is_closed_on s1 and
A2: I is_halting_on s1 and
A3: Initialize stop I c= s1 and
A4: Initialize stop I c= s2 and
A5: DataPart s1 = DataPart s2;
A6: s1 +* Initialize stop I = Initialize s1 +* stop I by COMPOS_1:125;
  s1 = Initialize s1 +* stop I by A3,A6,FUNCT_4:79;
  then
A7: ProgramPart s1 halts_on s1 by A2,SCMPDS_6:def 3;
A8: now
    let k be Element of NAT;
    assume
    CurInstr(ProgramPart (s2),Comput(ProgramPart(s2),s2,k)) = halt SCMPDS;
    then CurInstr(ProgramPart (s1),Comput(ProgramPart(s1),s1,k))
     = halt SCMPDS by A1,A3,A4,A5,Th24;
    hence LifeSpan(ProgramPart(s1),s1) <= k by A7,EXTPRO_1:def 14;
  end;
  CurInstr(ProgramPart (s1),Comput(
ProgramPart(s1),s1,LifeSpan(ProgramPart(s1),s1)))
   = halt SCMPDS by A7,EXTPRO_1:def 14;
  then
A9: CurInstr(ProgramPart (s2),
Comput(ProgramPart(s2),s2,LifeSpan(ProgramPart(s1),s1)))
 = halt SCMPDS by A1,A3,A4,A5,Th24;
  then ProgramPart s2 halts_on s2 by EXTPRO_1:30;
  hence thesis by A9,A8,EXTPRO_1:def 14;
end;

theorem Th28: ::SCMPDS_5:21
  for I being Program of SCMPDS st I is_closed_on s1 & I
is_halting_on s1 & Initialize stop I c= s1 & Initialize stop I c= s2 & s1,s2
  equal_outside NAT holds LifeSpan(ProgramPart(s1),s1) = LifeSpan(ProgramPart(
s2),s2) & Result(ProgramPart(s1),s1), Result(ProgramPart(s2),s2)
  equal_outside NAT
proof
  let I be Program of SCMPDS;
  assume that
A1: I is_closed_on s1 and
A2: I is_halting_on s1 and
A3: Initialize stop I c= s1 and
A4: Initialize stop I c= s2 and
A5: s1,s2 equal_outside A;
  DataPart s1 = DataPart s2 by A5,SCMPDS_6:4;
  then
A6: I is_halting_on s2 by A1,A2,SCMPDS_6:37;
A7: Initialize s1 +* stop I = s1 +* Initialize stop I by COMPOS_1:125;
A8: Initialize s2 +* stop I = s2 +* Initialize stop I by COMPOS_1:125;
  s2=Initialize s2 +* stop I by A4,A8,FUNCT_4:79;
  then
A9: ProgramPart s2 halts_on s2 by A6,SCMPDS_6:def 3;
  s1=Initialize s1 +* stop I by A3,A7,FUNCT_4:79;
  then
A10: ProgramPart s1 halts_on s1 by A2,SCMPDS_6:def 3;
A11: now
    let l be Element of NAT;
    assume
A12: CurInstr(ProgramPart (s2),Comput(ProgramPart(s2),s2,l)) = halt SCMPDS;
    CurInstr(ProgramPart (s1),Comput(ProgramPart(s1),s1,l))
     = CurInstr(ProgramPart (s2),Comput(ProgramPart(s2),s2,l))
      by A1,A3,A4,A5,Th26
;
    hence LifeSpan(ProgramPart(s1),s1) <= l by A10,A12,EXTPRO_1:def 14;
  end;
  CurInstr(ProgramPart (s2),
Comput(ProgramPart(s2),s2,LifeSpan(ProgramPart(s1),s1)))
   = CurInstr(ProgramPart (s1),
   Comput(ProgramPart(s1),s1,LifeSpan(ProgramPart(s1),s1)))
    by A1,A3,A4,A5,Th26
    .= halt SCMPDS by A10,EXTPRO_1:def 14;
  hence LifeSpan(ProgramPart(s1),s1) = LifeSpan(ProgramPart(s2),s2) by A11,A9,
EXTPRO_1:def 14;
  then
A13: Result(ProgramPart(s2),s2) = Comput(ProgramPart(s2),s2,LifeSpan(
ProgramPart(s1),s1)) by A9,EXTPRO_1:23;
  Result(ProgramPart(s1),s1) = Comput(ProgramPart(s1),s1,LifeSpan(ProgramPart(
s1),s1)) by A10,EXTPRO_1:23;
  hence thesis by A1,A3,A4,A5,A13,Th26;
end;

theorem Th29:
  for s1,s2 being State of SCMPDS,I being Program of SCMPDS st I
is_closed_on s1 & I is_halting_on s1 & DataPart s1 = DataPart s2 holds LifeSpan
(ProgramPart(Initialize s1 +* stop I),Initialize s1 +* stop I) = LifeSpan(
ProgramPart(Initialize s2 +* stop I),Initialize s2 +* stop I) & Result(
ProgramPart(Initialize s1 +* stop I),
   Initialize s1
  +* stop I),Result(ProgramPart(Initialize s2 +* stop I),Initialize s2 +*
stop I) equal_outside NAT
proof
  let s1,s2 be State of SCMPDS,I be Program of SCMPDS;
  assume
A1: I is_closed_on s1;
  set ss1 = Initialize s1 +* stop I;
  set ss2 = Initialize s2 +* stop I;
  assume
A2: I is_halting_on s1;
  then
A3: ProgramPart ss1 halts_on ss1 by SCMPDS_6:def 3;
  then
A4: Result(ProgramPart(ss1),ss1) = Comput(ProgramPart(ss1),ss1,LifeSpan(
ProgramPart(ss1),ss1)) by EXTPRO_1:23;
  assume
A5: DataPart s1 = DataPart s2;
  then I is_halting_on s2 by A1,A2,SCMPDS_6:37;
  then
A6: ProgramPart ss2 halts_on ss2 by SCMPDS_6:def 3;
A7: now
    let l be Element of NAT;
    assume
A8: CurInstr(ProgramPart (ss2),Comput(ProgramPart(ss2),ss2,l)) = halt SCMPDS;
    CurInstr(ProgramPart (ss1),Comput(ProgramPart(ss1),ss1,l))
     = CurInstr(ProgramPart (ss2),Comput(ProgramPart(ss2),ss2,l))
      by A1,A5,Th25;
    hence LifeSpan(ProgramPart(ss1),ss1) <= l by A3,A8,EXTPRO_1:def 14;
  end;
  CurInstr(ProgramPart (ss2),
  Comput(ProgramPart(ss2),ss2,LifeSpan(ProgramPart(ss1),ss1))) =
   CurInstr(ProgramPart (ss1),
   Comput(ProgramPart(ss1),ss1,LifeSpan(ProgramPart(ss1),ss1)))
    by A1,A5,Th25
    .= halt SCMPDS by A3,EXTPRO_1:def 14;
  hence LifeSpan(ProgramPart(ss1),ss1) = LifeSpan(ProgramPart(ss2),ss2) by A7
,A6,EXTPRO_1:def 14;
  then Result(ProgramPart(ss2),ss2) = Comput(ProgramPart(ss2),ss2,LifeSpan(
ProgramPart(ss1),ss1)) by A6,EXTPRO_1:23;
  hence thesis by A1,A5,A4,Th25;
end;

theorem
  for s1,s2 being State of SCMPDS,I being Program of SCMPDS st I
  is_closed_on s1 & I is_halting_on s1 & Initialize stop I c= s1 & Initialize
stop I c= s2 & ex k being Element of NAT st Comput(ProgramPart(s1),s1,k),s2
equal_outside
  NAT holds Result(ProgramPart(s1),s1),Result(ProgramPart(s2),s2) equal_outside
NAT
proof
  let s1,s2 be State of SCMPDS,I be Program of SCMPDS;
  set pI =stop I;
  assume
A1: I is_closed_on s1;
A2: s1 +* Initialize stop I = Initialize s1 +* stop I by COMPOS_1:125;
  assume
A3: I is_halting_on s1;
  assume
A4: Initialize stop I c= s1;
  then
A5: s1 = Initialize s1 +* stop I by A2,FUNCT_4:79;
  then
A6: ProgramPart s1 halts_on s1 by A3,SCMPDS_6:def 3;
  then consider n being Element of NAT such that
A7: CurInstr(ProgramPart (s1),Comput(ProgramPart(s1),s1,n))
 = halt SCMPDS by EXTPRO_1:30;
A8: s2 +* Initialize stop I = Initialize s2 +* stop I by COMPOS_1:125;
  assume
  Initialize stop I c= s2;
  then
A9: s2 = Initialize s2 +* stop I by A8,FUNCT_4:79;
  given k being Element of NAT such that
A10: Comput(ProgramPart(s1),s1,k),s2 equal_outside A;
  set s3 = Comput(ProgramPart(s1),s1,k);
A11: IC SCMPDS in dom s3 by COMPOS_1:9;
A12: s3 +* Initialize stop I = Initialize s3 +* stop I by COMPOS_1:125;
  pI c= Initialize stop I by COMPOS_1:126;
  then pI c= s1 by A4,XBOOLE_1:1;
  then
A13: pI c= s3 by AMI_1:86;
  IC s3 = IC (Initialize s2 +* stop I) by A10,A9,COMPOS_1:24
    .=  0 by SCMPDS_6:21;
  then IC SCMPDS .-->  0 c= s3 by A11,FUNCOP_1:88;
  then Initialize pI c= s3 by A13,FUNCT_4:92;
  then
A14: s3 = Initialize s3 +* stop I by A12,FUNCT_4:79;
A15: now
    let n be Element of NAT;
A16: ProgramPart s1 = ProgramPart s3
by AMI_1:123;
    IC Comput(ProgramPart(s1),s3,n) = IC Comput(ProgramPart(s1),s1,k+n) by
EXTPRO_1:5;
    hence IC Comput(ProgramPart(s3),s3,n) in dom pI
     by A1,A5,A16,SCMPDS_6:def 2;
  end;
A17: ProgramPart s1 = ProgramPart Comput(ProgramPart(s1),
s1,k)
by AMI_1:123;
A18: Comput(ProgramPart(s1),s1,k+n)
 = Comput(ProgramPart(s1),Comput(ProgramPart(s1),s1,k),n) by EXTPRO_1:5;
A19: Comput(ProgramPart(s1),s1,k+n) = Comput(ProgramPart(s1),s1,n)
     by A7,EXTPRO_1:6,NAT_1:11;
  CurInstr(ProgramPart (s3),Comput(ProgramPart(s3),s3,n)) =
   CurInstr(ProgramPart (s1),Comput(ProgramPart(s1),s1,k+n))
    by A18,A17
    .= CurInstr(ProgramPart (s1),Comput(ProgramPart(s1)
,s1,n))
     by A19;
  then ProgramPart s3 halts_on s3 by A7,EXTPRO_1:30;
  then
A20: I is_halting_on s3 by A14,SCMPDS_6:def 3;
A21: DataPart s3 = DataPart s2 by A10,SCMPDS_6:4;
  consider k being Element of NAT such that
A22: CurInstr(ProgramPart (s1),Comput(ProgramPart(s1),s1,k))
 = halt SCMPDS by A6,EXTPRO_1:30;
A23
:  (ProgramPart Comput(ProgramPart(s1),s1,k))/.IC Comput(ProgramPart(s1),s1,k)
 = Comput(ProgramPart(s1),s1,k).IC Comput(ProgramPart(s1),s1,k) by COMPOS_1:38;
A24: ProgramPart s1 = ProgramPart Comput(ProgramPart(s1),s1,k)
by AMI_1:123;
A25: (ProgramPart s1).IC Comput(ProgramPart(s1),s1,k)
    = s1.IC Comput(ProgramPart(s1),s1,k) by COMPOS_1:2
   .= halt SCMPDS by A22,A23,A24,AMI_1:54;
A26: ProgramPart s1 = ProgramPart s3
by AMI_1:123;
  I is_closed_on s3 by A14,A15,SCMPDS_6:def 2;
  then Result(ProgramPart(s3),s3),Result(ProgramPart(s2),s2) equal_outside A
by A9,A21,A14,A20,Th29;
  hence thesis by A25,A26,EXTPRO_1:9;
end;

theorem Th31:
  for s being State of SCMPDS,I being Program of SCMPDS, a being
  Int_position st I is_halting_on s holds IExec(I,s).a =
  Comput(ProgramPart(Initialize s +* stop I),Initialize s +*
  stop I, (LifeSpan(ProgramPart(Initialize s +* stop I),Initialize s +*
stop I))).a
proof
  let s be State of SCMPDS,I be Program of SCMPDS, a be Int_position;
  set s1 = Initialize s +* stop I;
  assume
  I is_halting_on s;
  then
A1: ProgramPart s1 halts_on s1 by SCMPDS_6:def 3;
A2: dom ProgramPart s =A by COMPOS_1:34;
  not a in dom (s | A) by A2,SCMPDS_2:53;
  hence IExec(I,s).a = (Result(ProgramPart(s1),s1)).a by FUNCT_4:12
    .= Comput(ProgramPart(s1),s1,LifeSpan(ProgramPart(s1),s1)).a by A1,
EXTPRO_1:23;
end;

theorem
  for s being State of SCMPDS,I being parahalting Program of SCMPDS, a
being Int_position holds IExec(I,s).a =
 Comput(ProgramPart(Initialize s +* stop I),Initialize s +* stop I, (
  LifeSpan(ProgramPart(Initialize s +* stop I),Initialize s +* stop I))).a
by Th31,SCMPDS_6:35;

theorem Th33:
  for I being Program of SCMPDS,i being Element of NAT st
Initialize stop I c= s & I is_closed_on s & I is_halting_on s & i < LifeSpan(
ProgramPart(s),s)
  holds IC Comput(ProgramPart(s),s,i) in dom I
proof
  let I be Program of SCMPDS,i be Element of NAT;
  set sI = stop I, Ci = Comput(ProgramPart(s),s,i), Lc = IC Ci;
  assume that
A1: Initialize sI c= s and
A2: I is_closed_on s and
A3: I is_halting_on s and
A4: i < LifeSpan(ProgramPart(s),s);
A5: s +* Initialize sI = Initialize s +* sI by COMPOS_1:125;
A6: s = Initialize s +* sI by A1,A5,FUNCT_4:79;
  then
A7: Lc in dom sI by A2,SCMPDS_6:def 2;
  sI c= Initialize sI by COMPOS_1:126;
  then
A8: sI c= s by A1,XBOOLE_1:1;
A9: ProgramPart s halts_on s by A3,A6,SCMPDS_6:def 3;
  now
    assume
A10: sI.Lc=halt SCMPDS;
A11: ProgramPart Ci = ProgramPart s
by AMI_1:123;
A12:  (ProgramPart Ci)/.IC Ci
 = Ci.IC Ci by COMPOS_1:38;
    CurInstr(ProgramPart Ci,Ci) =s.Lc by A12,AMI_1:54
      .=halt SCMPDS by A7,A8,A10,GRFUNC_1:8;
    hence contradiction by A4,A9,A11,EXTPRO_1:def 14;
  end;
  hence thesis by A7,SCMPDS_5:3;
end;

theorem Th34:
  for I being shiftable Program of SCMPDS st Initialize stop I c=
s1 & I is_closed_on s1 & I is_halting_on s1 for n being Element of NAT st Shift
  (I,n) c= s2 & card I > 0 & IC s2 =  n & DataPart s1 = DataPart s2 for i
  being Element of NAT holds i < LifeSpan(ProgramPart(s1),s1) implies IC Comput
(ProgramPart(s1),
s1,i) + n =
IC Comput(ProgramPart(s2),s2,i) &
CurInstr(ProgramPart Comput(ProgramPart(s1),s1,i),Comput(ProgramPart(s1),s1,i))
=
CurInstr(ProgramPart Comput(ProgramPart(s2),s2,i),Comput(ProgramPart(s2),s2,i))
 & DataPart Comput(ProgramPart(s1),s1,i) = DataPart Comput(ProgramPart(s2),s2,i
)
proof
  let I be shiftable Program of SCMPDS;
  set SI=stop I;
  assume that
A1: Initialize SI c= s1 and
A2: I is_closed_on s1 and
A3: I is_halting_on s1;
  dom SI misses dom Start-At(0,SCMPDS) by COMPOS_1:130;
  then
A4: SI c= Initialize SI by FUNCT_4:33;
  then
A5: dom SI c= dom Initialize SI by GRFUNC_1:8;
  let n be Element of NAT;
  assume that
A6: Shift(I,n) c= s2 and
A7: card I > 0 and
A8: IC s2 =  n and
A9: DataPart s1 = DataPart s2;
  defpred P[Element of NAT] means $1 < LifeSpan(ProgramPart(s1),s1) implies IC
Comput(
ProgramPart(s1),s1,
  $1) + n = IC Comput(ProgramPart(s2),s2,$1) & CurInstr(ProgramPart Comput(
ProgramPart(s1),s1,$1),
  Comput(ProgramPart(s1),s1,$1))
   = CurInstr(ProgramPart Comput(ProgramPart(s2),s2,$1),Comput(ProgramPart(s2),
s2,$1))
    & DataPart Comput(ProgramPart(s1),s1,$1) = DataPart Comput(ProgramPart(s2),
s2,$1);
A10: Initialize s1 +* SI = s1 +* Initialize SI by COMPOS_1:125;
A11: s1=Initialize s1 +* SI by A1,A10,FUNCT_4:79;
A12: for k being Element of NAT st P[k] holds P[k + 1]
  proof
    let k be Element of NAT;
    assume
A13: P[k];
    now
      reconsider m = IC Comput(ProgramPart(s1),s1,k) as Element of NAT;
      set i = CurInstr(ProgramPart Comput(ProgramPart(s1),s1,k),Comput(
ProgramPart(s1),s1,k));
A14:  k <= k+1 by NAT_1:11;
      reconsider l = IC Comput(ProgramPart(s1),s1,k+1) as Element of NAT;
A15: ProgramPart s1 = ProgramPart Comput(ProgramPart
(s1),s1,k)
by AMI_1:123;
A16:  Comput(ProgramPart(s1),s1,k+1) = Following(ProgramPart s1,
Comput(ProgramPart(s1),s1,k)) by EXTPRO_1:4
        .= Exec(CurInstr(ProgramPart Comput(ProgramPart(s1),s1,k),Comput(
ProgramPart(s1),s1,k)),
        Comput(ProgramPart(s1),s1,k)) by A15;
      assume
A17:  k+1 < LifeSpan(ProgramPart(s1),s1);
      then
A18:  IC Comput(ProgramPart(s1),s1,k+1) in dom I by A1,A2,A3,Th33;
      then
A19:  l+n in dom Shift(I,n) by VALUED_1:25;
A20: ProgramPart s2 = ProgramPart Comput(ProgramPart(s2),s2,k)
by AMI_1:123;
A21:  Comput(ProgramPart(s2),s2,k+1) =
Following(ProgramPart s2,Comput(ProgramPart(s2),s2,k)
)
 by EXTPRO_1:4
        .= Exec(CurInstr(ProgramPart Comput(ProgramPart(s2),s2,k),Comput(
ProgramPart(s2),s2,k)),
        Comput(ProgramPart(s2),s2,k)) by A20;
A22:  IC Comput(ProgramPart(s1),s1,k) in dom SI by A2,A11,SCMPDS_6:def 2;
A23
:  (ProgramPart Comput(ProgramPart(s1),s1,k))/.IC Comput(ProgramPart(s1),s1,k)
 = Comput(ProgramPart(s1),s1,k).IC Comput(ProgramPart(s1),s1,k) by COMPOS_1:38;
A24:  i = s1.IC Comput(ProgramPart(s1),s1,k) by A23,AMI_1:54
        .= (Initialize SI).IC Comput(ProgramPart(s1),s1,k)
           by A1,A5,A22,GRFUNC_1:8
        .= SI.IC Comput(ProgramPart(s1),s1,k) by A4,A22,GRFUNC_1:8;
      then
A25:  InsCode i <> 3 by A22,SCMPDS_4:def 12;
A26:  IC Comput(ProgramPart(s1),s1,k+1) in dom SI by A2,A11,SCMPDS_6:def 2;
A27:  i valid_at m by A22,A24,SCMPDS_4:def 12;
A28:  InsCode i <> 1 by A22,A24,SCMPDS_4:def 12;
      hence
A29:  IC Comput(ProgramPart(s1),s1,k+1) + n = IC Comput(ProgramPart(s2),s2,k+1)
by A13,A17,A14,A16,A21,A25,A27,SCMPDS_4:83,XXREAL_0:2;
A30
:  (ProgramPart Comput(ProgramPart(s1),s1,k+1))/.IC Comput(ProgramPart(s1),s1,
k+1)
 = Comput(ProgramPart(s1),s1,k+1).IC Comput(ProgramPart(s1),s1,k+1) by
COMPOS_1:38;
A31
:  (ProgramPart Comput(ProgramPart(s2),s2,k+1))/.IC Comput(ProgramPart(s2),s2,
k+1)
 = Comput(ProgramPart(s2),s2,k+1).IC Comput(ProgramPart(s2),s2,k+1) by
COMPOS_1:38;
      CurInstr(ProgramPart Comput(ProgramPart(s1),s1,k+1),Comput(ProgramPart(s1
),s1,k+1)) = s1.l
       by A30,AMI_1:54
        .= (Initialize SI).l by A1,A5,A26,GRFUNC_1:8
        .= SI.l by A4,A26,GRFUNC_1:8;
      hence CurInstr(ProgramPart Comput(ProgramPart(s1),s1,k+1),Comput(
ProgramPart(s1),s1,k+1))
       = Shift(SI,n).(l + n) by A26,VALUED_1:def 12
        .= Shift(I,n).(IC Comput(ProgramPart(s2),s2,k+1)) by A29,A18,Th18
        .= s2.IC Comput(ProgramPart(s2),s2,k+1) by A6,A29,A19,GRFUNC_1:8
        .= CurInstr(ProgramPart Comput(ProgramPart(s2),s2,k+1),Comput(
ProgramPart(s2),s2,k+1))
         by A31,AMI_1:54;
      thus DataPart Comput(ProgramPart(s1),s1,k+1) = DataPart Comput(
ProgramPart(s2),s2,k+1) by A13,A17,A14,A16,A21,A28,A25,A27,SCMPDS_4:83
,XXREAL_0:2;
    end;
    hence thesis;
  end;
  let i be Element of NAT;
A32:  0 in dom SI by COMPOS_1:135;
A33:  0 in dom I by A7,AFINSQ_1:70;
A34: P[0]
  proof
    assume
    0 < LifeSpan(ProgramPart(s1),s1);
A35:  ((0 qua Nat)+ n) in dom Shift(I,n) by A33,VALUED_1:25;
A36: IC SCMPDS in dom Initialize SI by COMPOS_1:def 16;
    then
A37: s1.IC s1 = s1.IC Initialize SI by A1,GRFUNC_1:8
      .= s1. 0 by COMPOS_1:def 16
      .= (Initialize SI). 0 by A1,A5,A32,GRFUNC_1:8
      .= SI. 0 by A4,A32,GRFUNC_1:8;
    IC Comput(ProgramPart(s1),s1,0) = s1.IC SCMPDS by EXTPRO_1:3
      .= IC Initialize SI by A1,A36,GRFUNC_1:8
      .=  0 by COMPOS_1:def 16;
    hence IC Comput(ProgramPart(s1),s1,0) + n =  ((0 qua Nat)+ n)
      .= IC Comput(ProgramPart(s2),s2,0) by A8,EXTPRO_1:3;
A38: Comput(ProgramPart(s1),s1,0) = s1 by EXTPRO_1:3;
A39: Comput(ProgramPart(s2),s2,0) = s2 by EXTPRO_1:3;
A40:  (ProgramPart s1)/.IC s1
 = s1.IC s1 by COMPOS_1:38;
A41:  (ProgramPart s2)/.IC s2
 = s2.IC s2 by COMPOS_1:38;
    thus CurInstr(ProgramPart Comput(ProgramPart(s1),s1,0),Comput(ProgramPart(
s1),s1,0))
     = CurInstr(ProgramPart s1,s1) by A38
      .= Shift(SI,n).( (0 qua Nat)+ n) by A32,A37,A40,VALUED_1:def 12
      .= Shift(SI,n). ((0 qua Nat)+ n)
      .= Shift(I,n). n by A7,Th19
      .= CurInstr(ProgramPart s2,s2) by A6,A8,A35,A41,GRFUNC_1:8
      .= CurInstr(ProgramPart Comput(ProgramPart(s2),s2,0),Comput(ProgramPart(
s2),s2,0))
       by A39;
    thus DataPart Comput(ProgramPart(s1),s1,0) = DataPart s2 by A9,EXTPRO_1:3
      .= DataPart Comput(ProgramPart(s2),s2,0) by EXTPRO_1:3;
  end;
  for k being Element of NAT holds P[k] from NAT_1:sch 1(A34,A12);
  hence thesis;
end;

theorem Th35:
  for I being halt-free Program of SCMPDS st Initialize stop I
  c= s & I is_halting_on s & card I > 0 holds LifeSpan(ProgramPart(s),s) > 0
proof
  let I be halt-free Program of SCMPDS;
  set si=Initialize s +* stop I;
  assume that
A1: Initialize stop I c= s and
A2: I is_halting_on s and
A3: card I > 0;
A4: Initialize s +* stop I = s +* Initialize stop I by COMPOS_1:125;
A5: s=si by A1,A4,FUNCT_4:79;
  assume
  LifeSpan(ProgramPart(s),s) <= 0;
  then
A6: LifeSpan(ProgramPart(s),s)=0;
A7: I c= Initialize stop I by SCMPDS_6:17;
  then
A8: dom I c= dom Initialize stop I by GRFUNC_1:8;
A9:  0 in dom I by A3,AFINSQ_1:70;
A10: Comput(ProgramPart(si),si,0) = si by EXTPRO_1:3;
A11:  (ProgramPart si)/.IC si
 = si.IC si by COMPOS_1:38;
  ProgramPart si halts_on si by A2,SCMPDS_6:def 3;
  then halt SCMPDS
     = CurInstr(ProgramPart (si),Comput(ProgramPart(si),si,0))
      by A5,A6,EXTPRO_1:def 14
    .= CurInstr(ProgramPart si,si) by A10
    .= s. 0 by A5,A11,SCMPDS_6:21
    .=(Initialize stop I). 0 by A1,A9,A8,GRFUNC_1:8
    .=I. 0 by A9,A7,GRFUNC_1:8;
  hence contradiction by A9,SCMPDS_5:def 3;
end;

theorem Th36:
  for I being halt-free shiftable Program of SCMPDS st
  Initialize stop I c= s1 & I is_closed_on s1 & I is_halting_on s1 for n being
  Element of NAT st Shift(I,n) c= s2 & card I > 0 & IC s2 =  n & DataPart
  s1 = DataPart s2 holds IC Comput(ProgramPart(s2),s2,LifeSpan(ProgramPart(s1),
s1)) =  (card I + n) &
  DataPart Comput(ProgramPart(s1),s1,LifeSpan(ProgramPart(s1),s1)) = DataPart
Comput(ProgramPart
(s2),s2,LifeSpan(ProgramPart(s1),s1))
proof
  let I be halt-free shiftable Program of SCMPDS;
  assume that
A1: Initialize stop I c= s1 and
A2: I is_closed_on s1 and
A3: I is_halting_on s1;
  let n be Element of NAT;
  assume that
A4: Shift(I,n) c= s2 and
A5: card I > 0 and
A6: IC s2 =  n and
A7: DataPart s1 = DataPart s2;
  1+(0 qua Nat) <= LifeSpan(ProgramPart(s1),s1) by A1,A3,A5,Th35,INT_1:20;
  then consider i be Nat such that
A8: 1+i=LifeSpan(ProgramPart(s1),s1) by NAT_1:10;
A9: Initialize s1 +* stop I = s1 +* Initialize stop I by COMPOS_1:125;
  reconsider i as Element of NAT by ORDINAL1:def 13;
A10: i < LifeSpan(ProgramPart(s1),s1) by A8,XREAL_1:31;
  then
A11: IC Comput(ProgramPart(s1),s1,i) + n = IC Comput(ProgramPart(s2),s2,i) by
A1,A2,A3,A4,A5,A6,A7,Th34;
  set L1=IC Comput(ProgramPart(s1),s1,i);
A12: L1 in dom I by A1,A2,A3,A8,Th33,XREAL_1:31;
  set i2=CurInstr(ProgramPart Comput(ProgramPart(s2),s2,i),Comput(ProgramPart(
s2),s2,i));
A13: ProgramPart s1 = ProgramPart Comput(ProgramPart(s1),s1,i)
by AMI_1:123;
A14: Comput(ProgramPart(s1),s1,i+1) =
Following(ProgramPart s1,Comput(ProgramPart(s1),s1,i)
)
 by EXTPRO_1:4
    .= Exec(i2,Comput(ProgramPart(s1),s1,i)) by A1,A2,A3,A4,A5,A6,A7,A10,Th34,
A13;
A15: I c= Initialize stop I by SCMPDS_6:17;
  then
A16: dom I c= dom Initialize stop I by GRFUNC_1:8;
A17: ProgramPart s2 = ProgramPart Comput(ProgramPart(s2),s2,i)
by AMI_1:123;
A18: Comput(ProgramPart(s2),s2,i+1) =
Following(ProgramPart s2,Comput(ProgramPart(s2),s2,i)
)
 by EXTPRO_1:4
    .=Exec(i2,Comput(ProgramPart(s2),s2,i)) by A17;
  reconsider m = L1 as Element of NAT;
A19
:  (ProgramPart Comput(ProgramPart(s1),s1,i))/.IC Comput(ProgramPart(s1),s1,i)
 = Comput(ProgramPart(s1),s1,i).IC Comput(ProgramPart(s1),s1,i) by COMPOS_1:38;
  i2=CurInstr(ProgramPart Comput(ProgramPart(s1),s1,i),Comput(ProgramPart(s1),
s1,i))
   by A1,A2,A3,A4,A5,A6,A7,A10,Th34;
  then
A20: i2=s1.L1 by A19,AMI_1:54
    .=(Initialize stop I).L1 by A1,A12,A16,GRFUNC_1:8
    .=I.L1 by A12,A15,GRFUNC_1:8;
  then
A21: InsCode i2 <> 1 by A12,SCMPDS_4:def 12;
A22: DataPart Comput(ProgramPart(s1),s1,i) = DataPart Comput(ProgramPart(s2),s2
,i) by A1,A2,A3,A4,A5,A6,A7,A10,Th34;
A23: i2 valid_at m by A12,A20,SCMPDS_4:def 12;
A24: InsCode i2 <> 3 by A12,A20,SCMPDS_4:def 12;
  s1=Initialize s1 +* stop I by A1,A9,FUNCT_4:79;
  then IC Comput(ProgramPart(s1),s1,i+1)= card I by A2,A3,A8,A9,SCMPDS_6:43;
  hence IC Comput(ProgramPart(s2),s2,LifeSpan(ProgramPart(s1),s1)) =  card I +
n by A8,A11,A21,A24,A23,A14,A22,A18,SCMPDS_4:83
    .=  (card I + n);
  thus thesis by A8,A11,A21,A24,A23,A14,A22,A18,SCMPDS_4:83;
end;

theorem Th37:
  for s being 0-started State of SCMPDS,I being Program of SCMPDS,
      n being Element of NAT
  st IC Comput(ProgramPart(s+*I),s+*I,n) =  0 holds
    Initialize Comput(ProgramPart(s+*I),s+*I,n) +* I =
       Comput(ProgramPart(s+*I),s+*I,n)
proof
  let s be 0-started State of SCMPDS,
      I be Program of SCMPDS,n be Element of NAT;
  set sn=Comput(ProgramPart(s+*I),s+*I,n);
  I c= s +* I by FUNCT_4:26;
  then
A1: I c= sn by AMI_1:81;
  assume IC sn=  0;
  then Initialize sn +* I = sn +* I by COMPOS_1:84;
  hence thesis by A1,FUNCT_4:79;
end;

theorem Th38: ::SCMPDS_5:33
  for I being Program of SCMPDS,J being Program of SCMPDS, k being
  Element of NAT st I is_closed_on s & I is_halting_on s &
   k <= LifeSpan(ProgramPart(Initialize s +* stop I),Initialize s +* stop I)
    holds Comput(ProgramPart(Initialize s +* stop I),Initialize s +*
stop I,k), Comput(ProgramPart(Initialize s +* (I ';' J)),
   Initialize s +* (I ';' J),k)
 equal_outside NAT
proof
  let I be Program of SCMPDS,J be Program of SCMPDS,k be Element of NAT;
  set spI= stop I;
  set s1 = Initialize s +* spI;
  set s2 = Initialize s +* (I ';' J);
  set n=LifeSpan(ProgramPart(s1),s1);
  assume that
A1: I is_closed_on s and
A2: I is_halting_on s;
 assume
A3: k <= n;
  defpred X[Element of NAT] means $1 <= n implies Comput(ProgramPart(s1),s1,$1)
,
  Comput(ProgramPart(s2),s2,$1) equal_outside NAT;
A4: for m being Element of NAT st X[m] holds X[m+1]
  proof
    let m be Element of NAT;
    assume
A5: m <= n implies Comput(ProgramPart(s1),s1,m), Comput(ProgramPart(s2),s2,m)
equal_outside
    NAT;
A6: ProgramPart s1 = ProgramPart Comput(ProgramPart(s1),s1,m)
by AMI_1:123;
A7: Comput(ProgramPart(s1),s1,m+1) =
Following(ProgramPart s1,Comput(ProgramPart(s1),s1,m)
)
 by EXTPRO_1:4
      .= Exec(CurInstr(ProgramPart Comput(ProgramPart(s1),s1,m),Comput(
ProgramPart(s1),s1,m)),
      Comput(ProgramPart(s1),s1,m)) by A6;
A8: IC Comput(ProgramPart(s1),s1,m) in dom spI by A1,SCMPDS_6:def 2;
A9: ProgramPart s2 = ProgramPart Comput(ProgramPart(
s2),s2,m)
by AMI_1:123;
A10: Comput(ProgramPart(s2),s2,m+1) = Following(ProgramPart s2,
Comput(ProgramPart(s2),s2,m)) by EXTPRO_1:4
      .= Exec(CurInstr(ProgramPart Comput(ProgramPart(s2),s2,m),Comput(
ProgramPart(s2),s2,m)),
      Comput(ProgramPart(s2),s2,m)) by A9;
    assume
A11: m+1 <= n;
    then m < n by NAT_1:13;
    then
A12: IC Comput(ProgramPart(s1),s1,m) in dom I by A1,A2,SCMPDS_6:40;
    then
A13: IC Comput(ProgramPart(s1),s1,m) in dom (I ';' J) by FUNCT_4:13;
A14
:  (ProgramPart Comput(ProgramPart(s1),s1,m))/.IC Comput(ProgramPart(s1),s1,m)
 = Comput(ProgramPart(s1),s1,m).IC Comput(ProgramPart(s1),s1,m) by COMPOS_1:38;
A15
:  (ProgramPart Comput(ProgramPart(s2),s2,m))/.IC Comput(ProgramPart(s2),s2,m)
 = Comput(ProgramPart(s2),s2,m).IC Comput(ProgramPart(s2),s2,m) by COMPOS_1:38;
    CurInstr(ProgramPart Comput(ProgramPart(s1),s1,m),Comput(ProgramPart(s1),s1
,m))
     = s1.IC Comput(ProgramPart(s1),s1,m) by A14,AMI_1:54
      .= spI.IC Comput(ProgramPart(s1),s1,m) by A8,FUNCT_4:14
      .= I.IC Comput(ProgramPart(s1),s1,m) by A12,AFINSQ_1:def 4
      .= (I ';' J).IC Comput(ProgramPart(s1),s1,m) by A12,AFINSQ_1:def 4
      .= s2.IC Comput(ProgramPart(s1),s1,m) by A13,FUNCT_4:14
      .= (Comput(ProgramPart(s2),s2,m)).IC Comput(ProgramPart(s1),s1,m) by
AMI_1:54
      .=CurInstr(ProgramPart Comput(ProgramPart(s2),s2,m),Comput(ProgramPart(s2
),s2,m))
       by A5,A11,A15,COMPOS_1:24,NAT_1:13;
    hence thesis by A5,A11,A10,A7,NAT_1:13,SCMPDS_4:15;
  end;
A16: Comput(ProgramPart(s2),s2,0) = s2 by EXTPRO_1:3;
A17: Comput(ProgramPart(s1),s1,0) = s1 by EXTPRO_1:3;
A18: Initialize s, Initialize s +* (I ';' J) equal_outside NAT by FUNCT_7:132;
  Initialize s +* spI, Initialize s equal_outside NAT by FUNCT_7:28,132;
  then
A19: X[0] by A18,A17,A16,FUNCT_7:29;
  for k being Element of NAT holds X[k] from NAT_1:sch 1(A19, A4);
  hence thesis by A3;
end;

theorem Th39: ::SCMPDS_5:29
  for I,J being Program of SCMPDS,k be Element of NAT st I c= J &
I is_closed_on s & I is_halting_on s &
 k <= LifeSpan(ProgramPart(Initialize s +*
stop(I)),Initialize s +* stop(I))
holds Comput(ProgramPart(Initialize s +* J), Initialize s +* J,k),
Comput(ProgramPart(Initialize s +* stop I),
 (Initialize s +* stop(I)),k) equal_outside NAT
proof
  let I,J be Program of SCMPDS,k be Element of NAT;
  set m=LifeSpan(ProgramPart(Initialize s +* stop I),Initialize s +* stop I);
  assume that
A1: I c= J and
A2: I is_closed_on s and
A3: I is_halting_on s and
A4: k <= m;
  set s1 = Initialize s +* J, s2 = Initialize s +* stop I;
A5: s +* Initialize J =  Initialize s +* J by COMPOS_1:125;
A6: s +* Initialize stop I = Initialize s +* stop I by COMPOS_1:125;
  defpred P[Element of NAT] means $1 <= m implies Comput(ProgramPart(s1),s1,$1)
,
  Comput(ProgramPart(s2),s2,$1) equal_outside NAT;
A7: dom I c= dom J by A1,GRFUNC_1:8;
A8: now
    let k be Element of NAT;
    assume
A9: P[k];
    now
A10: ProgramPart s2 = ProgramPart Comput(ProgramPart(s2),s2,k)
by AMI_1:123;
A11:   Comput(ProgramPart(s2),s2,k+1) =
Following(ProgramPart s2,Comput(ProgramPart(s2),s2,k)
)
 by EXTPRO_1:4
        .= Exec(CurInstr(ProgramPart Comput(ProgramPart(s2),s2,k),Comput(
ProgramPart(s2),s2,k)),
        Comput(ProgramPart(s2),s2,k)) by A10;
A12: ProgramPart s1 = ProgramPart Comput(ProgramPart(s1),s1,k)
by AMI_1:123;
A13:   Comput(ProgramPart(s1),s1,k+1) =
Following(ProgramPart s1,Comput(ProgramPart(s1),s1,k)
)
 by EXTPRO_1:4
        .= Exec(CurInstr(ProgramPart Comput(ProgramPart(s1),s1,k),Comput(
ProgramPart(s1),s1,k)),
        Comput(ProgramPart(s1),s1,k)) by A12;
A14:  k < k+1 by XREAL_1:31;
      assume
A15:  k+1 <= m;
      then k < m by A14,XXREAL_0:2;
      then
A16:  IC Comput(ProgramPart(s2),s2,k) in dom I by A2,A3,SCMPDS_6:40;
      then
A17:  IC Comput(ProgramPart(s2),s2,k) in dom (stop I) by FUNCT_4:13;
A18
:  (ProgramPart Comput(ProgramPart(s1),s1,k))/.IC Comput(ProgramPart(s1),s1,k)
 = Comput(ProgramPart(s1),s1,k).IC Comput(ProgramPart(s1),s1,k) by COMPOS_1:38;
A19
:  (ProgramPart Comput(ProgramPart(s2),s2,k))/.IC Comput(ProgramPart(s2),s2,k)
 = Comput(ProgramPart(s2),s2,k).IC Comput(ProgramPart(s2),s2,k) by COMPOS_1:38;
      CurInstr(ProgramPart Comput(ProgramPart(s1),s1,k),Comput(ProgramPart(s1),
s1,k))
       = (Comput(ProgramPart(s1),s1,k)).IC Comput(ProgramPart(s2),s2,
      k) by A9,A15,A14,A18,COMPOS_1:24,XXREAL_0:2
        .= (s +* Initialize J).IC Comput(ProgramPart(s2),s2,k)
        by A5,AMI_1:54
        .= J.IC Comput(ProgramPart(s2),s2,k) by A7,A16,A5,FUNCT_4:14
        .= I.IC Comput(ProgramPart(s2),s2,k) by A1,A16,GRFUNC_1:8
        .= (stop I).IC Comput(ProgramPart(s2),s2,k) by A16,AFINSQ_1:def 4
        .= (s +* Initialize stop I).IC Comput(ProgramPart(s2),s2,k)
        by A17,A6,FUNCT_4:14
        .= CurInstr(ProgramPart Comput(ProgramPart(s2),s2,k),Comput(ProgramPart
(s2),s2,k))
         by A19,A6,AMI_1:54;
      hence
      Comput(ProgramPart(s1),s1,k+1),Comput(ProgramPart(s2),s2,k+1)
equal_outside NAT by A9,A15,A14,A13,A11,SCMPDS_4:15,XXREAL_0:2;
    end;
    hence P[k+1];
  end;
A20: P[0]
  proof
    assume
    0 <= m;
A21: Comput(ProgramPart(s2),s2,0)=Initialize s +* stop I by EXTPRO_1:3;
    Comput(ProgramPart(s1),s1,0)=Initialize s +* J by EXTPRO_1:3;
    hence thesis by A21,FUNCT_7:134;
  end;
  for k be Element of NAT holds P[k] from NAT_1:sch 1(A20,A8);
  hence thesis by A4;
end;

theorem Th40:
  for I,J being Program of SCMPDS,k be Element of NAT st k <=
  LifeSpan(ProgramPart(Initialize s +* stop I),Initialize s +* stop I) & I
c= J & I is_closed_on s & I
  is_halting_on s holds IC Comput(ProgramPart(Initialize s +* J),
  Initialize s +* J,k) in dom stop I
proof
  let I,J be Program of SCMPDS,k be Element of NAT;
  set ss = Initialize s +* stop I;
  set s1= Comput(ProgramPart( (Initialize s +* J)), (Initialize s +* J),k),
s2= Comput(ProgramPart( ss), ss,k);
  assume that
A1: k <= LifeSpan(ProgramPart(ss),ss) and
A2: I c= J and
A3: I is_closed_on s and
A4: I is_halting_on s;
  IC s1 = IC s2 by A1,A2,A3,A4,Th39,COMPOS_1:24;
  hence thesis by A3,SCMPDS_6:def 2;
end;

theorem Th41: ::SCMPDS_5:31
  for I,J being Program of SCMPDS st I c= J & I is_closed_on s & I
is_halting_on s
 holds CurInstr(ProgramPart Comput(ProgramPart(Initialize s +* J),
 Initialize s +* J,LifeSpan(ProgramPart(Initialize s +*
  stop(I)),Initialize s +*
  stop(I))),
  Comput(ProgramPart(Initialize s +* J), Initialize s +* J,LifeSpan(
ProgramPart(Initialize s
+*
  stop(I)),Initialize s
+*
  stop(I))))
   = halt SCMPDS or IC Comput(ProgramPart(Initialize s +* J),
    Initialize s +* J,
  LifeSpan(ProgramPart(Initialize s +* stop(I)),Initialize s +* stop(I))) =
card I
proof
  let I,J be Program of SCMPDS;
  set ss = Initialize s +* stop I, m=LifeSpan(ProgramPart(ss),ss);
A1: Initialize s +* stop I = s +* Initialize stop I by COMPOS_1:125;
  set s0=Initialize s +* J, s1= Comput(ProgramPart( s0), s0,m), s2= Comput(
ProgramPart( ss), ss,m),
  Ik = IC s2;
  assume that
A2: I c= J and
A3: I is_closed_on s and
A4: I is_halting_on s;
A5: dom I c= dom J by A2,GRFUNC_1:8;
  reconsider n = Ik as Element of NAT;
A6: stop I c= Initialize stop I by COMPOS_1:126;
  Initialize stop I c= ss by A1,FUNCT_4:26;
  then
A7: stop I c= ss by A6,XBOOLE_1:1;
A8: ProgramPart ss halts_on ss by A4,SCMPDS_6:def 3;
A9: Ik in dom stop(I) by A3,SCMPDS_6:def 2;
  card stop I = card I + 1 by SCMPDS_5:7;
  then n < card I + 1 by A9,AFINSQ_1:70;
  then
A10: n <= card I by INT_1:20;
A11: IC s1 = Ik by A2,A3,A4,Th39,COMPOS_1:24;
  now
    per cases by A10,XXREAL_0:1;
    case
      n < card I;
      then
A12:   n in dom I by AFINSQ_1:70;
A13:  (ProgramPart s2)/.IC s2
 = s2.IC s2 by COMPOS_1:38;
A14:  (ProgramPart s1)/.IC s1
 = s1.IC s1 by COMPOS_1:38;
A15: ProgramPart s2 = ProgramPart ss
by AMI_1:123;
      thus halt SCMPDS = CurInstr(ProgramPart s2,s2) by A8,A15,EXTPRO_1:def 14
        .= ss.Ik by A13,AMI_1:54
        .= (stop I).Ik by A9,A7,GRFUNC_1:8
        .= I.Ik by A12,AFINSQ_1:def 4
        .= J.Ik by A2,A12,GRFUNC_1:8
        .= s0.IC s1 by A5,A11,A12,FUNCT_4:14
        .=CurInstr(ProgramPart s1,s1) by A14,AMI_1:54;
    end;
    case
      n = card I;
      hence IC s1=  card I by A2,A3,A4,Th39,COMPOS_1:24;
    end;
  end;
  hence thesis;
end;

theorem Th42:
  for I,J being Program of SCMPDS st I is_halting_on s & J
  is_closed_on IExec(I,s) & J is_halting_on IExec(I,s) holds J is_closed_on
Comput(ProgramPart(Initialize s +* stop I), (Initialize s +* stop I),
LifeSpan(ProgramPart(Initialize s +* stop I),Initialize s +* stop I)) & J
  is_halting_on Comput(ProgramPart(Initialize s +* stop I),
    Initialize s +* stop I, LifeSpan(ProgramPart(Initialize s +*
  stop I),Initialize s +* stop I))
proof
  let I,J be Program of SCMPDS;
  set s1= Initialize s +* stop I, sm = Comput(ProgramPart(s1),s1,LifeSpan(
ProgramPart(s1),s1)),
sE =
  IExec(I,s);
  assume that
A1: I is_halting_on s and
A2: J is_closed_on sE and
A3: J is_halting_on sE;
A4: ProgramPart s1 halts_on s1 by A1,SCMPDS_6:def 3;
  dom ProgramPart s = A by COMPOS_1:34;
  then DataPart sE = DataPart Result(ProgramPart(s1),s1) by AMI_2:29,FUNCT_4:76
,SCMPDS_2:100
    .= DataPart sm by A4,EXTPRO_1:23;
  hence thesis by A2,A3,SCMPDS_6:37;
end;

theorem Th43:
  for I being Program of SCMPDS,J being shiftable Program of
SCMPDS st I is_closed_on s & I is_halting_on s & J is_closed_on IExec(I,s) & J
  is_halting_on IExec(I,s) holds (I ';'J) is_closed_on s & (I ';' J)
  is_halting_on s
proof
  let I be Program of SCMPDS,J be shiftable Program of SCMPDS;
  set sE=IExec(I,s);
  assume that
A1: I is_closed_on s and
A2: I is_halting_on s and
A3: J is_closed_on sE and
A4: J is_halting_on sE;
  set IJ =I ';' J, sIJ = stop IJ, spI = stop I,
  ss=Initialize s +* stop IJ;
  set spJ = stop J,
  s1 = Initialize s +* stop I,
  m1 = LifeSpan(ProgramPart(s1),s1), sm
  = Comput(ProgramPart( s1), s1,m1), s3 = Initialize sm +* spJ,
  m3 = LifeSpan(ProgramPart(
s3),s3);
A5: sm +* Initialize spJ = Initialize sm +* spJ by COMPOS_1:125;
A6: dom (DataPart Initialize spJ) = dom Initialize spJ /\ D
by RELAT_1:90,SCMPDS_2:100;
  J is_halting_on sm by A2,A3,A4,Th42;
  then
A7: ProgramPart s3 halts_on s3 by SCMPDS_6:def 3;
A8: J is_closed_on sm by A2,A3,A4,Th42;
  then
A9: J is_closed_on s3 by SCMPDS_6:38;
A10: now
    let x be set;
    assume
    x in dom (DataPart Initialize spJ);
    then
A11: x in dom Initialize spJ /\ D by RELAT_1:90,SCMPDS_2:100;
    then
A12: x in dom Initialize spJ by XBOOLE_0:def 4;
A13: x in D by A11,XBOOLE_0:def 4;
    per cases by A12,COMPOS_1:77;
    suppose
A14:  x in dom spJ;
      reconsider l=x as Element of NAT by A14;
      l=x;
      hence (DataPart Initialize spJ).x =
      (DataPart Comput(ProgramPart(s1),s1,m1)).x by A13,SCMPDS_4:22;
    end;
    suppose
      x = IC SCMPDS;
      hence (DataPart Initialize spJ).x =
      (DataPart Comput(ProgramPart(s1),s1,m1)).x by A11,SCMPDS_3:6
,XBOOLE_0:def 4;
    end;
  end;
  set s4 = Comput(ProgramPart( ss), ss,m1);
A15: DataPart s3 = DataPart Comput(ProgramPart(s1),s1,m1) +*
DataPart Initialize spJ by A5,FUNCT_4:75;
A16: Initialize spJ c= s3 by A5,FUNCT_4:26;
  then dom Initialize spJ c= dom s3 by GRFUNC_1:8;
  then dom Initialize spJ c= the carrier of SCMPDS by PARTFUN1:def 4;
  then dom (DataPart Initialize spJ) c= (the carrier of SCMPDS) /\ D
  by A6,XBOOLE_1:26;
  then dom (DataPart Initialize spJ) c= dom sm /\ D by PARTFUN1:def 4;
  then dom (DataPart Initialize spJ) c= dom (DataPart sm)
  by RELAT_1:90,SCMPDS_2:100;
  then DataPart Initialize spJ c= DataPart sm by A10,GRFUNC_1:8;
  then
A17: DataPart sm = DataPart s3 by A15,LATTICE2:8;
  ss = Initialize s +* (I ';' (J ';' Stop SCMPDS)) by AFINSQ_1:30;
 then s4 = Comput(ProgramPart(Initialize s +* (I ';' (J ';' Stop SCMPDS))),
             Initialize s +* (I ';' (J ';' Stop SCMPDS)),m1);
 then sm, s4 equal_outside NAT
   by A1,A2,Th38;
  then
A18: DataPart s4 = DataPart s3 by A17,COMPOS_1:138;
  sIJ = I ';' (J ';' Stop SCMPDS) by AFINSQ_1:30
    .= I +* Shift(spJ, card I);
  then
A19: Shift(spJ, card I) c= sIJ by FUNCT_4:26;
  sIJ c= ss by FUNCT_4:26;
  then Shift(spJ, card I) c= ss by A19,XBOOLE_1:1;
  then
A20: Shift(spJ, card I) c= s4 by AMI_1:81;
A21: dom stop I c= dom sIJ by SCMPDS_5:16;
  now
    let k be Element of NAT;
A22: ProgramPart ss = ProgramPart s4
by AMI_1:123;
    per cases;
    suppose
      k <= m1;
      then IC Comput(ProgramPart( ss), ss,k) in dom stop I by A1,A2,Th17,Th40;
      hence IC Comput(ProgramPart( ss), ss,k) in dom sIJ by A21;
    end;
    suppose
A23:  k > m1;
A24:  IC s4 in dom spI by A1,A2,Th17,Th40;
      hereby
        per cases by A1,A2,Th17,Th41;
        suppose
A25:      IC s4 =  card I;
          consider ii be Nat such that
A26:      k=m1+ii by A23,NAT_1:10;
          reconsider ii as Element of NAT by ORDINAL1:def 13;
          reconsider nn = IC Comput(ProgramPart( s3), s3,ii) as Element of NAT;
          IC Comput(ProgramPart( s3), s3,ii) + card I = IC Comput(ProgramPart(
s4), s4,ii) by A16,A18,A9,A20,A25,SCMPDS_6:45;
          then
A27:      IC Comput(ProgramPart( s4), ss,k)= nn+card I by A26,A22,EXTPRO_1:5
            .= (nn + card I);
           nn in dom spJ by A8,SCMPDS_6:def 2;
          then nn < card spJ by AFINSQ_1:70;
          then nn < card J+1 by SCMPDS_5:7;
          then
A28:      card I +nn < card I +(card J+1) by XREAL_1:8;
          card sIJ=card IJ+1 by SCMPDS_5:7
            .=card I + card J+1 by AFINSQ_1:20;
          hence IC Comput(ProgramPart( ss), ss,k) in dom sIJ by A28,A27,A22,
AFINSQ_1:70;
        end;
        suppose
          CurInstr(ProgramPart s4,s4) = halt SCMPDS;
          then IC Comput(ProgramPart( ss), ss,k)=IC s4 by A23,A22,EXTPRO_1:6;
          hence IC Comput(ProgramPart( ss), ss,k) in dom sIJ by A21,A24;
        end;
      end;
    end;
  end;
  hence (I ';'J) is_closed_on s by SCMPDS_6:def 2;
A29: ProgramPart ss = ProgramPart Comput(ProgramPart(ss)
,ss,m1)
by AMI_1:123;
A30: ProgramPart s3 = ProgramPart Comput(ProgramPart(s3),s3,m3)
by AMI_1:123;
A31: ProgramPart s4 = ProgramPart Comput(ProgramPart(s4),s4,m3)
by AMI_1:123;
A32: Comput(ProgramPart(ss),ss,m1+m3)
 = Comput(ProgramPart(ss),Comput(ProgramPart(ss),ss,m1),m3) by EXTPRO_1:5;
  per cases by A1,A2,Th17,Th41;
  suppose
    CurInstr(ProgramPart s4,s4) = halt SCMPDS;
    then ProgramPart ss halts_on ss by A29,EXTPRO_1:30;
    hence thesis by SCMPDS_6:def 3;
  end;
  suppose
    IC s4 =  card I;
    then CurInstr(ProgramPart (s3),Comput(ProgramPart(s3),s3,m3)) =
    CurInstr(ProgramPart (s4),Comput(ProgramPart(s4),s4,m3)) by A16,A18,A9,A20
,A30,A31,SCMPDS_6:45;
    then
    CurInstr(ProgramPart (ss),Comput(ProgramPart(ss),ss,m1+m3)) =
    CurInstr(ProgramPart (s3),Comput(ProgramPart(s3),s3,m3)) by A32,A29
      .= halt SCMPDS by A7,EXTPRO_1:def 14;
    then ProgramPart ss halts_on ss by EXTPRO_1:30;
    hence thesis by SCMPDS_6:def 3;
  end;
end;

theorem Th44: :: SCMPDS_5:30
  for I be halt-free Program of SCMPDS,J be Program of SCMPDS st
  I c= J & I is_closed_on s & I is_halting_on s
   holds IC Comput(ProgramPart(Initialize s+*J), Initialize s +*J,
    LifeSpan(ProgramPart(Initialize s +* stop(I)),Initialize s +*
          stop(I))) =  card I
proof
  let I be halt-free Program of SCMPDS,J be Program of SCMPDS;
  set s1 = Initialize s +* J, ss = Initialize s +* stop I, m=LifeSpan(
ProgramPart(ss),ss);
A1: Initialize s +* stop I = s +* Initialize stop I by COMPOS_1:125;
  assume that
A2: I c= J and
A3: I is_closed_on s and
A4: I is_halting_on s;
  thus IC Comput(ProgramPart( s1), s1,m) =IC Comput(ProgramPart( ss), ss,
LifeSpan(ProgramPart(ss),ss)) by A2,A3,A4,Th39,COMPOS_1:24
    .= card I by A3,A4,A1,SCMPDS_6:43;
end;

theorem ::SCMPDS_6:42
  for I being Program of SCMPDS,s being State of SCMPDS, k being Element
  of NAT st I is_halting_on s & k < LifeSpan(ProgramPart(Initialize s +* stop
I),Initialize s +* stop I) holds
  CurInstr(ProgramPart (Initialize s +* stop I),
   Comput(ProgramPart(Initialize s +* stop I),Initialize s +* stop I,k)
)
   <> halt SCMPDS
proof
  let I be Program of SCMPDS,s be State of SCMPDS,k be Element of NAT;
  set ss=Initialize s +* stop(I), m=LifeSpan(ProgramPart(ss),ss);
  assume that
A1: I is_halting_on s and
A2: k < m;
  assume
A3: CurInstr(ProgramPart (ss),Comput(ProgramPart(ss),ss,k))=halt SCMPDS;
  ProgramPart ss halts_on ss by A1,SCMPDS_6:def 3;
  hence thesis by A2,A3,EXTPRO_1:def 14;
end;

theorem Th46: ::SCMPDS_6:42
  for I,J being Program of SCMPDS,s being State of SCMPDS, k being
  Element of NAT st I is_closed_on s & I is_halting_on s & k < LifeSpan(
ProgramPart(Initialize s +* stop I),Initialize s +* stop I) holds
 CurInstr(ProgramPart Comput(ProgramPart(Initialize s +* stop (I ';' J)),
  Initialize s +* stop (I ';' J),k),
  Comput(ProgramPart(Initialize s +* stop (I ';' J)),
    Initialize s +* stop (I ';' J),k))
   <> halt SCMPDS
proof
  let I,J be Program of SCMPDS,s be State of SCMPDS,k be Element of NAT;
  set s1=Initialize s +* stop I, s2=Initialize s +* stop (I ';' J), m=
  LifeSpan(ProgramPart(s1),s1), s3=Comput(ProgramPart(s2),s2,k);
  assume that
A1: I is_closed_on s and
A2: I is_halting_on s and
A3: k < m;
A4: ProgramPart s3 = ProgramPart s2
by AMI_1:123;
  assume
  CurInstr(ProgramPart s3,s3) = halt SCMPDS;
  then
A5: CurInstr(ProgramPart (s1),Comput(ProgramPart(s1),s1,k))
 = halt SCMPDS by A1,A2,A3,A4,SCMPDS_6:41;
  ProgramPart s1 halts_on s1 by A2,SCMPDS_6:def 3;
  hence thesis by A3,A5,EXTPRO_1:def 14;
end;

Lm1: for I being halt-free Program of SCMPDS,J being shiftable Program of
SCMPDS,s,s1,s2 being State of SCMPDS st I is_closed_on s & I is_halting_on s &
J is_closed_on IExec(I,s) & J is_halting_on IExec(I,s) &
s2=Initialize s +* stop (I ';' J) & s1=Initialize s +* stop I
holds IC Comput(ProgramPart(s2),s2,
LifeSpan(ProgramPart(s1),s1)
) =  card I & DataPart Comput(ProgramPart(s2),s2,LifeSpan(ProgramPart(s1),s1))
= DataPart(Initialize Comput
(ProgramPart(s1),s1,LifeSpan(ProgramPart(s1),s1)) +* stop J) &
Shift(stop J,card I)
c= Comput(ProgramPart(
s2),
s2,LifeSpan(ProgramPart(s1),s1)) & LifeSpan(ProgramPart(s2),s2) = LifeSpan(
ProgramPart(s1),s1) +
LifeSpan(ProgramPart(Initialize Result(ProgramPart(s1),s1) +* stop J),
Initialize Result(ProgramPart(s1),s1) +* stop J)

proof

  let I be halt-free Program of SCMPDS,J be shiftable Program of SCMPDS, s,
  s1,s2 be State of SCMPDS;

  set spJ = stop J,
   IJ = I ';' J, sIJ = stop IJ,
  m1 = LifeSpan(ProgramPart(s1),s1), sm =
  Comput(ProgramPart( s1), s1,m1), s3 = Initialize sm +* spJ;
A1: sm +* Initialize spJ = Initialize sm +* spJ by COMPOS_1:125;
  set m3 = LifeSpan(ProgramPart(s3),s3), sE = IExec(I,s);
  assume that
A2: I is_closed_on s and
A3: I is_halting_on s and
A4: J is_closed_on sE and
A5: J is_halting_on sE and
A6: s2=Initialize s +* stop IJ and
A7: s1=Initialize s +* stop I;
A8: s +* Initialize stop IJ = Initialize s +* stop IJ by COMPOS_1:125;

A9: DataPart s3 = DataPart Comput(ProgramPart(s1),s1,m1) +*
DataPart Initialize spJ by A1,FUNCT_4:75;

  set s4 = Comput(ProgramPart( s2), s2,m1);
  thus
A10: IC s4 =  card I by A2,A3,A6,A7,Th17,Th44;
A11: now
    let x be set;
    assume
    x in dom (DataPart Initialize spJ);
    then
A12: x in dom Initialize spJ /\ D by RELAT_1:90,SCMPDS_2:100;
    then
A13: x in dom Initialize spJ by XBOOLE_0:def 4;
A14: x in D by A12,XBOOLE_0:def 4;
    per cases by A13,COMPOS_1:77;
    suppose
A15:  x in dom spJ;
      reconsider l=x as Element of NAT by A15;
      l=x;

      hence (DataPart Initialize spJ).x =
      (DataPart Comput(ProgramPart(s1),s1,m1)).x by A14,SCMPDS_4:22;

    end;
    suppose
      x = IC SCMPDS;

      hence (DataPart Initialize spJ).x =
      (DataPart Comput(ProgramPart(s1),s1,m1)).x by A12,SCMPDS_3:6
,XBOOLE_0:def 4;

    end;
  end;
A16: dom (DataPart Initialize spJ) = dom Initialize spJ /\ D
by RELAT_1:90,SCMPDS_2:100;
A17: Initialize spJ c= s3 by A1,FUNCT_4:26;
  then dom Initialize spJ c= dom s3 by GRFUNC_1:8;
  then dom Initialize spJ c= the carrier of SCMPDS by PARTFUN1:def 4;

  then dom (DataPart Initialize spJ) c= (the carrier of SCMPDS) /\ D
  by A16,XBOOLE_1:26;

  then dom (DataPart Initialize spJ) c=
  dom ( Comput(ProgramPart( s1), s1,m1)) /\ D by PARTFUN1:def 4;

  then dom (DataPart Initialize spJ) c=
  dom DataPart Comput(ProgramPart(s1),s1,m1) by RELAT_1:90,SCMPDS_2:100;

  then DataPart Initialize spJ c= DataPart Comput(ProgramPart(s1),s1,m1)
  by A11,GRFUNC_1:8;
  then
A18: DataPart Comput(ProgramPart(s1),s1,m1) = DataPart s3 by A9,LATTICE2:8;

  s2 = Initialize s +* (I ';' (J ';' Stop SCMPDS)) by A6,AFINSQ_1:30;

 then s4 = Comput(ProgramPart(Initialize s +* (I ';' (J ';' Stop SCMPDS))),
             Initialize s +* (I ';' (J ';' Stop SCMPDS)),m1);
  then Comput(ProgramPart(s1),s1,m1), s4 equal_outside NAT
   by A2,A3,A7,Th38;
  hence
A19: DataPart s4 = DataPart s3
     by A18,COMPOS_1:138;
  reconsider m = m1 + m3 as Element of NAT;
A20: sIJ c= Initialize stop IJ by COMPOS_1:126;
  sIJ = I ';' (J ';' Stop SCMPDS) by AFINSQ_1:30
    .= I +* Shift(spJ, card I);
  then
A21: Shift(spJ, card I) c= sIJ by FUNCT_4:26;
  Initialize stop IJ c= s2 by A6,A8,FUNCT_4:26;
  then sIJ c= s2 by A20,XBOOLE_1:1;
  then Shift(spJ, card I) c= s2 by A21,XBOOLE_1:1;
  hence
A22: Shift(spJ, card I) c= s4 by AMI_1:81;
  J is_halting_on sm by A3,A4,A5,A7,Th42;
  then
A23: ProgramPart s3 halts_on s3 by SCMPDS_6:def 3;
A24: ProgramPart s2 = ProgramPart Comput(ProgramPart(s2)
,s2,m1)
by AMI_1:123;
A25: Comput(ProgramPart(s2),s2,m1+m3)
 = Comput(ProgramPart(s2),Comput(ProgramPart(s2),s2,m1),m3) by EXTPRO_1:5;
A26: ProgramPart s3 = ProgramPart Comput(ProgramPart(s3),s3,m3)
by AMI_1:123;
A27: ProgramPart s4 = ProgramPart Comput(ProgramPart(s4),s4,m3)
by AMI_1:123;
  J is_closed_on sm by A3,A4,A5,A7,Th42;
  then
A28: J is_closed_on s3 by SCMPDS_6:38;

  then CurInstr(ProgramPart (s3),Comput(ProgramPart(s3),s3,m3))
   = CurInstr(ProgramPart (s4),Comput(ProgramPart(s4),s4,m3)) by A17,A10,A19,
A22
,A26,A27,SCMPDS_6:45;

  then CurInstr(ProgramPart (s3),Comput(ProgramPart(s3),s3,m3))
   = CurInstr(ProgramPart (s2),Comput(ProgramPart(s2),s2,m1+m3)) by A25,A24;

  then
A29: CurInstr(ProgramPart (s2),Comput(ProgramPart(s2),s2,m))
 = halt SCMPDS by A23,EXTPRO_1:def 14;
A30: now
    let k be Element of NAT;
    assume
    m1 + k < m;
    then
A31: k < m3 by XREAL_1:8;
    assume
A32: CurInstr(ProgramPart Comput(ProgramPart(s2),s2,m1+k),Comput(ProgramPart(s2
),s2,m1+k))
 = halt SCMPDS;

A33: ProgramPart s2 = ProgramPart Comput(ProgramPart(s2),
s2,m1)
by AMI_1:123;
A34: ProgramPart s3 = ProgramPart Comput(ProgramPart(s3),s3,k)
by AMI_1:123;
A35: ProgramPart s4 = ProgramPart Comput(ProgramPart(s4),s4,k)
by AMI_1:123;
A36: Comput(ProgramPart(s2),s2,m1+k)
 = Comput(ProgramPart(s2),Comput(ProgramPart(s2),s2,m1),k) by EXTPRO_1:5;
    CurInstr(ProgramPart (s3),Comput(ProgramPart(s3),s3,k)) =
    CurInstr(ProgramPart (s4),Comput(ProgramPart(s4),s4,k))
     by A17,A28,A10,A19,A22,A34,A35,SCMPDS_6:45

      .= halt SCMPDS by A32,A36,A33,A35;
    hence contradiction by A23,A31,EXTPRO_1:def 14;
  end;
  now
    let k be Element of NAT;
    assume
A37: k < m;
A38: ProgramPart s2 = ProgramPart Comput(ProgramPart(s2),s2,k)
by AMI_1:123;
    per cases;
    suppose
      k < m1;
      hence CurInstr(ProgramPart (s2),Comput(ProgramPart(s2),s2,k)) <>
       halt SCMPDS by A2,A3,A6,A7,Th46,A38;
    end;
    suppose
      m1 <= k;
      then consider kk being Nat such that
A39:  m1 + kk = k by NAT_1:10;
      reconsider kk as Element of NAT by ORDINAL1:def 13;
      m1+kk=k by A39;
      hence CurInstr(ProgramPart (s2),Comput(ProgramPart(s2),s2,k)) <>
       halt SCMPDS by A30,A37,A38;
    end;
  end;

  then
A40: for k being Element of NAT st
 CurInstr(ProgramPart (s2),Comput(ProgramPart(s2),s2,k)) = halt SCMPDS
  holds m <= k;

A41: ProgramPart s1 halts_on s1 by A3,A7,SCMPDS_6:def 3;
A42: Result(ProgramPart(s1),s1) =
    Comput(ProgramPart s1,s1,LifeSpan(ProgramPart(s1),s1)) by A41,EXTPRO_1:23;
  IJ is_halting_on s by A2,A3,A4,A5,Th43;
  then ProgramPart s2 halts_on s2 by A6,SCMPDS_6:def 3;
  then LifeSpan(ProgramPart(s2),s2) = m by A29,A40,EXTPRO_1:def 14;
  hence thesis by A42;
end;

theorem ::SCMPDS_5:37
  for I being halt-free Program of SCMPDS,J being shiftable Program of
SCMPDS st I is_closed_on s & I is_halting_on s & J is_closed_on IExec(I,s) & J
  is_halting_on IExec(I,s)
holds LifeSpan(ProgramPart(Initialize s +* stop (I
';' J)),Initialize s +* stop (I ';' J)) =
LifeSpan(ProgramPart(Initialize s +* stop I),Initialize s +* stop I) +
LifeSpan(ProgramPart(
   Initialize Result(
    ProgramPart(Initialize s +* stop I),Initialize s +* stop I) +* stop J),
  Initialize Result(ProgramPart(Initialize s +* stop I),
      Initialize s +* stop I) +* stop J) by Lm1;

theorem Th48: :: SCMPDS_5:38
  for I being halt-free Program of SCMPDS, J being shiftable
  Program of SCMPDS st I is_closed_on s & I is_halting_on s & J is_closed_on
IExec(I,s) & J is_halting_on IExec(I,s) holds IExec(I ';' J,s) = IExec(J,IExec(
  I,s)) +* Start-At (IC IExec(J,IExec(I,s)) + card I,SCMPDS)
proof
  let I be halt-free Program of SCMPDS,J be shiftable Program of SCMPDS;
  set ps = s | A,
  IJ = I ';' J, s1 = Initialize s +* stop I,
  m1 = LifeSpan(ProgramPart(s1),s1),
  s2 = Initialize s +* stop IJ,
  s3 = Initialize Comput(ProgramPart(s1),s1,m1) +* stop J,
  m3 = LifeSpan(ProgramPart(s3),s3), sE = IExec(I,s);
A1: Comput(ProgramPart(s1),s1,m1) +* Initialize stop J
 = Initialize Comput(ProgramPart(s1),s1,m1) +* stop J by COMPOS_1:125;
  assume that
A2: I is_closed_on s and
A3: I is_halting_on s and
A4: J is_closed_on sE and
A5: J is_halting_on sE;
A6: DataPart Comput(ProgramPart(s2),s2,m1)
 = DataPart(Initialize Comput(ProgramPart(s1),s1,m1) +* stop J)
  by A2,A3,A4,A5,Lm1;
  J is_closed_on Comput(ProgramPart(s1),s1,m1) by A3,A4,A5,Th42;
  then
A7: J is_closed_on s3 by SCMPDS_6:38;
A8: Initialize stop J c= s3 by A1,FUNCT_4:26;
A9: Shift(stop J,card I) c= Comput(ProgramPart(s2),s2,m1) by A2,A3,A4,A5,Lm1;
A10: IC Comput(ProgramPart(s2),s2,m1) =  card I by A2,A3,A4,A5,Lm1;
  then
A11: IC Comput(ProgramPart( Comput(ProgramPart(s2),s2,m1)), Comput(ProgramPart(
s2),s2,m1),m3) = IC Comput(ProgramPart(s3),s3,m3) + card I
  by A8,A6,A9,A7,SCMPDS_6:45;
A12: DataPart Comput(ProgramPart( Comput(ProgramPart(s2),s2,m1)), Comput(
ProgramPart(s2),s2,m1),m3) = DataPart Comput(ProgramPart(s3),s3,
  m3) by A8,A10,A6,A9,A7,SCMPDS_6:45;
A13: Initialize sE +* stop J = sE +* Initialize stop J by COMPOS_1:125;
A14: Initialize stop J c= Initialize sE +* stop J by A13,FUNCT_4:26;
  set R1=Initialize IExec(I,s) +* stop J,
      R2=Initialize Result(ProgramPart(s1),s1) +* stop J;
A15: IExec(I,s) +* Initialize stop J = Initialize IExec(I,s) +* stop J
        by COMPOS_1:125;
A16: Result(ProgramPart(s1),s1) +* Initialize stop J
 = Initialize Result(ProgramPart(s1),s1) +* stop J
        by COMPOS_1:125;
A17: dom ps = dom s /\ A by RELAT_1:90
    .= ({IC SCMPDS} \/ D \/ A) /\ A by SCMPDS_4:19
    .= A by XBOOLE_1:21;
A18: Initialize stop J c= R2 by A16,FUNCT_4:26;
A19: Initialize stop J c= R1 by A15,FUNCT_4:26;
A20: Comput(ProgramPart(s1),s1,m1) +* Initialize stop J,
Comput(ProgramPart(s1),s1,m1) +* ps
+* Initialize stop J
  equal_outside dom ps by FUNCT_7:31,106;
  then
A21: Comput(ProgramPart(s1),s1,m1) +* ps +* Initialize stop J,
Comput(ProgramPart(s1),s1,m1)
+* Initialize stop J
  equal_outside dom ps by FUNCT_7:28;
A22: ProgramPart s1 halts_on s1 by A3,SCMPDS_6:def 3;
  then
A23: s3 = Initialize Result(ProgramPart(s1),s1) +* stop J by EXTPRO_1:23;
A24: DataPart sE = DataPart(Initialize sE +* stop J)
 by SCMPDS_6:9;
  then
A25: J is_closed_on Initialize sE +* stop J by A4,A5,SCMPDS_6:37;
A26: J is_halting_on Initialize sE +* stop J by A4,A5,A24,SCMPDS_6:37;
  Result(ProgramPart(s1),s1) = Comput(ProgramPart(s1),s1,m1) by A22,EXTPRO_1:23
;
  then Result(ProgramPart(s1),s1) +* ps +* Initialize stop J,
  Result(ProgramPart(s1),s1) +*
Initialize stop J equal_outside A by A17,A20,FUNCT_7:28;
  then
A27: IC Result(ProgramPart(Initialize Result(ProgramPart s1, s1) +* stop J),
Initialize Result(ProgramPart s1,s1) +* stop J) = IC Result(
ProgramPart(Initialize IExec(I,s) +* stop J),
 Initialize IExec(I,s) +* stop J)
 by A25,A26,A19,A18,Th28,A15,A16,COMPOS_1:24;
A28: Initialize stop J c= s3 by A1,FUNCT_4:26;
A29: IExec(I,s) | A = ps by PBOOLE:157;
  IJ is_halting_on s by A2,A3,A4,A5,Th43;
  then
A30: ProgramPart s2 halts_on s2 by SCMPDS_6:def 3;
  J is_halting_on Comput(ProgramPart(s1),s1,m1) by A3,A4,A5,Th42;
  then
A31: ProgramPart s3 halts_on s3 by SCMPDS_6:def 3;
  IExec(I,s) = Comput(ProgramPart(s1),s1,m1) +* ps by A22,EXTPRO_1:23;
  then Result(ProgramPart(Initialize IExec(I,s) +* stop J),
  Initialize IExec(I,s) +* stop J), Result(
ProgramPart(s3),s3) equal_outside A
 by A25,A26,A17,A21,A14,A28,Th28,A1,A15;
  then Result(ProgramPart(Initialize IExec(I,s) +* stop J),
  Initialize IExec(I,s) +* stop J) +* ps = Result(
ProgramPart(s3),s3) +* ps by A17,FUNCT_7:108;
  then
A32: IExec(J,IExec(I,s)) = Comput(ProgramPart(s3),s3,m3) +* ps by A31,A29,
EXTPRO_1:23;
A33: ProgramPart s2 = ProgramPart Comput(ProgramPart(s2),s2,m1)
by AMI_1:123;
A34: Result(ProgramPart(s1),s1) =
    Comput(ProgramPart s1,s1,LifeSpan(ProgramPart(s1),s1)) by A22,EXTPRO_1:23;
A35: IC IExec(I ';' J,s) = IC Result(ProgramPart(Initialize s +* stop IJ),
Initialize s +* stop IJ) by SCMPDS_5:22
    .= IC Comput(ProgramPart(s2),s2,LifeSpan(ProgramPart(s2),s2)) by A30,
EXTPRO_1:23
    .= IC Comput(ProgramPart(s2),s2,m1+m3) by A2,A3,A4,A5,A23,Lm1
    .= IC Comput(ProgramPart(s3),s3,m3) + card I by A11,A33,EXTPRO_1:5
    .= IC Result(ProgramPart(s3),s3) + card I by A31,EXTPRO_1:23
    .= IC Result(ProgramPart(Initialize Result(ProgramPart s1,s1) +* stop J),
    Initialize Result(ProgramPart s1,s1) +* stop J) + card I by A34
    .= IC IExec(J,IExec(I,s)) + card I by A27,SCMPDS_5:22;
  IExec(I ';' J,s) = Comput(ProgramPart(s2),s2,LifeSpan(ProgramPart(s2),s2)) +*
ps by A30,EXTPRO_1:23

    .= Comput(ProgramPart(s2),s2,m1+m3) +* ps by A2,A3,A4,A5,A23,Lm1;
  then
A36: DataPart IExec(I ';' J,s) = DataPart Comput(ProgramPart(s2),s2,m1+m3) by
A17,AMI_2:29,FUNCT_4:76,SCMPDS_2:100
    .= DataPart Comput(ProgramPart(s3),s3,m3) by A12,A33,EXTPRO_1:5
    .= DataPart IExec(J,IExec(I,s)) by A17,A32,AMI_2:29,FUNCT_4:76,SCMPDS_2:100
;
  hereby
    reconsider l = IC IExec(J,IExec(I,s)) + card I as Element of NAT;
A37: dom Start-At(l,SCMPDS) = {IC SCMPDS} by FUNCOP_1:19;
A38: now
      let x be set;
      assume
A39:  x in dom IExec(I ';' J,s);
      per cases by A39,SCMPDS_4:20;
      suppose
A40:    x is Int_position;
        then x <> IC SCMPDS by SCMPDS_2:52;
        then
A41:    not x in dom Start-At(l,SCMPDS) by A37,TARSKI:def 1;
        IExec(I ';' J,s).x = IExec(J,IExec(I,s)).x by A36,A40,SCMPDS_4:23;
        hence
        IExec(I ';' J,s).x = (IExec(J,IExec(I,s)) +* Start-At (IC IExec(J
        ,IExec(I,s)) + card I,SCMPDS)).x by A41,FUNCT_4:12;
      end;
      suppose
A42:    x = IC SCMPDS;
        then x in {IC SCMPDS} by TARSKI:def 1;
        then
A43:    x in dom Start-At(l,SCMPDS) by FUNCOP_1:19;
        thus IExec(I ';' J,s).x = (Start-At(l,SCMPDS)).IC SCMPDS
        by A35,A42,FUNCOP_1:87
          .= (IExec(J,IExec(I,s)) +* Start-At (IC IExec(J,IExec(I,s)) + card
        I,SCMPDS)).x by A42,A43,FUNCT_4:14;
      end;
      suppose
A44:    x is Element of NAT;
        then x <> IC SCMPDS by COMPOS_1:3;
        then
A45:    not x in dom Start-At(l,SCMPDS) by A37,TARSKI:def 1;
        IExec(I ';' J,s) | A = ps by PBOOLE:157
          .= IExec(J,IExec(I,s)) | A by A29,PBOOLE:157;
        then IExec(I ';' J,s).x = IExec(J,IExec(I,s)).x by A44,COMPOS_1:127;
        hence
        IExec(I ';' J,s).x = (IExec(J,IExec(I,s)) +* Start-At (IC IExec(J
        ,IExec(I,s)) + card I,SCMPDS)).x by A45,FUNCT_4:12;
      end;
    end;
    dom IExec(I ';' J,s) = the carrier of SCMPDS by PARTFUN1:def 4
      .= dom (IExec(J,IExec(I,s)) +* Start-At (IC IExec(J,IExec(I,s)) + card
    I,SCMPDS)) by PARTFUN1:def 4;
    hence thesis by A38,FUNCT_1:9;
  end;
end;

theorem Th49: ::SCMPDS_5:39
  for I being halt-free Program of SCMPDS, J being shiftable
  Program of SCMPDS st I is_closed_on s & I is_halting_on s & J is_closed_on
  IExec(I,s) & J is_halting_on IExec(I,s) holds IExec(I ';' J, s).a = IExec(J,
  IExec(I,s)).a
proof
  let I be halt-free Program of SCMPDS,J be shiftable Program of SCMPDS;
  assume that
A1: I is_closed_on s and
A2: I is_halting_on s and
A3: J is_closed_on IExec(I,s) and
A4: J is_halting_on IExec(I,s);
A5: not a in dom Start-At (IC IExec(J,IExec(I,s)) + card I,SCMPDS)
by SCMPDS_4:59;
  IExec(I ';' J,s) = IExec(J,IExec(I,s)) +* Start-At (IC IExec(J,IExec(I,s
  )) + card I,SCMPDS) by A1,A2,A3,A4,Th48;
  hence thesis by A5,FUNCT_4:12;
end;

theorem Th50: ::SCMPDS_5:46
  for I being halt-free Program of SCMPDS,j being parahalting
  shiftable Instruction of SCMPDS st I is_closed_on s & I is_halting_on s holds
  IExec(I ';' j, s).a = Exec(j, IExec(I, s)).a
proof
  let I be halt-free Program of SCMPDS,j be parahalting shiftable
  Instruction of SCMPDS;
  assume that
A1: I is_closed_on s and
A2: I is_halting_on s;
  set Mj = Load j;
A3: a in SCM-Data-Loc by SCMPDS_2:def 2;
  for a holds (Initialize IExec(I,s)).a=IExec(I, s).a by SCMPDS_5:40;
  then
A4: DataPart Initialize IExec(I,s) = DataPart IExec(I, s) by SCMPDS_4:23;
A5: Mj is_halting_on IExec(I,s) by SCMPDS_6:35;
  Mj is_closed_on IExec(I,s) by SCMPDS_6:34;
  hence IExec(I ';' j, s).a = IExec(Mj,IExec(I,s)).a by A1,A2,A5,Th49
    .= Exec(j, Initialize IExec(I,s)).a by SCMPDS_5:45
    .= (DataPart Exec(j, Initialize IExec(I,s))).a by A3,FUNCT_1:72
,SCMPDS_2:100
    .= (DataPart Exec(j, IExec(I, s))).a by A4,SCMPDS_5:44
    .= Exec(j, IExec(I, s)).a by A3,FUNCT_1:72,SCMPDS_2:100;
end;

begin :: The construction of for-up loop program

:: while (a,i)<=0 do { I, (a,i)+=n }

definition
  let a be Int_position, i be Integer,n be Element of NAT;
  let I be Program of SCMPDS;
  func for-up(a,i,n,I) -> Program of SCMPDS equals
  (a,i)>=0_goto (card I +3)
  ';' I ';' AddTo(a,i,n) ';' goto -(card I+2);
  coherence;
end;

begin :: The computation of for-up loop program

theorem Th51:
  for a be Int_position,i be Integer,n be Element of NAT,I be
  Program of SCMPDS holds card for-up(a,i,n,I)= card I +3
proof
  let a be Int_position,i be Integer,n be Element of NAT, I be Program of
  SCMPDS;
  set i1=(a,i)>=0_goto (card I +3), i2=AddTo(a,i,n);
  set I4=i1 ';' I, I5=I4 ';' i2;
  card I4=card I+1 by SCMPDS_6:15;
  then card I5=card I +1 +1 by SCMP_GCD:8
    .=card I+ (1+1);
  hence card for-up(a,i,n,I)=card I +2 +1 by SCMP_GCD:8
    .=card I + 3;
end;

Lm2: for a be Int_position,i be Integer,n be Element of NAT, I be Program of
SCMPDS holds card stop for-up(a,i,n,I)= card I+4

proof

  let a be Int_position,i be Integer,n be Element of NAT, I be Program of
  SCMPDS;

  thus card stop for-up(a,i,n,I)= card for-up(a,i,n,I) +1 by SCMPDS_5:7
    .= card I +3+1 by Th51
    .= card I + 4;
end;

theorem Th52:
  for a be Int_position,i be Integer,n,m be Element of NAT, I be
  Program of SCMPDS holds m < card I+3 iff  m in dom for-up(a,i,n,I)
proof
  let a be Int_position,i be Integer,n,m be Element of NAT, I be Program of
  SCMPDS;
  card for-up(a,i,n,I)=card I + 3 by Th51;
  hence thesis by AFINSQ_1:70;
end;

theorem Th53:
  for a be Int_position,i be Integer,n be Element of NAT, I be
  Program of SCMPDS holds for-up(a,i,n,I). 0=(a,i)>=0_goto (card I +3) &
for-up(a,i,n,I). (card I+1)=AddTo(a,i,n) & for-up(a,i,n,I). (card I
  +2)=goto -(card I+2)
proof
  let a be Int_position,i be Integer,n be Element of NAT, I be Program of
  SCMPDS;
  set i1=(a,i)>=0_goto (card I +3), i2=AddTo(a,i,n), i3=goto -(card I+2);
  set I4=i1 ';' I, I5=I4 ';' i2;
  set J6=i2 ';' i3, J5=I ';' J6;
  set FLOOP=for-up(a,i,n,I);
  FLOOP=I4 ';' J6 by SCMPDS_4:49;
  then FLOOP=i1 ';' J5 by SCMPDS_4:50;
  hence FLOOP. 0=i1 by SCMPDS_6:16;
A1: card I4=card I+1 by SCMPDS_6:15;
  hence FLOOP.(card I+1)=i2 by SCMP_GCD:11;
  card I5=card I +1 +1 by A1,SCMP_GCD:8
    .=card I+ (1+1);
  hence thesis by SCMP_GCD:10;
end;

theorem Th54:
  for s being State of SCMPDS,I being Program of SCMPDS,a being
  Int_position, i being Integer,n be Element of NAT st s.DataLoc(s.a,i) >= 0
  holds for-up(a,i,n,I) is_closed_on s & for-up(a,i,n,I) is_halting_on s
proof
  let s be State of SCMPDS,I be Program of SCMPDS,a be Int_position, i be
  Integer,n be Element of NAT;
  set d1=DataLoc(s.a,i);
  assume
A1: s.d1 >= 0;
  set i1=(a,i)>=0_goto (card I+3), i2=AddTo(a,i,n), i3=goto -(card I+2);
  set FOR=for-up(a,i,n,I), pFOR=stop FOR, s3 = Initialize s +* pFOR,
  s4 = Comput(ProgramPart(s3),s3,1);
A2: s +* Initialize pFOR = Initialize s +* pFOR by COMPOS_1:125;
A3: IC s3 = 0 by SCMPDS_6:21;
A4: not d1 in dom Initialize pFOR by SCMPDS_4:31;
  not a in dom Initialize pFOR by SCMPDS_4:31;
  then
A5: s3.DataLoc(s3.a,i)=s3.d1 by A2,FUNCT_4:12
    .= s.d1 by A4,A2,FUNCT_4:12;
A6: FOR = i1 ';' (I ';' i2 ';' i3) by Th15;
  Comput(ProgramPart( s3), s3,(0 qua Nat)+1) = Following(ProgramPart s3,
  Comput(ProgramPart(s3),s3,0)) by EXTPRO_1:4
    .= Following(ProgramPart s3,s3) by EXTPRO_1:3
    .= Exec(i1,s3) by A6,A2,SCMPDS_6:22;
  then
A7: IC s4 = ICplusConst(s3,(card I+3)) by A1,A5,SCMPDS_2:69
    .= ((0 qua Nat)+(card I+3)) by A3,SCMPDS_6:23;
A8: card FOR=card I+3 by Th51;
  then
A9: (card I+3) in dom pFOR by SCMPDS_6:25;
A10:  (ProgramPart s4)/.IC s4
 = s4.IC s4 by COMPOS_1:38;
  Initialize pFOR c= s3 by A2,FUNCT_4:26;
  then pFOR c= s4 by AMI_1:81,COMPOS_1:132;
  then s4.(card I+3) = pFOR.(card I+3) by A9,GRFUNC_1:8
    .=halt SCMPDS by A8,SCMPDS_6:25;
  then
A11: CurInstr(ProgramPart s4,s4) = halt SCMPDS by A7,A10;
A12: ProgramPart s3 = ProgramPart s4
by AMI_1:123;
  now
    let k be Element of NAT;
    per cases;
    suppose
      0 < k;
      then 1+(0 qua Nat) <= k by INT_1:20;
      hence IC Comput(ProgramPart(s3),s3,k) in dom pFOR
      by A9,A7,A11,A12,EXTPRO_1:6;
    end;
    suppose
      k = 0;
      then Comput(ProgramPart(s3),s3,k) = s3 by EXTPRO_1:3;
      hence IC Comput(ProgramPart(s3),s3,k) in dom pFOR by A3,COMPOS_1:135;
    end;
  end;
  hence FOR is_closed_on s by SCMPDS_6:def 2;
  ProgramPart s3 halts_on s3 by A11,A12,EXTPRO_1:30;
  hence thesis by SCMPDS_6:def 3;
end;

theorem Th55:
  for s being State of SCMPDS,I being Program of SCMPDS,a,c being
  Int_position, i being Integer,n be Element of NAT st s.DataLoc(s.a,i) >= 0
  holds IExec(for-up(a,i,n,I),s) = s +* Start-At((card I+3),SCMPDS)
proof
  let s be State of SCMPDS,I be Program of SCMPDS, a,c be Int_position, i be
  Integer,n be Element of NAT;
  set d1=DataLoc(s.a,i);
  set FOR=for-up(a,i,n,I), pFOR=stop FOR,
  s3 = Initialize s +* pFOR, s4 = Comput(ProgramPart( s3), s3,1),
i1=(a,i)>=0_goto (card I+3), i2=
AddTo(a,i,n), i3
  =goto -(card I+2);
A1: s +* Initialize pFOR = Initialize s +* pFOR by COMPOS_1:125;
  set SAl=Start-At((card I+3),SCMPDS);
A2: IC s3 = 0 by SCMPDS_6:21;
A3: not d1 in dom Initialize pFOR by SCMPDS_4:31;
  Initialize pFOR c= s3 by A1,FUNCT_4:26;
  then
A4: pFOR c= s4 by AMI_1:81,COMPOS_1:132;
  not a in dom Initialize pFOR by SCMPDS_4:31;
  then
A5: s3.DataLoc(s3.a,i)=s3.d1 by A1,FUNCT_4:12
    .= s.d1 by A3,A1,FUNCT_4:12;
A6: FOR = i1 ';' (I ';' i2 ';' i3) by Th15;
A7: Comput(ProgramPart( s3), s3,(0 qua Nat)+1) = Following(ProgramPart s3,
Comput(ProgramPart(s3),s3,0)) by EXTPRO_1:4
    .= Following(ProgramPart s3,s3) by EXTPRO_1:3
    .= Exec(i1,s3) by A6,A1,SCMPDS_6:22;
  assume
  s.d1 >= 0;
  then
A8: IC s4 = ICplusConst(s3,(card I+3)) by A7,A5,SCMPDS_2:69
    .= ((0 qua Nat)+(card I+3)) by A2,SCMPDS_6:23;
A9:  (ProgramPart s4)/.IC s4
 = s4.IC s4 by COMPOS_1:38;
A10: ProgramPart s3 = ProgramPart s4
by AMI_1:123;
A11: card FOR=card I+3 by Th51;
  then (card I+3) in dom pFOR by SCMPDS_6:25;
  then s4.(card I+3) = pFOR.(card I+3) by A4,GRFUNC_1:8
    .=halt SCMPDS by A11,SCMPDS_6:25;
  then
A12: CurInstr(ProgramPart s4,s4) = halt SCMPDS by A8,A9;
  then
A13: ProgramPart s3 halts_on s3 by A10,EXTPRO_1:30;
A14: CurInstr(ProgramPart s3,s3) = i1 by A6,A1,SCMPDS_6:22;
A15: ProgramPart s3 = ProgramPart s4
by AMI_1:123;
  now
    let l be Element of NAT;
A16: Comput(ProgramPart(s3),s3,0) = s3 by EXTPRO_1:3;
    assume
    l < (0 qua Nat)+1;
    then l=0 by NAT_1:13;
    then CurInstr(ProgramPart (s3),Comput(ProgramPart(s3),s3,l)) =
    CurInstr(ProgramPart s3,s3) by A16;
    hence CurInstr(ProgramPart (s3),Comput(ProgramPart(s3),s3,l))
     <> halt SCMPDS by A14,SCMPDS_6:31;
  end;
  then for l be Element of NAT st
   CurInstr(ProgramPart (s3),Comput(ProgramPart(s3),s3,l)) = halt SCMPDS
  holds 1 <= l;
  then LifeSpan(ProgramPart(s3),s3) = 1 by A12,A13,A15,EXTPRO_1:def 14;
  then
A17: s4 = Result(ProgramPart(s3),s3) by A13,EXTPRO_1:23;
A18: dom ProgramPart s = A by COMPOS_1:34;
A19: now
    let x be set;
A20: dom SAl = {IC SCMPDS} by FUNCOP_1:19;
    assume
A21: x in dom IExec(FOR,s);
    per cases by A21,SCMPDS_4:20;
    suppose
A22:  x is Int_position;
      then x <> IC SCMPDS by SCMPDS_2:52;
      then
A23:  not x in dom SAl by A20,TARSKI:def 1;
      not x in dom (s | A) by A18,A22,SCMPDS_2:53;
      hence IExec(FOR,s).x = s4.x by A17,FUNCT_4:12
        .= s3.x by A7,A22,SCMPDS_2:69
        .= s.x by A22,SCMPDS_5:19
        .= (s +* SAl).x by A23,FUNCT_4:12;
    end;
    suppose
A24:  x = IC SCMPDS;
      not x in dom (s | A) by A18,A24,COMPOS_1:3;
      hence IExec(FOR,s).x = (card I + 3) by A8,A17,A24,FUNCT_4:12
        .= (s +* SAl).x by A24,FUNCT_4:121;
    end;
    suppose
      x is Element of NAT;
      hence IExec(FOR,s).x = (s +* SAl).x by SCMPDS_6:27;
    end;
  end;
  dom IExec(FOR,s) = the carrier of SCMPDS by PARTFUN1:def 4
    .= dom (s +* SAl) by PARTFUN1:def 4;
  hence thesis by A19,FUNCT_1:9;
end;

theorem
  for s being State of SCMPDS,I being Program of SCMPDS,a being
  Int_position, i being Integer,n be Element of NAT st s.DataLoc(s.a,i) >= 0
  holds IC IExec(for-up(a,i,n,I),s) =  (card I + 3)
proof
  let s be State of SCMPDS,I be Program of SCMPDS,a be Int_position, i be
  Integer,n be Element of NAT;
  assume
  s.DataLoc(s.a,i) >= 0;
  then IExec(for-up(a,i,n,I),s) =s +* Start-At((card I+3),SCMPDS)
  by Th55;
  hence thesis by FUNCT_4:121;
end;

theorem
  for s being State of SCMPDS,I being Program of SCMPDS,a,b being
  Int_position, i being Integer,n be Element of NAT st s.DataLoc(s.a,i) >= 0
  holds IExec(for-up(a,i,n,I),s).b = s.b
proof
  let s be State of SCMPDS,I be Program of SCMPDS,a,b be Int_position, i be
  Integer,n be Element of NAT;
  assume
  s.DataLoc(s.a,i) >= 0;
  then
A1: IExec(for-up(a,i,n,I),s) = s +* Start-At((card I+3),SCMPDS) by Th55;
  not b in dom Start-At((card I+3),SCMPDS) by SCMPDS_4:59;
  hence thesis by A1,FUNCT_4:12;
end;

Lm3: for I being Program of SCMPDS,a being Int_position,i being Integer, n be
Element of NAT holds Shift(I,1) c= for-up(a,i,n,I)

proof

  let I be Program of SCMPDS,a be Int_position,i be Integer, n be Element of
  NAT;

  set i1=(a,i)>=0_goto (card I+3), i2=AddTo(a,i,n), i3=goto -(card I+2);
A1: for-up(a,i,n,I) = Load i1 ';' I ';' (i2 ';' i3) by SCMPDS_4:49;
  card Load i1=1 by SCMPDS_5:6;
  hence thesis by A1,Th16;
end;

theorem Th58:
  for s being State of SCMPDS,I being halt-free shiftable
Program of SCMPDS, a be Int_position, i be Integer,n be Element of NAT,X be set
  st s.DataLoc(s.a,i) < 0 & not DataLoc(s.a,i) in X & n > 0 & card I > 0 & a <>
DataLoc(s.a,i) & (for t be State of SCMPDS st (for x be Int_position st x in X
holds t.x=s.x) & t.a=s.a holds IExec(I,t).a=t.a & IExec(I,t).DataLoc(s.a,i)=t.
  DataLoc(s.a,i) & I is_closed_on t & I is_halting_on t & for y be Int_position
st y in X holds IExec(I,t).y=t.y) holds for-up(a,i,n,I) is_closed_on s & for-up
  (a,i,n,I) is_halting_on s
proof
  let s be State of SCMPDS,I be halt-free shiftable Program of SCMPDS, a be
  Int_position, i be Integer,n be Element of NAT,X be set;
  set b=DataLoc(s.a,i);
  set FOR=for-up(a,i,n,I), pFOR=stop FOR,
  pI=stop I;
  set i1=(a,i)>=0_goto (card I+3), i2=AddTo(a,i,n), i3=goto -(card I+2);
  assume
A1: s.b < 0;
  defpred P[Element of NAT] means for t be State of SCMPDS st -t.b <= $1 & (
for x be Int_position st x in X holds t.x=s.x) & t.a=s.a holds FOR is_closed_on
  t & FOR is_halting_on t;
  assume
A2: not b in X;
  assume
A3: n > 0;
  assume
A4: card I > 0;
  assume
A5: a <> b;
  assume
A6: for t be State of SCMPDS st (for x be Int_position st x in X holds t
.x=s.x) & t.a=s.a holds IExec(I,t).a=t.a & IExec(I,t).b=t.b & I is_closed_on t
  & I is_halting_on t & for y be Int_position st y in X holds IExec(I,t).y=t.y;
A7: for k be Element of NAT st P[k] holds P[k + 1]
  proof
    let k be Element of NAT;
    assume
A8: P[k];
    now
      let t be State of SCMPDS;
      assume
A9:   -t.b <= k+1;
      assume
A10:  for x be Int_position st x in X holds t.x=s.x;
      assume
A11:  t.a=s.a;
      per cases;
      suppose
        t.b >= 0;
        hence FOR is_closed_on t & FOR is_halting_on t by A11,Th54;
      end;
      suppose
A12:    t.b < 0;
        set t2 = Initialize t +* stop I, t3 = Initialize t +* pFOR,
        t4 = Comput(ProgramPart(t3),t3,1);
A13:     t +* Initialize stop I = Initialize t +* stop I by COMPOS_1:125;
A14:     t +* Initialize pFOR = Initialize t +* pFOR by COMPOS_1:125;
A15:    Initialize stop I c= t2 by A13,FUNCT_4:26;
A16:    dom ProgramPart t = A by COMPOS_1:34;
A17: not a in dom (t | A) by A16,SCMPDS_2:53;
A18:    FOR = i1 ';' (I ';' i2 ';' i3) by Th15;
A19:    Comput(ProgramPart( t3), t3,(0 qua Nat)+1) = Following(ProgramPart t3,
Comput(ProgramPart(t3),t3,0)) by EXTPRO_1:4
          .= Following(ProgramPart t3,t3) by EXTPRO_1:3
          .= Exec(i1,t3) by A18,A14,SCMPDS_6:22;
A20:    DataPart t2 = DataPart t3 by COMPOS_1:138,FUNCT_7:134;
        now
          let a;
          thus t2.a = t3.a by A20,SCMPDS_4:23
            .= t4.a by A19,SCMPDS_2:69;
        end;
        then
A21:    DataPart t2 = DataPart t4 by SCMPDS_4:23;
A22:  not b in dom (t | A) by A16,SCMPDS_2:53;
A23:    IExec(I,t).b=t.b by A6,A10,A11;
        -(-n) > 0 by A3;
        then -n < 0;
        then -n <= -1 by INT_1:21;
        then
A24:    -n-t.b <= -1-t.b by XREAL_1:11;
        -t.b-1 <= k by A9,XREAL_1:22;
        then
A25:    -n-t.b <= k by A24,XXREAL_0:2;
A26:    I is_closed_on t by A6,A10,A11;
        then
A27:    I is_closed_on t2 by SCMPDS_6:38;
A28:    not b in dom Initialize pFOR by SCMPDS_4:31;
        set m2=LifeSpan(ProgramPart(t2),t2), t5= Comput(ProgramPart( t4), t4,m2
), l1= (card I +
1);
A29:    IC t3 = 0 by SCMPDS_6:21;
        set m3=m2 +1;
        set t6= Comput(ProgramPart( t3), t3,m3);
        card I + 1 < card I + 3 by XREAL_1:8;
        then
A30:    l1 in dom FOR by Th52;
        set m5=m3+1+1, t8= Comput(ProgramPart( t3), t3,m5);
        set t7= Comput(ProgramPart( t3), t3,m3+1);
A31:    IExec(I,t).a=t.a by A6,A10,A11;
        set l2=(card I+2);
A32:     0 in dom pFOR by COMPOS_1:135;
        card I + 2 < card I + 3 by XREAL_1:8;
        then
A33:    l2 in dom FOR by Th52;
A34:    Initialize pFOR c= t3 by A14,FUNCT_4:26;
        FOR c= Initialize pFOR by SCMPDS_6:17;
        then
A35:    FOR c= t3 by A34,XBOOLE_1:1;
        Shift(I,1) c= FOR by Lm3;
        then Shift(I,1) c= t3 by A35,XBOOLE_1:1;
        then
A36:    Shift(I,1) c= t4 by AMI_1:81;
        I is_halting_on t by A6,A10,A11;
        then
A37:    ProgramPart t2 halts_on t2 by SCMPDS_6:def 3;
A38:     Initialize t2+*stop I = t2+*Initialize stop I by COMPOS_1:125;
        t2 = Initialize t2+*stop I by A15,A38,FUNCT_4:79;
        then ProgramPart(Initialize t2+*stop I) halts_on
        Initialize t2+*stop I by A37;
        then
A39:    I is_halting_on t2 by SCMPDS_6:def 3;
        not a in dom Initialize pFOR by SCMPDS_4:31;
        then t3.DataLoc(t3.a,i)= t3.b by A11,A14,FUNCT_4:12
          .= t.b by A28,A14,FUNCT_4:12;
        then
A40:    IC t4 = succ IC t3 by A12,A19,SCMPDS_2:69
          .= ((0 qua Nat)+1) by A29;
        then
A41:    IC t5=l1 by A4,A15,A39,A27,A21,A36,Th36;
A42:  (ProgramPart t6)/.IC t6
 = t6.IC t6 by COMPOS_1:38;
 ProgramPart t3 = ProgramPart t4
by AMI_1:123;
 then
A43:    t6=t5 by EXTPRO_1:5;
        then
A44:    CurInstr(ProgramPart t6,t6)=t5.l1 by A4,A15,A39,A27,A40,A21,A36,Th36,
A42
          .=t4.l1 by AMI_1:54
          .=t3.l1 by AMI_1:54
          .=FOR.l1 by A30,A35,GRFUNC_1:8
          .=i2 by Th53;
A45:  (ProgramPart t7)/.IC t7
 = t7.IC t7 by COMPOS_1:38;
A46: ProgramPart t3 = ProgramPart t6
by AMI_1:123;
A47:    t7 = Following(ProgramPart t3,t6) by EXTPRO_1:4
          .= Exec(i2,t6) by A44,A46;
        then
A48:    IC t7=succ IC t6 by SCMPDS_2:60
          .=(card I+1+1) by A41,A43,NAT_1:39
          .=(card I+(1+1));
        then
A49:    CurInstr(ProgramPart t7,t7)=t3.l2 by A45,AMI_1:54
          .=FOR.l2 by A35,A33,GRFUNC_1:8
          .=i3 by Th53;
A50: ProgramPart t3 = ProgramPart t7
by AMI_1:123;
A51:    t8 = Following(ProgramPart t3,t7) by EXTPRO_1:4
          .= Exec(i3,t7) by A49,A50;
        then IC t8=ICplusConst(t7,(0 qua Nat)-(card I+2)) by SCMPDS_2:66
          .= 0 by A48,Th1;
        then
A52:    Initialize t8 +* pFOR=t8 by Th37;
A53: ProgramPart t3 = ProgramPart t4
by AMI_1:123;
A54:    DataPart Comput(ProgramPart( t2), t2,m2) = DataPart t5 by A4,A15,A39
,A27,A40,A21,A36,Th36;
        then
A55:    t5.a= Comput(ProgramPart( t2), t2,m2).a by SCMPDS_4:23
          .=(Result(ProgramPart(t2),t2)).a by A37,EXTPRO_1:23
          .=s.a by A11,A31,A17,FUNCT_4:12;
        then DataLoc(t6.a,i)=b by A53,EXTPRO_1:5;
        then t7.a=t6.a by A5,A47,SCMPDS_2:60
          .=s.a by A55,A53,EXTPRO_1:5;
        then
A56:    t8.a=s.a by A51,SCMPDS_2:66;
A57:    now
          let x be Int_position;
          assume
A58:      x in X;
A59: not x in dom (t | A) by A16,SCMPDS_2:53;
          t5.x= Comput(ProgramPart( t2), t2,m2).x by A54,SCMPDS_4:23
            .=(Result(ProgramPart(t2),t2)).x by A37,EXTPRO_1:23
            .=IExec(I,t).x by A59,FUNCT_4:12
            .=t.x by A6,A10,A11,A58
            .=s.x by A10,A58;
          then t7.x=s.x by A2,A55,A43,A47,A58,SCMPDS_2:60;
          hence t8.x=s.x by A51,SCMPDS_2:66;
        end;
A60:    t5.b= Comput(ProgramPart( t2), t2,m2).b by A54,SCMPDS_4:23
          .=(Result(ProgramPart(t2),t2)).b by A37,EXTPRO_1:23
          .=t.b by A23,A22,FUNCT_4:12;
        t8.b=t7.b by A51,SCMPDS_2:66
          .=t.b+n by A55,A60,A43,A47,SCMPDS_2:60;
        then
A61:    -t8.b=-n-t.b;
        then
A62:    FOR is_closed_on t8 by A8,A56,A57,A25;
        now
          let k be Element of NAT;
          per cases;
          suppose
            k < m5;
            then k <= m3+1 by INT_1:20;
            then
A63:        k <= m3 or k=m3+1 by NAT_1:8;
            hereby
              per cases by A63,NAT_1:8;
              suppose
A64:            k <= m2;
                hereby
                  per cases;
                  suppose
                    k=0;
                    hence IC Comput(ProgramPart( t3), t3,k) in dom pFOR by A32
,A29,EXTPRO_1:3
;
                  end;
                  suppose
                    k<>0;
                    then consider kn be Nat such that
A65:                k=kn+1 by NAT_1:6;
                    reconsider kn as Element of NAT by ORDINAL1:def 13;
                    reconsider lm = IC Comput(ProgramPart( t2), t2,kn) as
Element of NAT;
                    kn < k by A65,XREAL_1:31;
                    then kn < m2 by A64,XXREAL_0:2;
                    then IC Comput(ProgramPart( t2), t2,kn) + 1 = IC Comput(
ProgramPart(t4),t4,kn)
                    by A4,A15,A39,A27,A40,A21,A36,Th34;
                    then
A66:                IC Comput(ProgramPart( t3), t3,k)= lm +1 by A65,A53,
EXTPRO_1:5
                      .= (lm+1);
                    IC Comput(ProgramPart( t2), t2,kn) in dom pI by A26,
SCMPDS_6:def 2;
                    then lm < card pI by AFINSQ_1:70;
                    then lm < card I+1 by SCMPDS_5:7;
                    then
A67:                lm+1 <= card I +1 by INT_1:20;
                    card I + 1 < card I + 4 by XREAL_1:8;
                    then lm+1 < card I +4 by A67,XXREAL_0:2;
                    then lm+1 < card pFOR by Lm2;
                    hence IC Comput(ProgramPart( t3), t3,k) in dom pFOR by A66,
AFINSQ_1:70;
                  end;
                end;
              end;
              suppose
A68:            k=m3;
                l1 in dom pFOR by A30,SCMPDS_6:18;
                hence
                IC Comput(ProgramPart( t3), t3,k) in dom pFOR by A4,A15,A39,A27
,A40,A21,A36,A43,A68,Th36;
              end;
              suppose
                k=m3+1;
                hence IC Comput(ProgramPart( t3), t3,k) in dom pFOR by A48,A33,
SCMPDS_6:18;
              end;
            end;
          end;
          suppose
            k >= m5;
            then consider nn be Nat such that
A69:        k=m5+nn by NAT_1:10;
            reconsider nn as Element of NAT by ORDINAL1:def 13;
 ProgramPart t3 = ProgramPart t8
by AMI_1:123;
   then
            Comput(ProgramPart(t3),t3,k)=
            Comput(ProgramPart( (Initialize t8 +* pFOR)), (
Initialize t8 +* pFOR),nn) by A52,A69,EXTPRO_1:5;
            hence IC Comput(ProgramPart( t3), t3,k) in dom pFOR by A62,
SCMPDS_6:def 2;
          end;
        end;
        hence FOR is_closed_on t by SCMPDS_6:def 2;
        FOR is_halting_on t8 by A8,A56,A57,A25,A61;
        then ProgramPart t8 halts_on t8 by A52,SCMPDS_6:def 3;
        then ProgramPart t3 halts_on t8 by AMI_1:123;
        then ProgramPart t3 halts_on t3 by EXTPRO_1:22;
        hence FOR is_halting_on t by SCMPDS_6:def 3;
      end;
    end;
    hence thesis;
  end;
  reconsider n=-s.b as Element of NAT by A1,INT_1:16;
A70: P[0]
  proof
    let t be State of SCMPDS;
    assume
    -t.b <= 0;
    then -t.b <= -(0 qua Nat);
    then
A71: t.b >= 0 by XREAL_1:26;
    assume
    for x be Int_position st x in X holds t.x=s.x;
    assume
    t.a=s.a;
    hence thesis by A71,Th54;
  end;
  for k being Element of NAT holds P[k] from NAT_1:sch 1(A70,A7);
  then
A72: P[n];
  for x be Int_position st x in X holds s.x=s.x;
  hence thesis by A72;
end;

theorem
  for s being State of SCMPDS,I being halt-free shiftable Program of
  SCMPDS, a be Int_position, i be Integer,n be Element of NAT,X be set st s.
  DataLoc(s.a,i) < 0 & not DataLoc(s.a,i) in X & n > 0 & card I > 0 & a <>
DataLoc(s.a,i) & (for t be State of SCMPDS st (for x be Int_position st x in X
holds t.x=s.x) & t.a=s.a holds IExec(I,t).a=t.a & IExec(I,t).DataLoc(s.a,i)=t.
  DataLoc(s.a,i) & I is_closed_on t & I is_halting_on t & for y be Int_position
st y in X holds IExec(I,t).y=t.y) holds IExec(for-up(a,i,n,I),s) = IExec(for-up
  (a,i,n,I),IExec(I ';' AddTo(a,i,n),s))
proof
  let s be State of SCMPDS,I be halt-free shiftable Program of SCMPDS, a be
  Int_position, i be Integer,n be Element of NAT,X be set;
  set b=DataLoc(s.a,i);
  set FOR=for-up(a,i,n,I),
  pFOR = stop FOR,
  s1= Initialize s +* pFOR, ps= ProgramPart s;
  set i1=(a,i)>=0_goto (card I+3), i2=AddTo(a,i,n), i3=goto -(card I+2);
A1: s +* Initialize pFOR = Initialize s +* pFOR by COMPOS_1:125;
  assume
A2: s.b < 0;
  set s4 = Comput(ProgramPart(s1),s1,1);
A3: IC s1 = 0 by SCMPDS_6:21;
A4: not b in dom Initialize pFOR by SCMPDS_4:31;
  set m0=LifeSpan(ProgramPart(s1),s1);
  set l2= card I+2;
  set sI= Initialize s +* stop I, m1=LifeSpan(ProgramPart(sI),sI)+3,
  J=I ';' AddTo(a,i,n), sJ= Initialize s +* stop J,
  s2=Initialize IExec(J,s) +* pFOR, m2=LifeSpan(ProgramPart(s2),s2);
A5: s +* Initialize stop I = Initialize s +* stop I by COMPOS_1:125;
A6: IExec(J,s) +* Initialize pFOR = Initialize IExec(J,s) +* pFOR
 by COMPOS_1:125;
  set Es=IExec(J,s), bj=DataLoc(Es.a,i);
A7: Initialize stop I c= sI by A5,FUNCT_4:26;
A8: dom ProgramPart s = A by COMPOS_1:34;
A9: not a in dom (s | A) by A8,SCMPDS_2:53;
A10: not b in dom (s | A) by A8,SCMPDS_2:53;
A11: FOR = i1 ';' (I ';' i2 ';' i3) by Th15;
  set mI=LifeSpan(ProgramPart(sI),sI), s5= Comput(ProgramPart( s4), s4,mI),
      l1= card I + 1;
  set m3=mI +1;
  set s6= Comput(ProgramPart( s1), s1,m3);
  set s7= Comput(ProgramPart( s1), s1,m3+1);
A12: Initialize pFOR c= s1 by A1,FUNCT_4:26;
  FOR c= Initialize pFOR by SCMPDS_6:17;
  then
A13: FOR c= s1 by A12,XBOOLE_1:1;
  Shift(I,1) c= FOR by Lm3;
  then Shift(I,1) c= s1 by A13,XBOOLE_1:1;
  then
A14: Shift(I,1) c= s4 by AMI_1:81;
  card I + 2 < card I + 3 by XREAL_1:8;
  then
A15: l2 in dom FOR by Th52;
  set m5=m3+1+1, s8= Comput(ProgramPart( s1), s1,m5);
A16: dom ps = dom s /\ A by RELAT_1:90
    .= ({IC SCMPDS} \/ D \/ A) /\ A by SCMPDS_4:19
    .= A by XBOOLE_1:21;
  card I + 1 < card I + 3 by XREAL_1:8;
  then
A17: l1 in dom FOR by Th52;
  assume
A18: not b in X;
  assume
A19: n > 0;
  assume
A20: card I > 0;
  assume
A21: a <> b;
  assume
A22: for t be State of SCMPDS st (for x be Int_position st x in X holds t
.x=s.x) & t.a=s.a holds IExec(I,t).a=t.a & IExec(I,t).b=t.b & I is_closed_on t
  & I is_halting_on t & for y be Int_position st y in X holds IExec(I,t).y=t.y;
  then FOR is_halting_on s by A2,A18,A19,A20,A21,Th58;
  then
A23: ProgramPart s1 halts_on s1 by SCMPDS_6:def 3;
A24: for x be Int_position st x in X holds s.x=s.x;
  then
A25: IExec(I,s).b=s.b by A22;
A26: IExec(I, s).a=s.a by A22,A24;
A27: b=DataLoc(IExec(I, s).a,i) by A22,A24;
A28: IExec(I,s).a=s.a by A22,A24;
A29: Comput(ProgramPart( s1), s1,(0 qua Nat)+1) = Following(ProgramPart s1,
Comput(ProgramPart(s1),s1,0)) by EXTPRO_1:4
    .= Following(ProgramPart s1,s1) by EXTPRO_1:3
    .= Exec(i1,s1) by A11,A1,SCMPDS_6:22;
  not a in dom Initialize pFOR by SCMPDS_4:31;
  then s1.DataLoc(s1.a,i)=s1.b by A1,FUNCT_4:12
    .= s.b by A4,A1,FUNCT_4:12;
  then
A30: IC s4 = succ IC s1 by A2,A29,SCMPDS_2:69
    .= ((0 qua Nat)+1) by A3;
A31: DataPart sI = DataPart s1 by COMPOS_1:138,FUNCT_7:134;
  now
    let a;
    thus sI.a = s1.a by A31,SCMPDS_4:23
      .= s4.a by A29,SCMPDS_2:69;
  end;
  then
A32: DataPart sI = DataPart s4 by SCMPDS_4:23;
A33: I is_halting_on s by A22,A24;
  then
A34: ProgramPart sI halts_on sI by SCMPDS_6:def 3;
A35: Initialize sI+*stop I = sI+*Initialize stop I by COMPOS_1:125;
  sI = Initialize sI+*stop I by A7,A35,FUNCT_4:79;
  then ProgramPart(Initialize sI+*stop I) halts_on Initialize sI+*stop I
       by A34;
  then
A36: I is_halting_on sI by SCMPDS_6:def 3;
A37: I is_closed_on s by A22,A24;
  then
A38: Es.b=Exec(i2, IExec(I, s)).b by A33,Th50
    .=IExec(I, s).b+n by A26,SCMPDS_2:60
    .=s.b+n by A22,A24;
A39: I is_closed_on sI by A37,SCMPDS_6:38;
  then
A40: IC s5=l1 by A20,A7,A36,A30,A32,A14,Th36;
A41:  (ProgramPart s6)/.IC s6
 = s6.IC s6 by COMPOS_1:38;
 ProgramPart s1 = ProgramPart s4
by AMI_1:123;
 then
A42: s6=s5 by EXTPRO_1:5;
  then
A43: CurInstr(ProgramPart s6,s6)=s5.l1 by A20,A7,A36,A39,A30,A32,A14,Th36,A41
    .=s4.l1 by AMI_1:54
    .=s1.l1 by AMI_1:54
    .=FOR.l1 by A17,A13,GRFUNC_1:8
    .=i2 by Th53;
A44: DataPart Comput(ProgramPart( sI), sI,mI) = DataPart s5 by A20,A7,A36,A39
,A30,A32,A14,Th36;
  then
A45: s5.a= Comput(ProgramPart( sI), sI,mI).a by SCMPDS_4:23
    .=(Result(ProgramPart(sI),sI)).a by A34,EXTPRO_1:23
    .=s.a by A28,A9,FUNCT_4:12;
A46: Es.a=Exec(i2, IExec(I, s)).a by A37,A33,Th50
    .=s.a by A21,A26,SCMPDS_2:60;
  now
    per cases;
    suppose
      Es.bj >= 0;
      hence FOR is_halting_on Es by Th54;
    end;
    suppose
A47:  Es.bj<0;
      now
        let t be State of SCMPDS;
        assume that
A48:    for x be Int_position st x in X holds t.x=Es.x and
A49:    t.a=Es.a;
A50:    now
          let x be Int_position;
          assume
A51:      x in X;
          hence t.x=Es.x by A48
            .=Exec(i2, IExec(I, s)).x by A37,A33,Th50
            .=IExec(I, s).x by A18,A26,A51,SCMPDS_2:60
            .=s.x by A22,A24,A51;
        end;
        hence IExec(I,t).a=t.a by A22,A46,A49;
        thus IExec(I,t).bj= t.bj by A22,A46,A49,A50;
        thus I is_closed_on t & I is_halting_on t & for y be Int_position st y
        in X holds IExec(I,t).y=t.y by A22,A46,A49,A50;
      end;
      hence FOR is_halting_on Es by A18,A19,A20,A21,A46,A47,Th58;
    end;
  end;
  then
A52: ProgramPart s2 halts_on s2 by SCMPDS_6:def 3;
A53:  (ProgramPart s7)/.IC s7
 = s7.IC s7 by COMPOS_1:38;
A54: ProgramPart s1 = ProgramPart s6
by AMI_1:123;
A55: s7 = Following(ProgramPart s1,s6) by EXTPRO_1:4
    .= Exec(i2,s6) by A43,A54;
  then
A56: IC s7=succ IC s6 by SCMPDS_2:60
    .=(card I+1+1) by A40,A42,NAT_1:39
    .=(card I+(1+1));
  then
A57: CurInstr(ProgramPart s7,s7)=s1.l2 by A53,AMI_1:54
    .=FOR.l2 by A13,A15,GRFUNC_1:8
    .=i3 by Th53;
A58: ProgramPart s1 = ProgramPart s7
by AMI_1:123;
A59: s8 = Following(ProgramPart s1,s7) by EXTPRO_1:4
    .= Exec(i3,s7) by A57,A58;
  then IC s8=ICplusConst(s7,(0 qua Nat)-(card I+2)) by SCMPDS_2:66
    .= 0 by A56,Th1;
  then
A60: IC s2 =IC Comput(ProgramPart(s1),s1,m1) by SCMPDS_6:21;
A61: s5.b= Comput(ProgramPart( sI), sI,mI).b by A44,SCMPDS_4:23
    .=(Result(ProgramPart(sI),sI)).b by A34,EXTPRO_1:23
    .=s.b by A25,A10,FUNCT_4:12;
A62: s8.b=s7.b by A59,SCMPDS_2:66
    .=s.b+n by A45,A61,A42,A55,SCMPDS_2:60;
  now
    let x be Int_position;
A63: not x in dom Initialize pFOR by SCMPDS_4:31;
    then
A64: s2.x=IExec(J,s).x by A6,FUNCT_4:12;
    per cases;
    suppose
      x=b;
      hence s8.x=s2.x by A62,A38,A63,A6,FUNCT_4:12;
    end;
    suppose
A65:  x<>b;
A66: not x in dom (s | A) by A8,SCMPDS_2:53;
A67:  s5.x= Comput(ProgramPart( sI), sI,mI).x by A44,SCMPDS_4:23
        .=(Result(ProgramPart(sI),sI)).x by A34,EXTPRO_1:23
        .=IExec(I,s).x by A66,FUNCT_4:12;
A68:  s7.x=s5.x by A45,A42,A55,A65,SCMPDS_2:60;
      Es.x=Exec(i2, IExec(I, s)).x by A37,A33,Th50
        .=IExec(I, s).x by A27,A65,SCMPDS_2:60;
      hence s8.x=s2.x by A59,A64,A67,A68,SCMPDS_2:66;
    end;
  end;
  then
A69: DataPart s8 = DataPart s2 by SCMPDS_4:23;
A70: ProgramPart s1 = ProgramPart Comput(ProgramPart(s1),s1,m1)
by AMI_1:123;
  ProgramPart s2
     =ProgramPart (Result(ProgramPart(sJ),sJ) +* ps)+* ProgramPart
     Initialize pFOR by A6,FUNCT_4:75
    .= ps +* ProgramPart Initialize pFOR by A16,FUNCT_4:24
    .= ProgramPart s1 by A1,FUNCT_4:75
    .= ProgramPart Comput(ProgramPart(s1),s1,m1) by AMI_1:123;
  then
A71: Comput(ProgramPart(s1),s1,m1)=s2 by A69,A60,Th7;
  then CurInstr(ProgramPart (s1),Comput(ProgramPart(s1),s1,m1))=i1
   by A11,A70,A6,SCMPDS_6:22;
  then m0 > m1 by A23,SCMPDS_6:2,31;
  then consider nn be Nat such that
A72: m0=m1+nn by NAT_1:10;
  reconsider nn as Element of NAT by ORDINAL1:def 13;
A73: ProgramPart s1 = ProgramPart s2
by A71,AMI_1:123;
  then
  Comput(ProgramPart(s1),s1,m1+m2) = Comput(ProgramPart(s2),s2,m2) by A71,
EXTPRO_1:5;
  then CurInstr(ProgramPart (s1),Comput(ProgramPart(s1),s1,m1+m2))
   = halt SCMPDS by A52,A73,EXTPRO_1:def 14;
  then m1 + m2 >= m0 by A23,EXTPRO_1:def 14;
  then
A74: m2 >= nn by A72,XREAL_1:8;
A75: Comput(ProgramPart(s1),s1,m0) = Comput(ProgramPart(s2),s2,nn) by A71,A72,
A73
,EXTPRO_1:5;
  then CurInstr(ProgramPart (s2),Comput(ProgramPart(s2),s2,nn))
   =halt SCMPDS by A23,A73,EXTPRO_1:def 14;
  then nn >= m2 by A52,EXTPRO_1:def 14;
  then nn=m2 by A74,XXREAL_0:1;
  then
A76: Result(ProgramPart(s1),s1) = Comput(ProgramPart(s2),s2,m2) by A23,A75,
EXTPRO_1:23;
  IExec(J,s) | A= ps by A16,FUNCT_4:24;
  hence thesis by A52,A76,EXTPRO_1:23;
end;

registration
  let I be shiftable Program of SCMPDS, a be Int_position,i be Integer,n be
  Element of NAT;
  cluster for-up(a,i,n,I) -> shiftable;
  correctness
  proof
    set FOR=for-up(a,i,n,I), i1= (a,i)>=0_goto (card I +3), i2= AddTo(a,i,n);
    set PF= Load i1 ';' I ';' i2;
    card PF=card (i1 ';' I) + 1 by SCMP_GCD:8
      .=card I + 1+1 by SCMPDS_6:15
      .=card I +(1+1);
    then card PF+ -(card I+2) =0;
    hence thesis by SCMPDS_4:78;
  end;
end;

registration
  let I be halt-free Program of SCMPDS, a be Int_position,i be Integer,n be
  Element of NAT;
  cluster for-up(a,i,n,I) -> halt-free;
  correctness
  proof
    -(card I+2) <> 0;
    then reconsider
    i3=goto -(card I+2) as No-StopCode Instruction of SCMPDS by SCMPDS_5:25;
    for-up(a,i,n,I) = (a,i)>=0_goto (card I +3) ';' I ';' AddTo(a,i,n) ';'
    i3;
    hence thesis;
  end;
end;

begin :: The construction of  for-down loop program

:: while (a,i)>=0 do { I, (a,i)-=n }

definition
  let a be Int_position, i be Integer,n be Element of NAT;
  let I be Program of SCMPDS;
  func for-down(a,i,n,I) -> Program of SCMPDS equals
  (a,i)<=0_goto (card I +3)
  ';' I ';' AddTo(a,i,-n) ';' goto -(card I+2);
  coherence;
end;

begin :: The computation of  for-down loop program

theorem Th60:
  for a be Int_position,i be Integer,n be Element of NAT,I be
  Program of SCMPDS holds card for-down(a,i,n,I)= card I +3
proof
  let a be Int_position,i be Integer,n be Element of NAT, I be Program of
  SCMPDS;
  set i1=(a,i)<=0_goto (card I +3), i2=AddTo(a,i,-n);
  set I4=i1 ';' I, I5=I4 ';' i2;
  card I4=card I+1 by SCMPDS_6:15;
  then card I5=card I +1 +1 by SCMP_GCD:8
    .=card I+ (1+1);
  hence card for-down(a,i,n,I)=card I +2 +1 by SCMP_GCD:8
    .=card I + 3;
end;

Lm4: for a be Int_position,i be Integer,n be Element of NAT, I be Program of
SCMPDS holds card stop for-down(a,i,n,I)= card I+4

proof

  let a be Int_position,i be Integer,n be Element of NAT, I be Program of
  SCMPDS;

  thus card stop for-down(a,i,n,I)= card for-down(a,i,n,I) +1 by SCMPDS_5:7
    .= card I +3+1 by Th60
    .= card I + 4;
end;

theorem Th61:
  for a be Int_position,i be Integer,n,m be Element of NAT, I be
  Program of SCMPDS holds m < card I+3 iff  m in dom for-down(a,i,n,I)
proof
  let a be Int_position,i be Integer,n,m be Element of NAT, I be Program of
  SCMPDS;
  card for-down(a,i,n,I)=card I + 3 by Th60;
  hence thesis by AFINSQ_1:70;
end;

theorem Th62:
  for a be Int_position,i be Integer,n be Element of NAT, I be
Program of SCMPDS holds for-down(a,i,n,I). 0=(a,i)<=0_goto (card I +3) &
for-down(a,i,n,I). (card I+1)=AddTo(a,i,-n) & for-down(a,i,n,I). (
  card I+2)=goto -(card I+2)
proof
  let a be Int_position,i be Integer,n be Element of NAT, I be Program of
  SCMPDS;
  set i1=(a,i)<=0_goto (card I +3), i2=AddTo(a,i,-n), i3=goto -(card I+2);
  set I4=i1 ';' I, I5=I4 ';' i2;
  set J6=i2 ';' i3, J5=I ';' J6;
  set FLOOP=for-down(a,i,n,I);
  FLOOP=I4 ';' J6 by SCMPDS_4:49;
  then FLOOP=i1 ';' J5 by SCMPDS_4:50;
  hence FLOOP. 0=i1 by SCMPDS_6:16;
A1: card I4=card I+1 by SCMPDS_6:15;
  hence FLOOP.(card I+1)=i2 by SCMP_GCD:11;
  card I5=card I +1 +1 by A1,SCMP_GCD:8
    .=card I+ (1+1);
  hence thesis by SCMP_GCD:10;
end;

theorem Th63:
  for s being State of SCMPDS,I being Program of SCMPDS,a being
  Int_position, i being Integer,n be Element of NAT st s.DataLoc(s.a,i) <= 0
  holds for-down(a,i,n,I) is_closed_on s & for-down(a,i,n,I) is_halting_on s
proof
  let s be State of SCMPDS,I be Program of SCMPDS,a be Int_position, i be
  Integer,n be Element of NAT;
  set d1=DataLoc(s.a,i);
  assume
A1: s.d1 <= 0;
  set i1=(a,i)<=0_goto (card I+3), i2=AddTo(a,i,-n), i3=goto -(card I+2);
  set FOR=for-down(a,i,n,I), pFOR=stop FOR,
  s3 = Initialize s +* pFOR, s4 = Comput(ProgramPart(s3),s3,1);
A2: s +* Initialize pFOR = Initialize s +* pFOR by COMPOS_1:125;
A3: IC s3 = 0 by SCMPDS_6:21;
A4: not d1 in dom Initialize pFOR by SCMPDS_4:31;
  not a in dom Initialize pFOR by SCMPDS_4:31;
  then
A5: s3.DataLoc(s3.a,i)=s3.d1 by A2,FUNCT_4:12
    .= s.d1 by A4,A2,FUNCT_4:12;
A6: FOR = i1 ';' (I ';' i2 ';' i3) by Th15;
  Comput(ProgramPart( s3), s3,(0 qua Nat)+1) = Following(ProgramPart s3,
  Comput(ProgramPart(s3),s3,0)) by EXTPRO_1:4
    .= Following(ProgramPart s3,s3) by EXTPRO_1:3
    .= Exec(i1,s3) by A6,A2,SCMPDS_6:22;
  then
A7: IC s4 = ICplusConst(s3,(card I+3)) by A1,A5,SCMPDS_2:68
    .= ((0 qua Nat)+(card I+3)) by A3,SCMPDS_6:23;
A8: card FOR=card I+3 by Th60;
  then
A9: (card I+3) in dom pFOR by SCMPDS_6:25;
A10:  (ProgramPart s4)/.IC s4
 = s4.IC s4 by COMPOS_1:38;
  Initialize pFOR c= s3 by A2,FUNCT_4:26;
  then pFOR c= s4 by AMI_1:81,COMPOS_1:132;
  then s4.(card I+3) = pFOR.(card I+3) by A9,GRFUNC_1:8
    .=halt SCMPDS by A8,SCMPDS_6:25;
  then
A11: CurInstr(ProgramPart s4,s4) = halt SCMPDS by A7,A10;
A12: ProgramPart s3 = ProgramPart s4
by AMI_1:123;
  now
    let k be Element of NAT;
    per cases;
    suppose
      0 < k;
      then 1+(0 qua Nat) <= k by INT_1:20;
      hence IC Comput(ProgramPart(s3),s3,k) in dom pFOR
      by A9,A7,A11,A12,EXTPRO_1:6;
    end;
    suppose
      k = 0;
      then Comput(ProgramPart(s3),s3,k) = s3 by EXTPRO_1:3;
      hence IC Comput(ProgramPart(s3),s3,k) in dom pFOR by A3,COMPOS_1:135;
    end;
  end;
  hence FOR is_closed_on s by SCMPDS_6:def 2;
  ProgramPart s3 halts_on s3 by A11,A12,EXTPRO_1:30;
  hence thesis by SCMPDS_6:def 3;
end;

theorem Th64:
  for s being State of SCMPDS,I being Program of SCMPDS,a,c being
  Int_position, i being Integer,n be Element of NAT st s.DataLoc(s.a,i) <= 0
  holds IExec(for-down(a,i,n,I),s) = s +* Start-At((card I+3),SCMPDS)
proof
  let s be State of SCMPDS,I be Program of SCMPDS, a,c be Int_position, i be
  Integer,n be Element of NAT;
  set d1=DataLoc(s.a,i);
  set FOR=for-down(a,i,n,I), pFOR=stop FOR,
  s3 = Initialize s +* pFOR, s4 = Comput(ProgramPart( s3), s3,1),
  i1=(a,i)<=0_goto (card I+3), i2= AddTo(a,i,-n),
  i3=goto -(card I+2);
A1: s +* Initialize pFOR = Initialize s +* pFOR by COMPOS_1:125;
  set SAl=Start-At((card I+3),SCMPDS);
A2: IC s3 = 0 by SCMPDS_6:21;
A3: not d1 in dom Initialize pFOR by SCMPDS_4:31;
  Initialize pFOR c= s3 by A1,FUNCT_4:26;
  then
A4: pFOR c= s4 by AMI_1:81,COMPOS_1:132;
  not a in dom Initialize pFOR by SCMPDS_4:31;
  then
A5: s3.DataLoc(s3.a,i)=s3.d1 by A1,FUNCT_4:12
    .= s.d1 by A3,A1,FUNCT_4:12;
A6: FOR = i1 ';' (I ';' i2 ';' i3) by Th15;
A7: Comput(ProgramPart( s3), s3,(0 qua Nat)+1) =
Following(ProgramPart s3,Comput(ProgramPart(s3),s3,0)
)
 by EXTPRO_1:4
    .= Following(ProgramPart s3,s3) by EXTPRO_1:3
    .= Exec(i1,s3) by A6,A1,SCMPDS_6:22;
  assume
  s.d1 <= 0;
  then
A8: IC s4 = ICplusConst(s3,(card I+3)) by A7,A5,SCMPDS_2:68
    .= ((0 qua Nat)+(card I+3)) by A2,SCMPDS_6:23;
A9:  (ProgramPart s4)/.IC s4
 = s4.IC s4 by COMPOS_1:38;
A10: ProgramPart s3 = ProgramPart s4
by AMI_1:123;
A11: card FOR=card I+3 by Th60;
  then (card I+3) in dom pFOR by SCMPDS_6:25;
  then s4.(card I+3) = pFOR.(card I+3) by A4,GRFUNC_1:8
    .=halt SCMPDS by A11,SCMPDS_6:25;
  then
A12: CurInstr(ProgramPart s4,s4) = halt SCMPDS by A8,A9;
  then
A13: ProgramPart s3 halts_on s3 by A10,EXTPRO_1:30;
A14: CurInstr(ProgramPart s3,s3) = i1 by A6,A1,SCMPDS_6:22;
A15: ProgramPart s3 = ProgramPart s4
by AMI_1:123;
  now
    let l be Element of NAT;
A16: Comput(ProgramPart(s3),s3,0) = s3 by EXTPRO_1:3;
    assume
    l < (0 qua Nat)+1;
    then l=0 by NAT_1:13;
    then CurInstr(ProgramPart (s3),Comput(ProgramPart(s3),s3,l))
     = CurInstr(ProgramPart s3,s3)
     by A16;
    hence CurInstr(ProgramPart (s3),Comput(ProgramPart(s3),s3,l))
     <> halt SCMPDS by A14,SCMPDS_6:30;
  end;
  then for l be Element of NAT st CurInstr(ProgramPart (s3),
  Comput(ProgramPart(s3),s3,l)) = halt SCMPDS holds 1 <= l;
  then LifeSpan(ProgramPart(s3),s3) = 1 by A12,A13,A15,EXTPRO_1:def 14;
  then
A17: s4 = Result(ProgramPart(s3),s3) by A13,EXTPRO_1:23;
A18: dom ProgramPart s = A by COMPOS_1:34;
A19: now
    let x be set;
A20: dom SAl = {IC SCMPDS} by FUNCOP_1:19;
    assume
A21: x in dom IExec(FOR,s);
    per cases by A21,SCMPDS_4:20;
    suppose
A22:  x is Int_position;
      then x <> IC SCMPDS by SCMPDS_2:52;
      then
A23:  not x in dom SAl by A20,TARSKI:def 1;
      not x in dom (s | A) by A18,A22,SCMPDS_2:53;
      hence IExec(FOR,s).x = s4.x by A17,FUNCT_4:12
        .= s3.x by A7,A22,SCMPDS_2:68
        .= s.x by A22,SCMPDS_5:19
        .= (s +* SAl).x by A23,FUNCT_4:12;
    end;
    suppose
A24:  x = IC SCMPDS;
      not x in dom (s | A) by A18,A24,COMPOS_1:3;
      hence IExec(FOR,s).x = (card I + 3) by A8,A17,A24,FUNCT_4:12
        .= (s +* SAl).x by A24,FUNCT_4:121;
    end;
    suppose
      x is Element of NAT;
      hence IExec(FOR,s).x = (s +* SAl).x by SCMPDS_6:27;
    end;
  end;
  dom IExec(FOR,s) = the carrier of SCMPDS by PARTFUN1:def 4
    .= dom (s +* SAl) by PARTFUN1:def 4;
  hence thesis by A19,FUNCT_1:9;
end;

theorem
  for s being State of SCMPDS,I being Program of SCMPDS,a being
  Int_position, i being Integer,n be Element of NAT st s.DataLoc(s.a,i) <= 0
  holds IC IExec(for-down(a,i,n,I),s) =  (card I + 3)
proof
  let s be State of SCMPDS,I be Program of SCMPDS,a be Int_position, i be
  Integer,n be Element of NAT;
  assume
  s.DataLoc(s.a,i) <= 0;
  then IExec(for-down(a,i,n,I),s) =s +* Start-At((card I+3),SCMPDS)
  by Th64;
  hence thesis by FUNCT_4:121;
end;

theorem Th66:
  for s being State of SCMPDS,I being Program of SCMPDS,a,b being
  Int_position, i being Integer,n be Element of NAT st s.DataLoc(s.a,i) <= 0
  holds IExec(for-down(a,i,n,I),s).b = s.b
proof
  let s be State of SCMPDS,I be Program of SCMPDS,a,b be Int_position, i be
  Integer,n be Element of NAT;
  assume
  s.DataLoc(s.a,i) <= 0;
  then
A1: IExec(for-down(a,i,n,I),s) = s +* Start-At((card I+3),SCMPDS)
by Th64;
  not b in dom Start-At((card I+3),SCMPDS) by SCMPDS_4:59;
  hence thesis by A1,FUNCT_4:12;
end;

Lm5: for I being Program of SCMPDS,a being Int_position,i being Integer, n be
Element of NAT holds Shift(I,1) c= for-down(a,i,n,I)

proof

  let I be Program of SCMPDS,a be Int_position,i be Integer, n be Element of
  NAT;

  set i1=(a,i)<=0_goto (card I+3), i2=AddTo(a,i,-n), i3=goto -(card I+2);
A1: for-down(a,i,n,I) = Load i1 ';' I ';' (i2 ';' i3) by SCMPDS_4:49;
  card Load i1=1 by SCMPDS_5:6;
  hence thesis by A1,Th16;
end;

theorem Th67:
  for s being State of SCMPDS,I being halt-free shiftable
Program of SCMPDS, a be Int_position, i be Integer,n be Element of NAT,X be set
  st s.DataLoc(s.a,i) > 0 & not DataLoc(s.a,i) in X & n > 0 & card I > 0 & a <>
DataLoc(s.a,i) &
 (for t be 0-started State of SCMPDS st (for x be Int_position st x in X
   holds t.x=s.x) & t.a=s.a holds IExec(I,t).a=t.a &
     IExec(I,t).DataLoc(s.a,i)=t.DataLoc(s.a,i) &
     I is_closed_on t & I is_halting_on t &
     for y be Int_position st y in X holds IExec(I,t).y=t.y)
 holds for-down(a,i,n,I) is_closed_on s &
       for-down(a,i,n,I) is_halting_on s
proof
  let s be State of SCMPDS,I be halt-free shiftable Program of SCMPDS, a be
  Int_position, i be Integer,n be Element of NAT,X be set;
  set b=DataLoc(s.a,i);
  set FOR=for-down(a,i,n,I), pFOR=stop FOR,
  pI=stop I;
  set i1=(a,i)<=0_goto (card I+3), i2=AddTo(a,i,-n), i3=goto -(card I+2);
  assume
A1: s.b > 0;
  defpred P[Element of NAT] means
   for t be State of SCMPDS st t.b <= $1 &
    (for x be Int_position st x in X holds t.x=s.x) & t.a=s.a
     holds FOR is_closed_on t & FOR is_halting_on t;
  assume
A2: not b in X;
  assume
A3: n > 0;
  assume
A4: card I > 0;
  assume
A5: a <> b;
  assume
A6: for t be 0-started State of SCMPDS st (for x be Int_position st x in X
  holds t.x=s.x) & t.a=s.a holds IExec(I,t).a=t.a & IExec(I,t).b=t.b &
  I is_closed_on t
  & I is_halting_on t & for y be Int_position st y in X holds IExec(I,t).y=t.y;
A7: for k be Element of NAT st P[k] holds P[k + 1]
  proof
    let k be Element of NAT;
    assume
A8: P[k];
:::    now
      let t be State of SCMPDS;
      assume
A9:   t.b <= k+1;
      assume
A10:  for x be Int_position st x in X holds t.x=s.x;
A11:  for x be Int_position st x in X holds (Initialize t).x=s.x
       proof let x be Int_position;
        assume x in X;
         then t.x=s.x by A10;
        hence (Initialize t).x=s.x by SCMPDS_5:40;
       end;
      assume
A12:  t.a=s.a;
      then
A13:   (Initialize t).a=s.a by SCMPDS_5:40;
      per cases;
      suppose
        t.b <= 0;
        hence FOR is_closed_on t & FOR is_halting_on t by A12,Th63;
      end;
      suppose
A14:    t.b > 0;
        set t2 = Initialize t +* stop I, t3 = Initialize t +* pFOR,
        t4 = Comput(ProgramPart(t3),t3,1);
A15:    t +* Initialize stop I = Initialize t +* stop I by COMPOS_1:125;
A16:    t +* Initialize pFOR = Initialize t +* pFOR by COMPOS_1:125;
A17:    Initialize stop I c= t2 by A15,FUNCT_4:26;
A18:    dom ProgramPart t = A by COMPOS_1:34;
A19: not a in dom (t | A) by A18,SCMPDS_2:53;
A20:    FOR = i1 ';' (I ';' i2 ';' i3) by Th15;
A21:    Comput(ProgramPart( t3), t3,(0 qua Nat)+1) = Following(ProgramPart t3,
Comput(ProgramPart(t3),t3,0)) by EXTPRO_1:4
          .= Following(ProgramPart t3,t3) by EXTPRO_1:3
          .= Exec(i1,t3) by A20,A16,SCMPDS_6:22;
A22:    DataPart t2 = DataPart t3 by COMPOS_1:138,FUNCT_7:134;
        now
          let a;
          thus t2.a = t3.a by A22,SCMPDS_4:23
            .= t4.a by A21,SCMPDS_2:68;
        end;
        then
A23:    DataPart t2 = DataPart t4 by SCMPDS_4:23;
A24: not b in dom (t | A) by A18,SCMPDS_2:53;
A25:      IExec(I,t) = IExec(I,Initialize t) by SCMPDS_5:48;
        then
A26:    IExec(I,t).b= (Initialize t).b by A6,A11,A13
          .= t.b by SCMPDS_5:40;
        -(-n) > 0 by A3;
        then -n < 0;
        then -n <= -1 by INT_1:21;
        then
A27:    -n+t.b <= -1+t.b by XREAL_1:8;
        t.b-1 <= k by A9,XREAL_1:22;
        then
A28:    -n+t.b <= k by A27,XXREAL_0:2;
        I is_closed_on Initialize t by A6,A11,A13;
        then
A29:    I is_closed_on t by SCMPDS_6:139;
        then
A30:    I is_closed_on t2 by SCMPDS_6:38;
A31:    not b in dom Initialize pFOR by SCMPDS_4:31;
        set m2=LifeSpan(ProgramPart(t2),t2), t5= Comput(ProgramPart( t4), t4,m2
), l1= (card I +
1);
A32:    IC t3 = 0 by SCMPDS_6:21;
        set m3=m2 +1;
        set t6= Comput(ProgramPart( t3), t3,m3);
        card I + 1 < card I + 3 by XREAL_1:8;
        then
A33:    l1 in dom FOR by Th61;
        set m5=m3+1+1, t8= Comput(ProgramPart( t3), t3,m5);
        set t7= Comput(ProgramPart( t3), t3,m3+1);
A34:    IExec(I,t).a = (Initialize t).a by A6,A11,A13,A25
           .=t.a by A12,A13;
        set l2=(card I+2);
A35:     0 in dom pFOR by COMPOS_1:135;
        card I + 2 < card I + 3 by XREAL_1:8;
        then
A36:    l2 in dom FOR by Th61;
A37:    Initialize pFOR c= t3 by A16,FUNCT_4:26;
        FOR c= Initialize pFOR by SCMPDS_6:17;
        then
A38:    FOR c= t3 by A37,XBOOLE_1:1;
        Shift(I,1) c= FOR by Lm5;
        then Shift(I,1) c= t3 by A38,XBOOLE_1:1;
        then
A39:    Shift(I,1) c= t4 by AMI_1:81;
        I is_halting_on Initialize t by A6,A11,A13;
        then I is_halting_on t by SCMPDS_6:140;
        then
A40:    ProgramPart t2 halts_on t2 by SCMPDS_6:def 3;
A41:     t2+*Initialize stop I = Initialize t2+*stop I by COMPOS_1:125;
        t2 = Initialize t2+*stop I by A17,A41,FUNCT_4:79;
        then ProgramPart(Initialize t2+*stop I) halts_on Initialize t2+*stop I
         by A40;
        then
A42:    I is_halting_on t2 by SCMPDS_6:def 3;
        not a in dom Initialize pFOR by SCMPDS_4:31;
        then t3.DataLoc(t3.a,i)= t3.b by A12,A16,FUNCT_4:12
          .= t.b by A31,A16,FUNCT_4:12;
        then
A43:    IC t4 = succ IC t3 by A14,A21,SCMPDS_2:68
          .= ((0 qua Nat)+1) by A32;
        then
A44:    IC t5=l1 by A4,A17,A42,A30,A23,A39,Th36;
A45:  (ProgramPart t6)/.IC t6
 = t6.IC t6 by COMPOS_1:38;
 ProgramPart t3 = ProgramPart t4
by AMI_1:123;
 then
A46:    t6=t5 by EXTPRO_1:5;
        then
A47:    CurInstr(ProgramPart t6,t6)=t5.l1 by A4,A17,A42,A30,A43,A23,A39,Th36,
A45
          .=t4.l1 by AMI_1:54
          .=t3.l1 by AMI_1:54
          .=FOR.l1 by A33,A38,GRFUNC_1:8
          .=i2 by Th62;
A48:  (ProgramPart t7)/.IC t7
 = t7.IC t7 by COMPOS_1:38;
A49: ProgramPart t3 = ProgramPart t6
by AMI_1:123;
A50:    t7 = Following(ProgramPart t3,t6) by EXTPRO_1:4
          .= Exec(i2,t6) by A47,A49;
        then
A51:    IC t7=succ IC t6 by SCMPDS_2:60
          .=(card I+1+1) by A44,A46,NAT_1:39
          .=(card I+(1+1));
        then
A52:    CurInstr(ProgramPart t7,t7)=t3.l2 by A48,AMI_1:54
          .=FOR.l2 by A38,A36,GRFUNC_1:8
          .=i3 by Th62;
A53: ProgramPart t3 = ProgramPart t7
by AMI_1:123;
A54:    t8 = Following(ProgramPart t3,t7) by EXTPRO_1:4
          .= Exec(i3,t7) by A52,A53;
        then IC t8=ICplusConst(t7,(0 qua Nat)-(card I+2)) by SCMPDS_2:66
          .= 0 by A51,Th1;
        then
A55:    Initialize t8 +* pFOR=t8 by Th37;
A56: ProgramPart t3 = ProgramPart t4
by AMI_1:123;
A57:    DataPart Comput(ProgramPart( t2), t2,m2) = DataPart t5 by A4,A17,A42
,A30,A43,A23,A39,Th36;
        then
A58:    t5.a= Comput(ProgramPart( t2), t2,m2).a by SCMPDS_4:23
          .=(Result(ProgramPart(t2),t2)).a by A40,EXTPRO_1:23
          .=s.a by A12,A34,A19,FUNCT_4:12;
        then DataLoc(t6.a,i)=b by A56,EXTPRO_1:5;
        then t7.a=t6.a by A5,A50,SCMPDS_2:60
          .=s.a by A58,A56,EXTPRO_1:5;
        then
A59:    t8.a=s.a by A54,SCMPDS_2:66;
A60:    now
          let x be Int_position;
          assume
A61:      x in X;
A62: not x in dom (t | A) by A18,SCMPDS_2:53;
          t5.x= Comput(ProgramPart( t2), t2,m2).x by A57,SCMPDS_4:23
            .=(Result(ProgramPart(t2),t2)).x by A40,EXTPRO_1:23
            .=IExec(I,t).x by A62,FUNCT_4:12
            .=IExec(I,Initialize t).x by SCMPDS_5:48
            .=(Initialize t).x by A6,A61,A11,A13
            .=t.x by SCMPDS_5:40
            .=s.x by A10,A61;
          then t7.x=s.x by A2,A58,A46,A50,A61,SCMPDS_2:60;
          hence t8.x=s.x by A54,SCMPDS_2:66;
        end;
A63:    t5.b= Comput(ProgramPart( t2), t2,m2).b by A57,SCMPDS_4:23
          .=(Result(ProgramPart(t2),t2)).b by A40,EXTPRO_1:23
          .=t.b by A26,A24,FUNCT_4:12;
A64:    t8.b=t7.b by A54,SCMPDS_2:66
          .=t.b+ -n by A58,A63,A46,A50,SCMPDS_2:60;
        then
A65:    FOR is_closed_on t8 by A8,A59,A60,A28;
        now
          let k be Element of NAT;
          per cases;
          suppose
            k < m5;
            then k <= m3+1 by INT_1:20;
            then
A66:        k <= m3 or k=m3+1 by NAT_1:8;
            hereby
              per cases by A66,NAT_1:8;
              suppose
A67:            k <= m2;
                hereby
                  per cases;
                  suppose
                    k=0;
                    hence IC Comput(ProgramPart( t3), t3,k) in dom pFOR by A35
,A32,EXTPRO_1:3
;
                  end;
                  suppose
                    k<>0;
                    then consider kn be Nat such that
A68:                k=kn+1 by NAT_1:6;
                    reconsider kn as Element of NAT by ORDINAL1:def 13;
                    reconsider lm = IC Comput(ProgramPart( t2), t2,kn) as
Element of NAT;
                    kn < k by A68,XREAL_1:31;
                    then kn < m2 by A67,XXREAL_0:2;
                    then IC Comput(ProgramPart( t2), t2,kn) + 1 = IC Comput(
ProgramPart(t4),t4,kn)
                    by A4,A17,A42,A30,A43,A23,A39,Th34;
                    then
A69:                IC Comput(ProgramPart( t3), t3,k)= lm +1 by A68,A56,
EXTPRO_1:5
                      .= (lm+1);
                    IC Comput(ProgramPart( t2), t2,kn) in dom pI by A29,
SCMPDS_6:def 2;
                    then lm < card pI by AFINSQ_1:70;
                    then lm < card I+1 by SCMPDS_5:7;
                    then
A70:                lm+1 <= card I +1 by INT_1:20;
                    card I + 1 < card I + 4 by XREAL_1:8;
                    then lm+1 < card I +4 by A70,XXREAL_0:2;
                    then lm+1 < card pFOR by Lm4;
                    hence IC Comput(ProgramPart( t3), t3,k) in dom pFOR by A69,
AFINSQ_1:70;
                  end;
                end;
              end;
              suppose
A71:            k=m3;
                l1 in dom pFOR by A33,SCMPDS_6:18;
                hence
                IC Comput(ProgramPart( t3), t3,k) in dom pFOR by A4,A17,A42,A30
,A43,A23,A39,A46,A71,Th36;
              end;
              suppose
                k=m3+1;
                hence IC Comput(ProgramPart( t3), t3,k) in dom pFOR by A51,A36,
SCMPDS_6:18;
              end;
            end;
          end;
          suppose
            k >= m5;
            then consider nn be Nat such that
A72:        k=m5+nn by NAT_1:10;
            reconsider nn as Element of NAT by ORDINAL1:def 13;
 ProgramPart t3 = ProgramPart t8
by AMI_1:123;
 then
            Comput(ProgramPart(t3),t3,k)=
            Comput(ProgramPart( (Initialize t8 +* pFOR)), (
Initialize t8 +* pFOR),nn) by A55,A72,EXTPRO_1:5;
            hence IC Comput(ProgramPart( t3), t3,k) in dom pFOR by A65,
SCMPDS_6:def 2;
          end;
        end;
        hence FOR is_closed_on t by SCMPDS_6:def 2;
        FOR is_halting_on t8 by A8,A59,A60,A64,A28;
        then ProgramPart t8 halts_on t8 by A55,SCMPDS_6:def 3;
        then ProgramPart t3 halts_on t8 by AMI_1:123;
        then ProgramPart t3 halts_on t3 by EXTPRO_1:22;
        hence FOR is_halting_on t by SCMPDS_6:def 3;
      end;
:::    end;
:::    hence thesis;
  end;
  reconsider n=s.b as Element of NAT by A1,INT_1:16;
A73: P[0] by Th63;
  for k being Element of NAT holds P[k] from NAT_1:sch 1(A73,A7);
  then
A74: P[n];
  for x be Int_position st x in X holds s.x=s.x;
  hence thesis by A74;
end;

theorem Th68:
  for s being 0-started State of SCMPDS,I being halt-free shiftable
Program of SCMPDS, a be Int_position, i be Integer,n be Element of NAT,X be set
  st s.DataLoc(s.a,i) > 0 & not DataLoc(s.a,i) in X & n > 0 & card I > 0 & a <>
DataLoc(s.a,i) &
  (for t be 0-started State of SCMPDS st (for x be Int_position st x in X
holds t.x=s.x) & t.a=s.a holds IExec(I,t).a=t.a & IExec(I,t).DataLoc(s.a,i)=t.
  DataLoc(s.a,i) & I is_closed_on t & I is_halting_on t & for y be Int_position
  st y in X holds IExec(I,t).y=t.y) holds IExec(for-down(a,i,n,I),s) = IExec(
  for-down(a,i,n,I),IExec(I ';' AddTo(a,i,-n),s))
proof
  let s be 0-started State of SCMPDS,
      I be halt-free shiftable Program of SCMPDS,
      a be Int_position, i be Integer,n be Element of NAT,X be set;
  set b=DataLoc(s.a,i);
  set FOR=for-down(a,i,n,I),
  pFOR = stop FOR,
  s1= Initialize s +* pFOR, ps= ProgramPart s;
A1: s +* Initialize pFOR =  Initialize s +* pFOR by COMPOS_1:125;
  set i1=(a,i)<=0_goto (card I+3), i2=AddTo(a,i,-n), i3=goto -(card I+2);
  assume
A2: s.b > 0;
  set s4 = Comput(ProgramPart(s1),s1,1);
A3: IC s1 = 0 by SCMPDS_6:21;
A4: not b in dom Initialize pFOR by SCMPDS_4:31;
  set m0=LifeSpan(ProgramPart(s1),s1);
  set l2=(card I+2);
  set sI= Initialize s +* stop I, m1=LifeSpan(ProgramPart(sI),sI)+3,
  J=I ';' AddTo(a,i,-n), sJ =Initialize s +* stop J,
  s2=Initialize IExec(J,s) +* pFOR,
  m2=LifeSpan(ProgramPart(s2),s2);
A5: s +* Initialize stop I = Initialize s +* stop I by COMPOS_1:125;
A6: IExec(J,s) +* Initialize pFOR =
    Initialize IExec(J,s) +* pFOR by COMPOS_1:125;
  set Es=IExec(J,s), bj=DataLoc(Es.a,i);
A7: Initialize stop I c= sI by A5,FUNCT_4:26;
A8: dom ProgramPart s = A by COMPOS_1:34;
A9:not a in dom (s | A) by A8,SCMPDS_2:53;
A10: not b in dom (s | A) by A8,SCMPDS_2:53;
A11: FOR = i1 ';' (I ';' i2 ';' i3) by Th15;
  set mI=LifeSpan(ProgramPart(sI),sI), s5= Comput(ProgramPart( s4), s4,mI), l1=
(card I + 1);
  set m3=mI +1;
  set s6= Comput(ProgramPart( s1), s1,m3);
  set s7= Comput(ProgramPart( s1), s1,m3+1);
A12: Initialize pFOR c= s1 by A1,FUNCT_4:26;
  FOR c= Initialize pFOR by SCMPDS_6:17;
  then
A13: FOR c= s1 by A12,XBOOLE_1:1;
  Shift(I,1) c= FOR by Lm5;
  then Shift(I,1) c= s1 by A13,XBOOLE_1:1;
  then
A14: Shift(I,1) c= s4 by AMI_1:81;
  card I + 2 < card I + 3 by XREAL_1:8;
  then
A15: l2 in dom FOR by Th61;
  set m5=m3+1+1, s8= Comput(ProgramPart( s1), s1,m5);
A16: dom ps = dom s /\ A by RELAT_1:90
    .= ({IC SCMPDS} \/ D \/ A) /\ A by SCMPDS_4:19
    .= A by XBOOLE_1:21;
  card I + 1 < card I + 3 by XREAL_1:8;
  then
A17: l1 in dom FOR by Th61;
  assume
A18: not b in X;
  assume
A19: n > 0;
  assume
A20: card I > 0;
  assume
A21: a <> b;
  assume
A22: for t be 0-started State of SCMPDS st
   (for x be Int_position st x in X holds t
.x=s.x) & t.a=s.a holds IExec(I,t).a=t.a & IExec(I,t).b=t.b & I is_closed_on t
  & I is_halting_on t & for y be Int_position st y in X holds IExec(I,t).y=t.y;
  then FOR is_halting_on s by A2,A18,A19,A20,A21,Th67;
  then
A23: ProgramPart s1 halts_on s1 by SCMPDS_6:def 3;
A24: for x be Int_position st x in X holds s.x=s.x;
  then
A25: IExec(I,s).b=s.b by A22;
A26: IExec(I, s).a=s.a by A22,A24;
A27: b=DataLoc(IExec(I, s).a,i) by A22,A24;
A28: IExec(I,s).a=s.a by A22,A24;
A29: Comput(ProgramPart( s1), s1,(0 qua Nat)+1) = Following(ProgramPart s1,
Comput(ProgramPart(s1),s1,0)) by EXTPRO_1:4
    .= Following(ProgramPart s1,s1) by EXTPRO_1:3
    .= Exec(i1,s1) by A11,A1,SCMPDS_6:22;
  not a in dom Initialize pFOR by SCMPDS_4:31;
  then s1.DataLoc(s1.a,i)=s1.b by A1,FUNCT_4:12
    .= s.b by A4,A1,FUNCT_4:12;
  then
A30: IC s4 = succ IC s1 by A2,A29,SCMPDS_2:68
    .= ((0 qua Nat)+1) by A3;
A31: DataPart sI = DataPart s1 by COMPOS_1:138,FUNCT_7:134;
  now
    let a;
    thus sI.a = s1.a by A31,SCMPDS_4:23
      .= s4.a by A29,SCMPDS_2:68;
  end;
  then
A32: DataPart sI = DataPart s4 by SCMPDS_4:23;
A33: I is_halting_on s by A22,A24;
  then
A34: ProgramPart sI halts_on sI by SCMPDS_6:def 3;
A35:  Initialize sI+*stop I = sI+*Initialize stop I by COMPOS_1:125;
  sI = Initialize sI+*stop I by A7,A35,FUNCT_4:79;
  then ProgramPart(Initialize sI+*stop I) halts_on Initialize sI+*stop I
   by A34;
  then
A36: I is_halting_on sI by SCMPDS_6:def 3;
A37: I is_closed_on s by A22,A24;
  then
A38: Es.b=Exec(i2, IExec(I, s)).b by A33,Th50
    .=IExec(I, s).b+ -n by A26,SCMPDS_2:60
    .=s.b+ -n by A22,A24;
A39:  (ProgramPart s6)/.IC s6
 = s6.IC s6 by COMPOS_1:38;
A40: I is_closed_on sI by A37,SCMPDS_6:38;
  then
A41: IC s5=l1 by A20,A7,A36,A30,A32,A14,Th36;
 ProgramPart s1 = ProgramPart s4
by AMI_1:123;
 then
A42: s6=s5 by EXTPRO_1:5;
  then
A43: CurInstr(ProgramPart s6,s6)=s5.l1 by A20,A7,A36,A40,A30,A32,A14,Th36,A39
    .=s4.l1 by AMI_1:54
    .=s1.l1 by AMI_1:54
    .=FOR.l1 by A17,A13,GRFUNC_1:8
    .=i2 by Th62;
A44: DataPart Comput(ProgramPart(sI),sI,mI) = DataPart s5 by A20,A7,A36,A40,A30
,A32,A14,Th36;
  then
A45: s5.a= Comput(ProgramPart( sI), sI,mI).a by SCMPDS_4:23
    .=(Result(ProgramPart(sI),sI)).a by A34,EXTPRO_1:23
    .=s.a by A28,A9,FUNCT_4:12;
A46: Es.a=Exec(i2, IExec(I, s)).a by A37,A33,Th50
    .=s.a by A21,A26,SCMPDS_2:60;
  now
    per cases;
    suppose
      Es.bj <= 0;
      hence FOR is_halting_on Es by Th63;
    end;
    suppose
A47:  Es.bj > 0;
      now
        let t be 0-started State of SCMPDS;
        assume that
A48:    for x be Int_position st x in X holds t.x=Es.x and
A49:    t.a=Es.a;
A50:    now
          let x be Int_position;
          assume
A51:      x in X;
          hence t.x=Es.x by A48
            .=Exec(i2, IExec(I, s)).x by A37,A33,Th50
            .=IExec(I, s).x by A18,A26,A51,SCMPDS_2:60
            .=s.x by A22,A24,A51;
        end;
        hence IExec(I,t).a=t.a by A22,A46,A49;
        thus IExec(I,t).bj= t.bj by A22,A46,A49,A50;
        thus I is_closed_on t & I is_halting_on t & for y be Int_position st y
        in X holds IExec(I,t).y=t.y by A22,A46,A49,A50;
      end;
      hence FOR is_halting_on Es by A18,A19,A20,A21,A46,A47,Th67;
    end;
  end;
  then
A52: ProgramPart s2 halts_on s2 by SCMPDS_6:def 3;
A53:  (ProgramPart s7)/.IC s7
 = s7.IC s7 by COMPOS_1:38;
A54: ProgramPart s1 = ProgramPart s6
by AMI_1:123;
A55: s7 = Following(ProgramPart s1,s6) by EXTPRO_1:4
    .= Exec(i2,s6) by A43,A54;
  then
A56: IC s7=succ IC s6 by SCMPDS_2:60
    .=(card I+1+1) by A41,A42,NAT_1:39
    .=(card I+(1+1));
  then
A57: CurInstr(ProgramPart s7,s7)=s1.l2 by A53,AMI_1:54
    .=FOR.l2 by A13,A15,GRFUNC_1:8
    .=i3 by Th62;
A58: ProgramPart s1 = ProgramPart s7
by AMI_1:123;
A59: s8 = Following(ProgramPart s1,s7) by EXTPRO_1:4
    .= Exec(i3,s7) by A57,A58;
  then IC s8=ICplusConst(s7,(0 qua Nat)-(card I+2)) by SCMPDS_2:66
    .= 0 by A56,Th1;
  then
A60: IC s2 =IC Comput(ProgramPart(s1),s1,m1) by SCMPDS_6:21;
A61: s5.b= Comput(ProgramPart( sI), sI,mI).b by A44,SCMPDS_4:23
    .=(Result(ProgramPart(sI),sI)).b by A34,EXTPRO_1:23
    .=s.b by A25,A10,FUNCT_4:12;
A62: s8.b=s7.b by A59,SCMPDS_2:66
    .=s.b+ -n by A45,A61,A42,A55,SCMPDS_2:60;
  now
    let x be Int_position;
A63: not x in dom Initialize pFOR by SCMPDS_4:31;
    then
A64: s2.x=IExec(J,s).x by A6,FUNCT_4:12;
    per cases;
    suppose
      x=b;
      hence s8.x=s2.x by A62,A38,A63,A6,FUNCT_4:12;
    end;
    suppose
A65:  x<>b;
A66: not x in dom (s | A) by A8,SCMPDS_2:53;
A67:  s5.x= Comput(ProgramPart( sI), sI,mI).x by A44,SCMPDS_4:23
        .=(Result(ProgramPart(sI),sI)).x by A34,EXTPRO_1:23
        .=IExec(I,s).x by A66,FUNCT_4:12;
A68:  s7.x=s5.x by A45,A42,A55,A65,SCMPDS_2:60;
      Es.x=Exec(i2, IExec(I, s)).x by A37,A33,Th50
        .=IExec(I, s).x by A27,A65,SCMPDS_2:60;
      hence s8.x=s2.x by A59,A64,A67,A68,SCMPDS_2:66;
    end;
  end;
  then
A69: DataPart s8 = DataPart s2 by SCMPDS_4:23;
A70: ProgramPart s1 = ProgramPart Comput(ProgramPart(s1),s1,m1)
by AMI_1:123;
  ProgramPart s2
     =ProgramPart (Result(ProgramPart(sJ),sJ) +* ps) +*
     ProgramPart Initialize pFOR by A6,FUNCT_4:75
    .= ps +* ProgramPart Initialize pFOR by A16,FUNCT_4:24
    .= ProgramPart s1 by A1,FUNCT_4:75
    .= ProgramPart Comput(ProgramPart(s1),s1,m1) by AMI_1:123;
  then
A71: Comput(ProgramPart(s1),s1,m1)=s2 by A69,A60,Th7;
  then CurInstr(ProgramPart (s1),Comput(ProgramPart(s1),s1,m1))
  =i1 by A11,A70,A6,SCMPDS_6:22;
  then m0 > m1 by A23,SCMPDS_6:2,30;
  then consider nn be Nat such that
A72: m0=m1+nn by NAT_1:10;
  reconsider nn as Element of NAT by ORDINAL1:def 13;
A73: ProgramPart s1 = ProgramPart s2
by A71,AMI_1:123;
 then
  Comput(ProgramPart(s1),s1,m1+m2) = Comput(ProgramPart(s2),s2,m2) by A71,
EXTPRO_1:5;
  then CurInstr(ProgramPart (s1),Comput(ProgramPart(s1),s1,m1+m2))
   = halt SCMPDS by A52,A73,EXTPRO_1:def 14;
  then m1 + m2 >= m0 by A23,EXTPRO_1:def 14;
  then
A74: m2 >= nn by A72,XREAL_1:8;
A75: Comput(ProgramPart(s1),s1,m0) = Comput(ProgramPart(s2),s2,nn) by A71,A72,
A73
,EXTPRO_1:5;
  then CurInstr(ProgramPart (s2),Comput(ProgramPart(s2),s2,nn))
   =halt SCMPDS by A23,A73,EXTPRO_1:def 14;
  then nn >= m2 by A52,EXTPRO_1:def 14;
  then nn=m2 by A74,XXREAL_0:1;
  then
A76: Result(ProgramPart(s1),s1) = Comput(ProgramPart(s2),s2,m2) by A23,A75,
EXTPRO_1:23;
  IExec(J,s) | A= ps by A16,FUNCT_4:24;
  hence thesis by A52,A76,EXTPRO_1:23;
end;

registration
  let I be shiftable Program of SCMPDS, a be Int_position,i be Integer,n be
  Element of NAT;
  cluster for-down(a,i,n,I) -> shiftable;
  correctness
  proof
    set FOR=for-down(a,i,n,I), i1= (a,i)<=0_goto (card I +3), i2= AddTo(a,i,-n
    );
    reconsider PF= Load i1 ';' I ';' i2 as shiftable Program of SCMPDS;
    card PF=card (i1 ';' I) + 1 by SCMP_GCD:8
      .=card I + 1+1 by SCMPDS_6:15
      .=card I +(1+1);
    then card PF+ -(card I+2) =0;
    hence thesis by SCMPDS_4:78;
  end;
end;

registration
  let I be halt-free Program of SCMPDS, a be Int_position,i be Integer,n be
  Element of NAT;
  cluster for-down(a,i,n,I) -> halt-free;
  correctness
  proof
    -(card I+2) <> 0;
    then reconsider
    i3=goto -(card I+2) as No-StopCode Instruction of SCMPDS by SCMPDS_5:25;
    for-down(a,i,n,I) = (a,i)<=0_goto (card I +3) ';' I ';' AddTo(a,i,-n)
    ';' i3;
    hence thesis;
  end;
end;

begin :: Two Examples for Summing

:: n=Sum 1+1+...+1

definition
  let n be Element of NAT;
  func sum(n) -> Program of SCMPDS equals
  (GBP:=0) ';' ((GBP,2):=n) ';' ((GBP,
  3):=0) ';' for-down(GBP,2,1, Load AddTo(GBP,3,1));
  coherence;
end;

theorem Th69:
  for s being 0-started State of SCMPDS st s.GBP=0 holds for-down(GBP,2,1,
  Load AddTo(GBP,3,1)) is_closed_on s & for-down(GBP,2,1, Load AddTo(GBP,3,1))
  is_halting_on s
proof
  set I= Load AddTo(GBP,3,1);
  let s be 0-started State of SCMPDS;
  assume
A1: s.GBP=0;
  per cases;
  suppose
    s.DataLoc(s.GBP,2) <= 0;
    hence thesis by Th63;
  end;
  suppose
A2: s.DataLoc(s.GBP,2) > 0;
A3: now
      set cv=DataLoc(s.GBP,2);
      let t be 0-started State of SCMPDS;
      assume that
      for x be Int_position st x in {GBP} holds t.x=s.x and
A4:   t.GBP=s.GBP;
      set t0=Initialize t;
      t0.GBP=0 by A1,A4,SCMPDS_5:40;
      then
A5:   DataLoc(t0.GBP,3)=intpos((0 qua Nat)+3) by SCMP_GCD:5;
      thus
A6:   IExec(I,t).GBP=Exec(AddTo(GBP,3,1),t0).GBP by SCMPDS_5:45
        .=t0.GBP by A5,AMI_3:52,SCMPDS_2:60
        .=t.GBP by SCMPDS_5:40;
A7:   cv=intpos((0 qua Nat)+2) by A1,SCMP_GCD:5;
      thus IExec(I,t).cv=Exec(AddTo(GBP,3,1),t0).cv by SCMPDS_5:45
        .=t0.cv by A5,A7,AMI_3:52,SCMPDS_2:60
        .=t.cv by SCMPDS_5:40;
      thus I is_closed_on t & I is_halting_on t by SCMPDS_6:34,35;
      hereby
        let y be Int_position;
        assume
        y in {GBP};
        then y=GBP by TARSKI:def 1;
        hence IExec(I,t).y=t.y by A6;
      end;
    end;
    DataLoc(s.GBP,2)=intpos((0 qua Nat)+2) by A1,SCMP_GCD:5;
    then DataLoc(s.GBP,2) <> GBP by AMI_3:52;
    then
 not DataLoc(s.GBP,2) in {GBP} by TARSKI:def 1;
    hence thesis by A1,A2,A3,Th67;
  end;
end;

theorem Th70:
  for s being 0-started State of SCMPDS,n be Element of NAT
   st s.GBP=0 & s.intpos 2=n & s.intpos 3=0
   holds IExec(for-down(GBP,2,1, Load AddTo(GBP,3,1)),s).intpos 3=n
proof
  set i= AddTo(GBP,3,1), I= Load i, FD= for-down(GBP,2,1, I), a=intpos 3;
  let s be 0-started State of SCMPDS,n be Element of NAT;
  assume that
A1: s.GBP=0 and
A2: s.intpos 2=n and
A3: s.a=0;
  defpred P[Element of NAT] means
   for s be 0-started State of SCMPDS st s.intpos 2=$1 & s.GBP=0
    holds IExec(FD,s).a=$1+s.a;
A4: now
    let k be Element of NAT;
    assume
A5: P[k];
    now
      let s be 0-started State of SCMPDS;
      assume that
A6:   s.intpos 2=k+1 and
A7:   s.GBP=0;
      GBP <> DataLoc(s.GBP,2) by A6,A7,SCMP_GCD:5;
      then
A8:   not DataLoc(s.GBP,2) in {GBP} by TARSKI:def 1;
A9:  now
        set cv=DataLoc(s.GBP,2);
        let t be 0-started State of SCMPDS;
        assume that
        for x be Int_position st x in {GBP} holds t.x=s.x and
A10:    t.GBP=s.GBP;
        set t0=Initialize t;
        t0.GBP=0 by A7,A10,SCMPDS_5:40;
        then
A11:    DataLoc(t0.GBP,3)=intpos(0 qua Nat+3) by SCMP_GCD:5;
        then
A12:    cv <> DataLoc(t0.GBP,3) by A6,A7,AMI_3:52,SCMP_GCD:5;
        thus
A13:    IExec(I,t).GBP=Exec(AddTo(GBP,3,1),t0).GBP by SCMPDS_5:45
          .=t0.GBP by A11,AMI_3:52,SCMPDS_2:60
          .=t.GBP by SCMPDS_5:40;
        thus IExec(I,t).cv=Exec(AddTo(GBP,3,1),t0).cv by SCMPDS_5:45
          .=t0.cv by A12,SCMPDS_2:60
          .=t.cv by SCMPDS_5:40;
        thus I is_closed_on t & I is_halting_on t by SCMPDS_6:34,35;
        hereby
          let y be Int_position;
          assume
          y in {GBP};
          then y=GBP by TARSKI:def 1;
          hence IExec(I,t).y=t.y by A13;
        end;
      end;
      set j=AddTo(GBP,2,-1), s0=Initialize s, s1=IExec(I, s),
          s2=IExec(I ';'j,s), l2=intpos 2;
A14:  s0.GBP=0 by A7,SCMPDS_5:40;
      then
A15:  DataLoc(s0.GBP,3)=intpos(0 qua Nat+3) by SCMP_GCD:5;
A16:  s1.GBP=Exec(i, s0).GBP by SCMPDS_5:45
        .=0 by A14,A15,AMI_3:52,SCMPDS_2:60;
      then
A17:  DataLoc(s1.GBP,2)=intpos(0 qua Nat+2) by SCMP_GCD:5;
A18:  s2.l2=Exec(j, s1).l2 by SCMPDS_5:46
        .=s1.l2+ -1 by A17,SCMPDS_2:60
        .=Exec(i, s0).l2+-1 by SCMPDS_5:45
        .=s0.l2+ -1 by A15,AMI_3:52,SCMPDS_2:60
        .=k+1+-1 by A6,SCMPDS_5:40
        .=k;
A19:  s2.a=Exec(j, s1).a by SCMPDS_5:46
        .=s1.a by A17,AMI_3:52,SCMPDS_2:60
        .=Exec(i, s0).a by SCMPDS_5:45
        .=s0.a+1 by A15,SCMPDS_2:60
        .=s.a+1 by SCMPDS_5:40;
A20:  s2.GBP=Exec(j, s1).GBP by SCMPDS_5:46
        .=0 by A16,A17,AMI_3:52,SCMPDS_2:60;
A21: (Initialize s2).intpos 2=s2.intpos 2 by SCMPDS_5:40;
A22: (Initialize s2).a=s2.a by SCMPDS_5:40;
A23: (Initialize s2).GBP=s2.GBP by SCMPDS_5:40;
A24: IExec(FD,Initialize s2) = IExec(FD,s2) by SCMPDS_5:48;
      DataLoc(s.GBP,2)=intpos(0 qua Nat+2) by A7,SCMP_GCD:5;
      hence IExec(FD,s).a =IExec(FD,s2).a by A6,A7,A8,A9,Th68
        .=k+s2.a by A5,A18,A20,A21,A22,A23,A24
        .=k+1+s.a by A19;
    end;
    hence P[k+1];
  end;
A25: P[0]
  proof
    let s be 0-started State of SCMPDS;
    assume that
A26: s.intpos 2=0 and
A27: s.GBP=0;
    DataLoc(s.GBP,2)=intpos((0 qua Nat)+2) by A27,SCMP_GCD:5;
    hence thesis by A26,Th66;
  end;
  for k be Element of NAT holds P[k] from NAT_1:sch 1(A25,A4);
  hence IExec(FD,s).a=n+(0 qua Nat) by A1,A2,A3
    .=n;
end;

theorem
  for s being 0-started State of SCMPDS,n be Element of NAT
   holds IExec(sum(n),s).intpos 3 =n
proof
  let s be 0-started State of SCMPDS,n be Element of NAT;
  set i1= GBP:=0, i2= (GBP,2):=n, i3= (GBP,3):=0, i4= AddTo(GBP,3,1), FD=
  for-down(GBP,2,1, Load i4), a = intpos 3, I2=i1 ';' i2, s1=IExec(I2, s), s2=
  Exec(i1, Initialize s), I3=I2 ';' i3, s3=IExec(I3,s);
A1: I3 is_closed_on s by SCMPDS_6:34;
A2: I3 is_halting_on s by SCMPDS_6:35;
A3: s2.GBP=0 by SCMPDS_2:57;
  then
A4: DataLoc(s2.GBP,2)=intpos((0 qua Nat)+2) by SCMP_GCD:5;
A5: s1.GBP=Exec(i2, s2).GBP by SCMPDS_5:47
    .=0 by A3,A4,AMI_3:52,SCMPDS_2:58;
  then
A6: DataLoc(s1.GBP,3)=intpos((0 qua Nat)+3) by SCMP_GCD:5;
A7: (Initialize s3).GBP=s3.GBP by SCMPDS_5:40;
A8: s3.GBP=Exec(i3,s1).GBP by SCMPDS_5:46
    .=0 by A5,A6,AMI_3:52,SCMPDS_2:58;
  then FD is_halting_on Initialize s3 by Th69,A7;
  then
A9: FD is_halting_on s3 by SCMPDS_6:140;
A10: s3.intpos 2=Exec(i3,s1).intpos 2 by SCMPDS_5:46
    .=s1.intpos 2 by A6,AMI_3:52,SCMPDS_2:58
    .=Exec(i2, s2).intpos 2 by SCMPDS_5:47
    .=n by A4,SCMPDS_2:58;
A11: s3.a=Exec(i3,s1).a by SCMPDS_5:46
    .=0 by A6,SCMPDS_2:58;
A12: (Initialize s3).intpos 2=s3.intpos 2 by SCMPDS_5:40;
A13: (Initialize s3).a=s3.a by SCMPDS_5:40;
A14: (Initialize s3).GBP=s3.GBP by SCMPDS_5:40;
A15: IExec(FD,Initialize s3) = IExec(FD,s3) by SCMPDS_5:48;
  FD is_closed_on Initialize s3 by A8,Th69,A14;
  then FD is_closed_on s3 by SCMPDS_6:139;
  hence IExec(sum(n),s).a = IExec(FD,s3).a by A1,A2,A9,Th49
    .= n by A11,A8,A10,Th70,A12,A13,A14,A15;
end;

:: sum=Sum x1+x2+...+x2

definition
  let sp,control,result,pp,pData be Element of NAT;
  func sum(sp,control,result,pp,pData) -> Program of SCMPDS equals
  ((intpos sp
  ,result):=0) ';' (intpos pp:=pData) ';' for-down(intpos sp,control,1, AddTo(
  intpos sp,result,intpos pData,0) ';' AddTo(intpos pp,0,1));
  coherence;
end;

theorem Th72:
  for s being 0-started State of SCMPDS,sp,cv,result,pp,pD be Element of NAT
st s.intpos sp > sp & cv < result & s.intpos pp=pD & s.intpos sp+result < pp &
pp <pD & pD < s.intpos pD
 holds for-down(intpos sp,cv,1, AddTo(intpos sp,result,intpos pD,0) ';'
  AddTo(intpos pp,0,1)) is_closed_on s &
   for-down(intpos sp,cv,1, AddTo(intpos sp,result,intpos pD,0) ';'
  AddTo(intpos pp,0,1)) is_halting_on s
proof
  let s be 0-started State of SCMPDS, sp,cv,fr,pp,pD be Element of NAT;
  set BP=intpos sp, PD=intpos pD, PP=intpos pp;
  assume that
A1: s.BP > sp and
A2: cv < fr and
A3: s.PP=pD and
A4: s.BP+fr <pp and
A5: pp < pD and
A6: pD < s.PD;
  set i2= AddTo(BP,fr,PD,0), i3= AddTo(PP,0,1), I= i2 ';' i3;
  per cases;
  suppose
    s.DataLoc(s.BP,cv) <= 0;
    hence thesis by Th63;
  end;
  suppose
A7: s.DataLoc(s.BP,cv) > 0;
    reconsider n=s.BP as Element of NAT by A1,INT_1:16;
    n+cv <> sp by A1,NAT_1:11;
    then abs(n+cv) <> sp by ABSVALUE:def 1;
    then
A8: DataLoc(s.BP,cv) <> BP by ZFMISC_1:33;
A9: n+fr > n+cv by A2,XREAL_1:8;
A10: now
      set Dv=DataLoc(s.BP,cv);
      let t be 0-started State of SCMPDS;
      assume that
A11:  for x be Int_position st x in {BP,PP} holds t.x=s.x and
A12:  t.BP=s.BP;
      set t0=Initialize t, t1=Exec(i2, t0);
A13:  DataLoc(t0.BP,fr)=DataLoc(n,fr) by A12,SCMPDS_5:40
        .=intpos(n+fr) by SCMP_GCD:5;
      then DataLoc(t0.BP,fr) <> PP by A4,ZFMISC_1:33;
      then
A14:  t1.PP=t0.PP by SCMPDS_2:61
        .=t.PP by SCMPDS_5:40;
      n+fr <> sp by A1,NAT_1:11;
      then DataLoc(t0.BP,fr) <> BP by A13,ZFMISC_1:33;
      then
A15:  t1.BP=t0.BP by SCMPDS_2:61
        .=t.BP by SCMPDS_5:40;
      PP in {BP,PP} by TARSKI:def 2;
      then t1.PP=pD by A3,A11,A14;
      then
A16:  DataLoc(t1.PP,0)=intpos (pD+(0 qua Nat)) by SCMP_GCD:5;
      then
A17:  abs(t1.PP+(0 qua Nat)) = pD by ZFMISC_1:33;
      n <= n+fr by NAT_1:11;
      then sp < n+fr by A1,XXREAL_0:2;
      then abs(t1.PP+(0 qua Nat)) <> sp by A4,A5,A17,XXREAL_0:2;
      then
A18:  DataLoc(t1.PP,0) <> BP by ZFMISC_1:33;
      Dv=intpos(n+cv) by SCMP_GCD:5;
      then
A19:  abs(s.BP+cv) = n+cv by ZFMISC_1:33;
      then abs(t1.PP+(0 qua Nat)) <> abs(s.BP+cv) by A4,A5,A9,A17,XXREAL_0:2;
      then
A20:  DataLoc(t1.PP,0) <> Dv by ZFMISC_1:33;
      abs(t0.BP+fr) = n+fr by A13,ZFMISC_1:33;
      then abs(t0.BP+fr) <> abs(s.BP+cv) by A2,A19;
      then
A21:  DataLoc(t0.BP,fr) <> Dv by ZFMISC_1:33;
      thus
A22:  IExec(I,t).BP=Exec(i3, t1).BP by SCMPDS_5:47
        .=t.BP by A15,A18,SCMPDS_2:60;
      thus IExec(I,t).Dv=Exec(i3, t1).Dv by SCMPDS_5:47
        .=t1.Dv by A20,SCMPDS_2:60
        .=t0.Dv by A21,SCMPDS_2:61
        .=t.Dv by SCMPDS_5:40;
      thus I is_closed_on t & I is_halting_on t by SCMPDS_6:34,35;
A23:  IExec(I,t).PP=Exec(i3, t1).PP by SCMPDS_5:47
        .=t.PP by A3,A6,A14,A16,SCMPDS_2:60;
      hereby
        let y be Int_position;
        assume
A24:    y in {BP,PP};
        per cases by A24,TARSKI:def 2;
        suppose
          y=BP;
          hence IExec(I,t).y=t.y by A22;
        end;
        suppose
          y=PP;
          hence IExec(I,t).y=t.y by A23;
        end;
      end;
    end;
    n+cv <> pp by A2,A4,XREAL_1:8;
    then abs(n+cv) <> pp by ABSVALUE:def 1;
    then DataLoc(s.BP,cv) <> PP by ZFMISC_1:33;
    then not DataLoc(s.BP,cv) in {BP,PP} by A8,TARSKI:def 2;
    hence thesis by A7,A8,A10,Th67;
  end;
end;

theorem Th73:
  for s being 0-started State of SCMPDS,sp,cv,result,pp,pD be Element of NAT
, f be FinSequence of NAT st s.intpos sp > sp & cv < result & s.intpos pp=pD &
  s.intpos sp+result < pp & pp <pD & pD < s.intpos pD & s.DataLoc(s.intpos sp,
result)=0 & len f = s.DataLoc(s.intpos sp,cv) & for k be Element of NAT st k <
len f holds f.(k+1)=s.DataLoc(s.intpos pD,k) holds IExec(for-down(intpos sp,cv,
1, AddTo(intpos sp,result,intpos pD,0) ';' AddTo(intpos pp,0,1)),s).DataLoc(s.
  intpos sp,result)=Sum f
proof
  let s be 0-started State of SCMPDS,
      sp,cv,fr,pp,pD be Element of NAT, f be FinSequence
  of NAT;
  set BP=intpos sp, PD=intpos pD, PP=intpos pp;
  assume that
A1: s.BP > sp and
A2: cv < fr and
A3: s.PP=pD and
A4: s.BP+fr <pp and
A5: pp < pD and
A6: pD < s.PD and
A7: s.DataLoc(s.BP,fr)=0 and
A8: len f = s.DataLoc(s.BP,cv) and
A9: for k be Element of NAT st k < len f holds f.(k+1)=s.DataLoc(s.PD,k);
  reconsider n=s.BP as Element of NAT by A1,INT_1:16;
A10: n+fr < pD by A4,A5,XXREAL_0:2;
  set i2= AddTo(BP,fr,PD,0), i3= AddTo(PP,0,1), I= i2 ';' i3, FD= for-down(BP,
  cv,1,I), a=DataLoc(s.BP,fr);
  defpred P[Element of NAT] means
   for t be 0-started State of SCMPDS,f be FinSequence of
NAT st t.BP=s.BP & t.PP=pD & pD < t.PD & len f = t.DataLoc(t.BP,cv) & len f=$1
  & for k be Element of NAT st k < len f holds f.(k+1)=t.DataLoc(t.PD,k) holds
  IExec(FD,t).a=Sum f+t.a;
  n <= n+fr by NAT_1:11;
  then
A11: sp < n+fr by A1,XXREAL_0:2;
A12: n+fr > n+cv by A2,XREAL_1:8;
  then n+cv < pp by A4,XXREAL_0:2;
  then
A13: n+cv < pD by A5,XXREAL_0:2;
A14: now
    let k be Element of NAT;
    assume
A15: P[k];
    now
      let t be 0-started State of SCMPDS,f be FinSequence of NAT;
      assume that
A16:  t.BP=s.BP and
A17:  t.PP=pD and
A18:  pD < t.PD and
A19:  len f = t.DataLoc(t.BP,cv) and
A20:  len f=k+1 and
A21:  for i be Element of NAT st i < len f holds f.(i+1)=t.DataLoc(t.
      PD,i );
A22:  f is FinSequence of REAL by FINSEQ_2:27;
A23:  now
        set Dv=DataLoc(t.BP,cv);
        let u be 0-started State of SCMPDS;
        assume that
A24:    for x be Int_position st x in {BP,PP} holds u.x=t.x and
A25:    u.BP=t.BP;
        set t0=Initialize u, t1=Exec(i2, t0);
A26:    DataLoc(t0.BP,fr)=DataLoc(n,fr) by A16,A25,SCMPDS_5:40
          .=intpos(n+fr) by SCMP_GCD:5;
        then
A27:    abs(t0.BP+fr) = n+fr by ZFMISC_1:33;
        then
A28:    t1.PP=t0.PP by A3,A5,A7,A26,SCMPDS_2:61
          .=u.PP by SCMPDS_5:40;
        PP in {BP,PP} by TARSKI:def 2;
        then
A29:    t1.PP=pD by A17,A24,A28;
        then t1.PP+(0 qua Nat) <> sp by A4,A5,A11,XXREAL_0:2;
        then abs(t1.PP+(0 qua Nat)) <> sp by A29,ABSVALUE:def 1;
        then
A30:    DataLoc(t1.PP,0) <> BP by ZFMISC_1:33;
A31:    t1.BP=t0.BP by A1,A7,A26,A27,SCMPDS_2:61
          .=u.BP by SCMPDS_5:40;
        thus
A32:    IExec(I,u).BP=Exec(i3, t1).BP by SCMPDS_5:47
          .=u.BP by A31,A30,SCMPDS_2:60;
        Dv=intpos(n+cv) by A16,SCMP_GCD:5;
        then
A33:    abs(t.BP+cv) = n+cv by ZFMISC_1:33;
        then abs(t0.BP+fr) <> abs(t.BP+cv) by A2,A27;
        then
A34:    DataLoc(t0.BP,fr) <> Dv by ZFMISC_1:33;
A35:    DataLoc(t1.PP,0)=intpos (pD+(0 qua Nat)) by A29,SCMP_GCD:5;
        then abs(t1.PP+(0 qua Nat))=pD+(0 qua Nat) by ZFMISC_1:33;
        then abs(t1.PP+(0 qua Nat)) <> abs(t.BP+cv)
         by A4,A5,A12,A33,XXREAL_0:2;
        then
A36:    DataLoc(t1.PP,0) <> Dv by ZFMISC_1:33;
        thus IExec(I,u).Dv=Exec(i3, t1).Dv by SCMPDS_5:47
          .=t1.Dv by A36,SCMPDS_2:60
          .=t0.Dv by A34,SCMPDS_2:61
          .=u.Dv by SCMPDS_5:40;
        thus I is_closed_on u & I is_halting_on u by SCMPDS_6:34,35;
A37:    IExec(I,u).PP=Exec(i3, t1).PP by SCMPDS_5:47
          .=u.PP by A3,A6,A28,A35,SCMPDS_2:60;
        hereby
          let y be Int_position;
          assume
A38:      y in {BP,PP};
          per cases by A38,TARSKI:def 2;
          suppose
            y=BP;
            hence IExec(I,u).y=u.y by A32;
          end;
          suppose
            y=PP;
            hence IExec(I,u).y=u.y by A37;
          end;
        end;
      end;
A39:  a=intpos(n+fr) by SCMP_GCD:5;
      set t0=Initialize t, t1=Exec(i2, t0);
      set j=AddTo(BP,cv,-1), s2=IExec(I ';'j,t), g=Del(f,1);
      set It=IExec(I,t);
A40:  DataLoc(t0.BP,fr)=DataLoc(n,fr) by A16,SCMPDS_5:40
        .=intpos(n+fr) by SCMP_GCD:5;
      then
A41:  abs(t0.BP+fr) = n+fr by ZFMISC_1:33;
      then
A42:  t1.BP = t0.BP by A1,A7,A40,SCMPDS_2:61
        .=t.BP by SCMPDS_5:40;
      t1.PP=t0.PP by A3,A5,A7,A40,A41,SCMPDS_2:61
        .=t.PP by SCMPDS_5:40;
      then
A43:  DataLoc(t1.PP,0)=intpos (pD+(0 qua Nat)) by A17,SCMP_GCD:5;
      then
A44:  abs(t1.PP+(0 qua Nat))=pD+(0 qua Nat) by ZFMISC_1:33;
      then abs(t1.PP+(0 qua Nat)) <> sp by A4,A5,A11,XXREAL_0:2;
      then
A45:  DataLoc(t1.PP,0) <> BP by ZFMISC_1:33;
A46:  It.BP=Exec(i3, t1).BP by SCMPDS_5:47
        .=t.BP by A42,A45,SCMPDS_2:60;
      then
A47:  DataLoc(It.BP,cv)=intpos(n+cv) by A16,SCMP_GCD:5;
      then
A48:  abs(It.BP+cv)=n+cv by ZFMISC_1:33;
      then pD <> abs(It.BP+cv) by A4,A5,A12,XXREAL_0:2;
      then
A49:  PD <> DataLoc(It.BP,cv) by ZFMISC_1:33;
A50:  f.((0 qua Nat)+1)=t.DataLoc(t.PD,0) by A20,A21
        .=t0.DataLoc(t.PD,0) by SCMPDS_5:40
        .=t0.DataLoc(t0.PD,0) by SCMPDS_5:40;
      n+fr <> abs(It.BP+cv) by A2,A48;
      then
A51:  a <> DataLoc(It.BP,cv) by A39,ZFMISC_1:33;
A52:  It.a=Exec(i3, t1).a by SCMPDS_5:47
        .=t1.a by A6,A7,A43,SCMPDS_2:60
        .=t0.a + f.1 by A40,A41,A50,SCMPDS_2:61
        .=t.a + f.1 by SCMPDS_5:40;
A53:  s2.a=Exec(j, It).a by SCMPDS_5:46
        .=f.1+t.a by A51,A52,SCMPDS_2:60;
      n+cv <> sp by A1,NAT_1:11;
      then abs(n+cv) <> sp by ABSVALUE:def 1;
      then
A54:  DataLoc(t.BP,cv) <> BP by A16,ZFMISC_1:33;
A55:  s2.PD=Exec(j, It).PD by SCMPDS_5:46
        .=It.PD by A49,SCMPDS_2:60
        .=Exec(i3, t1).PD by SCMPDS_5:47
        .=t1.PD+1 by A43,SCMPDS_2:60
        .=t0.PD+1 by A6,A7,A40,A41,SCMPDS_2:61
        .=t.PD+1 by SCMPDS_5:40;
      then t.PD < s2.PD by XREAL_1:31;
      then
A56:  pD < s2.PD by A18,XXREAL_0:2;
      1 <= k+1 by NAT_1:11;
      then 1 in Seg (k+1) by FINSEQ_1:3;
      then
A57:  1 in dom f by A20,FINSEQ_1:def 3;
      then
A58:  len g +1=len f by WSIERP_1:def 1;
A59:   s2.PD = (Initialize s2).PD by SCMPDS_5:40;
A60:   s2.DataLoc(s2.BP,cv) = (Initialize s2).DataLoc(s2.BP,cv) by SCMPDS_5:40;
A61:   s2.PP = (Initialize s2).PP by SCMPDS_5:40;
A62:   s2.BP = (Initialize s2).BP by SCMPDS_5:40;
A63:
    for k be Element of NAT st k < len g
     holds g.(k+1)=(Initialize s2).DataLoc((Initialize s2).PD,k)
 proof
        reconsider m=t.PD as Element of NAT by A18,INT_1:16;
        let i be Element of NAT;
        set SD=DataLoc((Initialize s2).PD,i);
        assume
        i < len g;
        then
A64:    i+1 < len g+1 by XREAL_1:8;
A65:   s2.SD = (Initialize s2).SD by SCMPDS_5:40;
        SD=intpos(m+1+i) by A55,A59,SCMP_GCD:5
          .=intpos(m+(1+i));
        then
A66:    abs(s2.PD+i) = m+(1+i) by A59,ZFMISC_1:33;
        then abs(t1.PP+(0 qua Nat)) <> abs(s2.PD+i) by A18,A44,NAT_1:11;
        then
A67:    DataLoc(t1.PP,0) <> SD by A59,ZFMISC_1:33;
        m <= m+(1+i) by NAT_1:11;
        then abs(t0.BP+fr)<> abs(s2.PD+i)by A10,A18,A41,A66,XXREAL_0:2;
        then
A68:    DataLoc(t0.BP,fr)<> SD by A59,ZFMISC_1:33;
        n+cv < m by A13,A18,XXREAL_0:2;
        then abs(s2.PD+i) <> abs(It.BP+cv) by A48,A66,NAT_1:11;
        then
A69:    SD <> DataLoc(It.BP,cv) by A59,ZFMISC_1:33;
A70:    s2.SD=Exec(j, It).SD by SCMPDS_5:46
          .=It.SD by A69,SCMPDS_2:60
          .=Exec(i3, t1).SD by SCMPDS_5:47
          .=t1.SD by A67,SCMPDS_2:60
          .=t0.SD by A68,SCMPDS_2:61
          .=t.SD by SCMPDS_5:40;
        (0 qua Nat)+1 <= i+1 by XREAL_1:8;
        hence g.(i+1)=f.(i+1+1) by A57,WSIERP_1:def 1
          .=t.DataLoc(t.PD,i+1) by A21,A58,A64
          .=(Initialize s2).SD by A66,A70,A59,A65;
      end;
      abs(t0.BP+fr) <> n+cv by A2,A41;
      then
A71:  DataLoc(t0.BP,fr)<> intpos(n+cv) by ZFMISC_1:33;
      abs(t1.PP+(0 qua Nat)) <> n+cv by A4,A5,A12,A44,XXREAL_0:2;
      then
A72:  DataLoc(t1.PP,0) <> intpos(n+cv) by ZFMISC_1:33;
A73:  It.intpos(n+cv)=Exec(i3, t1).intpos(n+cv) by SCMPDS_5:47
        .=t1.intpos(n+cv) by A72,SCMPDS_2:60
        .=t0.intpos(n+cv) by A71,SCMPDS_2:61
        .=t.intpos(n+cv) by SCMPDS_5:40
        .=k+1 by A16,A19,A20,SCMP_GCD:5;
      abs(It.BP+cv) <> sp by A1,A48,NAT_1:11;
      then
A74:  DataLoc(It.BP,cv) <> BP by ZFMISC_1:33;
A75:  s2.BP=Exec(j, It).BP by SCMPDS_5:46
        .=s.BP by A16,A46,A74,SCMPDS_2:60;
      then DataLoc(s2.BP,cv)=intpos(n+cv) by SCMP_GCD:5;
      then
A76:  s2.DataLoc(s2.BP,cv)=Exec(j, It).intpos(n+cv) by SCMPDS_5:46
        .=It.intpos(n+cv)+ -1 by A47,SCMPDS_2:60
        .=len g by A20,A58,A73;
      pp <> abs(It.BP+cv) by A2,A4,A48,XREAL_1:8;
      then
A77:  PP <> DataLoc(It.BP,cv) by ZFMISC_1:33;
A78:  s2.PP=Exec(j, It).PP by SCMPDS_5:46
        .=It.PP by A77,SCMPDS_2:60
        .=Exec(i3, t1).PP by SCMPDS_5:47
        .=t1.PP by A3,A6,A43,SCMPDS_2:60
        .=t0.PP by A3,A5,A7,A40,A41,SCMPDS_2:61
        .=pD by A17,SCMPDS_5:40;
      1 <= len f by A20,NAT_1:11;
      then
A79:  1 in dom f by FINSEQ_3:27;
      n+cv <> pp by A2,A4,XREAL_1:8;
      then abs(n+cv) <> pp by ABSVALUE:def 1;
      then DataLoc(s.BP,cv) <> PP by ZFMISC_1:33;
      then not DataLoc(t.BP,cv) in {BP,PP} by A16,A54,TARSKI:def 2;
      hence IExec(FD,t).a =IExec(FD,s2).a by A19,A20,A54,A23,Th68
        .= IExec(FD,Initialize s2).a by SCMPDS_5:48
        .=Sum g+(Initialize s2).a
         by A15,A20,A75,A58,A76,A78,A56,A63,A59,A60,A61,A62
        .=Sum g+s2.a by SCMPDS_5:40
        .=Sum g+f.1+t.a by A53
        .=Sum f+t.a by A79,A22,WSIERP_1:27;
    end;
    hence P[k+1];
  end;
  now
    let t be State of SCMPDS,f be FinSequence of NAT;
    assume that
    t.BP=s.BP and
    t.PP=pD and
    pD < t.PD and
A80: len f = t.DataLoc(t.BP,cv) and
A81: len f=0 and
    for k be Element of NAT st k < len f holds f.(k+1)=t.DataLoc(t.PD,k);
    f = <*>NAT by A81;
    then Sum f=0 by RVSUM_1:102;
    hence IExec(FD,t).a =Sum f + t.a by A80,A81,Th66;
  end;
  then
A82: P[0];
  for k be Element of NAT holds P[k] from NAT_1:sch 1(A82,A14);
  hence IExec(FD,s).a=Sum f+(0 qua Nat) by A3,A6,A7,A8,A9
    .=Sum f;
end;

theorem
  for s being 0-started State of SCMPDS,
   sp,cv,result,pp,pD be Element of NAT, f be
FinSequence of NAT st s.intpos sp > sp & cv < result & s.intpos sp+result < pp
  & pp <pD & pD < s.intpos pD & len f = s.DataLoc(s.intpos sp,cv) & for k be
Element of NAT st k < len f holds f.(k+1)=s.DataLoc(s.intpos pD,k) holds IExec(
  sum(sp,cv,result,pp,pD),s).DataLoc(s.intpos sp,result)=Sum f
proof
  let s be 0-started State of SCMPDS,
      sp,cv,fr,pp,pD be Element of NAT, f be FinSequence
  of NAT;
  set BP=intpos sp, PD=intpos pD, PP=intpos pp;
  assume that
A1: s.BP > sp and
A2: cv < fr and
A3: s.BP+fr <pp and
A4: pp < pD and
A5: pD < s.PD and
A6: len f = s.DataLoc(s.BP,cv) and
A7: for k be Element of NAT st k < len f holds f.(k+1)=s.DataLoc(s.PD,k);
  reconsider n=s.BP as Element of NAT by A1,INT_1:16;
A8: PD <> PP by A4,ZFMISC_1:33;
  set i0= (BP,fr):=0, i1= PP:=pD, Hi= i0 ';' i1, i2= AddTo(BP,fr,PD,0), i3=
AddTo(PP,0,1), FD= for-down(BP,cv,1,i2 ';' i3), s2=IExec(Hi,s),
  s0=Initialize s, s1=Exec(i0, s0), a =DataLoc(s.BP,fr), a1=DataLoc(s2.BP,fr);
A9: DataLoc(s0.BP,fr)=DataLoc(n,fr) by SCMPDS_5:40
    .=intpos(n+fr) by SCMP_GCD:5;
  then
A10: abs(s0.BP+fr) = n+fr by ZFMISC_1:33;
  then abs(s0.BP+fr) <> sp by A1,NAT_1:12;
  then
A11: DataLoc(s0.BP,fr) <> BP by ZFMISC_1:33;
A12: DataLoc(s0.BP,fr) <> PD by A3,A4,A9,ZFMISC_1:33;
A13: s2.PD=Exec(i1, s1).PD by SCMPDS_5:47
    .=s1.PD by A8,SCMPDS_2:57
    .=s0.PD by A12,SCMPDS_2:58
    .=s.PD by SCMPDS_5:40;
  n <= n+fr by NAT_1:12;
  then sp <> pp by A1,A3,XXREAL_0:2;
  then
A14: BP <> PP by ZFMISC_1:33;
A15: intpos(n+fr) <> PP by A3,ZFMISC_1:33;
A16: s2.BP=Exec(i1, s1).BP by SCMPDS_5:47
    .=s1.BP by A14,SCMPDS_2:57
    .=s0.BP by A11,SCMPDS_2:58
    .=n by SCMPDS_5:40;
  then
A17: s2.DataLoc(s2.BP,fr)=s2.intpos(n+fr) by SCMP_GCD:5
    .=Exec(i1, s1).intpos(n+fr) by SCMPDS_5:47
    .=s1.intpos(n+fr) by A15,SCMPDS_2:57
    .=0 by A9,SCMPDS_2:58;
A18: n+fr < pD by A3,A4,XXREAL_0:2;
A19: now
    reconsider m=s.PD as Element of NAT by A5,INT_1:16;
    let k be Element of NAT;
    assume
A20: k < len f;
    pp < m by A4,A5,XXREAL_0:2;
    then m+k <> pp by NAT_1:11;
    then
A21: intpos(m+k) <> PP by ZFMISC_1:33;
    m <= m + k by NAT_1:11;
    then abs(s0.BP+fr) <> m+k by A5,A10,A18,XXREAL_0:2;
    then
A22: DataLoc(s0.BP,fr) <> intpos(m+k) by ZFMISC_1:33;
    thus (Initialize s2).DataLoc(s2.PD,k)
       = s2.DataLoc(s2.PD,k) by SCMPDS_5:40
      .=s2.intpos(m+k) by A13,SCMP_GCD:5
      .=Exec(i1, s1).intpos(m+k) by SCMPDS_5:47
      .=s1.intpos(m+k) by A21,SCMPDS_2:57
      .=s0.intpos(m+k) by A22,SCMPDS_2:58
      .=s.intpos(m+k) by SCMPDS_5:40
      .=s.DataLoc(s.PD,k) by SCMP_GCD:5
      .=f.(k+1) by A7,A20;
  end;
  abs(s0.BP+fr) <> n+cv by A2,A10;
  then
A23: DataLoc(s0.BP,fr) <> intpos(n+cv) by ZFMISC_1:33;
  n+cv <> pp by A2,A3,XREAL_1:8;
  then
A24: intpos(n+cv) <> PP by ZFMISC_1:33;
A25: Hi is_halting_on s by SCMPDS_6:35;
A26: Hi is_closed_on s by SCMPDS_6:34;
A27:  s2.PP = (Initialize s2).PP by SCMPDS_5:40;
A28:  s2.BP = (Initialize s2).BP by SCMPDS_5:40;
A29:  s2.PD = (Initialize s2).PD by SCMPDS_5:40;
A30: s2.PP=Exec(i1, s1).PP by SCMPDS_5:47
    .=pD by SCMPDS_2:57;
  then FD is_halting_on Initialize s2 by A1,A2,A3,A4,A5,A16,A13,Th72,A27,A28,
A29;
  then
A31: FD is_halting_on s2 by SCMPDS_6:140;
A32: s2.DataLoc(s2.BP,cv)=s2.intpos(n+cv) by A16,SCMP_GCD:5
    .=Exec(i1, s1).intpos(n+cv) by SCMPDS_5:47
    .=s1.intpos(n+cv) by A24,SCMPDS_2:57
    .=s0.intpos(n+cv) by A23,SCMPDS_2:58
    .=s.intpos(n+cv) by SCMPDS_5:40
    .=len f by A6,SCMP_GCD:5;
A33:  s2.DataLoc(s2.BP,fr) = (Initialize s2).DataLoc(s2.BP,fr) by SCMPDS_5:40;
A34:  s2.DataLoc(s2.BP,cv) = (Initialize s2).DataLoc(s2.BP,cv) by SCMPDS_5:40;
  FD is_closed_on Initialize s2 by A1,A2,A3,A4,A5,A16,A30,A13,Th72,A27,A28,A29;
  then FD is_closed_on s2 by SCMPDS_6:139;
  hence IExec(sum(sp,cv,fr,pp,pD),s).a = IExec(FD,s2).a1
   by A16,A26,A25,A31,Th49
    .= IExec(FD,Initialize s2).a1 by SCMPDS_5:48
    .= Sum f by A1,A2,A3,A4,A5,A16,A30,A13,A17,A32,A19,Th73,A27,A28,A29,A33,A34
;
end;

