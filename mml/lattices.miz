:: Introduction to Lattice Theory
::  by Stanis{\l}aw \.Zukowski
::
:: Received April 14, 1989
:: Copyright (c) 1990 Association of Mizar Users

environ

 vocabularies BINOP_1, BOOLE, FINSUB_1, FUNCT_1, SUBSET_1, LATTICES;
 notations XBOOLE_0, ZFMISC_1, SUBSET_1, STRUCT_0, BINOP_1, FINSUB_1;
 constructors STRUCT_0, BINOP_1, FINSUB_1, XBOOLE_0;
 registrations FINSUB_1, STRUCT_0, SUBSET_1;
 requirements SUBSET, BOOLE;
 theorems TARSKI, ZFMISC_1, STRUCT_0, FINSUB_1;

begin

definition
  struct(1-sorted) /\-SemiLattStr
    (# carrier -> set, L_meet -> BinOp of the carrier #);
end;

definition
  struct (1-sorted) \/-SemiLattStr
    (# carrier -> set, L_join -> BinOp of the carrier #);
end;

definition
  struct (/\-SemiLattStr,\/-SemiLattStr) LattStr
    (# carrier -> set, L_join, L_meet -> BinOp of the carrier #);
end;

registration let D be non empty set, u be BinOp of D;
  cluster \/-SemiLattStr (# D, u #) -> non empty;
  coherence by STRUCT_0:def 1;
  cluster /\-SemiLattStr (# D, u #) -> non empty;
  coherence by STRUCT_0:def 1;
end;

registration let D be non empty set, u,n be BinOp of D;
  cluster LattStr (# D, u, n #) -> non empty;
  coherence by STRUCT_0:def 1;
end;

registration
  cluster strict non empty \/-SemiLattStr;
  existence
  proof
    consider u be BinOp of bool {};
    take \/-SemiLattStr (# bool {}, u #);
    thus thesis;
  end;
  cluster strict non empty /\-SemiLattStr;
  existence
  proof
    consider u be BinOp of bool {};
    take /\-SemiLattStr (# bool {}, u #);
    thus thesis;
  end;
  cluster strict non empty LattStr;
  existence
  proof
    consider u,n be BinOp of bool {};
    take LattStr (# bool {}, u, n #);
    thus thesis;
  end;
end;

definition let G be non empty \/-SemiLattStr,
               p, q be Element of G;
  func p"\/"q -> Element of G equals
    (the L_join of G).(p,q);
  coherence;
end;

definition let G be non empty /\-SemiLattStr,
               p, q be Element of G;
  func p"/\"q -> Element of G equals
    (the L_meet of G).(p,q);
  coherence;
end;

definition let G be non empty \/-SemiLattStr,
               p, q be Element of G;
  pred p [= q means :Def3:
    p"\/"q = q;
end;

Lm4: for uu,nn being BinOp of bool {},
         x,y being Element of LattStr(#bool {},uu,nn#) holds x = y
 proof
  let uu,nn be BinOp of bool {},
      x,y be Element of LattStr(#bool {},uu,nn#);
  x = {} & y = {} by TARSKI:def 1,ZFMISC_1:1;
  hence thesis;
 end;

Lm5: for n being BinOp of bool {},
         x,y being Element of \/-SemiLattStr (#bool {}, n#) holds x = y
 proof
   let n be BinOp of bool {};
   let x,y be Element of \/-SemiLattStr (#bool {}, n#);
   x = {} & y = {} by TARSKI:def 1,ZFMISC_1:1;
   hence thesis;
 end;

Lm6: for n being BinOp of bool {},
         x,y being Element of /\-SemiLattStr (#bool {}, n#) holds x = y
 proof
   let n be BinOp of bool {};
   let x,y be Element of /\-SemiLattStr (#bool {}, n#);
   x = {} & y = {} by TARSKI:def 1,ZFMISC_1:1;
   hence thesis;
 end;

definition let IT be non empty \/-SemiLattStr;
  attr IT is join-commutative means :Def4:
   for a,b being Element of IT holds a"\/"b = b"\/"a;
  attr IT is join-associative means :Def5:
   for a,b,c being Element of IT holds
     a"\/"(b"\/"c) = (a"\/"b)"\/"c;
end;

definition let IT be non empty /\-SemiLattStr;
  attr IT is meet-commutative means :Def6:
   for a,b being Element of IT holds a"/\"b = b"/\"a;
  attr IT is meet-associative means :Def7:
   for a,b,c being Element of IT holds a"/\"(b"/\"c) = (a"/\"b)"/\"c;
end;

definition let IT be non empty LattStr;
  attr IT is meet-absorbing means :Def8:
   for a,b being Element of IT holds (a"/\"b)"\/"b = b;
  attr IT is join-absorbing means :Def9:
   for a,b being Element of IT holds a"/\"(a"\/"b)=a;
end;

definition let IT be non empty LattStr;
  attr IT is Lattice-like means :Def10:
    IT is join-commutative join-associative meet-absorbing
          meet-commutative meet-associative join-absorbing;
end;

registration
  cluster Lattice-like ->
          join-commutative join-associative meet-absorbing
          meet-commutative meet-associative join-absorbing
          (non empty LattStr);
  coherence by Def10;
  cluster join-commutative join-associative meet-absorbing
          meet-commutative meet-associative join-absorbing
          -> Lattice-like (non empty LattStr);
  coherence by Def10;
end;

registration
  cluster strict join-commutative join-associative (non empty \/-SemiLattStr);
  existence
   proof
    consider u being BinOp of bool {};
    take GGj = \/-SemiLattStr(#bool {},u#);
A1: for x,y being Element of GGj holds x"\/"y = y"\/"x by Lm5;
    for x,y,z being Element of GGj holds
      x"\/"(y"\/"z) = (x"\/"y)"\/"z by Lm5;
    hence thesis by Def4,Def5,A1;
   end;
  cluster strict meet-commutative meet-associative (non empty /\-SemiLattStr);
  existence
   proof
    consider u being BinOp of bool {};
    take GGm = /\-SemiLattStr(#bool {},u#);
A1: for x,y being Element of GGm holds x"/\"y = y"/\"x by Lm6;
    for x,y,z being Element of GGm holds
      x"/\"(y"/\"z) = (x"/\"y)"/\"z by Lm6;
    hence thesis by Def6,Def7,A1;
   end;
  cluster strict Lattice-like (non empty LattStr);
  existence
  proof
    consider u,n being BinOp of bool {};
    take GG = LattStr(#bool {},u,n#);
A1: for x,y being Element of GG holds x"\/"y = y"\/"x by Lm4;
A2: for x,y,z being Element of GG holds
      x"\/"(y"\/"z) = (x"\/"y)"\/"z by Lm4;
A3: for x,y being Element of GG holds (x"/\"y)"\/"y = y by Lm4;
A4: for x,y being Element of GG holds x"/\"y = y"/\"x by Lm4;
A5: for x,y,z being Element of GG holds
      x"/\"(y"/\"z) = (x"/\"y)"/\"z by Lm4;
A6: for x,y being Element of GG holds x"/\"(x"\/"y) = x by Lm4;
    GG is join-commutative join-associative meet-absorbing
      meet-commutative meet-associative join-absorbing
        by Def4,Def5,Def6,Def7,Def8,Def9,A1,A2,A3,A4,A5,A6;
    hence thesis by Def10;
   end;
end;

definition
  mode Lattice is Lattice-like (non empty LattStr);
end;

definition let L be join-commutative (non empty \/-SemiLattStr),
               a, b be Element of L;
  redefine func a"\/"b;
  commutativity by Def4;
end;

definition let L be meet-commutative (non empty /\-SemiLattStr),
               a, b be Element of L;
  redefine func a"/\"b;
  commutativity by Def6;
end;

definition let IT be non empty LattStr;
  attr IT is distributive means :Def11:
   for a,b,c being Element of IT
    holds a"/\"(b"\/"c) = (a"/\"b)"\/"(a"/\"c);
end;

definition let IT be non empty LattStr;
  attr IT is modular means :Def12:
   for a,b,c being Element of IT st a [= c
    holds a"\/"(b"/\"c) = (a"\/"b)"/\"c;
end;

definition let IT be non empty /\-SemiLattStr;
  attr IT is lower-bounded means :Def13:
   ex c being Element of IT st
    for a being Element of IT holds c"/\"a = c & a"/\"c = c;
end;

definition let IT be non empty \/-SemiLattStr;
  attr IT is upper-bounded means :Def14:
   ex c being Element of IT st
    for a being Element of IT holds c"\/"a = c & a"\/"c = c;
end;

AA: for n,u being BinOp of bool {} holds
  LattStr (#bool {},n,u#) is Lattice
  proof
    let n,u be BinOp of bool {};
    set G = LattStr (#bool {},n,u#);
    for x,y being Element of G holds x"\/"y = y"\/"x by Lm4; then
B1: G is join-commutative by Def4;
    for x,y,z being Element of G holds
      x"\/"(y"\/"z) = (x"\/"y)"\/"z by Lm4; then
B2: G is join-associative by Def5;
    for x,y being Element of G holds (x"/\"y)"\/"y = y by Lm4; then
B3: G is meet-absorbing by Def8;
    for x,y being Element of G holds x"/\"y = y"/\"x by Lm4; then
B4: G is meet-commutative by Def6;
    for x,y,z being Element of G holds x"/\"(y"/\"z) = (x"/\"y)"/\"z by Lm4;
    then B5:G is meet-associative by Def7;
    for x,y being Element of G holds x"/\"(x"\/"y) = x by Lm4; then
    G is join-absorbing by Def9;
    hence thesis by Def10,B1,B2,B3,B4,B5;
  end;

registration
  cluster strict distributive lower-bounded upper-bounded modular Lattice;
  existence
   proof
    consider uu,nn being BinOp of bool {};
    set GG=LattStr(#bool {},uu,nn#);
    reconsider GG as Lattice by AA;
Lm18: for x,y,z being Element of GG holds
     x [= z implies x"\/"(y"/\"z) = (x"\/"y)"/\"z by Lm4;
A1: GG is modular by Def12,Lm18;
    reconsider 0_GG={}, D = {} as Element of GG by ZFMISC_1:def 1;
A3: for x being Element of GG holds
      0_GG"/\"x = 0_GG & x"/\"0_GG = 0_GG by Lm4;
A2: GG is lower-bounded by Def13,A3;
Lm17: for x,y,z being Element of GG holds
        x"/\"(y"\/"z) = (x"/\"y)"\/"(x"/\"z) by Lm4;
Lm20: for x being Element of GG holds D"\/"x = D & x"\/"D = D by Lm4;
Lm21: GG is distributive by Def11,Lm17;
    GG is upper-bounded by Def14,Lm20;
    hence thesis by A1,A2,Lm21;
   end;
end;

definition
  mode D_Lattice is distributive Lattice;
  mode M_Lattice is modular Lattice;
  mode 0_Lattice is lower-bounded Lattice;
  mode 1_Lattice is upper-bounded Lattice;
end;

Lm22: for n,u being BinOp of bool {} holds
  LattStr (#bool {},n,u#) is 0_Lattice
  proof
    let n,u be BinOp of bool {};
    set G = LattStr (#bool {},n,u#);
    reconsider G as Lattice by AA;
    reconsider D={} as Element of G by ZFMISC_1:def 1;
    for x being Element of G holds D"/\"x = D & x"/\"D = D by Lm4;
    hence thesis by Def13;
  end;
Lm23: for n,u being BinOp of bool {} holds
  LattStr (#bool {},n,u#) is 1_Lattice
  proof
    let n,u be BinOp of bool {};
    set G = LattStr (#bool {},n,u#);
    reconsider G as Lattice by AA;
    reconsider D={} as Element of G by ZFMISC_1:def 1;
    for x being Element of G holds D"\/"x = D & x"\/"D = D by Lm4;
    hence thesis by Def14;
  end;

definition let IT be non empty LattStr;
  attr IT is bounded means :Def15:
    IT is lower-bounded upper-bounded;
end;

registration
  cluster lower-bounded upper-bounded -> bounded (non empty LattStr);
  coherence by Def15;
  cluster bounded -> lower-bounded upper-bounded (non empty LattStr);
  coherence by Def15;
end;

registration
  cluster bounded strict Lattice;
  existence
   proof
    consider uu,nn being BinOp of bool {};
    set G=LattStr(#bool {},uu,nn#);
    reconsider G as Lattice by AA;
    G is 0_Lattice & G is 1_Lattice by Lm23,Lm22;
    then G is bounded by Def15;
    hence thesis;
   end;
end;

definition
  mode 01_Lattice is bounded Lattice;
end;

definition let L be non empty /\-SemiLattStr;
  assume A1: L is lower-bounded;
  func Bottom L -> Element of L means :Def16:
   for a being Element of L holds it "/\" a = it & a "/\" it = it;
  existence by A1,Def13;
  uniqueness
    proof
     let c1,c2 be Element of L such that
A2:  for a being Element of L holds c1"/\"a = c1 & a"/\"c1 = c1 and
A3:  for a being Element of L holds c2"/\"a = c2 & a"/\"c2 = c2;
     thus c1 = c2"/\"c1 by A2
            .= c2 by A3;
    end;
end;

definition let L be non empty \/-SemiLattStr;
  assume A1: L is upper-bounded;
  func Top L -> Element of L means :Def17:
   for a being Element of L holds it "\/" a = it & a "\/" it = it;
  existence by A1,Def14;
  uniqueness
    proof
     let c1,c2 be Element of L such that
A2:  for a being Element of L holds c1"\/"a = c1 & a"\/"c1 = c1 and
A3:  for a being Element of L holds c2"\/"a = c2 & a"\/"c2 = c2;
     thus c1 = c2"\/"c1 by A2
            .= c2 by A3;
    end;
end;

definition let L be non empty LattStr,
               a, b be Element of L;
  pred a is_a_complement_of b means :Def18:
   a"\/"b = Top L & b"\/"a = Top L & a"/\"b = Bottom L & b"/\"a = Bottom L;
end;

definition let IT be non empty LattStr;
  attr IT is complemented means :Def19:
   for b being Element of IT
    ex a being Element of IT st a is_a_complement_of b;
end;

registration
  cluster bounded complemented strict Lattice;
  existence
   proof
    consider n,u being BinOp of bool {};
    reconsider GG = LattStr (#bool {},n,u#) as strict Lattice by AA;
    take GG;
    GG is 0_Lattice & GG is 1_Lattice by Lm22,Lm23;
    hence GG is bounded by Def15;
    thus GG is complemented
    proof let b be Element of GG;
      consider a being Element of GG;
      take a;
      thus a"\/"b = Top GG & b"\/"a = Top GG by Lm4;
      thus a"/\"b = Bottom GG & b"/\"a = Bottom GG by Lm4;
    end;
    thus thesis;
   end;
end;

definition
  mode C_Lattice is complemented 01_Lattice;
end;

definition let IT be non empty LattStr;
  attr IT is Boolean means :Def20:
   IT is bounded complemented distributive;
end;

registration
  cluster Boolean -> bounded complemented distributive (non empty LattStr);
  coherence by Def20;
  cluster bounded complemented distributive -> Boolean (non empty LattStr);
  coherence by Def20;
end;

registration
  cluster Boolean strict Lattice;
  existence
   proof
    consider n, u being BinOp of bool {};
    reconsider G = LattStr (#bool {},n,u#) as strict Lattice by AA;
Lm24: G is complemented
    proof
     let b be Element of G;
     take b;
     thus b"\/"b = Top G & b"\/"b = Top G by Lm4;
     thus b"/\"b = Bottom G & b"/\"b = Bottom G by Lm4;
    end;
    G is 0_Lattice & G is 1_Lattice by Lm22,Lm23; then
    reconsider G as C_Lattice by Lm24,Def15;
    for x,y,z being Element of G holds
      x"/\"(y"\/"z) = (x"/\"y)"\/"(x"/\"z) by Lm4; then
    G is distributive by Def11; then
    G is Boolean by Def20;
    hence thesis;
   end;
end;

definition
  mode B_Lattice is Boolean Lattice;
end;

canceled 16;

theorem Th17:
  for L being meet-absorbing join-absorbing meet-commutative
          (non empty LattStr),
      a being Element of L holds
    a "\/" a = a
  proof
    let L be meet-absorbing join-absorbing meet-commutative
          (non empty LattStr),
        a be Element of L;
    thus a"\/"a = ( a "/\" ( a"\/"a ) ) "\/" a by Def9
             .= a by Def8;
  end;

theorem
  for L being meet-absorbing join-absorbing meet-commutative
          (non empty LattStr),
      a being Element of L holds
    a "/\" a = a
  proof
    let L be meet-absorbing join-absorbing meet-commutative
          (non empty LattStr),
        a be Element of L;
    a"/\"( a"\/"a ) = a by Def9;
    hence thesis by Th17;
  end;

theorem Th19:
  for L being Lattice holds
  (for a,b,c being Element of L holds a"/\"(b"\/"c) = (a"/\"b)"\/"(a"/\"c))
                         iff
  (for a,b,c being Element of L holds a"\/"(b"/\"c) = (a"\/"b)"/\"(a"\/"c))
    proof
      let L be Lattice;
       hereby
          assume A1:for a,b,c be Element of L holds
            a"/\"(b"\/"c)=(a"/\"b)"\/"(a"/\"c);
          let a,b,c be Element of L;
          thus a"\/"(b"/\"c)=(a"\/"(c"/\"a))"\/"(c"/\"b) by Def8
            .=a"\/"((c"/\"a)"\/"(c"/\"b)) by Def5
            .=a"\/"((a"\/"b)"/\"c) by A1
            .=((a"\/"b)"/\"a)"\/"((a"\/"b)"/\"c) by Def9
            .=(a"\/"b)"/\"(a"\/"c) by A1;
        end;
        assume A2:for a,b,c be Element of L holds
          a"\/"(b"/\"c)=(a"\/"b)"/\"(a"\/"c);
        let a,b,c be Element of L;
        thus a"/\"(b"\/"c)=(a"/\"(c"\/"a))"/\"(c"\/"b) by Def9
              .=a"/\"((c"\/"a)"/\"(c"\/"b)) by Def7
              .=a"/\"((a"/\"b)"\/"c) by A2
              .=((a"/\"b)"\/"a)"/\"((a"/\"b)"\/"c) by Def8
              .=(a"/\"b)"\/"(a"/\"c) by A2;
    end;

canceled;

theorem Th21:
  for L being meet-absorbing join-absorbing (non empty LattStr),
      a, b being Element of L holds
    a [= b iff a"/\"b = a
  proof
    let L be meet-absorbing join-absorbing (non empty LattStr),
        a, b be Element of L;
    a [= b iff a"\/"b = b by Def3;
    hence thesis by Def8,Def9;
  end;

theorem Th22:
  for L being meet-absorbing join-absorbing join-associative meet-commutative
            (non empty LattStr),
      a, b being Element of L holds
    a [= a"\/"b
  proof
    let L be meet-absorbing join-absorbing join-associative meet-commutative
           (non empty LattStr),
        a, b be Element of L;
    thus a"\/"( a"\/"b) = (a"\/"a)"\/"b by Def5
                    .= a"\/"b by Th17;
  end;

theorem Th23:
  for L being meet-absorbing meet-commutative (non empty LattStr),
      a, b being Element of L holds
    a"/\"b [= a
  proof
    let L be meet-absorbing meet-commutative (non empty LattStr),
        a, b be Element of L;
    thus ( a"/\"b )"\/"a = a by Def8;
  end;

definition
  let L be meet-absorbing join-absorbing meet-commutative (non empty LattStr),
      a, b be Element of L;
  redefine pred a [= b;
  reflexivity
  proof let a be Element of L;
    thus a"\/"a = a by Th17;
  end;
end;

canceled;

theorem
  for L being join-associative (non empty \/-SemiLattStr),
      a, b, c being Element of L holds
    a [= b & b [= c implies a [= c
  proof
    let L be join-associative (non empty \/-SemiLattStr),
        a, b, c be Element of L;
    assume a"\/"b = b & b"\/"c = c;
    hence a"\/"c = c by Def5;
  end;

theorem Th26:
  for L being join-commutative (non empty \/-SemiLattStr),
      a, b being Element of L holds
    a [= b & b [= a implies a=b
  proof
    let L be join-commutative (non empty \/-SemiLattStr),
        a, b be Element of L;
    assume a"\/"b = b & b"\/"a =a;
    hence thesis;
  end;

theorem Th27:
for L being meet-absorbing join-absorbing meet-associative (non empty LattStr),
    a, b, c being Element of L holds
  a [= b implies a"/\"c [= b"/\"c
   proof
let L be meet-absorbing join-absorbing meet-associative (non empty LattStr),
    a, b, c be Element of L;
     assume a [= b;
     hence (a"/\"c)"\/"(b"/\"c) = ((a"/\"b)"/\"c)"\/"(b"/\"c) by Th21
       .= (a"/\"(b"/\"c))"\/"(b"/\"c) by Def7
       .= b"/\"c by Def8;
   end;

canceled;

theorem
  for L being Lattice holds
  (for a,b,c being Element of L holds
       (a"/\"b)"\/"(b"/\"c)"\/"(c"/\"a) = (a"\/"b)"/\"(b"\/"c)"/\"(c"\/"a))
   implies L is distributive
   proof
     let L be Lattice;
     assume
A1:   for a,b,c being Element of L holds
          (a"/\"b)"\/"(b"/\"c)"\/"(c"/\"a) = (a"\/"b)"/\"(b"\/"c)"/\"(c"\/"a);
A2:    now let a,b,c be Element of L;
        assume A3: c [= a;
        thus a"/\"(b"\/"c) = (b"\/"c)"/\"(a"/\"(a"\/"b)) by Def9
       .= (a"\/"b)"/\"((b"\/"c)"/\"a) by Def7
       .= (a"\/"b)"/\"((b"\/"c)"/\"(c"\/"a)) by A3,Def3
       .= (a"\/"b)"/\"(b"\/"c)"/\"(c"\/"a) by Def7
       .= (a"/\"b)"\/"(b"/\"c)"\/"(c"/\"a) by A1
       .= (a"/\"b)"\/"((b"/\"c)"\/"(c"/\"a)) by Def5
       .= (a"/\"b)"\/"((b"/\"c)"\/"c) by A3,Th21
       .= (a"/\"b)"\/"c by Def8;
      end;
     let a,b,c be Element of L;
A4:   (a"/\"b)"\/"(c"/\"a) [= a
       proof
         thus ((a"/\"b)"\/"(c"/\"a))"\/"a = (a"/\"b)"\/"((c"/\"a)"\/"a) by Def5
            .= (a"/\"b)"\/"a by Def8
            .= a by Def8;
       end;
     thus a"/\"(b"\/"c)
       = (a"/\"(c"\/"a))"/\"(b"\/"c) by Def9
      .= a"/\"((c"\/"a)"/\"(b"\/"c)) by Def7
      .= (a"/\"(a"\/"b))"/\"((c"\/"a)"/\"(b"\/"c)) by Def9
      .= a"/\"((a"\/"b)"/\"((b"\/"c)"/\"(c"\/"a))) by Def7
      .= a"/\"((a"\/"b)"/\"(b"\/"c)"/\"(c"\/"a)) by Def7
      .= a"/\"((b"/\"c)"\/"(a"/\"b)"\/"(c"/\"a)) by A1
      .= a"/\"((b"/\"c)"\/"((a"/\"b)"\/"(c"/\"a))) by Def5
      .= (a"/\"(b"/\"c))"\/"((a"/\"b)"\/"(c"/\"a)) by A2,A4
      .= (a"/\"b"/\"c)"\/"((a"/\"b)"\/"(c"/\"a)) by Def7
      .= ((a"/\"b"/\"c)"\/"(a"/\"b))"\/"(c"/\"a) by Def5
      .= (a"/\"b)"\/"(a"/\"c) by Def8;
   end;

reserve L for D_Lattice;
reserve a, b, c for Element of L;

canceled;

theorem Th31:
  a"\/"(b"/\"c) = (a"\/"b)"/\"(a"\/"c)
   proof
        for a,b,c holds a"/\"(b"\/"c) = (a"/\"b)"\/"(a"/\"c) by Def11;
     hence thesis by Th19;
   end;

theorem Th32:
  c"/\"a = c"/\"b & c"\/"a = c"\/"b implies a=b
    proof
      assume that
A1:           c"/\"a = c"/\"b and
A2:           c"\/"a = c"\/"b;
      thus a = a"/\"( c"\/"a ) by Def9
            .= ( b"/\"c )"\/"( b"/\"a ) by A1,A2,Def11
            .= b"/\"( c"\/"a ) by Def11
            .= b by A2,Def9;
    end;

canceled;

theorem
  (a"\/"b)"/\"(b"\/"c)"/\"(c"\/"a) = (a"/\"b)"\/"(b"/\"c)"\/"(c"/\"a)
   proof
     thus (a"\/"b)"/\"(b"\/"c)"/\"(c"\/"a)
      = (((a"\/"b)"/\"(b"\/"c))"/\"c)"\/"(((a"\/"b)"/\"(b"\/"c))"/\"a) by Def11
     .= ((a"\/"b)"/\"((b"\/"c)"/\"c))"\/"(((a"\/"b)"/\"(b"\/"c))"/\"a) by Def7
     .= ((a"\/"b)"/\"c)"\/"(a"/\"((a"\/"b)"/\"(b"\/"c))) by Def9
     .= ((a"\/"b)"/\"c)"\/"((a"/\"(a"\/"b))"/\"(b"\/"c)) by Def7
     .= (c"/\"(a"\/"b))"\/"(a"/\"(b"\/"c)) by Def9
     .= ((c"/\"a)"\/"(c"/\"b))"\/"(a"/\"(b"\/"c)) by Def11
     .= ((a"/\"b)"\/"(c"/\"a))"\/"((c"/\"a)"\/"(b"/\"c)) by Def11
     .= (a"/\"b)"\/"((c"/\"a)"\/"((c"/\"a)"\/"(b"/\"c))) by Def5
     .= (a"/\"b)"\/"(((c"/\"a)"\/"(c"/\"a))"\/"(b"/\"c)) by Def5
     .= (a"/\"b)"\/"((b"/\"c)"\/"(c"/\"a)) by Th17
     .= (a"/\"b)"\/"(b"/\"c)"\/"(c"/\"a) by Def5;
   end;

registration
  cluster distributive -> modular Lattice;
  coherence
  proof let L be Lattice;
    assume A1: L is distributive;
    let a,b,c be Element of L;
    assume a"\/"c = c;
    hence a"\/"(b"/\"c) = (a"\/"b)"/\"c by A1,Th31;
  end;
end;

canceled 4;

theorem Th39:
  for L being 0_Lattice,
      a being Element of L holds
    Bottom L "\/" a = a
  proof
    let L be 0_Lattice,
        a be Element of L;
    thus Bottom L"\/"a = ( Bottom L"/\"a )"\/"a by Def16
                .= a by Def8;
  end;

theorem
  for L being 0_Lattice,
      a being Element of L holds
    Bottom L "/\" a = Bottom L by Def16;

theorem Th41:
  for L being 0_Lattice,
      a being Element of L holds
    Bottom L [= a
  proof
    let L be 0_Lattice,
        a be Element of L;
    Bottom L [= Bottom L "\/" a by Th22;
    hence thesis by Th39;
  end;

canceled;

theorem Th43:
  for L being 1_Lattice,
      a being Element of L holds
    Top L"/\"a = a
  proof
    let L be 1_Lattice,
        a be Element of L;
    thus Top L"/\"a = ( Top L"\/"a )"/\"a by Def17
                .= a by Def9;
  end;

theorem
  for L being 1_Lattice,
      a being Element of L holds
    Top L"\/"a = Top L by Def17;

theorem
  for L being 1_Lattice,
      a being Element of L holds
    a [= Top L
  proof
    let L be 1_Lattice,
        a be Element of L;
    Top L"/\"a [= Top L by Th23;
    hence thesis by Th43;
  end;

definition let L be non empty LattStr,
               x be Element of L;
  assume A1: L is complemented D_Lattice;
  func x` -> Element of L means :Def21:
   it is_a_complement_of x;
  existence by A1,Def19;
  uniqueness
    proof
     let a,b be Element of L such that
A2:           a is_a_complement_of x and
A3:           b is_a_complement_of x;
A4:  a"\/"x = Top L & x"\/"a = Top L & a"/\"x = Bottom L & x"/\"a = Bottom
L by A2,Def18;
        b"\/"x = Top L & b"/\"x = Bottom L & x"\/"b = Top L & x"/\"b = Bottom
L by A3,Def18;
     hence thesis by A1,A4,Th32;
    end;
end;

reserve L for B_Lattice;
reserve a, b for Element of L;

canceled;

theorem Th47:
  a`"/\"a = Bottom L
   proof a` is_a_complement_of a by Def21;
    hence thesis by Def18;
   end;

theorem Th48:
  a`"\/"a = Top L
   proof a` is_a_complement_of a by Def21;
    hence thesis by Def18;
   end;

theorem Th49:
  a`` = a
   proof
        a`` is_a_complement_of a` by Def21;
then A1:   a``"\/"a` = Top L & a``"/\"a` = Bottom L by Def18;
        a` is_a_complement_of a by Def21;
     then a"\/"a` =Top L & a "/\"a`= Bottom L by Def18;
     hence a``= a by A1,Th32;
   end;

theorem Th50:
  ( a"/\"b )` = a`"\/" b`
    proof
A1:    (a`"\/"b`)"\/"(a"/\"b) = a`"\/"(b`"\/"(a"/\"b)) by Def5
       .= a`"\/"((b`"\/"a)"/\"(b`"\/"b)) by Th31
       .= a`"\/"((b`"\/"a)"/\"Top L) by Th48
       .= (b`"\/"a)"\/"a` by Th43
       .= b`"\/"(a"\/"a`) by Def5
       .= b`"\/"Top L by Th48
       .= Top L by Def17;
         (a`"\/"b`)"/\"(a"/\"b) = ((a`"\/"b`)"/\"a)"/\"b by Def7
       .= ((a`"/\"a)"\/"(b`"/\"a))"/\"b by Def11
       .= (Bottom L"\/"(b`"/\"a))"/\"b by Th47
       .= b"/\"(b`"/\"a) by Th39
       .= (b"/\"b`)"/\"a by Def7
       .= Bottom L"/\"a by Th47
       .= Bottom L by Def16;
      then a`"\/"b` is_a_complement_of a"/\"b by A1,Def18;
      hence thesis by Def21;
    end;

theorem
  ( a"\/"b )` = a`"/\" b`
  proof
    thus (a"\/"b)` = (a``"\/"b)` by Th49
                  .= (a``"\/"b``)` by Th49
                  .= (a`"/\"b`)`` by Th50
                  .= a`"/\"b` by Th49;
  end;

theorem Th52:
  b"/\"a = Bottom L iff b [= a`
    proof
      thus b"/\"a = Bottom L implies b [= a`
        proof
          assume A1: b"/\"a = Bottom L;
             b = b"/\"Top L by Th43
           .= b"/\"(a"\/"a`) by Th48
           .= Bottom L"\/"(b"/\"a`) by A1,Def11
           .= b"/\"a` by Th39;
          then b"\/"a` = a` by Def8;
          hence b [= a` by Def3;
        end;
      thus thesis
        proof
          assume b [= a`;
          then b"/\"a [= a`"/\"a by Th27;
then A2:        b"/\"a [= Bottom L by Th47;
             Bottom L [= b"/\"a by Th41;
          hence b"/\"a = Bottom L by A2,Th26;
        end;
    end;

theorem
  a [= b implies b` [= a`
  proof
    assume a [= b;
    then b`"/\"a [= b`"/\"b by Th27;
then A1:    b`"/\"a [= Bottom L by Th47;
    Bottom L [= b`"/\"a by Th41;
    then b `"/\"a = Bottom L by A1,Th26;
    hence b` [= a` by Th52;
  end;
