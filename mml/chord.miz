:: Chordal Graphs
::  by Broderick Arneson and Piotr Rudnicki
::
:: Received August 18, 2006
:: Copyright (c) 2006 Association of Mizar Users

environ

 vocabularies ARYTM, ARYTM_1, BOOLE, CARD_1, CAT_1, ORDINAL2, FINSET_1,
      FUNCT_1, FINSEQ_1, FINSEQ_4, GRAPH_1, GLIB_000, GLIB_001, GLIB_002,
      MATRIX_2, MSAFREE2, XREAL_0, NAT_1, INT_1, PRE_TOPC, REALSET1, RELAT_1,
      RELAT_2, CHORD, TOPGEN_1, SQUARE_1, GRAPH_2, MEMBERED, BHSP_3;
 notations TARSKI, XBOOLE_0, CQC_SIM1, SUBSET_1, ORDINAL1, XCMPLX_0, XXREAL_0,
      DOMAIN_1, RELAT_1, FUNCT_1, FUNCT_2, FINSEQ_1, CARD_1, FINSET_1, INT_1,
      NAT_1, GLIB_000, GLIB_001, GLIB_002, ZFMISC_1, CQC_LANG, ABIAN, ENUMSET1,
      FINSEQ_4, NUMBERS, GRAPH_2, PRE_CIRC, MEMBERED;
 constructors DOMAIN_1, NAT_1, AMISTD_2, BINARITH, FINSEQ_4, GLIB_001,
      GLIB_002, CQC_SIM1, GRAPH_2, PRE_CIRC, XXREAL_0;
 registrations RELSET_1, NAT_1, XBOOLE_0, MEMBERED, GLIB_000, FINSEQ_1,
      GLIB_001, GLIB_002, SUBSET_1, FINSET_1, INT_1, ABIAN, JORDAN1D, ORDINAL1,
      RELAT_1, PRE_CIRC, PNPROC_1, HEYTING3;
 requirements ARITHM, BOOLE, NUMERALS, REAL, SUBSET;
 definitions TARSKI, XBOOLE_0, GLIB_000, GLIB_001, GLIB_002;
 theorems FINSEQ_1, FUNCT_1, GLIB_000, GLIB_001, GLIB_002, GRAPH_2, GRAPH_5,
      GRAPH_3, TREES_1, HEYTING3, INT_1, JORDAN12, NAT_1, ORDINAL1, REAL_1,
      RELAT_1, TARSKI, TRIANG_1, XBOOLE_0, XBOOLE_1, FINSET_1, CARD_1,
      CQC_LANG, FUNCT_2, FINSEQ_3, FINSEQ_4, ZFMISC_1, ABIAN, SCMFSA9A, CARD_2,
      ENUMSET1, FINSEQ_2, XREAL_1, CQC_THE1, CQC_SIM1, PRE_CIRC, MEMBERED,
      FINSEQ_5;
 schemes BINARITH, NAT_1, GRAPH_5, FUNCT_2, FRAENKEL;

begin :: Preliminaries

theorem Th1: :: Nat00
for n being non zero natural number holds n-1 is natural number & 1 <= n
proof let n be non zero Nat;
   0 < n by NAT_1:19; then
A1: 0+1 <= n by NAT_1:38; then
   0+1-1 <= n-1 by XREAL_1:11;
   then n-1 in NAT by INT_1:16;
  hence n-1 is Nat by ORDINAL1:def 13;
  thus 1 <= n by A1;
end;

theorem Th2: :: Nat02
for n being odd natural number holds n-1 is natural number & 1 <= n
proof let n be odd Nat;
   consider k being Element of NAT such that
A1: n = 2*k + 1 by SCMFSA9A:1;
   0 <= 2*k by NAT_1:18; then
A2: 0+1 <= 2*k+1 by XREAL_1:9;
  thus n-1 is Nat by A1;
  thus 1 <= n by A1,A2;
end;

Lm1:
for a,b,c being Integer st a+2 < b holds c-b+1 + 2 < c-a+1
proof let a,b,c be Integer such that A1: a+2 < b;
   assume c-b+1 + 2 >= c-a+1; then
   c-b+3-3 >= c-a + 1 -3 by XREAL_1:11; then
   c - b >= c - (a+2);
  hence contradiction by A1,XREAL_1:12;
end;

theorem Th3: :: EvenOdd02
for n,m being odd Integer st n < m holds n <= m-2
proof let n,m be odd Integer such that A1: n < m;
    n+1 <= m by A1,INT_1:20; then
    n+1+(-1) <= m+(-1) by XREAL_1:9; then
    n < m-1 by REAL_1:def 5; then
    n+1 <= m-1 by INT_1:20; then
    n+1+(-1) <= m-1+(-1) by XREAL_1:9;
    hence n <= m-2;
end;

theorem Th4:  :: EvenOdd03:
for n,m being odd Integer st m < n holds m+2 <= n
proof let n,m be odd Integer such that A1: m < n;
    m+1 <= n by A1,INT_1:20; then
    m+1 < n by REAL_1:def 5; then
    m+1+1 <= n by INT_1:20;
  hence m+2 <= n;
end;

theorem Th5: :: EvenOdd04:
for n being odd natural number st 1 <> n
  ex m being odd natural number st m+2 = n
proof let n being odd Nat; assume
A1: 1 <> n;
   1 <= n by HEYTING3:1; then
   2*0+1 < n by A1, REAL_1:def 5; then
   1+2 <= n by Th4; then
   1+2-2 <= n-2 by XREAL_1:11; then
   0 <= n-2*1 by XREAL_1:2; then
   n-2*1 in NAT by INT_1:16; then
 reconsider m = n-2 as odd Nat by ORDINAL1:def 13;
 take m;
 thus m+2 = n;
end;

theorem Th6: :: Odd100
for n being odd natural number st n<=2 holds n=1
proof let n be odd Nat such that A1: n<=2;
  n <> 2*1; then n < 1+1 by A1,REAL_1:def 5; then
  n <= 1 & n >= 1 by NAT_1:38,HEYTING3:1;
  hence n = 1 by XREAL_1:1;
end;

theorem Th7: :: Odd101
for n being odd natural number st n<=4 holds n=1 or n=3
proof let n be odd Nat such that A1: n<=4;
  n<>2*2; then n<3+1 by A1,REAL_1:def 5; then A2: n<=3 by NAT_1:38;
  per cases by A2,REAL_1:def 5;
  suppose n=3; hence thesis; end;
  suppose n<2+1; then n<=2 by NAT_1:38;
    hence thesis by Th6; end;
end;

theorem Th8: :: Odd102
for n being odd natural number st n<=6 holds n=1 or n=3 or n=5
proof let n be odd Nat such that A1: n<=6;
  n<>2*3; then n<5+1 by A1,REAL_1:def 5; then A2:n<=5 by NAT_1:38;
  per cases by A2,REAL_1:def 5;
  suppose n=5; hence thesis; end;
  suppose n<4+1; then n<=4 by NAT_1:38;
    hence thesis by Th7; end;
end;

theorem
for n being odd natural number st n<=8 holds n=1 or n=3 or n=5 or n=7
proof let n be odd Nat such that A1: n<=8;
  n<>2*4; then n<7+1 by A1,REAL_1:def 5; then A2:n<=7 by NAT_1:38;
  per cases by A2,REAL_1:def 5;
  suppose n=7; hence thesis; end;
  suppose n<6+1; then n<=6 by NAT_1:38;
    hence thesis by Th8; end;
end;

theorem Th10: :: Even100
for n being even natural number st n<=1 holds n=0
proof let n be even Nat such that A1: n<=1;
  n<>2*0+1; then n<0+1 by A1,REAL_1:def 5; then
  n<=0 & n>=0 by NAT_1:38,NAT_1:18;
  hence n=0 by XREAL_1:1;
end;

theorem Th11: :: Even101
for n being even natural number st n<=3 holds n=0 or n=2
proof let n be even Nat such that A1: n<=3;
  n<>2*1+1; then n<2+1 by A1,REAL_1:def 5; then A2: n<=2 by NAT_1:38;
  per cases by A2,REAL_1:def 5;
  suppose n=2; hence thesis; end;
  suppose n<1+1; then n<=1 by NAT_1:38;
    hence thesis by Th10; end;
end;

theorem Th12: :: Even102
for n being even natural number st n<=5 holds n=0 or n=2 or n=4
proof let n be even Nat such that A1: n<=5;
  n<>2*2+1; then n<4+1 by A1,REAL_1:def 5; then A2: n<=4 by NAT_1:38;
  per cases by A2,REAL_1:def 5;
  suppose n=4; hence thesis; end;
  suppose n<3+1; then n<=3 by NAT_1:38;
    hence thesis by Th11; end;
end;

theorem Th13: :: Even103
for n being even natural number st n<=7 holds n=0 or n=2 or n=4 or n=6
proof let n be even Nat such that A1: n<=7;
  n<>2*3+1; then n<6+1 by A1,REAL_1:def 5; then A2: n<=6 by NAT_1:38;
  per cases by A2,REAL_1:def 5;
  suppose n=6; hence thesis; end;
  suppose n<5+1; then n<=5 by NAT_1:38;
    hence thesis by Th12; end;
end;


Lm2: :: OddDiff00 :: also in lexbfs
for i,j being odd natural number st i <= j
  ex k being natural number st i+2*k = j
proof
    let i,j be odd Nat such that A1: i <= j;
    consider jjj being Nat such that
A2: j = i+jjj by A1,NAT_1:28;
A3: jjj in NAT by ORDINAL1:def 13;
    now assume jjj is odd; then
        reconsider jf=jjj as odd Nat;
        i+jf is even;
        hence contradiction by A2;
    end;
    then consider jj being Element of NAT such that
A4: 2*jj = jjj by A3, ABIAN:def 2;
    reconsider jj as Nat;
    take jj;
    thus i + 2*jj = j by A2,A4;
end;

theorem
for p being FinSequence, n being non zero natural number
 st p is one-to-one & n <= len p holds (p.n)..p = n
proof let S be FinSequence;
    let n be non zero Nat such that
A1: S is one-to-one and
A2: n <= len S;
    0+1 <= n by NAT_1:39; then
A3: n in dom S by A2,FINSEQ_3:27; then
A4: S.n in rng S by FUNCT_1:12;
    set m = (S.n)..S;
A5: m in dom S by A4,FINSEQ_4:30;
    S.m = S.n by A4,FINSEQ_4:29;
    hence n = m by A1,A3,A5,FUNCT_1:def 8;
end;

theorem Th15: :: Index01
for p being non empty FinSequence, T being non empty Subset of rng p
  ex x being set st x in T & for y being set st y in T holds x..p <= y..p
proof let S be non empty FinSequence; let T be non empty Subset of rng S;
    deffunc F(set) = $1..S;
    consider m being Element of T such that
A1: for y being Element of T holds F(m) <= F(y) from GRAPH_5:sch 2;
    take m;
    thus m in T;
    let y be set such that A2: y in T;
    thus m..S <= y..S by A1, A2;
end;

definition let p be FinSequence, n be natural number;
  func p.followSet(n) -> finite set equals
    rng (n,len p)-cut p;
  correctness;
end;

theorem Th16: :: Follow00
for p being FinSequence, x being set, n being natural number
 st x in rng p & n in dom p & p is one-to-one
  holds x in p.followSet(n) iff x..p >= n
proof
  let p be FinSequence, x be set, n be Nat such that
A1: x in rng p and
A2: n in dom p and
A3: p is one-to-one;

hereby assume x in p.followSet(n); then
    consider a being Element of NAT such that
A4: a in dom (n, len p)-cut p and
A5: ((n, len p)-cut p).a = x by FINSEQ_2:11;
     n in NAT by ORDINAL1:def 13; then
    consider k being Element of NAT such that
A6: k in dom p and
A7: p.k = ((n, len p)-cut p).a and k+1 = n+a and
A8: n <= k & k <= len p by A4, GRAPH_3:2;
A9: x..p in dom p by A1,FINSEQ_4:30;
    p.(x..p) = x by A1, FINSEQ_4:29;
  hence x..p >= n by A8, A3,A6,A9,A7,A5,FUNCT_1:def 8;
end;
assume
A10: x..p >= n;
A11: p.(x..p) = x by A1, FINSEQ_4:29;
    consider k being Nat such that
A12: x..p = n + k by A10,NAT_1:28;
A13: 1 <= n & n <= len p by A2,FINSEQ_3:27; then
A14: len ((n, len p)-cut p) + n = len p + 1 by GRAPH_2:def 1;
    x..p in dom p by A1,FINSEQ_4:30; then
    k + n <= len p by A12, FINSEQ_3:27; then
    k + n + (-n) <= len p + (-n) by XREAL_1:9; then
A15:    k + 1 <= len p - n + 1 by XREAL_1:9;
    0 <= k by NAT_1:18; then
    0+1 <= k+1 by XREAL_1:9; then
A16: k+1 in dom ((n, len p)-cut p) by A15,A14,FINSEQ_3:27;
    k < len ((n, len p)-cut p) by A15,A14, NAT_1:38;
    then ((n, len p)-cut p).(k+1) = p.(x..p) by A12,A13, GRAPH_2:def 1;
  hence x in p.followSet(n) by A11, A16, FUNCT_1:12;
end;

theorem Th17: :: Follow03
for p, q being FinSequence, x being set st p = <*x*>^q
for n being non zero natural number holds p.followSet(n+1) = q.followSet(n)
proof let p,q be FinSequence, x be set such that
A1: p = <*x*>^q;
    let n be non zero Nat;
    len <*x*> = 1 by FINSEQ_1:57; then
A2: len p = 1 + len q by A1,FINSEQ_1:35;
per cases;
suppose A3: n > len q; then
    n+1 > len p by A2,XREAL_1:10; then
    (n+1,len p)-cut p = {} by GRAPH_2:def 1;
  hence p.followSet(n+1) = q.followSet(n) by A3,GRAPH_2:def 1; end;
suppose A4: n <= len q;
    0 <= n & 0 <> n by NAT_1:18; then 0 < n by REAL_1:def 5; then
A5: 0+1 <= n by NAT_1:38;
A6: len (n, len q)-cut q + n = len q + 1 by A5, A4, GRAPH_2:def 1;
A7: 1 <= n+1 & n+1 <= len p & len p <= len p by A2,XREAL_1:9,A5,A4; then
A8:len ((n+1, len p)-cut p) + (n+1) = len p + 1 by GRAPH_2:def 1;
    dom ((n+1,len p)-cut p) =
    Seg (len ((n, len q)-cut q)) by A8,A6,A2,FINSEQ_1:def 3;then
A9: dom ((n+1,len p)-cut p) = dom ((n, len q)-cut q) by FINSEQ_1:def 3;

A10: now let i be Nat such that A11: i in dom q;
        p.(len <*x*> + i) = q.i by A1,A11,FINSEQ_1:def 7;
      hence p.(i+1) = q.i by FINSEQ_1:57;
    end;
A12: now let k be Nat such that A13: k in dom ((n, len q)-cut q);
    A14: 1 <= k & k <= (len p - n) by A8, A9,A13,FINSEQ_3:27; then
    A15: n+k <= n+((len p)-n) by XREAL_1:9;
    A16: 1+-1 <= k+-1 by A14,XREAL_1:9; then
        k-1 in NAT by INT_1:16; then
        reconsider k1 = k-1 as Nat by ORDINAL1:def 13;
    A17: -1 + k < 0 + (len p - n) by A14,XREAL_1:10;
    A18: k1+n +1 + -1 <= len q + 1 + -1 by A15,A2,XREAL_1:9;
        1+0 <= n+k1 by A16,A5,XREAL_1:9; then
    A19: n+k1 in dom q by A18,FINSEQ_3:27;
      thus ((n+1,len p)-cut p).k = ((n+1, len p)-cut p).(k1+1)
                    .= p.(n+1+k1) by A17,A8,A7,GRAPH_2:def 1
                    .= p.(n+k1+1)
                    .= q.(n+k1) by A10,A19
                   .= ((n,len q)-cut q).(k1+1) by A17,A6,A2,A5,A4,GRAPH_2:def 1
                    .= ((n,len q)-cut q).k;
    end;

    now let y be set;
      hereby assume y in rng (n+1,len p)-cut p; then
        consider k being Element of NAT such that
    A20: k in dom (n+1, len p)-cut p and
    A21: ((n+1,len p)-cut p).k = y by FINSEQ_2:11;
        ((n+1,len p)-cut p).k = ((n, len q)-cut q).k by A9,A20,A12;
       hence y in rng (n, len q)-cut q by A21,A9,A20,FUNCT_1:12;
      end;
      assume y in rng ((n, len q)-cut q); then
        consider k being Element of NAT such that
    A22: k in dom (n, len q)-cut q and
    A23: ((n, len q)-cut q).k = y by FINSEQ_2:11;
        ((n+1,len p)-cut p).k = ((n, len q)-cut q).k by A22,A12;
      hence y in rng (n+1,len p)-cut p by A23, A22,A9,FUNCT_1:12;
    end;
  hence p.followSet(n+1) = q.followSet(n) by TARSKI:2; end;
end;

theorem Th18: :: FinSubseq00
for X being set, f being FinSequence of X, g being FinSubsequence of f
 st len Seq g = len f holds Seq g = f
proof let X be set, f be FinSequence of X, g be FinSubsequence of f such that
A1: len Seq g = len f;
A2: len Seq g = card g by GLIB_001:5;
A3: g c= f by GRAPH_2:def 5;
   now assume g <> f; then g c< f by A3, XBOOLE_0:def 8;
    hence contradiction by A1, A2, CARD_2:67;
   end;
  hence Seq g = f by GRAPH_2:24;
end;

begin :: Miscellany on graphs

theorem Th19:  :: :: Joins01:
for G being _Graph, S being Subset of the_Vertices_of G
for H being inducedSubgraph of G,S
for u,v being set st u in S & v in S
for e being set st e Joins u,v,G holds e Joins u,v,H
proof let G be _Graph, S be Subset of the_Vertices_of G;
    let H be inducedSubgraph of G,S;
    let u,v be set such that
A1: u in S & v in S;
    reconsider S as non empty Subset of the_Vertices_of G by A1;
    let e be set such that
A2: e Joins u,v,G;
    e in G.edgesBetween(S) by A2,A1,GLIB_000:35; then
A3: e in the_Edges_of H by GLIB_000:def 39;
A4: (((the_Source_of G).e = u & (the_Target_of G).e = v) or
    ((the_Source_of G).e = v & (the_Target_of G).e = u)) by A2,GLIB_000:def 15;
    the_Source_of H = (the_Source_of G) | the_Edges_of H &
    the_Target_of H = (the_Target_of G) | the_Edges_of H by GLIB_000:48; then
    (the_Source_of H).e = (the_Source_of G).e &
    (the_Target_of H).e = (the_Target_of G).e by A3,FUNCT_1:72;
    hence thesis by A4, A3,GLIB_000:def 15;
end;

theorem
for G being _Graph, W being Walk of G
 holds W is Trail-like iff len W = 2*(card W.edges())+1
proof let G be _Graph, W be Walk of G; set WE = W.edges(), WES = W.edgeSeq();
    W is Trail-like iff W.edgeSeq() is one-to-one by GLIB_001:def 27; then
    W is Trail-like iff 2*card WE + 1 = 2*len WES+1 by FINSEQ_4:77;
    hence thesis by GLIB_001:def 15;
end;

theorem Th21: :: Walk02
for G being _Graph, S being Subset of the_Vertices_of G
for H being removeVertices of G,S
for W being Walk of G
 st (for n being odd natural number st n <= len W holds not W.n in S)
  holds W is Walk of H
proof
    let G be _Graph, S be Subset of the_Vertices_of G;
    let H be removeVertices of G,S;
    let W be Walk of G such that
A1: for n being odd Nat st n <= len W holds not W.n in S;
A2: now assume the_Vertices_of G\S = {}; then
    A3: the_Vertices_of G c= S & S c= the_Vertices_of G by XBOOLE_1:37;
        W.last() in the_Vertices_of G;
     hence contradiction by A1, A3;
    end;
A4: the_Vertices_of H = the_Vertices_of G\S &
    the_Edges_of H = G.edgesBetween(the_Vertices_of G\S) by A2,GLIB_000:def 39;
    now let x be set such that A5: x in W.vertices();
        consider n being odd Element of NAT such that
    A6: n <= len W & W.n = x by A5,GLIB_001:88;
        x in the_Vertices_of G & not x in S by A1, A6, GLIB_001:8;
        hence x in the_Vertices_of H by A4, XBOOLE_0:def 4;
    end; then
A7: W.vertices() c= the_Vertices_of H by TARSKI:def 3;
A8: W.edges() c= G.edgesBetween(W.vertices()) by GLIB_001:110;
    G.edgesBetween(W.vertices()) c= G.edgesBetween(the_Vertices_of H)
        by A7,GLIB_000:39; then
    W.edges() c= G.edgesBetween(the_Vertices_of H) by A8,XBOOLE_1:1;
    hence W is Walk of H by A4, A7,GLIB_001:171;
end;

theorem Th22: :: Walk03
for G being _Graph, a,b be set st a<>b
for W being Walk of G st W.vertices() = {a,b}
 holds ex e being set st e Joins a,b,G
proof let G be _Graph, a,b be set such that
A1: a<>b;
    let W be Walk of G such that
A2: W.vertices() = {a,b};
A3: W.first() in W.vertices() by GLIB_001:89;
A4: now let x be set such that
    A5: W.first() = x;
       let y be set such that
    A6: y in {a,b} \ {x};
    A7:x in {x} by TARSKI:def 1;
        set k = W.find(y);
    A8: x = a or x = b by A5,A2,A3,TARSKI:def 2;
    A9: k <= len W by A2,A6,GLIB_001:def 19;
    A10: W.k = y by A2,A6,GLIB_001:def 19;
        k <> 1 by A7,A6,XBOOLE_0:def 4,A10,A5;
        then consider m being odd Nat such that
    A11: m+2 = k by Th5;
    A12: m < k by A11, NAT_1:41; then
    A13: m < len W by A9, XREAL_1:2;
    A14: m in NAT by ORDINAL1:def 13; then
        W.m in {a,b} by A13,A2,GLIB_001:88; then
    A15: W.m = a or W.m = b by TARSKI:def 2;
    A16: y = a or y = b by A6,TARSKI:def 2;
        W.(m+1) Joins W.m,W.k,G by A14, A13, A11, GLIB_001:def 3;
     hence ex e being set st e Joins x,y,G
        by A15,A16,A8,A7,XBOOLE_0:def 4,A12,A14,A13,A10,A2,A6,GLIB_001:def 19;
   end;
   per cases by A2, A3, TARSKI:def 2;
   suppose A17: W.first() = a;
          b in {b} by TARSKI:def 1;
     then b in {a,b}\{a} by A1, ZFMISC_1:23;
    hence thesis by A17, A4;
   end;
   suppose A18: W.first() = b;
          a in {a} by TARSKI:def 1;
     then a in {a,b}\{b} by A1, ZFMISC_1:23;
     then consider e be set such that
   A19: e Joins b,a,G by A18,A4;
       e Joins a,b,G by A19, GLIB_000:17;
    hence thesis;
   end;
end;

theorem Th23: :: Walk04
for G being _Graph, S being non empty Subset of the_Vertices_of G
for H being inducedSubgraph of G,S
for W being Walk of G st W.vertices() c= S holds W is Walk of H
proof
    let G be _Graph, S be non empty Subset of the_Vertices_of G;
    let H be inducedSubgraph of G,S;
    let W be Walk of G such that A1: W.vertices() c= S;
A2: the_Vertices_of H = S &
    the_Edges_of H = G.edgesBetween(S) by GLIB_000:def 39;
A3: W.vertices() c= the_Vertices_of H by A1,GLIB_000:def 39;
A4: W.edges() c= G.edgesBetween(W.vertices()) by GLIB_001:110;
    G.edgesBetween(W.vertices()) c= G.edgesBetween(the_Vertices_of H)
        by A3,GLIB_000:39; then
    W.edges() c= the_Edges_of H by A2, A4,XBOOLE_1:1;
    hence W is Walk of H by A3,GLIB_001:171;
end;

theorem Th24: :: Cyclelike01
for G1,G2 being _Graph st G1 == G2
for W1 be Walk of G1, W2 being Walk of G2
 st W1 = W2 holds W1 is Cycle-like implies W2 is Cycle-like
proof let G1,G2 be _Graph such that A1: G1 == G2;
    let W1 be Walk of G1,W2 be Walk of G2 such that A2: W1 = W2;
    assume A3: W1 is Cycle-like;
    W1 is Path-like by A3,GLIB_001:def 31; then
A4: W2 is Path-like by A1,A2,GLIB_001:182;
    W1 is non trivial by A3,GLIB_001:def 31; then
    len W2 <> 1 by A2, GLIB_001:127; then
A5: W2 is non trivial by GLIB_001:127;
    W1 is closed by A3,GLIB_001:def 31; then
    W1.first() = W1.last() by GLIB_001:def 24; then
    W2.first() = W2.last() by A2; then
    W2 is closed by GLIB_001:def 24;
    hence W2 is Cycle-like by A5,A4,GLIB_001:def 31;
end;

theorem Th25: :: Path01
for G being _Graph, P being Path of G, m, n being odd natural number
 st m <= len P & n <= len P & P.m = P.n
  holds m = n or (m = 1 & n = len P) or (m = len P & n = 1)
proof let G be _Graph, P be Path of G, m, n be odd Nat such that
A1: m <= len P & n <= len P & P.m = P.n;
A2: m=n or m<n or n<m by REAL_1:def 5;
   m in NAT & n in NAT by ORDINAL1:def 13;
 hence m=n or (m=1 & n=len P) or (m=len P & n = 1) by A1,A2,GLIB_001:def 28;
end;

theorem
for G being _Graph, P being Path of G st P is open
for a,e,b being set
 st not a in P.vertices() & b = P.first() & e Joins a,b,G
  holds G.walkOf(a,e,b).append(P) is Path-like
proof let G be _Graph, P be Path of G such that A1: P is open;
    let a,e,b be set such that
A2: not a in P.vertices() and
A3: b = P.first() & e Joins a,b,G;
    set T = G.walkOf(a,e,b); set J = T.append(P);
A4: T.last() = P.first() by A3,GLIB_001:16;
    3 in Seg 3 by FINSEQ_1:5; then
    3 in Seg (len T) by A3,GLIB_001:15; then
    3 in dom T by FINSEQ_1:def 3; then
    J.3 = T.3 by GLIB_001:33; then
A5: J.3 = T.last() by A3,GLIB_001:15; then
A6: J.3 = b by A3,GLIB_001:16;
A7: now let m,n be odd Nat such that A8: m < n & n <= len J;
        assume A9: J.m = J.n;
    A10: 1 <= m & m < len J by HEYTING3:1,A8,XREAL_1:2; then
    A11: m in dom J by FINSEQ_3:27;
        2*0+1 < n by A10,A8,XREAL_1:2; then
    A12: 1+2 <= n by Th4;
        now assume m = 1; then
            J.m = J.first(); then
            J.m = T.first() by A4,GLIB_001:31; then
        A13: not J.m in P.vertices() by A2,A3,GLIB_001:16;
            per cases by A12,REAL_1:def 5;
          suppose n=3;
            hence contradiction by A9,A13, A3,A6,GLIB_001:89; end;
          suppose A14: n > 3; then
            not n in Seg 3 by FINSEQ_1:3; then
            not n in Seg (len T) by A3,GLIB_001:15; then
        A15: not n in dom T by FINSEQ_1:def 3;
            1 <= n by A14,XREAL_1:2; then
        A16: n in dom J by A8, FINSEQ_3:27;
            consider j being Element of NAT such that
        A17: j < len P & n = len T + j by A16,A15,GLIB_001:35;
            now assume j is odd; then
                reconsider jj=j as odd Nat;
                len T + jj is even;
               hence contradiction by A17;
            end; then reconsider jj=j as even Nat;
            reconsider j1=jj+1 as odd Nat;
            j+1 <= len P by A17,NAT_1:38; then
            P.j1 in P.vertices() by GLIB_001:88;
          hence contradiction by A9,A13, A17,A4,GLIB_001:34; end;
        end; then 2*0+1 < m by A10,REAL_1:def 5; then
    A18: 1+2 <= m by Th4; then
        3 < n by XREAL_1:2,A8; then
        not n in Seg 3 by FINSEQ_1:3; then
        not n in Seg (len T) by A3,GLIB_001:15; then
    A19: not n in dom T by FINSEQ_1:def 3;
        1 <= 3 & 3 <= n by A8,A18,XREAL_1:2; then
        1 <= n by XREAL_1:2; then
        n in Seg (len J) by A8,FINSEQ_1:3; then
    A20: n in dom J by FINSEQ_1:def 3;
        consider j being Element of NAT such that
    A21: j < len P & n = len T + j by A20,A19,GLIB_001:35;
    A22: J.n = P.(j+1) by A21,A4,GLIB_001:34;
        now assume j is odd; then
            reconsider jj=j as odd Nat;
            len T + jj is even;
            hence contradiction by A21;
        end; then reconsider jj=j as even Nat;
        reconsider j1=jj+1 as odd Nat;
    A23: j1 <= len P by A21,NAT_1:38;
        now assume m = 3; then
        A24: J.m = P.1 by A3,GLIB_001:16,A5;
            0 <> j & 0 <= j by A8,A18,A3,A21,GLIB_001:15,NAT_1:18;
            then 0 < j by REAL_1:def 5;
            then 2*0+1 < j1 by XREAL_1:10;
         hence contradiction by A24,A22,A9, A1,A23,GLIB_001:148;
        end; then
        3 < m by A18,REAL_1:def 5; then
        not m in Seg 3 by FINSEQ_1:3; then
        not m in Seg (len T) by A3,GLIB_001:15; then
    A25: not m in dom T by FINSEQ_1:def 3;
        consider k being Element of NAT such that
    A26: k < len P & m = len T + k by A25,A11,GLIB_001:35;
    A27: J.m = P.(k+1) by A26,A4,GLIB_001:34;
        now assume k is odd; then
            reconsider kk=k as odd Nat;
            len T + kk is even;
            hence contradiction by A26;
        end; then reconsider kk=k as even Nat;
        reconsider k1=kk+1 as odd Nat;
        k < j by A26,A21,A8,XREAL_1:9; then
        k1 < j1 by XREAL_1:10;
        hence contradiction by A27,A22,A9, A1,A23,GLIB_001:148;
    end;
    now let m,n be odd Element of NAT such that A28: m <= len J & n <= len J;
        assume A29: J.m = J.n;
    A30: m >= n by A28,A29,A7;
        not n < m by A28,A7,A29;
        hence n = m by A30,REAL_1:def 5;
    end;
    hence thesis by GLIB_001:147;
end;

theorem Th27: :: PathLike03
:: A similar theorem is needed for obtaining non closed Path
for G being _Graph, P,H being Path of G
 st P.edges() misses H.edges() &
    P is non trivial & P is open & H is non trivial & H is open &
    P.vertices() /\ H.vertices() = { P.first(), P.last() } &
    H.first() = P.last() & H.last() = P.first()
  holds P.append(H) is Cycle-like
proof let G be _Graph, P,H be Path of G such that
A1: P.edges() misses H.edges() and
A2: P is non trivial & P is open and
A3: H is non trivial & H is open and
A4: P.vertices() /\ H.vertices() = { P.first(), P.last() } and
A5: H.first() = P.last() & H.last() = P.first();
    set J = P.append(H);
A6: len J + 1 + (-1) = len P + len H + (-1) by A5,GLIB_001:29;
A7: now let m be odd Nat; assume A8: m <= len P;
        1 <= m & m <= len P by HEYTING3:1,A8;
        then m in dom P by FINSEQ_3:27;
      hence J.m = P.m by GLIB_001:33;
    end;
A9: for m being odd Nat st m > len P & m <= len J holds
        m in dom J & not m in dom P
    proof let m be odd Nat such that A10: m > len P & m <= len J;
        1 <= m & m <= len J by HEYTING3:1,A10;
        hence thesis by A10,FINSEQ_3:27;
    end;
    J.first() = P.first() & J.last() = P.first() by A5,GLIB_001:31; then
A11: J is closed by GLIB_001:def 24;
    now assume len J = 1; then
    A12: 1 + 1 = len P + len H by A5,GLIB_001:29;
        now assume A13: len P <> 1; 1 <= len P by Th2; then
            1 < len P by A13,REAL_1:def 5; then
            len P + len H <= len P by A12,NAT_1:38; then
            len P + len H + (-len P) <= len P + (-len P) by XREAL_1:9; then
            len H <= 0 & 0 <= len H by NAT_1:18;
            hence contradiction by XREAL_1:1;
        end;
        hence contradiction by A3,A12, GLIB_001:127;
    end; then
A14: J is non trivial by GLIB_001:127;
A15: rng P.edgeSeq() = P.edges() & rng H.edgeSeq() = H.edges() &
    P.edgeSeq() is one-to-one & H.edgeSeq() is one-to-one
        by GLIB_001:def 27;
    P.edgeSeq() ^ H.edgeSeq() is one-to-one by A1,A15,FINSEQ_3:98; then
    J.edgeSeq() is one-to-one by A5,GLIB_001:86; then
A16: J is Trail-like by GLIB_001:def 27;
    now let m,n being odd Element of NAT such that A17: m < n & n <= len J;
    A18: 1 <= m & m <= len J by HEYTING3:1,A17,XREAL_1:2;
      per cases;
      suppose m <= len P & n <= len P; then
        P.m <> P.n & P.m = J.m & J.n = P.n by A2,A17,A7,GLIB_001:148;
        hence J.m = J.n implies (m = 1 & n = len J);
      end;
      suppose A19: m <= len P & n > len P;
        A20: J.m = P.m by A19,A7;
        n in dom J & not n in dom P by A19,A17,A9; then
        consider j being Element of NAT such that
        A21: j < len H & n = len P + j by GLIB_001:35;
        A22: J.n = H.(j+1) by A21,A5,GLIB_001:34;
        now assume j is odd; then reconsider j as odd Nat;
          len P + j is even;
          hence contradiction by A21;
        end; then reconsider jj=j as even Nat;
        reconsider j1=jj+1 as odd Nat;
        A23: j1 <= len H by A21,NAT_1:38;
        A24: j1 in NAT by ORDINAL1:def 13;
        now assume A25: J.m = J.n;
          J.m in P.vertices() & J.m in H.vertices()
               by A19,A20,A23,A25,A22,GLIB_001:88; then
          A26: J.m in P.vertices() /\ H.vertices() by XBOOLE_0:def 3;
          A27: now assume A28: J.m = P.last();
                  j <> 0 & 0 <= j by A19,A21,NAT_1:18; then
                  0 < j by REAL_1:def 5; then
                  0+1 < j1 by XREAL_1:10; then
                  H.(2*0+1) <> H.j1 by A24,A23,A3,GLIB_001:148;
                 hence contradiction by A25,A21,A5,GLIB_001:34,A28;
               end; then
        A29: J.m = P.first() by A26,A4,TARSKI:def 2;
        A30: J.n = H.last() by A5,A25, A27, A26,A4,TARSKI:def 2;
        A31: now assume A32: n < len J;
             A33: H.j1 = H.(len H) by A21,A5,GLIB_001:34,A30;
                j1 <> len H by A32,A6,A21; then
                j1 < len H by A23,REAL_1:def 5;
               hence contradiction by A24,A33,A3,GLIB_001:148;
             end;
             now assume A34: 1 < m;
               P.m <> P.(2*0+1) by A19,A34,A2,GLIB_001:148;
               hence contradiction by A19,A7,A29;
             end;
           hence m = 1 & n = len J by A31,A17,A18,REAL_1:def 5;
        end;
        hence J.m = J.n implies (m = 1 & n = len J);
      end;
      suppose m > len P & n <= len P;
        hence J.m = J.n implies (m = 1 & n = len J) by A17,XREAL_1:2;
      end;
      suppose A35: m > len P & n > len P;
        m in dom J & not m in dom P by A35,A18,A9; then
        consider k being Element of NAT such that
      A36: k < len H & m = len P + k by GLIB_001:35;
        n in dom J & not n in dom P by A35,A17,A9; then
        consider j being Element of NAT such that
      A37: j < len H & n = len P + j by GLIB_001:35;
      A38: J.(len P + k) = H.(k+1) by A36,A5,GLIB_001:34;
      A39: J.(len P + j) = H.(j+1) by A37,A5,GLIB_001:34;
          now assume k is odd; then reconsider k as odd Nat;
            len P + k is even;
            hence contradiction by A36;
          end; then reconsider kk = k as even Nat;
          reconsider k1=kk+1 as odd Nat;
          now assume j is odd; then reconsider j as odd Nat;
            len P + j is even;
            hence contradiction by A37;
          end;
          then reconsider jj=j as even Nat;
          reconsider j1=jj+1 as odd Element of NAT by ORDINAL1:def 13;
          k < j by XREAL_1:9,A36,A37,A17; then
          A40: k1 < j1 by XREAL_1:10;
          j1 <= len H by A37,NAT_1:38;
        hence J.m = J.n implies (m = 1 & n = len J)
          by A38,A39,A36,A37, A40,A3,GLIB_001:148;
        end;
      end;
      then J is Path-like by A16,GLIB_001:def 28;
  hence thesis by A11,A14,GLIB_001:def 31;
end;

theorem Th28: :: PathLike04
for G being _Graph, W1,W2 being Walk of G st W1.last() = W2.first()
 holds W1.append(W2).length() = W1.length() + W2.length()
proof let G being _Graph, P,H being Walk of G such that
A1:  H.first() = P.last();
 thus P.append(H).length() = len (P.edgeSeq() ^ H.edgeSeq()) by A1, GLIB_001:86
                          .= P.length() + H.length() by FINSEQ_1:35;
end;

theorem Th29: :: Subgraph01
for G being _Graph, A,B being non empty Subset of the_Vertices_of G st B c= A
for H1 being inducedSubgraph of G,A
for H2 being inducedSubgraph of H1,B
  holds H2 is inducedSubgraph of G,B
proof   let G be _Graph;
    let A,B be non empty Subset of the_Vertices_of G such that A1: B c= A;
    let H1 be inducedSubgraph of G,A;  let H2 be inducedSubgraph of H1,B;
A2: the_Vertices_of H1 = A by GLIB_000:def 39; then
A3:the_Vertices_of H2 = B by A1,GLIB_000:def 39;
    the_Edges_of H2 c= the_Edges_of H1 &
    the_Edges_of H1 c= the_Edges_of G; then
A4: the_Edges_of H2 c= the_Edges_of G by XBOOLE_1:1;
    now let e be set such that A5: e in the_Edges_of H2;
        (the_Source_of H2).e = (the_Source_of H1).e &
        (the_Target_of H2).e = (the_Target_of H1).e by A5,GLIB_000:def 34;
        hence (the_Source_of H2).e = (the_Source_of G).e &
        (the_Target_of H2).e = (the_Target_of G).e by A5,GLIB_000:def 34;
    end; then
A6: H2 is Subgraph of G by A3,A4,GLIB_000:def 34;
    H1.edgesBetween(B) c= G.edgesBetween(B) by GLIB_000:79; then
A7: the_Edges_of H2 c= G.edgesBetween(B) by A2,A1,GLIB_000:def 39;
    now let e be set such that A8: e in G.edgesBetween(B);
    A9: (the_Source_of G).e in B &
        (the_Target_of G).e in B by A8,GLIB_000:34; then
        e in G.edgesBetween(A) by A1,A8,GLIB_000:34; then
    A10: e in the_Edges_of H1 by GLIB_000:def 39; then
        (the_Source_of H1).e = (the_Source_of G).e &
        (the_Target_of H1).e = (the_Target_of G).e by GLIB_000:def 34; then
        e in H1.edgesBetween(B) by A9,A10,GLIB_000:34;
        hence e in the_Edges_of H2 by A2,A1,GLIB_000:def 39;
    end; then
    for x being set holds x in the_Edges_of H2 iff x in G.edgesBetween(B)
        by A7; then
    the_Edges_of H2 = G.edgesBetween(B) by TARSKI:2;
    hence H2 is inducedSubgraph of G,B by A3,A6,GLIB_000:def 39;
end;

theorem Th30: :: Subgraph01a
for G being _Graph, A,B being non empty Subset of the_Vertices_of G st B c= A
for H1 being inducedSubgraph of G,A
for H2 being inducedSubgraph of G,B
  holds H2 is inducedSubgraph of H1,B
proof    let G be _Graph;
    let A,B be non empty Subset of the_Vertices_of G such that
A1: B c= A;
    let H1 be inducedSubgraph of G,A;    let H2 be inducedSubgraph of G,B;
A2: the_Vertices_of H1 = A by GLIB_000:def 39;
A3: the_Vertices_of H2 = B by GLIB_000:def 39;
A4: the_Edges_of H2 = G.edgesBetween(B) by GLIB_000:def 39;
A5: the_Edges_of H1 = G.edgesBetween(A) by GLIB_000:def 39;
A6: the_Edges_of H2 c= the_Edges_of H1 by A1,A4,A5,GLIB_000:39;
    now let e be set such that
    A7: e in the_Edges_of H2;
     thus (the_Source_of H2).e = (the_Source_of G).e by A7,GLIB_000:def 34
          .= (the_Source_of H1).e by  A7, A6,GLIB_000:def 34;
     thus (the_Target_of H2).e = (the_Target_of G).e by A7,GLIB_000:def 34
          .= (the_Target_of H1).e by  A7, A6,GLIB_000:def 34;
    end; then
A8: H2 is Subgraph of H1 by A1,A2,A3,A6,GLIB_000:def 34;
A9: H1.edgesBetween(B) c= the_Edges_of H2 by A4, GLIB_000:79;
    now let e be set such that A10: e in the_Edges_of H2;
    A11: (the_Source_of G).e = (the_Source_of H1).e by A10, A6,GLIB_000:def 34;
    A12: (the_Target_of G).e = (the_Target_of H1).e by A10, A6,GLIB_000:def 34;
        (the_Source_of G).e in B &
        (the_Target_of G).e in B by A10,A4,GLIB_000:34;
     hence e in H1.edgesBetween(B) by A11,A12,A10,A6,GLIB_000:34;
    end; then
    for x being set holds x in the_Edges_of H2 iff x in H1.edgesBetween(B)
        by A9; then
    the_Edges_of H2 = H1.edgesBetween(B) by TARSKI:2;
    hence H2 is inducedSubgraph of H1,B by A1,A2,A3,A8,GLIB_000:def 39;
end;

theorem Th31: :: Subgraph02
for G being _Graph, S,T being non empty Subset of the_Vertices_of G st T c= S
for G2 being inducedSubgraph of G,S
  holds G2.edgesBetween(T) = G.edgesBetween(T)
proof let G be _Graph;
    let S,T be non empty Subset of the_Vertices_of G such that
A1: T c= S;
    let G2 be inducedSubgraph of G,S;
A2: the_Vertices_of G2 = S &
    the_Edges_of G2 = G.edgesBetween(S) by GLIB_000:def 39;
    now let e be set;
        hereby assume A3: e in G.edgesBetween(T);
    A4: G.edgesBetween(T) c= G.edgesBetween(S) by A1, GLIB_000:39;
    A5: e in the_Edges_of G & (the_Source_of G).e in T &
        (the_Target_of G).e in T by A3,GLIB_000:34;
        (the_Source_of G2).e = (the_Source_of G).e &
       (the_Target_of G2).e = (the_Target_of G).e by A2,A3,A4,GLIB_000:def 34;
        hence e in G2.edgesBetween(T) by A4, A2, A3, A5, GLIB_000:34; end;
        assume e in G2.edgesBetween(T); then
    A6: e in the_Edges_of G2 & (the_Source_of G2).e in T &
        (the_Target_of G2).e in T by GLIB_000:34;
    A7: (the_Source_of G).e in T &(the_Target_of G).e in T
                  by A6, GLIB_000:def 34;
     thus e in G.edgesBetween(T) by A6, A7,GLIB_000:34;
    end;
    hence thesis by TARSKI:2;
end;

:: we do not consider infinite graphs
scheme FinGraphOrderCompInd{P[set]}:
    for G being finite _Graph holds P[G]
    provided
A1: for k being non zero natural number st
    (for Gk being finite _Graph st Gk.order() < k holds P[Gk]) holds
    (for Gk1 being finite _Graph st Gk1.order() = k holds P[Gk1])
proof
    defpred pP[non zero Nat] means
        for Gk being finite _Graph st Gk.order() < $1 holds P[Gk];
A2: pP[1] by NAT_1:39;
A3: for n being non zero Element of NAT holds pP[n] implies pP[n+1] proof
        let n be non zero Element of NAT such that A4: pP[n];
        now let Gk be finite _Graph such that A5: Gk.order() < n+1;
            Gk.order() <= n by A5,NAT_1:38; then
            Gk.order() < n or Gk.order() = n by REAL_1:def 5;
            hence P[Gk] by A1, A4;
        end;
        hence pP[n+1];
    end;
A6: for k being non zero Element of NAT holds pP[k]
    from BINARITH:sch 1(A2,A3);
    let G be finite _Graph;
    for Gk being finite _Graph st Gk.order()<G.order() holds P[Gk] by A6;
    hence thesis by A1;
end;

:: should be in GLIBs
theorem Th32: :: PDistinct
for G being _Graph, W being Walk of G
 st W is open & W is Path-like holds W is vertex-distinct
proof let G be _Graph, W be Walk of G;
  assume A1: W is open & W is Path-like;
  now let m,n be odd Element of NAT such that
A2: m <= len W & n <= len W & W.m = W.n;
    assume A3: m <> n;
    per cases by A3,REAL_1:def 5;
    suppose m < n; then
      W.m = W.first() & W.n = W.last() by A1,A2,GLIB_001:def 28;
    hence contradiction by A1,A2,GLIB_001:def 24; end;
    suppose m > n; then
      W.m = W.last() & W.n = W.first() by A1,A2,GLIB_001:def 28;
    hence contradiction by A1,A2,GLIB_001:def 24; end;
  end;
  hence W is vertex-distinct by GLIB_001:def 29;
end;

:: should be in GLIB
theorem Th33:  :: PathLike15
for G being _Graph, P being Path of G st P is open & len P > 3
for e being set
 st e Joins P.last(),P.first(),G holds P.addEdge(e) is Cycle-like
proof let G be _Graph, W be Path of G such that
A1: W is open and
A2: len W > 3;
    let e be set such that
A3: e Joins W.last(),W.first(),G;
    set P = W.addEdge(e);
A4: P.first() = W.first() & P.last() = W.first() by A3,GLIB_001:64; then
A5: P is closed by GLIB_001:def 24;
A6: len P = len W + 2*1 by A3,GLIB_001:65;
A7: e in W.last().edgesInOut() by A3,GLIB_000:65;
    now assume e in W.edges(); then
        consider v1,v2 being Vertex of G, n being odd Element of NAT such that
    A8: n+2 <= len W & v1 = W.n & e = W.(n+1) & v2 = W.(n+2) and
    A9: e Joins v1,v2,G by GLIB_001:104;
    A10: n < len W by A8,XREAL_1:41;
      per cases by A9,A3,GLIB_000:18;
      suppose A11: v1 = W.first() & v2 = W.last();
        now assume 1 <> n; then 1 <= n & 1 <> n by Th2; then
          2*0+1 < n by REAL_1:def 5;
          hence contradiction by A1,A10,A11,A8,GLIB_001:148;
        end;
        hence contradiction by A11,A8,A1,A2,GLIB_001:148; end;
      suppose v1 = W.last() & v2 = W.first();
        hence contradiction by A1,A8,A10,GLIB_001:148; end;
    end; then
A12: P is Trail-like by A7,GLIB_001:143;
A13: now let m,n be odd Element of NAT such that A14: m < n & n <= len P;
        assume A15: P.m = P.n;
    A16: 1 <= m by Th2;
        m < len W + 2*1 by A6,A14,XREAL_1:2; then
    A17: m <= len W + 2 - 2 by Th3; then
    A18: m in dom W by A16,FINSEQ_3:27; then
    A19: W.m = P.m by A3,GLIB_001:66;
    A20: now assume n < len P; then
            n < len W + 2*1 by A3,GLIB_001:65; then
        A21: n <= len W + 2 - 2 by Th3; then
        A22: W.n <> W.m by A14,A1,GLIB_001:148;
            1 <= n by Th2; then
            n in dom W by A21,FINSEQ_3:27;
          hence contradiction by A19,A15,A22,A3,GLIB_001:66;
        end; then
    A23: P.n = W.1 by A4,A14,XREAL_1:1;
        now assume m <> 1; then m <> 1 & 1 <= m by Th2; then
            2*0+1 < m by REAL_1:def 5; then
        A24: W.1 <> W.m by A1,A17,GLIB_001:148;
          thus contradiction by A15,A3,A24,A23,A18,GLIB_001:66;
        end;
      hence m = 1 & n = len P by A20, A14,XREAL_1:1;
    end;
A25: P is Path-like by A12,A13,GLIB_001:def 28;
A26: P is non trivial by A3,GLIB_001:133;
  thus P is Cycle-like by A5,A25,A26,GLIB_001:def 31;
end;

begin :: Shortest topological path

definition let G be _Graph, W be Walk of G;
  attr W is minlength means       :Def2:
    for W2 being Walk of G st W2 is_Walk_from W.first(),W.last()
      holds len W2 >= len W;
end;

theorem Th34: :: WalkSubwalk00
for G being _Graph, W being Walk of G, S being Subwalk of W
 st S.first() = W.first() & S.edgeSeq() = W.edgeSeq() holds S = W
proof
    let G be _Graph, W be Walk of G, S be Subwalk of W such that
A1: S.first() = W.first() and
A2: S.edgeSeq() = W.edgeSeq();
    len S = 2*len W.edgeSeq() + 1 by A2,GLIB_001:def 15; then
A3: len S = len W by GLIB_001:def 15;
    defpred P[Nat] means $1 in dom S implies S.$1 = W.$1;
A4: now let k be Element of NAT such that
    A5: for n being Element of NAT st n < k holds P[n];
        per cases;
        suppose k in dom S; then
        A6: 1 <= k & k <= len S by FINSEQ_3:27;
          per cases;
          suppose A7: k is even; then
              S.k = S.edgeSeq().(k div 2) by A6,GLIB_001:78;
              hence P[k] by A2,A6,A3,A7,GLIB_001:78; end;
          suppose k is odd; then
            reconsider kk=k as odd Nat;
            per cases by A6,REAL_1:def 5;
            suppose k = 1;
              hence P[k] by A1; end;
            suppose k > 2*0+1; then
            A8: 1+2 <= kk by Th4; then
                0<=2 & 3+-1 <= k+-1 by XREAL_1:9; then
                0<=k-1 by XREAL_1:2; then
                reconsider k1=k-1 as Element of NAT by INT_1:16;
                0<=1 & 3+-2 <= k+-2 by A8,XREAL_1:9; then
                0 <= k-2 by XREAL_1:2; then
                reconsider k2=kk-2*1 as odd Element of NAT by INT_1:16;
                3+-1 <= k+-1 by A8,XREAL_1:9; then
            A9: 1 <= k1 & k1 < k by XREAL_1:2,XREAL_1:46; then
                k1 <= len S by A6,XREAL_1:2; then
            A10: k1 in dom S by FINSEQ_3:27,A9;
            A11: S.k1 = W.k1 by A5,A10,A9;
            A12: 3+-2 <= k+-2 by A8,XREAL_1:9; then
            A13: 1 <= k2 & k2 < k by XREAL_1:46; then
                k2 <= len S by A6,XREAL_1:2; then
            A14: k2 in dom S by FINSEQ_3:27,A12;
            A15: S.k2 = W.k2 by A5,A14,A13;
            A16: k2 < len S & k2 < len W by A3,A13,A6,XREAL_1:2;
                S.(k2+1) Joins S.k2,S.(k2+2),G &
                W.(k2+1) Joins W.k2,W.(k2+2),G by A16,GLIB_001:def 3; then
                (S.k2 = S.k2 & S.k = W.k) or
                (S.k2 = W.k & S.k = S.k2) by A11,A15,GLIB_000:18;
              hence P[k]; end;
          end; end;
        suppose not k in dom S; hence P[k]; end;
    end;
A17: for n being Element of NAT holds P[n] from NAT_1:sch 4(A4);
    now let k be Element of NAT such that A18: 1 <= k & k <= len S;
        k in dom S by A18,FINSEQ_3:27;
        hence S.k = W.k by A17;
    end;
    hence S = W by A3,FINSEQ_1:18;
end;

theorem Th35: :: LenSubwalk00
for G being _Graph, W being Walk of G, S being Subwalk of W
 st len S = len W holds S = W
proof let G be _Graph, W be Walk of G, S be Subwalk of W such that
A1: len S = len W;
   consider es being FinSubsequence of W.edgeSeq() such that
A2: S.edgeSeq() = Seq es by GLIB_001:def 32;
A3: len S = 2*len S.edgeSeq() +1 by GLIB_001:def 15;
A4: len W = 2*len W.edgeSeq() +1 by GLIB_001:def 15;
A5: S.edgeSeq() = W.edgeSeq() by A1, A3, A4, A2, Th18;
   S.first() = W.first() by GLIB_001:162;
  hence S = W by A5, Th34;
end;

theorem
for G being _Graph, W being Walk of G st W is minlength holds W is Path-like
proof let G be _Graph, W be Walk of G such that
A1: W is minlength and
A2: not W is Path-like;
   consider s being Path-like Subwalk of W;
A3: s is_Walk_from W.first(),W.last() by GLIB_001:def 32;
   len s <= len W & len W <= len s by GLIB_001:163, A1, A3, Def2; then
   len s = len W by XREAL_1:1;
 hence contradiction by A2, Th35;
end;

theorem
for G being _Graph, W being Walk of G st W is minlength holds W is Path-like
proof let G be _Graph, W be Walk of G such that
A1: W is minlength;
    assume not W is Path-like; then
    consider m,n be odd Element of NAT such that
A2: m <= len W & n <= len W and
A3: W.m = W.n and
A4: m <> n by GLIB_001:147;  :: can we do this only once? :-/
    per cases by A4,REAL_1:def 5;
    suppose A5: m < n;
        set R = W.cut(1,m), S = W.cut(n,len W);
    A6: 2*0+1 <= m by HEYTING3:1; then
    A7: R.first() = W.(2*0+1) & R.last() = W.m by A2,GLIB_001:38;
    A8: S.first() = W.m & S.last() = W.(len W) by A2,A3,GLIB_001:38;
    A9: len R + 1 - 1 = m + 1 - 1 by A6,A2,GLIB_001:37;
    A10: len S + n - n = len W + 1 - n by A2,GLIB_001:37;
        set P = R.append(S);
    A11: P is_Walk_from W.first(),W.last() by A7,A8,GLIB_001:31;
        len P + 1 = len R + len S by A7,A8,GLIB_001:29; then
        len P = len W - n + m by A9, A10; then
        len P < len W - n + n by A5,XREAL_1:10;
      hence contradiction by A11,A1,Def2; end;
    suppose A12: n < m;
        set R = W.cut(1,n), S = W.cut(m,len W);
    A13: 2*0+1 <= n by HEYTING3:1; then
    A14: R.first() = W.(2*0+1) & R.last() = W.n by A2,GLIB_001:38;
    A15: S.first() = W.n & S.last() = W.(len W) by A2,A3,GLIB_001:38;
    A16: len R + 1 - 1 = n + 1 - 1 by A13,A2,GLIB_001:37;
    A17: len S + m - m = len W + 1 - m by A2,GLIB_001:37;
        set P = R.append(S);
    A18: P is_Walk_from W.first(),W.last() by A14,A15,GLIB_001:31;
        len P + 1 = len R + len S by A14,A15,GLIB_001:29; then
        len P = len W - m + n by A16,A17; then
        len P < len W - m + m by A12,XREAL_1:10;
      hence contradiction by A18,A1,Def2; end;
end;

theorem Th38: :: TopPath01
for G being _Graph, W being Walk of G
 holds (for P being Path of G
         st P is_Walk_from W.first(),W.last() holds len P >= len W)
       implies W is minlength
proof    let G be _Graph, W be Walk of G;
    assume A1: for P2 being Path of G st P2 is_Walk_from W.first(),W.last()
                   holds len P2 >= len W;
    now let V be Walk of G such that A2: V is_Walk_from W.first(),W.last();
    A3: V.first() = W.first() & V.last() = W.last() by A2,GLIB_001:def 23;
        consider P3 being Path-like Subwalk of V;
        P3.first()=W.first() & P3.last()=W.last() by A3,GLIB_001:162; then
        P3 is_Walk_from W.first(),W.last() by GLIB_001:def 23; then
        len W <= len P3 & len P3 <= len V by A1,GLIB_001:163;
        hence len V >= len W by XREAL_1:2;
    end;
    hence W is minlength by Def2;
end;

theorem Th39: :: TopPath02
for G being _Graph, W being Walk of G
  ex P being Path of G st P is_Walk_from W.first(),W.last() & P is minlength
proof let G being _Graph, W being Walk of G;
    set X = { len P where P is Path of G : P is_Walk_from W.first(),W.last() };
    consider T being Path-like Subwalk of W;
    T.first() = W.first() & T.last() = W.last() by GLIB_001:162; then
    T is_Walk_from W.first(),W.last() by GLIB_001:def 23; then
A1: len T in X;
    X c= NAT proof let x be set; assume x in X; then
       ex P being Path of G st x = len P & P is_Walk_from W.first(),W.last();
      hence x in NAT;
    end; then
    reconsider X as non empty Subset of NAT by A1;
    min X in X by CQC_SIM1:def 8; then
    consider P being Path of G such that
A2: len P = min X and
A3: P is_Walk_from W.first(),W.last();
   take  P;
   thus P is_Walk_from W.first(),W.last() by A3;
   let W2 be Walk of G such that
A4: W2 is_Walk_from P.first(),P.last();
    consider T being Path-like Subwalk of W2;
A5: len T <= len W2 by GLIB_001:163;
A6: P.first() = W2.first() & P.last() = W2.last() by  A4, GLIB_001:def 23;
A7: P.first() = W.first() & P.last() = W.last() by  A3, GLIB_001:def 23;
    T.first() = W2.first() & T.last() = W2.last() by GLIB_001:162; then
    T is_Walk_from W.first(),W.last() by A6,A7, GLIB_001:def 23; then
    len T in X; then
    len P <= len T by A2, CQC_SIM1:def 8;
  hence len P <= len W2 by A5, XREAL_1:2;
end;

theorem Th40: :: TopPath03
for G being _Graph, W being Walk of G st W is minlength
 holds for m,n being odd natural number st m+2 < n & n <= len W
        holds not ex e being set st e Joins W.m,W.n,G
proof
    let G be _Graph;
    let P be Walk of G such that A1: P is minlength;
    let m,n be odd Nat such that A2: m+2 < n & n <= len P;
    let e be set such that A3: e Joins P.m,P.n,G;
    set P1 = P.cut(1,m);        set P2 = P1.addEdge(e);
    set P3 = P.cut(n,len P);    set P4 = P2.append(P3);
A4: m in NAT & n in NAT by ORDINAL1:def 13;
    2*0 <= m & m+0 <= m+2 by XREAL_1:9,NAT_1:18; then
    0 < m & m <= n by A2,REAL_1:def 5,XREAL_1:2; then
A5: 2*0+1 <= m & m <= len P by A2,XREAL_1:2,HEYTING3:1; then
A6: P1.first() = P.1 & P1.last() = P.m by A4, GLIB_001:38;
A7: P1.first() = P.first() & P1.last() = P.m by A5,A4,GLIB_001:38;
A8: len P1 + 1 = m + 1 by A4, A5,GLIB_001:37;
A9: P2.first() = P.first() & P2.last() = P.n by A3,A7,GLIB_001:64;
A10: len P2 = m + 2 by A6,A3,A8,GLIB_001:65;
A11: P3.first() = P.n & P3.last() = P.(len P) by A4, A2,GLIB_001:38;
A12: P3.first() = P.n & P3.last() = P.last() by A4,A2,GLIB_001:38;
A13: len P3 + n = len P+1 by A4, A2,GLIB_001:37;
A14: P4 is_Walk_from P.first(),P.last() by A9,A12,GLIB_001:31;
A15: len P4 + 1 = len P2 + len P3 by A9,A11,GLIB_001:29;
    len P - n + (m + 2) < len P - n + n by A2,XREAL_1:10;
    hence contradiction by A1,A14,A15, A10, A13, Def2;
end;

theorem Th41: :: TopPath04
for G being _Graph, S being non empty Subset of the_Vertices_of G
for H being inducedSubgraph of G,S
for W being Walk of H st W is minlength
for m,n being odd natural number st m+2 < n & n <= len W
 holds not ex e being set st e Joins W.m,W.n,G
proof
    let G be _Graph, S be non empty Subset of the_Vertices_of G;
    let GA be inducedSubgraph of G,S;  let P be Walk of GA;
    assume A1: P is minlength;
A2: S = the_Vertices_of GA by GLIB_000:def 39;
    now let m,n be odd Nat such that
      A3: m+2 < n & n <= len P;
      A4: m in NAT & n in NAT by ORDINAL1:def 13;
        let e be set such that
      A5: e Joins P.m,P.n,G;
        m + 0 <= m + 2 by XREAL_1:9; then
        m <= n by A3,XREAL_1:2; then
        m <= len P by A3,XREAL_1:2; then
        P.m in the_Vertices_of GA & P.n in the_Vertices_of GA
           by A4,A3,GLIB_001:8;
        then e Joins P.m,P.n,GA by A2,A5,Th19;
     hence contradiction by A1,A3,Th40;
    end;
    hence thesis;
end;

theorem Th42: :: TopPath05
for G being _Graph for W being Walk of G st W is minlength
for m,n being odd natural number st m<=n & n<=len W
  holds W.cut(m,n) is minlength
proof
    let G be _Graph, W be Walk of G such that
A1: W is minlength;
    let m,n be odd Nat such that
A2: m <= n & n <= len W;
A3: 2*0+1 <= m & 1 <= n & m <= len W by A2,HEYTING3:1,XREAL_1:2;
    set R = W.cut(1,m);     set S = W.cut(m,n);     set T = W.cut(n,len W);
A4: m in NAT & n in NAT by ORDINAL1:def 13;
A5: R.first() = W.1 by A4,A3,GLIB_001:38;
A6: R.last() = W.m by A4,A3,GLIB_001:38;
A7: len R + 1 = m + 1 by A4,A3,GLIB_001:37;
A8: S.first() = W.m by A4,A2,GLIB_001:38;
A9: S.last() = W.n by A4,A2,GLIB_001:38;
A10: len S + m = n + 1 by A4,A2,GLIB_001:37;
A11: T.first() = W.n by A4,A2,GLIB_001:38;
A12: T.last() = W.(len W) by A4,A2,GLIB_001:38;
A13: len T + n = len W + 1 by A4,A2,GLIB_001:37;
    assume not S is minlength; then
    consider M being Walk of G such that
A14: M is_Walk_from S.first(),S.last() and
A15: len M < len S by Def2;
A16: M.first() = W.m by A14,A8,GLIB_001:def 23;
A17: M.last() = W.n by A14,A9,GLIB_001:def 23;
    set A = R.append(M);
A18: A.first() = W.1 by A5,A6,A16,GLIB_001:31;
A19: A.last() = W.n by A6,A16,A17,GLIB_001:31;
    len A + 1 = len R + len M by A6,A16,GLIB_001:29; then
    len A + 1 < len R + len S by A15,XREAL_1:10; then
A20: len A + 1 - 1 < n + 1 - 1 by A7,A10,XREAL_1:16;
    set B = A.append(T);
A21: B.first() = W.first() by A18,A19,A11,GLIB_001:31;
A22: B.last() = W.last()  by A19,A11,A12,GLIB_001:31;
    len B + 1 = len A + len T by A19,A11,GLIB_001:29; then
    len B + 1 < len T + n by A20,XREAL_1:10; then
A23: len B + 1 - 1 < len W + 1 - 1 by A13,XREAL_1:16;
    B is_Walk_from W.first(),W.last() by A21,A22,GLIB_001:def 23;
    hence contradiction by A1,A23,Def2;
end;

theorem
for G being _Graph st G is connected
for A,B being non empty Subset of the_Vertices_of G st A misses B holds
  ex P being Path of G st P is minlength & P is non trivial &
  P.first() in A & P.last() in B &
  for n being odd natural number st 1 < n & n < len P
    holds not P.n in A & not P.n in B
proof
    let G be _Graph such that A1: G is connected;
    let A,B be non empty Subset of the_Vertices_of G such that A2: A misses B;
    set X = { len P where P is Path of G : P.first() in A & P.last() in B };
    consider a being set such that A3: a in A by XBOOLE_0:def 1;
    reconsider a as Vertex of G by A3;
    consider b being set such that A4: b in B by XBOOLE_0:def 1;
    reconsider b as Vertex of G by A4;
    consider W being Walk of G such that A5: W is_Walk_from a,b
        by A1,GLIB_002:def 1;
    consider W2 being Path of G such that
A6: W2 is_Walk_from W.first(),W.last() &
    W2 is minlength by Th39;
    W.first() = a & W.last() = b by A5,GLIB_001:def 23; then
    W2.first() in A & W2.last() in B by A3,A4,A6,GLIB_001:def 23; then
A7: len W2 in X;
    X c= NAT proof let x be set; assume x in X; then
       ex P being Path of G st x = len P & P.first() in A & P.last() in B;
      hence x in NAT;
    end; then
    reconsider X as non empty Subset of NAT by A7;
    min X in X by CQC_SIM1:def 8; then
    consider M being Path of G such that
A8: len M = min X & M.first() in A & M.last() in B;

    now assume M.first() = M.last(); then
         M.first() in A /\ B by A8, XBOOLE_0:def 3;
         hence contradiction by A2,XBOOLE_0:def 7;
    end; then
A9: M is non trivial by GLIB_001:128;
    now let P2 be Path of G such that A10: P2 is_Walk_from M.first(),M.last();
        P2.first() in A & P2.last() in B by A8, A10,GLIB_001:def 23;
        then len P2 in X;
        hence len P2 >= len M by A8,CQC_SIM1:def 8;
    end; then
A11: M is minlength by Th38;
    now let n be odd Nat such that A12: 1 < n & n < len M;
        assume A13: M.n in A or M.n in B;
         reconsider nn = n as Element of NAT by ORDINAL1:def 13;
        per cases by A13;
        suppose A14: M.n in A;
            reconsider T = M.cut(nn,len M) as Path of G;
            T.first() in A & T.last() in B by A8, A14,A12,GLIB_001:38;  then
        A15: len T in X;
        A16: len T + nn = len M+1 by A12,GLIB_001:37;
            len T + 0 < len M + 1 + (-n) + (n + (-1)) by A12, A16,XREAL_1:10;
            hence contradiction by A15, A8, CQC_SIM1:def 8; end;

        suppose A17: M.n in B;
            reconsider T = M.cut(1,nn) as Path of G;
            2*0+1 <= n & n <= len M by A12; then
            T.first() = M.1 & T.last() = M.nn by GLIB_001:38; then
        A18: len T in X by A8,A17;
            2*0+1 <= n & n <= len M by A12; then
            len T + 1 = nn + 1 by GLIB_001:37;
            hence contradiction by A18, A12, A8, CQC_SIM1:def 8; end;
    end;
    hence thesis by A9,A8,A11;
end;

begin :: Adjacency and complete graphs

definition let G be _Graph, a,b be Vertex of G;
  pred a,b are_adjacent means               :Def3: :: DefAdjacent
    ex e being set st e Joins a,b,G;
  symmetry proof
     let a,b be Vertex of G;
     assume ex e being set st e Joins a,b,G; then
     consider e being set such that A1: e Joins a,b,G;
     e Joins b,a,G by A1,GLIB_000:17;
     hence ex e being set st e Joins b,a,G;
  end;
end;

theorem Th44: :: VAdjacent00
for G1,G2 being _Graph st G1 == G2
for u1,v1 being Vertex of G1 st u1,v1 are_adjacent
for u2,v2 being Vertex of G2 st u1=u2 & v1=v2 holds u2,v2 are_adjacent
proof let G1,G2 be _Graph such that A1: G1 == G2;
    let u1,v1 be Vertex of G1 such that A2: u1,v1 are_adjacent;
    let u2,v2 be Vertex of G2 such that A3: u1=u2 & v1=v2;
    consider e being set such that
A4: e Joins u1,v1,G1 by A2,Def3;
    e Joins u2,v2,G2 by A3, A4, A1,GLIB_000:91;
    hence thesis by Def3;
end;

theorem Th45: :: VAdjacent01
for G being _Graph, S being non empty Subset of the_Vertices_of G
for H being inducedSubgraph of G,S
for u, v being Vertex of G, t, w being Vertex of H
  st u = t & v = w holds u,v are_adjacent iff t,w are_adjacent
proof let G be _Graph, S be non empty Subset of the_Vertices_of G;
 let H be inducedSubgraph of G,S;
 let u, v be Vertex of G, t, w be Vertex of H such that
A1: u = t & v = w;
A2: S = the_Vertices_of H by GLIB_000:def 39;
    hereby assume u,v are_adjacent; then consider e being set such that
    A3: e Joins u,v,G by Def3;
        e Joins t,w,H by A1, A3, A2, Th19;
      hence t,w are_adjacent by Def3;
    end;
    assume t,w are_adjacent; then consider e being set such that
    A4: e Joins t,w,H by Def3;
        e Joins u,v,G by A4, A1, GLIB_000:75;
    hence u,v are_adjacent by Def3;
end;

theorem Th46: :: PathLike05
for G being _Graph, W being Walk of G
 st W.first() <> W.last() & not W.first(),W.last() are_adjacent
  holds W.length() >= 2
proof let G be _Graph, W be Walk of G such that
A1: W.first() <> W.last() and
A2: not W.first(),W.last() are_adjacent;
   set l = W.length();
   assume l < 2; then l < 1+1; then
A3: l <= 1 by NAT_1:38;
   per cases by A3, CQC_THE1:2;
   suppose l = 0; then W is trivial by GLIB_001:def 26;
    hence contradiction by A1, GLIB_001:128;
   end;
   suppose l = 1; then
   A4: len W = 2*1+1 by GLIB_001:113 .= 3;
       1 = 2*0+1; then
   A5: W.(1+1) Joins W.1,W.(1+2),G by A4, GLIB_001:def 3;
       reconsider W1 = W.1 as Vertex of G by GLIB_001:def 3;
       reconsider WlW = W.len W as Vertex of G by GLIB_001:8;
    thus contradiction by A2, A5, A4,Def3;
   end;
end;

theorem Th47: :: PathBuilder00
:: add sequences of vertices and edges
for G being _Graph, v1,v2,v3 being Vertex of G st
    v1<>v2 & v1<>v3 & v2<>v3 & v1,v2 are_adjacent & v2,v3 are_adjacent
  ex P being Path of G, e1,e2 being set st
     P is open & len P = 5 & P.length() = 2 &
     e1 Joins v1,v2,G & e2 Joins v2,v3,G & P.edges() = {e1,e2} &
     P.vertices() = {v1,v2,v3} & P.1 = v1 & P.3 = v2 & P.5 = v3
proof let G be _Graph;
    let v1,v2,v3 be Vertex of G such that
A1: v1 <> v2 & v1 <> v3 and
A2: v2 <> v3 and
A3: v1,v2 are_adjacent and
A4: v2,v3 are_adjacent;
    consider e1 being set such that
A5: e1 Joins v1,v2,G by A3,Def3;
    consider e2 being set such that
A6: e2 Joins v2,v3,G by A4,Def3;
    set P1 = G.walkOf(v1,e1,v2);
A7: P1.first() = v1 by A5,GLIB_001:16;
A8: P1.last() = v2 by A5,GLIB_001:16;
A9: len P1 = 3 by A5,GLIB_001:15;
A10: P1.vertices() = {v1,v2} by A5,GLIB_001:92;
A11: P1 is open by A7,A8,A1,GLIB_001:def 24;
    set P = P1.addEdge(e2);
A12: P.first() = v1 by A7,A8,A6,GLIB_001:64;
A13: P.last() = v3 by A8,A6,GLIB_001:64;
    not v3 in P1.vertices() by A10,A1,A2,TARSKI:def 2;
    then reconsider P as Path of G by A8,A6,A11,GLIB_001:152;
    take P,e1,e2;
    thus P is open by A12,A13,A1,GLIB_001:def 24;
A14: len P = 3 + 2 by A6,A8,A9,GLIB_001:65;
    hence len P = 5;
    5 = 2*P.length() + 1 by A14,GLIB_001:113;
    hence P.length() = 2;
    thus e1 Joins v1,v2,G by A5;
    thus e2 Joins v2,v3,G by A6;
    P1.edges() = {e1} by A5,GLIB_001:109; then
    P.edges() = {e1} \/ {e2} by A8,A6,GLIB_001:112;
    hence P.edges() = {e1,e2} by ENUMSET1:41;
    P.vertices() = {v1,v2} \/ {v3} by A6,A8,A10,GLIB_001:96;
    hence P.vertices() = {v1,v2,v3} by ENUMSET1:43;
    thus P.1 = v1 by A12;
    3 in dom P1 by A9,FINSEQ_3:27;
    hence P.3 = P1.3 by A6,A8,GLIB_001:66
             .= v2 by A8,A5,GLIB_001:15;
    thus P.5 = v3 by A14,A13;
end;

theorem Th48:  :: PathBuilder01
for G being _Graph, v1,v2,v3,v4 being Vertex of G st
  v1<>v2 & v1<>v3 & v2<>v3 & v2<>v4 & v3<>v4 &
  v1,v2 are_adjacent & v2,v3 are_adjacent & v3,v4 are_adjacent
 ex P being Path of G st len P = 7 & P.length() = 3 &
     P.vertices() = {v1,v2,v3,v4} & P.1 = v1 & P.3 = v2 & P.5 = v3 & P.7 = v4
proof
    let G be _Graph, v1,v2,v3,v4 be Vertex of G such that
A1: v1<>v2 & v1<>v3 & v2<>v3 & v2<>v4 & v3<>v4 and
A2: v1,v2 are_adjacent & v2,v3 are_adjacent & v3,v4 are_adjacent;
    consider e3 being set such that
A3: e3 Joins v3,v4,G by A2,Def3;
    consider R being Path of G,e1,e2 being set such that
A4: R is open and
A5: len R = 5 & R.length() = 2 and
A6: e1 Joins v1,v2,G & e2 Joins v2,v3,G & R.edges() = {e1,e2} and
A7: R.vertices() = {v1,v2,v3} and
A8: R.1 = v1 & R.3 = v2 & R.5 = v3 by A1,A2,Th47;

A9: e1 <> e3 by A1,A6,A3,GLIB_000:18;
A10: e2 <> e3 by A1,A6,A3,GLIB_000:18;
A11: not e3 in R.edges() by A6,A9,A10,TARSKI:def 2;
A12: for n being odd Element of NAT st 1 < n & n <= len R holds R.n <> v4
    proof let n be odd Element of NAT such that
    A13: 1 < n and A14: n <= len R;
    A15: n <= 6 by A5, A14, XREAL_1:2;
        per cases by A15, A13, Th8;
        suppose n = 3; hence R.n <> v4 by A8,A1; end;
        suppose n = 5; hence R.n <> v4 by A8,A1; end;
    end;
    set P = R.addEdge(e3);
    reconsider P as Path of G by A5,A8,A3,A11,A4,A12,GLIB_001:151;
    take P;
    A16: len P = 5 + 2 by A5,A8,A3,GLIB_001:65;
    hence len P = 7;
    7 = 2*P.length() + 1 by A16, GLIB_001:113;
    hence P.length() = 3;
    P.vertices() = {v1,v2,v3} \/ {v4} by A7,A5,A8,A3,GLIB_001:96;
    hence P.vertices() = {v1,v2,v3,v4} by ENUMSET1:46;
    1 in dom R by A5,FINSEQ_3:27;
    hence P.1 = v1 by A8,A5,A3,GLIB_001:66;
    3 in dom R by A5,FINSEQ_3:27;
    hence P.3 = v2 by A8,A5,A3,GLIB_001:66;
    5 in dom R by A5,FINSEQ_3:27;
    hence P.5 = v3 by A8,A5,A3,GLIB_001:66;
    P.last() = v4 by A5,A8,A3,GLIB_001:64;
    hence P.7 = v4 by A16;
end;

definition let G be _Graph, S be set;
  func G.AdjacentSet(S) -> Subset of the_Vertices_of G equals
      {u where u is Vertex of G :
         not u in S & ex v being Vertex of G st (v in S & u,v are_adjacent)};
  coherence proof
  set X = {u where u is Vertex of G :
           not u in S & ex v being Vertex of G st (v in S & u,v are_adjacent)};
      now let x be set such that A1: x in X;
          consider u being Vertex of G such that A2: u=x and
          not u in S & ex v being Vertex of G st (v in S & u,v are_adjacent)
              by A1;
          thus x in the_Vertices_of G by A2;
      end;
      hence thesis by TARSKI:def 3;
  end;
end;

theorem
for G being _Graph, S, x being set st x in G.AdjacentSet(S) holds not x in S
proof let G be _Graph, S,x be set;
   assume x in G.AdjacentSet(S); then
   consider t being Vertex of G such that
A1: t=x & not t in S & ex v being Vertex of G st (v in S & t,v are_adjacent);
  thus not x in S by A1;
end;

theorem Th50: :: Adjacent00
for G being _Graph, S being set
for u being Vertex of G
 holds u in G.AdjacentSet(S) iff
       not u in S & ex v being Vertex of G st (v in S & u,v are_adjacent)
proof
    let G be _Graph, S be set;
    let u be Vertex of G;
    hereby assume u in G.AdjacentSet(S); then
        consider t being Vertex of G such that A1: u=t and
    A2: not t in S & ex v being Vertex of G st
            (v in S & t,v are_adjacent);
        thus not u in S & ex v being Vertex of G st
            (v in S & u,v are_adjacent) by A1,A2;
    end;
    assume not u in S & ex v being Vertex of G st (v in S & u,v are_adjacent);
    hence u in G.AdjacentSet(S);
end;

theorem Th51: :: Adjacent01
for G1,G2 being _Graph st G1 == G2 for S being set
 holds G1.AdjacentSet(S) = G2.AdjacentSet(S)
proof let G1,G2 be _Graph such that A1: G1 == G2; let S be set;
A2: now let x be set such that A3: x in G1.AdjacentSet(S);
      reconsider t1 = x as Vertex of G1 by A3;
  A4: not t1 in S & ex v being Vertex of G1 st (v in S&t1,v are_adjacent)
         by A3,Th50;
      consider v1 being Vertex of G1 such that
  A5: v1 in S & t1,v1 are_adjacent by A3, Th50;
      reconsider t2 = t1, v2 = v1 as Vertex of G2 by A1, GLIB_000:def 36;
      t2,v2 are_adjacent by A1,A5,Th44;
    hence x in G2.AdjacentSet(S) by A4,A5;
   end;
   now let x be set such that A6: x in G2.AdjacentSet(S);
      reconsider t2 = x as Vertex of G2 by A6;
  A7: not t2 in S & ex v being Vertex of G2 st (v in S&t2,v are_adjacent)
         by A6,Th50;
      consider v2 being Vertex of G2 such that
  A8: v2 in S & t2,v2 are_adjacent by A6, Th50;
      reconsider t1 = t2, v1 = v2 as Vertex of G1 by A1,GLIB_000:def 36;
      t1,v1 are_adjacent by A1,A8,Th44;
     hence x in G1.AdjacentSet(S) by A7,A8;
   end;
  hence G1.AdjacentSet(S) = G2.AdjacentSet(S) by A2, TARSKI:2;
end;

theorem Th52: :: AdjacentV00
for G being _Graph, u,v being Vertex of G
 holds u in G.AdjacentSet({v}) iff (u <> v & v,u are_adjacent)
proof
    let G be _Graph, u,v be Vertex of G;
    hereby assume A1: u in G.AdjacentSet({v});
        consider x being Vertex of G such that
    A2: x in {v} & u,x are_adjacent by A1,Th50;
        x = v by A2,TARSKI:def 1;
        hence u <> v & v,u are_adjacent by A1,A2,Th50;
    end;
    assume A3: u <> v & v,u are_adjacent; then
    not u in {v} & v in {v} by TARSKI:def 1;
    hence u in G.AdjacentSet({v}) by A3;
end;

theorem
for G being _Graph, x,y being set
 holds x in G.AdjacentSet({y}) iff y in G.AdjacentSet({x})
proof let G be _Graph, x,y be set;
  hereby assume A1: x in G.AdjacentSet({y}); then
    reconsider xg = x as Vertex of G;
    now assume A2: not y in the_Vertices_of G;
       consider vy being Vertex of G such that
    A3: vy in {y} & vy,xg are_adjacent by A1,Th50;
       vy = y by A3,TARSKI:def 1;
      hence contradiction by A2;
    end; then
    reconsider yg = y as Vertex of G;
    xg <> yg & xg,yg are_adjacent by A1, Th52;
   hence y in G.AdjacentSet({x}) by Th52;
  end;
  assume A4: y in G.AdjacentSet({x}); then
    reconsider yg = y as Vertex of G;
    now assume A5: not x in the_Vertices_of G;
       consider vx being Vertex of G such that
    A6: vx in {x} & vx,yg are_adjacent by A4,Th50;
       vx = x by A6,TARSKI:def 1;
      hence contradiction by A5;
    end; then
    reconsider xg = x as Vertex of G;
    xg <> yg & xg,yg are_adjacent by A4, Th52;
  hence x in G.AdjacentSet({y}) by Th52;
end;

theorem
for G being _Graph, C being Path of G st C is Cycle-like & C.length() > 3
for x being Vertex of G st x in C.vertices()
  ex m,n being odd Nat st m+2 < n & n <= len C & not (m=1 & n = len C) &
                          not (m=1 & n = len C-2) & not (m=3 & n = len C) &
         C.m <> C.n & C.m in G.AdjacentSet({x}) & C.n in G.AdjacentSet({x})
proof let G be _Graph, C be Path of G such that
A1: C is Cycle-like & C.length() > 3;
    let x be Vertex of G such that
A2: x in C.vertices();
    C.length() >= 3+1 by A1,NAT_1:38; then
    2*C.length() >= 2*4 by XREAL_1:66; then
    2*C.length() + 1 >= 8 + 1 by XREAL_1:9; then
A3: len C >= 9 by GLIB_001:113;
    consider n being odd Element of NAT such that
A4: n <= len C & C.n = x by A2,GLIB_001:88;
A5: 0+1 <= n by HEYTING3:1;
A6: C is closed by A1,GLIB_001:def 31;
    per cases;
    suppose A7: n = 1 or n = len C;
        reconsider i=2*1+1 as odd Nat;
        len C + (-2) >= 9 + (-2) by A3,XREAL_1:9; then
        len C - 2*1 >= 0 by XREAL_1:2; then
        len C - 2 is odd Element of NAT by INT_1:16; then
        reconsider j=len C-2 as odd Nat;
     take i, j;
    A8: i in NAT & j in NAT by ORDINAL1:def 13;
    A9: len C + (-2) >= 9 + (-2) by A3,XREAL_1:9;
     hence
     i+2 < j by XREAL_1:2;
    A10: len C + 0 > len C+(-2) by XREAL_1:10;
     thus j <= len C by A10;
     thus not (i=1 & j=len C) & not (i=1 & j=len C-2) & not (i=3 & j=len C);
     hereby assume A11: C.i = C.j; i+2+(-2) < j+0 by A9, XREAL_1:2;
      hence contradiction by A8,A10,A11,GLIB_001:def 28;
     end;
        reconsider k=2*0+1 as odd Nat;
    A12: len C + 0 > 9 + (-6) by A3,XREAL_1:10; then
        reconsider Ci=C.i as Vertex of G by GLIB_001:8;
        len C + 0 > 9 + (-8) by A3,XREAL_1:10; then
    A13: C.(k+1) Joins C.k,C.i,G by GLIB_001:def 3;
    A14: now per cases by A7;
          suppose n = 1; hence x = C.k by A4; end;
          suppose n = len C; then
              x = C.last() by A4; then
              x = C.first() by A6,GLIB_001:def 24;
              hence x = C.k; end;
        end; then
    A15: x,Ci are_adjacent by A13, Def3;
        x <> Ci by A14,A12,GLIB_001:def 28;
     hence C.i in G.AdjacentSet({x}) by A15,Th52;
        reconsider Cj=C.j as Vertex of G by A8, A10,GLIB_001:8;
    A16: now per cases by A7;
          suppose n = 1; then x = C.first() by A4; then
              x = C.last() by A6,GLIB_001:def 24;
              hence x = C.(j+2); end;
          suppose n = len C; hence x = C.(j+2) by A4; end;
        end; then
        C.(j+1) Joins Cj,x,G by A8,A10,GLIB_001:def 3; then
    A17: x,Cj are_adjacent by Def3;
        now assume x = Cj;
             then j = 1 & j+2 = len C by A8,A16,A10,GLIB_001:def 28;
            hence contradiction by A3;
        end;
      hence C.j in G.AdjacentSet({x}) by A17,Th52;
    end;

    suppose A18: not (n = 1 or n = len C); then
    A19: 2*0+1 < n & n < len C by A5,A4,REAL_1:def 5; then
        1+2 <= n & n <= len C-2 by Th3,Th4; then
        3+(-2) <= n+(-2) by XREAL_1:9; then
        0 <= n-2*1 by XREAL_1:2; then
        n-2 is odd Element of NAT by INT_1:16; then
        reconsider i=n-2 as odd Nat;
        reconsider j=n+2 as odd Nat ;
     take i,j;
     A20: i in NAT & j in NAT by ORDINAL1:def 13;
     A21: n+0 < n+2 & n+2 <= len C-2+2
            by A19,Th4,XREAL_1:10;
     hence
     i+2 < j & j <= len C;
    A22: now assume A23: i = 1 & j = len C; j = i + 4;
            hence contradiction by A3,A23;
        end;
     hence not (i = 1 & j = len C);
     hereby assume A24: i = 1 & j = len C-2;
           len C+(-2) >= 9+(-3) by A3,XREAL_1:9;
       hence contradiction by A24;
     end;
     hereby assume A25: i = 3 & j = len C; j = i + 4;
       hence contradiction by A25,A3;
     end;
     hereby assume A26: C.i = C.j;
       i+2+(-2) < j+0 by XREAL_1:10;
       hence contradiction by A20,A22,A21,A26,GLIB_001:def 28;
     end;
        i+0 < i+2 by XREAL_1:10; then
    A27: i < len C by XREAL_1:2, A4; then
        reconsider Ci=C.i as Vertex of G by A20,GLIB_001:8;
        C.(i+1) Joins C.i,C.(i+2),G by A20,A27,GLIB_001:def 3; then
    A28: x,Ci are_adjacent by A4,Def3;
        now assume A29: Ci = x;
            n+0 > n+(-2) by XREAL_1:10;
            hence contradiction by A20,A4,A18,A29,GLIB_001:def 28;
        end;
     hence C.i in G.AdjacentSet({x}) by A28,Th52;
    A30: n+2 <= len C -2 + 2 by A19,Th4;
        reconsider Cj=C.j as Vertex of G by A30,GLIB_001:8;
        C.(n+1) Joins C.n,C.j,G by A19,GLIB_001:def 3; then
    A31: x,Cj are_adjacent by A4,Def3;
        now assume A32: Cj = x;
            n+2 > n+0 by XREAL_1:10;
            hence contradiction by A30,A18,A32, A4, GLIB_001:def 28;
        end;
      hence C.j in G.AdjacentSet({x}) by A31,Th52;
      end;
end;

theorem Th55: :: Cycle01a
for G being _Graph, C being Path of G st C is Cycle-like & C.length() > 3
for x being Vertex of G st x in C.vertices()
 ex m,n being odd natural number st m+2 < n & n <= len C &
         C.m <> C.n & C.m in G.AdjacentSet({x}) & C.n in G.AdjacentSet({x}) &
         for e being set st e in C.edges() holds not e Joins C.m,C.n,G
proof let G be _Graph, C be Path of G such that
A1: C is Cycle-like & C.length() > 3;
    let x be Vertex of G such that
A2: x in C.vertices();
    C.length() >= 3+1 by A1,NAT_1:38; then
    2*C.length() >= 2*4 by XREAL_1:66; then
    2*C.length() + 1 >= 8 + 1 by XREAL_1:9; then
A3: len C >= 9 by GLIB_001:113;
    consider n being odd Element of NAT such that
A4: n <= len C & C.n = x by A2,GLIB_001:88;
A5: 0+1 <= n by HEYTING3:1;
A6: C is closed by A1,GLIB_001:def 31;
    per cases;
    suppose A7: n = 1 or n = len C;
        reconsider i=2*1+1 as odd Nat;
        len C + (-2) >= 9 + (-2) by A3,XREAL_1:9; then
        len C - 2*1 >= 0 by XREAL_1:2; then
        len C-2 is odd Element of NAT by INT_1:16; then
        reconsider j=len C-2 as odd Nat;
      take i, j;
    A8: i in NAT & j in NAT by ORDINAL1:def 13;
    A9: len C + (-2) >= 9 + (-2) by A3,XREAL_1:9;
      hence
     i+2 < j by XREAL_1:2;
    A10: len C + 0 > len C+(-2) by XREAL_1:10;
      thus j <= len C by A10;
    hereby assume A11: C.i = C.j; i+2+(-2) < j+0 by A9,XREAL_1:2;
            hence contradiction by A8,A10,A11,GLIB_001:def 28;
    end;
        reconsider k=2*0+1 as odd Nat;
    A12: len C + 0 > 9 + (-6) by A3,XREAL_1:10; then
        reconsider Ci=C.i as Vertex of G by GLIB_001:8;
        len C + 0 > 9 + (-8) by A3,XREAL_1:10; then
    A13: C.(k+1) Joins C.k,C.i,G by GLIB_001:def 3;
    A14: now per cases by A7;
          suppose n = 1; hence x = C.k by A4; end;
          suppose n = len C; then
              x = C.last() by A4; then
              x = C.first() by A6,GLIB_001:def 24;
              hence x = C.k; end;
        end; then
    A15: x,Ci are_adjacent by A13, Def3;
        x <> Ci by A14,A12,GLIB_001:def 28;
     hence C.i in G.AdjacentSet({x}) by A15,Th52;
        reconsider Cj=C.j as Vertex of G by A8,A10,GLIB_001:8;
    A16: C.(j+1) Joins C.j,C.(j+2),G by A8,A10,GLIB_001:def 3;
    A17: now per cases by A7;
          suppose n = 1; then x = C.first() by A4; then
              x = C.last() by A6,GLIB_001:def 24;
              hence x = C.(j+2); end;
          suppose n = len C; hence x = C.(j+2) by A4; end;
        end; then
    A18: x,Cj are_adjacent by A16,Def3;
        now assume x = Cj;
              then j = 1 & j+2 = len C by A8,A17,A10,GLIB_001:def 28;
            hence contradiction by A3;
        end;
      hence C.j in G.AdjacentSet({x}) by A18,Th52;
      let e be set such that
     A19: e in C.edges() and
     A20: e Joins C.i,C.j,G;
         consider k being even Element of NAT such that
     A21: 1 <= k and
     A22: k <= len C and
     A23: C.k = e by A19,GLIB_001:100;
         k in dom C by A21, A22, FINSEQ_3:27; then
         consider ku1 being odd Element of NAT such that
     A24: ku1 = k-1 and
     A25: k-1 in dom C and
     A26: k+1 in dom C and
     A27: C.k Joins C.(ku1), C.(k+1),G by GLIB_001:10;
     A28: ((the_Source_of G).e = C.i & (the_Target_of G).e = C.j or
          (the_Source_of G).e = C.j & (the_Target_of G).e = C.i) &
         ((the_Source_of G).e = C.ku1 & (the_Target_of G).e = C.(k+1) or
          (the_Source_of G).e = C.(k+1) & (the_Target_of G).e = C.(ku1))
           by A20, A27, A23, GLIB_000:def 15;
     A29: ku1 <= len C by A24,A25,FINSEQ_3:27;
     A30: k+1 <= len C by A26, FINSEQ_3:27;
      i < j by A9,XREAL_1:2; then
     A31: i < len C by A10, XREAL_1:2;
     A32: j <> 1 by A9;
      per cases by A28;
       suppose A33: C.i = C.ku1 & C.j = C.(k+1);
           i+2 = k-1+(1+1) by A33,A31,A29,Th25,A24
              .= j by A33,A10,A30,A32,Th25;
         hence contradiction by A9;
       end;
       suppose A34: C.i = C.(k+1) & C.j = C.ku1;
                   i = k+1 by A34,A31,A30,Th25;
         hence contradiction by A34,A10,A24,A29,A32,Th25;
       end;
    end;

    suppose A35: not (n = 1 or n = len C); then
    A36: 2*0+1 < n & n < len C by A5,A4,REAL_1:def 5; then
        1+2 <= n & n <= len C-2 by Th3,Th4; then
        3+(-2) <= n+(-2) by XREAL_1:9;
        then 0 <= n-2 by XREAL_1:2;
        then n-2*1 is odd Element of NAT by INT_1:16;
        then reconsider i=n-2*1 as odd Nat;
        reconsider j=n+2 as odd Nat ;
     take i, j;
     A37: i in NAT & j in NAT by ORDINAL1:def 13;
        n+0 < n+2 by XREAL_1:10;
     hence i+2 < j;
     thus A38: j <= len C by A36,Th4;
    A39: now assume A40: i = 1 & j = len C; j = i + 4;
            hence contradiction by A3,A40;
        end;
     hereby assume A41: C.i = C.j;
       i+2+(-2) < j+0 by XREAL_1:10;
      hence contradiction by A37,A39,A38,A41,GLIB_001:def 28;
     end;
        i+0 < i+2 by XREAL_1:10; then
    A42: i < len C by XREAL_1:2, A4; then
        reconsider Ci=C.i as Vertex of G by A37,GLIB_001:8;
        C.(i+1) Joins C.i,C.(i+2),G by A37,A42,GLIB_001:def 3; then
    A43: x,Ci are_adjacent by A4,Def3;
        now assume A44: Ci = x;
            n+0 > n+(-2) by XREAL_1:10;
            hence contradiction by A37,A4,A35,A44,GLIB_001:def 28;
        end;
     hence C.i in G.AdjacentSet({x}) by A43,Th52;
    A45: n+2 <= len C -2 + 2 by A36,Th4;
        reconsider Cj=C.j as Vertex of G by A38,GLIB_001:8;
        C.(n+1) Joins C.n,C.j,G by A36,GLIB_001:def 3; then
    A46: x,Cj are_adjacent by A4,Def3;
        now assume A47: Cj = x;
            n+2 > n+0 by XREAL_1:10;
            hence contradiction by A45,A35,A47,A4,GLIB_001:def 28;
        end;
      hence C.j in G.AdjacentSet({x}) by A46,Th52;
      let e be set such that
     A48: e in C.edges() and
     A49: e Joins C.i,C.j,G;
         consider k being even Element of NAT such that
     A50: 1 <= k and
     A51: k <= len C and
     A52: C.k = e by A48,GLIB_001:100;
         k in dom C by A50, A51, FINSEQ_3:27; then
         consider ku1 being odd Element of NAT such that
     A53: ku1 = k-1 and k-1 in dom C and
     A54: k+1 in dom C and
     A55: C.k Joins C.(ku1), C.(k+1),G by GLIB_001:10;
     A56: ((the_Source_of G).e = C.i & (the_Target_of G).e = C.j or
          (the_Source_of G).e = C.j & (the_Target_of G).e = C.i) &
         ((the_Source_of G).e = C.ku1 & (the_Target_of G).e = C.(k+1) or
          (the_Source_of G).e = C.(k+1) & (the_Target_of G).e = C.(ku1))
           by A49, A55, A52, GLIB_000:def 15;
          k-1 < k by XREAL_1:148; then
     A57: k-1 < len C by A51,XREAL_1:2;
     A58: k+1 <= len C by A54, FINSEQ_3:27;
         1+2 <= j by A5,XREAL_1:9; then
     A59: j <> 1;
         1+1 <= k+1 by A50, XREAL_1:9; then
     A60: k+1 <> 1;
      per cases by A56;
       suppose A61: C.i = C.ku1 & C.j = C.(k+1);
          i+2 = k-1+(1+1) by A61,A53,A42,A57,Th25 :: .= k-1+1+1 .= k+1
              .= j by A61,A58,A38,A59,A60,Th25;
         hence contradiction;
       end;
       suppose A62: C.i = C.(k+1) & C.j = C.ku1;
         per cases by A62,A38,A57,A53,A42,A58,Th25;
         suppose i = k+1 & j = k-1;
           hence contradiction;
         end;
         suppose A63: i = k+1 & k-1 = 1 & j = len C;
           j = i+4;
           hence contradiction by A63,A3;
         end;
         suppose A64: i = 1 & k+1 = len C & j = k-1;
             k+1 = 7 by A64;
           hence contradiction by A64,A3;
         end;
         suppose A65: i = 1 & k+1 = len C & k-1 = 1 & j = len C;
          thus contradiction by A65;
         end;
       end;
      end;
end;

:: Gilbert's definition of isolated does not allow a vertex to have a
:: loop and a vertex just with a loop on it is NOT isolated.
:: This needs to be fixed, e.g.
::       v is isolated means G.AdjacentSet({v}) = {}
:: But we can keep the old one and the new one can be expressed just
:: by G.AdjacentSet({v}) = {}.  Should this be revised?
:: Ask Lorna and Ryan.  For loopless graphs it
:: does not matter, see below.

theorem :: AdjacentV01: :: :: AdjacentV01
for G being loopless _Graph, u being Vertex of G
 holds G.AdjacentSet({u}) = {} iff u is isolated
proof
    let G be loopless _Graph, u be Vertex of G;
    hereby assume A1: G.AdjacentSet({u}) = {};
        now assume u.edgesInOut() <> {}; then
            consider e being set such that
        A2: e in u.edgesInOut() by XBOOLE_0:def 1;
            consider v being Vertex of G such that
        A3: e Joins u,v,G by A2,GLIB_000:67;
            now assume u = v; then
                e in the_Edges_of G &
                (the_Source_of G).e = u & (the_Target_of G).e = u
                    by A3, GLIB_000:def 15;
                hence contradiction by GLIB_000:def 20;
            end; then u <> v & v,u are_adjacent by A3,Def3;
            hence contradiction by A1, Th52;
        end;
        hence u is isolated by GLIB_000:def 51;
    end;
    assume u is isolated; then
A4: u.edgesInOut() = {} by GLIB_000:def 51;
    now let v be set such that A5: v in G.AdjacentSet({u});
        reconsider v as Vertex of G by A5;
        v,u are_adjacent by A5,Th52; then
        consider e being set such that
    A6: e Joins v,u,G by Def3;
        e Joins u,v,G by A6,GLIB_000:17;
        hence contradiction by A4, GLIB_000:65;
    end;
    hence G.AdjacentSet({u}) = {} by XBOOLE_0:def 1;
end;

theorem Th57: :: Connected0
for G being _Graph, G0 being Subgraph of G,
    S being non empty Subset of the_Vertices_of G,
    x being Vertex of G,
    G1 being (inducedSubgraph of G,S),
    G2 being (inducedSubgraph of G,S\/{x})
 st G1 is connected & x in G.AdjacentSet(the_Vertices_of G1)
  holds G2 is connected
proof let G be _Graph, G0 be Subgraph of G,
          S be non empty Subset of the_Vertices_of G, x be Vertex of G,
          G1 be (inducedSubgraph of G,S),
          G2 be (inducedSubgraph of G,S\/{x}) such that
A1: G1 is connected and
A2: x in G.AdjacentSet(the_Vertices_of G1);
 let u,v be Vertex of G2;
      reconsider Sx = S\/{x} as Subset of the_Vertices_of G;
   the_Vertices_of G2 = Sx by GLIB_000:def 39; then
A3: (u in S or u in {x}) & (v in S or v in {x}) by XBOOLE_0:def 2;
   S c= Sx by XBOOLE_1:7; then
A4: G1 is inducedSubgraph of G2,S by Th30;
A5: the_Vertices_of G1 = S by GLIB_000:def 39; then
    consider xs being Vertex of G such that
A6: xs in S and
A7: x,xs are_adjacent by A2, Th50;
   consider e being set such that
A8: e Joins x,xs,G by A7, Def3;
A9: e Joins xs,x,G by A8, GLIB_000:17;
   x in {x} by TARSKI:def 1; then
   x in Sx & xs in Sx by A6,XBOOLE_0:def 2; then
A10: e Joins xs,x,G2 by A9, Th19;
A11: e Joins x,xs,G2 by A10,GLIB_000:17;
   per cases by A3, TARSKI:def 1;
   suppose A12: u in S & v in S;
     the_Vertices_of G1 = S by GLIB_000:def 39; then
     consider W being Walk of G1 such that
   A13: W is_Walk_from u,v by A1, A12, GLIB_002:def 1;
     reconsider W as Walk of G2 by A4, GLIB_001:168;
     take W;
     thus thesis by A13, GLIB_001:20;
   end;
   suppose A14: u in S & v = x;
     consider W being Walk of G1 such that
   A15: W is_Walk_from u,xs by A6, A5, A1, A14, GLIB_002:def 1;
     reconsider W as Walk of G2 by A4, GLIB_001:168;
     take WW = W.append(G2.walkOf(xs,e,x));
   A16: W is_Walk_from u, xs by A15,GLIB_001:20;
      G2.walkOf(xs,e,x) is_Walk_from xs,x by A10, GLIB_001:16;
     hence thesis by A14,A16,GLIB_001:32;
   end;
   suppose A17: u = x & v in S;
     consider W being Walk of G1 such that
   A18: W is_Walk_from xs,v by A6, A5, A1, A17, GLIB_002:def 1;
     reconsider W as Walk of G2 by A4, GLIB_001:168;
     take WW = G2.walkOf(x,e,xs).append(W);
   A19: W is_Walk_from xs, v by A18,GLIB_001:20;
      G2.walkOf(x,e,xs) is_Walk_from x,xs by A11, GLIB_001:16;
     hence thesis by A17,A19,GLIB_001:32;
   end;
   suppose u = x & v = x; then
       G2.walkOf(u) is_Walk_from u,v by GLIB_001:14;
     hence thesis;
   end;
end;

theorem Th58: :: Simplicial2a
for G being _Graph for S being non empty Subset of the_Vertices_of G
for H being inducedSubgraph of G,S
for u being Vertex of G st u in S & G.AdjacentSet({u}) c= S
for v being Vertex of H st u=v holds G.AdjacentSet({u}) = H.AdjacentSet({v})
proof
    let G be _Graph; let S be non empty Subset of the_Vertices_of G;
    let G2 be inducedSubgraph of G,S; let u be Vertex of G such that
A1: u in S & G.AdjacentSet({u}) c= S;
    let v be Vertex of G2 such that
A2: u=v;
    now let x be set;
        hereby assume A3: x in G.AdjacentSet({u}); then
            reconsider y=x as Vertex of G;
            reconsider w=x as Vertex of G2 by A1,A3,GLIB_000:def 39;
            y <> u & y,u are_adjacent by A3,Th52; then
            consider e being set such that
        A4: e Joins y,u,G by Def3;
            e Joins y,u,G2 by Th19,A3,A1,A4; then
            w <> v & w,v are_adjacent by A3,Th52,A2,Def3;
            hence x in G2.AdjacentSet({v}) by Th52;
        end;
        assume A5: x in G2.AdjacentSet({v}); then
        reconsider y=x as Vertex of G2;
        x in the_Vertices_of G2 by A5; then
        reconsider w=x as Vertex of G;
        y <> v & y,v are_adjacent by A5,Th52; then
        consider e being set such that
    A6: e Joins y,v,G2 by Def3;
        e Joins y,v,G by A6,GLIB_000:75; then
        w <> u & w,u are_adjacent by A5,Th52,A2,Def3;
        hence x in G.AdjacentSet({u}) by Th52;
    end;
  hence G.AdjacentSet({u}) = G2.AdjacentSet({v}) by TARSKI:2;
end;

:: Adjacency set as a subgraph of G
definition let G be _Graph, S be set;
  mode AdjGraph of G,S -> Subgraph of G means :Def5:
    it is inducedSubgraph of G,G.AdjacentSet(S)
    if S is Subset of the_Vertices_of G;
  existence proof consider T being inducedSubgraph of G,G.AdjacentSet(S);
      T is Subgraph of G;
      hence thesis;
  end;
  consistency;
end;

theorem Th59: :: AdjGraph00
for G1, G2 be _Graph st G1 == G2
for u1 being Vertex of G1, u2 being Vertex of G2 st u1 = u2
for H1 being AdjGraph of G1,{u1}, H2 being AdjGraph of G2,{u2} holds H1 == H2
proof let G1,G2 be _Graph such that A1: G1 == G2;
    let u1 be Vertex of G1, u2 be Vertex of G2 such that A2: u1 = u2;
    let H1 be AdjGraph of G1,{u1};
    let H2 be AdjGraph of G2,{u2};
    set G1Adj = G1.AdjacentSet({u1});
    set G2Adj = G2.AdjacentSet({u2});
A3: H1 is inducedSubgraph of G1,G1Adj by Def5;
A4: H2 is inducedSubgraph of G2,G2Adj by Def5;
A5: G1Adj = G2Adj by A1,A2,Th51;
    per cases;
    suppose A6: not G1Adj is non empty Subset of the_Vertices_of G1;
        H1 == G1 by A3,A6,GLIB_000:def 39; then
    A7: H1 == G2 by A1,GLIB_000:88;
        H2 == G2 by A4,A5,A6,GLIB_000:def 39;
        hence H1 == H2 by A7,GLIB_000:88; end;
    suppose A8: G1Adj is non empty Subset of the_Vertices_of G1;
    A9: the_Vertices_of H1 = G1Adj &
        the_Edges_of H1 = G1.edgesBetween(G1Adj) by A3,A8,GLIB_000:def 39;
    A10: the_Vertices_of H2 = G2Adj &
        the_Edges_of H2 = G2.edgesBetween(G2Adj) by A4,A8,A5,GLIB_000:def 39;
        G1 is Subgraph of G2 & G2 is Subgraph of G1 by A1,GLIB_000:90; then
        G1.edgesBetween(G1Adj) c= G2.edgesBetween(G1Adj) &
        G2.edgesBetween(G1Adj) c= G1.edgesBetween(G1Adj) by GLIB_000:79; then
    A11: the_Vertices_of H1 = the_Vertices_of H2 &
        the_Edges_of H1 = the_Edges_of H2 by A5,A9,A10,XBOOLE_0:def 10;
        H2 is Subgraph of G2 & G2 is Subgraph of G1 by A1,GLIB_000:90; then
        H2 is Subgraph of G1 by GLIB_000:46;
    hence H1 == H2 by A11,GLIB_000:89; end;
end;

theorem Th60: :: Simplicial2b
for G being _Graph for S being non empty Subset of the_Vertices_of G
for H being inducedSubgraph of G,S
for u being Vertex of G
  st u in S & G.AdjacentSet({u}) c= S & G.AdjacentSet({u}) <> {}
for v being Vertex of H st u=v
for Ga being AdjGraph of G,{u}, Ha being AdjGraph of H,{v} holds Ga == Ha
proof
let G be _Graph; let S being non empty Subset of the_Vertices_of G;
let H be inducedSubgraph of G,S;
let u be Vertex of G such that
A1: u in S & G.AdjacentSet({u}) c= S and
A2: G.AdjacentSet({u}) <> {};
let v be Vertex of H such that
A3: u=v;
let Ga be AdjGraph of G,{u}, Ha being AdjGraph of H,{v};
A4: G.AdjacentSet({u}) = H.AdjacentSet({v}) by A1, A3, Th58;
    Ga is inducedSubgraph of G,G.AdjacentSet({u}) by Def5; then
A5: the_Vertices_of Ga = G.AdjacentSet({u}) &
    the_Edges_of Ga = G.edgesBetween(G.AdjacentSet({u})) by A2,GLIB_000:def 39;
A6:Ha is inducedSubgraph of H,H.AdjacentSet({v}) by Def5; then
A7: the_Edges_of Ha = H.edgesBetween(H.AdjacentSet({v})) &
    the_Vertices_of Ha = H.AdjacentSet({v}) by A4,A2,GLIB_000:def 39;
thus the_Vertices_of Ga = the_Vertices_of Ha
            by A5,A6,A4,GLIB_000:def 39;
thus  A8: the_Edges_of Ga = the_Edges_of Ha by A5,A7,A4,A1,Th31;
 A9: the_Source_of Ga = (the_Source_of G)|the_Edges_of Ga &
     the_Target_of Ga = (the_Target_of G)|the_Edges_of Ga by GLIB_000:48;
     Ha is inducedSubgraph of H,G.AdjacentSet({u}) by Def5,A4; then
     Ha is inducedSubgraph of G,G.AdjacentSet({u}) by A1,A2,Th29;
hence the_Source_of Ha = the_Source_of Ga &
      the_Target_of Ha = the_Target_of Ga by A9, A8,GLIB_000:48;
end;

definition let G be _Graph;
  attr G is complete means               :Def6:
    for u,v being Vertex of G st u <> v holds u,v are_adjacent;
end;

theorem Th61: :: Completetr
for G being _Graph st G is trivial holds G is complete
proof let G be _Graph; assume G is trivial; then
    consider x being Vertex of G such that
A1: the_Vertices_of G = {x} by GLIB_000:25;
 let u,v being Vertex of G such that
A2: u <> v & not u,v are_adjacent;
    u = x & v = x by A1,TARSKI:def 1;
 hence contradiction by A2;
end;

registration
  cluster trivial -> complete _Graph;
  coherence by Th61;
end;

registration
  cluster trivial simple complete _Graph;
  existence proof consider G being trivial simple _Graph;
    take G;
    thus thesis;
  end;

  cluster non trivial finite simple complete _Graph;
  existence proof
    set V = {0,1}, E = {0}, S = 0 .--> 0, T = 0 .--> 1;
A1: dom S = E & dom T = E by CQC_LANG:5;
    now let x be set; assume x in E; then
        x = 0 by TARSKI:def 1; then
        S.x = 0 by CQC_LANG:6;
        hence S.x in V by TARSKI:def 2;
    end; then reconsider S as Function of E,V by A1, FUNCT_2:5;
    now let x be set; assume x in E; then
        x = 0 by TARSKI:def 1; then
        T.x = 1 by CQC_LANG:6;
        hence T.x in V by TARSKI:def 2;
    end; then reconsider T as Function of E,V by A1, FUNCT_2:5;
    set G = createGraph(V,E,S,T);
A2: the_Vertices_of G = V & the_Edges_of G = E & the_Source_of G = S &
      the_Target_of G = T by GLIB_000:8;
    take G;
    now assume Card (the_Vertices_of G) = 1; then
        consider x being set such that
    A3: the_Vertices_of G = {x} by CARD_2:60;
        thus contradiction by A2,A3,ZFMISC_1:9;
    end;
    hence G is non trivial & G is finite by GLIB_000:def 21;
A4: (the_Source_of G).0 = 0 by A2,CQC_LANG:6;
A5: (the_Target_of G).0 = 1 by A2,CQC_LANG:6;
    0 in the_Edges_of G by A2,TARSKI:def 1; then
A6: 0 Joins 0,1,G by A4,A5,GLIB_000:def 15;
    now let v be set;
        let e being set such that A7: e Joins v,v,G;
        reconsider v as Vertex of G by A7,GLIB_000:16;
        e in the_Edges_of G by A7,GLIB_000:def 15; then
        e Joins 0,1,G by A6,A2,TARSKI:def 1; then
        (0 = v & 1 = v) or (0 = v & 1 = v) by A7,GLIB_000:18;
        hence contradiction;
    end; then
A8: G is loopless by GLIB_000:21;
    now let e1,e2,v1,v2 be set such that
    A9: e1 Joins v1,v2,G & e2 Joins v1,v2,G;
        assume A10: e1 <> e2;
        e1 in {0} & e2 in {0} by A2,A9,GLIB_000:def 15; then
        e1 = 0 & e2 = 0 by TARSKI:def 1;
        hence contradiction by A10;
    end; then G is non-multi by GLIB_000:def 22;
    hence G is simple by A8,GLIB_000:def 24;
    now let u,v be Vertex of G such that A11: u <> v;
        per cases by A2,TARSKI:def 2;
        suppose A12: u = 0; then A13: v = 1 by A11,A2,TARSKI:def 2;
            0 in the_Edges_of G by A2,TARSKI:def 1; then
            0 Joins u,v,G by A4,A5,A12,A13,GLIB_000:def 15;
            hence u,v are_adjacent by Def3; end;
        suppose A14: u = 1; then A15: v = 0 by A11, A2,TARSKI:def 2;
            0 in the_Edges_of G by A2,TARSKI:def 1; then
            0 Joins v,u,G by A4,A5,A14,A15,GLIB_000:def 15;
            hence u,v are_adjacent by Def3; end;
    end;
    hence G is complete by Def6;
  end;
end;

theorem Th62: :: Complete00
for G1,G2 being _Graph st G1 == G2 holds G1 is complete implies G2 is complete
proof let G1,G2 be _Graph such that A1: G1 == G2;
    assume A2: G1 is complete;
    now let u,v be Vertex of G2 such that A3: u <> v;
        reconsider u2=u as Vertex of G1 by A1,GLIB_000:def 36;
        reconsider v2=v as Vertex of G1 by A1,GLIB_000:def 36;
        u2,v2 are_adjacent by A3,A2,Def6;
        hence u,v are_adjacent by A1,Th44;
    end;
    hence G2 is complete by Def6;
end;

theorem Th63: :: Complete01
for G being complete _Graph, S being Subset of the_Vertices_of G
for H being inducedSubgraph of G,S holds H is complete
proof
    let G be complete _Graph;
    let S be Subset of the_Vertices_of G;
    let H be inducedSubgraph of G,S;
    per cases;
    suppose S = {}; then
        H == G by GLIB_000:def 39;
        hence H is complete by Th62; end;
    suppose A1: S <> {};
    A2: the_Vertices_of H = S by A1,GLIB_000:def 39;
        now let u,v be Vertex of H such that A3: u <> v;
            reconsider u2=u as Vertex of G by A2,TARSKI:def 3;
            reconsider v2=v as Vertex of G by A2,TARSKI:def 3;
            u2,v2 are_adjacent by A3,Def6; then
            consider e being set such that
        A4: e Joins u2,v2,G by Def3;
            e Joins u,v,H by A2,A4,Th19;
            hence u,v are_adjacent by Def3;
        end;
        hence H is complete by Def6; end;
end;

begin :: Simplicial vertex :: Golumbic p. 81

definition let G be _Graph, v be Vertex of G;
  attr v is simplicial means                                  :Def7:
   G.AdjacentSet({v}) <> {} implies
       for G2 being AdjGraph of G,{v} holds G2 is complete;
end;

theorem Th64: :: Simplicial0
for G being complete _Graph, v being Vertex of G holds v is simplicial
proof let G be complete _Graph, v be Vertex of G;
    now let G2 be AdjGraph of G,{v};
        G2 is inducedSubgraph of G,G.AdjacentSet({v}) by Def5;
        hence G2 is complete by Th63;
    end;
    hence thesis by Def7;
end;

theorem Th65: :: Simplicial01
for G being trivial _Graph, v being Vertex of G holds v is simplicial
proof let G be trivial _Graph, v be Vertex of G;
   now assume G.AdjacentSet({v}) <> {}; then
      consider x being set such that
   A1: x in G.AdjacentSet({v}) by XBOOLE_0:def 1;
    consider u being Vertex of G such that x = u and
   A2: not u in {v} and
           ex v1 being Vertex of G st (v1 in {v} & u,v1 are_adjacent) by A1;
      consider w being Vertex of G such that
   A3: the_Vertices_of G = {w} by GLIB_000:25;
      u = w & v = w by A3, TARSKI:def 1;
    hence contradiction by A2, TARSKI:def 1;
   end;
 hence v is simplicial by Def7;
end;

theorem Th66: :: Simplicial1
for G1,G2 being _Graph st G1 == G2
for u1 being Vertex of G1, u2 being Vertex of G2
 st u1=u2 & u1 is simplicial holds u2 is simplicial
proof let G1,G2 be _Graph such that A1: G1 == G2;
    let u1 be Vertex of G1, u2 be Vertex of G2 such that A2: u1 = u2;
    assume A3: u1 is simplicial;
    now per cases;
    suppose G1.AdjacentSet({u1}) = {}; then
        G2.AdjacentSet({u2}) = {} by A1,A2,Th51;
        hence u2 is simplicial by Def7; end;
    suppose A4: G1.AdjacentSet({u1}) <> {};
        consider H1 being AdjGraph of G1,{u1};
    A5: H1 is complete by A3,A4,Def7;
    A6: now let H2 be AdjGraph of G2,{u2};
            H1 == H2 by A1,A2,Th59;
            hence H2 is complete by A5,Th62;
        end;
       thus u2 is simplicial by A6,Def7;
     end;
    end;
    hence thesis;
end;

theorem Th67: :: Simplicial2
for G being _Graph for S being non empty Subset of the_Vertices_of G
for H being inducedSubgraph of G,S
for u being Vertex of G st u in S & G.AdjacentSet({u}) c= S
for v being Vertex of H st u=v holds u is simplicial iff v is simplicial
proof
    let G be _Graph; let S be non empty Subset of the_Vertices_of G;
    let G2 be inducedSubgraph of G,S; let u be Vertex of G such that
A1: u in S & G.AdjacentSet({u}) c= S;
    let v be Vertex of G2 such that
A2: u=v;
A3: G.AdjacentSet({u}) = {} iff G2.AdjacentSet({v}) = {} by A1,A2,Th58;
   per cases;
   suppose G.AdjacentSet({u}) = {};
        hence thesis by A3,Def7; end;
   suppose A4: G.AdjacentSet({u}) <> {};
    A5: G2.AdjacentSet({v}) <> {} by A1, A2, Th58,A4;
   hereby assume A6: u is simplicial;
       consider Ga being AdjGraph of G,{u};
   A7: Ga is complete by A6, A4, Def7;
     thus v is simplicial proof
       assume G2.AdjacentSet({v}) <> {};
       let Ha be AdjGraph of G2,{v};
         Ga == Ha by A1, A2, A4, Th60;
       hence Ha is complete by A7,Th62;
     end;
   end;
   assume A8: v is simplicial;
       consider Ha being AdjGraph of G2,{v};
   A9: Ha is complete by A8, A5, Def7;
     thus u is simplicial proof
       assume G.AdjacentSet({u}) <> {};
       let Ga be AdjGraph of G,{u};
         Ga == Ha by A1, A2, A4, Th60;
       hence Ga is complete by A9,Th62;
     end;
   end;
end;

theorem Th68: :: Simplicial03
for G being _Graph, v being Vertex of G st v is simplicial
for a,b being set st a<>b & a in G.AdjacentSet({v}) & b in G.AdjacentSet({v})
  holds ex e being set st e Joins a,b,G
proof
    let G be _Graph, x be Vertex of G such that A1: x is simplicial;
    let a,b be set such that
A2: a<>b & a in G.AdjacentSet({x}) & b in G.AdjacentSet({x});
    consider H being AdjGraph of G,{x};
A3: H is complete by A1,A2,Def7;
A4: H is inducedSubgraph of G,G.AdjacentSet({x}) by Def5;
    reconsider u=a as Vertex of H by A2,A4,GLIB_000:def 39;
    reconsider v=b as Vertex of H by A2,A4,GLIB_000:def 39;
    u,v are_adjacent by A2,A3,Def6; then
    consider e being set such that
A5: e Joins u,v,H by Def3;
    e Joins a,b,G by A5,GLIB_000:75;
    hence thesis;
end;

theorem Th69: :: Simplicial03a
for G being _Graph, v being Vertex of G
 st not v is simplicial
   ex a,b being Vertex of G st a<>b & v<>a & v<>b &
          v,a are_adjacent & v,b are_adjacent & not a,b are_adjacent
proof
    let G be _Graph, v be Vertex of G such that A1: not v is simplicial;
    assume A2: not ex a,b being Vertex of G st a<>b & v<>a & v<>b &
       v,a are_adjacent & v,b are_adjacent &
       not a,b are_adjacent;
per cases;
suppose G.AdjacentSet({v}) = {};
  hence contradiction by A1,Def7; end;
suppose A3: G.AdjacentSet({v}) <> {};
A4: now let H be AdjGraph of G,{v};
    A5: H is inducedSubgraph of G,G.AdjacentSet({v}) by Def5;
        now let a,b be Vertex of H such that
        A6: a<>b;
        A7: the_Vertices_of H = G.AdjacentSet({v}) by A5,A3,GLIB_000:def 39;
            then
        a in G.AdjacentSet({v}) & b in G.AdjacentSet({v}); then
            reconsider vv=v,aa=a,bb=b as Vertex of G;
        A8: aa<>vv & aa,vv are_adjacent by A7,Th52;
        A9: bb<>vv & bb,vv are_adjacent by A7,Th52;
           aa,bb are_adjacent by A2,A6,A8,A9;
           hence a,b are_adjacent by A3,A5,Th45;
        end;
        hence H is complete by Def6;
    end;
    thus contradiction by A1,A4,Def7; end;
end;

begin :: Vertex separator  :: Golumbic, p. 84

definition let G be _Graph, a,b be Vertex of G;
 assume A1: a<>b & not a,b are_adjacent;
 mode VertexSeparator of a,b -> Subset of the_Vertices_of G means  : Def8 :
  not a in it & not b in it &
  for G2 being removeVertices of G,it holds
     not (ex W being Walk of G2 st W is_Walk_from a,b);
  existence proof
      set S = the_Vertices_of G\{a,b};
  A2: not ex e being set st e Joins a,b,G by A1,Def3;
      a in {a,b} & b in {a,b} by TARSKI:def 2; then
  A3: not a in S & not b in S by XBOOLE_0:def 4;
  A4: for G2 being removeVertices of G,S holds
        not ex W being Walk of G2 st W is_Walk_from a,b
      proof let G2 be removeVertices of G,S;
          let W be Walk of G2 such that A5: W is_Walk_from a,b;
          the_Vertices_of G\S is non empty by A3,XBOOLE_0:def 4; then
          the_Vertices_of G2 = the_Vertices_of G\S by GLIB_000:def 39;then
      A6: the_Vertices_of G2 = the_Vertices_of G /\ {a,b} by XBOOLE_1:48;
      A7: the_Vertices_of G2 = {a,b} by A6,XBOOLE_1:28;
          now let x be set such that A8: x in {a,b};
              now per cases by A8,TARSKI:def 2;
              suppose x = a; then
                  x = W.first() by A5,GLIB_001:def 23;
                  hence x in W.vertices() by GLIB_001:89; end;
              suppose x = b; then
                  x = W.last() by A5,GLIB_001:def 23;
                  hence x in W.vertices() by GLIB_001:89; end;
              end;
              hence x in W.vertices();
          end; then
          for x being set holds x in W.vertices() iff x in {a,b} by A7; then
      A9: W.vertices() = {a,b} by TARSKI:2;
          reconsider W2=W as Walk of G by GLIB_001:168;
          now let x be set;
              hereby assume x in W2.vertices(); then
                  ex n being odd Element of NAT
                     st n<=len W & W.n=x by GLIB_001:88;
                  hence x in W.vertices() by GLIB_001:88;
              end;
              assume x in W.vertices(); then
              ex n being odd Element of NAT
                    st n<=len W2 & W2.n=x by GLIB_001:88;
              hence x in W2.vertices() by GLIB_001:88;
          end; then W2.vertices() = {a,b} by TARSKI:2,A9;
          hence contradiction by A2, A1,Th22;
      end;
     thus thesis by A3,A4;
  end;
end;

theorem Th70: :: VS01
for G being _Graph, a,b being Vertex of G st a<>b & not a,b are_adjacent
for S being VertexSeparator of a,b holds S is VertexSeparator of b,a
proof
    let G be _Graph;
    let a,b be Vertex of G such that A1: a<>b & not a,b are_adjacent;
    let S be VertexSeparator of a,b;
A2: not a in S & not b in S by A1,Def8;
    for G2 being removeVertices of G,S holds
        not ex W being Walk of G2 st W is_Walk_from b,a
    proof let G2 be removeVertices of G,S;
        let W be Walk of G2 such that A3: W is_Walk_from b,a;
        W.reverse() is_Walk_from a,b by A3,GLIB_001:24;
        hence contradiction by A1, Def8;
    end;
    hence thesis by A1,A2,Def8;
end;

:: alternate characterization of Vertex Separator
theorem Th71: :: VS02
for G being _Graph, a,b being Vertex of G st a<>b & not a,b are_adjacent
for S being Subset of the_Vertices_of G holds
   S is VertexSeparator of a,b iff
   (not a in S & not b in S &
    for W being Walk of G st W is_Walk_from a,b holds
       ex x being Vertex of G st x in S & x in W.vertices())
proof
   let G be _Graph;
   let a,b be Vertex of G such that A1: a<>b & not a,b are_adjacent;
   let S be Subset of the_Vertices_of G;
   hereby assume A2: S is VertexSeparator of a,b;
     thus not a in S & not b in S by A1,A2,Def8; then
   A3: the_Vertices_of G \ S is non empty by XBOOLE_0:def 4;
     let W be Walk of G such that A4: W is_Walk_from a,b;
      now assume A5: not ex x being Vertex of G st x in S & x in W.vertices();
               let G2 be removeVertices of G,S;
           A6: the_Vertices_of G2 = the_Vertices_of G\S by A3,GLIB_000:def 39;
           A7: the_Edges_of G2 = G.edgesBetween(the_Vertices_of G2)
                   by A6,GLIB_000:def 39;
               now let x be set such that A8: x in W.vertices();
                   x in the_Vertices_of G & not x in S by A5,A8;
                   hence x in the_Vertices_of G2 by A6,XBOOLE_0:def 4;
               end; then
           A9: W.vertices() c= the_Vertices_of G2 by TARSKI:def 3;
           A10: W.edges() c= G.edgesBetween(W.vertices()) by GLIB_001:110;
               G.edgesBetween(W.vertices()) c=
               G.edgesBetween(the_Vertices_of G2) by A9,GLIB_000:39; then
               W.edges() c= the_Edges_of G2 by A10,A7,XBOOLE_1:1; then
               reconsider W2=W as Walk of G2 by A9,GLIB_001:171;
               W.first() = a & W.last() = b by A4,GLIB_001:def 23; then
               W2.first()=a&W2.last()=b; then
               W2 is_Walk_from a,b by GLIB_001:def 23;
               hence contradiction by A1,A2,Def8;
             end;
      hence ex x being Vertex of G st x in S & x in W.vertices();
     end;
   assume A11: not a in S & not b in S &
              for W being Walk of G st W is_Walk_from a,b holds
                (ex x being Vertex of G st x in S & x in W.vertices());
   now let G2 be removeVertices of G,S;
       the_Vertices_of G \ S is non empty by A11,XBOOLE_0:def 4; then
   A12: the_Vertices_of G2 = the_Vertices_of G \ S by GLIB_000:def 39;
       given W be Walk of G2 such that A13: W is_Walk_from a,b;
           reconsider W2=W as Walk of G by GLIB_001:168;
           W.first() = a & W.last() = b by A13,GLIB_001:def 23; then
           W2.first()=a&W2.last()=b; then
       A14: W2 is_Walk_from a,b by GLIB_001:def 23;
           now let x be set;
              hereby assume x in W2.vertices(); then
              ex n being odd Element of NAT st n<=len W & W.n=x by GLIB_001:88;
                  hence x in W.vertices() by GLIB_001:88;
              end;
              assume x in W.vertices(); then
            ex n being odd Element of NAT st n<=len W2 & W2.n=x by GLIB_001:88;
              hence x in W2.vertices() by GLIB_001:88;
           end; then A15: W2.vertices() = W.vertices() by TARSKI:2;
           for x being Vertex of G holds not (x in S & x in W2.vertices())
            by XBOOLE_0:def 4,A15,A12;
           hence contradiction by A11,A14;
    end;
   hence S is VertexSeparator of a,b by A1,A11,Def8;
end;

theorem Th72: :: VS07
for G being _Graph, a,b being Vertex of G st a<>b & not a,b are_adjacent
for S being VertexSeparator of a,b
for W being Walk of G st W is_Walk_from a,b
   ex k being odd Nat st 1 < k & k < len W & W.k in S
proof
    let G be _Graph;
    let a,b be Vertex of G such that A1: a<>b & not a,b are_adjacent;
    let S be VertexSeparator of a,b;
    let W be Walk of G such that A2: W is_Walk_from a,b;

A3: not a in S & not b in S by A1,Th71;
    consider x being Vertex of G such that
A4: x in S & x in W.vertices() by A1,A2,Th71;
    consider n being odd Element of NAT such that
A5: n <= len W & W.n = x by A4,GLIB_001:88;
A6: 1 <= n by HEYTING3:1;
    now assume 1 = n; then
        W.n = W.first();
        hence contradiction by A3,A4,A5,A2,GLIB_001:def 23;
    end; then A7: 1 < n by A6,REAL_1:def 5;
    now assume n = len W; then
        W.n = W.last();
        hence contradiction by A3,A4,A5, A2,GLIB_001:def 23;
    end; then n < len W by A5,REAL_1:def 5;
    hence thesis by A4,A5,A7;
end;

theorem Th73: :: VS08a
for G being _Graph, a,b being Vertex of G st a<>b & not a,b are_adjacent
for S being VertexSeparator of a,b
 st S = {} holds not ex W being Walk of G st W is_Walk_from a,b
proof
 let G be _Graph;
 let a,b be Vertex of G such that A1: a<>b & not a,b are_adjacent;
 let S be VertexSeparator of a,b;
 assume A2: S = {};
    consider G2 being removeVertices of G,S;
A3: G2 is inducedSubgraph of G,the_Vertices_of G,the_Edges_of G
             by A2,GLIB_000:37;
    the_Vertices_of G c= the_Vertices_of G; then
    the_Vertices_of G is non empty Subset of the_Vertices_of G &
    the_Edges_of G c= G.edgesBetween(the_Vertices_of G) by GLIB_000:37; then
A4: the_Vertices_of G2 = the_Vertices_of G &
    the_Edges_of G2 = the_Edges_of G by A3,GLIB_000:def 39;
    given W be Walk of G such that A5: W is_Walk_from a,b;
A6: W.vertices() c= the_Vertices_of G2 by A4;
A7: W.edges() c= the_Edges_of G2 by A4;
    reconsider W2=W as Walk of G2 by A6,A7,GLIB_001:171;
    W.first() = a & W.last() = b by A5,GLIB_001:def 23; then
    W2.first()=a&W2.last()=b; then
    W2 is_Walk_from a,b by GLIB_001:def 23;
 hence contradiction by A1,Def8;
end;

theorem
for G being _Graph, a,b being Vertex of G
 st a<>b &not a,b are_adjacent & not ex W being Walk of G st W is_Walk_from a,b
  holds {} is VertexSeparator of a,b
proof
 let G be _Graph;
 let a,b be Vertex of G such that A1: a<>b & not a,b are_adjacent;
 assume A2: not ex W being Walk of G st W is_Walk_from a,b;
A3: {} is Subset of the_Vertices_of G by XBOOLE_1:2;
    now let G2 be removeVertices of G,{};
      given W be Walk of G2 such that
    A4: W is_Walk_from a,b or W is_Walk_from b,a;
        per cases by A4;
        suppose A5: W is_Walk_from a,b;
          reconsider W2=W as Walk of G by GLIB_001:168;
          W.first() = a & W.last() = b by A5,GLIB_001:def 23; then
          W2.first()=a&W2.last()=b;
          then W2 is_Walk_from a,b by GLIB_001:def 23;
          hence contradiction by A2;
        end;
        suppose A6: W is_Walk_from b,a;
            set P=W.reverse();
        A7: P is_Walk_from a,b by A6,GLIB_001:24;
            reconsider W2=P as Walk of G by GLIB_001:168;
            P.first() = a & P.last() = b by A7,GLIB_001:def 23; then
            W2.first()=a&W2.last()=b;
            then W2 is_Walk_from a,b by GLIB_001:def 23;
            hence contradiction by A2;
        end;
      end;
     hence {} is VertexSeparator of a,b by A1,A3,Def8;
 end;

theorem Th75: :: VS11
for G being _Graph, a,b being Vertex of G st a<>b & not a,b are_adjacent
for S being VertexSeparator of a,b, G2 being removeVertices of G,S
for a2 being Vertex of G2 st a2=a holds G2.reachableFrom(a2) /\ S = {}
proof
    let G be _Graph;
    let a,b be Vertex of G such that A1: a<>b & not a,b are_adjacent;
    let S be VertexSeparator of a,b, G2 be removeVertices of G,S;
    let a2 be Vertex of G2 such that a2=a;
    set A = G2.reachableFrom(a2);
    not a in S by Def8,A1; then
    a in the_Vertices_of G \ S by XBOOLE_0:def 4; then
A2: the_Vertices_of G2 = the_Vertices_of G \ S by GLIB_000:def 39;
    now let x be set such that A3: x in A /\ S;
        x in A & x in S by A3,XBOOLE_0:def 3;
        hence contradiction by A2,XBOOLE_0:def 4;
    end;
    hence thesis by XBOOLE_0:def 1;
end;

theorem Th76: :: VS11b
for G being _Graph, a,b being Vertex of G st a<>b & not a,b are_adjacent
for S being VertexSeparator of a,b, G2 being removeVertices of G,S
for a2,b2 being Vertex of G2 st a2=a & b2=b holds
   G2.reachableFrom(a2) /\ G2.reachableFrom(b2) = {}
proof
    let G be _Graph;
    let a,b be Vertex of G such that A1: a<>b & not a,b are_adjacent;
    let S be VertexSeparator of a,b, G2 be removeVertices of G,S;
    let a2,b2 be Vertex of G2 such that A2: a2=a and A3: b2=b;
    set A = G2.reachableFrom(a2), B = G2.reachableFrom(b2);
    now let x be set such that A4: x in A /\ B;
        x in A by A4,XBOOLE_0:def 3; then
        consider W1 being Walk of G2 such that
    A5: W1 is_Walk_from a2,x by GLIB_002:def 5;
        x in B by A4,XBOOLE_0:def 3; then
        consider rW2 being Walk of G2 such that
    A6: rW2 is_Walk_from b2,x by GLIB_002:def 5;
        set W2 = rW2.reverse();
        set W = W1.append(W2);
        W2 is_Walk_from x,b2 by A6,GLIB_001:24; then
        W is_Walk_from a2,b2 by A5,GLIB_001:32;
        hence contradiction by A1,A2,A3,Def8;
    end;
    hence thesis by XBOOLE_0:def 1;
end;

theorem Th77: :: VS10
for G being _Graph, a,b being Vertex of G st a<>b & not a,b are_adjacent
for S being VertexSeparator of a,b for G2 being removeVertices of G,S
 holds a is Vertex of G2 & b is Vertex of G2
proof
    let G be _Graph;
    let a,b be Vertex of G such that A1: a<>b & not a,b are_adjacent;
    let S be VertexSeparator of a,b, G2 be removeVertices of G,S;
    not a in S & not b in S by Def8,A1; then
    a in the_Vertices_of G\S & b in the_Vertices_of G\S by XBOOLE_0:def 4;
    hence thesis by GLIB_000:def 39;
end;

definition let G be _Graph, a,b be Vertex of G;
  let S be VertexSeparator of a,b;
  attr S is minimal means                                          : Def9 :
     for T being Subset of S st T <> S holds not T is VertexSeparator of a,b;
end;

theorem Th78 : :: VS000
for G being  _Graph, a,b being Vertex of G
for S being VertexSeparator of a,b st S = {} holds S is minimal
proof
   let G be _Graph;
   let a,b be Vertex of G, S be VertexSeparator of a,b;
   assume A1: S = {};
   now assume not S is minimal; then
       consider T being Subset of S such that
   A2: T <> S & T is VertexSeparator of a,b by Def9;
      thus contradiction by A2,A1, XBOOLE_1:3;
   end;
   hence S is minimal;
end;

theorem Th79 : :: minVSexistance
for G being finite _Graph for a,b being Vertex of G
 ex S being VertexSeparator of a,b st S is minimal
proof let G be finite _Graph, a,b be Vertex of G;
    set X = {S where S is VertexSeparator of a,b : not contradiction };
    consider s being VertexSeparator of a,b;
A1: s in X;
    now let x be set; assume x in X; then
        consider y being VertexSeparator of a,b such that A2: x = y;
        thus x in bool the_Vertices_of G by A2;
    end; then
    X c= bool the_Vertices_of G by TARSKI:def 3; then
    reconsider X as non empty finite set by A1, FINSET_1:13;

    defpred P[set,set] means
      ex p being VertexSeparator of a,b st $1 = p & $2 = card p;

A3: now let x be set such that A4: x in X;
        consider Y being VertexSeparator of a,b such that
    A5: Y = x by A4;
        card Y is Element of NAT;
        hence ex y being set st y in REAL & P[x,y] by A5;
    end;
    consider F being Function of X, REAL such that
A6: for x being set st x in X holds P[x,F.x] from FUNCT_2:sch 1(A3);
A7: dom F = X by FUNCT_2:def 1;
    deffunc FF(Element of X) = F/.$1;
    consider Min being Element of X such that
A8: for N being Element of X holds FF(Min) <= FF(N) from GRAPH_5:sch 2;
    consider M being VertexSeparator of a,b such that
A9: M = Min & card M = F.Min by A6;
    M in dom F by A7; then
A10: F/.M = F.M by FINSEQ_4:def 4;

    now per cases;
    suppose M = {}; hence M is minimal by Th78; end;
    suppose M <> {};
        now assume not M is minimal; then
            consider T being Subset of M such that
        A11: T<>M & T is VertexSeparator of a,b by Def9;
            T in X by A11; then
            reconsider T2=T as Element of X;
            consider Tp being VertexSeparator of a,b such that
        A12: Tp=T2 & card Tp = F.T2 by A6;
            Tp in dom F by A7; then
        A13: F/.Tp = F.Tp by FINSEQ_4:def 4;
        A14: card M <= card T by A10,A9,A12,A13,A8;
        A15: card T <= card M by CARD_1:80;
            card T <> card M by A11,TRIANG_1:3;
            hence contradiction by A14, A15,REAL_1:def 5;
        end;
        hence M is minimal; end;
    end;
    hence thesis;
end;

theorem Th80: :: VS13
:: Property "symmetry" for 2 argument modes could be used if we had it
:: as VertexSeparator of a,b is a VertexSeparator of b,a
:: then this theorem would not be needed
for G being _Graph, a,b being Vertex of G st a<>b & not a,b are_adjacent
for S being VertexSeparator of a,b st S is minimal
for T being VertexSeparator of b,a st S=T holds T is minimal
proof
    let G be _Graph;
    let a,b be Vertex of G such that A1: a<>b and A2: not a,b are_adjacent;
    let S be VertexSeparator of a,b such that A3: S is minimal;
    let T be VertexSeparator of b,a such that A4: S=T;
    assume not T is minimal; then
        consider H being Subset of T such that
    A5: H <> T & H is VertexSeparator of b,a by Def9;
        H is Subset of S & H <> S & H is VertexSeparator of a,b
            by A1,A2,A5,A4,Th70;
    hence contradiction by A3,Def9;
end;

theorem :: VS06: :: :: VS06
for G being _Graph, a,b being Vertex of G st a<>b & not a,b are_adjacent
for S being VertexSeparator of a,b st S is minimal
for x being Vertex of G st x in S
    ex W being Walk of G st W is_Walk_from a,b & x in W.vertices()
proof
    let G be _Graph;
    let a,b be Vertex of G such that A1: a<>b and A2: not a,b are_adjacent;
    let S be VertexSeparator of a,b such that A3: S is minimal;
    let x be Vertex of G such that A4: x in S; assume
A5: not ex W being Walk of G st W is_Walk_from a,b & x in W.vertices();
    set T = S\{x};
    x in {x} by TARSKI:def 1;  then
A6: T <> S by A4,XBOOLE_0:def 4;
A7: T c= S by XBOOLE_1:36;
A8: not a in T & not b in T by A1,A2,A7,Def8;
    now let W be Walk of G such that A9: W is_Walk_from a,b;
         consider y being Vertex of G such that
    A10: y in S & y in W.vertices() by A1,A2,A9,Th71;
        take y;
        y <> x by A5,A9,A10;
        then not y in {x} by TARSKI:def 1;
      hence y in T by A10,XBOOLE_0:def 4;
      thus y in W.vertices() by A10;
    end; then T is VertexSeparator of a,b by A1,A2,A8,Th71;
  hence contradiction by A3,A6,A7,Def9;
end;

theorem Th82: :: VertexSep0
for G being _Graph
for a,b being Vertex of G st a<>b & not a,b are_adjacent
for S being VertexSeparator of a,b st S is minimal
for H being removeVertices of G,S for aa being Vertex of H st aa=a
for x being Vertex of G st x in S
    ex y being Vertex of G st y in H.reachableFrom(aa) & x,y are_adjacent
proof
    let G be _Graph;
    let a,b be Vertex of G such that A1: a<>b and A2: not a,b are_adjacent;
    let S be VertexSeparator of a,b such that A3: S is minimal;
    let H be removeVertices of G,S;
    let aa be Vertex of H such that A4: aa=a;
    let x be Vertex of G such that A5: x in S;
    reconsider bb=b as Vertex of H by A1,A2,Th77;

    set T = S\{x};
    set A=H.reachableFrom(aa), B=H.reachableFrom(bb);
    assume A6: not ex y being Vertex of G st
                   y in H.reachableFrom(aa) & x,y are_adjacent;
    A7: for W being Walk of G st W is_Walk_from a,b & x in W.vertices()
            ex y being Vertex of G st y in T & y in W.vertices()
        proof let W be Walk of G such that
        A8: W is_Walk_from a,b and A9: x in W.vertices();
            consider k being odd Element of NAT such that
        A10: k <= len W & W.k = x by A9,GLIB_001:88;
        A11: 0+1 <= W.find(x) by HEYTING3:1;
            now assume W.find(x) = 1; then
                W.(W.find(x)) = W.first(); then
                W.(W.find(x)) = a by A8,GLIB_001:def 23; then
                 not W.(W.find(x)) in S by A1,A2,Def8;
              hence contradiction by A5, A9,GLIB_001:def 19;
            end; then
            2*0+1 < W.find(x) by A11,REAL_1:def 5; then
            2*1+1 <= W.find(x) by Th4; then
        A12: 3+(-2) <= W.find(x)+(-2) by XREAL_1:9; then
            0 <= W.find(x)-2 by XREAL_1:2; then
        A13: W.find(x)-2 is Element of NAT by INT_1:16; then
            reconsider j=W.find(x)-2*1 as odd Nat;
            W.find(W.k) <= k by A10,GLIB_001:116; then
        A14: W.find(x) <= len W by A10,XREAL_1:2; then
        A15: W.find(x)+(-2) <= len W+0 by XREAL_1:9;
            per cases;
            suppose A16: W.j in T;
                W.j in the_Vertices_of G & W.j in W.vertices()
                    by A13, A15,GLIB_001:8,GLIB_001:88;
                hence thesis by A16;
            end;
            suppose not W.j in T;
              assume
            A17: not ex y being Vertex of G st y in T & y in W.vertices();
                    set P = W.cut(1,j);
                A18: 2*0+1 <= j & j <= len W by A15,A12; then
                A19: len P + 1 + (-1) = j + 1 + (-1) by A13, GLIB_001:37;
                A20: for n being odd Nat st n <= j holds not P.n in S & P.n=W.n
                    proof let n be odd Nat such that A21: n <= j;
                        1 <= n by HEYTING3:1; then
                        1+(-1) <= n+(-1) by XREAL_1:9; then
                     A22: n-1 is Element of NAT by INT_1:16;then
                        reconsider nu1 = n-1 as Nat;
                        n < j + 1 by A21,NAT_1:38; then
                        n+(-1) < j+1+(-1) by XREAL_1:10; then
                    A23: P.(nu1+1) = W.(1+nu1) by A22, A19,A18,GLIB_001:37;
                        now assume A24: P.n in S;
                        A25: n in NAT by ORDINAL1:def 13; then
                        A26: P.n in P.vertices() by A19,A21,GLIB_001:88;
                       P.vertices() c= W.vertices() by A13, A18
,GLIB_001:95;then
                        A27: not P.n in T by A26,A17;
                        A28: {x} c= S by A5,ZFMISC_1:37;
                            S \/ {x} = {x} \/ T by XBOOLE_1:39; then
                            S = {x} \/ T by A28,XBOOLE_1:12; then
                        A29: P.n in {x} by A24,A27,XBOOLE_0:def 2;
                        A30: n <= len W by A15,A21,XREAL_1:2;
                            n < j + 1 by A21,NAT_1:38; then
                        A31: n+0 < j + 1 + 1 by XREAL_1:10;
                            n < W.find(W.n) by A29,A31,A23,TARSKI:def 1;
                            hence contradiction by A25, A30,GLIB_001:116;
                        end;
                        hence thesis by A23;
                    end; then
                    for n being odd Nat st n <= j holds not P.n in S; then
                    reconsider HP=P as Walk of H by A19,Th21;
                    W.first() = a by A8,GLIB_001:def 23; then
                    P.(2*0+1) = a by A12,A20; then
                    aa in HP.vertices() by A4,A12,A19,GLIB_001:88; then
                A32: HP.vertices() c= A by GLIB_002:13;
                    P.j in HP.vertices() by A19,GLIB_001:88; then
                A33: W.j in HP.vertices() by A20;
                    P.j is Vertex of G by A19,GLIB_001:8; then
                    reconsider Wj=W.j as Vertex of G by A20;
                    W.find(x) < len W + 1 by A14,NAT_1:38; then
                    W.find(x)+(-2) < len W + 1 + (-2) by XREAL_1:10; then
                    j < len W - 1 & len W +(-1) < len W+0 by XREAL_1:10; then
                    j < len W by XREAL_1:2; then
                    W.(j+1) Joins Wj,W.(j+2),G by A13, GLIB_001:def 3; then
                    W.(j+1) Joins Wj,x,G by A9,GLIB_001:def 19; then
                    Wj,x are_adjacent by Def3;
                    hence contradiction by A33,A32,A6;
                end;
            end;
        x in {x} by TARSKI:def 1;  then
    A34: T <> S by A5,XBOOLE_0:def 4;
    A35: T c= S by XBOOLE_1:36;
    A36: not a in T & not b in T by A1,A2,A35,Def8;
        now let W be Walk of G such that A37: W is_Walk_from a,b;
            consider y being Vertex of G such that
        A38: y in S & y in W.vertices() by A1,A2,A37,Th71;
            per cases;
            suppose y = x;
             hence ex y being Vertex of G st y in T & y in W.vertices()
                     by A37,A38,A7;
            end;
            suppose A39: y <> x;
              take y;
                not y in {x} by A39, TARSKI:def 1;
              hence y in T by A38,XBOOLE_0:def 4;
              thus y in W.vertices() by A38;
            end;
        end; then T is VertexSeparator of a,b by A1,A2,A36,Th71;
      hence contradiction by A3,A35,A34,Def9;
end;

theorem Th83: :: VertexSep01
:: Property "symmetry" for 2 argument modes could be used if we had it
:: as VertexSeparator of a,b is a VertexSeparator of b,a
for G being _Graph
for a,b being Vertex of G st a<>b & not a,b are_adjacent
for S being VertexSeparator of a,b st S is minimal
for H being removeVertices of G,S for aa being Vertex of H st aa=b
for x being Vertex of G st x in S
    ex y being Vertex of G st y in H.reachableFrom(aa) & x,y are_adjacent
proof let G be _Graph, a,b be Vertex of G such that
A1: a<>b and
A2: not a,b are_adjacent;
   let S be VertexSeparator of a,b such that
A3: S is minimal;
   let H be (removeVertices of G,S), aa be Vertex of H such that
A4: aa=b;
   let x be Vertex of G such that
A5: x in S;
   reconsider S1 = S as VertexSeparator of b,a by A1,A2,Th70;
A6: S1 is minimal by A1, A2, A3, Th80;
 thus thesis by A1,A2,A4,A6,A5,Th82;
end;

begin :: Chordal graphs :: Golumbic, p. 81

:: The notion of a chord.  Is it worthwhile having it?

:: definition let G be _Graph, W be Walk of G, e be set;
::   pred e is_chord_of W means
::   ex m, n being odd Nat st m < n & n <= len W & W.m <> W.n &
::      e Joins W.m,W.n,G &
::      for f being set st f in W.edges() holds not f Joins W.m,W.n,G;
:: end;

:: More general notion of a chordal Walk.  Is such a notion useful? Or
:: should we stick with chordal Path?

definition let G be _Graph, W be Walk of G;
  attr W is chordal means                                      :Def10:
  ex m, n being odd natural number st m+2 < n & n <= len W & W.m <> W.n &
     (ex e being set st e Joins W.m,W.n,G) &
     for f being set st f in W.edges() holds not f Joins W.m,W.n,G;
end;

notation let G be _Graph, W be Walk of G;
  antonym W is chordless for W is chordal;
end;

:: The other characterization of chordal is 'more' technical and
:: sometimes more convenient to work with.  Is this really true?
:: I have tried to save as much as possible of what Broderic has already done.
:: Need separate theorems for walks and paths!  They cannot be put as an iff.

theorem Th84: :: ChordalWalk01
for G being _Graph, W being Walk of G
 st W is chordal
  ex m,n being odd natural number st m+2 < n & n <= len W & W.m <> W.n &
     (ex e being set st e Joins W.m,W.n,G) &
     (W is Cycle-like implies  not (m=1 & n = len W) &
                               not (m=1 & n = len W-2) &
                               not (m=3 & n = len W))
proof let G be _Graph, W be Walk of G;
  given m, n being odd Nat such that
A1: m+2 < n and
A2: n <= len W and
A3: W.m <> W.n and
A4: ex e being set st e Joins W.m,W.n,G and
A5: for f being set st f in W.edges() holds not f Joins W.m,W.n,G;
    take m, n;
    thus m+2 < n by A1;
    thus n <= len W by A2;
    thus W.m <> W.n by A3;
    thus ex e being set st e Joins W.m,W.n,G by A4;
    assume A6: W is Cycle-like; then
  A7: W is closed by GLIB_001:def 31;
      W is non trivial by A6, GLIB_001:def 31; then
  A8: 3 <= len W by GLIB_001:126; then
  A9: 1 < len W by XREAL_1:2;
  A10:  W.first() = W.1 & W.last() = W.len W; then
  A11: W.1 = W.len W by A7, GLIB_001:def 24;
    thus not (m=1 & n = len W) by A3, A10, A7, GLIB_001:def 24;
       2 <= len W by A8, XREAL_1:2; then
       reconsider lW2 = len W -2*1 as odd Element of NAT by INT_1:18;
       reconsider lW2 as odd Nat;
  A12: lW2 < len W by XREAL_1:46;
       W.(lW2+1) Joins W.(lW2),W.(lW2+2),G by A12,GLIB_001:def 3; then
  A13: W.(lW2+1) Joins W.1,W.(lW2),G by A11,GLIB_000:17;
       reconsider le = lW2+1 as even Nat;
  A14:  le in NAT by ORDINAL1:def 13;
  A15: 1 <= le by NAT_1:37;
  A16: le <= len W by A12,NAT_1:38;
       le div 2 in dom W.edgeSeq() by A15, A16, A14,GLIB_001:78; then
       W.edgeSeq().(le div 2) in rng W.edgeSeq() by FUNCT_1:12; then
       W.(len W -2+1) in W.edges() by A15, A16,A14, GLIB_001:78;
    hence not (m=1 & n = len W-2) by A13, A5;
  A17: 2*0+1 is odd Nat;
      W.(1+1) Joins W.1,W.(1+2),G by A17,A9,GLIB_001:def 3; then
  A18: W.(1+1) Joins W.(1+2),W.len W,G by A11, GLIB_000:17;
  A19: 2*1 div 2 = 1 by NAT_1:68;
  A20: 1+1 <= len W by A8,XREAL_1:2;
      1 in dom W.edgeSeq() by A19, A20, GLIB_001:78; then
      W.edgeSeq().1 in rng W.edgeSeq() by FUNCT_1:12; then
      W.(1+1) in rng W.edgeSeq() by A19, A20, GLIB_001:78;
    hence not (m=3 & n = len W) by A18, A5;
end;

theorem Th85: :: ChordalPath01
for G being _Graph, P being Path of G
 st ex m,n being odd natural number st m+2 < n & n <= len P &
       (ex e being set st e Joins P.m,P.n,G) &
       (P is Cycle-like implies  not (m=1 & n = len P) &
                                 not (m=1 & n = len P-2) &
                                 not (m=3 & n = len P))
  holds P is chordal
proof let G be _Graph, P be Path of G;
  given m, n being odd Nat such that
A1: m+2 < n and
A2: n <= len P and
A3: ex e being set st e Joins P.m,P.n,G and
A4: P is Cycle-like implies
     not (m=1 & n = len P) & not (m=1 & n = len P-2) & not (m=3 & n = len P);
  take m,n;
A5: m in NAT & n in NAT by ORDINAL1:def 13;
A6: m < n by A1, NAT_1:37;
  thus m+2 < n by A1;
  thus n <= len P by A2;
A7: m < len P by A6, A2, XREAL_1:2;
   now assume len P = 1; then m+2 < 1 by A1, A2, XREAL_1:2;
    hence contradiction by NAT_1:37;
   end; then
A8: P is non trivial by GLIB_001:127;
  hereby assume A9: P.m = P.n; then
  A10: m = 1 & n = len P by A5, A6, A2, GLIB_001:def 28;
      P.first() = P.1 & P.last() = P.len P; then
      P is closed by A9, A10, GLIB_001:def 24;
    hence contradiction by A5, A9,A6,A2,GLIB_001:def 28, A4,A8,GLIB_001:def 31;
  end;
  thus ex e being set st e Joins P.m,P.n,G by A3;
  let f be set such that
A11: f in P.edges() and
A12: f Joins P.m,P.n,G;
   consider i being Element of NAT such that
A13: i in dom P.edgeSeq() and
A14: P.edgeSeq().i = f by A11,FINSEQ_2:11;
A15: 1 <= i & i <= len P.edgeSeq() by A13, FINSEQ_3:27; then
A16: P.edgeSeq().i = P.(2*i) by GLIB_001:def 15;
   set k = 2*i-1;
   2*1 <= 2*i by A15, XREAL_1:66; then
   2-1 <= k by XREAL_1:11; then
   0 <= k by XREAL_1:2; then
   k is Element of NAT by INT_1:16; then
   reconsider k as odd Nat;
A17: k+1 = 2*i;
A18: k in NAT by ORDINAL1:def 13;
   2*i in dom P by A13, GLIB_001:79; then
   2*i <= len P by FINSEQ_3:27; then
A19: k < len P by A17, NAT_1:38; then
A20: P.(k+1) Joins P.k,P.(k+2),G by A18,GLIB_001:def 3;
A21: k+2 <= len P by A19, Th4;
A22: k+2 in NAT by ORDINAL1:def 13;
   per cases by A20, A16, A14, A12, GLIB_000:18;
   suppose A23: P.k = P.m & P.(k+2) = P.n;
    per cases by XREAL_1:1;
    suppose k < m;
     hence contradiction by A23, A7, A18,A5,GLIB_001:def 28;
    end;
    suppose A24: k = m;
     per cases by XREAL_1:1;
     suppose k+2 < n; then
     A25: k+2 = 1 by A23, A2,A22,A5,GLIB_001:def 28;
         1 <= k by HEYTING3:1; then
         k+2 < k+1 by A25, NAT_1:38;
      hence contradiction by XREAL_1:8;
     end;
     suppose k+2 = n;
       hence contradiction by A24, A1;
     end;
     suppose A26: k+2 > n;
       k+2 <= len P by A19,Th4; then
       n = 1 by A23, A26, A22,A5,GLIB_001:def 28;
      hence contradiction by A1,HEYTING3:1;
     end;
    end;
    suppose k > m;
     hence contradiction by A23, A19, A18,A5,GLIB_001:def 28;
    end;
   end;
   suppose A27: P.k = P.n & P.(k+2) = P.m;
    per cases by XREAL_1:1;
    suppose A28: k < n; then
    A29: k = 1 & n = len P by A27, A2, A18,A5,GLIB_001:def 28;
     per cases by XREAL_1:1;
     suppose k+2 < m;
      hence contradiction by A27,A7,A22,A5,GLIB_001:def 28;
     end;
     suppose A30: k+2 = m;
         P.first() = P.1 & P.last() = P.len P; then
         P is closed by A29, A27, GLIB_001:def 24;
      hence contradiction by A29, A30, A4, A8, GLIB_001:def 31;
    end;
     suppose k+2 > m; then
     A31: m = 1 & k+2 = len P by A21, A27, A22,A5,GLIB_001:def 28;
     A32: k+2 <= n by A28, Th4;
         P.first() = P.1 & P.last() = P.len P; then
         P is closed by A31, A27, GLIB_001:def 24;
      hence contradiction by A32,A2,XREAL_1:1,A31, A4, A8, GLIB_001:def 31;
     end;
    end;
    suppose A33: k = n;
     per cases by XREAL_1:1;
     suppose k+2 < m;       hence contradiction by NAT_1:37, A33, A6;
     end;
     suppose k+2 = m;
       hence contradiction by A6, A33, NAT_1:37;
     end;
     suppose k+2 > m; then
     A34: m = 1 & k+2 = len P by A27, A21, A22,A5,GLIB_001:def 28;
         P.first() = P.1 & P.last() = P.len P; then
         P is closed by A34, A27, GLIB_001:def 24;
      hence contradiction by A34, A4, A33, A8, GLIB_001:def 31;
     end;
    end;
    suppose k > n;
     hence contradiction by A19, A27, A18,A5,GLIB_001:def 28;
    end;
   end;
end;

theorem Th86: :: ChordalWalk02
for G1,G2 being _Graph st G1 == G2
for W1 being Walk of G1, W2 being Walk of G2
 st W1=W2 holds W1 is chordal implies  W2 is chordal
proof let G1,G2 be _Graph such that A1: G1 == G2;
  let W1 be Walk of G1, W2 be Walk of G2 such that A2: W1 = W2;
  given m, n being odd Nat such that
A3: m+2 < n & n <= len W1 & W1.m <> W1.n and
A4: ex e being set st e Joins W1.m,W1.n,G1 and
A5: for f being set st f in W1.edges() holds not f Joins W1.m,W1.n,G1;
  take m,n;
  thus m+2 < n & n <= len W2 & W2.m <> W2.n by A3, A2;
       consider e being set such that
A6: e Joins W1.m,W1.n,G1 by A4;
   e Joins W2.m,W2.n,G2 by A6, A1, A2, GLIB_000:91;
  hence ex e being set st e Joins W2.m,W2.n,G2;
  let f be set;
  assume f in W2.edges(); then f in W1.edges() by A2, GLIB_001:111; then
    not f Joins W1.m,W1.n,G1 by A5;
  hence not f Joins W2.m,W2.n,G2 by A1, A2, GLIB_000:91;
end;

theorem Th87: :: ChordalWalk03
for G being _Graph, S being non empty Subset of the_Vertices_of G,
    H being (inducedSubgraph of G,S), W1 being Walk of G, W2 being Walk of H
  st W1 = W2 holds W2 is chordal iff W1 is chordal
proof let G be _Graph, S be non empty Subset of the_Vertices_of G,
      H be (inducedSubgraph of G,S), W1 be Walk of G, W2 be Walk of H such that
A1: W1 = W2;
A2: S = the_Vertices_of H by GLIB_000:def 39;
 thus W2 is chordal implies W1 is chordal
 proof  given m, n being odd Nat such that
A3: m+2 < n & n <= len W2 & W2.m <> W2.n and
A4: ex e being set st e Joins W2.m,W2.n,H and
A5: for f being set st f in W2.edges() holds not f Joins W2.m,W2.n,H;
  take m,n;
  thus m+2 < n & n <= len W1 & W1.m <> W1.n by A3, A1;
       consider e being set such that
A6: e Joins W2.m,W2.n,H by A4;
   e Joins W1.m,W1.n,G by A6, A1, GLIB_000:75;
  hence ex e being set st e Joins W1.m,W1.n,G;
  let f be set;
  assume f in W1.edges(); then
A7: f in W2.edges() by A1, GLIB_001:111; then
   not f Joins W1.m,W1.n,H by A5, A1;
  hence not f Joins W1.m,W1.n,G by A7, GLIB_000:76;
 end;
 thus W1 is chordal implies W2 is chordal
 proof given m, n being odd Nat such that
A8: m+2 < n & n <= len W1 & W1.m <> W1.n and
A9: ex e being set st e Joins W1.m,W1.n,G and
A10: for f being set st f in W1.edges() holds not f Joins W1.m,W1.n,G;
  take m,n;
A11: m in NAT & n in NAT by ORDINAL1:def 13;
  thus m+2 < n & n <= len W2 & W2.m <> W2.n by A8, A1;
       consider e being set such that
A12: e Joins W1.m,W1.n,G by A9;
   m < n by A8, NAT_1:37; then
   m <= len W2 by A8, A1, XREAL_1:2; then
   W1.m in the_Vertices_of H & W1.n in the_Vertices_of H
        by A8,A1,A11,GLIB_001:8;
     then e Joins W2.m,W2.n,H  by A1, A2, A12, Th19;
  hence ex e being set st e Joins W2.m,W2.n,H;
  let f be set;
  assume f in W2.edges(); then
   f in W1.edges() by A1, GLIB_001:111; then
   not f Joins W2.m,W2.n,G by A10, A1;
  hence not f Joins W2.m,W2.n,H by GLIB_000:75;
 end;
end;

theorem
for G being _Graph, W being Walk of G
 st W is Cycle-like & W is chordal & W.length()=4
    holds ex e being set st e Joins W.1,W.5,G or e Joins W.3,W.7,G
proof let G be _Graph, W be Walk of G such that
A1: W is Cycle-like & W is chordal and
A2: W.length() = 4;
    W is closed by A1,GLIB_001:def 31; then
A3: W.first() = W.last() by GLIB_001:def 24;
A4: len W = 2*4+1 by A2,GLIB_001:113;
 assume A5: not(ex e being set st e Joins W.1,W.5,G or e Joins W.3,W.7,G);
    consider m, n being odd Nat such that
A6: m+2 < n & n <= len W & W.m <> W.n &
    (ex e being set st e Joins W.m,W.n,G) &
    (W is Cycle-like implies (not (m=1 & n = len W) &
    not (m=1 & n = len W-2) & not (m=3 & n = len W))) by A1,Th84;
    consider e being set such that
A7: e Joins W.m,W.n,G by A6;
A8: 0+1 <= m by HEYTING3:1;
    now assume A9: m = 1; then
            n < len W by A1,A6,REAL_1:def 5; then
        A10: n <= 9 - 2 by A4,Th3;
            reconsider jj=2*3+1 as odd Nat;
            n < jj by A1,A4,A6,A9,A10,REAL_1:def 5; then
        A11: n <= jj-2 by Th3;
            n <> 5 by A7,A9,A5; then n < 2*2+1 by A11,REAL_1:def 5; then
            n <= 5-2 by Th3;
            hence contradiction by A6, A9;
    end; then 2*0+1 < m by A8,REAL_1:def 5; then
    A12: 1+2 <= m by Th4;
        now assume A13: m = 3; then
            n < len W by A1,A6,REAL_1:def 5; then
        A14: n <= 9 - 2 by A4,Th3;
            n <> 7 by A7,A13,A5; then n < 2*3+1 by A14,REAL_1:def 5; then
            n <= 7 - 2 by Th3;
            hence contradiction by A6, A13;
        end; then 2*1+1 < m by A12,REAL_1:def 5; then
    A15: 3+2 <= m by Th4;
        now assume A16: m = 5;
            now assume n = 9; then
                e Joins W.1,W.5,G by A16,A7,A4,A3,GLIB_000:17;
                hence contradiction by A5;
            end; then n < len W by A6,A4,REAL_1:def 5; then
            n <= len W - 2 by Th3;
            hence contradiction by A4,A16,A6;
        end; then 2*2+1 < m by A15,REAL_1:def 5; then
        5+2 <= m by Th4; then
        7+2 <= m + 2 by XREAL_1:9;
        hence contradiction by A4,A6,XREAL_1:2;
end;

theorem Th89: :: MinChordal01
for G being _Graph, W being Walk of G st W is minlength holds W is chordless
proof
  let G be _Graph, W be Walk of G; assume
A1: W is minlength; assume
  W is chordal; then
  consider m,n being odd Nat such that
A2: m+2 < n and
A3: n <= len W and
   W.m <> W.n and
A4: ex e being set st e Joins W.m,W.n,G and
   (W is Cycle-like implies not (m=1 & n = len W) &
                            not (m=1 & n = len W-2) &
                            not (m=3 & n = len W)) by Th84;
 thus contradiction by A1, A2, A3, A4, Th40;
end;

theorem
for G being _Graph, W being Walk of G
 st W is open & len W = 5 & not W.first(),W.last() are_adjacent
  holds W is chordless
proof let G be _Graph, W be Walk of G such that
A1: W is open & len W = 5 & not W.first(),W.last() are_adjacent;
    assume W is chordal; then
    consider m,n being odd Nat such that
A2: m+2 < n & n <= len W & W.m <> W.n and
A3: ex e being set st e Joins W.m,W.n,G and
     (W is Cycle-like implies  not (m=1 & n = len W) &
                               not (m=1 & n = len W-2) &
                               not (m=3 & n = len W)) by Th84;
    consider e being set such that
A4: e Joins W.m,W.n,G by A3;
A5: now assume m <> 1; then 1 <> m & 1 <= m by Th2; then
       2*0+1 < m by REAL_1:def 5; then
       1+2 <= m by Th4; then
       3+2 <= m+2 by XREAL_1:9;
      hence contradiction by A2,A1,XREAL_1:2;
    end; then
    3+2 <= n by Th4, A2; then
    W.n = W.last() by A1,A2,XREAL_1:1;
  hence contradiction by A1,A4,A5,Def3;
end;

Lm3:
for G being _Graph, W being Walk of G holds
   W is chordal implies W.reverse() is chordal
proof let G be _Graph, W be Walk of G;
    set U = W.reverse();
    assume W is chordal; then
    consider m, n being odd Nat such that
A1: m+2 < n & n <= len W & W.m <> W.n and
A2: ex e being set st e Joins W.m,W.n,G and
A3: for f being set st f in W.edges() holds not f Joins W.m,W.n,G
       by Def10;
A4: m in NAT & n in NAT by ORDINAL1:def 13;
    consider e being set such that
A5: e Joins W.m,W.n,G by A2;
    m < m+2 by XREAL_1:31; then
    m < n by A1,XREAL_1:2; then
A6: 1 <= m & m <= len W & 1 <= n & n <= len W by Th2,A1,XREAL_1:2; then
A7: m in dom W & n in dom W by FINSEQ_3:27;

    set um = len W - m + 1, un = len W - n + 1;
    reconsider um, un as odd Element of NAT by A6,A4,FINSEQ_5:1;
    reconsider um, un as odd Nat;
A8: un + 2 < um by A1,Lm1;
    0 < m by A6,XREAL_1:2; then
    len W - m < len W by XREAL_1:46; then
    len W - m + 1 <= len W by INT_1:20; then
A9: um <= len U by GLIB_001:22;
A10: W.edges() = U.edges() by GLIB_001:108;
A11: W.m = U.um & W.n = U.un & un in dom U & um in dom U by A7,GLIB_001:25;
A12: now let f be set such that A13: f in U.edges();
      assume f Joins U.un,U.um,G; then
        f Joins W.m,W.n,G by A11,GLIB_000:17;
      hence contradiction by A13,A10,A3;
    end;
    e Joins U.un,U.um,G by A5,A11,GLIB_000:17;
  hence U is chordal by A8,A9,A11,A1,A12,Def10;
end;

theorem
for G being _Graph, W being Walk of G
  holds W is chordal iff W.reverse() is chordal
proof let G be _Graph, W be Walk of G;
   thus W is chordal implies  W.reverse() is chordal by Lm3;
   assume W.reverse() is chordal; then
   W.reverse().reverse() is chordal by Lm3;
   hence W is chordal by GLIB_001:27;
end;

theorem Th92: :: CPath03
for G being _Graph, P being Path of G st P is open & P is chordless
  for m,n being odd natural number st m < n & n <= len P holds
    (ex e being set st e Joins P.m,P.n,G) iff m+2 = n
proof let G be _Graph, P be Path of G such that
A1: P is open & P is chordless;
    let m,n be odd Nat such that
A2: m < n & n <= len P;
A3: m in NAT & n in NAT by ORDINAL1:def 13;
A4: P.m <> P.n by A1,A2,A3,GLIB_001:148;
A5: P is vertex-distinct by A1,Th32;
A6: m <= len P by A2,XREAL_1:2;
  hereby assume A7: ex e being set st e Joins P.m,P.n,G;
  A8: m+2 <= n by A2,Th4;
      now assume A9: m+2 < n;
        now let f be set such that A10: f in P.edges();
            consider k being odd Element of NAT such that
        A11: k < len P & P.(k+1) = f by A10,GLIB_001:101;
        A12: k+2 <= len P by A11,Th4;
        A13: f Joins P.k,P.(k+2),G by A11,GLIB_001:def 3;
          assume A14: f Joins P.m,P.n,G;
          per cases by A14,A13,GLIB_000:18;
          suppose P.m = P.k & P.n = P.(k+2); then
            m = k & n = k+2*1 by A6,A2,A11,A12,A5,A3,GLIB_001:def 29;
          hence contradiction by A9; end;
          suppose P.m = P.(k+2) & P.n = P.k; then
          A15: m = k+2*1 & n = k by A6,A2,A11,A12,A5,A3,GLIB_001:def 29;
          A16: m > n by A15,XREAL_1:31;
              m+2 > m by XREAL_1:31;
          hence contradiction by A9,A16,XREAL_1:2; end;
        end;
        hence contradiction by A1,A2,A4,A7,A9,Def10;
      end;
   hence m+2 = n by A8,XREAL_1:1;
  end;
  assume A17: m+2 = n;
  take P.(m+1);
    m < len P by A2,XREAL_1:2;
  hence P.(m+1) Joins P.m,P.n,G by A17,A3,GLIB_001:def 3;
end;

theorem
for G being _Graph, P being Path of G st P is open & P is chordless
for m,n being odd natural number st m < n & n <= len P
  holds P.cut(m,n) is chordless & P.cut(m,n) is open
proof let G be _Graph, P be Path of G such that
A1: P is open & P is chordless;
    let m,n be odd Nat such that A2: m < n & n <= len P;
    set Q = P.cut(m,n);
A3: m in NAT & n in NAT by ORDINAL1:def 13;
  now assume Q is chordal; then
    consider i,j being odd Nat such that
A4: i+2 < j & j <= len Q & Q.i <> Q.j and
A5: ex e being set st e Joins Q.i,Q.j,G and
    for f being set st f in Q.edges() holds not f Joins Q.i,Q.j,G
       by Def10;
    consider e being set such that
A6: e Joins Q.i,Q.j,G by A5;
    set mi = m+i-1;  set mj = m+j-1;
    i+0<i+2 by XREAL_1:10; then
    i<j by A4,XREAL_1:2; then
    1 <= i & i < len Q by A4,Th2,XREAL_1:2; then
A7: i in dom Q by FINSEQ_3:27; then
A8: Q.i = P.mi & mi in dom P by A2,A3,GLIB_001:48;
    1 <= j & j <= len Q by A4,Th2; then
    j in dom Q by FINSEQ_3:27; then
A9: Q.j = P.mj & mj in dom P by A2,A3,GLIB_001:48;
    reconsider mi as odd Element of NAT by A8;
    reconsider mi as odd Nat;
    reconsider mj as odd Element of NAT by A9;
    reconsider mj as odd Nat;
A10: e Joins P.mi,P.mj,G by A7, A2,A3,GLIB_001:48,A9,A6;
    i+2+m < j+m by A4,XREAL_1:10; then
A11: m+i+2-1 < m+j-1 by XREAL_1:11; then
A12: mi+2 < mj;
    mi+0 < mi+2 by XREAL_1:10; then
A13: mi < mj by A11,XREAL_1:2;
    mj <= len P by A9,FINSEQ_3:27;
  hence contradiction by A12, A1,A10,A13,Th92;
  end;
  hence Q is chordless;
  now assume Q is closed; then
  A14: Q.first() = Q.last() by GLIB_001:def 24;
      P.m = Q.first() & P.n = Q.last() by A2,A3,GLIB_001:38;
    hence contradiction by A14, A1,A2,A3,GLIB_001:148;
  end;
  hence Q is open;
end;

theorem
for G being _Graph, S being non empty Subset of the_Vertices_of G,
    H being (inducedSubgraph of G,S), W being Walk of G, V being Walk of H
 st W = V holds W is chordless iff V is chordless
proof let G be _Graph, S be non empty Subset of the_Vertices_of G;
    let H be inducedSubgraph of G,S;
    let W be Walk of G, V be Walk of H such that
A1: W = V;
    hereby assume A2: W is chordless;
    assume V is chordal; then
    consider m,n being odd Nat such that
A3: m+2 < n & n <= len V & V.m <> V.n and
A4: (ex e being set st e Joins V.m,V.n,H) and
A5: for f being set st f in V.edges() holds not f Joins V.m,V.n,H
      by Def10;
A6: m in NAT & n in NAT by ORDINAL1:def 13;
    consider e being set such that
A7: e Joins V.m,V.n,H by A4;
A8: e Joins W.m,W.n,G by A1, A7,GLIB_000:75;
    m+0 <= m+2 by XREAL_1:9; then m <= n by A3,XREAL_1:2; then
    m <= len V by A3,XREAL_1:2; then
    V.n in V.vertices() & V.m in V.vertices() by A3,A6,GLIB_001:88; then
    V.n in the_Vertices_of H & V.m in the_Vertices_of H; then
A9: V.n in S & V.m in S by GLIB_000:def 39;
    for f being set st f in W.edges() holds not f Joins W.m,W.n,G proof
        let f be set such that A10: f in W.edges();
        assume A11: f Joins W.m,W.n,G;
    A12: f Joins V.m,V.n,H by A1, A9,A11,Th19;
        f in V.edges() by A1,A10,GLIB_001:111;
      hence contradiction by A5,A12;
    end;
  hence contradiction by A2,Def10,A8,A1,A3;
  end;
    assume
A13: V is chordless;
    assume W is chordal; then
    consider m,n being odd Nat such that
A14: m+2 < n & n <= len W & W.m <> W.n and
A15: (ex e being set st e Joins W.m,W.n,G) and
A16: for f being set st f in W.edges() holds not f Joins W.m,W.n,G
      by Def10;
A17: m in NAT & n in NAT by ORDINAL1:def 13;
    consider e being set such that
A18: e Joins W.m,W.n,G by A15;

    m+0 <= m+2 by XREAL_1:9; then m <= n by A14,XREAL_1:2; then
    m <= len W by A14,XREAL_1:2; then
    W.n in V.vertices() & W.m in V.vertices() by A1,A14,A17,GLIB_001:88; then
    W.n in the_Vertices_of H & W.m in the_Vertices_of H; then
    W.n in S & W.m in S by GLIB_000:def 39; then
A19: e Joins V.m,V.n,H by A1, A18,Th19;
    for f being set st f in V.edges() holds not f Joins V.m,V.n,H proof
        let f be set such that A20: f in V.edges();
        assume A21: f Joins V.m,V.n,H;
    A22: f Joins W.m,W.n,G by A1, A21,GLIB_000:75;
        f in W.edges() by A1,A20,GLIB_001:111;
      hence contradiction by A16,A22;
    end;
  hence contradiction by A13,Def10,A19,A1, A14;
end;

definition let G be _Graph;
 attr G is chordal means                                     :Def11:
  for P being Walk of G st P.length() > 3 & P is Cycle-like holds P is chordal;
end;

theorem Th95: :: Chordal01
for G1,G2 being _Graph st G1 == G2 holds G1 is chordal implies G2 is chordal
proof
    let G1,G2 be _Graph such that A1: G1 == G2;
    assume A2: G1 is chordal;
    now let W be Walk of G2 such that A3: W.length() > 3 & W is Cycle-like;
        reconsider W2=W as Walk of G1 by A1,GLIB_001:180;
        2*W2.length() + 1 = len W by GLIB_001:113; then
    A4: 2*W2.length() + 1 = 2*W.length() + 1 by GLIB_001:113;
        W2 is Cycle-like by A3,A1,Th24; then
        W2 is chordal by A4,A3,A2,Def11;
        hence W is chordal by A1,Th86;
    end;
    hence thesis by Def11;
end;

theorem Th96: :: Chordal02
for G being finite _Graph st card the_Vertices_of G <= 3 holds G is chordal
proof let G be finite _Graph such that A1: card the_Vertices_of G <= 3;
    now let W be Walk of G such that A2: W.length() > 3 & W is Cycle-like;
        reconsider n1=2*0+1 as odd Nat; reconsider n2=2*1+1 as odd Nat;
        reconsider n3=2*2+1 as odd Nat; reconsider n4=2*3+1 as odd Nat;
        set x1=W.n1; set x2=W.n2; set x3=W.n3; set x4=W.n4;
        W.length() >= 3+1 by A2,NAT_1:38; then
        2*W.length() >= 2*4 by XREAL_1:66; then
        2*W.length() + 1 >= 8 + 1 by XREAL_1:9; then
        len W >= 9 by GLIB_001:113; then
    A3: n1 < len W & n2 < len W & n3 < len W & n4 < len W by XREAL_1:2;
    A4: W is Path-like by A2, GLIB_001:def 31;
    A5: x1 <> x2 by A4, A3,GLIB_001:def 28;
    A6: x1 <> x3 by A4, A3,GLIB_001:def 28;
    A7: x1 <> x4 by A4, A3,GLIB_001:def 28;
    A8: x2 <> x3 by A4, A3,GLIB_001:def 28;
    A9: x2 <> x4 by A4, A3,GLIB_001:def 28;
    A10: x3 <> x4 by A4, A3,GLIB_001:def 28;
   A11: card {x1,x2,x3,x4} = 4 by A5,A6,A7,A8,A9,A10,CARD_2:78;
        now let x be set; assume A12: x in {x1,x2,x3,x4};
          now per cases by A12,ENUMSET1:def 2;
            suppose x=x1; hence x in the_Vertices_of G by A3,GLIB_001:8; end;
            suppose x=x2; hence x in the_Vertices_of G by A3,GLIB_001:8; end;
            suppose x=x3; hence x in the_Vertices_of G by A3,GLIB_001:8; end;
            suppose x=x4; hence x in the_Vertices_of G by A3,GLIB_001:8; end;
            end;
          hence x in the_Vertices_of G;
        end; then
        {x1,x2,x3,x4} c= the_Vertices_of G by TARSKI:def 3; then
        4 <= card the_Vertices_of G by A11,CARD_1:80;
        hence contradiction by A1,XREAL_1:2;
    end; then for W being Walk of G st W.length() > 3 & W is Cycle-like
              holds W is chordal;
    hence G is chordal by Def11;
end;

registration
  cluster trivial finite chordal _Graph;
  existence proof
      consider G being trivial finite _Graph;
      consider v being Vertex of G such that
  A1: the_Vertices_of G = {v} by GLIB_000:25;
      now let W be Walk of G such that A2: W.length() > 3 & W is Cycle-like;
          2*W.length() > 2*3 by A2,XREAL_1:70; then
          2*W.length() + 1 > 6 + 1 by XREAL_1:10; then
      A3: len W > 7 by GLIB_001:113;
          reconsider j3=2*1+1 as odd Nat;
          reconsider j5=2*2+1 as odd Nat;
      A4: j3 <= len W & j5 <= len W by A3,XREAL_1:2; then
          W.j3 in W.vertices() & W.j5 in W.vertices() by GLIB_001:88; then
          W.j3 = v & W.j5 = v by A1, TARSKI:def 1;
          then not W is Path-like by A4, GLIB_001:def 28;
          hence contradiction by A2, GLIB_001:def 31;
      end; then
      for W being Walk of G st W.length() > 3 & W is Cycle-like
          holds W is chordal;
      then G is chordal by Def11;
      hence thesis;
  end;

  cluster non trivial finite simple chordal _Graph;
  existence proof
    set V = {0,1}, E = {0}, S = 0 .--> 0, T = 0 .--> 1;
A5: dom S = E & dom T = E by CQC_LANG:5;
    now let x be set; assume x in E; then
        x = 0 by TARSKI:def 1; then
        S.x = 0 by CQC_LANG:6;
        hence S.x in V by TARSKI:def 2;
    end; then reconsider S as Function of E,V by A5, FUNCT_2:5;
    now let x be set; assume x in E; then
        x = 0 by TARSKI:def 1; then
        T.x = 1 by CQC_LANG:6;
        hence T.x in V by TARSKI:def 2;
    end; then reconsider T as Function of E,V by A5, FUNCT_2:5;
    set G = createGraph(V,E,S,T);
A6: the_Vertices_of G = V & the_Edges_of G = E & the_Source_of G = S &
      the_Target_of G = T by GLIB_000:8;
    take G;
    now assume Card (the_Vertices_of G) = 1; then
        consider x being set such that
    A7: the_Vertices_of G = {x} by CARD_2:60;
        thus contradiction by A6,A7,ZFMISC_1:9;
    end;
    hence G is non trivial & G is finite by GLIB_000:def 21;
A8: (the_Source_of G).0 = 0 by A6,CQC_LANG:6;
A9: (the_Target_of G).0 = 1 by A6,CQC_LANG:6;
    0 in the_Edges_of G by A6,TARSKI:def 1; then
A10: 0 Joins 0,1,G by A8,A9,GLIB_000:def 15;
    now let v be set;
        let e being set such that A11: e Joins v,v,G;
        reconsider v as Vertex of G by A11,GLIB_000:16;
        e in the_Edges_of G by A11,GLIB_000:def 15; then
        e Joins 0,1,G by A10, A6,TARSKI:def 1; then
        (0 = v & 1 = v) or (0 = v & 1 = v) by A11,GLIB_000:18;
        hence contradiction;
    end; then
A12: G is loopless by GLIB_000:21;
    now let e1,e2,v1,v2 be set such that
    A13: e1 Joins v1,v2,G & e2 Joins v1,v2,G;
        assume A14: e1 <> e2;
        e1 in {0} & e2 in {0} by A6,A13,GLIB_000:def 15; then
        e1 = 0 & e2 = 0 by TARSKI:def 1;
        hence contradiction by A14;
    end; then G is non-multi by GLIB_000:def 22;
    hence G is simple by A12,GLIB_000:def 24;
    card the_Vertices_of G = 2 by A6, CARD_2:76;
    hence G is chordal by Th96;
  end;

  cluster complete -> chordal _Graph;
  correctness proof
    let G be _Graph; assume A15: G is complete;
    now let W be Walk of G such that A16: W.length() > 3 & W is Cycle-like;
    A17:  W is Path-like by A16,GLIB_001:def 31;
        W.length() >= 3+1 by A16,NAT_1:38; then
        2*W.length() >= 2*4 by XREAL_1:66; then
        2*W.length() + 1 >= 8 + 1 by XREAL_1:9; then
    A18: len W >= 9 by GLIB_001:113;
        reconsider t3=2*1+1 as odd Nat;
        reconsider t7=2*3+1 as odd Nat;
        t3 <= len W by A18,XREAL_1:2; then
        reconsider W3=W.t3 as Vertex of G by GLIB_001:8;
    A19: t7 <= len W by A18,XREAL_1:2; then
        reconsider W7=W.t7 as Vertex of G by GLIB_001:8;
        W3 <> W7 by A17, A19,GLIB_001:def 28;
        then W3,W7 are_adjacent by A15,Def6; then
        consider e being set such that
    A20: e Joins W3,W7,G by Def3;
        t3+2 < t7 & t7 <= len W & not (t3=3 & t7 = len W) by A18,XREAL_1:2;
        hence W is chordal by A17, A20,Th85;
    end;
    hence G is chordal by Def11;
  end;
end;

registration let G be chordal _Graph, V be set;
  cluster -> chordal inducedSubgraph of G,V;
  coherence proof
    let H be inducedSubgraph of G,V;
    now per cases;
    suppose not V is non empty Subset of the_Vertices_of G;
        then H == G by GLIB_000:def 39;
        hence H is chordal by Th95; end;
    suppose V is non empty Subset of the_Vertices_of G; then
    A1: V = the_Vertices_of H by GLIB_000:def 39;
    now let W be Walk of H such that
    A2: W.length() > 3 and A3: W is Cycle-like;
    A4: W is Path-like by A3, GLIB_001:def 31;
        reconsider P=W as Walk of G by GLIB_001:168;
        reconsider P as Path of G by A4, GLIB_001:176;
        W is closed & W is non trivial & W is Path-like
            by A3,GLIB_001:def 31; then
   A5: P is closed & P is non trivial & P is Path-like by GLIB_001:177; then
    A6: P is Cycle-like by GLIB_001:def 31;
        P.length() > 3 by A2,GLIB_001:115; then
        P is chordal by A6,Def11; then
        consider m, n being odd Nat such that A7: m+2 < n & n <= len P and
        P.m <> P.n and
    A8: (ex e being set st e Joins P.m,P.n,G) &
        (P is Cycle-like implies
        not (m=1 & n = len P) & not (m=1 & n = len P-2) &
        not (m=3 & n = len P)) by Th84;
    A9: m in NAT & n in NAT by ORDINAL1:def 13;
        consider e being set such that
    A10: e Joins P.m,P.n,G by A8;
        m + 0 <= m + 2 by XREAL_1:9; then
        m <= n by A7,XREAL_1:2; then
        m <= len P by A7,XREAL_1:2; then
        P.m in the_Vertices_of H & P.n in the_Vertices_of H
            by A7,A9,GLIB_001:8; then
        e Joins P.m,W.n,H by A1,A10,Th19;
        hence W is chordal by A4,A5,GLIB_001:def 31,A7,A8,Th85;
    end;
    hence H is chordal by Def11; end; end;
    hence H is chordal;
  end;
end;

theorem
for G being chordal _Graph, P being Path of G st P is open & P is chordless
for x,e being set st (not x in P.vertices() & e Joins P.last(),x,G &
                      not ex f being set st f Joins P.(len P-2),x,G)
  holds P.addEdge(e) is Path-like & P.addEdge(e) is open &
        P.addEdge(e) is chordless
proof let G be chordal _Graph, P be Path of G such that
A1: P is open & P is chordless;
    let x,e be set such that
A2: not x in P.vertices() and
A3: e Joins P.last(),x,G and
A4: not ex f being set st f Joins P.(len P-2),x,G;
    reconsider Q = P.addEdge(e) as Path of G by A1,A2,A3,GLIB_001:152;
A5: now let n be odd Nat such that A6: n <= len P;
       1 <= n & n <= len P by Th2,A6; then
       n in dom P by FINSEQ_3:27;
      hence P.n = Q.n by A3,GLIB_001:66;
    end;
A7: Q.first() = P.first() & Q.last() = x by A3,GLIB_001:64;
A8: Q.first() in P.vertices() by A7,GLIB_001:89;
A9: len Q = len P + 2 by A3,GLIB_001:65;

:: this proof turned into something of a nightmare...
:: cleaner way to do it?
    defpred P[Nat] means
      (4 <= 2*$1 & 2*$1 <= len P+1) implies
        for j being odd Nat st j + 2*$1 = len P + 2 holds
           not ex e being set st e Joins Q.j,x,G;
A10: for k being Nat st for a being Nat st a < k holds P[a] holds P[k] proof
        let k be Nat such that A11: for a being Nat st a < k holds P[a];
        assume A12: 4 <= 2*k & 2*k <= len P+1;
        let j be odd Nat such that A13: j + 2*k = len P + 2;
        let e be set such that A14: e Joins Q.j,x,G;
    A15: k in NAT & j in NAT by ORDINAL1:def 13;
        j + 4 <= j + 2*k by A12,XREAL_1:9; then
    A16: j + 4 - 4 <= len P + 2 - 4 by A13,XREAL_1:11;
   A17: len P - 2 <= len P by XREAL_1:45; then
   A18: j <= len P by A16,XREAL_1:2;
      per cases by A16,REAL_1:def 5;
      suppose A19: j = len P - 2;
        Q.j = P.(len P - 2) by A5,A17,A19;
      hence contradiction by A14,A4; end;
      suppose A20: j < len P - 2*1;
        len P < len P + 2 by XREAL_1:31; then
    A21: j <= len P + 2 by A18,XREAL_1:2;

        reconsider jj = j as odd Element of NAT by ORDINAL1:def 13;
        reconsider lP2 = len P+2 as odd Element of NAT;

        set B = Q.cut(jj,lP2);
    A22: len B + j = len P + 2 + 1 by A9,A21,GLIB_001:37;
    A23: len P + 3 - (len P - 2) < len P + 3 - j by A20,XREAL_1:17; then
   A24: 3 < len B by A22,XREAL_1:2;
   A25: B.first() = Q.j & B.last() = Q.(len P + 2)
             by A21,A9,GLIB_001:38;
   A26: B.first() = Q.j & B.last() = x by A7,A21,A9,GLIB_001:38;
        P.vertexAt(j) = P.j by A18,GLIB_001:def 8; then
        P.j in P.vertices() by A15,A18,GLIB_001:90;  then
        B.first() in P.vertices() by A25,A18,A5; then
    A27: B is open by A26,A2,GLIB_001:def 24;
    A28: now let i be even Nat such that A29: i < len B-1;
        A30: i in NAT by  ORDINAL1:def 13;
            len B - 1 < len B by XREAL_1:46; then
            i < len B by A29,XREAL_1:2; then
        A31: B.(i+1) = Q.(j+i) & j+i in dom Q by A9,A21,A30,GLIB_001:37;then
        A32: 1 <= j + i & j + i <= len P + 2 by A9,FINSEQ_3:27;
           j + i < (len B - 1) + j by A29,XREAL_1:10; then
           j + i <= len P + 2 - 2 by A22,Th3;
           hence B.(i+1) = P.(j+i) & j+i in dom P by A5,A31,A32,FINSEQ_3:27;
        end;

        set C = B.addEdge(e);
    A33: e Joins B.last(),B.first(),G by A14,A26,GLIB_000:17;
    A34: now let n be odd Nat such that A35: n <= len B;
           1 <= n & n <= len B by Th2,A35; then
           n in dom B by FINSEQ_3:27;
         hence C.n = B.n by A33,GLIB_001:66;
        end;
    A36: C is Cycle-like by A33,A24,A27,Th33;

    A37: C.first() = Q.j & C.last() = Q.j
             by A25,A33,GLIB_001:64;
    A38: len C = len B + 2 by A33,GLIB_001:65;
        len B + 2 > 5 + 2 by A23,A22, XREAL_1:10; then
   A39: len C > 7 by A33,GLIB_001:65;
        now assume C.length() <= 3; then
            2*C.length() <= 2*3 by XREAL_1:66; then
            2*C.length()+1 <= 2*3+1 by XREAL_1:8;
          hence contradiction by A39,GLIB_001:113;
        end; then
        C is chordal by A36,Def11; then
        consider m,n being odd Nat such that
    A40: m+2 < n & n <= len C & C.m <> C.n and
    A41: ex e being set st e Joins C.m,C.n,G and
    A42: (C is Cycle-like implies  not (m=1 & n = len C) &
                                  not (m=1 & n = len C-2) &
                                  not (m=3 & n = len C)) by Th84;
        consider e being set such that
    A43: e Joins C.m,C.n,G by A41;

        1 <= m by Th2; then 1-1 <= m-1 by XREAL_1:11; then
        reconsider m1 = m-1 as even Element of NAT by INT_1:16;
        reconsider m1 as even Nat;
        1 <= n by Th2; then 1-1 <= n-1 by XREAL_1:11; then
        reconsider n1 = n-1 as even Element of NAT by INT_1:16;
        reconsider n1 as even Nat;
        m < m+2 by XREAL_1:31; then
        m < n by A40,XREAL_1:2; then
    A44: m1 < n1 by XREAL_1:11;
    A45: m+2-1 <n-1 by A40,XREAL_1:11;
        m+2 < len B+2 by A40,XREAL_1:2,A38; then
    A46: m+2-2 < len B+2-2 by XREAL_1:11;
        m1 < len B-1 by A46, XREAL_1:11; then
    A47: B.(m1+1) = P.(j+m1) & j+m1 in dom P by A28; then
    A48: B.m = P.(j+m1) & j+m1 <= len P by FINSEQ_3:27;
        now assume A49: n = len C; then
             e Joins P.(j+m1),Q.j,G by A37,A43,A47,A34,A46; then
             e Joins P.(j+m1),P.j,G by A5,A18; then
         A50: e Joins P.j,P.(j+m1),G by GLIB_000:17;
            now assume m <= 3; then m <= 4 by XREAL_1:2;
              hence contradiction by A49,A42,A33,A24,A27,Th33,Th7;
            end; then
        A51: 2+1-1 < m-1 by XREAL_1:11;
        A52: j + 2 < j+m1 by A51, XREAL_1:10;
            0 < m1 by A51,XREAL_1:2; then
            j < j+m1 by XREAL_1:31;
          hence contradiction by A50,A52,A1,A48,Th92;
        end; then n < len B+2*1 by A38,A40,REAL_1:def 5; then
    A53: n <= len B+2-2 by Th3;

        now assume A54: n = len B;
        A55: C.n = x by A54,A26,A34;
            1 <> m & 1 <= m by Th2,A54,A38,A42,A33,A24,A27,Th33; then
            1 < m by REAL_1:def 5; then
        A56: 1-1 < m-1 by XREAL_1:11;
             j+m1 <= len P & len P < len P + 2
                by A47,FINSEQ_3:27,XREAL_1:31; then
         j+m1 < len P+2*1 by XREAL_1:2; then
            consider kk being Nat such that
        A57: (j+m1) + 2*kk = len P+2 by Lm2;
        A58:   now assume 2*kk < 3+1; then 2*kk <= 3 by NAT_1:38; then
                  2*kk = 0 or 2*kk = 2 by Th11;
              hence contradiction by A54,A40,A22,A57;
            end;
        A59:  now assume 2*kk > len P + 1; then
            A60:2*kk >= len P + 1 + 1 by NAT_1:38;
              2*kk + m1 > 2*kk & 2*kk + m1 +j >= 2*kk + m1
                 by A56,XREAL_1:31,NAT_1:29;
              hence contradiction by A57,A60, XREAL_1:2;
            end;
        A61: now assume kk >= k; then
            A62: 2*kk >= 2*k by XREAL_1:66;
                j + 2*kk + m1 > j + 2*kk by A56,XREAL_1:31;
              hence contradiction by A57,A13, A62, XREAL_1:9;
            end;
            C.m = B.m by A46,A34; then
            C.m = Q.(j+m1) by A48,A5;
          hence contradiction by A61,A11,A57,A58,A59,A55,A43;
        end; then
        n < len B by A53,REAL_1:def 5; then
        n1 < len B-1 by XREAL_1:11; then
        B.(n1+1) = P.(j+n1) & j+n1 in dom P by A28; then
   A63: B.n = P.(j+n1) & j+n1 <= len P by FINSEQ_3:27;
   A64: C.m = B.m & C.n = B.n by A46,A53,A34;
   A65: j+m1 < j+n1 by A44,XREAL_1:10;
        j+(m1+2) < j+n1 by A45,XREAL_1:10; then
        j+m1+2 < j+n1;
      hence contradiction by A1,A63,A64,A43,A47,A65,Th92; end;
    end;

A66: for k being Element of NAT st
        for a being Element of NAT st a < k holds P[a] holds P[k] proof
        let k be Element of NAT such that
    A67: for a being Element of NAT st a < k holds P[a];
        for a being Nat st a < k holds P[a] proof
           let a be Nat such that A68: a < k;
           a in NAT by ORDINAL1:def 13;
         hence P[a] by A67,A68;
        end;
      hence P[k] by A10;
    end;
 A69: for k being Element of NAT holds P[k] from NAT_1:sch 4(A66);

A70: now let n be odd Nat such that A71: n <= len P-2;
        len P-2 <= len P-2+4 by XREAL_1:33; then
        n <= len P + 2*1 by A71,XREAL_1:2; then
        consider k being Nat such that
    A72: n + 2*k = len P + 2 by Lm2;
    A73: k in NAT by ORDINAL1:def 13;
    A74: now assume A75: 2*k < 4;
            n + 4 <= len P-2+4 by A71,XREAL_1:9;
          hence contradiction by A72,A75,XREAL_1:10;
        end;
        now assume A76: 2*k > len P + 1;
            1 <= n by Th2; then
            n + 2*k > 1 + (len P + 1) by A76,XREAL_1:10;
          hence contradiction by A72;
        end;
      hence not ex e being set st e Joins Q.n,x,G by A72,A74,A69,A73;
    end;
    now assume Q is chordal; then
        consider m,n being odd Nat such that
    A77: m+2 < n & n <= len Q & Q.m <> Q.n and
    A78: ex e being set st e Joins Q.m,Q.n,G and
        (Q is Cycle-like implies  not (m=1 & n = len Q) &
         not (m=1 & n = len Q-2) & not (m=3 & n = len Q)) by Th84;
        consider e being set such that
    A79: e Joins Q.m,Q.n,G by A78;
        m < m+2 by XREAL_1:31; then
    A80: m < n by A77,XREAL_1:2;
        m+2 < len P+2 by A77,XREAL_1:2,A9; then
    A81: m+2-2 < len P+2-2 by XREAL_1:11;
      per cases by A77,REAL_1:def 5;
      suppose A82: n = len Q; then
          m+2-2 < len P+2-2 by A9,A77,XREAL_1:11; then
          m <= len P-2 by Th3;

      hence contradiction by A70,A79,A82,A7; end;
      suppose n < len Q; then
    A83: n <= len P + 2 - 2 by A9,Th3; then
        Q.m = P.m & Q.n = P.n by A5,A81;
      hence contradiction by A77,A79,A1,A80,A83,Th92; end;
    end;
  hence thesis by A8,A2,A7,GLIB_001:def 24;
end;


:: Golumbic, page 83. Theorem 4.1  (i) ==> (iii)
theorem Th98:  :: :: Chordal41:  : PR
for G being chordal _Graph, a,b being Vertex of G
 st a<>b & not a,b are_adjacent
  for S being VertexSeparator of a,b st S is minimal & S is non empty
  for H being inducedSubgraph of G,S holds H is complete
proof let G be chordal _Graph;
  set tVG = the_Vertices_of G;
     let a,b be Vertex of G such that
  A1: a<>b and
  A2: not a,b are_adjacent;
     let S be VertexSeparator of a,b such that
  A3: S is minimal and
  A4: S is non empty;
     let Gs be inducedSubgraph of G,S;

     consider Gns being removeVertices of G,S;
     reconsider sa = a, sb = b as Vertex of Gns by A1, A2, Th77;
     set A = Gns.reachableFrom(sa), B = Gns.reachableFrom(sb);
A5:  S is VertexSeparator of b,a by A1,A2,Th70;
A6: A/\B = {} by A1, A2,Th76;
 A7: A/\S = {} & B /\ S = {} by A5,A1,A2,Th75;

     consider Ga being inducedSubgraph of Gns,A;
     consider Gb being inducedSubgraph of Gns,B;
A8: the_Vertices_of Ga = A by GLIB_000:def 39;
A9: the_Vertices_of Gb = B by GLIB_000:def 39;

     the_Vertices_of Gns c= tVG; then
     reconsider A, B as non empty Subset of tVG by XBOOLE_1:1;
     not a in S by A1,A2,Def8; then
 A10: tVG\S is non empty Subset of tVG by XBOOLE_0:def 4;
      now let x be set such that A11: x in A;
          not x in S by A7,A11,XBOOLE_0:def 3;
          hence x in tVG \ S by A11,XBOOLE_0:def 4;
      end; then
A12: A c= tVG \ S by TARSKI:def 3;
      now let x be set such that A13: x in B;
          not x in S by A7,A13,XBOOLE_0:def 3;
          hence x in tVG \ S by A13,XBOOLE_0:def 4;
      end; then
A14: B c= tVG \ S by TARSKI:def 3;
   reconsider Ga as inducedSubgraph of G,A by A10,A12,Th29;
   reconsider Gb as inducedSubgraph of G,B by A10,A14,Th29;

  let x,y be Vertex of Gs such that
A15: x <> y and
A16: not x,y are_adjacent;
    reconsider xg = x, yg = y as Vertex of G by GLIB_000:45;
A17: S = the_Vertices_of Gs by A4,GLIB_000:def 39;
A18: not xg,yg are_adjacent by A16, A4, Th45;
    set xy = {xg, yg}; :: xy is Subset of tVG

        :: We construct minimal paths in Ga1 and Gb1 and append them
        :: to get a long enough cycle

      set Bx = B\/{xg}, Ax = A\/{xg};
      consider Gax being inducedSubgraph of G,Ax;
  A19: the_Vertices_of Gax = Ax by GLIB_000:def 39;
      consider Ga1 being inducedSubgraph of G,A\/{x}\/{y};
  A20: A\/{x}\/{y} = A\/({x}\/{y}) by XBOOLE_1:4 .= A\/xy by ENUMSET1:41;then
  A21: the_Vertices_of Ga1 c= A\/xy by GLIB_000:def 39;
      x in xy & y in xy by TARSKI:def 2; then
      x in A\/xy & y in A\/xy by XBOOLE_0:def 2; then
      reconsider xa = x, ya = y as Vertex of Ga1 by A20,GLIB_000:def 39;
      consider xag being Vertex of G such that
  A22: xag in A and
  A23: xg,xag are_adjacent by A1, A2, A3, A17, Th82;
      not x in A by A17, A12, XBOOLE_0:def 4;     then
      x in G.AdjacentSet(the_Vertices_of Ga) by A8, A22, A23; then
  A24: Gax is connected by Th57;
       consider yag being Vertex of G such that
  A25: yag in A and
  A26: yg,yag are_adjacent by A1, A2, A3, A17, Th82;
  A27: yag in Ax by A25, XBOOLE_0:def 2;
       not y in A & not y in {x} by A17, A12,XBOOLE_0:def 4,A15,TARSKI:def 1;
       then not yg in the_Vertices_of Gax by A19, XBOOLE_0:def 2; then
      y in G.AdjacentSet(the_Vertices_of Gax) by A19, A27,A26; then
      Ga1 is connected by A24, Th57; then
      consider Wa being Walk of Ga1 such that
  A28: Wa is_Walk_from xa,ya by GLIB_002:def 1;
  A29: Wa.first() = xa & Wa.last() = ya by A28, GLIB_001:def 23;
      consider Pa being Path of Ga1 such that
  A30: Pa is_Walk_from Wa.first(),Wa.last() and
  A31: Pa is minlength by Th39;

      :: the same about Gb1

      consider Gbx being inducedSubgraph of G,Bx;
  A32: the_Vertices_of Gbx = Bx by GLIB_000:def 39;
      consider Gb1 being inducedSubgraph of G,B\/{x}\/{y};
  A33: B\/{x}\/{y} = B\/({x}\/{y}) by XBOOLE_1:4 .= B\/xy by ENUMSET1:41;then
  A34: the_Vertices_of Gb1 c= B\/xy by GLIB_000:def 39;
      x in xy & y in xy by TARSKI:def 2; then
      x in B\/xy & y in B\/xy by XBOOLE_0:def 2; then
      reconsider xb = x, yb = y as Vertex of Gb1 by A33,GLIB_000:def 39;
      consider xbg being Vertex of G such that
  A35: xbg in B and
  A36: xg,xbg are_adjacent by A1, A2, A3, A17, Th83;
      not x in B by A17, A14, XBOOLE_0:def 4;     then
      x in G.AdjacentSet(the_Vertices_of Gb) by A9, A35, A36; then
  A37: Gbx is connected by Th57;
       consider ybg being Vertex of G such that
  A38: ybg in B and
  A39: yg,ybg are_adjacent by A1, A2, A3, A17, Th83;
  A40: ybg in Bx by A38, XBOOLE_0:def 2;
       not y in B & not y in {x} by A17, A14,XBOOLE_0:def 4,A15,TARSKI:def 1;
       then not yg in the_Vertices_of Gbx by A32, XBOOLE_0:def 2; then
      y in G.AdjacentSet(the_Vertices_of Gbx) by A32, A40,A39; then
      Gb1 is connected by A37, Th57; then
       consider Wb being Walk of Gb1 such that
  A41: Wb is_Walk_from yb,xb by GLIB_002:def 1;
  A42: Wb.first() = ya & Wb.last() = xa by A41, GLIB_001:def 23;
       consider Pb being Path of Gb1 such that
  A43: Pb is_Walk_from Wb.first(),Wb.last() and
  A44: Pb is minlength by Th39;

        reconsider Pag = Pa, Pbg = Pb as Path of G by GLIB_001:176;
  A45: Pag.first() = Pag.1 & Pag.last() = Pag.len Pag;
        Pa.first() = Pa.1 & Pa.last() = Pa.len Pa; then
  A46: Pag.1 = xg & Pag.len Pag = yg by A29, A30, GLIB_001:def 23;
  A47: Pag is open by A46, A45, A15, GLIB_001:def 24; then
  A48: not Pag is Cycle-like by GLIB_001:def 31;
  A49: x in Pag.vertices() & y in Pag.vertices() by A46, A45, GLIB_001:89;
  A50: Pbg.first() = Pbg.1 & Pbg.last() = Pbg.len Pbg;
  A51: Pb.first() = Pb.1 & Pb.last() = Pb.len Pb; then
  A52: Pbg.1 = yg & Pbg.len Pbg = xg by A42, A43, GLIB_001:def 23;
  A53: Pbg is open by A52, A50, A15, GLIB_001:def 24; then
  A54: not Pbg is Cycle-like by GLIB_001:def 31;
  A55: x in Pbg.vertices() & y in Pbg.vertices() by A52,A50,GLIB_001:89;

      set P = Pag.append(Pbg);
  A56: len P +1 = len Pag + len Pbg by A45,A46,A50,A52,GLIB_001:29;
  A57: Pag is non trivial by A15, A45, A46, GLIB_001:128;
  A58: Pag.length() >= 2 by A46,A45,A15,A18,Th46;
  A59: Pbg is non trivial by A15, A50, A52, GLIB_001:128;
  A60: Pbg.length() >= 2 by A52,A50,A15,A18,Th46;
A61: Pag.vertices() /\ Pbg.vertices() = xy  proof
     thus Pag.vertices() /\ Pbg.vertices() c= xy proof
          Pag.vertices() = Pa.vertices() by GLIB_001:99; then
     A62:  Pag.vertices() c= A\/xy by A21,XBOOLE_1:1;
          Pbg.vertices() = Pb.vertices() by GLIB_001:99; then
     A63:  Pbg.vertices() c= B\/xy by A34,XBOOLE_1:1;
          (A\/xy)/\(B\/xy) = A/\B\/xy by XBOOLE_1:24 .= xy by A6;
      hence thesis by A62,A63,XBOOLE_1:27;
     end;
      thus xy c= Pag.vertices() /\ Pbg.vertices() proof
       let a be set; assume a in xy; then a = x or a = y by TARSKI:def 2;
       hence thesis by A49,A55,XBOOLE_0:def 3;
      end;
    end;
A64: Pag.edges() misses Pbg.edges() proof
     assume Pag.edges() /\ Pbg.edges() <> {}; then
         consider e being set such that
    A65:  e in Pag.edges() /\ Pbg.edges() by XBOOLE_0:def 1;
         e in Pag.edges() by A65,XBOOLE_0:def 3; then
    A66: e in Pa.edges() by GLIB_001:111;
         e in Pbg.edges() by A65,XBOOLE_0:def 3; then
    A67: e in Pb.edges() by GLIB_001:111;
         consider a1, a2 being Vertex of Ga1, na being odd Element of NAT
         such that
    A68: na+2 <= len Pag and
    A69: a1 = Pag.na and e = Pag.(na+1) and
    A70: a2 = Pag.(na+2) and
    A71: e Joins a1, a2,Ga1 by A66,GLIB_001:104;
         consider b1, b2 being Vertex of Gb1, nb being odd Element of NAT
          such that
          nb+2 <= len Pbg and b1 = Pbg.nb and e = Pbg.(nb+1) and
          b2 = Pbg.(nb+2) and
    A72: e Joins b1, b2,Gb1 by A67,GLIB_001:104;
    A73: e Joins a1,a2,G  & e Joins b1,b2,G by A71, A72, GLIB_000:75; then
    A74:  a1=b1 & a2=b2 or a1=b2 & a2=b1 by GLIB_000:18;
         the_Vertices_of Ga1 = A\/xy by A20,GLIB_000:def 39; then
    A75:  (a1 in A or a1 in xy) & (a2 in A or a2 in xy) by XBOOLE_0:def 2;
         the_Vertices_of Gb1 = B\/xy by A33,GLIB_000:def 39; then
    A76:  (a1 in B or a1 in xy) & (a2 in B or a2 in xy) by A74,XBOOLE_0:def 2;
      per cases by TARSKI:def 2, A75,A76,A6,XBOOLE_0:def 3;
      suppose A77: a1 = x & a2 = x or a1 = y & a2 = y;
         na < na+2 by XREAL_1:41;
     hence contradiction by A77,A70,A69,A46,A15,A68,GLIB_001:def 28;
      end;
      suppose a1 = x & a2 = y or a1 = y & a2 = x;
       hence contradiction by A18, A73, Def3;
      end;
end;
    P.length() = Pag.length()+Pbg.length()
           by A45,A46,A50,A52,Th28; then
    P.length() >= 2+2 by A58,A60,XREAL_1:9; then P.length() >= 3+1; then
A78: P.length() > 3 by NAT_1:38;
    P is Cycle-like by A64,A57,A59,A47,A53,A61,A45,A46,A50,A52,Th27;
    then P is chordal by A78, Def11; then
    consider m, n being odd Nat such that
A79: m+2 < n and
A80: n <= len P and
A81: P.m <> P.n and
A82: ex e being set st e Joins P.m,P.n,G and
A83: for f being set st f in P.edges() holds not f Joins P.m,P.n,G
       by Def10;
A84: m in NAT & n in NAT by ORDINAL1:def 13;
A85: m < n by A79, NAT_1:37;
    consider e being set such that
A86: e Joins P.m,P.n,G by A82;
A87: e Joins P.n,P.m,G by A86,GLIB_000:17;

A88: 1 <= m by HEYTING3:1;
A89: 1 <= n by HEYTING3:1;
    per cases;
    suppose A90: m < len Pag & n <= len Pag; :: chord in minimal path Pa
        m in dom Pag & n in dom Pag by A90, A88, A89, FINSEQ_3:27; then
        P.m = Pag.m & P.n = Pag.n by GLIB_001:33;
        then Pag is chordal by A79, A82, A90, A48, Th85;
        then Pa is chordal by A20,Th87;
      hence contradiction by A31, Th89;
    end;
    suppose A91: m < len Pag & len Pag < n;
        m in dom Pag by A88, A91, FINSEQ_3:27; then
    A92: P.m = Pag.m by GLIB_001:33;
        n in dom P & not n in dom Pag by A91, A89, A80, FINSEQ_3:27; then
        consider n1 being Element of NAT such that
    A93: n1 < len Pbg and
    A94: n = len Pag + n1 by GLIB_001:35;
    A95: P.(len Pag +n1) = Pbg.(n1+1) by A45,A46,A50,A52,A93,GLIB_001:34;
    A96:  Pag.m in the_Vertices_of Ga1 by A91, A84,GLIB_001:8;
        n1 - 0 = n - len Pag by A94; then
        reconsider n1 as even Element of NAT;
        reconsider n11 = n1+1 as odd Element of NAT;
    A97: n11 <= len Pbg by A93, NAT_1:38; then
    A98:  Pbg.n11 in the_Vertices_of Gb1 by GLIB_001:8;
      per cases by A96, A21, A98, A34, XBOOLE_0:def 2;
      suppose A99: Pag.m in A & Pbg.n11 in xy; :: chord in minimal path Pa
        per cases by A99, A46, TARSKI:def 2;
        suppose A100: Pbg.n11 = Pag.1;
            now assume A101: 1+2 >= m;
             per cases by A101, REAL_1:def 5;
             suppose 1+2 > m; then 1 >= m by JORDAN12:3,Th4;
              hence contradiction by A100,A92,A94,A95,A81,A88,XREAL_1:1;
             end;
             suppose A102: 1+2 = m;
                 1 < len Pag by A88, A91, XREAL_1:2; then
                 Pag.(1+1) Joins Pag.1,Pag.m,G
                     by JORDAN12:3,A102,GLIB_001:def 3; then
             A103: Pag.(1+1) Joins Pag.m,Pag.1,G by GLIB_000:17;
             A104: 1+1 < len Pag by A91, A102, XREAL_1:2; then
                 1+1 in dom Pag by FINSEQ_3:27; then
             A105: Pag.(1+1) = P.(1+1) by GLIB_001:33;
             A106: 0 <= len Pbg by NAT_1:18;
                 1 < len Pag -1 by A104, XREAL_1:22; then
                 1+0 < (len Pag -1) + len Pbg by A106, XREAL_1:10; then
                 P.(1+1) in P.edges() by JORDAN12:3,A56,GLIB_001:101;
               hence contradiction by A105, A103, A100, A92, A94, A95, A83;
             end;
            end; then
          Pag is chordal by JORDAN12:3,A87,A91,A100,A48,A92,A94,A95,Th85;
          then Pa is chordal by A20,Th87;
         hence contradiction by A31, Th89;
        end;
        suppose A107: Pbg.n11 = Pag.len Pag;
          now assume A108: m+2 >= len Pag; set L = len Pag;
           per cases by A108, REAL_1:def 5;
           suppose A109: m+2 = L; then
           A110: L = m+1+1; then
           A111: m +1 < L by NAT_1:38; then m < L by NAT_1:38; then
           A112: Pag.(m+1) Joins Pag.m,Pag.L,G by A109,A84,GLIB_001:def 3;
               1<=m+1 by NAT_1:37; then m+1 in dom Pag by A111
,FINSEQ_3:27; then
           A113: Pag.(m+1) = P.(m+1) by GLIB_001:33;
           A114: 0 <= len Pbg by NAT_1:18;
               m < len Pag -1 by A110, NAT_1:38; then
               m+0 < (len Pag -1) + len Pbg by A114, XREAL_1:10; then
               P.(m+1) in P.edges() by A56,A84,GLIB_001:101;
             hence contradiction by A113, A112, A107, A92, A94, A95, A83;
           end;
           suppose m+2 > len Pag;
             hence contradiction by A91, Th4;
           end;
          end;
          then Pag is chordal by A82, A107, A48, A92, A94, A95, Th85;
          then Pa is chordal by A20,Th87;
        hence contradiction by A31, Th89;
       end;
      end;
      suppose A115: Pag.m in A & Pbg.n11 in B;  :: construct a walk
         reconsider ac = Pa.m as Vertex of Ga by A115, GLIB_000:def 39;
         a in A by GLIB_002:9; then
         reconsider aa = a as Vertex of Ga by GLIB_000:def 39;
         reconsider bc = Pb.n11 as Vertex of Gb by A115, GLIB_000:def 39;
         b in B by GLIB_002:9; then
         reconsider bb = b as Vertex of Gb by GLIB_000:def 39;
         consider WA being Walk of Ga such that
      A116: WA is_Walk_from aa, ac by GLIB_002:def 1;
         consider WB being Walk of Gb such that
      A117: WB is_Walk_from bc, bb by GLIB_002:def 1;
         reconsider WA, WB as Walk of Gns by GLIB_001:168;
         set WAB = Gns.walkOf(ac,e,bc);
          e Joins ac,bc,Gns by A12, A14,A115,A86,A92, A94, A95, Th19; then
      A118: WAB is_Walk_from ac,bc by GLIB_001:16;
          reconsider WAs = WA, WBs = WB as Walk of Gns;
          set WaB = WAs.append(WAB);
          set Wab = WaB.append(WBs);
          WAs is_Walk_from aa, ac by A116, GLIB_001:20; then
      A119: WaB is_Walk_from aa, bc by A118, GLIB_001:32;
          WBs is_Walk_from bc, bb by A117, GLIB_001:20; then
          Wab is_Walk_from a,b by A119, GLIB_001:32;
        hence contradiction by A1, A2,Def8;
      end;
      suppose A120: Pag.m in xy & Pbg.n11 in B; :: chord in minimal path Pb
          Pag.m = x or Pag.m = y by A120, TARSKI:def 2; then
      A121: Pag.m = x by A91, A46, A84,GLIB_001:def 28
               .= Pbg.len Pbg by A51,A42, A43, GLIB_001:def 23;
       now assume A122: n11+2 >= len Pbg;         set L = len Pbg;
        per cases by A122, REAL_1:def 5;
         suppose A123: n11+2 = L; then
         A124: L = :: n11+(1+1) .=
                 n11+1+1; then
             n11 +1 < L by NAT_1:38; then
         A125: n11 < L by NAT_1:38; then
             Pbg.(n11+1) Joins Pbg.n11,Pbg.L,Gb1 by A123,GLIB_001:def 3;then
             Pbg.(n11+1) Joins Pbg.L,Pbg.n11,Gb1 by GLIB_000:17; then
         A126: Pbg.(n11+1) Joins Pbg.L,Pbg.n11,G by GLIB_000:75;
         A127: Pbg.(n11+1) = P.(len Pag + n11)
                      by A45,A46,A50,A52,A125,GLIB_001:34;
             1 <= n11 by HEYTING3:1; then
         A128: 1 <= len Pag +n11 by NAT_1:37;
             n11 < len Pbg -1 by A124, NAT_1:38; then
             len Pag +n11 < (len Pbg -1) + len Pag by XREAL_1:8; then
             Pbg.(n11+1) in P.edges() by A127,A128,A56,GLIB_001:100;
          hence contradiction by A126, A92, A121, A94, A95, A83;
         end;
         suppose n11+2 > len Pbg; then n11 >= len Pbg by Th4;
           hence contradiction by A121, A92, A94, A95, A81, A97, XREAL_1:1;
         end;
       end;
       then Pbg is chordal by A87, A54, A121, A92, A94, A95, Th85;
       then Pb is chordal by A33,Th87;
      hence contradiction by A44, Th89;
      end;
      suppose Pag.m in xy & Pbg.n11 in xy; then
        (Pag.m = x or Pag.m = y)&(Pbg.n11 = x or Pbg.n11 = y) by TARSKI:def 2;
        then xg,yg are_adjacent by A82,A92,A95,A94,A81,Def3;
       hence contradiction by A4, A16, Th45;
      end;
    end;
    suppose A129: len Pag <= m;             :: chord in minimal path Pb
        consider m1 being Nat such that
    A130: m = len Pag + m1 by A129,NAT_1:28;
    A131: m1 in NAT by ORDINAL1:def 13;
        n > len Pag by A129, A85, XREAL_1:2; then
        n in dom P & not n in dom Pag by A89, A80, FINSEQ_3:27; then
        consider n1 being Element of NAT such that
    A132: n1 < len Pbg and
    A133: n = len Pag + n1 by GLIB_001:35;
    A134: P.(len Pag +n1) = Pbg.(n1+1) by A132,A45,A46,A50,A52,GLIB_001:34;
    A135: m1 < n1 by A85, A130, A133, XREAL_1:8; then
         m1 < len Pbg by A132, XREAL_1:2; then
    A136: P.(len Pag +m1) = Pbg.(m1+1) by A131,A45,A46,A50,A52,GLIB_001:34;
        n1 - 0 = n - len Pag & m1 -0 = m - len Pag by A130, A133; then
        reconsider n1, m1 as even Element of NAT by ORDINAL1:def 13;
        reconsider m11 = m1+1, n11 = n1+1 as odd Element of NAT;
    A137: n11 <= len Pbg by A132, NAT_1:38;
         m11 < n11 by A135, XREAL_1:8; then
    A138: m11 < len Pbg by A137, XREAL_1:2;
    A139: now assume A140: m11+2 >= n11;
         per cases by A140, REAL_1:def 5;
         suppose A141: m11+2 = n11; then
         A142: Pbg.(m11+1) Joins Pbg.m11,Pbg.n11,G by A138,GLIB_001:def 3;
         A143: Pbg.(m11+1) = P.(len Pag +m11)
               by A138,A45,A46,A50,A52,GLIB_001:34;
             1 <= m11 by HEYTING3:1; then
         A144: 1 <= len Pag +m11 by NAT_1:37;
             m11 +1 < len Pbg by A132, A141; then
             m11 < len Pbg -1 by XREAL_1:22; then
             len Pag +m11 < (len Pbg -1) + len Pag by XREAL_1:8; then
             Pbg.(m11+1) in P.edges() by A56,A143, A144,GLIB_001:100;
          hence contradiction by A142, A130, A136, A133, A134, A83;
         end;
         suppose m11+2 > n11; then m11 >= n11 by Th4;
           hence contradiction by A135, XREAL_1:8;
         end;
        end;
    A145: n11 <= len Pbg by A132, NAT_1:38;
        Pbg is chordal by A139, A145, A133, A134, A130, A136, A82, A54, Th85
; then
        Pb is chordal by A33,Th87;
      hence contradiction by A44, Th89;
    end;
end;

:: Golumbic, page 83, Theorem 4.1 (iii)->(i)
theorem ::: DiracThm2: :: :: DiracThm2
for G being finite _Graph
 st for a,b being Vertex of G st a<>b & not a,b are_adjacent
    for S being VertexSeparator of a,b st S is minimal & S is non empty
    for G2 being inducedSubgraph of G,S holds G2 is complete
  holds G is chordal
proof  let G be finite _Graph such that
A1: for a,b being Vertex of G st a<>b & not a,b are_adjacent holds
     for S being VertexSeparator of a,b st S is minimal & S is non empty
      for G2 being inducedSubgraph of G,S holds G2 is complete;
  let P be Walk of G such that A2: P.length() > 3 & P is Cycle-like;
A3: P is Path-like by A2, GLIB_001:def 31;
   P.length() >= 3+1 by A2,NAT_1:38;
   then 2*P.length() >= 2*4 by XREAL_1:66;
   then 2*P.length() + 1 >= 8 + 1 by XREAL_1:9; then
A4: len P >= 9 by GLIB_001:113;
    reconsider m = 2*0+1 as odd Nat;  :: so clusters come into effect
    reconsider n = 2*2+1 as odd Nat;
A5: now assume A6: P.m = P.n;
      m < n & n <= len P by A4,XREAL_1:2; then
      m=1 & n=len P by A3, A6,GLIB_001:def 28;
     hence contradiction by A4;
    end;
   per cases;
   suppose A7: ex e being set st e Joins P.m,P.n,G;
   A8: m+2 < n & n <= len P by A4,XREAL_1:2;
   A9: not (m=1 & n = len P) by A4;
       len P+(-2) >= 9+(-2) by A4,XREAL_1:9;
       then not (m=1 & n = len P-2);
     hence P is chordal by A3, A7,A8,A9,Th85; end;
   suppose A10: not ex e being set st e Joins P.m,P.n,G;
            m <= len P by A4,XREAL_1:2; then
            reconsider Pm=P.m as Vertex of G by GLIB_001:8;
            n <= len P by A4,XREAL_1:2; then
            reconsider Pn=P.n as Vertex of G by GLIB_001:8;
        A11: not Pm,Pn are_adjacent by A10,Def3;
            consider S being VertexSeparator of Pm,Pn such that
        A12: S is minimal by Th79;

            set P15=P.cut(m,n);  set P5l=P.cut(n,len P);
        A13: m <= n & n <= len P by A4,XREAL_1:2; then
        A14: P15 is_Walk_from P.m,P.n by GLIB_001:38; then
        A15: S is non empty by A5,A11,Th73;
            consider G2 being inducedSubgraph of G,S;
       A16: G2 is complete by A1,A5,A11,A12,A15;

        A17: len P15 + 1 + (-1) = 5 + 1 + (-1) by A13,GLIB_001:37;
            consider k being odd Nat such that
        A18: m < k & k < n and  A19: P15.k in S by A5,A11,A14,A17,Th72;
        A20: 1+2 <= k & k <= 5-2 by A18,Th3,Th4; then
        A21: k = 3 by XREAL_1:1;
            P15.(2+1) = P.(1+2) by A13, A17, GLIB_001:37; then
        A22: P.3 in S by A19,A20,XREAL_1:1;

       A23: P is closed by A2,GLIB_001:def 31;
       A24: n <= len P & len P <= len P by A4,XREAL_1:2; then
            P5l is_Walk_from P.n,P.(len P) by GLIB_001:38; then
       A25: P5l is_Walk_from P.n,P.m by A23,GLIB_001:119;
            S is VertexSeparator of Pn,Pm by A5,A11,Th70; then
            consider l being odd Nat such that
       A26: 1 < l & l < len P5l and A27: P5l.l in S by A5,A11,A25,Th72;
       A28:  1+(-1) < l+(-1) by A26,XREAL_1:10;
            reconsider l2=l-1 as even Element of NAT by A28,INT_1:16;
            reconsider l2 as even Nat;

            l+(-1) < l+0 & l < len P5l by XREAL_1:10,A26; then
            l-1 < len P5l by XREAL_1:2; then
       A29: P5l.(l2+1) = P.(n+l2) by A24,GLIB_001:37;
            reconsider aa=P.3 as Vertex of G2 by A22,GLIB_000:def 39;
            reconsider bb=P.(n+l2) as Vertex of G2
                       by A29,A27,GLIB_000:def 39;
      A30: len P5l + 5 + (-5) = len P + 1 + (-5) by A24,GLIB_001:37;
            l+(-1) < len P5l + (-1) by A26,XREAL_1:10; then
      A31: l2+n < len P-5+n by A30,XREAL_1:10;
       A32: k+2+0 < k+2+l2 by A28,XREAL_1:10;
        A33: n+l2 in NAT by ORDINAL1:def 13;
            now assume A34: aa = bb;
                k < n+l2 & n+l2 <= len P by A32, A21, A31, XREAL_1:2;
              hence contradiction
             by A33,A21, A3,A34,GLIB_001:def 28;
            end; then aa,bb are_adjacent by A16,Def6; then
            consider e being set such that
       A35: e Joins P.3,P.(n+l2),G2 by Def3;
            e Joins P.k,P.(n+l2),G by A21,A35,GLIB_000:75;
            hence P is chordal by A21,A32,A31, A3,Th85; end;
end;

:: Exercise 12, p. 101.
:: This needs "finite-branching", we do it for finite though
theorem Th100: :: tExercise12
for G being finite chordal _Graph, a, b being Vertex of G
 st a <> b & not a,b are_adjacent
for S being VertexSeparator of a,b st S is minimal
for H being removeVertices of G,S, a1 being Vertex of H st a = a1
 ex c being Vertex of G st c in H.reachableFrom(a1) &
   for x being Vertex of G st x in S holds c,x are_adjacent
proof let G be finite chordal _Graph, a, b be Vertex of G such that
A1: a <> b and
A2: not a,b are_adjacent;
   let S be VertexSeparator of a,b such that
A3: S is minimal;
   let H be removeVertices of G,S, a1 be Vertex of H such that
A4: a = a1;
   assume
A5: for c being Vertex of G holds not c in H.reachableFrom(a1) or
         ex x being Vertex of G st x in S & not c,x are_adjacent;
   per cases;
   suppose S is empty;
     then not ex x being Vertex of G st x in S & not a,x are_adjacent;
     then not a in H.reachableFrom(a1) by A5;
    hence contradiction by A4,GLIB_002:9;
   end;
   suppose A6: S is non empty;
    reconsider S as non empty Subset of the_Vertices_of G by A6;
    set A = H.reachableFrom(a1);
    deffunc F(set) = card (G.AdjacentSet({$1}) /\ S);
    set M = { F(x) where x is Vertex of G : x in A };
    a in A by A4,GLIB_002:9; then
A7: card (G.AdjacentSet({a}) /\ S) in M;
A8: A is finite;
A9: M is finite from FRAENKEL:sch 21(A8);
   now let x be set such that A10: x in M;
       consider y being Vertex of G such that
   A11: x = card (G.AdjacentSet({y}) /\ S) and y in A by A10;
       thus x is natural by A11;
   end; then
 reconsider M as finite non empty natural-membered set by A7,A9,MEMBERED:def 5;

    max M in M by PRE_CIRC:def 1; then
    consider c being Vertex of G such that
 A12: max M = card (G.AdjacentSet({c}) /\ S) and
 A13: c in A;
   consider y being Vertex of G such that
A14: y in S and
A15: not c,y are_adjacent by A5,A13;

A16: A/\S = {} by A1,A2,A4,Th75;
    consider Ga being inducedSubgraph of H,A;
A17: the_Vertices_of Ga = A by GLIB_000:def 39;
    set tVG = the_Vertices_of G;
    the_Vertices_of H c= tVG; then
    reconsider A as non empty Subset of tVG by XBOOLE_1:1;
    not a in S by A1,A2,Def8; then
A18: tVG\S is non empty Subset of tVG by XBOOLE_0:def 4;
    now let x be set such that A19: x in A;
      not x in S by A16,A19,XBOOLE_0:def 3;
     hence x in tVG \ S by A19,XBOOLE_0:def 4;
    end; then
A20: A c= tVG \ S by TARSKI:def 3;
    reconsider Ga as inducedSubgraph of G,A by A18,A20,Th29;
    set Ay = A\/{y};
      consider Gay being inducedSubgraph of G,Ay;
A21: the_Vertices_of Gay = Ay by GLIB_000:def 39;
      y in {y} by TARSKI:def 1; then
      c in Ay & y in Ay by A13, XBOOLE_0:def 2; then
      reconsider ca = c, ya = y as Vertex of Gay by GLIB_000:def 39;
      consider yaa being Vertex of G such that
A22: yaa in A and
A23: y,yaa are_adjacent by A1, A2, A3, A4, A14, Th82;
     not y in A by A16, A14, XBOOLE_0:def 3;     then
     y in G.AdjacentSet(the_Vertices_of Ga) by A17, A22, A23; then
      Gay is connected by Th57; then
     consider Wa being Walk of Gay such that
 A24: Wa is_Walk_from ca,ya by GLIB_002:def 1;
A25: Wa.first() = ca & Wa.last() = ya by A24, GLIB_001:def 23;
      consider P being Path of Gay such that
 A26: P is_Walk_from Wa.first(),Wa.last() and
 A27: P is minlength by Th39;
A28:P.first() = ca by A26,A25,GLIB_001:def 23;
A29:P.last() = y by A26,GLIB_001:def 23,A25;
    c <> y by A13, A16, A14, XBOOLE_0:def 3; then
    P is non trivial by A29,A28,GLIB_001:128; then
A30: len P >= 3 by GLIB_001:126;
A31: now assume len P < 2*2+1; then
        len P <= 5-2 by Th3; then
    A32: len P = 3 by A30,XREAL_1:1; then
        2*0+1 < len P; then
        P.(1+1) Joins P.1,P.(1+2),Gay by GLIB_001:def 3; then
        P.2 Joins c,y,G by A28,A29,A32,GLIB_000:75;
        hence contradiction by A15, Def3;
    end;
    5 + -2 <= len P + -2 by A31, XREAL_1:9; then
    0 <= len P - 2 by XREAL_1:2; then
    reconsider j = len P - 2*1 as odd Element of NAT by INT_1:16;
    set d = P.j;
A33: j < len P by XREAL_1:46; then
A34: P.j in the_Vertices_of Gay by GLIB_001:8; then
A35: d in A or d in {y} by A21,XBOOLE_0:def 2;
A36: now assume d = y; then
        len P - 2 = 1 by A29,A33,GLIB_001:def 28; then
        len P = 1 + 2 & 3 < 5;
        hence contradiction by A31;
    end;
    reconsider d as Vertex of G by A34;

    P.(j+1) Joins d,P.(len P-2+2),Gay by A33,GLIB_001:def 3; then
A37: P.(j+1) Joins d,y,G by A29,GLIB_000:75; then
    d <> y & d,y are_adjacent by A36,Def3; then
A38: y in G.AdjacentSet({d}) by Th52; then
A39: y in G.AdjacentSet({d}) /\ S by A14,XBOOLE_0:def 3;
A40: not y in G.AdjacentSet({c}) by A15, Th52;

    set gds = G.AdjacentSet({d}) /\ S;
    set gcs = G.AdjacentSet({c}) /\ S;
    now assume A41: gcs c= gds;
        not y in gcs by A40,XBOOLE_0:def 3; then
        gcs c< gds by A41,A39,XBOOLE_0:def 8; then
    A42: card gcs < card gds by TREES_1:24;
        card gds in M by A36,A35,TARSKI:def 1;
        hence contradiction by A42,A12,PRE_CIRC:def 1;
    end; then
    consider x being set such that
A43: x in G.AdjacentSet({c}) /\ S and
A44: not x in G.AdjacentSet({d}) /\ S by TARSKI:def 3;
A45: x in S by A43, XBOOLE_0:def 3; then
A46: not x in G.AdjacentSet({d}) by A44, XBOOLE_0:def 3;
    reconsider x as Vertex of G by A43;
A47: x <> y by A44,A38, A14,XBOOLE_0:def 3;
    consider Gs being inducedSubgraph of G,S;
    reconsider xs=x, ys=y as Vertex of Gs by A14,A45, GLIB_000:def 39;
    Gs is complete by A1,A2,A3,Th98; then
    xs,ys are_adjacent by A47,Def6; then
    consider ej being set such that
A48: ej Joins xs,ys,Gs by Def3;
    ej Joins x,y,G by A48,GLIB_000:75; then
A49: x,y are_adjacent by Def3;
    x in G.AdjacentSet({c}) by A43, XBOOLE_0:def 3; then
A50: c,x are_adjacent by Th52;
    d <> x by A36,A35,TARSKI:def 1, A16, A45, XBOOLE_0:def 3; then
A51: not d,x are_adjacent by A46, Th52;

   defpred Pmax[Nat] means
   $1 in dom P & $1 is odd & $1 < len P & ex e being set st e Joins x,P.($1),G;
   deffunc N() = len P;
A52: for k being Element of NAT st Pmax[k] holds k <= N();
A53: 1 < len P by A31,XREAL_1:2; then
A54: 1 in dom P by FINSEQ_3:27;
A55: 2*0+1 is odd;
    ex e being set st e Joins x,P.1,G by A50,Def3,A28; then
A56: ex k being Element of NAT st Pmax[k] by A53,A54,A55;
    consider k being Element of NAT such that
A57: Pmax[k] and
A58: for i being Element of NAT st Pmax[i] holds k >= i
         from NAT_1:sch 6(A52,A56);
    reconsider k as odd Element of NAT by A57;
A59: k <= j & j < len P by A57,Th3,XREAL_1:46;
A60: P.k <> P.j by A51,Def3,A57;
A61: now assume A62: P.k = P.(len P);
    A63: 2*0+1 <= k & k <= len P
             by A57,HEYTING3:1; then
    A64: P.cut(1,k) is_Walk_from P.first(),P.last() by A62,GLIB_001:38;
        len P.cut(1,k) + 1 = k + 1 by A63,GLIB_001:37;
        hence contradiction
          by A27,A64,A57,Def2;
    end;
    :::::::::: properties of Q ::::::::::
    set Q1 = P.cut(k,j);
A65: Q1 is minlength by A59,A27,Th42;
A66: Q1.first() = P.k & Q1.last() = P.j by A59,GLIB_001:38;
    reconsider Q=Q1 as Path of G by GLIB_001:176;
A67: Q.vertices() = Q1.vertices() by GLIB_001:99;
A68: Q.first() = P.k by A66;
A69: Q.last() = P.j by A66;
A70: Q.first() <> Q.last() by A66,A51,Def3,A57;
A71: Q is non trivial by A68,A69,A60,GLIB_001:128; then
    Q.length() <> 0 & Q.length() >= 0 by NAT_1:18,GLIB_001:def 26; then
    Q.length() > 0 by REAL_1:def 5; then
A72: Q.length() >= 0+1 by NAT_1:38;
A73: Q is open by GLIB_001:def 24,A70;
A74: len Q + k = j + 1 by A59,GLIB_001:37;
    set cc = Q.first(), dd = Q.last();

A75: not x in A & not x in {y} by A45,A16,XBOOLE_0:def 3, A47,TARSKI:def 1;
    dd in Q1.vertices() by GLIB_001:89,A67; then
A76: dd <> x by A75, XBOOLE_0:def 2, A21;
    cc in Q1.vertices() by GLIB_001:89,A67; then
A77: cc <> x by A75, XBOOLE_0:def 2, A21;
A78: dd,y are_adjacent by A37,A66,Def3;
A79: x,cc are_adjacent by A57,A66,Def3;

A80: now let i be odd Nat such that
    A81: i in dom Q & i <> len Q;
        assume ex e being set st e Joins Q.i,y,G; then
        consider e being set such that
    A82: e Joins Q.i,y,G;
    A83: i <= len Q by A81,FINSEQ_3:27;
        1 <= i by A81,FINSEQ_3:27; then
        1+-1 <= i+-1 by XREAL_1:9; then
        reconsider i1 = i-1 as even Element of NAT by INT_1:16;
        reconsider ki1= k+i1 as odd Element of NAT;
    A84: i+-1 < i+-0 by XREAL_1:10; then
    i1 < len Q by A83,XREAL_1:2; then
    A85: Q.(i1+1) = P.(ki1) & ki1 in dom P by A59,GLIB_001:37;
    A86: ki1 <= len P by A85,FINSEQ_3:27;
        now assume A87: ki1 = len P;
            len P - k + -1 < len P - k by XREAL_1:32;
            hence contradiction by A84,A83,XREAL_1:2,A74,A87;
        end; then
        ki1 < len P by A86,REAL_1:def 5; then
    A88: ki1+2 <= len P by Th4;
        ki1+2 <> len P by A81, A74;  then
    A89: ki1+2 < len P by A88,REAL_1:def 5;
        P.(ki1) in Ay & P.(len P) in Ay
              by A21,A86,GLIB_001:8; then
        e Joins P.(ki1), P.(len P),Gay by A29,A82,A85,Th19;
        hence contradiction by A89,A27,Th40;
    end;

A90: now let i be odd Nat such that
    A91: i in dom Q & i <> 1;
        assume ex e being set st e Joins Q.i,x,G; then
        consider e being set such that
    A92: e Joins Q.i,x,G;
    A93: 1 <= i & i <= len Q by A91,FINSEQ_3:27; then
        1+-1 <= i+-1 by XREAL_1:9; then
        reconsider i1 = i-1 as even Element of NAT by INT_1:16;
        reconsider ki1= k+i1 as odd Element of NAT;
        i+-1 < i+-0 by XREAL_1:10; then
    A94: i1 < len Q by A93,XREAL_1:2; then
    A95: Q.(i1+1) = P.(ki1) & ki1 in dom P by A59,GLIB_001:37;
    A96: i1+k < len P - 1 - k + k by XREAL_1:10,A94,A74;
        len P+-1 < len P+-0 by XREAL_1:10; then
        1 <= ki1 & ki1 < len P by HEYTING3:1,A96,XREAL_1:2;then
    A97: ki1 in dom P & ki1 < len P by FINSEQ_3:27;
    A98: e Joins x,P.(ki1),G by GLIB_000:17,A92,A95;
        now assume i1 <> 0; then
            i1 <> 0 & i1 >= 0 by NAT_1:18; then
            i1 > 0 by REAL_1:def 5; then
            k+0 < k + i1 by XREAL_1:10;
            hence contradiction by A98,A58,A97;
        end;
        hence contradiction by A91;
    end;

A99: now let v be set such that A100: v in Q.vertices();
        Q.vertices() c= P.vertices() by A59,A67,GLIB_001:95; then
    A101: v in P.vertices() by A100;
        consider n being odd Element of NAT such that
    A102: n <= len Q & Q.n = v by A100,GLIB_001:88;
        1 <= n by HEYTING3:1; then
        1+-1 <= n+-1 by XREAL_1:9; then
        reconsider n1 = n-1 as even Element of NAT by INT_1:16;
        reconsider kn1 = k+n1 as odd Element of NAT;
        n+-1 < n+-0 by XREAL_1:10; then
    A103: n1 < len Q by A102,XREAL_1:2; then
    A104: Q.(n1+1) = P.(kn1) & kn1 in dom P by A59,GLIB_001:37;
    A105: k+n1 < len P - 1 - k + k by A74,A103,XREAL_1:10;
        len P+-1 < len P+-0 by XREAL_1:10; then
    A106: kn1 < len P by A105,XREAL_1:2;
        now assume A107: v = y;
        A108: k+(n+-1) = 1 by A107,A104,A102,A29,A106,GLIB_001:def 28;
        A109: 1 <= k & 1 <= n by HEYTING3:1;
            now assume 1 < n; then
                1+1 <= n by NAT_1:38; then
                2+1 <= k+n by A109,XREAL_1:9;
                hence contradiction by A108;
            end;
            hence contradiction by A109,REAL_1:def 5,A107,A102,A66,A61,A29;
        end; then not v in {y} by TARSKI:def 1;
        hence v in A by A101,A21,XBOOLE_0:def 2;
    end;

    :::    R: building path dd - y - x - cc ::::::::::::::
    consider R being Path of G such that
A110: len R = 7 & R.length() = 3 and
A111: R.vertices() = {dd,y,x,cc} and
A112: R.1 = dd & R.3 = y & R.5 = x & R.7 = cc
        by A47,A36,A76,A66,A61,A29,A77,A78,A49,A79,Th48;
A113: R.first() = dd by A112;
A114: R.last() = cc by A112,A110;
A115: R is non trivial by A110,GLIB_001:127;
A116: R is open by A70,A113,A114,GLIB_001:def 24;

A117: Q.edges() misses R.edges() proof
        assume not Q.edges() misses R.edges(); then
        Q.edges() /\ R.edges() <> {} by XBOOLE_0:def 7; then
        consider e being set such that
    A118: e in Q.edges() /\ R.edges() by XBOOLE_0:def 1;
    A119: e in Q.edges() by A118,XBOOLE_0:def 3;
        e in R.edges() by A118,XBOOLE_0:def 3; then
        consider n being even Element of NAT such that
    A120: 1 <= n & n <= 7 & R.n = e by A110,GLIB_001:100;
    A121: n = 0 or n = 2 or n = 4 or n = 6 by A120,Th13;
        per cases by A121,A120;
        suppose A122: n = 2; 2*0+1 < len R by A110; then
            R.(1+1) Joins R.1,R.(1+2),G by GLIB_001:def 3; then
            y in Q.vertices() by A120,A122,A119,A112,GLIB_001:106; then
            y in A by A99;
            hence contradiction by A16,A14,XBOOLE_0:def 3; end;
        suppose A123: n = 4; 2*1+1 < len R by A110; then
            R.(3+1) Joins R.3,R.(3+2),G by GLIB_001:def 3; then
            y in Q.vertices() by A120,A123,A119,A112,GLIB_001:106; then
            y in A by A99;
            hence contradiction by A16,A14,XBOOLE_0:def 3; end;
        suppose A124: n = 6; 2*2+1 < len R by A110; then
            R.(5+1) Joins R.5,R.(5+2),G by GLIB_001:def 3; then
            x in Q.vertices() by A120,A124,A119,A112,GLIB_001:106; then
            x in A by A99;
            hence contradiction by A16,A45,XBOOLE_0:def 3; end;
    end;
    now let v be set such that A125: v in Q.vertices() /\ R.vertices();
        v in Q.vertices() by A125,XBOOLE_0:def 3; then
    A126: v in A by A99;
        v in {dd,y,x,cc} by A111,A125,XBOOLE_0:def 3; then
        v = dd or v = y or v = x or v = cc by ENUMSET1:def 2;
      hence v in {Q.first(), Q.last()}
         by A14,TARSKI:def 2,A45,A16,A126,XBOOLE_0:def 3;
    end; then
A127:Q.vertices() /\ R.vertices() c= {Q.first(), Q.last()} by TARSKI:def 3;
    now let v be set such that A128: v in {Q.first(), Q.last()};
        per cases by A128,TARSKI:def 2;
        suppose A129: v = cc; then
        A130: v in Q.vertices() by GLIB_001:89;
            v in R.vertices() by A129,A112,A110,GLIB_001:88;
           hence v in Q.vertices() /\ R.vertices() by A130,XBOOLE_0:def 3; end;
        suppose A131: v = dd; then
        A132: v in Q.vertices() by GLIB_001:89; 2*0+1 <= len R by A110; then
            v in R.vertices() by A131,A112,GLIB_001:88;
           hence v in Q.vertices() /\ R.vertices() by A132,XBOOLE_0:def 3; end;
    end; then
    {Q.first(),Q.last()} c= Q.vertices()/\R.vertices() by TARSKI:def 3; then
A133: Q.vertices() /\ R.vertices() = { Q.first(), Q.last() }
        by A127,XBOOLE_0:def 10;

    :::::::::: properties of C ::::::::::::
    set C = Q.append(R);
A134:  C is Cycle-like by A117, A71, A73, A115, A116, A133, A113, A114, Th27;
A135: len C +1+-1 = len Q + len R+-1 by A113,GLIB_001:29;

A136: C.(len Q+6) = R.(6+1) by A110,A113,GLIB_001:34;
A137: C.(len Q+4) = R.(4+1) by A110,A113,GLIB_001:34;
A138: C.(len Q+2) = R.(2+1) by A110,A113,GLIB_001:34;
    C.length() = Q.length() + 3 by A113,A110,Th28; then
    C.length() >= 1 + 3 by A72,XREAL_1:9; then
    C.length() > 3 by NAT_1:38; then
    C is chordal by A134, Def11;
    then consider m, n being odd Nat such that
A139: m+2 < n and
A140: n <= len C and C.m <> C.n and
A141: ex e being set st e Joins C.m,C.n,G  and
A142: C is Cycle-like implies not (m=1 & n = len C) & not (m=1 & n = len C-2) &
                            not (m=3 & n = len C) by Th84;
A143: 1 <= m by HEYTING3:1;
A144: n <= len Q or n = len Q+2 or n = len Q+4 or n = len Q+6 proof
      per cases;
       suppose n <= len Q; hence thesis; end;
       suppose n > len Q; then A145: len Q +2 <= n by Th4;
      per cases by A145,REAL_1:def 5;
       suppose len Q +2 = n; hence thesis; end;
       suppose len Q +2 < n; then A146: len Q +2+2 <= n by Th4;
      per cases by A146, REAL_1:def 5;
       suppose len Q +4 = n; hence thesis; end;
       suppose len Q +2*2 < n; then len Q +4+2 <= n by Th4;
      hence thesis by A135, A110, A140, REAL_1:def 5; end; end; end;
    end;

    ::::::::::::: show C has no chord :::::::::::::
  consider e being set such that A147: e Joins C.m,C.n,G by A141;
  per cases by A144;
  suppose A148: n <= len Q;
      1 <= n by HEYTING3:1; then
  A149: n in dom Q by A148,FINSEQ_3:27;
      m+2 <= len Q & m+0 <= m+2 by A139,A148,XREAL_1:9,XREAL_1:2; then
      m <= len Q by XREAL_1:2; then
  A150: m in dom Q by A143,FINSEQ_3:27;
      Q.m = C.m & Q.n = C.n by A149,A150,GLIB_001:33;
      hence contradiction by A147,A148,A139,A65,Th41; end;
  suppose A151: n = len Q + 2; then
      m < len Q by A139, XREAL_1:8; then
  A152: m in dom Q by A143, FINSEQ_3:27; then
      e Joins Q.m,y,G by A151,A138,A112,A147,GLIB_001:33;
      hence contradiction by A80,A151,A139,A152; end;
  suppose A153: n = len Q + 4; then
      m+2+2 <= len Q+4 by A139,Th4; then m+4 <= len Q +4; then
      m <= len Q by XREAL_1:8; then
  A154: m in dom Q by A143, FINSEQ_3:27; then
  A155: e Joins Q.m,x,G by A153,A137,A112,A147,GLIB_001:33;
      per cases by A143,REAL_1:def 5;
      suppose 1 = m; hence contradiction
        by A117,A71,A73,A115,A116,A133,A113,A114,Th27,A142,A153,A135,A110; end;
      suppose 1 < m; hence contradiction by A155,A90,A154; end; end;
  suppose A156: n = len Q +6; then
      m+2+2 <= len Q+6 by A139,Th4; then m+4 <= len Q +2+4; then
  A157: m <= len Q +2 by XREAL_1:8;
      per cases by A157, REAL_1:def 5;
      suppose m < len Q +2; then
      A158: m <= len Q by Th4; then
          m in dom Q by A143, FINSEQ_3:27; then
      A159: C.m = Q.m by GLIB_001:33;
      A160: e Joins Q.1,Q.m,G by A156, A159, A147, A136, A112,GLIB_000:17;
          now assume 1+2 >= m; then
              m< 2*1+1 by A117,A71,A73,A115,A116,A133,A113,A114,Th27,
                          A142,A156,A135,A110,REAL_1:def 5;then
              m <= 3-2 by Th3; then
              m < 1 by A117,A71,A73,A115,A116,A133,A113,A114,Th27,
                       A142,A156,A135,A110,REAL_1:def 5;
             hence contradiction by HEYTING3:1;
          end; then 2*0+1+2 < m;
          hence contradiction by A160, A158,A65,Th41; end;
      suppose A161: m = len Q + 2;
      A162: e Joins Q.1,y,G by A156,A136,A147,A161,A138,A112,GLIB_000:17;
          3 <= len Q & 1 <= 3 by A71,GLIB_001:126; then
          1 <= len Q by XREAL_1:2; then
          2*0+1 in dom Q & 1 <> len Q by A66,A51,Def3,A57,FINSEQ_3:27;
          hence contradiction by A80,A162; end; end;
  end;
end;

theorem :: Remark p. 83
for G being finite chordal _Graph, a, b being Vertex of G
 st a <> b & not a,b are_adjacent
for S being VertexSeparator of a,b st S is minimal
for H being removeVertices of G,S, a1 being Vertex of H st a = a1
for x, y being Vertex of G st x in S & y in S holds
 ex c being Vertex of G
  st c in H.reachableFrom(a1) & c,x are_adjacent & c,y are_adjacent
proof
    let G be finite chordal _Graph;
    let a,b be Vertex of G such that
A1: a <> b & not a,b are_adjacent;
    let S be VertexSeparator of a,b such that A2: S is minimal;
    let H be removeVertices of G,S, a1 be Vertex of H such that
A3: a = a1;
    let x,y be Vertex of G such that A4: x in S and A5: y in S;
    consider c being Vertex of G such that
A6: c in H.reachableFrom(a1) and
A7: for x being Vertex of G st x in S holds c,x are_adjacent
        by A1,A2,A3,Th100;
    c,x are_adjacent & c,y are_adjacent by A4,A5,A7;
    hence thesis by A6;
end;

:: Golumbic, page 83, Lemma 4.2.
theorem Th102 : :: DiracLemma2
for G being non trivial finite chordal _Graph
 st not G is complete
  ex a,b being Vertex of G
   st a<>b & not a,b are_adjacent & a is simplicial & b is simplicial
proof let G be non trivial finite chordal _Graph such that
A1: not G is complete;
    defpred P[finite _Graph] means
    $1 is non trivial & $1 is chordal & not $1 is complete
    implies ex a,b being Vertex of $1 st a <> b &
                     not a,b are_adjacent & a is simplicial & b is simplicial;

A2: for k being non zero Nat
     st for Gk being finite _Graph st Gk.order() < k holds P[Gk]
      holds for Gk1 being finite _Graph st Gk1.order() = k holds P[Gk1]
    proof let k be non zero Nat such that
    A3: for Gk being finite _Graph st Gk.order() < k holds P[Gk];
      let Gk1 be finite _Graph such that
    A4: Gk1.order() = k and
    A5:  Gk1 is non trivial and
    A6: Gk1 is chordal and
    A7: not Gk1 is complete;
         reconsider G=Gk1 as non trivial finite chordal _Graph by A5,A6;
         consider a,b being Vertex of G such that
    A8: a <> b and
    A9: not a,b are_adjacent by Def6, A7;
         consider S being VertexSeparator of a,b such that
    A10: S is minimal by Th79;
        consider Gs being inducedSubgraph of G,S;
        consider Gns being removeVertices of G,S;
        reconsider sa = a, sb = b as Vertex of Gns by A8,A9,Th77;
        set A = Gns.reachableFrom(sa), B = Gns.reachableFrom(sb);
        consider Gas being inducedSubgraph of G,(A \/ S);
        consider Gbs being inducedSubgraph of G,(B \/ S);
        A c= the_Vertices_of Gns & B c= the_Vertices_of Gns; then
    A11: A c= the_Vertices_of G & B c= the_Vertices_of G by XBOOLE_1:1; then
    A12: A\/S is non empty Subset of the_Vertices_of G &
        B\/S is non empty Subset of the_Vertices_of G by XBOOLE_1:8;
    A13: A /\ B = {} by A8,A9,Th76;
   A14: now assume
        A15: b in A \/ S;
            not b in S by A8,A9,Def8; then
        A16: b in A by A15, XBOOLE_0:def 2;
            b in B by GLIB_002:9;
         hence contradiction by A13,A16,XBOOLE_0:def 3;
        end;
   A17: now assume
        A18: a in B \/ S;
            not a in S by A8,A9,Def8; then
        A19: a in B by A18, XBOOLE_0:def 2;
            a in A by GLIB_002:9;
         hence contradiction by A13,A19,XBOOLE_0:def 3;
        end;
        not a in S by A8,A9,Def8; then
        a in the_Vertices_of G \ S by XBOOLE_0:def 4; then
   A20: the_Vertices_of Gns = the_Vertices_of G \ S by GLIB_000:def 39;

    A21: Gas.order() <= k by A4,GLIB_000:78;
        now assume A22: Gas.order() = k;
        A23: the_Vertices_of Gas = the_Vertices_of G by A22,A4,TRIANG_1:3;
            the_Vertices_of Gas = A\/S by A12,GLIB_000:def 39;
          hence contradiction by A14,A23;
        end; then
   A24: Gas.order() < k by A21,REAL_1:def 5;

    A25: Gbs.order() <= k by A4,GLIB_000:78;
        now assume A26: Gbs.order() = k;
        A27: the_Vertices_of Gbs = the_Vertices_of G by A26,A4,TRIANG_1:3;
            the_Vertices_of Gbs = B\/S by A12,GLIB_000:def 39;
         hence contradiction by A17,A27;
        end; then
   A28: Gbs.order() < k by A25,REAL_1:def 5;
:: XXXXXXXXXXXXXXXXXXXX for A XXXXXXXXXXXXXXXXXXXXXXX
        ex a being Vertex of Gk1 st a in A & a is simplicial
        proof
            consider aa being set such that
        A29: aa in A by XBOOLE_0:def 1;
        A30: the_Vertices_of Gas = A \/ S by A12,GLIB_000:def 39;then
            reconsider a = aa as Vertex of Gas by A29, XBOOLE_0:def 2;
            ex c being Vertex of Gas st c in A & c is simplicial
            proof
              per cases;
              suppose Gas is complete; then a is simplicial by Th64;
                hence thesis by A29;
              end;
              suppose A31: not Gas is complete;
                  not  Gas is trivial by A31, Th61; then
                  consider a2,b2 being Vertex of Gas such that
              A32: a2 <> b2 and
              A33: not a2,b2 are_adjacent and
              A34: a2 is simplicial & b2 is simplicial by A31,A24,A3;
                  now assume A35: a2 in S & b2 in S;
                      reconsider a3 = a2, b3 = b2 as Vertex of G by A35;
                  A36: not a3,b3 are_adjacent by A33,A12,Th45;
                  A37: Gs is complete by A35, A8, A9,A10,Th98;
                      reconsider a4 = a2, b4 = b2 as Vertex of Gs
                                                  by A35,GLIB_000:def 39;
                      a4,b4 are_adjacent by A37,A32,Def6;
                   hence contradiction by A36, A35, Th45;
                  end;
                  then b2 in A or a2 in A by A30, XBOOLE_0:def 2;
                 hence thesis by A34;
               end;
            end;
            then consider cc being Vertex of Gas such that
            A38: cc in A and
            A39: cc is simplicial;
            reconsider c = cc as Vertex of Gk1 by A11,A38;

            now let x be set such that
            A40: x in Gk1.AdjacentSet({c});
                 assume not x in A\/S; then
             A41: not x in A & not x in S by XBOOLE_0:def 2;
                 reconsider x as Vertex of Gk1 by A40;
             A42: x in the_Vertices_of Gns by A20,A41,XBOOLE_0:def 4;
                 c,x are_adjacent by A40,Th52;
                 then consider e being set such that
             A43: e Joins c,x,Gk1 by Def3;
                 e Joins c,x,Gns by A20,A42,A43,A38,Th19;
               hence contradiction by A41, A38, GLIB_002:10;
             end; then
             A44: Gk1.AdjacentSet({c}) c= A\/S by TARSKI:def 3;
                  c in A\/S by A38,XBOOLE_0:def 2; then
                  c is simplicial by A12,A39,A44,Th67;
                 hence thesis by A38;
        end;
        then consider a being Vertex of Gk1 such that
    A45: a in A & a is simplicial;
:: XXXXXXXXXXXXXX For B: proof by cut-n-paste XXXXXXXXXXXXX
        ex b being Vertex of Gk1 st b in B & b is simplicial
        proof
             consider aa being set such that
           A46: aa in B by XBOOLE_0:def 1;
           A47: the_Vertices_of Gbs = B \/ S by A12,GLIB_000:def 39;then
               reconsider a = aa as Vertex of Gbs by A46, XBOOLE_0:def 2;

               ex c being Vertex of Gbs st c in B & c is simplicial
               proof
                 per cases;
                 suppose Gbs is complete;
                    then a is simplicial by Th64;
                    hence thesis by A46;
                 end;
                 suppose A48: not Gbs is complete;
                        not  Gbs is trivial by A48, Th61; then
                        consider a2,b2 being Vertex of Gbs such that
                    A49: a2 <> b2 and
                    A50: not a2,b2 are_adjacent and
                    A51: a2 is simplicial & b2 is simplicial by A48,A28,A3;
                        now assume A52: a2 in S & b2 in S;
                            reconsider a3 = a2, b3 = b2 as Vertex of G by A52;
                        A53: not a3,b3 are_adjacent by A50,A12,Th45;
                        A54: Gs is complete by A52, A8,A9,A10,Th98;
                            reconsider a4 = a2, b4 = b2 as Vertex of Gs
                                                   by A52,GLIB_000:def 39;
                            a4,b4 are_adjacent by A54,A49,Def6;
                         hence contradiction by A53, A52, Th45;
                        end; then
                        b2 in B or a2 in B by A47, XBOOLE_0:def 2;
                      hence thesis by A51;
                     end;
                   end;
                   then consider cc being Vertex of Gbs such that
               A55: cc in B and
               A56: cc is simplicial;
                   reconsider c = cc as Vertex of Gk1 by A11,A55;

                  now let x be set such that
                   A57: x in Gk1.AdjacentSet({c});
                      assume not x in B\/S; then
                   A58: not x in B & not x in S by XBOOLE_0:def 2;
                       reconsider x as Vertex of Gk1 by A57;
                   A59: x in the_Vertices_of Gns by A20,A58,XBOOLE_0:def 4;
                       c,x are_adjacent by A57,Th52;
                       then consider e being set such that
                   A60: e Joins c,x,Gk1 by Def3;
                       e Joins c,x,Gns by A55,A20,A59,A60,Th19;
                       hence contradiction by A58, A55, GLIB_002:10;
                   end; then
              A61: Gk1.AdjacentSet({c}) c= B\/S by TARSKI:def 3;
                   c in B\/S by A55,XBOOLE_0:def 2; then
                   c is simplicial by A12,A56,A61,Th67;
                   hence thesis by A55;
        end;
        then consider b being Vertex of Gk1 such that
    A62: b in B & b is simplicial;
    A63: now assume a,b are_adjacent; then consider e being set such that
        A64: e Joins a,b,Gk1 by Def3;
            reconsider aa=a, bb=b as Vertex of Gns by A45,A62;
        A65: e Joins aa,bb,Gns by A20,A64,Th19;
            bb in A by A45, A65,GLIB_002:10;
          hence contradiction by A13,A62,XBOOLE_0:def 3;
        end;
        a<>b by A13,A45,A62,XBOOLE_0:def 3;
     hence thesis by A45,A62,A63;
    end;
    for G being finite _Graph holds P[G] from FinGraphOrderCompInd(A2);
  hence thesis by A1;
end;

theorem Th103 : :: DiracLemma1
for G being finite chordal _Graph ex v being Vertex of G st v is simplicial
proof let G be finite chordal _Graph;
    per cases;
    suppose A1: G is complete;
        consider u being Vertex of G;
        u is simplicial by A1,Th64;
     hence thesis;
    end;
    suppose A2: not G is complete; then
    A3: not G is trivial by Th61;
        consider a,b being Vertex of G such that
    A4: a<>b & not a,b are_adjacent &
        a is simplicial & b is simplicial by A2,A3, Th102;
     thus thesis by A4;
    end;
end;

begin :: Vertex Elimination Scheme :: Golumbic, p. 82

definition let G be finite _Graph;
  mode VertexScheme of G -> FinSequence of the_Vertices_of G means : Def12 :
    it is one-to-one & rng it = the_Vertices_of G;
  existence proof
    consider p being FinSequence such that
A1: rng p = the_Vertices_of G & p is one-to-one by FINSEQ_4:73;
    reconsider p as FinSequence of the_Vertices_of G by A1,FINSEQ_1:def 4;
    take p;
    thus thesis by A1;
   end;
end;

registration
  let G be finite _Graph;
  cluster -> non empty VertexScheme of G;
  correctness proof
   let S be VertexScheme of G;
    rng S = the_Vertices_of G by Def12;
   hence S is non empty by RELAT_1:60;
  end;
end;

theorem
for G being finite _Graph, S being VertexScheme of G
 holds len S = card the_Vertices_of G
proof let G be finite _Graph, S be VertexScheme of G;
   rng S = the_Vertices_of G & S is one-to-one by Def12;
 hence len S = card the_Vertices_of G by FINSEQ_4:77;
end;

theorem
for G being finite _Graph, S being VertexScheme of G holds 1 <= len S
proof let G be finite _Graph, S be VertexScheme of G;
   len S <> 0 by GRAPH_5:5;
  hence 1 <= len S by NAT_1:39;
end;

theorem Th106:
for G, H being finite _Graph, g being VertexScheme of G
 st G == H holds g is VertexScheme of H
proof let G,H be finite _Graph, g be VertexScheme of G such that A1: G == H;
A2: g is FinSequence of the_Vertices_of H by A1,GLIB_000:def 36;
   g is one-to-one & rng g = the_Vertices_of G by Def12; then
   g is one-to-one & rng g = the_Vertices_of H by A1,GLIB_000:def 36;
  hence g is VertexScheme of H by A2,Def12;
end;

definition let G be finite _Graph, S be VertexScheme of G, x be Vertex of G;
  redefine func x..S -> non zero Element of NAT;
  correctness proof
     rng S = the_Vertices_of G by Def12; then
     0+1 <= x..S by FINSEQ_4:31;
    hence x..S is non zero Element of NAT;
  end;
end;

definition let G be finite _Graph, S be VertexScheme of G, n be Nat;
  redefine func S.followSet(n) -> Subset of the_Vertices_of G;
  coherence proof
   n in NAT & len S in NAT by ORDINAL1:def 13; then
A1: rng (n,len S)-cut S c= rng S by GRAPH_2:11;
   now let x be set; assume x in S.followSet(n);
     then x in rng S by A1;
    hence x in the_Vertices_of G by Def12;
   end;
   hence S.followSet(n) is Subset of the_Vertices_of G by TARSKI:def 3;
  end;
end;

theorem Th107: :: NeVSchFol:
for G being finite _Graph, S being VertexScheme of G,
    n being non zero natural number st n <= len S
  holds S.followSet(n) is non empty
proof
  let G be finite _Graph, S be VertexScheme of G;
  let n be non zero Nat such that A1: n <= len S;
  0 <= n by NAT_1:18; then 0 < n by REAL_1:def 5; then
  0+1 <= n by NAT_1:38; then
A2: len ((n, len S)-cut S) + n = len S + 1 by A1, GRAPH_2:def 1;
     len S + 1 - n <> 0 by A1, NAT_1:38;
  then (n, len S)-cut S <> {} by A2,FINSEQ_1:25;
 hence S.followSet(n) is non empty by FINSEQ_1:27;
end;

definition let G be finite _Graph, S be VertexScheme of G;
  attr S is perfect means                                       :Def13:
    for n being non zero natural number st n <= len S
    for Gf being inducedSubgraph of G,S.followSet(n)
    for v being Vertex of Gf st v = S.n holds v is simplicial;
end;

:: finite is needed unless we add loopless
theorem Th108: :: PerScheme01
for G being finite trivial _Graph, v being Vertex of G
  ex S being VertexScheme of G st S = <*v*> & S is perfect
proof let G be finite trivial _Graph, v being Vertex of G;
   consider v1 being Vertex of G such that
A1: the_Vertices_of G = {v1} by GLIB_000:25;
A2: v1 = v by A1, TARSKI:def 1;
  set S = <*v*>;
A3: S is one-to-one by FINSEQ_3:102;
A4: rng S = the_Vertices_of G by A1, A2, FINSEQ_1:56;
  reconsider S as VertexScheme of G by A3, A4, Def12;
  take S;
  thus S = <*v*>;
  let n be non zero Nat such that n <= len S;
  let Gf be inducedSubgraph of G,S.followSet(n);
  thus thesis by Th65;
end;

theorem
for G being finite _Graph, V being VertexScheme of G holds
  V is perfect iff
  for a,b,c being Vertex of G st b<>c & a,b are_adjacent & a,c are_adjacent
  for va,vb,vc being natural number
    st va in dom V & vb in dom V & vc in dom V & V.va = a &
       V.vb = b & V.vc = c & va < vb & va < vc
      holds b,c are_adjacent
proof let G be finite _Graph, V be VertexScheme of G;
A1: rng V = the_Vertices_of G by Def12;
A2: V is one-to-one by Def12;
A3: now let a,b,c be Vertex of G such that
A4: b<>c & a,b are_adjacent & a,c are_adjacent & not b,c are_adjacent;
       let va,vb,vc be Nat such that
A5: va in dom V & vb in dom V & vc in dom V &
    V.va=a & V.vb=b & V.vc=c & va < vb & va < vc;
A6: a <> b & a <> c by A5,A2,FUNCT_1:def 8;
    assume A7: V is perfect;
A8: 1 <= va & va <= len V by A5,FINSEQ_3:27; then
A9: 0 < va by XREAL_1:2;
A10: V.followSet(va) is non empty by A8,A9,Th107;
    consider Gf being inducedSubgraph of G,V.followSet(va);
    set fs = (va,len V)-cut V;
A11: len fs + va - va = len V + 1 - va by A8,GRAPH_2:def 1;
A12: len fs = len V - va + 1 by A11;
    consider jb being Nat such that
A13: va + jb = vb by A5,NAT_1:28;
    consider jc being Nat such that
A14: va + jc = vc by A5,NAT_1:28;

     va - va <= len V - va by A8,XREAL_1:11; then
A15: 0 < len fs by XREAL_1:41,A12; then
A16: fs.(0+1) = V.(va + 0) by A8,GRAPH_2:def 1;
A17: now assume jb >= len fs; then
       va + jb >= len V + 1 - va + va by A11,XREAL_1:9; then
       vb > len V by A13, NAT_1:38;
       hence contradiction by A5,FINSEQ_3:27;
     end;
A18: fs.(jb+1) = V.(va + jb) by A17, A8,GRAPH_2:def 1;
A19: now assume jc >= len fs; then
       va + jc >= len V + 1 - va + va by A11, XREAL_1:9; then
       vc > len V by A14, NAT_1:38;
       hence contradiction by A5,FINSEQ_3:27;
     end;
A20: fs.(jc+1) = V.(va + jc) by A19, A8,GRAPH_2:def 1;
    0+1 <= len fs by A15,NAT_1:38; then
    0+1 in dom fs by FINSEQ_3:27; then
A21: a in V.followSet(va) by A5,A16,FUNCT_1:12;

    0 <= jb by NAT_1:18; then 0+1 <= jb+1 by XREAL_1:9; then
    1 <= jb+1 & jb+1 <= len fs by A17,NAT_1:38; then
    jb+1 in dom fs by FINSEQ_3:27; then
A22: b in V.followSet(va) by A5,A18,A13,FUNCT_1:12;

    0 <= jc by NAT_1:18; then 0+1 <= jc+1 by XREAL_1:9; then
    1 <= jc+1 & jc+1 <= len fs by A19,NAT_1:38; then
    jc+1 in dom fs by FINSEQ_3:27; then
A23: c in V.followSet(va) by A5,A20,A14,FUNCT_1:12;
    reconsider ag=a as Vertex of Gf by GLIB_000:def 39,A21;

reconsider bg=b as Vertex of Gf by GLIB_000:def 39,A22;
    reconsider cg=c as Vertex of Gf by GLIB_000:def 39,A23;
A24: ag is simplicial by A7,A9,A8,A5,Def13;
A25: ag,bg are_adjacent & ag,cg are_adjacent & not bg,cg are_adjacent
       by A10,A4,Th45;  then
    bg in Gf.AdjacentSet({ag}) & cg in Gf.AdjacentSet({ag}) by A6,Th52;
    then ex e being set st e Joins bg,cg,Gf by A24,A4,Th68;
    hence contradiction by A25, Def3;
   end;

   now assume not V is perfect; then
    not (for n being non zero Nat st n <= len V
    for Gf being inducedSubgraph of G,V.followSet(n)
    for v being Vertex of Gf st v = V.n holds v is simplicial)
      by Def13; then
       consider n being non zero Nat,
              Gf being (inducedSubgraph of G,V.followSet(n)),
                v being Vertex of Gf such that
   A26: n <= len V & v = V.n & not v is simplicial;
       1 <= n & n <= len V by A26,Th1; then
   A27: n in dom V by FINSEQ_3:27;
       consider a,b being Vertex of Gf such that
   A28: a<>b & v<>a & v<>b and
   A29: v,a are_adjacent & v,b are_adjacent & not a,b are_adjacent
            by A26,Th69;
   A30: V.followSet(n) is non empty Subset of the_Vertices_of G by A26,Th107;
       then
   A31: the_Vertices_of Gf = V.followSet(n) by GLIB_000:def 39;
       reconsider vg=v as Vertex of G by A31,TARSKI:def 3;
   A32: a in the_Vertices_of G by A31,TARSKI:def 3;
       reconsider ag=a, bg=b as Vertex of G by A31,TARSKI:def 3;
   A33: b in the_Vertices_of G by A31,TARSKI:def 3;
   A34: vg,ag are_adjacent & vg,bg are_adjacent & not ag,bg are_adjacent
          by A30,A29,Th45;
   A35: a in rng V by A31,TARSKI:def 3,A1;
       consider va being Element of NAT such that
   A36: va in dom V & V.va = a by A32, A1,FINSEQ_2:11;
   A37: b in rng V by A31,TARSKI:def 3,A1;
       consider vb being Element of NAT such that
   A38: vb in dom V & V.vb = b by A33, A1, FINSEQ_2:11;
   A39: now assume va <= n; then
       A40: va < n by A28,A26,A36,REAL_1:def 5;
           a..V >= n by Th16,A35,A31,A27,A2; then
           va < a..V by A40,XREAL_1:2;
         hence contradiction by A36, FINSEQ_4:34;
       end;
   A41:  now assume vb <= n; then
       A42: vb < n by A28,A26,A38,REAL_1:def 5;
           b..V >= n by Th16,A37,A31,A27,A2; then
           vb < b..V by A42,XREAL_1:2;
         hence contradiction by A38, FINSEQ_4:34;
       end;
       per cases by A28,A36,A38,REAL_1:def 5;
       suppose va < vb;
       thus ex a,b,c being Vertex of G, va,vb,vc being Nat st
             b<>c & a,b are_adjacent & a,c are_adjacent &
             va in dom V & vb in dom V & vc in dom V &
             V.va = a & V.vb = b & V.vc = c & va < vb & va < vc &
             not b,c are_adjacent by A28,A34,A26,A36,A38,A39,A41,A27; end;
       suppose vb < va;
       thus ex a,b,c being Vertex of G, va,vb,vc being Nat st
             b<>c & a,b are_adjacent & a,c are_adjacent &
             va in dom V & vb in dom V & vc in dom V &
             V.va = a & V.vb = b & V.vc = c & va < vb & va < vc &
             not b,c are_adjacent by A28,A34,A26,A36,A38,A39,A41,A27; end;
   end;
  hence thesis by A3;
end;

:: Golubmic pg 83-84, Theorem 4.1 (i) ==> (ii)
registration let G be finite chordal _Graph;
  cluster perfect VertexScheme of G;
  existence proof
    defpred P[finite _Graph] means
    $1 is chordal implies ex S being VertexScheme of $1 st S is perfect;
A1: now let k be non zero Nat such that
    A2: for Gk being finite _Graph st Gk.order() < k holds P[Gk];
     let Gk1 be finite _Graph such that
    A3: Gk1.order() = k;
     thus P[Gk1] proof
        assume A4: Gk1 is chordal;
        per cases;
        suppose k = 1; then
        A5: Gk1 is trivial by A3,GLIB_000:29;
            consider v being Vertex of Gk1;
            ex S being VertexScheme of Gk1 st S = <*v*> & S is perfect
               by A5, Th108;
          hence thesis;
        end;
        suppose k <> 1; then
            reconsider G=Gk1 as non trivial finite chordal _Graph
                     by A4,A3,GLIB_000:29;
            consider x being Vertex of G such that
        A6: x is simplicial by Th103;
            consider H being removeVertex of G,x;
        A7: the_Vertices_of G\{x} is non empty by GLIB_000:23; then
        A8: the_Vertices_of H=the_Vertices_of G\{x} by GLIB_000:def 39;
            H.order() = card (the_Vertices_of G\{x}) by A7,GLIB_000:def 39
                  .= G.order() - card {x} by CARD_2:63
                  .= k - 1 by A3, CARD_2:60; then
            A9: H.order() < k by XREAL_1:148;
                consider T being VertexScheme of H such that
            A10: T is perfect by A2,A9;
                set S = <*x*>^T;
                rng T = the_Vertices_of G\{x} by A8,Def12; then
                rng S = the_Vertices_of G\{x} \/ rng <*x*> by FINSEQ_1:44;then
                rng S = the_Vertices_of G\{x} \/ {x} by FINSEQ_1:55; then
                rng S = {x} \/ the_Vertices_of G by XBOOLE_1:39; then
            A11: rng S = the_Vertices_of G by XBOOLE_1:12; then
                reconsider S as FinSequence of the_Vertices_of G
                     by FINSEQ_1:def 4;
                {x} /\ rng T = {x} /\ (the_Vertices_of G\{x}) by A8,Def12
                     .= ({x} /\ the_Vertices_of G) \ {x} by XBOOLE_1:49
                     .= {x} \ {x} by XBOOLE_1:28
                     .= {} by XBOOLE_1:37; then
                {x} misses rng T by XBOOLE_0:def 7; then
            A12: rng <*x*> misses rng T by FINSEQ_1:55;
            A13: <*x*> is one-to-one by FINSEQ_3:102;
                T is one-to-one by Def12; then
                S is one-to-one by A12,A13,FINSEQ_3:98; then
                reconsider S as VertexScheme of Gk1 by A11,Def12;
                take S;
                let n be non zero Nat such that
            A14: n <= len S;
                let Gf be inducedSubgraph of Gk1,S.followSet(n);
                let v be Vertex of Gf such that
            A15: v = S.n;
            A16: 1 <= n by NAT_1:39;
                per cases by A16,REAL_1:def 5;
                suppose A17: 1 = n; then
                A18: x = v by A15,FINSEQ_1:58;
                    S.followSet(n) = rng S by A17, GRAPH_2:7
                                  .= the_Vertices_of G by Def12; then
                    Gf == G by GLIB_000:97;
                    hence v is simplicial by A6,A18,Th66;
                end;
                suppose A19: 1 < n; then
                    1+(-1) < n+(-1) by XREAL_1:10; then
                    reconsider n1 = n - 1 as non zero Element of NAT
                         by INT_1:16;
                    len <*x*> = 1 by FINSEQ_1:56; then
                A20: S.n = T.n1 by A14,A19,FINSEQ_1:37;
                    n+(-1) <= len S+(-1) by A14,XREAL_1:9; then
                    n1 <= len <*x*> + len T + (-1) by FINSEQ_1:35; then
               A21: n1 <= 1 + len T + (-1) by FINSEQ_1:56;
               A22: T.followSet(n1) = S.followSet(n1+1) by Th17;
                    T.followSet(n1) is non empty by A21,Th107; then
                  Gf is inducedSubgraph of H,T.followSet(n1)
                      by A22,A8,Th30;
                hence v is simplicial by A21,A15,A20,A10,Def13;
              end;
              end;
            end;
   end;
   for G being finite _Graph holds P[G] from FinGraphOrderCompInd(A1); then
   consider S being VertexScheme of G such that A23: S is perfect;
   take S;
   thus S is perfect by A23;
  end;
end;

theorem
for G, H being finite chordal _Graph, g being perfect VertexScheme of G
 st G == H holds g is perfect VertexScheme of H
proof let G,H be finite chordal _Graph, g be perfect VertexScheme of G
  such that A1: G == H;
  reconsider h=g as VertexScheme of H by A1,Th106;
  now let n be non zero Nat such that A2: n <= len h;
      let Hf be inducedSubgraph of H,h.followSet(n);
      let vh be Vertex of Hf such that A3: vh = h.n;
      G.edgesBetween(g.followSet(n)) = H.edgesBetween(g.followSet(n))
         by A1,GLIB_000:93; then
      reconsider Gf = Hf as inducedSubgraph of G,g.followSet(n)
         by A1,GLIB_000:98;
      reconsider vg = vh as Vertex of Gf;
      vg is simplicial by A2,A3,Def13;
    hence vh is simplicial;
  end;
 hence g is perfect VertexScheme of H by Def13;
end;

:: Golubmic pg 83-84,  Theorem 4.1 (ii) ==> (i)
theorem :: Chordal41c:
for G being finite _Graph
 st ex S being VertexScheme of G st S is perfect holds G is chordal
proof
   let G be finite _Graph;
   given S being VertexScheme of G such that
A1: S is perfect;
   let P be Walk of G such that A2: P.length() > 3 & P is Cycle-like;
A3:  P is Path-like by A2,GLIB_001:def 31;
A4: P.vertices() is non empty by GLIB_001:89;
A5: rng S = the_Vertices_of G by Def12;
    consider x being set such that
A6: x in P.vertices() and
A7: for y being set st y in P.vertices() holds x..S <= y..S
          by A5,A4,Th15;
    reconsider x as Vertex of G by A6;
    set n = x..S;
A8: rng S = the_Vertices_of G by Def12; then
A9: n <= len S by FINSEQ_4:31;
A10: n in dom S by A8,FINSEQ_4:30;
A11: S is one-to-one by Def12;
        now let y be set such that A12: y in P.vertices();
            reconsider z=y as Vertex of G by A12;
            x..S <= z..S by A12,A7;
            hence y in S.followSet(n) by A8, A10, A11, Th16;
        end; then
A13: P.vertices() c= S.followSet(n) by TARSKI:def 3;
    consider H being inducedSubgraph of G,S.followSet(n);
A14: rng S = the_Vertices_of G by Def12; then
A15: n <= len S by FINSEQ_4:31;
    x in S.followSet(n) by A8,A10,A11,Th16; then
    reconsider y=x as Vertex of H by GLIB_000:def 39;
    S.n = x by A14,FINSEQ_4:29; then
A16: y is simplicial by A1,A15,Def13;

A17: S.followSet(n) is non empty by A9, Th107; then
    reconsider C=P as Walk of H by A13,Th23;
    reconsider C as Path of H by A3, GLIB_001:177;
    P is non trivial & P is closed by A2,GLIB_001:def 31; then
    C is non trivial & C is closed by GLIB_001:177; then
A18: C is Cycle-like by GLIB_001:def 31;
A19: C.length() > 3 by A2,GLIB_001:115;
    y in C.vertices() by A6,GLIB_001:99; then
     consider a,b being odd Nat such that
A20: a+2 < b & b <= len C and
A21: C.a <> C.b & C.a in H.AdjacentSet({y}) & C.b in H.AdjacentSet({y}) and
A22: for e being set st e in C.edges() holds not e Joins C.a,C.b,H
     by A18,A19,Th55;  :: <==
    consider e being set such that
A23: e Joins C.a,C.b,H by A21,A16,Th68;
    C is chordal by A20,A21,A22,A23,Def10;
  hence P is chordal by A17, Th87;
end;
