:: Chordal Graphs
::  by Broderick Arneson and Piotr Rudnicki
:: 
:: Received August 18, 2006
:: Copyright (c) 2006 Association of Mizar Users

environ

 vocabularies ARYTM, ARYTM_1, BOOLE, CARD_1, CAT_1, ORDINAL2, FINSET_1,
      FUNCT_1, FINSEQ_1, FINSEQ_4, GRAPH_1, GLIB_000, GLIB_001, GLIB_002,
      MATRIX_2, MSAFREE2, XREAL_0, NAT_1, INT_1, PRE_TOPC, REALSET1, RELAT_1,
      RELAT_2, CHORD, TOPGEN_1, SQUARE_1, GRAPH_2, MEMBERED, BHSP_3;
 notations TARSKI, XBOOLE_0, CQC_SIM1, SUBSET_1, ORDINAL1, XCMPLX_0, XXREAL_0,
      DOMAIN_1, RELAT_1, FUNCT_1, FUNCT_2, FINSEQ_1, CARD_1, FINSET_1, INT_1,
      NAT_1, GLIB_000, GLIB_001, GLIB_002, ZFMISC_1, CQC_LANG, ABIAN, ENUMSET1,
      FINSEQ_4, NUMBERS, GRAPH_2, PRE_CIRC, MEMBERED;
 constructors DOMAIN_1, NAT_1, AMISTD_2, BINARITH, FINSEQ_4, GLIB_001,
      GLIB_002, CQC_SIM1, GRAPH_2, PRE_CIRC, XXREAL_0;
 registrations RELSET_1, NAT_1, XBOOLE_0, MEMBERED, GLIB_000, FINSEQ_1,
      GLIB_001, GLIB_002, SUBSET_1, FINSET_1, INT_1, ABIAN, JORDAN1D, ORDINAL1,
      RELAT_1, PRE_CIRC, PNPROC_1, HEYTING3;
 requirements ARITHM, BOOLE, NUMERALS, REAL, SUBSET;
 definitions TARSKI, XBOOLE_0, GLIB_000, GLIB_001, GLIB_002;
 theorems FINSEQ_1, FUNCT_1, GLIB_000, GLIB_001, GLIB_002, GRAPH_2, GRAPH_5,
      GRAPH_3, TREES_1, HEYTING3, INT_1, JORDAN12, NAT_1, ORDINAL1, REAL_1,
      RELAT_1, TARSKI, TRIANG_1, XBOOLE_0, XBOOLE_1, FINSET_1, CARD_1,
      CQC_LANG, FUNCT_2, FINSEQ_3, FINSEQ_4, ZFMISC_1, ABIAN, SCMFSA9A, CARD_2,
      ENUMSET1, FINSEQ_2, XREAL_1, CQC_THE1, CQC_SIM1, PRE_CIRC, MEMBERED,
      FINSEQ_5;
 schemes BINARITH, NAT_1, GRAPH_5, FUNCT_2, FRAENKEL;

begin :: Preliminaries

theorem Nat00: :: Nat00
for n being non zero natural number holds n-1 is natural number & 1 <= n
proof let n be non zero Nat;
   0 < n by NAT_1:19; then
A: 0+1 <= n by NAT_1:38; then
   0+1-1 <= n-1 by XREAL_1:11;
   then n-1 in NAT by INT_1:16;
  hence n-1 is Nat by ORDINAL1:def 13;
  thus 1 <= n by A;
end;

theorem Nat02: :: Nat02
for n being odd natural number holds n-1 is natural number & 1 <= n
proof let n be odd Nat;
   consider k being Element of NAT such that
A: n = 2*k + 1 by SCMFSA9A:1;
   0 <= 2*k by NAT_1:18; then
B: 0+1 <= 2*k+1 by XREAL_1:9; 
  thus n-1 is Nat by A;
  thus 1 <= n by A,B;
end;

Nat03:
for a,b,c being Integer st a+2 < b holds c-b+1 + 2 < c-a+1
proof let a,b,c be Integer such that A: a+2 < b;
   assume c-b+1 + 2 >= c-a+1; then
   c-b+3-3 >= c-a + 1 -3 by XREAL_1:11; then
   c - b >= c - (a+2);
  hence contradiction by A,XREAL_1:12;
end;

theorem EvenOdd02: :: EvenOdd02
for n,m being odd Integer st n < m holds n <= m-2
proof let n,m be odd Integer such that A1: n < m;
    n+1 <= m by A1,INT_1:20; then
    n+1+(-1) <= m+(-1) by XREAL_1:9; then
    n < m-1 by REAL_1:def 5; then
    n+1 <= m-1 by INT_1:20; then
    n+1+(-1) <= m-1+(-1) by XREAL_1:9; 
    hence n <= m-2;
end;

theorem EvenOdd03:  :: EvenOdd03:
for n,m being odd Integer st m < n holds m+2 <= n
proof let n,m be odd Integer such that A1: m < n;
    m+1 <= n by A1,INT_1:20; then
    m+1 < n by REAL_1:def 5; then
    m+1+1 <= n by INT_1:20;  
  hence m+2 <= n;
end;

theorem EvenOdd04: :: EvenOdd04:
for n being odd natural number st 1 <> n
  ex m being odd natural number st m+2 = n
proof let n being odd Nat; assume
A: 1 <> n; 
   1 <= n by HEYTING3:1; then
   2*0+1 < n by A, REAL_1:def 5; then
   1+2 <= n by EvenOdd03; then
   1+2-2 <= n-2 by XREAL_1:11; then
   0 <= n-2*1 by XREAL_1:2; then
   n-2*1 in NAT by INT_1:16; then
 reconsider m = n-2 as odd Nat by ORDINAL1:def 13;
 take m;
 thus m+2 = n;
end;

theorem Odd100: :: Odd100
for n being odd natural number st n<=2 holds n=1
proof let n be odd Nat such that A: n<=2;
  n <> 2*1; then n < 1+1 by A,REAL_1:def 5; then
  n <= 1 & n >= 1 by NAT_1:38,HEYTING3:1;
  hence n = 1 by XREAL_1:1;
end;

theorem Odd101: :: Odd101
for n being odd natural number st n<=4 holds n=1 or n=3
proof let n be odd Nat such that A: n<=4;
  n<>2*2; then n<3+1 by A,REAL_1:def 5; then B: n<=3 by NAT_1:38;
  per cases by B,REAL_1:def 5;
  suppose n=3; hence thesis; end;
  suppose n<2+1; then n<=2 by NAT_1:38;
    hence thesis by Odd100; end;
end;
 
theorem Odd102: :: Odd102
for n being odd natural number st n<=6 holds n=1 or n=3 or n=5
proof let n be odd Nat such that A: n<=6;
  n<>2*3; then n<5+1 by A,REAL_1:def 5; then B:n<=5 by NAT_1:38;
  per cases by B,REAL_1:def 5;
  suppose n=5; hence thesis; end;
  suppose n<4+1; then n<=4 by NAT_1:38;
    hence thesis by Odd101; end;
end;

theorem 
for n being odd natural number st n<=8 holds n=1 or n=3 or n=5 or n=7
proof let n be odd Nat such that A: n<=8;
  n<>2*4; then n<7+1 by A,REAL_1:def 5; then B:n<=7 by NAT_1:38;
  per cases by B,REAL_1:def 5;
  suppose n=7; hence thesis; end;
  suppose n<6+1; then n<=6 by NAT_1:38;
    hence thesis by Odd102; end;
end;

theorem Even100: :: Even100
for n being even natural number st n<=1 holds n=0
proof let n be even Nat such that A: n<=1;
  n<>2*0+1; then n<0+1 by A,REAL_1:def 5; then
  n<=0 & n>=0 by NAT_1:38,NAT_1:18;
  hence n=0 by XREAL_1:1;
end;

theorem Even101: :: Even101
for n being even natural number st n<=3 holds n=0 or n=2
proof let n be even Nat such that A: n<=3;
  n<>2*1+1; then n<2+1 by A,REAL_1:def 5; then B: n<=2 by NAT_1:38;
  per cases by B,REAL_1:def 5;
  suppose n=2; hence thesis; end;
  suppose n<1+1; then n<=1 by NAT_1:38;
    hence thesis by Even100; end;
end;

theorem Even102: :: Even102
for n being even natural number st n<=5 holds n=0 or n=2 or n=4
proof let n be even Nat such that A: n<=5;
  n<>2*2+1; then n<4+1 by A,REAL_1:def 5; then B: n<=4 by NAT_1:38;
  per cases by B,REAL_1:def 5;
  suppose n=4; hence thesis; end;
  suppose n<3+1; then n<=3 by NAT_1:38;
    hence thesis by Even101; end;
end;
 
theorem Even103: :: Even103
for n being even natural number st n<=7 holds n=0 or n=2 or n=4 or n=6
proof let n be even Nat such that A: n<=7;
  n<>2*3+1; then n<6+1 by A,REAL_1:def 5; then B: n<=6 by NAT_1:38;
  per cases by B,REAL_1:def 5;
  suppose n=6; hence thesis; end;
  suppose n<5+1; then n<=5 by NAT_1:38;
    hence thesis by Even102; end;
end;


OddDiff00: :: OddDiff00 :: also in lexbfs
for i,j being odd natural number st i <= j
  ex k being natural number st i+2*k = j
proof
    let i,j be odd Nat such that A1: i <= j;
    consider jjj being Nat such that
H5a: j = i+jjj by A1,NAT_1:28;
H5c: jjj in NAT by ORDINAL1:def 13;
    now assume jjj is odd; then
        reconsider jf=jjj as odd Nat;
        i+jf is even;
        hence contradiction by H5a;
    end;
    then consider jj being Element of NAT such that
H5b: 2*jj = jjj by H5c, ABIAN:def 2;
    reconsider jj as Nat;
    take jj;
    thus i + 2*jj = j by H5a,H5b;
end;

theorem 
for p being FinSequence, n being non zero natural number
 st p is one-to-one & n <= len p holds (p.n)..p = n
proof let S be FinSequence;
    let n be non zero Nat such that
A0: S is one-to-one and
A1: n <= len S;
    0+1 <= n by NAT_1:39; then
A4: n in dom S by A1,FINSEQ_3:27; then
A3: S.n in rng S by FUNCT_1:12;
    set m = (S.n)..S;
A5: m in dom S by A3,FINSEQ_4:30;
    S.m = S.n by A3,FINSEQ_4:29;
    hence n = m by A0,A4,A5,FUNCT_1:def 8;
end;

theorem Index01: :: Index01
for p being non empty FinSequence, T being non empty Subset of rng p
  ex x being set st x in T & for y being set st y in T holds x..p <= y..p
proof let S be non empty FinSequence; let T be non empty Subset of rng S;
    deffunc F(set) = $1..S;
    consider m being Element of T such that
A2: for y being Element of T holds F(m) <= F(y) from GRAPH_5:sch 2;
    take m;
    thus m in T;
    let y be set such that B1: y in T;
    thus m..S <= y..S by A2, B1;
end;

definition let p be FinSequence, n be natural number;
  func p.followSet(n) -> finite set equals
    rng (n,len p)-cut p;
  correctness;
end;

theorem Follow00: :: Follow00
for p being FinSequence, x being set, n being natural number
 st x in rng p & n in dom p & p is one-to-one
  holds x in p.followSet(n) iff x..p >= n
proof
  let p be FinSequence, x be set, n be Nat such that
A1: x in rng p and
A2: n in dom p and
A3: p is one-to-one;

hereby assume x in p.followSet(n); then
    consider a being Element of NAT such that
B2: a in dom (n, len p)-cut p and
B3: ((n, len p)-cut p).a = x by FINSEQ_2:11;
     n in NAT by ORDINAL1:def 13; then
    consider k being Element of NAT such that
B4: k in dom p and
B5: p.k = ((n, len p)-cut p).a and k+1 = n+a and
B7: n <= k & k <= len p by B2, GRAPH_3:2;
B8: x..p in dom p by A1,FINSEQ_4:30; 
    p.(x..p) = x by A1, FINSEQ_4:29; 
  hence x..p >= n by B7, A3,B4,B8,B5,B3,FUNCT_1:def 8;
end;
assume
BB: x..p >= n;
A4: p.(x..p) = x by A1, FINSEQ_4:29;
    consider k being Nat such that
B0: x..p = n + k by BB,NAT_1:28;
Bb: 1 <= n & n <= len p by A2,FINSEQ_3:27; then
B1: len ((n, len p)-cut p) + n = len p + 1 by GRAPH_2:def 1;
    x..p in dom p by A1,FINSEQ_4:30; then
    k + n <= len p by B0, FINSEQ_3:27; then
    k + n + (-n) <= len p + (-n) by XREAL_1:9; then
B3a:    k + 1 <= len p - n + 1 by XREAL_1:9; 
    0 <= k by NAT_1:18; then    
    0+1 <= k+1 by XREAL_1:9; then
B5: k+1 in dom ((n, len p)-cut p) by B3a,B1,FINSEQ_3:27;
    k < len ((n, len p)-cut p) by B3a,B1, NAT_1:38; 
    then ((n, len p)-cut p).(k+1) = p.(x..p) by B0,Bb, GRAPH_2:def 1; 
  hence x in p.followSet(n) by A4, B5, FUNCT_1:12;
end;

theorem Follow03: :: Follow03
for p, q being FinSequence, x being set st p = <*x*>^q
for n being non zero natural number holds p.followSet(n+1) = q.followSet(n)
proof let p,q be FinSequence, x be set such that
A1: p = <*x*>^q;
    let n be non zero Nat;
    len <*x*> = 1 by FINSEQ_1:57; then
A4: len p = 1 + len q by A1,FINSEQ_1:35;
per cases;
suppose D1: n > len q; then 
    n+1 > len p by A4,XREAL_1:10; then
    (n+1,len p)-cut p = {} by GRAPH_2:def 1; 
  hence p.followSet(n+1) = q.followSet(n) by D1,GRAPH_2:def 1; end;    
suppose D1: n <= len q; 
    0 <= n & 0 <> n by NAT_1:18; then 0 < n by REAL_1:def 5; then
C0: 0+1 <= n by NAT_1:38;
A7a: len (n, len q)-cut q + n = len q + 1 by C0, D1, GRAPH_2:def 1;
AC: 1 <= n+1 & n+1 <= len p & len p <= len p by A4,XREAL_1:9,C0,D1; then    
A6a:len ((n+1, len p)-cut p) + (n+1) = len p + 1 by GRAPH_2:def 1; 
    dom ((n+1,len p)-cut p) =
    Seg (len ((n, len q)-cut q)) by A6a,A7a,A4,FINSEQ_1:def 3;then
A8: dom ((n+1,len p)-cut p) = dom ((n, len q)-cut q) by FINSEQ_1:def 3;
    
AA: now let i be Nat such that B1: i in dom q;
        p.(len <*x*> + i) = q.i by A1,B1,FINSEQ_1:def 7; 
      hence p.(i+1) = q.i by FINSEQ_1:57;
    end;
A5: now let k be Nat such that B1: k in dom ((n, len q)-cut q); 
    B3: 1 <= k & k <= (len p - n) by A6a, A8,B1,FINSEQ_3:27; then
    B4: n+k <= n+((len p)-n) by XREAL_1:9; 
    B5: 1+-1 <= k+-1 by B3,XREAL_1:9; then
        k-1 in NAT by INT_1:16; then
        reconsider k1 = k-1 as Nat by ORDINAL1:def 13;
    AF: -1 + k < 0 + (len p - n) by B3,XREAL_1:10; 
    AD: k1+n +1 + -1 <= len q + 1 + -1 by B4,A4,XREAL_1:9; 
        1+0 <= n+k1 by B5,C0,XREAL_1:9; then
    AE: n+k1 in dom q by AD,FINSEQ_3:27;    
      thus ((n+1,len p)-cut p).k = ((n+1, len p)-cut p).(k1+1)
                    .= p.(n+1+k1) by AF,A6a,AC,GRAPH_2:def 1
                    .= p.(n+k1+1)
                    .= q.(n+k1) by AA,AE
                   .= ((n,len q)-cut q).(k1+1) by AF,A7a,A4,C0,D1,GRAPH_2:def 1
                    .= ((n,len q)-cut q).k;
    end;
    
    now let y be set;
      hereby assume y in rng (n+1,len p)-cut p; then
        consider k being Element of NAT such that
    B1: k in dom (n+1, len p)-cut p and 
    B2: ((n+1,len p)-cut p).k = y by FINSEQ_2:11;
        ((n+1,len p)-cut p).k = ((n, len q)-cut q).k by A8,B1,A5;
       hence y in rng (n, len q)-cut q by B2,A8,B1,FUNCT_1:12;
      end;  
      assume y in rng ((n, len q)-cut q); then
        consider k being Element of NAT such that
    B1: k in dom (n, len q)-cut q and
    B2: ((n, len q)-cut q).k = y by FINSEQ_2:11;
        ((n+1,len p)-cut p).k = ((n, len q)-cut q).k by B1,A5; 
      hence y in rng (n+1,len p)-cut p by B2, B1,A8,FUNCT_1:12;
    end;
  hence p.followSet(n+1) = q.followSet(n) by TARSKI:2; end;
end;

theorem FinSubseq00: :: FinSubseq00
for X being set, f being FinSequence of X, g being FinSubsequence of f
 st len Seq g = len f holds Seq g = f
proof let X be set, f be FinSequence of X, g be FinSubsequence of f such that
A: len Seq g = len f;
F: len Seq g = card g by GLIB_001:5;
E: g c= f by GRAPH_2:def 5; 
   now assume g <> f; then g c< f by E, XBOOLE_0:def 8; 
    hence contradiction by A, F, CARD_2:67;
   end; 
  hence Seq g = f by GRAPH_2:24; 
end;

begin :: Miscellany on graphs

theorem Joins01:  :: :: Joins01:  
for G being _Graph, S being Subset of the_Vertices_of G
for H being inducedSubgraph of G,S
for u,v being set st u in S & v in S
for e being set st e Joins u,v,G holds e Joins u,v,H
proof let G be _Graph, S be Subset of the_Vertices_of G;
    let H be inducedSubgraph of G,S;
    let u,v be set such that
AA: u in S & v in S;
    reconsider S as non empty Subset of the_Vertices_of G by AA;
    let e be set such that
A1: e Joins u,v,G;
    e in G.edgesBetween(S) by A1,AA,GLIB_000:35; then
A2: e in the_Edges_of H by GLIB_000:def 39;
A3: (((the_Source_of G).e = u & (the_Target_of G).e = v) or
    ((the_Source_of G).e = v & (the_Target_of G).e = u)) by A1,GLIB_000:def 15;
    the_Source_of H = (the_Source_of G) | the_Edges_of H &
    the_Target_of H = (the_Target_of G) | the_Edges_of H by GLIB_000:48; then
    (the_Source_of H).e = (the_Source_of G).e &
    (the_Target_of H).e = (the_Target_of G).e by A2,FUNCT_1:72; 
    hence thesis by A3, A2,GLIB_000:def 15;
end;

theorem 
for G being _Graph, W being Walk of G
 holds W is Trail-like iff len W = 2*(card W.edges())+1
proof let G be _Graph, W be Walk of G; set WE = W.edges(), WES = W.edgeSeq();
    W is Trail-like iff W.edgeSeq() is one-to-one by GLIB_001:def 27; then
    W is Trail-like iff 2*card WE + 1 = 2*len WES+1 by FINSEQ_4:77;
    hence thesis by GLIB_001:def 15;        
end;

theorem Walk02: :: Walk02
for G being _Graph, S being Subset of the_Vertices_of G
for H being removeVertices of G,S
for W being Walk of G
 st (for n being odd natural number st n <= len W holds not W.n in S)
  holds W is Walk of H
proof
    let G be _Graph, S be Subset of the_Vertices_of G;
    let H be removeVertices of G,S;
    let W be Walk of G such that
A1: for n being odd Nat st n <= len W holds not W.n in S;
A2: now assume the_Vertices_of G\S = {}; then
    B1a: the_Vertices_of G c= S & S c= the_Vertices_of G by XBOOLE_1:37; 
        W.last() in the_Vertices_of G;
     hence contradiction by A1, B1a;
    end;
A3: the_Vertices_of H = the_Vertices_of G\S &
    the_Edges_of H = G.edgesBetween(the_Vertices_of G\S) by A2,GLIB_000:def 39;
    now let x be set such that B1: x in W.vertices();
        consider n being odd Element of NAT such that
    B2: n <= len W & W.n = x by B1,GLIB_001:88;
        x in the_Vertices_of G & not x in S by A1, B2, GLIB_001:8; 
        hence x in the_Vertices_of H by A3, XBOOLE_0:def 4;
    end; then
BB: W.vertices() c= the_Vertices_of H by TARSKI:def 3;
BC: W.edges() c= G.edgesBetween(W.vertices()) by GLIB_001:110;
    G.edgesBetween(W.vertices()) c= G.edgesBetween(the_Vertices_of H)
        by BB,GLIB_000:39; then
    W.edges() c= G.edgesBetween(the_Vertices_of H) by BC,XBOOLE_1:1;
    hence W is Walk of H by A3, BB,GLIB_001:171;
end;

theorem Walk03: :: Walk03
for G being _Graph, a,b be set st a<>b
for W being Walk of G st W.vertices() = {a,b}
 holds ex e being set st e Joins a,b,G
proof let G be _Graph, a,b be set such that
A: a<>b;
    let W be Walk of G such that
B: W.vertices() = {a,b};
D: W.first() in W.vertices() by GLIB_001:89;
C: now let x be set such that
    A1: W.first() = x;
       let y be set such that
    B1: y in {a,b} \ {x};
    B1c:x in {x} by TARSKI:def 1; 
        set k = W.find(y);
    B1b: x = a or x = b by A1,B,D,TARSKI:def 2;
    D1: k <= len W by B,B1,GLIB_001:def 19;
    E1: W.k = y by B,B1,GLIB_001:def 19;
        k <> 1 by B1c,B1,XBOOLE_0:def 4,E1,A1;
        then consider m being odd Nat such that
    G1: m+2 = k by EvenOdd04;
    I1: m < k by G1, NAT_1:41; then
    J1: m < len W by D1, XREAL_1:2;
    J1a: m in NAT by ORDINAL1:def 13; then
        W.m in {a,b} by J1,B,GLIB_001:88; then
    L1: W.m = a or W.m = b by TARSKI:def 2;
    M1: y = a or y = b by B1,TARSKI:def 2;
        W.(m+1) Joins W.m,W.k,G by J1a, J1, G1, GLIB_001:def 3;
     hence ex e being set st e Joins x,y,G
        by L1,M1,B1b,B1c,XBOOLE_0:def 4,I1,J1a,J1,E1,B,B1,GLIB_001:def 19;
   end;
   per cases by B, D, TARSKI:def 2;
   suppose S0: W.first() = a;
          b in {b} by TARSKI:def 1;
     then b in {a,b}\{a} by A, ZFMISC_1:23;
    hence thesis by S0, C;
   end;
   suppose S0: W.first() = b;
          a in {a} by TARSKI:def 1;
     then a in {a,b}\{b} by A, ZFMISC_1:23;
     then consider e be set such that
   A1: e Joins b,a,G by S0,C;
       e Joins a,b,G by A1, GLIB_000:17;
    hence thesis;
   end;
end;

theorem Walk04: :: Walk04
for G being _Graph, S being non empty Subset of the_Vertices_of G
for H being inducedSubgraph of G,S
for W being Walk of G st W.vertices() c= S holds W is Walk of H
proof
    let G be _Graph, S be non empty Subset of the_Vertices_of G;
    let H be inducedSubgraph of G,S;
    let W be Walk of G such that A1: W.vertices() c= S;
A4a: the_Vertices_of H = S &
    the_Edges_of H = G.edgesBetween(S) by GLIB_000:def 39; 
A2: W.vertices() c= the_Vertices_of H by A1,GLIB_000:def 39;
A3: W.edges() c= G.edgesBetween(W.vertices()) by GLIB_001:110;
    G.edgesBetween(W.vertices()) c= G.edgesBetween(the_Vertices_of H)
        by A2,GLIB_000:39; then
    W.edges() c= the_Edges_of H by A4a, A3,XBOOLE_1:1;
    hence W is Walk of H by A2,GLIB_001:171;
end;

theorem Cyclelike01: :: Cyclelike01
for G1,G2 being _Graph st G1 == G2
for W1 be Walk of G1, W2 being Walk of G2
 st W1 = W2 holds W1 is Cycle-like implies W2 is Cycle-like
proof let G1,G2 be _Graph such that A1: G1 == G2;
    let W1 be Walk of G1,W2 be Walk of G2 such that A2: W1 = W2;
    assume A3: W1 is Cycle-like;
    W1 is Path-like by A3,GLIB_001:def 31; then
A5: W2 is Path-like by A1,A2,GLIB_001:182;
    W1 is non trivial by A3,GLIB_001:def 31; then
    len W2 <> 1 by A2, GLIB_001:127; then
A6: W2 is non trivial by GLIB_001:127;
    W1 is closed by A3,GLIB_001:def 31; then
    W1.first() = W1.last() by GLIB_001:def 24; then
    W2.first() = W2.last() by A2; then
    W2 is closed by GLIB_001:def 24;
    hence W2 is Cycle-like by A6,A5,GLIB_001:def 31;
end;

theorem Path01: :: Path01
for G being _Graph, P being Path of G, m, n being odd natural number
 st m <= len P & n <= len P & P.m = P.n
  holds m = n or (m = 1 & n = len P) or (m = len P & n = 1)
proof let G be _Graph, P be Path of G, m, n be odd Nat such that
A: m <= len P & n <= len P & P.m = P.n;
B: m=n or m<n or n<m by REAL_1:def 5;
   m in NAT & n in NAT by ORDINAL1:def 13; 
 hence m=n or (m=1 & n=len P) or (m=len P & n = 1) by A,B,GLIB_001:def 28;
end;

theorem 
for G being _Graph, P being Path of G st P is open
for a,e,b being set
 st not a in P.vertices() & b = P.first() & e Joins a,b,G
  holds G.walkOf(a,e,b).append(P) is Path-like
proof let G be _Graph, P be Path of G such that A1: P is open;
    let a,e,b be set such that
A2: not a in P.vertices() and
A3: b = P.first() & e Joins a,b,G;
    set T = G.walkOf(a,e,b); set J = T.append(P);
A4: T.last() = P.first() by A3,GLIB_001:16;
    3 in Seg 3 by FINSEQ_1:5; then
    3 in Seg (len T) by A3,GLIB_001:15; then
    3 in dom T by FINSEQ_1:def 3; then
    J.3 = T.3 by GLIB_001:33; then
GX: J.3 = T.last() by A3,GLIB_001:15; then
A6: J.3 = b by A3,GLIB_001:16;
A9: now let m,n be odd Nat such that B1: m < n & n <= len J;
        assume B2: J.m = J.n;
    B3: 1 <= m & m < len J by HEYTING3:1,B1,XREAL_1:2; then
    D0: m in dom J by FINSEQ_3:27;
        2*0+1 < n by B3,B1,XREAL_1:2; then
    D9: 1+2 <= n by EvenOdd03;
        now assume m = 1; then
            J.m = J.first(); then
            J.m = T.first() by A4,GLIB_001:31; then
        C2: not J.m in P.vertices() by A2,A3,GLIB_001:16;
            per cases by D9,REAL_1:def 5;
          suppose n=3;
            hence contradiction by B2,C2, A3,A6,GLIB_001:89; end;
          suppose E1: n > 3; then
            not n in Seg 3 by FINSEQ_1:3; then
            not n in Seg (len T) by A3,GLIB_001:15; then
        D1: not n in dom T by FINSEQ_1:def 3;
            1 <= n by E1,XREAL_1:2; then
        D2: n in dom J by B1, FINSEQ_3:27;
            consider j being Element of NAT such that
        D5: j < len P & n = len T + j by D2,D1,GLIB_001:35;
            now assume j is odd; then
                reconsider jj=j as odd Nat;
                len T + jj is even; 
               hence contradiction by D5;
            end; then reconsider jj=j as even Nat;
            reconsider j1=jj+1 as odd Nat;
            j+1 <= len P by D5,NAT_1:38; then
            P.j1 in P.vertices() by GLIB_001:88; 
          hence contradiction by B2,C2, D5,A4,GLIB_001:34; end;
        end; then 2*0+1 < m by B3,REAL_1:def 5; then
    B4: 1+2 <= m by EvenOdd03; then
        3 < n by XREAL_1:2,B1; then
        not n in Seg 3 by FINSEQ_1:3; then
        not n in Seg (len T) by A3,GLIB_001:15; then
    D1: not n in dom T by FINSEQ_1:def 3;
        1 <= 3 & 3 <= n by B1,B4,XREAL_1:2; then
        1 <= n by XREAL_1:2; then
        n in Seg (len J) by B1,FINSEQ_1:3; then
    D2: n in dom J by FINSEQ_1:def 3;
        consider j being Element of NAT such that
    D5: j < len P & n = len T + j by D2,D1,GLIB_001:35;
    D8: J.n = P.(j+1) by D5,A4,GLIB_001:34;
        now assume j is odd; then
            reconsider jj=j as odd Nat;
            len T + jj is even;
            hence contradiction by D5;
        end; then reconsider jj=j as even Nat;
        reconsider j1=jj+1 as odd Nat;
    D6: j1 <= len P by D5,NAT_1:38;
        now assume m = 3; then
        C2: J.m = P.1 by A3,GLIB_001:16,GX;
            0 <> j & 0 <= j by B1,B4,A3,D5,GLIB_001:15,NAT_1:18;
            then 0 < j by REAL_1:def 5;
            then 2*0+1 < j1 by XREAL_1:10;
         hence contradiction by C2,D8,B2, A1,D6,GLIB_001:148;
        end; then         
        3 < m by B4,REAL_1:def 5; then
        not m in Seg 3 by FINSEQ_1:3; then
        not m in Seg (len T) by A3,GLIB_001:15; then
    D3: not m in dom T by FINSEQ_1:def 3;
        consider k being Element of NAT such that
    D4: k < len P & m = len T + k by D3,D0,GLIB_001:35;
    D7: J.m = P.(k+1) by D4,A4,GLIB_001:34;
        now assume k is odd; then
            reconsider kk=k as odd Nat;
            len T + kk is even;
            hence contradiction by D4;
        end; then reconsider kk=k as even Nat;
        reconsider k1=kk+1 as odd Nat;
        k < j by D4,D5,B1,XREAL_1:9; then
        k1 < j1 by XREAL_1:10; 
        hence contradiction by D7,D8,B2, A1,D6,GLIB_001:148;
    end;
    now let m,n be odd Element of NAT such that B1: m <= len J & n <= len J;
        assume B2: J.m = J.n;
    B3: m >= n by B1,B2,A9;
        not n < m by B1,A9,B2;
        hence n = m by B3,REAL_1:def 5;
    end; 
    hence thesis by GLIB_001:147;
end;

theorem PathLike03: :: PathLike03
:: A similar theorem is needed for obtaining non closed Path
for G being _Graph, P,H being Path of G
 st P.edges() misses H.edges() &
    P is non trivial & P is open & H is non trivial & H is open & 
    P.vertices() /\ H.vertices() = { P.first(), P.last() } & 
    H.first() = P.last() & H.last() = P.first()
  holds P.append(H) is Cycle-like
proof let G be _Graph, P,H be Path of G such that
A1: P.edges() misses H.edges() and
A2: P is non trivial & P is open and
A3: H is non trivial & H is open and
A4: P.vertices() /\ H.vertices() = { P.first(), P.last() } and
A5: H.first() = P.last() & H.last() = P.first();
    set J = P.append(H);
A9: len J + 1 + (-1) = len P + len H + (-1) by A5,GLIB_001:29; 
P1: now let m be odd Nat; assume B1: m <= len P;
        1 <= m & m <= len P by HEYTING3:1,B1;
        then m in dom P by FINSEQ_3:27; 
      hence J.m = P.m by GLIB_001:33;
    end;
P2: for m being odd Nat st m > len P & m <= len J holds
        m in dom J & not m in dom P
    proof let m be odd Nat such that B1: m > len P & m <= len J;
        1 <= m & m <= len J by HEYTING3:1,B1; 
        hence thesis by B1,FINSEQ_3:27;
    end;
    J.first() = P.first() & J.last() = P.first() by A5,GLIB_001:31; then
T1: J is closed by GLIB_001:def 24;
    now assume len J = 1; then
    B1: 1 + 1 = len P + len H by A5,GLIB_001:29;
        now assume C1: len P <> 1; 1 <= len P by Nat02; then 
            1 < len P by C1,REAL_1:def 5; then
            len P + len H <= len P by B1,NAT_1:38; then
            len P + len H + (-len P) <= len P + (-len P) by XREAL_1:9; then
            len H <= 0 & 0 <= len H by NAT_1:18; 
            hence contradiction by XREAL_1:1;
        end; 
        hence contradiction by A3,B1, GLIB_001:127;
    end; then
T2: J is non trivial by GLIB_001:127;
TT: rng P.edgeSeq() = P.edges() & rng H.edgeSeq() = H.edges() &
    P.edgeSeq() is one-to-one & H.edgeSeq() is one-to-one
        by GLIB_001:def 27; 
    P.edgeSeq() ^ H.edgeSeq() is one-to-one by A1,TT,FINSEQ_3:98; then
    J.edgeSeq() is one-to-one by A5,GLIB_001:86; then
T3: J is Trail-like by GLIB_001:def 27;
    now let m,n being odd Element of NAT such that B1: m < n & n <= len J;
    B2: 1 <= m & m <= len J by HEYTING3:1,B1,XREAL_1:2;
      per cases;
      suppose m <= len P & n <= len P; then
        P.m <> P.n & P.m = J.m & J.n = P.n by A2,B1,P1,GLIB_001:148;
        hence J.m = J.n implies (m = 1 & n = len J);
      end;
      suppose C1: m <= len P & n > len P;
        C2: J.m = P.m by C1,P1;
        n in dom J & not n in dom P by C1,B1,P2; then
        consider j being Element of NAT such that
        C3: j < len H & n = len P + j by GLIB_001:35;
        C4: J.n = H.(j+1) by C3,A5,GLIB_001:34;
        now assume j is odd; then reconsider j as odd Nat;
          len P + j is even;
          hence contradiction by C3;
        end; then reconsider jj=j as even Nat;
        reconsider j1=jj+1 as odd Nat;
        C5: j1 <= len H by C3,NAT_1:38;
        C5a: j1 in NAT by ORDINAL1:def 13;
        now assume D1: J.m = J.n; 
          J.m in P.vertices() & J.m in H.vertices()
               by C1,C2,C5,D1,C4,GLIB_001:88; then
          D1a: J.m in P.vertices() /\ H.vertices() by XBOOLE_0:def 3; 
          D3a: now assume E3: J.m = P.last(); 
                  j <> 0 & 0 <= j by C1,C3,NAT_1:18; then
                  0 < j by REAL_1:def 5; then
                  0+1 < j1 by XREAL_1:10; then
                  H.(2*0+1) <> H.j1 by C5a,C5,A3,GLIB_001:148;
                 hence contradiction by D1,C3,A5,GLIB_001:34,E3;
               end; then
        D3: J.m = P.first() by D1a,A4,TARSKI:def 2;
        D4: J.n = H.last() by A5,D1, D3a, D1a,A4,TARSKI:def 2;
        D5a: now assume E0: n < len J;
             E1: H.j1 = H.(len H) by C3,A5,GLIB_001:34,D4;
                j1 <> len H by E0,A9,C3; then
                j1 < len H by C5,REAL_1:def 5; 
               hence contradiction by C5a,E1,A3,GLIB_001:148;
             end; 
             now assume E0: 1 < m;
               P.m <> P.(2*0+1) by C1,E0,A2,GLIB_001:148;
               hence contradiction by C1,P1,D3;
             end;
           hence m = 1 & n = len J by D5a,B1,B2,REAL_1:def 5;
        end;             
        hence J.m = J.n implies (m = 1 & n = len J);
      end;
      suppose m > len P & n <= len P; 
        hence J.m = J.n implies (m = 1 & n = len J) by B1,XREAL_1:2;
      end;
      suppose C1: m > len P & n > len P;
        m in dom J & not m in dom P by C1,B2,P2; then          
        consider k being Element of NAT such that
      C2: k < len H & m = len P + k by GLIB_001:35;
        n in dom J & not n in dom P by C1,B1,P2; then
        consider j being Element of NAT such that
      C3: j < len H & n = len P + j by GLIB_001:35;
      C4: J.(len P + k) = H.(k+1) by C2,A5,GLIB_001:34;
      C5: J.(len P + j) = H.(j+1) by C3,A5,GLIB_001:34;
          now assume k is odd; then reconsider k as odd Nat;
            len P + k is even;
            hence contradiction by C2;
          end; then reconsider kk = k as even Nat;
          reconsider k1=kk+1 as odd Nat;
          now assume j is odd; then reconsider j as odd Nat;
            len P + j is even;
            hence contradiction by C3;
          end;
          then reconsider jj=j as even Nat;
          reconsider j1=jj+1 as odd Element of NAT by ORDINAL1:def 13;
          k < j by XREAL_1:9,C2,C3,B1; then
          C6: k1 < j1 by XREAL_1:10;
          j1 <= len H by C3,NAT_1:38; 
        hence J.m = J.n implies (m = 1 & n = len J)
          by C4,C5,C2,C3, C6,A3,GLIB_001:148;
        end;
      end;
      then J is Path-like by T3,GLIB_001:def 28;
  hence thesis by T1,T2,GLIB_001:def 31;
end;

theorem PathLike04: :: PathLike04
for G being _Graph, W1,W2 being Walk of G st W1.last() = W2.first() 
 holds W1.append(W2).length() = W1.length() + W2.length()
proof let G being _Graph, P,H being Walk of G such that
A:  H.first() = P.last();
 thus P.append(H).length() = len (P.edgeSeq() ^ H.edgeSeq()) by A, GLIB_001:86
                          .= P.length() + H.length() by FINSEQ_1:35;
end;

theorem Subgraph01: :: Subgraph01
for G being _Graph, A,B being non empty Subset of the_Vertices_of G st B c= A
for H1 being inducedSubgraph of G,A
for H2 being inducedSubgraph of H1,B
  holds H2 is inducedSubgraph of G,B
proof   let G be _Graph;
    let A,B be non empty Subset of the_Vertices_of G such that A1: B c= A;
    let H1 be inducedSubgraph of G,A;  let H2 be inducedSubgraph of H1,B;
A0c: the_Vertices_of H1 = A by GLIB_000:def 39; then
A0b:the_Vertices_of H2 = B by A1,GLIB_000:def 39; 
    the_Edges_of H2 c= the_Edges_of H1 &
    the_Edges_of H1 c= the_Edges_of G; then
A3: the_Edges_of H2 c= the_Edges_of G by XBOOLE_1:1;
    now let e be set such that B1: e in the_Edges_of H2;
        (the_Source_of H2).e = (the_Source_of H1).e &
        (the_Target_of H2).e = (the_Target_of H1).e by B1,GLIB_000:def 34;
        hence (the_Source_of H2).e = (the_Source_of G).e &
        (the_Target_of H2).e = (the_Target_of G).e by B1,GLIB_000:def 34;
    end; then
A5: H2 is Subgraph of G by A0b,A3,GLIB_000:def 34;
    H1.edgesBetween(B) c= G.edgesBetween(B) by GLIB_000:79; then
A7: the_Edges_of H2 c= G.edgesBetween(B) by A0c,A1,GLIB_000:def 39;
    now let e be set such that B1: e in G.edgesBetween(B);
    B3: (the_Source_of G).e in B &
        (the_Target_of G).e in B by B1,GLIB_000:34; then
        e in G.edgesBetween(A) by A1,B1,GLIB_000:34; then
    B4: e in the_Edges_of H1 by GLIB_000:def 39; then
        (the_Source_of H1).e = (the_Source_of G).e &
        (the_Target_of H1).e = (the_Target_of G).e by GLIB_000:def 34; then
        e in H1.edgesBetween(B) by B3,B4,GLIB_000:34;
        hence e in the_Edges_of H2 by A0c,A1,GLIB_000:def 39;
    end; then
    for x being set holds x in the_Edges_of H2 iff x in G.edgesBetween(B)
        by A7; then
    the_Edges_of H2 = G.edgesBetween(B) by TARSKI:2; 
    hence H2 is inducedSubgraph of G,B by A0b,A5,GLIB_000:def 39;
end;

theorem Subgraph01a: :: Subgraph01a
for G being _Graph, A,B being non empty Subset of the_Vertices_of G st B c= A
for H1 being inducedSubgraph of G,A
for H2 being inducedSubgraph of G,B
  holds H2 is inducedSubgraph of H1,B
proof    let G be _Graph;
    let A,B be non empty Subset of the_Vertices_of G such that
A1: B c= A;
    let H1 be inducedSubgraph of G,A;    let H2 be inducedSubgraph of G,B;
A0a: the_Vertices_of H1 = A by GLIB_000:def 39; 
A0b: the_Vertices_of H2 = B by GLIB_000:def 39;
A3a: the_Edges_of H2 = G.edgesBetween(B) by GLIB_000:def 39;
A3b: the_Edges_of H1 = G.edgesBetween(A) by GLIB_000:def 39;
A3: the_Edges_of H2 c= the_Edges_of H1 by A1,A3a,A3b,GLIB_000:39;
    now let e be set such that
    B1: e in the_Edges_of H2;
     thus (the_Source_of H2).e = (the_Source_of G).e by B1,GLIB_000:def 34
          .= (the_Source_of H1).e by  B1, A3,GLIB_000:def 34;
     thus (the_Target_of H2).e = (the_Target_of G).e by B1,GLIB_000:def 34
          .= (the_Target_of H1).e by  B1, A3,GLIB_000:def 34;
    end; then
A5: H2 is Subgraph of H1 by A1,A0a,A0b,A3,GLIB_000:def 34;
A7: H1.edgesBetween(B) c= the_Edges_of H2 by A3a, GLIB_000:79;
    now let e be set such that B1: e in the_Edges_of H2;
    D1: (the_Source_of G).e = (the_Source_of H1).e by B1, A3,GLIB_000:def 34;
    E1: (the_Target_of G).e = (the_Target_of H1).e by B1, A3,GLIB_000:def 34;
        (the_Source_of G).e in B &
        (the_Target_of G).e in B by B1,A3a,GLIB_000:34; 
     hence e in H1.edgesBetween(B) by D1,E1,B1,A3,GLIB_000:34;
    end; then
    for x being set holds x in the_Edges_of H2 iff x in H1.edgesBetween(B)
        by A7; then
    the_Edges_of H2 = H1.edgesBetween(B) by TARSKI:2; 
    hence H2 is inducedSubgraph of H1,B by A1,A0a,A0b,A5,GLIB_000:def 39;
end;

theorem Subgraph02: :: Subgraph02
for G being _Graph, S,T being non empty Subset of the_Vertices_of G st T c= S
for G2 being inducedSubgraph of G,S
  holds G2.edgesBetween(T) = G.edgesBetween(T)
proof let G be _Graph;
    let S,T be non empty Subset of the_Vertices_of G such that
A1: T c= S;
    let G2 be inducedSubgraph of G,S;
A2: the_Vertices_of G2 = S &
    the_Edges_of G2 = G.edgesBetween(S) by GLIB_000:def 39;
    now let e be set;
        hereby assume B0: e in G.edgesBetween(T);
    B1a: G.edgesBetween(T) c= G.edgesBetween(S) by A1, GLIB_000:39; 
    B2: e in the_Edges_of G & (the_Source_of G).e in T &
        (the_Target_of G).e in T by B0,GLIB_000:34; 
        (the_Source_of G2).e = (the_Source_of G).e &
       (the_Target_of G2).e = (the_Target_of G).e by A2,B0,B1a,GLIB_000:def 34;
        hence e in G2.edgesBetween(T) by B1a, A2, B0, B2, GLIB_000:34; end;
        assume e in G2.edgesBetween(T); then
    B1: e in the_Edges_of G2 & (the_Source_of G2).e in T &
        (the_Target_of G2).e in T by GLIB_000:34;
    B2: (the_Source_of G).e in T &(the_Target_of G).e in T
                  by B1, GLIB_000:def 34;
     thus e in G.edgesBetween(T) by B1, B2,GLIB_000:34;
    end; 
    hence thesis by TARSKI:2;
end;

:: we do not consider infinite graphs
scheme FinGraphOrderCompInd{P[set]}: 
    for G being finite _Graph holds P[G]
    provided
A1: for k being non zero natural number st
    (for Gk being finite _Graph st Gk.order() < k holds P[Gk]) holds
    (for Gk1 being finite _Graph st Gk1.order() = k holds P[Gk1])
proof
    defpred pP[non zero Nat] means
        for Gk being finite _Graph st Gk.order() < $1 holds P[Gk];
A2: pP[1] by NAT_1:39;
A3: for n being non zero Element of NAT holds pP[n] implies pP[n+1] proof
        let n be non zero Element of NAT such that B1: pP[n];
        now let Gk be finite _Graph such that C1: Gk.order() < n+1;
            Gk.order() <= n by C1,NAT_1:38; then
            Gk.order() < n or Gk.order() = n by REAL_1:def 5;
            hence P[Gk] by A1, B1;            
        end; 
        hence pP[n+1];
    end;
A4: for k being non zero Element of NAT holds pP[k]
    from BINARITH:sch 1(A2,A3);
    let G be finite _Graph;
    for Gk being finite _Graph st Gk.order()<G.order() holds P[Gk] by A4; 
    hence thesis by A1;
end;

:: should be in GLIBs
theorem PDistinct: :: PDistinct
for G being _Graph, W being Walk of G 
 st W is open & W is Path-like holds W is vertex-distinct
proof let G be _Graph, W be Walk of G;
  assume A1: W is open & W is Path-like;
  now let m,n be odd Element of NAT such that
A2: m <= len W & n <= len W & W.m = W.n;
    assume A3: m <> n;
    per cases by A3,REAL_1:def 5;
    suppose m < n; then
      W.m = W.first() & W.n = W.last() by A1,A2,GLIB_001:def 28;
    hence contradiction by A1,A2,GLIB_001:def 24; end;
    suppose m > n; then
      W.m = W.last() & W.n = W.first() by A1,A2,GLIB_001:def 28;
    hence contradiction by A1,A2,GLIB_001:def 24; end;
  end; 
  hence W is vertex-distinct by GLIB_001:def 29;
end;

:: should be in GLIB
theorem PathLike15:  :: PathLike15 
for G being _Graph, P being Path of G st P is open & len P > 3
for e being set
 st e Joins P.last(),P.first(),G holds P.addEdge(e) is Cycle-like
proof let G be _Graph, W be Path of G such that
A1: W is open and
A2: len W > 3;
    let e be set such that
A3: e Joins W.last(),W.first(),G;
    set P = W.addEdge(e);
A4: P.first() = W.first() & P.last() = W.first() by A3,GLIB_001:64; then
P1: P is closed by GLIB_001:def 24;
A6: len P = len W + 2*1 by A3,GLIB_001:65;
A8: e in W.last().edgesInOut() by A3,GLIB_000:65;
    now assume e in W.edges(); then
        consider v1,v2 being Vertex of G, n being odd Element of NAT such that
    B1: n+2 <= len W & v1 = W.n & e = W.(n+1) & v2 = W.(n+2) and
    B2: e Joins v1,v2,G by GLIB_001:104;
    B3: n < len W by B1,XREAL_1:41;
      per cases by B2,A3,GLIB_000:18;
      suppose C0: v1 = W.first() & v2 = W.last(); 
        now assume 1 <> n; then 1 <= n & 1 <> n by Nat02; then
          2*0+1 < n by REAL_1:def 5;
          hence contradiction by A1,B3,C0,B1,GLIB_001:148;
        end; 
        hence contradiction by C0,B1,A1,A2,GLIB_001:148; end;
      suppose v1 = W.last() & v2 = W.first(); 
        hence contradiction by A1,B1,B3,GLIB_001:148; end;
    end; then
A5: P is Trail-like by A8,GLIB_001:143;
A7: now let m,n be odd Element of NAT such that B1: m < n & n <= len P;
        assume B2: P.m = P.n;
    B9: 1 <= m by Nat02;
        m < len W + 2*1 by A6,B1,XREAL_1:2; then
    B7: m <= len W + 2 - 2 by EvenOdd02; then
    B6: m in dom W by B9,FINSEQ_3:27; then
    B8: W.m = P.m by A3,GLIB_001:66;
    B3a: now assume n < len P; then
            n < len W + 2*1 by A3,GLIB_001:65; then
        C2: n <= len W + 2 - 2 by EvenOdd02; then
        C1: W.n <> W.m by B1,A1,GLIB_001:148;
            1 <= n by Nat02; then
            n in dom W by C2,FINSEQ_3:27; 
          hence contradiction by B8,B2,C1,A3,GLIB_001:66;
        end; then
    B4: P.n = W.1 by A4,B1,XREAL_1:1;
        now assume m <> 1; then m <> 1 & 1 <= m by Nat02; then
            2*0+1 < m by REAL_1:def 5; then
        C2: W.1 <> W.m by A1,B7,GLIB_001:148;
          thus contradiction by B2,A3,C2,B4,B6,GLIB_001:66;
        end;
      hence m = 1 & n = len P by B3a, B1,XREAL_1:1;
    end;
P2: P is Path-like by A5,A7,GLIB_001:def 28;
P3: P is non trivial by A3,GLIB_001:133;
  thus P is Cycle-like by P1,P2,P3,GLIB_001:def 31;
end;

begin :: Shortest topological path 

definition let G be _Graph, W be Walk of G;
  attr W is minlength means       :DefMinTop:
    for W2 being Walk of G st W2 is_Walk_from W.first(),W.last()
      holds len W2 >= len W;
end;

theorem WalkSubwalk00: :: WalkSubwalk00
for G being _Graph, W being Walk of G, S being Subwalk of W
 st S.first() = W.first() & S.edgeSeq() = W.edgeSeq() holds S = W
proof
    let G be _Graph, W be Walk of G, S be Subwalk of W such that
A0: S.first() = W.first() and
A1: S.edgeSeq() = W.edgeSeq();
    len S = 2*len W.edgeSeq() + 1 by A1,GLIB_001:def 15; then
P1: len S = len W by GLIB_001:def 15; 
    defpred P[Nat] means $1 in dom S implies S.$1 = W.$1;
I1: now let k be Element of NAT such that
    B0: for n being Element of NAT st n < k holds P[n];
        per cases;
        suppose k in dom S; then
        B2: 1 <= k & k <= len S by FINSEQ_3:27;
          per cases;
          suppose C0: k is even; then
              S.k = S.edgeSeq().(k div 2) by B2,GLIB_001:78;
              hence P[k] by A1,B2,P1,C0,GLIB_001:78; end;
          suppose k is odd; then
            reconsider kk=k as odd Nat;
            per cases by B2,REAL_1:def 5;
            suppose k = 1; 
              hence P[k] by A0; end;
            suppose k > 2*0+1; then
            D0: 1+2 <= kk by EvenOdd03; then
                0<=2 & 3+-1 <= k+-1 by XREAL_1:9; then
                0<=k-1 by XREAL_1:2; then
                reconsider k1=k-1 as Element of NAT by INT_1:16;
                0<=1 & 3+-2 <= k+-2 by D0,XREAL_1:9; then
                0 <= k-2 by XREAL_1:2; then
                reconsider k2=kk-2*1 as odd Element of NAT by INT_1:16;
                3+-1 <= k+-1 by D0,XREAL_1:9; then
            E2: 1 <= k1 & k1 < k by XREAL_1:2,XREAL_1:46; then
                k1 <= len S by B2,XREAL_1:2; then
            D1: k1 in dom S by FINSEQ_3:27,E2;
            D2: S.k1 = W.k1 by B0,D1,E2;
            E3a: 3+-2 <= k+-2 by D0,XREAL_1:9; then
            E3: 1 <= k2 & k2 < k by XREAL_1:46; then
                k2 <= len S by B2,XREAL_1:2; then
            D3: k2 in dom S by FINSEQ_3:27,E3a;
            D5: S.k2 = W.k2 by B0,D3,E3;
            E0: k2 < len S & k2 < len W by P1,E3,B2,XREAL_1:2;
                S.(k2+1) Joins S.k2,S.(k2+2),G &
                W.(k2+1) Joins W.k2,W.(k2+2),G by E0,GLIB_001:def 3; then
                (S.k2 = S.k2 & S.k = W.k) or
                (S.k2 = W.k & S.k = S.k2) by D2,D5,GLIB_000:18;
              hence P[k]; end;
          end; end;       
        suppose not k in dom S; hence P[k]; end;
    end;
I2: for n being Element of NAT holds P[n] from NAT_1:sch 4(I1); 
    now let k be Element of NAT such that B0: 1 <= k & k <= len S;
        k in dom S by B0,FINSEQ_3:27; 
        hence S.k = W.k by I2; 
    end;
    hence S = W by P1,FINSEQ_1:18;
end;

theorem LenSubwalk00: :: LenSubwalk00
for G being _Graph, W being Walk of G, S being Subwalk of W
 st len S = len W holds S = W
proof let G be _Graph, W be Walk of G, S be Subwalk of W such that
A: len S = len W;
   consider es being FinSubsequence of W.edgeSeq() such that
B: S.edgeSeq() = Seq es by GLIB_001:def 32;
C: len S = 2*len S.edgeSeq() +1 by GLIB_001:def 15;
D: len W = 2*len W.edgeSeq() +1 by GLIB_001:def 15;
E: S.edgeSeq() = W.edgeSeq() by A, C, D, B, FinSubseq00;
   S.first() = W.first() by GLIB_001:162;
  hence S = W by E, WalkSubwalk00;
end;

theorem 
for G being _Graph, W being Walk of G st W is minlength holds W is Path-like
proof let G be _Graph, W be Walk of G such that
A: W is minlength and
B: not W is Path-like;
   consider s being Path-like Subwalk of W;
C: s is_Walk_from W.first(),W.last() by GLIB_001:def 32;
   len s <= len W & len W <= len s by GLIB_001:163, A, C, DefMinTop; then
   len s = len W by XREAL_1:1; 
 hence contradiction by B, LenSubwalk00;
end;

theorem 
for G being _Graph, W being Walk of G st W is minlength holds W is Path-like
proof let G be _Graph, W be Walk of G such that
A1: W is minlength;
    assume not W is Path-like; then
    consider m,n be odd Element of NAT such that
A2: m <= len W & n <= len W and
A3: W.m = W.n and
A4: m <> n by GLIB_001:147;  :: can we do this only once? :-/
    per cases by A4,REAL_1:def 5;
    suppose B0: m < n;
        set R = W.cut(1,m), S = W.cut(n,len W);
    B9: 2*0+1 <= m by HEYTING3:1; then
    B1: R.first() = W.(2*0+1) & R.last() = W.m by A2,GLIB_001:38;
    B2: S.first() = W.m & S.last() = W.(len W) by A2,A3,GLIB_001:38;
    B3a: len R + 1 - 1 = m + 1 - 1 by B9,A2,GLIB_001:37; 
    B4a: len S + n - n = len W + 1 - n by A2,GLIB_001:37; 
        set P = R.append(S);
    B5: P is_Walk_from W.first(),W.last() by B1,B2,GLIB_001:31;
        len P + 1 = len R + len S by B1,B2,GLIB_001:29; then
        len P = len W - n + m by B3a, B4a; then
        len P < len W - n + n by B0,XREAL_1:10; 
      hence contradiction by B5,A1,DefMinTop; end;
    suppose B0: n < m;
        set R = W.cut(1,n), S = W.cut(m,len W);
    B9: 2*0+1 <= n by HEYTING3:1; then
    B1: R.first() = W.(2*0+1) & R.last() = W.n by A2,GLIB_001:38;
    B2: S.first() = W.n & S.last() = W.(len W) by A2,A3,GLIB_001:38;
    B3a: len R + 1 - 1 = n + 1 - 1 by B9,A2,GLIB_001:37; 
    B4a: len S + m - m = len W + 1 - m by A2,GLIB_001:37; 
        set P = R.append(S);
    B5: P is_Walk_from W.first(),W.last() by B1,B2,GLIB_001:31; 
        len P + 1 = len R + len S by B1,B2,GLIB_001:29; then
        len P = len W - m + n by B3a,B4a; then
        len P < len W - m + m by B0,XREAL_1:10; 
      hence contradiction by B5,A1,DefMinTop; end;
end;

theorem TopPath01: :: TopPath01
for G being _Graph, W being Walk of G
 holds (for P being Path of G
         st P is_Walk_from W.first(),W.last() holds len P >= len W)
       implies W is minlength 
proof    let G be _Graph, W be Walk of G;
    assume A1: for P2 being Path of G st P2 is_Walk_from W.first(),W.last()
                   holds len P2 >= len W;
    now let V be Walk of G such that B1: V is_Walk_from W.first(),W.last();
    B2: V.first() = W.first() & V.last() = W.last() by B1,GLIB_001:def 23;
        consider P3 being Path-like Subwalk of V;
        P3.first()=W.first() & P3.last()=W.last() by B2,GLIB_001:162; then
        P3 is_Walk_from W.first(),W.last() by GLIB_001:def 23; then
        len W <= len P3 & len P3 <= len V by A1,GLIB_001:163;
        hence len V >= len W by XREAL_1:2;
    end;
    hence W is minlength by DefMinTop;
end;

theorem TopPath02: :: TopPath02
for G being _Graph, W being Walk of G 
  ex P being Path of G st P is_Walk_from W.first(),W.last() & P is minlength
proof let G being _Graph, W being Walk of G;
    set X = { len P where P is Path of G : P is_Walk_from W.first(),W.last() };
    consider T being Path-like Subwalk of W;
    T.first() = W.first() & T.last() = W.last() by GLIB_001:162; then
    T is_Walk_from W.first(),W.last() by GLIB_001:def 23; then
B5: len T in X;
    X c= NAT proof let x be set; assume x in X; then
       ex P being Path of G st x = len P & P is_Walk_from W.first(),W.last();
      hence x in NAT;
    end; then
    reconsider X as non empty Subset of NAT by B5;
    min X in X by CQC_SIM1:def 8; then
    consider P being Path of G such that
A: len P = min X and
B: P is_Walk_from W.first(),W.last();
   take  P;
   thus P is_Walk_from W.first(),W.last() by B;
   let W2 be Walk of G such that
B1: W2 is_Walk_from P.first(),P.last();
    consider T being Path-like Subwalk of W2;
B2: len T <= len W2 by GLIB_001:163;
B3: P.first() = W2.first() & P.last() = W2.last() by  B1, GLIB_001:def 23;
B4: P.first() = W.first() & P.last() = W.last() by  B, GLIB_001:def 23; 
    T.first() = W2.first() & T.last() = W2.last() by GLIB_001:162; then
    T is_Walk_from W.first(),W.last() by B3,B4, GLIB_001:def 23; then
    len T in X; then
    len P <= len T by A, CQC_SIM1:def 8;
  hence len P <= len W2 by B2, XREAL_1:2;
end;

theorem TopPath03: :: TopPath03
for G being _Graph, W being Walk of G st W is minlength
 holds for m,n being odd natural number st m+2 < n & n <= len W
        holds not ex e being set st e Joins W.m,W.n,G
proof
    let G be _Graph;
    let P be Walk of G such that A1: P is minlength;
    let m,n be odd Nat such that A2: m+2 < n & n <= len P;
    let e be set such that A3: e Joins P.m,P.n,G;
    set P1 = P.cut(1,m);        set P2 = P1.addEdge(e);
    set P3 = P.cut(n,len P);    set P4 = P2.append(P3);
A0: m in NAT & n in NAT by ORDINAL1:def 13;
    2*0 <= m & m+0 <= m+2 by XREAL_1:9,NAT_1:18; then
    0 < m & m <= n by A2,REAL_1:def 5,XREAL_1:2; then
AA: 2*0+1 <= m & m <= len P by A2,XREAL_1:2,HEYTING3:1; then
Z1: P1.first() = P.1 & P1.last() = P.m by A0, GLIB_001:38;
A4: P1.first() = P.first() & P1.last() = P.m by AA,A0,GLIB_001:38;
A5a: len P1 + 1 = m + 1 by A0, AA,GLIB_001:37; 
B1: P2.first() = P.first() & P2.last() = P.n by A3,A4,GLIB_001:64; 
B2: len P2 = m + 2 by Z1,A3,A5a,GLIB_001:65;
Z2: P3.first() = P.n & P3.last() = P.(len P) by A0, A2,GLIB_001:38; 
C1: P3.first() = P.n & P3.last() = P.last() by A0,A2,GLIB_001:38;
C3a: len P3 + n = len P+1 by A0, A2,GLIB_001:37; 
T1: P4 is_Walk_from P.first(),P.last() by B1,C1,GLIB_001:31;
T2a: len P4 + 1 = len P2 + len P3 by B1,Z2,GLIB_001:29; 
    len P - n + (m + 2) < len P - n + n by A2,XREAL_1:10; 
    hence contradiction by A1,T1,T2a, B2, C3a, DefMinTop;
end;

theorem TopPath04: :: TopPath04
for G being _Graph, S being non empty Subset of the_Vertices_of G
for H being inducedSubgraph of G,S
for W being Walk of H st W is minlength
for m,n being odd natural number st m+2 < n & n <= len W
 holds not ex e being set st e Joins W.m,W.n,G
proof
    let G be _Graph, S be non empty Subset of the_Vertices_of G;
    let GA be inducedSubgraph of G,S;  let P be Walk of GA;
    assume A1: P is minlength;
B1: S = the_Vertices_of GA by GLIB_000:def 39;
    now let m,n be odd Nat such that
      A2: m+2 < n & n <= len P;
      A2a: m in NAT & n in NAT by ORDINAL1:def 13;
        let e be set such that
      A3: e Joins P.m,P.n,G;
        m + 0 <= m + 2 by XREAL_1:9; then
        m <= n by A2,XREAL_1:2; then
        m <= len P by A2,XREAL_1:2; then
        P.m in the_Vertices_of GA & P.n in the_Vertices_of GA
           by A2a,A2,GLIB_001:8;
        then e Joins P.m,P.n,GA by B1,A3,Joins01;
     hence contradiction by A1,A2,TopPath03;
    end;
    hence thesis;
end;

theorem TopPath05: :: TopPath05
for G being _Graph for W being Walk of G st W is minlength
for m,n being odd natural number st m<=n & n<=len W
  holds W.cut(m,n) is minlength
proof
    let G be _Graph, W be Walk of G such that
A0: W is minlength;
    let m,n be odd Nat such that
A1: m <= n & n <= len W;
A2: 2*0+1 <= m & 1 <= n & m <= len W by A1,HEYTING3:1,XREAL_1:2;
    set R = W.cut(1,m);     set S = W.cut(m,n);     set T = W.cut(n,len W);
AA: m in NAT & n in NAT by ORDINAL1:def 13;
R0: R.first() = W.1 by AA,A2,GLIB_001:38;
R1: R.last() = W.m by AA,A2,GLIB_001:38;
R2a: len R + 1 = m + 1 by AA,A2,GLIB_001:37; 
S0: S.first() = W.m by AA,A1,GLIB_001:38;
S1: S.last() = W.n by AA,A1,GLIB_001:38;
S2a: len S + m = n + 1 by AA,A1,GLIB_001:37; 
T0: T.first() = W.n by AA,A1,GLIB_001:38;
T1: T.last() = W.(len W) by AA,A1,GLIB_001:38;
T2a: len T + n = len W + 1 by AA,A1,GLIB_001:37; 
    assume not S is minlength; then
    consider M being Walk of G such that
M0: M is_Walk_from S.first(),S.last() and
M1: len M < len S by DefMinTop;
M2: M.first() = W.m by M0,S0,GLIB_001:def 23;
M3: M.last() = W.n by M0,S1,GLIB_001:def 23;
    set A = R.append(M);
A3: A.first() = W.1 by R0,R1,M2,GLIB_001:31;
A4: A.last() = W.n by R1,M2,M3,GLIB_001:31;
    len A + 1 = len R + len M by R1,M2,GLIB_001:29; then
    len A + 1 < len R + len S by M1,XREAL_1:10; then
A5a: len A + 1 - 1 < n + 1 - 1 by R2a,S2a,XREAL_1:16; 
    set B = A.append(T);
B0: B.first() = W.first() by A3,A4,T0,GLIB_001:31;
B1: B.last() = W.last()  by A4,T0,T1,GLIB_001:31;
    len B + 1 = len A + len T by A4,T0,GLIB_001:29; then
    len B + 1 < len T + n by A5a,XREAL_1:10; then
B2a: len B + 1 - 1 < len W + 1 - 1 by T2a,XREAL_1:16; 
    B is_Walk_from W.first(),W.last() by B0,B1,GLIB_001:def 23;  
    hence contradiction by A0,B2a,DefMinTop;
end;

theorem 
for G being _Graph st G is connected
for A,B being non empty Subset of the_Vertices_of G st A misses B holds
  ex P being Path of G st P is minlength & P is non trivial & 
  P.first() in A & P.last() in B &
  for n being odd natural number st 1 < n & n < len P
    holds not P.n in A & not P.n in B
proof
    let G be _Graph such that A1: G is connected;
    let A,B be non empty Subset of the_Vertices_of G such that A2: A misses B;
    set X = { len P where P is Path of G : P.first() in A & P.last() in B };
    consider a being set such that Z0: a in A by XBOOLE_0:def 1;
    reconsider a as Vertex of G by Z0;
    consider b being set such that Z1: b in B by XBOOLE_0:def 1;
    reconsider b as Vertex of G by Z1;
    consider W being Walk of G such that Z2: W is_Walk_from a,b
        by A1,GLIB_002:def 1; 
    consider W2 being Path of G such that
Z3: W2 is_Walk_from W.first(),W.last() &
    W2 is minlength by TopPath02;
    W.first() = a & W.last() = b by Z2,GLIB_001:def 23; then
    W2.first() in A & W2.last() in B by Z0,Z1,Z3,GLIB_001:def 23; then
A3a: len W2 in X; 
    X c= NAT proof let x be set; assume x in X; then
       ex P being Path of G st x = len P & P.first() in A & P.last() in B;
      hence x in NAT;
    end; then
    reconsider X as non empty Subset of NAT by A3a;
    min X in X by CQC_SIM1:def 8; then
    consider M being Path of G such that
A5: len M = min X & M.first() in A & M.last() in B;

    now assume M.first() = M.last(); then
         M.first() in A /\ B by A5, XBOOLE_0:def 3; 
         hence contradiction by A2,XBOOLE_0:def 7;
    end; then
A6: M is non trivial by GLIB_001:128;
    now let P2 be Path of G such that B1: P2 is_Walk_from M.first(),M.last();
        P2.first() in A & P2.last() in B by A5, B1,GLIB_001:def 23;
        then len P2 in X;  
        hence len P2 >= len M by A5,CQC_SIM1:def 8;
    end; then
A8: M is minlength by TopPath01;
    now let n be odd Nat such that B0: 1 < n & n < len M;
        assume B1: M.n in A or M.n in B;
         reconsider nn = n as Element of NAT by ORDINAL1:def 13;
        per cases by B1;
        suppose C1: M.n in A;
            reconsider T = M.cut(nn,len M) as Path of G;
            T.first() in A & T.last() in B by A5, C1,B0,GLIB_001:38;  then
        D3a: len T in X; 
        C3a: len T + nn = len M+1 by B0,GLIB_001:37; 
            len T + 0 < len M + 1 + (-n) + (n + (-1)) by B0, C3a,XREAL_1:10; 
            hence contradiction by D3a, A5, CQC_SIM1:def 8; end;

        suppose C1: M.n in B;
            reconsider T = M.cut(1,nn) as Path of G;
            2*0+1 <= n & n <= len M by B0; then
            T.first() = M.1 & T.last() = M.nn by GLIB_001:38; then
        D3a: len T in X by A5,C1; 
            2*0+1 <= n & n <= len M by B0; then
            len T + 1 = nn + 1 by GLIB_001:37; 
            hence contradiction by D3a, B0, A5, CQC_SIM1:def 8; end;
    end;
    hence thesis by A6,A5,A8;
end;

begin :: Adjacency and complete graphs

definition let G be _Graph, a,b be Vertex of G;
  pred a,b are_adjacent means               :DefAdjacent: :: DefAdjacent
    ex e being set st e Joins a,b,G;
  symmetry proof
     let a,b be Vertex of G;
     assume ex e being set st e Joins a,b,G; then
     consider e being set such that A1: e Joins a,b,G;
     e Joins b,a,G by A1,GLIB_000:17; 
     hence ex e being set st e Joins b,a,G;
  end;
end;

theorem VAdjacent00: :: VAdjacent00
for G1,G2 being _Graph st G1 == G2
for u1,v1 being Vertex of G1 st u1,v1 are_adjacent
for u2,v2 being Vertex of G2 st u1=u2 & v1=v2 holds u2,v2 are_adjacent
proof let G1,G2 be _Graph such that A1: G1 == G2;
    let u1,v1 be Vertex of G1 such that A2: u1,v1 are_adjacent;
    let u2,v2 be Vertex of G2 such that A3: u1=u2 & v1=v2;
    consider e being set such that
A4: e Joins u1,v1,G1 by A2,DefAdjacent;
    e Joins u2,v2,G2 by A3, A4, A1,GLIB_000:91;
    hence thesis by DefAdjacent;
end;

theorem VAdjacent01: :: VAdjacent01
for G being _Graph, S being non empty Subset of the_Vertices_of G
for H being inducedSubgraph of G,S
for u, v being Vertex of G, t, w being Vertex of H
  st u = t & v = w holds u,v are_adjacent iff t,w are_adjacent
proof let G be _Graph, S be non empty Subset of the_Vertices_of G;
 let H be inducedSubgraph of G,S;
 let u, v be Vertex of G, t, w be Vertex of H such that
A: u = t & v = w;
B: S = the_Vertices_of H by GLIB_000:def 39;
    hereby assume u,v are_adjacent; then consider e being set such that
    A1: e Joins u,v,G by DefAdjacent;
        e Joins t,w,H by A, A1, B, Joins01;
      hence t,w are_adjacent by DefAdjacent;
    end;
    assume t,w are_adjacent; then consider e being set such that
    A1: e Joins t,w,H by DefAdjacent;
        e Joins u,v,G by A1, A, GLIB_000:75;
    hence u,v are_adjacent by DefAdjacent;
end;

theorem PathLike05: :: PathLike05
for G being _Graph, W being Walk of G
 st W.first() <> W.last() & not W.first(),W.last() are_adjacent
  holds W.length() >= 2
proof let G be _Graph, W be Walk of G such that
A: W.first() <> W.last() and
B: not W.first(),W.last() are_adjacent;
   set l = W.length();
   assume l < 2; then l < 1+1; then
C: l <= 1 by NAT_1:38; 
   per cases by C, CQC_THE1:2;
   suppose l = 0; then W is trivial by GLIB_001:def 26;
    hence contradiction by A, GLIB_001:128;
   end;
   suppose l = 1; then
   D1: len W = 2*1+1 by GLIB_001:113 .= 3;
       1 = 2*0+1; then 
   A1: W.(1+1) Joins W.1,W.(1+2),G by D1, GLIB_001:def 3;
       reconsider W1 = W.1 as Vertex of G by GLIB_001:def 3;
       reconsider WlW = W.len W as Vertex of G by GLIB_001:8; 
    thus contradiction by B, A1, D1,DefAdjacent;
   end;
end;

theorem PathBuilder00: :: PathBuilder00
:: add sequences of vertices and edges
for G being _Graph, v1,v2,v3 being Vertex of G st
    v1<>v2 & v1<>v3 & v2<>v3 & v1,v2 are_adjacent & v2,v3 are_adjacent       
  ex P being Path of G, e1,e2 being set st
     P is open & len P = 5 & P.length() = 2 & 
     e1 Joins v1,v2,G & e2 Joins v2,v3,G & P.edges() = {e1,e2} & 
     P.vertices() = {v1,v2,v3} & P.1 = v1 & P.3 = v2 & P.5 = v3 
proof let G be _Graph;
    let v1,v2,v3 be Vertex of G such that
A0: v1 <> v2 & v1 <> v3 and
A1: v2 <> v3 and
A2: v1,v2 are_adjacent and
A3: v2,v3 are_adjacent;
    consider e1 being set such that
A4: e1 Joins v1,v2,G by A2,DefAdjacent;
    consider e2 being set such that
A5: e2 Joins v2,v3,G by A3,DefAdjacent;
    set P1 = G.walkOf(v1,e1,v2);
A6: P1.first() = v1 by A4,GLIB_001:16;
A7: P1.last() = v2 by A4,GLIB_001:16;
A8: len P1 = 3 by A4,GLIB_001:15;
A9: P1.vertices() = {v1,v2} by A4,GLIB_001:92;
B0: P1 is open by A6,A7,A0,GLIB_001:def 24;
    set P = P1.addEdge(e2);
B1: P.first() = v1 by A6,A7,A5,GLIB_001:64;
B2: P.last() = v3 by A7,A5,GLIB_001:64;
    not v3 in P1.vertices() by A9,A0,A1,TARSKI:def 2;
    then reconsider P as Path of G by A7,A5,B0,GLIB_001:152;
    take P,e1,e2;
    thus P is open by B1,B2,A0,GLIB_001:def 24;
B3: len P = 3 + 2 by A5,A7,A8,GLIB_001:65;
    hence len P = 5; 
    5 = 2*P.length() + 1 by B3,GLIB_001:113; 
    hence P.length() = 2;
    thus e1 Joins v1,v2,G by A4;
    thus e2 Joins v2,v3,G by A5;
    P1.edges() = {e1} by A4,GLIB_001:109; then
    P.edges() = {e1} \/ {e2} by A7,A5,GLIB_001:112;
    hence P.edges() = {e1,e2} by ENUMSET1:41;
    P.vertices() = {v1,v2} \/ {v3} by A5,A7,A9,GLIB_001:96; 
    hence P.vertices() = {v1,v2,v3} by ENUMSET1:43;
    thus P.1 = v1 by B1;
    3 in dom P1 by A8,FINSEQ_3:27; 
    hence P.3 = P1.3 by A5,A7,GLIB_001:66
             .= v2 by A7,A4,GLIB_001:15;
    thus P.5 = v3 by B3,B2;
end;
  
theorem PathBuilder01:  :: PathBuilder01
for G being _Graph, v1,v2,v3,v4 being Vertex of G st
  v1<>v2 & v1<>v3 & v2<>v3 & v2<>v4 & v3<>v4 &
  v1,v2 are_adjacent & v2,v3 are_adjacent & v3,v4 are_adjacent
 ex P being Path of G st len P = 7 & P.length() = 3 & 
     P.vertices() = {v1,v2,v3,v4} & P.1 = v1 & P.3 = v2 & P.5 = v3 & P.7 = v4
proof
    let G be _Graph, v1,v2,v3,v4 be Vertex of G such that
A0: v1<>v2 & v1<>v3 & v2<>v3 & v2<>v4 & v3<>v4 and
A1: v1,v2 are_adjacent & v2,v3 are_adjacent & v3,v4 are_adjacent;
    consider e3 being set such that
A4: e3 Joins v3,v4,G by A1,DefAdjacent;
    consider R being Path of G,e1,e2 being set such that
B0: R is open and
B1: len R = 5 & R.length() = 2 and
B9: e1 Joins v1,v2,G & e2 Joins v2,v3,G & R.edges() = {e1,e2} and 
B2: R.vertices() = {v1,v2,v3} and
B3: R.1 = v1 & R.3 = v2 & R.5 = v3 by A0,A1,PathBuilder00;

B6: e1 <> e3 by A0,B9,A4,GLIB_000:18;
B7: e2 <> e3 by A0,B9,A4,GLIB_000:18;
B8: not e3 in R.edges() by B9,B6,B7,TARSKI:def 2;
B9: for n being odd Element of NAT st 1 < n & n <= len R holds R.n <> v4
    proof let n be odd Element of NAT such that
    C0: 1 < n and C1: n <= len R;
    C2: n <= 6 by B1, C1, XREAL_1:2; 
        per cases by C2, C0, Odd102; 
        suppose n = 3; hence R.n <> v4 by B3,A0; end;
        suppose n = 5; hence R.n <> v4 by B3,A0; end;
    end;
    set P = R.addEdge(e3);
    reconsider P as Path of G by B1,B3,A4,B8,B0,B9,GLIB_001:151;
    take P;
    C0a: len P = 5 + 2 by B1,B3,A4,GLIB_001:65;
    hence len P = 7; 
    7 = 2*P.length() + 1 by C0a, GLIB_001:113; 
    hence P.length() = 3;
    P.vertices() = {v1,v2,v3} \/ {v4} by B2,B1,B3,A4,GLIB_001:96; 
    hence P.vertices() = {v1,v2,v3,v4} by ENUMSET1:46;
    1 in dom R by B1,FINSEQ_3:27; 
    hence P.1 = v1 by B3,B1,A4,GLIB_001:66;
    3 in dom R by B1,FINSEQ_3:27;
    hence P.3 = v2 by B3,B1,A4,GLIB_001:66;
    5 in dom R by B1,FINSEQ_3:27;
    hence P.5 = v3 by B3,B1,A4,GLIB_001:66;
    P.last() = v4 by B1,B3,A4,GLIB_001:64;
    hence P.7 = v4 by C0a;
end;

definition let G be _Graph, S be set;
  func G.AdjacentSet(S) -> Subset of the_Vertices_of G equals
      {u where u is Vertex of G :
         not u in S & ex v being Vertex of G st (v in S & u,v are_adjacent)};
  coherence proof 
  set X = {u where u is Vertex of G :
           not u in S & ex v being Vertex of G st (v in S & u,v are_adjacent)};
      now let x be set such that A1: x in X; 
          consider u being Vertex of G such that A2: u=x and
          not u in S & ex v being Vertex of G st (v in S & u,v are_adjacent)
              by A1;
          thus x in the_Vertices_of G by A2;
      end; 
      hence thesis by TARSKI:def 3;
  end;
end;

theorem 
for G being _Graph, S, x being set st x in G.AdjacentSet(S) holds not x in S
proof let G be _Graph, S,x be set;
   assume x in G.AdjacentSet(S); then
   consider t being Vertex of G such that
B: t=x & not t in S & ex v being Vertex of G st (v in S & t,v are_adjacent);
  thus not x in S by B;
end;

theorem Adjacent00: :: Adjacent00
for G being _Graph, S being set
for u being Vertex of G
 holds u in G.AdjacentSet(S) iff
       not u in S & ex v being Vertex of G st (v in S & u,v are_adjacent)
proof
    let G be _Graph, S be set;
    let u be Vertex of G;
    hereby assume u in G.AdjacentSet(S); then
        consider t being Vertex of G such that A2: u=t and
    A3: not t in S & ex v being Vertex of G st
            (v in S & t,v are_adjacent);
        thus not u in S & ex v being Vertex of G st
            (v in S & u,v are_adjacent) by A2,A3;
    end;
    assume not u in S & ex v being Vertex of G st (v in S & u,v are_adjacent);
    hence u in G.AdjacentSet(S);
end;

theorem Adjacent01: :: Adjacent01
for G1,G2 being _Graph st G1 == G2 for S being set
 holds G1.AdjacentSet(S) = G2.AdjacentSet(S)
proof let G1,G2 be _Graph such that A: G1 == G2; let S be set;
C: now let x be set such that B1: x in G1.AdjacentSet(S);
      reconsider t1 = x as Vertex of G1 by B1;
  B2: not t1 in S & ex v being Vertex of G1 st (v in S&t1,v are_adjacent)
         by B1,Adjacent00;
      consider v1 being Vertex of G1 such that
  B3: v1 in S & t1,v1 are_adjacent by B1, Adjacent00;
      reconsider t2 = t1, v2 = v1 as Vertex of G2 by A, GLIB_000:def 36;
      t2,v2 are_adjacent by A,B3,VAdjacent00;
    hence x in G2.AdjacentSet(S) by B2,B3;
   end;
   now let x be set such that B1: x in G2.AdjacentSet(S);
      reconsider t2 = x as Vertex of G2 by B1;
  B2: not t2 in S & ex v being Vertex of G2 st (v in S&t2,v are_adjacent)
         by B1,Adjacent00;
      consider v2 being Vertex of G2 such that
  B3: v2 in S & t2,v2 are_adjacent by B1, Adjacent00;
      reconsider t1 = t2, v1 = v2 as Vertex of G1 by A,GLIB_000:def 36;
      t1,v1 are_adjacent by A,B3,VAdjacent00;
     hence x in G1.AdjacentSet(S) by B2,B3;
   end; 
  hence G1.AdjacentSet(S) = G2.AdjacentSet(S) by C, TARSKI:2;
end;

theorem AdjacentV00: :: AdjacentV00
for G being _Graph, u,v being Vertex of G
 holds u in G.AdjacentSet({v}) iff (u <> v & v,u are_adjacent)
proof
    let G be _Graph, u,v be Vertex of G;
    hereby assume A1: u in G.AdjacentSet({v}); 
        consider x being Vertex of G such that
    A3: x in {v} & u,x are_adjacent by A1,Adjacent00;
        x = v by A3,TARSKI:def 1; 
        hence u <> v & v,u are_adjacent by A1,A3,Adjacent00;
    end;
    assume A1: u <> v & v,u are_adjacent; then
    not u in {v} & v in {v} by TARSKI:def 1; 
    hence u in G.AdjacentSet({v}) by A1;
end;

theorem 
for G being _Graph, x,y being set
 holds x in G.AdjacentSet({y}) iff y in G.AdjacentSet({x})
proof let G be _Graph, x,y be set;
  hereby assume A1: x in G.AdjacentSet({y}); then
    reconsider xg = x as Vertex of G;
    now assume B1: not y in the_Vertices_of G;
       consider vy being Vertex of G such that
    B2: vy in {y} & vy,xg are_adjacent by A1,Adjacent00;
       vy = y by B2,TARSKI:def 1; 
      hence contradiction by B1;
    end; then
    reconsider yg = y as Vertex of G;
    xg <> yg & xg,yg are_adjacent by A1, AdjacentV00; 
   hence y in G.AdjacentSet({x}) by AdjacentV00;
  end;
  assume A1: y in G.AdjacentSet({x}); then
    reconsider yg = y as Vertex of G;
    now assume B1: not x in the_Vertices_of G;
       consider vx being Vertex of G such that
    B2: vx in {x} & vx,yg are_adjacent by A1,Adjacent00;
       vx = x by B2,TARSKI:def 1;
      hence contradiction by B1;
    end; then
    reconsider xg = x as Vertex of G;
    xg <> yg & xg,yg are_adjacent by A1, AdjacentV00;
  hence x in G.AdjacentSet({y}) by AdjacentV00;
end;

theorem 
for G being _Graph, C being Path of G st C is Cycle-like & C.length() > 3
for x being Vertex of G st x in C.vertices() 
  ex m,n being odd Nat st m+2 < n & n <= len C & not (m=1 & n = len C) &
                          not (m=1 & n = len C-2) & not (m=3 & n = len C) &
         C.m <> C.n & C.m in G.AdjacentSet({x}) & C.n in G.AdjacentSet({x})
proof let G be _Graph, C be Path of G such that
A1: C is Cycle-like & C.length() > 3;
    let x be Vertex of G such that
A2: x in C.vertices();
    C.length() >= 3+1 by A1,NAT_1:38; then
    2*C.length() >= 2*4 by XREAL_1:66; then
    2*C.length() + 1 >= 8 + 1 by XREAL_1:9; then
A3: len C >= 9 by GLIB_001:113;
    consider n being odd Element of NAT such that
A4: n <= len C & C.n = x by A2,GLIB_001:88;
A5: 0+1 <= n by HEYTING3:1;
A6: C is closed by A1,GLIB_001:def 31;
    per cases;
    suppose B0: n = 1 or n = len C;
        reconsider i=2*1+1 as odd Nat;
        len C + (-2) >= 9 + (-2) by A3,XREAL_1:9; then
        len C - 2*1 >= 0 by XREAL_1:2; then
        len C - 2 is odd Element of NAT by INT_1:16; then
        reconsider j=len C-2 as odd Nat;
     take i, j;
    B1z: i in NAT & j in NAT by ORDINAL1:def 13;
    B1a: len C + (-2) >= 9 + (-2) by A3,XREAL_1:9;
     hence
     i+2 < j by XREAL_1:2;
    B2a: len C + 0 > len C+(-2) by XREAL_1:10; 
     thus j <= len C by B2a;
     thus not (i=1 & j=len C) & not (i=1 & j=len C-2) & not (i=3 & j=len C);
     hereby assume C1: C.i = C.j; i+2+(-2) < j+0 by B1a, XREAL_1:2; 
      hence contradiction by B1z,B2a,C1,GLIB_001:def 28;
     end;
        reconsider k=2*0+1 as odd Nat;
    F4: len C + 0 > 9 + (-6) by A3,XREAL_1:10; then
        reconsider Ci=C.i as Vertex of G by GLIB_001:8;
        len C + 0 > 9 + (-8) by A3,XREAL_1:10; then
    F1: C.(k+1) Joins C.k,C.i,G by GLIB_001:def 3;
    F3: now per cases by B0;
          suppose n = 1; hence x = C.k by A4; end;
          suppose n = len C; then
              x = C.last() by A4; then
              x = C.first() by A6,GLIB_001:def 24;
              hence x = C.k; end;
        end; then
    F2: x,Ci are_adjacent by F1, DefAdjacent;
        x <> Ci by F3,F4,GLIB_001:def 28;
     hence C.i in G.AdjacentSet({x}) by F2,AdjacentV00;
        reconsider Cj=C.j as Vertex of G by B1z, B2a,GLIB_001:8;
    F3: now per cases by B0;
          suppose n = 1; then x = C.first() by A4; then
              x = C.last() by A6,GLIB_001:def 24;
              hence x = C.(j+2); end;
          suppose n = len C; hence x = C.(j+2) by A4; end;
        end; then
        C.(j+1) Joins Cj,x,G by B1z,B2a,GLIB_001:def 3; then
    F2: x,Cj are_adjacent by DefAdjacent;
        now assume x = Cj;
             then j = 1 & j+2 = len C by B1z,F3,B2a,GLIB_001:def 28;
            hence contradiction by A3;  
        end; 
      hence C.j in G.AdjacentSet({x}) by F2,AdjacentV00;
    end;

    suppose G0: not (n = 1 or n = len C); then
    G8: 2*0+1 < n & n < len C by A5,A4,REAL_1:def 5; then
        1+2 <= n & n <= len C-2 by EvenOdd02,EvenOdd03; then
        3+(-2) <= n+(-2) by XREAL_1:9; then
        0 <= n-2*1 by XREAL_1:2; then
        n-2 is odd Element of NAT by INT_1:16; then
        reconsider i=n-2 as odd Nat;
        reconsider j=n+2 as odd Nat ;
     take i,j;
     B1z: i in NAT & j in NAT by ORDINAL1:def 13;
     B1a: n+0 < n+2 & n+2 <= len C-2+2
            by G8,EvenOdd03,XREAL_1:10; 
     hence
     i+2 < j & j <= len C;
    B2: now assume C1: i = 1 & j = len C; j = i + 4; 
            hence contradiction by A3,C1;
        end;
     hence not (i = 1 & j = len C);
     hereby assume C1: i = 1 & j = len C-2; 
           len C+(-2) >= 9+(-3) by A3,XREAL_1:9; 
       hence contradiction by C1;
     end;
     hereby assume C1: i = 3 & j = len C; j = i + 4; 
       hence contradiction by C1,A3;
     end;
     hereby assume C1: C.i = C.j;
       i+2+(-2) < j+0 by XREAL_1:10; 
       hence contradiction by B1z,B2,B1a,C1,GLIB_001:def 28;
     end;
        i+0 < i+2 by XREAL_1:10; then
    G1: i < len C by XREAL_1:2, A4; then
        reconsider Ci=C.i as Vertex of G by B1z,GLIB_001:8;
        C.(i+1) Joins C.i,C.(i+2),G by B1z,G1,GLIB_001:def 3; then
    G2: x,Ci are_adjacent by A4,DefAdjacent;
        now assume C1: Ci = x; 
            n+0 > n+(-2) by XREAL_1:10; 
            hence contradiction by B1z,A4,G0,C1,GLIB_001:def 28; 
        end;
     hence C.i in G.AdjacentSet({x}) by G2,AdjacentV00;
    G9a: n+2 <= len C -2 + 2 by G8,EvenOdd03; 
        reconsider Cj=C.j as Vertex of G by G9a,GLIB_001:8;
        C.(n+1) Joins C.n,C.j,G by G8,GLIB_001:def 3; then
    G2: x,Cj are_adjacent by A4,DefAdjacent;
        now assume C1: Cj = x; 
            n+2 > n+0 by XREAL_1:10; 
            hence contradiction by G9a,G0,C1, A4, GLIB_001:def 28;
        end;         
      hence C.j in G.AdjacentSet({x}) by G2,AdjacentV00;
      end;
end;

theorem Cycle01a: :: Cycle01a
for G being _Graph, C being Path of G st C is Cycle-like & C.length() > 3
for x being Vertex of G st x in C.vertices() 
 ex m,n being odd natural number st m+2 < n & n <= len C &
         C.m <> C.n & C.m in G.AdjacentSet({x}) & C.n in G.AdjacentSet({x}) &
         for e being set st e in C.edges() holds not e Joins C.m,C.n,G
proof let G be _Graph, C be Path of G such that
A1: C is Cycle-like & C.length() > 3;
    let x be Vertex of G such that
A2: x in C.vertices();
    C.length() >= 3+1 by A1,NAT_1:38; then
    2*C.length() >= 2*4 by XREAL_1:66; then
    2*C.length() + 1 >= 8 + 1 by XREAL_1:9; then
A3: len C >= 9 by GLIB_001:113;
    consider n being odd Element of NAT such that
A4: n <= len C & C.n = x by A2,GLIB_001:88;
A5: 0+1 <= n by HEYTING3:1;
A6: C is closed by A1,GLIB_001:def 31;
    per cases;
    suppose B0: n = 1 or n = len C;
        reconsider i=2*1+1 as odd Nat;
        len C + (-2) >= 9 + (-2) by A3,XREAL_1:9; then
        len C - 2*1 >= 0 by XREAL_1:2; then
        len C-2 is odd Element of NAT by INT_1:16; then
        reconsider j=len C-2 as odd Nat;
      take i, j;
    B1z: i in NAT & j in NAT by ORDINAL1:def 13;
    B1a: len C + (-2) >= 9 + (-2) by A3,XREAL_1:9;
      hence
     i+2 < j by XREAL_1:2;
    B2a: len C + 0 > len C+(-2) by XREAL_1:10; 
      thus j <= len C by B2a;
    hereby assume C1: C.i = C.j; i+2+(-2) < j+0 by B1a,XREAL_1:2; 
            hence contradiction by B1z,B2a,C1,GLIB_001:def 28;
    end;
        reconsider k=2*0+1 as odd Nat;
    F4: len C + 0 > 9 + (-6) by A3,XREAL_1:10; then
        reconsider Ci=C.i as Vertex of G by GLIB_001:8;
        len C + 0 > 9 + (-8) by A3,XREAL_1:10; then
    F1: C.(k+1) Joins C.k,C.i,G by GLIB_001:def 3;
    F3: now per cases by B0;
          suppose n = 1; hence x = C.k by A4; end;
          suppose n = len C; then
              x = C.last() by A4; then
              x = C.first() by A6,GLIB_001:def 24;
              hence x = C.k; end;
        end; then
    F2: x,Ci are_adjacent by F1, DefAdjacent;
        x <> Ci by F3,F4,GLIB_001:def 28;
     hence C.i in G.AdjacentSet({x}) by F2,AdjacentV00;
        reconsider Cj=C.j as Vertex of G by B1z,B2a,GLIB_001:8;
    F1: C.(j+1) Joins C.j,C.(j+2),G by B1z,B2a,GLIB_001:def 3;
    F3: now per cases by B0;
          suppose n = 1; then x = C.first() by A4; then
              x = C.last() by A6,GLIB_001:def 24;
              hence x = C.(j+2); end;
          suppose n = len C; hence x = C.(j+2) by A4; end;
        end; then
    F2: x,Cj are_adjacent by F1,DefAdjacent;
        now assume x = Cj;
              then j = 1 & j+2 = len C by B1z,F3,B2a,GLIB_001:def 28;
            hence contradiction by A3;  
        end; 
      hence C.j in G.AdjacentSet({x}) by F2,AdjacentV00;
      let e be set such that
     G5: e in C.edges() and
     G1: e Joins C.i,C.j,G; 
         consider k being even Element of NAT such that
     G2: 1 <= k and
     G3: k <= len C and
     G4: C.k = e by G5,GLIB_001:100;
         k in dom C by G2, G3, FINSEQ_3:27; then
         consider ku1 being odd Element of NAT such that
     H1: ku1 = k-1 and
     H2: k-1 in dom C and
     H3: k+1 in dom C and
     H4: C.k Joins C.(ku1), C.(k+1),G by GLIB_001:10;
     H5: ((the_Source_of G).e = C.i & (the_Target_of G).e = C.j or
          (the_Source_of G).e = C.j & (the_Target_of G).e = C.i) &
         ((the_Source_of G).e = C.ku1 & (the_Target_of G).e = C.(k+1) or
          (the_Source_of G).e = C.(k+1) & (the_Target_of G).e = C.(ku1))
           by G1, H4, G4, GLIB_000:def 15;
     I1: ku1 <= len C by H1,H2,FINSEQ_3:27;
     I2: k+1 <= len C by H3, FINSEQ_3:27;
      i < j by B1a,XREAL_1:2; then
     I3: i < len C by B2a, XREAL_1:2;
     I4: j <> 1 by B1a;
      per cases by H5;
       suppose S0: C.i = C.ku1 & C.j = C.(k+1);
           i+2 = k-1+(1+1) by S0,I3,I1,Path01,H1
              .= j by S0,B2a,I2,I4,Path01;
         hence contradiction by B1a;
       end;
       suppose S0: C.i = C.(k+1) & C.j = C.ku1;
                   i = k+1 by S0,I3,I2,Path01;
         hence contradiction by S0,B2a,H1,I1,I4,Path01;
       end;
    end;

    suppose G0: not (n = 1 or n = len C); then
    G8: 2*0+1 < n & n < len C by A5,A4,REAL_1:def 5; then
        1+2 <= n & n <= len C-2 by EvenOdd02,EvenOdd03; then
        3+(-2) <= n+(-2) by XREAL_1:9;
        then 0 <= n-2 by XREAL_1:2;
        then n-2*1 is odd Element of NAT by INT_1:16; 
        then reconsider i=n-2*1 as odd Nat;
        reconsider j=n+2 as odd Nat ;
     take i, j;
     B1z: i in NAT & j in NAT by ORDINAL1:def 13;
        n+0 < n+2 by XREAL_1:10;
     hence i+2 < j;
     thus B1b: j <= len C by G8,EvenOdd03;
    B2: now assume C1: i = 1 & j = len C; j = i + 4; 
            hence contradiction by A3,C1;
        end;
     hereby assume C1: C.i = C.j;
       i+2+(-2) < j+0 by XREAL_1:10; 
      hence contradiction by B1z,B2,B1b,C1,GLIB_001:def 28;
     end;
        i+0 < i+2 by XREAL_1:10; then
    G1: i < len C by XREAL_1:2, A4; then
        reconsider Ci=C.i as Vertex of G by B1z,GLIB_001:8;
        C.(i+1) Joins C.i,C.(i+2),G by B1z,G1,GLIB_001:def 3; then
    G2: x,Ci are_adjacent by A4,DefAdjacent;
        now assume C1: Ci = x; 
            n+0 > n+(-2) by XREAL_1:10;
            hence contradiction by B1z,A4,G0,C1,GLIB_001:def 28;
        end;
     hence C.i in G.AdjacentSet({x}) by G2,AdjacentV00;
    G9: n+2 <= len C -2 + 2 by G8,EvenOdd03;
        reconsider Cj=C.j as Vertex of G by B1b,GLIB_001:8;
        C.(n+1) Joins C.n,C.j,G by G8,GLIB_001:def 3; then
    G2: x,Cj are_adjacent by A4,DefAdjacent;
        now assume C1: Cj = x; 
            n+2 > n+0 by XREAL_1:10;
            hence contradiction by G9,G0,C1,A4,GLIB_001:def 28;
        end; 
      hence C.j in G.AdjacentSet({x}) by G2,AdjacentV00;
      let e be set such that
     G5: e in C.edges() and
     G1a: e Joins C.i,C.j,G; 
         consider k being even Element of NAT such that
     G2: 1 <= k and
     G3: k <= len C and
     G4: C.k = e by G5,GLIB_001:100;
         k in dom C by G2, G3, FINSEQ_3:27; then
         consider ku1 being odd Element of NAT such that
     H1: ku1 = k-1 and k-1 in dom C and
     H3: k+1 in dom C and
     H4: C.k Joins C.(ku1), C.(k+1),G by GLIB_001:10;
     H5: ((the_Source_of G).e = C.i & (the_Target_of G).e = C.j or
          (the_Source_of G).e = C.j & (the_Target_of G).e = C.i) &
         ((the_Source_of G).e = C.ku1 & (the_Target_of G).e = C.(k+1) or
          (the_Source_of G).e = C.(k+1) & (the_Target_of G).e = C.(ku1))
           by G1a, H4, G4, GLIB_000:def 15;
          k-1 < k by XREAL_1:148; then
     I1a: k-1 < len C by G3,XREAL_1:2;
     I2: k+1 <= len C by H3, FINSEQ_3:27;
         1+2 <= j by A5,XREAL_1:9; then
     I3: j <> 1;
         1+1 <= k+1 by G2, XREAL_1:9; then
     I4: k+1 <> 1;
      per cases by H5;
       suppose S0: C.i = C.ku1 & C.j = C.(k+1);
          i+2 = k-1+(1+1) by S0,H1,G1,I1a,Path01 :: .= k-1+1+1 .= k+1
              .= j by S0,I2,B1b,I3,I4,Path01;
         hence contradiction;
       end;
       suppose S0: C.i = C.(k+1) & C.j = C.ku1;
         per cases by S0,B1b,I1a,H1,G1,I2,Path01;
         suppose i = k+1 & j = k-1;
           hence contradiction;
         end;
         suppose S1: i = k+1 & k-1 = 1 & j = len C;
           j = i+4;
           hence contradiction by S1,A3;
         end;
         suppose S1: i = 1 & k+1 = len C & j = k-1;
             k+1 = 7 by S1;
           hence contradiction by S1,A3;
         end;
         suppose S1: i = 1 & k+1 = len C & k-1 = 1 & j = len C;
          thus contradiction by S1;
         end;
       end;
      end;
end;

:: Gilbert's definition of isolated does not allow a vertex to have a
:: loop and a vertex just with a loop on it is NOT isolated.
:: This needs to be fixed, e.g.
::       v is isolated means G.AdjacentSet({v}) = {}
:: But we can keep the old one and the new one can be expressed just
:: by G.AdjacentSet({v}) = {}.  Should this be revised?
:: Ask Lorna and Ryan.  For loopless graphs it
:: does not matter, see below.

theorem :: AdjacentV01: :: :: AdjacentV01
for G being loopless _Graph, u being Vertex of G
 holds G.AdjacentSet({u}) = {} iff u is isolated
proof
    let G be loopless _Graph, u be Vertex of G;
    hereby assume A0: G.AdjacentSet({u}) = {};
        now assume u.edgesInOut() <> {}; then
            consider e being set such that
        A1: e in u.edgesInOut() by XBOOLE_0:def 1;
            consider v being Vertex of G such that
        A2: e Joins u,v,G by A1,GLIB_000:67;
            now assume u = v; then
                e in the_Edges_of G &
                (the_Source_of G).e = u & (the_Target_of G).e = u
                    by A2, GLIB_000:def 15; 
                hence contradiction by GLIB_000:def 20;
            end; then u <> v & v,u are_adjacent by A2,DefAdjacent;
            hence contradiction by A0, AdjacentV00;
        end;
        hence u is isolated by GLIB_000:def 51;
    end;
    assume u is isolated; then
A0: u.edgesInOut() = {} by GLIB_000:def 51; 
    now let v be set such that B0: v in G.AdjacentSet({u});
        reconsider v as Vertex of G by B0;
        v,u are_adjacent by B0,AdjacentV00; then
        consider e being set such that
    A2: e Joins v,u,G by DefAdjacent;
        e Joins u,v,G by A2,GLIB_000:17;
        hence contradiction by A0, GLIB_000:65;
    end;
    hence G.AdjacentSet({u}) = {} by XBOOLE_0:def 1;
end;

theorem Connected0: :: Connected0
for G being _Graph, G0 being Subgraph of G,
    S being non empty Subset of the_Vertices_of G,
    x being Vertex of G,
    G1 being (inducedSubgraph of G,S),
    G2 being (inducedSubgraph of G,S\/{x})
 st G1 is connected & x in G.AdjacentSet(the_Vertices_of G1)
  holds G2 is connected
proof let G be _Graph, G0 be Subgraph of G,
          S be non empty Subset of the_Vertices_of G, x be Vertex of G,
          G1 be (inducedSubgraph of G,S),
          G2 be (inducedSubgraph of G,S\/{x}) such that
A: G1 is connected and
B: x in G.AdjacentSet(the_Vertices_of G1);
 let u,v be Vertex of G2;
      reconsider Sx = S\/{x} as Subset of the_Vertices_of G;
   the_Vertices_of G2 = Sx by GLIB_000:def 39; then
D: (u in S or u in {x}) & (v in S or v in {x}) by XBOOLE_0:def 2;
   S c= Sx by XBOOLE_1:7; then
E: G1 is inducedSubgraph of G2,S by Subgraph01a;
F: the_Vertices_of G1 = S by GLIB_000:def 39; then
    consider xs being Vertex of G such that
G: xs in S and
H: x,xs are_adjacent by B, Adjacent00;
   consider e being set such that
I: e Joins x,xs,G by H, DefAdjacent;
J: e Joins xs,x,G by I, GLIB_000:17;
   x in {x} by TARSKI:def 1; then
   x in Sx & xs in Sx by G,XBOOLE_0:def 2; then
K: e Joins xs,x,G2 by J, Joins01;
L: e Joins x,xs,G2 by K,GLIB_000:17;
   per cases by D, TARSKI:def 1;
   suppose S1: u in S & v in S;
     the_Vertices_of G1 = S by GLIB_000:def 39; then
     consider W being Walk of G1 such that
   A1: W is_Walk_from u,v by A, S1, GLIB_002:def 1;
     reconsider W as Walk of G2 by E, GLIB_001:168;
     take W;
     thus thesis by A1, GLIB_001:20;
   end;
   suppose S1: u in S & v = x;
     consider W being Walk of G1 such that
   A1: W is_Walk_from u,xs by G, F, A, S1, GLIB_002:def 1;
     reconsider W as Walk of G2 by E, GLIB_001:168;
     take WW = W.append(G2.walkOf(xs,e,x));
   B1: W is_Walk_from u, xs by A1,GLIB_001:20;
      G2.walkOf(xs,e,x) is_Walk_from xs,x by K, GLIB_001:16;
     hence thesis by S1,B1,GLIB_001:32;
   end;
   suppose S1: u = x & v in S;
     consider W being Walk of G1 such that
   A1: W is_Walk_from xs,v by G, F, A, S1, GLIB_002:def 1;
     reconsider W as Walk of G2 by E, GLIB_001:168;
     take WW = G2.walkOf(x,e,xs).append(W);
   B1: W is_Walk_from xs, v by A1,GLIB_001:20;
      G2.walkOf(x,e,xs) is_Walk_from x,xs by L, GLIB_001:16;
     hence thesis by S1,B1,GLIB_001:32;
   end;
   suppose u = x & v = x; then
       G2.walkOf(u) is_Walk_from u,v by GLIB_001:14;
     hence thesis;
   end;
end;

theorem Simplicial2a: :: Simplicial2a
for G being _Graph for S being non empty Subset of the_Vertices_of G
for H being inducedSubgraph of G,S  
for u being Vertex of G st u in S & G.AdjacentSet({u}) c= S
for v being Vertex of H st u=v holds G.AdjacentSet({u}) = H.AdjacentSet({v}) 
proof
    let G be _Graph; let S be non empty Subset of the_Vertices_of G;
    let G2 be inducedSubgraph of G,S; let u be Vertex of G such that
A1: u in S & G.AdjacentSet({u}) c= S;
    let v be Vertex of G2 such that
A2: u=v;
    now let x be set;
        hereby assume B1: x in G.AdjacentSet({u}); then
            reconsider y=x as Vertex of G;
            reconsider w=x as Vertex of G2 by A1,B1,GLIB_000:def 39;
            y <> u & y,u are_adjacent by B1,AdjacentV00; then
            consider e being set such that
        B3: e Joins y,u,G by DefAdjacent;
            e Joins y,u,G2 by Joins01,B1,A1,B3; then
            w <> v & w,v are_adjacent by B1,AdjacentV00,A2,DefAdjacent; 
            hence x in G2.AdjacentSet({v}) by AdjacentV00;
        end;
        assume B1: x in G2.AdjacentSet({v}); then
        reconsider y=x as Vertex of G2;
        x in the_Vertices_of G2 by B1; then
        reconsider w=x as Vertex of G;
        y <> v & y,v are_adjacent by B1,AdjacentV00; then
        consider e being set such that
    B3: e Joins y,v,G2 by DefAdjacent; 
        e Joins y,v,G by B3,GLIB_000:75; then
        w <> u & w,u are_adjacent by B1,AdjacentV00,A2,DefAdjacent;
        hence x in G.AdjacentSet({u}) by AdjacentV00;
    end; 
  hence G.AdjacentSet({u}) = G2.AdjacentSet({v}) by TARSKI:2;
end;

:: Adjacency set as a subgraph of G
definition let G be _Graph, S be set;
  mode AdjGraph of G,S -> Subgraph of G means :DefAdj0:
    it is inducedSubgraph of G,G.AdjacentSet(S)
    if S is Subset of the_Vertices_of G;
  existence proof consider T being inducedSubgraph of G,G.AdjacentSet(S);
      T is Subgraph of G;
      hence thesis;
  end;
  consistency;
end;

theorem AdjGraph00: :: AdjGraph00
for G1, G2 be _Graph st G1 == G2
for u1 being Vertex of G1, u2 being Vertex of G2 st u1 = u2 
for H1 being AdjGraph of G1,{u1}, H2 being AdjGraph of G2,{u2} holds H1 == H2
proof let G1,G2 be _Graph such that A1: G1 == G2;
    let u1 be Vertex of G1, u2 be Vertex of G2 such that A2: u1 = u2;
    let H1 be AdjGraph of G1,{u1};
    let H2 be AdjGraph of G2,{u2};
    set G1Adj = G1.AdjacentSet({u1});
    set G2Adj = G2.AdjacentSet({u2});
A3: H1 is inducedSubgraph of G1,G1Adj by DefAdj0;
A4: H2 is inducedSubgraph of G2,G2Adj by DefAdj0;
A5: G1Adj = G2Adj by A1,A2,Adjacent01;
    per cases;
    suppose B1: not G1Adj is non empty Subset of the_Vertices_of G1;
        H1 == G1 by A3,B1,GLIB_000:def 39; then
    B2: H1 == G2 by A1,GLIB_000:88; 
        H2 == G2 by A4,A5,B1,GLIB_000:def 39;
        hence H1 == H2 by B2,GLIB_000:88; end;
    suppose B1: G1Adj is non empty Subset of the_Vertices_of G1;
    B2: the_Vertices_of H1 = G1Adj &
        the_Edges_of H1 = G1.edgesBetween(G1Adj) by A3,B1,GLIB_000:def 39;
    B3: the_Vertices_of H2 = G2Adj &
        the_Edges_of H2 = G2.edgesBetween(G2Adj) by A4,B1,A5,GLIB_000:def 39;
        G1 is Subgraph of G2 & G2 is Subgraph of G1 by A1,GLIB_000:90; then
        G1.edgesBetween(G1Adj) c= G2.edgesBetween(G1Adj) &
        G2.edgesBetween(G1Adj) c= G1.edgesBetween(G1Adj) by GLIB_000:79; then
    A3: the_Vertices_of H1 = the_Vertices_of H2 &
        the_Edges_of H1 = the_Edges_of H2 by A5,B2,B3,XBOOLE_0:def 10;
        H2 is Subgraph of G2 & G2 is Subgraph of G1 by A1,GLIB_000:90; then
        H2 is Subgraph of G1 by GLIB_000:46;
    hence H1 == H2 by A3,GLIB_000:89; end;
end;

theorem Simplicial2b: :: Simplicial2b
for G being _Graph for S being non empty Subset of the_Vertices_of G
for H being inducedSubgraph of G,S  
for u being Vertex of G
  st u in S & G.AdjacentSet({u}) c= S & G.AdjacentSet({u}) <> {}
for v being Vertex of H st u=v 
for Ga being AdjGraph of G,{u}, Ha being AdjGraph of H,{v} holds Ga == Ha
proof
let G be _Graph; let S being non empty Subset of the_Vertices_of G;
let H be inducedSubgraph of G,S;
let u be Vertex of G such that
A1: u in S & G.AdjacentSet({u}) c= S and
B1: G.AdjacentSet({u}) <> {};
let v be Vertex of H such that
A2: u=v;
let Ga be AdjGraph of G,{u}, Ha being AdjGraph of H,{v};
A4: G.AdjacentSet({u}) = H.AdjacentSet({v}) by A1, A2, Simplicial2a;
    Ga is inducedSubgraph of G,G.AdjacentSet({u}) by DefAdj0; then
C3: the_Vertices_of Ga = G.AdjacentSet({u}) &
    the_Edges_of Ga = G.edgesBetween(G.AdjacentSet({u})) by B1,GLIB_000:def 39;
D1a:Ha is inducedSubgraph of H,H.AdjacentSet({v}) by DefAdj0; then
D1: the_Edges_of Ha = H.edgesBetween(H.AdjacentSet({v})) &
    the_Vertices_of Ha = H.AdjacentSet({v}) by A4,B1,GLIB_000:def 39;
thus the_Vertices_of Ga = the_Vertices_of Ha
            by C3,D1a,A4,GLIB_000:def 39;
thus  D2: the_Edges_of Ga = the_Edges_of Ha by C3,D1,A4,A1,Subgraph02;
 D3: the_Source_of Ga = (the_Source_of G)|the_Edges_of Ga &
     the_Target_of Ga = (the_Target_of G)|the_Edges_of Ga by GLIB_000:48;
     Ha is inducedSubgraph of H,G.AdjacentSet({u}) by DefAdj0,A4; then
     Ha is inducedSubgraph of G,G.AdjacentSet({u}) by A1,B1,Subgraph01;
hence the_Source_of Ha = the_Source_of Ga &
      the_Target_of Ha = the_Target_of Ga by D3, D2,GLIB_000:48;
end;

definition let G be _Graph;
  attr G is complete means               :DefComplete:
    for u,v being Vertex of G st u <> v holds u,v are_adjacent;
end;
  
theorem Completetr: :: Completetr
for G being _Graph st G is trivial holds G is complete
proof let G be _Graph; assume G is trivial; then
    consider x being Vertex of G such that
A0: the_Vertices_of G = {x} by GLIB_000:25;
 let u,v being Vertex of G such that
A1: u <> v & not u,v are_adjacent;
    u = x & v = x by A0,TARSKI:def 1;
 hence contradiction by A1;
end;

registration 
  cluster trivial -> complete _Graph;
  coherence by Completetr;
end;

registration
  cluster trivial simple complete _Graph;
  existence proof consider G being trivial simple _Graph;
    take G;
    thus thesis;
  end;

  cluster non trivial finite simple complete _Graph;
  existence proof
    set V = {0,1}, E = {0}, S = 0 .--> 0, T = 0 .--> 1;
A1: dom S = E & dom T = E by CQC_LANG:5;
    now let x be set; assume x in E; then
        x = 0 by TARSKI:def 1; then
        S.x = 0 by CQC_LANG:6;
        hence S.x in V by TARSKI:def 2;
    end; then reconsider S as Function of E,V by A1, FUNCT_2:5;
    now let x be set; assume x in E; then
        x = 0 by TARSKI:def 1; then
        T.x = 1 by CQC_LANG:6;
        hence T.x in V by TARSKI:def 2;
    end; then reconsider T as Function of E,V by A1, FUNCT_2:5;
    set G = createGraph(V,E,S,T);
A2: the_Vertices_of G = V & the_Edges_of G = E & the_Source_of G = S &
      the_Target_of G = T by GLIB_000:8;
    take G;
    now assume Card (the_Vertices_of G) = 1; then
        consider x being set such that
    B1: the_Vertices_of G = {x} by CARD_2:60;
        thus contradiction by A2,B1,ZFMISC_1:9;
    end;
    hence G is non trivial & G is finite by GLIB_000:def 21;
A4: (the_Source_of G).0 = 0 by A2,CQC_LANG:6;
A5: (the_Target_of G).0 = 1 by A2,CQC_LANG:6;
    0 in the_Edges_of G by A2,TARSKI:def 1; then
A6: 0 Joins 0,1,G by A4,A5,GLIB_000:def 15;
    now let v be set;
        let e being set such that B1: e Joins v,v,G;
        reconsider v as Vertex of G by B1,GLIB_000:16;
        e in the_Edges_of G by B1,GLIB_000:def 15; then
        e Joins 0,1,G by A6,A2,TARSKI:def 1; then
        (0 = v & 1 = v) or (0 = v & 1 = v) by B1,GLIB_000:18;
        hence contradiction;
    end; then
A3: G is loopless by GLIB_000:21;
    now let e1,e2,v1,v2 be set such that
    B1: e1 Joins v1,v2,G & e2 Joins v1,v2,G;
        assume B2: e1 <> e2;
        e1 in {0} & e2 in {0} by A2,B1,GLIB_000:def 15; then
        e1 = 0 & e2 = 0 by TARSKI:def 1;
        hence contradiction by B2;
    end; then G is non-multi by GLIB_000:def 22;
    hence G is simple by A3,GLIB_000:def 24;
    now let u,v be Vertex of G such that B1: u <> v;
        per cases by A2,TARSKI:def 2;
        suppose C1: u = 0; then C2: v = 1 by B1,A2,TARSKI:def 2; 
            0 in the_Edges_of G by A2,TARSKI:def 1; then
            0 Joins u,v,G by A4,A5,C1,C2,GLIB_000:def 15; 
            hence u,v are_adjacent by DefAdjacent; end;
        suppose C1: u = 1; then C2: v = 0 by B1, A2,TARSKI:def 2; 
            0 in the_Edges_of G by A2,TARSKI:def 1; then
            0 Joins v,u,G by A4,A5,C1,C2,GLIB_000:def 15;
            hence u,v are_adjacent by DefAdjacent; end;
    end;
    hence G is complete by DefComplete;
  end;
end;

theorem Complete00: :: Complete00
for G1,G2 being _Graph st G1 == G2 holds G1 is complete implies G2 is complete
proof let G1,G2 be _Graph such that A1: G1 == G2;
    assume A2: G1 is complete;
    now let u,v be Vertex of G2 such that B1: u <> v;
        reconsider u2=u as Vertex of G1 by A1,GLIB_000:def 36;
        reconsider v2=v as Vertex of G1 by A1,GLIB_000:def 36;
        u2,v2 are_adjacent by B1,A2,DefComplete;
        hence u,v are_adjacent by A1,VAdjacent00;
    end;
    hence G2 is complete by DefComplete;
end;

theorem Complete01: :: Complete01
for G being complete _Graph, S being Subset of the_Vertices_of G
for H being inducedSubgraph of G,S holds H is complete 
proof
    let G be complete _Graph;
    let S be Subset of the_Vertices_of G;
    let H be inducedSubgraph of G,S;
    per cases;
    suppose S = {}; then
        H == G by GLIB_000:def 39;
        hence H is complete by Complete00; end;
    suppose A1: S <> {};
    A2: the_Vertices_of H = S by A1,GLIB_000:def 39;
        now let u,v be Vertex of H such that B1: u <> v;
            reconsider u2=u as Vertex of G by A2,TARSKI:def 3;
            reconsider v2=v as Vertex of G by A2,TARSKI:def 3;
            u2,v2 are_adjacent by B1,DefComplete; then
            consider e being set such that
        B2: e Joins u2,v2,G by DefAdjacent;
            e Joins u,v,H by A2,B2,Joins01;
            hence u,v are_adjacent by DefAdjacent;
        end;
        hence H is complete by DefComplete; end;
end;

begin :: Simplicial vertex :: Golumbic p. 81

definition let G be _Graph, v be Vertex of G;
  attr v is simplicial means                                  :DefSimplicial:
   G.AdjacentSet({v}) <> {} implies
       for G2 being AdjGraph of G,{v} holds G2 is complete;
end;

theorem Simplicial0: :: Simplicial0
for G being complete _Graph, v being Vertex of G holds v is simplicial
proof let G be complete _Graph, v be Vertex of G;
    now let G2 be AdjGraph of G,{v};
        G2 is inducedSubgraph of G,G.AdjacentSet({v}) by DefAdj0;
        hence G2 is complete by Complete01;
    end; 
    hence thesis by DefSimplicial;   
end;

theorem Simplicial01: :: Simplicial01
for G being trivial _Graph, v being Vertex of G holds v is simplicial
proof let G be trivial _Graph, v be Vertex of G;
   now assume G.AdjacentSet({v}) <> {}; then
      consider x being set such that
   A: x in G.AdjacentSet({v}) by XBOOLE_0:def 1;
    consider u being Vertex of G such that x = u and
   C: not u in {v} and
           ex v1 being Vertex of G st (v1 in {v} & u,v1 are_adjacent) by A;
      consider w being Vertex of G such that
   E: the_Vertices_of G = {w} by GLIB_000:25;
      u = w & v = w by E, TARSKI:def 1; 
    hence contradiction by C, TARSKI:def 1;
   end;
 hence v is simplicial by DefSimplicial;
end;

theorem Simplicial1: :: Simplicial1
for G1,G2 being _Graph st G1 == G2
for u1 being Vertex of G1, u2 being Vertex of G2
 st u1=u2 & u1 is simplicial holds u2 is simplicial
proof let G1,G2 be _Graph such that A1: G1 == G2;
    let u1 be Vertex of G1, u2 be Vertex of G2 such that A2: u1 = u2;
    assume A3: u1 is simplicial;
    now per cases;
    suppose G1.AdjacentSet({u1}) = {}; then
        G2.AdjacentSet({u2}) = {} by A1,A2,Adjacent01;
        hence u2 is simplicial by DefSimplicial; end;
    suppose B1: G1.AdjacentSet({u1}) <> {};
        consider H1 being AdjGraph of G1,{u1};
    B2: H1 is complete by A3,B1,DefSimplicial;
    B3: now let H2 be AdjGraph of G2,{u2};
            H1 == H2 by A1,A2,AdjGraph00;
            hence H2 is complete by B2,Complete00;
        end;
       thus u2 is simplicial by B3,DefSimplicial;
     end;
    end;
    hence thesis;
end;

theorem Simplicial2: :: Simplicial2
for G being _Graph for S being non empty Subset of the_Vertices_of G
for H being inducedSubgraph of G,S  
for u being Vertex of G st u in S & G.AdjacentSet({u}) c= S
for v being Vertex of H st u=v holds u is simplicial iff v is simplicial
proof
    let G be _Graph; let S be non empty Subset of the_Vertices_of G;
    let G2 be inducedSubgraph of G,S; let u be Vertex of G such that
A1: u in S & G.AdjacentSet({u}) c= S;
    let v be Vertex of G2 such that
A2: u=v;
A5: G.AdjacentSet({u}) = {} iff G2.AdjacentSet({v}) = {} by A1,A2,Simplicial2a;
   per cases;
   suppose G.AdjacentSet({u}) = {};
        hence thesis by A5,DefSimplicial; end;
   suppose B1: G.AdjacentSet({u}) <> {};
    B3: G2.AdjacentSet({v}) <> {} by A1, A2, Simplicial2a,B1;
   hereby assume C0: u is simplicial;
       consider Ga being AdjGraph of G,{u};
   C1: Ga is complete by C0, B1, DefSimplicial;
     thus v is simplicial proof
       assume G2.AdjacentSet({v}) <> {};
       let Ha be AdjGraph of G2,{v};
         Ga == Ha by A1, A2, B1, Simplicial2b; 
       hence Ha is complete by C1,Complete00;
     end;
   end;
   assume C0: v is simplicial;
       consider Ha being AdjGraph of G2,{v};
   C1: Ha is complete by C0, B3, DefSimplicial;
     thus u is simplicial proof
       assume G.AdjacentSet({u}) <> {};
       let Ga be AdjGraph of G,{u};
         Ga == Ha by A1, A2, B1, Simplicial2b; 
       hence Ga is complete by C1,Complete00;
     end;
   end;
end;

theorem Simplicial03: :: Simplicial03
for G being _Graph, v being Vertex of G st v is simplicial
for a,b being set st a<>b & a in G.AdjacentSet({v}) & b in G.AdjacentSet({v})
  holds ex e being set st e Joins a,b,G
proof
    let G be _Graph, x be Vertex of G such that A1: x is simplicial;
    let a,b be set such that
A2: a<>b & a in G.AdjacentSet({x}) & b in G.AdjacentSet({x});
    consider H being AdjGraph of G,{x};
A4: H is complete by A1,A2,DefSimplicial;
A9a: H is inducedSubgraph of G,G.AdjacentSet({x}) by DefAdj0; 
    reconsider u=a as Vertex of H by A2,A9a,GLIB_000:def 39;
    reconsider v=b as Vertex of H by A2,A9a,GLIB_000:def 39;
    u,v are_adjacent by A2,A4,DefComplete; then
    consider e being set such that
A5: e Joins u,v,H by DefAdjacent;
    e Joins a,b,G by A5,GLIB_000:75;    
    hence thesis;
end;

theorem Simplicial03a: :: Simplicial03a
for G being _Graph, v being Vertex of G
 st not v is simplicial
   ex a,b being Vertex of G st a<>b & v<>a & v<>b &
          v,a are_adjacent & v,b are_adjacent & not a,b are_adjacent
proof
    let G be _Graph, v be Vertex of G such that A0: not v is simplicial;
    assume A1a: not ex a,b being Vertex of G st a<>b & v<>a & v<>b &
       v,a are_adjacent & v,b are_adjacent &
       not a,b are_adjacent; 
per cases;
suppose G.AdjacentSet({v}) = {};
  hence contradiction by A0,DefSimplicial; end;
suppose A2a: G.AdjacentSet({v}) <> {}; 
A7: now let H be AdjGraph of G,{v};
    A3: H is inducedSubgraph of G,G.AdjacentSet({v}) by DefAdj0;
        now let a,b be Vertex of H such that
        B1: a<>b;
        B9a: the_Vertices_of H = G.AdjacentSet({v}) by A3,A2a,GLIB_000:def 39;
            then
        a in G.AdjacentSet({v}) & b in G.AdjacentSet({v}); then
            reconsider vv=v,aa=a,bb=b as Vertex of G;
        B2: aa<>vv & aa,vv are_adjacent by B9a,AdjacentV00;
        B3: bb<>vv & bb,vv are_adjacent by B9a,AdjacentV00;
           aa,bb are_adjacent by A1a,B1,B2,B3;
           hence a,b are_adjacent by A2a,A3,VAdjacent01;
        end; 
        hence H is complete by DefComplete;
    end;
    thus contradiction by A0,A7,DefSimplicial; end;
end;

begin :: Vertex separator  :: Golumbic, p. 84

definition let G be _Graph, a,b be Vertex of G;
 assume A0: a<>b & not a,b are_adjacent;
 mode VertexSeparator of a,b -> Subset of the_Vertices_of G means  : DefVS :
  not a in it & not b in it & 
  for G2 being removeVertices of G,it holds
     not (ex W being Walk of G2 st W is_Walk_from a,b);
  existence proof
      set S = the_Vertices_of G\{a,b};
  A1: not ex e being set st e Joins a,b,G by A0,DefAdjacent;
      a in {a,b} & b in {a,b} by TARSKI:def 2; then
  A2: not a in S & not b in S by XBOOLE_0:def 4;
  A3: for G2 being removeVertices of G,S holds
        not ex W being Walk of G2 st W is_Walk_from a,b
      proof let G2 be removeVertices of G,S;
          let W be Walk of G2 such that B1: W is_Walk_from a,b;
          the_Vertices_of G\S is non empty by A2,XBOOLE_0:def 4; then
          the_Vertices_of G2 = the_Vertices_of G\S by GLIB_000:def 39;then
      C2: the_Vertices_of G2 = the_Vertices_of G /\ {a,b} by XBOOLE_1:48;
      B2a: the_Vertices_of G2 = {a,b} by C2,XBOOLE_1:28; 
          now let x be set such that D1: x in {a,b};
              now per cases by D1,TARSKI:def 2;
              suppose x = a; then
                  x = W.first() by B1,GLIB_001:def 23; 
                  hence x in W.vertices() by GLIB_001:89; end;
              suppose x = b; then
                  x = W.last() by B1,GLIB_001:def 23; 
                  hence x in W.vertices() by GLIB_001:89; end;
              end;
              hence x in W.vertices();
          end; then
          for x being set holds x in W.vertices() iff x in {a,b} by B2a; then
      C2: W.vertices() = {a,b} by TARSKI:2;
          reconsider W2=W as Walk of G by GLIB_001:168;
          now let x be set;
              hereby assume x in W2.vertices(); then
                  ex n being odd Element of NAT
                     st n<=len W & W.n=x by GLIB_001:88; 
                  hence x in W.vertices() by GLIB_001:88;
              end;
              assume x in W.vertices(); then
              ex n being odd Element of NAT
                    st n<=len W2 & W2.n=x by GLIB_001:88;
              hence x in W2.vertices() by GLIB_001:88;
          end; then W2.vertices() = {a,b} by TARSKI:2,C2;
          hence contradiction by A1, A0,Walk03;
      end;
     thus thesis by A2,A3;
  end;
end;

theorem VS01: :: VS01
for G being _Graph, a,b being Vertex of G st a<>b & not a,b are_adjacent
for S being VertexSeparator of a,b holds S is VertexSeparator of b,a
proof
    let G be _Graph;
    let a,b be Vertex of G such that A1: a<>b & not a,b are_adjacent;
    let S be VertexSeparator of a,b;
A2: not a in S & not b in S by A1,DefVS;
    for G2 being removeVertices of G,S holds
        not ex W being Walk of G2 st W is_Walk_from b,a
    proof let G2 be removeVertices of G,S;
        let W be Walk of G2 such that B1: W is_Walk_from b,a;
        W.reverse() is_Walk_from a,b by B1,GLIB_001:24;
        hence contradiction by A1, DefVS;
    end;
    hence thesis by A1,A2,DefVS;
end;

:: alternate characterization of Vertex Separator
theorem VS02: :: VS02
for G being _Graph, a,b being Vertex of G st a<>b & not a,b are_adjacent
for S being Subset of the_Vertices_of G holds
   S is VertexSeparator of a,b iff
   (not a in S & not b in S &
    for W being Walk of G st W is_Walk_from a,b holds
       ex x being Vertex of G st x in S & x in W.vertices())
proof
   let G be _Graph;
   let a,b be Vertex of G such that A1: a<>b & not a,b are_adjacent;
   let S be Subset of the_Vertices_of G;
   hereby assume B1: S is VertexSeparator of a,b;
     thus not a in S & not b in S by A1,B1,DefVS; then
   B3: the_Vertices_of G \ S is non empty by XBOOLE_0:def 4;
     let W be Walk of G such that C1: W is_Walk_from a,b;
      now assume D1: not ex x being Vertex of G st x in S & x in W.vertices();
               let G2 be removeVertices of G,S;
           D2: the_Vertices_of G2 = the_Vertices_of G\S by B3,GLIB_000:def 39;
           D5: the_Edges_of G2 = G.edgesBetween(the_Vertices_of G2)
                   by D2,GLIB_000:def 39;
               now let x be set such that E1: x in W.vertices();
                   x in the_Vertices_of G & not x in S by D1,E1;
                   hence x in the_Vertices_of G2 by D2,XBOOLE_0:def 4;
               end; then
           D3: W.vertices() c= the_Vertices_of G2 by TARSKI:def 3;
           D4: W.edges() c= G.edgesBetween(W.vertices()) by GLIB_001:110; 
               G.edgesBetween(W.vertices()) c=
               G.edgesBetween(the_Vertices_of G2) by D3,GLIB_000:39; then
               W.edges() c= the_Edges_of G2 by D4,D5,XBOOLE_1:1; then
               reconsider W2=W as Walk of G2 by D3,GLIB_001:171;
               W.first() = a & W.last() = b by C1,GLIB_001:def 23; then
               W2.first()=a&W2.last()=b; then
               W2 is_Walk_from a,b by GLIB_001:def 23;
               hence contradiction by A1,B1,DefVS;
             end;
      hence ex x being Vertex of G st x in S & x in W.vertices();
     end;
   assume B1: not a in S & not b in S &
              for W being Walk of G st W is_Walk_from a,b holds
                (ex x being Vertex of G st x in S & x in W.vertices());
   now let G2 be removeVertices of G,S;
       the_Vertices_of G \ S is non empty by B1,XBOOLE_0:def 4; then
   B2: the_Vertices_of G2 = the_Vertices_of G \ S by GLIB_000:def 39;
       given W be Walk of G2 such that C1: W is_Walk_from a,b;
           reconsider W2=W as Walk of G by GLIB_001:168;
           W.first() = a & W.last() = b by C1,GLIB_001:def 23; then
           W2.first()=a&W2.last()=b; then
       C3: W2 is_Walk_from a,b by GLIB_001:def 23;
           now let x be set;
              hereby assume x in W2.vertices(); then
              ex n being odd Element of NAT st n<=len W & W.n=x by GLIB_001:88;
                  hence x in W.vertices() by GLIB_001:88;
              end;
              assume x in W.vertices(); then
            ex n being odd Element of NAT st n<=len W2 & W2.n=x by GLIB_001:88;
              hence x in W2.vertices() by GLIB_001:88;
           end; then C4: W2.vertices() = W.vertices() by TARSKI:2;
           for x being Vertex of G holds not (x in S & x in W2.vertices())
            by XBOOLE_0:def 4,C4,B2;
           hence contradiction by B1,C3;
    end;
   hence S is VertexSeparator of a,b by A1,B1,DefVS;
end;

theorem VS07: :: VS07
for G being _Graph, a,b being Vertex of G st a<>b & not a,b are_adjacent
for S being VertexSeparator of a,b 
for W being Walk of G st W is_Walk_from a,b 
   ex k being odd Nat st 1 < k & k < len W & W.k in S
proof
    let G be _Graph;
    let a,b be Vertex of G such that A1: a<>b & not a,b are_adjacent;
    let S be VertexSeparator of a,b;
    let W be Walk of G such that A2: W is_Walk_from a,b;

A3: not a in S & not b in S by A1,VS02;
    consider x being Vertex of G such that
A4: x in S & x in W.vertices() by A1,A2,VS02;
    consider n being odd Element of NAT such that
A5: n <= len W & W.n = x by A4,GLIB_001:88;
A6: 1 <= n by HEYTING3:1;
    now assume 1 = n; then
        W.n = W.first(); 
        hence contradiction by A3,A4,A5,A2,GLIB_001:def 23;
    end; then A7: 1 < n by A6,REAL_1:def 5;
    now assume n = len W; then
        W.n = W.last();
        hence contradiction by A3,A4,A5, A2,GLIB_001:def 23;
    end; then n < len W by A5,REAL_1:def 5;
    hence thesis by A4,A5,A7;
end;

theorem VS08a: :: VS08a
for G being _Graph, a,b being Vertex of G st a<>b & not a,b are_adjacent 
for S being VertexSeparator of a,b 
 st S = {} holds not ex W being Walk of G st W is_Walk_from a,b
proof 
 let G be _Graph;
 let a,b be Vertex of G such that A1: a<>b & not a,b are_adjacent;
 let S be VertexSeparator of a,b;
 assume B1: S = {};
    consider G2 being removeVertices of G,S;
BB: G2 is inducedSubgraph of G,the_Vertices_of G,the_Edges_of G
             by B1,GLIB_000:37;
    the_Vertices_of G c= the_Vertices_of G; then
    the_Vertices_of G is non empty Subset of the_Vertices_of G &
    the_Edges_of G c= G.edgesBetween(the_Vertices_of G) by GLIB_000:37; then
B2: the_Vertices_of G2 = the_Vertices_of G &
    the_Edges_of G2 = the_Edges_of G by BB,GLIB_000:def 39;
    given W be Walk of G such that C1: W is_Walk_from a,b;
C2: W.vertices() c= the_Vertices_of G2 by B2;
C3: W.edges() c= the_Edges_of G2 by B2;
    reconsider W2=W as Walk of G2 by C2,C3,GLIB_001:171;
    W.first() = a & W.last() = b by C1,GLIB_001:def 23; then
    W2.first()=a&W2.last()=b; then
    W2 is_Walk_from a,b by GLIB_001:def 23;
 hence contradiction by A1,DefVS;
end;

theorem 
for G being _Graph, a,b being Vertex of G
 st a<>b &not a,b are_adjacent & not ex W being Walk of G st W is_Walk_from a,b
  holds {} is VertexSeparator of a,b
proof
 let G be _Graph;
 let a,b be Vertex of G such that A1: a<>b & not a,b are_adjacent;
 assume B1: not ex W being Walk of G st W is_Walk_from a,b;
B3: {} is Subset of the_Vertices_of G by XBOOLE_1:2;
    now let G2 be removeVertices of G,{};
      given W be Walk of G2 such that
    C1: W is_Walk_from a,b or W is_Walk_from b,a;
        per cases by C1;
        suppose D1: W is_Walk_from a,b;
          reconsider W2=W as Walk of G by GLIB_001:168;
          W.first() = a & W.last() = b by D1,GLIB_001:def 23; then
          W2.first()=a&W2.last()=b; 
          then W2 is_Walk_from a,b by GLIB_001:def 23;
          hence contradiction by B1;
        end;
        suppose D1: W is_Walk_from b,a;  
            set P=W.reverse();
        D2: P is_Walk_from a,b by D1,GLIB_001:24;
            reconsider W2=P as Walk of G by GLIB_001:168;
            P.first() = a & P.last() = b by D2,GLIB_001:def 23; then
            W2.first()=a&W2.last()=b; 
            then W2 is_Walk_from a,b by GLIB_001:def 23;
            hence contradiction by B1;
        end;
      end;
     hence {} is VertexSeparator of a,b by A1,B3,DefVS;
 end;

theorem VS11: :: VS11
for G being _Graph, a,b being Vertex of G st a<>b & not a,b are_adjacent
for S being VertexSeparator of a,b, G2 being removeVertices of G,S
for a2 being Vertex of G2 st a2=a holds G2.reachableFrom(a2) /\ S = {}
proof
    let G be _Graph;
    let a,b be Vertex of G such that A1: a<>b & not a,b are_adjacent;
    let S be VertexSeparator of a,b, G2 be removeVertices of G,S;
    let a2 be Vertex of G2 such that a2=a;
    set A = G2.reachableFrom(a2);
    not a in S by DefVS,A1; then
    a in the_Vertices_of G \ S by XBOOLE_0:def 4; then
A4: the_Vertices_of G2 = the_Vertices_of G \ S by GLIB_000:def 39;
    now let x be set such that B1: x in A /\ S;
        x in A & x in S by B1,XBOOLE_0:def 3; 
        hence contradiction by A4,XBOOLE_0:def 4;
    end;
    hence thesis by XBOOLE_0:def 1;
end;

theorem VS11b: :: VS11b
for G being _Graph, a,b being Vertex of G st a<>b & not a,b are_adjacent
for S being VertexSeparator of a,b, G2 being removeVertices of G,S
for a2,b2 being Vertex of G2 st a2=a & b2=b holds 
   G2.reachableFrom(a2) /\ G2.reachableFrom(b2) = {}
proof
    let G be _Graph;
    let a,b be Vertex of G such that A1: a<>b & not a,b are_adjacent;
    let S be VertexSeparator of a,b, G2 be removeVertices of G,S;
    let a2,b2 be Vertex of G2 such that A2: a2=a and A3: b2=b;
    set A = G2.reachableFrom(a2), B = G2.reachableFrom(b2);
    now let x be set such that B1: x in A /\ B;
        x in A by B1,XBOOLE_0:def 3; then
        consider W1 being Walk of G2 such that
    B2: W1 is_Walk_from a2,x by GLIB_002:def 5;
        x in B by B1,XBOOLE_0:def 3; then
        consider rW2 being Walk of G2 such that
    B3: rW2 is_Walk_from b2,x by GLIB_002:def 5;
        set W2 = rW2.reverse();
        set W = W1.append(W2);
        W2 is_Walk_from x,b2 by B3,GLIB_001:24; then
        W is_Walk_from a2,b2 by B2,GLIB_001:32;
        hence contradiction by A1,A2,A3,DefVS;
    end;
    hence thesis by XBOOLE_0:def 1;
end;

theorem VS10: :: VS10 
for G being _Graph, a,b being Vertex of G st a<>b & not a,b are_adjacent 
for S being VertexSeparator of a,b for G2 being removeVertices of G,S
 holds a is Vertex of G2 & b is Vertex of G2
proof
    let G be _Graph;
    let a,b be Vertex of G such that A1: a<>b & not a,b are_adjacent;
    let S be VertexSeparator of a,b, G2 be removeVertices of G,S;
    not a in S & not b in S by DefVS,A1; then
    a in the_Vertices_of G\S & b in the_Vertices_of G\S by XBOOLE_0:def 4;
    hence thesis by GLIB_000:def 39;
end;

definition let G be _Graph, a,b be Vertex of G;
  let S be VertexSeparator of a,b;
  attr S is minimal means                                          : DefVSMin :
     for T being Subset of S st T <> S holds not T is VertexSeparator of a,b;
end;

theorem VS000 : :: VS000 
for G being  _Graph, a,b being Vertex of G
for S being VertexSeparator of a,b st S = {} holds S is minimal
proof 
   let G be _Graph;
   let a,b be Vertex of G, S be VertexSeparator of a,b;
   assume A2: S = {};
   now assume not S is minimal; then
       consider T being Subset of S such that
   B0: T <> S & T is VertexSeparator of a,b by DefVSMin;
      thus contradiction by B0,A2, XBOOLE_1:3;
   end; 
   hence S is minimal;
end;

theorem minVSexistance : :: minVSexistance  
for G being finite _Graph for a,b being Vertex of G
 ex S being VertexSeparator of a,b st S is minimal
proof let G be finite _Graph, a,b be Vertex of G;
    set X = {S where S is VertexSeparator of a,b : not contradiction };
    consider s being VertexSeparator of a,b;
A2a: s in X; 
    now let x be set; assume x in X; then
        consider y being VertexSeparator of a,b such that B1: x = y;
        thus x in bool the_Vertices_of G by B1;
    end; then
    X c= bool the_Vertices_of G by TARSKI:def 3; then
    reconsider X as non empty finite set by A2a, FINSET_1:13;

    defpred P[set,set] means
      ex p being VertexSeparator of a,b st $1 = p & $2 = card p; 

ZZ: now let x be set such that Y1: x in X;
        consider Y being VertexSeparator of a,b such that
    C1: Y = x by Y1;
        card Y is Element of NAT;
        hence ex y being set st y in REAL & P[x,y] by C1;
    end;       
    consider F being Function of X, REAL such that
Z1: for x being set st x in X holds P[x,F.x] from FUNCT_2:sch 1(ZZ);
Z3: dom F = X by FUNCT_2:def 1;
    deffunc FF(Element of X) = F/.$1;
    consider Min being Element of X such that
A2: for N being Element of X holds FF(Min) <= FF(N) from GRAPH_5:sch 2;
    consider M being VertexSeparator of a,b such that
A3: M = Min & card M = F.Min by Z1;
    M in dom F by Z3; then
A4: F/.M = F.M by FINSEQ_4:def 4;

    now per cases;
    suppose M = {}; hence M is minimal by VS000; end;
    suppose M <> {};
        now assume not M is minimal; then
            consider T being Subset of M such that
        B1: T<>M & T is VertexSeparator of a,b by DefVSMin;
            T in X by B1; then
            reconsider T2=T as Element of X;
            consider Tp being VertexSeparator of a,b such that
        B2: Tp=T2 & card Tp = F.T2 by Z1;
            Tp in dom F by Z3; then
        B3: F/.Tp = F.Tp by FINSEQ_4:def 4;
        B9: card M <= card T by A4,A3,B2,B3,A2;
        B2: card T <= card M by CARD_1:80;
            card T <> card M by B1,TRIANG_1:3;
            hence contradiction by B9, B2,REAL_1:def 5;
        end;
        hence M is minimal; end;
    end;
    hence thesis;
end;

theorem VS13: :: VS13
:: Property "symmetry" for 2 argument modes could be used if we had it
:: as VertexSeparator of a,b is a VertexSeparator of b,a
:: then this theorem would not be needed
for G being _Graph, a,b being Vertex of G st a<>b & not a,b are_adjacent
for S being VertexSeparator of a,b st S is minimal
for T being VertexSeparator of b,a st S=T holds T is minimal
proof
    let G be _Graph;
    let a,b be Vertex of G such that A1: a<>b and A2: not a,b are_adjacent;
    let S be VertexSeparator of a,b such that A3: S is minimal;
    let T be VertexSeparator of b,a such that A4: S=T;
    assume not T is minimal; then
        consider H being Subset of T such that
    B1: H <> T & H is VertexSeparator of b,a by DefVSMin;
        H is Subset of S & H <> S & H is VertexSeparator of a,b
            by A1,A2,B1,A4,VS01;
    hence contradiction by A3,DefVSMin;
end;

theorem :: VS06: :: :: VS06
for G being _Graph, a,b being Vertex of G st a<>b & not a,b are_adjacent
for S being VertexSeparator of a,b st S is minimal
for x being Vertex of G st x in S 
    ex W being Walk of G st W is_Walk_from a,b & x in W.vertices()
proof
    let G be _Graph;
    let a,b be Vertex of G such that A1: a<>b and A2: not a,b are_adjacent;
    let S be VertexSeparator of a,b such that A3: S is minimal;
    let x be Vertex of G such that A4: x in S; assume
B1: not ex W being Walk of G st W is_Walk_from a,b & x in W.vertices();
    set T = S\{x};
    x in {x} by TARSKI:def 1;  then
B2: T <> S by A4,XBOOLE_0:def 4;
B3: T c= S by XBOOLE_1:36;
B4: not a in T & not b in T by A1,A2,B3,DefVS;
    now let W be Walk of G such that C1: W is_Walk_from a,b;
         consider y being Vertex of G such that
    C2: y in S & y in W.vertices() by A1,A2,C1,VS02;
        take y;
        y <> x by B1,C1,C2;
        then not y in {x} by TARSKI:def 1;
      hence y in T by C2,XBOOLE_0:def 4;
      thus y in W.vertices() by C2;
    end; then T is VertexSeparator of a,b by A1,A2,B4,VS02;
  hence contradiction by A3,B2,B3,DefVSMin;
end;

theorem VertexSep0: :: VertexSep0 
for G being _Graph
for a,b being Vertex of G st a<>b & not a,b are_adjacent
for S being VertexSeparator of a,b st S is minimal
for H being removeVertices of G,S for aa being Vertex of H st aa=a 
for x being Vertex of G st x in S 
    ex y being Vertex of G st y in H.reachableFrom(aa) & x,y are_adjacent
proof
    let G be _Graph;
    let a,b be Vertex of G such that A1: a<>b and A2: not a,b are_adjacent;
    let S be VertexSeparator of a,b such that A3: S is minimal;
    let H be removeVertices of G,S;
    let aa be Vertex of H such that A4: aa=a;
    let x be Vertex of G such that A6: x in S;
    reconsider bb=b as Vertex of H by A1,A2,VS10;

    set T = S\{x};
    set A=H.reachableFrom(aa), B=H.reachableFrom(bb);
    assume B1: not ex y being Vertex of G st
                   y in H.reachableFrom(aa) & x,y are_adjacent;
    B2: for W being Walk of G st W is_Walk_from a,b & x in W.vertices() 
            ex y being Vertex of G st y in T & y in W.vertices() 
        proof let W be Walk of G such that
        C1: W is_Walk_from a,b and C2: x in W.vertices();
            consider k being odd Element of NAT such that
        E3: k <= len W & W.k = x by C2,GLIB_001:88;
        E4: 0+1 <= W.find(x) by HEYTING3:1;
            now assume W.find(x) = 1; then
                W.(W.find(x)) = W.first(); then
                W.(W.find(x)) = a by C1,GLIB_001:def 23; then
                 not W.(W.find(x)) in S by A1,A2,DefVS;
              hence contradiction by A6, C2,GLIB_001:def 19;
            end; then
            2*0+1 < W.find(x) by E4,REAL_1:def 5; then
            2*1+1 <= W.find(x) by EvenOdd03; then
        E7: 3+(-2) <= W.find(x)+(-2) by XREAL_1:9; then
            0 <= W.find(x)-2 by XREAL_1:2; then
        E7a: W.find(x)-2 is Element of NAT by INT_1:16; then
            reconsider j=W.find(x)-2*1 as odd Nat;
            W.find(W.k) <= k by E3,GLIB_001:116; then
        E8: W.find(x) <= len W by E3,XREAL_1:2; then
        E6: W.find(x)+(-2) <= len W+0 by XREAL_1:9; 
            per cases;
            suppose D1: W.j in T; 
                W.j in the_Vertices_of G & W.j in W.vertices()
                    by E7a, E6,GLIB_001:8,GLIB_001:88; 
                hence thesis by D1;
            end;
            suppose not W.j in T;
              assume
            F1: not ex y being Vertex of G st y in T & y in W.vertices();
                    set P = W.cut(1,j);
                F4: 2*0+1 <= j & j <= len W by E6,E7; then
                F2a: len P + 1 + (-1) = j + 1 + (-1) by E7a, GLIB_001:37; 
                F3: for n being odd Nat st n <= j holds not P.n in S & P.n=W.n
                    proof let n be odd Nat such that G1: n <= j;
                        1 <= n by HEYTING3:1; then
                        1+(-1) <= n+(-1) by XREAL_1:9; then
                     G0a: n-1 is Element of NAT by INT_1:16;then
                        reconsider nu1 = n-1 as Nat;
                        n < j + 1 by G1,NAT_1:38; then
                        n+(-1) < j+1+(-1) by XREAL_1:10; then
                    G2: P.(nu1+1) = W.(1+nu1) by G0a, F2a,F4,GLIB_001:37;
                        now assume H0: P.n in S;
                        H0a: n in NAT by ORDINAL1:def 13; then
                        H3: P.n in P.vertices() by F2a,G1,GLIB_001:88;
                       P.vertices() c= W.vertices() by E7a, F4,GLIB_001:95;then
                        H5: not P.n in T by H3,F1;
                        H6: {x} c= S by A6,ZFMISC_1:37;
                            S \/ {x} = {x} \/ T by XBOOLE_1:39; then
                            S = {x} \/ T by H6,XBOOLE_1:12; then
                        H7: P.n in {x} by H0,H5,XBOOLE_0:def 2; 
                        H8: n <= len W by E6,G1,XREAL_1:2;
                            n < j + 1 by G1,NAT_1:38; then
                        H9: n+0 < j + 1 + 1 by XREAL_1:10;
                            n < W.find(W.n) by H7,H9,G2,TARSKI:def 1;
                            hence contradiction by H0a, H8,GLIB_001:116;
                        end; 
                        hence thesis by G2;                       
                    end; then
                    for n being odd Nat st n <= j holds not P.n in S; then
                    reconsider HP=P as Walk of H by F2a,Walk02;
                    W.first() = a by C1,GLIB_001:def 23; then
                    P.(2*0+1) = a by E7,F3; then
                    aa in HP.vertices() by A4,E7,F2a,GLIB_001:88; then
                F6: HP.vertices() c= A by GLIB_002:13;
                    P.j in HP.vertices() by F2a,GLIB_001:88; then
                F7: W.j in HP.vertices() by F3; 
                    P.j is Vertex of G by F2a,GLIB_001:8; then
                    reconsider Wj=W.j as Vertex of G by F3;
                    W.find(x) < len W + 1 by E8,NAT_1:38; then
                    W.find(x)+(-2) < len W + 1 + (-2) by XREAL_1:10; then
                    j < len W - 1 & len W +(-1) < len W+0 by XREAL_1:10; then
                    j < len W by XREAL_1:2; then
                    W.(j+1) Joins Wj,W.(j+2),G by E7a, GLIB_001:def 3; then
                    W.(j+1) Joins Wj,x,G by C2,GLIB_001:def 19; then
                    Wj,x are_adjacent by DefAdjacent;
                    hence contradiction by F7,F6,B1;
                end;
            end;
        x in {x} by TARSKI:def 1;  then
    B3: T <> S by A6,XBOOLE_0:def 4;
    B3a: T c= S by XBOOLE_1:36;
    B4: not a in T & not b in T by A1,A2,B3a,DefVS;
        now let W be Walk of G such that C1: W is_Walk_from a,b;
            consider y being Vertex of G such that
        C2: y in S & y in W.vertices() by A1,A2,C1,VS02;
            per cases;
            suppose y = x; 
             hence ex y being Vertex of G st y in T & y in W.vertices()
                     by C1,C2,B2;
            end;
            suppose S0: y <> x; 
              take y;
                not y in {x} by S0, TARSKI:def 1;
              hence y in T by C2,XBOOLE_0:def 4;
              thus y in W.vertices() by C2;
            end;
        end; then T is VertexSeparator of a,b by A1,A2,B4,VS02;
      hence contradiction by A3,B3a,B3,DefVSMin;
end;

theorem VertexSep01: :: VertexSep01
:: Property "symmetry" for 2 argument modes could be used if we had it
:: as VertexSeparator of a,b is a VertexSeparator of b,a
for G being _Graph
for a,b being Vertex of G st a<>b & not a,b are_adjacent
for S being VertexSeparator of a,b st S is minimal
for H being removeVertices of G,S for aa being Vertex of H st aa=b 
for x being Vertex of G st x in S 
    ex y being Vertex of G st y in H.reachableFrom(aa) & x,y are_adjacent
proof let G be _Graph, a,b be Vertex of G such that
A: a<>b and
B: not a,b are_adjacent;
   let S be VertexSeparator of a,b such that
C: S is minimal;
   let H be (removeVertices of G,S), aa be Vertex of H such that
D: aa=b;
   let x be Vertex of G such that
E: x in S;
   reconsider S1 = S as VertexSeparator of b,a by A,B,VS01;
F: S1 is minimal by A, B, C, VS13;
 thus thesis by A,B,D,F,E,VertexSep0;
end;

begin :: Chordal graphs :: Golumbic, p. 81

:: The notion of a chord.  Is it worthwhile having it?

:: definition let G be _Graph, W be Walk of G, e be set;
::   pred e is_chord_of W means  
::   ex m, n being odd Nat st m < n & n <= len W & W.m <> W.n &
::      e Joins W.m,W.n,G &
::      for f being set st f in W.edges() holds not f Joins W.m,W.n,G;
:: end;

:: More general notion of a chordal Walk.  Is such a notion useful? Or
:: should we stick with chordal Path?

definition let G be _Graph, W be Walk of G;
  attr W is chordal means                                      :DefChordalWalk:
  ex m, n being odd natural number st m+2 < n & n <= len W & W.m <> W.n &
     (ex e being set st e Joins W.m,W.n,G) &
     for f being set st f in W.edges() holds not f Joins W.m,W.n,G;
end;

notation let G be _Graph, W be Walk of G;
  antonym W is chordless for W is chordal;
end;

:: The other characterization of chordal is 'more' technical and
:: sometimes more convenient to work with.  Is this really true?
:: I have tried to save as much as possible of what Broderic has already done.
:: Need separate theorems for walks and paths!  They cannot be put as an iff.

theorem ChordalWalk01: :: ChordalWalk01
for G being _Graph, W being Walk of G
 st W is chordal
  ex m,n being odd natural number st m+2 < n & n <= len W & W.m <> W.n &
     (ex e being set st e Joins W.m,W.n,G) &
     (W is Cycle-like implies  not (m=1 & n = len W) &
                               not (m=1 & n = len W-2) &
                               not (m=3 & n = len W))
proof let G be _Graph, W be Walk of G;
  given m, n being odd Nat such that
A: m+2 < n and
B: n <= len W and
C: W.m <> W.n and
D: ex e being set st e Joins W.m,W.n,G and
E: for f being set st f in W.edges() holds not f Joins W.m,W.n,G;
    take m, n;
    thus m+2 < n by A;
    thus n <= len W by B;
    thus W.m <> W.n by C;
    thus ex e being set st e Joins W.m,W.n,G by D;
    assume AC: W is Cycle-like; then
  A1: W is closed by GLIB_001:def 31;
      W is non trivial by AC, GLIB_001:def 31; then
  B1: 3 <= len W by GLIB_001:126; then
  L1: 1 < len W by XREAL_1:2;
  C1a:  W.first() = W.1 & W.last() = W.len W; then
  C1: W.1 = W.len W by A1, GLIB_001:def 24; 
    thus not (m=1 & n = len W) by C, C1a, A1, GLIB_001:def 24;
       2 <= len W by B1, XREAL_1:2; then
       reconsider lW2 = len W -2*1 as odd Element of NAT by INT_1:18;
       reconsider lW2 as odd Nat;
  L1a: lW2 < len W by XREAL_1:46;
       W.(lW2+1) Joins W.(lW2),W.(lW2+2),G by L1a,GLIB_001:def 3; then
  M1a: W.(lW2+1) Joins W.1,W.(lW2),G by C1,GLIB_000:17;
       reconsider le = lW2+1 as even Nat;
  ZM:  le in NAT by ORDINAL1:def 13;
  O1a: 1 <= le by NAT_1:37;
  W1a: le <= len W by L1a,NAT_1:38;
       le div 2 in dom W.edgeSeq() by O1a, W1a, ZM,GLIB_001:78; then
       W.edgeSeq().(le div 2) in rng W.edgeSeq() by FUNCT_1:12; then
       W.(len W -2+1) in W.edges() by O1a, W1a,ZM, GLIB_001:78;   
    hence not (m=1 & n = len W-2) by M1a, E;
  K1: 2*0+1 is odd Nat;
      W.(1+1) Joins W.1,W.(1+2),G by K1,L1,GLIB_001:def 3; then
  M1: W.(1+1) Joins W.(1+2),W.len W,G by C1, GLIB_000:17;
  O1: 2*1 div 2 = 1 by NAT_1:68;
  W1: 1+1 <= len W by B1,XREAL_1:2; 
      1 in dom W.edgeSeq() by O1, W1, GLIB_001:78; then
      W.edgeSeq().1 in rng W.edgeSeq() by FUNCT_1:12; then
      W.(1+1) in rng W.edgeSeq() by O1, W1, GLIB_001:78; 
    hence not (m=3 & n = len W) by M1, E;
end;

theorem ChordalPath01: :: ChordalPath01
for G being _Graph, P being Path of G
 st ex m,n being odd natural number st m+2 < n & n <= len P & 
       (ex e being set st e Joins P.m,P.n,G) &
       (P is Cycle-like implies  not (m=1 & n = len P) &
                                 not (m=1 & n = len P-2) &
                                 not (m=3 & n = len P))
  holds P is chordal
proof let G be _Graph, P be Path of G;
  given m, n being odd Nat such that
A: m+2 < n and
B: n <= len P and
C: ex e being set st e Joins P.m,P.n,G and
D: P is Cycle-like implies
     not (m=1 & n = len P) & not (m=1 & n = len P-2) & not (m=3 & n = len P);
  take m,n;
A0: m in NAT & n in NAT by ORDINAL1:def 13;
E: m < n by A, NAT_1:37;
  thus m+2 < n by A;
  thus n <= len P by B;
F: m < len P by E, B, XREAL_1:2; 
   now assume len P = 1; then m+2 < 1 by A, B, XREAL_1:2; 
    hence contradiction by NAT_1:37;
   end; then
Ta: P is non trivial by GLIB_001:127;
  hereby assume A1: P.m = P.n; then
  B1: m = 1 & n = len P by A0, E, B, GLIB_001:def 28;
      P.first() = P.1 & P.last() = P.len P; then
      P is closed by A1, B1, GLIB_001:def 24;
    hence contradiction by A0, A1,E,B,GLIB_001:def 28, D,Ta,GLIB_001:def 31;
  end;
  thus ex e being set st e Joins P.m,P.n,G by C;
  let f be set such that
K: f in P.edges() and
L: f Joins P.m,P.n,G;
   consider i being Element of NAT such that
M: i in dom P.edgeSeq() and
N: P.edgeSeq().i = f by K,FINSEQ_2:11;
Pa: 1 <= i & i <= len P.edgeSeq() by M, FINSEQ_3:27; then
P: P.edgeSeq().i = P.(2*i) by GLIB_001:def 15;
   set k = 2*i-1;
   2*1 <= 2*i by Pa, XREAL_1:66; then
   2-1 <= k by XREAL_1:11; then
   0 <= k by XREAL_1:2; then
   k is Element of NAT by INT_1:16; then
   reconsider k as odd Nat;
O: k+1 = 2*i;
ZC: k in NAT by ORDINAL1:def 13;
   2*i in dom P by M, GLIB_001:79; then
   2*i <= len P by FINSEQ_3:27; then
R: k < len P by O, NAT_1:38; then
Q: P.(k+1) Joins P.k,P.(k+2),G by ZC,GLIB_001:def 3;
U: k+2 <= len P by R, EvenOdd03;
ZU: k+2 in NAT by ORDINAL1:def 13;
   per cases by Q, P, N, L, GLIB_000:18;
   suppose S1: P.k = P.m & P.(k+2) = P.n;
    per cases by XREAL_1:1;
    suppose k < m; 
     hence contradiction by S1, F, ZC,A0,GLIB_001:def 28;
    end;
    suppose S2: k = m;
     per cases by XREAL_1:1;
     suppose k+2 < n; then
     A3: k+2 = 1 by S1, B,ZU,A0,GLIB_001:def 28;
         1 <= k by HEYTING3:1; then
         k+2 < k+1 by A3, NAT_1:38;
      hence contradiction by XREAL_1:8;
     end;
     suppose k+2 = n; 
       hence contradiction by S2, A;
     end;
     suppose S3: k+2 > n;
       k+2 <= len P by R,EvenOdd03; then
       n = 1 by S1, S3, ZU,A0,GLIB_001:def 28; 
      hence contradiction by A,HEYTING3:1;
     end;
    end;
    suppose k > m; 
     hence contradiction by S1, R, ZC,A0,GLIB_001:def 28;
    end;
   end;
   suppose S1: P.k = P.n & P.(k+2) = P.m;
    per cases by XREAL_1:1;
    suppose S2: k < n; then
    A2: k = 1 & n = len P by S1, B, ZC,A0,GLIB_001:def 28;
     per cases by XREAL_1:1;
     suppose k+2 < m; 
      hence contradiction by S1,F,ZU,A0,GLIB_001:def 28;
     end;
     suppose S3: k+2 = m;
         P.first() = P.1 & P.last() = P.len P; then
         P is closed by A2, S1, GLIB_001:def 24; 
      hence contradiction by A2, S3, D, Ta, GLIB_001:def 31;
    end;
     suppose k+2 > m; then
     A3: m = 1 & k+2 = len P by U, S1, ZU,A0,GLIB_001:def 28;
     B3: k+2 <= n by S2, EvenOdd03; 
         P.first() = P.1 & P.last() = P.len P; then
         P is closed by A3, S1, GLIB_001:def 24; 
      hence contradiction by B3,B,XREAL_1:1,A3, D, Ta, GLIB_001:def 31;
     end;
    end;
    suppose S2: k = n;
     per cases by XREAL_1:1;
     suppose k+2 < m;       hence contradiction by NAT_1:37, S2, E;
     end;
     suppose k+2 = m; 
       hence contradiction by E, S2, NAT_1:37;
     end;
     suppose k+2 > m; then
     A3: m = 1 & k+2 = len P by S1, U, ZU,A0,GLIB_001:def 28;
         P.first() = P.1 & P.last() = P.len P; then
         P is closed by A3, S1, GLIB_001:def 24;
      hence contradiction by A3, D, S2, Ta, GLIB_001:def 31;
     end;
    end;
    suppose k > n;
     hence contradiction by R, S1, ZC,A0,GLIB_001:def 28;
    end;
   end;
end;

theorem ChordalWalk02: :: ChordalWalk02  
for G1,G2 being _Graph st G1 == G2
for W1 being Walk of G1, W2 being Walk of G2
 st W1=W2 holds W1 is chordal implies  W2 is chordal
proof let G1,G2 be _Graph such that A1: G1 == G2;
  let W1 be Walk of G1, W2 be Walk of G2 such that A2: W1 = W2;
  given m, n being odd Nat such that
A: m+2 < n & n <= len W1 & W1.m <> W1.n and
B: ex e being set st e Joins W1.m,W1.n,G1 and
C: for f being set st f in W1.edges() holds not f Joins W1.m,W1.n,G1;
  take m,n;
  thus m+2 < n & n <= len W2 & W2.m <> W2.n by A, A2;
       consider e being set such that
D: e Joins W1.m,W1.n,G1 by B;
   e Joins W2.m,W2.n,G2 by D, A1, A2, GLIB_000:91;
  hence ex e being set st e Joins W2.m,W2.n,G2;
  let f be set;
  assume f in W2.edges(); then f in W1.edges() by A2, GLIB_001:111; then
    not f Joins W1.m,W1.n,G1 by C;
  hence not f Joins W2.m,W2.n,G2 by A1, A2, GLIB_000:91;
end;

theorem ChordalWalk03: :: ChordalWalk03  
for G being _Graph, S being non empty Subset of the_Vertices_of G,
    H being (inducedSubgraph of G,S), W1 being Walk of G, W2 being Walk of H
  st W1 = W2 holds W2 is chordal iff W1 is chordal
proof let G be _Graph, S be non empty Subset of the_Vertices_of G,
      H be (inducedSubgraph of G,S), W1 be Walk of G, W2 be Walk of H such that
A2: W1 = W2;
A3: S = the_Vertices_of H by GLIB_000:def 39;
 thus W2 is chordal implies W1 is chordal
 proof  given m, n being odd Nat such that
A: m+2 < n & n <= len W2 & W2.m <> W2.n and
B: ex e being set st e Joins W2.m,W2.n,H and
C: for f being set st f in W2.edges() holds not f Joins W2.m,W2.n,H;
  take m,n;
  thus m+2 < n & n <= len W1 & W1.m <> W1.n by A, A2;
       consider e being set such that
D: e Joins W2.m,W2.n,H by B;
   e Joins W1.m,W1.n,G by D, A2, GLIB_000:75;
  hence ex e being set st e Joins W1.m,W1.n,G;
  let f be set;
  assume f in W1.edges(); then 
F: f in W2.edges() by A2, GLIB_001:111; then
   not f Joins W1.m,W1.n,H by C, A2;
  hence not f Joins W1.m,W1.n,G by F, GLIB_000:76;
 end;
 thus W1 is chordal implies W2 is chordal
 proof given m, n being odd Nat such that
A: m+2 < n & n <= len W1 & W1.m <> W1.n and
B: ex e being set st e Joins W1.m,W1.n,G and
C: for f being set st f in W1.edges() holds not f Joins W1.m,W1.n,G;
  take m,n;
ZC: m in NAT & n in NAT by ORDINAL1:def 13;
  thus m+2 < n & n <= len W2 & W2.m <> W2.n by A, A2;
       consider e being set such that
D: e Joins W1.m,W1.n,G by B;
   m < n by A, NAT_1:37; then
   m <= len W2 by A, A2, XREAL_1:2; then
   W1.m in the_Vertices_of H & W1.n in the_Vertices_of H
        by A,A2,ZC,GLIB_001:8;
     then e Joins W2.m,W2.n,H  by A2, A3, D, Joins01;
  hence ex e being set st e Joins W2.m,W2.n,H;
  let f be set;
  assume f in W2.edges(); then
   f in W1.edges() by A2, GLIB_001:111; then
   not f Joins W2.m,W2.n,G by C, A2;
  hence not f Joins W2.m,W2.n,H by GLIB_000:75;
 end;
end;

theorem 
for G being _Graph, W being Walk of G
 st W is Cycle-like & W is chordal & W.length()=4
    holds ex e being set st e Joins W.1,W.5,G or e Joins W.3,W.7,G
proof let G be _Graph, W be Walk of G such that
A1: W is Cycle-like & W is chordal and
A2: W.length() = 4;
    W is closed by A1,GLIB_001:def 31; then
ZZ: W.first() = W.last() by GLIB_001:def 24;
A3: len W = 2*4+1 by A2,GLIB_001:113; 
 assume A4: not(ex e being set st e Joins W.1,W.5,G or e Joins W.3,W.7,G);
    consider m, n being odd Nat such that
B1: m+2 < n & n <= len W & W.m <> W.n &
    (ex e being set st e Joins W.m,W.n,G) &
    (W is Cycle-like implies (not (m=1 & n = len W) &
    not (m=1 & n = len W-2) & not (m=3 & n = len W))) by A1,ChordalWalk01;
    consider e being set such that
A5: e Joins W.m,W.n,G by B1;
B2: 0+1 <= m by HEYTING3:1;
    now assume C1: m = 1; then
            n < len W by A1,B1,REAL_1:def 5; then
        C2: n <= 9 - 2 by A3,EvenOdd02;
            reconsider jj=2*3+1 as odd Nat;
            n < jj by A1,A3,B1,C1,C2,REAL_1:def 5; then
        C3: n <= jj-2 by EvenOdd02;
            n <> 5 by A5,C1,A4; then n < 2*2+1 by C3,REAL_1:def 5; then
            n <= 5-2 by EvenOdd02;
            hence contradiction by B1, C1;
    end; then 2*0+1 < m by B2,REAL_1:def 5; then
    B3: 1+2 <= m by EvenOdd03;
        now assume C1: m = 3; then
            n < len W by A1,B1,REAL_1:def 5; then
        C2: n <= 9 - 2 by A3,EvenOdd02; 
            n <> 7 by A5,C1,A4; then n < 2*3+1 by C2,REAL_1:def 5; then
            n <= 7 - 2 by EvenOdd02; 
            hence contradiction by B1, C1;
        end; then 2*1+1 < m by B3,REAL_1:def 5; then
    B4: 3+2 <= m by EvenOdd03;
        now assume C1: m = 5;
            now assume n = 9; then
                e Joins W.1,W.5,G by C1,A5,A3,ZZ,GLIB_000:17;
                hence contradiction by A4;
            end; then n < len W by B1,A3,REAL_1:def 5; then
            n <= len W - 2 by EvenOdd02;
            hence contradiction by A3,C1,B1;            
        end; then 2*2+1 < m by B4,REAL_1:def 5; then
        5+2 <= m by EvenOdd03; then
        7+2 <= m + 2 by XREAL_1:9;
        hence contradiction by A3,B1,XREAL_1:2;
end;

theorem MinChordal01: :: MinChordal01
for G being _Graph, W being Walk of G st W is minlength holds W is chordless
proof  
  let G be _Graph, W be Walk of G; assume
A: W is minlength; assume
  W is chordal; then
  consider m,n being odd Nat such that
C: m+2 < n and
D: n <= len W and
   W.m <> W.n and
E: ex e being set st e Joins W.m,W.n,G and
   (W is Cycle-like implies not (m=1 & n = len W) &
                            not (m=1 & n = len W-2) &
                            not (m=3 & n = len W)) by ChordalWalk01;
 thus contradiction by A, C, D, E, TopPath03;
end;

theorem 
for G being _Graph, W being Walk of G
 st W is open & len W = 5 & not W.first(),W.last() are_adjacent
  holds W is chordless
proof let G be _Graph, W be Walk of G such that
A1: W is open & len W = 5 & not W.first(),W.last() are_adjacent;
    assume W is chordal; then
    consider m,n being odd Nat such that
A2: m+2 < n & n <= len W & W.m <> W.n and
A3: ex e being set st e Joins W.m,W.n,G and
     (W is Cycle-like implies  not (m=1 & n = len W) &
                               not (m=1 & n = len W-2) &
                               not (m=3 & n = len W)) by ChordalWalk01;
    consider e being set such that
A4: e Joins W.m,W.n,G by A3;
A5: now assume m <> 1; then 1 <> m & 1 <= m by Nat02; then
       2*0+1 < m by REAL_1:def 5; then
       1+2 <= m by EvenOdd03; then 
       3+2 <= m+2 by XREAL_1:9;
      hence contradiction by A2,A1,XREAL_1:2;
    end; then 
    3+2 <= n by EvenOdd03, A2; then
    W.n = W.last() by A1,A2,XREAL_1:1; 
  hence contradiction by A1,A4,A5,DefAdjacent;
end;

CPath01Helper:
for G being _Graph, W being Walk of G holds
   W is chordal implies W.reverse() is chordal
proof let G be _Graph, W be Walk of G;
    set U = W.reverse();
    assume W is chordal; then
    consider m, n being odd Nat such that
A1: m+2 < n & n <= len W & W.m <> W.n and
A2: ex e being set st e Joins W.m,W.n,G and
A3: for f being set st f in W.edges() holds not f Joins W.m,W.n,G
       by DefChordalWalk;
ZC: m in NAT & n in NAT by ORDINAL1:def 13;
    consider e being set such that
A4: e Joins W.m,W.n,G by A2;
    m < m+2 by XREAL_1:31; then
    m < n by A1,XREAL_1:2; then
Z1: 1 <= m & m <= len W & 1 <= n & n <= len W by Nat02,A1,XREAL_1:2; then
Z2: m in dom W & n in dom W by FINSEQ_3:27;

    set um = len W - m + 1, un = len W - n + 1;
    reconsider um, un as odd Element of NAT by Z1,ZC,FINSEQ_5:1; 
    reconsider um, un as odd Nat;
A5: un + 2 < um by A1,Nat03;
    0 < m by Z1,XREAL_1:2; then
    len W - m < len W by XREAL_1:46; then
    len W - m + 1 <= len W by INT_1:20; then
A6: um <= len U by GLIB_001:22;
A7: W.edges() = U.edges() by GLIB_001:108;
A8: W.m = U.um & W.n = U.un & un in dom U & um in dom U by Z2,GLIB_001:25;
A9: now let f be set such that B1: f in U.edges();
      assume f Joins U.un,U.um,G; then
        f Joins W.m,W.n,G by A8,GLIB_000:17;
      hence contradiction by B1,A7,A3;
    end;
    e Joins U.un,U.um,G by A4,A8,GLIB_000:17;
  hence U is chordal by A5,A6,A8,A1,A9,DefChordalWalk;
end;

theorem 
for G being _Graph, W being Walk of G
  holds W is chordal iff W.reverse() is chordal
proof let G be _Graph, W be Walk of G;
   thus W is chordal implies  W.reverse() is chordal by CPath01Helper;
   assume W.reverse() is chordal; then
   W.reverse().reverse() is chordal by CPath01Helper;
   hence W is chordal by GLIB_001:27;
end;

theorem CPath03: :: CPath03
for G being _Graph, P being Path of G st P is open & P is chordless
  for m,n being odd natural number st m < n & n <= len P holds
    (ex e being set st e Joins P.m,P.n,G) iff m+2 = n
proof let G be _Graph, P be Path of G such that
A1: P is open & P is chordless;
    let m,n be odd Nat such that
A2: m < n & n <= len P;
ZC: m in NAT & n in NAT by ORDINAL1:def 13;
A3: P.m <> P.n by A1,A2,ZC,GLIB_001:148;
A4: P is vertex-distinct by A1,PDistinct;
A5: m <= len P by A2,XREAL_1:2;
  hereby assume B1: ex e being set st e Joins P.m,P.n,G;
  B2: m+2 <= n by A2,EvenOdd03;
      now assume B3: m+2 < n;
        now let f be set such that C1: f in P.edges();
            consider k being odd Element of NAT such that
        C2: k < len P & P.(k+1) = f by C1,GLIB_001:101;
        C5: k+2 <= len P by C2,EvenOdd03;
        C3: f Joins P.k,P.(k+2),G by C2,GLIB_001:def 3;
          assume CC: f Joins P.m,P.n,G; 
          per cases by CC,C3,GLIB_000:18;
          suppose P.m = P.k & P.n = P.(k+2); then
            m = k & n = k+2*1 by A5,A2,C2,C5,A4,ZC,GLIB_001:def 29;
          hence contradiction by B3; end;
          suppose P.m = P.(k+2) & P.n = P.k; then
          D1: m = k+2*1 & n = k by A5,A2,C2,C5,A4,ZC,GLIB_001:def 29; 
          D2: m > n by D1,XREAL_1:31;
              m+2 > m by XREAL_1:31;
          hence contradiction by B3,D2,XREAL_1:2; end;
        end; 
        hence contradiction by A1,A2,A3,B1,B3,DefChordalWalk;
      end; 
   hence m+2 = n by B2,XREAL_1:1;
  end;
  assume B1: m+2 = n;
  take P.(m+1);
    m < len P by A2,XREAL_1:2; 
  hence P.(m+1) Joins P.m,P.n,G by B1,ZC,GLIB_001:def 3;
end;

theorem 
for G being _Graph, P being Path of G st P is open & P is chordless
for m,n being odd natural number st m < n & n <= len P 
  holds P.cut(m,n) is chordless & P.cut(m,n) is open
proof let G be _Graph, P be Path of G such that
A1: P is open & P is chordless;
    let m,n be odd Nat such that A2: m < n & n <= len P;
    set Q = P.cut(m,n);
ZB: m in NAT & n in NAT by ORDINAL1:def 13;
  now assume Q is chordal; then
    consider i,j being odd Nat such that
A3: i+2 < j & j <= len Q & Q.i <> Q.j and
A4: ex e being set st e Joins Q.i,Q.j,G and
    for f being set st f in Q.edges() holds not f Joins Q.i,Q.j,G
       by DefChordalWalk;
    consider e being set such that
A6: e Joins Q.i,Q.j,G by A4;
    set mi = m+i-1;  set mj = m+j-1;
    i+0<i+2 by XREAL_1:10; then
    i<j by A3,XREAL_1:2; then
    1 <= i & i < len Q by A3,Nat02,XREAL_1:2; then
A8a: i in dom Q by FINSEQ_3:27; then
A8: Q.i = P.mi & mi in dom P by A2,ZB,GLIB_001:48;
    1 <= j & j <= len Q by A3,Nat02; then
    j in dom Q by FINSEQ_3:27; then
A9: Q.j = P.mj & mj in dom P by A2,ZB,GLIB_001:48;
    reconsider mi as odd Element of NAT by A8;
    reconsider mi as odd Nat;
    reconsider mj as odd Element of NAT by A9;
    reconsider mj as odd Nat;
B1: e Joins P.mi,P.mj,G by A8a, A2,ZB,GLIB_001:48,A9,A6;
    i+2+m < j+m by A3,XREAL_1:10; then
B4a: m+i+2-1 < m+j-1 by XREAL_1:11; then
B4: mi+2 < mj;
    mi+0 < mi+2 by XREAL_1:10; then
B2: mi < mj by B4a,XREAL_1:2;
    mj <= len P by A9,FINSEQ_3:27;
  hence contradiction by B4, A1,B1,B2,CPath03;
  end;
  hence Q is chordless;
  now assume Q is closed; then
  B1: Q.first() = Q.last() by GLIB_001:def 24;
      P.m = Q.first() & P.n = Q.last() by A2,ZB,GLIB_001:38;
    hence contradiction by B1, A1,A2,ZB,GLIB_001:148;
  end;
  hence Q is open;
end;

theorem 
for G being _Graph, S being non empty Subset of the_Vertices_of G,
    H being (inducedSubgraph of G,S), W being Walk of G, V being Walk of H
 st W = V holds W is chordless iff V is chordless
proof let G be _Graph, S be non empty Subset of the_Vertices_of G;
    let H be inducedSubgraph of G,S;
    let W be Walk of G, V be Walk of H such that
A0: W = V;
    hereby assume A1: W is chordless; 
    assume V is chordal; then
    consider m,n being odd Nat such that
A2: m+2 < n & n <= len V & V.m <> V.n and
A3: (ex e being set st e Joins V.m,V.n,H) and
A4: for f being set st f in V.edges() holds not f Joins V.m,V.n,H
      by DefChordalWalk;
ZC: m in NAT & n in NAT by ORDINAL1:def 13;
    consider e being set such that
Ae: e Joins V.m,V.n,H by A3; 
A5: e Joins W.m,W.n,G by A0, Ae,GLIB_000:75;
    m+0 <= m+2 by XREAL_1:9; then m <= n by A2,XREAL_1:2; then
    m <= len V by A2,XREAL_1:2; then
    V.n in V.vertices() & V.m in V.vertices() by A2,ZC,GLIB_001:88; then
    V.n in the_Vertices_of H & V.m in the_Vertices_of H; then
A8: V.n in S & V.m in S by GLIB_000:def 39;
    for f being set st f in W.edges() holds not f Joins W.m,W.n,G proof
        let f be set such that B1: f in W.edges();
        assume B2a: f Joins W.m,W.n,G;
    B2: f Joins V.m,V.n,H by A0, A8,B2a,Joins01;
        f in V.edges() by A0,B1,GLIB_001:111; 
      hence contradiction by A4,B2;        
    end;
  hence contradiction by A1,DefChordalWalk,A5,A0,A2;
  end;
    assume
A1: V is chordless;
    assume W is chordal; then
    consider m,n being odd Nat such that
A2: m+2 < n & n <= len W & W.m <> W.n and
A3: (ex e being set st e Joins W.m,W.n,G) and
A4: for f being set st f in W.edges() holds not f Joins W.m,W.n,G
      by DefChordalWalk;
ZC: m in NAT & n in NAT by ORDINAL1:def 13;
    consider e being set such that
Ae: e Joins W.m,W.n,G by A3;

    m+0 <= m+2 by XREAL_1:9; then m <= n by A2,XREAL_1:2; then
    m <= len W by A2,XREAL_1:2; then
    W.n in V.vertices() & W.m in V.vertices() by A0,A2,ZC,GLIB_001:88; then
    W.n in the_Vertices_of H & W.m in the_Vertices_of H; then
    W.n in S & W.m in S by GLIB_000:def 39; then
A5: e Joins V.m,V.n,H by A0, Ae,Joins01;
    for f being set st f in V.edges() holds not f Joins V.m,V.n,H proof
        let f be set such that B1: f in V.edges();
        assume B2a: f Joins V.m,V.n,H;
    B2: f Joins W.m,W.n,G by A0, B2a,GLIB_000:75;
        f in W.edges() by A0,B1,GLIB_001:111; 
      hence contradiction by A4,B2;        
    end;
  hence contradiction by A1,DefChordalWalk,A5,A0, A2;
end;

definition let G be _Graph;
 attr G is chordal means                                     :DefChordalGraph:
  for P being Walk of G st P.length() > 3 & P is Cycle-like holds P is chordal;
end;

theorem Chordal01: :: Chordal01
for G1,G2 being _Graph st G1 == G2 holds G1 is chordal implies G2 is chordal
proof
    let G1,G2 be _Graph such that A1: G1 == G2;
    assume A2: G1 is chordal;
    now let W be Walk of G2 such that A3: W.length() > 3 & W is Cycle-like;
        reconsider W2=W as Walk of G1 by A1,GLIB_001:180;
        2*W2.length() + 1 = len W by GLIB_001:113; then
    A4: 2*W2.length() + 1 = 2*W.length() + 1 by GLIB_001:113; 
        W2 is Cycle-like by A3,A1,Cyclelike01; then
        W2 is chordal by A4,A3,A2,DefChordalGraph;
        hence W is chordal by A1,ChordalWalk02;
    end;
    hence thesis by DefChordalGraph;
end;

theorem Chordal02: :: Chordal02
for G being finite _Graph st card the_Vertices_of G <= 3 holds G is chordal
proof let G be finite _Graph such that A1: card the_Vertices_of G <= 3;
    now let W be Walk of G such that A2: W.length() > 3 & W is Cycle-like;
        reconsider n1=2*0+1 as odd Nat; reconsider n2=2*1+1 as odd Nat;
        reconsider n3=2*2+1 as odd Nat; reconsider n4=2*3+1 as odd Nat;
        set x1=W.n1; set x2=W.n2; set x3=W.n3; set x4=W.n4;
        W.length() >= 3+1 by A2,NAT_1:38; then
        2*W.length() >= 2*4 by XREAL_1:66; then
        2*W.length() + 1 >= 8 + 1 by XREAL_1:9; then
        len W >= 9 by GLIB_001:113; then
    T1: n1 < len W & n2 < len W & n3 < len W & n4 < len W by XREAL_1:2;
    T0: W is Path-like by A2, GLIB_001:def 31;
    A4: x1 <> x2 by T0, T1,GLIB_001:def 28;
    A5: x1 <> x3 by T0, T1,GLIB_001:def 28;
    A6: x1 <> x4 by T0, T1,GLIB_001:def 28;
    A7: x2 <> x3 by T0, T1,GLIB_001:def 28;
    A8: x2 <> x4 by T0, T1,GLIB_001:def 28;
    A9: x3 <> x4 by T0, T1,GLIB_001:def 28;
   A10: card {x1,x2,x3,x4} = 4 by A4,A5,A6,A7,A8,A9,CARD_2:78;
        now let x be set; assume B1: x in {x1,x2,x3,x4};
          now per cases by B1,ENUMSET1:def 2;
            suppose x=x1; hence x in the_Vertices_of G by T1,GLIB_001:8; end;
            suppose x=x2; hence x in the_Vertices_of G by T1,GLIB_001:8; end;
            suppose x=x3; hence x in the_Vertices_of G by T1,GLIB_001:8; end;
            suppose x=x4; hence x in the_Vertices_of G by T1,GLIB_001:8; end;
            end;
          hence x in the_Vertices_of G;
        end; then          
        {x1,x2,x3,x4} c= the_Vertices_of G by TARSKI:def 3; then
        4 <= card the_Vertices_of G by A10,CARD_1:80;
        hence contradiction by A1,XREAL_1:2;        
    end; then for W being Walk of G st W.length() > 3 & W is Cycle-like
              holds W is chordal;
    hence G is chordal by DefChordalGraph;
end;

registration
  cluster trivial finite chordal _Graph;
  existence proof
      consider G being trivial finite _Graph;
      consider v being Vertex of G such that
  A0: the_Vertices_of G = {v} by GLIB_000:25;
      now let W be Walk of G such that A1: W.length() > 3 & W is Cycle-like;
          2*W.length() > 2*3 by A1,XREAL_1:70; then
          2*W.length() + 1 > 6 + 1 by XREAL_1:10; then
      A2: len W > 7 by GLIB_001:113;
          reconsider j3=2*1+1 as odd Nat;
          reconsider j5=2*2+1 as odd Nat;
      A4: j3 <= len W & j5 <= len W by A2,XREAL_1:2; then
          W.j3 in W.vertices() & W.j5 in W.vertices() by GLIB_001:88; then
          W.j3 = v & W.j5 = v by A0, TARSKI:def 1;
          then not W is Path-like by A4, GLIB_001:def 28;
          hence contradiction by A1, GLIB_001:def 31;
      end; then
      for W being Walk of G st W.length() > 3 & W is Cycle-like
          holds W is chordal;
      then G is chordal by DefChordalGraph;
      hence thesis;
  end;

  cluster non trivial finite simple chordal _Graph;
  existence proof
    set V = {0,1}, E = {0}, S = 0 .--> 0, T = 0 .--> 1;
A1: dom S = E & dom T = E by CQC_LANG:5;
    now let x be set; assume x in E; then
        x = 0 by TARSKI:def 1; then
        S.x = 0 by CQC_LANG:6;
        hence S.x in V by TARSKI:def 2;
    end; then reconsider S as Function of E,V by A1, FUNCT_2:5;
    now let x be set; assume x in E; then
        x = 0 by TARSKI:def 1; then
        T.x = 1 by CQC_LANG:6;
        hence T.x in V by TARSKI:def 2;
    end; then reconsider T as Function of E,V by A1, FUNCT_2:5;
    set G = createGraph(V,E,S,T);
A2: the_Vertices_of G = V & the_Edges_of G = E & the_Source_of G = S &
      the_Target_of G = T by GLIB_000:8;
    take G;
    now assume Card (the_Vertices_of G) = 1; then
        consider x being set such that
    B1: the_Vertices_of G = {x} by CARD_2:60;
        thus contradiction by A2,B1,ZFMISC_1:9;
    end;
    hence G is non trivial & G is finite by GLIB_000:def 21;
A4: (the_Source_of G).0 = 0 by A2,CQC_LANG:6;
A5: (the_Target_of G).0 = 1 by A2,CQC_LANG:6;
    0 in the_Edges_of G by A2,TARSKI:def 1; then
A6: 0 Joins 0,1,G by A4,A5,GLIB_000:def 15;
    now let v be set;
        let e being set such that B1: e Joins v,v,G;
        reconsider v as Vertex of G by B1,GLIB_000:16;
        e in the_Edges_of G by B1,GLIB_000:def 15; then
        e Joins 0,1,G by A6, A2,TARSKI:def 1; then
        (0 = v & 1 = v) or (0 = v & 1 = v) by B1,GLIB_000:18;
        hence contradiction;
    end; then
A3: G is loopless by GLIB_000:21;
    now let e1,e2,v1,v2 be set such that
    B1: e1 Joins v1,v2,G & e2 Joins v1,v2,G;
        assume B2: e1 <> e2;
        e1 in {0} & e2 in {0} by A2,B1,GLIB_000:def 15; then
        e1 = 0 & e2 = 0 by TARSKI:def 1;
        hence contradiction by B2;
    end; then G is non-multi by GLIB_000:def 22;
    hence G is simple by A3,GLIB_000:def 24;
    card the_Vertices_of G = 2 by A2, CARD_2:76;
    hence G is chordal by Chordal02;
  end;

  cluster complete -> chordal _Graph;
  correctness proof
    let G be _Graph; assume A1: G is complete;
    now let W be Walk of G such that A2: W.length() > 3 & W is Cycle-like;
    A:  W is Path-like by A2,GLIB_001:def 31;
        W.length() >= 3+1 by A2,NAT_1:38; then
        2*W.length() >= 2*4 by XREAL_1:66; then
        2*W.length() + 1 >= 8 + 1 by XREAL_1:9; then
    A3: len W >= 9 by GLIB_001:113;
        reconsider t3=2*1+1 as odd Nat;
        reconsider t7=2*3+1 as odd Nat;
        t3 <= len W by A3,XREAL_1:2; then
        reconsider W3=W.t3 as Vertex of G by GLIB_001:8;
    A5: t7 <= len W by A3,XREAL_1:2; then
        reconsider W7=W.t7 as Vertex of G by GLIB_001:8;
        W3 <> W7 by A, A5,GLIB_001:def 28;
        then W3,W7 are_adjacent by A1,DefComplete; then
        consider e being set such that
    A4: e Joins W3,W7,G by DefAdjacent;
        t3+2 < t7 & t7 <= len W & not (t3=3 & t7 = len W) by A3,XREAL_1:2;
        hence W is chordal by A, A4,ChordalPath01;
    end;
    hence G is chordal by DefChordalGraph;
  end;
end;

registration let G be chordal _Graph, V be set;
  cluster -> chordal inducedSubgraph of G,V;
  coherence proof
    let H be inducedSubgraph of G,V;
    now per cases;
    suppose not V is non empty Subset of the_Vertices_of G;
        then H == G by GLIB_000:def 39;
        hence H is chordal by Chordal01; end;
    suppose V is non empty Subset of the_Vertices_of G; then
    Aa: V = the_Vertices_of H by GLIB_000:def 39;
    now let W be Walk of H such that
    A1: W.length() > 3 and A2: W is Cycle-like;
    A: W is Path-like by A2, GLIB_001:def 31;
        reconsider P=W as Walk of G by GLIB_001:168;
        reconsider P as Path of G by A, GLIB_001:176;
        W is closed & W is non trivial & W is Path-like
            by A2,GLIB_001:def 31; then
   A3a: P is closed & P is non trivial & P is Path-like by GLIB_001:177; then
    A3: P is Cycle-like by GLIB_001:def 31;
        P.length() > 3 by A1,GLIB_001:115; then
        P is chordal by A3,DefChordalGraph; then
        consider m, n being odd Nat such that A4: m+2 < n & n <= len P and
        P.m <> P.n and
    A5: (ex e being set st e Joins P.m,P.n,G) &
        (P is Cycle-like implies
        not (m=1 & n = len P) & not (m=1 & n = len P-2) &
        not (m=3 & n = len P)) by ChordalWalk01;
    ZC: m in NAT & n in NAT by ORDINAL1:def 13;
        consider e being set such that
    A6: e Joins P.m,P.n,G by A5;
        m + 0 <= m + 2 by XREAL_1:9; then
        m <= n by A4,XREAL_1:2; then
        m <= len P by A4,XREAL_1:2; then
        P.m in the_Vertices_of H & P.n in the_Vertices_of H
            by A4,ZC,GLIB_001:8; then
        e Joins P.m,W.n,H by Aa,A6,Joins01;
        hence W is chordal by A,A3a,GLIB_001:def 31,A4,A5,ChordalPath01;
    end;
    hence H is chordal by DefChordalGraph; end; end;
    hence H is chordal; 
  end;
end;

theorem 
for G being chordal _Graph, P being Path of G st P is open & P is chordless
for x,e being set st (not x in P.vertices() & e Joins P.last(),x,G &
                      not ex f being set st f Joins P.(len P-2),x,G)
  holds P.addEdge(e) is Path-like & P.addEdge(e) is open &
        P.addEdge(e) is chordless
proof let G be chordal _Graph, P be Path of G such that
A1: P is open & P is chordless;
    let x,e be set such that
A2: not x in P.vertices() and
A3: e Joins P.last(),x,G and
A4: not ex f being set st f Joins P.(len P-2),x,G;
    reconsider Q = P.addEdge(e) as Path of G by A1,A2,A3,GLIB_001:152;
A5: now let n be odd Nat such that B1: n <= len P;
       1 <= n & n <= len P by Nat02,B1; then
       n in dom P by FINSEQ_3:27; 
      hence P.n = Q.n by A3,GLIB_001:66;
    end;
A6: Q.first() = P.first() & Q.last() = x by A3,GLIB_001:64;
P1: Q.first() in P.vertices() by A6,GLIB_001:89; 
A7: len Q = len P + 2 by A3,GLIB_001:65;

:: this proof turned into something of a nightmare...
:: cleaner way to do it?
    defpred P[Nat] means
      (4 <= 2*$1 & 2*$1 <= len P+1) implies
        for j being odd Nat st j + 2*$1 = len P + 2 holds
           not ex e being set st e Joins Q.j,x,G;
II: for k being Nat st for a being Nat st a < k holds P[a] holds P[k] proof
        let k be Nat such that B1: for a being Nat st a < k holds P[a];
        assume B2: 4 <= 2*k & 2*k <= len P+1;
        let j be odd Nat such that B3: j + 2*k = len P + 2;
        let e be set such that B4: e Joins Q.j,x,G;
    ZA: k in NAT & j in NAT by ORDINAL1:def 13;
        j + 4 <= j + 2*k by B2,XREAL_1:9; then
    B5: j + 4 - 4 <= len P + 2 - 4 by B3,XREAL_1:11;
   B5a: len P - 2 <= len P by XREAL_1:45; then
   B5b: j <= len P by B5,XREAL_1:2;
      per cases by B5,REAL_1:def 5;
      suppose C1: j = len P - 2; 
        Q.j = P.(len P - 2) by A5,B5a,C1; 
      hence contradiction by B4,A4; end;
      suppose E0: j < len P - 2*1;
        len P < len P + 2 by XREAL_1:31; then
    E2: j <= len P + 2 by B5b,XREAL_1:2;

        reconsider jj = j as odd Element of NAT by ORDINAL1:def 13;
        reconsider lP2 = len P+2 as odd Element of NAT;

        set B = Q.cut(jj,lP2);
    EVa: len B + j = len P + 2 + 1 by A7,E2,GLIB_001:37; 
    E4b: len P + 3 - (len P - 2) < len P + 3 - j by E0,XREAL_1:17; then
   E4a: 3 < len B by EVa,XREAL_1:2;
   E71a: B.first() = Q.j & B.last() = Q.(len P + 2)
             by E2,A7,GLIB_001:38;
   E71: B.first() = Q.j & B.last() = x by A6,E2,A7,GLIB_001:38; 
        P.vertexAt(j) = P.j by B5b,GLIB_001:def 8; then
        P.j in P.vertices() by ZA,B5b,GLIB_001:90;  then
        B.first() in P.vertices() by E71a,B5b,A5; then
    E5: B is open by E71,A2,GLIB_001:def 24;
    E6: now let i be even Nat such that F1: i < len B-1;
        ZB: i in NAT by  ORDINAL1:def 13;
            len B - 1 < len B by XREAL_1:46; then
            i < len B by F1,XREAL_1:2; then
        F2: B.(i+1) = Q.(j+i) & j+i in dom Q by A7,E2,ZB,GLIB_001:37;then
        F3: 1 <= j + i & j + i <= len P + 2 by A7,FINSEQ_3:27;
           j + i < (len B - 1) + j by F1,XREAL_1:10; then
           j + i <= len P + 2 - 2 by EVa,EvenOdd02; 
           hence B.(i+1) = P.(j+i) & j+i in dom P by A5,F2,F3,FINSEQ_3:27;
        end;

        set C = B.addEdge(e);
    CA: e Joins B.last(),B.first(),G by B4,E71,GLIB_000:17; 
    E7: now let n be odd Nat such that C1: n <= len B;
           1 <= n & n <= len B by Nat02,C1; then
           n in dom B by FINSEQ_3:27;
         hence C.n = B.n by CA,GLIB_001:66;
        end;
    CC: C is Cycle-like by CA,E4a,E5,PathLike15; 

    CD: C.first() = Q.j & C.last() = Q.j
             by E71a,CA,GLIB_001:64;
    C1: len C = len B + 2 by CA,GLIB_001:65; 
        len B + 2 > 5 + 2 by E4b,EVa, XREAL_1:10; then
   C1a: len C > 7 by CA,GLIB_001:65; 
        now assume C.length() <= 3; then
            2*C.length() <= 2*3 by XREAL_1:66; then
            2*C.length()+1 <= 2*3+1 by XREAL_1:8;
          hence contradiction by C1a,GLIB_001:113;
        end; then
        C is chordal by CC,DefChordalGraph; then
        consider m,n being odd Nat such that
    C2: m+2 < n & n <= len C & C.m <> C.n and
    C3: ex e being set st e Joins C.m,C.n,G and
    CZ: (C is Cycle-like implies  not (m=1 & n = len C) &
                                  not (m=1 & n = len C-2) &
                                  not (m=3 & n = len C)) by ChordalWalk01;
        consider e being set such that
    C4: e Joins C.m,C.n,G by C3;

        1 <= m by Nat02; then 1-1 <= m-1 by XREAL_1:11; then
        reconsider m1 = m-1 as even Element of NAT by INT_1:16; 
        reconsider m1 as even Nat;
        1 <= n by Nat02; then 1-1 <= n-1 by XREAL_1:11; then
        reconsider n1 = n-1 as even Element of NAT by INT_1:16; 
        reconsider n1 as even Nat;
        m < m+2 by XREAL_1:31; then
        m < n by C2,XREAL_1:2; then
    DD: m1 < n1 by XREAL_1:11;
    DZ: m+2-1 <n-1 by C2,XREAL_1:11; 
        m+2 < len B+2 by C2,XREAL_1:2,C1; then
    C5a: m+2-2 < len B+2-2 by XREAL_1:11; 
        m1 < len B-1 by C5a, XREAL_1:11; then
    C7a: B.(m1+1) = P.(j+m1) & j+m1 in dom P by E6; then
    C7: B.m = P.(j+m1) & j+m1 <= len P by FINSEQ_3:27;
        now assume D0: n = len C; then
             e Joins P.(j+m1),Q.j,G by CD,C4,C7a,E7,C5a; then
             e Joins P.(j+m1),P.j,G by A5,B5b; then
         D1: e Joins P.j,P.(j+m1),G by GLIB_000:17;
            now assume m <= 3; then m <= 4 by XREAL_1:2;
              hence contradiction by D0,CZ,CA,E4a,E5,PathLike15,Odd101;
            end; then 
        D3a: 2+1-1 < m-1 by XREAL_1:11; 
        D4: j + 2 < j+m1 by D3a, XREAL_1:10;
            0 < m1 by D3a,XREAL_1:2; then 
            j < j+m1 by XREAL_1:31;
          hence contradiction by D1,D4,A1,C7,CPath03;
        end; then n < len B+2*1 by C1,C2,REAL_1:def 5; then
    C8: n <= len B+2-2 by EvenOdd02;

        now assume D1: n = len B; 
        D6: C.n = x by D1,E71,E7;
            1 <> m & 1 <= m by Nat02,D1,C1,CZ,CA,E4a,E5,PathLike15; then
            1 < m by REAL_1:def 5; then
        DE: 1-1 < m-1 by XREAL_1:11;
             j+m1 <= len P & len P < len P + 2
                by C7a,FINSEQ_3:27,XREAL_1:31; then
         j+m1 < len P+2*1 by XREAL_1:2; then
            consider kk being Nat such that
        D2: (j+m1) + 2*kk = len P+2 by OddDiff00;
        D3a:   now assume 2*kk < 3+1; then 2*kk <= 3 by NAT_1:38; then
                  2*kk = 0 or 2*kk = 2 by Even101;
              hence contradiction by D1,C2,EVa,D2;
            end; 
        D4a:  now assume 2*kk > len P + 1; then
            E1a:2*kk >= len P + 1 + 1 by NAT_1:38; 
              2*kk + m1 > 2*kk & 2*kk + m1 +j >= 2*kk + m1
                 by DE,XREAL_1:31,NAT_1:29;
              hence contradiction by D2,E1a, XREAL_1:2;
            end; 
        D5: now assume kk >= k; then
            E1a: 2*kk >= 2*k by XREAL_1:66; 
                j + 2*kk + m1 > j + 2*kk by DE,XREAL_1:31;
              hence contradiction by D2,B3, E1a, XREAL_1:9; 
            end; 
            C.m = B.m by C5a,E7; then
            C.m = Q.(j+m1) by C7,A5; 
          hence contradiction by D5,B1,D2,D3a,D4a,D6,C4;
        end; then
        n < len B by C8,REAL_1:def 5; then
        n1 < len B-1 by XREAL_1:11; then
        B.(n1+1) = P.(j+n1) & j+n1 in dom P by E6; then
   C10: B.n = P.(j+n1) & j+n1 <= len P by FINSEQ_3:27;
   C11: C.m = B.m & C.n = B.n by C5a,C8,E7; 
   C12: j+m1 < j+n1 by DD,XREAL_1:10;
        j+(m1+2) < j+n1 by DZ,XREAL_1:10; then
        j+m1+2 < j+n1;
      hence contradiction by A1,C10,C11,C4,C7a,C12,CPath03; end;
    end;

ZZ: for k being Element of NAT st
        for a being Element of NAT st a < k holds P[a] holds P[k] proof
        let k be Element of NAT such that
    B1: for a being Element of NAT st a < k holds P[a];
        for a being Nat st a < k holds P[a] proof
           let a be Nat such that C1: a < k;
           a in NAT by ORDINAL1:def 13;
         hence P[a] by B1,C1;          
        end;  
      hence P[k] by II;
    end;
 I: for k being Element of NAT holds P[k] from NAT_1:sch 4(ZZ);

P2: now let n be odd Nat such that B1: n <= len P-2;
        len P-2 <= len P-2+4 by XREAL_1:33; then
        n <= len P + 2*1 by B1,XREAL_1:2; then
        consider k being Nat such that
    B2: n + 2*k = len P + 2 by OddDiff00;
    ZB: k in NAT by ORDINAL1:def 13;
    B3: now assume C1: 2*k < 4; 
            n + 4 <= len P-2+4 by B1,XREAL_1:9; 
          hence contradiction by B2,C1,XREAL_1:10;
        end; 
        now assume C1: 2*k > len P + 1;
            1 <= n by Nat02; then
            n + 2*k > 1 + (len P + 1) by C1,XREAL_1:10;
          hence contradiction by B2;
        end;
      hence not ex e being set st e Joins Q.n,x,G by B2,B3,I,ZB;
    end;
    now assume Q is chordal; then
        consider m,n being odd Nat such that
    B2: m+2 < n & n <= len Q & Q.m <> Q.n and
    B3: ex e being set st e Joins Q.m,Q.n,G and
        (Q is Cycle-like implies  not (m=1 & n = len Q) &
         not (m=1 & n = len Q-2) & not (m=3 & n = len Q)) by ChordalWalk01;
        consider e being set such that
    B4: e Joins Q.m,Q.n,G by B3;
        m < m+2 by XREAL_1:31; then
    B6: m < n by B2,XREAL_1:2; 
        m+2 < len P+2 by B2,XREAL_1:2,A7; then
    B5: m+2-2 < len P+2-2 by XREAL_1:11; 
      per cases by B2,REAL_1:def 5;
      suppose C0: n = len Q; then 
          m+2-2 < len P+2-2 by A7,B2,XREAL_1:11; then
          m <= len P-2 by EvenOdd02;

      hence contradiction by P2,B4,C0,A6; end;
      suppose n < len Q; then 
    C1: n <= len P + 2 - 2 by A7,EvenOdd02; then
        Q.m = P.m & Q.n = P.n by A5,B5; 
      hence contradiction by B2,B4,A1,B6,C1,CPath03; end;
    end;
  hence thesis by P1,A2,A6,GLIB_001:def 24;
end;


:: Golumbic, page 83. Theorem 4.1  (i) ==> (iii)
theorem Chordal41:  :: :: Chordal41:  : PR
for G being chordal _Graph, a,b being Vertex of G
 st a<>b & not a,b are_adjacent
  for S being VertexSeparator of a,b st S is minimal & S is non empty
  for H being inducedSubgraph of G,S holds H is complete
proof let G be chordal _Graph;
  set tVG = the_Vertices_of G;
     let a,b be Vertex of G such that
  A1: a<>b and
  A1b: not a,b are_adjacent;
     let S be VertexSeparator of a,b such that
  A2: S is minimal and
  A2b: S is non empty;
     let Gs be inducedSubgraph of G,S;

     consider Gns being removeVertices of G,S;
     reconsider sa = a, sb = b as Vertex of Gns by A1, A1b, VS10;
     set A = Gns.reachableFrom(sa), B = Gns.reachableFrom(sb);
Aa:  S is VertexSeparator of b,a by A1,A1b,VS01;
A5a: A/\B = {} by A1, A1b,VS11b; 
 A8: A/\S = {} & B /\ S = {} by Aa,A1,A1b,VS11;

     consider Ga being inducedSubgraph of Gns,A;
     consider Gb being inducedSubgraph of Gns,B;
Gad: the_Vertices_of Ga = A by GLIB_000:def 39;
Gbd: the_Vertices_of Gb = B by GLIB_000:def 39;

     the_Vertices_of Gns c= tVG; then
     reconsider A, B as non empty Subset of tVG by XBOOLE_1:1;
     not a in S by A1,A1b,DefVS; then
 A9a: tVG\S is non empty Subset of tVG by XBOOLE_0:def 4;
      now let x be set such that B1: x in A;
          not x in S by A8,B1,XBOOLE_0:def 3; 
          hence x in tVG \ S by B1,XBOOLE_0:def 4;
      end; then
A13a: A c= tVG \ S by TARSKI:def 3;
      now let x be set such that B1: x in B;
          not x in S by A8,B1,XBOOLE_0:def 3;
          hence x in tVG \ S by B1,XBOOLE_0:def 4;
      end; then
A13b: B c= tVG \ S by TARSKI:def 3;
   reconsider Ga as inducedSubgraph of G,A by A9a,A13a,Subgraph01;
   reconsider Gb as inducedSubgraph of G,B by A9a,A13b,Subgraph01;

  let x,y be Vertex of Gs such that
Aa: x <> y and
Ab: not x,y are_adjacent;
    reconsider xg = x, yg = y as Vertex of G by GLIB_000:45;
Ac: S = the_Vertices_of Gs by A2b,GLIB_000:def 39;
Abg: not xg,yg are_adjacent by Ab, A2b, VAdjacent01;
    set xy = {xg, yg}; :: xy is Subset of tVG

        :: We construct minimal paths in Ga1 and Gb1 and append them
        :: to get a long enough cycle

      set Bx = B\/{xg}, Ax = A\/{xg};
      consider Gax being inducedSubgraph of G,Ax;
  Gaxd: the_Vertices_of Gax = Ax by GLIB_000:def 39;
      consider Ga1 being inducedSubgraph of G,A\/{x}\/{y};
  Ga1u: A\/{x}\/{y} = A\/({x}\/{y}) by XBOOLE_1:4 .= A\/xy by ENUMSET1:41;then
  Ga1v: the_Vertices_of Ga1 c= A\/xy by GLIB_000:def 39;
      x in xy & y in xy by TARSKI:def 2; then
      x in A\/xy & y in A\/xy by XBOOLE_0:def 2; then
      reconsider xa = x, ya = y as Vertex of Ga1 by Ga1u,GLIB_000:def 39;
      consider xag being Vertex of G such that
  Z1x: xag in A and
  Y1x: xg,xag are_adjacent by A1, A1b, A2, Ac, VertexSep0;
      not x in A by Ac, A13a, XBOOLE_0:def 4;     then
      x in G.AdjacentSet(the_Vertices_of Ga) by Gad, Z1x, Y1x; then
  Gaxc: Gax is connected by Connected0;
       consider yag being Vertex of G such that
  Z1y: yag in A and
  Y1y: yg,yag are_adjacent by A1, A1b, A2, Ac, VertexSep0;
  X1y: yag in Ax by Z1y, XBOOLE_0:def 2;
       not y in A & not y in {x} by Ac, A13a,XBOOLE_0:def 4,Aa,TARSKI:def 1;
       then not yg in the_Vertices_of Gax by Gaxd, XBOOLE_0:def 2; then
      y in G.AdjacentSet(the_Vertices_of Gax) by Gaxd, X1y,Y1y; then
      Ga1 is connected by Gaxc, Connected0; then
      consider Wa being Walk of Ga1 such that
  Da0: Wa is_Walk_from xa,ya by GLIB_002:def 1;
  Da1: Wa.first() = xa & Wa.last() = ya by Da0, GLIB_001:def 23;
      consider Pa being Path of Ga1 such that
  Da2: Pa is_Walk_from Wa.first(),Wa.last() and
  Da: Pa is minlength by TopPath02;

      :: the same about Gb1

      consider Gbx being inducedSubgraph of G,Bx;
  Gbxd: the_Vertices_of Gbx = Bx by GLIB_000:def 39;
      consider Gb1 being inducedSubgraph of G,B\/{x}\/{y};
  Gb1u: B\/{x}\/{y} = B\/({x}\/{y}) by XBOOLE_1:4 .= B\/xy by ENUMSET1:41;then
  Gb1v: the_Vertices_of Gb1 c= B\/xy by GLIB_000:def 39;
      x in xy & y in xy by TARSKI:def 2; then
      x in B\/xy & y in B\/xy by XBOOLE_0:def 2; then
      reconsider xb = x, yb = y as Vertex of Gb1 by Gb1u,GLIB_000:def 39;
      consider xbg being Vertex of G such that
  Z1x: xbg in B and
  Y1x: xg,xbg are_adjacent by A1, A1b, A2, Ac, VertexSep01;
      not x in B by Ac, A13b, XBOOLE_0:def 4;     then
      x in G.AdjacentSet(the_Vertices_of Gb) by Gbd, Z1x, Y1x; then
  Gbxc: Gbx is connected by Connected0;
       consider ybg being Vertex of G such that
  Z1y: ybg in B and
  Y1y: yg,ybg are_adjacent by A1, A1b, A2, Ac, VertexSep01;
  X1y: ybg in Bx by Z1y, XBOOLE_0:def 2;
       not y in B & not y in {x} by Ac, A13b,XBOOLE_0:def 4,Aa,TARSKI:def 1;
       then not yg in the_Vertices_of Gbx by Gbxd, XBOOLE_0:def 2; then
      y in G.AdjacentSet(the_Vertices_of Gbx) by Gbxd, X1y,Y1y; then
      Gb1 is connected by Gbxc, Connected0; then
       consider Wb being Walk of Gb1 such that
  Db0: Wb is_Walk_from yb,xb by GLIB_002:def 1;
  Db1: Wb.first() = ya & Wb.last() = xa by Db0, GLIB_001:def 23;
       consider Pb being Path of Gb1 such that
  Db2: Pb is_Walk_from Wb.first(),Wb.last() and
  Db: Pb is minlength by TopPath02;

        reconsider Pag = Pa, Pbg = Pb as Path of G by GLIB_001:176;
  Cla2: Pag.first() = Pag.1 & Pag.last() = Pag.len Pag;
        Pa.first() = Pa.1 & Pa.last() = Pa.len Pa; then
  FLag: Pag.1 = xg & Pag.len Pag = yg by Da1, Da2, GLIB_001:def 23;
  Cla1: Pag is open by FLag, Cla2, Aa, GLIB_001:def 24; then
  Cla: not Pag is Cycle-like by GLIB_001:def 31;
  Cla3: x in Pag.vertices() & y in Pag.vertices() by FLag, Cla2, GLIB_001:89;
  Clb2: Pbg.first() = Pbg.1 & Pbg.last() = Pbg.len Pbg;
  GAG: Pb.first() = Pb.1 & Pb.last() = Pb.len Pb; then
  FLbg: Pbg.1 = yg & Pbg.len Pbg = xg by Db1, Db2, GLIB_001:def 23;
  Clb1: Pbg is open by FLbg, Clb2, Aa, GLIB_001:def 24; then
  Clb: not Pbg is Cycle-like by GLIB_001:def 31;
  Clb3: x in Pbg.vertices() & y in Pbg.vertices() by FLbg,Clb2,GLIB_001:89;

      set P = Pag.append(Pbg);
  Dl: len P +1 = len Pag + len Pbg by Cla2,FLag,Clb2,FLbg,GLIB_001:29; 
  O2: Pag is non trivial by Aa, Cla2, FLag, GLIB_001:128;
  O2a: Pag.length() >= 2 by FLag,Cla2,Aa,Abg,PathLike05;
  P2: Pbg is non trivial by Aa, Clb2, FLbg, GLIB_001:128;
  P2a: Pbg.length() >= 2 by FLbg,Clb2,Aa,Abg,PathLike05;
S2: Pag.vertices() /\ Pbg.vertices() = xy  proof
     thus Pag.vertices() /\ Pbg.vertices() c= xy proof
          Pag.vertices() = Pa.vertices() by GLIB_001:99; then
     A3:  Pag.vertices() c= A\/xy by Ga1v,XBOOLE_1:1;
          Pbg.vertices() = Pb.vertices() by GLIB_001:99; then
     B3:  Pbg.vertices() c= B\/xy by Gb1v,XBOOLE_1:1;
          (A\/xy)/\(B\/xy) = A/\B\/xy by XBOOLE_1:24 .= xy by A5a;
      hence thesis by A3,B3,XBOOLE_1:27;
     end;
      thus xy c= Pag.vertices() /\ Pbg.vertices() proof
       let a be set; assume a in xy; then a = x or a = y by TARSKI:def 2;
       hence thesis by Cla3,Clb3,XBOOLE_0:def 3;
      end; 
    end;
T2: Pag.edges() misses Pbg.edges() proof
     assume Pag.edges() /\ Pbg.edges() <> {}; then
         consider e being set such that
    A3:  e in Pag.edges() /\ Pbg.edges() by XBOOLE_0:def 1;
         e in Pag.edges() by A3,XBOOLE_0:def 3; then
    B3a: e in Pa.edges() by GLIB_001:111;
         e in Pbg.edges() by A3,XBOOLE_0:def 3; then
    B3b: e in Pb.edges() by GLIB_001:111;
         consider a1, a2 being Vertex of Ga1, na being odd Element of NAT
         such that
    C3a: na+2 <= len Pag and
    D3a: a1 = Pag.na and e = Pag.(na+1) and
    F3a: a2 = Pag.(na+2) and
    G3a: e Joins a1, a2,Ga1 by B3a,GLIB_001:104;
         consider b1, b2 being Vertex of Gb1, nb being odd Element of NAT
          such that
          nb+2 <= len Pbg and b1 = Pbg.nb and e = Pbg.(nb+1) and
          b2 = Pbg.(nb+2) and
    G3b: e Joins b1, b2,Gb1 by B3b,GLIB_001:104;
    G3c: e Joins a1,a2,G  & e Joins b1,b2,G by G3a, G3b, GLIB_000:75; then
    G3:  a1=b1 & a2=b2 or a1=b2 & a2=b1 by GLIB_000:18;
         the_Vertices_of Ga1 = A\/xy by Ga1u,GLIB_000:def 39; then
    H3:  (a1 in A or a1 in xy) & (a2 in A or a2 in xy) by XBOOLE_0:def 2;
         the_Vertices_of Gb1 = B\/xy by Gb1u,GLIB_000:def 39; then
    I3:  (a1 in B or a1 in xy) & (a2 in B or a2 in xy) by G3,XBOOLE_0:def 2;
      per cases by TARSKI:def 2, H3,I3,A5a,XBOOLE_0:def 3;
      suppose S1: a1 = x & a2 = x or a1 = y & a2 = y;
         na < na+2 by XREAL_1:41;
     hence contradiction by S1,F3a,D3a,FLag,Aa,C3a,GLIB_001:def 28;
      end;
      suppose a1 = x & a2 = y or a1 = y & a2 = x; 
       hence contradiction by Abg, G3c, DefAdjacent;
      end;
end;
    P.length() = Pag.length()+Pbg.length()
           by Cla2,FLag,Clb2,FLbg,PathLike04; then
    P.length() >= 2+2 by O2a,P2a,XREAL_1:9; then P.length() >= 3+1; then
E2: P.length() > 3 by NAT_1:38;
    P is Cycle-like by T2,O2,P2,Cla1,Clb1,S2,Cla2,FLag,Clb2,FLbg,PathLike03;
    then P is chordal by E2, DefChordalGraph; then
    consider m, n being odd Nat such that
G2: m+2 < n and
H2: n <= len P and
I2: P.m <> P.n and
J2: ex e being set st e Joins P.m,P.n,G and
K2: for f being set st f in P.edges() holds not f Joins P.m,P.n,G
       by DefChordalWalk;
ZX: m in NAT & n in NAT by ORDINAL1:def 13;
G2a: m < n by G2, NAT_1:37; 
    consider e being set such that
L2: e Joins P.m,P.n,G by J2;
L2a: e Joins P.n,P.m,G by L2,GLIB_000:17;

M2: 1 <= m by HEYTING3:1;
N2: 1 <= n by HEYTING3:1;
    per cases;
    suppose S1: m < len Pag & n <= len Pag; :: chord in minimal path Pa
        m in dom Pag & n in dom Pag by S1, M2, N2, FINSEQ_3:27; then
        P.m = Pag.m & P.n = Pag.n by GLIB_001:33;        
        then Pag is chordal by G2, J2, S1, Cla, ChordalPath01;
        then Pa is chordal by Ga1u,ChordalWalk03;
      hence contradiction by Da, MinChordal01;
    end;
    suppose S1: m < len Pag & len Pag < n;
        m in dom Pag by M2, S1, FINSEQ_3:27; then
    A3: P.m = Pag.m by GLIB_001:33;
        n in dom P & not n in dom Pag by S1, N2, H2, FINSEQ_3:27; then
        consider n1 being Element of NAT such that
    C3: n1 < len Pbg and
    B3: n = len Pag + n1 by GLIB_001:35;
    D3: P.(len Pag +n1) = Pbg.(n1+1) by Cla2,FLag,Clb2,FLbg,C3,GLIB_001:34;
    E3:  Pag.m in the_Vertices_of Ga1 by S1, ZX,GLIB_001:8; 
        n1 - 0 = n - len Pag by B3; then
        reconsider n1 as even Element of NAT;
        reconsider n11 = n1+1 as odd Element of NAT;
    C3a: n11 <= len Pbg by C3, NAT_1:38; then
    F3:  Pbg.n11 in the_Vertices_of Gb1 by GLIB_001:8; 
      per cases by E3, Ga1v, F3, Gb1v, XBOOLE_0:def 2;
      suppose S2: Pag.m in A & Pbg.n11 in xy; :: chord in minimal path Pa
        per cases by S2, FLag, TARSKI:def 2;
        suppose S3: Pbg.n11 = Pag.1;
            now assume A5: 1+2 >= m;
             per cases by A5, REAL_1:def 5;
             suppose 1+2 > m; then 1 >= m by JORDAN12:3,EvenOdd03; 
              hence contradiction by S3,A3,B3,D3,I2,M2,XREAL_1:1;
             end;
             suppose S4: 1+2 = m; 
                 1 < len Pag by M2, S1, XREAL_1:2; then
                 Pag.(1+1) Joins Pag.1,Pag.m,G
                     by JORDAN12:3,S4,GLIB_001:def 3; then
             A5: Pag.(1+1) Joins Pag.m,Pag.1,G by GLIB_000:17;
             H5: 1+1 < len Pag by S1, S4, XREAL_1:2; then
                 1+1 in dom Pag by FINSEQ_3:27; then
             C5: Pag.(1+1) = P.(1+1) by GLIB_001:33;
             F5: 0 <= len Pbg by NAT_1:18;
                 1 < len Pag -1 by H5, XREAL_1:22; then
                 1+0 < (len Pag -1) + len Pbg by F5, XREAL_1:10; then
                 P.(1+1) in P.edges() by JORDAN12:3,Dl,GLIB_001:101;
               hence contradiction by C5, A5, S3, A3, B3, D3, K2;
             end;
            end; then
          Pag is chordal by JORDAN12:3,L2a,S1,S3,Cla,A3,B3,D3,ChordalPath01;
          then Pa is chordal by Ga1u,ChordalWalk03;
         hence contradiction by Da, MinChordal01;
        end;
        suppose S3: Pbg.n11 = Pag.len Pag; 
          now assume A5: m+2 >= len Pag; set L = len Pag;
           per cases by A5, REAL_1:def 5;
           suppose S4: m+2 = L; then
           E5: L = m+1+1; then
           E6: m +1 < L by NAT_1:38; then m < L by NAT_1:38; then
           A5: Pag.(m+1) Joins Pag.m,Pag.L,G by S4,ZX,GLIB_001:def 3;
               1<=m+1 by NAT_1:37; then m+1 in dom Pag by E6,FINSEQ_3:27; then
           C5: Pag.(m+1) = P.(m+1) by GLIB_001:33;
           F5: 0 <= len Pbg by NAT_1:18;
               m < len Pag -1 by E5, NAT_1:38; then
               m+0 < (len Pag -1) + len Pbg by F5, XREAL_1:10; then
               P.(m+1) in P.edges() by Dl,ZX,GLIB_001:101;
             hence contradiction by C5, A5, S3, A3, B3, D3, K2;
           end;
           suppose m+2 > len Pag; 
             hence contradiction by S1, EvenOdd03;
           end;
          end;
          then Pag is chordal by J2, S3, Cla, A3, B3, D3, ChordalPath01;
          then Pa is chordal by Ga1u,ChordalWalk03;
        hence contradiction by Da, MinChordal01;
       end; 
      end;
      suppose S2: Pag.m in A & Pbg.n11 in B;  :: construct a walk
         reconsider ac = Pa.m as Vertex of Ga by S2, GLIB_000:def 39;
         a in A by GLIB_002:9; then
         reconsider aa = a as Vertex of Ga by GLIB_000:def 39;
         reconsider bc = Pb.n11 as Vertex of Gb by S2, GLIB_000:def 39;
         b in B by GLIB_002:9; then
         reconsider bb = b as Vertex of Gb by GLIB_000:def 39;
         consider WA being Walk of Ga such that
      A4: WA is_Walk_from aa, ac by GLIB_002:def 1;
         consider WB being Walk of Gb such that
      B4: WB is_Walk_from bc, bb by GLIB_002:def 1;
         reconsider WA, WB as Walk of Gns by GLIB_001:168;
         set WAB = Gns.walkOf(ac,e,bc);
          e Joins ac,bc,Gns by A13a, A13b,S2,L2,A3, B3, D3, Joins01; then
      D4: WAB is_Walk_from ac,bc by GLIB_001:16; 
          reconsider WAs = WA, WBs = WB as Walk of Gns;
          set WaB = WAs.append(WAB);
          set Wab = WaB.append(WBs);
          WAs is_Walk_from aa, ac by A4, GLIB_001:20; then
      F4: WaB is_Walk_from aa, bc by D4, GLIB_001:32;
          WBs is_Walk_from bc, bb by B4, GLIB_001:20; then
          Wab is_Walk_from a,b by F4, GLIB_001:32;
        hence contradiction by A1, A1b,DefVS;
      end;
      suppose S2: Pag.m in xy & Pbg.n11 in B; :: chord in minimal path Pb
          Pag.m = x or Pag.m = y by S2, TARSKI:def 2; then
      B4: Pag.m = x by S1, FLag, ZX,GLIB_001:def 28
               .= Pbg.len Pbg by GAG,Db1, Db2, GLIB_001:def 23;
       now assume A5: n11+2 >= len Pbg;         set L = len Pbg;
        per cases by A5, REAL_1:def 5;
         suppose S3: n11+2 = L; then
         E5: L = :: n11+(1+1) .=
                 n11+1+1; then
             n11 +1 < L by NAT_1:38; then
         B5: n11 < L by NAT_1:38; then
             Pbg.(n11+1) Joins Pbg.n11,Pbg.L,Gb1 by S3,GLIB_001:def 3;then
             Pbg.(n11+1) Joins Pbg.L,Pbg.n11,Gb1 by GLIB_000:17; then
         A5: Pbg.(n11+1) Joins Pbg.L,Pbg.n11,G by GLIB_000:75;
         C5: Pbg.(n11+1) = P.(len Pag + n11)
                      by Cla2,FLag,Clb2,FLbg,B5,GLIB_001:34;
             1 <= n11 by HEYTING3:1; then
         D5: 1 <= len Pag +n11 by NAT_1:37;
             n11 < len Pbg -1 by E5, NAT_1:38; then
             len Pag +n11 < (len Pbg -1) + len Pag by XREAL_1:8; then
             Pbg.(n11+1) in P.edges() by C5,D5,Dl,GLIB_001:100;
          hence contradiction by A5, A3, B4, B3, D3, K2;
         end;
         suppose n11+2 > len Pbg; then n11 >= len Pbg by EvenOdd03; 
           hence contradiction by B4, A3, B3, D3, I2, C3a, XREAL_1:1;
         end;
       end;
       then Pbg is chordal by L2a, Clb, B4, A3, B3, D3, ChordalPath01;
       then Pb is chordal by Gb1u,ChordalWalk03;
      hence contradiction by Db, MinChordal01;
      end;
      suppose Pag.m in xy & Pbg.n11 in xy; then
        (Pag.m = x or Pag.m = y)&(Pbg.n11 = x or Pbg.n11 = y) by TARSKI:def 2;
        then xg,yg are_adjacent by J2,A3,D3,B3,I2,DefAdjacent;
       hence contradiction by A2b, Ab, VAdjacent01;
      end;
    end;
    suppose S1: len Pag <= m;             :: chord in minimal path Pb
        consider m1 being Nat such that
    A3: m = len Pag + m1 by S1,NAT_1:28;
    ZM: m1 in NAT by ORDINAL1:def 13;
        n > len Pag by S1, G2a, XREAL_1:2; then
        n in dom P & not n in dom Pag by N2, H2, FINSEQ_3:27; then
        consider n1 being Element of NAT such that
    C3: n1 < len Pbg and
    B3: n = len Pag + n1 by GLIB_001:35;
    D3: P.(len Pag +n1) = Pbg.(n1+1) by C3,Cla2,FLag,Clb2,FLbg,GLIB_001:34;
    E3a: m1 < n1 by G2a, A3, B3, XREAL_1:8; then
         m1 < len Pbg by C3, XREAL_1:2; then
    F3: P.(len Pag +m1) = Pbg.(m1+1) by ZM,Cla2,FLag,Clb2,FLbg,GLIB_001:34;
        n1 - 0 = n - len Pag & m1 -0 = m - len Pag by A3, B3; then
        reconsider n1, m1 as even Element of NAT by ORDINAL1:def 13;
        reconsider m11 = m1+1, n11 = n1+1 as odd Element of NAT;
    G3b: n11 <= len Pbg by C3, NAT_1:38; 
         m11 < n11 by E3a, XREAL_1:8; then
    G3a: m11 < len Pbg by G3b, XREAL_1:2;
    G3: now assume A4: m11+2 >= n11;
         per cases by A4, REAL_1:def 5;
         suppose S2: m11+2 = n11; then
         A4: Pbg.(m11+1) Joins Pbg.m11,Pbg.n11,G by G3a,GLIB_001:def 3;
         B4: Pbg.(m11+1) = P.(len Pag +m11)
               by G3a,Cla2,FLag,Clb2,FLbg,GLIB_001:34;
             1 <= m11 by HEYTING3:1; then
         C4: 1 <= len Pag +m11 by NAT_1:37;
             m11 +1 < len Pbg by C3, S2; then
             m11 < len Pbg -1 by XREAL_1:22; then
             len Pag +m11 < (len Pbg -1) + len Pag by XREAL_1:8; then
             Pbg.(m11+1) in P.edges() by Dl,B4, C4,GLIB_001:100;
          hence contradiction by A4, A3, F3, B3, D3, K2;
         end;
         suppose m11+2 > n11; then m11 >= n11 by EvenOdd03;
           hence contradiction by E3a, XREAL_1:8;
         end;
        end;
    H3: n11 <= len Pbg by C3, NAT_1:38;
        Pbg is chordal by G3, H3, B3, D3, A3, F3, J2, Clb, ChordalPath01; then
        Pb is chordal by Gb1u,ChordalWalk03;
      hence contradiction by Db, MinChordal01;
    end;
end;

:: Golumbic, page 83, Theorem 4.1 (iii)->(i)
theorem ::: DiracThm2: :: :: DiracThm2
for G being finite _Graph
 st for a,b being Vertex of G st a<>b & not a,b are_adjacent 
    for S being VertexSeparator of a,b st S is minimal & S is non empty
    for G2 being inducedSubgraph of G,S holds G2 is complete
  holds G is chordal
proof  let G be finite _Graph such that
A0: for a,b being Vertex of G st a<>b & not a,b are_adjacent holds
     for S being VertexSeparator of a,b st S is minimal & S is non empty 
      for G2 being inducedSubgraph of G,S holds G2 is complete;
  let P be Walk of G such that B0: P.length() > 3 & P is Cycle-like;
B: P is Path-like by B0, GLIB_001:def 31;
   P.length() >= 3+1 by B0,NAT_1:38;
   then 2*P.length() >= 2*4 by XREAL_1:66;
   then 2*P.length() + 1 >= 8 + 1 by XREAL_1:9; then
B1: len P >= 9 by GLIB_001:113;
    reconsider m = 2*0+1 as odd Nat;  :: so clusters come into effect
    reconsider n = 2*2+1 as odd Nat;
B2: now assume C0: P.m = P.n;
      m < n & n <= len P by B1,XREAL_1:2; then
      m=1 & n=len P by B, C0,GLIB_001:def 28;
     hence contradiction by B1;
    end;
   per cases;
   suppose C0: ex e being set st e Joins P.m,P.n,G;
   C1: m+2 < n & n <= len P by B1,XREAL_1:2;
   C2: not (m=1 & n = len P) by B1;
       len P+(-2) >= 9+(-2) by B1,XREAL_1:9;
       then not (m=1 & n = len P-2);
     hence P is chordal by B, C0,C1,C2,ChordalPath01; end;
   suppose C0: not ex e being set st e Joins P.m,P.n,G;
            m <= len P by B1,XREAL_1:2; then
            reconsider Pm=P.m as Vertex of G by GLIB_001:8;
            n <= len P by B1,XREAL_1:2; then
            reconsider Pn=P.n as Vertex of G by GLIB_001:8;
        C1: not Pm,Pn are_adjacent by C0,DefAdjacent; 
            consider S being VertexSeparator of Pm,Pn such that
        C2: S is minimal by minVSexistance;

            set P15=P.cut(m,n);  set P5l=P.cut(n,len P);
        CC: m <= n & n <= len P by B1,XREAL_1:2; then
        C3: P15 is_Walk_from P.m,P.n by GLIB_001:38; then
        C4: S is non empty by B2,C1,VS08a;
            consider G2 being inducedSubgraph of G,S;
       C4a: G2 is complete by A0,B2,C1,C2,C4;

        C5: len P15 + 1 + (-1) = 5 + 1 + (-1) by CC,GLIB_001:37; 
            consider k being odd Nat such that
        C6: m < k & k < n and  C7: P15.k in S by B2,C1,C3,C5,VS07;
        C8a: 1+2 <= k & k <= 5-2 by C6,EvenOdd02,EvenOdd03; then
        C8: k = 3 by XREAL_1:1;
            P15.(2+1) = P.(1+2) by CC, C5, GLIB_001:37; then
        C9: P.3 in S by C7,C8a,XREAL_1:1;

       C10: P is closed by B0,GLIB_001:def 31;
       C11: n <= len P & len P <= len P by B1,XREAL_1:2; then
            P5l is_Walk_from P.n,P.(len P) by GLIB_001:38; then
       C12: P5l is_Walk_from P.n,P.m by C10,GLIB_001:119;
            S is VertexSeparator of Pn,Pm by B2,C1,VS01; then
            consider l being odd Nat such that
       C13: 1 < l & l < len P5l and C14: P5l.l in S by B2,C1,C12,VS07;
       C15b:  1+(-1) < l+(-1) by C13,XREAL_1:10;
            reconsider l2=l-1 as even Element of NAT by C15b,INT_1:16; 
            reconsider l2 as even Nat;

            l+(-1) < l+0 & l < len P5l by XREAL_1:10,C13; then
            l-1 < len P5l by XREAL_1:2; then
       C15: P5l.(l2+1) = P.(n+l2) by C11,GLIB_001:37;
            reconsider aa=P.3 as Vertex of G2 by C9,GLIB_000:def 39;
            reconsider bb=P.(n+l2) as Vertex of G2
                       by C15,C14,GLIB_000:def 39;
      C16a: len P5l + 5 + (-5) = len P + 1 + (-5) by C11,GLIB_001:37; 
            l+(-1) < len P5l + (-1) by C13,XREAL_1:10; then
      C16c: l2+n < len P-5+n by C16a,XREAL_1:10; 
       C17a: k+2+0 < k+2+l2 by C15b,XREAL_1:10;
        ZZ: n+l2 in NAT by ORDINAL1:def 13;
            now assume D1: aa = bb; 
                k < n+l2 & n+l2 <= len P by C17a, C8, C16c, XREAL_1:2;
              hence contradiction
             by ZZ,C8, B,D1,GLIB_001:def 28;
            end; then aa,bb are_adjacent by C4a,DefComplete; then
            consider e being set such that
       C18: e Joins P.3,P.(n+l2),G2 by DefAdjacent; 
            e Joins P.k,P.(n+l2),G by C8,C18,GLIB_000:75;
            hence P is chordal by C8,C17a,C16c, B,ChordalPath01; end;
end;

:: Exercise 12, p. 101.
:: This needs "finite-branching", we do it for finite though
theorem tExercise12: :: tExercise12
for G being finite chordal _Graph, a, b being Vertex of G
 st a <> b & not a,b are_adjacent
for S being VertexSeparator of a,b st S is minimal
for H being removeVertices of G,S, a1 being Vertex of H st a = a1
 ex c being Vertex of G st c in H.reachableFrom(a1) &
   for x being Vertex of G st x in S holds c,x are_adjacent 
proof let G be finite chordal _Graph, a, b be Vertex of G such that
A: a <> b and
B: not a,b are_adjacent;
   let S be VertexSeparator of a,b such that
C: S is minimal;
   let H be removeVertices of G,S, a1 be Vertex of H such that
D: a = a1;
   assume
E: for c being Vertex of G holds not c in H.reachableFrom(a1) or
         ex x being Vertex of G st x in S & not c,x are_adjacent;
   per cases;
   suppose S is empty;
     then not ex x being Vertex of G st x in S & not a,x are_adjacent;
     then not a in H.reachableFrom(a1) by E;
    hence contradiction by D,GLIB_002:9;
   end;
   suppose A1: S is non empty;
    reconsider S as non empty Subset of the_Vertices_of G by A1;
    set A = H.reachableFrom(a1);
    deffunc F(set) = card (G.AdjacentSet({$1}) /\ S);
    set M = { F(x) where x is Vertex of G : x in A };
    a in A by D,GLIB_002:9; then
B1: card (G.AdjacentSet({a}) /\ S) in M;
B2a: A is finite;
B2: M is finite from FRAENKEL:sch 21(B2a);    
   now let x be set such that D0: x in M;
       consider y being Vertex of G such that
   D1: x = card (G.AdjacentSet({y}) /\ S) and y in A by D0;
       thus x is natural by D1;
   end; then
 reconsider M as finite non empty natural-membered set by B1,B2,MEMBERED:def 5;

    max M in M by PRE_CIRC:def 1; then
    consider c being Vertex of G such that
 F: max M = card (G.AdjacentSet({c}) /\ S) and
 G: c in A;
   consider y being Vertex of G such that
Ha: y in S and
Hb: not c,y are_adjacent by E,G;
   
A8: A/\S = {} by A,B,D,VS11;
    consider Ga being inducedSubgraph of H,A;
Gad: the_Vertices_of Ga = A by GLIB_000:def 39;
    set tVG = the_Vertices_of G;
    the_Vertices_of H c= tVG; then
    reconsider A as non empty Subset of tVG by XBOOLE_1:1;
    not a in S by A,B,DefVS; then
A9a: tVG\S is non empty Subset of tVG by XBOOLE_0:def 4;
    now let x be set such that B1: x in A;
      not x in S by A8,B1,XBOOLE_0:def 3; 
     hence x in tVG \ S by B1,XBOOLE_0:def 4;
    end; then
A13a: A c= tVG \ S by TARSKI:def 3;
    reconsider Ga as inducedSubgraph of G,A by A9a,A13a,Subgraph01;
    set Ay = A\/{y};
      consider Gay being inducedSubgraph of G,Ay;
Gaxd: the_Vertices_of Gay = Ay by GLIB_000:def 39;
      y in {y} by TARSKI:def 1; then
      c in Ay & y in Ay by G, XBOOLE_0:def 2; then
      reconsider ca = c, ya = y as Vertex of Gay by GLIB_000:def 39;
      consider yaa being Vertex of G such that
Z1x: yaa in A and
Y1x: y,yaa are_adjacent by A, B, C, D, Ha, VertexSep0;
     not y in A by A8, Ha, XBOOLE_0:def 3;     then
     y in G.AdjacentSet(the_Vertices_of Ga) by Gad, Z1x, Y1x; then
      Gay is connected by Connected0; then
     consider Wa being Walk of Gay such that
 I: Wa is_Walk_from ca,ya by GLIB_002:def 1;
Ia: Wa.first() = ca & Wa.last() = ya by I, GLIB_001:def 23;
      consider P being Path of Gay such that
 J: P is_Walk_from Wa.first(),Wa.last() and
 K: P is minlength by TopPath02;
KK1:P.first() = ca by J,Ia,GLIB_001:def 23;
K2a:P.last() = y by J,GLIB_001:def 23,Ia; 
    c <> y by G, A8, Ha, XBOOLE_0:def 3; then
    P is non trivial by K2a,KK1,GLIB_001:128; then
K3: len P >= 3 by GLIB_001:126;
K3a: now assume len P < 2*2+1; then
        len P <= 5-2 by EvenOdd02; then
    D1: len P = 3 by K3,XREAL_1:1; then
        2*0+1 < len P; then
        P.(1+1) Joins P.1,P.(1+2),Gay by GLIB_001:def 3; then
        P.2 Joins c,y,G by KK1,K2a,D1,GLIB_000:75; 
        hence contradiction by Hb, DefAdjacent;
    end; 
    5 + -2 <= len P + -2 by K3a, XREAL_1:9; then
    0 <= len P - 2 by XREAL_1:2; then
    reconsider j = len P - 2*1 as odd Element of NAT by INT_1:16;
    set d = P.j;
K4: j < len P by XREAL_1:46; then
K5: P.j in the_Vertices_of Gay by GLIB_001:8; then
K6: d in A or d in {y} by Gaxd,XBOOLE_0:def 2;
K7: now assume d = y; then
        len P - 2 = 1 by K2a,K4,GLIB_001:def 28; then
        len P = 1 + 2 & 3 < 5; 
        hence contradiction by K3a;
    end; 
    reconsider d as Vertex of G by K5;

    P.(j+1) Joins d,P.(len P-2+2),Gay by K4,GLIB_001:def 3; then
YT: P.(j+1) Joins d,y,G by K2a,GLIB_000:75; then
    d <> y & d,y are_adjacent by K7,DefAdjacent; then
Lya: y in G.AdjacentSet({d}) by AdjacentV00; then
Ly: y in G.AdjacentSet({d}) /\ S by Ha,XBOOLE_0:def 3;
Oy: not y in G.AdjacentSet({c}) by Hb, AdjacentV00;

    set gds = G.AdjacentSet({d}) /\ S;
    set gcs = G.AdjacentSet({c}) /\ S;
    now assume D0: gcs c= gds; 
        not y in gcs by Oy,XBOOLE_0:def 3; then
        gcs c< gds by D0,Ly,XBOOLE_0:def 8; then
    D3: card gcs < card gds by TREES_1:24;
        card gds in M by K7,K6,TARSKI:def 1; 
        hence contradiction by D3,F,PRE_CIRC:def 1;
    end; then
    consider x being set such that
Lx: x in G.AdjacentSet({c}) /\ S and
Mx: not x in G.AdjacentSet({d}) /\ S by TARSKI:def 3;
Nx: x in S by Lx, XBOOLE_0:def 3; then
Ox: not x in G.AdjacentSet({d}) by Mx, XBOOLE_0:def 3;
    reconsider x as Vertex of G by Lx;
Oz: x <> y by Mx,Lya, Ha,XBOOLE_0:def 3;
    consider Gs being inducedSubgraph of G,S; 
    reconsider xs=x, ys=y as Vertex of Gs by Ha,Nx, GLIB_000:def 39;
    Gs is complete by A,B,C,Chordal41; then
    xs,ys are_adjacent by Oz,DefComplete; then
    consider ej being set such that
D1: ej Joins xs,ys,Gs by DefAdjacent;
    ej Joins x,y,G by D1,GLIB_000:75; then
Ow: x,y are_adjacent by DefAdjacent;
    x in G.AdjacentSet({c}) by Lx, XBOOLE_0:def 3; then
Lc: c,x are_adjacent by AdjacentV00;
    d <> x by K7,K6,TARSKI:def 1, A8, Nx, XBOOLE_0:def 3; then
Md: not d,x are_adjacent by Ox, AdjacentV00;

   defpred Pmax[Nat] means
   $1 in dom P & $1 is odd & $1 < len P & ex e being set st e Joins x,P.($1),G;
   deffunc N() = len P;
N0: for k being Element of NAT st Pmax[k] holds k <= N();
D0: 1 < len P by K3a,XREAL_1:2; then
D1: 1 in dom P by FINSEQ_3:27; 
D2: 2*0+1 is odd;
    ex e being set st e Joins x,P.1,G by Lc,DefAdjacent,KK1; then 
N1: ex k being Element of NAT st Pmax[k] by D0,D1,D2;
    consider k being Element of NAT such that
Na: Pmax[k] and
Nb: for i being Element of NAT st Pmax[i] holds k >= i
         from NAT_1:sch 6(N0,N1);
    reconsider k as odd Element of NAT by Na;
YW: k <= j & j < len P by Na,EvenOdd02,XREAL_1:46;  
WW: P.k <> P.j by Md,DefAdjacent,Na;
WX: now assume D0: P.k = P.(len P); 
    D1: 2*0+1 <= k & k <= len P
             by Na,HEYTING3:1; then
    D2: P.cut(1,k) is_Walk_from P.first(),P.last() by D0,GLIB_001:38;
        len P.cut(1,k) + 1 = k + 1 by D1,GLIB_001:37;
        hence contradiction
          by K,D2,Na,DefMinTop;
    end; 
    :::::::::: properties of Q ::::::::::
    set Q1 = P.cut(k,j);
YZ: Q1 is minlength by YW,K,TopPath05;
YY: Q1.first() = P.k & Q1.last() = P.j by YW,GLIB_001:38;
    reconsider Q=Q1 as Path of G by GLIB_001:176;
Ni: Q.vertices() = Q1.vertices() by GLIB_001:99;
Ne: Q.first() = P.k by YY;
Nf: Q.last() = P.j by YY;
Nj: Q.first() <> Q.last() by YY,Md,DefAdjacent,Na;
Pb: Q is non trivial by Ne,Nf,WW,GLIB_001:128; then
    Q.length() <> 0 & Q.length() >= 0 by NAT_1:18,GLIB_001:def 26; then
    Q.length() > 0 by REAL_1:def 5; then
Ps: Q.length() >= 0+1 by NAT_1:38; 
Pc: Q is open by GLIB_001:def 24,Nj;
Yv: len Q + k = j + 1 by YW,GLIB_001:37; 
    set cc = Q.first(), dd = Q.last();

TTa: not x in A & not x in {y} by Nx,A8,XBOOLE_0:def 3, Oz,TARSKI:def 1; 
    dd in Q1.vertices() by GLIB_001:89,Ni; then
Ub: dd <> x by TTa, XBOOLE_0:def 2, Gaxd;
    cc in Q1.vertices() by GLIB_001:89,Ni; then
Ud: cc <> x by TTa, XBOOLE_0:def 2, Gaxd;
Ue: dd,y are_adjacent by YT,YY,DefAdjacent;
Ug: x,cc are_adjacent by Na,YY,DefAdjacent;

Qy: now let i be odd Nat such that
    C1: i in dom Q & i <> len Q;
        assume ex e being set st e Joins Q.i,y,G; then
        consider e being set such that
    C2: e Joins Q.i,y,G;
    D0: i <= len Q by C1,FINSEQ_3:27;
        1 <= i by C1,FINSEQ_3:27; then
        1+-1 <= i+-1 by XREAL_1:9; then
        reconsider i1 = i-1 as even Element of NAT by INT_1:16;
        reconsider ki1= k+i1 as odd Element of NAT; 
    D9a: i+-1 < i+-0 by XREAL_1:10; then 
    i1 < len Q by D0,XREAL_1:2; then
    D2: Q.(i1+1) = P.(ki1) & ki1 in dom P by YW,GLIB_001:37;
    D5: ki1 <= len P by D2,FINSEQ_3:27;
        now assume E1: ki1 = len P;
            len P - k + -1 < len P - k by XREAL_1:32; 
            hence contradiction by D9a,D0,XREAL_1:2,Yv,E1;
        end; then
        ki1 < len P by D5,REAL_1:def 5; then
    D6: ki1+2 <= len P by EvenOdd03;
        ki1+2 <> len P by C1, Yv;  then 
    D4: ki1+2 < len P by D6,REAL_1:def 5;
        P.(ki1) in Ay & P.(len P) in Ay
              by Gaxd,D5,GLIB_001:8; then
        e Joins P.(ki1), P.(len P),Gay by K2a,C2,D2,Joins01;
        hence contradiction by D4,K,TopPath03;
    end;

Qx: now let i be odd Nat such that
    C0: i in dom Q & i <> 1;
        assume ex e being set st e Joins Q.i,x,G; then
        consider e being set such that
    C1: e Joins Q.i,x,G;
    D0: 1 <= i & i <= len Q by C0,FINSEQ_3:27; then
        1+-1 <= i+-1 by XREAL_1:9; then
        reconsider i1 = i-1 as even Element of NAT by INT_1:16;
        reconsider ki1= k+i1 as odd Element of NAT;
        i+-1 < i+-0 by XREAL_1:10; then 
    D9: i1 < len Q by D0,XREAL_1:2; then
    D2: Q.(i1+1) = P.(ki1) & ki1 in dom P by YW,GLIB_001:37;
    F0: i1+k < len P - 1 - k + k by XREAL_1:10,D9,Yv; 
        len P+-1 < len P+-0 by XREAL_1:10; then
        1 <= ki1 & ki1 < len P by HEYTING3:1,F0,XREAL_1:2;then
    F2: ki1 in dom P & ki1 < len P by FINSEQ_3:27;
    F4: e Joins x,P.(ki1),G by GLIB_000:17,C1,D2; 
        now assume i1 <> 0; then
            i1 <> 0 & i1 >= 0 by NAT_1:18; then
            i1 > 0 by REAL_1:def 5; then
            k+0 < k + i1 by XREAL_1:10;
            hence contradiction by F4,Nb,F2;
        end; 
        hence contradiction by C0;
    end;

Qz: now let v be set such that C1: v in Q.vertices();
        Q.vertices() c= P.vertices() by YW,Ni,GLIB_001:95; then
    C2: v in P.vertices() by C1;
        consider n being odd Element of NAT such that
    C3: n <= len Q & Q.n = v by C1,GLIB_001:88;
        1 <= n by HEYTING3:1; then
        1+-1 <= n+-1 by XREAL_1:9; then
        reconsider n1 = n-1 as even Element of NAT by INT_1:16;
        reconsider kn1 = k+n1 as odd Element of NAT;
        n+-1 < n+-0 by XREAL_1:10; then 
    D9: n1 < len Q by C3,XREAL_1:2; then
    D2: Q.(n1+1) = P.(kn1) & kn1 in dom P by YW,GLIB_001:37; 
    D8: k+n1 < len P - 1 - k + k by Yv,D9,XREAL_1:10; 
        len P+-1 < len P+-0 by XREAL_1:10; then
    D4: kn1 < len P by D8,XREAL_1:2;
        now assume E1: v = y;
        E2a: k+(n+-1) = 1 by E1,D2,C3,K2a,D4,GLIB_001:def 28; 
        E3: 1 <= k & 1 <= n by HEYTING3:1; 
            now assume 1 < n; then
                1+1 <= n by NAT_1:38; then
                2+1 <= k+n by E3,XREAL_1:9; 
                hence contradiction by E2a;
            end; 
            hence contradiction by E3,REAL_1:def 5,E1,C3,YY,WX,K2a;
        end; then not v in {y} by TARSKI:def 1; 
        hence v in A by C2,Gaxd,XBOOLE_0:def 2;
    end;

    :::    R: building path dd - y - x - cc ::::::::::::::
    consider R being Path of G such that
Od: len R = 7 & R.length() = 3 and
Ov: R.vertices() = {dd,y,x,cc} and
Pi: R.1 = dd & R.3 = y & R.5 = x & R.7 = cc
        by Oz,K7,Ub,YY,WX,K2a,Ud,Ue,Ow,Ug,PathBuilder01;
Pg: R.first() = dd by Pi;
Ph: R.last() = cc by Pi,Od;
Pd: R is non trivial by Od,GLIB_001:127;
Pe: R is open by Nj,Pg,Ph,GLIB_001:def 24;

Pa: Q.edges() misses R.edges() proof
        assume not Q.edges() misses R.edges(); then
        Q.edges() /\ R.edges() <> {} by XBOOLE_0:def 7; then
        consider e being set such that
    B0: e in Q.edges() /\ R.edges() by XBOOLE_0:def 1; 
    B9: e in Q.edges() by B0,XBOOLE_0:def 3;
        e in R.edges() by B0,XBOOLE_0:def 3; then
        consider n being even Element of NAT such that
    B1: 1 <= n & n <= 7 & R.n = e by Od,GLIB_001:100;
    B2: n = 0 or n = 2 or n = 4 or n = 6 by B1,Even103; 
        per cases by B2,B1;
        suppose C0: n = 2; 2*0+1 < len R by Od; then
            R.(1+1) Joins R.1,R.(1+2),G by GLIB_001:def 3; then
            y in Q.vertices() by B1,C0,B9,Pi,GLIB_001:106; then
            y in A by Qz;
            hence contradiction by A8,Ha,XBOOLE_0:def 3; end;
        suppose C0: n = 4; 2*1+1 < len R by Od; then
            R.(3+1) Joins R.3,R.(3+2),G by GLIB_001:def 3; then
            y in Q.vertices() by B1,C0,B9,Pi,GLIB_001:106; then
            y in A by Qz;
            hence contradiction by A8,Ha,XBOOLE_0:def 3; end;
        suppose C0: n = 6; 2*2+1 < len R by Od; then
            R.(5+1) Joins R.5,R.(5+2),G by GLIB_001:def 3; then
            x in Q.vertices() by B1,C0,B9,Pi,GLIB_001:106; then
            x in A by Qz; 
            hence contradiction by A8,Nx,XBOOLE_0:def 3; end;
    end;
    now let v be set such that B0: v in Q.vertices() /\ R.vertices();
        v in Q.vertices() by B0,XBOOLE_0:def 3; then
    B1: v in A by Qz;
        v in {dd,y,x,cc} by Ov,B0,XBOOLE_0:def 3; then
        v = dd or v = y or v = x or v = cc by ENUMSET1:def 2;
      hence v in {Q.first(), Q.last()}
         by Ha,TARSKI:def 2,Nx,A8,B1,XBOOLE_0:def 3;
    end; then
Pf1:Q.vertices() /\ R.vertices() c= {Q.first(), Q.last()} by TARSKI:def 3;
    now let v be set such that B0: v in {Q.first(), Q.last()};
        per cases by B0,TARSKI:def 2;
        suppose B2: v = cc; then
        B3: v in Q.vertices() by GLIB_001:89;
            v in R.vertices() by B2,Pi,Od,GLIB_001:88;
           hence v in Q.vertices() /\ R.vertices() by B3,XBOOLE_0:def 3; end;
        suppose B2: v = dd; then
        B3: v in Q.vertices() by GLIB_001:89; 2*0+1 <= len R by Od; then
            v in R.vertices() by B2,Pi,GLIB_001:88;
           hence v in Q.vertices() /\ R.vertices() by B3,XBOOLE_0:def 3; end;
    end; then
    {Q.first(),Q.last()} c= Q.vertices()/\R.vertices() by TARSKI:def 3; then 
Pf: Q.vertices() /\ R.vertices() = { Q.first(), Q.last() }
        by Pf1,XBOOLE_0:def 10;

    :::::::::: properties of C ::::::::::::
    set C = Q.append(R);
Q:  C is Cycle-like by Pa, Pb, Pc, Pd, Pe, Pf, Pg, Ph, PathLike03;
Qg: len C +1+-1 = len Q + len R+-1 by Pg,GLIB_001:29;

Ra: C.(len Q+6) = R.(6+1) by Od,Pg,GLIB_001:34; 
Re: C.(len Q+4) = R.(4+1) by Od,Pg,GLIB_001:34;
Rb: C.(len Q+2) = R.(2+1) by Od,Pg,GLIB_001:34; 
    C.length() = Q.length() + 3 by Pg,Od,PathLike04; then
    C.length() >= 1 + 3 by Ps,XREAL_1:9; then
    C.length() > 3 by NAT_1:38; then
    C is chordal by Q, DefChordalGraph;
    then consider m, n being odd Nat such that
Qb: m+2 < n and
Qc: n <= len C and C.m <> C.n and
Qd: ex e being set st e Joins C.m,C.n,G  and
Qe: C is Cycle-like implies not (m=1 & n = len C) & not (m=1 & n = len C-2) &
                            not (m=3 & n = len C) by ChordalWalk01;
Qm: 1 <= m by HEYTING3:1;
Qh: n <= len Q or n = len Q+2 or n = len Q+4 or n = len Q+6 proof
      per cases;
       suppose n <= len Q; hence thesis; end;
       suppose n > len Q; then A1: len Q +2 <= n by EvenOdd03;
      per cases by A1,REAL_1:def 5;
       suppose len Q +2 = n; hence thesis; end;
       suppose len Q +2 < n; then A2: len Q +2+2 <= n by EvenOdd03;
      per cases by A2, REAL_1:def 5;
       suppose len Q +4 = n; hence thesis; end;
       suppose len Q +2*2 < n; then len Q +4+2 <= n by EvenOdd03;
      hence thesis by Qg, Od, Qc, REAL_1:def 5; end; end; end;
    end;

    ::::::::::::: show C has no chord :::::::::::::
  consider e being set such that Qi: e Joins C.m,C.n,G by Qd;
  per cases by Qh;
  suppose S0: n <= len Q;
      1 <= n by HEYTING3:1; then
  S1: n in dom Q by S0,FINSEQ_3:27;
      m+2 <= len Q & m+0 <= m+2 by Qb,S0,XREAL_1:9,XREAL_1:2; then
      m <= len Q by XREAL_1:2; then
  S2: m in dom Q by Qm,FINSEQ_3:27;
      Q.m = C.m & Q.n = C.n by S1,S2,GLIB_001:33; 
      hence contradiction by Qi,S0,Qb,YZ,TopPath04; end;
  suppose S0: n = len Q + 2; then
      m < len Q by Qb, XREAL_1:8; then
  S2: m in dom Q by Qm, FINSEQ_3:27; then
      e Joins Q.m,y,G by S0,Rb,Pi,Qi,GLIB_001:33;
      hence contradiction by Qy,S0,Qb,S2; end;
  suppose S0: n = len Q + 4; then
      m+2+2 <= len Q+4 by Qb,EvenOdd03; then m+4 <= len Q +4; then
      m <= len Q by XREAL_1:8; then
  S4: m in dom Q by Qm, FINSEQ_3:27; then
  S6: e Joins Q.m,x,G by S0,Re,Pi,Qi,GLIB_001:33;
      per cases by Qm,REAL_1:def 5;
      suppose 1 = m; hence contradiction
        by Pa,Pb,Pc,Pd,Pe,Pf,Pg,Ph,PathLike03,Qe,S0,Qg,Od; end;
      suppose 1 < m; hence contradiction by S6,Qx,S4; end; end;
  suppose S0: n = len Q +6; then
      m+2+2 <= len Q+6 by Qb,EvenOdd03; then m+4 <= len Q +2+4; then
  S1: m <= len Q +2 by XREAL_1:8;
      per cases by S1, REAL_1:def 5;
      suppose m < len Q +2; then
      D1: m <= len Q by EvenOdd03; then
          m in dom Q by Qm, FINSEQ_3:27; then
      A1: C.m = Q.m by GLIB_001:33;
      C1: e Joins Q.1,Q.m,G by S0, A1, Qi, Ra, Pi,GLIB_000:17;
          now assume 1+2 >= m; then
              m< 2*1+1 by Pa,Pb,Pc,Pd,Pe,Pf,Pg,Ph,PathLike03,
                          Qe,S0,Qg,Od,REAL_1:def 5;then
              m <= 3-2 by EvenOdd02; then
              m < 1 by Pa,Pb,Pc,Pd,Pe,Pf,Pg,Ph,PathLike03,
                       Qe,S0,Qg,Od,REAL_1:def 5;
             hence contradiction by HEYTING3:1;
          end; then 2*0+1+2 < m;
          hence contradiction by C1, D1,YZ,TopPath04; end;
      suppose D0: m = len Q + 2;
      D1: e Joins Q.1,y,G by S0,Ra,Qi,D0,Rb,Pi,GLIB_000:17;
          3 <= len Q & 1 <= 3 by Pb,GLIB_001:126; then
          1 <= len Q by XREAL_1:2; then
          2*0+1 in dom Q & 1 <> len Q by YY,Md,DefAdjacent,Na,FINSEQ_3:27; 
          hence contradiction by Qy,D1; end; end;
  end;
end;

theorem :: Remark p. 83
for G being finite chordal _Graph, a, b being Vertex of G
 st a <> b & not a,b are_adjacent
for S being VertexSeparator of a,b st S is minimal
for H being removeVertices of G,S, a1 being Vertex of H st a = a1
for x, y being Vertex of G st x in S & y in S holds
 ex c being Vertex of G
  st c in H.reachableFrom(a1) & c,x are_adjacent & c,y are_adjacent
proof
    let G be finite chordal _Graph;
    let a,b be Vertex of G such that
A0: a <> b & not a,b are_adjacent;
    let S be VertexSeparator of a,b such that A1: S is minimal;
    let H be removeVertices of G,S, a1 be Vertex of H such that
A2: a = a1;
    let x,y be Vertex of G such that A3: x in S and A4: y in S;
    consider c being Vertex of G such that
A5: c in H.reachableFrom(a1) and
A6: for x being Vertex of G st x in S holds c,x are_adjacent
        by A0,A1,A2,tExercise12;
    c,x are_adjacent & c,y are_adjacent by A3,A4,A6; 
    hence thesis by A5;
end;

:: Golumbic, page 83, Lemma 4.2.
theorem DiracLemma2 : :: DiracLemma2
for G being non trivial finite chordal _Graph
 st not G is complete
  ex a,b being Vertex of G
   st a<>b & not a,b are_adjacent & a is simplicial & b is simplicial
proof let G be non trivial finite chordal _Graph such that
A0: not G is complete;
    defpred P[finite _Graph] means
    $1 is non trivial & $1 is chordal & not $1 is complete
    implies ex a,b being Vertex of $1 st a <> b & 
                     not a,b are_adjacent & a is simplicial & b is simplicial;
  
A1: for k being non zero Nat
     st for Gk being finite _Graph st Gk.order() < k holds P[Gk]
      holds for Gk1 being finite _Graph st Gk1.order() = k holds P[Gk1]
    proof let k be non zero Nat such that
    B1: for Gk being finite _Graph st Gk.order() < k holds P[Gk];
      let Gk1 be finite _Graph such that
    C1: Gk1.order() = k and
    D1:  Gk1 is non trivial and
    D1a: Gk1 is chordal and
    D1b: not Gk1 is complete;
         reconsider G=Gk1 as non trivial finite chordal _Graph by D1,D1a;
         consider a,b being Vertex of G such that
    A1: a <> b and
    A1a: not a,b are_adjacent by DefComplete, D1b;
         consider S being VertexSeparator of a,b such that
    A2: S is minimal by minVSexistance;
        consider Gs being inducedSubgraph of G,S;
        consider Gns being removeVertices of G,S;
        reconsider sa = a, sb = b as Vertex of Gns by A1,A1a,VS10;
        set A = Gns.reachableFrom(sa), B = Gns.reachableFrom(sb);
        consider Gas being inducedSubgraph of G,(A \/ S);
        consider Gbs being inducedSubgraph of G,(B \/ S);
        A c= the_Vertices_of Gns & B c= the_Vertices_of Gns; then
    A4: A c= the_Vertices_of G & B c= the_Vertices_of G by XBOOLE_1:1; then
    A5: A\/S is non empty Subset of the_Vertices_of G &
        B\/S is non empty Subset of the_Vertices_of G by XBOOLE_1:8;
    A6: A /\ B = {} by A1,A1a,VS11b;
   A11: now assume
        B1: b in A \/ S;                    
            not b in S by A1,A1a,DefVS; then
        C1: b in A by B1, XBOOLE_0:def 2;
            b in B by GLIB_002:9;
         hence contradiction by A6,C1,XBOOLE_0:def 3;
        end;
   A18: now assume
        B1: a in B \/ S;                    
            not a in S by A1,A1a,DefVS; then
        C1: a in B by B1, XBOOLE_0:def 2; 
            a in A by GLIB_002:9;
         hence contradiction by A6,C1,XBOOLE_0:def 3;
        end; 
        not a in S by A1,A1a,DefVS; then
        a in the_Vertices_of G \ S by XBOOLE_0:def 4; then
   A13: the_Vertices_of Gns = the_Vertices_of G \ S by GLIB_000:def 39;

    EE: Gas.order() <= k by C1,GLIB_000:78;
        now assume F1: Gas.order() = k;
        F3: the_Vertices_of Gas = the_Vertices_of G by F1,C1,TRIANG_1:3;
            the_Vertices_of Gas = A\/S by A5,GLIB_000:def 39;
          hence contradiction by A11,F3;
        end; then
   A14: Gas.order() < k by EE,REAL_1:def 5; 

    EE: Gbs.order() <= k by C1,GLIB_000:78;
        now assume F1: Gbs.order() = k;
        F3: the_Vertices_of Gbs = the_Vertices_of G by F1,C1,TRIANG_1:3;
            the_Vertices_of Gbs = B\/S by A5,GLIB_000:def 39;
         hence contradiction by A18,F3;
        end; then
   A15: Gbs.order() < k by EE,REAL_1:def 5; 
:: XXXXXXXXXXXXXXXXXXXX for A XXXXXXXXXXXXXXXXXXXXXXX
        ex a being Vertex of Gk1 st a in A & a is simplicial
        proof
            consider aa being set such that
        D1: aa in A by XBOOLE_0:def 1;
        D3: the_Vertices_of Gas = A \/ S by A5,GLIB_000:def 39;then
            reconsider a = aa as Vertex of Gas by D1, XBOOLE_0:def 2;
            ex c being Vertex of Gas st c in A & c is simplicial
            proof
              per cases;
              suppose Gas is complete; then a is simplicial by Simplicial0;
                hence thesis by D1;
              end;
              suppose E1: not Gas is complete;
                  not  Gas is trivial by E1, Completetr; then
                  consider a2,b2 being Vertex of Gas such that
              U6: a2 <> b2 and                            
              E5: not a2,b2 are_adjacent and
              E6: a2 is simplicial & b2 is simplicial by E1,A14,B1;
                  now assume F1: a2 in S & b2 in S;
                      reconsider a3 = a2, b3 = b2 as Vertex of G by F1;
                  F3: not a3,b3 are_adjacent by E5,A5,VAdjacent01;
                  F4: Gs is complete by F1, A1, A1a,A2,Chordal41;
                      reconsider a4 = a2, b4 = b2 as Vertex of Gs
                                                  by F1,GLIB_000:def 39;
                      a4,b4 are_adjacent by F4,U6,DefComplete;
                   hence contradiction by F3, F1, VAdjacent01;
                  end;
                  then b2 in A or a2 in A by D3, XBOOLE_0:def 2;
                 hence thesis by E6;
               end;
            end;
            then consider cc being Vertex of Gas such that
            E8: cc in A and
            E9: cc is simplicial;
            reconsider c = cc as Vertex of Gk1 by A4,E8;
                   
            now let x be set such that
            F1: x in Gk1.AdjacentSet({c});
                 assume not x in A\/S; then
             G0: not x in A & not x in S by XBOOLE_0:def 2;
                 reconsider x as Vertex of Gk1 by F1;
             G3: x in the_Vertices_of Gns by A13,G0,XBOOLE_0:def 4;
                 c,x are_adjacent by F1,AdjacentV00;
                 then consider e being set such that
             G2: e Joins c,x,Gk1 by DefAdjacent;
                 e Joins c,x,Gns by A13,G3,G2,E8,Joins01;
               hence contradiction by G0, E8, GLIB_002:10;
             end; then
             E10: Gk1.AdjacentSet({c}) c= A\/S by TARSKI:def 3;
                  c in A\/S by E8,XBOOLE_0:def 2; then
                  c is simplicial by A5,E9,E10,Simplicial2;
                 hence thesis by E8;
        end;
        then consider a being Vertex of Gk1 such that
    A7: a in A & a is simplicial;    
:: XXXXXXXXXXXXXX For B: proof by cut-n-paste XXXXXXXXXXXXX
        ex b being Vertex of Gk1 st b in B & b is simplicial
        proof
             consider aa being set such that
           D1: aa in B by XBOOLE_0:def 1;
           D3: the_Vertices_of Gbs = B \/ S by A5,GLIB_000:def 39;then
               reconsider a = aa as Vertex of Gbs by D1, XBOOLE_0:def 2;
                    
               ex c being Vertex of Gbs st c in B & c is simplicial
               proof
                 per cases;
                 suppose Gbs is complete;
                    then a is simplicial by Simplicial0;
                    hence thesis by D1;
                 end;
                 suppose E1: not Gbs is complete;
                        not  Gbs is trivial by E1, Completetr; then
                        consider a2,b2 being Vertex of Gbs such that
                    U6: a2 <> b2 and                            
                    E5: not a2,b2 are_adjacent and
                    E6: a2 is simplicial & b2 is simplicial by E1,A15,B1;
                        now assume F1: a2 in S & b2 in S;
                            reconsider a3 = a2, b3 = b2 as Vertex of G by F1;
                        F3: not a3,b3 are_adjacent by E5,A5,VAdjacent01;
                        F4: Gs is complete by F1, A1,A1a,A2,Chordal41;
                            reconsider a4 = a2, b4 = b2 as Vertex of Gs
                                                   by F1,GLIB_000:def 39;
                            a4,b4 are_adjacent by F4,U6,DefComplete;
                         hence contradiction by F3, F1, VAdjacent01;
                        end; then
                        b2 in B or a2 in B by D3, XBOOLE_0:def 2;
                      hence thesis by E6;
                     end;
                   end;
                   then consider cc being Vertex of Gbs such that
               E8: cc in B and
               E9: cc is simplicial;
                   reconsider c = cc as Vertex of Gk1 by A4,E8;
                   
                  now let x be set such that
                   F1: x in Gk1.AdjacentSet({c});
                      assume not x in B\/S; then
                   G0: not x in B & not x in S by XBOOLE_0:def 2;
                       reconsider x as Vertex of Gk1 by F1;
                   G3: x in the_Vertices_of Gns by A13,G0,XBOOLE_0:def 4;
                       c,x are_adjacent by F1,AdjacentV00;
                       then consider e being set such that
                   G2: e Joins c,x,Gk1 by DefAdjacent;
                       e Joins c,x,Gns by E8,A13,G3,G2,Joins01;
                       hence contradiction by G0, E8, GLIB_002:10; 
                   end; then
              E10: Gk1.AdjacentSet({c}) c= B\/S by TARSKI:def 3;
                   c in B\/S by E8,XBOOLE_0:def 2; then
                   c is simplicial by A5,E9,E10,Simplicial2;
                   hence thesis by E8;
        end;
        then consider b being Vertex of Gk1 such that
    A8: b in B & b is simplicial;
    A9: now assume a,b are_adjacent; then consider e being set such that
        B2: e Joins a,b,Gk1 by DefAdjacent;
            reconsider aa=a, bb=b as Vertex of Gns by A7,A8;
        B5: e Joins aa,bb,Gns by A13,B2,Joins01;
            bb in A by A7, B5,GLIB_002:10; 
          hence contradiction by A6,A8,XBOOLE_0:def 3;
        end;
        a<>b by A6,A7,A8,XBOOLE_0:def 3;
     hence thesis by A7,A8,A9;
    end;  
    for G being finite _Graph holds P[G] from FinGraphOrderCompInd(A1); 
  hence thesis by A0;
end;

theorem DiracLemma1 : :: DiracLemma1   
for G being finite chordal _Graph ex v being Vertex of G st v is simplicial
proof let G be finite chordal _Graph;
    per cases;
    suppose A0: G is complete;
        consider u being Vertex of G; 
        u is simplicial by A0,Simplicial0;
     hence thesis;
    end;
    suppose A0: not G is complete; then
    A1: not G is trivial by Completetr;
        consider a,b being Vertex of G such that
    A3: a<>b & not a,b are_adjacent &
        a is simplicial & b is simplicial by A0,A1, DiracLemma2;   
     thus thesis by A3;
    end;
end;

begin :: Vertex Elimination Scheme :: Golumbic, p. 82

definition let G be finite _Graph;
  mode VertexScheme of G -> FinSequence of the_Vertices_of G means : DefVSch :
    it is one-to-one & rng it = the_Vertices_of G;
  existence proof
    consider p being FinSequence such that
A1: rng p = the_Vertices_of G & p is one-to-one by FINSEQ_4:73;
    reconsider p as FinSequence of the_Vertices_of G by A1,FINSEQ_1:def 4;
    take p;
    thus thesis by A1;
   end;
end;

registration
  let G be finite _Graph;
  cluster -> non empty VertexScheme of G;
  correctness proof
   let S be VertexScheme of G;
    rng S = the_Vertices_of G by DefVSch; 
   hence S is non empty by RELAT_1:60; 
  end;
end;

theorem 
for G being finite _Graph, S being VertexScheme of G
 holds len S = card the_Vertices_of G
proof let G be finite _Graph, S be VertexScheme of G;
   rng S = the_Vertices_of G & S is one-to-one by DefVSch;
 hence len S = card the_Vertices_of G by FINSEQ_4:77;
end;

theorem 
for G being finite _Graph, S being VertexScheme of G holds 1 <= len S
proof let G be finite _Graph, S be VertexScheme of G;
   len S <> 0 by GRAPH_5:5; 
  hence 1 <= len S by NAT_1:39;
end;

theorem cuVscheme01:
for G, H being finite _Graph, g being VertexScheme of G
 st G == H holds g is VertexScheme of H
proof let G,H be finite _Graph, g be VertexScheme of G such that A: G == H;
B: g is FinSequence of the_Vertices_of H by A,GLIB_000:def 36;
   g is one-to-one & rng g = the_Vertices_of G by DefVSch; then
   g is one-to-one & rng g = the_Vertices_of H by A,GLIB_000:def 36; 
  hence g is VertexScheme of H by B,DefVSch;
end;

definition let G be finite _Graph, S be VertexScheme of G, x be Vertex of G;
  redefine func x..S -> non zero Element of NAT;
  correctness proof
     rng S = the_Vertices_of G by DefVSch; then
     0+1 <= x..S by FINSEQ_4:31; 
    hence x..S is non zero Element of NAT;
  end;
end;

definition let G be finite _Graph, S be VertexScheme of G, n be Nat;
  redefine func S.followSet(n) -> Subset of the_Vertices_of G; 
  coherence proof
   n in NAT & len S in NAT by ORDINAL1:def 13; then
A: rng (n,len S)-cut S c= rng S by GRAPH_2:11;
   now let x be set; assume x in S.followSet(n);
     then x in rng S by A;
    hence x in the_Vertices_of G by DefVSch;
   end; 
   hence S.followSet(n) is Subset of the_Vertices_of G by TARSKI:def 3;
  end;
end;

theorem NeVSchFol: :: NeVSchFol:
for G being finite _Graph, S being VertexScheme of G,
    n being non zero natural number st n <= len S
  holds S.followSet(n) is non empty
proof
  let G be finite _Graph, S be VertexScheme of G;
  let n be non zero Nat such that A1: n <= len S;
  0 <= n by NAT_1:18; then 0 < n by REAL_1:def 5; then
  0+1 <= n by NAT_1:38; then 
Ba: len ((n, len S)-cut S) + n = len S + 1 by A1, GRAPH_2:def 1; 
     len S + 1 - n <> 0 by A1, NAT_1:38;
  then (n, len S)-cut S <> {} by Ba,FINSEQ_1:25;
 hence S.followSet(n) is non empty by FINSEQ_1:27; 
end;

definition let G be finite _Graph, S be VertexScheme of G;
  attr S is perfect means                                       :DefPerfectSch:
    for n being non zero natural number st n <= len S
    for Gf being inducedSubgraph of G,S.followSet(n)
    for v being Vertex of Gf st v = S.n holds v is simplicial;
end;

:: finite is needed unless we add loopless
theorem PerScheme01: :: PerScheme01
for G being finite trivial _Graph, v being Vertex of G
  ex S being VertexScheme of G st S = <*v*> & S is perfect
proof let G be finite trivial _Graph, v being Vertex of G;
   consider v1 being Vertex of G such that
A: the_Vertices_of G = {v1} by GLIB_000:25;
Aa: v1 = v by A, TARSKI:def 1;
  set S = <*v*>;
C: S is one-to-one by FINSEQ_3:102;
D: rng S = the_Vertices_of G by A, Aa, FINSEQ_1:56;
  reconsider S as VertexScheme of G by C, D, DefVSch;
  take S;
  thus S = <*v*>;
  let n be non zero Nat such that n <= len S;
  let Gf be inducedSubgraph of G,S.followSet(n);
  thus thesis by Simplicial01;
end;

theorem 
for G being finite _Graph, V being VertexScheme of G holds
  V is perfect iff
  for a,b,c being Vertex of G st b<>c & a,b are_adjacent & a,c are_adjacent
  for va,vb,vc being natural number
    st va in dom V & vb in dom V & vc in dom V & V.va = a &
       V.vb = b & V.vc = c & va < vb & va < vc
      holds b,c are_adjacent
proof let G be finite _Graph, V be VertexScheme of G;
R0: rng V = the_Vertices_of G by DefVSch;
R1: V is one-to-one by DefVSch;
P: now let a,b,c be Vertex of G such that
A1: b<>c & a,b are_adjacent & a,c are_adjacent & not b,c are_adjacent;
       let va,vb,vc be Nat such that
A2: va in dom V & vb in dom V & vc in dom V &
    V.va=a & V.vb=b & V.vc=c & va < vb & va < vc;
A7: a <> b & a <> c by A2,R1,FUNCT_1:def 8;
    assume A3: V is perfect;
A4: 1 <= va & va <= len V by A2,FINSEQ_3:27; then
ZZa: 0 < va by XREAL_1:2; 
A5: V.followSet(va) is non empty by A4,ZZa,NeVSchFol;
    consider Gf being inducedSubgraph of G,V.followSet(va);
    set fs = (va,len V)-cut V;
D1a: len fs + va - va = len V + 1 - va by A4,GRAPH_2:def 1;
D1b: len fs = len V - va + 1 by D1a;
    consider jb being Nat such that
D2a: va + jb = vb by A2,NAT_1:28;
    consider jc being Nat such that
D3a: va + jc = vc by A2,NAT_1:28;

     va - va <= len V - va by A4,XREAL_1:11; then
D4a: 0 < len fs by XREAL_1:41,D1b; then
D4b: fs.(0+1) = V.(va + 0) by A4,GRAPH_2:def 1;
D5c: now assume jb >= len fs; then
       va + jb >= len V + 1 - va + va by D1a,XREAL_1:9; then
       vb > len V by D2a, NAT_1:38; 
       hence contradiction by A2,FINSEQ_3:27;  
     end; 
D5b: fs.(jb+1) = V.(va + jb) by D5c, A4,GRAPH_2:def 1;
D6c: now assume jc >= len fs; then
       va + jc >= len V + 1 - va + va by D1a, XREAL_1:9; then
       vc > len V by D3a, NAT_1:38; 
       hence contradiction by A2,FINSEQ_3:27;  
     end; 
D6b: fs.(jc+1) = V.(va + jc) by D6c, A4,GRAPH_2:def 1;
    0+1 <= len fs by D4a,NAT_1:38; then
    0+1 in dom fs by FINSEQ_3:27; then
B1: a in V.followSet(va) by A2,D4b,FUNCT_1:12;
   
    0 <= jb by NAT_1:18; then 0+1 <= jb+1 by XREAL_1:9; then
    1 <= jb+1 & jb+1 <= len fs by D5c,NAT_1:38; then
    jb+1 in dom fs by FINSEQ_3:27; then
B2: b in V.followSet(va) by A2,D5b,D2a,FUNCT_1:12;

    0 <= jc by NAT_1:18; then 0+1 <= jc+1 by XREAL_1:9; then
    1 <= jc+1 & jc+1 <= len fs by D6c,NAT_1:38; then
    jc+1 in dom fs by FINSEQ_3:27; then
B3: c in V.followSet(va) by A2,D6b,D3a,FUNCT_1:12;
    reconsider ag=a as Vertex of Gf by GLIB_000:def 39,B1;

reconsider bg=b as Vertex of Gf by GLIB_000:def 39,B2;
    reconsider cg=c as Vertex of Gf by GLIB_000:def 39,B3;
B4: ag is simplicial by A3,ZZa,A4,A2,DefPerfectSch;
B5: ag,bg are_adjacent & ag,cg are_adjacent & not bg,cg are_adjacent
       by A5,A1,VAdjacent01;  then
    bg in Gf.AdjacentSet({ag}) & cg in Gf.AdjacentSet({ag}) by A7,AdjacentV00;
    then ex e being set st e Joins bg,cg,Gf by B4,A1,Simplicial03;
    hence contradiction by B5, DefAdjacent;
   end;

   now assume not V is perfect; then
    not (for n being non zero Nat st n <= len V
    for Gf being inducedSubgraph of G,V.followSet(n)
    for v being Vertex of Gf st v = V.n holds v is simplicial)
      by DefPerfectSch; then
       consider n being non zero Nat,
              Gf being (inducedSubgraph of G,V.followSet(n)),
                v being Vertex of Gf such that
   A1: n <= len V & v = V.n & not v is simplicial;
       1 <= n & n <= len V by A1,Nat00; then
   ZZ: n in dom V by FINSEQ_3:27;
       consider a,b being Vertex of Gf such that
   A2: a<>b & v<>a & v<>b and
   A0: v,a are_adjacent & v,b are_adjacent & not a,b are_adjacent
            by A1,Simplicial03a;
   C1: V.followSet(n) is non empty Subset of the_Vertices_of G by A1,NeVSchFol;
       then
   C2: the_Vertices_of Gf = V.followSet(n) by GLIB_000:def 39;
       reconsider vg=v as Vertex of G by C2,TARSKI:def 3;
   C4: a in the_Vertices_of G by C2,TARSKI:def 3; 
       reconsider ag=a, bg=b as Vertex of G by C2,TARSKI:def 3;
   C5: b in the_Vertices_of G by C2,TARSKI:def 3; 
   A3: vg,ag are_adjacent & vg,bg are_adjacent & not ag,bg are_adjacent
          by C1,A0,VAdjacent01;
   E2: a in rng V by C2,TARSKI:def 3,R0; 
       consider va being Element of NAT such that
   B2: va in dom V & V.va = a by C4, R0,FINSEQ_2:11;
   E3: b in rng V by C2,TARSKI:def 3,R0; 
       consider vb being Element of NAT such that
   B3: vb in dom V & V.vb = b by C5, R0, FINSEQ_2:11;
   B4a: now assume va <= n; then
       D1: va < n by A2,A1,B2,REAL_1:def 5;
           a..V >= n by Follow00,E2,C2,ZZ,R1; then
           va < a..V by D1,XREAL_1:2;
         hence contradiction by B2, FINSEQ_4:34;
       end;
   B5a:  now assume vb <= n; then
       D1: vb < n by A2,A1,B3,REAL_1:def 5;
           b..V >= n by Follow00,E3,C2,ZZ,R1; then
           vb < b..V by D1,XREAL_1:2;
         hence contradiction by B3, FINSEQ_4:34;
       end;
       per cases by A2,B2,B3,REAL_1:def 5;
       suppose va < vb;
       thus ex a,b,c being Vertex of G, va,vb,vc being Nat st
             b<>c & a,b are_adjacent & a,c are_adjacent &
             va in dom V & vb in dom V & vc in dom V & 
             V.va = a & V.vb = b & V.vc = c & va < vb & va < vc &
             not b,c are_adjacent by A2,A3,A1,B2,B3,B4a,B5a,ZZ; end;
       suppose vb < va;  
       thus ex a,b,c being Vertex of G, va,vb,vc being Nat st
             b<>c & a,b are_adjacent & a,c are_adjacent &
             va in dom V & vb in dom V & vc in dom V & 
             V.va = a & V.vb = b & V.vc = c & va < vb & va < vc &
             not b,c are_adjacent by A2,A3,A1,B2,B3,B4a,B5a,ZZ; end;
   end;
  hence thesis by P;
end;

:: Golubmic pg 83-84, Theorem 4.1 (i) ==> (ii)
registration let G be finite chordal _Graph;
  cluster perfect VertexScheme of G;
  existence proof
    defpred P[finite _Graph] means
    $1 is chordal implies ex S being VertexScheme of $1 st S is perfect;
A1: now let k be non zero Nat such that
    B1: for Gk being finite _Graph st Gk.order() < k holds P[Gk];
     let Gk1 be finite _Graph such that
    C1: Gk1.order() = k;
     thus P[Gk1] proof
        assume C2: Gk1 is chordal;
        per cases;
        suppose k = 1; then
        A2: Gk1 is trivial by C1,GLIB_000:29;
            consider v being Vertex of Gk1;
            ex S being VertexScheme of Gk1 st S = <*v*> & S is perfect
               by A2, PerScheme01;
          hence thesis;
        end;
        suppose k <> 1; then
            reconsider G=Gk1 as non trivial finite chordal _Graph
                     by C2,C1,GLIB_000:29;
            consider x being Vertex of G such that
        D2: x is simplicial by DiracLemma1;
            consider H being removeVertex of G,x;
        TZ: the_Vertices_of G\{x} is non empty by GLIB_000:23; then
        T0: the_Vertices_of H=the_Vertices_of G\{x} by GLIB_000:def 39; 
            H.order() = card (the_Vertices_of G\{x}) by TZ,GLIB_000:def 39
                  .= G.order() - card {x} by CARD_2:63
                  .= k - 1 by C1, CARD_2:60; then
            D3: H.order() < k by XREAL_1:148;
                consider T being VertexScheme of H such that
            D6: T is perfect by B1,D3;
                set S = <*x*>^T;
                rng T = the_Vertices_of G\{x} by T0,DefVSch; then
                rng S = the_Vertices_of G\{x} \/ rng <*x*> by FINSEQ_1:44;then
                rng S = the_Vertices_of G\{x} \/ {x} by FINSEQ_1:55; then
                rng S = {x} \/ the_Vertices_of G by XBOOLE_1:39; then
            SS: rng S = the_Vertices_of G by XBOOLE_1:12; then
                reconsider S as FinSequence of the_Vertices_of G
                     by FINSEQ_1:def 4;
                {x} /\ rng T = {x} /\ (the_Vertices_of G\{x}) by T0,DefVSch
                     .= ({x} /\ the_Vertices_of G) \ {x} by XBOOLE_1:49
                     .= {x} \ {x} by XBOOLE_1:28 
                     .= {} by XBOOLE_1:37; then
                {x} misses rng T by XBOOLE_0:def 7; then
            D8: rng <*x*> misses rng T by FINSEQ_1:55;
            D9: <*x*> is one-to-one by FINSEQ_3:102;
                T is one-to-one by DefVSch; then
                S is one-to-one by D8,D9,FINSEQ_3:98; then
                reconsider S as VertexScheme of Gk1 by SS,DefVSch;
                take S;
                let n be non zero Nat such that
            F1: n <= len S;
                let Gf be inducedSubgraph of Gk1,S.followSet(n);
                let v be Vertex of Gf such that
            F2: v = S.n;
            F3: 1 <= n by NAT_1:39;
                per cases by F3,REAL_1:def 5;
                suppose G1: 1 = n; then
                G2: x = v by F2,FINSEQ_1:58; 
                    S.followSet(n) = rng S by G1, GRAPH_2:7
                                  .= the_Vertices_of G by DefVSch; then
                    Gf == G by GLIB_000:97;
                    hence v is simplicial by D2,G2,Simplicial1;
                end;
                suppose G10: 1 < n; then
                    1+(-1) < n+(-1) by XREAL_1:10; then 
                    reconsider n1 = n - 1 as non zero Element of NAT
                         by INT_1:16;
                    len <*x*> = 1 by FINSEQ_1:56; then
                G0: S.n = T.n1 by F1,G10,FINSEQ_1:37;
                    n+(-1) <= len S+(-1) by F1,XREAL_1:9; then
                    n1 <= len <*x*> + len T + (-1) by FINSEQ_1:35; then
               G99: n1 <= 1 + len T + (-1) by FINSEQ_1:56; 
               G98: T.followSet(n1) = S.followSet(n1+1) by Follow03;
                    T.followSet(n1) is non empty by G99,NeVSchFol; then 
                  Gf is inducedSubgraph of H,T.followSet(n1)
                      by G98,T0,Subgraph01a;
                hence v is simplicial by G99,F2,G0,D6,DefPerfectSch;
              end;
              end;
            end;
   end;
   for G being finite _Graph holds P[G] from FinGraphOrderCompInd(A1); then
   consider S being VertexScheme of G such that A1: S is perfect;
   take S;
   thus S is perfect by A1;
  end;
end;

theorem 
for G, H being finite chordal _Graph, g being perfect VertexScheme of G
 st G == H holds g is perfect VertexScheme of H
proof let G,H be finite chordal _Graph, g be perfect VertexScheme of G  
  such that A: G == H;
  reconsider h=g as VertexScheme of H by A,cuVscheme01;
  now let n be non zero Nat such that B1: n <= len h;
      let Hf be inducedSubgraph of H,h.followSet(n);
      let vh be Vertex of Hf such that B2: vh = h.n;
      G.edgesBetween(g.followSet(n)) = H.edgesBetween(g.followSet(n))
         by A,GLIB_000:93; then
      reconsider Gf = Hf as inducedSubgraph of G,g.followSet(n)
         by A,GLIB_000:98;
      reconsider vg = vh as Vertex of Gf;
      vg is simplicial by B1,B2,DefPerfectSch;
    hence vh is simplicial;
  end;
 hence g is perfect VertexScheme of H by DefPerfectSch;
end;

:: Golubmic pg 83-84,  Theorem 4.1 (ii) ==> (i)
theorem :: Chordal41c: 
for G being finite _Graph
 st ex S being VertexScheme of G st S is perfect holds G is chordal
proof
   let G be finite _Graph;
   given S being VertexScheme of G such that
A1: S is perfect;
   let P be Walk of G such that B0: P.length() > 3 & P is Cycle-like;
B:  P is Path-like by B0,GLIB_001:def 31;  
B2: P.vertices() is non empty by GLIB_001:89;
BB: rng S = the_Vertices_of G by DefVSch;
    consider x being set such that
B3: x in P.vertices() and
B4: for y being set st y in P.vertices() holds x..S <= y..S
          by BB,B2,Index01;
    reconsider x as Vertex of G by B3;
    set n = x..S;
Ba: rng S = the_Vertices_of G by DefVSch; then
B9: n <= len S by FINSEQ_4:31;
Bb: n in dom S by Ba,FINSEQ_4:30;
Bc: S is one-to-one by DefVSch;
        now let y be set such that C1: y in P.vertices();
            reconsider z=y as Vertex of G by C1;
            x..S <= z..S by C1,B4; 
            hence y in S.followSet(n) by Ba, Bb, Bc, Follow00;
        end; then
B5: P.vertices() c= S.followSet(n) by TARSKI:def 3;
    consider H being inducedSubgraph of G,S.followSet(n);
T9: rng S = the_Vertices_of G by DefVSch; then
T0: n <= len S by FINSEQ_4:31;
    x in S.followSet(n) by Ba,Bb,Bc,Follow00; then
    reconsider y=x as Vertex of H by GLIB_000:def 39;
    S.n = x by T9,FINSEQ_4:29; then
T1: y is simplicial by A1,T0,DefPerfectSch;
    
TT: S.followSet(n) is non empty by B9, NeVSchFol; then
    reconsider C=P as Walk of H by B5,Walk04;
    reconsider C as Path of H by B, GLIB_001:177;
    P is non trivial & P is closed by B0,GLIB_001:def 31; then
    C is non trivial & C is closed by GLIB_001:177; then
B6: C is Cycle-like by GLIB_001:def 31;
B6a: C.length() > 3 by B0,GLIB_001:115;
    y in C.vertices() by B3,GLIB_001:99; then
     consider a,b being odd Nat such that
B7: a+2 < b & b <= len C and
B8: C.a <> C.b & C.a in H.AdjacentSet({y}) & C.b in H.AdjacentSet({y}) and
B8a: for e being set st e in C.edges() holds not e Joins C.a,C.b,H
     by B6,B6a,Cycle01a;  :: <==
    consider e being set such that
B9: e Joins C.a,C.b,H by B8,T1,Simplicial03;
    C is chordal by B7,B8,B8a,B9,DefChordalWalk; 
  hence P is chordal by TT, ChordalWalk03;
end;
