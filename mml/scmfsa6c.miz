:: On the compositions of macro instructions, Part III
::  by Noriko Asamoto , Yatsuka Nakamura , Piotr Rudnicki and Andrzej Trybulec
::
:: Received July 22, 1996
:: Copyright (c) 1996-2011 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies AMI_1, SCMFSA_2, FSM_1, CARD_1, SCMFSA6B, TURING_1, FUNCT_1,
      RELAT_1, ARYTM_3, FUNCT_4, SCMFSA6A, TARSKI, XBOOLE_0, CIRCUIT2, NUMBERS,
      SUBSET_1, GRAPHSP, AMI_3, XXREAL_0, SF_MASTR, FUNCOP_1, FUNCT_7,
      STRUCT_0, ARYTM_1, INT_1, COMPLEX1, PARTFUN1, FINSEQ_1, FINSEQ_2,
      MSUALG_1, AOFA_I00, ORDINAL1, SCMNORM, PBOOLE, SCMFSA6C,
      AMISTD_1, AMISTD_2, COMPOS_1;
 notations TARSKI, XBOOLE_0, SUBSET_1, ENUMSET1, CARD_1, NUMBERS, XCMPLX_0,
      NAT_1, INT_1, COMPLEX1, RELAT_1, FUNCT_1, PARTFUN1, FINSEQ_1, FINSEQ_2,
      FUNCOP_1, FUNCT_4, PBOOLE, STRUCT_0, MEMSTR_0, COMPOS_1, EXTPRO_1,
      AMISTD_1, AMISTD_2, FUNCT_7, SCMFSA_2, SCMFSA6A, SF_MASTR, SCMFSA6B,
      XXREAL_0;
 constructors DOMAIN_1, SETWISEO, XXREAL_0, INT_2, SCMFSA6A, SF_MASTR,
      SCMFSA6B, RELSET_1, PRE_POLY, AMISTD_1, AMISTD_2, PBOOLE, FUNCT_4,
      MEMSTR_0;
 registrations XBOOLE_0, SETFAM_1, RELAT_1, FUNCT_1, FUNCOP_1, FINSET_1,
      NUMBERS, XREAL_0, INT_1, SCMFSA_2, SCMFSA6A, SF_MASTR, SCMFSA6B,
      ORDINAL1, RELSET_1, COMPOS_1, STRUCT_0, EXTPRO_1, SCMFSA10, PBOOLE,
      FUNCT_4, AMISTD_2, MEMSTR_0, AMISTD_1;
 requirements NUMERALS, BOOLE, SUBSET, ARITHM;
 definitions FUNCOP_1, COMPOS_1, EXTPRO_1, SCMFSA6B, SCMFSA6A, PARTFUN1,
      MEMSTR_0, AMISTD_1;
 theorems RELAT_1, FUNCT_7, FUNCT_4, FUNCT_1, SCMFSA_3, ZFMISC_1, FUNCOP_1,
      TARSKI, NAT_1, SCMFSA_2, ENUMSET1, GRFUNC_1, SCMFSA6A, SF_MASTR,
      SCMFSA6B, XBOOLE_0, XBOOLE_1, PARTFUN1, COMPOS_1, EXTPRO_1, AMISTD_2,
      PBOOLE, STRUCT_0, MEMSTR_0, AMISTD_1;

begin :: Consequences of the main theorem from SCMFSA6B

reserve x for set,
  i for Instruction of SCM+FSA,
  a,b for Int-Location,
  f for FinSeq-Location,
  l, l1 for Element of NAT,
  s,s1,s2 for State of SCM+FSA,
  P,P1,P2 for Instruction-Sequence of SCM+FSA;

set SA0 = Start-At(0,SCM+FSA);

theorem
  for I being keeping_0 parahalting Program of SCM+FSA, J being
parahalting Program of SCM+FSA holds IExec(I ';' J,P,s).a
 = IExec(J,P,IExec(I,P,s)).a
proof
  let I be keeping_0 parahalting Program of SCM+FSA, J be parahalting Program
  of SCM+FSA;
A1: not a in dom Start-At (IC IExec(J,P,IExec(I,P,s)) + card I,SCM+FSA)
 by SCMFSA_2:102;
  IExec(I ';' J,P,s) = IncIC(IExec(J,P,IExec(I,P,s)),card I) by SCMFSA6B:20;
  hence thesis by A1,FUNCT_4:11;
end;

theorem
  for I being keeping_0 parahalting Program of SCM+FSA, J being
parahalting Program of SCM+FSA
 holds IExec(I ';' J,P,s).f = IExec(J,P,IExec(I,P,s)).f
proof
  let I be keeping_0 parahalting Program of SCM+FSA, J be parahalting Program
  of SCM+FSA;
A1: not f in dom Start-At (IC IExec(J,P,IExec(I,P,s)) + card I,SCM+FSA)
 by SCMFSA_2:103;
  IExec(I ';' J,P,s) = IncIC(IExec(J,P,IExec(I,P,s)),card I) by SCMFSA6B:20;
  hence thesis by A1,FUNCT_4:11;
end;

begin :: Properties of simple macro instructions

definition
  let i be Instruction of SCM+FSA;
  attr i is parahalting means
  :Def1:
  Macro i is parahalting;
  attr i is keeping_0 means
  :Def2:
  Macro i is keeping_0;
end;

Lm1: Macro halt SCM+FSA is parahalting
proof
  let s be 0-started State of SCM+FSA;
  set m = Macro halt SCM+FSA;
  set m1 = m;
A1: Start-At(0,SCM+FSA) c= s by MEMSTR_0:29;
  let P be Instruction-Sequence of SCM+FSA
  such that
A2: m c= P;
B4: IC SCM+FSA in dom Start-At(0,SCM+FSA) by MEMSTR_0:15;
  take 0;
A6: dom P = NAT by PARTFUN1:def 2;
    thus IC Comput(P,s,0) in dom P by A6;
  dom m = { 0, 1} by COMPOS_1:61;
  then
A7:  0 in dom m by TARSKI:def 2;
  CurInstr(P,Comput(P,s,0))
   = CurInstr(P,s)  by EXTPRO_1:2
    .= P.IC s by A6,PARTFUN1:def 6
    .= P.IC Start-At(0,SCM+FSA) by A1,B4,GRFUNC_1:2
    .= P.0 by FUNCOP_1:72
    .= m. 0 by A2,A7,GRFUNC_1:2
    .= halt SCM+FSA by COMPOS_1:58;
    hence thesis;
end;

Lm2: Macro halt SCM+FSA is keeping_0
proof
  set Mi = Macro halt SCM+FSA;
    let s be 0-started State of SCM+FSA;
A1: Start-At(0,SCM+FSA) c= s by MEMSTR_0:29;
    let P be Instruction-Sequence of SCM+FSA;
    assume
A2:  Mi c= P;
    let k be Element of NAT;
A3: s = Comput(P,s,0) by EXTPRO_1:2;
A4:  (P)/.IC s = P.IC s by PBOOLE:143;
A5: 0 in dom Mi by COMPOS_1:60;
 Comput(P,s,0) =
  s by EXTPRO_1:2;
  then
    CurInstr(P,Comput(P,s,0))
       = P.0 by A1,A4,MEMSTR_0:39
      .= Mi.0 by A2,A5,GRFUNC_1:2
      .= halt SCM+FSA by COMPOS_1:58;
    hence (Comput(P,s,k)).intloc 0 = s.intloc 0 by A3,EXTPRO_1:5,NAT_1:2;
end;

registration
  cluster halt SCM+FSA -> keeping_0 parahalting;
  coherence
  proof
    thus Macro halt SCM+FSA is keeping_0 parahalting by Lm1,Lm2;
  end;
end;

registration
  cluster keeping_0 parahalting for Instruction of SCM+FSA;
  existence
  proof
    take halt SCM+FSA;
    thus thesis;
  end;
end;

registration
  let i be parahalting Instruction of SCM+FSA;
  cluster Macro i -> parahalting;
  coherence by Def1;
end;

registration
  let i be keeping_0 Instruction of SCM+FSA;
  cluster Macro i -> keeping_0;
  coherence by Def2;
end;

registration
  let a, b be Int-Location;
  cluster a := b -> parahalting;
  coherence
  proof
    set Ma = Macro (a := b);
    let s be 0-started State of SCM+FSA;
A1: Start-At(0,SCM+FSA) c= s by MEMSTR_0:29;
  let P be Instruction-Sequence of SCM+FSA
  such that
A2: Ma c= P;
    take 1;
A4: dom P = NAT by PARTFUN1:def 2;
    thus IC Comput(P,s,1) in dom P by A4;
    dom SA0 = {IC SCM+FSA} by FUNCOP_1:13;
    then
A5: IC SCM+FSA in dom SA0 by TARSKI:def 1;
A6: IC s = SA0.IC SCM+FSA by A5,A1,GRFUNC_1:2
      .=  0 by FUNCOP_1:72;
    then
A7: IC Exec(a:=b, s) = succ  0 by SCMFSA_2:63
      .=  (0+1);
A8:  1 in dom Ma by COMPOS_1:60;
A9:  0 in dom Ma by COMPOS_1:60;
A10: P.0 = Ma.0 by A2,A9,GRFUNC_1:2
     .= a:=b by COMPOS_1:58;
A11: P.1 = Ma.1 by A2,A8,GRFUNC_1:2
     .= halt SCM+FSA by COMPOS_1:59;
   Comput(P,s,0+1) = Following(P,
    Comput(P,s,0)) by EXTPRO_1:3
      .= Following(P,s) by EXTPRO_1:2
      .= Exec(a:=b, s) by A6,A4,A10,PARTFUN1:def 6;
    hence thesis by A7,A4,A11,PARTFUN1:def 6;
  end;
  cluster AddTo(a,b) -> parahalting;
  coherence
  proof
    set Ma = Macro (AddTo(a,b));
    let s be 0-started State of SCM+FSA;
A12: Start-At(0,SCM+FSA) c= s by MEMSTR_0:29;
  let P be Instruction-Sequence of SCM+FSA
  such that
A13: Ma c= P;
    take 1;
A15: dom P = NAT by PARTFUN1:def 2;
    thus IC Comput(P,s,1) in dom P by A15;
    dom SA0 = {IC SCM+FSA} by FUNCOP_1:13;
    then
A16: IC SCM+FSA in dom SA0 by TARSKI:def 1;
::    then
A17: IC s = SA0.IC SCM+FSA by A16,A12,GRFUNC_1:2
      .=  0 by FUNCOP_1:72;
    then
A18: IC Exec(AddTo(a,b), s) = succ  0 by SCMFSA_2:64
      .=  (0+1);
A19:   1 in dom Ma by COMPOS_1:60;
A20:  0 in dom Ma by COMPOS_1:60;
A21: P.0 = Ma.0 by A13,A20,GRFUNC_1:2
     .= AddTo(a,b) by COMPOS_1:58;
A22: P.1 = Ma.1 by A13,A19,GRFUNC_1:2
     .= halt SCM+FSA by COMPOS_1:59;
    Comput(P,s,0+1) = Following(P,
    Comput(P,s,0)) by EXTPRO_1:3
      .= Following(P,s) by EXTPRO_1:2
      .= Exec(AddTo(a,b), s) by A17,A15,A21,PARTFUN1:def 6;
    hence thesis by A18,A15,A22,PARTFUN1:def 6;
  end;
  cluster SubFrom(a,b) -> parahalting;
  coherence
  proof
    set Ma = Macro (SubFrom(a,b));
    let s be 0-started State of SCM+FSA;
A23: Start-At(0,SCM+FSA) c= s by MEMSTR_0:29;
  let P be Instruction-Sequence of SCM+FSA
  such that
A24: Ma c= P;
    take 1;
A26: dom P = NAT by PARTFUN1:def 2;
    thus IC Comput(P,s,1) in dom P by A26;
    dom SA0 = {IC SCM+FSA} by FUNCOP_1:13;
    then
A27: IC SCM+FSA in dom SA0 by TARSKI:def 1;
A28: IC s = SA0.IC SCM+FSA by A27,A23,GRFUNC_1:2
      .=  0 by FUNCOP_1:72;
    then
A29: IC Exec(SubFrom(a,b), s) = succ  0 by SCMFSA_2:65
      .=  (0+1);
A30:   1 in dom Ma by COMPOS_1:60;
A31:  0 in dom Ma by COMPOS_1:60;
A32: P.0 = Ma.0 by A24,A31,GRFUNC_1:2
     .= SubFrom(a,b) by COMPOS_1:58;
A33: P.1 = Ma.1 by A24,A30,GRFUNC_1:2
     .= halt SCM+FSA by COMPOS_1:59;
    Comput(P,s,0+1) = Following(P,
    Comput(P,s,0)) by EXTPRO_1:3
      .= Following(P,s) by EXTPRO_1:2
      .= Exec(SubFrom(a,b), s) by A28,A26,A32,PARTFUN1:def 6;
    hence thesis by A29,A26,A33,PARTFUN1:def 6;
  end;
  cluster MultBy(a,b) -> parahalting;
  coherence
  proof
    set Ma = Macro (MultBy(a,b));
    let s be 0-started State of SCM+FSA;
A34: Start-At(0,SCM+FSA) c= s by MEMSTR_0:29;
  let P be Instruction-Sequence of SCM+FSA
  such that
A35: Macro (MultBy(a,b)) c= P;
    take 1;
A37: dom P = NAT by PARTFUN1:def 2;
    thus IC Comput(P,s,1) in dom P by A37;
    dom SA0 = {IC SCM+FSA} by FUNCOP_1:13;
    then
A38: IC SCM+FSA in dom SA0 by TARSKI:def 1;
A39: IC s = SA0.IC SCM+FSA by A38,A34,GRFUNC_1:2
      .=  0 by FUNCOP_1:72;
    then
A40: IC Exec(MultBy(a,b), s) = succ  0 by SCMFSA_2:66
      .=  0+1;
A41:   1 in dom Ma by COMPOS_1:60;
A42:  0 in dom Ma by COMPOS_1:60;
A43: P.0 = Ma.0 by A35,A42,GRFUNC_1:2
     .= MultBy(a,b) by COMPOS_1:58;
A44: P.1 = Ma.1 by A35,A41,GRFUNC_1:2
     .= halt SCM+FSA by COMPOS_1:59;
    Comput(P,s,0+1) = Following(P,
    Comput(P,s,0)) by EXTPRO_1:3
      .= Following(P,s) by EXTPRO_1:2
      .= Exec(MultBy(a,b), s) by A39,A37,A43,PARTFUN1:def 6;
    hence thesis by A40,A37,A44,PARTFUN1:def 6;
  end;
  cluster Divide(a,b) -> parahalting;
  coherence
  proof
    set Ma = Macro (Divide(a,b));
    let s be 0-started State of SCM+FSA;
A45: Start-At(0,SCM+FSA) c= s by MEMSTR_0:29;
  let P be Instruction-Sequence of SCM+FSA
  such that
A46: Macro (Divide(a,b)) c= P;
    take 1;
A48: dom P = NAT by PARTFUN1:def 2;
    thus IC Comput(P,s,1) in dom P by A48;
    dom SA0 = {IC SCM+FSA} by FUNCOP_1:13;
    then
A49: IC SCM+FSA in dom SA0 by TARSKI:def 1;
A50: IC s = SA0.IC SCM+FSA by A49,A45,GRFUNC_1:2
      .=  0 by FUNCOP_1:72;
    then
A51: IC Exec(Divide(a,b), s) = succ  0 by SCMFSA_2:67
      .=  (0+1);
A52:   1 in dom Ma by COMPOS_1:60;
A53:  0 in dom Ma by COMPOS_1:60;
A54: P.0 = Ma.0 by A46,A53,GRFUNC_1:2
     .= Divide(a,b) by COMPOS_1:58;
A55: P.1 = Ma.1 by A46,A52,GRFUNC_1:2
     .= halt SCM+FSA by COMPOS_1:59;
    Comput(P,s,0+1) = Following(P,
    Comput(P,s,0)) by EXTPRO_1:3
      .= Following(P,s) by EXTPRO_1:2
      .= Exec(Divide(a,b), s) by A50,A48,A54,PARTFUN1:def 6;
    hence thesis by A51,A48,A55,PARTFUN1:def 6;
  end;
  let f be FinSeq-Location;
  cluster b := (f,a) -> parahalting;
  coherence
  proof
    set Ma = Macro (b:=(f,a));
    let s be 0-started State of SCM+FSA;
A56: Start-At(0,SCM+FSA) c= s by MEMSTR_0:29;
  let P be Instruction-Sequence of SCM+FSA
  such that
A57: Macro (b:=(f,a)) c= P;
    take 1;
A59: dom P = NAT by PARTFUN1:def 2;
    thus IC Comput(P,s,1) in dom P by A59;
    dom SA0 = {IC SCM+FSA} by FUNCOP_1:13;
    then
A60: IC SCM+FSA in dom SA0 by TARSKI:def 1;
A61: IC s = SA0.IC SCM+FSA by A60,A56,GRFUNC_1:2
      .=  0 by FUNCOP_1:72;
    then
A62: IC Exec(b:=(f,a), s) = succ  0 by SCMFSA_2:72
      .=  (0+1);
A63:   1 in dom Ma by COMPOS_1:60;
A64:  0 in dom Ma by COMPOS_1:60;
A65: P.0 = Ma.0 by A57,A64,GRFUNC_1:2
     .= b:=(f,a) by COMPOS_1:58;
A66: P.1 = Ma.1 by A57,A63,GRFUNC_1:2
     .= halt SCM+FSA by COMPOS_1:59;
    Comput(P,s,0+1) = Following(P,
    Comput(P,s,0)) by EXTPRO_1:3
      .= Following(P,s) by EXTPRO_1:2
      .= Exec(b:=(f,a), s) by A61,A59,A65,PARTFUN1:def 6;
    hence thesis by A62,A59,A66,PARTFUN1:def 6;
  end;
  cluster (f,a) := b -> parahalting keeping_0;
  coherence
  proof
    thus (f,a) := b is parahalting
    proof
      set Ma = Macro ((f,a):=b);
      let s be 0-started State of SCM+FSA;
A67:  Start-At(0,SCM+FSA) c= s by MEMSTR_0:29;
  let P be Instruction-Sequence of SCM+FSA
  such that
A68: Macro ((f,a):=b) c= P;
      take 1;
A70: dom P = NAT by PARTFUN1:def 2;
    thus IC Comput(P,s,1) in dom P by A70;
      dom SA0 = {IC SCM+FSA} by FUNCOP_1:13;
      then
A71:  IC SCM+FSA in dom SA0 by TARSKI:def 1;
A72:  IC s = SA0.IC SCM+FSA by A71,A67,GRFUNC_1:2
        .=  0 by FUNCOP_1:72;
      then
A73:  IC Exec((f,a):=b, s) = succ  0 by SCMFSA_2:73
        .=  (0+1);
A74:     1 in dom Ma by COMPOS_1:60;
A75:    0 in dom Ma by COMPOS_1:60;
A76: P.0 = Ma.0 by A68,A75,GRFUNC_1:2
     .= (f,a):=b by COMPOS_1:58;
A77: P.1 = Ma.1 by A68,A74,GRFUNC_1:2
     .= halt SCM+FSA by COMPOS_1:59;
      Comput(P,s,0+1) = Following(P,
      Comput(P,s,0)) by EXTPRO_1:3
        .= Following(P,s) by EXTPRO_1:2
        .= Exec((f,a):=b, s) by A72,A70,A76,PARTFUN1:def 6;
      hence thesis by A73,A70,A77,PARTFUN1:def 6;
    end;
    thus (f,a) := b is keeping_0
    proof
      set Ma = Macro ((f,a):=b);
      let s be 0-started State of SCM+FSA;
A78:  Start-At(0,SCM+FSA) c= s by MEMSTR_0:29;
    let P be Instruction-Sequence of SCM+FSA;
    assume
A79: Ma c= P;
      let k be Element of NAT;
      dom SA0 = {IC SCM+FSA} by FUNCOP_1:13;
      then
A80:  IC SCM+FSA in dom SA0 by TARSKI:def 1;
A81:  IC s = SA0.IC SCM+FSA by A80,A78,GRFUNC_1:2
        .=  0 by FUNCOP_1:72;
    0 in dom Ma by COMPOS_1:60;
      then
A82:  Ma. 0 = P.0 by A79,GRFUNC_1:2;
A83:  (P)/.IC s
 = P.IC s by PBOOLE:143;
A84:  Comput(P,s,0+1) = Following(P,
Comput(P,s,0)) by EXTPRO_1:3
        .= Following(P,s) by EXTPRO_1:2
        .= Exec((f,a):=b, s) by A81,A82,A83,COMPOS_1:58;
     1 in dom Ma by COMPOS_1:60;
      then Ma. 1 = P.1 by A79,GRFUNC_1:2;
      then
A85:  P.1 = halt SCM+FSA by COMPOS_1:59;
      IC Exec((f,a):=b, s) = succ  0 by A81,SCMFSA_2:73
        .=  (0+1);
      then
A86:  CurInstr(P,Comput(P,s,1)) = halt SCM+FSA by A85,A84,PBOOLE:143;
      per cases by NAT_1:14;
      suppose
        k = 0;
        hence thesis by EXTPRO_1:2;
      end;
      suppose
A87:    1 <= k;
        Comput(P,s,1).intloc 0 = s.intloc 0 by A84,SCMFSA_2:73;
        hence thesis by A86,A87,EXTPRO_1:5;
      end;
    end;
  end;
end;

registration
  let a be Int-Location, f be FinSeq-Location;
  cluster a :=len f -> parahalting;
  coherence
  proof
    set Ma = Macro (a:=len f);
    let s be 0-started State of SCM+FSA;
A1: Start-At(0,SCM+FSA) c= s by MEMSTR_0:29;
  let P be Instruction-Sequence of SCM+FSA
  such that
A2: Macro (a:=len f) c= P;
    take 1;
A4: dom P = NAT by PARTFUN1:def 2;
    thus IC Comput(P,s,1) in dom P by A4;
    dom SA0 = {IC SCM+FSA} by FUNCOP_1:13;
    then
A5: IC SCM+FSA in dom SA0 by TARSKI:def 1;
A6: IC s = SA0.IC SCM+FSA by A5,A1,GRFUNC_1:2
      .=  0 by FUNCOP_1:72;
    then
A7: IC Exec(a:=len f, s) = succ  0 by SCMFSA_2:74
      .=  (0+1);
A8:   1 in dom Ma by COMPOS_1:60;
A9:  0 in dom Ma by COMPOS_1:60;
A10: P.0 = Ma.0 by A2,A9,GRFUNC_1:2
     .= a:=len f by COMPOS_1:58;
A11: P.1 = Ma.1 by A2,A8,GRFUNC_1:2
     .= halt SCM+FSA by COMPOS_1:59;
    Comput(P,s,0+1) = Following(P,
    Comput(P,s,0)) by EXTPRO_1:3
      .= Following(P,s) by EXTPRO_1:2
      .= Exec(a:=len f, s) by A6,A4,A10,PARTFUN1:def 6;
    hence thesis by A7,A4,A11,PARTFUN1:def 6;
  end;
  cluster f :=<0,...,0> a -> parahalting keeping_0;
  coherence
  proof
    thus f :=<0,...,0> a is parahalting
    proof
      set Ma = Macro (f:=<0,...,0>a);
      let s be 0-started State of SCM+FSA;
A12:   Start-At(0,SCM+FSA) c= s by MEMSTR_0:29;
  let P be Instruction-Sequence of SCM+FSA
  such that
A13: Macro (f:=<0,...,0>a) c= P;
      take 1;
A15: dom P = NAT by PARTFUN1:def 2;
    thus IC Comput(P,s,1) in dom P by A15;
      dom SA0 = {IC SCM+FSA} by FUNCOP_1:13;
      then
A16:  IC SCM+FSA in dom SA0 by TARSKI:def 1;
A17:  IC s = SA0.IC SCM+FSA by A16,A12,GRFUNC_1:2
        .=  0 by FUNCOP_1:72;
      then
A18:  IC Exec(f:=<0,...,0>a, s) = succ  0 by SCMFSA_2:75
        .=  (0+1);
A19:     1 in dom Ma by COMPOS_1:60;
A20:    0 in dom Ma by COMPOS_1:60;
A21: P.0 = Ma.0 by A13,A20,GRFUNC_1:2
     .= f:=<0,...,0>a by COMPOS_1:58;
A22: P.1 = Ma.1 by A13,A19,GRFUNC_1:2
     .= halt SCM+FSA by COMPOS_1:59;
      Comput(P,s,0+1) = Following(P,
      Comput(P,s,0)) by EXTPRO_1:3
        .= Following(P,s) by EXTPRO_1:2
        .= Exec(f:=<0,...,0>a, s) by A17,A15,A21,PARTFUN1:def 6;
      hence thesis by A18,A15,A22,PARTFUN1:def 6;
    end;
    thus (f:=<0,...,0>a) is keeping_0
    proof
      set Ma = Macro (f:=<0,...,0>a);
      let s be 0-started State of SCM+FSA;
A23:  Start-At(0,SCM+FSA) c= s by MEMSTR_0:29;
    let P be Instruction-Sequence of SCM+FSA;
    assume
A24: Ma c= P;
      let k be Element of NAT;
      dom SA0 = {IC SCM+FSA} by FUNCOP_1:13;
      then
A25:  IC SCM+FSA in dom SA0 by TARSKI:def 1;
A26:  IC s = SA0.IC SCM+FSA by A25,A23,GRFUNC_1:2
        .=  0 by FUNCOP_1:72;
    0 in dom Ma by COMPOS_1:60;
      then
A27:  Ma. 0 = P.0 by A24,GRFUNC_1:2;
A28:  (P)/.IC s
 = P.IC s by PBOOLE:143;
A29:  Comput(P,s,0+1) = Following(P,
Comput(P,s,0)) by EXTPRO_1:3
        .= Following(P,s) by EXTPRO_1:2
        .= Exec(f:=<0,...,0>a, s) by A26,A27,A28,COMPOS_1:58;
     1 in dom Ma by COMPOS_1:60;
      then Ma. 1 = P.1 by A24,GRFUNC_1:2;
      then
A30:  P.1 = halt SCM+FSA by COMPOS_1:59;
      IC Exec(f:=<0,...,0>a, s) = succ  0 by A26,SCMFSA_2:75
        .=  (0+1);
      then
A31:  CurInstr(P,Comput(P,s,1
))
 = halt SCM+FSA by A30,A29,PBOOLE:143;
      per cases by NAT_1:14;
      suppose
        k = 0;
        hence thesis by EXTPRO_1:2;
      end;
      suppose
A32:    1 <= k;
        Comput(P,s,1).intloc 0 = s.intloc 0 by A29,SCMFSA_2:75;
        hence thesis by A31,A32,EXTPRO_1:5;
      end;
    end;
  end;
end;

registration
  let a be read-write Int-Location, b be Int-Location;
  cluster a := b -> keeping_0;
  coherence
  proof
    set Ma = Macro (a:=b);
    let s be 0-started State of SCM+FSA;
A1: Start-At(0,SCM+FSA) c= s by MEMSTR_0:29;
    let P be Instruction-Sequence of SCM+FSA;
    assume
A2: Ma c= P;
    let k be Element of NAT;
    dom SA0 = {IC SCM+FSA} by FUNCOP_1:13;
    then
A3: IC SCM+FSA in dom SA0 by TARSKI:def 1;
A4: IC s = SA0.IC SCM+FSA by A3,A1,GRFUNC_1:2
      .=  0 by FUNCOP_1:72;
  0 in dom Ma by COMPOS_1:60;
    then
A5: Ma. 0 = P.0 by A2,GRFUNC_1:2;
A6:  (P)/.IC s
 = P.IC s by PBOOLE:143;
A7: Comput(P,s,0+1) = Following(P,
Comput(P,s,0)) by EXTPRO_1:3
      .= Following(P,s) by EXTPRO_1:2
      .= Exec(a:=b, s) by A4,A5,A6,COMPOS_1:58;
   1 in dom Ma by COMPOS_1:60;
    then Ma. 1 = P.1 by A2,GRFUNC_1:2;
    then
A8: P.1 = halt SCM+FSA by COMPOS_1:59;
    IC Exec(a:=b, s) = succ  0 by A4,SCMFSA_2:63
      .=  (0+1);
    then
A9: CurInstr(P,Comput(P,s,1))
 = halt SCM+FSA by A8,A7,PBOOLE:143;
    per cases by NAT_1:14;
    suppose
      k = 0;
      hence thesis by EXTPRO_1:2;
    end;
    suppose
A10:   1 <= k;
      Comput(P,s,1).intloc 0 = s.intloc 0 by A7,SCMFSA_2:63;
      hence thesis by A9,A10,EXTPRO_1:5;
    end;
  end;
  cluster AddTo(a, b) -> keeping_0;
  coherence
  proof
    set Ma = Macro (AddTo(a,b));
    let s be 0-started  State of SCM+FSA;
A11: Start-At(0,SCM+FSA) c= s by MEMSTR_0:29;
    let P be Instruction-Sequence of SCM+FSA;
    assume
A12: Ma c= P;
    let k be Element of NAT;
    dom SA0 = {IC SCM+FSA} by FUNCOP_1:13;
    then
A13: IC SCM+FSA in dom SA0 by TARSKI:def 1;
A14: IC s = SA0.IC SCM+FSA by A13,A11,GRFUNC_1:2
      .=  0 by FUNCOP_1:72;
  0 in dom Ma by COMPOS_1:60;
    then
A15: Ma. 0 = P.0 by A12,GRFUNC_1:2;
A16:  (P)/.IC s
 = P.IC s by PBOOLE:143;
A17: Comput(P,s,0+1) = Following(P,
Comput(P,s,0)) by EXTPRO_1:3
      .= Following(P,s) by EXTPRO_1:2
      .= Exec(AddTo(a,b), s) by A14,A15,A16,COMPOS_1:58;
   1 in dom Ma by COMPOS_1:60;
    then Ma. 1 = P.1 by A12,GRFUNC_1:2;
    then
A18: P.1 = halt SCM+FSA by COMPOS_1:59;
    IC Exec(AddTo(a,b), s) = succ  0 by A14,SCMFSA_2:64
      .=  (0+1);
    then
A19: CurInstr(P,Comput(P,s,1)
)
 = halt SCM+FSA by A18,A17,PBOOLE:143;
    per cases by NAT_1:14;
    suppose
      k = 0;
      hence thesis by EXTPRO_1:2;
    end;
    suppose
A20:  1 <= k;
      Comput(P,s,1).intloc 0 = s.intloc 0 by A17,SCMFSA_2:64;
      hence thesis by A19,A20,EXTPRO_1:5;
    end;
  end;
  cluster SubFrom(a, b) -> keeping_0;
  coherence
  proof
    set Ma = Macro (SubFrom(a,b));
    let s be 0-started  State of SCM+FSA;
A21: Start-At(0,SCM+FSA) c= s by MEMSTR_0:29;
    let P be Instruction-Sequence of SCM+FSA;
    assume
A22: Ma c= P;
    let k be Element of NAT;
    dom SA0 = {IC SCM+FSA} by FUNCOP_1:13;
    then
A23: IC SCM+FSA in dom SA0 by TARSKI:def 1;
A24: IC s = SA0.IC SCM+FSA by A23,A21,GRFUNC_1:2
      .=  0 by FUNCOP_1:72;
  0 in dom Ma by COMPOS_1:60;
    then
A25: Ma. 0 = P.0 by A22,GRFUNC_1:2;
A26:  (P)/.IC s
 = P.IC s by PBOOLE:143;
A27: Comput(P,s,0+1) = Following(P,
Comput(P,s,0)) by EXTPRO_1:3
      .= Following(P,s) by EXTPRO_1:2
      .= Exec(SubFrom(a,b), s) by A24,A25,A26,COMPOS_1:58;
   1 in dom Ma by COMPOS_1:60;
    then Ma. 1 = P.1 by A22,GRFUNC_1:2;
    then
A28: P.1 = halt SCM+FSA by COMPOS_1:59;
    IC Exec(SubFrom(a,b), s) = succ  0 by A24,SCMFSA_2:65
      .=  (0+1);
    then
A29: CurInstr(P,Comput(P,s,1)
)
 = halt SCM+FSA by A28,A27,PBOOLE:143;
    per cases by NAT_1:14;
    suppose
      k = 0;
      hence thesis by EXTPRO_1:2;
    end;
    suppose
A30:  1 <= k;
      Comput(P,s,1).intloc 0 = s.intloc 0 by A27,SCMFSA_2:65;
      hence thesis by A29,A30,EXTPRO_1:5;
    end;
  end;
  cluster MultBy(a, b) -> keeping_0;
  coherence
  proof
    set Ma = Macro (MultBy(a,b));
    let s be 0-started  State of SCM+FSA;
A31: Start-At(0,SCM+FSA) c= s by MEMSTR_0:29;
    let P be Instruction-Sequence of SCM+FSA;
    assume
A32: Ma c= P;
    let k be Element of NAT;
    dom SA0 = {IC SCM+FSA} by FUNCOP_1:13;
    then
A33: IC SCM+FSA in dom SA0 by TARSKI:def 1;
A34: IC s = SA0.IC SCM+FSA by A33,A31,GRFUNC_1:2
      .=  0 by FUNCOP_1:72;
  0 in dom Ma by COMPOS_1:60;
    then
A35: Ma. 0 = P.0 by A32,GRFUNC_1:2;
A36:  (P)/.IC s
 = P.IC s by PBOOLE:143;
A37: Comput(P,s,0+1) = Following(P,
Comput(P,s,0)) by EXTPRO_1:3
      .= Following(P,s) by EXTPRO_1:2
      .= Exec(MultBy(a,b), s) by A34,A35,A36,COMPOS_1:58;
   1 in dom Ma by COMPOS_1:60;
    then Ma. 1 = P.1 by A32,GRFUNC_1:2;
    then
A38: P.1 = halt SCM+FSA by COMPOS_1:59;
    IC Exec(MultBy(a,b), s) = succ  0 by A34,SCMFSA_2:66
      .=  (0+1);
    then
A39: CurInstr(P,Comput(P,s,1)
)
 = halt SCM+FSA by A38,A37,PBOOLE:143;
    per cases by NAT_1:14;
    suppose
      k = 0;
      hence thesis by EXTPRO_1:2;
    end;
    suppose
A40:  1 <= k;
      Comput(P,s,1).intloc 0 = s.intloc 0 by A37,SCMFSA_2:66;
      hence thesis by A39,A40,EXTPRO_1:5;
    end;
  end;
end;

registration
  let a, b be read-write Int-Location;
  cluster Divide(a, b) -> keeping_0;
  coherence
  proof
    set Ma = Macro (Divide(a,b));
    let s be 0-started  State of SCM+FSA;
A1: Start-At(0,SCM+FSA) c= s by MEMSTR_0:29;
    let P be Instruction-Sequence of SCM+FSA;
    assume
A2: Ma c= P;
    let k be Element of NAT;
    dom SA0 = {IC SCM+FSA} by FUNCOP_1:13;
    then
A3: IC SCM+FSA in dom SA0 by TARSKI:def 1;
A4: IC s = SA0.IC SCM+FSA by A3,A1,GRFUNC_1:2
      .=  0 by FUNCOP_1:72;
  0 in dom Ma by COMPOS_1:60;
    then
A5: Ma. 0 = P.0 by A2,GRFUNC_1:2;
A6:  (P)/.IC s
 = P.IC s by PBOOLE:143;
A7: Comput(P,s,0+1) = Following(P,
Comput(P,s,0)) by EXTPRO_1:3
      .= Following(P,s) by EXTPRO_1:2
      .= Exec(Divide(a,b), s) by A4,A5,A6,COMPOS_1:58;
   1 in dom Ma by COMPOS_1:60;
    then Ma. 1 = P.1 by A2,GRFUNC_1:2;
    then
A8: P.1 = halt SCM+FSA by COMPOS_1:59;
    IC Exec(Divide(a,b), s) = succ  0 by A4,SCMFSA_2:67
      .= 0+1;
    then
A9: CurInstr(P,Comput(P,s,1))
 = halt SCM+FSA by A8,A7,PBOOLE:143;
    per cases by NAT_1:14;
    suppose
      k = 0;
      hence thesis by EXTPRO_1:2;
    end;
    suppose
A10:   1 <= k;
      Comput(P,s,1).intloc 0 = s.intloc 0 by A7,SCMFSA_2:67;
      hence thesis by A9,A10,EXTPRO_1:5;
    end;
  end;
end;

registration
  let a be Int-Location, f be FinSeq-Location, b be read-write Int-Location;
  cluster b := (f,a) -> keeping_0;
  coherence
  proof
    set Ma = Macro (b:=(f,a));
    let s be 0-started  State of SCM+FSA;
A1: Start-At(0,SCM+FSA) c= s by MEMSTR_0:29;
    let P be Instruction-Sequence of SCM+FSA;
    assume
A2: Ma c= P;
    let k be Element of NAT;
    dom SA0 = {IC SCM+FSA} by FUNCOP_1:13;
    then
A3: IC SCM+FSA in dom SA0 by TARSKI:def 1;
A4: IC s = SA0.IC SCM+FSA by A3,A1,GRFUNC_1:2
      .=  0 by FUNCOP_1:72;
  0 in dom Ma by COMPOS_1:60;
    then
A5: Ma. 0 = P.0 by A2,GRFUNC_1:2;
A6:  (P)/.IC s
 = P.IC s by PBOOLE:143;
A7: Comput(P,s,0+1) = Following(P,
Comput(P,s,0)) by EXTPRO_1:3
      .= Following(P,s) by EXTPRO_1:2
      .= Exec(b:=(f,a), s) by A4,A5,A6,COMPOS_1:58;
   1 in dom Ma by COMPOS_1:60;
    then Ma. 1 = P.1 by A2,GRFUNC_1:2;
    then
A8: P.1 = halt SCM+FSA by COMPOS_1:59;
    IC Exec(b:=(f,a), s) = succ  0 by A4,SCMFSA_2:72
      .=  (0+1);
    then
A9: CurInstr(P,Comput(P,s,1))
 = halt SCM+FSA by A8,A7,PBOOLE:143;
    per cases by NAT_1:14;
    suppose
      k = 0;
      hence thesis by EXTPRO_1:2;
    end;
    suppose
A10:   1 <= k;
      Comput(P,s,1).intloc 0 = s.intloc 0 by A7,SCMFSA_2:72;
      hence thesis by A9,A10,EXTPRO_1:5;
    end;
  end;
end;

registration
  let f be FinSeq-Location, b be read-write Int-Location;
  cluster b :=len f -> keeping_0;
  coherence
  proof
    set Ma = Macro (b:=len f);
    let s be 0-started State of SCM+FSA;
A1: Start-At(0,SCM+FSA) c= s by MEMSTR_0:29;
    let P be Instruction-Sequence of SCM+FSA;
    assume
A2: Ma c= P;
    let k be Element of NAT;
    dom SA0 = {IC SCM+FSA} by FUNCOP_1:13;
    then
A3: IC SCM+FSA in dom SA0 by TARSKI:def 1;
A4: IC s = SA0.IC SCM+FSA by A3,A1,GRFUNC_1:2
      .=  0 by FUNCOP_1:72;
  0 in dom Ma by COMPOS_1:60;
    then
A5: Ma. 0 = P.0 by A2,GRFUNC_1:2;
A6:  (P)/.IC s
 = P.IC s by PBOOLE:143;
A7: Comput(P,s,0+1) =
Following(P,Comput(P,s,0))
 by EXTPRO_1:3
      .= Following(P,s) by EXTPRO_1:2
      .= Exec(b:=len f, s) by A4,A5,A6,COMPOS_1:58;
   1 in dom Ma by COMPOS_1:60;
    then Ma. 1 = P.1 by A2,GRFUNC_1:2;
    then
A8: P.1 = halt SCM+FSA by COMPOS_1:59;
    IC Exec(b:=len f, s) = succ  0 by A4,SCMFSA_2:74
      .=  (0+1);
    then
A9: CurInstr(P,Comput(P,s,1))
 = halt SCM+FSA by A8,A7,PBOOLE:143;
    per cases by NAT_1:14;
    suppose
      k = 0;
      hence thesis by EXTPRO_1:2;
    end;
    suppose
A10:   1 <= k;
      Comput(P,s,1).intloc 0 = s.intloc 0 by A7,SCMFSA_2:74;
      hence thesis by A9,A10,EXTPRO_1:5;
    end;
  end;
end;

registration
  let i be parahalting Instruction of SCM+FSA, J be parahalting Program of
  SCM+FSA;
  cluster i ';' J -> parahalting;
  coherence;
end;

registration
  let I be parahalting Program of SCM+FSA, j be parahalting Instruction of
  SCM+FSA;
  cluster I ';' j -> parahalting;
  coherence;
end;

registration
  let i be parahalting Instruction of SCM+FSA, j be parahalting Instruction of
  SCM+FSA;
  cluster i ';' j -> parahalting;
  coherence;
end;

registration
  let i be keeping_0 Instruction of SCM+FSA, J be keeping_0 Program of SCM+FSA;
  cluster i ';' J -> keeping_0;
  coherence;
end;

registration
  let I be keeping_0 Program of SCM+FSA, j be keeping_0 Instruction of SCM+FSA;
  cluster I ';' j -> keeping_0;
  coherence;
end;

registration
  let i, j be keeping_0 Instruction of SCM+FSA;
  cluster i ';' j -> keeping_0;
  coherence;
end;

begin :: Consequenses of the main theorem

theorem Th3:
  (for a being read-write Int-Location holds (Initialized s).a = s.a) &
  (for f holds (Initialized s).f = s.f)
proof
A3: Initialized s = Initialize(s +* ((intloc 0) .--> 1)) by FUNCT_4:14;
A4: dom ((intloc 0) .--> 1) = {intloc 0} by FUNCOP_1:13;
  hereby
    let a be read-write Int-Location;
A6: not a in dom ((intloc 0) .--> 1) by A4,TARSKI:def 1;
    not a in dom SA0 by SCMFSA_2:102;
    hence (Initialized s).a = (s+*((intloc 0) .--> 1)).a by A3,FUNCT_4:11
      .= s.a by A6,FUNCT_4:11;
  end;
  hereby
    let f be FinSeq-Location;
    intloc 0 <> f by SCMFSA_2:58;
    then
A7: not f in dom ((intloc 0) .--> 1) by A4,TARSKI:def 1;
    not f in dom SA0 by SCMFSA_2:103;
    hence (Initialized s).f = (s+*((intloc 0) .--> 1)).f by A3,FUNCT_4:11
      .= s.f by A7,FUNCT_4:11;
  end;
end;



theorem Th5:
  DataPart s1 = DataPart s2 implies DataPart Exec (i, s1) =
  DataPart Exec (i, s2)
proof
  assume
A1: DataPart s1 = DataPart s2;
  set l = i;
A5: dom Exec(l,s1) = the carrier of SCM+FSA by PARTFUN1:def 2;
  then
A6: dom Exec(l,s1) = dom Exec(l,s2) by PARTFUN1:def 2;
A7: dom ((Exec (l,s1)) | (Data-Locations SCM+FSA)) = (
  Data-Locations SCM+FSA) by A5,RELAT_1:62;
A8: dom Exec(l,s2) = the carrier of SCM+FSA by PARTFUN1:def 2;
  then
A9: dom ((Exec (l,s2)) | (Data-Locations SCM+FSA)) = (
  Data-Locations SCM+FSA) by RELAT_1:62;
  per cases by NAT_1:36,SCMFSA_2:16;
  suppose
    InsCode i = 0;
    then
A10: i = halt SCM+FSA by SCMFSA_2:95;
    then Exec (i,s1) = s1 by EXTPRO_1:def 3;
    hence thesis by A1,A10,EXTPRO_1:def 3;
  end;
  suppose
    InsCode i = 1;
    then consider db,da being Int-Location such that
A11: l = db := da by SCMFSA_2:30;
A12: for x being set st x in ((Data-Locations SCM+FSA) \ {db})
holds (Exec (l,s1) | (Data-Locations SCM+FSA \ {db})).x = (Exec (l,
    s2) | (Data-Locations SCM+FSA \ {db})).x
    proof
      let x be set;
      assume
A13:  x in ((Data-Locations SCM+FSA) \ {db});
      then
A14:  x in Data-Locations SCM+FSA by XBOOLE_0:def 5;
A15:  not x in {db} by A13,XBOOLE_0:def 5;
      per cases by A14,SCMFSA_2:100,XBOOLE_0:def 3;
      suppose
        x in Int-Locations;
        then reconsider a = x as Int-Location by SCMFSA_2:4;
A16:    a <> db by A15,TARSKI:def 1;
        thus (Exec (l,s1) | (Data-Locations SCM+FSA \ {db})).x = (
        Exec (l,s1)).a by A13,FUNCT_1:49
          .= s1.a by A11,A16,SCMFSA_2:63
          .= (DataPart s1).a by A14,FUNCT_1:49
          .= s2.a by A1,A14,FUNCT_1:49
          .= (Exec (l,s2)).a by A11,A16,SCMFSA_2:63
          .= (Exec (l,s2) | (Data-Locations SCM+FSA \ {db})).x by A13,
FUNCT_1:49;
      end;
      suppose
        x in FinSeq-Locations;
        then reconsider a = x as FinSeq-Location by SCMFSA_2:5;
        thus (Exec (l,s1) | (Data-Locations SCM+FSA \ {db})).x = (
        Exec (l,s1)).a by A13,FUNCT_1:49
          .= s1.a by A11,SCMFSA_2:63
          .= (DataPart s1).a by A14,FUNCT_1:49
          .= s2.a by A1,A14,FUNCT_1:49
          .= (Exec (l,s2)).a by A11,SCMFSA_2:63
          .= (Exec (l,s2) | (Data-Locations SCM+FSA \ {db})).x by A13,
FUNCT_1:49;
      end;
    end;
A17: dom ((Exec (l,s2)) | (Data-Locations SCM+FSA \ {db})) = (
    Data-Locations SCM+FSA \ {db}) by A8,RELAT_1:62;
    dom ((Exec (l,s1)) | (Data-Locations SCM+FSA \ {db})) = (
    Data-Locations SCM+FSA \ {db}) by A5,RELAT_1:62;
    then
A18: Exec (l,s1) | (Data-Locations SCM+FSA \ {db} ) = Exec (l,
    s2) | (Data-Locations SCM+FSA \ {db} ) by A17,A12,FUNCT_1:2;
    db in Int-Locations by SCMFSA_2:2;
    then db in Data-Locations SCM+FSA by SCMFSA_2:100,XBOOLE_0:def 3;
    then
A19: Data-Locations SCM+FSA = Data-Locations SCM+FSA
    \/ {db} by ZFMISC_1:40
      .= (Data-Locations SCM+FSA \ {db} ) \/ {db} by XBOOLE_1:39;
A20: Exec(l, s2).db = s2.da by A11,SCMFSA_2:63;
A21: Exec(l, s1).db = s1.da by A11,SCMFSA_2:63;
    da in Int-Locations by SCMFSA_2:2;
    then
A22: da in Data-Locations SCM+FSA by SCMFSA_2:100,XBOOLE_0:def 3;
    then s1.da = (DataPart s1).da by FUNCT_1:49
      .= s2.da by A1,A22,FUNCT_1:49;
    then Exec (l,s1) | {db} = Exec(l,s2) | {db} by A6,A21,A20,GRFUNC_1:29;
    hence thesis by A19,A18,RELAT_1:150;
  end;
  suppose
    InsCode i = 2;
    then consider db,da being Int-Location such that
A23: l = AddTo(db,da) by SCMFSA_2:31;
A24: for x being set st x in ((Data-Locations SCM+FSA) \ {db})
holds (Exec (l,s1) | (Data-Locations SCM+FSA \ {db})).x = (Exec (l,
    s2) | (Data-Locations SCM+FSA \ {db})).x
    proof
      let x be set;
      assume
A25:  x in ((Data-Locations SCM+FSA) \ {db});
      then
A26:  x in Data-Locations SCM+FSA by XBOOLE_0:def 5;
A27:  not x in {db} by A25,XBOOLE_0:def 5;
      per cases by A26,SCMFSA_2:100,XBOOLE_0:def 3;
      suppose
        x in Int-Locations;
        then reconsider a = x as Int-Location by SCMFSA_2:4;
A28:    a <> db by A27,TARSKI:def 1;
        thus (Exec (l,s1) | (Data-Locations SCM+FSA \ {db})).x = (
        Exec (l,s1)).a by A25,FUNCT_1:49
          .= s1.a by A23,A28,SCMFSA_2:64
          .= (DataPart s1).a by A26,FUNCT_1:49
          .= s2.a by A1,A26,FUNCT_1:49
          .= (Exec (l,s2)).a by A23,A28,SCMFSA_2:64
          .= (Exec (l,s2) | (Data-Locations SCM+FSA \ {db})).x by A25,
FUNCT_1:49;
      end;
      suppose
        x in FinSeq-Locations;
        then reconsider a = x as FinSeq-Location by SCMFSA_2:5;
        thus (Exec (l,s1) | (Data-Locations SCM+FSA \ {db})).x = (
        Exec (l,s1)).a by A25,FUNCT_1:49
          .= s1.a by A23,SCMFSA_2:64
          .= (DataPart s1).a by A26,FUNCT_1:49
          .= s2.a by A1,A26,FUNCT_1:49
          .= (Exec (l,s2)).a by A23,SCMFSA_2:64
          .= (Exec (l,s2) | (Data-Locations SCM+FSA \ {db})).x by A25,
FUNCT_1:49;
      end;
    end;
A29: dom ((Exec (l,s2)) | (Data-Locations SCM+FSA \ {db})) = (
    Data-Locations SCM+FSA \ {db}) by A8,RELAT_1:62;
    dom ((Exec (l,s1)) | (Data-Locations SCM+FSA \ {db})) = (
    Data-Locations SCM+FSA \ {db}) by A5,RELAT_1:62;
    then
A30: Exec (l,s1) | (Data-Locations SCM+FSA \ {db} ) = Exec (l,
    s2) | (Data-Locations SCM+FSA \ {db} ) by A29,A24,FUNCT_1:2;
    db in Int-Locations by SCMFSA_2:2;
    then db in Data-Locations SCM+FSA by SCMFSA_2:100,XBOOLE_0:def 3;
    then
A31: Data-Locations SCM+FSA = Data-Locations SCM+FSA
    \/ {db} by ZFMISC_1:40
      .= (Data-Locations SCM+FSA \ {db} ) \/ {db} by XBOOLE_1:39;
A32: Exec(l, s2).db = s2.db + s2.da by A23,SCMFSA_2:64;
A33: Exec(l, s1).db = s1.db + s1.da by A23,SCMFSA_2:64;
    db in Int-Locations by SCMFSA_2:2;
    then
A34: db in Data-Locations SCM+FSA by SCMFSA_2:100,XBOOLE_0:def 3;
    then
A35: s1.db = (DataPart s1).db by FUNCT_1:49
      .= s2.db by A1,A34,FUNCT_1:49;
    da in Int-Locations by SCMFSA_2:2;
    then
A36: da in Data-Locations SCM+FSA by SCMFSA_2:100,XBOOLE_0:def 3;
    then s1.da = (DataPart s1).da by FUNCT_1:49
      .= s2.da by A1,A36,FUNCT_1:49;
    then Exec (l,s1) | {db} = Exec(l,s2) | {db} by A6,A33,A32,A35,GRFUNC_1:29;
    hence thesis by A31,A30,RELAT_1:150;
  end;
  suppose
    InsCode i = 3;
    then consider db,da being Int-Location such that
A37: l = SubFrom(db,da) by SCMFSA_2:32;
A38: for x being set st x in ((Data-Locations SCM+FSA) \ {db})
holds (Exec (l,s1) | (Data-Locations SCM+FSA \ {db})).x = (Exec (l,
    s2) | (Data-Locations SCM+FSA \ {db})).x
    proof
      let x be set;
      assume
A39:  x in ((Data-Locations SCM+FSA) \ {db});
      then
A40:  x in Data-Locations SCM+FSA by XBOOLE_0:def 5;
A41:  not x in {db} by A39,XBOOLE_0:def 5;
      per cases by A40,SCMFSA_2:100,XBOOLE_0:def 3;
      suppose
        x in Int-Locations;
        then reconsider a = x as Int-Location by SCMFSA_2:4;
A42:    a <> db by A41,TARSKI:def 1;
        thus (Exec (l,s1) | (Data-Locations SCM+FSA \ {db})).x = (
        Exec (l,s1)).a by A39,FUNCT_1:49
          .= s1.a by A37,A42,SCMFSA_2:65
          .= (DataPart s1).a by A40,FUNCT_1:49
          .= s2.a by A1,A40,FUNCT_1:49
          .= (Exec (l,s2)).a by A37,A42,SCMFSA_2:65
          .= (Exec (l,s2) | (Data-Locations SCM+FSA \ {db})).x by A39,
FUNCT_1:49;
      end;
      suppose
        x in FinSeq-Locations;
        then reconsider a = x as FinSeq-Location by SCMFSA_2:5;
        thus (Exec (l,s1) | (Data-Locations SCM+FSA \ {db})).x = (
        Exec (l,s1)).a by A39,FUNCT_1:49
          .= s1.a by A37,SCMFSA_2:65
          .= (DataPart s1).a by A40,FUNCT_1:49
          .= s2.a by A1,A40,FUNCT_1:49
          .= (Exec (l,s2)).a by A37,SCMFSA_2:65
          .= (Exec (l,s2) | (Data-Locations SCM+FSA \ {db})).x by A39,
FUNCT_1:49;
      end;
    end;
A43: dom ((Exec (l,s2)) | (Data-Locations SCM+FSA \ {db})) = (
    Data-Locations SCM+FSA \ {db}) by A8,RELAT_1:62;
    dom ((Exec (l,s1)) | (Data-Locations SCM+FSA \ {db})) = (
    Data-Locations SCM+FSA \ {db}) by A5,RELAT_1:62;
    then
A44: Exec (l,s1) | (Data-Locations SCM+FSA \ {db} ) = Exec (l,
    s2) | (Data-Locations SCM+FSA \ {db} ) by A43,A38,FUNCT_1:2;
    db in Int-Locations by SCMFSA_2:2;
    then db in Data-Locations SCM+FSA by SCMFSA_2:100,XBOOLE_0:def 3;
    then
A45: Data-Locations SCM+FSA = Data-Locations SCM+FSA
    \/ {db} by ZFMISC_1:40
      .= (Data-Locations SCM+FSA \ {db} ) \/ {db} by XBOOLE_1:39;
A46: Exec(l, s2).db = s2.db - s2.da by A37,SCMFSA_2:65;
A47: Exec(l, s1).db = s1.db - s1.da by A37,SCMFSA_2:65;
    db in Int-Locations by SCMFSA_2:2;
    then
A48: db in Data-Locations SCM+FSA by SCMFSA_2:100,XBOOLE_0:def 3;
    then
A49: s1.db = (DataPart s1).db by FUNCT_1:49
      .= s2.db by A1,A48,FUNCT_1:49;
    da in Int-Locations by SCMFSA_2:2;
    then
A50: da in Data-Locations SCM+FSA by SCMFSA_2:100,XBOOLE_0:def 3;
    then s1.da = (DataPart s1).da by FUNCT_1:49
      .= s2.da by A1,A50,FUNCT_1:49;
    then Exec (l,s1) | {db} = Exec(l,s2) | {db} by A6,A47,A46,A49,GRFUNC_1:29;
    hence thesis by A45,A44,RELAT_1:150;
  end;
  suppose
    InsCode i = 4;
    then consider db,da being Int-Location such that
A51: l = MultBy(db,da) by SCMFSA_2:33;
A52: for x being set st x in ((Data-Locations SCM+FSA) \ {db})
holds (Exec (l,s1) | (Data-Locations SCM+FSA \ {db})).x = (Exec (l,
    s2) | (Data-Locations SCM+FSA \ {db})).x
    proof
      let x be set;
      assume
A53:  x in ((Data-Locations SCM+FSA) \ {db});
      then
A54:  x in Data-Locations SCM+FSA by XBOOLE_0:def 5;
A55:  not x in {db} by A53,XBOOLE_0:def 5;
      per cases by A54,SCMFSA_2:100,XBOOLE_0:def 3;
      suppose
        x in Int-Locations;
        then reconsider a = x as Int-Location by SCMFSA_2:4;
A56:    a <> db by A55,TARSKI:def 1;
        thus (Exec (l,s1) | (Data-Locations SCM+FSA \ {db})).x = (
        Exec (l,s1)).a by A53,FUNCT_1:49
          .= s1.a by A51,A56,SCMFSA_2:66
          .= (DataPart s1).a by A54,FUNCT_1:49
          .= s2.a by A1,A54,FUNCT_1:49
          .= (Exec (l,s2)).a by A51,A56,SCMFSA_2:66
          .= (Exec (l,s2) | (Data-Locations SCM+FSA \ {db})).x by A53,
FUNCT_1:49;
      end;
      suppose
        x in FinSeq-Locations;
        then reconsider a = x as FinSeq-Location by SCMFSA_2:5;
        thus (Exec (l,s1) | (Data-Locations SCM+FSA \ {db})).x = (
        Exec (l,s1)).a by A53,FUNCT_1:49
          .= s1.a by A51,SCMFSA_2:66
          .= (DataPart s1).a by A54,FUNCT_1:49
          .= s2.a by A1,A54,FUNCT_1:49
          .= (Exec (l,s2)).a by A51,SCMFSA_2:66
          .= (Exec (l,s2) | (Data-Locations SCM+FSA \ {db})).x by A53,
FUNCT_1:49;
      end;
    end;
A57: dom ((Exec (l,s2)) | (Data-Locations SCM+FSA \ {db})) = (
    Data-Locations SCM+FSA \ {db}) by A8,RELAT_1:62;
    dom ((Exec (l,s1)) | (Data-Locations SCM+FSA \ {db})) = (
    Data-Locations SCM+FSA \ {db}) by A5,RELAT_1:62;
    then
A58: Exec (l,s1) | (Data-Locations SCM+FSA \ {db} ) = Exec (l,
    s2) | (Data-Locations SCM+FSA \ {db} ) by A57,A52,FUNCT_1:2;
    db in Int-Locations by SCMFSA_2:2;
    then db in Data-Locations SCM+FSA by SCMFSA_2:100,XBOOLE_0:def 3;
    then
A59: Data-Locations SCM+FSA = Data-Locations SCM+FSA
    \/ {db} by ZFMISC_1:40
      .= (Data-Locations SCM+FSA \ {db} ) \/ {db} by XBOOLE_1:39;
A60: Exec(l, s2).db = s2.db * s2.da by A51,SCMFSA_2:66;
A61: Exec(l, s1).db = s1.db * s1.da by A51,SCMFSA_2:66;
    db in Int-Locations by SCMFSA_2:2;
    then
A62: db in Data-Locations SCM+FSA by SCMFSA_2:100,XBOOLE_0:def 3;
    then
A63: s1.db = (DataPart s1).db by FUNCT_1:49
      .= s2.db by A1,A62,FUNCT_1:49;
    da in Int-Locations by SCMFSA_2:2;
    then
A64: da in Data-Locations SCM+FSA by SCMFSA_2:100,XBOOLE_0:def 3;
    then s1.da = (DataPart s1).da by FUNCT_1:49
      .= s2.da by A1,A64,FUNCT_1:49;
    then Exec (l,s1) | {db} = Exec(l,s2) | {db} by A6,A61,A60,A63,GRFUNC_1:29;
    hence thesis by A59,A58,RELAT_1:150;
  end;
  suppose
    InsCode i = 5;
    then consider db,da being Int-Location such that
A65: l = Divide(db,da) by SCMFSA_2:34;
    hereby
      per cases;
      suppose
A66:    da <> db;
A67:    for x being set st x in ((Data-Locations SCM+FSA) \ {
db,da} ) holds (Exec (l,s1) | (Data-Locations SCM+FSA \ {db,da})).x
        = (Exec (l,s2) | (Data-Locations SCM+FSA \ {db,da})).x
        proof
          let x be set;
          assume
A68:      x in ((Data-Locations SCM+FSA) \ {db,da});
          then
A69:      x in Data-Locations SCM+FSA by XBOOLE_0:def 5;
A70:      not x in {db,da} by A68,XBOOLE_0:def 5;
          per cases by A69,SCMFSA_2:100,XBOOLE_0:def 3;
          suppose
            x in Int-Locations;
            then reconsider a = x as Int-Location by SCMFSA_2:4;
A71:        a <> da by A70,TARSKI:def 2;
A72:        a <> db by A70,TARSKI:def 2;
            thus (Exec (l,s1) | (Data-Locations SCM+FSA \ {db,da}))
            .x = (Exec (l,s1)).a by A68,FUNCT_1:49
              .= s1.a by A65,A71,A72,SCMFSA_2:67
              .= (DataPart s1).a by A69,FUNCT_1:49
              .= s2.a by A1,A69,FUNCT_1:49
              .= (Exec (l,s2)).a by A65,A71,A72,SCMFSA_2:67
              .= (Exec (l,s2) | (Data-Locations SCM+FSA \ {db,da}
            )).x by A68,FUNCT_1:49;
          end;
          suppose
            x in FinSeq-Locations;
            then reconsider a = x as FinSeq-Location by SCMFSA_2:5;
            thus (Exec (l,s1) | (Data-Locations SCM+FSA \ {db,da}))
            .x = (Exec (l,s1)).a by A68,FUNCT_1:49
              .= s1.a by A65,SCMFSA_2:67
              .= (DataPart s1).a by A69,FUNCT_1:49
              .= s2.a by A1,A69,FUNCT_1:49
              .= (Exec (l,s2)).a by A65,SCMFSA_2:67
              .= (Exec (l,s2) | (Data-Locations SCM+FSA \ {db,da}
            )).x by A68,FUNCT_1:49;
          end;
        end;
A73:    dom ((Exec (l,s2)) | (Data-Locations SCM+FSA \ {db,da
        })) = (Data-Locations SCM+FSA \ {db,da}) by A8,RELAT_1:62;
        dom ((Exec (l,s1)) | (Data-Locations SCM+FSA \ {db,da
        })) = (Data-Locations SCM+FSA \ {db,da}) by A5,RELAT_1:62;
        then
A74:    Exec (l,s1) | (Data-Locations SCM+FSA \ {db,da} ) =
Exec (l,s2) | (Data-Locations SCM+FSA \ {db,da} ) by A73,A67,FUNCT_1:2;
A75:    Exec(l, s2).da = s2.db mod s2.da by A65,SCMFSA_2:67;
        db in Int-Locations by SCMFSA_2:2;
        then
A76:    db in Data-Locations SCM+FSA by SCMFSA_2:100,XBOOLE_0:def 3;
        then
A77:    s1.db = (DataPart s1).db by FUNCT_1:49
          .= s2.db by A1,A76,FUNCT_1:49;
        da in Int-Locations by SCMFSA_2:2;
        then
A78:    da in Data-Locations SCM+FSA by SCMFSA_2:100,XBOOLE_0:def 3;
        db in Int-Locations by SCMFSA_2:2;
        then db in Data-Locations SCM+FSA by SCMFSA_2:100,XBOOLE_0:def 3;
        then
A79:    Data-Locations SCM+FSA
          = Data-Locations SCM+FSA \/ {db,da} by A78,ZFMISC_1:42
          .= (Data-Locations SCM+FSA \ {db,da} ) \/ {db,da} by XBOOLE_1:39;
A80:    Exec(l, s1).da = s1.db mod s1.da by A65,SCMFSA_2:67;
A81:    Exec(l, s2).db = s2.db div s2.da by A65,A66,SCMFSA_2:67;
A82:    Exec(l, s1).db = s1.db div s1.da by A65,A66,SCMFSA_2:67;
        da in Int-Locations by SCMFSA_2:2;
        then
A83:    da in Data-Locations SCM+FSA by SCMFSA_2:100,XBOOLE_0:def 3;
        then s1.da = (DataPart s1).da by FUNCT_1:49
          .= s2.da by A1,A83,FUNCT_1:49;
        then Exec (l,s1) | {db,da} = Exec(l,s2) | {db,da} by A6,A82,A80,A81,A75
,A77,GRFUNC_1:30;
        hence thesis by A79,A74,RELAT_1:150;
      end;
      suppose
A84:    da = db;
A85:    for x being set st x in ((Data-Locations SCM+FSA) \ {
db}) holds (Exec (l,s1) | (Data-Locations SCM+FSA \ {db})).x = (Exec
        (l,s2) | (Data-Locations SCM+FSA \ {db})).x
        proof
          let x be set;
          assume
A86:      x in ((Data-Locations SCM+FSA) \ {db});
          then
A87:      x in Data-Locations SCM+FSA by XBOOLE_0:def 5;
A88:      not x in {db} by A86,XBOOLE_0:def 5;
          per cases by A87,SCMFSA_2:100,XBOOLE_0:def 3;
          suppose
            x in Int-Locations;
            then reconsider a = x as Int-Location by SCMFSA_2:4;
A89:        a <> db by A88,TARSKI:def 1;
            thus (Exec (l,s1) | (Data-Locations SCM+FSA \ {db})).x
            = (Exec (l,s1)).a by A86,FUNCT_1:49
              .= s1.a by A65,A84,A89,SCMFSA_2:68
              .= (DataPart s1).a by A87,FUNCT_1:49
              .= s2.a by A1,A87,FUNCT_1:49
              .= (Exec (l,s2)).a by A65,A84,A89,SCMFSA_2:68
              .= (Exec (l,s2) | (Data-Locations SCM+FSA \ {db})).
            x by A86,FUNCT_1:49;
          end;
          suppose
            x in FinSeq-Locations;
            then reconsider a = x as FinSeq-Location by SCMFSA_2:5;
            thus (Exec (l,s1) | (Data-Locations SCM+FSA \ {db})).x
            = (Exec (l,s1)).a by A86,FUNCT_1:49
              .= s1.a by A65,A84,SCMFSA_2:68
              .= (s1 | (Data-Locations SCM+FSA)).a by A87,FUNCT_1:49
              .= s2.a by A1,A87,FUNCT_1:49
              .= (Exec (l,s2)).a by A65,A84,SCMFSA_2:68
              .= (Exec (l,s2) | (Data-Locations SCM+FSA \ {db})).
            x by A86,FUNCT_1:49;
          end;
        end;
A90:    dom ((Exec (l,s2)) | (Data-Locations SCM+FSA \ {db}))
        = (Data-Locations SCM+FSA \ {db}) by A8,RELAT_1:62;
        dom ((Exec (l,s1)) | (Data-Locations SCM+FSA \ {db}))
        = (Data-Locations SCM+FSA \ {db}) by A5,RELAT_1:62;
        then
A91:    Exec (l,s1) | (Data-Locations SCM+FSA \ {db} ) = Exec
(l,s2) | (Data-Locations SCM+FSA \ {db} ) by A90,A85,FUNCT_1:2;
        db in Int-Locations by SCMFSA_2:2;
        then db in Data-Locations SCM+FSA by SCMFSA_2:100,XBOOLE_0:def 3;
        then
A92:    Data-Locations SCM+FSA = Data-Locations SCM+FSA \/ {db} by ZFMISC_1:40
          .= (Data-Locations SCM+FSA \ {db} ) \/ {db} by XBOOLE_1:39
;
A93:    Exec(l, s2).db = s2.db mod s2.da by A65,A84,SCMFSA_2:68;
A94:    Exec(l, s1).db = s1.db mod s1.da by A65,A84,SCMFSA_2:68;
        db in Int-Locations by SCMFSA_2:2;
        then
A95:    db in Data-Locations SCM+FSA by SCMFSA_2:100,XBOOLE_0:def 3;
        then
A96:    s1.db = (DataPart s1).db by FUNCT_1:49
          .= s2.db by A1,A95,FUNCT_1:49;
        da in Int-Locations by SCMFSA_2:2;
        then
A97:    da in Data-Locations SCM+FSA by SCMFSA_2:100,XBOOLE_0:def 3;
        then s1.da = (DataPart s1).da by FUNCT_1:49
          .= s2.da by A1,A97,FUNCT_1:49;
        then Exec (l,s1) | {db} = Exec(l,s2) | {db} by A6,A94,A93,A96,
GRFUNC_1:29;
        hence thesis by A92,A91,RELAT_1:150;
      end;
    end;
  end;
  suppose
    InsCode i = 6;
    then
A98: ex l1 st i = goto l1 by SCMFSA_2:35;
    for x being set st x in ((Data-Locations SCM+FSA)) holds
    (DataPart Exec (l,s1)).x = (DataPart Exec (l,s2)).x
    proof
      let x be set;
      assume
A99:  x in ((Data-Locations SCM+FSA));
      per cases by A99,SCMFSA_2:100,XBOOLE_0:def 3;
      suppose
        x in Int-Locations;
        then reconsider a = x as Int-Location by SCMFSA_2:4;
        thus (DataPart Exec (l,s1)).x = (Exec (l,s1)).a by A99,FUNCT_1:49

          .= s1.a by A98,SCMFSA_2:69
          .= (DataPart s1).a by A99,FUNCT_1:49
          .= s2.a by A1,A99,FUNCT_1:49
          .= (Exec (l,s2)).a by A98,SCMFSA_2:69
          .= (DataPart Exec (l,s2)).x by A99,FUNCT_1:49;
      end;
      suppose
        x in FinSeq-Locations;
        then reconsider a = x as FinSeq-Location by SCMFSA_2:5;
        thus (DataPart Exec (l,s1)).x = (Exec (l,s1)).a by A99,FUNCT_1:49

          .= s1.a by A98,SCMFSA_2:69
          .= (DataPart s1).a by A99,FUNCT_1:49
          .= s2.a by A1,A99,FUNCT_1:49
          .= (Exec (l,s2)).a by A98,SCMFSA_2:69
          .= (DataPart Exec (l,s2)).x by A99,FUNCT_1:49;
      end;
    end;
    hence thesis by A7,A9,FUNCT_1:2;
  end;
  suppose
    InsCode i = 7;
    then
A100: ex l1, a st i = a=0_goto l1 by SCMFSA_2:36;
    for x being set st x in ((Data-Locations SCM+FSA)) holds
    (DataPart Exec (l,s1)).x = (DataPart Exec (l,s2)).x
    proof
      let x be set;
      assume
A101: x in ((Data-Locations SCM+FSA));
      per cases by A101,SCMFSA_2:100,XBOOLE_0:def 3;
      suppose
        x in Int-Locations;
        then reconsider a = x as Int-Location by SCMFSA_2:4;
        thus (DataPart Exec (l,s1)).x = (Exec (l,s1)).a by A101,FUNCT_1:49

          .= s1.a by A100,SCMFSA_2:70
          .= (DataPart s1).a by A101,FUNCT_1:49
          .= s2.a by A1,A101,FUNCT_1:49
          .= (Exec (l,s2)).a by A100,SCMFSA_2:70
          .= (DataPart Exec (l,s2)).x by A101,FUNCT_1:49;
      end;
      suppose
        x in FinSeq-Locations;
        then reconsider a = x as FinSeq-Location by SCMFSA_2:5;
        thus (DataPart Exec (l,s1)).x = (Exec (l,s1)).a by A101,FUNCT_1:49

          .= s1.a by A100,SCMFSA_2:70
          .= (DataPart s1).a by A101,FUNCT_1:49
          .= s2.a by A1,A101,FUNCT_1:49
          .= (Exec (l,s2)).a by A100,SCMFSA_2:70
          .= (DataPart Exec (l,s2)).x by A101,FUNCT_1:49;
      end;
    end;
    hence thesis by A7,A9,FUNCT_1:2;
  end;
  suppose
    InsCode i = 8;
    then
A102: ex l1, a st i = a>0_goto l1 by SCMFSA_2:37;
    for x being set st x in ((Data-Locations SCM+FSA)) holds
    (DataPart Exec (l,s1)).x = (DataPart Exec (l,s2)).x
    proof
      let x be set;
      assume
A103: x in ((Data-Locations SCM+FSA));
      per cases by A103,SCMFSA_2:100,XBOOLE_0:def 3;
      suppose
        x in Int-Locations;
        then reconsider a = x as Int-Location by SCMFSA_2:4;
        thus (DataPart Exec (l,s1)).x = (Exec (l,s1)).a by A103,FUNCT_1:49

          .= s1.a by A102,SCMFSA_2:71
          .= (DataPart s1).a by A103,FUNCT_1:49
          .= s2.a by A1,A103,FUNCT_1:49
          .= (Exec (l,s2)).a by A102,SCMFSA_2:71
          .= (DataPart Exec (l,s2)).x by A103,FUNCT_1:49;
      end;
      suppose
        x in FinSeq-Locations;
        then reconsider a = x as FinSeq-Location by SCMFSA_2:5;
        thus (DataPart Exec (l,s1)).x = (Exec (l,s1)).a by A103,FUNCT_1:49

          .= s1.a by A102,SCMFSA_2:71
          .= (DataPart s1).a by A103,FUNCT_1:49
          .= s2.a by A1,A103,FUNCT_1:49
          .= (Exec (l,s2)).a by A102,SCMFSA_2:71
          .= (DataPart Exec (l,s2)).x by A103,FUNCT_1:49;
      end;
    end;
    hence thesis by A7,A9,FUNCT_1:2;
  end;
  suppose
    InsCode i = 9;
    then consider da,db being Int-Location, fa being FinSeq-Location such that
A104: l = db:=(fa,da) by SCMFSA_2:38;
A105: for x being set st x in ((Data-Locations SCM+FSA) \ {db})
holds (Exec (l,s1) | (Data-Locations SCM+FSA \ {db})).x = (Exec (l,
    s2) | (Data-Locations SCM+FSA \ {db})).x
    proof
      let x be set;
      assume
A106: x in ((Data-Locations SCM+FSA) \ {db});
      then
A107: x in Data-Locations SCM+FSA by XBOOLE_0:def 5;
A108: not x in {db} by A106,XBOOLE_0:def 5;
      per cases by A107,SCMFSA_2:100,XBOOLE_0:def 3;
      suppose
        x in Int-Locations;
        then reconsider a = x as Int-Location by SCMFSA_2:4;
A109:   a <> db by A108,TARSKI:def 1;
        thus (Exec (l,s1) | (Data-Locations SCM+FSA \ {db})).x = (
        Exec (l,s1)).a by A106,FUNCT_1:49
          .= s1.a by A104,A109,SCMFSA_2:72
          .= (DataPart s1).a by A107,FUNCT_1:49
          .= s2.a by A1,A107,FUNCT_1:49
          .= (Exec (l,s2)).a by A104,A109,SCMFSA_2:72
          .= (Exec (l,s2) | (Data-Locations SCM+FSA \ {db})).x by A106,
FUNCT_1:49;
      end;
      suppose
        x in FinSeq-Locations;
        then reconsider a = x as FinSeq-Location by SCMFSA_2:5;
        thus (Exec (l,s1) | (Data-Locations SCM+FSA \ {db})).x = (
        Exec (l,s1)).a by A106,FUNCT_1:49
          .= s1.a by A104,SCMFSA_2:72
          .= (DataPart s1).a by A107,FUNCT_1:49
          .= s2.a by A1,A107,FUNCT_1:49
          .= (Exec (l,s2)).a by A104,SCMFSA_2:72
          .= (Exec (l,s2) | (Data-Locations SCM+FSA \ {db})).x by A106,
FUNCT_1:49;
      end;
    end;
A110: dom ((Exec (l,s2)) | (Data-Locations SCM+FSA \ {db})) = (
    Data-Locations SCM+FSA \ {db}) by A8,RELAT_1:62;
    dom ((Exec (l,s1)) | (Data-Locations SCM+FSA \ {db})) = (
    Data-Locations SCM+FSA \ {db}) by A5,RELAT_1:62;
    then
A111: Exec (l,s1) | (Data-Locations SCM+FSA \ {db} ) = Exec (l,
    s2) | (Data-Locations SCM+FSA \ {db} ) by A110,A105,FUNCT_1:2;
    db in Int-Locations by SCMFSA_2:2;
    then db in Data-Locations SCM+FSA by SCMFSA_2:100,XBOOLE_0:def 3;
    then
A112: Data-Locations SCM+FSA = Data-Locations SCM+FSA \/ {db} by ZFMISC_1:40
      .= (Data-Locations SCM+FSA \ {db} ) \/ {db} by XBOOLE_1:39;
A113: ex k2 being Element of NAT st k2 = abs(s2.da) & Exec(l, s2).db = (
    s2.fa)/.k2 by A104,SCMFSA_2:72;
A114: ex k1 being Element of NAT st k1 = abs(s1.da) & Exec(l, s1).db = (
    s1.fa)/.k1 by A104,SCMFSA_2:72;
    fa in FinSeq-Locations by SCMFSA_2:3;
    then
A115: fa in Data-Locations SCM+FSA by SCMFSA_2:100,XBOOLE_0:def 3;
    then
A116: s1.fa = (DataPart s1).fa by FUNCT_1:49
      .= s2.fa by A1,A115,FUNCT_1:49;
    da in Int-Locations by SCMFSA_2:2;
    then
A117: da in Data-Locations SCM+FSA by SCMFSA_2:100,XBOOLE_0:def 3;
    then s1.da = (DataPart s1).da by FUNCT_1:49
      .= s2.da by A1,A117,FUNCT_1:49;
    then Exec (l,s1) | {db} = Exec(l,s2) | {db} by A6,A114,A113,A116,
GRFUNC_1:29;
    hence thesis by A112,A111,RELAT_1:150;
  end;
  suppose
    InsCode i = 10;
    then consider da,db being Int-Location, fa being FinSeq-Location such that
A118: l = (fa,da):=db by SCMFSA_2:39;
A119: for x being set st x in ((Data-Locations SCM+FSA) \ {fa})
holds (Exec (l,s1) | (Data-Locations SCM+FSA \ {fa})).x = (Exec (l,
    s2) | (Data-Locations SCM+FSA \ {fa})).x
    proof
      let x be set;
      assume
A120: x in ((Data-Locations SCM+FSA) \ {fa});
      then
A121: x in Data-Locations SCM+FSA by XBOOLE_0:def 5;
A122: not x in {fa} by A120,XBOOLE_0:def 5;
      per cases by A121,SCMFSA_2:100,XBOOLE_0:def 3;
      suppose
        x in Int-Locations;
        then reconsider a = x as Int-Location by SCMFSA_2:4;
        thus (Exec (l,s1) | (Data-Locations SCM+FSA \ {fa})).x = (
        Exec (l,s1)).a by A120,FUNCT_1:49
          .= s1.a by A118,SCMFSA_2:73
          .= (DataPart s1).a by A121,FUNCT_1:49
          .= s2.a by A1,A121,FUNCT_1:49
          .= (Exec (l,s2)).a by A118,SCMFSA_2:73
          .= (Exec (l,s2) | (Data-Locations SCM+FSA \ {fa})).x by A120,
FUNCT_1:49;
      end;
      suppose
        x in FinSeq-Locations;
        then reconsider a = x as FinSeq-Location by SCMFSA_2:5;
A123:   a <> fa by A122,TARSKI:def 1;
        thus (Exec (l,s1) | (Data-Locations SCM+FSA \ {fa})).x = (
        Exec (l,s1)).a by A120,FUNCT_1:49
          .= s1.a by A118,A123,SCMFSA_2:73
          .= (DataPart s1).a by A121,FUNCT_1:49
          .= s2.a by A1,A121,FUNCT_1:49
          .= (Exec (l,s2)).a by A118,A123,SCMFSA_2:73
          .= (Exec (l,s2) | (Data-Locations SCM+FSA \ {fa})).x by A120,
FUNCT_1:49;
      end;
    end;
A124: dom ((Exec (l,s2)) | (Data-Locations SCM+FSA \ {fa})) = (
    Data-Locations SCM+FSA \ {fa}) by A8,RELAT_1:62;
    dom ((Exec (l,s1)) | (Data-Locations SCM+FSA \ {fa})) = (
    Data-Locations SCM+FSA \ {fa}) by A5,RELAT_1:62;
    then
A125: Exec (l,s1) | (Data-Locations SCM+FSA \ {fa} ) = Exec (l,
    s2) | (Data-Locations SCM+FSA \ {fa} ) by A124,A119,FUNCT_1:2;
    fa in FinSeq-Locations by SCMFSA_2:3;
    then fa in Data-Locations SCM+FSA by SCMFSA_2:100,XBOOLE_0:def 3;
    then
A126: Data-Locations SCM+FSA = Data-Locations SCM+FSA \/ {fa} by ZFMISC_1:40
      .= (Data-Locations SCM+FSA \ {fa} ) \/ {fa} by XBOOLE_1:39;
    fa in FinSeq-Locations by SCMFSA_2:3;
    then
A127: fa in Data-Locations SCM+FSA by SCMFSA_2:100,XBOOLE_0:def 3;
    then
A128: s1.fa = (DataPart s1).fa by FUNCT_1:49
      .= s2.fa by A1,A127,FUNCT_1:49;
    db in Int-Locations by SCMFSA_2:2;
    then
A129: db in Data-Locations SCM+FSA by SCMFSA_2:100,XBOOLE_0:def 3;
    then
A130: s1.db = (DataPart s1).db by FUNCT_1:49
      .= s2.db by A1,A129,FUNCT_1:49;
A131: ex k2 being Element of NAT st k2 = abs(s2.da) & Exec(l, s2).fa =
    s2.fa+*(k2,s2.db) by A118,SCMFSA_2:73;
A132: ex k1 being Element of NAT st k1 = abs(s1.da) & Exec(l, s1).fa =
    s1.fa+*(k1,s1.db) by A118,SCMFSA_2:73;
    da in Int-Locations by SCMFSA_2:2;
    then
A133: da in Data-Locations SCM+FSA by SCMFSA_2:100,XBOOLE_0:def 3;
    then s1.da = (DataPart s1).da by FUNCT_1:49
      .= s2.da by A1,A133,FUNCT_1:49;
    then Exec (l,s1) | {fa} = Exec(l,s2) | {fa} by A6,A132,A131,A130,A128,
GRFUNC_1:29;
    hence thesis by A126,A125,RELAT_1:150;
  end;
  suppose
    InsCode i = 11;
    then consider da being Int-Location, fa being FinSeq-Location such that
A134: l = da:=len fa by SCMFSA_2:40;
A135: for x being set st x in ((Data-Locations SCM+FSA) \ {da})
holds (Exec (l,s1) | (Data-Locations SCM+FSA \ {da})).x = (Exec (l,
    s2) | (Data-Locations SCM+FSA \ {da})).x
    proof
      let x be set;
      assume
A136: x in ((Data-Locations SCM+FSA) \ {da});
      then
A137: x in Data-Locations SCM+FSA by XBOOLE_0:def 5;
A138: not x in {da} by A136,XBOOLE_0:def 5;
      per cases by A137,SCMFSA_2:100,XBOOLE_0:def 3;
      suppose
        x in Int-Locations;
        then reconsider a = x as Int-Location by SCMFSA_2:4;
A139:   a <> da by A138,TARSKI:def 1;
        thus (Exec (l,s1) | (Data-Locations SCM+FSA \ {da})).x = (
        Exec (l,s1)).a by A136,FUNCT_1:49
          .= s1.a by A134,A139,SCMFSA_2:74
          .= (DataPart s1).a by A137,FUNCT_1:49
          .= s2.a by A1,A137,FUNCT_1:49
          .= (Exec (l,s2)).a by A134,A139,SCMFSA_2:74
          .= (Exec (l,s2) | (Data-Locations SCM+FSA \ {da})).x by A136,
FUNCT_1:49;
      end;
      suppose
        x in FinSeq-Locations;
        then reconsider a = x as FinSeq-Location by SCMFSA_2:5;
        thus (Exec (l,s1) | (Data-Locations SCM+FSA \ {da})).x = (
        Exec (l,s1)).a by A136,FUNCT_1:49
          .= s1.a by A134,SCMFSA_2:74
          .= (DataPart s1).a by A137,FUNCT_1:49
          .= s2.a by A1,A137,FUNCT_1:49
          .= (Exec (l,s2)).a by A134,SCMFSA_2:74
          .= (Exec (l,s2) | (Data-Locations SCM+FSA \ {da})).x by A136,
FUNCT_1:49;
      end;
    end;
    da in Int-Locations by SCMFSA_2:2;
    then da in Data-Locations SCM+FSA by SCMFSA_2:100,XBOOLE_0:def 3;
    then
A140: Data-Locations SCM+FSA = Data-Locations SCM+FSA \/ {da} by ZFMISC_1:40
      .= (Data-Locations SCM+FSA \ {da} ) \/ {da} by XBOOLE_1:39;
    fa in FinSeq-Locations by SCMFSA_2:3;
    then
A141: fa in Data-Locations SCM+FSA by SCMFSA_2:100,XBOOLE_0:def 3;
    then s1.fa = (s1 | (Data-Locations SCM+FSA)).fa by FUNCT_1:49
      .= s2.fa by A1,A141,FUNCT_1:49;
    then Exec (l,s1).da = len(s2.fa) by A134,SCMFSA_2:74
      .= Exec (l,s2).da by A134,SCMFSA_2:74;
    then
A142: Exec (l,s1) | {da} = Exec(l,s2) | {da} by A5,A8,GRFUNC_1:29;
A143: dom ((Exec (l,s2)) | (Data-Locations SCM+FSA \ {da})) = (
    Data-Locations SCM+FSA \ {da}) by A8,RELAT_1:62;
    dom ((Exec (l,s1)) | (Data-Locations SCM+FSA \ {da})) = (
    Data-Locations SCM+FSA \ {da}) by A5,RELAT_1:62;
    then Exec (l,s1) | (Data-Locations SCM+FSA \ {da} ) = Exec (l,
    s2) | (Data-Locations SCM+FSA \ {da} ) by A143,A135,FUNCT_1:2;
    hence thesis by A140,A142,RELAT_1:150;
  end;
  suppose
    InsCode i = 12;
    then consider da being Int-Location, fa being FinSeq-Location such that
A144: i = fa:=<0,...,0>da by SCMFSA_2:41;
    set l = i;
A145: dom ((Exec (l,s2)) | (Data-Locations SCM+FSA \ {fa})) = (
    Data-Locations SCM+FSA \ {fa}) by A8,RELAT_1:62;
A146: ex k2 being Element of NAT st k2 = abs(s2.da) & Exec(l, s2).fa =
    k2 |->0 by A144,SCMFSA_2:75;
A147: ex k1 being Element of NAT st k1 = abs(s1.da) & Exec(l, s1).fa =
    k1 |->0 by A144,SCMFSA_2:75;
A148: for x being set st x in ((Data-Locations SCM+FSA) \ {fa})
holds (Exec (l,s1) | (Data-Locations SCM+FSA \ {fa})).x = (Exec (l,
    s2) | (Data-Locations SCM+FSA \ {fa})).x
    proof
      let x be set;
      assume
A149: x in ((Data-Locations SCM+FSA) \ {fa});
      then
A150: x in Data-Locations SCM+FSA by XBOOLE_0:def 5;
A151: not x in {fa} by A149,XBOOLE_0:def 5;
      per cases by A150,SCMFSA_2:100,XBOOLE_0:def 3;
      suppose
        x in Int-Locations;
        then reconsider a = x as Int-Location by SCMFSA_2:4;
        thus (Exec (l,s1) | (Data-Locations SCM+FSA \ {fa})).x = (
        Exec (l,s1)).a by A149,FUNCT_1:49
          .= s1.a by A144,SCMFSA_2:75
          .= (DataPart s1).a by A150,FUNCT_1:49
          .= s2.a by A1,A150,FUNCT_1:49
          .= (Exec (l,s2)).a by A144,SCMFSA_2:75
          .= (Exec (l,s2) | (Data-Locations SCM+FSA \ {fa})).x by A149,
FUNCT_1:49;
      end;
      suppose
        x in FinSeq-Locations;
        then reconsider a = x as FinSeq-Location by SCMFSA_2:5;
A152:   a <> fa by A151,TARSKI:def 1;
        thus (Exec (l,s1) | (Data-Locations SCM+FSA \ {fa})).x = (
        Exec (l,s1)).a by A149,FUNCT_1:49
          .= s1.a by A144,A152,SCMFSA_2:75
          .= (DataPart s1).a by A150,FUNCT_1:49
          .= s2.a by A1,A150,FUNCT_1:49
          .= (Exec (l,s2)).a by A144,A152,SCMFSA_2:75
          .= (Exec (l,s2) | (Data-Locations SCM+FSA \ {fa})).x by A149,
FUNCT_1:49;
      end;
    end;
    dom ((Exec (l,s1)) | (Data-Locations SCM+FSA \ {fa})) = (
    Data-Locations SCM+FSA \ {fa}) by A5,RELAT_1:62;
    then
A153: Exec (l,s1) | (Data-Locations SCM+FSA \ {fa} ) = Exec (l,
    s2) | (Data-Locations SCM+FSA \ {fa} ) by A145,A148,FUNCT_1:2;
    fa in FinSeq-Locations by SCMFSA_2:3;
    then fa in Data-Locations SCM+FSA by SCMFSA_2:100,XBOOLE_0:def 3;
    then
A154: Data-Locations SCM+FSA = Data-Locations SCM+FSA \/ {fa} by ZFMISC_1:40
      .= (Data-Locations SCM+FSA \ {fa} ) \/ {fa} by XBOOLE_1:39;
    da in Int-Locations by SCMFSA_2:2;
    then
A155: da in Data-Locations SCM+FSA by SCMFSA_2:100,XBOOLE_0:def 3;
    then s1.da = (DataPart s1).da by FUNCT_1:49
      .= s2.da by A1,A155,FUNCT_1:49;
    then Exec (l,s1) | {fa} = Exec(l,s2) | {fa} by A6,A147,A146,GRFUNC_1:29;
    hence thesis by A154,A153,RELAT_1:150;
  end;
end;

Lm3: now
  set IF = Data-Locations SCM+FSA;
  let I be keeping_0 parahalting Program of SCM+FSA, s be State of SCM+FSA;
  let P be Instruction-Sequence of SCM+FSA;
  set IE = IExec(I,P,s);
  now
A1: dom Initialized IE = the carrier of SCM+FSA by PARTFUN1:def 2;
A2: the carrier of SCM+FSA = {IC SCM+FSA} \/ Data-Locations SCM+FSA
     by STRUCT_0:4;
A3: dom IE = the carrier of SCM+FSA by PARTFUN1:def 2;
    hence dom DataPart Initialized IE = dom IE /\ IF by A1,RELAT_1:61;
    then
A4: dom DataPart Initialized IE= Data-Locations SCM+FSA
       by A3,A2,XBOOLE_1:21;
    let x;
    assume
A5: x in dom DataPart Initialized IE;
    per cases by A5,A4,SCMFSA_2:100,XBOOLE_0:def 3;
    suppose
      x in Int-Locations;
      then reconsider x9 = x as Int-Location by SCMFSA_2:4;
        per cases;
        suppose
A6:       x9 is read-write;
          thus (DataPart Initialized IE).x = (Initialized IE).x by A5,A4,
FUNCT_1:49
            .= IE.x by A6,Th3;
        end;
        suppose
          x9 is read-only;
          then
A7:       x9 = intloc 0 by SF_MASTR:def 5;
          thus (DataPart Initialized IE).x = (Initialized IE).x9 by A5,A4,
FUNCT_1:49
            .= 1 by A7,SCMFSA6A:38
            .= IE.x by A7,SCMFSA6B:11;
        end;
    end;
    suppose
      x in FinSeq-Locations;
      then reconsider x9 = x as FinSeq-Location by SCMFSA_2:5;
      thus (DataPart Initialized IE).x = (Initialized IE).x9
      by A5,A4,FUNCT_1:49
        .= IE.x by Th3;
    end;
  end;
  hence DataPart Initialized IE = DataPart IE by FUNCT_1:46;
end;

theorem Th6:
  for i being parahalting Instruction of SCM+FSA
   holds  Exec(i,Initialized s) =  IExec(Macro i,P,s)
proof
  let i be parahalting Instruction of SCM+FSA;
  set Mi = Macro i;
  set sI = s+*Initialize((intloc 0).-->1),
      pI = P+*Mi;
A1:  Mi c= pI by FUNCT_4:25;
  set Is = Initialized s;
  set IC1 = IC Comput(P+*Mi,sI,1);
  reconsider Mi as parahalting Program of SCM+FSA;
A3: IC1 in dom Mi by A1,AMISTD_1:def 10;
A24:  1 in dom Mi by COMPOS_1:60;
A25:  0 in dom Mi by COMPOS_1:60;
A26: Mi. 0 = i by COMPOS_1:58;
XX:  IC sI = 0 by MEMSTR_0:def 8;
A28: Comput(P+*Mi,sI,0+1) = Following(P+*Mi,Comput(P+*Mi,sI,0)) by EXTPRO_1:3
    .= Following(P+*Mi,sI) by EXTPRO_1:2
    .= Exec(pI. 0, sI) by XX,PBOOLE:143
    .= Exec(i, sI) by A26,A1,A25,GRFUNC_1:2;
  per cases by A3,COMPOS_1:60;
  suppose
A29: IC1 =  0;
    then
A30: CurInstr(P+*Mi,Comput(P+*Mi,sI,1)) = (P+*Mi). 0 by PBOOLE:143
      .= i by A26,A25,FUNCT_4:13;
    succ IC sI =  1 by XX;
    then
A31: InsCode i in {0, 6, 7, 8} by A28,A29,SCMFSA6A:3;
    hereby
      per cases by A31,ENUMSET1:def 2;
      suppose
        InsCode i = 0;
        then
A32:    i = halt SCM+FSA by SCMFSA_2:95;
        then P+*Mi halts_on sI by A30,EXTPRO_1:29;
        hence thesis by A28,A30,A32,EXTPRO_1:def 9;
      end;
      suppose
A33:    InsCode i = 6 or InsCode i = 7 or InsCode i = 8;
A34:    now
          let a;
          per cases by A33;
          suppose
            InsCode i = 6;
            then ex l st i = goto l by SCMFSA_2:35;
            hence sI.a = Exec(i, sI).a by SCMFSA_2:69;
          end;
          suppose
            InsCode i = 7;
            then ex l, b st i = b=0_goto l by SCMFSA_2:36;
            hence sI.a = Exec(i, sI).a by SCMFSA_2:70;
          end;
          suppose
            InsCode i = 8;
            then ex l, b st i = b>0_goto l by SCMFSA_2:37;
            hence sI.a = Exec(i, sI).a by SCMFSA_2:71;
          end;
        end;
A36:    now
          let f;
          per cases by A33;
          suppose
            InsCode i = 6;
            then ex l st i = goto l by SCMFSA_2:35;
            hence sI.f = Exec(i, sI).f by SCMFSA_2:69;
          end;
          suppose
            InsCode i = 7;
            then ex l, a st i = a=0_goto l by SCMFSA_2:36;
            hence sI.f = Exec(i, sI).f by SCMFSA_2:70;
          end;
          suppose
            InsCode i = 8;
            then ex l, a st i = a>0_goto l by SCMFSA_2:37;
            hence sI.f = Exec(i, sI).f by SCMFSA_2:71;
          end;
        end;
A38:    Following(P+*Mi,sI)
           = Following(P+*Mi,Comput(P+*Mi,sI,0)) by EXTPRO_1:2
          .= Exec(i, sI) by A28,EXTPRO_1:3;
        for n being Element of NAT holds
         CurInstr(P+*Mi,Comput(P+*Mi,sI,n)) <> halt SCM+FSA
          by A30,A33,SCMFSA_2:97,A34,A36,A28,A29,XX,
          A38,AMISTD_2:11,SCMFSA_2:104;
        then
A39:      not P+*Mi halts_on sI by EXTPRO_1:29;
         Mi c= P+*Mi by FUNCT_4:25;
        hence Exec(i,Initialized s) = IExec(Macro i,P,s)
          by A39,AMISTD_1:def 11;
      end;
    end;
  end;
  suppose
A41:    IC1 = 1;
A43: Mi.1 = halt SCM+FSA by COMPOS_1:59;
A44: CurInstr(P+*Mi,Comput(P+*Mi,sI,1))
       = (P+*Mi). 1 by A41,PBOOLE:143
      .= halt SCM+FSA by A43,A1,A24,GRFUNC_1:2;
    then P+*Mi halts_on sI by EXTPRO_1:29;
    hence thesis by A28,A44,EXTPRO_1:def 9;
  end;
end;

theorem Th7:
  for I being keeping_0 parahalting Program of SCM+FSA, j being
parahalting Instruction of SCM+FSA holds IExec(I ';' j,P,s).a
 = Exec(j,IExec(I,P,s)).a
proof
  let I be keeping_0 parahalting Program of SCM+FSA, j be parahalting
  Instruction of SCM+FSA;
  set Mj = Macro j;
  set SA = Start-At (IC IExec(Mj,P,IExec(I,P,s)) + card I,SCM+FSA);
A1: not a in dom SA by SCMFSA_2:102;
A2: DataPart Initialized IExec(I,P,s) = DataPart IExec(I,P,s) by Lm3;
  a in Int-Locations by SCMFSA_2:2;
  then
A3: a in Data-Locations SCM+FSA by SCMFSA_2:100,XBOOLE_0:def 3;
  thus IExec(I ';' j,P,s).a = IncIC(IExec(Mj,P,IExec(I,P,s)),card I).a
           by SCMFSA6B:20
    .= IExec(Mj,P,IExec(I,P,s)).a by A1,FUNCT_4:11
    .= ( Exec(j, Initialized IExec(I,P,s))).a by Th6
    .= (DataPart Exec(j, Initialized IExec(I,P,s))).a by A3,FUNCT_1:49

    .= (DataPart Exec(j,IExec(I,P,s))).a by A2,Th5
    .= Exec(j,IExec(I,P,s)).a by A3,FUNCT_1:49;
end;

theorem Th8:
  for I being keeping_0 parahalting Program of SCM+FSA, j being
parahalting Instruction of SCM+FSA holds IExec(I ';' j,P,s).f
 = Exec(j,IExec(I,P,s)).f
proof
  let I be keeping_0 parahalting Program of SCM+FSA, j be parahalting
  Instruction of SCM+FSA;
  set Mj = Macro j;
  set SA = Start-At (IC IExec(Mj,P,IExec(I,P,s)) + card I,SCM+FSA);
A1: not f in dom SA by SCMFSA_2:103;
A2: DataPart Initialized IExec(I,P,s) = DataPart IExec(I,P,s) by Lm3;
  f in FinSeq-Locations by SCMFSA_2:3;
  then
A3: f in Data-Locations SCM+FSA by SCMFSA_2:100,XBOOLE_0:def 3;
  thus IExec(I ';' j,P,s).f = IncIC(IExec(Mj,P,IExec(I,P,s)),card I).f
           by SCMFSA6B:20
    .= IExec(Mj,P,IExec(I,P,s)).f by A1,FUNCT_4:11
    .= ( Exec(j, Initialized IExec(I,P,s))).f by Th6
    .= (DataPart Exec(j, Initialized IExec(I,P,s))).f by A3,FUNCT_1:49
    .= (DataPart Exec(j,IExec(I,P,s))).f by A2,Th5
    .= Exec(j,IExec(I,P,s)).f by A3,FUNCT_1:49;
end;

theorem Th9:
  for i being keeping_0 parahalting Instruction of SCM+FSA, j being
parahalting Instruction of SCM+FSA holds IExec(i ';' j,P,s).a
 = Exec(j, Exec(i,Initialized s)).a
proof
  let i be keeping_0 parahalting Instruction of SCM+FSA, j be parahalting
  Instruction of SCM+FSA;
  set Mi = Macro i;
  thus IExec(i ';' j,P,s).a = IExec(Mi ';' j,P, s).a
    .= Exec(j,IExec(Mi,P,s)).a by Th7
    .= Exec(j, Exec(i, Initialized s)).a by Th6;
end;

theorem
  for i being keeping_0 parahalting Instruction of SCM+FSA, j being
parahalting Instruction of SCM+FSA holds IExec(i ';' j,P,s).f = Exec(j, Exec(i,
  Initialized s)).f
proof
  let i be keeping_0 parahalting Instruction of SCM+FSA, j be parahalting
  Instruction of SCM+FSA;
  set Mi = Macro i;
  thus IExec(i ';' j,P,s).f = IExec(Mi ';' j,P,s).f
    .= Exec(j,IExec(Mi,P,s)).f by Th8
    .= Exec(j, Exec(i, Initialized s)).f by Th6;
end;

begin :: An example

definition
  let a, b be Int-Location;
  func swap (a, b) -> Program of SCM+FSA equals
  FirstNotUsed Macro (a := b) :=
  a ';' (a := b) ';' (b := FirstNotUsed Macro (a := b));
  correctness;
end;

registration
  let a, b be Int-Location;
  cluster swap(a,b) -> parahalting;
  coherence;
end;

registration
  let a, b be read-write Int-Location;
  cluster swap(a,b) -> keeping_0;
  coherence;
end;

theorem
  for a, b being read-write Int-Location holds IExec(swap(a,b),P,s).a =
  s.b & IExec(swap(a,b),P,s).b = s.a
proof
  let a, b be read-write Int-Location;
  set i0 = FirstNotUsed Macro (a := b) := a;
  set i1 = a := b;
  set i2 = b := FirstNotUsed Macro (a := b);
  set i01 = i0 ';' i1;
  UsedIntLoc Macro (a := b) = UsedIntLoc (a := b) by SF_MASTR:28;
  then UsedIntLoc Macro (a := b) = {a, b} by SF_MASTR:14;
  then
A1: not FirstNotUsed Macro (a := b) in {a, b} by SF_MASTR:50;
  then
A2: FirstNotUsed Macro (a := b) <> a by TARSKI:def 2;
A3: FirstNotUsed Macro (a := b) <> b by A1,TARSKI:def 2;
  hereby
    per cases;
    suppose
A4:   a <> b;
      thus IExec(swap(a,b),P,s).a = Exec(i2, IExec(i01,P,s)).a by Th7
        .= IExec(i01,P,s).a by A4,SCMFSA_2:63
        .= Exec(i1, Exec(i0, Initialized s)).a by Th9
        .= Exec(i0, Initialized s).b by SCMFSA_2:63
        .= (Initialized s).b by A3,SCMFSA_2:63
        .= s.b by Th3;
    end;
    suppose
A5:   a = b;
      thus IExec(swap(a,b),P,s).a = Exec(i2, IExec(i01,P,s)).a by Th7
        .= IExec(i01,P,s).(FirstNotUsed Macro (a := b)) by A5,SCMFSA_2:63
        .= Exec(i1, Exec(i0, Initialized s)).(FirstNotUsed Macro (a := b)) by
Th9
        .= Exec(i0, Initialized s).(FirstNotUsed Macro (a := b)) by A2,
SCMFSA_2:63
        .= (Initialized s).a by SCMFSA_2:63
        .= s.b by A5,Th3;
    end;
  end;
  thus IExec(swap(a,b),P,s).b = Exec(i2, IExec(i01,P,s)).b by Th7
    .= IExec(i01,P,s).(FirstNotUsed Macro (a := b)) by SCMFSA_2:63
    .= Exec(i1, Exec(i0, Initialized s)).(FirstNotUsed Macro (a := b)) by Th9
    .= Exec(i0, Initialized s).(FirstNotUsed Macro (a := b)) by A2,SCMFSA_2:63
    .= (Initialized s).a by SCMFSA_2:63
    .= s.a by Th3;
end;

theorem
  UsedInt*Loc swap(a, b) = {}
proof
  set i0 = FirstNotUsed Macro (a := b) := a;
  set i1 = a := b;
  set i2 = b := FirstNotUsed Macro (a := b);
  thus UsedInt*Loc swap(a, b) = (UsedInt*Loc (i0 ';' i1)) \/ (UsedInt*Loc i2)
  by SF_MASTR:46
    .= (UsedInt*Loc (i0 ';' i1)) \/ {} by SF_MASTR:32
    .= (UsedInt*Loc i0) \/ (UsedInt*Loc i1) by SF_MASTR:47
    .= (UsedInt*Loc i0) \/ {} by SF_MASTR:32
    .= {} by SF_MASTR:32;
end;
