:: On the compositions of macro instructions, Part III
::  by Noriko Asamoto , Yatsuka Nakamura , Piotr Rudnicki and Andrzej Trybulec
::
:: Received July 22, 1996
:: Copyright (c) 1996 Association of Mizar Users

environ

 vocabularies AMI_1, SCMFSA_2, FSM_1, CARD_1, SCMFSA6B, TURING_1, FUNCT_1,
      RELAT_1, ARYTM_3, FUNCT_4, SCMFSA6A, TARSKI, XBOOLE_0, CIRCUIT2, NUMBERS,
      SUBSET_1, GRAPHSP, AMI_3, XXREAL_0, SF_MASTR, FUNCOP_1, NAT_1, FUNCT_7,
      STRUCT_0, ARYTM_1, INT_1, COMPLEX1, PARTFUN1, FINSEQ_1, FINSEQ_2,
      MSUALG_1, AOFA_I00, SCMFSA6C, ORDINAL1, SCMNORM;
 notations TARSKI, XBOOLE_0, SUBSET_1, ENUMSET1, CARD_1, NUMBERS, XCMPLX_0,
      NAT_1, INT_1, COMPLEX1, RELAT_1, FUNCT_1, PARTFUN1, FINSEQ_1, FINSEQ_2,
      FUNCOP_1, FUNCT_4, STRUCT_0, COMPOS_1, EXTPRO_1, AMI_1, FUNCT_7,
      SCMFSA_2,
      SCMFSA6A, SF_MASTR, SCMFSA6B, XXREAL_0;
 constructors DOMAIN_1, SETWISEO, XXREAL_0, INT_2, SCMFSA6A, SF_MASTR,
      SCMFSA6B, RELSET_1, PRE_POLY, AMISTD_2, AMI_1;
 registrations XBOOLE_0, SETFAM_1, RELAT_1, FUNCT_1, FUNCOP_1, FINSET_1,
      NUMBERS, XREAL_0, INT_1, AMI_1, SCMFSA_2, SCMFSA6A, SF_MASTR, SCMFSA6B,
      ORDINAL1, RELSET_1, COMPOS_1, STRUCT_0, EXTPRO_1;
 requirements NUMERALS, BOOLE, SUBSET, ARITHM;
 definitions FUNCOP_1, COMPOS_1, EXTPRO_1, AMI_1, SCMFSA6B, SCMFSA6A, PARTFUN1;
 theorems RELAT_1, FUNCT_7, FUNCT_4, FUNCT_1, SCMFSA_3, ZFMISC_1, FUNCOP_1,
      TARSKI, NAT_1, AMI_1, SCMFSA_2, ENUMSET1, GRFUNC_1, SCMFSA6A, SF_MASTR,
      SCMFSA6B, XBOOLE_0, XBOOLE_1, PARTFUN1, AFINSQ_1, COMPOS_1, EXTPRO_1;

begin :: Consequences of the main theorem from SCMFSA6B

reserve x for set,
  i for Instruction of SCM+FSA,
  a,b for Int-Location,
  f for FinSeq-Location,
  l, l1 for Element of NAT,
  s,s1,s2 for State of SCM+FSA;
set SA0 = Start-At( 0,SCM+FSA);

theorem
  for I being keeping_0 parahalting Program of SCM+FSA, J being
parahalting Program of SCM+FSA holds IExec(I ';' J, s).a = IExec(J,IExec(I,s)).
  a
proof
  let I be keeping_0 parahalting Program of SCM+FSA, J be parahalting Program
  of SCM+FSA;
A1: not a in dom Start-At (IC IExec(J,IExec(I,s)) + card I,SCM+FSA)
 by SCMFSA6B:9;
  IExec(I ';' J,s) = IExec(J,IExec(I,s)) +* Start-At (IC IExec(J,IExec(I,s
  )) + card I,SCM+FSA) by SCMFSA6B:44;
  hence thesis by A1,FUNCT_4:12;
end;

theorem
  for I being keeping_0 parahalting Program of SCM+FSA, J being
parahalting Program of SCM+FSA
 holds IExec(I ';' J, s).f = IExec(J,IExec(I,s)).f
proof
  let I be keeping_0 parahalting Program of SCM+FSA, J be parahalting Program
  of SCM+FSA;
A1: not f in dom Start-At (IC IExec(J,IExec(I,s)) + card I,SCM+FSA)
 by SCMFSA6B:10;
  IExec(I ';' J,s) = IExec(J,IExec(I,s)) +* Start-At (IC IExec(J,IExec(I,s
  )) + card I,SCM+FSA) by SCMFSA6B:44;
  hence thesis by A1,FUNCT_4:12;
end;

begin :: Properties of simple macro instructions

definition
  let i be Instruction of SCM+FSA;
  attr i is parahalting means
  :Def1:
  Macro i is parahalting;
  attr i is keeping_0 means
  :Def2:
  Macro i is keeping_0;
end;

Lm1: Macro halt SCM+FSA is parahalting
proof
  let s;
  set m = Macro halt SCM+FSA;
  set m1 = m +* Start-At( 0,SCM+FSA);
  assume
A1: m1 c= s;
A2: dom(Start-At( 0,SCM+FSA)) = {IC SCM+FSA} by FUNCOP_1:19;
  then
A3: IC SCM+FSA in dom (Start-At( 0,SCM+FSA)) by TARSKI:def 1;
  then
A4: IC SCM+FSA in dom m1 by FUNCT_4:13;
A5: IC m1 = m1.IC SCM+FSA
    .= (Start-At( 0,SCM+FSA)).IC SCM+FSA by A3,FUNCT_4:14
    .=  0 by FUNCOP_1:87;
A6: dom m = { 0, 1} by FUNCT_4:65;
  now
    assume dom m /\ dom (Start-At( 0,SCM+FSA)) is non empty;
    then consider x being set such that
A7: x in dom m /\ dom (Start-At( 0,SCM+FSA)) by XBOOLE_0:def 1;
    x in dom (Start-At( 0,SCM+FSA)) by A7,XBOOLE_0:def 4;
    then
A8: x=IC SCM+FSA by A2,TARSKI:def 1;
    x in dom m by A7,XBOOLE_0:def 4;
    then x= 0 or x= 1 by A6,TARSKI:def 2;
    hence contradiction by A8,COMPOS_1:3;
  end;
  then dom m misses dom (Start-At( 0,SCM+FSA)) by XBOOLE_0:def 7;
  then
A9: m c= m1 by FUNCT_4:33;
  take 0;
     IC Comput(ProgramPart(s),s,0) in NAT;
    hence IC Comput(ProgramPart(s),s,0) in dom ProgramPart s by COMPOS_1:34;
A10: m. 0 = halt SCM+FSA by FUNCT_4:66;
  dom m = { 0, 1} by FUNCT_4:65;
  then
A11:  0 in dom m by TARSKI:def 2;
  then
A12:  0 in dom m1 by FUNCT_4:13;
Y:  (ProgramPart s)/.IC s
 = s.IC s by COMPOS_1:38;
 Comput(ProgramPart(s),s,0) =
  s by EXTPRO_1:3;
  then
  CurInstr(ProgramPart (s),Comput(ProgramPart(s),s,0))
   = CurInstr(ProgramPart s,s)
    .= s.IC m1 by A1,A4,Y,GRFUNC_1:8
    .= m1. 0 by A1,A12,A5,GRFUNC_1:8
    .= halt SCM+FSA by A10,A9,A11,GRFUNC_1:8;
    hence thesis;
end;

Lm2: Macro halt SCM+FSA is keeping_0 parahalting
proof
  set Mi = Macro halt SCM+FSA;
  hereby
A1:  0 in dom (Mi +* Start-At( 0,SCM+FSA)) by COMPOS_1:146,SCMFSA6B:31;
    let s be State of SCM+FSA;
    assume
A2: Mi +* Start-At( 0,SCM+FSA) c= s;
    let k be Element of NAT;
A3: s = Comput(ProgramPart(s),s,0) by EXTPRO_1:3;
Y:  (ProgramPart s)/.IC s
 = s.IC s by COMPOS_1:38;
 Comput(ProgramPart(s),s,0) =
  s by EXTPRO_1:3;
  then
    CurInstr(ProgramPart Comput(ProgramPart(s),s,0),Comput(ProgramPart(s),s,0))
     = CurInstr(ProgramPart s,s)
      .= s. 0 by A2,Y,COMPOS_1:143
      .= (Mi +* Start-At( 0,SCM+FSA)). 0 by A2,A1,GRFUNC_1:8
      .= halt SCM+FSA by COMPOS_1:148,SCMFSA6B:33;
    hence (Comput(ProgramPart(s),s,k)).intloc 0 = s.intloc 0 by A3,EXTPRO_1:6
,NAT_1:2;
  end;
  thus thesis by Lm1;
end;

registration
  cluster halt SCM+FSA -> keeping_0 parahalting;
  coherence
  proof
    thus Macro halt SCM+FSA is keeping_0 parahalting by Lm2;
  end;
end;

registration
  cluster keeping_0 parahalting Instruction of SCM+FSA;
  existence
  proof
    take halt SCM+FSA;
    thus thesis;
  end;
end;

registration
  let i be parahalting Instruction of SCM+FSA;
  cluster Macro i -> parahalting;
  coherence by Def1;
end;

registration
  let i be keeping_0 Instruction of SCM+FSA;
  cluster Macro i -> keeping_0;
  coherence by Def2;
end;

registration
  let a, b be Int-Location;
  cluster a := b -> parahalting;
  coherence
  proof
    set Ma = Macro (a := b);
    let s such that
A1: Macro (a := b) +* Start-At( 0,SCM+FSA) c= s;
A2: Ma c= s by A1,SCMFSA6B:5;
    take 1;
     IC Comput(ProgramPart(s),s,1) in NAT;
    hence IC Comput(ProgramPart(s),s,1) in dom ProgramPart s by COMPOS_1:34;
    dom Start-At( 0,SCM+FSA) = {IC SCM+FSA} by FUNCOP_1:19;
    then
A3: IC SCM+FSA in dom SA0 by TARSKI:def 1;
    SA0 c= Macro (a := b) +* Start-At( 0,SCM+FSA) by FUNCT_4:26;
    then SA0 c= s by A1,XBOOLE_1:1;
    then
A4: IC s = SA0.IC SCM+FSA by A3,GRFUNC_1:8
      .=  0 by FUNCOP_1:87;
    then
A5: IC Exec(a:=b, s) = succ  0 by SCMFSA_2:89
      .=  (0+1);
     1 in dom Ma by SCMFSA6B:32;
    then Ma. 1 = s. 1 by A2,GRFUNC_1:8;
    then
A6: s. 1 = halt SCM+FSA by COMPOS_1:148,SCMFSA6B:33;
     0 in dom Ma by SCMFSA6B:32;
    then
A7: Ma. 0 = s. 0 by A2,GRFUNC_1:8;
Y:  (ProgramPart s)/.IC s
 = s.IC s by COMPOS_1:38;
Z:  (ProgramPart Comput(ProgramPart(s),s,1))/.IC Comput(ProgramPart(s),s,1)
 = Comput(ProgramPart(s),s,1).IC Comput(ProgramPart(s),s,1) by COMPOS_1:38;
NX: ProgramPart s = ProgramPart Comput(ProgramPart(s),s,1)
by AMI_1:123;
    Comput(ProgramPart(s),s,0+1) = Following(ProgramPart s,
    Comput(ProgramPart(s),s,0)) by EXTPRO_1:4
      .= Following(ProgramPart s,s) by EXTPRO_1:3
      .= Exec(a:=b, s) by A4,A7,Y,COMPOS_1:148,SCMFSA6B:33;
     then CurInstr(ProgramPart (s),Comput(ProgramPart(s),s,1))
      = halt SCM+FSA by A6,A5,Z,NX,AMI_1:def 13;
    hence thesis;
  end;
  cluster AddTo(a,b) -> parahalting;
  coherence
  proof
    set Ma = Macro (AddTo(a,b));
    let s such that
A8: Macro (AddTo(a,b)) +* Start-At( 0,SCM+FSA) c= s;
A9: Ma c= s by A8,SCMFSA6B:5;
    take 1;
     IC Comput(ProgramPart(s),s,1) in NAT;
    hence IC Comput(ProgramPart(s),s,1) in dom ProgramPart s by COMPOS_1:34;
    dom Start-At( 0,SCM+FSA) = {IC SCM+FSA} by FUNCOP_1:19;
    then
A10: IC SCM+FSA in dom SA0 by TARSKI:def 1;
    SA0 c= Macro (AddTo(a,b)) +* Start-At( 0,SCM+FSA) by FUNCT_4:26;
    then SA0 c= s by A8,XBOOLE_1:1;
    then
A11: IC s = SA0.IC SCM+FSA by A10,GRFUNC_1:8
      .=  0 by FUNCOP_1:87;
    then
A12: IC Exec(AddTo(a,b), s) = succ  0 by SCMFSA_2:90
      .=  (0+1);
     1 in dom Ma by SCMFSA6B:32;
    then Ma. 1 = s. 1 by A9,GRFUNC_1:8;
    then
A13: s. 1 = halt SCM+FSA by COMPOS_1:148,SCMFSA6B:33;
     0 in dom Ma by SCMFSA6B:32;
    then
A14: Ma. 0 = s. 0 by A9,GRFUNC_1:8;
Y:  (ProgramPart s)/.IC s
 = s.IC s by COMPOS_1:38;
Z:  (ProgramPart Comput(ProgramPart(s),s,1))/.IC Comput(ProgramPart(s),s,1)
 = Comput(ProgramPart(s),s,1).IC Comput(ProgramPart(s),s,1) by COMPOS_1:38;
NX: ProgramPart s = ProgramPart Comput(ProgramPart(s),s,1)
by AMI_1:123;
    Comput(ProgramPart(s),s,0+1) = Following(ProgramPart s,
    Comput(ProgramPart(s),s,0)) by EXTPRO_1:4
      .= Following(ProgramPart s,s) by EXTPRO_1:3
      .= Exec(AddTo(a,b), s) by A11,A14,Y,COMPOS_1:148,SCMFSA6B:33;
     then CurInstr(ProgramPart (s),Comput(ProgramPart(s),s,1))
      = halt SCM+FSA by A13,A12,Z,NX,AMI_1:def 13;
    hence thesis;
  end;
  cluster SubFrom(a,b) -> parahalting;
  coherence
  proof
    set Ma = Macro (SubFrom(a,b));
    let s such that
A15: Macro (SubFrom(a,b)) +* Start-At( 0,SCM+FSA) c= s;
A16: Ma c= s by A15,SCMFSA6B:5;
    take 1;
     IC Comput(ProgramPart(s),s,1) in NAT;
    hence IC Comput(ProgramPart(s),s,1) in dom ProgramPart s by COMPOS_1:34;
    dom Start-At( 0,SCM+FSA) = {IC SCM+FSA} by FUNCOP_1:19;
    then
A17: IC SCM+FSA in dom SA0 by TARSKI:def 1;
    SA0 c= Macro (SubFrom(a,b)) +* Start-At( 0,SCM+FSA) by FUNCT_4:26;
    then SA0 c= s by A15,XBOOLE_1:1;
    then
A18: IC s = SA0.IC SCM+FSA by A17,GRFUNC_1:8
      .=  0 by FUNCOP_1:87;
    then
A19: IC Exec(SubFrom(a,b), s) = succ  0 by SCMFSA_2:91
      .=  (0+1);
     1 in dom Ma by SCMFSA6B:32;
    then Ma. 1 = s. 1 by A16,GRFUNC_1:8;
    then
A20: s. 1 = halt SCM+FSA by COMPOS_1:148,SCMFSA6B:33;
Y:  (ProgramPart s)/.IC s
 = s.IC s by COMPOS_1:38;
Z:  (ProgramPart Comput(ProgramPart(s),s,1))/.IC Comput(ProgramPart(s),s,1)
 = Comput(ProgramPart(s),s,1).IC Comput(ProgramPart(s),s,1) by COMPOS_1:38;
     0 in dom Ma by SCMFSA6B:32;
    then
A21: Ma. 0 = s. 0 by A16,GRFUNC_1:8;
NX: ProgramPart s = ProgramPart Comput(ProgramPart(s),s,1)
by AMI_1:123;
    Comput(ProgramPart(s),s,0+1) = Following(ProgramPart s,
    Comput(ProgramPart(s),s,0)) by EXTPRO_1:4
      .= Following(ProgramPart s,s) by EXTPRO_1:3
      .= Exec(SubFrom(a,b), s) by A18,A21,Y,COMPOS_1:148,SCMFSA6B:33;
     then CurInstr(ProgramPart (s),Comput(ProgramPart(s),s,1))
      = halt SCM+FSA by A20,A19,Z,NX,AMI_1:def 13;
    hence thesis;
  end;
  cluster MultBy(a,b) -> parahalting;
  coherence
  proof
    set Ma = Macro (MultBy(a,b));
    let s such that
A22: Macro (MultBy(a,b)) +* Start-At( 0,SCM+FSA) c= s;
A23: Ma c= s by A22,SCMFSA6B:5;
    take 1;
     IC Comput(ProgramPart(s),s,1) in NAT;
    hence IC Comput(ProgramPart(s),s,1) in dom ProgramPart s by COMPOS_1:34;
    dom Start-At( 0,SCM+FSA) = {IC SCM+FSA} by FUNCOP_1:19;
    then
A24: IC SCM+FSA in dom SA0 by TARSKI:def 1;
    SA0 c= Macro (MultBy(a,b)) +* Start-At( 0,SCM+FSA) by FUNCT_4:26;
    then SA0 c= s by A22,XBOOLE_1:1;
    then
A25: IC s = SA0.IC SCM+FSA by A24,GRFUNC_1:8
      .=  0 by FUNCOP_1:87;
    then
A26: IC Exec(MultBy(a,b), s) = succ  0 by SCMFSA_2:92
      .=  (0+1);
     1 in dom Ma by SCMFSA6B:32;
    then Ma. 1 = s. 1 by A23,GRFUNC_1:8;
    then
A27: s. 1 = halt SCM+FSA by COMPOS_1:148,SCMFSA6B:33;
     0 in dom Ma by SCMFSA6B:32;
    then
A28: Ma. 0 = s. 0 by A23,GRFUNC_1:8;
Y:  (ProgramPart s)/.IC s
 = s.IC s by COMPOS_1:38;
Z:  (ProgramPart Comput(ProgramPart(s),s,1))/.IC Comput(ProgramPart(s),s,1)
 = Comput(ProgramPart(s),s,1).IC Comput(ProgramPart(s),s,1) by COMPOS_1:38;
NX: ProgramPart s = ProgramPart Comput(ProgramPart(s),s,1)
by AMI_1:123;
    Comput(ProgramPart(s),s,0+1) = Following(ProgramPart s,
    Comput(ProgramPart(s),s,0)) by EXTPRO_1:4
      .= Following(ProgramPart s,s) by EXTPRO_1:3
      .= Exec(MultBy(a,b), s) by A25,A28,Y,COMPOS_1:148,SCMFSA6B:33;
     then CurInstr(ProgramPart (s),Comput(ProgramPart(s),s,1))
      = halt SCM+FSA by A27,A26,Z,NX,AMI_1:def 13;
    hence thesis;
  end;
  cluster Divide(a,b) -> parahalting;
  coherence
  proof
    set Ma = Macro (Divide(a,b));
    let s such that
A29: Macro (Divide(a,b)) +* Start-At( 0,SCM+FSA) c= s;
A30: Ma c= s by A29,SCMFSA6B:5;
    take 1;
     IC Comput(ProgramPart(s),s,1) in NAT;
    hence IC Comput(ProgramPart(s),s,1) in dom ProgramPart s by COMPOS_1:34;
    dom Start-At( 0,SCM+FSA) = {IC SCM+FSA} by FUNCOP_1:19;
    then
A31: IC SCM+FSA in dom SA0 by TARSKI:def 1;
    SA0 c= Macro (Divide(a,b)) +* Start-At( 0,SCM+FSA) by FUNCT_4:26;
    then SA0 c= s by A29,XBOOLE_1:1;
    then
A32: IC s = SA0.IC SCM+FSA by A31,GRFUNC_1:8
      .=  0 by FUNCOP_1:87;
    then
A33: IC Exec(Divide(a,b), s) = succ  0 by SCMFSA_2:93
      .=  (0+1);
     1 in dom Ma by SCMFSA6B:32;
    then Ma. 1 = s. 1 by A30,GRFUNC_1:8;
    then
A34: s. 1 = halt SCM+FSA by COMPOS_1:148,SCMFSA6B:33;
     0 in dom Ma by SCMFSA6B:32;
    then
A35: Ma. 0 = s. 0 by A30,GRFUNC_1:8;
Y:  (ProgramPart s)/.IC s
 = s.IC s by COMPOS_1:38;
Z:  (ProgramPart Comput(ProgramPart(s),s,1))/.IC Comput(ProgramPart(s),s,1)
 = Comput(ProgramPart(s),s,1).IC Comput(ProgramPart(s),s,1) by COMPOS_1:38;
NX: ProgramPart s = ProgramPart Comput(ProgramPart(s),s,1)
by AMI_1:123;
    Comput(ProgramPart(s),s,0+1) = Following(ProgramPart s,
    Comput(ProgramPart(s),s,0)) by EXTPRO_1:4
      .= Following(ProgramPart s,s) by EXTPRO_1:3
      .= Exec(Divide(a,b), s) by A32,A35,Y,COMPOS_1:148,SCMFSA6B:33;
     then CurInstr(ProgramPart (s),Comput(ProgramPart(s),s,1))
      = halt SCM+FSA by A34,A33,Z,NX,AMI_1:def 13;
    hence thesis;
  end;
  let f be FinSeq-Location;
  cluster b := (f,a) -> parahalting;
  coherence
  proof
    set Ma = Macro (b:=(f,a));
    let s such that
A36: Macro (b:=(f,a)) +* Start-At( 0,SCM+FSA) c= s;
A37: Ma c= s by A36,SCMFSA6B:5;
    take 1;
     IC Comput(ProgramPart(s),s,1) in NAT;
    hence IC Comput(ProgramPart(s),s,1) in dom ProgramPart s by COMPOS_1:34;
    dom Start-At( 0,SCM+FSA) = {IC SCM+FSA} by FUNCOP_1:19;
    then
A38: IC SCM+FSA in dom SA0 by TARSKI:def 1;
    SA0 c= Macro (b:=(f,a)) +* Start-At( 0,SCM+FSA) by FUNCT_4:26;
    then SA0 c= s by A36,XBOOLE_1:1;
    then
A39: IC s = SA0.IC SCM+FSA by A38,GRFUNC_1:8
      .=  0 by FUNCOP_1:87;
    then
A40: IC Exec(b:=(f,a), s) = succ  0 by SCMFSA_2:98
      .=  (0+1);
     1 in dom Ma by SCMFSA6B:32;
    then Ma. 1 = s. 1 by A37,GRFUNC_1:8;
    then
A41: s. 1 = halt SCM+FSA by COMPOS_1:148,SCMFSA6B:33;
     0 in dom Ma by SCMFSA6B:32;
    then
A42: Ma. 0 = s. 0 by A37,GRFUNC_1:8;
Y:  (ProgramPart s)/.IC s
 = s.IC s by COMPOS_1:38;
Z:  (ProgramPart Comput(ProgramPart(s),s,1))/.IC Comput(ProgramPart(s),s,1)
 = Comput(ProgramPart(s),s,1).IC Comput(ProgramPart(s),s,1) by COMPOS_1:38;
NX: ProgramPart s = ProgramPart Comput(ProgramPart(s),s,1)
by AMI_1:123;
    Comput(ProgramPart(s),s,0+1) = Following(ProgramPart s,
    Comput(ProgramPart(s),s,0)) by EXTPRO_1:4
      .= Following(ProgramPart s,s) by EXTPRO_1:3
      .= Exec(b:=(f,a), s) by A39,A42,Y,COMPOS_1:148,SCMFSA6B:33;
     then CurInstr(ProgramPart (s),Comput(ProgramPart(s),s,1))
      = halt SCM+FSA by A41,A40,Z,NX,AMI_1:def 13;
    hence thesis;
  end;
  cluster (f,a) := b -> parahalting keeping_0;
  coherence
  proof
    thus (f,a) := b is parahalting
    proof
      set Ma = Macro ((f,a):=b);
      let s such that
A43:  Macro ((f,a):=b) +* Start-At( 0,SCM+FSA) c= s;
A44:  Ma c= s by A43,SCMFSA6B:5;
      take 1;
     IC Comput(ProgramPart(s),s,1) in NAT;
    hence IC Comput(ProgramPart(s),s,1) in dom ProgramPart s by COMPOS_1:34;
      dom Start-At( 0,SCM+FSA) = {IC SCM+FSA} by FUNCOP_1:19;
      then
A45:  IC SCM+FSA in dom SA0 by TARSKI:def 1;
      SA0 c= Macro ((f,a):=b) +* Start-At( 0,SCM+FSA) by FUNCT_4:26;
      then SA0 c= s by A43,XBOOLE_1:1;
      then
A46:  IC s = SA0.IC SCM+FSA by A45,GRFUNC_1:8
        .=  0 by FUNCOP_1:87;
      then
A47:  IC Exec((f,a):=b, s) = succ  0 by SCMFSA_2:99
        .=  (0+1);
       1 in dom Ma by SCMFSA6B:32;
      then Ma. 1 = s. 1 by A44,GRFUNC_1:8;
      then
A48:  s. 1 = halt SCM+FSA by COMPOS_1:148,SCMFSA6B:33;
       0 in dom Ma by SCMFSA6B:32;
      then
A49:  Ma. 0 = s. 0 by A44,GRFUNC_1:8;
Y:  (ProgramPart s)/.IC s
 = s.IC s by COMPOS_1:38;
Z:  (ProgramPart Comput(ProgramPart(s),s,1))/.IC Comput(ProgramPart(s),s,1)
 = Comput(ProgramPart(s),s,1).IC Comput(ProgramPart(s),s,1) by COMPOS_1:38;
NX: ProgramPart s = ProgramPart Comput(ProgramPart(s),s,1)
by AMI_1:123;
      Comput(ProgramPart(s),s,0+1) = Following(ProgramPart s,
      Comput(ProgramPart(s),s,0)) by EXTPRO_1:4
        .= Following(ProgramPart s,s) by EXTPRO_1:3
        .= Exec((f,a):=b, s) by A46,A49,Y,COMPOS_1:148,SCMFSA6B:33;
     then CurInstr(ProgramPart (s),Comput(ProgramPart(s),s,1))
      = halt SCM+FSA by A48,A47,Z,NX,AMI_1:def 13;
      hence thesis;
    end;
    thus (f,a) := b is keeping_0
    proof
      set Ma = Macro ((f,a):=b);
      let s;
      assume
A50:  Macro ((f,a):=b) +* Start-At( 0,SCM+FSA) c= s;
      then
A51:  Ma c= s by SCMFSA6B:5;
      let k be Element of NAT;
      dom Start-At( 0,SCM+FSA) = {IC SCM+FSA} by FUNCOP_1:19;
      then
A52:  IC SCM+FSA in dom SA0 by TARSKI:def 1;
      SA0 c= Macro ((f,a):=b) +* Start-At( 0,SCM+FSA) by FUNCT_4:26;
      then SA0 c= s by A50,XBOOLE_1:1;
      then
A53:  IC s = SA0.IC SCM+FSA by A52,GRFUNC_1:8
        .=  0 by FUNCOP_1:87;
       0 in dom Ma by SCMFSA6B:32;
      then
A54:  Ma. 0 = s. 0 by A51,GRFUNC_1:8;
Y:  (ProgramPart s)/.IC s
 = s.IC s by COMPOS_1:38;
Z:  (ProgramPart Comput(ProgramPart(s),s,1))/.IC Comput(ProgramPart(s),s,1)
 = Comput(ProgramPart(s),s,1).IC Comput(ProgramPart(s),s,1) by COMPOS_1:38;
A55:  Comput(ProgramPart(s),s,0+1) = Following(ProgramPart s,
Comput(ProgramPart(s),s,0)) by EXTPRO_1:4
        .= Following(ProgramPart s,s) by EXTPRO_1:3
        .= Exec((f,a):=b, s) by A53,A54,Y,COMPOS_1:148,SCMFSA6B:33;
       1 in dom Ma by SCMFSA6B:32;
      then Ma. 1 = s. 1 by A51,GRFUNC_1:8;
      then
A56:  s. 1 = halt SCM+FSA by COMPOS_1:148,SCMFSA6B:33;
T: ProgramPart s = ProgramPart Comput(ProgramPart(s),s,1)
by AMI_1:123;
      IC Exec((f,a):=b, s) = succ  0 by A53,SCMFSA_2:99
        .=  (0+1);
      then
A57:  CurInstr(ProgramPart Comput(ProgramPart(s),s,1),Comput(ProgramPart(s),s,1
))
 = halt SCM+FSA by A56,A55,Z,AMI_1:def 13;
      per cases by NAT_1:14;
      suppose
        k = 0;
        hence thesis by EXTPRO_1:3;
      end;
      suppose
A58:    1 <= k;
        Comput(ProgramPart(s),s,1).intloc 0 = s.intloc 0 by A55,SCMFSA_2:99;
        hence thesis by A57,A58,T,EXTPRO_1:6;
      end;
    end;
  end;
end;

registration
  let a be Int-Location, f be FinSeq-Location;
  cluster a :=len f -> parahalting;
  coherence
  proof
    set Ma = Macro (a:=len f);
    let s such that
A1: Macro (a:=len f) +* Start-At( 0,SCM+FSA) c= s;
A2: Ma c= s by A1,SCMFSA6B:5;
    take 1;
     IC Comput(ProgramPart(s),s,1) in NAT;
    hence IC Comput(ProgramPart(s),s,1) in dom ProgramPart s by COMPOS_1:34;
    dom Start-At( 0,SCM+FSA) = {IC SCM+FSA} by FUNCOP_1:19;
    then
A3: IC SCM+FSA in dom SA0 by TARSKI:def 1;
    SA0 c= Macro (a:=len f) +* Start-At( 0,SCM+FSA) by FUNCT_4:26;
    then SA0 c= s by A1,XBOOLE_1:1;
    then
A4: IC s = SA0.IC SCM+FSA by A3,GRFUNC_1:8
      .=  0 by FUNCOP_1:87;
    then
A5: IC Exec(a:=len f, s) = succ  0 by SCMFSA_2:100
      .=  (0+1);
     1 in dom Ma by SCMFSA6B:32;
    then Ma. 1 = s. 1 by A2,GRFUNC_1:8;
    then
A6: s. 1 = halt SCM+FSA by COMPOS_1:148,SCMFSA6B:33;
     0 in dom Ma by SCMFSA6B:32;
    then
A7: Ma. 0 = s. 0 by A2,GRFUNC_1:8;
Y:  (ProgramPart s)/.IC s
 = s.IC s by COMPOS_1:38;
Z:  (ProgramPart Comput(ProgramPart(s),s,1))/.IC Comput(ProgramPart(s),s,1)
 = Comput(ProgramPart(s),s,1).IC Comput(ProgramPart(s),s,1) by COMPOS_1:38;
NX: ProgramPart s = ProgramPart Comput(ProgramPart(s),s,1)
by AMI_1:123;
    Comput(ProgramPart(s),s,0+1) = Following(ProgramPart s,
    Comput(ProgramPart(s),s,0)) by EXTPRO_1:4
      .= Following(ProgramPart s,s) by EXTPRO_1:3
      .= Exec(a:=len f, s) by A4,A7,Y,COMPOS_1:148,SCMFSA6B:33;
     then CurInstr(ProgramPart (s),Comput(ProgramPart(s),s,1))
      = halt SCM+FSA by A5,A6,Z,NX,AMI_1:def 13;
    hence thesis;
  end;
  cluster f :=<0,...,0> a -> parahalting keeping_0;
  coherence
  proof
    thus f :=<0,...,0> a is parahalting
    proof
      set Ma = Macro (f:=<0,...,0>a);
      let s such that
A8:   Macro (f:=<0,...,0>a) +* Start-At( 0,SCM+FSA) c= s;
A9:   Ma c= s by A8,SCMFSA6B:5;
      take 1;
     IC Comput(ProgramPart(s),s,1) in NAT;
    hence IC Comput(ProgramPart(s),s,1) in dom ProgramPart s by COMPOS_1:34;
      dom Start-At( 0,SCM+FSA) = {IC SCM+FSA} by FUNCOP_1:19;
      then
A10:  IC SCM+FSA in dom SA0 by TARSKI:def 1;
      SA0 c= Macro (f:=<0,...,0>a) +* Start-At( 0,SCM+FSA) by FUNCT_4:26;
      then SA0 c= s by A8,XBOOLE_1:1;
      then
A11:  IC s = SA0.IC SCM+FSA by A10,GRFUNC_1:8
        .=  0 by FUNCOP_1:87;
      then
A12:  IC Exec(f:=<0,...,0>a, s) = succ  0 by SCMFSA_2:101
        .=  (0+1);
       1 in dom Ma by SCMFSA6B:32;
      then Ma. 1 = s. 1 by A9,GRFUNC_1:8;
      then
A13:  s. 1 = halt SCM+FSA by COMPOS_1:148,SCMFSA6B:33;
       0 in dom Ma by SCMFSA6B:32;
      then
A14:  Ma. 0 = s. 0 by A9,GRFUNC_1:8;
Y:  (ProgramPart s)/.IC s
 = s.IC s by COMPOS_1:38;
Z:  (ProgramPart Comput(ProgramPart(s),s,1))/.IC Comput(ProgramPart(s),s,1)
 = Comput(ProgramPart(s),s,1).IC Comput(ProgramPart(s),s,1) by COMPOS_1:38;
NX: ProgramPart s = ProgramPart Comput(ProgramPart(s),s,1)
by AMI_1:123;
      Comput(ProgramPart(s),s,0+1) = Following(ProgramPart s,
      Comput(ProgramPart(s),s,0)) by EXTPRO_1:4
        .= Following(ProgramPart s,s) by EXTPRO_1:3
        .= Exec(f:=<0,...,0>a, s) by A11,A14,Y,COMPOS_1:148,SCMFSA6B:33;
     then CurInstr(ProgramPart (s),Comput(ProgramPart(s),s,1))
      = halt SCM+FSA by A12,A13,Z,NX,AMI_1:def 13;
      hence thesis;
    end;
    thus (f:=<0,...,0>a) is keeping_0
    proof
      set Ma = Macro (f:=<0,...,0>a);
      let s;
      assume
A15:  Macro (f:=<0,...,0>a) +* Start-At( 0,SCM+FSA) c= s;
      then
A16:  Ma c= s by SCMFSA6B:5;
      let k be Element of NAT;
      dom Start-At( 0,SCM+FSA) = {IC SCM+FSA} by FUNCOP_1:19;
      then
A17:  IC SCM+FSA in dom SA0 by TARSKI:def 1;
      SA0 c= Macro (f:=<0,...,0>a) +* Start-At( 0,SCM+FSA) by FUNCT_4:26;
      then SA0 c= s by A15,XBOOLE_1:1;
      then
A18:  IC s = SA0.IC SCM+FSA by A17,GRFUNC_1:8
        .=  0 by FUNCOP_1:87;
       0 in dom Ma by SCMFSA6B:32;
      then
A19:  Ma. 0 = s. 0 by A16,GRFUNC_1:8;
Y:  (ProgramPart s)/.IC s
 = s.IC s by COMPOS_1:38;
Z:  (ProgramPart Comput(ProgramPart(s),s,1))/.IC Comput(ProgramPart(s),s,1)
 = Comput(ProgramPart(s),s,1).IC Comput(ProgramPart(s),s,1) by COMPOS_1:38;
A20:  Comput(ProgramPart(s),s,0+1) = Following(ProgramPart s,
Comput(ProgramPart(s),s,0)) by EXTPRO_1:4
        .= Following(ProgramPart s,s) by EXTPRO_1:3
        .= Exec(f:=<0,...,0>a, s) by A18,A19,Y,COMPOS_1:148,SCMFSA6B:33;
       1 in dom Ma by SCMFSA6B:32;
      then Ma. 1 = s. 1 by A16,GRFUNC_1:8;
      then
A21:  s. 1 = halt SCM+FSA by COMPOS_1:148,SCMFSA6B:33;
T: ProgramPart s = ProgramPart Comput(ProgramPart(s),s,1)
by AMI_1:123;
      IC Exec(f:=<0,...,0>a, s) = succ  0 by A18,SCMFSA_2:101
        .=  (0+1);
      then
A22:  CurInstr(ProgramPart Comput(ProgramPart(s),s,1),Comput(ProgramPart(s),s,1
))
 = halt SCM+FSA by A21,A20,Z,AMI_1:def 13;
      per cases by NAT_1:14;
      suppose
        k = 0;
        hence thesis by EXTPRO_1:3;
      end;
      suppose
A23:    1 <= k;
        Comput(ProgramPart(s),s,1).intloc 0 = s.intloc 0 by A20,SCMFSA_2:101;
        hence thesis by A22,A23,T,EXTPRO_1:6;
      end;
    end;
  end;
end;

registration
  let a be read-write Int-Location, b be Int-Location;
  cluster a := b -> keeping_0;
  coherence
  proof
    set Ma = Macro (a:=b);
    let s;
    assume
A1: Macro (a:=b) +* Start-At( 0,SCM+FSA) c= s;
    then
A2: Ma c= s by SCMFSA6B:5;
    let k be Element of NAT;
    dom Start-At( 0,SCM+FSA) = {IC SCM+FSA} by FUNCOP_1:19;
    then
A3: IC SCM+FSA in dom SA0 by TARSKI:def 1;
    SA0 c= Macro (a:=b) +* Start-At( 0,SCM+FSA) by FUNCT_4:26;
    then SA0 c= s by A1,XBOOLE_1:1;
    then
A4: IC s = SA0.IC SCM+FSA by A3,GRFUNC_1:8
      .=  0 by FUNCOP_1:87;
     0 in dom Ma by SCMFSA6B:32;
    then
A5: Ma. 0 = s. 0 by A2,GRFUNC_1:8;
Y:  (ProgramPart s)/.IC s
 = s.IC s by COMPOS_1:38;
Z:  (ProgramPart Comput(ProgramPart(s),s,1))/.IC Comput(ProgramPart(s),s,1)
 = Comput(ProgramPart(s),s,1).IC Comput(ProgramPart(s),s,1) by COMPOS_1:38;
A6: Comput(ProgramPart(s),s,0+1) = Following(ProgramPart s,
Comput(ProgramPart(s),s,0)) by EXTPRO_1:4
      .= Following(ProgramPart s,s) by EXTPRO_1:3
      .= Exec(a:=b, s) by A4,A5,Y,COMPOS_1:148,SCMFSA6B:33;
     1 in dom Ma by SCMFSA6B:32;
    then Ma. 1 = s. 1 by A2,GRFUNC_1:8;
    then
A7: s. 1 = halt SCM+FSA by COMPOS_1:148,SCMFSA6B:33;
    IC Exec(a:=b, s) = succ  0 by A4,SCMFSA_2:89
      .=  (0+1);
    then
A8: CurInstr(ProgramPart Comput(ProgramPart(s),s,1),Comput(ProgramPart(s),s,1))
 = halt SCM+FSA by A7,A6,Z,AMI_1:def 13;
T: ProgramPart s = ProgramPart Comput(ProgramPart(s),s,1)
by AMI_1:123;
    per cases by NAT_1:14;
    suppose
      k = 0;
      hence thesis by EXTPRO_1:3;
    end;
    suppose
A9:   1 <= k;
      Comput(ProgramPart(s),s,1).intloc 0 = s.intloc 0 by A6,SCMFSA_2:89;
      hence thesis by A8,A9,T,EXTPRO_1:6;
    end;
  end;
  cluster AddTo(a, b) -> keeping_0;
  coherence
  proof
    set Ma = Macro (AddTo(a,b));
    let s;
    assume
A10: Macro (AddTo(a,b)) +* Start-At( 0,SCM+FSA) c= s;
    then
A11: Ma c= s by SCMFSA6B:5;
    let k be Element of NAT;
    dom Start-At( 0,SCM+FSA) = {IC SCM+FSA} by FUNCOP_1:19;
    then
A12: IC SCM+FSA in dom SA0 by TARSKI:def 1;
    SA0 c= Macro (AddTo(a,b)) +* Start-At( 0,SCM+FSA) by FUNCT_4:26;
    then SA0 c= s by A10,XBOOLE_1:1;
    then
A13: IC s = SA0.IC SCM+FSA by A12,GRFUNC_1:8
      .=  0 by FUNCOP_1:87;
     0 in dom Ma by SCMFSA6B:32;
    then
A14: Ma. 0 = s. 0 by A11,GRFUNC_1:8;
Y:  (ProgramPart s)/.IC s
 = s.IC s by COMPOS_1:38;
Z:  (ProgramPart Comput(ProgramPart(s),s,1))/.IC Comput(ProgramPart(s),s,1)
 = Comput(ProgramPart(s),s,1).IC Comput(ProgramPart(s),s,1) by COMPOS_1:38;
A15: Comput(ProgramPart(s),s,0+1) = Following(ProgramPart s,
Comput(ProgramPart(s),s,0)) by EXTPRO_1:4
      .= Following(ProgramPart s,s) by EXTPRO_1:3
      .= Exec(AddTo(a,b), s) by A13,A14,Y,COMPOS_1:148,SCMFSA6B:33;
     1 in dom Ma by SCMFSA6B:32;
    then Ma. 1 = s. 1 by A11,GRFUNC_1:8;
    then
A16: s. 1 = halt SCM+FSA by COMPOS_1:148,SCMFSA6B:33;
    IC Exec(AddTo(a,b), s) = succ  0 by A13,SCMFSA_2:90
      .=  (0+1);
    then
A17: CurInstr(ProgramPart Comput(ProgramPart(s),s,1),Comput(ProgramPart(s),s,1)
)
 = halt SCM+FSA by A16,A15,Z,AMI_1:def 13;
T: ProgramPart s = ProgramPart Comput(ProgramPart(s),s,1)
by AMI_1:123;
    per cases by NAT_1:14;
    suppose
      k = 0;
      hence thesis by EXTPRO_1:3;
    end;
    suppose
A18:  1 <= k;
      Comput(ProgramPart(s),s,1).intloc 0 = s.intloc 0 by A15,SCMFSA_2:90;
      hence thesis by A17,A18,T,EXTPRO_1:6;
    end;
  end;
  cluster SubFrom(a, b) -> keeping_0;
  coherence
  proof
    set Ma = Macro (SubFrom(a,b));
    let s;
    assume
A19: Macro (SubFrom(a,b)) +* Start-At( 0,SCM+FSA) c= s;
    then
A20: Ma c= s by SCMFSA6B:5;
    let k be Element of NAT;
    dom Start-At( 0,SCM+FSA) = {IC SCM+FSA} by FUNCOP_1:19;
    then
A21: IC SCM+FSA in dom SA0 by TARSKI:def 1;
    SA0 c= Macro (SubFrom(a,b)) +* Start-At( 0,SCM+FSA) by FUNCT_4:26;
    then SA0 c= s by A19,XBOOLE_1:1;
    then
A22: IC s = SA0.IC SCM+FSA by A21,GRFUNC_1:8
      .=  0 by FUNCOP_1:87;
     0 in dom Ma by SCMFSA6B:32;
    then
A23: Ma. 0 = s. 0 by A20,GRFUNC_1:8;
Y:  (ProgramPart s)/.IC s
 = s.IC s by COMPOS_1:38;
Z:  (ProgramPart Comput(ProgramPart(s),s,1))/.IC Comput(ProgramPart(s),s,1)
 = Comput(ProgramPart(s),s,1).IC Comput(ProgramPart(s),s,1) by COMPOS_1:38;
A24: Comput(ProgramPart(s),s,0+1) = Following(ProgramPart s,
Comput(ProgramPart(s),s,0)) by EXTPRO_1:4
      .= Following(ProgramPart s,s) by EXTPRO_1:3
      .= Exec(SubFrom(a,b), s) by A22,A23,Y,COMPOS_1:148,SCMFSA6B:33;
     1 in dom Ma by SCMFSA6B:32;
    then Ma. 1 = s. 1 by A20,GRFUNC_1:8;
    then
A25: s. 1 = halt SCM+FSA by COMPOS_1:148,SCMFSA6B:33;
    IC Exec(SubFrom(a,b), s) = succ  0 by A22,SCMFSA_2:91
      .=  (0+1);
    then
A26: CurInstr(ProgramPart Comput(ProgramPart(s),s,1),Comput(ProgramPart(s),s,1)
)
 = halt SCM+FSA by A25,A24,Z,AMI_1:def 13;
T: ProgramPart s = ProgramPart Comput(ProgramPart(s),s,1)
by AMI_1:123;
    per cases by NAT_1:14;
    suppose
      k = 0;
      hence thesis by EXTPRO_1:3;
    end;
    suppose
A27:  1 <= k;
      Comput(ProgramPart(s),s,1).intloc 0 = s.intloc 0 by A24,SCMFSA_2:91;
      hence thesis by A26,A27,T,EXTPRO_1:6;
    end;
  end;
  cluster MultBy(a, b) -> keeping_0;
  coherence
  proof
    set Ma = Macro (MultBy(a,b));
    let s;
    assume
A28: Macro (MultBy(a,b)) +* Start-At( 0,SCM+FSA) c= s;
    then
A29: Ma c= s by SCMFSA6B:5;
    let k be Element of NAT;
    dom Start-At( 0,SCM+FSA) = {IC SCM+FSA} by FUNCOP_1:19;
    then
A30: IC SCM+FSA in dom SA0 by TARSKI:def 1;
    SA0 c= Macro (MultBy(a,b)) +* Start-At( 0,SCM+FSA) by FUNCT_4:26;
    then SA0 c= s by A28,XBOOLE_1:1;
    then
A31: IC s = SA0.IC SCM+FSA by A30,GRFUNC_1:8
      .=  0 by FUNCOP_1:87;
     0 in dom Ma by SCMFSA6B:32;
    then
A32: Ma. 0 = s. 0 by A29,GRFUNC_1:8;
Y:  (ProgramPart s)/.IC s
 = s.IC s by COMPOS_1:38;
Z:  (ProgramPart Comput(ProgramPart(s),s,1))/.IC Comput(ProgramPart(s),s,1)
 = Comput(ProgramPart(s),s,1).IC Comput(ProgramPart(s),s,1) by COMPOS_1:38;
A33: Comput(ProgramPart(s),s,0+1) = Following(ProgramPart s,
Comput(ProgramPart(s),s,0)) by EXTPRO_1:4
      .= Following(ProgramPart s,s) by EXTPRO_1:3
      .= Exec(MultBy(a,b), s) by A31,A32,Y,COMPOS_1:148,SCMFSA6B:33;
     1 in dom Ma by SCMFSA6B:32;
    then Ma. 1 = s. 1 by A29,GRFUNC_1:8;
    then
A34: s. 1 = halt SCM+FSA by COMPOS_1:148,SCMFSA6B:33;
    IC Exec(MultBy(a,b), s) = succ  0 by A31,SCMFSA_2:92
      .=  (0+1);
    then
A35: CurInstr(ProgramPart Comput(ProgramPart(s),s,1),Comput(ProgramPart(s),s,1)
)
 = halt SCM+FSA by A34,A33,Z,AMI_1:def 13;
T: ProgramPart s = ProgramPart Comput(ProgramPart(s),s,1)
by AMI_1:123;
    per cases by NAT_1:14;
    suppose
      k = 0;
      hence thesis by EXTPRO_1:3;
    end;
    suppose
A36:  1 <= k;
      Comput(ProgramPart(s),s,1).intloc 0 = s.intloc 0 by A33,SCMFSA_2:92;
      hence thesis by A35,A36,T,EXTPRO_1:6;
    end;
  end;
end;

registration
  let a, b be read-write Int-Location;
  cluster Divide(a, b) -> keeping_0;
  coherence
  proof
    set Ma = Macro (Divide(a,b));
    let s;
    assume
A1: Macro (Divide(a,b)) +* Start-At( 0,SCM+FSA) c= s;
    then
A2: Ma c= s by SCMFSA6B:5;
    let k be Element of NAT;
    dom Start-At( 0,SCM+FSA) = {IC SCM+FSA} by FUNCOP_1:19;
    then
A3: IC SCM+FSA in dom SA0 by TARSKI:def 1;
    SA0 c= Macro (Divide(a,b)) +* Start-At( 0,SCM+FSA) by FUNCT_4:26;
    then SA0 c= s by A1,XBOOLE_1:1;
    then
A4: IC s = SA0.IC SCM+FSA by A3,GRFUNC_1:8
      .=  0 by FUNCOP_1:87;
     0 in dom Ma by SCMFSA6B:32;
    then
A5: Ma. 0 = s. 0 by A2,GRFUNC_1:8;
Y:  (ProgramPart s)/.IC s
 = s.IC s by COMPOS_1:38;
Z:  (ProgramPart Comput(ProgramPart(s),s,1))/.IC Comput(ProgramPart(s),s,1)
 = Comput(ProgramPart(s),s,1).IC Comput(ProgramPart(s),s,1) by COMPOS_1:38;
A6: Comput(ProgramPart(s),s,0+1) = Following(ProgramPart s,
Comput(ProgramPart(s),s,0)) by EXTPRO_1:4
      .= Following(ProgramPart s,s) by EXTPRO_1:3
      .= Exec(Divide(a,b), s) by A4,A5,Y,COMPOS_1:148,SCMFSA6B:33;
     1 in dom Ma by SCMFSA6B:32;
    then Ma. 1 = s. 1 by A2,GRFUNC_1:8;
    then
A7: s. 1 = halt SCM+FSA by COMPOS_1:148,SCMFSA6B:33;
    IC Exec(Divide(a,b), s) = succ  0 by A4,SCMFSA_2:93
      .=  (0+1);
    then
A8: CurInstr(ProgramPart Comput(ProgramPart(s),s,1),Comput(ProgramPart(s),s,1))
 = halt SCM+FSA by A7,A6,Z,AMI_1:def 13;
T: ProgramPart s = ProgramPart Comput(ProgramPart(s),s,1)
by AMI_1:123;
    per cases by NAT_1:14;
    suppose
      k = 0;
      hence thesis by EXTPRO_1:3;
    end;
    suppose
A9:   1 <= k;
      Comput(ProgramPart(s),s,1).intloc 0 = s.intloc 0 by A6,SCMFSA_2:93;
      hence thesis by A8,A9,T,EXTPRO_1:6;
    end;
  end;
end;

registration
  let a be Int-Location, f be FinSeq-Location, b be read-write Int-Location;
  cluster b := (f,a) -> keeping_0;
  coherence
  proof
    set Ma = Macro (b:=(f,a));
    let s;
    assume
A1: Macro (b:=(f,a)) +* Start-At( 0,SCM+FSA) c= s;
    then
A2: Ma c= s by SCMFSA6B:5;
    let k be Element of NAT;
    dom Start-At( 0,SCM+FSA) = {IC SCM+FSA} by FUNCOP_1:19;
    then
A3: IC SCM+FSA in dom SA0 by TARSKI:def 1;
    SA0 c= Macro (b:=(f,a)) +* Start-At( 0,SCM+FSA) by FUNCT_4:26;
    then SA0 c= s by A1,XBOOLE_1:1;
    then
A4: IC s = SA0.IC SCM+FSA by A3,GRFUNC_1:8
      .=  0 by FUNCOP_1:87;
     0 in dom Ma by SCMFSA6B:32;
    then
A5: Ma. 0 = s. 0 by A2,GRFUNC_1:8;
Y:  (ProgramPart s)/.IC s
 = s.IC s by COMPOS_1:38;
Z:  (ProgramPart Comput(ProgramPart(s),s,1))/.IC Comput(ProgramPart(s),s,1)
 = Comput(ProgramPart(s),s,1).IC Comput(ProgramPart(s),s,1) by COMPOS_1:38;
A6: Comput(ProgramPart(s),s,0+1) = Following(ProgramPart s,
Comput(ProgramPart(s),s,0)) by EXTPRO_1:4
      .= Following(ProgramPart s,s) by EXTPRO_1:3
      .= Exec(b:=(f,a), s) by A4,A5,Y,COMPOS_1:148,SCMFSA6B:33;
     1 in dom Ma by SCMFSA6B:32;
    then Ma. 1 = s. 1 by A2,GRFUNC_1:8;
    then
A7: s. 1 = halt SCM+FSA by COMPOS_1:148,SCMFSA6B:33;
    IC Exec(b:=(f,a), s) = succ  0 by A4,SCMFSA_2:98
      .=  (0+1);
    then
A8: CurInstr(ProgramPart Comput(ProgramPart(s),s,1),Comput(ProgramPart(s),s,1))
 = halt SCM+FSA by A7,A6,Z,AMI_1:def 13;
T: ProgramPart s = ProgramPart Comput(ProgramPart(s),s,1)
by AMI_1:123;
    per cases by NAT_1:14;
    suppose
      k = 0;
      hence thesis by EXTPRO_1:3;
    end;
    suppose
A9:   1 <= k;
      Comput(ProgramPart(s),s,1).intloc 0 = s.intloc 0 by A6,SCMFSA_2:98;
      hence thesis by A8,A9,T,EXTPRO_1:6;
    end;
  end;
end;

registration
  let f be FinSeq-Location, b be read-write Int-Location;
  cluster b :=len f -> keeping_0;
  coherence
  proof
    set Ma = Macro (b:=len f);
    let s;
    assume
A1: Macro (b:=len f) +* Start-At( 0,SCM+FSA) c= s;
    then
A2: Ma c= s by SCMFSA6B:5;
    let k be Element of NAT;
    dom Start-At( 0,SCM+FSA) = {IC SCM+FSA} by FUNCOP_1:19;
    then
A3: IC SCM+FSA in dom SA0 by TARSKI:def 1;
    SA0 c= Macro (b:=len f) +* Start-At( 0,SCM+FSA) by FUNCT_4:26;
    then SA0 c= s by A1,XBOOLE_1:1;
    then
A4: IC s = SA0.IC SCM+FSA by A3,GRFUNC_1:8
      .=  0 by FUNCOP_1:87;
     0 in dom Ma by SCMFSA6B:32;
    then
A5: Ma. 0 = s. 0 by A2,GRFUNC_1:8;
Y:  (ProgramPart s)/.IC s
 = s.IC s by COMPOS_1:38;
Z:  (ProgramPart Comput(ProgramPart(s),s,1))/.IC Comput(ProgramPart(s),s,1)
 = Comput(ProgramPart(s),s,1).IC Comput(ProgramPart(s),s,1) by COMPOS_1:38;
A6: Comput(ProgramPart(s),s,0+1) =
Following(ProgramPart s,Comput(ProgramPart(s),s,0))
 by EXTPRO_1:4
      .= Following(ProgramPart s,s) by EXTPRO_1:3
      .= Exec(b:=len f, s) by A4,A5,Y,COMPOS_1:148,SCMFSA6B:33;
     1 in dom Ma by SCMFSA6B:32;
    then Ma. 1 = s. 1 by A2,GRFUNC_1:8;
    then
A7: s. 1 = halt SCM+FSA by COMPOS_1:148,SCMFSA6B:33;
    IC Exec(b:=len f, s) = succ  0 by A4,SCMFSA_2:100
      .=  (0+1);
    then
A8: CurInstr(ProgramPart Comput(ProgramPart(s),s,1),Comput(ProgramPart(s),s,1))
 = halt SCM+FSA by A7,A6,Z,AMI_1:def 13;
T: ProgramPart s = ProgramPart Comput(ProgramPart(s),s,1)
by AMI_1:123;
    per cases by NAT_1:14;
    suppose
      k = 0;
      hence thesis by EXTPRO_1:3;
    end;
    suppose
A9:   1 <= k;
      Comput(ProgramPart(s),s,1).intloc 0 = s.intloc 0 by A6,SCMFSA_2:100;
      hence thesis by A8,A9,T,EXTPRO_1:6;
    end;
  end;
end;

registration
  let i be parahalting Instruction of SCM+FSA, J be parahalting Program of
  SCM+FSA;
  cluster i ';' J -> parahalting;
  coherence;
end;

registration
  let I be parahalting Program of SCM+FSA, j be parahalting Instruction of
  SCM+FSA;
  cluster I ';' j -> parahalting;
  coherence;
end;

registration
  let i be parahalting Instruction of SCM+FSA, j be parahalting Instruction of
  SCM+FSA;
  cluster i ';' j -> parahalting;
  coherence;
end;

registration
  let i be keeping_0 Instruction of SCM+FSA, J be keeping_0 Program of SCM+FSA;
  cluster i ';' J -> keeping_0;
  coherence;
end;

registration
  let I be keeping_0 Program of SCM+FSA, j be keeping_0 Instruction of SCM+FSA;
  cluster I ';' j -> keeping_0;
  coherence;
end;

registration
  let i, j be keeping_0 Instruction of SCM+FSA;
  cluster i ';' j -> keeping_0;
  coherence;
end;

begin :: Consequenses of the main theorem

registration
  let s be State of SCM+FSA;
  cluster Initialized s -> total;
  coherence
  proof
C: dom s = the carrier of SCM+FSA by PARTFUN1:def 4;
   then
A:  intloc 0 in the carrier of SCM+FSA by RELAT_1:def 18;
B:  IC SCM+FSA in dom s by COMPOS_1:9;
   thus dom Initialized s
      = dom s \/ {intloc 0} \/ {IC SCM+FSA} by SCMFSA6A:43
     .= dom s \/ {IC SCM+FSA} by A,C,ZFMISC_1:46
     .= dom s by B,ZFMISC_1:46
     .= the carrier of SCM+FSA by C;
  end;
end;

theorem Th3:
  IC Initialized s =  0 & (Initialized s).intloc 0 = 1 & (for a
  being read-write Int-Location holds (Initialized s).a = s.a) & (for f holds (
  Initialized s).f = s.f) & for l holds (Initialized s).l = s.l
proof
A1: ((intloc 0) .--> 1).intloc 0 = 1 by FUNCOP_1:87;
  dom Start-At( 0,SCM+FSA) = {IC SCM+FSA} by FUNCOP_1:19;
  then
A2: IC SCM+FSA in dom Start-At( 0,SCM+FSA) by TARSKI:def 1;
  (Start-At( 0,SCM+FSA)).IC SCM+FSA =  0 by FUNCOP_1:87;
  hence IC Initialized s =  0 by A2,FUNCT_4:14;
A3: dom ((intloc 0) .--> 1) = {intloc 0} by FUNCOP_1:19;
  then
A4: intloc 0 in dom ((intloc 0) .--> 1) by TARSKI:def 1;
  not intloc 0 in dom Start-At( 0,SCM+FSA) by SCMFSA6B:9;
  hence (Initialized s).intloc 0 = (s+*((intloc 0) .--> 1)).intloc 0 by
FUNCT_4:12
    .= 1 by A4,A1,FUNCT_4:14;
  hereby
    let a be read-write Int-Location;
A5: not a in dom ((intloc 0) .--> 1) by A3,TARSKI:def 1;
    not a in dom Start-At( 0,SCM+FSA) by SCMFSA6B:9;
    hence (Initialized s).a = (s+*((intloc 0) .--> 1)).a by FUNCT_4:12
      .= s.a by A5,FUNCT_4:12;
  end;
  hereby
    let f be FinSeq-Location;
    intloc 0 <> f by SCMFSA_2:83;
    then
A6: not f in dom ((intloc 0) .--> 1) by A3,TARSKI:def 1;
    not f in dom Start-At( 0,SCM+FSA) by SCMFSA6B:10;
    hence (Initialized s).f = (s+*((intloc 0) .--> 1)).f by FUNCT_4:12
      .= s.f by A6,FUNCT_4:12;
  end;
  let l;
  intloc 0 <> l by SCMFSA_2:84;
  then
A7: not l in dom ((intloc 0) .--> 1) by A3,TARSKI:def 1;
  not l in dom Start-At( 0,SCM+FSA) by COMPOS_1:29;
  hence (Initialized s).l = (s+*((intloc 0) .--> 1)).l by FUNCT_4:12
    .= s.l by A7,FUNCT_4:12;
end;

theorem Th4:
  s1, s2 equal_outside NAT iff (s1 | (Int-Locations \/
  FinSeq-Locations \/ {IC SCM+FSA})) = (s2 | (Int-Locations \/ FinSeq-Locations
  \/ {IC SCM+FSA}))
proof
  set Y = NAT;
  set X = Int-Locations \/ FinSeq-Locations \/ {IC SCM+FSA};
A1: (X \/ Y) \ Y \/ Y = X \/ Y \/ Y by XBOOLE_1:39
    .= X \/ (Y \/ Y) by XBOOLE_1:4
    .= Y \/ X;
A2: Y misses (X \/ Y) \ Y by XBOOLE_1:79;
A3: X misses Y
  proof
    assume X meets Y;
    then consider x such that
A4: x in X and
A5: x in Y by XBOOLE_0:3;
A6: x in Int-Locations \/ FinSeq-Locations or x in {IC SCM+FSA} by A4,
XBOOLE_0:def 3;
    per cases by A6,TARSKI:def 1,XBOOLE_0:def 3;
    suppose
      x in Int-Locations;
      hence contradiction by A5,SCMFSA_2:13,XBOOLE_0:3;
    end;
    suppose
      x in FinSeq-Locations;
      hence contradiction by A5,SCMFSA_2:14,XBOOLE_0:3;
    end;
    suppose
A7:   x = IC SCM+FSA;
      reconsider x as Element of NAT by A5;
      x = IC SCM+FSA by A7;
      hence contradiction by COMPOS_1:3;
    end;
  end;
  dom s2 = the carrier of SCM+FSA by PARTFUN1:def 4;
  then
A8: dom s2 \ Y = X by A1,A2,A3,SCMFSA_2:8,XBOOLE_1:72;
  dom s1 = the carrier of SCM+FSA by PARTFUN1:def 4;
  then dom s1 \ Y = X by A1,A2,A3,SCMFSA_2:8,XBOOLE_1:72;
  hence thesis by A8,FUNCT_7:def 2;
end;

theorem Th5:
  DataPart s1 = DataPart s2 implies DataPart Exec (i, s1) =
  DataPart Exec (i, s2)
proof
  assume
A1: DataPart s1 = DataPart s2;
A2: InsCode i <= 9+1 implies InsCode i <= 8+1 or InsCode i = 10 by NAT_1:8;
A3: InsCode i <= 10+1 implies InsCode i <= 10 or InsCode i = 11 by NAT_1:8;
  set l = i;
A4: InsCode i <= 11+1 by SCMFSA_2:35;
A5: dom Exec(l,s1) = the carrier of SCM+FSA by PARTFUN1:def 4;
  then
A6: dom Exec(l,s1) = dom Exec(l,s2) by PARTFUN1:def 4;
A7: dom ((Exec (l,s1)) | (Int-Locations \/ FinSeq-Locations)) = (
  Int-Locations \/ FinSeq-Locations) by A5,RELAT_1:91;
A8: dom Exec(l,s2) = the carrier of SCM+FSA by PARTFUN1:def 4;
  then
A9: dom ((Exec (l,s2)) | (Int-Locations \/ FinSeq-Locations)) = (
  Int-Locations \/ FinSeq-Locations) by RELAT_1:91;
  per cases by A4,A3,A2,NAT_1:8,33;
  suppose
    InsCode i = 0;
    then
A10: i = halt SCM+FSA by SCMFSA_2:122;
    then Exec (i,s1) = s1 by EXTPRO_1:def 3;
    hence thesis by A1,A10,EXTPRO_1:def 3;
  end;
  suppose
    InsCode i = 1;
    then consider db,da being Int-Location such that
A11: l = db := da by SCMFSA_2:54;
A12: for x being set st x in ((Int-Locations \/ FinSeq-Locations) \ {db})
holds (Exec (l,s1) | (Int-Locations \/ FinSeq-Locations \ {db})).x = (Exec (l,
    s2) | (Int-Locations \/ FinSeq-Locations \ {db})).x
    proof
      let x be set;
      assume
A13:  x in ((Int-Locations \/ FinSeq-Locations) \ {db});
      then
A14:  x in Int-Locations \/ FinSeq-Locations by XBOOLE_0:def 5;
A15:  not x in {db} by A13,XBOOLE_0:def 5;
      per cases by A14,XBOOLE_0:def 3;
      suppose
        x in Int-Locations;
        then reconsider a = x as Int-Location by SCMFSA_2:11;
A16:    a <> db by A15,TARSKI:def 1;
        thus (Exec (l,s1) | (Int-Locations \/ FinSeq-Locations \ {db})).x = (
        Exec (l,s1)).a by A13,FUNCT_1:72
          .= s1.a by A11,A16,SCMFSA_2:89
          .= (DataPart s1).a by A14,FUNCT_1:72,SCMFSA_2:127
          .= s2.a by A1,A14,FUNCT_1:72,SCMFSA_2:127
          .= (Exec (l,s2)).a by A11,A16,SCMFSA_2:89
          .= (Exec (l,s2) | (Int-Locations \/ FinSeq-Locations \ {db})).x by
A13,FUNCT_1:72;
      end;
      suppose
        x in FinSeq-Locations;
        then reconsider a = x as FinSeq-Location by SCMFSA_2:12;
        thus (Exec (l,s1) | (Int-Locations \/ FinSeq-Locations \ {db})).x = (
        Exec (l,s1)).a by A13,FUNCT_1:72
          .= s1.a by A11,SCMFSA_2:89
          .= (DataPart s1).a by A14,FUNCT_1:72,SCMFSA_2:127
          .= s2.a by A1,A14,FUNCT_1:72,SCMFSA_2:127
          .= (Exec (l,s2)).a by A11,SCMFSA_2:89
          .= (Exec (l,s2) | (Int-Locations \/ FinSeq-Locations \ {db})).x by
A13,FUNCT_1:72;
      end;
    end;
A17: dom ((Exec (l,s2)) | (Int-Locations \/ FinSeq-Locations \ {db})) = (
    Int-Locations \/ FinSeq-Locations \ {db}) by A8,RELAT_1:91;
    dom ((Exec (l,s1)) | (Int-Locations \/ FinSeq-Locations \ {db})) = (
    Int-Locations \/ FinSeq-Locations \ {db}) by A5,RELAT_1:91;
    then
A18: Exec (l,s1) | (Int-Locations \/ FinSeq-Locations \ {db} ) = Exec (l,
    s2) | (Int-Locations \/ FinSeq-Locations \ {db} ) by A17,A12,FUNCT_1:9;
    db in Int-Locations by SCMFSA_2:9;
    then db in Int-Locations \/ FinSeq-Locations by XBOOLE_0:def 3;
    then
A19: Int-Locations \/ FinSeq-Locations = Int-Locations \/ FinSeq-Locations
    \/ {db} by ZFMISC_1:46
      .= (Int-Locations \/ FinSeq-Locations \ {db} ) \/ {db} by XBOOLE_1:39;
A20: Exec(l, s2).db = s2.da by A11,SCMFSA_2:89;
A21: Exec(l, s1).db = s1.da by A11,SCMFSA_2:89;
    da in Int-Locations by SCMFSA_2:9;
    then
A22: da in Int-Locations \/ FinSeq-Locations by XBOOLE_0:def 3;
    then s1.da = (DataPart s1).da by FUNCT_1:72,SCMFSA_2:127
      .= s2.da by A1,A22,FUNCT_1:72,SCMFSA_2:127;
    then Exec (l,s1) | {db} = Exec(l,s2) | {db} by A6,A21,A20,GRFUNC_1:90;
    hence thesis by A19,A18,RELAT_1:185,SCMFSA_2:127;
  end;
  suppose
    InsCode i = 2;
    then consider db,da being Int-Location such that
A23: l = AddTo(db,da) by SCMFSA_2:55;
A24: for x being set st x in ((Int-Locations \/ FinSeq-Locations) \ {db})
holds (Exec (l,s1) | (Int-Locations \/ FinSeq-Locations \ {db})).x = (Exec (l,
    s2) | (Int-Locations \/ FinSeq-Locations \ {db})).x
    proof
      let x be set;
      assume
A25:  x in ((Int-Locations \/ FinSeq-Locations) \ {db});
      then
A26:  x in Int-Locations \/ FinSeq-Locations by XBOOLE_0:def 5;
A27:  not x in {db} by A25,XBOOLE_0:def 5;
      per cases by A26,XBOOLE_0:def 3;
      suppose
        x in Int-Locations;
        then reconsider a = x as Int-Location by SCMFSA_2:11;
A28:    a <> db by A27,TARSKI:def 1;
        thus (Exec (l,s1) | (Int-Locations \/ FinSeq-Locations \ {db})).x = (
        Exec (l,s1)).a by A25,FUNCT_1:72
          .= s1.a by A23,A28,SCMFSA_2:90
          .= (DataPart s1).a by A26,FUNCT_1:72,SCMFSA_2:127
          .= s2.a by A1,A26,FUNCT_1:72,SCMFSA_2:127
          .= (Exec (l,s2)).a by A23,A28,SCMFSA_2:90
          .= (Exec (l,s2) | (Int-Locations \/ FinSeq-Locations \ {db})).x by
A25,FUNCT_1:72;
      end;
      suppose
        x in FinSeq-Locations;
        then reconsider a = x as FinSeq-Location by SCMFSA_2:12;
        thus (Exec (l,s1) | (Int-Locations \/ FinSeq-Locations \ {db})).x = (
        Exec (l,s1)).a by A25,FUNCT_1:72
          .= s1.a by A23,SCMFSA_2:90
          .= (DataPart s1).a by A26,FUNCT_1:72,SCMFSA_2:127
          .= s2.a by A1,A26,FUNCT_1:72,SCMFSA_2:127
          .= (Exec (l,s2)).a by A23,SCMFSA_2:90
          .= (Exec (l,s2) | (Int-Locations \/ FinSeq-Locations \ {db})).x by
A25,FUNCT_1:72;
      end;
    end;
A29: dom ((Exec (l,s2)) | (Int-Locations \/ FinSeq-Locations \ {db})) = (
    Int-Locations \/ FinSeq-Locations \ {db}) by A8,RELAT_1:91;
    dom ((Exec (l,s1)) | (Int-Locations \/ FinSeq-Locations \ {db})) = (
    Int-Locations \/ FinSeq-Locations \ {db}) by A5,RELAT_1:91;
    then
A30: Exec (l,s1) | (Int-Locations \/ FinSeq-Locations \ {db} ) = Exec (l,
    s2) | (Int-Locations \/ FinSeq-Locations \ {db} ) by A29,A24,FUNCT_1:9;
    db in Int-Locations by SCMFSA_2:9;
    then db in Int-Locations \/ FinSeq-Locations by XBOOLE_0:def 3;
    then
A31: Int-Locations \/ FinSeq-Locations = Int-Locations \/ FinSeq-Locations
    \/ {db} by ZFMISC_1:46
      .= (Int-Locations \/ FinSeq-Locations \ {db} ) \/ {db} by XBOOLE_1:39;
A32: Exec(l, s2).db = s2.db + s2.da by A23,SCMFSA_2:90;
A33: Exec(l, s1).db = s1.db + s1.da by A23,SCMFSA_2:90;
    db in Int-Locations by SCMFSA_2:9;
    then
A34: db in Int-Locations \/ FinSeq-Locations by XBOOLE_0:def 3;
    then
A35: s1.db = (DataPart s1).db by FUNCT_1:72,SCMFSA_2:127
      .= s2.db by A1,A34,FUNCT_1:72,SCMFSA_2:127;
    da in Int-Locations by SCMFSA_2:9;
    then
A36: da in Int-Locations \/ FinSeq-Locations by XBOOLE_0:def 3;
    then s1.da = (DataPart s1).da by FUNCT_1:72,SCMFSA_2:127
      .= s2.da by A1,A36,FUNCT_1:72,SCMFSA_2:127;
    then Exec (l,s1) | {db} = Exec(l,s2) | {db} by A6,A33,A32,A35,GRFUNC_1:90;
    hence thesis by A31,A30,RELAT_1:185,SCMFSA_2:127;
  end;
  suppose
    InsCode i = 3;
    then consider db,da being Int-Location such that
A37: l = SubFrom(db,da) by SCMFSA_2:56;
A38: for x being set st x in ((Int-Locations \/ FinSeq-Locations) \ {db})
holds (Exec (l,s1) | (Int-Locations \/ FinSeq-Locations \ {db})).x = (Exec (l,
    s2) | (Int-Locations \/ FinSeq-Locations \ {db})).x
    proof
      let x be set;
      assume
A39:  x in ((Int-Locations \/ FinSeq-Locations) \ {db});
      then
A40:  x in Int-Locations \/ FinSeq-Locations by XBOOLE_0:def 5;
A41:  not x in {db} by A39,XBOOLE_0:def 5;
      per cases by A40,XBOOLE_0:def 3;
      suppose
        x in Int-Locations;
        then reconsider a = x as Int-Location by SCMFSA_2:11;
A42:    a <> db by A41,TARSKI:def 1;
        thus (Exec (l,s1) | (Int-Locations \/ FinSeq-Locations \ {db})).x = (
        Exec (l,s1)).a by A39,FUNCT_1:72
          .= s1.a by A37,A42,SCMFSA_2:91
          .= (DataPart s1).a by A40,FUNCT_1:72,SCMFSA_2:127
          .= s2.a by A1,A40,FUNCT_1:72,SCMFSA_2:127
          .= (Exec (l,s2)).a by A37,A42,SCMFSA_2:91
          .= (Exec (l,s2) | (Int-Locations \/ FinSeq-Locations \ {db})).x by
A39,FUNCT_1:72;
      end;
      suppose
        x in FinSeq-Locations;
        then reconsider a = x as FinSeq-Location by SCMFSA_2:12;
        thus (Exec (l,s1) | (Int-Locations \/ FinSeq-Locations \ {db})).x = (
        Exec (l,s1)).a by A39,FUNCT_1:72
          .= s1.a by A37,SCMFSA_2:91
          .= (DataPart s1).a by A40,FUNCT_1:72,SCMFSA_2:127
          .= s2.a by A1,A40,FUNCT_1:72,SCMFSA_2:127
          .= (Exec (l,s2)).a by A37,SCMFSA_2:91
          .= (Exec (l,s2) | (Int-Locations \/ FinSeq-Locations \ {db})).x by
A39,FUNCT_1:72;
      end;
    end;
A43: dom ((Exec (l,s2)) | (Int-Locations \/ FinSeq-Locations \ {db})) = (
    Int-Locations \/ FinSeq-Locations \ {db}) by A8,RELAT_1:91;
    dom ((Exec (l,s1)) | (Int-Locations \/ FinSeq-Locations \ {db})) = (
    Int-Locations \/ FinSeq-Locations \ {db}) by A5,RELAT_1:91;
    then
A44: Exec (l,s1) | (Int-Locations \/ FinSeq-Locations \ {db} ) = Exec (l,
    s2) | (Int-Locations \/ FinSeq-Locations \ {db} ) by A43,A38,FUNCT_1:9;
    db in Int-Locations by SCMFSA_2:9;
    then db in Int-Locations \/ FinSeq-Locations by XBOOLE_0:def 3;
    then
A45: Int-Locations \/ FinSeq-Locations = Int-Locations \/ FinSeq-Locations
    \/ {db} by ZFMISC_1:46
      .= (Int-Locations \/ FinSeq-Locations \ {db} ) \/ {db} by XBOOLE_1:39;
A46: Exec(l, s2).db = s2.db - s2.da by A37,SCMFSA_2:91;
A47: Exec(l, s1).db = s1.db - s1.da by A37,SCMFSA_2:91;
    db in Int-Locations by SCMFSA_2:9;
    then
A48: db in Int-Locations \/ FinSeq-Locations by XBOOLE_0:def 3;
    then
A49: s1.db = (DataPart s1).db by FUNCT_1:72,SCMFSA_2:127
      .= s2.db by A1,A48,FUNCT_1:72,SCMFSA_2:127;
    da in Int-Locations by SCMFSA_2:9;
    then
A50: da in Int-Locations \/ FinSeq-Locations by XBOOLE_0:def 3;
    then s1.da = (DataPart s1).da by FUNCT_1:72,SCMFSA_2:127
      .= s2.da by A1,A50,FUNCT_1:72,SCMFSA_2:127;
    then Exec (l,s1) | {db} = Exec(l,s2) | {db} by A6,A47,A46,A49,GRFUNC_1:90;
    hence thesis by A45,A44,RELAT_1:185,SCMFSA_2:127;
  end;
  suppose
    InsCode i = 4;
    then consider db,da being Int-Location such that
A51: l = MultBy(db,da) by SCMFSA_2:57;
A52: for x being set st x in ((Int-Locations \/ FinSeq-Locations) \ {db})
holds (Exec (l,s1) | (Int-Locations \/ FinSeq-Locations \ {db})).x = (Exec (l,
    s2) | (Int-Locations \/ FinSeq-Locations \ {db})).x
    proof
      let x be set;
      assume
A53:  x in ((Int-Locations \/ FinSeq-Locations) \ {db});
      then
A54:  x in Int-Locations \/ FinSeq-Locations by XBOOLE_0:def 5;
A55:  not x in {db} by A53,XBOOLE_0:def 5;
      per cases by A54,XBOOLE_0:def 3;
      suppose
        x in Int-Locations;
        then reconsider a = x as Int-Location by SCMFSA_2:11;
A56:    a <> db by A55,TARSKI:def 1;
        thus (Exec (l,s1) | (Int-Locations \/ FinSeq-Locations \ {db})).x = (
        Exec (l,s1)).a by A53,FUNCT_1:72
          .= s1.a by A51,A56,SCMFSA_2:92
          .= (DataPart s1).a by A54,FUNCT_1:72,SCMFSA_2:127
          .= s2.a by A1,A54,FUNCT_1:72,SCMFSA_2:127
          .= (Exec (l,s2)).a by A51,A56,SCMFSA_2:92
          .= (Exec (l,s2) | (Int-Locations \/ FinSeq-Locations \ {db})).x by
A53,FUNCT_1:72;
      end;
      suppose
        x in FinSeq-Locations;
        then reconsider a = x as FinSeq-Location by SCMFSA_2:12;
        thus (Exec (l,s1) | (Int-Locations \/ FinSeq-Locations \ {db})).x = (
        Exec (l,s1)).a by A53,FUNCT_1:72
          .= s1.a by A51,SCMFSA_2:92
          .= (DataPart s1).a by A54,FUNCT_1:72,SCMFSA_2:127
          .= s2.a by A1,A54,FUNCT_1:72,SCMFSA_2:127
          .= (Exec (l,s2)).a by A51,SCMFSA_2:92
          .= (Exec (l,s2) | (Int-Locations \/ FinSeq-Locations \ {db})).x by
A53,FUNCT_1:72;
      end;
    end;
A57: dom ((Exec (l,s2)) | (Int-Locations \/ FinSeq-Locations \ {db})) = (
    Int-Locations \/ FinSeq-Locations \ {db}) by A8,RELAT_1:91;
    dom ((Exec (l,s1)) | (Int-Locations \/ FinSeq-Locations \ {db})) = (
    Int-Locations \/ FinSeq-Locations \ {db}) by A5,RELAT_1:91;
    then
A58: Exec (l,s1) | (Int-Locations \/ FinSeq-Locations \ {db} ) = Exec (l,
    s2) | (Int-Locations \/ FinSeq-Locations \ {db} ) by A57,A52,FUNCT_1:9;
    db in Int-Locations by SCMFSA_2:9;
    then db in Int-Locations \/ FinSeq-Locations by XBOOLE_0:def 3;
    then
A59: Int-Locations \/ FinSeq-Locations = Int-Locations \/ FinSeq-Locations
    \/ {db} by ZFMISC_1:46
      .= (Int-Locations \/ FinSeq-Locations \ {db} ) \/ {db} by XBOOLE_1:39;
A60: Exec(l, s2).db = s2.db * s2.da by A51,SCMFSA_2:92;
A61: Exec(l, s1).db = s1.db * s1.da by A51,SCMFSA_2:92;
    db in Int-Locations by SCMFSA_2:9;
    then
A62: db in Int-Locations \/ FinSeq-Locations by XBOOLE_0:def 3;
    then
A63: s1.db = (DataPart s1).db by FUNCT_1:72,SCMFSA_2:127
      .= s2.db by A1,A62,FUNCT_1:72,SCMFSA_2:127;
    da in Int-Locations by SCMFSA_2:9;
    then
A64: da in Int-Locations \/ FinSeq-Locations by XBOOLE_0:def 3;
    then s1.da = (DataPart s1).da by FUNCT_1:72,SCMFSA_2:127
      .= s2.da by A1,A64,FUNCT_1:72,SCMFSA_2:127;
    then Exec (l,s1) | {db} = Exec(l,s2) | {db} by A6,A61,A60,A63,GRFUNC_1:90;
    hence thesis by A59,A58,RELAT_1:185,SCMFSA_2:127;
  end;
  suppose
    InsCode i = 5;
    then consider db,da being Int-Location such that
A65: l = Divide(db,da) by SCMFSA_2:58;
    hereby
      per cases;
      suppose
A66:    da <> db;
A67:    for x being set st x in ((Int-Locations \/ FinSeq-Locations) \ {
db,da} ) holds (Exec (l,s1) | (Int-Locations \/ FinSeq-Locations \ {db,da})).x
        = (Exec (l,s2) | (Int-Locations \/ FinSeq-Locations \ {db,da})).x
        proof
          let x be set;
          assume
A68:      x in ((Int-Locations \/ FinSeq-Locations) \ {db,da});
          then
A69:      x in Int-Locations \/ FinSeq-Locations by XBOOLE_0:def 5;
A70:      not x in {db,da} by A68,XBOOLE_0:def 5;
          per cases by A69,XBOOLE_0:def 3;
          suppose
            x in Int-Locations;
            then reconsider a = x as Int-Location by SCMFSA_2:11;
A71:        a <> da by A70,TARSKI:def 2;
A72:        a <> db by A70,TARSKI:def 2;
            thus (Exec (l,s1) | (Int-Locations \/ FinSeq-Locations \ {db,da}))
            .x = (Exec (l,s1)).a by A68,FUNCT_1:72
              .= s1.a by A65,A71,A72,SCMFSA_2:93
              .= (DataPart s1).a by A69,FUNCT_1:72,SCMFSA_2:127
              .= s2.a by A1,A69,FUNCT_1:72,SCMFSA_2:127
              .= (Exec (l,s2)).a by A65,A71,A72,SCMFSA_2:93
              .= (Exec (l,s2) | (Int-Locations \/ FinSeq-Locations \ {db,da}
            )).x by A68,FUNCT_1:72;
          end;
          suppose
            x in FinSeq-Locations;
            then reconsider a = x as FinSeq-Location by SCMFSA_2:12;
            thus (Exec (l,s1) | (Int-Locations \/ FinSeq-Locations \ {db,da}))
            .x = (Exec (l,s1)).a by A68,FUNCT_1:72
              .= s1.a by A65,SCMFSA_2:93
              .= (DataPart s1).a by A69,FUNCT_1:72,SCMFSA_2:127
              .= s2.a by A1,A69,FUNCT_1:72,SCMFSA_2:127
              .= (Exec (l,s2)).a by A65,SCMFSA_2:93
              .= (Exec (l,s2) | (Int-Locations \/ FinSeq-Locations \ {db,da}
            )).x by A68,FUNCT_1:72;
          end;
        end;
A73:    dom ((Exec (l,s2)) | (Int-Locations \/ FinSeq-Locations \ {db,da
        })) = (Int-Locations \/ FinSeq-Locations \ {db,da}) by A8,RELAT_1:91;
        dom ((Exec (l,s1)) | (Int-Locations \/ FinSeq-Locations \ {db,da
        })) = (Int-Locations \/ FinSeq-Locations \ {db,da}) by A5,RELAT_1:91;
        then
A74:    Exec (l,s1) | (Int-Locations \/ FinSeq-Locations \ {db,da} ) =
Exec (l,s2) | (Int-Locations \/ FinSeq-Locations \ {db,da} ) by A73,A67,
FUNCT_1:9;
A75:    Exec(l, s2).da = s2.db mod s2.da by A65,SCMFSA_2:93;
        db in Int-Locations by SCMFSA_2:9;
        then
A76:    db in Int-Locations \/ FinSeq-Locations by XBOOLE_0:def 3;
        then
A77:    s1.db = (DataPart s1).db by FUNCT_1:72,SCMFSA_2:127
          .= s2.db by A1,A76,FUNCT_1:72,SCMFSA_2:127;
        da in Int-Locations by SCMFSA_2:9;
        then
A78:    da in Int-Locations \/ FinSeq-Locations by XBOOLE_0:def 3;
        db in Int-Locations by SCMFSA_2:9;
        then db in Int-Locations \/ FinSeq-Locations by XBOOLE_0:def 3;
        then
A79:    Int-Locations \/ FinSeq-Locations = Int-Locations \/
        FinSeq-Locations \/ {db,da} by A78,ZFMISC_1:48
          .= (Int-Locations \/ FinSeq-Locations \ {db,da} ) \/ {db,da} by
XBOOLE_1:39;
A80:    Exec(l, s1).da = s1.db mod s1.da by A65,SCMFSA_2:93;
A81:    Exec(l, s2).db = s2.db div s2.da by A65,A66,SCMFSA_2:93;
A82:    Exec(l, s1).db = s1.db div s1.da by A65,A66,SCMFSA_2:93;
        da in Int-Locations by SCMFSA_2:9;
        then
A83:    da in Int-Locations \/ FinSeq-Locations by XBOOLE_0:def 3;
        then s1.da = (DataPart s1).da by FUNCT_1:72,SCMFSA_2:127
          .= s2.da by A1,A83,FUNCT_1:72,SCMFSA_2:127;
        then Exec (l,s1) | {db,da} = Exec(l,s2) | {db,da} by A6,A82,A80,A81,A75
,A77,GRFUNC_1:91;
        hence thesis by A79,A74,RELAT_1:185,SCMFSA_2:127;
      end;
      suppose
A84:    da = db;
A85:    for x being set st x in ((Int-Locations \/ FinSeq-Locations) \ {
db}) holds (Exec (l,s1) | (Int-Locations \/ FinSeq-Locations \ {db})).x = (Exec
        (l,s2) | (Int-Locations \/ FinSeq-Locations \ {db})).x
        proof
          let x be set;
          assume
A86:      x in ((Int-Locations \/ FinSeq-Locations) \ {db});
          then
A87:      x in Int-Locations \/ FinSeq-Locations by XBOOLE_0:def 5;
A88:      not x in {db} by A86,XBOOLE_0:def 5;
          per cases by A87,XBOOLE_0:def 3;
          suppose
            x in Int-Locations;
            then reconsider a = x as Int-Location by SCMFSA_2:11;
A89:        a <> db by A88,TARSKI:def 1;
            thus (Exec (l,s1) | (Int-Locations \/ FinSeq-Locations \ {db})).x
            = (Exec (l,s1)).a by A86,FUNCT_1:72
              .= s1.a by A65,A84,A89,SCMFSA_2:94
              .= (DataPart s1).a by A87,FUNCT_1:72,SCMFSA_2:127
              .= s2.a by A1,A87,FUNCT_1:72,SCMFSA_2:127
              .= (Exec (l,s2)).a by A65,A84,A89,SCMFSA_2:94
              .= (Exec (l,s2) | (Int-Locations \/ FinSeq-Locations \ {db})).
            x by A86,FUNCT_1:72;
          end;
          suppose
            x in FinSeq-Locations;
            then reconsider a = x as FinSeq-Location by SCMFSA_2:12;
            thus (Exec (l,s1) | (Int-Locations \/ FinSeq-Locations \ {db})).x
            = (Exec (l,s1)).a by A86,FUNCT_1:72
              .= s1.a by A65,A84,SCMFSA_2:94
              .= (s1 | (Int-Locations \/ FinSeq-Locations)).a by A87,FUNCT_1:72
              .= s2.a by A1,A87,FUNCT_1:72,SCMFSA_2:127
              .= (Exec (l,s2)).a by A65,A84,SCMFSA_2:94
              .= (Exec (l,s2) | (Int-Locations \/ FinSeq-Locations \ {db})).
            x by A86,FUNCT_1:72;
          end;
        end;
A90:    dom ((Exec (l,s2)) | (Int-Locations \/ FinSeq-Locations \ {db}))
        = (Int-Locations \/ FinSeq-Locations \ {db}) by A8,RELAT_1:91;
        dom ((Exec (l,s1)) | (Int-Locations \/ FinSeq-Locations \ {db}))
        = (Int-Locations \/ FinSeq-Locations \ {db}) by A5,RELAT_1:91;
        then
A91:    Exec (l,s1) | (Int-Locations \/ FinSeq-Locations \ {db} ) = Exec
(l,s2) | (Int-Locations \/ FinSeq-Locations \ {db} ) by A90,A85,FUNCT_1:9;
        db in Int-Locations by SCMFSA_2:9;
        then db in Int-Locations \/ FinSeq-Locations by XBOOLE_0:def 3;
        then
A92:    Int-Locations \/ FinSeq-Locations = Int-Locations \/
        FinSeq-Locations \/ {db} by ZFMISC_1:46
          .= (Int-Locations \/ FinSeq-Locations \ {db} ) \/ {db} by XBOOLE_1:39
;
A93:    Exec(l, s2).db = s2.db mod s2.da by A65,A84,SCMFSA_2:94;
A94:    Exec(l, s1).db = s1.db mod s1.da by A65,A84,SCMFSA_2:94;
        db in Int-Locations by SCMFSA_2:9;
        then
A95:    db in Int-Locations \/ FinSeq-Locations by XBOOLE_0:def 3;
        then
A96:    s1.db = (DataPart s1).db by FUNCT_1:72,SCMFSA_2:127
          .= s2.db by A1,A95,FUNCT_1:72,SCMFSA_2:127;
        da in Int-Locations by SCMFSA_2:9;
        then
A97:    da in Int-Locations \/ FinSeq-Locations by XBOOLE_0:def 3;
        then s1.da = (DataPart s1).da by FUNCT_1:72,SCMFSA_2:127
          .= s2.da by A1,A97,FUNCT_1:72,SCMFSA_2:127;
        then Exec (l,s1) | {db} = Exec(l,s2) | {db} by A6,A94,A93,A96,
GRFUNC_1:90;
        hence thesis by A92,A91,RELAT_1:185,SCMFSA_2:127;
      end;
    end;
  end;
  suppose
    InsCode i = 6;
    then
A98: ex l1 st i = goto l1 by SCMFSA_2:59;
    for x being set st x in ((Int-Locations \/ FinSeq-Locations)) holds
    (DataPart Exec (l,s1)).x = (DataPart Exec (l,s2)).x
    proof
      let x be set;
      assume
A99:  x in ((Int-Locations \/ FinSeq-Locations));
      per cases by A99,XBOOLE_0:def 3;
      suppose
        x in Int-Locations;
        then reconsider a = x as Int-Location by SCMFSA_2:11;
        thus (DataPart Exec (l,s1)).x = (Exec (l,s1)).a by A99,FUNCT_1:72
,SCMFSA_2:127
          .= s1.a by A98,SCMFSA_2:95
          .= (DataPart s1).a by A99,FUNCT_1:72,SCMFSA_2:127
          .= s2.a by A1,A99,FUNCT_1:72,SCMFSA_2:127
          .= (Exec (l,s2)).a by A98,SCMFSA_2:95
          .= (DataPart Exec (l,s2)).x by A99,FUNCT_1:72,SCMFSA_2:127;
      end;
      suppose
        x in FinSeq-Locations;
        then reconsider a = x as FinSeq-Location by SCMFSA_2:12;
        thus (DataPart Exec (l,s1)).x = (Exec (l,s1)).a by A99,FUNCT_1:72
,SCMFSA_2:127
          .= s1.a by A98,SCMFSA_2:95
          .= (DataPart s1).a by A99,FUNCT_1:72,SCMFSA_2:127
          .= s2.a by A1,A99,FUNCT_1:72,SCMFSA_2:127
          .= (Exec (l,s2)).a by A98,SCMFSA_2:95
          .= (DataPart Exec (l,s2)).x by A99,FUNCT_1:72,SCMFSA_2:127;
      end;
    end;
    hence thesis by A7,A9,FUNCT_1:9,SCMFSA_2:127;
  end;
  suppose
    InsCode i = 7;
    then
A100: ex l1, a st i = a=0_goto l1 by SCMFSA_2:60;
    for x being set st x in ((Int-Locations \/ FinSeq-Locations)) holds
    (DataPart Exec (l,s1)).x = (DataPart Exec (l,s2)).x
    proof
      let x be set;
      assume
A101: x in ((Int-Locations \/ FinSeq-Locations));
      per cases by A101,XBOOLE_0:def 3;
      suppose
        x in Int-Locations;
        then reconsider a = x as Int-Location by SCMFSA_2:11;
        thus (DataPart Exec (l,s1)).x = (Exec (l,s1)).a by A101,FUNCT_1:72
,SCMFSA_2:127
          .= s1.a by A100,SCMFSA_2:96
          .= (DataPart s1).a by A101,FUNCT_1:72,SCMFSA_2:127
          .= s2.a by A1,A101,FUNCT_1:72,SCMFSA_2:127
          .= (Exec (l,s2)).a by A100,SCMFSA_2:96
          .= (DataPart Exec (l,s2)).x by A101,FUNCT_1:72,SCMFSA_2:127;
      end;
      suppose
        x in FinSeq-Locations;
        then reconsider a = x as FinSeq-Location by SCMFSA_2:12;
        thus (DataPart Exec (l,s1)).x = (Exec (l,s1)).a by A101,FUNCT_1:72
,SCMFSA_2:127
          .= s1.a by A100,SCMFSA_2:96
          .= (DataPart s1).a by A101,FUNCT_1:72,SCMFSA_2:127
          .= s2.a by A1,A101,FUNCT_1:72,SCMFSA_2:127
          .= (Exec (l,s2)).a by A100,SCMFSA_2:96
          .= (DataPart Exec (l,s2)).x by A101,FUNCT_1:72,SCMFSA_2:127;
      end;
    end;
    hence thesis by A7,A9,FUNCT_1:9,SCMFSA_2:127;
  end;
  suppose
    InsCode i = 8;
    then
A102: ex l1, a st i = a>0_goto l1 by SCMFSA_2:61;
    for x being set st x in ((Int-Locations \/ FinSeq-Locations)) holds
    (DataPart Exec (l,s1)).x = (DataPart Exec (l,s2)).x
    proof
      let x be set;
      assume
A103: x in ((Int-Locations \/ FinSeq-Locations));
      per cases by A103,XBOOLE_0:def 3;
      suppose
        x in Int-Locations;
        then reconsider a = x as Int-Location by SCMFSA_2:11;
        thus (DataPart Exec (l,s1)).x = (Exec (l,s1)).a by A103,FUNCT_1:72
,SCMFSA_2:127
          .= s1.a by A102,SCMFSA_2:97
          .= (DataPart s1).a by A103,FUNCT_1:72,SCMFSA_2:127
          .= s2.a by A1,A103,FUNCT_1:72,SCMFSA_2:127
          .= (Exec (l,s2)).a by A102,SCMFSA_2:97
          .= (DataPart Exec (l,s2)).x by A103,FUNCT_1:72,SCMFSA_2:127;
      end;
      suppose
        x in FinSeq-Locations;
        then reconsider a = x as FinSeq-Location by SCMFSA_2:12;
        thus (DataPart Exec (l,s1)).x = (Exec (l,s1)).a by A103,FUNCT_1:72
,SCMFSA_2:127
          .= s1.a by A102,SCMFSA_2:97
          .= (DataPart s1).a by A103,FUNCT_1:72,SCMFSA_2:127
          .= s2.a by A1,A103,FUNCT_1:72,SCMFSA_2:127
          .= (Exec (l,s2)).a by A102,SCMFSA_2:97
          .= (DataPart Exec (l,s2)).x by A103,FUNCT_1:72,SCMFSA_2:127;
      end;
    end;
    hence thesis by A7,A9,FUNCT_1:9,SCMFSA_2:127;
  end;
  suppose
    InsCode i = 9;
    then consider da,db being Int-Location, fa being FinSeq-Location such that
A104: l = db:=(fa,da) by SCMFSA_2:62;
A105: for x being set st x in ((Int-Locations \/ FinSeq-Locations) \ {db})
holds (Exec (l,s1) | (Int-Locations \/ FinSeq-Locations \ {db})).x = (Exec (l,
    s2) | (Int-Locations \/ FinSeq-Locations \ {db})).x
    proof
      let x be set;
      assume
A106: x in ((Int-Locations \/ FinSeq-Locations) \ {db});
      then
A107: x in Int-Locations \/ FinSeq-Locations by XBOOLE_0:def 5;
A108: not x in {db} by A106,XBOOLE_0:def 5;
      per cases by A107,XBOOLE_0:def 3;
      suppose
        x in Int-Locations;
        then reconsider a = x as Int-Location by SCMFSA_2:11;
A109:   a <> db by A108,TARSKI:def 1;
        thus (Exec (l,s1) | (Int-Locations \/ FinSeq-Locations \ {db})).x = (
        Exec (l,s1)).a by A106,FUNCT_1:72
          .= s1.a by A104,A109,SCMFSA_2:98
          .= (DataPart s1).a by A107,FUNCT_1:72,SCMFSA_2:127
          .= s2.a by A1,A107,FUNCT_1:72,SCMFSA_2:127
          .= (Exec (l,s2)).a by A104,A109,SCMFSA_2:98
          .= (Exec (l,s2) | (Int-Locations \/ FinSeq-Locations \ {db})).x by
A106,FUNCT_1:72;
      end;
      suppose
        x in FinSeq-Locations;
        then reconsider a = x as FinSeq-Location by SCMFSA_2:12;
        thus (Exec (l,s1) | (Int-Locations \/ FinSeq-Locations \ {db})).x = (
        Exec (l,s1)).a by A106,FUNCT_1:72
          .= s1.a by A104,SCMFSA_2:98
          .= (DataPart s1).a by A107,FUNCT_1:72,SCMFSA_2:127
          .= s2.a by A1,A107,FUNCT_1:72,SCMFSA_2:127
          .= (Exec (l,s2)).a by A104,SCMFSA_2:98
          .= (Exec (l,s2) | (Int-Locations \/ FinSeq-Locations \ {db})).x by
A106,FUNCT_1:72;
      end;
    end;
A110: dom ((Exec (l,s2)) | (Int-Locations \/ FinSeq-Locations \ {db})) = (
    Int-Locations \/ FinSeq-Locations \ {db}) by A8,RELAT_1:91;
    dom ((Exec (l,s1)) | (Int-Locations \/ FinSeq-Locations \ {db})) = (
    Int-Locations \/ FinSeq-Locations \ {db}) by A5,RELAT_1:91;
    then
A111: Exec (l,s1) | (Int-Locations \/ FinSeq-Locations \ {db} ) = Exec (l,
    s2) | (Int-Locations \/ FinSeq-Locations \ {db} ) by A110,A105,FUNCT_1:9;
    db in Int-Locations by SCMFSA_2:9;
    then db in Int-Locations \/ FinSeq-Locations by XBOOLE_0:def 3;
    then
A112: Int-Locations \/ FinSeq-Locations = Int-Locations \/
    FinSeq-Locations \/ {db} by ZFMISC_1:46
      .= (Int-Locations \/ FinSeq-Locations \ {db} ) \/ {db} by XBOOLE_1:39;
A113: ex k2 being Element of NAT st k2 = abs(s2.da) & Exec(l, s2).db = (
    s2.fa)/.k2 by A104,SCMFSA_2:98;
A114: ex k1 being Element of NAT st k1 = abs(s1.da) & Exec(l, s1).db = (
    s1.fa)/.k1 by A104,SCMFSA_2:98;
    fa in FinSeq-Locations by SCMFSA_2:10;
    then
A115: fa in Int-Locations \/ FinSeq-Locations by XBOOLE_0:def 3;
    then
A116: s1.fa = (DataPart s1).fa by FUNCT_1:72,SCMFSA_2:127
      .= s2.fa by A1,A115,FUNCT_1:72,SCMFSA_2:127;
    da in Int-Locations by SCMFSA_2:9;
    then
A117: da in Int-Locations \/ FinSeq-Locations by XBOOLE_0:def 3;
    then s1.da = (DataPart s1).da by FUNCT_1:72,SCMFSA_2:127
      .= s2.da by A1,A117,FUNCT_1:72,SCMFSA_2:127;
    then Exec (l,s1) | {db} = Exec(l,s2) | {db} by A6,A114,A113,A116,
GRFUNC_1:90;
    hence thesis by A112,A111,RELAT_1:185,SCMFSA_2:127;
  end;
  suppose
    InsCode i = 10;
    then consider da,db being Int-Location, fa being FinSeq-Location such that
A118: l = (fa,da):=db by SCMFSA_2:63;
A119: for x being set st x in ((Int-Locations \/ FinSeq-Locations) \ {fa})
holds (Exec (l,s1) | (Int-Locations \/ FinSeq-Locations \ {fa})).x = (Exec (l,
    s2) | (Int-Locations \/ FinSeq-Locations \ {fa})).x
    proof
      let x be set;
      assume
A120: x in ((Int-Locations \/ FinSeq-Locations) \ {fa});
      then
A121: x in Int-Locations \/ FinSeq-Locations by XBOOLE_0:def 5;
A122: not x in {fa} by A120,XBOOLE_0:def 5;
      per cases by A121,XBOOLE_0:def 3;
      suppose
        x in Int-Locations;
        then reconsider a = x as Int-Location by SCMFSA_2:11;
        thus (Exec (l,s1) | (Int-Locations \/ FinSeq-Locations \ {fa})).x = (
        Exec (l,s1)).a by A120,FUNCT_1:72
          .= s1.a by A118,SCMFSA_2:99
          .= (DataPart s1).a by A121,FUNCT_1:72,SCMFSA_2:127
          .= s2.a by A1,A121,FUNCT_1:72,SCMFSA_2:127
          .= (Exec (l,s2)).a by A118,SCMFSA_2:99
          .= (Exec (l,s2) | (Int-Locations \/ FinSeq-Locations \ {fa})).x by
A120,FUNCT_1:72;
      end;
      suppose
        x in FinSeq-Locations;
        then reconsider a = x as FinSeq-Location by SCMFSA_2:12;
A123:   a <> fa by A122,TARSKI:def 1;
        thus (Exec (l,s1) | (Int-Locations \/ FinSeq-Locations \ {fa})).x = (
        Exec (l,s1)).a by A120,FUNCT_1:72
          .= s1.a by A118,A123,SCMFSA_2:99
          .= (DataPart s1).a by A121,FUNCT_1:72,SCMFSA_2:127
          .= s2.a by A1,A121,FUNCT_1:72,SCMFSA_2:127
          .= (Exec (l,s2)).a by A118,A123,SCMFSA_2:99
          .= (Exec (l,s2) | (Int-Locations \/ FinSeq-Locations \ {fa})).x by
A120,FUNCT_1:72;
      end;
    end;
A124: dom ((Exec (l,s2)) | (Int-Locations \/ FinSeq-Locations \ {fa})) = (
    Int-Locations \/ FinSeq-Locations \ {fa}) by A8,RELAT_1:91;
    dom ((Exec (l,s1)) | (Int-Locations \/ FinSeq-Locations \ {fa})) = (
    Int-Locations \/ FinSeq-Locations \ {fa}) by A5,RELAT_1:91;
    then
A125: Exec (l,s1) | (Int-Locations \/ FinSeq-Locations \ {fa} ) = Exec (l,
    s2) | (Int-Locations \/ FinSeq-Locations \ {fa} ) by A124,A119,FUNCT_1:9;
    fa in FinSeq-Locations by SCMFSA_2:10;
    then fa in Int-Locations \/ FinSeq-Locations by XBOOLE_0:def 3;
    then
A126: Int-Locations \/ FinSeq-Locations = Int-Locations \/
    FinSeq-Locations \/ {fa} by ZFMISC_1:46
      .= (Int-Locations \/ FinSeq-Locations \ {fa} ) \/ {fa} by XBOOLE_1:39;
    fa in FinSeq-Locations by SCMFSA_2:10;
    then
A127: fa in Int-Locations \/ FinSeq-Locations by XBOOLE_0:def 3;
    then
A128: s1.fa = (DataPart s1).fa by FUNCT_1:72,SCMFSA_2:127
      .= s2.fa by A1,A127,FUNCT_1:72,SCMFSA_2:127;
    db in Int-Locations by SCMFSA_2:9;
    then
A129: db in Int-Locations \/ FinSeq-Locations by XBOOLE_0:def 3;
    then
A130: s1.db = (DataPart s1).db by FUNCT_1:72,SCMFSA_2:127
      .= s2.db by A1,A129,FUNCT_1:72,SCMFSA_2:127;
A131: ex k2 being Element of NAT st k2 = abs(s2.da) & Exec(l, s2).fa =
    s2.fa+*(k2,s2.db) by A118,SCMFSA_2:99;
A132: ex k1 being Element of NAT st k1 = abs(s1.da) & Exec(l, s1).fa =
    s1.fa+*(k1,s1.db) by A118,SCMFSA_2:99;
    da in Int-Locations by SCMFSA_2:9;
    then
A133: da in Int-Locations \/ FinSeq-Locations by XBOOLE_0:def 3;
    then s1.da = (DataPart s1).da by FUNCT_1:72,SCMFSA_2:127
      .= s2.da by A1,A133,FUNCT_1:72,SCMFSA_2:127;
    then Exec (l,s1) | {fa} = Exec(l,s2) | {fa} by A6,A132,A131,A130,A128,
GRFUNC_1:90;
    hence thesis by A126,A125,RELAT_1:185,SCMFSA_2:127;
  end;
  suppose
    InsCode i = 11;
    then consider da being Int-Location, fa being FinSeq-Location such that
A134: l = da:=len fa by SCMFSA_2:64;
A135: for x being set st x in ((Int-Locations \/ FinSeq-Locations) \ {da})
holds (Exec (l,s1) | (Int-Locations \/ FinSeq-Locations \ {da})).x = (Exec (l,
    s2) | (Int-Locations \/ FinSeq-Locations \ {da})).x
    proof
      let x be set;
      assume
A136: x in ((Int-Locations \/ FinSeq-Locations) \ {da});
      then
A137: x in Int-Locations \/ FinSeq-Locations by XBOOLE_0:def 5;
A138: not x in {da} by A136,XBOOLE_0:def 5;
      per cases by A137,XBOOLE_0:def 3;
      suppose
        x in Int-Locations;
        then reconsider a = x as Int-Location by SCMFSA_2:11;
A139:   a <> da by A138,TARSKI:def 1;
        thus (Exec (l,s1) | (Int-Locations \/ FinSeq-Locations \ {da})).x = (
        Exec (l,s1)).a by A136,FUNCT_1:72
          .= s1.a by A134,A139,SCMFSA_2:100
          .= (DataPart s1).a by A137,FUNCT_1:72,SCMFSA_2:127
          .= s2.a by A1,A137,FUNCT_1:72,SCMFSA_2:127
          .= (Exec (l,s2)).a by A134,A139,SCMFSA_2:100
          .= (Exec (l,s2) | (Int-Locations \/ FinSeq-Locations \ {da})).x by
A136,FUNCT_1:72;
      end;
      suppose
        x in FinSeq-Locations;
        then reconsider a = x as FinSeq-Location by SCMFSA_2:12;
        thus (Exec (l,s1) | (Int-Locations \/ FinSeq-Locations \ {da})).x = (
        Exec (l,s1)).a by A136,FUNCT_1:72
          .= s1.a by A134,SCMFSA_2:100
          .= (DataPart s1).a by A137,FUNCT_1:72,SCMFSA_2:127
          .= s2.a by A1,A137,FUNCT_1:72,SCMFSA_2:127
          .= (Exec (l,s2)).a by A134,SCMFSA_2:100
          .= (Exec (l,s2) | (Int-Locations \/ FinSeq-Locations \ {da})).x by
A136,FUNCT_1:72;
      end;
    end;
    da in Int-Locations by SCMFSA_2:9;
    then da in Int-Locations \/ FinSeq-Locations by XBOOLE_0:def 3;
    then
A140: Int-Locations \/ FinSeq-Locations = Int-Locations \/
    FinSeq-Locations \/ {da} by ZFMISC_1:46
      .= (Int-Locations \/ FinSeq-Locations \ {da} ) \/ {da} by XBOOLE_1:39;
    fa in FinSeq-Locations by SCMFSA_2:10;
    then
A141: fa in Int-Locations \/ FinSeq-Locations by XBOOLE_0:def 3;
    then s1.fa = (s1 | (Int-Locations \/ FinSeq-Locations)).fa by FUNCT_1:72
      .= s2.fa by A1,A141,FUNCT_1:72,SCMFSA_2:127;
    then Exec (l,s1).da = len(s2.fa) by A134,SCMFSA_2:100
      .= Exec (l,s2).da by A134,SCMFSA_2:100;
    then
A142: Exec (l,s1) | {da} = Exec(l,s2) | {da} by A5,A8,GRFUNC_1:90;
A143: dom ((Exec (l,s2)) | (Int-Locations \/ FinSeq-Locations \ {da})) = (
    Int-Locations \/ FinSeq-Locations \ {da}) by A8,RELAT_1:91;
    dom ((Exec (l,s1)) | (Int-Locations \/ FinSeq-Locations \ {da})) = (
    Int-Locations \/ FinSeq-Locations \ {da}) by A5,RELAT_1:91;
    then Exec (l,s1) | (Int-Locations \/ FinSeq-Locations \ {da} ) = Exec (l,
    s2) | (Int-Locations \/ FinSeq-Locations \ {da} ) by A143,A135,FUNCT_1:9;
    hence thesis by A140,A142,RELAT_1:185,SCMFSA_2:127;
  end;
  suppose
    InsCode i = 12;
    then consider da being Int-Location, fa being FinSeq-Location such that
A144: i = fa:=<0,...,0>da by SCMFSA_2:65;
    set l = i;
A145: dom ((Exec (l,s2)) | (Int-Locations \/ FinSeq-Locations \ {fa})) = (
    Int-Locations \/ FinSeq-Locations \ {fa}) by A8,RELAT_1:91;
A146: ex k2 being Element of NAT st k2 = abs(s2.da) & Exec(l, s2).fa =
    k2 |->0 by A144,SCMFSA_2:101;
A147: ex k1 being Element of NAT st k1 = abs(s1.da) & Exec(l, s1).fa =
    k1 |->0 by A144,SCMFSA_2:101;
A148: for x being set st x in ((Int-Locations \/ FinSeq-Locations) \ {fa})
holds (Exec (l,s1) | (Int-Locations \/ FinSeq-Locations \ {fa})).x = (Exec (l,
    s2) | (Int-Locations \/ FinSeq-Locations \ {fa})).x
    proof
      let x be set;
      assume
A149: x in ((Int-Locations \/ FinSeq-Locations) \ {fa});
      then
A150: x in Int-Locations \/ FinSeq-Locations by XBOOLE_0:def 5;
A151: not x in {fa} by A149,XBOOLE_0:def 5;
      per cases by A150,XBOOLE_0:def 3;
      suppose
        x in Int-Locations;
        then reconsider a = x as Int-Location by SCMFSA_2:11;
        thus (Exec (l,s1) | (Int-Locations \/ FinSeq-Locations \ {fa})).x = (
        Exec (l,s1)).a by A149,FUNCT_1:72
          .= s1.a by A144,SCMFSA_2:101
          .= (DataPart s1).a by A150,FUNCT_1:72,SCMFSA_2:127
          .= s2.a by A1,A150,FUNCT_1:72,SCMFSA_2:127
          .= (Exec (l,s2)).a by A144,SCMFSA_2:101
          .= (Exec (l,s2) | (Int-Locations \/ FinSeq-Locations \ {fa})).x by
A149,FUNCT_1:72;
      end;
      suppose
        x in FinSeq-Locations;
        then reconsider a = x as FinSeq-Location by SCMFSA_2:12;
A152:   a <> fa by A151,TARSKI:def 1;
        thus (Exec (l,s1) | (Int-Locations \/ FinSeq-Locations \ {fa})).x = (
        Exec (l,s1)).a by A149,FUNCT_1:72
          .= s1.a by A144,A152,SCMFSA_2:101
          .= (DataPart s1).a by A150,FUNCT_1:72,SCMFSA_2:127
          .= s2.a by A1,A150,FUNCT_1:72,SCMFSA_2:127
          .= (Exec (l,s2)).a by A144,A152,SCMFSA_2:101
          .= (Exec (l,s2) | (Int-Locations \/ FinSeq-Locations \ {fa})).x by
A149,FUNCT_1:72;
      end;
    end;
    dom ((Exec (l,s1)) | (Int-Locations \/ FinSeq-Locations \ {fa})) = (
    Int-Locations \/ FinSeq-Locations \ {fa}) by A5,RELAT_1:91;
    then
A153: Exec (l,s1) | (Int-Locations \/ FinSeq-Locations \ {fa} ) = Exec (l,
    s2) | (Int-Locations \/ FinSeq-Locations \ {fa} ) by A145,A148,FUNCT_1:9;
    fa in FinSeq-Locations by SCMFSA_2:10;
    then fa in Int-Locations \/ FinSeq-Locations by XBOOLE_0:def 3;
    then
A154: Int-Locations \/ FinSeq-Locations = Int-Locations \/
    FinSeq-Locations \/ {fa} by ZFMISC_1:46
      .= (Int-Locations \/ FinSeq-Locations \ {fa} ) \/ {fa} by XBOOLE_1:39;
    da in Int-Locations by SCMFSA_2:9;
    then
A155: da in Int-Locations \/ FinSeq-Locations by XBOOLE_0:def 3;
    then s1.da = (DataPart s1).da by FUNCT_1:72,SCMFSA_2:127
      .= s2.da by A1,A155,FUNCT_1:72,SCMFSA_2:127;
    then Exec (l,s1) | {fa} = Exec(l,s2) | {fa} by A6,A147,A146,GRFUNC_1:90;
    hence thesis by A154,A153,RELAT_1:185,SCMFSA_2:127;
  end;
end;

Lm3: now
  set IF = Int-Locations \/ FinSeq-Locations;
  let I be keeping_0 parahalting Program of SCM+FSA, s be State of SCM+FSA;
  set IE = IExec(I,s);
  now
A1: dom (Initialized IE) = the carrier of SCM+FSA by PARTFUN1:def 4;

    then
A2: dom (Initialized IE) = Int-Locations \/ FinSeq-Locations \/ ({IC
    SCM+FSA } \/ NAT) by SCMFSA_2:8,XBOOLE_1:4;

A3: dom IE = the carrier of SCM+FSA by PARTFUN1:def 4;

    hence dom DataPart Initialized IE = dom IE /\ IF by A1,RELAT_1:90
,SCMFSA_2:127;

    then
A4: dom DataPart Initialized IE = Int-Locations \/ FinSeq-Locations
by A1,A3,A2,XBOOLE_1:21;

    let x;
    assume
A5: x in dom DataPart Initialized IE;
    per cases by A5,A4,XBOOLE_0:def 3;
    suppose
      x in Int-Locations;
      then reconsider x9 = x as Int-Location by SCMFSA_2:11;
      hereby
        per cases;
        suppose
A6:       x9 is read-write;

          thus (DataPart Initialized IE).x = (Initialized IE).x by A5,A4,
FUNCT_1:72,SCMFSA_2:127

            .= IE.x by A6,Th3;
        end;
        suppose
          x9 is read-only;
          then
A7:       x9 = intloc 0 by SF_MASTR:def 5;

          thus (DataPart Initialized IE).x = (Initialized IE).x9 by A5,A4,
FUNCT_1:72,SCMFSA_2:127

            .= 1 by A7,Th3
            .= IE.x by A7,SCMFSA6B:35;
        end;
      end;
    end;
    suppose
      x in FinSeq-Locations;
      then reconsider x9 = x as FinSeq-Location by SCMFSA_2:12;

      thus (DataPart Initialized IE).x = (Initialized IE).x9
      by A5,A4,FUNCT_1:72,SCMFSA_2:127

        .= IE.x by Th3;
    end;
  end;
  hence DataPart Initialized IE = DataPart IE by FUNCT_1:68,SCMFSA_2:127;
end;

theorem Th6:
  for i being parahalting Instruction of SCM+FSA holds Exec(i,
  Initialized s) = IExec(Macro i, s)
proof
  let i be parahalting Instruction of SCM+FSA;
  set Mi = Macro i;
  set sI = s+*Initialized Mi;
  set Is = Initialized s;
  set IC1 = IC Comput(ProgramPart(sI),sI,1);
  reconsider Mi9 = Mi as parahalting Program of SCM+FSA;
A1:  0 in dom Initialized Mi by COMPOS_1:146,SCMFSA6B:31;
  Mi+*SA0 c= sI by FUNCT_4:26,SCMFSA6B:8;
  then
A2: IC1 in dom Mi9 by SCMFSA6B:def 2;
A3: (Initialized Mi). 1=halt SCM+FSA by COMPOS_1:148,SCMFSA6B:33;
A4: Initialized Mi c= sI by FUNCT_4:26;
A5: now
    set Y = NAT;
    set X = Int-Locations \/ FinSeq-Locations \/ {IC SCM+FSA};
    assume
A6: Result(ProgramPart(sI),sI) = Exec(i, sI);
A7: s+* ((intloc 0) .--> 1),s+*Mi+* ((intloc 0) .--> 1) equal_outside Y
    by FUNCT_7:106,132;
    sI = s+* (Mi +* (((intloc 0) .--> 1) +* Start-At( 0,SCM+FSA)))
     by FUNCT_4:15
      .= s+* Mi +* (((intloc 0) .--> 1) +* Start-At( 0,SCM+FSA))
       by FUNCT_4:15
      .= s+* Mi +* ((intloc 0) .--> 1) +* Start-At( 0,SCM+FSA)
       by FUNCT_4:15;
    then Is, sI equal_outside Y by A7,FUNCT_7:106;
    then Is | X = sI | X by Th4;
    then
A8: Exec(i, Is) | X = Exec(i, sI) | X by SCMFSA_3:4;
A9: Y /\ (X \/ Y) c= Y /\ (X \/ Y);
A10: dom IExec(Mi, s) = the carrier of SCM+FSA by PARTFUN1:def 4;
A11: dom Exec(i, Is) = the carrier of SCM+FSA by PARTFUN1:def 4;
A12: dom s = X \/ Y by PARTFUN1:def 4,SCMFSA_2:8;
    now
      thus dom (Exec(i, Is) | Y) = dom s /\ Y by A11,A12,RELAT_1:90,SCMFSA_2:8;
      let x;
      assume x in dom (Exec(i, Is) | Y);
      then
A13:  x in Y /\ (X \/ Y) by A11,RELAT_1:90,SCMFSA_2:8;
      then x in NAT by XBOOLE_1:21;
      then reconsider x9 = x as Element of NAT;
      x in Y by A13,XBOOLE_1:21;
      hence (Exec(i, Is)|Y).x = (Exec(i, Is)).x by FUNCT_1:72
        .= Is.x9 by AMI_1:def 13
        .= s.x by Th3;
    end;
    then
A14: Exec(i, Is) | Y = s | Y by FUNCT_1:68;
    dom Exec(i, sI) = the carrier of SCM+FSA by PARTFUN1:def 4;
    then
A15: IExec(Mi, s) | Y = s | Y by A6,A12,A9,FUNCT_4:93,SCMFSA_2:8;
    X misses Y
    proof
      assume X meets Y;
      then consider x such that
A16:  x in X and
A17:  x in Y by XBOOLE_0:3;
A18:  x in Int-Locations \/ FinSeq-Locations or x in {IC SCM+FSA} by A16,
XBOOLE_0:def 3;
      per cases by A18,TARSKI:def 1,XBOOLE_0:def 3;
      suppose
        x in Int-Locations;
        hence contradiction by A17,SCMFSA_2:13,XBOOLE_0:3;
      end;
      suppose
        x in FinSeq-Locations;
        hence contradiction by A17,SCMFSA_2:14,XBOOLE_0:3;
      end;
      suppose
A19:    x = IC SCM+FSA;
        reconsider x as Element of NAT by A17;
        x = IC SCM+FSA by A19;
        hence contradiction by COMPOS_1:3;
      end;
    end;
    then X misses dom (s|Y) by RELAT_1:87,XBOOLE_1:63;
    then IExec(Mi, s) | X = Exec(i, sI) | X by A6,FUNCT_4:76;
    then
A20: Exec(i, Is)| (X \/ Y) = IExec(Mi, s) | (X \/ Y) by A8,A15,A14,RELAT_1:185;
    thus Exec(i, Is) = Exec(i, Is)| (X \/ Y) by A11,RELAT_1:98,SCMFSA_2:8
      .= IExec(Mi, s) by A10,A20,RELAT_1:98,SCMFSA_2:8;
  end;
  Mi c= Initialized Mi by SCMFSA6A:26;
  then
A21: dom Mi c= dom Initialized Mi by RELAT_1:25;
A22:  1 in dom Mi by SCMFSA6B:32;
A23: (Initialized Mi). 0 = i by COMPOS_1:148,SCMFSA6B:33;
Y:  (ProgramPart sI)/.IC sI
 = sI.IC sI by COMPOS_1:38;
Z:  (ProgramPart Comput(ProgramPart(sI),sI,1))/.IC Comput(ProgramPart(sI),sI,1)
 = Comput(ProgramPart(sI),sI,1).IC Comput(ProgramPart(sI),sI,1) by COMPOS_1:38;
A24: Comput(ProgramPart(sI),sI,0+1) = Following(ProgramPart sI,
Comput(ProgramPart(sI),sI,0)) by EXTPRO_1:4
    .= Following(ProgramPart sI,sI) by EXTPRO_1:3
    .= Exec(sI. 0, sI) by Y,FUNCT_4:26,SCMFSA6B:34
    .= Exec(i, sI) by A1,A23,A4,GRFUNC_1:8;
TX: ProgramPart sI = ProgramPart Comput(ProgramPart(sI),sI,1)
by AMI_1:123;
  per cases by A2,SCMFSA6B:32;
  suppose
A25: IC1 =  0;
    then
A26: CurInstr(ProgramPart(sI),Comput(ProgramPart(sI),
sI,1)) = sI. 0
 by A24,Z,TX,AMI_1:def 13
      .= i by A1,A23,A4,GRFUNC_1:8;
    succ IC sI = succ  0 by FUNCT_4:26,SCMFSA6B:34
      .=  1;
    then
A27: InsCode i in {0, 6, 7, 8} by A24,A25,SCMFSA6A:23;
    hereby
      per cases by A27,ENUMSET1:def 2;
      suppose
        InsCode i = 0;
        then
A28:    i = halt SCM+FSA by SCMFSA_2:122;
        then ProgramPart sI halts_on sI by A26,EXTPRO_1:30;
        hence thesis by A5,A24,A26,A28,EXTPRO_1:def 8;
      end;
      suppose
A29:    InsCode i = 6 or InsCode i = 7 or InsCode i = 8;
A30:    now
          let a;
          per cases by A29;
          suppose
            InsCode i = 6;
            then ex l st i = goto l by SCMFSA_2:59;
            hence sI.a = Exec(i, sI).a by SCMFSA_2:95;
          end;
          suppose
            InsCode i = 7;
            then ex l, b st i = b=0_goto l by SCMFSA_2:60;
            hence sI.a = Exec(i, sI).a by SCMFSA_2:96;
          end;
          suppose
            InsCode i = 8;
            then ex l, b st i = b>0_goto l by SCMFSA_2:61;
            hence sI.a = Exec(i, sI).a by SCMFSA_2:97;
          end;
        end;
A31:    for l holds sI.l = Exec(i, sI).l by AMI_1:def 13;
A32:    now
          let f;
          per cases by A29;
          suppose
            InsCode i = 6;
            then ex l st i = goto l by SCMFSA_2:59;
            hence sI.f = Exec(i, sI).f by SCMFSA_2:95;
          end;
          suppose
            InsCode i = 7;
            then ex l, a st i = a=0_goto l by SCMFSA_2:60;
            hence sI.f = Exec(i, sI).f by SCMFSA_2:96;
          end;
          suppose
            InsCode i = 8;
            then ex l, a st i = a>0_goto l by SCMFSA_2:61;
            hence sI.f = Exec(i, sI).f by SCMFSA_2:97;
          end;
        end;
        IC sI = IC Exec(i, sI) by A24,A25,FUNCT_4:26,SCMFSA6B:34;
        then
A33:    sI = Exec(i, sI) by A30,A32,A31,SCMFSA_2:86;
A34:    Following(ProgramPart sI,sI) =
Following(ProgramPart sI,Comput(ProgramPart(sI),sI,0)
) by EXTPRO_1:3
          .= Exec(i, sI) by A24,EXTPRO_1:4;
        now
          let n be Element of NAT;
          Comput(ProgramPart(sI),sI,n) = sI by A33,A34,EXTPRO_1:27
            .= Following(ProgramPart sI,Comput(
ProgramPart(sI),sI,0))
             by A33,A34,EXTPRO_1:3
            .= Comput(ProgramPart(sI),sI,0+1) by EXTPRO_1:4;
          hence CurInstr(ProgramPart(sI),Comput(ProgramPart(sI),sI,n))
           <> halt SCM+FSA by A26,A29,SCMFSA_2:124;
        end;
        then not ProgramPart sI halts_on sI by EXTPRO_1:30;
        hence thesis by A4,EXTPRO_1:def 10;
      end;
    end;
  end;
  suppose
S:    IC1 =  1;
  (ProgramPart Comput(ProgramPart(sI),sI,1))/.IC Comput(ProgramPart(sI),sI,1)
 = Comput(ProgramPart(sI),sI,1).IC Comput(ProgramPart(sI),sI,1) by COMPOS_1:38;
    then
A35: CurInstr(ProgramPart(sI),Comput(ProgramPart(sI),
sI,1))
 = sI. 1 by A24,S,TX,AMI_1:def 13
      .= halt SCM+FSA by A21,A22,A3,A4,GRFUNC_1:8;
    then ProgramPart sI halts_on sI by EXTPRO_1:30;
    hence thesis by A5,A24,A35,EXTPRO_1:def 8;
  end;
end;

theorem Th7:
  for I being keeping_0 parahalting Program of SCM+FSA, j being
parahalting Instruction of SCM+FSA holds IExec(I ';' j, s).a = Exec(j, IExec(I,
  s)).a
proof
  let I be keeping_0 parahalting Program of SCM+FSA, j be parahalting
  Instruction of SCM+FSA;
  set Mj = Macro j;
  set SA = Start-At (IC IExec(Mj,IExec(I,s)) + card I,SCM+FSA);
A1: not a in dom SA by SCMFSA6B:9;
A2: DataPart Initialized IExec(I,s) = DataPart IExec(I, s) by Lm3;
  a in Int-Locations by SCMFSA_2:9;
  then
A3: a in Int-Locations \/ FinSeq-Locations by XBOOLE_0:def 3;
  thus IExec(I ';' j, s).a = (IExec(Mj,IExec(I,s))+*SA).a by SCMFSA6B:44
    .= IExec(Mj, IExec(I,s)).a by A1,FUNCT_4:12
    .= Exec(j, Initialized IExec(I,s)).a by Th6
    .= (DataPart Exec(j, Initialized IExec(I,s))).a by A3,FUNCT_1:72
,SCMFSA_2:127
    .= (DataPart Exec(j, IExec(I, s))).a by A2,Th5
    .= Exec(j, IExec(I, s)).a by A3,FUNCT_1:72,SCMFSA_2:127;
end;

theorem Th8:
  for I being keeping_0 parahalting Program of SCM+FSA, j being
parahalting Instruction of SCM+FSA holds IExec(I ';' j, s).f = Exec(j, IExec(I,
  s)).f
proof
  let I be keeping_0 parahalting Program of SCM+FSA, j be parahalting
  Instruction of SCM+FSA;
  set Mj = Macro j;
  set SA = Start-At (IC IExec(Mj,IExec(I,s)) + card I,SCM+FSA);
A1: not f in dom SA by SCMFSA6B:10;
A2: DataPart Initialized IExec(I,s) = DataPart IExec(I, s) by Lm3;
  f in FinSeq-Locations by SCMFSA_2:10;
  then
A3: f in Int-Locations \/ FinSeq-Locations by XBOOLE_0:def 3;
  thus IExec(I ';' j, s).f = (IExec(Mj,IExec(I,s))+*SA).f by SCMFSA6B:44
    .= IExec(Mj, IExec(I,s)).f by A1,FUNCT_4:12
    .= Exec(j, Initialized IExec(I,s)).f by Th6
    .= (DataPart Exec(j, Initialized IExec(I,s))).f by A3,FUNCT_1:72
,SCMFSA_2:127
    .= (DataPart Exec(j, IExec(I, s))).f by A2,Th5
    .= Exec(j, IExec(I, s)).f by A3,FUNCT_1:72,SCMFSA_2:127;
end;

theorem Th9:
  for i being keeping_0 parahalting Instruction of SCM+FSA, j being
parahalting Instruction of SCM+FSA holds IExec(i ';' j, s).a = Exec(j, Exec(i,
  Initialized s)).a
proof
  let i be keeping_0 parahalting Instruction of SCM+FSA, j be parahalting
  Instruction of SCM+FSA;
  set Mi = Macro i;
  thus IExec(i ';' j, s).a = IExec(Mi ';' j, s).a
    .= Exec(j, IExec(Mi,s)).a by Th7
    .= Exec(j, Exec(i, Initialized s)).a by Th6;
end;

theorem
  for i being keeping_0 parahalting Instruction of SCM+FSA, j being
parahalting Instruction of SCM+FSA holds IExec(i ';' j, s).f = Exec(j, Exec(i,
  Initialized s)).f
proof
  let i be keeping_0 parahalting Instruction of SCM+FSA, j be parahalting
  Instruction of SCM+FSA;
  set Mi = Macro i;
  thus IExec(i ';' j, s).f = IExec(Mi ';' j, s).f
    .= Exec(j, IExec(Mi,s)).f by Th8
    .= Exec(j, Exec(i, Initialized s)).f by Th6;
end;

begin :: An example

definition
 canceled;
  let a, b be Int-Location;
  func swap (a, b) -> Program of SCM+FSA equals
  FirstNotUsed Macro (a := b) :=
  a ';' (a := b) ';' (b := FirstNotUsed Macro (a := b));
  correctness;
end;

registration
  let a, b be Int-Location;
  cluster swap(a,b) -> parahalting;
  coherence;
end;

registration
  let a, b be read-write Int-Location;
  cluster swap(a,b) -> keeping_0;
  coherence;
end;

theorem
  for a, b being read-write Int-Location holds IExec (swap(a, b), s).a =
  s.b & IExec (swap(a, b), s).b = s.a
proof
  let a, b be read-write Int-Location;
  set i0 = FirstNotUsed Macro (a := b) := a;
  set i1 = a := b;
  set i2 = b := FirstNotUsed Macro (a := b);
  set i01 = i0 ';' i1;
  UsedIntLoc Macro (a := b) = UsedIntLoc (a := b) by SF_MASTR:32;
  then UsedIntLoc Macro (a := b) = {a, b} by SF_MASTR:18;
  then
A1: not FirstNotUsed Macro (a := b) in {a, b} by SF_MASTR:54;
  then
A2: FirstNotUsed Macro (a := b) <> a by TARSKI:def 2;
A3: FirstNotUsed Macro (a := b) <> b by A1,TARSKI:def 2;
  hereby
    per cases;
    suppose
A4:   a <> b;
      thus IExec(swap(a, b), s).a = Exec(i2, IExec(i01, s)).a by Th7
        .= IExec(i01, s).a by A4,SCMFSA_2:89
        .= Exec(i1, Exec(i0, Initialized s)).a by Th9
        .= Exec(i0, Initialized s).b by SCMFSA_2:89
        .= (Initialized s).b by A3,SCMFSA_2:89
        .= s.b by Th3;
    end;
    suppose
A5:   a = b;
      thus IExec(swap(a, b), s).a = Exec(i2, IExec(i01, s)).a by Th7
        .= IExec(i01, s).(FirstNotUsed Macro (a := b)) by A5,SCMFSA_2:89
        .= Exec(i1, Exec(i0, Initialized s)).(FirstNotUsed Macro (a := b)) by
Th9
        .= Exec(i0, Initialized s).(FirstNotUsed Macro (a := b)) by A2,
SCMFSA_2:89
        .= (Initialized s).a by SCMFSA_2:89
        .= s.b by A5,Th3;
    end;
  end;
  thus IExec(swap(a, b), s).b = Exec(i2, IExec(i01, s)).b by Th7
    .= IExec(i01, s).(FirstNotUsed Macro (a := b)) by SCMFSA_2:89
    .= Exec(i1, Exec(i0, Initialized s)).(FirstNotUsed Macro (a := b)) by Th9
    .= Exec(i0, Initialized s).(FirstNotUsed Macro (a := b)) by A2,SCMFSA_2:89
    .= (Initialized s).a by SCMFSA_2:89
    .= s.a by Th3;
end;

theorem
  UsedInt*Loc swap(a, b) = {}
proof
  set i0 = FirstNotUsed Macro (a := b) := a;
  set i1 = a := b;
  set i2 = b := FirstNotUsed Macro (a := b);
  thus UsedInt*Loc swap(a, b) = (UsedInt*Loc (i0 ';' i1)) \/ (UsedInt*Loc i2)
  by SF_MASTR:50
    .= (UsedInt*Loc (i0 ';' i1)) \/ {} by SF_MASTR:36
    .= (UsedInt*Loc i0) \/ (UsedInt*Loc i1) by SF_MASTR:51
    .= (UsedInt*Loc i0) \/ {} by SF_MASTR:36
    .= {} by SF_MASTR:36;
end;

