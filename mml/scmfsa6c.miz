:: On the compositions of macro instructions, Part III
::  by Noriko Asamoto , Yatsuka Nakamura , Piotr Rudnicki and Andrzej Trybulec
::
:: Received July 22, 1996
:: Copyright (c) 1996 Association of Mizar Users

environ

 vocabularies AMI_1, SCMFSA_2, FSM_1, CARD_1, SCMFSA6B, TURING_1, FUNCT_1,
      RELAT_1, ARYTM_3, FUNCT_4, SCMFSA6A, TARSKI, XBOOLE_0, CIRCUIT2, NUMBERS,
      SUBSET_1, GRAPHSP, AMI_3, XXREAL_0, SF_MASTR, FUNCOP_1, FUNCT_7,
      STRUCT_0, ARYTM_1, INT_1, COMPLEX1, PARTFUN1, FINSEQ_1, FINSEQ_2,
      MSUALG_1, AOFA_I00, ORDINAL1, SCMNORM, PBOOLE, SCMFSA6C;
 notations TARSKI, XBOOLE_0, SUBSET_1, ENUMSET1, CARD_1, NUMBERS, XCMPLX_0,
      NAT_1, INT_1, COMPLEX1, RELAT_1, FUNCT_1, PARTFUN1, FINSEQ_1, FINSEQ_2,
      FUNCOP_1, FUNCT_4, PBOOLE,
      STRUCT_0, COMPOS_1, EXTPRO_1, AMI_1, FUNCT_7,
      SCMFSA_2, SCMFSA6A, SF_MASTR, SCMFSA6B, XXREAL_0;
 constructors DOMAIN_1, SETWISEO, XXREAL_0, INT_2, SCMFSA6A, SF_MASTR,
      SCMFSA6B, RELSET_1, PRE_POLY, AMISTD_2, AMI_1, PBOOLE;
 registrations XBOOLE_0, SETFAM_1, RELAT_1, FUNCT_1, FUNCOP_1, FINSET_1,
      NUMBERS, XREAL_0, INT_1, AMI_1, SCMFSA_2, SCMFSA6A, SF_MASTR, SCMFSA6B,
      ORDINAL1, RELSET_1, COMPOS_1, STRUCT_0, EXTPRO_1, SCMFSA10, PBOOLE,
      FUNCT_4;
 requirements NUMERALS, BOOLE, SUBSET, ARITHM;
 definitions FUNCOP_1, COMPOS_1, EXTPRO_1, AMI_1, SCMFSA6B, SCMFSA6A, PARTFUN1;
 theorems RELAT_1, FUNCT_7, FUNCT_4, FUNCT_1, SCMFSA_3, ZFMISC_1, FUNCOP_1,
      TARSKI, NAT_1, AMI_1, SCMFSA_2, ENUMSET1, GRFUNC_1, SCMFSA6A, SF_MASTR,
      SCMFSA6B, XBOOLE_0, XBOOLE_1, PARTFUN1, COMPOS_1, EXTPRO_1, AMISTD_2,
      PBOOLE;

begin :: Consequences of the main theorem from SCMFSA6B

reserve x for set,
  i for Instruction of SCM+FSA,
  a,b for Int-Location,
  f for FinSeq-Location,
  l, l1 for Element of NAT,
  s,s1,s2 for State of SCM+FSA,
  P,P1,P2 for (the Instructions of SCM+FSA)-valued ManySortedSet of NAT;

set SA0 = Start-At(0,SCM+FSA);

theorem
  for I being keeping_0 parahalting Program of SCM+FSA, J being
parahalting Program of SCM+FSA holds IExec(I ';' J,P,s).a
 = IExec(J,P,IExec(I,P,s)).a
proof
  let I be keeping_0 parahalting Program of SCM+FSA, J be parahalting Program
  of SCM+FSA;
A1: not a in dom Start-At (IC IExec(J,P,IExec(I,P,s)) + card I,SCM+FSA)
 by SCMFSA6B:9;
  IExec(I ';' J,P,s)
   = IExec(J,P,IExec(I,P,s)) +* Start-At (IC IExec(J,P,IExec(I,P,s
  )) + card I,SCM+FSA) by SCMFSA6B:44;
  hence thesis by A1,FUNCT_4:12;
end;

theorem
  for I being keeping_0 parahalting Program of SCM+FSA, J being
parahalting Program of SCM+FSA
 holds IExec(I ';' J,P,s).f = IExec(J,P,IExec(I,P,s)).f
proof
  let I be keeping_0 parahalting Program of SCM+FSA, J be parahalting Program
  of SCM+FSA;
A1: not f in dom Start-At (IC IExec(J,P,IExec(I,P,s)) + card I,SCM+FSA)
 by SCMFSA6B:10;
  IExec(I ';' J,P,s)
   = IExec(J,P,IExec(I,P,s)) +* Start-At (IC IExec(J,P,IExec(I,P,s
  )) + card I,SCM+FSA) by SCMFSA6B:44;
  hence thesis by A1,FUNCT_4:12;
end;

begin :: Properties of simple macro instructions

definition
  let i be Instruction of SCM+FSA;
  attr i is parahalting means
  :Def1:
  Macro i is parahalting;
  attr i is keeping_0 means
  :Def2:
  Macro i is keeping_0;
end;

Lm1: Macro halt SCM+FSA is parahalting
proof
  let s;
  set m = Macro halt SCM+FSA;
  set m1 = Initialize m;
  assume
A1: m1 c= s;
  let P be (the Instructions of SCM+FSA)-valued ManySortedSet of NAT
  such that
A2: ProgramPart m1 c= P;
 dom(SA0) = {IC SCM+FSA} by FUNCOP_1:19;
  then
A3: IC SCM+FSA in dom (SA0) by TARSKI:def 1;
  then
A4: IC SCM+FSA in dom m1 by FUNCT_4:13;
A5: IC m1 = (SA0).IC SCM+FSA by A3,FUNCT_4:14
    .=  0 by FUNCOP_1:87;
  take 0;
A6: dom P = NAT by PARTFUN1:def 4;
    thus IC Comput(P,s,0) in dom P by A6;
  dom m = { 0, 1} by FUNCT_4:65;
  then
A7:  0 in dom m by TARSKI:def 2;
A8: m c= P by A2,COMPOS_1:144;
  CurInstr(P,Comput(P,s,0))
   = CurInstr(P,s)  by EXTPRO_1:3
    .= P.IC s by A6,PARTFUN1:def 8
    .= P.IC m1 by A1,A4,GRFUNC_1:8
    .= m. 0 by A5,GRFUNC_1:8,A8,A7
    .= halt SCM+FSA by FUNCT_4:66;
    hence thesis;
end;

Lm2: Macro halt SCM+FSA is keeping_0
proof
  set Mi = Macro halt SCM+FSA;
    let s be State of SCM+FSA;
    assume
A1: Initialize Mi c= s;
    let P be (the Instructions of SCM+FSA)-valued ManySortedSet of NAT;
    assume
A2:  Mi c= P;
    let k be Element of NAT;
A3: s = Comput(P,s,0) by EXTPRO_1:3;
A4:  (P)/.IC s = P.IC s by PBOOLE:158;
A5: 0 in dom Mi by COMPOS_1:147;
 Comput(P,s,0) =
  s by EXTPRO_1:3;
  then
    CurInstr(P,Comput(P,s,0))
       = P.0 by A1,A4,COMPOS_1:143
      .= Mi.0 by GRFUNC_1:8,A2,A5
      .= halt SCM+FSA by COMPOS_1:148;
    hence (Comput(P,s,k)).intloc 0 = s.intloc 0 by A3,EXTPRO_1:6,NAT_1:2;
end;

registration
  cluster halt SCM+FSA -> keeping_0 parahalting;
  coherence
  proof
    thus Macro halt SCM+FSA is keeping_0 parahalting by Lm1,Lm2;
  end;
end;

registration
  cluster keeping_0 parahalting Instruction of SCM+FSA;
  existence
  proof
    take halt SCM+FSA;
    thus thesis;
  end;
end;

registration
  let i be parahalting Instruction of SCM+FSA;
  cluster Macro i -> parahalting;
  coherence by Def1;
end;

registration
  let i be keeping_0 Instruction of SCM+FSA;
  cluster Macro i -> keeping_0;
  coherence by Def2;
end;

registration
  let a, b be Int-Location;
  cluster a := b -> parahalting;
  coherence
  proof
    set Ma = Macro (a := b);
    let s such that
A1: Initialize Macro (a := b) c= s;
  let P be (the Instructions of SCM+FSA)-valued ManySortedSet of NAT
  such that
A2: ProgramPart(Initialize Ma) c= P;
A3: Ma c= P by A2,COMPOS_1:144;
    take 1;
A4: dom P = NAT by PARTFUN1:def 4;
    thus IC Comput(P,s,1) in dom P by A4;
    dom SA0 = {IC SCM+FSA} by FUNCOP_1:19;
    then
A5: IC SCM+FSA in dom SA0 by TARSKI:def 1;
    SA0 c= Initialize Macro (a := b) by FUNCT_4:26;
    then SA0 c= s by A1,XBOOLE_1:1;
    then
A6: IC s = SA0.IC SCM+FSA by A5,GRFUNC_1:8
      .=  0 by FUNCOP_1:87;
    then
A7: IC Exec(a:=b, s) = succ  0 by SCMFSA_2:89
      .=  (0+1);
A8:  1 in dom Ma by COMPOS_1:147;
A9:  0 in dom Ma by COMPOS_1:147;
A10: P.0 = Ma.0 by A3,A9,GRFUNC_1:8
     .= a:=b by COMPOS_1:148;
A11: P.1 = Ma.1 by A3,A8,GRFUNC_1:8
     .= halt SCM+FSA by COMPOS_1:148;
   Comput(P,s,0+1) = Following(P,
    Comput(P,s,0)) by EXTPRO_1:4
      .= Following(P,s) by EXTPRO_1:3
      .= Exec(a:=b, s) by A6,A4,PARTFUN1:def 8,A10;
    hence thesis by A7,A4,PARTFUN1:def 8,A11;
  end;
  cluster AddTo(a,b) -> parahalting;
  coherence
  proof
    set Ma = Macro (AddTo(a,b));
    let s such that
A12: Initialize Macro (AddTo(a,b)) c= s;
  let P be (the Instructions of SCM+FSA)-valued ManySortedSet of NAT
  such that
A13: ProgramPart(Initialize Ma) c= P;
A14: Ma c= P by A13,COMPOS_1:144;
    take 1;
A15: dom P = NAT by PARTFUN1:def 4;
    thus IC Comput(P,s,1) in dom P by A15;
    dom SA0 = {IC SCM+FSA} by FUNCOP_1:19;
    then
A16: IC SCM+FSA in dom SA0 by TARSKI:def 1;
    SA0 c= Initialize Macro (AddTo(a,b)) by FUNCT_4:26;
    then SA0 c= s by A12,XBOOLE_1:1;
    then
A17: IC s = SA0.IC SCM+FSA by A16,GRFUNC_1:8
      .=  0 by FUNCOP_1:87;
    then
A18: IC Exec(AddTo(a,b), s) = succ  0 by SCMFSA_2:90
      .=  (0+1);
A19:   1 in dom Ma by COMPOS_1:147;
A20:  0 in dom Ma by COMPOS_1:147;
A21: P.0 = Ma.0 by A14,A20,GRFUNC_1:8
     .= AddTo(a,b) by COMPOS_1:148;
A22: P.1 = Ma.1 by A14,A19,GRFUNC_1:8
     .= halt SCM+FSA by COMPOS_1:148;
    Comput(P,s,0+1) = Following(P,
    Comput(P,s,0)) by EXTPRO_1:4
      .= Following(P,s) by EXTPRO_1:3
      .= Exec(AddTo(a,b), s) by A17,A15,PARTFUN1:def 8,A21;
    hence thesis by A18,A15,PARTFUN1:def 8,A22;
  end;
  cluster SubFrom(a,b) -> parahalting;
  coherence
  proof
    set Ma = Macro (SubFrom(a,b));
    let s such that
A23: Initialize Macro (SubFrom(a,b)) c= s;
  let P be (the Instructions of SCM+FSA)-valued ManySortedSet of NAT
  such that
A24: ProgramPart(Initialize Ma) c= P;
A25: Ma c= P by A24,COMPOS_1:144;
    take 1;
A26: dom P = NAT by PARTFUN1:def 4;
    thus IC Comput(P,s,1) in dom P by A26;
    dom SA0 = {IC SCM+FSA} by FUNCOP_1:19;
    then
A27: IC SCM+FSA in dom SA0 by TARSKI:def 1;
    SA0 c= Initialize Macro (SubFrom(a,b)) by FUNCT_4:26;
    then SA0 c= s by A23,XBOOLE_1:1;
    then
A28: IC s = SA0.IC SCM+FSA by A27,GRFUNC_1:8
      .=  0 by FUNCOP_1:87;
    then
A29: IC Exec(SubFrom(a,b), s) = succ  0 by SCMFSA_2:91
      .=  (0+1);
A30:   1 in dom Ma by COMPOS_1:147;
A31:  0 in dom Ma by COMPOS_1:147;
A32: P.0 = Ma.0 by A25,A31,GRFUNC_1:8
     .= SubFrom(a,b) by COMPOS_1:148;
A33: P.1 = Ma.1 by A25,A30,GRFUNC_1:8
     .= halt SCM+FSA by COMPOS_1:148;
    Comput(P,s,0+1) = Following(P,
    Comput(P,s,0)) by EXTPRO_1:4
      .= Following(P,s) by EXTPRO_1:3
      .= Exec(SubFrom(a,b), s) by A28,A26,PARTFUN1:def 8,A32;
    hence thesis by A29,A26,PARTFUN1:def 8,A33;
  end;
  cluster MultBy(a,b) -> parahalting;
  coherence
  proof
    set Ma = Macro (MultBy(a,b));
    let s such that
A34: Initialize Macro (MultBy(a,b)) c= s;
  let P be (the Instructions of SCM+FSA)-valued ManySortedSet of NAT
  such that
A35: ProgramPart(Initialize Macro (MultBy(a,b))) c= P;
A36: Ma c= P by A35,COMPOS_1:144;
    take 1;
A37: dom P = NAT by PARTFUN1:def 4;
    thus IC Comput(P,s,1) in dom P by A37;
    dom SA0 = {IC SCM+FSA} by FUNCOP_1:19;
    then
A38: IC SCM+FSA in dom SA0 by TARSKI:def 1;
    SA0 c= Initialize Macro (MultBy(a,b)) by FUNCT_4:26;
    then SA0 c= s by A34,XBOOLE_1:1;
    then
A39: IC s = SA0.IC SCM+FSA by A38,GRFUNC_1:8
      .=  0 by FUNCOP_1:87;
    then
A40: IC Exec(MultBy(a,b), s) = succ  0 by SCMFSA_2:92
      .=  0+1;
A41:   1 in dom Ma by COMPOS_1:147;
A42:  0 in dom Ma by COMPOS_1:147;
A43: P.0 = Ma.0 by A36,A42,GRFUNC_1:8
     .= MultBy(a,b) by COMPOS_1:148;
A44: P.1 = Ma.1 by A36,A41,GRFUNC_1:8
     .= halt SCM+FSA by COMPOS_1:148;
    Comput(P,s,0+1) = Following(P,
    Comput(P,s,0)) by EXTPRO_1:4
      .= Following(P,s) by EXTPRO_1:3
      .= Exec(MultBy(a,b), s) by A39,A37,PARTFUN1:def 8,A43;
    hence thesis by A40,A37,PARTFUN1:def 8,A44;
  end;
  cluster Divide(a,b) -> parahalting;
  coherence
  proof
    set Ma = Macro (Divide(a,b));
    let s such that
A45: Initialize Macro (Divide(a,b)) c= s;
  let P be (the Instructions of SCM+FSA)-valued ManySortedSet of NAT
  such that
A46: ProgramPart(Initialize Macro (Divide(a,b))) c= P;
A47: Ma c= P by A46,COMPOS_1:144;
    take 1;
A48: dom P = NAT by PARTFUN1:def 4;
    thus IC Comput(P,s,1) in dom P by A48;
    dom SA0 = {IC SCM+FSA} by FUNCOP_1:19;
    then
A49: IC SCM+FSA in dom SA0 by TARSKI:def 1;
    SA0 c= Initialize Macro (Divide(a,b)) by FUNCT_4:26;
    then SA0 c= s by A45,XBOOLE_1:1;
    then
A50: IC s = SA0.IC SCM+FSA by A49,GRFUNC_1:8
      .=  0 by FUNCOP_1:87;
    then
A51: IC Exec(Divide(a,b), s) = succ  0 by SCMFSA_2:93
      .=  (0+1);
A52:   1 in dom Ma by COMPOS_1:147;
A53:  0 in dom Ma by COMPOS_1:147;
A54: P.0 = Ma.0 by A47,A53,GRFUNC_1:8
     .= Divide(a,b) by COMPOS_1:148;
A55: P.1 = Ma.1 by A47,A52,GRFUNC_1:8
     .= halt SCM+FSA by COMPOS_1:148;
    Comput(P,s,0+1) = Following(P,
    Comput(P,s,0)) by EXTPRO_1:4
      .= Following(P,s) by EXTPRO_1:3
      .= Exec(Divide(a,b), s) by A50,A48,PARTFUN1:def 8,A54;
    hence thesis by A51,A48,PARTFUN1:def 8,A55;
  end;
  let f be FinSeq-Location;
  cluster b := (f,a) -> parahalting;
  coherence
  proof
    set Ma = Macro (b:=(f,a));
    let s such that
A56: Initialize Macro (b:=(f,a)) c= s;
  let P be (the Instructions of SCM+FSA)-valued ManySortedSet of NAT
  such that
A57: ProgramPart(Initialize Macro (b:=(f,a))) c= P;
A58: Ma c= P by A57,COMPOS_1:144;
    take 1;
A59: dom P = NAT by PARTFUN1:def 4;
    thus IC Comput(P,s,1) in dom P by A59;
    dom SA0 = {IC SCM+FSA} by FUNCOP_1:19;
    then
A60: IC SCM+FSA in dom SA0 by TARSKI:def 1;
    SA0 c= Initialize Macro (b:=(f,a)) by FUNCT_4:26;
    then SA0 c= s by A56,XBOOLE_1:1;
    then
A61: IC s = SA0.IC SCM+FSA by A60,GRFUNC_1:8
      .=  0 by FUNCOP_1:87;
    then
A62: IC Exec(b:=(f,a), s) = succ  0 by SCMFSA_2:98
      .=  (0+1);
A63:   1 in dom Ma by COMPOS_1:147;
A64:  0 in dom Ma by COMPOS_1:147;
A65: P.0 = Ma.0 by A58,A64,GRFUNC_1:8
     .= b:=(f,a) by COMPOS_1:148;
A66: P.1 = Ma.1 by A58,A63,GRFUNC_1:8
     .= halt SCM+FSA by COMPOS_1:148;
    Comput(P,s,0+1) = Following(P,
    Comput(P,s,0)) by EXTPRO_1:4
      .= Following(P,s) by EXTPRO_1:3
      .= Exec(b:=(f,a), s) by A61,A59,PARTFUN1:def 8,A65;
    hence thesis by A62,A59,PARTFUN1:def 8,A66;
  end;
  cluster (f,a) := b -> parahalting keeping_0;
  coherence
  proof
    thus (f,a) := b is parahalting
    proof
      set Ma = Macro ((f,a):=b);
      let s such that
A67:  Initialize Macro ((f,a):=b) c= s;
  let P be (the Instructions of SCM+FSA)-valued ManySortedSet of NAT
  such that
A68: ProgramPart(Initialize Macro ((f,a):=b)) c= P;
A69: Ma c= P by A68,COMPOS_1:144;
      take 1;
A70: dom P = NAT by PARTFUN1:def 4;
    thus IC Comput(P,s,1) in dom P by A70;
      dom SA0 = {IC SCM+FSA} by FUNCOP_1:19;
      then
A71:  IC SCM+FSA in dom SA0 by TARSKI:def 1;
      SA0 c= Initialize Macro ((f,a):=b) by FUNCT_4:26;
      then SA0 c= s by A67,XBOOLE_1:1;
      then
A72:  IC s = SA0.IC SCM+FSA by A71,GRFUNC_1:8
        .=  0 by FUNCOP_1:87;
      then
A73:  IC Exec((f,a):=b, s) = succ  0 by SCMFSA_2:99
        .=  (0+1);
A74:     1 in dom Ma by COMPOS_1:147;
A75:    0 in dom Ma by COMPOS_1:147;
A76: P.0 = Ma.0 by A69,A75,GRFUNC_1:8
     .= (f,a):=b by COMPOS_1:148;
A77: P.1 = Ma.1 by A69,A74,GRFUNC_1:8
     .= halt SCM+FSA by COMPOS_1:148;
      Comput(P,s,0+1) = Following(P,
      Comput(P,s,0)) by EXTPRO_1:4
        .= Following(P,s) by EXTPRO_1:3
        .= Exec((f,a):=b, s) by A72,A70,PARTFUN1:def 8,A76;
      hence thesis by A73,A70,PARTFUN1:def 8,A77;
    end;
    thus (f,a) := b is keeping_0
    proof
      set Ma = Macro ((f,a):=b);
      let s;
      assume
A78:  Initialize Macro ((f,a):=b) c= s;
    let P be (the Instructions of SCM+FSA)-valued ManySortedSet of NAT;
    assume
A79: Ma c= P;
      let k be Element of NAT;
      dom SA0 = {IC SCM+FSA} by FUNCOP_1:19;
      then
A80:  IC SCM+FSA in dom SA0 by TARSKI:def 1;
      SA0 c= Initialize Macro ((f,a):=b) by FUNCT_4:26;
      then SA0 c= s by A78,XBOOLE_1:1;
      then
A81:  IC s = SA0.IC SCM+FSA by A80,GRFUNC_1:8
        .=  0 by FUNCOP_1:87;
    0 in dom Ma by COMPOS_1:147;
      then
A82:  Ma. 0 = P.0 by A79,GRFUNC_1:8;
A83:  (P)/.IC s
 = P.IC s by PBOOLE:158;
A84:  Comput(P,s,0+1) = Following(P,
Comput(P,s,0)) by EXTPRO_1:4
        .= Following(P,s) by EXTPRO_1:3
        .= Exec((f,a):=b, s) by A81,A82,A83,COMPOS_1:148;
     1 in dom Ma by COMPOS_1:147;
      then Ma. 1 = P.1 by A79,GRFUNC_1:8;
      then
A85:  P.1 = halt SCM+FSA by COMPOS_1:148;
      IC Exec((f,a):=b, s) = succ  0 by A81,SCMFSA_2:99
        .=  (0+1);
      then
A86:  CurInstr(P,Comput(P,s,1)) = halt SCM+FSA by A85,A84,PBOOLE:158;
      per cases by NAT_1:14;
      suppose
        k = 0;
        hence thesis by EXTPRO_1:3;
      end;
      suppose
A87:    1 <= k;
        Comput(P,s,1).intloc 0 = s.intloc 0 by A84,SCMFSA_2:99;
        hence thesis by A86,A87,EXTPRO_1:6;
      end;
    end;
  end;
end;

registration
  let a be Int-Location, f be FinSeq-Location;
  cluster a :=len f -> parahalting;
  coherence
  proof
    set Ma = Macro (a:=len f);
    let s such that
A1: Initialize Macro (a:=len f) c= s;
  let P be (the Instructions of SCM+FSA)-valued ManySortedSet of NAT
  such that
A2: ProgramPart(Initialize Macro (a:=len f)) c= P;
A3: Ma c= P by A2,COMPOS_1:144;
    take 1;
A4: dom P = NAT by PARTFUN1:def 4;
    thus IC Comput(P,s,1) in dom P by A4;
    dom SA0 = {IC SCM+FSA} by FUNCOP_1:19;
    then
A5: IC SCM+FSA in dom SA0 by TARSKI:def 1;
    SA0 c= Initialize Macro (a:=len f) by FUNCT_4:26;
    then SA0 c= s by A1,XBOOLE_1:1;
    then
A6: IC s = SA0.IC SCM+FSA by A5,GRFUNC_1:8
      .=  0 by FUNCOP_1:87;
    then
A7: IC Exec(a:=len f, s) = succ  0 by SCMFSA_2:100
      .=  (0+1);
A8:   1 in dom Ma by COMPOS_1:147;
A9:  0 in dom Ma by COMPOS_1:147;
A10: P.0 = Ma.0 by A3,A9,GRFUNC_1:8
     .= a:=len f by COMPOS_1:148;
A11: P.1 = Ma.1 by A3,A8,GRFUNC_1:8
     .= halt SCM+FSA by COMPOS_1:148;
    Comput(P,s,0+1) = Following(P,
    Comput(P,s,0)) by EXTPRO_1:4
      .= Following(P,s) by EXTPRO_1:3
      .= Exec(a:=len f, s) by A6,A4,PARTFUN1:def 8,A10;
    hence thesis by A7,A4,PARTFUN1:def 8,A11;
  end;
  cluster f :=<0,...,0> a -> parahalting keeping_0;
  coherence
  proof
    thus f :=<0,...,0> a is parahalting
    proof
      set Ma = Macro (f:=<0,...,0>a);
      let s such that
A12:   Initialize Macro (f:=<0,...,0>a) c= s;
  let P be (the Instructions of SCM+FSA)-valued ManySortedSet of NAT
  such that
A13: ProgramPart(Initialize Macro (f:=<0,...,0>a)) c= P;
A14: Ma c= P by A13,COMPOS_1:144;
      take 1;
A15: dom P = NAT by PARTFUN1:def 4;
    thus IC Comput(P,s,1) in dom P by A15;
      dom SA0 = {IC SCM+FSA} by FUNCOP_1:19;
      then
A16:  IC SCM+FSA in dom SA0 by TARSKI:def 1;
      SA0 c= Initialize Macro (f:=<0,...,0>a) by FUNCT_4:26;
      then SA0 c= s by A12,XBOOLE_1:1;
      then
A17:  IC s = SA0.IC SCM+FSA by A16,GRFUNC_1:8
        .=  0 by FUNCOP_1:87;
      then
A18:  IC Exec(f:=<0,...,0>a, s) = succ  0 by SCMFSA_2:101
        .=  (0+1);
A19:     1 in dom Ma by COMPOS_1:147;
A20:    0 in dom Ma by COMPOS_1:147;
A21: P.0 = Ma.0 by A14,A20,GRFUNC_1:8
     .= f:=<0,...,0>a by COMPOS_1:148;
A22: P.1 = Ma.1 by A14,A19,GRFUNC_1:8
     .= halt SCM+FSA by COMPOS_1:148;
      Comput(P,s,0+1) = Following(P,
      Comput(P,s,0)) by EXTPRO_1:4
        .= Following(P,s) by EXTPRO_1:3
        .= Exec(f:=<0,...,0>a, s) by A17,A15,PARTFUN1:def 8,A21;
      hence thesis by A18,A15,PARTFUN1:def 8,A22;
    end;
    thus (f:=<0,...,0>a) is keeping_0
    proof
      set Ma = Macro (f:=<0,...,0>a);
      let s;
      assume
A23:  Initialize Macro (f:=<0,...,0>a) c= s;
    let P be (the Instructions of SCM+FSA)-valued ManySortedSet of NAT;
    assume
A24: Ma c= P;
      let k be Element of NAT;
      dom SA0 = {IC SCM+FSA} by FUNCOP_1:19;
      then
A25:  IC SCM+FSA in dom SA0 by TARSKI:def 1;
      SA0 c= Initialize Macro (f:=<0,...,0>a) by FUNCT_4:26;
      then SA0 c= s by A23,XBOOLE_1:1;
      then
A26:  IC s = SA0.IC SCM+FSA by A25,GRFUNC_1:8
        .=  0 by FUNCOP_1:87;
    0 in dom Ma by COMPOS_1:147;
      then
A27:  Ma. 0 = P.0 by A24,GRFUNC_1:8;
A28:  (P)/.IC s
 = P.IC s by PBOOLE:158;
A29:  Comput(P,s,0+1) = Following(P,
Comput(P,s,0)) by EXTPRO_1:4
        .= Following(P,s) by EXTPRO_1:3
        .= Exec(f:=<0,...,0>a, s) by A26,A27,A28,COMPOS_1:148;
     1 in dom Ma by COMPOS_1:147;
      then Ma. 1 = P.1 by A24,GRFUNC_1:8;
      then
A30:  P.1 = halt SCM+FSA by COMPOS_1:148;
      IC Exec(f:=<0,...,0>a, s) = succ  0 by A26,SCMFSA_2:101
        .=  (0+1);
      then
A31:  CurInstr(P,Comput(P,s,1
))
 = halt SCM+FSA by A30,A29,PBOOLE:158;
      per cases by NAT_1:14;
      suppose
        k = 0;
        hence thesis by EXTPRO_1:3;
      end;
      suppose
A32:    1 <= k;
        Comput(P,s,1).intloc 0 = s.intloc 0 by A29,SCMFSA_2:101;
        hence thesis by A31,A32,EXTPRO_1:6;
      end;
    end;
  end;
end;

registration
  let a be read-write Int-Location, b be Int-Location;
  cluster a := b -> keeping_0;
  coherence
  proof
    set Ma = Macro (a:=b);
    let s;
    assume
A1: Initialize Macro (a:=b) c= s;
    let P be (the Instructions of SCM+FSA)-valued ManySortedSet of NAT;
    assume
A2: Ma c= P;
    let k be Element of NAT;
    dom SA0 = {IC SCM+FSA} by FUNCOP_1:19;
    then
A3: IC SCM+FSA in dom SA0 by TARSKI:def 1;
    SA0 c= Initialize Macro (a:=b) by FUNCT_4:26;
    then SA0 c= s by A1,XBOOLE_1:1;
    then
A4: IC s = SA0.IC SCM+FSA by A3,GRFUNC_1:8
      .=  0 by FUNCOP_1:87;
  0 in dom Ma by COMPOS_1:147;
    then
A5: Ma. 0 = P.0 by A2,GRFUNC_1:8;
A6:  (P)/.IC s
 = P.IC s by PBOOLE:158;
A7: Comput(P,s,0+1) = Following(P,
Comput(P,s,0)) by EXTPRO_1:4
      .= Following(P,s) by EXTPRO_1:3
      .= Exec(a:=b, s) by A4,A5,A6,COMPOS_1:148;
   1 in dom Ma by COMPOS_1:147;
    then Ma. 1 = P.1 by A2,GRFUNC_1:8;
    then
A8: P.1 = halt SCM+FSA by COMPOS_1:148;
    IC Exec(a:=b, s) = succ  0 by A4,SCMFSA_2:89
      .=  (0+1);
    then
A9: CurInstr(P,Comput(P,s,1))
 = halt SCM+FSA by A8,A7,PBOOLE:158;
    per cases by NAT_1:14;
    suppose
      k = 0;
      hence thesis by EXTPRO_1:3;
    end;
    suppose
A10:   1 <= k;
      Comput(P,s,1).intloc 0 = s.intloc 0 by A7,SCMFSA_2:89;
      hence thesis by A9,A10,EXTPRO_1:6;
    end;
  end;
  cluster AddTo(a, b) -> keeping_0;
  coherence
  proof
    set Ma = Macro (AddTo(a,b));
    let s;
    assume
A11: Initialize Macro (AddTo(a,b)) c= s;
    let P be (the Instructions of SCM+FSA)-valued ManySortedSet of NAT;
    assume
A12: Ma c= P;
    let k be Element of NAT;
    dom SA0 = {IC SCM+FSA} by FUNCOP_1:19;
    then
A13: IC SCM+FSA in dom SA0 by TARSKI:def 1;
    SA0 c= Initialize Macro (AddTo(a,b)) by FUNCT_4:26;
    then SA0 c= s by A11,XBOOLE_1:1;
    then
A14: IC s = SA0.IC SCM+FSA by A13,GRFUNC_1:8
      .=  0 by FUNCOP_1:87;
  0 in dom Ma by COMPOS_1:147;
    then
A15: Ma. 0 = P.0 by A12,GRFUNC_1:8;
A16:  (P)/.IC s
 = P.IC s by PBOOLE:158;
A17: Comput(P,s,0+1) = Following(P,
Comput(P,s,0)) by EXTPRO_1:4
      .= Following(P,s) by EXTPRO_1:3
      .= Exec(AddTo(a,b), s) by A14,A15,A16,COMPOS_1:148;
   1 in dom Ma by COMPOS_1:147;
    then Ma. 1 = P.1 by A12,GRFUNC_1:8;
    then
A18: P.1 = halt SCM+FSA by COMPOS_1:148;
    IC Exec(AddTo(a,b), s) = succ  0 by A14,SCMFSA_2:90
      .=  (0+1);
    then
A19: CurInstr(P,Comput(P,s,1)
)
 = halt SCM+FSA by A18,A17,PBOOLE:158;
    per cases by NAT_1:14;
    suppose
      k = 0;
      hence thesis by EXTPRO_1:3;
    end;
    suppose
A20:  1 <= k;
      Comput(P,s,1).intloc 0 = s.intloc 0 by A17,SCMFSA_2:90;
      hence thesis by A19,A20,EXTPRO_1:6;
    end;
  end;
  cluster SubFrom(a, b) -> keeping_0;
  coherence
  proof
    set Ma = Macro (SubFrom(a,b));
    let s;
    assume
A21: Initialize Macro (SubFrom(a,b)) c= s;
    let P be (the Instructions of SCM+FSA)-valued ManySortedSet of NAT;
    assume
A22: Ma c= P;
    let k be Element of NAT;
    dom SA0 = {IC SCM+FSA} by FUNCOP_1:19;
    then
A23: IC SCM+FSA in dom SA0 by TARSKI:def 1;
    SA0 c= Initialize Macro (SubFrom(a,b)) by FUNCT_4:26;
    then SA0 c= s by A21,XBOOLE_1:1;
    then
A24: IC s = SA0.IC SCM+FSA by A23,GRFUNC_1:8
      .=  0 by FUNCOP_1:87;
  0 in dom Ma by COMPOS_1:147;
    then
A25: Ma. 0 = P.0 by A22,GRFUNC_1:8;
A26:  (P)/.IC s
 = P.IC s by PBOOLE:158;
A27: Comput(P,s,0+1) = Following(P,
Comput(P,s,0)) by EXTPRO_1:4
      .= Following(P,s) by EXTPRO_1:3
      .= Exec(SubFrom(a,b), s) by A24,A25,A26,COMPOS_1:148;
   1 in dom Ma by COMPOS_1:147;
    then Ma. 1 = P.1 by A22,GRFUNC_1:8;
    then
A28: P.1 = halt SCM+FSA by COMPOS_1:148;
    IC Exec(SubFrom(a,b), s) = succ  0 by A24,SCMFSA_2:91
      .=  (0+1);
    then
A29: CurInstr(P,Comput(P,s,1)
)
 = halt SCM+FSA by A28,A27,PBOOLE:158;
    per cases by NAT_1:14;
    suppose
      k = 0;
      hence thesis by EXTPRO_1:3;
    end;
    suppose
A30:  1 <= k;
      Comput(P,s,1).intloc 0 = s.intloc 0 by A27,SCMFSA_2:91;
      hence thesis by A29,A30,EXTPRO_1:6;
    end;
  end;
  cluster MultBy(a, b) -> keeping_0;
  coherence
  proof
    set Ma = Macro (MultBy(a,b));
    let s;
    assume
A31: Initialize Macro (MultBy(a,b)) c= s;
    let P be (the Instructions of SCM+FSA)-valued ManySortedSet of NAT;
    assume
A32: Ma c= P;
    let k be Element of NAT;
    dom SA0 = {IC SCM+FSA} by FUNCOP_1:19;
    then
A33: IC SCM+FSA in dom SA0 by TARSKI:def 1;
    SA0 c= Initialize Macro (MultBy(a,b)) by FUNCT_4:26;
    then SA0 c= s by A31,XBOOLE_1:1;
    then
A34: IC s = SA0.IC SCM+FSA by A33,GRFUNC_1:8
      .=  0 by FUNCOP_1:87;
  0 in dom Ma by COMPOS_1:147;
    then
A35: Ma. 0 = P.0 by A32,GRFUNC_1:8;
A36:  (P)/.IC s
 = P.IC s by PBOOLE:158;
A37: Comput(P,s,0+1) = Following(P,
Comput(P,s,0)) by EXTPRO_1:4
      .= Following(P,s) by EXTPRO_1:3
      .= Exec(MultBy(a,b), s) by A34,A35,A36,COMPOS_1:148;
   1 in dom Ma by COMPOS_1:147;
    then Ma. 1 = P.1 by A32,GRFUNC_1:8;
    then
A38: P.1 = halt SCM+FSA by COMPOS_1:148;
    IC Exec(MultBy(a,b), s) = succ  0 by A34,SCMFSA_2:92
      .=  (0+1);
    then
A39: CurInstr(P,Comput(P,s,1)
)
 = halt SCM+FSA by A38,A37,PBOOLE:158;
    per cases by NAT_1:14;
    suppose
      k = 0;
      hence thesis by EXTPRO_1:3;
    end;
    suppose
A40:  1 <= k;
      Comput(P,s,1).intloc 0 = s.intloc 0 by A37,SCMFSA_2:92;
      hence thesis by A39,A40,EXTPRO_1:6;
    end;
  end;
end;

registration
  let a, b be read-write Int-Location;
  cluster Divide(a, b) -> keeping_0;
  coherence
  proof
    set Ma = Macro (Divide(a,b));
    let s;
    assume
A1: Initialize Macro (Divide(a,b)) c= s;
    let P be (the Instructions of SCM+FSA)-valued ManySortedSet of NAT;
    assume
A2: Ma c= P;
    let k be Element of NAT;
    dom SA0 = {IC SCM+FSA} by FUNCOP_1:19;
    then
A3: IC SCM+FSA in dom SA0 by TARSKI:def 1;
    SA0 c= Initialize Macro (Divide(a,b)) by FUNCT_4:26;
    then SA0 c= s by A1,XBOOLE_1:1;
    then
A4: IC s = SA0.IC SCM+FSA by A3,GRFUNC_1:8
      .=  0 by FUNCOP_1:87;
  0 in dom Ma by COMPOS_1:147;
    then
A5: Ma. 0 = P.0 by A2,GRFUNC_1:8;
A6:  (P)/.IC s
 = P.IC s by PBOOLE:158;
A7: Comput(P,s,0+1) = Following(P,
Comput(P,s,0)) by EXTPRO_1:4
      .= Following(P,s) by EXTPRO_1:3
      .= Exec(Divide(a,b), s) by A4,A5,A6,COMPOS_1:148;
   1 in dom Ma by COMPOS_1:147;
    then Ma. 1 = P.1 by A2,GRFUNC_1:8;
    then
A8: P.1 = halt SCM+FSA by COMPOS_1:148;
    IC Exec(Divide(a,b), s) = succ  0 by A4,SCMFSA_2:93
      .= 0+1;
    then
A9: CurInstr(P,Comput(P,s,1))
 = halt SCM+FSA by A8,A7,PBOOLE:158;
    per cases by NAT_1:14;
    suppose
      k = 0;
      hence thesis by EXTPRO_1:3;
    end;
    suppose
A10:   1 <= k;
      Comput(P,s,1).intloc 0 = s.intloc 0 by A7,SCMFSA_2:93;
      hence thesis by A9,A10,EXTPRO_1:6;
    end;
  end;
end;

registration
  let a be Int-Location, f be FinSeq-Location, b be read-write Int-Location;
  cluster b := (f,a) -> keeping_0;
  coherence
  proof
    set Ma = Macro (b:=(f,a));
    let s;
    assume
A1: Initialize Macro (b:=(f,a)) c= s;
    let P be (the Instructions of SCM+FSA)-valued ManySortedSet of NAT;
    assume
A2: Ma c= P;
    let k be Element of NAT;
    dom SA0 = {IC SCM+FSA} by FUNCOP_1:19;
    then
A3: IC SCM+FSA in dom SA0 by TARSKI:def 1;
    SA0 c= Initialize Macro (b:=(f,a)) by FUNCT_4:26;
    then SA0 c= s by A1,XBOOLE_1:1;
    then
A4: IC s = SA0.IC SCM+FSA by A3,GRFUNC_1:8
      .=  0 by FUNCOP_1:87;
  0 in dom Ma by COMPOS_1:147;
    then
A5: Ma. 0 = P.0 by A2,GRFUNC_1:8;
A6:  (P)/.IC s
 = P.IC s by PBOOLE:158;
A7: Comput(P,s,0+1) = Following(P,
Comput(P,s,0)) by EXTPRO_1:4
      .= Following(P,s) by EXTPRO_1:3
      .= Exec(b:=(f,a), s) by A4,A5,A6,COMPOS_1:148;
   1 in dom Ma by COMPOS_1:147;
    then Ma. 1 = P.1 by A2,GRFUNC_1:8;
    then
A8: P.1 = halt SCM+FSA by COMPOS_1:148;
    IC Exec(b:=(f,a), s) = succ  0 by A4,SCMFSA_2:98
      .=  (0+1);
    then
A9: CurInstr(P,Comput(P,s,1))
 = halt SCM+FSA by A8,A7,PBOOLE:158;
    per cases by NAT_1:14;
    suppose
      k = 0;
      hence thesis by EXTPRO_1:3;
    end;
    suppose
A10:   1 <= k;
      Comput(P,s,1).intloc 0 = s.intloc 0 by A7,SCMFSA_2:98;
      hence thesis by A9,A10,EXTPRO_1:6;
    end;
  end;
end;

registration
  let f be FinSeq-Location, b be read-write Int-Location;
  cluster b :=len f -> keeping_0;
  coherence
  proof
    set Ma = Macro (b:=len f);
    let s;
    assume
A1: Initialize Macro (b:=len f) c= s;
    let P be (the Instructions of SCM+FSA)-valued ManySortedSet of NAT;
    assume
A2: Ma c= P;
    let k be Element of NAT;
    dom SA0 = {IC SCM+FSA} by FUNCOP_1:19;
    then
A3: IC SCM+FSA in dom SA0 by TARSKI:def 1;
    SA0 c= Initialize Macro (b:=len f) by FUNCT_4:26;
    then SA0 c= s by A1,XBOOLE_1:1;
    then
A4: IC s = SA0.IC SCM+FSA by A3,GRFUNC_1:8
      .=  0 by FUNCOP_1:87;
  0 in dom Ma by COMPOS_1:147;
    then
A5: Ma. 0 = P.0 by A2,GRFUNC_1:8;
A6:  (P)/.IC s
 = P.IC s by PBOOLE:158;
A7: Comput(P,s,0+1) =
Following(P,Comput(P,s,0))
 by EXTPRO_1:4
      .= Following(P,s) by EXTPRO_1:3
      .= Exec(b:=len f, s) by A4,A5,A6,COMPOS_1:148;
   1 in dom Ma by COMPOS_1:147;
    then Ma. 1 = P.1 by A2,GRFUNC_1:8;
    then
A8: P.1 = halt SCM+FSA by COMPOS_1:148;
    IC Exec(b:=len f, s) = succ  0 by A4,SCMFSA_2:100
      .=  (0+1);
    then
A9: CurInstr(P,Comput(P,s,1))
 = halt SCM+FSA by A8,A7,PBOOLE:158;
    per cases by NAT_1:14;
    suppose
      k = 0;
      hence thesis by EXTPRO_1:3;
    end;
    suppose
A10:   1 <= k;
      Comput(P,s,1).intloc 0 = s.intloc 0 by A7,SCMFSA_2:100;
      hence thesis by A9,A10,EXTPRO_1:6;
    end;
  end;
end;

registration
  let i be parahalting Instruction of SCM+FSA, J be parahalting Program of
  SCM+FSA;
  cluster i ';' J -> parahalting;
  coherence;
end;

registration
  let I be parahalting Program of SCM+FSA, j be parahalting Instruction of
  SCM+FSA;
  cluster I ';' j -> parahalting;
  coherence;
end;

registration
  let i be parahalting Instruction of SCM+FSA, j be parahalting Instruction of
  SCM+FSA;
  cluster i ';' j -> parahalting;
  coherence;
end;

registration
  let i be keeping_0 Instruction of SCM+FSA, J be keeping_0 Program of SCM+FSA;
  cluster i ';' J -> keeping_0;
  coherence;
end;

registration
  let I be keeping_0 Program of SCM+FSA, j be keeping_0 Instruction of SCM+FSA;
  cluster I ';' j -> keeping_0;
  coherence;
end;

registration
  let i, j be keeping_0 Instruction of SCM+FSA;
  cluster i ';' j -> keeping_0;
  coherence;
end;

begin :: Consequenses of the main theorem

registration
  let s be State of SCM+FSA;
  cluster Initialized s -> total;
  coherence
  proof
A1: dom s = the carrier of SCM+FSA by PARTFUN1:def 4;
   thus dom Initialized s
      = dom s \/ {intloc 0} \/ {IC SCM+FSA} by SCMFSA6A:43
     .= dom s \/ {IC SCM+FSA} by A1,ZFMISC_1:46
     .= dom s by COMPOS_1:9,ZFMISC_1:46
     .= the carrier of SCM+FSA by PARTFUN1:def 4;
  end;
end;

theorem Th3:
  IC Initialized s =  0 & (Initialized s).intloc 0 = 1 & (for a
  being read-write Int-Location holds (Initialized s).a = s.a) & (for f holds (
  Initialized s).f = s.f) & for l holds (Initialized s).l = s.l
proof
A1: ((intloc 0) .--> 1).intloc 0 = 1 by FUNCOP_1:87;
  dom SA0 = {IC SCM+FSA} by FUNCOP_1:19;
  then
A2: IC SCM+FSA in dom SA0 by TARSKI:def 1;
A3: Initialized s = Initialize(s +* ((intloc 0) .--> 1)) by FUNCT_4:15;
  SA0.IC SCM+FSA =  0 by FUNCOP_1:87;
  hence IC Initialized s =  0 by A2,FUNCT_4:14,A3;
A4: dom ((intloc 0) .--> 1) = {intloc 0} by FUNCOP_1:19;
  then
A5: intloc 0 in dom ((intloc 0) .--> 1) by TARSKI:def 1;
  not intloc 0 in dom SA0 by SCMFSA6B:9;
  hence (Initialized s).intloc 0 = (s+*((intloc 0) .--> 1)).intloc 0 by
FUNCT_4:12,A3
    .= 1 by A5,A1,FUNCT_4:14;
  hereby
    let a be read-write Int-Location;
A6: not a in dom ((intloc 0) .--> 1) by A4,TARSKI:def 1;
    not a in dom SA0 by SCMFSA6B:9;
    hence (Initialized s).a = (s+*((intloc 0) .--> 1)).a by FUNCT_4:12,A3
      .= s.a by A6,FUNCT_4:12;
  end;
  hereby
    let f be FinSeq-Location;
    intloc 0 <> f by SCMFSA_2:83;
    then
A7: not f in dom ((intloc 0) .--> 1) by A4,TARSKI:def 1;
    not f in dom SA0 by SCMFSA6B:10;
    hence (Initialized s).f = (s+*((intloc 0) .--> 1)).f by FUNCT_4:12,A3
      .= s.f by A7,FUNCT_4:12;
  end;
  let l;
  intloc 0 <> l by SCMFSA_2:84;
  then
A8: not l in dom ((intloc 0) .--> 1) by A4,TARSKI:def 1;
  not l in dom SA0 by COMPOS_1:29;
  hence (Initialized s).l = (s+*((intloc 0) .--> 1)).l by FUNCT_4:12,A3
    .= s.l by A8,FUNCT_4:12;
end;

canceled;

theorem Th5:
  DataPart s1 = DataPart s2 implies DataPart Exec (i, s1) =
  DataPart Exec (i, s2)
proof
  assume
A1: DataPart s1 = DataPart s2;
A2: InsCode i <= 9+1 implies InsCode i <= 8+1 or InsCode i = 10 by NAT_1:8;
A3: InsCode i <= 10+1 implies InsCode i <= 10 or InsCode i = 11 by NAT_1:8;
  set l = i;
A4: InsCode i <= 11+1 by SCMFSA_2:35;
A5: dom Exec(l,s1) = the carrier of SCM+FSA by PARTFUN1:def 4;
  then
A6: dom Exec(l,s1) = dom Exec(l,s2) by PARTFUN1:def 4;
A7: dom ((Exec (l,s1)) | (Data-Locations SCM+FSA)) = (
  Data-Locations SCM+FSA) by A5,RELAT_1:91;
A8: dom Exec(l,s2) = the carrier of SCM+FSA by PARTFUN1:def 4;
  then
A9: dom ((Exec (l,s2)) | (Data-Locations SCM+FSA)) = (
  Data-Locations SCM+FSA) by RELAT_1:91;
  per cases by A4,A3,A2,NAT_1:8,33;
  suppose
    InsCode i = 0;
    then
A10: i = halt SCM+FSA by SCMFSA_2:122;
    then Exec (i,s1) = s1 by EXTPRO_1:def 3;
    hence thesis by A1,A10,EXTPRO_1:def 3;
  end;
  suppose
    InsCode i = 1;
    then consider db,da being Int-Location such that
A11: l = db := da by SCMFSA_2:54;
A12: for x being set st x in ((Data-Locations SCM+FSA) \ {db})
holds (Exec (l,s1) | (Data-Locations SCM+FSA \ {db})).x = (Exec (l,
    s2) | (Data-Locations SCM+FSA \ {db})).x
    proof
      let x be set;
      assume
A13:  x in ((Data-Locations SCM+FSA) \ {db});
      then
A14:  x in Data-Locations SCM+FSA by XBOOLE_0:def 5;
A15:  not x in {db} by A13,XBOOLE_0:def 5;
      per cases by A14,XBOOLE_0:def 3,SCMFSA_2:127;
      suppose
        x in Int-Locations;
        then reconsider a = x as Int-Location by SCMFSA_2:11;
A16:    a <> db by A15,TARSKI:def 1;
        thus (Exec (l,s1) | (Data-Locations SCM+FSA \ {db})).x = (
        Exec (l,s1)).a by A13,FUNCT_1:72
          .= s1.a by A11,A16,SCMFSA_2:89
          .= (DataPart s1).a by A14,FUNCT_1:72
          .= s2.a by A1,A14,FUNCT_1:72
          .= (Exec (l,s2)).a by A11,A16,SCMFSA_2:89
          .= (Exec (l,s2) | (Data-Locations SCM+FSA \ {db})).x by
A13,FUNCT_1:72;
      end;
      suppose
        x in FinSeq-Locations;
        then reconsider a = x as FinSeq-Location by SCMFSA_2:12;
        thus (Exec (l,s1) | (Data-Locations SCM+FSA \ {db})).x = (
        Exec (l,s1)).a by A13,FUNCT_1:72
          .= s1.a by A11,SCMFSA_2:89
          .= (DataPart s1).a by A14,FUNCT_1:72
          .= s2.a by A1,A14,FUNCT_1:72
          .= (Exec (l,s2)).a by A11,SCMFSA_2:89
          .= (Exec (l,s2) | (Data-Locations SCM+FSA \ {db})).x by
A13,FUNCT_1:72;
      end;
    end;
A17: dom ((Exec (l,s2)) | (Data-Locations SCM+FSA \ {db})) = (
    Data-Locations SCM+FSA \ {db}) by A8,RELAT_1:91;
    dom ((Exec (l,s1)) | (Data-Locations SCM+FSA \ {db})) = (
    Data-Locations SCM+FSA \ {db}) by A5,RELAT_1:91;
    then
A18: Exec (l,s1) | (Data-Locations SCM+FSA \ {db} ) = Exec (l,
    s2) | (Data-Locations SCM+FSA \ {db} ) by A17,A12,FUNCT_1:9;
    db in Int-Locations by SCMFSA_2:9;
    then db in Data-Locations SCM+FSA by XBOOLE_0:def 3,SCMFSA_2:127;
    then
A19: Data-Locations SCM+FSA = Data-Locations SCM+FSA
    \/ {db} by ZFMISC_1:46
      .= (Data-Locations SCM+FSA \ {db} ) \/ {db} by XBOOLE_1:39;
A20: Exec(l, s2).db = s2.da by A11,SCMFSA_2:89;
A21: Exec(l, s1).db = s1.da by A11,SCMFSA_2:89;
    da in Int-Locations by SCMFSA_2:9;
    then
A22: da in Data-Locations SCM+FSA by XBOOLE_0:def 3,SCMFSA_2:127;
    then s1.da = (DataPart s1).da by FUNCT_1:72
      .= s2.da by A1,A22,FUNCT_1:72;
    then Exec (l,s1) | {db} = Exec(l,s2) | {db} by A6,A21,A20,GRFUNC_1:90;
    hence thesis by A19,A18,RELAT_1:185;
  end;
  suppose
    InsCode i = 2;
    then consider db,da being Int-Location such that
A23: l = AddTo(db,da) by SCMFSA_2:55;
A24: for x being set st x in ((Data-Locations SCM+FSA) \ {db})
holds (Exec (l,s1) | (Data-Locations SCM+FSA \ {db})).x = (Exec (l,
    s2) | (Data-Locations SCM+FSA \ {db})).x
    proof
      let x be set;
      assume
A25:  x in ((Data-Locations SCM+FSA) \ {db});
      then
A26:  x in Data-Locations SCM+FSA by XBOOLE_0:def 5;
A27:  not x in {db} by A25,XBOOLE_0:def 5;
      per cases by A26,XBOOLE_0:def 3,SCMFSA_2:127;
      suppose
        x in Int-Locations;
        then reconsider a = x as Int-Location by SCMFSA_2:11;
A28:    a <> db by A27,TARSKI:def 1;
        thus (Exec (l,s1) | (Data-Locations SCM+FSA \ {db})).x = (
        Exec (l,s1)).a by A25,FUNCT_1:72
          .= s1.a by A23,A28,SCMFSA_2:90
          .= (DataPart s1).a by A26,FUNCT_1:72
          .= s2.a by A1,A26,FUNCT_1:72
          .= (Exec (l,s2)).a by A23,A28,SCMFSA_2:90
          .= (Exec (l,s2) | (Data-Locations SCM+FSA \ {db})).x by
A25,FUNCT_1:72;
      end;
      suppose
        x in FinSeq-Locations;
        then reconsider a = x as FinSeq-Location by SCMFSA_2:12;
        thus (Exec (l,s1) | (Data-Locations SCM+FSA \ {db})).x = (
        Exec (l,s1)).a by A25,FUNCT_1:72
          .= s1.a by A23,SCMFSA_2:90
          .= (DataPart s1).a by A26,FUNCT_1:72
          .= s2.a by A1,A26,FUNCT_1:72
          .= (Exec (l,s2)).a by A23,SCMFSA_2:90
          .= (Exec (l,s2) | (Data-Locations SCM+FSA \ {db})).x by
A25,FUNCT_1:72;
      end;
    end;
A29: dom ((Exec (l,s2)) | (Data-Locations SCM+FSA \ {db})) = (
    Data-Locations SCM+FSA \ {db}) by A8,RELAT_1:91;
    dom ((Exec (l,s1)) | (Data-Locations SCM+FSA \ {db})) = (
    Data-Locations SCM+FSA \ {db}) by A5,RELAT_1:91;
    then
A30: Exec (l,s1) | (Data-Locations SCM+FSA \ {db} ) = Exec (l,
    s2) | (Data-Locations SCM+FSA \ {db} ) by A29,A24,FUNCT_1:9;
    db in Int-Locations by SCMFSA_2:9;
    then db in Data-Locations SCM+FSA by XBOOLE_0:def 3,SCMFSA_2:127;
    then
A31: Data-Locations SCM+FSA = Data-Locations SCM+FSA
    \/ {db} by ZFMISC_1:46
      .= (Data-Locations SCM+FSA \ {db} ) \/ {db} by XBOOLE_1:39;
A32: Exec(l, s2).db = s2.db + s2.da by A23,SCMFSA_2:90;
A33: Exec(l, s1).db = s1.db + s1.da by A23,SCMFSA_2:90;
    db in Int-Locations by SCMFSA_2:9;
    then
A34: db in Data-Locations SCM+FSA by XBOOLE_0:def 3,SCMFSA_2:127;
    then
A35: s1.db = (DataPart s1).db by FUNCT_1:72
      .= s2.db by A1,A34,FUNCT_1:72;
    da in Int-Locations by SCMFSA_2:9;
    then
A36: da in Data-Locations SCM+FSA by XBOOLE_0:def 3,SCMFSA_2:127;
    then s1.da = (DataPart s1).da by FUNCT_1:72
      .= s2.da by A1,A36,FUNCT_1:72;
    then Exec (l,s1) | {db} = Exec(l,s2) | {db} by A6,A33,A32,A35,GRFUNC_1:90;
    hence thesis by A31,A30,RELAT_1:185;
  end;
  suppose
    InsCode i = 3;
    then consider db,da being Int-Location such that
A37: l = SubFrom(db,da) by SCMFSA_2:56;
A38: for x being set st x in ((Data-Locations SCM+FSA) \ {db})
holds (Exec (l,s1) | (Data-Locations SCM+FSA \ {db})).x = (Exec (l,
    s2) | (Data-Locations SCM+FSA \ {db})).x
    proof
      let x be set;
      assume
A39:  x in ((Data-Locations SCM+FSA) \ {db});
      then
A40:  x in Data-Locations SCM+FSA by XBOOLE_0:def 5;
A41:  not x in {db} by A39,XBOOLE_0:def 5;
      per cases by A40,XBOOLE_0:def 3,SCMFSA_2:127;
      suppose
        x in Int-Locations;
        then reconsider a = x as Int-Location by SCMFSA_2:11;
A42:    a <> db by A41,TARSKI:def 1;
        thus (Exec (l,s1) | (Data-Locations SCM+FSA \ {db})).x = (
        Exec (l,s1)).a by A39,FUNCT_1:72
          .= s1.a by A37,A42,SCMFSA_2:91
          .= (DataPart s1).a by A40,FUNCT_1:72
          .= s2.a by A1,A40,FUNCT_1:72
          .= (Exec (l,s2)).a by A37,A42,SCMFSA_2:91
          .= (Exec (l,s2) | (Data-Locations SCM+FSA \ {db})).x by
A39,FUNCT_1:72;
      end;
      suppose
        x in FinSeq-Locations;
        then reconsider a = x as FinSeq-Location by SCMFSA_2:12;
        thus (Exec (l,s1) | (Data-Locations SCM+FSA \ {db})).x = (
        Exec (l,s1)).a by A39,FUNCT_1:72
          .= s1.a by A37,SCMFSA_2:91
          .= (DataPart s1).a by A40,FUNCT_1:72
          .= s2.a by A1,A40,FUNCT_1:72
          .= (Exec (l,s2)).a by A37,SCMFSA_2:91
          .= (Exec (l,s2) | (Data-Locations SCM+FSA \ {db})).x by
A39,FUNCT_1:72;
      end;
    end;
A43: dom ((Exec (l,s2)) | (Data-Locations SCM+FSA \ {db})) = (
    Data-Locations SCM+FSA \ {db}) by A8,RELAT_1:91;
    dom ((Exec (l,s1)) | (Data-Locations SCM+FSA \ {db})) = (
    Data-Locations SCM+FSA \ {db}) by A5,RELAT_1:91;
    then
A44: Exec (l,s1) | (Data-Locations SCM+FSA \ {db} ) = Exec (l,
    s2) | (Data-Locations SCM+FSA \ {db} ) by A43,A38,FUNCT_1:9;
    db in Int-Locations by SCMFSA_2:9;
    then db in Data-Locations SCM+FSA by XBOOLE_0:def 3,SCMFSA_2:127;
    then
A45: Data-Locations SCM+FSA = Data-Locations SCM+FSA
    \/ {db} by ZFMISC_1:46
      .= (Data-Locations SCM+FSA \ {db} ) \/ {db} by XBOOLE_1:39;
A46: Exec(l, s2).db = s2.db - s2.da by A37,SCMFSA_2:91;
A47: Exec(l, s1).db = s1.db - s1.da by A37,SCMFSA_2:91;
    db in Int-Locations by SCMFSA_2:9;
    then
A48: db in Data-Locations SCM+FSA by XBOOLE_0:def 3,SCMFSA_2:127;
    then
A49: s1.db = (DataPart s1).db by FUNCT_1:72
      .= s2.db by A1,A48,FUNCT_1:72;
    da in Int-Locations by SCMFSA_2:9;
    then
A50: da in Data-Locations SCM+FSA by XBOOLE_0:def 3,SCMFSA_2:127;
    then s1.da = (DataPart s1).da by FUNCT_1:72
      .= s2.da by A1,A50,FUNCT_1:72;
    then Exec (l,s1) | {db} = Exec(l,s2) | {db} by A6,A47,A46,A49,GRFUNC_1:90;
    hence thesis by A45,A44,RELAT_1:185;
  end;
  suppose
    InsCode i = 4;
    then consider db,da being Int-Location such that
A51: l = MultBy(db,da) by SCMFSA_2:57;
A52: for x being set st x in ((Data-Locations SCM+FSA) \ {db})
holds (Exec (l,s1) | (Data-Locations SCM+FSA \ {db})).x = (Exec (l,
    s2) | (Data-Locations SCM+FSA \ {db})).x
    proof
      let x be set;
      assume
A53:  x in ((Data-Locations SCM+FSA) \ {db});
      then
A54:  x in Data-Locations SCM+FSA by XBOOLE_0:def 5;
A55:  not x in {db} by A53,XBOOLE_0:def 5;
      per cases by A54,XBOOLE_0:def 3,SCMFSA_2:127;
      suppose
        x in Int-Locations;
        then reconsider a = x as Int-Location by SCMFSA_2:11;
A56:    a <> db by A55,TARSKI:def 1;
        thus (Exec (l,s1) | (Data-Locations SCM+FSA \ {db})).x = (
        Exec (l,s1)).a by A53,FUNCT_1:72
          .= s1.a by A51,A56,SCMFSA_2:92
          .= (DataPart s1).a by A54,FUNCT_1:72
          .= s2.a by A1,A54,FUNCT_1:72
          .= (Exec (l,s2)).a by A51,A56,SCMFSA_2:92
          .= (Exec (l,s2) | (Data-Locations SCM+FSA \ {db})).x by
A53,FUNCT_1:72;
      end;
      suppose
        x in FinSeq-Locations;
        then reconsider a = x as FinSeq-Location by SCMFSA_2:12;
        thus (Exec (l,s1) | (Data-Locations SCM+FSA \ {db})).x = (
        Exec (l,s1)).a by A53,FUNCT_1:72
          .= s1.a by A51,SCMFSA_2:92
          .= (DataPart s1).a by A54,FUNCT_1:72
          .= s2.a by A1,A54,FUNCT_1:72
          .= (Exec (l,s2)).a by A51,SCMFSA_2:92
          .= (Exec (l,s2) | (Data-Locations SCM+FSA \ {db})).x by
A53,FUNCT_1:72;
      end;
    end;
A57: dom ((Exec (l,s2)) | (Data-Locations SCM+FSA \ {db})) = (
    Data-Locations SCM+FSA \ {db}) by A8,RELAT_1:91;
    dom ((Exec (l,s1)) | (Data-Locations SCM+FSA \ {db})) = (
    Data-Locations SCM+FSA \ {db}) by A5,RELAT_1:91;
    then
A58: Exec (l,s1) | (Data-Locations SCM+FSA \ {db} ) = Exec (l,
    s2) | (Data-Locations SCM+FSA \ {db} ) by A57,A52,FUNCT_1:9;
    db in Int-Locations by SCMFSA_2:9;
    then db in Data-Locations SCM+FSA by XBOOLE_0:def 3,SCMFSA_2:127;
    then
A59: Data-Locations SCM+FSA = Data-Locations SCM+FSA
    \/ {db} by ZFMISC_1:46
      .= (Data-Locations SCM+FSA \ {db} ) \/ {db} by XBOOLE_1:39;
A60: Exec(l, s2).db = s2.db * s2.da by A51,SCMFSA_2:92;
A61: Exec(l, s1).db = s1.db * s1.da by A51,SCMFSA_2:92;
    db in Int-Locations by SCMFSA_2:9;
    then
A62: db in Data-Locations SCM+FSA by XBOOLE_0:def 3,SCMFSA_2:127;
    then
A63: s1.db = (DataPart s1).db by FUNCT_1:72
      .= s2.db by A1,A62,FUNCT_1:72;
    da in Int-Locations by SCMFSA_2:9;
    then
A64: da in Data-Locations SCM+FSA by XBOOLE_0:def 3,SCMFSA_2:127;
    then s1.da = (DataPart s1).da by FUNCT_1:72
      .= s2.da by A1,A64,FUNCT_1:72;
    then Exec (l,s1) | {db} = Exec(l,s2) | {db} by A6,A61,A60,A63,GRFUNC_1:90;
    hence thesis by A59,A58,RELAT_1:185;
  end;
  suppose
    InsCode i = 5;
    then consider db,da being Int-Location such that
A65: l = Divide(db,da) by SCMFSA_2:58;
    hereby
      per cases;
      suppose
A66:    da <> db;
A67:    for x being set st x in ((Data-Locations SCM+FSA) \ {
db,da} ) holds (Exec (l,s1) | (Data-Locations SCM+FSA \ {db,da})).x
        = (Exec (l,s2) | (Data-Locations SCM+FSA \ {db,da})).x
        proof
          let x be set;
          assume
A68:      x in ((Data-Locations SCM+FSA) \ {db,da});
          then
A69:      x in Data-Locations SCM+FSA by XBOOLE_0:def 5;
A70:      not x in {db,da} by A68,XBOOLE_0:def 5;
          per cases by A69,XBOOLE_0:def 3,SCMFSA_2:127;
          suppose
            x in Int-Locations;
            then reconsider a = x as Int-Location by SCMFSA_2:11;
A71:        a <> da by A70,TARSKI:def 2;
A72:        a <> db by A70,TARSKI:def 2;
            thus (Exec (l,s1) | (Data-Locations SCM+FSA \ {db,da}))
            .x = (Exec (l,s1)).a by A68,FUNCT_1:72
              .= s1.a by A65,A71,A72,SCMFSA_2:93
              .= (DataPart s1).a by A69,FUNCT_1:72
              .= s2.a by A1,A69,FUNCT_1:72
              .= (Exec (l,s2)).a by A65,A71,A72,SCMFSA_2:93
              .= (Exec (l,s2) | (Data-Locations SCM+FSA \ {db,da}
            )).x by A68,FUNCT_1:72;
          end;
          suppose
            x in FinSeq-Locations;
            then reconsider a = x as FinSeq-Location by SCMFSA_2:12;
            thus (Exec (l,s1) | (Data-Locations SCM+FSA \ {db,da}))
            .x = (Exec (l,s1)).a by A68,FUNCT_1:72
              .= s1.a by A65,SCMFSA_2:93
              .= (DataPart s1).a by A69,FUNCT_1:72
              .= s2.a by A1,A69,FUNCT_1:72
              .= (Exec (l,s2)).a by A65,SCMFSA_2:93
              .= (Exec (l,s2) | (Data-Locations SCM+FSA \ {db,da}
            )).x by A68,FUNCT_1:72;
          end;
        end;
A73:    dom ((Exec (l,s2)) | (Data-Locations SCM+FSA \ {db,da
        })) = (Data-Locations SCM+FSA \ {db,da}) by A8,RELAT_1:91;
        dom ((Exec (l,s1)) | (Data-Locations SCM+FSA \ {db,da
        })) = (Data-Locations SCM+FSA \ {db,da}) by A5,RELAT_1:91;
        then
A74:    Exec (l,s1) | (Data-Locations SCM+FSA \ {db,da} ) =
Exec (l,s2) | (Data-Locations SCM+FSA \ {db,da} ) by A73,A67,
FUNCT_1:9;
A75:    Exec(l, s2).da = s2.db mod s2.da by A65,SCMFSA_2:93;
        db in Int-Locations by SCMFSA_2:9;
        then
A76:    db in Data-Locations SCM+FSA by XBOOLE_0:def 3,SCMFSA_2:127;
        then
A77:    s1.db = (DataPart s1).db by FUNCT_1:72
          .= s2.db by A1,A76,FUNCT_1:72;
        da in Int-Locations by SCMFSA_2:9;
        then
A78:    da in Data-Locations SCM+FSA by XBOOLE_0:def 3,SCMFSA_2:127;
        db in Int-Locations by SCMFSA_2:9;
        then db in Data-Locations SCM+FSA by XBOOLE_0:def 3,SCMFSA_2:127;
        then
A79:    Data-Locations SCM+FSA
          = Data-Locations SCM+FSA \/ {db,da} by A78,ZFMISC_1:48
          .= (Data-Locations SCM+FSA \ {db,da} ) \/ {db,da} by
XBOOLE_1:39;
A80:    Exec(l, s1).da = s1.db mod s1.da by A65,SCMFSA_2:93;
A81:    Exec(l, s2).db = s2.db div s2.da by A65,A66,SCMFSA_2:93;
A82:    Exec(l, s1).db = s1.db div s1.da by A65,A66,SCMFSA_2:93;
        da in Int-Locations by SCMFSA_2:9;
        then
A83:    da in Data-Locations SCM+FSA by XBOOLE_0:def 3,SCMFSA_2:127;
        then s1.da = (DataPart s1).da by FUNCT_1:72
          .= s2.da by A1,A83,FUNCT_1:72;
        then Exec (l,s1) | {db,da} = Exec(l,s2) | {db,da} by A6,A82,A80,A81,A75
,A77,GRFUNC_1:91;
        hence thesis by A79,A74,RELAT_1:185;
      end;
      suppose
A84:    da = db;
A85:    for x being set st x in ((Data-Locations SCM+FSA) \ {
db}) holds (Exec (l,s1) | (Data-Locations SCM+FSA \ {db})).x = (Exec
        (l,s2) | (Data-Locations SCM+FSA \ {db})).x
        proof
          let x be set;
          assume
A86:      x in ((Data-Locations SCM+FSA) \ {db});
          then
A87:      x in Data-Locations SCM+FSA by XBOOLE_0:def 5;
A88:      not x in {db} by A86,XBOOLE_0:def 5;
          per cases by A87,XBOOLE_0:def 3,SCMFSA_2:127;
          suppose
            x in Int-Locations;
            then reconsider a = x as Int-Location by SCMFSA_2:11;
A89:        a <> db by A88,TARSKI:def 1;
            thus (Exec (l,s1) | (Data-Locations SCM+FSA \ {db})).x
            = (Exec (l,s1)).a by A86,FUNCT_1:72
              .= s1.a by A65,A84,A89,SCMFSA_2:94
              .= (DataPart s1).a by A87,FUNCT_1:72
              .= s2.a by A1,A87,FUNCT_1:72
              .= (Exec (l,s2)).a by A65,A84,A89,SCMFSA_2:94
              .= (Exec (l,s2) | (Data-Locations SCM+FSA \ {db})).
            x by A86,FUNCT_1:72;
          end;
          suppose
            x in FinSeq-Locations;
            then reconsider a = x as FinSeq-Location by SCMFSA_2:12;
            thus (Exec (l,s1) | (Data-Locations SCM+FSA \ {db})).x
            = (Exec (l,s1)).a by A86,FUNCT_1:72
              .= s1.a by A65,A84,SCMFSA_2:94
              .= (s1 | (Data-Locations SCM+FSA)).a by A87,FUNCT_1:72
              .= s2.a by A1,A87,FUNCT_1:72
              .= (Exec (l,s2)).a by A65,A84,SCMFSA_2:94
              .= (Exec (l,s2) | (Data-Locations SCM+FSA \ {db})).
            x by A86,FUNCT_1:72;
          end;
        end;
A90:    dom ((Exec (l,s2)) | (Data-Locations SCM+FSA \ {db}))
        = (Data-Locations SCM+FSA \ {db}) by A8,RELAT_1:91;
        dom ((Exec (l,s1)) | (Data-Locations SCM+FSA \ {db}))
        = (Data-Locations SCM+FSA \ {db}) by A5,RELAT_1:91;
        then
A91:    Exec (l,s1) | (Data-Locations SCM+FSA \ {db} ) = Exec
(l,s2) | (Data-Locations SCM+FSA \ {db} ) by A90,A85,FUNCT_1:9;
        db in Int-Locations by SCMFSA_2:9;
        then db in Data-Locations SCM+FSA by XBOOLE_0:def 3,SCMFSA_2:127;
        then
A92:    Data-Locations SCM+FSA = Data-Locations SCM+FSA \/ {db} by ZFMISC_1:46
          .= (Data-Locations SCM+FSA \ {db} ) \/ {db} by XBOOLE_1:39
;
A93:    Exec(l, s2).db = s2.db mod s2.da by A65,A84,SCMFSA_2:94;
A94:    Exec(l, s1).db = s1.db mod s1.da by A65,A84,SCMFSA_2:94;
        db in Int-Locations by SCMFSA_2:9;
        then
A95:    db in Data-Locations SCM+FSA by XBOOLE_0:def 3,SCMFSA_2:127;
        then
A96:    s1.db = (DataPart s1).db by FUNCT_1:72
          .= s2.db by A1,A95,FUNCT_1:72;
        da in Int-Locations by SCMFSA_2:9;
        then
A97:    da in Data-Locations SCM+FSA by XBOOLE_0:def 3,SCMFSA_2:127;
        then s1.da = (DataPart s1).da by FUNCT_1:72
          .= s2.da by A1,A97,FUNCT_1:72;
        then Exec (l,s1) | {db} = Exec(l,s2) | {db} by A6,A94,A93,A96,
GRFUNC_1:90;
        hence thesis by A92,A91,RELAT_1:185;
      end;
    end;
  end;
  suppose
    InsCode i = 6;
    then
A98: ex l1 st i = goto l1 by SCMFSA_2:59;
    for x being set st x in ((Data-Locations SCM+FSA)) holds
    (DataPart Exec (l,s1)).x = (DataPart Exec (l,s2)).x
    proof
      let x be set;
      assume
A99:  x in ((Data-Locations SCM+FSA));
      per cases by A99,XBOOLE_0:def 3,SCMFSA_2:127;
      suppose
        x in Int-Locations;
        then reconsider a = x as Int-Location by SCMFSA_2:11;
        thus (DataPart Exec (l,s1)).x = (Exec (l,s1)).a by A99,FUNCT_1:72

          .= s1.a by A98,SCMFSA_2:95
          .= (DataPart s1).a by A99,FUNCT_1:72
          .= s2.a by A1,A99,FUNCT_1:72
          .= (Exec (l,s2)).a by A98,SCMFSA_2:95
          .= (DataPart Exec (l,s2)).x by A99,FUNCT_1:72;
      end;
      suppose
        x in FinSeq-Locations;
        then reconsider a = x as FinSeq-Location by SCMFSA_2:12;
        thus (DataPart Exec (l,s1)).x = (Exec (l,s1)).a by A99,FUNCT_1:72

          .= s1.a by A98,SCMFSA_2:95
          .= (DataPart s1).a by A99,FUNCT_1:72
          .= s2.a by A1,A99,FUNCT_1:72
          .= (Exec (l,s2)).a by A98,SCMFSA_2:95
          .= (DataPart Exec (l,s2)).x by A99,FUNCT_1:72;
      end;
    end;
    hence thesis by A7,A9,FUNCT_1:9;
  end;
  suppose
    InsCode i = 7;
    then
A100: ex l1, a st i = a=0_goto l1 by SCMFSA_2:60;
    for x being set st x in ((Data-Locations SCM+FSA)) holds
    (DataPart Exec (l,s1)).x = (DataPart Exec (l,s2)).x
    proof
      let x be set;
      assume
A101: x in ((Data-Locations SCM+FSA));
      per cases by A101,XBOOLE_0:def 3,SCMFSA_2:127;
      suppose
        x in Int-Locations;
        then reconsider a = x as Int-Location by SCMFSA_2:11;
        thus (DataPart Exec (l,s1)).x = (Exec (l,s1)).a by A101,FUNCT_1:72

          .= s1.a by A100,SCMFSA_2:96
          .= (DataPart s1).a by A101,FUNCT_1:72
          .= s2.a by A1,A101,FUNCT_1:72
          .= (Exec (l,s2)).a by A100,SCMFSA_2:96
          .= (DataPart Exec (l,s2)).x by A101,FUNCT_1:72;
      end;
      suppose
        x in FinSeq-Locations;
        then reconsider a = x as FinSeq-Location by SCMFSA_2:12;
        thus (DataPart Exec (l,s1)).x = (Exec (l,s1)).a by A101,FUNCT_1:72

          .= s1.a by A100,SCMFSA_2:96
          .= (DataPart s1).a by A101,FUNCT_1:72
          .= s2.a by A1,A101,FUNCT_1:72
          .= (Exec (l,s2)).a by A100,SCMFSA_2:96
          .= (DataPart Exec (l,s2)).x by A101,FUNCT_1:72;
      end;
    end;
    hence thesis by A7,A9,FUNCT_1:9;
  end;
  suppose
    InsCode i = 8;
    then
A102: ex l1, a st i = a>0_goto l1 by SCMFSA_2:61;
    for x being set st x in ((Data-Locations SCM+FSA)) holds
    (DataPart Exec (l,s1)).x = (DataPart Exec (l,s2)).x
    proof
      let x be set;
      assume
A103: x in ((Data-Locations SCM+FSA));
      per cases by A103,XBOOLE_0:def 3,SCMFSA_2:127;
      suppose
        x in Int-Locations;
        then reconsider a = x as Int-Location by SCMFSA_2:11;
        thus (DataPart Exec (l,s1)).x = (Exec (l,s1)).a by A103,FUNCT_1:72

          .= s1.a by A102,SCMFSA_2:97
          .= (DataPart s1).a by A103,FUNCT_1:72
          .= s2.a by A1,A103,FUNCT_1:72
          .= (Exec (l,s2)).a by A102,SCMFSA_2:97
          .= (DataPart Exec (l,s2)).x by A103,FUNCT_1:72;
      end;
      suppose
        x in FinSeq-Locations;
        then reconsider a = x as FinSeq-Location by SCMFSA_2:12;
        thus (DataPart Exec (l,s1)).x = (Exec (l,s1)).a by A103,FUNCT_1:72

          .= s1.a by A102,SCMFSA_2:97
          .= (DataPart s1).a by A103,FUNCT_1:72
          .= s2.a by A1,A103,FUNCT_1:72
          .= (Exec (l,s2)).a by A102,SCMFSA_2:97
          .= (DataPart Exec (l,s2)).x by A103,FUNCT_1:72;
      end;
    end;
    hence thesis by A7,A9,FUNCT_1:9;
  end;
  suppose
    InsCode i = 9;
    then consider da,db being Int-Location, fa being FinSeq-Location such that
A104: l = db:=(fa,da) by SCMFSA_2:62;
A105: for x being set st x in ((Data-Locations SCM+FSA) \ {db})
holds (Exec (l,s1) | (Data-Locations SCM+FSA \ {db})).x = (Exec (l,
    s2) | (Data-Locations SCM+FSA \ {db})).x
    proof
      let x be set;
      assume
A106: x in ((Data-Locations SCM+FSA) \ {db});
      then
A107: x in Data-Locations SCM+FSA by XBOOLE_0:def 5;
A108: not x in {db} by A106,XBOOLE_0:def 5;
      per cases by A107,XBOOLE_0:def 3,SCMFSA_2:127;
      suppose
        x in Int-Locations;
        then reconsider a = x as Int-Location by SCMFSA_2:11;
A109:   a <> db by A108,TARSKI:def 1;
        thus (Exec (l,s1) | (Data-Locations SCM+FSA \ {db})).x = (
        Exec (l,s1)).a by A106,FUNCT_1:72
          .= s1.a by A104,A109,SCMFSA_2:98
          .= (DataPart s1).a by A107,FUNCT_1:72
          .= s2.a by A1,A107,FUNCT_1:72
          .= (Exec (l,s2)).a by A104,A109,SCMFSA_2:98
          .= (Exec (l,s2) | (Data-Locations SCM+FSA \ {db})).x by
A106,FUNCT_1:72;
      end;
      suppose
        x in FinSeq-Locations;
        then reconsider a = x as FinSeq-Location by SCMFSA_2:12;
        thus (Exec (l,s1) | (Data-Locations SCM+FSA \ {db})).x = (
        Exec (l,s1)).a by A106,FUNCT_1:72
          .= s1.a by A104,SCMFSA_2:98
          .= (DataPart s1).a by A107,FUNCT_1:72
          .= s2.a by A1,A107,FUNCT_1:72
          .= (Exec (l,s2)).a by A104,SCMFSA_2:98
          .= (Exec (l,s2) | (Data-Locations SCM+FSA \ {db})).x by
A106,FUNCT_1:72;
      end;
    end;
A110: dom ((Exec (l,s2)) | (Data-Locations SCM+FSA \ {db})) = (
    Data-Locations SCM+FSA \ {db}) by A8,RELAT_1:91;
    dom ((Exec (l,s1)) | (Data-Locations SCM+FSA \ {db})) = (
    Data-Locations SCM+FSA \ {db}) by A5,RELAT_1:91;
    then
A111: Exec (l,s1) | (Data-Locations SCM+FSA \ {db} ) = Exec (l,
    s2) | (Data-Locations SCM+FSA \ {db} ) by A110,A105,FUNCT_1:9;
    db in Int-Locations by SCMFSA_2:9;
    then db in Data-Locations SCM+FSA by XBOOLE_0:def 3,SCMFSA_2:127;
    then
A112: Data-Locations SCM+FSA = Data-Locations SCM+FSA \/ {db} by ZFMISC_1:46
      .= (Data-Locations SCM+FSA \ {db} ) \/ {db} by XBOOLE_1:39;
A113: ex k2 being Element of NAT st k2 = abs(s2.da) & Exec(l, s2).db = (
    s2.fa)/.k2 by A104,SCMFSA_2:98;
A114: ex k1 being Element of NAT st k1 = abs(s1.da) & Exec(l, s1).db = (
    s1.fa)/.k1 by A104,SCMFSA_2:98;
    fa in FinSeq-Locations by SCMFSA_2:10;
    then
A115: fa in Data-Locations SCM+FSA by XBOOLE_0:def 3,SCMFSA_2:127;
    then
A116: s1.fa = (DataPart s1).fa by FUNCT_1:72
      .= s2.fa by A1,A115,FUNCT_1:72;
    da in Int-Locations by SCMFSA_2:9;
    then
A117: da in Data-Locations SCM+FSA by XBOOLE_0:def 3,SCMFSA_2:127;
    then s1.da = (DataPart s1).da by FUNCT_1:72
      .= s2.da by A1,A117,FUNCT_1:72;
    then Exec (l,s1) | {db} = Exec(l,s2) | {db} by A6,A114,A113,A116,
GRFUNC_1:90;
    hence thesis by A112,A111,RELAT_1:185;
  end;
  suppose
    InsCode i = 10;
    then consider da,db being Int-Location, fa being FinSeq-Location such that
A118: l = (fa,da):=db by SCMFSA_2:63;
A119: for x being set st x in ((Data-Locations SCM+FSA) \ {fa})
holds (Exec (l,s1) | (Data-Locations SCM+FSA \ {fa})).x = (Exec (l,
    s2) | (Data-Locations SCM+FSA \ {fa})).x
    proof
      let x be set;
      assume
A120: x in ((Data-Locations SCM+FSA) \ {fa});
      then
A121: x in Data-Locations SCM+FSA by XBOOLE_0:def 5;
A122: not x in {fa} by A120,XBOOLE_0:def 5;
      per cases by A121,XBOOLE_0:def 3,SCMFSA_2:127;
      suppose
        x in Int-Locations;
        then reconsider a = x as Int-Location by SCMFSA_2:11;
        thus (Exec (l,s1) | (Data-Locations SCM+FSA \ {fa})).x = (
        Exec (l,s1)).a by A120,FUNCT_1:72
          .= s1.a by A118,SCMFSA_2:99
          .= (DataPart s1).a by A121,FUNCT_1:72
          .= s2.a by A1,A121,FUNCT_1:72
          .= (Exec (l,s2)).a by A118,SCMFSA_2:99
          .= (Exec (l,s2) | (Data-Locations SCM+FSA \ {fa})).x by
A120,FUNCT_1:72;
      end;
      suppose
        x in FinSeq-Locations;
        then reconsider a = x as FinSeq-Location by SCMFSA_2:12;
A123:   a <> fa by A122,TARSKI:def 1;
        thus (Exec (l,s1) | (Data-Locations SCM+FSA \ {fa})).x = (
        Exec (l,s1)).a by A120,FUNCT_1:72
          .= s1.a by A118,A123,SCMFSA_2:99
          .= (DataPart s1).a by A121,FUNCT_1:72
          .= s2.a by A1,A121,FUNCT_1:72
          .= (Exec (l,s2)).a by A118,A123,SCMFSA_2:99
          .= (Exec (l,s2) | (Data-Locations SCM+FSA \ {fa})).x by
A120,FUNCT_1:72;
      end;
    end;
A124: dom ((Exec (l,s2)) | (Data-Locations SCM+FSA \ {fa})) = (
    Data-Locations SCM+FSA \ {fa}) by A8,RELAT_1:91;
    dom ((Exec (l,s1)) | (Data-Locations SCM+FSA \ {fa})) = (
    Data-Locations SCM+FSA \ {fa}) by A5,RELAT_1:91;
    then
A125: Exec (l,s1) | (Data-Locations SCM+FSA \ {fa} ) = Exec (l,
    s2) | (Data-Locations SCM+FSA \ {fa} ) by A124,A119,FUNCT_1:9;
    fa in FinSeq-Locations by SCMFSA_2:10;
    then fa in Data-Locations SCM+FSA by XBOOLE_0:def 3,SCMFSA_2:127;
    then
A126: Data-Locations SCM+FSA = Data-Locations SCM+FSA \/ {fa} by ZFMISC_1:46
      .= (Data-Locations SCM+FSA \ {fa} ) \/ {fa} by XBOOLE_1:39;
    fa in FinSeq-Locations by SCMFSA_2:10;
    then
A127: fa in Data-Locations SCM+FSA by XBOOLE_0:def 3,SCMFSA_2:127;
    then
A128: s1.fa = (DataPart s1).fa by FUNCT_1:72
      .= s2.fa by A1,A127,FUNCT_1:72;
    db in Int-Locations by SCMFSA_2:9;
    then
A129: db in Data-Locations SCM+FSA by XBOOLE_0:def 3,SCMFSA_2:127;
    then
A130: s1.db = (DataPart s1).db by FUNCT_1:72
      .= s2.db by A1,A129,FUNCT_1:72;
A131: ex k2 being Element of NAT st k2 = abs(s2.da) & Exec(l, s2).fa =
    s2.fa+*(k2,s2.db) by A118,SCMFSA_2:99;
A132: ex k1 being Element of NAT st k1 = abs(s1.da) & Exec(l, s1).fa =
    s1.fa+*(k1,s1.db) by A118,SCMFSA_2:99;
    da in Int-Locations by SCMFSA_2:9;
    then
A133: da in Data-Locations SCM+FSA by XBOOLE_0:def 3,SCMFSA_2:127;
    then s1.da = (DataPart s1).da by FUNCT_1:72
      .= s2.da by A1,A133,FUNCT_1:72;
    then Exec (l,s1) | {fa} = Exec(l,s2) | {fa} by A6,A132,A131,A130,A128,
GRFUNC_1:90;
    hence thesis by A126,A125,RELAT_1:185;
  end;
  suppose
    InsCode i = 11;
    then consider da being Int-Location, fa being FinSeq-Location such that
A134: l = da:=len fa by SCMFSA_2:64;
A135: for x being set st x in ((Data-Locations SCM+FSA) \ {da})
holds (Exec (l,s1) | (Data-Locations SCM+FSA \ {da})).x = (Exec (l,
    s2) | (Data-Locations SCM+FSA \ {da})).x
    proof
      let x be set;
      assume
A136: x in ((Data-Locations SCM+FSA) \ {da});
      then
A137: x in Data-Locations SCM+FSA by XBOOLE_0:def 5;
A138: not x in {da} by A136,XBOOLE_0:def 5;
      per cases by A137,XBOOLE_0:def 3,SCMFSA_2:127;
      suppose
        x in Int-Locations;
        then reconsider a = x as Int-Location by SCMFSA_2:11;
A139:   a <> da by A138,TARSKI:def 1;
        thus (Exec (l,s1) | (Data-Locations SCM+FSA \ {da})).x = (
        Exec (l,s1)).a by A136,FUNCT_1:72
          .= s1.a by A134,A139,SCMFSA_2:100
          .= (DataPart s1).a by A137,FUNCT_1:72
          .= s2.a by A1,A137,FUNCT_1:72
          .= (Exec (l,s2)).a by A134,A139,SCMFSA_2:100
          .= (Exec (l,s2) | (Data-Locations SCM+FSA \ {da})).x by
A136,FUNCT_1:72;
      end;
      suppose
        x in FinSeq-Locations;
        then reconsider a = x as FinSeq-Location by SCMFSA_2:12;
        thus (Exec (l,s1) | (Data-Locations SCM+FSA \ {da})).x = (
        Exec (l,s1)).a by A136,FUNCT_1:72
          .= s1.a by A134,SCMFSA_2:100
          .= (DataPart s1).a by A137,FUNCT_1:72
          .= s2.a by A1,A137,FUNCT_1:72
          .= (Exec (l,s2)).a by A134,SCMFSA_2:100
          .= (Exec (l,s2) | (Data-Locations SCM+FSA \ {da})).x by
A136,FUNCT_1:72;
      end;
    end;
    da in Int-Locations by SCMFSA_2:9;
    then da in Data-Locations SCM+FSA by XBOOLE_0:def 3,SCMFSA_2:127;
    then
A140: Data-Locations SCM+FSA = Data-Locations SCM+FSA \/ {da} by ZFMISC_1:46
      .= (Data-Locations SCM+FSA \ {da} ) \/ {da} by XBOOLE_1:39;
    fa in FinSeq-Locations by SCMFSA_2:10;
    then
A141: fa in Data-Locations SCM+FSA by XBOOLE_0:def 3,SCMFSA_2:127;
    then s1.fa = (s1 | (Data-Locations SCM+FSA)).fa by FUNCT_1:72
      .= s2.fa by A1,A141,FUNCT_1:72;
    then Exec (l,s1).da = len(s2.fa) by A134,SCMFSA_2:100
      .= Exec (l,s2).da by A134,SCMFSA_2:100;
    then
A142: Exec (l,s1) | {da} = Exec(l,s2) | {da} by A5,A8,GRFUNC_1:90;
A143: dom ((Exec (l,s2)) | (Data-Locations SCM+FSA \ {da})) = (
    Data-Locations SCM+FSA \ {da}) by A8,RELAT_1:91;
    dom ((Exec (l,s1)) | (Data-Locations SCM+FSA \ {da})) = (
    Data-Locations SCM+FSA \ {da}) by A5,RELAT_1:91;
    then Exec (l,s1) | (Data-Locations SCM+FSA \ {da} ) = Exec (l,
    s2) | (Data-Locations SCM+FSA \ {da} ) by A143,A135,FUNCT_1:9;
    hence thesis by A140,A142,RELAT_1:185;
  end;
  suppose
    InsCode i = 12;
    then consider da being Int-Location, fa being FinSeq-Location such that
A144: i = fa:=<0,...,0>da by SCMFSA_2:65;
    set l = i;
A145: dom ((Exec (l,s2)) | (Data-Locations SCM+FSA \ {fa})) = (
    Data-Locations SCM+FSA \ {fa}) by A8,RELAT_1:91;
A146: ex k2 being Element of NAT st k2 = abs(s2.da) & Exec(l, s2).fa =
    k2 |->0 by A144,SCMFSA_2:101;
A147: ex k1 being Element of NAT st k1 = abs(s1.da) & Exec(l, s1).fa =
    k1 |->0 by A144,SCMFSA_2:101;
A148: for x being set st x in ((Data-Locations SCM+FSA) \ {fa})
holds (Exec (l,s1) | (Data-Locations SCM+FSA \ {fa})).x = (Exec (l,
    s2) | (Data-Locations SCM+FSA \ {fa})).x
    proof
      let x be set;
      assume
A149: x in ((Data-Locations SCM+FSA) \ {fa});
      then
A150: x in Data-Locations SCM+FSA by XBOOLE_0:def 5;
A151: not x in {fa} by A149,XBOOLE_0:def 5;
      per cases by A150,XBOOLE_0:def 3,SCMFSA_2:127;
      suppose
        x in Int-Locations;
        then reconsider a = x as Int-Location by SCMFSA_2:11;
        thus (Exec (l,s1) | (Data-Locations SCM+FSA \ {fa})).x = (
        Exec (l,s1)).a by A149,FUNCT_1:72
          .= s1.a by A144,SCMFSA_2:101
          .= (DataPart s1).a by A150,FUNCT_1:72
          .= s2.a by A1,A150,FUNCT_1:72
          .= (Exec (l,s2)).a by A144,SCMFSA_2:101
          .= (Exec (l,s2) | (Data-Locations SCM+FSA \ {fa})).x by
A149,FUNCT_1:72;
      end;
      suppose
        x in FinSeq-Locations;
        then reconsider a = x as FinSeq-Location by SCMFSA_2:12;
A152:   a <> fa by A151,TARSKI:def 1;
        thus (Exec (l,s1) | (Data-Locations SCM+FSA \ {fa})).x = (
        Exec (l,s1)).a by A149,FUNCT_1:72
          .= s1.a by A144,A152,SCMFSA_2:101
          .= (DataPart s1).a by A150,FUNCT_1:72
          .= s2.a by A1,A150,FUNCT_1:72
          .= (Exec (l,s2)).a by A144,A152,SCMFSA_2:101
          .= (Exec (l,s2) | (Data-Locations SCM+FSA \ {fa})).x by
A149,FUNCT_1:72;
      end;
    end;
    dom ((Exec (l,s1)) | (Data-Locations SCM+FSA \ {fa})) = (
    Data-Locations SCM+FSA \ {fa}) by A5,RELAT_1:91;
    then
A153: Exec (l,s1) | (Data-Locations SCM+FSA \ {fa} ) = Exec (l,
    s2) | (Data-Locations SCM+FSA \ {fa} ) by A145,A148,FUNCT_1:9;
    fa in FinSeq-Locations by SCMFSA_2:10;
    then fa in Data-Locations SCM+FSA by XBOOLE_0:def 3,SCMFSA_2:127;
    then
A154: Data-Locations SCM+FSA = Data-Locations SCM+FSA \/ {fa} by ZFMISC_1:46
      .= (Data-Locations SCM+FSA \ {fa} ) \/ {fa} by XBOOLE_1:39;
    da in Int-Locations by SCMFSA_2:9;
    then
A155: da in Data-Locations SCM+FSA by XBOOLE_0:def 3,SCMFSA_2:127;
    then s1.da = (DataPart s1).da by FUNCT_1:72
      .= s2.da by A1,A155,FUNCT_1:72;
    then Exec (l,s1) | {fa} = Exec(l,s2) | {fa} by A6,A147,A146,GRFUNC_1:90;
    hence thesis by A154,A153,RELAT_1:185;
  end;
end;

Lm3: now
  set IF = Data-Locations SCM+FSA;
  let I be keeping_0 parahalting Program of SCM+FSA, s be State of SCM+FSA;
  let P be (the Instructions of SCM+FSA)-valued ManySortedSet of NAT;
  set IE = IExec(I,P,s);
  now
A1: dom Initialized IE = the carrier of SCM+FSA by PARTFUN1:def 4;
A2: the carrier of SCM+FSA = {IC SCM+FSA} \/ Data-Locations SCM+FSA \/ NAT
           by COMPOS_1:160
      .= {IC SCM+FSA} \/ NAT \/ Data-Locations SCM+FSA
           by XBOOLE_1:4;
A3: dom IE = the carrier of SCM+FSA by PARTFUN1:def 4;

    hence dom DataPart Initialized IE = dom IE /\ IF by A1,RELAT_1:90
;

    then
A4: dom DataPart Initialized IE= Data-Locations SCM+FSA
       by A3,XBOOLE_1:21,A2;

    let x;
    assume
A5: x in dom DataPart Initialized IE;
    per cases by A5,A4,XBOOLE_0:def 3,SCMFSA_2:127;
    suppose
      x in Int-Locations;
      then reconsider x9 = x as Int-Location by SCMFSA_2:11;
      hereby
        per cases;
        suppose
A6:       x9 is read-write;

          thus (DataPart Initialized IE).x = (Initialized IE).x by A5,A4,
FUNCT_1:72

            .= IE.x by A6,Th3;
        end;
        suppose
          x9 is read-only;
          then
A7:       x9 = intloc 0 by SF_MASTR:def 5;

          thus (DataPart Initialized IE).x = (Initialized IE).x9 by A5,A4,
FUNCT_1:72

            .= 1 by A7,Th3
            .= IE.x by A7,SCMFSA6B:35;
        end;
      end;
    end;
    suppose
      x in FinSeq-Locations;
      then reconsider x9 = x as FinSeq-Location by SCMFSA_2:12;

      thus (DataPart Initialized IE).x = (Initialized IE).x9
      by A5,A4,FUNCT_1:72

        .= IE.x by Th3;
    end;
  end;
  hence DataPart Initialized IE = DataPart IE by FUNCT_1:68;
end;

theorem Th6:
  for i being parahalting Instruction of SCM+FSA
   holds Exec(i,Initialized s) = IExec(Macro i,P,s)
proof
  let i be parahalting Instruction of SCM+FSA;
  set Mi = Macro i;
  set sI = s+*Initialized Mi,
      pI = P+*Mi;
A1:  Mi c= pI by FUNCT_4:26;
  set Is = Initialized s;
  set IC1 = IC Comput(P+*Mi,sI,1);
  reconsider Mi as parahalting Program of SCM+FSA;
A2:  Initialize Mi c= sI by FUNCT_4:26,SCMFSA6B:8;
A3: IC1 in dom Mi by SCMFSA6B:def 2,A2,FUNCT_4:26;
A4: Initialized Mi c= sI by FUNCT_4:26;
A5: now
    set Y = NAT;
    set X = Data-Locations SCM+FSA \/ {IC SCM+FSA};
    assume
A6: Result(P+*Mi,sI) = Exec(i, sI);
A7: s+* ((intloc 0) .--> 1),s+*Mi+* ((intloc 0) .--> 1) equal_outside Y
    by FUNCT_7:106,132;
A8: Initialized s = Initialize(s +* ((intloc 0) .--> 1)) by FUNCT_4:15;
A9: Initialized Mi = Initialize(Mi +* ((intloc 0) .--> 1)) by FUNCT_4:15;
    sI = s+* (Mi +* (Initialize ((intloc 0) .--> 1)))
     by FUNCT_4:15
      .= s+* Mi +* (Initialize ((intloc 0) .--> 1))
       by FUNCT_4:15
       .= Initialize (s+* Mi +* ((intloc 0) .--> 1)) by FUNCT_4:15;
    then Is, sI equal_outside Y by A7,FUNCT_7:106,A8,A9;
    then Is | X = sI | X by COMPOS_1:175;
    then
A10: Exec(i, Is) | X = Exec(i, sI) | X by AMISTD_2:65;
A11: Y /\ (X \/ Y) c= Y /\ (X \/ Y);
A12: dom IExec(Mi,P,s) = the carrier of SCM+FSA by PARTFUN1:def 4;
A13: dom Exec(i, Is) = the carrier of SCM+FSA by PARTFUN1:def 4;
A14: the carrier of SCM+FSA = X \/ Y by COMPOS_1:160;
A15: dom s = X \/ Y by COMPOS_1:172;
    now
      thus dom (Exec(i, Is) | Y) = dom s /\ Y
       by A13,A15,RELAT_1:90,A14;
      let x;
      assume x in dom (Exec(i, Is) | Y);
      then
A16:  x in Y /\ (X \/ Y) by A13,RELAT_1:90,A14;
      then reconsider x9 = x as Element of NAT by XBOOLE_1:21;
      x in Y by A16,XBOOLE_1:21;
      hence (Exec(i, Is)|Y).x = (Exec(i, Is)).x by FUNCT_1:72
        .= Is.x9 by AMI_1:def 13
        .= s.x by Th3;
    end;
    then
A17: Exec(i, Is) | Y = s | Y by FUNCT_1:68;
    dom Exec(i, sI) = the carrier of SCM+FSA by PARTFUN1:def 4;
    then
A18: IExec(Mi,P,s) | Y = s | Y by A6,A15,A11,FUNCT_4:93,A14;
    X misses Y
    proof
      assume X meets Y;
      then consider x such that
A19:  x in X and
A20:  x in Y by XBOOLE_0:3;
A21:  x in Int-Locations \/ FinSeq-Locations or x in {IC SCM+FSA} by A19,
XBOOLE_0:def 3,SCMFSA_2:127;
      per cases by A21,TARSKI:def 1,XBOOLE_0:def 3;
      suppose
        x in Int-Locations;
        hence contradiction by A20,SCMFSA_2:13,XBOOLE_0:3;
      end;
      suppose
        x in FinSeq-Locations;
        hence contradiction by A20,SCMFSA_2:14,XBOOLE_0:3;
      end;
      suppose
A22:    x = IC SCM+FSA;
        reconsider x as Element of NAT by A20;
        x = IC SCM+FSA by A22;
        hence contradiction by COMPOS_1:3;
      end;
    end;
    then X misses dom (s|Y) by RELAT_1:87,XBOOLE_1:63;
    then IExec(Mi,P,s) | X = Exec(i, sI) | X by A6,FUNCT_4:76;
    then
A23: Exec(i, Is)| (X \/ Y) = IExec(Mi,P,s) | (X \/ Y)
 by A10,A18,A17,RELAT_1:185;
    thus Exec(i, Is) = Exec(i, Is)| (X \/ Y) by A13,RELAT_1:98,A14
      .= IExec(Mi,P,s) by A12,A23,RELAT_1:98,A14;
  end;
A24:  1 in dom Mi by COMPOS_1:147;
A25:  0 in dom Mi by COMPOS_1:147;
A26: Mi. 0 = i by COMPOS_1:148;
A27:  (P+*Mi)/.IC sI
 = (P+*Mi).IC sI by PBOOLE:158;
A28: Comput(P+*Mi,sI,0+1) = Following(P+*Mi,
        Comput(P+*Mi,sI,0)) by EXTPRO_1:4
    .= Following(P+*Mi,sI) by EXTPRO_1:3
    .= Exec(pI. 0, sI) by A27,FUNCT_4:26,SCMFSA6B:34
    .= Exec(i, sI) by A26,GRFUNC_1:8,A1,A25;
  per cases by A3,COMPOS_1:147;
  suppose
A29: IC1 =  0;
    then
A30: CurInstr(P+*Mi,Comput(P+*Mi,sI,1)) = (P+*Mi). 0 by PBOOLE:158
      .= i by A26,FUNCT_4:14,A25;
    succ IC sI = succ  0 by FUNCT_4:26,SCMFSA6B:34
      .=  1;
    then
A31: InsCode i in {0, 6, 7, 8} by A28,A29,SCMFSA6A:23;
    hereby
      per cases by A31,ENUMSET1:def 2;
      suppose
        InsCode i = 0;
        then
A32:    i = halt SCM+FSA by SCMFSA_2:122;
        then P+*Mi halts_on sI by A30,EXTPRO_1:30;
        hence thesis by A5,A28,A30,A32,EXTPRO_1:def 8;
      end;
      suppose
A33:    InsCode i = 6 or InsCode i = 7 or InsCode i = 8;
A34:    now
          let a;
          per cases by A33;
          suppose
            InsCode i = 6;
            then ex l st i = goto l by SCMFSA_2:59;
            hence sI.a = Exec(i, sI).a by SCMFSA_2:95;
          end;
          suppose
            InsCode i = 7;
            then ex l, b st i = b=0_goto l by SCMFSA_2:60;
            hence sI.a = Exec(i, sI).a by SCMFSA_2:96;
          end;
          suppose
            InsCode i = 8;
            then ex l, b st i = b>0_goto l by SCMFSA_2:61;
            hence sI.a = Exec(i, sI).a by SCMFSA_2:97;
          end;
        end;
A35:    for l holds sI.l = Exec(i, sI).l by AMI_1:def 13;
A36:    now
          let f;
          per cases by A33;
          suppose
            InsCode i = 6;
            then ex l st i = goto l by SCMFSA_2:59;
            hence sI.f = Exec(i, sI).f by SCMFSA_2:95;
          end;
          suppose
            InsCode i = 7;
            then ex l, a st i = a=0_goto l by SCMFSA_2:60;
            hence sI.f = Exec(i, sI).f by SCMFSA_2:96;
          end;
          suppose
            InsCode i = 8;
            then ex l, a st i = a>0_goto l by SCMFSA_2:61;
            hence sI.f = Exec(i, sI).f by SCMFSA_2:97;
          end;
        end;
        IC sI = IC Exec(i, sI) by A28,A29,FUNCT_4:26,SCMFSA6B:34;
        then
A37:    sI = Exec(i, sI) by A34,A36,A35,SCMFSA_2:86;
A38:    Following(P+*Mi,sI) =
Following(P+*Mi,Comput(P+*Mi,sI,0)
) by EXTPRO_1:3
          .= Exec(i, sI) by A28,EXTPRO_1:4;
        now
          let n be Element of NAT;
          Comput(P+*Mi,sI,n) = sI by A37,A38,EXTPRO_1:27
            .= Following(P+*Mi,Comput(
P+*Mi,sI,0))
             by A37,A38,EXTPRO_1:3
            .= Comput(P+*Mi,sI,0+1) by EXTPRO_1:4;
          hence CurInstr(P+*Mi,Comput(P+*Mi,sI,n))
           <> halt SCM+FSA by A30,A33,SCMFSA_2:124;
        end;
        then
A39:      not P+*Mi halts_on sI by EXTPRO_1:30;
A40:      ProgramPart Initialized Mi = Mi by SCMFSA6A:33;
         Mi c= P+*Mi by FUNCT_4:26;
        hence Exec(i,Initialized s) = IExec(Macro i,P,s)
            by A4,EXTPRO_1:def 10,A39,A40;
      end;
    end;
  end;
  suppose
A41:    IC1 = 1;
A42:    Mi c= Initialized Mi by SCMFSA6A:26;
    (Initialized Mi). 1 = halt SCM+FSA by SCMFSA6B:33;
    then
A43: Mi.1 = halt SCM+FSA by A42, A24,GRFUNC_1:8;
A44: CurInstr(P+*Mi,Comput(P+*Mi,sI,1))
       = (P+*Mi). 1 by A41,PBOOLE:158
      .= halt SCM+FSA by A43,GRFUNC_1:8,A1,A24;
    then P+*Mi halts_on sI by EXTPRO_1:30;
    hence thesis by A5,A28,A44,EXTPRO_1:def 8;
  end;
end;

Lm4:
 s.a = (NPP s).a
  proof
A1:  Data-Locations SCM+FSA c= dom NPP s by COMPOS_1:185;
    a in Int-Locations by SCMFSA_2:9;
    then
A2:   a in Data-Locations SCM+FSA by SCMFSA_2:127,XBOOLE_0:def 3;
   thus s.a = (ProgramPart s +* NPP s).a by COMPOS_1:184
     .= (NPP s).a by A2,A1,FUNCT_4:14;
  end;

Lm5:
 (NPP s).f = s.f
  proof
A1:  Data-Locations SCM+FSA c= dom NPP s by COMPOS_1:185;
    f in FinSeq-Locations by SCMFSA_2:10;
    then
A2:   f in Data-Locations SCM+FSA by SCMFSA_2:127,XBOOLE_0:def 3;
   thus s.f = (ProgramPart s +* NPP s).f by COMPOS_1:184
     .= (NPP s).f by A2,A1,FUNCT_4:14;
  end;

theorem Th7:
  for I being keeping_0 parahalting Program of SCM+FSA, j being
parahalting Instruction of SCM+FSA holds IExec(I ';' j,P,s).a
 = Exec(j,IExec(I,P,s)).a
proof
  let I be keeping_0 parahalting Program of SCM+FSA, j be parahalting
  Instruction of SCM+FSA;
  set Mj = Macro j;
  set SA = Start-At (IC IExec(Mj,P,IExec(I,P,s)) + card I,SCM+FSA);
A1: not a in dom SA by SCMFSA6B:9;
A2: DataPart Initialized IExec(I,P,s) = DataPart IExec(I,P,s) by Lm3;
  a in Int-Locations by SCMFSA_2:9;
  then
A3: a in Data-Locations SCM+FSA by XBOOLE_0:def 3,SCMFSA_2:127;
  thus IExec(I ';' j,P,s).a = (IExec(Mj,P,IExec(I,P,s))+*SA).a by SCMFSA6B:44
    .= IExec(Mj,P,IExec(I,P,s)).a by A1,FUNCT_4:12
    .= Exec(j, Initialized IExec(I,P,s)).a by Th6
    .= (DataPart Exec(j, Initialized IExec(I,P,s))).a by A3,FUNCT_1:72

    .= (DataPart Exec(j,IExec(I,P,s))).a by A2,Th5
    .= Exec(j,IExec(I,P,s)).a by A3,FUNCT_1:72;
end;

theorem Th8:
  for I being keeping_0 parahalting Program of SCM+FSA, j being
parahalting Instruction of SCM+FSA holds IExec(I ';' j,P,s).f
 = Exec(j,IExec(I,P,s)).f
proof
  let I be keeping_0 parahalting Program of SCM+FSA, j be parahalting
  Instruction of SCM+FSA;
  set Mj = Macro j;
  set SA = Start-At (IC IExec(Mj,P,IExec(I,P,s)) + card I,SCM+FSA);
A1: not f in dom SA by SCMFSA6B:10;
A2: DataPart Initialized IExec(I,P,s) = DataPart IExec(I,P,s) by Lm3;
  f in FinSeq-Locations by SCMFSA_2:10;
  then
A3: f in Data-Locations SCM+FSA by XBOOLE_0:def 3,SCMFSA_2:127;
  thus IExec(I ';' j,P,s).f = (IExec(Mj,P,IExec(I,P,s))+*SA).f by SCMFSA6B:44
    .= IExec(Mj,P,IExec(I,P,s)).f by A1,FUNCT_4:12
    .= Exec(j, Initialized IExec(I,P,s)).f by Th6
    .= (DataPart Exec(j, Initialized IExec(I,P,s))).f by A3,FUNCT_1:72

    .= (DataPart Exec(j,IExec(I,P,s))).f by A2,Th5
    .= Exec(j,IExec(I,P,s)).f by A3,FUNCT_1:72;
end;

theorem Th9:
  for i being keeping_0 parahalting Instruction of SCM+FSA, j being
parahalting Instruction of SCM+FSA holds IExec(i ';' j,P,s).a
 = Exec(j, Exec(i,Initialized s)).a
proof
  let i be keeping_0 parahalting Instruction of SCM+FSA, j be parahalting
  Instruction of SCM+FSA;
  set Mi = Macro i;
  thus IExec(i ';' j,P,s).a = IExec(Mi ';' j,P, s).a
    .= Exec(j,IExec(Mi,P,s)).a by Th7
    .= Exec(j, Exec(i, Initialized s)).a by Th6;
end;

theorem
  for i being keeping_0 parahalting Instruction of SCM+FSA, j being
parahalting Instruction of SCM+FSA holds IExec(i ';' j,P,s).f = Exec(j, Exec(i,
  Initialized s)).f
proof
  let i be keeping_0 parahalting Instruction of SCM+FSA, j be parahalting
  Instruction of SCM+FSA;
  set Mi = Macro i;
  thus IExec(i ';' j,P,s).f = IExec(Mi ';' j,P,s).f
    .= Exec(j,IExec(Mi,P,s)).f by Th8
    .= Exec(j, Exec(i, Initialized s)).f by Th6;
end;

begin :: An example

definition
 canceled;
  let a, b be Int-Location;
  func swap (a, b) -> Program of SCM+FSA equals
  FirstNotUsed Macro (a := b) :=
  a ';' (a := b) ';' (b := FirstNotUsed Macro (a := b));
  correctness;
end;

registration
  let a, b be Int-Location;
  cluster swap(a,b) -> parahalting;
  coherence;
end;

registration
  let a, b be read-write Int-Location;
  cluster swap(a,b) -> keeping_0;
  coherence;
end;

theorem
  for a, b being read-write Int-Location holds IExec(swap(a,b),P,s).a =
  s.b & IExec(swap(a,b),P,s).b = s.a
proof
  let a, b be read-write Int-Location;
  set i0 = FirstNotUsed Macro (a := b) := a;
  set i1 = a := b;
  set i2 = b := FirstNotUsed Macro (a := b);
  set i01 = i0 ';' i1;
  UsedIntLoc Macro (a := b) = UsedIntLoc (a := b) by SF_MASTR:32;
  then UsedIntLoc Macro (a := b) = {a, b} by SF_MASTR:18;
  then
A1: not FirstNotUsed Macro (a := b) in {a, b} by SF_MASTR:54;
  then
A2: FirstNotUsed Macro (a := b) <> a by TARSKI:def 2;
A3: FirstNotUsed Macro (a := b) <> b by A1,TARSKI:def 2;
  hereby
    per cases;
    suppose
A4:   a <> b;
      thus IExec(swap(a,b),P,s).a = Exec(i2, IExec(i01,P,s)).a by Th7
        .= IExec(i01,P,s).a by A4,SCMFSA_2:89
        .= Exec(i1, Exec(i0, Initialized s)).a by Th9
        .= Exec(i0, Initialized s).b by SCMFSA_2:89
        .= (Initialized s).b by A3,SCMFSA_2:89
        .= s.b by Th3;
    end;
    suppose
A5:   a = b;
      thus IExec(swap(a,b),P,s).a = Exec(i2, IExec(i01,P,s)).a by Th7
        .= IExec(i01,P,s).(FirstNotUsed Macro (a := b)) by A5,SCMFSA_2:89
        .= Exec(i1, Exec(i0, Initialized s)).(FirstNotUsed Macro (a := b)) by
Th9
        .= Exec(i0, Initialized s).(FirstNotUsed Macro (a := b)) by A2,
SCMFSA_2:89
        .= (Initialized s).a by SCMFSA_2:89
        .= s.b by A5,Th3;
    end;
  end;
  thus IExec(swap(a,b),P,s).b = Exec(i2, IExec(i01,P,s)).b by Th7
    .= IExec(i01,P,s).(FirstNotUsed Macro (a := b)) by SCMFSA_2:89
    .= Exec(i1, Exec(i0, Initialized s)).(FirstNotUsed Macro (a := b)) by Th9
    .= Exec(i0, Initialized s).(FirstNotUsed Macro (a := b)) by A2,SCMFSA_2:89
    .= (Initialized s).a by SCMFSA_2:89
    .= s.a by Th3;
end;

theorem
  UsedInt*Loc swap(a, b) = {}
proof
  set i0 = FirstNotUsed Macro (a := b) := a;
  set i1 = a := b;
  set i2 = b := FirstNotUsed Macro (a := b);
  thus UsedInt*Loc swap(a, b) = (UsedInt*Loc (i0 ';' i1)) \/ (UsedInt*Loc i2)
  by SF_MASTR:50
    .= (UsedInt*Loc (i0 ';' i1)) \/ {} by SF_MASTR:36
    .= (UsedInt*Loc i0) \/ (UsedInt*Loc i1) by SF_MASTR:51
    .= (UsedInt*Loc i0) \/ {} by SF_MASTR:36
    .= {} by SF_MASTR:36;
end;

theorem
 s.a = (NPP s).a by Lm4;

theorem
 (NPP s).f = s.f by Lm5;
