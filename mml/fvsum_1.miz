:: Sum and Product of Finite Sequences of Elements of a Field
::  by Katarzyna Zawadzka
::
:: Received December 29, 1992
:: Copyright (c) 1992 Association of Mizar Users

environ

 vocabularies RLVECT_1, BINOP_1, FUNCT_1, VECTSP_1, ALGSTR_1, SETWISEO,
      LATTICES, FUNCOP_1, ARYTM_1, FINSEQOP, FINSEQ_1, RELAT_1, FINSEQ_2,
      RVSUM_1, SQUARE_1, FINSUB_1, BOOLE, SUBSET_1, FINSEQ_4, RLSUB_2,
      FINSET_1, CARD_1, CAT_3, FVSUM_1, CARD_3, GROUP_1, ORDINAL2, ARYTM;
 notations TARSKI, XBOOLE_0, SUBSET_1, NUMBERS, ORDINAL1, ORDINAL2, NAT_1,
      SQUARE_1, RELAT_1, FUNCT_1, STRUCT_0, PARTFUN1, FUNCT_2, FINSEQ_1,
      FINSEQ_4, BINOP_1, FUNCOP_1, RLVECT_1, SETWISEO, FINSEQ_2, FINSEQOP,
      SETWOP_2, GROUP_1, ALGSTR_1, GROUP_4, VECTSP_1, CARD_1, FINSET_1,
      FINSUB_1, MATRIX_2, XXREAL_0;
 constructors DOMAIN_1, NAT_1, SQUARE_1, SETWISEO, FINSEQOP, SETWOP_2,
      ALGSTR_1, GROUP_4, MATRIX_2, FINSOP_1, FINSEQ_4, MEMBERED, PARTFUN1,
      XXREAL_0, BINOP_1;
 registrations FUNCT_1, FINSEQ_1, VECTSP_1, RELSET_1, STRUCT_0, FINSEQ_2,
      ALGSTR_1, FINSET_1, FINSUB_1, NAT_1, MEMBERED, FUNCT_2, ORDINAL2,
      XXREAL_0;
 requirements NUMERALS, REAL, BOOLE, SUBSET;
 definitions SETWISEO, ALGSTR_1, BINOP_1, GROUP_4;
 theorems FINSEQ_1, FINSEQ_2, TARSKI, FUNCT_1, FUNCT_2, NAT_1, BINOP_1,
      FINSEQOP, VECTSP_1, FUNCOP_1, SQUARE_1, SETWOP_2, RLVECT_1, RELAT_1,
      SETWISEO, FINSEQ_3, ZFMISC_1, FINSEQ_4, ALGSTR_1, FINSOP_1, GROUP_1,
      XBOOLE_0, XBOOLE_1, XCMPLX_1, ORDINAL2, XREAL_1, GROUP_4, XXREAL_0;
 schemes NAT_1, FUNCT_2;

begin :: Auxiliary theorems

 reserve i,j,k for Nat;

canceled;

theorem Th2:
  for K being Abelian (non empty LoopStr) holds the add of K is commutative
  proof let K be Abelian (non empty LoopStr);
    now let a,b be Element of K;
      thus (the add of K).(a,b)=a+b by RLVECT_1:5
                         .=(the add of K).(b,a) by RLVECT_1:5;
    end;
    hence the add of K is commutative by BINOP_1:def 2;
 end;

theorem Th3:
for K being add-associative (non empty LoopStr)
 holds the add of K is associative
   proof let K be add-associative (non empty LoopStr);
    now let a,b,c be Element of K;
      thus (the add of K).(a,(the add of K).(b,c))=(the add of K).(a,b+c)
                                            by RLVECT_1:5
                  .=a+(b+c) by RLVECT_1:5
                  .=(a+b)+c by RLVECT_1:def 6
                  .=(the add of K).(a,b)+c by RLVECT_1:5
                  .=(the add of K).((the add of K).(a,b),c) by RLVECT_1:5;
     end;
     hence the add of K is associative by BINOP_1:def 3;
    end;

theorem Th4:
  for K being commutative (non empty HGrStr) holds
    the mult of K is commutative
  proof
    let K be commutative (non empty HGrStr);
    now let a,b be Element of K;
      thus (the mult of K).(a,b)=a*b by GROUP_1:def 1
             .=(the mult of K).(b,a) by GROUP_1:def 1;
    end;
    hence the mult of K is commutative by BINOP_1:def 2;
  end;

registration let K be Abelian (non empty LoopStr);
  cluster the add of K -> commutative;
  coherence by Th2;
end;

registration let K be add-associative (non empty LoopStr);
  cluster the add of K -> associative;
  coherence by Th3;
end;

registration let K be commutative (non empty HGrStr);
  cluster the mult of K -> commutative;
  coherence by Th4;
end;

canceled;

theorem Th6:
  for K being commutative left_unital (non empty multLoopStr) holds
    1.K is_a_unity_wrt the mult of K
  proof
  let K be commutative left_unital (non empty multLoopStr);
   set o = the mult of K;
   now let h be Element of K;
     thus o.(1.K,h) = 1.K * h by GROUP_1:def 1
                   .= h by VECTSP_1:def 19;
     thus o.(h,1.K) = h * 1.K by GROUP_1:def 1
                   .= h by VECTSP_1:def 19;
    end;
   hence thesis by BINOP_1:11;
  end;

theorem Th7:
  for K being commutative left_unital (non empty multLoopStr) holds
   the_unity_wrt the mult of K = 1.K
    proof
     let K be commutative left_unital (non empty multLoopStr);
     reconsider e=1.K as Element of K;
     e is_a_unity_wrt the mult of K by Th6;
     hence thesis by BINOP_1:def 8;
    end;

theorem Th8:
  for K being left_zeroed right_zeroed (non empty LoopStr)
    holds 0.K is_a_unity_wrt the add of K
 proof let K be left_zeroed right_zeroed (non empty LoopStr);
      now let a be Element of K;
    thus (the add of K).(0.K,a) = 0.K + a by RLVECT_1:5
                               .= a by ALGSTR_1:def 5;
  thus (the add of K).(a,0.K) = a + 0.K by RLVECT_1:5
                             .= a by RLVECT_1:def 7;
  end;
  hence thesis by BINOP_1:11;
 end;

theorem Th9:
  for K being left_zeroed right_zeroed (non empty LoopStr) holds
    the_unity_wrt the add of K = 0.K
   proof let K be left_zeroed right_zeroed (non empty LoopStr);
    reconsider e=0.K as Element of K;
       e is_a_unity_wrt the add of K by Th8;
    hence thesis by BINOP_1:def 8;
   end;

theorem Th10:
for K being left_zeroed right_zeroed (non empty LoopStr)
 holds the add of K has_a_unity
 proof let K be left_zeroed right_zeroed (non empty LoopStr);
  take 0.K;
  thus thesis by Th8;
 end;

theorem Th11:
 for K being commutative left_unital (non empty multLoopStr) holds
   the mult of K has_a_unity
proof
  let K be commutative left_unital (non empty multLoopStr);
  take 1.K;
  thus thesis by Th6;
end;

theorem Th12:
 for K being distributive (non empty doubleLoopStr) holds
   the mult of K is_distributive_wrt the add of K
 proof
 let K be distributive (non empty doubleLoopStr);
     now let a1,a2,a3 be Element of K;
   thus (the mult of K).(a1,(the add of K).(a2,a3))
      = (the mult of K).(a1,a2+a3) by RLVECT_1:5
     .= a1*(a2+a3) by GROUP_1:def 1
     .= a1*a2+a1*a3 by VECTSP_1:def 18
     .= (the add of K).(a1*a2,a1*a3) by RLVECT_1:5
     .= (the add of K).((the mult of K).(a1,a2),a1*a3) by GROUP_1:def 1
     .= (the add of K).((the mult of K).(a1,a2),(the mult of K).(a1,a3))
      by GROUP_1:def 1;
   thus (the mult of K).((the add of K).(a1,a2),a3)
      = (the mult of K).(a1+a2,a3) by RLVECT_1:5
     .= (a1+a2)*a3 by GROUP_1:def 1
     .= a1*a3+a2*a3 by VECTSP_1:def 18
     .= (the add of K).(a1*a3,a2*a3) by RLVECT_1:5
     .= (the add of K).((the mult of K).(a1,a3),a2*a3) by GROUP_1:def 1
     .= (the add of K).((the mult of K).(a1,a3),(the mult of K).(a2,a3))
      by GROUP_1:def 1;
  end;
  hence thesis by BINOP_1:23;
 end;

definition let K be non empty HGrStr;let a be Element of K;
 func a multfield -> UnOp of the carrier of K equals
  (the mult of K)[;](a,id (the carrier of K));
 coherence;
end;

definition let K be non empty LoopStr;
 func diffield(K) -> BinOp of the carrier of K equals
  (the add of K)*(id the carrier of K,comp K);
  correctness;
end;

canceled;

theorem Th14:
 for K being non empty LoopStr,
   a1,a2 being Element of K holds
   (diffield(K)).(a1,a2) = a1 - a2
 proof
 let K be non empty LoopStr,
   a1,a2 be Element of K;
  thus (diffield(K)).(a1,a2) =
      (the add of K)*(id (the carrier of K),(comp K)).(a1,a2)
      .= (the add of K).(a1,(comp K).a2) by FINSEQOP:87
                       .= (the add of K).(a1,-a2) by VECTSP_1:def 25
                       .= a1 + - a2 by RLVECT_1:5
                       .= a1 - a2 by RLVECT_1:def 11;
 end;

Lm1:
 for K being non empty HGrStr,
   a,b being Element of K holds
   (the mult of K)[;](b,id (the carrier of K)).a = b*a
 proof
 let K be non empty HGrStr,
   a,b be Element of K;
  thus ((the mult of K)[;](b,id (the carrier of K)).a =
       (the mult of K).(b,(id (the carrier of K).a))) by FUNCOP_1:66
                               .= (the mult of K).(b,a) by FUNCT_1:35
                               .= b*a by GROUP_1:def 1;
 end;

theorem Th15:
 for K being distributive (non empty doubleLoopStr),
     a being Element of K holds
   a multfield is_distributive_wrt the add of K
 proof
  let K be distributive (non empty doubleLoopStr),
      a be Element of K;
  A1:the mult of K is_distributive_wrt the add of K by Th12;
  thus thesis by A1,FINSEQOP:55;
 end;

theorem Th16:
 for K being left_zeroed right_zeroed add-associative right_complementable
    (non empty LoopStr) holds
   comp K is_an_inverseOp_wrt the add of K
 proof
  let K be left_zeroed right_zeroed add-associative right_complementable
   (non empty LoopStr);
     now let a be Element of K;
   thus (the add of K).(a,((comp K)).a) = a+((comp K)).a by RLVECT_1:5
                              .= a+ -a by VECTSP_1:def 25
                              .= 0.K by RLVECT_1:16
                              .= the_unity_wrt the add of K by Th9;
   thus (the add of K).(((comp K)).a,a) = ((comp K)).a+a by RLVECT_1:5
                              .= -a+a by VECTSP_1:def 25
                              .= 0.K by RLVECT_1:16
                              .= the_unity_wrt the add of K by Th9;
  end;
  hence thesis by FINSEQOP:def 1;
 end;

theorem Th17:
 for K being left_zeroed right_zeroed add-associative right_complementable
    (non empty LoopStr) holds
  the add of K has_an_inverseOp
    proof
  let K be left_zeroed right_zeroed add-associative right_complementable
    (non empty LoopStr);
        comp K is_an_inverseOp_wrt the add of K by Th16;
     hence thesis by FINSEQOP:def 2;
    end;

theorem Th18:
  for K being left_zeroed right_zeroed add-associative right_complementable
    (non empty LoopStr) holds
   the_inverseOp_wrt the add of K = comp K
   proof
  let K be left_zeroed right_zeroed add-associative right_complementable
    (non empty LoopStr);
      the add of K has_a_unity & the add of K is associative &
   the add of K has_an_inverseOp &
   comp K is_an_inverseOp_wrt the add of K by Th10,Th16,Th17;
   hence thesis by FINSEQOP:def 3;
   end;

theorem
     for K being right_zeroed add-associative right_complementable
    Abelian (non empty LoopStr) holds
   comp K is_distributive_wrt the add of K
   proof
  let K be right_zeroed add-associative right_complementable
    Abelian (non empty LoopStr);
      the add of K has_a_unity & the add of K is associative &
   the add of K is commutative & the add of K has_an_inverseOp
    by Th10,Th17;
    then (the_inverseOp_wrt the add of K) is_distributive_wrt the add of K
    by FINSEQOP:67;
    hence thesis by Th18;
   end;

begin
::
:: Some Operations on the i-tuples on Element of K
::

definition let K be non empty LoopStr;
 let p1,p2 be FinSequence of the carrier of K;
  func p1 + p2 -> FinSequence of the carrier of K equals
  (the add of K).:(p1,p2);
   correctness;
end;

canceled;

theorem Th21:
 for K being non empty LoopStr, p1, p2 be FinSequence of the carrier of K,
     a1, a2 being Element of K, i being Nat
  st i in dom (p1+p2) & a1 = p1.i & a2 = p2.i holds (p1+p2).i = a1 + a2
 proof let K be non empty LoopStr, p1, p2 be FinSequence of the carrier of K,
           a1, a2 be Element of K, i be Nat such that
A1: i in dom (p1+p2) and
A2: a1 = p1.i & a2 = p2.i;
     p1 + p2 = (the add of K).:(p1,p2) & i in dom(p1+p2) by A1;
  then (p1 + p2).i = (the add of K).(a1,a2) by A2,FUNCOP_1:28;
  hence thesis by RLVECT_1:5;
 end;

definition let i; let K be non empty LoopStr;
  let R1,R2 be Element of i-tuples_on the carrier of K;
  redefine func R1 + R2 -> Element of i-tuples_on the carrier of K;
   coherence by FINSEQ_2:140;
end;

theorem
  for K being non empty LoopStr,
      a1,a2 being Element of K,
  R1,R2 being Element of i-tuples_on the carrier of K holds
   j in Seg i & a1 = R1.j & a2 = R2.j implies (R1+R2).j = a1 + a2
 proof
  let K be non empty LoopStr,
   a1,a2 be Element of K,
  R1,R2 be Element of i-tuples_on the carrier of K;
  assume j in Seg i;
  then j in Seg len (R1 + R2) by FINSEQ_2:109;
  then j in dom (R1 + R2) by FINSEQ_1:def 3;
  hence thesis by Th21;
 end;

theorem
  for K being non empty LoopStr,
      p being FinSequence of the carrier of K holds
   <*>(the carrier of K) + p = <*>(the carrier of K) & p +
    <*>(the carrier of K) = <*>(the carrier of K) by FINSEQ_2:87;

theorem
  for K being non empty LoopStr,
    a1,a2 being Element of K holds
  <*a1*> + <*a2*> = <*a1+a2*>
 proof
   let K be non empty LoopStr,
      a1,a2 be Element of K;
   thus <*a1*> + <*a2*> = (the add of K).:(<*a1*>,<*a2*>)
                       .= <*(the add of K).(a1,a2)*> by FINSEQ_2:88
                       .= <*a1+a2*> by RLVECT_1:5;
 end;

theorem
  for K being non empty LoopStr,
    a1,a2 being Element of K holds
   (i|->a1) + (i|->a2) = i|->(a1+a2)
 proof
   let K be non empty LoopStr,
      a1,a2 be Element of K;
   thus (i|->a1) + (i|->a2) = (the add of K).:(i|->a1,i|->a2)
                           .= i|->((the add of K).(a1,a2)) by FINSEQOP:18
                           .= i|->(a1+a2) by RLVECT_1:5;
 end;

theorem Th26:
 for K being Abelian (non empty LoopStr),
     R1,R2 being Element of i-tuples_on the carrier of K holds
   R1 + R2 = R2 + R1
 proof
  let K be Abelian (non empty LoopStr),
     R1,R2 be Element of i-tuples_on the carrier of K;
   thus R1 + R2 = (the add of K).:(R1,R2)
               .= (the add of K).:(R2,R1) by FINSEQOP:34
               .= R2 + R1;
 end;

theorem Th27:
 for K be add-associative (non empty LoopStr),
     R1,R2,R3 being Element of i-tuples_on the carrier of K holds
   R1 + (R2 + R3) = R1 + R2 + R3
 proof
 let K be add-associative (non empty LoopStr),
     R1,R2,R3 be Element of i-tuples_on the carrier of K;
   thus R1 + (R2 + R3) = (the add of K).:(R1,R2+R3)
                      .= (the add of K).:(R1,(the add of K).:(R2,R3))
                      .= (the add of K).:((the add of K).:(R1,R2),R3)
                      by FINSEQOP:29
                      .= (the add of K).:(R1+R2,R3)
                      .= R1 + R2 + R3;
 end;

Lm2:
 for K be left_zeroed right_zeroed (non empty LoopStr),
     R be Element of i-tuples_on the carrier of K holds
R + (i|->(0.K)) = R
 proof
 let K be left_zeroed right_zeroed (non empty LoopStr),
     R be Element of i-tuples_on the carrier of K;
  A1:the_unity_wrt the add of K = 0.K & the add of K has_a_unity by Th9,Th10;
  thus R + (i|->(0.K)) = (the add of K).:(R,i|->0.K)
  .= R by A1,FINSEQOP:57;
 end;

theorem Th28:
 for K being Abelian left_zeroed right_zeroed (non empty LoopStr),
     R being Element of i-tuples_on the carrier of K holds
   R + (i|->(0.K)) = R & R = (i|->(0.K)) + R
 proof
 let K be Abelian left_zeroed right_zeroed (non empty LoopStr),
     R be Element of i-tuples_on the carrier of K;
 thus R + (i|->(0.K)) = R by Lm2; hence thesis by Th26; end;

definition let K be non empty LoopStr;
  let p be FinSequence of the carrier of K;
  func -p -> FinSequence of the carrier of K equals
  (comp K)*p;
   correctness;
end;

 reserve K for non empty LoopStr,
  a for Element of K,
  p for FinSequence of the carrier of K,
  R for Element of i-tuples_on the carrier of K;

canceled;

theorem Th30:
   i in dom -p & a = p.i implies (-p).i = -a
 proof assume that
A1:  i in dom -p and
A2:  a = p.i;
      -p = (comp K)*p & i in dom(-p) by A1;
  then (-p).i = (comp K).a by A2,FUNCT_1:22;
  hence thesis by VECTSP_1:def 25;
 end;

definition let i;let K be non empty LoopStr;
  let R be Element of i-tuples_on the carrier of K;
 redefine func -R -> Element of i-tuples_on the carrier of K;
  coherence by FINSEQ_2:133;
end;

theorem
      j in Seg i & a = R.j implies (-R).j = -a
 proof assume j in Seg i; then j in Seg len -R by FINSEQ_2:109;
  then j in dom -R by FINSEQ_1:def 3;
  hence thesis by Th30;
 end;

theorem
      -(<*>(the carrier of K)) = <*>(the carrier of K) by FINSEQ_2:38;

theorem
      -<*a*> = <*-a*>
 proof
   thus -<*a*> = (comp K)*<*a*>
              .= <*(comp K).a*> by FINSEQ_2:39
              .= <*-a*> by VECTSP_1:def 25;
 end;

theorem Th34:
   -(i|->a) = i|->-a
 proof
   thus -(i|->a) = (comp K)*(i|->a)
                .= i|->((comp K).a) by FINSEQOP:17
                .= i|->-a by VECTSP_1:def 25;
 end;

Lm3:
 for K be left_zeroed right_zeroed add-associative right_complementable
        (non empty LoopStr),
  R be Element of i-tuples_on the carrier of K holds
R + -R = (i|->0.K)
 proof
 let K be left_zeroed right_zeroed add-associative right_complementable
        (non empty LoopStr),
  R be Element of i-tuples_on the carrier of K;
  A1: the add of K has_an_inverseOp & the add of K has_a_unity
    by Th10,Th17;
  thus R + -R = (the add of K).:(R,-R)
             .= (the add of K).:(R,(comp K)*R)
             .= (the add of K).:
(R,(the_inverseOp_wrt (the add of K)*R)) by Th18
             .= i|->the_unity_wrt the add of K by A1,FINSEQOP:77
             .= i|->0.K by Th9;
 end;

theorem Th35:
 for K being Abelian right_zeroed add-associative right_complementable
        (non empty LoopStr),
     R being Element of i-tuples_on the carrier of K holds
   R + -R = (i|->0.K) & -R + R = (i|->0.K)
 proof
  let K be Abelian right_zeroed add-associative right_complementable
        (non empty LoopStr),
     R be Element of i-tuples_on the carrier of K;
 thus R + -R = (i|->0.K) by Lm3; hence -R + R = (i|->0.K) by Th26;
  end;

 reserve
  K for left_zeroed right_zeroed add-associative right_complementable
        (non empty LoopStr),
  R,R1,R2 for Element of i-tuples_on the carrier of K;

theorem Th36:
   R1 + R2 = (i|->0.K) implies R1 = -R2 & R2 = -R1
 proof
  A1:the_unity_wrt the add of K = 0.K & the add of K has_a_unity by Th9,Th10;
  A2:the add of K has_an_inverseOp &
   the_inverseOp_wrt the add of K = (comp K) by Th17,Th18;
   thus thesis by A1,A2,FINSEQOP:78;
 end;

theorem Th37:
   --R = R
 proof R + -R = (i|->0.K) by Lm3; hence thesis by Th36; end;

theorem
      -R1 = -R2 implies R1 = R2
 proof assume -R1 = -R2; hence R1 = --R2 by Th37 .= R2 by Th37; end;

Lm4: R1 + R = R2 + R implies R1 = R2
 proof assume R1 + R = R2 + R;
  then R1 + (R + -R)= (R2 + R)+-R by Th27;
  then R1 + (R + -R)= R2 + (R + -R) & R + -R = (i|->0.K) by Lm3,Th27;
  then R1 = R2 + (i|->(0.K)) by Lm2;
  hence R1 = R2 by Lm2;
 end;

theorem
    for K being Abelian right_zeroed add-associative right_complementable
        (non empty LoopStr),
   R,R1,R2 being Element of i-tuples_on the carrier of K holds
   R1 + R = R2 + R or R1 + R = R + R2 implies R1 = R2
 proof
  let K be Abelian right_zeroed add-associative right_complementable
        (non empty LoopStr),
   R,R1,R2 be Element of i-tuples_on the carrier of K;
     R1 + R = R2 + R iff R1 + R = R + R2 by Th26;
  hence thesis by Lm4;
 end;

theorem Th40:
 for K being Abelian right_zeroed add-associative right_complementable
        (non empty LoopStr),
   R1,R2 being Element of i-tuples_on the carrier of K holds
   -(R1 + R2) = -R1 + -R2
 proof
  let K be Abelian right_zeroed add-associative right_complementable
        (non empty LoopStr),
   R1,R2 be Element of i-tuples_on the carrier of K;
      (R1 + R2) + (-R1 + -R2) = R1 + R2 + -R1 + -R2 by Th27
                          .= R2 + R1 + -R1 + -R2 by Th26
                          .= R2 + (R1 + -R1) + -R2 by Th27
                          .= R2 + (i|->(0.K)) + -R2 by Lm3
                          .= R2 + -R2 by Lm2
                          .= (i|->0.K) by Lm3;
   hence thesis by Th36;
 end;

definition let K be non empty LoopStr;
  let p1,p2 be FinSequence of the carrier of K;
  func p1 - p2 -> FinSequence of the carrier of K equals
  (diffield(K)).:(p1,p2);
   correctness;
end;

 reserve K for non empty LoopStr,
  a1,a2 for Element of K,
  p1,p2 for FinSequence of the carrier of K,
  R1,R2 for Element of i-tuples_on the carrier of K;

canceled;

theorem Th42:
   i in dom (p1-p2) & a1 = p1.i & a2 = p2.i implies (p1-p2).i = a1 - a2
 proof assume that
A1: i in dom (p1-p2) and
A2: a1 = p1.i & a2 = p2.i;
     p1 - p2 = (diffield(K)).:(p1,p2) & i in dom(p1-p2) by A1;
  then (p1 - p2).i = (diffield(K)).(a1,a2) by A2,FUNCOP_1:28;
  hence thesis by Th14;
 end;

definition let i;let K be non empty LoopStr;
  let R1,R2 be Element of i-tuples_on the carrier of K;
 redefine func R1 - R2 -> Element of i-tuples_on the carrier of K;
  coherence by FINSEQ_2:140;
end;

theorem
      j in Seg i & a1 = R1.j & a2 = R2.j implies (R1-R2).j = a1 - a2
 proof assume j in Seg i; then j in Seg len (R1-R2) by FINSEQ_2:109;
  then j in dom (R1-R2) by FINSEQ_1:def 3;
  hence thesis by Th42;
 end;

theorem
      <*>(the carrier of K) - p1 = <*>(the carrier of K) &
   p1 - <*>(the carrier of K) = <*>(the carrier of K) by FINSEQ_2:87;

theorem
      <*a1*> - <*a2*> = <*a1-a2*>
 proof
   thus <*a1*> - <*a2*> = (diffield(K)).:(<*a1*>,<*a2*>)
                       .= <*(diffield(K)).(a1,a2)*> by FINSEQ_2:88
                       .= <*a1-a2*> by Th14;
 end;

theorem
      (i|->a1) - (i|->a2) = i|->(a1-a2)
 proof
   thus (i|->a1) - (i|->a2) = (diffield(K)).:((i|->a1),(i|->a2))
                           .= i|->((diffield(K)).(a1,a2)) by FINSEQOP:18
                           .= i|->(a1-a2) by Th14;
 end;

theorem Th47:
   R1 - R2 = R1 + - R2 by FINSEQOP:89;

theorem
    for K being add-associative right_complementable left_zeroed right_zeroed
        (non empty LoopStr),
  R being Element of i-tuples_on the carrier of K holds
   R - (i|->(0.K)) = R
 proof
 let K be add-associative right_complementable left_zeroed right_zeroed
        (non empty LoopStr),
  R be Element of i-tuples_on the carrier of K;
  thus R - (i|->(0.K)) = R + - (i|->(0.K)) by Th47
                      .= R + (i|->(-0.K)) by Th34
                      .= R + (i|->(0.K)) by RLVECT_1:25
                      .= R by Lm2;
 end;

theorem
    for K being Abelian left_zeroed right_zeroed (non empty LoopStr),
     R being Element of i-tuples_on the carrier of K holds
   (i|->(0.K)) - R = -R
 proof
 let K be Abelian left_zeroed right_zeroed (non empty LoopStr),
     R be Element of i-tuples_on the carrier of K;
 thus (i|->(0.K)) - R = (i|->(0.K)) + -R by Th47
 .= - R by Th28; end;

theorem
    for K being left_zeroed right_zeroed add-associative right_complementable
    (non empty LoopStr),
  R1,R2 being Element of i-tuples_on the carrier of K holds
   R1 - -R2 = R1 + R2
 proof
 let K be left_zeroed right_zeroed add-associative right_complementable
    (non empty LoopStr),
  R1,R2 be Element of i-tuples_on the carrier of K;
 thus R1 - -R2 = R1 + --R2 by Th47 .= R1 + R2 by Th37;
 end;

 reserve K for Abelian right_zeroed add-associative right_complementable
    (non empty LoopStr),
  R,R1,R2,R3 for Element of i-tuples_on the carrier of K;

theorem
      -(R1 - R2) = R2 - R1
 proof
   thus -(R1 - R2) = -(R1 + -R2) by Th47
                  .= -R1 + --R2 by Th40
                  .= -R1 + R2 by Th37
                  .= R2 + -R1 by Th26
                  .= R2 - R1 by Th47;
 end;

theorem Th52:
   -(R1 - R2) = -R1 + R2
 proof
   thus -(R1 - R2) = -(R1+ -R2) by Th47
                  .= -R1 +--R2 by Th40
                  .= -R1 + R2 by Th37;
 end;

theorem Th53:
   R - R = (i|->0.K)
 proof thus R - R = R + - R by Th47 .= (i|->0.K) by Lm3; end;

theorem
      R1 - R2 = (i|->0.K) implies R1 = R2
 proof assume R1 - R2 = (i|->0.K);
   then R1 + - R2 = (i|->0.K) by Th47;
   then R1 = --R2 by Th36;
   hence thesis by Th37;
 end;

theorem
      R1 - R2 - R3 = R1 - (R2 + R3)
 proof
   thus R1 - R2 - R3 = R1 - R2 + - R3 by Th47
                    .= R1 + - R2 + - R3 by Th47
                    .= R1 + (- R2 + - R3) by Th27
                    .= R1 + -(R2 + R3) by Th40
                    .= R1 - (R2 + R3) by Th47;
 end;

theorem Th56:
   R1 + (R2 - R3) = R1 + R2 - R3
 proof
   thus R1 + (R2 - R3) = R1 + (R2 + - R3) by Th47
                      .= R1 + R2 + - R3 by Th27
                      .= R1 + R2 - R3 by Th47;
 end;

theorem
      R1 - (R2 - R3) = R1 - R2 + R3
 proof
   thus R1 - (R2 - R3) = R1 + - (R2 - R3) by Th47
                      .= R1 + (- R2 + R3) by Th52
                      .= R1 + - R2 + R3 by Th27
                      .= R1 - R2 + R3 by Th47;
 end;

theorem
      R1 = R1 + R - R
 proof
   thus R1 = R1 + (i|->(0.K)) by Lm2
          .= R1 + (R - R) by Th53
          .= R1 + R - R by Th56;
 end;

theorem
      R1 = R1 - R + R
 proof
   thus R1 = R1 + (i|->(0.K)) by Lm2
          .= R1 + (-R + R) by Th35
          .= R1 + -R + R by Th27
          .= R1 - R + R by Th47;
 end;

 reserve K for non empty HGrStr,
  a,a',a1,a2 for Element of K,
  p for FinSequence of the carrier of K,
  R for Element of i-tuples_on the carrier of K;

theorem
Th60:for a,b being Element of K holds
   ((the mult of K)[;](a,id the carrier of K)).b = a*b
 proof let a,b be Element of K;
  thus ((the mult of K)[;](a,id (the carrier of K))).b =
        (the mult of K).(a,(id (the carrier of K)).b) by FUNCOP_1:66
                               .= (the mult of K).(a,b) by FUNCT_1:35
                               .= a*b by GROUP_1:def 1;
 end;

theorem
   for a,b being Element of K holds
   (a multfield).b = a*b by Th60;

definition let K be non empty HGrStr;
   let p be FinSequence of the carrier of K;
   let a be Element of K;
  func a*p -> FinSequence of the carrier of K equals
  (a multfield)*p;
   correctness;
end;

theorem Th62:
   i in dom (a*p) & a' = p.i implies (a*p).i = a*a'
proof assume that
A1:  i in dom (a*p) and
A2:  a' = p.i;
A3:  i in dom(a*p) & a*p = ((the mult of K)[;](a,id the carrier of K))*p
by A1;
then A4:  a' in dom((the mult of K)[;](a,id the carrier of K))
   by A2,FUNCT_1:21;
  thus (a*p).i = ((the mult of K)[;](a,id the carrier of K)).a'
                 by A2,A3,FUNCT_1:22
              .=(the mult of K).(a,(id the carrier of K).a')
                  by A4,FUNCOP_1:42
              .= (the mult of K).(a,a') by FUNCT_1:35
              .= a*a' by GROUP_1:def 1;
 end;

definition let i;let K be non empty HGrStr;
  let R be Element of i-tuples_on the carrier of K;
  let a be Element of K;
 redefine func a*R -> Element of i-tuples_on the carrier of K;
  coherence by FINSEQ_2:133;
end;

theorem
      j in Seg i & a' = R.j implies (a*R).j = a*a'
 proof assume j in Seg i; then j in Seg len (a*R) by FINSEQ_2:109;
  then j in dom (a*R) by FINSEQ_1:def 3;
  hence thesis by Th62;
 end;

theorem
     a*(<*>(the carrier of K)) = <*>(the carrier of K) by FINSEQ_2:38;

theorem
      a*<*a1*> = <*a*a1*>
 proof
   thus a*<*a1*>
     = ((the mult of K)[;](a,id the carrier of K))*<*a1*>
    .= <*((the mult of K)[;](a,id the carrier of K)).a1*>
        by FINSEQ_2:39
    .= <*a*a1*> by Th60;
 end;

theorem Th66:
   a1*(i|->a2) = i|->(a1*a2)
 proof
   thus a1*(i|->a2) =
     ((the mult of K)[;](a1,id the carrier of K))*(i|->a2)
     .= i|->(((the mult of K)[;](a1,id the carrier of K)).a2)
         by FINSEQOP:17
     .= i|->(a1*a2) by Th60;
 end;

theorem
    for K being associative (non empty HGrStr),
  a1,a2 being Element of K,
  R being Element of i-tuples_on the carrier of K holds
   (a1*a2)*R = a1*(a2*R)
 proof
  let K be associative (non empty HGrStr),
  a1,a2 be Element of K,
  R be Element of i-tuples_on the carrier of K;
   set F=the mult of K;
   set f=id the carrier of K;
    A1:F is associative by GROUP_1:31;
  thus (a1*a2)*R
      = ((the mult of K)[;](a1*a2,id the carrier of K))*R
     .= (F[;](F.(a1,a2),f))*R by GROUP_1:def 1
    .= (F[;](a1,F[;](a2,f)))*R by A1,FUNCOP_1:77
     .= ((the mult of K)[;](a1,id the carrier of K)*
         (the mult of K)[;](a2,id the carrier of K))*R by FUNCOP_1:69
     .= ((the mult of K)[;](a1,id the carrier of K))*
         ((the mult of K)[;](a2,id the carrier of K)*R) by RELAT_1:55
     .= ((the mult of K)[;](a1,id the carrier of K))*(a2*R)
     .= a1*(a2*R);
 end;

 reserve
  K for distributive (non empty doubleLoopStr),
  a,a1,a2 for Element of K,
  R,R1,R2 for Element of i-tuples_on the carrier of K;

theorem
      (a1 + a2)*R = a1*R + a2*R
 proof
  A1:the mult of K is_distributive_wrt the add of K by Th12;
  thus (a1 + a2)*R
    = ((the mult of K)[;](a1 + a2,id the carrier of K))*R
   .= (the mult of K)[;]
       ((the add of K).(a1,a2),id the carrier of K)*R by RLVECT_1:5
   .= (the add of K).:((the mult of K)[;](a1,id the carrier of K),
       (the mult of K)[;](a2,id the carrier of K))*R
         by A1,FINSEQOP:36
    .= (the add of K).:((the mult of K)[;] (a1,id the carrier of K)*R,
       (the mult of K)[;](a2,id the carrier of K)*R) by FUNCOP_1:31
    .= (the mult of K)[;](a1,id the carrier of K)*R +
        (the mult of K)[;](a2,id the carrier of K)*R
    .= a1*R + (the mult of K)[;](a2,id the carrier of K)*R
    .= a1*R + a2*R;
 end;

theorem
      a*(R1+R2) = a*R1 + a*R2
 proof set aM = a multfield;
A1:  a multfield is_distributive_wrt the add of K by Th15;
  thus a*(R1+R2)
     = aM*(R1 + R2)
    .= aM*((the add of K).:(R1,R2))
    .= (the add of K).:(aM*R1,aM*R2) by A1,FINSEQOP:52
    .= aM*R1 + aM*R2
    .= a*R1 + aM*R2
    .= a*R1 + a*R2;
 end;

theorem
    for K being distributive commutative left_unital (non empty doubleLoopStr),
     R being Element of i-tuples_on the carrier of K holds
   1.K * R = R
 proof
 let K be distributive commutative left_unital (non empty doubleLoopStr),
     R be Element of i-tuples_on the carrier of K;
   A1:the_unity_wrt the mult of K = 1.K &
   the mult of K has_a_unity by Th7,Th11;
A2: rng R c= the carrier of K by FINSEQ_1:def 4;
   thus 1.K * R = (the mult of K)[;](1.K,id the carrier of K)*R
           .= (id the carrier of K)*R by A1,FINSEQOP:45
           .= R by A2,RELAT_1:79;

 end;

theorem
    for K being add-associative right_zeroed right_complementable
    distributive (non empty doubleLoopStr),
  R being Element of i-tuples_on the carrier of K holds
   0.K*R = i|->0.K
 proof
 let K be add-associative right_zeroed right_complementable distributive
   (non empty doubleLoopStr),
  R be Element of i-tuples_on the carrier of K;
  A1:the_unity_wrt the add of K = 0.K & the add of K has_a_unity by Th9,Th10;
  A2:the mult of K is_distributive_wrt the add of K by Th12;
  A3:the add of K has_an_inverseOp by Th17;
A4:  rng R c= (the carrier of K) by FINSEQ_1:def 4;
  thus 0.K*R =(the mult of K)[;](0.K,id the carrier of K)*R
          .= (the mult of K)[;](0.K,(id the carrier of K)*R)
            by FUNCOP_1:44
          .= (the mult of K)[;](0.K,R) by A4,RELAT_1:79
          .= i|->0.K by A1,A2,A3,FINSEQOP:80;
 end;

theorem
    for K being add-associative right_zeroed right_complementable
   commutative left_unital distributive (non empty doubleLoopStr),
  R being Element of i-tuples_on the carrier of K holds
  (-1.K) * R = -R
 proof
 let K be add-associative right_zeroed right_complementable
   commutative left_unital distributive (non empty doubleLoopStr),
  R be Element of i-tuples_on the carrier of K;
   A1:(comp K).(1.K) = -1.K by VECTSP_1:def 25;
   A2:the_unity_wrt the mult of K = 1.K &
   the mult of K has_a_unity by Th7,Th11;
  A3:the mult of K is_distributive_wrt the add of K by Th12;
  A4: the add of K has_a_unity &
  the add of K has_an_inverseOp &
   the_inverseOp_wrt the add of K = (comp K) by Th10,Th17,Th18;
   reconsider a=-1.K as Element of K;
   thus (-1.K)*R=((the mult of K)[;](a,id the carrier of K))*R
     .= (comp K)*R by A1,A2,A3,A4,FINSEQOP:72
     .= -R;
 end;

definition let M be non empty HGrStr,
               p1, p2 be FinSequence of the carrier of M;
  func mlt(p1,p2) -> FinSequence of the carrier of M equals
  (the mult of M).:(p1,p2);
  correctness;
end;

 reserve K for non empty HGrStr,
  a1,a2,b1,b2 for Element of K,
  p,p1,p2 for FinSequence of the carrier of K,
  R1,R2 for Element of i-tuples_on the carrier of K;

theorem Th73:
   i in dom mlt(p1,p2) & a1 = p1.i & a2 = p2.i
     implies mlt(p1,p2).i = a1 * a2
 proof assume that
A1: i in dom mlt(p1,p2) and
A2: a1 = p1.i & a2 = p2.i;
     mlt(p1,p2) = (the mult of K).:(p1,p2) & i in dom mlt(p1,p2) by A1;
  then mlt(p1,p2).i = (the mult of K).(a1,a2) by A2,FUNCOP_1:28;
  hence thesis by GROUP_1:def 1;
 end;

definition let i;let K be non empty HGrStr;
  let R1,R2 be Element of i-tuples_on the carrier of K;
 redefine func mlt(R1,R2) -> Element of i-tuples_on the carrier of K;
  coherence by FINSEQ_2:140;
end;

theorem
      j in Seg i & a1 = R1.j & a2 = R2.j implies mlt(R1,R2).j = a1 * a2
 proof assume j in Seg i; then j in Seg len mlt(R1,R2) by FINSEQ_2:109;
  then j in dom mlt(R1,R2) by FINSEQ_1:def 3;
  hence thesis by Th73;
 end;

theorem
      mlt(<*>(the carrier of K),p) = <*>(the carrier of K) &
    mlt(p,<*>(the carrier of K)) = <*>(the carrier of K) by FINSEQ_2:87;

theorem
Th76:mlt(<*a1*>,<*a2*>) = <*a1*a2*>
 proof
  thus mlt(<*a1*>,<*a2*>) = (the mult of K).:(<*a1*>,<*a2*>)
                         .= <*(the mult of K).(a1,a2)*> by FINSEQ_2:88
                         .= <*a1*a2*> by GROUP_1:def 1;
 end;

Lm5: mlt(R1^<*a1*>,R2^<*a2*>) = (mlt(R1,R2))^<*a1*a2*>
 proof
  thus mlt(R1^<*a1*>,R2^<*a2*>)
      = (the mult of K).:(R1^<*a1*>,R2^<*a2*>)
     .= ((the mult of K).:(R1,R2))^<*(the mult of K).(a1,a2)*> by FINSEQOP:11
     .= ((the mult of K).:(R1,R2))^<*a1*a2*> by GROUP_1:def 1
     .= (mlt(R1,R2))^<*a1*a2*>;
 end;

Lm6:mlt(<*a1,a2*>,<*b1,b2*>)=<*a1*b1,a2*b2*>
proof
      <*a1,a2*>=<*a1*>^<*a2*>& <*b1,b2*>=<*b1*>^<*b2*> by FINSEQ_1:def 9;
   hence mlt(<*a1,a2*>,<*b1,b2*>)=mlt(<*a1*>,<*b1*>)^<*a2*b2*> by Lm5
                        .=<*a1*b1*>^<*a2*b2*> by Th76
                        .=<*a1*b1,a2*b2*> by FINSEQ_1:def 9;
end;

 reserve K for commutative (non empty HGrStr),
         p,q for FinSequence of the carrier of K,
         R1,R2 for Element of i-tuples_on the carrier of K;

theorem Th77:
   mlt(R1,R2) = mlt(R2,R1)
 proof
   thus mlt(R1,R2) = (the mult of K).:(R1,R2)
                  .= (the mult of K).:(R2,R1) by FINSEQOP:34
                  .= mlt(R2,R1);
 end;

theorem
Th78:mlt(p,q)=mlt(q,p)
 proof
     reconsider r=mlt(p,q) as FinSequence of the carrier of K;
     reconsider s=mlt(q,p) as FinSequence of the carrier of K;
      A1:len r =min(len p,len q) & len s=min(len q,len p) by
FINSEQ_2:85;
     reconsider k=min(len p,len q) as Nat by XXREAL_0:15;
     A2:dom r=Seg k & dom s=Seg k by A1,FINSEQ_1:def 3;
        min(len p,len q)<= len p & min(len p,len q)<=len q by XXREAL_0:17;
     then Seg k c= Seg len p & Seg k c= Seg len q by FINSEQ_1:7;
     then A3:Seg k c= dom p & Seg k c= dom q by FINSEQ_1:def 3;
        now let i;
      assume A4:i in Seg k;
      then reconsider d1=(p.i),d2=(q.i) as Element of K
       by A3,FINSEQ_2:13;
      thus r.i=(the mult of K).(p.i,q.i) by A2,A4,FUNCOP_1:28
             .=d1*d2 by GROUP_1:def 1
             .=(the mult of K).(q.i,p.i) by GROUP_1:def 1
             .=s.i by A2,A4,FUNCOP_1:28;
    end;
    hence thesis by A1,FINSEQ_2:10;
  end;

theorem
    for K being associative (non empty HGrStr),
     R1,R2,R3 being Element of i-tuples_on the carrier of K holds
 mlt(R1,mlt(R2,R3)) = mlt(mlt(R1,R2),R3)
 proof
 let K be associative (non empty HGrStr),
     R1,R2,R3 be Element of i-tuples_on the carrier of K;
   A1:the mult of K is associative by GROUP_1:31;
  thus mlt(R1,mlt(R2,R3)) = (the mult of K).:(R1,mlt(R2,R3))
                         .= (the mult of K).:(R1,(the mult of K).:(R2,R3))
                         .= (the mult of K).:((the mult of K).:(R1,R2),R3)
                         by A1,FINSEQOP:29
                         .= (the mult of K).:(mlt(R1,R2),R3)
                         .= mlt(mlt(R1,R2),R3);
 end;

 reserve K for commutative associative (non empty HGrStr),
         a,a1,a2 for Element of K,
         R for Element of i-tuples_on the carrier of K;

theorem Th80:
   mlt(i|->a,R) = a*R & mlt(R,i|->a) = a*R
 proof
  thus mlt(i|->a,R) = (the mult of K).:(i|->a,R)
                   .= (the mult of K)[;](a,R) by FINSEQOP:21
                   .= (the mult of K)[;](a,(id (the carrier of K)))*R
                   by FINSEQOP:23
                   .= a*R;
  hence thesis by Th77;
 end;

theorem
      mlt(i|->a1,i|->a2) = i|->(a1*a2)
 proof
   thus mlt(i|->a1,i|->a2) = a1*(i|->a2) by Th80
                          .= i|->(a1*a2) by Th66;
 end;

theorem Th82:
 for K being associative (non empty HGrStr),
     a being Element of K,
     R1,R2 being Element of i-tuples_on the carrier of K holds
   a*mlt(R1,R2) = mlt(a*R1,R2)
 proof
 let K be associative (non empty HGrStr),
     a be Element of K,
     R1,R2 be Element of i-tuples_on the carrier of K;
   A1:the mult of K is associative by GROUP_1:31;
   thus a*mlt(R1,R2)
      = ((the mult of K)[;](a,id (the carrier of K)))*(mlt(R1,R2))
     .= ((the mult of K)[;](a,id (the carrier of K)))*((the mult of K).:
(R1,R2))
     .= (the mult of K).:(((the mult of K)[;](a,id (the carrier of K)))*R1,R2)
     by A1,FINSEQOP:27
     .= (the mult of K).:(a*R1,R2)
     .= mlt(a*R1,R2);
 end;

 reserve K for commutative associative (non empty HGrStr),
         a for Element of K,
         R,R1,R2 for Element of i-tuples_on the carrier of K;

theorem
      a*mlt(R1,R2) = mlt(a*R1,R2) & a*mlt(R1,R2) = mlt(R1,a*R2)
 proof
  thus a*mlt(R1,R2) = mlt(a*R1,R2) by Th82;
  thus a*mlt(R1,R2) = a*mlt(R2,R1) by Th77
                   .= mlt(a*R2,R1) by Th82
                   .= mlt(R1,a*R2) by Th77;
 end;

theorem
      a*R = mlt(i|->a,R) by Th80;

begin
::
::The Sum of Finite Number of Elements
::

registration
 cluster Abelian right_zeroed -> left_zeroed (non empty LoopStr);
 coherence
  proof let L be non empty LoopStr such that
A1: L is Abelian and
A2: L is right_zeroed;
   let x be Element of L;
   thus 0.L + x = x + 0.L by A1,RLVECT_1:def 5 .= x by A2,RLVECT_1:def 7;
  end;
end;

definition
 let K be Abelian add-associative right_zeroed
                 right_complementable (non empty LoopStr);
 let p be FinSequence of the carrier of K;
 redefine func Sum(p) equals
  (the add of K) $$ p;
  compatibility
  proof let s be Element of K;
   hereby assume
A1:  s = Sum(p);
A2: the add of K has_a_unity by Th10;
A3:  dom p = Seg len p by FINSEQ_1:def 3;
    defpred P[set,set] means
     ex q being FinSequence of the carrier of K
        st q = p*Sgm dom(p|$1) & $2 = Sum q;
A4: for x being Element of Fin NAT
    ex y being Element of K st P[x,y]
    proof let B be Element of Fin NAT;
     per cases;
     suppose dom p = {};
then A5:    p = {} by RELAT_1:64;
     reconsider q = <*>the carrier of K as FinSequence of the carrier of K;
     reconsider u = Sum<*>the carrier of K as Element of K;
     take u, q;
     thus q = p*Sgm dom(p|B) by A5,RELAT_1:62;
     thus u = Sum q;
     end;
     suppose
A6:    dom p <> {};
A7:   dom(p|B) c= dom p by RELAT_1:89;
     then reconsider pB = p|B as FinSubsequence by A3,FINSEQ_1:def 12;
     reconsider domp = dom p as non empty set by A6;
        rng Sgm dom pB = dom pB by FINSEQ_1:71;
     then reconsider p'' = Sgm dom(p|B) as FinSequence of domp by A7,
FINSEQ_1:def 4;
     reconsider p' = p as Function of domp, the carrier of K by FINSEQ_2:30;
     reconsider q = p'*p'' as FinSequence of the carrier of K;
     reconsider u = Sum q as Element of K;
     take u, q;
     thus q = p*Sgm dom(p|B) & u = Sum q;
    end;
    end;
    consider G being Function of Fin NAT, the carrier of K such that
A8:   for B being Element of Fin NAT holds P[B,G.B] from FUNCT_2:sch 3(A4);
    consider q1 being FinSequence of the carrier of K such that
A9: q1 = p*Sgm dom(p|dom p) and
A10: G.dom p = Sum q1 by A8;
A11:  q1 = p*Sgm dom p by A9,RELAT_1:98
       .= p*Sgm Seg len p by FINSEQ_1:def 3
       .= p*idseq len p by FINSEQ_3:54
       .= p by FINSEQ_2:64;
A12:  now let e be Element of K;
      consider q being FinSequence of the carrier of K such that
A13:    q = p*Sgm dom(p|{}.NAT) and
A14:    G.{}.NAT = Sum q by A8;
A15:    q = p*Sgm dom {} by A13,RELAT_1:110
       .= p*{} by FINSEQ_1:4,72,RELAT_1:60
       .= <*>the carrier of K by RELAT_1:62;
     assume
A16:    e is_a_unity_wrt the add of K;
         0.K is_a_unity_wrt the add of K by Th8;
      then e = 0.K by A16,BINOP_1:18;
     hence e = G.{} by A14,A15,RLVECT_1:60;
    end;
A17:  now let x be Element of NAT;
      consider q being FinSequence of the carrier of K such that
A18:    q = p*Sgm dom(p|{x}) and
A19:    G.{x} = Sum q by A8;
     per cases;
     suppose
A20:    not x in dom p;
      then dom p misses {x} by ZFMISC_1:56;
then dom p /\ {x} = {} by XBOOLE_0:def 7;
      then q = p*Sgm {} by A18,RELAT_1:90
       .= p*{} by FINSEQ_1:4,72
       .= <*>the carrier of K by RELAT_1:62;
     hence G.{x} = 0.K by A19,RLVECT_1:60
       .= the_unity_wrt the add of K by Th9
       .= [#](p,the_unity_wrt the add of K).x by A20,SETWOP_2:22;
     end;
     suppose
A21:    x in dom p;
      then p.x = p/.x by FINSEQ_4:def 4;
      then reconsider px = p.x as Element of K;
      A22:    x <> 0 by A21,FINSEQ_3:27;
A23:    dom<*x*> = Seg 1 & dom<*px*> = Seg 1 by FINSEQ_1:55;
         rng<*x*> = { x } by FINSEQ_1:55;
      then rng<*x*> c= dom p by A21,ZFMISC_1:37;
then A24:    dom(p*<*x*>) = dom<*px*> by A23,RELAT_1:46;
A25:    now let e be set;
       assume
A26:     e in dom<*px*>;
        then A27:      e = 1 by A23,FINSEQ_1:4,TARSKI:def 1;
       thus (p*<*x*>).e = p.(<*x*>.e) by A24,A26,FUNCT_1:22
            .= p.x by A27,FINSEQ_1:57
            .= <*px*>.e by A27,FINSEQ_1:57;
      end;
         q = p*Sgm(dom p /\ {x}) by A18,RELAT_1:90
       .= p*Sgm{x} by A21,ZFMISC_1:52
       .= p*<*x*> by A22,FINSEQ_3:50
       .= <*px*> by A24,A25,FUNCT_1:9;
     hence G.{x} = px by A19,RLVECT_1:61
       .= [#](p,the_unity_wrt the add of K).x by A21,SETWOP_2:22;
    end;
    end;
       now let B' be Element of Fin NAT such that
      B' c= dom p and
      B' <> {};
      consider q1 being FinSequence of the carrier of K such that
A28:    q1 = p*Sgm dom(p|B') and
A29:    G.B' = Sum q1 by A8;
     let x be Element of NAT; assume
A30:   x in dom p \ B';
      consider q2 being FinSequence of the carrier of K such that
A31:    q2 = p*Sgm dom(p|(B' \/ {x})) and
A32:    G.(B' \/ {x}) = Sum q2 by A8;
      set f2 = Sgm dom(p|(B' \/ {x})),
          f3 = f2 -| x, f4 = f2 |-- x;
A33:  dom(p|(B' \/ {x})) c= dom p by RELAT_1:89;
         dom p = Seg len p by FINSEQ_1:def 3;
      then reconsider pp = p|(B' \/ {x}) as FinSubsequence
                                                by A33,FINSEQ_1:def 12;
A34:  rng Sgm dom pp = dom pp by FINSEQ_1:71;
then A35:    rng f2 c= dom p by RELAT_1:89;
A36:    x in dom p by A30,XBOOLE_0:def 4;
      then p.x = p/.x by FINSEQ_4:def 4;
      then reconsider px = p.x as Element of K;
         x in {x} by TARSKI:def 1;
then A37:   x in B' \/ {x} by XBOOLE_0:def 2;
         dom pp = dom p /\ (B' \/ {x}) by RELAT_1:90;
then A38:   x in rng f2 by A34,A36,A37,XBOOLE_0:def 3;
      dom(p|(B' \/ {x})) = dom p /\ (B' \/ {x}) by RELAT_1:90;
      then dom(p|(B' \/ {x})) c= dom p by XBOOLE_1:17;
then A39:    dom(p|(B' \/ {x})) c= Seg len p by FINSEQ_1:def 3;
      then reconsider pB'x = p|(B' \/ {x}) as FinSubsequence
                                         by FINSEQ_1:def 12;
A40:   f2 is one-to-one by A39,FINSEQ_3:99;
      reconsider Y = Seg(len f2) \ f2 " {x} as finite set;
         Seg(len f2) = dom f2 by FINSEQ_1:def 3;
then A41:   Y c= dom Sgm (dom(p|(B' \/ {x}))) by XBOOLE_1:36;
A42:   dom(p|B') = dom p /\ B' by RELAT_1:90;
         not x in B' by A30,XBOOLE_0:def 4;
then A43:   not x in dom(p|B') by A42,XBOOLE_0:def 3;
         x in dom p by A30,XBOOLE_0:def 4;
then A44:   {x} c= dom p by ZFMISC_1:37;
A45:   rng ((Sgm (dom(p|(B' \/ {x}))))|
             (Seg(len f2) \ f2 " {x}))
         = (Sgm (dom(p|(B' \/ {x})))).:(Seg(len f2) \ f2 " {x}) by RELAT_1:148
        .= (Sgm (dom(p|(B' \/ {x})))).:(dom f2 \ f2 " {x}) by FINSEQ_1:def 3
        .= (Sgm (dom(p|(B' \/ {x})))).:(dom f2) \ {x} by SETWISEO:11
        .= rng Sgm dom pB'x \ {x} by RELAT_1:146
        .= dom(p|(B' \/ {x})) \ {x} by FINSEQ_1:71
        .= (dom p /\ (B' \/ {x})) \ {x} by RELAT_1:90
        .= (dom p /\ B' \/ dom p /\ {x}) \ {x} by XBOOLE_1:23
        .= dom p /\ B' \/ {x} \ {x} by A44,XBOOLE_1:28
        .= dom(p|B') \ {x} by A42,XBOOLE_1:40
        .= dom(p|B') by A43,ZFMISC_1:65;
A46: Y c= Seg len f2 by XBOOLE_1:36;
  set M = f2*(Sgm Y);
A47: dom Sgm Y = Seg card Y by A46,FINSEQ_3:45;
A48: rng Sgm Y = Y by A46,FINSEQ_1:def 13;
  then dom M = Seg card Y by A41,A47,RELAT_1:46;
  then reconsider M as FinSequence by FINSEQ_1:def 2;
     rng f2 c= Seg len p by A39,FINSEQ_1:def 13;
  then A49: rng f2 c= dom p by FINSEQ_1:def 3;
A50: rng f2 c= NAT by FINSEQ_1:def 4;
     rng M c= rng f2 by RELAT_1:45;
  then rng M c= NAT by A50,XBOOLE_1:1;
  then reconsider L = f2*(Sgm Y) as FinSequence of NAT by FINSEQ_1:def 4;
  set R = rng (f2|Y);
     R c= rng f2 by RELAT_1:99;
 then R c= dom p by A49,XBOOLE_1:1;
then A51: R c= Seg len p by FINSEQ_1:def 3;
     now let y be set;
   hereby assume y in rng L; then consider x be set such that
A52:  x in dom L & y = L.x by FUNCT_1:def 5;
A53:  y = f2.((Sgm Y).x) by A52,FUNCT_1:22;
       x in dom Sgm Y by A52,FUNCT_1:21;
  then (Sgm Y).x in Y by A48,FUNCT_1:def 5; hence y in R by A41,A53,FUNCT_1:73
;
   end;
   assume y in R; then consider x be set such that
A54:  x in dom (f2|Y) & y = (f2|Y).x by FUNCT_1:def 5;
       x in (dom f2)/\Y by A54,RELAT_1:90;
then A55:  x in dom f2 & x in Y by XBOOLE_0:def 3;
    then consider z being set such that
A56:  z in dom Sgm Y & x = (Sgm Y).z by A48,FUNCT_1:def 5;
A57:  z in dom(f2*(Sgm Y)) by A55,A56,FUNCT_1:21;
    then L.z = f2.((Sgm Y).z) by FUNCT_1:22 .= y by A54,A55,A56,FUNCT_1:72;
   hence y in rng L by A57,FUNCT_1:def 5;
  end;
then A58: rng L = R by TARSKI:2;
   now let l,m,k1,k2 be natural number; assume
A59:   1 <= l & l < m & m <= len L & k1=L.l & k2=L.m;
     then l <= len L & 1<=m by XXREAL_0:2;
then A60:   l in dom L & m in dom L by A59,FINSEQ_3:27;
then A61:   L.l = f2.((Sgm Y).l) & L.m = f2.((Sgm Y).m) by FUNCT_1:22;
A62:   l in dom Sgm Y & (Sgm Y).l in dom f2 &
     m in dom Sgm Y & (Sgm Y).m in dom f2 by A60,FUNCT_1:21;
     then A63:   1<=l & l<=len Sgm Y & 1<=m & m<=len Sgm Y by FINSEQ_3:27;
     reconsider l,m as Nat by ORDINAL2:def 21;
     reconsider K1 = (Sgm Y).l, K2 = (Sgm Y).m as Nat by A62,FINSEQ_2:13;
A64:   K1 < K2 by A46,A59,A63,FINSEQ_1:def 13;
       1<=K1 & K1<=len f2 & 1<=K2 & K2<=len f2 by A62,FINSEQ_3:27;
    hence k1 < k2 by A39,A59,A61,A64,FINSEQ_1:def 13;
   end;
then A65: Sgm dom(p|B') = f2*Sgm(Seg(len f2) \ f2 " {x}) by A45,A51,A58,
FINSEQ_1:def 13
        .= f2*Sgm(dom f2 \ f2 " {x}) by FINSEQ_1:def 3
        .= f2 - {x} by FINSEQ_3:def 1
        .= f3^f4 by A38,A40,FINSEQ_4:70;
      reconsider D = dom p, E = rng p as non empty set by A36,RELAT_1:65;
      reconsider p' = p as Function of D, E by FUNCT_2:3;
      reconsider x' = x as Element of D by A30,XBOOLE_0:def 4;
         rng f3 c= rng f2 & rng f4 c= rng f2 by A38,FINSEQ_4:51,59;
      then rng f3 c= D & rng f4 c= D by A35,XBOOLE_1:1;
      then reconsider f3' = f3, f4' = f4 as FinSequence of D by FINSEQ_1:def 4;
      reconsider p3 = p'*f3', p4 = p'*f4' as FinSequence of E;
A66:   rng p3 c= E & rng p4 c= E by FINSEQ_1:def 4;
         E c= the carrier of K by FINSEQ_1:def 4;
      then rng p3 c= the carrier of K & rng p4 c= the carrier of K
                                                  by A66,XBOOLE_1:1;
      then reconsider p3, p4 as FinSequence of the carrier of K
                                                  by FINSEQ_1:def 4;
A67:    dom<*x*> = Seg 1 & dom<*px*> = Seg 1 by FINSEQ_1:55;
         rng<*x*> = { x } by FINSEQ_1:55;
      then rng<*x*> c= dom p by A36,ZFMISC_1:37;
then A68:    dom(p*<*x*>) = dom<*px*> by A67,RELAT_1:46;
A69:    now let e be set;
       assume
A70:     e in dom<*px*>;
        then A71:      e = 1 by A67,FINSEQ_1:4,TARSKI:def 1;
       thus (p*<*x*>).e = p.(<*x*>.e) by A68,A70,FUNCT_1:22
            .= p.x by A71,FINSEQ_1:57
            .= <*px*>.e by A71,FINSEQ_1:57;
      end;
A72:   q1 = p3^p4 by A28,A65,FINSEQOP:10;
         q2 = p'*(f3'^<*x'*>^f4') by A31,A38,FINSEQ_4:66
        .= (p'*(f3'^<*x'*>))^(p'*f4') by FINSEQOP:10
        .= (p'*f3')^(p'*<*x'*>)^(p'*f4') by FINSEQOP:10
        .= p3^<*px*>^p4 by A68,A69,FUNCT_1:9;
     hence G.(B' \/ {x})
       = Sum(p3^<*px*>) + Sum p4 by A32,RLVECT_1:58
      .= Sum p3 + Sum<*px*> + Sum p4 by RLVECT_1:58
      .= Sum p3 + Sum p4 + Sum<*px*> by RLVECT_1:def 6
      .= Sum q1 + Sum<*px*> by A72,RLVECT_1:58
      .= Sum q1 + px by RLVECT_1:61
      .= (the add of K).[Sum q1,px] by RLVECT_1:def 3
      .= (the add of K).(Sum q1,px)
      .= (the add of K).(G.B',[#](p,the_unity_wrt the add of K).x)
                       by A29,A36,SETWOP_2:22;
    end;
    hence s = (the add of K)$$(dom p,[#](p,the_unity_wrt the add of K))
                    by A1,A2,A10,A11,A12,A17,SETWISEO:def 3
           .= (the add of K) $$ p by A2,SETWOP_2:def 2;
   end;
   assume
A73:  s = (the add of K) $$ p;
    deffunc F(Nat) = (the add of K) $$ (p|$1);
    consider f being Function of NAT, the carrier of K such that
A74:   for i holds f.i = F(i) from FUNCT_2:sch 4;
       p|len p = p|Seg len p by FINSEQ_1:def 15 .= p|dom p by FINSEQ_1:def 3
     .= p by RELAT_1:98;
then A75:  s = f.(len p) by A73,A74;
  set q = <*> (the carrier of K);
   A76:the add of K is commutative & the add of K is associative &
    the add of K has_a_unity by Th10;
       p|0 = p|Seg 0 by FINSEQ_1:def 15 .= q by FINSEQ_1:4,RELAT_1:110;
then A77:  f.0 = (the add of K) $$ q by A74
          .=the_unity_wrt the add of K by A76,FINSOP_1:11
          .= 0.K by Th9;
       now let j; let a be Element of K;
     assume that
A78:  j < len p and
A79:  a = p.(j + 1);
A80:   j+1 <= len p by A78,NAT_1:38;
then A81:    len(p|(j+1)) = j + 1 by FINSEQ_1:80;
A82:    1 <= j+1 by NAT_1:29;
then A83:    j+1 in dom(p|(j+1)) by A81,FINSEQ_3:27;
         j+1 in dom p by A80,A82,FINSEQ_3:27;
then A84:    a = p/.(j+1) by A79,FINSEQ_4:def 4 .= (p|(j+1))/.(j+1)
        by A83,FINSEQ_4:85
              .= (p|(j+1)).(j + 1) by A83,FINSEQ_4:def 4;
         j <= j+1 by NAT_1:29;
then A85:    Seg j c= Seg(j+1) by FINSEQ_1:7;
         p|j = p|Seg j by FINSEQ_1:def 15
        .= (p|Seg(j+1))|Seg j by A85,RELAT_1:103
        .= (p|(j+1))|Seg j by FINSEQ_1:def 15;
      then p|(j+1) = (p|j)^<*a*> by A81,A84,FINSEQ_3:61;
     hence f.(j + 1) = (the add of K) $$ ((p|j)^<*a*>) by A74
            .= (the add of K).((the add of K) $$ (p|j),a) by A76,FINSOP_1:5
            .= (the add of K).(f.j,a) by A74
            .= f.j + a by RLVECT_1:5;
    end;
   hence s = Sum(p) by A75,A77,RLVECT_1:def 12;
  end;
end;

 reserve K for add-associative right_zeroed
       right_complementable (non empty LoopStr),
         a for Element of K,
         p for FinSequence of the carrier of K;

canceled 2;

theorem
      Sum(p^<*a*>) = Sum p + a
 proof
  thus Sum(p^<*a*>) = Sum p + Sum <*a*> by RLVECT_1:58
                 .= Sum p + a by RLVECT_1:61;
 end;

canceled;

theorem
      Sum(<*a*>^p) = a + Sum p
 proof thus Sum(<*a*>^p) = Sum <*a*> + Sum p by RLVECT_1:58
 .= a + Sum p by RLVECT_1:61; end;

canceled 2;

theorem
    for K being Abelian add-associative right_zeroed
        right_complementable distributive(non empty doubleLoopStr),
     a being Element of K,
     p being FinSequence of the carrier of K holds
   Sum(a*p) = a*(Sum p)
 proof
 let K be Abelian add-associative right_zeroed distributive
                 right_complementable (non empty doubleLoopStr),
     a be Element of K,
     p be FinSequence of the carrier of K;
 set rM = (the mult of K)[;](a,id the carrier of K);
   A1:the add of K is commutative & the add of K is associative &
    the add of K has_a_unity by Th10;
   A2:the mult of K is_distributive_wrt the add of K by Th12;
   A3: the add of K has_an_inverseOp by Th17;
  thus Sum (a*p)
     = (the add of K) $$(a*p)
    .= (the add of K) $$(rM*p)
    .= rM.((the add of K) $$ p) by A1,A2,A3,SETWOP_2:41
   .= rM.(Sum p)
    .= a*(Sum p) by Lm1;
 end;

theorem
    for K being non empty LoopStr
   for R being Element of 0-tuples_on the carrier of K holds Sum R = 0.K
    proof let K be non empty LoopStr,
     R be Element of 0-tuples_on (the carrier of K);
        R=<*>(the carrier of K) by FINSEQ_2:113;
     hence Sum R=0.K by RLVECT_1:60;
    end;

 reserve K for Abelian add-associative right_zeroed
         right_complementable (non empty LoopStr),
         p for FinSequence of the carrier of K,
         R1,R2 for Element of i-tuples_on the carrier of K;

theorem
      Sum -p = -(Sum p)
 proof
  A1: the add of K has_a_unity by Th10;
  A2:the add of K has_an_inverseOp &
   the_inverseOp_wrt the add of K = (comp K) by Th17,Th18;
   thus Sum -p = (the add of K) $$(-p)
            .= (the add of K) $$((comp K)*p)
            .= (comp K).((the add of K) $$ p)
            by A1,A2,SETWOP_2:42
            .= (comp K).(Sum p)
            .= -(Sum p) by VECTSP_1:def 25;
 end;

theorem
    Sum(R1 + R2) = Sum R1 + Sum R2
 proof
  A1: the add of K has_a_unity by Th10;
  thus Sum(R1 + R2)
     = (the add of K) $$(R1 + R2)
    .= (the add of K) $$((the add of K).:(R1,R2))
    .= (the add of K).((the add of K)$$R1,(the add of K)$$R2) by A1,
SETWOP_2:46
    .= (the add of K).(Sum R1,(the add of K)$$R2)
    .= (the add of K).(Sum R1,Sum R2)
    .= Sum R1 + Sum R2 by RLVECT_1:5;
 end;

theorem
      Sum(R1 - R2) = Sum R1 - Sum R2
 proof
  A1: the add of K has_a_unity by Th10;
  A2:the add of K has_an_inverseOp &
   the_inverseOp_wrt the add of K = (comp K) by Th17,Th18;
  thus Sum(R1 - R2)
     = (the add of K) $$(R1 - R2)
    .= (the add of K) $$((diffield(K)).:(R1,R2))
    .= (diffield(K)).((the add of K)$$R1,(the add of K)$$R2)
         by A1,A2,SETWOP_2:48
    .= (diffield(K)).(Sum R1,(the add of K)$$R2)
    .= (diffield(K)).(Sum R1,Sum R2)
    .= Sum R1 - Sum R2 by Th14;
 end;

begin
::
::The Product of Finite Number of Elements
::

definition canceled;
end;

canceled;

theorem Th98:
  for K being commutative left_unital (non empty multLoopStr) holds
   Product(<*> (the carrier of K)) = 1.K by GROUP_4:11;

theorem Th99:
 for K being non empty HGrStr,
     a being Element of K holds
   Product <*a*> = a by FINSOP_1:12;

theorem Th100:
 for K being commutative left_unital (non empty doubleLoopStr),
     a being Element of K,
     p being FinSequence of the carrier of K holds
   Product(p^<*a*>) = Product p * a by GROUP_4:9;

 reserve K for commutative associative left_unital (non empty doubleLoopStr),
         a,a1,a2,a3 for Element of K,
         p1,p2 for FinSequence of the carrier of K,
         R1,R2 for Element of i-tuples_on the carrier of K;

theorem Th101:
  Product(p1^p2) = Product p1 * Product p2 by GROUP_4:8;

theorem
  Product(<*a*>^p1) = a * Product p1
 proof thus Product(<*a*>^p1) = Product <*a*> * Product p1 by Th101
   .= a * Product p1 by Th99; end;

theorem Th103:
  Product<*a1,a2*> = a1 * a2 by GROUP_4:13;

theorem
  Product<*a1,a2,a3*> = a1 * a2 * a3
proof
  thus Product<*a1,a2,a3*> = Product(<*a1,a2*>^<*a3*>) by FINSEQ_1:60
                     .= Product<*a1,a2*> * a3 by Th100
                     .= a1 * a2 * a3 by Th103;
 end;

theorem
  for R being Element of 0-tuples_on the carrier of K holds Product R =1.K
  proof
    let R be Element of 0-tuples_on (the carrier of K);
    R =<*>(the carrier of K) by FINSEQ_2:113;
    hence thesis by Th98;
  end;

theorem
  Product(i|->(1.K)) = 1.K
 proof
A1:the_unity_wrt the mult of K = 1.K &
   the mult of K has_a_unity by Th7,Th11;
  thus Product(i|->(1.K)) = (the mult of K)$$(i|->(1.K))
               .= 1.K by A1,SETWOP_2:35;
 end;

theorem
    for K being add-associative right_zeroed right_complementable
    Abelian commutative associative left_unital distributive
      Field-like non degenerated (non empty doubleLoopStr)
   for p being FinSequence of the carrier of K
 holds
   (ex k st k in dom p & p.k = 0.K) iff Product p = 0.K
 proof
 let K be add-associative right_zeroed right_complementable
    Abelian commutative associative left_unital distributive
      Field-like non degenerated (non empty doubleLoopStr);
  let p be FinSequence of the carrier of K;
   defpred P[Nat] means
     for p be FinSequence of the carrier of K st len p = $1 holds
      (ex k st k in Seg $1 & p.k = 0.K) iff Product p = 0.K;
   A1: P[0]
   proof
    let p be FinSequence of the carrier of K such that A2:len p = 0;
    thus (ex k st k in Seg 0 & p.k=0.K) implies Product p=0.K by FINSEQ_1:4;
    assume A3:Product p=0.K;
        p=<*>(the carrier of K) by A2,FINSEQ_1:32;
     then Product p = 1.K by Th98;
     hence thesis by A3,VECTSP_1:def 21;
   end;
A4: for i st P[i] holds P[i+1]
     proof let i such that
A5:     for p be FinSequence of the carrier of K st len p = i holds
         (ex k st k in Seg i & p.k =0.K) iff Product p = 0.K;
      let p be FinSequence of the carrier of K; assume
A6:     len p = i+1;
      then consider p' be FinSequence of the carrier of K,
        a be Element of K such that
A7:     p = p'^<*a*> by FINSEQ_2:22;
A8:      i+ 1= len p'+ 1 by A6,A7,FINSEQ_2:19;
      then A9:i=len p' by XCMPLX_1:2;
A10:    Product p = Product p' * a by A7,Th100;
      thus (ex k st k in Seg (i+1) & p.k = 0.K) implies Product p = 0.K
       proof given k such that
A11:      k in Seg (i+1) and
A12:      p.k = 0.K;
           now per cases by A11,FINSEQ_2:8;
         suppose
A13:          k in Seg i;
          then k in dom p' by A9,FINSEQ_1:def 3;
          then p'.k = p.k by A7,FINSEQ_1:def 7;
          then Product p' = 0.K by A5,A9,A12,A13;
          hence thesis by A10,VECTSP_1:39;
         end;
         suppose k = i+1;
          then a = 0.K by A7,A8,A12,FINSEQ_1:59;
          hence thesis by A10,VECTSP_1:39;
        end;
        end;
        hence thesis;
       end;
      assume
A14:      Product p = 0.K;
      per cases by A10,A14,VECTSP_1:44;
       suppose Product p' = 0.K;
        then consider k such that
A15:       k in Seg i & p'.k = 0.K by A5,A9;
           k in dom p' by A9,A15,FINSEQ_1:def 3;
        then k in Seg (i+1) & p.k = 0.K by A7,A15,FINSEQ_1:def 7,FINSEQ_2:9;
        hence thesis;
       end;
       suppose a = 0.K;
        then i+1 in Seg(i+1) & p.(i+1) = 0.K by A7,A8,FINSEQ_1:6,59;
        hence thesis;
     end;
     end;
A16: for i holds P[i] from NAT_1:sch 1(A1,A4);
     Seg len p = dom p by FINSEQ_1:def 3;
  hence thesis by A16;
 end;

theorem
      Product((i+j)|->a) = (Product(i|->a))*(Product(j|->a))
 proof
   A1:the mult of K has_a_unity by Th11;
   A2:the mult of K is commutative & the mult of K is associative by
GROUP_1:31;
   thus Product((i+j)|->a)
      = (the mult of K)$$((i+j)|->a)
     .= (the mult of K).((the mult of K)$$(i|->a),(the mult of K)$$(j|->a))
       by A1,A2,SETWOP_2:37
     .= ((the mult of K)$$(i|->a))*((the mult of K)$$(j|->a)) by GROUP_1:def 1
     .= ((the mult of K)$$(i|->a))*(Product(j|->a))
     .= (Product(i|->a))*(Product(j|->a));
 end;

theorem
      Product((i*j)|->a) = Product(j|->(Product(i|->a)))
 proof
   A1:the mult of K has_a_unity by Th11;
   A2:the mult of K is commutative & the mult of K is associative by
GROUP_1:31;
   thus Product((i*j)|->a)
      = (the mult of K)$$((i*j)|->a)
     .= (the mult of K)$$(j|->(the mult of K)$$(i|->a))
     by A1,A2,SETWOP_2:38
     .= (the mult of K)$$(j|->(Product(i|->a)))
     .= Product(j|->(Product(i|->a)));
 end;

theorem
      Product(i|->(a1*a2)) = (Product(i|->a1))*(Product(i|->a2))
 proof
   A1:the mult of K has_a_unity by Th11;
   A2:the mult of K is commutative & the mult of K is associative by
GROUP_1:31;
   thus Product(i|->(a1*a2))
      = (the mult of K)$$(i|->(a1*a2))
     .= (the mult of K)$$(i|->(the mult of K).(a1,a2)) by GROUP_1:def 1
     .= (the mult of K).((the mult of K)$$(i|->a1),(the mult of K)$$(i|->a2))
        by A1,A2,SETWOP_2:47
     .= ((the mult of K)$$(i|->a1))*((the mult of K)$$(i|->a2)) by
GROUP_1:def 1
     .= ((the mult of K)$$(i|->a1))*(Product(i|->a2))
     .= (Product(i|->a1))*(Product(i|->a2));
 end;

theorem Th111:
   Product mlt(R1,R2) = Product R1 * Product R2
 proof
   A1:the mult of K has_a_unity by Th11;
   A2:the mult of K is commutative & the mult of K is associative by
GROUP_1:31;
  thus Product(mlt(R1,R2))
     = (the mult of K) $$ mlt (R1,R2)
    .= (the mult of K) $$((the mult of K).:(R1,R2))
    .= (the mult of K).((the mult of K)$$R1,(the mult of K)$$R2)
    by A1,A2,SETWOP_2:46
    .= (the mult of K).(Product R1,(the mult of K)$$R2)
    .= (the mult of K).(Product R1,Product R2)
    .= Product R1 * Product R2 by GROUP_1:def 1;
 end;

theorem
      Product(a*R1) = Product (i|->a) * Product R1
 proof
   thus Product(a*R1) = Product mlt(i|->a,R1) by Th80
     .= Product (i|->a) * Product R1 by Th111;
 end;

begin
::
::The Product of Vectors
::

definition let K be non empty doubleLoopStr;
  let p,q be FinSequence of the carrier of K;
 func p "*" q -> Element of K equals
 Sum(mlt(p,q));
 coherence;
end;

theorem
    for K being commutative associative left_unital Abelian add-associative
       right_zeroed right_complementable (non empty doubleLoopStr)
 for a,b being Element of K holds
  <*a*> "*" <*b*>= a * b
proof
  let K be commutative associative left_unital Abelian add-associative
      right_zeroed right_complementable (non empty doubleLoopStr);
   let a,b be Element of K;
   set p=<*a*>, q=<*b*>;
   set m=mlt(p,q);
      m=<*a*b*> by Th76;
   then m=1|-> (a*b) by FINSEQ_2:73;
   then (the add of K)$$m=a*b by FINSOP_1:17;
   hence thesis;
  end;

theorem
    for K being commutative associative left_unital Abelian add-associative
       right_zeroed right_complementable (non empty doubleLoopStr)
 for a1,a2,b1,b2 being Element of K holds
  <*a1,a2*> "*" <*b1,b2*>= a1*b1 + a2*b2
 proof
   let K be commutative associative left_unital Abelian add-associative
      right_zeroed right_complementable (non empty doubleLoopStr);
   let a1,a2,b1,b2 be Element of K;
   set p=<*a1,a2*>;
   set q=<*b1,b2*>;
      (the add of K)$$(mlt(p,q))=(the add of K)$$<*a1*b1,a2*b2*> by Lm6
                              .=(the add of K).(a1*b1,a2*b2) by FINSOP_1:13
                        .=a1*b1 + a2*b2 by RLVECT_1:5;
  hence thesis;
  end;

theorem
    for p,q be FinSequence of the carrier of K holds
     p "*" q = q "*" p by Th78;
