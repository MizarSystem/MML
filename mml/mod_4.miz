:: Opposite Rings, Modules and their Morphisms
::  by Micha{\l} Muzalewski
::
:: Received June 22, 1992
:: Copyright (c) 1992 Association of Mizar Users

environ

 vocabularies FUNCT_1, RELAT_1, VECTSP_1, OPPCAT_1, RLVECT_1, ARYTM_1,
      FUNCSDOM, VECTSP_2, LATTICES, BINOP_1, INCSP_1, MOD_1, ORDINAL4, GROUP_6,
      MOD_4, GROUP_1, NAT_1, GRCAT_1, ENDALG, COHSP_1;
 notations XBOOLE_0, ZFMISC_1, SUBSET_1, RELAT_1, FUNCT_1, FUNCT_2, DOMAIN_1,
      STRUCT_0, MOD_1, BINOP_1, RLVECT_1, GROUP_1, VECTSP_1, FUNCSDOM,
      VECTSP_2, GRCAT_1, FUNCT_4, GROUP_6, RINGCAT1;
 constructors PARTFUN1, DOMAIN_1, FUNCOP_1, VECTSP_2, GRCAT_1, RINGCAT1, NAT_D,
      GROUP_6;
 registrations VECTSP_1, VECTSP_2, STRUCT_0, RELSET_1, SUBSET_1, XBOOLE_0;
 requirements SUBSET, BOOLE;
 definitions RLVECT_1, STRUCT_0, GROUP_1, BINOP_1, GROUP_6, GRCAT_1, RINGCAT1,
     VECTSP_1;
 theorems FUNCT_1, FUNCT_2, RINGCAT1, VECTSP_1, VECTSP_2, FUNCT_4, RLVECT_1,
      RELAT_1, GROUP_1, FUNCOP_1, GRCAT_1, GROUP_6;

begin :: Funkcje przeciwne

reserve A,B,C for non empty set,
        f for Function of [:A,B:],C;

definition let A,B,C,f;
 redefine func ~f -> Function of [:B,A:],C;
  coherence by FUNCT_4:51;
end;

theorem
Th1: for x being Element of A, y being Element of B holds
         f.(x,y) = ~f.(y,x)
 proof
   let x be Element of A, y be Element of B;
      dom f = [:A,B:] by FUNCT_2:def 1;
   then [x,y] in dom f;
then A1: [y,x] in dom ~f by FUNCT_4:43;
   thus f.(x,y) = ~f.(y,x) by A1,FUNCT_4:44;
 end;

begin :: Pierscienie przeciwne

reserve K for non empty doubleLoopStr;

definition let K;
 func opp(K) -> strict doubleLoopStr equals
   doubleLoopStr (# the carrier of K,
                               the add of K,
                               ~(the mult of K),
                               1.K,
                               0.K #);
 correctness;
end;

registration let K;
 cluster opp(K) -> non empty;
 coherence
  proof
   thus the carrier of opp K is non empty;
  end;
end;

Lm1: for K being non empty doubleLoopStr
for x,y being Scalar of K, a,b being Scalar of opp(K)
       st x = a & y = b holds x+y = a+b & x*y = b*a by Th1;

Lm2: for K being unital (non empty doubleLoopStr)
 for h, e being Element of opp(K) st e = 1_K holds
h * e = h & e * h = h
proof
  let K be unital (non empty doubleLoopStr);
  let h, e be Element of opp(K);
  assume
A1: e = 1_K;
  reconsider a = h, b = e as Element of K;
  thus h * e = b * a by Lm1
  .= h by A1,GROUP_1:def 5;
  thus e * h = a * b by Lm1
  .= h by A1,GROUP_1:def 5;
end;

registration
  let K be unital (non empty doubleLoopStr);
  cluster opp(K) -> unital;
coherence
proof
 reconsider e = 1_K as Element of opp(K);
 take e;
 thus thesis by Lm2;
end;
end;

Lm3: for K being unital (non empty doubleLoopStr) holds 1_K = 1_opp(K)
proof
  let K be unital (non empty doubleLoopStr);
 set G = opp(K);
 reconsider e = 1_K as Element of G;
 for h being Element of G holds h * e = h & e * h = h by Lm2;
 hence 1_K = 1_opp(K) by GROUP_1:def 5;
end;

Lm4: now
let K be add-associative right_zeroed right_complementable
  (non empty doubleLoopStr);
   set L = opp(K);
   thus for x,y,z being Scalar of L holds
    (x+y)+z = x+(y+z)
    & x+(0.L) = x
    proof
     let x,y,z be Scalar of L;
     reconsider a = x, b = y, c = z as Scalar of K;
     thus (x+y)+z = (a+b)+c
                 .= a+(b+c) by RLVECT_1:def 6
                 .= x+(y+z);
     thus x+(0.L) = a + 0.K
                 .= x by RLVECT_1:def 7;
   end;
  end;

registration let K be add-associative right_complementable right_zeroed
  (non empty doubleLoopStr);
  cluster opp K -> add-associative right_zeroed right_complementable;
  coherence
  proof
    thus for x,y,z be Element of opp K holds
      x + (y + z) = x + y + z by Lm4;
    thus for x be Element of opp K holds
      x + 0.opp K = x by Lm4;
    let a be Element of opp K;
    reconsider x = a as Element of K;
    reconsider y = -x as Element of opp K;
    take y;
    thus a+y = x+-x
       .= 0.K by RLVECT_1:16
       .= 0.opp K;
  end;
end;

Lm5:
for K being add-associative right_zeroed
                 right_complementable (non empty doubleLoopStr)
for x,y being Scalar of K, a,b being Scalar of opp(K)
       st x = a & y = b holds x+y = a+b & x*y = b*a & -x = -a
proof
 let K be add-associative right_zeroed right_complementable
   (non empty doubleLoopStr);
 let x,y be Scalar of K,a,b be Scalar of opp(K) such that
 A1: x = a & y = b;
 thus x+y = a+b by A1;
 thus x*y = b*a by A1,Th1;
  reconsider c = -a as Element of K;
   c+x = -a+a by A1
     .= 0.opp K by RLVECT_1:16
     .= 0.K;
 hence -x = -a by RLVECT_1:19;
end;

theorem
the LoopStr of opp(K) = the LoopStr of K &
(K is add-associative right_zeroed right_complementable implies
    comp opp K = comp K)
    & for x being set holds x is Scalar of opp(K) iff x is Scalar of K
proof
 thus the LoopStr of opp(K) = the LoopStr of K;
hereby assume A1:K is add-associative right_zeroed right_complementable;
A2: dom comp opp K = the carrier of K by FUNCT_2:def 1;
A3: dom comp K = the carrier of K by FUNCT_2:def 1;
    for x be set st x in the carrier of K holds (comp opp K).x = (comp K).x
 proof
   let x be set;
   assume x in the carrier of K;
   then reconsider y = x as Element of K;
   reconsider z = y as Element of opp K;
A4: -y = -z by A1,Lm5;
   thus (comp opp K).x = -z by VECTSP_1:def 25
     .= (comp K).x by A4,VECTSP_1:def 25;
 end;
 hence comp opp K = comp K by A2,A3,FUNCT_1:9;
 end;
 let x be set;
 thus thesis;
end;

Lm6: opp(opp(K)) = the doubleLoopStr of K by FUNCT_4:54;

Lm7:
for K being add-associative right_zeroed
                 right_complementable (non empty doubleLoopStr)
for x,y,z,u being Scalar of K, a,b,c,d being Scalar of opp(K)
       st x = a & y = b & z = c & u = d holds
         (x+y)+z = (a+b)+c & x+(y+z) = a+(b+c)
       & (x*y)*z = c*(b*a) & x*(y*z) = (c*b)*a
       & x*(y+z) = (b+c)*a & (y+z)*x = a*(b+c)
       & x*y+z*u = b*a+d*c
proof
let K be add-associative right_zeroed right_complementable
  (non empty doubleLoopStr);
 let x,y,z,u be Scalar of K, a,b,c,d be Scalar of opp(K); assume
 A1: x = a & y = b & z = c & u = d;
   then x+y = a+b & y+z = b+c
 & x*y = b*a & y*z = c*b
 & x*z = c*a & y*x = a*b
 & z*u = d*c by Lm5;
 hence thesis by A1,Lm5;
end;

canceled;

theorem
   (for K being unital (non empty doubleLoopStr) holds
    1_K = 1_opp(K)) &
   for K being add-associative right_zeroed
      right_complementable (non empty doubleLoopStr) holds
  0.K = 0.opp(K)
     & for x,y,z,u being (Scalar of K), a,b,c,d being Scalar of opp(K)
        st x = a & y = b & z = c & u = d holds
          x+y = a+b
        & x*y = b*a
        & -x = -a
        & (x+y)+z = (a+b)+c & x+(y+z) = a+(b+c)
        & (x*y)*z = c*(b*a) & x*(y*z) = (c*b)*a
        & x*(y+z) = (b+c)*a & (y+z)*x = a*(b+c)
        & x*y+z*u = b*a+d*c by Lm5,Lm7,Lm3;

theorem
Th5: for K being Ring holds opp(K) is strict Ring
  proof
   let K be Ring;
   set L = opp(K);
      for x,y,z being Scalar of L holds
      x+y = y+x
    & (x+y)+z = x+(y+z)
    & x+(0.L) = x
    & x+(-x) = (0.L)
    & x*(1_L) = x & (1_L)*x = x
    & (x*y)*z = x*(y*z)
    & x*(y+z) = x*y+x*z & (y+z)*x = y*x+z*x
    proof
     let x,y,z be Scalar of L;
     reconsider a = x, b = y, c = z as Scalar of K;
     A1: a+b = b+a
      & (a+b)+c = a+(b+c)
      & a+(0.K) = a
      & a+(-a) = (0.K)
      & a*(1_K) = a & (1_K)*a = a
      & a*(b+c) = a*b+a*c & (b+c)*a = b*a+c*a by VECTSP_2:1;
     A2: x+y = a+b & y+x = b+a & y+z = b+c
      & 0.K = 0.L
      & -x = -a
      & 1_K = 1_L
      & x*y = b*a
      & x*z = c*a & y*x = a*b & z*x = a*c by Lm5,Lm3;
     hence x+y = y+x;
     thus (x+y)+z = (a+b)+c
                 .= a+(b+c) by VECTSP_2:1
                 .= x+(y+z);
     thus x+(0.L) = x by A1;
     thus x+(-x) = (0.L) by A1,A2;
     thus x*(1_L) = x by A1,A2,Lm5;
     thus (1_L)*x = x by A1,A2,Lm5;
     thus (x*y)*z = c*(b*a) by Lm7
                 .= c*b*a by VECTSP_2:1
                 .= x*(y*z) by Lm7;
     thus x*(y+z) = (b+c)*a by Lm7
                 .= b*a+c*a by VECTSP_2:1
                 .= x*y+x*z by Lm7;
     thus (y+z)*x = a*(b+c) by Lm7
                 .= a*b+a*c by VECTSP_2:1
                 .= y*x+z*x by Lm7;
    end;
    hence thesis by VECTSP_2:1;
  end;

registration let K be Ring;
 cluster opp(K) -> Abelian add-associative right_zeroed right_complementable
        unital distributive;
 coherence by Th5;
end;

theorem
Th6: for K being Ring holds opp(K) is Ring
  proof
   let K be Ring;
      for x,y,z being Scalar of opp(K) holds x*(y*z) = (x*y)*z
    proof
     let x,y,z be Scalar of opp(K);
     reconsider a = x,b = y,c = z as Scalar of K;
     A1: (c*b)*a = c*(b*a) by GROUP_1:def 4;
        (c*b)*a = x*(y*z) by Lm7;
     hence thesis by A1,Lm7;
    end;
    hence thesis by GROUP_1:def 4;
  end;

registration let K be Ring;
 cluster opp(K) -> associative;
 coherence by Th6;
end;

theorem
Th7: for K being Skew-Field holds opp(K) is Skew-Field
  proof
   let K be Skew-Field;
   set L = opp(K);
      for x being Scalar of L holds
    (x <> 0.L implies ex y be Scalar of L st x*y = 1_L)
    & 0.L <> 1_L
    proof
     let x be Scalar of L;
     A1: 1_K = 1_L & 0.K = 0.L by Lm3;
         x <> 0.L implies ex y be Scalar of L st x*y = 1_L
      proof
       assume
       A2: x <> 0.L;
       reconsider a = x as Scalar of K;
       consider b being Scalar of K such that
       A3: b*a = 1_K by A1,A2,VECTSP_2:40;
       reconsider y = b as Scalar of opp(K);
       take y;
       thus thesis by A3,A1,Lm5;
      end;
     hence thesis by A1,VECTSP_1:def 21;
    end;
   hence thesis by VECTSP_1:def 20,def 21;
  end;

registration let K be Skew-Field;
 cluster opp(K) -> non degenerated Field-like associative Abelian
   add-associative right_zeroed right_complementable unital distributive;
 coherence by Th7;
end;

Lm8: for F being commutative (non empty doubleLoopStr),
     x,y being Element of F holds x*y = y*x;

theorem
    for K being Field holds opp(K) is strict Field
  proof
   let K be Field;
   set L = opp(K);
      for x,y being Scalar of L holds x*y = y*x
    proof
     let x,y be Scalar of L;
     reconsider a = x, b = y as Scalar of K;
        b*a = x*y by Lm5;
     hence thesis by Lm5;
    end;
   hence thesis by GROUP_1:def 16;
  end;

registration let K be Field;
 cluster opp(K) -> strict Field-like;
 coherence;
end;

begin :: Moduly przeciwne

reserve V for non empty VectSpStr over K;

definition let K,V;
 func opp(V) -> strict RightModStr over opp(K) means :Def2:
  for o being Function of [:the carrier of V,
   the carrier of opp(K):], the carrier of V
    st o = ~(the lmult of V)
   holds it = RightModStr
    (# the carrier of V, the add of V, 0.V, o #);
 existence
  proof
    reconsider o = ~(the lmult of V) as
    Function of [:the carrier of V,
    the carrier of opp(K):], the carrier of V;
    take RightModStr
      (#the carrier of V, the add of V, 0.V, o#);
    thus thesis;
  end;
 uniqueness
  proof
    let M1,M2 be strict RightModStr over opp(K) such that
A1:  for o being Function of [:the carrier of V,
    the carrier of opp(K):], the carrier of V
    st o = ~(the lmult of V) holds M1 = RightModStr
      (# the carrier of V, the add of V, 0.V, o #) and
A2:  for o being Function of [:the carrier of V,
    the carrier of opp(K):], the carrier of V
    st o = ~(the lmult of V) holds M2 = RightModStr
     (# the carrier of V, the add of V, 0.V, o #);
    reconsider o = ~(the lmult of V) as
    Function of [:the carrier of V,
    the carrier of opp(K):], the carrier of V;
   thus M1 = RightModStr
    (# the carrier of V, the add of V, 0.V, o #) by A1
    .= M2 by A2;
  end;
end;

registration let K,V;
 cluster opp(V) -> non empty;
  coherence
 proof
  reconsider o = ~(the lmult of V) as
    Function of [:the carrier of V,the carrier of opp(K):], the carrier of V;
     opp V = RightModStr
    (# the carrier of V, the add of V, 0.V, o #)
 by Def2;
  hence the carrier of opp V is non empty;
 end;
end;

theorem
Th9: the LoopStr of opp(V) = the LoopStr of V
 & for x being set holds x is Vector of V iff x is Vector of opp(V)
  proof
    reconsider p = ~(the lmult of V) as
     Function of [:the carrier of V,
     the carrier of opp(K):], the carrier of V;
    A1: opp(V) = RightModStr
     (# the carrier of V, the add of V, 0.V, p #)
 by Def2;
   hence
    the LoopStr of opp(V) = the LoopStr of V;
    let x be set;
   thus thesis by A1;
  end;

definition let K,V; let o be Function of [:the carrier of K,
 the carrier of V:], the carrier of V;
  func opp(o) -> Function of [:the carrier of opp(V),
    the carrier of opp(K):], the carrier of opp(V) equals
  ~o;
 coherence
  proof
A1:  the LoopStr of opp(V) = the LoopStr of V by Th9;
   thus ~o is Function of [:the carrier of opp(V),
    the carrier of opp(K):], the carrier of opp(V) by A1;
  end;
end;

theorem
Th10: the rmult of opp(V) = opp(the lmult of V)
  proof
    reconsider p = ~(the lmult of V) as
     Function of [:the carrier of V,
     the carrier of opp(K):], the carrier of V;
       opp(V) = RightModStr
     (# the carrier of V, the add of V, 0.V, p #) by Def2;
   hence the rmult of opp(V) = opp(the lmult of V);
  end;

reserve W for non empty RightModStr over K;

definition let K,W;
 func opp(W) -> strict VectSpStr over opp(K) means
:Def4:
  for o being Function of [:the carrier of opp(K),
   the carrier of W:], the carrier of W
    st o = ~(the rmult of W)
   holds it = VectSpStr
    (# the carrier of W, the add of W, 0.W, o #);
 existence
  proof
    reconsider o = ~(the rmult of W) as Function of [:the carrier of opp(K
),
    the carrier of W:], the carrier of W;
    take VectSpStr
     (#the carrier of W, the add of W, 0.W, o#);
    thus thesis;
  end;
 uniqueness
  proof
    let M1,M2 be strict VectSpStr over opp(K) such that
A1:  for o being Function of [:the carrier of opp(K),
   the carrier of W:], the carrier of W
    st o = ~(the rmult of W) holds M1 = VectSpStr
      (# the carrier of W, the add of W, 0.W, o #) and
A2:  for o being Function of [:the carrier of opp(K),
   the carrier of W:], the carrier of W
    st o = ~(the rmult of W) holds M2 = VectSpStr
     (# the carrier of W, the add of W, 0.W, o #);
    reconsider o = ~(the rmult of W) as
    Function of [:the carrier of opp(K),
   the carrier of W:], the carrier of W;
   thus M1 = VectSpStr
    (# the carrier of W, the add of W, 0.W, o #) by A1
    .= M2 by A2;
  end;
end;

registration let K,W;
 cluster opp(W) -> non empty;
 coherence
 proof
  reconsider o = ~(the rmult of W) as Function of [:the carrier of opp(K),
                                      the carrier of W:], the carrier of W;
     opp W = VectSpStr
     (#the carrier of W, the add of W, 0.W, o#)
 by Def4;
  hence the carrier of opp W is non empty;
 end;
end;

canceled;

theorem
Th12: the LoopStr of opp(W) = the LoopStr of W
 & for x being set holds x is Vector of W iff x is Vector of opp(W)
  proof
    reconsider p = ~(the rmult of W) as
     Function of [:the carrier of opp(K),
   the carrier of W:], the carrier of W;
    A1: opp(W) = VectSpStr
     (# the carrier of W, the add of W, 0.W, p #)
 by Def4;
   hence
    the LoopStr of opp(W) = the LoopStr of W;
    let x be set;
   thus thesis by A1;
  end;

definition let K,W; let o be Function of [:the carrier of W,
 the carrier of K:], the carrier of W;
  func opp(o) -> Function of [:the carrier of opp(K),
   the carrier of opp(W):],
   the carrier of opp(W) equals
  ~o;
 coherence
  proof
A1:  the LoopStr of opp(W) = the LoopStr of W by Th12;
    reconsider o' = ~o as Function of [:the carrier of opp(K),
    the carrier of opp(W):],
    the carrier of opp(W) by A1;
       o' is Function of [:the carrier of opp(K),
   the carrier of opp(W):],
   the carrier of opp(W);
   hence thesis;
  end;
end;

theorem
Th13: the lmult of opp(W) = opp(the rmult of W)
  proof
    reconsider p = ~(the rmult of W) as
     Function of [:the carrier of opp(K),
    the carrier of W:], the carrier of W;
       opp(W) = VectSpStr
     (# the carrier of W, the add of W, 0.W, p #)
 by Def4;
   hence the lmult of opp(W) = opp(the rmult of W);
  end;

Lm9: for o being Function of [:the carrier of K,
  the carrier of V:], the carrier of V
 holds opp(opp(o)) = o by FUNCT_4:54;

canceled 2;

theorem
Th16: for o being Function of [:the carrier of K,
  the carrier of V:], the carrier of V,
  x being Scalar of K, y being Scalar of opp(K),
  v being Vector of V, w being Vector of opp(V) st x=y & v=w
 holds (opp(o)).(w,y) = o.(x,v) by Th1;

theorem
Th17: for K,L being Ring, V being non empty VectSpStr over K
  for W being non empty RightModStr over L
   for x being Scalar of K, y being Scalar of L,
    v being Vector of V, w being Vector of W
  st L=opp(K) & W=opp(V) & x=y & v=w
 holds w*y = x*v
proof let K,L be Ring, V be non empty VectSpStr over K;
  let W be non empty RightModStr over L;
  let x be Scalar of K, y be Scalar of L,
     v be Vector of V, w be Vector of W such that
A1: L=opp(K) & W=opp(V) & x=y & v=w;
   set o = the lmult of V;
      opp(o) = the rmult of opp(V) by Th10;
  hence w*y = (opp(o)).(w,y) by A1,VECTSP_2:def 15
           .= o.(x,v) by A1,Th16
           .= x*v by VECTSP_1:def 24;
end;

theorem
Th18: for K,L being Ring, V being non empty VectSpStr over K
  for W being non empty RightModStr over L for v1,v2 being Vector of V,
  w1,w2 being Vector of W
  st L=opp(K) & W=opp(V) & v1=w1 & v2=w2
 holds w1+w2=v1+v2
proof
 let K,L be Ring, V be non empty VectSpStr over K;
 let W be non empty RightModStr over L, v1,v2 be Vector of V,
  w1,w2 be Vector of W such that
A1: L=opp(K) & W=opp(V) & v1=w1 & v2=w2;
    the LoopStr of opp(V) = the LoopStr of V by Th9;
 hence w1+w2 = v1+v2 by A1;
end;

Lm10: for o being Function of [:the carrier of W,
  the carrier of K:], the carrier of W
 holds opp(opp(o)) = o by FUNCT_4:54;

canceled;

theorem
Th20: for o being Function of [:the carrier of W,
 the carrier of K:], the carrier of W,
  x being Scalar of K, y being Scalar of opp(K),
  v being Vector of W, w being Vector of opp(W) st x=y & v=w
 holds (opp(o)).(y,w) = o.(v,x) by Th1;

theorem
Th21: for K,L being Ring, V being non empty VectSpStr over K
  for W being non empty RightModStr over L
   for x being Scalar of K, y being Scalar of L,
  v being Vector of V, w being Vector of W
  st K=opp(L) & V=opp(W) & x=y & v=w
 holds w*y = x*v
proof let K,L be Ring, V be non empty VectSpStr over K;
  let W be non empty RightModStr over L;
  let x be Scalar of K, y be Scalar of L,
  v be Vector of V, w be Vector of W such that
A1: K=opp(L) & V=opp(W) & x=y & v=w;
   set o = the rmult of W;
A2: opp(o) = the lmult of opp(W) by Th13;
  thus w*y = o.(w,y) by VECTSP_2:def 15
           .= (opp(o)).(x,v) by A1,Th20
           .= x*v by A1,A2,VECTSP_1:def 24;
end;

theorem
Th22: for K,L being Ring, V being non empty VectSpStr over K
  for W being non empty RightModStr over L for v1,v2 being Vector of V,
  w1,w2 being Vector of W
  st K=opp(L) & V=opp(W) & v1=w1 & v2=w2
 holds w1+w2=v1+v2
proof
  let K,L be Ring, V be non empty VectSpStr over K;
  let W be non empty RightModStr over L; let v1,v2 be Vector of V,
  w1,w2 be Vector of W such that
A1: K=opp(L) & V=opp(W) & v1=w1 & v2=w2;
     the LoopStr of opp(W) = the LoopStr of W by Th12;
 hence w1+w2 = v1+v2 by A1;
end;

theorem
   for K being strict non empty doubleLoopStr, V being non empty VectSpStr over
K
 holds opp(opp(V)) = the VectSpStr of V
 proof let K be strict non empty doubleLoopStr,
           V be non empty VectSpStr over K;
   set W = opp(V);
A1: the LoopStr of opp(W) = the LoopStr of W by Th12
                         .= the LoopStr of V by Th9;
A2: opp(the rmult of W) = opp(opp(the lmult of V)) by Th10
                      .= the lmult of V by Lm9;
    opp(opp(K)) = K by Lm6;
  hence thesis by A1,A2,Th13;
 end;

theorem
   for K being strict non empty doubleLoopStr,
    W being non empty RightModStr over K
 holds opp(opp(W)) = the RightModStr of W
 proof let K be strict non empty doubleLoopStr,
           W be non empty RightModStr over K;
   set V = opp(W);
A1: the LoopStr of opp(V) = the LoopStr of V by Th9
                         .= the LoopStr of W by Th12;
A2: opp(the lmult of V) = opp(opp(the rmult of W)) by Th13
                      .= the rmult of W by Lm10;
    opp(opp(K)) = K by Lm6;
  hence thesis by A1,A2,Th10;
 end;

theorem
Th25: for K being Ring, V being LeftMod of K holds
       opp V is strict RightMod of opp K
 proof let K be Ring, V be LeftMod of K;
   set R=opp(K);
   reconsider W=opp(V) as non empty RightModStr over R;
A1: the LoopStr of opp V = the LoopStr of V by Th9;
     A2: for a,b be Element of opp V
      for x,y be Element of V
       st x = a & b = y
      holds a + b = x + y by A1;
A3: 0.opp V = 0.V by A1;
A4:  opp V is Abelian add-associative right_zeroed right_complementable
      proof
       thus opp V is Abelian
        proof let a,b be Element of opp V;
          reconsider x = a, y = b as Element of V by Th9;
         thus a + b = y + x by A2
                   .= b + a by A2;
        end;
       hereby let a,b,c be Element of opp V;
        reconsider x = a, y = b, z = c as Element of V by Th9;
        A5: a + b = x + y & b + c = y + z by A2;
       hence a + b + c = x + y + z by A2
                     .= x + (y + z) by RLVECT_1:def 6
                     .= a + (b + c) by A2,A5;
       end;
       hereby let a be Element of opp V;
        reconsider x = a as Element of V by Th9;
       thus a + 0.opp V = x + 0.V by A2,A3
                    .= a by RLVECT_1:10;
       end;
       let a be Element of opp V;
        reconsider x = a as Element of V by Th9;
        consider b being Element of V such that
A6:      x + b = 0.V by RLVECT_1:def 8;
        reconsider b' = b as Element of opp V by Th9;
       take b';
       thus a + b' = 0.opp V by A2,A3,A6;
      end;
      now let x,y be Scalar of R, v,w be Vector of W;
     reconsider a=x,b=y as Scalar of K;
     reconsider p=v,q=w as Vector of V by Th9;
A7:   v+w=p+q by Th18;
A8:   y*x=a*b & 1_R=1_K & x+y=a+b by Lm5,Lm3;
A9:   b*p=v*y & a*p=v*x & b*p=v*y & a*q=w*x by Th17;
    thus (v+w)*x = a*(p+q) by A7,Th17
                .= a*p+a*q by VECTSP_1:def 26
                .= v*x+w*x by A9,Th18;
    thus v*(x+y) = (a+b)*p by Th17
                .= a*p+b*p by VECTSP_1:def 26
                .= v*x+v*y by A9,Th18;
    thus v*(y*x) = (a*b)*p by A8,Th17
                .= a*(b*p) by VECTSP_1:def 26
                .= (v*y)*x by A9,Th17;
    thus v*(1_R) = (1_K)*p by A8,Th17
                .= v by VECTSP_1:def 26;end;
  hence thesis by A4,VECTSP_2:def 23;
 end;

registration let K be Ring, V be LeftMod of K;
 cluster opp(V) -> Abelian add-associative right_zeroed right_complementable
   RightMod-like;
 coherence by Th25;
end;

theorem
Th26: for K being Ring, W being RightMod of K holds
       opp W is strict LeftMod of opp K
 proof let K be Ring, W be RightMod of K;
   set R=opp(K);
   reconsider V=opp(W) as non empty VectSpStr over R;
A1: the LoopStr of opp W = the LoopStr of W by Th12;
     A2: for a,b be Element of opp W
      for x,y be Element of W
       st x = a & b = y
      holds a + b = x + y by A1;
A3: 0.opp W = 0.W by A1;
A4:  opp W is Abelian add-associative right_zeroed right_complementable
      proof
       thus opp W is Abelian
        proof let a,b be Element of opp W;
          reconsider x = a, y = b as Element of W by Th12;
         thus a + b = y + x by A2
                   .= b + a by A2;
        end;
       hereby let a,b,c be Element of opp W;
        reconsider x = a, y = b, z = c as Element of W by Th12;
        A5: a + b = x + y & b + c = y + z by A2;
       hence a + b + c = x + y + z by A2
                     .= x + (y + z) by RLVECT_1:def 6
                     .= a + (b + c) by A2,A5;
       end;
       hereby let a be Element of opp W;
        reconsider x = a as Element of W by Th12;
       thus a + 0.opp W = x + 0.W by A2,A3
                    .= a by RLVECT_1:10;
       end;
       let a be Element of opp W;
        reconsider x = a as Element of W by Th12;
        consider b being Element of W such that
A6:      x + b = 0.W by RLVECT_1:def 8;
        reconsider b' = b as Element of opp W by Th12;
       take b';
       thus a + b' = 0.opp W by A2,A3,A6;
      end;
      now let x,y be Scalar of R, v,w be Vector of V;
     reconsider a=x,b=y as Scalar of K;
     reconsider p=v,q=w as Vector of W by Th12;
A7:   v+w=p+q by Th22;
A8:   x*y=b*a & 1_R=1_K & x+y=a+b by Lm5,Lm3;
A9:   p*b=y*v & p*a=x*v & p*b=y*v & q*a=x*w by Th21;
    thus x*(v+w) = (p+q)*a by A7,Th21
                .= p*a+q*a by VECTSP_2:def 23
                .= x*v+x*w by A9,Th22;
    thus (x+y)*v = p*(a+b) by Th21
                .= p*a+p*b by VECTSP_2:def 23
                .= x*v+y*v by A9,Th22;
    thus (x*y)*v = p*(b*a) by A8,Th21
                .= (p*b)*a by VECTSP_2:def 23
                .= x*(y*v) by A9,Th21;
    thus (1_R)*v = p*(1_K) by A8,Th21
                .= v by VECTSP_2:def 23;end;
  hence thesis by A4,VECTSP_1:def 26;
 end;

registration let K be Ring, W be RightMod of K;
 cluster opp(W) -> Abelian add-associative right_zeroed right_complementable
  VectSp-like;
 coherence by Th26;
end;

begin :: Morfizmy pierscieni

definition let K,L be non empty HGrStr;
           let IT be Function of K,L;
 attr IT is antimultiplicative means :Def6a:
  for x,y being Scalar of K holds IT.(x*y) = IT.y*IT.x;
end;

definition let K,L be non empty doubleLoopStr;
           let IT be Function of K,L;
 attr IT is antilinear means :Def6:
 IT is additive antimultiplicative unity-preserving;
end;

registration let K,L be non empty doubleLoopStr;
 cluster antilinear -> additive antimultiplicative unity-preserving
 Function of K,L;
 coherence by Def6;
 cluster additive antimultiplicative unity-preserving -> antilinear
 Function of K,L;
 coherence by Def6;
end;

definition let K,L be non empty doubleLoopStr;
  let IT be Function of K,L;
 attr IT is monomorphism means :Def7:
    IT is linear & IT is one-to-one;
 attr IT is antimonomorphism means :Def8:
    IT is antilinear & IT is one-to-one;
end;

definition let K,L be non empty doubleLoopStr;
  let IT be Function of K,L;
 attr IT is epimorphism means :Def9:
    IT is linear & rng IT = the carrier of L;
 attr IT is antiepimorphism means :Def10:
    IT is antilinear & rng IT = the carrier of L;
end;

definition let K,L be non empty doubleLoopStr;
  let IT be Function of K,L;
 attr IT is isomorphism means :Def11:
    IT is monomorphism & rng IT = the carrier of L;
 attr IT is antiisomorphism means :Def12:
    IT is antimonomorphism & rng IT = the carrier of L;
end;

reserve J for Function of K,K;

definition let K be non empty doubleLoopStr;
  let IT be Function of K,K;
 attr IT is endomorphism means
 :Def13: IT is linear;
 attr IT is antiendomorphism means
 :Def14: IT is antilinear;
 attr IT is automorphism means
 :Def15: IT is isomorphism;
 attr IT is antiautomorphism means
 :Def16: IT is antiisomorphism;
end;

theorem
   J is automorphism
iff (for x,y being Scalar of K holds J.(x+y) = J.x+J.y)
    & (for x,y being Scalar of K holds J.(x*y) = J.x*J.y)
    & J.(1_K) = 1_K
    & J is one-to-one
    & rng J = the carrier of K
   proof
    A1: now
     assume J is automorphism;
     then A2: J is isomorphism by Def15;
     then A3: J is monomorphism by Def11;
     then J is linear by Def7;
     then J is additive multiplicative unity-preserving by RINGCAT1:def 2;
     hence for x,y being Scalar of K holds J.(x+y) = J.x+J.y
         & for x,y being Scalar of K holds J.(x*y) = J.x*J.y
         & J.(1_K) = 1_K by GRCAT_1:def 13,GROUP_6:def 7,GROUP_1:def 17;
     thus J is one-to-one by A3,Def7;
     thus rng J = the carrier of K by A2,Def11;
    end;
       now assume that
     A4:   (for x,y being Scalar of K holds J.(x+y) = J.x+J.y)
         & (for x,y being Scalar of K holds J.(x*y) = J.x*J.y)
         & J.(1_K) = 1_K and
     A5: J is one-to-one and
     A6: rng J = the carrier of K;
     J is additive multiplicative unity-preserving
     by A4,GRCAT_1:def 13,GROUP_6:def 7,GROUP_1:def 17;
     then J is linear by RINGCAT1:def 2;
     then J is monomorphism by A5,Def7;
     then J is isomorphism by A6,Def11;
     hence J is automorphism by Def15;
    end;
    hence thesis by A1;
   end;

theorem
Th28:  J is antiautomorphism iff
       (for x,y being Scalar of K holds J.(x+y) = J.x+J.y)
     & (for x,y being Scalar of K holds J.(x*y) = J.y*J.x)
     & J.(1_K) = 1_K
     & J is one-to-one
     & rng J = the carrier of K
   proof
    A1: now
     assume J is antiautomorphism;
     then A2: J is antiisomorphism by Def16;
     then A3: J is antimonomorphism by Def12;
     then J is antilinear by Def8;
     then J is additive antimultiplicative unity-preserving by Def6;
     hence for x,y being Scalar of K holds J.(x+y) = J.x+J.y
           & for x,y being Scalar of K holds J.(x*y) = J.y*J.x
           & J.(1_K) = 1_K by GRCAT_1:def 13,GROUP_1:def 17,Def6a;
     thus J is one-to-one by A3,Def8;
     thus rng J = the carrier of K by A2,Def12;
    end;
       now assume that
     A4:   (for x,y being Scalar of K holds J.(x+y) = J.x+J.y)
         & (for x,y being Scalar of K holds J.(x*y) = J.y*J.x)
         & J.(1_K) = 1_K and
     A5: J is one-to-one and
     A6: rng J = the carrier of K;
     J is additive antimultiplicative unity-preserving
     by A4,GRCAT_1:def 13,GROUP_1:def 17,Def6a;
     then J is antilinear by Def6;
     then J is antimonomorphism by A5,Def8;
     then J is antiisomorphism by A6,Def12;
     hence J is antiautomorphism by Def16;end;
    hence thesis by A1;
 end;

Lm11:
  (for x,y being Scalar of K holds (id K).(x+y) = (id K).x+(id K).y)
& (for x,y being Scalar of K holds (id K).(x*y) = (id K).x*(id K).y)
& (id K).(1_K) = 1_K
& id K is one-to-one
& rng (id K) = the carrier of K
 proof
  set J = id K;
  thus for x,y being Scalar of K holds J.(x+y) = J.x+J.y
   proof
    let x,y be Scalar of K;
        J.(x+y) = x+y & J.x = x & J.y = y by FUNCT_1:35;
    hence J.(x+y) = J.x+J.y;
   end;
  thus for x,y being Scalar of K holds J.(x*y) = J.x*J.y
   proof
    let x,y be Scalar of K;
        J.(x*y) = x*y & J.x = x & J.y = y by FUNCT_1:35;
    hence J.(x*y) = J.x*J.y;
   end;
  thus (id K).(1_K) = 1_K by FUNCT_1:35;
  thus J is one-to-one by FUNCT_1:52;
  thus rng J = the carrier of K by RELAT_1:71;
 end;

theorem
   id K is automorphism
 proof
  set J = id K;
  A1: J is monomorphism
    proof
     A2: J is linear
      proof
        (for x,y being Scalar of K holds J.(x+y) = J.x+J.y)
       & (for x,y being Scalar of K holds J.(x*y) = J.x*J.y)
       & J.(1_K) = 1_K by Lm11;
       then J is additive multiplicative unity-preserving
       by GRCAT_1:def 13,GROUP_6:def 7,GROUP_1:def 17;
       hence thesis by RINGCAT1:def 2;
      end;
        J is one-to-one by Lm11;
     hence thesis by A2,Def7;
    end;
      rng J = the carrier of K by Lm11;
  then J is isomorphism by A1,Def11;
  hence thesis by Def15;
 end;

reserve K,L for Ring;
reserve J for Function of K,L;
reserve x,y for Scalar of K;

Lm12: J is linear implies J.(0.K) = 0.L
proof
 assume J is linear;
 then
A1: J is additive by RINGCAT1:def 2;
 set a = 0.K;
    a+a = a by RLVECT_1:10;
 then J.a+J.a = J.a by A1,GRCAT_1:def 13
        .= J.a+(0.L) by RLVECT_1:10;
 hence thesis by RLVECT_1:21;
end;

Lm13: J is linear implies J.(-x) = -J.x
proof
 assume
 A1: J is linear;
 then
A2: J is additive by RINGCAT1:def 2;
 set a = 0.K, b = 0.L, y = J.x;
A3: x+-x = a & y+-y = b by RLVECT_1:16;
 then y+J.(-x) = J.a by A2,GRCAT_1:def 13
         .= b by A1,Lm12;
 hence thesis by A3,RLVECT_1:21;
end;

Lm14: J is linear implies J.(x-y) = J.x-J.y
proof
 assume
 A1: J is linear;
 then J is additive by RINGCAT1:def 2;
 hence J.(x-y) = J.x+J.(-y) by GRCAT_1:def 13
             .= J.x-J.y by A1,Lm13;
end;

theorem
   J is linear implies
  J.(0.K) = 0.L
& J.(-x) = -J.x
& J.(x-y) = J.x-J.y by Lm12,Lm13,Lm14;

Lm15: J is antilinear implies J.(0.K) = 0.L
proof
 assume J is antilinear;
 then
A1: J is additive by Def6;
 set a = 0.K;
    a+a = a by RLVECT_1:10;
 then J.a+J.a = J.a by A1,GRCAT_1:def 13
        .= J.a+(0.L) by RLVECT_1:10;
 hence thesis by RLVECT_1:21;
end;

Lm16: J is antilinear implies J.(-x) = -J.x
proof
 assume A1: J is antilinear;
 then
A3: J is additive by Def6;
 set a = 0.K, b = 0.L, y = J.x;
 A2: x+-x = a & y+-y = b by RLVECT_1:16;
 then y+J.(-x) = J.a by A3,GRCAT_1:def 13
         .= b by A1,Lm15;
 hence thesis by A2,RLVECT_1:21;
end;

Lm17: J is antilinear implies J.(x-y) = J.x-J.y
proof
 assume
 A1: J is antilinear;
 then J is additive by Def6;
 hence J.(x-y) = J.x+J.(-y) by GRCAT_1:def 13
             .= J.x-J.y by A1,Lm16;
end;

theorem
   J is antilinear implies
  J.(0.K) = 0.L
& J.(-x) = -J.x
& J.(x-y) = J.x-J.y by Lm15,Lm16,Lm17;

theorem
   for K being Ring holds id K is antiautomorphism iff K is comRing
proof
 let K be Ring;
 set J = id K;
 A1: now assume
  A2: J is antiautomorphism;
     for x,y being Element of K holds x*y = y*x
    proof
     let x,y be Element of K;
        J.(x*y) = x*y & J.x = x & J.y = y by FUNCT_1:35;
     hence thesis by A2,Th28;
    end;
  hence K is comRing by GROUP_1:def 16;
 end;
    now assume
  A3: K is comRing;
  A4: for x,y being Scalar of K holds J.(x*y) = J.y*J.x
   proof
    let x,y be Scalar of K;
        J.(x*y) = x*y & J.x = x & J.y = y by FUNCT_1:35;
    hence thesis by A3,Lm8;
   end;
       (for x,y being Scalar of K holds J.(x+y) = J.x+J.y)
  & J.(1_K) = 1_K
  & J is one-to-one
  & rng J = the carrier of K by Lm11;
  hence J is antiautomorphism by A4,Th28;
 end;
 hence thesis by A1;
end;

theorem
   for K being Skew-Field holds id K is antiautomorphism iff K is Field
proof
 let K be Skew-Field;
 set J = id K;
 A1: now assume
 A2: J is antiautomorphism;
     for x,y being Scalar of K holds x*y = y*x
    proof
     let x,y be Scalar of K;
        J.(x*y) = x*y & J.x = x & J.y = y by FUNCT_1:35;
     hence thesis by A2,Th28;
    end;
  hence K is Field by GROUP_1:def 16;
 end;
    now assume
  A3: K is Field;
  A4: for x,y being Scalar of K holds J.(x*y) = J.y*J.x
   proof
    let x,y be Scalar of K;
         J.(x*y) = x*y & J.x = x & J.y = y by FUNCT_1:35;
    hence thesis by A3,GROUP_1:def 16;
   end;
       (for x,y being Scalar of K holds J.(x+y) = J.x+J.y)
  & J.(1_K) = 1_K
  & J is one-to-one
  & rng J = the carrier of K by Lm11;
  hence J is antiautomorphism by A4,Th28;
 end;
 hence thesis by A1;
end;

begin :: Morfizmy przeciwne do morfizmow pierscieni

definition let K,L be non empty doubleLoopStr,
               J be Function of K,L;
 func opp(J) -> Function of K,opp(L) equals
   J;
 coherence;
end;

reserve K,L for add-associative right_zeroed right_complementable
  (non empty doubleLoopStr);
reserve J for Function of K,L;

theorem
   opp(opp(J)) = J;

reserve K for add-associative right_zeroed right_complementable
  (non empty doubleLoopStr);
reserve L for add-associative right_zeroed right_complementable
  unital (non empty doubleLoopStr);
reserve J for Function of K,L;

theorem Th35:
 J is linear iff opp(J) is antilinear
 proof
  set J' = opp(J), L' = opp(L);
  A1: now assume J is linear;
   then
A0: J is additive multiplicative unity-preserving by RINGCAT1:def 2;
   A3: for x,y being Scalar of K holds J'.(x+y) = J'.x+J'.y
    proof
     let x,y be Scalar of K;
     thus J'.(x+y) = J.x+J.y by A0,GRCAT_1:def 13
                  .= J'.x+J'.y;
    end;
   A4: for x,y being Scalar of K holds J'.(x*y) = J'.y*J'.x
    proof
     let x,y be Scalar of K;
     thus J'.(x*y) = J.x*J.y by A0,GROUP_6:def 7
                  .= J'.y*J'.x by Lm5;
    end;
    J'.(1_K) = 1_L by A0,GROUP_1:def 17
                  .= 1_L' by Lm3;
   then J' is additive antimultiplicative unity-preserving
   by A3,A4,GRCAT_1:def 13,GROUP_1:def 17,Def6a;
   hence J' is antilinear by Def6;
  end;
     now assume
   J' is antilinear;
   then
A0: J' is additive antimultiplicative unity-preserving by Def6;
   A6: for x,y being Scalar of K holds J.(x+y) = J.x+J.y
    proof
     let x,y be Scalar of K;
     thus J.(x+y) = J'.x+J'.y by A0,GRCAT_1:def 13
                  .= J.x+J.y;
    end;
   A7: for x,y being Scalar of K holds J.(x*y) = J.x*J.y
    proof
     let x,y be Scalar of K;
     thus J.(x*y) = J'.y*J'.x by A0,Def6a
                  .= J.x*J.y by Lm5;
    end;
    J.(1_K) = 1_L' by A0,GROUP_1:def 17
    .= 1_L by Lm3;
    then J is additive multiplicative unity-preserving
    by A6,A7,GROUP_1:def 17,GROUP_6:def 7,GRCAT_1:def 13;
   hence J is linear by RINGCAT1:def 2;
  end;
  hence thesis by A1;
 end;

theorem
Th36: J is antilinear iff opp(J) is linear
 proof
  set J' = opp(J), L' = opp(L);
  hereby assume J is antilinear;
    then
A0:J is additive antimultiplicative unity-preserving
    by Def6;
    thus J' is linear
    proof
    thus J' is additive
    proof
     let x,y be Scalar of K;
     thus J'.(x+y) = J.x+J.y by A0,GRCAT_1:def 13
                  .= J'.x+J'.y;
    end;
    thus J' is multiplicative
    proof
     let x,y be Scalar of K;
     thus J'.(x*y) = J.y*J.x by A0,Def6a
                  .= J'.x*J'.y by Lm5;
    end;
    thus J'.(1_K) = 1_L by A0,GROUP_1:def 17
                  .= 1_L' by Lm3;
  end;
  end;
  assume
   A5: J' is  additive multiplicative unity-preserving;
    hereby
     let x,y be Scalar of K;
     thus J.(x+y) = J'.x+J'.y by A5,GRCAT_1:def 13
                  .= J.x+J.y;
    end;
    hereby
     let x,y be Scalar of K;
     thus J.(x*y) = J'.x*J'.y by A5,GROUP_6:def 7
                  .= J.y*J.x by Lm5;
    end;
    thus J.(1_K) = 1_L' by A5,GROUP_1:def 17
                  .= 1_L by Lm3;
 end;

theorem
Th37: J is monomorphism iff opp(J) is antimonomorphism
 proof
  set J' = opp(J);
  A1: J' is antimonomorphism
  iff J' is antilinear & J' is one-to-one by Def8;
         J is linear iff J' is antilinear by Th35;
  hence thesis by A1,Def7;
 end;

theorem
Th38: J is antimonomorphism iff opp(J) is monomorphism
 proof
  set J' = opp(J);
  A1: J' is monomorphism iff J' is linear & J' is one-to-one by Def7;
     J is antilinear iff J' is linear by Th36;
  hence thesis by A1,Def8;
 end;

theorem
   J is epimorphism iff opp(J) is antiepimorphism
 proof
  set J' = opp(J), L' = opp(L);
  A1: rng J = the carrier of L iff rng J' = the carrier of L';
     J is linear iff J' is antilinear by Th35;
  hence thesis by A1,Def9,Def10;
 end;

theorem
   J is antiepimorphism iff opp(J) is epimorphism
 proof
  set J' = opp(J), L' = opp(L);
  A1: rng J = the carrier of L iff rng J' = the carrier of L';
     J is antilinear iff J' is linear by Th36;
  hence thesis by A1,Def9,Def10;
 end;

theorem
Th41: J is isomorphism iff opp(J) is antiisomorphism
 proof
  set J' = opp(J), L' = opp(L);
  A1: rng J = the carrier of L
  iff rng J' = the carrier of L';
     J is monomorphism iff J' is antimonomorphism by Th37;
  hence thesis by A1,Def11,Def12;
 end;

theorem
Th42: J is antiisomorphism iff opp(J) is isomorphism
 proof
  set J' = opp(J), L' = opp(L);
  A1: rng J = the carrier of L
  iff rng J' = the carrier of L';
     J is antimonomorphism iff J' is monomorphism by Th38;
  hence thesis by A1,Def11,Def12;
 end;

reserve K for add-associative right_zeroed right_complementable
  unital (non empty doubleLoopStr);
reserve J for Function of K,K;

theorem
   J is endomorphism iff opp(J) is antilinear
 proof
     J is linear iff opp(J) is antilinear by Th35;
  hence thesis by Def13;
 end;

theorem
   J is antiendomorphism iff opp(J) is linear
 proof
     J is antilinear iff opp(J) is linear by Th36;
  hence thesis by Def14;
 end;

theorem
   J is automorphism iff opp(J) is antiisomorphism
 proof
     J is isomorphism iff opp(J) is antiisomorphism by Th41;
  hence thesis by Def15;
 end;

theorem
   J is antiautomorphism iff opp(J) is isomorphism
 proof
     J is antiisomorphism iff opp(J) is isomorphism by Th42;
  hence thesis by Def16;
 end;

begin :: Morfizmy grup i grup abelowych

reserve G,H for AddGroup;

Lm18: for x,y being Element of G holds
        ZeroMap(G,H).(x+y) = ZeroMap(G,H).x+ZeroMap(G,H).y
 proof
   set f = ZeroMap(G,H);
   thus for x,y being Element of G holds f.(x+y) = f.x+f.y
    proof
      let x,y be Element of G;
          f.(x+y) = 0.H & f.x = 0.H & f.y = 0.H by FUNCOP_1:13;
      hence f.(x+y) = f.x+f.y by RLVECT_1:def 7;
    end;
 end;

definition let G,H;
 mode Homomorphism of G,H -> Function of G,H means
 :Def18: for x,y being Element of G holds it.(x+y) = it.x+it.y;
 existence
  proof
    take ZeroMap(G,H);
    thus thesis by Lm18;
  end;
end;

definition let G,H;
 redefine func ZeroMap(G,H) -> Homomorphism of G,H;
 coherence
  proof
       for x,y being Element of G holds
     ZeroMap(G,H).(x+y) = ZeroMap(G,H).x+ZeroMap(G,H).y by Lm18;
    hence thesis by Def18;
  end;
end;

reserve f for Homomorphism of G,H;

definition let G,H;
  let IT be Homomorphism of G,H;
 attr IT is monomorphism means
   IT is one-to-one;
end;

definition let G,H;
  let IT be Homomorphism of G,H;
 attr IT is epimorphism means
   rng IT = the carrier of H;
end;

definition let G,H;
  let IT be Homomorphism of G,H;
 attr IT is isomorphism means
 :Def21: IT is one-to-one & rng IT = the carrier of H;
end;

definition let G;
 mode Endomorphism of G is Homomorphism of G,G;
end;

Lm19: for x being Element of G holds (id G).x = x by FUNCT_1:35;

Lm20: (for x,y being Element of G
   holds (id G).(x+y) = (id G).x+(id G).y)
         & id G is one-to-one
         & rng id G = the carrier of G
proof
 set f = id G;
 thus for x,y being Element of G holds f.(x+y) = f.x+f.y
  proof
   let x,y be Element of G;
       f.(x+y) = x+y & f.x = x & f.y = y by Lm19;
   hence f.(x+y) = f.x+f.y;
  end;
 thus f is one-to-one by FUNCT_1:52;
 thus rng f = the carrier of G by RELAT_1:71;
end;

registration let G;
 cluster isomorphism Endomorphism of G;
 existence
  proof
    set f = id G;
    for x,y being Element of G holds f.(x+y) = f.x+f.y by Lm20;
    then reconsider f as Homomorphism of G,G by Def18;
    A1: f is one-to-one by Lm20;
    A2: rng f = the carrier of G by Lm20;
    take f;
    thus f is isomorphism by A1,A2,Def21;
  end;
end;

definition let G;
 mode Automorphism of G is isomorphism Endomorphism of G;
end;

definition let G;
 redefine func id G -> Automorphism of G;
 coherence
  proof
    set f = id G;
    for x,y being Element of G holds f.(x+y) = f.x+f.y by Lm20;
    then reconsider f as Homomorphism of G,G by Def18;
    A1: f is one-to-one by Lm20;
        rng f = the carrier of G by Lm20;
    hence thesis by A1,Def21;
  end;
end;

reserve x,y for Element of G;

Lm21: f.(0.G) = 0.H
proof
 set a = 0.G;
    a+a = a by RLVECT_1:def 7;
 then f.a+f.a = f.a by Def18
        .= f.a+(0.H) by RLVECT_1:def 7;
 hence thesis by RLVECT_1:21;
end;

Lm22: f.(-x) = -f.x
proof
 set a = 0.G, b = 0.H, y = f.x;
    x+-x = a & y+-y = b by RLVECT_1:def 10;
 then y+f.(-x) = f.a by Def18
         .= b by Lm21;
 hence thesis by VECTSP_1:63;
end;

Lm23: f.(x-y) = f.x-f.y
proof
 thus f.(x-y) = f.x+f.(-y) by Def18
              .= f.x-f.y by Lm22;
end;

canceled;

theorem
     f.(0.G) = 0.H
& f.(-x) = -f.x
& f.(x-y) = f.x-f.y by Lm21,Lm22,Lm23;

reserve G,H for AbGroup;
reserve f for Homomorphism of G,H;
reserve x,y for Element of G;

theorem
   f.(x-y) = f.x-f.y
proof
 thus f.(x-y) = f.x+f.(-y) by Def18
             .= f.x-f.y by Lm22;
end;

begin :: Odwzorowania semiliniowe

reserve K,L for Ring;
reserve J for Function of K,L;
reserve V for LeftMod of K;
reserve W for LeftMod of L;

Lm24: for x,y being Vector of V holds
        ZeroMap(V,W).(x+y) = ZeroMap(V,W).x+ZeroMap(V,W).y
 proof
   set f = ZeroMap(V,W);
   thus for x,y being Vector of V holds f.(x+y) = f.x+f.y
    proof
      let x,y be Vector of V;
         f.(x+y) = 0.W & f.x = 0.W & f.y = 0.W by FUNCOP_1:13;
      hence f.(x+y) = f.x+f.y by VECTSP_1:7;
    end;
 end;

Lm25: for a being Scalar of K, x being Vector of V holds
          ZeroMap(V,W).(a*x) = J.a*ZeroMap(V,W).x
 proof
   let a be Scalar of K, x be Vector of V;
   set z = ZeroMap(V,W);
      z.(a*x) = 0.W & z.(x) = 0.W by FUNCOP_1:13;
   hence thesis by VECTSP_1:59;
 end;

definition let K,L,J,V,W;
 canceled;

 mode Homomorphism of J,V,W -> Function of V,W means
 :Def23:
    (for x,y being Vector of V holds it.(x+y) = it.x+it.y)
  & for a being Scalar of K, x being Vector of V holds it.(a*x) = J.a*it.x;
 existence
  proof
    take ZeroMap(V,W);
    thus thesis by Lm24,Lm25;
  end;
end;

theorem
   ZeroMap(V,W) is Homomorphism of J,V,W
 proof
   set z = ZeroMap(V,W);
   A1: for x,y being Vector of V holds z.(x+y) = z.x+z.y
 by Lm24;
       for a being Scalar of K, x being Vector of V holds z.(a*x) = J.a*z.x
 by Lm25;
   hence thesis by A1,Def23;
 end;

reserve f for Homomorphism of J,V,W;

definition let K,L,J,V,W,f;
 pred f is_monomorphism_wrp J means
     f is one-to-one;

 pred f is_epimorphism_wrp J means
     rng f = the carrier of W;

 pred f is_isomorphism_wrp J means
       f is one-to-one & rng f = the carrier of W;
end;

reserve J for Function of K,K;
reserve f for Homomorphism of J,V,V;

definition let K,J,V;
 mode Endomorphism of J,V is Homomorphism of J,V,V;
end;

definition let K,J,V,f;
 pred f is_automorphism_wrp J means
       f is one-to-one
  & rng f = the carrier of V;
end;

reserve W for LeftMod of K;

definition let K,V,W;
 mode Homomorphism of V,W is Homomorphism of (id K),V,W;
end;

theorem
   for f being Function of V,W holds
      f is Homomorphism of V,W
  iff
        (for x,y being Vector of V holds f.(x+y) = f.x+f.y)
      & for a being Scalar of K, x being Vector of V holds f.(a*x) = a*f.x
 proof
   let f be Function of V,W;
   set J = id K;
       (for a being Scalar of K, x being Vector of V holds f.(a*x) = J.a*f.x)
    iff for a being Scalar of K, x being Vector of V holds f.(a*x) = a*f.x
     proof
      A1: now assume
A2: for a being Scalar of K, x being Vector of V holds f.(a*x) = J.a*f.x;
       let a be Scalar of K, x be Vector of V;
          J.a = a by FUNCT_1:35;
       hence f.(a*x) = a*f.x by A2;end;
         now assume A3:
       for a being Scalar of K, x being Vector of V holds f.(a*x) = a*f.x;
       let a be Scalar of K, x be Vector of V;
          J.a = a by FUNCT_1:35;
       hence f.(a*x) = J.a*f.x by A3;end;
      hence thesis by A1;
     end;
   hence thesis by Def23;
 end;

definition let K,V,W;
  let IT be Homomorphism of V,W;
 attr IT is monomorphism means
     IT is one-to-one;
 attr IT is epimorphism means
     rng IT = the carrier of W;
 attr IT is isomorphism means
       IT is one-to-one & rng IT = the carrier of W;
end;

definition let K,V;
  mode Endomorphism of V is Homomorphism of V,V;
end;

definition let K,V;
  let IT be Endomorphism of V;
 attr IT is automorphism means
       IT is one-to-one & rng IT = the carrier of V;
end;

