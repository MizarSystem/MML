:: Real Linear-Metric Space and Isometric Functions
::  by Robert Milewski
::
:: Received November 3, 1998
:: Copyright (c) 1998 Association of Mizar Users

environ

 vocabularies METRIC_1, JORDAN1, ARYTM_1, FINSEQ_1, ABSVALUE, RLVECT_1,
      ARYTM_3, BINTREE1, TREES_2, RELAT_1, FUNCT_1, BOOLE, TREES_4, CAT_1,
      TREES_1, POWER, INT_1, BINTREE2, MCART_1, EUCLID, FINSEQ_2, MIDSP_3,
      MARGREL1, ZF_LANG, NAT_1, MATRIX_2, RELAT_2, PRE_TOPC, FUNCT_2, SUBSET_1,
      BINOP_1, UNIALG_1, COMPLEX1, VECTSP_1, GROUP_1, GROUP_2, VECTMETR,
      FINSEQ_4, PARTFUN1, STRUCT_0;
 notations TARSKI, XBOOLE_0, ZFMISC_1, SUBSET_1, NUMBERS, MCART_1, XCMPLX_0,
      COMPLEX1, REAL_1, RELAT_2, INT_1, NAT_1, NAT_D, POWER, ABIAN, SERIES_1,
      RELAT_1, RELSET_1, MARGREL1, BINOP_1, DOMAIN_1, FUNCT_1, PARTFUN1,
      FUNCT_2, STRUCT_0, PRE_TOPC, FINSEQ_1, FINSEQ_2, FINSEQ_4, FINSEQOP,
      BINARITH, TREES_1, TREES_2, TREES_4, BINTREE1, BINTREE2, RVSUM_1,
      RLVECT_1, GROUP_1, GROUP_2, TOPS_2, METRIC_1, EUCLID, XXREAL_0;
 constructors XXREAL_0, REAL_1, NAT_1, NAT_D, COMPLEX1, FINSEQOP, FINSEQ_4,
      FINSOP_1, SERIES_1, REALSET1, BINARITH, ABIAN, TOPS_2, GROUP_2, GRCAT_1,
      EUCLID, BINTREE2;
 registrations XBOOLE_0, SUBSET_1, FUNCT_1, RELSET_1, FUNCT_2, NUMBERS,
      XXREAL_0, XREAL_0, NAT_1, FINSEQ_1, BINOP_2, MEMBERED, SEQ_1, MARGREL1,
      FINSEQ_2, TREES_2, STRUCT_0, GROUP_1, METRIC_1, GROUP_2, BINTREE1,
      BINTREE2;
 requirements REAL, NUMERALS, BOOLE, SUBSET, ARITHM;
 definitions STRUCT_0, TARSKI, XBOOLE_0, MARGREL1, XBOOLEAN, RLVECT_1, RVSUM_1,
      EUCLID, FINSEQ_2;
 theorems STRUCT_0, TARSKI, MCART_1, REAL_1, REAL_2, NAT_1, NAT_2, ZFMISC_1,
      BINOP_1, RELAT_1, FUNCT_1, FUNCT_2, POWER, FINSEQ_1, FINSEQ_2, FINSEQ_4,
      FINSEQ_5, BINARITH, BINARI_2, BINARI_3, ABSVALUE, TOPS_2, FUNCOP_1,
      BINTREE2, PRE_FF, RLVECT_1, METRIC_1, RVSUM_1, EUCLID, GROUP_1, GROUP_2,
      RELAT_2, XCMPLX_1, PARTFUN1, INT_1, ORDERS_1, XREAL_1, FINSEQOP,
      XXREAL_0, FINSOP_1, NAT_D;
 schemes BINOP_1, NAT_1, FINSEQ_2, BINARITH, BINTREE2, RELSET_1, XBOOLE_0;

begin  :: Convex and Internal Metric Spaces

  definition
   let V be non empty MetrStruct;
   attr V is convex means :Def1:
    for x,y be Element of V
    for r be Real st 0 <= r & r <= 1
    ex z be Element of V st
     dist(x,z) = r * dist(x,y) & dist(z,y) = (1 - r) * dist(x,y);
  end;

  definition
   let V be non empty MetrStruct;
   attr V is internal means
         for x,y be Element of V
    for p,q be Real st p > 0 & q > 0
    ex f be FinSequence of the carrier of V st
     f/.1 = x & f/.len f = y &
     (for i be Element of NAT st 1 <= i & i <=
 len f - 1 holds dist(f/.i,f/.(i+1)) < p) &
     for F be FinSequence of REAL st len F = len f - 1 &
      for i be Element of NAT st 1 <= i & i <= len F
      holds F/.i = dist(f/.i,f/.(i+1))
     holds abs(dist(x,y) - Sum F) < q;
  end;

  theorem Th1:
   for V be non empty MetrSpace st V is convex
   for x,y be Element of V
   for p be Real st p > 0
   ex f be FinSequence of the carrier of V st
    f/.1 = x & f/.len f = y &
    (for i be Element of NAT st 1 <= i & i <= len f - 1
    holds dist(f/.i,f/.(i+1)) < p) &
    for F be FinSequence of REAL st len F = len f - 1 &
     for i be Element of NAT st 1 <= i & i <= len F
      holds F/.i = dist(f/.i,f/.(i+1))
    holds dist(x,y) = Sum F
   proof
    let V be non empty MetrSpace;
    assume A1: V is convex;
    let x,y be Element of V;
    let p be Real such that
     A2: p > 0;
    set A = the carrier of V;
    defpred P[set,set,set] means
      for a1,a2 be Element of A st $1 = [a1,a2]
      ex b be Element of A st
       $2 = [a1,b] & $3 = [b,a2] &
       dist(a1,a2) = 2 * dist(a1,b) & dist(a1,a2) = 2 * dist(b,a2);
    A3: for a be Element of [:A,A:]
     ex c,d be Element of [:A,A:] st P[a,c,d]
    proof
     let a be Element of [:A,A:];
     consider a1',a2' be set such that
      A4: a1' in A and
      A5: a2' in A and
      A6: a = [a1',a2'] by ZFMISC_1:def 2;
     reconsider a1', a2' as Element of A by A4,A5;
     consider z be Element of A such that
      A7: dist(a1',z) = 1/2 * dist(a1',a2') and
      A8: dist(z,a2') = (1 - 1/2) * dist(a1',a2') by A1,Def1;
     take c = [a1',z];
     take d = [z,a2'];
     let a1,a2 be Element of A;
     assume A9: a = [a1,a2];
     then A10: a1 = a1' & a2 = a2' by A6,ZFMISC_1:33;
     take z;
     thus c = [a1,z] by A6,A9,ZFMISC_1:33;
     thus d = [z,a2] by A6,A9,ZFMISC_1:33;
     thus dist(a1,a2) = 2 * dist(a1,z) by A7,A10;
     thus dist(a1,a2) = 2 * dist(z,a2) by A8,A10;
    end;
    consider D be binary DecoratedTree of [:A,A:] such that
     A11: dom D = {0,1}* and
     A12: D.{} = [x,y] and
     A13: for z be Node of D holds P[D.z, D.(z ^ <* 0 *>), D.(z ^ <*1*>)]
                                                 from BINTREE2:sch 1(A3);
    reconsider dD = dom D as full Tree by A11,BINTREE2:def 2;
    per cases;
     suppose dist(x,y) >= p;
     then dist(x,y)/p >= 1 by A2,REAL_2:143;
     then log(2,dist(x,y)/p) >= log(2,1) by PRE_FF:12;
     then log(2,dist(x,y)/p) >= 0 by POWER:59;
     then reconsider n1 = [\ log(2,dist(x,y)/p) /] as Element of NAT
      by INT_1:80;
     reconsider n = n1 + 1 as non empty Element of NAT;
     A14: 2 to_power n > 0 by POWER:39;
     reconsider N = 2 to_power n as non empty Element of NAT by POWER:39;
     set r = dist(x,y) / N;
          log(2,dist(x,y)/p) < n * 1 by INT_1:52;
     then log(2,dist(x,y)/p) < n * log(2,2) by POWER:60;
     then log(2,dist(x,y)/p) < log(2,2 to_power n) by POWER:63;
     then dist(x,y)/p < N by PRE_FF:12;
     then dist(x,y)/p*p < N*p by A2,XREAL_1:70;
     then dist(x,y) < N*p by A2,XCMPLX_1:88;
     then dist(x,y)/N < N*p/N by REAL_1:73;
     then dist(x,y)/N < p/N*N by XCMPLX_1:75;
     then A15: r < p by XCMPLX_1:88;
     reconsider FSL = FinSeqLevel(n,dD) as FinSequence of dom D;
     deffunc G(Element of NAT) = D.(FSL/.$1);
     consider g be FinSequence of [:A,A:] such that
      A16: len g = N and
      A17: for k be Element of NAT st k in Seg N holds g.k = G(k)
       from FINSEQ_2:sch 1;
     deffunc F(Element of NAT) = (g/.$1)`1;
     consider h be FinSequence of the carrier of V such that
      A18: len h = N and
      A19: for k be Element of NAT st k in Seg N holds h.k = F(k)
       from FINSEQ_2:sch 1;
     take f = h^<*y*>;
     defpred P[Element of NAT] means (D.(0*$1))`1 = x;
         (D.(0*0))`1 = [x,y]`1 by A12,FINSEQ_2:72;
     then A20: P[0] by MCART_1:7;
     A21: for j be Element of NAT st P[j] holds P[j+1]
     proof
      let j be Element of NAT;
      reconsider zj = 0*j as Node of D by A11,BINARI_3:5;
      consider a,b be set such that
       A22: a in A and
       A23: b in A and
       A24: D.zj = [a,b] by ZFMISC_1:def 2;
      reconsider a1 = a, b1 = b as Element of A by A22,A23;
      consider z1 be Element of A such that
       A25: D.(zj^<* 0 *>) = [a1,z1] and
            D.(zj^<* 1 *>) = [z1,b1] and
            dist(a1,b1) = 2 * dist(a1,z1) and
            dist(a1,b1) = 2 * dist(z1,b1) by A13,A24;
      assume A26: (D.(0*j))`1 = x;
      thus (D.(0*(j+1)))`1 = (D.(zj^<* 0 *>))`1 by FINSEQ_2:74
         .= a1 by A25,MCART_1:7
         .= x by A24,A26,MCART_1:7;
     end;
     A27: for j be Element of NAT holds P[j] from NAT_1:sch 1(A20,A21);
     defpred Q[Element of NAT] means
      for t be Tuple of $1,BOOLEAN st t = 0*$1 holds (D.'not' t)`2 = y;
     A28: Q[1]
     proof
      let t be Tuple of 1,BOOLEAN;
      reconsider pusty = <*>({0,1}) as Node of D by A11,FINSEQ_1:def 11;
      consider b be Element of A such that
            D.(pusty^<* 0 *>) = [x,b] and
       A29: D.(pusty^<* 1 *>) = [b,y] and
            dist(x,y) = 2 * dist(x,b) and
            dist(x,y) = 2 * dist(b,y) by A12,A13;
      assume t = 0*1;
      then t = <*FALSE*> by FINSEQ_2:73;
      hence (D.'not' t)`2 = (D.(pusty^<* 1 *>))`2
                                       by BINARI_3:15,FINSEQ_1:47
         .= y by A29,MCART_1:7;
     end;
     A30: for j be non empty Element of NAT st Q[j] holds Q[j+1]
     proof
      let j be non empty Element of NAT;
      assume A31: for t be Tuple of j,BOOLEAN st t = 0*j holds (D.'not'
t)`2 = y;
      let t be Tuple of j+1,BOOLEAN;
      assume A32: t = 0*(j+1);
      consider t1 be Tuple of j,BOOLEAN,
               dd be Element of BOOLEAN
       such that A33: t = t1^<*dd*> by FINSEQ_2:137;
      A34: j + 1 in Seg (j + 1) by FINSEQ_1:6;
           dd = t.(len t1 + 1) by A33,FINSEQ_1:59
        .= ((j + 1) |-> (0 qua Real)).(j + 1) by A32,FINSEQ_2:109
        .= FALSE by A34,FUNCOP_1:13;
      then 'not' dd = 1;
      then A35: 'not' t = 'not' t1^<* 1 *> by A33,BINARI_2:11;
      reconsider nt1 = 'not'
t1 as Node of D by A11,FINSEQ_1:def 11;
      consider a,b be set such that
       A36: a in A and
       A37: b in A and
       A38: D.nt1 = [a,b] by ZFMISC_1:def 2;
      reconsider a1 = a, b1 = b as Element of A by A36,A37;
      consider b be Element of A such that
            D.(nt1^<* 0 *>) = [a1,b] and
       A39: D.(nt1^<* 1 *>) = [b,b1] and
            dist(a1,b1) = 2 * dist(a1,b) and
            dist(a1,b1) = 2 * dist(b,b1) by A13,A38;
           t = 0*j ^ <* 0 *> by A32,FINSEQ_2:74;
      then t1 = 0*j by A33,FINSEQ_2:20;
      then A40: (D.'not' t1)`2 = y by A31;
      thus (D.'not' t)`2 = b1 by A35,A39,MCART_1:7
         .= y by A38,A40,MCART_1:7;
     end;
     A41: for j be non empty Element of NAT holds Q[j]
      from BINARITH:sch 1(A28,A30);
     A42: len f = len h + len <*y*> by FINSEQ_1:35
              .= len h + 1 by FINSEQ_1:56;
     A43: 1 <= N by NAT_1:14;
     then A44: 1 in Seg N by FINSEQ_1:3;
     then A45: 1 in dom h by A18,FINSEQ_1:def 3;
          0 + 1 <= 2 to_power n by A14,NAT_1:13;
     then A46: 1 <= len FinSeqLevel(n,dD) by BINTREE2:19;
          1 <= N + 1 by NAT_1:11;
     hence f/.1 = f.1 by A18,A42,FINSEQ_4:24
        .= h.1 by A45,FINSEQ_1:def 7
        .= (g/.1)`1 by A19,A44
        .= (g.1)`1 by A16,A43,FINSEQ_4:24
        .= (D.(FSL/.1))`1 by A17,A44
        .= (D.(FinSeqLevel(n,dD).1))`1 by A46,FINSEQ_4:24
        .= (D.(0*n))`1 by BINTREE2:15
        .= x by A27;
          len f in Seg (len f) by A42,FINSEQ_1:6;
     then len f in dom f by FINSEQ_1:def 3;
     hence A47: f/.len f = (h^<*y*>).(len h + 1) by A42,FINSEQ_4:def 4
                     .= y by FINSEQ_1:59;
     A48: for i be Element of NAT st 1 <= i & i <= len f - 1 holds
      dist(f/.i,f/.(i+1)) = r
     proof
      let i be Element of NAT;
      assume that
       A49: 1 <= i and
       A50: i <= len f - 1;
      A51: len FSL = N by BINTREE2:19;
      A52: i in Seg len h by A42,A49,A50,FINSEQ_1:3;
      then i in dom h by FINSEQ_1:def 3;
      then A53: f/.i = h/.i by FINSEQ_4:83
         .= h.i by A42,A49,A50,FINSEQ_4:24
         .= (g/.i)`1 by A18,A19,A52
         .= (g.i)`1 by A16,A18,A42,A49,A50,FINSEQ_4:24
         .= (D.(FSL/.i))`1 by A17,A18,A52
         .= (D.(FinSeqLevel(n,dD).i))`1 by A18,A42,A49,A50,A51,FINSEQ_4:24;
      A54: len f >= 1 by A42,NAT_1:11;
           0*n in BOOLEAN* by BINARI_3:5;
      then A55: 0*n is FinSequence of BOOLEAN by FINSEQ_1:def 11;
           len (0*n) = n by FINSEQ_2:109;
      then reconsider ze = 0*n as Tuple of n,BOOLEAN by A55,FINSEQ_2:110;
      A56: now per cases by A50,REAL_1:def 5;
       suppose i < len f - 1;
        then i < len f-'1 by A54,BINARITH:50;
        then i + 1 <= len f-'1 by NAT_1:13;
        then A57: i + 1 <= len f - 1 by A54,BINARITH:50;
        then A58: i + 1 - 1 <= (2 to_power n) - 1 by A18,A42,XREAL_1:11;
        defpred R[non empty Element of NAT] means
         for i be Element of NAT st 1 <= i & i <= (2 to_power $1) - 1 holds
          (D.(FinSeqLevel($1,dD).(i+1)))`1 = (D.(FinSeqLevel($1,dD).i))`2;
        A59: R[1]
        proof
         let i be Element of NAT;
         assume that
          A60: 1 <= i and
          A61: i <= (2 to_power 1) - 1;
              (2 to_power 1) - 1
            = 1 + 1 - 1 by POWER:30
            .= 1;
         then A62: i = 1 by A60,A61,XXREAL_0:1;
         reconsider pusty = <*>({0,1}) as Node of D by A11,FINSEQ_1:def 11;
         consider b be Element of A such that
          A63: D.(pusty^<* 0 *>) = [x,b] and
          A64: D.(pusty^<* 1 *>) = [b,y] and
               dist(x,y) = 2 * dist(x,b) and
               dist(x,y) = 2 * dist(b,y) by A12,A13;
         thus (D.(FinSeqLevel(1,dD).(i+1)))`1 = (D.<* 1 *>)`1
                                                            by A62,BINTREE2:23
            .= (D.(pusty^<* 1 *>))`1 by FINSEQ_1:47
            .= b by A64,MCART_1:7
            .= (D.(pusty^<* 0 *>))`2 by A63,MCART_1:7
            .= (D.<* 0 *>)`2 by FINSEQ_1:47
            .= (D.(FinSeqLevel(1,dD).i))`2 by A62,BINTREE2:22;
        end;
        A65: for n be non empty Element of NAT st R[n] holds R[n+1]
        proof
         let n be non empty Element of NAT;
         assume A66: for i be Element of NAT
          st 1 <= i & i <= (2 to_power n) - 1 holds
          (D.(FinSeqLevel(n,dD).(i+1)))`1 = (D.(FinSeqLevel(n,dD).i))`2;
         let i be Element of NAT;
         assume that
          A67: 1 <= i and
          A68: i <= (2 to_power (n+1)) - 1;
              2 to_power (n+1) > 0 by POWER:39;
         then A69: 2 to_power (n+1) >= 0 + 1 by NAT_1:13;
         then i <= (2 to_power (n+1)) -' 1 by A68,BINARITH:50;
         then i < (2 to_power (n+1)) -' 1 + 1 by NAT_1:13;
         then A70: i < (2 to_power (n+1)) - 1 + 1 by A69,BINARITH:50;
         then A71: i + 1 <= 2 to_power (n+1) by NAT_1:13;
              i <= (2 to_power n) * (2 to_power 1) by A70,POWER:32;
         then i <= (2 to_power n) * 2 by POWER:30;
         then A72: (i+1) div 2 <= 2 to_power n by NAT_2:27;
         A73: 1 + 1 <= i + 1 by A67,XREAL_1:8;
         then A74: (i+1) div 2 >= 1 by NAT_2:15;
         then (i+1) div 2 in Seg (2 to_power n) by A72,FINSEQ_1:3;
         then A75: (i+1) div 2 in dom FinSeqLevel(n,dD) by BINTREE2:20;
         reconsider zb = dD-level n as non empty set by A11,BINTREE2:10;
              FinSeqLevel(n,dD).((i+1) div 2) in zb by A75,FINSEQ_2:13;
         then reconsider F = FinSeqLevel(n,dD).((i+1) div 2)
                                         as Tuple of n,BOOLEAN by BINTREE2:5;
         reconsider F1 = F as Node of D by A11,FINSEQ_1:def 11;
              i + 1 <= (2 to_power n) * (2 to_power 1) by A71,POWER:32;
         then i + 1 <= (2 to_power n) * 2 by POWER:30;
         then A76: (i+1+1) div 2 <= 2 to_power n by NAT_2:27;
              i + 1 <= i + 1 + 1 by NAT_1:11;
         then 2 <= i + 1 + 1 by A73,XXREAL_0:2;
         then (i+1+1) div 2 >= 1 by NAT_2:15;
         then (i+1+1) div 2 in Seg (2 to_power n) by A76,FINSEQ_1:3;
         then (i+1+1) div 2 in dom FinSeqLevel(n,dD) by BINTREE2:20;
         then FinSeqLevel(n,dD).((i+1+1) div 2) in zb by FINSEQ_2:13;
         then reconsider FF = FinSeqLevel(n,dD).((i+1+1) div 2)
                                         as Tuple of n,BOOLEAN by BINTREE2:5;
         reconsider FF1 = FF as Node of D by A11,FINSEQ_1:def 11;
         consider a,b be set such that
          A77: a in A and
          A78: b in A and
          A79: D.F1 = [a,b] by ZFMISC_1:def 2;
         consider a',b' be set such that
          A80: a' in A and
          A81: b' in A and
          A82: D.FF1 = [a',b'] by ZFMISC_1:def 2;
         reconsider a1 = a, b1 = b, a1' = a', b1' = b' as Element of A
                                                        by A77,A78,A80,A81;
         consider d be Element of A such that
          A83: D.(F1^<* 0 *>) = [a1,d] and
          A84: D.(F1^<* 1 *>) = [d,b1] and
               dist(a1,b1) = 2 * dist(a1,d) and
               dist(a1,b1) = 2 * dist(d,b1) by A13,A79;
         consider d' be Element of A such that
          A85: D.(FF1^<* 0 *>) = [a1',d'] and
          A86: D.(FF1^<* 1 *>) = [d',b1'] and
               dist(a1',b1') = 2 * dist(a1',d') and
               dist(a1',b1') = 2 * dist(d',b1') by A13,A82;
         A87: i + 1 >= 1 by NAT_1:11;
         A88: i = i + 1 - 1
              .= i + 1 -' 1 by A87,BINARITH:50;
              now per cases;
          suppose i is odd;
           then A89: i mod 2 = 1 by NAT_2:24;
           then (i + 1) mod 2 = 0 by A88,NAT_2:20;
           then i + 1 is even by NAT_2:23;
           then (i+1) div 2 = (i+1+1) div 2 by NAT_2:28;
           then A90: d = d' by A83,A85,ZFMISC_1:33;
           thus (D.(FinSeqLevel(n+1,dD).(i+1)))`1 = (D.(FF^<*(2*1+i) mod 2*>))
`1 by A71,BINTREE2:24
              .= (D.(FF^<* 1 *>))`1 by A89,NAT_D:21
              .= d by A86,A90,MCART_1:7
              .= (D.(F^<* 0 *>))`2 by A83,MCART_1:7
              .= (D.(F^<*(i+1) mod 2*>))`2 by A88,A89,NAT_2:20
              .= (D.(FinSeqLevel(n+1,dD).i))`2 by A67,A70,BINTREE2:24;
          end;
          suppose i is even;
           then A91: i mod 2 = 0 by NAT_2:23;
           then A92: 1 = (i -' 1) mod 2 by A67,NAT_2:20
              .= (i -' 1 + 2 * 1) mod 2 by NAT_D:21
              .= (i -' 1 + 1 + 1) mod 2
              .= (i + 1) mod 2 by A67,BINARITH:53;
              A93: 1 + (1 + i) >= 1 by NAT_1:11;
            1 + 1 + (i -' 1) = 1 + 1 + (i - 1) by A67,BINARITH:50
              .= 1 + 1 + i - 1;
               then 1 = (1 + 1 + i -' 1) mod 2 by A92,
A93,BINARITH:50;
           then (1 + 1 + i) mod 2 = 0 by NAT_2:20;
           then i + 1 + 1 = 2 * ((i + 1 + 1) div 2) + 0 by NAT_D:2;
           then A94: 2 divides i + 1 + 1 by NAT_D:3;
                1 <= i + 1 + 1 by NAT_1:11;
           then (i + 1 + 1 -' 1) div 2 = ((i + 1 + 1) div 2) - 1
                                                              by A94,NAT_2:17;
           then (i + 1) div 2 = ((i + 1 + 1) div 2) - 1 by BINARITH:39;
           then A95: ((i + 1) div 2) + 1 = (i + 1 + 1) div 2;
           then A96: (i+1) div 2 <= (2 to_power n) - 1 by A76,XREAL_1:21;
           A97: a' =
                 (D.(FinSeqLevel(n,dD).((i+1+1) div 2)))`1 by A82,MCART_1:7
              .= (D.(FinSeqLevel(n,dD).((i+1) div 2)))`2 by A66,A74,A95,A96
              .= b by A79,MCART_1:7;
           thus (D.(FinSeqLevel(n+1,dD).(i+1)))`1 = (D.(FF^<*(2*1+i) mod 2*>))
`1 by A71,BINTREE2:24
              .= (D.(FF^<* 0 *>))`1 by A91,NAT_D:21
              .= a1' by A85,MCART_1:7
              .= (D.(F^<* 1 *>))`2 by A84,A97,MCART_1:7
              .= (D.(FinSeqLevel(n+1,dD).i))`2 by A67,A70,A92,BINTREE2:24;
         end;
         end;
         hence (D.(FinSeqLevel(n+1,dD).(i+1)))`1 =
          (D.(FinSeqLevel(n+1,dD).i))`2;
        end;
        A98: for n be non empty Element of NAT holds R[n]
                                                      from BINARITH:sch 1
(A59,A65);
        A99: 1 <= 1 + i by NAT_1:11;
        then A100: i + 1 in Seg len h by A42,A57,FINSEQ_1:3;
        then i + 1 in dom h by FINSEQ_1:def 3;
        hence f/.(i+1) = h/.(i+1) by FINSEQ_4:83
           .= h.(i+1) by A42,A57,A99,FINSEQ_4:24
           .= (g/.(i+1))`1 by A18,A19,A100
           .= (g.(i+1))`1 by A16,A18,A42,A57,A99,FINSEQ_4:24
           .= (D.(FSL/.(i+1)))`1 by A17,A18,A100
           .= (D.(FinSeqLevel(n,dD).(i+1)))`1 by A18,A42,A51,A57,A99,
FINSEQ_4:24
           .= (D.(FinSeqLevel(n,dD).i))`2 by A49,A58,A98;
       end;
       suppose A101: i = len f - 1;
        hence f/.(i+1) = (D.'not' ze)`2 by A41,A47
           .= (D.(FinSeqLevel(n,dD).i))`2 by A18,A42,A101,BINTREE2:16;
      end;
      end;
          A102: i >= 0 + 1 by A49;
      defpred S[non empty Element of NAT] means
        for j be non empty Element of NAT st j <= 2 to_power $1
       for DF1,DF2 be Element of V st
       DF1 = (D.(FinSeqLevel($1,dD).j))`1 & DF2 = (D.(FinSeqLevel($1,dD).j))`2
        holds dist(DF1,DF2) = dist(x,y) / 2 to_power $1;
      A103: S[1]
      proof
       let j be non empty Element of NAT;
       A104: 2 to_power 1 = 2 by POWER:30;
       A105: j >= 1 by NAT_1:14;
       assume A106: j <= 2 to_power 1;
       then A107: j in Seg 2 by A104,A105,FINSEQ_1:3;
       let DF1,DF2 be Element of V;
       assume that
        A108: DF1 = (D.(FinSeqLevel(1,dD).j))`1 and
        A109: DF2 = (D.(FinSeqLevel(1,dD).j))`2;
       reconsider pusty = <*>({0,1}) as Node of D by A11,FINSEQ_1:def 11;
            j >= 1 by NAT_1:14;
       then j in Seg (2 to_power 1) by A106,FINSEQ_1:3;
       then j in dom FinSeqLevel(1,dD) by BINTREE2:20;
       then reconsider FSL1j = FinSeqLevel(1,dD).j as Element of dom D
                                                              by FINSEQ_2:13;
            now per cases by A107,FINSEQ_1:4,TARSKI:def 2;
        suppose A110: j = 1;
         A111: D.(pusty ^ <* 0 *>) = D.(<* 0 *>) by FINSEQ_1:47
            .= D.FSL1j by A110,BINTREE2:22
            .= [DF1,DF2] by A108,A109,MCART_1:23;
         consider b be Element of A such that
          A112: D.(pusty^<* 0 *>) = [x,b] and
               D.(pusty^<* 1 *>) = [b,y] and
          A113: dist(x,y) = 2 * dist(x,b) and
               dist(x,y) = 2 * dist(b,y) by A12,A13;
           DF1 = x & DF2 = b by A111,A112,ZFMISC_1:33;
         hence dist(DF1,DF2) = dist(x,y) / 2 by A113;
        end;
        suppose A114: j = 2;
         A115: D.(pusty ^ <* 1 *>) = D.(<* 1 *>) by FINSEQ_1:47
            .= D.FSL1j by A114,BINTREE2:23
            .= [DF1,DF2] by A108,A109,MCART_1:23;
         consider b be Element of A such that
               D.(pusty^<* 0 *>) = [x,b] and
          A116: D.(pusty^<* 1 *>) = [b,y] and
               dist(x,y) = 2 * dist(x,b) and
          A117: dist(x,y) = 2 * dist(b,y) by A12,A13;
           DF1 = b & DF2 = y by A115,A116,ZFMISC_1:33;
         hence dist(DF1,DF2) = dist(x,y) / 2 by A117;
       end;
       end;
       hence dist(DF1,DF2) = dist(x,y) / 2 to_power 1 by POWER:30;
      end;
      A118: for l be non empty Element of NAT st S[l] holds S[l+1]
      proof
       let l be non empty Element of NAT;
       assume A119: for j be non empty Element of NAT st j <= 2 to_power l
        for DF1,DF2 be Element of V st
         DF1 = (D.(FinSeqLevel(l,dD).j))`1 & DF2 = (D.(FinSeqLevel(l,dD).j))`2
          holds dist(DF1,DF2) = dist(x,y) / 2 to_power l;
       let j be non empty Element of NAT;
       assume A120: j <= 2 to_power (l+1);
       let DF1,DF2 be Element of V;
       assume that
        A121: DF1 = (D.(FinSeqLevel(l+1,dD).j))`1 and
        A122: DF2 = (D.(FinSeqLevel(l+1,dD).j))`2;
            (j + 1) div 2 <> 0
       proof
        assume (j + 1) div 2 = 0;
        then j + 1 < 1 + 1 by NAT_2:14;
        then j < 1 by XREAL_1:8;
        hence contradiction by NAT_1:14;
       end;
       then reconsider j1 = (j+1) div 2 as non empty Element of NAT;
       A123: j1 >= 1 by NAT_1:14;
            j <= (2 to_power l) * (2 to_power 1) by A120,POWER:32;
       then j <= (2 to_power l) * 2 by POWER:30;
       then A124: j1 <= 2 to_power l by NAT_2:27;
       then j1 in Seg (2 to_power l) by A123,FINSEQ_1:3;
       then A125: (j+1) div 2 in dom FinSeqLevel(l,dD) by BINTREE2:20;
            j >= 1 by NAT_1:14;
       then j in Seg (2 to_power (l+1)) by A120,FINSEQ_1:3;
       then A126: j in dom FinSeqLevel(l+1,dD) by BINTREE2:20;
       reconsider dDll1 = dD-level (l+1) as non empty set by A11,BINTREE2:10;
            FinSeqLevel(l+1,dD).j in dDll1 by A126,FINSEQ_2:13;
       then reconsider FSLl1 = FinSeqLevel(l+1,dD).j as Tuple of l+1,BOOLEAN
                                                               by BINTREE2:5;
       reconsider Fj = (FinSeqLevel(l+1,dD).j) as Element of dom D
                                                          by A126,FINSEQ_2:13;
       A127: D.Fj = [DF1,DF2] by A121,A122,MCART_1:23;
       consider FSLl be Tuple of l,BOOLEAN,
                d be Element of BOOLEAN such that
        A128: FSLl1 = FSLl^<*d*> by FINSEQ_2:137;
       reconsider NFSLl = FSLl as Node of D by A11,FINSEQ_1:def 11;
       consider x1,y1 be set such that
        A129: x1 in A and
        A130: y1 in A and
        A131: D.NFSLl = [x1,y1] by ZFMISC_1:def 2;
       reconsider x1, y1 as Element of A by A129,A130;
       consider b be Element of A such that
        A132: D.(NFSLl^<* 0 *>) = [x1,b] and
        A133: D.(NFSLl^<* 1 *>) = [b,y1] and
        A134: dist(x1,y1) = 2 * dist(x1,b) and
        A135: dist(x1,y1) = 2 * dist(b,y1) by A13,A131;
       reconsider dDll = dD-level l as non empty set by A11,BINTREE2:10;
            FinSeqLevel(l,dD).((j+1) div 2) in dDll by A125,FINSEQ_2:13;
       then reconsider FSLlprim = FinSeqLevel(l,dD).((j+1) div 2)
                                         as Tuple of l,BOOLEAN by BINTREE2:5;
            FinSeqLevel(l+1,dD).j = FSLlprim^<*(j+1) mod 2*> by A120,BINTREE2:
24
;
       then A136: FSLl = FSLlprim & d = (j+1) mod 2 by A128,FINSEQ_2:20;
       then A137:   x1 = (D.(FinSeqLevel(l,dD).j1))`1 &
        y1 = (D.(FinSeqLevel(l,dD).j1))`2 by A131,MCART_1:7;
            now per cases by A136,NAT_D:12;
        suppose d = 0;
         then DF1 = x1 & DF2 = b by A127,A128,A132,ZFMISC_1:33;
         then 2 * dist(DF1,DF2) = (dist(x,y) / 2 to_power l) / 2 * 2
                                                   by A134,A137,A119,A124;
         hence dist(DF1,DF2) = dist(x,y) / ((2 to_power l) * 2) by XCMPLX_1:79
           .= dist(x,y) / ((2 to_power l) * (2 to_power 1)) by POWER:30
           .= dist(x,y) / (2 to_power (l+1)) by POWER:32;
        end;
        suppose d = 1;
         then DF1 = b & DF2 = y1 by A127,A128,A133,ZFMISC_1:33;
         then 2 * dist(DF1,DF2) = (dist(x,y) / 2 to_power l) / 2 * 2
                                                   by A135,A137,A119,A124;
         hence dist(DF1,DF2) = dist(x,y) / ((2 to_power l) * 2) by XCMPLX_1:79
           .= dist(x,y) / ((2 to_power l) * (2 to_power 1)) by POWER:30
           .= dist(x,y) / (2 to_power (l+1)) by POWER:32;
       end;
       end;
       hence dist(DF1,DF2) = dist(x,y) / 2 to_power (l+1);
      end;
           for l be non empty Element of NAT holds S[l]
           from BINARITH:sch 1(A103,A118);
      hence dist(f/.i,f/.(i+1)) = r by A18,A42,A50,A53,A56,A102;
     end;
     hence for i be Element of NAT st 1 <= i & i <= len f - 1 holds
      dist(f/.i,f/.(i+1)) < p by A15;
     let F be FinSequence of REAL such that
      A138: len F = len f - 1 and
      A139: for i be Element of NAT st 1 <= i & i <= len F holds
       F/.i = dist(f/.i,f/.(i+1));
     A140: dom F = Seg len F by FINSEQ_1:def 3;
          rng F = {r}
     proof
      thus rng F c= {r}
      proof
       let a be set;
       assume a in rng F;
       then consider c be set such that
        A141: c in dom F and
        A142: F.c = a by FUNCT_1:def 5;
            c in Seg len F by A141,FINSEQ_1:def 3;
       then c in { t where t is Element of NAT : 1 <= t & t <= len F }
        by FINSEQ_1:def 1;
       then consider c1 be Element of NAT such that
        A143: c1 = c and
        A144: 1 <= c1 and
        A145: c1 <= len F;
            a = F/.c1 by A142,A143,A144,A145,FINSEQ_4:24
        .= dist(f/.c1,f/.(c1+1)) by A139,A144,A145
        .= r by A48,A138,A144,A145;
       hence a in {r} by TARSKI:def 1;
      end;
      let a be set;
      assume a in {r};
      then A146: a = r by TARSKI:def 1;
        1 in Seg len F by A18,A42,A43,A138,FINSEQ_1:3;
      then A147: 1 in dom F by FINSEQ_1:def 3;
           a = dist(f/.1,f/.(1+1)) by A18,A42,A43,A48,A146
       .= F/.1 by A18,A42,A43,A138,A139
       .= F.1 by A18,A42,A43,A138,FINSEQ_4:24;
      hence a in rng F by A147,FUNCT_1:def 5;
     end;
     then F = len F |-> r by A140,FUNCOP_1:15;
     hence Sum F = (N + 1 - 1) * r by A18,A42,A138,RVSUM_1:110
             .= dist(x,y) by XCMPLX_1:88;
    end;
    suppose A148: dist(x,y) < p;
     take f = <*x,y*>;
     thus A149: f/.1 = x by FINSEQ_4:26;
          len f = 2 by FINSEQ_1:61;
     hence f/.len f = y by FINSEQ_4:26;
     A150: len f - 1 = 1 + 1 - 1 by FINSEQ_1:61
        .= 1;
     thus for i be Element of NAT st 1 <= i & i <= len f - 1 holds
      dist(f/.i,f/.(i+1)) < p
     proof
      let i be Element of NAT;
      assume that
       A151: 1 <= i and
       A152: i <= len f - 1;
           i in Seg 1 by A150,A151,A152,FINSEQ_1:3;
      then i = 1 by FINSEQ_1:4,TARSKI:def 1;
      hence dist(f/.i,f/.(i+1)) < p by A148,A149,FINSEQ_4:26;
     end;
     let F be FinSequence of REAL;
     assume that
      A153: len F = len f - 1 and
      A154: for i be Element of NAT st 1 <= i & i <= len F holds
       F/.i = dist(f/.i,f/.(i+1));
          F/.1 = dist(f/.1,f/.(1+1)) by A150,A153,A154
        .= dist(x,y) by A149,FINSEQ_4:26;
     then F = <*dist(x,y)*> by A150,A153,FINSEQ_5:15;
     hence dist(x,y) = Sum F by FINSOP_1:12;
   end;
   end;

  registration
   cluster convex -> internal (non empty MetrSpace);
   coherence
   proof
    let V be non empty MetrSpace;
    assume A1: V is convex;
    let x,y be Element of V;
    let p,q be Real such that
     A2: p > 0 and
     A3: q > 0;
    consider f be FinSequence of the carrier of V such that
     A4: f/.1 = x and
     A5: f/.len f = y and
     A6: for i be Element of NAT st 1 <= i & i <= len f - 1 holds
      dist(f/.i,f/.(i+1)) < p and
     A7: for F be FinSequence of REAL st len F = len f - 1 &
      for i be Element of NAT st 1 <= i & i <= len F
       holds F/.i = dist(f/.i,f/.(i+1))
       holds dist(x,y) = Sum F by A1,A2,Th1;
    take f;
    thus f/.1 = x & f/.len f = y &
     for i be Element of NAT st 1 <= i & i <= len f - 1
      holds dist(f/.i,f/.(i+1)) < p
                                                                 by A4,A5,A6;
    let F be FinSequence of REAL such that
     A8: len F = len f - 1 and
     A9: for i be Element of NAT st 1 <= i & i <= len F holds
      F/.i = dist(f/.i,f/.(i+1));
          dist(x,y) = Sum F by A7,A8,A9;
     hence abs(dist(x,y) - Sum F) < q by A3,ABSVALUE:7;
   end;
  end;

  registration
   cluster convex (non empty MetrSpace);
   existence
   proof
    reconsider ZS = {0} as non empty set;
    deffunc T((Element of ZS), Element of ZS) = 0;
    consider F be Function of [:ZS,ZS:],REAL such that
     A1: for x,y be Element of ZS holds F.(x,y) = T(x,y) from BINOP_1:sch 4;
   reconsider V = MetrStruct (# ZS,F #) as non empty MetrStruct
                                                          by STRUCT_0:def 1;
   A2: now let a,b be Element of V;
    assume dist(a,b) = 0;
         a = 0 & b = 0 by TARSKI:def 1;
    hence a = b;
   end;
   A3: now let a be Element of V;
    thus dist(a,a) = F.(a,a) by METRIC_1:def 1
                .= 0 by A1;
   end;
   A4: now let a,b be Element of V;
    thus dist(a,b) = F.(a,b) by METRIC_1:def 1
                .= 0 by A1
                .= F.(b,a) by A1
                .= dist(b,a) by METRIC_1:def 1;
   end;
        now let a,b,c be Element of V;
         a = 0 & b = 0 & c = 0 by TARSKI:def 1;
    then dist(a,c) = 0 & dist(a,b) = 0 & dist(b,c) = 0 by A3;
    hence dist(a,c) <= dist(a,b) + dist(b,c);
   end;
   then reconsider V as discerning Reflexive symmetric
    triangle (non empty MetrStruct) by A2,A3,A4,METRIC_1:1,2,
3,4;
   take V;
   let x,y be Element of V;
   let r be Real such that
         0 <= r and
         r <= 1;
   take z = x;
   A5: dist(x,z) = F.(x,z) by METRIC_1:def 1
                .= 0 by A1;
        dist(z,y) = F.(z,y) by METRIC_1:def 1
            .= 0 by A1;
   hence dist(x,z) = r * dist(x,y) & dist(z,y) = (1 - r) * dist(x,y) by A5;
   end;
  end;

  definition
   mode Geometry is Reflexive discerning symmetric triangle internal
        (non empty MetrStruct);
  end;

begin  :: Isometric Functions

  definition
   let V be non empty MetrStruct;
   let f be Function of V,V;
   attr f is isometric means :Def3:
    rng f = the carrier of V &
    for x,y be Element of V holds dist(x,y) = dist(f.x,f.y);
  end;

  definition
   let V be non empty MetrStruct;
   func ISOM(V) -> set means :Def4:
    for x be set holds
     x in it iff ex f be Function of V,V st f = x & f is isometric;
   existence
   proof
     defpred Sep[set] means
      ex f be Function of V,V st f = $1 & f is isometric;
    consider X be set such that
     A1: for x be set holds x in X iff
      x in Funcs(the carrier of V,the carrier of V) & Sep[x] from
XBOOLE_0:sch 1;
    take X;
    let x be set;
    thus x in X implies ex f be Function
 of V,V st f = x & f is isometric by A1;
    thus (ex f be Function of V,V st f = x & f is isometric) implies x in X
    proof
     given f be Function of V,V such that
      A2: f = x and
      A3: f is isometric;
          f in Funcs(the carrier of V,the carrier of V) by FUNCT_2:11;
     hence x in X by A1,A2,A3;
    end;
   end;
   uniqueness
    proof
      defpred P[set] means
       ex f be Function of V,V st f = $1 & f is isometric;
      thus for X1,X2 being set st
      (for x being set holds x in X1 iff P[x]) &
      (for x being set holds x in X2 iff P[x]) holds X1 = X2 from
XBOOLE_0:sch 3;
    end;
  end;

  definition
   let V be non empty MetrStruct;
   redefine func ISOM(V) -> Subset of Funcs(the carrier of V,the carrier of V);
   coherence
   proof
         now let x be set;
     assume x in ISOM(V);
     then consider f be Function of V,V such that
      A1: f = x and
           f is isometric by Def4;
     thus x in Funcs(the carrier of V,the carrier of V) by A1,FUNCT_2:11;
    end;
    hence ISOM(V) is Subset of Funcs(the carrier of V,the carrier of V)
                                                            by TARSKI:def 3;
   end;
  end;

  theorem Th2:
   for V be discerning Reflexive (non empty MetrStruct)
   for f be Function of V,V st f is isometric holds
    f is one-to-one
   proof
    let V be discerning Reflexive (non empty MetrStruct);
    let f be Function of V,V;
    assume A1: f is isometric;
         now let x,y be set;
     assume that
      A2: x in dom f and
      A3: y in dom f and
      A4: f.x = f.y;
     reconsider x1 = x, y1 = y as Element of V
                                                     by A2,A3;
          dist(x1,y1) = dist(f.x1,f.y1) by A1,Def3
                .= 0 by A4,METRIC_1:1;
     hence x = y by METRIC_1:2;
    end;
    hence f is one-to-one by FUNCT_1:def 8;
   end;

  registration
   let V be discerning Reflexive (non empty MetrStruct);
   cluster isometric -> one-to-one Function of V,V;
   coherence by Th2;
  end;

  registration
   let V be non empty MetrStruct;
   cluster isometric Function of V,V;
   existence
   proof
    reconsider f = id (the carrier of V) as Function of V,V;
    take f;
    thus rng f = the carrier of V by RELAT_1:71;
    let x,y be Element of V;
    thus dist(x,y) = dist(f.x,y) by FUNCT_1:35
                  .= dist(f.x,f.y) by FUNCT_1:35;
   end;
  end;

  theorem Th3:
   for V be discerning Reflexive (non empty MetrStruct)
   for f be isometric Function of V,V holds
    f" is isometric
   proof
    let V be discerning Reflexive (non empty MetrStruct);
    let f be isometric Function of V,V;
    A1: rng f = the carrier of V by Def3;
     rng f = [#]V by Def3;
    hence rng (f") = the carrier of V by TOPS_2:62;
    let x,y be Element of V;
    A2: dom f = [#]V & rng f = [#]V by Def3,FUNCT_2:def 1;
    A3: dom (f") = [#]V by A1,TOPS_2:62;
    A4: x = (id rng f).x by A1,FUNCT_1:35
         .= (f*f").x by A2,TOPS_2:65
         .= f.(f".x) by A3,FUNCT_1:23;
         y = (id rng f).y by A1,FUNCT_1:35
     .= (f*f").y by A2,TOPS_2:65
     .= f.(f".y) by A3,FUNCT_1:23;
    hence dist(x,y) = dist(f".x,f".y) by A4,Def3;
   end;

  theorem Th4:
   for V be non empty MetrStruct
   for f,g be isometric Function of V,V holds
    f*g is isometric
   proof
    let V be non empty MetrStruct;
    let f,g be isometric Function of V,V;
         rng g = the carrier of V by Def3
       .= dom f by FUNCT_2:def 1;
    hence rng (f*g) = rng f by RELAT_1:47
       .= the carrier of V by Def3;
    let x,y be Element of V;
         x in the carrier of V & y in the carrier of V;
    then A1: x in dom g & y in dom g by FUNCT_2:def 1;
    thus dist(x,y) = dist(g.x,g.y) by Def3
                  .= dist(f.(g.x),f.(g.y)) by Def3
                  .= dist((f*g).x,f.(g.y)) by A1,FUNCT_1:23
                  .= dist((f*g).x,(f*g).y) by A1,FUNCT_1:23;
   end;

  theorem Th5:
   for V be non empty MetrStruct holds
    id(V) is isometric
   proof
    let V be non empty MetrStruct;
    thus rng id(V) = the carrier of V by RELAT_1:71;
    let x,y be Element of V;
    thus dist(x,y) = dist(id(V).x,y) by FUNCT_1:35
                  .= dist(id(V).x,id(V).y) by FUNCT_1:35;
   end;

  registration
   let V be non empty MetrStruct;
   cluster ISOM V -> non empty;
   coherence
   proof
         id(V) is isometric by Th5;
    hence ISOM V is non empty by Def4;
   end;
  end;

begin  :: Real Linear-Metric Spaces

definition
  struct(RLSStruct,MetrStruct) RLSMetrStruct (# carrier -> set,
          distance -> Function of [:the carrier,the carrier:],REAL,
          ZeroF -> Element of the carrier,
          add -> BinOp of the carrier,
          Mult -> Function of [:REAL, the carrier:],the carrier #);
end;

  registration
   cluster non empty strict RLSMetrStruct;
   existence
   proof
    consider X be non empty set,
             F be Function of [:X,X:],REAL,
             O be Element of X,
             B be BinOp of X,
             G be Function of [:REAL,X:],X;
    take RLSMetrStruct (# X,F,O,B,G #);
    thus the carrier of RLSMetrStruct (# X,F,O,B,G #) is non empty;
    thus RLSMetrStruct (# X,F,O,B,G #) is strict;
   end;
  end;

  registration
   let X be non empty set;
   let F be Function of [:X,X:],REAL;
   let O be Element of X;
   let B be BinOp of X;
   let G be Function of [:REAL,X:],X;
   cluster RLSMetrStruct (# X,F,O,B,G #) -> non empty;
   coherence by STRUCT_0:def 1;
  end;

  definition
   let V be non empty RLSMetrStruct;
   attr V is homogeneous means :Def5:
    for r be Real
    for v,w be Element of V holds
     dist(r*v,r*w) = abs(r) * dist(v,w);
  end;

  definition
   let V be non empty RLSMetrStruct;
   attr V is translatible means :Def6:
    for u,w,v be Element of V holds
     dist(v,w) = dist(v+u,w+u);
  end;

  definition
   let V be non empty RLSMetrStruct;
   let v be Element of V;
   func Norm(v) -> Real equals
     dist(0.V,v);
   coherence;
  end;

  registration
   cluster strict Abelian add-associative right_zeroed
           right_complementable RealLinearSpace-like
           Reflexive discerning symmetric triangle
           homogeneous translatible (non empty RLSMetrStruct);
   existence
   proof
    reconsider ZS = {0} as non empty set;
    reconsider O = 0 as Element of ZS by TARSKI:def 1;
    deffunc T((Element of ZS), Element of ZS) = 0;
    consider FF be Function of [:ZS,ZS:],REAL such that
     A1: for x,y be Element of ZS holds FF.(x,y) = T(x,y) from BINOP_1:sch 4;
    deffunc A((Element of ZS), Element of ZS) = O;
    consider F be BinOp of ZS such that
     A2: for x,y be Element of ZS holds F.(x,y) = A(x,y) from BINOP_1:sch 4;
    deffunc M((Element of REAL), Element of ZS) = O;
    consider G be Function of [:REAL,ZS:],ZS such that
     A3: for a be Element of REAL for x be Element of ZS holds
            G.(a,x) = M(a,x) from BINOP_1:sch 4;
    set W = RLSMetrStruct (# ZS,FF,O,F,G #);
    A4: for x,y be VECTOR of W holds x + y = y + x
    proof
     let x,y be VECTOR of W;
     reconsider X = x, Y = y as Element of ZS;
          x + y = A(X,Y) & y + x = A(Y,X) by A2;
     hence thesis;
    end;
    A5: for x,y,z be VECTOR of W holds (x + y) + z = x + (y + z)
    proof
     let x,y,z be VECTOR of W;
     reconsider X = x, Y = y, Z = z as Element of ZS;
          (x + y) + z = A(A(X,Y),Z) & x + (y + z) = A(X,A(Y,Z)) by A2;
     hence thesis;
    end;
    A6: for x be VECTOR of W holds x + 0.W = x
    proof
     let x be VECTOR of W;
     reconsider X = x as Element of ZS;
          x + 0.W = A(X,O) by A2;
     hence thesis by TARSKI:def 1;
    end;
    A7: for x be VECTOR of W ex y be VECTOR of W st x + y = 0.W
    proof
     let x be VECTOR of W;
     reconsider y = O as VECTOR of W;
     take y;
     thus x + y = 0.W by A2;
    end;
    A8: for a be Element of REAL for x,y be VECTOR of W holds
          a * (x + y) = a * x + a * y
    proof
     let a be Element of REAL;
     let x,y be VECTOR of W;
     reconsider X = x, Y = y as Element of ZS;
          a * x + a * y = A(M(a,X),M(a,Y)) by A2;
     hence thesis by A3;
    end;
    A9: for a,b be Element of REAL
         for x be VECTOR of W holds (a + b) * x = a * x + b * x
    proof
     let a,b be Element of REAL;
     let x be VECTOR of W;
     set c = a + b;
     reconsider X = x as Element of ZS;
       c * x = M(c,X) by A3;
     hence thesis by A2;
    end;
    A10: for a,b be Element of REAL
         for x be VECTOR of W holds (a * b) * x = a * (b * x)
    proof
     let a,b be Element of REAL;
     let x be VECTOR of W;
     set c = a * b;
     reconsider X = x as Element of ZS;
       c * x = M(c,X) by A3;
     hence thesis by A3;
    end;
    A11: for x be VECTOR of W holds 1 * x = x
    proof
     let x be VECTOR of W;
     reconsider X = x as Element of ZS;
     reconsider A' = 1 as Element of REAL;
          1 * x = M(A',X) by A3;
     hence thesis by TARSKI:def 1;
    end;
    A12: for a,b,c be Point of W holds
          dist (a,a) = 0 &
          (dist(a,b) = 0 implies a=b) &
          dist(a,b) = dist(b,a) &
          dist(a,c)<=dist(a,b)+dist(b,c)
    proof
     let a,b,c be Point of W;
     A13: a = 0 & b = 0 & c = 0 by TARSKI:def 1;
     thus A14: dist(a,a) = 0
     proof
      thus dist(a,a) = FF.(a,a) by METRIC_1:def 1
                    .= 0 by A1;
     end;
     thus dist(a,b) = 0 implies a = b by A13;
     thus dist(a,b) = dist(b,a) by A13;
     thus dist(a,c)<=dist(a,b)+dist(b,c) by A13,A14;
    end;
    A15: for r be Element of REAL
         for v,w be VECTOR of W holds
          dist(r*v,r*w) = abs(r) * dist(v,w)
    proof
     let r be Element of REAL;
     let v,w be VECTOR of W;
     reconsider v1 = v, w1 = w as Element of ZS;
     thus dist(r*v,r*w) = FF.(r*v,r*w) by METRIC_1:def 1
                       .= abs(r) * 0 by A1
                       .= abs(r) * FF.(v1,w1) by A1
                       .= abs(r) * dist(v,w) by METRIC_1:def 1;
    end;
    A16: for u,w,v be VECTOR of W holds
       dist(v,w) = dist(v + u,w + u)
    proof
     let u,w,v be VECTOR of W;
     thus dist(v + u,w + u) = FF.(v + u,w + u) by METRIC_1:def 1
                   .= 0 by A1
                   .= FF.(v,w) by A1
                   .= dist(v,w) by METRIC_1:def 1;
    end;
    take W;
    thus W is strict;
    thus W is Abelian by A4,RLVECT_1:def 5;
    thus W is add-associative by A5,RLVECT_1:def 6;
    thus W is right_zeroed by A6,RLVECT_1:def 7;
    thus W is right_complementable by A7,RLVECT_1:def 8;
    thus W is RealLinearSpace-like by A8,A9,A10,A11,RLVECT_1:def 9;
    thus W is Reflexive by A12,METRIC_1:1;
    thus W is discerning by A12,METRIC_1:2;
    thus W is symmetric by A12,METRIC_1:3;
    thus W is triangle by A12,METRIC_1:4;
    thus W is homogeneous by A15,Def5;
    thus W is translatible by A16,Def6;
   end;
  end;

  definition
   mode RealLinearMetrSpace is
    Abelian add-associative right_zeroed right_complementable
    RealLinearSpace-like Reflexive discerning symmetric triangle
    homogeneous translatible (non empty RLSMetrStruct);
  end;

  theorem
        for V be homogeneous Abelian add-associative right_zeroed
    right_complementable RealLinearSpace-like (non empty RLSMetrStruct)
   for r be Real
   for v be Element of V holds
    Norm (r * v) = abs(r) * Norm v
   proof
    let V be homogeneous Abelian add-associative right_zeroed
     right_complementable RealLinearSpace-like (non empty RLSMetrStruct);
    let r be Real;
    let v be Element of V;
    thus Norm (r * v) = dist(r*(0.V),r * v) by RLVECT_1:23
         .= abs(r) * Norm (v) by Def5;
   end;

  theorem
        for V be translatible Abelian add-associative right_zeroed
              right_complementable triangle (non empty RLSMetrStruct)
   for v,w be Element of V holds
    Norm (v + w) <= Norm v + Norm w
   proof
    let V be translatible Abelian add-associative right_zeroed
             right_complementable triangle (non empty RLSMetrStruct);
    let v,w be Element of V;
     Norm (v + w) <= dist(0.V,v) + dist(v,v + w) by METRIC_1:4;
    then Norm (v + w) <= Norm v + dist(v + -v,v + w + -v) by Def6;
    then Norm (v + w) <= Norm v + dist(0.V,v + w + -v) by RLVECT_1:16;
    then Norm (v + w) <= Norm v + dist(0.V,w + ((-v) + v)) by RLVECT_1:def 6;
    then Norm (v + w) <= Norm v + dist(0.V,w + (0.V)) by RLVECT_1:16;
    hence Norm (v + w) <= Norm v + Norm w by RLVECT_1:10;
   end;

  theorem
        for V be translatible add-associative right_zeroed right_complementable
                                                    (non empty RLSMetrStruct)
   for v,w be Element of V holds
    dist(v,w) = Norm (w - v)
   proof
    let V be translatible add-associative right_zeroed
                              right_complementable (non empty RLSMetrStruct);
    let v,w be Element of V;
    thus dist(v,w) = dist(v + -v,w + -v) by Def6
         .= Norm (w - v) by RLVECT_1:16;
   end;

  definition
   let n be Element of NAT;
   func RLMSpace n -> strict RealLinearMetrSpace means :Def8:
    the carrier of it = REAL n &
    the distance of it = Pitag_dist n &
    0.it = 0*n &
    (for x,y be Element of REAL n holds (the add of it).(x,y) = x + y) &
    for x be Element of REAL n,r be Element of REAL holds
     (the Mult of it).(r,x) = r * x;
   existence
   proof
     deffunc F(Element of REAL n, Element of REAL n) = $1+$2;
    consider f be BinOp of REAL n such that
A1: for x,y be Element of REAL n holds f.(x,y) = F(x,y) from BINOP_1:sch 4;
     deffunc G(Element of REAL, Element of REAL n) = $1*$2;
    consider g be Function of [:REAL, REAL n:],REAL n such that
     A2: for r be Element of REAL,
             x be Element of REAL n holds g.(r,x) = G(r,x) from BINOP_1:sch 4;
    set RLSMS = RLSMetrStruct (# REAL n, Pitag_dist n, 0*n, f, g #);
    A3: now let v,w be Element of RLSMS;
     reconsider v1 = v, w1 = w as Element of REAL n;
     thus v + w = v1 + w1 by A1
               .= w + v by A1;
    end;
    A4: now let u,v,w be Element of RLSMS;
     reconsider u1 = u, v1 = v, w1 = w as Element of REAL n;
     thus (u + v) + w = f.(u1 + v1,w) by A1
                     .= (u1 + v1) + w1 by A1
                     .= u1 + (v1 + w1) by FINSEQOP:29
                     .= f.(u,v1 + w1) by A1
                     .= u + (v + w) by A1;
    end;
    A5: now let v be Element of RLSMS;
     reconsider v1 = v as Element of n-tuples_on REAL;
     thus v + 0.RLSMS = v1 + (n |-> (0 qua Real)) by A1
                     .= v by RVSUM_1:33;
    end;
    A6: now let v be Element of RLSMS;
     reconsider v1 = v as Element of n-tuples_on REAL;
     reconsider w = -v1 as Element of RLSMS;
     take w;
     thus v + w = v1 + - v1 by A1
               .= v1 - v1 by FINSEQOP:89
               .= 0.RLSMS by RVSUM_1:58;
    end;
    A7: now
     hereby let a be Real, v,w be VECTOR of RLSMS;
      reconsider v1 = v, w1 = w as Element of REAL n;
      reconsider v2 = v1, w2 = w1 as Element of n-tuples_on REAL;
      thus a * (v + w) = g.(a,v1 + w1) by A1
                      .= a * (v2 + w2) by A2
                      .= a * v1 + a * w1 by RVSUM_1:73
                      .= f.(a * v1,a * w1) by A1
                      .= f.(g.(a,v),a * w1) by A2
                      .= a * v + a * w by A2;
     end;
     hereby let a,b be Real, v be VECTOR of RLSMS;
      reconsider v1 = v as Element of REAL n;
      reconsider v2 = v1 as Element of n-tuples_on REAL;
      thus (a + b) * v = (a + b) * v2 by A2
                      .= a * v1 + b * v1 by RVSUM_1:72
                      .= f.(a * v1,b * v1) by A1
                      .= f.(g.(a,v),b * v1) by A2
                      .= a * v + b * v by A2;
     end;
     hereby let a,b be Real, v be VECTOR of RLSMS;
      reconsider v1 = v as Element of REAL n;
      reconsider v2 = v1 as Element of n-tuples_on REAL;
      thus (a * b) * v = (a * b) * v2 by A2
                      .= a * (b * v1) by RVSUM_1:71
                      .= g.(a,b * v1) by A2
                      .= a * (b * v) by A2;
     end;
     hereby let v be VECTOR of RLSMS;
      reconsider v1 = v as Element of n-tuples_on REAL;
      thus 1 * v = 1 * v1 by A2
                .= v by RVSUM_1:74;
     end;
    end;
    A8: now let a,b,c be VECTOR of RLSMS;
     reconsider a1 = a, b1 = b, c1 = c as Element of REAL n;
     thus dist(a,b) = 0 implies a = b
     proof
      assume dist(a,b) = 0;
      then (Pitag_dist n).(a,b) = 0 by METRIC_1:def 1;
      then |.a1 - b1.| = 0 by EUCLID:def 6;
      hence a = b by EUCLID:19;
     end;
     thus dist(a,a) = 0
     proof
           |.a1 - a1.| = 0 by EUCLID:19;
      then (Pitag_dist n).(a,a) = 0 by EUCLID:def 6;
      hence dist(a,a) = 0 by METRIC_1:def 1;
     end;
     thus dist(a,b) = (Pitag_dist n).(a,b) by METRIC_1:def 1
                   .= |.a1 - b1.| by EUCLID:def 6
                   .= |.b1 - a1.| by EUCLID:21
                   .= (Pitag_dist n).(b,a) by EUCLID:def 6
                   .= dist(b,a) by METRIC_1:def 1;
     A9: dist(a,b) = (Pitag_dist n).(a,b) by METRIC_1:def 1
                 .= |.a1 - b1.| by EUCLID:def 6;
     A10: dist(a,c) = (Pitag_dist n).(a,c) by METRIC_1:def 1
                  .= |.a1 - c1.| by EUCLID:def 6;
          dist(b,c) = (Pitag_dist n).(b,c) by METRIC_1:def 1
                   .= |.b1 - c1.| by EUCLID:def 6;
     hence dist(a,c) <= dist(a,b) + dist(b,c) by A9,A10,EUCLID:22;
    end;
    A11: now let r be Real, v,w be VECTOR of RLSMS;
     reconsider v1 = v, w1 = w as Element of REAL n;
     reconsider v2 = v1, w2 = w1 as Element of n-tuples_on REAL;
     A12: dist(v,w) = (Pitag_dist n).(v,w) by METRIC_1:def 1
                   .= |.v1 - w1.| by EUCLID:def 6;
     A13: r * v = r * v1 by A2;
     A14: r * w = r * w1 by A2;
     thus dist(r*v,r*w) = (Pitag_dist n).(r*v,r*w) by METRIC_1:def 1
                       .= |.r*v2 - r*w2.| by A13,A14,EUCLID:def 6
                       .= |.r*v2 + - (r*w2).| by FINSEQOP:89
                       .= |.r*v2 + (-1)*(r*w2).| by RVSUM_1:76
                       .= |.r*v2 + (-1) * r * w2.| by RVSUM_1:71
                       .= |.r*v2 + r*((-1) * w2).| by RVSUM_1:71
                       .= |.r * v2 + r * (-w2).| by RVSUM_1:76
                       .= |.r*(v2 + - w2).| by RVSUM_1:73
                       .= |.r*(v1 - w1).| by FINSEQOP:89
                       .= abs(r) * dist(v,w) by A12,EUCLID:14;
    end;
    A15: now let u,w,v be VECTOR of RLSMS;
     reconsider u1 = u, w1 = w, v1 = v as Element of REAL n;
     reconsider u2 = u1, w2 = w1, v2 = v1 as Element of n-tuples_on REAL;
     A16: v + u = v1 + u1 by A1;
     A17: w + u = w1 + u1 by A1;
     thus dist(v,w) = (Pitag_dist n).(v,w) by METRIC_1:def 1
                   .= |.v1 - w1.| by EUCLID:def 6
                   .= |.(v2 + u2 - u2) - w2.| by RVSUM_1:63
                   .= |.(v2 + u2) - (u2 + w2).| by RVSUM_1:60
                   .= (Pitag_dist n).(v1 + u1,w1 + u1) by EUCLID:def 6
                   .= dist(v + u,w + u) by A16,A17,METRIC_1:def 1;
    end;
    reconsider RLSMS as strict Abelian add-associative right_zeroed
          right_complementable RealLinearSpace-like (non empty RLSMetrStruct)
           by A3,A4,A5,A6,A7,RLVECT_1:def 5,def 6,def 7,
def 8,def 9;
    reconsider RLSMS as strict RealLinearMetrSpace by A8,A11,A15,Def5,Def6,
METRIC_1:1,2,3,4;
    take RLSMS;
    thus thesis by A1,A2;
   end;
   uniqueness
   proof
    let V1,V2 be strict RealLinearMetrSpace such that
     A18: the carrier of V1 = REAL n and
     A19: the distance of V1 = Pitag_dist n and
     A20: 0.V1 = 0*n and
     A21: for x,y be Element of REAL n holds (the add of V1).(x,y) = x + y and
     A22: for x be Element of REAL n,r be Element of REAL holds
      (the Mult of V1).(r,x) = r*x and
     A23: the carrier of V2 = REAL n and
     A24: the distance of V2 = Pitag_dist n and
     A25: 0.V2 = 0*n and
     A26: for x,y be Element of REAL n holds (the add of V2).(x,y) = x + y and
     A27: for x be Element of REAL n,r be Element of REAL holds
      (the Mult of V2).(r,x) = r*x;
         now let x,y be Element of V1;
     reconsider x1 = x, y1 = y as Element of REAL n by A18;
     thus (the add of V1).(x,y) = x1 + y1 by A21
        .= (the add of V2).(x,y) by A26;
    end;
    then A28: the add of V1 = the add of V2 by A18,A23,BINOP_1:2;
         now let r be Element of REAL,
            x be Element of V1;
     reconsider x1 = x as Element of REAL n by A18;
     thus (the Mult of V1).(r,x) = r*x1 by A22
        .= (the Mult of V2).(r,x) by A27;
    end;
    hence V1 = V2 by A18,A19,A20,A23,A24,A25,A28,BINOP_1:2;
   end;
  end;

  theorem
        for n be Element of NAT
   for f be isometric Function of RLMSpace n,RLMSpace n holds
    rng f = REAL n
   proof
    let n be Element of NAT;
    let f be isometric Function of RLMSpace n,RLMSpace n;
    thus rng f = the carrier of RLMSpace n by Def3
       .= REAL n by Def8;
   end;

begin  :: Groups of Isometric Functions

  definition
   let n be Element of NAT;
   func IsomGroup n -> strict HGrStr means :Def9:
    the carrier of it = ISOM RLMSpace n &
    (for f,g be Function st f in ISOM RLMSpace n &
     g in ISOM RLMSpace n holds (the mult of it).(f,g) = f*g);
   existence
   proof
     defpred P[set, set, set] means
      ex f,g be Function st f = $1 & g = $2 & $3 = f*g;
    A1: for x,y be Element of ISOM RLMSpace n
        ex z be Element of ISOM RLMSpace n st P[x,y,z]
    proof
     let x,y be Element of ISOM RLMSpace n;
     consider x1 be Function of RLMSpace n,RLMSpace n such that
      A2: x1 = x and
      A3: x1 is isometric by Def4;
     consider y1 be Function of RLMSpace n,RLMSpace n such that
      A4: y1 = y and
      A5: y1 is isometric by Def4;
          x1*y1 is isometric by A3,A5,Th4;
     then reconsider z = x1*y1 as Element of ISOM RLMSpace n by Def4;
     take z;
     take x1,y1;
     thus thesis by A2,A4;
    end;
    consider o be BinOp of ISOM RLMSpace n such that
     A6: for a,b be Element of ISOM RLMSpace n holds P[a,b, o.(a,b)]
       from BINOP_1:sch 3(A1);
    take G = HGrStr(#ISOM RLMSpace n,o#);
         for f,g be Function st f in ISOM RLMSpace n &
     g in ISOM RLMSpace n holds (the mult of G).(f,g) = f*g
    proof
     let f,g be Function;
     assume that
      A7: f in ISOM RLMSpace n and
      A8: g in ISOM RLMSpace n;
     consider f1,g1 be Function such that
      A9: f1 = f and
      A10: g1 = g and
      A11: o.(f,g) = f1*g1 by A6,A7,A8;
     thus (the mult of G).(f,g) = f*g by A9,A10,A11;
    end;
    hence thesis;
   end;
   uniqueness
   proof
    set V = RLMSpace n;
    let G1,G2 be strict HGrStr such that
     A12: the carrier of G1 = ISOM V and
     A13: for f,g be Function st f in ISOM V & g in ISOM V holds
          (the mult of G1).(f,g) = f*g and
     A14: the carrier of G2 = ISOM V and
     A15: for f,g be Function st f in ISOM V & g in ISOM V holds
          (the mult of G2).(f,g) = f*g;
         now let f,g be Element of G1;
     consider f1 be Function of RLMSpace n,RLMSpace n such that
      A16: f1 = f and
           f1 is isometric by A12,Def4;
     consider g1 be Function of RLMSpace n,RLMSpace n such that
      A17: g1 = g and
           g1 is isometric by A12,Def4;
     thus (the mult of G1).(f,g) = f1*g1 by A12,A13,A16,A17
        .= (the mult of G2).(f,g) by A12,A15,A16,A17;
    end;
    hence G1 = G2 by A12,A14,BINOP_1:2;
   end;
  end;

  registration
   let n be Element of NAT;
   cluster IsomGroup n -> non empty;
   coherence
   proof
         the carrier of IsomGroup n = ISOM RLMSpace n by Def9;
    hence IsomGroup n is non empty by STRUCT_0:def 1;
   end;
  end;

  registration
   let n be Element of NAT;
   cluster IsomGroup n -> associative Group-like;
   coherence
   proof
         now let x,y,z be Element of IsomGroup n;
          x in the carrier of IsomGroup n;
     then A1: x in ISOM RLMSpace n by Def9;
     then consider x1 be Function of RLMSpace n,RLMSpace n such that
      A2: x1 = x and
      A3: x1 is isometric by Def4;
          y in the carrier of IsomGroup n;
     then A4: y in ISOM RLMSpace n by Def9;
     then consider y1 be Function of RLMSpace n,RLMSpace n such that
      A5: y1 = y and
      A6: y1 is isometric by Def4;
          z in the carrier of IsomGroup n;
     then A7: z in ISOM RLMSpace n by Def9;
     then consider z1 be Function of RLMSpace n,RLMSpace n such that
      A8: z1 = z and
      A9: z1 is isometric by Def4;
          x1*y1 is isometric by A3,A6,Th4;
     then A10: x1*y1 in ISOM RLMSpace n by Def4;
          y1*z1 is isometric by A6,A9,Th4;
     then A11: y1*z1 in ISOM RLMSpace n by Def4;
     thus (x*y)*z = (the mult of IsomGroup n).(x*y,z) by GROUP_1:def 1
        .= (the mult of IsomGroup n).((the mult of IsomGroup n).(x,y),z)
                                                          by GROUP_1:def 1
        .= (the mult of IsomGroup n).(x1*y1,z) by A1,A2,A4,A5,Def9
        .= (x1*y1)*z1 by A7,A8,A10,Def9
        .= x1*(y1*z1) by RELAT_1:55
        .= (the mult of IsomGroup n).(x,y1*z1) by A1,A2,A11,Def9
        .= (the mult of IsomGroup n).(x,(the mult of IsomGroup n).(y,z))
                                                            by A4,A5,A7,A8,Def9
        .= (the mult of IsomGroup n).(x,y*z) by GROUP_1:def 1
        .= x*(y*z) by GROUP_1:def 1;
    end;
    hence IsomGroup n is associative by GROUP_1:def 4;
         ex e be Element of IsomGroup n st
     for h be Element of IsomGroup n holds
      h * e = h & e * h = h &
      ex g be Element of IsomGroup n st h * g = e & g * h = e
    proof
          id(RLMSpace n) is isometric by Th5;
     then A12: id(RLMSpace n) in ISOM RLMSpace n by Def4;
     then reconsider e = id(RLMSpace n) as
                                 Element of IsomGroup n by Def9;
     take e;
     let h be Element of IsomGroup n;
          h in the carrier of IsomGroup n;
     then A13: h in ISOM RLMSpace n by Def9;
     then consider h1 be Function of RLMSpace n,RLMSpace n such that
      A14: h1 = h and
      A15: h1 is isometric by Def4;
     thus h * e = (the mult of IsomGroup n).(h,e) by GROUP_1:def 1
        .= h1*id(the carrier of RLMSpace n) by A12,A13,A14,Def9
        .= h by A14,FUNCT_2:23;
     thus e * h = (the mult of IsomGroup n).(e,h) by GROUP_1:def 1
        .= id(the carrier of RLMSpace n)*h1 by A12,A13,A14,Def9
        .= h by A14,FUNCT_2:23;
          h1" is isometric by A15,Th3;
     then A16: h1" in ISOM RLMSpace n by Def4;
     then reconsider g = h1" as Element of IsomGroup n by Def9;
     take g;
     A17: rng h1 = [#](RLMSpace n) by A15,Def3;
     A18: h1 is one-to-one by A15,Th2;
     thus h * g = (the mult of IsomGroup n).(h,g) by GROUP_1:def 1
        .= h1*h1" by A13,A14,A16,Def9
        .= e by A17,A18,TOPS_2:65;
     thus g * h = (the mult of IsomGroup n).(g,h) by GROUP_1:def 1
        .= h1"*h1 by A13,A14,A16,Def9
        .= id dom h1 by A17,A18,TOPS_2:65
        .= e by FUNCT_2:def 1;
    end;
    hence IsomGroup n is Group-like by GROUP_1:def 3;
   end;
  end;

  theorem Th10:
   for n be Element of NAT holds
    1_IsomGroup n = id (RLMSpace n)
   proof
    let n be Element of NAT;
         id(RLMSpace n) is isometric by Th5;
    then A1: id(RLMSpace n) in ISOM RLMSpace n by Def4;
    then reconsider e = id(RLMSpace n) as
                                 Element of IsomGroup n by Def9;
         now let h be Element of IsomGroup n;
          h in the carrier of IsomGroup n;
     then A2: h in ISOM RLMSpace n by Def9;
     then consider h1 be Function of RLMSpace n,RLMSpace n such that
      A3: h1 = h and
           h1 is isometric by Def4;
     thus h * e = (the mult of IsomGroup n).(h,e) by GROUP_1:def 1
        .= h1*id(the carrier of RLMSpace n) by A1,A2,A3,Def9
        .= h by A3,FUNCT_2:23;
     thus e * h = (the mult of IsomGroup n).(e,h) by GROUP_1:def 1
        .= id(the carrier of RLMSpace n)*h1 by A1,A2,A3,Def9
        .= h by A3,FUNCT_2:23;
    end;
    hence 1_IsomGroup n = id (RLMSpace n) by GROUP_1:10;
   end;

  theorem Th11:
   for n be Element of NAT
   for f be Element of IsomGroup n
   for g be Function of RLMSpace n,RLMSpace n st f = g holds
    f" = g"
   proof
    let n be Element of NAT;
    let f be Element of IsomGroup n;
    let g be Function of RLMSpace n,RLMSpace n;
    assume A1: f = g;
         f in the carrier of IsomGroup n;
    then A2: f in ISOM RLMSpace n by Def9;
    then consider f1 be Function of RLMSpace n,RLMSpace n such that
     A3: f1 = f and
     A4: f1 is isometric by Def4;
         g" is isometric by A1,A3,A4,Th3;
    then A5: g" in ISOM RLMSpace n by Def4;
    then reconsider g1 = g" as Element of IsomGroup n by Def9;
    A6: rng f1 = [#](RLMSpace n) by A4,Def3;
    A7: f1 is one-to-one by A4,Th2;
    A8: f * g1 = (the mult of IsomGroup n).(f,g1) by GROUP_1:def 1
       .= f1*g" by A2,A3,A5,Def9
       .= id(RLMSpace n) by A1,A3,A6,A7,TOPS_2:65
       .= 1_IsomGroup n by Th10;
         g1 * f = (the mult of IsomGroup n).(g1,f) by GROUP_1:def 1
       .= g"*f1 by A2,A3,A5,Def9
       .= id dom f1 by A1,A3,A6,A7,TOPS_2:65
       .= id(RLMSpace n) by FUNCT_2:def 1
       .= 1_IsomGroup n by Th10;
    hence f" = g" by A8,GROUP_1:12;
   end;

  definition
   let n be Element of NAT;
   let G be Subgroup of IsomGroup n;
   func SubIsomGroupRel G -> Relation of the carrier of RLMSpace n means :Def10
:
    for A,B be Element of RLMSpace n holds
     [A,B] in it iff ex f be Function st f in the carrier of G & f.A = B;
   existence
   proof
     defpred P[set, set] means
      ex f be Function st f in the carrier of G & f.$1 = $2;
    consider R be Relation of
     the carrier of RLMSpace n,the carrier of RLMSpace n such that
      A1: for x,y be set holds [x,y] in R iff
       x in the carrier of RLMSpace n & y in the carrier of RLMSpace n & P[x,y]
         from RELSET_1:sch 1;
    take R;
    let A,B be Element of RLMSpace n;
    thus thesis by A1;
   end;
   uniqueness
   proof
    let R1,R2 be Relation of the carrier of RLMSpace n such that
     A2: for A,B be Element of RLMSpace n holds
      [A,B] in R1 iff ex f be Function st f in the carrier of G & f.A = B and
     A3: for A,B be Element of RLMSpace n holds
      [A,B] in R2 iff ex f be Function st f in the carrier of G & f.A = B;
          now let a,b be set;
      thus [a,b] in R1 implies [a,b] in R2
      proof
       assume A4: [a,b] in R1;
       then reconsider a1 = a, b1 = b as Element of RLMSpace n
                                                          by ZFMISC_1:106;
            ex f be Function st f in the carrier of G & f.a1 = b1 by A2,A4;
       hence [a,b] in R2 by A3;
      end;
      assume A5: [a,b] in R2;
      then reconsider a1 = a, b1 = b as Element of RLMSpace n
                                                          by ZFMISC_1:106;
           ex f be Function st f in the carrier of G & f.a1 = b1 by A3,A5;
      hence [a,b] in R1 by A2;
     end;
     hence R1 = R2 by RELAT_1:def 2;
   end;
  end;

  registration
   let n be Element of NAT;
   let G be Subgroup of IsomGroup n;
   cluster SubIsomGroupRel G -> total symmetric transitive;
   coherence
   proof
    set X = the carrier of RLMSpace n;
    set S = SubIsomGroupRel G;
         now let x be set;
     assume x in X;
     then reconsider x1 = x as Element of RLMSpace n;
          1_IsomGroup n = id (RLMSpace n) by Th10;
     then id(RLMSpace n) in G by GROUP_2:55;
     then A1: id(RLMSpace n) in the carrier of G by STRUCT_0:def 5;
          id(RLMSpace n).x1 = x1 by FUNCT_1:35;
     hence [x,x] in S by A1,Def10;
    end;
    then S is_reflexive_in X by RELAT_2:def 1;
    then A2:   dom S = X & field S = X by ORDERS_1:98;
    hence S is total by PARTFUN1:def 4;
         now let x,y be set;
     assume that
      A3: x in X and
      A4: y in X and
      A5: [x,y] in S;
     reconsider x1 = x, y1 = y as Element of RLMSpace n by A3,A4;
     consider f be Function such that
      A6: f in the carrier of G and
      A7: f.x1 = y1 by A5,Def10;
     A8: the carrier of G c= the carrier of IsomGroup n by GROUP_2:def 5;
     then f in the carrier of IsomGroup n by A6;
     then f in ISOM RLMSpace n by Def9;
     then consider f2 be Function of RLMSpace n,RLMSpace n such that
      A9: f2 = f and
      A10: f2 is isometric by Def4;
     reconsider f1 = f as Element of G by A6;
     reconsider f3 = f1 as Element of IsomGroup n by A8,TARSKI:def 3;
     A11: rng f2 = the carrier of RLMSpace n by A10,Def3;
     A12: f2 is one-to-one by A10,Th2;
     A13: f1" = f3" by GROUP_2:57
        .= f2" by A9,Th11
        .= f" by A9,A11,A12,TOPS_2:def 4;
          x1 in the carrier of RLMSpace n;
     then x1 in dom f by A9,FUNCT_2:def 1;
     then f".y1 = x1 by A7,A9,A12,FUNCT_1:56;
     hence [y,x] in S by A13,Def10;
    end;
    then S is_symmetric_in X by RELAT_2:def 3;
    hence S is symmetric by A2,RELAT_2:def 11;
         now let x,y,z be set;
     assume that
      A14: x in X and
      A15: y in X and
      A16: z in X and
      A17: [x,y] in S and
      A18: [y,z] in S;
     reconsider x1 = x, y1 = y, z1 = z as Element of RLMSpace n
                                                 by A14,A15,A16;
     consider f be Function such that
      A19: f in the carrier of G and
      A20: f.x1 = y1 by A17,Def10;
     consider g be Function such that
      A21: g in the carrier of G and
      A22: g.y1 = z1 by A18,Def10;
     A23: the carrier of G c= the carrier of IsomGroup n by GROUP_2:def 5;
     then f in the carrier of IsomGroup n by A19;
     then A24: f in ISOM RLMSpace n by Def9;
     then consider f1 be Function of RLMSpace n,RLMSpace n such that
      A25: f1 = f and
           f1 is isometric by Def4;
     reconsider f2 = f as Element of G by A19;
     reconsider f3 = f2 as Element of IsomGroup n by A23,TARSKI:def 3;
          g in the carrier of IsomGroup n by A21,A23;
     then A26: g in ISOM RLMSpace n by Def9;
     reconsider g2 = g as Element of G by A21;
     reconsider g3 = g2 as Element of IsomGroup n by A23,TARSKI:def 3;
     A27: g3*f3 = (the mult of IsomGroup n).(g,f) by GROUP_1:def 1
        .= g*f by A24,A26,Def9;
        f2 in G & g2 in G by STRUCT_0:def 5;
     then g3*f3 in G by GROUP_2:59;
     then A28: g*f in the carrier of G by A27,STRUCT_0:def 5;
          x1 in the carrier of RLMSpace n;
     then x1 in dom f by A25,FUNCT_2:def 1;
     then (g*f).x1 = z1 by A20,A22,FUNCT_1:23;
     hence [x,z] in S by A28,Def10;
    end;
    then S is_transitive_in X by RELAT_2:def 8;
    hence S is transitive by A2,RELAT_2:def 16;
   end;
  end;

