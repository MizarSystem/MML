:: Properties of Fields
::  by J\'ozef Bia{\l}as
::
:: Received June 20, 1990
:: Copyright (c) 1990 Association of Mizar Users

environ

 vocabularies BOOLE, REALSET1, FUNCT_1, RELAT_1, BINOP_1, RLVECT_1, QC_LANG1,
      VECTSP_1, REALSET2, FUNCT_4, CAT_1, FUNCT_7, GROUP_1, LATTICES, ORDINAL2,
      ARYTM_1, VECTSP_2, ARYTM, ALGSTR_0;
 notations TARSKI, XBOOLE_0, ZFMISC_1, SUBSET_1, DOMAIN_1, RELAT_1, FUNCT_1,
      NUMBERS, REALSET1, FUNCOP_1, FUNCT_2, BINOP_1, FUNCT_4, FUNCT_7,
      ORDINAL1, STRUCT_0, ALGSTR_0, RLVECT_1, GROUP_1, VECTSP_1;
 constructors RLVECT_1, BINOP_1, FUNCT_4, REALSET1, FUNCT_7, VECTSP_1;
 registrations XBOOLE_0, SUBSET_1, RELSET_1, REALSET1, STRUCT_0, RLVECT_1,
      VECTSP_1, ORDINAL1, ALGSTR_0;
 requirements SUBSET, BOOLE, NUMERALS;
 definitions RLVECT_1, TARSKI, REALSET1, BINOP_1, STRUCT_0, FUNCOP_1, VECTSP_1,
      GROUP_1, ALGSTR_0;
 theorems TARSKI, FUNCT_1, FUNCT_2, ZFMISC_1, ENUMSET1, REALSET1, VECTSP_1,
      RELSET_1, XBOOLE_0, RLVECT_1, FUNCT_4, FUNCOP_1, CARD_1, XBOOLE_1,
      FUNCT_7, STRUCT_0, GROUP_1, ALGSTR_0;
 schemes FUNCT_2;

begin

definition
  canceled 7;
  func add_2 -> BinOp of 2 equals
  ((0,0) .--> 0) +* ((0,1).-->1) +* ((1,0).-->1) +* ((1,1).-->0);
  coherence
  proof
    set f2 = ((0,0).-->0) +* ((0,1).-->1), f1 = f2 +* ((1,0).-->1),
    f = f1 +*((1,1).-->0);
A1: dom f = dom f1 \/ dom((1,1).-->0) by FUNCT_4:def 1
      .= dom f1 \/ {[1,1]} by FUNCOP_1:19
      .= dom f2 \/ dom((1,0).-->1) \/ {[1,1]} by FUNCT_4:def 1
      .= dom f2 \/ {[1,0]} \/ {[1,1]} by FUNCOP_1:19
      .= dom((0,0) .--> 0) \/ dom ((0,1).-->1) \/ {[1,0]} \/ {[1,1]}
    by FUNCT_4:def 1
      .= dom((0,0) .--> 0) \/ {[0,1]} \/ {[1,0]} \/ {[1,1]} by FUNCOP_1:19
      .= {[0,0]} \/ {[0,1]} \/ {[1,0]} \/ {[1,1]} by FUNCOP_1:19
      .= {[0,0],[0,1]} \/ {[1,0]} \/ {[1,1]} by ENUMSET1:41
      .= {[0,0],[0,1],[1,0]} \/ {[1,1]} by ENUMSET1:43
      .= {[0,0],[0,1],[1,0],[1,1]} by ENUMSET1:46
      .= [:2,2:] by CARD_1:88,ZFMISC_1:146;
A2: rng f2 c= rng ((0,0).-->0) \/ rng ((0,1).-->1) by FUNCT_4:18;
A3: rng f1 c= rng f2 \/ rng ((1,0).-->1) by FUNCT_4:18;
A4: rng f c= rng f1 \/ rng ((1,1).-->0) by FUNCT_4:18;
A5: 1 c= 2 by CARD_1:87,88,ZFMISC_1:12;
A6: {1} c= 2 by CARD_1:88,ZFMISC_1:12;
    rng ((0,1).-->1) c= {1} by FUNCOP_1:19;
    then
A7: rng ((0,1).-->1) c= 2 by A6,XBOOLE_1:1;
    rng ((0,0).-->0) c= 1 by CARD_1:87,FUNCOP_1:19;
    then rng ((0,0).-->0) c= 2 by A5,XBOOLE_1:1;
    then rng ((0,0).-->0) \/ rng ((0,1).-->1) c= 2 by A7,XBOOLE_1:8;
    then
A8: rng f2 c= 2 by A2,XBOOLE_1:1;
    rng ((1,0).-->1) c= {1} by FUNCOP_1:19;
    then rng ((1,0).-->1) c= 2 by A6,XBOOLE_1:1;
    then rng f2 \/ rng ((1,0).-->1) c= 2 by A8,XBOOLE_1:8;
    then
A9: rng f1 c= 2 by A3,XBOOLE_1:1;
    rng ((1,1).-->0) c= 1 by CARD_1:87,FUNCOP_1:19;
    then rng ((1,1).-->0) c= 2 by A5,XBOOLE_1:1;
    then rng f1 \/ rng ((1,1).-->0) c= 2 by A9,XBOOLE_1:8;
    then rng f c= 2 by A4,XBOOLE_1:1;
    hence thesis by A1,FUNCT_2:def 1,RELSET_1:11;
  end;
  func mult_2 -> BinOp of 2 equals
  ((0,0).-->0) +* ((0,1).-->0) +* ((1,0).-->0) +* ((1,1).-->1);
  coherence
  proof
    set f2 = ((0,0).-->0) +* ((0,1).-->0), f1 = f2 +* ((1,0).-->0),
    f = f1 +* ((1,1).-->1);
A10: dom f = dom f1 \/ dom ((1,1).-->1) by FUNCT_4:def 1
      .= dom f1 \/ {[1,1]} by FUNCOP_1:19
      .= dom f2 \/ dom ((1,0).-->0) \/ {[1,1]} by FUNCT_4:def 1
      .= dom f2 \/ {[1,0]} \/ {[1,1]} by FUNCOP_1:19
      .= dom(((0,0).-->0)) \/ dom ((0,1).-->0) \/ {[1,0]} \/ {[1,1]}
    by FUNCT_4:def 1
      .= dom(((0,0).-->0)) \/ {[0,1]} \/ {[1,0]} \/ {[1,1]} by FUNCOP_1:19
      .= {[0,0]} \/ {[0,1]} \/ {[1,0]} \/ {[1,1]} by FUNCOP_1:19
      .= {[0,0],[0,1]} \/ {[1,0]} \/ {[1,1]} by ENUMSET1:41
      .= {[0,0],[0,1],[1,0]} \/ {[1,1]} by ENUMSET1:43
      .= {[0,0],[0,1],[1,0],[1,1]} by ENUMSET1:46
      .= [:2,2:] by CARD_1:88,ZFMISC_1:146;
A11: rng f2 c= rng ((0,0).-->0) \/ rng ((0,1).-->0) by FUNCT_4:18;
A12: rng f1 c= rng f2 \/ rng ((1,0).-->0) by FUNCT_4:18;
A13: rng f c= rng f1 \/ rng ((1,1).-->1) by FUNCT_4:18;
A14: 1 c= 2 by CARD_1:87,88,ZFMISC_1:12;
A15: {1} c= 2 by CARD_1:88,ZFMISC_1:12;
    rng ((0,1).-->0) c= 1 by CARD_1:87,FUNCOP_1:19;
    then
A16: rng ((0,1).-->0) c= 2 by A14,XBOOLE_1:1;
    rng ((0,0).-->0) c= 1 by CARD_1:87,FUNCOP_1:19;
    then rng ((0,0).-->0) c= 2 by A14,XBOOLE_1:1;
    then rng ((0,0).-->0) \/ rng ((0,1).-->0) c= 2 by A16,XBOOLE_1:8;
    then
A17: rng f2 c= 2 by A11,XBOOLE_1:1;
    rng ((1,0).-->0) c= 1 by CARD_1:87,FUNCOP_1:19;
    then rng ((1,0).-->0) c= 2 by A14,XBOOLE_1:1;
    then rng f2 \/ rng ((1,0).-->0) c= 2 by A17,XBOOLE_1:8;
    then
A18: rng f1 c= 2 by A12,XBOOLE_1:1;
    rng ((1,1).-->1) c= {1} by FUNCOP_1:19;
    then rng ((1,1).-->1) c= 2 by A15,XBOOLE_1:1;
    then rng f1 \/ rng ((1,1).-->1) c= 2 by A18,XBOOLE_1:8;
    then rng f c= 2 by A13,XBOOLE_1:1;
    hence thesis by A10,FUNCT_2:def 1,RELSET_1:11;
  end;
end;

reserve x,y for set;

:: Properties of fields
set x = In(0,2), y = In(1,2);

Lm1: 1 in 2 & 0 in 2 by CARD_1:88,TARSKI:def 2;
then

Lm2: x = 0 & y = 1 by FUNCT_7:def 1;
set Z = 2;
reconsider A = Z as non trivial set by Lm1,REALSET1:14;
reconsider nd = x as Element of A;

Lm3: dom ((1,1).-->0) = {[1,1]} by FUNCOP_1:19;

Lm4: dom(((1,0).-->1)) = {[1,0]} by FUNCOP_1:19;

Lm5: dom ((0,1).-->1) = {[0,1]} by FUNCOP_1:19;

Lm6: add_2.(x,x) = x
proof
  [x,x] <> [1,1] by Lm2,ZFMISC_1:33;
  then
A1: not [x,x] in dom ((1,1).-->0) by Lm3,TARSKI:def 1;
  [x,x] <> [1,0] by Lm2,ZFMISC_1:33;
  then
A2: not [x,x] in dom(((1,0).-->1)) by Lm4,TARSKI:def 1;
  [x,x] <> [0,1] by Lm2,ZFMISC_1:33;
  then
A3: not [x,x] in dom ((0,1).-->1) by Lm5,TARSKI:def 1;
  thus add_2.(x,x)
  = (((0,0).-->0) +* ((0,1).-->1) +* ((1,0).-->1)).(x,x) by A1,FUNCT_4:12
    .= (((0,0).-->0) +* ((0,1).-->1)).(x,x) by A2,FUNCT_4:12
    .= (((0,0).-->0)).(x,x) by A3,FUNCT_4:12
    .= x by Lm2,FUNCOP_1:86;
end;

Lm7: add_2.(x,y) = y
proof
  [x,y] <> [1,1] by Lm2,ZFMISC_1:33;
  then
A1: not [x,y] in dom ((1,1).-->0) by Lm3,TARSKI:def 1;
  [x,y] <> [1,0] by Lm2,ZFMISC_1:33;
  then
A2: not [x,y] in dom(((1,0).-->1)) by Lm4,TARSKI:def 1;
A3: [x,y] in dom(((0,1).-->1)) by Lm2,Lm5,TARSKI:def 1;
  thus add_2.(x,y)
  = (((0,0).-->0) +* ((0,1).-->1) +* ((1,0).-->1)).(x,y) by A1,FUNCT_4:12
    .= (((0,0).-->0) +* ((0,1).-->1)).(x,y) by A2,FUNCT_4:12
    .= (((0,1).-->1)).(x,y) by A3,FUNCT_4:14
    .= y by Lm2,FUNCOP_1:86;
end;

Lm8: add_2.(y,x) = y
proof
  [y,x] <> [1,1] by Lm2,ZFMISC_1:33;
  then
A1: not [y,x] in dom ((1,1).-->0) by Lm3,TARSKI:def 1;
A2: [y,x] in dom(((1,0).-->1)) by Lm2,Lm4,TARSKI:def 1;
  thus add_2.(y,x)
  = (((0,0).-->0) +* ((0,1).-->1) +* ((1,0).-->1)).(y,x) by A1,FUNCT_4:12
    .= (((1,0).-->1)).(y,x) by A2,FUNCT_4:14
    .= y by Lm2,FUNCOP_1:86;
end;

Lm9: add_2.(y,y) = x
proof
  [y,y] in dom ((1,1).-->0) by Lm2,Lm3,TARSKI:def 1;
  hence add_2.(y,y) = (((1,1).-->0)).(y,y) by FUNCT_4:14
    .= x by Lm2,FUNCOP_1:86;
end;

Lm10: dom ((1,1).-->1) = {[1,1]} by FUNCOP_1:19;

Lm11: dom ((1,0).-->0) = {[1,0]} by FUNCOP_1:19;

Lm12: dom ((0,1).-->0) = {[0,1]} by FUNCOP_1:19;

Lm13: mult_2.(x,x) = x
proof
  [x,x] <> [1,1] by Lm2,ZFMISC_1:33;
  then
A1: not [x,x] in dom ((1,1).-->1) by Lm10,TARSKI:def 1;
  [x,x] <> [1,0] by Lm2,ZFMISC_1:33;
  then
A2: not [x,x] in dom ((1,0).-->0) by Lm11,TARSKI:def 1;
  [x,x] <> [0,1] by Lm2,ZFMISC_1:33;
  then
A3: not [x,x] in dom ((0,1).-->0) by Lm12,TARSKI:def 1;
  thus mult_2.(x,x)
  = (((0,0).-->0) +* ((0,1).-->0) +* ((1,0).-->0)).(x,x) by A1,FUNCT_4:12
    .= (((0,0).-->0) +* ((0,1).-->0)).(x,x) by A2,FUNCT_4:12
    .= (((0,0).-->0)).(x,x) by A3,FUNCT_4:12
    .= x by Lm2,FUNCOP_1:86;
end;

Lm14: mult_2.(x,y) = x
proof
  [x,y] <> [1,1] by Lm2,ZFMISC_1:33;
  then
A1: not [x,y] in dom ((1,1).-->1) by Lm10,TARSKI:def 1;
  [x,y] <> [1,0] by Lm2,ZFMISC_1:33;
  then
A2: not [x,y] in dom ((1,0).-->0) by Lm11,TARSKI:def 1;
A3: [x,y] in dom ((0,1).-->0) by Lm2,Lm12,TARSKI:def 1;
  thus mult_2.(x,y)
  = (((0,0).-->0) +* ((0,1).-->0) +* ((1,0).-->0)).(x,y) by A1,FUNCT_4:12
    .= (((0,0).-->0) +* ((0,1).-->0)).(x,y) by A2,FUNCT_4:12
    .= (((0,1).-->0)).(x,y) by A3,FUNCT_4:14
    .= x by Lm2,FUNCOP_1:86;
end;

Lm15: mult_2.(y,x) = x
proof
  [y,x] <> [1,1] by Lm2,ZFMISC_1:33;
  then
A1: not [y,x] in dom ((1,1).-->1) by Lm10,TARSKI:def 1;
A2: [y,x] in dom ((1,0).-->0) by Lm2,Lm11,TARSKI:def 1;
  thus mult_2.(y,x)
  = (((0,0).-->0) +* ((0,1).-->0) +* ((1,0).-->0)).(y,x) by A1,FUNCT_4:12
    .= (((1,0).-->0)).(y,x) by A2,FUNCT_4:14
    .= x by Lm2,FUNCOP_1:86;
end;

Lm16: mult_2.(y,y) = y
proof
  [y,y] in dom ((1,1).-->1) by Lm2,Lm10,TARSKI:def 1;
  hence mult_2.(y,y) = (((1,1).-->1)).(y,y) by FUNCT_4:14
    .= y by Lm2,FUNCOP_1:86;
end;
set om = mult_2;

Lm17: A\{x}={y} by Lm2,CARD_1:88,ZFMISC_1:23;
then

Lm18: [:A\{x},A\{x}:] = {[y,y]} by ZFMISC_1:35;

Lm19: for t being set holds t in [:A\{x},A\{x}:] implies om.t in A\{x}
proof
  let t be set;
  assume t in [:A\{x},A\{x}:];
  then t=[y,y] by Lm18,TARSKI:def 1;
  hence thesis by Lm16,Lm17,TARSKI:def 1;
end;
reconsider nm = y as Element of A\{nd} by Lm17,TARSKI:def 1;
reconsider od0=add_2 as BinOp of A;
reconsider om0=om as BinOp of A;

Lm20: for a,b,d being Element of A holds
add_2.(add_2.(a,b),d) = add_2.(a,add_2.(b,d))
proof
  let a,b,d be Element of A;
A1: a = x or a = y by Lm2,CARD_1:88,TARSKI:def 2;
A2: b = x or b = y by Lm2,CARD_1:88,TARSKI:def 2;
A3: d = x or d = y by Lm2,CARD_1:88,TARSKI:def 2;
  per cases by Lm2,CARD_1:88,TARSKI:def 2;
  suppose a = x;
    hence add_2.(add_2.(a,b),d) = add_2.(a,add_2.(b,d))
    by A2,A3,Lm6,Lm7,Lm8,Lm9;
  end;
  suppose b = x;
    hence add_2.(add_2.(a,b),d) = add_2.(a,add_2.(b,d)) by A1,A3,Lm6,Lm7,Lm8;
  end;
  suppose d = x;
    hence add_2.(add_2.(a,b),d) = add_2.(a,add_2.(b,d))
    by A1,A2,Lm6,Lm7,Lm8,Lm9;
  end;
  suppose a = y & b = y & d = y;
    hence add_2.(add_2.(a,b),d) = add_2.(a,add_2.(b,d)) by Lm7,Lm8,Lm9;
  end;
end;
reconsider dL=doubleLoopStr(#A,od0,om0,nm,nd#) as non empty doubleLoopStr;

Lm21: for a being Element of dL holds a + 0.dL = a
proof
  let a be Element of dL;
  a=x or a=y by Lm2,CARD_1:88,TARSKI:def 2;
  hence thesis by Lm6,Lm8;
end;

Lm22: for a,b,c being Element of dL holds a+b+c = a+(b+c) by Lm20;

Lm23: for a,b being Element of dL holds a+b = b+a
proof
  let a,b be Element of dL;
  (a=x & b=x) or (a=x & b=y) or (a=y & b=x) or (a=y & b=y)
  by Lm2,CARD_1:88,TARSKI:def 2;
  hence thesis by Lm7,Lm8;
end;
reconsider om1=om as DnT of nd,A by Lm19,REALSET1:def 8;

Lm24: for B being non empty set, P being BinOp of B, e being Element of B st
B = A\{nd} & e = nm & P = om1!(A,nd) holds addLoopStr(#B,P,e#) is AbGroup
proof
  let B be non empty set, P be BinOp of B, e be Element of B;
  assume
A1: B = A\{nd} & e = nm & P = om1!(A,nd);
A2: for a,b,c being Element of B holds P.(P.(a,b),c) = P.(a,P.(b,c))
  proof
    let a,b,c be Element of B;
    a = y & b = y & c = y by A1,Lm17,TARSKI:def 1;
    hence thesis by A1,Lm17,TARSKI:def 1;
  end;
A3: for a being Element of addLoopStr(#B,P,e#)
  holds a+0.addLoopStr(#B,P,e#) = a
  proof
    let a be Element of addLoopStr(#B,P,e#);
    a = y by A1,Lm17,TARSKI:def 1;
    hence thesis by A1,Lm17,TARSKI:def 1;
  end;
A4: addLoopStr(#B,P,e#) is right_complementable
  proof
    let a be Element of addLoopStr(#B,P,e#);
    take a;
    thus thesis by A1,Lm17,TARSKI:def 1;
  end;
A5: for a,b,c being Element of addLoopStr(#B,P,e#) holds a+b+c = a+(b+c)
  by A2;
  for a,b being Element of addLoopStr(#B,P,e#) holds a+b = b+a
  proof
    let a,b be Element of addLoopStr(#B,P,e#);
    a = y & b = y by A1,Lm17,TARSKI:def 1;
    hence thesis;
  end;
  hence thesis by A3,A4,A5,RLVECT_1:def 5,def 6,def 7;
end;

Lm25: for a,b,d being Element of dL holds
a*(b+d) = a*b+a*d & (b+d)*a = b*a+d*a
proof
  let a,b,d be Element of dL;
A1: (a=x & b=x & d=x) or (a=x & b=x & d=y) or
  (a=x & b=y & d=x) or (a=x & b=y & d=y) or
  (a=y & b=x & d=x) or (a=y & b=x & d=y) or
  (a=y & b=y & d=x) or (a=y & b=y & d=y) by Lm2,CARD_1:88,TARSKI:def 2;
  hence a*(b+d) = a*b+a*d by Lm6,Lm7,Lm8,Lm9,Lm13,Lm14,Lm15,Lm16;
  thus (b+d)*a = b*a+d*a by A1,Lm6,Lm7,Lm8,Lm9,Lm13,Lm14,Lm15,Lm16;
end;

definition
  func dL-Z_2 -> doubleLoopStr equals
  doubleLoopStr(#2,add_2,mult_2,In(1,2),In(0,2)#);
  coherence;
end;

registration
  cluster dL-Z_2 -> strict non empty non degenerated;
  coherence
  proof
    thus dL-Z_2 is strict;
    thus the carrier of dL-Z_2 is non empty;
    0 in 2 by CARD_1:88,TARSKI:def 2;
    then
A1: 0.dL-Z_2 = 0 by FUNCT_7:def 1;
    1 in 2 by CARD_1:88,TARSKI:def 2;
    hence 0.dL-Z_2 <> 1.dL-Z_2 by A1,FUNCT_7:def 1;
  end;
end;

registration
  cluster dL-Z_2 -> add-associative distributive;
  coherence
  proof
    thus dL-Z_2 is add-associative
    proof
      thus for a,b,c being Element of dL-Z_2 holds a+b+c = a+(b+c) by Lm20;
    end;
    thus dL-Z_2 is distributive
    proof
      let a,b,d be Element of dL-Z_2;
A1:   (a=x & b=x & d=x) or (a=x & b=x & d=y) or
      (a=x & b=y & d=x) or (a=x & b=y & d=y) or
      (a=y & b=x & d=x) or (a=y & b=x & d=y) or
      (a=y & b=y & d=x) or (a=y & b=y & d=y) by Lm2,CARD_1:88,TARSKI:def 2;
      hence a*(b+d) = a*b+a*d by Lm6,Lm7,Lm8,Lm9,Lm13,Lm14,Lm15,Lm16;
      thus (b+d)*a = b*a+d*a by A1,Lm6,Lm7,Lm8,Lm9,Lm13,Lm14,Lm15,Lm16;
    end;
  end;
end;

registration
  cluster add-associative (non trivial non empty strict doubleLoopStr);
  existence
  proof
    take dL-Z_2;
    thus thesis;
  end;
end;

registration
  cluster -> natural Element of dL-Z_2;
  coherence by CARD_1:88,TARSKI:def 2;
end;

registration
  cluster empty Element of dL-Z_2;
  existence
  proof reconsider z = 0 as Element of dL-Z_2 by CARD_1:88,TARSKI:def 2;
    take z;
    thus thesis;
  end;
  cluster non empty Element of dL-Z_2;
  existence
  proof reconsider z = 1 as Element of dL-Z_2 by CARD_1:88,TARSKI:def 2;
    take z;
    thus thesis;
  end;
end;

definition
  let L be non trivial doubleLoopStr;
  attr L is Field-like means
  :Def11:
  the multF of L is DnT of 0.L,the carrier of L &
  (for B being non empty set, P being BinOp of B, e being Element of B holds
  B = (the carrier of L)\{0.L} & e = 1.L &
  P = (the multF of L)||((the carrier of L)\{0.L})
  implies addLoopStr(#B,P,e#) is AbGroup);
end;

registration
  let A be non trivial set, od be BinOp of A, nd be Element of A,
  om be BinOp of A, nm be Element of A;
  cluster doubleLoopStr(#A,od,om,nm,nd#) -> non empty;
  coherence;
end;

registration
  cluster non trivial -> non empty doubleLoopStr;
  coherence;
end;

registration
  cluster strict Field-like Abelian distributive add-associative
    right_zeroed right_complementable (non degenerated doubleLoopStr);
  existence
  proof
    set L = doubleLoopStr(#A,od0,om0,nm,nd#);
A1: 0.L = nd;
A2: 1.L = nm;

then reconsider L as non degenerated doubleLoopStr by A1,Lm2,STRUCT_0:def 8;
    take L;
    L is right_complementable
    proof
      let a be Element of L;
      take a;
      a=x or a=y by Lm2,CARD_1:88,TARSKI:def 2;
      hence thesis by Lm6,Lm9;
    end;
    hence thesis by A2,Def11,Lm21,Lm22,Lm23,Lm24,Lm25,RLVECT_1:def 5,def 6
,def 7,VECTSP_1:def 18;
  end;
end;

registration
  cluster add-associative right_zeroed right_complementable
    Abelian commutative associative well-unital distributive
    almost_left_invertible -> Field-like (non degenerated doubleLoopStr);
  coherence
  proof
    let L be non degenerated doubleLoopStr;
    assume
A1: L is add-associative right_zeroed right_complementable
    Abelian commutative associative well-unital distributive
    almost_left_invertible;
    set B = (the carrier of L)\{0.L};
A3: for y being set st y in [:B,B:] holds (the multF of L).y in B
    proof
      let z be set;
      assume z in [:B,B:];
      then consider x,y such that
A4:   x in B & y in B and
A5:   z = [x,y] by ZFMISC_1:103;
      reconsider x,y as Element of L by A4;
      not x in {0.L} & not y in {0.L} by A4,XBOOLE_0:def 5;
      then x <> 0.L & y <> 0.L by TARSKI:def 1;
      then x*y <> 0.L by A1,VECTSP_1:44;
      then not x*y in {0.L} by TARSKI:def 1;
      hence (the multF of L).z in B by A5,XBOOLE_0:def 5;
    end;
    hence the multF of L is DnT of 0.L,the carrier of L by REALSET1:def 8;
    reconsider om = the multF of L as DnT of 0.L,the carrier of L by A3,
REALSET1:def 8;
    let B be non empty set, P be BinOp of B, e be Element of B such that
A6: B = (the carrier of L)\{0.L} and
A7: e = 1.L and
A8: P = (the multF of L)||((the carrier of L)\{0.L});
    set K = addLoopStr(#B,P,e#);
A9: K is Abelian
    proof
      let v,w be Element of K;
      reconsider a=v, b=w as Element of L by A6,XBOOLE_0:def 5;
A10:  [v,w] in [:B,B:];
A11:  [w,v] in [:B,B:];
      thus v + w = a*b by A6,A8,A10,FUNCT_1:72
        .= b*a by A1,GROUP_1:def 16
        .= w + v by A6,A8,A11,FUNCT_1:72;
    end;
A12: K is add-associative
    proof
      let u,v,w be Element of K;
      reconsider a=u, b=v, c =w as Element of L by A6,XBOOLE_0:def 5;
A13:  [u,v] in [:B,B:];
      then P.(u,v) in B by FUNCT_2:7;
      then
A14:  [(om||B).(u,v),w] in [:B,B:] by A6,A8,ZFMISC_1:106;
A15:  [v,w] in [:B,B:];
      then P.(v,w) in B by FUNCT_2:7;
      then
A16:  [u,(om||B).(v,w)] in [:B,B:] by A6,A8,ZFMISC_1:106;
      thus (u + v) + w = om.((om||B).(u,v),w) by A6,A8,A14,FUNCT_1:72
        .= (a*b)*c by A13,FUNCT_1:72
        .= a*(b*c) by A1,GROUP_1:def 4
        .= om.(u,(om||B).(v,w)) by A15,FUNCT_1:72
        .= u + (v + w) by A6,A8,A16,FUNCT_1:72;
    end;
A17: K is right_zeroed
    proof
      let v be Element of K;
      reconsider a=v as Element of L by A6,XBOOLE_0:def 5;
      [v,0.K] in [:B,B:];
      hence v + 0.K = a*1.L by A6,A7,A8,FUNCT_1:72
        .= v by A1,VECTSP_1:def 16;
    end;
    K is right_complementable
    proof
      let v be Element of K;
      reconsider a=v as Element of L by A6,XBOOLE_0:def 5;
      not a in {0.L} by A6,XBOOLE_0:def 5;
      then a <> 0.L by TARSKI:def 1;
      then consider b being Element of L such that
A18:  b*a = 1.L by A1,VECTSP_1:def 20;
A19:  a*b = 1.L by A1,A18,GROUP_1:def 16;
      then b <> 0.L by A1,VECTSP_1:36;
      then not b in {0.L} by TARSKI:def 1;
      then reconsider w=b as Element of K by A6,XBOOLE_0:def 5;
      take w;
      [v,w] in [:B,B:];
      hence v + w = 0.K by A6,A7,A8,A19,FUNCT_1:72;
    end;
    hence addLoopStr(#B,P,e#) is AbGroup by A9,A12,A17;
  end;
end;

Lm26: for F being non degenerated doubleLoopStr holds
1.F is Element of (the carrier of F)\{0.F}
proof
  let F be non degenerated doubleLoopStr;
  not 1.F in {0.F} by TARSKI:def 1;
  hence 1.F is Element of (the carrier of F)\{0.F} by XBOOLE_0:def 5;
end;
deffunc suppf1(Field-like Abelian distributive add-associative
right_zeroed right_complementable (non degenerated doubleLoopStr))
= the carrier of $1;

definition
  let F be Field-like Abelian distributive add-associative
  right_zeroed right_complementable (non degenerated doubleLoopStr);
  canceled 3;
  func omf(F) -> DnT of 0.F,the carrier of F equals

  the multF of F;
  coherence by Def11;
end;

theorem
  for F being Field holds the addLoopStr of F is AbGroup
proof
  let F be Field;
  set L = the addLoopStr of F;
A1: L is Abelian
  proof
    let v,w be Element of L;
    reconsider a=v, b=w as Element of F;
    thus v + w = a + b
      .= b + a
      .= w + v;
  end;
A2: L is add-associative
  proof
    let u,v,w being Element of L;
    reconsider a=u, b=v, c = w as Element of F;
    thus (u + v) + w = (a + b) + c
      .= a + (b + c) by RLVECT_1:def 6
      .= u + (v + w);
  end;
A3: L is right_zeroed
  proof
    let v be Element of L;
    reconsider a=v as Element of F;
    thus v + 0.L = a + 0.F
      .= v by RLVECT_1:def 7;
  end;
  L is right_complementable
  proof
    let v be Element of L;
    reconsider a=v as Element of F;
    consider b being Element of F such that
A4: a + b = 0.F by ALGSTR_0:def 11;
    reconsider w=b as Element of L;
    take w;
    thus v + w = 0.L by A4;
  end;
  hence thesis by A1,A2,A3;
end;

canceled 4;

theorem
  for F being Field, a being Element of F holds
  a+0.F = a & 0.F+a = a by RLVECT_1:def 15;

theorem Th7:
  for F being AbGroup, a being Element of F ex b being Element of F st
  a+b = 0.F & b+a = 0.F :::by ALGSTR_0:def 16;  ::: !!!
proof
  let F be AbGroup, a be Element of F;
  consider b being Element of F such that
A1: a+b = 0.F by ALGSTR_0:def 11;
  take b;
  thus a+b = 0.F by A1;
  thus b+a = 0.F by A1;
end;

theorem Th8:
  for F being Field-like Abelian distributive add-associative
  right_zeroed right_complementable (non degenerated doubleLoopStr),
  a,b,c being Element of (the carrier of F)\{0.F} holds (a*b)*c = a*(b*c)
proof
  let F be Field-like Abelian distributive add-associative
  right_zeroed right_complementable (non degenerated doubleLoopStr),
  a,b,c be Element of suppf1(F)\{0.F};
  set B = suppf1(F)\{0.F};
  set P = omf(F)!(suppf1(F),0.F);
  reconsider e = 1.F as Element of B by Lm26;
  reconsider D = addLoopStr(#B,P,e#) as strict AbGroup by Def11;
  reconsider a,b,c as Element of D;
A1: omf(F)||(suppf1(F)\{0.F})
  is Function of [:suppf1(F)\{0.F},suppf1(F)\{0.F}:],
  (suppf1(F)\{0.F}) by REALSET1:11;
  then
A2: dom(omf(F)||(suppf1(F)\{0.F})) =
  [:suppf1(F)\{0.F},suppf1(F)\{0.F}:] by FUNCT_2:def 1;
A3: for s,t being Element of (suppf1(F)\{0.F}) holds
  (the addF of D).(s,t) is Element of (suppf1(F)\{0.F}) &
  omf(F).(s,t) is Element of (suppf1(F)\{0.F})
  proof
    let s,t be Element of (suppf1(F)\{0.F});
A4: [s,t] in [:suppf1(F)\{0.F},suppf1(F)\{0.F}:];
    consider W being Function of [:suppf1(F)\{0.F},suppf1(F)\{0.F}:],
    (suppf1(F)\{0.F}) such that
A5: W = omf(F)||(suppf1(F)\{0.F}) by A1;
    W.(s,t) is Element of (suppf1(F)\{0.F});
    hence thesis by A2,A4,A5,FUNCT_1:70;
  end;
A6: for x,y being Element of suppf1(F)\{0.F} holds
  omf(F).(x,y) = (the addF of D).(x,y)
  proof
    let x,y be Element of suppf1(F)\{0.F};
    [x,y] in [:suppf1(F)\{0.F},suppf1(F)\{0.F}:];
    hence thesis by A2,FUNCT_1:70;
  end;
A7: for x,y,z being Element of suppf1(F)\{0.F} holds
  omf(F).((the addF of D).(x,y),z)
  = (the addF of D).((the addF of D).(x,y),z) &
  (the addF of D).(x,omf(F).(y,z)) = omf(F).(x,omf(F).(y,z))
  proof
    let x,y,z be Element of suppf1(F)\{0.F};
A8: (the addF of D).(x,y) is Element of suppf1(F)\{0.F} by A3;
    omf(F).(y,z) is Element of suppf1(F)\{0.F} by A3;
    hence thesis by A6,A8;
  end;
  reconsider x=a, y=b, z=c as Element of F;
  (x*y)*z = omf(F).((the addF of D).(a,b),c) by A6
    .= a+b+c by A7
    .= a+(b+c) by RLVECT_1:def 6
    .= (the addF of D).(a,omf(F).(b,c)) by A6
    .= x*(y*z) by A7;
  hence thesis;
end;

theorem Th9:
  for F being Field-like Abelian distributive add-associative
  right_zeroed right_complementable (non degenerated doubleLoopStr),
  a,b being Element of (the carrier of F)\{0.F} holds a*b = b*a
proof
  let F be Field-like Abelian distributive add-associative
  right_zeroed right_complementable (non degenerated doubleLoopStr),
  a,b be Element of suppf1(F)\{0.F};
  set B = suppf1(F)\{0.F};
  set P = omf(F)!(suppf1(F),0.F);
  reconsider e = 1.F as Element of B by Lm26;
  reconsider D = addLoopStr(#B,P,e#) as strict AbGroup by Def11;
  reconsider a,b as Element of D;
  omf(F)||(suppf1(F)\{0.F})
  is Function of [:suppf1(F)\{0.F},suppf1(F)\{0.F}:],
  (suppf1(F)\{0.F}) by REALSET1:11;
  then
A1: dom(omf(F)||(suppf1(F)\{0.F})) =
  [:suppf1(F)\{0.F},suppf1(F)\{0.F}:] by FUNCT_2:def 1;
A2: for x,y being Element of suppf1(F)\{0.F} holds
  omf(F).(x,y) = (the addF of D).(x,y)
  proof
    let x,y be Element of suppf1(F)\{0.F};
    [x,y] in [:suppf1(F)\{0.F},suppf1(F)\{0.F}:];
    hence thesis by A1,FUNCT_1:70;
  end;
  reconsider x = a, y = b as Element of F;
  x*y = a+b by A2
    .= b+a
    .= y*x by A2;
  hence thesis;
end;

theorem Th10:
  for F being Field-like Abelian distributive add-associative
  right_zeroed right_complementable (non degenerated doubleLoopStr),
  a being Element of (the carrier of F)\{0.F} holds a*1.F = a & 1.F*a = a
proof
  let F be Field-like Abelian distributive add-associative
  right_zeroed right_complementable (non degenerated doubleLoopStr),
  a be Element of suppf1(F)\{0.F};
  set B = suppf1(F)\{0.F};
  set P = omf(F)!(suppf1(F),0.F);
  reconsider e = 1.F as Element of B by Lm26;
  reconsider D = addLoopStr(#B,P,e#) as strict AbGroup by Def11;
  reconsider a as Element of D;
  omf(F)||(suppf1(F)\{0.F})
  is Function of [:suppf1(F)\{0.F},suppf1(F)\{0.F}:],
  (suppf1(F)\{0.F}) by REALSET1:11;
  then
A1: dom(omf(F)||(suppf1(F)\{0.F})) =
  [:suppf1(F)\{0.F},suppf1(F)\{0.F}:] by FUNCT_2:def 1;
A2: for x,y being Element of suppf1(F)\{0.F} holds
  omf(F).(x,y) = (the addF of D).(x,y)
  proof
    let x,y be Element of suppf1(F)\{0.F};
    [x,y] in [:suppf1(F)\{0.F},suppf1(F)\{0.F}:];
    hence thesis by A1,FUNCT_1:70;
  end;
  then
A3: omf(F).(a,1.F) = a + 0.D
    .= a by RLVECT_1:def 7;
  omf(F).(1.F,a) = 0.D + a by A2
    .= a by RLVECT_1:def 15;
  hence thesis by A3;
end;

theorem Th11:
  for F being Field-like Abelian distributive add-associative
  right_zeroed right_complementable (non degenerated doubleLoopStr),
  a being Element of (the carrier of F)\{0.F}
  ex b being Element of (the carrier of F)\{0.F} st a*b = 1.F & b*a = 1.F
proof
  let F be Field-like Abelian distributive add-associative
  right_zeroed right_complementable (non degenerated doubleLoopStr),
  a be Element of suppf1(F)\{0.F};
  set B = suppf1(F)\{0.F};
  set P = omf(F)!(suppf1(F),0.F);
  reconsider e = 1.F as Element of B by Lm26;
  addLoopStr(#B,P,e#) is AbGroup by Def11;
  then consider D being strict AbGroup such that
A1: D = addLoopStr(#B,P,e#);
  reconsider a as Element of D by A1;
  consider b being Element of D such that
A2: a+b = 0.D & b+a = 0.D by Th7;
  omf(F)||(suppf1(F)\{0.F})
  is Function of [:suppf1(F)\{0.F},suppf1(F)\{0.F}:],
  (suppf1(F)\{0.F}) by REALSET1:11;
  then
A3: dom(omf(F)||(suppf1(F)\{0.F})) =
  [:suppf1(F)\{0.F},suppf1(F)\{0.F}:] by FUNCT_2:def 1;
A4: for x,y being Element of suppf1(F)\{0.F} holds
  omf(F).(x,y) = (the addF of D).(x,y)
  proof
    let x,y be Element of suppf1(F)\{0.F};
    [x,y] in [:suppf1(F)\{0.F},suppf1(F)\{0.F}:];
    hence thesis by A1,A3,FUNCT_1:70;
  end;
  reconsider b as Element of suppf1(F)\{0.F} by A1;
  take b;
  thus thesis by A1,A2,A4;
end;

theorem
  for F being Field, x,y being Element of F holds
  x+y = 0.F implies y = (comp F).x
proof
  let F be Field, x,y be Element of F;
  assume x+y = 0.F;
  then y = -x by RLVECT_1:19;
  hence thesis by VECTSP_1:def 25;
end;

theorem
  for F being Field, x being Element of F holds x = (comp F).((comp F).x)
proof
  let F be Field, x be Element of F;
  thus x = --x by RLVECT_1:30
    .= (comp F).-x by VECTSP_1:def 25
    .= (comp F).((comp F).x) by VECTSP_1:def 25;
end;

theorem
  for F being Field, a,b being Element of (the carrier of F)holds
  (the addF of F).(a,b) is Element of (the carrier of F)&
  omf(F).(a,b) is Element of (the carrier of F)&
  (comp F).a is Element of the carrier of F;

theorem
  for F being Field, a,b,c being Element of F holds
  a*(b-c) = a*b-a*c by VECTSP_1:43;

theorem
  for F being Field, a,b,c being Element of F holds
  (a-b)*c = a*c-b*c by VECTSP_1:45;

theorem
  for F being Field, a being Element of F holds a*0.F = 0.F by VECTSP_1:36;

theorem
  for F being Field, a being Element of F holds 0.F*a = 0.F by VECTSP_1:39;

theorem
  for F being Field, a,b being Element of F holds
  -(a*b) = a*-b by VECTSP_1:40;

theorem
  for F being Field holds 1.F*0.F = 0.F by VECTSP_1:36;

theorem
  for F being Field holds 0.F*1.F = 0.F by VECTSP_1:39;

theorem
  for F being Field, a,b being Element of (the carrier of F)holds
  omf(F).(a,b) is Element of the carrier of F;

theorem Th23:
  for F being Field-like Abelian distributive add-associative
  right_zeroed right_complementable (non degenerated doubleLoopStr),
  a,b,c being Element of F holds (a*b)*c = a*(b*c)
proof
  let F be Field-like Abelian distributive add-associative
  right_zeroed right_complementable (non degenerated doubleLoopStr),
  a,b,c be Element of suppf1(F);
A1: a = 0.F or b = 0.F or c = 0.F or (a is Element of suppf1(F)\{0.F} &
  b is Element of suppf1(F)\{0.F} &
  c is Element of suppf1(F)\{0.F}) by ZFMISC_1:64;
A2: a = 0.F implies (a*b)*c = a*(b*c)
  proof
    assume
A3: a = 0.F;
    hence (a*b)*c = 0.F*c by VECTSP_1:39
      .= 0.F by VECTSP_1:39
      .= a*(b*c) by A3,VECTSP_1:39;
  end;
A4: b = 0.F implies (a*b)*c = a*(b*c)
  proof
    assume
A5: b = 0.F;
    hence (a*b)*c = 0.F*c by VECTSP_1:36
      .= 0.F by VECTSP_1:39
      .= a*0.F by VECTSP_1:36
      .= a*(b*c) by A5,VECTSP_1:39;
  end;
  c = 0.F implies (a*b)*c = a*(b*c)
  proof
    assume
A6: c = 0.F;
    hence (a*b)*c = 0.F by VECTSP_1:36
      .= a*0.F by VECTSP_1:36
      .= a*(b*c) by A6,VECTSP_1:36;
  end;
  hence thesis by A1,A2,A4,Th8;
end;

theorem Th24:
  for F being Field-like Abelian distributive add-associative
  right_zeroed right_complementable (non degenerated doubleLoopStr),
  a,b being Element of F holds a*b = b*a
proof
  let F be Field-like Abelian distributive add-associative
  right_zeroed right_complementable (non degenerated doubleLoopStr),
  a,b be Element of suppf1(F);
A1: a = 0.F or b = 0.F or (a is Element of suppf1(F)\{0.F} &
  b is Element of suppf1(F)\{0.F}) by ZFMISC_1:64;
A2: a = 0.F implies a*b = b*a
  proof
    assume
A3: a = 0.F;
    then a*b = 0.F by VECTSP_1:39
      .= b*a by A3,VECTSP_1:36;
    hence thesis;
  end;
  b = 0.F implies a*b = b*a
  proof
    assume
A4: b = 0.F;
    then a*b = 0.F by VECTSP_1:36
      .= b*a by A4,VECTSP_1:39;
    hence thesis;
  end;
  hence thesis by A1,A2,Th9;
end;

theorem Th25:
  for F being Field-like Abelian distributive add-associative
  right_zeroed right_complementable (non degenerated doubleLoopStr),
  a being Element of F holds a*1.F = a & 1.F*a = a
proof
  let F be Field-like Abelian distributive add-associative
  right_zeroed right_complementable (non degenerated doubleLoopStr),
  a be Element of suppf1(F);
  per cases by ZFMISC_1:64;
  suppose
A1: a = 0.F;
    hence a*1.F = a by VECTSP_1:39;
    thus 1.F*a = a by A1,VECTSP_1:36;
  end;
  suppose a is Element of suppf1(F)\{0.F};
    hence thesis by Th10;
  end;
end;

definition
  let F be Field;
  canceled 2;
  func revf(F) -> UnOp of (the carrier of F)\{0.F} means
  :Def18:
  for x being Element of (the carrier of F)\{0.F} holds omf(F).(x,it.x) = 1.F;
  existence
  proof
    defpred Z[set,set] means omf(F).($1,$2) = 1.F;
A1: for x being set st x in suppf1(F)\{0.F} ex y being set st
    y in suppf1(F)\{0.F} & Z[x,y]
    proof
      let x be set;
      assume x in suppf1(F)\{0.F};
      then reconsider x as Element of suppf1(F)\{0.F};
      consider y being Element of suppf1(F)\{0.F} such that
A2:   x*y = 1.F & y*x = 1.F by Th11;
      reconsider y as set;
      take y;
      thus thesis by A2;
    end;
    ex C being Function of suppf1(F)\{0.F},suppf1(F)\{0.F} st
    for x being set st x in suppf1(F)\{0.F} holds Z[x,C.x] from FUNCT_2:sch 1
    (A1);
    then consider C being Function of suppf1(F)\{0.F},suppf1(F)\{0.F}
    such that
A3: for x being set st x in suppf1(F)\{0.F} holds omf(F).(x,C.x) = 1.F;
    take C;
    thus thesis by A3;
  end;
  uniqueness
  proof
    let C1,C2 be Function of suppf1(F)\{0.F},suppf1(F)\{0.F} such that
A4: for x being Element of suppf1(F)\{0.F} holds omf(F).(x,C1.x) = 1.F and
A5: for x being Element of suppf1(F)\{0.F} holds omf(F).(x,C2.x) = 1.F;
    for x being set st x in suppf1(F)\{0.F} holds C1.x = C2.x
    proof
      let x be set;
      assume
A6:   x in suppf1(F)\{0.F};
      then
A7:   C1.x is Element of suppf1(F)\{0.F} by FUNCT_2:7;
      then reconsider a=x, C1a = C1.x as Element of F by A6;
A8:   C2.x is Element of suppf1(F)\{0.F} by A6,FUNCT_2:7;
      then reconsider C2a = C2.x as Element of F;
      C1.x = (C1a)*1.F by A7,Th10
        .= C1a*(a*C2a) by A5,A6
        .= (a*C1a)*C2a by A6,A7,A8,Th8
        .= 1.F*(C2a) by A4,A6
        .= C2.x by A8,Th10;
      hence thesis;
    end;
    hence thesis by FUNCT_2:18;
  end;
end;

theorem
  for F being Field, x,y being Element of (the carrier of F)\{0.F} holds
  x*y = 1.F implies y = revf(F).x
proof
  let F be Field, x,y be Element of suppf1(F)\{0.F};
  assume
A1: x*y = 1.F;
  reconsider rx = revf(F).x as Element of F by XBOOLE_0:def 5;
  y = y*1.F by Th10
    .= omf(F).(y,1.F)
    .= y*(x*rx) by Def18
    .= 1.F*rx by A1,Th8
    .= revf(F).x by Th10;
  hence thesis;
end;

theorem
  for F being Field, x being Element of (the carrier of F)\{0.F} holds
  x =revf(F).(revf(F).x)
proof
  let F be Field, x be Element of suppf1(F)\{0.F};
  reconsider rx = revf(F).x as Element of F by XBOOLE_0:def 5;
  reconsider rrx = revf(F).(revf(F).x) as Element of F by XBOOLE_0:def 5;
  x =x*1.F by Th10
    .= omf(F).(x,1.F)
    .= x*(rx*rrx) by Def18
    .= x*rx*rrx by Th8
    .= omf(F).(1.F,revf(F).(revf(F).x)) by Def18
    .= 1.F*rrx
    .= revf(F).(revf(F).x) by Th10;
  hence thesis;
end;

theorem
  for F being Field, a,b being Element of (the carrier of F)\{0.F} holds
  omf(F).(a,b) is Element of (the carrier of F)\{0.F} &
  revf(F).a is Element of (the carrier of F)\{0.F}
proof
  let F be Field, a,b be Element of suppf1(F)\{0.F};
  [a,b] in [:suppf1(F)\{0.F},suppf1(F)\{0.F}:];
  hence thesis by REALSET1:def 8;
end;

theorem
  for F being Field, a,b,c being Element of F holds
  a+b = a+c implies b = c by RLVECT_1:21;

theorem
  for F being Field, a being Element of (the carrier of F)\{0.F},
  b,c being Element of (the carrier of F)holds a*b = a*c implies b = c
proof
  let F be Field, a be Element of suppf1(F)\{0.F},
  b,c be Element of suppf1(F);
  reconsider x=a as Element of F;
  assume
A1: a*b = a*c;
  reconsider ra = revf(F).a as Element of F by XBOOLE_0:def 5;
  b = 1.F*b by Th25
    .= omf(F).(1.F,b)
    .= (x*ra)*b by Def18
    .= ra*(x*c) by A1,Th23
    .= (x*ra)*c by Th23
    .= omf(F).(1.F,c) by Def18
    .= 1.F*c
    .= c by Th25;
  hence thesis;
end;

registration
  cluster Field-like Abelian distributive add-associative
    right_zeroed right_complementable -> commutative associative well-unital
    almost_left_invertible (non degenerated doubleLoopStr);
  coherence
  proof
    let L be non degenerated doubleLoopStr;
    assume
A1: L is Field-like Abelian distributive add-associative
    right_zeroed right_complementable;
    thus L is commutative
    proof
      thus for x,y being Element of L holds x*y = y*x by A1,Th24;
    end;
    thus L is associative
    proof
      thus for x,y,z being Element of L holds (x*y)*z = x*(y*z) by A1,Th23;
    end;
    thus L is well-unital
    proof
      thus for x being Element of L holds x * 1.L = x & 1.L * x = x by A1,Th25;
    end;
    let x being Element of L;
    assume x <> 0.L;
    then not x in {0.L} by TARSKI:def 1;
    then reconsider x as Element of (the carrier of L)\{0.L} by XBOOLE_0:def 5;
    consider y being Element of (the carrier of L)\{0.L} such that
A2: x*y = 1.L & y*x = 1.L by A1,Th11;
    take y;
    thus thesis by A2;
  end;
end;

theorem
  for F being non degenerated doubleLoopStr holds
  1.F is Element of (the carrier of F)\{0.F} by Lm26;

