:: Properties of Fields
::  by J\'ozef Bia{\l}as
::
:: Received June 20, 1990
:: Copyright (c) 1990 Association of Mizar Users

environ

 vocabularies BOOLE, REALSET1, FUNCT_1, RELAT_1, BINOP_1, RLVECT_1, QC_LANG1,
      VECTSP_1, REALSET2, NAT_1, FUNCOP_1, FUNCT_4, CAT_1, FUNCT_7, GROUP_1,
      LATTICES, ORDINAL2, XREAL_0, ARYTM_1, ALGSTR_2, MOD_1, VECTSP_2,
      STRUCT_0;
 notations TARSKI, XBOOLE_0, ENUMSET1, ZFMISC_1, SUBSET_1, DOMAIN_1, RELAT_1,
      FUNCT_1, REALSET1, FUNCOP_1, FUNCT_2, BINOP_1, FUNCT_4, FUNCT_7,
      ORDINAL1, XCMPLX_0, STRUCT_0, RLVECT_1, GROUP_1, VECTSP_1;
 constructors BINOP_1, FUNCT_4, XCMPLX_0, REALSET1, FUNCT_7, VECTSP_1;
 registrations XBOOLE_0, SUBSET_1, RELSET_1, ARYTM_3, XCMPLX_0, REALSET1,
      STRUCT_0, RLVECT_1, GROUP_1, VECTSP_1;
 requirements SUBSET, BOOLE, NUMERALS;
 definitions RLVECT_1, TARSKI, REALSET1, BINOP_1, STRUCT_0, FUNCOP_1, VECTSP_1,
      GROUP_1;
 theorems TARSKI, FUNCT_1, FUNCT_2, ZFMISC_1, ENUMSET1, REALSET1, VECTSP_1,
      RELSET_1, XBOOLE_0, RLVECT_1, FUNCT_4, FUNCOP_1, CARD_1, XBOOLE_1,
      FUNCT_7, STRUCT_0, GROUP_1;
 schemes FUNCT_2;

begin

definition
  canceled 7;
 func add_2 -> BinOp of 2 equals
  ((0,0) .--> 0) +* ((0,1).-->1) +* ((1,0).-->1) +* ((1,1).-->0);
 coherence
  proof
    set f2 = ((0,0).-->0) +* ((0,1).-->1),
        f1 = f2 +* ((1,0).-->1),
        f = f1 +*((1,1).-->0);
A1:  dom f = dom f1 \/ dom((1,1).-->0) by FUNCT_4:def 1
         .= dom f1 \/ {[1,1]} by FUNCOP_1:19
         .= dom f2 \/ dom((1,0).-->1) \/ {[1,1]} by FUNCT_4:def 1
         .= dom f2 \/ {[1,0]} \/ {[1,1]} by FUNCOP_1:19
         .= dom((0,0) .--> 0) \/ dom ((0,1).-->1) \/ {[1,0]} \/ {[1,1]}
                   by FUNCT_4:def 1
         .= dom((0,0) .--> 0) \/ {[0,1]} \/ {[1,0]} \/ {[1,1]} by FUNCOP_1:19
         .= {[0,0]} \/ {[0,1]} \/ {[1,0]} \/ {[1,1]} by FUNCOP_1:19
         .= {[0,0],[0,1]} \/ {[1,0]} \/ {[1,1]} by ENUMSET1:41
         .= {[0,0],[0,1],[1,0]} \/ {[1,1]} by ENUMSET1:43
         .= {[0,0],[0,1],[1,0],[1,1]} by ENUMSET1:46
         .= [:2,2:] by ZFMISC_1:146,CARD_1:88;
A2:  rng f2 c= rng ((0,0).-->0) \/ rng ((0,1).-->1) by FUNCT_4:18;
A3:  rng f1 c= rng f2 \/ rng ((1,0).-->1) by FUNCT_4:18;
A4:  rng f c= rng f1 \/ rng ((1,1).-->0) by FUNCT_4:18;
A5:  1 c= 2 by ZFMISC_1:12,CARD_1:87,88;
A6:  {1} c= 2 by ZFMISC_1:12,CARD_1:88;
    rng ((0,1).-->1) c= {1} by FUNCOP_1:19;
    then
A7:  rng ((0,1).-->1) c= 2 by A6,XBOOLE_1:1;
    rng ((0,0).-->0) c= 1 by CARD_1:87,FUNCOP_1:19;
    then rng ((0,0).-->0) c= 2 by A5,XBOOLE_1:1;
    then rng ((0,0).-->0) \/ rng ((0,1).-->1) c= 2 by A7,XBOOLE_1:8;
    then
A8:  rng f2 c= 2 by A2,XBOOLE_1:1;
    rng ((1,0).-->1) c= {1} by FUNCOP_1:19;
    then rng ((1,0).-->1) c= 2 by A6,XBOOLE_1:1;
    then rng f2 \/ rng ((1,0).-->1) c= 2 by A8,XBOOLE_1:8;
    then
A9:   rng f1 c= 2 by A3,XBOOLE_1:1;
    rng ((1,1).-->0) c= 1 by FUNCOP_1:19,CARD_1:87;
    then rng ((1,1).-->0) c= 2 by A5,XBOOLE_1:1;
    then rng f1 \/ rng ((1,1).-->0) c= 2 by A9,XBOOLE_1:8;
    then rng f c= 2 by A4,XBOOLE_1:1;
   hence thesis by A1,RELSET_1:11,FUNCT_2:def 1;
  end;
 func mult_2 -> BinOp of 2 equals
  ((0,0).-->0) +* ((0,1).-->0) +* ((1,0).-->0) +* ((1,1).-->1);
 coherence
  proof
    set f2 = ((0,0).-->0) +* ((0,1).-->0),
        f1 = f2 +* ((1,0).-->0),
        f = f1 +* ((1,1).-->1);
A10:  dom f = dom f1 \/ dom ((1,1).-->1) by FUNCT_4:def 1
         .= dom f1 \/ {[1,1]} by FUNCOP_1:19
         .= dom f2 \/ dom ((1,0).-->0) \/ {[1,1]} by FUNCT_4:def 1
         .= dom f2 \/ {[1,0]} \/ {[1,1]} by FUNCOP_1:19
         .= dom(((0,0).-->0)) \/ dom ((0,1).-->0) \/ {[1,0]} \/ {[1,1]}
                   by FUNCT_4:def 1
         .= dom(((0,0).-->0)) \/ {[0,1]} \/ {[1,0]} \/ {[1,1]} by FUNCOP_1:19
         .= {[0,0]} \/ {[0,1]} \/ {[1,0]} \/ {[1,1]} by FUNCOP_1:19
         .= {[0,0],[0,1]} \/ {[1,0]} \/ {[1,1]} by ENUMSET1:41
         .= {[0,0],[0,1],[1,0]} \/ {[1,1]} by ENUMSET1:43
         .= {[0,0],[0,1],[1,0],[1,1]} by ENUMSET1:46
         .= [:2,2:] by ZFMISC_1:146,CARD_1:88;
A11:  rng f2 c= rng ((0,0).-->0) \/ rng ((0,1).-->0) by FUNCT_4:18;
A12:  rng f1 c= rng f2 \/ rng ((1,0).-->0) by FUNCT_4:18;
A13:  rng f c= rng f1 \/ rng ((1,1).-->1) by FUNCT_4:18;
A14:  1 c= 2 by ZFMISC_1:12,CARD_1:87,88;
A15:  {1} c= 2 by ZFMISC_1:12,CARD_1:88;
    rng ((0,1).-->0) c= 1 by FUNCOP_1:19, CARD_1:87;
    then
A16:  rng ((0,1).-->0) c= 2 by A14,XBOOLE_1:1;
    rng ((0,0).-->0) c= 1 by CARD_1:87,FUNCOP_1:19;
    then rng ((0,0).-->0) c= 2 by A14,XBOOLE_1:1;
    then rng ((0,0).-->0) \/ rng ((0,1).-->0) c= 2 by A16,XBOOLE_1:8;
    then
A17:  rng f2 c= 2 by A11,XBOOLE_1:1;
    rng ((1,0).-->0) c= 1 by CARD_1:87,FUNCOP_1:19;
    then rng ((1,0).-->0) c= 2 by A14,XBOOLE_1:1;
    then rng f2 \/ rng ((1,0).-->0) c= 2 by A17,XBOOLE_1:8;
    then
A18:   rng f1 c= 2 by A12,XBOOLE_1:1;
    rng ((1,1).-->1) c= {1} by FUNCOP_1:19;
    then rng ((1,1).-->1) c= 2 by A15,XBOOLE_1:1;
    then rng f1 \/ rng ((1,1).-->1) c= 2 by A18,XBOOLE_1:8;
    then rng f c= 2 by A13,XBOOLE_1:1;
   hence thesis by A10,RELSET_1:11,FUNCT_2:def 1;
  end;
end;

reserve x,y for set;

:: Properties of fields

 set x = In(0,2), y = In(1,2);
Lm1: 1 in 2 & 0 in 2 by CARD_1:88,TARSKI:def 2;
 then
Lm2: x = 0 & y = 1 by FUNCT_7:def 1;
 set Z = 2;
     reconsider A = Z as non trivial set by REALSET1:14,Lm1;
     reconsider nd = x as Element of A;
     set x1=[[x,x],x], x2=[[x,y],y], x3=[[y,x],y], x4=[[y,y],x];
     set od = add_2;

Lm3: dom ((1,1).-->0) = {[1,1]} by FUNCOP_1:19;
Lm4: dom(((1,0).-->1)) = {[1,0]} by FUNCOP_1:19;
Lm5: dom ((0,1).-->1) = {[0,1]} by FUNCOP_1:19;

Lm6: add_2.(x,x) = x
 proof
  [x,x] <> [1,1] by Lm2, ZFMISC_1:33;
  then
A1: not [x,x] in dom ((1,1).-->0) by Lm3, TARSKI:def 1;
  [x,x] <> [1,0] by Lm2, ZFMISC_1:33;
  then
A2: not [x,x] in dom(((1,0).-->1)) by Lm4, TARSKI:def 1;
  [x,x] <> [0,1] by Lm2, ZFMISC_1:33;
  then
A3: not [x,x] in dom ((0,1).-->1) by Lm5, TARSKI:def 1;
  thus add_2.(x,x)
     = (((0,0).-->0) +* ((0,1).-->1) +* ((1,0).-->1)).(x,x) by A1,FUNCT_4:12
    .= (((0,0).-->0) +* ((0,1).-->1)).(x,x) by A2,FUNCT_4:12
    .= (((0,0).-->0)).(x,x) by A3,FUNCT_4:12
    .= x by FUNCOP_1:86,Lm2;
 end;

Lm7: add_2.(x,y) = y
 proof
  [x,y] <> [1,1] by Lm2, ZFMISC_1:33;
  then
A1: not [x,y] in dom ((1,1).-->0) by Lm3, TARSKI:def 1;
  [x,y] <> [1,0] by Lm2, ZFMISC_1:33;
  then
A2: not [x,y] in dom(((1,0).-->1)) by Lm4, TARSKI:def 1;
A3: [x,y] in dom(((0,1).-->1)) by Lm5, TARSKI:def 1, Lm2;
  thus add_2.(x,y)
     = (((0,0).-->0) +* ((0,1).-->1) +* ((1,0).-->1)).(x,y) by A1,FUNCT_4:12
    .= (((0,0).-->0) +* ((0,1).-->1)).(x,y) by A2,FUNCT_4:12
    .= (((0,1).-->1)).(x,y) by A3,FUNCT_4:14
    .= y by FUNCOP_1:86,Lm2;
 end;

Lm8: add_2.(y,x) = y
 proof
  [y,x] <> [1,1] by Lm2, ZFMISC_1:33;
  then
A1: not [y,x] in dom ((1,1).-->0) by Lm3, TARSKI:def 1;
A2: [y,x] in dom(((1,0).-->1)) by Lm4, TARSKI:def 1, Lm2;
  thus add_2.(y,x)
     = (((0,0).-->0) +* ((0,1).-->1) +* ((1,0).-->1)).(y,x) by A1,FUNCT_4:12
    .= (((1,0).-->1)).(y,x) by A2,FUNCT_4:14
    .= y by FUNCOP_1:86,Lm2;
 end;

Lm9: add_2.(y,y) = x
 proof
A1: [y,y] in dom ((1,1).-->0) by Lm3, TARSKI:def 1,Lm2;
  thus add_2.(y,y)
     = (((1,1).-->0)).(y,y) by A1,FUNCT_4:14
    .= x by FUNCOP_1:86,Lm2;
 end;

Lm10: dom ((1,1).-->1) = {[1,1]} by FUNCOP_1:19;
Lm11: dom ((1,0).-->0) = {[1,0]} by FUNCOP_1:19;
Lm12: dom ((0,1).-->0) = {[0,1]} by FUNCOP_1:19;

Lm13: mult_2.(x,x) = x
 proof
  [x,x] <> [1,1] by Lm2, ZFMISC_1:33;
  then
A1: not [x,x] in dom ((1,1).-->1) by Lm10, TARSKI:def 1;
  [x,x] <> [1,0] by Lm2, ZFMISC_1:33;
  then
A2: not [x,x] in dom ((1,0).-->0) by Lm11, TARSKI:def 1;
  [x,x] <> [0,1] by Lm2, ZFMISC_1:33;
  then
A3: not [x,x] in dom ((0,1).-->0) by Lm12, TARSKI:def 1;
  thus mult_2.(x,x)
     = (((0,0).-->0) +* ((0,1).-->0) +* ((1,0).-->0)).(x,x) by A1,FUNCT_4:12
    .= (((0,0).-->0) +* ((0,1).-->0)).(x,x) by A2,FUNCT_4:12
    .= (((0,0).-->0)).(x,x) by A3,FUNCT_4:12
    .= x by FUNCOP_1:86,Lm2;
 end;

Lm14: mult_2.(x,y) = x
 proof
  [x,y] <> [1,1] by Lm2, ZFMISC_1:33;
  then
A1: not [x,y] in dom ((1,1).-->1) by Lm10, TARSKI:def 1;
  [x,y] <> [1,0] by Lm2, ZFMISC_1:33;
  then
A2: not [x,y] in dom ((1,0).-->0) by Lm11, TARSKI:def 1;
A3: [x,y] in dom ((0,1).-->0) by Lm12, TARSKI:def 1,Lm2;
  thus mult_2.(x,y)
     = (((0,0).-->0) +* ((0,1).-->0) +* ((1,0).-->0)).(x,y) by A1,FUNCT_4:12
    .= (((0,0).-->0) +* ((0,1).-->0)).(x,y) by A2,FUNCT_4:12
    .= (((0,1).-->0)).(x,y) by A3,FUNCT_4:14
    .= x by FUNCOP_1:86,Lm2;
 end;

Lm15: mult_2.(y,x) = x
 proof
  [y,x] <> [1,1] by Lm2, ZFMISC_1:33;
  then
A1: not [y,x] in dom ((1,1).-->1) by Lm10, TARSKI:def 1;
A2: [y,x] in dom ((1,0).-->0) by Lm11, TARSKI:def 1,Lm2;
  thus mult_2.(y,x)
     = (((0,0).-->0) +* ((0,1).-->0) +* ((1,0).-->0)).(y,x) by A1,FUNCT_4:12
    .= (((1,0).-->0)).(y,x) by A2,FUNCT_4:14
    .= x by FUNCOP_1:86,Lm2;
 end;

Lm16: mult_2.(y,y) = y
 proof
A1: [y,y] in dom ((1,1).-->1) by Lm10, TARSKI:def 1,Lm2;
  thus mult_2.(y,y)
     = (((1,1).-->1)).(y,y) by A1,FUNCT_4:14
    .= y by FUNCOP_1:86,Lm2;
 end;

     set om = mult_2;
Lm17:A\{x}={y} by ZFMISC_1:23,Lm2,CARD_1:88;
  then Lm18:[:A\{x},A\{x}:] = {[y,y]} by ZFMISC_1:35;
Lm19: for t being set holds t in [:A\{x},A\{x}:] implies om.t in A\{x}
     proof
        let t be set;
        assume t in [:A\{x},A\{x}:];
        then t=[y,y] by Lm18,TARSKI:def 1;
        hence thesis by Lm16,Lm17,TARSKI:def 1;
     end;
     reconsider nm = y as Element of A\{nd} by Lm17,TARSKI:def 1;
     reconsider od0=add_2 as BinOp of A;
     reconsider om0=om as BinOp of A;

Lm20: for a,b,d being Element of A holds
     add_2.(add_2.(a,b),d) = add_2.(a,add_2.(b,d))
     proof
       let a,b,d be Element of A;
A1:    a = x or a = y by TARSKI:def 2,Lm2,CARD_1:88;
A2:    b = x or b = y by TARSKI:def 2,Lm2,CARD_1:88;
A3:    d = x or d = y by TARSKI:def 2,Lm2,CARD_1:88;
       per cases by TARSKI:def 2,Lm2,CARD_1:88;
       suppose a = x;
       hence add_2.(add_2.(a,b),d) = add_2.(a,add_2.(b,d))
         by A2,A3,Lm6,Lm7,Lm8,Lm9;
       end;
       suppose b = x;
       hence add_2.(add_2.(a,b),d) = add_2.(a,add_2.(b,d))
           by A1,A3,Lm6,Lm7,Lm8;
       end;
       suppose d = x;
       hence add_2.(add_2.(a,b),d) = add_2.(a,add_2.(b,d))
                  by A1,A2,Lm6,Lm7,Lm8,Lm9;
       end;
       suppose a = y & b = y & d = y;
       hence add_2.(add_2.(a,b),d) = add_2.(a,add_2.(b,d)) by Lm7,Lm8,Lm9;
       end;
     end;

  reconsider dL=doubleLoopStr(#A,od0,om0,nm,nd#) as non empty doubleLoopStr
                    by STRUCT_0:def 1;
Lm21: for a being Element of dL holds a + 0.dL = a
     proof
       let a be Element of dL;
          a=x or a=y by TARSKI:def 2,Lm2,CARD_1:88;
       hence thesis by Lm6,Lm8;
     end;
Lm22: for a being Element of dL ex b being Element of dL st
       a+b = 0.dL
     proof
       let a be Element of dL;
       take a;
        a=x or a=y by TARSKI:def 2,Lm2,CARD_1:88;
       hence thesis by Lm6,Lm9;
     end;
Lm23:  for a,b,c being Element of dL holds a+b+c = a+(b+c)
         by Lm20;
Lm24: for a,b being Element of dL holds a+b = b+a
     proof
       let a,b be Element of dL;
          (a=x & b=x) or (a=x & b=y) or (a=y & b=x) or (a=y & b=y)
         by TARSKI:def 2,Lm2,CARD_1:88;
       hence thesis by Lm7,Lm8;
     end;
     reconsider om1=om as DnT of nd,A by Lm19,REALSET1:def 8;
Lm25:for B being non empty set, P being BinOp of B,
         e being Element of B st
     B = A\{nd} & e = nm & P = om1!(A,nd) holds LoopStr(#B,P,e#) is AbGroup
     proof
        let B be non empty set,
            P be BinOp of B,
            e be Element of B;
        assume
    A1: B = A\{nd} & e = nm & P = om1!(A,nd);
    A2: for a,b,c being Element of B holds P.(P.(a,b),c) = P.(a,P.(b,c))
        proof
          let a,b,c be Element of B;
          a = y & b = y & c = y by A1,Lm17,TARSKI:def 1;
          hence thesis by A1,Lm17,TARSKI:def 1;
        end;
    A3: for a being Element of LoopStr(#B,P,e#) holds a+0.LoopStr(#B,P,e#) = a
        proof
          let a be Element of LoopStr(#B,P,e#);
          a = y by A1,Lm17,TARSKI:def 1;
          hence thesis by A1,Lm17,TARSKI:def 1;
        end;
    A4: for a being Element of LoopStr(#B,P,e#)
         ex b being Element of LoopStr(#B,P,e#) st
           a+b = 0.LoopStr(#B,P,e#)
        proof
          let a be Element of LoopStr(#B,P,e#);
          take a;
          thus thesis by A1,Lm17,TARSKI:def 1;
        end;
A5:     for a,b,c being Element of LoopStr(#B,P,e#) holds a+b+c = a+(b+c) by A2
;
           for a,b being Element of LoopStr(#B,P,e#) holds a+b = b+a
        proof
          let a,b be Element of LoopStr(#B,P,e#);
             a = y & b = y by A1,Lm17,TARSKI:def 1;
          hence thesis;
        end;
        hence thesis by A3,A4,RLVECT_1:def 7,def 8,def 5,def 6,A5;
     end;
Lm26: for a,b,d being Element of dL holds
         a*(b+d) = a*b+a*d & (b+d)*a = b*a+d*a
     proof
       let a,b,d be Element of dL;
A1:        (a=x & b=x & d=x) or (a=x & b=x & d=y) or
       (a=x & b=y & d=x) or (a=x & b=y & d=y) or
       (a=y & b=x & d=x) or (a=y & b=x & d=y) or
       (a=y & b=y & d=x) or (a=y & b=y & d=y) by TARSKI:def 2,Lm2,CARD_1:88;
      thus a*(b+d)
         = a*b+a*d by Lm6,Lm7,Lm8,Lm9,Lm13,Lm14,Lm15,Lm16,A1;
      thus (b+d)*a
          = b*a+d*a by Lm6,Lm7,Lm8,Lm9,Lm13,Lm14,Lm15,Lm16,A1;
     end;

definition
 func dL-Z_2 -> doubleLoopStr equals
  doubleLoopStr(#2,add_2,mult_2,In(1,2),In(0,2)#);
 coherence;
end;

registration
 cluster dL-Z_2 -> strict non empty non degenerated;
 coherence
  proof
   thus dL-Z_2 is strict;
   thus the carrier of dL-Z_2 is non empty;
    0 in 2 by CARD_1:88,TARSKI:def 2;
    then
A1:  0.dL-Z_2 = 0 by FUNCT_7:def 1;
    1 in 2 by CARD_1:88,TARSKI:def 2;
   hence 0.dL-Z_2 <> 1.dL-Z_2 by A1, FUNCT_7:def 1;
  end;
end;

registration
 cluster dL-Z_2 -> add-associative distributive;
 coherence
  proof
   thus dL-Z_2 is add-associative
    proof
     thus for a,b,c being Element of dL-Z_2 holds a+b+c = a+(b+c)
         by Lm20;

    end;
   thus dL-Z_2 is distributive
    proof
     let a,b,d be Element of dL-Z_2;
A1:    (a=x & b=x & d=x) or (a=x & b=x & d=y) or
      (a=x & b=y & d=x) or (a=x & b=y & d=y) or
      (a=y & b=x & d=x) or (a=y & b=x & d=y) or
      (a=y & b=y & d=x) or (a=y & b=y & d=y) by TARSKI:def 2,Lm2,CARD_1:88;
     thus a*(b+d)
         = a*b+a*d by Lm6,Lm7,Lm8,Lm9,Lm13,Lm14,Lm15,Lm16,A1;
     thus (b+d)*a
           = b*a+d*a by Lm6,Lm7,Lm8,Lm9,Lm13,Lm14,Lm15,Lm16,A1;
    end;
  end;
end;

registration
 cluster add-associative
  (non trivial non empty strict doubleLoopStr);
 existence
  proof take dL-Z_2;
   thus thesis;
  end;
end;

registration
 cluster -> natural Element of dL-Z_2;
 coherence by TARSKI:def 2,CARD_1:88;
end;

registration
 cluster zero Element of dL-Z_2;
 existence
  proof reconsider z = 0 as Element of dL-Z_2 by TARSKI:def 2,CARD_1:88;
   take z;
   thus thesis;
  end;
 cluster non zero Element of dL-Z_2;
 existence
  proof reconsider z = 1 as Element of dL-Z_2 by TARSKI:def 2,CARD_1:88;
   take z;
   thus thesis;
  end;
end;

definition
  let L be non trivial doubleLoopStr;
  attr L is Field-like means
:Def11:
   ex om being DnT of 0.L,the carrier of L st
     om = the mult of L &
           (for B being non empty set, P being BinOp of B,
                e being Element of B holds
           B = (the carrier of L)\{0.L} & e = 1.L &
           P = om!(the carrier of L,0.L)
           implies LoopStr(#B,P,e#) is AbGroup);
end;

registration
 let A be non trivial set,
     od be BinOp of A,
     nd be Element of A,
     om be BinOp of A,
     nm be Element of A;
 cluster doubleLoopStr(#A,od,om,nm,nd#) -> non empty;
 coherence
  proof
   thus the carrier of doubleLoopStr(#A,od,om,nm,nd#) is non empty;
  end;
end;

registration
 cluster non trivial -> non empty doubleLoopStr;
 coherence
  proof let L be doubleLoopStr;
   assume L is non trivial;
    then the carrier of L is non trivial by STRUCT_0:def 9;
   hence the carrier of L is non empty;
  end;
end;

registration
 cluster strict Field-like Abelian distributive add-associative
   right_zeroed right_complementable (non degenerated doubleLoopStr);
  existence
   proof set L = doubleLoopStr(#A,od0,om0,nm,nd#);
A1:   0.L = nd;
A2:   1.L = nm;
     reconsider L as non degenerated doubleLoopStr by STRUCT_0:def 8,Lm2,A2,A1;
    take L;
    thus thesis by Def11,Lm24,Lm25,A2,Lm26,VECTSP_1:def 18,
     RLVECT_1:def 7,def 8,def 5,def 6,Lm21,Lm22,Lm23;
   end;
end;

registration
 cluster add-associative right_zeroed right_complementable
    Abelian commutative associative well-unital distributive
      almost_left_invertible
    -> Field-like (non degenerated doubleLoopStr);
 coherence
  proof let L be non degenerated doubleLoopStr;
   assume
A1:  L is add-associative right_zeroed right_complementable
    Abelian commutative associative well-unital distributive
      almost_left_invertible;
A2: L is right-distributive
    proof
     thus for a, b, c being Element of L holds a*(b+c) = a*b + a*c
                    by A1,VECTSP_1:def 18;
    end;
    set B = (the carrier of L)\{0.L};
    for y being set st y in [:B,B:] holds (the mult of L).y in B
     proof let z be set;
      assume z in [:B,B:];
       then consider x,y such that
A3:     x in B & y in B and
A4:     z = [x,y] by ZFMISC_1:103;
       reconsider x,y as Element of L by A3;
       not x in {0.L} & not y in {0.L} by A3,XBOOLE_0:def 4;
       then x <> 0.L & y <> 0.L by TARSKI:def 1;
       then x*y <> 0.L by A1,VECTSP_1:44;
       then not x*y in {0.L} by TARSKI:def 1;
:::       then x*y in B by XBOOLE_0:def 4;
      hence (the mult of L).z in B by A4,XBOOLE_0:def 4;
     end;
    then reconsider om = the mult of L as DnT of 0.L,the carrier of L
              by REALSET1:def 8;
   take om;
   thus om = the mult of L;
   let B be non empty set, P be BinOp of B, e be Element of B such that
A5: B = (the carrier of L)\{0.L} and
A6: e = 1.L and
A7: P = om!(the carrier of L,0.L);
    set K = LoopStr(#B,P,e#);
A8:  K is Abelian
     proof let v,w be Element of K;
       reconsider a=v, b=w as Element of L by A5,XBOOLE_0:def 4;
A9:     [v,w] in [:B,B:];
A10:     [w,v] in [:B,B:];
      thus v + w = a*b by A9,FUNCT_1:72,A5,A7
         .= b*a by A1,GROUP_1:def 16
         .= w + v by A5,A7,A10,FUNCT_1:72;
     end;
A11:  K is add-associative
     proof let u,v,w be Element of K;
       reconsider a=u, b=v, c =w as Element of L by A5,XBOOLE_0:def 4;
A12:     [u,v] in [:B,B:];
       then P.(u,v) in B by FUNCT_2:7;
       then
A13:     [(om||B).(u,v),w] in [:B,B:] by ZFMISC_1:106,A5,A7;
A14:     [v,w] in [:B,B:];
       then P.(v,w) in B by FUNCT_2:7;
       then
A15:     [u,(om||B).(v,w)] in [:B,B:] by ZFMISC_1:106,A5,A7;
      thus (u + v) + w
           = om.((om||B).(u,v),w) by A13,FUNCT_1:72,A5,A7
           .= (a*b)*c by A12,FUNCT_1:72
           .= a*(b*c) by A1,GROUP_1:def 4
           .= om.(u,(om||B).(v,w)) by A14,FUNCT_1:72
           .= u + (v + w) by A5,A7,A15,FUNCT_1:72;
     end;
A16:  K is right_zeroed
     proof let v be Element of K;
       reconsider a=v as Element of L by A5,XBOOLE_0:def 4;
A17:     [v,0.K] in [:B,B:];
      thus v + 0.K = a*1.L by A6,A17,FUNCT_1:72,A5,A7
         .= v by A1,VECTSP_1:def 16;
     end;
    K is right_complementable
     proof let v be Element of K;
       reconsider a=v as Element of L by A5,XBOOLE_0:def 4;
       not a in {0.L} by XBOOLE_0:def 4,A5;
       then a <> 0.L by TARSKI:def 1;
       then consider b being Element of L such that
A18:      a*b = 1.L by A1,VECTSP_1:def 20;
       0.L <> 1.L by STRUCT_0:def 8;
       then b <> 0.L by A18,VECTSP_1:36,A2,A1;
       then not b in {0.L} by TARSKI:def 1;
       then reconsider w=b as Element of K by A5,XBOOLE_0:def 4;
      take w;
       [v,w] in [:B,B:];
      hence v + w = 0.K by A6,A18,FUNCT_1:72,A5,A7;
     end;
   hence LoopStr(#B,P,e#) is AbGroup by A8,A11,A16;
  end;
end;

Lm27:
 for F being Field-like Abelian distributive add-associative
        right_zeroed right_complementable (non degenerated doubleLoopStr) holds
    1.F is Element of (the carrier of F)\{0.F}
 proof let F be Field-like Abelian distributive add-associative
        right_zeroed right_complementable (non degenerated doubleLoopStr);
   1.F <> 0.F by STRUCT_0:def 8;
   then not 1.F in {0.F} by TARSKI:def 1;
  hence 1.F is Element of (the carrier of F)\{0.F} by XBOOLE_0:def 4;
 end;

deffunc suppf1(Field-like Abelian distributive add-associative
        right_zeroed right_complementable (non degenerated doubleLoopStr))
         = the carrier of $1;

definition
   let F be Field-like Abelian distributive add-associative
        right_zeroed right_complementable (non degenerated doubleLoopStr);
canceled 3;
   func omf(F) -> DnT of 0.F,the carrier of F equals
    the mult of F;
 coherence
  proof
   consider om being DnT of 0.F,the carrier of F such that
A1: om = the mult of F and
    for B being non empty set, P being BinOp of B,
                e being Element of B holds
           B = (the carrier of F)\{0.F} & e = 1.F &
           P = om!(the carrier of F,0.F)
           implies LoopStr(#B,P,e#) is AbGroup by Def11;
   thus thesis by A1;
  end;
end;

definition
   let F be Field-like Abelian distributive add-associative
        right_zeroed right_complementable (non degenerated doubleLoopStr);
   func nmf(F) -> Element of (the carrier of F)\{0.F} equals
     1.F;
 coherence by Lm27;
end;

theorem
  for F being Field holds the LoopStr of F is AbGroup
proof
 let F be Field;
  set L = the LoopStr of F;
A1: L is Abelian
    proof let v,w be Element of L;
      reconsider a=v, b=w as Element of F;
     thus v + w = a + b
               .= b + a
               .= w + v;
    end;
A2: L is add-associative
    proof let u,v,w being Element of L;
      reconsider a=u, b=v, c = w as Element of F;
     thus (u + v) + w = (a + b) + c
         .= a + (b + c) by RLVECT_1:def 6
         .= u + (v + w);
    end;
A3: L is right_zeroed
    proof let v be Element of L;
      reconsider a=v as Element of F;
     thus v + 0.L = a + 0.F
            .= v by RLVECT_1:def 7;
    end;
    L is right_complementable
     proof let v be Element of L;
       reconsider a=v as Element of F;
       consider b being Element of F such that
A4:      a + b = 0.F by RLVECT_1:def 8;
       reconsider w=b as Element of L;
      take w;
      thus v + w = 0.L by A4;
     end;
 hence thesis by A1,A2,A3;
end;

theorem Th2:
   for F being Field-like Abelian distributive add-associative
        right_zeroed right_complementable (non degenerated doubleLoopStr),
       B being non empty set,
       P being BinOp of B, e being Element of B st
   B = (the carrier of F)\{0.F} & e = nmf(F) &
   P = omf(F)!(the carrier of F,0.F) holds
    LoopStr(#B,P,e#) is AbGroup
proof
 let F be Field-like Abelian distributive add-associative
        right_zeroed right_complementable (non degenerated doubleLoopStr),
     B be non empty set, P be BinOp of B, e be Element of B;
  set A = the carrier of F, od = the add of F, nd = 0.F;
  set nm = 1.F;
  ex om being DnT of nd,A st om = the mult of F &
   for B being non empty set,
       P being BinOp of B,
       e being Element of B st
       B = A\{nd} & e = nm & P = om!(A,nd) holds
                  LoopStr(#B,P,e#) is AbGroup by Def11;
 hence thesis;
end;

theorem
 for F being Field, x,y,z being Element of F holds
    x*(y+z) = (x*y)+(x*z) &
    (x+y)*z = x*z+y*z by VECTSP_1:def 18;

theorem
   for F being Field,
       a,b,c being Element of (the carrier of F)holds
   (a+b)+c = a+(b+c) by RLVECT_1:def 6;

theorem
   for F being Field,
       a,b being Element of (the carrier of F)holds
   a+b = b+a;

theorem
   for F being Field, a being Element of F holds
   a+0.F = a & 0.F+a = a by RLVECT_1:def 14;

theorem
   for F being Field, a being Element of F ex b being Element of F st
    a+b = 0.F & b+a = 0.F by RLVECT_1:def 15;

theorem Th8:
   for F being Field-like Abelian distributive add-associative
        right_zeroed right_complementable (non degenerated doubleLoopStr),
       a,b,c being Element of (the carrier of F)\{0.F} holds
   (a*b)*c = a*(b*c)
proof
   let F be Field-like Abelian distributive add-associative
        right_zeroed right_complementable (non degenerated doubleLoopStr),
       a,b,c be Element of suppf1(F)\{0.F};
   set B = suppf1(F)\{0.F};
   set P = omf(F)!(suppf1(F),0.F);
   set e = nmf(F);
   reconsider D = LoopStr(#B,P,e#) as strict AbGroup by Th2;
   reconsider a,b,c as Element of D;
A1:omf(F)||(suppf1(F)\{0.F})
    is Function of [:suppf1(F)\{0.F},suppf1(F)\{0.F}:],
    (suppf1(F)\{0.F}) by REALSET1:11;
then A2:dom(omf(F)||(suppf1(F)\{0.F})) =
    [:suppf1(F)\{0.F},suppf1(F)\{0.F}:] by FUNCT_2:def 1;
A3:for s,t being Element of (suppf1(F)\{0.F}) holds
    (the add of D).(s,t) is Element of (suppf1(F)\{0.F}) &
    omf(F).(s,t) is Element of (suppf1(F)\{0.F})
    proof
        let s,t be Element of (suppf1(F)\{0.F});
     A4:[s,t] in [:suppf1(F)\{0.F},suppf1(F)\{0.F}:];
        consider W being Function of
        [:suppf1(F)\{0.F},suppf1(F)\{0.F}:],
        (suppf1(F)\{0.F}) such that
    A5: W = omf(F)||(suppf1(F)\{0.F}) by A1;
           W.(s,t) is Element of (suppf1(F)\{0.F});
        hence thesis by A2,A4,A5,FUNCT_1:70;
    end;
A6:for x,y being Element of suppf1(F)\{0.F} holds
    omf(F).(x,y) = (the add of D).(x,y)
    proof
      let x,y be Element of suppf1(F)\{0.F};
         [x,y] in [:suppf1(F)\{0.F},suppf1(F)\{0.F}:];
      hence thesis by A2,FUNCT_1:70;
    end;
A7:for x,y,z being Element of suppf1(F)\{0.F} holds
  omf(F).((the add of D).(x,y),z) = (the add of D).((the add of D).(x,y),z) &
    (the add of D).(x,omf(F).(y,z)) = omf(F).(x,omf(F).(y,z))
    proof
        let x,y,z be Element of suppf1(F)\{0.F};
    A8:(the add of D).(x,y) is Element of suppf1(F)\{0.F} by A3;
           omf(F).(y,z) is Element of suppf1(F)\{0.F} by A3;
        hence thesis by A6,A8;
    end;
    reconsider x=a, y=b, z=c as Element of F;
     (x*y)*z = omf(F).((the add of D).(a,b),c) by A6
                           .= a+b+c by A7
                           .= a+(b+c) by RLVECT_1:def 6
                           .= (the add of D).(a,omf(F).(b,c)) by A6
                           .= x*(y*z) by A7;
   hence thesis;
end;

theorem Th9:
   for F being Field-like Abelian distributive add-associative
        right_zeroed right_complementable (non degenerated doubleLoopStr),
       a,b being Element of (the carrier of F)\{0.F} holds
   a*b = b*a
proof
   let F be Field-like Abelian distributive add-associative
        right_zeroed right_complementable (non degenerated doubleLoopStr),
       a,b be Element of suppf1(F)\{0.F};
   set B = suppf1(F)\{0.F};
   set P = omf(F)!(suppf1(F),0.F);
   set e = nmf(F);
   reconsider D = LoopStr(#B,P,e#) as strict AbGroup by Th2;
   reconsider a,b as Element of D;
      omf(F)||(suppf1(F)\{0.F})
    is Function of [:suppf1(F)\{0.F},suppf1(F)\{0.F}:],
    (suppf1(F)\{0.F}) by REALSET1:11;
then A1: dom(omf(F)||(suppf1(F)\{0.F})) =
    [:suppf1(F)\{0.F},suppf1(F)\{0.F}:] by FUNCT_2:def 1;
A2:for x,y being Element of suppf1(F)\{0.F} holds
    omf(F).(x,y) = (the add of D).(x,y)
    proof
        let x,y be Element of suppf1(F)\{0.F};
           [x,y] in [:suppf1(F)\{0.F},suppf1(F)\{0.F}:];
        hence thesis by A1,FUNCT_1:70;
    end;
    reconsider x = a, y = b as Element of F;
      x*y = a+b by A2
                .= b+a
                .= y*x by A2;
   hence thesis;
end;

theorem Th10:
   for F being Field-like Abelian distributive add-associative
        right_zeroed right_complementable (non degenerated doubleLoopStr),
       a being Element of (the carrier of F)\{0.F} holds
   a*1.F = a & 1.F*a = a
proof
   let F be Field-like Abelian distributive add-associative
        right_zeroed right_complementable (non degenerated doubleLoopStr),
       a be Element of suppf1(F)\{0.F};
   set B = suppf1(F)\{0.F};
   set P = omf(F)!(suppf1(F),0.F);
   set e = nmf(F);
   reconsider D = LoopStr(#B,P,e#) as strict AbGroup by Th2;
   reconsider a as Element of D;
   omf(F)||(suppf1(F)\{0.F})
    is Function of [:suppf1(F)\{0.F},suppf1(F)\{0.F}:],
    (suppf1(F)\{0.F}) by REALSET1:11;
then A1: dom(omf(F)||(suppf1(F)\{0.F})) =
    [:suppf1(F)\{0.F},suppf1(F)\{0.F}:] by FUNCT_2:def 1;
A2:for x,y being Element of suppf1(F)\{0.F} holds
    omf(F).(x,y) = (the add of D).(x,y)
    proof
        let x,y be Element of suppf1(F)\{0.F};
       [x,y] in [:suppf1(F)\{0.F},suppf1(F)\{0.F}:];
        hence thesis by A1,FUNCT_1:70;
    end;
A3:omf(F).(a,nmf(F)) = a + 0.D by A2
                     .= a by RLVECT_1:def 7;
      omf(F).(nmf(F),a) = 0.D + a by A2
                     .= a by RLVECT_1:def 14;
   hence thesis by A3;
end;

theorem Th11:
   for F being Field-like Abelian distributive add-associative
        right_zeroed right_complementable (non degenerated doubleLoopStr),
       a being Element of (the carrier of F)\{0.F}
   ex b being Element of (the carrier of F)\{0.F} st
   a*b = 1.F & b*a = 1.F
proof
   let F be Field-like Abelian distributive add-associative
        right_zeroed right_complementable (non degenerated doubleLoopStr),
       a be Element of suppf1(F)\{0.F};
   set B = suppf1(F)\{0.F};
   set P = omf(F)!(suppf1(F),0.F);
   set e = nmf(F);
      LoopStr(#B,P,e#) is AbGroup by Th2;
   then consider D being strict AbGroup such that
A1:D = LoopStr(#B,P,e#);
   reconsider a as Element of D by A1;
   consider b being Element of D such that
A2: a+b = 0.D & b+a = 0.D
    by RLVECT_1:def 15;
   omf(F)||(suppf1(F)\{0.F})
    is Function of [:suppf1(F)\{0.F},suppf1(F)\{0.F}:],
    (suppf1(F)\{0.F}) by REALSET1:11;
then A3: dom(omf(F)||(suppf1(F)\{0.F})) =
    [:suppf1(F)\{0.F},suppf1(F)\{0.F}:] by FUNCT_2:def 1;
A4:for x,y being Element of suppf1(F)\{0.F} holds
    omf(F).(x,y) = (the add of D).(x,y)
    proof
        let x,y be Element of suppf1(F)\{0.F};
       [x,y] in [:suppf1(F)\{0.F},suppf1(F)\{0.F}:];
        hence thesis by A1,A3,FUNCT_1:70;
    end;
    reconsider b as Element of suppf1(F)\{0.F} by A1;
   take b;
   thus thesis by A1,A2,A4;
end;

definition
   let F be Field;
   func compf F -> UnOp of the carrier of F means
:Def17: for x being Element of F holds it.x = -x;
existence
 proof deffunc F(Element of F) = -$1;
  consider f being UnOp of the carrier of F such that
A1: for x being Element of F holds f.x = F(x) from FUNCT_2:sch 4;
  take f;
  thus thesis by A1;
 end;
uniqueness
proof
   let C1,C2 be UnOp of the carrier of F such that
A2:for x being Element of F holds C1.x = -x and
A3:for x being Element of F holds C2.x = -x;
  for x being Element of F holds C1.x = C2.x
   proof let x be Element of F;
    thus C1.x = -x by A2 .= C2.x by A3;
   end;
 hence thesis by FUNCT_2:113;
end;
end;

theorem
   for F being Field, x,y being Element of F holds
   x+y = 0.F implies y = (compf F).x
proof
   let F be Field, x,y be Element of F;
   assume x+y = 0.F;
    then y = -x by RLVECT_1:19;
   hence thesis by Def17;
end;

theorem
   for F being Field, x being Element of F holds
   x = compf(F).(compf(F).x)
proof
   let F be Field, x be Element of F;
   thus x = --x by RLVECT_1:30 .= (compf(F).-x) by Def17
         .= compf(F).(compf(F).x) by Def17;
end;

theorem
    for F being Field,
        a,b being Element of (the carrier of F)holds
    (the add of F).(a,b) is Element of (the carrier of F)&
    omf(F).(a,b) is Element of (the carrier of F)&
    compf(F).a is Element of the carrier of F;

theorem
   for F being Field, a,b,c being Element of F holds
   a*(b-c) = a*b-a*c by VECTSP_1:43;

theorem
   for F being Field, a,b,c being Element of F holds
   (a-b)*c = a*c-b*c by VECTSP_1:45;

theorem
   for F being Field, a being Element of F holds a*0.F = 0.F by VECTSP_1:36;

theorem
   for F being Field, a being Element of F holds 0.F*a = 0.F by VECTSP_1:39;

theorem
  for F being Field, a,b being Element of F holds
   -(a*b) = a*-b by VECTSP_1:40;

theorem
   for F being Field holds 1.F*0.F = 0.F by VECTSP_1:36;

theorem
   for F being Field holds 0.F*1.F = 0.F by VECTSP_1:39;

theorem
  for F being Field,
       a,b being Element of (the carrier of F)holds
   omf(F).(a,b) is Element of the carrier of F;

theorem Th23:
   for F being Field-like Abelian distributive add-associative
        right_zeroed right_complementable (non degenerated doubleLoopStr),
      a,b,c being Element of F holds
   (a*b)*c = a*(b*c)
proof
   let F be Field-like Abelian distributive add-associative
        right_zeroed right_complementable (non degenerated doubleLoopStr),
       a,b,c be Element of suppf1(F);
A1:a = 0.F or b = 0.F or c = 0.F or
   (a is Element of suppf1(F)\{0.F} &
    b is Element of suppf1(F)\{0.F} &
    c is Element of suppf1(F)\{0.F}) by ZFMISC_1:64;
A2:a = 0.F implies (a*b)*c = a*(b*c)
   proof
      assume
   A3:a = 0.F;
      hence (a*b)*c = 0.F*c by VECTSP_1:39
                            .= 0.F by VECTSP_1:39
                            .= a*(b*c) by A3,VECTSP_1:39;
   end;
A4:b = 0.F implies (a*b)*c = a*(b*c)
   proof
      assume
   A5:b = 0.F;
      hence (a*b)*c = 0.F*c by VECTSP_1:36
                            .= 0.F by VECTSP_1:39
                            .= a*0.F by VECTSP_1:36
                            .= a*(b*c) by A5,VECTSP_1:39;
   end;
      c = 0.F implies (a*b)*c = a*(b*c)
   proof
      assume
   A6:c = 0.F;
      hence (a*b)*c = 0.F by VECTSP_1:36
                            .= a*0.F by VECTSP_1:36
                            .= a*(b*c) by A6,VECTSP_1:36;
   end;
   hence thesis by A1,A2,A4,Th8;
end;

theorem Th24:
  for F being Field-like Abelian distributive add-associative
        right_zeroed right_complementable (non degenerated doubleLoopStr),
      a,b being Element of F holds
   a*b = b*a
proof
   let F be  Field-like Abelian distributive add-associative
        right_zeroed right_complementable (non degenerated doubleLoopStr),
       a,b be Element of suppf1(F);
A1:a = 0.F or b = 0.F or
   (a is Element of suppf1(F)\{0.F} &
    b is Element of suppf1(F)\{0.F}) by ZFMISC_1:64;
A2:a = 0.F implies a*b = b*a
   proof
      assume
   A3:a = 0.F;
      then a*b = 0.F by VECTSP_1:39
                  .= b*a by A3,VECTSP_1:36;
      hence thesis;
   end;
   b = 0.F implies a*b = b*a
   proof
      assume
   A4:b = 0.F;
      then a*b = 0.F by VECTSP_1:36
                  .= b*a by A4,VECTSP_1:39;
      hence thesis;
   end;
   hence thesis by A1,A2,Th9;
end;

theorem Th25:
   for F being Field-like Abelian distributive add-associative
        right_zeroed right_complementable (non degenerated doubleLoopStr),
       a being Element of F holds
   a*1.F = a & 1.F*a = a
proof
   let F be Field-like Abelian distributive add-associative
        right_zeroed right_complementable (non degenerated doubleLoopStr),
       a be Element of suppf1(F);
   per cases by ZFMISC_1:64;
   suppose
A1:  a = 0.F;
   thus a*1.F = a by VECTSP_1:39,A1;
   thus 1.F*a = a by VECTSP_1:36,A1;
   end;
   suppose a is Element of suppf1(F)\{0.F};
    hence thesis by Th10;
   end;
end;

definition
  let F be Field;
  func revf(F) -> UnOp of (the carrier of F)\{0.F} means
:Def18: for x being Element of (the carrier of F)\{0.F} holds
        omf(F).(x,it.x) = nmf(F);
existence
proof
  defpred Z[set,set] means omf(F).($1,$2) = nmf(F);
   A1:for x being set st x in suppf1(F)\{0.F} ex y being set st
          y in suppf1(F)\{0.F} & Z[x,y]
      proof
         let x be set;
         assume x in suppf1(F)\{0.F};
          then reconsider x as Element of suppf1(F)\{0.F};
         consider y being Element of suppf1(F)\{0.F} such that
      A2: x*y = 1.F & y*x = 1.F by Th11;
         reconsider y as set;
         take y;
         thus thesis by A2;
      end;
       ex C being Function of suppf1(F)\{0.F},suppf1(F)\{0.F} st
    for x being set st x in suppf1(F)\{0.F} holds Z[x,C.x]
     from FUNCT_2:sch 1
(A1);
    then consider C being Function of suppf1(F)\{0.F},suppf1(F)\{0.F}
    such that
A3:for x being set st x in suppf1(F)\{0.F} holds omf(F).(x,C.x) = nmf(F);
    take C;
    thus thesis by A3;
end;
uniqueness
proof
   let C1,C2 be Function of suppf1(F)\{0.F},suppf1(F)\{0.F} such that
A4:for x being Element of suppf1(F)\{0.F} holds
       omf(F).(x,C1.x) = nmf(F) and
A5:for x being Element of suppf1(F)\{0.F} holds
       omf(F).(x,C2.x) = nmf(F);
      for x being set st x in suppf1(F)\{0.F} holds C1.x = C2.x
      proof
         let x be set;
         assume
     A6:x in suppf1(F)\{0.F};
      then A7:C1.x is Element of suppf1(F)\{0.F} by FUNCT_2:7;
      then reconsider a=x, C1a = C1.x as Element of F by A6;
      A8:C2.x is Element of suppf1(F)\{0.F} by A6,FUNCT_2:7;
      then reconsider C2a = C2.x as Element of F;
            C1.x = (C1a)*1.F by A7,Th10
             .= C1a*(a*C2a) by A5,A6
             .= (a*C1a)*C2a by A6,A7,A8,Th8
             .= 1.F*(C2a) by A4,A6
             .= C2.x by A8,Th10;
         hence thesis;
      end;
      hence thesis by FUNCT_2:18;
end;
end;

theorem
  for F being Field,
      x,y being Element of (the carrier of F)\{0.F} holds
      x*y = 1.F implies y = revf(F).x
proof
   let F be Field,
       x,y be Element of suppf1(F)\{0.F};
   assume
A1: x*y = 1.F;
    reconsider rx = revf(F).x as Element of F by XBOOLE_0:def 4;
      y = y*1.F by Th10
         .= omf(F).(y,nmf(F))
         .= y*(x*rx) by Def18
         .= 1.F*rx by A1,Th8
         .= revf(F).x by Th10;
   hence thesis;
end;

theorem
  for F being Field,
      x being Element of (the carrier of F)\{0.F} holds
      x =revf(F).(revf(F).x)
proof
   let F be Field,
       x be Element of suppf1(F)\{0.F};
    reconsider rx = revf(F).x as Element of F by XBOOLE_0:def 4;
    reconsider rrx = revf(F).(revf(F).x) as Element of F by XBOOLE_0:def 4;
   x =x*1.F by Th10
         .= omf(F).(x,nmf(F))
         .= x*(rx*rrx) by Def18
         .= x*rx*rrx by Th8
         .= omf(F).(nmf(F),revf(F).(revf(F).x)) by Def18
         .= 1.F*rrx
         .= revf(F).(revf(F).x) by Th10;
   hence thesis;
end;

theorem
  for F being Field,
      a,b being Element of (the carrier of F)\{0.F} holds
   omf(F).(a,b) is Element of (the carrier of F)\{0.F} &
   revf(F).a is Element of (the carrier of F)\{0.F}
proof
   let F be Field,
       a,b be Element of suppf1(F)\{0.F};
   [a,b] in [:suppf1(F)\{0.F},suppf1(F)\{0.F}:];
   hence thesis by REALSET1:def 8;
end;

theorem
  for F being Field, a,b,c being Element of F holds
   a+b = a+c implies b = c by RLVECT_1:21;

theorem
  for F being Field,
      a being Element of (the carrier of F)\{0.F},
      b,c being Element of (the carrier of F)holds
   a*b = a*c implies b = c
proof
   let F be Field,
       a be Element of suppf1(F)\{0.F},
       b,c be Element of suppf1(F);
    reconsider x=a, y=b, z=c as Element of F;
   assume
A1: a*b = a*c;
    reconsider ra = revf(F).a as Element of F by XBOOLE_0:def 4;

    b = 1.F*b by Th25
    .= omf(F).(nmf(F),b)
    .= (x*ra)*b by Def18
    .= ra*(x*c) by A1,Th23
    .= (x*ra)*c by Th23
    .= omf(F).(nmf(F),c) by Def18
    .= 1.F*c
    .= c by Th25;
   hence thesis;
end;

registration
 cluster Field-like Abelian distributive add-associative
    right_zeroed right_complementable
  -> commutative associative well-unital
      almost_left_invertible (non degenerated doubleLoopStr);
 coherence
  proof let L be non degenerated doubleLoopStr;
   assume
A1: L is Field-like Abelian distributive add-associative
    right_zeroed right_complementable;
   thus L is commutative
    proof
     thus for x,y being Element of L holds x*y = y*x by A1,Th24;
    end;
   thus L is associative
    proof
     thus for x,y,z being Element of L holds
          (x*y)*z = x*(y*z) by A1,Th23;
    end;
   thus L is well-unital
    proof
     thus for x being Element of L holds x * 1.L = x & 1.L * x = x by A1,Th25;
    end;
   let x being Element of L;
   assume x <> 0.L;
    then not x in {0.L} by TARSKI:def 1;
    then reconsider x as Element of (the carrier of L)\{0.L} by XBOOLE_0:def 4;
    consider y being Element of (the carrier of L)\{0.L} such that
A2:   x*y = 1.L & y*x = 1.L by A1,Th11;
    take y;
    thus thesis by A2;
  end;
end;

