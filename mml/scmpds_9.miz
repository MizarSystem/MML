:: SCMPDS Is Not Standard
::  by Artur Korni{\l}owicz and Yasunari Shidama
::
:: Received September 27, 2003
:: Copyright (c) 2003 Association of Mizar Users

environ

 vocabularies BOOLE, SETFAM_1, FUNCT_1, ARYTM, ORDINAL2, FUNCT_4, FINSEQ_1,
      FINSEQ_4, RELAT_1, CAT_1, AMISTD_2, REALSET1, FINSET_1, ARYTM_3, ARYTM_1,
      ABSVALUE, INT_1, NAT_1, FUNCOP_1, TARSKI, AMI_1, AMI_2, AMI_3, AMISTD_1,
      SCMPDS_2, SCMPDS_3, GOBOARD5, SQUARE_1;
 notations TARSKI, XBOOLE_0, SUBSET_1, SETFAM_1, ORDINAL1, NUMBERS,
      XCMPLX_0, XXREAL_0, XREAL_0, FUNCT_1, INT_1, NAT_1, CQC_LANG, FINSET_1,
      COMPLEX1, REALSET1, STRUCT_0, INT_2, RELAT_1, FUNCT_4, FINSEQ_1,
      FINSEQ_4, PRE_CIRC, AMI_1, AMI_2, AMI_3, AMI_5, SCMPDS_2, SCMPDS_3,
      AMISTD_1, AMISTD_2;
 constructors XXREAL_0, REAL_1, NAT_1, FINSEQ_4, REALSET1, INT_2, PRE_CIRC,
      AMI_5, SCMPDS_1, SCMPDS_3, AMISTD_2;
 registrations ARYTM_3, FRAENKEL, INT_1, RELSET_1, AMI_1, SCMPDS_2, XREAL_0,
      GOBOARD1, FUNCT_4, AMISTD_2, CQC_LANG, SCMRING1, FINSET_1, MEMBERED,
      ORDINAL1, SETFAM_1, XXREAL_0, CARD_3;
 requirements BOOLE, SUBSET, NUMERALS, ARITHM, REAL;
 definitions TARSKI, XBOOLE_0, AMISTD_1, AMISTD_2;
 theorems AMI_1, AMISTD_1, SETFAM_1, XBOOLE_0, SCMPDS_1, SCMPDS_2, SCMPDS_3,
      ABSVALUE, INT_1, JORDAN4, ORDINAL1, TARSKI, FINSEQ_1, AMI_2, AMI_3,
      NAT_1, XCMPLX_1, XBOOLE_1, REAL_1, AMI_6, RELAT_1, FUNCT_4, YELLOW14,
      CQC_LANG, YELLOW_8, PRE_CIRC, WSIERP_1, SCPINVAR, PEPIN, COMPLEX1,
      XREAL_1, NEWTON;
 schemes GOBOARD1;

begin :: Preliminaries

reserve r, s for real number;

theorem Th1:
  0 <= r + abs(r)
  proof
A1: 0 <= abs(r) by COMPLEX1:132;
    then A2: 0 + abs(r) <= abs(r) + abs(r) by XREAL_1:8;
    abs(r) + abs(r) = r + abs(r) or abs(r) + r = -r + r by ABSVALUE:1;
    hence thesis by A1,A2;
  end;

theorem Th2:
  0 <= -r + abs(r)
  proof
    r <= abs(r) by COMPLEX1:162;
    then -r >= -abs(r) by XREAL_1:26;
    then -r+abs(r) >= -abs(r)+abs(r) by XREAL_1:9;
    hence thesis;
  end;

theorem Th3:
  abs(r) = abs(s) implies r = s or r = -s
  proof
    assume
A1:   abs(r) = abs(s);
    assume
A2:   r <> s;
    per cases by ABSVALUE:1;
    suppose abs(r) = r & abs(s) = s;
    hence r = -s by A1,A2;
    end;
    suppose abs(r) = r & abs(s) = -s;
    hence r = -s by A1;
    end;
    suppose abs(r) = -r & abs(s) = s;
    hence r = -s by A1;
    end;
    suppose abs(r) = -r & abs(s) = -s;
    hence r = -s by A1,A2;
  end;
  end;

theorem Th4:
  for i, j being natural number st i < j & i <> 0 holds
    i/j is not integer
  proof
    let i, j be natural number such that
A1:   i < j and
A2:   i <> 0;
A3: i >= 0 by NAT_1:19;
    assume i/j is integer;
    then reconsider r = i/j as Integer;
 i is Nat & j is Nat by ORDINAL1:def 13;
    then i div j = 0 by A1,JORDAN4:5;
    then A4:   i qua Integer div j = 0 by NEWTON:101;
     r = [\ r /] by INT_1:47
     .= i qua Integer div j by INT_1:def 7;
    hence thesis by A1,A2,A3,A4,XCMPLX_1:50;
  end;

theorem Th5:
  {2*k where k is Nat: k > 1} is infinite
  proof
    set X = {2*k where k is Nat: k > 1};
    assume
A1:   X is finite;
A2: X c= NAT
    proof
      let x be set;
      assume x in X;
      then ex k being Nat st x = 2*k & k > 1;
      hence thesis;
    end;
     2*2 in X;
    then reconsider X as non empty finite Subset of NAT by A1,A2;
    set m = max X;
     m in X by PRE_CIRC:def 1;
    then consider k being Nat such that
A3:   m = 2*k and
A4:   k > 1;
A5: m+2 = 2*(k+1) by A3;
     k+1 > k+0 by XREAL_1:10;
    then k+1 > 1 by A4,XREAL_1:2;
    then m+2 in X by A5;
    then m+2 <= m+0 by PRE_CIRC:def 1;
    hence contradiction by XREAL_1:10;
  end;

theorem Th6:
  for f being Function, a,b,c being set st a <> c holds
    (f +* (a.-->b)).c = f.c by CQC_LANG:46;

theorem Th7:
  for f being Function, a,b,c,d being set st a <> b holds
   (f +* ((a,b)-->(c,d))) .a = c &
   (f +* ((a,b)-->(c,d))) .b = d by CQC_LANG:47;

begin :: SCMPDS

reserve a, b for Int_position,
        i for Instruction of SCMPDS,
        l for Instruction-Location of SCMPDS,
        k, k1, k2 for Integer,
        n for Nat;

Lm1:
  for N being with_non-empty_elements set,
      S being IC-Ins-separated definite (non empty non void AMI-Struct over N),
      s being State of S,
      i being Instruction of S
   holds Exec(s.IC s,s).IC S = IC Following s
  proof
    let N be with_non-empty_elements set,
        S be IC-Ins-separated definite (non empty non void AMI-Struct over N),
        s be State of S,
        i be Instruction of S;
    thus Exec(s.IC s,s).IC S = Exec(CurInstr s,s).IC S by AMI_1:def 17
      .= (Following s).IC S by AMI_1:def 18
      .= IC Following s by AMI_1:def 15;
  end;

definition
  let la, lb be Int_position,
      a, b be Integer;
  redefine func (la,lb) --> (a,b) -> FinPartState of SCMPDS;
coherence
  proof
     a is Element of INT & b is Element of INT &
    ObjectKind la = INT & ObjectKind lb = INT by INT_1:def 2,SCMPDS_2:13;
    hence thesis by AMI_1:58;
  end;
end;

registration
  cluster SCMPDS -> with-non-trivial-Instruction-Locations;
coherence
  proof
    thus the Instruction-Locations of SCMPDS is non trivial by SCMPDS_2:def 1;
  end;
end;

definition
  let l be Instruction-Location of SCMPDS;
  func locnum l -> natural number means :Def1:
   il.it = l;
existence
  proof
    consider i being Nat such that
A1:   l = inspos i by SCMPDS_3:32;
     l = il.i by A1,SCMPDS_3:def 2;
    hence thesis;
  end;
uniqueness
  proof
    let m, n be natural number such that
A2:   il.m = l & il.n = l;
    reconsider m,n as Nat by ORDINAL1:def 13;
     l = inspos m & l = inspos n by A2,SCMPDS_3:def 2;
    hence thesis by SCMPDS_3:31;
  end;
end;

definition
  let l be Instruction-Location of SCMPDS;
  redefine func locnum l -> Nat;
coherence by ORDINAL1:def 13;
end;

theorem Th8:
  l = 2*locnum l + 2
  proof
    thus 2*locnum l + 2 = il.locnum l by AMI_3:def 20
      .= l by Def1;
  end;

theorem
   for l1, l2 being Instruction-Location of SCMPDS st l1 <> l2 holds
    locnum l1 <> locnum l2
  proof
    let l1, l2 be Instruction-Location of SCMPDS such that
A1:   l1 <> l2 & locnum l1 = locnum l2;
     il.locnum l1 = l1 & il.locnum l2 = l2 by Def1;
    hence thesis by A1;
  end;

theorem Th10:
  for l1, l2 being Instruction-Location of SCMPDS st l1 <> l2 holds
    Next l1 <> Next l2
  proof
    let l1, l2 be Instruction-Location of SCMPDS;
    assume
A1:   l1 <> l2 & Next l1 = Next l2;
    consider m1 being Element of SCM-Instr-Loc such that
A2:   m1 = l1 & Next l1 = Next m1 by SCMPDS_2:def 19;
    consider m2 being Element of SCM-Instr-Loc such that
A3:   m2 = l2 & Next l2 = Next m2 by SCMPDS_2:def 19;
     Next m1 = m1+2 & Next m2 = m2+2 by AMI_2:def 15;
    hence contradiction by A1,A2,A3;
  end;

theorem Th11:
  for N being with_non-empty_elements set,
      S being IC-Ins-separated definite (non empty non void AMI-Struct over N),
      i being Instruction of S,
      l being Instruction-Location of S holds
  JUMP(i) c= NIC(i,l)
  proof
    let N be with_non-empty_elements set,
        S be IC-Ins-separated definite (non empty non void AMI-Struct over N),
        i be Instruction of S,
        l be Instruction-Location of S;
    set X = { NIC(i,k) where k is Instruction-Location of S:
      not contradiction };
    let x be set;
    assume x in JUMP(i);
    then A1: x in meet X;
     NIC(i,l) in X;
    hence thesis by A1,SETFAM_1:def 1;
  end;

theorem Th12:
  (for s being State of SCMPDS st IC s = l & s.l = i
   holds Exec(i,s).IC SCMPDS = Next IC s)
  implies
  NIC(i, l) = {Next l}
  proof
    assume
A1:   for s being State of SCMPDS st IC s = l & s.l = i
        holds Exec(i, s).IC SCMPDS = Next IC s;
    set X = {IC Following s where s is State of SCMPDS: IC s = l & s.l = i};
    hereby
      let x be set;
      assume x in NIC(i,l);
      then consider s being State of SCMPDS such that
A2:     x = IC Following s & IC s = l & s.l = i;
       x = Exec(s.IC s, s).IC SCMPDS by A2,Lm1
       .= Next l by A1,A2;
      hence x in {Next l} by TARSKI:def 1;
    end;
    let x be set;
    assume x in {Next l};
    then A3: x = Next l by TARSKI:def 1;
    consider t being State of SCMPDS;
    reconsider il1 = l as Element of ObjectKind IC SCMPDS by AMI_1:def 11;
    reconsider I = i as Element of ObjectKind l by AMI_1:def 14;
    set u = t+*((IC SCMPDS, l)-->(il1, I));
A4: IC u = l by AMI_6:6;
A5: u.l = i by AMI_6:6;
     IC Following u = Exec(u.IC u, u).IC SCMPDS by AMI_6:6
    .= Next l by A1,A4,A5;
    hence thesis by A3,A4,A5;
  end;

theorem Th13:
  (for l being Instruction-Location of SCMPDS holds NIC(i,l)={Next l})
  implies JUMP i is empty
  proof
    assume
A1:   for l being Instruction-Location of SCMPDS holds NIC(i,l)={Next l};
    consider p, q being Element of the Instruction-Locations of SCMPDS
     such that
A2:   p <> q by YELLOW_8:def 1;
    set X = { NIC(i,f) where f is Instruction-Location of SCMPDS:
        not contradiction };
    assume not thesis;
    then meet X is non empty;
    then consider x being set such that
A3:   x in meet X by XBOOLE_0:def 1;
     NIC(i,p) = {Next p} & NIC(i,q) = {Next q} by A1;
    then {Next p} in X & {Next q} in X;
    then x in {Next p} & x in {Next q} by A3,SETFAM_1:def 1;
    then x = Next p & x = Next q by TARSKI:def 1;
    hence contradiction by A2,Th10;
  end;

theorem Th14:
  NIC(goto k,l) = { 2*abs(k+locnum l) + 2 }
  proof
    set i = goto k;
    set X = { IC Following s where s is State of SCMPDS: IC s = l & s.l = i };
    set t = 2*abs(k+locnum l)+2;
     l in { 2*k1 where k1 is Nat: k1 > 0 } by AMI_2:def 3,SCMPDS_2:def 1;
    then consider k1 being Nat such that
A1:   l = 2*k1 and
      k1 > 0;
A2: 2*locnum l + 2 = l by Th8; then
    2*locnum l = 2*k1 - 2 by A1; then
A3: 2*locnum l = 2*(k1-1);
A4: now
      thus 2*abs(locnum l+k) = abs(2)*abs(locnum l + k) by ABSVALUE:def 1
        .= abs(2*(locnum l+k)) by COMPLEX1:151;
    end;
    hereby
      let x be set;
      assume x in NIC(i,l);
      then consider s being State of SCMPDS such that
A5:     x = IC Following s and
A6:     IC s = l and
A7:     s.l = i;
      consider m1 being Nat such that
A8:     m1 = IC s and
A9:     ICplusConst(s,k) = abs(m1-2+2*k)+2 by SCMPDS_2:def 20;
       x = Exec(i,s).IC SCMPDS by A5,A6,A7,Lm1
       .= abs(2*k1-2*1+2*k)+2 by A1,A6,A8,A9,SCMPDS_2:66
       .= abs(2*(k1-1)+2*k)+2
       .= abs(2*locnum l+2*k)+2 by A3
       .= t by A4;
      hence x in {t} by TARSKI:def 1;
    end;
    let x be set;
    assume
A10:   x in {t};
    consider s being State of SCMPDS;
    reconsider il1 = l as Element of ObjectKind IC SCMPDS by AMI_1:def 11;
    reconsider I = i as Element of ObjectKind l by AMI_1:def 14;
    set u = s+*((IC SCMPDS, l)-->(il1, I));
A11: u.l = i by AMI_6:6;
A12: IC u = l by AMI_6:6;
    consider m1 being Nat such that
A13:   m1 = IC u and
A14:   ICplusConst(u,k) = abs(m1-2+2*k)+2 by SCMPDS_2:def 20;
     x = abs(2*locnum l+2*k)+2 by A4,A10,TARSKI:def 1
     .= abs(m1-2+2*k)+2 by A2,A12,A13
     .= Exec(i,u).IC SCMPDS by A14,SCMPDS_2:66
     .= IC Following u by A11,A12,Lm1;
    hence thesis by A11,A12;
  end;

Lm2:
for k being natural number st k > 1 holds k-2 is Nat
proof
  let k be natural number;
  assume k > 1;
  then k >= 1+1 by NAT_1:38;
  then k - 2 >= 2 - 2 by XREAL_1:11;
  hence thesis by INT_1:16;
end;

theorem Th15:
  NIC(return a,l) = {2*k where k is Nat: k > 1}
  proof
    set i = return a;
    set X = {2*k where k is Nat: k > 1};
    hereby
      let x be set;
      assume x in NIC(i,l);
      then consider s being State of SCMPDS such that
A1:     x = IC Following s and
A2:     IC s = l and
A3:     s.l = i;
A4:   x = Exec(i,s).IC SCMPDS by A1,A2,A3,Lm1
       .= 2*(abs(s.DataLoc(s.a,1)) div 2)+2*2 by SCMPDS_1:def 23,SCMPDS_2:70;
       x in { 2*k where k is Nat: k > 0 } by A1,AMI_2:def 3,SCMPDS_2:def 1;
      then consider k being Nat such that
A5:     x = 2*k and k > 0;
A6:   2*k = 2*((abs(s.DataLoc(s.a,1)) div 2)+2) by A4,A5;
      (abs(s.DataLoc(s.a,1)) div 2)+2 >= 0+2 by XREAL_1:8;
      then k >= 1+1 by A6;
      then k > 1 by NAT_1:38;
      hence x in X by A5;
    end;
    let x be set;
    assume x in X;
    then consider k being Nat such that
A7:   x = 2*k and
A8:   k > 1;
    reconsider k2 = k - 2 as Nat by A8,Lm2;
     a in SCM-Data-Loc by SCMPDS_2:def 2;
    then consider j being Nat such that
A9:   a = 2*j+1 by AMI_2:def 2;
    consider s being State of SCMPDS;
    reconsider il1 = l as Element of ObjectKind IC SCMPDS by AMI_1:def 11;
    reconsider I = i as Element of ObjectKind l by AMI_1:def 14;
    set u = s +* ((IC SCMPDS, l)-->(il1, I));
    set t = 2*j+1+2;
     t = 2*(j+1)+1;
    then t in SCM-Data-Loc by AMI_2:def 2;
    then reconsider t1 = t as Int_position by SCMPDS_2:9;
    set g = (a,t1)-->(j,2*k2);
    set v = u +* g;
A10: dom g = {a,t} by FUNCT_4:65;
A11: u.l = i by AMI_6:6;
A12: u.IC SCMPDS = IC u by AMI_1:def 15
      .= l by AMI_6:6;
     l <> a & l <> t1 by SCMPDS_2:53;
    then not l in dom g by A10,TARSKI:def 2;
    then A13: v.l = i by A11,FUNCT_4:12;
     a <> IC SCMPDS & t1 <> IC SCMPDS by SCMPDS_2:52;
    then A14: not IC SCMPDS in dom g by A10,TARSKI:def 2;
A15: IC v = v.IC SCMPDS by AMI_1:def 15
      .= l by A12,A14,FUNCT_4:12;
     a = 2*j+1+0 by A9;
    then A16: a <> t;
    then A17: v.a = j by Th7;
A18: v.t = 2*k2 by A16,Th7;
A19: DataLoc(j,1) = 2*abs(j+1)+1 by SCMPDS_2:def 4
     .= 2*(j+1)+1 by ABSVALUE:def 1
     .= t;
    reconsider r = v.t as Nat by A16,Th7;
     x = 2*(k2 + 2) by A7
     .= 2*((2*k2 div 2) + 2) by NAT_1:68
     .= 2*((abs(r) div 2)+2) by A18,ABSVALUE:def 1
     .= 2*(abs(v.DataLoc(j,1)) div 2) + 2*2 by A19
     .= Exec(i,v).IC SCMPDS by A17,SCMPDS_1:def 23,SCMPDS_2:70
     .= IC Following v by A13,A15,Lm1;
    hence x in NIC(i,l) by A13,A15;
  end;

theorem Th16:
  NIC(saveIC(a,k1), l) = {Next l}
  proof
    set i = saveIC(a,k1);
     for s being State of SCMPDS st IC s = l & s.l = i
     holds Exec(i,s).IC SCMPDS = Next IC s by SCMPDS_2:71;
    hence thesis by Th12;
  end;

theorem Th17:
  NIC(a:=k1, l) = {Next l}
  proof
    set i = a:=k1;
     for s being State of SCMPDS st IC s = l & s.l = i
     holds Exec(i,s).IC SCMPDS = Next IC s by SCMPDS_2:57;
    hence thesis by Th12;
  end;

theorem Th18:
  NIC((a,k1):=k2, l) = {Next l}
  proof
    set i = (a,k1):=k2;
     for s being State of SCMPDS st IC s = l & s.l = i
     holds Exec(i,s).IC SCMPDS = Next IC s by SCMPDS_2:58;
    hence thesis by Th12;
  end;

theorem Th19:
  NIC((a,k1):=(b,k2), l) = {Next l}
  proof
    set i = (a,k1):=(b,k2);
     for s being State of SCMPDS st IC s = l & s.l = i
     holds Exec(i,s).IC SCMPDS = Next IC s by SCMPDS_2:59;
    hence thesis by Th12;
  end;

theorem Th20:
  NIC(AddTo(a,k1,k2), l) = {Next l}
  proof
    set i = AddTo(a,k1,k2);
     for s being State of SCMPDS st IC s = l & s.l = i
     holds Exec(i,s).IC SCMPDS = Next IC s by SCMPDS_2:60;
    hence thesis by Th12;
  end;

theorem Th21:
  NIC(AddTo(a,k1,b,k2), l) = {Next l}
  proof
    set i = AddTo(a,k1,b,k2);
     for s being State of SCMPDS st IC s = l & s.l = i
     holds Exec(i,s).IC SCMPDS = Next IC s by SCMPDS_2:61;
    hence thesis by Th12;
  end;

theorem Th22:
  NIC(SubFrom(a,k1,b,k2), l) = {Next l}
  proof
    set i = SubFrom(a,k1,b,k2);
     for s being State of SCMPDS st IC s = l & s.l = i
     holds Exec(i,s).IC SCMPDS = Next IC s by SCMPDS_2:62;
    hence thesis by Th12;
  end;

theorem Th23:
  NIC(MultBy(a,k1,b,k2), l) = {Next l}
  proof
    set i = MultBy(a,k1,b,k2);
     for s being State of SCMPDS st IC s = l & s.l = i
     holds Exec(i,s).IC SCMPDS = Next IC s by SCMPDS_2:63;
    hence thesis by Th12;
  end;

theorem Th24:
  NIC(Divide(a,k1,b,k2), l) = {Next l}
  proof
    set i = Divide(a,k1,b,k2);
     for s being State of SCMPDS st IC s = l & s.l = i
     holds Exec(i,s).IC SCMPDS = Next IC s by SCMPDS_2:64;
    hence thesis by Th12;
  end;

theorem
   NIC((a,k1)<>0_goto k2,l) = { Next l, abs( 2*(k2+locnum l) ) + 2 }
  proof
    set i = (a,k1)<>0_goto k2;
    set X = { IC Following s where s is State of SCMPDS: IC s = l & s.l = i };
    set t = abs(2*(k2+locnum l))+2;
     l in { 2*w1 where w1 is Nat: w1 > 0 } by AMI_2:def 3,SCMPDS_2:def 1;
    then consider w1 being Nat such that
A1:   l = 2*w1 and
       w1 > 0;
A2: 2*locnum l + 2 = l by Th8;
    hereby
      let x be set;
      assume x in NIC(i,l);
      then consider s being State of SCMPDS such that
A3:     x = IC Following s and
A4:     IC s = l and
A5:     s.l = i;
      consider m1 being Nat such that
A6:     m1 = IC s and
A7:     ICplusConst(s,k2) = abs(m1-2+2*k2)+2 by SCMPDS_2:def 20;
      per cases;
      suppose
A8:     s.DataLoc(s.a,k1) <> 0;
       x = Exec(i,s).IC SCMPDS by A3,A4,A5,Lm1
       .= abs(2*w1-2*1+2*k2)+2 by A1,A4,A6,A7,A8,SCMPDS_2:67
       .= abs(2*locnum l+2*k2)+2 by A1,A2
       .= t;
      hence x in {Next l,t} by TARSKI:def 2;
      end;
      suppose
A9:     s.DataLoc(s.a,k1) = 0;
       x = Exec(i,s).IC SCMPDS by A3,A4,A5,Lm1
       .= Next l by A4,A9,SCMPDS_2:67;
      hence x in {Next l,t} by TARSKI:def 2;
    end;
    end;
    let x be set;
    assume
A10:   x in {Next l,t};
    consider s being State of SCMPDS;
    reconsider il1 = l as Element of ObjectKind IC SCMPDS by AMI_1:def 11;
    reconsider I = i as Element of ObjectKind l by AMI_1:def 14;
    set u = s+*((IC SCMPDS, l)-->(il1, I));
    per cases by A10,TARSKI:def 2;
    suppose
A11:   x = Next l;
    set u1 = u +* (a.-->0);
    set u2 = u1 +* (DataLoc(u1.a,k1).-->0);
A12: l <> a by SCMPDS_2:53;
     l <> DataLoc(u1.a,k1) by SCMPDS_2:53;
    then A13: u2.l = u1.l by Th6
        .= u.l by A12,Th6
        .= i by AMI_6:6;
A14: IC SCMPDS <> DataLoc(u1.a,k1) by SCMPDS_2:52;
A15: IC SCMPDS <> a by SCMPDS_2:52;
A16: IC u2 = u2.IC SCMPDS by AMI_1:def 15
         .= u1.IC SCMPDS by A14,Th6
         .= u.IC SCMPDS by A15,Th6
         .= IC u by AMI_1:def 15
         .= il1 by AMI_6:6;
A17: u2.DataLoc(u1.a,k1) = 0 by YELLOW14:3;
     u2.DataLoc(u2.a,k1) = 0
    proof
      per cases;
      suppose a = DataLoc(u1.a,k1);
      hence thesis by A17,YELLOW14:3;
      end;
      suppose a <> DataLoc(u1.a,k1);
      then u2.a = u1.a by Th6;
      hence thesis by YELLOW14:3;
    end;
    end;
    then x = Exec(i,u2).IC SCMPDS by A11,A16,SCMPDS_2:67
     .= IC Following u2 by A13,A16,Lm1;
    hence thesis by A13,A16;
    end;
    suppose
A18:   x = t;
    set u1 = u +* (a.-->1);
    set u2 = u1 +* (DataLoc(u1.a,k1).-->1);
A19: l <> a by SCMPDS_2:53;
     l <> DataLoc(u1.a,k1) by SCMPDS_2:53;
    then A20: u2.l = u1.l by Th6
        .= u.l by A19,Th6
        .= i by AMI_6:6;
A21: IC SCMPDS <> DataLoc(u1.a,k1) by SCMPDS_2:52;
A22: IC SCMPDS <> a by SCMPDS_2:52;
A23: IC u2 = u2.IC SCMPDS by AMI_1:def 15
         .= u1.IC SCMPDS by A21,Th6
         .= u.IC SCMPDS by A22,Th6
         .= IC u by AMI_1:def 15
         .= il1 by AMI_6:6;
A24: u2.DataLoc(u1.a,k1) = 1 by YELLOW14:3;
A25: u2.DataLoc(u2.a,k1) <> 0
    proof
      per cases;
      suppose a = DataLoc(u1.a,k1);
      hence thesis by A24,YELLOW14:3;
      end;
      suppose a <> DataLoc(u1.a,k1);
      then u2.a = u1.a by Th6;
      hence thesis by YELLOW14:3;
    end;
    end;
    consider m1 being Nat such that
A26:   m1 = IC u2 and
A27:   ICplusConst(u2,k2) = abs(m1-2+2*k2)+2 by SCMPDS_2:def 20;
     x = Exec(i,u2).IC SCMPDS by A2,A18,A23,A25,A26,A27,SCMPDS_2:67
     .= IC Following u2 by A20,A23,Lm1;
    hence thesis by A20,A23;
  end;
  end;

theorem
   NIC((a,k1)<=0_goto k2,l) = { Next l, abs( 2*(k2+locnum l) ) + 2 }
  proof
    set i = (a,k1)<=0_goto k2;
    set X = { IC Following s where s is State of SCMPDS: IC s = l & s.l = i };
    set t = abs(2*(k2+locnum l))+2;
     l in { 2*w1 where w1 is Nat: w1 > 0 } by AMI_2:def 3,SCMPDS_2:def 1;
    then consider w1 being Nat such that
A1:   l = 2*w1 and
       w1 > 0;
A2: 2*locnum l + 2 = l by Th8;
    hereby
      let x be set;
      assume x in NIC(i,l);
      then consider s being State of SCMPDS such that
A3:     x = IC Following s and
A4:     IC s = l and
A5:     s.l = i;
      consider m1 being Nat such that
A6:     m1 = IC s and
A7:     ICplusConst(s,k2) = abs(m1-2+2*k2)+2 by SCMPDS_2:def 20;
      per cases;
      suppose
A8:     s.DataLoc(s.a,k1) <= 0;
       x = Exec(i,s).IC SCMPDS by A3,A4,A5,Lm1
       .= abs(2*w1-2*1+2*k2)+2 by A1,A4,A6,A7,A8,SCMPDS_2:68
       .= abs(2*locnum l+2*k2)+2 by A1,A2
       .= t;
      hence x in {Next l,t} by TARSKI:def 2;
      end;
      suppose
A9:     s.DataLoc(s.a,k1) > 0;
       x = Exec(i,s).IC SCMPDS by A3,A4,A5,Lm1
       .= Next l by A4,A9,SCMPDS_2:68;
      hence x in {Next l,t} by TARSKI:def 2;
    end;
    end;
    let x be set;
    assume
A10:   x in {Next l,t};
    consider s being State of SCMPDS;
    reconsider il1 = l as Element of ObjectKind IC SCMPDS by AMI_1:def 11;
    reconsider I = i as Element of ObjectKind l by AMI_1:def 14;
    set u = s+*((IC SCMPDS, l)-->(il1, I));
    per cases by A10,TARSKI:def 2;
    suppose
A11:   x = Next l;
    set u1 = u +* (a.-->1);
    set u2 = u1 +* (DataLoc(u1.a,k1).-->1);
A12: l <> a by SCMPDS_2:53;
     l <> DataLoc(u1.a,k1) by SCMPDS_2:53;
    then A13: u2.l = u1.l by Th6
        .= u.l by A12,Th6
        .= i by AMI_6:6;
A14: IC SCMPDS <> DataLoc(u1.a,k1) by SCMPDS_2:52;
A15: IC SCMPDS <> a by SCMPDS_2:52;
A16: IC u2 = u2.IC SCMPDS by AMI_1:def 15
         .= u1.IC SCMPDS by A14,Th6
         .= u.IC SCMPDS by A15,Th6
         .= IC u by AMI_1:def 15
         .= il1 by AMI_6:6;
A17: u2.DataLoc(u1.a,k1) = 1 by YELLOW14:3;
     u2.DataLoc(u2.a,k1) > 0
    proof
      per cases;
      suppose a = DataLoc(u1.a,k1);
      hence thesis by A17,YELLOW14:3;
      end;
      suppose a <> DataLoc(u1.a,k1);
      then u2.a = u1.a by Th6;
      hence thesis by YELLOW14:3;
    end;
    end;
    then x = Exec(i,u2).IC SCMPDS by A11,A16,SCMPDS_2:68
     .= IC Following u2 by A13,A16,Lm1;
    hence thesis by A13,A16;
    end;
    suppose
A18:   x = t;
    set u1 = u +* (a.-->0);
    set u2 = u1 +* (DataLoc(u1.a,k1).-->0);
A19: l <> a by SCMPDS_2:53;
     l <> DataLoc(u1.a,k1) by SCMPDS_2:53;
    then A20: u2.l = u1.l by Th6
        .= u.l by A19,Th6
        .= i by AMI_6:6;
A21: IC SCMPDS <> DataLoc(u1.a,k1) by SCMPDS_2:52;
A22: IC SCMPDS <> a by SCMPDS_2:52;
A23: IC u2 = u2.IC SCMPDS by AMI_1:def 15
         .= u1.IC SCMPDS by A21,Th6
         .= u.IC SCMPDS by A22,Th6
         .= IC u by AMI_1:def 15
         .= il1 by AMI_6:6;
A24: u2.DataLoc(u1.a,k1) = 0 by YELLOW14:3;
A25: u2.DataLoc(u2.a,k1) <= 0
    proof
      per cases;
      suppose a = DataLoc(u1.a,k1);
      hence thesis by A24,YELLOW14:3;
      end;
      suppose a <> DataLoc(u1.a,k1);
      then u2.a = u1.a by Th6;
      hence thesis by YELLOW14:3;
    end;
    end;
    consider m1 being Nat such that
A26:   m1 = IC u2 and
A27:   ICplusConst(u2,k2) = abs(m1-2+2*k2)+2 by SCMPDS_2:def 20;
     x = Exec(i,u2).IC SCMPDS by A2,A18,A23,A25,A26,A27,SCMPDS_2:68
     .= IC Following u2 by A20,A23,Lm1;
    hence thesis by A20,A23;
  end;
  end;

theorem
   NIC((a,k1)>=0_goto k2,l) = { Next l, abs( 2*(k2+locnum l) ) + 2 }
  proof
    set i = (a,k1)>=0_goto k2;
    set X = { IC Following s where s is State of SCMPDS: IC s = l & s.l = i };
    set t = abs(2*(k2+locnum l))+2;
     l in { 2*w1 where w1 is Nat: w1 > 0 } by AMI_2:def 3,SCMPDS_2:def 1;
    then consider w1 being Nat such that
A1:   l = 2*w1 and
       w1 > 0;
A2: 2*locnum l + 2 = l by Th8;
    hereby
      let x be set;
      assume x in NIC(i,l);
      then consider s being State of SCMPDS such that
A3:     x = IC Following s and
A4:     IC s = l and
A5:     s.l = i;
      consider m1 being Nat such that
A6:     m1 = IC s and
A7:     ICplusConst(s,k2) = abs(m1-2+2*k2)+2 by SCMPDS_2:def 20;
      per cases;
      suppose
A8:     s.DataLoc(s.a,k1) >= 0;
       x = Exec(i,s).IC SCMPDS by A3,A4,A5,Lm1
       .= abs(2*w1-2*1+2*k2)+2 by A1,A4,A6,A7,A8,SCMPDS_2:69
       .= abs(2*locnum l+2*k2)+2 by A1,A2
       .= t;
      hence x in {Next l,t} by TARSKI:def 2;
      end;
      suppose
A9:     s.DataLoc(s.a,k1) < 0;
       x = Exec(i,s).IC SCMPDS by A3,A4,A5,Lm1
       .= Next l by A4,A9,SCMPDS_2:69;
      hence x in {Next l,t} by TARSKI:def 2;
    end;
    end;
    let x be set;
    assume
A10:   x in {Next l,t};
    consider s being State of SCMPDS;
    reconsider il1 = l as Element of ObjectKind IC SCMPDS by AMI_1:def 11;
    reconsider I = i as Element of ObjectKind l by AMI_1:def 14;
    set u = s+*((IC SCMPDS, l)-->(il1, I));
    per cases by A10,TARSKI:def 2;
    suppose
A11:   x = Next l;
    set u1 = u +* (a.-->-1);
    set u2 = u1 +* (DataLoc(u1.a,k1).-->-1);
A12: l <> a by SCMPDS_2:53;
     l <> DataLoc(u1.a,k1) by SCMPDS_2:53;
    then A13: u2.l = u1.l by Th6
        .= u.l by A12,Th6
        .= i by AMI_6:6;
A14: IC SCMPDS <> DataLoc(u1.a,k1) by SCMPDS_2:52;
A15: IC SCMPDS <> a by SCMPDS_2:52;
A16: IC u2 = u2.IC SCMPDS by AMI_1:def 15
         .= u1.IC SCMPDS by A14,Th6
         .= u.IC SCMPDS by A15,Th6
         .= IC u by AMI_1:def 15
         .= il1 by AMI_6:6;
A17: u2.DataLoc(u1.a,k1) = -1 by YELLOW14:3;
A18: -1 < 0;
     u2.DataLoc(u2.a,k1) < 0
    proof
      per cases;
      suppose a = DataLoc(u1.a,k1);
      hence thesis by A17,A18,YELLOW14:3;
      end;
      suppose a <> DataLoc(u1.a,k1);
      then u2.a = u1.a by Th6;
      hence thesis by A18,YELLOW14:3;
    end;
    end;
    then x = Exec(i,u2).IC SCMPDS by A11,A16,SCMPDS_2:69
     .= IC Following u2 by A13,A16,Lm1;
    hence thesis by A13,A16;
    end;
    suppose
A19:   x = t;
    set u1 = u +* (a.-->0);
    set u2 = u1 +* (DataLoc(u1.a,k1).-->0);
A20: l <> a by SCMPDS_2:53;
     l <> DataLoc(u1.a,k1) by SCMPDS_2:53;
    then A21: u2.l = u1.l by Th6
        .= u.l by A20,Th6
        .= i by AMI_6:6;
A22: IC SCMPDS <> DataLoc(u1.a,k1) by SCMPDS_2:52;
A23: IC SCMPDS <> a by SCMPDS_2:52;
A24: IC u2 = u2.IC SCMPDS by AMI_1:def 15
         .= u1.IC SCMPDS by A22,Th6
         .= u.IC SCMPDS by A23,Th6
         .= IC u by AMI_1:def 15
         .= il1 by AMI_6:6;
A25: u2.DataLoc(u1.a,k1) = 0 by YELLOW14:3;
A26: u2.DataLoc(u2.a,k1) >= 0
    proof
      per cases;
      suppose a = DataLoc(u1.a,k1);
      hence thesis by A25,YELLOW14:3;
      end;
      suppose a <> DataLoc(u1.a,k1);
      then u2.a = u1.a by Th6;
      hence thesis by YELLOW14:3;
    end;
    end;
    consider m1 being Nat such that
A27:   m1 = IC u2 and
A28:   ICplusConst(u2,k2) = abs(m1-2+2*k2)+2 by SCMPDS_2:def 20;
     x = Exec(i,u2).IC SCMPDS by A2,A19,A24,A26,A27,A28,SCMPDS_2:69
     .= IC Following u2 by A21,A24,Lm1;
    hence thesis by A21,A24;
  end;
  end;

Lm3: JUMP goto k = {}
  proof
    set i = goto k;
    set X = { NIC(i,l) where l is Instruction-Location of SCMPDS:
        not contradiction };
    hereby
      let x be set;
      assume
A1:     x in JUMP i;
      set l1 = inspos 0;
A2:   NIC(i,l1) in X;
      x in NIC(i,l1) by A1,A2,SETFAM_1:def 1;
      then x in { IC Following s1 where s1 is State of SCMPDS:
           IC s1 = l1 & s1.l1 = i };
      then consider s1 being State of SCMPDS such that
A3:     x = IC Following s1 and
A4:     IC s1 = l1 and
A5:     s1.l1 = i;
      consider m1 being Nat such that
A6:     m1 = IC s1 and
A7:     ICplusConst(s1,k) = abs(m1-2+2*k)+2 by SCMPDS_2:def 20;
A8:   m1 = il.0 by A4,A6,SCMPDS_3:def 2
        .= 2*0+2 by AMI_3:def 20;
A9:   x = (Following s1).IC SCMPDS by A3,AMI_1:def 15
       .= Exec(CurInstr s1,s1).IC SCMPDS by AMI_1:def 18
       .= Exec(i,s1).IC SCMPDS by A4,A5,AMI_1:def 17
       .= abs(m1-2+2*k)+2 by A7,SCMPDS_2:66;

      set l2 = inspos 1;
       NIC(i,l2) in X;
      then x in NIC(i,l2) by A1,SETFAM_1:def 1;
      then x in { IC Following s2 where s2 is State of SCMPDS:
           IC s2 = l2 & s2.l2 = i };
      then consider s2 being State of SCMPDS such that
A10:     x = IC Following s2 and
A11:     IC s2 = l2 and
A12:     s2.l2 = i;
      consider m2 being Nat such that
A13:     m2 = IC s2 and
A14:     ICplusConst(s2,k) = abs(m2-2+2*k)+2 by SCMPDS_2:def 20;
A15:   m2 = il.1 by A11,A13,SCMPDS_3:def 2
        .= 2*1+2 by AMI_3:def 20;
       x = (Following s2).IC SCMPDS by A10,AMI_1:def 15
       .= Exec(CurInstr s2,s2).IC SCMPDS by AMI_1:def 18
       .= Exec(i,s2).IC SCMPDS by A11,A12,AMI_1:def 17
       .= abs(m2-2+2*k)+2 by A14,SCMPDS_2:66;
      then A16:   abs(m1-2+2*k) = abs(m2-2+2*k) by A9;
      per cases by A8,A15,A16,Th3;
      suppose 0+2*k = 2+2*k;
      hence x in {};
      end;
      suppose
A17:     2*k = -(2+2*k);
       0 = -(2*k) + 2*k
       .= 2 + (2*k + 2*k) by A17
       .= 2 + ((2+2)*k);
      then -2 = 4*k;
      then A18: -2/4 = 4*k/4;
       for i being Integer holds -i is integer;
      then --1/2 is integer by A18;
      hence x in {} by Th4;
    end;
    end;
    thus thesis by XBOOLE_1:2;
  end;

registration
  let k;
  cluster JUMP (goto k) -> empty;
coherence by Lm3;
end;

theorem Th28:
  JUMP (return a) = {2*k where k is Nat: k > 1}
  proof
    set i = return a;
    set A = {2*k where k is Nat: k > 1};
     JUMP i c= NIC(i,inspos(0)) by Th11;
    hence JUMP i c= A by Th15;
    let x be set;
    assume
A1:   x in A;
    set X = { NIC(i,l) where l is Instruction-Location of SCMPDS:
        not contradiction };
     now
       NIC(i,inspos(0)) in X;
      hence X <> {};
      let y be set;
      assume y in X;
      then consider l being Instruction-Location of SCMPDS such that
A2:     y = NIC(i,l);
       a in SCM-Data-Loc by SCMPDS_2:def 2;
      then consider j being Nat such that
A3:     a = 2*j+1 by AMI_2:def 2;
      consider s being State of SCMPDS;
      reconsider il1 = l as Element of ObjectKind IC SCMPDS by AMI_1:def 11;
      reconsider I = i as Element of ObjectKind l by AMI_1:def 14;
      set u = s+*((IC SCMPDS, l)-->(il1, I));
      consider k being Nat such that
A4:     x = 2*k and
A5:     k > 1 by A1;
      set t = 2*j+1+2;
       t = 2*(j+1)+1;
      then t in SCM-Data-Loc by AMI_2:def 2;
      then reconsider t1 = t as Int_position by SCMPDS_2:9;
      reconsider k2 = k-2 as Nat by A5,Lm2;
      set g = (a,t1)-->(j,2*k2);
      set v = u +* g;
A6:   dom g = {a,t1} by FUNCT_4:65;
A7:   u.l = i by AMI_6:6;
A8:   u.IC SCMPDS = IC u by AMI_1:def 15
       .= l by AMI_6:6;
       l <> a & l <> t1 by SCMPDS_2:53;
      then not l in dom g by A6,TARSKI:def 2;
      then A9:   v.l = i by A7,FUNCT_4:12;
       a <> IC SCMPDS & t1 <> IC SCMPDS by SCMPDS_2:52;
      then A10:   not IC SCMPDS in dom g by A6,TARSKI:def 2;
A11:   IC v = v.IC SCMPDS by AMI_1:def 15
        .= l by A8,A10,FUNCT_4:12;
       a = 2*j+1+0 by A3;
      then A12:   a <> t1;
      then A13:   v.a = j by Th7;
A14:   v.t1 = 2*k2 by A12,Th7;
A15:  DataLoc(j,1) = 2*abs(j+1)+1 by SCMPDS_2:def 4
       .= 2*(j+1)+1 by ABSVALUE:def 1
       .= t;
      reconsider r = v.t as Nat by A12,Th7;
       x = 2*(k2 + 2) by A4
       .= 2*((2*k2 div 2) + 2) by NAT_1:68
       .= 2*((abs(r) div 2)+2) by A14,ABSVALUE:def 1
       .= 2*(abs(v.DataLoc(j,1)) div 2) + 2*2 by A15
       .= Exec(i,v).IC SCMPDS by A13,SCMPDS_1:def 23,SCMPDS_2:70
       .= IC Following v by A9,A11,Lm1;
      hence x in y by A2,A9,A11;
    end;
    then x in meet X by SETFAM_1:def 1;
    hence thesis;
  end;

registration
  let a;
  cluster JUMP (return a) -> infinite;
coherence by Th5,Th28;
end;

registration
  let a,k1;
  cluster JUMP (saveIC(a,k1)) -> empty;
coherence
  proof
     for l being Instruction-Location of SCMPDS holds
     NIC(saveIC(a,k1),l)={Next l} by Th16;
    hence thesis by Th13;
  end;
end;

registration
  let a,k1;
  cluster JUMP (a:=k1) -> empty;
coherence
  proof
     for l being Instruction-Location of SCMPDS holds NIC(a:=k1,l)={Next l}
     by Th17;
    hence thesis by Th13;
  end;
end;

registration
  let a,k1,k2;
  cluster JUMP ((a,k1):=k2) -> empty;
coherence
  proof
     for l being Instruction-Location of SCMPDS holds NIC((a,k1):=k2,l)={Next l
}
     by Th18;
    hence thesis by Th13;
  end;
end;

registration
  let a,b,k1,k2;
  cluster JUMP ((a,k1):=(b,k2)) -> empty;
coherence
  proof
     for l being Instruction-Location of SCMPDS holds
     NIC((a,k1):=(b,k2),l)={Next l} by Th19;
    hence thesis by Th13;
  end;
end;

registration
  let a,k1,k2;
  cluster JUMP (AddTo(a,k1,k2)) -> empty;
coherence
  proof
     for l being Instruction-Location of SCMPDS holds
     NIC(AddTo(a,k1,k2),l)={Next l} by Th20;
    hence thesis by Th13;
  end;
end;

registration
  let a,b,k1,k2;
  cluster JUMP (AddTo(a,k1,b,k2)) -> empty;
coherence
  proof
     for l being Instruction-Location of SCMPDS holds
     NIC(AddTo(a,k1,b,k2),l)={Next l} by Th21;
    hence thesis by Th13;
  end;
  cluster JUMP (SubFrom(a,k1,b,k2)) -> empty;
coherence
  proof
     for l being Instruction-Location of SCMPDS holds
     NIC(SubFrom(a,k1,b,k2),l)={Next l} by Th22;
    hence thesis by Th13;
  end;
  cluster JUMP (MultBy(a,k1,b,k2)) -> empty;
coherence
  proof
     for l being Instruction-Location of SCMPDS holds
     NIC(MultBy(a,k1,b,k2),l)={Next l} by Th23;
    hence thesis by Th13;
  end;
  cluster JUMP (Divide(a,k1,b,k2)) -> empty;
coherence
  proof
     for l being Instruction-Location of SCMPDS holds
     NIC(Divide(a,k1,b,k2),l)={Next l} by Th24;
    hence thesis by Th13;
  end;
end;

Lm4:
  5/3 is not integer
  proof
     not 3 qua Integer divides 5
    proof
      assume not thesis;
      then 3 divides 5 by SCPINVAR:2;
      then A1:   5 mod 3 = 0 by PEPIN:6;
       5 = 3 * 1 + 2;
      hence contradiction by A1,NAT_1:def 2;
    end;
    hence 5/3 is not integer by WSIERP_1:22;
  end;

Lm5:
  for a being real number st a > 0 holds -(2*a+(1+a)) < -0
  proof
    let a be real number;
    assume
A1:   a > 0;
    then A2: 2*a > 2*0 by XREAL_1:70;
     1+a > 1+0 by A1,XREAL_1:10;
    then 2*a+(1+a) > 1+0 by A2,XREAL_1:10;
    then 2*a+(1+a) > 0;
    hence -(2*a+(1+a)) < -0 by XREAL_1:26;
end;

Lm6:
  for d being real number holds
   2*(abs(d)+(-d+abs(d)+4))+2-2+2*d <>
   -(2*(abs(d)+(-d+abs(d)+4)+(-d+abs(d)+4))+2-2+2*d)
  proof
    let d be real number;
    set c = -d+abs(d)+4;
    set xx = c+c+c;
    assume 2*(abs(d)+c)+2-2+2*d = -(2*(abs(d)+c+(-d+abs(d)+4))+2-2+2*d);
    then A1: d + abs(d) = (-2)*xx/4;
     -d+abs(d) >= 0 by Th2;
    then c >= 0+4 by XREAL_1:8;
    then c > 0;
    then 3*c > 3*0 by XREAL_1:70;
    then (-2)*xx < (-2)*0 by XREAL_1:71;
    then (-2)*xx/4 < 0/4 by REAL_1:73;
    hence contradiction by A1,Th1;
  end;

Lm7:
  for b,d being real number holds
    2*b+2 <> 2*b + (2*(-d+abs(d)+4) + 2*d)
  proof
    let b,d be real number;
    set c = -d+abs(d)+4;
    assume 2*b+2 = 2*b + (2*c + 2*d);
    then 2*(c+d) = 2*1;
    then c+d-d = 1-d;
    then A1: c = 1-d+0;
     abs(d) >= 0 by COMPLEX1:132;
    then abs(d)+3 >= 0+3 by XREAL_1:9;
    then abs(d)+3 <> 0;
    hence thesis by A1;
  end;

Lm8:
  for c,d being real number st c > 0 holds
   2*(abs(d)+c)+2 <> -(2*(abs(d)+c)+2*c+2*d)
  proof
    let c,d be real number;
    assume
A1:   c > 0;
    assume 2*(abs(d)+c)+2 = -(2*(abs(d)+c)+2*c+2*d);
    then A2: 2*abs(d)+d = -(2*c+(1+c));
    per cases;
    suppose
A3:   d >= 0;
    then A4: -(2*c+(1+c)) = 2*d+1*d by A2,ABSVALUE:def 1
         .= (2+1)*d;
     3*d >= 3*0 by A3,XREAL_1:66;
    hence thesis by A1,A4,Lm5;
    end;
    suppose
A5:   d < 0;
    then abs(d) = -d by ABSVALUE:def 1;
    then A6: -(2*c+(1+c)) = (-2)*d+1*d by A2
        .= (-2+1)*d;
     (-1)*d >= (-1)*0 by A5,XREAL_1:67;
    hence thesis by A1,A6,Lm5;
  end;
  end;

Lm9:
  for b being real number, d being Integer st d <> 5 holds
    2*(b+(-d+abs(d)+4)+1) <> 2*(b+d)
  proof
    let b be real number,
        d be Integer;
    assume
A1:   d <> 5;
    assume A2: 2*(b+(-d+abs(d)+4)+1) = 2*(b+d);
    then A3: 0 = abs(d) - 2*d+(2 + 3);
    per cases;
    suppose d >= 0;
    then abs(d) = d by ABSVALUE:def 1;
    then -d+5 = 0 by A3;
    hence thesis by A1;
    end;
    suppose d < 0;
    then abs(d) = -d by ABSVALUE:def 1;
    then 0 = (-1)*d-2*d+(2+3) by A2
      .= (-1-2)*d+(2+3);
    then (-3)*d/-3 = (-5)/-3;
    hence thesis by Lm4;
  end;
  end;

Lm10:
  for c,d being real number st -(2*c+(1+c)) < -0
    holds 2*(abs(d)+c+c)+2 <> -(2*(abs(d)+c)+2*d)
  proof
    let c,d be real number;
    assume
A1:   -(2*c+(1+c)) < -0;
    assume 2*(abs(d)+c+c)+2 = -(2*(abs(d)+c)+2*d);
    then A2: 2*abs(d)+d = -(2*c+(c+1));
A3: 0 <= abs(d)+d by Th1;
     0 <= abs(d) by COMPLEX1:132;
    then 1*abs(d) <= 2*abs(d) by XREAL_1:66;
    hence thesis by A1,A2,A3,XREAL_1:8;
  end;

Lm11:
  JUMP ((a,k1)<>0_goto 5) = {}
  proof
    set k2 = 5;
    set i = (a,k1)<>0_goto k2;
    set X = { NIC(i,l) where l is Instruction-Location of SCMPDS:
        not contradiction };
    hereby
      let x be set;
      assume
A1:     x in JUMP i;
      set nl1 = 5;
      set nl2 = 8;
      set l1 = inspos nl1;
A2:   NIC(i,l1) in X;
      x in NIC(i,l1) by A1,A2,SETFAM_1:def 1;
      then x in { IC Following s1 where s1 is State of SCMPDS:
           IC s1 = l1 & s1.l1 = i };
      then consider s1 being State of SCMPDS such that
A3:     x = IC Following s1 and
A4:     IC s1 = l1 and
A5:     s1.l1 = i;
      consider m1 being Nat such that
A6:     m1 = IC s1 and
A7:     ICplusConst(s1,k2) = abs(m1-2+2*k2)+2 by SCMPDS_2:def 20;
A8:   m1 = il.nl1 by A4,A6,SCMPDS_3:def 2
        .= 2*nl1+2 by AMI_3:def 20;

      set l2 = inspos nl2;
       NIC(i,l2) in X;
      then x in NIC(i,l2) by A1,SETFAM_1:def 1;
      then x in { IC Following s2 where s2 is State of SCMPDS:
           IC s2 = l2 & s2.l2 = i };
      then consider s2 being State of SCMPDS such that
A9:     x = IC Following s2 and
A10:     IC s2 = l2 and
A11:     s2.l2 = i;
      consider m2 being Nat such that
A12:     m2 = IC s2 and
A13:     ICplusConst(s2,k2) = abs(m2-2+2*k2)+2 by SCMPDS_2:def 20;
A14:   m2 = il.nl2 by A10,A12,SCMPDS_3:def 2
        .= 2*nl2+2 by AMI_3:def 20;
A15:   l1 <> l2 by SCMPDS_3:31;

      per cases;
      suppose that
A16:     s1.DataLoc(s1.a,k1) <> 0 and
A17:     s2.DataLoc(s2.a,k1) <> 0;
A18:   x = Exec(i,s1).IC SCMPDS by A3,A4,A5,Lm1
       .= abs(m1-2+2*k2)+2 by A7,A16,SCMPDS_2:67;
       x = Exec(i,s2).IC SCMPDS by A9,A10,A11,Lm1
       .= abs(m2-2+2*k2)+2 by A13,A17,SCMPDS_2:67;
      then abs(m1-2+2*k2) = abs(m2-2+2*k2) by A18;
      then 2*nl1+2-2+2*k2 = 2*nl2+2-2+2*k2 or
        2*nl1+2-2+2*k2 = -(2*nl2+2-2+2*k2) by A8,A14,Th3;
      hence x in {};

      end;
      suppose that
A19:     s1.DataLoc(s1.a,k1) = 0 and
A20:     s2.DataLoc(s2.a,k1) = 0;
A21:   x = Exec(i,s1).IC SCMPDS by A3,A4,A5,Lm1
       .= Next l1 by A4,A19,SCMPDS_2:67;
       x = Exec(i,s2).IC SCMPDS by A9,A10,A11,Lm1
       .= Next l2 by A10,A20,SCMPDS_2:67;
      hence x in {} by A15,A21,Th10;

      end;
      suppose that
A22:     s1.DataLoc(s1.a,k1) = 0 and
A23:     s2.DataLoc(s2.a,k1) <> 0;
      consider n1 being Element of SCM-Instr-Loc such that
A24:     n1 = l1 & Next l1 = Next n1 by SCMPDS_2:def 19;
      consider w1 being Nat such that
A25:     n1 = 2*w1+2 by SCMPDS_2:1;
A26:   x = Exec(i,s1).IC SCMPDS by A3,A4,A5,Lm1
       .= Next n1 by A4,A22,A24,SCMPDS_2:67
       .= n1 + 2 by AMI_2:def 15;
       x = Exec(i,s2).IC SCMPDS by A9,A10,A11,Lm1
       .= abs(m2-2+2*k2)+2 by A13,A23,SCMPDS_2:67;
      then 2*w1+2 = abs(m2-2+2*k2) by A25,A26;
      then 2*w1+2 = m2-2+2*k2 or 2*w1+2 = -(m2-2+2*k2) by ABSVALUE:1;
      hence x in {} by A4,A6,A8,A14,A24,A25;
      end;
      suppose that
A27:     s1.DataLoc(s1.a,k1) <> 0 and
A28:     s2.DataLoc(s2.a,k1) = 0;
      consider n2 being Element of SCM-Instr-Loc such that
A29:     n2 = l2 & Next l2 = Next n2 by SCMPDS_2:def 19;
      consider w2 being Nat such that
A30:     n2 = 2*w2+2 by SCMPDS_2:1;
A31:   x = Exec(i,s1).IC SCMPDS by A3,A4,A5,Lm1
       .= abs(m1-2+2*k2)+2 by A7,A27,SCMPDS_2:67;
       x = Exec(i,s2).IC SCMPDS by A9,A10,A11,Lm1
       .= Next n2 by A10,A28,A29,SCMPDS_2:67
       .= n2 + 2 by AMI_2:def 15;
      then 2*w2+2 = abs(m1-2+2*k2) by A30,A31;
      then 2*w2+2 = m1-2+2*k2 or 2*w2+2 = -(m1-2+2*k2) by ABSVALUE:1;
      hence x in {} by A8,A10,A12,A14,A29,A30;
    end;
    end;
    thus thesis by XBOOLE_1:2;
  end;

Lm12:
  k2 <> 5 implies JUMP ((a,k1)<>0_goto k2) = {}
  proof
    assume
A1:   k2 <> 5;
    set i = (a,k1)<>0_goto k2;
    set X = { NIC(i,l) where l is Instruction-Location of SCMPDS:
        not contradiction };
    hereby
      let x be set;
      assume
A2:     x in JUMP i;
      set x1 = -k2+abs(k2)+4;
       x1 > -k2+abs(k2)+0 by XREAL_1:8;
      then A3:   x1 > 0 by Th2;
      then reconsider x1 as Nat by INT_1:16;
A4:   -(2*x1+(1+x1)) < -0 by A3,Lm5;
      set nl1 = abs(k2)+x1;
      set nl2 = nl1+x1;
      set l1 = inspos nl1;
A5:   NIC(i,l1) in X;
      x in NIC(i,l1) by A2,A5,SETFAM_1:def 1;
      then x in { IC Following s1 where s1 is State of SCMPDS:
           IC s1 = l1 & s1.l1 = i };
      then consider s1 being State of SCMPDS such that
A6:     x = IC Following s1 and
A7:     IC s1 = l1 and
A8:     s1.l1 = i;
      consider m1 being Nat such that
A9:     m1 = IC s1 and
A10:     ICplusConst(s1,k2) = abs(m1-2+2*k2)+2 by SCMPDS_2:def 20;
A11:   m1 = il.nl1 by A7,A9,SCMPDS_3:def 2
        .= 2*nl1+2 by AMI_3:def 20;

      set l2 = inspos nl2;
       NIC(i,l2) in X;
      then x in NIC(i,l2) by A2,SETFAM_1:def 1;
      then x in { IC Following s2 where s2 is State of SCMPDS:
           IC s2 = l2 & s2.l2 = i };
      then consider s2 being State of SCMPDS such that
A12:     x = IC Following s2 and
A13:     IC s2 = l2 and
A14:     s2.l2 = i;
      consider m2 being Nat such that
A15:     m2 = IC s2 and
A16:     ICplusConst(s2,k2) = abs(m2-2+2*k2)+2 by SCMPDS_2:def 20;
A17:   m2 = il.nl2 by A13,A15,SCMPDS_3:def 2
        .= 2*nl2+2 by AMI_3:def 20;
      nl1 <> nl2 by A3;
      then A18:   l1 <> l2 by SCMPDS_3:31;

      per cases;
      suppose that
A19:     s1.DataLoc(s1.a,k1) <> 0 and
A20:     s2.DataLoc(s2.a,k1) <> 0;
A21:   x = Exec(i,s1).IC SCMPDS by A6,A7,A8,Lm1
       .= abs(m1-2+2*k2)+2 by A10,A19,SCMPDS_2:67;
       x = Exec(i,s2).IC SCMPDS by A12,A13,A14,Lm1
       .= abs(m2-2+2*k2)+2 by A16,A20,SCMPDS_2:67;
      then A22:   abs(m1-2+2*k2) = abs(m2-2+2*k2) by A21;
      thus x in {}
      proof
        per cases by A11,A17,A22,Th3;
        suppose 2*nl1+2-2+2*k2 = 2*nl2+2-2+2*k2;
        then nl1+0 = nl2;
        hence x in {} by A3;
        end;
        suppose 2*nl1+2-2+2*k2 = -(2*nl2+2-2+2*k2);
        hence x in {} by Lm6;
      end;
      end;

      end;
      suppose that
A23:     s1.DataLoc(s1.a,k1) = 0 and
A24:     s2.DataLoc(s2.a,k1) = 0;
A25:   x = Exec(i,s1).IC SCMPDS by A6,A7,A8,Lm1
       .= Next l1 by A7,A23,SCMPDS_2:67;
       x = Exec(i,s2).IC SCMPDS by A12,A13,A14,Lm1
       .= Next l2 by A13,A24,SCMPDS_2:67;
      hence x in {} by A18,A25,Th10;

      end;
      suppose that
A26:     s1.DataLoc(s1.a,k1) = 0 and
A27:     s2.DataLoc(s2.a,k1) <> 0;
      consider n1 being Element of SCM-Instr-Loc such that
A28:     n1 = l1 & Next l1 = Next n1 by SCMPDS_2:def 19;
      consider w1 being Nat such that
A29:     n1 = 2*w1+2 by SCMPDS_2:1;
A30:   x = Exec(i,s1).IC SCMPDS by A6,A7,A8,Lm1
       .= Next n1 by A7,A26,A28,SCMPDS_2:67
       .= n1 + 2 by AMI_2:def 15;
       x = Exec(i,s2).IC SCMPDS by A12,A13,A14,Lm1
       .= abs(m2-2+2*k2)+2 by A16,A27,SCMPDS_2:67;
      then A31:   2*w1+2 = abs(m2-2+2*k2) by A29,A30;
      thus x in {}
      proof
        per cases by A31,ABSVALUE:1;
        suppose 2*w1+2 = m2-2+2*k2;
        then 2*nl1+2 = 2*nl1 + 2*x1 + 2*k2 by A7,A9,A11,A17,A28,A29
         .= 2*nl1 + (2*x1 + 2*k2);
        hence x in {} by Lm7;
        end;
        suppose 2*w1+2 = -(m2-2+2*k2);
        then 2*nl1+2 = -(2*nl1+2*x1+2*k2) by A7,A9,A11,A17,A28,A29;
        hence x in {} by A3,Lm8;
      end;
      end;

      end;
      suppose that
A32:     s1.DataLoc(s1.a,k1) <> 0 and
A33:     s2.DataLoc(s2.a,k1) = 0;
      consider n2 being Element of SCM-Instr-Loc such that
A34:     n2 = l2 & Next l2 = Next n2 by SCMPDS_2:def 19;
      consider w2 being Nat such that
A35:     n2 = 2*w2+2 by SCMPDS_2:1;
A36:   x = Exec(i,s1).IC SCMPDS by A6,A7,A8,Lm1
       .= abs(m1-2+2*k2)+2 by A10,A32,SCMPDS_2:67;
       x = Exec(i,s2).IC SCMPDS by A12,A13,A14,Lm1
       .= Next n2 by A13,A33,A34,SCMPDS_2:67
       .= n2 + 2 by AMI_2:def 15;
      then A37:   2*w2+2 = abs(m1-2+2*k2) by A35,A36;
      thus x in {}
      proof
        per cases by A37,ABSVALUE:1;
        suppose
A38:       2*w2+2 = m1-2+2*k2;
         2*(nl2+1) = 2*nl2+2*1
          .= 2*nl1+2*k2 by A11,A13,A15,A17,A34,A35,A38
          .= 2*(nl1+k2);
        hence thesis by A1,Lm9;
        end;
        suppose 2*w2+2 = -(m1-2+2*k2);
        hence x in {} by A4,A11,A13,A15,A17,A34,A35,Lm10;
      end;
      end;
    end;
    end;
    thus thesis by XBOOLE_1:2;
  end;

Lm13:
  JUMP ((a,k1)<=0_goto 5) = {}
  proof
    set k2 = 5;
    set i = (a,k1)<=0_goto k2;
    set X = { NIC(i,l) where l is Instruction-Location of SCMPDS:
        not contradiction };
    hereby
      let x be set;
      assume
A1:     x in JUMP i;
      set nl1 = 5;
      set nl2 = 8;
      set l1 = inspos nl1;
A2:   NIC(i,l1) in X;
      x in NIC(i,l1) by A1,A2,SETFAM_1:def 1;
      then x in { IC Following s1 where s1 is State of SCMPDS:
           IC s1 = l1 & s1.l1 = i };
      then consider s1 being State of SCMPDS such that
A3:     x = IC Following s1 and
A4:     IC s1 = l1 and
A5:     s1.l1 = i;
      consider m1 being Nat such that
A6:     m1 = IC s1 and
A7:     ICplusConst(s1,k2) = abs(m1-2+2*k2)+2 by SCMPDS_2:def 20;
A8:   m1 = il.nl1 by A4,A6,SCMPDS_3:def 2
        .= 2*nl1+2 by AMI_3:def 20;

      set l2 = inspos nl2;
       NIC(i,l2) in X;
      then x in NIC(i,l2) by A1,SETFAM_1:def 1;
      then x in { IC Following s2 where s2 is State of SCMPDS:
           IC s2 = l2 & s2.l2 = i };
      then consider s2 being State of SCMPDS such that
A9:     x = IC Following s2 and
A10:     IC s2 = l2 and
A11:     s2.l2 = i;
      consider m2 being Nat such that
A12:     m2 = IC s2 and
A13:     ICplusConst(s2,k2) = abs(m2-2+2*k2)+2 by SCMPDS_2:def 20;
A14:   m2 = il.nl2 by A10,A12,SCMPDS_3:def 2
        .= 2*nl2+2 by AMI_3:def 20;
A15:   l1 <> l2 by SCMPDS_3:31;

      per cases;
      suppose that
A16:     s1.DataLoc(s1.a,k1) <= 0 and
A17:     s2.DataLoc(s2.a,k1) <= 0;
A18:   x = Exec(i,s1).IC SCMPDS by A3,A4,A5,Lm1
       .= abs(m1-2+2*k2)+2 by A7,A16,SCMPDS_2:68;
       x = Exec(i,s2).IC SCMPDS by A9,A10,A11,Lm1
       .= abs(m2-2+2*k2)+2 by A13,A17,SCMPDS_2:68;
      then abs(m1-2+2*k2) = abs(m2-2+2*k2) by A18;
      then 2*nl1+2-2+2*k2 = 2*nl2+2-2+2*k2 or
        2*nl1+2-2+2*k2 = -(2*nl2+2-2+2*k2) by A8,A14,Th3;
      hence x in {};

      end;
      suppose that
A19:     s1.DataLoc(s1.a,k1) > 0 and
A20:     s2.DataLoc(s2.a,k1) > 0;
A21:   x = Exec(i,s1).IC SCMPDS by A3,A4,A5,Lm1
       .= Next l1 by A4,A19,SCMPDS_2:68;
       x = Exec(i,s2).IC SCMPDS by A9,A10,A11,Lm1
       .= Next l2 by A10,A20,SCMPDS_2:68;
      hence x in {} by A15,A21,Th10;

      end;
      suppose that
A22:     s1.DataLoc(s1.a,k1) > 0 and
A23:     s2.DataLoc(s2.a,k1) <= 0;
      consider n1 being Element of SCM-Instr-Loc such that
A24:     n1 = l1 & Next l1 = Next n1 by SCMPDS_2:def 19;
      consider w1 being Nat such that
A25:     n1 = 2*w1+2 by SCMPDS_2:1;
A26:   x = Exec(i,s1).IC SCMPDS by A3,A4,A5,Lm1
       .= Next n1 by A4,A22,A24,SCMPDS_2:68
       .= n1 + 2 by AMI_2:def 15;
       x = Exec(i,s2).IC SCMPDS by A9,A10,A11,Lm1
       .= abs(m2-2+2*k2)+2 by A13,A23,SCMPDS_2:68;
      then 2*w1+2 = abs(m2-2+2*k2) by A25,A26;
      then 2*w1+2 = m2-2+2*k2 or 2*w1+2 = -(m2-2+2*k2) by ABSVALUE:1;
      hence x in {} by A4,A6,A8,A14,A24,A25;

      end;
      suppose that
A27:     s1.DataLoc(s1.a,k1) <= 0 and
A28:     s2.DataLoc(s2.a,k1) > 0;
      consider n2 being Element of SCM-Instr-Loc such that
A29:     n2 = l2 & Next l2 = Next n2 by SCMPDS_2:def 19;
      consider w2 being Nat such that
A30:     n2 = 2*w2+2 by SCMPDS_2:1;
A31:   x = Exec(i,s1).IC SCMPDS by A3,A4,A5,Lm1
       .= abs(m1-2+2*k2)+2 by A7,A27,SCMPDS_2:68;
       x = Exec(i,s2).IC SCMPDS by A9,A10,A11,Lm1
       .= Next n2 by A10,A28,A29,SCMPDS_2:68
       .= n2 + 2 by AMI_2:def 15;
      then 2*w2+2 = abs(m1-2+2*k2) by A30,A31;
      then 2*w2+2 = m1-2+2*k2 or 2*w2+2 = -(m1-2+2*k2) by ABSVALUE:1;
      hence x in {} by A8,A10,A12,A14,A29,A30;
    end;
    end;
    thus thesis by XBOOLE_1:2;
  end;

Lm14:
  k2 <> 5 implies JUMP ((a,k1)<=0_goto k2) = {}
  proof
    assume
A1:   k2 <> 5;
    set i = (a,k1)<=0_goto k2;
    set X = { NIC(i,l) where l is Instruction-Location of SCMPDS:
        not contradiction };
    hereby
      let x be set;
      assume
A2:     x in JUMP i;
      set x1 = -k2+abs(k2)+4;
       x1 > -k2+abs(k2)+0 by XREAL_1:8;
      then A3:   x1 > 0 by Th2;
      then reconsider x1 as Nat by INT_1:16;
A4:   -(2*x1+(1+x1)) < -0 by A3,Lm5;
      set nl1 = abs(k2)+x1;
      set nl2 = nl1+x1;
      set l1 = inspos nl1;
A5:   NIC(i,l1) in X;
      x in NIC(i,l1) by A2,A5,SETFAM_1:def 1;
      then x in { IC Following s1 where s1 is State of SCMPDS:
           IC s1 = l1 & s1.l1 = i };
      then consider s1 being State of SCMPDS such that
A6:     x = IC Following s1 and
A7:     IC s1 = l1 and
A8:     s1.l1 = i;
      consider m1 being Nat such that
A9:     m1 = IC s1 and
A10:     ICplusConst(s1,k2) = abs(m1-2+2*k2)+2 by SCMPDS_2:def 20;
A11:   m1 = il.nl1 by A7,A9,SCMPDS_3:def 2
        .= 2*nl1+2 by AMI_3:def 20;

      set l2 = inspos nl2;
       NIC(i,l2) in X;
      then x in NIC(i,l2) by A2,SETFAM_1:def 1;
      then x in { IC Following s2 where s2 is State of SCMPDS:
           IC s2 = l2 & s2.l2 = i };
      then consider s2 being State of SCMPDS such that
A12:     x = IC Following s2 and
A13:     IC s2 = l2 and
A14:     s2.l2 = i;
      consider m2 being Nat such that
A15:     m2 = IC s2 and
A16:     ICplusConst(s2,k2) = abs(m2-2+2*k2)+2 by SCMPDS_2:def 20;
A17:   m2 = il.nl2 by A13,A15,SCMPDS_3:def 2
        .= 2*nl2+2 by AMI_3:def 20;
      nl1 <> nl2 by A3;
      then A18:   l1 <> l2 by SCMPDS_3:31;

      per cases;
      suppose that
A19:     s1.DataLoc(s1.a,k1) <= 0 and
A20:     s2.DataLoc(s2.a,k1) <= 0;
A21:   x = Exec(i,s1).IC SCMPDS by A6,A7,A8,Lm1
       .= abs(m1-2+2*k2)+2 by A10,A19,SCMPDS_2:68;
       x = Exec(i,s2).IC SCMPDS by A12,A13,A14,Lm1
       .= abs(m2-2+2*k2)+2 by A16,A20,SCMPDS_2:68;
      then A22:   abs(m1-2+2*k2) = abs(m2-2+2*k2) by A21;
      thus x in {}
      proof
        per cases by A11,A17,A22,Th3;
        suppose 2*nl1+2-2+2*k2 = 2*nl2+2-2+2*k2;
        then nl1+0 = nl2;
        hence x in {} by A3;
        end;
        suppose 2*nl1+2-2+2*k2 = -(2*nl2+2-2+2*k2);
        hence x in {} by Lm6;
      end;
      end;

      end;
      suppose that
A23:     s1.DataLoc(s1.a,k1) > 0 and
A24:     s2.DataLoc(s2.a,k1) > 0;
A25:   x = Exec(i,s1).IC SCMPDS by A6,A7,A8,Lm1
       .= Next l1 by A7,A23,SCMPDS_2:68;
       x = Exec(i,s2).IC SCMPDS by A12,A13,A14,Lm1
       .= Next l2 by A13,A24,SCMPDS_2:68;
      hence x in {} by A18,A25,Th10;

      end;
      suppose that
A26:     s1.DataLoc(s1.a,k1) > 0 and
A27:     s2.DataLoc(s2.a,k1) <= 0;
      consider n1 being Element of SCM-Instr-Loc such that
A28:     n1 = l1 & Next l1 = Next n1 by SCMPDS_2:def 19;
      consider w1 being Nat such that
A29:     n1 = 2*w1+2 by SCMPDS_2:1;
A30:   x = Exec(i,s1).IC SCMPDS by A6,A7,A8,Lm1
       .= Next n1 by A7,A26,A28,SCMPDS_2:68
       .= n1 + 2 by AMI_2:def 15;
       x = Exec(i,s2).IC SCMPDS by A12,A13,A14,Lm1
       .= abs(m2-2+2*k2)+2 by A16,A27,SCMPDS_2:68;
      then A31:   2*w1+2 = abs(m2-2+2*k2) by A29,A30;
      thus x in {}
      proof
        per cases by A31,ABSVALUE:1;
        suppose 2*w1+2 = m2-2+2*k2;
        then 2*nl1+2 = 2*nl1 + 2*x1 + 2*k2 by A7,A9,A11,A17,A28,A29
         .= 2*nl1 + (2*x1 + 2*k2);
        hence x in {} by Lm7;
        end;
        suppose 2*w1+2 = -(m2-2+2*k2);
        then 2*nl1+2 = -(2*nl1+2*x1+2*k2) by A7,A9,A11,A17,A28,A29;
        hence x in {} by A3,Lm8;
      end;
      end;

      end;
      suppose that
A32:     s1.DataLoc(s1.a,k1) <= 0 and
A33:     s2.DataLoc(s2.a,k1) > 0;
      consider n2 being Element of SCM-Instr-Loc such that
A34:     n2 = l2 & Next l2 = Next n2 by SCMPDS_2:def 19;
      consider w2 being Nat such that
A35:     n2 = 2*w2+2 by SCMPDS_2:1;
A36:   x = Exec(i,s1).IC SCMPDS by A6,A7,A8,Lm1
       .= abs(m1-2+2*k2)+2 by A10,A32,SCMPDS_2:68;
       x = Exec(i,s2).IC SCMPDS by A12,A13,A14,Lm1
       .= Next n2 by A13,A33,A34,SCMPDS_2:68
       .= n2 + 2 by AMI_2:def 15;
      then A37:   2*w2+2 = abs(m1-2+2*k2) by A35,A36;
      thus x in {}
      proof
        per cases by A37,ABSVALUE:1;
        suppose
A38:       2*w2+2 = m1-2+2*k2;
         2*(nl2+1) = 2*nl2+2*1
          .= 2*nl1+2*k2 by A11,A13,A15,A17,A34,A35,A38
          .= 2*(nl1+k2);
        hence thesis by A1,Lm9;
        end;
        suppose 2*w2+2 = -(m1-2+2*k2);
        hence x in {} by A4,A11,A13,A15,A17,A34,A35,Lm10;
      end;
      end;
    end;
    end;
    thus thesis by XBOOLE_1:2;
  end;

Lm15:
  JUMP ((a,k1)>=0_goto 5) = {}
  proof
    set k2 = 5;
    set i = (a,k1)>=0_goto k2;
    set X = { NIC(i,l) where l is Instruction-Location of SCMPDS:
        not contradiction };
    hereby
      let x be set;
      assume
A1:     x in JUMP i;
      set nl1 = 5;
      set nl2 = 8;
      set l1 = inspos nl1;
A2:   NIC(i,l1) in X;
      x in NIC(i,l1) by A1,A2,SETFAM_1:def 1;
      then x in { IC Following s1 where s1 is State of SCMPDS:
           IC s1 = l1 & s1.l1 = i };
      then consider s1 being State of SCMPDS such that
A3:     x = IC Following s1 and
A4:     IC s1 = l1 and
A5:     s1.l1 = i;
      consider m1 being Nat such that
A6:     m1 = IC s1 and
A7:     ICplusConst(s1,k2) = abs(m1-2+2*k2)+2 by SCMPDS_2:def 20;
A8:   m1 = il.nl1 by A4,A6,SCMPDS_3:def 2
        .= 2*nl1+2 by AMI_3:def 20;

      set l2 = inspos nl2;
       NIC(i,l2) in X;
      then x in NIC(i,l2) by A1,SETFAM_1:def 1;
      then x in { IC Following s2 where s2 is State of SCMPDS:
           IC s2 = l2 & s2.l2 = i };
      then consider s2 being State of SCMPDS such that
A9:     x = IC Following s2 and
A10:     IC s2 = l2 and
A11:     s2.l2 = i;
      consider m2 being Nat such that
A12:     m2 = IC s2 and
A13:     ICplusConst(s2,k2) = abs(m2-2+2*k2)+2 by SCMPDS_2:def 20;
A14:   m2 = il.nl2 by A10,A12,SCMPDS_3:def 2
        .= 2*nl2+2 by AMI_3:def 20;
A15:   l1 <> l2 by SCMPDS_3:31;

      per cases;
      suppose that
A16:     s1.DataLoc(s1.a,k1) >= 0 and
A17:     s2.DataLoc(s2.a,k1) >= 0;
A18:   x = Exec(i,s1).IC SCMPDS by A3,A4,A5,Lm1
       .= abs(m1-2+2*k2)+2 by A7,A16,SCMPDS_2:69;
       x = Exec(i,s2).IC SCMPDS by A9,A10,A11,Lm1
       .= abs(m2-2+2*k2)+2 by A13,A17,SCMPDS_2:69;
      then abs(m1-2+2*k2) = abs(m2-2+2*k2) by A18;
      then 2*nl1+2-2+2*k2 = 2*nl2+2-2+2*k2 or
        2*nl1+2-2+2*k2 = -(2*nl2+2-2+2*k2) by A8,A14,Th3;
      hence x in {};

      end;
      suppose that
A19:     s1.DataLoc(s1.a,k1) < 0 and
A20:     s2.DataLoc(s2.a,k1) < 0;
A21:   x = Exec(i,s1).IC SCMPDS by A3,A4,A5,Lm1
       .= Next l1 by A4,A19,SCMPDS_2:69;
       x = Exec(i,s2).IC SCMPDS by A9,A10,A11,Lm1
       .= Next l2 by A10,A20,SCMPDS_2:69;
      hence x in {} by A15,A21,Th10;

      end;
      suppose that
A22:     s1.DataLoc(s1.a,k1) < 0 and
A23:     s2.DataLoc(s2.a,k1) >= 0;
      consider n1 being Element of SCM-Instr-Loc such that
A24:     n1 = l1 & Next l1 = Next n1 by SCMPDS_2:def 19;
      consider w1 being Nat such that
A25:     n1 = 2*w1+2 by SCMPDS_2:1;
A26:   x = Exec(i,s1).IC SCMPDS by A3,A4,A5,Lm1
       .= Next n1 by A4,A22,A24,SCMPDS_2:69
       .= n1 + 2 by AMI_2:def 15;
       x = Exec(i,s2).IC SCMPDS by A9,A10,A11,Lm1
       .= abs(m2-2+2*k2)+2 by A13,A23,SCMPDS_2:69;
      then 2*w1+2 = abs(m2-2+2*k2) by A25,A26;
      then 2*w1+2 = m2-2+2*k2 or 2*w1+2 = -(m2-2+2*k2) by ABSVALUE:1;
      hence x in {} by A4,A6,A8,A14,A24,A25;
      end;
      suppose that
A27:     s1.DataLoc(s1.a,k1) >= 0 and
A28:     s2.DataLoc(s2.a,k1) < 0;
      consider n2 being Element of SCM-Instr-Loc such that
A29:     n2 = l2 & Next l2 = Next n2 by SCMPDS_2:def 19;
      consider w2 being Nat such that
A30:     n2 = 2*w2+2 by SCMPDS_2:1;
A31:   x = Exec(i,s1).IC SCMPDS by A3,A4,A5,Lm1
       .= abs(m1-2+2*k2)+2 by A7,A27,SCMPDS_2:69;
       x = Exec(i,s2).IC SCMPDS by A9,A10,A11,Lm1
       .= Next n2 by A10,A28,A29,SCMPDS_2:69
       .= n2 + 2 by AMI_2:def 15;
      then 2*w2+2 = abs(m1-2+2*k2) by A30,A31;
      then 2*w2+2 = m1-2+2*k2 or 2*w2+2 = -(m1-2+2*k2) by ABSVALUE:1;
      hence x in {} by A8,A10,A12,A14,A29,A30;
    end;
    end;
    thus thesis by XBOOLE_1:2;
  end;

Lm16:
  k2 <> 5 implies JUMP ((a,k1)>=0_goto k2) = {}
  proof
    assume
A1:   k2 <> 5;
    set i = (a,k1)>=0_goto k2;
    set X = { NIC(i,l) where l is Instruction-Location of SCMPDS:
        not contradiction };
    hereby
      let x be set;
      assume
A2:     x in JUMP i;
      set x1 = -k2+abs(k2)+4;
       x1 > -k2+abs(k2)+0 by XREAL_1:8;
      then A3:   x1 > 0 by Th2;
      then reconsider x1 as Nat by INT_1:16;
A4:   -(2*x1+(1+x1)) < -0 by A3,Lm5;
      set nl1 = abs(k2)+x1;
      set nl2 = nl1+x1;
      set l1 = inspos nl1;
A5:   NIC(i,l1) in X;
      x in NIC(i,l1) by A2,A5,SETFAM_1:def 1;
      then x in { IC Following s1 where s1 is State of SCMPDS:
           IC s1 = l1 & s1.l1 = i };
      then consider s1 being State of SCMPDS such that
A6:     x = IC Following s1 and
A7:     IC s1 = l1 and
A8:     s1.l1 = i;
      consider m1 being Nat such that
A9:     m1 = IC s1 and
A10:     ICplusConst(s1,k2) = abs(m1-2+2*k2)+2 by SCMPDS_2:def 20;
A11:   m1 = il.nl1 by A7,A9,SCMPDS_3:def 2
        .= 2*nl1+2 by AMI_3:def 20;

      set l2 = inspos nl2;
       NIC(i,l2) in X;
      then x in NIC(i,l2) by A2,SETFAM_1:def 1;
      then x in { IC Following s2 where s2 is State of SCMPDS:
           IC s2 = l2 & s2.l2 = i };
      then consider s2 being State of SCMPDS such that
A12:     x = IC Following s2 and
A13:     IC s2 = l2 and
A14:     s2.l2 = i;
      consider m2 being Nat such that
A15:     m2 = IC s2 and
A16:     ICplusConst(s2,k2) = abs(m2-2+2*k2)+2 by SCMPDS_2:def 20;
A17:   m2 = il.nl2 by A13,A15,SCMPDS_3:def 2
        .= 2*nl2+2 by AMI_3:def 20;
      nl1 <> nl2 by A3;
      then A18:   l1 <> l2 by SCMPDS_3:31;

      per cases;
      suppose that
A19:     s1.DataLoc(s1.a,k1) >= 0 and
A20:     s2.DataLoc(s2.a,k1) >= 0;
A21:   x = Exec(i,s1).IC SCMPDS by A6,A7,A8,Lm1
       .= abs(m1-2+2*k2)+2 by A10,A19,SCMPDS_2:69;
       x = Exec(i,s2).IC SCMPDS by A12,A13,A14,Lm1
       .= abs(m2-2+2*k2)+2 by A16,A20,SCMPDS_2:69;
      then A22:   abs(m1-2+2*k2) = abs(m2-2+2*k2) by A21;
      thus x in {}
      proof
        per cases by A11,A17,A22,Th3;
        suppose 2*nl1+2-2+2*k2 = 2*nl2+2-2+2*k2;
        then nl1+0 = nl2;
        hence x in {} by A3;
        end;
        suppose 2*nl1+2-2+2*k2 = -(2*nl2+2-2+2*k2);
        hence x in {} by Lm6;
      end;
      end;

      end;
      suppose that
A23:     s1.DataLoc(s1.a,k1) < 0 and
A24:     s2.DataLoc(s2.a,k1) < 0;
A25:   x = Exec(i,s1).IC SCMPDS by A6,A7,A8,Lm1
       .= Next l1 by A7,A23,SCMPDS_2:69;
       x = Exec(i,s2).IC SCMPDS by A12,A13,A14,Lm1
       .= Next l2 by A13,A24,SCMPDS_2:69;
      hence x in {} by A18,A25,Th10;

      end;
      suppose that
A26:     s1.DataLoc(s1.a,k1) < 0 and
A27:     s2.DataLoc(s2.a,k1) >= 0;
      consider n1 being Element of SCM-Instr-Loc such that
A28:     n1 = l1 & Next l1 = Next n1 by SCMPDS_2:def 19;
      consider w1 being Nat such that
A29:     n1 = 2*w1+2 by SCMPDS_2:1;
A30:   x = Exec(i,s1).IC SCMPDS by A6,A7,A8,Lm1
       .= Next n1 by A7,A26,A28,SCMPDS_2:69
       .= n1 + 2 by AMI_2:def 15;
       x = Exec(i,s2).IC SCMPDS by A12,A13,A14,Lm1
       .= abs(m2-2+2*k2)+2 by A16,A27,SCMPDS_2:69;
      then A31:   2*w1+2 = abs(m2-2+2*k2) by A29,A30;
      thus x in {}
      proof
        per cases by A31,ABSVALUE:1;
        suppose 2*w1+2 = m2-2+2*k2;
        then 2*nl1+2 = 2*nl1 + 2*x1 + 2*k2 by A7,A9,A11,A17,A28,A29
         .= 2*nl1 + (2*x1 + 2*k2);
        hence x in {} by Lm7;
        end;
        suppose 2*w1+2 = -(m2-2+2*k2);
        then 2*nl1+2 = -(2*nl1+2*x1+2*k2) by A7,A9,A11,A17,A28,A29;
        hence x in {} by A3,Lm8;
      end;
      end;

      end;
      suppose that
A32:     s1.DataLoc(s1.a,k1) >= 0 and
A33:     s2.DataLoc(s2.a,k1) < 0;
      consider n2 being Element of SCM-Instr-Loc such that
A34:     n2 = l2 & Next l2 = Next n2 by SCMPDS_2:def 19;
      consider w2 being Nat such that
A35:     n2 = 2*w2+2 by SCMPDS_2:1;
A36:   x = Exec(i,s1).IC SCMPDS by A6,A7,A8,Lm1
       .= abs(m1-2+2*k2)+2 by A10,A32,SCMPDS_2:69;
       x = Exec(i,s2).IC SCMPDS by A12,A13,A14,Lm1
       .= Next n2 by A13,A33,A34,SCMPDS_2:69
       .= n2 + 2 by AMI_2:def 15;
      then A37:   2*w2+2 = abs(m1-2+2*k2) by A35,A36;
      thus x in {}
      proof
        per cases by A37,ABSVALUE:1;
        suppose
A38:       2*w2+2 = m1-2+2*k2;
         2*(nl2+1) = 2*nl2+2*1
          .= 2*nl1+2*k2 by A11,A13,A15,A17,A34,A35,A38
          .= 2*(nl1+k2);
        hence thesis by A1,Lm9;
        end;
        suppose 2*w2+2 = -(m1-2+2*k2);
        hence x in {} by A4,A11,A13,A15,A17,A34,A35,Lm10;
      end;
      end;
    end;
    end;
    thus thesis by XBOOLE_1:2;
  end;

registration
  let a,k1,k2;
  cluster JUMP ((a,k1)<>0_goto k2) -> empty;
coherence
  proof
     k2 = 5 or k2 <> 5;
    hence thesis by Lm11,Lm12;
  end;
  cluster JUMP ((a,k1)<=0_goto k2) -> empty;
coherence
  proof
     k2 = 5 or k2 <> 5;
    hence thesis by Lm13,Lm14;
  end;
  cluster JUMP ((a,k1)>=0_goto k2) -> empty;
coherence
  proof
     k2 = 5 or k2 <> 5;
    hence thesis by Lm15,Lm16;
  end;
end;

theorem Th29:
  SUCC(l) = the Instruction-Locations of SCMPDS
  proof
    thus SUCC(l) c= the Instruction-Locations of SCMPDS;
    let x be set;
    assume x in the Instruction-Locations of SCMPDS;
    then reconsider x as Instruction-Location of SCMPDS;
    set X = { NIC(i,l) \ JUMP i where
     i is Element of the Instructions of SCMPDS: not contradiction };
    set i = goto (locnum x - locnum l);
     NIC(i,l) = { 2*abs(locnum x - locnum l + locnum l) + 2 } by Th14
      .= { 2*locnum x + 2 } by ABSVALUE:def 1
      .= {x} by Th8;
    then A1: x in NIC(i,l) by TARSKI:def 1;
     NIC(i,l) \ JUMP i in X;
    then x in union X by A1,TARSKI:def 4;
    hence thesis;
  end;

theorem Th30:
  for N being with_non-empty_elements set,
      S being IC-Ins-separated definite (non empty non void AMI-Struct over N),
      l1, l2 being Instruction-Location of S
    st SUCC(l1) = the Instruction-Locations of S
   holds l1 <= l2
  proof
    let N be with_non-empty_elements set,
        S be IC-Ins-separated definite (non empty non void AMI-Struct over N),
        l1, l2 be Instruction-Location of S such that
A1:   SUCC(l1) = the Instruction-Locations of S;
    defpred P[set,set] means
      ($1 = 1 implies $2 = l1) & ($1 = 2 implies $2 = l2);
A2: for n being Nat st n in Seg 2
     ex d being Element of the Instruction-Locations of S st P[n,d]
    proof
      let n be Nat;
      assume
A3:     n in Seg 2;
      per cases by A3,FINSEQ_1:4,TARSKI:def 2;
      suppose
A4:     n = 1;
      take l1;
      thus P[n,l1] by A4;
      end;
      suppose
A5:     n = 2;
      take l2;
      thus P[n,l2] by A5;
    end;
    end;
    consider f being FinSequence of the Instruction-Locations of S such that
A6:   len f = 2 and
A7:   for n being Nat st n in Seg 2 holds P[n,f/.n] from GOBOARD1:sch 1(A2);
A8: 1 in Seg 2 & 2 in Seg 2 by FINSEQ_1:4,TARSKI:def 2;
     dom f = Seg 2 by A6,FINSEQ_1:def 3;
    then ex y being set st [1,y] in f by A8,RELAT_1:def 4;
    then reconsider f as non empty FinSequence of the Instruction-Locations of
S;
    take f;
    thus f/.1 = l1 & f/.len f = l2 by A6,A7,A8;
    let n be Nat;
    assume
A9:   1 <= n;
    assume n < len f;
    then n < 1+1 by A6;
    then n <= 1 by NAT_1:38;
    then n = 1 by A9,XREAL_1:1;
    then f/.n = l1 by A7,A8;
    hence f/.(n+1) in SUCC f/.n by A1;
  end;

registration
  cluster SCMPDS -> non InsLoc-antisymmetric;
  coherence
  proof
    assume
A1:   SCMPDS is InsLoc-antisymmetric;
     SUCC(inspos(1)) = the Instruction-Locations of SCMPDS &
    SUCC(inspos(2)) = the Instruction-Locations of SCMPDS by Th29;
    then inspos(1) <= inspos(2) & inspos(2) <= inspos(1) by Th30;
    then inspos(1) = inspos(2) by A1,AMISTD_1:def 9;
    hence thesis by SCMPDS_3:31;
  end;
end;

registration
  cluster SCMPDS -> non standard;
  coherence by AMISTD_1:30;
end;

