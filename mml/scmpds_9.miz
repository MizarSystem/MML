:: SCMPDS Is Not Standard
::  by Artur Korni{\l}owicz and Yasunari Shidama
::
:: Received September 27, 2003
:: Copyright (c) 2003 Association of Mizar Users

environ

 vocabularies NUMBERS, SCMPDS_2, AMI_1, INT_1, FUNCOP_1, SUBSET_1, FSM_1,
      FUNCT_1, AMISTD_1, FUNCT_4, XBOOLE_0, SETFAM_1, AMI_3,
      COMPLEX1, ARYTM_3, ORDINAL1, XXREAL_0, ARYTM_1, CARD_1, AMI_2, RELAT_1,
      GRAPHSP, TARSKI, FINSET_1, XREAL_0, CARD_3, AMI_WSTD;
 notations TARSKI, XBOOLE_0, SUBSET_1, SETFAM_1, ORDINAL1, CARD_3, NUMBERS,
      XCMPLX_0, XXREAL_0, XREAL_0, FUNCT_1, INT_1, NAT_1, FINSET_1, COMPLEX1,
      INT_2, PARTFUN1, FUNCOP_1, RELAT_1, FUNCT_4, COMPOS_1, EXTPRO_1,
      AMI_1, AMI_2,
      SCMPDS_2,
      SCMPDS_3, AMISTD_1, AMI_WSTD;
 constructors XXREAL_0, REAL_1, NAT_D, REALSET1, SCMPDS_1, SCMPDS_3, AMI_WSTD,
      PRE_POLY, AMISTD_1, AMI_1;
 registrations SETFAM_1, ORDINAL1, RELSET_1, NUMBERS, XXREAL_0, XREAL_0, NAT_1,
      INT_1, MEMBERED, CARD_3, SCMPDS_2, FUNCT_1, AMI_1, FUNCT_2, XBOOLE_0,
      FUNCOP_1, FUNCT_4, AMISTD_1, COMPOS_1;
 requirements BOOLE, SUBSET, NUMERALS, ARITHM, REAL;
 definitions TARSKI, XBOOLE_0, NAT_1, AMI_WSTD, AMISTD_1, COMPOS_1;
 theorems AMI_WSTD, SETFAM_1, XBOOLE_0, SCMPDS_1, SCMPDS_2, ABSVALUE,
      INT_1, TARSKI, AMI_2, NAT_1, XBOOLE_1, FUNCT_4, PRE_CIRC, WSIERP_1,
      PEPIN, COMPLEX1, XREAL_1, FUNCT_7, NAT_D, ZFMISC_1, PBOOLE, AMISTD_1,
      COMPOS_1, EXTPRO_1;

begin

reserve a, b for Int_position,
  i for Instruction of SCMPDS,
  l for Element of NAT,
  k, k1, k2 for Integer;

definition
  let la, lb be Int_position, a, b be Integer;
  redefine func (la,lb) --> (a,b) -> FinPartState of SCMPDS;
  coherence
  proof
A1: ObjectKind la = INT & ObjectKind lb = INT by SCMPDS_2:13;
    a is Element of INT & b is Element of INT by INT_1:def 2;
    hence thesis by A1,COMPOS_1:4;
  end;
end;

canceled 6;

Lm2: JUMP goto k = {}
proof
  set i = goto k;

  set X = { NIC(i,l) where l is Element of NAT: not
  contradiction };

  hereby
    set l2 =  1;
    set l1 =  0;
    let x be set;
    assume
A1: x in JUMP i;
    NIC(i,l2) in X;
    then x in NIC(i,l2) by A1,SETFAM_1:def 1;
    then consider s2 being Element of product the Object-Kind of SCMPDS
    such that
A2: x = IC Exec(i,s2) and
A3: IC s2 = l2;
    consider m2 being Element of NAT such that
A5: m2 = IC s2 and
A6: ICplusConst(s2,k) = abs(m2+k) by SCMPDS_2:def 20;
    NIC(i,l1) in X;
    then x in NIC(i,l1) by A1,SETFAM_1:def 1;
    then consider s1 being Element of product the Object-Kind of SCMPDS
    such that
A8: x = IC Exec(i,s1) and
A9: IC s1 = l1;
    consider m1 being Element of NAT such that
A11: m1 = IC s1 and
A12: ICplusConst(s1,k) = abs(m1+k) by SCMPDS_2:def 20;
A13: x = abs(m1+k) by A8,A12,SCMPDS_2:66;
    per cases by A9,A11,A13,A3,A5,A2,A6,SCMPDS_2:66,ABSVALUE:45;
    suppose
      0+k = 1+k;
      hence x in {};
    end;
    suppose
      k = -(1+k);
      then --1/2 is integer;
      hence x in {} by NAT_D:33;
    end;
  end;
  thus thesis by XBOOLE_1:2;
end;

registration
  let k;
  cluster JUMP (goto k) -> empty;
  coherence by Lm2;
end;

theorem Th7:
  (for s being State of SCMPDS st IC s = l
   holds Exec(i,s).IC SCMPDS = succ IC s) implies NIC(i, l) = {succ l}
proof
  consider t being State of SCMPDS;
  reconsider I = i as Instruction of SCMPDS;
  reconsider n = l as Element of NAT;
  assume
A1: for s being State of SCMPDS st IC s = l
     holds Exec(i, s).IC SCMPDS = succ IC s;
  hereby
    let x be set;
    assume x in NIC(i,l);
    then consider s being Element of product the Object-Kind of SCMPDS
    such that
A2: x = IC Exec(i,s) and
A3: IC s = l;
    x = succ l by A1,A2,A3;
    hence x in {succ l} by TARSKI:def 1;
  end;
  reconsider il1 = l as Element of ObjectKind IC SCMPDS by COMPOS_1:def 6;
  (IC SCMPDS, l)-->(il1, I)
   =  (IC SCMPDS .--> il1)+*(l .--> I) by FUNCT_4:def 4;
  then reconsider u = t+*((IC SCMPDS, l)-->(il1, i))
     as Element of product the Object-Kind of SCMPDS by PBOOLE:155;
A4: IC u = n & u.n = I by EXTPRO_1:26;
  let x be set;
  assume x in {succ l};
  then
A5: x = succ l by TARSKI:def 1;
 IC Exec(I,u) = succ l by A1,A4;
  hence thesis by A5,A4;
end;

theorem Th8:
  (for l being Element of NAT holds NIC(i,l)={succ
  l}) implies JUMP i is empty
proof
  set p=1, q=2;
  assume
A1: for l being Element of NAT holds NIC(i,l)={succ l};
  set X = { NIC(i,f) where f is Element of NAT: not
  contradiction };
  reconsider p, q as Element of NAT;
  assume not thesis;
  then consider x being set such that
A2: x in meet X by XBOOLE_0:def 1;
  NIC(i,p) = {succ p} by A1;
  then {succ p} in X;
  then x in {succ p} by A2,SETFAM_1:def 1;
  then
A3: x = succ p by TARSKI:def 1;
  NIC(i,q) = {succ q} by A1;
  then {succ q} in X;
  then x in {succ q} by A2,SETFAM_1:def 1;
  hence contradiction by A3,TARSKI:def 1;
end;

theorem Th9:
  NIC(goto k,l) = { abs(k+ l) }
proof
  consider s being State of SCMPDS;
  set i = goto k;
  set t = abs(k+ l);
  reconsider I = i as Element of (the Object-Kind of SCMPDS).l by
COMPOS_1:def 8;
  reconsider n = l as Element of NAT;
  reconsider il1 = l as Element of ObjectKind IC SCMPDS by COMPOS_1:def 6;
  (IC SCMPDS, l)-->(il1, I)
   =  (IC SCMPDS .--> il1)+*(l .--> I) by FUNCT_4:def 4;
  then reconsider u = s+*((IC SCMPDS, l)-->(il1, i))
     as Element of product the Object-Kind of SCMPDS by PBOOLE:155;
  hereby
    let x be set;
    assume x in NIC(i,l);
    then consider s being Element of product the Object-Kind of SCMPDS
    such that
A3: x = IC Exec(i,s) and
A4: IC s = l;
A6: ex m1 being Element of NAT st m1 = IC s & ICplusConst(s,k ) = abs(m1+k)
    by SCMPDS_2:def 20;
    x = t by A3,A4,A6,SCMPDS_2:66;
    hence x in {t} by TARSKI:def 1;
  end;
  let x be set;
A7: IC u = n by EXTPRO_1:26;
  consider m1 being Element of NAT such that
A8: m1 = IC u and
A9: ICplusConst(u,k) = abs(m1+k) by SCMPDS_2:def 20;
  assume x in {t};
  then x = abs(m1+k) by A7,A8,TARSKI:def 1
    .= IC Exec(i,u) by A9,SCMPDS_2:66;
  hence thesis by A7;
end;

Lm1: for k being natural number st k > 1 holds k-2 is Element of NAT
proof
  let k be natural number;
  assume k > 1;
  then k >= 1+1 by NAT_1:13;
  then k - 2 >= 2 - 2 by XREAL_1:11;
  hence thesis by INT_1:16;
end;

theorem Th10:
  NIC(return a,l) = {k where k is Element of NAT: k > 1}
proof
  consider s being State of SCMPDS;
  set X = {k where k is Element of NAT: k > 1};
  set i = return a;
  hereby
    let x be set;
    assume x in NIC(i,l);
    then consider s being Element of product the Object-Kind of SCMPDS
    such that
A1: x = IC Exec(i,s) and
    IC s = l;
    reconsider k = x as Element of NAT by A1;
A4: (abs(s.DataLoc(s.a,1)) )+2 >= 0+2 by XREAL_1:8;
    k >= 1+1 by A4,A1,SCMPDS_1:def 23,SCMPDS_2:70;
    then k > 1 by NAT_1:13;
    hence x in X;
  end;
  let x be set;
  reconsider I = i as Element of (the Object-Kind of SCMPDS).l by
COMPOS_1:def 8;
  reconsider n = l as Element of NAT;
  assume x in X;
  then consider k being Element of NAT such that
A5: x = k and
A6: k > 1;
  reconsider il1 = l as Element of ObjectKind IC SCMPDS by COMPOS_1:def 6;
  reconsider k2 = k - 2 as Element of NAT by A6,Lm1;
  (IC SCMPDS, l)-->(il1, I)
   =  (IC SCMPDS .--> il1)+*(l .--> I) by FUNCT_4:def 4;
  then reconsider u = s+*((IC SCMPDS, l)-->(il1, I))
     as Element of product the Object-Kind of SCMPDS by PBOOLE:155;
A7: u.IC SCMPDS = IC u
    .= n by EXTPRO_1:26;
  a in SCM-Data-Loc by SCMPDS_2:def 2;
  then consider j being Element of NAT such that
A8: a = [1,j] by AMI_2:32;
  set t = [1,j+1];
  reconsider t1 = t as Int_position by AMI_2:33,SCMPDS_2:9;
A9: DataLoc(j,1) = [1,abs(j+1)] by SCMPDS_2:def 4
    .= t by ABSVALUE:def 1;
  set g = (a,t1)-->(j,k2);
  reconsider v = u +* g
     as Element of product the Object-Kind of SCMPDS by PBOOLE:155;
A10: dom g = {a,t} by FUNCT_4:65;
  j <> j+1;
  then
A11: a <> t by A8,ZFMISC_1:33;
  then
A12: v.a = j by FUNCT_4:89;
  a <> IC SCMPDS & t1 <> IC SCMPDS by SCMPDS_2:52;
  then
A14: not IC SCMPDS in dom g by A10,TARSKI:def 2;
A15: IC v = l by A7,A14,FUNCT_4:12;
A16: v.t = k2 by A11,FUNCT_4:89;
  x = ((k2 ) + 2) by A5
    .= (abs(v.DataLoc(j,1)) ) + 2 by A16,A9,ABSVALUE:def 1
    .= IC Exec(i,v) by A12,SCMPDS_1:def 23,SCMPDS_2:70;
  hence thesis by A15;
end;

theorem Th11:
  NIC(saveIC(a,k1), l) = {succ l}
proof
  set i = saveIC(a,k1);
  for s being State of SCMPDS st IC s = l holds Exec(i,s).IC
  SCMPDS = succ IC s by SCMPDS_2:71;
  hence thesis by Th7;
end;

theorem Th12:
  NIC(a:=k1, l) = {succ l}
proof
  set i = a:=k1;
  for s being State of SCMPDS st IC s = l holds Exec(i,s).IC
  SCMPDS = succ IC s by SCMPDS_2:57;
  hence thesis by Th7;
end;

theorem Th13:
  NIC((a,k1):=k2, l) = {succ l}
proof
  set i = (a,k1):=k2;
  for s being State of SCMPDS st IC s = l holds Exec(i,s).IC
  SCMPDS = succ IC s by SCMPDS_2:58;
  hence thesis by Th7;
end;

theorem Th14:
  NIC((a,k1):=(b,k2), l) = {succ l}
proof
  set i = (a,k1):=(b,k2);
  for s being State of SCMPDS st IC s = l holds Exec(i,s).IC
  SCMPDS = succ IC s by SCMPDS_2:59;
  hence thesis by Th7;
end;

theorem Th15:
  NIC(AddTo(a,k1,k2), l) = {succ l}
proof
  set i = AddTo(a,k1,k2);
  for s being State of SCMPDS st IC s = l holds Exec(i,s).IC
  SCMPDS = succ IC s by SCMPDS_2:60;
  hence thesis by Th7;
end;

theorem Th16:
  NIC(AddTo(a,k1,b,k2), l) = {succ l}
proof
  set i = AddTo(a,k1,b,k2);
  for s being State of SCMPDS st IC s = l holds Exec(i,s).IC
  SCMPDS = succ IC s by SCMPDS_2:61;
  hence thesis by Th7;
end;

theorem Th17:
  NIC(SubFrom(a,k1,b,k2), l) = {succ l}
proof
  set i = SubFrom(a,k1,b,k2);
  for s being State of SCMPDS st IC s = l holds Exec(i,s).IC
  SCMPDS = succ IC s by SCMPDS_2:62;
  hence thesis by Th7;
end;

theorem Th18:
  NIC(MultBy(a,k1,b,k2), l) = {succ l}
proof
  set i = MultBy(a,k1,b,k2);
  for s being State of SCMPDS st IC s = l holds Exec(i,s).IC
  SCMPDS = succ IC s by SCMPDS_2:63;
  hence thesis by Th7;
end;

theorem Th19:
  NIC(Divide(a,k1,b,k2), l) = {succ l}
proof
  set i = Divide(a,k1,b,k2);
  for s being State of SCMPDS st IC s = l holds Exec(i,s).IC
  SCMPDS = succ IC s by SCMPDS_2:64;
  hence thesis by Th7;
end;

theorem
  NIC((a,k1)<>0_goto k2,l) = { succ l, abs( (k2+ l) ) }
proof
  consider s being State of SCMPDS;
  set i = (a,k1)<>0_goto k2;
  set t = abs((k2+ l));
  reconsider I = i as Element of (the Object-Kind of SCMPDS).l by
COMPOS_1:def 8;
  reconsider n = l as Element of NAT;
  reconsider il1 = l as Element of ObjectKind IC SCMPDS by COMPOS_1:def 6;
  (IC SCMPDS, l)-->(il1, I)
   =  (IC SCMPDS .--> il1)+*(l .--> I) by FUNCT_4:def 4;
  then reconsider u = s+*((IC SCMPDS, l)-->(il1, i))
     as Element of product the Object-Kind of SCMPDS by PBOOLE:155;
  hereby
    let x be set;
    assume x in NIC(i,l);
    then consider s being Element of product the Object-Kind of SCMPDS
    such that
A2: x = IC Exec(i,s) and
A3: IC s = l;
A5: ex m1 being Element of NAT st m1 = IC s & ICplusConst(s, k2) = abs(m1+
    k2) by SCMPDS_2:def 20;
    per cases;
    suppose
A6:   s.DataLoc(s.a,k1) <> 0;
      x = t by A2,A3,A5,A6,SCMPDS_2:67;
      hence x in {succ l,t} by TARSKI:def 2;
    end;
    suppose
A7:   s.DataLoc(s.a,k1) = 0;
      x = succ l by A2,A3,A7,SCMPDS_2:67;
      hence x in {succ l,t} by TARSKI:def 2;
    end;
  end;
  let x be set;
  assume
A8: x in {succ l,t};
  per cases by A8,TARSKI:def 2;
  suppose
A9: x = succ l;
    set u1 = u +* (a.-->0);
  reconsider u2 = u1 +* (DataLoc(u1.a,k1).-->0)
     as Element of product the Object-Kind of SCMPDS by PBOOLE:155;
A12: IC u2 = u1.IC SCMPDS by FUNCT_4:88,SCMPDS_2:52
      .= IC u by FUNCT_4:88,SCMPDS_2:52
      .= n by EXTPRO_1:26;
A13: u2.DataLoc(u1.a,k1) = 0 by FUNCT_7:96;
    u2.DataLoc(u2.a,k1) = 0
    proof
      per cases;
      suppose
        a = DataLoc(u1.a,k1);
        hence thesis by A13,FUNCT_7:96;
      end;
      suppose
        a <> DataLoc(u1.a,k1);
        then u2.a = u1.a by FUNCT_4:88;
        hence thesis by FUNCT_7:96;
      end;
    end;
    then x = IC Exec(i,u2) by A9,A12,SCMPDS_2:67;
    hence thesis by A12;
  end;
  suppose
A14: x = t;
    set u1 = u +* (a.-->1);
  reconsider u2 = u1 +* (DataLoc(u1.a,k1).-->1)
     as Element of product the Object-Kind of SCMPDS by PBOOLE:155;
A17: u2.DataLoc(u1.a,k1) = 1 by FUNCT_7:96;
A18: u2.DataLoc(u2.a,k1) <> 0
    proof
      per cases;
      suppose
        a = DataLoc(u1.a,k1);
        hence thesis by A17,FUNCT_7:96;
      end;
      suppose
        a <> DataLoc(u1.a,k1);
        then u2.a = u1.a by FUNCT_4:88;
        hence thesis by FUNCT_7:96;
      end;
    end;
A19: IC u2 = u1.IC SCMPDS by FUNCT_4:88,SCMPDS_2:52
      .= IC u by FUNCT_4:88,SCMPDS_2:52
      .= n by EXTPRO_1:26;
    ex m1 being Element of NAT st m1 = IC u2 & ICplusConst(u2,k2) = abs(
    m1+k2) by SCMPDS_2:def 20;
    then x = IC Exec(i,u2) by A14,A19,A18,SCMPDS_2:67;
    hence thesis by A19;
  end;
end;

theorem
  NIC((a,k1)<=0_goto k2,l) = { succ l, abs( (k2+ l) ) }
proof
  consider s being State of SCMPDS;
  set i = (a,k1)<=0_goto k2;
  set t = abs((k2+ l));
  reconsider I = i as Element of (the Object-Kind of SCMPDS).l by
COMPOS_1:def 8;
  reconsider n = l as Element of NAT;
  reconsider il1 = l as Element of ObjectKind IC SCMPDS by COMPOS_1:def 6;
  (IC SCMPDS, l)-->(il1, I)
   =  (IC SCMPDS .--> il1)+*(l .--> I) by FUNCT_4:def 4;
  then reconsider u = s+*((IC SCMPDS, l)-->(il1, i))
     as Element of product the Object-Kind of SCMPDS by PBOOLE:155;
  hereby
    let x be set;
    assume x in NIC(i,l);
    then consider s being Element of product the Object-Kind of SCMPDS
    such that
A2: x = IC Exec(i,s) and
A3: IC s = l;
A5: ex m1 being Element of NAT st m1 = IC s & ICplusConst(s, k2) = abs(m1+
    k2) by SCMPDS_2:def 20;
    per cases;
    suppose
A6:   s.DataLoc(s.a,k1) <= 0;
      x = t by A2,A3,A5,A6,SCMPDS_2:68;
      hence x in {succ l,t} by TARSKI:def 2;
    end;
    suppose
A7:   s.DataLoc(s.a,k1) > 0;
      x = succ l by A2,A3,A7,SCMPDS_2:68;
      hence x in {succ l,t} by TARSKI:def 2;
    end;
  end;
  let x be set;
  assume
A8: x in {succ l,t};
  per cases by A8,TARSKI:def 2;
  suppose
A9: x = succ l;
    set u1 = u +* (a.-->1);
  reconsider u2 = u1 +* (DataLoc(u1.a,k1).-->1)
     as Element of product the Object-Kind of SCMPDS by PBOOLE:155;
A12: IC u2 = u1.IC SCMPDS by FUNCT_4:88,SCMPDS_2:52
      .= IC u by FUNCT_4:88,SCMPDS_2:52
      .= n by EXTPRO_1:26;
A13: u2.DataLoc(u1.a,k1) = 1 by FUNCT_7:96;
    u2.DataLoc(u2.a,k1) > 0
    proof
      per cases;
      suppose a = DataLoc(u1.a,k1);
        hence thesis by A13,FUNCT_7:96;
      end;
      suppose
        a <> DataLoc(u1.a,k1);
        then u2.a = u1.a by FUNCT_4:88;
        hence thesis by FUNCT_7:96;
      end;
    end;
    then x = IC Exec(i,u2) by A9,A12,SCMPDS_2:68;
    hence thesis by A12;
  end;
  suppose
A14: x = t;
    set u1 = u +* (a.-->0);
  reconsider u2 = u1 +* (DataLoc(u1.a,k1).-->0)
     as Element of product the Object-Kind of SCMPDS by PBOOLE:155;
A17: u2.DataLoc(u1.a,k1) = 0 by FUNCT_7:96;
A18: u2.DataLoc(u2.a,k1) <= 0
    proof
      per cases;
      suppose
        a = DataLoc(u1.a,k1);
        hence thesis by A17,FUNCT_7:96;
      end;
      suppose
        a <> DataLoc(u1.a,k1);
        then u2.a = u1.a by FUNCT_4:88;
        hence thesis by FUNCT_7:96;
      end;
    end;
A19: IC u2 = u1.IC SCMPDS by FUNCT_4:88,SCMPDS_2:52
      .= IC u by FUNCT_4:88,SCMPDS_2:52
      .= n by EXTPRO_1:26;
    ex m1 being Element of NAT st m1 = IC u2 & ICplusConst(u2,k2) = abs(
    m1+k2) by SCMPDS_2:def 20;
    then x = IC Exec(i,u2) by A14,A19,A18,SCMPDS_2:68;
    hence thesis by A19;
  end;
end;

theorem
  NIC((a,k1)>=0_goto k2,l) = { succ l, abs( (k2+ l) ) }
proof
  consider s being State of SCMPDS;
  set i = (a,k1)>=0_goto k2;
  set t = abs((k2+ l));
  reconsider I = i as Element of (the Object-Kind of SCMPDS).l by
COMPOS_1:def 8;
  reconsider n = l as Element of NAT;
  reconsider il1 = l as Element of ObjectKind IC SCMPDS by COMPOS_1:def 6;
  (IC SCMPDS, l)-->(il1, I)
   =  (IC SCMPDS .--> il1)+*(l .--> I) by FUNCT_4:def 4;
  then reconsider u = s+*((IC SCMPDS, l)-->(il1, i))
     as Element of product the Object-Kind of SCMPDS by PBOOLE:155;
  hereby
    let x be set;
    assume x in NIC(i,l);
    then consider s being Element of product the Object-Kind of SCMPDS
    such that
A2: x = IC Exec(i,s) and
A3: IC s = l;
A5: ex m1 being Element of NAT st m1 = IC s & ICplusConst(s, k2) = abs(m1+
    k2) by SCMPDS_2:def 20;
    per cases;
    suppose
A6:   s.DataLoc(s.a,k1) >= 0;
      x = t by A2,A3,A5,A6,SCMPDS_2:69;
      hence x in {succ l,t} by TARSKI:def 2;
    end;
    suppose
A7:   s.DataLoc(s.a,k1) < 0;
      x = succ l by A2,A3,A7,SCMPDS_2:69;
      hence x in {succ l,t} by TARSKI:def 2;
    end;
  end;
  let x be set;
  assume
A8: x in {succ l,t};
  per cases by A8,TARSKI:def 2;
  suppose
A9: x = succ l;
A10: -1 < 0;
    set u1 = u +* (a.-->-1);
  reconsider u1 = u +* (a.-->-1)
     as Element of product the Object-Kind of SCMPDS by PBOOLE:155;
  reconsider u2 = u1 +* (DataLoc(u1.a,k1).-->-1)
     as Element of product the Object-Kind of SCMPDS by PBOOLE:155;
A13: IC u2 = u1.IC SCMPDS by FUNCT_4:88,SCMPDS_2:52
      .= IC u by FUNCT_4:88,SCMPDS_2:52
      .= n by EXTPRO_1:26;
A14: u2.DataLoc(u1.a,k1) = -1 by FUNCT_7:96;
    u2.DataLoc(u2.a,k1) < 0
    proof
      per cases;
      suppose
        a = DataLoc(u1.a,k1);
        hence thesis by A14,A10,FUNCT_7:96;
      end;
      suppose
        a <> DataLoc(u1.a,k1);
        then u2.a = u1.a by FUNCT_4:88;
        hence thesis by A10,FUNCT_7:96;
      end;
    end;
    then x = IC Exec(i,u2) by A9,A13,SCMPDS_2:69;
    hence thesis by A13;
  end;
  suppose
A15: x = t;
    set u1 = u +* (a.-->0);
  reconsider u1 = u +* (a.-->0)
     as Element of product the Object-Kind of SCMPDS by PBOOLE:155;
  reconsider u2 = u1 +* (DataLoc(u1.a,k1).-->0)
     as Element of product the Object-Kind of SCMPDS by PBOOLE:155;
A18: u2.DataLoc(u1.a,k1) = 0 by FUNCT_7:96;
A19: u2.DataLoc(u2.a,k1) >= 0
    proof
      per cases;
      suppose
        a = DataLoc(u1.a,k1);
        hence thesis by A18,FUNCT_7:96;
      end;
      suppose
        a <> DataLoc(u1.a,k1);
        then u2.a = u1.a by FUNCT_4:88;
        hence thesis by FUNCT_7:96;
      end;
    end;
A20: IC u2 = u1.IC SCMPDS by FUNCT_4:88,SCMPDS_2:52
      .= IC u by FUNCT_4:88,SCMPDS_2:52
      .= n by EXTPRO_1:26;
    ex m1 being Element of NAT st m1 = IC u2 & ICplusConst(u2,k2) = abs(
    m1+k2) by SCMPDS_2:def 20;
    then x = IC Exec(i,u2) by A15,A20,A19,SCMPDS_2:69;
    hence thesis by A20;
  end;
end;

theorem Th23:
  JUMP (return a) = {k where k is Element of NAT: k > 1}
proof
  set A = {k where k is Element of NAT: k > 1};
  set i = return a;
  set X = { NIC(i,l) where l is Element of NAT: not
  contradiction };
  JUMP i c= NIC(i,(0)) by AMISTD_1:58;
  hence JUMP i c= A by Th10;
  let x be set;
  assume
A1: x in A;
  now
    consider k being Element of NAT such that
A2: x = k and
A3: k > 1 by A1;
    reconsider k2 = k-2 as Element of NAT by A3,Lm1;
    NIC(i,(0)) in X;
    hence X <> {};
    a in SCM-Data-Loc by SCMPDS_2:def 2;
    then consider j being Element of NAT such that
A4: a = [1,j] by AMI_2:32;
    set t = [1,j+1];
    consider s being State of SCMPDS;
    let y be set;
A5: DataLoc(j,1) = [1,abs(j+1)] by SCMPDS_2:def 4
      .= t by ABSVALUE:def 1;
    reconsider t1 = t as Int_position by AMI_2:33,SCMPDS_2:9;
    assume y in X;
    then consider l being Element of NAT such that
A6: y = NIC(i,l);
  reconsider n = l as Element of NAT;
    reconsider il1 = l as Element of ObjectKind IC SCMPDS by COMPOS_1:def 6;
    reconsider I = i as Element of (the Object-Kind of SCMPDS).l
     by COMPOS_1:def 8;
  (IC SCMPDS, l)-->(il1, I)
   =  (IC SCMPDS .--> il1)+*(l .--> I) by FUNCT_4:def 4;
  then reconsider u = s+*((IC SCMPDS, l)-->(il1, i))
     as Element of product the Object-Kind of SCMPDS by PBOOLE:155;
A7: u.IC SCMPDS = IC u
      .= n by EXTPRO_1:26;
    set g = (a,t1)-->(j,k2);
  reconsider v = u +* g
     as Element of product the Object-Kind of SCMPDS by PBOOLE:155;
    j <> j+1;
    then
A8: a <> t1 by A4,ZFMISC_1:33;
    then
A9: v.a = j by FUNCT_4:89;
A10: v.t1 = k2 by A8,FUNCT_4:89;
A11: dom g = {a,t1} by FUNCT_4:65;
    a <> IC SCMPDS & t1 <> IC SCMPDS by SCMPDS_2:52;
    then
A13: not IC SCMPDS in dom g by A11,TARSKI:def 2;
A14: IC v = l by A7,A13,FUNCT_4:12;
    x = ((k2 ) + 2) by A2
      .= (abs(v.DataLoc(j,1)) ) + 2 by A10,A5,ABSVALUE:def 1
      .= IC Exec(i,v) by A9,SCMPDS_1:def 23,SCMPDS_2:70;
    hence x in y by A6,A14;
  end;
  hence thesis by SETFAM_1:def 1;
end;

registration
  let a;
  cluster JUMP (return a) -> infinite;
  coherence by Th23,PRE_CIRC:29;
end;

registration
  let a,k1;
  cluster JUMP (saveIC(a,k1)) -> empty;
  coherence
  proof
    for l being Element of NAT holds NIC(saveIC(a,k1),l)={
    succ l} by Th11;
    hence thesis by Th8;
  end;
end;

registration
  let a,k1;
  cluster JUMP (a:=k1) -> empty;
  coherence
  proof
    for l being Element of NAT holds NIC(a:=k1,l)={succ l}
    by Th12;
    hence thesis by Th8;
  end;
end;

registration
  let a,k1,k2;
  cluster JUMP ((a,k1):=k2) -> empty;
  coherence
  proof
    for l being Element of NAT holds NIC((a,k1):=k2,l)={
    succ l } by Th13;
    hence thesis by Th8;
  end;
end;

registration
  let a,b,k1,k2;
  cluster JUMP ((a,k1):=(b,k2)) -> empty;
  coherence
  proof
    for l being Element of NAT holds NIC((a,k1):=(b,k2),l)
    ={succ l} by Th14;
    hence thesis by Th8;
  end;
end;

registration
  let a,k1,k2;
  cluster JUMP (AddTo(a,k1,k2)) -> empty;
  coherence
  proof
    for l being Element of NAT holds NIC(AddTo(a,k1,k2),l)
    ={succ l} by Th15;
    hence thesis by Th8;
  end;
end;

registration
  let a,b,k1,k2;
  cluster JUMP (AddTo(a,k1,b,k2)) -> empty;
  coherence
  proof
    for l being Element of NAT holds NIC(AddTo(a,k1,b,k2),
    l)={succ l} by Th16;
    hence thesis by Th8;
  end;
  cluster JUMP (SubFrom(a,k1,b,k2)) -> empty;
  coherence
  proof
    for l being Element of NAT holds NIC(SubFrom(a,k1,b,k2
    ),l)={succ l} by Th17;
    hence thesis by Th8;
  end;
  cluster JUMP (MultBy(a,k1,b,k2)) -> empty;
  coherence
  proof
    for l being Element of NAT holds NIC(MultBy(a,k1,b,k2)
    ,l)={succ l} by Th18;
    hence thesis by Th8;
  end;
  cluster JUMP (Divide(a,k1,b,k2)) -> empty;
  coherence
  proof
    for l being Element of NAT holds NIC(Divide(a,k1,b,k2)
    ,l)={succ l} by Th19;
    hence thesis by Th8;
  end;
end;

Lm3: 5/3 is not integer
proof
  not 3 qua Integer divides 5
  proof
    assume not thesis;
    then
A1: 5 mod 3 = 0 by PEPIN:6;
    5 = 3 * 1 + 2;
    hence contradiction by A1,NAT_D:def 2;
  end;
  hence thesis by WSIERP_1:22;
end;

Lm4: for d being real number holds (abs(d)+(-d+abs(d)+4))+2-2+d <> -((abs(d)+(
-d+abs(d)+4)+(-d+abs(d)+4))+2-2+d)

proof
  let d be real number;
  set c = -d+abs(d)+4;
  set xx = c+c+c;
  -d+abs(d) >= 0 by ABSVALUE:44;
  then (-2)*xx < (-2)*0 by XREAL_1:71;
  then
A1: (-2)*xx/4 < 0/4 by XREAL_1:76;
  assume (abs(d)+c)+2-2+d = -((abs(d)+c+(-d+abs(d)+4))+2-2+d);
  then d + abs(d) = (-2)*xx/4;
  hence contradiction by A1,ABSVALUE:43;
end;

Lm5: for b,d being real number holds b+1 <> b + ((-d+abs(d)+4) + d)
proof
  let b,d be real number;
  set c = -d+abs(d)+4;
  abs(d) >= 0 by COMPLEX1:132;
  then
A1: abs(d)+3 >= 0+3 by XREAL_1:9;
  assume b+1 = b + (c + d);
  hence thesis by A1;
end;

Lm6: for c,d being real number st c > 0 holds (abs(d)+c)+1 <> -((abs(d)+c)+c+d
)

proof
  let c,d being real number such that
A1: c > 0;
  assume
A2: (abs(d)+c)+1 = -((abs(d)+c)+c+d);
  per cases;
  suppose
A3: d >= 0;
    then abs(d) = d by ABSVALUE:def 1;
    hence contradiction by A1,A2,A3;
  end;
  suppose
A4: d < 0;
    then abs(d) = -d by ABSVALUE:def 1;
    then (-d+3*c)+1 = 0 by A2;
    hence contradiction by A1,A4;
  end;
end;

Lm7: for b being real number, d being Integer st d <> 5 holds (b+(-d+abs(d)+4)
+1) <> (b+d)

proof
  let b be real number, d be Integer;
  assume
A1: d <> 5;
  assume
A2: (b+(-d+abs(d)+4)+1) = (b+d);
  per cases;
  suppose
    d >= 0;
    then abs(d) = d by ABSVALUE:def 1;
    hence thesis by A1,A2;
  end;
  suppose
    d < 0;
    then abs(d) = -d by ABSVALUE:def 1;
    hence thesis by A2,Lm3;
  end;
end;

Lm8: for c,d being real number st c > 0 holds (abs(d)+c+c)+1 <> -((abs(d)+c)+d
)

proof
  let c,d be real number;
  assume
A1: c > 0;
  assume
A2: (abs(d)+c+c)+1 = -((abs(d)+c)+d);
  per cases;
  suppose
A3: d >= 0;
    then abs(d) = d by ABSVALUE:def 1;
    hence contradiction by A1,A2,A3;
  end;
  suppose
A4: d < 0;
    then abs(d) = -d by ABSVALUE:def 1;
    hence contradiction by A1,A2,A4;
  end;
end;

Lm9: JUMP ((a,k1)<>0_goto 5) = {}
proof
  set k2 = 5;
  set i = (a,k1)<>0_goto k2;

  set X = { NIC(i,l) where l is Element of NAT: not
  contradiction };

  hereby
    set nl2 = 8;
    set nl1 = 5;
    let x be set;
    assume
A1: x in JUMP i;
    set l2 =  nl2;
    NIC(i,l2) in X;
    then x in NIC(i,l2) by A1,SETFAM_1:def 1;
    then consider s2 being Element of product the Object-Kind of SCMPDS
    such that
A2: x = IC Exec(i,s2) and
A3: IC s2 = l2;
    set l1 =  nl1;
    NIC(i,l1) in X;
    then x in NIC(i,l1) by A1,SETFAM_1:def 1;
    then consider s1 being Element of product the Object-Kind of SCMPDS
    such that
A5: x = IC Exec(i,s1) and
A6: IC s1 = l1;
    consider m2 being Element of NAT such that
A8: m2 = IC s2 and
A9: ICplusConst(s2,k2) = abs(m2+k2) by SCMPDS_2:def 20;
    consider m1 being Element of NAT such that
A10: m1 = IC s1 and
A11: ICplusConst(s1,k2) = abs(m1+k2) by SCMPDS_2:def 20;
    per cases;
    suppose that
A12:  s1.DataLoc(s1.a,k1) <> 0 and
A13:  s2.DataLoc(s2.a,k1) <> 0;
A14:  x = abs(m2+k2) by A2,A9,A13,SCMPDS_2:67;
      x = abs(m1+k2) by A5,A11,A12,SCMPDS_2:67;

      then nl1+k2 = nl2+k2 or nl1+k2 = -(nl2+k2) by A6,A10,A3,A8,A14,
ABSVALUE:45;

      hence x in {};
    end;
    suppose that
A15:  s1.DataLoc(s1.a,k1) = 0 and
A16:  s2.DataLoc(s2.a,k1) = 0;
A17:  x = succ l2 by A2,A3,A16,SCMPDS_2:67;
      x = succ l1 by A5,A6,A15,SCMPDS_2:67;
      hence x in {} by A17;
    end;
    suppose that
A18:  s1.DataLoc(s1.a,k1) = 0 and
A19:  s2.DataLoc(s2.a,k1) <> 0;
      reconsider n1 = l1 as Element of NAT;
      set w1 = n1;
A20:  x = abs(m2+k2) by A2,A9,A19,SCMPDS_2:67;
      x = succ n1 by A5,A6,A18,SCMPDS_2:67
        .= n1 + 1;
      then w1+1 = m2+k2 or w1+1 = -(m2+k2) by A20,ABSVALUE:1;
      hence x in {} by A3,A8;
    end;
    suppose that
A21:  s1.DataLoc(s1.a,k1) <> 0 and
A22:  s2.DataLoc(s2.a,k1) = 0;
      reconsider n2 = l2 as Element of NAT;
A23:  x = succ n2 by A2,A3,A22,SCMPDS_2:67
        .= n2 + 1;
      set w2 = n2;
      x = abs(m1+k2) by A5,A11,A21,SCMPDS_2:67;
      then w2+1 = m1+k2 or w2+1 = -(m1+k2) by A23,ABSVALUE:1;
      hence x in {} by A6,A10;
    end;
  end;
  thus thesis by XBOOLE_1:2;
end;

Lm10: k2 <> 5 implies JUMP ((a,k1)<>0_goto k2) = {}
proof
  set i = (a,k1)<>0_goto k2;

  set X = { NIC(i,l) where l is Element of NAT: not
  contradiction };

  assume
A1: k2 <> 5;
  hereby
    set x1 = -k2+abs(k2)+4;
    let x be set;
    assume
A2: x in JUMP i;
A3: x1 > -k2+abs(k2)+0 by XREAL_1:8;
    then
A4: x1 > 0 by ABSVALUE:44;
    then reconsider x1 as Element of NAT by INT_1:16;
    set nl1 = abs(k2)+x1;
    set nl2 = nl1+x1;
    set l1 =  nl1;
    set l2 =  nl2;
    NIC(i,l1) in X;
    then x in NIC(i,l1) by A2,SETFAM_1:def 1;
    then consider s1 being Element of product the Object-Kind of SCMPDS
    such that
A5: x = IC Exec(i,s1) and
A6: IC s1 = l1;
    consider m1 being Element of NAT such that
A8: m1 = IC s1 and
A9: ICplusConst(s1,k2) = abs(m1+k2) by SCMPDS_2:def 20;
    NIC(i,l2) in X;
    then x in NIC(i,l2) by A2,SETFAM_1:def 1;
    then consider s2 being Element of product the Object-Kind of SCMPDS
    such that
A10: x = IC Exec(i,s2) and
A11: IC s2 = l2;
    consider m2 being Element of NAT such that
A13: m2 = IC s2 and
A14: ICplusConst(s2,k2) = abs(m2+k2) by SCMPDS_2:def 20;
    per cases;
    suppose that
A15:  s1.DataLoc(s1.a,k1) <> 0 and
A16:  s2.DataLoc(s2.a,k1) <> 0;
A17:  x = abs(m2+k2) by A10,A14,A16,SCMPDS_2:67;
A18:  x = abs(m1+k2) by A5,A9,A15,SCMPDS_2:67;
      thus x in {}
      proof
        per cases by A6,A8,A11,A13,A18,A17,ABSVALUE:45;
        suppose
          nl1+2-2+k2 = nl2+2-2+k2;
          hence thesis by A3,ABSVALUE:44;
        end;
        suppose
          nl1+2-2+k2 = -(nl2+2-2+k2);
          hence thesis by Lm4;
        end;
      end;
    end;
    suppose that
A19:  s1.DataLoc(s1.a,k1) = 0 and
A20:  s2.DataLoc(s2.a,k1) = 0;
A21:  x = succ l2 by A10,A11,A20,SCMPDS_2:67;
      x = succ l1 by A5,A6,A19,SCMPDS_2:67;
      hence x in {} by A3,A21,ABSVALUE:44;
    end;
    suppose that
A22:  s1.DataLoc(s1.a,k1) = 0 and
A23:  s2.DataLoc(s2.a,k1) <> 0;
      reconsider n1 = l1 as Element of NAT;
      set w1 = n1;
A24:  x = abs(m2+k2) by A10,A14,A23,SCMPDS_2:67;
A25:  x = succ n1 by A5,A6,A22,SCMPDS_2:67
        .= n1 + 1;
      thus x in {}
      proof
        per cases by A25,A24,ABSVALUE:1;
        suppose
          w1+1 = m2+k2;
          then nl1+1 = nl1 + (x1 + k2) by A11,A13;
          hence thesis by Lm5;
        end;
        suppose
          w1+1 = -(m2+k2);
          hence thesis by A4,A11,A13,Lm6;
        end;
      end;
    end;
    suppose that
A26:  s1.DataLoc(s1.a,k1) <> 0 and
A27:  s2.DataLoc(s2.a,k1) = 0;
      reconsider n2 = l2 as Element of NAT;
A28:  x = succ n2 by A10,A11,A27,SCMPDS_2:67
        .= n2 + 1;
      set w2 = n2;
A29:  x = abs(m1+k2) by A5,A9,A26,SCMPDS_2:67;
      thus x in {}
      proof
        per cases by A29,A28,ABSVALUE:1;
        suppose
          w2+1 = m1+k2;
          hence thesis by A1,A6,A8,Lm7;
        end;
        suppose
          w2+1 = -(m1+k2);
          hence thesis by A4,A6,A8,Lm8;
        end;
      end;
    end;
  end;
  thus thesis by XBOOLE_1:2;
end;

Lm11: JUMP ((a,k1)<=0_goto 5) = {}
proof
  set k2 = 5;
  set i = (a,k1)<=0_goto k2;

  set X = { NIC(i,l) where l is Element of NAT: not
  contradiction };

  hereby
    set nl2 = 8;
    set nl1 = 5;
    let x be set;
    assume
A1: x in JUMP i;
    set l2 =  nl2;
    NIC(i,l2) in X;
    then x in NIC(i,l2) by A1,SETFAM_1:def 1;
    then consider s2 being Element of product the Object-Kind of SCMPDS
    such that
A2: x = IC Exec(i,s2) and
A3: IC s2 = l2;
    set l1 =  nl1;
    NIC(i,l1) in X;
    then x in NIC(i,l1) by A1,SETFAM_1:def 1;
    then consider s1 being Element of product the Object-Kind of SCMPDS
    such that
A5: x = IC Exec(i,s1) and
A6: IC s1 = l1;
    consider m2 being Element of NAT such that
A8: m2 = IC s2 and
A9: ICplusConst(s2,k2) = abs(m2+k2) by SCMPDS_2:def 20;
    consider m1 being Element of NAT such that
A10: m1 = IC s1 and
A11: ICplusConst(s1,k2) = abs(m1+k2) by SCMPDS_2:def 20;
    per cases;
    suppose that
A12:  s1.DataLoc(s1.a,k1) <= 0 and
A13:  s2.DataLoc(s2.a,k1) <= 0;
A14:  x = abs(m2+k2) by A2,A9,A13,SCMPDS_2:68;
      x = abs(m1+k2) by A5,A11,A12,SCMPDS_2:68;

      then nl1+k2 = nl2+k2 or nl1+k2 = -(nl2+k2) by A6,A10,A3,A8,A14,
ABSVALUE:45;

      hence x in {};
    end;
    suppose that
A15:  s1.DataLoc(s1.a,k1) > 0 and
A16:  s2.DataLoc(s2.a,k1) > 0;
A17:  x = succ l2 by A2,A3,A16,SCMPDS_2:68;
      x = succ l1 by A5,A6,A15,SCMPDS_2:68;
      hence x in {} by A17;
    end;
    suppose that
A18:  s1.DataLoc(s1.a,k1) > 0 and
A19:  s2.DataLoc(s2.a,k1) <= 0;
      reconsider n1 = l1 as Element of NAT;
      set w1 = n1;
A20:  x = abs(m2+k2) by A2,A9,A19,SCMPDS_2:68;
      x = succ n1 by A5,A6,A18,SCMPDS_2:68
        .= n1 + 1;
      then w1+1 = m2+k2 or w1+1 = -(m2+k2) by A20,ABSVALUE:1;
      hence x in {} by A3,A8;
    end;
    suppose that
A21:  s1.DataLoc(s1.a,k1) <= 0 and
A22:  s2.DataLoc(s2.a,k1) > 0;
      reconsider n2 = l2 as Element of NAT;
A23:  x = succ n2 by A2,A3,A22,SCMPDS_2:68
        .= n2 + 1;
      set w2 = n2;
      x = abs(m1+k2) by A5,A11,A21,SCMPDS_2:68;
      then w2+1 = m1+k2 or w2+1 = -(m1+k2) by A23,ABSVALUE:1;
      hence x in {} by A6,A10;
    end;
  end;
  thus thesis by XBOOLE_1:2;
end;

Lm12: k2 <> 5 implies JUMP ((a,k1)<=0_goto k2) = {}
proof
  set i = (a,k1)<=0_goto k2;

  set X = { NIC(i,l) where l is Element of NAT: not
  contradiction };

  assume
A1: k2 <> 5;
  hereby
    set x1 = -k2+abs(k2)+4;
    let x be set;
    assume
A2: x in JUMP i;
A3: x1 > -k2+abs(k2)+0 by XREAL_1:8;
    then
A4: x1 > 0 by ABSVALUE:44;
    then reconsider x1 as Element of NAT by INT_1:16;
    set nl1 = abs(k2)+x1;
    set nl2 = nl1+x1;
    set l1 =  nl1;
    set l2 =  nl2;
    NIC(i,l1) in X;
    then x in NIC(i,l1) by A2,SETFAM_1:def 1;
    then consider s1 being Element of product the Object-Kind of SCMPDS
    such that
A5: x = IC Exec(i,s1) and
A6: IC s1 = l1;
    consider m1 being Element of NAT such that
A8: m1 = IC s1 and
A9: ICplusConst(s1,k2) = abs(m1+k2) by SCMPDS_2:def 20;
    NIC(i,l2) in X;
    then x in NIC(i,l2) by A2,SETFAM_1:def 1;
    then consider s2 being Element of product the Object-Kind of SCMPDS
    such that
A10: x = IC Exec(i,s2) and
A11: IC s2 = l2;
    consider m2 being Element of NAT such that
A13: m2 = IC s2 and
A14: ICplusConst(s2,k2) = abs(m2+k2) by SCMPDS_2:def 20;
    per cases;
    suppose that
A15:  s1.DataLoc(s1.a,k1) <= 0 and
A16:  s2.DataLoc(s2.a,k1) <= 0;
A17:  x = abs(m2+k2) by A10,A14,A16,SCMPDS_2:68;
A18:  x = abs(m1+k2) by A5,A9,A15,SCMPDS_2:68;
      thus x in {}
      proof
        per cases by A6,A8,A11,A13,A18,A17,ABSVALUE:45;
        suppose
          nl1+k2 = nl2+k2;
          hence thesis by A3,ABSVALUE:44;
        end;
        suppose
          nl1+2-2+k2 = -(nl2+2-2+k2);
          hence thesis by Lm4;
        end;
      end;
    end;
    suppose that
A19:  s1.DataLoc(s1.a,k1) > 0 and
A20:  s2.DataLoc(s2.a,k1) > 0;
A21:  x = succ l2 by A10,A11,A20,SCMPDS_2:68;
      x = succ l1 by A5,A6,A19,SCMPDS_2:68;
      hence x in {} by A3,A21,ABSVALUE:44;
    end;
    suppose that
A22:  s1.DataLoc(s1.a,k1) > 0 and
A23:  s2.DataLoc(s2.a,k1) <= 0;
      reconsider n1 = l1 as Element of NAT;
      set w1 = n1;
A24:  x = abs(m2+k2) by A10,A14,A23,SCMPDS_2:68;
A25:  x = succ n1 by A5,A6,A22,SCMPDS_2:68
        .= n1 + 1;
      thus x in {}
      proof
        per cases by A25,A24,ABSVALUE:1;
        suppose
          w1+1 = m2+k2;
          then nl1+1 = nl1 + (x1 + k2) by A11,A13;
          hence thesis by Lm5;
        end;
        suppose
          w1+1 = -(m2+k2);
          hence thesis by A4,A11,A13,Lm6;
        end;
      end;
    end;
    suppose that
A26:  s1.DataLoc(s1.a,k1) <= 0 and
A27:  s2.DataLoc(s2.a,k1) > 0;
      reconsider n2 = l2 as Element of NAT;
A28:  x = succ n2 by A10,A11,A27,SCMPDS_2:68
        .= n2 + 1;
      set w2 = n2;
A29:  x = abs(m1+k2) by A5,A9,A26,SCMPDS_2:68;
      thus x in {}
      proof
        per cases by A29,A28,ABSVALUE:1;
        suppose
          w2+1 = m1+k2;
          hence thesis by A1,A6,A8,Lm7;
        end;
        suppose
          w2+1 = -(m1+k2);
          hence thesis by A4,A6,A8,Lm8;
        end;
      end;
    end;
  end;
  thus thesis by XBOOLE_1:2;
end;

Lm13: JUMP ((a,k1)>=0_goto 5) = {}
proof
  set k2 = 5;
  set i = (a,k1)>=0_goto k2;

  set X = { NIC(i,l) where l is Element of NAT: not
  contradiction };

  hereby
    set nl2 = 8;
    set nl1 = 5;
    let x be set;
    assume
A1: x in JUMP i;
    set l2 =  nl2;
    NIC(i,l2) in X;
    then x in NIC(i,l2) by A1,SETFAM_1:def 1;
    then consider s2 being Element of product the Object-Kind of SCMPDS
    such that
A2: x = IC Exec(i,s2) and
A3: IC s2 = l2;
    set l1 =  nl1;
    NIC(i,l1) in X;
    then x in NIC(i,l1) by A1,SETFAM_1:def 1;
    then consider s1 being Element of product the Object-Kind of SCMPDS
    such that
A5: x = IC Exec(i,s1) and
A6: IC s1 = l1;
    consider m2 being Element of NAT such that
A8: m2 = IC s2 and
A9: ICplusConst(s2,k2) = abs(m2+k2) by SCMPDS_2:def 20;
    consider m1 being Element of NAT such that
A10: m1 = IC s1 and
A11: ICplusConst(s1,k2) = abs(m1+k2) by SCMPDS_2:def 20;
    per cases;
    suppose that
A12:  s1.DataLoc(s1.a,k1) >= 0 and
A13:  s2.DataLoc(s2.a,k1) >= 0;
A14:  x = abs(m2+k2) by A2,A9,A13,SCMPDS_2:69;
      x = abs(m1+k2) by A5,A11,A12,SCMPDS_2:69;

      then
      nl1+2-2+k2 = nl2+2-2+k2 or nl1+2-2+k2 = -(nl2+2-2+k2) by A6,A10,A3,A8,A14
,ABSVALUE:45;

      hence x in {};
    end;
    suppose that
A15:  s1.DataLoc(s1.a,k1) < 0 and
A16:  s2.DataLoc(s2.a,k1) < 0;
A17:  x = succ l2 by A2,A3,A16,SCMPDS_2:69;
      x = succ l1 by A5,A6,A15,SCMPDS_2:69;
      hence x in {} by A17;
    end;
    suppose that
A18:  s1.DataLoc(s1.a,k1) < 0 and
A19:  s2.DataLoc(s2.a,k1) >= 0;
      reconsider n1 = l1 as Element of NAT;
      set w1 = n1;
A20:  x = abs(m2+k2) by A2,A9,A19,SCMPDS_2:69;
      x = succ n1 by A5,A6,A18,SCMPDS_2:69
        .= n1 + 1;
      then w1+1 = m2+k2 or w1+1 = -(m2+k2) by A20,ABSVALUE:1;
      hence x in {} by A3,A8;
    end;
    suppose that
A21:  s1.DataLoc(s1.a,k1) >= 0 and
A22:  s2.DataLoc(s2.a,k1) < 0;
      reconsider n2 = l2 as Element of NAT;
A23:  x = succ n2 by A2,A3,A22,SCMPDS_2:69
        .= n2 + 1;
      set w2 = n2;
      x = abs(m1+k2) by A5,A11,A21,SCMPDS_2:69;
      then w2+1 = m1+k2 or w2+1 = -(m1+k2) by A23,ABSVALUE:1;
      hence x in {} by A6,A10;
    end;
  end;
  thus thesis by XBOOLE_1:2;
end;

Lm14: k2 <> 5 implies JUMP ((a,k1)>=0_goto k2) = {}
proof
  set i = (a,k1)>=0_goto k2;

  set X = { NIC(i,l) where l is Element of NAT: not
  contradiction };

  assume
A1: k2 <> 5;
  hereby
    set x1 = -k2+abs(k2)+4;
    let x be set;
    assume
A2: x in JUMP i;
A3: x1 > -k2+abs(k2)+0 by XREAL_1:8;
    then
A4: x1 > 0 by ABSVALUE:44;
    then reconsider x1 as Element of NAT by INT_1:16;
    set nl1 = abs(k2)+x1;
    set nl2 = nl1+x1;
    set l1 =  nl1;
    set l2 =  nl2;
    NIC(i,l1) in X;
    then x in NIC(i,l1) by A2,SETFAM_1:def 1;
    then consider s1 being Element of product the Object-Kind of SCMPDS
    such that
A5: x = IC Exec(i,s1) and
A6: IC s1 = l1;
    consider m1 being Element of NAT such that
A8: m1 = IC s1 and
A9: ICplusConst(s1,k2) = abs(m1+k2) by SCMPDS_2:def 20;
    NIC(i,l2) in X;
    then x in NIC(i,l2) by A2,SETFAM_1:def 1;
    then consider s2 being Element of product the Object-Kind of SCMPDS
    such that
A10: x = IC Exec(i,s2) and
A11: IC s2 = l2;
    consider m2 being Element of NAT such that
A13: m2 = IC s2 and
A14: ICplusConst(s2,k2) = abs(m2+k2) by SCMPDS_2:def 20;
    per cases;
    suppose that
A15:  s1.DataLoc(s1.a,k1) >= 0 and
A16:  s2.DataLoc(s2.a,k1) >= 0;
A17:  x = abs(m2+k2) by A10,A14,A16,SCMPDS_2:69;
A18:  x = abs(m1+k2) by A5,A9,A15,SCMPDS_2:69;
      thus x in {}
      proof
        per cases by A6,A8,A11,A13,A18,A17,ABSVALUE:45;
        suppose
          nl1+2-2+k2 = nl2+2-2+k2;
          hence thesis by A3,ABSVALUE:44;
        end;
        suppose
          nl1+2-2+k2 = -(nl2+2-2+k2);
          hence thesis by Lm4;
        end;
      end;
    end;
    suppose that
A19:  s1.DataLoc(s1.a,k1) < 0 and
A20:  s2.DataLoc(s2.a,k1) < 0;
A21:  x = succ l2 by A10,A11,A20,SCMPDS_2:69;
      x = succ l1 by A5,A6,A19,SCMPDS_2:69;
      hence x in {} by A3,A21,ABSVALUE:44;
    end;
    suppose that
A22:  s1.DataLoc(s1.a,k1) < 0 and
A23:  s2.DataLoc(s2.a,k1) >= 0;
      reconsider n1 = l1 as Element of NAT;
      set w1 = n1;
A24:  x = abs(m2+k2) by A10,A14,A23,SCMPDS_2:69;
A25:  x = succ n1 by A5,A6,A22,SCMPDS_2:69
        .= n1 + 1;
      thus x in {}
      proof
        per cases by A25,A24,ABSVALUE:1;
        suppose
          w1+1 = m2+k2;
          then nl1+1 = nl1 + (x1 + k2) by A11,A13;
          hence thesis by Lm5;
        end;
        suppose
          w1+1 = -(m2+k2);
          hence thesis by A4,A11,A13,Lm6;
        end;
      end;
    end;
    suppose that
A26:  s1.DataLoc(s1.a,k1) >= 0 and
A27:  s2.DataLoc(s2.a,k1) < 0;
      reconsider n2 = l2 as Element of NAT;
A28:  x = succ n2 by A10,A11,A27,SCMPDS_2:69
        .= n2 + 1;
      set w2 = n2;
A29:  x = abs(m1+k2) by A5,A9,A26,SCMPDS_2:69;
      thus x in {}
      proof
        per cases by A29,A28,ABSVALUE:1;
        suppose
          w2+1 = m1+k2;
          hence thesis by A1,A6,A8,Lm7;
        end;
        suppose
          w2+1 = -(m1+k2);
          hence thesis by A4,A6,A8,Lm8;
        end;
      end;
    end;
  end;
  thus thesis by XBOOLE_1:2;
end;

registration
  let a,k1,k2;
  cluster JUMP ((a,k1)<>0_goto k2) -> empty;
  coherence
  proof
    k2 = 5 or k2 <> 5;
    hence thesis by Lm9,Lm10;
  end;
  cluster JUMP ((a,k1)<=0_goto k2) -> empty;
  coherence
  proof
    k2 = 5 or k2 <> 5;
    hence thesis by Lm11,Lm12;
  end;
  cluster JUMP ((a,k1)>=0_goto k2) -> empty;
  coherence
  proof
    k2 = 5 or k2 <> 5;
    hence thesis by Lm13,Lm14;
  end;
end;

theorem Th24:
  SUCC(l,SCMPDS) = NAT
proof
  thus SUCC(l,SCMPDS) c= NAT;
  let x be set;
  set X = { NIC(i,l) \ JUMP i where i is Element of the Instructions of SCMPDS
  : not contradiction };
  assume x in NAT;
  then reconsider x as Element of NAT;
  reconsider xx=x as Element of NAT;
  set i = goto ( xx -  l);
  NIC(i,l) = { abs( xx -  l +  l) } by Th9
    .= {x} by ABSVALUE:def 1;
  then
A1: x in NIC(i,l) \ JUMP i by TARSKI:def 1;
  NIC(i,l) \ JUMP i in X;
  hence thesis by A1,TARSKI:def 4;
end;

registration
  cluster SCMPDS -> non InsLoc-antisymmetric;
  coherence
  proof
    SUCC( 2,SCMPDS) = NAT by Th24;
    then
A1: (2) <= (1), SCMPDS by AMI_WSTD:59;
    SUCC( 1,SCMPDS) = NAT by Th24;
    then
A2: (1) <= (2), SCMPDS by AMI_WSTD:59;
    assume SCMPDS is InsLoc-antisymmetric;
    hence thesis by A2,A1,AMI_WSTD:def 9;
  end;
end;

registration
  cluster SCMPDS -> non weakly_standard;
  coherence by AMI_WSTD:30;
end;

