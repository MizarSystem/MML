:: Computation of Two Consecutive Program Blocks for SCMPDS
::  by JingChao Chen
::
:: Received June 15, 1999
:: Copyright (c) 1999-2011 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies NUMBERS, SUBSET_1, SCMPDS_2, AMI_1, FSM_1, INT_1, SETFAM_1,
      RELAT_1, SCMFSA_7, CARD_1, SCMPDS_4, FUNCT_1, AMISTD_2, VALUED_1,
      ARYTM_3, TARSKI, XXREAL_0, TURING_1, FUNCT_4, XBOOLE_0, SCMFSA6B,
      CIRCUIT2, GRAPHSP, MSUALG_1, AMI_2, AMI_3, SCMPDS_1, COMPLEX1, STRUCT_0,
      ARYTM_1, NAT_1, SCMPDS_5, ORDINAL1, PARTFUN1, SCMNORM, SCMFSA6C,
      COMPOS_1,SCMFSA6A;
 notations TARSKI, XBOOLE_0, SETFAM_1, ENUMSET1, SUBSET_1, CARD_1, NUMBERS,
      XCMPLX_0, RELAT_1, FUNCT_1, PARTFUN1, FUNCT_4, INT_1, NAT_1,
      STRUCT_0, MEMSTR_0, COMPOS_1, EXTPRO_1, VALUED_1, AMI_2, FUNCT_7,
      SCMPDS_1, SCMPDS_2, INT_2, SCMPDS_4, XXREAL_0;
 constructors ENUMSET1, XXREAL_0, REAL_1, INT_2, SCMPDS_1, SCMPDS_4, PRE_POLY,
      DOMAIN_1, AMI_3, NAT_D, MEMSTR_0, RELSET_1;
 registrations SETFAM_1, FUNCT_1, NUMBERS, XREAL_0, INT_1, SCMPDS_2, SCMPDS_4,
      ORDINAL1, XBOOLE_0, VALUED_1, AFINSQ_1, COMPOS_1, RELAT_1, EXTPRO_1,
      FUNCT_4, MEMSTR_0;
 requirements NUMERALS, REAL, SUBSET, BOOLE, ARITHM;
 definitions FUNCOP_1, COMPOS_1, SCMPDS_4, NAT_1, AFINSQ_1, EXTPRO_1, MEMSTR_0;
 theorems NAT_1, TARSKI, FUNCT_4, FUNCT_1, INT_1, RELAT_1, SCMPDS_2, SCMPDS_3,
      ENUMSET1, ABSVALUE, GRFUNC_1, SCMPDS_4, MEMSTR_0, XBOOLE_0,
      XBOOLE_1, XREAL_1, ORDINAL1, FUNCOP_1, XXREAL_0, VALUED_1, AFINSQ_1,
      PBOOLE, PARTFUN1, COMPOS_1, EXTPRO_1;
 schemes NAT_1;

begin :: Preliminaries

reserve x for set,
  m,n for Element of NAT,
  a,b,c for Int_position,
  i for Instruction of SCMPDS,
  s,s1,s2 for State of SCMPDS,
  k1,k2 for Integer,
  loc,l1 for Element of NAT,
  I,J for Program of SCMPDS,
  N for with_non-empty_elements set;

Lm1: card Stop SCMPDS = 1 by AFINSQ_1:33;

canceled 11;

theorem Th12:
  for I,J being Program of SCMPDS holds I c= stop (I ';' J)
proof
  let I,J be Program of SCMPDS;
  set IS=I ';' (J ';' Stop SCMPDS),
  Ip=stop (I ';' J);
A1: I c= IS by AFINSQ_1:74;
  thus thesis by A1,AFINSQ_1:27;
end;

theorem Th16:
  dom stop I c= dom stop (I ';' J)
proof
  set sI=stop I, sIJ=stop (I ';'J);
A1: card sIJ=card (I ';' J) +1 by Lm1,AFINSQ_1:17
    .=card I + card J +1 by AFINSQ_1:17
    .=card I + 1 + card J;
  card sI=card I +1 by Lm1,AFINSQ_1:17;
  then
A2: card sI <= card sIJ by A1,NAT_1:11;
  now
    set A = NAT;
    let x be set;
    assume
A3: x in dom sI;
    dom sI c= A by RELAT_1:def 18;
    then reconsider l=x as Element of NAT by A3;
    reconsider n = l as Element of NAT;
    n < card sI by A3,AFINSQ_1:66;
    then n < card sIJ by A2,XXREAL_0:2;
    hence x in dom sIJ by AFINSQ_1:66;
  end;
  hence thesis by TARSKI:def 3;
end;

theorem Th17:
  for I,J being Program of SCMPDS holds
   stop I +* stop (I ';' J) = stop (I ';' J)
proof
  let I,J be Program of SCMPDS;
  set sI=stop I, IsI=sI, sIJ=stop (I ';' J), IsIJ= sIJ;
  dom sI c= dom sIJ by Th16;
  hence thesis by FUNCT_4:19;
end;

set SA0 = Start-At(0,SCMPDS);

theorem Th19:
  (Initialize s).a = s.a
proof
  not a in dom SA0 by SCMPDS_4:18;
  hence (Initialize s).a =s.a by FUNCT_4:11;
end;

reserve P,P1,P2,Q for Instruction-Sequence of SCMPDS;

theorem Th20:
  for s being 0-started State of SCMPDS
  for I being parahalting Program of SCMPDS
    st stop I c= P1 & stop I c= P2
  for k being Element of NAT holds
    Comput(P1,s,k) =  Comput(P2,s,k) &
   CurInstr(P1,Comput(P1,s,k)) = CurInstr(P2,Comput(P2,s,k))
proof
  let s be 0-started State of SCMPDS;
  let I be parahalting Program of SCMPDS;
  set SI=stop I;
  assume that
A1: SI c= P1 and
A2: SI c= P2;
    let k be Element of NAT;
A4: IC Comput(P1,s,k) in dom SI by A1,SCMPDS_4:def 6;
A5: IC Comput(P2,s,k) in dom SI by A2,SCMPDS_4:def 6;
    for m being Element of NAT st m < k holds IC(Comput(P2,s,m))
in dom
    SI by A2,SCMPDS_4:def 6;
    hence
K:   Comput(P1,s,k) =  Comput(P2,s,k) by A1,A2,SCMPDS_4:21;
    thus CurInstr(P2,Comput(P2,s,k))
     = P2.IC Comput(P2,s,k) by PBOOLE:143
      .= SI.IC Comput(P2,s,k) by A2,A5,GRFUNC_1:2
      .= P1.IC Comput(P1,s,k) by A1,K,A4,GRFUNC_1:2
      .= CurInstr(P1,Comput(P1,s,k)) by PBOOLE:143;
end;

theorem Th21:
  for s being 0-started State of SCMPDS
  for I being parahalting Program of SCMPDS
   st stop I c= P1 & stop I c= P2
  holds LifeSpan(P1,s) = LifeSpan(P2,s) &
   Result(P1,s) =  Result(P2,s)
proof
  let s be 0-started State of SCMPDS;
  let I be parahalting Program of SCMPDS;
  set SI=stop I;
  assume that
A1: SI c= P1 and
A2: SI c= P2;
A4: P2 halts_on s by A2,SCMPDS_4:def 7;
A5: P1 halts_on s by A1,SCMPDS_4:def 7;
A6: now
    let l be Element of NAT;
    assume
A7: CurInstr(P2,Comput(P2,s,l)) = halt SCMPDS;
    CurInstr(P1,Comput(P1,s,l))
     = CurInstr(P2,Comput(P2,s,l))
     by A1,A2,Th20;
    hence LifeSpan(P1,s) <= l by A5,A7,EXTPRO_1:def 15;
  end;
  CurInstr(P2,Comput(P2,s,LifeSpan(P1,s)))
     = CurInstr(P1,Comput(P1,s,LifeSpan(P1,s))) by A1,A2,Th20
    .= halt SCMPDS by A5,EXTPRO_1:def 15;
  hence
K:  LifeSpan(P1,s) = LifeSpan(P2,s) by A6,A4,EXTPRO_1:def 15;
   P2 halts_on s by A2,SCMPDS_4:def 7;
   then
A8: Result(P2,s) = Comput(P2,s,LifeSpan(P1,s))
     by K,EXTPRO_1:23;
    P1 halts_on s by A1,SCMPDS_4:def 7;
    then
    Result(P1,s) = Comput(P1,s,LifeSpan(P1,s))
      by EXTPRO_1:23;
  hence thesis by A1,A2,A8,Th20;
end;

canceled;

theorem Th23:
  for s being 0-started State of SCMPDS
  for I being parahalting Program of SCMPDS, J being Program of SCMPDS
   st stop I c= P
  for m st m <= LifeSpan(P,s)
   holds  Comput(P,s,m) =  Comput(P+*(I ';' J),s,m)
proof
  let s be 0-started State of SCMPDS;
  let I be parahalting Program of SCMPDS, J be Program of SCMPDS;
  set SI=stop I;
  defpred X[Element of NAT] means $1 <= LifeSpan(P,s) implies
     Comput(P,s,$1) =  Comput(P+*(I ';' J),s,$1);
A1: Comput(P+*(I ';' J),s,0) = s by EXTPRO_1:2;
  assume
A2: SI c= P;
  then
A3: P halts_on s by SCMPDS_4:def 7;
A4: for m st X[m] holds X[m+1]
  proof
    dom(I ';' J) = dom I \/ dom Shift(J, card I) by FUNCT_4:def 1;
    then
A5: dom I c= dom(I ';' J) by XBOOLE_1:7;
    let m;
    assume
A6: m <= LifeSpan(P,s) implies Comput(P,s,m) =  Comput(P+*(I ';' J),s,m);
    assume
A7: m+1 <= LifeSpan(P,s);
A10: Comput(P+*(I ';' J),s,m+1)
    = Following(P+*(I ';' J),Comput(P+*(I ';' J),s,m)) by EXTPRO_1:3;
A11: Comput(P,s,m+1) = Following(P,Comput(P,s,m)) by EXTPRO_1:3;
A12: I ';' J c= P+*(I ';' J) by FUNCT_4:25;
A13: IC Comput(P,s,m) in dom SI by A2,SCMPDS_4:def 6;
A15:  P/.IC Comput(P,s,m) = P.IC Comput(P,s,m) by PBOOLE:143;
A16: CurInstr(P,Comput(P,s,m)) = SI.IC (Comput(P,s,m))
      by A13,A15,GRFUNC_1:2,A2;
A17:  (P+*(I ';' J))/.IC Comput(P+*(I ';' J),s,m)
       = (P+*(I ';' J)).IC Comput(P+*(I ';' J),s,m) by PBOOLE:143;
    m < LifeSpan(P,s) by A7,NAT_1:13;
    then SI.IC(Comput(P,s,m)) <> halt SCMPDS by A3,A16,EXTPRO_1:def 15;
    then
A18: IC Comput(P,s,m) in dom I by A13,COMPOS_1:51;
    CurInstr(P,Comput(P,s,m))
       =I.IC (Comput(P,s,m)) by A16,AFINSQ_1:def 3,A18
      .=(I ';' J).IC(Comput(P,s,m))
              by A18,AFINSQ_1:def 3
      .= CurInstr(P+*(I ';' J),Comput(P+*(I ';' J),s,m))
       by A7,A12,A18,A5,A17,GRFUNC_1:2,A6,NAT_1:13;
    hence thesis by A6,A7,A11,A10,NAT_1:13;
  end;
A20: X[0] by A1,EXTPRO_1:2;
  thus for m holds X[m] from NAT_1:sch 1(A20,A4);
end;

theorem Th24:
 for s being 0-started State of SCMPDS
 for I being parahalting Program of SCMPDS, J being Program of SCMPDS
   st stop I c= P
 for m st m <= LifeSpan(P,s)
 holds  Comput(P,s,m) =  Comput(P+*stop(I ';' J), s,m)
proof
  let s be 0-started State of SCMPDS;
  let I be parahalting Program of SCMPDS, J be Program of SCMPDS;
  assume
A1: stop I c= P;
  set sIJ=stop (I ';' J), SS=Stop SCMPDS;
  let m;
  assume
A2: m <= LifeSpan(P,s);
  P +* sIJ = P +* (I ';' (J ';' SS)) by AFINSQ_1:27;
  hence thesis by A1,A2,Th23;
end;

Lm2: Load (DataLoc(0,0):=0) is parahalting
proof
  set ii= DataLoc(0,0):=0, m0= stop Load ii;
  let s be 0-started State of SCMPDS;
  let P such that
A1: m0 c= P;
XX: m0 = Macro ii;
  take 1;
     IC Comput(P,s,1) in NAT;
    hence IC Comput(P,s,1) in dom P by PARTFUN1:def 2;
A2: IC s = 0 by MEMSTR_0:def 8;
  then
A3: IC Exec(ii, s) = succ 0 by SCMPDS_2:45
    .=  (0+1);
   1 in dom m0 by COMPOS_1:57,XX;
  then m0. 1 = P. 1 by A1,GRFUNC_1:2;
  then
A4: P. 1 = halt SCMPDS by COMPOS_1:59,XX;
   0 in dom m0 by COMPOS_1:57,XX;
  then
A5: m0. 0 = P. 0 by A1,GRFUNC_1:2;
A6: P/.IC s = P.IC s by PBOOLE:143;
  Comput(P,s,0+1) = Following(P,Comput(P,s,0)) by EXTPRO_1:3
    .= Following(P,s) by EXTPRO_1:2
    .= Exec(ii,s) by A2,A5,COMPOS_1:58,A6,XX;
  hence thesis by A4,A3,PBOOLE:143;
end;

begin :: Non halting instrutions and parahalting instrutions

definition
 canceled;
  let i be Instruction of SCMPDS;
  attr i is parahalting means
  :Def2:
  Load i is parahalting;
end;

registration
  cluster No-StopCode shiftable parahalting for Instruction of SCMPDS;
  existence
  proof
    take i=DataLoc(0,0):=0;
A1: InsCode halt SCMPDS=0 by SCMPDS_2:12,81;
    InsCode i=2 by SCMPDS_2:14;
    hence thesis by A1,COMPOS_1:def 24,Def2,Lm2;
  end;
end;

theorem
  k1 <>0 implies goto k1 is No-StopCode
proof
  set i=goto k1;
  assume
A1: k1 <>0;
  assume
  i is not No-StopCode;
  then i=halt SCMPDS by COMPOS_1:def 24;
  hence contradiction by A1,SCMPDS_2:73;
end;

registration
  let a;
  cluster return a -> No-StopCode;
  coherence
  proof
    set i=return a;
A1: InsCode halt SCMPDS=0 by SCMPDS_2:12,81;
    InsCode i=1 by SCMPDS_2:13;
    hence thesis by A1,COMPOS_1:def 24;
  end;
end;

registration
  let a,k1;
  cluster a := k1 -> No-StopCode;
  coherence
  proof
    set i=a:=k1;
A1: InsCode halt SCMPDS=0 by SCMPDS_2:12,81;
    InsCode i=2 by SCMPDS_2:14;
    hence thesis by A1,COMPOS_1:def 24;
  end;
  cluster saveIC(a,k1) -> No-StopCode;
  coherence
  proof
    set i=saveIC(a,k1);
A2: InsCode halt SCMPDS=0 by SCMPDS_2:12,81;
    InsCode i=3 by SCMPDS_2:15;
    hence thesis by A2,COMPOS_1:def 24;
  end;
end;

registration
  let a,k1,k2;
  cluster (a,k1)<>0_goto k2 -> No-StopCode;
  coherence
  proof
    set i=(a,k1)<>0_goto k2;
A1: InsCode halt SCMPDS=0 by SCMPDS_2:12,81;
    InsCode i=4 by SCMPDS_2:16;
    hence thesis by A1,COMPOS_1:def 24;
  end;
  cluster (a,k1)<=0_goto k2 -> No-StopCode;
  coherence
  proof
    set i=(a,k1)<=0_goto k2;
A2: InsCode halt SCMPDS=0 by SCMPDS_2:12,81;
    InsCode i=5 by SCMPDS_2:17;
    hence thesis by A2,COMPOS_1:def 24;
  end;
  cluster (a,k1)>=0_goto k2 -> No-StopCode;
  coherence
  proof
    set i=(a,k1)>=0_goto k2;
A3: InsCode halt SCMPDS=0 by SCMPDS_2:12,81;
    InsCode i=6 by SCMPDS_2:18;
    hence thesis by A3,COMPOS_1:def 24;
  end;
  cluster (a,k1) := k2 -> No-StopCode;
  coherence
  proof
    set i=(a,k1) := k2;
A4: InsCode halt SCMPDS=0 by SCMPDS_2:12,81;
    InsCode i=7 by SCMPDS_2:19;
    hence thesis by A4,COMPOS_1:def 24;
  end;
end;

registration
  let a,k1,k2;
  cluster AddTo(a,k1,k2) -> No-StopCode;
  coherence
  proof
    set i=AddTo(a,k1,k2);
A1: InsCode halt SCMPDS=0 by SCMPDS_2:12,81;
    InsCode i=8 by SCMPDS_2:20;
    hence thesis by A1,COMPOS_1:def 24;
  end;
end;

registration
  let a,b,k1,k2;
  cluster AddTo(a,k1,b,k2) -> No-StopCode;
  coherence
  proof
    set i=AddTo(a,k1,b,k2);
A1: InsCode halt SCMPDS=0 by SCMPDS_2:12,81;
    InsCode i=9 by SCMPDS_2:21;
    hence thesis by A1,COMPOS_1:def 24;
  end;
  cluster SubFrom(a,k1,b,k2) -> No-StopCode;
  coherence
  proof
    set i=SubFrom(a,k1,b,k2);
A2: InsCode halt SCMPDS=0 by SCMPDS_2:12,81;
    InsCode i=10 by SCMPDS_2:22;
    hence thesis by A2,COMPOS_1:def 24;
  end;
  cluster MultBy(a,k1,b,k2) -> No-StopCode;
  coherence
  proof
    set i=MultBy(a,k1,b,k2);
A3: InsCode halt SCMPDS=0 by SCMPDS_2:12,81;
    InsCode i=11 by SCMPDS_2:23;
    hence thesis by A3,COMPOS_1:def 24;
  end;
  cluster Divide(a,k1,b,k2) -> No-StopCode;
  coherence
  proof
    set i=Divide(a,k1,b,k2);
A4: InsCode halt SCMPDS=0 by SCMPDS_2:12,81;
    InsCode i=12 by SCMPDS_2:24;
    hence thesis by A4,COMPOS_1:def 24;
  end;
  cluster (a,k1) := (b,k2) -> No-StopCode;
  coherence
  proof
    set i=(a,k1) := (b,k2);
A5: InsCode halt SCMPDS=0 by SCMPDS_2:12,81;
    InsCode i=13 by SCMPDS_2:25;
    hence thesis by A5,COMPOS_1:def 24;
  end;
end;

registration
  cluster halt SCMPDS -> parahalting;
  coherence
  proof
    Stop SCMPDS=Load halt SCMPDS;
    hence thesis by Def2;
  end;
end;

registration
  let i be parahalting Instruction of SCMPDS;
  cluster Load i -> parahalting for Program of SCMPDS;
  coherence by Def2;
end;

       :: ??? is sequential
Lm3: (for s holds Exec(i,s).IC SCMPDS = succ IC s)
  implies Load i is parahalting
proof
  assume
A1: for s holds Exec(i,s).IC SCMPDS = succ IC s;
  set m0= stop Load i;
  let t be 0-started State of SCMPDS;
XX: m0 = Macro i;
  let Q such that
A2: m0 c= Q;
  take 1;
     IC Comput(Q,t,1) in NAT;
    hence IC Comput(Q,t,1) in dom Q by PARTFUN1:def 2;
A3: IC t =  0 by MEMSTR_0:def 8;
  then
A4: IC Exec(i, t) = succ  0 by A1
    .=  (0+1);
   1 in dom m0 by COMPOS_1:57,XX;
  then m0. 1 = Q. 1 by A2,GRFUNC_1:2;
  then
A5: Q. 1 = halt SCMPDS by COMPOS_1:59,XX;
   0 in dom m0 by COMPOS_1:57,XX;
  then
A6: m0. 0 = Q. 0 by A2,GRFUNC_1:2;
A7: Q/.IC t = Q.IC t by PBOOLE:143;
  Comput(Q,t,0+1) = Following(Q,Comput(Q,t,0)) by EXTPRO_1:3
    .= Following(Q,t) by EXTPRO_1:2
    .= Exec(i,t) by A3,A6,COMPOS_1:58,A7,XX;
  hence thesis by A4,A5,PBOOLE:143;
end;

registration
  let a,k1;
  cluster a := k1 -> parahalting;
  coherence
  proof
    set i= a:=k1;
    for s holds Exec(i,s).IC SCMPDS = succ IC s by SCMPDS_2:45;
    then Load i is parahalting by Lm3;
    hence thesis by Def2;
  end;
end;

registration
  let a,k1,k2;
  cluster (a,k1) := k2 -> parahalting;
  coherence
  proof
    set i= (a,k1) := k2;
    for s holds Exec(i,s).IC SCMPDS = succ IC s by SCMPDS_2:46;
    then Load i is parahalting by Lm3;
    hence thesis by Def2;
  end;
  cluster AddTo(a,k1,k2) -> parahalting;
  coherence
  proof
    set i= AddTo(a,k1,k2);
    for s holds Exec(i,s).IC SCMPDS = succ IC s by SCMPDS_2:48;
    then Load i is parahalting by Lm3;
    hence thesis by Def2;
  end;
end;

registration
  let a,b,k1,k2;
  cluster AddTo(a,k1,b,k2) -> parahalting;
  coherence
  proof
    set i= AddTo(a,k1,b,k2);
    for s holds Exec(i,s).IC SCMPDS = succ IC s by SCMPDS_2:49;
    then Load i is parahalting by Lm3;
    hence thesis by Def2;
  end;
  cluster SubFrom(a,k1,b,k2) -> parahalting;
  coherence
  proof
    set i= SubFrom(a,k1,b,k2);
    for s holds Exec(i,s).IC SCMPDS = succ IC s by SCMPDS_2:50;
    then Load i is parahalting by Lm3;
    hence thesis by Def2;
  end;
  cluster MultBy(a,k1,b,k2) -> parahalting;
  coherence
  proof
    set i= MultBy(a,k1,b,k2);
    for s holds Exec(i,s).IC SCMPDS = succ IC s by SCMPDS_2:51;
    then Load i is parahalting by Lm3;
    hence thesis by Def2;
  end;
  cluster Divide(a,k1,b,k2) -> parahalting;
  coherence
  proof
    set i= Divide(a,k1,b,k2);
    for s holds Exec(i,s).IC SCMPDS = succ IC s by SCMPDS_2:52;
    then Load i is parahalting by Lm3;
    hence thesis by Def2;
  end;
  cluster (a,k1) := (b,k2) -> parahalting;
  coherence
  proof
    set i= (a,k1) := (b,k2);
    for s holds Exec(i,s).IC SCMPDS = succ IC s by SCMPDS_2:47;
    then Load i is parahalting by Lm3;
    hence thesis by Def2;
  end;
end;

theorem Th26:
  InsCode i =1 implies i is not parahalting
proof
  consider s such that
A1: for a holds s.a = 2 by SCMPDS_2:61;
  set P = the Instruction-Sequence of SCMPDS;
  assume InsCode i=1;
  then consider a such that
A2: i = return a by SCMPDS_2:27;
  assume i is parahalting;
  then reconsider Li = Load i as parahalting Program of SCMPDS;
  set pi= Macro i;
  set s1=Initialize s, P1= P+*pi;
  s1.DataLoc(s1.a,RetIC)=s.DataLoc(s1.a,RetIC) by Th19
    .=2 by A1;
  then
A4: Exec(i, s1).IC SCMPDS =(abs(2))+2 by A2,SCMPDS_2:58
    .= 2+2 by ABSVALUE:def 1
    .= 4;
  set C1=Comput(P1,s1,1);
   stop Li c= P1 by FUNCT_4:25;
   then
A5: IC C1 in dom pi by SCMPDS_4:def 6;
   0 in dom pi by COMPOS_1:57;
  then
A6: P1. 0= pi. 0 by FUNCT_4:13
    .=i by COMPOS_1:58;
A7: card pi = 2 by COMPOS_1:56;
A8: P1/.IC s1 = P1.IC s1 by PBOOLE:143;
  Comput(P1,s1,0+1) = Following(P1,Comput(P1,s1,0)) by EXTPRO_1:3
    .= Following(P1,s1) by EXTPRO_1:2
    .= Exec(i, s1) by A6,A8,MEMSTR_0:47;
  hence contradiction by A4,A5,A7,AFINSQ_1:66;
end;

registration
  cluster parahalting shiftable halt-free for Program of SCMPDS;
  existence
  proof
    set ii=DataLoc(0,0):=0;
    take II=Load ii;
    now
      let x be Nat;
      assume
      x in dom II;
      then x in { 0} by FUNCOP_1:13;
      then x= 0 by TARSKI:def 1;
      then
A1:   II.x=ii by FUNCOP_1:72;
      InsCode ii=2 by SCMPDS_2:14;
      hence II.x <> halt SCMPDS by A1,SCMPDS_2:12,81;
    end;
    hence thesis by COMPOS_1:def 25;
  end;
end;

registration
  let I,J be halt-free Program of SCMPDS;
  cluster I ';' J -> halt-free;
  coherence
  proof
    set IJ=I ';' J;
      set D = {n+card I: n in dom J };
      dom Shift(J,card I) = D by VALUED_1:def 12;
      then
A1:   dom IJ = dom I \/ D by FUNCT_4:def 1;
      let x be Nat such that
A2:   x in dom IJ;
      per cases by A2,A1,XBOOLE_0:def 3;
      suppose
A3:     x in dom I;
        then I.x=IJ.x by AFINSQ_1:def 3;
        hence IJ.x<>halt SCMPDS by A3,COMPOS_1:def 25;
      end;
      suppose
        x in D;
        then consider n such that
A4:     x = n+card I and
A5:     n in dom J;
        J. n =IJ.x by A4,A5,AFINSQ_1:def 3;
        hence IJ.x<>halt SCMPDS by A5,COMPOS_1:def 25;
      end;
    end;
end;

registration
  let i be No-StopCode Instruction of SCMPDS;
  cluster Load i -> halt-free;
  coherence
  proof
    set p=Load i;
    now
      let x be Nat;
      assume
      x in dom p;
      then x =  0 by COMPOS_1:50;
      then p.x=i by FUNCOP_1:72;
      hence p.x <>halt SCMPDS by COMPOS_1:def 24;
    end;
    hence thesis by COMPOS_1:def 25;
  end;
end;

registration
  let i be No-StopCode Instruction of SCMPDS, J be halt-free Program of
  SCMPDS;
  cluster i ';' J -> halt-free;
  coherence;
end;

registration
  let I be halt-free Program of SCMPDS, j be No-StopCode Instruction of
  SCMPDS;
  cluster I ';' j -> halt-free;
  coherence;
end;

registration
  let i,j be No-StopCode Instruction of SCMPDS;
  cluster i ';' j -> halt-free;
  coherence;
end;

theorem Th27:
  for s being 0-started State of SCMPDS
  for I being parahalting halt-free Program of SCMPDS st stop I c= P
   holds IC Comput(P, s,LifeSpan(P +* stop I,s)) =  card I
proof
  let s be 0-started State of SCMPDS;
  let I be parahalting halt-free Program of SCMPDS;
  set Css= Comput(P, s,LifeSpan(P,s));
  reconsider n = IC Css as Element of NAT;
  assume
A1: stop I c= P;
  then
A2: P halts_on s by SCMPDS_4:def 7;
A3:  P +* stop I = P by A1,FUNCT_4:98;
  I c= stop I by AFINSQ_1:74;
  then
A4: I c= P by A1,XBOOLE_1:1;
  now
    assume
A5: IC Css in dom I;
    then I.IC Css=P.IC Css by A4,GRFUNC_1:2
      .=CurInstr(P,Css) by PBOOLE:143
      .=halt SCMPDS by A2,EXTPRO_1:def 15;
    hence contradiction by A5,COMPOS_1:def 25;
  end;
  then
A6: n >= card I by AFINSQ_1:66;
A7: card stop I =card I + 1 by Lm1,AFINSQ_1:17;
  IC Css in dom stop(I) by A1,SCMPDS_4:def 6;
  then n < card I + 1 by A7,AFINSQ_1:66;
  then n <= card I by NAT_1:13;
  hence thesis by A3,A6,XXREAL_0:1;
end;

theorem Th28:
 for s being 0-started State of SCMPDS
  for I being parahalting Program of SCMPDS,k be Element of NAT st
     k < LifeSpan(P +* stop I,s)
 holds IC Comput(P +* stop I,s,k) in dom I
proof let s be 0-started State of SCMPDS;
  let I be parahalting Program of SCMPDS,k be Element of NAT;
  set ss= s, PP = P +* stop I, m=LifeSpan(PP,ss);
  set Sk= Comput(PP, ss,k), Ik=IC Sk;
XX: stop I c= PP by FUNCT_4:25;
  then
A1: PP halts_on ss by SCMPDS_4:def 7;
  reconsider n = Ik as Element of NAT;
A2: Ik in dom stop(I) by XX,SCMPDS_4:def 6;
A3: stop I c= PP by FUNCT_4:25;
  assume
A4: k < m;
A5: now
    assume
A6: n = card I;
A7:  0 in dom Stop SCMPDS by COMPOS_1:3;
A8: (Stop SCMPDS). 0 = halt SCMPDS by AFINSQ_1:34;
    CurInstr(PP,Sk) =PP.Ik by PBOOLE:143
      .=(stop I).(0+n) by A2,A3,GRFUNC_1:2
      .=halt SCMPDS by A6,A8,A7,AFINSQ_1:def 3;
    hence contradiction by A4,A1,EXTPRO_1:def 15;
  end;
  card stop I=card I + 1 by Lm1,AFINSQ_1:17;
  then n < card I + 1 by A2,AFINSQ_1:66;
  then n <= card I by INT_1:7;
  then n < card I by A5,XXREAL_0:1;
  hence thesis by AFINSQ_1:66;
end;

theorem Th29:
  for s being 0-started State of SCMPDS
  for I being parahalting Program of SCMPDS,k be Element of NAT st
    I c= P & k <= LifeSpan(P +* stop I,s)
   holds Comput(P, s,k) = Comput(P +* stop I,s,k)
proof
  let s be 0-started State of SCMPDS;
  let I be parahalting Program of SCMPDS,k be Element of NAT;
  set m=LifeSpan(P +* stop I,s);
  assume that
A1: I c= P and
A2: k <= m;
  set s2 = s, P2 = P +* stop I;
  defpred P[Element of NAT] means
    $1 <= m implies Comput(P,s,$1) = Comput(P2,s2,$1);
A3: P = P +* I by A1,FUNCT_4:98;
A4: now
    let k be Element of NAT;
    assume
A5: P[k];
    now
A6:   Comput(P2,s2,k+1) = Following(P2,Comput(P2,s2,k)) by EXTPRO_1:3;
A7:   Comput(P,s,k+1) = Following(P,Comput(P,s,k)) by EXTPRO_1:3;
A8:  k < k+1 by XREAL_1:29;
      assume
A9:  k+1 <= m;
      then
A10:    k < m by A8,XXREAL_0:2;
      then IC Comput(P2,s2,k) in dom I by Th28;
      then
A11:  IC Comput(P2,s2,k) in dom (stop I) by FUNCT_4:12;
A12:   IC Comput(P2,s2,k) in dom I by A10,Th28;
      CurInstr(P,Comput(P,s,k))
         = P.IC Comput(P2,s2,k) by PBOOLE:143,A5,A9,A8,XXREAL_0:2
        .= I.IC Comput(P2,s2,k) by A3,A10,Th28,FUNCT_4:13
        .= (stop I).IC Comput(P2,s2,k) by A12,AFINSQ_1:def 3
        .= (P +* stop I).IC Comput(P2,s2,k) by A11,FUNCT_4:13
        .= CurInstr(P2,Comput(P2,s2,k)) by PBOOLE:143;
      hence  Comput(P,s,k+1) =  Comput(P2,s2,k+1)
        by A5,A9,A8,A7,A6,XXREAL_0:2;
    end;
    hence P[k+1];
  end;
A13: P[0]
  proof
    assume 0 <= m;
     Comput(P2,s2,0)= s by EXTPRO_1:2;
    hence thesis by EXTPRO_1:2;
  end;
  for k be Element of NAT holds P[k] from NAT_1:sch 1(A13,A4);
  hence thesis by A2;
end;

theorem Th30:
  for s being 0-started State of SCMPDS
  for I being parahalting halt-free Program of SCMPDS st I c= P
   holds IC Comput(P,s,LifeSpan(P +* stop I,s)) =  card I
proof
  let s be 0-started State of SCMPDS;
  let I be parahalting halt-free Program of SCMPDS;
  set PP = P +* stop I, m=LifeSpan(PP,s);
A1: stop I c= PP by FUNCT_4:25;
A2: stop I +* PP = PP & PP +* stop I = PP by A1,FUNCT_4:97,98;
  assume I c= P;
  hence IC Comput(P,s,m) = IC Comput(PP,s,m) by Th29
    .= card I by Th27,A2,FUNCT_4:25;
end;

theorem Th31:
  for s being 0-started State of SCMPDS
  for I being parahalting Program of SCMPDS st I c= P
  holds CurInstr(P,Comput(P, s,LifeSpan(P +* stop I,s))) = halt SCMPDS
    or IC Comput(P, s,LifeSpan(P +* stop I,s)) = card I
proof
  let s be 0-started State of SCMPDS;
  let I be parahalting Program of SCMPDS;
  set PP = P+* stop I, m=LifeSpan(PP,s);
  set s1=Comput(P,s,m),
      s2= Comput(PP, s,LifeSpan(PP +* stop I,Initialize s)),
      Ik = IC s2;
XX: stop I c= PP by FUNCT_4:25;
   then
A1: PP halts_on s by SCMPDS_4:def 7;
  reconsider n = Ik as Element of NAT;
A3: Ik in dom stop(I) by XX,SCMPDS_4:def 6;
X: Initialize s = s by MEMSTR_0:44;
A4: PP +* stop I = PP by FUNCT_4:25,FUNCT_4:98;
  card stop I = card I + 1 by Lm1,AFINSQ_1:17;
  then n < card I + 1 by A3,AFINSQ_1:66;
  then
A5: n <= card I by INT_1:7;
A6: stop I c= PP by FUNCT_4:25;
  assume
A7: I c= P;
  then
A8: IC s1 =Ik by A4,Th29,X;
  now
    per cases by A5,XXREAL_0:1;
    case
      n < card I;
      then
A9:    n in dom I by AFINSQ_1:66;
      thus halt SCMPDS
        = CurInstr(PP,s2) by A4,A1,X,EXTPRO_1:def 15
        .=PP.Ik by PBOOLE:143
        .=(stop I).Ik by A3,A6,GRFUNC_1:2
        .=I.Ik by A9,AFINSQ_1:def 3
        .=P.IC s1 by A7,A8,A9,GRFUNC_1:2
        .=CurInstr(P,s1) by PBOOLE:143;
    end;
    case n = card I;
      hence IC s1 =  card I by A7,A4,Th29,X;
    end;
  end;
  hence thesis;
end;

theorem Th32:
  for s being 0-started State of SCMPDS
  for I being parahalting halt-free Program of SCMPDS,k being Element of NAT
   st I c= P & k < LifeSpan(P +* stop I,s)
  holds CurInstr(P,Comput(P,s,k)) <> halt SCMPDS
proof
  let s be 0-started State of SCMPDS;
  let I be parahalting halt-free Program of SCMPDS,k be Element of NAT;
  set PI = P +* stop I, s1= Comput(P, s,k), s2= Comput(PI, s,k);
  assume that
A1: I c= P and
A2: k < LifeSpan(PI,s);
A4: IC s2 in dom I by A2,Th28;
A6: P/.IC s1 = P.IC s1 by PBOOLE:143;
   CurInstr(P,s1)=P.IC s2 by A6,A1,A2,Th29
    .=I.IC s2 by A1,A4,GRFUNC_1:2;
  hence thesis by A4,COMPOS_1:def 25;
end;

theorem Th33:
 for s being 0-started State of SCMPDS
  for I being parahalting Program of SCMPDS,
      J being Program of SCMPDS, k being Element of NAT
   st k <= LifeSpan(P +* stop I,s)
 holds Comput(P +* stop I,s,k) = Comput(P+*(I ';' J),s,k)
proof
  let s be 0-started State of SCMPDS;
  let I be parahalting Program of SCMPDS,J be Program of SCMPDS,
      k be Element of NAT;
  set spI= stop I, P1 = P +* spI, P2 = P +* (I ';' J);
  set n=LifeSpan(P1,s);
I: Initialize s = s by MEMSTR_0:44;
  defpred X[Element of NAT] means
   $1 <= n implies Comput(P1,s,$1) = Comput(P2,s,$1);
A2: for n being Element of NAT st X[n] holds X[n+1]
  proof
    let m be Element of NAT;
    assume
A3: m <= n implies Comput(P1,s,m) =  Comput(P2,s,m);
A4: Comput(P2,s,m+1) = Following(P2,Comput(P2,s,m)) by EXTPRO_1:3;
  spI c= P1 by FUNCT_4:25;
  then
A5: IC Comput(P1,s,m) in dom spI by SCMPDS_4:def 6;
A6: Comput(P1,s,m+1) = Following(P1,Comput(P1,s,m)) by EXTPRO_1:3;
    assume
A7: m+1 <= n;
A9: m < n by A7,NAT_1:13;
    then IC Comput(P1,s,m) in dom I by I,Th28;
    then
A10: IC Comput(P1,s,m) in dom (I ';' J) by FUNCT_4:12;
A11: IC Comput(P1,s,m) in dom I by A9,I,Th28;
    CurInstr(P1,Comput(P1,s,m))
       = P1.IC Comput(P1,s,m) by PBOOLE:143
      .= spI.IC Comput(P1,s,m) by A5,FUNCT_4:13
      .= I.IC Comput(P1,s,m) by A11,AFINSQ_1:def 3
      .= (I ';' J).IC Comput(P1,s,m) by A11,AFINSQ_1:def 3
      .= P2.IC Comput(P1,s,m) by A10,FUNCT_4:13
      .=CurInstr(P2,Comput(P2,s,m)) by A7,PBOOLE:143,A3,NAT_1:13;
    hence thesis by A3,A7,A6,A4,NAT_1:13;
  end;
A12: Comput(P2,s,0) = s by EXTPRO_1:2,I;
A15: X[0] by EXTPRO_1:2,A12,I;
   for k being Element of NAT holds X[k] from NAT_1:sch 1(A15, A2);
  hence thesis by I;
end;

theorem Th34:
  for s being 0-started State of SCMPDS
  for I being parahalting Program of SCMPDS,J being Program of SCMPDS,
      k being Element of NAT st k <= LifeSpan(P +* stop I,s)
  holds  Comput(P +* stop I, s,k) =  Comput(P+*stop(I ';' J),s,k)
proof
  let s be 0-started State of SCMPDS;
  let I be parahalting Program of SCMPDS,J be Program of SCMPDS,
      k be Element of NAT;
A1: stop (I ';' J) = (I ';' (J ';' Stop SCMPDS)) by AFINSQ_1:27;
A2: s = Initialize s by MEMSTR_0:44;
:::  assume k <= LifeSpan(P +* stop I,s);
  hence thesis by A1,Th33;
end;

registration
  let I be parahalting Program of SCMPDS,
      J be parahalting shiftable Program of SCMPDS;
  cluster I ';' J -> parahalting for Program of SCMPDS;
  coherence
  proof
    let p be Program of SCMPDS such that
A1:   p = I ';' J;
    let s be 0-started State of SCMPDS;
    let P;
    set sIJ = stop p;
    set spJ = stop J, s1 = Initialize s,
        P1 = P +* stop I,
        m1 = LifeSpan(P1,s1),
    s3 = Initialize Comput(P1, s1,m1),
    P3 = P1 +* spJ,
    m3 = LifeSpan(P3,s3),
    D = SCM-Data-Loc;
A8: spJ c= P3 by FUNCT_4:25;
    then
A9: P3 halts_on s3 by SCMPDS_4:def 7;
A11: DataPart Comput(P1,s1,m1) = DataPart s3 by MEMSTR_0:45;
A12: I c= sIJ by A1,Th12;
    set s4 = Comput(P,s,m1), P4=P;
    assume
A15: sIJ c= P;
B15: p c= sIJ by AFINSQ_1:74;
A16: s = Initialize s by MEMSTR_0:44;
    P+*(I ';' J) = P by FUNCT_4:98,B15,A1,A15,XBOOLE_1:1;
    then
A17: DataPart s4 = DataPart s3 by A11,A16,Th33;
    per cases by A15,A12,Th31,A16,XBOOLE_1:1;
    suppose
A18:  CurInstr(P,s4) = halt SCMPDS;
      take m1;
     IC Comput(P,s,m1) in NAT;
    hence IC Comput(P,s,m1) in dom P by PARTFUN1:def 2;
    thus thesis by A18;
    end;
    suppose
A19:  IC s4 =  card I;
      reconsider m = m1 + m3 as Element of NAT;
      take m;
     IC Comput(P,s,m) in NAT;
    hence IC Comput(P,s,m) in dom P by PARTFUN1:def 2;
A20: Comput(P,s,m1+m3) = Comput(P,Comput(P,s,m1),m3) by EXTPRO_1:4;
      sIJ = I ';' (J ';' Stop SCMPDS) by A1,AFINSQ_1:27
        .= I +* Shift(spJ, card I);
      then Shift(spJ, card I) c= sIJ by FUNCT_4:25;
      then
A21:    Shift(spJ, card I) c= P4 by A15,XBOOLE_1:1;
    CurInstr(P3,Comput(P3,s3,m3)) = CurInstr(P,Comput(P,s,m1+m3))
      by A20,A8,A17,A19,A21,SCMPDS_4:29;
     hence thesis by A9,EXTPRO_1:def 15;
    end;
  end;
end;

registration
  let i be parahalting Instruction of SCMPDS, J be parahalting shiftable
  Program of SCMPDS;
  cluster i ';' J -> parahalting;
  coherence;
end;

registration
  let I be parahalting Program of SCMPDS, j be parahalting shiftable
  Instruction of SCMPDS;
  cluster I ';' j -> parahalting;
  coherence;
end;

registration
  let i be parahalting Instruction of SCMPDS, j be parahalting shiftable
  Instruction of SCMPDS;
  cluster i ';' j -> parahalting;
  coherence;
end;

theorem Th35:
  for s being State of SCMPDS, s1 being 0-started State of SCMPDS,
      J being parahalting shiftable Program of SCMPDS
    st stop J c= P & s = Comput(P1 +* stop J, s1,m)
  holds Exec(CurInstr(P,s),IncIC(s,n)) = IncIC(Following(P,s),n)
proof
  let s be State of SCMPDS, s1 be 0-started State of SCMPDS,
      J be parahalting shiftable Program of SCMPDS;
  set pJ=stop J, s2=s1,
      P2 = P1 +* pJ;
  set i = CurInstr(P,s), ss=s +* Start-At(IC s + n,SCMPDS);
  reconsider k = IC s as Element of NAT;
  reconsider Nl=succ IC s as Element of NAT;
A1: succ IC ss = (k + n + 1) by FUNCT_4:113
    .= IC (Exec(i, s) +*Start-At (Nl + n,SCMPDS)) by FUNCT_4:113;
  assume
Z: pJ c= P;
  assume
ZZ:  s=Comput(P2,s2,m);
  pJ c= P2 by FUNCT_4:25;
  then
A3: IC s in dom pJ by ZZ,SCMPDS_4:def 6;
  reconsider n1 = IC s as Element of NAT;
  set IEn=IC Exec(i,s)+n;
A4: IC ss = IC s + n by FUNCT_4:113;
A6: P/.IC s = P.IC s by PBOOLE:143;
A7: i=pJ.(n1) by A3,A6,GRFUNC_1:2,Z;
  then
A8: InsCode i <> 1 by A3,SCMPDS_4:def 9;
A9: i valid_at n1 by A3,A7,SCMPDS_4:def 9;
A10: InsCode i <> 3 by A3,A7,SCMPDS_4:def 9;
  per cases by A8,A10,NAT_1:37,SCMPDS_2:6;
  suppose
    InsCode i = 0;
    then consider k1 such that
A11: i = goto k1 and
A12: n1+k1 >= 0 by A9,SCMPDS_4:def 8;
A13: IC Exec(i,s) =ICplusConst(s,k1) by A11,SCMPDS_2:54;
A14: now
      let b;
      thus Exec(i, ss).b= ss.b by A11,SCMPDS_2:54
        .= s.b by SCMPDS_3:6
        .= Exec(i, s).b by A11,SCMPDS_2:54
        .= (IncIC(Exec(i,s),n)).b by SCMPDS_3:6;
    end;
    IC Exec(i, ss) =ICplusConst(ss,k1) by A11,SCMPDS_2:54
      .=IEn by A4,A12,A13,SCMPDS_4:27
      .= IC (IncIC(Exec(i,s),n)) by FUNCT_4:113;
    hence thesis by A14,SCMPDS_2:44;
  end;
  suppose
    InsCode i = 2;
    then consider a,k1 such that
A15: i = a := k1 by SCMPDS_2:28;
A16: now
      let b;
      per cases;
      suppose
A17:    a = b;
        hence Exec(i, ss).b = k1 by A15,SCMPDS_2:45
          .= Exec(i,s).b by A15,A17,SCMPDS_2:45
          .= (IncIC(Exec(i,s),n)).b by SCMPDS_3:6;
      end;
      suppose
A18:    a <> b;
        hence Exec(i, ss).b = ss.b by A15,SCMPDS_2:45
          .= s.b by SCMPDS_3:6
          .= Exec(i, s).b by A15,A18,SCMPDS_2:45
          .= (IncIC(Exec(i,s),n)).b by SCMPDS_3:6;
      end;
    end;
    IC Exec(i, s) = Nl by A15,SCMPDS_2:45;
    then IC Exec(i, ss) = IC (IncIC(Exec(i,s),n))
    by A1,A15,SCMPDS_2:45;
    hence thesis by A16,SCMPDS_2:44;
  end;
  suppose
    InsCode i = 4;
    then consider a,k1,k2 such that
A19: i = (a,k1)<>0_goto k2 and
A20: n1+k2 >= 0 by A9,SCMPDS_4:def 8;
A21: now
      per cases;
      suppose
A22:    s.DataLoc(s.a,k1) <> 0;
        then
A23:    IC Exec(i,s) =ICplusConst(s,k2) by A19,SCMPDS_2:55;
        ss.DataLoc(s.a,k1) <> 0 by A22,SCMPDS_3:6;
        then ss.DataLoc(ss.a,k1) <> 0 by SCMPDS_3:6;
        hence IC Exec(i, ss) =ICplusConst(ss,k2) by A19,SCMPDS_2:55
          .=IEn by A4,A20,A23,SCMPDS_4:27
          .= IC (IncIC(Exec(i,s),n)) by FUNCT_4:113;
      end;
      suppose
A24:    s.DataLoc(s.a,k1) = 0;
        then ss.DataLoc(s.a,k1) = 0 by SCMPDS_3:6;
        then
A25:    ss.DataLoc(ss.a,k1) = 0 by SCMPDS_3:6;
        IC Exec(i, s) = Nl by A19,A24,SCMPDS_2:55;
        hence IC Exec(i,ss) = IC (IncIC(Exec(i,s),n))
        by A1,A19,A25,SCMPDS_2:55;
      end;
    end;
    now
      let b;
      thus Exec(i, ss).b= ss.b by A19,SCMPDS_2:55
        .= s.b by SCMPDS_3:6
        .= Exec(i, s).b by A19,SCMPDS_2:55
        .= (IncIC(Exec(i,s),n)).b by SCMPDS_3:6;
    end;
    hence thesis by A21,SCMPDS_2:44;
  end;
  suppose
    InsCode i = 5;
    then consider a,k1,k2 such that
A26: i = (a,k1)<=0_goto k2 and
A27: n1+k2 >= 0 by A9,SCMPDS_4:def 8;
A28: now
      per cases;
      suppose
A29:    s.DataLoc(s.a,k1) <= 0;
        then
A30:    IC Exec(i,s) =ICplusConst(s,k2) by A26,SCMPDS_2:56;
        ss.DataLoc(s.a,k1) <= 0 by A29,SCMPDS_3:6;
        then ss.DataLoc(ss.a,k1) <= 0 by SCMPDS_3:6;
        hence IC Exec(i, ss) =ICplusConst(ss,k2) by A26,SCMPDS_2:56
          .=IEn by A4,A27,A30,SCMPDS_4:27
          .= IC (IncIC(Exec(i,s),n)) by FUNCT_4:113;
      end;
      suppose
A31:    s.DataLoc(s.a,k1) > 0;
        then ss.DataLoc(s.a,k1) > 0 by SCMPDS_3:6;
        then
A32:    ss.DataLoc(ss.a,k1) > 0 by SCMPDS_3:6;
        IC Exec(i, s) = Nl by A26,A31,SCMPDS_2:56;
        hence IC Exec(i,ss) = IC (IncIC(Exec(i,s),n))
        by A1,A26,A32,SCMPDS_2:56;
      end;
    end;
    now
      let b;
      thus Exec(i, ss).b= ss.b by A26,SCMPDS_2:56
        .= s.b by SCMPDS_3:6
        .= Exec(i, s).b by A26,SCMPDS_2:56
        .= (IncIC(Exec(i,s),n)).b by SCMPDS_3:6;
    end;
    hence thesis by A28,SCMPDS_2:44;
  end;
  suppose
    InsCode i = 6;
    then consider a,k1,k2 such that
A33: i = (a,k1)>=0_goto k2 and
A34: n1+k2 >= 0 by A9,SCMPDS_4:def 8;
A35: now
      per cases;
      suppose
A36:    s.DataLoc(s.a,k1) >= 0;
        then
A37:    IC Exec(i,s) =ICplusConst(s,k2) by A33,SCMPDS_2:57;
        ss.DataLoc(s.a,k1) >= 0 by A36,SCMPDS_3:6;
        then ss.DataLoc(ss.a,k1) >= 0 by SCMPDS_3:6;
        hence IC Exec(i, ss) =ICplusConst(ss,k2) by A33,SCMPDS_2:57
          .=IEn by A4,A34,A37,SCMPDS_4:27
          .= IC (IncIC(Exec(i,s),n)) by FUNCT_4:113;
      end;
      suppose
A38:    s.DataLoc(s.a,k1) < 0;
        then ss.DataLoc(s.a,k1) < 0 by SCMPDS_3:6;
        then
A39:    ss.DataLoc(ss.a,k1) < 0 by SCMPDS_3:6;
        IC Exec(i, s) = Nl by A33,A38,SCMPDS_2:57;
        hence IC Exec(i,ss) = IC (IncIC(Exec(i,s),n))
        by A1,A33,A39,SCMPDS_2:57;
      end;
    end;
    now
      let b;
      thus Exec(i, ss).b= ss.b by A33,SCMPDS_2:57
        .= s.b by SCMPDS_3:6
        .= Exec(i, s).b by A33,SCMPDS_2:57
        .= (IncIC(Exec(i,s),n)).b by SCMPDS_3:6;
    end;
    hence thesis by A35,SCMPDS_2:44;
  end;
  suppose
    InsCode i = 7;
    then consider a,k1,k2 such that
A40: i = (a,k1) := k2 by SCMPDS_2:33;
A41: now
      let b;
      per cases;
      suppose
A42:    DataLoc(ss.a,k1) = b;
        then
A43:    DataLoc(s.a,k1) = b by SCMPDS_3:6;
        thus Exec(i, ss).b = k2 by A40,A42,SCMPDS_2:46
          .= Exec(i,s).b by A40,A43,SCMPDS_2:46
          .= (IncIC(Exec(i,s),n)).b by SCMPDS_3:6;
      end;
      suppose
A44:    DataLoc(ss.a,k1) <> b;
        then
A45:    DataLoc(s.a,k1) <> b by SCMPDS_3:6;
        thus Exec(i, ss).b = ss.b by A40,A44,SCMPDS_2:46
          .= s.b by SCMPDS_3:6
          .= Exec(i, s).b by A40,A45,SCMPDS_2:46
          .= (IncIC(Exec(i,s),n)).b by SCMPDS_3:6;
      end;
    end;
    IC Exec(i, s) = Nl by A40,SCMPDS_2:46;
    then IC Exec(i, ss) = IC IncIC(Exec(i,s),n) by A1,A40,SCMPDS_2:46;
    hence thesis by A41,SCMPDS_2:44;
  end;
  suppose
    InsCode i = 8;
    then consider a,k1,k2 such that
A46: i = AddTo(a,k1,k2) by SCMPDS_2:34;
A47: now
      let b;
      per cases;
      suppose
A48:    DataLoc(ss.a,k1) = b;
        then
A49:    DataLoc(s.a,k1) = b by SCMPDS_3:6;
        thus Exec(i, ss).b = ss.b + k2 by A46,A48,SCMPDS_2:48
          .= s.b + k2 by SCMPDS_3:6
          .= Exec(i, s).b by A46,A49,SCMPDS_2:48
          .= (IncIC(Exec(i,s),n)).b by SCMPDS_3:6;
      end;
      suppose
A50:    DataLoc(ss.a,k1) <> b;
        then
A51:    DataLoc(s.a,k1) <> b by SCMPDS_3:6;
        thus Exec(i, ss).b = ss.b by A46,A50,SCMPDS_2:48
          .= s.b by SCMPDS_3:6
          .= Exec(i, s).b by A46,A51,SCMPDS_2:48
          .= (IncIC(Exec(i,s),n)).b by SCMPDS_3:6;
      end;
    end;
    IC Exec(i, s) = Nl by A46,SCMPDS_2:48;
    then IC Exec(i, ss) = IC IncIC(Exec(i,s),n) by A1,A46,SCMPDS_2:48;
    hence thesis by A47,SCMPDS_2:44;
  end;
  suppose
    InsCode i = 9;
    then consider a,b,k1,k2 such that
A52: i = AddTo(a,k1,b,k2) by SCMPDS_2:35;
A53: now
      let c;
      per cases;
      suppose
A54:    DataLoc(ss.a,k1) = c;
        then
A55:    DataLoc(s.a,k1) = c by SCMPDS_3:6;
A56:    ss.DataLoc(ss.b,k2) =s.DataLoc(ss.b,k2) by SCMPDS_3:6
          .=s.DataLoc(s.b,k2) by SCMPDS_3:6;
        ss.DataLoc(ss.a,k1) =s.DataLoc(ss.a,k1) by SCMPDS_3:6
          .=s.DataLoc(s.a,k1) by SCMPDS_3:6;
        hence
        Exec(i, ss).c = s.DataLoc(s.a,k1) + s.DataLoc(s.b,k2) by A52,A54,A56,
SCMPDS_2:49
          .= Exec(i, s).c by A52,A55,SCMPDS_2:49
          .= (IncIC(Exec(i,s),n)).c by SCMPDS_3:6;
      end;
      suppose
A57:    DataLoc(ss.a,k1) <> c;
        then
A58:    DataLoc(s.a,k1) <> c by SCMPDS_3:6;
        thus Exec(i, ss).c = ss.c by A52,A57,SCMPDS_2:49
          .= s.c by SCMPDS_3:6
          .= Exec(i, s).c by A52,A58,SCMPDS_2:49
          .= (IncIC(Exec(i,s),n)).c by SCMPDS_3:6;
      end;
    end;
    IC Exec(i, s) = Nl by A52,SCMPDS_2:49;
    then IC Exec(i, ss) = IC (IncIC(Exec(i,s),n)) by A1,A52,SCMPDS_2:49;
    hence thesis by A53,SCMPDS_2:44;
  end;
  suppose
    InsCode i = 10;
    then consider a,b,k1,k2 such that
A59: i = SubFrom(a,k1,b,k2) by SCMPDS_2:36;
A60: now
      let c;
      per cases;
      suppose
A61:    DataLoc(ss.a,k1) = c;
        then
A62:    DataLoc(s.a,k1) = c by SCMPDS_3:6;
A63:    ss.DataLoc(ss.b,k2) =s.DataLoc(ss.b,k2) by SCMPDS_3:6
          .=s.DataLoc(s.b,k2) by SCMPDS_3:6;
        ss.DataLoc(ss.a,k1) =s.DataLoc(ss.a,k1) by SCMPDS_3:6
          .=s.DataLoc(s.a,k1) by SCMPDS_3:6;
        hence
        Exec(i, ss).c = s.DataLoc(s.a,k1) - s.DataLoc(s.b,k2) by A59,A61,A63,
SCMPDS_2:50
          .= Exec(i, s).c by A59,A62,SCMPDS_2:50
          .= (IncIC(Exec(i,s),n)).c by SCMPDS_3:6;
      end;
      suppose
A64:    DataLoc(ss.a,k1) <> c;
        then
A65:    DataLoc(s.a,k1) <> c by SCMPDS_3:6;
        thus Exec(i, ss).c = ss.c by A59,A64,SCMPDS_2:50
          .= s.c by SCMPDS_3:6
          .= Exec(i, s).c by A59,A65,SCMPDS_2:50
          .= (IncIC(Exec(i,s),n)).c by SCMPDS_3:6;
      end;
    end;
    IC Exec(i, s) = Nl by A59,SCMPDS_2:50;
    then IC Exec(i, ss) = IC (IncIC(Exec(i,s),n)) by A1,A59,SCMPDS_2:50;
    hence thesis by A60,SCMPDS_2:44;
  end;
  suppose
    InsCode i = 11;
    then consider a,b,k1,k2 such that
A66: i = MultBy(a,k1,b,k2) by SCMPDS_2:37;
A67: now
      let c;
      per cases;
      suppose
A68:    DataLoc(ss.a,k1) = c;
        then
A69:    DataLoc(s.a,k1) = c by SCMPDS_3:6;
A70:    ss.DataLoc(ss.b,k2) =s.DataLoc(ss.b,k2) by SCMPDS_3:6
          .=s.DataLoc(s.b,k2) by SCMPDS_3:6;
        ss.DataLoc(ss.a,k1) =s.DataLoc(ss.a,k1) by SCMPDS_3:6
          .=s.DataLoc(s.a,k1) by SCMPDS_3:6;
        hence Exec(i, ss).c = s.DataLoc(s.a,k1) * s.DataLoc(s.b,k2) by A66,A68
,A70,SCMPDS_2:51
          .= Exec(i, s).c by A66,A69,SCMPDS_2:51
          .= (IncIC(Exec(i,s),n)).c by SCMPDS_3:6;
      end;
      suppose
A71:    DataLoc(ss.a,k1) <> c;
        then
A72:    DataLoc(s.a,k1) <> c by SCMPDS_3:6;
        thus Exec(i, ss).c = ss.c by A66,A71,SCMPDS_2:51
          .= s.c by SCMPDS_3:6
          .= Exec(i, s).c by A66,A72,SCMPDS_2:51
          .= (IncIC(Exec(i,s),n)).c by SCMPDS_3:6;
      end;
    end;
    IC Exec(i, s) = Nl by A66,SCMPDS_2:51;
    then IC Exec(i, ss) = IC (IncIC(Exec(i,s),n)) by A1,A66,SCMPDS_2:51;
    hence thesis by A67,SCMPDS_2:44;
  end;
  suppose
    InsCode i = 12;
    then consider a,b,k1,k2 such that
A73: i = Divide(a,k1,b,k2) by SCMPDS_2:38;
A74: now
      let c;
A75:  ss.DataLoc(ss.a,k1) =s.DataLoc(ss.a,k1) by SCMPDS_3:6
        .=s.DataLoc(s.a,k1) by SCMPDS_3:6;
A76:  ss.DataLoc(ss.b,k2) =s.DataLoc(ss.b,k2) by SCMPDS_3:6
        .=s.DataLoc(s.b,k2) by SCMPDS_3:6;
      per cases;
      suppose
A77:    DataLoc(ss.b,k2) = c;
        then
A78:    DataLoc(s.b,k2) = c by SCMPDS_3:6;
        thus Exec(i, ss).c = s.DataLoc(s.a,k1) mod s.DataLoc(s.b,k2) by A73,A75
,A76,A77,SCMPDS_2:52
          .= Exec(i, s).c by A73,A78,SCMPDS_2:52
          .= (IncIC(Exec(i,s),n)).c by SCMPDS_3:6;
      end;
      suppose
A79:    DataLoc(ss.b,k2) <> c;
        then
A80:    DataLoc(s.b,k2) <> c by SCMPDS_3:6;
        hereby
          per cases;
          suppose
A81:        DataLoc(ss.a,k1) <> c;
            then
A82:        DataLoc(s.a,k1) <> c by SCMPDS_3:6;
            thus Exec(i, ss).c = ss.c by A73,A79,A81,SCMPDS_2:52
              .=s.c by SCMPDS_3:6
              .=Exec(i,s).c by A73,A80,A82,SCMPDS_2:52
              .= (IncIC(Exec(i,s),n)).c by SCMPDS_3:6;
          end;
          suppose
A83:        DataLoc(ss.a,k1) = c;
            then
A84:        DataLoc(s.a,k1) = c by SCMPDS_3:6;
            thus Exec(i, ss).c = s.DataLoc(s.a,k1) div s.DataLoc(s.b,k2) by A73
,A75,A76,A79,A83,SCMPDS_2:52
              .= Exec(i,s).c by A73,A80,A84,SCMPDS_2:52
              .= (IncIC(Exec(i,s),n)).c by SCMPDS_3:6;
          end;
        end;
      end;
    end;
    IC Exec(i, s) = Nl by A73,SCMPDS_2:52;
    then IC Exec(i, ss) = IC (IncIC(Exec(i,s),n)) by A1,A73,SCMPDS_2:52;
    hence thesis by A74,SCMPDS_2:44;
  end;
  suppose
    InsCode i = 13;
    then consider a,b,k1,k2 such that
A85: i = (a,k1):=(b,k2) by SCMPDS_2:39;
A86: now
      let c;
      per cases;
      suppose
A87:    DataLoc(ss.a,k1) = c;
        then
A88:    DataLoc(s.a,k1) = c by SCMPDS_3:6;
        thus Exec(i, ss).c = ss.DataLoc(ss.b,k2) by A85,A87,SCMPDS_2:47
          .=s.DataLoc(ss.b,k2) by SCMPDS_3:6
          .=s.DataLoc(s.b,k2) by SCMPDS_3:6
          .=Exec(i,s).c by A85,A88,SCMPDS_2:47
          .= (IncIC(Exec(i,s),n)).c by SCMPDS_3:6;
      end;
      suppose
A89:    DataLoc(ss.a,k1) <> c;
        then
A90:    DataLoc(s.a,k1) <> c by SCMPDS_3:6;
        thus Exec(i,ss).c = ss.c by A85,A89,SCMPDS_2:47
          .=s.c by SCMPDS_3:6
          .=Exec(i,s).c by A85,A90,SCMPDS_2:47
          .= (IncIC(Exec(i,s),n)).c by SCMPDS_3:6;
      end;
    end;
    IC Exec(i, s) = Nl by A85,SCMPDS_2:47;
    then IC Exec(i, ss) = IC IncIC(Exec(i,s),n) by A1,A85,SCMPDS_2:47;
    hence thesis by A86,SCMPDS_2:44;
  end;
end;

begin :: Computation of two consecutive program blocks

theorem
  for s being 0-started State of SCMPDS
  for I being parahalting halt-free Program of SCMPDS,J being
  parahalting shiftable Program of SCMPDS,k being Element of NAT st
  stop (I ';' J) c= P holds
   IncIC(Comput(P +* stop I +* stop J,
     Initialize Result(P +* stop I,s),k),card I)
  =  Comput(P+*stop(I ';' J),s,LifeSpan(P +* stop I,s)+k)
proof
  let s be 0-started State of SCMPDS;
  let I be parahalting halt-free Program of SCMPDS,J be parahalting
  shiftable Program of SCMPDS,k be Element of NAT;
  set sIsI = s, PIPI = P +* stop I,
      RI = Result(PIPI,sIsI), pJ= stop J,
   RIJ = Initialize RI, PRIJ = PIPI +* pJ,
   pIJ = stop (I ';' J),
   sIsIJ = s, PIPIJ = P +* pIJ;
LL:  pJ c= PRIJ by FUNCT_4:25;
   stop I c= PIPI by FUNCT_4:25;
   then
A2: PIPI halts_on sIsI by SCMPDS_4:def 7;
  set s2 = Comput(PIPIJ, sIsIJ,LifeSpan(PIPI,sIsI)+0);
  set s1 = RIJ +* Start-At (IC RIJ + card I,SCMPDS);
  set m1 = LifeSpan(PIPI,sIsI);
A3: I c= pIJ by Th12;
  assume
A4: pIJ c= P;
B4: P +* pIJ = P by A4,FUNCT_4:98;
A6: now
    thus IC s1 = IC RIJ + card I by FUNCT_4:113
      .=  (0+card I) by FUNCT_4:113
      .= IC s2 by A4,A3,Th30,B4,XBOOLE_1:1;

    hereby
      let a be Int_position;
YY: not a in dom Start-At(0,SCMPDS) by SCMPDS_4:18;
   not a in dom Start-At (IC RIJ + card I,SCMPDS) by SCMPDS_4:18;
      hence s1.a = RIJ.a by FUNCT_4:11
        .= RI.a by YY,FUNCT_4:11
        .= Comput(PIPI, sIsI,m1).a by A2,EXTPRO_1:23
        .= s2.a by Th34;
    end;
  end;
  defpred X[Element of NAT] means
    IncIC(Comput(PRIJ, RIJ,$1), card I)
     = Comput(PIPIJ, sIsIJ,LifeSpan(PIPI,sIsI)+$1);
A8: pIJ c= PIPIJ by FUNCT_4:25;
A9: for k being Element of NAT st X[k] holds X[k+1]
  proof
    let k be Element of NAT;
    set k1 = k+1, CRk = Comput(PRIJ, RIJ,k),
       PCRk = PRIJ,
       CRSk = IncIC(CRk,card I),
    CIJk = Comput(PIPIJ, sIsIJ,LifeSpan(PIPI,sIsI)+k),
    PCIJk = PIPIJ,
CRk1 = Comput(PRIJ, RIJ,k1
    ), CRSk1 = CRk1 +* Start-At (IC CRk1 + card I,SCMPDS),
    CIJk1 = Comput(PIPIJ, sIsIJ,
    LifeSpan(PIPI,sIsI)+k1);
    assume
A10:  CRSk =  CIJk;
A11: CurInstr(PCRk,CRk) = CurInstr(PCIJk,CIJk)
    proof
A13:  CurInstr(PCIJk,CIJk) = PCIJk.IC CRSk by A10,PBOOLE:143
        .= PCIJk.(IC CRk + card I) by FUNCT_4:113;
      reconsider n = IC CRk as Element of NAT;
A14:  pIJ = I ';' pJ by AFINSQ_1:27;
A15:  IC CRk in dom pJ by LL,SCMPDS_4:def 6;
      then n < card pJ by AFINSQ_1:66;
      then n+card I < card pJ + card I by XREAL_1:6;
      then n+card I < card pIJ by A14,AFINSQ_1:17;
      then
A16:  IC CRk + card I in dom pIJ by AFINSQ_1:66;
A17:  PCRk/.IC CRk = PCRk.IC CRk by PBOOLE:143;
      pJ c= PCRk by FUNCT_4:25;
      hence CurInstr(PCRk,CRk) =pJ.IC CRk by A15,A17,GRFUNC_1:2
        .=pIJ.(IC CRk + card I) by A15,A14,AFINSQ_1:def 3
        .= CurInstr(PCIJk,CIJk) by A13,A8,A16,GRFUNC_1:2;
    end;
A18:  Exec(CurInstr(PCIJk,CIJk), CIJk)
   =  IncIC(Following(PCRk,CRk), card I) by A10,Th35,A11,FUNCT_4:25;
    CIJk1 = Comput(PIPIJ, sIsIJ,LifeSpan(PIPI,sIsI)+k+1);
    then
A20: CIJk1 = Following(PIPIJ,CIJk) by EXTPRO_1:3;
A21: now
      let a be Int_position;
      thus CRSk1.a = CRk1.a by SCMPDS_3:6
        .= (Following(PRIJ,CRk)).a by EXTPRO_1:3
        .= CIJk1.a by A20,A18,SCMPDS_3:6;
    end;
    IC CRSk1 = IC CRk1 + card I by FUNCT_4:113
      .= IC Following(PRIJ,CRk) + card I by EXTPRO_1:3;
    then
    IC CRSk1 = IC CIJk1 by A20,A18,FUNCT_4:113;
    hence thesis by A21,SCMPDS_4:2;
  end;
  Comput(PRIJ, RIJ,0) = RIJ by EXTPRO_1:2;
  then
A24: X[0] by A6,SCMPDS_4:2;
  for k being Element of NAT holds X[k] from NAT_1:sch 1(A24,A9);
  hence thesis;
end;

Lm4:
 for I being parahalting halt-free Program of SCMPDS,
     J being parahalting shiftable Program of SCMPDS,
  s being 0-started State of SCMPDS st stop (I ';' J) c= P & P1= P +* stop I
   holds IC Comput(P, s,LifeSpan(P1,s)) = card I &
  DataPart Comput(P, s,LifeSpan(P1,s)) =
   DataPart (Initialize Comput(P1,s,LifeSpan(P1,s))) &
   Shift(stop J,card I) c= P &
   LifeSpan(P,s) = LifeSpan(P1,s)
    + LifeSpan(P1 +* stop J,Initialize Result(P1,s))
proof
  set D = SCM-Data-Loc;
  let I be parahalting halt-free Program of SCMPDS,J be parahalting
  shiftable Program of SCMPDS,s be 0-started State of SCMPDS;
A1: Initialize s = s by MEMSTR_0:44;
  set spJ = stop J,
  sIJ = stop (I ';' J), m1 = LifeSpan(P1,s),
  s3 = Initialize Comput(P1, s, m1),
  P3 = P1 +* spJ;
  set m3 = LifeSpan(P3,s3);
  assume that
A3: sIJ c= P and
A4: P1= P +* stop I;
  set s4 = Comput(P,s,m1), P4 = P;
A7: I c= sIJ by Th12;
  hence
A8: IC s4 =  card I by A3,A4,Th30,XBOOLE_1:1;
  reconsider m = m1 + m3 as Element of NAT;
  sIJ = I ';' (J ';' Stop SCMPDS) by AFINSQ_1:27
    .= I +* Shift(spJ, card I);
  then
A15: Shift(spJ, card I) c= sIJ by FUNCT_4:25;
A16: spJ c= P3 by FUNCT_4:25;
    then
A17: P3 halts_on s3 by SCMPDS_4:def 7;
A20: DataPart Comput(P1, s,m1) = DataPart s3 by MEMSTR_0:45;
  I ';' J c= stop (I ';' J) by AFINSQ_1:74;
  then P+*(I ';' J) = P by FUNCT_4:98,A3,XBOOLE_1:1;
  hence
A21: DataPart s4 = DataPart s3 by A20,A4,Th33,A1;
A23: Comput(P,s,m1+m3) = Comput(P,Comput(P,s,m1),m3) by EXTPRO_1:4;
  thus
A24: Shift(spJ, card I) c= P4 by A15,A3,XBOOLE_1:1;
  then CurInstr(P3,Comput(P3,s3,m3)) = CurInstr(P,Comput(P,s,m1+m3))
      by A23,A16,A8,A21,SCMPDS_4:29;
  then
A25: CurInstr(P,Comput(P,s,m)) = halt SCMPDS by A17,EXTPRO_1:def 15;
A26: now
    let k be Element of NAT;
    assume
    m1 + k < m;
    then
A27: k < m3 by XREAL_1:6;
    assume
A28: CurInstr(P,Comput(P,s,m1+k)) = halt SCMPDS;
A29: Comput(P,s,m1+k) =
Comput(P,Comput(P,s,m1),k) by EXTPRO_1:4;
    CurInstr(P3,Comput(P3,s3,k))
     = halt SCMPDS by A28,A29,A16,A8,A21,A24,SCMPDS_4:29;
    hence contradiction by A17,A27,EXTPRO_1:def 15;
  end;
  now
    let k be Element of NAT;
    assume
A30: k < m;
    per cases;
    suppose k < m1;
      hence CurInstr(P,Comput(P,s,k)) <> halt SCMPDS
            by A4,Th32,A3,A7,XBOOLE_1:1;
    end;
    suppose
      m1 <= k;
      then consider kk being Nat such that
A31:  m1 + kk = k by NAT_1:10;
      kk in NAT by ORDINAL1:def 12;
      hence CurInstr(P,Comput(P,s,k)) <> halt SCMPDS by A26,A30,A31;
    end;
  end;
  then
A32: for k being Element of NAT st CurInstr(P,Comput(P,s,k)) = halt SCMPDS
        holds m <= k;
 stop I c= P1 by A4,FUNCT_4:25;
 then P1 halts_on s by SCMPDS_4:def 7;
  then
A33: Result(P1,s) = Comput(P1,s,LifeSpan(P1,s)) by EXTPRO_1:23;
  P halts_on s by A3,SCMPDS_4:def 7;
  hence thesis by A33,A25,A32,EXTPRO_1:def 15;
end;

theorem Th37:
  for s being 0-started State of SCMPDS
  for I being parahalting halt-free Program of SCMPDS,
      J being parahalting shiftable Program of SCMPDS holds
  LifeSpan(P+*stop(I ';' J), s)
   = LifeSpan(P +* stop I,s) +
     LifeSpan(P +* stop I +* stop J,Initialize Result(P +* stop I,s))
proof
  let s be 0-started State of SCMPDS;
  let I be parahalting halt-free Program of SCMPDS,J be parahalting
  shiftable Program of SCMPDS;
  set sI=stop I, sIJ = stop (I ';' J),
  s1= s, s2= s,
  P1 = P +* sIJ, P2 = P +* stop I;
A1: sIJ c= P1 by FUNCT_4:25;
  set
  s3=Initialize Result(P1 +* stop I,s1),
  P3 = P1 +* stop I +* stop J,
  s4=Initialize Result(P2,s2),
  P4 = P2 +* stop J;
A2: stop I c= P2 by FUNCT_4:25;
A4: stop J c= P4 by FUNCT_4:25;
A6: stop J c= P3 by FUNCT_4:25;
A8: stop I c= P1 +* stop I by FUNCT_4:25;
  then s4 =  s3 by A2,Th21;
  then
A9: LifeSpan(P3,s3) = LifeSpan(P4,s4) by A6,A4,Th21;
  LifeSpan(P1 +* stop I,s1) =
  LifeSpan(P2,s2) by A8,A2,Th21;
  hence thesis by A1,A9,Lm4;
end;

theorem Th38:
  for s being 0-started State of SCMPDS
  for I being parahalting halt-free Program of SCMPDS,J being
parahalting shiftable Program of SCMPDS holds IExec(I ';' J,P,s)
 = IncIC(IExec(J,P,Initialize IExec(I,P,s)),card I)
proof
  let s be 0-started State of SCMPDS;
  let I be parahalting halt-free Program of SCMPDS,J be parahalting
  shiftable Program of SCMPDS;
  set A = NAT, D = SCM-Data-Loc, sI = stop I,
   sIJ = stop (I ';' J), P1 = P +* stop I,
   m1 = LifeSpan(P1,s), P2 = P +* stop(I ';' J),
   s3 = Initialize Comput(P1,s,m1), P3 = P1 +* stop J,
   m3 = LifeSpan(P3,s3);
A2: stop J c= P3 by FUNCT_4:25;
  then
A3: P3 halts_on s3 by SCMPDS_4:def 7;
A6: s = s by MEMSTR_0:44;
A9: stop J c= P +* stop J by FUNCT_4:25;
A11: stop I c= P1 by FUNCT_4:25;
  then
  P1 halts_on s by SCMPDS_4:def 7;
  then
A12: Initialize Comput(P1,s,m1)
      = Initialize IExec(I,P,s) by EXTPRO_1:23;
B13:  Result(P +* stop J,Initialize IExec(I,P,s))
   =  Result(P3,s3) by A2,A9,Th21,A12;
A15: stop I c= P2 +* stop I by FUNCT_4:25;
A16: s = s by MEMSTR_0:44;
A19: P2 +* stop I +* sIJ = P2 +* (stop I +* sIJ) by FUNCT_4:14
      .= P2 +* sIJ by Th17;
A20: LifeSpan(P2 +* stop I,s) = m1 by A11,A15,Th21;
 set S1=s,
     E1 = P2 +* stop I;
X2:  Comput(P1,s,m1)
  =  Comput(P1 +* stop(I ';' J), s,m1) by FUNCT_4:25,Th24;
B21:  P +* stop I +* sIJ =  P +* (stop I +* sIJ) by FUNCT_4:14
        .= P +* (sIJ +* sIJ) by Th17
        .= P2 +* stop I +* sIJ by A19,FUNCT_4:14;
A22: DataPart(Comput(P2 +* stop I,s,m1))
      = DataPart Comput(P1, s,m1) by B21,X2,FUNCT_4:25,A20,Th24;
A23: sIJ c= P2 by FUNCT_4:25;
  then
A24: DataPart Comput(P2,s,m1)
     = DataPart(Initialize Comput(P2 +* stop I,s,m1)) by A20,Lm4,A16
    .= DataPart(Comput(P2 +* stop I, s,m1)) by MEMSTR_0:45;
A25: Shift(stop J,card I) c= P2 by A23,A15,Lm4;
A26: IC Comput(P2,s,m1) =  card I by A23,A20,Lm4,A16;
B29: DataPart Initialize Comput(P1,s,m1)
     = DataPart Comput(P2,s,m1) by A22,A24,MEMSTR_0:45;
  then
A27: IC Comput(P2, Comput(P2,s,m1),m3) = IC Comput(P3,s3,m3) + card I
        by A25,A2,A26,SCMPDS_4:29;
A29: DataPart Comput(P2, Comput(P2,s,m1),m3) = DataPart Comput(P3,s3,m3)
   by A26,A25,A2,B29,SCMPDS_4:29;
A30: P1 halts_on s by A11,SCMPDS_4:def 7;
   then
A31: s3 = Initialize Result(P1,s) by EXTPRO_1:23;
 set SS1 = Initialize Result(P1,s) +* stop J,
     SS2 = Initialize IExec(I,P,s) +* stop J;
A33: IC Result(P1 +* stop J,Initialize Result(P1,s))
= IC Result(P +* stop J,Initialize IExec(I,P,s)) by Th21,A2,A9;
B34: P2 halts_on s
     by A23,SCMPDS_4:def 7;
A35: IC IExec(I ';' J,P,s)
     = IC Comput(P2,s,LifeSpan(P2,s)) by A6,B34,EXTPRO_1:23
    .= IC Comput(P2,s,m1+m3) by A31,Th37,A6
    .= IC Comput(P3,s3,m3) + card I by A27,EXTPRO_1:4
    .= IC Result(P3,s3) + card I by A3,EXTPRO_1:23
    .= IC IExec(J,P,Initialize IExec(I,P,s)) + card I
          by A33,A30,EXTPRO_1:23;
  IExec(I ';' J,P,s) = Comput(P2,s,LifeSpan(P2,s))
    by A6,B34,EXTPRO_1:23
    .= Comput(P2,s,m1+m3) by A31,Th37,A6;
  then
A36: DataPart IExec(I ';' J,P,s)
     = DataPart Comput(P3,s3,m3) by A29,EXTPRO_1:4
    .= DataPart IExec(J,P,Initialize IExec(I,P,s))
      by B13,A3,EXTPRO_1:23;
  hereby
    reconsider l = IC IExec(J,P,Initialize IExec(I,P,s)) + card I
     as Element of NAT;
A37: dom Start-At(l,SCMPDS) = {IC SCMPDS} by FUNCOP_1:13;
A38: now
      let x be set;
      assume
A39:  x in dom IExec(I ';' J,P,s);
      per cases by A39,SCMPDS_4:6;
      suppose
A40:    x is Int_position;
        then x <> IC SCMPDS by SCMPDS_2:43;
        then
A41:    not x in dom Start-At(l,SCMPDS) by A37,TARSKI:def 1;
        IExec(I ';' J,P,s).x
         = IExec(J,P,Initialize IExec(I,P,s)).x
        by A36,A40,SCMPDS_4:8;
        hence
        IExec(I ';' J,P,s).x
         = (IncIC(IExec(J,P,Initialize IExec(I,P,s)),card I)).x
           by A41,FUNCT_4:11;
      end;
      suppose
A42:    x = IC SCMPDS;
        then x in {IC SCMPDS} by TARSKI:def 1;
        then
A43:    x in dom Start-At(l,SCMPDS) by FUNCOP_1:13;
        thus IExec(I ';' J,P,s).x = (Start-At(l,SCMPDS)).IC SCMPDS
        by A35,A42,FUNCOP_1:72
          .= (IncIC(IExec(J,P,Initialize IExec(I,P,s)),card I)).x
           by A42,A43,FUNCT_4:13;
      end;
    end;
    dom IExec(I ';' J,P,s) = the carrier of SCMPDS by PARTFUN1:def 2
      .= dom IncIC(IExec(J,P,Initialize IExec(I,P,s)),card I)
                by PARTFUN1:def 2;
    hence thesis by A38,FUNCT_1:2;
  end;
end;

theorem
 for s being 0-started State of SCMPDS
 for I being parahalting halt-free Program of SCMPDS,J being
  parahalting shiftable Program of SCMPDS holds IExec(I ';' J,P,s).a
   = IExec(J,P,Initialize IExec(I,P,s)).a
proof
  let s be 0-started State of SCMPDS;
  let I be parahalting halt-free Program of SCMPDS,J be parahalting
  shiftable Program of SCMPDS;
A1: not a in
 dom Start-At(IC IExec(J,P,Initialize IExec(I,P,s)) + card I,SCMPDS)
by SCMPDS_4:18;
  IExec(I ';' J,P,s) = IncIC(IExec(J,P,Initialize IExec(I,P,s)),card I)
   by Th38;
  hence thesis by A1,FUNCT_4:11;
end;

begin :: Computation of the program consisting of a instruction and a block

canceled;

theorem
 s1 | (SCM-Data-Loc \/ {IC SCMPDS})
  = s2 | (SCM-Data-Loc \/ {IC SCMPDS}) implies s1 =  s2
proof
  set Y = NAT;
  set X = SCM-Data-Loc \/ {IC SCMPDS};
X1:  s1 = s1|(Data-Locations SCMPDS \/ {IC SCMPDS})
   &  s2 = s2|(Data-Locations SCMPDS \/ {IC SCMPDS}) by MEMSTR_0:33;
  thus thesis by X1,SCMPDS_2:84;
end;

theorem Th43:
  DataPart s1 = DataPart s2 & InsCode i <> 3 implies
   DataPart Exec(i,s1) = DataPart Exec(i,s2)
proof
  assume that
A1: DataPart s1 = DataPart s2 and
A2: InsCode i <> 3;
  per cases by A2,NAT_1:37,SCMPDS_2:6;
  suppose
    InsCode i = 0;
    then
A3: ex k1 st i = goto k1 by SCMPDS_2:26;
    now
      let a;
      thus Exec(i, s1).a = s1.a by A3,SCMPDS_2:54
        .=s2.a by A1,SCMPDS_4:8
        .=Exec(i, s2).a by A3,SCMPDS_2:54;
    end;
    hence thesis by SCMPDS_4:8;
  end;
  suppose
    InsCode i = 1;
    then consider a such that
A4: i = return a by SCMPDS_2:27;
    now
      let b;
      per cases;
      suppose
A5:     a=b;
        hence Exec(i, s1).b= s1.DataLoc(s1.a,RetSP) by A4,SCMPDS_2:58
          .=s2.DataLoc(s2.a,RetSP) by A1,SCMPDS_3:2
          .=Exec(i,s2).b by A4,A5,SCMPDS_2:58;
      end;
      suppose
A6:     a<>b;
        hence Exec(i, s1).b = s1.b by A4,SCMPDS_2:58
          .=s2.b by A1,SCMPDS_4:8
          .=Exec(i,s2).b by A4,A6,SCMPDS_2:58;
      end;
    end;
    hence thesis by SCMPDS_4:8;
  end;
  suppose
    InsCode i = 2;
    then consider a,k1 such that
A7: i = a := k1 by SCMPDS_2:28;
    now
      let b;
      per cases;
      suppose
A8:     a=b;
        hence Exec(i, s1).b= k1 by A7,SCMPDS_2:45
          .=Exec(i,s2).b by A7,A8,SCMPDS_2:45;
      end;
      suppose
A9:     a<>b;
        hence Exec(i,s1).b = s1.b by A7,SCMPDS_2:45
          .=s2.b by A1,SCMPDS_4:8
          .=Exec(i,s2).b by A7,A9,SCMPDS_2:45;
      end;
    end;
    hence thesis by SCMPDS_4:8;
  end;
  suppose
    InsCode i = 4;
    then
A10: ex a,k1,k2 st i = (a,k1)<>0_goto k2 by SCMPDS_2:30;
    now
      let a;
      thus Exec(i, s1).a = s1.a by A10,SCMPDS_2:55
        .=s2.a by A1,SCMPDS_4:8
        .=Exec(i, s2).a by A10,SCMPDS_2:55;
    end;
    hence thesis by SCMPDS_4:8;
  end;
  suppose
    InsCode i = 5;
    then
A11: ex a,k1,k2 st i = (a,k1)<=0_goto k2 by SCMPDS_2:31;
    now
      let a;
      thus Exec(i, s1).a = s1.a by A11,SCMPDS_2:56
        .=s2.a by A1,SCMPDS_4:8
        .=Exec(i, s2).a by A11,SCMPDS_2:56;
    end;
    hence thesis by SCMPDS_4:8;
  end;
  suppose
    InsCode i = 6;
    then
A12: ex a,k1,k2 st i = (a,k1)>=0_goto k2 by SCMPDS_2:32;
    now
      let a;
      thus Exec(i, s1).a = s1.a by A12,SCMPDS_2:57
        .=s2.a by A1,SCMPDS_4:8
        .=Exec(i, s2).a by A12,SCMPDS_2:57;
    end;
    hence thesis by SCMPDS_4:8;
  end;
  suppose
    InsCode i = 7;
    then consider a,k1,k2 such that
A13: i = (a,k1) := k2 by SCMPDS_2:33;
    now
      let b;
      per cases;
      suppose
A14:    DataLoc(s1.a,k1)=b;
        then
A15:    DataLoc(s2.a,k1)=b by A1,SCMPDS_4:8;
        thus Exec(i, s1).b= k2 by A13,A14,SCMPDS_2:46
          .=Exec(i,s2).b by A13,A15,SCMPDS_2:46;
      end;
      suppose
A16:    DataLoc(s1.a,k1)<>b;
        then
A17:    DataLoc(s2.a,k1)<>b by A1,SCMPDS_4:8;
        thus Exec(i,s1).b = s1.b by A13,A16,SCMPDS_2:46
          .=s2.b by A1,SCMPDS_4:8
          .=Exec(i,s2).b by A13,A17,SCMPDS_2:46;
      end;
    end;
    hence thesis by SCMPDS_4:8;
  end;
  suppose
    InsCode i = 8;
    then consider a,k1,k2 such that
A18: i = AddTo(a,k1,k2) by SCMPDS_2:34;
    now
      let b;
      per cases;
      suppose
A19:    DataLoc(s1.a,k1)=b;
        then
A20:    DataLoc(s2.a,k1)=b by A1,SCMPDS_4:8;
        thus Exec(i, s1).b= s1.DataLoc(s1.a,k1)+k2 by A18,A19,SCMPDS_2:48
          .= s2.DataLoc(s2.a,k1)+k2 by A1,SCMPDS_3:2
          .=Exec(i,s2).b by A18,A20,SCMPDS_2:48;
      end;
      suppose
A21:    DataLoc(s1.a,k1)<>b;
        then
A22:    DataLoc(s2.a,k1)<>b by A1,SCMPDS_4:8;
        thus Exec(i,s1).b = s1.b by A18,A21,SCMPDS_2:48
          .=s2.b by A1,SCMPDS_4:8
          .=Exec(i,s2).b by A18,A22,SCMPDS_2:48;
      end;
    end;
    hence thesis by SCMPDS_4:8;
  end;
  suppose
    InsCode i = 9;
    then consider a,b,k1,k2 such that
A23: i = AddTo(a,k1,b,k2) by SCMPDS_2:35;
    now
      let c;
      per cases;
      suppose
A24:    DataLoc(s1.a,k1)=c;
        then
A25:    DataLoc(s2.a,k1)=c by A1,SCMPDS_4:8;
        thus Exec(i, s1).c = s1.DataLoc(s1.a,k1)+s1.DataLoc(s1.b,k2) by A23,A24
,SCMPDS_2:49
          .= s2.DataLoc(s2.a,k1)+s1.DataLoc(s1.b,k2) by A1,SCMPDS_3:2
          .= s2.DataLoc(s2.a,k1)+s2.DataLoc(s2.b,k2) by A1,SCMPDS_3:2
          .=Exec(i,s2).c by A23,A25,SCMPDS_2:49;
      end;
      suppose
A26:    DataLoc(s1.a,k1)<>c;
        then
A27:    DataLoc(s2.a,k1)<>c by A1,SCMPDS_4:8;
        thus Exec(i,s1).c = s1.c by A23,A26,SCMPDS_2:49
          .=s2.c by A1,SCMPDS_4:8
          .=Exec(i,s2).c by A23,A27,SCMPDS_2:49;
      end;
    end;
    hence thesis by SCMPDS_4:8;
  end;
  suppose
    InsCode i = 10;
    then consider a,b,k1,k2 such that
A28: i = SubFrom(a,k1,b,k2) by SCMPDS_2:36;
    now
      let c;
      per cases;
      suppose
A29:    DataLoc(s1.a,k1)=c;
        then
A30:    DataLoc(s2.a,k1)=c by A1,SCMPDS_4:8;
        thus Exec(i, s1).c = s1.DataLoc(s1.a,k1)-s1.DataLoc(s1.b,k2)
         by A28,A29,SCMPDS_2:50
          .= s2.DataLoc(s2.a,k1)-s1.DataLoc(s1.b,k2) by A1,SCMPDS_3:2
          .= s2.DataLoc(s2.a,k1)-s2.DataLoc(s2.b,k2) by A1,SCMPDS_3:2
          .=Exec(i,s2).c by A28,A30,SCMPDS_2:50;
      end;
      suppose
A31:    DataLoc(s1.a,k1)<>c;
        then
A32:    DataLoc(s2.a,k1)<>c by A1,SCMPDS_4:8;
        thus Exec(i,s1).c = s1.c by A28,A31,SCMPDS_2:50
          .=s2.c by A1,SCMPDS_4:8
          .=Exec(i,s2).c by A28,A32,SCMPDS_2:50;
      end;
    end;
    hence thesis by SCMPDS_4:8;
  end;
  suppose
    InsCode i = 11;
    then consider a,b,k1,k2 such that
A33: i = MultBy(a,k1,b,k2) by SCMPDS_2:37;
    now
      let c;
      per cases;
      suppose
A34:    DataLoc(s1.a,k1)=c;
        then
A35:    DataLoc(s2.a,k1)=c by A1,SCMPDS_4:8;
        thus Exec(i, s1).c = s1.DataLoc(s1.a,k1)*s1.DataLoc(s1.b,k2) by A33,A34
,SCMPDS_2:51
          .= s2.DataLoc(s2.a,k1)*s1.DataLoc(s1.b,k2) by A1,SCMPDS_3:2
          .= s2.DataLoc(s2.a,k1)*s2.DataLoc(s2.b,k2) by A1,SCMPDS_3:2
          .=Exec(i,s2).c by A33,A35,SCMPDS_2:51;
      end;
      suppose
A36:    DataLoc(s1.a,k1)<>c;
        then
A37:    DataLoc(s2.a,k1)<>c by A1,SCMPDS_4:8;
        thus Exec(i,s1).c = s1.c by A33,A36,SCMPDS_2:51
          .=s2.c by A1,SCMPDS_4:8
          .=Exec(i,s2).c by A33,A37,SCMPDS_2:51;
      end;
    end;
    hence thesis by SCMPDS_4:8;
  end;
  suppose
    InsCode i = 12;
    then consider a,b,k1,k2 such that
A38: i = Divide(a,k1,b,k2) by SCMPDS_2:38;
    now
      let c;
      per cases;
      suppose
A39:    DataLoc(s1.b,k2)=c;
        then
A40:    DataLoc(s2.b,k2)=c by A1,SCMPDS_4:8;
        thus Exec(i, s1).c = s1.DataLoc(s1.a,k1) mod s1.DataLoc(s1.b,k2) by A38
,A39,SCMPDS_2:52
          .= s2.DataLoc(s2.a,k1) mod s1.DataLoc(s1.b,k2) by A1,SCMPDS_3:2
          .= s2.DataLoc(s2.a,k1) mod s2.DataLoc(s2.b,k2) by A1,SCMPDS_3:2
          .= Exec(i,s2).c by A38,A40,SCMPDS_2:52;
      end;
      suppose
A41:    DataLoc(s1.b,k2)<>c;
        then
A42:    DataLoc(s2.b,k2)<>c by A1,SCMPDS_4:8;
        hereby
          per cases;
          suppose
A43:        DataLoc(s1.a,k1)<>c;
            then
A44:        DataLoc(s2.a,k1)<>c by A1,SCMPDS_4:8;
            thus Exec(i, s1).c = s1.c by A38,A41,A43,SCMPDS_2:52
              .=s2.c by A1,SCMPDS_4:8
              .=Exec(i,s2).c by A38,A42,A44,SCMPDS_2:52;
          end;
          suppose
A45:        DataLoc(s1.a,k1)=c;
            then
A46:        DataLoc(s2.a,k1)=c by A1,SCMPDS_4:8;
            thus Exec(i, s1).c = s1.DataLoc(s1.a,k1) div s1.DataLoc(s1.b,k2)
            by A38,A41,A45,SCMPDS_2:52
              .= s2.DataLoc(s2.a,k1) div s1.DataLoc(s1.b,k2) by A1,SCMPDS_3:2
              .= s2.DataLoc(s2.a,k1) div s2.DataLoc(s2.b,k2) by A1,SCMPDS_3:2
              .= Exec(i,s2).c by A38,A42,A46,SCMPDS_2:52;
          end;
        end;
      end;
    end;
    hence thesis by SCMPDS_4:8;
  end;
  suppose
    InsCode i = 13;
    then consider a,b,k1,k2 such that
A47: i = (a,k1):=(b,k2) by SCMPDS_2:39;
    now
      let c;
      per cases;
      suppose
A48:    DataLoc(s1.a,k1)=c;
        then
A49:    DataLoc(s2.a,k1)=c by A1,SCMPDS_4:8;
        thus Exec(i, s1).c = s1.DataLoc(s1.b,k2) by A47,A48,SCMPDS_2:47
          .= s2.DataLoc(s2.b,k2) by A1,SCMPDS_3:2
          .=Exec(i,s2).c by A47,A49,SCMPDS_2:47;
      end;
      suppose
A50:    DataLoc(s1.a,k1)<>c;
        then
A51:    DataLoc(s2.a,k1)<>c by A1,SCMPDS_4:8;
        thus Exec(i,s1).c = s1.c by A47,A50,SCMPDS_2:47
          .=s2.c by A1,SCMPDS_4:8
          .=Exec(i,s2).c by A47,A51,SCMPDS_2:47;
      end;
    end;
    hence thesis by SCMPDS_4:8;
  end;
end;

theorem Th44:
  for i being shiftable Instruction of SCMPDS holds (DataPart s1 =
  DataPart s2 implies DataPart Exec(i,s1) = DataPart Exec(i,s2))
proof
  let i be shiftable Instruction of SCMPDS;
  InsCode i <> 3 by SCMPDS_4:def 10;
  hence thesis by Th43;
end;

theorem Th45:
 for s being 0-started State of SCMPDS
  for i being parahalting Instruction of SCMPDS
   holds Exec(i,s) = IExec(Load i,P,s)
proof
  let s be 0-started State of SCMPDS;
  let i be parahalting Instruction of SCMPDS;
  set Li=Load i, Mi= Macro i;
  set PI = P +* Mi;
  set IC1 = IC Comput(PI, s,1);
I: Initialize s = s by MEMSTR_0:44;
  Mi c= PI by FUNCT_4:25;
  then
A2: PI halts_on s by SCMPDS_4:def 7;
A3:  1 in dom Mi by COMPOS_1:57;
A4:  0 in dom Mi by COMPOS_1:57;
A22: Mi. 1=halt SCMPDS by COMPOS_1:59;
A23: Mi. 0 = i by COMPOS_1:58;
A24: Mi c= PI by FUNCT_4:25;
     then
A25: IC1 in dom Mi by SCMPDS_4:def 6;
A26: PI/.IC s = PI.IC s by PBOOLE:143;
A27: Comput(PI, s,0+1) = Following(PI,Comput(PI,s,0)) by EXTPRO_1:3
    .= Following(PI,s) by EXTPRO_1:2
    .= Exec(PI. 0, s) by A26,MEMSTR_0:47,I
    .= Exec(i, s) by A4,A23,A24,GRFUNC_1:2;
  per cases by A25,COMPOS_1:60;
  suppose
A28: IC1 =  0;
    set Ni=InsCode i;
    succ IC s = succ  0 by MEMSTR_0:47,I
      .=  1;
    then
A29: Ni in {0,1,4,5,6} by A27,A28,SCMPDS_4:1;
A30: CurInstr(PI,Comput(PI,s,1)) = PI. 0 by A28,PBOOLE:143
      .= i by A4,A23,A24,GRFUNC_1:2;
A31: Ni <> 1 by Th26;
    hereby
      per cases;
      suppose
        i = halt SCMPDS;
        hence thesis by A2,A27,A30,EXTPRO_1:def 9;
      end;
      suppose
A32:    i <> halt SCMPDS;
A34:    now
          let b;
          per cases by A29,A31,ENUMSET1:def 3;
          suppose
            InsCode i = 0;
            then ex k1 st i = goto k1 by SCMPDS_2:26;
            hence s.b=Exec(i, s).b by SCMPDS_2:54;
          end;
          suppose
            InsCode i = 4;
            then ex a,k1,k2 st i = (a,k1)<>0_goto k2 by SCMPDS_2:30;
            hence s.b=Exec(i, s).b by SCMPDS_2:55;
          end;
          suppose
            InsCode i = 5;
            then ex a,k1,k2 st i = (a,k1)<=0_goto k2 by SCMPDS_2:31;
            hence s.b=Exec(i, s).b by SCMPDS_2:56;
          end;
          suppose
            InsCode i = 6;
            then ex a,k1,k2 st i = (a,k1)>=0_goto k2 by SCMPDS_2:32;
            hence s.b=Exec(i, s).b by SCMPDS_2:57;
          end;
        end;
A35:    Following(PI,s) = Following(PI,Comput(PI,s,0)) by EXTPRO_1:2
          .= Exec(i, s) by A27,EXTPRO_1:3;
A36:    IC s = IC Exec(i, s) by A27,A28,MEMSTR_0:47,I;
        then
A37:    s = Exec(i, s) by A34,SCMPDS_2:44;
        now
          let n;
          Comput(PI, s,n) = s by A36,A34,A35,EXTPRO_1:27,SCMPDS_2:44
            .= Following(PI,Comput(PI,s,0))
            by A37,A35,EXTPRO_1:2
            .= Comput(PI, s,0+1) by EXTPRO_1:3;
          hence CurInstr(PI,Comput(PI,s,n)) <> halt SCMPDS by A30,A32;
        end;
        then not PI halts_on s by EXTPRO_1:29;
        hence thesis by A24,SCMPDS_4:def 7;
      end;
    end;
  end;
  suppose
A38:    IC1 =  1;
    CurInstr(PI,Comput(PI,s,1))
     = PI. 1 by A38,PBOOLE:143
      .= halt SCMPDS by A3,A22,A24,GRFUNC_1:2;
    hence thesis by A2,A27,EXTPRO_1:def 9;
  end;
end;

theorem Th46:
 for s being 0-started State of SCMPDS
  for I being parahalting halt-free Program of SCMPDS,
      j being parahalting shiftable Instruction of SCMPDS
 holds IExec(I ';' j,P,s).a = Exec(j,IExec(I,P,s)).a
proof
  let s be 0-started State of SCMPDS;
  let I be parahalting halt-free Program of SCMPDS,j be parahalting
  shiftable Instruction of SCMPDS;
  set Mj = Load j;
  set SA = Start-At (IC IExec(Mj,P,Initialize IExec(I,P,s)) + card I,SCMPDS);
A1: not a in dom SA by SCMPDS_4:18;
A2: a in SCM-Data-Loc by SCMPDS_2:def 2;
  for a holds (Initialize IExec(I,P,s)).a = IExec(I,P,s).a by Th19;
  then
A3: DataPart Initialize IExec(I,P,s) = DataPart IExec(I,P,s) by SCMPDS_4:8;
  thus IExec(I ';' j,P,s).a
   = IncIC(IExec(Mj,P,Initialize IExec(I,P,s)),card I).a by Th38
    .= IExec(Mj,P,Initialize IExec(I,P,s)).a by A1,FUNCT_4:11
    .= Exec(j, Initialize IExec(I,P,s)).a by Th45
    .= (DataPart Exec(j, Initialize IExec(I,P,s))).a
        by A2,FUNCT_1:49,SCMPDS_2:84
    .= (DataPart Exec(j, IExec(I,P,s))).a by A3,Th44
    .= Exec(j, IExec(I,P,s)).a by A2,FUNCT_1:49,SCMPDS_2:84;
end;

theorem
  for s being 0-started State of SCMPDS
  for i being No-StopCode parahalting Instruction of SCMPDS,
      j being shiftable parahalting Instruction of SCMPDS
 holds IExec(i ';' j,P,s).a = Exec(j,Exec(i, s)).a
proof
  let s be 0-started State of SCMPDS;
  let i be No-StopCode parahalting Instruction of SCMPDS, j be shiftable
  parahalting Instruction of SCMPDS;
  set Mi = Load i;
  thus IExec(i ';' j,P,s).a = IExec(Mi ';' j,P,s).a
    .= Exec(j, IExec(Mi,P,s)).a by Th46
    .= Exec(j, Exec(i, s)).a by Th45;
end;

