:: Computation of Two Consecutive Program Blocks for SCMPDS
::  by JingChao Chen
::
:: Received June 15, 1999
:: Copyright (c) 1999 Association of Mizar Users

environ

 vocabularies AMI_3, SCMPDS_2, AMI_1, INT_1, SCMPDS_4, FUNCT_1, RELAT_1,
      SCMFSA_7, SCMPDS_3, RELOC, CARD_1, SCMFSA6A, FUNCT_4, BOOLE, SCMFSA6B,
      FUNCT_7, SCM_1, AMI_2, AMI_5, SCMPDS_1, ABSVALUE, NAT_1, ARYTM_1,
      SCMPDS_5;
 notations TARSKI, XBOOLE_0, SETFAM_1, ENUMSET1, SUBSET_1, NUMBERS, XCMPLX_0,
      RELAT_1, FUNCT_1, FUNCT_4, INT_1, NAT_1, STRUCT_0, AMI_1, AMI_2, FUNCT_7,
      SCMPDS_1, SCMPDS_2, INT_2, SCMPDS_3, CARD_1, SCMPDS_4, XXREAL_0;
 constructors ENUMSET1, XXREAL_0, REAL_1, NAT_1, INT_2, SCM_1, SCMPDS_1,
      SCMPDS_4;
 registrations SETFAM_1, RELAT_1, FUNCT_1, FRAENKEL, NUMBERS, XREAL_0, INT_1,
      CARD_3, TREES_2, AMI_1, SCMPDS_2, SCMPDS_3, SCMPDS_4, ORDINAL1;
 requirements NUMERALS, REAL, SUBSET, BOOLE, ARITHM;
 definitions FUNCOP_1, AMI_1, AMI_3, SCMPDS_2, SCMPDS_3, SCMPDS_4;
 theorems AMI_1, NAT_1, REAL_1, CQC_LANG, TARSKI, FUNCT_4, FUNCT_1, INT_1,
      RELAT_1, SCMPDS_2, FUNCT_7, SCMPDS_3, CARD_1, PRE_CIRC, ENUMSET1,
      ABSVALUE, GRFUNC_1, SCMPDS_4, LATTICE2, XBOOLE_0, XBOOLE_1, XREAL_1,
      ORDINAL1, FUNCOP_1, XXREAL_0, AMI_2;
 schemes NAT_1;

begin :: Preliminaries

reserve x for set,
        m,n for Element of NAT,
        a,b,c for Int_position,
        i for Instruction of SCMPDS,
        s,s1,s2 for State of SCMPDS,
        k1,k2 for Integer,
        loc,l1 for Instruction-Location of SCMPDS,
        I,J for Program-block,
        N for with_non-empty_elements set;

theorem Th1:  :: S6B15
for S being halting IC-Ins-separated definite
   (non empty non void AMI-Struct over N),
    s being State of S st s = Following s
    holds for n holds (Computation s).n = s
proof
    let S be halting IC-Ins-separated definite
       (non empty non void AMI-Struct over N),
    s be State of S;
    assume
A1: s = Following s;
  defpred X[Element of NAT] means (Computation s).$1 = s;
A2: X[0] by AMI_1:def 19;
A3: for n st X[n] holds X[n+1] by A1,AMI_1:def 19;
   thus for n holds X[n] from NAT_1:sch 1(A2, A3);
end;

theorem Th2:
  x in dom Load i iff x = inspos 0
proof
   dom Load i = {inspos 0} by CQC_LANG:5;
 hence thesis by TARSKI:def 1;
end;

theorem Th3:    :: Stp
   loc in dom (stop I) & (stop I).loc <> halt SCMPDS
   implies loc in dom I
proof
  assume A1:loc in dom (stop I) & (stop I).loc <> halt SCMPDS;
  assume A2:not loc in dom I;
  set SS=SCMPDS-Stop,
      S2=Shift(SS, card I);
     loc in dom S2 by A1,A2,FUNCT_4:13;
    then loc in {l1+ card I : l1 in dom SS} by SCMPDS_3:38;
    then consider l1 such that
A3: loc=l1+ card I & l1 in dom SS;
     dom SS = {inspos 0} by CQC_LANG:5;
    then l1=inspos 0 by A3,TARSKI:def 1;
    hence contradiction by A1,A3,SCMPDS_4:38,73;
end;

theorem     :: PDS4_72
  dom Load i = {inspos 0} & (Load i).(inspos 0)=i by CQC_LANG:5,6;

theorem Th5:
  inspos 0 in dom Load i
proof
       dom Load i = {inspos 0} by CQC_LANG:5;
   hence thesis by TARSKI:def 1;
end;

theorem Th6:   :: PDS4_74
  card Load i = 1
proof
A1: dom Load i = {inspos 0} by CQC_LANG:5;
   thus card Load i = card dom Load i by PRE_CIRC:21
   .= 1 by A1,CARD_1:79;
end;

theorem   ::CardsI
 card stop I = card I + 1 by SCMPDS_4:45,74;

theorem Th8:
 card stop Load i = 2
proof
 thus card stop Load i = card (Load i) +1 by SCMPDS_4:45,74
      .=1+1 by Th6
      .=2;
end;

theorem Th9:  ::PDS4_75
 inspos 0 in dom stop (Load i) & inspos 1 in dom stop (Load i)
proof
       card stop Load i = 2 by Th8;
   hence thesis by SCMPDS_4:1;
end;

theorem Th10:
  (stop Load i).inspos 0=i & (stop Load i).inspos 1=halt SCMPDS
proof
   set II=Load i,
       SS=SCMPDS-Stop;
 inspos 0 in dom II by Th5;
   hence (stop II).inspos 0 =II.inspos 0 by SCMPDS_4:37
    .=i by CQC_LANG:6;
        inspos 1=inspos (0+1)
    .=inspos 0 + 1 by SCMPDS_3:def 3
    .=inspos 0 + card II by Th6;
   hence (stop II).inspos 1=halt SCMPDS by SCMPDS_4:38,73;
end;

theorem Th11:   ::SCMFSA6B_32
  x in dom stop Load i iff x=inspos 0 or x=inspos 1
proof
     set pi=stop Load i,
         A = the Instruction-Locations of SCMPDS;
A1:  card pi = 2 by Th8;
     hereby assume A2:x in dom pi;
           dom pi c= A by AMI_1:def 40;
       then reconsider l=x as Instruction-Location of SCMPDS by A2,AMI_1:def 4;
       consider n such that
A3:    l=inspos n by SCMPDS_3:32;
           n < 1+1 by A1,A2,A3,SCMPDS_4:1;
       then n <= 1 by NAT_1:13;
       hence x=inspos 0 or x=inspos 1 by A3,NAT_1:26;
     end;
     assume A4:x=inspos 0 or x=inspos 1;
     per cases by A4;
     suppose x=inspos 0;
       hence x in dom pi by A1,SCMPDS_4:1;
     end;
     suppose x=inspos 1;
       hence x in dom pi by A1,SCMPDS_4:1;
end;
end;

theorem
      dom (stop Load i)={inspos 0,inspos 1}
proof
      for x holds (x in dom (stop Load i) iff x=inspos 0 or x=inspos 1)
  by Th11;
  hence thesis by TARSKI:def 2;
end;

theorem Th13:
  inspos 0 in dom (Initialized stop Load i) &
  inspos 1 in dom (Initialized stop Load i) &
  (Initialized stop Load i).inspos 0=i &
  (Initialized stop Load i).inspos 1=halt SCMPDS
proof
    set si=stop Load i,
        Ii=Initialized si;
A1: inspos 0 in dom si & inspos 1 in dom si by Th9;
        si c= Ii by SCMPDS_4:9;
    then dom si c= dom Ii by RELAT_1:25;
    hence inspos 0 in dom Ii & inspos 1 in dom Ii by A1;
    thus Ii.inspos 0=si.inspos 0 by A1,SCMPDS_4:33
          .=i by Th10;
    thus Ii.inspos 1=si.inspos 1 by A1,SCMPDS_4:33
          .=halt SCMPDS by Th10;
end;

canceled;

theorem Th15:
 for I,J being Program-block holds
  Initialized I c= Initialized stop (I ';' J)
proof
    let I,J be Program-block;
    set SA0=Start-At inspos 0,
        IS=I ';' (J ';' SCMPDS-Stop),
        Ip=Initialized stop (I ';' J);
A1: dom IS misses dom SA0 by SCMPDS_4:54;
  Ip= IS +* SA0 by SCMPDS_4:46;
then A2: IS c= Ip by A1,FUNCT_4:33;
        I c= IS by SCMPDS_4:40;
then A3: I c= Ip by A2,XBOOLE_1:1;
    A4: SA0 c= Ip by FUNCT_4:26;
        dom I misses dom SA0 by SCMPDS_4:54;
    then I \/ SA0 =Initialized I by FUNCT_4:32;
    hence thesis by A3,A4,XBOOLE_1:8;
end;

theorem Th16:
   dom stop I c= dom stop (I ';' J)
proof
    set sI=stop I,
        sIJ=stop (I ';'J);
A1: card sI=card I +1 by SCMPDS_4:45,74;
        card sIJ=card (I ';' J) +1 by SCMPDS_4:45,74
    .=card I + card J +1 by SCMPDS_4:45
    .=card I + 1 + card J;
then A2: card sI <= card sIJ by A1,NAT_1:11;
        now let x be set;
      set A = the Instruction-Locations of SCMPDS;
       assume
    A3: x in dom sI;
           dom sI c= A by AMI_1:def 40;
       then reconsider l=x as Instruction-Location of SCMPDS by A3,AMI_1:def 4;
       consider n such that
    A4: inspos n= l by SCMPDS_3:32;
            n < card sI by A3,A4,SCMPDS_4:1;
        then n < card sIJ by A2,XXREAL_0:2;
        hence x in dom sIJ by A4,SCMPDS_4:1;
     end;
     hence thesis by TARSKI:def 3;
end;

theorem Th17:   :: SCMPDS_4:42,T6A40
 for I,J being Program-block holds
     Initialized stop I +* Initialized stop (I ';' J)
     = Initialized stop (I ';' J)
proof
   let I,J be Program-block;
   set sI=stop I,
       IsI=Initialized sI,
       sIJ=stop (I ';' J),
       IsIJ=Initialized sIJ;
A1: dom sI c= dom sIJ by Th16;
A2: dom IsI = dom sI \/ {IC SCMPDS} by SCMPDS_4:27;
     dom IsIJ = dom sIJ \/ {IC SCMPDS} by SCMPDS_4:27;
    then dom IsI c= dom IsIJ by A1,A2,XBOOLE_1:9;
    hence thesis by FUNCT_4:20;
end;

theorem Th18:
  Initialized I c= s implies IC s = inspos 0
proof assume
A1: Initialized I c= s;
A2: IC Initialized I = inspos 0 by SCMPDS_4:8;
       IC SCMPDS in dom Initialized I by SCMPDS_4:7;
 hence IC s = inspos 0 by A1,A2,AMI_1:97;
end;

theorem Th19:
  (s +* Initialized I).a = s.a
proof
        not a in dom Initialized I by SCMPDS_4:31;
    hence thesis by FUNCT_4:12;
end;

theorem Th20: ::T13
 for I being parahalting Program-block st
     Initialized stop I c= s1 & Initialized stop I c= s2 &
     s1,s2 equal_outside the Instruction-Locations of SCMPDS holds
 for k being Element of NAT holds
     (Computation s1).k, (Computation s2).k
         equal_outside the Instruction-Locations of SCMPDS &
     CurInstr (Computation s1).k = CurInstr (Computation s2).k
 proof
   let I be parahalting Program-block;
   set SI=stop I;
   assume that
A1: Initialized SI c= s1 and
A2: Initialized SI c= s2 and
A3: s1,s2 equal_outside the Instruction-Locations of SCMPDS;
A4: SI c= s1 by A1,SCMPDS_4:57;
A5: SI c= s2 by A2,SCMPDS_4:57;
   hereby let k be Element of NAT;
          for m being Element of NAT st m < k
         holds IC((Computation s2).m) in dom SI
          by A2,SCMPDS_4:def 9;
      hence (Computation s1).k, (Computation s2).k equal_outside
          the Instruction-Locations of SCMPDS by A3,A4,A5,SCMPDS_4:67;
  then A6: IC (Computation s1).k = IC (Computation s2).k by AMI_1:121;
  A7: IC (Computation s1).k in dom SI by A1,SCMPDS_4:def 9;
  A8: IC (Computation s2).k in dom SI by A2,SCMPDS_4:def 9;
      thus CurInstr (Computation s2).k
       = s2.IC (Computation s2).k by AMI_1:54
      .= SI.IC (Computation s2).k by A5,A8,GRFUNC_1:8
      .= s1.IC (Computation s1).k by A4,A6,A7,GRFUNC_1:8
      .= CurInstr (Computation s1).k by AMI_1:54;
    end;
end;

theorem Th21: ::T14
 for I being parahalting Program-block st
     Initialized stop I c= s1 & Initialized stop I c= s2 &
     s1,s2 equal_outside the Instruction-Locations of SCMPDS holds
 LifeSpan s1 = LifeSpan s2 &
     Result s1, Result s2 equal_outside the Instruction-Locations of SCMPDS
proof
   let I be parahalting Program-block;
   set SI=stop I;
   assume that
A1: Initialized SI c= s1 and
A2: Initialized SI c= s2 and
A3: s1,s2 equal_outside the Instruction-Locations of SCMPDS;
A4: s1 is halting by A1,SCMPDS_4:63;
A5: now let l be Element of NAT; assume
   A6: CurInstr (Computation s2).l = halt SCMPDS;
       CurInstr (Computation s1).l = CurInstr (Computation s2).l by A1,A2,A3,
Th20
;
      hence LifeSpan s1 <= l by A4,A6,AMI_1:def 46;
     end;
A7: CurInstr (Computation s2).LifeSpan s1
     = CurInstr (Computation s1).LifeSpan s1 by A1,A2,A3,Th20
    .= halt SCMPDS by A4,AMI_1:def 46;
A8: s2 is halting by A2,SCMPDS_4:63;
   hence LifeSpan s1 = LifeSpan s2 by A5,A7,AMI_1:def 46;
then A9: Result s2 = (Computation s2).LifeSpan s1 by A8,AMI_1:122;
       Result s1 = (Computation s1).LifeSpan s1 by A4,AMI_1:122;
   hence Result s1, Result s2 equal_outside
       the Instruction-Locations of SCMPDS by A1,A2,A3,A9,Th20;
end;

theorem Th22: ::T27
 for I being Program-block
  holds IC IExec(I,s) = IC Result (s +* Initialized stop I)
proof
   let I be Program-block;
   set SI=stop I,
       IL=the Instruction-Locations of SCMPDS;
A1: dom s = {IC SCMPDS} \/ SCM-Data-Loc \/ IL by SCMPDS_4:19;
A2:  dom (s | IL)
    = dom s /\ IL by RELAT_1:90
   .= IL by A1,XBOOLE_1:21;
 now assume IC SCMPDS in dom (s | IL);
      then reconsider l=IC SCMPDS as Instruction-Location of SCMPDS
             by A2,AMI_1:def 4;
       l=IC SCMPDS;
     hence contradiction by AMI_1:48;
    end;
   hence IC IExec(I,s) = IC Result (s +* Initialized SI) by FUNCT_4:12;
end;

theorem Th23:
 for I being parahalting Program-block, J being Program-block
   st Initialized stop I c= s
 for m st m <= LifeSpan s
  holds (Computation s).m,(Computation(s+*(I ';' J))).m
    equal_outside the Instruction-Locations of SCMPDS
proof let I be parahalting Program-block, J be Program-block;
 set SI=stop I,
     IL=the Instruction-Locations of SCMPDS;
 assume
A1: Initialized SI c= s;
then A2: s is halting by SCMPDS_4:63;
  defpred X[Element of NAT] means
   $1 <= LifeSpan s implies (Computation s).$1,(Computation(s+*(I ';' J))).$1
    equal_outside IL;
       (Computation s).0 = s &
   (Computation(s+*(I ';' J))).0 = s+*(I ';' J) by AMI_1:def 19;
then A3: X[0] by AMI_1:120;
A4: for m st X[m] holds X[m+1]
   proof let m;
      assume
A5:   m <= LifeSpan s implies
         (Computation s).m,(Computation(s+*(I ';' J))).m equal_outside IL;
      assume A6: m+1 <= LifeSpan s;
then A7:    m < LifeSpan s by NAT_1:13;
       set Cs = Computation s,
         CsIJ = Computation(s+*(I ';' J));
A8:    Cs.(m+1) = Following Cs.m by AMI_1:def 19
             .= Exec(CurInstr Cs.m,Cs.m);
A9:   CsIJ.(m+1) = Following CsIJ.m by AMI_1:def 19
             .= Exec(CurInstr CsIJ.m,CsIJ.m);
A10:   IC (Cs.m) = IC (CsIJ.m) by A5,A6,AMI_1:121,NAT_1:13;
A11:   IC Cs.m in dom SI by A1,SCMPDS_4:def 9;
           dom SI misses dom Start-At inspos 0 by SCMPDS_4:54;
       then SI c= SI +* Start-At inspos 0 by FUNCT_4:33;
       then SI c= s by A1,XBOOLE_1:1;
then A12:   SI c= Cs.m by AMI_1:81;
           I ';' J c= s+*(I ';' J) by FUNCT_4:26;
then A13:   I ';' J c= CsIJ.m by AMI_1:81;
A14:   CurInstr(Cs.m) = SI.IC (Cs.m) by A11,A12,GRFUNC_1:8;
  then SI.IC(Cs.m) <> halt SCMPDS by A2,A7,AMI_1:def 46;
then A15:   IC Cs.m in dom I by A11,Th3;
          dom(I ';' J) = dom I \/ dom Shift(J, card I) by FUNCT_4:def 1;
      then A16: dom I c= dom(I ';' J) by XBOOLE_1:7;
          CurInstr(Cs.m)=I.IC (Cs.m) by A14,A15,SCMPDS_4:37
        .=(I ';' J).IC(Cs.m) by A15,SCMPDS_4:37
        .= CurInstr(CsIJ.m) by A10,A13,A15,A16,GRFUNC_1:8;
    hence (Computation s).(m+1),(Computation(s+*(I ';' J))).(m+1)
          equal_outside IL by A5,A6,A8,A9,NAT_1:13,SCMPDS_4:15;
   end;
 thus for m holds X[m] from NAT_1:sch 1(A3,A4);
end;

theorem Th24:
 for I being parahalting Program-block, J being Program-block
   st Initialized stop I c= s
 for m st m <= LifeSpan s
  holds (Computation s).m,(Computation(s+*Initialized stop (I ';' J))).m
    equal_outside the Instruction-Locations of SCMPDS
proof
   let I be parahalting Program-block, J be Program-block;
   assume A1: Initialized stop I c= s;
   let m;
   assume A2: m <= LifeSpan s;
   set sIJ=stop (I ';' J),
       SS=SCMPDS-Stop;
    sIJ= I ';' (J ';' SS) by SCMPDS_4:46;
   then s +* Initialized sIJ =s +* (I ';' (J ';' SS)) by A1,SCMPDS_4:34;
   hence thesis by A1,A2,Th23;
end;

Lm1:
  Load (DataLoc(0,0):=0) is parahalting
proof
  set ii= DataLoc(0,0):=0,
      m0= stop Load ii,
      m1 = Initialized m0;
  set SA0 = Start-At inspos 0;
  let s such that
A1: m1 c= s;
    take 1;
        SA0 c= m1 by FUNCT_4:26;
then A2: SA0 c= s by A1,XBOOLE_1:1;
        dom SA0 = {IC SCMPDS} by FUNCOP_1:19;
then IC SCMPDS in dom SA0 by TARSKI:def 1;
then A3: IC s = SA0.IC SCMPDS by A2,GRFUNC_1:8
       .= inspos 0 by CQC_LANG:6;
A4: inspos 0 in dom m0 & inspos 1 in dom m0 by Th9;
       m0 c= s by A1,SCMPDS_4:57;
   then A5: m0.inspos 0 = s.inspos 0 & m0.inspos 1 = s.inspos 1 by A4,
GRFUNC_1:8;
then A6: s.inspos 0 = ii & s.inspos 1 = halt SCMPDS by Th10;
A7: IC Exec(ii, s) = Next inspos 0 by A3,SCMPDS_2:57
                   .= inspos (0+1) by SCMPDS_4:70;
     (Computation s).(0+1) = Following (Computation s).0 by AMI_1:def 19
      .= Following s by AMI_1:def 19
      .= Exec(ii,s) by A3,A5,Th10;
  hence CurInstr((Computation s).1)
      = halt SCMPDS by A6,A7,AMI_1:def 13;
end;

begin :: Non halting instrutions and parahalting instrutions

definition let i be Instruction of SCMPDS;
 attr i is No-StopCode means
:Def1:   i <> halt SCMPDS;
end;

definition
 let i be Instruction of SCMPDS;
 attr i is parahalting means
:Def2:   Load i is parahalting;
end;

registration
 cluster No-StopCode shiftable parahalting Instruction of SCMPDS;
 existence proof
  take i=DataLoc(0,0):=0;
A1:InsCode i=2 by SCMPDS_2:23;
       InsCode halt SCMPDS=0 by SCMPDS_2:21,93;
   hence thesis by A1,Def1,Def2,Lm1;
 end;
end;

theorem
       k1 <>0 implies goto k1 is No-StopCode
proof
  set i=goto k1;
  assume A1: k1 <>0;
  assume i is not No-StopCode;
  then i=halt SCMPDS by Def1;
  hence contradiction by A1,SCMPDS_2:85;
end;

registration
 let a;
 cluster return a -> No-StopCode;
 coherence
 proof
    set i=return a;
A1: InsCode i=1 by SCMPDS_2:22;
       InsCode halt SCMPDS=0 by SCMPDS_2:21,93;
   hence thesis by A1,Def1;
 end;
end;

registration
 let a,k1;
 cluster a := k1 -> No-StopCode;
 coherence
 proof
    set i=a:=k1;
A1: InsCode i=2 by SCMPDS_2:23;
       InsCode halt SCMPDS=0 by SCMPDS_2:21,93;
   hence thesis by A1,Def1;
 end;

 cluster saveIC(a,k1) -> No-StopCode;
 coherence
 proof
    set i=saveIC(a,k1);
A2: InsCode i=3 by SCMPDS_2:24;
       InsCode halt SCMPDS=0 by SCMPDS_2:21,93;
   hence thesis by A2,Def1;
 end;
end;

registration
 let a,k1,k2;
 cluster (a,k1)<>0_goto k2 -> No-StopCode;
 coherence
 proof
    set i=(a,k1)<>0_goto k2;
A1: InsCode i=4 by SCMPDS_2:25;
       InsCode halt SCMPDS=0 by SCMPDS_2:21,93;
   hence thesis by A1,Def1;
 end;

 cluster (a,k1)<=0_goto k2 -> No-StopCode;
 coherence
 proof
    set i=(a,k1)<=0_goto k2;
A2: InsCode i=5 by SCMPDS_2:26;
       InsCode halt SCMPDS=0 by SCMPDS_2:21,93;
   hence thesis by A2,Def1;
 end;

 cluster (a,k1)>=0_goto k2 -> No-StopCode;
 coherence
 proof
    set i=(a,k1)>=0_goto k2;
A3: InsCode i=6 by SCMPDS_2:27;
       InsCode halt SCMPDS=0 by SCMPDS_2:21,93;
   hence thesis by A3,Def1;
 end;

 cluster (a,k1) := k2 -> No-StopCode;
 coherence
 proof
    set i=(a,k1) := k2;
A4: InsCode i=7 by SCMPDS_2:28;
       InsCode halt SCMPDS=0 by SCMPDS_2:21,93;
   hence thesis by A4,Def1;
 end;
end;

registration
 let a,k1,k2;
 cluster AddTo(a,k1,k2) -> No-StopCode;
 coherence
 proof
    set i=AddTo(a,k1,k2);
A1: InsCode i=8 by SCMPDS_2:29;
       InsCode halt SCMPDS=0 by SCMPDS_2:21,93;
   hence thesis by A1,Def1;
 end;
end;

registration
 let a,b,k1,k2;
cluster AddTo(a,k1,b,k2) -> No-StopCode;
 coherence
 proof
    set i=AddTo(a,k1,b,k2);
A1: InsCode i=9 by SCMPDS_2:30;
       InsCode halt SCMPDS=0 by SCMPDS_2:21,93;
   hence thesis by A1,Def1;
 end;

cluster SubFrom(a,k1,b,k2) -> No-StopCode;
 coherence
 proof
    set i=SubFrom(a,k1,b,k2);
A2: InsCode i=10 by SCMPDS_2:31;
       InsCode halt SCMPDS=0 by SCMPDS_2:21,93;
   hence thesis by A2,Def1;
 end;

cluster MultBy(a,k1,b,k2) -> No-StopCode;
 coherence
 proof
    set i=MultBy(a,k1,b,k2);
A3: InsCode i=11 by SCMPDS_2:32;
       InsCode halt SCMPDS=0 by SCMPDS_2:21,93;
   hence thesis by A3,Def1;
 end;

cluster Divide(a,k1,b,k2) -> No-StopCode;
 coherence
 proof
    set i=Divide(a,k1,b,k2);
A4: InsCode i=12 by SCMPDS_2:33;
       InsCode halt SCMPDS=0 by SCMPDS_2:21,93;
   hence thesis by A4,Def1;
 end;

cluster (a,k1) := (b,k2) -> No-StopCode;
 coherence
 proof
    set i=(a,k1) := (b,k2);
A5: InsCode i=13 by SCMPDS_2:34;
       InsCode halt SCMPDS=0 by SCMPDS_2:21,93;
   hence thesis by A5,Def1;
 end;
end;

registration
 cluster halt SCMPDS -> parahalting;
 coherence proof
        SCMPDS-Stop=Load halt SCMPDS;
    hence thesis by Def2;
 end;
end;

registration
 let i be parahalting Instruction of SCMPDS;
 cluster Load i -> parahalting;
 coherence by Def2;
end;

Lm2:
  (for s holds Exec(i,s).IC SCMPDS = Next IC s)
    implies Load i is parahalting
proof
   assume
A1: for s holds Exec(i,s).IC SCMPDS = Next IC s;
  set m0= stop Load i,
      m1 = Initialized m0;
  set SA0 = Start-At inspos 0;
  let t be State of SCMPDS such that
A2: m1 c= t;
    take 1;
        SA0 c= m1 by FUNCT_4:26;
then A3: SA0 c= t by A2,XBOOLE_1:1;
        dom SA0 = {IC SCMPDS} by FUNCOP_1:19;
then IC SCMPDS in dom SA0 by TARSKI:def 1;
then A4: IC t = SA0.IC SCMPDS by A3,GRFUNC_1:8
       .= inspos 0 by CQC_LANG:6;
A5: inspos 0 in dom m0 & inspos 1 in dom m0 by Th9;
       m0 c= t by A2,SCMPDS_4:57;
   then A6: m0.inspos 0 = t.inspos 0 & m0.inspos 1 = t.inspos 1 by A5,
GRFUNC_1:8;
then A7: t.inspos 0 = i & t.inspos 1 = halt SCMPDS by Th10;
A8: IC Exec(i, t) = Next inspos 0 by A1,A4
                   .= inspos (0+1) by SCMPDS_4:70;
     (Computation t).(0+1) = Following (Computation t).0 by AMI_1:def 19
      .= Following t by AMI_1:def 19
      .= Exec(i,t) by A4,A6,Th10;
  hence CurInstr((Computation t).1)
      = halt SCMPDS by A7,A8,AMI_1:def 13;
end;

registration
 let a,k1;
 cluster a := k1 -> parahalting;
 coherence
 proof
  set i= a:=k1;
      for s holds Exec(i,s).IC SCMPDS = Next IC s by SCMPDS_2:57;
  then Load i is parahalting by Lm2;
  hence thesis by Def2;
 end;
end;

registration
 let a,k1,k2;
 cluster (a,k1) := k2 -> parahalting;
 coherence
 proof
  set i= (a,k1) := k2;
      for s holds Exec(i,s).IC SCMPDS = Next IC s by SCMPDS_2:58;
  then Load i is parahalting by Lm2;
  hence thesis by Def2;
 end;

 cluster AddTo(a,k1,k2) -> parahalting;
 coherence
 proof
  set i= AddTo(a,k1,k2);
      for s holds Exec(i,s).IC SCMPDS = Next IC s by SCMPDS_2:60;
  then Load i is parahalting by Lm2;
  hence thesis by Def2;
 end;
end;

registration
 let a,b,k1,k2;
 cluster AddTo(a,k1,b,k2) -> parahalting;
 coherence
 proof
  set i= AddTo(a,k1,b,k2);
      for s holds Exec(i,s).IC SCMPDS = Next IC s by SCMPDS_2:61;
  then Load i is parahalting by Lm2;
  hence thesis by Def2;
 end;

 cluster SubFrom(a,k1,b,k2) -> parahalting;
 coherence
 proof
  set i= SubFrom(a,k1,b,k2);
      for s holds Exec(i,s).IC SCMPDS = Next IC s by SCMPDS_2:62;
  then Load i is parahalting by Lm2;
  hence thesis by Def2;
 end;

 cluster MultBy(a,k1,b,k2) -> parahalting;
 coherence
 proof
  set i= MultBy(a,k1,b,k2);
      for s holds Exec(i,s).IC SCMPDS = Next IC s by SCMPDS_2:63;
  then Load i is parahalting by Lm2;
  hence thesis by Def2;
 end;

 cluster Divide(a,k1,b,k2) -> parahalting;
 coherence
 proof
  set i= Divide(a,k1,b,k2);
      for s holds Exec(i,s).IC SCMPDS = Next IC s by SCMPDS_2:64;
  then Load i is parahalting by Lm2;
  hence thesis by Def2;
 end;

 cluster (a,k1) := (b,k2) -> parahalting;
 coherence
 proof
  set i= (a,k1) := (b,k2);
      for s holds Exec(i,s).IC SCMPDS = Next IC s by SCMPDS_2:59;
  then Load i is parahalting by Lm2;
  hence thesis by Def2;
 end;
end;

theorem Th26:
  InsCode i =1 implies i is not parahalting
proof
   assume A1:InsCode i=1;
   assume i is parahalting;
   then reconsider Li = Load i as parahalting Program-block by Def2;
    set pi=stop Li,
        Ii=Initialized pi;
    consider s such that
A2: for a holds s.a = 2 by SCMPDS_2:73;
    set s1=s +* Ii;
A3: Ii c= s1 by FUNCT_4:26;
        inspos 0 in dom Ii by Th13;
then A4: s1.inspos 0=Ii.inspos 0 by FUNCT_4:14
    .=i by Th13;
A5: (Computation s1).(0+1) = Following (Computation s1).0 by AMI_1:def 19
      .= Following s1 by AMI_1:def 19
      .= Exec(i, s1) by A3,A4,Th18;
      consider a such that
A6:   i = return a by A1,SCMPDS_2:36;
      s1.DataLoc(s1.a,RetIC)=s.DataLoc(s1.a,RetIC) by Th19
      .=2 by A2;
then A7:   Exec(i, s1).IC SCMPDS =(abs(2))+2 by A6,SCMPDS_2:70
      .=(2)+2 by ABSVALUE:def 1
      .=4
      .=inspos 4;
      set C1=(Computation s1).1;
      A8: IC C1 in dom pi by A3,SCMPDS_4:def 9;
          card pi = 2 by Th8;
      hence contradiction by A5,A7,A8,SCMPDS_4:1;
end;

definition let IT be FinPartState of SCMPDS;
 attr IT is No-StopCode means
:Def3:      for x being Instruction-Location of SCMPDS
      st x in dom IT holds IT.x <> halt SCMPDS;
end;

registration
 cluster parahalting shiftable No-StopCode Program-block;
 existence
 proof
   set ii=DataLoc(0,0):=0;
   take II=Load ii;
       now let x be Instruction-Location of SCMPDS;
      assume x in dom II;
      then x in {inspos 0} by CQC_LANG:5;
      then x=inspos 0 by TARSKI:def 1;
  then A1: II.x=ii by CQC_LANG:6;
      InsCode ii=2 by SCMPDS_2:23;
      hence II.x <> halt SCMPDS by A1,SCMPDS_2:21,93;
   end;
   hence thesis by Def3;
  end;
end;

registration
 let I,J be No-StopCode Program-block;
 cluster I ';' J -> No-StopCode;
 coherence
 proof
     set IJ=I ';' J;
       now let x be Instruction-Location of SCMPDS such that
A1:    x in dom IJ;
       set D = {inspos(n+card I): inspos n in dom J };
           dom Shift(J,card I) = D by SCMPDS_3:def 7;
then A2:    dom IJ = dom I \/ D by FUNCT_4:def 1;
      per cases by A1,A2,XBOOLE_0:def 2;
       suppose A3:x in dom I;
           then I.x=IJ.x by SCMPDS_4:37;
         hence IJ.x<>halt SCMPDS by A3,Def3;
       end;
       suppose x in D;
        then consider n such that
A4:      x = inspos(n+card I) and
A5:      inspos n in dom J;
             J.inspos n=IJ.(inspos n+card I) by A5,SCMPDS_4:38
         .=IJ.x by A4,SCMPDS_3:def 3;
         hence IJ.x<>halt SCMPDS by A5,Def3;
   end;
   end;
   hence thesis by Def3;
 end;
end;

registration
 let i be No-StopCode Instruction of SCMPDS;
 cluster Load i -> No-StopCode;
 coherence
 proof
   set p=Load i;
       now let x be Instruction-Location of SCMPDS; assume
        x in dom p;
       then x = inspos 0 by Th2;
       then p.x=i by CQC_LANG:6;
       hence p.x <>halt SCMPDS by Def1;
   end;
   hence thesis by Def3;
  end;
end;

registration
  let i be No-StopCode Instruction of SCMPDS,
      J be No-StopCode Program-block;
 cluster i ';' J -> No-StopCode;
 coherence;
end;

registration
 let I be No-StopCode Program-block,
     j be No-StopCode Instruction of SCMPDS;
 cluster I ';' j -> No-StopCode;
 coherence;
end;

registration
 let i,j be No-StopCode Instruction of SCMPDS;
 cluster i ';' j -> No-StopCode;
 coherence;
end;

theorem Th27:   ::Th37
 for I being parahalting No-StopCode Program-block
 st Initialized (stop I) c= s
 holds
     IC (Computation s).LifeSpan (s +* Initialized stop(I)) = inspos card I
proof
 let I be parahalting No-StopCode Program-block;
  set IsI=Initialized stop(I);
  assume
A1: IsI c= s;
then A2: s is halting by SCMPDS_4:63;
A3: I c= stop I by SCMPDS_4:40;
        stop I c= IsI by SCMPDS_4:9;
    then I c= IsI by A3,XBOOLE_1:1;
then A4: I c= s by A1,XBOOLE_1:1;
    set Css=(Computation s).LifeSpan s;
A5: IC Css in dom stop(I) by A1,SCMPDS_4:def 9;
    consider n such that
A6: inspos n= IC Css by SCMPDS_3:32;
        now
       assume A7: IC Css in dom I;
       then I.IC Css=s.IC Css by A4,GRFUNC_1:8
       .=CurInstr Css by AMI_1:54
       .=halt SCMPDS by A2,AMI_1:def 46;
       hence contradiction by A7,Def3;
    end;
then A8: n >= card I by A6,SCMPDS_4:1;
        card stop I =card I + 1 by SCMPDS_4:45,74;
   then n < card I + 1 by A5,A6,SCMPDS_4:1;
   then n <= card I by NAT_1:13;
then n=card I by A8,XXREAL_0:1;
   hence IC (Computation s).LifeSpan (s +* IsI)
    =inspos card I by A1,A6,FUNCT_4:79;
end;

theorem Th28:
 for I being parahalting Program-block,k be Element of NAT
 st k < LifeSpan (s +* Initialized stop(I))
 holds IC (Computation (s +* Initialized stop(I))).k in dom I
proof
 let I be parahalting Program-block,k be Element of NAT;
  set IsI=Initialized stop(I),
      ss= s +* IsI,
      m=LifeSpan ss,
      Sp=SCMPDS-Stop;
  assume
A1: k < m;
    set Sk= (Computation ss).k,
        Ik=IC Sk;
A2: IsI c= ss by FUNCT_4:26;
then A3: Ik in dom stop(I) by SCMPDS_4:def 9;
A4: ss is halting by A2,SCMPDS_4:63;
        stop I c= IsI by SCMPDS_4:9;
then A5: stop I c= ss by A2,XBOOLE_1:1;
    consider n such that
A6: inspos n= Ik by SCMPDS_3:32;
        card stop I=card I + 1 by SCMPDS_4:45,74;
    then n < card I + 1 by A3,A6,SCMPDS_4:1;
then A7: n <= card I by INT_1:20;
        now assume
        A8: n = card I;
            CurInstr Sk =ss.Ik by AMI_1:54
        .=(stop I).inspos(0+n) by A3,A5,A6,GRFUNC_1:8
        .=(stop I).(inspos 0+n) by SCMPDS_3:def 3
        .=halt SCMPDS by A8,SCMPDS_4:38,73;
        hence contradiction by A1,A4,AMI_1:def 46;
    end;
    then n < card I by A7,REAL_1:def 5;
    hence thesis by A6,SCMPDS_4:1;
end;

theorem Th29:
 for I being parahalting Program-block,k be Element of NAT
 st Initialized I c= s &
    k <= LifeSpan (s +* Initialized stop(I))
 holds
    (Computation s).k,(Computation (s +* Initialized stop(I))).k
    equal_outside the Instruction-Locations of SCMPDS
proof
 let I be parahalting Program-block,k be Element of NAT;
  set II=Initialized I,
      IsI=Initialized stop(I),
      IL=the Instruction-Locations of SCMPDS,
      m=LifeSpan (s +* IsI);
  assume that
A1: II c= s and
A2: k <= m;
    set Sp=SCMPDS-Stop,
        Cs1=Computation s,
        Cs2=Computation (s +* IsI);
    defpred P[Element of NAT] means
       $1 <= m implies
       Cs1.$1,Cs2.$1 equal_outside IL;
A3: s = s +* II by A1,FUNCT_4:79
    .=s +* I by A1,SCMPDS_4:34;
A4: s +* IsI = s +* stop(I) by A1,SCMPDS_4:34;
A5: P[0]
   proof
    assume 0 <= m;
    A6: Cs1.0=s by AMI_1:def 19;
        Cs2.0=s +* IsI by AMI_1:def 19;
        hence Cs1.0,Cs2.0 equal_outside IL by A4,A6,AMI_1:120;
    end;
A7: now let k be Element of NAT;
      assume A8: P[k];
          now assume A9:k+1 <= m;
       A10: k < k+1 by XREAL_1:31;
       then A11: IC Cs1.k = IC Cs2.k by A8,A9,AMI_1:121,XXREAL_0:2;
            k < m by A9,A10,XXREAL_0:2;
       then A12: IC Cs2.k in dom I by Th28;
       then A13: IC Cs2.k in dom (stop I) by FUNCT_4:13;
       A14: CurInstr Cs1.k
        = s.IC Cs2.k by A11,AMI_1:54
        .= I.IC Cs2.k by A3,A12,FUNCT_4:14
        .= (stop I).IC Cs2.k by A12,SCMPDS_4:37
        .= (s +* IsI).IC Cs2.k by A4,A13,FUNCT_4:14
        .= CurInstr Cs2.k by AMI_1:54;
      A15: (Cs1).(k + 1) = Following Cs1.k by AMI_1:def 19
         .= Exec(CurInstr Cs1.k,Cs1.k);
              (Cs2).(k + 1) = Following Cs2.k by AMI_1:def 19
         .= Exec(CurInstr Cs2.k,Cs2.k);
        hence Cs1.(k+1),Cs2.(k+1) equal_outside IL by A8,A9,A10,A14,A15,
SCMPDS_4:15,XXREAL_0:2;
      end;
      hence P[k+1];
   end;
       for k be Element of NAT holds P[k] from NAT_1:sch 1(A5,A7);
   hence thesis by A2;
end;

theorem Th30: :: Th37,Lemma01
 for I being parahalting No-StopCode Program-block
 st Initialized I c= s
 holds
     IC (Computation s).LifeSpan (s +* Initialized stop(I)) = inspos card I
proof
 let I be parahalting No-StopCode Program-block;
  set IsI=Initialized stop(I),
      ss = s +* IsI,
      m=LifeSpan ss;
  assume
A1: Initialized I c= s;
A2: IsI c= ss by FUNCT_4:26;
        (Computation s).m,(Computation ss).m equal_outside
    the Instruction-Locations of SCMPDS by A1,Th29;
    hence IC (Computation s).m = IC (Computation ss).m by AMI_1:121
          .=IC (Computation ss).LifeSpan (ss +* IsI) by A2,FUNCT_4:79
          .=inspos card I by A2,Th27;
end;

theorem Th31:    ::Th37 end
 for I being parahalting Program-block st Initialized I c= s
 holds
 CurInstr (Computation s).LifeSpan (s +* Initialized stop(I)) = halt SCMPDS
 or IC (Computation s).LifeSpan (s +* Initialized stop(I)) = inspos card I
proof
 let I be parahalting Program-block;
  set IsI=Initialized stop(I),
      ss = s +* IsI,
      m=LifeSpan ss;
  assume
A1: Initialized I c= s;
A2: IsI c= ss by FUNCT_4:26;
A3: I c= s by A1,SCMPDS_4:57;
    set s1=(Computation s).m,
        s2=(Computation ss).LifeSpan (ss +* IsI),
        Ik = IC s2;
        s1,(Computation ss).m equal_outside
    the Instruction-Locations of SCMPDS by A1,Th29;
then A4: IC s1 = IC (Computation ss).m by AMI_1:121
    .=Ik by A2,FUNCT_4:79;
A5: Ik in dom stop(I) by A2,SCMPDS_4:def 9;
A6: ss is halting by A2,SCMPDS_4:63;
        stop I c= IsI by SCMPDS_4:9;
then A7: stop I c= ss by A2,XBOOLE_1:1;
    consider n such that
A8: inspos n= Ik by SCMPDS_3:32;
        card stop I = card I + 1 by SCMPDS_4:45,74;
    then n < card I + 1 by A5,A8,SCMPDS_4:1;
 then A9: n <= card I by INT_1:20;
        now per cases by A9,REAL_1:def 5;
    case n < card I;
        then A10: inspos n in dom I by SCMPDS_4:1;
    thus halt SCMPDS = CurInstr (Computation ss).LifeSpan ss
               by A6,AMI_1:def 46
        .= CurInstr s2 by A2,FUNCT_4:79
        .=ss.Ik by AMI_1:54
        .=(stop I).Ik by A5,A7,GRFUNC_1:8
        .=I.Ik by A8,A10,SCMPDS_4:37
        .=s.IC s1 by A3,A4,A8,A10,GRFUNC_1:8
        .=CurInstr s1 by AMI_1:54;
    end;
    case n = card I;
      hence IC s1= inspos card I by A4,A8;
    end;
    end;
    hence thesis;
end;

theorem Th32: :: Th39
 for I being parahalting No-StopCode Program-block,k being Element of NAT
 st Initialized I c= s & k < LifeSpan (s +* Initialized stop(I))
 holds CurInstr (Computation s).k <> halt SCMPDS
proof
  let I be parahalting No-StopCode Program-block,k be Element of NAT;
  set sI=s +* Initialized stop(I),
      s1=(Computation s).k,
      s2=(Computation sI).k;
  assume
A1: Initialized I c= s & k < LifeSpan sI;
then A2: s1,s2 equal_outside the Instruction-Locations of SCMPDS by Th29;
        I c= s by A1,SCMPDS_4:57;
then A3: I c= s1 by AMI_1:81;
A4: IC s2 in dom I by A1,Th28;
        CurInstr s1=s1.IC s2 by A2,AMI_1:121
    .=I.IC s2 by A3,A4,GRFUNC_1:8;
    hence thesis by A4,Def3;
end;

theorem Th33: ::Th40
 for I being parahalting Program-block,J being Program-block,
  k being Element of NAT st k <= LifeSpan (s +* Initialized stop(I))
 holds (Computation (s +* Initialized stop I )).k,
       (Computation (s +* ((I ';' J) +* Start-At inspos 0))).k
        equal_outside the Instruction-Locations of SCMPDS
proof
    let I be parahalting Program-block,J be Program-block,k be Element of NAT;
    set SA0=Start-At inspos 0,
        spI= stop I,
        IsI=Initialized spI;
    set s1 = s +* IsI;
    set s2 = s +* ((I ';' J) +* SA0);
    set n=LifeSpan s1;
    assume A1: k <= n;
A2: IsI c= s1 by FUNCT_4:26;
A3: s1 =s +* spI +* SA0 by FUNCT_4:15
    .=s+*SA0+* spI by SCMPDS_4:62;
A4: s2 = s +* (I ';' J) +* SA0 by FUNCT_4:15
       .= s+*SA0+*(I ';' J) by SCMPDS_4:62;
     set IL=the Instruction-Locations of SCMPDS;
     set Cs1 = Computation s1, Cs2 = Computation s2;
         s +* SA0, s +* SA0 +* spI equal_outside IL by AMI_1:120;
then A5:  s +* SA0 +* spI, s +* SA0 equal_outside IL by FUNCT_7:28;
   defpred X[Element of NAT] means
    $1 <= n implies Cs1.$1, Cs2.$1 equal_outside IL;
     A6: s +* SA0, s +* SA0 +* (I ';' J) equal_outside IL by AMI_1:120;
         Cs1.0 = s1 & Cs2.0 = s2 by AMI_1:def 19;
then A7: X[0] by A3,A4,A5,A6,FUNCT_7:29
;
A8: for n being Element of NAT st X[n] holds X[n+1]
   proof let m be Element of NAT;
    assume
A9:  m <= n implies Cs1.m, Cs2.m equal_outside IL;
    assume A10: m+1 <= n;
then A11:    m < n by NAT_1:13;
A12:    Cs1.(m+1) = Following Cs1.m by AMI_1:def 19
             .= Exec(CurInstr Cs1.m,Cs1.m);
A13:    Cs2.(m+1) = Following Cs2.m by AMI_1:def 19
             .= Exec(CurInstr Cs2.m,Cs2.m);
A14:   IC Cs1.m = IC Cs2.m by A9,A10,AMI_1:121,NAT_1:13;
A15:   IC Cs1.m in dom spI by A2,SCMPDS_4:def 9;
A16:    IC Cs1.m in dom I by A11,Th28;
then A17:    IC Cs1.m in dom (I ';' J) by FUNCT_4:13;
        CurInstr Cs1.m
        = s1.IC Cs1.m by AMI_1:54
        .= spI.IC Cs1.m by A3,A15,FUNCT_4:14
        .= I.IC Cs1.m by A16,SCMPDS_4:37
        .= (I ';' J).IC Cs1.m by A16,SCMPDS_4:37
        .= s2.IC Cs1.m by A4,A17,FUNCT_4:14
        .=CurInstr Cs2.m by A14,AMI_1:54;
    hence Cs1.(m+1),Cs2.(m+1) equal_outside IL by A9,A10,A12,A13,NAT_1:13
,SCMPDS_4:15;
   end;
       for k being Element of NAT holds X[k] from NAT_1:sch 1(A7, A8);
  hence thesis by A1;
end;

theorem Th34:    ::Th41B
 for I being parahalting Program-block,J being Program-block,
  k being Element of NAT st k <= LifeSpan (s +* Initialized stop(I))
 holds (Computation (s +* Initialized stop I )).k,
       (Computation (s +* Initialized stop (I ';' J))).k
        equal_outside the Instruction-Locations of SCMPDS
proof
    let I be parahalting Program-block,J be Program-block,k be Element of NAT;
    assume A1: k <= LifeSpan (s +* Initialized stop I);
        Initialized stop (I ';' J) =
    (I ';' (J ';' SCMPDS-Stop)) +* Start-At inspos 0 by SCMPDS_4:46;
    hence thesis by A1,Th33;
end;

registration
 let I be parahalting Program-block,
     J be parahalting shiftable Program-block;
 cluster I ';' J -> parahalting;
 coherence
 proof
   set sIJ = stop(I ';' J),
       IsIJ = Initialized sIJ;
   let s be State of SCMPDS; assume
A1: IsIJ c= s;
then A2: s = s +* IsIJ by FUNCT_4:79
    .= s +* ((I ';' (J ';' SCMPDS-Stop)) +* Start-At inspos 0) by SCMPDS_4:46;
A3: sIJ c= s by A1,SCMPDS_4:57;
    set spJ = stop J,
       IsJ = Initialized spJ,
       s1 = s +* Initialized stop(I),
       m1 = LifeSpan s1,
       s3 = (Computation s1).m1 +* IsJ,
       m3 = LifeSpan s3,
       A = the Instruction-Locations of SCMPDS,
       D = SCM-Data-Loc;
A4:  s3 | D = ((Computation s1).m1 | D) +* IsJ | D by FUNCT_4:75;
A5:  now let x be set;
         assume x in dom (IsJ | D);
         then A6: x in dom IsJ /\ D by FUNCT_1:68;
    then A7: x in dom IsJ & x in D by XBOOLE_0:def 3;
         per cases by A7,SCMPDS_4:28;
         suppose A8: x in dom spJ;
                dom spJ c= A by AMI_1:def 40;
          then reconsider l=x as Instruction-Location of SCMPDS
                       by A8,AMI_1:def 4;
           (IsJ | D).l = ((Computation s1).m1 | D).l by A7,SCMPDS_4:22;
          hence (IsJ | D).x = ((Computation s1).m1 | D).x;
         end;
         suppose x = IC SCMPDS;
          hence (IsJ | D).x = ((Computation s1).m1 | D).x by A6,SCMPDS_3:6
,XBOOLE_0:def 3;
      end;
      end;
A9:   IsJ c= s3 by FUNCT_4:26;
      then dom IsJ c= dom s3 by GRFUNC_1:8;
then A10:   dom IsJ c= the carrier of SCMPDS by AMI_1:79;
          dom (IsJ | D) = dom IsJ /\ D by RELAT_1:90;
      then dom (IsJ | D) c= (the carrier of SCMPDS) /\ D by A10,XBOOLE_1:26;
      then dom (IsJ | D) c= dom ((Computation s1).m1) /\ D by AMI_1:79;
      then dom (IsJ | D) c= dom ((Computation s1).m1 | D) by RELAT_1:90;
      then IsJ | D c= (Computation s1).m1 | D by A5,GRFUNC_1:8;
then A11:   (Computation s1).m1 | D = s3 | D by A4,LATTICE2:8;
      set s4 = (Computation s).m1;
       (Computation s1).m1, s4 equal_outside A by A2,Th33;
then A12:   s4 | D = s3 | D by A11,SCMPDS_4:24;
A13:   s3 is halting by A9,AMI_1:def 26;
          Initialized I c= IsIJ by Th15;
      then A14: Initialized I c= s by A1,XBOOLE_1:1;
     per cases by A14,Th31;
     suppose A15: CurInstr s4 = halt SCMPDS;
       take m1;
       thus CurInstr s4 = halt SCMPDS by A15;
     end;
     suppose A16:IC s4 = inspos card I;
        reconsider m = m1 + m3 as Element of NAT;
            sIJ = I ';' (J ';' SCMPDS-Stop) by SCMPDS_4:46
        .= I +* Shift(spJ, card I);
        then Shift(spJ, card I) c= sIJ by FUNCT_4:26;
        then Shift(spJ, card I) c= s by A3,XBOOLE_1:1;
        then A17: Shift(spJ, card I) c= s4 by AMI_1:81;
        take m;
           CurInstr (Computation s3).m3 = CurInstr (Computation s4).m3 by A9
,A12,A16,A17,SCMPDS_4:84;
       then CurInstr (Computation s3).m3 = CurInstr (Computation s).(m1 + m3)
        by AMI_1:51;
       hence CurInstr (Computation s).m = halt SCMPDS by A13,AMI_1:def 46;
  end;
  end;
end;

registration
 let i be parahalting Instruction of SCMPDS,
     J be parahalting shiftable Program-block;
 cluster i ';' J -> parahalting;
 coherence;
end;

registration
 let I be parahalting Program-block,
     j be parahalting shiftable Instruction of SCMPDS;
 cluster I ';' j -> parahalting;
 coherence;
end;

registration
 let i be parahalting Instruction of SCMPDS,
     j be parahalting shiftable Instruction of SCMPDS;
 cluster i ';' j -> parahalting;
 coherence;
end;

theorem Th35:    :: SF4_28
 for s,s1 being State of SCMPDS, J being parahalting shiftable Program-block
 st s=(Computation (s1+*Initialized stop J)).m
  holds Exec(CurInstr s ,s +* Start-At (IC s + n))
      = Following(s) +* Start-At (IC Following(s) + n)
proof
   let s,s1 be State of SCMPDS, J be parahalting shiftable Program-block;
   set pJ=stop J,
       IsJ=Initialized pJ,
       s2=s1+*IsJ;
   assume A1:s=(Computation s2).m;
   set i = CurInstr s,
       ss=s +* Start-At (IC s + n);
     consider k being Element of NAT such that
A2:  IC s = inspos k by SCMPDS_3:32;
A3:  IC s + n = inspos (k + n) by A2,SCMPDS_3:def 3;
     reconsider Nl=Next IC s as Instruction-Location of SCMPDS;
A4:  Next IC ss = Next inspos(k + n) by A3,AMI_1:111
     .= inspos(k + n + 1) by SCMPDS_4:70
     .= inspos(k + 1 + n)
     .= inspos(k + 1) + n by SCMPDS_3:def 3
     .= Nl + n by A2,SCMPDS_4:70
     .= IC (Exec(i, s) +*Start-At (Nl + n)) by AMI_1:111;
A5: IC ss = IC s + n by AMI_1:111;
     set IEn=IC Exec(i,s)+n;
A6:  now let d be Instruction-Location of SCMPDS;
      thus Exec(i, ss).d = ss.d by AMI_1:def 13
         .= s.d by AMI_1:112
         .= Exec(i, s).d by AMI_1:def 13
         .= (Exec(i, s) +* Start-At IEn).d by AMI_1:112;
     end;
     consider n1 be Element of NAT such that
A7:  IC s=inspos n1 by SCMPDS_3:32;
A8:  IsJ c= s2 by FUNCT_4:26;
     then A9: IC s in dom pJ by A1,SCMPDS_4:def 9;
         pJ c= s2 by A8,SCMPDS_4:57;
then  pJ c= s by A1,AMI_1:81;
        then i=pJ.(inspos n1) by A7,A9,GRFUNC_1:8;
then A10: InsCode i <> 1 & InsCode i <> 3 & i valid_at n1 by A7,A9,
SCMPDS_4:def 12;
A11: InsCode i <= 13 by SCMPDS_2:15;
    per cases by A10,A11,NAT_1:38;
    suppose InsCode i = 0;
     then consider k1 such that
A12:  i = goto k1 & n1+k1 >= 0 by A10,SCMPDS_4:def 11;
A13:  IC Exec(i,s) =ICplusConst(s,k1) by A12,SCMPDS_2:66;
A14:   IC Exec(i, ss)
      =ICplusConst(ss,k1) by A12,SCMPDS_2:66
     .=IEn by A5,A7,A12,A13,SCMPDS_4:82
     .= IC (Exec(i, s) +* Start-At IEn) by AMI_1:111;
      now let b;
     thus Exec(i, ss).b= ss.b by A12,SCMPDS_2:66
         .= s.b by SCMPDS_3:14
         .= Exec(i, s).b by A12,SCMPDS_2:66
         .= (Exec(i, s) +* Start-At IEn).b by SCMPDS_3:14;
     end;
     hence thesis by A6,A14,SCMPDS_2:54;

    end;
    suppose InsCode i = 2;
    then consider a,k1 such that
A15:   i = a := k1 by SCMPDS_2:37;
  IC Exec(i, s) = Nl by A15,SCMPDS_2:57;
then A16: IC Exec(i, ss) =
 IC (Exec(i, s) +* Start-At IEn) by A4,A15,SCMPDS_2:57;
        now let b;
     per cases;
     suppose
A17:     a = b;
        hence Exec(i, ss).b
          = k1 by A15,SCMPDS_2:57
         .= Exec(i,s).b by A15,A17,SCMPDS_2:57
         .= (Exec(i, s) +* Start-At IEn).b by SCMPDS_3:14;
     end;
     suppose
A18:       a <> b;
          hence Exec(i, ss).b
          = ss.b by A15,SCMPDS_2:57
         .= s.b by SCMPDS_3:14
         .= Exec(i, s).b by A15,A18,SCMPDS_2:57
         .= (Exec(i, s) +* Start-At IEn).b by SCMPDS_3:14;
     end;
     end;
     hence thesis by A6,A16,SCMPDS_2:54;

    end;
    suppose InsCode i = 4;
    then consider a,k1,k2 such that
A19:   i = (a,k1)<>0_goto k2 & n1+k2 >= 0 by A10,SCMPDS_4:def 11;
A20:  now
        per cases;
        suppose A21: s.DataLoc(s.a,k1) <> 0;
             then ss.DataLoc(s.a,k1) <> 0 by SCMPDS_3:14;
         then A22: ss.DataLoc(ss.a,k1) <> 0 by SCMPDS_3:14;
         A23: IC Exec(i,s) =ICplusConst(s,k2) by A19,A21,SCMPDS_2:67;
         thus IC Exec(i, ss) =ICplusConst(ss,k2) by A19,A22,SCMPDS_2:67
             .=IEn by A5,A7,A19,A23,SCMPDS_4:82
             .= IC (Exec(i, s) +* Start-At IEn) by AMI_1:111;
        end;
        suppose A24: s.DataLoc(s.a,k1) = 0;
             then ss.DataLoc(s.a,k1) = 0 by SCMPDS_3:14;
         then A25: ss.DataLoc(ss.a,k1) = 0 by SCMPDS_3:14;
          IC Exec(i, s) = Nl by A19,A24,SCMPDS_2:67;
         hence IC Exec(i,ss) =
 IC (Exec(i, s) +* Start-At IEn) by A4,A19,A25,SCMPDS_2:67;
     end;
     end;
      now let b;
     thus Exec(i, ss).b= ss.b by A19,SCMPDS_2:67
         .= s.b by SCMPDS_3:14
         .= Exec(i, s).b by A19,SCMPDS_2:67
         .= (Exec(i, s) +* Start-At IEn).b by SCMPDS_3:14;
     end;
     hence thesis by A6,A20,SCMPDS_2:54;

    end;
    suppose InsCode i = 5;
    then consider a,k1,k2 such that
A26:   i = (a,k1)<=0_goto k2 & n1+k2 >= 0 by A10,SCMPDS_4:def 11;
A27:  now
        per cases;
        suppose A28: s.DataLoc(s.a,k1) <= 0;
             then ss.DataLoc(s.a,k1) <= 0 by SCMPDS_3:14;
         then A29: ss.DataLoc(ss.a,k1) <= 0 by SCMPDS_3:14;
         A30: IC Exec(i,s) =ICplusConst(s,k2) by A26,A28,SCMPDS_2:68;
         thus IC Exec(i, ss) =ICplusConst(ss,k2) by A26,A29,SCMPDS_2:68
             .=IEn by A5,A7,A26,A30,SCMPDS_4:82
             .= IC (Exec(i, s) +* Start-At IEn) by AMI_1:111;
        end;
        suppose A31: s.DataLoc(s.a,k1) > 0;
             then ss.DataLoc(s.a,k1) > 0 by SCMPDS_3:14;
         then A32: ss.DataLoc(ss.a,k1) > 0 by SCMPDS_3:14;
          IC Exec(i, s) = Nl by A26,A31,SCMPDS_2:68;
         hence IC Exec(i,ss) =
 IC (Exec(i, s) +* Start-At IEn) by A4,A26,A32,SCMPDS_2:68;
     end;
     end;
      now let b;
     thus Exec(i, ss).b= ss.b by A26,SCMPDS_2:68
         .= s.b by SCMPDS_3:14
         .= Exec(i, s).b by A26,SCMPDS_2:68
         .= (Exec(i, s) +* Start-At IEn).b by SCMPDS_3:14;
     end;
     hence thesis by A6,A27,SCMPDS_2:54;

    end;
    suppose InsCode i = 6;
    then consider a,k1,k2 such that
A33:   i = (a,k1)>=0_goto k2 & n1+k2 >= 0 by A10,SCMPDS_4:def 11;
A34:  now
        per cases;
        suppose A35: s.DataLoc(s.a,k1) >= 0;
             then ss.DataLoc(s.a,k1) >= 0 by SCMPDS_3:14;
         then A36: ss.DataLoc(ss.a,k1) >= 0 by SCMPDS_3:14;
         A37: IC Exec(i,s) =ICplusConst(s,k2) by A33,A35,SCMPDS_2:69;
         thus IC Exec(i, ss) =ICplusConst(ss,k2) by A33,A36,SCMPDS_2:69
             .=IEn by A5,A7,A33,A37,SCMPDS_4:82
             .= IC (Exec(i, s) +* Start-At IEn) by AMI_1:111;
        end;
        suppose A38: s.DataLoc(s.a,k1) < 0;
             then ss.DataLoc(s.a,k1) < 0 by SCMPDS_3:14;
         then A39: ss.DataLoc(ss.a,k1) < 0 by SCMPDS_3:14;
          IC Exec(i, s) = Nl by A33,A38,SCMPDS_2:69;
         hence IC Exec(i,ss) =
 IC (Exec(i, s) +* Start-At IEn) by A4,A33,A39,SCMPDS_2:69;
     end;
     end;
      now let b;
     thus Exec(i, ss).b= ss.b by A33,SCMPDS_2:69
         .= s.b by SCMPDS_3:14
         .= Exec(i, s).b by A33,SCMPDS_2:69
         .= (Exec(i, s) +* Start-At IEn).b by SCMPDS_3:14;
     end;
     hence thesis by A6,A34,SCMPDS_2:54;

    end;
    suppose InsCode i = 7;
    then consider a,k1,k2 such that
A40:  i = (a,k1) := k2 by SCMPDS_2:42;
  IC Exec(i, s) = Nl by A40,SCMPDS_2:58;
then A41: IC Exec(i, ss) =
 IC (Exec(i, s) +* Start-At IEn) by A4,A40,SCMPDS_2:58;
        now let b;
     per cases;
     suppose
A42:       DataLoc(ss.a,k1) = b;
then A43:       DataLoc(s.a,k1) = b by SCMPDS_3:14;
        thus Exec(i, ss).b
          = k2 by A40,A42,SCMPDS_2:58
         .= Exec(i,s).b by A40,A43,SCMPDS_2:58
         .= (Exec(i, s) +* Start-At IEn).b by SCMPDS_3:14;
     end;
     suppose
A44:       DataLoc(ss.a,k1) <> b;
then A45:       DataLoc(s.a,k1) <> b by SCMPDS_3:14;
          thus Exec(i, ss).b
          = ss.b by A40,A44,SCMPDS_2:58
         .= s.b by SCMPDS_3:14
         .= Exec(i, s).b by A40,A45,SCMPDS_2:58
         .= (Exec(i, s) +* Start-At IEn).b by SCMPDS_3:14;
     end;
     end;
     hence thesis by A6,A41,SCMPDS_2:54;

     thus thesis;
    end;
    suppose InsCode i = 8;
      then consider a,k1,k2 such that
A46:   i = AddTo(a,k1,k2) by SCMPDS_2:43;
    IC Exec(i, s) = Nl by A46,SCMPDS_2:60;
then A47:   IC Exec(i, ss) =
 IC (Exec(i, s) +* Start-At IEn) by A4,A46,SCMPDS_2:60;
        now let b;
     per cases;
     suppose
A48:       DataLoc(ss.a,k1) = b;
then A49:       DataLoc(s.a,k1) = b by SCMPDS_3:14;
        thus Exec(i, ss).b
          = ss.b + k2 by A46,A48,SCMPDS_2:60
         .= s.b + k2 by SCMPDS_3:14
         .= Exec(i, s).b by A46,A49,SCMPDS_2:60
         .= (Exec(i, s) +* Start-At IEn).b by SCMPDS_3:14;
     end;
     suppose
A50:       DataLoc(ss.a,k1) <> b;
then A51:       DataLoc(s.a,k1) <> b by SCMPDS_3:14;
          thus Exec(i, ss).b
          = ss.b by A46,A50,SCMPDS_2:60
         .= s.b by SCMPDS_3:14
         .= Exec(i, s).b by A46,A51,SCMPDS_2:60
         .= (Exec(i, s) +* Start-At IEn).b by SCMPDS_3:14;
     end;
     end;
     hence thesis by A6,A47,SCMPDS_2:54;

    end;
    suppose InsCode i = 9;
    then consider a,b,k1,k2 such that
A52:  i = AddTo(a,k1,b,k2) by SCMPDS_2:44;
  IC Exec(i, s) = Nl by A52,SCMPDS_2:61;
then A53: IC Exec(i, ss) =
 IC (Exec(i, s) +* Start-At IEn) by A4,A52,SCMPDS_2:61;
        now let c;
     per cases;
     suppose
A54:       DataLoc(ss.a,k1) = c;
then A55:       DataLoc(s.a,k1) = c by SCMPDS_3:14;
A56:       ss.DataLoc(ss.a,k1) =s.DataLoc(ss.a,k1) by SCMPDS_3:14
          .=s.DataLoc(s.a,k1) by SCMPDS_3:14;
          ss.DataLoc(ss.b,k2) =s.DataLoc(ss.b,k2) by SCMPDS_3:14
          .=s.DataLoc(s.b,k2) by SCMPDS_3:14;
       hence Exec(i, ss).c
          = s.DataLoc(s.a,k1) + s.DataLoc(s.b,k2) by A52,A54,A56,SCMPDS_2:61
         .= Exec(i, s).c by A52,A55,SCMPDS_2:61
         .= (Exec(i, s) +* Start-At IEn).c by SCMPDS_3:14;
       end;
       suppose
A57:       DataLoc(ss.a,k1) <> c;
then A58:       DataLoc(s.a,k1) <> c by SCMPDS_3:14;
          thus Exec(i, ss).c
          = ss.c by A52,A57,SCMPDS_2:61
         .= s.c by SCMPDS_3:14
         .= Exec(i, s).c by A52,A58,SCMPDS_2:61
         .= (Exec(i, s) +* Start-At IEn).c by SCMPDS_3:14;
     end;
     end;
     hence thesis by A6,A53,SCMPDS_2:54;

    end;
    suppose InsCode i = 10;
    then consider a,b,k1,k2 such that
A59:  i = SubFrom(a,k1,b,k2) by SCMPDS_2:45;
  IC Exec(i, s) = Nl by A59,SCMPDS_2:62;
then A60: IC Exec(i, ss) =
 IC (Exec(i, s) +* Start-At IEn) by A4,A59,SCMPDS_2:62;
        now let c;
     per cases;
     suppose
A61:       DataLoc(ss.a,k1) = c;
then A62:       DataLoc(s.a,k1) = c by SCMPDS_3:14;
A63:       ss.DataLoc(ss.a,k1) =s.DataLoc(ss.a,k1) by SCMPDS_3:14
          .=s.DataLoc(s.a,k1) by SCMPDS_3:14;
          ss.DataLoc(ss.b,k2) =s.DataLoc(ss.b,k2) by SCMPDS_3:14
          .=s.DataLoc(s.b,k2) by SCMPDS_3:14;
       hence Exec(i, ss).c
          = s.DataLoc(s.a,k1) - s.DataLoc(s.b,k2) by A59,A61,A63,SCMPDS_2:62
         .= Exec(i, s).c by A59,A62,SCMPDS_2:62
         .= (Exec(i, s) +* Start-At IEn).c by SCMPDS_3:14;
       end;
       suppose
A64:       DataLoc(ss.a,k1) <> c;
then A65:       DataLoc(s.a,k1) <> c by SCMPDS_3:14;
          thus Exec(i, ss).c
          = ss.c by A59,A64,SCMPDS_2:62
         .= s.c by SCMPDS_3:14
         .= Exec(i, s).c by A59,A65,SCMPDS_2:62
         .= (Exec(i, s) +* Start-At IEn).c by SCMPDS_3:14;
     end;
     end;
     hence thesis by A6,A60,SCMPDS_2:54;

    end;
    suppose InsCode i = 11;
    then consider a,b,k1,k2 such that
A66:   i = MultBy(a,k1,b,k2) by SCMPDS_2:46;
  IC Exec(i, s) = Nl by A66,SCMPDS_2:63;
then A67: IC Exec(i, ss) =
 IC (Exec(i, s) +* Start-At IEn) by A4,A66,SCMPDS_2:63;
        now let c;
     per cases;
     suppose
A68:       DataLoc(ss.a,k1) = c;
then A69:       DataLoc(s.a,k1) = c by SCMPDS_3:14;
A70:       ss.DataLoc(ss.a,k1) =s.DataLoc(ss.a,k1) by SCMPDS_3:14
          .=s.DataLoc(s.a,k1) by SCMPDS_3:14;
          ss.DataLoc(ss.b,k2) =s.DataLoc(ss.b,k2) by SCMPDS_3:14
          .=s.DataLoc(s.b,k2) by SCMPDS_3:14;
       hence Exec(i, ss).c
          = s.DataLoc(s.a,k1) * s.DataLoc(s.b,k2) by A66,A68,A70,SCMPDS_2:63
         .= Exec(i, s).c by A66,A69,SCMPDS_2:63
         .= (Exec(i, s) +* Start-At IEn).c by SCMPDS_3:14;
       end;
       suppose
A71:       DataLoc(ss.a,k1) <> c;
then A72:       DataLoc(s.a,k1) <> c by SCMPDS_3:14;
          thus Exec(i, ss).c
          = ss.c by A66,A71,SCMPDS_2:63
         .= s.c by SCMPDS_3:14
         .= Exec(i, s).c by A66,A72,SCMPDS_2:63
         .= (Exec(i, s) +* Start-At IEn).c by SCMPDS_3:14;
     end;
     end;
     hence thesis by A6,A67,SCMPDS_2:54;

    end;
    suppose InsCode i = 12;
     then consider a,b,k1,k2 such that
A73:  i = Divide(a,k1,b,k2) by SCMPDS_2:47;
  IC Exec(i, s) = Nl by A73,SCMPDS_2:64;
then A74: IC Exec(i, ss) =
 IC (Exec(i, s) +* Start-At IEn) by A4,A73,SCMPDS_2:64;
         now let c;
A75:       ss.DataLoc(ss.a,k1) =s.DataLoc(ss.a,k1) by SCMPDS_3:14
          .=s.DataLoc(s.a,k1) by SCMPDS_3:14;
A76:       ss.DataLoc(ss.b,k2) =s.DataLoc(ss.b,k2) by SCMPDS_3:14
          .=s.DataLoc(s.b,k2) by SCMPDS_3:14;
         per cases;
         suppose
A77:       DataLoc(ss.b,k2) = c;
then A78:       DataLoc(s.b,k2) = c by SCMPDS_3:14;
          thus Exec(i, ss).c = s.DataLoc(s.a,k1) mod s.DataLoc(s.b,k2) by A73
,A75,A76,A77,SCMPDS_2:64
         .= Exec(i, s).c by A73,A78,SCMPDS_2:64
         .= (Exec(i, s) +* Start-At IEn).c by SCMPDS_3:14;
         end;
         suppose
A79:       DataLoc(ss.b,k2) <> c;
then A80:       DataLoc(s.b,k2) <> c by SCMPDS_3:14;
          hereby
             per cases;
             suppose
            A81: DataLoc(ss.a,k1) <> c;
            then A82: DataLoc(s.a,k1) <> c by SCMPDS_3:14;
            thus Exec(i, ss).c = ss.c by A73,A79,A81,SCMPDS_2:64
                .=s.c by SCMPDS_3:14
                .=Exec(i,s).c by A73,A80,A82,SCMPDS_2:64
                .= (Exec(i, s) +* Start-At IEn).c by SCMPDS_3:14;
             end;
             suppose
             A83: DataLoc(ss.a,k1) = c;
             then A84: DataLoc(s.a,k1) = c by SCMPDS_3:14;
             thus Exec(i, ss).c = s.DataLoc(s.a,k1) div s.DataLoc(s.b,k2) by
A73,A75,A76,A79,A83,SCMPDS_2:64
             .= Exec(i,s).c by A73,A80,A84,SCMPDS_2:64
             .= (Exec(i, s) +* Start-At IEn).c by SCMPDS_3:14;
           end;
           end;
     end;
     end;
     hence thesis by A6,A74,SCMPDS_2:54;

    end;
    suppose InsCode i = 13;
    then consider a,b,k1,k2 such that
A85:  i = (a,k1):=(b,k2) by SCMPDS_2:48;
  IC Exec(i, s) = Nl by A85,SCMPDS_2:59;
then A86: IC Exec(i, ss) =
 IC (Exec(i, s) +* Start-At IEn) by A4,A85,SCMPDS_2:59;
         now let c;
         per cases;
         suppose
A87:       DataLoc(ss.a,k1) = c;
then A88:       DataLoc(s.a,k1) = c by SCMPDS_3:14;
          thus Exec(i, ss).c = ss.DataLoc(ss.b,k2) by A85,A87,SCMPDS_2:59
          .=s.DataLoc(ss.b,k2) by SCMPDS_3:14
          .=s.DataLoc(s.b,k2) by SCMPDS_3:14
          .=Exec(i,s).c by A85,A88,SCMPDS_2:59
          .= (Exec(i, s) +* Start-At IEn).c by SCMPDS_3:14;
         end;
         suppose
A89:       DataLoc(ss.a,k1) <> c;
then A90:       DataLoc(s.a,k1) <> c by SCMPDS_3:14;
          thus Exec(i,ss).c = ss.c by A85,A89,SCMPDS_2:59
          .=s.c by SCMPDS_3:14
          .=Exec(i,s).c by A85,A90,SCMPDS_2:59
          .= (Exec(i, s) +* Start-At IEn).c by SCMPDS_3:14;
     end;
     end;
     hence thesis by A6,A86,SCMPDS_2:54;
end;
end;

begin :: Computation of two consecutive program blocks

theorem    ::Th42
     for I being parahalting No-StopCode Program-block,J being parahalting
 shiftable Program-block,k being Element of NAT
 st Initialized stop (I ';' J) c= s
 holds
 (Computation (Result(s +*Initialized stop I) +* Initialized stop J )).k
 +* Start-At (IC
 (Computation (Result(s +*Initialized stop I) +* Initialized stop J )).k
 + card I),
 (Computation (s +* Initialized stop (I ';' J))).
                          (LifeSpan (s +* Initialized stop I)+k)
            equal_outside the Instruction-Locations of SCMPDS
proof
 let I be parahalting No-StopCode Program-block,J be parahalting
 shiftable Program-block,k be Element of NAT;
set IsI = Initialized stop I,
    sIsI = s +* IsI,
    RI = Result sIsI,
    pJ= stop J,
    IsJ = Initialized pJ,
    RIJ = RI +* IsJ,
    pIJ = stop (I ';' J),
    IsIJ = Initialized pIJ,
    sIsIJ = s +* IsIJ;
    assume
A1: IsIJ c= s;
A2: IsI c= sIsI by FUNCT_4:26;
     IsIJ c= sIsIJ by FUNCT_4:26;
then A3: pIJ c= sIsIJ by SCMPDS_4:57;
A4: s = sIsIJ by A1,FUNCT_4:79;
        Initialized I c= IsIJ by Th15;
then A5: Initialized I c= s by A1,XBOOLE_1:1;
    set SA0=Start-At inspos 0;
A6: sIsI is halting by A2,SCMPDS_4:63;
   set IL=the Instruction-Locations of SCMPDS,
        m1 = LifeSpan sIsI;
   set s1 = RIJ +* Start-At (IC RIJ + card I);
   set s2 = (Computation sIsIJ).(LifeSpan sIsI+0);
   A7: now
    thus IC s1 = IC (RI +* (stop J +* SA0)) + card I by AMI_1:111
      .= IC (RI +* stop J +* SA0) + card I by FUNCT_4:15
      .= inspos 0 + card I by AMI_1:111
      .= inspos (0+card I) by SCMPDS_3:def 3
      .= IC s2 by A4,A5,Th30;
A8: (Computation sIsI).m1,(Computation sIsIJ).m1 equal_outside IL by Th34;
     hereby let a be Int_position;
               A9: not a in dom (stop J+*SA0) by SCMPDS_4:61;
            not a in dom Start-At (IC RIJ + card I) by SCMPDS_4:59;
      hence s1.a = RIJ.a by FUNCT_4:12
         .= RI.a by A9,FUNCT_4:12
         .= (Computation sIsI).m1.a by A6,AMI_1:122
         .= s2.a by A8,SCMPDS_4:13;
     end;
  end;
  defpred X[Element of NAT] means
    (Computation RIJ).$1 +* Start-At (IC (Computation RIJ).$1 + card I),
    (Computation sIsIJ).(LifeSpan sIsI+$1) equal_outside IL;
        (Computation RIJ).0 = RIJ by AMI_1:def 19;
then A10: X[0] by A7,SCMPDS_4:11;
A11: for k being Element of NAT st X[k] holds X[k+1]
    proof let k be Element of NAT;
    set k1 = k+1,
        CRk = (Computation RIJ).k,
        CRSk = CRk +* Start-At (IC CRk + card I),
        CIJk = (Computation sIsIJ).(LifeSpan sIsI+k),

        CRk1 = (Computation RIJ).k1,
        CRSk1 = CRk1 +* Start-At (IC CRk1 + card I),
        CIJk1 = (Computation sIsIJ).(LifeSpan sIsI+k1);
    assume
A12:  CRSk,CIJk equal_outside IL;
A13:  CurInstr CRk = CurInstr CIJk
      proof
A14:     CurInstr CIJk = CIJk.IC CRSk by A12,AMI_1:121
         .= CIJk.(IC CRk + card I) by AMI_1:111;
             IsJ c= RIJ by FUNCT_4:26;
then A15:     IC CRk in dom pJ by SCMPDS_4:def 9;
A16:     pIJ = I ';' pJ by SCMPDS_4:46;
         consider n such that
A17:     inspos n= IC CRk by SCMPDS_3:32;
             n < card pJ by A15,A17,SCMPDS_4:1;
         then n+card I < card pJ + card I by XREAL_1:8;
         then n+card I < card pIJ by A16,SCMPDS_4:45;
         then inspos(n+card I) in dom pIJ by SCMPDS_4:1;
then A18:     IC CRk + card I in dom pIJ by A17,SCMPDS_3:def 3;
             RIJ =RI +* pJ +* SA0 by FUNCT_4:15
         .=RI +* SA0 +* pJ by SCMPDS_4:62;
         then pJ c= RIJ by FUNCT_4:26;
then     pJ c= CRk by AMI_1:81;
      hence CurInstr CRk =pJ.IC CRk by A15,GRFUNC_1:8
        .=pIJ.(IC CRk + card I) by A15,A16,SCMPDS_4:38
        .= sIsIJ.(IC CRk + card I) by A3,A18,GRFUNC_1:8
        .= CurInstr CIJk by A14,AMI_1:54;
     end;
         CIJk1 =(Computation sIsIJ).(LifeSpan sIsI+k+1);
     then A19: CIJk1 = Following CIJk by AMI_1:def 19;
         CIJk,CRSk equal_outside IL by A12,FUNCT_7:28;
     then Exec(CurInstr CIJk, CIJk),Exec(CurInstr CRk,CRSk)
           equal_outside IL by A13,SCMPDS_4:15;

then A20: Exec(CurInstr CIJk, CIJk),
       Following(CRk) +* Start-At (IC Following(CRk) + card I)
           equal_outside IL by Th35;
         IC CRSk1 = IC CRk1 + card I by AMI_1:111
     .= IC Following CRk + card I by AMI_1:def 19;
then A21: IC CRSk1=IC (Following(CRk) +* Start-At (IC Following(CRk) + card I))
          by AMI_1:111
      .= IC CIJk1 by A19,A20,AMI_1:121;
    now let a be Int_position;
      thus CRSk1.a = CRk1.a by SCMPDS_3:14
         .= (Following CRk).a by AMI_1:def 19
         .= (Following(CRk) +* Start-At (IC Following(CRk) + card I)).a
                      by SCMPDS_3:14
         .= CIJk1.a by A19,A20,SCMPDS_4:13;
     end;
    hence (Computation RIJ).k1 +* Start-At (IC (Computation RIJ).k1 + card I),
      (Computation sIsIJ).(LifeSpan sIsI+k1)
    equal_outside IL by A21,SCMPDS_4:11;
   end;
     for k being Element of NAT holds X[k] from NAT_1:sch 1(A10,A11);
  hence thesis;
end;

Lm3:
 for I being parahalting No-StopCode Program-block,J being parahalting
 shiftable Program-block,s,s1 being State of SCMPDS
 st Initialized stop (I ';' J) c= s & s1=s +* Initialized stop I holds
 IC (Computation s).(LifeSpan s1) = inspos card I &
 (Computation s).(LifeSpan s1) | SCM-Data-Loc =
 ((Computation s1).(LifeSpan s1) +* Initialized stop J) | SCM-Data-Loc &
   Shift(stop J,card I) c= (Computation s).(LifeSpan s1) &
  LifeSpan s = LifeSpan s1 + LifeSpan (Result s1 +* Initialized stop J)
proof
 let I be parahalting No-StopCode Program-block,J be parahalting
     shiftable Program-block,s,s1 be State of SCMPDS;
   set IsI = Initialized stop I,
       spJ = stop J,
       IsJ = Initialized spJ,
       sIJ = stop (I ';' J),
       IsIJ = Initialized sIJ,
       m1 = LifeSpan s1,
       s3 = (Computation s1).m1 +* IsJ;
   set m3 = LifeSpan s3;
   set A = the Instruction-Locations of SCMPDS;
   set D = SCM-Data-Loc;
   assume
A1:  IsIJ c= s & s1=s +* IsI;
then A2:  s = s +* IsIJ by FUNCT_4:79
     .= s +* ((I ';' (J ';' SCMPDS-Stop)) +* Start-At inspos 0) by SCMPDS_4:46;
A3:  sIJ c= s by A1,SCMPDS_4:57;
A4:  s3 | D = ((Computation s1).m1 | D) +* IsJ | D by FUNCT_4:75;
A5:  now let x be set;
         assume x in dom (IsJ | D);
         then A6: x in dom IsJ /\ D by FUNCT_1:68;
    then A7: x in dom IsJ & x in D by XBOOLE_0:def 3;
         per cases by A7,SCMPDS_4:28;
         suppose A8: x in dom spJ;
                dom spJ c= A by AMI_1:def 40;
          then reconsider l=x as Instruction-Location of SCMPDS
                    by A8,AMI_1:def 4;
           (IsJ | D).l = ((Computation s1).m1 | D).l by A7,SCMPDS_4:22;
          hence (IsJ | D).x = ((Computation s1).m1 | D).x;
         end;
         suppose x = IC SCMPDS;
          hence (IsJ | D).x = ((Computation s1).m1 | D).x by A6,SCMPDS_3:6
,XBOOLE_0:def 3;
     end;
     end;
A9:   IsJ c= s3 by FUNCT_4:26;
      then dom IsJ c= dom s3 by GRFUNC_1:8;
then A10:  dom IsJ c= the carrier of SCMPDS by AMI_1:79;
          dom (IsJ | D) = dom IsJ /\ D by RELAT_1:90;
      then dom (IsJ | D) c= (the carrier of SCMPDS) /\ D by A10,XBOOLE_1:26;
      then dom (IsJ | D) c= dom ((Computation s1).m1) /\ D by AMI_1:79;
      then dom (IsJ | D) c= dom ((Computation s1).m1 | D) by RELAT_1:90;
      then IsJ | D c= (Computation s1).m1 | D by A5,GRFUNC_1:8;
then A11:  (Computation s1).m1 | D = s3 | D by A4,LATTICE2:8;
      set s4 = (Computation s).m1;
A12:   (Computation s1).m1, s4 equal_outside A by A1,A2,Th33;
A13:  s3 is halting by A9,AMI_1:def 26;
          Initialized I c= IsIJ by Th15;
then A14:  Initialized I c= s by A1,XBOOLE_1:1;
      hence A15:   IC s4 = inspos card I by A1,Th30;
      thus
A16:   s4 | D = s3 | D by A11,A12,SCMPDS_4:24;
        reconsider m = m1 + m3 as Element of NAT;
            sIJ = I ';' (J ';' SCMPDS-Stop) by SCMPDS_4:46
        .= I +* Shift(spJ, card I);
        then Shift(spJ, card I) c= sIJ by FUNCT_4:26;
        then Shift(spJ, card I) c= s by A3,XBOOLE_1:1;
     hence A17: Shift(spJ, card I) c= s4 by AMI_1:81;
A18:  now let k be Element of NAT;
      assume m1 + k < m;
then A19:    k < m3 by XREAL_1:8;
      assume
A20:    CurInstr (Computation s).(m1 + k) = halt SCMPDS;
            CurInstr (Computation s3).k
        = CurInstr (Computation s4).k by A9,A15,A16,A17,SCMPDS_4:84
        .= halt SCMPDS by A20,AMI_1:51;
        hence contradiction by A13,A19,AMI_1:def 46;
     end;
         CurInstr (Computation s3).m3 = CurInstr (Computation s4).m3
         by A9,A15,A16,A17,SCMPDS_4:84;
     then CurInstr (Computation s3).m3
          = CurInstr (Computation s).(m1 + m3) by AMI_1:51;
then A21:  CurInstr (Computation s).m = halt SCMPDS by A13,AMI_1:def 46;

         now let k be Element of NAT;
      assume
A22:    k < m;
      per cases;
      suppose k < m1;
       hence CurInstr (Computation s).k <> halt SCMPDS by A1,A14,Th32;
      end;
      suppose m1 <= k;
       then consider kk being Nat such that
A23:   m1 + kk = k by NAT_1:10;
        kk in NAT by ORDINAL1:def 13;
       hence CurInstr (Computation s).k <> halt SCMPDS by A18,A22,A23;
     end;
     end;
then A24:  for k being Element of NAT
st CurInstr (Computation s).k = halt SCMPDS
     holds m <= k;
         s is halting by A1,SCMPDS_4:63;
then A25: LifeSpan s = m by A21,A24,AMI_1:def 46;
        IsI c= s1 by A1,FUNCT_4:26;
    then s1 is halting by SCMPDS_4:63;
   hence LifeSpan s = LifeSpan s1 + LifeSpan (Result s1 +* IsJ)
                   by A25,AMI_1:122;
end;

theorem Th37: ::Th43
 for I being parahalting No-StopCode Program-block,J being parahalting
 shiftable Program-block
   holds
     LifeSpan (s +* Initialized stop (I ';' J))
     = LifeSpan (s +* Initialized stop I)
      + LifeSpan (Result (s +* Initialized stop I) +* Initialized stop J)
proof
  let I be parahalting No-StopCode Program-block,J be parahalting
      shiftable Program-block;
    set sI=stop I,
        IsI = Initialized sI,
        sIJ = stop (I ';' J),
        IsIJ= Initialized sIJ,
        s1=s +* IsIJ,
        s2=s +* IsI;
A1: IsIJ c= s1 by FUNCT_4:26;
    set IL=the Instruction-Locations of SCMPDS,
        SA0= Start-At inspos 0;
A2: s1 =s +* sIJ +* SA0 by FUNCT_4:15
    .=s+*SA0+* sIJ by SCMPDS_4:62;
A3: s2 =s +* sI +* SA0 by FUNCT_4:15
    .=s+*SA0+* sI by SCMPDS_4:62;
      s1 +* IsI = s1 +* sI by A1,SCMPDS_4:34;
then A4: s1, s1 +* IsI equal_outside IL by AMI_1:120;
        s+*SA0, s2 equal_outside IL by A3,AMI_1:120;
then A5: s2,s+*SA0 equal_outside IL by FUNCT_7:28;
        s+*SA0,s1 equal_outside IL by A2,AMI_1:120;
    then s2, s1 equal_outside IL by A5,FUNCT_7:29;
then A6: s2,s1+*IsI equal_outside IL by A4,FUNCT_7:29;
A7: IsI c= s1 +* IsI by FUNCT_4:26;
     IsI c= s2 by FUNCT_4:26;
then A8: LifeSpan (s1 +* IsI) = LifeSpan s2 &
    Result s2,Result (s1 +* IsI) equal_outside IL by A6,A7,Th21;
    set IsJ=Initialized stop J,
        s3=Result (s1 +* IsI) +* IsJ,
        s4=Result s2 +* IsJ;
A9: s4,s3 equal_outside IL by A8,FUNCT_7:106;
A10: IsJ c= s3 by FUNCT_4:26;
     IsJ c= s4 by FUNCT_4:26;
then LifeSpan s3 = LifeSpan s4 by A9,A10,Th21;
    hence LifeSpan s1 = LifeSpan s2 + LifeSpan s4 by A1,A8,Lm3;
end;

theorem Th38:
 for I being parahalting No-StopCode Program-block,J being parahalting
 shiftable Program-block
  holds
     IExec(I ';' J,s) =
         IExec(J,IExec(I,s)) +* Start-At (IC IExec(J,IExec(I,s)) + card I)
proof
 let I be parahalting No-StopCode Program-block,J be parahalting
      shiftable Program-block;
   set A = the Instruction-Locations of SCMPDS,
       D = SCM-Data-Loc,
       ps = s | A,
       sI = stop I,
       IsI = Initialized sI,
       IsJ = Initialized stop J,
       sIJ = stop (I ';' J),
       IsIJ =Initialized sIJ,
       s1 = s +* IsI ,
       m1 = LifeSpan s1,
       C1 = Computation s1,
       s2 = s +* Initialized stop (I ';' J),
       s3 = C1.m1 +* IsJ,
       m3 = LifeSpan s3,
       C2 = Computation s2,
       C3 = Computation s3;
A1: IsI c= s1 by FUNCT_4:26;
then A2: s1 is halting by SCMPDS_4:63;
A3: IsIJ c= s2 by FUNCT_4:26;
then A4: s2 is halting by SCMPDS_4:63;
        IsJ c= s3 by FUNCT_4:26;
then A5: s3 is halting by SCMPDS_4:63;
A6: dom ps = dom s /\ A by RELAT_1:90
    .= ({IC SCMPDS} \/ D \/ A) /\ A by SCMPDS_4:19
    .= A by XBOOLE_1:21;
        C1.m1, C1.m1 +* ps equal_outside dom ps by FUNCT_7:31;
    then A7: C1.m1 +* IsJ, C1.m1 +* ps +* IsJ equal_outside dom ps
     by FUNCT_7:106;
then A8: C1.m1 +* ps +* IsJ, C1.m1 +* IsJ equal_outside dom ps by FUNCT_7:28;
       Result (IExec(I,s) +* IsJ), Result s3 equal_outside A
   proof
   A9: IsJ c= IExec(I,s) +* IsJ by FUNCT_4:26;
   A10: IsJ c= s3 by FUNCT_4:26;
            IExec(I,s) = C1.m1 +* ps by A2,AMI_1:122;
        hence thesis by A6,A8,A9,A10,Th21;
     end;
then A11: Result (IExec(I,s) +* IsJ) +* ps = Result s3 +* ps
                           by A6,FUNCT_7:108;
A12:  s3 = Result s1 +* IsJ by A2,AMI_1:122;
A13: IExec(I ';' J,s)
    = C2.LifeSpan s2 +* ps by A4,AMI_1:122
   .= C2.(m1 + m3) +* ps by A12,Th37;
      A14: IExec(I,s) | A = ps by SCMPDS_4:25;
then A15: IExec(J,IExec(I,s))
    = C3.m3 +* ps by A5,A11,AMI_1:122;
   set SA0= Start-At inspos 0;
A16: s2 =s +* sIJ +* SA0 by FUNCT_4:15
    .=s+*SA0+* sIJ by SCMPDS_4:62;
A17: s1 =s +* sI +* SA0 by FUNCT_4:15
    .=s+*SA0+* sI by SCMPDS_4:62;
A18:  s2 +* IsI = s2 +* sI by A3,SCMPDS_4:34;
A19: IsI c= s2 +* IsI by FUNCT_4:26;
A20: s2, s2 +* IsI equal_outside A by A18,AMI_1:120;
        s+*SA0, s1 equal_outside A by A17,AMI_1:120;
then A21: s1,s+*SA0 equal_outside A by FUNCT_7:28;
        s+*SA0,s2 equal_outside A by A16,AMI_1:120;
    then s1, s2 equal_outside A by A21,FUNCT_7:29;
 then s1,s2+*IsI equal_outside A by A20,FUNCT_7:29;
then A22: LifeSpan (s2 +* IsI) = m1 by A1,A19,Th21;
then A23: IC C2.m1 = inspos card I &
     C2.m1 | D = ((Computation (s2 +* IsI)).m1 +* IsJ) | D &
     Shift(stop J,card I) c= C2.m1 by A3,Lm3;
A24: (Computation C2.m1).m3 | D = C3.m3 | D &
     IC (Computation C2.m1).m3 = IC C3.m3 + card I
     proof
 A25:  IsJ c= s3 by FUNCT_4:26;
       s1 +* IsIJ =s +* (IsI +* IsIJ) by FUNCT_4:15
       .=s2 by Th17;
 then A26:  (Computation s1).m1, (Computation s2).m1 equal_outside A
          by A1,Th24;
          (Computation (s2 +* IsI)).m1,(Computation ((s2 +* IsI) +*IsIJ)).m1
          equal_outside A by A19,A22,Th24;
      then (Computation (s2 +* IsI)).m1 | D
       = (Computation (s2 +* IsI +* IsIJ)).m1 | D by SCMPDS_4:24
      .= (Computation (s2 +* (IsI +* IsIJ))).m1 | D by FUNCT_4:15
      .= (Computation (s2 +* IsIJ)).m1 | D by Th17
      .= (Computation (s +* (IsIJ +* IsIJ))).m1 | D by FUNCT_4:15
      .= (Computation s1).m1 | D by A26,SCMPDS_4:24;
 then ((Computation (s2 +* IsI)).m1 +* IsJ) | D
       =(Computation s1).m1 | D +* IsJ | D by FUNCT_4:75
      .= ((Computation s1).m1 +* IsJ) | D by FUNCT_4:75;
      hence thesis by A23,A25,SCMPDS_4:84;
     end;
A27: IExec(I ';' J,s) | D = IExec(J,IExec(I,s)) | D
     proof
      thus IExec(I ';' J,s) | D
       = C2.(m1 + m3) | D by A6,A13,AMI_2:29,FUNCT_4:76
      .= C3.m3 | D by A24,AMI_1:51
      .= IExec(J,IExec(I,s)) | D by A6,A15,AMI_2:29,FUNCT_4:76;
     end;
     A28: Result s1 = C1.m1 by A2,AMI_1:122;
A29: IsJ c= Result s1 +* IsJ by FUNCT_4:26;
         IsJ c= IExec(I,s) +* IsJ by FUNCT_4:26;
     then Result (Result s1 +* IsJ), Result (IExec(I,s) +* IsJ)
       equal_outside A by A6,A7,A28,A29,Th21;
then A30: IC Result (Result s1 +* IsJ)
   = IC Result (IExec(I,s) +* IsJ) by AMI_1:121;
A31: IC IExec(I ';' J,s) = IC Result (s +* IsIJ) by Th22
   .= IC C2.LifeSpan s2 by A4,AMI_1:122
   .= IC C2.(m1 + m3) by A12,Th37
   .= IC C3.m3 + card I by A24,AMI_1:51
   .= IC Result s3 + card I by A5,AMI_1:122
   .= IC Result (Result s1 +* IsJ) + card I by A2,AMI_1:122
   .= IC IExec(J,IExec(I,s)) + card I by A30,Th22;
   hereby
A32: dom IExec(I ';' J,s) = the carrier of SCMPDS by AMI_1:79
    .= dom (IExec(J,IExec(I,s)) +*
        Start-At (IC IExec(J,IExec(I,s)) + card I)) by AMI_1:79;
      reconsider l = IC IExec(J,IExec(I,s)) + card I
          as Instruction-Location of SCMPDS;
A33:   dom Start-At l = {IC SCMPDS} by FUNCOP_1:19;
          now let x be set;
      assume A34: x in dom IExec(I ';' J,s);
      per cases by A34,SCMPDS_4:20;
      suppose A35: x is Int_position;
  then A36:  IExec(I ';' J,s).x = IExec(J,IExec(I,s)).x by A27,SCMPDS_4:23;
           x <> IC SCMPDS by A35,SCMPDS_2:52;
       then not x in dom Start-At l by A33,TARSKI:def 1;
       hence IExec(I ';' J,s).x
       = (IExec(J,IExec(I,s)) +* Start-At
         (IC IExec(J,IExec(I,s)) + card I)).x by A36,FUNCT_4:12;
      end;
      suppose A37: x = IC SCMPDS;
       then x in {IC SCMPDS} by TARSKI:def 1;
    then A38: x in dom Start-At l by FUNCOP_1:19;
       thus IExec(I ';' J,s).x
        = (Start-At l).IC SCMPDS by A31,A37,CQC_LANG:6
       .= (IExec(J,IExec(I,s)) +* Start-At
           (IC IExec(J,IExec(I,s)) + card I)).x by A37,A38,FUNCT_4:14;
      end;
      suppose A39: x is Instruction-Location of SCMPDS;
           IExec(I ';' J,s) | A = ps by SCMPDS_4:25
       .= IExec(J,IExec(I,s)) | A by A14,SCMPDS_4:25;
  then A40:  IExec(I ';' J,s).x = IExec(J,IExec(I,s)).x by A39,SCMPDS_4:21;
           x <> IC SCMPDS by A39,AMI_1:48;
       then not x in dom Start-At l by A33,TARSKI:def 1;
       hence IExec(I ';' J,s).x
       = (IExec(J,IExec(I,s)) +* Start-At
         (IC IExec(J,IExec(I,s)) + card I)).x by A40,FUNCT_4:12;
      end;
      end;
      hence thesis by A32,FUNCT_1:9;
    end;
end;

theorem
     for I being parahalting No-StopCode Program-block,J being parahalting
 shiftable Program-block
  holds IExec(I ';' J, s).a = IExec(J,IExec(I,s)).a
proof
  let I be parahalting No-StopCode Program-block,J be parahalting
    shiftable Program-block;
A1: IExec(I ';' J,s) =
         IExec(J,IExec(I,s)) +* Start-At (IC IExec(J,IExec(I,s)) + card I)
                by Th38;
     not a in dom Start-At (IC IExec(J,IExec(I,s)) + card I) by SCMPDS_4:59;
 hence IExec(I ';' J, s).a = IExec(J,IExec(I,s)).a by A1,FUNCT_4:12;
end;

begin :: Computation of the program consisting of a instruction and a block

definition
 let s be State of SCMPDS;
 func Initialized s -> State of SCMPDS equals
    s +* Start-At(inspos 0);
 coherence;
end;

theorem Th40:   ::Th3c
  IC Initialized s = inspos 0 & (Initialized s).a = s.a &
  (Initialized s).loc = s.loc
proof
       dom Start-At inspos 0 = {IC SCMPDS} by FUNCOP_1:19;
then (Start-At inspos 0).IC SCMPDS = inspos 0 &
   IC SCMPDS in dom Start-At inspos 0 by CQC_LANG:6,TARSKI:def 1;
 hence IC Initialized s = inspos 0 by FUNCT_4:14;
         not a in dom Start-At inspos 0 by SCMPDS_4:59;
    hence (Initialized s).a =s.a by FUNCT_4:12;
         not loc in dom Start-At inspos 0 by SCMPDS_4:60;
   hence (Initialized s).loc = s.loc by FUNCT_4:12;
end;

theorem Th41:  ::Th4c
 s1, s2 equal_outside the Instruction-Locations of SCMPDS
iff
   s1 | (SCM-Data-Loc \/ {IC SCMPDS}) = s2 | (SCM-Data-Loc \/ {IC SCMPDS})
proof
    set X = SCM-Data-Loc \/ {IC SCMPDS};
    set Y = the Instruction-Locations of SCMPDS;
    A1: dom s1 = the carrier of SCMPDS by AMI_1:79;
    A2: dom s2 = the carrier of SCMPDS by AMI_1:79;
A3: (X \/ Y) \ Y \/ Y = X \/ Y \/ Y by XBOOLE_1:39
                     .= X \/ (Y \/ Y) by XBOOLE_1:4
                     .= Y \/ X;
A4:  Y misses (X \/ Y) \ Y by XBOOLE_1:79;
A5:  X misses Y
     proof
      assume X meets Y; then consider x such that
A6:   x in X & x in Y by XBOOLE_0:3;
        A7: x in SCM-Data-Loc or x in {IC SCMPDS} by A6,XBOOLE_0:def 2;
      per cases by A7,TARSKI:def 1;
      suppose x in SCM-Data-Loc;
        hence contradiction by A6,AMI_2:29,XBOOLE_0:3;
      end;
      suppose x = IC SCMPDS;
      then reconsider l=IC SCMPDS as Instruction-Location of SCMPDS
             by A6,AMI_1:def 4;
          l=IC SCMPDS;
        hence contradiction by AMI_1:48;
     end;
     end;
then A8: dom s1 \ Y = X by A1,A3,A4,SCMPDS_3:5,XBOOLE_1:72;
    dom s2 \ Y = X by A2,A3,A4,A5,SCMPDS_3:5,XBOOLE_1:72;
    hence s1, s2 equal_outside Y iff
       s1 | X = s2 | X by A8,FUNCT_7:def 2;
end;

canceled;

theorem Th43:   ::Th5c
    s1 | SCM-Data-Loc = s2 | SCM-Data-Loc & InsCode i <> 3 implies
    Exec (i, s1) | SCM-Data-Loc = Exec (i, s2) | SCM-Data-Loc
proof assume
A1: s1 | SCM-Data-Loc = s2 | SCM-Data-Loc & InsCode i <> 3;
A2: InsCode i <= 13 by SCMPDS_2:15;
    per cases by A1,A2,NAT_1:38;
    suppose InsCode i = 0;
    then consider k1 such that
A3:  i = goto k1 by SCMPDS_2:35;
      now let a;
        thus Exec(i, s1).a = s1.a by A3,SCMPDS_2:66
          .=s2.a by A1,SCMPDS_4:23
          .=Exec(i, s2).a by A3,SCMPDS_2:66;
     end;
     hence Exec (i, s1) | SCM-Data-Loc = Exec (i, s2) | SCM-Data-Loc
     by SCMPDS_4:23;

    end;
    suppose InsCode i = 1;
    then consider a such that
A4:  i = return a by SCMPDS_2:36;
         now let b;
         per cases;
         suppose A5:a=b;
          hence Exec(i, s1).b= s1.DataLoc(s1.a,RetSP) by A4,SCMPDS_2:70
          .=s2.DataLoc(s2.a,RetSP) by A1,SCMPDS_3:3
          .=Exec(i,s2).b by A4,A5,SCMPDS_2:70;
         end;
         suppose A6:a<>b;
          hence Exec(i, s1).b = s1.b by A4,SCMPDS_2:70
          .=s2.b by A1,SCMPDS_4:23
          .=Exec(i,s2).b by A4,A6,SCMPDS_2:70;
      end;
      end;
      hence thesis by SCMPDS_4:23;

    end;
    suppose InsCode i = 2;
    then consider a,k1 such that
A7:   i = a := k1 by SCMPDS_2:37;
          now let b;
         per cases;
         suppose A8:a=b;
          hence Exec(i, s1).b= k1 by A7,SCMPDS_2:57
          .=Exec(i,s2).b by A7,A8,SCMPDS_2:57;
         end;
         suppose A9:a<>b;
          hence Exec(i,s1).b = s1.b by A7,SCMPDS_2:57
          .=s2.b by A1,SCMPDS_4:23
          .=Exec(i,s2).b by A7,A9,SCMPDS_2:57;
     end;
     end;
      hence thesis by SCMPDS_4:23;

    end;
    suppose InsCode i = 4;
    then consider a,k1,k2 such that
A10:   i = (a,k1)<>0_goto k2 by SCMPDS_2:39;
         now let a;
        thus Exec(i, s1).a = s1.a by A10,SCMPDS_2:67
        .=s2.a by A1,SCMPDS_4:23
        .=Exec(i, s2).a by A10,SCMPDS_2:67;
     end;
     hence thesis by SCMPDS_4:23;

    end;
    suppose InsCode i = 5;
    then consider a,k1,k2 such that
A11:   i = (a,k1)<=0_goto k2 by SCMPDS_2:40;
         now let a;
        thus Exec(i, s1).a = s1.a by A11,SCMPDS_2:68
        .=s2.a by A1,SCMPDS_4:23
        .=Exec(i, s2).a by A11,SCMPDS_2:68;
     end;
     hence thesis by SCMPDS_4:23;

    end;
    suppose InsCode i = 6;
    then consider a,k1,k2 such that
A12:   i = (a,k1)>=0_goto k2 by SCMPDS_2:41;
        now let a;
        thus Exec(i, s1).a = s1.a by A12,SCMPDS_2:69
        .=s2.a by A1,SCMPDS_4:23
        .=Exec(i, s2).a by A12,SCMPDS_2:69;
     end;
     hence thesis by SCMPDS_4:23;

    end;
    suppose InsCode i = 7;
    then consider a,k1,k2 such that
A13:   i = (a,k1) := k2 by SCMPDS_2:42;
         now let b;
         per cases;
         suppose A14:DataLoc(s1.a,k1)=b;
         then A15: DataLoc(s2.a,k1)=b by A1,SCMPDS_4:23;
          thus Exec(i, s1).b= k2 by A13,A14,SCMPDS_2:58
          .=Exec(i,s2).b by A13,A15,SCMPDS_2:58;
         end;
         suppose A16:DataLoc(s1.a,k1)<>b;
         then A17: DataLoc(s2.a,k1)<>b by A1,SCMPDS_4:23;
          thus Exec(i,s1).b = s1.b by A13,A16,SCMPDS_2:58
          .=s2.b by A1,SCMPDS_4:23
          .=Exec(i,s2).b by A13,A17,SCMPDS_2:58;
     end;
     end;
      hence thesis by SCMPDS_4:23;

    end;
    suppose InsCode i = 8;
    then consider a,k1,k2 such that
A18:   i = AddTo(a,k1,k2) by SCMPDS_2:43;
         now let b;
         per cases;
         suppose A19:DataLoc(s1.a,k1)=b;
         then A20: DataLoc(s2.a,k1)=b by A1,SCMPDS_4:23;
          thus Exec(i, s1).b= s1.DataLoc(s1.a,k1)+k2 by A18,A19,SCMPDS_2:60
          .= s2.DataLoc(s2.a,k1)+k2 by A1,SCMPDS_3:3
          .=Exec(i,s2).b by A18,A20,SCMPDS_2:60;
         end;
         suppose A21:DataLoc(s1.a,k1)<>b;
         then A22: DataLoc(s2.a,k1)<>b by A1,SCMPDS_4:23;
          thus Exec(i,s1).b = s1.b by A18,A21,SCMPDS_2:60
          .=s2.b by A1,SCMPDS_4:23
          .=Exec(i,s2).b by A18,A22,SCMPDS_2:60;
     end;
     end;
      hence thesis by SCMPDS_4:23;

    end;
    suppose InsCode i = 9;
    then consider a,b,k1,k2 such that
A23:   i = AddTo(a,k1,b,k2) by SCMPDS_2:44;
         now let c;
         per cases;
         suppose A24:DataLoc(s1.a,k1)=c;
         then A25: DataLoc(s2.a,k1)=c by A1,SCMPDS_4:23;
          thus Exec(i, s1).c = s1.DataLoc(s1.a,k1)+s1.DataLoc(s1.b,k2)
             by A23,A24,SCMPDS_2:61
          .= s2.DataLoc(s2.a,k1)+s1.DataLoc(s1.b,k2) by A1,SCMPDS_3:3
          .= s2.DataLoc(s2.a,k1)+s2.DataLoc(s2.b,k2) by A1,SCMPDS_3:3
          .=Exec(i,s2).c by A23,A25,SCMPDS_2:61;
         end;
         suppose A26:DataLoc(s1.a,k1)<>c;
         then A27: DataLoc(s2.a,k1)<>c by A1,SCMPDS_4:23;
          thus Exec(i,s1).c = s1.c by A23,A26,SCMPDS_2:61
          .=s2.c by A1,SCMPDS_4:23
          .=Exec(i,s2).c by A23,A27,SCMPDS_2:61;
     end;
     end;
      hence thesis by SCMPDS_4:23;

    end;
    suppose InsCode i = 10;
    then consider a,b,k1,k2 such that
A28:  i = SubFrom(a,k1,b,k2) by SCMPDS_2:45;
          now let c;
         per cases;
         suppose A29:DataLoc(s1.a,k1)=c;
         then A30: DataLoc(s2.a,k1)=c by A1,SCMPDS_4:23;
          thus Exec(i, s1).c = s1.DataLoc(s1.a,k1)-s1.DataLoc(s1.b,k2)
             by A28,A29,SCMPDS_2:62
          .= s2.DataLoc(s2.a,k1)-s1.DataLoc(s1.b,k2) by A1,SCMPDS_3:3
          .= s2.DataLoc(s2.a,k1)-s2.DataLoc(s2.b,k2) by A1,SCMPDS_3:3
          .=Exec(i,s2).c by A28,A30,SCMPDS_2:62;
         end;
         suppose A31:DataLoc(s1.a,k1)<>c;
         then A32: DataLoc(s2.a,k1)<>c by A1,SCMPDS_4:23;
          thus Exec(i,s1).c = s1.c by A28,A31,SCMPDS_2:62
          .=s2.c by A1,SCMPDS_4:23
          .=Exec(i,s2).c by A28,A32,SCMPDS_2:62;
     end;
     end;
      hence thesis by SCMPDS_4:23;

    end;
    suppose InsCode i = 11;
    then consider a,b,k1,k2 such that
A33: i = MultBy(a,k1,b,k2) by SCMPDS_2:46;
          now let c;
         per cases;
         suppose A34:DataLoc(s1.a,k1)=c;
         then A35: DataLoc(s2.a,k1)=c by A1,SCMPDS_4:23;
          thus Exec(i, s1).c = s1.DataLoc(s1.a,k1)*s1.DataLoc(s1.b,k2)
             by A33,A34,SCMPDS_2:63
          .= s2.DataLoc(s2.a,k1)*s1.DataLoc(s1.b,k2) by A1,SCMPDS_3:3
          .= s2.DataLoc(s2.a,k1)*s2.DataLoc(s2.b,k2) by A1,SCMPDS_3:3
          .=Exec(i,s2).c by A33,A35,SCMPDS_2:63;
         end;
         suppose A36:DataLoc(s1.a,k1)<>c;
         then A37: DataLoc(s2.a,k1)<>c by A1,SCMPDS_4:23;
          thus Exec(i,s1).c = s1.c by A33,A36,SCMPDS_2:63
          .=s2.c by A1,SCMPDS_4:23
          .=Exec(i,s2).c by A33,A37,SCMPDS_2:63;
     end;
     end;
      hence thesis by SCMPDS_4:23;

    end;
    suppose InsCode i = 12;
    then consider a,b,k1,k2 such that
A38: i = Divide(a,k1,b,k2) by SCMPDS_2:47;
          now let c;
         per cases;
         suppose A39:DataLoc(s1.b,k2)=c;
         then A40: DataLoc(s2.b,k2)=c by A1,SCMPDS_4:23;
          thus Exec(i, s1).c = s1.DataLoc(s1.a,k1) mod s1.DataLoc(s1.b,k2)
             by A38,A39,SCMPDS_2:64
          .= s2.DataLoc(s2.a,k1) mod s1.DataLoc(s1.b,k2) by A1,SCMPDS_3:3
          .= s2.DataLoc(s2.a,k1) mod s2.DataLoc(s2.b,k2) by A1,SCMPDS_3:3
          .= Exec(i,s2).c by A38,A40,SCMPDS_2:64;
         end;
         suppose A41:DataLoc(s1.b,k2)<>c;
         then A42: DataLoc(s2.b,k2)<>c by A1,SCMPDS_4:23;
           hereby
             per cases;
             suppose A43:DataLoc(s1.a,k1)<>c;
             then A44: DataLoc(s2.a,k1)<>c by A1,SCMPDS_4:23;
            thus Exec(i, s1).c = s1.c by A38,A41,A43,SCMPDS_2:64
                .=s2.c by A1,SCMPDS_4:23
                .=Exec(i,s2).c by A38,A42,A44,SCMPDS_2:64;
             end;
             suppose A45:DataLoc(s1.a,k1)=c;
              then A46: DataLoc(s2.a,k1)=c by A1,SCMPDS_4:23;
             thus Exec(i, s1).c = s1.DataLoc(s1.a,k1) div s1.DataLoc(s1.b,k2)
               by A38,A41,A45,SCMPDS_2:64
             .= s2.DataLoc(s2.a,k1) div s1.DataLoc(s1.b,k2) by A1,SCMPDS_3:3
             .= s2.DataLoc(s2.a,k1) div s2.DataLoc(s2.b,k2) by A1,SCMPDS_3:3
             .= Exec(i,s2).c by A38,A42,A46,SCMPDS_2:64;
           end;
           end;
     end;
     end;
      hence thesis by SCMPDS_4:23;

    end;
    suppose InsCode i = 13;
    then consider a,b,k1,k2 such that
A47:   i = (a,k1):=(b,k2) by SCMPDS_2:48;
         now let c;
         per cases;
         suppose A48:DataLoc(s1.a,k1)=c;
         then A49: DataLoc(s2.a,k1)=c by A1,SCMPDS_4:23;
          thus Exec(i, s1).c = s1.DataLoc(s1.b,k2) by A47,A48,SCMPDS_2:59
          .= s2.DataLoc(s2.b,k2) by A1,SCMPDS_3:3
          .=Exec(i,s2).c by A47,A49,SCMPDS_2:59;
         end;
         suppose A50:DataLoc(s1.a,k1)<>c;
         then A51: DataLoc(s2.a,k1)<>c by A1,SCMPDS_4:23;
          thus Exec(i,s1).c = s1.c by A47,A50,SCMPDS_2:59
          .=s2.c by A1,SCMPDS_4:23
          .=Exec(i,s2).c by A47,A51,SCMPDS_2:59;
     end;
     end;
      hence thesis by SCMPDS_4:23;
end;
end;

theorem Th44:   ::Th5c
  for i being shiftable Instruction of SCMPDS holds
   (s1 | SCM-Data-Loc = s2 | SCM-Data-Loc implies
    Exec (i, s1) | SCM-Data-Loc = Exec (i, s2) | SCM-Data-Loc)
proof
  let i be shiftable Instruction of SCMPDS;
        InsCode i <> 3 by SCMPDS_4:def 13;
  hence thesis by Th43;
end;

theorem Th45:   ::Th6c
 for i being parahalting Instruction of SCMPDS
  holds Exec(i, Initialized s) = IExec(Load i, s)
proof
 let i be parahalting Instruction of SCMPDS;
    set Li=Load i,
        Mi= stop Li;
    set sI = s+*Initialized Mi;
    set Is = Initialized s;
    set SA0=Start-At (inspos 0);
    set IC1 = IC (Computation sI).1;
A1: inspos 0 in dom Initialized Mi & (Initialized Mi).inspos 0 = i
           by Th13;
A2: inspos 1 in dom Initialized Mi & (Initialized Mi).inspos 1=halt SCMPDS
           by Th13;
A3: Initialized Mi c= sI by FUNCT_4:26;
then A4: sI is halting by SCMPDS_4:63;
A5: now assume
A6:  Result sI = Exec(i, sI);
     set X = SCM-Data-Loc \/ {IC SCMPDS};
     set Y = the Instruction-Locations of SCMPDS;
     A7: dom Exec(i, Is) = the carrier of SCMPDS by AMI_1:79;
     A8: dom IExec(Li, s) = the carrier of SCMPDS by AMI_1:79;
A9: sI = s +*Mi +* SA0 by FUNCT_4:15;
         s,s+*Mi equal_outside Y by AMI_1:120;
     then Is,sI equal_outside Y by A9,FUNCT_7:106;
     then Is | X = sI | X by Th41;
then A10: Exec(i, Is) | X = Exec(i, sI) | X by SCMPDS_3:7;
A11:  X misses Y
      proof
        assume X meets Y; then consider x such that
A12:    x in X & x in Y by XBOOLE_0:3;
        A13: x in SCM-Data-Loc or x in {IC SCMPDS} by A12,XBOOLE_0:def 2;
       per cases by A13,TARSKI:def 1;
       suppose x in SCM-Data-Loc;
        hence contradiction by A12,AMI_2:29,XBOOLE_0:3;
       end;
       suppose x = IC SCMPDS;
      then reconsider l=IC SCMPDS as Instruction-Location of SCMPDS
             by A12,AMI_1:def 4;
          l=IC SCMPDS;
        hence contradiction by AMI_1:48;
     end;
     end;
         dom (s|Y) c= Y by RELAT_1:87;
then A14: X misses dom (s|Y) by A11,XBOOLE_1:63;
     A15: dom Exec(i, sI) = the carrier of SCMPDS by AMI_1:79;
A16: dom s = X \/ Y by AMI_1:79,SCMPDS_3:5;
A17: Y /\ (X \/ Y) c= Y /\ (X \/ Y);
A18: IExec(Li, s) | X = Exec(i, sI) | X by A6,A14,FUNCT_4:76;
A19: IExec(Li, s) | Y = s | Y by A6,A15,A16,A17,FUNCT_4:93,SCMPDS_3:5;
         now
       thus dom (Exec(i, Is) | Y) = dom s /\ Y by A7,A16,RELAT_1:90,SCMPDS_3:5
;
       let x; assume
            x in dom (Exec(i, Is) | Y);
        then A20: x in Y /\ (X \/ Y) by A7,RELAT_1:90,SCMPDS_3:5;
then A21:    x in Y by XBOOLE_1:21;
         x is Element of the Instruction-Locations of SCMPDS by A20,XBOOLE_1:21
;
        then reconsider x' = x as Instruction-Location of SCMPDS
                          by AMI_1:def 4;
      thus (Exec(i, Is)|Y).x = (Exec(i, Is)).x by A21,FUNCT_1:72
            .= Is.x' by AMI_1:def 13
            .= s.x by Th40;
     end;
     then Exec(i, Is) | Y = s | Y by FUNCT_1:68;
then A22: Exec(i, Is)| (X \/ Y) = IExec(Li,s) | (X \/ Y) by A10,A18,A19,
RELAT_1:185;
     thus Exec(i, Is) = Exec(i, Is)| (X \/ Y) by A7,RELAT_1:98,SCMPDS_3:5
      .= IExec(Li, s) by A8,A22,RELAT_1:98,SCMPDS_3:5;
    end;
A23: (Computation sI).(0+1) = Following (Computation sI).0 by AMI_1:def 19
      .= Following sI by AMI_1:def 19
      .= Exec(sI.inspos 0, sI) by A3,Th18
      .= Exec(i, sI) by A1,A3,GRFUNC_1:8;
     A24: IC1 in dom Mi by A3,SCMPDS_4:def 9;
     per cases by A24,Th11;
     suppose A25: IC1 = inspos 0;
then A26:    CurInstr((Computation sI).1)
        = sI.inspos 0 by A23,AMI_1:def 13
        .= i by A1,A3,GRFUNC_1:8;
A27:    Next IC sI = Next inspos 0 by A3,Th18
             .= inspos (0+1) by SCMPDS_4:70
             .= inspos 1;
         set Ni=InsCode i;
        A28: Ni in {0,1,4,5,6} by A23,A25,A27,SCMPDS_4:6;
A29:    Ni <> 1 by Th26;
        hereby
         per cases;
         suppose i = halt SCMPDS;
           hence thesis by A4,A5,A23,A26,AMI_1:def 22;
         end;
         suppose A30: i <> halt SCMPDS;
A31:       IC sI = IC Exec(i, sI) by A3,A23,A25,Th18;
A32:       now let b;
             per cases by A28,A29,ENUMSET1:def 3;
             suppose InsCode i = 0;
               then consider k1 such that
           A33: i = goto k1 by SCMPDS_2:35;
               thus sI.b=Exec(i, sI).b by A33,SCMPDS_2:66;
             end;
             suppose InsCode i = 4;
               then consider a,k1,k2 such that
           A34: i = (a,k1)<>0_goto k2 by SCMPDS_2:39;
               thus sI.b=Exec(i, sI).b by A34,SCMPDS_2:67;
             end;
             suppose InsCode i = 5;
               then consider a,k1,k2 such that
           A35: i = (a,k1)<=0_goto k2 by SCMPDS_2:40;
              thus sI.b=Exec(i, sI).b by A35,SCMPDS_2:68;
             end;
             suppose InsCode i = 6;
              then consider a,k1,k2 such that
            A36: i = (a,k1)>=0_goto k2 by SCMPDS_2:41;
              thus sI.b=Exec(i, sI).b by A36,SCMPDS_2:69;
           end;
           end;
               for loc holds sI.loc = Exec(i, sI).loc by AMI_1:def 13;
then A37:       sI = Exec(i, sI) by A31,A32,SCMPDS_2:54;
           A38: Following sI = Following (Computation sI).0 by AMI_1:def 19
           .= Exec(i, sI) by A23,AMI_1:def 19;
               now let n;
                   (Computation sI).n = sI by A37,A38,Th1
               .= Following (Computation sI).0 by A37,A38,AMI_1:def 19
               .= (Computation sI).(0+1) by AMI_1:def 19;
             hence CurInstr((Computation sI).n) <> halt SCMPDS by A26,A30;
           end;
           then sI is non halting by AMI_1:def 20;
           hence thesis by A3,SCMPDS_4:63;
        end;
        end;
     end;
     suppose
      IC1 = inspos 1;
       then CurInstr((Computation sI).1)
       = sI.inspos 1 by A23,AMI_1:def 13
       .= halt SCMPDS by A2,A3,GRFUNC_1:8;
       hence thesis by A4,A5,A23,AMI_1:def 22;
end;
end;

theorem Th46:   ::Th7c
 for I being parahalting No-StopCode Program-block,j being parahalting
 shiftable Instruction of SCMPDS
  holds IExec(I ';' j, s).a = Exec(j, IExec(I, s)).a
proof
   let I be parahalting No-StopCode Program-block,j be parahalting
   shiftable Instruction of SCMPDS;
 set Mj = Load j;
 set SA = Start-At (IC IExec(Mj,IExec(I,s)) + card I);
A1: not a in dom SA & a in dom IExec(Mj,IExec(I,s)) by SCMPDS_2:49,SCMPDS_4:59;
        for a holds (Initialized IExec(I,s)).a=IExec(I, s).a by Th40;
then A2: (Initialized IExec(I,s)) | SCM-Data-Loc
    = IExec(I, s) | SCM-Data-Loc by SCMPDS_4:23;
A3: a in SCM-Data-Loc by SCMPDS_2:def 2;
 thus IExec(I ';' j, s).a
    = (IExec(Mj,IExec(I,s))+*SA).a by Th38
   .= IExec(Mj, IExec(I,s)).a by A1,FUNCT_4:12
   .= Exec(j, Initialized IExec(I,s)).a by Th45
   .= (Exec(j, Initialized IExec(I,s)) | SCM-Data-Loc).a by A3,FUNCT_1:72
   .= (Exec(j, IExec(I, s)) |SCM-Data-Loc ).a by A2,Th44
   .= Exec(j, IExec(I, s)).a by A3,FUNCT_1:72;
end;

theorem    ::Th9c
     for i being No-StopCode parahalting Instruction of SCMPDS,
     j being shiftable parahalting Instruction of SCMPDS
  holds IExec(i ';' j, s).a = Exec(j, Exec(i, Initialized s)).a
proof
   let i be No-StopCode parahalting Instruction of SCMPDS,
     j be shiftable parahalting Instruction of SCMPDS;
 set Mi = Load i;
 thus IExec(i ';' j, s).a
    = IExec(Mi ';' j, s).a
   .= Exec(j, IExec(Mi,s)).a by Th46
   .= Exec(j, Exec(i, Initialized s)).a by Th45;
end;
