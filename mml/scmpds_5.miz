:: Computation of Two Consecutive Program Blocks for SCMPDS
::  by JingChao Chen
::
:: Received June 15, 1999
:: Copyright (c) 1999 Association of Mizar Users

environ

 vocabularies NUMBERS, SUBSET_1, SCMPDS_2, AMI_1, FSM_1, INT_1, SETFAM_1,
      RELAT_1, SCMFSA_7, CARD_1, SCMPDS_4, FUNCT_1, AMISTD_2, VALUED_1,
      ARYTM_3, TARSKI, XXREAL_0, TURING_1, FUNCT_4, XBOOLE_0,
      SCMFSA6B, FUNCT_7, CIRCUIT2, GRAPHSP, MSUALG_1, AMI_2, AMI_3, SCMPDS_1,
      COMPLEX1, STRUCT_0, ARYTM_1, NAT_1, SCMPDS_5, ORDINAL1, PARTFUN1,
      SCMNORM, GLIB_000, SCMFSA6C;
 notations TARSKI, XBOOLE_0, SETFAM_1, ENUMSET1, SUBSET_1, CARD_1, NUMBERS,
      XCMPLX_0, RELAT_1, FUNCT_1, PARTFUN1, FUNCT_4, INT_1, NAT_1, STRUCT_0,
      COMPOS_1, EXTPRO_1,
      AMI_1, VALUED_1, AMI_2, FUNCT_7, SCMPDS_1, SCMPDS_2,
      INT_2, SCMPDS_4, XXREAL_0;
 constructors ENUMSET1, XXREAL_0, REAL_1, INT_2, SCMPDS_1, SCMPDS_4,
      PRE_POLY, DOMAIN_1, AMI_1;
 registrations SETFAM_1, FUNCT_1, NUMBERS, XREAL_0, INT_1, AMI_1, SCMPDS_2,
      SCMPDS_4, ORDINAL1, XBOOLE_0, VALUED_1, AFINSQ_1, COMPOS_1, RELAT_1,
      EXTPRO_1;
 requirements NUMERALS, REAL, SUBSET, BOOLE, ARITHM;
 definitions FUNCOP_1, COMPOS_1, AMI_1, SCMPDS_4, NAT_1, AFINSQ_1, EXTPRO_1;
 theorems AMI_1, NAT_1, TARSKI, FUNCT_4, FUNCT_1, INT_1, RELAT_1, SCMPDS_2,
      FUNCT_7, SCMPDS_3, CARD_1, ENUMSET1, ABSVALUE, GRFUNC_1, SCMPDS_4,
      LATTICE2, XBOOLE_0, XBOOLE_1, XREAL_1, ORDINAL1, FUNCOP_1, XXREAL_0,
      AMI_2, VALUED_1, AFINSQ_1, PBOOLE, PARTFUN1, COMPOS_1, EXTPRO_1;
 schemes NAT_1;

begin :: Preliminaries

reserve x for set,
  m,n for Element of NAT,
  a,b,c for Int_position,
  i for Instruction of SCMPDS,
  s,s1,s2 for State of SCMPDS,
  k1,k2 for Integer,
  loc,l1 for Element of NAT,
  I,J for Program of SCMPDS,
  N for with_non-empty_elements set;

canceled;

LL: card Stop SCMPDS = 1 by COMPOS_1:46;

theorem Th2:
  x in dom Load i iff x =  0
proof
  dom Load i = { 0} by FUNCOP_1:19;
  hence thesis by TARSKI:def 1;
end;

theorem Th3:
  loc in dom stop I & (stop I).loc <> halt SCMPDS implies loc in dom I
proof
  assume that
A1: loc in dom (stop I) and
A2: (stop I).loc <> halt SCMPDS;
  set SS=Stop SCMPDS, S2=Shift(SS, card I);
  assume
  not loc in dom I;
  then loc in dom S2 by A1,FUNCT_4:13;
  then loc in {l1+ card I where l1 is Element of NAT : l1 in dom SS} by
VALUED_1:def 12;
  then consider l1 being Element of NAT such that
A3: loc=l1+ card I and
A4: l1 in dom SS;
y:  0 in dom Stop SCMPDS by COMPOS_1:45;
x: (Stop SCMPDS). 0 = halt SCMPDS by AFINSQ_1:38;
  dom SS = { 0} by AFINSQ_1:36,CARD_1:87;
  then l1= 0 by A4,TARSKI:def 1;
  hence contradiction by A2,A3,x,y,AFINSQ_1:def 4;
end;

theorem
  dom Load i = { 0} & (Load i).( 0)=i by FUNCOP_1:19,87;

theorem Th5:
   0 in dom Load i
proof
  dom Load i = { 0} by FUNCOP_1:19;
  hence thesis by TARSKI:def 1;
end;

theorem Th6:
  card Load i = 1
proof
A1: dom Load i = { 0} by FUNCOP_1:19;
  thus card Load i = card dom Load i
    .= 1 by A1,CARD_1:50;
end;

theorem
  card stop I = card I + 1 by LL,AFINSQ_1:20;

theorem Th8:
  card stop Load i = 2
proof
  thus card stop Load i = card (Load i) +1 by LL,AFINSQ_1:20
    .=1+1 by Th6
    .=2;
end;

theorem Th9:
   0 in dom stop Load i &  1 in dom stop Load i
proof
  card stop Load i = 2 by Th8;
  hence thesis by AFINSQ_1:70;
end;

theorem Th10:
  (stop Load i). 0=i & (stop Load i). 1=halt SCMPDS
proof
  set II=Load i;
   0 in dom II by Th5;
  hence (stop II). 0 =II. 0 by AFINSQ_1:def 4
    .=i by FUNCOP_1:87;
y:  0 in dom Stop SCMPDS by COMPOS_1:45;
x: (Stop SCMPDS). 0 = halt SCMPDS by AFINSQ_1:38;
   1 = 0 + card II by Th6;
  hence thesis by x,y,AFINSQ_1:def 4;
end;

theorem Th11:
  x in dom stop Load i iff x= 0 or x= 1
proof
  set pi=stop Load i, A = NAT;
A1: card pi = 2 by Th8;
  hereby
    assume
A2: x in dom pi;
    dom pi c= A by RELAT_1:def 18;
    then reconsider l=x as Element of NAT by A2;
    reconsider n = l as Element of NAT;
    n < 1+1 by A1,A2,AFINSQ_1:70;
    then n <= 1 by NAT_1:13;
    hence x= 0 or x= 1 by NAT_1:26;
  end;
  assume
A3: x= 0 or x= 1;
  per cases by A3;
  suppose
    x= 0;
    hence thesis by A1,AFINSQ_1:70;
  end;
  suppose
    x= 1;
    hence thesis by A1,AFINSQ_1:70;
  end;
end;

theorem
  dom stop Load i = {0,1}
proof
  for x holds (x in dom (stop Load i) iff x= 0 or x= 1) by Th11;
  hence thesis by TARSKI:def 2;
end;

canceled 2;

theorem Th15:
  for I,J being Program of SCMPDS holds I c= stop (I ';' J)
proof
  let I,J be Program of SCMPDS;
  set IS=I ';' (J ';' Stop SCMPDS),
  Ip=stop (I ';' J);
A2: I c= IS by AFINSQ_1:78;
  thus thesis by A2,AFINSQ_1:30;
end;

theorem Th16:
  dom stop I c= dom stop (I ';' J)
proof
  set sI=stop I, sIJ=stop (I ';'J);
A1: card sIJ=card (I ';' J) +1 by LL,AFINSQ_1:20
    .=card I + card J +1 by AFINSQ_1:20
    .=card I + 1 + card J;
  card sI=card I +1 by LL,AFINSQ_1:20;
  then
A2: card sI <= card sIJ by A1,NAT_1:11;
  now
    set A = NAT;
    let x be set;
    assume
A3: x in dom sI;
    dom sI c= A by RELAT_1:def 18;
    then reconsider l=x as Element of NAT by A3;
    reconsider n = l as Element of NAT;
    n < card sI by A3,AFINSQ_1:70;
    then n < card sIJ by A2,XXREAL_0:2;
    hence x in dom sIJ by AFINSQ_1:70;
  end;
  hence thesis by TARSKI:def 3;
end;

theorem Th17:
  for I,J being Program of SCMPDS holds
   stop I +* stop (I ';' J) = stop (I ';' J)
proof
  let I,J be Program of SCMPDS;
  set sI=stop I, IsI=sI, sIJ=stop (I ';' J), IsIJ= sIJ;
  dom sI c= dom sIJ by Th16;
  hence thesis by FUNCT_4:20;
end;

theorem Th18:
  Initialize I c= s implies IC s =  0
proof
A1: IC Initialize I =  0 by COMPOS_1:def 16;
A2: IC SCMPDS in dom Initialize I by COMPOS_1:def 16;
  assume
  Initialize I c= s;
  hence thesis by A1,A2,GRFUNC_1:8;
end;

theorem Th19:
  (Initialize s +* I).a = s.a
proof
I1: s +* Initialize I = Initialize s +* I by COMPOS_1:125;
  not a in dom Initialize I by SCMPDS_4:31;
  hence thesis by I1,FUNCT_4:12;
end;

theorem Th20:
  for s1,s2 being 0-started State of SCMPDS
  for I being parahalting Program of SCMPDS st stop I c= s1 &
  stop I c= s2 & s1,s2 equal_outside NAT
  for k being Element of NAT holds
   Comput(ProgramPart(s1),s1,k),
   Comput(ProgramPart(s2),s2,k) equal_outside NAT &
   CurInstr(ProgramPart (s1),Comput(ProgramPart(s1),s1,k))
    = CurInstr(ProgramPart (s2),Comput(ProgramPart(s2),s2,k))
proof
  let s1,s2 be 0-started State of SCMPDS;
  let I be parahalting Program of SCMPDS;
  set SI=stop I;
  assume that
A1: SI c= s1 and
A2: SI c= s2 and
A3: s1,s2 equal_outside NAT;
  hereby
    let k be Element of NAT;
A6: IC Comput(ProgramPart(s1),s1,k) in dom SI by A1,SCMPDS_4:def 9;
A7: IC Comput(ProgramPart(s2),s2,k) in dom SI by A2,SCMPDS_4:def 9;
    for m being Element of NAT st m < k holds IC(Comput(ProgramPart(s2),s2,m))
in dom
    SI by A2,SCMPDS_4:def 9;
    hence Comput(ProgramPart(s1),s1,k), Comput(ProgramPart(s2),s2,k)
equal_outside NAT by A3,A1,A2,SCMPDS_4:67;
    then
A8: IC Comput(ProgramPart(s1),s1,k) = IC Comput(ProgramPart(s2),s2,k) by
COMPOS_1:24;
    thus CurInstr(ProgramPart s2,Comput(ProgramPart(s2),s2,k))
     = s2.IC Comput(ProgramPart(s2),s2,k) by COMPOS_1:38
      .= SI.IC Comput(ProgramPart(s2),s2,k) by A2,A7,GRFUNC_1:8
      .= s1.IC Comput(ProgramPart(s1),s1,k) by A1,A8,A6,GRFUNC_1:8
      .= CurInstr(ProgramPart s1,Comput(ProgramPart(s1),s1,k))
       by COMPOS_1:38;
  end;
end;

theorem Th21:
  for s1,s2 being 0-started State of SCMPDS
  for I being parahalting Program of SCMPDS st stop I c= s1 &
      stop I c= s2 & s1,s2 equal_outside NAT
  holds LifeSpan(ProgramPart(s1),s1) =
  LifeSpan(ProgramPart(s2),s2) &
  Result(ProgramPart(s1),s1), Result(ProgramPart(s2),s2) equal_outside NAT
proof
  let s1,s2 be 0-started State of SCMPDS;
  let I be parahalting Program of SCMPDS;
  set SI=stop I;
  assume that
A1: SI c= s1 and
A2: SI c= s2 and
A3: s1,s2 equal_outside NAT;
A4: ProgramPart s2 halts_on s2 by A2,SCMPDS_4:def 10;
A5: ProgramPart s1 halts_on s1 by A1,SCMPDS_4:def 10;
A6: now
    let l be Element of NAT;
    assume
A7: CurInstr(ProgramPart s2,Comput(ProgramPart(s2),s2,l)) = halt SCMPDS;
    CurInstr(ProgramPart s1,Comput(ProgramPart(s1),s1,l))
     = CurInstr(ProgramPart (s2),Comput(ProgramPart(s2),s2,l))
     by A1,A2,A3,Th20;
    hence LifeSpan(ProgramPart(s1),s1) <= l by A5,A7,EXTPRO_1:def 14;
  end;
  CurInstr(ProgramPart s2,
Comput(ProgramPart(s2),s2,LifeSpan(ProgramPart(s1),s1)))
   = CurInstr(ProgramPart s1,
   Comput(ProgramPart(s1),s1,LifeSpan(ProgramPart(s1),s1)))
    by A1,A2,A3,Th20
    .= halt SCMPDS by A5,EXTPRO_1:def 14;
  hence LifeSpan(ProgramPart(s1),s1) = LifeSpan(ProgramPart(s2),s2) by A6,A4,
EXTPRO_1:def 14;
   then
A8: Result(ProgramPart(s2),s2) = Comput(ProgramPart(s2),s2,LifeSpan(ProgramPart
(s1),s1)) by A2,EXTPRO_1:23,SCMPDS_4:def 10;
  Result(ProgramPart(s1),s1) = Comput(ProgramPart(s1),s1,LifeSpan(ProgramPart(
s1),s1)) by A1,EXTPRO_1:23,SCMPDS_4:def 10;
  hence thesis by A1,A2,A3,A8,Th20;
end;

theorem Th22:
  for I being Program of SCMPDS holds IC IExec(I,s) =
   IC Result(ProgramPart(Initialize s +* stop I),Initialize s +* stop I)
proof
  let I be Program of SCMPDS;
  set SI=stop I;
A1: dom s = {IC SCMPDS} \/ SCM-Data-Loc \/ NAT by SCMPDS_4:19;
A2: dom (s | NAT) = dom s /\ NAT by RELAT_1:90
    .= NAT by A1,XBOOLE_1:21;
  not IC SCMPDS in dom (s | NAT) by A2,COMPOS_1:3;
  hence thesis by FUNCT_4:12;
end;

theorem Th23:
  for s being 0-started State of SCMPDS
  for I being parahalting Program of SCMPDS, J being Program of
SCMPDS st stop I c= s for m st m <= LifeSpan(ProgramPart(s),s)
holds Comput(ProgramPart(s),s,
  m),Comput(ProgramPart(s+*(I ';' J)),s+*(I ';' J),m) equal_outside NAT
proof
  let s be 0-started State of SCMPDS;
  let I be parahalting Program of SCMPDS, J be Program of SCMPDS;
  set SI=stop I;
  defpred X[Element of NAT] means $1 <= LifeSpan(ProgramPart(s),s) implies
Comput(ProgramPart(s
),s,$1),
  Comput(ProgramPart(s+*(I ';' J)),s+*(I ';' J),$1) equal_outside NAT;
A1: Comput(ProgramPart(s+*(I ';' J)),s+*(I ';' J),0) = s+*(I ';' J) by
EXTPRO_1:3
;
  assume
A2: SI c= s;
  then
A3: ProgramPart s halts_on s by SCMPDS_4:def 10;
A4: for m st X[m] holds X[m+1]
  proof
    dom(I ';' J) = dom I \/ dom Shift(J, card I) by FUNCT_4:def 1;
    then
A5: dom I c= dom(I ';' J) by XBOOLE_1:7;
    let m;
    assume
A6: m <= LifeSpan(ProgramPart(s),s) implies Comput(ProgramPart(s),s,m),Comput(
ProgramPart(s+*(I
';' J)),s+*(I ';' J),
    m) equal_outside NAT;
    assume
A7: m+1 <= LifeSpan(ProgramPart(s),s);
    then
A8: IC (Comput(ProgramPart(s),s,m)) = IC (Comput(ProgramPart(s+*(I ';' J)),s+*(
I ';' J),m)) by A6,COMPOS_1:24,NAT_1:13;
T1: ProgramPart (s+*(I ';' J))
   = ProgramPart Comput(ProgramPart(s+*(I ';' J)),s+*(I ';' J),m) by AMI_1:123;
A9: Comput(ProgramPart(s+*(I ';' J)),s+*(I ';' J),m+1)
 = Following(ProgramPart (s+*(I ';' J)),
 Comput(ProgramPart(s+*(I ';' J)),s+*(I ';' J),m))
    by EXTPRO_1:4
      .= Exec(CurInstr(ProgramPart(s+*(I ';' J)),
      Comput(ProgramPart(s+*(I ';' J)),s+*(I ';' J),m)), Comput(ProgramPart(s+*
(I ';' J)
    ),s+*(I ';' J)
    ,m));
A10: Comput(ProgramPart(s),s,m+1)
 = Following(ProgramPart s,Comput(ProgramPart(s),s,m))
 by EXTPRO_1:4
      .= Exec(CurInstr(ProgramPart(s),Comput(ProgramPart(s),s,m)),
      Comput(ProgramPart(s),s,m));
A11: I ';' J c= Comput(ProgramPart(s+*(I ';' J)),s+*(I ';' J),m) by AMI_1:81
,FUNCT_4:26;
A12: IC Comput(ProgramPart(s),s,m) in dom SI by A2,SCMPDS_4:def 9;
TX: ProgramPart s = ProgramPart Comput(ProgramPart(s),s,m) by AMI_1:123;
Y:  (ProgramPart(s))/.IC Comput(ProgramPart(s),s,m)
 = Comput(ProgramPart(s),s,m).IC Comput(ProgramPart(s),s,m)
    by TX,COMPOS_1:38;
    SI c= Comput(ProgramPart(s),s,m) by A2,AMI_1:81;
    then
A13: CurInstr(ProgramPart s,Comput(ProgramPart(s),s,m)
)
 = SI.IC (Comput(ProgramPart(s),s,m)) by A12,Y,GRFUNC_1:8;
Y:  (ProgramPart(s+*(I ';' J)))/.IC Comput(
ProgramPart(s+*(I ';' J)),s+*(I ';' J),m)
 = Comput(ProgramPart(s+*(I ';' J)),s+*(I ';' J),m).IC Comput(ProgramPart(s+*(I
';' J)),s+*(I ';' J),m) by T1,COMPOS_1:38;
    m < LifeSpan(ProgramPart(s),s) by A7,NAT_1:13;
    then
 SI.IC(Comput(ProgramPart(s),s,m)) <> halt SCMPDS by A3,A13,EXTPRO_1:def 14;
    then
A14: IC Comput(ProgramPart(s),s,m) in dom I by A12,Th3;
    then
XX:  IC(Comput(ProgramPart(s),s,m)) in dom I;
    then CurInstr(ProgramPart(s),Comput(ProgramPart(s),s,m))
    =I.IC (Comput(ProgramPart(s),s,m)) by A13,AFINSQ_1:def 4
      .=(I ';' J).IC(Comput(ProgramPart(s),s,m))
              by XX,AFINSQ_1:def 4
      .= CurInstr(ProgramPart(s+*(I ';' J)),
      Comput(ProgramPart(s+*(I ';' J)),s+*(I ';' J),m))
       by A8,A11,A14,A5,Y,GRFUNC_1:8;
    hence thesis by A6,A7,A10,A9,NAT_1:13,SCMPDS_4:15;
  end;
  Comput(ProgramPart(s),s,0) = s by EXTPRO_1:3;
  then
A15: X[0] by A1,FUNCT_7:132;
  thus for m holds X[m] from NAT_1:sch 1(A15,A4);
end;

theorem Th24:
 for s being 0-started State of SCMPDS
 for I being parahalting Program of SCMPDS, J being Program of SCMPDS
   st stop I c= s
 for m st m <= LifeSpan(ProgramPart(s),s)
 holds Comput(ProgramPart(s),s,m),
  Comput(ProgramPart(s+*stop(I ';' J)), s+*stop(I ';' J),m) equal_outside NAT
proof
  let s be 0-started State of SCMPDS;
  let I be parahalting Program of SCMPDS, J be Program of SCMPDS;
  assume
A1: stop I c= s;
  set sIJ=stop (I ';' J), SS=Stop SCMPDS;
  let m;
  assume
A2: m <= LifeSpan(ProgramPart(s),s);
  s +* sIJ =s +* (I ';' (J ';' SS)) by AFINSQ_1:30;
  hence thesis by A1,A2,Th23;
end;

Lm1: Load (DataLoc(0,0):=0) is parahalting
proof
  set SA0 = Start-At( 0,SCMPDS);
  set ii= DataLoc(0,0):=0, m0= stop Load ii, m1 = Initialize m0;
  let s be 0-started State of SCMPDS such that
A2: m0 c= s;
  take 1;
     IC Comput(ProgramPart(s),s,1) in NAT;
    hence IC Comput(ProgramPart(s),s,1) in dom ProgramPart s by COMPOS_1:34;
A4: IC s =  0 by COMPOS_1:def 16;
  then
A5: IC Exec(ii, s) = succ  0 by SCMPDS_2:57
    .=  (0+1);
   1 in dom m0 by Th9;
  then m0. 1 = s. 1 by A2,GRFUNC_1:8;
  then
A6: s. 1 = halt SCMPDS by Th10;
   0 in dom m0 by Th9;
  then
A7: m0. 0 = s. 0 by A2,GRFUNC_1:8;
Y:  (ProgramPart s)/.IC s = s.IC s by COMPOS_1:38;
  Comput(ProgramPart(s),s,0+1) =
  Following(ProgramPart s,Comput(ProgramPart(s),s,0))
   by EXTPRO_1:4
    .= Following(ProgramPart s,s) by EXTPRO_1:3
    .= Exec(ii,s) by A4,A7,Th10,Y;
  hence thesis by A6,A5,COMPOS_1:38;
end;

begin :: Non halting instrutions and parahalting instrutions

definition
  let i be Instruction of SCMPDS;
  attr i is No-StopCode means
  :Def1:
  i <> halt SCMPDS;
end;

definition
  let i be Instruction of SCMPDS;
  attr i is parahalting means
  :Def2:
  Load i is parahalting;
end;

registration
  cluster No-StopCode shiftable parahalting Instruction of SCMPDS;
  existence
  proof
    take i=DataLoc(0,0):=0;
A1: InsCode halt SCMPDS=0 by SCMPDS_2:21,93;
    InsCode i=2 by SCMPDS_2:23;
    hence thesis by A1,Def1,Def2,Lm1;
  end;
end;

theorem
  k1 <>0 implies goto k1 is No-StopCode
proof
  set i=goto k1;
  assume
A1: k1 <>0;
  assume
  i is not No-StopCode;
  then i=halt SCMPDS by Def1;
  hence contradiction by A1,SCMPDS_2:85;
end;

registration
  let a;
  cluster return a -> No-StopCode;
  coherence
  proof
    set i=return a;
A1: InsCode halt SCMPDS=0 by SCMPDS_2:21,93;
    InsCode i=1 by SCMPDS_2:22;
    hence thesis by A1,Def1;
  end;
end;

registration
  let a,k1;
  cluster a := k1 -> No-StopCode;
  coherence
  proof
    set i=a:=k1;
A1: InsCode halt SCMPDS=0 by SCMPDS_2:21,93;
    InsCode i=2 by SCMPDS_2:23;
    hence thesis by A1,Def1;
  end;
  cluster saveIC(a,k1) -> No-StopCode;
  coherence
  proof
    set i=saveIC(a,k1);
A2: InsCode halt SCMPDS=0 by SCMPDS_2:21,93;
    InsCode i=3 by SCMPDS_2:24;
    hence thesis by A2,Def1;
  end;
end;

registration
  let a,k1,k2;
  cluster (a,k1)<>0_goto k2 -> No-StopCode;
  coherence
  proof
    set i=(a,k1)<>0_goto k2;
A1: InsCode halt SCMPDS=0 by SCMPDS_2:21,93;
    InsCode i=4 by SCMPDS_2:25;
    hence thesis by A1,Def1;
  end;
  cluster (a,k1)<=0_goto k2 -> No-StopCode;
  coherence
  proof
    set i=(a,k1)<=0_goto k2;
A2: InsCode halt SCMPDS=0 by SCMPDS_2:21,93;
    InsCode i=5 by SCMPDS_2:26;
    hence thesis by A2,Def1;
  end;
  cluster (a,k1)>=0_goto k2 -> No-StopCode;
  coherence
  proof
    set i=(a,k1)>=0_goto k2;
A3: InsCode halt SCMPDS=0 by SCMPDS_2:21,93;
    InsCode i=6 by SCMPDS_2:27;
    hence thesis by A3,Def1;
  end;
  cluster (a,k1) := k2 -> No-StopCode;
  coherence
  proof
    set i=(a,k1) := k2;
A4: InsCode halt SCMPDS=0 by SCMPDS_2:21,93;
    InsCode i=7 by SCMPDS_2:28;
    hence thesis by A4,Def1;
  end;
end;

registration
  let a,k1,k2;
  cluster AddTo(a,k1,k2) -> No-StopCode;
  coherence
  proof
    set i=AddTo(a,k1,k2);
A1: InsCode halt SCMPDS=0 by SCMPDS_2:21,93;
    InsCode i=8 by SCMPDS_2:29;
    hence thesis by A1,Def1;
  end;
end;

registration
  let a,b,k1,k2;
  cluster AddTo(a,k1,b,k2) -> No-StopCode;
  coherence
  proof
    set i=AddTo(a,k1,b,k2);
A1: InsCode halt SCMPDS=0 by SCMPDS_2:21,93;
    InsCode i=9 by SCMPDS_2:30;
    hence thesis by A1,Def1;
  end;
  cluster SubFrom(a,k1,b,k2) -> No-StopCode;
  coherence
  proof
    set i=SubFrom(a,k1,b,k2);
A2: InsCode halt SCMPDS=0 by SCMPDS_2:21,93;
    InsCode i=10 by SCMPDS_2:31;
    hence thesis by A2,Def1;
  end;
  cluster MultBy(a,k1,b,k2) -> No-StopCode;
  coherence
  proof
    set i=MultBy(a,k1,b,k2);
A3: InsCode halt SCMPDS=0 by SCMPDS_2:21,93;
    InsCode i=11 by SCMPDS_2:32;
    hence thesis by A3,Def1;
  end;
  cluster Divide(a,k1,b,k2) -> No-StopCode;
  coherence
  proof
    set i=Divide(a,k1,b,k2);
A4: InsCode halt SCMPDS=0 by SCMPDS_2:21,93;
    InsCode i=12 by SCMPDS_2:33;
    hence thesis by A4,Def1;
  end;
  cluster (a,k1) := (b,k2) -> No-StopCode;
  coherence
  proof
    set i=(a,k1) := (b,k2);
A5: InsCode halt SCMPDS=0 by SCMPDS_2:21,93;
    InsCode i=13 by SCMPDS_2:34;
    hence thesis by A5,Def1;
  end;
end;

registration
  cluster halt SCMPDS -> parahalting;
  coherence
  proof
    Stop SCMPDS=Load halt SCMPDS;
    hence thesis by Def2;
  end;
end;

registration
  let i be parahalting Instruction of SCMPDS;
  cluster Load i -> parahalting Program of SCMPDS;
  coherence by Def2;
end;

Lm2: (for s holds Exec(i,s).IC SCMPDS = succ IC s) implies Load i is
parahalting

proof
  set SA0 = Start-At( 0,SCMPDS);
  assume
A1: for s holds Exec(i,s).IC SCMPDS = succ IC s;
  set m0= stop Load i, m1 = Initialize m0;
  let t be 0-started State of SCMPDS such that
A3: m0 c= t;
  take 1;
     IC Comput(ProgramPart(t),t,1) in NAT;
    hence IC Comput(ProgramPart(t),t,1) in dom ProgramPart t by COMPOS_1:34;
A5: IC t =  0 by COMPOS_1:def 16;
  then
A6: IC Exec(i, t) = succ  0 by A1
    .=  (0+1);
   1 in dom m0 by Th9;
  then m0. 1 = t. 1 by A3,GRFUNC_1:8;
  then
A7: t. 1 = halt SCMPDS by Th10;
   0 in dom m0 by Th9;
  then
A8: m0. 0 = t. 0 by A3,GRFUNC_1:8;
V:  (ProgramPart t)/.IC t = t.IC t by COMPOS_1:38;
  Comput(ProgramPart(t),t,0+1)
   = Following(ProgramPart t,Comput(ProgramPart(t),t,0))
   by EXTPRO_1:4
    .= Following(ProgramPart t,t) by EXTPRO_1:3
    .= Exec(i,t) by A5,A8,Th10,V;
  hence thesis by A6,A7,COMPOS_1:38;
end;

registration
  let a,k1;
  cluster a := k1 -> parahalting;
  coherence
  proof
    set i= a:=k1;
    for s holds Exec(i,s).IC SCMPDS = succ IC s by SCMPDS_2:57;
    then Load i is parahalting by Lm2;
    hence thesis by Def2;
  end;
end;

registration
  let a,k1,k2;
  cluster (a,k1) := k2 -> parahalting;
  coherence
  proof
    set i= (a,k1) := k2;
    for s holds Exec(i,s).IC SCMPDS = succ IC s by SCMPDS_2:58;
    then Load i is parahalting by Lm2;
    hence thesis by Def2;
  end;
  cluster AddTo(a,k1,k2) -> parahalting;
  coherence
  proof
    set i= AddTo(a,k1,k2);
    for s holds Exec(i,s).IC SCMPDS = succ IC s by SCMPDS_2:60;
    then Load i is parahalting by Lm2;
    hence thesis by Def2;
  end;
end;

registration
  let a,b,k1,k2;
  cluster AddTo(a,k1,b,k2) -> parahalting;
  coherence
  proof
    set i= AddTo(a,k1,b,k2);
    for s holds Exec(i,s).IC SCMPDS = succ IC s by SCMPDS_2:61;
    then Load i is parahalting by Lm2;
    hence thesis by Def2;
  end;
  cluster SubFrom(a,k1,b,k2) -> parahalting;
  coherence
  proof
    set i= SubFrom(a,k1,b,k2);
    for s holds Exec(i,s).IC SCMPDS = succ IC s by SCMPDS_2:62;
    then Load i is parahalting by Lm2;
    hence thesis by Def2;
  end;
  cluster MultBy(a,k1,b,k2) -> parahalting;
  coherence
  proof
    set i= MultBy(a,k1,b,k2);
    for s holds Exec(i,s).IC SCMPDS = succ IC s by SCMPDS_2:63;
    then Load i is parahalting by Lm2;
    hence thesis by Def2;
  end;
  cluster Divide(a,k1,b,k2) -> parahalting;
  coherence
  proof
    set i= Divide(a,k1,b,k2);
    for s holds Exec(i,s).IC SCMPDS = succ IC s by SCMPDS_2:64;
    then Load i is parahalting by Lm2;
    hence thesis by Def2;
  end;
  cluster (a,k1) := (b,k2) -> parahalting;
  coherence
  proof
    set i= (a,k1) := (b,k2);
    for s holds Exec(i,s).IC SCMPDS = succ IC s by SCMPDS_2:59;
    then Load i is parahalting by Lm2;
    hence thesis by Def2;
  end;
end;

theorem Th26:
  InsCode i =1 implies i is not parahalting
proof
  consider s such that
A1: for a holds s.a = 2 by SCMPDS_2:73;
  assume
  InsCode i=1;
  then consider a such that
A2: i = return a by SCMPDS_2:36;
  assume
  i is parahalting;
  then reconsider Li = Load i as parahalting Program of SCMPDS;
  set pi=stop Li;
  set s1=Initialize s +* pi;
I1: s +* Initialize pi = Initialize s +* pi by COMPOS_1:125;
  s1.DataLoc(s1.a,RetIC)=s.DataLoc(s1.a,RetIC) by Th19
    .=2 by A1;
  then
A3: Exec(i, s1).IC SCMPDS =(abs(2))+2 by A2,SCMPDS_2:70
    .= 2+2 by ABSVALUE:def 1
    .= 4;
  set C1=Comput(ProgramPart(s1),s1,1);
A4: IC C1 in dom pi by FUNCT_4:26,SCMPDS_4:def 9;
   0 in dom pi by Th9;
  then
A5: s1. 0= pi. 0 by FUNCT_4:14
    .=i by Th10;
A6: card pi = 2 by Th8;
Y:  (ProgramPart s1)/.IC s1
 = s1.IC s1 by COMPOS_1:38;
  Comput(ProgramPart(s1),s1,0+1)
   = Following(ProgramPart s1,Comput(ProgramPart(s1),
s1,0))
   by EXTPRO_1:4
    .= Following(ProgramPart s1,s1) by EXTPRO_1:3
    .= Exec(i, s1) by A5,Th18,Y,I1,FUNCT_4:26;
  hence contradiction by A3,A4,A6,AFINSQ_1:70;
end;

definition
  let N be with_non-empty_elements set;
:::  let S be halting (AMI-Struct over N);
  let S be definite (non empty stored-program AMI-Struct over N);
  let IT be  NAT-defined (the Instructions of S)-valued Function;
  redefine attr IT is halt-free means
  :Def3:
  for x being Element of NAT st x in dom IT holds IT.x <> halt S;
  compatibility
   proof
    thus IT is halt-free implies
     for x being Element of NAT
     st x in dom IT holds IT.x <> halt S
     proof assume
Z:     IT is halt-free;
      let x be Element of NAT;
      assume
ZZ:    x in dom IT;
       reconsider n=x as Element of NAT;
       IT.n in rng IT by ZZ,FUNCT_1:12;
      hence IT.x <> halt S by Z,COMPOS_1:def 7;
     end;
    assume
Z:   for x being Element of NAT
     st x in dom IT holds IT.x <> halt S;
    assume halt S in rng IT;
     then consider x such that
W1:   x in dom IT and
W2:   halt S = IT.x by FUNCT_1:def 5;
     dom IT c= NAT by RELAT_1:def 18;
    hence contradiction by W1,W2,Z;
   end;
end;

registration
  cluster parahalting shiftable halt-free Program of SCMPDS;
  existence
  proof
    set ii=DataLoc(0,0):=0;
    take II=Load ii;
    now
      let x be Element of NAT;
      assume
      x in dom II;
      then x in { 0} by FUNCOP_1:19;
      then x= 0 by TARSKI:def 1;
      then
A1:   II.x=ii by FUNCOP_1:87;
      InsCode ii=2 by SCMPDS_2:23;
      hence II.x <> halt SCMPDS by A1,SCMPDS_2:21,93;
    end;
    hence thesis by Def3;
  end;
end;

registration
  let I,J be halt-free Program of SCMPDS;
  cluster I ';' J -> halt-free;
  coherence
  proof
    set IJ=I ';' J;
    now
      set D = {n+card I: n in dom J };
      dom Shift(J,card I) = D by VALUED_1:def 12;
      then
A1:   dom IJ = dom I \/ D by FUNCT_4:def 1;
      let x be Element of NAT such that
A2:   x in dom IJ;
      per cases by A2,A1,XBOOLE_0:def 3;
      suppose
A3:     x in dom I;
        then I.x=IJ.x by AFINSQ_1:def 4;
        hence IJ.x<>halt SCMPDS by A3,Def3;
      end;
      suppose
        x in D;
        then consider n such that
A4:     x = n+card I and
A5:     n in dom J;
        J. n =IJ.x by A4,A5,AFINSQ_1:def 4;
        hence IJ.x<>halt SCMPDS by A5,Def3;
      end;
    end;
    hence thesis by Def3;
  end;
end;

registration
  let i be No-StopCode Instruction of SCMPDS;
  cluster Load i -> halt-free;
  coherence
  proof
    set p=Load i;
    now
      let x be Element of NAT;
      assume
      x in dom p;
      then x =  0 by Th2;
      then p.x=i by FUNCOP_1:87;
      hence p.x <>halt SCMPDS by Def1;
    end;
    hence thesis by Def3;
  end;
end;

registration
  let i be No-StopCode Instruction of SCMPDS, J be halt-free Program of
  SCMPDS;
  cluster i ';' J -> halt-free;
  coherence;
end;

registration
  let I be halt-free Program of SCMPDS, j be No-StopCode Instruction of
  SCMPDS;
  cluster I ';' j -> halt-free;
  coherence;
end;

registration
  let i,j be No-StopCode Instruction of SCMPDS;
  cluster i ';' j -> halt-free;
  coherence;
end;

theorem Th27:
  for s being 0-started State of SCMPDS
  for I being parahalting halt-free Program of SCMPDS st stop I c= s
   holds IC Comput(ProgramPart( s), s,
     LifeSpan(ProgramPart(s +* stop I),s +* stop I))
     =  card I
proof
  let s be 0-started State of SCMPDS;
  let I be parahalting halt-free Program of SCMPDS;
  set Css= Comput(ProgramPart( s), s,LifeSpan(ProgramPart(s),s));
  reconsider n = IC Css as Element of NAT;
  assume
A2: stop I c= s;
  then
A3: ProgramPart s halts_on s by SCMPDS_4:def 10;
X:  s +* stop I = s by A2,FUNCT_4:79;
  I c= stop I by AFINSQ_1:78;
  then
A4: I c= s by A2,XBOOLE_1:1;
  now
    assume
A5: IC Css in dom I;
    then I.IC Css=s.IC Css by A4,GRFUNC_1:8
      .=CurInstr(ProgramPart s,Css) by COMPOS_1:38
      .=halt SCMPDS by A3,EXTPRO_1:def 14;
    hence contradiction by A5,Def3;
  end;
  then
A6: n >= card I by AFINSQ_1:70;
A7: card stop I =card I + 1 by LL,AFINSQ_1:20;
  IC Css in dom stop(I) by A2,SCMPDS_4:def 9;
  then n < card I + 1 by A7,AFINSQ_1:70;
  then n <= card I by NAT_1:13;
  hence thesis by X,A6,XXREAL_0:1;
end;

theorem Th28:
 for s being 0-started State of SCMPDS
  for I being parahalting Program of SCMPDS,k be Element of NAT st
     k < LifeSpan(ProgramPart(s +* stop I),s +* stop I)
holds IC Comput(ProgramPart(s +* stop I),(s +* stop I),k) in dom I
proof let s be 0-started State of SCMPDS;
  let I be parahalting Program of SCMPDS,k be Element of NAT;
  set ss= s +* stop I, m=LifeSpan(ProgramPart(ss),ss);
  set Sk= Comput(ProgramPart( ss), ss,k), Ik=IC Sk;
A1: ProgramPart ss halts_on ss by FUNCT_4:26,SCMPDS_4:def 10;
  reconsider n = Ik as Element of NAT;
A3: Ik in dom stop(I) by FUNCT_4:26,SCMPDS_4:def 9;
A4: stop I c= ss by FUNCT_4:26;
  assume
A5: k < m;
A6: now
    assume
A7: n = card I;
y:  0 in dom Stop SCMPDS by COMPOS_1:45;
x: (Stop SCMPDS). 0 = halt SCMPDS by AFINSQ_1:38;
    CurInstr(ProgramPart ss,Sk) =ss.Ik by COMPOS_1:38
      .=(stop I).(0+n) by A3,A4,GRFUNC_1:8
      .=halt SCMPDS by A7,x,y,AFINSQ_1:def 4;
    hence contradiction by A5,A1,EXTPRO_1:def 14;
  end;
  card stop I=card I + 1 by LL,AFINSQ_1:20;
  then n < card I + 1 by A3,AFINSQ_1:70;
  then n <= card I by INT_1:20;
  then n < card I by A6,XXREAL_0:1;
  hence thesis by AFINSQ_1:70;
end;

theorem Th29:
  for s being 0-started State of SCMPDS
  for I being parahalting Program of SCMPDS,k be Element of NAT st
 I c= s & k <= LifeSpan(ProgramPart(s +* stop I),s +* stop I)
   holds Comput(ProgramPart s, s,k),
      Comput(ProgramPart(s +* stop I),s +* stop I,k) equal_outside NAT
proof
  let s be 0-started State of SCMPDS;
  let I be parahalting Program of SCMPDS,k be Element of NAT;
  set
  m=LifeSpan(ProgramPart(s +* stop I),s +* stop I);
  assume that
A1: I c= s and
A2: k <= m;
  set s2 = s +* stop I;
  defpred P[Element of NAT] means $1 <= m implies Comput(ProgramPart(s),s,$1),
  Comput(ProgramPart(s2),s2,$1) equal_outside NAT;
A4: s = s +* I by A1,FUNCT_4:79;
A5: now
    let k be Element of NAT;
    assume
A6: P[k];
    now
A7:   Comput(ProgramPart(s2),s2,k+1)
 = Following(ProgramPart s2,Comput(ProgramPart(s2),s2,k))
 by EXTPRO_1:4
        .= Exec(CurInstr(ProgramPart(s2),
        Comput(ProgramPart(s2),s2,k)),Comput(ProgramPart(s2),s2,k));
A8:   Comput(ProgramPart(s),s,k+1)
 = Following(ProgramPart s,Comput(ProgramPart(s),s,k))
by EXTPRO_1:4
        .= Exec(CurInstr(ProgramPart(s),Comput(ProgramPart(s),s,k)),
        Comput(ProgramPart(s),s,k));
A9:   k < k+1 by XREAL_1:31;
      assume
A10:  k+1 <= m;
      then
B11:    k < m by A9,XXREAL_0:2;
      then
  IC Comput(ProgramPart(s2),s2,k) in dom I by Th28;
      then
A12:  IC Comput(ProgramPart(s2),s2,k) in dom (stop I) by FUNCT_4:13;
XX:   IC Comput(ProgramPart s2,s2,k) in dom I by B11,Th28;
      IC Comput(ProgramPart(s),s,k) = IC Comput(ProgramPart(s2),s2,k)
        by A6,A10,A9,COMPOS_1:24,XXREAL_0:2;
      then CurInstr(ProgramPart(s),Comput(ProgramPart(s),s,k))
       = s.IC Comput(ProgramPart(s2),s2,k) by COMPOS_1:38
        .= I.IC Comput(ProgramPart(s2),s2,k) by A4,B11,Th28,FUNCT_4:14
        .= (stop I).IC Comput(ProgramPart(s2),s2,k)
             by XX,AFINSQ_1:def 4
        .= (s +* stop I).IC Comput(ProgramPart(s2),s2,k)
         by A12,FUNCT_4:14
        .= CurInstr(ProgramPart(s2),Comput(ProgramPart(s2),s2,k))
         by COMPOS_1:38;
      hence Comput(ProgramPart(s),s,k+1),Comput(ProgramPart(s2),s2,k+1)
equal_outside NAT by A6,A10,A9,A8,A7,SCMPDS_4:15,XXREAL_0:2;
    end;
    hence P[k+1];
  end;
A13: P[0]
  proof
    assume
    0 <= m;
A14: Comput(ProgramPart(s2),s2,0)= s +* stop I by EXTPRO_1:3;
    Comput(ProgramPart(s),s,0)=s by EXTPRO_1:3;
    hence thesis by A14,FUNCT_7:132;
  end;
  for k be Element of NAT holds P[k] from NAT_1:sch 1(A13,A5);
  hence thesis by A2;
end;

theorem Th30:
  for s being 0-started State of SCMPDS
  for I being parahalting halt-free Program of SCMPDS st I c= s
   holds IC Comput(ProgramPart s,s,
    LifeSpan(ProgramPart(s +* stop I),s +* stop I)) =  card I
proof
  let s be 0-started State of SCMPDS;
  let I be parahalting halt-free Program of SCMPDS;
  set ss = s +* stop I, m=LifeSpan(ProgramPart(ss),ss);
A1: stop I c= ss by FUNCT_4:26;
XX: stop I +* ss = ss & ss +* stop I = ss
by A1,FUNCT_4:79;
  assume I c= s;
  hence IC Comput(ProgramPart(s),s,m)
     = IC Comput(ProgramPart( ss), ss,m) by Th29,COMPOS_1:24
    .= card I by Th27,XX,FUNCT_4:26;
end;

theorem Th31:
  for s being 0-started State of SCMPDS
  for I being parahalting Program of SCMPDS st I c= s
  holds CurInstr(ProgramPart s,
   Comput(ProgramPart s, s,LifeSpan(ProgramPart(s +* stop I),
    s +* stop I))) = halt SCMPDS or
   IC Comput(ProgramPart( s), s,
  LifeSpan(ProgramPart(s +* stop I),s +* stop I)) = card I
proof
  let s be 0-started State of SCMPDS;
  let I be parahalting Program of SCMPDS;
  set ss = s +* stop I, m=LifeSpan(ProgramPart(ss),ss);
  set s1=Comput(ProgramPart(s),s,m),
      s2= Comput(ProgramPart( ss), ss,
       LifeSpan(ProgramPart(Initialize ss +* stop I),Initialize ss +* stop I)),
      Ik = IC s2;
A1: ProgramPart ss halts_on ss by FUNCT_4:26,SCMPDS_4:def 10;
  reconsider n = Ik as Element of NAT;
A2: stop I c= ss by FUNCT_4:26;
A3: Ik in dom stop(I) by FUNCT_4:26,SCMPDS_4:def 9;
  Initialize ss = ss by COMPOS_1:79;
  then
XX: Initialize ss +* stop I = ss by A2,FUNCT_4:79;
  card stop I = card I + 1 by LL,AFINSQ_1:20;
  then n < card I + 1 by A3,AFINSQ_1:70;
  then
A4: n <= card I by INT_1:20;
A5: stop I c= ss by FUNCT_4:26;
  assume
A6: I c= s;
  then
A7: IC s1 =Ik by XX,Th29,COMPOS_1:24;
  now
    per cases by A4,XXREAL_0:1;
    case
      n < card I;
      then
A9:    n in dom I by AFINSQ_1:70;
      thus halt SCMPDS
        = CurInstr(ProgramPart ss,s2) by XX,A1,EXTPRO_1:def 14
        .=ss.Ik by COMPOS_1:38
        .=(stop I).Ik by A3,A5,GRFUNC_1:8
        .=I.Ik by A9,AFINSQ_1:def 4
        .=s.IC s1 by A6,A7,A9,GRFUNC_1:8
        .=CurInstr(ProgramPart s,s1) by COMPOS_1:38;
    end;
    case
      n = card I;
      hence IC s1=  card I by A6,XX,Th29,COMPOS_1:24;
    end;
  end;
  hence thesis;
end;

theorem Th32:
  for s being 0-started State of SCMPDS
  for I being parahalting halt-free Program of SCMPDS,k being Element of NAT
   st I c= s & k < LifeSpan(ProgramPart(s +* stop I),s +* stop I)
  holds CurInstr(ProgramPart(s),Comput(ProgramPart(s),s,k)) <> halt SCMPDS
proof
  let s be 0-started State of SCMPDS;
  let I be parahalting halt-free Program of SCMPDS,k be Element of NAT;
  set sI=s +* stop(I), s1= Comput(ProgramPart( s), s,k),
      s2= Comput(ProgramPart( sI), sI,k);
  assume that
A1: I c= s and
A2: k < LifeSpan(ProgramPart(sI),sI);
A3: I c= s1 by A1,AMI_1:81;
A4: IC s2 in dom I by A2,Th28;
TT: ProgramPart s1 = ProgramPart s by AMI_1:123;
Y:  (ProgramPart s)/.IC s1 = s1.IC s1 by TT,COMPOS_1:38;
  CurInstr(ProgramPart s,s1)=s1.IC s2 by A1,A2,Th29,Y,COMPOS_1:24
    .=I.IC s2 by A3,A4,GRFUNC_1:8;
  hence thesis by A4,Def3,TT;
end;

theorem Th33:
  for I being parahalting Program of SCMPDS,J being Program of
  SCMPDS, k being Element of NAT st k <= LifeSpan(
  ProgramPart(Initialize s +* stop(I)),Initialize s +* stop(I))
holds Comput(ProgramPart( (Initialize s +* stop I )), (Initialize s +* stop I
),k), Comput(ProgramPart( (s +* ((I ';' J)
  +* Start-At( 0,SCMPDS)))), (s +* ((I ';' J)
  +* Start-At( 0,SCMPDS))),k) equal_outside NAT
proof
  let I be parahalting Program of SCMPDS,J be Program of SCMPDS, k be Element
  of NAT;
  set SA0=Start-At( 0,SCMPDS), spI= stop I;
  set s1 = Initialize s +* spI;
  set s2 = s +* ((I ';' J) +* SA0);
  set n=LifeSpan(ProgramPart(s1),s1);
  defpred X[Element of NAT] means $1 <= n implies Comput(ProgramPart(s1),s1,$1)
,
  Comput(ProgramPart(s2),s2,$1) equal_outside NAT;
A2: s2 = Initialize(s +* (I ';' J)) by FUNCT_4:15
    .= Initialize s+*(I ';' J) by COMPOS_1:83;
A4: for n being Element of NAT st X[n] holds X[n+1]
  proof
    let m be Element of NAT;
    assume
A5: m <= n implies Comput(ProgramPart(s1),s1,m), Comput(ProgramPart(s2),s2,m)
equal_outside
    NAT;
A6: Comput(ProgramPart(s2),s2,m+1)
 = Following(ProgramPart s2,Comput(ProgramPart(s2),s2
,m))
 by EXTPRO_1:4
      .= Exec(CurInstr(ProgramPart(s2),Comput(ProgramPart(s2),s2,m)),
      Comput(ProgramPart(s2),s2,m));
A7: IC Comput(ProgramPart(s1),s1,m) in dom spI by FUNCT_4:26,SCMPDS_4:def 9;
A8: Comput(ProgramPart(s1),s1,m+1) = Following(ProgramPart s1,
Comput(ProgramPart(s1),s1,m)) by EXTPRO_1:4
      .= Exec(CurInstr(ProgramPart(s1),Comput(ProgramPart(s1),s1,m)),
      Comput(ProgramPart(s1),s1,m));
    assume
A9: m+1 <= n;
    then
A10: IC Comput(ProgramPart(s1),s1,m) = IC Comput(ProgramPart(s2),s2,m) by A5,
COMPOS_1:24,NAT_1:13;
B11:  m < n by A9,NAT_1:13;
    then
 IC Comput(ProgramPart(s1),s1,m) in dom I by Th28;
    then
A12: IC Comput(ProgramPart(s1),s1,m) in dom (I ';' J) by FUNCT_4:13;
XX:   IC Comput(ProgramPart s1,s1,m) in dom I by B11,Th28;
    CurInstr(ProgramPart(s1),Comput(ProgramPart(s1),s1,m))
     = s1.IC Comput(ProgramPart(s1),s1,m) by COMPOS_1:38
      .= spI.IC Comput(ProgramPart(s1),s1,m) by A7,FUNCT_4:14
      .= I.IC Comput(ProgramPart(s1),s1,m) by XX,AFINSQ_1:def 4
      .= (I ';' J).IC Comput(ProgramPart(s1),s1,m)
            by XX,AFINSQ_1:def 4
      .= s2.IC Comput(ProgramPart(s1),s1,m) by A2,A12,FUNCT_4:14
      .=CurInstr(ProgramPart(s2),Comput(ProgramPart(s2),s2,m))
       by A10,COMPOS_1:38;
    hence thesis by A5,A9,A8,A6,NAT_1:13,SCMPDS_4:15;
  end;
A13: Comput(ProgramPart(s2),s2,0) = s2 by EXTPRO_1:3;
A14: Comput(ProgramPart(s1),s1,0) = s1 by EXTPRO_1:3;
A15: s +* SA0, s +* SA0 +* (I ';' J) equal_outside NAT by FUNCT_7:132;
  s +* SA0 +* spI, s +* SA0 equal_outside NAT by FUNCT_7:28,132;
  then
A16: X[0] by A2,A15,A14,A13,FUNCT_7:29;
A17: for k being Element of NAT holds X[k] from NAT_1:sch 1(A16, A4);
  assume
  k <= n;
  hence thesis by A17;
end;

theorem Th34:
  for s being 0-started State of SCMPDS
  for I being parahalting Program of SCMPDS,J being Program of SCMPDS,
      k being Element of NAT st
   k <= LifeSpan(ProgramPart(s +* stop I),s +* stop I)
  holds Comput(ProgramPart(s +* stop I), s +* stop I,k),
  Comput(ProgramPart(s +* stop (I ';' J)),s +* stop (I ';' J),k)
     equal_outside NAT
proof
  let s be 0-started State of SCMPDS;
  let I be parahalting Program of SCMPDS,J be Program of SCMPDS, k be Element
  of NAT;
A1: stop (I ';' J) = (I ';' (J ';' Stop SCMPDS)) by AFINSQ_1:30;
AA: s = Initialize s by COMPOS_1:78;
I2: Initialize s +* stop (I ';' J) = s +* Initialize stop (I ';' J)
by COMPOS_1:125;
  assume
  k <= LifeSpan(ProgramPart(s +* stop I),s +* stop I);
  hence thesis by A1,Th33,I2,AA;
end;

registration
  let I be parahalting Program of SCMPDS, J be parahalting shiftable Program
  of SCMPDS;
  cluster I ';' J -> parahalting Program of SCMPDS;
  coherence
  proof
    let p be Program of SCMPDS such that
Z:   p = I ';' J;
    let s be 0-started State of SCMPDS;
    set sIJ = stop p;
    set spJ = stop J, s1 = Initialize s +* stop(I), m1
    = LifeSpan(ProgramPart(s1),s1),
    s3 = Initialize Comput(ProgramPart( s1), s1,m1) +* spJ,
    m3 = LifeSpan(ProgramPart s3,s3),
    D = SCM-Data-Loc;
A1: DataPart s3 = DataPart Initialize Comput(ProgramPart( s1), s1,m1) +*
DataPart spJ by FUNCT_4:75;
A2: now
      let x be set;
      assume x in dom DataPart spJ;
      then
A3:   x in dom spJ /\ D by RELAT_1:90,SCMPDS_2:100;
A5:   x in D by A3,XBOOLE_0:def 4;
      per cases by A3,XBOOLE_0:def 4;
      suppose
A6:     x in dom spJ;
        dom spJ c= NAT by RELAT_1:def 18;
        then reconsider l=x as Element of NAT by A6;
        (DataPart spJ).l =
        (DataPart Initialize Comput(ProgramPart( s1), s1,m1)).l
        by A5,SCMPDS_4:22;
        hence (DataPart spJ).x =
        (DataPart Initialize Comput(ProgramPart( s1), s1,m1)).x;
      end;
      suppose
        x = IC SCMPDS;
        hence (DataPart spJ).x =
        (DataPart Initialize Comput(ProgramPart( s1), s1,m1)).x
by A3,SCMPDS_3:6,XBOOLE_0:def 4;
      end;
    end;
A7: dom (DataPart spJ) = dom spJ /\ D
by RELAT_1:90,SCMPDS_2:100;
A8: spJ c= s3 by FUNCT_4:26;
A9: ProgramPart s3 halts_on s3 by FUNCT_4:26,SCMPDS_4:def 10;
    dom spJ c= dom s3 by A8,GRFUNC_1:8;
    then dom spJ c= the carrier of SCMPDS by PARTFUN1:def 4;
    then dom (DataPart spJ) c= (the carrier of SCMPDS) /\ D
    by A7,XBOOLE_1:26;
    then dom (DataPart spJ) c=
    dom (Initialize Comput(ProgramPart( s1), s1,m1)) /\ D by PARTFUN1:def 4;
    then dom (DataPart spJ) c=
    dom (DataPart Initialize Comput(ProgramPart( s1), s1,m1))
by RELAT_1:90,SCMPDS_2:100;
    then
WW:     DataPart spJ c=
    DataPart Initialize
    Comput(ProgramPart( s1), s1,m1) by A2,GRFUNC_1:8;

A10: DataPart Comput(ProgramPart(s1),s1,m1)
  =DataPart Initialize
Comput(ProgramPart(s1),s1,m1) by COMPOS_1:80
 .= DataPart s3
     by A1,WW,LATTICE2:8;
A11: I c= sIJ by Z,Th15;
    set s4 = Comput(ProgramPart(s),s,m1);
UU: ProgramPart s4 = ProgramPart s by AMI_1:123;
I1: Initialize s +* sIJ = s +* Initialize sIJ by COMPOS_1:125;
    assume
A12: sIJ c= s;
AA: s = Initialize s by COMPOS_1:78;
    s = Initialize s +* sIJ by A12,AA,FUNCT_4:79
      .= s +* ((I ';' (J ';' Stop SCMPDS)) +* Start-At( 0,SCMPDS))
       by Z,I1,AFINSQ_1:30;
    then s4, Comput(ProgramPart(s1),s1,m1) equal_outside NAT
     by Th33,FUNCT_7:28;

    then
A14: DataPart s4 = DataPart s3 by A10,COMPOS_1:138;
    per cases by A12,A11,Th31,AA,XBOOLE_1:1;
    suppose
A15:  CurInstr(ProgramPart s,s4) = halt SCMPDS;
      take m1;
     IC Comput(ProgramPart(s),s,m1) in NAT;
    hence IC Comput(ProgramPart(s),s,m1) in dom ProgramPart s by COMPOS_1:34;
  thus thesis by A15;
    end;
    suppose
A16:  IC s4 =  card I;
      reconsider m = m1 + m3 as Element of NAT;
      take m;
     IC Comput(ProgramPart(s),s,m) in NAT;
    hence IC Comput(ProgramPart(s),s,m) in dom ProgramPart s by COMPOS_1:34;
x: Comput(ProgramPart(s),s,m1+m3)
 = Comput(ProgramPart(s),Comput(ProgramPart(s),s,m1),m3) by EXTPRO_1:5;
      sIJ = I ';' (J ';' Stop SCMPDS) by Z,AFINSQ_1:30
        .= I +* Shift(spJ, card I);
      then Shift(spJ, card I) c= sIJ by FUNCT_4:26;
      then Shift(spJ, card I) c= s by A12,XBOOLE_1:1;
      then
AA:    Shift(spJ, card I) c= s4 by AMI_1:81;
   CurInstr(ProgramPart(s3),Comput(ProgramPart(s3),s3,m3))
 = CurInstr(ProgramPart(s),Comput(ProgramPart(s),s,m1+m3))
      by x,A8,A14,A16,UU,AA,SCMPDS_4:84;
  hence thesis by A9,EXTPRO_1:def 14;
    end;
  end;
end;

registration
  let i be parahalting Instruction of SCMPDS, J be parahalting shiftable
  Program of SCMPDS;
  cluster i ';' J -> parahalting;
  coherence;
end;

registration
  let I be parahalting Program of SCMPDS, j be parahalting shiftable
  Instruction of SCMPDS;
  cluster I ';' j -> parahalting;
  coherence;
end;

registration
  let i be parahalting Instruction of SCMPDS, j be parahalting shiftable
  Instruction of SCMPDS;
  cluster i ';' j -> parahalting;
  coherence;
end;

theorem Th35:
  for s being State of SCMPDS, s1 being 0-started State of SCMPDS,
      J being parahalting shiftable Program of SCMPDS
    st s = Comput(ProgramPart(s1+*stop J),
   s1+* stop J,m) holds
    Exec(CurInstr(ProgramPart s,s),s +* Start-At(IC s + n,SCMPDS))
  = Following(ProgramPart s,s) +*
    Start-At (IC Following(ProgramPart s,s) + n,SCMPDS)
proof
  let s be State of SCMPDS, s1 be 0-started State of SCMPDS,
      J be parahalting shiftable Program of SCMPDS;
  set pJ=stop J, IsJ=Initialize pJ, s2=s1+*pJ;
  set i = CurInstr(ProgramPart s,s), ss=s +* Start-At(IC s + n,SCMPDS);
  reconsider k = IC s as Element of NAT;
  reconsider Nl=succ IC s as Element of NAT;
A1: succ IC ss = (k + n + 1) by FUNCT_4:121
    .= IC (Exec(i, s) +*Start-At (Nl + n,SCMPDS)) by FUNCT_4:121;
  assume
A3: s=Comput(ProgramPart(s2),s2,m);
  then
A4: IC s in dom pJ by FUNCT_4:26,SCMPDS_4:def 9;
  reconsider n1 = IC s as Element of NAT;
  set IEn=IC Exec(i,s)+n;
A5: IC ss = IC s + n by FUNCT_4:121;
A6: now
    let d be Element of NAT;
    thus Exec(i, ss).d = ss.d by AMI_1:def 13
      .= s.d by COMPOS_1:20
      .= Exec(i, s).d by AMI_1:def 13
      .= (Exec(i, s) +* Start-At(IEn,SCMPDS)).d by COMPOS_1:20;
  end;
Y:  (ProgramPart s)/.IC s
 = s.IC s by COMPOS_1:38;
  pJ c= s by A3,AMI_1:81,FUNCT_4:26;
  then
A7: i=pJ.( n1) by A4,Y,GRFUNC_1:8;
  then
A8: InsCode i <> 1 by A4,SCMPDS_4:def 12;
A9: i valid_at n1 by A4,A7,SCMPDS_4:def 12;
A10: InsCode i <> 3 by A4,A7,SCMPDS_4:def 12;
  per cases by A8,A10,NAT_1:38,SCMPDS_2:15;
  suppose
    InsCode i = 0;
    then consider k1 such that
A12: i = goto k1 and
A13: n1+k1 >= 0 by A9,SCMPDS_4:def 11;
A14: IC Exec(i,s) =ICplusConst(s,k1) by A12,SCMPDS_2:66;
A15: now
      let b;
      thus Exec(i, ss).b= ss.b by A12,SCMPDS_2:66
        .= s.b by SCMPDS_3:14
        .= Exec(i, s).b by A12,SCMPDS_2:66
        .= (Exec(i, s) +* Start-At(IEn,SCMPDS)).b by SCMPDS_3:14;
    end;
    IC Exec(i, ss) =ICplusConst(ss,k1) by A12,SCMPDS_2:66
      .=IEn by A5,A13,A14,SCMPDS_4:82
      .= IC (Exec(i, s) +* Start-At(IEn,SCMPDS)) by FUNCT_4:121;
    hence thesis by A6,A15,SCMPDS_2:54;
  end;
  suppose
    InsCode i = 2;
    then consider a,k1 such that
A16: i = a := k1 by SCMPDS_2:37;
A17: now
      let b;
      per cases;
      suppose
A18:    a = b;
        hence Exec(i, ss).b = k1 by A16,SCMPDS_2:57
          .= Exec(i,s).b by A16,A18,SCMPDS_2:57
          .= (Exec(i, s) +* Start-At(IEn,SCMPDS)).b by SCMPDS_3:14;
      end;
      suppose
A19:    a <> b;
        hence Exec(i, ss).b = ss.b by A16,SCMPDS_2:57
          .= s.b by SCMPDS_3:14
          .= Exec(i, s).b by A16,A19,SCMPDS_2:57
          .= (Exec(i, s) +* Start-At(IEn,SCMPDS)).b by SCMPDS_3:14;
      end;
    end;
    IC Exec(i, s) = Nl by A16,SCMPDS_2:57;
    then IC Exec(i, ss) = IC (Exec(i, s) +* Start-At(IEn,SCMPDS))
    by A1,A16,SCMPDS_2:57
;
    hence thesis by A6,A17,SCMPDS_2:54;
  end;
  suppose
    InsCode i = 4;
    then consider a,k1,k2 such that
A20: i = (a,k1)<>0_goto k2 and
A21: n1+k2 >= 0 by A9,SCMPDS_4:def 11;
A22: now
      per cases;
      suppose
A23:    s.DataLoc(s.a,k1) <> 0;
        then
A24:    IC Exec(i,s) =ICplusConst(s,k2) by A20,SCMPDS_2:67;
        ss.DataLoc(s.a,k1) <> 0 by A23,SCMPDS_3:14;
        then ss.DataLoc(ss.a,k1) <> 0 by SCMPDS_3:14;
        hence IC Exec(i, ss) =ICplusConst(ss,k2) by A20,SCMPDS_2:67
          .=IEn by A5,A21,A24,SCMPDS_4:82
          .= IC (Exec(i, s) +* Start-At(IEn,SCMPDS)) by FUNCT_4:121;
      end;
      suppose
A25:    s.DataLoc(s.a,k1) = 0;
        then ss.DataLoc(s.a,k1) = 0 by SCMPDS_3:14;
        then
A26:    ss.DataLoc(ss.a,k1) = 0 by SCMPDS_3:14;
        IC Exec(i, s) = Nl by A20,A25,SCMPDS_2:67;
        hence IC Exec(i,ss) = IC (Exec(i, s) +* Start-At(IEn,SCMPDS))
        by A1,A20,A26,SCMPDS_2:67;
      end;
    end;
    now
      let b;
      thus Exec(i, ss).b= ss.b by A20,SCMPDS_2:67
        .= s.b by SCMPDS_3:14
        .= Exec(i, s).b by A20,SCMPDS_2:67
        .= (Exec(i, s) +* Start-At(IEn,SCMPDS)).b by SCMPDS_3:14;
    end;
    hence thesis by A6,A22,SCMPDS_2:54;
  end;
  suppose
    InsCode i = 5;
    then consider a,k1,k2 such that
A27: i = (a,k1)<=0_goto k2 and
A28: n1+k2 >= 0 by A9,SCMPDS_4:def 11;
A29: now
      per cases;
      suppose
A30:    s.DataLoc(s.a,k1) <= 0;
        then
A31:    IC Exec(i,s) =ICplusConst(s,k2) by A27,SCMPDS_2:68;
        ss.DataLoc(s.a,k1) <= 0 by A30,SCMPDS_3:14;
        then ss.DataLoc(ss.a,k1) <= 0 by SCMPDS_3:14;
        hence IC Exec(i, ss) =ICplusConst(ss,k2) by A27,SCMPDS_2:68
          .=IEn by A5,A28,A31,SCMPDS_4:82
          .= IC (Exec(i, s) +* Start-At(IEn,SCMPDS)) by FUNCT_4:121;
      end;
      suppose
A32:    s.DataLoc(s.a,k1) > 0;
        then ss.DataLoc(s.a,k1) > 0 by SCMPDS_3:14;
        then
A33:    ss.DataLoc(ss.a,k1) > 0 by SCMPDS_3:14;
        IC Exec(i, s) = Nl by A27,A32,SCMPDS_2:68;
        hence IC Exec(i,ss) = IC (Exec(i, s) +* Start-At(IEn,SCMPDS))
        by A1,A27,A33,SCMPDS_2:68;
      end;
    end;
    now
      let b;
      thus Exec(i, ss).b= ss.b by A27,SCMPDS_2:68
        .= s.b by SCMPDS_3:14
        .= Exec(i, s).b by A27,SCMPDS_2:68
        .= (Exec(i, s) +* Start-At(IEn,SCMPDS)).b by SCMPDS_3:14;
    end;
    hence thesis by A6,A29,SCMPDS_2:54;
  end;
  suppose
    InsCode i = 6;
    then consider a,k1,k2 such that
A34: i = (a,k1)>=0_goto k2 and
A35: n1+k2 >= 0 by A9,SCMPDS_4:def 11;
A36: now
      per cases;
      suppose
A37:    s.DataLoc(s.a,k1) >= 0;
        then
A38:    IC Exec(i,s) =ICplusConst(s,k2) by A34,SCMPDS_2:69;
        ss.DataLoc(s.a,k1) >= 0 by A37,SCMPDS_3:14;
        then ss.DataLoc(ss.a,k1) >= 0 by SCMPDS_3:14;
        hence IC Exec(i, ss) =ICplusConst(ss,k2) by A34,SCMPDS_2:69
          .=IEn by A5,A35,A38,SCMPDS_4:82
          .= IC (Exec(i, s) +* Start-At(IEn,SCMPDS)) by FUNCT_4:121;
      end;
      suppose
A39:    s.DataLoc(s.a,k1) < 0;
        then ss.DataLoc(s.a,k1) < 0 by SCMPDS_3:14;
        then
A40:    ss.DataLoc(ss.a,k1) < 0 by SCMPDS_3:14;
        IC Exec(i, s) = Nl by A34,A39,SCMPDS_2:69;
        hence IC Exec(i,ss) = IC (Exec(i, s) +* Start-At(IEn,SCMPDS))
        by A1,A34,A40,SCMPDS_2:69;
      end;
    end;
    now
      let b;
      thus Exec(i, ss).b= ss.b by A34,SCMPDS_2:69
        .= s.b by SCMPDS_3:14
        .= Exec(i, s).b by A34,SCMPDS_2:69
        .= (Exec(i, s) +* Start-At(IEn,SCMPDS)).b by SCMPDS_3:14;
    end;
    hence thesis by A6,A36,SCMPDS_2:54;
  end;
  suppose
    InsCode i = 7;
    then consider a,k1,k2 such that
A41: i = (a,k1) := k2 by SCMPDS_2:42;
A42: now
      let b;
      per cases;
      suppose
A43:    DataLoc(ss.a,k1) = b;
        then
A44:    DataLoc(s.a,k1) = b by SCMPDS_3:14;
        thus Exec(i, ss).b = k2 by A41,A43,SCMPDS_2:58
          .= Exec(i,s).b by A41,A44,SCMPDS_2:58
          .= (Exec(i, s) +* Start-At(IEn,SCMPDS)).b by SCMPDS_3:14;
      end;
      suppose
A45:    DataLoc(ss.a,k1) <> b;
        then
A46:    DataLoc(s.a,k1) <> b by SCMPDS_3:14;
        thus Exec(i, ss).b = ss.b by A41,A45,SCMPDS_2:58
          .= s.b by SCMPDS_3:14
          .= Exec(i, s).b by A41,A46,SCMPDS_2:58
          .= (Exec(i, s) +* Start-At(IEn,SCMPDS)).b by SCMPDS_3:14;
      end;
    end;
    IC Exec(i, s) = Nl by A41,SCMPDS_2:58;
    then IC Exec(i, ss) = IC (Exec(i, s) +* Start-At(IEn,SCMPDS))
    by A1,A41,SCMPDS_2:58;
    hence thesis by A6,A42,SCMPDS_2:54;
  end;
  suppose
    InsCode i = 8;
    then consider a,k1,k2 such that
A47: i = AddTo(a,k1,k2) by SCMPDS_2:43;
A48: now
      let b;
      per cases;
      suppose
A49:    DataLoc(ss.a,k1) = b;
        then
A50:    DataLoc(s.a,k1) = b by SCMPDS_3:14;
        thus Exec(i, ss).b = ss.b + k2 by A47,A49,SCMPDS_2:60
          .= s.b + k2 by SCMPDS_3:14
          .= Exec(i, s).b by A47,A50,SCMPDS_2:60
          .= (Exec(i, s) +* Start-At(IEn,SCMPDS)).b by SCMPDS_3:14;
      end;
      suppose
A51:    DataLoc(ss.a,k1) <> b;
        then
A52:    DataLoc(s.a,k1) <> b by SCMPDS_3:14;
        thus Exec(i, ss).b = ss.b by A47,A51,SCMPDS_2:60
          .= s.b by SCMPDS_3:14
          .= Exec(i, s).b by A47,A52,SCMPDS_2:60
          .= (Exec(i, s) +* Start-At(IEn,SCMPDS)).b by SCMPDS_3:14;
      end;
    end;
    IC Exec(i, s) = Nl by A47,SCMPDS_2:60;
    then IC Exec(i, ss) = IC (Exec(i, s) +* Start-At(IEn,SCMPDS))
    by A1,A47,SCMPDS_2:60
;
    hence thesis by A6,A48,SCMPDS_2:54;
  end;
  suppose
    InsCode i = 9;
    then consider a,b,k1,k2 such that
A53: i = AddTo(a,k1,b,k2) by SCMPDS_2:44;
A54: now
      let c;
      per cases;
      suppose
A55:    DataLoc(ss.a,k1) = c;
        then
A56:    DataLoc(s.a,k1) = c by SCMPDS_3:14;
A57:    ss.DataLoc(ss.b,k2) =s.DataLoc(ss.b,k2) by SCMPDS_3:14
          .=s.DataLoc(s.b,k2) by SCMPDS_3:14;
        ss.DataLoc(ss.a,k1) =s.DataLoc(ss.a,k1) by SCMPDS_3:14
          .=s.DataLoc(s.a,k1) by SCMPDS_3:14;
        hence
        Exec(i, ss).c = s.DataLoc(s.a,k1) + s.DataLoc(s.b,k2) by A53,A55,A57,
SCMPDS_2:61
          .= Exec(i, s).c by A53,A56,SCMPDS_2:61
          .= (Exec(i, s) +* Start-At(IEn,SCMPDS)).c by SCMPDS_3:14;
      end;
      suppose
A58:    DataLoc(ss.a,k1) <> c;
        then
A59:    DataLoc(s.a,k1) <> c by SCMPDS_3:14;
        thus Exec(i, ss).c = ss.c by A53,A58,SCMPDS_2:61
          .= s.c by SCMPDS_3:14
          .= Exec(i, s).c by A53,A59,SCMPDS_2:61
          .= (Exec(i, s) +* Start-At(IEn,SCMPDS)).c by SCMPDS_3:14;
      end;
    end;
    IC Exec(i, s) = Nl by A53,SCMPDS_2:61;
    then IC Exec(i, ss) = IC (Exec(i, s) +* Start-At(IEn,SCMPDS))
    by A1,A53,SCMPDS_2:61
;
    hence thesis by A6,A54,SCMPDS_2:54;
  end;
  suppose
    InsCode i = 10;
    then consider a,b,k1,k2 such that
A60: i = SubFrom(a,k1,b,k2) by SCMPDS_2:45;
A61: now
      let c;
      per cases;
      suppose
A62:    DataLoc(ss.a,k1) = c;
        then
A63:    DataLoc(s.a,k1) = c by SCMPDS_3:14;
A64:    ss.DataLoc(ss.b,k2) =s.DataLoc(ss.b,k2) by SCMPDS_3:14
          .=s.DataLoc(s.b,k2) by SCMPDS_3:14;
        ss.DataLoc(ss.a,k1) =s.DataLoc(ss.a,k1) by SCMPDS_3:14
          .=s.DataLoc(s.a,k1) by SCMPDS_3:14;
        hence
        Exec(i, ss).c = s.DataLoc(s.a,k1) - s.DataLoc(s.b,k2) by A60,A62,A64,
SCMPDS_2:62
          .= Exec(i, s).c by A60,A63,SCMPDS_2:62
          .= (Exec(i, s) +* Start-At(IEn,SCMPDS)).c by SCMPDS_3:14;
      end;
      suppose
A65:    DataLoc(ss.a,k1) <> c;
        then
A66:    DataLoc(s.a,k1) <> c by SCMPDS_3:14;
        thus Exec(i, ss).c = ss.c by A60,A65,SCMPDS_2:62
          .= s.c by SCMPDS_3:14
          .= Exec(i, s).c by A60,A66,SCMPDS_2:62
          .= (Exec(i, s) +* Start-At(IEn,SCMPDS)).c by SCMPDS_3:14;
      end;
    end;
    IC Exec(i, s) = Nl by A60,SCMPDS_2:62;
    then IC Exec(i, ss) = IC (Exec(i, s) +* Start-At(IEn,SCMPDS))
    by A1,A60,SCMPDS_2:62
;
    hence thesis by A6,A61,SCMPDS_2:54;
  end;
  suppose
    InsCode i = 11;
    then consider a,b,k1,k2 such that
A67: i = MultBy(a,k1,b,k2) by SCMPDS_2:46;
A68: now
      let c;
      per cases;
      suppose
A69:    DataLoc(ss.a,k1) = c;
        then
A70:    DataLoc(s.a,k1) = c by SCMPDS_3:14;
A71:    ss.DataLoc(ss.b,k2) =s.DataLoc(ss.b,k2) by SCMPDS_3:14
          .=s.DataLoc(s.b,k2) by SCMPDS_3:14;
        ss.DataLoc(ss.a,k1) =s.DataLoc(ss.a,k1) by SCMPDS_3:14
          .=s.DataLoc(s.a,k1) by SCMPDS_3:14;
        hence Exec(i, ss).c = s.DataLoc(s.a,k1) * s.DataLoc(s.b,k2) by A67,A69
,A71,SCMPDS_2:63
          .= Exec(i, s).c by A67,A70,SCMPDS_2:63
          .= (Exec(i, s) +* Start-At(IEn,SCMPDS)).c by SCMPDS_3:14;
      end;
      suppose
A72:    DataLoc(ss.a,k1) <> c;
        then
A73:    DataLoc(s.a,k1) <> c by SCMPDS_3:14;
        thus Exec(i, ss).c = ss.c by A67,A72,SCMPDS_2:63
          .= s.c by SCMPDS_3:14
          .= Exec(i, s).c by A67,A73,SCMPDS_2:63
          .= (Exec(i, s) +* Start-At(IEn,SCMPDS)).c by SCMPDS_3:14;
      end;
    end;
    IC Exec(i, s) = Nl by A67,SCMPDS_2:63;
    then IC Exec(i, ss) = IC (Exec(i, s) +* Start-At(IEn,SCMPDS))
    by A1,A67,SCMPDS_2:63
;
    hence thesis by A6,A68,SCMPDS_2:54;
  end;
  suppose
    InsCode i = 12;
    then consider a,b,k1,k2 such that
A74: i = Divide(a,k1,b,k2) by SCMPDS_2:47;
A75: now
      let c;
A76:  ss.DataLoc(ss.a,k1) =s.DataLoc(ss.a,k1) by SCMPDS_3:14
        .=s.DataLoc(s.a,k1) by SCMPDS_3:14;
A77:  ss.DataLoc(ss.b,k2) =s.DataLoc(ss.b,k2) by SCMPDS_3:14
        .=s.DataLoc(s.b,k2) by SCMPDS_3:14;
      per cases;
      suppose
A78:    DataLoc(ss.b,k2) = c;
        then
A79:    DataLoc(s.b,k2) = c by SCMPDS_3:14;
        thus Exec(i, ss).c = s.DataLoc(s.a,k1) mod s.DataLoc(s.b,k2) by A74,A76
,A77,A78,SCMPDS_2:64
          .= Exec(i, s).c by A74,A79,SCMPDS_2:64
          .= (Exec(i, s) +* Start-At(IEn,SCMPDS)).c by SCMPDS_3:14;
      end;
      suppose
A80:    DataLoc(ss.b,k2) <> c;
        then
A81:    DataLoc(s.b,k2) <> c by SCMPDS_3:14;
        hereby
          per cases;
          suppose
A82:        DataLoc(ss.a,k1) <> c;
            then
A83:        DataLoc(s.a,k1) <> c by SCMPDS_3:14;
            thus Exec(i, ss).c = ss.c by A74,A80,A82,SCMPDS_2:64
              .=s.c by SCMPDS_3:14
              .=Exec(i,s).c by A74,A81,A83,SCMPDS_2:64
              .= (Exec(i, s) +* Start-At(IEn,SCMPDS)).c by SCMPDS_3:14;
          end;
          suppose
A84:        DataLoc(ss.a,k1) = c;
            then
A85:        DataLoc(s.a,k1) = c by SCMPDS_3:14;
            thus Exec(i, ss).c = s.DataLoc(s.a,k1) div s.DataLoc(s.b,k2) by A74
,A76,A77,A80,A84,SCMPDS_2:64
              .= Exec(i,s).c by A74,A81,A85,SCMPDS_2:64
              .= (Exec(i, s) +* Start-At(IEn,SCMPDS)).c by SCMPDS_3:14;
          end;
        end;
      end;
    end;
    IC Exec(i, s) = Nl by A74,SCMPDS_2:64;
    then IC Exec(i, ss) = IC (Exec(i, s) +* Start-At(IEn,SCMPDS))
    by A1,A74,SCMPDS_2:64
;
    hence thesis by A6,A75,SCMPDS_2:54;
  end;
  suppose
    InsCode i = 13;
    then consider a,b,k1,k2 such that
A86: i = (a,k1):=(b,k2) by SCMPDS_2:48;
A87: now
      let c;
      per cases;
      suppose
A88:    DataLoc(ss.a,k1) = c;
        then
A89:    DataLoc(s.a,k1) = c by SCMPDS_3:14;
        thus Exec(i, ss).c = ss.DataLoc(ss.b,k2) by A86,A88,SCMPDS_2:59
          .=s.DataLoc(ss.b,k2) by SCMPDS_3:14
          .=s.DataLoc(s.b,k2) by SCMPDS_3:14
          .=Exec(i,s).c by A86,A89,SCMPDS_2:59
          .= (Exec(i, s) +* Start-At(IEn,SCMPDS)).c by SCMPDS_3:14;
      end;
      suppose
A90:    DataLoc(ss.a,k1) <> c;
        then
A91:    DataLoc(s.a,k1) <> c by SCMPDS_3:14;
        thus Exec(i,ss).c = ss.c by A86,A90,SCMPDS_2:59
          .=s.c by SCMPDS_3:14
          .=Exec(i,s).c by A86,A91,SCMPDS_2:59
          .= (Exec(i, s) +* Start-At(IEn,SCMPDS)).c by SCMPDS_3:14;
      end;
    end;
    IC Exec(i, s) = Nl by A86,SCMPDS_2:59;
    then IC Exec(i, ss) = IC (Exec(i, s) +* Start-At(IEn,SCMPDS))
    by A1,A86,SCMPDS_2:59
;
    hence thesis by A6,A87,SCMPDS_2:54;
  end;
end;

begin :: Computation of two consecutive program blocks

theorem
  for s being 0-started State of SCMPDS
  for I being parahalting halt-free Program of SCMPDS,J being
  parahalting shiftable Program of SCMPDS,k being Element of NAT st
  stop (I ';' J) c= s holds Comput(ProgramPart(
   Initialize Result(ProgramPart(s +* stop I),s +*stop I)
      +* stop J ),
  Initialize Result(ProgramPart(s +*stop I),s +* stop I) +* stop J,k) +*
  Start-At (IC Comput(ProgramPart(
  Initialize Result(
      ProgramPart(s +* stop I),s +* stop I) +* stop J ),
   (Initialize Result(ProgramPart(s +*stop I),
      s +*stop I) +* stop J ),k) + card I,SCMPDS),
  Comput(ProgramPart(s +* stop (I ';' J)),s +* stop (I ';' J),
   LifeSpan(ProgramPart(s +* stop I),s +* stop I)+k) equal_outside NAT
proof
  let s be 0-started State of SCMPDS;
  set SA0=Start-At( 0,SCMPDS);
  let I be parahalting halt-free Program of SCMPDS,J be parahalting
  shiftable Program of SCMPDS,k be Element of NAT;
  set sIsI = s +* stop I, RI = Result(ProgramPart(sIsI),sIsI), pJ= stop J,
   RIJ = Initialize RI +* pJ, pIJ = stop (I ';' J),
   sIsIJ = s +* pIJ;
I3: RI +* Initialize pJ = Initialize RI +* pJ by COMPOS_1:125;
B1: ProgramPart sIsI halts_on sIsI by FUNCT_4:26,SCMPDS_4:def 10;
  set s2 = Comput(ProgramPart( sIsIJ), sIsIJ,LifeSpan(ProgramPart(sIsI),sIsI)+0
);
  set s1 = RIJ +* Start-At (IC RIJ + card I,SCMPDS);
  set m1 = LifeSpan(ProgramPart(sIsI),sIsI);
A2: I c= pIJ by Th15;
  assume
A3: pIJ c= s;
  then
A4: s = sIsIJ by FUNCT_4:79;
A5: now
    thus IC s1 = IC (RI +* (stop J +* SA0)) + card I by I3,FUNCT_4:121
      .= IC (RI +* stop J +* SA0) + card I by FUNCT_4:15
      .=  (0+card I) by FUNCT_4:121
      .= IC s2 by A3,A4,A2,Th30,XBOOLE_1:1;
    hereby
      let a be Int_position;
A6:   not a in dom (stop J+*SA0) by SCMPDS_4:61;
      not a in dom Start-At (IC RIJ + card I,SCMPDS) by SCMPDS_4:59;
      hence s1.a = RIJ.a by FUNCT_4:12
        .= RI.a by A6,I3,FUNCT_4:12
        .= Comput(ProgramPart( sIsI), sIsI,m1).a by B1,EXTPRO_1:23
        .= s2.a by Th34,SCMPDS_4:13;
    end;
  end;
  defpred X[Element of NAT] means Comput(ProgramPart( RIJ), RIJ,$1) +* Start-At
(IC
  Comput(ProgramPart( RIJ), RIJ,$1) + card I,SCMPDS),
   Comput(ProgramPart( sIsIJ
), sIsIJ,LifeSpan(ProgramPart(sIsI),sIsI)+$1)
  equal_outside NAT;
A7: pIJ c= sIsIJ by FUNCT_4:26;
A8: for k being Element of NAT st X[k] holds X[k+1]
  proof
    let k be Element of NAT;
    set k1 = k+1, CRk = Comput(ProgramPart( RIJ), RIJ,k), CRSk = CRk +*
Start-At (IC CRk +
card I,SCMPDS), CIJk = Comput(ProgramPart( sIsIJ), sIsIJ,LifeSpan(ProgramPart(
sIsI),sIsI)+k),
CRk1 = Comput(ProgramPart( RIJ), RIJ,k1
    ), CRSk1 = CRk1 +* Start-At (IC CRk1 + card I,SCMPDS),
    CIJk1 = Comput(ProgramPart( sIsIJ), sIsIJ,
    LifeSpan(ProgramPart(sIsI),sIsI)+k1);
    assume
A9: CRSk,CIJk equal_outside NAT;
A10: CurInstr(ProgramPart CRk,CRk) = CurInstr(ProgramPart CIJk,CIJk)
    proof
Y:  (ProgramPart CIJk)/.IC CIJk
 = CIJk.IC CIJk by COMPOS_1:38;
A11:  CurInstr(ProgramPart CIJk,CIJk) = CIJk.IC CRSk by A9,Y,COMPOS_1:24
        .= CIJk.(IC CRk + card I) by FUNCT_4:121;
      reconsider n = IC CRk as Element of NAT;
A12:  pIJ = I ';' pJ by AFINSQ_1:30;
A13:  IC CRk in dom pJ by FUNCT_4:26,SCMPDS_4:def 9;
      then n < card pJ by AFINSQ_1:70;
      then n+card I < card pJ + card I by XREAL_1:8;
      then n+card I < card pIJ by A12,AFINSQ_1:20;
      then
A14:  IC CRk + card I in dom pIJ by AFINSQ_1:70;
Y:  (ProgramPart CRk)/.IC CRk
 = CRk.IC CRk by COMPOS_1:38;
      pJ c= CRk by AMI_1:81,FUNCT_4:26;
      hence CurInstr(ProgramPart CRk,CRk) =pJ.IC CRk by A13,Y,GRFUNC_1:8
        .=pIJ.(IC CRk + card I) by A13,A12,AFINSQ_1:def 4
        .= sIsIJ.(IC CRk + card I) by A7,A14,GRFUNC_1:8
        .= CurInstr(ProgramPart CIJk,CIJk) by A11,AMI_1:54;
    end;
    CIJk,CRSk equal_outside NAT by A9,FUNCT_7:28;
    then
    Exec(CurInstr(ProgramPart CIJk,CIJk), CIJk),
    Exec(CurInstr(ProgramPart CRk,CRk),CRSk)
     equal_outside NAT by A10,SCMPDS_4:15;
    then
A15: Exec(CurInstr(ProgramPart CIJk,CIJk), CIJk),
Following(ProgramPart CRk,CRk) +* Start-At (IC Following(ProgramPart CRk,CRk)
 + card I,SCMPDS) equal_outside NAT by Th35;
T: ProgramPart sIsIJ = ProgramPart CIJk
by AMI_1:123;
    CIJk1 = Comput(ProgramPart( sIsIJ), sIsIJ,LifeSpan(ProgramPart(sIsI),sIsI)+
k+1);
    then
A16: CIJk1 = Following(ProgramPart sIsIJ,CIJk) by EXTPRO_1:4;
A17: now
      let a be Int_position;
S: ProgramPart RIJ = ProgramPart CRk
by AMI_1:123;
      thus CRSk1.a = CRk1.a by SCMPDS_3:14
        .= (Following(ProgramPart RIJ,CRk)).a by EXTPRO_1:4
        .= (Following(ProgramPart CRk,CRk) +*
        Start-At (IC Following(ProgramPart CRk,CRk) + card I,SCMPDS)).a
         by S,SCMPDS_3:14
        .= CIJk1.a by A16,A15,T,SCMPDS_4:13;
    end;
S: ProgramPart RIJ = ProgramPart CRk
by AMI_1:123;
    IC CRSk1 = IC CRk1 + card I by FUNCT_4:121
      .= IC Following(ProgramPart RIJ,CRk) + card I by EXTPRO_1:4;
    then
    IC CRSk1=IC (Following(ProgramPart CRk,CRk) +*
    Start-At (IC Following(ProgramPart CRk,CRk) + card I,SCMPDS))
    by S,FUNCT_4:121
      .= IC CIJk1 by A16,A15,T,COMPOS_1:24;
    hence thesis by A17,SCMPDS_4:11;
  end;
  Comput(ProgramPart( RIJ), RIJ,0) = RIJ by EXTPRO_1:3;
  then
A18: X[0] by A5,SCMPDS_4:11;
  for k being Element of NAT holds X[k] from NAT_1:sch 1(A18,A8);
  hence thesis;
end;

Lm3:
 for I being parahalting halt-free Program of SCMPDS,J being parahalting
shiftable Program of SCMPDS,
  s being 0-started State of SCMPDS,
  s1 being State of SCMPDS st stop (I
';' J) c= s & s1= s +* stop I holds IC Comput(ProgramPart( s), s,
LifeSpan(ProgramPart(s1),s1)) = card I &
 DataPart Comput(ProgramPart( s), s,LifeSpan(ProgramPart(s1),s1)) =
DataPart (Initialize Comput(ProgramPart(s1),s1,LifeSpan(ProgramPart(s1),s1))
 +* stop J) & Shift(stop J,card I)
  c= Comput(ProgramPart( s), s,LifeSpan(ProgramPart(s1),s1)) &
LifeSpan(ProgramPart(s),s) = LifeSpan(
ProgramPart(s1),s1) + LifeSpan(ProgramPart(
Initialize Result(ProgramPart(s1),s1) +*
stop J),Initialize Result(ProgramPart(s1),s1) +* stop J)

proof
  set D = SCM-Data-Loc;

  let I be parahalting halt-free Program of SCMPDS,J be parahalting
  shiftable Program of SCMPDS,s be 0-started State of SCMPDS,
  s1 be State of SCMPDS;
AA: Initialize s = s by COMPOS_1:78;
  set spJ = stop J,
  sIJ = stop (I ';' J), m1 = LifeSpan(ProgramPart(s1),s1),
  s3 = Initialize Comput(ProgramPart( s1), s1, m1) +* spJ;
I1: Initialize Comput(ProgramPart( s1), s1, m1) +* spJ =
  Comput(ProgramPart( s1), s1, m1) +* Initialize spJ by COMPOS_1:125;
  set m3 = LifeSpan(ProgramPart(s3),s3);
  assume that
A1: sIJ c= s and
A2: s1= s +* stop I;
A3: DataPart s3 = DataPart Comput(ProgramPart( s1), s1,m1) +*
      DataPart Initialize spJ by I1,FUNCT_4:75;

  set s4 = Comput(ProgramPart(s),s,m1);
UU: ProgramPart s4 = ProgramPart s by AMI_1:123;
A4: I c= sIJ by Th15;
  hence
A5: IC s4 =  card I by A1,A2,Th30,XBOOLE_1:1;
A6: now
    let x be set;
    assume
    x in dom (DataPart Initialize spJ);
    then
A7: x in dom Initialize spJ /\ D by RELAT_1:90,SCMPDS_2:100;
    then
A8: x in dom Initialize spJ by XBOOLE_0:def 4;
A9: x in D by A7,XBOOLE_0:def 4;
    per cases by A8,COMPOS_1:77;
    suppose
A10:  x in dom spJ;
      dom spJ c= NAT by RELAT_1:def 18;
      then reconsider l=x as Element of NAT by A10;

      (DataPart Initialize spJ).l =
      (DataPart Comput(ProgramPart(s1),s1,m1)).l by A9,SCMPDS_4:22;

      hence (DataPart Initialize spJ).x =
      (DataPart Comput(ProgramPart(s1),s1,m1)).x;
    end;
    suppose
      x = IC SCMPDS;

      hence (DataPart Initialize spJ).x =
      (DataPart Comput(ProgramPart(s1),s1,m1)).x by A7,SCMPDS_3:6
,XBOOLE_0:def 4;

    end;
  end;
A11: dom (DataPart spJ) = dom spJ /\ D
by RELAT_1:90,SCMPDS_2:100;
  reconsider m = m1 + m3 as Element of NAT;
  sIJ = I ';' (J ';' Stop SCMPDS) by AFINSQ_1:30
    .= I +* Shift(spJ, card I);
  then
A12: Shift(spJ, card I) c= sIJ by FUNCT_4:26;
A13: spJ c= s3 by FUNCT_4:26;
A14: ProgramPart s3 halts_on s3 by FUNCT_4:26,SCMPDS_4:def 10;
I3: Initialize s +* sIJ = s +* Initialize sIJ by COMPOS_1:125;
XX: DataPart Initialize spJ = DataPart spJ by COMPOS_1:80;
  dom spJ c= dom s3 by A13,GRFUNC_1:8;
  then dom spJ c= the carrier of SCMPDS by PARTFUN1:def 4;

  then dom (DataPart spJ) c= (the carrier of SCMPDS) /\ D
  by A11,XBOOLE_1:26;

  then dom (DataPart spJ) c=
  dom ( Comput(ProgramPart( s1), s1,m1)) /\ D by PARTFUN1:def 4;

  then dom (DataPart spJ) c=
  dom DataPart Comput(ProgramPart(s1),s1,m1) by RELAT_1:90,SCMPDS_2:100;

  then DataPart spJ c= DataPart Comput(ProgramPart( s1), s1,m1)
  by A6,XX,GRFUNC_1:8;
  then
A15: DataPart Comput(ProgramPart( s1), s1,m1) = DataPart s3
 by A3,XX,LATTICE2:8;
  s = Initialize s +* sIJ by A1,AA,FUNCT_4:79
    .= s +* ((I ';' (J ';' Stop SCMPDS)) +* Start-At( 0,SCMPDS))
    by I3,AFINSQ_1:30;
  hence
A16: DataPart s4 = DataPart s3 by A2,A15,Th33,AA,COMPOS_1:138;
T: ProgramPart s = ProgramPart Comput(ProgramPart(s),s,m1) by AMI_1:123;
x: Comput(ProgramPart(s),s,m1+m3)
 = Comput(ProgramPart(s),Comput(ProgramPart(s),s,m1),m3) by EXTPRO_1:5;
  Shift(spJ, card I) c= s by A12,A1,XBOOLE_1:1;
  hence
A17: Shift(spJ, card I) c= s4 by AMI_1:81;

  then CurInstr(ProgramPart (s3),Comput(ProgramPart(s3),s3,m3))
   = CurInstr(ProgramPart s,Comput(ProgramPart(s),s,m1+m3))
      by x,T,A13,A5,A16,SCMPDS_4:84;
  then
A18: CurInstr(ProgramPart s,Comput(ProgramPart(s),s,m))
 = halt SCMPDS by A14,EXTPRO_1:def 14;
A19: now
    let k be Element of NAT;
    assume
    m1 + k < m;
    then
A20: k < m3 by XREAL_1:8;
    assume
A21: CurInstr(ProgramPart s,Comput(ProgramPart(s),s,m1+k))
 = halt SCMPDS;
x: Comput(ProgramPart(s),s,m1+k) =
Comput(ProgramPart(s),Comput(ProgramPart(s),s,m1),k) by EXTPRO_1:5;
    CurInstr(ProgramPart s3,Comput(ProgramPart(s3),s3,k))
     = halt SCMPDS by A21,x,A13,A5,A16,A17,UU,SCMPDS_4:84;
    hence contradiction by A14,A20,EXTPRO_1:def 14;
  end;
  now
    let k be Element of NAT;
    assume
A22: k < m;
TX: ProgramPart s = ProgramPart Comput(ProgramPart(s),s,k) by AMI_1:123;
    per cases;
    suppose
      k < m1;

      hence CurInstr(ProgramPart s,Comput(ProgramPart(s),s,k)) <>
       halt SCMPDS by A1,A2,A4,Th32,TX,XBOOLE_1:1;

    end;
    suppose
      m1 <= k;
      then consider kk being Nat such that
A23:  m1 + kk = k by NAT_1:10;
      kk in NAT by ORDINAL1:def 13;
      hence CurInstr(ProgramPart s,Comput(ProgramPart(s),s,k)) <>
       halt SCMPDS by A19,A22,A23;
    end;
  end;

  then
A24: for k being Element of NAT st CurInstr(ProgramPart (s),
Comput(ProgramPart(s),s,k))
 = halt SCMPDS
  holds m <= k;
 ProgramPart s1 halts_on s1 by A2,FUNCT_4:26,SCMPDS_4:def 10;
  then
X: Result(ProgramPart(s1),s1) =
    Comput(ProgramPart s1,s1,LifeSpan(ProgramPart(s1),s1)) by EXTPRO_1:23;
  ProgramPart s halts_on s by A1,SCMPDS_4:def 10;
  hence thesis by X,A18,A24,EXTPRO_1:def 14;
end;

theorem Th37:
  for s being 0-started State of SCMPDS
  for I being parahalting halt-free Program of SCMPDS,
      J being parahalting shiftable Program of SCMPDS holds
 LifeSpan(ProgramPart(s +* stop(I ';' J)), s +* stop (I ';' J))
  = LifeSpan(ProgramPart(s +* stop I),s +* stop I) +
    LifeSpan(ProgramPart(Initialize Result(ProgramPart(s +*
  stop I),s +* stop I) +* stop J),
  Initialize Result(ProgramPart(s +* stop I),s +* stop I) +* stop J)
proof
  let s be 0-started State of SCMPDS;
  set SA0= Start-At( 0,SCMPDS);
  let I be parahalting halt-free Program of SCMPDS,J be parahalting
  shiftable Program of SCMPDS;
  set sI=stop I, sIJ = stop (I ';' J),
  s1= s +* sIJ, s2= s +* stop I;
A1: sIJ c= s1 by FUNCT_4:26;
  set
  s3=Initialize Result(ProgramPart(s1 +* stop I),s1 +* stop I) +* stop J,
  s4=Initialize Result(ProgramPart(s2),s2) +* stop J;
A2: stop I c= s2 by FUNCT_4:26;
A3: s1, s1 +* stop I equal_outside NAT by FUNCT_7:132;
A4: stop J c= s4 by FUNCT_4:26;
A5: s2,s equal_outside NAT by FUNCT_7:28,132;
A6: stop J c= s3 by FUNCT_4:26;
  s,s1 equal_outside NAT by FUNCT_7:132;
  then s2, s1 equal_outside NAT by A5,FUNCT_7:29;
  then
A7: s2,s1+* stop I equal_outside NAT by A3,FUNCT_7:29;
A8: stop I c= s1 +* stop I by FUNCT_4:26;
  then Result(ProgramPart(s2),s2),
   Result(
  ProgramPart(s1 +* stop I),s1 +* stop I) equal_outside NAT by A7,A2,Th21;
  then Initialize Result(ProgramPart(s2),s2),
   Initialize Result(
  ProgramPart(s1 +* stop I),s1 +* stop I) equal_outside NAT by COMPOS_1:81;
  then s4,s3 equal_outside NAT by FUNCT_7:106;
  then
A9: LifeSpan(ProgramPart(s3),s3) = LifeSpan(ProgramPart s4,s4) by A6,A4,Th21;
  LifeSpan(ProgramPart(s1 +* stop I),s1 +* stop I) =
  LifeSpan(ProgramPart(s2),s2) by A7,A8,A2,Th21;
  hence thesis by A1,A9,Lm3;
end;

theorem Th38:
  for s being 0-started State of SCMPDS
  for I being parahalting halt-free Program of SCMPDS,J being
parahalting shiftable Program of SCMPDS holds IExec(I ';' J,s) = IExec(J,IExec(
  I,s)) +* Start-At (IC IExec(J,IExec(I,s)) + card I,SCMPDS)
proof
  let s be 0-started State of SCMPDS;
  set SA0= Start-At( 0,SCMPDS);
  let I be parahalting halt-free Program of SCMPDS,J be parahalting
  shiftable Program of SCMPDS;
  set A = NAT, D = SCM-Data-Loc, ps = s | NAT, sI = stop I,
  sIJ = stop (I ';' J),
   s1 = Initialize s +* stop I, m1 = LifeSpan(ProgramPart(s1),s1),
  s2 = s +* stop (I ';' J), s3 =
  Initialize Comput(ProgramPart(s1),s1,m1) +* stop J,
  m3 = LifeSpan(ProgramPart(s3),s3);
I1: Initialize Comput(ProgramPart(s1),s1,m1) +* stop J
      = Comput(ProgramPart(s1),s1,m1) +* Initialize stop J by COMPOS_1:125;
A1: stop J c= s3 by FUNCT_4:26;
B1: ProgramPart s3 halts_on s3 by FUNCT_4:26,SCMPDS_4:def 10;
A3: IExec(I,s) | A = ps by PBOOLE:157;
I2: s2 +* Initialize stop I = Initialize s2 +* stop I by COMPOS_1:125;
AA: Initialize s = s by COMPOS_1:78;
  Initialize s2 +* stop I = s2 +* sI by COMPOS_1:78;
  then
A4: s2, s2 +* Initialize stop I equal_outside A by I2,FUNCT_7:132;
A7: s1 +* sIJ =s +* (stop I +* sIJ) by AA,FUNCT_4:15
    .=s2 by Th17;
A9: stop J c= Initialize IExec(I,s) +* stop J by FUNCT_4:26;
A10: dom ps = dom s /\ A by RELAT_1:90
    .= ({IC SCMPDS} \/ D \/ A) /\ A by SCMPDS_4:19
    .= A by XBOOLE_1:21;
A11: stop I c= s1 by FUNCT_4:26;
  ProgramPart s1 halts_on s1 by FUNCT_4:26,SCMPDS_4:def 10;
  then
 IExec(I,s) = Comput(ProgramPart(s1),s1,m1) +* ps
by EXTPRO_1:23;
  then
B12: Initialize Comput(ProgramPart(s1),s1,m1) +* ps
      = Initialize IExec(I,s) by COMPOS_1:83;
 s3, Initialize Comput(ProgramPart(s1),s1,m1) +* ps +* stop J
equal_outside
  dom ps by FUNCT_7:31,106;
  then
 Initialize IExec(I,s) +* stop J,s3 equal_outside NAT
 by B12,A10,FUNCT_7:28;
  then Result(ProgramPart(Initialize IExec(I,s) +* stop J),
  Initialize IExec(I,s) +* stop J),
     Result(ProgramPart(s3),s3) equal_outside A by A1,A9,Th21;
  then Result(ProgramPart(Initialize IExec(I,s) +* stop J),
  Initialize IExec(I,s) +* stop J) +* ps = Result(
ProgramPart(s3),s3) +* ps by A10,FUNCT_7:108;
  then
A14: IExec(J,IExec(I,s)) = Comput(ProgramPart(s3),s3,m3) +* ps by B1,A3,
EXTPRO_1:23;
A15: s1,s+*SA0 equal_outside A by FUNCT_7:28,132;
A16: stop I c= Initialize s2 +* stop I by FUNCT_4:26;
LL: Initialize s2 = s2 by COMPOS_1:78;
X: Initialize s2 +* stop I +* sIJ = s2 +* (stop I +* sIJ) by LL,FUNCT_4:15;
X1: Initialize s2 +* sIJ = s +* (sIJ +* sIJ) by LL,FUNCT_4:15;
X2: s2 +* (stop I +* sIJ)
   = s2 +* sIJ by Th17;
  s+*SA0,s2 equal_outside A by AA,FUNCT_7:132;
  then s1, s2 equal_outside A by A15,FUNCT_7:29;
  then s1,Initialize s2+*stop I equal_outside A
   by A4,I2,FUNCT_7:29;
  then
A17: LifeSpan(ProgramPart(Initialize s2 +* stop I),
Initialize s2 +* stop I) = m1
by A11,A16,Th21;
 set S1=Initialize s2 +* stop I;
XX: DataPart Comput(ProgramPart S1,S1,m1)
    = DataPart Comput(ProgramPart( (s2 +* sIJ)),
    (s2 +* sIJ),m1) by X2,X,A16,A17,Th24,COMPOS_1:138
    .= DataPart Comput(ProgramPart(s1),s1,m1)
    by A11,A7,Th24,X1,LL,COMPOS_1:138;
A18: DataPart(Comput(ProgramPart(Initialize s2 +* stop I),
(Initialize s2 +* stop I),m1) +* Initialize stop J)
     = DataPart Comput(ProgramPart(s1),s1,m1) +*
     DataPart Initialize stop J by XX,FUNCT_4:75
    .= DataPart(Comput(ProgramPart( s1), s1,m1) +* Initialize stop J)
    by FUNCT_4:75;
A19: sIJ c= s2 by FUNCT_4:26;
  then
A20: DataPart Comput(ProgramPart(s2),s2,m1) =
 DataPart(Initialize Comput(ProgramPart( (Initialize s2
+* stop I)), (Initialize s2 +* stop I),m1) +*
  stop J) by A17,Lm3,LL
  .= DataPart(Comput(ProgramPart( (Initialize s2
+* stop I)), (Initialize s2 +* stop I),m1) +*
  Initialize stop J) by COMPOS_1:125;
A21: Shift(stop J,card I) c= Comput(ProgramPart(s2),s2,m1)
by A19,A17,Lm3,LL;
A22: IC Comput(ProgramPart(s2),s2,m1) =  card I by A19,A17,Lm3,LL;
  then
A23: IC Comput(ProgramPart( Comput(ProgramPart(s2),s2,m1)), Comput(ProgramPart(
s2),s2,m1),m3) = IC Comput(ProgramPart(s3),s3,m3) + card I
  by A20,A21,A18,I1,A1,SCMPDS_4:84;
T1: ProgramPart s2 = ProgramPart Comput(ProgramPart(s2),s2,m1) by AMI_1:123;

A24: DataPart Comput(ProgramPart( Comput(ProgramPart(s2),s2,m1)), Comput(
ProgramPart(s2),s2,m1),m3) = DataPart Comput(ProgramPart(s3),s3,
  m3) by A22,A20,A21,A18,I1,A1,SCMPDS_4:84;
X: ProgramPart s1 halts_on s1 by FUNCT_4:26,SCMPDS_4:def 10;
A25: s3 = Initialize Result(ProgramPart(s1),s1) +* stop J
   by A11,EXTPRO_1:23,SCMPDS_4:def 10;
 set SS1 = Initialize Result(ProgramPart s1,s1) +* stop J,
     SS2 = Initialize IExec(I,s) +* stop J;
yy: Result(ProgramPart(s1),s1) = Comput(ProgramPart(s1),s1,m1)
 by A11,EXTPRO_1:23,SCMPDS_4:def 10;

  s3,Initialize IExec(I,s) +* stop J equal_outside NAT
   by B12,A10,FUNCT_7:31,106;
  then
A26: IC Result(ProgramPart(Initialize Result(ProgramPart s1,s1) +* stop J),
Initialize Result(ProgramPart s1,s1) +* stop J)
= IC Result(
ProgramPart(Initialize IExec(I,s) +* stop J),Initialize IExec(I,s) +* stop J)
by Th21,A1,A9,yy,COMPOS_1:24;
XX: s3 = Initialize Result(ProgramPart s1,s1) +* stop J
by X,EXTPRO_1:23;
A27: IC IExec(I ';' J,s) = IC Result(ProgramPart(Initialize s +* sIJ),
Initialize s +* sIJ) by Th22
    .= IC Comput(ProgramPart(s2),s2,LifeSpan(ProgramPart(s2),s2))
     by A19,AA,EXTPRO_1:23,SCMPDS_4:def 10
    .= IC Comput(ProgramPart(s2),s2,m1+m3) by A25,Th37,AA
    .= IC Comput(ProgramPart(s3),s3,m3) + card I by A23,T1,EXTPRO_1:5
    .= IC Result(ProgramPart(s3),s3) + card I by B1,EXTPRO_1:23
    .= IC IExec(J,IExec(I,s)) + card I by A26,Th22,XX;
  IExec(I ';' J,s) = Comput(ProgramPart(s2),s2,LifeSpan(ProgramPart(s2),s2)) +*
ps by A19,AA,EXTPRO_1:23,SCMPDS_4:def 10

    .= Comput(ProgramPart(s2),s2,m1+m3) +* ps by A25,Th37,AA;
  then
A28: DataPart IExec(I ';' J,s) = DataPart Comput(ProgramPart(s2),s2,m1+m3) by
A10,AMI_2:29,FUNCT_4:76,SCMPDS_2:100
    .= DataPart Comput(ProgramPart(s3),s3,m3) by A24,T1,EXTPRO_1:5
    .= DataPart IExec(J,IExec(I,s))
     by A10,A14,AMI_2:29,FUNCT_4:76,SCMPDS_2:100;
  hereby
    reconsider l = IC IExec(J,IExec(I,s)) + card I as Element of NAT;
A29: dom Start-At(l,SCMPDS) = {IC SCMPDS} by FUNCOP_1:19;
A30: now
      let x be set;
      assume
A31:  x in dom IExec(I ';' J,s);
      per cases by A31,SCMPDS_4:20;
      suppose
A32:    x is Int_position;
        then x <> IC SCMPDS by SCMPDS_2:52;
        then
A33:    not x in dom Start-At(l,SCMPDS) by A29,TARSKI:def 1;
        IExec(I ';' J,s).x = IExec(J,IExec(I,s)).x by A28,A32,SCMPDS_4:23;
        hence
        IExec(I ';' J,s).x = (IExec(J,IExec(I,s)) +* Start-At (IC IExec(J
        ,IExec(I,s)) + card I,SCMPDS)).x by A33,FUNCT_4:12;
      end;
      suppose
A34:    x = IC SCMPDS;
        then x in {IC SCMPDS} by TARSKI:def 1;
        then
A35:    x in dom Start-At(l,SCMPDS) by FUNCOP_1:19;
        thus IExec(I ';' J,s).x = (Start-At(l,SCMPDS)).IC SCMPDS
        by A27,A34,FUNCOP_1:87
          .= (IExec(J,IExec(I,s)) +* Start-At (IC IExec(J,IExec(I,s)) + card
        I,SCMPDS)).x by A34,A35,FUNCT_4:14;
      end;
      suppose
A36:    x is Element of NAT;
        then x <> IC SCMPDS by COMPOS_1:3;
        then
A37:    not x in dom Start-At(l,SCMPDS) by A29,TARSKI:def 1;
        IExec(I ';' J,s) | A = ps by PBOOLE:157
          .= IExec(J,IExec(I,s)) | A by A3,PBOOLE:157;
        then IExec(I ';' J,s).x = IExec(J,IExec(I,s)).x by A36,COMPOS_1:127;
        hence
        IExec(I ';' J,s).x = (IExec(J,IExec(I,s)) +* Start-At (IC IExec(J
        ,IExec(I,s)) + card I,SCMPDS)).x by A37,FUNCT_4:12;
      end;
    end;
    dom IExec(I ';' J,s) = the carrier of SCMPDS by PARTFUN1:def 4
      .= dom (IExec(J,IExec(I,s)) +* Start-At (IC IExec(J,IExec(I,s)) + card
    I,SCMPDS)) by PARTFUN1:def 4;
    hence thesis by A30,FUNCT_1:9;
  end;
end;

theorem
 for s being 0-started State of SCMPDS
 for I being parahalting halt-free Program of SCMPDS,J being
  parahalting shiftable Program of SCMPDS holds IExec(I ';' J, s).a = IExec(J,
  IExec(I,s)).a
proof
  let s be 0-started State of SCMPDS;
  let I be parahalting halt-free Program of SCMPDS,J be parahalting
  shiftable Program of SCMPDS;
A1: not a in dom Start-At (IC IExec(J,IExec(I,s)) + card I,SCMPDS)
by SCMPDS_4:59;
  IExec(I ';' J,s) = IExec(J,IExec(I,s)) +* Start-At (IC IExec(J,IExec(I,s
  )) + card I,SCMPDS) by Th38;
  hence thesis by A1,FUNCT_4:12;
end;

begin :: Computation of the program consisting of a instruction and a block

theorem Th40:
  IC Initialize s =  0 & (Initialize s).a = s.a & (Initialize s).loc = s.loc
proof
  dom Start-At( 0,SCMPDS) = {IC SCMPDS} by FUNCOP_1:19;
  then
A1: IC SCMPDS in dom Start-At( 0,SCMPDS) by TARSKI:def 1;
  (Start-At( 0,SCMPDS)).IC SCMPDS =  0 by FUNCOP_1:87;
  hence IC Initialize s =  0 by A1,FUNCT_4:14;
  not a in dom Start-At( 0,SCMPDS) by SCMPDS_4:59;
  hence (Initialize s).a =s.a by FUNCT_4:12;
  not loc in dom Start-At( 0,SCMPDS) by COMPOS_1:29;
  hence thesis by FUNCT_4:12;
end;

theorem Th41:
  s1, s2 equal_outside NAT iff s1 | (SCM-Data-Loc \/ {IC SCMPDS})
  = s2 | (SCM-Data-Loc \/ {IC SCMPDS})
proof
  set Y = NAT;
  set X = SCM-Data-Loc \/ {IC SCMPDS};
A1: (X \/ Y) \ Y \/ Y = X \/ Y \/ Y by XBOOLE_1:39
    .= X \/ (Y \/ Y) by XBOOLE_1:4
    .= Y \/ X;
A2: Y misses (X \/ Y) \ Y by XBOOLE_1:79;
A3: X misses Y
  proof
    assume
    X meets Y;
    then consider x such that
A4: x in X and
A5: x in Y by XBOOLE_0:3;
A6: x in SCM-Data-Loc or x in {IC SCMPDS} by A4,XBOOLE_0:def 3;
    per cases by A6,TARSKI:def 1;
    suppose
      x in SCM-Data-Loc;
      hence contradiction by A5,AMI_2:29,XBOOLE_0:3;
    end;
    suppose
      x = IC SCMPDS;
      then reconsider l=IC SCMPDS as Element of NAT by A5;
      l=IC SCMPDS;
      hence contradiction by COMPOS_1:3;
    end;
  end;
  dom s2 = the carrier of SCMPDS by PARTFUN1:def 4;
  then
A7: dom s2 \ Y = X by A1,A2,A3,SCMPDS_3:5,XBOOLE_1:72;
  dom s1 = the carrier of SCMPDS by PARTFUN1:def 4;
  then dom s1 \ Y = X by A1,A2,A3,SCMPDS_3:5,XBOOLE_1:72;
  hence thesis by A7,FUNCT_7:def 2;
end;

canceled;

theorem Th43:
  DataPart s1 = DataPart s2 & InsCode i <> 3 implies
   DataPart Exec(i,s1) = DataPart Exec(i,s2)
proof
  assume that
A1: DataPart s1 = DataPart s2 and
A2: InsCode i <> 3;
  per cases by A2,NAT_1:38,SCMPDS_2:15;
  suppose
    InsCode i = 0;
    then
A3: ex k1 st i = goto k1 by SCMPDS_2:35;
    now
      let a;
      thus Exec(i, s1).a = s1.a by A3,SCMPDS_2:66
        .=s2.a by A1,SCMPDS_4:23
        .=Exec(i, s2).a by A3,SCMPDS_2:66;
    end;
    hence thesis by SCMPDS_4:23;
  end;
  suppose
    InsCode i = 1;
    then consider a such that
A4: i = return a by SCMPDS_2:36;
    now
      let b;
      per cases;
      suppose
A5:     a=b;
        hence Exec(i, s1).b= s1.DataLoc(s1.a,RetSP) by A4,SCMPDS_2:70
          .=s2.DataLoc(s2.a,RetSP) by A1,SCMPDS_3:3
          .=Exec(i,s2).b by A4,A5,SCMPDS_2:70;
      end;
      suppose
A6:     a<>b;
        hence Exec(i, s1).b = s1.b by A4,SCMPDS_2:70
          .=s2.b by A1,SCMPDS_4:23
          .=Exec(i,s2).b by A4,A6,SCMPDS_2:70;
      end;
    end;
    hence thesis by SCMPDS_4:23;
  end;
  suppose
    InsCode i = 2;
    then consider a,k1 such that
A7: i = a := k1 by SCMPDS_2:37;
    now
      let b;
      per cases;
      suppose
A8:     a=b;
        hence Exec(i, s1).b= k1 by A7,SCMPDS_2:57
          .=Exec(i,s2).b by A7,A8,SCMPDS_2:57;
      end;
      suppose
A9:     a<>b;
        hence Exec(i,s1).b = s1.b by A7,SCMPDS_2:57
          .=s2.b by A1,SCMPDS_4:23
          .=Exec(i,s2).b by A7,A9,SCMPDS_2:57;
      end;
    end;
    hence thesis by SCMPDS_4:23;
  end;
  suppose
    InsCode i = 4;
    then
A10: ex a,k1,k2 st i = (a,k1)<>0_goto k2 by SCMPDS_2:39;
    now
      let a;
      thus Exec(i, s1).a = s1.a by A10,SCMPDS_2:67
        .=s2.a by A1,SCMPDS_4:23
        .=Exec(i, s2).a by A10,SCMPDS_2:67;
    end;
    hence thesis by SCMPDS_4:23;
  end;
  suppose
    InsCode i = 5;
    then
A11: ex a,k1,k2 st i = (a,k1)<=0_goto k2 by SCMPDS_2:40;
    now
      let a;
      thus Exec(i, s1).a = s1.a by A11,SCMPDS_2:68
        .=s2.a by A1,SCMPDS_4:23
        .=Exec(i, s2).a by A11,SCMPDS_2:68;
    end;
    hence thesis by SCMPDS_4:23;
  end;
  suppose
    InsCode i = 6;
    then
A12: ex a,k1,k2 st i = (a,k1)>=0_goto k2 by SCMPDS_2:41;
    now
      let a;
      thus Exec(i, s1).a = s1.a by A12,SCMPDS_2:69
        .=s2.a by A1,SCMPDS_4:23
        .=Exec(i, s2).a by A12,SCMPDS_2:69;
    end;
    hence thesis by SCMPDS_4:23;
  end;
  suppose
    InsCode i = 7;
    then consider a,k1,k2 such that
A13: i = (a,k1) := k2 by SCMPDS_2:42;
    now
      let b;
      per cases;
      suppose
A14:    DataLoc(s1.a,k1)=b;
        then
A15:    DataLoc(s2.a,k1)=b by A1,SCMPDS_4:23;
        thus Exec(i, s1).b= k2 by A13,A14,SCMPDS_2:58
          .=Exec(i,s2).b by A13,A15,SCMPDS_2:58;
      end;
      suppose
A16:    DataLoc(s1.a,k1)<>b;
        then
A17:    DataLoc(s2.a,k1)<>b by A1,SCMPDS_4:23;
        thus Exec(i,s1).b = s1.b by A13,A16,SCMPDS_2:58
          .=s2.b by A1,SCMPDS_4:23
          .=Exec(i,s2).b by A13,A17,SCMPDS_2:58;
      end;
    end;
    hence thesis by SCMPDS_4:23;
  end;
  suppose
    InsCode i = 8;
    then consider a,k1,k2 such that
A18: i = AddTo(a,k1,k2) by SCMPDS_2:43;
    now
      let b;
      per cases;
      suppose
A19:    DataLoc(s1.a,k1)=b;
        then
A20:    DataLoc(s2.a,k1)=b by A1,SCMPDS_4:23;
        thus Exec(i, s1).b= s1.DataLoc(s1.a,k1)+k2 by A18,A19,SCMPDS_2:60
          .= s2.DataLoc(s2.a,k1)+k2 by A1,SCMPDS_3:3
          .=Exec(i,s2).b by A18,A20,SCMPDS_2:60;
      end;
      suppose
A21:    DataLoc(s1.a,k1)<>b;
        then
A22:    DataLoc(s2.a,k1)<>b by A1,SCMPDS_4:23;
        thus Exec(i,s1).b = s1.b by A18,A21,SCMPDS_2:60
          .=s2.b by A1,SCMPDS_4:23
          .=Exec(i,s2).b by A18,A22,SCMPDS_2:60;
      end;
    end;
    hence thesis by SCMPDS_4:23;
  end;
  suppose
    InsCode i = 9;
    then consider a,b,k1,k2 such that
A23: i = AddTo(a,k1,b,k2) by SCMPDS_2:44;
    now
      let c;
      per cases;
      suppose
A24:    DataLoc(s1.a,k1)=c;
        then
A25:    DataLoc(s2.a,k1)=c by A1,SCMPDS_4:23;
        thus Exec(i, s1).c = s1.DataLoc(s1.a,k1)+s1.DataLoc(s1.b,k2) by A23,A24
,SCMPDS_2:61
          .= s2.DataLoc(s2.a,k1)+s1.DataLoc(s1.b,k2) by A1,SCMPDS_3:3
          .= s2.DataLoc(s2.a,k1)+s2.DataLoc(s2.b,k2) by A1,SCMPDS_3:3
          .=Exec(i,s2).c by A23,A25,SCMPDS_2:61;
      end;
      suppose
A26:    DataLoc(s1.a,k1)<>c;
        then
A27:    DataLoc(s2.a,k1)<>c by A1,SCMPDS_4:23;
        thus Exec(i,s1).c = s1.c by A23,A26,SCMPDS_2:61
          .=s2.c by A1,SCMPDS_4:23
          .=Exec(i,s2).c by A23,A27,SCMPDS_2:61;
      end;
    end;
    hence thesis by SCMPDS_4:23;
  end;
  suppose
    InsCode i = 10;
    then consider a,b,k1,k2 such that
A28: i = SubFrom(a,k1,b,k2) by SCMPDS_2:45;
    now
      let c;
      per cases;
      suppose
A29:    DataLoc(s1.a,k1)=c;
        then
A30:    DataLoc(s2.a,k1)=c by A1,SCMPDS_4:23;
        thus Exec(i, s1).c = s1.DataLoc(s1.a,k1)-s1.DataLoc(s1.b,k2) by A28,A29
,SCMPDS_2:62
          .= s2.DataLoc(s2.a,k1)-s1.DataLoc(s1.b,k2) by A1,SCMPDS_3:3
          .= s2.DataLoc(s2.a,k1)-s2.DataLoc(s2.b,k2) by A1,SCMPDS_3:3
          .=Exec(i,s2).c by A28,A30,SCMPDS_2:62;
      end;
      suppose
A31:    DataLoc(s1.a,k1)<>c;
        then
A32:    DataLoc(s2.a,k1)<>c by A1,SCMPDS_4:23;
        thus Exec(i,s1).c = s1.c by A28,A31,SCMPDS_2:62
          .=s2.c by A1,SCMPDS_4:23
          .=Exec(i,s2).c by A28,A32,SCMPDS_2:62;
      end;
    end;
    hence thesis by SCMPDS_4:23;
  end;
  suppose
    InsCode i = 11;
    then consider a,b,k1,k2 such that
A33: i = MultBy(a,k1,b,k2) by SCMPDS_2:46;
    now
      let c;
      per cases;
      suppose
A34:    DataLoc(s1.a,k1)=c;
        then
A35:    DataLoc(s2.a,k1)=c by A1,SCMPDS_4:23;
        thus Exec(i, s1).c = s1.DataLoc(s1.a,k1)*s1.DataLoc(s1.b,k2) by A33,A34
,SCMPDS_2:63
          .= s2.DataLoc(s2.a,k1)*s1.DataLoc(s1.b,k2) by A1,SCMPDS_3:3
          .= s2.DataLoc(s2.a,k1)*s2.DataLoc(s2.b,k2) by A1,SCMPDS_3:3
          .=Exec(i,s2).c by A33,A35,SCMPDS_2:63;
      end;
      suppose
A36:    DataLoc(s1.a,k1)<>c;
        then
A37:    DataLoc(s2.a,k1)<>c by A1,SCMPDS_4:23;
        thus Exec(i,s1).c = s1.c by A33,A36,SCMPDS_2:63
          .=s2.c by A1,SCMPDS_4:23
          .=Exec(i,s2).c by A33,A37,SCMPDS_2:63;
      end;
    end;
    hence thesis by SCMPDS_4:23;
  end;
  suppose
    InsCode i = 12;
    then consider a,b,k1,k2 such that
A38: i = Divide(a,k1,b,k2) by SCMPDS_2:47;
    now
      let c;
      per cases;
      suppose
A39:    DataLoc(s1.b,k2)=c;
        then
A40:    DataLoc(s2.b,k2)=c by A1,SCMPDS_4:23;
        thus Exec(i, s1).c = s1.DataLoc(s1.a,k1) mod s1.DataLoc(s1.b,k2) by A38
,A39,SCMPDS_2:64
          .= s2.DataLoc(s2.a,k1) mod s1.DataLoc(s1.b,k2) by A1,SCMPDS_3:3
          .= s2.DataLoc(s2.a,k1) mod s2.DataLoc(s2.b,k2) by A1,SCMPDS_3:3
          .= Exec(i,s2).c by A38,A40,SCMPDS_2:64;
      end;
      suppose
A41:    DataLoc(s1.b,k2)<>c;
        then
A42:    DataLoc(s2.b,k2)<>c by A1,SCMPDS_4:23;
        hereby
          per cases;
          suppose
A43:        DataLoc(s1.a,k1)<>c;
            then
A44:        DataLoc(s2.a,k1)<>c by A1,SCMPDS_4:23;
            thus Exec(i, s1).c = s1.c by A38,A41,A43,SCMPDS_2:64
              .=s2.c by A1,SCMPDS_4:23
              .=Exec(i,s2).c by A38,A42,A44,SCMPDS_2:64;
          end;
          suppose
A45:        DataLoc(s1.a,k1)=c;
            then
A46:        DataLoc(s2.a,k1)=c by A1,SCMPDS_4:23;
            thus Exec(i, s1).c = s1.DataLoc(s1.a,k1) div s1.DataLoc(s1.b,k2)
            by A38,A41,A45,SCMPDS_2:64
              .= s2.DataLoc(s2.a,k1) div s1.DataLoc(s1.b,k2) by A1,SCMPDS_3:3
              .= s2.DataLoc(s2.a,k1) div s2.DataLoc(s2.b,k2) by A1,SCMPDS_3:3
              .= Exec(i,s2).c by A38,A42,A46,SCMPDS_2:64;
          end;
        end;
      end;
    end;
    hence thesis by SCMPDS_4:23;
  end;
  suppose
    InsCode i = 13;
    then consider a,b,k1,k2 such that
A47: i = (a,k1):=(b,k2) by SCMPDS_2:48;
    now
      let c;
      per cases;
      suppose
A48:    DataLoc(s1.a,k1)=c;
        then
A49:    DataLoc(s2.a,k1)=c by A1,SCMPDS_4:23;
        thus Exec(i, s1).c = s1.DataLoc(s1.b,k2) by A47,A48,SCMPDS_2:59
          .= s2.DataLoc(s2.b,k2) by A1,SCMPDS_3:3
          .=Exec(i,s2).c by A47,A49,SCMPDS_2:59;
      end;
      suppose
A50:    DataLoc(s1.a,k1)<>c;
        then
A51:    DataLoc(s2.a,k1)<>c by A1,SCMPDS_4:23;
        thus Exec(i,s1).c = s1.c by A47,A50,SCMPDS_2:59
          .=s2.c by A1,SCMPDS_4:23
          .=Exec(i,s2).c by A47,A51,SCMPDS_2:59;
      end;
    end;
    hence thesis by SCMPDS_4:23;
  end;
end;

theorem Th44:
  for i being shiftable Instruction of SCMPDS holds (DataPart s1 =
  DataPart s2 implies DataPart Exec(i,s1) = DataPart Exec(i,s2))
proof
  let i be shiftable Instruction of SCMPDS;
  InsCode i <> 3 by SCMPDS_4:def 13;
  hence thesis by Th43;
end;

theorem Th45:
  for i being parahalting Instruction of SCMPDS
   holds Exec(i,Initialize s) = IExec(Load i, s)
proof
  set SA0=Start-At( 0,SCMPDS);
  let i be parahalting Instruction of SCMPDS;
  set Li=Load i, Mi= stop Li;
  set sI = Initialize s+*Mi;
  set Is = Initialize s;
I1: Initialize s+*Mi = s+*Initialize Mi by COMPOS_1:125;
  set IC1 = IC Comput(ProgramPart( sI), sI,1);
A1: ProgramPart sI halts_on sI by FUNCT_4:26,SCMPDS_4:def 10;
A2:  1 in dom Mi by Th9;
A3:  0 in dom Mi by Th9;
A4: now
    set Y = NAT;
    set X = SCM-Data-Loc \/ {IC SCMPDS};
    assume
A5: Result(ProgramPart(sI),sI) = Exec(i, sI);
    Is,sI equal_outside Y by FUNCT_7:132;
    then Is | X = sI | X by Th41;
    then
A6: Exec(i, Is) | X = Exec(i, sI) | X by SCMPDS_3:7;
A7: Y /\ (X \/ Y) c= Y /\ (X \/ Y);
A8: dom IExec(Li, s) = the carrier of SCMPDS by PARTFUN1:def 4;
A9: dom Exec(i, Is) = the carrier of SCMPDS by PARTFUN1:def 4;
A10: dom s = X \/ Y by PARTFUN1:def 4,SCMPDS_3:5;
    now
      thus dom (Exec(i, Is) | Y) = dom s /\ Y by A9,A10,RELAT_1:90,SCMPDS_3:5;
      let x;
      assume
      x in dom (Exec(i, Is) | Y);
      then
A11:  x in Y /\ (X \/ Y) by A9,RELAT_1:90,SCMPDS_3:5;
      then reconsider x9 = x as Element of NAT by XBOOLE_1:21;
      x in Y by A11,XBOOLE_1:21;
      hence (Exec(i, Is)|Y).x = (Exec(i, Is)).x by FUNCT_1:72
        .= Is.x9 by AMI_1:def 13
        .= s.x by Th40;
    end;
    then
A12: Exec(i, Is) | Y = s | Y by FUNCT_1:68;
    dom Exec(i, sI) = the carrier of SCMPDS by PARTFUN1:def 4;
    then
A13: IExec(Li, s) | Y = s | Y by A5,A10,A7,FUNCT_4:93,SCMPDS_3:5;
    X misses Y
    proof
      assume
      X meets Y;
      then consider x such that
A14:  x in X and
A15:  x in Y by XBOOLE_0:3;
A16:  x in SCM-Data-Loc or x in {IC SCMPDS} by A14,XBOOLE_0:def 3;
      per cases by A16,TARSKI:def 1;
      suppose
        x in SCM-Data-Loc;
        hence contradiction by A15,AMI_2:29,XBOOLE_0:3;
      end;
      suppose
        x = IC SCMPDS;
        then reconsider l=IC SCMPDS as Element of NAT by A15;
        l=IC SCMPDS;
        hence contradiction by COMPOS_1:3;
      end;
    end;
    then X misses dom (s|Y) by RELAT_1:87,XBOOLE_1:63;
    then IExec(Li, s) | X = Exec(i, sI) | X by A5,FUNCT_4:76;
    then
A17: Exec(i, Is)| (X \/ Y) = IExec(Li,s) | (X \/ Y) by A6,A13,A12,RELAT_1:185;
    thus Exec(i, Is) = Exec(i, Is)| (X \/ Y) by A9,RELAT_1:98,SCMPDS_3:5
      .= IExec(Li, s) by A8,A17,RELAT_1:98,SCMPDS_3:5;
  end;
A18: Mi. 1=halt SCMPDS by Th10;
A19: Mi. 0 = i by Th10;
A20: Mi c= sI by FUNCT_4:26;
A21: IC1 in dom Mi by FUNCT_4:26,SCMPDS_4:def 9;
Y:  (ProgramPart sI)/.IC sI
 = sI.IC sI by COMPOS_1:38;
A22: Comput(ProgramPart( sI), sI,0+1)
 = Following(ProgramPart sI,Comput(ProgramPart(sI),sI,0))
by EXTPRO_1:4
    .= Following(ProgramPart sI,sI) by EXTPRO_1:3
    .= Exec(sI. 0, sI) by Th18,Y,I1,FUNCT_4:26
    .= Exec(i, sI) by A3,A19,A20,GRFUNC_1:8;
  per cases by A21,Th11;
  suppose
A23: IC1 =  0;
    set Ni=InsCode i;
    succ IC sI = succ  0 by Th18,I1,FUNCT_4:26
      .=  1;
    then
A24: Ni in {0,1,4,5,6} by A22,A23,SCMPDS_4:6;
A25: CurInstr(ProgramPart(sI),Comput(ProgramPart(sI),
sI,1)) = sI. 0
 by A23,COMPOS_1:38
      .= i by A3,A19,A20,GRFUNC_1:8;
A26: Ni <> 1 by Th26;
    hereby
      per cases;
      suppose
        i = halt SCMPDS;
        hence thesis by A1,A4,A22,A25,EXTPRO_1:def 8;
      end;
      suppose
A27:    i <> halt SCMPDS;
A28:    for loc holds sI.loc = Exec(i, sI).loc by AMI_1:def 13;
A29:    now
          let b;
          per cases by A24,A26,ENUMSET1:def 3;
          suppose
            InsCode i = 0;
            then ex k1 st i = goto k1 by SCMPDS_2:35;
            hence sI.b=Exec(i, sI).b by SCMPDS_2:66;
          end;
          suppose
            InsCode i = 4;
            then ex a,k1,k2 st i = (a,k1)<>0_goto k2 by SCMPDS_2:39;
            hence sI.b=Exec(i, sI).b by SCMPDS_2:67;
          end;
          suppose
            InsCode i = 5;
            then ex a,k1,k2 st i = (a,k1)<=0_goto k2 by SCMPDS_2:40;
            hence sI.b=Exec(i, sI).b by SCMPDS_2:68;
          end;
          suppose
            InsCode i = 6;
            then ex a,k1,k2 st i = (a,k1)>=0_goto k2 by SCMPDS_2:41;
            hence sI.b=Exec(i, sI).b by SCMPDS_2:69;
          end;
        end;
A30:    Following(ProgramPart sI,sI)
 = Following(ProgramPart sI,Comput(ProgramPart(sI),sI,0)) by EXTPRO_1:3
          .= Exec(i, sI) by A22,EXTPRO_1:4;
A31:    IC sI = IC Exec(i, sI) by A22,A23,Th18,I1,FUNCT_4:26;
        then
A32:    sI = Exec(i, sI) by A29,A28,SCMPDS_2:54;
        now
          let n;
          Comput(ProgramPart( sI), sI,n) = sI by A31,A29,A28,A30,EXTPRO_1:27
,SCMPDS_2:54
            .= Following(ProgramPart sI,Comput(ProgramPart(sI),sI,0))
            by A32,A30,EXTPRO_1:3
            .= Comput(ProgramPart( sI), sI,0+1) by EXTPRO_1:4;
          hence CurInstr(ProgramPart sI,Comput(ProgramPart(sI),sI,n))
           <> halt SCMPDS by A25,A27;
        end;
        then not ProgramPart sI halts_on sI by EXTPRO_1:30;
        hence thesis by FUNCT_4:26,SCMPDS_4:def 10;
      end;
    end;
  end;
  suppose
S:    IC1 =  1;
    CurInstr(ProgramPart(sI),Comput(ProgramPart(sI),sI,1))
     = sI. 1 by S,COMPOS_1:38
      .= halt SCMPDS by A2,A18,A20,GRFUNC_1:8;
    hence thesis by A1,A4,A22,EXTPRO_1:def 8;
  end;
end;

theorem Th46:
 for s being 0-started State of SCMPDS
  for I being parahalting halt-free Program of SCMPDS,
      j being parahalting shiftable Instruction of SCMPDS
 holds IExec(I ';' j, s).a = Exec(j,IExec(I, s)).a
proof
  let s be 0-started State of SCMPDS;
  let I be parahalting halt-free Program of SCMPDS,j be parahalting
  shiftable Instruction of SCMPDS;
  set Mj = Load j;
  set SA = Start-At (IC IExec(Mj,IExec(I,s)) + card I,SCMPDS);
A1: not a in dom SA by SCMPDS_4:59;
A2: a in SCM-Data-Loc by SCMPDS_2:def 2;
  for a holds (Initialize IExec(I,s)).a=IExec(I, s).a by Th40;
  then
A3: DataPart Initialize IExec(I,s) = DataPart IExec(I, s) by SCMPDS_4:23;
  thus IExec(I ';' j, s).a = (IExec(Mj,IExec(I,s))+*SA).a by Th38
    .= IExec(Mj, IExec(I,s)).a by A1,FUNCT_4:12
    .= Exec(j, Initialize IExec(I,s)).a by Th45
    .= (DataPart Exec(j, Initialize IExec(I,s))).a by A2,FUNCT_1:72
,SCMPDS_2:100
    .= (DataPart Exec(j, IExec(I, s))).a by A3,Th44
    .= Exec(j, IExec(I, s)).a by A2,FUNCT_1:72,SCMPDS_2:100;
end;

theorem
  for s being 0-started State of SCMPDS
  for i being No-StopCode parahalting Instruction of SCMPDS, j being
shiftable parahalting Instruction of SCMPDS holds IExec(i ';' j, s).a = Exec(j,
  Exec(i, Initialize s)).a
proof
  let s be 0-started State of SCMPDS;
  let i be No-StopCode parahalting Instruction of SCMPDS, j be shiftable
  parahalting Instruction of SCMPDS;
  set Mi = Load i;
  thus IExec(i ';' j, s).a = IExec(Mi ';' j, s).a
    .= Exec(j, IExec(Mi,s)).a by Th46
    .= Exec(j, Exec(i, Initialize s)).a by Th45;
end;

theorem
  IExec(I,Initialize s) = IExec(I,s)
proof
  (Initialize s)|NAT = s|NAT +* Start-At(0,SCMPDS)|NAT by FUNCT_4:75
    .= s|NAT +* {} by COMPOS_1:47
    .= s|NAT by FUNCT_4:22;
 hence IExec(I,Initialize s) = IExec(I,s);
end;
