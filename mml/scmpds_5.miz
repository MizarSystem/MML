:: Computation of Two Consecutive Program Blocks for SCMPDS
::  by JingChao Chen
::
:: Received June 15, 1999
:: Copyright (c) 1999 Association of Mizar Users

environ

 vocabularies NUMBERS, SUBSET_1, SCMPDS_2, AMI_1, FSM_1, INT_1, SETFAM_1,
      RELAT_1, SCMFSA_7, CARD_1, SCMPDS_4, FUNCT_1, AMISTD_2, VALUED_1,
      ARYTM_3, TARSKI, XXREAL_0, SCMFSA6A, TURING_1, FUNCT_4, XBOOLE_0,
      SCMFSA6B, FUNCT_7, CIRCUIT2, GRAPHSP, MSUALG_1, AMI_2, AMI_3, SCMPDS_1,
      COMPLEX1, STRUCT_0, ARYTM_1, NAT_1, SCMPDS_5, ORDINAL1, PARTFUN1,
      SCMNORM;
 notations TARSKI, XBOOLE_0, SETFAM_1, ENUMSET1, SUBSET_1, CARD_1, NUMBERS,
      XCMPLX_0, RELAT_1, FUNCT_1, PARTFUN1,
      FUNCT_4, INT_1, NAT_1, STRUCT_0, AMI_1,
      SCMNORM, AMI_2, FUNCT_7, SCMPDS_1, SCMPDS_2, INT_2, SCMPDS_4, XXREAL_0;
 constructors ENUMSET1, XXREAL_0, REAL_1, NAT_1, INT_2, SCMPDS_1, SCMPDS_4,
      SCMNORM, SCMPDS_3, AFINSQ_1, PRE_POLY;
 registrations SETFAM_1, RELAT_1, FUNCT_1, NUMBERS, XREAL_0, INT_1, CARD_3,
      AMI_1, SCMPDS_2, SCMPDS_4, ORDINAL1, XBOOLE_0, SCMNORM, VALUED_1,
      RELSET_1, AFINSQ_1;
 requirements NUMERALS, REAL, SUBSET, BOOLE, ARITHM;
 definitions FUNCOP_1, AMI_1, SCMPDS_4, NAT_1, SCMNORM, AFINSQ_1;
 theorems AMI_1, NAT_1, TARSKI, FUNCT_4, FUNCT_1, INT_1, RELAT_1, SCMPDS_2,
      FUNCT_7, SCMPDS_3, CARD_1, ENUMSET1, ABSVALUE, GRFUNC_1, SCMPDS_4,
      LATTICE2, XBOOLE_0, XBOOLE_1, XREAL_1, ORDINAL1, FUNCOP_1, XXREAL_0,
      AMI_2, VALUED_1, AFINSQ_1, PBOOLE, PARTFUN1, SCMNORM;
 schemes NAT_1;

begin :: Preliminaries

reserve x for set,
  m,n for Element of NAT,
  a,b,c for Int_position,
  i for
  Instruction of SCMPDS,
  s,s1,s2 for State of SCMPDS,
  k1,k2 for Integer,
  loc,l1
  for Element of NAT,
  I,J for Program of SCMPDS,
  N for with_non-empty_elements set;

canceled;

LL: card Stop SCMPDS = 1 by SCMNORM:3;

theorem Th2:
  x in dom Load i iff x =  0
proof
  dom Load i = { 0} by FUNCOP_1:19;
  hence thesis by TARSKI:def 1;
end;

theorem Th3:
  loc in dom (stop I) & (stop I).loc <> halt SCMPDS implies loc in
  dom I
proof
  assume that
A1: loc in dom (stop I) and
A2: (stop I).loc <> halt SCMPDS;
  set SS=Stop SCMPDS, S2=Shift(SS, card I);
  assume
  not loc in dom I;
  then loc in dom S2 by A1,FUNCT_4:13;
  then loc in {l1+ card I where l1 is Element of NAT : l1 in dom SS} by
VALUED_1:def 12;
  then consider l1 being Element of NAT such that
A3: loc=l1+ card I and
A4: l1 in dom SS;
y:  0 in dom Stop SCMPDS by SCMNORM:2;
x: (Stop SCMPDS). 0 = halt SCMPDS by AFINSQ_1:38;
  dom SS = { 0} by AFINSQ_1:36,CARD_1:87;
  then l1= 0 by A4,TARSKI:def 1;
  hence contradiction by A2,A3,SCMPDS_4:38,x,y;
end;

theorem
  dom Load i = { 0} & (Load i).( 0)=i by FUNCOP_1:19,87;

theorem Th5:
   0 in dom Load i
proof
  dom Load i = { 0} by FUNCOP_1:19;
  hence thesis by TARSKI:def 1;
end;

theorem Th6:
  card Load i = 1
proof
A1: dom Load i = { 0} by FUNCOP_1:19;
  thus card Load i = card dom Load i by CARD_1:104
    .= 1 by A1,CARD_1:50;
end;

theorem
  card stop I = card I + 1 by SCMPDS_4:45,LL;

theorem Th8:
  card stop Load i = 2
proof
  thus card stop Load i = card (Load i) +1 by SCMPDS_4:45,LL
    .=1+1 by Th6
    .=2;
end;

theorem Th9:
   0 in dom stop (Load i) &  1 in dom stop (Load i)
proof
  card stop Load i = 2 by Th8;
  hence thesis by SCMPDS_4:1;
end;

theorem Th10:
  (stop Load i). 0=i & (stop Load i). 1=halt SCMPDS
proof
  set II=Load i;
   0 in dom II by Th5;
  hence (stop II). 0 =II. 0 by SCMPDS_4:37
    .=i by FUNCOP_1:87;
y:  0 in dom Stop SCMPDS by SCMNORM:2;
x: (Stop SCMPDS). 0 = halt SCMPDS by AFINSQ_1:38;
   1 = 0 + card II by Th6;
  hence thesis by SCMPDS_4:38,x,y;
end;

theorem Th11:
  x in dom stop Load i iff x= 0 or x= 1
proof
  set pi=stop Load i, A = NAT;
A1: card pi = 2 by Th8;
  hereby
    assume
A2: x in dom pi;
    dom pi c= A by RELAT_1:def 18;
    then reconsider l=x as Element of NAT by A2;
    reconsider n = l as Element of NAT;
    n < 1+1 by A1,A2,SCMPDS_4:1;
    then n <= 1 by NAT_1:13;
    hence x= 0 or x= 1 by NAT_1:26;
  end;
  assume
A3: x= 0 or x= 1;
  per cases by A3;
  suppose
    x= 0;
    hence thesis by A1,SCMPDS_4:1;
  end;
  suppose
    x= 1;
    hence thesis by A1,SCMPDS_4:1;
  end;
end;

theorem
  dom (stop Load i)={ 0, 1}
proof
  for x holds (x in dom (stop Load i) iff x= 0 or x= 1) by Th11;
  hence thesis by TARSKI:def 2;
end;

theorem Th13:
   0 in dom (Initialized stop Load i) &  1 in dom (
Initialized stop Load i) & (Initialized stop Load i). 0=i & (Initialized
  stop Load i). 1=halt SCMPDS
proof
  set si=stop Load i, Ii=Initialized si;
A1:  0 in dom si by Th9;
A2:  1 in dom si by Th9;
  si c= Ii by SCMPDS_4:9;
  then dom si c= dom Ii by RELAT_1:25;
  hence  0 in dom Ii &  1 in dom Ii by A1,A2;
  thus Ii. 0=si. 0 by A1,SCMPDS_4:33
    .=i by Th10;
  thus Ii. 1=si. 1 by A2,SCMPDS_4:33
    .=halt SCMPDS by Th10;
end;

canceled;

theorem Th15:
  for I,J being Program of SCMPDS holds Initialized I c=
  Initialized stop (I ';' J)
proof
  let I,J be Program of SCMPDS;
  set SA0=Start-At( 0,SCMPDS), IS=I ';' (J ';' Stop SCMPDS),
  Ip=Initialized stop
  (I ';' J);
A1: Ip= IS +* SA0 by SCMPDS_4:46;
A2: I c= IS by SCMPDS_4:40;
  dom IS misses dom SA0 by SCMPDS_4:54;
  then IS c= Ip by A1,FUNCT_4:33;
  then
A3: I c= Ip by A2,XBOOLE_1:1;
  dom I misses dom SA0 by SCMPDS_4:54;
  then
A4: I \/ SA0 =Initialized I by FUNCT_4:32;
  SA0 c= Ip by FUNCT_4:26;
  hence thesis by A3,A4,XBOOLE_1:8;
end;

theorem Th16:
  dom stop I c= dom stop (I ';' J)
proof
  set sI=stop I, sIJ=stop (I ';'J);
A1: card sIJ=card (I ';' J) +1 by SCMPDS_4:45,LL
    .=card I + card J +1 by SCMPDS_4:45
    .=card I + 1 + card J;
  card sI=card I +1 by SCMPDS_4:45,LL;
  then
A2: card sI <= card sIJ by A1,NAT_1:11;
  now
    set A = NAT;
    let x be set;
    assume
A3: x in dom sI;
    dom sI c= A by RELAT_1:def 18;
    then reconsider l=x as Element of NAT by A3;
    reconsider n = l as Element of NAT;
    n < card sI by A3,SCMPDS_4:1;
    then n < card sIJ by A2,XXREAL_0:2;
    hence x in dom sIJ by SCMPDS_4:1;
  end;
  hence thesis by TARSKI:def 3;
end;

theorem Th17:
  for I,J being Program of SCMPDS holds Initialized stop I +*
  Initialized stop (I ';' J) = Initialized stop (I ';' J)
proof
  let I,J be Program of SCMPDS;
  set sI=stop I, IsI=Initialized sI, sIJ=stop (I ';' J), IsIJ=Initialized sIJ;
A1: dom IsI = dom sI \/ {IC SCMPDS} by SCMPDS_4:27;
A2: dom IsIJ = dom sIJ \/ {IC SCMPDS} by SCMPDS_4:27;
  dom sI c= dom sIJ by Th16;
  hence thesis by A1,A2,FUNCT_4:20,XBOOLE_1:9;
end;

theorem Th18:
  Initialized I c= s implies IC s =  0
proof
A1: IC Initialized I =  0 by SCMPDS_4:8;
A2: IC SCMPDS in dom Initialized I by SCMPDS_4:7;
  assume
  Initialized I c= s;
  hence thesis by A1,A2,GRFUNC_1:8;
end;

theorem Th19:
  (s +* Initialized I).a = s.a
proof
  not a in dom Initialized I by SCMPDS_4:31;
  hence thesis by FUNCT_4:12;
end;

theorem Th20:
  for I being parahalting Program of SCMPDS st Initialized stop I
  c= s1 & Initialized stop I c= s2 & s1,s2 equal_outside NAT holds for k being
  Element of NAT holds Comput(ProgramPart(s1),s1,k), Comput(ProgramPart(s2),s2,
k) equal_outside NAT &
  CurInstr(ProgramPart Comput(ProgramPart(s1),s1,k),Comput(ProgramPart(s1),s1,k
))
   = CurInstr(ProgramPart Comput(ProgramPart(s2),s2,k),Comput(ProgramPart(s2),
s2,k))
proof
  let I be parahalting Program of SCMPDS;
  set SI=stop I;
  assume that
A1: Initialized SI c= s1 and
A2: Initialized SI c= s2 and
A3: s1,s2 equal_outside NAT;
A4: SI c= s2 by A2,SCMPDS_4:57;
A5: SI c= s1 by A1,SCMPDS_4:57;
  hereby
    let k be Element of NAT;
A6: IC Comput(ProgramPart(s1),s1,k) in dom SI by A1,SCMPDS_4:def 9;
A7: IC Comput(ProgramPart(s2),s2,k) in dom SI by A2,SCMPDS_4:def 9;
    for m being Element of NAT st m < k holds IC(Comput(ProgramPart(s2),s2,m))
in dom
    SI by A2,SCMPDS_4:def 9;
    hence Comput(ProgramPart(s1),s1,k), Comput(ProgramPart(s2),s2,k)
equal_outside NAT by A3,A5,A4,
SCMPDS_4:67;
    then
A8: IC Comput(ProgramPart(s1),s1,k) = IC Comput(ProgramPart(s2),s2,k) by AMI_1:
121;
Y:  (ProgramPart Comput(ProgramPart(s2),s2,k))/.IC Comput(ProgramPart(s2),s2,k)
 = Comput(ProgramPart(s2),s2,k).IC Comput(ProgramPart(s2),s2,k) by AMI_1:150;
Z:  (ProgramPart Comput(ProgramPart(s1),s1,k))/.IC Comput(ProgramPart(s1),s1,k)
 = Comput(ProgramPart(s1),s1,k).IC Comput(ProgramPart(s1),s1,k) by AMI_1:150;
    thus CurInstr(ProgramPart Comput(ProgramPart(s2),s2,k),Comput(ProgramPart(
s2),s2,k))
     = s2.IC Comput(ProgramPart(s2),s2,k) by AMI_1:54,Y
      .= SI.IC Comput(ProgramPart(s2),s2,k) by A4,A7,GRFUNC_1:8
      .= s1.IC Comput(ProgramPart(s1),s1,k) by A5,A8,A6,GRFUNC_1:8
      .= CurInstr(ProgramPart Comput(ProgramPart(s1),s1,k),Comput(ProgramPart(
s1),s1,k))
       by AMI_1:54,Z;
  end;
end;

theorem Th21:
  for I being parahalting Program of SCMPDS st Initialized stop I
c= s1 & Initialized stop I c= s2 & s1,s2 equal_outside NAT holds LifeSpan s1 =
  LifeSpan s2 & Result s1, Result s2 equal_outside NAT
proof
  let I be parahalting Program of SCMPDS;
  set SI=stop I;
  assume that
A1: Initialized SI c= s1 and
A2: Initialized SI c= s2 and
A3: s1,s2 equal_outside NAT;
A4: ProgramPart s2 halts_on s2 by A2,SCMPDS_4:63;
A5: ProgramPart s1 halts_on s1 by A1,SCMPDS_4:63;
A6: now
    let l be Element of NAT;
    assume
A7: CurInstr(ProgramPart Comput(ProgramPart(s2),s2,l),Comput(ProgramPart(s2),s2
,l)) = halt SCMPDS;
    CurInstr(ProgramPart Comput(ProgramPart(s1),s1,l),Comput(ProgramPart(s1),s1
,l))
     = CurInstr(ProgramPart Comput(ProgramPart(s2),s2,l),
    Comput(ProgramPart(s2),s2,l))
     by A1,A2,A3,Th20;
    hence LifeSpan s1 <= l by A5,A7,AMI_1:def 46;
  end;
  CurInstr(ProgramPart Comput(ProgramPart(s2),s2,LifeSpan s1),Comput(
ProgramPart(s2),s2,LifeSpan s1))
   = CurInstr(ProgramPart Comput(ProgramPart(s1),s1,LifeSpan s1),
   Comput(ProgramPart(s1),s1,LifeSpan s1))
    by A1,A2,A3,Th20
    .= halt SCMPDS by A5,AMI_1:def 46;
  hence LifeSpan s1 = LifeSpan s2 by A6,A4,AMI_1:def 46;
   then
A8: Result s2 = Comput(ProgramPart(s2),s2,LifeSpan s1) by A4,AMI_1:122;
  Result s1 = Comput(ProgramPart(s1),s1,LifeSpan s1) by A5,AMI_1:122;
  hence thesis by A1,A2,A3,A8,Th20;
end;

theorem Th22:
  for I being Program of SCMPDS holds IC IExec(I,s) = IC Result (s
  +* Initialized stop I)
proof
  let I be Program of SCMPDS;
  set SI=stop I;
A1: dom s = {IC SCMPDS} \/ SCM-Data-Loc \/ NAT by SCMPDS_4:19;
A2: dom (s | NAT) = dom s /\ NAT by RELAT_1:90
    .= NAT by A1,XBOOLE_1:21;
  not IC SCMPDS in dom (s | NAT) by A2,AMI_1:48;
  hence thesis by FUNCT_4:12;
end;

theorem Th23:
  for I being parahalting Program of SCMPDS, J being Program of
SCMPDS st Initialized stop I c= s for m st m <= LifeSpan s holds Comput(
ProgramPart(s),s,
  m),Comput(ProgramPart(s+*(I ';' J)),s+*(I ';' J),m) equal_outside NAT
proof
  let I be parahalting Program of SCMPDS, J be Program of SCMPDS;
  set SI=stop I;
  defpred X[Element of NAT] means $1 <= LifeSpan s implies Comput(ProgramPart(s
),s,$1),
  Comput(ProgramPart(s+*(I ';' J)),s+*(I ';' J),$1) equal_outside NAT;
A1: Comput(ProgramPart(s+*(I ';' J)),s+*(I ';' J),0) = s+*(I ';' J) by AMI_1:13
;
  assume
A2: Initialized SI c= s;
  then
A3: ProgramPart s halts_on s by SCMPDS_4:63;
A4: for m st X[m] holds X[m+1]
  proof
    dom(I ';' J) = dom I \/ dom Shift(J, card I) by FUNCT_4:def 1;
    then
A5: dom I c= dom(I ';' J) by XBOOLE_1:7;
    let m;
    assume
A6: m <= LifeSpan s implies Comput(ProgramPart(s),s,m),Comput(ProgramPart(s+*(I
';' J)),s+*(I ';' J),
    m) equal_outside NAT;
    assume
A7: m+1 <= LifeSpan s;
    then
A8: IC (Comput(ProgramPart(s),s,m)) = IC (Comput(ProgramPart(s+*(I ';' J)),s+*(
I ';' J),m)) by A6,AMI_1:121
,NAT_1:13;
T: ProgramPart (s+*(I ';' J)) =
ProgramPart Comput(ProgramPart(s+*(I ';' J)),s+*(I ';' J),m)
by AMI_1:144;
A9: Comput(ProgramPart(s+*(I ';' J)),s+*(I ';' J),m+1)
 = Following(ProgramPart (s+*(I ';' J)),
 Comput(ProgramPart(s+*(I ';' J)),s+*(I ';' J),m))
    by AMI_1:14
      .= Exec(CurInstr(ProgramPart Comput(ProgramPart(s+*(I ';' J)),s+*(I ';' J
),m),
      Comput(ProgramPart(s+*(I ';' J)),s+*(I ';' J),m)), Comput(ProgramPart(s+*
(I ';' J)
    ),s+*(I ';' J)
    ,m)) by T;
T: ProgramPart s = ProgramPart Comput(ProgramPart(s),s,m)
by AMI_1:144;
A10: Comput(ProgramPart(s),s,m+1)
 = Following(ProgramPart s,Comput(ProgramPart(s),s,m))
 by AMI_1:14
      .= Exec(CurInstr(ProgramPart Comput(ProgramPart(s),s,m),Comput(
ProgramPart(s),s,m)),
      Comput(ProgramPart(s),s,m)) by T;
A11: I ';' J c= Comput(ProgramPart(s+*(I ';' J)),s+*(I ';' J),m) by AMI_1:81,
FUNCT_4:26;
A12: IC Comput(ProgramPart(s),s,m) in dom SI by A2,SCMPDS_4:def 9;
Y:  (ProgramPart Comput(ProgramPart(s),s,m))/.IC Comput(ProgramPart(s),s,m)
 = Comput(ProgramPart(s),s,m).IC Comput(ProgramPart(s),s,m) by AMI_1:150;
    dom SI misses dom Start-At( 0,SCMPDS) by SCMPDS_4:54;
    then SI c= SI +* Start-At( 0,SCMPDS) by FUNCT_4:33;
    then SI c= s by A2,XBOOLE_1:1;
    then SI c= Comput(ProgramPart(s),s,m) by AMI_1:81;
    then
A13: CurInstr(ProgramPart Comput(ProgramPart(s),s,m),Comput(ProgramPart(s),s,m)
)
 = SI.IC (Comput(ProgramPart(s),s,m)) by A12,GRFUNC_1:8,Y;
Y:  (ProgramPart Comput(ProgramPart(s+*(I ';' J)),s+*(I ';' J),m))/.IC Comput(
ProgramPart(s+*(I ';' J)),s+*(I ';' J),m)
 = Comput(ProgramPart(s+*(I ';' J)),s+*(I ';' J),m).IC Comput(ProgramPart(s+*(I
';' J)),s+*(I ';' J),m) by AMI_1:150;
    m < LifeSpan s by A7,NAT_1:13;
    then SI.IC(Comput(ProgramPart(s),s,m)) <> halt SCMPDS by A3,A13,AMI_1:def
46;
    then
A14: IC Comput(ProgramPart(s),s,m) in dom I by A12,Th3;
    then CurInstr(ProgramPart Comput(ProgramPart(s),s,m),Comput(ProgramPart(s),
s,m))
    =I.IC (Comput(ProgramPart(s),s,m)) by A13,SCMPDS_4:37
      .=(I ';' J).IC(Comput(ProgramPart(s),s,m)) by A14,SCMPDS_4:37
      .= CurInstr(ProgramPart Comput(ProgramPart(s+*(I ';' J)),s+*(I ';' J),m),
      Comput(ProgramPart(s+*(I ';' J)),s+*(I ';' J),m))
       by A8,A11,A14,A5,GRFUNC_1:8,Y;
    hence thesis by A6,A7,A10,A9,NAT_1:13,SCMPDS_4:15;
  end;
  Comput(ProgramPart(s),s,0) = s by AMI_1:13;
  then
A15: X[0] by A1,AMI_1:120;
  thus for m holds X[m] from NAT_1:sch 1(A15,A4);
end;

theorem Th24:
  for I being parahalting Program of SCMPDS, J being Program of
SCMPDS st Initialized stop I c= s for m st m <= LifeSpan s holds Comput(
ProgramPart(s),s,
  m),Comput(ProgramPart(s+*Initialized stop(I ';' J)),s+*Initialized stop(I ';'
J),m) equal_outside NAT
proof
  let I be parahalting Program of SCMPDS, J be Program of SCMPDS;
  assume
A1: Initialized stop I c= s;
  set sIJ=stop (I ';' J), SS=Stop SCMPDS;
  let m;
  assume
A2: m <= LifeSpan s;
  sIJ= I ';' (J ';' SS) by SCMPDS_4:46;
  then s +* Initialized sIJ =s +* (I ';' (J ';' SS)) by A1,SCMPDS_4:34;
  hence thesis by A1,A2,Th23;
end;

Lm1: Load (DataLoc(0,0):=0) is parahalting
proof
  set SA0 = Start-At( 0,SCMPDS);
  set ii= DataLoc(0,0):=0, m0= stop Load ii, m1 = Initialized m0;
  let s such that
A1: m1 c= s;
A2: m0 c= s by A1,SCMPDS_4:57;
  take 1;
     IC Comput(ProgramPart(s),s,1) in NAT;
    hence IC Comput(ProgramPart(s),s,1) in dom ProgramPart s by AMI_1:143;
  dom SA0 = {IC SCMPDS} by FUNCOP_1:19;
  then
A3: IC SCMPDS in dom SA0 by TARSKI:def 1;
  SA0 c= m1 by FUNCT_4:26;
  then SA0 c= s by A1,XBOOLE_1:1;
  then
A4: IC s = SA0.IC SCMPDS by A3,GRFUNC_1:8
    .=  0 by FUNCOP_1:87;
  then
A5: IC Exec(ii, s) = succ  0 by SCMPDS_2:57
    .=  (0+1);
   1 in dom m0 by Th9;
  then m0. 1 = s. 1 by A2,GRFUNC_1:8;
  then
A6: s. 1 = halt SCMPDS by Th10;
   0 in dom m0 by Th9;
  then
A7: m0. 0 = s. 0 by A2,GRFUNC_1:8;
Y:  (ProgramPart s)/.IC s
 = s.IC s by AMI_1:150;
Z:  (ProgramPart Comput(ProgramPart(s),s,1))/.IC Comput(ProgramPart(s),s,1)
 = Comput(ProgramPart(s),s,1).IC Comput(ProgramPart(s),s,1) by AMI_1:150;
  Comput(ProgramPart(s),s,0+1) =
  Following(ProgramPart s,Comput(ProgramPart(s),s,0))
   by AMI_1:14
    .= Following(ProgramPart s,s) by AMI_1:13
    .= Exec(ii,s) by A4,A7,Th10,Y;
   then CurInstr(ProgramPart Comput(ProgramPart(s),s,1),Comput(ProgramPart(s),s
,1))
    = halt SCMPDS by A6,A5,AMI_1:def 13,Z;
  hence thesis by AMI_1:145;
end;

begin :: Non halting instrutions and parahalting instrutions

definition
  let i be Instruction of SCMPDS;
  attr i is No-StopCode means
  :Def1:
  i <> halt SCMPDS;
end;

definition
  let i be Instruction of SCMPDS;
  attr i is parahalting means
  :Def2:
  Load i is parahalting;
end;

registration
  cluster No-StopCode shiftable parahalting Instruction of SCMPDS;
  existence
  proof
    take i=DataLoc(0,0):=0;
A1: InsCode halt SCMPDS=0 by SCMPDS_2:21,93;
    InsCode i=2 by SCMPDS_2:23;
    hence thesis by A1,Def1,Def2,Lm1;
  end;
end;

theorem
  k1 <>0 implies goto k1 is No-StopCode
proof
  set i=goto k1;
  assume
A1: k1 <>0;
  assume
  i is not No-StopCode;
  then i=halt SCMPDS by Def1;
  hence contradiction by A1,SCMPDS_2:85;
end;

registration
  let a;
  cluster return a -> No-StopCode;
  coherence
  proof
    set i=return a;
A1: InsCode halt SCMPDS=0 by SCMPDS_2:21,93;
    InsCode i=1 by SCMPDS_2:22;
    hence thesis by A1,Def1;
  end;
end;

registration
  let a,k1;
  cluster a := k1 -> No-StopCode;
  coherence
  proof
    set i=a:=k1;
A1: InsCode halt SCMPDS=0 by SCMPDS_2:21,93;
    InsCode i=2 by SCMPDS_2:23;
    hence thesis by A1,Def1;
  end;
  cluster saveIC(a,k1) -> No-StopCode;
  coherence
  proof
    set i=saveIC(a,k1);
A2: InsCode halt SCMPDS=0 by SCMPDS_2:21,93;
    InsCode i=3 by SCMPDS_2:24;
    hence thesis by A2,Def1;
  end;
end;

registration
  let a,k1,k2;
  cluster (a,k1)<>0_goto k2 -> No-StopCode;
  coherence
  proof
    set i=(a,k1)<>0_goto k2;
A1: InsCode halt SCMPDS=0 by SCMPDS_2:21,93;
    InsCode i=4 by SCMPDS_2:25;
    hence thesis by A1,Def1;
  end;
  cluster (a,k1)<=0_goto k2 -> No-StopCode;
  coherence
  proof
    set i=(a,k1)<=0_goto k2;
A2: InsCode halt SCMPDS=0 by SCMPDS_2:21,93;
    InsCode i=5 by SCMPDS_2:26;
    hence thesis by A2,Def1;
  end;
  cluster (a,k1)>=0_goto k2 -> No-StopCode;
  coherence
  proof
    set i=(a,k1)>=0_goto k2;
A3: InsCode halt SCMPDS=0 by SCMPDS_2:21,93;
    InsCode i=6 by SCMPDS_2:27;
    hence thesis by A3,Def1;
  end;
  cluster (a,k1) := k2 -> No-StopCode;
  coherence
  proof
    set i=(a,k1) := k2;
A4: InsCode halt SCMPDS=0 by SCMPDS_2:21,93;
    InsCode i=7 by SCMPDS_2:28;
    hence thesis by A4,Def1;
  end;
end;

registration
  let a,k1,k2;
  cluster AddTo(a,k1,k2) -> No-StopCode;
  coherence
  proof
    set i=AddTo(a,k1,k2);
A1: InsCode halt SCMPDS=0 by SCMPDS_2:21,93;
    InsCode i=8 by SCMPDS_2:29;
    hence thesis by A1,Def1;
  end;
end;

registration
  let a,b,k1,k2;
  cluster AddTo(a,k1,b,k2) -> No-StopCode;
  coherence
  proof
    set i=AddTo(a,k1,b,k2);
A1: InsCode halt SCMPDS=0 by SCMPDS_2:21,93;
    InsCode i=9 by SCMPDS_2:30;
    hence thesis by A1,Def1;
  end;
  cluster SubFrom(a,k1,b,k2) -> No-StopCode;
  coherence
  proof
    set i=SubFrom(a,k1,b,k2);
A2: InsCode halt SCMPDS=0 by SCMPDS_2:21,93;
    InsCode i=10 by SCMPDS_2:31;
    hence thesis by A2,Def1;
  end;
  cluster MultBy(a,k1,b,k2) -> No-StopCode;
  coherence
  proof
    set i=MultBy(a,k1,b,k2);
A3: InsCode halt SCMPDS=0 by SCMPDS_2:21,93;
    InsCode i=11 by SCMPDS_2:32;
    hence thesis by A3,Def1;
  end;
  cluster Divide(a,k1,b,k2) -> No-StopCode;
  coherence
  proof
    set i=Divide(a,k1,b,k2);
A4: InsCode halt SCMPDS=0 by SCMPDS_2:21,93;
    InsCode i=12 by SCMPDS_2:33;
    hence thesis by A4,Def1;
  end;
  cluster (a,k1) := (b,k2) -> No-StopCode;
  coherence
  proof
    set i=(a,k1) := (b,k2);
A5: InsCode halt SCMPDS=0 by SCMPDS_2:21,93;
    InsCode i=13 by SCMPDS_2:34;
    hence thesis by A5,Def1;
  end;
end;

registration
  cluster halt SCMPDS -> parahalting;
  coherence
  proof
    Stop SCMPDS=Load halt SCMPDS;
    hence thesis by Def2;
  end;
end;

registration
  let i be parahalting Instruction of SCMPDS;
  cluster Load i -> parahalting;
  coherence by Def2;
end;

Lm2: (for s holds Exec(i,s).IC SCMPDS = succ IC s) implies Load i is
parahalting

proof
  set SA0 = Start-At( 0,SCMPDS);
  assume
A1: for s holds Exec(i,s).IC SCMPDS = succ IC s;
  set m0= stop Load i, m1 = Initialized m0;
  let t be State of SCMPDS such that
A2: m1 c= t;
A3: m0 c= t by A2,SCMPDS_4:57;
  take 1;
     IC Comput(ProgramPart(t),t,1) in NAT;
    hence IC Comput(ProgramPart(t),t,1) in dom ProgramPart t by AMI_1:143;
  dom SA0 = {IC SCMPDS} by FUNCOP_1:19;
  then
A4: IC SCMPDS in dom SA0 by TARSKI:def 1;
  SA0 c= m1 by FUNCT_4:26;
  then SA0 c= t by A2,XBOOLE_1:1;
  then
A5: IC t = SA0.IC SCMPDS by A4,GRFUNC_1:8
    .=  0 by FUNCOP_1:87;
  then
A6: IC Exec(i, t) = succ  0 by A1
    .=  (0+1);
   1 in dom m0 by Th9;
  then m0. 1 = t. 1 by A3,GRFUNC_1:8;
  then
A7: t. 1 = halt SCMPDS by Th10;
   0 in dom m0 by Th9;
  then
A8: m0. 0 = t. 0 by A3,GRFUNC_1:8;
Z:  (ProgramPart Comput(ProgramPart(t),t,1))/.IC Comput(ProgramPart(t),t,1)
 = Comput(ProgramPart(t),t,1).IC Comput(ProgramPart(t),t,1) by AMI_1:150;
V:  (ProgramPart t)/.IC t
 = t.IC t by AMI_1:150;
  Comput(ProgramPart(t),t,0+1)
   = Following(ProgramPart t,Comput(ProgramPart(t),t,0
))
   by AMI_1:14
    .= Following(ProgramPart t,t) by AMI_1:13
    .= Exec(i,t) by A5,A8,Th10,V;
   then CurInstr(ProgramPart Comput(ProgramPart(t),t,1),Comput(ProgramPart(t),t
,1))
    = halt SCMPDS by A6,A7,AMI_1:def 13,Z;
  hence thesis by AMI_1:145;
end;

registration
  let a,k1;
  cluster a := k1 -> parahalting;
  coherence
  proof
    set i= a:=k1;
    for s holds Exec(i,s).IC SCMPDS = succ IC s by SCMPDS_2:57;
    then Load i is parahalting by Lm2;
    hence thesis by Def2;
  end;
end;

registration
  let a,k1,k2;
  cluster (a,k1) := k2 -> parahalting;
  coherence
  proof
    set i= (a,k1) := k2;
    for s holds Exec(i,s).IC SCMPDS = succ IC s by SCMPDS_2:58;
    then Load i is parahalting by Lm2;
    hence thesis by Def2;
  end;
  cluster AddTo(a,k1,k2) -> parahalting;
  coherence
  proof
    set i= AddTo(a,k1,k2);
    for s holds Exec(i,s).IC SCMPDS = succ IC s by SCMPDS_2:60;
    then Load i is parahalting by Lm2;
    hence thesis by Def2;
  end;
end;

registration
  let a,b,k1,k2;
  cluster AddTo(a,k1,b,k2) -> parahalting;
  coherence
  proof
    set i= AddTo(a,k1,b,k2);
    for s holds Exec(i,s).IC SCMPDS = succ IC s by SCMPDS_2:61;
    then Load i is parahalting by Lm2;
    hence thesis by Def2;
  end;
  cluster SubFrom(a,k1,b,k2) -> parahalting;
  coherence
  proof
    set i= SubFrom(a,k1,b,k2);
    for s holds Exec(i,s).IC SCMPDS = succ IC s by SCMPDS_2:62;
    then Load i is parahalting by Lm2;
    hence thesis by Def2;
  end;
  cluster MultBy(a,k1,b,k2) -> parahalting;
  coherence
  proof
    set i= MultBy(a,k1,b,k2);
    for s holds Exec(i,s).IC SCMPDS = succ IC s by SCMPDS_2:63;
    then Load i is parahalting by Lm2;
    hence thesis by Def2;
  end;
  cluster Divide(a,k1,b,k2) -> parahalting;
  coherence
  proof
    set i= Divide(a,k1,b,k2);
    for s holds Exec(i,s).IC SCMPDS = succ IC s by SCMPDS_2:64;
    then Load i is parahalting by Lm2;
    hence thesis by Def2;
  end;
  cluster (a,k1) := (b,k2) -> parahalting;
  coherence
  proof
    set i= (a,k1) := (b,k2);
    for s holds Exec(i,s).IC SCMPDS = succ IC s by SCMPDS_2:59;
    then Load i is parahalting by Lm2;
    hence thesis by Def2;
  end;
end;

theorem Th26:
  InsCode i =1 implies i is not parahalting
proof
  consider s such that
A1: for a holds s.a = 2 by SCMPDS_2:73;
  assume
  InsCode i=1;
  then consider a such that
A2: i = return a by SCMPDS_2:36;
  assume
  i is parahalting;
  then reconsider Li = Load i as parahalting Program of SCMPDS;
  set pi=stop Li, Ii=Initialized pi;
  set s1=s +* Ii;
  s1.DataLoc(s1.a,RetIC)=s.DataLoc(s1.a,RetIC) by Th19
    .=2 by A1;
  then
A3: Exec(i, s1).IC SCMPDS =(abs(2))+2 by A2,SCMPDS_2:70
    .=(2)+2 by ABSVALUE:def 1
    .= 4;
  set C1=Comput(ProgramPart(s1),s1,1);
  Ii c= s1 by FUNCT_4:26;
  then
A4: IC C1 in dom pi by SCMPDS_4:def 9;
   0 in dom Ii by Th13;
  then
A5: s1. 0=Ii. 0 by FUNCT_4:14
    .=i by Th13;
A6: card pi = 2 by Th8;
Y:  (ProgramPart s1)/.IC s1
 = s1.IC s1 by AMI_1:150;
  Comput(ProgramPart(s1),s1,0+1)
   = Following(ProgramPart s1,Comput(ProgramPart(s1),
s1,0))
   by AMI_1:14
    .= Following(ProgramPart s1,s1) by AMI_1:13
    .= Exec(i, s1) by A5,Th18,FUNCT_4:26,Y;
  hence contradiction by A3,A4,A6,SCMPDS_4:1;
end;

definition
  let IT be FinPartState of SCMPDS;
  attr IT is No-StopCode means
  :Def3:
  for x being Element of NAT
  st x in dom IT holds IT.x <> halt SCMPDS;
end;

registration
  cluster parahalting shiftable No-StopCode Program of SCMPDS;
  existence
  proof
    set ii=DataLoc(0,0):=0;
    take II=Load ii;
    now
      let x be Element of NAT;
      assume
      x in dom II;
      then x in { 0} by FUNCOP_1:19;
      then x= 0 by TARSKI:def 1;
      then
A1:   II.x=ii by FUNCOP_1:87;
      InsCode ii=2 by SCMPDS_2:23;
      hence II.x <> halt SCMPDS by A1,SCMPDS_2:21,93;
    end;
    hence thesis by Def3;
  end;
end;

registration
  let I,J be No-StopCode Program of SCMPDS;
  cluster I ';' J -> No-StopCode;
  coherence
  proof
    set IJ=I ';' J;
    now
      set D = {n+card I: n in dom J };
      dom Shift(J,card I) = D by VALUED_1:def 12;
      then
A1:   dom IJ = dom I \/ D by FUNCT_4:def 1;
      let x be Element of NAT such that
A2:   x in dom IJ;
      per cases by A2,A1,XBOOLE_0:def 3;
      suppose
A3:     x in dom I;
        then I.x=IJ.x by SCMPDS_4:37;
        hence IJ.x<>halt SCMPDS by A3,Def3;
      end;
      suppose
        x in D;
        then consider n such that
A4:     x = n+card I and
A5:     n in dom J;
        J. n =IJ.x by A4,A5,SCMPDS_4:38;
        hence IJ.x<>halt SCMPDS by A5,Def3;
      end;
    end;
    hence thesis by Def3;
  end;
end;

registration
  let i be No-StopCode Instruction of SCMPDS;
  cluster Load i -> No-StopCode;
  coherence
  proof
    set p=Load i;
    now
      let x be Element of NAT;
      assume
      x in dom p;
      then x =  0 by Th2;
      then p.x=i by FUNCOP_1:87;
      hence p.x <>halt SCMPDS by Def1;
    end;
    hence thesis by Def3;
  end;
end;

registration
  let i be No-StopCode Instruction of SCMPDS, J be No-StopCode Program of
  SCMPDS;
  cluster i ';' J -> No-StopCode;
  coherence;
end;

registration
  let I be No-StopCode Program of SCMPDS, j be No-StopCode Instruction of
  SCMPDS;
  cluster I ';' j -> No-StopCode;
  coherence;
end;

registration
  let i,j be No-StopCode Instruction of SCMPDS;
  cluster i ';' j -> No-StopCode;
  coherence;
end;

theorem Th27:
  for I being parahalting No-StopCode Program of SCMPDS st
  Initialized (stop I) c= s holds IC Comput(ProgramPart( s), s,LifeSpan (s +*
Initialized
  stop(I))) =  card I
proof
  let I be parahalting No-StopCode Program of SCMPDS;
  set IsI=Initialized stop(I);
A1: stop I c= IsI by SCMPDS_4:9;
  set Css= Comput(ProgramPart( s), s,LifeSpan s);
  reconsider n = IC Css as Element of NAT;
  assume
A2: IsI c= s;
  then
A3: ProgramPart s halts_on s by SCMPDS_4:63;
  I c= stop I by SCMPDS_4:40;
  then I c= IsI by A1,XBOOLE_1:1;
  then
A4: I c= s by A2,XBOOLE_1:1;
  now
Y:  (ProgramPart Css)/.IC Css
 = Css.IC Css by AMI_1:150;
    assume
A5: IC Css in dom I;
    then I.IC Css=s.IC Css by A4,GRFUNC_1:8
      .=CurInstr(ProgramPart Css,Css) by AMI_1:54,Y
      .=halt SCMPDS by A3,AMI_1:def 46;
    hence contradiction by A5,Def3;
  end;
  then
A6: n >= card I by SCMPDS_4:1;
A7: card stop I =card I + 1 by SCMPDS_4:45,LL;
  IC Css in dom stop(I) by A2,SCMPDS_4:def 9;
  then n < card I + 1 by A7,SCMPDS_4:1;
  then n <= card I by NAT_1:13;
  then n=card I by A6,XXREAL_0:1;
  hence thesis by A2,FUNCT_4:79;
end;

theorem Th28:
  for I being parahalting Program of SCMPDS,k be Element of NAT st
k < LifeSpan (s +* Initialized stop(I)) holds IC Comput(ProgramPart( (s +*
Initialized
  stop(I))), (s +* Initialized
  stop(I)),k) in dom I
proof
  let I be parahalting Program of SCMPDS,k be Element of NAT;
  set IsI=Initialized stop(I), ss= s +* IsI, m=LifeSpan ss;
  set Sk= Comput(ProgramPart( ss), ss,k), Ik=IC Sk;
A1: ProgramPart ss halts_on ss by FUNCT_4:26,SCMPDS_4:63;
  reconsider n = Ik as Element of NAT;
A2: IsI c= ss by FUNCT_4:26;
  then
A3: Ik in dom stop(I) by SCMPDS_4:def 9;
  stop I c= IsI by SCMPDS_4:9;
  then
A4: stop I c= ss by A2,XBOOLE_1:1;
  assume
A5: k < m;
A6: now
Y:  (ProgramPart Sk)/.IC Sk
 = Sk.IC Sk by AMI_1:150;
    assume
A7: n = card I;
y:  0 in dom Stop SCMPDS by SCMNORM:2;
x: (Stop SCMPDS). 0 = halt SCMPDS by AFINSQ_1:38;
    CurInstr(ProgramPart Sk,Sk) =ss.Ik by AMI_1:54,Y
      .=(stop I).(0+n) by A3,A4,GRFUNC_1:8
      .=halt SCMPDS by A7,SCMPDS_4:38,x,y;
    hence contradiction by A5,A1,AMI_1:def 46;
  end;
  card stop I=card I + 1 by SCMPDS_4:45,LL;
  then n < card I + 1 by A3,SCMPDS_4:1;
  then n <= card I by INT_1:20;
  then n < card I by A6,XXREAL_0:1;
  hence thesis by SCMPDS_4:1;
end;

theorem Th29:
  for I being parahalting Program of SCMPDS,k be Element of NAT st
Initialized I c= s & k <= LifeSpan (s +* Initialized stop(I)) holds Comput(
ProgramPart( s), s,k), Comput(ProgramPart( (s +* Initialized stop(I))), (s +*
Initialized stop(I)),k) equal_outside NAT
proof
  let I be parahalting Program of SCMPDS,k be Element of NAT;
  set II=Initialized I, IsI=Initialized stop(I), m=LifeSpan (s +* IsI);
  assume that
A1: II c= s and
A2: k <= m;
  set s2 = s +* IsI;
  defpred P[Element of NAT] means $1 <= m implies Comput(ProgramPart(s),s,$1),
  Comput(ProgramPart(s2),s2,$1) equal_outside NAT;
A3: s +* IsI = s +* stop(I) by A1,SCMPDS_4:34;
A4: s = s +* II by A1,FUNCT_4:79
    .=s +* I by A1,SCMPDS_4:34;
A5: now
    let k be Element of NAT;
    assume
A6: P[k];
    now
T: ProgramPart s2 = ProgramPart Comput(ProgramPart(s2),s2,k)
by AMI_1:144;
A7:   Comput(ProgramPart(s2),s2,k+1)
 = Following(ProgramPart s2,Comput(ProgramPart(s2),s2
,k))
 by AMI_1:14
        .= Exec(CurInstr(ProgramPart Comput(ProgramPart(s2),s2,k),
        Comput(ProgramPart(s2),s2,k)),Comput(ProgramPart(s2),s2,k)) by T;
T: ProgramPart s = ProgramPart Comput(ProgramPart(s),s,k)
by AMI_1:144;
A8:   Comput(ProgramPart(s),s,k+1)
 = Following(ProgramPart s,Comput(ProgramPart(s),s,k))
by AMI_1:14
        .= Exec(CurInstr(ProgramPart Comput(ProgramPart(s),s,k),Comput(
ProgramPart(s),s,k)),
        Comput(ProgramPart(s),s,k)) by T;
A9:   k < k+1 by XREAL_1:31;
      assume
A10:  k+1 <= m;
      then k < m by A9,XXREAL_0:2;
      then
A11:  IC Comput(ProgramPart(s2),s2,k) in dom I by Th28;
      then
A12:  IC Comput(ProgramPart(s2),s2,k) in dom (stop I) by FUNCT_4:13;
Y:  (ProgramPart Comput(ProgramPart(s),s,k))/.IC Comput(ProgramPart(s),s,k)
 = Comput(ProgramPart(s),s,k).IC Comput(ProgramPart(s),s,k) by AMI_1:150;
Z:  (ProgramPart Comput(ProgramPart(s2),s2,k))/.IC Comput(ProgramPart(s2),s2,k)
 = Comput(ProgramPart(s2),s2,k).IC Comput(ProgramPart(s2),s2,k) by AMI_1:150;
      IC Comput(ProgramPart(s),s,k) = IC Comput(ProgramPart(s2),s2,k) by A6,A10
,A9,AMI_1:121
,XXREAL_0:2;
      then CurInstr(ProgramPart Comput(ProgramPart(s),s,k),Comput(ProgramPart(s
),s,k))
       = s.IC Comput(ProgramPart(s2),s2,k) by AMI_1:54,Y
        .= I.IC Comput(ProgramPart(s2),s2,k) by A4,A11,FUNCT_4:14
        .= (stop I).IC Comput(ProgramPart(s2),s2,k) by A11,SCMPDS_4:37
        .= (s +* IsI).IC Comput(ProgramPart(s2),s2,k) by A3,A12,FUNCT_4:14
        .= CurInstr(ProgramPart Comput(ProgramPart(s2),s2,k),Comput(ProgramPart
(s2),s2,k))
         by AMI_1:54,Z;
      hence Comput(ProgramPart(s),s,k+1),Comput(ProgramPart(s2),s2,k+1)
equal_outside NAT by A6,A10
,A9,A8,A7,SCMPDS_4:15,XXREAL_0:2;
    end;
    hence P[k+1];
  end;
A13: P[0]
  proof
    assume
    0 <= m;
A14: Comput(ProgramPart(s2),s2,0)=s +* IsI by AMI_1:13;
    Comput(ProgramPart(s),s,0)=s by AMI_1:13;
    hence thesis by A3,A14,AMI_1:120;
  end;
  for k be Element of NAT holds P[k] from NAT_1:sch 1(A13,A5);
  hence thesis by A2;
end;

theorem Th30:
  for I being parahalting No-StopCode Program of SCMPDS st
Initialized I c= s holds IC Comput(ProgramPart(s),s,LifeSpan (s +* Initialized
stop(I)))
  =  card I
proof
  let I be parahalting No-StopCode Program of SCMPDS;
  set IsI=Initialized stop(I), ss = s +* IsI, m=LifeSpan ss;
A1: IsI c= ss by FUNCT_4:26;
  assume
  Initialized I c= s;
  hence IC Comput(ProgramPart(s),s,m) = IC Comput(ProgramPart( ss), ss,m) by
Th29,AMI_1:121
    .=IC Comput(ProgramPart( ss), ss,LifeSpan (ss +* IsI)) by A1,FUNCT_4:79
    .= card I by Th27,FUNCT_4:26;
end;

theorem Th31:
  for I being parahalting Program of SCMPDS st Initialized I c= s
  holds CurInstr(
   ProgramPart Comput(ProgramPart( s), s,LifeSpan (s +* Initialized stop(I))),
   Comput(ProgramPart( s), s,LifeSpan (s +* Initialized stop(I))))
   = halt
SCMPDS or IC Comput(ProgramPart( s), s,LifeSpan (s +* Initialized stop(I))) =
card
  I
proof
  let I be parahalting Program of SCMPDS;
  set IsI=Initialized stop(I), ss = s +* IsI, m=LifeSpan ss;
  set s1=Comput(ProgramPart(s),s,m), s2= Comput(ProgramPart( ss), ss,LifeSpan (
ss +* IsI)), Ik = IC
  s2;
A1: ProgramPart ss halts_on ss by FUNCT_4:26,SCMPDS_4:63;
  reconsider n = Ik as Element of NAT;
A2: IsI c= ss by FUNCT_4:26;
  then
A3: Ik in dom stop(I) by SCMPDS_4:def 9;
xx: IsI +* ss = ss & ss +* IsI = ss by A2,FUNCT_4:79;
  card stop I = card I + 1 by SCMPDS_4:45,LL;
  then n < card I + 1 by A3,SCMPDS_4:1;
  then
A4: n <= card I by INT_1:20;
  stop I c= IsI by SCMPDS_4:9;
  then
A5: stop I c= ss by A2,XBOOLE_1:1;
  assume
A6: Initialized I c= s;
  then
A7: IC s1 = IC Comput(ProgramPart( ss), ss,m) by Th29,AMI_1:121
    .=Ik by A2,FUNCT_4:79;
A8: I c= s by A6,SCMPDS_4:57;
  now
    per cases by A4,XXREAL_0:1;
    case
      n < card I;
      then
A9:    n in dom I by SCMPDS_4:1;
Z:  (ProgramPart s1)/.IC s1
 = s1.IC s1 by AMI_1:150;
V:  (ProgramPart s2)/.IC s2
 = s2.IC s2 by AMI_1:150;
      thus halt SCMPDS
       = CurInstr(ProgramPart Comput(ProgramPart( ss), ss,LifeSpan ss),
       Comput(ProgramPart( ss), ss,LifeSpan ss)) by A1,
AMI_1:def 46
        .= CurInstr(ProgramPart s2,s2) by xx
        .=ss.Ik by AMI_1:54,V
        .=(stop I).Ik by A3,A5,GRFUNC_1:8
        .=I.Ik by A9,SCMPDS_4:37
        .=s.IC s1 by A8,A7,A9,GRFUNC_1:8
        .=CurInstr(ProgramPart s1,s1) by AMI_1:54,Z;
    end;
    case
      n = card I;
      hence IC s1=  card I by A7;
    end;
  end;
  hence thesis;
end;

theorem Th32:
  for I being parahalting No-StopCode Program of SCMPDS,k being
Element of NAT st Initialized I c= s & k < LifeSpan (s +* Initialized stop(I))
  holds CurInstr(ProgramPart Comput(ProgramPart(s),s,k),Comput(ProgramPart(s),s
,k)) <> halt SCMPDS
proof
  let I be parahalting No-StopCode Program of SCMPDS,k be Element of NAT;
  set sI=s +* Initialized stop(I), s1= Comput(ProgramPart( s), s,k), s2= Comput
(ProgramPart( sI), sI,
  k);
  assume that
A1: Initialized I c= s and
A2: k < LifeSpan sI;
A3: I c= s1 by A1,AMI_1:81,SCMPDS_4:57;
A4: IC s2 in dom I by A2,Th28;
Y:  (ProgramPart s1)/.IC s1
 = s1.IC s1 by AMI_1:150;
  CurInstr(ProgramPart s1,s1)=s1.IC s2 by A1,A2,Th29,AMI_1:121,Y
    .=I.IC s2 by A3,A4,GRFUNC_1:8;
  hence thesis by A4,Def3;
end;

theorem Th33:
  for I being parahalting Program of SCMPDS,J being Program of
  SCMPDS, k being Element of NAT st k <= LifeSpan (s +* Initialized stop(I))
holds Comput(ProgramPart( (s +* Initialized stop I )), (s +* Initialized stop I
),k), Comput(ProgramPart( (s +* ((I ';' J)
  +* Start-At( 0,SCMPDS)))), (s +* ((I ';' J)
  +* Start-At( 0,SCMPDS))),k) equal_outside NAT
proof
  let I be parahalting Program of SCMPDS,J be Program of SCMPDS, k be Element
  of NAT;
  set SA0=Start-At( 0,SCMPDS), spI= stop I, IsI=Initialized spI;
  set s1 = s +* IsI;
  set s2 = s +* ((I ';' J) +* SA0);
  set n=LifeSpan s1;
A1: s1 =s +* spI +* SA0 by FUNCT_4:15
    .=s+*SA0+* spI by SCMPDS_4:62;
  defpred X[Element of NAT] means $1 <= n implies Comput(ProgramPart(s1),s1,$1)
,
  Comput(ProgramPart(s2),s2,$1) equal_outside NAT;
A2: s2 = s +* (I ';' J) +* SA0 by FUNCT_4:15
    .= s+*SA0+*(I ';' J) by SCMPDS_4:62;
A3: IsI c= s1 by FUNCT_4:26;
A4: for n being Element of NAT st X[n] holds X[n+1]
  proof
    let m be Element of NAT;
    assume
A5: m <= n implies Comput(ProgramPart(s1),s1,m), Comput(ProgramPart(s2),s2,m)
equal_outside
    NAT;
T: ProgramPart s2 = ProgramPart Comput(ProgramPart(s2),s2,m)
by AMI_1:144;
A6: Comput(ProgramPart(s2),s2,m+1)
 = Following(ProgramPart s2,Comput(ProgramPart(s2),s2
,m))
 by AMI_1:14
      .= Exec(CurInstr(ProgramPart Comput(ProgramPart(s2),s2,m),Comput(
ProgramPart(s2),s2,m)),
      Comput(ProgramPart(s2),s2,m)) by T;
A7: IC Comput(ProgramPart(s1),s1,m) in dom spI by A3,SCMPDS_4:def 9;
T: ProgramPart s1 = ProgramPart Comput(ProgramPart(
s1),s1,m)
by AMI_1:144;
A8: Comput(ProgramPart(s1),s1,m+1) = Following(ProgramPart s1,
Comput(ProgramPart(s1),s1,m)) by AMI_1:14
      .= Exec(CurInstr(ProgramPart Comput(ProgramPart(s1),s1,m),Comput(
ProgramPart(s1),s1,m)),
      Comput(ProgramPart(s1),s1,m)) by T;
    assume
A9: m+1 <= n;
    then
A10: IC Comput(ProgramPart(s1),s1,m) = IC Comput(ProgramPart(s2),s2,m) by A5,
AMI_1:121,NAT_1:13;
    m < n by A9,NAT_1:13;
    then
A11: IC Comput(ProgramPart(s1),s1,m) in dom I by Th28;
    then
A12: IC Comput(ProgramPart(s1),s1,m) in dom (I ';' J) by FUNCT_4:13;
Y:  (ProgramPart Comput(ProgramPart(s1),s1,m))/.IC Comput(ProgramPart(s1),s1,m)
 = Comput(ProgramPart(s1),s1,m).IC Comput(ProgramPart(s1),s1,m) by AMI_1:150;
Z:  (ProgramPart Comput(ProgramPart(s2),s2,m))/.IC Comput(ProgramPart(s2),s2,m)
 = Comput(ProgramPart(s2),s2,m).IC Comput(ProgramPart(s2),s2,m) by AMI_1:150;
    CurInstr(ProgramPart Comput(ProgramPart(s1),s1,m),Comput(ProgramPart(s1),s1
,m))
     = s1.IC Comput(ProgramPart(s1),s1,m) by AMI_1:54,Y
      .= spI.IC Comput(ProgramPart(s1),s1,m) by A1,A7,FUNCT_4:14
      .= I.IC Comput(ProgramPart(s1),s1,m) by A11,SCMPDS_4:37
      .= (I ';' J).IC Comput(ProgramPart(s1),s1,m) by A11,SCMPDS_4:37
      .= s2.IC Comput(ProgramPart(s1),s1,m) by A2,A12,FUNCT_4:14
      .=CurInstr(ProgramPart Comput(ProgramPart(s2),s2,m),Comput(ProgramPart(s2
),s2,m))
       by A10,AMI_1:54,Z;
    hence thesis by A5,A9,A8,A6,NAT_1:13,SCMPDS_4:15;
  end;
A13: Comput(ProgramPart(s2),s2,0) = s2 by AMI_1:13;
A14: Comput(ProgramPart(s1),s1,0) = s1 by AMI_1:13;
A15: s +* SA0, s +* SA0 +* (I ';' J) equal_outside NAT by AMI_1:120;
  s +* SA0 +* spI, s +* SA0 equal_outside NAT by AMI_1:120,FUNCT_7:28;
  then
A16: X[0] by A1,A2,A15,A14,A13,FUNCT_7:29;
A17: for k being Element of NAT holds X[k] from NAT_1:sch 1(A16, A4);
  assume
  k <= n;
  hence thesis by A17;
end;

theorem Th34:
  for I being parahalting Program of SCMPDS,J being Program of
  SCMPDS, k being Element of NAT st k <= LifeSpan (s +* Initialized stop(I))
  holds Comput(ProgramPart( (s +* Initialized stop I )), (s +* Initialized stop
I ),k), Comput(ProgramPart( (s +*
  Initialized stop (I ';' J))), (s +*
  Initialized stop (I ';' J)),k) equal_outside NAT
proof
  let I be parahalting Program of SCMPDS,J be Program of SCMPDS, k be Element
  of NAT;
A1: Initialized stop (I ';' J) = (I ';' (J ';' Stop SCMPDS)) +* Start-At(
   0,SCMPDS) by SCMPDS_4:46;
  assume
  k <= LifeSpan (s +* Initialized stop I);
  hence thesis by A1,Th33;
end;

registration
  let I be parahalting Program of SCMPDS, J be parahalting shiftable Program
  of SCMPDS;
  cluster I ';' J -> parahalting;
  coherence
  proof
    let s be State of SCMPDS;
    set sIJ = stop(I ';' J), IsIJ = Initialized sIJ;
    set spJ = stop J, IsJ = Initialized spJ, s1 = s +* Initialized stop(I), m1
    = LifeSpan s1, s3 = Comput(ProgramPart( s1), s1,m1) +* IsJ, m3 = LifeSpan
s3, D =
    SCM-Data-Loc;
A1: DataPart s3 = DataPart Comput(ProgramPart( s1), s1,m1) +* DataPart IsJ by
FUNCT_4:75;
A2: now
      let x be set;
      assume
      x in dom (DataPart IsJ);
      then
A3:   x in dom IsJ /\ D by RELAT_1:90,SCMPDS_2:100;
      then
A4:   x in dom IsJ by XBOOLE_0:def 4;
A5:   x in D by A3,XBOOLE_0:def 4;
      per cases by A4,SCMPDS_4:28;
      suppose
A6:     x in dom spJ;
        dom spJ c= NAT by RELAT_1:def 18;
        then reconsider l=x as Element of NAT by A6
;
        (DataPart IsJ).l = (DataPart Comput(ProgramPart( s1), s1,m1)).l by A5,
SCMPDS_4:22;
        hence (DataPart IsJ).x = (DataPart Comput(ProgramPart( s1), s1,m1)).x;
      end;
      suppose
        x = IC SCMPDS;
        hence (DataPart IsJ).x = (DataPart Comput(ProgramPart( s1), s1,m1)).x
by A3,
SCMPDS_3:6,XBOOLE_0:def 4;
      end;
    end;
A7: dom (DataPart IsJ) = dom IsJ /\ D by RELAT_1:90,SCMPDS_2:100;
A8: IsJ c= s3 by FUNCT_4:26;
    then
A9: ProgramPart s3 halts_on s3 by AMI_1:def 26;
    dom IsJ c= dom s3 by A8,GRFUNC_1:8;
    then dom IsJ c= the carrier of SCMPDS by PARTFUN1:def 4;
    then dom (DataPart IsJ) c= (the carrier of SCMPDS) /\ D by A7,XBOOLE_1:26;
    then dom (DataPart IsJ) c= dom ( Comput(ProgramPart( s1), s1,m1)) /\ D by
PARTFUN1:def 4;
    then dom (DataPart IsJ) c= dom (DataPart Comput(ProgramPart( s1), s1,m1))
by RELAT_1:90
,SCMPDS_2:100;
    then DataPart IsJ c= DataPart Comput(ProgramPart( s1), s1,m1) by A2,
GRFUNC_1:8;
    then
A10: DataPart Comput(ProgramPart(s1),s1,m1) = DataPart s3 by A1,LATTICE2:8;
A11: Initialized I c= IsIJ by Th15;
    set s4 = Comput(ProgramPart(s),s,m1);
    assume
A12: IsIJ c= s;
    then
A13: sIJ c= s by SCMPDS_4:57;
    s = s +* IsIJ by A12,FUNCT_4:79
      .= s +* ((I ';' (J ';' Stop SCMPDS)) +* Start-At( 0,SCMPDS))
      by SCMPDS_4:46
;
    then
A14: DataPart s4 = DataPart s3 by A10,Th33,SCMPDS_4:24;
    per cases by A12,A11,Th31,XBOOLE_1:1;
    suppose
A15:  CurInstr(ProgramPart s4,s4) = halt SCMPDS;
      take m1;
     IC Comput(ProgramPart(s),s,m1) in NAT;
    hence IC Comput(ProgramPart(s),s,m1) in dom ProgramPart s by AMI_1:143;
   CurInstr(ProgramPart Comput(ProgramPart(s),s,m1),Comput(ProgramPart(s),s,m1)
)
    = halt SCMPDS by A15;
  hence thesis by AMI_1:145;
    end;
    suppose
A16:  IC s4 =  card I;
      reconsider m = m1 + m3 as Element of NAT;
      take m;
     IC Comput(ProgramPart(s),s,m) in NAT;
    hence IC Comput(ProgramPart(s),s,m) in dom ProgramPart s by AMI_1:143;
T: ProgramPart s = ProgramPart Comput(ProgramPart(s),s,
m1)
by AMI_1:144;
x: Comput(ProgramPart(s),s,m1+m3)
 = Comput(ProgramPart(s),Comput(ProgramPart(s),s,m1),m3) by AMI_1:51;
      sIJ = I ';' (J ';' Stop SCMPDS) by SCMPDS_4:46
        .= I +* Shift(spJ, card I);
      then Shift(spJ, card I) c= sIJ by FUNCT_4:26;
      then Shift(spJ, card I) c= s by A13,XBOOLE_1:1;
      then Shift(spJ, card I) c= s4 by AMI_1:81;
      then
     CurInstr(ProgramPart Comput(ProgramPart(s3),s3,m3),Comput(ProgramPart(s3),
s3,m3))
 = CurInstr(ProgramPart Comput(ProgramPart(s4),s4,m3),Comput(ProgramPart(s4),s4
,m3)) by A8,A14
,A16,SCMPDS_4:84;
      then
Y:   CurInstr(ProgramPart Comput(ProgramPart(s3),s3,m3),Comput(ProgramPart(s3),
s3,m3))
 = CurInstr(ProgramPart Comput(ProgramPart(s),s,m1+m3),Comput(ProgramPart(s),s,
m1+m3)) by
x,T;
    CurInstr(ProgramPart Comput(ProgramPart(s3),s3,m3),Comput(ProgramPart(s3),
s3,m3))
     = halt SCMPDS by A9,AMI_1:def 46;
   then CurInstr(ProgramPart Comput(ProgramPart(s),s,m),Comput(ProgramPart(s),s
,m))
    = halt SCMPDS by Y;
  hence thesis by AMI_1:145;
    end;
  end;
end;

registration
  let i be parahalting Instruction of SCMPDS, J be parahalting shiftable
  Program of SCMPDS;
  cluster i ';' J -> parahalting;
  coherence;
end;

registration
  let I be parahalting Program of SCMPDS, j be parahalting shiftable
  Instruction of SCMPDS;
  cluster I ';' j -> parahalting;
  coherence;
end;

registration
  let i be parahalting Instruction of SCMPDS, j be parahalting shiftable
  Instruction of SCMPDS;
  cluster i ';' j -> parahalting;
  coherence;
end;

theorem Th35:
  for s,s1 being State of SCMPDS, J being parahalting shiftable
  Program of SCMPDS st s= Comput(ProgramPart( (s1+*Initialized stop J)), (s1+*
Initialized stop J),m) holds Exec(
CurInstr(ProgramPart s,s),s +* Start-At(IC s + n,SCMPDS))
 = Following(ProgramPart s,s) +*
Start-At (IC Following(ProgramPart s,s) + n,SCMPDS)
proof
  let s,s1 be State of SCMPDS, J be parahalting shiftable Program of SCMPDS;
  set pJ=stop J, IsJ=Initialized pJ, s2=s1+*IsJ;
  set i = CurInstr(ProgramPart s,s), ss=s +* Start-At(IC s + n,SCMPDS);
  reconsider k = IC s as Element of NAT;
  reconsider Nl=succ IC s as Element of NAT;
A1: succ IC ss = (k + n + 1) by AMI_1:111
    .= IC (Exec(i, s) +*Start-At (Nl + n,SCMPDS)) by AMI_1:111;
A2: IsJ c= s2 by FUNCT_4:26;
  assume
A3: s=Comput(ProgramPart(s2),s2,m);
  then
A4: IC s in dom pJ by A2,SCMPDS_4:def 9;
  reconsider n1 = IC s as Element of NAT;
  set IEn=IC Exec(i,s)+n;
A5: IC ss = IC s + n by AMI_1:111;
A6: now
    let d be Element of NAT;
    thus Exec(i, ss).d = ss.d by AMI_1:def 13
      .= s.d by AMI_1:112
      .= Exec(i, s).d by AMI_1:def 13
      .= (Exec(i, s) +* Start-At(IEn,SCMPDS)).d by AMI_1:112;
  end;
Y:  (ProgramPart s)/.IC s
 = s.IC s by AMI_1:150;
  pJ c= s by A3,A2,AMI_1:81,SCMPDS_4:57;
  then
A7: i=pJ.( n1) by A4,GRFUNC_1:8,Y;
  then
A8: InsCode i <> 1 by A4,SCMPDS_4:def 12;
A9: i valid_at n1 by A4,A7,SCMPDS_4:def 12;
A10: InsCode i <> 3 by A4,A7,SCMPDS_4:def 12;
  per cases by A8,A10,NAT_1:38,SCMPDS_2:15;
  suppose
    InsCode i = 0;
    then consider k1 such that
A12: i = goto k1 and
A13: n1+k1 >= 0 by A9,SCMPDS_4:def 11;
A14: IC Exec(i,s) =ICplusConst(s,k1) by A12,SCMPDS_2:66;
A15: now
      let b;
      thus Exec(i, ss).b= ss.b by A12,SCMPDS_2:66
        .= s.b by SCMPDS_3:14
        .= Exec(i, s).b by A12,SCMPDS_2:66
        .= (Exec(i, s) +* Start-At(IEn,SCMPDS)).b by SCMPDS_3:14;
    end;
    IC Exec(i, ss) =ICplusConst(ss,k1) by A12,SCMPDS_2:66
      .=IEn by A5,A13,A14,SCMPDS_4:82
      .= IC (Exec(i, s) +* Start-At(IEn,SCMPDS)) by AMI_1:111;
    hence thesis by A6,A15,SCMPDS_2:54;
  end;
  suppose
    InsCode i = 2;
    then consider a,k1 such that
A16: i = a := k1 by SCMPDS_2:37;
A17: now
      let b;
      per cases;
      suppose
A18:    a = b;
        hence Exec(i, ss).b = k1 by A16,SCMPDS_2:57
          .= Exec(i,s).b by A16,A18,SCMPDS_2:57
          .= (Exec(i, s) +* Start-At(IEn,SCMPDS)).b by SCMPDS_3:14;
      end;
      suppose
A19:    a <> b;
        hence Exec(i, ss).b = ss.b by A16,SCMPDS_2:57
          .= s.b by SCMPDS_3:14
          .= Exec(i, s).b by A16,A19,SCMPDS_2:57
          .= (Exec(i, s) +* Start-At(IEn,SCMPDS)).b by SCMPDS_3:14;
      end;
    end;
    IC Exec(i, s) = Nl by A16,SCMPDS_2:57;
    then IC Exec(i, ss) = IC (Exec(i, s) +* Start-At(IEn,SCMPDS))
    by A1,A16,SCMPDS_2:57
;
    hence thesis by A6,A17,SCMPDS_2:54;
  end;
  suppose
    InsCode i = 4;
    then consider a,k1,k2 such that
A20: i = (a,k1)<>0_goto k2 and
A21: n1+k2 >= 0 by A9,SCMPDS_4:def 11;
A22: now
      per cases;
      suppose
A23:    s.DataLoc(s.a,k1) <> 0;
        then
A24:    IC Exec(i,s) =ICplusConst(s,k2) by A20,SCMPDS_2:67;
        ss.DataLoc(s.a,k1) <> 0 by A23,SCMPDS_3:14;
        then ss.DataLoc(ss.a,k1) <> 0 by SCMPDS_3:14;
        hence IC Exec(i, ss) =ICplusConst(ss,k2) by A20,SCMPDS_2:67
          .=IEn by A5,A21,A24,SCMPDS_4:82
          .= IC (Exec(i, s) +* Start-At(IEn,SCMPDS)) by AMI_1:111;
      end;
      suppose
A25:    s.DataLoc(s.a,k1) = 0;
        then ss.DataLoc(s.a,k1) = 0 by SCMPDS_3:14;
        then
A26:    ss.DataLoc(ss.a,k1) = 0 by SCMPDS_3:14;
        IC Exec(i, s) = Nl by A20,A25,SCMPDS_2:67;
        hence IC Exec(i,ss) = IC (Exec(i, s) +* Start-At(IEn,SCMPDS))
        by A1,A20,A26,SCMPDS_2:67;
      end;
    end;
    now
      let b;
      thus Exec(i, ss).b= ss.b by A20,SCMPDS_2:67
        .= s.b by SCMPDS_3:14
        .= Exec(i, s).b by A20,SCMPDS_2:67
        .= (Exec(i, s) +* Start-At(IEn,SCMPDS)).b by SCMPDS_3:14;
    end;
    hence thesis by A6,A22,SCMPDS_2:54;
  end;
  suppose
    InsCode i = 5;
    then consider a,k1,k2 such that
A27: i = (a,k1)<=0_goto k2 and
A28: n1+k2 >= 0 by A9,SCMPDS_4:def 11;
A29: now
      per cases;
      suppose
A30:    s.DataLoc(s.a,k1) <= 0;
        then
A31:    IC Exec(i,s) =ICplusConst(s,k2) by A27,SCMPDS_2:68;
        ss.DataLoc(s.a,k1) <= 0 by A30,SCMPDS_3:14;
        then ss.DataLoc(ss.a,k1) <= 0 by SCMPDS_3:14;
        hence IC Exec(i, ss) =ICplusConst(ss,k2) by A27,SCMPDS_2:68
          .=IEn by A5,A28,A31,SCMPDS_4:82
          .= IC (Exec(i, s) +* Start-At(IEn,SCMPDS)) by AMI_1:111;
      end;
      suppose
A32:    s.DataLoc(s.a,k1) > 0;
        then ss.DataLoc(s.a,k1) > 0 by SCMPDS_3:14;
        then
A33:    ss.DataLoc(ss.a,k1) > 0 by SCMPDS_3:14;
        IC Exec(i, s) = Nl by A27,A32,SCMPDS_2:68;
        hence IC Exec(i,ss) = IC (Exec(i, s) +* Start-At(IEn,SCMPDS))
        by A1,A27,A33,SCMPDS_2:68;
      end;
    end;
    now
      let b;
      thus Exec(i, ss).b= ss.b by A27,SCMPDS_2:68
        .= s.b by SCMPDS_3:14
        .= Exec(i, s).b by A27,SCMPDS_2:68
        .= (Exec(i, s) +* Start-At(IEn,SCMPDS)).b by SCMPDS_3:14;
    end;
    hence thesis by A6,A29,SCMPDS_2:54;
  end;
  suppose
    InsCode i = 6;
    then consider a,k1,k2 such that
A34: i = (a,k1)>=0_goto k2 and
A35: n1+k2 >= 0 by A9,SCMPDS_4:def 11;
A36: now
      per cases;
      suppose
A37:    s.DataLoc(s.a,k1) >= 0;
        then
A38:    IC Exec(i,s) =ICplusConst(s,k2) by A34,SCMPDS_2:69;
        ss.DataLoc(s.a,k1) >= 0 by A37,SCMPDS_3:14;
        then ss.DataLoc(ss.a,k1) >= 0 by SCMPDS_3:14;
        hence IC Exec(i, ss) =ICplusConst(ss,k2) by A34,SCMPDS_2:69
          .=IEn by A5,A35,A38,SCMPDS_4:82
          .= IC (Exec(i, s) +* Start-At(IEn,SCMPDS)) by AMI_1:111;
      end;
      suppose
A39:    s.DataLoc(s.a,k1) < 0;
        then ss.DataLoc(s.a,k1) < 0 by SCMPDS_3:14;
        then
A40:    ss.DataLoc(ss.a,k1) < 0 by SCMPDS_3:14;
        IC Exec(i, s) = Nl by A34,A39,SCMPDS_2:69;
        hence IC Exec(i,ss) = IC (Exec(i, s) +* Start-At(IEn,SCMPDS))
        by A1,A34,A40,SCMPDS_2:69;
      end;
    end;
    now
      let b;
      thus Exec(i, ss).b= ss.b by A34,SCMPDS_2:69
        .= s.b by SCMPDS_3:14
        .= Exec(i, s).b by A34,SCMPDS_2:69
        .= (Exec(i, s) +* Start-At(IEn,SCMPDS)).b by SCMPDS_3:14;
    end;
    hence thesis by A6,A36,SCMPDS_2:54;
  end;
  suppose
    InsCode i = 7;
    then consider a,k1,k2 such that
A41: i = (a,k1) := k2 by SCMPDS_2:42;
A42: now
      let b;
      per cases;
      suppose
A43:    DataLoc(ss.a,k1) = b;
        then
A44:    DataLoc(s.a,k1) = b by SCMPDS_3:14;
        thus Exec(i, ss).b = k2 by A41,A43,SCMPDS_2:58
          .= Exec(i,s).b by A41,A44,SCMPDS_2:58
          .= (Exec(i, s) +* Start-At(IEn,SCMPDS)).b by SCMPDS_3:14;
      end;
      suppose
A45:    DataLoc(ss.a,k1) <> b;
        then
A46:    DataLoc(s.a,k1) <> b by SCMPDS_3:14;
        thus Exec(i, ss).b = ss.b by A41,A45,SCMPDS_2:58
          .= s.b by SCMPDS_3:14
          .= Exec(i, s).b by A41,A46,SCMPDS_2:58
          .= (Exec(i, s) +* Start-At(IEn,SCMPDS)).b by SCMPDS_3:14;
      end;
    end;
    IC Exec(i, s) = Nl by A41,SCMPDS_2:58;
    then IC Exec(i, ss) = IC (Exec(i, s) +* Start-At(IEn,SCMPDS))
    by A1,A41,SCMPDS_2:58
;
    hence thesis by A6,A42,SCMPDS_2:54;
    thus thesis;
  end;
  suppose
    InsCode i = 8;
    then consider a,k1,k2 such that
A47: i = AddTo(a,k1,k2) by SCMPDS_2:43;
A48: now
      let b;
      per cases;
      suppose
A49:    DataLoc(ss.a,k1) = b;
        then
A50:    DataLoc(s.a,k1) = b by SCMPDS_3:14;
        thus Exec(i, ss).b = ss.b + k2 by A47,A49,SCMPDS_2:60
          .= s.b + k2 by SCMPDS_3:14
          .= Exec(i, s).b by A47,A50,SCMPDS_2:60
          .= (Exec(i, s) +* Start-At(IEn,SCMPDS)).b by SCMPDS_3:14;
      end;
      suppose
A51:    DataLoc(ss.a,k1) <> b;
        then
A52:    DataLoc(s.a,k1) <> b by SCMPDS_3:14;
        thus Exec(i, ss).b = ss.b by A47,A51,SCMPDS_2:60
          .= s.b by SCMPDS_3:14
          .= Exec(i, s).b by A47,A52,SCMPDS_2:60
          .= (Exec(i, s) +* Start-At(IEn,SCMPDS)).b by SCMPDS_3:14;
      end;
    end;
    IC Exec(i, s) = Nl by A47,SCMPDS_2:60;
    then IC Exec(i, ss) = IC (Exec(i, s) +* Start-At(IEn,SCMPDS))
    by A1,A47,SCMPDS_2:60
;
    hence thesis by A6,A48,SCMPDS_2:54;
  end;
  suppose
    InsCode i = 9;
    then consider a,b,k1,k2 such that
A53: i = AddTo(a,k1,b,k2) by SCMPDS_2:44;
A54: now
      let c;
      per cases;
      suppose
A55:    DataLoc(ss.a,k1) = c;
        then
A56:    DataLoc(s.a,k1) = c by SCMPDS_3:14;
A57:    ss.DataLoc(ss.b,k2) =s.DataLoc(ss.b,k2) by SCMPDS_3:14
          .=s.DataLoc(s.b,k2) by SCMPDS_3:14;
        ss.DataLoc(ss.a,k1) =s.DataLoc(ss.a,k1) by SCMPDS_3:14
          .=s.DataLoc(s.a,k1) by SCMPDS_3:14;
        hence
        Exec(i, ss).c = s.DataLoc(s.a,k1) + s.DataLoc(s.b,k2) by A53,A55,A57,
SCMPDS_2:61
          .= Exec(i, s).c by A53,A56,SCMPDS_2:61
          .= (Exec(i, s) +* Start-At(IEn,SCMPDS)).c by SCMPDS_3:14;
      end;
      suppose
A58:    DataLoc(ss.a,k1) <> c;
        then
A59:    DataLoc(s.a,k1) <> c by SCMPDS_3:14;
        thus Exec(i, ss).c = ss.c by A53,A58,SCMPDS_2:61
          .= s.c by SCMPDS_3:14
          .= Exec(i, s).c by A53,A59,SCMPDS_2:61
          .= (Exec(i, s) +* Start-At(IEn,SCMPDS)).c by SCMPDS_3:14;
      end;
    end;
    IC Exec(i, s) = Nl by A53,SCMPDS_2:61;
    then IC Exec(i, ss) = IC (Exec(i, s) +* Start-At(IEn,SCMPDS))
    by A1,A53,SCMPDS_2:61
;
    hence thesis by A6,A54,SCMPDS_2:54;
  end;
  suppose
    InsCode i = 10;
    then consider a,b,k1,k2 such that
A60: i = SubFrom(a,k1,b,k2) by SCMPDS_2:45;
A61: now
      let c;
      per cases;
      suppose
A62:    DataLoc(ss.a,k1) = c;
        then
A63:    DataLoc(s.a,k1) = c by SCMPDS_3:14;
A64:    ss.DataLoc(ss.b,k2) =s.DataLoc(ss.b,k2) by SCMPDS_3:14
          .=s.DataLoc(s.b,k2) by SCMPDS_3:14;
        ss.DataLoc(ss.a,k1) =s.DataLoc(ss.a,k1) by SCMPDS_3:14
          .=s.DataLoc(s.a,k1) by SCMPDS_3:14;
        hence
        Exec(i, ss).c = s.DataLoc(s.a,k1) - s.DataLoc(s.b,k2) by A60,A62,A64,
SCMPDS_2:62
          .= Exec(i, s).c by A60,A63,SCMPDS_2:62
          .= (Exec(i, s) +* Start-At(IEn,SCMPDS)).c by SCMPDS_3:14;
      end;
      suppose
A65:    DataLoc(ss.a,k1) <> c;
        then
A66:    DataLoc(s.a,k1) <> c by SCMPDS_3:14;
        thus Exec(i, ss).c = ss.c by A60,A65,SCMPDS_2:62
          .= s.c by SCMPDS_3:14
          .= Exec(i, s).c by A60,A66,SCMPDS_2:62
          .= (Exec(i, s) +* Start-At(IEn,SCMPDS)).c by SCMPDS_3:14;
      end;
    end;
    IC Exec(i, s) = Nl by A60,SCMPDS_2:62;
    then IC Exec(i, ss) = IC (Exec(i, s) +* Start-At(IEn,SCMPDS))
    by A1,A60,SCMPDS_2:62
;
    hence thesis by A6,A61,SCMPDS_2:54;
  end;
  suppose
    InsCode i = 11;
    then consider a,b,k1,k2 such that
A67: i = MultBy(a,k1,b,k2) by SCMPDS_2:46;
A68: now
      let c;
      per cases;
      suppose
A69:    DataLoc(ss.a,k1) = c;
        then
A70:    DataLoc(s.a,k1) = c by SCMPDS_3:14;
A71:    ss.DataLoc(ss.b,k2) =s.DataLoc(ss.b,k2) by SCMPDS_3:14
          .=s.DataLoc(s.b,k2) by SCMPDS_3:14;
        ss.DataLoc(ss.a,k1) =s.DataLoc(ss.a,k1) by SCMPDS_3:14
          .=s.DataLoc(s.a,k1) by SCMPDS_3:14;
        hence Exec(i, ss).c = s.DataLoc(s.a,k1) * s.DataLoc(s.b,k2) by A67,A69
,A71,SCMPDS_2:63
          .= Exec(i, s).c by A67,A70,SCMPDS_2:63
          .= (Exec(i, s) +* Start-At(IEn,SCMPDS)).c by SCMPDS_3:14;
      end;
      suppose
A72:    DataLoc(ss.a,k1) <> c;
        then
A73:    DataLoc(s.a,k1) <> c by SCMPDS_3:14;
        thus Exec(i, ss).c = ss.c by A67,A72,SCMPDS_2:63
          .= s.c by SCMPDS_3:14
          .= Exec(i, s).c by A67,A73,SCMPDS_2:63
          .= (Exec(i, s) +* Start-At(IEn,SCMPDS)).c by SCMPDS_3:14;
      end;
    end;
    IC Exec(i, s) = Nl by A67,SCMPDS_2:63;
    then IC Exec(i, ss) = IC (Exec(i, s) +* Start-At(IEn,SCMPDS))
    by A1,A67,SCMPDS_2:63
;
    hence thesis by A6,A68,SCMPDS_2:54;
  end;
  suppose
    InsCode i = 12;
    then consider a,b,k1,k2 such that
A74: i = Divide(a,k1,b,k2) by SCMPDS_2:47;
A75: now
      let c;
A76:  ss.DataLoc(ss.a,k1) =s.DataLoc(ss.a,k1) by SCMPDS_3:14
        .=s.DataLoc(s.a,k1) by SCMPDS_3:14;
A77:  ss.DataLoc(ss.b,k2) =s.DataLoc(ss.b,k2) by SCMPDS_3:14
        .=s.DataLoc(s.b,k2) by SCMPDS_3:14;
      per cases;
      suppose
A78:    DataLoc(ss.b,k2) = c;
        then
A79:    DataLoc(s.b,k2) = c by SCMPDS_3:14;
        thus Exec(i, ss).c = s.DataLoc(s.a,k1) mod s.DataLoc(s.b,k2) by A74,A76
,A77,A78,SCMPDS_2:64
          .= Exec(i, s).c by A74,A79,SCMPDS_2:64
          .= (Exec(i, s) +* Start-At(IEn,SCMPDS)).c by SCMPDS_3:14;
      end;
      suppose
A80:    DataLoc(ss.b,k2) <> c;
        then
A81:    DataLoc(s.b,k2) <> c by SCMPDS_3:14;
        hereby
          per cases;
          suppose
A82:        DataLoc(ss.a,k1) <> c;
            then
A83:        DataLoc(s.a,k1) <> c by SCMPDS_3:14;
            thus Exec(i, ss).c = ss.c by A74,A80,A82,SCMPDS_2:64
              .=s.c by SCMPDS_3:14
              .=Exec(i,s).c by A74,A81,A83,SCMPDS_2:64
              .= (Exec(i, s) +* Start-At(IEn,SCMPDS)).c by SCMPDS_3:14;
          end;
          suppose
A84:        DataLoc(ss.a,k1) = c;
            then
A85:        DataLoc(s.a,k1) = c by SCMPDS_3:14;
            thus Exec(i, ss).c = s.DataLoc(s.a,k1) div s.DataLoc(s.b,k2) by A74
,A76,A77,A80,A84,SCMPDS_2:64
              .= Exec(i,s).c by A74,A81,A85,SCMPDS_2:64
              .= (Exec(i, s) +* Start-At(IEn,SCMPDS)).c by SCMPDS_3:14;
          end;
        end;
      end;
    end;
    IC Exec(i, s) = Nl by A74,SCMPDS_2:64;
    then IC Exec(i, ss) = IC (Exec(i, s) +* Start-At(IEn,SCMPDS))
    by A1,A74,SCMPDS_2:64
;
    hence thesis by A6,A75,SCMPDS_2:54;
  end;
  suppose
    InsCode i = 13;
    then consider a,b,k1,k2 such that
A86: i = (a,k1):=(b,k2) by SCMPDS_2:48;
A87: now
      let c;
      per cases;
      suppose
A88:    DataLoc(ss.a,k1) = c;
        then
A89:    DataLoc(s.a,k1) = c by SCMPDS_3:14;
        thus Exec(i, ss).c = ss.DataLoc(ss.b,k2) by A86,A88,SCMPDS_2:59
          .=s.DataLoc(ss.b,k2) by SCMPDS_3:14
          .=s.DataLoc(s.b,k2) by SCMPDS_3:14
          .=Exec(i,s).c by A86,A89,SCMPDS_2:59
          .= (Exec(i, s) +* Start-At(IEn,SCMPDS)).c by SCMPDS_3:14;
      end;
      suppose
A90:    DataLoc(ss.a,k1) <> c;
        then
A91:    DataLoc(s.a,k1) <> c by SCMPDS_3:14;
        thus Exec(i,ss).c = ss.c by A86,A90,SCMPDS_2:59
          .=s.c by SCMPDS_3:14
          .=Exec(i,s).c by A86,A91,SCMPDS_2:59
          .= (Exec(i, s) +* Start-At(IEn,SCMPDS)).c by SCMPDS_3:14;
      end;
    end;
    IC Exec(i, s) = Nl by A86,SCMPDS_2:59;
    then IC Exec(i, ss) = IC (Exec(i, s) +* Start-At(IEn,SCMPDS))
    by A1,A86,SCMPDS_2:59
;
    hence thesis by A6,A87,SCMPDS_2:54;
  end;
end;

begin :: Computation of two consecutive program blocks

theorem
  for I being parahalting No-StopCode Program of SCMPDS,J being
  parahalting shiftable Program of SCMPDS,k being Element of NAT st Initialized
  stop (I ';' J) c= s holds Comput(ProgramPart( (Result(s +*Initialized stop I)
+*
  Initialized stop J )), (Result(s +*Initialized stop I) +*
  Initialized stop J ),k) +* Start-At (IC Comput(ProgramPart( (Result(s +*
Initialized
  stop I) +* Initialized stop J )), (Result(s +*Initialized
  stop I) +* Initialized stop J ),k) + card I,SCMPDS),
  Comput(ProgramPart( (s +* Initialized
  stop (I ';' J))), (s +* Initialized
  stop (I ';' J)), (LifeSpan (s +* Initialized stop I)+k)) equal_outside NAT
proof
  set SA0=Start-At( 0,SCMPDS);
  let I be parahalting No-StopCode Program of SCMPDS,J be parahalting
  shiftable Program of SCMPDS,k be Element of NAT;
  set IsI = Initialized stop I, sIsI = s +* IsI, RI = Result sIsI, pJ= stop J,
IsJ = Initialized pJ, RIJ = RI +* IsJ, pIJ = stop (I ';' J), IsIJ = Initialized
  pIJ, sIsIJ = s +* IsIJ;
 IsI c= sIsI by FUNCT_4:26;
  then
B1: ProgramPart sIsI halts_on sIsI by SCMPDS_4:63;
  set s2 = Comput(ProgramPart( sIsIJ), sIsIJ,LifeSpan sIsI+0);
  set s1 = RIJ +* Start-At (IC RIJ + card I,SCMPDS);
  set m1 = LifeSpan sIsI;
A2: Initialized I c= IsIJ by Th15;
  assume
A3: IsIJ c= s;
  then
A4: s = sIsIJ by FUNCT_4:79;
A5: now
    thus IC s1 = IC (RI +* (stop J +* SA0)) + card I by AMI_1:111
      .= IC (RI +* stop J +* SA0) + card I by FUNCT_4:15
      .=  (0+card I) by AMI_1:111
      .= IC s2 by A3,A4,A2,Th30,XBOOLE_1:1;
    hereby
      let a be Int_position;
A6:   not a in dom (stop J+*SA0) by SCMPDS_4:61;
      not a in dom Start-At (IC RIJ + card I,SCMPDS) by SCMPDS_4:59;
      hence s1.a = RIJ.a by FUNCT_4:12
        .= RI.a by A6,FUNCT_4:12
        .= Comput(ProgramPart( sIsI), sIsI,m1).a by B1,AMI_1:122
        .= s2.a by Th34,SCMPDS_4:13;
    end;
  end;
  defpred X[Element of NAT] means Comput(ProgramPart( RIJ), RIJ,$1) +* Start-At
(IC
  Comput(ProgramPart( RIJ), RIJ,$1) + card I,SCMPDS), Comput(ProgramPart( sIsIJ
), sIsIJ,LifeSpan sIsI+$1)
  equal_outside NAT;
A7: pIJ c= sIsIJ by FUNCT_4:26,SCMPDS_4:57;
A8: for k being Element of NAT st X[k] holds X[k+1]
  proof
    let k be Element of NAT;
    set k1 = k+1, CRk = Comput(ProgramPart( RIJ), RIJ,k), CRSk = CRk +*
Start-At (IC CRk +
card I,SCMPDS), CIJk = Comput(ProgramPart( sIsIJ), sIsIJ,LifeSpan sIsI+k),
CRk1 = Comput(ProgramPart( RIJ), RIJ,k1
    ), CRSk1 = CRk1 +* Start-At (IC CRk1 + card I,SCMPDS),
    CIJk1 = Comput(ProgramPart( sIsIJ), sIsIJ,
    LifeSpan sIsI+k1);
    assume
A9: CRSk,CIJk equal_outside NAT;
A10: CurInstr(ProgramPart CRk,CRk) = CurInstr(ProgramPart CIJk,CIJk)
    proof
Y:  (ProgramPart CIJk)/.IC CIJk
 = CIJk.IC CIJk by AMI_1:150;
A11:  CurInstr(ProgramPart CIJk,CIJk) = CIJk.IC CRSk by A9,AMI_1:121,Y
        .= CIJk.(IC CRk + card I) by AMI_1:111;
      reconsider n = IC CRk as Element of NAT;
A12:  pIJ = I ';' pJ by SCMPDS_4:46;
      IsJ c= RIJ by FUNCT_4:26;
      then
A13:  IC CRk in dom pJ by SCMPDS_4:def 9;
      then n < card pJ by SCMPDS_4:1;
      then n+card I < card pJ + card I by XREAL_1:8;
      then n+card I < card pIJ by A12,SCMPDS_4:45;
      then
A14:  IC CRk + card I in dom pIJ by SCMPDS_4:1;
Y:  (ProgramPart CRk)/.IC CRk
 = CRk.IC CRk by AMI_1:150;
      RIJ =RI +* pJ +* SA0 by FUNCT_4:15
        .=RI +* SA0 +* pJ by SCMPDS_4:62;
      then pJ c= CRk by AMI_1:81,FUNCT_4:26;
      hence CurInstr(ProgramPart CRk,CRk) =pJ.IC CRk by A13,GRFUNC_1:8,Y
        .=pIJ.(IC CRk + card I) by A13,A12,SCMPDS_4:38
        .= sIsIJ.(IC CRk + card I) by A7,A14,GRFUNC_1:8
        .= CurInstr(ProgramPart CIJk,CIJk) by A11,AMI_1:54;
    end;
    CIJk,CRSk equal_outside NAT by A9,FUNCT_7:28;
    then
    Exec(CurInstr(ProgramPart CIJk,CIJk), CIJk),
    Exec(CurInstr(ProgramPart CRk,CRk),CRSk)
     equal_outside NAT by A10,
SCMPDS_4:15;
    then
A15: Exec(CurInstr(ProgramPart CIJk,CIJk), CIJk),
Following(ProgramPart CRk,CRk) +* Start-At (IC Following(ProgramPart CRk,CRk)
 + card I,SCMPDS) equal_outside NAT by Th35;
T: ProgramPart sIsIJ = ProgramPart CIJk
by AMI_1:144;
    CIJk1 = Comput(ProgramPart( sIsIJ), sIsIJ,LifeSpan sIsI+k+1);
    then
A16: CIJk1 = Following(ProgramPart sIsIJ,CIJk) by AMI_1:14;
A17: now
      let a be Int_position;
S: ProgramPart RIJ = ProgramPart CRk
by AMI_1:144;
      thus CRSk1.a = CRk1.a by SCMPDS_3:14
        .= (Following(ProgramPart RIJ,CRk)).a by AMI_1:14
        .= (Following(ProgramPart CRk,CRk) +*
        Start-At (IC Following(ProgramPart CRk,CRk) + card I,SCMPDS)).a
         by SCMPDS_3:14,S
        .= CIJk1.a by A16,A15,SCMPDS_4:13,T;
    end;
S: ProgramPart RIJ = ProgramPart CRk
by AMI_1:144;
    IC CRSk1 = IC CRk1 + card I by AMI_1:111
      .= IC Following(ProgramPart RIJ,CRk) + card I by AMI_1:14;
    then
    IC CRSk1=IC (Following(ProgramPart CRk,CRk) +*
    Start-At (IC Following(ProgramPart CRk,CRk) + card I,SCMPDS))
    by AMI_1:111,S
      .= IC CIJk1 by A16,A15,AMI_1:121,T;
    hence thesis by A17,SCMPDS_4:11;
  end;
  Comput(ProgramPart( RIJ), RIJ,0) = RIJ by AMI_1:13;
  then
A18: X[0] by A5,SCMPDS_4:11;
  for k being Element of NAT holds X[k] from NAT_1:sch 1(A18,A8);
  hence thesis;
end;

Lm3: for I being parahalting No-StopCode Program of SCMPDS,J being parahalting
shiftable Program of SCMPDS,s,s1 being State of SCMPDS st Initialized stop (I
';' J) c= s & s1=s +* Initialized stop I holds IC Comput(ProgramPart( s), s,
LifeSpan s1) =
 card I & DataPart Comput(ProgramPart( s), s,LifeSpan s1) = DataPart (Comput(
ProgramPart(
s1),
s1,LifeSpan s1) +* Initialized stop J) & Shift(stop J,card I) c= Comput(
ProgramPart( s
), s
,LifeSpan s1) & LifeSpan s = LifeSpan s1 + LifeSpan (Result s1 +* Initialized
stop J)

proof
  set D = SCM-Data-Loc;

  let I be parahalting No-StopCode Program of SCMPDS,J be parahalting
  shiftable Program of SCMPDS,s,s1 be State of SCMPDS;

  set IsI = Initialized stop I, spJ = stop J, IsJ = Initialized spJ, sIJ =

stop (I ';' J), IsIJ = Initialized sIJ, m1 = LifeSpan s1, s3 = Comput(
ProgramPart( s1), s1,
  m1) +* IsJ;

  set m3 = LifeSpan s3;
  assume that
A1: IsIJ c= s and
A2: s1=s +* IsI;

A3: DataPart s3 = DataPart Comput(ProgramPart( s1), s1,m1) +* DataPart IsJ by
FUNCT_4:75;

  set s4 = Comput(ProgramPart(s),s,m1);
A4: Initialized I c= IsIJ by Th15;
  hence
A5: IC s4 =  card I by A1,A2,Th30,XBOOLE_1:1;
A6: now
    let x be set;
    assume
    x in dom (DataPart IsJ);
    then
A7: x in dom IsJ /\ D by RELAT_1:90,SCMPDS_2:100;
    then
A8: x in dom IsJ by XBOOLE_0:def 4;
A9: x in D by A7,XBOOLE_0:def 4;
    per cases by A8,SCMPDS_4:28;
    suppose
A10:  x in dom spJ;
      dom spJ c= NAT by RELAT_1:def 18;
      then reconsider l=x as Element of NAT by A10;

      (DataPart IsJ).l = (DataPart Comput(ProgramPart(s1),s1,m1)).l by A9,
SCMPDS_4:22;

      hence (DataPart IsJ).x = (DataPart Comput(ProgramPart(s1),s1,m1)).x;
    end;
    suppose
      x = IC SCMPDS;

      hence (DataPart IsJ).x = (DataPart Comput(ProgramPart(s1),s1,m1)).x by A7
,SCMPDS_3:6
,XBOOLE_0:def 4;

    end;
  end;
A11: dom (DataPart IsJ) = dom IsJ /\ D by RELAT_1:90,SCMPDS_2:100;
  reconsider m = m1 + m3 as Element of NAT;
  sIJ = I ';' (J ';' Stop SCMPDS) by SCMPDS_4:46
    .= I +* Shift(spJ, card I);
  then
A12: Shift(spJ, card I) c= sIJ by FUNCT_4:26;
A13: IsJ c= s3 by FUNCT_4:26;
  then
A14: ProgramPart s3 halts_on s3 by AMI_1:def 26;
  dom IsJ c= dom s3 by A13,GRFUNC_1:8;
  then dom IsJ c= the carrier of SCMPDS by PARTFUN1:def 4;

  then dom (DataPart IsJ) c= (the carrier of SCMPDS) /\ D by A11,XBOOLE_1:26;

  then dom (DataPart IsJ) c= dom ( Comput(ProgramPart( s1), s1,m1)) /\ D by
PARTFUN1:def 4;

  then dom (DataPart IsJ) c= dom DataPart Comput(ProgramPart(s1),s1,m1) by
RELAT_1:90
,SCMPDS_2:100;

  then DataPart IsJ c= DataPart Comput(ProgramPart( s1), s1,m1) by A6,GRFUNC_1:
8;
  then
A15: DataPart Comput(ProgramPart( s1), s1,m1) = DataPart s3 by A3,LATTICE2:8;
  s = s +* IsIJ by A1,FUNCT_4:79

    .= s +* ((I ';' (J ';' Stop SCMPDS)) +* Start-At( 0,SCMPDS))
    by SCMPDS_4:46;

  hence
A16: DataPart s4 = DataPart s3 by A2,A15,Th33,SCMPDS_4:24;
T: ProgramPart s = ProgramPart Comput(ProgramPart(s),s,
m1)
by AMI_1:144;
x: Comput(ProgramPart(s),s,m1+m3)
 = Comput(ProgramPart(s),Comput(ProgramPart(s),s,m1),m3) by AMI_1:51;
  sIJ c= s by A1,SCMPDS_4:57;
  then Shift(spJ, card I) c= s by A12,XBOOLE_1:1;
  hence
A17: Shift(spJ, card I) c= s4 by AMI_1:81;

  then
  CurInstr(ProgramPart Comput(ProgramPart(s3),s3,m3),Comput(ProgramPart(s3),s3,
m3))
   = CurInstr(ProgramPart Comput(ProgramPart(s4),s4,m3),Comput(ProgramPart(s4),
s4,m3))
    by A13,A5,A16,
SCMPDS_4:84;

  then CurInstr(ProgramPart Comput(ProgramPart(s3),s3,m3),Comput(ProgramPart(s3
),s3,m3))
   = CurInstr(ProgramPart Comput(ProgramPart(s),s,m1+m3),Comput(ProgramPart(s),
s,m1+m3)) by
x,T;

  then
A18: CurInstr(ProgramPart Comput(ProgramPart(s),s,m),Comput(ProgramPart(s),s,m)
)
 = halt SCMPDS by A14,AMI_1:def 46;
A19: now
    let k be Element of NAT;
    assume
    m1 + k < m;
    then
A20: k < m3 by XREAL_1:8;
    assume
A21: CurInstr(ProgramPart Comput(ProgramPart(s),s,m1+k),Comput(ProgramPart(s),s
,m1+k))
 = halt SCMPDS;
T: ProgramPart s = ProgramPart Comput(ProgramPart(s),s,
m1)
by AMI_1:144;
x: Comput(ProgramPart(s),s,m1+k) =
Comput(ProgramPart(s),Comput(ProgramPart(s),s,m1),k) by AMI_1:51;
    CurInstr(ProgramPart Comput(ProgramPart(s3),s3,k),Comput(ProgramPart(s3),s3
,k))
     = CurInstr(ProgramPart Comput(ProgramPart(s4),s4,k),Comput(ProgramPart(s4)
,s4,k))
      by A13,A5,A16,A17
,SCMPDS_4:84

      .= halt SCMPDS by A21,x,T;
    hence contradiction by A14,A20,AMI_1:def 46;
  end;
  now
    let k be Element of NAT;
    assume
A22: k < m;
    per cases;
    suppose
      k < m1;

      hence CurInstr(ProgramPart Comput(ProgramPart(s),s,k),Comput(ProgramPart(
s),s,k)) <>
       halt SCMPDS by A1,A2,A4,Th32,
XBOOLE_1:1;

    end;
    suppose
      m1 <= k;
      then consider kk being Nat such that
A23:  m1 + kk = k by NAT_1:10;
      kk in NAT by ORDINAL1:def 13;
      hence CurInstr(ProgramPart Comput(ProgramPart(s),s,k),Comput(ProgramPart(
s),s,k)) <>
       halt SCMPDS by A19,A22,A23;
    end;
  end;

  then
A24: for k being Element of NAT st CurInstr(ProgramPart Comput(ProgramPart(s),s
,k),
Comput(ProgramPart(s),s,k))
 = halt SCMPDS
  holds m <= k;
 IsI c= s1 by A2,FUNCT_4:26;
  then
B25: ProgramPart s1 halts_on s1 by SCMPDS_4:63;
  ProgramPart s halts_on s by A1,SCMPDS_4:63;
  then LifeSpan s = m by A18,A24,AMI_1:def 46;
  hence thesis by B25,AMI_1:122;
end;

theorem Th37:
  for I being parahalting No-StopCode Program of SCMPDS,J being
parahalting shiftable Program of SCMPDS holds LifeSpan (s +* Initialized stop (
  I ';' J)) = LifeSpan (s +* Initialized stop I) + LifeSpan (Result (s +*
  Initialized stop I) +* Initialized stop J)
proof
  set SA0= Start-At( 0,SCMPDS);
  let I be parahalting No-StopCode Program of SCMPDS,J be parahalting
  shiftable Program of SCMPDS;
  set sI=stop I, IsI = Initialized sI, sIJ = stop (I ';' J), IsIJ= Initialized
  sIJ, s1=s +* IsIJ, s2=s +* IsI;
A1: IsIJ c= s1 by FUNCT_4:26;
  set IsJ=Initialized stop J, s3=Result (s1 +* IsI) +* IsJ, s4=Result s2 +*
  IsJ;
A2: IsI c= s2 by FUNCT_4:26;
  s1 +* IsI = s1 +* sI by FUNCT_4:26,SCMPDS_4:34;
  then
A3: s1, s1 +* IsI equal_outside NAT by AMI_1:120;
A4: IsJ c= s4 by FUNCT_4:26;
  s2 =s +* sI +* SA0 by FUNCT_4:15
    .=s+*SA0+* sI by SCMPDS_4:62;
  then
A5: s2,s+*SA0 equal_outside NAT by AMI_1:120,FUNCT_7:28;
A6: IsJ c= s3 by FUNCT_4:26;
  s1 =s +* sIJ +* SA0 by FUNCT_4:15
    .=s+*SA0+* sIJ by SCMPDS_4:62;
  then s+*SA0,s1 equal_outside NAT by AMI_1:120;
  then s2, s1 equal_outside NAT by A5,FUNCT_7:29;
  then
A7: s2,s1+*IsI equal_outside NAT by A3,FUNCT_7:29;
A8: IsI c= s1 +* IsI by FUNCT_4:26;
  then Result s2,Result (s1 +* IsI) equal_outside NAT by A7,A2,Th21;
  then s4,s3 equal_outside NAT by FUNCT_7:106;
  then
A9: LifeSpan s3 = LifeSpan s4 by A6,A4,Th21;
  LifeSpan (s1 +* IsI) = LifeSpan s2 by A7,A8,A2,Th21;
  hence thesis by A1,A9,Lm3;
end;

theorem Th38:
  for I being parahalting No-StopCode Program of SCMPDS,J being
parahalting shiftable Program of SCMPDS holds IExec(I ';' J,s) = IExec(J,IExec(
  I,s)) +* Start-At (IC IExec(J,IExec(I,s)) + card I,SCMPDS)
proof
  set SA0= Start-At( 0,SCMPDS);
  let I be parahalting No-StopCode Program of SCMPDS,J be parahalting
  shiftable Program of SCMPDS;
  set A = NAT, D = SCM-Data-Loc, ps = s | A, sI = stop I, IsI = Initialized sI
, IsJ = Initialized stop J, sIJ = stop (I ';' J), IsIJ =Initialized sIJ, s1 = s
  +* IsI, m1 = LifeSpan s1, s2 = s +* Initialized stop (I ';' J), s3 =
  Comput(ProgramPart(s1),s1,m1) +* IsJ, m3 = LifeSpan s3;
A1: IsJ c= s3 by FUNCT_4:26;
A2: IsJ c= s3 by FUNCT_4:26;
B1: ProgramPart s3 halts_on s3 by A1,SCMPDS_4:63;
A3: IExec(I,s) | A = ps by PBOOLE:157;
  s2 +* IsI = s2 +* sI by FUNCT_4:26,SCMPDS_4:34;
  then
A4: s2, s2 +* IsI equal_outside A by AMI_1:120;
A5: IsJ c= s3 by FUNCT_4:26;
A6: IsJ c= IExec(I,s) +* IsJ by FUNCT_4:26;
A7: s1 +* IsIJ =s +* (IsI +* IsIJ) by FUNCT_4:15
    .=s2 by Th17;
A8: IsJ c= Result s1 +* IsJ by FUNCT_4:26;
A9: IsJ c= IExec(I,s) +* IsJ by FUNCT_4:26;
A10: dom ps = dom s /\ A by RELAT_1:90
    .= ({IC SCMPDS} \/ D \/ A) /\ A by SCMPDS_4:19
    .= A by XBOOLE_1:21;
A11: IsI c= s1 by FUNCT_4:26;
  then ProgramPart s1 halts_on s1 by SCMPDS_4:63;
  then
A12: IExec(I,s) = Comput(ProgramPart(s1),s1,m1) +* ps by AMI_1:122;
A13: Comput(ProgramPart(s1),s1,m1) +* IsJ, Comput(ProgramPart(s1),s1,m1) +* ps
+* IsJ equal_outside
  dom ps by FUNCT_7:31,106;
  then
  Comput(ProgramPart(s1),s1,m1) +* ps +* IsJ, Comput(ProgramPart(s1),s1,m1) +*
IsJ equal_outside
  dom ps by FUNCT_7:28;
  then Result (IExec(I,s) +* IsJ), Result s3 equal_outside A by A10,A9,A2,A12
,Th21;
  then Result (IExec(I,s) +* IsJ) +* ps = Result s3 +* ps by A10,FUNCT_7:108;
  then
A14: IExec(J,IExec(I,s)) = Comput(ProgramPart(s3),s3,m3) +* ps by B1,A3,AMI_1:
122
;
  s1 =s +* sI +* SA0 by FUNCT_4:15
    .=s+*SA0+* sI by SCMPDS_4:62;
  then
A15: s1,s+*SA0 equal_outside A by AMI_1:120,FUNCT_7:28;
A16: IsI c= s2 +* IsI by FUNCT_4:26;
X: s2 +* IsI +* IsIJ = s2 +* (IsI +* IsIJ) by FUNCT_4:15;
X1: s2 +* IsIJ = s +* (IsIJ +* IsIJ) by FUNCT_4:15;
X2: s2 +* (IsI +* IsIJ) = s2 +* IsIJ by Th17;
  s2 =s +* sIJ +* SA0 by FUNCT_4:15
    .=s+*SA0+* sIJ by SCMPDS_4:62;
  then s+*SA0,s2 equal_outside A by AMI_1:120;
  then s1, s2 equal_outside A by A15,FUNCT_7:29;
  then s1,s2+*IsI equal_outside A by A4,FUNCT_7:29;
  then
A17: LifeSpan (s2 +* IsI) = m1 by A11,A16,Th21;
  then DataPart Comput(ProgramPart( (s2 +* IsI)), (s2 +* IsI),m1) = DataPart
Comput(ProgramPart( (s2 +*
  IsI +* IsIJ)), (s2 +*
  IsI +* IsIJ),m1) by A16,Th24,SCMPDS_4:24
    .= DataPart Comput(ProgramPart( (s2 +* (IsI +* IsIJ))), (s2 +* (IsI +* IsIJ
)),m1) by X
    .= DataPart Comput(ProgramPart( (s2 +* IsIJ)), (s2 +* IsIJ),m1) by X2
    .= DataPart Comput(ProgramPart( (s +* (IsIJ +* IsIJ))), (s +* (IsIJ +* IsIJ
)),m1) by X1
    .= DataPart Comput(ProgramPart(s1),s1,m1) by A11,A7,Th24,SCMPDS_4:24;
  then
A18: DataPart( Comput(ProgramPart( (s2 +* IsI)), (s2 +* IsI),m1) +* IsJ) =
DataPart Comput(ProgramPart(
  s1),
  s1,m1) +* DataPart IsJ by FUNCT_4:75
    .= DataPart(Comput(ProgramPart( s1), s1,m1) +* IsJ) by FUNCT_4:75;
A19: IsIJ c= s2 by FUNCT_4:26;
  then
A20: DataPart Comput(ProgramPart(s2),s2,m1) = DataPart(Comput(ProgramPart( (s2
+* IsI)), (s2 +* IsI),m1) +*
  IsJ) by A17,Lm3;
A21: Shift(stop J,card I) c= Comput(ProgramPart(s2),s2,m1) by A19,A17,Lm3;
A22: IC Comput(ProgramPart(s2),s2,m1) =  card I by A19,A17,Lm3;
  then
A23: IC Comput(ProgramPart( Comput(ProgramPart(s2),s2,m1)), Comput(ProgramPart(
s2),s2,m1),m3) = IC Comput(ProgramPart(s3),s3,m3) + card I
  by A20,A21,A5,A18,SCMPDS_4:84;
T1: ProgramPart s2 = ProgramPart Comput(ProgramPart(s2),s2,m1)
by AMI_1:144;

A24: DataPart Comput(ProgramPart( Comput(ProgramPart(s2),s2,m1)), Comput(
ProgramPart(s2),s2,m1),m3) = DataPart Comput(ProgramPart(s3),s3,
  m3) by A22,A20,A21,A5,A18,SCMPDS_4:84;
X: ProgramPart s1 halts_on s1 by A11,SCMPDS_4:63;
  then
A25: s3 = Result s1 +* IsJ by AMI_1:122;
  Result s1 = Comput(ProgramPart(s1),s1,m1) by X,AMI_1:122;
  then
A26: IC Result (Result s1 +* IsJ) = IC Result (IExec(I,s) +* IsJ) by A10,A13,A8
,A6,Th21,AMI_1:121;
Y:   ProgramPart s2 halts_on s2 by A19,SCMPDS_4:63;
A27: IC IExec(I ';' J,s) = IC Result (s +* IsIJ) by Th22
    .= IC Comput(ProgramPart(s2),s2,LifeSpan s2) by Y,AMI_1:122
    .= IC Comput(ProgramPart(s2),s2,m1+m3) by A25,Th37
    .= IC Comput(ProgramPart(s3),s3,m3) + card I by A23,AMI_1:51,T1
    .= IC Result s3 + card I by B1,AMI_1:122
    .= IC Result (Result s1 +* IsJ) + card I by X,AMI_1:122
    .= IC IExec(J,IExec(I,s)) + card I by A26,Th22;
  IExec(I ';' J,s) = Comput(ProgramPart(s2),s2,LifeSpan s2) +* ps by Y,AMI_1:
122

    .= Comput(ProgramPart(s2),s2,m1+m3) +* ps by A25,Th37;
  then
A28: DataPart IExec(I ';' J,s) = DataPart Comput(ProgramPart(s2),s2,m1+m3) by
A10,AMI_2:29
,FUNCT_4:76,SCMPDS_2:100
    .= DataPart Comput(ProgramPart(s3),s3,m3) by A24,AMI_1:51,T1
    .= DataPart IExec(J,IExec(I,s))
     by A10,A14,AMI_2:29,FUNCT_4:76,SCMPDS_2:100;
  hereby
    reconsider l = IC IExec(J,IExec(I,s)) + card I as Element of NAT;
A29: dom Start-At(l,SCMPDS) = {IC SCMPDS} by FUNCOP_1:19;
A30: now
      let x be set;
      assume
A31:  x in dom IExec(I ';' J,s);
      per cases by A31,SCMPDS_4:20;
      suppose
A32:    x is Int_position;
        then x <> IC SCMPDS by SCMPDS_2:52;
        then
A33:    not x in dom Start-At(l,SCMPDS) by A29,TARSKI:def 1;
        IExec(I ';' J,s).x = IExec(J,IExec(I,s)).x by A28,A32,SCMPDS_4:23;
        hence
        IExec(I ';' J,s).x = (IExec(J,IExec(I,s)) +* Start-At (IC IExec(J
        ,IExec(I,s)) + card I,SCMPDS)).x by A33,FUNCT_4:12;
      end;
      suppose
A34:    x = IC SCMPDS;
        then x in {IC SCMPDS} by TARSKI:def 1;
        then
A35:    x in dom Start-At(l,SCMPDS) by FUNCOP_1:19;
        thus IExec(I ';' J,s).x = (Start-At(l,SCMPDS)).IC SCMPDS
        by A27,A34,FUNCOP_1:87
          .= (IExec(J,IExec(I,s)) +* Start-At (IC IExec(J,IExec(I,s)) + card
        I,SCMPDS)).x by A34,A35,FUNCT_4:14;
      end;
      suppose
A36:    x is Element of NAT;
        then x <> IC SCMPDS by AMI_1:48;
        then
A37:    not x in dom Start-At(l,SCMPDS) by A29,TARSKI:def 1;
        IExec(I ';' J,s) | A = ps by PBOOLE:157
          .= IExec(J,IExec(I,s)) | A by A3,PBOOLE:157;
        then IExec(I ';' J,s).x = IExec(J,IExec(I,s)).x by A36,SCMPDS_4:21;
        hence
        IExec(I ';' J,s).x = (IExec(J,IExec(I,s)) +* Start-At (IC IExec(J
        ,IExec(I,s)) + card I,SCMPDS)).x by A37,FUNCT_4:12;
      end;
    end;
    dom IExec(I ';' J,s) = the carrier of SCMPDS by PARTFUN1:def 4
      .= dom (IExec(J,IExec(I,s)) +* Start-At (IC IExec(J,IExec(I,s)) + card
    I,SCMPDS)) by PARTFUN1:def 4;
    hence thesis by A30,FUNCT_1:9;
  end;
end;

theorem
  for I being parahalting No-StopCode Program of SCMPDS,J being
  parahalting shiftable Program of SCMPDS holds IExec(I ';' J, s).a = IExec(J,
  IExec(I,s)).a
proof
  let I be parahalting No-StopCode Program of SCMPDS,J be parahalting
  shiftable Program of SCMPDS;
A1: not a in dom Start-At (IC IExec(J,IExec(I,s)) + card I,SCMPDS)
by SCMPDS_4:59;
  IExec(I ';' J,s) = IExec(J,IExec(I,s)) +* Start-At (IC IExec(J,IExec(I,s
  )) + card I,SCMPDS) by Th38;
  hence thesis by A1,FUNCT_4:12;
end;

begin :: Computation of the program consisting of a instruction and a block

definition
  let s be State of SCMPDS;
  func Initialized s -> State of SCMPDS equals
  s +* Start-At( 0,SCMPDS);
  coherence;
end;

theorem Th40:
  IC Initialized s =  0 & (Initialized s).a = s.a & (
  Initialized s).loc = s.loc
proof
  dom Start-At( 0,SCMPDS) = {IC SCMPDS} by FUNCOP_1:19;
  then
A1: IC SCMPDS in dom Start-At( 0,SCMPDS) by TARSKI:def 1;
  (Start-At( 0,SCMPDS)).IC SCMPDS =  0 by FUNCOP_1:87;
  hence IC Initialized s =  0 by A1,FUNCT_4:14;
  not a in dom Start-At( 0,SCMPDS) by SCMPDS_4:59;
  hence (Initialized s).a =s.a by FUNCT_4:12;
  not loc in dom Start-At( 0,SCMPDS) by AMI_1:137;
  hence thesis by FUNCT_4:12;
end;

theorem Th41:
  s1, s2 equal_outside NAT iff s1 | (SCM-Data-Loc \/ {IC SCMPDS})
  = s2 | (SCM-Data-Loc \/ {IC SCMPDS})
proof
  set Y = NAT;
  set X = SCM-Data-Loc \/ {IC SCMPDS};
A1: (X \/ Y) \ Y \/ Y = X \/ Y \/ Y by XBOOLE_1:39
    .= X \/ (Y \/ Y) by XBOOLE_1:4
    .= Y \/ X;
A2: Y misses (X \/ Y) \ Y by XBOOLE_1:79;
A3: X misses Y
  proof
    assume
    X meets Y;
    then consider x such that
A4: x in X and
A5: x in Y by XBOOLE_0:3;
A6: x in SCM-Data-Loc or x in {IC SCMPDS} by A4,XBOOLE_0:def 3;
    per cases by A6,TARSKI:def 1;
    suppose
      x in SCM-Data-Loc;
      hence contradiction by A5,AMI_2:29,XBOOLE_0:3;
    end;
    suppose
      x = IC SCMPDS;
      then reconsider l=IC SCMPDS as Element of NAT by A5;
      l=IC SCMPDS;
      hence contradiction by AMI_1:48;
    end;
  end;
  dom s2 = the carrier of SCMPDS by PARTFUN1:def 4;
  then
A7: dom s2 \ Y = X by A1,A2,A3,SCMPDS_3:5,XBOOLE_1:72;
  dom s1 = the carrier of SCMPDS by PARTFUN1:def 4;
  then dom s1 \ Y = X by A1,A2,A3,SCMPDS_3:5,XBOOLE_1:72;
  hence thesis by A7,FUNCT_7:def 2;
end;

canceled;

theorem Th43:
  DataPart s1 = DataPart s2 & InsCode i <> 3 implies DataPart Exec
  (i,s1) = DataPart Exec(i,s2)
proof
  assume that
A1: DataPart s1 = DataPart s2 and
A2: InsCode i <> 3;
  per cases by A2,NAT_1:38,SCMPDS_2:15;
  suppose
    InsCode i = 0;
    then
A3: ex k1 st i = goto k1 by SCMPDS_2:35;
    now
      let a;
      thus Exec(i, s1).a = s1.a by A3,SCMPDS_2:66
        .=s2.a by A1,SCMPDS_4:23
        .=Exec(i, s2).a by A3,SCMPDS_2:66;
    end;
    hence thesis by SCMPDS_4:23;
  end;
  suppose
    InsCode i = 1;
    then consider a such that
A4: i = return a by SCMPDS_2:36;
    now
      let b;
      per cases;
      suppose
A5:     a=b;
        hence Exec(i, s1).b= s1.DataLoc(s1.a,RetSP) by A4,SCMPDS_2:70
          .=s2.DataLoc(s2.a,RetSP) by A1,SCMPDS_3:3
          .=Exec(i,s2).b by A4,A5,SCMPDS_2:70;
      end;
      suppose
A6:     a<>b;
        hence Exec(i, s1).b = s1.b by A4,SCMPDS_2:70
          .=s2.b by A1,SCMPDS_4:23
          .=Exec(i,s2).b by A4,A6,SCMPDS_2:70;
      end;
    end;
    hence thesis by SCMPDS_4:23;
  end;
  suppose
    InsCode i = 2;
    then consider a,k1 such that
A7: i = a := k1 by SCMPDS_2:37;
    now
      let b;
      per cases;
      suppose
A8:     a=b;
        hence Exec(i, s1).b= k1 by A7,SCMPDS_2:57
          .=Exec(i,s2).b by A7,A8,SCMPDS_2:57;
      end;
      suppose
A9:     a<>b;
        hence Exec(i,s1).b = s1.b by A7,SCMPDS_2:57
          .=s2.b by A1,SCMPDS_4:23
          .=Exec(i,s2).b by A7,A9,SCMPDS_2:57;
      end;
    end;
    hence thesis by SCMPDS_4:23;
  end;
  suppose
    InsCode i = 4;
    then
A10: ex a,k1,k2 st i = (a,k1)<>0_goto k2 by SCMPDS_2:39;
    now
      let a;
      thus Exec(i, s1).a = s1.a by A10,SCMPDS_2:67
        .=s2.a by A1,SCMPDS_4:23
        .=Exec(i, s2).a by A10,SCMPDS_2:67;
    end;
    hence thesis by SCMPDS_4:23;
  end;
  suppose
    InsCode i = 5;
    then
A11: ex a,k1,k2 st i = (a,k1)<=0_goto k2 by SCMPDS_2:40;
    now
      let a;
      thus Exec(i, s1).a = s1.a by A11,SCMPDS_2:68
        .=s2.a by A1,SCMPDS_4:23
        .=Exec(i, s2).a by A11,SCMPDS_2:68;
    end;
    hence thesis by SCMPDS_4:23;
  end;
  suppose
    InsCode i = 6;
    then
A12: ex a,k1,k2 st i = (a,k1)>=0_goto k2 by SCMPDS_2:41;
    now
      let a;
      thus Exec(i, s1).a = s1.a by A12,SCMPDS_2:69
        .=s2.a by A1,SCMPDS_4:23
        .=Exec(i, s2).a by A12,SCMPDS_2:69;
    end;
    hence thesis by SCMPDS_4:23;
  end;
  suppose
    InsCode i = 7;
    then consider a,k1,k2 such that
A13: i = (a,k1) := k2 by SCMPDS_2:42;
    now
      let b;
      per cases;
      suppose
A14:    DataLoc(s1.a,k1)=b;
        then
A15:    DataLoc(s2.a,k1)=b by A1,SCMPDS_4:23;
        thus Exec(i, s1).b= k2 by A13,A14,SCMPDS_2:58
          .=Exec(i,s2).b by A13,A15,SCMPDS_2:58;
      end;
      suppose
A16:    DataLoc(s1.a,k1)<>b;
        then
A17:    DataLoc(s2.a,k1)<>b by A1,SCMPDS_4:23;
        thus Exec(i,s1).b = s1.b by A13,A16,SCMPDS_2:58
          .=s2.b by A1,SCMPDS_4:23
          .=Exec(i,s2).b by A13,A17,SCMPDS_2:58;
      end;
    end;
    hence thesis by SCMPDS_4:23;
  end;
  suppose
    InsCode i = 8;
    then consider a,k1,k2 such that
A18: i = AddTo(a,k1,k2) by SCMPDS_2:43;
    now
      let b;
      per cases;
      suppose
A19:    DataLoc(s1.a,k1)=b;
        then
A20:    DataLoc(s2.a,k1)=b by A1,SCMPDS_4:23;
        thus Exec(i, s1).b= s1.DataLoc(s1.a,k1)+k2 by A18,A19,SCMPDS_2:60
          .= s2.DataLoc(s2.a,k1)+k2 by A1,SCMPDS_3:3
          .=Exec(i,s2).b by A18,A20,SCMPDS_2:60;
      end;
      suppose
A21:    DataLoc(s1.a,k1)<>b;
        then
A22:    DataLoc(s2.a,k1)<>b by A1,SCMPDS_4:23;
        thus Exec(i,s1).b = s1.b by A18,A21,SCMPDS_2:60
          .=s2.b by A1,SCMPDS_4:23
          .=Exec(i,s2).b by A18,A22,SCMPDS_2:60;
      end;
    end;
    hence thesis by SCMPDS_4:23;
  end;
  suppose
    InsCode i = 9;
    then consider a,b,k1,k2 such that
A23: i = AddTo(a,k1,b,k2) by SCMPDS_2:44;
    now
      let c;
      per cases;
      suppose
A24:    DataLoc(s1.a,k1)=c;
        then
A25:    DataLoc(s2.a,k1)=c by A1,SCMPDS_4:23;
        thus Exec(i, s1).c = s1.DataLoc(s1.a,k1)+s1.DataLoc(s1.b,k2) by A23,A24
,SCMPDS_2:61
          .= s2.DataLoc(s2.a,k1)+s1.DataLoc(s1.b,k2) by A1,SCMPDS_3:3
          .= s2.DataLoc(s2.a,k1)+s2.DataLoc(s2.b,k2) by A1,SCMPDS_3:3
          .=Exec(i,s2).c by A23,A25,SCMPDS_2:61;
      end;
      suppose
A26:    DataLoc(s1.a,k1)<>c;
        then
A27:    DataLoc(s2.a,k1)<>c by A1,SCMPDS_4:23;
        thus Exec(i,s1).c = s1.c by A23,A26,SCMPDS_2:61
          .=s2.c by A1,SCMPDS_4:23
          .=Exec(i,s2).c by A23,A27,SCMPDS_2:61;
      end;
    end;
    hence thesis by SCMPDS_4:23;
  end;
  suppose
    InsCode i = 10;
    then consider a,b,k1,k2 such that
A28: i = SubFrom(a,k1,b,k2) by SCMPDS_2:45;
    now
      let c;
      per cases;
      suppose
A29:    DataLoc(s1.a,k1)=c;
        then
A30:    DataLoc(s2.a,k1)=c by A1,SCMPDS_4:23;
        thus Exec(i, s1).c = s1.DataLoc(s1.a,k1)-s1.DataLoc(s1.b,k2) by A28,A29
,SCMPDS_2:62
          .= s2.DataLoc(s2.a,k1)-s1.DataLoc(s1.b,k2) by A1,SCMPDS_3:3
          .= s2.DataLoc(s2.a,k1)-s2.DataLoc(s2.b,k2) by A1,SCMPDS_3:3
          .=Exec(i,s2).c by A28,A30,SCMPDS_2:62;
      end;
      suppose
A31:    DataLoc(s1.a,k1)<>c;
        then
A32:    DataLoc(s2.a,k1)<>c by A1,SCMPDS_4:23;
        thus Exec(i,s1).c = s1.c by A28,A31,SCMPDS_2:62
          .=s2.c by A1,SCMPDS_4:23
          .=Exec(i,s2).c by A28,A32,SCMPDS_2:62;
      end;
    end;
    hence thesis by SCMPDS_4:23;
  end;
  suppose
    InsCode i = 11;
    then consider a,b,k1,k2 such that
A33: i = MultBy(a,k1,b,k2) by SCMPDS_2:46;
    now
      let c;
      per cases;
      suppose
A34:    DataLoc(s1.a,k1)=c;
        then
A35:    DataLoc(s2.a,k1)=c by A1,SCMPDS_4:23;
        thus Exec(i, s1).c = s1.DataLoc(s1.a,k1)*s1.DataLoc(s1.b,k2) by A33,A34
,SCMPDS_2:63
          .= s2.DataLoc(s2.a,k1)*s1.DataLoc(s1.b,k2) by A1,SCMPDS_3:3
          .= s2.DataLoc(s2.a,k1)*s2.DataLoc(s2.b,k2) by A1,SCMPDS_3:3
          .=Exec(i,s2).c by A33,A35,SCMPDS_2:63;
      end;
      suppose
A36:    DataLoc(s1.a,k1)<>c;
        then
A37:    DataLoc(s2.a,k1)<>c by A1,SCMPDS_4:23;
        thus Exec(i,s1).c = s1.c by A33,A36,SCMPDS_2:63
          .=s2.c by A1,SCMPDS_4:23
          .=Exec(i,s2).c by A33,A37,SCMPDS_2:63;
      end;
    end;
    hence thesis by SCMPDS_4:23;
  end;
  suppose
    InsCode i = 12;
    then consider a,b,k1,k2 such that
A38: i = Divide(a,k1,b,k2) by SCMPDS_2:47;
    now
      let c;
      per cases;
      suppose
A39:    DataLoc(s1.b,k2)=c;
        then
A40:    DataLoc(s2.b,k2)=c by A1,SCMPDS_4:23;
        thus Exec(i, s1).c = s1.DataLoc(s1.a,k1) mod s1.DataLoc(s1.b,k2) by A38
,A39,SCMPDS_2:64
          .= s2.DataLoc(s2.a,k1) mod s1.DataLoc(s1.b,k2) by A1,SCMPDS_3:3
          .= s2.DataLoc(s2.a,k1) mod s2.DataLoc(s2.b,k2) by A1,SCMPDS_3:3
          .= Exec(i,s2).c by A38,A40,SCMPDS_2:64;
      end;
      suppose
A41:    DataLoc(s1.b,k2)<>c;
        then
A42:    DataLoc(s2.b,k2)<>c by A1,SCMPDS_4:23;
        hereby
          per cases;
          suppose
A43:        DataLoc(s1.a,k1)<>c;
            then
A44:        DataLoc(s2.a,k1)<>c by A1,SCMPDS_4:23;
            thus Exec(i, s1).c = s1.c by A38,A41,A43,SCMPDS_2:64
              .=s2.c by A1,SCMPDS_4:23
              .=Exec(i,s2).c by A38,A42,A44,SCMPDS_2:64;
          end;
          suppose
A45:        DataLoc(s1.a,k1)=c;
            then
A46:        DataLoc(s2.a,k1)=c by A1,SCMPDS_4:23;
            thus Exec(i, s1).c = s1.DataLoc(s1.a,k1) div s1.DataLoc(s1.b,k2)
            by A38,A41,A45,SCMPDS_2:64
              .= s2.DataLoc(s2.a,k1) div s1.DataLoc(s1.b,k2) by A1,SCMPDS_3:3
              .= s2.DataLoc(s2.a,k1) div s2.DataLoc(s2.b,k2) by A1,SCMPDS_3:3
              .= Exec(i,s2).c by A38,A42,A46,SCMPDS_2:64;
          end;
        end;
      end;
    end;
    hence thesis by SCMPDS_4:23;
  end;
  suppose
    InsCode i = 13;
    then consider a,b,k1,k2 such that
A47: i = (a,k1):=(b,k2) by SCMPDS_2:48;
    now
      let c;
      per cases;
      suppose
A48:    DataLoc(s1.a,k1)=c;
        then
A49:    DataLoc(s2.a,k1)=c by A1,SCMPDS_4:23;
        thus Exec(i, s1).c = s1.DataLoc(s1.b,k2) by A47,A48,SCMPDS_2:59
          .= s2.DataLoc(s2.b,k2) by A1,SCMPDS_3:3
          .=Exec(i,s2).c by A47,A49,SCMPDS_2:59;
      end;
      suppose
A50:    DataLoc(s1.a,k1)<>c;
        then
A51:    DataLoc(s2.a,k1)<>c by A1,SCMPDS_4:23;
        thus Exec(i,s1).c = s1.c by A47,A50,SCMPDS_2:59
          .=s2.c by A1,SCMPDS_4:23
          .=Exec(i,s2).c by A47,A51,SCMPDS_2:59;
      end;
    end;
    hence thesis by SCMPDS_4:23;
  end;
end;

theorem Th44:
  for i being shiftable Instruction of SCMPDS holds (DataPart s1 =
  DataPart s2 implies DataPart Exec(i,s1) = DataPart Exec(i,s2))
proof
  let i be shiftable Instruction of SCMPDS;
  InsCode i <> 3 by SCMPDS_4:def 13;
  hence thesis by Th43;
end;

theorem Th45:
  for i being parahalting Instruction of SCMPDS holds Exec(i,
  Initialized s) = IExec(Load i, s)
proof
  set SA0=Start-At( 0,SCMPDS);
  let i be parahalting Instruction of SCMPDS;
  set Li=Load i, Mi= stop Li;
  set sI = s+*Initialized Mi;
  set Is = Initialized s;
  set IC1 = IC Comput(ProgramPart( sI), sI,1);
A1: ProgramPart sI halts_on sI by FUNCT_4:26,SCMPDS_4:63;
A2:  1 in dom Initialized Mi by Th13;
A3:  0 in dom Initialized Mi by Th13;
A4: now
    set Y = NAT;
    set X = SCM-Data-Loc \/ {IC SCMPDS};
    assume
A5: Result sI = Exec(i, sI);
    sI = s +*Mi +* SA0 by FUNCT_4:15;
    then Is,sI equal_outside Y by AMI_1:120,FUNCT_7:106;
    then Is | X = sI | X by Th41;
    then
A6: Exec(i, Is) | X = Exec(i, sI) | X by SCMPDS_3:7;
A7: Y /\ (X \/ Y) c= Y /\ (X \/ Y);
A8: dom IExec(Li, s) = the carrier of SCMPDS by PARTFUN1:def 4;
A9: dom Exec(i, Is) = the carrier of SCMPDS by PARTFUN1:def 4;
A10: dom s = X \/ Y by PARTFUN1:def 4,SCMPDS_3:5;
    now
      thus dom (Exec(i, Is) | Y) = dom s /\ Y by A9,A10,RELAT_1:90,SCMPDS_3:5;
      let x;
      assume
      x in dom (Exec(i, Is) | Y);
      then
A11:  x in Y /\ (X \/ Y) by A9,RELAT_1:90,SCMPDS_3:5;
      then x is Element of NAT by XBOOLE_1:21;
      then reconsider x9 = x as Element of NAT;
      x in Y by A11,XBOOLE_1:21;
      hence (Exec(i, Is)|Y).x = (Exec(i, Is)).x by FUNCT_1:72
        .= Is.x9 by AMI_1:def 13
        .= s.x by Th40;
    end;
    then
A12: Exec(i, Is) | Y = s | Y by FUNCT_1:68;
    dom Exec(i, sI) = the carrier of SCMPDS by PARTFUN1:def 4;
    then
A13: IExec(Li, s) | Y = s | Y by A5,A10,A7,FUNCT_4:93,SCMPDS_3:5;
    X misses Y
    proof
      assume
      X meets Y;
      then consider x such that
A14:  x in X and
A15:  x in Y by XBOOLE_0:3;
A16:  x in SCM-Data-Loc or x in {IC SCMPDS} by A14,XBOOLE_0:def 3;
      per cases by A16,TARSKI:def 1;
      suppose
        x in SCM-Data-Loc;
        hence contradiction by A15,AMI_2:29,XBOOLE_0:3;
      end;
      suppose
        x = IC SCMPDS;
        then reconsider l=IC SCMPDS as Element of NAT by A15;
        l=IC SCMPDS;
        hence contradiction by AMI_1:48;
      end;
    end;
    then X misses dom (s|Y) by RELAT_1:87,XBOOLE_1:63;
    then IExec(Li, s) | X = Exec(i, sI) | X by A5,FUNCT_4:76;
    then
A17: Exec(i, Is)| (X \/ Y) = IExec(Li,s) | (X \/ Y) by A6,A13,A12,RELAT_1:185;
    thus Exec(i, Is) = Exec(i, Is)| (X \/ Y) by A9,RELAT_1:98,SCMPDS_3:5
      .= IExec(Li, s) by A8,A17,RELAT_1:98,SCMPDS_3:5;
  end;
A18: (Initialized Mi). 1=halt SCMPDS by Th13;
A19: (Initialized Mi). 0 = i by Th13;
A20: Initialized Mi c= sI by FUNCT_4:26;
  then
A21: IC1 in dom Mi by SCMPDS_4:def 9;
u: Comput(ProgramPart(sI),sI,0) = sI by AMI_1:13;
Y:  (ProgramPart sI)/.IC sI
 = sI.IC sI by AMI_1:150;
A22: Comput(ProgramPart( sI), sI,0+1)
 = Following(ProgramPart sI,Comput(ProgramPart(sI),sI
,0))
by AMI_1:14
    .= Following(ProgramPart sI,sI) by AMI_1:13
    .= Exec(sI. 0, sI) by Th18,FUNCT_4:26,Y,u
    .= Exec(i, sI) by A3,A19,A20,GRFUNC_1:8;
  per cases by A21,Th11;
  suppose
A23: IC1 =  0;
    set Ni=InsCode i;
    succ IC sI = succ  0 by Th18,FUNCT_4:26
      .=  1;
    then
A24: Ni in {0,1,4,5,6} by A22,A23,SCMPDS_4:6;
Y:  (ProgramPart Comput(ProgramPart(sI),sI,1))/.IC Comput(ProgramPart(sI),sI,1)
 = Comput(ProgramPart(sI),sI,1).IC Comput(ProgramPart(sI),sI,1) by AMI_1:150;
A25: CurInstr(ProgramPart Comput(ProgramPart(sI),sI,1),Comput(ProgramPart(sI),
sI,1)) = sI. 0
 by A22,A23,AMI_1:def 13,Y
      .= i by A3,A19,A20,GRFUNC_1:8;
A26: Ni <> 1 by Th26;
    hereby
      per cases;
      suppose
        i = halt SCMPDS;
        hence thesis by A1,A4,A22,A25,AMI_1:def 22;
      end;
      suppose
A27:    i <> halt SCMPDS;
A28:    for loc holds sI.loc = Exec(i, sI).loc by AMI_1:def 13;
A29:    now
          let b;
          per cases by A24,A26,ENUMSET1:def 3;
          suppose
            InsCode i = 0;
            then ex k1 st i = goto k1 by SCMPDS_2:35;
            hence sI.b=Exec(i, sI).b by SCMPDS_2:66;
          end;
          suppose
            InsCode i = 4;
            then ex a,k1,k2 st i = (a,k1)<>0_goto k2 by SCMPDS_2:39;
            hence sI.b=Exec(i, sI).b by SCMPDS_2:67;
          end;
          suppose
            InsCode i = 5;
            then ex a,k1,k2 st i = (a,k1)<=0_goto k2 by SCMPDS_2:40;
            hence sI.b=Exec(i, sI).b by SCMPDS_2:68;
          end;
          suppose
            InsCode i = 6;
            then ex a,k1,k2 st i = (a,k1)>=0_goto k2 by SCMPDS_2:41;
            hence sI.b=Exec(i, sI).b by SCMPDS_2:69;
          end;
        end;
u: Comput(ProgramPart(sI),sI,0) = sI by AMI_1:13;
A30:    Following(ProgramPart sI,sI)
 = Following(ProgramPart sI,Comput(ProgramPart(sI),sI
,0))
by AMI_1:13
          .= Exec(i, sI) by A22,AMI_1:14;
A31:    IC sI = IC Exec(i, sI) by A22,A23,Th18,FUNCT_4:26;
        then
A32:    sI = Exec(i, sI) by A29,A28,SCMPDS_2:54;
        now
          let n;
          Comput(ProgramPart( sI), sI,n) = sI by A31,A29,A28,A30,AMI_1:130,
SCMPDS_2:54,u
            .= Following(ProgramPart sI,Comput(
ProgramPart(sI),sI,0))
            by A32,A30,AMI_1:13
            .= Comput(ProgramPart( sI), sI,0+1) by AMI_1:14;
          hence CurInstr(ProgramPart Comput(ProgramPart(sI),sI,n),Comput(
ProgramPart(sI),sI,n))
           <> halt SCMPDS by A25,A27;
        end;
        then not ProgramPart sI halts_on sI by AMI_1:146;
        hence thesis by FUNCT_4:26,SCMPDS_4:63;
      end;
    end;
  end;
  suppose
S:    IC1 =  1;
  (ProgramPart Comput(ProgramPart(sI),sI,1))/.IC Comput(ProgramPart(sI),sI,1)
 = Comput(ProgramPart(sI),sI,1).IC Comput(ProgramPart(sI),sI,1) by AMI_1:150;
    then CurInstr(ProgramPart Comput(ProgramPart(sI),sI,1),Comput(ProgramPart(
sI),sI,1))
     = sI. 1 by A22,AMI_1:def 13,S
      .= halt SCMPDS by A2,A18,A20,GRFUNC_1:8;
    hence thesis by A1,A4,A22,AMI_1:def 22;
  end;
end;

theorem Th46:
  for I being parahalting No-StopCode Program of SCMPDS,j being
parahalting shiftable Instruction of SCMPDS holds IExec(I ';' j, s).a = Exec(j,
  IExec(I, s)).a
proof
  let I be parahalting No-StopCode Program of SCMPDS,j be parahalting
  shiftable Instruction of SCMPDS;
  set Mj = Load j;
  set SA = Start-At (IC IExec(Mj,IExec(I,s)) + card I,SCMPDS);
A1: not a in dom SA by SCMPDS_4:59;
A2: a in SCM-Data-Loc by SCMPDS_2:def 2;
  for a holds (Initialized IExec(I,s)).a=IExec(I, s).a by Th40;
  then
A3: DataPart Initialized IExec(I,s) = DataPart IExec(I, s) by SCMPDS_4:23;
  thus IExec(I ';' j, s).a = (IExec(Mj,IExec(I,s))+*SA).a by Th38
    .= IExec(Mj, IExec(I,s)).a by A1,FUNCT_4:12
    .= Exec(j, Initialized IExec(I,s)).a by Th45
    .= (DataPart Exec(j, Initialized IExec(I,s))).a by A2,FUNCT_1:72
,SCMPDS_2:100
    .= (DataPart Exec(j, IExec(I, s))).a by A3,Th44
    .= Exec(j, IExec(I, s)).a by A2,FUNCT_1:72,SCMPDS_2:100;
end;

theorem
  for i being No-StopCode parahalting Instruction of SCMPDS, j being
shiftable parahalting Instruction of SCMPDS holds IExec(i ';' j, s).a = Exec(j,
  Exec(i, Initialized s)).a
proof
  let i be No-StopCode parahalting Instruction of SCMPDS, j be shiftable
  parahalting Instruction of SCMPDS;
  set Mi = Load i;
  thus IExec(i ';' j, s).a = IExec(Mi ';' j, s).a
    .= Exec(j, IExec(Mi,s)).a by Th46
    .= Exec(j, Exec(i, Initialized s)).a by Th45;
end;

