:: Computation of Two Consecutive Program Blocks for SCMPDS
::  by JingChao Chen
::
:: Received June 15, 1999
:: Copyright (c) 1999-2011 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies NUMBERS, SUBSET_1, SCMPDS_2, AMI_1, FSM_1, INT_1, SETFAM_1,
      RELAT_1, SCMFSA_7, CARD_1, SCMPDS_4, FUNCT_1, AMISTD_2, VALUED_1,
      ARYTM_3, TARSKI, XXREAL_0, TURING_1, FUNCT_4, XBOOLE_0,
      SCMFSA6B, CIRCUIT2, GRAPHSP, MSUALG_1, AMI_2, AMI_3, SCMPDS_1,
      COMPLEX1, STRUCT_0, ARYTM_1, NAT_1, SCMPDS_5, ORDINAL1, PARTFUN1,
      SCMNORM, SCMFSA6C, COMPOS_1, PBOOLE;
 notations TARSKI, XBOOLE_0, SETFAM_1, ENUMSET1, SUBSET_1, CARD_1, NUMBERS,
      XCMPLX_0, RELAT_1, FUNCT_1, PARTFUN1, FUNCT_4, PBOOLE,
      INT_1, NAT_1, STRUCT_0,
      COMPOS_1, EXTPRO_1,
      AMI_1, VALUED_1, AMI_2, FUNCT_7, SCMPDS_1, SCMPDS_2,
      INT_2, SCMPDS_4, XXREAL_0;
 constructors ENUMSET1, XXREAL_0, REAL_1, INT_2, SCMPDS_1, SCMPDS_4,
      PRE_POLY, DOMAIN_1, AMI_1, AMI_3, NAT_D;
 registrations SETFAM_1, FUNCT_1, NUMBERS, XREAL_0, INT_1, AMI_1, SCMPDS_2,
      SCMPDS_4, ORDINAL1, XBOOLE_0, VALUED_1, AFINSQ_1, COMPOS_1, RELAT_1,
      EXTPRO_1, PBOOLE, FUNCT_4;
 requirements NUMERALS, REAL, SUBSET, BOOLE, ARITHM;
 definitions FUNCOP_1, COMPOS_1, AMI_1, SCMPDS_4, NAT_1, AFINSQ_1, EXTPRO_1;
 theorems AMI_1, NAT_1, TARSKI, FUNCT_4, FUNCT_1, INT_1, RELAT_1, SCMPDS_2,
      SCMPDS_3, CARD_1, ENUMSET1, ABSVALUE, GRFUNC_1, SCMPDS_4,
      XBOOLE_0, XBOOLE_1, XREAL_1, ORDINAL1, FUNCOP_1, XXREAL_0,
      AMI_2, VALUED_1, AFINSQ_1, PBOOLE, PARTFUN1, COMPOS_1, EXTPRO_1;
 schemes NAT_1;

begin :: Preliminaries

reserve x for set,
  m,n for Element of NAT,
  a,b,c for Int_position,
  i for Instruction of SCMPDS,
  s,s1,s2 for State of SCMPDS,
  k1,k2 for Integer,
  loc,l1 for Element of NAT,
  I,J for Program of SCMPDS,
  N for with_non-empty_elements set;

canceled;

Lm1: card Stop SCMPDS = 1 by COMPOS_1:46;

theorem Th2:
  x in dom Load i iff x =  0
proof
  dom Load i = { 0} by FUNCOP_1:19;
  hence thesis by TARSKI:def 1;
end;

theorem Th3:
  loc in dom stop I & (stop I).loc <> halt SCMPDS implies loc in dom I
proof
  assume that
A1: loc in dom (stop I) and
A2: (stop I).loc <> halt SCMPDS;
  set SS=Stop SCMPDS, S2=Shift(SS, card I);
  assume
  not loc in dom I;
  then loc in dom S2 by A1,FUNCT_4:13;
  then loc in {l1+ card I where l1 is Element of NAT : l1 in dom SS} by
VALUED_1:def 12;
  then consider l1 being Element of NAT such that
A3: loc=l1+ card I and
A4: l1 in dom SS;
A5:  0 in dom Stop SCMPDS by COMPOS_1:45;
A6: (Stop SCMPDS). 0 = halt SCMPDS by AFINSQ_1:38;
  dom SS = { 0} by AFINSQ_1:36,CARD_1:87;
  then l1= 0 by A4,TARSKI:def 1;
  hence contradiction by A2,A3,A6,A5,AFINSQ_1:def 4;
end;

theorem
  dom Load i = { 0} & (Load i).( 0)=i by FUNCOP_1:19,87;

theorem Th5:
   0 in dom Load i
proof
  dom Load i = { 0} by FUNCOP_1:19;
  hence thesis by TARSKI:def 1;
end;

theorem Th6:
  card Load i = 1
proof
A1: dom Load i = { 0} by FUNCOP_1:19;
  thus card Load i = card dom Load i
    .= 1 by A1,CARD_1:50;
end;

theorem
  card stop I = card I + 1 by Lm1,AFINSQ_1:20;

theorem Th8:
  card stop Load i = 2
proof
  thus card stop Load i = card (Load i) +1 by Lm1,AFINSQ_1:20
    .=1+1 by Th6
    .=2;
end;

theorem Th9:
   0 in dom stop Load i &  1 in dom stop Load i
proof
  card stop Load i = 2 by Th8;
  hence thesis by AFINSQ_1:70;
end;

theorem Th10:
  (stop Load i). 0=i & (stop Load i). 1=halt SCMPDS
proof
  set II=Load i;
   0 in dom II by Th5;
  hence (stop II). 0 =II. 0 by AFINSQ_1:def 4
    .=i by FUNCOP_1:87;
A1:  0 in dom Stop SCMPDS by COMPOS_1:45;
A2: (Stop SCMPDS). 0 = halt SCMPDS by AFINSQ_1:38;
   1 = 0 + card II by Th6;
  hence thesis by A2,A1,AFINSQ_1:def 4;
end;

theorem Th11:
  x in dom stop Load i iff x= 0 or x= 1
proof
  set pi=stop Load i, A = NAT;
A1: card pi = 2 by Th8;
  hereby
    assume
A2: x in dom pi;
    dom pi c= A by RELAT_1:def 18;
    then reconsider l=x as Element of NAT by A2;
    reconsider n = l as Element of NAT;
    n < 1+1 by A1,A2,AFINSQ_1:70;
    then n <= 1 by NAT_1:13;
    hence x= 0 or x= 1 by NAT_1:26;
  end;
  assume
A3: x= 0 or x= 1;
  per cases by A3;
  suppose
    x= 0;
    hence thesis by A1,AFINSQ_1:70;
  end;
  suppose
    x= 1;
    hence thesis by A1,AFINSQ_1:70;
  end;
end;

theorem
  dom stop Load i = {0,1}
proof
  for x holds (x in dom (stop Load i) iff x= 0 or x= 1) by Th11;
  hence thesis by TARSKI:def 2;
end;

canceled 2;

theorem Th15:
  for I,J being Program of SCMPDS holds I c= stop (I ';' J)
proof
  let I,J be Program of SCMPDS;
  set IS=I ';' (J ';' Stop SCMPDS),
  Ip=stop (I ';' J);
A1: I c= IS by AFINSQ_1:78;
  thus thesis by A1,AFINSQ_1:30;
end;

theorem Th16:
  dom stop I c= dom stop (I ';' J)
proof
  set sI=stop I, sIJ=stop (I ';'J);
A1: card sIJ=card (I ';' J) +1 by Lm1,AFINSQ_1:20
    .=card I + card J +1 by AFINSQ_1:20
    .=card I + 1 + card J;
  card sI=card I +1 by Lm1,AFINSQ_1:20;
  then
A2: card sI <= card sIJ by A1,NAT_1:11;
  now
    set A = NAT;
    let x be set;
    assume
A3: x in dom sI;
    dom sI c= A by RELAT_1:def 18;
    then reconsider l=x as Element of NAT by A3;
    reconsider n = l as Element of NAT;
    n < card sI by A3,AFINSQ_1:70;
    then n < card sIJ by A2,XXREAL_0:2;
    hence x in dom sIJ by AFINSQ_1:70;
  end;
  hence thesis by TARSKI:def 3;
end;

theorem Th17:
  for I,J being Program of SCMPDS holds
   stop I +* stop (I ';' J) = stop (I ';' J)
proof
  let I,J be Program of SCMPDS;
  set sI=stop I, IsI=sI, sIJ=stop (I ';' J), IsIJ= sIJ;
  dom sI c= dom sIJ by Th16;
  hence thesis by FUNCT_4:20;
end;

canceled;

set SA0 = Start-At(0,SCMPDS);

theorem Th19:
  (Initialize s).a = s.a
proof
  not a in dom SA0 by SCMPDS_4:59;
  hence (Initialize s).a =s.a by FUNCT_4:12;
end;

reserve P,P1,P2,Q for (the Instructions of SCMPDS)-valued ManySortedSet of NAT;

theorem Th20:
  for s1,s2 being 0-started State of SCMPDS
  for I being parahalting Program of SCMPDS st stop I c= P1 &
  stop I c= P2 & NPP s1 = NPP s2
  for k being Element of NAT holds
   NPP Comput(P1,s1,k)
    = NPP Comput(P2,s2,k) &
   CurInstr(P1,Comput(P1,s1,k))
    = CurInstr(P2,Comput(P2,s2,k))
proof
  let s1,s2 be 0-started State of SCMPDS;
  let I be parahalting Program of SCMPDS;
  set SI=stop I;
  assume that
A1: SI c= P1 and
A2: SI c= P2 and
A3: NPP s1 = NPP s2;
  hereby
    let k be Element of NAT;
A4: IC Comput(P1,s1,k) in dom SI by A1,SCMPDS_4:def 9;
A5: IC Comput(P2,s2,k) in dom SI by A2,SCMPDS_4:def 9;
    for m being Element of NAT st m < k holds IC(Comput(P2,s2,m))
in dom
    SI by A2,SCMPDS_4:def 9;
    hence NPP Comput(P1,s1,k) = NPP Comput(P2,s2,k)
              by A3,A1,A2,SCMPDS_4:67;
    then
A6: IC Comput(P1,s1,k) = IC Comput(P2,s2,k) by
COMPOS_1:230;
    thus CurInstr(P2,Comput(P2,s2,k))
     = P2.IC Comput(P2,s2,k) by PBOOLE:158
      .= SI.IC Comput(P2,s2,k) by A2,A5,GRFUNC_1:8
      .= P1.IC Comput(P1,s1,k) by A1,A6,A4,GRFUNC_1:8
      .= CurInstr(P1,Comput(P1,s1,k))
       by PBOOLE:158;
  end;
end;

theorem Th21:
  for s1,s2 being 0-started State of SCMPDS
  for I being parahalting Program of SCMPDS st stop I c= P1 &
      stop I c= P2 & NPP s1 = NPP s2
  holds LifeSpan(P1,s1) = LifeSpan(P2,s2) &
  NPP Result(P1,s1) = NPP Result(P2,s2)
proof
  let s1,s2 be 0-started State of SCMPDS;
  let I be parahalting Program of SCMPDS;
  set SI=stop I;
  assume that
A1: SI c= P1 and
A2: SI c= P2 and
A3: NPP s1 = NPP s2;
A4: P2 halts_on s2 by A2,SCMPDS_4:def 10;
A5: P1 halts_on s1 by A1,SCMPDS_4:def 10;
A6: now
    let l be Element of NAT;
    assume
A7: CurInstr(P2,Comput(P2,s2,l)) = halt SCMPDS;
    CurInstr(P1,Comput(P1,s1,l))
     = CurInstr(P2,Comput(P2,s2,l))
     by A1,A2,A3,Th20;
    hence LifeSpan(P1,s1) <= l by A5,A7,EXTPRO_1:def 14;
  end;
  CurInstr(P2,
Comput(P2,s2,LifeSpan(P1,s1)))
   = CurInstr(P1,
   Comput(P1,s1,LifeSpan(P1,s1)))
    by A1,A2,A3,Th20
    .= halt SCMPDS by A5,EXTPRO_1:def 14;
  hence LifeSpan(P1,s1) = LifeSpan(P2,s2) by A6,A4,
EXTPRO_1:def 14;
   then
A8: Result(P2,s2) = Comput(P2,s2,LifeSpan(P1,s1))
 by A2,EXTPRO_1:23,SCMPDS_4:def 10;
  Result(P1,s1) = Comput(P1,s1,LifeSpan(P1,s1))
      by A1,EXTPRO_1:23,SCMPDS_4:def 10;
  hence thesis by A1,A2,A3,A8,Th20;
end;

theorem Th22:
  for I being Program of SCMPDS holds IC IExec(I,P,s) =
   IC Result(P +* stop I,Initialize s)
proof
  let I be Program of SCMPDS;
  set SI=stop I;
A1: dom s = {IC SCMPDS} \/ SCM-Data-Loc \/ NAT by SCMPDS_4:19;
A2: dom (s | NAT) = dom s /\ NAT by RELAT_1:90
    .= NAT by A1,XBOOLE_1:21;
  not IC SCMPDS in dom (s | NAT) by A2,COMPOS_1:3;
  hence thesis by FUNCT_4:12;
end;

theorem Th23:
  for s being 0-started State of SCMPDS
  for I being parahalting Program of SCMPDS, J being Program of SCMPDS
   st stop I c= P
  for m st m <= LifeSpan(P,s)
   holds NPP Comput(P,s,m) = NPP Comput(P+*(I ';' J),s,m)
proof
  let s be 0-started State of SCMPDS;
  let I be parahalting Program of SCMPDS, J be Program of SCMPDS;
  set SI=stop I;
  defpred X[Element of NAT] means $1 <= LifeSpan(P,s) implies
    NPP Comput(P,s,$1) = NPP Comput(P+*(I ';' J),s,$1);
A1: Comput(P+*(I ';' J),s,0) = s by EXTPRO_1:3;
  assume
A2: SI c= P;
  then
A3: P halts_on s by SCMPDS_4:def 10;
A4: for m st X[m] holds X[m+1]
  proof
    dom(I ';' J) = dom I \/ dom Shift(J, card I) by FUNCT_4:def 1;
    then
A5: dom I c= dom(I ';' J) by XBOOLE_1:7;
    let m;
    assume
A6: m <= LifeSpan(P,s) implies
    NPP Comput(P,s,m) = NPP Comput(P+*(I ';' J),s,m);
    assume
A7: m+1 <= LifeSpan(P,s);
    then
A8: IC (Comput(P,s,m)) = IC (Comput(P+*(I ';' J),s,m))
      by A6,COMPOS_1:230,NAT_1:13;
A10: Comput(P+*(I ';' J),s,m+1)
    = Following(P+*(I ';' J),Comput(P+*(I ';' J),s,m))
    by EXTPRO_1:4
      .= Exec(CurInstr(P+*(I ';' J),
      Comput(P+*(I ';' J),s,m)),
      Comput(P+*(I ';' J),s,m));
A11: Comput(P,s,m+1)
 = Following(P,Comput(P,s,m))
 by EXTPRO_1:4
      .= Exec(CurInstr(P,Comput(P,s,m)),
      Comput(P,s,m));
A12: I ';' J c= P+*(I ';' J) by FUNCT_4:26;
A13: IC Comput(P,s,m) in dom SI by A2,SCMPDS_4:def 9;
A15:  P/.IC Comput(P,s,m) = P.IC Comput(P,s,m) by PBOOLE:158;
    SI c= P by A2;
    then
A16: CurInstr(P,Comput(P,s,m)) = SI.IC (Comput(P,s,m)) by A13,A15,GRFUNC_1:8;
A17:  (P+*(I ';' J))/.IC Comput(P+*(I ';' J),s,m)
   = (P+*(I ';' J)).IC Comput(P+*(I ';' J),s,m) by PBOOLE:158;
    m < LifeSpan(P,s) by A7,NAT_1:13;
    then
 SI.IC(Comput(P,s,m)) <> halt SCMPDS by A3,A16,EXTPRO_1:def 14;
    then
A18: IC Comput(P,s,m) in dom I by A13,Th3;
    then
A19:  IC(Comput(P,s,m)) in dom I;
    then CurInstr(P,Comput(P,s,m))
    =I.IC (Comput(P,s,m)) by A16,AFINSQ_1:def 4
      .=(I ';' J).IC(Comput(P,s,m))
              by A19,AFINSQ_1:def 4
      .= CurInstr(P+*(I ';' J),
      Comput(P+*(I ';' J),s,m))
       by A8,A12,A18,A5,A17,GRFUNC_1:8;
    hence thesis by A6,A7,A11,A10,NAT_1:13,SCMPDS_4:15;
  end;
  Comput(P,s,0) = s by EXTPRO_1:3;
  then
A20: X[0] by A1;
  thus for m holds X[m] from NAT_1:sch 1(A20,A4);
end;

theorem Th24:
 for s being 0-started State of SCMPDS
 for I being parahalting Program of SCMPDS, J being Program of SCMPDS
   st stop I c= P
 for m st m <= LifeSpan(P,s)
 holds NPP Comput(P,s,m) = NPP Comput(P+*stop(I ';' J), s,m)
proof
  let s be 0-started State of SCMPDS;
  let I be parahalting Program of SCMPDS, J be Program of SCMPDS;
  assume
A1: stop I c= P;
  set sIJ=stop (I ';' J), SS=Stop SCMPDS;
  let m;
  assume
A2: m <= LifeSpan(P,s);
  P +* sIJ = P +* (I ';' (J ';' SS)) by AFINSQ_1:30;
  hence thesis by A1,A2,Th23;
end;

Lm2: Load (DataLoc(0,0):=0) is parahalting
proof
  set ii= DataLoc(0,0):=0, m0= stop Load ii, m1 = Initialize m0;
  let s be 0-started State of SCMPDS;
  let P such that
A1: m0 c= P;
  take 1;
     IC Comput(P,s,1) in NAT;
    hence IC Comput(P,s,1) in dom P by PARTFUN1:def 4;
A2: IC s =  0 by COMPOS_1:def 16;
  then
A3: IC Exec(ii, s) = succ  0 by SCMPDS_2:57
    .=  (0+1);
   1 in dom m0 by Th9;
  then m0. 1 = P. 1 by A1,GRFUNC_1:8;
  then
A4: P. 1 = halt SCMPDS by Th10;
   0 in dom m0 by Th9;
  then
A5: m0. 0 = P. 0 by A1,GRFUNC_1:8;
A6: P/.IC s = P.IC s by PBOOLE:158;
  Comput(P,s,0+1) =
  Following(P,Comput(P,s,0))
   by EXTPRO_1:4
    .= Following(P,s) by EXTPRO_1:3
    .= Exec(ii,s) by A2,A5,Th10,A6;
  hence thesis by A4,A3,PBOOLE:158;
end;

begin :: Non halting instrutions and parahalting instrutions

definition
  let i be Instruction of SCMPDS;
  attr i is No-StopCode means
  :Def1:
  i <> halt SCMPDS;
end;

definition
  let i be Instruction of SCMPDS;
  attr i is parahalting means
  :Def2:
  Load i is parahalting;
end;

registration
  cluster No-StopCode shiftable parahalting Instruction of SCMPDS;
  existence
  proof
    take i=DataLoc(0,0):=0;
A1: InsCode halt SCMPDS=0 by SCMPDS_2:21,93;
    InsCode i=2 by SCMPDS_2:23;
    hence thesis by A1,Def1,Def2,Lm2;
  end;
end;

theorem
  k1 <>0 implies goto k1 is No-StopCode
proof
  set i=goto k1;
  assume
A1: k1 <>0;
  assume
  i is not No-StopCode;
  then i=halt SCMPDS by Def1;
  hence contradiction by A1,SCMPDS_2:85;
end;

registration
  let a;
  cluster return a -> No-StopCode;
  coherence
  proof
    set i=return a;
A1: InsCode halt SCMPDS=0 by SCMPDS_2:21,93;
    InsCode i=1 by SCMPDS_2:22;
    hence thesis by A1,Def1;
  end;
end;

registration
  let a,k1;
  cluster a := k1 -> No-StopCode;
  coherence
  proof
    set i=a:=k1;
A1: InsCode halt SCMPDS=0 by SCMPDS_2:21,93;
    InsCode i=2 by SCMPDS_2:23;
    hence thesis by A1,Def1;
  end;
  cluster saveIC(a,k1) -> No-StopCode;
  coherence
  proof
    set i=saveIC(a,k1);
A2: InsCode halt SCMPDS=0 by SCMPDS_2:21,93;
    InsCode i=3 by SCMPDS_2:24;
    hence thesis by A2,Def1;
  end;
end;

registration
  let a,k1,k2;
  cluster (a,k1)<>0_goto k2 -> No-StopCode;
  coherence
  proof
    set i=(a,k1)<>0_goto k2;
A1: InsCode halt SCMPDS=0 by SCMPDS_2:21,93;
    InsCode i=4 by SCMPDS_2:25;
    hence thesis by A1,Def1;
  end;
  cluster (a,k1)<=0_goto k2 -> No-StopCode;
  coherence
  proof
    set i=(a,k1)<=0_goto k2;
A2: InsCode halt SCMPDS=0 by SCMPDS_2:21,93;
    InsCode i=5 by SCMPDS_2:26;
    hence thesis by A2,Def1;
  end;
  cluster (a,k1)>=0_goto k2 -> No-StopCode;
  coherence
  proof
    set i=(a,k1)>=0_goto k2;
A3: InsCode halt SCMPDS=0 by SCMPDS_2:21,93;
    InsCode i=6 by SCMPDS_2:27;
    hence thesis by A3,Def1;
  end;
  cluster (a,k1) := k2 -> No-StopCode;
  coherence
  proof
    set i=(a,k1) := k2;
A4: InsCode halt SCMPDS=0 by SCMPDS_2:21,93;
    InsCode i=7 by SCMPDS_2:28;
    hence thesis by A4,Def1;
  end;
end;

registration
  let a,k1,k2;
  cluster AddTo(a,k1,k2) -> No-StopCode;
  coherence
  proof
    set i=AddTo(a,k1,k2);
A1: InsCode halt SCMPDS=0 by SCMPDS_2:21,93;
    InsCode i=8 by SCMPDS_2:29;
    hence thesis by A1,Def1;
  end;
end;

registration
  let a,b,k1,k2;
  cluster AddTo(a,k1,b,k2) -> No-StopCode;
  coherence
  proof
    set i=AddTo(a,k1,b,k2);
A1: InsCode halt SCMPDS=0 by SCMPDS_2:21,93;
    InsCode i=9 by SCMPDS_2:30;
    hence thesis by A1,Def1;
  end;
  cluster SubFrom(a,k1,b,k2) -> No-StopCode;
  coherence
  proof
    set i=SubFrom(a,k1,b,k2);
A2: InsCode halt SCMPDS=0 by SCMPDS_2:21,93;
    InsCode i=10 by SCMPDS_2:31;
    hence thesis by A2,Def1;
  end;
  cluster MultBy(a,k1,b,k2) -> No-StopCode;
  coherence
  proof
    set i=MultBy(a,k1,b,k2);
A3: InsCode halt SCMPDS=0 by SCMPDS_2:21,93;
    InsCode i=11 by SCMPDS_2:32;
    hence thesis by A3,Def1;
  end;
  cluster Divide(a,k1,b,k2) -> No-StopCode;
  coherence
  proof
    set i=Divide(a,k1,b,k2);
A4: InsCode halt SCMPDS=0 by SCMPDS_2:21,93;
    InsCode i=12 by SCMPDS_2:33;
    hence thesis by A4,Def1;
  end;
  cluster (a,k1) := (b,k2) -> No-StopCode;
  coherence
  proof
    set i=(a,k1) := (b,k2);
A5: InsCode halt SCMPDS=0 by SCMPDS_2:21,93;
    InsCode i=13 by SCMPDS_2:34;
    hence thesis by A5,Def1;
  end;
end;

registration
  cluster halt SCMPDS -> parahalting;
  coherence
  proof
    Stop SCMPDS=Load halt SCMPDS;
    hence thesis by Def2;
  end;
end;

registration
  let i be parahalting Instruction of SCMPDS;
  cluster Load i -> parahalting Program of SCMPDS;
  coherence by Def2;
end;

Lm3: (for s holds Exec(i,s).IC SCMPDS = succ IC s) implies Load i is
parahalting

proof
  assume
A1: for s holds Exec(i,s).IC SCMPDS = succ IC s;
  set m0= stop Load i, m1 = Initialize m0;
  let t be 0-started State of SCMPDS;
  let Q such that
A2: m0 c= Q;
  take 1;
     IC Comput(Q,t,1) in NAT;
    hence IC Comput(Q,t,1) in dom Q by PARTFUN1:def 4;
A3: IC t =  0 by COMPOS_1:def 16;
  then
A4: IC Exec(i, t) = succ  0 by A1
    .=  (0+1);
   1 in dom m0 by Th9;
  then m0. 1 = Q. 1 by A2,GRFUNC_1:8;
  then
A5: Q. 1 = halt SCMPDS by Th10;
   0 in dom m0 by Th9;
  then
A6: m0. 0 = Q. 0 by A2,GRFUNC_1:8;
A7: Q/.IC t = Q.IC t by PBOOLE:158;
  Comput(Q,t,0+1)
   = Following(Q,Comput(Q,t,0))
   by EXTPRO_1:4
    .= Following(Q,t) by EXTPRO_1:3
    .= Exec(i,t) by A3,A6,Th10,A7;
  hence thesis by A4,A5,PBOOLE:158;
end;

registration
  let a,k1;
  cluster a := k1 -> parahalting;
  coherence
  proof
    set i= a:=k1;
    for s holds Exec(i,s).IC SCMPDS = succ IC s by SCMPDS_2:57;
    then Load i is parahalting by Lm3;
    hence thesis by Def2;
  end;
end;

registration
  let a,k1,k2;
  cluster (a,k1) := k2 -> parahalting;
  coherence
  proof
    set i= (a,k1) := k2;
    for s holds Exec(i,s).IC SCMPDS = succ IC s by SCMPDS_2:58;
    then Load i is parahalting by Lm3;
    hence thesis by Def2;
  end;
  cluster AddTo(a,k1,k2) -> parahalting;
  coherence
  proof
    set i= AddTo(a,k1,k2);
    for s holds Exec(i,s).IC SCMPDS = succ IC s by SCMPDS_2:60;
    then Load i is parahalting by Lm3;
    hence thesis by Def2;
  end;
end;

registration
  let a,b,k1,k2;
  cluster AddTo(a,k1,b,k2) -> parahalting;
  coherence
  proof
    set i= AddTo(a,k1,b,k2);
    for s holds Exec(i,s).IC SCMPDS = succ IC s by SCMPDS_2:61;
    then Load i is parahalting by Lm3;
    hence thesis by Def2;
  end;
  cluster SubFrom(a,k1,b,k2) -> parahalting;
  coherence
  proof
    set i= SubFrom(a,k1,b,k2);
    for s holds Exec(i,s).IC SCMPDS = succ IC s by SCMPDS_2:62;
    then Load i is parahalting by Lm3;
    hence thesis by Def2;
  end;
  cluster MultBy(a,k1,b,k2) -> parahalting;
  coherence
  proof
    set i= MultBy(a,k1,b,k2);
    for s holds Exec(i,s).IC SCMPDS = succ IC s by SCMPDS_2:63;
    then Load i is parahalting by Lm3;
    hence thesis by Def2;
  end;
  cluster Divide(a,k1,b,k2) -> parahalting;
  coherence
  proof
    set i= Divide(a,k1,b,k2);
    for s holds Exec(i,s).IC SCMPDS = succ IC s by SCMPDS_2:64;
    then Load i is parahalting by Lm3;
    hence thesis by Def2;
  end;
  cluster (a,k1) := (b,k2) -> parahalting;
  coherence
  proof
    set i= (a,k1) := (b,k2);
    for s holds Exec(i,s).IC SCMPDS = succ IC s by SCMPDS_2:59;
    then Load i is parahalting by Lm3;
    hence thesis by Def2;
  end;
end;

theorem Th26:
  InsCode i =1 implies i is not parahalting
proof
  consider s such that
A1: for a holds s.a = 2 by SCMPDS_2:73;
  consider P;
  assume
  InsCode i=1;
  then consider a such that
A2: i = return a by SCMPDS_2:36;
  assume
  i is parahalting;
  then reconsider Li = Load i as parahalting Program of SCMPDS;
  set pi=stop Li;
  set s1=Initialize s, P1= P+*pi;
  s1.DataLoc(s1.a,RetIC)=s.DataLoc(s1.a,RetIC) by Th19
    .=2 by A1;
  then
A4: Exec(i, s1).IC SCMPDS =(abs(2))+2 by A2,SCMPDS_2:70
    .= 2+2 by ABSVALUE:def 1
    .= 4;
  set C1=Comput(P1,s1,1);
A5: IC C1 in dom pi by FUNCT_4:26,SCMPDS_4:def 9;
   0 in dom pi by Th9;
  then
A6: P1. 0= pi. 0 by FUNCT_4:14
    .=i by Th10;
A7: card pi = 2 by Th8;
A8: P1/.IC s1 = P1.IC s1 by PBOOLE:158;
  Comput(P1,s1,0+1)
   = Following(P1,Comput(P1,s1,0))
   by EXTPRO_1:4
    .= Following(P1,s1) by EXTPRO_1:3
    .= Exec(i, s1) by A6,A8,COMPOS_1:223;
  hence contradiction by A4,A5,A7,AFINSQ_1:70;
end;

definition
  let N be with_non-empty_elements set;
  let S be definite (non empty stored-program AMI-Struct over N);
  let IT be  NAT-defined (the Instructions of S)-valued Function;
  redefine attr IT is halt-free means
  :Def3:
  for x being Element of NAT st x in dom IT holds IT.x <> halt S;
  compatibility
   proof
    thus IT is halt-free implies
     for x being Element of NAT
     st x in dom IT holds IT.x <> halt S
     proof assume
A1:     IT is halt-free;
      let x be Element of NAT;
      assume
A2:    x in dom IT;
       reconsider n=x as Element of NAT;
       IT.n in rng IT by A2,FUNCT_1:12;
      hence IT.x <> halt S by A1,COMPOS_1:def 7;
     end;
    assume
A3:   for x being Element of NAT
     st x in dom IT holds IT.x <> halt S;
    assume halt S in rng IT;
     then consider x such that
A4:   x in dom IT and
A5:   halt S = IT.x by FUNCT_1:def 5;
     dom IT c= NAT by RELAT_1:def 18;
    hence contradiction by A4,A5,A3;
   end;
end;

registration
  cluster parahalting shiftable halt-free Program of SCMPDS;
  existence
  proof
    set ii=DataLoc(0,0):=0;
    take II=Load ii;
    now
      let x be Element of NAT;
      assume
      x in dom II;
      then x in { 0} by FUNCOP_1:19;
      then x= 0 by TARSKI:def 1;
      then
A1:   II.x=ii by FUNCOP_1:87;
      InsCode ii=2 by SCMPDS_2:23;
      hence II.x <> halt SCMPDS by A1,SCMPDS_2:21,93;
    end;
    hence thesis by Def3;
  end;
end;

registration
  let I,J be halt-free Program of SCMPDS;
  cluster I ';' J -> halt-free;
  coherence
  proof
    set IJ=I ';' J;
    now
      set D = {n+card I: n in dom J };
      dom Shift(J,card I) = D by VALUED_1:def 12;
      then
A1:   dom IJ = dom I \/ D by FUNCT_4:def 1;
      let x be Element of NAT such that
A2:   x in dom IJ;
      per cases by A2,A1,XBOOLE_0:def 3;
      suppose
A3:     x in dom I;
        then I.x=IJ.x by AFINSQ_1:def 4;
        hence IJ.x<>halt SCMPDS by A3,Def3;
      end;
      suppose
        x in D;
        then consider n such that
A4:     x = n+card I and
A5:     n in dom J;
        J. n =IJ.x by A4,A5,AFINSQ_1:def 4;
        hence IJ.x<>halt SCMPDS by A5,Def3;
      end;
    end;
    hence thesis by Def3;
  end;
end;

registration
  let i be No-StopCode Instruction of SCMPDS;
  cluster Load i -> halt-free;
  coherence
  proof
    set p=Load i;
    now
      let x be Element of NAT;
      assume
      x in dom p;
      then x =  0 by Th2;
      then p.x=i by FUNCOP_1:87;
      hence p.x <>halt SCMPDS by Def1;
    end;
    hence thesis by Def3;
  end;
end;

registration
  let i be No-StopCode Instruction of SCMPDS, J be halt-free Program of
  SCMPDS;
  cluster i ';' J -> halt-free;
  coherence;
end;

registration
  let I be halt-free Program of SCMPDS, j be No-StopCode Instruction of
  SCMPDS;
  cluster I ';' j -> halt-free;
  coherence;
end;

registration
  let i,j be No-StopCode Instruction of SCMPDS;
  cluster i ';' j -> halt-free;
  coherence;
end;

theorem Th27:
  for s being 0-started State of SCMPDS
  for I being parahalting halt-free Program of SCMPDS st stop I c= P
   holds IC Comput(P, s,
     LifeSpan(P +* stop I,s))
     =  card I
proof
  let s be 0-started State of SCMPDS;
  let I be parahalting halt-free Program of SCMPDS;
  set Css= Comput(P, s,LifeSpan(P,s));
  reconsider n = IC Css as Element of NAT;
  assume
A1: stop I c= P;
  then
A2: P halts_on s by SCMPDS_4:def 10;
A3:  P +* stop I = P by A1,FUNCT_4:104;
  I c= stop I by AFINSQ_1:78;
  then
A4: I c= P by A1,XBOOLE_1:1;
  now
    assume
A5: IC Css in dom I;
    then I.IC Css=P.IC Css by A4,GRFUNC_1:8
      .=CurInstr(P,Css) by PBOOLE:158
      .=halt SCMPDS by A2,EXTPRO_1:def 14;
    hence contradiction by A5,Def3;
  end;
  then
A6: n >= card I by AFINSQ_1:70;
A7: card stop I =card I + 1 by Lm1,AFINSQ_1:20;
  IC Css in dom stop(I) by A1,SCMPDS_4:def 9;
  then n < card I + 1 by A7,AFINSQ_1:70;
  then n <= card I by NAT_1:13;
  hence thesis by A3,A6,XXREAL_0:1;
end;

theorem Th28:
 for s being 0-started State of SCMPDS
  for I being parahalting Program of SCMPDS,k be Element of NAT st
     k < LifeSpan(P +* stop I,s)
holds IC Comput(P +* stop I,s,k) in dom I
proof let s be 0-started State of SCMPDS;
  let I be parahalting Program of SCMPDS,k be Element of NAT;
  set ss= s, PP = P +* stop I,
      m=LifeSpan(PP,ss);
  set Sk= Comput(PP, ss,k), Ik=IC Sk;
A1: PP halts_on ss by FUNCT_4:26,SCMPDS_4:def 10;
  reconsider n = Ik as Element of NAT;
A2: Ik in dom stop(I) by FUNCT_4:26,SCMPDS_4:def 9;
A3: stop I c= PP by FUNCT_4:26;
  assume
A4: k < m;
A5: now
    assume
A6: n = card I;
A7:  0 in dom Stop SCMPDS by COMPOS_1:45;
A8: (Stop SCMPDS). 0 = halt SCMPDS by AFINSQ_1:38;
    CurInstr(PP,Sk) =PP.Ik by PBOOLE:158
      .=(stop I).(0+n) by A2,A3,GRFUNC_1:8
      .=halt SCMPDS by A6,A8,A7,AFINSQ_1:def 4;
    hence contradiction by A4,A1,EXTPRO_1:def 14;
  end;
  card stop I=card I + 1 by Lm1,AFINSQ_1:20;
  then n < card I + 1 by A2,AFINSQ_1:70;
  then n <= card I by INT_1:20;
  then n < card I by A5,XXREAL_0:1;
  hence thesis by AFINSQ_1:70;
end;

theorem Th29:
  for s being 0-started State of SCMPDS
  for I being parahalting Program of SCMPDS,k be Element of NAT st
 I c= P & k <= LifeSpan(P +* stop I,s)
   holds NPP Comput(P, s,k)
    = NPP Comput(P +* stop I,s,k)
proof
  let s be 0-started State of SCMPDS;
  let I be parahalting Program of SCMPDS,k be Element of NAT;
  set
  m=LifeSpan(P +* stop I,s);
  assume that
A1: I c= P and
A2: k <= m;
  set s2 = s, P2 = P +* stop I;
  defpred P[Element of NAT] means $1 <= m implies
   NPP Comput(P,s,$1)
    = NPP Comput(P2,s2,$1);
A3: P = P +* I by A1,FUNCT_4:104;
A4: now
    let k be Element of NAT;
    assume
A5: P[k];
    now
A6:   Comput(P2,s2,k+1)
 = Following(P2,Comput(P2,s2,k))
 by EXTPRO_1:4
        .= Exec(CurInstr(P2,
        Comput(P2,s2,k)),Comput(P2,s2,k));
A7:   Comput(P,s,k+1)
 = Following(P,Comput(P,s,k))
by EXTPRO_1:4
        .= Exec(CurInstr(P,Comput(P,s,k)),
        Comput(P,s,k));
A8:   k < k+1 by XREAL_1:31;
      assume
A9:  k+1 <= m;
      then
A10:    k < m by A8,XXREAL_0:2;
      then
  IC Comput(P2,s2,k) in dom I by Th28;
      then
A11:  IC Comput(P2,s2,k) in dom (stop I) by FUNCT_4:13;
A12:   IC Comput(P2,s2,k) in dom I by A10,Th28;
      IC Comput(P,s,k) = IC Comput(P2,s2,k)
        by A5,A9,A8,COMPOS_1:230,XXREAL_0:2;
      then CurInstr(P,Comput(P,s,k))
       = P.IC Comput(P2,s2,k) by PBOOLE:158
        .= I.IC Comput(P2,s2,k) by A3,A10,Th28,FUNCT_4:14
        .= (stop I).IC Comput(P2,s2,k)
             by A12,AFINSQ_1:def 4
        .= (P +* stop I).IC Comput(P2,s2,k)
         by A11,FUNCT_4:14
        .= CurInstr(P2,Comput(P2,s2,k)) by PBOOLE:158;
      hence NPP Comput(P,s,k+1)
       = NPP Comput(P2,s2,k+1)
        by A5,A9,A8,A7,A6,SCMPDS_4:15,XXREAL_0:2;
    end;
    hence P[k+1];
  end;
A13: P[0]
  proof
    assume
    0 <= m;
A14: Comput(P2,s2,0)= s by EXTPRO_1:3;
    Comput(P,s,0)=s by EXTPRO_1:3;
    hence thesis by A14;
  end;
  for k be Element of NAT holds P[k] from NAT_1:sch 1(A13,A4);
  hence thesis by A2;
end;

theorem Th30:
  for s being 0-started State of SCMPDS
  for I being parahalting halt-free Program of SCMPDS st I c= P
   holds IC Comput(P,s,
    LifeSpan(P +* stop I,s)) =  card I
proof
  let s be 0-started State of SCMPDS;
  let I be parahalting halt-free Program of SCMPDS;
  set ss = s, PP = P +* stop I,
      m=LifeSpan(PP,ss);
A1: stop I c= PP by FUNCT_4:26;
A2: stop I +* PP = PP & PP +* stop I = PP
by A1,FUNCT_4:103,104;
  assume I c= P;
  then NPP Comput(P,s,m)
     = NPP Comput(PP, ss,m) by Th29;
  hence IC Comput(P,s,m)
     = IC Comput(PP, ss,m) by COMPOS_1:230
    .= card I by Th27,A2,FUNCT_4:26;
end;

theorem Th31:
  for s being 0-started State of SCMPDS
  for I being parahalting Program of SCMPDS st I c= P
  holds CurInstr(P,
   Comput(P, s,LifeSpan(P +* stop I,s))) = halt SCMPDS or
   IC Comput(P, s,LifeSpan(P +* stop I,s)) = card I
proof
  let s be 0-started State of SCMPDS;
  let I be parahalting Program of SCMPDS;
  set ss = s, PP = P+* stop I,
      m=LifeSpan(PP,ss);
  set s1=Comput(P,s,m),
      s2= Comput(PP, ss,LifeSpan(PP +* stop I,Initialize ss)),
      Ik = IC s2;
A1: PP halts_on ss by FUNCT_4:26,SCMPDS_4:def 10;
  reconsider n = Ik as Element of NAT;
A2: stop I c= PP by FUNCT_4:26;
A3: Ik in dom stop(I) by FUNCT_4:26,SCMPDS_4:def 9;
X: Initialize ss = ss by COMPOS_1:78;
A4: PP +* stop I = PP by A2,FUNCT_4:104;
  card stop I = card I + 1 by Lm1,AFINSQ_1:20;
  then n < card I + 1 by A3,AFINSQ_1:70;
  then
A5: n <= card I by INT_1:20;
A6: stop I c= PP by FUNCT_4:26;
  assume
A7: I c= P;
  then
 NPP s1 = NPP s2 by A4,Th29,X;
  then
A8: IC s1 =Ik by COMPOS_1:230;
  now
    per cases by A5,XXREAL_0:1;
    case
      n < card I;
      then
A9:    n in dom I by AFINSQ_1:70;
      thus halt SCMPDS
        = CurInstr(PP,s2) by A4,A1,EXTPRO_1:def 14,X
        .=PP.Ik by PBOOLE:158
        .=(stop I).Ik by A3,A6,GRFUNC_1:8
        .=I.Ik by A9,AFINSQ_1:def 4
        .=P.IC s1 by A7,A8,A9,GRFUNC_1:8
        .=CurInstr(P,s1) by PBOOLE:158;
    end;
    case
C:    n = card I;
      NPP s1 =  NPP s2 by A7,A4,Th29,X;
      hence IC s1 =  card I by C,COMPOS_1:230;
    end;
  end;
  hence thesis;
end;

theorem Th32:
  for s being 0-started State of SCMPDS
  for I being parahalting halt-free Program of SCMPDS,k being Element of NAT
   st I c= P & k < LifeSpan(P +* stop I,s)
  holds CurInstr(P,Comput(P,s,k)) <> halt SCMPDS
proof
  let s be 0-started State of SCMPDS;
  let I be parahalting halt-free Program of SCMPDS,k be Element of NAT;
  set sI=s, PI = P +* stop I,
      s1= Comput(P, s,k),
      s2= Comput(PI, sI,k);
  assume that
A1: I c= P and
A2: k < LifeSpan(PI,sI);
A3: I c= P by A1;
A4: IC s2 in dom I by A2,Th28;
A6: P/.IC s1 = P.IC s1 by PBOOLE:158;
  NPP Comput(P, s,k)
    = NPP Comput(P +* stop I,s,k)
      by A1,A2,Th29;
  then CurInstr(P,s1)=P.IC s2 by A6,COMPOS_1:230
    .=I.IC s2 by A3,A4,GRFUNC_1:8;
  hence thesis by A4,Def3;
end;

theorem Th33:
  for I being parahalting Program of SCMPDS,J being Program of
  SCMPDS, k being Element of NAT
   st k <= LifeSpan(P +* stop I,Initialize s)
holds NPP Comput(P +* stop I,Initialize s,k)
   = NPP Comput(P+*(I ';' J),Initialize s,k)
proof
  let I be parahalting Program of SCMPDS,J be Program of SCMPDS, k be Element
  of NAT;
  set spI= stop I;
  set s1 = Initialize s, P1 = P +* spI;
  set s2 = Initialize s, P2 = P +* (I ';' J);
  set n=LifeSpan(P1,s1);
  defpred X[Element of NAT] means $1 <= n implies
   NPP Comput(P1,s1,$1)
   = NPP Comput(P2,s2,$1);
A2: for n being Element of NAT st X[n] holds X[n+1]
  proof
    let m be Element of NAT;
    assume
A3: m <= n implies
     NPP Comput(P1,s1,m) = NPP Comput(P2,s2,m);
A4: Comput(P2,s2,m+1)
 = Following(P2,Comput(P2,s2,m))
 by EXTPRO_1:4
      .= Exec(CurInstr(P2,Comput(P2,s2,m)),
      Comput(P2,s2,m));
A5: IC Comput(P1,s1,m) in dom spI by FUNCT_4:26,SCMPDS_4:def 9;
A6: Comput(P1,s1,m+1) = Following(P1,
Comput(P1,s1,m)) by EXTPRO_1:4
      .= Exec(CurInstr(P1,Comput(P1,s1,m)),
      Comput(P1,s1,m));
    assume
A7: m+1 <= n;
    then
A8: IC Comput(P1,s1,m) = IC Comput(P2,s2,m) by A3,
COMPOS_1:230,NAT_1:13;
A9:  m < n by A7,NAT_1:13;
    then
 IC Comput(P1,s1,m) in dom I by Th28;
    then
A10: IC Comput(P1,s1,m) in dom (I ';' J) by FUNCT_4:13;
A11:   IC Comput(P1,s1,m) in dom I by A9,Th28;
    CurInstr(P1,Comput(P1,s1,m))
     = P1.IC Comput(P1,s1,m) by PBOOLE:158
      .= spI.IC Comput(P1,s1,m) by A5,FUNCT_4:14
      .= I.IC Comput(P1,s1,m) by A11,AFINSQ_1:def 4
      .= (I ';' J).IC Comput(P1,s1,m)
            by A11,AFINSQ_1:def 4
      .= P2.IC Comput(P1,s1,m) by A10,FUNCT_4:14
      .=CurInstr(P2,Comput(P2,s2,m)) by A8,PBOOLE:158;
    hence thesis by A3,A7,A6,A4,NAT_1:13,SCMPDS_4:15;
  end;
A12: Comput(P2,s2,0) = s2 by EXTPRO_1:3;
A13: Comput(P1,s1,0) = s1 by EXTPRO_1:3;
A15: X[0] by A13,A12;
A16: for k being Element of NAT holds X[k] from NAT_1:sch 1(A15, A2);
  assume
  k <= n;
  hence thesis by A16;
end;

theorem Th34:
  for s being 0-started State of SCMPDS
  for I being parahalting Program of SCMPDS,J being Program of SCMPDS,
      k being Element of NAT st k <= LifeSpan(P +* stop I,s)
  holds NPP Comput(P +* stop I, s,k) = NPP Comput(P+*stop(I ';' J),s,k)
proof
  let s be 0-started State of SCMPDS;
  let I be parahalting Program of SCMPDS,J be Program of SCMPDS, k be Element
  of NAT;
A1: stop (I ';' J) = (I ';' (J ';' Stop SCMPDS)) by AFINSQ_1:30;
A2: s = Initialize s by COMPOS_1:78;
  assume
  k <= LifeSpan(P +* stop I,s);
  hence thesis by A1,Th33,A2;
end;

registration
  let I be parahalting Program of SCMPDS, J be parahalting shiftable Program
  of SCMPDS;
  cluster I ';' J -> parahalting Program of SCMPDS;
  coherence
  proof
    let p be Program of SCMPDS such that
A1:   p = I ';' J;
    let s be 0-started State of SCMPDS;
    let P;
    set sIJ = stop p;
    set spJ = stop J, s1 = Initialize s,
        P1 = P +* stop I,
        m1 = LifeSpan(P1,s1),
    s3 = Initialize Comput(P1, s1,m1),
    P3 = P1 +* spJ,
    m3 = LifeSpan(P3,s3),
    D = SCM-Data-Loc;
A8: spJ c= P3 by FUNCT_4:26;
A9: P3 halts_on s3 by FUNCT_4:26,SCMPDS_4:def 10;
A11: DataPart Comput(P1,s1,m1)
  =DataPart Initialize
Comput(P1,s1,m1) by COMPOS_1:80
 .= DataPart s3;
A12: I c= sIJ by A1,Th15;
    set s4 = Comput(P,s,m1), P4=P;
    assume
A15: sIJ c= P;
    p c= sIJ by AFINSQ_1:78;
    then
B15: p c= P by A15,XBOOLE_1:1;
A16: s = Initialize s by COMPOS_1:78;
    I ';' J c= P by B15,A1;
    then P+*(I ';' J) = P by FUNCT_4:104;
    then NPP Comput(P,s,m1) = NPP Comput(P1,s1,m1) by A16,Th33;
    then
A17: DataPart s4 = DataPart s3 by A11,COMPOS_1:138;
    per cases by A15,A12,Th31,A16,XBOOLE_1:1;
    suppose
A18:  CurInstr(P,s4) = halt SCMPDS;
      take m1;
     IC Comput(P,s,m1) in NAT;
    hence IC Comput(P,s,m1) in dom P by PARTFUN1:def 4;
  thus thesis by A18;
    end;
    suppose
A19:  IC s4 =  card I;
      reconsider m = m1 + m3 as Element of NAT;
      take m;
     IC Comput(P,s,m) in NAT;
    hence IC Comput(P,s,m) in dom P by PARTFUN1:def 4;
A20: Comput(P,s,m1+m3)
 = Comput(P,Comput(P,s,m1),m3) by EXTPRO_1:5;
      sIJ = I ';' (J ';' Stop SCMPDS) by A1,AFINSQ_1:30
        .= I +* Shift(spJ, card I);
      then Shift(spJ, card I) c= sIJ by FUNCT_4:26;
      then Shift(spJ, card I) c= P by A15,XBOOLE_1:1;
      then
A21:    Shift(spJ, card I) c= P4;
   CurInstr(P3,Comput(P3,s3,m3))
 = CurInstr(P,Comput(P,s,m1+m3))
      by A20,A8,A17,A19,A21,SCMPDS_4:84;
  hence thesis by A9,EXTPRO_1:def 14;
    end;
  end;
end;

registration
  let i be parahalting Instruction of SCMPDS, J be parahalting shiftable
  Program of SCMPDS;
  cluster i ';' J -> parahalting;
  coherence;
end;

registration
  let I be parahalting Program of SCMPDS, j be parahalting shiftable
  Instruction of SCMPDS;
  cluster I ';' j -> parahalting;
  coherence;
end;

registration
  let i be parahalting Instruction of SCMPDS, j be parahalting shiftable
  Instruction of SCMPDS;
  cluster i ';' j -> parahalting;
  coherence;
end;

theorem Th35:
  for s being State of SCMPDS, s1 being 0-started State of SCMPDS,
      J being parahalting shiftable Program of SCMPDS
    st stop J c= P &
    s = Comput(P1 +* stop J, s1,m) holds
    Exec(CurInstr(P,s),s +* Start-At(IC s + n,SCMPDS))
  = IncIC(Following(P,s),n)
proof
  let s be State of SCMPDS, s1 be 0-started State of SCMPDS,
      J be parahalting shiftable Program of SCMPDS;
  set pJ=stop J, IsJ=Initialize pJ, s2=s1,
      P2 = P1 +* pJ;
  set i = CurInstr(P,s), ss=s +* Start-At(IC s + n,SCMPDS);
  reconsider k = IC s as Element of NAT;
  reconsider Nl=succ IC s as Element of NAT;
A1: succ IC ss = (k + n + 1) by FUNCT_4:121
    .= IC (Exec(i, s) +*Start-At (Nl + n,SCMPDS)) by FUNCT_4:121;
  assume
Z: pJ c= P;
  assume
 s=Comput(P2,s2,m);
  then
A3: IC s in dom pJ by FUNCT_4:26,SCMPDS_4:def 9;
  reconsider n1 = IC s as Element of NAT;
  set IEn=IC Exec(i,s)+n;
A4: IC ss = IC s + n by FUNCT_4:121;
A5: now
    let d be Element of NAT;
    thus Exec(i, ss).d = ss.d by AMI_1:def 13
      .= s.d by COMPOS_1:20
      .= Exec(i, s).d by AMI_1:def 13
      .= (Exec(i, s) +* Start-At(IEn,SCMPDS)).d by COMPOS_1:20;
  end;
A6: P/.IC s = P.IC s by PBOOLE:158;
  pJ c= P by Z;
  then
A7: i=pJ.(n1) by A3,A6,GRFUNC_1:8;
  then
A8: InsCode i <> 1 by A3,SCMPDS_4:def 12;
A9: i valid_at n1 by A3,A7,SCMPDS_4:def 12;
A10: InsCode i <> 3 by A3,A7,SCMPDS_4:def 12;
  per cases by A8,A10,NAT_1:38,SCMPDS_2:15;
  suppose
    InsCode i = 0;
    then consider k1 such that
A11: i = goto k1 and
A12: n1+k1 >= 0 by A9,SCMPDS_4:def 11;
A13: IC Exec(i,s) =ICplusConst(s,k1) by A11,SCMPDS_2:66;
A14: now
      let b;
      thus Exec(i, ss).b= ss.b by A11,SCMPDS_2:66
        .= s.b by SCMPDS_3:14
        .= Exec(i, s).b by A11,SCMPDS_2:66
        .= (Exec(i, s) +* Start-At(IEn,SCMPDS)).b by SCMPDS_3:14;
    end;
    IC Exec(i, ss) =ICplusConst(ss,k1) by A11,SCMPDS_2:66
      .=IEn by A4,A12,A13,SCMPDS_4:82
      .= IC (Exec(i, s) +* Start-At(IEn,SCMPDS)) by FUNCT_4:121;
    hence thesis by A5,A14,SCMPDS_2:54;
  end;
  suppose
    InsCode i = 2;
    then consider a,k1 such that
A15: i = a := k1 by SCMPDS_2:37;
A16: now
      let b;
      per cases;
      suppose
A17:    a = b;
        hence Exec(i, ss).b = k1 by A15,SCMPDS_2:57
          .= Exec(i,s).b by A15,A17,SCMPDS_2:57
          .= (Exec(i, s) +* Start-At(IEn,SCMPDS)).b by SCMPDS_3:14;
      end;
      suppose
A18:    a <> b;
        hence Exec(i, ss).b = ss.b by A15,SCMPDS_2:57
          .= s.b by SCMPDS_3:14
          .= Exec(i, s).b by A15,A18,SCMPDS_2:57
          .= (Exec(i, s) +* Start-At(IEn,SCMPDS)).b by SCMPDS_3:14;
      end;
    end;
    IC Exec(i, s) = Nl by A15,SCMPDS_2:57;
    then IC Exec(i, ss) = IC (Exec(i, s) +* Start-At(IEn,SCMPDS))
    by A1,A15,SCMPDS_2:57;
    hence thesis by A5,A16,SCMPDS_2:54;
  end;
  suppose
    InsCode i = 4;
    then consider a,k1,k2 such that
A19: i = (a,k1)<>0_goto k2 and
A20: n1+k2 >= 0 by A9,SCMPDS_4:def 11;
A21: now
      per cases;
      suppose
A22:    s.DataLoc(s.a,k1) <> 0;
        then
A23:    IC Exec(i,s) =ICplusConst(s,k2) by A19,SCMPDS_2:67;
        ss.DataLoc(s.a,k1) <> 0 by A22,SCMPDS_3:14;
        then ss.DataLoc(ss.a,k1) <> 0 by SCMPDS_3:14;
        hence IC Exec(i, ss) =ICplusConst(ss,k2) by A19,SCMPDS_2:67
          .=IEn by A4,A20,A23,SCMPDS_4:82
          .= IC (Exec(i, s) +* Start-At(IEn,SCMPDS)) by FUNCT_4:121;
      end;
      suppose
A24:    s.DataLoc(s.a,k1) = 0;
        then ss.DataLoc(s.a,k1) = 0 by SCMPDS_3:14;
        then
A25:    ss.DataLoc(ss.a,k1) = 0 by SCMPDS_3:14;
        IC Exec(i, s) = Nl by A19,A24,SCMPDS_2:67;
        hence IC Exec(i,ss) = IC (Exec(i, s) +* Start-At(IEn,SCMPDS))
        by A1,A19,A25,SCMPDS_2:67;
      end;
    end;
    now
      let b;
      thus Exec(i, ss).b= ss.b by A19,SCMPDS_2:67
        .= s.b by SCMPDS_3:14
        .= Exec(i, s).b by A19,SCMPDS_2:67
        .= (Exec(i, s) +* Start-At(IEn,SCMPDS)).b by SCMPDS_3:14;
    end;
    hence thesis by A5,A21,SCMPDS_2:54;
  end;
  suppose
    InsCode i = 5;
    then consider a,k1,k2 such that
A26: i = (a,k1)<=0_goto k2 and
A27: n1+k2 >= 0 by A9,SCMPDS_4:def 11;
A28: now
      per cases;
      suppose
A29:    s.DataLoc(s.a,k1) <= 0;
        then
A30:    IC Exec(i,s) =ICplusConst(s,k2) by A26,SCMPDS_2:68;
        ss.DataLoc(s.a,k1) <= 0 by A29,SCMPDS_3:14;
        then ss.DataLoc(ss.a,k1) <= 0 by SCMPDS_3:14;
        hence IC Exec(i, ss) =ICplusConst(ss,k2) by A26,SCMPDS_2:68
          .=IEn by A4,A27,A30,SCMPDS_4:82
          .= IC (Exec(i, s) +* Start-At(IEn,SCMPDS)) by FUNCT_4:121;
      end;
      suppose
A31:    s.DataLoc(s.a,k1) > 0;
        then ss.DataLoc(s.a,k1) > 0 by SCMPDS_3:14;
        then
A32:    ss.DataLoc(ss.a,k1) > 0 by SCMPDS_3:14;
        IC Exec(i, s) = Nl by A26,A31,SCMPDS_2:68;
        hence IC Exec(i,ss) = IC (Exec(i, s) +* Start-At(IEn,SCMPDS))
        by A1,A26,A32,SCMPDS_2:68;
      end;
    end;
    now
      let b;
      thus Exec(i, ss).b= ss.b by A26,SCMPDS_2:68
        .= s.b by SCMPDS_3:14
        .= Exec(i, s).b by A26,SCMPDS_2:68
        .= (Exec(i, s) +* Start-At(IEn,SCMPDS)).b by SCMPDS_3:14;
    end;
    hence thesis by A5,A28,SCMPDS_2:54;
  end;
  suppose
    InsCode i = 6;
    then consider a,k1,k2 such that
A33: i = (a,k1)>=0_goto k2 and
A34: n1+k2 >= 0 by A9,SCMPDS_4:def 11;
A35: now
      per cases;
      suppose
A36:    s.DataLoc(s.a,k1) >= 0;
        then
A37:    IC Exec(i,s) =ICplusConst(s,k2) by A33,SCMPDS_2:69;
        ss.DataLoc(s.a,k1) >= 0 by A36,SCMPDS_3:14;
        then ss.DataLoc(ss.a,k1) >= 0 by SCMPDS_3:14;
        hence IC Exec(i, ss) =ICplusConst(ss,k2) by A33,SCMPDS_2:69
          .=IEn by A4,A34,A37,SCMPDS_4:82
          .= IC (Exec(i, s) +* Start-At(IEn,SCMPDS)) by FUNCT_4:121;
      end;
      suppose
A38:    s.DataLoc(s.a,k1) < 0;
        then ss.DataLoc(s.a,k1) < 0 by SCMPDS_3:14;
        then
A39:    ss.DataLoc(ss.a,k1) < 0 by SCMPDS_3:14;
        IC Exec(i, s) = Nl by A33,A38,SCMPDS_2:69;
        hence IC Exec(i,ss) = IC (Exec(i, s) +* Start-At(IEn,SCMPDS))
        by A1,A33,A39,SCMPDS_2:69;
      end;
    end;
    now
      let b;
      thus Exec(i, ss).b= ss.b by A33,SCMPDS_2:69
        .= s.b by SCMPDS_3:14
        .= Exec(i, s).b by A33,SCMPDS_2:69
        .= (Exec(i, s) +* Start-At(IEn,SCMPDS)).b by SCMPDS_3:14;
    end;
    hence thesis by A5,A35,SCMPDS_2:54;
  end;
  suppose
    InsCode i = 7;
    then consider a,k1,k2 such that
A40: i = (a,k1) := k2 by SCMPDS_2:42;
A41: now
      let b;
      per cases;
      suppose
A42:    DataLoc(ss.a,k1) = b;
        then
A43:    DataLoc(s.a,k1) = b by SCMPDS_3:14;
        thus Exec(i, ss).b = k2 by A40,A42,SCMPDS_2:58
          .= Exec(i,s).b by A40,A43,SCMPDS_2:58
          .= (Exec(i, s) +* Start-At(IEn,SCMPDS)).b by SCMPDS_3:14;
      end;
      suppose
A44:    DataLoc(ss.a,k1) <> b;
        then
A45:    DataLoc(s.a,k1) <> b by SCMPDS_3:14;
        thus Exec(i, ss).b = ss.b by A40,A44,SCMPDS_2:58
          .= s.b by SCMPDS_3:14
          .= Exec(i, s).b by A40,A45,SCMPDS_2:58
          .= (Exec(i, s) +* Start-At(IEn,SCMPDS)).b by SCMPDS_3:14;
      end;
    end;
    IC Exec(i, s) = Nl by A40,SCMPDS_2:58;
    then IC Exec(i, ss) = IC (Exec(i, s) +* Start-At(IEn,SCMPDS))
    by A1,A40,SCMPDS_2:58;
    hence thesis by A5,A41,SCMPDS_2:54;
  end;
  suppose
    InsCode i = 8;
    then consider a,k1,k2 such that
A46: i = AddTo(a,k1,k2) by SCMPDS_2:43;
A47: now
      let b;
      per cases;
      suppose
A48:    DataLoc(ss.a,k1) = b;
        then
A49:    DataLoc(s.a,k1) = b by SCMPDS_3:14;
        thus Exec(i, ss).b = ss.b + k2 by A46,A48,SCMPDS_2:60
          .= s.b + k2 by SCMPDS_3:14
          .= Exec(i, s).b by A46,A49,SCMPDS_2:60
          .= (Exec(i, s) +* Start-At(IEn,SCMPDS)).b by SCMPDS_3:14;
      end;
      suppose
A50:    DataLoc(ss.a,k1) <> b;
        then
A51:    DataLoc(s.a,k1) <> b by SCMPDS_3:14;
        thus Exec(i, ss).b = ss.b by A46,A50,SCMPDS_2:60
          .= s.b by SCMPDS_3:14
          .= Exec(i, s).b by A46,A51,SCMPDS_2:60
          .= (Exec(i, s) +* Start-At(IEn,SCMPDS)).b by SCMPDS_3:14;
      end;
    end;
    IC Exec(i, s) = Nl by A46,SCMPDS_2:60;
    then IC Exec(i, ss) = IC (Exec(i, s) +* Start-At(IEn,SCMPDS))
    by A1,A46,SCMPDS_2:60
;
    hence thesis by A5,A47,SCMPDS_2:54;
  end;
  suppose
    InsCode i = 9;
    then consider a,b,k1,k2 such that
A52: i = AddTo(a,k1,b,k2) by SCMPDS_2:44;
A53: now
      let c;
      per cases;
      suppose
A54:    DataLoc(ss.a,k1) = c;
        then
A55:    DataLoc(s.a,k1) = c by SCMPDS_3:14;
A56:    ss.DataLoc(ss.b,k2) =s.DataLoc(ss.b,k2) by SCMPDS_3:14
          .=s.DataLoc(s.b,k2) by SCMPDS_3:14;
        ss.DataLoc(ss.a,k1) =s.DataLoc(ss.a,k1) by SCMPDS_3:14
          .=s.DataLoc(s.a,k1) by SCMPDS_3:14;
        hence
        Exec(i, ss).c = s.DataLoc(s.a,k1) + s.DataLoc(s.b,k2) by A52,A54,A56,
SCMPDS_2:61
          .= Exec(i, s).c by A52,A55,SCMPDS_2:61
          .= (Exec(i, s) +* Start-At(IEn,SCMPDS)).c by SCMPDS_3:14;
      end;
      suppose
A57:    DataLoc(ss.a,k1) <> c;
        then
A58:    DataLoc(s.a,k1) <> c by SCMPDS_3:14;
        thus Exec(i, ss).c = ss.c by A52,A57,SCMPDS_2:61
          .= s.c by SCMPDS_3:14
          .= Exec(i, s).c by A52,A58,SCMPDS_2:61
          .= (Exec(i, s) +* Start-At(IEn,SCMPDS)).c by SCMPDS_3:14;
      end;
    end;
    IC Exec(i, s) = Nl by A52,SCMPDS_2:61;
    then IC Exec(i, ss) = IC (Exec(i, s) +* Start-At(IEn,SCMPDS))
    by A1,A52,SCMPDS_2:61
;
    hence thesis by A5,A53,SCMPDS_2:54;
  end;
  suppose
    InsCode i = 10;
    then consider a,b,k1,k2 such that
A59: i = SubFrom(a,k1,b,k2) by SCMPDS_2:45;
A60: now
      let c;
      per cases;
      suppose
A61:    DataLoc(ss.a,k1) = c;
        then
A62:    DataLoc(s.a,k1) = c by SCMPDS_3:14;
A63:    ss.DataLoc(ss.b,k2) =s.DataLoc(ss.b,k2) by SCMPDS_3:14
          .=s.DataLoc(s.b,k2) by SCMPDS_3:14;
        ss.DataLoc(ss.a,k1) =s.DataLoc(ss.a,k1) by SCMPDS_3:14
          .=s.DataLoc(s.a,k1) by SCMPDS_3:14;
        hence
        Exec(i, ss).c = s.DataLoc(s.a,k1) - s.DataLoc(s.b,k2) by A59,A61,A63,
SCMPDS_2:62
          .= Exec(i, s).c by A59,A62,SCMPDS_2:62
          .= (Exec(i, s) +* Start-At(IEn,SCMPDS)).c by SCMPDS_3:14;
      end;
      suppose
A64:    DataLoc(ss.a,k1) <> c;
        then
A65:    DataLoc(s.a,k1) <> c by SCMPDS_3:14;
        thus Exec(i, ss).c = ss.c by A59,A64,SCMPDS_2:62
          .= s.c by SCMPDS_3:14
          .= Exec(i, s).c by A59,A65,SCMPDS_2:62
          .= (Exec(i, s) +* Start-At(IEn,SCMPDS)).c by SCMPDS_3:14;
      end;
    end;
    IC Exec(i, s) = Nl by A59,SCMPDS_2:62;
    then IC Exec(i, ss) = IC (Exec(i, s) +* Start-At(IEn,SCMPDS))
    by A1,A59,SCMPDS_2:62
;
    hence thesis by A5,A60,SCMPDS_2:54;
  end;
  suppose
    InsCode i = 11;
    then consider a,b,k1,k2 such that
A66: i = MultBy(a,k1,b,k2) by SCMPDS_2:46;
A67: now
      let c;
      per cases;
      suppose
A68:    DataLoc(ss.a,k1) = c;
        then
A69:    DataLoc(s.a,k1) = c by SCMPDS_3:14;
A70:    ss.DataLoc(ss.b,k2) =s.DataLoc(ss.b,k2) by SCMPDS_3:14
          .=s.DataLoc(s.b,k2) by SCMPDS_3:14;
        ss.DataLoc(ss.a,k1) =s.DataLoc(ss.a,k1) by SCMPDS_3:14
          .=s.DataLoc(s.a,k1) by SCMPDS_3:14;
        hence Exec(i, ss).c = s.DataLoc(s.a,k1) * s.DataLoc(s.b,k2) by A66,A68
,A70,SCMPDS_2:63
          .= Exec(i, s).c by A66,A69,SCMPDS_2:63
          .= (Exec(i, s) +* Start-At(IEn,SCMPDS)).c by SCMPDS_3:14;
      end;
      suppose
A71:    DataLoc(ss.a,k1) <> c;
        then
A72:    DataLoc(s.a,k1) <> c by SCMPDS_3:14;
        thus Exec(i, ss).c = ss.c by A66,A71,SCMPDS_2:63
          .= s.c by SCMPDS_3:14
          .= Exec(i, s).c by A66,A72,SCMPDS_2:63
          .= (Exec(i, s) +* Start-At(IEn,SCMPDS)).c by SCMPDS_3:14;
      end;
    end;
    IC Exec(i, s) = Nl by A66,SCMPDS_2:63;
    then IC Exec(i, ss) = IC (Exec(i, s) +* Start-At(IEn,SCMPDS))
    by A1,A66,SCMPDS_2:63
;
    hence thesis by A5,A67,SCMPDS_2:54;
  end;
  suppose
    InsCode i = 12;
    then consider a,b,k1,k2 such that
A73: i = Divide(a,k1,b,k2) by SCMPDS_2:47;
A74: now
      let c;
A75:  ss.DataLoc(ss.a,k1) =s.DataLoc(ss.a,k1) by SCMPDS_3:14
        .=s.DataLoc(s.a,k1) by SCMPDS_3:14;
A76:  ss.DataLoc(ss.b,k2) =s.DataLoc(ss.b,k2) by SCMPDS_3:14
        .=s.DataLoc(s.b,k2) by SCMPDS_3:14;
      per cases;
      suppose
A77:    DataLoc(ss.b,k2) = c;
        then
A78:    DataLoc(s.b,k2) = c by SCMPDS_3:14;
        thus Exec(i, ss).c = s.DataLoc(s.a,k1) mod s.DataLoc(s.b,k2) by A73,A75
,A76,A77,SCMPDS_2:64
          .= Exec(i, s).c by A73,A78,SCMPDS_2:64
          .= (Exec(i, s) +* Start-At(IEn,SCMPDS)).c by SCMPDS_3:14;
      end;
      suppose
A79:    DataLoc(ss.b,k2) <> c;
        then
A80:    DataLoc(s.b,k2) <> c by SCMPDS_3:14;
        hereby
          per cases;
          suppose
A81:        DataLoc(ss.a,k1) <> c;
            then
A82:        DataLoc(s.a,k1) <> c by SCMPDS_3:14;
            thus Exec(i, ss).c = ss.c by A73,A79,A81,SCMPDS_2:64
              .=s.c by SCMPDS_3:14
              .=Exec(i,s).c by A73,A80,A82,SCMPDS_2:64
              .= (Exec(i, s) +* Start-At(IEn,SCMPDS)).c by SCMPDS_3:14;
          end;
          suppose
A83:        DataLoc(ss.a,k1) = c;
            then
A84:        DataLoc(s.a,k1) = c by SCMPDS_3:14;
            thus Exec(i, ss).c = s.DataLoc(s.a,k1) div s.DataLoc(s.b,k2) by A73
,A75,A76,A79,A83,SCMPDS_2:64
              .= Exec(i,s).c by A73,A80,A84,SCMPDS_2:64
              .= (Exec(i, s) +* Start-At(IEn,SCMPDS)).c by SCMPDS_3:14;
          end;
        end;
      end;
    end;
    IC Exec(i, s) = Nl by A73,SCMPDS_2:64;
    then IC Exec(i, ss) = IC (Exec(i, s) +* Start-At(IEn,SCMPDS))
    by A1,A73,SCMPDS_2:64
;
    hence thesis by A5,A74,SCMPDS_2:54;
  end;
  suppose
    InsCode i = 13;
    then consider a,b,k1,k2 such that
A85: i = (a,k1):=(b,k2) by SCMPDS_2:48;
A86: now
      let c;
      per cases;
      suppose
A87:    DataLoc(ss.a,k1) = c;
        then
A88:    DataLoc(s.a,k1) = c by SCMPDS_3:14;
        thus Exec(i, ss).c = ss.DataLoc(ss.b,k2) by A85,A87,SCMPDS_2:59
          .=s.DataLoc(ss.b,k2) by SCMPDS_3:14
          .=s.DataLoc(s.b,k2) by SCMPDS_3:14
          .=Exec(i,s).c by A85,A88,SCMPDS_2:59
          .= (Exec(i, s) +* Start-At(IEn,SCMPDS)).c by SCMPDS_3:14;
      end;
      suppose
A89:    DataLoc(ss.a,k1) <> c;
        then
A90:    DataLoc(s.a,k1) <> c by SCMPDS_3:14;
        thus Exec(i,ss).c = ss.c by A85,A89,SCMPDS_2:59
          .=s.c by SCMPDS_3:14
          .=Exec(i,s).c by A85,A90,SCMPDS_2:59
          .= (Exec(i, s) +* Start-At(IEn,SCMPDS)).c by SCMPDS_3:14;
      end;
    end;
    IC Exec(i, s) = Nl by A85,SCMPDS_2:59;
    then IC Exec(i, ss) = IC (Exec(i, s) +* Start-At(IEn,SCMPDS))
    by A1,A85,SCMPDS_2:59
;
    hence thesis by A5,A86,SCMPDS_2:54;
  end;
end;

begin :: Computation of two consecutive program blocks

theorem
  for s being 0-started State of SCMPDS
  for I being parahalting halt-free Program of SCMPDS,J being
  parahalting shiftable Program of SCMPDS,k being Element of NAT st
  stop (I ';' J) c= P holds
  NPP IncIC(Comput(P +* stop I +* stop J,
     Initialize Result(P +* stop I,s),k),card I)
  = NPP Comput(P+*stop(I ';' J),s,LifeSpan(P +* stop I,s)+k)
proof
  let s be 0-started State of SCMPDS;
  let I be parahalting halt-free Program of SCMPDS,J be parahalting
  shiftable Program of SCMPDS,k be Element of NAT;
  set sIsI = s, PIPI = P +* stop I,
      RI = Result(PIPI,sIsI), pJ= stop J,
   RIJ = Initialize RI, PRIJ = PIPI +* pJ,
   pIJ = stop (I ';' J),
   sIsIJ = s, PIPIJ = P +* pIJ;
A2: PIPI halts_on sIsI by FUNCT_4:26,SCMPDS_4:def 10;
  set s2 = Comput(PIPIJ, sIsIJ,LifeSpan(PIPI,sIsI)+0);
  set s1 = RIJ +* Start-At (IC RIJ + card I,SCMPDS);
  set m1 = LifeSpan(PIPI,sIsI);
A3: I c= pIJ by Th15;
  assume
A4: pIJ c= P;
B4: P +* pIJ = P by A4,FUNCT_4:104;
A6: now
    thus IC s1 = IC RIJ + card I by FUNCT_4:121
      .=  (0+card I) by FUNCT_4:121
      .= IC s2 by A4,A3,Th30,XBOOLE_1:1,B4;

    hereby
      let a be Int_position;
XX: NPP Comput(P +* stop I, s,m1)
  = NPP Comput(P+*stop(I ';' J),s,m1)
          by Th34;
YY: not a in dom Start-At(0,SCMPDS) by SCMPDS_4:59;
   not a in dom Start-At (IC RIJ + card I,SCMPDS) by SCMPDS_4:59;
      hence s1.a = RIJ.a by FUNCT_4:12
        .= RI.a by FUNCT_4:12,YY
        .= Comput(PIPI, sIsI,m1).a by A2,EXTPRO_1:23
        .= s2.a by XX,SCMPDS_4:13;
    end;
  end;
  defpred X[Element of NAT] means
   NPP IncIC(Comput(PRIJ, RIJ,$1), card I)
   = NPP Comput(PIPIJ, sIsIJ,LifeSpan(PIPI,sIsI)+$1);
A8: pIJ c= PIPIJ by FUNCT_4:26;
A9: for k being Element of NAT st X[k] holds X[k+1]
  proof
    let k be Element of NAT;
    set k1 = k+1, CRk = Comput(PRIJ, RIJ,k),
       PCRk = PRIJ,
       CRSk = IncIC(CRk,card I),
    CIJk = Comput(PIPIJ, sIsIJ,LifeSpan(PIPI,sIsI)+k),
    PCIJk = PIPIJ,
CRk1 = Comput(PRIJ, RIJ,k1
    ), CRSk1 = CRk1 +* Start-At (IC CRk1 + card I,SCMPDS),
    CIJk1 = Comput(PIPIJ, sIsIJ,
    LifeSpan(PIPI,sIsI)+k1);
    assume
A10: NPP CRSk = NPP CIJk;
A11: CurInstr(PCRk,CRk) = CurInstr(PCIJk,CIJk)
    proof
A12:  PCIJk/.IC CIJk = PCIJk.IC CIJk by PBOOLE:158;
A13:  CurInstr(PCIJk,CIJk) = PCIJk.IC CRSk by A10,A12,COMPOS_1:230
        .= PCIJk.(IC CRk + card I) by FUNCT_4:121;
      reconsider n = IC CRk as Element of NAT;
A14:  pIJ = I ';' pJ by AFINSQ_1:30;
A15:  IC CRk in dom pJ by FUNCT_4:26,SCMPDS_4:def 9;
      then n < card pJ by AFINSQ_1:70;
      then n+card I < card pJ + card I by XREAL_1:8;
      then n+card I < card pIJ by A14,AFINSQ_1:20;
      then
A16:  IC CRk + card I in dom pIJ by AFINSQ_1:70;
A17:  PCRk/.IC CRk = PCRk.IC CRk by PBOOLE:158;
      pJ c= PCRk by FUNCT_4:26;
      hence CurInstr(PCRk,CRk) =pJ.IC CRk by A15,A17,GRFUNC_1:8
        .=pIJ.(IC CRk + card I) by A15,A14,AFINSQ_1:def 4
        .= PIPIJ.(IC CRk + card I) by A8,A16,GRFUNC_1:8
        .= CurInstr(PCIJk,CIJk) by A13;
    end;
    NPP CIJk = NPP CRSk by A10;
    then
xx:   NPP Exec(CurInstr(PCIJk,CIJk), CIJk)
     = NPP Exec(CurInstr(PCRk,CRk),CRSk)
      by A11,SCMPDS_4:15;
    pJ c= PCRk by FUNCT_4:26;
    then NPP Exec(CurInstr(PCRk,CRk),CRSk)
      = NPP IncIC(Following(PCRk,CRk), card I) by Th35;
    then
A18: NPP Exec(CurInstr(PCIJk,CIJk), CIJk)
   = NPP IncIC(Following(PCRk,CRk), card I) by xx;
    CIJk1 = Comput(PIPIJ, sIsIJ,LifeSpan(PIPI,sIsI)+
k+1);
    then
A20: CIJk1 = Following(PIPIJ,CIJk) by EXTPRO_1:4;
A21: now
      let a be Int_position;
      thus CRSk1.a = CRk1.a by SCMPDS_3:14
        .= (Following(PRIJ,CRk)).a by EXTPRO_1:4
        .= (Following(PCRk,CRk) +*
        Start-At (IC Following(PCRk,CRk) + card I,SCMPDS)).a
         by SCMPDS_3:14
        .= CIJk1.a by A20,A18,SCMPDS_4:13;
    end;
    IC CRSk1 = IC CRk1 + card I by FUNCT_4:121
      .= IC Following(PRIJ,CRk) + card I by EXTPRO_1:4;
    then
    IC CRSk1=IC (Following(PCRk,CRk) +*
    Start-At (IC Following(PCRk,CRk) + card I,SCMPDS))
    by FUNCT_4:121
      .= IC CIJk1 by A20,A18,COMPOS_1:230;
    hence thesis by A21,SCMPDS_4:11;
  end;
  Comput(PRIJ, RIJ,0) = RIJ by EXTPRO_1:3;
  then
A24: X[0] by A6,SCMPDS_4:11;
  for k being Element of NAT holds X[k] from NAT_1:sch 1(A24,A9);
  hence thesis;
end;

Lm4:
 for I being parahalting halt-free Program of SCMPDS,J being parahalting
shiftable Program of SCMPDS,
  s being 0-started State of SCMPDS,
  s being 0-started State of SCMPDS st stop (I ';' J) c= P & P1= P +* stop I
   holds IC Comput(P, s,LifeSpan(P1,s)) = card I &
  DataPart Comput(P, s,LifeSpan(P1,s)) =
   DataPart (Initialize Comput(P1,s,LifeSpan(P1,s))) &
   Shift(stop J,card I) c= P &
   LifeSpan(P,s) = LifeSpan(P1,s)
    + LifeSpan(P1 +* stop J,Initialize Result(P1,s))
proof
  set D = SCM-Data-Loc;

  let I be parahalting halt-free Program of SCMPDS,J be parahalting
  shiftable Program of SCMPDS,s be 0-started State of SCMPDS,
  s be 0-started State of SCMPDS;
A1: Initialize s = s by COMPOS_1:78;
  set spJ = stop J,
  sIJ = stop (I ';' J), m1 = LifeSpan(P1,s),
  s3 = Initialize Comput(P1, s, m1),
  P3 = P1 +* spJ;
  set m3 = LifeSpan(P3,s3);
  assume that
A3: sIJ c= P and
A4: P1= P +* stop I;
A5: DataPart s3 = DataPart Comput(P1, s,m1) by COMPOS_1:80;
  set s4 = Comput(P,s,m1), P4 = P;
A7: I c= sIJ by Th15;
  hence
A8: IC s4 =  card I by A3,A4,Th30,XBOOLE_1:1;
  reconsider m = m1 + m3 as Element of NAT;
  sIJ = I ';' (J ';' Stop SCMPDS) by AFINSQ_1:30
    .= I +* Shift(spJ, card I);
  then
A15: Shift(spJ, card I) c= sIJ by FUNCT_4:26;
A16: spJ c= P3 by FUNCT_4:26;
A17: P3 halts_on s3 by FUNCT_4:26,SCMPDS_4:def 10;
A20: DataPart Comput(P1, s,m1) = DataPart s3
 by A5;
  I ';' J c= stop (I ';' J) by AFINSQ_1:78;
  then I ';' J c= P by A3,XBOOLE_1:1;
  then P+*(I ';' J) = P by FUNCT_4:104;
  then NPP Comput(P1, s,m1) = NPP Comput(P,s,m1) by A4,Th33,A1;
  hence
A21: DataPart s4 = DataPart s3 by A20,COMPOS_1:138;
A23: Comput(P,s,m1+m3)
 = Comput(P,Comput(P,s,m1),m3) by EXTPRO_1:5;
  Shift(spJ, card I) c= P by A15,A3,XBOOLE_1:1;
  hence
A24: Shift(spJ, card I) c= P4;

  then CurInstr(P3,Comput(P3,s3,m3))
   = CurInstr(P,Comput(P,s,m1+m3))
      by A23,A16,A8,A21,SCMPDS_4:84;
  then
A25: CurInstr(P,Comput(P,s,m))
 = halt SCMPDS by A17,EXTPRO_1:def 14;
A26: now
    let k be Element of NAT;
    assume
    m1 + k < m;
    then
A27: k < m3 by XREAL_1:8;
    assume
A28: CurInstr(P,Comput(P,s,m1+k)) = halt SCMPDS;
A29: Comput(P,s,m1+k) =
Comput(P,Comput(P,s,m1),k) by EXTPRO_1:5;
    CurInstr(P3,Comput(P3,s3,k))
     = halt SCMPDS by A28,A29,A16,A8,A21,A24,SCMPDS_4:84;
    hence contradiction by A17,A27,EXTPRO_1:def 14;
  end;
  now
    let k be Element of NAT;
    assume
A30: k < m;
    per cases;
    suppose
S:    k < m1;
       I c= P by A3,A7,XBOOLE_1:1;
      hence CurInstr(P,Comput(P,s,k)) <>
       halt SCMPDS by A4,Th32,S;
    end;
    suppose
      m1 <= k;
      then consider kk being Nat such that
A31:  m1 + kk = k by NAT_1:10;
      kk in NAT by ORDINAL1:def 13;
      hence CurInstr(P,Comput(P,s,k)) <>
       halt SCMPDS by A26,A30,A31;
    end;
  end;
  then
A32: for k being Element of NAT st CurInstr(P,Comput(P,s,k)) = halt SCMPDS
        holds m <= k;
 stop I c= P1 by A4,FUNCT_4:26;
 then P1 halts_on s by SCMPDS_4:def 10;
  then
A33: Result(P1,s) =
    Comput(P1,s,LifeSpan(P1,s)) by EXTPRO_1:23;
  P halts_on s by A3,SCMPDS_4:def 10;
  hence thesis by A33,A25,A32,EXTPRO_1:def 14;
end;

theorem Th37:
  for s being 0-started State of SCMPDS
  for I being parahalting halt-free Program of SCMPDS,
      J being parahalting shiftable Program of SCMPDS holds
 LifeSpan(P+*stop(I ';' J), s)
  = LifeSpan(P +* stop I,s) +
    LifeSpan(P +* stop I +* stop J,Initialize Result(P +* stop I,s))
proof
  let s be 0-started State of SCMPDS;
  let I be parahalting halt-free Program of SCMPDS,J be parahalting
  shiftable Program of SCMPDS;
  set sI=stop I, sIJ = stop (I ';' J),
  s1= s, s2= s,
  P1 = P +* sIJ, P2 = P +* stop I;
A1: sIJ c= P1 by FUNCT_4:26;
  set
  s3=Initialize Result(P1 +* stop I,s1),
  P3 = P1 +* stop I +* stop J,
  s4=Initialize Result(P2,s2),
  P4 = P2 +* stop J;
A2: stop I c= P2 by FUNCT_4:26;
A3: NPP s1 = NPP(s1 +* stop I) by COMPOS_1:236;
A4: stop J c= P4 by FUNCT_4:26;
A6: stop J c= P3 by FUNCT_4:26;
A7: NPP s2 = NPP(s1+* stop I) by A3;
A8: stop I c= P1 +* stop I by FUNCT_4:26;
  then NPP Result(P2,s2)
   = NPP Result(P1 +* stop I,s1) by A7,A2,Th21;
  then NPP Initialize Result(P2,s2)
   = NPP Initialize Result(P1 +* stop I,s1) by COMPOS_1:81;
  then NPP s4 = NPP s3;
  then
A9: LifeSpan(P3,s3) = LifeSpan(P4,s4) by A6,A4,Th21;
  LifeSpan(P1 +* stop I,s1) =
  LifeSpan(P2,s2) by A7,A8,A2,Th21;
  hence thesis by A1,A9,Lm4;
end;

theorem Th38:
  for s being 0-started State of SCMPDS
  for I being parahalting halt-free Program of SCMPDS,J being
parahalting shiftable Program of SCMPDS holds IExec(I ';' J,P,s)
 = IncIC(IExec(J,P,IExec(I,P,s)),card I)
proof
  let s be 0-started State of SCMPDS;
  let I be parahalting halt-free Program of SCMPDS,J be parahalting
  shiftable Program of SCMPDS;
  set A = NAT, D = SCM-Data-Loc, ps = s | NAT, sI = stop I,
  sIJ = stop (I ';' J),
   s1 = Initialize s, P1 = P +* stop I,
   m1 = LifeSpan(P1,s1),
  s2 = s,
  P2 = P +* stop(I ';' J),
  s3 = Initialize Comput(P1,s1,m1),
  P3 = P1 +* stop J,
  m3 = LifeSpan(P3,s3);
A2: stop J c= P3 by FUNCT_4:26;
A3: P3 halts_on s3 by FUNCT_4:26,SCMPDS_4:def 10;
A4: IExec(I,P,s) | A = ps by PBOOLE:157;
A6: Initialize s = s by COMPOS_1:78;
A9: stop J c= P +* stop J by FUNCT_4:26;
A10: dom ps = dom s /\ A by RELAT_1:90
    .= ({IC SCMPDS} \/ D \/ A) /\ A by SCMPDS_4:19
    .= A by XBOOLE_1:21;
A11: stop I c= P1 by FUNCT_4:26;
  P1 halts_on s1 by FUNCT_4:26,SCMPDS_4:def 10;
  then Result(P1,s1) = Comput(P1,s1,LifeSpan(P1,s1)) by EXTPRO_1:23;
  then
   IExec(I,P,s) = Comput(P1,s1,m1) +* ps;
  then
A12: Initialize Comput(P1,s1,m1) +* ps
      = Initialize IExec(I,P,s) by COMPOS_1:83;
 NPP s3 = NPP Initialize Comput(P1,s1,m1)
   .= NPP(Initialize Comput(P1,s1,m1) +* ps) by COMPOS_1:236
   .= NPP(Initialize Comput(P1,s1,m1) +* ps);
  then NPP(Initialize IExec(I,P,s)) = NPP s3 by A12;
  then NPP Result(P +* stop J,Initialize IExec(I,P,s))
   = NPP Result(P3,s3) by A2,A9,Th21;
  then Result(P +* stop J,
  Initialize IExec(I,P,s)) +* ps = Result(P3,s3) +* ps by A10,COMPOS_1:238;
  then
A13: IExec(J,P,IExec(I,P,s)) = Comput(P3,s3,m3) +* ps by A3,A4,
EXTPRO_1:23;
A15: stop I c= P2 +* stop I by FUNCT_4:26;
A16: Initialize s2 = s2 by COMPOS_1:78;
A18: P2 +* sIJ = P +* (sIJ +* sIJ) by FUNCT_4:15;
A19: P2 +* stop I +* sIJ = P2 +* (stop I +* sIJ) by FUNCT_4:15
      .= P2 +* sIJ by Th17;
  NPP s1 = NPP(Initialize s2);
  then
A20: LifeSpan(P2 +* stop I,Initialize s2) = m1 by A11,A15,Th21;
 set S1=Initialize s2,
     E1 = P2 +* stop I;
X1: NPP Comput(E1,S1,m1)
  = NPP Comput(E1 +* stop(I ';' J), s2,m1) by A15,A20,Th24,A16;
X2: NPP Comput(P1,s1,m1)
  = NPP Comput(P1 +* stop(I ';' J), s1,m1)
     by A11,Th24;
   P +* stop I +* sIJ =  P +* (stop I +* sIJ) by FUNCT_4:15
        .= P +* sIJ by Th17
        .= P +* (sIJ +* sIJ)
        .= P2 +* sIJ by A18
        .= P2 +* stop I +* sIJ by A19;
   then
A21: DataPart Comput(E1,S1,m1)
    = DataPart Comput(P1 +* sIJ,s2,m1) by X1,COMPOS_1:138
    .= DataPart Comput(P1,s1,m1) by A16,X2,COMPOS_1:138;
A22: DataPart(Comput(P2 +* stop I,Initialize s2,m1))
      = DataPart Comput(P1,s1,m1) by A21
     .= DataPart(Comput(P1, s1,m1));
A23: sIJ c= P2 by FUNCT_4:26;
  then
A24: DataPart Comput(P2,s2,m1)
     = DataPart(Initialize Comput(P2 +* stop I,Initialize s2,m1))
       by A20,Lm4,A16
    .= DataPart(Comput(P2 +* stop I, Initialize s2,m1)) by COMPOS_1:80;
A25: Shift(stop J,card I) c= P2 by A23,A20,Lm4;
A26: IC Comput(P2,s2,m1) =  card I by A23,A20,Lm4,A16;
B29: DataPart Initialize Comput(P1,s1,m1)
      = DataPart Comput(P1,s1,m1) by COMPOS_1:80
     .= DataPart(Comput(P2 +* stop I, Initialize s2,m1))
     by A22
     .= DataPart Comput(P2,s2,m1)
     by A24;
  then
A27: IC Comput(P2, Comput(P2,s2,m1),m3) = IC Comput(P3,s3,m3) + card I
        by A25,A2,SCMPDS_4:84,A26;
A29: DataPart Comput(P2, Comput(P2,s2,m1),m3) = DataPart Comput(P3,s3,m3)
   by A26,A25,A2,SCMPDS_4:84,B29;
A30: P1 halts_on s1 by FUNCT_4:26,SCMPDS_4:def 10;
A31: s3 = Initialize Result(P1,s1)
   by A11,EXTPRO_1:23,SCMPDS_4:def 10;
 set SS1 = Initialize Result(P1,s1) +* stop J,
     SS2 = Initialize IExec(I,P,s) +* stop J;
A32: Result(P1,s1) = Comput(P1,s1,m1)
 by A11,EXTPRO_1:23,SCMPDS_4:def 10;
  NPP s3 = NPP Initialize Comput(P1,s1,m1)
   .= NPP(Initialize Comput(P1,s1,m1) +* ps)
           by COMPOS_1:236
   .= NPP(Initialize IExec(I,P,s))
   by A12;
  then NPP Result(P1 +* stop J,Initialize Result(P1,s1))
    = NPP Result(P +* stop J,Initialize IExec(I,P,s))
        by Th21,A2,A9,A32;
  then
A33: IC Result(P1 +* stop J,Initialize Result(P1,s1))
= IC Result(P +* stop J,Initialize IExec(I,P,s))
by COMPOS_1:230;
A34: s3 = Initialize Result(P1,s1) by A30,EXTPRO_1:23;
A35: IC IExec(I ';' J,P,s) = IC Result(P +* sIJ,Initialize s) by Th22
    .= IC Comput(P2,s2,LifeSpan(P2,s2))
     by A23,A6,EXTPRO_1:23,SCMPDS_4:def 10
    .= IC Comput(P2,s2,m1+m3) by A31,Th37,A6
    .= IC Comput(P3,s3,m3) + card I by A27,EXTPRO_1:5
    .= IC Result(P3,s3) + card I by A3,EXTPRO_1:23
    .= IC IExec(J,P,IExec(I,P,s)) + card I by A33,Th22,A34;
  IExec(I ';' J,P,s) = Comput(P2,s2,LifeSpan(P2,s2)) +* ps
    by A23,A6,EXTPRO_1:23,SCMPDS_4:def 10

    .= Comput(P2,s2,m1+m3) +* ps by A31,Th37,A6;
  then
A36: DataPart IExec(I ';' J,P,s) = DataPart Comput(P2,s2,m1+m3) by
A10,AMI_2:29,FUNCT_4:76,SCMPDS_2:100
    .= DataPart Comput(P3,s3,m3) by A29,EXTPRO_1:5
    .= DataPart IExec(J,P,IExec(I,P,s))
     by A10,A13,AMI_2:29,FUNCT_4:76,SCMPDS_2:100;
  hereby
    reconsider l = IC IExec(J,P,IExec(I,P,s)) + card I as Element of NAT;
A37: dom Start-At(l,SCMPDS) = {IC SCMPDS} by FUNCOP_1:19;
A38: now
      let x be set;
      assume
A39:  x in dom IExec(I ';' J,P,s);
      per cases by A39,SCMPDS_4:20;
      suppose
A40:    x is Int_position;
        then x <> IC SCMPDS by SCMPDS_2:52;
        then
A41:    not x in dom Start-At(l,SCMPDS) by A37,TARSKI:def 1;
        IExec(I ';' J,P,s).x = IExec(J,P,IExec(I,P,s)).x
        by A36,A40,SCMPDS_4:23;
        hence
        IExec(I ';' J,P,s).x = (IExec(J,P,IExec(I,P,s)) +*
           Start-At (IC IExec(J,P
        ,IExec(I,P,s)) + card I,SCMPDS)).x by A41,FUNCT_4:12;
      end;
      suppose
A42:    x = IC SCMPDS;
        then x in {IC SCMPDS} by TARSKI:def 1;
        then
A43:    x in dom Start-At(l,SCMPDS) by FUNCOP_1:19;
        thus IExec(I ';' J,P,s).x = (Start-At(l,SCMPDS)).IC SCMPDS
        by A35,A42,FUNCOP_1:87
          .= (IExec(J,P,IExec(I,P,s)) +*
          Start-At (IC IExec(J,P,IExec(I,P,s)) + card
        I,SCMPDS)).x by A42,A43,FUNCT_4:14;
      end;
      suppose
A44:    x is Element of NAT;
        then x <> IC SCMPDS by COMPOS_1:3;
        then
A45:    not x in dom Start-At(l,SCMPDS) by A37,TARSKI:def 1;
        IExec(I ';' J,P,s) | A = ps by PBOOLE:157
          .= IExec(J,P,IExec(I,P,s)) | A by A4,PBOOLE:157;
        then IExec(I ';' J,P,s).x = IExec(J,P,IExec(I,P,s)).x
         by A44,COMPOS_1:127;
        hence
        IExec(I ';' J,P,s).x
         = (IExec(J,P,IExec(I,P,s)) +* Start-At (IC IExec(J,P
        ,IExec(I,P,s)) + card I,SCMPDS)).x by A45,FUNCT_4:12;
      end;
    end;
    dom IExec(I ';' J,P,s) = the carrier of SCMPDS by PARTFUN1:def 4
      .= dom (IExec(J,P,IExec(I,P,s)) +*
      Start-At (IC IExec(J,P,IExec(I,P,s)) + card
    I,SCMPDS)) by PARTFUN1:def 4;
    hence thesis by A38,FUNCT_1:9;
  end;
end;

theorem
 for s being 0-started State of SCMPDS
 for I being parahalting halt-free Program of SCMPDS,J being
  parahalting shiftable Program of SCMPDS holds IExec(I ';' J,P,s).a
   = IExec(J,P,
  IExec(I,P,s)).a
proof
  let s be 0-started State of SCMPDS;
  let I be parahalting halt-free Program of SCMPDS,J be parahalting
  shiftable Program of SCMPDS;
A1: not a in dom Start-At (IC IExec(J,P,IExec(I,P,s)) + card I,SCMPDS)
by SCMPDS_4:59;
  IExec(I ';' J,P,s) = IncIC(IExec(J,P,IExec(I,P,s)),card I) by Th38;
  hence thesis by A1,FUNCT_4:12;
end;

begin :: Computation of the program consisting of a instruction and a block

theorem Th40:
  IC Initialize s = 0 & (Initialize s).a = s.a & (Initialize s).loc = s.loc
proof
  dom SA0 = {IC SCMPDS} by FUNCOP_1:19;
  then
A1: IC SCMPDS in dom SA0 by TARSKI:def 1;
  (SA0).IC SCMPDS =  0 by FUNCOP_1:87;
  hence IC Initialize s =  0 by A1,FUNCT_4:14;
  not a in dom SA0 by SCMPDS_4:59;
  hence (Initialize s).a =s.a by FUNCT_4:12;
  not loc in dom SA0 by COMPOS_1:29;
  hence thesis by FUNCT_4:12;
end;

theorem
  NPP s1 = NPP s2 iff s1 | (SCM-Data-Loc \/ {IC SCMPDS})
  = s2 | (SCM-Data-Loc \/ {IC SCMPDS})
proof
  set Y = NAT;
  set X = SCM-Data-Loc \/ {IC SCMPDS};
X1: NPP s1 = s1|(Data-Locations SCMPDS \/ {IC SCMPDS})
   & NPP s2 = s2|(Data-Locations SCMPDS \/ {IC SCMPDS}) by COMPOS_1:231;
X2: Data-Locations SCMPDS = SCM-Data-Loc by SCMPDS_2:100;
  thus thesis by X1,X2;
end;

canceled;

theorem Th43:
  DataPart s1 = DataPart s2 & InsCode i <> 3 implies
   DataPart Exec(i,s1) = DataPart Exec(i,s2)
proof
  assume that
A1: DataPart s1 = DataPart s2 and
A2: InsCode i <> 3;
  per cases by A2,NAT_1:38,SCMPDS_2:15;
  suppose
    InsCode i = 0;
    then
A3: ex k1 st i = goto k1 by SCMPDS_2:35;
    now
      let a;
      thus Exec(i, s1).a = s1.a by A3,SCMPDS_2:66
        .=s2.a by A1,SCMPDS_4:23
        .=Exec(i, s2).a by A3,SCMPDS_2:66;
    end;
    hence thesis by SCMPDS_4:23;
  end;
  suppose
    InsCode i = 1;
    then consider a such that
A4: i = return a by SCMPDS_2:36;
    now
      let b;
      per cases;
      suppose
A5:     a=b;
        hence Exec(i, s1).b= s1.DataLoc(s1.a,RetSP) by A4,SCMPDS_2:70
          .=s2.DataLoc(s2.a,RetSP) by A1,SCMPDS_3:3
          .=Exec(i,s2).b by A4,A5,SCMPDS_2:70;
      end;
      suppose
A6:     a<>b;
        hence Exec(i, s1).b = s1.b by A4,SCMPDS_2:70
          .=s2.b by A1,SCMPDS_4:23
          .=Exec(i,s2).b by A4,A6,SCMPDS_2:70;
      end;
    end;
    hence thesis by SCMPDS_4:23;
  end;
  suppose
    InsCode i = 2;
    then consider a,k1 such that
A7: i = a := k1 by SCMPDS_2:37;
    now
      let b;
      per cases;
      suppose
A8:     a=b;
        hence Exec(i, s1).b= k1 by A7,SCMPDS_2:57
          .=Exec(i,s2).b by A7,A8,SCMPDS_2:57;
      end;
      suppose
A9:     a<>b;
        hence Exec(i,s1).b = s1.b by A7,SCMPDS_2:57
          .=s2.b by A1,SCMPDS_4:23
          .=Exec(i,s2).b by A7,A9,SCMPDS_2:57;
      end;
    end;
    hence thesis by SCMPDS_4:23;
  end;
  suppose
    InsCode i = 4;
    then
A10: ex a,k1,k2 st i = (a,k1)<>0_goto k2 by SCMPDS_2:39;
    now
      let a;
      thus Exec(i, s1).a = s1.a by A10,SCMPDS_2:67
        .=s2.a by A1,SCMPDS_4:23
        .=Exec(i, s2).a by A10,SCMPDS_2:67;
    end;
    hence thesis by SCMPDS_4:23;
  end;
  suppose
    InsCode i = 5;
    then
A11: ex a,k1,k2 st i = (a,k1)<=0_goto k2 by SCMPDS_2:40;
    now
      let a;
      thus Exec(i, s1).a = s1.a by A11,SCMPDS_2:68
        .=s2.a by A1,SCMPDS_4:23
        .=Exec(i, s2).a by A11,SCMPDS_2:68;
    end;
    hence thesis by SCMPDS_4:23;
  end;
  suppose
    InsCode i = 6;
    then
A12: ex a,k1,k2 st i = (a,k1)>=0_goto k2 by SCMPDS_2:41;
    now
      let a;
      thus Exec(i, s1).a = s1.a by A12,SCMPDS_2:69
        .=s2.a by A1,SCMPDS_4:23
        .=Exec(i, s2).a by A12,SCMPDS_2:69;
    end;
    hence thesis by SCMPDS_4:23;
  end;
  suppose
    InsCode i = 7;
    then consider a,k1,k2 such that
A13: i = (a,k1) := k2 by SCMPDS_2:42;
    now
      let b;
      per cases;
      suppose
A14:    DataLoc(s1.a,k1)=b;
        then
A15:    DataLoc(s2.a,k1)=b by A1,SCMPDS_4:23;
        thus Exec(i, s1).b= k2 by A13,A14,SCMPDS_2:58
          .=Exec(i,s2).b by A13,A15,SCMPDS_2:58;
      end;
      suppose
A16:    DataLoc(s1.a,k1)<>b;
        then
A17:    DataLoc(s2.a,k1)<>b by A1,SCMPDS_4:23;
        thus Exec(i,s1).b = s1.b by A13,A16,SCMPDS_2:58
          .=s2.b by A1,SCMPDS_4:23
          .=Exec(i,s2).b by A13,A17,SCMPDS_2:58;
      end;
    end;
    hence thesis by SCMPDS_4:23;
  end;
  suppose
    InsCode i = 8;
    then consider a,k1,k2 such that
A18: i = AddTo(a,k1,k2) by SCMPDS_2:43;
    now
      let b;
      per cases;
      suppose
A19:    DataLoc(s1.a,k1)=b;
        then
A20:    DataLoc(s2.a,k1)=b by A1,SCMPDS_4:23;
        thus Exec(i, s1).b= s1.DataLoc(s1.a,k1)+k2 by A18,A19,SCMPDS_2:60
          .= s2.DataLoc(s2.a,k1)+k2 by A1,SCMPDS_3:3
          .=Exec(i,s2).b by A18,A20,SCMPDS_2:60;
      end;
      suppose
A21:    DataLoc(s1.a,k1)<>b;
        then
A22:    DataLoc(s2.a,k1)<>b by A1,SCMPDS_4:23;
        thus Exec(i,s1).b = s1.b by A18,A21,SCMPDS_2:60
          .=s2.b by A1,SCMPDS_4:23
          .=Exec(i,s2).b by A18,A22,SCMPDS_2:60;
      end;
    end;
    hence thesis by SCMPDS_4:23;
  end;
  suppose
    InsCode i = 9;
    then consider a,b,k1,k2 such that
A23: i = AddTo(a,k1,b,k2) by SCMPDS_2:44;
    now
      let c;
      per cases;
      suppose
A24:    DataLoc(s1.a,k1)=c;
        then
A25:    DataLoc(s2.a,k1)=c by A1,SCMPDS_4:23;
        thus Exec(i, s1).c = s1.DataLoc(s1.a,k1)+s1.DataLoc(s1.b,k2) by A23,A24
,SCMPDS_2:61
          .= s2.DataLoc(s2.a,k1)+s1.DataLoc(s1.b,k2) by A1,SCMPDS_3:3
          .= s2.DataLoc(s2.a,k1)+s2.DataLoc(s2.b,k2) by A1,SCMPDS_3:3
          .=Exec(i,s2).c by A23,A25,SCMPDS_2:61;
      end;
      suppose
A26:    DataLoc(s1.a,k1)<>c;
        then
A27:    DataLoc(s2.a,k1)<>c by A1,SCMPDS_4:23;
        thus Exec(i,s1).c = s1.c by A23,A26,SCMPDS_2:61
          .=s2.c by A1,SCMPDS_4:23
          .=Exec(i,s2).c by A23,A27,SCMPDS_2:61;
      end;
    end;
    hence thesis by SCMPDS_4:23;
  end;
  suppose
    InsCode i = 10;
    then consider a,b,k1,k2 such that
A28: i = SubFrom(a,k1,b,k2) by SCMPDS_2:45;
    now
      let c;
      per cases;
      suppose
A29:    DataLoc(s1.a,k1)=c;
        then
A30:    DataLoc(s2.a,k1)=c by A1,SCMPDS_4:23;
        thus Exec(i, s1).c = s1.DataLoc(s1.a,k1)-s1.DataLoc(s1.b,k2) by A28,A29
,SCMPDS_2:62
          .= s2.DataLoc(s2.a,k1)-s1.DataLoc(s1.b,k2) by A1,SCMPDS_3:3
          .= s2.DataLoc(s2.a,k1)-s2.DataLoc(s2.b,k2) by A1,SCMPDS_3:3
          .=Exec(i,s2).c by A28,A30,SCMPDS_2:62;
      end;
      suppose
A31:    DataLoc(s1.a,k1)<>c;
        then
A32:    DataLoc(s2.a,k1)<>c by A1,SCMPDS_4:23;
        thus Exec(i,s1).c = s1.c by A28,A31,SCMPDS_2:62
          .=s2.c by A1,SCMPDS_4:23
          .=Exec(i,s2).c by A28,A32,SCMPDS_2:62;
      end;
    end;
    hence thesis by SCMPDS_4:23;
  end;
  suppose
    InsCode i = 11;
    then consider a,b,k1,k2 such that
A33: i = MultBy(a,k1,b,k2) by SCMPDS_2:46;
    now
      let c;
      per cases;
      suppose
A34:    DataLoc(s1.a,k1)=c;
        then
A35:    DataLoc(s2.a,k1)=c by A1,SCMPDS_4:23;
        thus Exec(i, s1).c = s1.DataLoc(s1.a,k1)*s1.DataLoc(s1.b,k2) by A33,A34
,SCMPDS_2:63
          .= s2.DataLoc(s2.a,k1)*s1.DataLoc(s1.b,k2) by A1,SCMPDS_3:3
          .= s2.DataLoc(s2.a,k1)*s2.DataLoc(s2.b,k2) by A1,SCMPDS_3:3
          .=Exec(i,s2).c by A33,A35,SCMPDS_2:63;
      end;
      suppose
A36:    DataLoc(s1.a,k1)<>c;
        then
A37:    DataLoc(s2.a,k1)<>c by A1,SCMPDS_4:23;
        thus Exec(i,s1).c = s1.c by A33,A36,SCMPDS_2:63
          .=s2.c by A1,SCMPDS_4:23
          .=Exec(i,s2).c by A33,A37,SCMPDS_2:63;
      end;
    end;
    hence thesis by SCMPDS_4:23;
  end;
  suppose
    InsCode i = 12;
    then consider a,b,k1,k2 such that
A38: i = Divide(a,k1,b,k2) by SCMPDS_2:47;
    now
      let c;
      per cases;
      suppose
A39:    DataLoc(s1.b,k2)=c;
        then
A40:    DataLoc(s2.b,k2)=c by A1,SCMPDS_4:23;
        thus Exec(i, s1).c = s1.DataLoc(s1.a,k1) mod s1.DataLoc(s1.b,k2) by A38
,A39,SCMPDS_2:64
          .= s2.DataLoc(s2.a,k1) mod s1.DataLoc(s1.b,k2) by A1,SCMPDS_3:3
          .= s2.DataLoc(s2.a,k1) mod s2.DataLoc(s2.b,k2) by A1,SCMPDS_3:3
          .= Exec(i,s2).c by A38,A40,SCMPDS_2:64;
      end;
      suppose
A41:    DataLoc(s1.b,k2)<>c;
        then
A42:    DataLoc(s2.b,k2)<>c by A1,SCMPDS_4:23;
        hereby
          per cases;
          suppose
A43:        DataLoc(s1.a,k1)<>c;
            then
A44:        DataLoc(s2.a,k1)<>c by A1,SCMPDS_4:23;
            thus Exec(i, s1).c = s1.c by A38,A41,A43,SCMPDS_2:64
              .=s2.c by A1,SCMPDS_4:23
              .=Exec(i,s2).c by A38,A42,A44,SCMPDS_2:64;
          end;
          suppose
A45:        DataLoc(s1.a,k1)=c;
            then
A46:        DataLoc(s2.a,k1)=c by A1,SCMPDS_4:23;
            thus Exec(i, s1).c = s1.DataLoc(s1.a,k1) div s1.DataLoc(s1.b,k2)
            by A38,A41,A45,SCMPDS_2:64
              .= s2.DataLoc(s2.a,k1) div s1.DataLoc(s1.b,k2) by A1,SCMPDS_3:3
              .= s2.DataLoc(s2.a,k1) div s2.DataLoc(s2.b,k2) by A1,SCMPDS_3:3
              .= Exec(i,s2).c by A38,A42,A46,SCMPDS_2:64;
          end;
        end;
      end;
    end;
    hence thesis by SCMPDS_4:23;
  end;
  suppose
    InsCode i = 13;
    then consider a,b,k1,k2 such that
A47: i = (a,k1):=(b,k2) by SCMPDS_2:48;
    now
      let c;
      per cases;
      suppose
A48:    DataLoc(s1.a,k1)=c;
        then
A49:    DataLoc(s2.a,k1)=c by A1,SCMPDS_4:23;
        thus Exec(i, s1).c = s1.DataLoc(s1.b,k2) by A47,A48,SCMPDS_2:59
          .= s2.DataLoc(s2.b,k2) by A1,SCMPDS_3:3
          .=Exec(i,s2).c by A47,A49,SCMPDS_2:59;
      end;
      suppose
A50:    DataLoc(s1.a,k1)<>c;
        then
A51:    DataLoc(s2.a,k1)<>c by A1,SCMPDS_4:23;
        thus Exec(i,s1).c = s1.c by A47,A50,SCMPDS_2:59
          .=s2.c by A1,SCMPDS_4:23
          .=Exec(i,s2).c by A47,A51,SCMPDS_2:59;
      end;
    end;
    hence thesis by SCMPDS_4:23;
  end;
end;

theorem Th44:
  for i being shiftable Instruction of SCMPDS holds (DataPart s1 =
  DataPart s2 implies DataPart Exec(i,s1) = DataPart Exec(i,s2))
proof
  let i be shiftable Instruction of SCMPDS;
  InsCode i <> 3 by SCMPDS_4:def 13;
  hence thesis by Th43;
end;

theorem Th45:
  for i being parahalting Instruction of SCMPDS
   holds Exec(i,Initialize s) = IExec(Load i,P,s)
proof
  let i be parahalting Instruction of SCMPDS;
  set Li=Load i, Mi= stop Li;
  set sI = Initialize s, PI = P +* Mi;
  set Is = Initialize s;
  set IC1 = IC Comput(PI, sI,1);
A2: PI halts_on sI by FUNCT_4:26,SCMPDS_4:def 10;
A3:  1 in dom Mi by Th9;
A4:  0 in dom Mi by Th9;
A5: now
    set Y = NAT;
    set X = SCM-Data-Loc \/ {IC SCMPDS};
    assume
A6: Result(PI,sI) = Exec(i, sI);
A8: Y /\ (X \/ Y) c= Y /\ (X \/ Y);
A9: dom Exec(i, Is) = the carrier of SCMPDS by PARTFUN1:def 4;
A10: dom s = the carrier of SCMPDS by PARTFUN1:def 4;
  then dom s = X \/ Y by COMPOS_1:160,SCMPDS_2:100;
  then
A11: dom s = X \/ Y;
    now
      thus
A12:     dom (Exec(i, Is) | Y) = dom s /\ Y
       by A9,A10,RELAT_1:90;
      let x;
      assume
    x in dom (Exec(i, Is) | Y);
      then x in dom s /\ Y by A12;
      then
A13:  x in Y /\ (X \/ Y)
        by A11;
      then reconsider x9 = x as Element of NAT by XBOOLE_1:21;
      x in Y by A13,XBOOLE_1:21;
      hence (Exec(i, Is)|Y).x = (Exec(i, Is)).x by FUNCT_1:72
        .= Is.x9 by AMI_1:def 13
        .= s.x by Th40;
    end;
    then
A14: Exec(i, Is) | Y = s | Y by FUNCT_1:68;
    dom Exec(i, sI) = the carrier of SCMPDS by PARTFUN1:def 4;
    then dom Exec(i, sI) = X \/ Y by COMPOS_1:160,SCMPDS_2:100;
    then
A15: IExec(Li,P,s) | Y = s | Y by A6,A11,A8,FUNCT_4:93;
    X misses Y
    proof
      assume
      X meets Y;
      then consider x such that
A16:  x in X and
A17:  x in Y by XBOOLE_0:3;
A18:  x in SCM-Data-Loc or x in {IC SCMPDS} by A16,XBOOLE_0:def 3;
      per cases by A18,TARSKI:def 1;
      suppose
        x in SCM-Data-Loc;
        hence contradiction by A17,AMI_2:29,XBOOLE_0:3;
      end;
      suppose
        x = IC SCMPDS;
        then reconsider l=IC SCMPDS as Element of NAT by A17;
        l=IC SCMPDS;
        hence contradiction by COMPOS_1:3;
      end;
    end;
    then X misses dom (s|Y) by RELAT_1:87,XBOOLE_1:63;
    then IExec(Li,P,s) | X = Exec(i, sI) | X by A6,FUNCT_4:76;
    then
A19: Exec(i, Is)| (X \/ Y) = IExec(Li,P,s) | (X \/ Y)
 by A15,A14,RELAT_1:185;
  dom IExec(Li,P,s) = the carrier of SCMPDS by PARTFUN1:def 4;
    then
A20:   dom IExec(Li,P,s) = X \/ Y by COMPOS_1:160,SCMPDS_2:100;
A21:  dom Exec(i, Is) = the carrier of SCMPDS by PARTFUN1:def 4;
  dom Exec(i, Is) = X \/ Y by A21,COMPOS_1:160,SCMPDS_2:100;
    hence Exec(i, Is) = Exec(i, Is)| (X \/ Y)
     by RELAT_1:98
      .= IExec(Li,P,s) | (X \/ Y) by A19
      .= IExec(Li,P,s)
       by A20,RELAT_1:98;
  end;
A22: Mi. 1=halt SCMPDS by Th10;
A23: Mi. 0 = i by Th10;
A24: Mi c= PI by FUNCT_4:26;
A25: IC1 in dom Mi by FUNCT_4:26,SCMPDS_4:def 9;
A26: PI/.IC sI = PI.IC sI by PBOOLE:158;
A27: Comput(PI, sI,0+1)
 = Following(PI,Comput(PI,sI,0))
by EXTPRO_1:4
    .= Following(PI,sI) by EXTPRO_1:3
    .= Exec(PI. 0, sI) by A26,COMPOS_1:223
    .= Exec(i, sI) by A4,A23,A24,GRFUNC_1:8;
  per cases by A25,Th11;
  suppose
A28: IC1 =  0;
    set Ni=InsCode i;
    succ IC sI = succ  0 by COMPOS_1:223
      .=  1;
    then
A29: Ni in {0,1,4,5,6} by A27,A28,SCMPDS_4:6;
A30: CurInstr(PI,Comput(PI,sI,1)) = PI. 0 by A28,PBOOLE:158
      .= i by A4,A23,A24,GRFUNC_1:8;
A31: Ni <> 1 by Th26;
    hereby
      per cases;
      suppose
        i = halt SCMPDS;
        hence thesis by A2,A5,A27,A30,EXTPRO_1:def 8;
      end;
      suppose
A32:    i <> halt SCMPDS;
A33:    for loc holds sI.loc = Exec(i, sI).loc by AMI_1:def 13;
A34:    now
          let b;
          per cases by A29,A31,ENUMSET1:def 3;
          suppose
            InsCode i = 0;
            then ex k1 st i = goto k1 by SCMPDS_2:35;
            hence sI.b=Exec(i, sI).b by SCMPDS_2:66;
          end;
          suppose
            InsCode i = 4;
            then ex a,k1,k2 st i = (a,k1)<>0_goto k2 by SCMPDS_2:39;
            hence sI.b=Exec(i, sI).b by SCMPDS_2:67;
          end;
          suppose
            InsCode i = 5;
            then ex a,k1,k2 st i = (a,k1)<=0_goto k2 by SCMPDS_2:40;
            hence sI.b=Exec(i, sI).b by SCMPDS_2:68;
          end;
          suppose
            InsCode i = 6;
            then ex a,k1,k2 st i = (a,k1)>=0_goto k2 by SCMPDS_2:41;
            hence sI.b=Exec(i, sI).b by SCMPDS_2:69;
          end;
        end;
A35:    Following(PI,sI)
 = Following(PI,Comput(PI,sI,0)) by EXTPRO_1:3
          .= Exec(i, sI) by A27,EXTPRO_1:4;
A36:    IC sI = IC Exec(i, sI) by A27,A28,COMPOS_1:223;
        then
A37:    sI = Exec(i, sI) by A34,A33,SCMPDS_2:54;
        now
          let n;
          Comput(PI, sI,n) = sI by A36,A34,A33,A35,EXTPRO_1:27
,SCMPDS_2:54
            .= Following(PI,Comput(PI,sI,0))
            by A37,A35,EXTPRO_1:3
            .= Comput(PI, sI,0+1) by EXTPRO_1:4;
          hence CurInstr(PI,Comput(PI,sI,n))
           <> halt SCMPDS by A30,A32;
        end;
        then not PI halts_on sI by EXTPRO_1:30;
        hence thesis by FUNCT_4:26,SCMPDS_4:def 10;
      end;
    end;
  end;
  suppose
A38:    IC1 =  1;
    CurInstr(PI,Comput(PI,sI,1))
     = PI. 1 by A38,PBOOLE:158
      .= halt SCMPDS by A3,A22,A24,GRFUNC_1:8;
    hence thesis by A2,A5,A27,EXTPRO_1:def 8;
  end;
end;

theorem Th46:
 for s being 0-started State of SCMPDS
  for I being parahalting halt-free Program of SCMPDS,
      j being parahalting shiftable Instruction of SCMPDS
 holds IExec(I ';' j,P,s).a = Exec(j,IExec(I,P,s)).a
proof
  let s be 0-started State of SCMPDS;
  let I be parahalting halt-free Program of SCMPDS,j be parahalting
  shiftable Instruction of SCMPDS;
  set Mj = Load j;
  set SA = Start-At (IC IExec(Mj,P,IExec(I,P,s)) + card I,SCMPDS);
A1: not a in dom SA by SCMPDS_4:59;
A2: a in SCM-Data-Loc by SCMPDS_2:def 2;
  for a holds (Initialize IExec(I,P,s)).a=IExec(I,P,s).a by Th40;
  then
A3: DataPart Initialize IExec(I,P,s) = DataPart IExec(I,P,s) by SCMPDS_4:23;

  thus IExec(I ';' j,P,s).a = IncIC(IExec(Mj,P,IExec(I,P,s)),card I).a by Th38
    .= IExec(Mj,P, IExec(I,P,s)).a by A1,FUNCT_4:12
    .= Exec(j, Initialize IExec(I,P,s)).a by Th45
    .= (DataPart Exec(j, Initialize IExec(I,P,s))).a by A2,FUNCT_1:72
,SCMPDS_2:100
    .= (DataPart Exec(j, IExec(I,P,s))).a by A3,Th44
    .= Exec(j, IExec(I,P,s)).a by A2,FUNCT_1:72,SCMPDS_2:100;
end;

theorem
  for s being 0-started State of SCMPDS
  for i being No-StopCode parahalting Instruction of SCMPDS, j being
shiftable parahalting Instruction of SCMPDS
 holds IExec(i ';' j,P,s).a = Exec(j,Exec(i, Initialize s)).a
proof
  let s be 0-started State of SCMPDS;
  let i be No-StopCode parahalting Instruction of SCMPDS, j be shiftable
  parahalting Instruction of SCMPDS;
  set Mi = Load i;
  thus IExec(i ';' j,P,s).a = IExec(Mi ';' j,P, s).a
    .= Exec(j, IExec(Mi,P,s)).a by Th46
    .= Exec(j, Exec(i, Initialize s)).a by Th45;
end;

theorem
  IExec(I,P,Initialize s) = IExec(I,P,s)
proof
  (Initialize s)|NAT = s|NAT +* SA0|NAT by FUNCT_4:75
    .= s|NAT +* {} by COMPOS_1:47
    .= s|NAT by FUNCT_4:22;
 hence IExec(I,P,Initialize s) = IExec(I,P,s);
end;
