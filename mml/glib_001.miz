:: Walks in a Graph
::  by Gilbert Lee
:: 
:: Received February 22, 2005
:: Copyright (c) 2005 Association of Mizar Users

environ

 vocabularies ARYTM, ARYTM_1, ARYTM_3, BOOLE, CARD_1, CAT_1, FINSEQ_1,
      FINSEQ_5, FINSET_1, FUNCT_1, FUNCT_4, GRAPH_1, GRAPH_2, GLIB_000,
      GLIB_001, MATRIX_2, MCART_1, MSAFREE2, NAT_1, NEWTON, PRE_TOPC, QUANTAL1,
      REALSET1, RELAT_1, TOPGEN_1;
 notations TARSKI, XBOOLE_0, NUMBERS, SUBSET_1, XCMPLX_0, XREAL_0, DOMAIN_1,
      RELAT_1, FUNCT_1, FINSEQ_1, FINSEQ_2, CARD_1, GRAPH_2, CARD_FIL,
      FINSEQ_5, ORDINAL1, RELSET_1, MCART_1, FINSET_1, NAT_1, CQC_LANG,
      FUNCT_4, GLIB_000, ABIAN;
 constructors WELLORD2, DOMAIN_1, NAT_1, CARD_FIL, RECDEF_1, AMISTD_2,
      GLIB_000, ABIAN, GRAPH_2, FINSEQ_5, BINARITH;
 registrations SUBSET_1, RELSET_1, FINSET_1, XREAL_0, PNPROC_1, BINARITH,
      INT_1, ABIAN, FINSEQ_1, GRAPH_3, NAT_1, TREES_2, FUNCT_1, JORDAN1D,
      XBOOLE_0, RELAT_1, NUMBERS, ORDINAL2, GLIB_000;
 requirements ARITHM, BOOLE, NUMERALS, REAL, SUBSET;
 theorems ABIAN, AMI_1, AMI_5, AMISTD_2, AXIOMS, CARD_1, CARD_2, CQC_LANG,
      CQC_THE1, ENUMSET1, FINSEQ_1, FINSEQ_2, FINSEQ_3, FINSEQ_4, FINSEQ_5,
      FINSEQ_6, FINSET_1, FUNCT_1, FUNCT_4, GLIB_000, GRAPH_2, GRAPH_5,
      HEYTING3, INT_1, JORDAN12, MCART_1, NAT_1, NAT_2, PEPIN, REAL_1, RELAT_1,
      SPPOL_1, TARSKI, XBOOLE_0, XBOOLE_1, XCMPLX_0, XCMPLX_1, XREAL_1,
      PRE_CIRC;
 schemes BINARITH, FINSEQ_1, FUNCT_1, NAT_1, RECDEF_1;

begin :: Preliminaries

theorem tODD01: ::tODD01
  for x,y being odd Nat holds
    x < y iff x + 2 <= y proof
    let x,y be odd Nat;
    hereby assume x < y; then
        x + 1 <= y by NAT_1:38; then
        x + 1 < y by REAL_1:def 5; then
        x + 1 + 1 < y + 1 by REAL_1:67;
        hence x + 2 <= y by NAT_1:38;
    end;
    assume x + 2 <= y; then
    x + 2 - 2 < y - 0 by REAL_1:92;
    hence x < y;
end;    

tREAL01:
  for x, y, z being real number holds
    0 < z & x * z <= y * z implies x <= y by XREAL_1:70;

tCARD01:
  for F being finite Function holds card (dom F) = card F by PRE_CIRC:21;

theorem tSGM01: ::tSGM01
  for X being set, k being Nat st X c= Seg k holds
    (for m,n being Nat st m in dom (Sgm X) & n = (Sgm X).m
       holds m <= n) proof
    let X be set, k be Nat; assume
A1: X c= Seg k;
    let m, n be Nat; assume
A2: m in dom (Sgm X) & n = (Sgm X).m;
    defpred P[Nat] means ($1 in dom (Sgm X) & (ex n being Nat st n=(Sgm X).$1 &
                          $1 <= n)) or (not $1 in dom (Sgm X));
    now 1 <= m & m <= len (Sgm X) by A2, FINSEQ_3:27; then
        1 <= len (Sgm X) by AXIOMS:22;
        hence 1 in dom (Sgm X) by FINSEQ_3:27; then
    B1: (Sgm X).1 in rng (Sgm X) by FUNCT_1:12; set n = (Sgm X).1;
        reconsider n as Nat by B1;
        take n;
        thus n = (Sgm X).1;
        rng (Sgm X) = X by A1, FINSEQ_1:def 13; 
        hence 1 <= n by A1,B1,FINSEQ_1:3;
    end; then
A3: P[1];
    now let x be non empty Nat; assume
    B1: P[x];
        now per cases by B1;
        suppose
        C1: x in dom (Sgm X) & ex n being Nat st n = (Sgm X).x & x <= n; then
        C2: 1 <= x by FINSEQ_3:27;
        C3: x+0 < x+1 by REAL_1:67;
            consider n being Nat such that
        C4: n = Sgm(X).x & x <= n by C1;
            now assume
            D1: x+1 in dom (Sgm X);
                set n1 = (Sgm X).(x+1);
            D2: (Sgm X).(x+1) in rng (Sgm X) by D1, FUNCT_1:12;
                reconsider n1 as Nat by D2;
                take n1;
                thus n1 = (Sgm X).(x+1);
                x+1 <= len Sgm X by D1, FINSEQ_3:27; then
                n < n1 by A1, C2, C3, C4, FINSEQ_1:def 13; then
                x < n1 by C4, AXIOMS:22;
                hence x+1 <= n1 by NAT_1:38;
            end;
            hence P[x+1]; end;
        suppose not x in dom (Sgm X); then
            x < 0+1 or x > len Sgm X by FINSEQ_3:27; then
            x <= 0 or x > len Sgm X by NAT_1:38; then
            x+1 > len Sgm X + 0 by NAT_1:18, REAL_1:67;
            hence P[x+1] by FINSEQ_3:27; end;
        end;
        hence P[x+1];
    end; then
A4: for x being non empty Nat st P[x] holds P[x+1];
A5: for x being non empty Nat holds P[x] from BINARITH:sch 1(A3,A4);
    m <> 0 by A2, FINSEQ_3:27; then reconsider m'=m as non empty Nat;
    P[m'] by A5; then
    consider n' being Nat such that
A6: n' = (Sgm X).m & m <= n' by A2;
    thus m <= n by A2, A6;
end;    

theorem tFINSUBSEQ01: ::tFINSUBSEQ01
  for X being set, fs being FinSequence of X,
      fss being FinSubsequence of fs holds len (Seq fss) <= len fs proof
    let X be set, fs be FinSequence of X, fss be FinSubsequence of fs;
A0: fss c= fs by GRAPH_2:def 5;
    dom fss c= dom fs by GRAPH_2:27; then
A2: dom fss c= Seg len fs by FINSEQ_1:def 3;
A3: Seq fss = fss * Sgm(dom fss) by FINSEQ_1:def 14;
    rng (Sgm(dom fss)) = dom fss by A2, FINSEQ_1:def 13; then
    len (Seq fss) = len Sgm (dom fss) by A3, FINSEQ_2:33
                 .= card (dom fss) by A2, FINSEQ_3:44
                 .= card fss by tCARD01;
    hence len (Seq fss) <= len fs by A0, CARD_1:80;
end;     

theorem tFINSUBSEQ02: ::tFINSUBSEQ02
  for X being set, fs being FinSequence of X, fss being FinSubsequence of fs,
      m being Nat st m in dom Seq fss holds
    ex n being Nat st n in dom fs & m <= n & (Seq fss).m = fs.n proof
    let X be set, fs be FinSequence of X, fss be FinSubsequence of fs,
        m be Nat;
A1: fss c= fs by GRAPH_2:def 5; set f = Sgm(dom fss), n = f.m;
A2: Seq fss = fss * f by FINSEQ_1:def 14; assume
A3: m in dom Seq fss; then
    m in dom (fss * f) by FINSEQ_1:def 14; then
A4: m in dom f & n in dom fss by FUNCT_1:21;
    (Seq fss).m = fss.n by A2,A3,FUNCT_1:22; then
    [n, Seq(fss).m] in fss by A4, FUNCT_1:def 4; then
A5: n in dom fs & (Seq fss).m = fs.n by A1, FUNCT_1:8; then
    reconsider n as Nat;
    set X = dom fss;
    consider k being Nat such that
A6: dom fss c= Seg k by FINSEQ_1:def 12;
    m <= n by A4, A6, tSGM01;
    hence thesis by A5;
end;  

theorem tFINSUBSEQ03: ::tFINSUBSEQ03
  for X being set, fs being FinSequence of X, fss being FinSubsequence of fs
    holds len Seq fss = card fss proof
    let X be set, fs be FinSequence of X, fss be FinSubsequence of fs;    
A1: Seq fss = fss * Sgm(dom fss) by FINSEQ_1:def 14;
    consider k being Nat such that
A2: dom fss c= Seg k by FINSEQ_1:def 12;
    rng Sgm(dom fss) = dom fss by A2, FINSEQ_1:def 13; then
    dom (Seq fss) = dom (Sgm (dom fss)) by A1, RELAT_1:46; then
    dom (Seq fss) = Seg (card dom fss) by A2, FINSEQ_3:45; then
    len Seq fss = card dom fss by FINSEQ_1:def 3;
    hence len Seq fss = card fss by tCARD01;
end;

theorem tFINSUBSEQ04: ::tFINSUBSEQ04
  for X being set, fs being FinSequence of X, fss being FinSubsequence of fs
    holds dom Seq fss = dom Sgm (dom fss) proof
    let X be set, fs be FinSequence of X, fss be FinSubsequence of fs;
    consider k being Nat such that
A1: dom fss c= Seg k by FINSEQ_1:def 12;    
A2: Seq fss = fss * Sgm (dom fss) by FINSEQ_1:def 14;
    rng Sgm(dom fss) c= dom fss by A1, FINSEQ_1:def 13;
    hence dom Seq fss = dom Sgm (dom fss) by A2, RELAT_1:46;
end;

begin :: Definitions

definition let G be _Graph; 
  mode VertexSeq of G -> FinSequence of the_Vertices_of G means :dVSEQ: ::dVSEQ
    for n being Nat st 1 <= n & n < len it holds
      ex e being set st e Joins it.n, it.(n+1), G;
  existence proof
    set v = choose the_Vertices_of G, IT = <*v*>;
    reconsider IT as FinSequence of the_Vertices_of G;
    take IT;
    let n be Nat; assume 1 <= n & n < len IT;
    hence thesis by FINSEQ_1:57;
  end;
end;

definition let G be _Graph;
  mode EdgeSeq of G -> FinSequence of the_Edges_of G means :dESEQ: ::dESEQ
    ex vs being FinSequence of the_Vertices_of G st
      len vs = len it + 1 &
      for n being Nat st 1 <= n & n <= len it holds
        it.n Joins vs.n,vs.(n+1),G;
  existence proof
    set IT = {}, vs = <*choose the_Vertices_of G*>;
    reconsider IT as FinSequence of the_Edges_of G by FINSEQ_1:29;
    reconsider vs as FinSequence of the_Vertices_of G;
    take IT, vs;
    len vs = 0 + 1 by FINSEQ_1:57;
    hence len vs = len IT + 1 by FINSEQ_1:25;
    let n be Nat; assume 1 <= n & n <= len IT;
    hence thesis by FINSEQ_1:25;
  end;
end;

definition let G be _Graph;
  mode Walk of G -> FinSequence of the_Vertices_of G \/ the_Edges_of G means
    :dWALK: ::dWALK
    len it is odd & it.1 in the_Vertices_of G &
    for n being odd Nat st n < len it holds it.(n+1) Joins it.n, it.(n+2), G;
  existence proof 
    set VE = (the_Vertices_of G) \/ (the_Edges_of G);
    consider v being set such that
A1: v in the_Vertices_of G by XBOOLE_0:def 1;
    reconsider v as Element of VE by A1, XBOOLE_0:def 2;
    take <*v*>;
    thus len <*v*> is odd by FINSEQ_1:57, JORDAN12:3; 
    thus <*v*>.1 in the_Vertices_of G by A1, FINSEQ_1:57;
    let n be odd Nat; assume n < len <*v*>; then
    n < 1 by FINSEQ_1:57;
    hence thesis by HEYTING3:1;
end;
end;

registration let G be _Graph, W be Walk of G;
  cluster len W -> odd non empty;
  correctness proof
    thus len W is odd by dWALK; then
    len W <> 0 by HEYTING3:1;
    hence len W is non empty;
  end;
end;

definition let G be _Graph, v be Vertex of G;
  func G.walkOf(v) -> Walk of G equals :dWALKOFV: ::dWALKOFV
    <*v*>;
  coherence proof
    set VE = (the_Vertices_of G) \/ (the_Edges_of G), W = <*v*>, v' = v;
    reconsider v' as Element of VE by XBOOLE_0:def 2;
    <*v'*> is FinSequence of VE; then reconsider W as FinSequence of VE;
    now thus len W is odd by FINSEQ_1:57, JORDAN12:3;
        W.1 = v by FINSEQ_1:57;
        hence W.1 in the_Vertices_of G;
        let n be odd Nat; assume n < len <*v*>; then
        1 <= n & n < 1 by FINSEQ_1:57, HEYTING3:1;
        hence W.(n+1) Joins W.n, W.(n+2), G;
    end;
    hence <*v*> is Walk of G by dWALK;
  end;
end;

definition let G be _Graph, x,y,e be set;
    func G.walkOf(x,e,y) -> Walk of G equals: dWALKOFE: ::dWALKOFE
      <*x,e,y*> if e Joins x,y,G otherwise G.walkOf(choose the_Vertices_of G);
   coherence proof
    set VE = (the_Vertices_of G)\/(the_Edges_of G);
    hereby assume
    B1: e Joins x,y,G; then
        x is Vertex of G & y is Vertex of G by GLIB_000:16; then
    B3: x is Element of VE & y is Element of VE by XBOOLE_0:def 2;
        e in the_Edges_of G by B1, GLIB_000:def 15; then
    B4: e is Element of VE by XBOOLE_0:def 2;
        set W = <*x,e,y*>;
        reconsider W as FinSequence of VE by B3, B4, FINSEQ_2:16;
    B5: len W = 3 & W.1 = x & W.2 = e & W.3 = y by FINSEQ_1:62;
        now reconsider _1=1 as odd Nat by JORDAN12:3;
            _1+2 is odd;
            hence len W is odd by FINSEQ_1:62;
            thus W.1 in the_Vertices_of G by B5, B1, GLIB_000:16;
            let n be odd Nat; assume n < len W; then
            n < 2 + 1 by FINSEQ_1:62; then
            n <= 2*1 by NAT_1:38; then
            n = 2*0 or n = 1 or n = 2*1 by CQC_THE1:3;
            hence W.(n+1) Joins W.n,W.(n+2),G by B1,B5;
        end;
        hence <*x,e,y*> is Walk of G by dWALK;
    end;
    thus thesis;
  end;
  consistency;
end;

definition let G be _Graph, W be Walk of G;
  func W.first() -> Vertex of G equals :dWFIRST:  ::dWFIRST
    W.1;
  coherence by dWALK;

  func W.last() -> Vertex of G equals :dWLAST: ::dWLAST
    W.(len W);
  coherence proof
    now per cases;
    suppose len W = 1;
        hence thesis by dWALK; end;
    suppose   
    B1: len W <> 1;
        1 <= len W by HEYTING3:1; then
        1 < len W by B1, REAL_1:def 5; then
        1+1 < len W + 1 by REAL_1:67; then
        2 <= len W by NAT_1:38; then
        reconsider n = len W - 2 * 1 as odd Nat by INT_1:18;
    B2: n + 2 = len W; then
        n < len W by NAT_1:41; then
        W.(n+1) Joins W.n, W.(len W), G by B2, dWALK;
        hence thesis by GLIB_000:16; end;
    end;
    hence thesis;
  end;
end;

definition let G be _Graph, W be Walk of G, n be Nat; 
  func W.vertexAt(n) -> Vertex of G equals :dWVAT: ::dWVAT
    W.n if n is odd & n <= len W otherwise W.first();
  correctness proof
    hereby assume
    B1: n is odd & n <= len W;
        now per cases;
        suppose n = len W; then
            W.n = W.last() by dWLAST;
            hence W.n is Vertex of G; end;
        suppose n <> len W; then
            n < len W by B1, REAL_1:def 5; then
            W.(n+1) Joins W.n, W.(n+2), G by B1, dWALK;
            hence W.n is Vertex of G by GLIB_000:16; end;
        end;
        hence W.n is Vertex of G;
    end;
    thus thesis;
  end;
end;

definition let G be _Graph, W be Walk of G; 
  func W.reverse() -> Walk of G equals :dWREV: ::dWREV
    Rev W;
  coherence proof
    set W' = Rev W;
    reconsider W' as FinSequence of (the_Vertices_of G)\/(the_Edges_of G);
A1: len W' = len W by FINSEQ_5:def 3;
    now thus len W' is odd by A1;
        W'.1 = W.(len W) by FINSEQ_5:65; then
        W'.1 = W.last() by dWLAST;
        hence W'.1 in the_Vertices_of G;
        let n be odd Nat; assume
    B1: n < len W';
    B2: now 1 <= n & n <= len W by B1, FINSEQ_5:def 3, HEYTING3:1;
            hence n in dom W by FINSEQ_3:27;
        C1: 1 <= n+1 & 1 <= n+2 by NAT_1:37;
        C2: n+1 <= len W by A1, B1, NAT_1:38;
            hence n+1 in dom W by C1, FINSEQ_3:27;
            n+1 < len W by C2, REAL_1:def 5; then
            n+1+1 <= len W by NAT_1:38; 
            hence n+2 in dom W by C1, FINSEQ_3:27;
        end; then
    B4: n <= len W & n+1 <= len W & n+2 <= len W by FINSEQ_3:27;
        set rn = len W-n+1, rn_1 = len W-(n+1)+1, rn_2 = len W-(n+2)+1;
        reconsider rn, rn_2 as odd Nat by B4, FINSEQ_5:1;
        reconsider rn_1 as even Nat by B4, FINSEQ_5:1;
        1 <= n by HEYTING3:1; then
        1+0 < n+2 by REAL_1:67; then
        len W - (n+2) < len W - 1 by REAL_1:92; then
        len W - (n+2) + 1 < len W - 1 + 1 by REAL_1:67; then
    B7: W.(rn_2+1) Joins W.rn_2, W.(rn_2+2), G by dWALK;
    C1: W'.n = W.rn by B2,FINSEQ_5:61
            .= W.(rn_2+2);
    C2:  W'.(n+1) = W.(rn_1) by B2, FINSEQ_5:61
                 .= W.(rn_2+1);
        W'.(n+1) Joins W'.(n+2), W'.n, G by C1,C2,B2, B7, FINSEQ_5:61;
        hence W'.(n+1) Joins W'.n, W'.(n+2), G by GLIB_000:17;
    end; 
    hence Rev W is Walk of G by dWALK;    
  end;
end;

definition let G be _Graph, W1, W2 be Walk of G; 
  func W1.append(W2) -> Walk of G equals :dWAPPND: ::dWAPPND
     W1 ^' W2 if W1.last() = W2.first() otherwise W1;
  correctness proof
    set W = W1 ^' W2, lenW = len W;
    hereby assume
    B1: W1.last() = W2.first();
        len W2 <> 0; then
    B2: W2 <> {} by FINSEQ_1:25;
    B3: now assume len W is even; then reconsider lenW as even Nat;
            lenW + 1 = len W1 + len W2 by B2, GRAPH_2:13;
            hence contradiction;
        end;
        1 <= len W1 by HEYTING3:1; then
    B4: W.1 = W1.1 by GRAPH_2:14
           .= W1.first() by dWFIRST;
        now let n be odd Nat such that
        C1: n < len W; set v1 = W.n, v2 = W.(n+2), e = W.(n+1);
            now per cases;
            suppose
            D1: n+2 <= len W1;
            D2: 1 <= n by HEYTING3:1;
            D3: 1 <= n+1 & 1 <= n+2 by NAT_1:37; 
                n < n+2 by NAT_1:41; then
            D4: n < len W1 by D1, AXIOMS:22;
                n+2-2 <= len W1-0 & n+2-1 <= len W1-0 by D1, REAL_1:92; then
                W.n = W1.n & W.(n+1) = W1.(n+1) & W.(n+2) = W1.(n+2)
                  by D1,D2,D3,GRAPH_2:14;                
                hence W.(n+1) Joins W.n,W.(n+2),G by D4, dWALK; end;
            suppose
            D1: len W1 < n+2; then consider k being Nat such that
            D2: n + 2 = len W1 + k by NAT_1:28;
                now assume k is odd; then reconsider k as odd Nat;
                    n+2 = len W1 + k by D2;
                    hence contradiction;
                end; then reconsider k as even Nat;
                k <> 0 by D1, D2; then
                0 < k by NAT_1:18; then
                0 + 1 < k + 1 by REAL_1:67; then
            D3: 1 <= k by NAT_1:38;
                n + 1 < len W + 1 by C1, REAL_1:67; then
                n + 1 < len W1 + len W2 by B2, GRAPH_2:13; then
                n + 1 + 1 < len W1 + len W2 + 1 by REAL_1:67; then
                n + (1+1) < len W1 + len W2 + 1; then
            D4: k + len W1 < len W1 + (len W2 + 1) by D2; then
                k <= len W2 + 1 by REAL_1:53; then
            D5: k < len W2 + 1 by D4, REAL_1:def 5; then
            D6: k <= len W2 by NAT_1:38; then
            D7: k < len W2 by REAL_1:def 5; then
            D8: W.(n + 2) = W2.(k+1) by D2, D3, GRAPH_2:15;
                len W1 + 1 <= n+2 by D1, NAT_1:38; then
                len W1 + 1 < n+1+1 by REAL_1:def 5; then
                len W1 <= n + 1 by REAL_1:53; then
                len W1 < n + 1 by REAL_1:def 5; then
            D9: len W1 <= n by NAT_1:38;
                now per cases;
                suppose
                E1: n = len W1; then
                    1 <= n & n <= len W1 by HEYTING3:1; then
                    W.n = W1.(len W1) by E1, GRAPH_2:14; then
                E2: W.n = W2.first() by B1, dWLAST
                       .= W2.1 by dWFIRST;
                E3: k = 2 by D2, E1, XCMPLX_1:2;
                E4: 1+1+0< len W2 + 1 by D2, D5, E1, XCMPLX_1:2; then
                    1 <= len W2 by REAL_1:53; then
                E5: 1 < len W2 by E4, REAL_1:def 5; then
                    W.(n + 1) = W2.(1+1) by E1, GRAPH_2:15;
                    hence W.(n+1) Joins W.n, W.(n+2), G
                      by E2, E3, D8, E5, dWALK, JORDAN12:3; end;
                suppose len W1 <> n; then
                    len W1 < n by D9, REAL_1:def 5; then
                E1: 2+len W1-len W1<k+len W1-len W1
                      by D2,REAL_1:67;
                    reconsider two=2*1 as even Nat;
                    reconsider k_2 = k-two as even Nat by E1, INT_1:18;
                    n + 2 = len W1 + k_2 + 2 by D2; then
                E3: n = len W1 + k_2 by XCMPLX_1:2;
                    1+1-1 < k_2 + 1 + 1 - 1 by E1, REAL_1:92; then
                E5: 1 <= k_2 by NAT_1:38;
                    k_2 < k_2 + (1+1) by NAT_1:41; then
                    k_2 < len W2 by D6, AXIOMS:22; then
                E7: W.n = W2.(k_2+1) by E3, E5, GRAPH_2:15;
                    set k_1 = k_2+1; reconsider k_1 as odd Nat;
                    k_1+2 = k + 1; then
                E9: W2.(k_1+2) = W.(n+2) by D2, D3, D7, GRAPH_2:15;
                    k_1 < k_1 + 1 by NAT_1:59; then
                EA: k_1 < len W2 by D6, AXIOMS:22;
                EB: 1 <= k_2+1 by NAT_1:37;
                    k_1+1-1 < len W2-0 by D6, REAL_1:92; then
                    W2.(k_1+1) = W.(len W1 + k_1) by EB, GRAPH_2:15
                              .= W.(n+1) by E3;
                    hence e Joins v1,v2,G by EA, E7, E9, dWALK; end;
                end;
                hence e Joins v1,v2,G; end;
            end; 
            hence e Joins v1,v2,G;
        end; 
        hence W1 ^' W2 is Walk of G by B3, B4, dWALK;
    end;
    thus thesis;
  end;
end;

definition let G be _Graph, W be Walk of G, m, n being Nat;
  func W.cut(m,n) -> Walk of G equals :dWCUT: ::dWCUT
     (m,n)-cut W if m is odd & n is odd & m <= n & n <= len W otherwise W;
  correctness proof 
    hereby assume
    B1: m is odd & n is odd & m <= n & n <= len W;      
        reconsider _m = m, _n = n as odd Nat by B1;
        set W2 = (m,n)-cut W, VG = the_Vertices_of G, EG = the_Edges_of G;
    B2: 1 <= m & m <= n+1 & n <= len W by B1, NAT_1:37, HEYTING3:1; then
        len W2 + _m - _m = _n + 1 - _m by GRAPH_2:def 1; then
        reconsider lenW2 = len W2 as odd Nat by XCMPLX_1:26;
        now lenW2 is odd;
            hence len W2 is odd;
            1 <= lenW2 by HEYTING3:1; then
            reconsider lenW2_1 = lenW2-1 as Nat by INT_1:18;
            0 < lenW2_1 + 1 by HEYTING3:1; then
        C2: W2.(0+1) = W.(m+0) by B2, GRAPH_2:def 1;
            1 <= m & m <= len W by B1, AXIOMS:22, HEYTING3:1; then
            W.m = W.vertexAt(m) by B1, dWVAT;
            hence W2.1 in VG by C2;
            let i be odd Nat; assume
        C3: i < len W2; then
            i + m < len W2 + m by REAL_1:67; then
            i + m < n + 1 by B2, GRAPH_2:def 1; then
            i + _m <= _n by NAT_1:38; then
            _m + i < _n by REAL_1:def 5; then
        C4: m + i < len W by B1, AXIOMS:22;        
            1 <= i by HEYTING3:1; then
            reconsider i_1 = i-1 as even Nat by INT_1:18;
            i_1 < len W2-0 by C3, REAL_1:92; then
        C6: W2.(i_1+1) = W.(m+i_1) by B2, GRAPH_2:def 1;
            i+1 <= lenW2 by C3, NAT_1:38; then
            i+1 < len W2 by REAL_1:def 5; then
        C8: W2.(i+1+1) = W.(m+(i+1)) by B2, GRAPH_2:def 1;
            1 <= m+i by B2, NAT_1:37; then
            reconsider x=_m+i-1 as odd Nat by INT_1:18;
            m + i - 1 < len W - 0 by C4, REAL_1:92; then
            W.(x+1) Joins W.x, W.(x+2), G by dWALK;
            hence W2.(i+1) Joins W2.i, W2.(i+2), G
              by C6,B2,C3,GRAPH_2:def 1,C8;
        end;
        hence (m,n)-cut W is Walk of G by dWALK;
    end;
    thus thesis;
  end;
end;

definition let G be _Graph, W be Walk of G, m, n be Nat;
  func W.remove(m,n) -> Walk of G equals :dWREMOVE: ::dWREMOVE
     W.cut(1,m).append(W.cut(n,len W)) if m is odd & n is odd &
     m <= n & n <= len W & W.m = W.n otherwise W;
  correctness;
end;

definition let G be _Graph, W be Walk of G, e be set;
  func W.addEdge(e) -> Walk of G equals :dWADDEDGE: ::dWADDEDGE
    W.append(G.walkOf(W.last(), e, W.last().adj(e)));
  coherence;
end;    

definition let G be _Graph, W be Walk of G;
  func W.vertexSeq() -> VertexSeq of G means :dWVSEQ: ::dWVSEQ
    len W + 1 = 2 * len it &
    for n being Nat st 1 <= n & n <= len it holds it.n = W.(2*n - 1);
  existence proof 
    reconsider lenW1 = len W + 1 as even Nat;
    set lenIT = lenW1 div 2;
A1: 2 divides lenW1 by PEPIN:22; then
A2: 2*lenIT = lenW1 by NAT_1:49;
    deffunc F(Nat) = W.(2*$1-1);
    consider IT being FinSequence such that
A3: len IT = lenIT &
      for k being Nat st k in Seg lenIT holds IT.k = F(k)
      from FINSEQ_1:sch 2;
    now let y be set; assume y in rng IT; then
        consider x being set such that
    B1: x in dom IT & y = IT.x by FUNCT_1:def 5;
    B2: x in Seg lenIT by A3, B1, FINSEQ_1:def 3;
        reconsider x as Nat by B1;
        set 2x = x*2; reconsider 2x as even Nat by ABIAN:def 1;
        set 2x_1 = 2x-1;
        1 <= x & x <= lenIT by B2, FINSEQ_1:3; then
    B3: 1*2 <= 2x & 2x <= lenIT * 2 by AXIOMS:25; then
        1 <= 2x by AXIOMS:22; then reconsider 2x_1 as odd Nat by INT_1:18;
        2 - 1 <= 2x_1 & 2x_1 <= lenW1-1 by A2, B3, REAL_1:49; then
        W.2x_1 = W.vertexAt(2x_1) by dWVAT; then
        W.2x_1 in the_Vertices_of G;
        hence y in the_Vertices_of G by A3, B1, B2;
    end; then
    rng IT c= the_Vertices_of G by TARSKI:def 3; then
    reconsider IT as FinSequence of the_Vertices_of G by FINSEQ_1:def 4;
    now let n be Nat; set v1 = IT.n, v2 = IT.(n+1); assume
    B1: 1 <= n & n < len IT; then
    B2: n in Seg lenIT by A3, FINSEQ_1:3; 
        set 2n = 2*n; reconsider 2n as even Nat; set 2n_1 = 2n-1;
        1 <= 2 & 1*2 <= n*2 by B1, AXIOMS:25; then
        1 <= 2n by AXIOMS:22; then reconsider 2n_1 as odd Nat by INT_1:18;
        1 <= n+1 & n+1 <= lenIT by A3, B1, NAT_1:38; then
        n+1 in Seg lenIT by FINSEQ_1:3; then
    B3: v2 = W.(2*(n+1)-1) by A3
          .= W.(2n+1);
        2n <= lenW1 & 2n <> lenW1 by A2, A3, B1, REAL_1:70; then
    B5: 2n - 1 <= len W + 1 - 1 by REAL_1:49;
        2n_1 <> len W by A2,A3,B1,REAL_1:70; then
        2n_1 < len W by B5, REAL_1:def 5; then
        W.(2n_1+1) Joins W.2n_1, W.(2n_1+2), G by dWALK; then
    B6: W.(2n_1+1) Joins IT.n, W.(2n_1+2), G by A3, B2;
        thus ex e being set st e Joins IT.n, IT.(n+1), G by B3, B6;
    end; then reconsider IT as VertexSeq of G by dVSEQ;
    take IT;
    thus len W + 1 = 2 * len IT by A1, A3, NAT_1:49;
    let n be Nat; assume
    1 <= n & n <= len IT; then
    n in Seg len IT by FINSEQ_1:3;
    hence IT.n = W.(2*n-1) by A3;
end;
  uniqueness proof 
    let IT1, IT2 be VertexSeq of G such that
A1: len W + 1 = 2 * len IT1 &
      for n being Nat st 1 <= n & n <= len IT1 holds IT1.n = W.(2*n - 1) and
A2: len W + 1 = 2 * len IT2 &
      for n being Nat st 1 <= n & n <= len IT2 holds IT2.n = W.(2*n - 1);
A3: len IT1 = len IT2 by A1, A2, XCMPLX_1:5;
A4: dom IT1 = Seg len IT2 by A3, FINSEQ_1:def 3
           .= dom IT2 by FINSEQ_1:def 3;
    now let n be Nat such that
    B1:  n in dom IT1;
    B2:  1 <= n & n <= len IT1 by B1, FINSEQ_3:27; then
         IT1.n = W.(2*n - 1) by A1;
         hence IT1.n = IT2.n by A2, A3, B2;
    end;
    hence IT1 = IT2 by A4, FINSEQ_1:17; 
end;
end;

definition let G be _Graph, W be Walk of G;
  func W.edgeSeq() -> EdgeSeq of G means :dWESEQ: ::dWESEQ
    len W = 2*len it+1 &
    for n being Nat st 1 <= n & n <= len it holds it.n = W.(2*n);
  existence proof 
    1 <= len W by HEYTING3:1; then
    reconsider lenW_1 = len W-1 as even Nat by INT_1:18;
    set lenIT = lenW_1 div 2; reconsider lenIT as Nat;
    2 divides lenW_1 by PEPIN:22; then
A1: lenW_1 = 2 * lenIT by NAT_1:49; then
A2: len W = 2 * lenIT + 1;
    deffunc F(Nat) = W.(2*$1);
    consider IT being FinSequence such that
A3: len IT = lenIT &
    for n being Nat st n in Seg lenIT holds IT.n = F(n) from FINSEQ_1:sch 2;
    now let y be set; assume y in rng IT; then consider x being set such that
    B1: x in dom IT & y = IT.x by FUNCT_1:def 5;
    B2: x in Seg lenIT by A3, B1, FINSEQ_1:def 3; reconsider x as Nat by B1;
    B3: y = W.(2*x) by A3, B1, B2; reconsider 2x = 2*x as even Nat;
        1 <= x & x <= lenIT by B2, FINSEQ_1:3; then
    B4: 1*2 <= 2*x & x*2 <= lenIT*2 by AXIOMS:25; then
    B5: 1 <= 2x by AXIOMS:22;
        2 divides lenW_1 by PEPIN:22; then
        2x <= lenW_1 by B4, NAT_1:49; then
        2x + 1 <= lenW_1 + 1 by REAL_1:55; then
        2x <= 2x+1 & 2x+1 <= len W by NAT_1:29; then
    B6: 2x <= len W by AXIOMS:22;
        reconsider 2x_1 = 2x-1 as odd Nat by B5, INT_1:18;
        2x_1 < len W by B6, SPPOL_1:5; then
        W.(2x_1+1) Joins W.2x_1, W.(2x_1+2), G by dWALK;
        hence y in the_Edges_of G by B3, GLIB_000:def 15;
    end; then
    rng IT c= the_Edges_of G by TARSKI:def 3; then
    reconsider IT as FinSequence of the_Edges_of G by FINSEQ_1:def 4;
    now set vs = W.vertexSeq();
        take vs;
        (2 * len IT + 1) + 1 = 2 * len vs by A2, A3, dWVSEQ; then
        2 * len IT + (1 + 1) = 2 * len vs by XCMPLX_1:1; then
        2 * len IT + 2 * 1 = 2 * len vs; then
        2 * (len IT + 1) = 2 * len vs by XCMPLX_1:8;
        hence
    B1: len vs = len IT + 1 by XCMPLX_1:5;
        let n be Nat; set v1 = vs.n, v2 = vs.(n+1); assume
    B2: 1 <= n & n <= len IT; then
    B3: 1 <= n & n <= len vs by B1, NAT_1:37; 
    B4: 1 <= n+1 & n+1 <= len vs by B1, B2, NAT_1:37, REAL_1:55;
        set 2n = 2*n; reconsider 2n as even Nat;
        set 2n_1 = 2n-1;
        1 <= n+n by B2, NAT_1:37; then
        reconsider 2n_1 as odd Nat by INT_1:18;
    B5: v1 = W.(2*n-1) & v2 = W.(2*(n+1)-1) by B3, B4, dWVSEQ;
        n in Seg lenIT by B2, A3, FINSEQ_1:3; then
    B6: IT.n = W.(2n_1+1) by A3;
    B7: v2 = W.(2n_1+2) by B5;
        n*2 <= len IT*2 by B2, AXIOMS:25; then
        n*2 <= len W by A2, A3, NAT_1:37; then
        2n_1 < len W - 0 by REAL_1:92;
        hence IT.n Joins vs.n, vs.(n+1), G by B5, B6, B7, dWALK;
    end; then reconsider IT as EdgeSeq of G by dESEQ;
    take IT;
    thus len W = 2*len IT+1 by A1, A3, XCMPLX_1:27;
    let n be Nat; assume 1 <= n & n <= len IT;  then
    n in Seg lenIT by A3, FINSEQ_1:3;
    hence IT.n = W.(2*n) by A3;
end;
  uniqueness proof
    let IT1, IT2 be EdgeSeq of G such that
A1: len W = 2*len IT1 + 1 &
    for n being Nat st 1 <= n & n <= len IT1 holds IT1.n = W.(2*n) and
A2: len W = 2*len IT2 + 1 &
      for n being Nat st 1 <= n & n <= len IT2 holds IT2.n = W.(2*n);
    2*len IT1 = 2*len IT2 by A1, A2, XCMPLX_1:2; then
A3: len IT1 = len IT2 by XCMPLX_1:5;
A4: dom IT1 = Seg len IT2 by A3, FINSEQ_1:def 3
           .= dom IT2 by FINSEQ_1:def 3;
    now let n be Nat; assume n in dom IT1; then
    B1: 1 <= n & n <= len IT1 & n <= len IT2 by A3, FINSEQ_3:27;
        hence IT1.n = W.(2*n) by A1
                   .= IT2.n by B1, A2;
    end;
    hence IT1 = IT2 by A4, FINSEQ_1:17;
end;
end;

definition let G be _Graph, W be Walk of G; 
  func W.vertices() -> finite Subset of the_Vertices_of G equals :dWVERTICES: ::dWVERTICES
    rng W.vertexSeq();
  coherence;
end;

definition let G be _Graph, W be Walk of G;
  func W.edges() -> finite Subset of the_Edges_of G equals :dWEDGES: ::dWEDGES
    rng W.edgeSeq();
  coherence;
end;

definition let G be _Graph, W be Walk of G;
  func W.length() -> Nat equals : dWLENGTH: ::dWLENGTH
    len W.edgeSeq();
  coherence;
end;

definition let G be _Graph, W be Walk of G, v be set;
  func W.find(v) -> odd Nat means :dWFINDV: ::dWFINDV
    it <= len W & W.it = v &
    for n being odd Nat st n <= len W & W.n = v holds it <= n if
    v in W.vertices() otherwise it = len W;
  existence proof
    hereby assume
A1: v in W.vertices();    
  set vs = W.vertexSeq();
    defpred P[Nat] means $1 is odd & $1 <= len W & W.$1 = v;
    now v in rng vs by A1, dWVERTICES; then consider i being Nat such that
    B1: i in dom vs & vs.i = v by FINSEQ_2:11;
        set n1 = 2*i; reconsider n1 as even Nat; set n = n1-1;
    B2: 1 <= i & i <= len vs by B1, FINSEQ_3:27; then
        1 <= i+i by NAT_1:37; then reconsider n as odd Nat by INT_1:18;
        take n;
        i*2 <= len vs *2 by B2, AXIOMS:25; then
        i*2 <= len W + 1 by dWVSEQ; then
        n1 - 1 <= len W + 1 - 1 by REAL_1:92;
        hence n <= len W; 
        thus W.n = v by B1, B2, dWVSEQ;
    end; then
A2: ex k being Nat st P[k];
    consider IT being Nat such that
A3: P[IT] & for n being Nat st P[n] holds IT <= n from NAT_1:sch 5(A2);
    reconsider IT as odd Nat by A3;
    take IT;
    thus IT <= len W & W.IT = v by A3;
    let n be odd Nat; assume
    n <= len W & W.n = v;
    hence IT <= n by A3;
    end;
    assume not v in W.vertices();
    set IT = len W;
    take IT;
    thus thesis;
end;
  uniqueness proof
    let IT1, IT2 be odd Nat;
    hereby assume v in W.vertices();
        assume
    A1: IT1 <= len W & W.IT1 = v &
        for n being odd Nat st n <= len W & W.n = v holds IT1 <= n;
        assume
    A2: IT2 <= len W & W.IT2 = v &
        for n being odd Nat st n <= len W & W.n = v holds IT2 <= n;
    A3: IT1 <= IT2 by A1, A2;
        IT2 <= IT1 by A1, A2; 
        hence IT1 = IT2 by A3, AXIOMS:21;
    end;
    assume not v in W.vertices();
    thus thesis;
  end;
  consistency;
end;

definition let G be _Graph, W be Walk of G, n be Nat;
  func W.find(n) -> odd Nat means :dWFINDN: ::dWFINDN
    it <= len W & W.it = W.n &
      for k being odd Nat st k <= len W & W.k = W.n holds it <= k
    if (n is odd & n <= len W) otherwise it = len W;
  existence proof
    defpred P[Nat] means $1 is odd & $1 <= len W & W.$1 = W.n;
    hereby assume (n is odd & n <= len W); then
    B1: ex n being Nat st P[n];
        consider IT being Nat such that
    B2: P[IT] & for k being Nat st P[k] holds IT <= k from NAT_1:sch 5(B1);
        reconsider IT as odd Nat by B2;
        take IT;
        thus IT <= len W & W.IT = W.n by B2;
        thus for k being odd Nat st k <= len W & W.k = W.n holds IT <= k by B2;
    end;
    thus thesis;
  end;
  uniqueness proof
    let IT1, IT2 be odd Nat;
    hereby assume n is odd & n <= len W; assume
    B1: IT1 <= len W & W.IT1 = W.n &
         for k being odd Nat st k <= len W & W.k = W.n holds IT1 <= k;
        assume IT2 <= len W & W.IT2 = W.n &
          for k being odd Nat st k <= len W & W.k = W.n holds IT2 <= k; then
        IT1 <= IT2 & IT2 <= IT1 by B1;
        hence IT1 = IT2 by AXIOMS:21;
    end;
    thus thesis;
  end;
  consistency;
end;  

definition let G be _Graph, W be Walk of G, v be set;
  func W.rfind(v) -> odd Nat means :dWRFINDV: ::dWRFINDV
    it <= len W & W.it = v &
    for n being odd Nat st n <= len W & W.n = v holds n <= it
    if v in W.vertices() otherwise it = len W;
  existence proof
    hereby assume
    A1: v in W.vertices();
        defpred P[Nat] means $1 is odd & $1 <= len W & W.$1 = v;
    A2: for k being Nat st P[k] holds k <= len W;
        W.find(v) <= len W & W.(W.find(v)) = v by A1, dWFINDV; then
    A3: ex k being Nat st P[k];
        consider IT being Nat such that
    A4: P[IT] & for n being Nat st P[n] holds n <= IT from NAT_1:sch 6(A2,A3);
        reconsider IT as odd Nat by A4;
        take IT;
        thus IT <= len W & W.IT = v by A4;
        let n be odd Nat; assume
        n <= len W & W.n = v;
        hence n <= IT by A4;
    end;
    thus thesis;
  end;
  uniqueness proof
    let IT1, IT2 be odd Nat;
    hereby assume v in W.vertices(); assume
    A1: IT1 <= len W & W.IT1 = v &
          for n being odd Nat st n <= len W & W.n = v holds n <= IT1; assume
    A2: IT2 <= len W & W.IT2 = v &
          for n being odd Nat st n <= len W & W.n = v holds n <= IT2;
    A3: IT2 <= IT1 by A1, A2;
          IT1 <= IT2 by A1, A2;
        hence IT1 = IT2 by A3, AXIOMS:21;
    end;
    thus thesis;
  end;
  consistency;
end;

definition let G be _Graph, W be Walk of G, n be Nat;
  func W.rfind(n) -> odd Nat means :dWRFINDN: ::dWRFINDN
    it <= len W & W.it = W.n &
    for k being odd Nat st k <= len W & W.k = W.n holds k <= it
    if (n is odd & n <= len W) otherwise it = len W;
  existence proof
    defpred P[Nat] means $1 is odd & $1 <= len W & W.$1 = W.n;
    hereby assume (n is odd & n <= len W); then
    B1: ex k being Nat st P[k];
    B2: for k being Nat st P[k] holds k <= len W;
        consider IT being Nat such that
    B3: P[IT] & for k being Nat st P[k] holds k <= IT from NAT_1:sch 6(B2,B1);
        reconsider IT as odd Nat by B3;
        take IT;
        thus IT <= len W & W.IT = W.n by B3;
        thus for k being odd Nat st k <= len W & W.k = W.n
           holds k <= IT by B3;
    end;
    thus thesis;
  end;
  uniqueness proof
    let IT1, IT2 be odd Nat;
    hereby assume n is odd & n <= len W; assume
    B1: IT1 <= len W & W.IT1 = W.n &
         for k being odd Nat st k <= len W & W.k = W.n holds k <= IT1;
        assume IT2 <= len W & W.IT2 = W.n &
          for k being odd Nat st k <= len W & W.k = W.n holds k <= IT2; then
        IT1 <= IT2 & IT2 <= IT1 by B1;
        hence IT1 = IT2 by AXIOMS:21;
    end;
    thus thesis;
  end;
  consistency;
end;  

definition let G be _Graph, u, v be set, W be Walk of G;
  pred W is_Walk_from u,v  means :dWALKFROM: ::dWALKFROM
    W.first() = u & W.last() = v;
end;

definition let G be _Graph, W be Walk of G; 
  attr W is closed means :dCLWALK: ::dCLWALK
    W.first() = W.last();
  attr W is directed means :dDIWALK: ::dDIWALK
    for n being odd Nat st n < len W
      holds (the_Source_of G).(W.(n+1)) = W.n;
  attr W is trivial means :dTVWALK: ::dTVWALK
    W.length() = 0;
  attr W is Trail-like means :dTLWALK: ::dTLWALK
    W.edgeSeq() is one-to-one;
end;

notation let G be _Graph, W be Walk of G;
  antonym W is open for W is closed;
end;

definition let G be _Graph, W be Walk of G;
  attr W is Path-like means :dPLWALK: ::dPLWALK
    W is Trail-like & 
    for m, n being odd Nat st m < n & n <= len W holds
      W.m = W.n implies (m = 1 & n = len W);
end;

definition let G be _Graph, W be Walk of G;
  attr W is vertex-distinct means :dVDWALK: ::dVDWALK
    for m,n being odd Nat st m <= len W & n <= len W & W.m = W.n
      holds m = n;
end;

definition let G be _Graph, W be Walk of G;
  attr W is Circuit-like means :dCIWALK: ::dCIWALK
     W is closed & W is Trail-like & W is non trivial;

  attr W is Cycle-like means :dCYWALK: ::dCYWALK
    W is closed & W is Path-like & W is non trivial;
end;

lWALK02:
  for G be _Graph, W be Walk of G, n being odd Nat st n <= len W holds
    W.n in the_Vertices_of G proof
    let G be _Graph, W be Walk of G, n be odd Nat; assume n <= len W; then
    W.n = W.vertexAt(n) by dWVAT;
    hence thesis;
end;

lWALK04:
  for G be _Graph, W be Walk of G, n being even Nat st n in dom W holds
    ex n_1 being odd Nat st
      n_1 = n-1 & n-1 in dom W & n+1 in dom W &
      W.n Joins W.(n_1), W.(n+1),G proof
    let G be _Graph, W be Walk of G, n be even Nat; assume n in dom W; then
A1: 1 <= n & n <= len W by FINSEQ_3:27; then
    reconsider n_1 = n-1 as odd Nat by INT_1:18;
    take n_1;
    thus n_1 = n-1;
    1 < n by A1,JORDAN12:3,REAL_1:def 5; then
    1+1 <= n by NAT_1:38; then
    1+1-1 <= n-1 by REAL_1:92; then
A2: 1 <= n_1;
    n - 1 <= len W - 0 by A1, REAL_1:92;
    hence n - 1 in dom W by A2, FINSEQ_3:27;
    n < len W by A1, REAL_1:def 5; then
A4: n+1 <= len W by NAT_1:38;
    1 <= 1+n by NAT_1:37; 
    hence n+1 in dom W by A4, FINSEQ_3:27;
    n - 1 < len W - 0 by A1, REAL_1:92; then
    W.(n_1+1) Joins W.n_1, W.(n_1+2),G by dWALK; 
    hence thesis;
end;    

lWALK07:
  for G be _Graph, W be Walk of G, n being odd Nat st n < len W holds
     n in dom W & n+1 in dom W & n+2 in dom W proof
    let G be _Graph, W be Walk of G, n be odd Nat; assume
A1: n < len W;
A2: 1 <= n by HEYTING3:1; 
A3: 1 <= n+1 & 1 <= n+2 by NAT_1:37;
    n+1 <= len W & n+2 <= len W by A1,NAT_1:38,tODD01;
    hence thesis by A1,A2,A3,FINSEQ_3:27;
end;     

lWALKOFV:
  for G being _Graph, v being Vertex of G holds
    G.walkOf(v) is closed & G.walkOf(v) is directed & G.walkOf(v) is trivial &
    G.walkOf(v) is Trail-like & G.walkOf(v) is Path-like proof
    let G be _Graph, v be Vertex of G; set W = G.walkOf(v);    
A1: W = <*v*> by dWALKOFV;
    W.first() = W.1 by dWFIRST
             .= W.(len W) by A1,FINSEQ_1:57
             .= W.last() by dWLAST;
    hence W is closed by dCLWALK;
    now let n be odd Nat; assume n < len W; then
        n < 1 by A1,FINSEQ_1:56;
        hence W.n = (the_Source_of G).(W.(n+1)) by HEYTING3:1;
    end;
    hence W is directed by dDIWALK;
    len W = 1 by A1,FINSEQ_1:56; then
    0 + 1 = 2*len W.edgeSeq() + 1 by dWESEQ; then
    0 = 2*len W.edgeSeq() by XCMPLX_1:2; then
    0 = len W.edgeSeq() by XCMPLX_1:6; then
    W.length() = 0 by dWLENGTH; 
    hence W is trivial by dTVWALK;    
    len W = 2*(len (W.edgeSeq()))+1 by dWESEQ; then
    0 + 1 = 2 * (len (W.edgeSeq())) + 1 by A1,FINSEQ_1:57; then
    0 = 2 * len (W.edgeSeq()) by XCMPLX_1:2;  then
    len (W.edgeSeq()) = 0 by XCMPLX_1:6; then
    W.edgeSeq() is one-to-one by FINSEQ_1:25;
    hence
A2: W is Trail-like by dTLWALK;
    now let n, m be odd Nat; assume n < m & m <= len W; then
        n < m & m <= 1 by A1,FINSEQ_1:57; then
        n < 1 by AXIOMS:22;
        hence W.n = W.m implies (n = 1 & m = len W) by HEYTING3:1;
    end;
    hence W is Path-like by A2, dPLWALK;
end;

lWALKOFE01:
  for G be _Graph, x,e,y be set holds
    e Joins x,y,G implies len G.walkOf(x,e,y) = 3 proof
    let G be _Graph, x,e,y be set; assume e Joins x,y,G; then
    G.walkOf(x,e,y) = <*x,e,y*> by dWALKOFE;
    hence thesis by FINSEQ_1:62;
end;    

lWALKOFE02:
  for G being _Graph, x,e,y being set holds e Joins x,y,G implies
    G.walkOf(x,e,y).first() = x & G.walkOf(x,e,y).last() = y &
    G.walkOf(x,e,y) is_Walk_from x,y proof
    let G be _Graph, x,e,y be set; set W = G.walkOf(x,e,y);
    assume e Joins x,y,G; then
    W = <*x,e,y*> by dWALKOFE; then
A1: len W = 3 & W.1 = x & W.2 = e & W.3 = y by FINSEQ_1:62;
    hence
A2: W.first() = x by dWFIRST;
    thus W.last() = y by A1, dWLAST;
    hence W is_Walk_from x, y by A2, dWALKFROM;
end;

lWREV01:
 for G being _Graph, W being Walk of G holds
  len W = len W.reverse() & dom W = dom W.reverse() &
    rng W = rng W.reverse() proof
    let G be _Graph, W be Walk of G;    
    W.reverse() = Rev W by dWREV;    
    hence thesis by FINSEQ_5:def 3, FINSEQ_5:60;
end;    

lWREV02:
  for G be _Graph, W be Walk of G holds
    W.first() = W.reverse().last() & W.last() = W.reverse().first() proof
    let G be _Graph, W be Walk of G;    
A1: len W = len W.reverse() by lWREV01;
A2: W.reverse() = Rev W by dWREV;
    thus W.first() = W.1 by dWFIRST
                  .= W.reverse().(len W) by A2,FINSEQ_5:65
                  .= W.reverse().last() by A1, dWLAST;
    thus W.last() = W.(len W) by dWLAST
                .= W.reverse().1 by A2,FINSEQ_5:65
                .= W.reverse().first() by dWFIRST;
end;  

lWREV05:
  for G being _Graph, W being Walk of G, n being Nat holds    
  n in dom W.reverse() implies W.reverse().n = W.(len W - n + 1) &
    (len W - n + 1) in dom W proof
    let G be _Graph, W be Walk of G, n be Nat;    
A0: W.reverse() = Rev W by dWREV; assume
A1: n in dom W.reverse(); 
    hence W.reverse().n = W.(len W - n + 1) by A0,FINSEQ_5:def 3;
    n in Seg len W.reverse() by A1, FINSEQ_1:def 3; then
    n in Seg len W by lWREV01; then
    len W - n + 1 in Seg len W by FINSEQ_5:2;
    hence len W - n + 1 in dom W by FINSEQ_1:def 3;
end;    

lWREV06:
  for G being _Graph, W being Walk of G holds
    W.reverse().reverse() = W proof
    let G be _Graph, W be Walk of G;     
    W.reverse() = Rev W by dWREV; then
    W.reverse().reverse() = Rev (Rev W) by dWREV;
    hence thesis by FINSEQ_6:29;
end;

lWAPPND01:
  for G being _Graph, W1,W2 being Walk of G holds
    W1.last() = W2.first() implies
    len W1.append(W2) + 1 = len W1 + len W2 proof
    let G be _Graph, W1,W2 be Walk of G; set W = W1.append(W2);
    assume W1.last() = W2.first(); then
A1: W = W1 ^' W2 by dWAPPND;
    len W2 <> 0; then
    W2 <> {} by FINSEQ_1:25;
    hence thesis by A1, GRAPH_2:13;
end;

lWAPPND02:
  for G be _Graph, W1,W2 be Walk of G holds W1.last() = W2.first() implies
    len W1 <= len W1.append(W2) & len W2 <= len W1.append(W2) proof
    let G be _Graph, W1,W2 be Walk of G; set W = W1.append(W2);
    assume W1.last() = W2.first(); then
A1: len W + 1 = len W1 + len W2 by lWAPPND01;
A2: 1 <= len W1 & 1 <= len W2 by HEYTING3:1; then
    len W1 + len W2 - len W2 <= len W + 1 - 1 by A1, REAL_1:92;
    hence len W1 <= len W;
    len W2 + len W1 - len W1 <= len W + 1 - 1 by A1, A2, REAL_1:92;
    hence len W2 <= len W;
end;    

lWAPPND03:
  for G being _Graph, W1,W2 being Walk of G holds
  W1.last() = W2.first() implies
    W1.append(W2).first() = W1.first() & W1.append(W2).last() = W2.last() &
    W1.append(W2) is_Walk_from W1.first(), W2.last() proof
    let G be _Graph, W1, W2 be Walk of G; assume
A1: W1.last() = W2.first(); set W = W1.append(W2);
A2: W = W1 ^' W2 by A1, dWAPPND;
    1 <= len W1 by HEYTING3:1; then
    W.1 = W1.1 by A2, GRAPH_2:14
       .= W1.first() by dWFIRST;
    hence
A3: W.first() = W1.first() by dWFIRST;
    now per cases;
    suppose
    B1: len W2 <> 1;
        1 <= len W2 by HEYTING3:1; then
        1 < len W2 by B1, REAL_1:def 5; then
        W.(len W) = W2.(len W2) by A2, GRAPH_2:16
                 .= W2.last() by dWLAST;
        hence W.last() = W2.last() by dWLAST; end;
    suppose
    B1: len W2 = 1; then
    B2: W = W1^(2,1)-cut W2 by A2, GRAPH_2:def 2;
        len (2,1)-cut W2 + 2 = 1 + 1 by B1, GRAPH_2:def 1; then
        len (2,1)-cut W2 = 0 by XCMPLX_1:3; then
        (2,1)-cut W2 = {} by FINSEQ_1:25;
        hence W.last() = W2.first() by A1, B2, FINSEQ_1:47
                      .= W2.1 by dWFIRST
                      .= W2.last() by B1, dWLAST; end;
    end;
    hence thesis by A3, dWALKFROM;
end;

lWAPPND05:
  for G be _Graph, W1,W2 be Walk of G, n being Nat holds
  n in dom W1 implies
    W1.append(W2).n = W1.n & n in dom W1.append(W2) proof
    let G be _Graph, W1,W2 be Walk of G, n be Nat;
    set W = W1.append(W2); assume
A0: n in dom W1; then
A1: 1 <= n & n <= len W1 by FINSEQ_3:27;
    now per cases;
    suppose
    B1: W1.last() = W2.first(); then
        W = W1 ^' W2 by dWAPPND;
        hence W.n = W1.n by A1,GRAPH_2:14;
        1 <= len W2 by HEYTING3:1; then
        reconsider lenW2_1 = len W2 - 1 as Nat by INT_1:18;
        n <= len W1 + lenW2_1 by A1, NAT_1:37; then
        n <= len W1 + len W2 + -1; then
        n <= len W + 1 + -1 by B1, lWAPPND01;
        hence n in dom W by A1, FINSEQ_3:27; end;
    suppose W1.last() <> W2.first();
        hence W.n = W1.n & n in dom W by A0,dWAPPND; end;
    end;
    hence thesis;
end;    

lWAPPND06:
  for G be _Graph, W1,W2 be Walk of G holds W1.last() = W2.first() implies
  for n being Nat st n < len W2 holds
    W1.append(W2).(len W1 + n) = W2.(n+1) &
    (len W1 + n) in dom W1.append(W2) proof
    let G be _Graph, W1,W2 be Walk of G;    
    set W = W1.append(W2); assume
A1: W1.last() = W2.first(); then
A2: W = W1 ^' W2 by dWAPPND;
    let n be Nat; assume
A3: n < len W2;
    now per cases;
    suppose
    B1: n = 0; then 
        1 <= len W1 + n & len W1 + n <= len W1 by HEYTING3:1; then
        len W1 + n in dom W1 by FINSEQ_3:27;
        hence W1.append(W2).(len W1 + n) = W1.(len W1 + n) by lWAPPND05
                                        .= W2.first() by A1, B1, dWLAST
                                        .= W2.(n + 1) by B1, dWFIRST; end;
    suppose n <> 0; then
        0 < n by NAT_1:19; then
        0 + 1 < n + 1 by REAL_1:67; then
        1 <= n by NAT_1:38; 
        hence W1.append(W2).(len W1 + n) = W2.(n+1) by A2, A3, GRAPH_2:15; end;
    end;
    hence W1.append(W2).(len W1 + n) = W2.(n+1);
    1 <= len W1 by HEYTING3:1; then
A4: 1 <= len W1 + n by NAT_1:37;
    n + 1 <= len W2 by A3, NAT_1:38; then
    n + 1 + len W1 <= len W2 + len W1 by REAL_1:55; then
    len W1 + n + 1 <= len W + 1 by A1,lWAPPND01; then
    len W1 + n <= len W by REAL_1:53;
    hence thesis by A4, FINSEQ_3:27;
end;

lWAPPND07:
  for G be _Graph, W1,W2 be Walk of G, n be Nat holds
  n in dom W1.append(W2) implies
     n in dom W1 or ex k being Nat st k < len W2 & n = len W1 + k proof
    let G be _Graph, W1,W2 be Walk of G, n be Nat;
    set W3 = W1.append(W2); assume
A1: n in dom W3; then
A2: 1 <= n & n <= len W3 by FINSEQ_3:27;
    now per cases;
    suppose W1.last() = W2.first(); then
    B2: len W3 + 1 = len W1 + len W2 by lWAPPND01;
        now assume not n in dom W1; then
            len W1 < n by A2, FINSEQ_3:27; then
            reconsider k = n - len W1 as Nat by INT_1:18;
            take k;
            now assume len W2 <= k; then
                len W1 + len W2 <= len W1 + k by REAL_1:55;
                hence contradiction by A2,B2,NAT_1:38;
            end;
            hence k < len W2;
            thus n = len W1+k;
        end;
        hence thesis; end;
    suppose W1.last() <> W2.first();
        hence thesis by A1,dWAPPND; end;
    end;
    hence thesis;
end;     

lWCUT01:
  for G being _Graph, W being Walk of G, m,n being odd Nat
   st m <= n & n <= len W holds len W.cut(m,n) + m = n+1 &
    for i being Nat st i < len W.cut(m,n)
        holds W.cut(m,n).(i+1) = W.(m+i) & m+i in dom W proof
    let G be _Graph, W be Walk of G, m, n be odd Nat;
    set W2 = W.cut(m,n); assume
A1: m <= n & n <= len W; then
A2: W2 = (m,n)-cut W by dWCUT;
A3: 1 <= m & m <= n+1 & n <= len W by A1, NAT_1:37, HEYTING3:1;
    hence
A4: len W.cut(m,n) + m = n + 1 by A2, GRAPH_2:def 1;
    let i be Nat; assume
A5: i < len W.cut(m,n);    
    hence W.cut(m,n).(i+1) = W.(m+i) by A2, A3,GRAPH_2:def 1;
    1 <= m by HEYTING3:1; then
A6: 1 <= m+i by NAT_1:37;
    m+i < n + 1 by A4,A5,REAL_1:67; then
    m+i <= n by NAT_1:38; then
    m+i <= len W by A1, AXIOMS:22; 
    hence m+i in dom W by A6, FINSEQ_3:27;
end;

lWCUT02:
  for G being _Graph, W being Walk of G, m, n being odd Nat
    st m <= n & n <= len W holds
    W.cut(m,n).first() = W.m & W.cut(m,n).last() = W.n &
    W.cut(m,n) is_Walk_from W.m, W.n proof
    let G be _Graph, W be Walk of G, m, n be odd Nat;
    set W2 = W.cut(m,n); assume
A1: m <= n & n <= len W;
    1-1 < len W2 - 0 by HEYTING3:1; then
    W2.(0+1) = W.(m+0) by A1, lWCUT01;
    hence
A3: W2.first() = W.m by dWFIRST;
    reconsider n_m = n-m as Nat by A1, INT_1:18;
A4: len W2 + m - m = n + 1 - m by A1, lWCUT01; then
    len W2 = n - m + 1 by XCMPLX_1:26; then
    n - m + 1 -1 < len W2 - 0 by REAL_1:92; then
    n_m < len W2; then
    W2.((n-m)+1) = W.(m+(n-m)) by A1, lWCUT01; then
    W2.(len W2) = W.n by A4,XCMPLX_1:26;
    hence W2.last() = W.n by dWLAST;
    hence thesis by A3, dWALKFROM;
end;

lWCUT03:
  for G be _Graph, W be Walk of G, m,n,o being odd Nat
    st m <= n & n <= o & o <= len W holds
    W.cut(m,n).append(W.cut(n,o)) = W.cut(m,o) proof
    let G be _Graph, W be Walk of G, m,n,o be odd Nat; assume
A1: m <= n & n <= o & o <= len W; then
A2: m <= o & n <= len W by AXIOMS:22;
    set W1 = W.cut(m,n), W2 = W.cut(n,o), W3 = W.cut(m,o), W4 = W1.append(W2);
    now
    B1: W1.last() = W.n by A1,A2,lWCUT02
                 .= W2.first() by A1,lWCUT02;
    B2: len W1 + m = n + 1 by A1, A2, lWCUT01;
        len W2 + n = o + 1 by A1, lWCUT01; then
        len W1 + m + len W2 + n = o + 1 + 1 + n by B2,XCMPLX_1:1; then
    B3: len W1 + len W2 + m = 1 + (o + 1) by XCMPLX_1:2;
        len W3 + m = o + 1 by A1, A2, lWCUT01; then
        len W1 + len W2 + m = 1 + len W3 + m by B3, XCMPLX_1:1; then
    BZ: len W1 + len W2 = 1 + len W3 by XCMPLX_1:2; then
    BY: len W4 + 1 = len W3 + 1 by B1, lWAPPND01; then
    B4: len W4 = len W3 by XCMPLX_1:2;
        thus len W4 = len W4 & len W3 = len W4 by BY,XCMPLX_1:2;
        let x be Nat; assume x in Seg len W4; then
        x in dom W4 by FINSEQ_1:def 3; then
    B6: 1 <= x & x <= len W4 by FINSEQ_3:27; then
        reconsider x_1 = x-1 as Nat by INT_1:18;
        x_1 < len W4 - 0 by B6, REAL_1:92; then
    BX: W3.(x_1+1) = W.(m+x_1) by A1, A2, B4, lWCUT01;
        now per cases;
        suppose
        C1: x <= len W1; then
        C2: x_1 < len W1 - 0 by REAL_1:92; 
        C3: x in dom W1 by C1, B6, FINSEQ_3:27;
            thus W4.x = W1.(x_1+1) by C3,lWAPPND05
                     .= W3.x by A1,A2,C2,lWCUT01,BX; end;
        suppose x > len W1; then consider k being Nat such that
        C2: len W1 + k = x by NAT_1:28;
            len W1 + k + 1 <= len W3 + 1
              by BY,B6,C2,REAL_1:55; then
            (k + 1)+len W1-len W1 <= len W2 +len W1-len W1
              by BZ,REAL_1:92; then
        C4: k + 1 - 1 < len W2 + 1 - 1 by NAT_1:38; then
        C5: W4.x = W2.(k+1) by B1, C2, lWAPPND06
                .= W.(n+k) by A1,C4,lWCUT01;
            n + k = k + (len W1 + m) + -1 by B2
                 .= m + x_1 by C2;
            hence W4.x = W3.x by C5, BX; end;
        end;
        hence W4.x = W3.x;
    end;
    hence thesis by FINSEQ_2:10;
end;    

lWCUT04:
  for G be _Graph, W be Walk of G holds W.cut(1,len W) = W proof
    let G be _Graph, W be Walk of G;   
    1 is odd & 1 <= len W by JORDAN12:3, HEYTING3:1; then
    W.cut(1,len W) = (1,len W)-cut W by dWCUT;
    hence thesis by GRAPH_2:7;
end;  


lWCUT07:
  for G be _Graph, W be Walk of G, n being odd Nat st n <= len W holds
     W.cut(n,n) = <* W.vertexAt(n) *> proof
    let G be _Graph, W be Walk of G, n be odd Nat; assume
A1: n <= len W; then
A2: W.cut(n,n) = (n,n)-cut W by dWCUT;
A3: W.n = W.vertexAt(n) by A1, dWVAT;
    1 <= n by HEYTING3:1;
    hence W.cut(n,n) = <* W.vertexAt(n) *> by A1, A2, A3, GRAPH_2:6;
end;     

lWCUT08:
  for G being _Graph, W being Walk of G, m,n being Nat holds
    m is odd & m <= n implies W.cut(1,n).cut(1,m) = W.cut(1,m) proof
    let G be _Graph, W be Walk of G, m,n be Nat; set W1 = W.cut(1,n); assume
A1: m is odd & m <= n;    
    now per cases;
    suppose
    B1: n is odd & n <= len W; then
    B2: 1 <= n & 1 <= m & m <= len W by HEYTING3:1, A1, AXIOMS:22;
        len W1 + 1 = n + 1 by JORDAN12:3,lWCUT01,B1,B2; then
    B4: len W1 = n by XCMPLX_1:2; then
    B5: W1.cut(1,m) = (1,m)-cut W1 by A1,B2,JORDAN12:3,dWCUT;
        len W1.cut(1,m) + 1 = m + 1 by A1,B2,JORDAN12:3,B4,lWCUT01; then
    B6: len W1.cut(1,m) = m by XCMPLX_1:2;
        len W.cut(1,m) + 1 = m + 1 by A1,B2,JORDAN12:3,lWCUT01; then
    B7: len W.cut(1,m) = m by XCMPLX_1:2;
    B8: 1 <= m + 1 & 1 <= n + 1 by NAT_1:37;
    B9: W1 = (1,n)-cut W by B1,B2,JORDAN12:3,dWCUT;
    BA: W.cut(1,m) = (1,m)-cut W by A1, B2,JORDAN12:3, dWCUT;
    BB: len W.cut(1,m) + 1 = m + 1 by A1, B2,JORDAN12:3, lWCUT01;
        now let x be Nat; assume x in Seg m; then
        C1: 1 <= x & x <= m by FINSEQ_1:3; then
            reconsider x_1 = x-1 as Nat by INT_1:18;
            x <= n by A1, C1, AXIOMS:22; then
        C2: x_1 < len W1 - 0 by B4, REAL_1:92;
        C3: x_1 < len W1.cut(1,m) - 0 by C1, B6, REAL_1:92;
            x <= len W.cut(1,m) by C1, BB,XCMPLX_1:2; then
        C4: x_1 < len W.cut(1,m) - 0 by REAL_1:92;
            thus W1.cut(1,m).x = W1.(1+x_1) by A1,B4,B5,B8,C3,GRAPH_2:def 1
                               .= W.(1+x_1) by B1,B8,B9,C2,GRAPH_2:def 1
                               .= W.cut(1,m).x by B8,C4,B2,BA,GRAPH_2:def 1;
        end;
        hence W1.cut(1,m) = W.cut(1,m) by B6, B7, FINSEQ_2:10; end;
    suppose not (n is odd & n <= len W);
        hence thesis by dWCUT; end;
    end;
    hence thesis;
end;    

lWCUT09:
  for G be _Graph, W1,W2 be Walk of G, m,n being odd Nat
    st m <= n & n <= len W1 & W1.last() = W2.first()
    holds W1.append(W2).cut(m,n) = W1.cut(m,n) proof
    let G be _Graph, W1,W2 be Walk of G, m,n be odd Nat; assume
A1: m <= n & n <= len W1 & W1.last() = W2.first();
    set W3 = W1.append(W2);
    len W1 <= len W3 by A1, lWAPPND02;  then
A3: n <= len W3 by A1, AXIOMS:22; then
    len W3.cut(m,n) + m = n + 1 by A1, lWCUT01
                       .= len W1.cut(m,n) + m by A1, lWCUT01; then
A4: len W3.cut(m,n) = len W1.cut(m,n) by XCMPLX_1:2;
A5: W3.cut(m,n) = (m,n)-cut W3 by A1, A3, dWCUT;
A6: W1.cut(m,n) = (m,n)-cut W1 by A1, dWCUT;
A7: 1 <= m & m <= n + 1 by HEYTING3:1, A1, NAT_1:37;
    now let x be Nat; assume x in Seg len W1.cut(m,n); then
        x in dom W1.cut(m,n) by FINSEQ_1:def 3; then
    B2: 1 <= x & x <= len W1.cut(m,n) by FINSEQ_3:27; then
        reconsider x_1 = x-1 as Nat by INT_1:18;
    B3: x_1 + 1 = x;
    B4: x_1 < len W3.cut(m,n) - 0 by A4,B2,REAL_1:92;
    B5: x_1 < len W1.cut(m,n) - 0 by B2,REAL_1:92; then
    B6: W1.cut(m,n).x = W1.(m+x_1) by A1,A6,A7,B3,GRAPH_2:def 1;
    B7: W3.cut(m,n).x = W3.(m+x_1) by A3,A5,A7,B3,B4,GRAPH_2:def 1;
    B8: 1 <= m+x_1 by A7, NAT_1:37;
        len W1.cut(m,n) + m = n + 1 by A1, lWCUT01; then
        m + x_1 < n + 1 by B5, REAL_1:67; then
        m + x_1 <= n by NAT_1:38; then
        m+x_1 <= len W1 by A1, AXIOMS:22; then
        m+x_1 in dom W1 by B8, FINSEQ_3:27;
        hence W3.cut(m,n).x = W1.cut(m,n).x by B6,B7,lWAPPND05;
    end;
    hence thesis by A4, FINSEQ_2:10;
end;    

lWCUT10:
  for G being _Graph, W being Walk of G, m being odd Nat st m <= len W holds
     len W.cut(1,m) = m proof
    let G be _Graph, W be Walk of G, m be odd Nat; assume
A1: m <= len W;
    1 is odd & 1 <= m by HEYTING3:1, JORDAN12:3; then
    len W.cut(1,m) + 1 = m + 1 by A1, lWCUT01;
    hence thesis by XCMPLX_1:2;
end;     

lWCUT11:
  for G be _Graph, W be Walk of G, m be odd Nat, x be Nat
    st x in dom W.cut(1,m) & m <= len W holds W.cut(1,m).x = W.x proof
    let G be _Graph, W be Walk of G, m be odd Nat, x be Nat; assume
A1: x in dom W.cut(1,m) & m <= len W; then
A2: 1 <= x & x <= len W.cut(1,m) by FINSEQ_3:27; then
    reconsider x_1 = x-1 as Nat by INT_1:18;
A3: x_1 + 1 = x;
A4: 1 is odd & 1 <= m by HEYTING3:1, JORDAN12:3;
    x-1 < len W.cut(1,m) - 0 by A2, REAL_1:92;
    hence W.cut(1,m).x = W.x by A1,A3,A4,lWCUT01;
end;     

lWREMOVE01:
  for G be _Graph, W be Walk of G, m,n be odd Nat
    st m <= n & n <= len W & W.m = W.n holds
    len W.remove(m,n) + n = len W + m proof
    let G be _Graph, W be Walk of G, m, n be odd Nat;
    set W1 = W.cut(1,m), W2 = W.cut(n,len W); assume
A1: m <= n & n <= len W & W.m = W.n; then
A2: 1 is odd & 1 <= m & m <= len W by HEYTING3:1, JORDAN12:3, AXIOMS:22; 
A3: W.remove(m,n) = W1.append(W2) by A1,dWREMOVE;
A4: W1.last() = W.n & W.n = W2.first() by A1, A2, lWCUT02;
    len W1 + 1 = m + 1 by A2, lWCUT01; then
A6: len W1 = m by XCMPLX_1:2;
    len W2 + n = len W + 1 by A1, lWCUT01; then
    len W2 = len W + 1 - n by XCMPLX_1:26; then
    len W1.append(W2) + 1 = m + (len W + 1 + -n) by A4,lWAPPND01,A6
                         .= len W + m + -n + 1; then
    len W1.append(W2) = len W + m - n by XCMPLX_1:2;
    hence thesis by A3;
end;

lWREMOVE02:
  for G be _Graph, W be Walk of G, m,n be Nat, x,y be set holds
    W is_Walk_from x,y implies W.remove(m,n) is_Walk_from x,y proof
    let G be _Graph, W be Walk of G, m,n be Nat, x,y be set;
    set W2 = W.remove(m,n), WA = W.cut(1,m), WB = W.cut(n,len W); assume
A1: W is_Walk_from x,y;   
    now per cases;
    suppose
    B1: m is odd & n is odd & m <= n & n <= len W & W.m = W.n; then
    B2: 1 is odd & 1 <= m & m <= len W by HEYTING3:1,JORDAN12:3,AXIOMS:22;
    B3: W2 = WA.append(WB) by B1, dWREMOVE;
    B4: WA.last() = W.n by B1, B2, lWCUT02
                 .= WB.first() by B1, lWCUT02;
    B5: WA.first() = W.1 by B1, B2, lWCUT02
                  .= W.first() by dWFIRST
                  .= x by A1, dWALKFROM;
        WB.last() = W.(len W) by B1, lWCUT02
                 .= W.last() by dWLAST
                 .= y by A1, dWALKFROM;
        hence thesis by B3,B4,B5,lWAPPND03; end;
    suppose not (m is odd & n is odd & m <= n & n <= len W & W.m = W.n);
       hence thesis by A1,dWREMOVE; end;
    end;
    hence thesis;
end;   

lWREMOVE03:
  for G being _Graph, W being Walk of G, m,n be Nat holds
    len W.remove(m,n) <= len W proof
    let G be _Graph, W be Walk of G, m,n be Nat;    
    set W2 = W.remove(m,n);
    now per cases;
    suppose
    A1: m is odd & n is odd & m <= n & n <= len W & W.m = W.n; then
        len W2 + n = len W + m by lWREMOVE01; then
        len W2 + n - n <= len W + m - m by A1, REAL_1:92;
        hence len W2 <= len W; end;
    suppose not (m is odd & n is odd & m <= n & n <= len W & W.m = W.n);
        hence len W2 <= len W by dWREMOVE; end;
    end;
    hence thesis;
end;  

lWREMOVE04:
  for G be _Graph, W be Walk of G, m be Nat holds W.remove(m,m) = W proof
    let G be _Graph, W be Walk of G, m be Nat;
    now per cases;
    suppose
    B1: m is odd & m <= len W & W.m = W.m; then
    B2: 1 is odd & 1 <= m by HEYTING3:1, JORDAN12:3;
        thus W.remove(m,m) = W.cut(1,m).append(W.cut(m,len W)) by B1, dWREMOVE
                          .= W.cut(1,len W) by B1, B2, lWCUT03
                          .= W by lWCUT04; end;
    suppose not (m is odd & m <= len W & W.m = W.m);
        hence W.remove(m,m) = W by dWREMOVE; end;
    end;
    hence thesis;
    
end;  

lWREMOVE05:
  for G being _Graph, W being Walk of G, m,n be odd Nat 
   st m <= n & n <= len W & W.m = W.n holds
     W.cut(1,m).last() = W.cut(n,len W).first() proof
    let G be _Graph, W be Walk of G, m,n be odd Nat; assume
A1: m <= n & n <= len W & W.m = W.n; then
A2: m <= len W by AXIOMS:22;
    1 <= m & 1 is odd by HEYTING3:1, JORDAN12:3; 
    hence W.cut(1,m).last() = W.n by A1,A2,lWCUT02
                           .= W.cut(n,len W).first() by A1, lWCUT02;
end;

lWREMOVE06:
  for G be _Graph, W be Walk of G, x,y be set, m,n being odd Nat
   st m <= n & n <= len W & W.m = W.n holds
     (for x being Nat st x in Seg m holds W.remove(m,n).x = W.x) proof
    let G be _Graph, W be Walk of G, x,y be set, m, n be odd Nat;
    set W2 = W.remove(m,n); assume
A1: m <= n & n <= len W & W.m = W.n; then
A2: W2 = W.cut(1,m).append(W.cut(n,len W)) by dWREMOVE;
A4: m <= len W by A1, AXIOMS:22;
    let x be Nat; assume x in Seg m; then
    1 <= x & x <= m by FINSEQ_1:3; then
    1 <= x & x <= len W.cut(1,m) by A4, lWCUT10; then
A5: x in dom W.cut(1,m) by FINSEQ_3:27; 
    hence W2.x = W.cut(1,m).x by A2,lWAPPND05
              .= W.x by A4,A5,lWCUT11;
end;     

lWREMOVE07:
  for G be _Graph, W be Walk of G, m,n being odd Nat
    st m <= n & n <= len W & W.m = W.n holds
     (for x being Nat st m <= x & x <= len W.remove(m,n) holds
        W.remove(m,n).x = W.(x - m + n) &
        x - m + n is Nat & x - m + n <= len W) proof
    let G be _Graph, W be Walk of G, m, n be odd Nat;
    set W2 = W.remove(m,n), WA = W.cut(1,m), WB = W.cut(n,len W); assume
A1: m <= n & n <= len W & W.m = W.n; then
A2: W2 = WA.append(WB) by dWREMOVE;
A3: WA.last() = WB.first() by A1, lWREMOVE05;
    1 is odd & 1 <= m & m <= len W by HEYTING3:1,JORDAN12:3,A1,AXIOMS:22; then
A5: len WA = m by lWCUT10;
A6: len WB + n = len W + 1 by A1, lWCUT01;
A7: len W2 + n = len W + m by A1, lWREMOVE01;
    let x be Nat; assume
A8: m <= x & x <= len W2; then consider a being Nat such that
A9: len WA + a = x by A5, NAT_1:28;
    m + a + n <= m + len W by A5,A7,A8,A9,REAL_1:55; then
AD: a+n + m - m <= len W + m - m by REAL_1:92; then
    a + n + 1 <= len WB + n by A6, REAL_1:55; then
    a + 1 + n - n <= len WB + n - n by REAL_1:92; then
AA: a + 1 - 1 < len WB + 1 - 1 by NAT_1:38; then
AB: W2.x = WB.(a+1) by A2,A3,A9,lWAPPND06
        .= W.(a + n) by A1, AA, lWCUT01;
    thus W2.x = W.(x - m + n) by AB, A5, A9;
    a + n is Nat;
    hence x-m+n is Nat by A5, A9;
    thus x-m+n <= len W by A5, A9, AD;
end;        

lWREMOVE08:
  for G be _Graph, W be Walk of G, m,n be odd Nat
    st m <= n & n <= len W & W.m = W.n holds
    len W.remove(m,n) = len W + m - n proof
   let G be _Graph, W be Walk of G, m,n be odd Nat; assume
   m <= n & n <= len W & W.m = W.n; then
   len W.remove(m,n) + n = len W + m by lWREMOVE01;
   hence thesis by XCMPLX_1:26;
end;    

lWREMOVE10:
  for G be _Graph, W be Walk of G, m being Nat st W.first() = W.m holds
    W.remove(1,m) = W.cut(m, len W) proof
    let G be _Graph, W be Walk of G, m be Nat; assume W.first() = W.m; then
A1: W.1 = W.m by dWFIRST;
    now per cases;
    suppose
    B1: m is odd & m <= len W; then
        1 is odd & 1 <= m by JORDAN12:3, HEYTING3:1; then
    B3: W.remove(1,m) = W.cut(1,1).append(W.cut(m, len W))
          by A1,B1,dWREMOVE;
    B4: 1 <= len W by HEYTING3:1; then
    B5: W.cut(1,1).last() = W.m by A1,JORDAN12:3,lWCUT02
                         .= W.cut(m, len W).first() by B1,lWCUT02; then
        len W.remove(1,m) + 1 = len W.cut(1,1) + len W.cut(m, len W)
          by B3, lWAPPND01; then
        len W.remove(1,m) + 1 = len W.cut(m, len W) + 1
          by JORDAN12:3,B4,lWCUT10; then
    B6: len W.remove(1,m) = len W.cut(m, len W) by XCMPLX_1:2;
        now let n be Nat; assume 1 <= n & n <= len W.remove(1,m); then
        C2: n in dom W.remove(1,m) by FINSEQ_3:27;
            now per cases by B3, C2, lWAPPND07;
              suppose
            D1: n in dom W.cut(1,1); then
            D2: 1 <= n & n <= len W.cut(1,1) by FINSEQ_3:27; then
            D3: n <= 1 by JORDAN12:3,B4,lWCUT10; then
            D4: n = 1 by D2, AXIOMS:21;
                W.remove(1,m).n = W.cut(1,1).n by B3,D1,lWAPPND05
                               .= <* W.vertexAt(1) *>.1
                                 by JORDAN12:3,B4,D4,lWCUT07
                               .= W.vertexAt(1) by FINSEQ_1:def 8
                               .= W.m by A1,JORDAN12:3,B4,dWVAT
                               .= W.cut(m, len W).first() by B1, lWCUT02
                               .= W.cut(m, len W).1 by dWFIRST;
                hence W.remove(1,m).n = W.cut(m, len W).n by D3,D2,AXIOMS:21;
              end;
              suppose ex k being Nat st k < len W.cut(m, len W) &
                    n = len W.cut(1,1) + k; then consider k being Nat such that
            D1: k < len W.cut(m, len W) & n = len W.cut(1,1) + k;
                n = k + 1 by D1,JORDAN12:3,B4, lWCUT10;
                hence W.remove(1,m).n = W.cut(m, len W).n
                  by B3,B5,D1,lWAPPND06;
              end;
            end;
            hence W.remove(1,m).n = W.cut(m, len W).n;
        end;
        hence thesis by B6, FINSEQ_1:18; end;
    suppose
    B1: not (m is odd & m <= len W); then
        W.cut(m, len W) = W by dWCUT;
        hence thesis by B1, dWREMOVE; end;
    end;
    hence thesis;
end;    

lWREMOVE11:
  for G be _Graph, W be Walk of G, m,n be Nat holds
  W.remove(m,n).first() = W.first() &
    W.remove(m,n).last() = W.last() proof
    let G be _Graph, W be Walk of G, m,n be Nat;    
    W is_Walk_from W.first(), W.last() by dWALKFROM; then
    W.remove(m,n) is_Walk_from W.first(), W.last() by lWREMOVE02;
    hence thesis by dWALKFROM;
end;    

lWREMOVE12:
 for G be _Graph, W be Walk of G, m,n being odd Nat, x being Nat
  st m <= n & n <= len W & W.m = W.n & x in dom W.remove(m,n) holds
     x in Seg m or (m <= x & x <= len W.remove(m,n)) proof
   let G be _Graph, W be Walk of G, m,n be odd Nat, x be Nat; assume
    m <= n & n <= len W & W.m = W.n & x in dom W.remove(m,n); then
    1 <= x & x <= len W.remove(m,n) by FINSEQ_3:27;
    hence thesis by FINSEQ_1:3;
end;       

lWADDEDGE01:
  for G be _Graph, W be Walk of G, e,x be set holds
  e Joins W.last(), x, G implies
  W.addEdge(e) = W^<*e,x*> proof
    let G be _Graph, W be Walk of G, e,x be set;  
    set W1 = G.walkOf(W.last(), e, W.last().adj(e)); assume
A1: e Joins W.last(), x, G; then
    reconsider x'=x as Vertex of G by GLIB_000:16;
A2: W.last().adj(e) = x' by A1, GLIB_000:69; then
A3: W1 = <*W.last(), e, x*> by A1, dWALKOFE;
    W.last() = W1.first() by A1, A2, lWALKOFE02; then
A4: W.append(W1) = W ^' W1 by dWAPPND
                .= W ^ (2,len W1)-cut W1 by GRAPH_2:def 2
                .= W ^ (2,3)-cut W1 by A3, FINSEQ_1:62;
A5: len W1 = 3 & W1.2 = e & W1.3 = x by A3, FINSEQ_1:62; then
    (2,2)-cut W1 = <*e*> & (3,3)-cut W1 = <*x*> by GRAPH_2:6; then
    <*e*> ^ (2+1,3)-cut W1 = (1+1,3)-cut W1 by A5, GRAPH_2:8; then
    <*e*> ^ <*x*> = (2,3)-cut W1 by A5, GRAPH_2:6; then
    W.append(G.walkOf(W.last(), e, x)) = W^<*e,x*> by A2, A4, FINSEQ_1:def 9;
    hence thesis by A2, dWADDEDGE;
end;

lWADDEDGE02:
  for G be _Graph, W be Walk of G, e,x be set holds
    e Joins W.last(),x,G implies
    W.addEdge(e).first() = W.first() & W.addEdge(e).last() = x &
  W.addEdge(e) is_Walk_from W.first(), x proof
    let G be _Graph, W be Walk of G, e,x be set;
    set W2 = G.walkOf(W.last(), e, W.last().adj(e)); assume
A1: e Joins W.last(), x, G; then
    reconsider x'=x as Vertex of G by GLIB_000:16;
    W.last().adj(e) = x' by A1, GLIB_000:69; then
    W2.first() = W.last() & W2.last() = x by A1, lWALKOFE02; then
    W.append(W2) is_Walk_from W.first(), x by lWAPPND03; then
    W.addEdge(e) is_Walk_from W.first(), x by dWADDEDGE;
    hence thesis by dWALKFROM;
end;

lWADDEDGE03:
  for G be _Graph, W be Walk of G, e,x be set holds
  e Joins W.last(),x,G implies 
  len W.addEdge(e) = len W + 2 proof
    let G be _Graph, W be Walk of G, e,x be set;
    set W2 = G.walkOf(W.last(),e, W.last().adj(e)); assume
A1: e Joins W.last(), x, G; then
    reconsider x'=x as Vertex of G by GLIB_000:16;
A2: W.last().adj(e) = x' by A1, GLIB_000:69; then
A3: W2 = <*W.last(), e, x*> by A1, dWALKOFE;
A4: W2.first() = W.last() by A1, A2, lWALKOFE02;
    W.addEdge(e) = W.append(W2) by dWADDEDGE; then
    len W.addEdge(e) + 1 = len W + len W2 by A4, lWAPPND01; then
    len W.addEdge(e) + 1 = len W + 3 by A3, FINSEQ_1:62; 
    hence len W.addEdge(e) = len W + 3 - 1 by XCMPLX_1:26
                          .= len W + 2;
end;  

lWADDEDGE04:
  for G be _Graph, W be Walk of G, e,x be set holds
  e Joins W.last(),x,G implies
  W.addEdge(e).(len W + 1) = e & W.addEdge(e).(len W + 2) = x &
  for n being Nat st n in dom W holds W.addEdge(e).n = W.n proof
    let G be _Graph, W be Walk of G, e,x be set;
    set W2 = W.addEdge(e); assume
    e Joins W.last(), x, G; then
A1: W2 = W^<*e,x*> by lWADDEDGE01;
A2: <*e,x*>.1 = e & <*e,x*>.2 = x by FINSEQ_1:61;
A3: dom <*e,x*> = Seg 2 by FINSEQ_3:29; then
    1 in dom <*e,x*> by FINSEQ_1:3;
    hence W2.(len W + 1) = e by A1, A2, FINSEQ_1:def 7;
    2 in dom <*e,x*> by A3, FINSEQ_1:3;
    hence W2.(len W + 2) = x by A1, A2, FINSEQ_1:def 7;
    let n be Nat;
    assume n in dom W;
    hence thesis by A1, FINSEQ_1:def 7;
end;

lWADDEDGE05:
  for G be _Graph, W be Walk of G, e,x,y,z be set holds
  W is_Walk_from x,y & e Joins y,z,G implies
  W.addEdge(e) is_Walk_from x,z proof
    let G be _Graph, W be Walk of G, e,x,y,z be set; assume
A1: W is_Walk_from x,y & e Joins y,z,G; then
    W.first() = x & W.last() = y by dWALKFROM;
    hence thesis by A1, lWADDEDGE02;
end;

lWESEQ01:
  for G being _Graph, W being Walk of G, n being even Nat
    st 1 <= n & n <= len W holds
    n div 2 in dom W.edgeSeq() & W.n = W.edgeSeq().(n div 2) proof
    let G be _Graph, W be Walk of G, n be even Nat; assume
A1: 1 <= n & n <= len W;
A0: 2 divides n by PEPIN:22; then
A2: n = 2 * (n div 2) by NAT_1:49;
A3: now assume
    B0: not n div 2 in dom W.edgeSeq();
        now per cases by B0,FINSEQ_3:27;
        suppose n div 2 < 0+1; then
            n div 2 <= 0 by NAT_1:38; then
            n div 2 = 0 by NAT_1:18; then
            n = 2 * 0 by A0,NAT_1:49;
            hence contradiction by A1; end;
        suppose n div 2 > len W.edgeSeq(); then
            2 * (n div 2) > 2 * len W.edgeSeq() by REAL_1:70; then
            n + 1 > 2 * len W.edgeSeq() + 1 by A2, REAL_1:67; then
            n + 1 > len W by dWESEQ; then
            n >= len W by NAT_1:38;
            hence contradiction by A1,REAL_1:def 5; end;
        end;
        hence contradiction;
    end;
    hence n div 2 in dom W.edgeSeq();
    1 <= n div 2 & n div 2 <= len W.edgeSeq() by A3,FINSEQ_3:27;
    hence thesis by A2,dWESEQ;
end;  

lWESEQ02:
  for G being _Graph, W being Walk of G, n being Nat holds
    n in dom W.edgeSeq() iff 2*n in dom W proof
    let G be _Graph, W be Walk of G, n be Nat;    
    hereby assume n in dom W.edgeSeq(); then
    B1: 1 <= n & n <= len W.edgeSeq() by FINSEQ_3:27; then
    B2: 1 <= n + n by NAT_1:37;
        2*n <= len W.edgeSeq()*2 by B1, NAT_1:20; then
        2*n <= len W.edgeSeq()*2 + 1 by NAT_1:37; then
        2*n <= len W by dWESEQ;
        hence 2*n in dom W by B2,FINSEQ_3:27;
    end;
    assume 2*n in dom W; then
    1 <= 2*n & 2*n <= len W by FINSEQ_3:27; then
    2*n div 2 in dom W.edgeSeq() by lWESEQ01;
    hence n in dom W.edgeSeq() by AMI_5:3;
end;  

lWESEQ04:
  for G be _Graph, W be Walk of G holds
  ex lenW_1 being even Nat st lenW_1 = len W - 1 &
  len W.edgeSeq() = lenW_1 div 2 proof
    let G be _Graph, W be Walk of G; set lenW_1 = len W - 1;
    1 <= len W by HEYTING3:1; then
    reconsider lenW_1 as even Nat by INT_1:18;
    take lenW_1;
    thus lenW_1 = len W - 1;
A1: len W = 2*len W.edgeSeq()+1 by dWESEQ;
    2 divides lenW_1 by PEPIN:22; then
    lenW_1 = 2 * (lenW_1 div 2) by NAT_1:49;
    hence thesis by A1,XCMPLX_1:5;
end;  

lWESEQ05:
  for G be _Graph, W be Walk of G, n be Nat holds
   W.cut(1,n).edgeSeq() c= W.edgeSeq() proof
    let G be _Graph, W be Walk of G, n be Nat;   
    per cases;
    suppose
    A1: n is odd & 1 <= n & n <= len W;
        set f = W.cut(1,n).edgeSeq();
        now let e be set; assume
        B1: e in W.cut(1,n).edgeSeq(); then
            consider x,y being set such that
        B2: e = [x,y] by RELAT_1:def 1;
        B3: x in dom f & y = f.x by B1, B2, FUNCT_1:8; then
            reconsider x as Nat;
            1 <= x & x <= len f by B3, FINSEQ_3:27; then
        B4: y = W.cut(1,n).(2*x) by B3, dWESEQ;
        B5: 2*x in dom W.cut(1,n) by B3, lWESEQ02; then
        B6: y = W.(2*x) by A1, B4, lWCUT11;
        B7: 1 <= 2*x & 2*x <= len W.cut(1,n) by B5, FINSEQ_3:27; then
            2*x <= n by A1, lWCUT10; then
            2*x <= len W by A1, AXIOMS:22; then
            2*x in dom W by B7, FINSEQ_3:27; then
        B8: x in dom W.edgeSeq() by lWESEQ02; then
            1 <= x & x <= len W.edgeSeq() by FINSEQ_3:27; then
            W.edgeSeq().x = y by B6, dWESEQ;
            hence e in W.edgeSeq() by B2, B8, FUNCT_1:8;
        end;
        hence thesis by TARSKI:def 3;
        end;
    suppose not (n is odd & 1 <= n & n <= len W);
        hence thesis by dWCUT; end;
end;

lWESEQ06:
  for G be _Graph, W be Walk of G, e,x be set holds
    e Joins W.last(),x,G implies
    W.addEdge(e).edgeSeq() = W.edgeSeq() ^ <*e*> proof
    let G be _Graph, W be Walk of G, e,x be set;    
    set W2 = W.addEdge(e), W3 = W.edgeSeq() ^ <*e*>; assume
A1: e Joins W.last(),x,G; then
    len W2 = len W + 2 by lWADDEDGE03; then
    len W + 2 = 2 * len W2.edgeSeq() + 1 by dWESEQ; then
    2 + (2*len W.edgeSeq()+1) = 2*len W2.edgeSeq() + 1 by dWESEQ; then
    2 + 2*len W.edgeSeq() + 1 = 2*len W2.edgeSeq() + 1 by XCMPLX_1:1; then
A4: 2*(len W.edgeSeq()+1) = 2*len W2.edgeSeq() by XCMPLX_1:2;
    len W3 = len W.edgeSeq() + len <*e*> by FINSEQ_1:35; then
    2*len W3 = 2*len W2.edgeSeq() by A4,FINSEQ_1:56; then
A6: len W3 = len W2.edgeSeq() by XCMPLX_1:5;
    now let k be Nat; assume
    B1: 1 <= k & k <= len W2.edgeSeq(); then
    B2: k in dom W3 by A6, FINSEQ_3:27;
    B3: W2.edgeSeq().k = W2.(2*k) by B1, dWESEQ;
        now per cases by B2, FINSEQ_1:38;
        suppose
        C1: k in dom W.edgeSeq(); then
        C2: W3.k = W.edgeSeq().k by FINSEQ_1:def 7;
            1 <= k & k <= len W.edgeSeq() by C1, FINSEQ_3:27; then
        C3: W3.k = W.(2*k) by C2, dWESEQ;
            2*k in dom W by C1, lWESEQ02;
            hence W2.edgeSeq().k = W3.k by A1,B3,C3,lWADDEDGE04; end;
        suppose ex n being Nat st n in dom <*e*> & k=len W.edgeSeq() + n;then
            consider n being Nat such that
        C1: n in dom <*e*> & k = len W.edgeSeq() + n;
            n in {1} by FINSEQ_1:4,C1,FINSEQ_1:55; then
        C2: n = 1 by TARSKI:def 1; then
        C3: W3.k = <*e*>.1 by C1, FINSEQ_1:def 7
                .= e by FINSEQ_1:def 8;
            2*k = 2*len W.edgeSeq() + 1 + 1 by C1,C2
               .= len W + 1 by dWESEQ;
            hence W2.edgeSeq().k = W3.k by A1,lWADDEDGE04,B3, C3; end;
        end;
        hence W2.edgeSeq().k = W3.k;
    end;
    hence W2.edgeSeq() = W3 by A6, FINSEQ_1:18;
end;    

lWVERTICES01:
  for G be _Graph, W be Walk of G, x be set holds
    x in W.vertices() iff
     ex n being odd Nat st n <= len W & W.n = x proof
    let G be _Graph, W be Walk of G, x be set; set vs = W.vertexSeq();
    hereby assume x in W.vertices(); then
        x in rng vs by dWVERTICES; then consider i being Nat such that
    B1: i in dom vs & vs.i = x by FINSEQ_2:11;
        set n1 = 2*i; reconsider n1 as even Nat; set n = n1-1;
    B2: 1 <= i & i <= len vs by B1, FINSEQ_3:27;
        1 <= i+i by B2,NAT_1:37; then reconsider n as odd Nat by INT_1:18;
        take n;
        i*2 <= len vs *2 by B2, AXIOMS:25; then
        i*2 <= len W + 1 by dWVSEQ; then
        n1 - 1 <= len W + 1 - 1 by REAL_1:92;
        hence n <= len W; 
        thus W.n = x by B1,B2,dWVSEQ;
    end;
    assume ex n being odd Nat st n <= len W & W.n = x; then
    consider n being odd Nat such that
A1: n <= len W & W.n = x;
    set n1 = n+1; reconsider n1 as even Nat;
    set i = n1 div 2;
A0: 2 divides n1 by PEPIN:22; then
A2: 2*i = n1 by NAT_1:49;
    reconsider i as Nat;
    now 1 <= n by HEYTING3:1; then
        1+1 <= n1 by REAL_1:55; then
        2*1 <= 2*i by A0,NAT_1:49; then
    B1: 1 <= i by tREAL01;
        n1 <= len W + 1 by A1, REAL_1:55; then
        2*i <= 2*len vs by A2, dWVSEQ; then
    B2: i <= len vs by tREAL01;
        hence i in dom vs by B1, FINSEQ_3:27;
        thus vs.i = W.(2*i-1) by B1,B2,dWVSEQ
                 .= x by A1, A2, XCMPLX_1:26;
    end; then
    x in rng vs by FUNCT_1:def 5;
    hence x in W.vertices() by dWVERTICES;
end;

lWEDGES01:
  for G be _Graph, W be Walk of G, e be set holds
    e in W.edges() iff
     ex n being even Nat st 1 <= n & n <= len W & W.n = e proof
    let G be _Graph, W be Walk of G, e be set; set es = W.edgeSeq();
    hereby assume e in W.edges(); then
        e in rng es by dWEDGES; then consider i being Nat such that
    B1: i in dom es & es.i = e by FINSEQ_2:11;
        set n = 2*i; reconsider n as even Nat; 
    B2: 1 <= i & i <= len es by B1, FINSEQ_3:27;
        take n;
        1 <= i+i by B2, NAT_1:37;
        hence 1 <= n;
        i*2 <= len es * 2 by B2, AXIOMS:25; then
        n <= len es * 2 + 1 by NAT_1:37;
        hence n <= len W by dWESEQ;
        thus W.n = e by B1,B2,dWESEQ;
    end;
    assume ex n being even Nat st 1 <= n & n <= len W & W.n = e; then
    consider n being even Nat such that
A1: 1 <= n & n <= len W & W.n = e;
    set i = n div 2;
    2 divides n by PEPIN:22; then
A2: 2*i = n by NAT_1:49;
    reconsider i as Nat;
    now 1 < n by A1, JORDAN12:3,REAL_1:def 5; then
        1+1 < n+1 by REAL_1:67; then
        2*1 <= 2*i by NAT_1:38,A2; then
    B1: 1 <= i by tREAL01;
        n < len W by A1, REAL_1:def 5; then
        2*i < 2*len es + 1 by A2, dWESEQ; then
        2*i <= 2*len es by NAT_1:38; then
    B2: i <= len es by tREAL01;
        hence i in dom es by B1, FINSEQ_3:27;
        thus es.i = e by A1, A2, B1, B2, dWESEQ;
    end; then
    e in rng es by FUNCT_1:def 5;
    hence e in W.edges() by dWEDGES;
end;

lWEDGES05:
  for G be _Graph, W be Walk of G, e be set holds
  e in W.edges() implies ex v1, v2 being Vertex of G, n being odd Nat st
    n+2 <= len W & v1 = W.n & e = W.(n+1) & v2 = W.(n+2) &
    e Joins v1, v2,G proof
    let G be _Graph, W be Walk of G, e be set; assume
    e in W.edges(); then consider n1 being even Nat such that
A1: 1 <= n1 & n1 <= len W & W.n1 = e by lWEDGES01;
    reconsider n = n1-1 as odd Nat by A1, INT_1:18;
    set v1 = W.n, v2 = W.(n+2);
    n1-1 <= len W - 0 by A1, REAL_1:92; then
    reconsider v1 as Vertex of G by lWALK02;
    reconsider lenW = len W as odd Nat;
    n1 < lenW by A1, REAL_1:def 5; then
AZ: n+1+1 <= len W by NAT_1:38;
    reconsider v2 as Vertex of G by AZ,lWALK02;
    take v1, v2, n;
    thus n+2 <= len W by AZ;
    thus v1 = W.n & e = W.(n+1) & v2 = W.(n+2) by A1;
    n+1-1 < len W - 0 by A1,REAL_1:92; 
    hence e Joins v1, v2, G by A1, dWALK;
end;

lWEDGES07:
  for G be _Graph, W be Walk of G, e,x,y be set holds
  e in W.edges() & e Joins x,y,G implies
    x in W.vertices() & y in W.vertices() proof
    let G be _Graph, W be Walk of G, e,x,y be set; assume
A1: e in W.edges() & e Joins x,y,G; then
    consider v1,v2 being Vertex of G, n being odd Nat such that
A2: n+2 <= len W & v1 = W.n & e = W.(n+1) & v2 = W.(n+2) &
      e Joins v1,v2,G by lWEDGES05;
A3: v2 in W.vertices() by A2, lWVERTICES01;
    n+2-2 <= len W-0 by A2, REAL_1:92; then
    v1 in W.vertices() by A2, lWVERTICES01;
    hence thesis by A1,A2,A3,GLIB_000:18;
end;    

lWLENGTH01: 
  for G be _Graph, W be Walk of G holds len W = 2 * W.length() + 1 proof
    let G be _Graph, W be Walk of G;  
    W.length() = len W.edgeSeq() by dWLENGTH;
    hence thesis by dWESEQ;
end;   

lWFINDN01:
  for G be _Graph, W be Walk of G, n be odd Nat
    st n <= len W holds W.find(n) <= n proof
    let G be _Graph, W be Walk of G, n be odd Nat; assume
A1: n <= len W; then
    W.find(n) <= len W & W.(W.find(n)) = W.n &
    for k being odd Nat st k <= len W & W.k = W.n holds W.find(n) <= k
      by dWFINDN;
    hence thesis by A1;
end;

lWRFINDN01:
  for G be _Graph, W be Walk of G, n being odd Nat
    st n <= len W holds W.rfind(n) >= n proof
    let G be _Graph, W be Walk of G, n be odd Nat; assume
A1: n <= len W; then
    W.rfind(n) <= len W & W.(W.rfind(n)) = W.n &
    for k being odd Nat st k <= len W & W.k = W.n holds k <= W.rfind(n)
      by dWRFINDN;
    hence thesis by A1;
end;  

lDIWALK01:
  for G being _Graph, W being Walk of G holds W is directed iff
    for n being odd Nat st n < len W
      holds W.(n+1) DJoins W.n, W.(n+2), G proof
    let G be _Graph, W be Walk of G;
    hereby assume
    B1: W is directed;
        let n be odd Nat; assume
    B2: n < len W; then
    B3: W.(n+1) Joins W.n, W.(n+2), G by dWALK;
    B5: W.n = (the_Source_of G).(W.(n+1)) by B1, B2, dDIWALK;
        now assume
        C1: W.(n+1) DJoins W.(n+2), W.n, G; then
            W.(n+2) = W.n by GLIB_000:def 16, B5;
            hence W.(n+1) DJoins W.n, W.(n+2), G by C1;
        end;
        hence W.(n+1) DJoins W.n, W.(n+2), G by B3,GLIB_000:19;
    end;
    assume
A1: for n being odd Nat st n < len W holds W.(n+1) DJoins W.n, W.(n+2), G;
    now let n be odd Nat; assume
        n < len W; then
        W.(n+1) DJoins W.n, W.(n+2), G by A1;
        hence (the_Source_of G).(W.(n+1)) = W.n by GLIB_000:def 16;
    end;  
    hence W is directed by dDIWALK;
end;
  
lDIWALK02:
  for G be _Graph, W be Walk of G, x,e,y,z be set holds
    W is directed & W is_Walk_from x,y & e DJoins y,z,G
    implies W.addEdge(e) is directed & W.addEdge(e) is_Walk_from x,z proof
    let G be _Graph, W be Walk of G, x,e,y,z be set;
    set W2 = W.addEdge(e); assume
A1: W is directed & W is_Walk_from x,y & e DJoins y,z,G; then
A2: W.last() = y by dWALKFROM; then
A3: e Joins W.last(),z,G by A1, GLIB_000:19; then
A4: len W2 = len W + 2 by lWADDEDGE03;
    1 <= len W by HEYTING3:1; then
    len W in dom W by FINSEQ_3:27; then
A5: W2.(len W) = W.(len W) by A3, lWADDEDGE04
              .= y by A2, dWLAST;
A6: W2.(len W + 1) = e by A3, lWADDEDGE04;
    now let n be odd Nat; assume n < len W2; then
        n < len W + 1+1 by A4; then
        n <= len W + 1 by NAT_1:38; then
        n < len W + 1 by REAL_1:def 5; then
    B2: n <= len W by NAT_1:38;
        now per cases;
          suppose n = len W;
            hence W2.n = (the_Source_of G).(W2.(n+1))
              by A1,A5,A6,GLIB_000:def 16;
          end;
          suppose n <> len W; then
        C2: n < len W by B2, REAL_1:def 5;
            1 <= n by HEYTING3:1; then
            n in dom W by B2,FINSEQ_3:27; then
        C4: W2.n = W.n by A3, lWADDEDGE04;
        C5: 1 <= n+1 by NAT_1:37;
            n + 1 <= len W by C2,NAT_1:38; then
            n+1 in dom W by C5, FINSEQ_3:27; then
            W2.(n+1) = W.(n+1) by A3, lWADDEDGE04;
            hence W2.n = (the_Source_of G).(W2.(n+1))
              by A1,C2,C4,dDIWALK;
          end;
        end;
        hence W2.n = (the_Source_of G).(W2.(n+1));
    end;
    hence W.addEdge(e) is directed by dDIWALK;
    thus W2 is_Walk_from x,z by A1,A2,A3,lWADDEDGE05 ;
end;

lDIWALK03:
  for G being _Graph, W being Walk of G, m,n being Nat holds
    W is directed implies W.cut(m,n) is directed proof 
    let G be _Graph, W be Walk of G, m, n be Nat; set W2 = W.cut(m,n); assume
A1: W is directed;    
    now per cases;
    suppose
    B1: m is odd & n is odd & m <= n & n <= len W; then
        reconsider m' = m as odd Nat;
        now let x be odd Nat; assume
        C1: x < len W2; then
        C2: W2.(x+1) = W.(m+x) & m+x in dom W by B1, lWCUT01;
            1 <= x by HEYTING3:1; then
            reconsider x_1 = x - 1 as even Nat by INT_1:18;
            x_1 < len W2 - 0 by C1, REAL_1:92; then
        C3: W2.(x_1+1) = W.(m+x_1) & m+x_1 in dom W by B1, lWCUT01;
            x + 1 <= len W2 by C1,NAT_1:38; then
        C4: x + 1 < len W2 by REAL_1:def 5;
             m'+x <= len W by C2, FINSEQ_3:27; then
        CZ: m'+x-1 < len W - 0 by REAL_1:92;
        C6: W2.(x+1) = W.(m+x-1+1) by C1,B1,lWCUT01
                    .= W.(m+x_1+1);
            W2.(x+2) = W2.(x+1+1)
                    .= W.(m+(x-1+1+1)) by C4,B1,lWCUT01
                    .= W.(m+x_1+2);
            hence W2.(x+1) DJoins W2.x, W2.(x+2), G by CZ,A1,lDIWALK01,C6,C3;
        end;
        hence W2 is directed by lDIWALK01; end;
    suppose not (m is odd & n is odd & m <= n & n <= len W);
        hence thesis by A1,dWCUT; end;
    end;
    hence thesis;
end;    

lTVWALK01:
  for G being _Graph, W being Walk of G holds
    W is non trivial iff 3 <= len W proof
    let G be _Graph, W be Walk of G;    
    hereby assume W is non trivial; then
        W.length() <> 0 by dTVWALK; then
        len W.edgeSeq() <> 0 by dWLENGTH; then
        len W.edgeSeq() > 0 by NAT_1:19; then
        0+1 <= len W.edgeSeq() by NAT_1:38; then
        2*1 <= 2*len W.edgeSeq() by NAT_1:20; then
        2+1 <= 2*len W.edgeSeq() + 1 by REAL_1:55;
        hence 3 <= len W by dWESEQ;
    end;
    assume 3 <= len W; then
    2*1 + 1 <= 2*len W.edgeSeq() + 1 by dWESEQ; then
    len W.edgeSeq() <> 0; then
    W.length() <> 0 by dWLENGTH;
    hence W is non trivial by dTVWALK;
end;

lTVWALK02:
  for G being _Graph, W being Walk of G holds
    W is non trivial iff len W <> 1 proof
    let G be _Graph, W be Walk of G;    
    thus W is non trivial implies len W <> 1 by lTVWALK01;
    assume
A1: len W <> 1;
    1 <= len W by HEYTING3:1; then
    1 < len W by A1, REAL_1:def 5; then
    1+1 <= len W by NAT_1:38; then
    2*1 < len W by REAL_1:def 5; then
    2*1+1 <= len W by NAT_1:38;
    hence W is non trivial by lTVWALK01;
end;  

lTVWALK04:
  for G be _Graph, W be Walk of G holds
  W is trivial iff ex v being Vertex of G st W = G.walkOf(v) proof
    let G be _Graph, W be Walk of G;  
    hereby assume W is trivial; then
    B1: len W = 1 by lTVWALK02;
        take v = W.first();
        v = W.1 by dWFIRST; then
        W = <*v*> by B1, FINSEQ_1:57;
        hence W = G.walkOf(v) by dWALKOFV;
    end;
    given v being Vertex of G such that
A1: W = G.walkOf(v);
    W = <*v*> by A1, dWALKOFV; then
    len W = 1 by FINSEQ_1:56;
    hence W is trivial by lTVWALK02;
end;  

lTLWALK01:
  for G being _Graph, W being Walk of G holds W is Trail-like iff
  for m,n being even Nat st 1 <= m & m < n & n <= len W holds
    W.m <> W.n proof
    let G be _Graph, W be Walk of G;    
    hereby assume W is Trail-like; then
    B1: W.edgeSeq() is one-to-one by dTLWALK;
        let m, n be even Nat; assume
    B2: 1 <= m & m < n & n <= len W; then
        m <= len W by AXIOMS:22; then
    B3: m div 2 in dom W.edgeSeq() & W.m = W.edgeSeq().(m div 2)
          by B2, lWESEQ01;
        1 <= n by B2, AXIOMS:22; then
    B4: n div 2 in dom W.edgeSeq() & W.n = W.edgeSeq().(n div 2)
          by B2, lWESEQ01;
        now assume
        C1: m div 2 = n div 2;
            2 divides m & 2 divides n by PEPIN:22; then
            2 * (m div 2) = m & 2 * (n div 2) = n by NAT_1:49;
            hence contradiction by B2,C1;
        end;
        hence W.m <> W.n by B1, B3, B4, FUNCT_1:def 8;
    end;
    assume
A1: for m,n being even Nat st 1 <= m & m < n & n <= len W holds W.m <> W.n;
    now let x1, x2 be set; assume
    B1: x1 in dom W.edgeSeq() & x2 in dom W.edgeSeq() &
          W.edgeSeq().x1 = W.edgeSeq().x2; then
        reconsider m = x1, n = x2 as Nat;
        1 <= m & m <= len W.edgeSeq() by B1, FINSEQ_3:27; then
    B2: W.edgeSeq().x1 = W.(2*m) by dWESEQ;
        1 <= n & n <= len W.edgeSeq() by B1, FINSEQ_3:27; then
    BZ: W.(2*m) = W.(2*n) by B1, B2, dWESEQ;
        2*m in dom W & 2*n in dom W by B1, lWESEQ02; then
    B4: 1 <= 2*m & 2*m <= len W & 1 <= 2*n & 2*n <= len W by FINSEQ_3:27;
        now per cases by REAL_1:def 5;
        suppose 2*m < 2*n; 
            hence x1 = x2 by A1, B4,BZ; end;
        suppose 2*m = 2*n;
            hence x1 = x2 by XCMPLX_1:5; end;
        suppose 2*m > 2*n;
            hence x1 = x2 by A1,B4,BZ; end;
        end;
        hence x1 = x2;
    end; then
    W.edgeSeq() is one-to-one by FUNCT_1:def 8;
    hence W is Trail-like by dTLWALK;
end;    

lTLWALK03:
  for G being _Graph, W being Walk of G holds
    W is Trail-like iff W.reverse() is Trail-like proof
    let G be _Graph, W be Walk of G;     
A1: now let W be Walk of G; assume
    B1: W is Trail-like;
        now let m, n be even Nat; assume
        C1: 1 <= m & m < n & n <= len W.reverse(); then
            m <= len W.reverse() by AXIOMS:22; then
            m in dom W.reverse() by C1, FINSEQ_3:27; then
        C2: W.reverse().m = W.(len W - m + 1) &
              len W - m + 1 in dom W by lWREV05;
            1 <= n by C1, AXIOMS:22; then
            n in dom W.reverse() by C1, FINSEQ_3:27; then
        C3: W.reverse().n = W.(len W - n + 1) &
              len W - n + 1 in dom W by lWREV05;
            reconsider lenW = len W as odd Nat;
            reconsider rn = lenW-n+1 as even Nat by C3;
            reconsider rm = lenW-m+1 as even Nat by C2;
            len W - n < len W - m by C1, REAL_1:92; then
        C4: len W - n + 1 < len W - m + 1 by REAL_1:67;
            1 <= rn & rm <= len W by C2, C3, FINSEQ_3:27;
            hence W.reverse().m <> W.reverse().n
              by C2, C3, B1, C4, lTLWALK01;
        end;
        hence W.reverse() is Trail-like by lTLWALK01;
    end;
    thus W is Trail-like implies W.reverse() is Trail-like by A1;
    assume W.reverse() is Trail-like; then
    W.reverse().reverse() is Trail-like by A1;
    hence W is Trail-like by lWREV06;
end;  

lTLWALK04:
  for G being _Graph, W being Walk of G, m,n being Nat holds
    W is Trail-like implies W.cut(m,n) is Trail-like proof
    let G be _Graph, W be Walk of G, m,n be Nat; assume
A1: W is Trail-like;    
    now per cases;
      suppose
    B1: m is odd & n is odd & m <= n & n <= len W;
        now let x,y be even Nat; assume
        C1: 1 <= x & x < y & y <= len W.cut(m,n);
            reconsider x_1 = x-1 as odd Nat by C1, INT_1:18;
            1 <= y by C1, AXIOMS:22; then
            reconsider y_1 = y-1 as odd Nat by INT_1:18;
            reconsider m'=m, n'=n as odd Nat by B1;
            x <= len W.cut(m,n) by C1, AXIOMS:22; then
            x-1 < len W.cut(m,n)-0 by REAL_1:92; then
        C2: W.cut(m,n).(x_1+1) = W.(m+x_1) &
              m+x_1 in dom W by B1, lWCUT01;
            y-1 < len W.cut(m,n)-0 by C1, REAL_1:92; then
        C3: W.cut(m,n).(y_1+1) = W.(m+y_1) &
               m+y_1 in dom W by B1, lWCUT01;
        C5: m+y_1 <= len W by C3, FINSEQ_3:27;
            1 <= m by B1, HEYTING3:1; then
        C6: 1 <= m+x_1 by NAT_1:37;
            x - 1 < y - 1 by C1, REAL_1:92; then
            x_1 + m < y_1 + m by REAL_1:67; then
            W.(m'+x_1) <> W.(m'+y_1) by A1, C5, C6, lTLWALK01;
            hence W.cut(m,n).x <> W.cut(m,n).y by C2,C3;
        end;
        hence thesis by lTLWALK01;
      end;
      suppose not (m is odd & n is odd & m <= n & n <= len W);
        hence thesis by A1,dWCUT;
      end;

    end;
    hence thesis;
end;

lTLWALK05:
  for G be _Graph, W being Walk of G, e being set
    st W is Trail-like & e in W.last().edgesInOut() & not e in W.edges()
    holds W.addEdge(e) is Trail-like proof
    let G be _Graph, W be Walk of G, e be set; assume
A1: W is Trail-like & e in W.last().edgesInOut() & not e in W.edges(); then
A2: e Joins W.last(), W.last().adj(e),G by GLIB_000:70;
    set W2 = W.addEdge(e);
    reconsider lenW = len W, lenW2 = len W2 as odd Nat;
    now let m,n be even Nat; assume
    B1: 1 <= m & m < n & n <= len W2;
        now per cases;
        suppose
        C1: n <= len W;
            1 <= n by B1, AXIOMS:22; then
            n in dom W by C1, FINSEQ_3:27; then
        C3: W2.n = W.n by A2, lWADDEDGE04;
            m <= len W by B1, C1, AXIOMS:22; then
            m in dom W by B1, FINSEQ_3:27; then
            W2.m = W.m by A2, lWADDEDGE04; 
            hence W2.m <> W2.n by A1, B1, C1, C3, lTLWALK01; end;
        suppose n > len W; then
        C1: len W + 1 <= n by NAT_1:38;
            n < lenW2 by B1, REAL_1:def 5; then
            n+1 <= len W2 by NAT_1:38; then
            n+1-1 <= len W2 - 1 by REAL_1:92; then
            n <= len W + (1+1) - 1 by A2, lWADDEDGE03; then
        C2: n = len W + 1 by C1, AXIOMS:21; then
        C3: W2.n = e by A2, lWADDEDGE04;
        C4: m + 1 - 1 <= len W + 1 - 1 by B1,C2,NAT_1:38; then
            m in dom W by B1, FINSEQ_3:27; then
            W2.m = W.m by A2, lWADDEDGE04;
            hence W2.m <> W2.n by A1,B1,C3,C4,lWEDGES01; end;
        end;
        hence W2.m <> W2.n;
    end;
    hence W2 is Trail-like by lTLWALK01;
end;    

lTLWALK02:
  for G be _Graph, W be Walk of G holds
   len W <= 3 implies W is Trail-like proof
    let G be _Graph, W be Walk of G; assume
A1: len W <= 3;
    now per cases;
    suppose len W = 1; then
        W is trivial by lTVWALK02; then consider v being Vertex of G such that
    B1: W = G.walkOf(v) by lTVWALK04;
        thus W is Trail-like by B1, lWALKOFV; end;
    suppose
    B1: len W <> 1;
        1 <= len W by HEYTING3:1; then
        1 < len W by B1, REAL_1:def 5; then
        1+2 <= len W by JORDAN12:3, tODD01; then
    B2: len W = 3 by A1, AXIOMS:21;
        now let m, n be even Nat such that
        C1: 1 <= m & m < n & n <= len W;
            2*0+1 < m by C1, REAL_1:def 5; then
        C2: 1+1 <= m by NAT_1:38;
            n < 2+1 by B2, C1, REAL_1:def 5; then
            n <= 2 by NAT_1:38;
            hence W.m <> W.n by C1,C2,AXIOMS:22;
        end;
        hence W is Trail-like by lTLWALK01; end;
    end;
    hence thesis;
end;   

lPLWALK:
  for G being _Graph, x,e,y being set holds
  e Joins x,y,G implies G.walkOf(x,e,y) is Path-like proof
    let G be _Graph, x,e,y be set; set W = G.walkOf(x,e,y); assume
A1: e Joins x,y,G; then
A2: len W = 3 by lWALKOFE01;
   now let m,n be even Nat; assume
    B1: 1 <= m & m < n & n <= len W; then
        1 < m by JORDAN12:3, REAL_1:def 5; then
        1+1 <= m by NAT_1:38; then
    B2: 2 < n by B1, AXIOMS:22;
        n <= 3 by A1,B1,lWALKOFE01; then
        n < 2*1+1 by REAL_1:def 5;
        hence W.m <> W.n by B2,NAT_1:38;
    end; then
A3: W is Trail-like by lTLWALK01;
    now let m,n be odd Nat; assume
    B1: m < n & n <= len W;  assume W.m = W.n;
    B2: 1 <= m by HEYTING3:1; then
        1 < n by B1, AXIOMS:22; then
        1+1 < n+1 by REAL_1:67; then
        2*1 <= n by NAT_1:38; then
        2*1 < n by REAL_1:def 5; then
        2+1 < n+1 by REAL_1:67; then
    B4: 3 <= n by NAT_1:38; then
    B3: n = 3 by A2, B1, AXIOMS:21;
        now assume m <> 1; then
            1 < m by B2, REAL_1:def 5; then
            1+1 < m+1 by REAL_1:67; then
            2*1 <= m by NAT_1:38; then
            2*1 < m by REAL_1:def 5; then
            2+1 < m+1 by REAL_1:67;
            hence contradiction by B1, B3, NAT_1:38;
        end;
        hence m = 1 & n = len W by B4,A2,B1,AXIOMS:21;
    end;
    hence thesis by A3, dPLWALK;
end;  

lPLWALK04:
  for G being _Graph, W being Walk of G holds
   W is Path-like iff W.reverse() is Path-like proof
    let G be _Graph, W be Walk of G;    
A1: now let W be Walk of G; assume
    B0: W is Path-like; then
        W is Trail-like & for m, n being odd Nat st m < n & n <= len W
          holds W.m = W.n implies (m = 1 & n = len W) by dPLWALK; then
    B2: W.reverse() is Trail-like by lTLWALK03;
        reconsider lenW=len W as odd Nat;
        now let m, n be odd Nat; assume
        C1: m < n & n <= len W.reverse() & W.reverse().m = W.reverse().n; then
        C2: m <= len W.reverse() by AXIOMS:22;
            1 <= m by HEYTING3:1; then
        CZ: m in dom W.reverse() by C2, FINSEQ_3:27; then
        C3: W.reverse().m = W.(len W - m + 1) & len W - m + 1 in dom W
              by lWREV05; then
            reconsider rm = lenW-m+1 as odd Nat;              
            1 <= n by HEYTING3:1; then
            n in dom W.reverse() by C1, FINSEQ_3:27; then
        C4: W.reverse().n = W.(len W - n + 1) & len W - n + 1 in dom W
              by lWREV05; then
            reconsider rn = lenW-n+1 as odd Nat;
            lenW - n < len W - m by C1, REAL_1:92; then
        C5: rn < rm by REAL_1:67;
        C6: rm <= len W by C3, FINSEQ_3:27;
        C8: W.rm = W.rn by C1, CZ,lWREV05, C4; then
        C7: rn = 1 & rm = len W by B0,dPLWALK,C5,C6; 
            len W + (1 + -m) = len W by C8,B0,dPLWALK,C5,C6; then
            1 + -m + len W - len W = 0; then
            1 - m = 0;
            hence m = 1 by XCMPLX_1:15;
            len W - n + 1 - 1 = 0 by C7; then
            n = len W by XCMPLX_1:15; 
            hence n = len W.reverse() by lWREV01;
        end;
        hence W.reverse() is Path-like by B2, dPLWALK;
    end;
    thus W is Path-like implies W.reverse() is Path-like by A1;
    assume W.reverse() is Path-like; then
    W.reverse().reverse() is Path-like by A1; 
    hence W is Path-like by lWREV06;
end;   

lPLWALK05:
  for G being _Graph, W being Walk of G, m, n being Nat st W is Path-like 
     holds W.cut(m,n) is Path-like proof
    let G be _Graph, W be Walk of G, m, n be Nat; assume
A0: W is Path-like;
    now per cases;
    suppose
    A1: m is odd & n is odd & m <= n & n <= len W; then
        reconsider m'=m, n'=n as odd Nat;
        now W is Trail-like by A0,dPLWALK;
            hence W.cut(m,n) is Trail-like by lTLWALK04;
            let x,y be odd Nat; assume
        B1: x < y & y <= len W.cut(m,n) & W.cut(m,n).x = W.cut(m,n).y;
            1 <= x by HEYTING3:1; then
            reconsider x_1 = x-1 as even Nat by INT_1:18;
            1 <= y by HEYTING3:1; then
            reconsider y_1 = y-1 as even Nat by INT_1:18;
            x <= len W.cut(m,n) by B1, AXIOMS:22; then
            x-1 < len W.cut(m,n) - 0 by REAL_1:92; then
        B2: W.cut(m,n).(x_1+1) = W.(m+x_1) &
              m+x_1 in dom W by A1, lWCUT01;
            y-1 < len W.cut(m,n) - 0 by B1, REAL_1:92; then
        B4: W.cut(m,n).(y_1+1) = W.(m+y_1) &
              m+y_1 in dom W by A1, lWCUT01;
            x - 1 < y - 1 by B1, REAL_1:92; then
        B7: x_1 + m < y_1 + m by REAL_1:67;
        BZ: 1 <= m'+x_1 & m'+y_1 <= len W by B2, B4, FINSEQ_3:27; then
        B8: m'+x_1 = 1 & m'+y_1 = len W by A0,B1,B2,B4,B7,dPLWALK;
        BY: now assume x_1 <> 0; then
            C1: 0 < x_1 by NAT_1:19; 
                1 <= m by A1, HEYTING3:1; then
                1+0 < m + x_1 by C1, REAL_1:67;
                hence contradiction by BZ,A0,B1,B2,B4,B7,dPLWALK;
            end;
            hence x = 1 by XCMPLX_1:15;
        B9: m + 1 - 1 = 1 by BZ,BY,A0,B1,B2,B4,B7,dPLWALK;
        BA: y = len W by BY,XCMPLX_1:27,B8;
            len W.cut(m,n) + 1 = n + 1
              by A1,B9,lWCUT01; then
            len W.cut(m,n) + 1 - 1 = n;
            hence y = len W.cut(m,n) by A1,BA,B1,AXIOMS:21;
        end;
        hence W.cut(m,n) is Path-like by dPLWALK; end;
    suppose not (m is odd & n is odd & m <= n & n <= len W);
        hence thesis by A0,dWCUT; end;
    end;
    hence thesis;
end;

lPLWALK06:
  for G being _Graph, W being Walk of G, e,v being set
   st W is Path-like & e Joins W.last(),v,G & not e in W.edges() &
      (W is trivial or W is open) &
     for n being odd Nat st 1 < n & n <= len W holds W.n <> v holds
   W.addEdge(e) is Path-like proof
    let G be _Graph, W be Walk of G, e,v be set; assume
A1: W is Path-like & e Joins W.last(), v,G & not e in W.edges() &
      (W is trivial or W is open) & 
      (for n being odd Nat st 1 < n & n <= len W holds W.n <> v); then
A2: e in W.last().edgesInOut() by GLIB_000:65; 
    set W2 = W.addEdge(e); reconsider lenW = len W as odd Nat;
    now W is Trail-like by A1, dPLWALK;
        hence W2 is Trail-like by A1, A2, lTLWALK05;
        let m, n be odd Nat; assume
    B1: m < n & n <= len W2 & W2.m = W2.n;
        now per cases by A1;
          suppose
        C1: W is open;
            now per cases;
              suppose
            D1: n <= len W; then
            D2: m <= len W by B1, AXIOMS:22;
                1 <= m by HEYTING3:1; then
                m in dom W by D2, FINSEQ_3:27; then
            D3: W2.m = W.m by A1, lWADDEDGE04;
                1 <= n by HEYTING3:1; then
                n in dom W by D1, FINSEQ_3:27; then
            D4: W.m = W.n by B1, D3,A1,lWADDEDGE04; then
            D5: m = 1 & n = len W by A1,B1, D1, dPLWALK; then
                W.first() = W.m by dWFIRST
                         .= W.last() by D4, D5, dWLAST;
                hence m = 1 & n = len W2 by C1, dCLWALK;
              end;
              suppose n > len W; then
                lenW + 1 <= n by NAT_1:38; then
                lenW + 1 < n by REAL_1:def 5; then
                lenW + 1 + 1 <= n by NAT_1:38; then
                len W + (1+1) <= n; then
            D0: len W2 <= n by A1, lWADDEDGE03; then
                n = len W2 by B1, AXIOMS:21; then
                W2.n = W2.(len W + 2) by A1, lWADDEDGE03; then
            D2: W2.n = v by A1, lWADDEDGE04; 
                m < len W2 by D0,B1,AXIOMS:21; then
                m < len W + (1 + 1) by A1, lWADDEDGE03; then
                m < len W + 1 + 1; then
                m <= lenW + 1 by NAT_1:38; then
                m < lenW + 1 by REAL_1:def 5; then
            D3: m <= len W by NAT_1:38;
                1 <= m by HEYTING3:1; then
                m in dom W by D3, FINSEQ_3:27; then
            D4: W.m = v by B1, D2,A1,lWADDEDGE04;
                now assume
                E1: m <> 1;
                    1 <= m by HEYTING3:1; then
                    1 < m by E1, REAL_1:def 5;
                    hence contradiction by D4,D3,A1;
                end;
                hence m = 1;
                thus n = len W2 by D0,B1,AXIOMS:21;
              end;
            end;
            hence m = 1 & n = len W2;
          end;
          suppose W is trivial; then consider v being Vertex of G such that
        C1: W = G.walkOf(v) by lTVWALK04;
            W = <*v*> by C1, dWALKOFV; then
            len W = 1 by FINSEQ_1:56; then
        C2: len W2 = 1 + 2 by A1, lWADDEDGE03;
        C3: 1 <= m by HEYTING3:1; then
        C4: 1+1 <= m+1 by REAL_1:55;
            m+1 <= n by B1, NAT_1:38; then
            2*1 <= n by C4, AXIOMS:22; then
            2*1 < n by REAL_1:def 5; then
        C5: len W2 <= n by C2,NAT_1:38; then
            n = len W2 by B1, AXIOMS:21; then
            m+1-1 <= 3-1 by B1,C2,NAT_1:38; then
            m < 2*1 by REAL_1:def 5; then
            m+1 <= 2 by NAT_1:38; then
            m+1-1 <= 2-1 by REAL_1:92;
            hence m = 1 & n = len W2 by C3,C5,B1,AXIOMS:21;
          end;
        end;
        hence m = 1 & n = len W2;
    end; 
    hence W.addEdge(e) is Path-like by dPLWALK;
end;   

lPLWALK02:
  for G be _Graph, W be Walk of G holds
  (for m,n being odd Nat st m <= len W & n <= len W & W.m = W.n holds m = n)
      implies W is Path-like proof
    let G be _Graph, W be Walk of G; assume
A1: for m,n being odd Nat st m <= len W & n <= len W & W.m = W.n holds m = n;
    now let m,n be even Nat; assume
    B1: 1 <= m & m < n & n <= len W; then
        1 <= n & m <= len W by AXIOMS:22; then
    B3: m in dom W & n in dom W by B1, FINSEQ_3:27;
        now assume
        C1: W.m = W.n;
            consider m_1 being odd Nat such that
        C2: m_1 = m-1 & m-1 in dom W & m+1 in dom W &
            W.m Joins W.(m_1), W.(m+1), G by B3, lWALK04;
            consider n_1 being odd Nat such that
        C3: n_1 = n-1 & n-1 in dom W & n+1 in dom W &
            W.m Joins W.(n_1), W.(n+1), G by C1, B3, lWALK04;
        C4: m_1 <= len W & m+1 <= len W by C2, FINSEQ_3:27;
        C5: n_1 <= len W & n+1 <= len W by C3, FINSEQ_3:27;
            now per cases by C2, C3, GLIB_000:18;
              suppose W.(n_1) = W.(m_1) & W.(n+1) = W.(m+1); then
                n_1 = m_1 by A1, C4, C5; then
                n = m_1 + 1 by C3
                 .= m by C2;
                hence contradiction by B1;
              end;
              suppose
            D1: W.(n_1) = W.(m+1) & W.(n+1) = W.(m_1); then
                n_1 = m+1 & n+1 = m_1 by A1,C4,C5; then
                n = m+1+1 by C3; then
                m_1 = m+(2+1) by D1,A1,C4,C5; then
                m = m+3+1 by C2,XCMPLX_1:27; then
                m + 0 = m+(3+1) by XCMPLX_1:1;
                hence contradiction by XCMPLX_1:2;
              end;
            end;
            hence contradiction;
        end;
        hence W.m <> W.n;
    end; then
A2: W is Trail-like by lTLWALK01;
    now let m,n be odd Nat; assume
    B1: m < n & n <= len W; then
    B2: m <= len W by AXIOMS:22;
        assume W.m = W.n;
        hence m = 1 & n = len W by B1,B2,A1;
    end;
    hence W is Path-like by A2, dPLWALK;
end;      

lPLWALK09:
  for G be _Graph, W be Walk of G holds
    (for n being odd Nat st n <= len W holds W.rfind(n) = n)
    implies W is Path-like proof
    let G be _Graph, W be Walk of G; assume
A1: for n being odd Nat st n <= len W holds W.rfind(n) = n;
    now let m,n be odd Nat; assume
    B1: m <= len W & n <= len W & W.m = W.n; then
    B2: W.rfind(m) = m & W.rfind(n) = n by A1;
    B5: n <= m by B1,B2,dWRFINDN;
        m <= n by B1,B2,dWRFINDN;
        hence m = n by B5, AXIOMS:21;
    end;
    hence W is Path-like by lPLWALK02;
end;     

lPLWALK07:
  for G be _Graph, W being Walk of G, e, v being set st e Joins W.last(),v,G &
    W is Path-like &
    not v in W.vertices() & (W is trivial or W is open)
    holds W.addEdge(e) is Path-like proof
    let G be _Graph, W be Walk of G, e , v be set; assume
A1: e Joins W.last(),v,G & W is Path-like & not v in W.vertices() &
    (W is trivial or W is open);
A2: not e in W.edges() by A1,lWEDGES07;
    for n being odd Nat st 1 < n & n <= len W holds v <> W.n
      by A1,lWVERTICES01;
    hence thesis by A1, A2, lPLWALK06;
end;     

lPLWALK01:
  for G be _Graph, W be Walk of G holds
  len W <= 3 implies W is Path-like proof
    let G be _Graph, W be Walk of G; assume
A1: len W <= 3;
    now per cases;
    suppose len W = 1; then
        W is trivial by lTVWALK02; then consider v being Vertex of G such that
    B1: W = G.walkOf(v) by lTVWALK04;
        thus W is Path-like by B1, lWALKOFV; end;
    suppose
    B1: len W <> 1;
        1 <= len W by HEYTING3:1; then
        1 < len W by B1, REAL_1:def 5; then
        1+2 <= len W by JORDAN12:3, tODD01; then
    B2: len W = 3 by A1, AXIOMS:21;
    B3: W is Trail-like by A1, lTLWALK02;
        now let m, n be odd Nat; assume
        C1: m < n & n <= len W & W.m = W.n;
            m < 2*1+1 by B2, C1, AXIOMS:22; then
            m+2 <= 3 by tODD01; then
        C2: m+2-2 <= 3-2 by REAL_1:92;
        C3: 1 <= m by HEYTING3:1;
            hence m = 1 by C2,AXIOMS:21;
            2*0+1 < n by C1,C3,AXIOMS:22; then
            1+2 <= n by tODD01;
            hence n = len W by B2,C1,AXIOMS:21;
        end;
        hence W is Path-like by B3, dPLWALK; end;
    end;
    hence thesis;
end;

registration let G be _Graph;
  cluster Path-like -> Trail-like Walk of G;
  correctness by dPLWALK;
  cluster trivial -> Path-like Walk of G;
  correctness proof
    let W be Walk of G; assume
A1: W is trivial; then
    len W = 1 by lTVWALK02; then
    2*len W.edgeSeq() + 1 = 0+1 by dWESEQ; then
    2*len W.edgeSeq() = 0 by XCMPLX_1:2; then
    len W.edgeSeq() = 0 by XCMPLX_1:6; then
    W.edgeSeq() is one-to-one by FINSEQ_1:25; then
A2: W is Trail-like by dTLWALK;
    now let m,n be odd Nat; assume
    B1: m < n & n <= len W & W.m = W.n; then
        1 <= m & 1 <= n & n <= 1 by A1,lTVWALK02,HEYTING3:1;
        hence m = 1 & n = len W by B1,AXIOMS:21;
    end;
    hence thesis by A2, dPLWALK;
  end;
  cluster trivial -> vertex-distinct Walk of G;
  coherence proof
    let W be Walk of G; assume
A1: W is trivial;
    now let m,n be odd Nat; assume m <= len W & n <= len W & W.m = W.n; then
        m <= 1 & n <= 1 & 1 <= m & 1 <= n by A1,lTVWALK02,HEYTING3:1; then
        m = 1 & n = 1 by AXIOMS:21;
        hence m = n;
    end;
    hence W is vertex-distinct by dVDWALK;
  end;
  cluster vertex-distinct -> Path-like Walk of G;
  coherence proof
    let W be Walk of G; assume W is vertex-distinct; then
    for m,n being odd Nat st m <= len W & n <= len W & W.m = W.n
      holds m = n by dVDWALK;
    hence W is Path-like by lPLWALK02;
  end;    
  cluster Circuit-like -> closed Trail-like non trivial Walk of G;
  correctness by dCIWALK;
  cluster Cycle-like -> closed Path-like non trivial Walk of G;
  correctness by dCYWALK;
end;  

registration let G be _Graph;
  cluster closed directed trivial Walk of G;
  existence proof
    consider v being Vertex of G;
    take G.walkOf(v);
    thus thesis by lWALKOFV;
  end;
end;

registration let G be _Graph;
  cluster vertex-distinct Walk of G;
  existence proof
    consider W being trivial Walk of G;
    take W;
    thus thesis;
  end;
end;

definition let G be _Graph;
  mode Trail of G is Trail-like Walk of G;
  mode Path  of G is Path-like  Walk of G;
end;

definition let G be _Graph;
  mode DWalk  of G is directed Walk of G;
  mode DTrail of G is directed Trail of G;
  mode DPath  of G is directed Path of G;
end;

registration let G be _Graph, v be Vertex of G;
  cluster G.walkOf(v) -> closed directed trivial;
  coherence by lWALKOFV;
end;

registration let G be _Graph, x,e,y be set;
  cluster G.walkOf(x,e,y) -> Path-like;
  coherence proof
    set W = G.walkOf(x,e,y);
    now per cases;
    suppose e Joins x,y,G;
        hence thesis by lPLWALK; end;
    suppose not e Joins x,y,G; then
        W = G.walkOf(choose the_Vertices_of G) by dWALKOFE;
        hence thesis; end;
    end;
    hence thesis;
  end;
end;

registration let G be _Graph, x,e be set;
  cluster G.walkOf(x,e,x) -> closed;
  coherence proof
    set W = G.walkOf(x,e,x);  
    now per cases;
    suppose e Joins x,x,G; then
        W.first() = x & W.last() = x by lWALKOFE02;
        hence W is closed by dCLWALK; end;
    suppose not e Joins x,x,G; then
        W = G.walkOf(choose the_Vertices_of G) by dWALKOFE;
        hence thesis; end;
    end;
    hence thesis;
  end;
end;    

registration let G be _Graph, W be closed Walk of G;
  cluster W.reverse() -> closed;
  coherence proof
    W is closed iff W.first() = W.last() by dCLWALK; then
    W is closed iff W.reverse().last() = W.last() by lWREV02; then
    W is closed iff W.reverse().last() = W.reverse().first() by lWREV02;
    hence thesis by dCLWALK;
  end;
end;

registration let G be _Graph, W be trivial Walk of G;
  cluster W.reverse() -> trivial;
  coherence proof  
    len W = 1 by lTVWALK02; then
    len W.reverse() = 1 by lWREV01;
    hence thesis by lTVWALK02;
  end;
end;  

registration let G be _Graph, W be Trail of G;
  cluster W.reverse() -> Trail-like;
  coherence by lTLWALK03;
end;

registration let G be _Graph, W be Path of G;
  cluster W.reverse() -> Path-like;
  coherence by lPLWALK04;
end;

registration let G be _Graph, W1,W2 be closed Walk of G;
  cluster W1.append(W2) -> closed;
  coherence proof 
    set W = W1.append(W2);
    now per cases;
    suppose
    B1: W1.last() = W2.first(); then
        W1.last() = W2.last() by dCLWALK; then
        W1.first() = W2.last() by dCLWALK
                  .= W.last() by B1,lWAPPND03; then
        W.first() = W.last() by B1, lWAPPND03;
        hence thesis by dCLWALK; end;
    suppose W1.last() <> W2.first();
        hence thesis by dWAPPND; end;
    end;
    hence thesis;
  end;
end;

registration let G be _Graph, W1,W2 be DWalk of G;
  cluster W1.append(W2) -> directed;
  coherence proof
    set W = W1.append(W2);
    now per cases;
    suppose
    B1: W1.last() = W2.first();
        now let n be odd Nat; assume
        C1: n < len W;
            1 <= n by HEYTING3:1; then
        C2: n in dom W by C1, FINSEQ_3:27;
            now per cases by C2, lWAPPND07;
            suppose
            D1: n in dom W1; then
            D2: W.n = W1.n by lWAPPND05;
            D3: 1 <= n & n <= len W1 by D1, FINSEQ_3:27;
                now per cases by D3, REAL_1:def 5;
                  suppose
                E1: n < len W1; then
                    n+1 in dom W1 & n+2 in dom W1 by lWALK07; then
                    W.(n+1) = W1.(n+1) & W.(n+2) = W1.(n+2) by lWAPPND05;
                    hence W.(n+1) DJoins W.n, W.(n+2), G by D2,E1,lDIWALK01;
                  end;
                  suppose
                E1: n = len W1; then
                E2: 0 < len W2 & n = len W1 + 0 by NAT_1:18;
                    n + 1 < len W + 1 by C1, REAL_1:67; then
                E4: 1 + n < len W2 + n by B1,E1,lWAPPND01; then
                    1 <= len W2 by REAL_1:53; then
                E5: 1 < len W2 & n+1 = len W1 + 1 by E1,E4,REAL_1:def 5; then
                E6: W.(n+1) = W2.(1+1) by B1,lWAPPND06;
                    1+1 <= len W2 by E5,NAT_1:38; then
                    2*1 < len W2 & n+2 = len W1+2 by E1,REAL_1:def 5; then
                E8: W.(n+2) = W2.(2+1) by B1, lWAPPND06;
                    W2.(2*0+1+1) DJoins W2.(2*0+1), W2.(2*0+1+2), G
                      by E5,lDIWALK01;
                    hence W.(n+1) DJoins W.n, W.(n+2), G
                      by E2,E6,E8,B1,lWAPPND06;
                  end;
                end;
                hence W.(n+1) DJoins W.n, W.(n+2), G; end;
              suppose ex k being Nat st k < len W2 & n = len W1 + k; then
                consider k being Nat such that
            D1: k < len W2 & n = len W1 + k;
                now assume k is odd; then
                    reconsider k' = k as odd Nat;
                    n = len W1 + k' by D1;
                    hence contradiction;
                end; then reconsider k as even Nat;
            D2: W.n = W2.(k+1) by B1, D1, lWAPPND06;
                n + 1 < len W + 1 by C1, REAL_1:67; then
                1 + (k + len W1) < len W2 + len W1
                  by D1,B1,lWAPPND01; then
            DZ: k + 1 + len W1 - len W1 < len W2 + len W1 - len W1
                  by REAL_1:92;
                k + 1 + 1 <= len W2 by DZ,NAT_1:38; then
            D4: k + 1 + 1 < len W2 by REAL_1:def 5;
            D6: n + 1 + 1 = len W1 + ((k + 1) + 1) by D1;
            D7: W.(n+1) = W2.(k+1+1) by B1,DZ,D1,lWAPPND06;
                W2.(k+1+(1+1)) = W2.(k+1+1+1)
                              .= W.(n+1+1) by B1,D4,D6,lWAPPND06
                              .= W.(n+(1+1));
                hence W.(n+1) DJoins W.n, W.(n+2), G by D2,DZ,D7,lDIWALK01;
              end;
            end;
            hence W.(n+1) DJoins W.n, W.(n+2), G;
        end;
        hence thesis by lDIWALK01; end;
    suppose W1.last() <> W2.first();
        hence thesis by dWAPPND; end;
    end;
    hence thesis;
  end;
end;

registration let G be _Graph, W1,W2 be trivial Walk of G;
  cluster W1.append(W2) -> trivial;
  coherence proof
    set W = W1.append(W2);
    now per cases;
    suppose W1.last() = W2.first(); then
        len W + 1 = len W1 + len W2 by lWAPPND01
                 .= len W1 + 1 by lTVWALK02
                 .= 1 + 1 by lTVWALK02; then
        len W = 1 by XCMPLX_1:2;
        hence thesis by lTVWALK02; end;
    suppose W1.last() <> W2.first();
        hence thesis by dWAPPND; end;
    end;
    hence thesis;
  end;
end;  

registration let G be _Graph, W be DWalk of G, m,n be Nat;
  cluster W.cut(m,n) -> directed;
  coherence by lDIWALK03;
end;

registration let G be _Graph, W be trivial Walk of G, m,n be Nat;
  cluster W.cut(m,n) -> trivial;
  coherence proof
    set W2 = W.cut(m,n);
    now per cases;
    suppose
    B1: m is odd & n is odd & m <= n & n <= len W; then
    B2: len W2 + m = n + 1 by lWCUT01;
    B3: 1 <= m & 1 <= n & n <= 1 by B1, lTVWALK02, HEYTING3:1; then
        n = 1 by AXIOMS:21; then
        len W2 + 1 = 1 + 1 by B1,B2,B3,AXIOMS:21; then
        len W2 = 1 by XCMPLX_1:2;
        hence thesis by lTVWALK02; end;
    suppose not (m is odd & n is odd & m <= n & n <= len W);
        hence thesis by dWCUT; end;
    end;
    hence thesis;
  end;
end;  
  
registration let G be _Graph, W be Trail of G, m,n be Nat;
  cluster W.cut(m,n) -> Trail-like;
  coherence by lTLWALK04;
end;

registration let G be _Graph, W be Path of G, m,n be Nat;
  cluster W.cut(m,n) -> Path-like;
  coherence by lPLWALK05;
end;

registration let G be _Graph, W be vertex-distinct Walk of G, m,n be Nat;
  cluster W.cut(m,n) -> vertex-distinct;
  coherence proof
    set W2 = W.cut(m,n);
    now per cases;
      suppose
    B1: m is odd & n is odd & m <= n & n <= len W; then
        reconsider m' = m as odd Nat;
        now let a,b be odd Nat; assume
        C1: a <= len W2 & b <= len W2 & W2.a = W2.b;
            1 <= a & 1 <= b by HEYTING3:1; then
            reconsider a_1 = a-1, b_1 = b-1 as even Nat by INT_1:18;
            a_1 < len W2 - 0 & b_1 < len W2 - 0 by C1,REAL_1:92; then
        C3: W2.(a_1+1) = W.(m+a_1) & m+a_1 in dom W &
              W2.(b_1+1) = W.(m+b_1) & m+b_1 in dom W by B1,lWCUT01; then
            m'+a_1 <= len W & m' + b_1 <= len W by FINSEQ_3:27; then
            a_1+m' = b_1 + m' by C3,C1,dVDWALK; then
            a_1 = b_1 by XCMPLX_1:2;
            hence a = b by XCMPLX_1:19;
        end;
        hence thesis by dVDWALK;
      end;
      suppose not (m is odd & n is odd & m <= n & n <= len W);
        hence thesis by dWCUT;
      end;
    end;
    hence thesis;
  end;
end;  

registration let G be _Graph, W be closed Walk of G, m,n be Nat;
  cluster W.remove(m,n) -> closed;
  coherence proof
    thus W.remove(m,n).first() = W.first() by lWREMOVE11
                              .= W.last() by dCLWALK
                              .= W.remove(m,n).last() by lWREMOVE11;
  end;
end;  

registration let G be _Graph, W be DWalk of G, m,n be Nat;
  cluster W.remove(m,n) -> directed;
  coherence proof
    now per cases;
      suppose m is odd & n is odd & m <= n & n <= len W & W.m = W.n; then
        W.remove(m,n) = W.cut(1,m).append(W.cut(n,len W)) by dWREMOVE;
        hence thesis;
      end;
      suppose not (m is odd & n is odd & m <= n & n <= len W & W.m = W.n);
        hence thesis by dWREMOVE;
      end;
    end;
    hence thesis;
  end;
end;  

registration let G be _Graph, W be trivial Walk of G, m,n be Nat;
  cluster W.remove(m,n) -> trivial;
  coherence proof
    now per cases;
      suppose m is odd & n is odd & m <= n & n <= len W & W.m = W.n; then
        W.remove(m,n) = W.cut(1,m).append(W.cut(n,len W)) by dWREMOVE;
        hence thesis;
      end;
      suppose not (m is odd & n is odd & m <= n & n <= len W & W.m = W.n); 
        hence thesis by dWREMOVE;
      end;
    end;
    hence thesis;
  end;
end;

registration let G be _Graph, W be Trail of G, m,n be Nat;
  cluster W.remove(m,n) -> Trail-like;
  coherence proof
    set W2 = W.remove(m,n);
A1: len W2 <= len W by lWREMOVE03;    
    now per cases;
    suppose
    B1: m is odd & n is odd & m <= n & n <= len W & W.m = W.n; then
        reconsider m'=m, n'=n as odd Nat;
        now given a,b being even Nat such that
        C1: 1 <= a & a < b & b <= len W2 & W2.a = W2.b;
            1 <= b & a <= len W2 by C1,AXIOMS:22; then
        C3: a in dom W2 & b in dom W2 by C1,FINSEQ_3:27;
            now per cases by B1,C3,lWREMOVE12;
            suppose a in Seg m; then
            D1: W2.a = W.a by B1,lWREMOVE06;
                now per cases by B1,C3,lWREMOVE12;
                suppose b in Seg m; then
                E1: W2.b = W.b by B1,lWREMOVE06;
                    b <= len W by A1,C1,AXIOMS:22;
                    hence contradiction by C1,D1,E1,lTLWALK01; end;
                suppose
                E0: m <= b & b <= len W2; then
                    reconsider b2 = b-m'+n' as even Nat by B1,lWREMOVE07;
                E2: W2.b = W.b2 & b2 <= len W by E0,B1,lWREMOVE07;
                    now per cases;
                    suppose a < b2;
                        hence contradiction by C1,D1,E2,lTLWALK01; end;
                    suppose b2 <= a; then
                    F1:(n-m)+b-b <= a-b by REAL_1:92;
                        n-m >= m-m by B1,REAL_1:92; then
                    F2: 0 <= a-b by F1;
                        a-b < b-b by C1,REAL_1:92;
                        hence contradiction by F2; end;
                    end;
                    hence contradiction; end;
                end;
                hence contradiction; end;
            suppose
            D1: m <= a & a <= len W2;
                reconsider a2 = a-m'+n' as even Nat by D1,B1,lWREMOVE07;
                reconsider n_m = n'-m' as even Nat by B1, INT_1:18;
            D4: W2.a = W.a2 & a2 <= len W by D1,B1,lWREMOVE07;
                now per cases by B1,C3,lWREMOVE12;
                  suppose b in Seg m; then
                    b <= m by FINSEQ_1:3;
                    hence contradiction by D1,C1,AXIOMS:22;
                  end;
                  suppose
                E0: m <= b & b <= len W2; 
                    reconsider b2 = b-m'+n' as even Nat by E0,B1,lWREMOVE07;
                E3: W2.b = W.b2 & b2 <= len W by E0,B1,lWREMOVE07;
                    now per cases;
                      suppose
                    F1: a2 < b2;
                        1 <= m' by HEYTING3:1; then
                        1 <= a by D1, AXIOMS:22; then
                        1 <= a+n_m by NAT_1:37;
                        hence contradiction by C1,D4,E3,F1,lTLWALK01;
                      end;
                      suppose b2 <= a2; then
                        b + n_m <= a + n_m;
                        hence contradiction by C1,REAL_1:53;
                      end;
                    end;
                    hence contradiction; end;
                end;
                hence contradiction; end;
            end; 
            hence contradiction;
        end;
        hence thesis by lTLWALK01; end;
    suppose not (m is odd & n is odd & m <= n & n <= len W & W.m = W.n);
        hence thesis by dWREMOVE; end;
    end;
    hence thesis;
  end;
end;

registration let G be _Graph, W be Path of G, m,n be Nat;
  cluster W.remove(m,n) -> Path-like;
  coherence proof
    set W2 = W.remove(m,n);
A1: len W2 <= len W by lWREMOVE03;    
    now per cases;
    suppose
    B1: m is odd & n is odd & m <= n & n <= len W & W.m = W.n;
        reconsider m'=m, n'=n as odd Nat by B1;
        now let x,y be odd Nat; assume
        C1: x < y & y <= len W2 & W2.x = W2.y; then
        C2: 1 <= x & 1 <= y & x <= len W2 by HEYTING3:1, AXIOMS:22; then
        C3: x in dom W2 & y in dom W2 by C1, FINSEQ_3:27;
        C4: x <= len W & y <= len W by C1, C2, A1, AXIOMS:22;
            now per cases by B1,C3,lWREMOVE12;
            suppose x in Seg m; then
            D2: W2.x = W.x by B1,lWREMOVE06;
                now per cases by B1,C3,lWREMOVE12;
                  suppose y in Seg m; then
                    W2.y = W.y by B1,lWREMOVE06; then
                    x = 1 & y = len W by C1,C4,D2,dPLWALK;
                    hence x = 1 & y = len W2 by A1,C1,AXIOMS:21;
                  end;
                  suppose
                E0: m <= y & y <= len W2; then
                E1: W2.y = W.(y-m+n) & y-m+n is Nat & y-m+n <= len W
                      by B1,lWREMOVE07;
                    reconsider y2 = y-m'+n' as odd Nat by E0,B1,lWREMOVE07;
                    y-m + n >= y-m+m by B1,REAL_1:55; then
                E3: x < y2 & y2 <= len W by C1,E0,B1,lWREMOVE07,AXIOMS:22; then
                    x = 1 & y2 = len W by C1,D2,E1,dPLWALK; then
                    len W2 + n = y -m + n + m by B1,lWREMOVE01
                              .= y + n;
                    hence x = 1 & y = len W2
                      by C1,D2,E1,E3,dPLWALK,XCMPLX_1:2;
                  end;
                end;
                hence x = 1 & y = len W2; end;
            suppose
            D1: m <= x & x <= len W2; then
            D2: W2.x = W.(x-m+n) & x-m+n is Nat & x-m+n <= len W
                  by B1,lWREMOVE07;
                reconsider x2 = x-m'+n' as odd Nat by D1,B1,lWREMOVE07;
                now per cases by B1,C3,lWREMOVE12;
                  suppose y in Seg m; then
                    y <= m by FINSEQ_1:3;
                    hence x = 1 & y = len W2 by C1,D1,AXIOMS:22;
                  end;
                  suppose
                E0: m <= y & y <= len W2; then
                E1: W2.y = W.(y-m+n) & y-m+n is Nat & y-m+n <= len W
                      by B1,lWREMOVE07;
                    reconsider y2 = y-m'+n' as odd Nat by E0,B1,lWREMOVE07;
                    x + (n - m) < y + (n-m) by C1, REAL_1:67; then
                E2: x2 < y2; then
                EZ: x2 = 1 & y2 = len W by C1,D2,E1,dPLWALK; then
                EY: len W2 + n = y -m + n + m by B1,lWREMOVE01
                              .= y + n; 
                    reconsider x_m = x-m as Nat by D1, INT_1:18;
                    1 <= n' by HEYTING3:1; then
                    x2 - n' <= 1-1 by EZ,REAL_1:92; then
                E5: x_m = 0 by NAT_1:18; then
                E6: x = m by XCMPLX_1:15;
                E7: m <= 1 by B1,E2,C1,D2,E1,dPLWALK,E5;
                    1 <= m' by HEYTING3:1;
                    hence x = 1 & y = len W2
                      by EY,XCMPLX_1:2,E6,E7,AXIOMS:21; end;
                end;
                hence x = 1 & y = len W2; end;
            end;
            hence x = 1 & y = len W2;
        end;
        hence thesis by dPLWALK; end;
    suppose not (m is odd & n is odd & m <= n & n <= len W & W.m = W.n);
        hence thesis by dWREMOVE; end;
    end;
    hence thesis;
  end;
end;
  
definition let G be _Graph, W be Walk of G; 
  mode Subwalk of W -> Walk of G means :dSUBWALK: ::dSUBWALK
    it is_Walk_from W.first(), W.last() &
    ex es being FinSubsequence of W.edgeSeq() st
      it.edgeSeq() = Seq es;
  existence proof
   take W;
   thus W is_Walk_from W.first(), W.last() by dWALKFROM;
::   reconsider fs = W.edgeSeq() as FinSubsequence;
   reconsider es = W.edgeSeq() as FinSubsequence of W.edgeSeq()
     by GRAPH_2:def 5;
   take es;
   thus W.edgeSeq() = Seq es by GRAPH_2:24;
  end;
end;

lSUBWALK01:
  for G being _Graph, W being Walk of G holds W is Subwalk of W proof
    let G be _Graph, W be Walk of G;
A1: W is_Walk_from W.first(),W.last() by dWALKFROM;
::    reconsider fs = W.edgeSeq() as FinSubsequence;
    reconsider es = W.edgeSeq() as FinSubsequence of W.edgeSeq()
      by GRAPH_2:def 5;
    W.edgeSeq() = Seq es by GRAPH_2:24;
    hence thesis by A1, dSUBWALK;   
end;  

lSUBWALK02:
  for G be _Graph, W1 be Walk of G, W2 be Subwalk of W1, W3 be Subwalk of W2
    holds W3 is Subwalk of W1 proof
    let G be _Graph, W1 be Walk of G, W2 be Subwalk of W1, W3 be Subwalk of W2;
    set fs  = W1.edgeSeq(),fs1 = W2.edgeSeq(),fs2 = W3.edgeSeq();
A1: W3 is_Walk_from W2.first(), W2.last() &
      ex fss1 being FinSubsequence of fs1 st fs2 = Seq fss1 by dSUBWALK;
    W2 is_Walk_from W1.first(), W1.last() &
      ex fss being FinSubsequence of fs st fs1 = Seq fss by dSUBWALK; then
A3: W2.first() = W1.first() & W2.last() = W1.last() by dWALKFROM;
    consider fss1 being FinSubsequence of fs1 such that
A4: fs2 = Seq fss1 by dSUBWALK;
    consider fss being FinSubsequence of fs such that
A5: fs1 = Seq fss by dSUBWALK;
    set fss2 = fss | rng((Sgm dom fss)|dom fss1);
    reconsider fss2 as FinSubsequence of fs by GRAPH_2:29;
    fs2 = Seq fss2 by A4, A5, GRAPH_2:30;

    hence W3 is Subwalk of W1 by A1,A3,dSUBWALK;
end;    

lSUBWALK05:
  for G be _Graph, W1,W2 be Walk of G holds
    W1 is Subwalk of W2 implies
      len W1 <= len W2 proof
    let G be _Graph, W1,W2 be Walk of G; assume W1 is Subwalk of W2; then   
    consider es being FinSubsequence of W2.edgeSeq() such that
A1: W1.edgeSeq() = Seq es by dSUBWALK;
    len W1.edgeSeq() <= len W2.edgeSeq() by A1, tFINSUBSEQ01; then
    2*len W1.edgeSeq() <= 2*len W2.edgeSeq() by AXIOMS:25; then
    2*len W1.edgeSeq()+1 <= 2*len W2.edgeSeq() + 1 by REAL_1:55; then
    len W1 <= 2*len W2.edgeSeq() + 1 by dWESEQ;
    hence thesis by dWESEQ;
end;  

definition let G be _Graph, W be Walk of G, m,n being Nat;
  redefine func W.remove(m,n) -> Subwalk of W; 
  coherence proof 
    set W2 = W.remove(m,n), es1 = W2.edgeSeq();
    now per cases;
    suppose
    B1: m is odd & n is odd & m <= n & n <= len W & W.m = W.n;  then
        reconsider m'=m, n'=n as odd Nat;
        W is_Walk_from W.first(), W.last() by dWALKFROM; then
    B2: W2 is_Walk_from W.first(), W.last() by lWREMOVE02;
        1 <= m by B1, HEYTING3:1; then
        reconsider m_1 = m'-1 as even Nat by INT_1:18;
        reconsider lenW_n = len W - n' as even Nat by B1, INT_1:18;
        reconsider n1 = n'+1 as even Nat;
        1 <= len W by HEYTING3:1; then
        reconsider lenW_1 = len W - 1 as even Nat by INT_1:18;
    BZ: 2 divides m_1 & 2 divides lenW_n & 2 divides lenW_1 & 2 divides n1
          by PEPIN:22; then
    B5: m_1 = 2 * (m_1 div 2) & lenW_n = 2 * (lenW_n div 2) &
          lenW_1 = 2 * (lenW_1 div 2) & n1 = 2 * (n1 div 2) by NAT_1:49;
        set X = {x where x is Nat : 1 <= x & x <= m_1 div 2};
        set Y = {x where x is Nat : n1 div 2 <= x & x <= lenW_1 div 2};
        set Z = X \/ Y, es = W.edgeSeq() | Z;
        now let x be set; assume
        C1: x in Z;
            now per cases by C1,XBOOLE_0:def 2;
            suppose x in X; then consider y being Element of NAT such that
            D1: y = x & 1 <= y & y <= m_1 div 2;
            D2: 1 <= y+y by D1, NAT_1:37;
                2*y <= m_1 by B5,D1,AXIOMS:25; then
                2*y <= m_1+1 by NAT_1:37; then
                2*y <= n by B1, AXIOMS:22; then
                2*y <= len W by B1, AXIOMS:22; then
                2*y in dom W by D2, FINSEQ_3:27;
                hence x in dom W.edgeSeq() by D1, lWESEQ02; end;
            suppose x in Y; then consider y being Element of NAT such that
            D1: y = x & n1 div 2 <= y & y <= lenW_1 div 2; 
::                2 * (n1 div 2) <= 2 * y by D1, AXIOMS:25; then
            D2: n1 <= 2*y by B5, D1,AXIOMS:25;
                1 <= n1 by NAT_1:37; then
            D3: 1 <= 2*y by D2, AXIOMS:22;
                2*y <= lenW_1 by B5,D1,AXIOMS:25; then
                2*y <= lenW_1+1 by NAT_1:37; then
                2*y in dom W by D3, FINSEQ_3:27; 
                hence x in dom W.edgeSeq() by D1, lWESEQ02; end;
            end;
            hence x in dom W.edgeSeq();
        end; then
    B6: Z c= dom W.edgeSeq() by TARSKI:def 3; then
    BA: dom W.edgeSeq() /\ Z = Z by XBOOLE_1:28; then
    B7: dom es = Z by RELAT_1:90;
    B8: Z c= Seg len W.edgeSeq() by B6, FINSEQ_1:def 3; then
    B9: X c= Seg len W.edgeSeq() & Y c= Seg len W.edgeSeq() by XBOOLE_1:11;
        reconsider Z as finite set by B6, FINSET_1:13;
        reconsider X,Y as finite set by B9, FINSET_1:13;
    BB: now let a,b be Nat; assume
        C1: a in X & b in Y; then
            consider a' being Element of NAT such that
        C2: a'=a & 1 <= a' & a' <= m_1 div 2;
            consider b' being Element of NAT such that
        C3: b'=b & n1 div 2 <= b' & b' <= lenW_1 div 2 by C1;
            2*a' <= m_1 by B5,C2,AXIOMS:25; then
            2*a' < m_1+1 by NAT_1:38; then
            2*a' < n by B1, AXIOMS:22; then
        C4: 2*a'+0 < n+1 by REAL_1:67;
        C5: n+1 <= 2*b' by B5,C3,AXIOMS:25; then
            2*a' < 2*b' by C4, AXIOMS:22; then
            a' <= b' by tREAL01;
            hence a < b by C2,C3,C5,C4,REAL_1:def 5;
        end;
        W.edgeSeq() is FinSubsequence of W.edgeSeq() by GRAPH_2:28; then
        reconsider es as FinSubsequence of W.edgeSeq() by GRAPH_2:29;
    BC: len W2 = 2*len W2.edgeSeq()+1 by dWESEQ;
    BD: Seg len es1 = dom es1 by FINSEQ_1:def 3;
        set es2 = Seq es;
    BE: es2 = es * Sgm(dom es) by FINSEQ_1:def 14;
        dom es c= Seg len W.edgeSeq() by BA,RELAT_1:90,B8; then
        rng Sgm(dom es) = dom es by FINSEQ_1:def 13; then
    BG: dom es2 = dom Sgm(Z) by BE, B7, RELAT_1:46
               .= Seg card Z by B8, FINSEQ_3:45;
        len W + m - n = 2*len es1 + 1 by BC,B1,lWREMOVE08; then
        m + len W + -n = 2*len es1 + 1 by XCMPLX_0:def 8; then
    BI: 2 * len es1 = m + len W + -n + -1
                   .= m - 1 + len W - n;
    BJ: now per cases;
          suppose
        C1: m_1 div 2 = 0;
            now assume X <> {}; then consider x being set such that
            D1: x in X by XBOOLE_0:def 1; 
                consider x' being Element of NAT such that
            D2: x' = x & 1 <= x' & x' <= m_1 div 2 by D1;
                thus contradiction by D2,C1;
            end;
            hence card X = m_1 div 2 by C1, CARD_2:19;
          end;
          suppose m_1 div 2 <> 0; then consider k being Nat such that
        C1: m_1 div 2 = k + 1 by NAT_1:22;
            thus card X = m_1 div 2 by C1,GRAPH_2:4;
          end;
        end;
    BK: now per cases;
          suppose
        C1: n1 div 2 > lenW_1 div 2;
        C2: now assume Y <> {}; then consider x being set such that
            D1: x in Y by XBOOLE_0:def 1;
                consider x' being Nat such that
            D2: x' = x & n1 div 2 <= x' & x' <= lenW_1 div 2 by D1;
                thus contradiction by C1,D2,AXIOMS:22; 
            end;
            lenW_1 < n+1 by B5,C1,REAL_1:70; then
            lenW_1 + 1 <= n+1 by NAT_1:38; then
            len W <= n'+1; then
            len W < n+1 by REAL_1:def 5; then
            len W <= n by NAT_1:38; then
            len W = n by B1, AXIOMS:21; then
            lenW_n div 2 = 0 by NAT_2:4;
            hence card Y = lenW_n div 2 by C2,CARD_2:19;
          end;
        suppose n1 div 2 <= lenW_1 div 2; then
            reconsider k = (lenW_1 div 2) - (n1 div 2) as Nat by INT_1:18;
            Y = {x where x is Nat: n1 div 2 <= x & x <= n1 div 2 + k}; then
            card Y = k+1 by GRAPH_2:4; then
            2 * card Y = 2*(lenW_1 div 2) - 2*(n1 div 2) + 2*1
                      .= lenW_n by B5; then
            lenW_n = 2 * card Y + 0 & 0 < 2;
            hence card Y = lenW_n div 2 by NAT_1:def 1;
          end;
        end;
        now assume not X /\ Y = {}; then consider x being set such that
        C1: x in X /\ Y by XBOOLE_0:def 1;
        C2: x in X & x in Y by C1, XBOOLE_0:def 3; then
            consider x' being Nat such that
        C3: x' = x & 1 <= x' & x' <= m_1 div 2;
            consider y' being Nat such that
        C4: y' = x & n1 div 2 <= y' & y' <= lenW_1 div 2 by C2;
            2*x' <= m_1 by B5,C3,AXIOMS:25; then
            2*y' < m_1+1 by C3,C4,NAT_1:38; then
            2*y' < n by B1,AXIOMS:22; then
            2*y'+0 < n+1 by REAL_1:67; 
            hence contradiction by B5,C4,AXIOMS:25;
        end; then
    BL: X misses Y by XBOOLE_0:def 7;
        card Z = (m_1 div 2) + (lenW_n div 2) by BJ, BK,BL,CARD_2:53; then
        card Z * 2 = 2 * (m_1 div 2) + 2 * (lenW_n div 2)
                  .= 2 * len es1 by B5,BI; then
    BM: dom es1 = dom es2 by BD,BG,XCMPLX_1:5;
    BN: dom Sgm X = Seg (m_1 div 2) by B9, BJ, FINSEQ_3:45;
    BO: dom Sgm Y = Seg (lenW_n div 2) by B9, BK, FINSEQ_3:45;
    BP: X = {x where x is Nat : 0+1 <= x & x <= 0+(m_1 div 2)};
        now assume n1 div 2 < 1; then
            2*(n1 div 2) < 2*1 by REAL_1:70; then
            n + 1 - 1 < 2 - 1 by B5,REAL_1:92; then
            n' < 1;
            hence contradiction by HEYTING3:1;
        end; then reconsider n1div2_1 = (n1 div 2) - 1 as Nat by INT_1:18;
        set lenY = lenW_1 div 2 - n1div2_1;
        now assume n1div2_1 > lenW_1 div 2; then
            2*n1div2_1 > 2 * (lenW_1 div 2) by REAL_1:70; then
            n1 - 2*1 > lenW_1 by B5, XCMPLX_1:40; then
        C1: n+1 - 1 - 1 > len W - 1; then
            n+1 - 1 >= len W by REAL_1:54;
            hence contradiction by B1,C1,REAL_1:def 5;
        end; then reconsider lenY as Nat by INT_1:18;
    BT: Y = {x where x is Nat: n1div2_1+1 <= x & x <= n1div2_1+lenY};
    BU: len (Sgm X) = m_1 div 2 by BN, FINSEQ_1:def 3;
        2*lenY =  2*(lenW_1 div 2) - 2*(n1 div 2) + 2
              .= lenW_n by B5; then
        lenW_n = 2 * lenY + 0 & 0 < 2; then
    BW: lenY = lenW_n div 2 by NAT_1:def 1;
        now let x' be set; assume
        C1: x' in dom es1; then reconsider x = x' as Nat;
        C2: 1 <= x & x <= len es1 by C1, FINSEQ_3:27; then
        C3: es1.x = W2.(2*x) by dWESEQ;
            now per cases;
              suppose
            D1: 2*x+1 <= m; then
            D2: 2*x+1-1 < m - 0 by REAL_1:92;
                1 <= x+x by C2, NAT_1:37; then
                2*x in Seg m by D2, FINSEQ_1:3; then
            D3: es1.x' = W.(2*x) by B1, C3, lWREMOVE06;
            D4: Sgm(Z).x = (Sgm(X) ^ Sgm(Y)).x by BB,B9,FINSEQ_3:48;
                2*x+1-1 <= m_1 by D1, REAL_1:92; then
            D6: x <= m_1 div 2 by B5,REAL_1:70; then
                x in dom Sgm X by BN,C2,FINSEQ_1:3; then
                Sgm(Z).x = Sgm(X).x by D4, FINSEQ_1:def 7
                        .= 0+x by BP,GRAPH_2:5,C2, D6; then
            D8: es2.x = es.x by B7,BE,BM,C1,FUNCT_1:22;
                x in X by C2, D6; then
            D9: x in dom es by B7, XBOOLE_0:def 2; then
            DA: es2.x = W.edgeSeq().x by D8, FUNCT_1:70;
                x <= len W.edgeSeq() by B7,B8,D9,FINSEQ_1:3;
                hence es1.x' = es2.x' by C2,DA,D3,dWESEQ;
              end;
              suppose
            D1: 2*x+1 > m; then
            D2: m <= 2*x by NAT_1:38;
                2*x <= 2*len es1 by C2, AXIOMS:25; then
                2*x <= 2*len es1 + 1 by NAT_1:37; then
            DZ: 2*x <= len W2 by dWESEQ; then
            D3: es1.x' = W.(2*x-m+n) & 2*x-m+n is Nat & 2*x-m+n <= len W
                  by B1, C3, D2, lWREMOVE07;
            D4: Sgm(Z).x = (Sgm(X) ^ Sgm(Y)).x by BB,B9,FINSEQ_3:48;
            D5: now assume x <= m_1 div 2; then
                    2*x <= m_1 by B5,AXIOMS:25; then
                    2*x+1 <= m_1+1 by REAL_1:55;
                    hence contradiction by D1;
                end; then consider k being Nat such that
            D6: x = m_1 div 2 + k by NAT_1:28;
                k <> 0 by D6,D5; then
                0 < k by NAT_1:19; then
                0+1 < k+1 by REAL_1:67; then
            D7: 1 <= k by NAT_1:38;
            D9: now assume lenW_n div 2 < x - (m_1 div 2); then
                    2 * (lenW_n div 2) < 2*(x - (m_1 div 2)) by REAL_1:70; then
                    lenW_n < 2*x - m_1 by B5, XCMPLX_1:40; then
                E1: lenW_n + n < 2*x - m + 1 + n by REAL_1:67;
                    set z = 2*x-m'+n';
                    reconsider z as Nat by B1,D2,DZ,lWREMOVE07;
                    2*x-m'+n' < len W by D3, REAL_1:def 5; then
                    z+1 <= len W by NAT_1:38;
                    hence contradiction by E1;
                end; then
                k in dom Sgm(Y) by BO,D6,D7,FINSEQ_1:3; then
                Sgm(Z).x = Sgm(Y).k by BU, D4, D6, FINSEQ_1:def 7
                        .= n1div2_1 + k by D6,D7, D9, BT, GRAPH_2:5,BW; then
            DA: es2.x = es.(n1div2_1 + k) by B7,BE,BM,C1,FUNCT_1:22;
            DB: 1 <= n1div2_1+k by D7, NAT_1:37;
            DC: n1div2_1 + 1 <= n1div2_1 + k by D7, REAL_1:55;
            DD: now assume lenW_1 div 2 < k + n1div2_1; then
                    lenW_1 < 2*(x - (m_1 div 2) + n1div2_1)
                      by B5,D6,REAL_1:70; then
                    lenW_1 < 2*(x- (m_1 div 2)) + 2*(n1div2_1); then
                    lenW_1 < (2*x - m_1) + 2*(n1div2_1) by B5,XCMPLX_1:40; then
                    lenW_1 < 2*x - m_1 + (n1 - 2*1) by B5, XCMPLX_1:40; then
                E1: lenW_1 + 1 < 2*x-m+n+1 by REAL_1:67;
                    reconsider z = 2*x-m'+n' as Nat by DZ,B1,D2,lWREMOVE07;
                    len W <= z by E1, NAT_1:38;
                    hence contradiction by D3,REAL_1:def 5;
                end; then
                n1div2_1 + k in Y by DC; then
                n1div2_1+k in dom es by B7,XBOOLE_0:def 2; then
            DE: es.(n1div2_1+k) = W.edgeSeq().(n1div2_1+k) by FUNCT_1:70;
                consider lenW_1' being even Nat such that
            DF: lenW_1' = lenW_1 & len W.edgeSeq() = lenW_1' div 2
                  by lWESEQ04;
            DG: es2.x = W.(2*(n1div2_1+k)) by DA,DB,DD,DE,DF,dWESEQ;
                2*(n1div2_1 + k) = 2*(n1 div 2) - 2*1 + 2*k
                                .= n1-2+(2*x-2*(m_1 div 2)) by D6,BZ,NAT_1:49
                                .= 2*x - m + n by B5;
                hence es1.x' = es2.x' by DZ,B1,C3,D2,lWREMOVE07,DG; end;
            end;
            hence es1.x' = es2.x';
        end; then
        W2.edgeSeq() = Seq es by BM, FUNCT_1:9;
        hence W.remove(m,n) is Subwalk of W by B2, dSUBWALK; end;
    suppose not (m is odd & n is odd & m <= n & n <= len W & W.m = W.n); then
        W.remove(m,n) = W by dWREMOVE;
        hence thesis by lSUBWALK01; end;
    end;
    hence thesis;
  end;
end;  

registration let G be _Graph, W be Walk of G;
  cluster Trail-like Path-like Subwalk of W;
  existence proof 
    defpred P1[Nat,set,set] means
      ($2 is Walk of G & ex Wn being Walk of G st Wn = $2 &
      $3 = Wn.remove(Wn.find(2*$1+1),Wn.rfind(2*$1+1))) or
      (not $2 is Walk of G & $3 = $2);
A1: now let n be Nat, x be set;
        now per cases;
        suppose x is Walk of G; then reconsider W = x as Walk of G;
            set y = W.remove(W.find(2*n+1),W.rfind(2*n+1));
            P1[n,x,y];
            hence ex y being set st P1[n,x,y]; end;
        suppose not x is Walk of G;
            hence ex y being set st P1[n,x,y]; end;
        end;
        hence ex y being set st P1[n,x,y];
    end;
A2: for n being Nat, x,y1,y2 being set st P1[n,x,y1] & P1[n,x,y2] holds y1=y2;
    consider f being Function such that
A3: dom f = NAT & f.0 = W & 
    for n being Element of NAT holds P1[n,f.n,f.(n+1)]
      from RECDEF_1:sch 1(A1,A2);
    defpred P2[Nat] means f.$1 is Subwalk of W;
A4: P2[0] by A3, lSUBWALK01;
    now let n be Nat; assume
    B1: f.n is Subwalk of W; then consider Wn being Walk of G such that
    B2: Wn = f.n &
        f.(n+1) = Wn.remove(Wn.find(2*n+1),Wn.rfind(2*n+1)) by A3;
        thus f.(n+1) is Subwalk of W by B1, B2, lSUBWALK02;
    end; then
A5: for n being Nat st P2[n] holds P2[n+1];
    for n being Nat holds P2[n] from NAT_1:sch 1(A4,A5); then
    reconsider W0 = f.0 as Subwalk of W;
    defpred P3[Nat] means
      ex Wn being Subwalk of W st Wn = f.$1 & len Wn <= len W &
      for m being odd Nat st m < 2*$1+1 &  m <= len Wn
        holds Wn.rfind(m) = m;
    for m being odd Nat st m < 2*0+1 & m <= len W0 holds W0.rfind(m) = m
      by HEYTING3:1; then
A7: P3[0] by A3;
    now let n be Nat; assume P3[n]; then
        consider Wn being Subwalk of W such that
    B2: Wn = f.n & len Wn <= len W &
          for m being odd Nat st m < 2*n+1 & m <= len Wn
          holds Wn.rfind(m) = m;
        set a = Wn.find(2*n+1), b = Wn.rfind(2*n+1);
        set Wn1 = Wn.remove(a,b);
        reconsider Wn1 as Subwalk of W by lSUBWALK02;
        take Wn1;
        P1[n,f.n,f.(n+1)] by A3;
        hence f.(n+1) = Wn1 by B2;
        len Wn1 <= len Wn by lWREMOVE03;
        hence len Wn1 <= len W by B2, AXIOMS:22;
        let m be odd Nat; set m' = Wn1.rfind(m); assume
    B5: m < 2*(n+1)+1 & m <= len Wn1; then
        m <= 2*(n+1) by NAT_1:38; then
        m < 2*n+1+1 by REAL_1:def 5; then
    B6: m <= 2*n+1 by NAT_1:38;
    B7: len Wn1 <= len Wn by lWREMOVE03; then
    B8: m <= len Wn by B5, AXIOMS:22;
        set W1 = Wn.cut(1,a), W2 = Wn.cut(b, len Wn);
        now per cases;
          suppose
        C1: 2*n+1 <= len Wn; then
        C2: a <= len Wn & Wn.a = Wn.(2*n+1) & for k being odd Nat st
              k <= len Wn & Wn.k = Wn.(2*n+1) holds a <= k by dWFINDN;
        C3: b <= len Wn & Wn.b = Wn.(2*n+1) & for k being odd Nat st
              k <= len Wn & Wn.k = Wn.(2*n+1) holds k <= b by C1, dWRFINDN;
        C4: a <= 2*n+1 & 2*n+1 <= b by C1, lWFINDN01, lWRFINDN01; then
        CZ: a <= b by AXIOMS:22; then
        C5: Wn1 = W1.append(W2) by C2,C3,dWREMOVE;
        CY: now assume
            D1: a < 2*n+1; then
                a <= len Wn by C1, AXIOMS:22; then
                Wn.rfind(a) = a by D1, B2;
                hence contradiction by C1, C2, D1, dWRFINDN;
            end; then
        C6: a = 2*n+1 by C4, AXIOMS:21;
        C7: 1 is odd & 1 <= a & 1 <= m by JORDAN12:3, HEYTING3:1;
        C8: W1.last() = Wn.(2*n+1) by C2, C7, lWCUT02
                     .= W2.first() by C3, lWCUT02;
            set m' = Wn1.rfind(m);
        C9: m' >= m by B5, lWRFINDN01;
        CA: m' <= len Wn1 & Wn1.m' = Wn1.m & for k being odd Nat st
              k <= len Wn1 & Wn1.k = Wn1.m holds k <= m' by B5, dWRFINDN; then
        CB: m' <= len Wn by B7, AXIOMS:22;
            now per cases by B6, AXIOMS:21;
              suppose
            D1: m < 2*n+1; then
            D2: Wn.rfind(m) = m by B2, B8;
                m < len Wn.cut(1,a) by C1, C6, D1, lWCUT10; then
            D5: Wn1.cut(1,m) = Wn.cut(1,a).cut(1,m) by C5, C7, C8, lWCUT09
                            .= Wn.cut(1,m) by B6, C6, lWCUT08;
                reconsider m_1 = m - 1 as Nat by C7, INT_1:18;
            D6: m_1 + 1 = m;
            D7: m_1 < m - 0 by REAL_1:92; then
                m_1 < len Wn1.cut(1,m) by B5, lWCUT10; then
            D8: Wn1.m = Wn.cut(1,m).m by D5,D6,C7,B5,lWCUT01;
                m_1 < len Wn.cut(1,m) by B8, D7, lWCUT10; then
            D9: Wn1.m = Wn.m by B8, C7,D6,D8,lWCUT01;
                now per cases;
                  suppose
                E1: m' < a; then
                E2: m' < len Wn.cut(1,a) by C2, lWCUT10; 
                E3: 1 <= m' by HEYTING3:1; then
                E4: Wn1.cut(1,m') = Wn.cut(1,a).cut(1,m')
                                     by C5,JORDAN12:3,C8,E2,lWCUT09
                                 .= Wn.cut(1,m') by E1, lWCUT08;
                    reconsider m'_1 = m' - 1 as Nat by E3, INT_1:18;
                E6: m'_1 < m' - 0 by REAL_1:92; then
                    m'_1 < len Wn1.cut(1,m') by CA, lWCUT10; then
                E7: Wn1.m' = Wn.cut(1,m').(m'_1+1)
                      by E4,JORDAN12:3,CA,E3,lWCUT01;
                    m'_1 < len Wn.cut(1,m') by E6, CB, lWCUT10; then
                    Wn.m' = Wn.m
                      by CA,JORDAN12:3,CB,D9,E3,E7,lWCUT01; then
                    m' <= m by D2,B8,dWRFINDN,CB;
                    hence Wn1.rfind(m) = m by C9, AXIOMS:21;
                  end;
                  suppose
                E1: a <= m'; set x = m' - a + b;
                E2: Wn1.m' = Wn.x & x is Nat & x <= len Wn
                      by CZ, C2, C3, CA, E1, lWREMOVE07;
                    reconsider x as Nat by CZ,C2,C3,CA,E1,lWREMOVE07;
                E3: x <= m by D2,B8,dWRFINDN,E2,CA,D9;
                    m' + a <= m' + b by CZ, REAL_1:55; then
                    m' + a - a <= m' + b - a by REAL_1:92; then
                    m' <= m by E3, AXIOMS:22;
                    hence Wn1.rfind(m) = m by C9, AXIOMS:21;
                  end;                    
                end;
                hence Wn1.rfind(m) = m;
              end;
              suppose
            D1: m = 2*n+1; then
                m <= len Wn.cut(1,a) by C1,C6,lWCUT10; then
            D3: Wn1.cut(1,m) = Wn.cut(1,a).cut(1,m) by C5, C7, C8, lWCUT09
                            .= Wn.cut(1,m) by B6, C6, lWCUT08;
                reconsider m_1 = m - 1 as Nat by C7, INT_1:18;
            D4: m_1 + 1 = m;
            D5: m_1 < m - 0 by REAL_1:92; then
                m_1 < len Wn1.cut(1,m) by B5, lWCUT10; then
            D6: Wn1.m = Wn.cut(1,m).m by D3,C7,B5,D4,lWCUT01;
                m_1 < len Wn.cut(1,m) by B8, D5, lWCUT10; then
            D7: Wn1.m = Wn.m by B8, C7,D4,D6,lWCUT01;
                now assume
                E1: m < m'; then
                E2: a < m' by CY,C4,AXIOMS:21,D1; set x = m' - a + b;
                    Wn1.m' = Wn.x & x is Nat & x <= len Wn
                      by CZ, C2, C3, CA, E2, lWREMOVE07; then
                    m' - a + b <= b by D1,D7,C1,dWRFINDN,CA; then
                    m' - a + b - b <= b - b by REAL_1:92; then
                    m' - a + a <= 0 + a by REAL_1:55;
                    hence contradiction by E1,CY,C4,AXIOMS:21,D1;
                end;
                hence Wn1.rfind(m) = m by C9, AXIOMS:21; end;
            end;
            hence Wn1.rfind(m) = m; end;
        suppose
        C1: len Wn < 2*n+1; then
            a = len Wn & b = len Wn by dWFINDN, dWRFINDN; then
        C2: Wn1 = Wn by lWREMOVE04;
            m < 2*n+1 by B8, C1, AXIOMS:22;
            hence Wn1.rfind(m) = m by C2,B2,B5; end;
        end;
        hence Wn1.rfind(m) = m;
    end; then
A8: for n being Nat st P3[n] holds P3[n+1];
A9: for n being Nat holds P3[n] from NAT_1:sch 1(A7,A8);
    set n = len W + 1;
    consider P being Subwalk of W such that
AB: P = f.n & len P <= len W &
    for m being odd Nat st m < 2*n+1 & m <= len P
      holds P.rfind(m) = m by A9;
    take P;
    now let m be odd Nat; assume
    B1: m <= len P;
    B2: len P + 0 < n by AB, REAL_1:67;
        0 <= n by NAT_1:18; then
        len P + 0 < n+n by B2, REAL_1:67; then
        len P + 0 < 2*n+1 by REAL_1:67; then
        m < 2*n+1 by B1, AXIOMS:22;
        hence P.rfind(m) = m by AB, B1;
    end; then       
    P is Path-like by lPLWALK09;
    hence P is Trail-like & P is Path-like by dPLWALK;
  end;
end;

definition let G be _Graph, W be Walk of G;
   mode Trail of W is Trail-like Subwalk of W;
   mode Path of W is Path-like Subwalk of W;
end;

registration let G be _Graph, W be DWalk of G;
  cluster directed Path of W;
  existence proof
    defpred P[Nat] means
      for W1 being DWalk of G st W1.length() = $1 holds
       ex W2 being Path of W1 st W2 is directed;
    now let W1 be DWalk of G; assume W1.length() = 0; then
    B1: len W1 = 2*0+1 by lWLENGTH01;
        consider W2 being Path of W1;
        take W2;
    B2: len W2 <= 1 by B1, lSUBWALK05;
        1 <= len W2 by HEYTING3:1; then
        len W2 = 1 by B2, AXIOMS:21; then
        W2 is trivial by lTVWALK02; then
        consider v being Vertex of G such that
    B3: W2 = G.walkOf(v) by lTVWALK04;
        thus W2 is directed by B3;
    end; then
A1: P[0];
    now let k be Nat; assume
    B1: P[k];
        let W1 be DWalk of G; assume
    B2: W1.length() = k + 1; then
    B3: len W1 = 2*(k+1)+1 by lWLENGTH01
              .= 2*k+1+2; then
    B4: 2*k+1+2-2 < len W1 - 0 by REAL_1:92;
        set WA = W1.cut(1,2*k+1);
        len WA = 2*k+1 by B4, lWCUT10; then
        2*k+1 = 2*WA.length()+1 by lWLENGTH01; then
        2*k = 2*WA.length() by XCMPLX_1:2; then
    BZ: WA.length() = k by XCMPLX_1:5; then
        consider WB being Path of WA such that
    B5: WB is directed by B1;
        set e = W1.(2*k+1+1), v = W1.(2*k+1+2);
    B6: e DJoins W1.(2*k+1), v, G by B4, lDIWALK01;
    B7: WB is_Walk_from WA.first(), WA.last() by dSUBWALK;
        1 is odd & 1 <= 2*k+1 by JORDAN12:3, NAT_1:37; then
    B9: WA.first() = W1.1 & WA.last() = W1.(2*k+1) by B4, lWCUT02; then
    BA: WB.first() = W1.1 & WB.last() = W1.(2*k+1) by B7, dWALKFROM; then
    BB: e Joins WB.last(), v, G by B6, GLIB_000:19;
    BC: WA.edgeSeq() c= W1.edgeSeq() by lWESEQ05;
        now per cases;
          suppose WB is closed; then
            W1.1 = W1.(2*k+1) by BA, dCLWALK; then
        C1: W1.first() = W1.(2*k+1) by dWFIRST;
            set W2 = W1.remove(1,2*k+1);
            W2 = W1.cut(2*k+1, 2*k+1+2) by B3, C1, lWREMOVE10; then
            len W2 + (2*k+1) = 2*k+1+2+1 by B3,B4,lWCUT01
                            .= 2*k+1+(2+1); then
            len W2 = 3 by XCMPLX_1:2; then
            reconsider W2 as Path of W1 by lPLWALK01;
            take W2;
            thus W2 is directed;
          end;
          suppose
        C1: WB is open;
            consider esb being FinSubsequence of WA.edgeSeq() such that
        C2: WB.edgeSeq() = Seq esb by dSUBWALK;
        C3: esb c= WA.edgeSeq() by GRAPH_2:def 5;
        CZ: now let x be set; assume
                x in dom esb; then
                [x,esb.x] in esb by FUNCT_1:8; then
                x in dom WA.edgeSeq() by FUNCT_1:8,C3; then
                x in Seg len WA.edgeSeq() by FINSEQ_1:def 3;
                hence x in Seg k by BZ, dWLENGTH;
            end; then
        C4: dom esb c= Seg k by TARSKI:def 3;
        C5: Seq esb = esb * (Sgm (dom esb)) by FINSEQ_1:def 14;
        C6: Seq esb is one-to-one by C2, dTLWALK; 
            rng Sgm(dom esb) = dom esb by C4, FINSEQ_1:def 13; then
        C8: esb is one-to-one & Sgm(dom esb) is one-to-one by C5,C6,FUNCT_1:48;
            now per cases;
              suppose v in WB.vertices(); then
                consider n being odd Nat such that
            D1: n <= len WB & WB.n = v by lWVERTICES01;
                reconsider WB' = WB as directed Path of G by B5;
                set W2 = WB'.cut(1,n);
                2*0+1 <= n by HEYTING3:1; then
                W2 is_Walk_from WB.1, v by D1,lWCUT02; then
                W2 is_Walk_from W1.1, v by dWFIRST, BA; then
                W2 is_Walk_from W1.1, W1.last() by B3, dWLAST; then
            D3: W2 is_Walk_from W1.first(), W1.last() by dWFIRST;
                len W2 = n by D1, lWCUT10; then
                consider n_1 being even Nat such that
            D5: n_1 = n - 1 & len W2.edgeSeq() = n_1 div 2 by lWESEQ04;
                set es = esb | (rng (Sgm (dom esb) | Seg (n_1 div 2)));
                reconsider es as FinSubsequence of WA.edgeSeq() by GRAPH_2:29;
            D6: es c= WA.edgeSeq() by GRAPH_2:def 5;
                for x being set st x in es holds x in W1.edgeSeq()
                  by BC, D6, TARSKI:def 3; then
                es c= W1.edgeSeq() by TARSKI:def 3; then
                reconsider es as FinSubsequence of W1.edgeSeq()
                  by GRAPH_2:def 5;
            D8: W2.edgeSeq() c= WB.edgeSeq() by lWESEQ05;
            D9: Seq es = es * Sgm (dom es) by FINSEQ_1:def 14;
            DB: es c= esb by RELAT_1:88;
                now let z be set;
                    hereby assume
                    F1: z in esb;
                        now per cases;
                        suppose z in es; 
                            hence z in es \/ (esb \ es) by XBOOLE_0:def 2; end;
                        suppose not z in es; then
                            z in esb \ es by F1, XBOOLE_0:def 4;
                            hence z in es \/ (esb \ es) by XBOOLE_0:def 2; end;
                        end;
                        hence z in es \/ (esb \ es);
                    end;
                    assume
                E1: z in es \/ (esb \ es);
                    now per cases by E1, XBOOLE_0:def 2;
                    suppose z in es;
                       hence z in esb by DB; end;
                    suppose z in esb \ es;
                       hence z in esb; end;
                    end;
                    hence z in esb;
                end; then
                esb = es \/ (esb \ es) by TARSKI:2; then
            DD: dom esb = dom es \/ dom (esb \ es) by RELAT_1:13;
                dom (esb \ es) c= dom esb by RELAT_1:25; then
            DE: dom (esb \ es) c= Seg k by C4, XBOOLE_1:1;
                dom es c= dom esb by DB, RELAT_1:25; then
            DG: dom es c= Seg k by C4, XBOOLE_1:1;
                now let z be set; assume
                E1: z in rng (Sgm (dom esb) | Seg (n_1 div 2));
                    rng (Sgm (dom esb) | Seg (n_1 div 2)) c= rng Sgm (dom esb)
                      by RELAT_1:99; then
                    z in rng Sgm (dom esb) by E1;
                    hence z in dom esb by C4, FINSEQ_1:def 13;
                end; then
                rng (Sgm (dom esb) | Seg (n_1 div 2)) c= dom esb
                  by TARSKI:def 3; then
            DI: dom es = rng (Sgm (dom esb) | Seg (n_1 div 2)) by RELAT_1:91;
                2 divides n_1 by PEPIN:22; then
            DK: 2*(n_1 div 2) = n_1 by NAT_1:49;
            DL: dom Sgm(dom esb) = dom WB.edgeSeq() by C2, tFINSUBSEQ04
                                .= Seg len WB.edgeSeq() by FINSEQ_1:def 3;
                now assume n_1 div 2 > len WB.edgeSeq(); then
                    n_1 > 2 * len WB.edgeSeq() by DK,REAL_1:70; then
                    n_1+1 > 2*len WB.edgeSeq() + 1 by REAL_1:67;
                    hence contradiction by D1,D5,dWESEQ;
                end; then
                Seg (n_1 div 2) c= dom Sgm (dom esb) by DL, FINSEQ_1:7; then
            DO: dom (Sgm(dom esb)| Seg(n_1 div 2)) = Seg (n_1 div 2)
                  by RELAT_1:91; then
                reconsider ses = Sgm(dom esb)|Seg(n_1 div 2) as FinSequence
                  by FINSEQ_1:def 2;
            DP: len ses = n_1 div 2 by DO, FINSEQ_1:def 3;
                ses is one-to-one by C8,FUNCT_1:84; then
                card dom es = n_1 div 2 by DI,DP,FINSEQ_4:77; then
                card es = n_1 div 2 by tCARD01; then
            DR: len Seq es = len W2.edgeSeq() by D5,tFINSUBSEQ03;
                for x,y1,y2 being set st [x,y1] in esb\es & [x,y2] in esb\es
                  holds y1 = y2 by FUNCT_1:def 1; then
                reconsider esb_es = esb \ es as Function by FUNCT_1:def 1;
                now let a,b be Nat; assume
                E1: a in dom es & b in dom (esb_es); then
                    consider xa being set such that
                E2: xa in dom ses & ses.xa = a by DI, FUNCT_1:def 5;
                    reconsider xa as Nat by E2;
                E3: a = Sgm(dom esb).xa by E2, FUNCT_1:70;
                E4: xa in Seg(n_1 div 2) & xa in dom Sgm(dom esb)
                      by E2, RELAT_1:86;
                E5: [b, (esb_es).b] in esb \ es by E1, FUNCT_1:8; then
                    b in dom esb by FUNCT_1:8; then
                    b in rng (Sgm (dom esb)) by C4, FINSEQ_1:def 13; then
                    consider xb being set such that
                E6: xb in dom (Sgm (dom esb)) & Sgm(dom esb).xb = b
                      by FUNCT_1:def 5;
                    reconsider xb as Nat by E6;
                E7: 1 <= xa & xa <= n_1 div 2 by E4, FINSEQ_1:3;
                E8: 1 <= xb & xb <= len WB.edgeSeq() by DL,E6,FINSEQ_1:3; then
                    xb in dom Seq esb by C2,FINSEQ_3:27; then
                    xb in dom Sgm (dom esb) by tFINSUBSEQ04; then
                E9: xb <= len Sgm(dom esb) by FINSEQ_3:27;
                    now assume xb <= xa; then
                        xb <= n_1 div 2 by E7, AXIOMS:22; then
                    F1: xb in Seg(n_1 div 2) by E8, FINSEQ_1:3;
                        [xb, b] in Sgm(dom esb) by E6, FUNCT_1:8; then
                        [xb, b] in ses by F1, RELAT_1:def 11; then
                        b in rng ses by RELAT_1:def 5; then
                        [b, (esb_es).b] in es
                          by E5,RELAT_1:def 11;
                        hence contradiction by E5,XBOOLE_0:def 4;
                    end;
                    hence a < b by C4, E3, E6, E7, E9, FINSEQ_1:def 13;
                end; then
            DK: Sgm(dom esb) = Sgm(dom es) ^ Sgm(dom (esb \ es))
                  by DD, DE, DG, FINSEQ_3:48;
            DL: dom W2.edgeSeq() c= dom Seq esb by C2,D8,RELAT_1:25;
                now let x be Nat; assume
                E1: 1 <= x & x <= len W2.edgeSeq(); then
                E2: x in dom W2.edgeSeq() by FINSEQ_3:27; then
                    [x,W2.edgeSeq().x] in W2.edgeSeq() by FUNCT_1:8; then
                E4: W2.edgeSeq().x = (Seq esb).x by C2, FUNCT_1:8,D8
                                  .= esb.(Sgm(dom esb).x)
                                       by C5,E2,DL,FUNCT_1:22;
                E5: x in dom Seq es by DR, E1, FINSEQ_3:27; then
                    x in dom Sgm(dom es) by tFINSUBSEQ04; then
                E7: Sgm(dom esb).x = Sgm(dom es).x by DK, FINSEQ_1:def 7;
                E9: x in dom Sgm(dom esb) & 
                     Sgm(dom esb).x in dom esb by C5,E2,DL,FUNCT_1:21; then
                EA: [Sgm(dom esb).x, esb.(Sgm(dom esb).x)] in esb by FUNCT_1:8;
                EB: x in Seg (n_1 div 2) by E1, FINSEQ_1:3,D5;
                    [x, Sgm(dom esb).x] in Sgm(dom esb) by E9, FUNCT_1:8; then
                    [x, Sgm(dom esb).x] in ses by EB, RELAT_1:def 11; then
                    Sgm(dom esb).x in rng ses by RELAT_1:def 5; then
                    [Sgm(dom esb).x, esb.(Sgm(dom esb).x)] in es
                      by EA, RELAT_1:def 11; then
                    es.(Sgm(dom es).x) = esb.(Sgm(dom esb).x) by E7, FUNCT_1:8;
                    hence W2.edgeSeq().x = (Seq es).x by E4,E5,D9,FUNCT_1:22;
                end; then
                W2.edgeSeq() = Seq es by DR, FINSEQ_1:18; then
                reconsider W2 as Path of W1 by D3, dSUBWALK;
                take W2;
                thus W2 is directed;
              end;
              suppose
            D1: not v in WB.vertices(); set W2 = WB.addEdge(e);
                W2 is directed & W2 is_Walk_from W1.1,v
                  by B5,B6,B7,B9,lDIWALK02; then
                W2 is_Walk_from W1.first(), v by dWFIRST; then
            D4: W2 is_Walk_from W1.first(), W1.last() by B3, dWLAST;
                set es = esb +* ((k+1) .--> e);
            D5: dom ((k+1) .--> e) = {k+1} by CQC_LANG:5; then
            D6: dom es = dom esb \/ {k+1} by FUNCT_4:def 1;
                now let x be set; assume
                E1: x in dom es;
                    now per cases by D6, E1, XBOOLE_0:def 2;
                    suppose x in dom esb; then
                    F1: x in Seg k by CZ; then
                        reconsider x'=x as Nat;
                    F2: 1 <= x' & x' <= k by F1,FINSEQ_1:3; then
                        x' <= k+1 by NAT_1:37;
                        hence x in Seg (k+1) by F2, FINSEQ_1:3; end;
                    suppose x in {k+1}; then
                    F1: x = k+1 by TARSKI:def 1;
                        1 <= k+1 by NAT_1:37;
                        hence x in Seg (k+1) by F1,FINSEQ_1:3; end;
                    end;
                    hence x in Seg (k+1);
                end; then
            D7: dom es c= Seg (k+1) by TARSKI:def 3; then
                reconsider es as FinSubsequence by FINSEQ_1:def 12;
                now let z be set; assume
                E1: z in es; then consider x,y being set such that
                E2: z = [x,y] by RELAT_1:def 1;
                E3: x in dom es & es.x = y by E1, E2, FUNCT_1:8;
                    now per cases;
                    suppose
                    F1: x in dom ((k+1) .--> e); then
                    F2: y = ((k+1).-->e).x by D5,D6,E3,FUNCT_4:def 1;
                    F3: x = k+1 by D5, F1, TARSKI:def 1; then
                    F4: y = e by F2, CQC_LANG:6;
                        reconsider x' = x as Nat by D5,F1;
                    F5: 1 <= x' & x' <= len W1.edgeSeq()
                          by F3, NAT_1:37,B2,dWLENGTH; then
                    F6: x in dom W1.edgeSeq() by FINSEQ_3:27;
                        W1.edgeSeq().x = W1.(2*(k+1)) by F3, F5,dWESEQ
                                      .= W1.(2*k+1+1);
                        hence z in W1.edgeSeq() by E2,F4,F6,FUNCT_1:8;
                      end;
                      suppose
                    F1: not x in dom ((k+1) .--> e); then
                    F2: y = esb.x by D5, D6, E3, FUNCT_4:def 1;
                        x in dom esb by D5, D6, E3, F1, XBOOLE_0:def 2; then
                        [x,y] in esb by F2, FUNCT_1:8; then
                        [x,y] in WA.edgeSeq() by C3;
                        hence z in W1.edgeSeq() by BC,E2;
                     end;
                    end;
                    hence z in W1.edgeSeq(); 
                end; then
                es c= W1.edgeSeq() by TARSKI:def 3; then
                reconsider es as FinSubsequence of W1.edgeSeq()
                  by GRAPH_2:def 5;
                now assume dom esb /\ dom ((k+1).-->e) <> {}; then
                    consider x being set such that
                E1: x in dom esb /\ dom ((k+1).-->e) by XBOOLE_0:def 1;
                E2: x in dom esb & x in {k+1} by D5, E1, XBOOLE_0:def 3; then
                    x = k+1 by TARSKI:def 1; then
                    k+1 <= k+0 by C4,E2,FINSEQ_1:3;
                    hence contradiction by REAL_1:53;
                end; then
            D8: dom esb misses dom ((k+1).-->e) by XBOOLE_0:def 7;
            DA: W2.edgeSeq() = Seq esb ^ <*e*> by BB, C2, lWESEQ06; then
            DB: len W2.edgeSeq() = len Seq esb + len <*e*> by FINSEQ_1:35
                                .= len Seq esb + 1 by FINSEQ_1:56
                                .= card esb + 1 by tFINSUBSEQ03;
            DC: len Seq es = card es by tFINSUBSEQ03
                          .= card esb + card ((k+1).-->e) by D8, AMISTD_2:2
                          .= card esb + card {[k+1,e]} by AMI_1:19
                          .= len W2.edgeSeq() by DB, CARD_1:79;
            DD: {k+1} c= Seg (k+1) by D6,D7,XBOOLE_1:11;
                now let m, n be Nat; assume
                E1: m in dom esb & n in {k+1}; then
                E2: n = k+1 by TARSKI:def 1;
                    m <= k by FINSEQ_1:3,C4,E1;
                    hence m < n by E2, NAT_1:38;
                end; then
            DE: Sgm(dom es)=Sgm(dom esb) ^ Sgm({k+1}) by C4,D6,DD,FINSEQ_3:48
                          .=Sgm(dom esb) ^ <* k+1 *> by FINSEQ_3:50;     
                now let n be Nat; assume
                E1: 1 <= n & n <= len W2.edgeSeq(); then
                E2: n in dom W2.edgeSeq() by FINSEQ_3:27;
                E3: n in dom Seq es by E1, DC, FINSEQ_3:27;
                    Seq es = es * Sgm(dom es) by FINSEQ_1:def 14; then
                E5: (Seq es).n = es.(Sgm(dom es).n) by E3,FUNCT_1:22;
                E6: Seq esb = esb * Sgm(dom esb) by FINSEQ_1:def 14;
                    now per cases by DA, E2, FINSEQ_1:38;
                      suppose
                    F1: n in dom Seq esb; then
                    F2: W2.edgeSeq().n = (Seq esb).n by DA, FINSEQ_1:def 7
                                   .= esb.(Sgm(dom esb).n) by E6,F1,FUNCT_1:22;
                    F3: n in dom Sgm(dom esb) &
                          Sgm(dom esb).n in dom esb by E6,F1,FUNCT_1:21; then
                        Sgm(dom es).n=Sgm(dom esb).n by DE,FINSEQ_1:def 7;
                        hence W2.edgeSeq().n = (Seq es).n
                          by F2,D8,E5,F3,FUNCT_4:17;
                      end;
                      suppose ex m being Nat st m in dom <*e*> &
                      n = len Seq esb + m; then consider m being Nat such that
                    F1: m in dom <*e*> & n = len Seq esb + m;
                        m in {1} by F1,FINSEQ_1:4,FINSEQ_1:def 8; then
                    F2: m = 1 by TARSKI:def 1; then
                    F3: W2.edgeSeq().n = <*e*>.1 by DA, F1, FINSEQ_1:def 7
                                      .= e by FINSEQ_1:def 8;
                        len Sgm(dom esb) = card dom esb by C4, FINSEQ_3:44
                                       .= card esb by tCARD01
                                       .= len Seq esb by tFINSUBSEQ03; then
                    F5: (Seq es).n = es.(k+1) by E5,DE,F1,F2,FINSEQ_1:59;
                    F6: k+1 in dom ((k+1).-->e) by D5, TARSKI:def 1; then
                        k+1 in dom esb \/ dom ((k+1).-->e)
                          by XBOOLE_0:def 2; then
                        (Seq es).n = ((k+1).-->e).(k+1) by F5,F6,FUNCT_4:def 1
                                  .= e by CQC_LANG:6;
                        hence W2.edgeSeq().n = (Seq es).n by F3; end;
                    end;
                    hence W2.edgeSeq().n = (Seq es).n;
                end; then
                W2.edgeSeq() = Seq es by DC, FINSEQ_1:18; then
                reconsider W2 as Path of W1 by D1,BB,C1,lPLWALK07,D4,dSUBWALK;
                take W2;
                thus W2 is directed by B5,B6,B7,B9,lDIWALK02; end;
            end;
            hence ex W2 being Path of W1 st W2 is directed; end;
        end;
        hence ex W2 being Path of W1 st W2 is directed;
    end; then
A2: for k being Nat st P[k] holds P[k+1];
A3: for k being Nat holds P[k] from NAT_1:sch 1(A1,A2);
    W.length() = W.length(); 
    hence thesis by A3;
  end;
end;

definition let G be _Graph, W be DWalk of G;
  mode DWalk of W is directed Subwalk of W;
  mode DTrail of W is directed Trail of W;
  mode DPath of W is directed Path of W;
end;  

definition let G be _Graph;
  func G.allWalks()-> non empty
                      Subset of ((the_Vertices_of G)\/(the_Edges_of G))*
    equals :dGALLWALKS: ::dGALLWALKS
    {W where W is Walk of G : not contradiction};
  coherence proof
    set IT = {W where W is Walk of G : not contradiction};
A1: G.walkOf(choose(the_Vertices_of G)) in IT;
    now let x be set; assume x in IT; then consider W being Walk of G such that
    B1: x = W;
        thus x in ((the_Vertices_of G)\/(the_Edges_of G))*
          by B1, FINSEQ_1:def 11;
    end;
    hence thesis by A1,TARSKI:def 3;
  end;
end;  

definition let G be _Graph;
   func G.allTrails() -> non empty Subset of G.allWalks()
     equals :dGALLTRAILS: ::dGALLTRAILS
     {W where W is Trail of G : not contradiction};
  coherence proof
    set IT = {W where W is Trail of G : not contradiction};
A1: G.walkOf(choose(the_Vertices_of G)) in IT;   
    now let e be set; assume e in IT; then
        consider W being Trail of G such that
    B1: W = e;
        e in {X where X is Walk of G : not contradiction} by B1;
        hence e in G.allWalks() by dGALLWALKS;
    end;
    hence thesis by A1,TARSKI:def 3;
 end;
end;   

definition let G be _Graph;
  func G.allPaths() -> non empty Subset of G.allTrails()
    equals :dGALLPATHS: ::dGALLPATHS
    {W where W is Path of G : not contradiction};
  coherence proof 
    set IT = {W where W is Path of G : not contradiction};
A1: G.walkOf(choose(the_Vertices_of G)) in IT;
    now let e be set; assume e in IT; then
        consider W being Path of G such that
    B1: e = W;
        e in {X where X is Trail of G : not contradiction} by B1;
        hence e in G.allTrails() by dGALLTRAILS;
    end;
    hence thesis by A1,TARSKI:def 3;
  end;
end;

definition let G be _Graph;
  func G.allDWalks() -> non empty Subset of G.allWalks()
    equals :dGALLDWALKS: ::dGALLDWALKS
    {W where W is DWalk of G : not contradiction};
  coherence proof 
    set IT = {W where W is directed Walk of G : not contradiction};
A1: G.walkOf(choose(the_Vertices_of G)) in IT;
    now let e be set; assume e in IT; then
        consider W being directed Walk of G such that
    B1: e = W;
        e in {X where X is Walk of G : not contradiction} by B1;
        hence e in G.allWalks() by dGALLWALKS;
    end;
    hence thesis by A1,TARSKI:def 3;
  end;
end;

definition let G be _Graph;
  func G.allDTrails() -> non empty Subset of G.allTrails()
    equals :dGALLDTRAILS: ::dGALLDTRAILS
    {W where W is DTrail of G : not contradiction};
  coherence proof 
    set IT = {W where W is DTrail of G : not contradiction};
A1: G.walkOf(choose(the_Vertices_of G)) in IT;    
    now let e be set; assume e in IT; then
        consider W being DTrail of G such that
    B1: e = W;
        e in {X where X is Trail of G : not contradiction} by B1;
        hence e in G.allTrails() by dGALLTRAILS;
    end;
    hence thesis by A1,TARSKI:def 3;
  end;
end;

definition let G be _Graph;
  func G.allDPaths() -> non empty Subset of G.allDTrails()
    equals :dGALLDPATHS: ::dGALLPATHS
    {W where W is directed Path of G : not contradiction};
  coherence proof 
    set IT = {W where W is DPath of G : not contradiction};
A1: G.walkOf(choose(the_Vertices_of G)) in IT;    
    now let e be set; assume e in IT; then
        consider W being DPath of G such that
    B1: e = W;
        e in {X where X is DTrail of G : not contradiction} by B1;
        hence e in G.allDTrails() by dGALLDTRAILS;
    end;
    hence thesis by A1,TARSKI:def 3;
  end;
end;

registration let G be finite _Graph;
  cluster G.allTrails() -> finite;
  correctness proof
    set D = (the_Vertices_of G)\/(the_Edges_of G);
A1: now let W be Trail of G;
        consider f being Function such that
    B1: dom f = W.edgeSeq() & for x being set st x in W.edgeSeq()
          holds f.x = x`2 from FUNCT_1:sch 3;
        now let y be set; assume y in rng f; then
            consider x being set such that
        C2: x in dom f & f.x = y by FUNCT_1:def 5;
        C3: x in W.edgeSeq() & y = x`2 by B1, C2;
            consider a,b being set such that
        C4: x = [a,b] by B1,C2,RELAT_1:def 1;
            y = b by C3, C4, MCART_1:def 2; then
            y in rng W.edgeSeq() by B1,C2,C4,RELAT_1:def 5;
            hence y in (the_Edges_of G);
        end; then
    B2: rng f c= the_Edges_of G by TARSKI:def 3;
        now let x1,x2 be set; assume
        C1: x1 in dom f & x2 in dom f & f.x1 = f.x2; then
        C2: x1 in W.edgeSeq() & f.x1 = x1`2 & x2 in W.edgeSeq() & f.x2 = x2`2
              by B1; consider a1,b1 being set such that
        C3: x1 = [a1,b1] by B1,C1,RELAT_1:def 1;
            consider a2,b2 being set such that
        C4: x2 = [a2,b2] by B1,C1, RELAT_1:def 1;
        C5: b1 = f.x1 by C2,C3,MCART_1:def 2
              .= b2 by C1,C2,C4,MCART_1:def 2;
        C6: W.edgeSeq() is one-to-one by dTLWALK;
        C7: a1 in dom W.edgeSeq() & W.edgeSeq().a1 = b1
              by B1,C1,C3,FUNCT_1:8;
            a2 in dom W.edgeSeq() & W.edgeSeq().a2 = b1
              by B1,C1,C4,C5,FUNCT_1:8;
            hence x1 = x2 by C3, C4, C5,C6,C7,FUNCT_1:def 8;
        end; then
        f is one-to-one by FUNCT_1:def 8; then
        Card W.edgeSeq() <=` Card (the_Edges_of G) by B1,B2,CARD_1:26; then
        len W.edgeSeq() <= card (the_Edges_of G) by CARD_2:57; then
        len W.edgeSeq() <= G.size() by GLIB_000:def 27; then
        2*len W.edgeSeq() <= 2*G.size() by AXIOMS:25; then
        2*len W.edgeSeq()+1 <= 2*G.size()+1 by REAL_1:55;
        hence len W <= 2*G.size()+1 by dWESEQ;
    end;
    set X = {x where x is Element of D* : len x <= 2*G.size()+1};
A2: X is finite by GRAPH_5:4;
    now let e be set; assume e in G.allTrails(); then
        e in {W where W is Trail of G : not contradiction} by dGALLTRAILS;then
        consider W being Trail of G such that
    B1: W = e;
    B2: e is Element of D* by B1, FINSEQ_1:def 11;
        len W <= 2*G.size()+1 by A1;
        hence e in X by B1,B2;
    end; then
    G.allTrails() c= X by TARSKI:def 3;
    hence G.allTrails() is finite by A2, FINSET_1:13;
  end;
end;

definition let G be _Graph, X be non empty Subset of G.allWalks();
  redefine mode Element of X -> Walk of G;
  coherence proof
    let x be Element of X;
    x in G.allWalks(); then
    x in {W where W is Walk of G : not contradiction} by dGALLWALKS; then
    consider y being Walk of G such that
A1: y = x;
    thus thesis by A1;
   end;
end;  
definition let G be _Graph, X be non empty Subset of G.allTrails();
  redefine mode Element of X -> Trail of G;
  coherence proof
    let x be Element of X;
    x in G.allTrails(); then
    x in {W where W is Trail of G : not contradiction} by dGALLTRAILS; then
    consider y being Trail of G such that
A1: y = x;
    thus thesis by A1;
   end;
end;

definition let G be _Graph, X be non empty Subset of G.allPaths();
  redefine mode Element of X -> Path of G;
  coherence proof
    let x be Element of X;
    x in G.allPaths(); then
    x in {W where W is Path of G : not contradiction} by dGALLPATHS; then
    consider y being Path of G such that
A1: y = x;
    thus thesis by A1;  
  end;
end;
definition let G be _Graph, X be non empty Subset of G.allDWalks();
  redefine mode Element of X -> DWalk of G;
  coherence proof
    let x be Element of X;
    x in G.allDWalks(); then
    x in {W where W is DWalk of G : not contradiction} by dGALLDWALKS; then
    consider y being DWalk of G such that
A1: y = x;
    thus thesis by A1;   
  end;
end;

definition let G be _Graph, X be non empty Subset of G.allDTrails();
  redefine mode Element of X -> DTrail of G;
  coherence proof
    let x be Element of X;
    x in G.allDTrails(); then
    x in {W where W is DTrail of G : not contradiction} by dGALLDTRAILS; then
    consider y being DTrail of G such that
A1: y = x;
    thus thesis by A1;     
  end;
end;

definition let G be _Graph, X be non empty Subset of G.allDPaths();
  redefine mode Element of X -> DPath of G;
  coherence proof
    let x be Element of X;
    x in G.allDPaths(); then
    x in {W where W is DPath of G : not contradiction} by dGALLDPATHS; then
    consider y being DPath of G such that
A1: y = x;
    thus thesis by A1;     
  end;
end;

begin :: Theorems

reserve G,G1,G2 for _Graph;
reserve W,W1,W2 for Walk of G;
reserve e,x,y,z for set;
reserve v for Vertex of G;
reserve n,m for Nat;

theorem ::tWALK01
   1 <= len W by HEYTING3:1;

theorem ::tWALK02
  for n being odd Nat st n <= len W holds
    W.n in the_Vertices_of G by lWALK02;

theorem tWALK03: ::tWALK03
  for n being even Nat st n in dom W holds
    W.n in the_Edges_of G proof
    let n be even Nat; assume n in dom W; then
A1: 1 <= n & n <= len W by FINSEQ_3:27; then
    reconsider n_1 = n-1 as odd Nat by INT_1:18;
    n_1 < len W - 0 by A1, REAL_1:92; then
    W.(n_1+1) Joins W.n_1, W.(n_1+2), G by dWALK;
    hence thesis by GLIB_000:def 15;
end;    

theorem ::tWALK04
  for n being even Nat st n in dom W holds
    ex n_1 being odd Nat st
      n_1 = n-1 & n-1 in dom W & n+1 in dom W &
      W.n Joins W.(n_1), W.(n+1),G by lWALK04;

theorem tWALK05: ::tWALK05
  for n being odd Nat st n < len W holds
    W.(n+1) in W.vertexAt(n).edgesInOut() proof
    let n be odd Nat; assume
A1: n < len W; then
A2: W.(n+1) Joins W.n, W.(n+2), G by dWALK;
    W.vertexAt(n) = W.n by A1, dWVAT;
    hence thesis by A2,GLIB_000:65;
end;    

theorem tWALK06: ::tWALK06
  for n being odd Nat st 1 < n & n <= len W holds
     W.(n-1) in W.vertexAt(n).edgesInOut() proof
    let n be odd Nat; assume
A1: 1 < n & n <= len W;
    reconsider n_1 = n-1 as even Nat by A1, INT_1:18;
A2: n - 1 <= len W - 0 by A1, REAL_1:92;
    1+1 <= n by A1, NAT_1:38; then
    1+1-1 <= n-1 by REAL_1:92; then
    n_1 in dom W by A2, FINSEQ_3:27; then
    consider n_2 being odd Nat such that
A3: n_2 = n_1-1 & n_1-1 in dom W & n_1+1 in dom W &
      W.n_1 Joins W.(n_2), W.(n_1+1),G by lWALK04;
    n_2 <= len W by A3, FINSEQ_3:27; then
    W.(n_2) = W.vertexAt(n_2) by dWVAT; then
    W.(n-1) Joins W.vertexAt(n_2), W.vertexAt(n), G by A1,A3,dWVAT; then
    W.(n-1) Joins W.vertexAt(n), W.vertexAt(n_2), G by GLIB_000:17;
    hence thesis by GLIB_000:65;
end;

theorem ::tWALK07
  for n being odd Nat st n < len W holds
     n in dom W & n+1 in dom W & n+2 in dom W proof
    let n be odd Nat; assume
A1: n < len W;
A2: 1 <= n by HEYTING3:1;
A3: 1 <= n+1 & 1 <= n+2 by NAT_1:37;
    n+1 <= len W & n+2 <= len W by A1,NAT_1:38,tODD01;
    hence thesis by A1,A2,A3,FINSEQ_3:27;
end;     

theorem tWALKOFV01: ::tWALKOFV01
  len G.walkOf(v) = 1 &  G.walkOf(v).1 = v &
    G.walkOf(v).first() = v & G.walkOf(v).last() = v &
    G.walkOf(v) is_Walk_from v,v proof
    G.walkOf(v) = <*v*> by dWALKOFV;
    hence A1: len G.walkOf(v) = 1 & G.walkOf(v).1 = v by FINSEQ_1:57;
    hence A2: G.walkOf(v).first() = v by dWFIRST;
    thus G.walkOf(v).last() = v by A1, dWLAST;
    hence G.walkOf(v) is_Walk_from v,v by A2, dWALKFROM;
end;

theorem tWALKOFE01: ::tWALKOFE01
  e Joins x,y,G implies len G.walkOf(x,e,y) = 3 proof
    assume e Joins x,y,G; then
    G.walkOf(x,e,y) = <*x,e,y*> by dWALKOFE;
    hence thesis by FINSEQ_1:62;
end;    

theorem tWALKOFE02: ::tWALKOFE02
  e Joins x,y,G implies
    G.walkOf(x,e,y).first() = x & G.walkOf(x,e,y).last() = y &
    G.walkOf(x,e,y) is_Walk_from x,y proof
    set W = G.walkOf(x,e,y);
    assume e Joins x,y,G; then
    W = <*x,e,y*> by dWALKOFE; then
A1: len W = 3 & W.1 = x & W.2 = e & W.3 = y by FINSEQ_1:62;
    hence
A2: W.first() = x by dWFIRST;
    thus W.last() = y by A1, dWLAST;
    hence W is_Walk_from x, y by A2, dWALKFROM;
end;

theorem tWFIRST01: ::tWFIRST01
  for W1 being Walk of G1, W2 being Walk of G2 st W1 = W2 holds
    W1.first() = W2.first() & W1.last() = W2.last() proof
    let W1 be Walk of G1, W2 be Walk of G2; assume
A1: W1 = W2;
    hence W1.first() = W2.1 by dWFIRST
                    .= W2.first() by dWFIRST;
    thus W1.last() = W2.(len W2) by A1, dWLAST
                  .= W2.last() by dWLAST;
end;    

theorem tWALKFROM01: ::tWALKFROM01
  W is_Walk_from x,y iff W.1 = x & W.(len W) = y proof  
  W is_Walk_from x,y iff W.first() = x & W.last() = y by dWALKFROM;
  hence thesis by dWFIRST, dWLAST;
end;

theorem ::tWALKFROM02
  W is_Walk_from x,y implies x is Vertex of G & y is Vertex of G proof
      assume W is_Walk_from x,y; then
      W.first() = x & W.last() = y by dWALKFROM;
      hence thesis;
end;

theorem ::tWALKFROM03
  for W1 being Walk of G1, W2 being Walk of G2 st W1 = W2 holds
    W1 is_Walk_from x,y iff W2 is_Walk_from x,y proof
    let W1 be Walk of G1, W2 be Walk of G2; assume
A1: W1 = W2;
    W1 is_Walk_from x,y iff W1.first() = x & W1.last() = y by dWALKFROM; then
    W1 is_Walk_from x,y iff W2.first() = x & W2.last() = y by A1,tWFIRST01;
    hence W1 is_Walk_from x,y iff W2 is_Walk_from x,y by dWALKFROM;
end;    

theorem ::tWVAT01
  for W1 being Walk of G1, W2 being Walk of G2 st W1 = W2 holds
    for n being Nat holds W1.vertexAt(n) = W2.vertexAt(n) proof
    let W1 be Walk of G1, W2 be Walk of G2; assume
A1: W1 = W2;
    let n be Nat;
    now per cases;
    suppose
    B1: n is odd & n <= len W1;
        hence W1.vertexAt(n) = W2.n by A1, dWVAT
                            .= W2.vertexAt(n) by A1,B1,dWVAT; end;
    suppose
    B1: not (n is odd & n <= len W1);
        hence W1.vertexAt(n) = W1.first() by dWVAT
                            .= W2.first() by A1,tWFIRST01
                            .= W2.vertexAt(n) by A1,B1,dWVAT; end;
    end;
    hence thesis;
end;

theorem ::tWREV01
  len W = len W.reverse() & dom W = dom W.reverse() &
    rng W = rng W.reverse() by lWREV01;

theorem tWREV02: ::tWREV02
  W.first() = W.reverse().last() & W.last() = W.reverse().first() proof
A1: len W = len W.reverse() by lWREV01;
A2: W.reverse() = Rev W by dWREV;
    thus W.first() = W.1 by dWFIRST
                  .= W.reverse().(len W) by A2,FINSEQ_5:65
                  .= W.reverse().last() by A1, dWLAST;
    thus W.last() = W.(len W) by dWLAST
                .= W.reverse().1 by A2,FINSEQ_5:65
                .= W.reverse().first() by dWFIRST;
end;  

theorem tWREV03: ::tWREV03
  W is_Walk_from x,y iff W.reverse() is_Walk_from y, x proof
A1: len W = len W.reverse() by lWREV01;
A2: W.reverse() = Rev W by dWREV;
    hereby assume W is_Walk_from x, y; then
        W.1 = x & W.(len W) = y by tWALKFROM01; then
        W.reverse().1 = y & W.reverse().(len W) = x by A2,FINSEQ_5:65;
        hence W.reverse() is_Walk_from y,x by A1, tWALKFROM01;
    end;
    assume W.reverse() is_Walk_from y,x; then
    W.reverse().1=y & W.reverse().(len W.reverse())=x by tWALKFROM01; then
    W.1 = x & W.(len W) = y by A1,A2,FINSEQ_5:65;
    hence W is_Walk_from x,y by tWALKFROM01;
end;

theorem tWREV04: ::tWREV04
  n in dom W implies W.n = W.reverse().(len W - n + 1) &
    (len W - n + 1) in dom W.reverse() proof
    set rn = len W - n + 1;
A0: W.reverse() = Rev W by dWREV; assume
A1: n in dom W; then
    n <= len W by FINSEQ_3:27; then
    reconsider rn as Nat by FINSEQ_5:1;
    n in Seg len W by A1, FINSEQ_1:def 3; then
    len W - n + 1 in Seg len W by FINSEQ_5:2; then
A2: rn in Seg len W.reverse() by A0,FINSEQ_5:def 3; then
    rn in dom W.reverse() by FINSEQ_1:def 3; then
    W.reverse().rn = W.(len W - rn + 1) by A0,FINSEQ_5:def 3;
    hence thesis by A2,FINSEQ_1:def 3;
end;

theorem ::tWREV05
  n in dom W.reverse() implies W.reverse().n = W.(len W - n + 1) &
    (len W - n + 1) in dom W by lWREV05;

theorem ::tWREV06
  W.reverse().reverse() = W by lWREV06;

theorem ::tWREV07
  for W1 being Walk of G1, W2 being Walk of G2 st W1 = W2 holds
    W1.reverse() = W2.reverse() proof
    let W1 be Walk of G1, W2 be Walk of G2; assume
A1: W1 = W2;
    now thus len W1.reverse() = len W1 by lWREV01;
        thus len W2.reverse() = len W1 by A1, lWREV01;
        let n be Nat; assume n in Seg len W1; then
        n in dom W1 & n in dom W2 by A1, FINSEQ_1:def 3; then
    B1: n in dom W1.reverse() & n in dom W2.reverse() by lWREV01;
        hence W1.reverse().n = W1.(len W1 - n + 1)  by lWREV05
                            .= W2.reverse().n by A1,B1, lWREV05;
    end;
    hence W1.reverse() = W2.reverse() by FINSEQ_2:10;
end;    
  
theorem ::tWAPPND01
  W1.last() = W2.first() implies
  len W1.append(W2) + 1 = len W1 + len W2 by lWAPPND01;

theorem ::tWAPPND02
  W1.last() = W2.first() implies
    len W1 <= len W1.append(W2) & len W2 <= len W1.append(W2) by lWAPPND02;

theorem ::tWAPPND03
  W1.last() = W2.first() implies
    W1.append(W2).first() = W1.first() & W1.append(W2).last() = W2.last() &
    W1.append(W2) is_Walk_from W1.first(), W2.last() by lWAPPND03;

theorem tWAPPND04: ::tWAPPND04
  W1 is_Walk_from x,y & W2 is_Walk_from y,z implies
  W1.append(W2) is_Walk_from x,z proof
    assume W1 is_Walk_from x, y & W2 is_Walk_from y,z; then
    W1.first() = x & W1.last() = y & W2.first() = y & W2.last() = z
      by dWALKFROM;
    hence thesis by lWAPPND03;
end;  

theorem ::tWAPPND05
  n in dom W1 implies
    W1.append(W2).n = W1.n & n in dom W1.append(W2) by lWAPPND05;

theorem ::tWAPPND06
  W1.last() = W2.first() implies
  for n being Nat st n < len W2 holds
    W1.append(W2).(len W1 + n) = W2.(n+1) &
    (len W1 + n) in dom W1.append(W2) by lWAPPND06;

theorem ::tWAPPND07
  n in dom W1.append(W2) implies
     n in dom W1 or ex k being Nat st k < len W2 & n = len W1 + k by lWAPPND07;

theorem tWAPPND08: ::tWAPPND08
  for W1A, W1B being Walk of G1, W2A,W2B being Walk of G2
   st W1A = W2A & W1B = W2B holds
    W1A.append(W1B) = W2A.append(W2B) proof
    let W1A, W1B be Walk of G1, W2A, W2B be Walk of G2; assume
A1: W1A = W2A & W1B = W2B;
    now per cases;
    suppose
    B1: W1A.last() = W1B.first(); then
    B2: W2A.last() = W1B.first() by A1, tWFIRST01
                  .= W2B.first() by A1, tWFIRST01;
        thus W1A.append(W1B) = W1A ^' W1B by B1, dWAPPND
                             .= W2A.append(W2B) by A1,B2, dWAPPND; end;
    suppose
    B1: W1A.last() <> W1B.first(); then
        W2A.last() <> W1B.first() by A1, tWFIRST01; then
    B2: W2A.last() <> W2B.first() by A1, tWFIRST01;
        thus W1A.append(W1B) = W2A by A1, B1, dWAPPND
                            .= W2A.append(W2B) by B2, dWAPPND; end;
    end;
    hence thesis;
end;   

theorem ::tWCUT01
  for m,n being odd Nat st m <= n & n <= len W holds
    len W.cut(m,n) + m = n+1 &
    for i being Nat st i < len W.cut(m,n)
        holds W.cut(m,n).(i+1) = W.(m+i) & m+i in dom W by lWCUT01;

theorem ::tWCUT02
  for m, n being odd Nat st m <= n & n <= len W holds
    W.cut(m,n).first() = W.m & W.cut(m,n).last() = W.n &
    W.cut(m,n) is_Walk_from W.m, W.n by lWCUT02;

theorem ::tWCUT03
  for m,n,o being odd Nat st m <= n & n <= o & o <= len W holds
    W.cut(m,n).append(W.cut(n,o)) = W.cut(m,o) by lWCUT03;

theorem ::tWCUT04
  W.cut(1,len W) = W by lWCUT04;

theorem tWCUT05: ::tWCUT05
  for n being odd Nat st n < len W holds
  G.walkOf(W.n, W.(n+1), W.(n+2)) = W.cut(n,n+2) proof
    let n be odd Nat; set v1 = W.n, e = W.(n+1), v2 = W.(n+2); assume
A1: n < len W; then
A2: e Joins v1,v2,G by dWALK; then
A3: G.walkOf(v1,e,v2) = <*v1,e,v2*> by dWALKOFE;
    set W1 = G.walkOf(v1,e,v2), W2 = W.cut(n,n+2);
A4: n <= n+2 & n+2 <= len W by A1, tODD01; then
    len W.cut(n,n+2) + n = 1 + (2+n) by lWCUT01; then
    len W.cut(n,n+2) + n = (1+2) + n; then
A5: len W2 = 3 by XCMPLX_1:2;
A6: len W1 = 3 by A2,tWALKOFE01;
    now let x be Nat; assume
    B1: x in Seg 3; then
    B2: 1 <= x & x <= 3 by FINSEQ_1:3; then
        reconsider x_1 = x-1 as Nat by INT_1:18;
    B3: x_1+1 = x;
        x_1 < 3-0 by B2, REAL_1:92; then
    B4: W2.x = W.(n+x_1) by A4, A5, B3, lWCUT01;
        now per cases by B1, FINSEQ_3:1, ENUMSET1:def 1;
        suppose x = 1;
            hence W1.x = W2.x by A3, B4, FINSEQ_1:62; end;
        suppose x = 2;
            hence W1.x = W2.x by A3, B4, FINSEQ_1:62; end;
        suppose x = 3;
            hence W1.x = W2.x by A3, B4, FINSEQ_1:62; end;        
        end;
        hence W1.x = W2.x;
    end;
    hence thesis by A5, A6, FINSEQ_2:10;
end;  

theorem tWCUT06: ::tWCUT06
  for m,n being odd Nat st m <= n & n < len W holds
    W.cut(m,n).addEdge(W.(n+1)) = W.cut(m,n+2) proof
    let m,n be odd Nat; set W1 = W.cut(m,n); set e = W.(n+1); assume
A1: m <= n & n < len W; then
A2: n <= n+2 & n+2 <= len W by tODD01;
A3: W1.last() = W.n by A1, lWCUT02; then
    e Joins W1.last(), W.(n+2), G by A1, dWALK; then
    e Joins W1.last(), W.vertexAt(n+2), G by A2, dWVAT; then
    W1.last().adj(e) = W.vertexAt(n+2) by GLIB_000:69; then
    W1.last().adj(e) = W.(n+2) by A2, dWVAT; then
    G.walkOf(W1.last(),e,W1.last().adj(e)) = W.cut(n,n+2)
      by A1, A3, tWCUT05; then
    W1.addEdge(e) = W1.append(W.cut(n,n+2)) by dWADDEDGE;
    hence thesis by A1, A2, lWCUT03;
end;

theorem ::tWCUT07
  for n being odd Nat st n <= len W holds
     W.cut(n,n) = <* W.vertexAt(n) *> by lWCUT07;

theorem ::tWCUT08
  m is odd & m <= n implies
    W.cut(1,n).cut(1,m) = W.cut(1,m) by lWCUT08;

theorem ::tWCUT09
  for m,n being odd Nat st m <= n & n <= len W1 & W1.last() = W2.first()
    holds W1.append(W2).cut(m,n) = W1.cut(m,n) by lWCUT09;

theorem ::tWCUT10
  for m being odd Nat st m <= len W holds
     len W.cut(1,m) = m by lWCUT10;

theorem ::tWCUT11
  for m being odd Nat, x being Nat st x in dom W.cut(1,m) & m <= len W holds
     W.cut(1,m).x = W.x  by lWCUT11;

theorem ::tWCUT12
  for m,n being odd Nat, i being Nat
    st m <= n & n <= len W & i in dom W.cut(m,n) holds
      W.cut(m,n).i = W.(m+i-1) & m+i-1 in dom W proof
    let m,n be odd Nat, i be Nat; assume
A1: m <= n & n <= len W & i in dom W.cut(m,n); then
A2: 1 <= i & i <= len W.cut(m,n) by FINSEQ_3:27; then
    reconsider i_1 = i-1 as Nat by INT_1:18;
A3: i_1 < len W.cut(m,n) - 0 by A2, REAL_1:92;
    i_1+1 = i; then
    W.cut(m,n).i = W.(m+i_1) & m+i_1 in dom W by A1,A3,lWCUT01;
    hence thesis;
end;

theorem tWCUT13: ::tWCUT13
  for W1 being Walk of G1, W2 being Walk of G2, m, n being Nat st W1 = W2 holds
    W1.cut(m,n) = W2.cut(m,n) proof
    let W1 be Walk of G1, W2 be Walk of G2, m, n be Nat; assume
A1: W1 = W2;
    now per cases;
    suppose
    B1: m is odd & n is odd & m <= n & n <= len W1;
        hence W1.cut(m,n) = (m,n)-cut W2 by A1, dWCUT
                         .= W2.cut(m,n) by A1, B1, dWCUT; end;
    suppose
    B1: not (m is odd & n is odd & m <= n & n <= len W1);
        hence W1.cut(m,n) = W2 by A1, dWCUT
                         .= W2.cut(m,n) by A1, B1, dWCUT; end;
    end;
    hence thesis;
end;

theorem ::tWREMOVE01
  for m,n being odd Nat st m <= n & n <= len W & W.m = W.n holds
     len W.remove(m,n) + n = len W + m  by lWREMOVE01;

theorem ::tWREMOVE02
   W is_Walk_from x,y implies W.remove(m,n) is_Walk_from x,y by lWREMOVE02;

theorem ::tWREMOVE03
  len W.remove(m,n) <= len W by lWREMOVE03;

theorem ::tWREMOVE04
  W.remove(m,m) = W by lWREMOVE04;

theorem ::tWREMOVE05
  for m,n being odd Nat st m <= n & n <= len W & W.m = W.n holds
     W.cut(1,m).last() = W.cut(n,len W).first() by lWREMOVE05;

theorem ::tWREMOVE06
  for m,n being odd Nat st m <= n & n <= len W & W.m = W.n holds
     (for x being Nat st x in Seg m holds W.remove(m,n).x = W.x) by lWREMOVE06;

theorem ::tWREMOVE07
  for m,n being odd Nat st m <= n & n <= len W & W.m = W.n holds
     (for x being Nat st m <= x & x <= len W.remove(m,n) holds
        W.remove(m,n).x = W.(x - m + n) &
        x - m + n is Nat & x - m + n <= len W) by lWREMOVE07;

theorem ::tWREMOVE08
  for m,n being odd Nat st m <= n & n <= len W & W.m = W.n holds
    len W.remove(m,n) = len W + m - n by lWREMOVE08;

theorem tWREMOVE09: ::tWREMOVE09
   for m being Nat st W.m = W.last() holds
     W.remove(m,len W) = W.cut(1,m) proof
    let m be Nat; assume W.m = W.last(); then
A1: W.m = W.(len W) by dWLAST;    
    now per cases;
    suppose
    B1: m is odd & m <= len W; then
        len W.remove(m,len W) + len W = len W + m by A1, lWREMOVE01; then
    B4: len W.remove(m,len W) = m by XCMPLX_1:2; then
    B5: len W.remove(m,len W) = len W.cut(1,m) by B1, lWCUT10;
        now let k be Nat; assume
        C1: 1 <= k & k <= len W.remove(m, len W); then
        C2: k in dom W.cut(1,m) by B5, FINSEQ_3:27; 
            k in Seg m by B4, C1, FINSEQ_1:3;
            hence W.remove(m,len W).k = W.k by A1, B1, lWREMOVE06
                                     .= W.cut(1,m).k by B1,C2,lWCUT11;
        end;
        hence thesis by B5, FINSEQ_1:18; end;
    suppose
    B1: not (m is odd & m <= len W); then
        W.cut(1,m) = W by dWCUT;
        hence W.remove(m,len W) = W.cut(1,m) by B1, dWREMOVE; end;
    end;
    hence thesis;
end;   

theorem ::tWREMOVE10
  for m being Nat st W.first() = W.m holds
    W.remove(1,m) = W.cut(m, len W) by lWREMOVE10;

theorem ::tWREMOVE11
  W.remove(m,n).first() = W.first() &
    W.remove(m,n).last() = W.last() by lWREMOVE11;

theorem ::tWREMOVE12
 for m,n being odd Nat, x being Nat
  st m <= n & n <= len W & W.m = W.n & x in dom W.remove(m,n) holds
     x in Seg m or (m <= x & x <= len W.remove(m,n)) by lWREMOVE12;

theorem ::tWREMOVE13
  for W1 being Walk of G1, W2 being Walk of G2, m, n being Nat st W1 = W2 holds
    W1.remove(m,n) = W2.remove(m,n) proof
    let W1 be Walk of G1, W2 be Walk of G2, m, n be Nat; assume
A1: W1 = W2;
    now per cases;
    suppose
    B1: (m is odd & n is odd & m <= n & n <= len W1 & W1.m = W1.n); then
    B2: W1.remove(m,n) = W1.cut(1,m).append(W1.cut(n,len W1)) by dWREMOVE;
        W1.cut(1,m) = W2.cut(1,m) & W1.cut(n,len W1) = W2.cut(n,len W2)
          by A1, tWCUT13; then
        W1.remove(m,n) = W2.cut(1,m).append(W2.cut(n,len W2))
          by B2, tWAPPND08;
        hence W1.remove(m,n) = W2.remove(m,n) by A1, B1, dWREMOVE; end;
    suppose
    B1: not (m is odd & n is odd & m <= n & n <= len W1 & W1.m = W1.n);
        hence W1.remove(m,n) = W2 by A1, dWREMOVE
                            .= W2.remove(m,n) by A1, B1, dWREMOVE; end;
    end;
    hence thesis;
end;    

theorem ::tWADDEDGE01
  e Joins W.last(), x, G implies
  W.addEdge(e) = W^<*e,x*> by lWADDEDGE01;

theorem ::tWADDEDGE02
  e Joins W.last(),x,G implies
  W.addEdge(e).first() = W.first() & W.addEdge(e).last() = x &
  W.addEdge(e) is_Walk_from W.first(), x by lWADDEDGE02;

theorem ::tWADDEDGE03
  e Joins W.last(),x,G implies
  len W.addEdge(e) = len W + 2 by lWADDEDGE03;

theorem ::tWADDEDGE04
  e Joins W.last(),x,G implies
  W.addEdge(e).(len W + 1) = e & W.addEdge(e).(len W + 2) = x &
  for n being Nat st n in dom W holds W.addEdge(e).n = W.n by lWADDEDGE04;

theorem ::tWADDEDGE05
  W is_Walk_from x,y & e Joins y,z,G implies
  W.addEdge(e) is_Walk_from x,z  by lWADDEDGE05;

theorem tWVSEQ01: ::tWVSEQ01
  1 <= len W.vertexSeq() proof
    now assume len W.vertexSeq() < 1; then
        len W.vertexSeq() < 0 + 1; then
        len W.vertexSeq() <= 0 by NAT_1:38; then
        len W.vertexSeq() = 0 by NAT_1:18; then
        len W + 1 = 2 * 0 by dWVSEQ;
        hence contradiction;
    end;
    hence thesis;
end;  

theorem tWVSEQ02: ::tWVSEQ02
  for n being odd Nat st n <= len W holds
    2 * ((n+1) div 2) - 1 = n &
    1 <= (n+1) div 2 & (n+1) div 2 <= len W.vertexSeq() proof
    let n be odd Nat; assume
A1: n <= len W; set m = (n+1) div 2;
    2 divides n+1 by PEPIN:22; then
A2: 2 * m = n+1 by NAT_1:49;
    hence 2 * m - 1 = n;
A3: now assume m < 1; then
        m < 0 + 1; then
        m <= 0 by NAT_1:38; then
        m = 0 by NAT_1:18; 
        hence contradiction by A2;
    end;
    hence 1 <= m;
    reconsider m_1 = m-1 as Nat by A3, INT_1:18;
    now assume len W.vertexSeq() < m; then
        len W.vertexSeq() < m_1 + 1; then
        len W.vertexSeq() <= m_1 by NAT_1:38; then
        2 * len W.vertexSeq() <= 2 * m_1 by NAT_1:20; then
        len W + 1 <= (2 * m) - (2 * 1) by dWVSEQ; then
        len W + 1 + 2 <= n + 1 - 2 + 2 by A2, REAL_1:55; then
        len W + 1 + 2 < n + 1 + 1 by NAT_1:38; then
        len W + 3 - 3 < n + 2 - 2 by REAL_1:92;
        hence contradiction by A1;
    end;
    hence m <= len W.vertexSeq();
end;    

theorem ::tWVSEQ03
  G.walkOf(v).vertexSeq() = <*v*> proof
    set VS = G.walkOf(v).vertexSeq();
    len G.walkOf(v) + 1 = 2 * len VS by dWVSEQ; then
    1 + 1 = 2 * len VS by tWALKOFV01; then
A1: len VS = 1 by XCMPLX_1:7; then
    VS.1 = G.walkOf(v).(2*1-1) by dWVSEQ
        .= v by tWALKOFV01;
    hence thesis by A1, FINSEQ_1:57;
end;

theorem tWVSEQ04: ::tWVSEQ04
  e Joins x,y,G implies
    G.walkOf(x,e,y).vertexSeq() = <*x,y*> proof
    set W = G.walkOf(x,e,y); assume e Joins x, y, G; then
A1: W = <*x, e, y*> by dWALKOFE;
    len W + 1 = 2 * len W.vertexSeq() by dWVSEQ; then
    3 + 1 = 2 * len W.vertexSeq() by A1, FINSEQ_1:62; then
    2 * 2 = 2 * len W.vertexSeq(); then
A2: len W.vertexSeq() = 2 by XCMPLX_1:5; then
    W.vertexSeq().1 = W.(2*1-1) & W.vertexSeq().2 = W.(2*2-1) by dWVSEQ; then
    W.vertexSeq().1 = x & W.vertexSeq().2 = y by A1, FINSEQ_1:62;
    hence thesis by A2, FINSEQ_1:61;
end;

theorem ::tWVSEQ05
  W.first() = W.vertexSeq().1 &
  W.last() = W.vertexSeq().(len W.vertexSeq()) proof
    1 <= len W.vertexSeq() by tWVSEQ01; then
A1: W.vertexSeq().1 = W.(2*1-1) &
      W.vertexSeq().(len W.vertexSeq()) = W.(2*len W.vertexSeq()-1) by dWVSEQ;
    hence W.vertexSeq().1 = W.first() by dWFIRST;
    len W + 1 = 2*len W.vertexSeq() by dWVSEQ;
    hence W.vertexSeq().(len W.vertexSeq()) = W.(len W) by A1, XCMPLX_1:26
                                           .= W.last() by dWLAST;
end;

theorem ::tWVSEQ06
  for n being odd Nat st n <= len W holds
    W.vertexAt(n) = W.vertexSeq().((n+1) div 2) proof
    let n be odd Nat; assume
A1: n <= len W; then
A2: W.vertexAt(n) = W.n by dWVAT; set m = (n+1) div 2;
    2 * m - 1 = n & 1 <= m & m <= len W.vertexSeq() by A1, tWVSEQ02;
    hence thesis by A2, dWVSEQ;
end;

theorem tWVSEQ07: ::tWVSEQ07
  n in dom W.vertexSeq() iff (2*n-1 in dom W) proof
    hereby assume n in dom W.vertexSeq(); then
    B1: 1 <= n & n <= len W.vertexSeq() by FINSEQ_3:27; then
        2*n <= 2*len W.vertexSeq() by AXIOMS:25; then
        2*n <= len W + 1 by dWVSEQ; then
    B2: 2*n-1 <= len W + 1 - 1 by REAL_1:92;
        2*1 <= 2*n by B1, AXIOMS:25; then
    B3: 2-1 <= 2*n-1 by REAL_1:92;
        1 <= n+n by B1, NAT_1:37; then
        2*n-1 is Nat by INT_1:18;
        hence 2*n-1 in dom W by B2,B3,FINSEQ_3:27;
    end;
    assume
A0: 2*n-1 in dom W; then
    reconsider 2n_1=2*n-1 as Nat;
    1 <= 2n_1 & 2n_1 <= len W by A0,FINSEQ_3:27; then
A1: 1+1 <= 2*n-1+1 & 2*n-1+1 <= len W+1 by REAL_1:55; then
A2: 2*1 <= 2*n & 2*n <= len W + 1;
    2*n <= 2 * len W.vertexSeq() by A1,dWVSEQ; then
    1 <= n & n <= len W.vertexSeq() by A2, tREAL01;
    hence n in dom W.vertexSeq() by FINSEQ_3:27;
end;  

theorem ::tWVSEQ08
  W.cut(1,n).vertexSeq() c= W.vertexSeq() proof
    now per cases;
    suppose
    B1: n is odd & 1 <= n & n <= len W;
        set f = W.cut(1,n).vertexSeq();
        now let v be set; assume
        C1: v in f; then consider x,y being set such that
        C2: v = [x,y] by RELAT_1:def 1;
        C3: x in dom f & y = f.x by C1, C2, FUNCT_1:8; then
            reconsider x as Nat;
            1 <= x & x <= len f by C3,FINSEQ_3:27; then
        C4: y = W.cut(1,n).(2*x-1) by C3, dWVSEQ;
        C5: 2*x-1 in dom W.cut(1,n) by C3, tWVSEQ07; then
        C6: y = W.(2*x-1) by B1, C4, lWCUT11;
        C0: 2*x-1 is Nat by C5; then
        C7: 1 <= 2*x-1 & 2*x-1 <= len W.cut(1,n) by C5, FINSEQ_3:27; then
            2*x-1 <= n by B1, lWCUT10; then
        C8: 2*x-1 <= len W by B1, AXIOMS:22;
            2*x-1 in dom W by C0,C7, C8, FINSEQ_3:27; then
        C9: x in dom W.vertexSeq() by tWVSEQ07; then
            1 <= x & x <= len W.vertexSeq() by FINSEQ_3:27; then
            W.vertexSeq().x = y by C6, dWVSEQ;
            hence v in W.vertexSeq() by C2, C9, FUNCT_1:8;
        end;
        hence thesis by TARSKI:def 3; end;
    suppose not (n is odd & 1 <= n & n <= len W);
        hence thesis by dWCUT; end;
    end;
    hence thesis;
end;  

theorem tWVSEQ09: ::tWVSEQ09
  e Joins W.last(),x,G implies
    W.addEdge(e).vertexSeq() = W.vertexSeq() ^ <*x*> proof
    set W2 = W.addEdge(e), W3 = W.vertexSeq() ^ <*x*>; assume
A1: e Joins W.last(),x,G; then
    len W2 = len W + 2 by lWADDEDGE03; then
A3: len W + 2 + 1 = 2 * len W2.vertexSeq() by dWVSEQ;
    len W3 = len W.vertexSeq() + len <*x*> by FINSEQ_1:35; then
    len W3 = len W.vertexSeq() + 1 by FINSEQ_1:56; then
    2*len W3 = 2*len W.vertexSeq()+2*1; then
    2*len W3 = len W + 1 + 2 by dWVSEQ
            .= 2* len W2.vertexSeq() by A3, XCMPLX_1:1; then
A4: len W3 = len W2.vertexSeq() by XCMPLX_1:5;            
    now let k be Nat; assume
    B1: 1 <= k & k <= len W2.vertexSeq(); then
    B2: k in dom W3 by A4, FINSEQ_3:27;
    B3: W2.vertexSeq().k = W2.(2*k-1) by B1, dWVSEQ;
        now per cases by B2, FINSEQ_1:38;
        suppose
        C1: k in dom W.vertexSeq(); then
        C2: W3.k = W.vertexSeq().k by FINSEQ_1:def 7;
            1 <= k & k <= len W.vertexSeq() by C1, FINSEQ_3:27; then
        C3: W3.k = W.(2*k-1) by C2, dWVSEQ;
            2*k-1 in dom W by C1, tWVSEQ07;
            hence W2.vertexSeq().k = W3.k by A1,B3,C3,lWADDEDGE04; end;
        suppose ex n being Nat st n in dom <*x*> & k=len W.vertexSeq()+n; then
            consider n being Nat such that
        C1: n in dom <*x*> & k  = len W.vertexSeq() + n;
            n in Seg 1 by C1, FINSEQ_1:55; then
        C2: n = 1 by FINSEQ_1:4,TARSKI:def 1; then
        C3: W3.k = <*x*>.1 by C1, FINSEQ_1:def 7
                .= x by FINSEQ_1:def 8;
            2*k = 2*len W.vertexSeq() + 2*1 by C1,C2
               .= len W + 1 + 2 by dWVSEQ
               .= len W + 2 + 1;
            hence W2.vertexSeq().k = W3.k by A1,B3,C3,lWADDEDGE04; end;
        end;
        hence W2.vertexSeq().k = W3.k;
    end;
    hence thesis by A4, FINSEQ_1:18;
end;    

theorem tWVSEQ10: ::tWVSEQ10
  for W1 being Walk of G1, W2 being Walk of G2 st W1 = W2 holds
    W1.vertexSeq() = W2.vertexSeq() proof
    let W1 be Walk of G1, W2 be Walk of G2;
    set VS1 = W1.vertexSeq(), VS2 = W2.vertexSeq(); assume
A1: W1 = W2;
    now thus len VS1 = len VS1;
        2 * len VS1 = len W2 + 1 by A1, dWVSEQ
                   .= 2 * len VS2 by dWVSEQ;
        hence
    B1: len VS2 = len VS1 by XCMPLX_1:5;
        let x be Nat; assume x in Seg len VS1; then
        x in dom VS1 by FINSEQ_1:def 3; then
    B2: 1 <= x & x <= len VS1 & x <= len VS2 by B1, FINSEQ_3:27;
        hence VS1.x = W2.(2*x - 1) by A1, dWVSEQ
                   .= VS2.x by B2, dWVSEQ;
    end;
    hence W1.vertexSeq() = W2.vertexSeq() by FINSEQ_2:10;
end;      

theorem ::tWESEQ01
  for n being even Nat st 1 <= n & n <= len W holds
    n div 2 in dom W.edgeSeq() & W.n = W.edgeSeq().(n div 2) by lWESEQ01;

theorem ::tWESEQ02
    n in dom W.edgeSeq() iff 2*n in dom W by lWESEQ02;

theorem ::tWESEQ03
  for n being Nat st n in dom W.edgeSeq()
    holds W.edgeSeq().n in the_Edges_of G proof
    let n be Nat; assume n in dom W.edgeSeq(); then
    W.edgeSeq().n in rng W.edgeSeq() by FUNCT_1:def 5;
    hence W.edgeSeq().n in the_Edges_of G;
end;

theorem ::tWESEQ04
  ex lenW_1 being even Nat st lenW_1 = len W - 1 &
  len W.edgeSeq() = lenW_1 div 2 by lWESEQ04;

theorem ::tWESEQ05
   W.cut(1,n).edgeSeq() c= W.edgeSeq() by lWESEQ05;

theorem ::tWESEQ06
  e Joins W.last(),x,G implies
    W.addEdge(e).edgeSeq() = W.edgeSeq() ^ <*e*> by lWESEQ06;

theorem tWESEQ07: ::tWESEQ07
  e Joins x,y,G iff
     G.walkOf(x,e,y).edgeSeq() = <*e*> proof
    set W = G.walkOf(x,e,y);
    hereby assume
    A1: e Joins x,y, G; then
        len W = 3 by tWALKOFE01; then
        2+1 = 2*len W.edgeSeq()+1 by dWESEQ; then
        2*1 = 2*len W.edgeSeq() by XCMPLX_1:2; then
    A2: len W.edgeSeq() = 1 by XCMPLX_1:5; then
    A3: len W.edgeSeq() = len <*e*> by FINSEQ_1:56;
    A4: W = <*x,e,y*> by A1, dWALKOFE;    
        now let k be Nat; assume
        B1: 1 <= k & k <= len W.edgeSeq();
        B2: k = 1 by B1, A2, AXIOMS:21; then
            W.edgeSeq().k = W.(2*1) by B1, dWESEQ
                         .= e by A4, FINSEQ_1:62;
            hence W.edgeSeq().k = <*e*>.k by B2,FINSEQ_1:def 8;
        end;
        hence W.edgeSeq() = <*e*> by A3, FINSEQ_1:18;
    end;
    assume W.edgeSeq() = <*e*>; then
    len W.edgeSeq() = 1 by FINSEQ_1:56; then
A1: len W = 2*1+1 by dWESEQ;
    now assume not e Joins x,y,G; then
        W = G.walkOf(choose the_Vertices_of G) by dWALKOFE;
        hence contradiction by A1,tWALKOFV01;
    end;
    hence thesis;
end;    

theorem ::tWESEQ08
  W.reverse().edgeSeq() = Rev (W.edgeSeq()) proof
    set W1 = W.reverse().edgeSeq(), W2 = Rev (W.edgeSeq());
A1: len W = len W.reverse() by lWREV01;
    len W = 2 * len W.edgeSeq() + 1 by dWESEQ; then
    2 * len W.edgeSeq() + 1 = 2 * len W1 + 1 by A1, dWESEQ; then
    2 * len W.edgeSeq() = 2 * len W1 by XCMPLX_1:2; then
A2: len W1 = len W.edgeSeq() by XCMPLX_1:5; then
A3: len W1 = len W2 by FINSEQ_5:def 3;
    now let n be Nat; assume
    B1: 1 <= n & n <= len W1;
        set rn = len W.edgeSeq() - n + 1;
        reconsider rn as Nat by A2,B1,FINSEQ_5:1;
    B2: n in Seg len W.edgeSeq() by A2, B1, FINSEQ_1:3; then
        rn in Seg len W.edgeSeq() by FINSEQ_5:2; then
    B3: 1 <= rn & rn <= len W.edgeSeq() by FINSEQ_1:3;
    B4: n in dom W.edgeSeq() by B2, FINSEQ_1:def 3; then
    B5: W2.n = W.edgeSeq().rn by FINSEQ_5:61
            .= W.(2*rn) by B3, dWESEQ;
        2*n in dom W by B4, lWESEQ02; then
        1 <= 2*n & 2*n <= len W.reverse() by A1, FINSEQ_3:27; then
    B6: 2*n in dom W.reverse() by FINSEQ_3:27;
    B7: W1.n = W.reverse().(2*n) by B1, dWESEQ;
        len W - 2*n + 1 = 2*len W.edgeSeq() + 1 - 2*n + 1 by dWESEQ
                       .= 2*rn;
        hence W1.n = W2.n by B5,B7,B6,lWREV05;
    end;
    hence thesis by A3, FINSEQ_1:18;
end;  

theorem ::tWESEQ09
  W1.last() = W2.first() implies
    W1.append(W2).edgeSeq() = W1.edgeSeq() ^ W2.edgeSeq() proof
    set W3 = W1.append(W2), W4 = W1.edgeSeq() ^ W2.edgeSeq(); assume
A1: W1.last() = W2.first();
A2: len W4 = len W1.edgeSeq() + len W2.edgeSeq() by FINSEQ_1:35;
    len W3 + 1 = len W1 + len W2 by A1, lWAPPND01; then
    len W3 + 1 = len W1 + (2*len W2.edgeSeq() + 1) by dWESEQ
              .= len W1 + 2*len W2.edgeSeq() + 1; then
    len W3 = 2*len W2.edgeSeq() + len W1 by XCMPLX_1:2; then
    2*len W3.edgeSeq()+1 = 2*len W2.edgeSeq()+len W1 by dWESEQ
                  .= 2*len W2.edgeSeq()+(2*len W1.edgeSeq()+1) by dWESEQ
                  .= 2*len W2.edgeSeq()+2*len W1.edgeSeq()+1;then
    2*len W3.edgeSeq() = 2*(len W1.edgeSeq() + len W2.edgeSeq())
      by XCMPLX_1:2; then
A3: len W3.edgeSeq() = len W4 by A2, XCMPLX_1:5;
A4: W3 = W1 ^' W2 by A1, dWAPPND;
    now let n be Nat; assume
    B1: 1 <= n & n <= len W3.edgeSeq(); then
    B2: n in dom W4 by A3, FINSEQ_3:27;
    B3: W3.edgeSeq().n = W3.(2*n) by B1, dWESEQ;
        now per cases by B2, FINSEQ_1:38;
        suppose
        C1: n in dom W1.edgeSeq(); then
        C2: 1 <= n & n <= len W1.edgeSeq() by FINSEQ_3:27;
        C3: W4.n = W1.edgeSeq().n by C1, FINSEQ_1:def 7
                .= W1.(2*n) by C2, dWESEQ;
            2*n in dom W1 by C1, lWESEQ02; then
            1 <= 2*n & 2*n <= len W1 by FINSEQ_3:27;
            hence W3.edgeSeq().n = W4.n by A4,B3,C3,GRAPH_2:14; end;
        suppose ex k being Nat st k in dom W2.edgeSeq() &
                n = len W1.edgeSeq() + k; then consider k being Nat such that
        C1: k in dom W2.edgeSeq() & n = len W1.edgeSeq() + k;
        C2: 1 <= k & k <= len W2.edgeSeq() by C1, FINSEQ_3:27; then
            1 <= k+k by NAT_1:37; then
            reconsider 2k_1 = 2*k-1 as Nat by INT_1:18;
        C3: W4.n = W2.edgeSeq().k by C1, FINSEQ_1:def 7
                .= W2.(2*k) by C2, dWESEQ;
            2*n+1 = 2*k + (2*len W1.edgeSeq()+1) by C1
                 .= 2*k + len W1 by dWESEQ; then
        C4: 2*n = len W1 + 2*k - 1 by XCMPLX_1:26
               .= len W1 + (2*k-1);
            1+1 <= k+k by C2, REAL_1:55; then
        C5: 1+1-1 <= 2k_1 by REAL_1:92;
            2*k <= 2*len W2.edgeSeq() by C2, AXIOMS:25; then
            2*k < 2*len W2.edgeSeq() + 1 by NAT_1:38; then
            2*k < len W2 by dWESEQ; then
            2k_1 < len W2 - 0 by REAL_1:92; then
            W3.(2*n) = W2.(2k_1+1) by A4, C4, C5, GRAPH_2:15
                    .= W2.(2*k);
            hence W3.edgeSeq().n = W4.n by B1,dWESEQ,C3; end;
        end;
        hence W3.edgeSeq().n = W4.n;
    end;
    hence thesis by A3, FINSEQ_1:18;
end;    

theorem tWESEQ10: ::tWESEQ10
  for W1 being Walk of G1, W2 being Walk of G2 st W1 = W2 holds
    W1.edgeSeq() = W2.edgeSeq() proof
    let W1 be Walk of G1, W2 be Walk of G2;
    set ES1 = W1.edgeSeq(), ES2 = W2.edgeSeq(); assume
A1: W1 = W2;
    now thus len ES1 = len ES1;
        2 * len ES1 + 1 = len W2 by A1, dWESEQ
                       .= 2 * len ES2 + 1 by dWESEQ; then
        2 * len ES1 = 2 * len ES2 by XCMPLX_1:2;
        hence
    B1: len ES2 = len ES1 by XCMPLX_1:5;
        let x be Nat; assume x in Seg len ES1; then
        x in dom ES1 by FINSEQ_1:def 3; then
    B2: 1 <= x & x <= len ES1 & x <= len ES2 by B1, FINSEQ_3:27;
        hence ES1.x = W2.(2*x) by A1, dWESEQ
                   .= ES2.x by B2, dWESEQ;
    end;
    hence thesis by FINSEQ_2:10;
end;    

theorem ::tWVERTICES01
  x in W.vertices() iff
     ex n being odd Nat st n <= len W & W.n = x by lWVERTICES01;

theorem tWVERTICES02: ::tWVERTICES02
    W.first() in W.vertices() & W.last() in W.vertices() proof
A1: W.first() = W.1 by dWFIRST;
    1 <= len W by HEYTING3:1;
    hence W.first() in W.vertices() by A1, JORDAN12:3, lWVERTICES01;
    W.last() = W.(len W) by dWLAST;
    hence W.last() in W.vertices() by lWVERTICES01;
end;    
  
theorem tWVERTICES03: ::tWVERTICES03
  for n being odd Nat st n <= len W holds
    W.vertexAt(n) in W.vertices() proof
    let n be odd Nat; assume
A1: n <= len W;
    W.vertexAt(n) = W.n by A1, dWVAT;
    hence thesis by A1, lWVERTICES01;
end;

theorem ::tWVERTICES04
  G.walkOf(v).vertices() = {v} proof
    now let x be set;
        hereby assume x in G.walkOf(v).vertices(); then
            consider n being odd Nat such that
        C1: n <= len G.walkOf(v) & G.walkOf(v).n = x by lWVERTICES01;
        C2: n <= 1 by C1, tWALKOFV01;
            1 <= n by HEYTING3:1; then
            x = G.walkOf(v).1 by C1,C2,AXIOMS:21; then
            x = v by tWALKOFV01;
            hence x in {v} by TARSKI:def 1;
        end;
        assume x in {v}; then
    B1: x = v by TARSKI:def 1;
    B2: 1 <= len G.walkOf(v) & 1 is odd by HEYTING3:1, JORDAN12:3;
        G.walkOf(v).1 = v by tWALKOFV01;
        hence x in G.walkOf(v).vertices() by B1,B2,lWVERTICES01;
    end;
    hence thesis by TARSKI:2;
end;

theorem tWVERTICES05: ::tWVERTICES05
  e Joins x,y,G implies G.walkOf(x,e,y).vertices() = {x,y} proof
    set W = G.walkOf(x,e,y);
    assume e Joins x, y, G; then
    W.vertexSeq() = <*x,y*> by tWVSEQ04; then
    W.vertices() = rng <*x,y*> by dWVERTICES;
    hence W.vertices() = {x,y} by FINSEQ_2:147;
end;

theorem ::tWVERTICES06
  W.vertices() = W.reverse().vertices() proof
    now let x be set;
        hereby assume
        C1: x in W.vertices(); then
            consider n being odd Nat such that
        C2: n <= len W & W.n = x by lWVERTICES01;
            1 <= n by HEYTING3:1; then
        C3: n in dom W by C2, FINSEQ_3:27; then
        C4: W.reverse().(len W - n + 1) = x by C2, tWREV04;
            reconsider lenW = len W as odd Nat;
        C5: lenW-n+1 is odd Nat by C2, FINSEQ_5:1;
            n in Seg len W by C3, FINSEQ_1:def 3; then
            lenW-n+1 in Seg len W by FINSEQ_5:2; then
        C0: lenW-n+1 in dom W by FINSEQ_1:def 3; then
            lenW-n+1 is Nat; then
            lenW-n+1 <= len W by C0,FINSEQ_3:27; then
        C6: lenW-n+1 <= len W.reverse() by lWREV01;
            reconsider v=x as Vertex of G by C1;
            thus x in W.reverse().vertices() by C4,C5,C6,lWVERTICES01;
        end;
    B0: W.reverse() = Rev W by dWREV;
        assume
    B1: x in W.reverse().vertices(); then
        consider n being odd Nat such that
    B2: n <= len W.reverse() & W.reverse().n = x by lWVERTICES01;
    B3: 1 <= n by HEYTING3:1; then
        n in dom W.reverse() by B2, FINSEQ_3:27; then
    B4: W.(len W - n + 1) = x by B2, B0, FINSEQ_5:def 3;
        reconsider lenW = len W as odd Nat;
    B5: n <= len W by B2, lWREV01; then
    B6: lenW-n+1 is odd Nat by FINSEQ_5:1;
        n in Seg len W by B3,B5, FINSEQ_1:3; then
        lenW-n+1 in Seg len W by FINSEQ_5:2; then
    B7: lenW-n+1 <= len W by B6, FINSEQ_1:3;
        reconsider v = x as Vertex of G by B1;
        thus x in W.vertices() by B4,B6,B7,lWVERTICES01;
    end;
    hence thesis by TARSKI:2;
end;

theorem tWVERTICES07: ::tWVERTICES07
  W1.last() = W2.first() implies
  W1.append(W2).vertices() = W1.vertices() \/ W2.vertices() proof
    set W = W1.append(W2); assume
A1: W1.last() = W2.first(); then
A2: W = W1 ^' W2 by dWAPPND;
    now let x be set;
        hereby assume
        C1: x in W.vertices(); then reconsider v=x as Vertex of G;
            consider n being odd Nat such that
        C2: n <= len W & W.n = v by C1, lWVERTICES01;
        C3: 1 <= n by HEYTING3:1;
            now per cases;
            suppose
            D1: n <= len W1; then
                n in dom W1 by C3, FINSEQ_3:27; then
                W1.n = v by C2,lWAPPND05; then
                v in W1.vertices() by D1, lWVERTICES01; 
                hence x in W1.vertices()\/W2.vertices() by XBOOLE_0:def 2; end;
            suppose
            D1: n > len W1; then consider k being Nat such that
            D2: len W1 + k = n by NAT_1:28;
                reconsider lenW1 = len W1 as odd Nat;
                now assume k is odd; then
                   reconsider k'=k as odd Nat;
                   lenW1 + k' = n by D2;
                   hence contradiction;
                end; then reconsider k as even Nat;
                k <> 0 by D1, D2 ; then
                0 < k by NAT_1:19; then
            D3: 0+1 <= k by NAT_1:38;
                len W1 + k + 1 <= len W + 1 by C2,D2,REAL_1:55; then
                (k + 1) + len W1 <= len W2 + len W1 by A1,lWAPPND01; then
            D4: k + 1 + len W1 - len W1 <= len W2 + len W1 - len W1
                  by REAL_1:92; then
                k < len W2 - 1 + 1 by NAT_1:38; then
            D6: W2.(k+1) = v by A2, C2, D2, D3, GRAPH_2:15;
                W2.vertexAt(k+1) in W2.vertices() by D4, tWVERTICES03; then
                v in W2.vertices() by dWVAT, D4, D6;
                hence x in W1.vertices() \/ W2.vertices()
                  by XBOOLE_0:def 2; end;
            end;
            hence x in W1.vertices() \/ W2.vertices();
        end;
        assume
    B1: x in W1.vertices() \/ W2.vertices();
    B2: now assume x in W1.vertices(); then
            consider n being odd Nat such that
        C1: n <= len W1 & W1.n = x by lWVERTICES01;
            1 <= n by HEYTING3:1; then
            n in dom W1 by C1, FINSEQ_3:27; then
            W.n = W1.n & n in dom W by lWAPPND05; then
            W.n = x & n <= len W by C1, FINSEQ_3:27;
            hence x in W.vertices() by lWVERTICES01;
        end;
        now per cases by B1, XBOOLE_0:def 2;
        suppose x in W1.vertices();
            hence x in W.vertices() by B2; end;
        suppose x in W2.vertices(); then consider n being odd Nat such that
        C1: n <= len W2 & W2.n = x by lWVERTICES01;
            now per cases;
            suppose n = 1; then
                W1.last() = x by A1,C1,dWFIRST;
                hence x in W.vertices() by B2,tWVERTICES02; end;
            suppose n <> 1;
                1 <= n by HEYTING3:1; then
                reconsider n_1 = n-1 as even Nat by INT_1:18;
                n_1 < len W2 - 0 by C1, REAL_1:92; then
            D3: W.(len W1 + n_1) = W2.(n_1 + 1) & (len W1 + n_1) in dom W
                  by A1, lWAPPND06;
                reconsider lenW1 = len W1 as odd Nat;
                lenW1 + n_1 <= len W by D3, FINSEQ_3:27;
                hence x in W.vertices() by D3,C1,lWVERTICES01; end;
            end; 
            hence x in W.vertices(); end;
        end;
        hence x in W.vertices();
    end;
    hence thesis by TARSKI:2;
end;

theorem ::tWVERTICES08
  for m,n being odd Nat st m <= n & n <= len W holds
    W.cut(m,n).vertices() c= W.vertices() proof
    let m, n be odd Nat; set W2 = W.cut(m,n); assume
A1: m <= n & n <= len W;
    now let x be set; assume x in W2.vertices(); then
    consider n being odd Nat such that
B1: n <= len W2 & W2.n = x by lWVERTICES01;
    1 <= n by HEYTING3:1; then
    reconsider n_1 = n - 1 as even Nat by INT_1:18;
    n_1 < len W2 - 0 by B1, REAL_1:92; then
B2: W2.(n_1+1) = W.(m+n_1) & m+n_1 in dom W by A1, lWCUT01; then
    m+n_1 <= len W by FINSEQ_3:27;
    hence x in W.vertices() by B1,B2,lWVERTICES01;
    end;
    hence thesis by TARSKI:def 3;
end;

theorem tWVERTICES09: ::tWVERTICES09
  e Joins W.last(),x,G implies
  W.addEdge(e).vertices() = W.vertices() \/ {x} proof
    set W2 = G.walkOf(W.last(), e, W.last().adj(e));
    set W3 = W.addEdge(e), WV = W.vertices(); assume
A1: e Joins W.last(), x, G; 
A2: W3 = W.append(W2) by dWADDEDGE;
    reconsider x'=x as Vertex of G by A1, GLIB_000:16;
A3: W.last().adj(e) = x' by A1, GLIB_000:69; then
    W2.first() = W.last() by A1, tWALKOFE02; then
A4: W3.vertices() = WV \/ W2.vertices() by A2, tWVERTICES07;
A5: W2.vertices() = {W.last(), x} by A1,A3, tWVERTICES05;
    now let y be set;
        hereby assume
        C1: y in WV \/ {W.last(), x};
            now per cases by C1, XBOOLE_0:def 2;
            suppose y in WV;
                hence y in WV \/ {x} by XBOOLE_0:def 2; end;
            suppose
            D1: y in {W.last(), x};
                now per cases by D1, TARSKI:def 2;
                suppose y = W.last(); then
                    y in WV by tWVERTICES02;
                    hence y in WV \/ {x} by XBOOLE_0:def 2; end;
                suppose y = x; then
                    y in {x} by TARSKI:def 1;
                    hence y in WV \/ {x} by XBOOLE_0:def 2; end;
                end;
                hence y in WV \/ {x}; end;
            end;
            hence y in WV \/ {x};
        end;
        assume
    B1: y in WV \/ {x};
        now per cases by B1, XBOOLE_0:def 2;
        suppose y in WV;
            hence y in WV \/ {W.last(), x} by XBOOLE_0:def 2; end;
        suppose y in {x}; then
            y = x by TARSKI:def 1; then
            y in {W.last(), x} by TARSKI:def 2;
            hence y in WV \/ {W.last(), x} by XBOOLE_0:def 2; end;
        end;
        hence y in WV \/ {W.last(), x};
    end;
    hence thesis by A4,A5,TARSKI:2;
end;  

theorem ::tWVERTICES10
  for G being finite _Graph, W being Walk of G, e,x being set holds
    e Joins W.last(),x,G & not x in W.vertices() implies
    card W.addEdge(e).vertices() = card W.vertices() + 1 proof
    let G be finite _Graph, W be Walk of G, e, x be set; assume
A1: e Joins W.last(),x,G & not x in W.vertices(); then
    card W.addEdge(e).vertices() = card (W.vertices()\/{x}) by tWVERTICES09;
    hence thesis by A1, CARD_2:54;
end;

theorem ::tWVERTICES11
   x in W.vertices() & y in W.vertices() implies
     ex W' being Walk of G st W' is_Walk_from x,y proof
    assume
A1: x in W.vertices() & y in W.vertices(); then
    consider m being odd Nat such that
A2: m <= len W & W.m = x by lWVERTICES01;
    consider n being odd Nat such that
A3: n <= len W & W.n = y by A1, lWVERTICES01;
    now per cases;
        suppose m <= n; then
        W.cut(m,n) is_Walk_from x, y by A2,A3,lWCUT02;
        hence thesis; end;
        suppose n <= m; then
        W.cut(n,m) is_Walk_from y, x by A2,A3,lWCUT02; then
        W.cut(n,m).reverse() is_Walk_from x, y by tWREV03;
        hence thesis; end;
    end;
    hence thesis;
end;   

theorem tWVERTICES12: ::tWVERTICES12
  for W1 being Walk of G1, W2 being Walk of G2 st W1 = W2 holds
    W1.vertices() = W2.vertices() proof
    let W1 be Walk of G1, W2 be Walk of G2; assume
A1: W1 = W2;
    thus W1.vertices() = rng W1.vertexSeq() by dWVERTICES
                      .= rng W2.vertexSeq() by A1, tWVSEQ10
                      .= W2.vertices() by dWVERTICES;
end;

theorem ::tWEDGES01
   e in W.edges() iff
     ex n being even Nat st 1 <= n & n <= len W & W.n = e by lWEDGES01;

theorem tWEDGES02: ::tWEDGES02
  e in W.edges() iff
    ex n being odd Nat st n < len W & W.(n+1) = e proof
    hereby assume e in W.edges(); then
        consider n1 being even Nat such that
    B1: 1 <= n1 & n1 <= len W & W.n1 = e by lWEDGES01;
        reconsider n = n1-1 as odd Nat by B1, INT_1:18;
        take n;
        n1-1 < len W - 0 by B1, REAL_1:92;
        hence n < len W;
        thus W.(n+1) = e by B1;
    end;
    given n being odd Nat such that
A1: n < len W & W.(n+1) = e;
A2: n+1 <= len W by A1,NAT_1:38;
    1 <= n+1 by NAT_1:37;
    hence e in W.edges() by A1, A2, lWEDGES01;
end;       

theorem tWEDGES03: ::tWEDGES03
  rng W = W.vertices() \/ W.edges() proof
    now let y be set; assume y in rng W; then
        consider x being Nat such that
    B1: x in dom W & W.x = y by FINSEQ_2:11;
    B2: 1 <= x & x <= len W by B1, FINSEQ_3:27;
        now per cases;
            suppose x is odd; then
            y in W.vertices() by B1, B2, lWVERTICES01;
            hence y in W.vertices() \/ W.edges() by XBOOLE_0:def 2; end;
            suppose x is even; then
            y in W.edges() by B1, B2, lWEDGES01;
            hence y in W.vertices() \/ W.edges() by XBOOLE_0:def 2; end;
        end;
        hence y in W.vertices() \/ W.edges();
    end; then
A1: rng W c= W.vertices() \/ W.edges() by TARSKI:def 3;
    now let y be set; assume
    B1: y in W.vertices() \/ W.edges();
        now per cases by B1, XBOOLE_0:def 2;
            suppose y in W.vertices(); then
            consider x being odd Nat such that
        C1: x <= len W & W.x = y by lWVERTICES01;
            1 <= x by HEYTING3:1; then
            x in dom W by C1, FINSEQ_3:27;
            hence y in rng W by C1, FUNCT_1:def 5; end;
            suppose y in W.edges(); then
            consider x being even Nat such that
        C1: 1 <= x & x <= len W & W.x = y by lWEDGES01;
            x in dom W by C1, FINSEQ_3:27;
            hence y in rng W by C1, FUNCT_1:def 5; end;
        end;
        hence y in rng W;
    end; then
    W.vertices() \/ W.edges() c= rng W by TARSKI:def 3;
    hence rng W = W.vertices() \/ W.edges() by A1, XBOOLE_0:def 10;
end;

theorem tWEDGES04: ::tWEDGES04
  W1.last() = W2.first() implies
    W1.append(W2).edges() = W1.edges() \/ W2.edges() proof
    set W = W1.append(W2);
    set WV = W.vertices(), W1V = W1.vertices(), W2V = W2.vertices();
    set WE = W.edges(),    W1E = W1.edges(),    W2E = W2.edges(); assume
A1: W1.last() = W2.first(); then
A2: W = W1 ^' W2 by dWAPPND;
    set lenW1 = len W1, lenW2 = len W2;
    reconsider lenW1, lenW2 as odd Nat;
    now let x be set;
        hereby assume x in WE; then consider n being even Nat such that
        C1: 1 <= n & n <= len W & W.n = x by lWEDGES01;
            now per cases;
            suppose
            D1: n <= len W1; then
                W.n = W1.n by A2, C1, GRAPH_2:14; then
                x in W1E by C1, D1, lWEDGES01;
                hence x in W1E \/ W2E by XBOOLE_0:def 2; end;
            suppose len W1 < n; then
                reconsider k = n-lenW1 as odd Nat by INT_1:18;
            D1: 1 <= k by HEYTING3:1;
                n - lenW1 + len W1 < len W + 1 by C1,NAT_1:38; then
                n-lenW1 + lenW1 < lenW2 + len W1 by A1, lWAPPND01; then
            D2: k < lenW2 + len W1 - len W1 by REAL_1:92; then
            D3: W2.(k+1) = W.(len W1+k) by A2, D1, GRAPH_2:15
                        .= x by C1;
            D4: 1 <= k+1 by NAT_1:37;
                k+1 <= len W2 by D2,NAT_1:38; then
                x in W2E by D3, D4, lWEDGES01;
                hence x in W1E \/ W2E by XBOOLE_0:def 2; end;
            end;  
            hence x in W1E \/ W2E;
        end;
        assume
    B1: x in W1E \/ W2E;
        now per cases by B1, XBOOLE_0:def 2;
            suppose x in W1E; then consider n being even Nat such that
        C1: 1 <= n & n <= len W1 & W1.n = x by lWEDGES01;
        C2: W.n = x by A2, C1, GRAPH_2:14;
            len W1 <= len W by A1, lWAPPND02; then
            n <= len W by C1, AXIOMS:22;
            hence x in WE by C1, C2, lWEDGES01; end;
            
            suppose x in W2E; then consider n being even Nat such that
        C1: 1 <= n & n <= len W2 & W2.n = x by lWEDGES01;
            reconsider n_1 = n-1 as odd Nat by C1, INT_1:18;
        C2: 1 <= n_1 by HEYTING3:1;
             n_1 < len W2 by C1, SPPOL_1:5; then
        C3:  W.(lenW1 + n_1) = W2.(n_1+1) by A2, C2, GRAPH_2:15
                            .= x by C1;
            1 <= lenW1 by HEYTING3:1; then
        C4: 1 <= lenW1+n_1 by NAT_1:37;
            (n_1 + 1) + lenW1 <= len W2 + len W1 by C1,REAL_1:55; then
            lenW1 + n_1 + 1 <= len W + 1 by A1, lWAPPND01; then
            lenW1+n_1 <= len W by REAL_1:53;
            hence x in WE by C3, C4, lWEDGES01; end;
        end;
        hence x in WE;
    end;
    hence thesis by TARSKI:2;
end;    

theorem ::tWEDGES05
  e in W.edges() implies ex v1, v2 being Vertex of G, n being odd Nat st
    n+2 <= len W & v1 = W.n & e = W.(n+1) & v2 = W.(n+2) &
    e Joins v1, v2,G by lWEDGES05;

theorem tWEDGES06: ::tWEDGES06
  e in W.edges() iff
    ex n being Nat st n in dom W.edgeSeq() & W.edgeSeq().n = e proof
    hereby assume e in W.edges(); then
        e in rng W.edgeSeq() by dWEDGES; then
        consider n being set such that
    B1: n in dom W.edgeSeq() & W.edgeSeq().n = e by FUNCT_1:def 5;
        reconsider n as Nat by B1;
        take n;
        thus n in dom W.edgeSeq() & W.edgeSeq().n = e by B1;
    end;
    given n being Nat such that
A1: n in dom W.edgeSeq() & W.edgeSeq().n = e;
    e in rng W.edgeSeq() by A1, FUNCT_1:def 5;
    hence thesis by dWEDGES;
end;

theorem ::tWEDGES07
  e in W.edges() & e Joins x,y,G implies
    x in W.vertices() & y in W.vertices() by lWEDGES07;

theorem ::tWEDGES08
  W.cut(m,n).edges() c= W.edges() proof
    now per cases;
    suppose
    B1: m is odd & n is odd & m <= n & n <= len W; then
        reconsider m' = m as odd Nat;
        now let e be set; assume e in W.cut(m,n).edges(); then
            consider x being even Nat such that
        C1: 1 <= x & x <= len W.cut(m,n) & W.cut(m,n).x = e
              by lWEDGES01;
            reconsider x_1 = x-1 as odd Nat by C1, INT_1:18;
        C2: x_1+1 = x;
            x_1 < len W.cut(m,n) - 0 by C1, REAL_1:92; then
        C3: e = W.(m+x_1) & m+x_1 in dom W by B1, C1, C2, lWCUT01; then
            1 <= m'+x_1 & m'+x_1 <= len W by FINSEQ_3:27;
            hence e in W.edges() by C3, lWEDGES01;
        end;
        hence thesis by TARSKI:def 3; end;
    suppose not (m is odd & n is odd & m <= n & n <= len W);
        hence thesis by dWCUT; end;
    end;
    hence thesis;
end;  

theorem tWEDGES09: ::tWEDGES09
  W.edges() = W.reverse().edges() proof
    now let e be set;
        hereby assume e in W.edges(); then
            consider n being even Nat such that
        C1: 1 <= n & n <= len W & W.n = e by lWEDGES01;
            n in dom W by C1, FINSEQ_3:27; then
        C2: e = W.reverse().(len W - n + 1) &
              (len W - n + 1) in dom W.reverse() by C1, tWREV04; then
            reconsider rn = len W - n + 1 as even Nat;
            1 <= rn & rn <= len W.reverse() by C2, FINSEQ_3:27;
            hence e in W.reverse().edges() by C2, lWEDGES01;
        
        end;
        assume e in W.reverse().edges(); then
        consider n being even Nat such that
    B1: 1 <= n & n <= len W.reverse() & W.reverse().n = e by lWEDGES01;
        n in dom W.reverse() by B1, FINSEQ_3:27; then
    B2: e = W.reverse().reverse().(len W.reverse() - n + 1) &
          (len W.reverse() - n + 1) in dom W.reverse().reverse()
          by B1, tWREV04; then
        reconsider rn = len W.reverse() - n + 1 as even Nat;
    B3: e = W.rn & rn in dom W by B2, lWREV06; then
        1 <= rn & rn <= len W by FINSEQ_3:27;
        hence e in W.edges() by B3, lWEDGES01;
    end;
    hence thesis by TARSKI:2;
end;  

theorem tWEDGES10: ::tWEDGES10
  e Joins x,y,G iff G.walkOf(x,e,y).edges() = {e} proof
    set W = G.walkOf(x,e,y);  
    hereby assume e Joins x,y,G; then 
        W.edgeSeq() = <*e*> by tWESEQ07;
        hence W.edges() = rng <*e*> by dWEDGES
                       .= {e} by FINSEQ_1:56;
    end;
    assume W.edges() = {e}; then
    e in W.edges() by TARSKI:def 1; then
    consider n being even Nat such that
A1: 1 <= n & n <= len W & W.n = e by lWEDGES01;
A2: 2*0+1 < n by A1, REAL_1:def 5;
    now assume not e Joins x,y,G; then
        W = G.walkOf(choose the_Vertices_of G) by dWALKOFE;
        hence contradiction by A1,A2,tWALKOFV01;
    end;
    hence thesis;
end;  

theorem ::tWEDGES11
  W.edges() c= G.edgesBetween(W.vertices()) proof
    now let e be set; assume e in W.edges(); then
        consider v1,v2 being Vertex of G, n being odd Nat such that
    B2: n+2 <= len W & v1 = W.n & e = W.(n+1) & v2 = W.(n+2) &
        e Joins v1,v2,G by lWEDGES05;
        n < len W by B2, tODD01; then
    B3: v1 in W.vertices() by B2, lWVERTICES01;
        v2 in W.vertices() by B2, lWVERTICES01;
        hence e in G.edgesBetween(W.vertices()) by B2, B3, GLIB_000:35;
    end;
    hence thesis by TARSKI:def 3;
end;

theorem ::tWEDGES12
  for W1 being Walk of G1, W2 being Walk of G2 st W1 = W2 holds
    W1.edges() = W2.edges() proof
    let W1 be Walk of G1, W2 be Walk of G2; assume
A1: W1 = W2;
    thus W1.edges() = rng W1.edgeSeq() by dWEDGES
                   .= rng W2.edgeSeq() by A1, tWESEQ10
                   .= W2.edges() by dWEDGES;
end;

theorem ::tWEDGES13
  e Joins W.last(),x,G implies
    W.addEdge(e).edges() = W.edges() \/ {e} proof
    set W2 = W.addEdge(e), WB = G.walkOf(W.last(),e,W.last().adj(e));
    assume e Joins W.last(),x,G; then
    e in W.last().edgesInOut() by GLIB_000:65; then
A1: e Joins W.last(), W.last().adj(e), G by GLIB_000:70;
A2: W2 = W.append(WB) by dWADDEDGE;
A3: WB.edges() = {e} by A1,tWEDGES10;
    WB.first() = W.last() by A1,tWALKOFE02;
    hence thesis by A2,A3,tWEDGES04;
end;    

theorem ::tWLENGTH01
   len W = 2 * W.length() + 1 by lWLENGTH01;

theorem ::tWLENGTH02
  len W1 = len W2 iff W1.length() = W2.length() proof
    hereby assume len W1 = len W2; then
        2 * W1.length() + 1 = len W2 by lWLENGTH01
                           .= 2 * W2.length() + 1 by lWLENGTH01; then
        2 * W1.length() = 2 * W2.length() by XCMPLX_1:2;
        hence W1.length() = W2.length() by XCMPLX_1:5;
    end;
    assume W1.length() = W2.length();
    hence len W1 = 2*W2.length()+1 by lWLENGTH01
                .= len W2 by lWLENGTH01;
end;  

theorem ::tWLENGTH03
  for W1 being Walk of G1, W2 being Walk of G2 st W1 = W2 holds
      W1.length() = W2.length() proof
    let W1 be Walk of G1, W2 be Walk of G2; assume
A1: W1 = W2;
    thus W1.length() = len W1.edgeSeq() by dWLENGTH
                     .= len W2.edgeSeq() by A1, tWESEQ10
                     .= W2.length() by dWLENGTH;
end;

theorem tWFINDV01: ::tWFINDV01
  for n being odd Nat st n <= len W holds
    W.find(W.n) <= n & W.rfind(W.n) >= n proof
    let n be odd Nat; assume
A1: n <= len W; then
A2: W.n in W.vertices() by lWVERTICES01;
    hence W.find(W.n) <= n by A1,dWFINDV;
    thus thesis by A1,A2,dWRFINDV;
end;  

theorem ::tWFINDV02
  for W1 being Walk of G1, W2 being Walk of G2, v being set st W1 = W2 holds
    W1.find(v) = W2.find(v) & W1.rfind(v) = W2.rfind(v) proof
    let W1 be Walk of G1, W2 be Walk of G2, v be set; assume
A1: W1 = W2;
    now per cases;
    suppose
    B1: v in W1.vertices(); then
    B2: v in W2.vertices() by A1,tWVERTICES12;
        W1.find(v) <= len W2 & W2.(W1.find(v)) = v &
        for n being odd Nat st n <= len W2 & W2.n = v holds W1.find(v) <= n
          by A1, B1, dWFINDV;
        hence W1.find(v) = W2.find(v) by B2,dWFINDV;
        W1.rfind(v) <= len W2 & W2.(W1.rfind(v)) = v &
          for n being odd Nat st n <= len W2 & W2.n = v holds n <= W1.rfind(v)
          by A1, B1, dWRFINDV;
        hence W1.rfind(v) = W2.rfind(v) by B2,dWRFINDV; end;          
    suppose
    B1: not v in W1.vertices(); then
    B2: not v in W2.vertices() by A1,tWVERTICES12;
        thus W1.find(v) = len W2 by A1, B1, dWFINDV
                       .= W2.find(v) by B2,dWFINDV;
        thus W1.rfind(v) = len W2 by A1, B1, dWRFINDV
                        .= W2.rfind(v) by B2,dWRFINDV; end;
    end;
    hence thesis;
end;

theorem ::tWFINDN01
  for n being odd Nat st n <= len W holds
    W.find(n) <= n & W.rfind(n) >= n by lWFINDN01, lWRFINDN01;

theorem tCLWALK01: ::tCLWALK01
  W is closed iff W.1 = W.(len W) proof
    hereby assume W is closed; then
        W.first() = W.last() by dCLWALK; then
        W.1 = W.last() by dWFIRST;
        hence W.1 = W.(len W) by dWLAST;
    end;
    assume W.1 = W.(len W); then
    W.first() = W.(len W) by dWFIRST; then
    W.first() = W.last() by dWLAST;
    hence W is closed by dCLWALK;
end;

theorem ::tCLWALK02
  W is closed iff ex x being set st W is_Walk_from x,x proof
    hereby assume W is closed; then
    B1: W.first() = W.last() by dCLWALK;
        set x = W.first();
        W is_Walk_from x,x by B1, dWALKFROM;
        hence ex x being set st W is_Walk_from x,x;
    end;
    given v being set such that
A1: W is_Walk_from v,v;
    W.first() = v & W.last() = v by A1, dWALKFROM;
    hence W is closed by dCLWALK;
end;  

theorem ::tCLWALK03
  W is closed iff W.reverse() is closed proof
    W is closed iff W.first() = W.last() by dCLWALK; then
    W is closed iff W.reverse().last() = W.last() by tWREV02; then
    W is closed iff W.reverse().last() = W.reverse().first() by tWREV02;
    hence thesis by dCLWALK;
end;

theorem ::tCLWALK04
  for W1 being Walk of G1, W2 being Walk of G2 st W1 = W2 & W1 is closed
    holds W2 is closed proof
    let W1 be Walk of G1, W2 be Walk of G2; assume
    W1 = W2 & W1 is closed; then
    W2.1 = W2.(len W2) by tCLWALK01;
    hence W2 is closed by tCLWALK01;
end;    
   
theorem ::tDIWALK01
  W is directed iff
  for n being odd Nat st n < len W
    holds W.(n+1) DJoins W.n, W.(n+2), G by lDIWALK01;

theorem ::tDIWALK02
  W is directed & W is_Walk_from x,y & e DJoins y,z,G
    implies W.addEdge(e) is directed & W.addEdge(e) is_Walk_from x,z
    by lDIWALK02;

theorem ::tDIWALK03
  for W being DWalk of G, m,n being Nat holds
    W.cut(m,n) is directed;

theorem ::tTVWALK01
  W is non trivial iff 3 <= len W by lTVWALK01;

theorem ::tTVWALK02
  W is non trivial iff len W <> 1 by lTVWALK02;

theorem tTVWALK03: ::tTVWALK03
  W.first() <> W.last() implies W is non trivial proof
    assume W.first() <> W.last(); then
    W.1 <> W.last() by dWFIRST; then
    W.1 <> W.(len W) by dWLAST;
    hence W is non trivial by lTVWALK02;
end;  

theorem ::tTVWALK04
  W is trivial iff ex v being Vertex of G st W = G.walkOf(v) by lTVWALK04;

theorem ::tTVWALK05
  W is trivial iff W.reverse() is trivial proof
    hereby assume W is trivial; then
         len W = 1 by lTVWALK02; then
         len W.reverse() = 1 by lWREV01; 
         hence W.reverse() is trivial by lTVWALK02;
    end;
    assume W.reverse() is trivial; then
    len W.reverse() = 1 by lTVWALK02; then
    len W = 1 by lWREV01; 
    hence W is trivial by lTVWALK02;
end;  

theorem ::tTVWALK06
  W2 is trivial implies W1.append(W2) = W1 proof
    assume W2 is trivial; then
A1: len W2 = 1 by lTVWALK02;  then
A2: W2 <> {} by FINSEQ_1:25;
    now per cases;
    suppose W1.last() = W2.first(); then
    B1: W1.append(W2) = W1 ^' W2 by dWAPPND; then
        len W1.append(W2) + 1 = len W1 + 1 by A1, A2, GRAPH_2:13; then
    B2: len W1.append(W2) = len W1 by XCMPLX_1:2;
        for k being Nat st 1 <= k & k <= len W1.append(W2)
          holds W1.append(W2).k = W1.k by B1,B2,GRAPH_2:14;
        hence thesis by B2, FINSEQ_1:18; end;
    suppose W1.last() <> W2.first();
       hence thesis by dWAPPND; end;
    end;
    hence thesis;
end;  

theorem ::tTVWALK07
  for m, n being odd Nat st m <= n & n <= len W holds
    W.cut(m,n) is trivial iff m = n proof
    let m, n be odd Nat; assume m <= n & n <= len W; then
    len W.cut(m,n) + m = n + 1 by lWCUT01; then
A1: len W.cut(m,n) = n + 1 - m by XCMPLX_1:26
                  .= (n - m) + 1;
    hereby assume W.cut(m,n) is trivial; then
        1 = (n - m) + 1 by A1,lTVWALK02; then
        n - m = 0 by XCMPLX_1:3;
        hence m = n by XCMPLX_1:15;
    end;
    assume m = n;
    hence W.cut(m,n) is trivial by A1,lTVWALK02;
end;    

theorem tTVWALK08: ::tTVWALK08
  e Joins W.last(),x,G implies W.addEdge(e) is non trivial proof
    1 <= len W by HEYTING3:1; then
A1: 1 + 0 < len W + 2 by REAL_1:67;
    assume e Joins W.last(), x, G; then
    len W.addEdge(e) = len W + 2 by lWADDEDGE03;
    hence thesis by A1,lTVWALK02;
end;  

theorem tTVWALK09: ::tTVWALK09
  W is non trivial implies ex lenW_2 being odd Nat st lenW_2 = len W - 2 &
    W.cut(1,lenW_2).addEdge(W.(lenW_2+1)) = W proof
    assume W is non trivial; then
A1: len W >= 3 by lTVWALK01;
    set lenW_2 = len W - 2*1;
    2 <= len W by A1, AXIOMS:22; then reconsider lenW_2 as odd Nat by INT_1:18;
    take lenW_2;
    thus lenW_2 = len W - 2;
    set W1 = W.cut(1,lenW_2), e = W.(lenW_2+1);
    1 <= lenW_2 & lenW_2 < len W - 0 by REAL_1:92, HEYTING3:1;
    hence W1.addEdge(e) = W.cut(1,lenW_2+2) by tWCUT06,JORDAN12:3
                       .= W by lWCUT04;
end;  

theorem tTVWALK10: ::tTVWALK10
  W2 is non trivial & W2.edges() c= W1.edges() implies
    W2.vertices() c= W1.vertices() proof
    assume
A1: W2 is non trivial & W2.edges() c= W1.edges(); then
A2: 3 <= len W2 by lTVWALK01;
    now let v be set; assume v in W2.vertices(); then
        consider n being odd Nat such that
    B2: n <= len W2 & W2.n = v by lWVERTICES01;
        now per cases;
        suppose n = len W2; then
            3-1 < n-0 by A2, REAL_1:92; then
            reconsider n_2 = n-2*1 as odd Nat by INT_1:18;
            n_2 < n - 0 by REAL_1:92; then
        C2: n_2 < len W2 by B2, AXIOMS:22; then
        CZ: W2.(n_2+1) Joins W2.n_2, W2.(n_2+2), G by dWALK;
            1 <= n_2+1 & n_2+1 <= len W2
              by C2,NAT_1:37,NAT_1:38; then
            W2.(n_2+1) in W2.edges() by lWEDGES01; then
            consider m being even Nat such that
        C4: 1 <= m & m <= len W1 & W1.m = W2.(n_2+1) by A1,lWEDGES01;
            reconsider m_1 = m - 1 as odd Nat by C4, INT_1:18;
        C6: m_1 < len W1 - 0 by C4, REAL_1:92; then
        CY: W1.(m_1+1) Joins W1.m_1, W1.(m_1+2), G by dWALK;
        C8: W1.m_1 = W1.vertexAt(m_1) by C6, dWVAT;
        C9: m_1+2 <= len W1 by C6, tODD01; then
            W1.(m_1+2) = W1.vertexAt(m_1+2) by dWVAT; then
            v = W1.vertexAt(m_1) or v = W1.vertexAt(m_1+2)
              by GLIB_000:18,C4,B2,CZ,CY,C8;
            hence v in W1.vertices() by C6, C9, tWVERTICES03; end;
        suppose n <> len W2; then
        C1: n < len W2 by B2, REAL_1:def 5; then
            W2.(n+1) in W2.edges() by tWEDGES02; then
            consider m being even Nat such that
        C3: 1 <= m & m <= len W1 & W1.m = W2.(n+1) by A1,lWEDGES01;
        C4: W1.m Joins v, W2.(n+2),G by C1,B2,C3,dWALK;
            reconsider m_1 = m - 1 as odd Nat by C3, INT_1:18;
        C5: m_1 < len W1 - 0 by C3, REAL_1:92; then
        C6: W1.(m_1+1) Joins W1.m_1, W1.(m_1+2), G by dWALK;
        C7: W1.m_1 = W1.vertexAt(m_1) by C5, dWVAT;
        C8: m_1+2 <= len W1 by C5, tODD01; then
            W1.(m_1+2) = W1.vertexAt(m_1+2) by dWVAT; then
            v = W1.vertexAt(m_1) or v = W1.vertexAt(m_1+2)
              by GLIB_000:18,C6,C7,C4;
            hence v in W1.vertices() by C5, C8, tWVERTICES03; end;
        end;
        hence v in W1.vertices();
     end;
     hence thesis by TARSKI:def 3;
end;

theorem ::tTVWALK11
  W is non trivial implies
    for v being Vertex of G st v in W.vertices() holds not v is isolated proof
    assume W is non trivial; then
A1: len W <> 1 by lTVWALK02;
    let v be Vertex of G; assume v in W.vertices(); then
    consider n being odd Nat such that
A3: n <= len W & W.n = v by lWVERTICES01;
    now per cases;
    suppose
    B1: n = len W;
        1 <= len W by HEYTING3:1; then
        1 < len W by A1, REAL_1:def 5; then
        1+1 <= len W by NAT_1:38; then
        reconsider lenW_2 = len W - 2*1 as odd Nat by INT_1:18;
        lenW_2 < len W - 0 by REAL_1:92; then
        W.(lenW_2+1) Joins W.lenW_2,W.(lenW_2+2),G by dWALK; then
        W.(lenW_2+1) Joins v,W.lenW_2,G by A3,B1,GLIB_000:17; then
        W.(lenW_2+1) in v.edgesInOut() by GLIB_000:65;
        hence ex e being set st e in v.edgesInOut(); end;
    suppose n <> len W; then
        n < len W by A3, REAL_1:def 5; then
        W.(n+1) Joins v, W.(n+2), G by A3, dWALK; then
        W.(n+1) in v.edgesInOut() by GLIB_000:65;
        hence ex e being set st e in v.edgesInOut(); end;
    end;
    hence not v is isolated by GLIB_000:def 51;
end;    

theorem ::tTVWALK12
  W is trivial iff W.edges() = {} proof
    W is trivial iff W.length() = 0 by dTVWALK; then
    W is trivial iff len W.edgeSeq() = 0 by dWLENGTH; then
    W is trivial iff W.edgeSeq() = {} by FINSEQ_1:25;
    hence W is trivial implies W.edges() = {} by RELAT_1:60,dWEDGES;
    assume W.edges() = {}; then
    rng W.edgeSeq() = {} by dWEDGES; then
    W.edgeSeq() = {} by RELAT_1:64; then
    len W.edgeSeq() = 0 by FINSEQ_1:25; then
    W.length() = 0 by dWLENGTH;
    hence W is trivial by dTVWALK;
end;

theorem ::tTVWALK13
  for W1 being Walk of G1, W2 being Walk of G2 st W1 = W2 & W1 is trivial
    holds W2 is trivial proof
    let W1 be Walk of G1, W2 be Walk of G2; assume
    W1 = W2 & W1 is trivial; then
    len W2 = 1 by lTVWALK02;
    hence thesis by lTVWALK02;
end;    

theorem ::tTLWALK01
  W is Trail-like iff
  for m,n being even Nat st 1 <= m & m < n & n <= len W holds
    W.m <> W.n by lTLWALK01;

theorem ::tTLWALK02
   len W <= 3 implies W is Trail-like by lTLWALK02;

theorem ::tTLWALK03
  W is Trail-like iff W.reverse() is Trail-like by lTLWALK03;

theorem ::tTLWALK04
  for W being Trail of G, m,n being Nat holds W.cut(m,n) is Trail-like;

theorem ::tTLWALK05
  for W being Trail of G, e being set
    st e in W.last().edgesInOut() & not e in W.edges()
    holds W.addEdge(e) is Trail-like by lTLWALK05;

theorem ::tTLWALK06
  for W being Trail of G, v being Vertex of G
    st v in W.vertices() & v is endvertex
    holds v = W.first() or v = W.last() proof
    let W be Trail of G, v be Vertex of G; assume
A1: v in W.vertices() & v is endvertex; then
    consider n being odd Nat such that
A2: n <= len W & W.n = v by lWVERTICES01;
A3: W.vertexAt(n) = v by A2, dWVAT;
    consider e being set such that
A4: v.edgesInOut() = {e} & not e Joins v,v,G by A1, GLIB_000:def 53;
    now assume
    B1: v <> W.first() & v <> W.last(); then
    B2: n <> 1 & n <> len W by A2, dWFIRST, dWLAST;
    BZ: 1 <= n by HEYTING3:1; then
    B3: 1 < n by B2, REAL_1:def 5; 
        reconsider n_1 = n-1 as even Nat by BZ,INT_1:18;
        1+1 <= n by B3, NAT_1:38; then
    B4: 1+1-1 <= n-1 by REAL_1:92;
        n <> len W by A2, B1, dWLAST; then
    B5: n < len W by A2, REAL_1:def 5; then
    B6: n+1 <= len W by NAT_1:38;
        n-1 < n_1+2 by NAT_1:41; then
    B7: W.(n_1) <> W.(n+1) by B4, B6, lTLWALK01;
        W.(n-1) in v.edgesInOut() by A2, A3, B3, tWALK06; then
    B8: W.(n-1) = e by A4, TARSKI:def 1;
        W.(n+1) in v.edgesInOut() by A3, B5, tWALK05;
        hence contradiction by A4,B7, B8,TARSKI:def 1;
    end;
    hence thesis;
end;

theorem ::tTLWALK07
  for G being finite _Graph, W being Trail of G holds
    len W.edgeSeq() <= G.size() proof
    let G be finite _Graph, W be Trail of G;
    consider f being Function such that
A1: dom f = W.edgeSeq() & for x being set st x in W.edgeSeq() holds f.x = x`2
      from FUNCT_1:sch 3;
    now let y be set; assume y in rng f; then
        consider x being set such that
    B2: x in dom f & f.x = y by FUNCT_1:def 5;
    B3: x in W.edgeSeq() & y = x`2 by A1, B2;
        consider a,b being set such that
    B4: x = [a,b] by A1,B2,RELAT_1:def 1;
        y = b by B3, B4, MCART_1:def 2; then
        y in rng W.edgeSeq() by A1,B2,B4,RELAT_1:def 5;
        hence y in (the_Edges_of G);
    end; then
A2: rng f c= the_Edges_of G by TARSKI:def 3;
    now let x1,x2 be set; assume
    B1: x1 in dom f & x2 in dom f & f.x1 = f.x2; then
    B2: x1 in W.edgeSeq() & f.x1 = x1`2 & x2 in W.edgeSeq() & f.x2 = x2`2
          by A1;
        consider a1,b1 being set such that
    B3: x1 = [a1,b1] by A1,B1,RELAT_1:def 1;
        consider a2,b2 being set such that
    B4: x2 = [a2,b2] by A1,B1,RELAT_1:def 1;
    B5: b1 = f.x1 by B2,B3,MCART_1:def 2
          .= b2 by B1,B2,B4,MCART_1:def 2;
    B6: W.edgeSeq() is one-to-one by dTLWALK;
    B7: a1 in dom W.edgeSeq() & W.edgeSeq().a1 = b1 by A1,B1,B3,FUNCT_1:8;
        a2 in dom W.edgeSeq() & W.edgeSeq().a2 = b1 by A1,B1,B4,B5,FUNCT_1:8;
        hence x1 = x2 by B3,B4,B5,B6,B7,FUNCT_1:def 8;
    end; then
    f is one-to-one by FUNCT_1:def 8; then
    Card W.edgeSeq() <=` Card (the_Edges_of G) by A1,A2,CARD_1:26; then
    card W.edgeSeq() <= card (the_Edges_of G) by CARD_2:57;
    hence len W.edgeSeq() <= G.size() by GLIB_000:def 27;
end;      

theorem ::tPLWALK01
  len W <= 3 implies W is Path-like by lPLWALK01;

theorem ::tPLWALK02
  (for m,n being odd Nat st m <= len W & n <= len W & W.m = W.n holds m = n)
      implies W is Path-like by lPLWALK02;

theorem ::tPLWALK03
  for W being Path of G st W is open holds
    for m, n being odd Nat st m < n & n <= len W holds W.m <> W.n proof
    let W be Path of G; assume
A1: W is open;
    let m, n be odd Nat; assume
A2: m < n & n <= len W;
    now assume
    B1: W.m = W.n; then
        m = 1 & n = len W by A2, dPLWALK;
        hence contradiction by A1,B1,tCLWALK01;
    end;
    hence thesis;
end;    

theorem ::tPLWALK04
   W is Path-like iff W.reverse() is Path-like by lPLWALK04;

theorem ::tPLWALK05
   for W being Path of G, m, n being Nat
     holds W.cut(m,n) is Path-like;

theorem tPLWALK06: ::tPLWALK06
  for W being Path of G, e,v being set
   st e Joins W.last(),v,G & not e in W.edges() & (W is trivial or W is open) &
     for n being odd Nat st 1 < n & n <= len W holds W.n <> v holds
   W.addEdge(e) is Path-like proof
    let W be Path of G, e,v be set; assume
A1: e Joins W.last(), v,G & not e in W.edges() & (W is trivial or W is open) & 
    (for n being odd Nat st 1 < n & n <= len W holds W.n <> v); then
A2: e in W.last().edgesInOut() by GLIB_000:65; 
    set W2 = W.addEdge(e); reconsider lenW = len W as odd Nat;
    now thus W2 is Trail-like by A1, A2, lTLWALK05;
        let m, n be odd Nat; assume
    B1: m < n & n <= len W2 & W2.m = W2.n;
        now per cases by A1;
        suppose
        C1: W is open;
            now per cases;
            suppose
            D1: n <= len W; then
            D2: m <= len W by B1, AXIOMS:22;
                1 <= m by HEYTING3:1; then
                m in dom W by D2, FINSEQ_3:27; then
            D3: W2.m = W.m by A1, lWADDEDGE04;
                1 <= n by HEYTING3:1; then
                n in dom W by D1, FINSEQ_3:27; then
            D4: W.m = W.n by A1,B1,D3,lWADDEDGE04; then
            D5: m = 1 & n = len W by B1, D1, dPLWALK; then
                W.first() = W.m by dWFIRST
                         .= W.last() by D4, D5, dWLAST;
            hence m = 1 & n = len W2 by C1, dCLWALK; end;
            suppose n > len W; then
                lenW + 1 <= n by NAT_1:38; then
                lenW + 1 < n by REAL_1:def 5; then
                lenW + 1 + 1 <= n by NAT_1:38; then
                len W + (1+1) <= n; then
            D0: len W2 <= n by A1, lWADDEDGE03; then
            D1: n = len W2 by B1, AXIOMS:21; then
                W2.n = W2.(len W + 2) by A1, lWADDEDGE03; then
            D2: W2.n = v by A1, lWADDEDGE04; 
                m < len W + (1 + 1) by A1,B1,D1,lWADDEDGE03; then
                m < len W + 1 + 1; then
                m <= lenW + 1 by NAT_1:38; then
                m < lenW + 1 by REAL_1:def 5; then
            D3: m <= len W by NAT_1:38;
                1 <= m by HEYTING3:1; then
                m in dom W by D3, FINSEQ_3:27; then
            D4: W.m = v by A1,B1,D2,lWADDEDGE04;
                now assume
                E1: m <> 1;
                    1 <= m by HEYTING3:1; then
                    1 < m by E1, REAL_1:def 5;
                    hence contradiction by A1,D3,D4;
                end;
                hence m = 1;
                thus n = len W2 by D0,B1,AXIOMS:21; end;
            end;
            hence m = 1 & n = len W2; end;
        suppose W is trivial; then consider v being Vertex of G such that
        C1: W = G.walkOf(v) by lTVWALK04; 
            len W = 1 by C1, tWALKOFV01; then
        C2: len W2 = 1 + 2 by A1, lWADDEDGE03;
        C3: 1 <= m by HEYTING3:1; then
        C4: 1+1 <= m+1 by REAL_1:55;
            m+1 <= n by B1, NAT_1:38; then
            2*1 <= n by C4, AXIOMS:22; then
            2*1 < n by REAL_1:def 5; then
        C5: len W2 <= n by C2,NAT_1:38; then
            m < 3  by B1,C2,AXIOMS:21; then
            m+1-1 <= 3-1 by C2,NAT_1:38; then
            m < 2*1 by REAL_1:def 5; then
            m+1 <= 2 by NAT_1:38; then
            m+1-1 <= 2-1 by REAL_1:92;
            hence m = 1 & n = len W2 by B1,C3,C5,AXIOMS:21; end;
        end;
        hence m = 1 & n = len W2;
    end;
    hence W.addEdge(e) is Path-like by dPLWALK;
end;

theorem ::tPLWALK07
  for W being Path of G, e, v being set st e Joins W.last(),v,G &
    not v in W.vertices() & (W is trivial or W is open)
    holds W.addEdge(e) is Path-like by lPLWALK07;

theorem ::tPLWALK08
  (for n being odd Nat st n <= len W holds W.find(W.n) = W.rfind(W.n))
    implies W is Path-like proof
    assume
A1: for n being odd Nat st n <= len W holds W.find(W.n) = W.rfind(W.n);
A2: now let x be odd Nat; assume
    B1: x <= len W;
    B3: W.find(W.x) <= x by B1, tWFINDV01;
    B4: W.rfind(W.x) >= x by B1, tWFINDV01;
        W.find(W.x) = W.rfind(W.x) by B1, A1;
        hence W.find(W.x) = x & W.rfind(W.x) = x by B3, B4, AXIOMS:21;
    end;
    now let m, n be even Nat; assume
    B1: 1 <= m & m < n & n <= len W; then
        1 <= m & m <= len W by AXIOMS:22; then
         m in dom W by FINSEQ_3:27; then
        consider m_1 being odd Nat such that
    B2: m_1 = m-1 & m-1 in dom W & m+1 in dom W &
         W.m Joins W.(m_1), W.(m+1),G by lWALK04;
         1 <= n & n <= len W by B1, AXIOMS:22; then
        n in dom W by FINSEQ_3:27; then
        consider n_1 being odd Nat such that
    B3: n_1 = n-1 & n-1 in dom W & n+1 in dom W &
          W.n Joins W.(n_1), W.(n+1),G by lWALK04;
        now assume
        C0: W.m = W.n;
            set Wm_1 = W.(m_1), Wm1 = W.(m+1);
            set Wn_1 = W.(n_1), Wn1 = W.(n+1);
        C2: m_1 <= len W & n+1 <= len W & n_1 <= len W
              by B2, B3, FINSEQ_3:27;
        C4: W.find(Wm_1) = m_1 & W.rfind(Wn_1) = n_1 & W.rfind(Wn1) = n+1
              by A2, C2;
            now per cases by C0,B3,B2,GLIB_000:18;
            suppose Wm_1 = Wn_1 & Wm1 = Wn1; then
                m_1 = n_1 by A1,C2,C4; then
                m = n - 1 + 1 by B2,B3,XCMPLX_1:27;
                hence contradiction by B1; end;
            suppose Wm_1 = Wn1 & Wm1 = Wn_1; then
                m_1 = n+1 by A1,C2,C4; then
                n <= m_1-1+1 by NAT_1:37; then
                n <= m-1+1 by B2, NAT_1:37;
                hence contradiction by B1; end;
            end;
            hence contradiction;
        end;
        hence W.m <> W.n;
    end; then
A3: W is Trail-like by lTLWALK01;
    now let m, n be odd Nat; assume
    B1: m < n & n <= len W & W.m = W.n; then
        m <= len W by AXIOMS:22; then
        W.find(W.m) = m & W.find(W.m) = n by A2, B1;
        hence m = 1 & n = len W by B1;
    end;
    hence thesis by A3, dPLWALK;
end;    

theorem ::tPLWALK09
  (for n being odd Nat st n <= len W holds W.rfind(n) = n)
    implies W is Path-like by lPLWALK09;

theorem ::tPLWALK10
  for G being finite _Graph, W being Path of G holds
    len W.vertexSeq() <= G.order() + 1 proof
    let G be finite _Graph, W be Path of G;
    now per cases;
    suppose len W = 1; then
        1 + 1 = 2 * len W.vertexSeq() by dWVSEQ; then
        2*1 = 2*len W.vertexSeq(); then
        len W.vertexSeq() = 1 by XCMPLX_1:5;
        hence thesis by NAT_1:37; end;
    suppose len W <> 1; then
        W is non trivial by lTVWALK02; then
        consider lenW_2 being odd Nat such that
    B1: lenW_2 = len W - 2 & W.cut(1,lenW_2).addEdge(W.(lenW_2+1)) = W
          by tTVWALK09;
        set W2 = W.cut(1,lenW_2), vs1 = W2.vertexSeq();
    BW: lenW_2 < len W - 0 by B1, REAL_1:92; then
    BV: len W2 = lenW_2 by lWCUT10;
        consider f being Function such that
    BZ: dom f = vs1 & for x being set st x in vs1 holds f.x = x`2
          from FUNCT_1:sch 3;
        now let y be set; assume
            y in rng f; then consider x being set such that
        C1: x in dom f & f.x = y by FUNCT_1:def 5;
            consider a,b being set such that
        C3: x = [a,b] by C1,BZ,RELAT_1:def 1;
            y = x`2 by C1, BZ; then
        C4: y = b by C3, MCART_1:def 2;
            a in dom vs1 & b = vs1.a by C1,BZ,C3,FUNCT_1:8; then
            y in rng vs1 by C4, FUNCT_1:def 5; 
            hence y in the_Vertices_of G;
        end; then
    BY: rng f c= the_Vertices_of G by TARSKI:def 3;
        now let x1, x2 be set; assume
        C1: x1 in dom f & x2 in dom f & f.x1 = f.x2; then
            consider a1,b1 being set such that
        C3: x1 = [a1,b1] by BZ,RELAT_1:def 1;
            consider a2,b2 being set such that
        C4: x2 = [a2,b2] by C1,BZ,RELAT_1:def 1;
        C5: f.x1 = x1`2 by C1,BZ
                .= b1 by C3, MCART_1:def 2;
        C6: f.x2 = x2`2 by C1,BZ
                .= b2 by C4, MCART_1:def 2;
        C7: a1 in dom vs1 & b1 = vs1.a1 & a2 in dom vs1 & b2 = vs1.a2
              by C1,BZ,C3,C4,FUNCT_1:8;
            reconsider a1,a2 as Nat by C7;
        C8: now let n1,n2 be Nat; assume
            D1: n1<n2 & n1 in dom vs1 & n2 in dom vs1 & vs1.n1 = vs1.n2; then
            D2: 2*n1-1 in dom W2 & 2*n2-1 in dom W2 by tWVSEQ07; then
                reconsider a = 2*n1-1, b=2*n2-1 as odd Nat;
                1 <= n1 & n1 <= len vs1 & 1 <= n2 & n2 <= len vs1
                  by D1, FINSEQ_3:27; then
            D4: vs1.n1 = W2.a & vs1.n2 = W2.b by dWVSEQ;
            D5: W2.a = W.a & W2.b = W.b by BW,D2,lWCUT11;
                2*n1 < 2*n2 by D1, REAL_1:70; then
            D6: a < b by REAL_1:92;
                b <= lenW_2 by BV, D2, FINSEQ_3:27; then
                b < len W by BW, AXIOMS:22;
                hence contradiction by D1,D4,D5,D6,dPLWALK;
            end;
            now assume
            D1: a1 <> a2;
                now per cases;
                suppose a1 <= a2; then
                    a1 < a2 by D1, REAL_1:def 5;
                    hence contradiction by C1,C5,C6,C7,C8; end;
                suppose a1 > a2;
                    hence contradiction by C1,C5,C6,C7,C8; end;
                end;
                hence contradiction;
            end;
            hence x1 = x2 by C1,C3,C4,C5,C6;
        end; then
        f is one-to-one by FUNCT_1:def 8; then
        Card vs1 <=` Card the_Vertices_of G by BZ,BY,CARD_1:26; then
        card vs1 <= card the_Vertices_of G by CARD_2:57; then
        len vs1 <= G.order() by GLIB_000:def 26; then
    B2: len vs1 + 1 <= G.order() + 1 by REAL_1:55;
    B3: lenW_2 < len W - 0 by B1, REAL_1:92; then
    B5: W.(lenW_2+1) Joins W.lenW_2, W.(lenW_2+2), G by dWALK;
        1 is odd & 1 <= lenW_2 by HEYTING3:1, JORDAN12:3; then
        W2.last() = W.lenW_2 by B3, lWCUT02; then
        W.vertexSeq() = vs1 ^ <*W.(lenW_2+2)*> by B1, B5, tWVSEQ09; then
        len W.vertexSeq() = len vs1 + len <*W.(lenW_2+2)*> by FINSEQ_1:35;
        hence thesis by B2,FINSEQ_1:56; end;
    end;
    hence thesis;
end;

theorem ::tWVDISTINCT01
  for G being _Graph, W being vertex-distinct Walk of G, e,v being set
   st e Joins W.last(),v,G & not v in W.vertices()
   holds W.addEdge(e) is vertex-distinct proof
    let G be _Graph, W be vertex-distinct Walk of G, e,v be set; assume
A1: e Joins W.last(),v,G & not v in W.vertices();
    set W2 = W.addEdge(e);
A2: len W2 = len W + 2 by A1,lWADDEDGE03;
A3: now let n be odd Nat; assume
    B1: n <= len W2 & n > len W; then
        len W + 1 <= n by NAT_1:38; then
        len W + 1 < n by REAL_1:def 5; then
        len W + 1 + 1 <= n by NAT_1:38;
        hence n = len W2 by A2,B1,AXIOMS:21;
        hence W2.n = v by A1,A2,lWADDEDGE04;
    end;
    now let m,n be odd Nat; assume
    B1: m <= len W2 & n <= len W2 & W2.m = W2.n;
    B2: 1 <= m & 1 <= n by HEYTING3:1;
        now per cases;
          suppose
        C1: m <= len W; then
            m in dom W by B2,FINSEQ_3:27; then
        C3: W2.m = W.m by A1,lWADDEDGE04;
            now per cases;
              suppose
            D1: n <= len W; then
                n in dom W by B2,FINSEQ_3:27; then
                W2.n = W.n by A1,lWADDEDGE04;
                hence m = n by B1,C1,D1,C3,dVDWALK;
              end;
              suppose n > len W; then
                n = len W2 & W.m = v by A3,C3,B1;
                hence m = n by A1,C1,lWVERTICES01;
              end;
            end;
            hence m = n;
          end;
          suppose m > len W; then
        C1: m = len W2 & W2.m = v by A3,B1;
            now per cases;
              suppose
            D1: n <= len W; then
                n in dom W by B2,FINSEQ_3:27; then
                v = W.n by A1,B1,C1,lWADDEDGE04;
                hence m = n by A1,D1,lWVERTICES01;
              end;
              suppose n > len W;
                hence m = n by A3,B1,C1;
              end;
            end;
            hence m =n;
          end;
        end;
        hence m = n;
    end;
    hence thesis by dVDWALK;
end;   

theorem ::tCYWALK01
  e Joins x,x,G implies G.walkOf(x,e,x) is Cycle-like proof
    set W = G.walkOf(x,e,x); assume e Joins x,x,G; then
    len W = 3 by tWALKOFE01; then
    W is non trivial by lTVWALK01;
    hence thesis by dCYWALK;
end;

theorem ::tCYWALK02
  e Joins x,y,G & e in W1.edges() & W1 is Cycle-like implies
    ex W2 being Walk of G st W2 is_Walk_from x,y & not e in W2.edges() proof
    assume
A1: e Joins x,y,G & e in W1.edges() & W1 is Cycle-like; then
    consider v1,v2 being Vertex of G, n being odd Nat such that
A2: n+2 <= len W1 & v1 = W1.n & e = W1.(n+1) & v2 = W1.(n+2) &
      e Joins v1,v2,G by lWEDGES05;
    set WA = W1.cut(n+2, len W1), WB = W1.cut(2*0+1,n);
    WA is_Walk_from v2, W1.(len W1) by A2, lWCUT02; then
A3: WA is_Walk_from v2, W1.last() by dWLAST;
A4: 1 <= n by HEYTING3:1;
AZ: n+2-2 < len W1-0 by A2, REAL_1:92; then
    WB is_Walk_from W1.(2*0+1), v1 by A2, A4, lWCUT02; then
A5: WB is_Walk_from W1.first(), v1 by dWFIRST;
    W1 is closed by A1, dCYWALK; then
A6: WB is_Walk_from W1.last(), v1 by A5,dCLWALK; then
A7: WA.append(WB) is_Walk_from v2,v1 by A3, tWAPPND04;
A8: WA.last() = W1.last() & WB.first() = W1.last() by A3,A6,dWALKFROM;
    W1 is Path-like by A1, dCYWALK; then
A9: W1 is Trail-like by dPLWALK;
AA: now assume e in WA.edges(); then
        consider m being even Nat such that
    B1: 1 <= m & m <= len WA & WA.m = e by lWEDGES01;
        reconsider m_1 = m-1 as odd Nat by B1, INT_1:18;
    B2: m_1+1 = m;
        m_1 < len WA - 0 by B1, REAL_1:92; then
    B3: e = W1.(n+2+m_1) & n+2+m_1 in dom W1 by A2, B1, B2, lWCUT01; then
    B4: n+2+m_1 <= len W1 by FINSEQ_3:27;
    B5: n+1 < n+1+1 by NAT_1:38;
        0 <= m_1 by NAT_1:18; then
    B6: n+1+0 < n+2+m_1 by B5, REAL_1:67;
        1 <= n+1 by NAT_1:37;
        hence contradiction by A2,A9,B3,B4,B6,lTLWALK01;
    end;
AB: now assume e in WB.edges(); then
        consider m being even Nat such that
    B1: 1 <= m & m <= len WB & WB.m = e by lWEDGES01;
        m in dom WB by B1, FINSEQ_3:27; then
    B2: W1.m = W1.(n+1) by A2, AZ, B1, lWCUT11;
        len WB = n by AZ, lWCUT10; then
    B4: m+0 < n+1 by B1,REAL_1:67;
        n+1 <= len W1 by AZ, NAT_1:38;
        hence contradiction by A9, B1, B2, B4, lTLWALK01;
    end;
    WA.append(WB).edges() = WA.edges() \/ WB.edges() by A8, tWEDGES04; then
AC: not e in WA.append(WB).edges() by AA,AB,XBOOLE_0:def 2; then
AD: not e in WA.append(WB).reverse().edges() by tWEDGES09;
AE: WA.append(WB).reverse() is_Walk_from v1,v2 by A7, tWREV03;
    now per cases by A1,A2,GLIB_000:18;
    suppose x = v1 & y = v2;
        hence thesis by AE,AD; end;
    suppose x = v2 & y = v1;
        hence thesis by A7,AC; end;
    end;
    hence thesis;
end;

theorem ::tSUBWALK01
  W is Subwalk of W by lSUBWALK01;

theorem ::tSUBWALK02
  for W1 being Walk of G, W2 being Subwalk of W1, W3 being Subwalk of W2
    holds W3 is Subwalk of W1 by lSUBWALK02;

theorem ::tSUBWALK03
    W1 is Subwalk of W2 implies
      (W1 is_Walk_from x,y iff W2 is_Walk_from x,y) proof
    assume
A0: W1 is Subwalk of W2;
    hereby assume W1 is_Walk_from x,y; then
    B1: W1.first() = x & W1.last() = y by dWALKFROM;    
        W1 is_Walk_from W2.first(),W2.last() by A0, dSUBWALK; then
        x = W2.first() & y = W2.last() by B1, dWALKFROM;
        hence W2 is_Walk_from x,y by dWALKFROM;
    end;
    assume W2 is_Walk_from x,y; then
    W2.first() = x & W2.last() = y by dWALKFROM;
    hence W1 is_Walk_from x,y by A0, dSUBWALK;
end;      

theorem tSUBWALK04: ::tSUBWALK04
    W1 is Subwalk of W2 implies
       W1.first() = W2.first() & W1.last() = W2.last() proof
    assume W1 is Subwalk of W2; then
    W1 is_Walk_from W2.first(), W2.last() by dSUBWALK;
    hence thesis by dWALKFROM;
end;

theorem ::tSUBWALK05
    W1 is Subwalk of W2 implies
      len W1 <= len W2 by lSUBWALK05;

theorem tSUBWALK06: ::tSUBWALK06
    W1 is Subwalk of W2 implies
      W1.edges() c= W2.edges() & W1.vertices() c= W2.vertices() proof
    assume
A1: W1 is Subwalk of W2; then
    consider es being FinSubsequence of W2.edgeSeq() such that
A2: W1.edgeSeq() = Seq es by dSUBWALK;
    now let e be set; assume e in W1.edges(); then
        consider n being even Nat such that
    B2: 1 <= n & n <= len W1 & W1.n = e by lWEDGES01;
        n div 2 in dom Seq es & W1.n = (Seq es).(n div 2)
          by lWESEQ01, A2, B2; then
        consider m being Nat such that
    B3: m in dom W2.edgeSeq() & n div 2 <= m & W1.n = W2.edgeSeq().m
          by tFINSUBSEQ02;
        thus e in W2.edges() by B2, B3, tWEDGES06;
    end;
    hence
A5: W1.edges() c= W2.edges() by TARSKI:def 3;
    now per cases;
    suppose
    B1: W1 is trivial;
        now let v be set; assume v in W1.vertices(); then
            consider n being odd Nat such that
        C1: n <= len W1 & W1.n = v by lWVERTICES01;
            1 <= n & n <= 1 by B1,C1,lTVWALK02,HEYTING3:1; then
            n = 1 by AXIOMS:21; then
            v = W1.first() by C1, dWFIRST; then
            v = W2.first() by A1, tSUBWALK04;
            hence v in W2.vertices() by tWVERTICES02;
        end;
        hence W1.vertices() c= W2.vertices() by TARSKI:def 3; end;
    suppose W1 is non trivial;
        hence W1.vertices() c= W2.vertices() by A5, tTVWALK10; end;
    end;
    hence thesis;
end;

theorem tSUBWALK07: ::tSUBWALK07
    W1 is Subwalk of W2 implies
      for m being odd Nat st m <= len W1 holds
       ex n being odd Nat st m <= n & n <= len W2 & W1.m = W2.n proof
    assume
A1: W1 is Subwalk of W2; then
    consider es being FinSubsequence of W2.edgeSeq() such that
A2: W1.edgeSeq() = Seq es by dSUBWALK;
    let m be odd Nat such that
AZ: m <= len W1;
    now per cases by AZ, REAL_1:def 5;
    suppose
    B1: m < len W1; then
    B2: W1.(m+1) Joins W1.m, W1.(m+2), G by dWALK;
        reconsider m1= m+1 as even Nat;
        1 <= m1 & m1 <= len W1 by B1,NAT_1:37, NAT_1:38; then
        m1 div 2 in dom W1.edgeSeq() & W1.m1 = W1.edgeSeq().(m1 div 2)
          by lWESEQ01; then
        consider x being Nat such that
    B4: x in dom W2.edgeSeq() & m1 div 2 <= x & W1.m1 = W2.edgeSeq().x
          by A2, tFINSUBSEQ02; set n = 2*x;
    B5: 1 <= x & x <= len W2.edgeSeq() by B4, FINSEQ_3:27;
        2 divides m1 by PEPIN:22; then
    B7: 2 * (m1 div 2) = m1 by NAT_1:49;
        n in dom W2 by B4, lWESEQ02; then
    B8: 1 <= n & n <= len W2 by FINSEQ_3:27; then
        reconsider n_1 = n - 1 as odd Nat by INT_1:18;
    BZ: n_1 < len W2 - 0 by B8, REAL_1:92; then
        W2.(n_1+1) Joins W2.n_1, W2.(n_1+2), G by dWALK; then
    B9: W1.m1 Joins W2.n_1, W2.(n_1+2), G by B5,B4,dWESEQ;
        m1 <= n by B7,B4,AXIOMS:25; then
    BA: m1-1 <= n-1 by REAL_1:92; then
    BB: m <= n_1+2 by NAT_1:37;
    BC: n_1 + 2 <= len W2 by BZ, tODD01;
        now per cases by B2, B9, GLIB_000:18;
        suppose W1.m = W2.n_1;
           hence thesis by BA, BZ; end;
        suppose W1.m = W2.(n_1+2);
           hence thesis by BB, BC; end;
        end;
        hence thesis; end;
    suppose m = len W1; then
    B2: W1.m = W1.last() by dWLAST
            .= W2.last() by A1, tSUBWALK04
            .= W2.(len W2) by dWLAST;
        len W1 <= len W2 by A1, lSUBWALK05; then
        m <= len W2 by AZ, AXIOMS:22;
        hence thesis by B2; end;
    end;
    hence thesis;
end;

theorem ::tSUBWALK08
   W1 is Subwalk of W2 implies
      for m being even Nat st 1 <= m & m <= len W1 holds
       ex n being even Nat st m <= n & n <= len W2 & W1.m = W2.n proof
    assume W1 is Subwalk of W2; then
    consider es being FinSubsequence of W2.edgeSeq() such that
A2: W1.edgeSeq() = Seq es by dSUBWALK;
    let m be even Nat such that
A4: 1 <= m & m <= len W1;
    m div 2 in dom W1.edgeSeq() & W1.m = W1.edgeSeq().(m div 2)
      by A4, lWESEQ01; then
    consider ndiv2 being Nat such that
A5: ndiv2 in dom W2.edgeSeq() & m div 2 <= ndiv2 & W1.m = W2.edgeSeq().ndiv2
      by A2, tFINSUBSEQ02;
    1 <= ndiv2 & ndiv2 <= len W2.edgeSeq() by A5, FINSEQ_3:27; then
A6: W1.m = W2.(2*ndiv2) by A5, dWESEQ;
    2 divides m by PEPIN:22; then
    2 * (m div 2) = m by NAT_1:49; then
A7: m <= 2*ndiv2 by A5, AXIOMS:25; 
    2*ndiv2 in dom W2 by A5, lWESEQ02; then
    2*ndiv2 <= len W2 by FINSEQ_3:27;
    hence thesis by A6, A7;
end;

theorem ::tSUBPATH01
  for W1 being Trail of G st W1 is non trivial holds
    ex W2 being Path of W1 st W2 is non trivial proof
    let W1 be Trail of G; assume
    W1 is non trivial; then
A2: 1 <> len W1 by lTVWALK02;
    1 <= len W1 by HEYTING3:1; then
A3: 1 < len W1 by A2, REAL_1:def 5; 
    now per cases;
    suppose W1 is open; then
    B1: W1.first() <> W1.last() by dCLWALK;
        consider P being Path of W1;
        take P;
        P.first() = W1.first() & P.last() = W1.last() by tSUBWALK04;
        hence P is non trivial by B1,tTVWALK03; end;
    suppose W1 is closed; then
    B1: W1.1 = W1.(len W1) by tCLWALK01;
        defpred P[Nat] means $1 is odd & 1 < $1 & $1 <= len W1 &
          W1.($1) = W1.(len W1);
    B2: ex k being Nat st P[k] by A3;
        consider k being Nat such that
    B3: P[k] & for m being Nat st P[m] holds k <= m from NAT_1:sch 5(B2);
        reconsider k as odd Nat by B3;
        set W3 = W1.remove(k,len W1);
        1+1 < k+1 by B3, REAL_1:67; then
        2 <= k by NAT_1:38; then
        reconsider k_2 = k - 2*1 as odd Nat by INT_1:18;
        set W4 = W3.cut(2*0+1,k_2);
        consider W5 being Path of W4;
        set e = W1.(k_2+1), W2 = W5.addEdge(e);
        k_2 < len W1 - 0 by B3, REAL_1:92; then
    B7: e Joins W1.k_2, W1.(k_2+2), G by dWALK;
        len W3 + len W1 = len W1 + k by B3, lWREMOVE01; then
    B8: len W3 = k by XCMPLX_1:2; then
    B9: k_2 <= len W3 - 0 by REAL_1:92;
    BA: 1 <= k_2 by HEYTING3:1; then
    BB: W4.first() =  W3.1 & W4.last() = W3.k_2 by B9, lWCUT02;
        W5 is_Walk_from W4.first(), W4.last() by dSUBWALK; then
    BC: W5.first() = W3.1 & W5.last() = W3.k_2 by BB, dWALKFROM;
        W1.k = W1.last() by B3, dWLAST; then
    BD: W3 = W1.cut(1,k) by tWREMOVE09;
        k_2 in dom W3 by BA, B9, FINSEQ_3:27; then
    BE: W5.last() = W1.k_2 by B3, BC, BD, lWCUT11;
    BF: k_2 < len W3 - 0 by B8, REAL_1:92; then
        k_2+1 <= k by B8, NAT_1:38; then
    BG: k_2+1 <= len W1 by B3, AXIOMS:22;
    BZ: len W4 = k_2 by BF, lWCUT10;
    BH: now assume
        C1: e in W5.edges();
            W5.edges() c= W4.edges() by tSUBWALK06; then
            consider n being even Nat such that
        C2: 1 <= n & n <= len W4 & W4.n = e by C1,lWEDGES01;
            n in dom W4 by C2, FINSEQ_3:27; then
        C3: e = W3.n by B9, C2, lWCUT11;
            n <= k_2+2 by BZ,C2,NAT_1:37; then
            n in dom W3 by C2, B8, FINSEQ_3:27; then
        C7: W1.(k_2+1) = W1.n by B3, BD, C3, lWCUT11;
            n < k_2+1 by BZ,C2,NAT_1:38; 
            hence contradiction by BG, C2, C7, lTLWALK01;
        end;
    BI: now assume
        C1: W5 is non trivial & W5 is closed; then
        C2: W5.first() = W1.k_2 by BE, dCLWALK;
            1 <= len W3 by HEYTING3:1; then
            2*0+1 in dom W3 by FINSEQ_3:27; then
        C3: W1.k_2 = W1.(len W1) by B1, B3, BC, BD, C2, lWCUT11;
            now assume k_2 = 1; then
                len W4 = 1 by B9, lWCUT10; then
                1 <= len W5 & len W5 <= 1 by HEYTING3:1, lSUBWALK05; then
                len W5 = 1 by AXIOMS:21;
                hence contradiction by C1, lTVWALK02;
            end; then
        C4: 1 < k_2 by BA, REAL_1:def 5;
        C5: k_2 < k - 0 by REAL_1:92; then
            k_2 <= len W1 by B3, AXIOMS:22;
            hence contradiction by B3,C3,C4,C5;
        end;
        now let m be odd Nat; assume
        C1: 1 < m & m <= len W5; then consider n being odd Nat such that
        C2: m <= n & n <= len W4 & W5.m = W4.n by tSUBWALK07;
        C3: 1 < n by C1, C2, AXIOMS:22; then
            n in dom W4 by C2, FINSEQ_3:27; then
        C4: W5.m = W3.n by B9, C2, lWCUT11;
        C5: n+0 < k_2+2 by C2, BZ, REAL_1:67; then
            n in dom W3 by  B8, C3, FINSEQ_3:27; then
        C7: W5.m = W1.n by B3, BD, C4, lWCUT11;
            n <= len W1 by B3, C5, AXIOMS:22; 
            hence W5.m <> W1.k by C3, B3, C5, C7;
        end; then
        reconsider W2 as Path of G by BE,B7,BH,BI,tPLWALK06;
        1 <= len W3 by HEYTING3:1; then
        2*0+1 in dom W3 by FINSEQ_3:27; then
    BK: W5.first() = W1.1 by B3, BC, BD, lWCUT11
                  .= W1.first() by dWFIRST;
    XX: k_2 in dom W3 by BA, BF, FINSEQ_3:27; then
    BY: W5.last() = W1.k_2 by B3, BC, BD, lWCUT11; then
        W5 is_Walk_from W1.first(), W1.k_2 by BK, dWALKFROM; then
        W2 is_Walk_from W1.first(), W1.k by B7, lWADDEDGE05; then
    BL: W2 is_Walk_from W1.first(), W1.last() by B3, dWLAST;
        consider es5 being FinSubsequence of W4.edgeSeq() such that
    BM: W5.edgeSeq() = Seq es5 by dSUBWALK;
    BN: W4.edgeSeq() c= W3.edgeSeq() by lWESEQ05;
        W3.edgeSeq() c= W1.edgeSeq() by BD, lWESEQ05; then
    BO: W4.edgeSeq() c= W1.edgeSeq() by BN, XBOOLE_1:1;
        es5 c= W4.edgeSeq() by GRAPH_2:def 5; then
    BP: es5 c= W1.edgeSeq() by BO, XBOOLE_1:1; then
        reconsider es5 as FinSubsequence of W1.edgeSeq() by GRAPH_2:def 5;
        set g = ((k_2+1) div 2) .--> e, es = es5 +* g;
    BR: dom es = dom es5 \/ dom g & for x st x in dom es5 \/ dom g
          holds (x in dom g implies es.x = g.x) &
          (not x in dom g implies es.x = es5.x) by FUNCT_4:def 1;
    BS: dom g = {(k_2+1) div 2} & rng g = {e} by CQC_LANG:5;
    BT: g.((k_2+1) div 2) = e by CQC_LANG:6;
        now let z be set; assume
        C1: z in es; then consider x,y being set such that
        C2: z = [x,y] by RELAT_1:def 1;
        C3: x in dom es & y = es.x by C1,C2, FUNCT_1:8; 
            now per cases;
            suppose
            D0: x in dom g; then
            D1: x = (k_2+1) div 2 by BS, TARSKI:def 1;
                1 <= k_2+1 by NAT_1:37; then
            D2: x in dom W1.edgeSeq() & W1.(k_2+1) = W1.edgeSeq().x
                  by BG,D1,lWESEQ01;
                W1.edgeSeq().x = y by BR,BT,C3,D0,D1,D2;
                hence z in W1.edgeSeq() by C2, D2, FUNCT_1:8; end;
            suppose
            D1: not x in dom g; then
            D2: x in dom es5 by BR, C3, XBOOLE_0:def 2;
                y = es5.x by BR, C3, D1; then
                z in es5 by C2,D2,FUNCT_1:8;
                hence z in W1.edgeSeq() by BP; end;
            end;
            hence z in W1.edgeSeq();
        end; then
    BU: es c= W1.edgeSeq() by TARSKI:def 3; then
        dom es c= dom W1.edgeSeq() by RELAT_1:25; then
    BV: dom es c= Seg len W1.edgeSeq() by FINSEQ_1:def 3; then
        reconsider es as FinSubsequence by FINSEQ_1:def 12;
        reconsider es as FinSubsequence of W1.edgeSeq() by BU, GRAPH_2:def 5;
    BW: dom es5 c= dom W4.edgeSeq() by GRAPH_2:27;
        now thus dom es5 c= Seg len W1.edgeSeq() &
              dom g c= Seg len W1.edgeSeq() by BR,XBOOLE_1:11,BV;
            let x,y be Nat such that
        C1: x in dom es5 & y in dom g;
        C2: y = (k_2+1) div 2 by BS, C1, TARSKI:def 1;
            2 divides k_2+1 by PEPIN:22; then
        C3: 2*y = k_2+1 by C2, NAT_1:49;
            x <= len W4.edgeSeq() by BW,C1,FINSEQ_3:27; then
            2*x <= 2*len W4.edgeSeq() by AXIOMS:25; then
            2*x+1 <= 2*len W4.edgeSeq()+1 by REAL_1:55; then
            2*x+1 <= k_2 by BZ, dWESEQ; then
            2*x+1 < 2*y by C3, NAT_1:38; then
        C4: 2*x+1-1 < 2*y - 0 by REAL_1:92; then
            x <= y by tREAL01;
            hence x < y by C4, REAL_1:def 5;
        end; then
    BX: Sgm(dom es) = Sgm(dom es5) ^ Sgm(dom g) by BR, FINSEQ_3:48;
        now
        C1: e Joins W5.last(), W1.k, G by B7,XX,B3,BC,BD,lWCUT11;
            len W2 = len W5 + 2 by B7,BY,lWADDEDGE03; then
        C2: len W5 + 2 = 2 * len W2.edgeSeq() + 1 by dWESEQ;
        C3: len Seq es = card es by tFINSUBSEQ03
                      .= card dom es by tCARD01;
            now assume dom es5 /\ dom g <> {}; then
                consider x being set such that
            D1: x in dom es5 /\ dom g by XBOOLE_0:def 1;
            D2: x in dom es5 & x in dom g by D1, XBOOLE_0:def 3; then
            D3: x = (k_2+1) div 2 by BS, TARSKI:def 1;
                (k_2+1) div 2 <= len W4.edgeSeq() by BW,D2,D3,FINSEQ_3:27; then
            D4: 2 * ((k_2+1) div 2) <= 2*len W4.edgeSeq() by AXIOMS:25;
                2 divides (k_2+1) by PEPIN:22; then
                k_2+1 <= 2*len W4.edgeSeq() by D4, NAT_1:49; then
                k_2+1+1 <= 2*len W4.edgeSeq()+1 by REAL_1:55; then
                (1+1)+k_2 <= 0 + k_2 by BZ,dWESEQ;
                hence contradiction by REAL_1:53;
            end; then
        CY: dom es5 misses dom g by XBOOLE_0:def 7; then
            len Seq es = card dom es5 + card dom g by BR,C3,CARD_2:53
                      .= card dom es5 + 1 by BS, CARD_1:79
                      .= card es5 + 1 by tCARD01
                      .= len W5.edgeSeq() + 1 by BM, tFINSUBSEQ03; then
            2 * len Seq es + 1 = 2*len W5.edgeSeq() + 1 + 2
                              .= 2 * len W2.edgeSeq() + 1 by C2, dWESEQ; then
            2 * len Seq es = 2 * len W2.edgeSeq() by XCMPLX_1:2;
            hence
        C4: len W2.edgeSeq() = len Seq es by XCMPLX_1:5;
            let x be Nat; assume
        C5: 1 <= x & x <= len W2.edgeSeq();
            set h = Sgm dom es;
        C7: Seq es = es * h by FINSEQ_1:def 14;
        C8: x in dom (Seq es) by C4, C5, FINSEQ_3:27; then
        C9: x in dom h & h.x in dom es by C7,FUNCT_1:21;
        CA: (Seq es).x = es.(h.x) by C7, C8, FUNCT_1:22;
        CB: dom h = Seg (len Sgm(dom es5) + len (Sgm dom g)) &
              (for x being Nat st x in dom Sgm dom es5 holds
               h.x = Sgm(dom es5).x) &
              (for x being Nat st x in dom Sgm dom g holds
                h.(len Sgm(dom es5) + x) = (Sgm dom g).x)
                by BX, FINSEQ_1:def 7;
        CC: Sgm dom g = Sgm {(k_2+1) div 2} by CQC_LANG:5;
            now assume k_2+1 div 2 = 0; then
            D1: 2 * ((k_2+1) div 2) = 2*0;
                2 divides k_2+1 by PEPIN:22;
                hence contradiction by D1,NAT_1:49;
            end; then
            Sgm dom g = <* (k_2+1) div 2 *> by CC, FINSEQ_3:50; then
        CE: len Sgm dom g = 1 & (Sgm dom g).1 = (k_2+1) div 2 by FINSEQ_1:57;
        CZ: dom es5 c=Seg len W1.edgeSeq() by BR,BV,XBOOLE_1:11;then
        CF: len Sgm(dom es5) = card dom es5 by FINSEQ_3:44
                            .= card es5 by tCARD01
                            .= len W5.edgeSeq() by BM, tFINSUBSEQ03;
            now per cases;
            suppose
            D0: x <= len Sgm (dom es5); then
            D1: x in dom Sgm dom es5 by C5, FINSEQ_3:27; then
            D2: h.x = Sgm(dom es5).x by BX, FINSEQ_1:def 7;
                rng Sgm(dom es5) = dom es5 by CZ, FINSEQ_1:def 13; then
                h.x in dom es5 by D1, D2, FUNCT_1:def 5; then
                not h.x in dom g by CY, XBOOLE_0:3; then
            D3: (Seq es).x = es5.(Sgm(dom es5).x) by C9,CA,BR,D2;
            D5: W5.edgeSeq().x = W5.(2*x) by CF,D0,C5, dWESEQ;
            D6: x in dom W5.edgeSeq() by C5,CF,D0,FINSEQ_3:27; then
                2*x in dom W5 by lWESEQ02; then
            D7: W2.(2*x) = W5.edgeSeq().x by C1, D5, lWADDEDGE04
                        .= (es5 * Sgm(dom es5)).x by BM, FINSEQ_1:def 14;
                x in dom (es5 * Sgm(dom es5)) by BM,D6,FINSEQ_1:def 14;
                hence (Seq es).x = W2.(2*x) by D3,D7,FUNCT_1:22; end;
            suppose len Sgm (dom es5) < x; then
            D1: len Sgm(dom es5) + 1 <= x by NAT_1:38; 
                x <= len Sgm(dom es5) + 1 by C9,CB,CE,FINSEQ_1:3; then
            D2: x = len Sgm(dom es5) + 1 by D1, AXIOMS:21;
                1 in dom Sgm(dom g) by CE, FINSEQ_3:27; then
            D3: h.x = (k_2+1) div 2 by BX,FINSEQ_1:def 7,CE,D2; 
                 h.x in dom g by D3, BS, TARSKI:def 1; then
                 D5: (Seq es).x = g.((k_2+1) div 2) by BR,C9,D3,CA
                          .= e by CQC_LANG:6
                          .= W2.(len W5 + 1) by C1, lWADDEDGE04;
                2*x = 2*len W5.edgeSeq()+1+1 by CF,D2
                   .= len W5 + 1 by dWESEQ;
                hence (Seq es).x = W2.(2*x) by D5; end;
            end;
            hence W2.edgeSeq().x = (Seq es).x by C5,dWESEQ; 
        end; then
        W2.edgeSeq() = Seq es by FINSEQ_1:18; then
        reconsider W2 as Path of W1 by BL, dSUBWALK;
        take W2;
        thus W2 is non trivial by B7,BE, tTVWALK08; end;
    end;
    hence thesis;
end;    

theorem tSUBGRAPH_W01: ::tSUBGRAPH_W01
  for G1 being _Graph, G2 being Subgraph of G1, W being Walk of G2 holds
    W is Walk of G1 proof
    let G1 be _Graph, G2 be Subgraph of G1, W be Walk of G2;
    set VG1 = the_Vertices_of G1, VG2 = the_Vertices_of G2;
    set EG1 = the_Edges_of G1, EG2 = the_Edges_of G2;
    VG2 c= VG1 \/ EG1 & EG2 c= VG1 \/ EG1 by XBOOLE_1:10; then
A3: VG2 \/ EG2 c= VG1 \/ EG1 by XBOOLE_1:8;
    for y being set st y in rng W holds y in VG1 \/ EG1
      by A3, TARSKI:def 3; then
    rng W c= VG1 \/ EG1 by TARSKI:def 3; then
A4: W is FinSequence of VG1 \/ EG1 by FINSEQ_1:def 4;
    now thus len W is odd;
        W.1 in VG2 by dWALK;
        hence W.1 in VG1;
        let n be odd Nat; assume n < len W; then
        W.(n+1) Joins W.n, W.(n+2), G2 by dWALK;
        hence W.(n+1) Joins W.n, W.(n+2), G1 by GLIB_000:75;
    end;
    hence W is Walk of G1 by A4, dWALK;
end;

theorem tSUBGRAPH_W02: ::tSUBGRAPH_W02
  for G1 being _Graph, G2 being Subgraph of G1, W being Walk of G1
   st W is trivial & W.first() in the_Vertices_of G2
   holds W is Walk of G2 proof
    let G1 be _Graph, G2 be Subgraph of G1, W be Walk of G1; assume
A1: W is trivial & W.first() in the_Vertices_of G2; then
    consider v being Vertex of G1 such that
A2: W = G1.walkOf(v) by lTVWALK04;
A3: W = <*v*> by A2,dWALKOFV;
    reconsider v'= v as Vertex of G2 by A1,A2,tWALKOFV01;
    W = G2.walkOf(v') by A3,dWALKOFV;
    hence W is Walk of G2;
end;

theorem tSUBGRAPH_W03: ::tSUBGRAPH_W03
  for G1 being _Graph, G2 being Subgraph of G1, W being Walk of G1
   st W is non trivial & W.edges() c= the_Edges_of G2
   holds W is Walk of G2 proof
    let G1 be _Graph, G2 be Subgraph of G1, W be Walk of G1; assume
A1: W is non trivial & W.edges() c= the_Edges_of G2;
    set WV = W.vertices(), WE = W.edges();
    set VG2 = the_Vertices_of G2, EG2 = the_Edges_of G2;
A2: now let n be odd Nat such that
    B1: n <= len W;
        now per cases;
        suppose
        C1: n = len W; then
        C2: n <> 1 by A1, lTVWALK01;
            1 <= n by HEYTING3:1; then
            1 < n by C2, REAL_1:def 5; then
            1+1 <= n by NAT_1:38; then
            reconsider n_2 = n-2*1 as odd Nat by INT_1:18;
            n_2 < len W - 0 by C1, REAL_1:92; then
        C4: W.(n_2+1) Joins W.n_2, W.(n_2+2), G1 by dWALK;
        C5: 1 <= n_2+1 by NAT_1:37;
            n_2+1 = n-(2-1); then
            n_2+1 <= len W-0 by C1, REAL_1:92; then
            W.(n_2+1) in W.edges() by C5, lWEDGES01; then
            W.(n_2+1) Joins W.n_2, W.(n_2+2), G2 by A1,GLIB_000:76, C4;
            hence W.n in the_Vertices_of G2 by GLIB_000:16; end;
        suppose n <> len W; then
        C1: n < len W by B1, REAL_1:def 5; then
        C2: W.(n+1) Joins W.n, W.(n+2), G1 by dWALK;
        C3: 1 <= n+1 by NAT_1:37;
            n+1 <= len W by C1, NAT_1:38; then
            W.(n+1) in W.edges() by C3, lWEDGES01; then
            W.(n+1) Joins W.n, W.(n+2), G2 by A1,C2, GLIB_000:76;
            hence W.n in the_Vertices_of G2 by GLIB_000:16; end;
        end;
        hence W.n in VG2;
    end;
    now let y be set; assume y in rng W; then
    B1: y in WV \/ WE by tWEDGES03;
        now per cases by B1, XBOOLE_0:def 2;
        suppose y in WV; then consider n being odd Nat such that
        C1: n <= len W & W.n = y by lWVERTICES01;
            y in VG2 by A2, C1;
            hence y in VG2 \/ EG2 by XBOOLE_0:def 2; end;
        suppose y in WE;
            hence y in VG2 \/ EG2 by A1,XBOOLE_0:def 2; end;
        end;
        hence y in VG2 \/ EG2;
    end; then
    rng W c= VG2 \/ EG2 by TARSKI:def 3; then
A3: W is FinSequence of VG2 \/ EG2 by FINSEQ_1:def 4;
    now thus len W is odd;
        reconsider _1 = 1 as odd Nat by JORDAN12:3;
        _1 <= len W by HEYTING3:1;
        hence W.1 in VG2 by A2;
        let n be odd Nat; set e = W.(n+1); assume
    B1: n < len W; then
    B2: W.(n+1) Joins W.n, W.(n+2), G1 by dWALK;
        1 <= n+1 & n+1 <= len W by B1,NAT_1:37,NAT_1:38; then
        W.(n+1) in W.edges() by lWEDGES01;
        hence W.(n+1) Joins W.n, W.(n+2), G2 by A1,B2, GLIB_000:76;
    end;
    hence W is Walk of G2 by A3, dWALK;
end;    

theorem tSUBGRAPH_W04: ::tSUBGRAPH_W04
  for G1 being _Graph, G2 being Subgraph of G1, W being Walk of G1
   st W.vertices() c= the_Vertices_of G2 & W.edges() c= the_Edges_of G2
   holds W is Walk of G2 proof
    let G1 be _Graph, G2 be Subgraph of G1, W be Walk of G1; assume
A1: W.vertices() c= the_Vertices_of G2 & W.edges() c= the_Edges_of G2;
    now per cases;
    suppose W is non trivial;
         hence thesis by A1, tSUBGRAPH_W03; end;
    suppose
    B1: W is trivial;
        W.first() in W.vertices() by tWVERTICES02;
        hence thesis by A1,B1,tSUBGRAPH_W02; end;
    end;
    hence thesis;
end;

theorem ::tSUBGRAPH_W05
  for G1 being non trivial _Graph, W being Walk of G1, v being Vertex of G1,
      G2 being removeVertex of G1,v st not v in W.vertices()
    holds W is Walk of G2 proof
    let G1 be non trivial _Graph, W be Walk of G1, v be Vertex of G1,
        G2 be removeVertex of G1,v; assume
A1: not v in W.vertices();
    set W2 = W, VG2 = (the_Vertices_of G1) \ {v};
    set EG2 = (the_Edges_of G1) \ v.edgesInOut();
    v.edgesInOut() = G1.edgesInOut({v}) by GLIB_000:def 42; then
A2: EG2 = G1.edgesBetween( the_Vertices_of G1 \ {v}) by GLIB_000:38;
    now let y be set; assume y in rng W2; then consider x being set such that
    B1: x in dom W2 & y = W2.x by FUNCT_1:def 5;
        reconsider x as Nat by B1;
    B2: 1 <= x & x <= len W2 by B1, FINSEQ_3:27;
        now per cases;
        suppose
        C1: x is odd; then
        C2: y in the_Vertices_of G1 by B1, B2, lWALK02;
            now assume y in {v}; then
                not y in W.vertices() by A1,TARSKI:def 1;
                hence contradiction by B1, B2, C1,lWVERTICES01;
            end; then
            y in VG2 by C2, XBOOLE_0:def 4;
            hence y in VG2 \/ EG2 by XBOOLE_0:def 2; end;
        suppose x is even; then reconsider x as even Nat;
            consider x_1 being odd Nat such that
        C2: x_1 = x-1 & x-1 in dom W2 & x+1 in dom W2 &
              W2.x Joins W2.(x_1), W2.(x+1),G1 by B1, lWALK04;
        C3: y in the_Edges_of G1 by B1, C2, GLIB_000:def 15;
        C4: x_1 <= len W2 & x+1 <= len W2 by C2, FINSEQ_3:27;
            now assume y in v.edgesInOut(); then
            D1: y in v.edgesIn() \/ v.edgesOut() by GLIB_000:63;
                now per cases by D1, XBOOLE_0:def 2;
                  suppose y in v.edgesIn(); then
                    (the_Target_of G1).y = v by GLIB_000:59;
                    hence v=W2.(x_1) or v = W2.(x+1) by B1,C2,GLIB_000:def 15;
                  end;
                  suppose y in v.edgesOut(); then
                    (the_Source_of G1).y = v by GLIB_000:61;
                    hence v=W2.(x_1) or v = W2.(x+1) by B1,C2,GLIB_000:def 15;
                  end;
                end; then
                v = W2.vertexAt(x_1) or v = W2.vertexAt(x+1)
                  by C4, dWVAT;
                hence contradiction by A1,C4,tWVERTICES03;
            end; then
            y in EG2 by C3, XBOOLE_0:def 4;
            hence y in VG2 \/ EG2 by XBOOLE_0:def 2; end;
        end; then
        y in (the_Vertices_of G2) \/ EG2 by GLIB_000:50;
        hence y in (the_Vertices_of G2) \/ (the_Edges_of G2) by A2,GLIB_000:50;
    end; then
    rng W2 c= (the_Vertices_of G2) \/ (the_Edges_of G2) by TARSKI:def 3; then
    reconsider W2 as FinSequence of (the_Vertices_of G2)\/(the_Edges_of G2)
      by FINSEQ_1:def 4;
    now thus len W2 is odd by dWALK;
        W.first() in the_Vertices_of G1; then
    B1: W.1 in the_Vertices_of G1 by dWFIRST;
        W.first() in W.vertices() by tWVERTICES02; then
        W.1 <> v by A1,dWFIRST; then
        not W2.1 in {v} by TARSKI:def 1; then
        W2.1 in VG2 by B1, XBOOLE_0:def 4; 
        hence W2.1 in the_Vertices_of G2 by GLIB_000:50;
        let n be odd Nat; assume
    B2: n < len W2; then
    B3: W.(n+1) Joins W.n, W.(n+2), G1 by dWALK;
    B4: W.n <> v by A1,B2,lWVERTICES01;
        reconsider lenW2 = len W2 as odd Nat by dWALK;
        set e = W.(n+1);
        n+1 <= len W2 by B2, NAT_1:38; then
        n+1 < lenW2 by REAL_1:def 5; then
        n+1+1 <= len W2 by NAT_1:38; then
    B6: W.(n+2) <> v by lWVERTICES01,A1;
    B8: W.(n+1) in the_Edges_of G1 by B3, GLIB_000:def 15;
        not W.(n+1) in v.edgesInOut() by B4, B6, B3, GLIB_000:68; then
        W.(n+1) in EG2 by B8, XBOOLE_0:def 4; then
        W.(n+1) in the_Edges_of G2 by A2,GLIB_000:50;
        hence W.(n+1) Joins W.n, W.(n+2), G2 by B3, GLIB_000:76;
    end;
    hence W is Walk of G2 by dWALK;
end;

theorem ::tSUBGRAPH_W06
  for G1 being _Graph, W being Walk of G1, e being set,
      G2 being removeEdge of G1,e st not e in W.edges()
    holds W is Walk of G2 proof
    let G1 be _Graph, W be Walk of G1, e be set, G2 be removeEdge of G1,e;
    assume
A1: not e in W.edges();    
A2: the_Vertices_of G2 = the_Vertices_of G1 &
      the_Edges_of G2 = (the_Edges_of G1) \ {e} by GLIB_000:56; then
A3: W.vertices() c= the_Vertices_of G2;
    now let x be set; assume
    B1: x in W.edges(); then
        not x in {e} by A1, TARSKI:def 1;
        hence x in the_Edges_of G2 by A2, B1, XBOOLE_0:def 4;
    end; then
    W.edges() c= the_Edges_of G2 by TARSKI:def 3;
    hence thesis by tSUBGRAPH_W04, A3;
end;    

theorem tSUBGRAPH_WF01: ::tSUBGRAPH_WF01
  for G1 being _Graph, G2 being Subgraph of G1, x,y,e being set
   st e Joins x,y,G2 holds
   G1.walkOf(x, e, y) = G2.walkOf(x, e, y) proof
    let G1 be _Graph, G2 be Subgraph of G1, x, y, e be set;
    assume
A1: e Joins x,y,G2; then
A2: G2.walkOf(x,e,y) = <*x,e,y*> by dWALKOFE;
    e Joins x,y,G1 by A1, GLIB_000:75;
    hence G1.walkOf(x,e,y) = G2.walkOf(x,e,y) by A2, dWALKOFE;
end;   

theorem ::tSUBGRAPH_WF02
  for G1 being _Graph, G2 being Subgraph of G1, W1 being Walk of G1,
    W2 being Walk of G2, e being set st W1 = W2 & e in W2.last().edgesInOut()
    holds W1.addEdge(e) = W2.addEdge(e) proof
    let G1 be _Graph, G2 be Subgraph of G1, W1 be Walk of G1,
        W2 be Walk of G2, e be set; assume
A1: W1 = W2 & e in W2.last().edgesInOut(); then
A2: e Joins W2.last(),W2.last().adj(e),G2 by GLIB_000:70;
    set W1B = G1.walkOf(W1.last(), e, W1.last().adj(e));
    set W2B = G2.walkOf(W2.last(), e, W2.last().adj(e));
A3: W1.last() = W2.last() by A1, tWFIRST01;
    W1.last().adj(e) = W2.last().adj(e) by A1, A3, GLIB_000:83; then
A4: W1B = W2B by A2, A3, tSUBGRAPH_WF01;
    thus W1.addEdge(e) = W1.append(W1B) by dWADDEDGE
                      .= W2.append(W2B) by A1, A4, tWAPPND08
                      .= W2.addEdge(e) by dWADDEDGE;
end;   

theorem tSUBGRAPH_WA01: ::tSUBGRAPH_WA01
  for G1 being _Graph, G2 being Subgraph of G1, W being Walk of G2 holds
    (W is closed          implies W is closed          Walk of G1) &
    (W is directed        implies W is directed        Walk of G1) &
    (W is trivial         implies W is trivial         Walk of G1) &
    (W is Trail-like      implies W is Trail-like      Walk of G1) &
    (W is Path-like       implies W is Path-like       Walk of G1) &
    (W is vertex-distinct implies W is vertex-distinct Walk of G1) proof
    let G1 be _Graph, G2 be Subgraph of G1, W be Walk of G2;
    reconsider W'=W as Walk of G1 by tSUBGRAPH_W01;
    hereby assume W is closed; then
        W.first() = W.last() by dCLWALK; then
        W.1 = W.last() by dWFIRST
           .= W.(len W) by dWLAST; then
        W'.first() = W'.(len W') by dWFIRST; then
        W'.first() = W'.last() by dWLAST;
        hence W is closed Walk of G1 by dCLWALK;
    end;
    hereby assume
    B1: W is directed;
        now let n be odd Nat; assume
        C1: n < len W'; then
        C2: (the_Source_of G2).(W'.(n+1)) = W'.n by B1, dDIWALK;
        C3: 1 <= n+1 by NAT_1:37;
            n+1 <= len W' by C1,NAT_1:38; then
            n+1 in dom W' by C3, FINSEQ_3:27; then
            W'.(n+1) in the_Edges_of G2 by tWALK03;
            hence (the_Source_of G1).(W'.(n+1)) = W'.n by GLIB_000:def 34, C2;
        end;
        hence W is directed Walk of G1 by dDIWALK;
    end;
    hereby assume W is trivial; then
        len W' = 1 by lTVWALK02;
        hence W is trivial Walk of G1 by lTVWALK01;
    end;
A2: now assume W is Trail-like; then
        for m,n being even Nat st 1 <= m & m < n & n <= len W
          holds W'.m <> W'.n by lTLWALK01;
        hence W is Trail-like Walk of G1 by lTLWALK01;
    end;
    hence W is Trail-like implies W is Trail-like Walk of G1;    
    now assume W is Path-like; then
        W' is Trail-like & for m,n being odd Nat st m < n & n <= len W'
          holds W'.m = W'.n implies (m=1 & n = len W') by A2,dPLWALK;
        hence W is Path-like Walk of G1 by dPLWALK;
    end;
    hence W is Path-like implies W is Path-like Walk of G1;
    hereby assume W is vertex-distinct; then
        for m,n being odd Nat st m <= len W' & n <= len W' & W'.m = W'.n
          holds m = n by dVDWALK;
        hence W is vertex-distinct Walk of G1 by dVDWALK;
    end;
    thus thesis;
end;    

theorem tSUBGRAPH_WA02: ::tSUBGRAPH_WA02
  for G1 being _Graph, G2 being Subgraph of G1, W1 being Walk of G1,
    W2 being Walk of G2 st W1 = W2 holds
    (W1 is closed          iff W2 is closed) &
    (W1 is directed        iff W2 is directed) &
    (W1 is trivial         iff W2 is trivial) &
    (W1 is Trail-like      iff W2 is Trail-like) &
    (W1 is Path-like       iff W2 is Path-like) &
    (W1 is vertex-distinct iff W2 is vertex-distinct) proof
    let G1 be _Graph, G2 be Subgraph of G1, W1 be Walk of G1, W2 be Walk of G2;
    assume
A1: W1 = W2;
A2: W1 is closed iff W1.first() = W1.last() by dCLWALK;
    W1.first() = W2.first() & W1.last() = W2.last() by A1, tWFIRST01;
    hence W1 is closed iff W2 is closed by A2,dCLWALK;
    now
        hereby assume
        C1: W1 is directed;
            now let n be odd Nat; assume
            D1: n < len W2; then
                1 <= n+1 & n+1 <= len W2 by NAT_1:38, NAT_1:37; then
                n+1 in dom W2 by FINSEQ_3:27; then
                W2.(n+1) in the_Edges_of G2 by tWALK03; then
                (the_Source_of G2).(W2.(n+1)) = (the_Source_of G1).(W2.(n+1))
                  by GLIB_000:def 34;
                hence (the_Source_of G2).(W2.(n+1)) = W2.n by A1,C1,D1,dDIWALK;
            end;
            hence W2 is directed by dDIWALK;
        end;
        assume W2 is directed;
        hence W1 is directed Walk of G1 by A1, tSUBGRAPH_WA01;
    end;
    hence W1 is directed iff W2 is directed;
    W1 is trivial iff len W2 = 1 by A1, lTVWALK02;
    hence W1 is trivial iff W2 is trivial by lTVWALK02;
    W1 is Trail-like iff for m,n being even Nat st 1 <= m & m < n & n <= len W2
      holds W2.m <> W2.n by A1, lTLWALK01;
    hence
A3: W1 is Trail-like iff W2 is Trail-like by lTLWALK01;
    W1 is Path-like iff (W1 is Trail-like & for m,n being odd Nat
      st m < n & n <= len W2 holds W2.m = W2.n implies (m = 1 & n = len W2))
      by A1, dPLWALK;
    hence W1 is Path-like iff W2 is Path-like by A3, dPLWALK;
    W1 is vertex-distinct iff
      (for m,n being odd Nat st m <= len W2 & n <= len W2 & W2.m = W2.n
        holds m = n) by A1,dVDWALK;
    hence W1 is vertex-distinct iff W2 is vertex-distinct by dVDWALK;
end;

theorem ::tGPEQ_VSEQ01
  G1 == G2 & x is VertexSeq of G1 implies x is VertexSeq of G2 proof assume
A1: G1 == G2 & x is VertexSeq of G1; then
    reconsider x2 = x as FinSequence of the_Vertices_of G2
      by GLIB_000:def 36;
    now let n be Nat; assume
        1 <= n & n < len x2; then
        consider e being set such that
    B2: e Joins x2.n, x2.(n+1), G1 by A1,dVSEQ;
        e Joins x2.n, x2.(n+1), G2 by A1,B2,GLIB_000:91;
        hence ex e being set st e Joins x2.n, x2.(n+1), G2;
    end;
    hence thesis by dVSEQ;
end;  

theorem ::tGPEQ_ESEQ01
  G1 == G2 & x is EdgeSeq of G1 implies x is EdgeSeq of G2 proof assume
A1: G1 == G2 & x is EdgeSeq of G1; then
    reconsider es = x as EdgeSeq of G1;
    consider vs being FinSequence of the_Vertices_of G1 such that
A2: len vs = len es + 1 & for n being Nat st 1 <= n & n <= len es holds
      es.n Joins vs.n,vs.(n+1),G1 by dESEQ;
    reconsider es2 = es as FinSequence of the_Edges_of G2
      by A1,GLIB_000:def 36;
    now reconsider vs as FinSequence of the_Vertices_of G2
          by A1,GLIB_000:def 36;
        take vs;
        thus len vs = len es + 1 by A2;
        let n be Nat; assume 1 <= n & n <= len es2; then
        es2.n Joins vs.n,vs.(n+1),G1 by A2; 
        hence es2.n Joins vs.n,vs.(n+1),G2 by A1,GLIB_000:91;
    end;
    hence thesis by dESEQ;
end;  

theorem ::tGPEQ_WALK01
  G1 == G2 & x is Walk of G1 implies x is Walk of G2 proof assume
A1: G1 == G2 & x is Walk of G1; then
A2: the_Vertices_of G1 = the_Vertices_of G2 &
    the_Edges_of G2 = the_Edges_of G1 by GLIB_000:def 36; then
    reconsider W = x as FinSequence of the_Vertices_of G2 \/ the_Edges_of G2
      by A1;
A3: len W is odd & W.1 in the_Vertices_of G2 by A1,A2,dWALK;
    now let n be odd Nat; assume n < len W; then
        W.(n+1) Joins W.n, W.(n+2), G1 by A1, dWALK;
        hence W.(n+1) Joins W.n, W.(n+2), G2 by A1,GLIB_000:91;
    end;
    hence thesis by A3,dWALK;
end;  

theorem ::tGPEQ_WF01
  G1 == G2 implies G1.walkOf(x,e,y) = G2.walkOf(x,e,y) proof assume
A1: G1 == G2;
    now per cases;
    suppose
    B1: e Joins x,y,G1; then
    B2: e Joins x,y,G2 by A1, GLIB_000:91;
        thus G1.walkOf(x,e,y) = <*x,e,y*> by B1, dWALKOFE
                             .= G2.walkOf(x,e,y) by B2, dWALKOFE; end;
    suppose
    B1: not e Joins x,y,G1; then
    B2: not e Joins x,y,G2 by A1,GLIB_000:91;
        thus G1.walkOf(x,e,y) = G1.walkOf(choose the_Vertices_of G1)
                                by B1,dWALKOFE
                             .= <* choose the_Vertices_of G1 *> by dWALKOFV
                             .= <* choose the_Vertices_of G2 *>
                                by A1, GLIB_000:def 36
                             .= G2.walkOf(choose the_Vertices_of G2)
                                by dWALKOFV
                             .= G2.walkOf(x,e,y) by B2, dWALKOFE; end;
    end;
    hence thesis;
end;

theorem ::tGPEQ_WA01
  for W1 being Walk of G1, W2 being Walk of G2 st G1 == G2 & W1 = W2 holds
    (W1 is closed          iff W2 is closed) &
    (W1 is directed        iff W2 is directed) &
    (W1 is trivial         iff W2 is trivial) &
    (W1 is Trail-like      iff W2 is Trail-like) &
    (W1 is Path-like       iff W2 is Path-like) &
    (W1 is vertex-distinct iff W2 is vertex-distinct) proof
    let W1 be Walk of G1, W2 be Walk of G2; assume
A1: G1 == G2 & W1 = W2; then
    G1 is Subgraph of G2 by GLIB_000:90;
    hence thesis by A1,tSUBGRAPH_WA02;
end;    
