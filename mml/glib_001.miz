:: Walks in a Graph
::  by Gilbert Lee
::
:: Received February 22, 2005
:: Copyright (c) 2005 Association of Mizar Users

environ

 vocabularies ARYTM_1, ARYTM_3, BOOLE, CARD_1, CAT_1, FINSEQ_1, FINSEQ_5,
      FINSET_1, FUNCT_1, FUNCT_4, GRAPH_1, GRAPH_2, GLIB_000, GLIB_001,
      MATRIX_2, MCART_1, MSAFREE2, NAT_1, NEWTON, PRE_TOPC, QUANTAL1, REALSET1,
      RELAT_1, TOPGEN_1, ARYTM;
 notations TARSKI, XBOOLE_0, CARD_1, NUMBERS, SUBSET_1, XCMPLX_0, XXREAL_0,
      DOMAIN_1, RELAT_1, FUNCT_1, FINSEQ_1, FINSEQ_2, GRAPH_2, FINSEQ_5,
      RELSET_1, MCART_1, FINSET_1, NAT_1, NAT_D, FUNCOP_1, FUNCT_4, GLIB_000,
      ABIAN;
 constructors DOMAIN_1, FUNCT_4, XXREAL_0, REAL_1, NAT_1, NAT_D, BINOP_2,
      RECDEF_1, FINSEQ_5, GLIB_000, ABIAN, GRAPH_2, VALUED_1, XXREAL_2;
 registrations XBOOLE_0, RELAT_1, FUNCT_1, ORDINAL1, FUNCOP_1, FINSET_1,
      XXREAL_0, XREAL_0, NAT_1, INT_1, FINSEQ_1, GLIB_000, ABIAN, GRAPH_2,
      GRAPH_3, HEYTING3, CARD_1, SUBSET_1;
 requirements ARITHM, BOOLE, NUMERALS, REAL, SUBSET;
 definitions FUNCOP_1;
 theorems CARD_1, CARD_2, FUNCOP_1, ENUMSET1, FINSEQ_1, FINSEQ_2, FINSEQ_3,
      FINSEQ_4, FINSEQ_5, FINSEQ_6, FINSET_1, FUNCT_1, FUNCT_4, GLIB_000,
      GRAPH_2, GRAPH_5, INT_1, JORDAN12, MCART_1, NAT_1, NAT_2, PEPIN, RELAT_1,
      TARSKI, XBOOLE_0, XBOOLE_1, XREAL_1, PRE_CIRC, XXREAL_0, HEYTING3,
      ORDINAL1, NAT_D;
 schemes FINSEQ_1, FUNCT_1, NAT_1, RECDEF_1;

begin :: Preliminaries

theorem Th1: ::tODD01
  for x,y being odd Element of NAT holds x < y iff x + 2 <= y
proof
  let x,y be odd Element of NAT;
  hereby
    assume x < y;
    then x + 1 <= y by NAT_1:13;
    then x + 1 < y by XXREAL_0:1;
    then x + 1 + 1 < y + 1 by XREAL_1:10;
    hence x + 2 <= y by NAT_1:13;
  end;
  assume x + 2 <= y;
  then x + 2 - 2 < y - 0 by XREAL_1:17;
  hence x < y;
end;

theorem Th2: ::tSGM01
  for X being set, k being Element of NAT st X c= Seg k holds
  for m,n being Element of NAT st m in dom (Sgm X) & n = (Sgm X).m
  holds m <= n
proof
  let X be set, k be Element of NAT;
  assume
A1: X c= Seg k;
  let m, n be Element of NAT;
  assume
A2: m in dom (Sgm X) & n = (Sgm X).m;
  defpred P[Nat] means ($1 in dom (Sgm X) &
  (ex n being Element of NAT st n=(Sgm X).$1 &
  $1 <= n)) or (not $1 in dom (Sgm X));
  now 1 <= m & m <= len (Sgm X) by A2,FINSEQ_3:27;
    then 1 <= len (Sgm X) by XXREAL_0:2;
    hence 1 in dom (Sgm X) by FINSEQ_3:27;
    then
A3: (Sgm X).1 in rng (Sgm X) by FUNCT_1:12;
    set n = (Sgm X).1;
    reconsider n as Element of NAT by A3;
    take n;
    thus n = (Sgm X).1;
    rng (Sgm X) = X by A1,FINSEQ_1:def 13;
    hence 1 <= n by A1,A3,FINSEQ_1:3;
  end;
  then
A4: P[1];
  now
    let x be non empty Nat;
    assume
A5: P[x];
    now per cases by A5;
      suppose
A6:     x in dom (Sgm X) & ex n being Element of NAT
        st n = (Sgm X).x & x <= n;
        then
A7:     1 <= x by FINSEQ_3:27;
A8:     x+0 < x+1 by XREAL_1:10;
        consider n being Element of NAT such that
A9:     n = Sgm(X).x & x <= n by A6;
        now
          assume
A10:      x+1 in dom (Sgm X);
          set n1 = (Sgm X).(x+1);
          (Sgm X).(x+1) in rng (Sgm X) by A10,FUNCT_1:12;
          then reconsider n1 as Element of NAT;
          take n1;
          thus n1 = (Sgm X).(x+1);
          x+1 <= len Sgm X by A10,FINSEQ_3:27;
          then n < n1 by A1,A7,A8,A9,FINSEQ_1:def 13;
          then x < n1 by A9,XXREAL_0:2;
          hence x+1 <= n1 by NAT_1:13;
        end;
        hence P[x+1];
      end;
      suppose not x in dom (Sgm X);
        then x < 0+1 or x > len Sgm X by FINSEQ_3:27;
        then x+1 > len Sgm X + 0 by NAT_1:13;
        hence P[x+1] by FINSEQ_3:27;
      end;
    end;
    hence P[x+1];
  end;
  then
A11: for x being non empty Nat st P[x] holds P[x+1];
A12: for x being non empty Nat holds P[x]
  from NAT_1:sch 10(A4,A11);
  reconsider m'=m as non empty Element of NAT by A2,FINSEQ_3:27;
  P[m'] by A12;
  then consider n' being Element of NAT such that
A13: n' = (Sgm X).m & m <= n' by A2;
  thus m <= n by A2,A13;
end;

theorem Th3: ::tFINSUBSEQ01
  for X being set, fs being FinSequence of X,
  fss being Subset of fs holds len (Seq fss) <= len fs
proof
  let X be set, fs be FinSequence of X, fss be Subset of fs;
  dom fss c= dom fs by GRAPH_2:27;
  then
A1: dom fss c= Seg len fs by FINSEQ_1:def 3;
A2: Seq fss = fss * Sgm(dom fss) by FINSEQ_1:def 14;
  rng (Sgm(dom fss)) = dom fss by A1,FINSEQ_1:def 13;
  then len (Seq fss) = len Sgm (dom fss) by A2,FINSEQ_2:33
    .= card (dom fss) by A1,FINSEQ_3:44
    .= card fss by PRE_CIRC:21;
  hence len (Seq fss) <= len fs by NAT_1:44;
end;

theorem Th4: ::tFINSUBSEQ02
  for X being set, fs being FinSequence of X, fss being Subset of fs,
  m being Element of NAT st m in dom Seq fss holds
  ex n being Element of NAT st n in dom fs & m <= n & (Seq fss).m = fs.n
proof
  let X be set, fs be FinSequence of X, fss be Subset of fs,
  m be Element of NAT;
  set f = Sgm(dom fss), n = f.m;
A1: Seq fss = fss * f by FINSEQ_1:def 14;
  assume
A2: m in dom Seq fss;
  then m in dom (fss * f) by FINSEQ_1:def 14;
  then
A3: m in dom f & n in dom fss by FUNCT_1:21;
  (Seq fss).m = fss.n by A1,A2,FUNCT_1:22;
  then [n, Seq(fss).m] in fss by A3,FUNCT_1:def 4;
  then
A4: n in dom fs & (Seq fss).m = fs.n by FUNCT_1:8;
  consider k being Nat such that
A5: dom fss c= Seg k by FINSEQ_1:def 12;
  k in NAT by ORDINAL1:def 13;
  hence thesis by A3,A4,A5,Th2;
end;

theorem Th5: ::tFINSUBSEQ03
  for X being set, fs being FinSequence of X, fss being Subset of fs
  holds len Seq fss = card fss
proof
  let X be set, fs be FinSequence of X, fss be Subset of fs;
A1: Seq fss = fss * Sgm(dom fss) by FINSEQ_1:def 14;
  consider k being Nat such that
A2: dom fss c= Seg k by FINSEQ_1:def 12;
  rng Sgm(dom fss) = dom fss by A2,FINSEQ_1:def 13;
  then dom (Seq fss) = dom (Sgm (dom fss)) by A1,RELAT_1:46;
  then dom (Seq fss) = Seg (card dom fss) by A2,FINSEQ_3:45;
  then len Seq fss = card dom fss by FINSEQ_1:def 3;
  hence len Seq fss = card fss by PRE_CIRC:21;
end;

theorem Th6: ::tFINSUBSEQ04
  for X being set, fs being FinSequence of X, fss being Subset of fs
  holds dom Seq fss = dom Sgm (dom fss)
proof
  let X be set, fs be FinSequence of X, fss be Subset of fs;
  consider k being Nat such that
A1: dom fss c= Seg k by FINSEQ_1:def 12;
A2: Seq fss = fss * Sgm (dom fss) by FINSEQ_1:def 14;
  rng Sgm(dom fss) c= dom fss by A1,FINSEQ_1:def 13;
  hence dom Seq fss = dom Sgm (dom fss) by A2,RELAT_1:46;
end;

begin :: Definitions

definition
  let G be _Graph;
  mode VertexSeq of G -> FinSequence of the_Vertices_of G means
    :Def1: ::dVSEQ
    for n being Element of NAT st 1 <= n & n < len it holds
    ex e being set st e Joins it.n, it.(n+1), G;
  existence
  proof
    set v = choose the_Vertices_of G, IT = <*v*>;
    reconsider IT as FinSequence of the_Vertices_of G;
    take IT;
    let n be Element of NAT;
    assume 1 <= n & n < len IT;
    hence thesis by FINSEQ_1:57;
  end;
end;

definition
  let G be _Graph;
  mode EdgeSeq of G -> FinSequence of the_Edges_of G means
    :Def2: ::dESEQ
    ex vs being FinSequence of the_Vertices_of G st len vs = len it + 1 &
    for n being Element of NAT st 1 <= n & n <= len it holds
    it.n Joins vs.n,vs.(n+1),G;
  existence
  proof
    set IT = <*>the_Edges_of G, vs = <*choose the_Vertices_of G*>;
    reconsider vs as FinSequence of the_Vertices_of G;
    take IT, vs;
    len vs = 0 + 1 by FINSEQ_1:57;
    hence len vs = len IT + 1;
    let n be Element of NAT;
    assume 1 <= n & n <= len IT;
    hence thesis;
  end;
end;

definition
  let G be _Graph;
  mode Walk of G -> FinSequence of the_Vertices_of G \/ the_Edges_of G means
    :Def3: ::dWALK
    len it is odd & it.1 in the_Vertices_of G &
    for n being odd Element of NAT st n < len it
    holds it.(n+1) Joins it.n, it.(n+2), G;
  existence
  proof
    set VE = (the_Vertices_of G) \/ (the_Edges_of G);
    consider v being set such that
A1: v in the_Vertices_of G by XBOOLE_0:def 1;
    reconsider v as Element of VE by A1,XBOOLE_0:def 3;
    take <*v*>;
    thus len <*v*> is odd by FINSEQ_1:57,JORDAN12:3;
    thus <*v*>.1 in the_Vertices_of G by A1,FINSEQ_1:57;
    let n be odd Element of NAT;
    assume n < len <*v*>;
    then n < 1 by FINSEQ_1:57;
    hence thesis by HEYTING3:1;
  end;
end;

registration
  let G be _Graph, W be Walk of G;
  cluster len W -> odd non empty;
  correctness
  proof
    thus len W is odd by Def3;
    hence len W is non empty by HEYTING3:1;
  end;
end;

definition
  let G be _Graph, v be Vertex of G;
  func G.walkOf(v) -> Walk of G equals  ::dWALKOFV
  <*v*>;
  coherence
  proof
    set VE = (the_Vertices_of G) \/ (the_Edges_of G), W = <*v*>, v' = v;
    reconsider v' as Element of VE by XBOOLE_0:def 3;
    <*v'*> is FinSequence of VE;
    then reconsider W as FinSequence of VE;
    now thus len W is odd by FINSEQ_1:57,JORDAN12:3;
      W.1 = v by FINSEQ_1:57;
      hence W.1 in the_Vertices_of G;
      let n be odd Element of NAT;
      assume n < len <*v*>;
      then 1 <= n & n < 1 by FINSEQ_1:57,HEYTING3:1;
      hence W.(n+1) Joins W.n, W.(n+2), G;
    end;
    hence <*v*> is Walk of G by Def3;
  end;
end;

definition
  let G be _Graph, x,y,e be set;
  func G.walkOf(x,e,y) -> Walk of G equals
  : Def5: ::dWALKOFE
  <*x,e,y*> if e Joins x,y,G otherwise G.walkOf(choose the_Vertices_of G);
  coherence
  proof
    set VE = (the_Vertices_of G)\/(the_Edges_of G);
    hereby
      assume
A1:   e Joins x,y,G;
      then x is Vertex of G & y is Vertex of G by GLIB_000:16;
      then
A2:   x is Element of VE & y is Element of VE by XBOOLE_0:def 3;
      e in the_Edges_of G by A1,GLIB_000:def 15;
      then
A3:   e is Element of VE by XBOOLE_0:def 3;
      set W = <*x,e,y*>;
      reconsider W as FinSequence of VE by A2,A3,FINSEQ_2:16;
A4:   len W = 3 & W.1 = x & W.2 = e & W.3 = y by FINSEQ_1:62;
      now reconsider aa1=1 as odd Element of NAT by JORDAN12:3;
        aa1+2 is odd;
        hence len W is odd by FINSEQ_1:62;
        thus W.1 in the_Vertices_of G by A1,A4,GLIB_000:16;
        let n be odd Element of NAT;
        assume n < len W;
        then n < 2 + 1 by FINSEQ_1:62;
        then n <= 2*1 by NAT_1:13;
        then n = 2*0 or n = 1 or n = 2*1 by NAT_1:27;
        hence W.(n+1) Joins W.n,W.(n+2),G by A1,A4;
      end;
      hence <*x,e,y*> is Walk of G by Def3;
    end;
    thus thesis;
  end;
  consistency;
end;

definition
  let G be _Graph, W be Walk of G;
  func W.first() -> Vertex of G equals   ::dWFIRST
  W.1;
  coherence by Def3;
  func W.last() -> Vertex of G equals  ::dWLAST
  W.(len W);
  coherence
  proof
    now per cases;
      suppose len W = 1;
        hence thesis by Def3;
      end;
      suppose
A1:     len W <> 1;
        1 <= len W by HEYTING3:1;
        then 1 < len W by A1,XXREAL_0:1;
        then 1+1 < len W + 1 by XREAL_1:10;
        then 2 <= len W by NAT_1:13;
        then reconsider n = len W - 2 * 1 as odd Element of NAT by INT_1:18;
A2:     n + 2 = len W;
        then n < len W by NAT_1:16;
        then W.(n+1) Joins W.n, W.(len W), G by A2,Def3;
        hence thesis by GLIB_000:16;
      end;
    end;
    hence thesis;
  end;
end;

definition
  let G be _Graph, W be Walk of G, n be Nat;
  func W.vertexAt(n) -> Vertex of G equals
  :Def8: ::dWVAT
  W.n if n is odd & n <= len W otherwise W.first();
  correctness
  proof
    hereby
      assume
A1:   n is odd & n <= len W;
      reconsider n1 = n as Element of NAT by ORDINAL1:def 13;
      now per cases;
        suppose n = len W;
          then W.n = W.last();
          hence W.n is Vertex of G;
        end;
        suppose n <> len W;
          then n < len W by A1,XXREAL_0:1;
          then W.(n1+1) Joins W.n, W.(n+2), G by A1,Def3;
          hence W.n is Vertex of G by GLIB_000:16;
        end;
      end;
      hence W.n is Vertex of G;
    end;
    thus thesis;
  end;
end;

definition
  let G be _Graph, W be Walk of G;
  func W.reverse() -> Walk of G equals  ::dWREV
  Rev W;
  coherence
  proof
    set W' = Rev W;
    reconsider W' as FinSequence of (the_Vertices_of G)\/(the_Edges_of G);
A1: len W' = len W by FINSEQ_5:def 3;
    now thus len W' is odd by A1;
      W'.1 = W.last() by FINSEQ_5:65;
      hence W'.1 in the_Vertices_of G;
      let n be odd Element of NAT;
      assume
A2:   n < len W';
A3:   now 1 <= n & n <= len W by A2,FINSEQ_5:def 3,HEYTING3:1;
        hence n in dom W by FINSEQ_3:27;
A4:     1 <= n+1 & 1 <= n+2 by NAT_1:12;
A5:     n+1 <= len W by A1,A2,NAT_1:13;
        hence n+1 in dom W by A4,FINSEQ_3:27;
        n+1 < len W by A5,XXREAL_0:1;
        then n+1+1 <= len W by NAT_1:13;
        hence n+2 in dom W by A4,FINSEQ_3:27;
      end;
      then
A6:   n <= len W & n+1 <= len W & n+2 <= len W by FINSEQ_3:27;
      set rn = len W-n+1, rnaa1 = len W-(n+1)+1, rn2 = len W-(n+2)+1;
      reconsider rn as odd Element of NAT by A6,FINSEQ_5:1;
      reconsider rn2 as odd Element of NAT by A6,FINSEQ_5:1;
      reconsider rnaa1 as even Element of NAT by A6,FINSEQ_5:1;
      1+0 < n+2 by XREAL_1:10;
      then len W - (n+2) < len W - 1 by XREAL_1:17;
      then len W - (n+2) + 1 < len W - 1 + 1 by XREAL_1:10;
      then
A7:   W.(rn2+1) Joins W.rn2, W.(rn2+2), G by Def3;
A8:   W'.n = W.rn by A3,FINSEQ_5:61
        .= W.(rn2+2);
      W'.(n+1) = W.(rnaa1) by A3,FINSEQ_5:61
        .= W.(rn2+1);
      then W'.(n+1) Joins W'.(n+2), W'.n, G by A3,A7,A8,FINSEQ_5:61;
      hence W'.(n+1) Joins W'.n, W'.(n+2), G by GLIB_000:17;
    end;
    hence Rev W is Walk of G by Def3;
  end;
end;

definition
  let G be _Graph, W1, W2 be Walk of G;
  func W1.append(W2) -> Walk of G equals
  :Def10: ::dWAPPND
  W1 ^' W2 if W1.last() = W2.first() otherwise W1;
  correctness
  proof
    set W = W1 ^' W2, lenW = len W;
    hereby
      assume
A1:   W1.last() = W2.first();
A2:   W2 <> {} by CARD_1:47;
A3:   now
        assume len W is even;
        then reconsider lenW as even Element of NAT;
        lenW + 1 = len W1 + len W2 by A2,GRAPH_2:13;
        hence contradiction;
      end;
      1 <= len W1 by HEYTING3:1;
      then
A4:   W.1 = W1.first() by GRAPH_2:14;
      now
        let n be odd Element of NAT such that
A5:     n < len W;
        set v1 = W.n, v2 = W.(n+2), e = W.(n+1);
        now per cases;
          suppose
A6:         n+2 <= len W1;
A7:         1 <= n by HEYTING3:1;
A8:         n < len W1 by A6,NAT_1:16,XXREAL_0:2;
            n+2-2 <= len W1-0 & n+2-1 <= len W1-0 by A6,XREAL_1:15;
            then W.n = W1.n & W.(n+1) = W1.(n+1) & W.(n+2) = W1.(n+2)
            by A6,A7,GRAPH_2:14,NAT_1:12;
            hence W.(n+1) Joins W.n,W.(n+2),G by A8,Def3;
          end;
          suppose
A9:         len W1 < n+2;
            then consider k being Nat such that
A10:        n + 2 = len W1 + k by NAT_1:10;
            k is even by A10;
            then reconsider k as even Element of NAT by ORDINAL1:def 13;
            k <> 0 by A9,A10;
            then 0 < k;
            then 0 + 1 < k + 1 by XREAL_1:10;
            then
A11:        1 <= k by NAT_1:13;
            n + 1 < len W + 1 by A5,XREAL_1:10;
            then n + 1 < len W1 + len W2 by A2,GRAPH_2:13;
            then n + 1 + 1 < len W1 + len W2 + 1 by XREAL_1:10;
            then
A12:        k + len W1 < len W1 + (len W2 + 1) by A10;
            then k < len W2 + 1 by XREAL_1:8;
            then
A13:        k <= len W2 by NAT_1:13;
            then
A14:        k < len W2 by XXREAL_0:1;
            then
A15:        W.(n + 2) = W2.(k+1) by A10,A11,GRAPH_2:15;
            len W1 + 1 <= n+2 by A9,NAT_1:13;
            then len W1 + 1 < n+1+1 by XXREAL_0:1;
            then len W1 < n + 1 by XREAL_1:8;
            then
A16:        len W1 <= n by NAT_1:13;
            now per cases;
              suppose
A17:            n = len W1;
                then 1 <= n & n <= len W1 by HEYTING3:1;
                then
A18:            W.n = W1.(len W1) by A17,GRAPH_2:14;
                1+1+0< len W2 + 1 by A10,A12,A17,XREAL_1:8;
                then
A19:            1 < len W2 by XREAL_1:8;
                then W.(n + 1) = W2.(1+1) by A17,GRAPH_2:15;
                hence W.(n+1) Joins W.n, W.(n+2), G
                by A1,A10,A15,A17,A18,A19,Def3,JORDAN12:3;
              end;
              suppose len W1 <> n;
                then
A20:            len W1 < n by A16,XXREAL_0:1;
                then
A21:            2+len W1-len W1<k+len W1-len W1 by A10,XREAL_1:10;
                reconsider two=2*1 as even Element of NAT;
                reconsider k2 = k-two as even Element of NAT
                by A10,A20,INT_1:18,XREAL_1:10;
A22:            n + 2 = len W1 + k2 + 2 by A10;
                1+1-1 < k2 + 1 + 1 - 1 by A21,XREAL_1:16;
                then
A23:            1 <= k2 by NAT_1:13;
                k2 < k2 + (1+1) by NAT_1:16;
                then k2 < len W2 by A13,XXREAL_0:2;
                then
A24:            W.n = W2.(k2+1) by A22,A23,GRAPH_2:15;
                set kaa1 = k2+1;
                reconsider kaa1 as odd Element of NAT;
                kaa1+2 = k + 1;
                then
A25:            W2.(kaa1+2) = W.(n+2) by A10,A11,A14,GRAPH_2:15;
                kaa1 < kaa1 + 1 by NAT_1:19;
                then
A26:            kaa1 < len W2 by A13,XXREAL_0:2;
A27:            1 <= k2+1 by NAT_1:12;
                kaa1+1-1 < len W2-0 by A13,XREAL_1:17;
                then W2.(kaa1+1) = W.(len W1 + kaa1) by A27,GRAPH_2:15
                  .= W.(n+1) by A10;
                hence e Joins v1,v2,G by A24,A25,A26,Def3;
              end;
            end;
            hence e Joins v1,v2,G;
          end;
        end;
        hence e Joins v1,v2,G;
      end;
      hence W1 ^' W2 is Walk of G by A3,A4,Def3;
    end;
    thus thesis;
  end;
end;

definition
  let G be _Graph, W be Walk of G, m, n being Nat;
  func W.cut(m,n) -> Walk of G equals
  :Def11: ::dWCUT
  (m,n)-cut W if m is odd & n is odd & m <= n & n <= len W otherwise W;
  correctness
  proof
    hereby
      assume
A1:   m is odd & n is odd & m <= n & n <= len W;
      then reconsider m4 = m, n4 = n as odd Nat;
      set W2 = (m,n)-cut W, VG = the_Vertices_of G;
A2:   1 <= m & m <= n & n <= len W by A1,HEYTING3:1;
      then len W2 + m4 - m4 = n4 + 1 - m4 by GRAPH_2:def 1;
      then reconsider lenW2 = len W2 as odd Element of NAT;
      now lenW2 is odd;
        hence len W2 is odd;
        reconsider lenW2aa1 = lenW2-1 as Element of NAT by HEYTING3:1,INT_1:18;
        0 < lenW2aa1 + 1;
        then
A3:     W2.(0+1) = W.(m+0) by A2,GRAPH_2:def 1;
        1 <= m & m <= len W by A1,HEYTING3:1,XXREAL_0:2;
        then W.m = W.vertexAt(m) by A1,Def8;
        hence W2.1 in VG by A3;
        let i be odd Element of NAT;
        assume
A4:     i < len W2;
        then i + m < len W2 + m by XREAL_1:10;
        then i + m < n + 1 by A2,GRAPH_2:def 1;
        then i + m4 <= n4 by NAT_1:13;
        then m4 + i < n4 by XXREAL_0:1;
        then
A5:     m + i < len W by A1,XXREAL_0:2;
        reconsider iaa1 = i-1 as even Element of NAT by HEYTING3:1,INT_1:18;
        iaa1 < len W2-0 by A4,XREAL_1:16;
        then
A6:     W2.(iaa1+1) = W.(m+iaa1) by A2,GRAPH_2:def 1;
        i+1 <= lenW2 by A4,NAT_1:13;
        then i+1 < len W2 by XXREAL_0:1;
        then
A7:     W2.(i+1+1) = W.(m+(i+1)) by A2,GRAPH_2:def 1;
        reconsider x=m4+i-1 as odd Element of NAT by A2,INT_1:18,NAT_1:12;
        m + i - 1 < len W - 0 by A5,XREAL_1:16;
        then W.(x+1) Joins W.x, W.(x+2), G by Def3;
        hence W2.(i+1) Joins W2.i, W2.(i+2), G by A2,A4,A6,A7,GRAPH_2:def 1;
      end;
      hence (m,n)-cut W is Walk of G by Def3;
    end;
    thus thesis;
  end;
end;

definition
  let G be _Graph, W be Walk of G, m, n be Element of NAT;
  func W.remove(m,n) -> Walk of G equals
  :Def12: ::dWREMOVE
  W.cut(1,m).append(W.cut(n,len W)) if m is odd & n is odd &
  m <= n & n <= len W & W.m = W.n otherwise W;
  correctness;
end;

definition
  let G be _Graph, W be Walk of G, e be set;
  func W.addEdge(e) -> Walk of G equals  ::dWADDEDGE
  W.append(G.walkOf(W.last(), e, W.last().adj(e)));
  coherence;
end;

definition
  let G be _Graph, W be Walk of G;
  func W.vertexSeq() -> VertexSeq of G means
  :Def14: ::dWVSEQ
  len W + 1 = 2 * len it &
  for n being Nat st 1 <= n & n <= len it holds it.n = W.(2*n - 1);
  existence
  proof
    reconsider lenW1 = len W + 1 as even Element of NAT;
    set lenIT = lenW1 div 2;
A1: 2 divides lenW1 by PEPIN:22;
    then
A2: 2*lenIT = lenW1 by NAT_D:3;
    deffunc F(Nat) = W.(2*$1-1);
    consider IT being FinSequence such that
A3: len IT = lenIT & for k being Nat st k in dom IT holds IT.k = F(k)
    from FINSEQ_1:sch 2;
    now
      let y be set;
      assume y in rng IT;
      then consider x being set such that
A4:   x in dom IT & y = IT.x by FUNCT_1:def 5;
A5:   x in Seg lenIT by A3,A4,FINSEQ_1:def 3;
      reconsider x as Element of NAT by A4;
      set 2x = x*2;
      reconsider 2x as even Element of NAT;
      set 2xaa1 = 2x-1;
      1 <= x & x <= lenIT by A5,FINSEQ_1:3;
      then
A6:   1*2 <= 2x & 2x <= lenIT * 2 by XREAL_1:66;
      then reconsider 2xaa1 as odd Element of NAT by INT_1:18,XXREAL_0:2;
      2 - 1 <= 2xaa1 & 2xaa1 <= lenW1-1 by A2,A6,XREAL_1:11;
      then W.2xaa1 = W.vertexAt(2xaa1) by Def8;
      then W.2xaa1 in the_Vertices_of G;
      hence y in the_Vertices_of G by A3,A4;
    end;
    then rng IT c= the_Vertices_of G by TARSKI:def 3;
    then reconsider IT as FinSequence of the_Vertices_of G by FINSEQ_1:def 4;
    now
      let n be Element of NAT;
      set v2 = IT.(n+1);
      assume
A7:   1 <= n & n < len IT;
      then
A8:   n in dom IT by FINSEQ_3:27;
      set 2n = 2*n;
      reconsider 2n as even Element of NAT;
      set 2naa1 = 2n-1;
      1 <= 2 & 1*2 <= n*2 by A7,XREAL_1:66;
      then reconsider 2naa1 as odd Element of NAT by INT_1:18,XXREAL_0:2;
      1 <= n+1 & n+1 <= lenIT by A3,A7,NAT_1:13;
      then n+1 in dom IT by A3,FINSEQ_3:27;
      then
A9:   v2 = W.(2*(n+1)-1) by A3
        .= W.(2n+1);
      2n <= lenW1 & 2n <> lenW1 by A2,A3,A7,XREAL_1:70;
      then
A10:  2n - 1 <= len W + 1 - 1 by XREAL_1:11;
      2naa1 <> len W by A2,A3,A7;
      then 2naa1 < len W by A10,XXREAL_0:1;
      then W.(2naa1+1) Joins W.2naa1, W.(2naa1+2), G by Def3;
      then W.(2naa1+1) Joins IT.n, W.(2naa1+2), G by A3,A8;
      hence ex e being set st e Joins IT.n, IT.(n+1), G by A9;
    end;
    then reconsider IT as VertexSeq of G by Def1;
    take IT;
    thus len W + 1 = 2 * len IT by A1,A3,NAT_D:3;
    let n be Nat;
    assume 1 <= n & n <= len IT;
    then n in dom IT by FINSEQ_3:27;
    hence IT.n = W.(2*n-1) by A3;
  end;
  uniqueness
  proof
    let IT1, IT2 be VertexSeq of G such that
A11: len W + 1 = 2 * len IT1 & for n being Nat st 1 <= n & n <= len IT1
    holds IT1.n = W.(2*n - 1) and
A12: len W + 1 = 2 * len IT2 & for n being Nat st 1 <= n & n <= len IT2
    holds IT2.n = W.(2*n - 1);
A13: dom IT1 = Seg len IT2 by A11,A12,FINSEQ_1:def 3
      .= dom IT2 by FINSEQ_1:def 3;
    now
      let n be Nat such that
A14:  n in dom IT1;
A15:  1 <= n & n <= len IT1 by A14,FINSEQ_3:27;
      then IT1.n = W.(2*n - 1) by A11;
      hence IT1.n = IT2.n by A11,A12,A15;
    end;
    hence IT1 = IT2 by A13,FINSEQ_1:17;
  end;
end;

definition
  let G be _Graph, W be Walk of G;
  func W.edgeSeq() -> EdgeSeq of G means
  :Def15: ::dWESEQ
  len W = 2*len it+1 &
  for n being Nat st 1 <= n & n <= len it holds it.n = W.(2*n);
  existence
  proof
    reconsider lenWaa1 = len W-1 as even Element of NAT by HEYTING3:1,INT_1:18;
    set lenIT = lenWaa1 div 2;
    reconsider lenIT as Element of NAT;
    2 divides lenWaa1 by PEPIN:22;
    then
A1: lenWaa1 = 2 * lenIT by NAT_D:3;
    then
A2: len W = 2 * lenIT + 1;
    deffunc F(Nat) = W.(2*$1);
    consider IT being FinSequence such that
A3: len IT = lenIT & for n being Nat st n in dom IT holds IT.n = F(n)
    from FINSEQ_1:sch 2;
    now
      let y be set;
      assume y in rng IT;
      then consider x being set such that
A4:   x in dom IT & y = IT.x by FUNCT_1:def 5;
A5:   x in Seg lenIT by A3,A4,FINSEQ_1:def 3;
      reconsider x as Element of NAT by A4;
A6:   y = W.(2*x) by A3,A4;
      reconsider 2x = 2*x as even Element of NAT;
      1 <= x & x <= lenIT by A5,FINSEQ_1:3;
      then
A7:   1*2 <= 2*x & x*2 <= lenIT*2 by XREAL_1:66;
      2 divides lenWaa1 by PEPIN:22;
      then 2x <= lenWaa1 by A7,NAT_D:3;
      then 2x + 1 <= lenWaa1 + 1 by XREAL_1:9;
      then 2x <= 2x+1 & 2x+1 <= len W by NAT_1:11;
      then
A8:   2x <= len W by XXREAL_0:2;
      reconsider 2xaa1 = 2x-1 as odd Element of NAT by A7,INT_1:18,XXREAL_0:2;
      2xaa1 < len W by A8,XREAL_1:149;
      then W.(2xaa1+1) Joins W.2xaa1, W.(2xaa1+2), G by Def3;
      hence y in the_Edges_of G by A6,GLIB_000:def 15;
    end;
    then rng IT c= the_Edges_of G by TARSKI:def 3;
    then reconsider IT as FinSequence of the_Edges_of G by FINSEQ_1:def 4;
    now
      set vs = W.vertexSeq();
      take vs;
A9:   (2 * len IT + 1) + 1 = 2 * len vs by A1,A3,Def14;
      then
A10:  2 * (len IT + 1) = 2 * len vs; thus
      len vs = len IT + 1 by A9;
      let n be Element of NAT;
      set v1 = vs.n, v2 = vs.(n+1);
      assume
A11:  1 <= n & n <= len IT;
      then
A12:  1 <= n & n <= len vs by A10,NAT_1:12;
A13:  1 <= n+1 & n+1 <= len vs by A10,A11,NAT_1:12,XREAL_1:9;
      set 2n = 2*n;
      reconsider 2n as even Element of NAT;
      set 2naa1 = 2n-1;
      1 <= n+n by A11,NAT_1:12;
      then reconsider 2naa1 as odd Element of NAT by INT_1:18;
A14:  v1 = W.(2*n-1) & v2 = W.(2*(n+1)-1) by A12,A13,Def14;
      n in dom IT by A11,FINSEQ_3:27;
      then
A15:  IT.n = W.(2naa1+1) by A3;
A16:  v2 = W.(2naa1+2) by A14;
      n*2 <= len IT*2 by A11,XREAL_1:66;
      then n*2 <= len W by A2,A3,NAT_1:12;
      then 2naa1 < len W - 0 by XREAL_1:17;
      hence IT.n Joins vs.n, vs.(n+1), G by A14,A15,A16,Def3;
    end;
    then reconsider IT as EdgeSeq of G by Def2;
    take IT;
    thus len W = 2*len IT+1 by A1,A3;
    let n be Nat;
    assume 1 <= n & n <= len IT;
    then n in dom IT by FINSEQ_3:27;
    hence IT.n = W.(2*n) by A3;
  end;
  uniqueness
  proof
    let IT1, IT2 be EdgeSeq of G such that
A17: len W = 2*len IT1 + 1 &
    for n being Nat st 1 <= n & n <= len IT1 holds IT1.n = W.(2*n) and
A18: len W = 2*len IT2 + 1 & for n being Nat st 1 <= n & n <= len IT2
    holds IT2.n = W.(2*n);
A19: dom IT1 = Seg len IT2 by A17,A18,FINSEQ_1:def 3
      .= dom IT2 by FINSEQ_1:def 3;
    now
      let n be Nat;
      assume n in dom IT1;
      then
A20:  1 <= n & n <= len IT1 & n <= len IT2 by A17,A18,FINSEQ_3:27;
      hence IT1.n = W.(2*n) by A17
        .= IT2.n by A18,A20;
    end;
    hence IT1 = IT2 by A19,FINSEQ_1:17;
  end;
end;

definition
  let G be _Graph, W be Walk of G;
  func W.vertices() -> finite Subset of the_Vertices_of G equals  ::dWVERTICES
  rng W.vertexSeq();
  coherence;
end;

definition
  let G be _Graph, W be Walk of G;
  func W.edges() -> finite Subset of the_Edges_of G equals  ::dWEDGES
  rng W.edgeSeq();
  coherence;
end;

definition
  let G be _Graph, W be Walk of G;
  func W.length() -> Element of NAT equals  ::dWLENGTH
  len W.edgeSeq();
  coherence;
end;

definition
  let G be _Graph, W be Walk of G, v be set;
  func W.find(v) -> odd Element of NAT means
  :Def19: ::dWFINDV
  it <= len W & W.it = v &
  for n being odd Nat st n <= len W & W.n = v holds it <= n if
  v in W.vertices() otherwise it = len W;
  existence
  proof
    hereby
      assume
A1:   v in W.vertices();
      set vs = W.vertexSeq();
      defpred P[Nat] means $1 is odd & $1 <= len W & W.$1 = v;
      now consider i being Nat such that
A2:     i in dom vs & vs.i = v by A1,FINSEQ_2:11;
        set n1 = 2*i;
        reconsider n1 as even Nat;
        set n = n1-1;
A3:     1 <= i & i <= len vs by A2,FINSEQ_3:27;
        then 1 <= i+i by NAT_1:12;
        then reconsider n as odd Element of NAT by INT_1:18;
        take n;
        i*2 <= len vs *2 by A3,XREAL_1:66;
        then i*2 <= len W + 1 by Def14;
        then n1 - 1 <= len W + 1 - 1 by XREAL_1:15;
        hence n <= len W;
        thus W.n = v by A2,A3,Def14;
      end;
      then
A4:   ex k being Nat st P[k];
      consider IT being Nat such that
A5:   P[IT] & for n being Nat st P[n] holds IT <= n from NAT_1:sch 5(A4);
      reconsider IT as odd Element of NAT by A5,ORDINAL1:def 13;
      take IT;
      thus IT <= len W & W.IT = v by A5;
      let n be odd Nat;
      assume n <= len W & W.n = v;
      hence IT <= n by A5;
    end;
    assume not v in W.vertices();
    set IT = len W;
    take IT;
    thus thesis;
  end;
  uniqueness
  proof
    let IT1, IT2 be odd Element of NAT;
    hereby
      assume v in W.vertices();
      assume
A6:   IT1 <= len W & W.IT1 = v &
      for n being odd Nat st n <= len W & W.n = v holds IT1 <= n;
      assume
A7:   IT2 <= len W & W.IT2 = v &
      for n being odd Nat st n <= len W & W.n = v holds IT2 <= n;
      then
A8:   IT1 <= IT2 by A6;
      IT2 <= IT1 by A6,A7;
      hence IT1 = IT2 by A8,XXREAL_0:1;
    end;
    assume not v in W.vertices();
    thus thesis;
  end;
  consistency;
end;

definition
  let G be _Graph, W be Walk of G, n be Element of NAT;
  func W.find(n) -> odd Element of NAT means
  :Def20: ::dWFINDN
  it <= len W & W.it = W.n &
  for k being odd Nat st k <= len W & W.k = W.n holds it <= k
  if (n is odd & n <= len W) otherwise it = len W;
  existence
  proof
    defpred P[Nat] means $1 is odd & $1 <= len W & W.$1 = W.n;
    hereby
      assume n is odd & n <= len W;
      then
A1:   ex n being Nat st P[n];
      consider IT being Nat such that
A2:   P[IT] & for k being Nat st P[k] holds IT <= k from NAT_1:sch 5(A1);
      reconsider IT as odd Element of NAT by A2,ORDINAL1:def 13;
      take IT;
      thus IT <= len W & W.IT = W.n by A2;
      let k be odd Nat;
      thus k <= len W & W.k = W.n implies IT <= k by A2;
    end;
    thus thesis;
  end;
  uniqueness
  proof
    let IT1, IT2 be odd Element of NAT;
    hereby
      assume n is odd & n <= len W;
      assume
A3:   IT1 <= len W & W.IT1 = W.n &
      for k being odd Nat st k <= len W & W.k = W.n holds IT1 <= k;
      assume IT2 <= len W & W.IT2 = W.n &
      for k being odd Nat st k <= len W & W.k = W.n holds IT2 <= k;
      then IT1 <= IT2 & IT2 <= IT1 by A3;
      hence IT1 = IT2 by XXREAL_0:1;
    end;
    thus thesis;
  end;
  consistency;
end;

definition
  let G be _Graph, W be Walk of G, v be set;
  func W.rfind(v) -> odd Element of NAT means
  :Def21: ::dWRFINDV
  it <= len W & W.it = v &
  for n being odd Element of NAT st n <= len W & W.n = v holds n <= it
  if v in W.vertices() otherwise it = len W;
  existence
  proof
    hereby
      assume
A1:   v in W.vertices();
      defpred P[Nat] means $1 is odd & $1 <= len W & W.$1 = v;
A2:   for k being Nat st P[k] holds k <= len W;
      W.find(v) <= len W & W.(W.find(v)) = v by A1,Def19;
      then
A3:   ex k being Nat st P[k];
      consider IT being Nat such that
A4:   P[IT] & for n being Nat st P[n] holds n <= IT from NAT_1:sch 6(A2,A3);
      reconsider IT as odd Element of NAT by A4,ORDINAL1:def 13;
      take IT;
      thus IT <= len W & W.IT = v by A4;
      let n be odd Element of NAT;
      assume n <= len W & W.n = v;
      hence n <= IT by A4;
    end;
    thus thesis;
  end;
  uniqueness
  proof
    let IT1, IT2 be odd Element of NAT;
    hereby
      assume v in W.vertices();
      assume
A5:   IT1 <= len W & W.IT1 = v &
      for n being odd Element of NAT st n <= len W & W.n = v holds n <= IT1;
      assume
A6:   IT2 <= len W & W.IT2 = v &
      for n being odd Element of NAT st n <= len W & W.n = v holds n <= IT2;
      then
A7:   IT2 <= IT1 by A5;
      IT1 <= IT2 by A5,A6;
      hence IT1 = IT2 by A7,XXREAL_0:1;
    end;
    thus thesis;
  end;
  consistency;
end;

definition
  let G be _Graph, W be Walk of G, n be Element of NAT;
  func W.rfind(n) -> odd Element of NAT means
  :Def22: ::dWRFINDN
  it <= len W & W.it = W.n &
  for k being odd Element of NAT st k <= len W & W.k = W.n holds k <= it
  if (n is odd & n <= len W) otherwise it = len W;
  existence
  proof
    defpred P[Nat] means $1 is odd & $1 <= len W & W.$1 = W.n;
    hereby
      assume n is odd & n <= len W;
      then
A1:   ex k being Nat st P[k];
A2:   for k being Nat st P[k] holds k <= len W;
      consider IT being Nat such that
A3:   P[IT] & for k being Nat st P[k] holds k <= IT from NAT_1:sch 6(A2,A1);
      reconsider IT as odd Element of NAT by A3,ORDINAL1:def 13;
      take IT;
      thus IT <= len W & W.IT = W.n by A3;
      thus for k being odd Element of NAT st k <= len W & W.k = W.n
      holds k <= IT by A3;
    end;
    thus thesis;
  end;
  uniqueness
  proof
    let IT1, IT2 be odd Element of NAT;
    hereby
      assume n is odd & n <= len W;
      assume
A4:   IT1 <= len W & W.IT1 = W.n &
      for k being odd Element of NAT st k <= len W & W.k = W.n holds k <= IT1;
      assume IT2 <= len W & W.IT2 = W.n &
      for k being odd Element of NAT st k <= len W & W.k = W.n holds k <= IT2;
      then IT1 <= IT2 & IT2 <= IT1 by A4;
      hence IT1 = IT2 by XXREAL_0:1;
    end;
    thus thesis;
  end;
  consistency;
end;

definition
  let G be _Graph, u, v be set, W be Walk of G;
  pred W is_Walk_from u,v means
  :Def23: ::dWALKFROM
  W.first() = u & W.last() = v;
end;

definition
  let G be _Graph, W be Walk of G;
  attr W is closed means
  :Def24: ::dCLWALK
  W.first() = W.last();
  attr W is directed means
  :Def25: ::dDIWALK
  for n being odd Element of NAT st n < len W
  holds (the_Source_of G).(W.(n+1)) = W.n;
  attr W is trivial means
  :Def26: ::dTVWALK
  W.length() = 0;
  attr W is Trail-like means
  :Def27: ::dTLWALK
  W.edgeSeq() is one-to-one;
end;

notation
  let G be _Graph, W be Walk of G;
  antonym W is open for W is closed;
end;

definition
  let G be _Graph, W be Walk of G;
  attr W is Path-like means
  :Def28: ::dPLWALK
  W is Trail-like &
  for m, n being odd Element of NAT st m < n & n <= len W holds
  W.m = W.n implies (m = 1 & n = len W);
end;

definition
  let G be _Graph, W be Walk of G;
  attr W is vertex-distinct means
  :Def29: ::dVDWALK
  for m,n being odd Element of NAT st m <= len W & n <= len W & W.m = W.n
  holds m = n;
end;

definition
  let G be _Graph, W be Walk of G;
  attr W is Circuit-like means
  :Def30: ::dCIWALK
  W is closed & W is Trail-like & W is non trivial;
  attr W is Cycle-like means
  :Def31: ::dCYWALK
  W is closed & W is Path-like & W is non trivial;
end;

Lm1: for G be _Graph, W be Walk of G, n being odd Element of NAT st n <= len W
holds W.n in the_Vertices_of G
proof
  let G be _Graph, W be Walk of G, n be odd Element of NAT;
  assume n <= len W;
  then W.n = W.vertexAt(n) by Def8;
  hence thesis;
end;

Lm2: for G be _Graph, W be Walk of G, n being even Element of NAT st n in dom W
holds ex naa1 being odd Element of NAT st
naa1 = n-1 & n-1 in dom W & n+1 in dom W & W.n Joins W.(naa1), W.(n+1),G
proof
  let G be _Graph, W be Walk of G, n be even Element of NAT;
  assume n in dom W;
  then
A1: 1 <= n & n <= len W by FINSEQ_3:27;
  then reconsider naa1 = n-1 as odd Element of NAT by INT_1:18;
  take naa1;
  thus naa1 = n-1;
  1 < n by A1,JORDAN12:3,XXREAL_0:1;
  then 1+1 <= n by NAT_1:13;
  then 1+1-1 <= n-1 by XREAL_1:15;
  then
A2: 1 <= naa1;
  n - 1 <= len W - 0 by A1,XREAL_1:15;
  hence n - 1 in dom W by A2,FINSEQ_3:27;
  n < len W by A1,XXREAL_0:1;
  then
A3: n+1 <= len W by NAT_1:13;
  1 <= 1+n by NAT_1:12;
  hence n+1 in dom W by A3,FINSEQ_3:27;
  n - 1 < len W - 0 by A1,XREAL_1:17;
  then W.(naa1+1) Joins W.naa1, W.(naa1+2),G by Def3;
  hence thesis;
end;

Lm3: for G be _Graph, W be Walk of G, n being odd Element of NAT st n < len W
holds n in dom W & n+1 in dom W & n+2 in dom W
proof
  let G be _Graph, W be Walk of G, n be odd Element of NAT;
  assume
A1: n < len W;
A2: 1 <= n by HEYTING3:1;
A3: 1 <= n+1 & 1 <= n+2 by NAT_1:12;
  n+1 <= len W & n+2 <= len W by A1,Th1,NAT_1:13;
  hence thesis by A1,A2,A3,FINSEQ_3:27;
end;

Lm4: for G being _Graph, v being Vertex of G holds
G.walkOf(v) is closed & G.walkOf(v) is directed & G.walkOf(v) is trivial &
G.walkOf(v) is Trail-like & G.walkOf(v) is Path-like
proof
  let G be _Graph, v be Vertex of G;
  set W = G.walkOf(v);
  W.first() = W.last() by FINSEQ_1:57;
  hence W is closed by Def24;
  now
    let n be odd Element of NAT;
    assume n < len W;
    then n < 1 by FINSEQ_1:56;
    hence W.n = (the_Source_of G).(W.(n+1)) by HEYTING3:1;
  end;
  hence W is directed by Def25;
  len W = 1 by FINSEQ_1:56;
  then 0 + 1 = 2*len W.edgeSeq() + 1 by Def15;
  then W.length() = 0;
  hence W is trivial by Def26;
  len W = 2*(len (W.edgeSeq()))+1 by Def15;
  then 0 + 1 = 2 * (len (W.edgeSeq())) + 1 by FINSEQ_1:57;
  then W.edgeSeq() = {};
  then W.edgeSeq() is one-to-one;
  hence
A1: W is Trail-like by Def27;
  now
    let n, m be odd Element of NAT;
    assume n < m & m <= len W;
    then n < m & m <= 1 by FINSEQ_1:57;
    then n < 1 by XXREAL_0:2;
    hence W.n = W.m implies (n = 1 & m = len W) by HEYTING3:1;
  end;
  hence W is Path-like by A1,Def28;
end;

Lm5: for G be _Graph, x,e,y be set holds
e Joins x,y,G implies len G.walkOf(x,e,y) = 3
proof
  let G be _Graph, x,e,y be set;
  assume e Joins x,y,G;
  then G.walkOf(x,e,y) = <*x,e,y*> by Def5;
  hence thesis by FINSEQ_1:62;
end;

Lm6: for G being _Graph, x,e,y being set holds e Joins x,y,G implies
G.walkOf(x,e,y).first() = x & G.walkOf(x,e,y).last() = y &
G.walkOf(x,e,y) is_Walk_from x,y
proof
  let G be _Graph, x,e,y be set;
  set W = G.walkOf(x,e,y);
  assume e Joins x,y,G;
  then
A1: W = <*x,e,y*> by Def5;
  then
A2: len W = 3 & W.1 = x & W.2 = e & W.3 = y by FINSEQ_1:62; thus
A3: W.first() = x by A1,FINSEQ_1:62;
  thus W.last() = y by A2;
  hence W is_Walk_from x, y by A3,Def23;
end;

Lm7: for G be _Graph, W be Walk of G holds
W.first() = W.reverse().last() & W.last() = W.reverse().first()
proof
  let G be _Graph, W be Walk of G;
  len W = len W.reverse() by FINSEQ_5:def 3;
  hence W.first() = W.reverse().last() by FINSEQ_5:65;
  thus W.last() = W.reverse().first() by FINSEQ_5:65;
end;

Lm8: for G being _Graph, W being Walk of G, n being Element of NAT holds
n in dom W.reverse() implies W.reverse().n = W.(len W - n + 1) &
(len W - n + 1) in dom W
proof
  let G be _Graph, W be Walk of G, n be Element of NAT;
  assume
A1: n in dom W.reverse();
  hence W.reverse().n = W.(len W - n + 1) by FINSEQ_5:def 3;
  n in Seg len W.reverse() by A1,FINSEQ_1:def 3;
  then n in Seg len W by FINSEQ_5:def 3;
  then len W - n + 1 in Seg len W by FINSEQ_5:2;
  hence len W - n + 1 in dom W by FINSEQ_1:def 3;
end;

Lm9: for G being _Graph, W1,W2 being Walk of G holds
W1.last() = W2.first() implies len W1.append(W2) + 1 = len W1 + len W2
proof
  let G be _Graph, W1,W2 be Walk of G;
  set W = W1.append(W2);
  assume W1.last() = W2.first();
  then
A1: W = W1 ^' W2 by Def10;
  W2 <> {} by CARD_1:47;
  hence thesis by A1,GRAPH_2:13;
end;

Lm10: for G be _Graph, W1,W2 be Walk of G holds W1.last() = W2.first() implies
len W1 <= len W1.append(W2) & len W2 <= len W1.append(W2)
proof
  let G be _Graph, W1,W2 be Walk of G;
  set W = W1.append(W2);
  assume W1.last() = W2.first();
  then
A1: len W + 1 = len W1 + len W2 by Lm9;
A2: 1 <= len W1 & 1 <= len W2 by HEYTING3:1;
  then len W1 + len W2 - len W2 <= len W + 1 - 1 by A1,XREAL_1:15;
  hence len W1 <= len W;
  len W2 + len W1 - len W1 <= len W + 1 - 1 by A1,A2,XREAL_1:15;
  hence len W2 <= len W;
end;

Lm11: for G being _Graph, W1,W2 being Walk of G holds
W1.last() = W2.first() implies
W1.append(W2).first() = W1.first() & W1.append(W2).last() = W2.last() &
W1.append(W2) is_Walk_from W1.first(), W2.last()
proof
  let G be _Graph, W1, W2 be Walk of G;
  assume
A1: W1.last() = W2.first();
  set W = W1.append(W2);
A2: W = W1 ^' W2 by A1,Def10;
  1 <= len W1 by HEYTING3:1;
  hence
A3: W.first() = W1.first() by A2,GRAPH_2:14;
  now per cases;
    suppose
A4:   len W2 <> 1;
      1 <= len W2 by HEYTING3:1;
      then 1 < len W2 by A4,XXREAL_0:1;
      hence W.last() = W2.last() by A2,GRAPH_2:16;
    end;
    suppose
A5:   len W2 = 1;
      then
A6:   W = W1^(2,1)-cut W2 by A2,GRAPH_2:def 2;
      (2,1)-cut W2 = {} by GRAPH_2:def 1;
      hence W.last() = W2.last() by A1,A5,A6,FINSEQ_1:47;
    end;
  end;
  hence thesis by A3,Def23;
end;

Lm12: for G be _Graph, W1,W2 be Walk of G, n being Element of NAT holds
n in dom W1 implies W1.append(W2).n = W1.n & n in dom W1.append(W2)
proof
  let G be _Graph, W1,W2 be Walk of G, n be Element of NAT;
  set W = W1.append(W2);
  assume
A1: n in dom W1;
  then
A2: 1 <= n & n <= len W1 by FINSEQ_3:27;
  now per cases;
    suppose
A3:   W1.last() = W2.first();
      then W = W1 ^' W2 by Def10;
      hence W.n = W1.n by A2,GRAPH_2:14;
      reconsider lenW2aa1 = len W2 - 1 as Element of NAT by HEYTING3:1,INT_1:18
;
      n <= len W1 + lenW2aa1 by A2,NAT_1:12;
      then n <= len W1 + len W2 + -1;
      then n <= len W + 1 + -1 by A3,Lm9;
      hence n in dom W by A2,FINSEQ_3:27;
    end;
    suppose W1.last() <> W2.first();
      hence W.n = W1.n & n in dom W by A1,Def10;
    end;
  end;
  hence thesis;
end;

Lm13: for G be _Graph, W1,W2 be Walk of G holds W1.last() = W2.first() implies
for n being Element of NAT st n < len W2 holds
W1.append(W2).(len W1 + n) = W2.(n+1) & (len W1 + n) in dom W1.append(W2)
proof
  let G be _Graph, W1,W2 be Walk of G;
  set W = W1.append(W2);
  assume
A1: W1.last() = W2.first();
  then
A2: W = W1 ^' W2 by Def10;
  let n be Element of NAT;
  assume
A3: n < len W2;
  now per cases;
    suppose
A4:   n = 0;
      then 1 <= len W1 + n & len W1 + n <= len W1 by HEYTING3:1;
      then len W1 + n in dom W1 by FINSEQ_3:27;
      hence W1.append(W2).(len W1 + n) = W2.(n + 1) by A1,A4,Lm12;
    end;
    suppose n <> 0;
      then 0 < n;
      then 0 + 1 < n + 1 by XREAL_1:10;
      then 1 <= n by NAT_1:13;
      hence W1.append(W2).(len W1 + n) = W2.(n+1) by A2,A3,GRAPH_2:15;
    end;
  end;
  hence W1.append(W2).(len W1 + n) = W2.(n+1);
A5: 1 <= len W1 + n by HEYTING3:1,NAT_1:12;
  n + 1 <= len W2 by A3,NAT_1:13;
  then n + 1 + len W1 <= len W2 + len W1 by XREAL_1:9;
  then len W1 + n + 1 <= len W + 1 by A1,Lm9;
  then len W1 + n <= len W by XREAL_1:8;
  hence thesis by A5,FINSEQ_3:27;
end;

Lm14: for G be _Graph, W1,W2 be Walk of G, n be Element of NAT holds
n in dom W1.append(W2) implies
n in dom W1 or ex k being Element of NAT st k < len W2 & n = len W1 + k
proof
  let G be _Graph, W1,W2 be Walk of G, n be Element of NAT;
  set W3 = W1.append(W2);
  assume
A1: n in dom W3;
  then
A2: 1 <= n & n <= len W3 by FINSEQ_3:27;
  now per cases;
    suppose W1.last() = W2.first();
      then
A3:   len W3 + 1 = len W1 + len W2 by Lm9;
      now
        assume not n in dom W1;
        then len W1 < n by A2,FINSEQ_3:27;
        then reconsider k = n - len W1 as Element of NAT by INT_1:18;
        take k;
        now
          assume len W2 <= k;
          then len W1 + len W2 <= len W1 + k by XREAL_1:9;
          hence contradiction by A2,A3,NAT_1:13;
        end;
        hence k < len W2;
        thus n = len W1+k;
      end;
      hence thesis;
    end;
    suppose W1.last() <> W2.first();
      hence thesis by A1,Def10;
    end;
  end;
  hence thesis;
end;

Lm15: for G being _Graph, W being Walk of G, m,n being odd Element of NAT
st m <= n & n <= len W holds len W.cut(m,n) + m = n+1 &
for i being Element of NAT st i < len W.cut(m,n)
holds W.cut(m,n).(i+1) = W.(m+i) & m+i in dom W
proof
  let G be _Graph, W be Walk of G, m, n be odd Element of NAT;
  set W2 = W.cut(m,n);
  assume
A1: m <= n & n <= len W;
  then
A2: W2 = (m,n)-cut W by Def11;
A3: 1 <= m & m <= n & n <= len W by A1,HEYTING3:1;
  hence
A4: len W.cut(m,n) + m = n + 1 by A2,GRAPH_2:def 1;
  let i be Element of NAT;
  assume
A5: i < len W.cut(m,n);
  hence W.cut(m,n).(i+1) = W.(m+i) by A2,A3,GRAPH_2:def 1;
A6: 1 <= m+i by HEYTING3:1,NAT_1:12;
  m+i < n + 1 by A4,A5,XREAL_1:10;
  then m+i <= n by NAT_1:13;
  then m+i <= len W by A1,XXREAL_0:2;
  hence m+i in dom W by A6,FINSEQ_3:27;
end;

Lm16: for G being _Graph, W being Walk of G, m, n being odd Element of NAT
st m <= n & n <= len W holds
W.cut(m,n).first() = W.m & W.cut(m,n).last() = W.n &
W.cut(m,n) is_Walk_from W.m, W.n
proof
  let G be _Graph, W be Walk of G, m, n be odd Element of NAT;
  set W2 = W.cut(m,n);
  assume
A1: m <= n & n <= len W;
  1-1 < len W2 - 0;
  then W2.(0+1) = W.(m+0) by A1,Lm15;
  hence
A2: W2.first() = W.m;
  reconsider nm4 = n-m as Element of NAT by A1,INT_1:18;
A3: len W2 + m - m = n + 1 - m by A1,Lm15;
  then n - m + 1 -1 < len W2 - 0 by XREAL_1:17;
  then nm4 < len W2;
  then W2.((n-m)+1) = W.(m+(n-m)) by A1,Lm15;
  hence W2.last() = W.n by A3;
  hence thesis by A2,Def23;
end;

Lm17: for G be _Graph, W be Walk of G, m,n,o being odd Element of NAT
st m <= n & n <= o & o <= len W holds
W.cut(m,n).append(W.cut(n,o)) = W.cut(m,o)
proof
  let G be _Graph, W be Walk of G, m,n,o be odd Element of NAT;
  assume
A1: m <= n & n <= o & o <= len W;
  then
A2: m <= o & n <= len W by XXREAL_0:2;
  set W1 = W.cut(m,n), W2 = W.cut(n,o), W3 = W.cut(m,o), W4 = W1.append(W2);
  now
A3: W1.last() = W.n by A1,A2,Lm16
      .= W2.first() by A1,Lm16;
A4: len W1 + m = n + 1 by A1,A2,Lm15;
A5: len W2 + n = o + 1 by A1,Lm15;
A6: len W3 + m = o + 1 by A1,A2,Lm15;
    then len W1 + len W2 + m = 1 + len W3 + m by A4,A5;
    then
A7: len W4 + 1 = len W3 + 1 by A3,Lm9;
    hence len W4 = len W4 & len W3 = len W4;
    let x be Nat;
    assume x in dom W4;
    then
A8: 1 <= x & x <= len W4 by FINSEQ_3:27;
    then reconsider xaa1 = x-1 as Element of NAT by INT_1:18;
    xaa1 < len W4 - 0 by A8,XREAL_1:17;
    then
A9: W3.(xaa1+1) = W.(m+xaa1) by A1,A2,A7,Lm15;
    now per cases;
      suppose
A10:    x <= len W1;
        then
A11:    xaa1 < len W1 - 0 by XREAL_1:17;
        x in dom W1 by A8,A10,FINSEQ_3:27;
        hence W4.x = W1.(xaa1+1) by Lm12
          .= W3.x by A1,A2,A9,A11,Lm15;
      end;
      suppose x > len W1;
        then consider k being Nat such that
A12:    len W1 + k = x by NAT_1:10;
        reconsider k as Element of NAT by ORDINAL1:def 13;
        len W1 + k + 1 <= len W3 + 1 by A7,A8,A12,XREAL_1:9;
        then (k + 1)+len W1-len W1 <= len W2 +len W1-len W1
        by A4,A5,A6,XREAL_1:15;
        then
A13:    k + 1 - 1 < len W2 + 1 - 1 by NAT_1:13;
        then W4.x = W2.(k+1) by A3,A12,Lm13
          .= W.(n+k) by A1,A13,Lm15;
        hence W4.x = W3.x by A4,A9,A12;
      end;
    end;
    hence W4.x = W3.x;
  end;
  hence thesis by FINSEQ_2:10;
end;

Lm18: for G be _Graph, W be Walk of G holds W.cut(1,len W) = W
proof
  let G be _Graph, W be Walk of G;
  1 is odd & 1 <= len W by HEYTING3:1,JORDAN12:3;
  then W.cut(1,len W) = (1,len W)-cut W by Def11;
  hence thesis by GRAPH_2:7;
end;

Lm19: for G be _Graph, W be Walk of G, n being odd Element of NAT st n <= len W
holds W.cut(n,n) = <* W.vertexAt(n) *>
proof
  let G be _Graph, W be Walk of G, n be odd Element of NAT;
  assume
A1: n <= len W;
  then
A2: W.cut(n,n) = (n,n)-cut W by Def11;
A3: W.n = W.vertexAt(n) by A1,Def8;
  1 <= n by HEYTING3:1;
  hence W.cut(n,n) = <* W.vertexAt(n) *> by A1,A2,A3,GRAPH_2:6;
end;

Lm20: for G being _Graph, W being Walk of G, m,n being Element of NAT holds
m is odd & m <= n implies W.cut(1,n).cut(1,m) = W.cut(1,m)
proof
  let G be _Graph, W be Walk of G, m,n be Element of NAT;
  set W1 = W.cut(1,n);
  assume
A1: m is odd & m <= n;
  now per cases;
    suppose
A2:   n is odd & n <= len W;
      then
A3:   1 <= n & 1 <= m & m <= len W by A1,HEYTING3:1,XXREAL_0:2;
      then
A4:   len W1 + 1 = n + 1 by A2,Lm15,JORDAN12:3;
      then
A5:   W1.cut(1,m) = (1,m)-cut W1 by A1,A3,Def11,JORDAN12:3;
A6:   len W1.cut(1,m) + 1 = m + 1 by A1,A3,A4,Lm15,JORDAN12:3;
A7:   len W.cut(1,m) + 1 = m + 1 by A1,A3,Lm15,JORDAN12:3;
A8:   W1 = (1,n)-cut W by A2,A3,Def11,JORDAN12:3;
A9:   W.cut(1,m) = (1,m)-cut W by A1,A3,Def11,JORDAN12:3;
A10:  len W.cut(1,m) + 1 = m + 1 by A1,A3,Lm15,JORDAN12:3;
      now
        let x be Nat;
        assume x in dom W1.cut(1,m);
        then
A11:    1 <= x & x <= m by A6,FINSEQ_3:27;
        then reconsider xaa1 = x-1 as Element of NAT by INT_1:18;
        x <= n by A1,A11,XXREAL_0:2;
        then
A12:    xaa1 < len W1 - 0 by A4,XREAL_1:17;
A13:    xaa1 < len W1.cut(1,m) - 0 by A6,A11,XREAL_1:17;
A14:    xaa1 < len W.cut(1,m) - 0 by A10,A11,XREAL_1:17;
        1 <= m by A11,XXREAL_0:2;
        hence W1.cut(1,m).x = W1.(1+xaa1) by A1,A4,A5,A13,GRAPH_2:def 1
          .= W.(1+xaa1) by A2,A3,A8,A12,GRAPH_2:def 1
          .= W.cut(1,m).x by A3,A9,A14,GRAPH_2:def 1;
      end;
      hence W1.cut(1,m) = W.cut(1,m) by A6,A7,FINSEQ_2:10;
    end;
    suppose not (n is odd & n <= len W);
      hence thesis by Def11;
    end;
  end;
  hence thesis;
end;

Lm21: for G be _Graph, W1,W2 be Walk of G, m,n being odd Element of NAT
st m <= n & n <= len W1 & W1.last() = W2.first()
holds W1.append(W2).cut(m,n) = W1.cut(m,n)
proof
  let G be _Graph, W1,W2 be Walk of G, m,n be odd Element of NAT;
  assume
A1: m <= n & n <= len W1 & W1.last() = W2.first();
  set W3 = W1.append(W2);
  len W1 <= len W3 by A1,Lm10;
  then
A2: n <= len W3 by A1,XXREAL_0:2;
  then
A3: len W3.cut(m,n) + m = n + 1 by A1,Lm15
    .= len W1.cut(m,n) + m by A1,Lm15;
A4: W3.cut(m,n) = (m,n)-cut W3 by A1,A2,Def11;
A5: W1.cut(m,n) = (m,n)-cut W1 by A1,Def11;
A6: 1 <= m & m <= n by A1,HEYTING3:1;
  now
    let x be Nat;
    assume x in dom W1.cut(m,n);
    then x in dom W1.cut(m,n);
    then
A7: 1 <= x & x <= len W1.cut(m,n) by FINSEQ_3:27;
    then reconsider xaa1 = x-1 as Element of NAT by INT_1:18;
A8: xaa1 + 1 = x;
A9: xaa1 < len W3.cut(m,n) - 0 by A3,A7,XREAL_1:17;
A10: xaa1 < len W1.cut(m,n) - 0 by A7,XREAL_1:17;
    then
A11: W1.cut(m,n).x = W1.(m+xaa1) by A1,A5,A6,A8,GRAPH_2:def 1;
A12: W3.cut(m,n).x = W3.(m+xaa1) by A2,A4,A6,A8,A9,GRAPH_2:def 1;
A13: 1 <= m+xaa1 by HEYTING3:1,NAT_1:12;
    len W1.cut(m,n) + m = n + 1 by A1,Lm15;
    then m + xaa1 < n + 1 by A10,XREAL_1:10;
    then m + xaa1 <= n by NAT_1:13;
    then m+xaa1 <= len W1 by A1,XXREAL_0:2;
    then m+xaa1 in dom W1 by A13,FINSEQ_3:27;
    hence W3.cut(m,n).x = W1.cut(m,n).x by A11,A12,Lm12;
  end;
  hence thesis by A3,FINSEQ_2:10;
end;

Lm22: for G being _Graph, W being Walk of G, m being odd Element of NAT
st m <= len W holds len W.cut(1,m) = m
proof
  let G be _Graph, W be Walk of G, m be odd Element of NAT;
  assume
A1: m <= len W;
  1 is odd & 1 <= m by HEYTING3:1,JORDAN12:3;
  then len W.cut(1,m) + 1 = m + 1 by A1,Lm15;
  hence thesis;
end;

Lm23: for
G be _Graph, W be Walk of G, m be odd Element of NAT, x be Element of NAT
st x in dom W.cut(1,m) & m <= len W holds W.cut(1,m).x = W.x
proof
  let G be _Graph, W be Walk of G, m be odd Element of NAT,
  x be Element of NAT;
  assume
A1: x in dom W.cut(1,m) & m <= len W;
  then
A2: 1 <= x & x <= len W.cut(1,m) by FINSEQ_3:27;
  then reconsider xaa1 = x-1 as Element of NAT by INT_1:18;
A3: xaa1 + 1 = x;
A4: 1 is odd & 1 <= m by HEYTING3:1,JORDAN12:3;
  x-1 < len W.cut(1,m) - 0 by A2,XREAL_1:17;
  hence W.cut(1,m).x = W.x by A1,A3,A4,Lm15;
end;

Lm24: for G be _Graph, W be Walk of G, m,n be odd Element of NAT
st m <= n & n <= len W & W.m = W.n holds len W.remove(m,n) + n = len W + m
proof
  let G be _Graph, W be Walk of G, m, n be odd Element of NAT;
  set W1 = W.cut(1,m), W2 = W.cut(n,len W);
  assume
A1: m <= n & n <= len W & W.m = W.n;
  then
A2: 1 is odd & 1 <= m & m <= len W by HEYTING3:1,JORDAN12:3,XXREAL_0:2;
A3: W.remove(m,n) = W1.append(W2) by A1,Def12;
A4: W1.last() = W.n & W.n = W2.first() by A1,A2,Lm16;
A5: len W1 + 1 = m + 1 by A2,Lm15;
  len W2 + n = len W + 1 by A1,Lm15;
  then len W1.append(W2) + 1 = m + (len W + 1 + -n) by A4,A5,Lm9
    .= len W + m + -n + 1;
  hence thesis by A3;
end;

Lm25: for G be _Graph, W be Walk of G, m,n be Element of NAT, x,y be set holds
W is_Walk_from x,y implies W.remove(m,n) is_Walk_from x,y
proof
  let G be _Graph, W be Walk of G, m,n be Element of NAT, x,y be set;
  set W2 = W.remove(m,n), WA = W.cut(1,m), WB = W.cut(n,len W);
  assume
A1: W is_Walk_from x,y;
  now per cases;
    suppose
A2:   m is odd & n is odd & m <= n & n <= len W & W.m = W.n;
      then
A3:   1 is odd & 1 <= m & m <= len W by HEYTING3:1,JORDAN12:3,XXREAL_0:2;
A4:   W2 = WA.append(WB) by A2,Def12;
A5:   WA.last() = W.n by A2,A3,Lm16
        .= WB.first() by A2,Lm16;
A6:   WA.first() = W.first() by A2,A3,Lm16
        .= x by A1,Def23;
      WB.last() = W.last() by A2,Lm16
        .= y by A1,Def23;
      hence thesis by A4,A5,A6,Lm11;
    end;
    suppose not (m is odd & n is odd & m <= n & n <= len W & W.m = W.n);
      hence thesis by A1,Def12;
    end;
  end;
  hence thesis;
end;

Lm26: for G being _Graph, W being Walk of G, m,n be Element of NAT holds
len W.remove(m,n) <= len W
proof
  let G be _Graph, W be Walk of G, m,n be Element of NAT;
  set W2 = W.remove(m,n);
  now per cases;
    suppose
A1:   m is odd & n is odd & m <= n & n <= len W & W.m = W.n;
      then len W2 + n = len W + m by Lm24;
      then len W2 + n - n <= len W + m - m by A1,XREAL_1:15;
      hence len W2 <= len W;
    end;
    suppose not (m is odd & n is odd & m <= n & n <= len W & W.m = W.n);
      hence len W2 <= len W by Def12;
    end;
  end;
  hence thesis;
end;

Lm27: for G be _Graph, W be Walk of G, m be Element of NAT
holds W.remove(m,m) = W
proof
  let G be _Graph, W be Walk of G, m be Element of NAT;
  now per cases;
    suppose
A1:   m is odd & m <= len W & W.m = W.m;
      then
A2:   1 is odd & 1 <= m by HEYTING3:1,JORDAN12:3;
      thus W.remove(m,m) = W.cut(1,m).append(W.cut(m,len W)) by A1,Def12
        .= W.cut(1,len W) by A1,A2,Lm17
        .= W by Lm18;
    end;
    suppose not (m is odd & m <= len W & W.m = W.m);
      hence W.remove(m,m) = W by Def12;
    end;
  end;
  hence thesis;
end;

Lm28: for G being _Graph, W being Walk of G, m,n be odd Element of NAT
st m <= n & n <= len W & W.m = W.n holds
W.cut(1,m).last() = W.cut(n,len W).first()
proof
  let G be _Graph, W be Walk of G, m,n be odd Element of NAT;
  assume
A1: m <= n & n <= len W & W.m = W.n;
  then
A2: m <= len W by XXREAL_0:2;
  1 <= m & 1 is odd by HEYTING3:1,JORDAN12:3;
  hence W.cut(1,m).last() = W.n by A1,A2,Lm16
    .= W.cut(n,len W).first() by A1,Lm16;
end;

Lm29: for G be _Graph, W be Walk of G, x,y be set, m,n being odd Element of NAT
st m <= n & n <= len W & W.m = W.n holds
(for x being Element of NAT st x in Seg m holds W.remove(m,n).x = W.x)
proof
  let G be _Graph, W be Walk of G, x,y be set, m, n be odd Element of NAT;
  set W2 = W.remove(m,n);
  assume
A1: m <= n & n <= len W & W.m = W.n;
  then
A2: W2 = W.cut(1,m).append(W.cut(n,len W)) by Def12;
  let x be Element of NAT;
  assume x in Seg m;
  then 1 <= x & x <= m by FINSEQ_1:3;
  then 1 <= x & x <= len W.cut(1,m) by A1,Lm22,XXREAL_0:2;
  then
A3: x in dom W.cut(1,m) by FINSEQ_3:27;
  hence W2.x = W.cut(1,m).x by A2,Lm12
    .= W.x by A1,A3,Lm23,XXREAL_0:2;
end;

Lm30: for G be _Graph, W be Walk of G, m,n being odd Element of NAT
st m <= n & n <= len W & W.m = W.n holds
(for x being Element of NAT st m <= x & x <= len W.remove(m,n) holds
W.remove(m,n).x = W.(x - m + n) &
x - m + n is Element of NAT & x - m + n <= len W)
proof
  let G be _Graph, W be Walk of G, m, n be odd Element of NAT;
  set W2 = W.remove(m,n), WA = W.cut(1,m), WB = W.cut(n,len W);
  assume
A1: m <= n & n <= len W & W.m = W.n;
  then
A2: W2 = WA.append(WB) by Def12;
A3: WA.last() = WB.first() by A1,Lm28;
  1 is odd & 1 <= m & m <= len W by A1,HEYTING3:1,JORDAN12:3,XXREAL_0:2;
  then
A4: len WA = m by Lm22;
A5: len WB + n = len W + 1 by A1,Lm15;
A6: len W2 + n = len W + m by A1,Lm24;
  let x be Element of NAT;
  assume
A7: m <= x & x <= len W2;
  then consider a being Nat such that
A8: len WA + a = x by A4,NAT_1:10;
  reconsider a as Element of NAT by ORDINAL1:def 13;
  m + a + n <= m + len W by A4,A6,A7,A8,XREAL_1:9;
  then
A9: a+n + m - m <= len W + m - m by XREAL_1:15;
  then a + n + 1 <= len WB + n by A5,XREAL_1:9;
  then a + 1 + n - n <= len WB + n - n by XREAL_1:15;
  then
A10: a + 1 - 1 < len WB + 1 - 1 by NAT_1:13;
  then W2.x = WB.(a+1) by A2,A3,A8,Lm13
    .= W.(a + n) by A1,A10,Lm15;
  hence W2.x = W.(x - m + n) by A4,A8;
  a + n is Element of NAT;
  hence x-m+n is Element of NAT by A4,A8;
  thus x-m+n <= len W by A4,A8,A9;
end;

Lm31: for G be _Graph, W be Walk of G, m,n be odd Element of NAT
st m <= n & n <= len W & W.m = W.n holds len W.remove(m,n) = len W + m - n
proof
  let G be _Graph, W be Walk of G, m,n be odd Element of NAT;
  assume m <= n & n <= len W & W.m = W.n;
  then len W.remove(m,n) + n = len W + m by Lm24;
  hence thesis;
end;

Lm32: for
G be _Graph, W be Walk of G, m being Element of NAT st W.first() = W.m holds
W.remove(1,m) = W.cut(m, len W)
proof
  let G be _Graph, W be Walk of G, m be Element of NAT;
  assume
A1: W.first() = W.m;
  now per cases;
    suppose
A2:   m is odd & m <= len W;
      then 1 is odd & 1 <= m by HEYTING3:1,JORDAN12:3;
      then
A3:   W.remove(1,m) = W.cut(1,1).append(W.cut(m, len W)) by A1,A2,Def12;
A4:   1 <= len W by HEYTING3:1;
      then
A5:   W.cut(1,1).last() = W.m by A1,Lm16,JORDAN12:3
        .= W.cut(m, len W).first() by A2,Lm16;
      then len W.remove(1,m) + 1 = len W.cut(1,1) + len W.cut(m, len W)
      by A3,Lm9;
      then
A6:   len W.remove(1,m) + 1 = len W.cut(m, len W) + 1
      by Lm22,HEYTING3:1,JORDAN12:3;
      now
        let n be Nat;
        assume 1 <= n & n <= len W.remove(1,m);
        then
A7:     n in dom W.remove(1,m) by FINSEQ_3:27;
        now per cases by A3,A7,Lm14;
          suppose
A8:         n in dom W.cut(1,1);
            then
A9:         1 <= n & n <= len W.cut(1,1) by FINSEQ_3:27;
            then
A10:        n <= 1 by A4,Lm22,JORDAN12:3;
            then
A11:        n = 1 by A9,XXREAL_0:1;
            W.remove(1,m).n = W.cut(1,1).n by A3,A8,Lm12
              .= <* W.vertexAt(1) *>.1 by A4,A11,Lm19,JORDAN12:3
              .= W.vertexAt(1) by FINSEQ_1:def 8
              .= W.m by A1,A4,Def8,JORDAN12:3
              .= W.cut(m, len W).first() by A2,Lm16
              .= W.cut(m, len W).1;
            hence W.remove(1,m).n = W.cut(m, len W).n by A9,A10,XXREAL_0:1;
          end;
          suppose ex k being Element of NAT st k < len W.cut(m, len W) &
            n = len W.cut(1,1) + k;
            then consider k being Element of NAT such that
A12:        k < len W.cut(m, len W) & n = len W.cut(1,1) + k;
            n = k + 1 by A12,Lm22,HEYTING3:1,JORDAN12:3;
            hence W.remove(1,m).n = W.cut(m, len W).n by A3,A5,A12,Lm13;
          end;
        end;
        hence W.remove(1,m).n = W.cut(m, len W).n;
      end;
      hence thesis by A6,FINSEQ_1:18;
    end;
    suppose
A13:  not (m is odd & m <= len W);
      then W.cut(m, len W) = W by Def11;
      hence thesis by A13,Def12;
    end;
  end;
  hence thesis;
end;

Lm33: for G be _Graph, W be Walk of G, m,n be Element of NAT holds
W.remove(m,n).first() = W.first() & W.remove(m,n).last() = W.last()
proof
  let G be _Graph, W be Walk of G, m,n be Element of NAT;
  W is_Walk_from W.first(), W.last() by Def23;
  then W.remove(m,n) is_Walk_from W.first(), W.last() by Lm25;
  hence thesis by Def23;
end;

Lm34: for G be _Graph, W be Walk of G, m,n being odd Element of NAT,
x being Element of NAT
st m <= n & n <= len W & W.m = W.n & x in dom W.remove(m,n) holds
x in Seg m or (m <= x & x <= len W.remove(m,n))
proof
  let G be _Graph, W be Walk of G, m,n be odd Element of NAT,
  x be Element of NAT;
  assume m <= n & n <= len W & W.m = W.n & x in dom W.remove(m,n);
  then 1 <= x & x <= len W.remove(m,n) by FINSEQ_3:27;
  hence thesis by FINSEQ_1:3;
end;

Lm35: for G be _Graph, W be Walk of G, e,x be set holds
e Joins W.last(), x, G implies W.addEdge(e) = W^<*e,x*>
proof
  let G be _Graph, W be Walk of G, e,x be set;
  set W1 = G.walkOf(W.last(), e, W.last().adj(e));
  assume
A1: e Joins W.last(), x, G;
  then reconsider x'=x as Vertex of G by GLIB_000:16;
A2: W.last().adj(e) = x' by A1,GLIB_000:69;
  then
A3: W1 = <*W.last(), e, x*> by A1,Def5;
  W.last() = W1.first() by A1,A2,Lm6;
  then
A4: W.append(W1) = W ^' W1 by Def10
    .= W ^ (2,len W1)-cut W1 by GRAPH_2:def 2
    .= W ^ (2,3)-cut W1 by A3,FINSEQ_1:62;
A5: len W1 = 3 & W1.2 = e & W1.3 = x by A3,FINSEQ_1:62;
  then (2,2)-cut W1 = <*e*> & (3,3)-cut W1 = <*x*> by GRAPH_2:6;
  then <*e*> ^ (2+1,3)-cut W1 = (1+1,3)-cut W1 by A5,GRAPH_2:8;
  then <*e*> ^ <*x*> = (2,3)-cut W1 by A5,GRAPH_2:6;
  hence thesis by A4,FINSEQ_1:def 9;
end;

Lm36: for G be _Graph, W be Walk of G, e,x be set holds
e Joins W.last(),x,G implies
W.addEdge(e).first() = W.first() & W.addEdge(e).last() = x &
W.addEdge(e) is_Walk_from W.first(), x
proof
  let G be _Graph, W be Walk of G, e,x be set;
  set W2 = G.walkOf(W.last(), e, W.last().adj(e));
  assume
A1: e Joins W.last(), x, G;
  then reconsider x'=x as Vertex of G by GLIB_000:16;
  W.last().adj(e) = x' by A1,GLIB_000:69;
  then W2.first() = W.last() & W2.last() = x by A1,Lm6;
  hence thesis by Lm11;
end;

Lm37: for G be _Graph, W be Walk of G, e,x be set holds
e Joins W.last(),x,G implies len W.addEdge(e) = len W + 2
proof
  let G be _Graph, W be Walk of G, e,x be set;
  set W2 = G.walkOf(W.last(),e, W.last().adj(e));
  assume
A1: e Joins W.last(), x, G;
  then reconsider x'=x as Vertex of G by GLIB_000:16;
A2: W.last().adj(e) = x' by A1,GLIB_000:69;
  then
A3: W2 = <*W.last(), e, x*> by A1,Def5;
  W2.first() = W.last() by A1,A2,Lm6;
  then len W.addEdge(e) + 1 = len W + len W2 by Lm9;
  then len W.addEdge(e) + 1 = len W + 3 by A3,FINSEQ_1:62;
  hence len W.addEdge(e) = len W + 2;
end;

Lm38: for G be _Graph, W be Walk of G, e,x be set holds
e Joins W.last(),x,G implies
W.addEdge(e).(len W + 1) = e & W.addEdge(e).(len W + 2) = x &
for n being Element of NAT st n in dom W holds W.addEdge(e).n = W.n
proof
  let G be _Graph, W be Walk of G, e,x be set;
  set W2 = W.addEdge(e);
  assume e Joins W.last(), x, G;
  then
A1: W2 = W^<*e,x*> by Lm35;
A2: <*e,x*>.1 = e & <*e,x*>.2 = x by FINSEQ_1:61;
A3: dom <*e,x*> = Seg 2 by FINSEQ_3:29;
  then 1 in dom <*e,x*> by FINSEQ_1:3;
  hence W2.(len W + 1) = e by A1,A2,FINSEQ_1:def 7;
  2 in dom <*e,x*> by A3,FINSEQ_1:3;
  hence W2.(len W + 2) = x by A1,A2,FINSEQ_1:def 7;
  let n be Element of NAT;
  assume n in dom W;
  hence thesis by A1,FINSEQ_1:def 7;
end;

Lm39: for G be _Graph, W be Walk of G, e,x,y,z be set holds
W is_Walk_from x,y & e Joins y,z,G implies W.addEdge(e) is_Walk_from x,z
proof
  let G be _Graph, W be Walk of G, e,x,y,z be set;
  assume
A1: W is_Walk_from x,y & e Joins y,z,G;
  then W.first() = x & W.last() = y by Def23;
  hence thesis by A1,Lm36;
end;

Lm40: for G being _Graph, W being Walk of G, n being even Element of NAT
st 1 <= n & n <= len W holds
n div 2 in dom W.edgeSeq() & W.n = W.edgeSeq().(n div 2)
proof
  let G be _Graph, W be Walk of G, n be even Element of NAT;
  assume
A1: 1 <= n & n <= len W;
A2: 2 divides n by PEPIN:22;
  then
A3: n = 2 * (n div 2) by NAT_D:3;
A4: now
    assume
A5: not n div 2 in dom W.edgeSeq();
    now per cases by A5,FINSEQ_3:27;
      suppose n div 2 < 0+1;
        then n div 2 <= 0 by NAT_1:13;
        then n div 2 = 0;
        then n = 2 * 0 by A2,NAT_D:3;
        hence contradiction by A1;
      end;
      suppose n div 2 > len W.edgeSeq();
        then 2 * (n div 2) > 2 * len W.edgeSeq() by XREAL_1:70;
        then n + 1 > 2 * len W.edgeSeq() + 1 by A3,XREAL_1:10;
        then n + 1 > len W by Def15;
        then n >= len W by NAT_1:13;
        hence contradiction by A1,XXREAL_0:1;
      end;
    end;
    hence contradiction;
  end;
  hence n div 2 in dom W.edgeSeq();
  1 <= n div 2 & n div 2 <= len W.edgeSeq() by A4,FINSEQ_3:27;
  hence thesis by A3,Def15;
end;

Lm41: for G being _Graph, W being Walk of G, n being Element of NAT holds
n in dom W.edgeSeq() iff 2*n in dom W
proof
  let G be _Graph, W be Walk of G, n be Element of NAT;
  hereby
    assume n in dom W.edgeSeq();
    then
A1: 1 <= n & n <= len W.edgeSeq() by FINSEQ_3:27;
    then
A2: 1 <= n + n by NAT_1:12;
    2*n <= len W.edgeSeq()*2 by A1,NAT_1:4;
    then 2*n <= len W.edgeSeq()*2 + 1 by NAT_1:12;
    then 2*n <= len W by Def15;
    hence 2*n in dom W by A2,FINSEQ_3:27;
  end;
  assume 2*n in dom W;
  then 1 <= 2*n & 2*n <= len W by FINSEQ_3:27;
  then 2*n div 2 in dom W.edgeSeq() by Lm40;
  hence n in dom W.edgeSeq() by NAT_D:20;
end;

Lm42: for G be _Graph, W be Walk of G holds
ex lenWaa1 being even Element of NAT st lenWaa1 = len W - 1 &
len W.edgeSeq() = lenWaa1 div 2
proof
  let G be _Graph, W be Walk of G;
  set lenWaa1 = len W - 1;
  reconsider lenWaa1 as even Element of NAT by HEYTING3:1,INT_1:18;
  take lenWaa1;
  thus lenWaa1 = len W - 1;
A1: len W = 2*len W.edgeSeq()+1 by Def15;
  2 divides lenWaa1 by PEPIN:22;
  then lenWaa1 = 2 * (lenWaa1 div 2) by NAT_D:3;
  hence thesis by A1;
end;

Lm43: for G be _Graph, W be Walk of G, n be Element of NAT holds
W.cut(1,n).edgeSeq() c= W.edgeSeq()
proof
  let G be _Graph, W be Walk of G, n be Element of NAT;
  per cases;
  suppose
A1: n is odd & 1 <= n & n <= len W;
    set f = W.cut(1,n).edgeSeq();
    now
      let e be set;
      assume
A2:   e in W.cut(1,n).edgeSeq();
      then consider x,y being set such that
A3:   e = [x,y] by RELAT_1:def 1;
A4:   x in dom f & y = f.x by A2,A3,FUNCT_1:8;
      then reconsider x as Element of NAT;
      1 <= x & x <= len f by A4,FINSEQ_3:27;
      then
A5:   y = W.cut(1,n).(2*x) by A4,Def15;
A6:   2*x in dom W.cut(1,n) by A4,Lm41;
      then
A7:   y = W.(2*x) by A1,A5,Lm23;
A8:   1 <= 2*x & 2*x <= len W.cut(1,n) by A6,FINSEQ_3:27;
      then 2*x <= n by A1,Lm22;
      then 2*x <= len W by A1,XXREAL_0:2;
      then 2*x in dom W by A8,FINSEQ_3:27;
      then
A9:   x in dom W.edgeSeq() by Lm41;
      then 1 <= x & x <= len W.edgeSeq() by FINSEQ_3:27;
      then W.edgeSeq().x = y by A7,Def15;
      hence e in W.edgeSeq() by A3,A9,FUNCT_1:8;
    end;
    hence thesis by TARSKI:def 3;
  end;
  suppose not (n is odd & 1 <= n & n <= len W);
    hence thesis by Def11;
  end;
end;

Lm44: for G be _Graph, W be Walk of G, e,x be set holds
e Joins W.last(),x,G implies W.addEdge(e).edgeSeq() = W.edgeSeq() ^ <*e*>
proof
  let G be _Graph, W be Walk of G, e,x be set;
  set W2 = W.addEdge(e), W3 = W.edgeSeq() ^ <*e*>;
  assume
A1: e Joins W.last(),x,G;
  then len W2 = len W + 2 by Lm37;
  then len W + 2 = 2 * len W2.edgeSeq() + 1 by Def15;
  then 2 + (2*len W.edgeSeq()+1) = 2*len W2.edgeSeq() + 1 by Def15;
  then
A2: 2*(len W.edgeSeq()+1) = 2*len W2.edgeSeq();
  len W3 = len W.edgeSeq() + len <*e*> by FINSEQ_1:35;
  then
A3: 2*len W3 = 2*len W2.edgeSeq() by A2,FINSEQ_1:56;
  now
    let k be Nat;
    assume
A4: 1 <= k & k <= len W2.edgeSeq();
    then
A5: k in dom W3 by A3,FINSEQ_3:27;
A6: W2.edgeSeq().k = W2.(2*k) by A4,Def15;
    now per cases by A5,FINSEQ_1:38;
      suppose
A7:     k in dom W.edgeSeq();
        then
A8:     W3.k = W.edgeSeq().k by FINSEQ_1:def 7;
        1 <= k & k <= len W.edgeSeq() by A7,FINSEQ_3:27;
        then
A9:     W3.k = W.(2*k) by A8,Def15;
        2*k in dom W by A7,Lm41;
        hence W2.edgeSeq().k = W3.k by A1,A6,A9,Lm38;
      end;
      suppose ex n being Nat st n in dom <*e*> & k=len W.edgeSeq() + n;
        then consider n being Element of NAT such that
A10:    n in dom <*e*> & k = len W.edgeSeq() + n;
        n in {1} by A10,FINSEQ_1:4,55;
        then
A11:    n = 1 by TARSKI:def 1;
        then
A12:    W3.k = <*e*>.1 by A10,FINSEQ_1:def 7
          .= e by FINSEQ_1:def 8;
        2*k = 2*len W.edgeSeq() + 1 + 1 by A10,A11
          .= len W + 1 by Def15;
        hence W2.edgeSeq().k = W3.k by A1,A6,A12,Lm38;
      end;
    end;
    hence W2.edgeSeq().k = W3.k;
  end;
  hence W2.edgeSeq() = W3 by A3,FINSEQ_1:18;
end;

Lm45: for G be _Graph, W be Walk of G, x be set holds x in W.vertices() iff
ex n being odd Element of NAT st n <= len W & W.n = x
proof
  let G be _Graph, W be Walk of G, x be set;
  set vs = W.vertexSeq();
  hereby
    assume x in W.vertices();
    then consider i being Nat such that
A1: i in dom vs & vs.i = x by FINSEQ_2:11;
    set n1 = 2*i;
    reconsider n1 as even Nat;
    set n = n1-1;
A2: 1 <= i & i <= len vs by A1,FINSEQ_3:27;
    then 1 <= i+i by NAT_1:12;
    then reconsider n as odd Element of NAT by INT_1:18;
    take n;
    i*2 <= len vs *2 by A2,XREAL_1:66;
    then i*2 <= len W + 1 by Def14;
    then n1 - 1 <= len W + 1 - 1 by XREAL_1:15;
    hence n <= len W;
    thus W.n = x by A1,A2,Def14;
  end;
  assume ex n being odd Element of NAT st n <= len W & W.n = x;
  then consider n being odd Element of NAT such that
A3: n <= len W & W.n = x;
  set n1 = n+1;
  reconsider n1 as even Element of NAT;
  set i = n1 div 2;
A4: 2 divides n1 by PEPIN:22;
  then
A5: 2*i = n1 by NAT_D:3;
  reconsider i as Element of NAT;
  now 1 <= n by HEYTING3:1;
    then 1+1 <= n1 by XREAL_1:9;
    then 2*1 <= 2*i by A4,NAT_D:3;
    then
A6: 1 <= i by XREAL_1:70;
    n1 <= len W + 1 by A3,XREAL_1:9;
    then 2*i <= 2*len vs by A5,Def14;
    then
A7: i <= len vs by XREAL_1:70;
    hence i in dom vs by A6,FINSEQ_3:27;
    thus vs.i = W.(2*i-1) by A6,A7,Def14
      .= x by A3,A5;
  end;
  hence x in W.vertices() by FUNCT_1:def 5;
end;

Lm46: for G be _Graph, W be Walk of G, e be set holds e in W.edges() iff
ex n being even Element of NAT st 1 <= n & n <= len W & W.n = e
proof
  let G be _Graph, W be Walk of G, e be set;
  set es = W.edgeSeq();
  hereby
    assume e in W.edges();
    then consider i being Nat such that
A1: i in dom es & es.i = e by FINSEQ_2:11;
    set n = 2*i;
    reconsider n as even Element of NAT;
A2: 1 <= i & i <= len es by A1,FINSEQ_3:27;
    take n;
    1 <= i+i by A2,NAT_1:12;
    hence 1 <= n;
    i*2 <= len es * 2 by A2,XREAL_1:66;
    then n <= len es * 2 + 1 by NAT_1:12;
    hence n <= len W by Def15;
    thus W.n = e by A1,A2,Def15;
  end;
  assume ex n being even Element of NAT st 1 <= n & n <= len W & W.n = e;
  then consider n being even Element of NAT such that
A3: 1 <= n & n <= len W & W.n = e;
  set i = n div 2;
  2 divides n by PEPIN:22;
  then
A4: 2*i = n by NAT_D:3;
  reconsider i as Element of NAT;
  now 1 < n by A3,JORDAN12:3,XXREAL_0:1;
    then 1+1 < n+1 by XREAL_1:10;
    then 2*1 <= 2*i by A4,NAT_1:13;
    then
A5: 1 <= i by XREAL_1:70;
    n < len W by A3,XXREAL_0:1;
    then 2*i < 2*len es + 1 by A4,Def15;
    then 2*i <= 2*len es by NAT_1:13;
    then
A6: i <= len es by XREAL_1:70;
    hence i in dom es by A5,FINSEQ_3:27;
    thus es.i = e by A3,A4,A5,A6,Def15;
  end;
  hence e in W.edges() by FUNCT_1:def 5;
end;

Lm47: for G be _Graph, W be Walk of G, e be set holds e in W.edges() implies
ex v1, v2 being Vertex of G, n being odd Element of NAT st
n+2 <= len W & v1 = W.n & e = W.(n+1) & v2 = W.(n+2) & e Joins v1, v2,G
proof
  let G be _Graph, W be Walk of G, e be set;
  assume e in W.edges();
  then consider n1 being even Element of NAT such that
A1: 1 <= n1 & n1 <= len W & W.n1 = e by Lm46;
  reconsider n = n1-1 as odd Element of NAT by A1,INT_1:18;
  set v1 = W.n, v2 = W.(n+2);
  n1-1 <= len W - 0 by A1,XREAL_1:15;
  then reconsider v1 as Vertex of G by Lm1;
  reconsider lenW = len W as odd Element of NAT;
  n1 < lenW by A1,XXREAL_0:1;
  then
A2: n+1+1 <= len W by NAT_1:13;
  then reconsider v2 as Vertex of G by Lm1;
  take v1, v2, n;
  thus n+2 <= len W by A2;
  thus v1 = W.n & e = W.(n+1) & v2 = W.(n+2) by A1;
  n+1-1 < len W - 0 by A1,XREAL_1:17;
  hence e Joins v1, v2, G by A1,Def3;
end;

Lm48: for G be _Graph, W be Walk of G, e,x,y be set holds
e in W.edges() & e Joins x,y,G implies x in W.vertices() & y in W.vertices()
proof
  let G be _Graph, W be Walk of G, e,x,y be set;
  assume
A1: e in W.edges() & e Joins x,y,G;
  then consider v1,v2 being Vertex of G, n being odd Element of NAT such that
A2: n+2 <= len W & v1 = W.n & e = W.(n+1) & v2 = W.(n+2) &
  e Joins v1,v2,G by Lm47;
A3: v2 in W.vertices() by A2,Lm45;
  n+2-2 <= len W-0 by A2,XREAL_1:15;
  then v1 in W.vertices() by A2,Lm45;
  hence thesis by A1,A2,A3,GLIB_000:18;
end;

Lm49: for G be _Graph, W be Walk of G, n be odd Element of NAT
st n <= len W holds W.find(n) <= n
proof
  let G be _Graph, W be Walk of G, n be odd Element of NAT;
  assume
A1: n <= len W;
  then W.find(n) <= len W & W.(W.find(n)) = W.n &
  for k being odd Element of NAT st k <= len W & W.k = W.n
  holds W.find(n) <= k by Def20;
  hence thesis by A1;
end;

Lm50: for G be _Graph, W be Walk of G, n being odd Element of NAT
st n <= len W holds W.rfind(n) >= n
proof
  let G be _Graph, W be Walk of G, n be odd Element of NAT;
  assume
A1: n <= len W;
  then W.rfind(n) <= len W & W.(W.rfind(n)) = W.n &
  for k being odd Element of NAT st k <= len W & W.k = W.n
  holds k <= W.rfind(n) by Def22;
  hence thesis by A1;
end;

Lm51: for G being _Graph, W being Walk of G holds W is directed iff
for n being odd Element of NAT st n < len W
holds W.(n+1) DJoins W.n, W.(n+2), G
proof
  let G be _Graph, W be Walk of G;
  hereby
    assume
A1: W is directed;
    let n be odd Element of NAT;
    assume
A2: n < len W;
    then
A3: W.(n+1) Joins W.n, W.(n+2), G by Def3;
A4: W.n = (the_Source_of G).(W.(n+1)) by A1,A2,Def25;
    now
      assume
A5:   W.(n+1) DJoins W.(n+2), W.n, G;
      then W.(n+2) = W.n by A4,GLIB_000:def 16;
      hence W.(n+1) DJoins W.n, W.(n+2), G by A5;
    end;
    hence W.(n+1) DJoins W.n, W.(n+2), G by A3,GLIB_000:19;
  end;
  assume
A6: for n being odd Element of NAT st n < len W
  holds W.(n+1) DJoins W.n, W.(n+2), G;
  now
    let n be odd Element of NAT;
    assume n < len W;
    then W.(n+1) DJoins W.n, W.(n+2), G by A6;
    hence (the_Source_of G).(W.(n+1)) = W.n by GLIB_000:def 16;
  end;
  hence W is directed by Def25;
end;

Lm52: for G be _Graph, W be Walk of G, x,e,y,z be set holds
W is directed & W is_Walk_from x,y & e DJoins y,z,G
implies W.addEdge(e) is directed & W.addEdge(e) is_Walk_from x,z
proof
  let G be _Graph, W be Walk of G, x,e,y,z be set;
  set W2 = W.addEdge(e);
  assume
A1: W is directed & W is_Walk_from x,y & e DJoins y,z,G;
  then
A2: W.last() = y by Def23;
  then
A3: e Joins W.last(),z,G by A1,GLIB_000:19;
  then
A4: len W2 = len W + 2 by Lm37;
  1 <= len W by HEYTING3:1;
  then len W in dom W by FINSEQ_3:27;
  then
A5: W2.(len W) = y by A2,A3,Lm38;
A6: W2.(len W + 1) = e by A3,Lm38;
  now
    let n be odd Element of NAT;
    assume n < len W2;
    then n < len W + 1+1 by A4;
    then n <= len W + 1 by NAT_1:13;
    then n < len W + 1 by XXREAL_0:1;
    then
A7: n <= len W by NAT_1:13;
    now per cases;
      suppose n = len W;
        hence W2.n = (the_Source_of G).(W2.(n+1)) by A1,A5,A6,GLIB_000:def 16;
      end;
      suppose n <> len W;
        then
A8:     n < len W by A7,XXREAL_0:1;
        1 <= n by HEYTING3:1;
        then n in dom W by A7,FINSEQ_3:27;
        then
A9:     W2.n = W.n by A3,Lm38;
A10:    1 <= n+1 by NAT_1:12;
        n + 1 <= len W by A8,NAT_1:13;
        then n+1 in dom W by A10,FINSEQ_3:27;
        then W2.(n+1) = W.(n+1) by A3,Lm38;
        hence W2.n = (the_Source_of G).(W2.(n+1)) by A1,A8,A9,Def25;
      end;
    end;
    hence W2.n = (the_Source_of G).(W2.(n+1));
  end;
  hence W.addEdge(e) is directed by Def25;
  thus W2 is_Walk_from x,z by A1,A2,A3,Lm39;
end;

Lm53: for G being _Graph, W being Walk of G, m,n being Element of NAT holds
W is directed implies W.cut(m,n) is directed
proof
  let G be _Graph, W be Walk of G, m, n be Element of NAT;
  set W2 = W.cut(m,n);
  assume
A1: W is directed;
  now per cases;
    suppose
A2:   m is odd & n is odd & m <= n & n <= len W;
      then reconsider m' = m as odd Element of NAT;
      now
        let x be odd Element of NAT;
        assume
A3:     x < len W2;
        then
A4:     W2.(x+1) = W.(m+x) & m+x in dom W by A2,Lm15;
        reconsider xaa1 = x - 1 as even Element of NAT by HEYTING3:1,INT_1:18;
        xaa1 < len W2 - 0 by A3,XREAL_1:16;
        then
A5:     W2.(xaa1+1) = W.(m+xaa1) & m+xaa1 in dom W by A2,Lm15;
        x + 1 <= len W2 by A3,NAT_1:13;
        then
A6:     x + 1 < len W2 by XXREAL_0:1;
        m'+x <= len W by A4,FINSEQ_3:27;
        then
A7:     m'+x-1 < len W - 0 by XREAL_1:17;
A8:     W2.(x+1) = W.(m+x-1+1) by A2,A3,Lm15
          .= W.(m+xaa1+1);
        W2.(x+2) = W2.(x+1+1)
          .= W.(m+(x-1+1+1)) by A2,A6,Lm15
          .= W.(m+xaa1+2);
        hence W2.(x+1) DJoins W2.x, W2.(x+2), G by A1,A5,A7,A8,Lm51;
      end;
      hence W2 is directed by Lm51;
    end;
    suppose not (m is odd & n is odd & m <= n & n <= len W);
      hence thesis by A1,Def11;
    end;
  end;
  hence thesis;
end;

Lm54: for G being _Graph, W being Walk of G holds
W is non trivial iff 3 <= len W
proof
  let G be _Graph, W be Walk of G;
  hereby
    assume W is non trivial;
    then W.length() <> 0 by Def26;
    then len W.edgeSeq() > 0;
    then 0+1 <= len W.edgeSeq() by NAT_1:13;
    then 2*1 <= 2*len W.edgeSeq() by NAT_1:4;
    then 2+1 <= 2*len W.edgeSeq() + 1 by XREAL_1:9;
    hence 3 <= len W by Def15;
  end;
  assume 3 <= len W;
  then 2*1 + 1 <= 2*len W.edgeSeq() + 1 by Def15;
  then W.length() <> 0;
  hence W is non trivial by Def26;
end;

Lm55: for G being _Graph, W being Walk of G holds
W is non trivial iff len W <> 1
proof
  let G be _Graph, W be Walk of G;
  thus W is non trivial implies len W <> 1 by Lm54;
  assume
A1: len W <> 1;
  1 <= len W by HEYTING3:1;
  then 1 < len W by A1,XXREAL_0:1;
  then 1+1 <= len W by NAT_1:13;
  then 2*1 < len W by XXREAL_0:1;
  then 2*1+1 <= len W by NAT_1:13;
  hence W is non trivial by Lm54;
end;

Lm56: for G be _Graph, W be Walk of G holds
W is trivial iff ex v being Vertex of G st W = G.walkOf(v)
proof
  let G be _Graph, W be Walk of G;
  hereby
    assume W is trivial;
    then
A1: len W = 1 by Lm55;
    take v = W.first();
    thus W = G.walkOf(v) by A1,FINSEQ_1:57;
  end;
  given v being Vertex of G such that
A2: W = G.walkOf(v);
  len W = 1 by A2,FINSEQ_1:56;
  hence W is trivial by Lm55;
end;

Lm57: for G being _Graph, W being Walk of G holds W is Trail-like iff
for m,n being even Element of NAT st 1 <= m & m < n & n <= len W holds
W.m <> W.n
proof
  let G be _Graph, W be Walk of G;
  hereby
    assume W is Trail-like;
    then
A1: W.edgeSeq() is one-to-one by Def27;
    let m, n be even Element of NAT;
    assume
A2: 1 <= m & m < n & n <= len W;
    then m <= len W by XXREAL_0:2;
    then
A3: m div 2 in dom W.edgeSeq() & W.m = W.edgeSeq().(m div 2) by A2,Lm40;
    1 <= n by A2,XXREAL_0:2;
    then
A4: n div 2 in dom W.edgeSeq() & W.n = W.edgeSeq().(n div 2) by A2,Lm40;
    now
      assume
A5:   m div 2 = n div 2;
      2 divides m & 2 divides n by PEPIN:22;
      then 2 * (m div 2) = m & 2 * (n div 2) = n by NAT_D:3;
      hence contradiction by A2,A5;
    end;
    hence W.m <> W.n by A1,A3,A4,FUNCT_1:def 8;
  end;
  assume
A6: for m,n being even Element of NAT st 1 <= m & m < n & n <= len W
  holds W.m <> W.n;
  now
    let x1, x2 be set;
    assume
A7: x1 in dom W.edgeSeq() & x2 in dom W.edgeSeq() &
    W.edgeSeq().x1 = W.edgeSeq().x2;
    then reconsider m = x1, n = x2 as Element of NAT;
    1 <= m & m <= len W.edgeSeq() by A7,FINSEQ_3:27;
    then
A8: W.edgeSeq().x1 = W.(2*m) by Def15;
    1 <= n & n <= len W.edgeSeq() by A7,FINSEQ_3:27;
    then
A9: W.(2*m) = W.(2*n) by A7,A8,Def15;
    2*m in dom W & 2*n in dom W by A7,Lm41;
    then
A10: 1 <= 2*m & 2*m <= len W & 1 <= 2*n & 2*n <= len W by FINSEQ_3:27;
    now per cases by XXREAL_0:1;
      suppose 2*m < 2*n;
        hence x1 = x2 by A6,A9,A10;
      end;
      suppose 2*m = 2*n;
        hence x1 = x2;
      end;
      suppose 2*m > 2*n;
        hence x1 = x2 by A6,A9,A10;
      end;
    end;
    hence x1 = x2;
  end;
  then W.edgeSeq() is one-to-one by FUNCT_1:def 8;
  hence W is Trail-like by Def27;
end;

Lm58: for G being _Graph, W being Walk of G holds
W is Trail-like iff W.reverse() is Trail-like
proof
  let G be _Graph, W be Walk of G;
A1: now
    let W be Walk of G;
    assume
A2: W is Trail-like;
    now
      let m, n be even Element of NAT;
      assume
A3:   1 <= m & m < n & n <= len W.reverse();
      then m <= len W.reverse() by XXREAL_0:2;
      then m in dom W.reverse() by A3,FINSEQ_3:27;
      then
A4:   W.reverse().m = W.(len W - m + 1) & len W - m + 1 in dom W by Lm8;
      1 <= n by A3,XXREAL_0:2;
      then n in dom W.reverse() by A3,FINSEQ_3:27;
      then
A5:   W.reverse().n = W.(len W - n + 1) & len W - n + 1 in dom W by Lm8;
      reconsider lenW = len W as odd Element of NAT;
      reconsider rn = lenW-n+1 as even Element of NAT by A5;
      reconsider rm = lenW-m+1 as even Element of NAT by A4;
      len W - n < len W - m by A3,XREAL_1:17;
      then
A6:   len W - n + 1 < len W - m + 1 by XREAL_1:10;
      1 <= rn & rm <= len W by A4,A5,FINSEQ_3:27;
      hence W.reverse().m <> W.reverse().n by A2,A4,A5,A6,Lm57;
    end;
    hence W.reverse() is Trail-like by Lm57;
  end;
  hence W is Trail-like implies W.reverse() is Trail-like;
  assume W.reverse() is Trail-like;
  then W.reverse().reverse() is Trail-like by A1;
  hence W is Trail-like by FINSEQ_6:29;
end;

Lm59: for G being _Graph, W being Walk of G, m,n being Element of NAT holds
W is Trail-like implies W.cut(m,n) is Trail-like
proof
  let G be _Graph, W be Walk of G, m,n be Element of NAT;
  assume
A1: W is Trail-like;
  now per cases;
    suppose
A2:   m is odd & n is odd & m <= n & n <= len W;
      now
        let x,y be even Element of NAT;
        assume
A3:     1 <= x & x < y & y <= len W.cut(m,n);
        then reconsider xaa1 = x-1 as odd Element of NAT by INT_1:18;
        reconsider yaa1 = y-1 as odd Element of NAT by A3,INT_1:18,XXREAL_0:2;
        reconsider m'=m as odd Element of NAT by A2;
        x <= len W.cut(m,n) by A3,XXREAL_0:2;
        then x-1 < len W.cut(m,n)-0 by XREAL_1:17;
        then
A4:     W.cut(m,n).(xaa1+1) = W.(m+xaa1) & m+xaa1 in dom W by A2,Lm15;
        y-1 < len W.cut(m,n)-0 by A3,XREAL_1:17;
        then
A5:     W.cut(m,n).(yaa1+1) = W.(m+yaa1) & m+yaa1 in dom W by A2,Lm15;
        then
A6:     m+yaa1 <= len W by FINSEQ_3:27;
A7:     1 <= m+xaa1 by HEYTING3:1,NAT_1:12;
        x - 1 < y - 1 by A3,XREAL_1:16;
        then xaa1 + m < yaa1 + m by XREAL_1:10;
        then W.(m'+xaa1) <> W.(m'+yaa1) by A1,A6,A7,Lm57;
        hence W.cut(m,n).x <> W.cut(m,n).y by A4,A5;
      end;
      hence thesis by Lm57;
    end;
    suppose not (m is odd & n is odd & m <= n & n <= len W);
      hence thesis by A1,Def11;
    end;
  end;
  hence thesis;
end;

Lm60: for G be _Graph, W being Walk of G, e being set
st W is Trail-like & e in W.last().edgesInOut() & not e in W.edges()
holds W.addEdge(e) is Trail-like
proof
  let G be _Graph, W be Walk of G, e be set;
  assume
A1: W is Trail-like & e in W.last().edgesInOut() & not e in W.edges();
  then
A2: e Joins W.last(), W.last().adj(e),G by GLIB_000:70;
  set W2 = W.addEdge(e);
  reconsider lenW2 = len W2 as odd Element of NAT;
  now
    let m,n be even Element of NAT;
    assume
A3: 1 <= m & m < n & n <= len W2;
    now per cases;
      suppose
A4:     n <= len W;
        1 <= n by A3,XXREAL_0:2;
        then n in dom W by A4,FINSEQ_3:27;
        then
A5:     W2.n = W.n by A2,Lm38;
        m <= len W by A3,A4,XXREAL_0:2;
        then m in dom W by A3,FINSEQ_3:27;
        then W2.m = W.m by A2,Lm38;
        hence W2.m <> W2.n by A1,A3,A4,A5,Lm57;
      end;
      suppose n > len W;
        then
A6:     len W + 1 <= n by NAT_1:13;
        n < lenW2 by A3,XXREAL_0:1;
        then n+1 <= len W2 by NAT_1:13;
        then n+1-1 <= len W2 - 1 by XREAL_1:15;
        then n <= len W + (1+1) - 1 by A2,Lm37;
        then
A7:     n = len W + 1 by A6,XXREAL_0:1;
        then
A8:     W2.n = e by A2,Lm38;
A9:     m + 1 - 1 <= len W + 1 - 1 by A3,A7,NAT_1:13;
        then m in dom W by A3,FINSEQ_3:27;
        then W2.m = W.m by A2,Lm38;
        hence W2.m <> W2.n by A1,A3,A8,A9,Lm46;
      end;
    end;
    hence W2.m <> W2.n;
  end;
  hence W2 is Trail-like by Lm57;
end;

Lm61: for G be _Graph, W be Walk of G holds len W <= 3 implies W is Trail-like
proof
  let G be _Graph, W be Walk of G;
  assume
A1: len W <= 3;
  now per cases;
    suppose len W = 1;
      then W is trivial by Lm55;
      then consider v being Vertex of G such that
A2:   W = G.walkOf(v) by Lm56;
      thus W is Trail-like by A2,Lm4;
    end;
    suppose
A3:   len W <> 1;
      1 <= len W by HEYTING3:1;
      then 1 < len W by A3,XXREAL_0:1;
      then 1+2 <= len W by Th1,JORDAN12:3;
      then
A4:   len W = 3 by A1,XXREAL_0:1;
      now
        let m, n be even Element of NAT such that
A5:     1 <= m & m < n & n <= len W;
        2*0+1 < m by A5,XXREAL_0:1;
        then
A6:     1+1 <= m by NAT_1:13;
        n < 2+1 by A4,A5,XXREAL_0:1;
        then n <= 2 by NAT_1:13;
        hence W.m <> W.n by A5,A6,XXREAL_0:2;
      end;
      hence W is Trail-like by Lm57;
    end;
  end;
  hence thesis;
end;

Lm62: for G being _Graph, x,e,y being set holds
e Joins x,y,G implies G.walkOf(x,e,y) is Path-like
proof
  let G be _Graph, x,e,y be set;
  set W = G.walkOf(x,e,y);
  assume
A1: e Joins x,y,G;
  then
A2: len W = 3 by Lm5;
  now
    let m,n be even Element of NAT;
    assume
A3: 1 <= m & m < n & n <= len W;
    then 1 < m by JORDAN12:3,XXREAL_0:1;
    then 1+1 <= m by NAT_1:13;
    then
A4: 2 < n by A3,XXREAL_0:2;
    n <= 3 by A1,A3,Lm5;
    then n < 2*1+1 by XXREAL_0:1;
    hence W.m <> W.n by A4,NAT_1:13;
  end;
  then
A5: W is Trail-like by Lm57;
  now
    let m,n be odd Element of NAT;
    assume
A6: m < n & n <= len W;
    assume W.m = W.n;
A7: 1 <= m by HEYTING3:1;
    then 1 < n by A6,XXREAL_0:2;
    then 1+1 < n+1 by XREAL_1:10;
    then 2*1 <= n by NAT_1:13;
    then 2*1 < n by XXREAL_0:1;
    then 2+1 < n+1 by XREAL_1:10;
    then
A8: 3 <= n by NAT_1:13;
    then
A9: n = 3 by A2,A6,XXREAL_0:1;
    now
      assume m <> 1;
      then 1 < m by A7,XXREAL_0:1;
      then 1+1 < m+1 by XREAL_1:10;
      then 2*1 <= m by NAT_1:13;
      then 2*1 < m by XXREAL_0:1;
      then 2+1 < m+1 by XREAL_1:10;
      hence contradiction by A6,A9,NAT_1:13;
    end;
    hence m = 1 & n = len W by A2,A6,A8,XXREAL_0:1;
  end;
  hence thesis by A5,Def28;
end;

Lm63: for G being _Graph, W being Walk of G holds
W is Path-like iff W.reverse() is Path-like
proof
  let G be _Graph, W be Walk of G;
A1: now
    let W be Walk of G;
    assume
A2: W is Path-like;
    then W is Trail-like & for m, n being odd Element of NAT
    st m < n & n <= len W
    holds W.m = W.n implies (m = 1 & n = len W) by Def28;
    then
A3: W.reverse() is Trail-like by Lm58;
    reconsider lenW=len W as odd Element of NAT;
    now
      let m, n be odd Element of NAT;
      assume
A4:   m < n & n <= len W.reverse() & W.reverse().m = W.reverse().n;
      then
A5:   m <= len W.reverse() by XXREAL_0:2;
      1 <= m by HEYTING3:1;
      then
A6:   m in dom W.reverse() by A5,FINSEQ_3:27;
      then
A7:   W.reverse().m = W.(len W - m + 1) & len W - m + 1 in dom W by Lm8;
      then reconsider rm = lenW-m+1 as odd Element of NAT;
      1 <= n by HEYTING3:1;
      then n in dom W.reverse() by A4,FINSEQ_3:27;
      then
A8:   W.reverse().n = W.(len W - n + 1) & len W - n + 1 in dom W by Lm8;
      then reconsider rn = lenW-n+1 as odd Element of NAT;
      lenW - n < len W - m by A4,XREAL_1:17;
      then
A9:   rn < rm by XREAL_1:10;
A10:  rm <= len W by A7,FINSEQ_3:27;
A11:  W.rm = W.rn by A4,A6,A8,Lm8;
      then
A12:  rn = 1 & rm = len W by A2,A9,A10,Def28;
      len W + (1 + -m) = len W by A2,A9,A10,A11,Def28;
      hence m = 1;
      thus n = len W.reverse() by A12,FINSEQ_5:def 3;
    end;
    hence W.reverse() is Path-like by A3,Def28;
  end;
  hence W is Path-like implies W.reverse() is Path-like;
  assume W.reverse() is Path-like;
  then W.reverse().reverse() is Path-like by A1;
  hence W is Path-like by FINSEQ_6:29;
end;

Lm64: for G being _Graph, W being Walk of G, m, n being Element of NAT
st W is Path-like holds W.cut(m,n) is Path-like
proof
  let G be _Graph, W be Walk of G, m, n be Element of NAT;
  assume
A1: W is Path-like;
  now per cases;
    suppose
A2:   m is odd & n is odd & m <= n & n <= len W;
      then reconsider m'=m as odd Element of NAT;
      now W is Trail-like by A1,Def28;
        hence W.cut(m,n) is Trail-like by Lm59;
        let x,y be odd Element of NAT;
        assume
A3:     x < y & y <= len W.cut(m,n) & W.cut(m,n).x = W.cut(m,n).y;
        reconsider xaa1 = x-1 as even Element of NAT by HEYTING3:1,INT_1:18;
        reconsider yaa1 = y-1 as even Element of NAT by HEYTING3:1,INT_1:18;
        x <= len W.cut(m,n) by A3,XXREAL_0:2;
        then x-1 < len W.cut(m,n) - 0 by XREAL_1:17;
        then
A4:     W.cut(m,n).(xaa1+1) = W.(m+xaa1) & m+xaa1 in dom W by A2,Lm15;
        y-1 < len W.cut(m,n) - 0 by A3,XREAL_1:17;
        then
A5:     W.cut(m,n).(yaa1+1) = W.(m+yaa1) & m+yaa1 in dom W by A2,Lm15;
        x - 1 < y - 1 by A3,XREAL_1:16;
        then
A6:     xaa1 + m < yaa1 + m by XREAL_1:10;
A7:     1 <= m'+xaa1 & m'+yaa1 <= len W by A4,A5,FINSEQ_3:27;
        then
A8:     m'+xaa1 = 1 & m'+yaa1 = len W by A1,A3,A4,A5,A6,Def28;
A9:     now
          assume xaa1 <> 0;
          then 0 < xaa1 & m >= 1 by A2,HEYTING3:1;
          then 1+0 < m + xaa1 by XREAL_1:10;
          hence contradiction by A1,A3,A4,A5,A6,A7,Def28;
        end;
        hence x = 1;
        m + 1 - 1 = 1 by A1,A3,A4,A5,A6,A7,A9,Def28;
        then len W.cut(m,n) + 1 = n + 1 by A2,Lm15;
        hence y = len W.cut(m,n) by A2,A3,A8,A9,XXREAL_0:1;
      end;
      hence W.cut(m,n) is Path-like by Def28;
    end;
    suppose not (m is odd & n is odd & m <= n & n <= len W);
      hence thesis by A1,Def11;
    end;
  end;
  hence thesis;
end;

Lm65: for G being _Graph, W being Walk of G, e,v being set
st W is Path-like & e Joins W.last(),v,G & not e in W.edges() &
(W is trivial or W is open) &
for n being odd Element of NAT st 1 < n & n <= len W holds W.n <> v holds
W.addEdge(e) is Path-like
proof
  let G be _Graph, W be Walk of G, e,v be set;
  assume
A1: W is Path-like & e Joins W.last(), v,G & not e in W.edges() &
  (W is trivial or W is open) &
  (for n being odd Element of NAT st 1 < n & n <= len W holds W.n <> v);
  then
A2: e in W.last().edgesInOut() by GLIB_000:65;
  set W2 = W.addEdge(e);
  reconsider lenW = len W as odd Element of NAT;
  now W is Trail-like by A1,Def28;
    hence W2 is Trail-like by A1,A2,Lm60;
    let m, n be odd Element of NAT;
    assume
A3: m < n & n <= len W2 & W2.m = W2.n;
    now per cases by A1;
      suppose
A4:     W is open;
        now per cases;
          suppose
A5:         n <= len W;
            then
A6:         m <= len W by A3,XXREAL_0:2;
            1 <= m by HEYTING3:1;
            then m in dom W by A6,FINSEQ_3:27;
            then
A7:         W2.m = W.m by A1,Lm38;
            1 <= n by HEYTING3:1;
            then
A8:         n in dom W by A5,FINSEQ_3:27;
            then W.m = W.n by A1,A3,A7,Lm38;
            then m = 1 & n = len W by A1,A3,A5,Def28;
            then W.first() = W.last() by A1,A3,A7,A8,Lm38;
            hence m = 1 & n = len W2 by A4,Def24;
          end;
          suppose n > len W;
            then lenW + 1 <= n by NAT_1:13;
            then lenW + 1 < n by XXREAL_0:1;
            then lenW + 1 + 1 <= n by NAT_1:13;
            then len W + (1+1) <= n;
            then
A9:         len W2 <= n by A1,Lm37;
            then n = len W2 by A3,XXREAL_0:1;
            then W2.n = W2.(len W + 2) by A1,Lm37;
            then
A10:        W2.n = v by A1,Lm38;
            m < len W2 by A3,A9,XXREAL_0:1;
            then m < len W + (1 + 1) by A1,Lm37;
            then m < len W + 1 + 1;
            then m <= lenW + 1 by NAT_1:13;
            then m < lenW + 1 by XXREAL_0:1;
            then
A11:        m <= len W by NAT_1:13;
            1 <= m by HEYTING3:1;
            then m in dom W by A11,FINSEQ_3:27;
            then
A12:        W.m = v by A1,A3,A10,Lm38;
            now
              assume
A13:          m <> 1;
              1 <= m by HEYTING3:1;
              then 1 < m by A13,XXREAL_0:1;
              hence contradiction by A1,A11,A12;
            end;
            hence m = 1;
            thus n = len W2 by A3,A9,XXREAL_0:1;
          end;
        end;
        hence m = 1 & n = len W2;
      end;
      suppose W is trivial;
        then consider v being Vertex of G such that
A14:    W = G.walkOf(v) by Lm56;
        len W = 1 by A14,FINSEQ_1:56;
        then
A15:    len W2 = 1 + 2 by A1,Lm37;
A16:    1 <= m by HEYTING3:1;
        then
A17:    1+1 <= m+1 by XREAL_1:9;
        m+1 <= n by A3,NAT_1:13;
        then 2*1 <= n by A17,XXREAL_0:2;
        then 2*1 < n by XXREAL_0:1;
        then
A18:    len W2 <= n by A15,NAT_1:13;
        then n = len W2 by A3,XXREAL_0:1;
        then m+1-1 <= 3-1 by A3,A15,NAT_1:13;
        then m < 2*1 by XXREAL_0:1;
        then m+1 <= 2 by NAT_1:13;
        then m+1-1 <= 2-1 by XREAL_1:15;
        hence m = 1 & n = len W2 by A3,A16,A18,XXREAL_0:1;
      end;
    end;
    hence m = 1 & n = len W2;
  end;
  hence W.addEdge(e) is Path-like by Def28;
end;

Lm66: for G be _Graph, W be Walk of G holds
(for m,n being odd Element of NAT st m <= len W & n <= len W & W.m = W.n
holds m = n) implies W is Path-like
proof
  let G be _Graph, W be Walk of G;
  assume
A1: for m,n being odd Element of NAT st m <= len W & n <= len W & W.m = W.n
  holds m = n;
  now
    let m,n be even Element of NAT;
    assume
A2: 1 <= m & m < n & n <= len W;
    then 1 <= n & m <= len W by XXREAL_0:2;
    then
A3: m in dom W & n in dom W by A2,FINSEQ_3:27;
    now
      assume
A4:   W.m = W.n;
      consider maa1 being odd Element of NAT such that
A5:   maa1 = m-1 & m-1 in dom W & m+1 in dom W &
      W.m Joins W.(maa1), W.(m+1), G by A3,Lm2;
      consider naa1 being odd Element of NAT such that
A6:   naa1 = n-1 & n-1 in dom W & n+1 in dom W &
      W.m Joins W.(naa1), W.(n+1), G by A3,A4,Lm2;
A7:   maa1 <= len W & m+1 <= len W by A5,FINSEQ_3:27;
A8:   naa1 <= len W & n+1 <= len W by A6,FINSEQ_3:27;
      now per cases by A5,A6,GLIB_000:18;
        suppose W.(naa1) = W.(maa1) & W.(n+1) = W.(m+1);
          then naa1 = maa1 by A1,A7,A8;
          hence contradiction by A2,A5,A6;
        end;
        suppose W.(naa1) = W.(m+1) & W.(n+1) = W.(maa1);
          then naa1 = m+1 & n+1 = maa1 by A1,A7,A8;
          hence contradiction by A5,A6;
        end;
      end;
      hence contradiction;
    end;
    hence W.m <> W.n;
  end;
  then
A9: W is Trail-like by Lm57;
  now
    let m,n be odd Element of NAT;
    assume
A10: m < n & n <= len W;
    then
A11: m <= len W by XXREAL_0:2;
    assume W.m = W.n;
    hence m = 1 & n = len W by A1,A10,A11;
  end;
  hence W is Path-like by A9,Def28;
end;

Lm67: for G be _Graph, W be Walk of G holds
(for n being odd Element of NAT st n <= len W holds W.rfind(n) = n)
implies W is Path-like
proof
  let G be _Graph, W be Walk of G;
  assume
A1: for n being odd Element of NAT st n <= len W holds W.rfind(n) = n;
  now
    let m,n be odd Element of NAT;
    assume
A2: m <= len W & n <= len W & W.m = W.n;
    then
A3: W.rfind(m) = m & W.rfind(n) = n by A1;
    then
A4: n <= m by A2,Def22;
    m <= n by A2,A3,Def22;
    hence m = n by A4,XXREAL_0:1;
  end;
  hence W is Path-like by Lm66;
end;

Lm68: for
G be _Graph, W being Walk of G, e, v being set st e Joins W.last(),v,G &
W is Path-like & not v in W.vertices() & (W is trivial or W is open)
holds W.addEdge(e) is Path-like
proof
  let G be _Graph, W be Walk of G, e, v be set;
  assume
A1: e Joins W.last(),v,G & W is Path-like & not v in W.vertices() &
  (W is trivial or W is open);
  then
A2: not e in W.edges() by Lm48;
  for n being odd Element of NAT st 1 < n & n <= len W holds v <> W.n
  by A1,Lm45;
  hence thesis by A1,A2,Lm65;
end;

Lm69: for G be _Graph, W be Walk of G holds len W <= 3 implies W is Path-like
proof
  let G be _Graph, W be Walk of G;
  assume
A1: len W <= 3;
  now per cases;
    suppose len W = 1;
      then W is trivial by Lm55;
      then consider v being Vertex of G such that
A2:   W = G.walkOf(v) by Lm56;
      thus W is Path-like by A2,Lm4;
    end;
    suppose
A3:   len W <> 1;
      1 <= len W by HEYTING3:1;
      then 1 < len W by A3,XXREAL_0:1;
      then 1+2 <= len W by Th1,JORDAN12:3;
      then
A4:   len W = 3 by A1,XXREAL_0:1;
A5:   W is Trail-like by A1,Lm61;
      now
        let m, n be odd Element of NAT;
        assume
A6:     m < n & n <= len W & W.m = W.n;
        then m < 2*1+1 by A4,XXREAL_0:2;
        then m+2 <= 3 by Th1;
        then
A7:     m+2-2 <= 3-2 by XREAL_1:15;
A8:     1 <= m by HEYTING3:1;
        hence m = 1 by A7,XXREAL_0:1;
        2*0+1 < n by A6,A8,XXREAL_0:2;
        then 1+2 <= n by Th1;
        hence n = len W by A4,A6,XXREAL_0:1;
      end;
      hence W is Path-like by A5,Def28;
    end;
  end;
  hence thesis;
end;

registration
  let G be _Graph;
  cluster Path-like -> Trail-like Walk of G;
  correctness by Def28;
  cluster trivial -> Path-like Walk of G;
  correctness
  proof
    let W be Walk of G;
    assume
A1: W is trivial;
    then len W = 1 by Lm55;
    then 2*len W.edgeSeq() + 1 = 0+1 by Def15;
    then W.edgeSeq() = {};
    then W.edgeSeq() is one-to-one;
    then
A2: W is Trail-like by Def27;
    now
      let m,n be odd Element of NAT;
      assume
A3:   m < n & n <= len W & W.m = W.n;
      then 1 <= m & 1 <= n & n <= 1 by A1,Lm55,HEYTING3:1;
      hence m = 1 & n = len W by A3,XXREAL_0:1;
    end;
    hence thesis by A2,Def28;
  end;
  cluster trivial -> vertex-distinct Walk of G;
  coherence
  proof
    let W be Walk of G;
    assume
A4: W is trivial;
    now
      let m,n be odd Element of NAT;
      assume m <= len W & n <= len W & W.m = W.n;
      then m <= 1 & n <= 1 & 1 <= m & 1 <= n by A4,Lm55,HEYTING3:1;
      then m = 1 & n = 1 by XXREAL_0:1;
      hence m = n;
    end;
    hence W is vertex-distinct by Def29;
  end;
  cluster vertex-distinct -> Path-like Walk of G;
  coherence
  proof
    let W be Walk of G;
    assume W is vertex-distinct;
    then for m,n being odd Element of NAT st m <= len W & n <= len W & W.m = W
    .n holds m = n by Def29;
    hence W is Path-like by Lm66;
  end;
  cluster Circuit-like -> closed Trail-like non trivial Walk of G;
  correctness by Def30;
  cluster Cycle-like -> closed Path-like non trivial Walk of G;
  correctness by Def31;
end;

registration
  let G be _Graph;
  cluster closed directed trivial Walk of G;
  existence
  proof
    consider v being Vertex of G;
    take G.walkOf(v);
    thus thesis by Lm4;
  end;
end;

registration
  let G be _Graph;
  cluster vertex-distinct Walk of G;
  existence
  proof
    consider W being trivial Walk of G;
    take W;
    thus thesis;
  end;
end;

definition
  let G be _Graph;
  mode Trail of G is Trail-like Walk of G;
  mode Path of G is Path-like Walk of G;
end;

definition
  let G be _Graph;
  mode DWalk of G is directed Walk of G;
  mode DTrail of G is directed Trail of G;
  mode DPath of G is directed Path of G;
end;

registration
  let G be _Graph, v be Vertex of G;
  cluster G.walkOf(v) -> closed directed trivial;
  coherence by Lm4;
end;

registration
  let G be _Graph, x,e,y be set;
  cluster G.walkOf(x,e,y) -> Path-like;
  coherence
  proof
    set W = G.walkOf(x,e,y);
    now per cases;
      suppose e Joins x,y,G;
        hence thesis by Lm62;
      end;
      suppose not e Joins x,y,G;
        then W = G.walkOf(choose the_Vertices_of G) by Def5;
        hence thesis;
      end;
    end;
    hence thesis;
  end;
end;

registration
  let G be _Graph, x,e be set;
  cluster G.walkOf(x,e,x) -> closed;
  coherence
  proof
    set W = G.walkOf(x,e,x);
    now per cases;
      suppose e Joins x,x,G;
        then W.first() = x & W.last() = x by Lm6;
        hence W is closed by Def24;
      end;
      suppose not e Joins x,x,G;
        then W = G.walkOf(choose the_Vertices_of G) by Def5;
        hence thesis;
      end;
    end;
    hence thesis;
  end;
end;

registration
  let G be _Graph, W be closed Walk of G;
  cluster W.reverse() -> closed;
  coherence
  proof
    W is closed iff W.first() = W.last() by Def24;
    then W is closed iff W.reverse().last() = W.last() by Lm7;
    then W is closed iff W.reverse().last() = W.reverse().first() by Lm7;
    hence thesis by Def24;
  end;
end;

registration
  let G be _Graph, W be trivial Walk of G;
  cluster W.reverse() -> trivial;
  coherence
  proof
    len W = 1 by Lm55;
    then len W.reverse() = 1 by FINSEQ_5:def 3;
    hence thesis by Lm55;
  end;
end;

registration
  let G be _Graph, W be Trail of G;
  cluster W.reverse() -> Trail-like;
  coherence by Lm58;
end;

registration
  let G be _Graph, W be Path of G;
  cluster W.reverse() -> Path-like;
  coherence by Lm63;
end;

registration
  let G be _Graph, W1,W2 be closed Walk of G;
  cluster W1.append(W2) -> closed;
  coherence
  proof
    set W = W1.append(W2);
    now per cases;
      suppose
A1:     W1.last() = W2.first();
        then W1.last() = W2.last() by Def24;
        then W1.first() = W2.last() by Def24
          .= W.last() by A1,Lm11;
        then W.first() = W.last() by A1,Lm11;
        hence thesis by Def24;
      end;
      suppose W1.last() <> W2.first();
        hence thesis by Def10;
      end;
    end;
    hence thesis;
  end;
end;

registration
  let G be _Graph, W1,W2 be DWalk of G;
  cluster W1.append(W2) -> directed;
  coherence
  proof
    set W = W1.append(W2);
    now per cases;
      suppose
A1:     W1.last() = W2.first();
        now
          let n be odd Element of NAT;
          assume
A2:       n < len W;
          1 <= n by HEYTING3:1;
          then
A3:       n in dom W by A2,FINSEQ_3:27;
          now per cases by A3,Lm14;
            suppose
A4:           n in dom W1;
              then
A5:           W.n = W1.n by Lm12;
A6:           1 <= n & n <= len W1 by A4,FINSEQ_3:27;
              now per cases by A6,XXREAL_0:1;
                suppose
A7:               n < len W1;
                  then n+1 in dom W1 & n+2 in dom W1 by Lm3;
                  then W.(n+1) = W1.(n+1) & W.(n+2) = W1.(n+2) by Lm12;
                  hence W.(n+1) DJoins W.n, W.(n+2), G by A5,A7,Lm51;
                end;
                suppose
A8:               n = len W1;
                  then
A9:               0 < len W2 & n = len W1 + 0;
                  n + 1 < len W + 1 by A2,XREAL_1:10;
                  then 1 + n < len W2 + n by A1,A8,Lm9;
                  then
A10:              1 < len W2 & n+1 = len W1 + 1 by A8,XREAL_1:8;
                  then
A11:              W.(n+1) = W2.(1+1) by A1,Lm13;
                  1+1 <= len W2 by A10,NAT_1:13;
                  then 2*1 < len W2 & n+2 = len W1+2 by A8,XXREAL_0:1;
                  then
A12:              W.(n+2) = W2.(2+1) by A1,Lm13;
                  W2.(2*0+1+1) DJoins W2.(2*0+1), W2.(2*0+1+2), G by A10,Lm51;
                  hence W.(n+1) DJoins W.n, W.(n+2), G by A1,A9,A11,A12,Lm13;
                end;
              end;
              hence W.(n+1) DJoins W.n, W.(n+2), G;
            end;
            suppose ex k being Element of NAT st k < len W2 & n = len W1 + k;
              then consider k being Element of NAT such that
A13:          k < len W2 & n = len W1 + k;
              k is even by A13;
              then reconsider k as even Element of NAT;
A14:          W.n = W2.(k+1) by A1,A13,Lm13;
              n + 1 < len W + 1 by A2,XREAL_1:10;
              then 1 + (k + len W1) < len W2 + len W1 by A1,A13,Lm9;
              then
A15:          k + 1 + len W1 - len W1 < len W2 + len W1 - len W1
 by XREAL_1:16;
              then k + 1 + 1 <= len W2 by NAT_1:13;
              then
A16:          k + 1 + 1 < len W2 by XXREAL_0:1;
A17:          n + 1 + 1 = len W1 + ((k + 1) + 1) by A13;
A18:          W.(n+1) = W2.(k+1+1) by A1,A13,A15,Lm13;
              W2.(k+1+(1+1)) = W2.(k+1+1+1)
                .= W.(n+(1+1)) by A1,A16,A17,Lm13;
              hence W.(n+1) DJoins W.n, W.(n+2), G by A14,A15,A18,Lm51;
            end;
          end;
          hence W.(n+1) DJoins W.n, W.(n+2), G;
        end;
        hence thesis by Lm51;
      end;
      suppose W1.last() <> W2.first();
        hence thesis by Def10;
      end;
    end;
    hence thesis;
  end;
end;

registration
  let G be _Graph, W1,W2 be trivial Walk of G;
  cluster W1.append(W2) -> trivial;
  coherence
  proof
    set W = W1.append(W2);
    now per cases;
      suppose W1.last() = W2.first();
        then len W + 1 = len W1 + len W2 by Lm9
          .= len W1 + 1 by Lm55
          .= 1 + 1 by Lm55;
        hence thesis by Lm55;
      end;
      suppose W1.last() <> W2.first();
        hence thesis by Def10;
      end;
    end;
    hence thesis;
  end;
end;

registration
  let G be _Graph, W be DWalk of G, m,n be Element of NAT;
  cluster W.cut(m,n) -> directed;
  coherence by Lm53;
end;

registration
  let G be _Graph, W be trivial Walk of G, m,n be Element of NAT;
  cluster W.cut(m,n) -> trivial;
  coherence
  proof
    set W2 = W.cut(m,n);
    now per cases;
      suppose
A1:     m is odd & n is odd & m <= n & n <= len W;
        then
A2:     len W2 + m = n + 1 by Lm15;
A3:     1 <= m & 1 <= n & n <= 1 by A1,Lm55,HEYTING3:1;
        then n = 1 by XXREAL_0:1;
        then len W2 + 1 = 1 + 1 by A1,A2,A3,XXREAL_0:1;
        hence thesis by Lm55;
      end;
      suppose not (m is odd & n is odd & m <= n & n <= len W);
        hence thesis by Def11;
      end;
    end;
    hence thesis;
  end;
end;

registration
  let G be _Graph, W be Trail of G, m,n be Element of NAT;
  cluster W.cut(m,n) -> Trail-like;
  coherence by Lm59;
end;

registration
  let G be _Graph, W be Path of G, m,n be Element of NAT;
  cluster W.cut(m,n) -> Path-like;
  coherence by Lm64;
end;

registration
  let G be _Graph, W be vertex-distinct Walk of G, m,n be Element of NAT;
  cluster W.cut(m,n) -> vertex-distinct;
  coherence
  proof
    set W2 = W.cut(m,n);
    now per cases;
      suppose
A1:     m is odd & n is odd & m <= n & n <= len W;
        then reconsider m' = m as odd Element of NAT;
        now
          let a,b be odd Element of NAT;
          assume
A2:       a <= len W2 & b <= len W2 & W2.a = W2.b;
          reconsider aaa1 = a-1, baa1 = b-1 as even Element of NAT
          by HEYTING3:1,INT_1:18;
          aaa1 < len W2 - 0 & baa1 < len W2 - 0 by A2,XREAL_1:17;
          then
A3:       W2.(aaa1+1) = W.(m+aaa1) & m+aaa1 in dom W &
          W2.(baa1+1) = W.(m+baa1) & m+baa1 in dom W by A1,Lm15;
          then m'+aaa1 <= len W & m' + baa1 <= len W by FINSEQ_3:27;
          then aaa1+m' = baa1 + m' by A2,A3,Def29;
          hence a = b;
        end;
        hence thesis by Def29;
      end;
      suppose not (m is odd & n is odd & m <= n & n <= len W);
        hence thesis by Def11;
      end;
    end;
    hence thesis;
  end;
end;

registration
  let G be _Graph, W be closed Walk of G, m,n be Element of NAT;
  cluster W.remove(m,n) -> closed;
  coherence
  proof
    thus W.remove(m,n).first() = W.first() by Lm33
      .= W.last() by Def24
      .= W.remove(m,n).last() by Lm33;
  end;
end;

registration
  let G be _Graph, W be DWalk of G, m,n be Element of NAT;
  cluster W.remove(m,n) -> directed;
  coherence
  proof
    now per cases;
      suppose m is odd & n is odd & m <= n & n <= len W & W.m = W.n;
        then W.remove(m,n) = W.cut(1,m).append(W.cut(n,len W)) by Def12;
        hence thesis;
      end;
      suppose not (m is odd & n is odd & m <= n & n <= len W & W.m = W.n);
        hence thesis by Def12;
      end;
    end;
    hence thesis;
  end;
end;

registration
  let G be _Graph, W be trivial Walk of G, m,n be Element of NAT;
  cluster W.remove(m,n) -> trivial;
  coherence
  proof
    now per cases;
      suppose m is odd & n is odd & m <= n & n <= len W & W.m = W.n;
        then W.remove(m,n) = W.cut(1,m).append(W.cut(n,len W)) by Def12;
        hence thesis;
      end;
      suppose not (m is odd & n is odd & m <= n & n <= len W & W.m = W.n);
        hence thesis by Def12;
      end;
    end;
    hence thesis;
  end;
end;

registration
  let G be _Graph, W be Trail of G, m,n be Element of NAT;
  cluster W.remove(m,n) -> Trail-like;
  coherence
  proof
    set W2 = W.remove(m,n);
A1: len W2 <= len W by Lm26;
    now per cases;
      suppose
A2:     m is odd & n is odd & m <= n & n <= len W & W.m = W.n;
        then reconsider m'=m, n'=n as odd Element of NAT;
        now
          given a,b being even Element of NAT such that
A3:       1 <= a & a < b & b <= len W2 & W2.a = W2.b;
          1 <= b & a <= len W2 by A3,XXREAL_0:2;
          then
A4:       a in dom W2 & b in dom W2 by A3,FINSEQ_3:27;
          now per cases by A2,A4,Lm34;
            suppose a in Seg m;
              then
A5:           W2.a = W.a by A2,Lm29;
              now per cases by A2,A4,Lm34;
                suppose b in Seg m;
                  then
A6:               W2.b = W.b by A2,Lm29;
                  b <= len W by A1,A3,XXREAL_0:2;
                  hence contradiction by A3,A5,A6,Lm57;
                end;
                suppose
A7:               m <= b & b <= len W2;
                  then reconsider b2 = b-m'+n' as even Element of NAT by A2
,Lm30;
A8:               W2.b = W.b2 & b2 <= len W by A2,A7,Lm30;
                  now per cases;
                    suppose a < b2;
                      hence contradiction by A3,A5,A8,Lm57;
                    end;
                    suppose b2 <= a;
                      then
A9:                   (n-m)+b-b <= a-b by XREAL_1:15;
                      n-m >= m-m by A2,XREAL_1:15;
                      then
A10:                  0 <= a-b by A9;
                      a-b < b-b by A3,XREAL_1:16;
                      hence contradiction by A10;
                    end;
                  end;
                  hence contradiction;
                end;
              end;
              hence contradiction;
            end;
            suppose
A11:          m <= a & a <= len W2;
              then reconsider a2 = a-m'+n' as even Element of NAT by A2,Lm30;
              reconsider nm4 = n'-m' as even Element of NAT by A2,INT_1:18;
A12:          W2.a = W.a2 & a2 <= len W by A2,A11,Lm30;
              now per cases by A2,A4,Lm34;
                suppose b in Seg m;
                  then b <= m by FINSEQ_1:3;
                  hence contradiction by A3,A11,XXREAL_0:2;
                end;
                suppose
A13:              m <= b & b <= len W2;
                  then reconsider b2 = b-m'+n' as even Element of NAT
                  by A2,Lm30;
A14:              W2.b = W.b2 & b2 <= len W by A2,A13,Lm30;
                  now per cases;
                    suppose
A15:                  a2 < b2;
                      1 <= m' by HEYTING3:1;
                      then 1 <= a by A11,XXREAL_0:2;
                      then 1 <= a+nm4 by NAT_1:12;
                      hence contradiction by A3,A12,A14,A15,Lm57;
                    end;
                    suppose b2 <= a2;
                      then b + nm4 <= a + nm4;
                      hence contradiction by A3,XREAL_1:8;
                    end;
                  end;
                  hence contradiction;
                end;
              end;
              hence contradiction;
            end;
          end;
          hence contradiction;
        end;
        hence thesis by Lm57;
      end;
      suppose not (m is odd & n is odd & m <= n & n <= len W & W.m = W.n);
        hence thesis by Def12;
      end;
    end;
    hence thesis;
  end;
end;

registration
  let G be _Graph, W be Path of G, m,n be Element of NAT;
  cluster W.remove(m,n) -> Path-like;
  coherence
  proof
    set W2 = W.remove(m,n);
A1: len W2 <= len W by Lm26;
    now per cases;
      suppose
A2:     m is odd & n is odd & m <= n & n <= len W & W.m = W.n;
        then reconsider m'=m, n'=n as odd Element of NAT;
        now
          let x,y be odd Element of NAT;
          assume
A3:       x < y & y <= len W2 & W2.x = W2.y;
          then
A4:       1 <= x & 1 <= y & x <= len W2 by HEYTING3:1,XXREAL_0:2;
          then
A5:       x in dom W2 & y in dom W2 by A3,FINSEQ_3:27;
A6:       x <= len W & y <= len W by A1,A3,A4,XXREAL_0:2;
          now per cases by A2,A5,Lm34;
            suppose x in Seg m;
              then
A7:           W2.x = W.x by A2,Lm29;
              now per cases by A2,A5,Lm34;
                suppose y in Seg m;
                  then W2.y = W.y by A2,Lm29;
                  then x = 1 & y = len W by A3,A6,A7,Def28;
                  hence x = 1 & y = len W2 by A1,A3,XXREAL_0:1;
                end;
                suppose
A8:               m <= y & y <= len W2;
                  then
A9:               W2.y = W.(y-m+n) & y-m+n is Element of NAT & y-m+n <= len W
                  by A2,Lm30;
                  reconsider y2 = y-m'+n' as odd Element of NAT by A2,A8,Lm30;
                  y-m + n >= y-m+m by A2,XREAL_1:9;
                  then
A10:              x < y2 & y2 <= len W by A2,A3,A8,Lm30,XXREAL_0:2;
                  then x = 1 & y2 = len W by A3,A7,A9,Def28;
                  then len W2 + n = y -m + n + m by A2,Lm24
                    .= y + n;
                  hence x = 1 & y = len W2 by A3,A7,A9,A10,Def28;
                end;
              end;
              hence x = 1 & y = len W2;
            end;
            suppose
A11:          m <= x & x <= len W2;
              then
A12:          W2.x = W.(x-m+n) & x-m+n is Element of NAT & x -m+n <= len W
              by A2,Lm30;
              reconsider x2 = x-m'+n' as odd Element of NAT by A2,A11,Lm30;
              now per cases by A2,A5,Lm34;
                suppose y in Seg m;
                  then y <= m by FINSEQ_1:3;
                  hence x = 1 & y = len W2 by A3,A11,XXREAL_0:2;
                end;
                suppose
A13:              m <= y & y <= len W2;
                  then
A14:              W2.y = W.(y-m+n) & y-m+n is Element of NAT & y-m+n <= len W
                  by A2,Lm30;
                  reconsider y2 = y-m'+n' as odd Element of NAT
                  by A2,A13,Lm30;
                  x + (n - m) < y + (n-m) by A3,XREAL_1:10;
                  then
A15:              x2 < y2;
                  then
A16:              x2 = 1 & y2 = len W by A3,A12,A14,Def28;
                  then
A17:              len W2 + n = y -m + n + m by A2,Lm24
                    .= y + n;
                  reconsider xm4 = x-m as Element of NAT by A11,INT_1:18;
                  1 <= n' by HEYTING3:1;
                  then x2 - n' <= 1-1 by A16,XREAL_1:15;
                  then
A18:              xm4 = 0;
                  then
A19:              m <= 1 by A2,A3,A12,A14,A15,Def28;
                  1 <= m' by HEYTING3:1;
                  hence x = 1 & y = len W2 by A17,A18,A19,XXREAL_0:1;
                end;
              end;
              hence x = 1 & y = len W2;
            end;
          end;
          hence x = 1 & y = len W2;
        end;
        hence thesis by Def28;
      end;
      suppose not (m is odd & n is odd & m <= n & n <= len W & W.m = W.n);
        hence thesis by Def12;
      end;
    end;
    hence thesis;
  end;
end;

definition
  let G be _Graph, W be Walk of G;
  mode Subwalk of W -> Walk of G means
    :Def32: ::dSUBWALK
    it is_Walk_from W.first(), W.last() & ex es being Subset of W.edgeSeq() st
    it.edgeSeq() = Seq es;
  existence
  proof
    take W;
    thus W is_Walk_from W.first(), W.last() by Def23;
    reconsider es = W.edgeSeq() as Subset of W.edgeSeq() by GRAPH_2:28;
    take es;
    thus W.edgeSeq() = Seq es by FINSEQ_3:125;
  end;
end;

Lm70: for G being _Graph, W being Walk of G holds W is Subwalk of W
proof
  let G be _Graph, W be Walk of G;
A1: W is_Walk_from W.first(),W.last() by Def23;
  reconsider es = W.edgeSeq() as Subset of W.edgeSeq() by GRAPH_2:28;
  W.edgeSeq() = Seq es by FINSEQ_3:125;
  hence thesis by A1,Def32;
end;

Lm71: for
G be _Graph, W1 be Walk of G, W2 be Subwalk of W1, W3 be Subwalk of W2
holds W3 is Subwalk of W1
proof
  let G be _Graph, W1 be Walk of G, W2 be Subwalk of W1, W3 be Subwalk of W2;
  set fs = W1.edgeSeq(),fs1 = W2.edgeSeq(),fs2 = W3.edgeSeq();
  W2 is_Walk_from W1.first(), W1.last() &
  ex fss being Subset of fs st fs1 = Seq fss by Def32;
  then
A2: W2.first() = W1.first() & W2.last() = W1.last() by Def23;
  consider fss1 being Subset of fs1 such that
A3: fs2 = Seq fss1 by Def32;
  consider fss being Subset of fs such that
A4: fs1 = Seq fss by Def32;
  set fss2 = fss | rng((Sgm dom fss)|dom fss1);
  reconsider fss2 as Subset of fs by GRAPH_2:29;
  fs2 = Seq fss2 by A3,A4,GRAPH_2:30;
  hence W3 is Subwalk of W1 by A2,Def32;
end;

Lm72: for G be _Graph, W1,W2 be Walk of G holds W1 is Subwalk of W2 implies
len W1 <= len W2
proof
  let G be _Graph, W1,W2 be Walk of G;
  assume W1 is Subwalk of W2;
  then consider es being Subset of W2.edgeSeq() such that
A1: W1.edgeSeq() = Seq es by Def32;
  2*len W1.edgeSeq() <= 2*len W2.edgeSeq() by A1,Th3,XREAL_1:66;
  then 2*len W1.edgeSeq()+1 <= 2*len W2.edgeSeq() + 1 by XREAL_1:9;
  then len W1 <= 2*len W2.edgeSeq() + 1 by Def15;
  hence thesis by Def15;
end;

definition
  let G be _Graph, W be Walk of G, m,n being Element of NAT;
  redefine func W.remove(m,n) -> Subwalk of W;
  coherence
  proof
    set W2 = W.remove(m,n), es1 = W2.edgeSeq();
    now per cases;
      suppose
A1:     m is odd & n is odd & m <= n & n <= len W & W.m = W.n;
        then reconsider m'=m, n'=n as odd Element of NAT;
        W is_Walk_from W.first(), W.last() by Def23;
        then
A2:     W2 is_Walk_from W.first(), W.last() by Lm25;
        reconsider maa1 = m'-1 as even Element of NAT by HEYTING3:1,INT_1:18;
        reconsider lenWn4 = len W - n' as even Element of NAT by A1,INT_1:18;
        reconsider n1 = n'+1 as even Element of NAT;
        reconsider lenWaa1 = len W - 1 as even Element of NAT by HEYTING3:1
,INT_1:18;
        2 divides maa1 & 2 divides lenWn4 & 2 divides lenWaa1 & 2 divides n1
        by PEPIN:22;
        then
A3:     maa1 = 2 * (maa1 div 2) & lenWn4 = 2 * (lenWn4 div 2) &
        lenWaa1 = 2 * (lenWaa1 div 2) & n1 = 2 * (n1 div 2) by NAT_D:3;
        set X = {x where x is Element of NAT : 1 <= x & x <= maa1 div 2};
        set Y = {x where x is Element of NAT :
        n1 div 2 <= x & x <= lenWaa1 div 2};
        set Z = X \/ Y, es = W.edgeSeq() | Z;
        now
          let x be set;
          assume
A4:       x in Z;
          now per cases by A4,XBOOLE_0:def 3;
            suppose x in X;
              then consider y being Element of NAT such that
A5:           y = x & 1 <= y & y <= maa1 div 2;
A6:           1 <= y+y by A5,NAT_1:12;
              2*y <= maa1 by A3,A5,XREAL_1:66;
              then 2*y <= maa1+1 by NAT_1:12;
              then 2*y <= n by A1,XXREAL_0:2;
              then 2*y <= len W by A1,XXREAL_0:2;
              then 2*y in dom W by A6,FINSEQ_3:27;
              hence x in dom W.edgeSeq() by A5,Lm41;
            end;
            suppose x in Y;
              then consider y being Element of NAT such that
A7:           y = x & n1 div 2 <= y & y <= lenWaa1 div 2;

::                2 * (n1 div 2) <= 2 * y by D1, AXIOMS:25; then
A8:           n1 <= 2*y by A3,A7,XREAL_1:66;
              1 <= n1 by NAT_1:12;
              then
A9:           1 <= 2*y by A8,XXREAL_0:2;
              2*y <= lenWaa1 by A3,A7,XREAL_1:66;
              then 2*y <= lenWaa1+1 by NAT_1:12;
              then 2*y in dom W by A9,FINSEQ_3:27;
              hence x in dom W.edgeSeq() by A7,Lm41;
            end;
          end;
          hence x in dom W.edgeSeq();
        end;
        then
A10:    Z c= dom W.edgeSeq() by TARSKI:def 3;
        then
A11:    dom W.edgeSeq() /\ Z = Z by XBOOLE_1:28;
        then
A12:    dom es = Z by RELAT_1:90;
A13:    Z c= Seg len W.edgeSeq() by A10,FINSEQ_1:def 3;
        then
A14:    X c= Seg len W.edgeSeq() & Y c= Seg len W.edgeSeq() by XBOOLE_1:11;
        reconsider Z as finite set by A10;
        reconsider X,Y as finite set by A13,FINSET_1:13,XBOOLE_1:11;
A15:    now
          let a,b be Element of NAT;
          assume
A16:      a in X & b in Y;
          then consider a' being Element of NAT such that
A17:      a'=a & 1 <= a' & a' <= maa1 div 2;
          consider b' being Element of NAT such that
A18:      b'=b & n1 div 2 <= b' & b' <= lenWaa1 div 2 by A16;
          2*a' <= maa1 by A3,A17,XREAL_1:66;
          then 2*a' < maa1+1 by NAT_1:13;
          then 2*a' < n by A1,XXREAL_0:2;
          then
A19:      2*a'+0 < n+1 by XREAL_1:10;
A20:      n+1 <= 2*b' by A3,A18,XREAL_1:66;
          then 2*a' < 2*b' by A19,XXREAL_0:2;
          then a' <= b' by XREAL_1:70;
          hence a < b by A17,A18,A19,A20,XXREAL_0:1;
        end;
        W.edgeSeq() is Subset of W.edgeSeq() by GRAPH_2:28;
        then reconsider es as Subset of W.edgeSeq() by GRAPH_2:29;
A21:    len W2 = 2*len W2.edgeSeq()+1 by Def15;
A22:    Seg len es1 = dom es1 by FINSEQ_1:def 3;
        set es2 = Seq es;
A23:    es2 = es * Sgm(dom es) by FINSEQ_1:def 14;
        dom es c= Seg len W.edgeSeq() by A11,A13,RELAT_1:90;
        then rng Sgm(dom es) = dom es by FINSEQ_1:def 13;
        then
A24:    dom es2 = dom Sgm(Z) by A12,A23,RELAT_1:46
          .= Seg card Z by A13,FINSEQ_3:45;
A25:    len W + m - n = 2*len es1 + 1 by A1,A21,Lm31;
A26:    now per cases;
          suppose
A27:        maa1 div 2 = 0;
            now
              assume X <> {};
              then consider x being set such that
A28:          x in X by XBOOLE_0:def 1;
              consider x' being Element of NAT such that
A29:          x' = x & 1 <= x' & x' <= maa1 div 2 by A28;
              thus contradiction by A27,A29;
            end;
            hence card X = maa1 div 2 by A27;
          end;
          suppose maa1 div 2 <> 0;
            then consider k being Nat such that
A30:        maa1 div 2 = k + 1 by NAT_1:6;
            reconsider k as Element of NAT by ORDINAL1:def 13;
            maa1 div 2 = k + 1 by A30;
            hence card X = maa1 div 2 by GRAPH_2:4;
          end;
        end;
A31:    now per cases;
          suppose
A32:        n1 div 2 > lenWaa1 div 2;
A33:        now
              assume Y <> {};
              then consider x being set such that
A34:          x in Y by XBOOLE_0:def 1;
              consider x' being Element of NAT such that
A35:          x' = x & n1 div 2 <= x' & x' <= lenWaa1 div 2 by A34;
              thus contradiction by A32,A35,XXREAL_0:2;
            end;
            lenWaa1 < n+1 by A3,A32,XREAL_1:70;
            then lenWaa1 + 1 <= n+1 by NAT_1:13;
            then len W <= n'+1;
            then len W < n+1 by XXREAL_0:1;
            then len W <= n by NAT_1:13;
            then len W = n by A1,XXREAL_0:1;
            hence card Y = lenWn4 div 2 by A33,CARD_1:47,NAT_2:4;
          end;
          suppose n1 div 2 <= lenWaa1 div 2;
            then reconsider k = (lenWaa1 div 2) - (n1 div 2) as Element of NAT
            by INT_1:18;
            Y = {x where x is Element of NAT:
            n1 div 2 <= x & x <= n1 div 2 + k};
            then card Y = k+1 by GRAPH_2:4;
            hence card Y = lenWn4 div 2 by A3;
          end;
        end;
        now
          assume not X /\ Y = {};
          then consider x being set such that
A36:      x in X /\ Y by XBOOLE_0:def 1;
A37:      x in X & x in Y by A36,XBOOLE_0:def 4;
          then consider x' being Element of NAT such that
A38:      x' = x & 1 <= x' & x' <= maa1 div 2;
          consider y' being Element of NAT such that
A39:      y' = x & n1 div 2 <= y' & y' <= lenWaa1 div 2 by A37;
          2*x' <= maa1 by A3,A38,XREAL_1:66;
          then 2*y' < maa1+1 by A38,A39,NAT_1:13;
          then 2*y' < n by A1,XXREAL_0:2;
          then 2*y'+0 < n+1 by XREAL_1:10;
          hence contradiction by A3,A39,XREAL_1:66;
        end;
        then X misses Y by XBOOLE_0:def 7;
        then
A40:    card Z = (maa1 div 2) + (lenWn4 div 2) by A26,A31,CARD_2:53;
A41:    dom Sgm X = Seg (maa1 div 2) by A13,A26,FINSEQ_3:45,XBOOLE_1:11;
A42:    dom Sgm Y = Seg (lenWn4 div 2) by A13,A31,FINSEQ_3:45,XBOOLE_1:11;
A43:    X = {x where x is Element of NAT : 0+1 <= x & x <= 0+(maa1 div 2)};
        now
          assume n1 div 2 < 1;
          then 2*(n1 div 2) < 2*1 by XREAL_1:70;
          then n + 1 - 1 < 2 - 1 by A3,XREAL_1:16;
          then n' < 1;
          hence contradiction by HEYTING3:1;
        end;
        then reconsider n1div2aa1 = (n1 div 2) - 1 as Element of NAT
        by INT_1:18;
        set lenY = lenWaa1 div 2 - n1div2aa1;
        now
          assume n1div2aa1 > lenWaa1 div 2;
          then 2*n1div2aa1 > 2 * (lenWaa1 div 2) by XREAL_1:70;
          then n+1 - 1 - 1 > len W - 1 by A3;
          hence contradiction by A1,XREAL_1:11;
        end;
        then reconsider lenY as Element of NAT by INT_1:18;
A44:    Y = {x where x is Element of NAT:
        n1div2aa1+1 <= x & x <= n1div2aa1+lenY};
A45:    len (Sgm X) = maa1 div 2 by A41,FINSEQ_1:def 3;
        now
          let x' be set;
          assume
A46:      x' in dom es1;
          then reconsider x = x' as Element of NAT;
A47:      1 <= x & x <= len es1 by A46,FINSEQ_3:27;
          then
A48:      es1.x = W2.(2*x) by Def15;
          now per cases;
            suppose
A49:          2*x+1 <= m;
              then
A50:          2*x+1-1 < m - 0 by XREAL_1:17;
              1 <= x+x by A47,NAT_1:12;
              then 2*x in Seg m by A50,FINSEQ_1:3;
              then
A51:          es1.x' = W.(2*x) by A1,A48,Lm29;
A52:          Sgm(Z).x = (Sgm(X) ^ Sgm(Y)).x by A14,A15,FINSEQ_3:48;
              2*x+1-1 <= maa1 by A49,XREAL_1:15;
              then
A53:          x <= maa1 div 2 by A3,XREAL_1:70;
              then x in dom Sgm X by A41,A47,FINSEQ_1:3;
              then Sgm(Z).x = Sgm(X).x by A52,FINSEQ_1:def 7
                .= 0+x by A43,A47,A53,GRAPH_2:5;
              then
A54:          es2.x = es.x by A3,A12,A22,A23,A24,A25,A40,A46,FUNCT_1:22;
              x in X by A47,A53;
              then
A55:          x in dom es by A12,XBOOLE_0:def 3;
              then
A56:          es2.x = W.edgeSeq().x by A54,FUNCT_1:70;
              x <= len W.edgeSeq() by A12,A13,A55,FINSEQ_1:3;
              hence es1.x' = es2.x' by A47,A51,A56,Def15;
            end;
            suppose
A57:          2*x+1 > m;
              then
A58:          m <= 2*x by NAT_1:13;
              2*x <= 2*len es1 by A47,XREAL_1:66;
              then 2*x <= 2*len es1 + 1 by NAT_1:12;
              then
A59:          2*x <= len W2 by Def15;
              then
A60:          es1.x' = W.(2*x-m+n) & 2*x-m+n is Element of NAT &
              2*x-m+n <= len W by A1,A48,A58,Lm30;
A61:          Sgm(Z).x = (Sgm(X) ^ Sgm(Y)).x by A14,A15,FINSEQ_3:48;
A62:          now
                assume x <= maa1 div 2;
                then 2*x <= maa1 by A3,XREAL_1:66;
                then 2*x+1 <= maa1+1 by XREAL_1:9;
                hence contradiction by A57;
              end;
              then consider k being Nat such that
A63:          x = maa1 div 2 + k by NAT_1:10;
              reconsider k as Element of NAT by ORDINAL1:def 13;
              k <> 0 by A62,A63;
              then 0 < k;
              then 0+1 < k+1 by XREAL_1:10;
              then
A64:          1 <= k by NAT_1:13;
A65:          now
                assume lenWn4 div 2 < x - (maa1 div 2);
                then 2 * (lenWn4 div 2) < 2*(x - (maa1 div 2)) by XREAL_1:70;
                then
A66:            lenWn4 + n < 2*x - m + 1 + n by A3,XREAL_1:10;
                set z = 2*x-m'+n';
                reconsider z as Element of NAT by A1,A58,A59,Lm30;
                2*x-m'+n' < len W by A60,XXREAL_0:1;
                then z+1 <= len W by NAT_1:13;
                hence contradiction by A66;
              end;
              then k in dom Sgm(Y) by A42,A63,A64,FINSEQ_1:3;
              then Sgm(Z).x = Sgm(Y).k by A45,A61,A63,FINSEQ_1:def 7
                .= n1div2aa1 + k by A3,A44,A63,A64,A65,GRAPH_2:5;
              then
A67:          es2.x = es.(n1div2aa1 + k) by A3,A12,A22,A23,A24,A25,A40,A46,
FUNCT_1:22;
A68:          1 <= n1div2aa1+k by A64,NAT_1:12;
A69:          n1div2aa1 + 1 <= n1div2aa1 + k by A64,XREAL_1:9;
A70:          now
                assume lenWaa1 div 2 < k + n1div2aa1;
                then lenWaa1 < 2*(x - (maa1 div 2) + n1div2aa1)
                by A3,A63,XREAL_1:70;
                then
A71:            lenWaa1 + 1 < 2*x-m+n+1 by A3,XREAL_1:10;
                reconsider z = 2*x-m'+n' as Element of NAT by A1,A58,A59,Lm30;
                len W <= z by A71,NAT_1:13;
                hence contradiction by A60,XXREAL_0:1;
              end;
              then n1div2aa1 + k in Y by A69;
              then n1div2aa1+k in dom es by A12,XBOOLE_0:def 3;
              then
A72:          es.(n1div2aa1+k) = W.edgeSeq().(n1div2aa1+k) by FUNCT_1:70;
              consider lenWaa1' being even Element of NAT such that
A73:          lenWaa1' = lenWaa1 & len W.edgeSeq() = lenWaa1' div 2 by Lm42;
A74:          es2.x = W.(2*(n1div2aa1+k)) by A67,A68,A70,A72,A73,Def15;
              2*(n1div2aa1 + k) = 2*x - m + n by A3,A63;
              hence es1.x' = es2.x' by A1,A48,A58,A59,A74,Lm30;
            end;
          end;
          hence es1.x' = es2.x';
        end;
        then W2.edgeSeq() = Seq es by A3,A22,A24,A25,A40,FUNCT_1:9;
        hence W.remove(m,n) is Subwalk of W by A2,Def32;
      end;
      suppose not (m is odd & n is odd & m <= n & n <= len W & W.m = W.n);
        then W.remove(m,n) = W by Def12;
        hence thesis by Lm70;
      end;
    end;
    hence thesis;
  end;
end;

registration
  let G be _Graph, W be Walk of G;
  cluster Trail-like Path-like Subwalk of W;
  existence
  proof
    defpred P1[Element of NAT,set,set] means
    ($2 is Walk of G & ex Wn being Walk of G st Wn = $2 &
    $3 = Wn.remove(Wn.find(2*$1+1),Wn.rfind(2*$1+1))) or
    (not $2 is Walk of G & $3 = $2);
A1: now
      let n be Element of NAT, x be set;
      now per cases;
        suppose x is Walk of G;
          then reconsider W = x as Walk of G;
          set y = W.remove(W.find(2*n+1),W.rfind(2*n+1));
          P1[n,x,y];
          hence ex y being set st P1[n,x,y];
        end;
        suppose not x is Walk of G;
          hence ex y being set st P1[n,x,y];
        end;
      end;
      hence ex y being set st P1[n,x,y];
    end;
    consider f being Function such that
A3: dom f = NAT & f.0 = W & for n being Element of NAT holds P1[n,f.n,f.(n+1)]
    from RECDEF_1:sch 1(A1);
    defpred P2[Element of NAT] means f.$1 is Subwalk of W;
    reconsider W0 = f.0 as Subwalk of W by A3,Lm70;
    defpred P3[Element of NAT] means
    ex Wn being Subwalk of W st Wn = f.$1 & len Wn <= len W &
    for m being odd Element of NAT st m < 2*$1+1 & m <= len Wn
    holds Wn.rfind(m) = m;
    for m being odd Element of NAT st m < 2*0+1 & m <= len W0
    holds W0.rfind(m) = m by HEYTING3:1;
    then
A4: P3[0] by A3;
    now
      let n be Element of NAT;
      assume P3[n];
      then consider Wn being Subwalk of W such that
A5:   Wn = f.n & len Wn <= len W &
      for m being odd Element of NAT st m < 2*n+1 & m <= len Wn
      holds Wn.rfind(m) = m;
      set a = Wn.find(2*n+1), b = Wn.rfind(2*n+1);
      set Wn1 = Wn.remove(a,b);
      reconsider Wn1 as Subwalk of W by Lm71;
      take Wn1;
      P1[n,f.n,f.(n+1)] by A3;
      hence f.(n+1) = Wn1 by A5;
      len Wn1 <= len Wn by Lm26;
      hence len Wn1 <= len W by A5,XXREAL_0:2;
      let m be odd Element of NAT;
      assume
A6:   m < 2*(n+1)+1 & m <= len Wn1;
      then m <= 2*(n+1) by NAT_1:13;
      then m < 2*n+1+1 by XXREAL_0:1;
      then
A7:   m <= 2*n+1 by NAT_1:13;
A8:   len Wn1 <= len Wn by Lm26;
      then
A9:   m <= len Wn by A6,XXREAL_0:2;
      set W1 = Wn.cut(1,a), W2 = Wn.cut(b, len Wn);
      now per cases;
        suppose
A10:      2*n+1 <= len Wn;
          then
A11:      a <= len Wn & Wn.a = Wn.(2*n+1) & for k being odd Element of NAT st
          k <= len Wn & Wn.k = Wn.(2*n+1) holds a <= k by Def20;
A12:      b <= len Wn & Wn.b = Wn.(2*n+1) & for k being odd Element of NAT st
          k <= len Wn & Wn.k = Wn.(2*n+1) holds k <= b by A10,Def22;
A13:      a <= 2*n+1 & 2*n+1 <= b by A10,Lm49,Lm50;
          then
A14:      a <= b by XXREAL_0:2;
          then
A15:      Wn1 = W1.append(W2) by A11,A12,Def12;
A16:      now
            assume
A17:        a < 2*n+1;
            then a <= len Wn by A10,XXREAL_0:2;
            then Wn.rfind(a) = a by A5,A17;
            hence contradiction by A10,A11,A17,Def22;
          end;
          then
A18:      a = 2*n+1 by A13,XXREAL_0:1;
A19:      1 is odd & 1 <= a & 1 <= m by HEYTING3:1,JORDAN12:3;
          then
A20:      W1.last() = Wn.(2*n+1) by A11,Lm16
            .= W2.first() by A12,Lm16;
          set m' = Wn1.rfind(m);
A21:      m' >= m by A6,Lm50;
A22:      m' <= len Wn1 & Wn1.m' = Wn1.m & for k being odd Element of NAT st
          k <= len Wn1 & Wn1.k = Wn1.m holds k <= m' by A6,Def22;
          then
A23:      m' <= len Wn by A8,XXREAL_0:2;
          now per cases by A7,XXREAL_0:1;
            suppose
A24:          m < 2*n+1;
              then
A25:          Wn.rfind(m) = m by A5,A9;
              m < len Wn.cut(1,a) by A10,A18,A24,Lm22;
              then
A26:          Wn1.cut(1,m) = Wn.cut(1,a).cut(1,m) by A15,A19,A20,Lm21
                .= Wn.cut(1,m) by A7,A18,Lm20;
              reconsider maa1 = m - 1 as Element of NAT by HEYTING3:1,INT_1:18;
A27:          maa1 + 1 = m;
A28:          maa1 < m - 0 by XREAL_1:17;
              then maa1 < len Wn1.cut(1,m) by A6,Lm22;
              then
A29:          Wn1.m = Wn.cut(1,m).m by A6,A19,A26,A27,Lm15;
              maa1 < len Wn.cut(1,m) by A6,A8,A28,Lm22,XXREAL_0:2;
              then
A30:          Wn1.m = Wn.m by A9,A19,A27,A29,Lm15;
              now per cases;
                suppose
A31:              m' < a;
                  then
A32:              m' < len Wn.cut(1,a) by A11,Lm22;
A33:              1 <= m' by HEYTING3:1;
                  then
A34:              Wn1.cut(1,m') = Wn.cut(1,a).cut(1,m')
                  by A15,A20,A32,Lm21,JORDAN12:3
                    .= Wn.cut(1,m') by A31,Lm20;
                  reconsider m'aa1 = m' - 1 as Element of NAT
                  by HEYTING3:1,INT_1:18;
A35:              m'aa1 < m' - 0 by XREAL_1:17;
                  then m'aa1 < len Wn1.cut(1,m') by A22,Lm22;
                  then
A36:              Wn1.m' = Wn.cut(1,m').(m'aa1+1)
                  by A22,A33,A34,Lm15,JORDAN12:3;
                  m'aa1 < len Wn.cut(1,m') by A23,A35,Lm22;
                  then Wn.m' = Wn.m by A22,A23,A30,A33,A36,Lm15,JORDAN12:3;
                  then m' <= m by A9,A23,A25,Def22;
                  hence Wn1.rfind(m) = m by A21,XXREAL_0:1;
                end;
                suppose
A37:              a <= m';
                  set x = m' - a + b;
A38:              Wn1.m' = Wn.x & x is Element of NAT & x <= len Wn
                  by A11,A12,A14,A22,A37,Lm30;
                  reconsider x as Element of NAT by A11,A12,A14,A22,A37,Lm30;
A39:              x <= m by A9,A22,A25,A30,A38,Def22;
                  m' + a <= m' + b by A14,XREAL_1:9;
                  then m' + a - a <= m' + b - a by XREAL_1:15;
                  then m' <= m by A39,XXREAL_0:2;
                  hence Wn1.rfind(m) = m by A21,XXREAL_0:1;
                end;
              end;
              hence Wn1.rfind(m) = m;
            end;
            suppose
A40:          m = 2*n+1;
              then m <= len Wn.cut(1,a) by A10,A18,Lm22;
              then
A41:          Wn1.cut(1,m) = Wn.cut(1,a).cut(1,m) by A15,A19,A20,Lm21
                .= Wn.cut(1,m) by A7,A18,Lm20;
              reconsider maa1 = m - 1 as Element of NAT by HEYTING3:1,INT_1:18;
A42:          maa1 + 1 = m;
A43:          maa1 < m - 0 by XREAL_1:17;
              then maa1 < len Wn1.cut(1,m) by A6,Lm22;
              then
A44:          Wn1.m = Wn.cut(1,m).m by A6,A19,A41,A42,Lm15;
              maa1 < len Wn.cut(1,m) by A6,A8,A43,Lm22,XXREAL_0:2;
              then
A45:          Wn1.m = Wn.m by A9,A19,A42,A44,Lm15;
              now
                assume
A46:            m < m';
                then
A47:            a < m' by A13,A16,A40,XXREAL_0:1;
                set x = m' - a + b;
                Wn1.m' = Wn.x & x is Element of NAT & x <= len Wn
                by A11,A12,A14,A22,A47,Lm30;
                then m' - a + b <= b by A10,A22,A40,A45,Def22;
                then m' - a + b - b <= b - b by XREAL_1:15;
                then m' - a + a <= 0 + a by XREAL_1:9;
                hence contradiction by A13,A16,A40,A46,XXREAL_0:1;
              end;
              hence Wn1.rfind(m) = m by A21,XXREAL_0:1;
            end;
          end;
          hence Wn1.rfind(m) = m;
        end;
        suppose
A48:      len Wn < 2*n+1;
          then a = len Wn & b = len Wn by Def20,Def22;
          then
A49:      Wn1 = Wn by Lm27;
          m < 2*n+1 by A9,A48,XXREAL_0:2;
          hence Wn1.rfind(m) = m by A5,A6,A49;
        end;
      end;
      hence Wn1.rfind(m) = m;
    end;
    then
A50: for n being Element of NAT st P3[n] holds P3[n+1];
A51: for n being Element of NAT holds P3[n] from NAT_1:sch 1(A4,A50);
    set n = len W + 1;
    consider P being Subwalk of W such that
A52: P = f.n & len P <= len W &
    for m being odd Element of NAT st m < 2*n+1 & m <= len P
    holds P.rfind(m) = m by A51;
    take P;
    now
      let m be odd Element of NAT;
      assume
A53:  m <= len P;
      len P + 0 < n by A52,XREAL_1:10;
      then len P + 0 < n+n by XREAL_1:10;
      then len P + 0 < 2*n+1 by XREAL_1:10;
      then m < 2*n+1 by A53,XXREAL_0:2;
      hence P.rfind(m) = m by A52,A53;
    end;
    then P is Path-like by Lm67;
    hence P is Trail-like & P is Path-like;
  end;
end;

definition
  let G be _Graph, W be Walk of G;
  mode Trail of W is Trail-like Subwalk of W;
  mode Path of W is Path-like Subwalk of W;
end;

registration
  let G be _Graph, W be DWalk of G;
  cluster directed Path of W;
  existence
  proof
    defpred P[Element of NAT] means
    for W1 being DWalk of G st W1.length() = $1 holds
    ex W2 being Path of W1 st W2 is directed;
    now
      let W1 be DWalk of G;
      assume W1.length() = 0;
      then
A1:   len W1 = 2*0+1 by Def15;
      consider W2 being Path of W1;
      take W2;
A2:   len W2 <= 1 by A1,Lm72;
      1 <= len W2 by HEYTING3:1;
      then len W2 = 1 by A2,XXREAL_0:1;
      then W2 is trivial by Lm55;
      then consider v being Vertex of G such that
A3:   W2 = G.walkOf(v) by Lm56;
      thus W2 is directed by A3;
    end;
    then
A4: P[0];
    now
      let k be Element of NAT;
      assume
A5:   P[k];
      let W1 be DWalk of G;
      assume
A6:   W1.length() = k + 1;
      then
A7:   len W1 = 2*(k+1)+1 by Def15
        .= 2*k+1+2;
      then
A8:   2*k+1+2-2 < len W1 - 0 by XREAL_1:17;
      set WA = W1.cut(1,2*k+1);
      len WA = 2*k+1 by A8,Lm22;
      then
A9:   2*k+1 = 2*WA.length()+1 by Def15;
      then consider WB being Path of WA such that
A10:  WB is directed by A5;
      set e = W1.(2*k+1+1), v = W1.(2*k+1+2);
A11:  e DJoins W1.(2*k+1), v, G by A8,Lm51;
A12:  WB is_Walk_from WA.first(), WA.last() by Def32;
      1 is odd & 1 <= 2*k+1 by JORDAN12:3,NAT_1:12;
      then
A13:  WA.first() = W1.1 & WA.last() = W1.(2*k+1) by A8,Lm16;
      then
A14:  WB.first() = W1.1 & WB.last() = W1.(2*k+1) by A12,Def23;
      then
A15:  e Joins WB.last(), v, G by A11,GLIB_000:19;
A16:  WA.edgeSeq() c= W1.edgeSeq() by Lm43;
      now per cases;
        suppose WB is closed;
          then
A17:      W1.first() = W1.(2*k+1) by A14,Def24;
          set W2 = W1.remove(1,2*k+1);
          W2 = W1.cut(2*k+1, 2*k+1+2) by A7,A17,Lm32;
          then len W2 + (2*k+1) = 2*k+1+2+1 by A7,A8,Lm15
            .= 2*k+1+(2+1);
          then reconsider W2 as Path of W1 by Lm69;
          take W2;
          thus W2 is directed;
        end;
        suppose
A18:      WB is open;
          consider esb being Subset of WA.edgeSeq() such that
A19:      WB.edgeSeq() = Seq esb by Def32;
A20:      now
            let x be set;
            assume x in dom esb;
            then [x,esb.x] in esb by FUNCT_1:8;
            then x in dom WA.edgeSeq() by FUNCT_1:8;
            hence x in Seg k by A9,FINSEQ_1:def 3;
          end;
          then
A21:      dom esb c= Seg k by TARSKI:def 3;
A22:      Seq esb = esb * (Sgm (dom esb)) by FINSEQ_1:def 14;
A23:      Seq esb is one-to-one by A19,Def27;
          rng Sgm(dom esb) = dom esb by A21,FINSEQ_1:def 13;
          then
A24:      esb is one-to-one & Sgm(dom esb) is one-to-one by A22,A23,FUNCT_1:48;
          now per cases;
            suppose v in WB.vertices();
              then consider n being odd Element of NAT such that
A25:          n <= len WB & WB.n = v by Lm45;
              reconsider WB' = WB as directed Path of G by A10;
              set W2 = WB'.cut(1,n);
              2*0+1 <= n by HEYTING3:1;
              then
A26:          W2 is_Walk_from W1.first(), W1.last() by A7,A14,A25,Lm16;
              len W2 = n by A25,Lm22;
              then consider naa1 being even Element of NAT such that
A27:          naa1 = n - 1 & len W2.edgeSeq() = naa1 div 2 by Lm42;
              set es = esb | (rng (Sgm (dom esb) | Seg (naa1 div 2)));
              reconsider es as Subset of WA.edgeSeq() by GRAPH_2:29;
              for x being set st x in es holds x in W1.edgeSeq()
              by A16,TARSKI:def 3;
              then reconsider es as Subset of W1.edgeSeq() by TARSKI:def 3;
A28:          W2.edgeSeq() c= WB.edgeSeq() by Lm43;
A29:          Seq es = es * Sgm (dom es) by FINSEQ_1:def 14;
A30:          es c= esb by RELAT_1:88;
              now
                let z be set;
                hereby
                  assume
A31:              z in esb;
                  now per cases;
                    suppose z in es;
                      hence z in es \/ (esb \ es) by XBOOLE_0:def 3;
                    end;
                    suppose not z in es;
                      then z in esb \ es by A31,XBOOLE_0:def 5;
                      hence z in es \/ (esb \ es) by XBOOLE_0:def 3;
                    end;
                  end;
                  hence z in es \/ (esb \ es);
                end;
                assume
A32:            z in es \/ (esb \ es);
                now per cases by A32,XBOOLE_0:def 3;
                  suppose z in es;
                    hence z in esb by A30;
                  end;
                  suppose z in esb \ es;
                    hence z in esb by XBOOLE_0:def 5;
                  end;
                end;
                hence z in esb;
              end;
              then esb = es \/ (esb \ es) by TARSKI:2;
              then
A33:          dom esb = dom es \/ dom (esb \ es) by RELAT_1:13;
              esb \ es c= esb by XBOOLE_1:36;
              then dom (esb \ es) c= dom esb by RELAT_1:25;
              then
A34:          dom (esb \ es) c= Seg k by A21,XBOOLE_1:1;
              dom es c= dom esb by A30,RELAT_1:25;
              then
A35:          dom es c= Seg k by A21,XBOOLE_1:1;
              now
                let z be set;
                assume
A36:            z in rng (Sgm (dom esb) | Seg (naa1 div 2));
                rng (Sgm (dom esb) | Seg (naa1 div 2)) c= rng Sgm (dom esb )
                by RELAT_1:99;
                then z in rng Sgm (dom esb) by A36;
                hence z in dom esb by A21,FINSEQ_1:def 13;
              end;
              then rng (Sgm (dom esb) | Seg (naa1 div 2)) c= dom esb
              by TARSKI:def 3;
              then
A37:          dom es = rng (Sgm (dom esb) | Seg (naa1 div 2) ) by RELAT_1:91;
              2 divides naa1 by PEPIN:22;
              then
A38:          2*(naa1 div 2) = naa1 by NAT_D:3;
A39:          dom Sgm(dom esb) = dom WB.edgeSeq() by A19,Th6
                .= Seg len WB.edgeSeq() by FINSEQ_1:def 3;
              now
                assume naa1 div 2 > len WB.edgeSeq();
                then naa1 > 2 * len WB.edgeSeq() by A38,XREAL_1:70;
                then naa1+1 > 2*len WB.edgeSeq() + 1 by XREAL_1:10;
                hence contradiction by A25,A27,Def15;
              end;
              then Seg (naa1 div 2) c= dom Sgm (dom esb) by A39,FINSEQ_1:7;
              then
A40:          dom (Sgm(dom esb)| Seg(naa1 div 2)) = Seg ( naa1 div 2)
              by RELAT_1:91;
              then reconsider ses = Sgm(dom esb)|Seg(naa1 div 2) as
              FinSequence by FINSEQ_1:def 2;
A41:          len ses = naa1 div 2 by A40,FINSEQ_1:def 3;
              ses is one-to-one by A24,FUNCT_1:84;
              then card dom es = naa1 div 2 by A37,A41,FINSEQ_4:77;
              then card es = naa1 div 2 by PRE_CIRC:21;
              then
A42:          len Seq es = len W2.edgeSeq() by A27,Th5;
              reconsider esbes1 = esb \ es as Function;
              now
                let a,b be Element of NAT;
                assume
A43:            a in dom es & b in dom (esbes1);
                then consider xa being set such that
A44:            xa in dom ses & ses.xa = a by A37,FUNCT_1:def 5;
                reconsider xa as Element of NAT by A44;
A45:            a = Sgm(dom esb).xa by A44,FUNCT_1:70;
A46:            xa in Seg(naa1 div 2) & xa in dom Sgm(dom esb)
                by A44,RELAT_1:86;
A47:            [b, esbes1.b] in esb \ es by A43,FUNCT_1:8;
                then
A48:            [b, esbes1.b] in esb by XBOOLE_0:def 5;
                then b in dom esb by FUNCT_1:8;
                then b in rng (Sgm (dom esb)) by A21,FINSEQ_1:def 13;
                then consider xb being set such that
A49:            xb in dom (Sgm (dom esb)) & Sgm(dom esb).xb = b
                by FUNCT_1:def 5;
                reconsider xb as Element of NAT by A49;
A50:            1 <= xa & xa <= naa1 div 2 by A46,FINSEQ_1:3;
A51:            1 <= xb & xb <= len WB.edgeSeq() by A39,A49,FINSEQ_1:3;
                then xb in dom Seq esb by A19,FINSEQ_3:27;
                then xb in dom Sgm (dom esb) by Th6;
                then
A52:            xb <= len Sgm(dom esb) by FINSEQ_3:27;
                now
                  assume xb <= xa;
                  then xb <= naa1 div 2 by A50,XXREAL_0:2;
                  then
A53:              xb in Seg(naa1 div 2) by A51,FINSEQ_1:3;
                  [xb, b] in Sgm(dom esb) by A49,FUNCT_1:8;
                  then [xb, b] in ses by A53,RELAT_1:def 11;
                  then b in rng ses by RELAT_1:def 5;
                  then [b, esbes1.b] in es by A48,RELAT_1:def 11;
                  hence contradiction by A47,XBOOLE_0:def 5;
                end;
                hence a < b by A21,A45,A49,A50,A52,FINSEQ_1:def 13;
              end;
              then
A54:          Sgm(dom esb) = Sgm(dom es) ^ Sgm(dom (esb \ es ))
              by A33,A34,A35,FINSEQ_3:48;
A55:          dom W2.edgeSeq() c= dom Seq esb by A19,A28,RELAT_1:25;
              now
                let x be Nat;
                assume
A56:            1 <= x & x <= len W2.edgeSeq();
                then
A57:            x in dom W2.edgeSeq() by FINSEQ_3:27;
                then [x,W2.edgeSeq().x] in W2.edgeSeq() by FUNCT_1:8;
                then
A58:            W2.edgeSeq().x = (Seq esb).x by A19,A28,FUNCT_1:8
                  .= esb.(Sgm(dom esb).x) by A22,A55,A57,FUNCT_1:22;
A59:            x in dom Seq es by A42,A56,FINSEQ_3:27;
                then x in dom Sgm(dom es) by Th6;
                then
A60:            Sgm(dom esb).x = Sgm(dom es).x by A54,FINSEQ_1:def 7;
A61:            x in dom Sgm(dom esb) &
                Sgm(dom esb).x in dom esb by A22,A55,A57,FUNCT_1:21;
                then
A62:            [Sgm(dom esb).x, esb.(Sgm(dom esb).x)] in esb by FUNCT_1:8;
A63:            x in Seg (naa1 div 2) by A27,A56,FINSEQ_1:3;
                [x, Sgm(dom esb).x] in Sgm(dom esb) by A61,FUNCT_1:8;
                then [x, Sgm(dom esb).x] in ses by A63,RELAT_1:def 11;
                then Sgm(dom esb).x in rng ses by RELAT_1:def 5;
                then [Sgm(dom esb).x, esb.(Sgm(dom esb).x)] in es
                by A62,RELAT_1:def 11;
                then es.(Sgm(dom es).x) = esb.(Sgm(dom esb).x) by A60,FUNCT_1:8
;
                hence W2.edgeSeq().x = (Seq es).x by A29,A58,A59,FUNCT_1:22;
              end;
              then W2.edgeSeq() = Seq es by A42,FINSEQ_1:18;
              then reconsider W2 as Path of W1 by A26,Def32;
              take W2;
              thus W2 is directed;
            end;
            suppose
A64:          not v in WB.vertices();
              set W2 = WB.addEdge(e);
A65:          W2 is_Walk_from W1.first(), W1.last() by A7,A10,A11,A12,A13,Lm52;
              set es = esb +* ((k+1) .--> e);
A66:          dom ((k+1) .--> e) = {k+1} by FUNCOP_1:19;
              then
A67:          dom es = dom esb \/ {k+1} by FUNCT_4:def 1;
              now
                let x be set;
                assume
A68:            x in dom es;
                now per cases by A67,A68,XBOOLE_0:def 3;
                  suppose x in dom esb;
                    then
A69:                x in Seg k by A20;
                    then reconsider x'=x as Element of NAT;
A70:                1 <= x' & x' <= k by A69,FINSEQ_1:3;
                    then x' <= k+1 by NAT_1:12;
                    hence x in Seg (k+1) by A70,FINSEQ_1:3;
                  end;
                  suppose x in {k+1};
                    then
A71:                x = k+1 by TARSKI:def 1;
                    1 <= k+1 by NAT_1:12;
                    hence x in Seg (k+1) by A71,FINSEQ_1:3;
                  end;
                end;
                hence x in Seg (k+1);
              end;
              then
A72:          dom es c= Seg (k+1) by TARSKI:def 3;
              then reconsider es as FinSubsequence by FINSEQ_1:def 12;
              now
                let z be set;
                assume
A73:            z in es;
                then consider x,y being set such that
A74:            z = [x,y] by RELAT_1:def 1;
A75:            x in dom es & es.x = y by A73,A74,FUNCT_1:8;
                now per cases;
                  suppose
A76:                x in dom ((k+1) .--> e);
                    then
A77:                y = ((k+1).-->e).x by A66,A67,A75,FUNCT_4:def 1;
A78:                x = k+1 by A66,A76,TARSKI:def 1;
                    then
A79:                y = e by A77,FUNCOP_1:87;
                    reconsider x' = x as Element of NAT by A66,A76;
A80:                1 <= x' & x' <= len W1.edgeSeq() by A6,A78,NAT_1:12;
                    then
A81:                x in dom W1.edgeSeq() by FINSEQ_3:27;
                    W1.edgeSeq().x = W1.(2*(k+1)) by A78,A80,Def15
                      .= W1.(2*k+1+1);
                    hence z in W1.edgeSeq() by A74,A79,A81,FUNCT_1:8;
                  end;
                  suppose
A82:                not x in dom ((k+1) .--> e);
                    then
A83:                y = esb.x by A66,A67,A75,FUNCT_4:def 1;
                    x in dom esb by A66,A67,A75,A82,XBOOLE_0:def 3;
                    then [x,y] in esb by A83,FUNCT_1:8;
                    then [x,y] in WA.edgeSeq();
                    hence z in W1.edgeSeq() by A16,A74;
                  end;
                end;
                hence z in W1.edgeSeq();
              end;
              then reconsider es as Subset of W1.edgeSeq() by TARSKI:def 3;
              now
                assume dom esb /\ dom ((k+1).-->e) <> {};
                then consider x being set such that
A84:            x in dom esb /\ dom ((k+1).-->e) by XBOOLE_0:def 1;
A85:            x in dom esb & x in {k+1} by A66,A84,XBOOLE_0:def 4;
                then x = k+1 by TARSKI:def 1;
                then k+1 <= k+0 by A21,A85,FINSEQ_1:3;
                hence contradiction by XREAL_1:8;
              end;
              then
A86:          dom esb misses dom ((k+1).-->e) by XBOOLE_0:def 7;
A87:          W2.edgeSeq() = Seq esb ^ <*e*> by A15,A19,Lm44;
              then
A88:          len W2.edgeSeq() = len Seq esb + len <*e*> by FINSEQ_1:35
                .= len Seq esb + 1 by FINSEQ_1:56
                .= card esb + 1 by Th5;
A89:          len Seq es = card es by Th5
                .= card esb + card ((k+1).-->e) by A86,PRE_CIRC:27
                .= card esb + card {[k+1,e]} by FUNCT_4:87
                .= len W2.edgeSeq() by A88,CARD_1:50;
A90:          {k+1} c= Seg (k+1) by A67,A72,XBOOLE_1:11;
              now
                let m, n be Element of NAT;
                assume
A91:            m in dom esb & n in {k+1};
                then
A92:            n = k+1 by TARSKI:def 1;
                m <= k by A21,A91,FINSEQ_1:3;
                hence m < n by A92,NAT_1:13;
              end;
              then
A93:          Sgm(dom es)=Sgm(dom esb) ^ Sgm({k+1}) by A21,A67,A90,FINSEQ_3:48
                .=Sgm(dom esb) ^ <* k+1 *> by FINSEQ_3:50;
              now
                let n be Nat;
                assume
A94:            1 <= n & n <= len W2.edgeSeq();
                then
A95:            n in dom W2.edgeSeq() by FINSEQ_3:27;
A96:            n in dom Seq es by A89,A94,FINSEQ_3:27;
                Seq es = es * Sgm(dom es) by FINSEQ_1:def 14;
                then
A97:            (Seq es).n = es.(Sgm(dom es).n) by A96,FUNCT_1:22;
A98:            Seq esb = esb * Sgm(dom esb) by FINSEQ_1:def 14;
                now per cases by A87,A95,FINSEQ_1:38;
                  suppose
A99:                n in dom Seq esb;
                    then
A100:               W2.edgeSeq().n = (Seq esb).n by A87,FINSEQ_1:def 7
                      .= esb.(Sgm(dom esb).n) by A98,A99,FUNCT_1:22;
A101:               n in dom Sgm(dom esb) &
                    Sgm(dom esb).n in dom esb by A98,A99,FUNCT_1:21;
                    then Sgm(dom es).n=Sgm(dom esb).n by A93,FINSEQ_1:def 7;
                    hence W2.edgeSeq().n = (Seq es).n
                    by A86,A97,A100,A101,FUNCT_4:17;
                  end;
                  suppose ex m being Nat st m in dom <*e*> &
                    n = len Seq esb + m;
                    then consider m being Nat such that
A102:               m in dom <*e*> & n = len Seq esb + m;
                    m in {1} by A102,FINSEQ_1:4,def 8;
                    then
A103:               m = 1 by TARSKI:def 1;
                    then
A104:               W2.edgeSeq().n = <*e*>.1 by A87,A102,FINSEQ_1:def 7
                      .= e by FINSEQ_1:def 8;
                    len Sgm(dom esb) = card dom esb by A21,FINSEQ_3:44
                      .= card esb by PRE_CIRC:21
                      .= len Seq esb by Th5;
                    then
A105:               (Seq es).n = es.(k+1) by A93,A97,A102,A103,FINSEQ_1:59;
A106:               k+1 in dom ((k+1).-->e) by A66,TARSKI:def 1;
                    then k+1 in dom esb \/ dom ((k+1).-->e) by XBOOLE_0:def 3;
                    then (Seq es).n = ((k+1).-->e).(k+1) by A105,A106,
FUNCT_4:def 1
                      .= e by FUNCOP_1:87;
                    hence W2.edgeSeq().n = (Seq es).n by A104;
                  end;
                end;
                hence W2.edgeSeq().n = (Seq es).n;
              end;
              then W2.edgeSeq() = Seq es by A89,FINSEQ_1:18;
              then reconsider W2 as Path of W1 by A15,A18,A64,A65,Def32,Lm68;
              take W2;
              thus W2 is directed by A10,A11,A12,A13,Lm52;
            end;
          end;
          hence ex W2 being Path of W1 st W2 is directed;
        end;
      end;
      hence ex W2 being Path of W1 st W2 is directed;
    end;
    then
A107: for k being Element of NAT st P[k] holds P[k+1];
A108: for k being Element of NAT holds P[k] from NAT_1:sch 1(A4,A107);
    W.length() = W.length();
    hence thesis by A108;
  end;
end;

definition
  let G be _Graph, W be DWalk of G;
  mode DWalk of W is directed Subwalk of W;
  mode DTrail of W is directed Trail of W;
  mode DPath of W is directed Path of W;
end;

definition
  let G be _Graph;
  func G.allWalks()-> non empty
  Subset of ((the_Vertices_of G)\/(the_Edges_of G))*
  equals  ::dGALLWALKS
  {W where W is Walk of G : not contradiction};
  coherence
  proof
    set IT = {W where W is Walk of G : not contradiction};
A1: G.walkOf(choose(the_Vertices_of G)) in IT;
    now
      let x be set;
      assume x in IT;
      then consider W being Walk of G such that
A2:   x = W;
      thus x in ((the_Vertices_of G)\/(the_Edges_of G))*
      by A2,FINSEQ_1:def 11;
    end;
    hence thesis by A1,TARSKI:def 3;
  end;
end;

definition
  let G be _Graph;
  func G.allTrails() -> non empty Subset of G.allWalks()
  equals  ::dGALLTRAILS
  {W where W is Trail of G : not contradiction};
  coherence
  proof
    set IT = {W where W is Trail of G : not contradiction};
A1: G.walkOf(choose(the_Vertices_of G)) in IT;
    now
      let e be set;
      assume e in IT;
      then consider W being Trail of G such that
A2:   W = e;
      thus e in G.allWalks() by A2;
    end;
    hence thesis by A1,TARSKI:def 3;
  end;
end;

definition
  let G be _Graph;
  func G.allPaths() -> non empty Subset of G.allTrails()
  equals  ::dGALLPATHS
  {W where W is Path of G : not contradiction};
  coherence
  proof
    set IT = {W where W is Path of G : not contradiction};
A1: G.walkOf(choose(the_Vertices_of G)) in IT;
    now
      let e be set;
      assume e in IT;
      then consider W being Path of G such that
A2:   e = W;
      thus e in G.allTrails() by A2;
    end;
    hence thesis by A1,TARSKI:def 3;
  end;
end;

definition
  let G be _Graph;
  func G.allDWalks() -> non empty Subset of G.allWalks()
  equals  ::dGALLDWALKS
  {W where W is DWalk of G : not contradiction};
  coherence
  proof
    set IT = {W where W is directed Walk of G : not contradiction};
A1: G.walkOf(choose(the_Vertices_of G)) in IT;
    now
      let e be set;
      assume e in IT;
      then consider W being directed Walk of G such that
A2:   e = W;
      thus e in G.allWalks() by A2;
    end;
    hence thesis by A1,TARSKI:def 3;
  end;
end;

definition
  let G be _Graph;
  func G.allDTrails() -> non empty Subset of G.allTrails()
  equals  ::dGALLDTRAILS
  {W where W is DTrail of G : not contradiction};
  coherence
  proof
    set IT = {W where W is DTrail of G : not contradiction};
A1: G.walkOf(choose(the_Vertices_of G)) in IT;
    now
      let e be set;
      assume e in IT;
      then consider W being DTrail of G such that
A2:   e = W;
      thus e in G.allTrails() by A2;
    end;
    hence thesis by A1,TARSKI:def 3;
  end;
end;

definition
  let G be _Graph;
  func G.allDPaths() -> non empty Subset of G.allDTrails()
  equals  ::dGALLPATHS
  {W where W is directed Path of G : not contradiction};
  coherence
  proof
    set IT = {W where W is DPath of G : not contradiction};
A1: G.walkOf(choose(the_Vertices_of G)) in IT;
    now
      let e be set;
      assume e in IT;
      then consider W being DPath of G such that
A2:   e = W;
      thus e in G.allDTrails() by A2;
    end;
    hence thesis by A1,TARSKI:def 3;
  end;
end;

registration
  let G be finite _Graph;
  cluster G.allTrails() -> finite;
  correctness
  proof
    set D = (the_Vertices_of G)\/(the_Edges_of G);
A1: now
      let W be Trail of G;
      consider f being Function such that
A2:   dom f = W.edgeSeq() & for x being set st x in W.edgeSeq()
      holds f.x = x`2 from FUNCT_1:sch 3;
      now
        let y be set;
        assume y in rng f;
        then consider x being set such that
A3:     x in dom f & f.x = y by FUNCT_1:def 5;
A4:     x in W.edgeSeq() & y = x`2 by A2,A3;
        consider a,b being set such that
A5:     x = [a,b] by A2,A3,RELAT_1:def 1;
        y = b by A4,A5,MCART_1:def 2;
        then y in rng W.edgeSeq() by A2,A3,A5,RELAT_1:def 5;
        hence y in (the_Edges_of G);
      end;
      then
A6:   rng f c= the_Edges_of G by TARSKI:def 3;
      now
        let x1,x2 be set;
        assume
A7:     x1 in dom f & x2 in dom f & f.x1 = f.x2;
        then
A8:     x1 in W.edgeSeq() & f.x1 = x1`2 & x2 in W.edgeSeq() & f.x2 = x2`2
        by A2;
        consider a1,b1 being set such that
A9:     x1 = [a1,b1] by A2,A7,RELAT_1:def 1;
        consider a2,b2 being set such that
A10:    x2 = [a2,b2] by A2,A7,RELAT_1:def 1;
A11:    b1 = f.x1 by A8,A9,MCART_1:def 2
          .= b2 by A7,A8,A10,MCART_1:def 2;
A12:    W.edgeSeq() is one-to-one by Def27;
A13:    a1 in dom W.edgeSeq() & W.edgeSeq().a1 = b1 by A2,A7,A9,FUNCT_1:8;
        a2 in dom W.edgeSeq() & W.edgeSeq().a2 = b1
        by A2,A7,A10,A11,FUNCT_1:8;
        hence x1 = x2 by A9,A10,A11,A12,A13,FUNCT_1:def 8;
      end;
      then f is one-to-one by FUNCT_1:def 8;
      then card W.edgeSeq() c= card (the_Edges_of G) by A2,A6,CARD_1:26;
      then len W.edgeSeq() <= card (the_Edges_of G) by NAT_1:40;
      then len W.edgeSeq() <= G.size() by GLIB_000:def 27;
      then 2*len W.edgeSeq() <= 2*G.size() by XREAL_1:66;
      then 2*len W.edgeSeq()+1 <= 2*G.size()+1 by XREAL_1:9;
      hence len W <= 2*G.size()+1 by Def15;
    end;
    set X = {x where x is Element of D* : len x <= 2*G.size()+1};
    now
      let e be set;
      assume e in G.allTrails();
      then consider W being Trail of G such that
A14:  W = e;
A15:  e is Element of D* by A14,FINSEQ_1:def 11;
      len W <= 2*G.size()+1 by A1;
      hence e in X by A14,A15;
    end;
    then G.allTrails() c= X by TARSKI:def 3;
    hence G.allTrails() is finite by FINSET_1:13,GRAPH_5:4;
  end;
end;

definition
  let G be _Graph, X be non empty Subset of G.allWalks();
  redefine mode Element of X -> Walk of G;
  coherence
  proof
    let x be Element of X;
    x in {W where W is Walk of G : not contradiction};
    then consider y being Walk of G such that
A1: y = x;
    thus thesis by A1;
  end;
end;

definition
  let G be _Graph, X be non empty Subset of G.allTrails();
  redefine mode Element of X -> Trail of G;
  coherence
  proof
    let x be Element of X;
    x in {W where W is Trail of G : not contradiction};
    then consider y being Trail of G such that
A1: y = x;
    thus thesis by A1;
  end;
end;

definition
  let G be _Graph, X be non empty Subset of G.allPaths();
  redefine mode Element of X -> Path of G;
  coherence
  proof
    let x be Element of X;
    x in {W where W is Path of G : not contradiction};
    then consider y being Path of G such that
A1: y = x;
    thus thesis by A1;
  end;
end;

definition
  let G be _Graph, X be non empty Subset of G.allDWalks();
  redefine mode Element of X -> DWalk of G;
  coherence
  proof
    let x be Element of X;
    x in {W where W is DWalk of G : not contradiction};
    then consider y being DWalk of G such that
A1: y = x;
    thus thesis by A1;
  end;
end;

definition
  let G be _Graph, X be non empty Subset of G.allDTrails();
  redefine mode Element of X -> DTrail of G;
  coherence
  proof
    let x be Element of X;
    x in {W where W is DTrail of G : not contradiction};
    then consider y being DTrail of G such that
A1: y = x;
    thus thesis by A1;
  end;
end;

definition
  let G be _Graph, X be non empty Subset of G.allDPaths();
  redefine mode Element of X -> DPath of G;
  coherence
  proof
    let x be Element of X;
    x in {W where W is DPath of G : not contradiction};
    then consider y being DPath of G such that
A1: y = x;
    thus thesis by A1;
  end;
end;

begin :: Theorems

reserve G,G1,G2 for _Graph;
reserve W,W1,W2 for Walk of G;
reserve e,x,y,z for set;
reserve v for Vertex of G;
reserve n,m for Element of NAT;

canceled;

theorem ::tWALK02
  for n being odd Element of NAT st n <= len W holds
  W.n in the_Vertices_of G by Lm1;

theorem Th9: ::tWALK03
  for n being even Element of NAT st n in dom W holds W.n in the_Edges_of G
proof
  let n be even Element of NAT;
  assume n in dom W;
  then
A1: 1 <= n & n <= len W by FINSEQ_3:27;
  then reconsider naa1 = n-1 as odd Element of NAT by INT_1:18;
  naa1 < len W - 0 by A1,XREAL_1:17;
  then W.(naa1+1) Joins W.naa1, W.(naa1+2), G by Def3;
  hence thesis by GLIB_000:def 15;
end;

theorem ::tWALK04
  for n being even Element of NAT st n in dom W holds
  ex naa1 being odd Element of NAT st
  naa1 = n-1 & n-1 in dom W & n+1 in dom W &
  W.n Joins W.(naa1), W.(n+1),G by Lm2;

theorem Th11: ::tWALK05
  for n being odd Element of NAT st n < len W holds
  W.(n+1) in W.vertexAt(n).edgesInOut()
proof
  let n be odd Element of NAT;
  assume
A1: n < len W;
  then
A2: W.(n+1) Joins W.n, W.(n+2), G by Def3;
  W.vertexAt(n) = W.n by A1,Def8;
  hence thesis by A2,GLIB_000:65;
end;

theorem Th12: ::tWALK06
  for n being odd Element of NAT st 1 < n & n <= len W holds
  W.(n-1) in W.vertexAt(n).edgesInOut()
proof
  let n be odd Element of NAT;
  assume
A1: 1 < n & n <= len W;
  then reconsider naa1 = n-1 as even Element of NAT by INT_1:18;
A2: n - 1 <= len W - 0 by A1,XREAL_1:15;
  1+1 <= n by A1,NAT_1:13;
  then 1+1-1 <= n-1 by XREAL_1:15;
  then naa1 in dom W by A2,FINSEQ_3:27;
  then consider n5 being odd Element of NAT such that
A3: n5 = naa1-1 & naa1-1 in dom W & naa1+1 in dom W &
  W.naa1 Joins W.(n5), W.(naa1+1),G by Lm2;
  n5 <= len W by A3,FINSEQ_3:27;
  then W.(n5) = W.vertexAt(n5) by Def8;
  then W.(n-1) Joins W.vertexAt(n5), W.vertexAt(n), G by A1,A3,Def8;
  hence thesis by GLIB_000:17,65;
end;

theorem ::tWALK07
  for n being odd Element of NAT st n < len W holds
  n in dom W & n+1 in dom W & n+2 in dom W
proof
  let n be odd Element of NAT;
  assume
A1: n < len W;
A2: 1 <= n by HEYTING3:1;
A3: 1 <= n+1 & 1 <= n+2 by NAT_1:12;
  n+1 <= len W & n+2 <= len W by A1,Th1,NAT_1:13;
  hence thesis by A1,A2,A3,FINSEQ_3:27;
end;

theorem Th14: ::tWALKOFV01
  len G.walkOf(v) = 1 & G.walkOf(v).1 = v &
  G.walkOf(v).first() = v & G.walkOf(v).last() = v &
  G.walkOf(v) is_Walk_from v,v
proof thus
A1: len G.walkOf(v) = 1 & G.walkOf(v).1 = v by FINSEQ_1:57; thus
A2: G.walkOf(v).first() = v by FINSEQ_1:57;
  thus G.walkOf(v).last() = v by A1;
  hence G.walkOf(v) is_Walk_from v,v by A2,Def23;
end;

theorem Th15: ::tWALKOFE01
  e Joins x,y,G implies len G.walkOf(x,e,y) = 3
proof
  assume e Joins x,y,G;
  then G.walkOf(x,e,y) = <*x,e,y*> by Def5;
  hence thesis by FINSEQ_1:62;
end;

theorem Th16: ::tWALKOFE02
  e Joins x,y,G implies
  G.walkOf(x,e,y).first() = x & G.walkOf(x,e,y).last() = y &
  G.walkOf(x,e,y) is_Walk_from x,y
proof
  set W = G.walkOf(x,e,y);
  assume e Joins x,y,G;
  then
A1: W = <*x,e,y*> by Def5;
  then
A2: len W = 3 & W.1 = x & W.2 = e & W.3 = y by FINSEQ_1:62; thus
A3: W.first() = x by A1,FINSEQ_1:62;
  thus W.last() = y by A2;
  hence W is_Walk_from x, y by A3,Def23;
end;

theorem  ::tWFIRST01
  for W1 being Walk of G1, W2 being Walk of G2 st W1 = W2 holds
  W1.first() = W2.first() & W1.last() = W2.last();

theorem Th18: ::tWALKFROM01
  W is_Walk_from x,y iff W.1 = x & W.(len W) = y
proof
  W is_Walk_from x,y iff W.first() = x & W.last() = y by Def23;
  hence thesis;
end;

theorem ::tWALKFROM02
  W is_Walk_from x,y implies x is Vertex of G & y is Vertex of G
proof
  assume W is_Walk_from x,y;
  then W.first() = x & W.last() = y by Def23;
  hence thesis;
end;

theorem ::tWALKFROM03
  for W1 being Walk of G1, W2 being Walk of G2 st W1 = W2 holds
  W1 is_Walk_from x,y iff W2 is_Walk_from x,y
proof
  let W1 be Walk of G1, W2 be Walk of G2;
  assume
A1: W1 = W2;
  W1 is_Walk_from x,y iff W1.first() = x & W1.last() = y by Def23;
  then W1 is_Walk_from x,y iff W2.first() = x & W2.last() = y by A1;
  hence W1 is_Walk_from x,y iff W2 is_Walk_from x,y by Def23;
end;

theorem ::tWVAT01
  for W1 being Walk of G1, W2 being Walk of G2 st W1 = W2 holds
  for n being Element of NAT holds W1.vertexAt(n) = W2.vertexAt(n)
proof
  let W1 be Walk of G1, W2 be Walk of G2;
  assume
A1: W1 = W2;
  let n be Element of NAT;
  now per cases;
    suppose
A2:   n is odd & n <= len W1;
      hence W1.vertexAt(n) = W2.n by A1,Def8
        .= W2.vertexAt(n) by A1,A2,Def8;
    end;
    suppose
A3:   not (n is odd & n <= len W1);
      hence W1.vertexAt(n) = W1.first() by Def8
        .= W2.first() by A1
        .= W2.vertexAt(n) by A1,A3,Def8;
    end;
  end;
  hence thesis;
end;

theorem ::tWREV01
  len W = len W.reverse() & dom W = dom W.reverse() &
  rng W = rng W.reverse() by FINSEQ_5:60,def 3;

theorem Th23: ::tWREV02
  W.first() = W.reverse().last() & W.last() = W.reverse().first()
proof
  len W = len W.reverse() by FINSEQ_5:def 3;
  hence W.first() = W.reverse().last() by FINSEQ_5:65;
  thus W.last() = W.reverse().first() by FINSEQ_5:65;
end;

theorem Th24: ::tWREV03
  W is_Walk_from x,y iff W.reverse() is_Walk_from y, x
proof
A1: len W = len W.reverse() by FINSEQ_5:def 3;
  hereby
    assume W is_Walk_from x, y;
    then W.1 = x & W.(len W) = y by Th18;
    then W.reverse().1 = y & W.reverse().(len W) = x by FINSEQ_5:65;
    hence W.reverse() is_Walk_from y,x by A1,Th18;
  end;
  assume W.reverse() is_Walk_from y,x;
  then W.reverse().1=y & W.reverse().(len W.reverse())=x by Th18;
  then W.1 = x & W.(len W) = y by A1,FINSEQ_5:65;
  hence W is_Walk_from x,y by Th18;
end;

theorem Th25: ::tWREV04
  n in dom W implies W.n = W.reverse().(len W - n + 1) &
  (len W - n + 1) in dom W.reverse()
proof
  set rn = len W - n + 1;
  assume
A1: n in dom W;
  then n <= len W by FINSEQ_3:27;
  then reconsider rn as Element of NAT by FINSEQ_5:1;
  n in Seg len W by A1,FINSEQ_1:def 3;
  then len W - n + 1 in Seg len W by FINSEQ_5:2;
  then
A2: rn in Seg len W.reverse() by FINSEQ_5:def 3;
  then rn in dom W.reverse() by FINSEQ_1:def 3;
  then W.reverse().rn = W.(len W - rn + 1) by FINSEQ_5:def 3;
  hence thesis by A2,FINSEQ_1:def 3;
end;

theorem ::tWREV05
  n in dom W.reverse() implies W.reverse().n = W.(len W - n + 1) &
  (len W - n + 1) in dom W by Lm8;

theorem ::tWREV06
  W.reverse().reverse() = W by FINSEQ_6:29;

theorem ::tWREV07
  for W1 being Walk of G1, W2 being Walk of G2 st W1 = W2 holds
  W1.reverse() = W2.reverse();

theorem ::tWAPPND01
  W1.last() = W2.first() implies
  len W1.append(W2) + 1 = len W1 + len W2 by Lm9;

theorem ::tWAPPND02
  W1.last() = W2.first() implies
  len W1 <= len W1.append(W2) & len W2 <= len W1.append(W2) by Lm10;

theorem ::tWAPPND03
  W1.last() = W2.first() implies
  W1.append(W2).first() = W1.first() & W1.append(W2).last() = W2.last() &
  W1.append(W2) is_Walk_from W1.first(), W2.last() by Lm11;

theorem Th32: ::tWAPPND04
  W1 is_Walk_from x,y & W2 is_Walk_from y,z implies
  W1.append(W2) is_Walk_from x,z
proof
  assume W1 is_Walk_from x, y & W2 is_Walk_from y,z;
  then W1.first() = x & W1.last() = y & W2.first() = y & W2.last() = z
  by Def23;
  hence thesis by Lm11;
end;

theorem ::tWAPPND05
  n in dom W1 implies W1.append(W2).n = W1.n & n in dom W1.append(W2) by Lm12;

theorem ::tWAPPND06
  W1.last() = W2.first() implies
  for n being Element of NAT st n < len W2 holds
  W1.append(W2).(len W1 + n) = W2.(n+1) &
  (len W1 + n) in dom W1.append(W2) by Lm13;

theorem ::tWAPPND07
  n in dom W1.append(W2) implies
  n in dom W1 or ex k being Element of NAT st k < len W2 & n = len W1 + k
  by Lm14;

theorem Th36: ::tWAPPND08
  for W1A, W1B being Walk of G1, W2A,W2B being Walk of G2
  st W1A = W2A & W1B = W2B holds W1A.append(W1B) = W2A.append(W2B)
proof
  let W1A, W1B be Walk of G1, W2A, W2B be Walk of G2;
  assume
A1: W1A = W2A & W1B = W2B;
  now per cases;
    suppose
A2:   W1A.last() = W1B.first();
      then
A3:   W2A.last() = W2B.first() by A1;
      thus W1A.append(W1B) = W1A ^' W1B by A2,Def10
        .= W2A.append(W2B) by A1,A3,Def10;
    end;
    suppose
A4:   W1A.last() <> W1B.first();
      then
A5:   W2A.last() <> W2B.first() by A1;
      thus W1A.append(W1B) = W2A by A1,A4,Def10
        .= W2A.append(W2B) by A5,Def10;
    end;
  end;
  hence thesis;
end;

theorem ::tWCUT01
  for m,n being odd Element of NAT st m <= n & n <= len W holds
  len W.cut(m,n) + m = n+1 & for i being Element of NAT st i < len W.cut(m,n)
  holds W.cut(m,n).(i+1) = W.(m+i) & m+i in dom W by Lm15;

theorem ::tWCUT02
  for m, n being odd Element of NAT st m <= n & n <= len W holds
  W.cut(m,n).first() = W.m & W.cut(m,n).last() = W.n &
  W.cut(m,n) is_Walk_from W.m, W.n by Lm16;

theorem ::tWCUT03
  for m,n,o being odd Element of NAT st m <= n & n <= o & o <= len W holds
  W.cut(m,n).append(W.cut(n,o)) = W.cut(m,o) by Lm17;

theorem ::tWCUT04
  W.cut(1,len W) = W by Lm18;

theorem Th41: ::tWCUT05
  for n being odd Element of NAT st n < len W holds
  G.walkOf(W.n, W.(n+1), W.(n+2)) = W.cut(n,n+2)
proof
  let n be odd Element of NAT;
  set v1 = W.n, e = W.(n+1), v2 = W.(n+2);
  assume
A1: n < len W;
  then
A2: e Joins v1,v2,G by Def3;
  then
A3: G.walkOf(v1,e,v2) = <*v1,e,v2*> by Def5;
  set W1 = G.walkOf(v1,e,v2), W2 = W.cut(n,n+2);
A4: n <= n+2 & n+2 <= len W by A1,Th1;
  then
A5: len W.cut(n,n+2) + n = 1 + (2+n) by Lm15;
A6: len W1 = 3 by A2,Th15;
   then
X: dom W1 = Seg 3 by FINSEQ_1:def 3;
  now
    let x be Nat;
    assume
A7: x in dom W1;
    then
A8: 1 <= x & x <= 3 by A6,FINSEQ_3:27;
    then reconsider xaa1 = x-1 as Element of NAT by INT_1:18;
A9: xaa1+1 = x;
    xaa1 < 3-0 by A8,XREAL_1:17;
    then
A10: W2.x = W.(n+xaa1) by A4,A5,A9,Lm15;
    now per cases by A7,X,ENUMSET1:def 1,FINSEQ_3:1;
      suppose x = 1;
        hence W1.x = W2.x by A3,A10,FINSEQ_1:62;
      end;
      suppose x = 2;
        hence W1.x = W2.x by A3,A10,FINSEQ_1:62;
      end;
      suppose x = 3;
        hence W1.x = W2.x by A3,A10,FINSEQ_1:62;
      end;
    end;
    hence W1.x = W2.x;
  end;
  hence thesis by A5,A6,FINSEQ_2:10;
end;

theorem Th42: ::tWCUT06
  for m,n being odd Element of NAT st m <= n & n < len W holds
  W.cut(m,n).addEdge(W.(n+1)) = W.cut(m,n+2)
proof
  let m,n be odd Element of NAT;
  set W1 = W.cut(m,n);
  set e = W.(n+1);
  assume
A1: m <= n & n < len W;
  then
A2: n <= n+2 & n+2 <= len W by Th1;
A3: W1.last() = W.n by A1,Lm16;
  then e Joins W1.last(), W.(n+2), G by A1,Def3;
  then e Joins W1.last(), W.vertexAt(n+2), G by A2,Def8;
  then W1.last().adj(e) = W.vertexAt(n+2) by GLIB_000:69;
  then W1.last().adj(e) = W.(n+2) by A2,Def8;
  then G.walkOf(W1.last(),e,W1.last().adj(e)) = W.cut(n,n+2) by A1,A3,Th41;
  hence thesis by A1,A2,Lm17;
end;

theorem ::tWCUT07
  for n being odd Element of NAT st n <= len W holds
  W.cut(n,n) = <* W.vertexAt(n) *> by Lm19;

theorem ::tWCUT08
  m is odd & m <= n implies W.cut(1,n).cut(1,m) = W.cut(1,m) by Lm20;

theorem ::tWCUT09
  for m,n being odd Element of NAT
  st m <= n & n <= len W1 & W1.last() = W2.first()
  holds W1.append(W2).cut(m,n) = W1.cut(m,n) by Lm21;

theorem ::tWCUT10
  for m being odd Element of NAT st m <= len W holds
  len W.cut(1,m) = m by Lm22;

theorem ::tWCUT11
  for m being odd Element of NAT, x being Element of NAT
  st x in dom W.cut(1,m) & m <= len W holds W.cut(1,m).x = W.x by Lm23;

theorem ::tWCUT12
  for m,n being odd Element of NAT, i being Element of NAT
  st m <= n & n <= len W & i in dom W.cut(m,n) holds
  W.cut(m,n).i = W.(m+i-1) & m+i-1 in dom W
proof
  let m,n be odd Element of NAT, i be Element of NAT;
  assume
A1: m <= n & n <= len W & i in dom W.cut(m,n);
  then
A2: 1 <= i & i <= len W.cut(m,n) by FINSEQ_3:27;
  then reconsider iaa1 = i-1 as Element of NAT by INT_1:18;
A3: iaa1 < len W.cut(m,n) - 0 by A2,XREAL_1:17;
  iaa1+1 = i;
  then W.cut(m,n).i = W.(m+iaa1) & m+iaa1 in dom W by A1,A3,Lm15;
  hence thesis;
end;

theorem Th49: ::tWCUT13
  for W1 being Walk of G1, W2 being Walk of G2, m, n being Element of NAT
  st W1 = W2 holds W1.cut(m,n) = W2.cut(m,n)
proof
  let W1 be Walk of G1, W2 be Walk of G2, m, n be Element of NAT;
  assume
A1: W1 = W2;
  now per cases;
    suppose
A2:   m is odd & n is odd & m <= n & n <= len W1;
      hence W1.cut(m,n) = (m,n)-cut W2 by A1,Def11
        .= W2.cut(m,n) by A1,A2,Def11;
    end;
    suppose
A3:   not (m is odd & n is odd & m <= n & n <= len W1);
      hence W1.cut(m,n) = W2 by A1,Def11
        .= W2.cut(m,n) by A1,A3,Def11;
    end;
  end;
  hence thesis;
end;

theorem ::tWREMOVE01
  for m,n being odd Element of NAT st m <= n & n <= len W & W.m = W.n holds
  len W.remove(m,n) + n = len W + m by Lm24;

theorem ::tWREMOVE02
  W is_Walk_from x,y implies W.remove(m,n) is_Walk_from x,y by Lm25;

theorem ::tWREMOVE03
  len W.remove(m,n) <= len W by Lm26;

theorem ::tWREMOVE04
  W.remove(m,m) = W by Lm27;

theorem ::tWREMOVE05
  for m,n being odd Element of NAT st m <= n & n <= len W & W.m = W.n holds
  W.cut(1,m).last() = W.cut(n,len W).first() by Lm28;

theorem ::tWREMOVE06
  for m,n being odd Element of NAT st m <= n & n <= len W & W.m = W.n holds
  (for x being Element of NAT st x in Seg m holds W.remove(m,n).x = W.x)
  by Lm29;

theorem ::tWREMOVE07
  for m,n being odd Element of NAT st m <= n & n <= len W & W.m = W.n holds
  (for x being Element of NAT st m <= x & x <= len W.remove(m,n) holds
  W.remove(m,n).x = W.(x - m + n) &
  x - m + n is Element of NAT & x - m + n <= len W) by Lm30;

theorem ::tWREMOVE08
  for m,n being odd Element of NAT st m <= n & n <= len W & W.m = W.n holds
  len W.remove(m,n) = len W + m - n by Lm31;

theorem Th58: ::tWREMOVE09
  for m being Element of NAT st W.m = W.last() holds
  W.remove(m,len W) = W.cut(1,m)
proof
  let m be Element of NAT;
  assume
A1: W.m = W.last();
  now per cases;
    suppose
A2:   m is odd & m <= len W;
      then
A3:   len W.remove(m,len W) + len W = len W + m by A1,Lm24;
      then
A4:   len W.remove(m,len W) = len W.cut(1,m) by A2,Lm22;
      now
        let k be Nat;
        assume
A5:     1 <= k & k <= len W.remove(m, len W);
        then
A6:     k in dom W.cut(1,m) by A4,FINSEQ_3:27;
        k in Seg m by A3,A5,FINSEQ_1:3;
        hence W.remove(m,len W).k = W.k by A1,A2,Lm29
          .= W.cut(1,m).k by A2,A6,Lm23;
      end;
      hence thesis by A4,FINSEQ_1:18;
    end;
    suppose
A7:   not (m is odd & m <= len W);
      then W.cut(1,m) = W by Def11;
      hence W.remove(m,len W) = W.cut(1,m) by A7,Def12;
    end;
  end;
  hence thesis;
end;

theorem ::tWREMOVE10
  for m being Element of NAT st W.first() = W.m holds
  W.remove(1,m) = W.cut(m, len W) by Lm32;

theorem ::tWREMOVE11
  W.remove(m,n).first() = W.first() & W.remove(m,n).last() = W.last() by Lm33;

theorem ::tWREMOVE12
  for m,n being odd Element of NAT, x being Element of NAT
  st m <= n & n <= len W & W.m = W.n & x in dom W.remove(m,n) holds
  x in Seg m or (m <= x & x <= len W.remove(m,n)) by Lm34;

theorem ::tWREMOVE13
  for W1 being Walk of G1, W2 being Walk of G2, m, n being Element of NAT
  st W1 = W2 holds W1.remove(m,n) = W2.remove(m,n)
proof
  let W1 be Walk of G1, W2 be Walk of G2, m, n be Element of NAT;
  assume
A1: W1 = W2;
  now per cases;
    suppose
A2:   (m is odd & n is odd & m <= n & n <= len W1 & W1.m = W1.n);
      then
A3:   W1.remove(m,n) = W1.cut(1,m).append(W1.cut(n,len W1)) by Def12;
      W1.cut(1,m) = W2.cut(1,m) & W1.cut(n,len W1) = W2.cut(n,len W2)
      by A1,Th49;
      then W1.remove(m,n) = W2.cut(1,m).append(W2.cut(n,len W2)) by A3,Th36;
      hence W1.remove(m,n) = W2.remove(m,n) by A1,A2,Def12;
    end;
    suppose
A4:   not (m is odd & n is odd & m <= n & n <= len W1 & W1.m = W1.n);
      hence W1.remove(m,n) = W2 by A1,Def12
        .= W2.remove(m,n) by A1,A4,Def12;
    end;
  end;
  hence thesis;
end;

theorem ::tWADDEDGE01
  e Joins W.last(), x, G implies W.addEdge(e) = W^<*e,x*> by Lm35;

theorem ::tWADDEDGE02
  e Joins W.last(),x,G implies
  W.addEdge(e).first() = W.first() & W.addEdge(e).last() = x &
  W.addEdge(e) is_Walk_from W.first(), x by Lm36;

theorem ::tWADDEDGE03
  e Joins W.last(),x,G implies len W.addEdge(e) = len W + 2 by Lm37;

theorem ::tWADDEDGE04
  e Joins W.last(),x,G implies
  W.addEdge(e).(len W + 1) = e & W.addEdge(e).(len W + 2) = x &
  for n being Element of NAT st n in dom W holds W.addEdge(e).n = W.n by Lm38;

theorem ::tWADDEDGE05
  W is_Walk_from x,y & e Joins y,z,G implies
  W.addEdge(e) is_Walk_from x,z by Lm39;

theorem Th68: ::tWVSEQ01
  1 <= len W.vertexSeq()
proof
  now
    assume len W.vertexSeq() < 1;
    then len W.vertexSeq() < 0 + 1;
    then len W.vertexSeq() <= 0 by NAT_1:13;
    then len W.vertexSeq() = 0;
    then len W + 1 = 2 * 0 by Def14;
    hence contradiction;
  end;
  hence thesis;
end;

theorem Th69: ::tWVSEQ02
  for n being odd Element of NAT st n <= len W holds
  2 * ((n+1) div 2) - 1 = n &
  1 <= (n+1) div 2 & (n+1) div 2 <= len W.vertexSeq()
proof
  let n be odd Element of NAT;
  assume
A1: n <= len W;
  set m = (n+1) div 2;
  2 divides n+1 by PEPIN:22;
  then
A2: 2 * m = n+1 by NAT_D:3;
  hence 2 * m - 1 = n;
A3: now
    assume m < 1;
    then m < 0 + 1;
    then m <= 0 by NAT_1:13;
    then m = 0;
    hence contradiction by A2;
  end;
  hence 1 <= m;
  reconsider maa1 = m-1 as Element of NAT by A3,INT_1:18;
  now
    assume len W.vertexSeq() < m;
    then len W.vertexSeq() < maa1 + 1;
    then len W.vertexSeq() <= maa1 by NAT_1:13;
    then 2 * len W.vertexSeq() <= 2 * maa1 by NAT_1:4;
    then len W + 1 <= (2 * m) - (2 * 1) by Def14;
    then len W + 1 + 2 <= n + 1 - 2 + 2 by A2,XREAL_1:9;
    then len W + 1 + 2 < n + 1 + 1 by NAT_1:13;
    then len W + 3 - 3 < n + 2 - 2 by XREAL_1:16;
    hence contradiction by A1;
  end;
  hence m <= len W.vertexSeq();
end;

theorem ::tWVSEQ03
  G.walkOf(v).vertexSeq() = <*v*>
proof
  set VS = G.walkOf(v).vertexSeq();
  len G.walkOf(v) + 1 = 2 * len VS by Def14;
  then
A1: 1 + 1 = 2 * len VS by Th14;
  then VS.1 = G.walkOf(v).(2*1-1) by Def14
    .= v by Th14;
  hence thesis by A1,FINSEQ_1:57;
end;

theorem Th71: ::tWVSEQ04
  e Joins x,y,G implies G.walkOf(x,e,y).vertexSeq() = <*x,y*>
proof
  set W = G.walkOf(x,e,y);
  assume e Joins x, y, G;
  then
A1: W = <*x, e, y*> by Def5;
  len W + 1 = 2 * len W.vertexSeq() by Def14;
  then
A2: 3 + 1 = 2 * len W.vertexSeq() by A1,FINSEQ_1:62;
  then W.vertexSeq().1 = W.(2*1-1) & W.vertexSeq().2 = W.(2*2-1) by Def14;
  then W.vertexSeq().1 = x & W.vertexSeq().2 = y by A1,FINSEQ_1:62;
  hence thesis by A2,FINSEQ_1:61;
end;

theorem ::tWVSEQ05
  W.first() = W.vertexSeq().1 & W.last() = W.vertexSeq().(len W.vertexSeq())
proof
  1 <= len W.vertexSeq() by Th68;
  then
A1: W.vertexSeq().1 = W.(2*1-1) &
  W.vertexSeq().(len W.vertexSeq()) = W.(2*len W.vertexSeq()-1) by Def14;
  hence W.vertexSeq().1 = W.first();
  len W + 1 = 2*len W.vertexSeq() by Def14;
  hence W.vertexSeq().(len W.vertexSeq()) = W.last() by A1;
end;

theorem ::tWVSEQ06
  for n being odd Element of NAT st n <= len W holds
  W.vertexAt(n) = W.vertexSeq().((n+1) div 2)
proof
  let n be odd Element of NAT;
  assume
A1: n <= len W;
  then
A2: W.vertexAt(n) = W.n by Def8;
  set m = (n+1) div 2;
  2 * m - 1 = n & 1 <= m & m <= len W.vertexSeq() by A1,Th69;
  hence thesis by A2,Def14;
end;

theorem Th74: ::tWVSEQ07
  n in dom W.vertexSeq() iff (2*n-1 in dom W)
proof
  hereby
    assume n in dom W.vertexSeq();
    then
A1: 1 <= n & n <= len W.vertexSeq() by FINSEQ_3:27;
    then 2*n <= 2*len W.vertexSeq() by XREAL_1:66;
    then 2*n <= len W + 1 by Def14;
    then
A2: 2*n-1 <= len W + 1 - 1 by XREAL_1:15;
    2*1 <= 2*n by A1,XREAL_1:66;
    then
A3: 2-1 <= 2*n-1 by XREAL_1:15;
    1 <= n+n by A1,NAT_1:12;
    then 2*n-1 is Element of NAT by INT_1:18;
    hence 2*n-1 in dom W by A2,A3,FINSEQ_3:27;
  end;
  assume
A4: 2*n-1 in dom W;
  then reconsider 2naa1=2*n-1 as Element of NAT;
  1 <= 2naa1 & 2naa1 <= len W by A4,FINSEQ_3:27;
  then
A5: 1+1 <= 2*n-1+1 & 2*n-1+1 <= len W+1 by XREAL_1:9;
  then
A6: 2*1 <= 2*n & 2*n <= len W + 1;
  2*n <= 2 * len W.vertexSeq() by A5,Def14;
  then 1 <= n & n <= len W.vertexSeq() by A6,XREAL_1:70;
  hence n in dom W.vertexSeq() by FINSEQ_3:27;
end;

theorem ::tWVSEQ08
  W.cut(1,n).vertexSeq() c= W.vertexSeq()
proof
  now per cases;
    suppose
A1:   n is odd & 1 <= n & n <= len W;
      set f = W.cut(1,n).vertexSeq();
      now
        let v be set;
        assume
A2:     v in f;
        then consider x,y being set such that
A3:     v = [x,y] by RELAT_1:def 1;
A4:     x in dom f & y = f.x by A2,A3,FUNCT_1:8;
        then reconsider x as Element of NAT;
        1 <= x & x <= len f by A4,FINSEQ_3:27;
        then
A5:     y = W.cut(1,n).(2*x-1) by A4,Def14;
A6:     2*x-1 in dom W.cut(1,n) by A4,Th74;
        then
A7:     y = W.(2*x-1) by A1,A5,Lm23;
A8:     2*x-1 is Element of NAT by A6;
A9:     1 <= 2*x-1 & 2*x-1 <= len W.cut(1,n) by A6,FINSEQ_3:27;
        then 2*x-1 <= n by A1,Lm22;
        then 2*x-1 <= len W by A1,XXREAL_0:2;
        then 2*x-1 in dom W by A8,A9,FINSEQ_3:27;
        then
A10:    x in dom W.vertexSeq() by Th74;
        then 1 <= x & x <= len W.vertexSeq() by FINSEQ_3:27;
        then W.vertexSeq().x = y by A7,Def14;
        hence v in W.vertexSeq() by A3,A10,FUNCT_1:8;
      end;
      hence thesis by TARSKI:def 3;
    end;
    suppose not (n is odd & 1 <= n & n <= len W);
      hence thesis by Def11;
    end;
  end;
  hence thesis;
end;

theorem Th76: ::tWVSEQ09
  e Joins W.last(),x,G implies
  W.addEdge(e).vertexSeq() = W.vertexSeq() ^ <*x*>
proof
  set W2 = W.addEdge(e), W3 = W.vertexSeq() ^ <*x*>;
  assume
A1: e Joins W.last(),x,G;
  then len W2 = len W + 2 by Lm37;
  then
A2: len W + 2 + 1 = 2 * len W2.vertexSeq() by Def14;
  len W3 = len W.vertexSeq() + len <*x*> by FINSEQ_1:35;
  then len W3 = len W.vertexSeq() + 1 by FINSEQ_1:56;
  then 2*len W3 = 2*len W.vertexSeq()+2*1;
  then
A3: 2*len W3 = len W + 1 + 2 by Def14
    .= 2* len W2.vertexSeq() by A2;
  now
    let k be Nat;
    assume
A4: 1 <= k & k <= len W2.vertexSeq();
    then
A5: k in dom W3 by A3,FINSEQ_3:27;
A6: W2.vertexSeq().k = W2.(2*k-1) by A4,Def14;
    now per cases by A5,FINSEQ_1:38;
      suppose
A7:     k in dom W.vertexSeq();
        then
A8:     W3.k = W.vertexSeq().k by FINSEQ_1:def 7;
        1 <= k & k <= len W.vertexSeq() by A7,FINSEQ_3:27;
        then
A9:     W3.k = W.(2*k-1) by A8,Def14;
        2*k-1 in dom W by A7,Th74;
        hence W2.vertexSeq().k = W3.k by A1,A6,A9,Lm38;
      end;
      suppose ex n being Nat st n in dom <*x*> & k=len W.vertexSeq()+n;
        then consider n being Nat such that
A10:    n in dom <*x*> & k = len W.vertexSeq() + n;
        n in Seg 1 by A10,FINSEQ_1:55;
        then
A11:    n = 1 by FINSEQ_1:4,TARSKI:def 1;
        then
A12:    W3.k = <*x*>.1 by A10,FINSEQ_1:def 7
          .= x by FINSEQ_1:def 8;
        2*k = 2*len W.vertexSeq() + 2*1 by A10,A11
          .= len W + 1 + 2 by Def14
          .= len W + 2 + 1;
        hence W2.vertexSeq().k = W3.k by A1,A6,A12,Lm38;
      end;
    end;
    hence W2.vertexSeq().k = W3.k;
  end;
  hence thesis by A3,FINSEQ_1:18;
end;

theorem Th77: ::tWVSEQ10
  for W1 being Walk of G1, W2 being Walk of G2 st W1 = W2 holds
  W1.vertexSeq() = W2.vertexSeq()
proof
  let W1 be Walk of G1, W2 be Walk of G2;
  set VS1 = W1.vertexSeq(), VS2 = W2.vertexSeq();
  assume
A1: W1 = W2;
  now thus len VS1 = len VS1;
A2: 2 * len VS1 = len W2 + 1 by A1,Def14
      .= 2 * len VS2 by Def14;
    hence len VS2 = len VS1;
    let x be Nat;
    assume x in dom VS1;
    then x in dom VS1;
    then
A3: 1 <= x & x <= len VS1 & x <= len VS2 by A2,FINSEQ_3:27;
    hence VS1.x = W2.(2*x - 1) by A1,Def14
      .= VS2.x by A3,Def14;
  end;
  hence W1.vertexSeq() = W2.vertexSeq() by FINSEQ_2:10;
end;

theorem ::tWESEQ01
  for n being even Element of NAT st 1 <= n & n <= len W holds
  n div 2 in dom W.edgeSeq() & W.n = W.edgeSeq().(n div 2) by Lm40;

theorem ::tWESEQ02
  n in dom W.edgeSeq() iff 2*n in dom W by Lm41;

theorem ::tWESEQ03
  for n being Element of NAT st n in dom W.edgeSeq()
  holds W.edgeSeq().n in the_Edges_of G
proof
  let n be Element of NAT;
  assume n in dom W.edgeSeq();
  then W.edgeSeq().n in rng W.edgeSeq() by FUNCT_1:def 5;
  hence W.edgeSeq().n in the_Edges_of G;
end;

theorem ::tWESEQ04
  ex lenWaa1 being even Element of NAT st lenWaa1 = len W - 1 &
  len W.edgeSeq() = lenWaa1 div 2 by Lm42;

theorem ::tWESEQ05
  W.cut(1,n).edgeSeq() c= W.edgeSeq() by Lm43;

theorem ::tWESEQ06
  e Joins W.last(),x,G implies
  W.addEdge(e).edgeSeq() = W.edgeSeq() ^ <*e*> by Lm44;

theorem Th84: ::tWESEQ07
  e Joins x,y,G iff G.walkOf(x,e,y).edgeSeq() = <*e*>
proof
  set W = G.walkOf(x,e,y);
  hereby
    assume
A1: e Joins x,y, G;
    then len W = 3 by Th15;
    then
A2: 2+1 = 2*len W.edgeSeq()+1 by Def15;
    then
A3: len W.edgeSeq() = len <*e*> by FINSEQ_1:56;
A4: W = <*x,e,y*> by A1,Def5;
    now
      let k be Nat;
      assume
A5:   1 <= k & k <= len W.edgeSeq();
      then
A6:   k = 1 by A2,XXREAL_0:1;
      then W.edgeSeq().k = W.(2*1) by A5,Def15
        .= e by A4,FINSEQ_1:62;
      hence W.edgeSeq().k = <*e*>.k by A6,FINSEQ_1:def 8;
    end;
    hence W.edgeSeq() = <*e*> by A3,FINSEQ_1:18;
  end;
  assume W.edgeSeq() = <*e*>;
  then len W.edgeSeq() = 1 by FINSEQ_1:56;
  then
A7: len W = 2*1+1 by Def15;
  now
    assume not e Joins x,y,G;
    then W = G.walkOf(choose the_Vertices_of G) by Def5;
    hence contradiction by A7,Th14;
  end;
  hence thesis;
end;

theorem ::tWESEQ08
  W.reverse().edgeSeq() = Rev (W.edgeSeq())
proof
  set W1 = W.reverse().edgeSeq(), W2 = Rev (W.edgeSeq());
A1: len W = len W.reverse() by FINSEQ_5:def 3;
  len W = 2 * len W.edgeSeq() + 1 by Def15;
  then
A2: 2 * len W.edgeSeq() + 1 = 2 * len W1 + 1 by A1,Def15;
  then
A3: len W1 = len W2 by FINSEQ_5:def 3;
  now
    let n be Nat;
    assume
A4: 1 <= n & n <= len W1;
    set rn = len W.edgeSeq() - n + 1;
    reconsider rn as Element of NAT by A2,A4,FINSEQ_5:1;
A5: n in Seg len W.edgeSeq() by A2,A4,FINSEQ_1:3;
    then rn in Seg len W.edgeSeq() by FINSEQ_5:2;
    then
A6: 1 <= rn & rn <= len W.edgeSeq() by FINSEQ_1:3;
A7: n in dom W.edgeSeq() by A5,FINSEQ_1:def 3;
    then
A8: W2.n = W.edgeSeq().rn by FINSEQ_5:61
      .= W.(2*rn) by A6,Def15;
    2*n in dom W by A7,Lm41;
    then 1 <= 2*n & 2*n <= len W.reverse() by A1,FINSEQ_3:27;
    then
A9: 2*n in dom W.reverse() by FINSEQ_3:27;
A10: W1.n = W.reverse().(2*n) by A4,Def15;
    len W - 2*n + 1 = 2*len W.edgeSeq() + 1 - 2*n + 1 by Def15
      .= 2*rn;
    hence W1.n = W2.n by A8,A9,A10,Lm8;
  end;
  hence thesis by A3,FINSEQ_1:18;
end;

theorem ::tWESEQ09
  W1.last() = W2.first() implies
  W1.append(W2).edgeSeq() = W1.edgeSeq() ^ W2.edgeSeq()
proof
  set W3 = W1.append(W2), W4 = W1.edgeSeq() ^ W2.edgeSeq();
  assume
A1: W1.last() = W2.first();
A2: len W4 = len W1.edgeSeq() + len W2.edgeSeq() by FINSEQ_1:35;
  len W3 + 1 = len W1 + len W2 by A1,Lm9;
  then len W3 + 1 = len W1 + (2*len W2.edgeSeq() + 1) by Def15
    .= len W1 + 2*len W2.edgeSeq() + 1;
  then
A3: 2*len W3.edgeSeq()+1 = 2*len W2.edgeSeq()+len W1 by Def15
    .= 2*len W2.edgeSeq()+(2*len W1.edgeSeq()+1) by Def15
    .= 2*len W2.edgeSeq()+2*len W1.edgeSeq()+1;
A4: W3 = W1 ^' W2 by A1,Def10;
  now
    let n be Nat;
    assume
A5: 1 <= n & n <= len W3.edgeSeq();
    reconsider n1 = n as Element of NAT by ORDINAL1:def 13;
A6: n1 in dom W4 by A2,A3,A5,FINSEQ_3:27;
A7: W3.edgeSeq().n1 = W3.(2*n1) by A5,Def15;
    now per cases by A6,FINSEQ_1:38;
      suppose
A8:     n in dom W1.edgeSeq();
        then
A9:     1 <= n & n <= len W1.edgeSeq() by FINSEQ_3:27;
A10:    W4.n = W1.edgeSeq().n by A8,FINSEQ_1:def 7
          .= W1.(2*n) by A9,Def15;
        2*n in dom W1 by A8,Lm41;
        then 1 <= 2*n & 2*n <= len W1 by FINSEQ_3:27;
        hence W3.edgeSeq().n = W4.n by A4,A7,A10,GRAPH_2:14;
      end;
      suppose ex k being Nat st k in dom W2.edgeSeq() &
        n = len W1.edgeSeq() + k;
        then consider k being Nat such that
A11:    k in dom W2.edgeSeq() & n = len W1.edgeSeq() + k;
A12:    1 <= k & k <= len W2.edgeSeq() by A11,FINSEQ_3:27;
        then 1 <= k+k by NAT_1:12;
        then reconsider 2kaa1 = 2*k-1 as Element of NAT by INT_1:18;
A13:    W4.n = W2.edgeSeq().k by A11,FINSEQ_1:def 7
          .= W2.(2*k) by A12,Def15;
        2*n+1 = 2*k + (2*len W1.edgeSeq()+1) by A11
          .= 2*k + len W1 by Def15;
        then
A14:    2*n = len W1 + (2*k-1);
        1+1 <= k+k by A12,XREAL_1:9;
        then
A15:    1+1-1 <= 2kaa1 by XREAL_1:15;
        2*k <= 2*len W2.edgeSeq() by A12,XREAL_1:66;
        then 2*k < 2*len W2.edgeSeq() + 1 by NAT_1:13;
        then 2*k < len W2 by Def15;
        then 2kaa1 < len W2 - 0 by XREAL_1:16;
        then W3.(2*n) = W2.(2kaa1+1) by A4,A14,A15,GRAPH_2:15
          .= W2.(2*k);
        hence W3.edgeSeq().n = W4.n by A5,A13,Def15;
      end;
    end;
    hence W3.edgeSeq().n = W4.n;
  end;
  hence thesis by A2,A3,FINSEQ_1:18;
end;

theorem Th87: ::tWESEQ10
  for W1 being Walk of G1, W2 being Walk of G2 st W1 = W2 holds
  W1.edgeSeq() = W2.edgeSeq()
proof
  let W1 be Walk of G1, W2 be Walk of G2;
  set ES1 = W1.edgeSeq(), ES2 = W2.edgeSeq();
  assume
A1: W1 = W2;
  now thus len ES1 = len ES1;
A2: 2 * len ES1 + 1 = len W2 by A1,Def15
      .= 2 * len ES2 + 1 by Def15;
    hence len ES2 = len ES1;
    let x be Nat;
    assume x in dom ES1;
    then x in dom ES1;
    then
A3: 1 <= x & x <= len ES1 & x <= len ES2 by A2,FINSEQ_3:27;
    hence ES1.x = W2.(2*x) by A1,Def15
      .= ES2.x by A3,Def15;
  end;
  hence thesis by FINSEQ_2:10;
end;

theorem ::tWVERTICES01
  x in W.vertices() iff
  ex n being odd Element of NAT st n <= len W & W.n = x by Lm45;

theorem Th89: ::tWVERTICES02
  W.first() in W.vertices() & W.last() in W.vertices()
proof
  1 <= len W by HEYTING3:1;
  hence W.first() in W.vertices() by Lm45,JORDAN12:3;
  thus W.last() in W.vertices() by Lm45;
end;

theorem Th90: ::tWVERTICES03
  for n being odd Element of NAT st n <= len W holds
  W.vertexAt(n) in W.vertices()
proof
  let n be odd Element of NAT;
  assume
A1: n <= len W;
  then W.vertexAt(n) = W.n by Def8;
  hence thesis by A1,Lm45;
end;

theorem ::tWVERTICES04
  G.walkOf(v).vertices() = {v}
proof
  now
    let x be set;
    hereby
      assume x in G.walkOf(v).vertices();
      then consider n being odd Element of NAT such that
A1:   n <= len G.walkOf(v) & G.walkOf(v).n = x by Lm45;
A2:   n <= 1 by A1,Th14;
      1 <= n by HEYTING3:1;
      then x = G.walkOf(v).1 by A1,A2,XXREAL_0:1;
      then x = v by Th14;
      hence x in {v} by TARSKI:def 1;
    end;
    assume x in {v};
    then
A3: x = v by TARSKI:def 1;
A4: 1 <= len G.walkOf(v) & 1 is odd by HEYTING3:1,JORDAN12:3;
    G.walkOf(v).1 = v by Th14;
    hence x in G.walkOf(v).vertices() by A3,A4,Lm45;
  end;
  hence thesis by TARSKI:2;
end;

theorem Th92: ::tWVERTICES05
  e Joins x,y,G implies G.walkOf(x,e,y).vertices() = {x,y}
proof
  set W = G.walkOf(x,e,y);
  assume e Joins x, y, G;
  then W.vertexSeq() = <*x,y*> by Th71;
  hence W.vertices() = {x,y} by FINSEQ_2:147;
end;

theorem ::tWVERTICES06
  W.vertices() = W.reverse().vertices()
proof
  now
    let x be set;
    hereby
      assume x in W.vertices();
      then consider n being odd Element of NAT such that
A2:   n <= len W & W.n = x by Lm45;
      1 <= n by HEYTING3:1;
      then
A3:   n in dom W by A2,FINSEQ_3:27;
      then
A4:   W.reverse().(len W - n + 1) = x by A2,Th25;
      reconsider lenW = len W as odd Element of NAT;
A5:   lenW-n+1 is odd Element of NAT by A2,FINSEQ_5:1;
      n in Seg len W by A3,FINSEQ_1:def 3;
      then
   lenW-n+1 in Seg len W by FINSEQ_5:2;
      then
A7:   lenW-n+1 in dom W by FINSEQ_1:def 3;
      lenW-n+1 <= len W by A7,FINSEQ_3:27;
      then
A8:   lenW-n+1 <= len W.reverse() by FINSEQ_5:def 3;
      thus x in W.reverse().vertices() by A4,A5,A8,Lm45;
    end;
    assume x in W.reverse().vertices();
    then consider n being odd Element of NAT such that
A10: n <= len W.reverse() & W.reverse().n = x by Lm45;
A11: 1 <= n by HEYTING3:1;
    then n in dom W.reverse() by A10,FINSEQ_3:27;
    then
A12: W.(len W - n + 1) = x by A10,FINSEQ_5:def 3;
    reconsider lenW = len W as odd Element of NAT;
A13: n <= len W by A10,FINSEQ_5:def 3;
    then
A14: lenW-n+1 is odd Element of NAT by FINSEQ_5:1;
    n in Seg len W by A11,A13,FINSEQ_1:3;
    then lenW-n+1 in Seg len W by FINSEQ_5:2;
    then
A15: lenW-n+1 <= len W by FINSEQ_1:3;
    thus x in W.vertices() by A12,A14,A15,Lm45;
  end;
  hence thesis by TARSKI:2;
end;

theorem Th94: ::tWVERTICES07
  W1.last() = W2.first() implies
  W1.append(W2).vertices() = W1.vertices() \/ W2.vertices()
proof
  set W = W1.append(W2);
  assume
A1: W1.last() = W2.first();
  then
A2: W = W1 ^' W2 by Def10;
  now
    let x be set;
    hereby
      assume
A3:   x in W.vertices();
      then reconsider v=x as Vertex of G;
      consider n being odd Element of NAT such that
A4:   n <= len W & W.n = v by A3,Lm45;
A5:   1 <= n by HEYTING3:1;
      now per cases;
        suppose
A6:       n <= len W1;
          then n in dom W1 by A5,FINSEQ_3:27;
          then W1.n = v by A4,Lm12;
          then v in W1.vertices() by A6,Lm45;
          hence x in W1.vertices()\/W2.vertices() by XBOOLE_0:def 3;
        end;
        suppose
A7:       n > len W1;
          then consider k being Nat such that
A8:       len W1 + k = n by NAT_1:10;
          reconsider lenW1 = len W1 as odd Element of NAT;
          k is even by A8;
          then reconsider k as even Element of NAT by ORDINAL1:def 13;
          k <> 0 by A7,A8;
          then 0 < k;
          then
A9:       0+1 <= k by NAT_1:13;
          len W1 + k + 1 <= len W + 1 by A4,A8,XREAL_1:9;
          then (k + 1) + len W1 <= len W2 + len W1 by A1,Lm9;
          then
A10:      k + 1 + len W1 - len W1 <= len W2 + len W1 - len W1
 by XREAL_1:15;
          then k < len W2 - 1 + 1 by NAT_1:13;
          then
A11:      W2.(k+1) = v by A2,A4,A8,A9,GRAPH_2:15;
          W2.vertexAt(k+1) in W2.vertices() by A10,Th90;
          then v in W2.vertices() by A10,A11,Def8;
          hence x in W1.vertices() \/ W2.vertices() by XBOOLE_0:def 3;
        end;
      end;
      hence x in W1.vertices() \/ W2.vertices();
    end;
    assume
A12: x in W1.vertices() \/ W2.vertices();
A13: now
      assume x in W1.vertices();
      then consider n being odd Element of NAT such that
A14:  n <= len W1 & W1.n = x by Lm45;
      1 <= n by HEYTING3:1;
      then n in dom W1 by A14,FINSEQ_3:27;
      then W.n = W1.n & n in dom W by Lm12;
      then W.n = x & n <= len W by A14,FINSEQ_3:27;
      hence x in W.vertices() by Lm45;
    end;
    now per cases by A12,XBOOLE_0:def 3;
      suppose x in W1.vertices();
        hence x in W.vertices() by A13;
      end;
      suppose x in W2.vertices();
        then consider n being odd Element of NAT such that
A15:    n <= len W2 & W2.n = x by Lm45;
        reconsider naa1 = n-1 as even Element of NAT by HEYTING3:1,INT_1:18;
        naa1 < len W2 - 0 by A15,XREAL_1:17;
        then
A16:    W.(len W1 + naa1) = W2.(naa1 + 1) & (len W1 + naa1) in dom W
        by A1,Lm13;
        reconsider lenW1 = len W1 as odd Element of NAT;
        lenW1 + naa1 <= len W by A16,FINSEQ_3:27;
        hence x in W.vertices() by A15,A16,Lm45;
      end;
    end;
    hence x in W.vertices();
  end;
  hence thesis by TARSKI:2;
end;

theorem ::tWVERTICES08
  for m,n being odd Element of NAT st m <= n & n <= len W holds
  W.cut(m,n).vertices() c= W.vertices()
proof
  let m, n be odd Element of NAT;
  set W2 = W.cut(m,n);
  assume
A1: m <= n & n <= len W;
  now
    let x be set;
    assume x in W2.vertices();
    then consider n being odd Element of NAT such that
A2: n <= len W2 & W2.n = x by Lm45;
    reconsider naa1 = n - 1 as even Element of NAT by HEYTING3:1,INT_1:18;
    naa1 < len W2 - 0 by A2,XREAL_1:17;
    then
A3: W2.(naa1+1) = W.(m+naa1) & m+naa1 in dom W by A1,Lm15;
    then m+naa1 <= len W by FINSEQ_3:27;
    hence x in W.vertices() by A2,A3,Lm45;
  end;
  hence thesis by TARSKI:def 3;
end;

theorem Th96: ::tWVERTICES09
  e Joins W.last(),x,G implies W.addEdge(e).vertices() = W.vertices() \/ {x}
proof
  set W2 = G.walkOf(W.last(), e, W.last().adj(e));
  set W3 = W.addEdge(e), WV = W.vertices();
  assume
A1: e Joins W.last(), x, G;
  then reconsider x'=x as Vertex of G by GLIB_000:16;
A2: W.last().adj(e) = x' by A1,GLIB_000:69;
  then W2.first() = W.last() by A1,Th16;
  then
A3: W3.vertices() = WV \/ W2.vertices() by Th94;
A4: W2.vertices() = {W.last(), x} by A1,A2,Th92;
  now
    let y be set;
    hereby
      assume
A5:   y in WV \/ {W.last(), x};
      now per cases by A5,XBOOLE_0:def 3;
        suppose y in WV;
          hence y in WV \/ {x} by XBOOLE_0:def 3;
        end;
        suppose
A6:       y in {W.last(), x};
          now per cases by A6,TARSKI:def 2;
            suppose y = W.last();
              then y in WV by Th89;
              hence y in WV \/ {x} by XBOOLE_0:def 3;
            end;
            suppose y = x;
              then y in {x} by TARSKI:def 1;
              hence y in WV \/ {x} by XBOOLE_0:def 3;
            end;
          end;
          hence y in WV \/ {x};
        end;
      end;
      hence y in WV \/ {x};
    end;
    assume
A7: y in WV \/ {x};
    now per cases by A7,XBOOLE_0:def 3;
      suppose y in WV;
        hence y in WV \/ {W.last(), x} by XBOOLE_0:def 3;
      end;
      suppose y in {x};
        then y = x by TARSKI:def 1;
        then y in {W.last(), x} by TARSKI:def 2;
        hence y in WV \/ {W.last(), x} by XBOOLE_0:def 3;
      end;
    end;
    hence y in WV \/ {W.last(), x};
  end;
  hence thesis by A3,A4,TARSKI:2;
end;

theorem ::tWVERTICES10
  for G being finite _Graph, W being Walk of G, e,x being set holds
  e Joins W.last(),x,G & not x in W.vertices() implies
  card W.addEdge(e).vertices() = card W.vertices() + 1
proof
  let G be finite _Graph, W be Walk of G, e, x be set;
  assume
A1: e Joins W.last(),x,G & not x in W.vertices();
  then card W.addEdge(e).vertices() = card (W.vertices()\/{x}) by Th96;
  hence thesis by A1,CARD_2:54;
end;

theorem ::tWVERTICES11
  x in W.vertices() & y in W.vertices() implies
  ex W' being Walk of G st W' is_Walk_from x,y
proof
  assume
A1: x in W.vertices() & y in W.vertices();
  then consider m being odd Element of NAT such that
A2: m <= len W & W.m = x by Lm45;
  consider n being odd Element of NAT such that
A3: n <= len W & W.n = y by A1,Lm45;
  now per cases;
    suppose m <= n;
      then W.cut(m,n) is_Walk_from x, y by A2,A3,Lm16;
      hence thesis;
    end;
    suppose n <= m;
      then W.cut(n,m) is_Walk_from y, x by A2,A3,Lm16;
      then W.cut(n,m).reverse() is_Walk_from x, y by Th24;
      hence thesis;
    end;
  end;
  hence thesis;
end;

theorem  ::tWVERTICES12
  for W1 being Walk of G1, W2 being Walk of G2 st W1 = W2 holds
  W1.vertices() = W2.vertices() by Th77;

theorem ::tWEDGES01
  e in W.edges() iff
  ex n being even Element of NAT st 1 <= n & n <= len W & W.n = e by Lm46;

theorem Th101: ::tWEDGES02
  e in W.edges() iff ex n being odd Element of NAT st n < len W & W.(n+1) = e
proof
  hereby
    assume e in W.edges();
    then consider n1 being even Element of NAT such that
A1: 1 <= n1 & n1 <= len W & W.n1 = e by Lm46;
    reconsider n = n1-1 as odd Element of NAT by A1,INT_1:18;
    take n;
    n1-1 < len W - 0 by A1,XREAL_1:17;
    hence n < len W;
    thus W.(n+1) = e by A1;
  end;
  given n being odd Element of NAT such that
A2: n < len W & W.(n+1) = e;
A3: n+1 <= len W by A2,NAT_1:13;
  1 <= n+1 by NAT_1:12;
  hence e in W.edges() by A2,A3,Lm46;
end;

theorem Th102: ::tWEDGES03
  rng W = W.vertices() \/ W.edges()
proof
  now
    let y be set;
    assume y in rng W;
    then consider x being Nat such that
A1: x in dom W & W.x = y by FINSEQ_2:11;
A2: 1 <= x & x <= len W by A1,FINSEQ_3:27;
    now per cases;
      suppose x is odd;
        then y in W.vertices() by A1,A2,Lm45;
        hence y in W.vertices() \/ W.edges() by XBOOLE_0:def 3;
      end;
      suppose x is even;
        then y in W.edges() by A1,A2,Lm46;
        hence y in W.vertices() \/ W.edges() by XBOOLE_0:def 3;
      end;
    end;
    hence y in W.vertices() \/ W.edges();
  end;
  then
A3: rng W c= W.vertices() \/ W.edges() by TARSKI:def 3;
  now
    let y be set;
    assume
A4: y in W.vertices() \/ W.edges();
    now per cases by A4,XBOOLE_0:def 3;
      suppose y in W.vertices();
        then consider x being odd Element of NAT such that
A5:     x <= len W & W.x = y by Lm45;
        1 <= x by HEYTING3:1;
        then x in dom W by A5,FINSEQ_3:27;
        hence y in rng W by A5,FUNCT_1:def 5;
      end;
      suppose y in W.edges();
        then consider x being even Element of NAT such that
A6:     1 <= x & x <= len W & W.x = y by Lm46;
        x in dom W by A6,FINSEQ_3:27;
        hence y in rng W by A6,FUNCT_1:def 5;
      end;
    end;
    hence y in rng W;
  end;
  then W.vertices() \/ W.edges() c= rng W by TARSKI:def 3;
  hence rng W = W.vertices() \/ W.edges() by A3,XBOOLE_0:def 10;
end;

theorem Th103: ::tWEDGES04
  W1.last() = W2.first() implies
  W1.append(W2).edges() = W1.edges() \/ W2.edges()
proof
  set W = W1.append(W2);
  set WE = W.edges(), W1E = W1.edges(), W2E = W2.edges();
  assume
A1: W1.last() = W2.first();
  then
A2: W = W1 ^' W2 by Def10;
  set lenW1 = len W1, lenW2 = len W2;
  reconsider lenW1, lenW2 as odd Element of NAT;
  now
    let x be set;
    hereby
      assume x in WE;
      then consider n being even Element of NAT such that
A3:   1 <= n & n <= len W & W.n = x by Lm46;
      now per cases;
        suppose
A4:       n <= len W1;
          then W.n = W1.n by A2,A3,GRAPH_2:14;
          then x in W1E by A3,A4,Lm46;
          hence x in W1E \/ W2E by XBOOLE_0:def 3;
        end;
        suppose len W1 < n;
          then reconsider k = n-lenW1 as odd Element of NAT by INT_1:18;
          n - lenW1 + len W1 < len W + 1 by A3,NAT_1:13;
          then n-lenW1 + lenW1 < lenW2 + len W1 by A1,Lm9;
          then
A5:       k < lenW2 + len W1 - len W1 by XREAL_1:16;
          then
A6:       W2.(k+1) = W.(len W1+k) by A2,GRAPH_2:15,HEYTING3:1
            .= x by A3;
A7:       1 <= k+1 by NAT_1:12;
          k+1 <= len W2 by A5,NAT_1:13;
          then x in W2E by A6,A7,Lm46;
          hence x in W1E \/ W2E by XBOOLE_0:def 3;
        end;
      end;
      hence x in W1E \/ W2E;
    end;
    assume
A8: x in W1E \/ W2E;
    now per cases by A8,XBOOLE_0:def 3;
      suppose x in W1E;
        then consider n being even Element of NAT such that
A9:     1 <= n & n <= len W1 & W1.n = x by Lm46;
A10:    W.n = x by A2,A9,GRAPH_2:14;
        len W1 <= len W by A1,Lm10;
        then n <= len W by A9,XXREAL_0:2;
        hence x in WE by A9,A10,Lm46;
      end;
      suppose x in W2E;
        then consider n being even Element of NAT such that
A11:    1 <= n & n <= len W2 & W2.n = x by Lm46;
        reconsider naa1 = n-1 as odd Element of NAT by A11,INT_1:18;
        naa1 < len W2 by A11,XREAL_1:149;
        then
A12:    W.(lenW1 + naa1) = W2.(naa1+1) by A2,GRAPH_2:15,HEYTING3:1
          .= x by A11;
A13:    1 <= lenW1+naa1 by HEYTING3:1,NAT_1:12;
        (naa1 + 1) + lenW1 <= len W2 + len W1 by A11,XREAL_1:9;
        then lenW1 + naa1 + 1 <= len W + 1 by A1,Lm9;
        then lenW1+naa1 <= len W by XREAL_1:8;
        hence x in WE by A12,A13,Lm46;
      end;
    end;
    hence x in WE;
  end;
  hence thesis by TARSKI:2;
end;

theorem ::tWEDGES05
  e in W.edges() implies
  ex v1, v2 being Vertex of G, n being odd Element of NAT st
  n+2 <= len W & v1 = W.n & e = W.(n+1) & v2 = W.(n+2) &
  e Joins v1, v2,G by Lm47;

theorem Th105: ::tWEDGES06
  e in W.edges() iff
  ex n being Element of NAT st n in dom W.edgeSeq() & W.edgeSeq().n = e
proof
  hereby
    assume e in W.edges();
    then consider n being set such that
A1: n in dom W.edgeSeq() & W.edgeSeq().n = e by FUNCT_1:def 5;
    reconsider n as Element of NAT by A1;
    take n;
    thus n in dom W.edgeSeq() & W.edgeSeq().n = e by A1;
  end;
  given n being Element of NAT such that
A2: n in dom W.edgeSeq() & W.edgeSeq().n = e;
  thus thesis by A2,FUNCT_1:def 5;
end;

theorem ::tWEDGES07
  e in W.edges() & e Joins x,y,G implies
  x in W.vertices() & y in W.vertices() by Lm48;

theorem ::tWEDGES08
  W.cut(m,n).edges() c= W.edges()
proof
  now per cases;
    suppose
A1:   m is odd & n is odd & m <= n & n <= len W;
      then reconsider m' = m as odd Element of NAT;
      now
        let e be set;
        assume e in W.cut(m,n).edges();
        then consider x being even Element of NAT such that
A2:     1 <= x & x <= len W.cut(m,n) & W.cut(m,n).x = e by Lm46;
        reconsider xaa1 = x-1 as odd Element of NAT by A2,INT_1:18;
A3:     xaa1+1 = x;
        xaa1 < len W.cut(m,n) - 0 by A2,XREAL_1:17;
        then
A4:     e = W.(m+xaa1) & m+xaa1 in dom W by A1,A2,A3,Lm15;
        then 1 <= m'+xaa1 & m'+xaa1 <= len W by FINSEQ_3:27;
        hence e in W.edges() by A4,Lm46;
      end;
      hence thesis by TARSKI:def 3;
    end;
    suppose not (m is odd & n is odd & m <= n & n <= len W);
      hence thesis by Def11;
    end;
  end;
  hence thesis;
end;

theorem Th108: ::tWEDGES09
  W.edges() = W.reverse().edges()
proof
  now
    let e be set;
    hereby
      assume e in W.edges();
      then consider n being even Element of NAT such that
A1:   1 <= n & n <= len W & W.n = e by Lm46;
      n in dom W by A1,FINSEQ_3:27;
      then
A2:   e = W.reverse().(len W - n + 1) &
      (len W - n + 1) in dom W.reverse() by A1,Th25;
      then reconsider rn = len W - n + 1 as even Element of NAT;
      1 <= rn & rn <= len W.reverse() by A2,FINSEQ_3:27;
      hence e in W.reverse().edges() by A2,Lm46;
    end;
    assume e in W.reverse().edges();
    then consider n being even Element of NAT such that
A3: 1 <= n & n <= len W.reverse() & W.reverse().n = e by Lm46;
    n in dom W.reverse() by A3,FINSEQ_3:27;
    then
A4: e = W.reverse().reverse().(len W.reverse() - n + 1) &
    (len W.reverse() - n + 1) in dom W.reverse().reverse() by A3,Th25;
    then reconsider rn = len W.reverse() - n + 1 as even Element of NAT;
A5: e = W.rn & rn in dom W by A4,FINSEQ_6:29;
    then 1 <= rn & rn <= len W by FINSEQ_3:27;
    hence e in W.edges() by A5,Lm46;
  end;
  hence thesis by TARSKI:2;
end;

theorem Th109: ::tWEDGES10
  e Joins x,y,G iff G.walkOf(x,e,y).edges() = {e}
proof
  set W = G.walkOf(x,e,y);
  hereby
    assume e Joins x,y,G;
    then W.edgeSeq() = <*e*> by Th84;
    hence W.edges() = {e} by FINSEQ_1:56;
  end;
  assume W.edges() = {e};
  then e in W.edges() by TARSKI:def 1;
  then consider n being even Element of NAT such that
A1: 1 <= n & n <= len W & W.n = e by Lm46;
A2: 2*0+1 < n by A1,XXREAL_0:1;
  now
    assume not e Joins x,y,G;
    then W = G.walkOf(choose the_Vertices_of G) by Def5;
    hence contradiction by A1,A2,Th14;
  end;
  hence thesis;
end;

theorem ::tWEDGES11
  W.edges() c= G.edgesBetween(W.vertices())
proof
  now
    let e be set;
    assume e in W.edges();
    then consider v1,v2 being Vertex of G, n being odd Element of NAT such
    that
A1: n+2 <= len W & v1 = W.n & e = W.(n+1) & v2 = W.(n+2) &
    e Joins v1,v2,G by Lm47;
    n < len W by A1,Th1;
    then
A2: v1 in W.vertices() by A1,Lm45;
    v2 in W.vertices() by A1,Lm45;
    hence e in G.edgesBetween(W.vertices()) by A1,A2,GLIB_000:35;
  end;
  hence thesis by TARSKI:def 3;
end;

theorem ::tWEDGES12
  for W1 being Walk of G1, W2 being Walk of G2 st W1 = W2 holds
  W1.edges() = W2.edges() by Th87;

theorem ::tWEDGES13
  e Joins W.last(),x,G implies W.addEdge(e).edges() = W.edges() \/ {e}
proof
  set WB = G.walkOf(W.last(),e,W.last().adj(e));
  assume e Joins W.last(),x,G;
  then e in W.last().edgesInOut() by GLIB_000:65;
  then
A1: e Joins W.last(), W.last().adj(e), G by GLIB_000:70;
  then
A2: WB.edges() = {e} by Th109;
  WB.first() = W.last() by A1,Th16;
  hence thesis by A2,Th103;
end;

theorem ::tWLENGTH01
  len W = 2 * W.length() + 1 by Def15;

theorem ::tWLENGTH02
  len W1 = len W2 iff W1.length() = W2.length()
proof
  hereby
    assume len W1 = len W2;
    then 2 * W1.length() + 1 = len W2 by Def15
      .= 2 * W2.length() + 1 by Def15;
    hence W1.length() = W2.length();
  end;
  assume W1.length() = W2.length();
  hence len W1 = 2*W2.length()+1 by Def15
    .= len W2 by Def15;
end;

theorem ::tWLENGTH03
  for W1 being Walk of G1, W2 being Walk of G2 st W1 = W2 holds
  W1.length() = W2.length() by Th87;

theorem Th116: ::tWFINDV01
  for n being odd Element of NAT st n <= len W holds
  W.find(W.n) <= n & W.rfind(W.n) >= n
proof
  let n be odd Element of NAT;
  assume
A1: n <= len W;
  then
A2: W.n in W.vertices() by Lm45;
  hence W.find(W.n) <= n by A1,Def19;
  thus thesis by A1,A2,Def21;
end;

theorem ::tWFINDV02
  for W1 being Walk of G1, W2 being Walk of G2, v being set st W1 = W2 holds
  W1.find(v) = W2.find(v) & W1.rfind(v) = W2.rfind(v)
proof
  let W1 be Walk of G1, W2 be Walk of G2, v be set;
  assume
A1: W1 = W2;
  now per cases;
    suppose
A2:   v in W1.vertices();
      then
A3:   v in W2.vertices() by A1,Th77;
      W1.find(v) <= len W2 & W2.(W1.find(v)) = v &
      for n being odd Nat st n <= len W2 & W2.n = v
      holds W1.find(v) <= n by A1,A2,Def19;
      hence W1.find(v) = W2.find(v) by A3,Def19;
      W1.rfind(v) <= len W2 & W2.(W1.rfind(v)) = v &
      for n being odd Element of NAT st n <= len W2 & W2.n = v
      holds n <= W1.rfind(v) by A1,A2,Def21;
      hence W1.rfind(v) = W2.rfind(v) by A3,Def21;
    end;
    suppose
A4:   not v in W1.vertices();
      then
A5:   not v in W2.vertices() by A1,Th77;
      thus W1.find(v) = len W2 by A1,A4,Def19
        .= W2.find(v) by A5,Def19;
      thus W1.rfind(v) = len W2 by A1,A4,Def21
        .= W2.rfind(v) by A5,Def21;
    end;
  end;
  hence thesis;
end;

theorem ::tWFINDN01
  for n being odd Element of NAT st n <= len W holds
  W.find(n) <= n & W.rfind(n) >= n by Lm49,Lm50;

theorem Th119: ::tCLWALK01
  W is closed iff W.1 = W.(len W)
proof
  hereby
    assume W is closed;
    then W.first() = W.last() by Def24;
    hence W.1 = W.(len W);
  end;
  assume W.1 = W.(len W);
  then W.first() = W.last();
  hence W is closed by Def24;
end;

theorem ::tCLWALK02
  W is closed iff ex x being set st W is_Walk_from x,x
proof
  hereby
    assume W is closed;
    then
A1: W.first() = W.last() by Def24;
    set x = W.first();
    W is_Walk_from x,x by A1,Def23;
    hence ex x being set st W is_Walk_from x,x;
  end;
  given v being set such that
A2: W is_Walk_from v,v;
  W.first() = v & W.last() = v by A2,Def23;
  hence W is closed by Def24;
end;

theorem ::tCLWALK03
  W is closed iff W.reverse() is closed
proof
  W is closed iff W.first() = W.last() by Def24;
  then W is closed iff W.reverse().last() = W.last() by Th23;
  then W is closed iff W.reverse().last() = W.reverse().first() by Th23;
  hence thesis by Def24;
end;

theorem ::tCLWALK04
  for W1 being Walk of G1, W2 being Walk of G2 st W1 = W2 & W1 is closed
  holds W2 is closed
proof
  let W1 be Walk of G1, W2 be Walk of G2;
  assume W1 = W2 & W1 is closed;
  then W2.1 = W2.(len W2) by Th119;
  hence W2 is closed by Th119;
end;

theorem ::tDIWALK01
  W is directed iff for n being odd Element of NAT st n < len W
  holds W.(n+1) DJoins W.n, W.(n+2), G by Lm51;

theorem ::tDIWALK02
  W is directed & W is_Walk_from x,y & e DJoins y,z,G
  implies W.addEdge(e) is directed & W.addEdge(e) is_Walk_from x,z by Lm52;

theorem ::tDIWALK03
  for W being DWalk of G, m,n being Element of NAT holds
  W.cut(m,n) is directed;

theorem ::tTVWALK01
  W is non trivial iff 3 <= len W by Lm54;

theorem ::tTVWALK02
  W is non trivial iff len W <> 1 by Lm55;

theorem  ::tTVWALK03
  W.first() <> W.last() implies W is non trivial by Lm55;

theorem ::tTVWALK04
  W is trivial iff ex v being Vertex of G st W = G.walkOf(v) by Lm56;

theorem ::tTVWALK05
  W is trivial iff W.reverse() is trivial
proof
  thus W is trivial implies W.reverse() is trivial;
  assume W.reverse() is trivial;
  then len W.reverse() = 1 by Lm55;
  then len W = 1 by FINSEQ_5:def 3;
  hence W is trivial by Lm55;
end;

theorem ::tTVWALK06
  W2 is trivial implies W1.append(W2) = W1
proof
  assume W2 is trivial;
  then
A1: len W2 = 1 by Lm55;
A2: W2 <> {} by CARD_1:47;
  now per cases;
    suppose W1.last() = W2.first();
      then
A3:   W1.append(W2) = W1 ^' W2 by Def10;
      then
A4:   len W1.append(W2) + 1 = len W1 + 1 by A1,A2,GRAPH_2:13;
      for k being Nat st 1 <= k & k <= len W1.append(W2)
      holds W1.append(W2).k = W1.k
      proof
        let k be Nat;
        reconsider k as Element of NAT by ORDINAL1:def 13;
        1 <= k & k <= len W1.append(W2)
        implies W1.append(W2).k = W1.k by A3,A4,GRAPH_2:14;
        hence thesis;
      end;
      hence thesis by A4,FINSEQ_1:18;
    end;
    suppose W1.last() <> W2.first();
      hence thesis by Def10;
    end;
  end;
  hence thesis;
end;

theorem ::tTVWALK07
  for m, n being odd Element of NAT st m <= n & n <= len W holds
  W.cut(m,n) is trivial iff m = n
proof
  let m, n be odd Element of NAT;
  assume m <= n & n <= len W;
  then
A1: len W.cut(m,n) + m = n + 1 by Lm15;
  hereby
    assume W.cut(m,n) is trivial;
    then 1 = (n - m) + 1 by A1,Lm55;
    hence m = n;
  end;
  assume m = n;
  hence W.cut(m,n) is trivial by A1,Lm55;
end;

theorem Th133: ::tTVWALK08
  e Joins W.last(),x,G implies W.addEdge(e) is non trivial
proof
A1: 1 + 0 < len W + 2 by XREAL_1:10;
  assume e Joins W.last(), x, G;
  then len W.addEdge(e) = len W + 2 by Lm37;
  hence thesis by A1,Lm55;
end;

theorem Th134: ::tTVWALK09
  W is non trivial implies ex lenW2 being odd Element of NAT
  st lenW2 = len W - 2 & W.cut(1,lenW2).addEdge(W.(lenW2+1)) = W
proof
  assume W is non trivial;
  then
A1: len W >= 3 by Lm54;
  set lenW2 = len W - 2*1;
  reconsider lenW2 as odd Element of NAT by A1,INT_1:18,XXREAL_0:2;
  take lenW2;
  thus lenW2 = len W - 2;
  set W1 = W.cut(1,lenW2), e = W.(lenW2+1);
  1 <= lenW2 & lenW2 < len W - 0 by HEYTING3:1,XREAL_1:17;
  hence W1.addEdge(e) = W.cut(1,lenW2+2) by Th42,JORDAN12:3
    .= W by Lm18;
end;

theorem Th135: ::tTVWALK10
  W2 is non trivial & W2.edges() c= W1.edges() implies
  W2.vertices() c= W1.vertices()
proof
  assume
A1: W2 is non trivial & W2.edges() c= W1.edges();
  then
A2: 3 <= len W2 by Lm54;
  now
    let v be set;
    assume v in W2.vertices();
    then consider n being odd Element of NAT such that
A3: n <= len W2 & W2.n = v by Lm45;
    now per cases;
      suppose n = len W2;
        then 3-1 < n-0 by A2,XREAL_1:17;
        then reconsider n5 = n-2*1 as odd Element of NAT by INT_1:18;
        n5 < n - 0 by XREAL_1:17;
        then
A4:     n5 < len W2 by A3,XXREAL_0:2;
        then
A5:     W2.(n5+1) Joins W2.n5, W2.(n5+2), G by Def3;
        1 <= n5+1 & n5+1 <= len W2 by A4,NAT_1:12,13;
        then W2.(n5+1) in W2.edges() by Lm46;
        then consider m being even Element of NAT such that
A6:     1 <= m & m <= len W1 & W1.m = W2.(n5+1) by A1,Lm46;
        reconsider maa1 = m - 1 as odd Element of NAT by A6,INT_1:18;
A7:     maa1 < len W1 - 0 by A6,XREAL_1:17;
        then
A8:     W1.(maa1+1) Joins W1.maa1, W1.(maa1+2), G by Def3;
A9:     W1.maa1 = W1.vertexAt(maa1) by A7,Def8;
A10:    maa1+2 <= len W1 by A7,Th1;
        then W1.(maa1+2) = W1.vertexAt(maa1+2) by Def8;
        then v = W1.vertexAt(maa1) or v = W1.vertexAt(maa1+2)
        by A3,A5,A6,A8,A9,GLIB_000:18;
        hence v in W1.vertices() by A7,A10,Th90;
      end;
      suppose n <> len W2;
        then
A11:    n < len W2 by A3,XXREAL_0:1;
        then W2.(n+1) in W2.edges() by Th101;
        then consider m being even Element of NAT such that
A12:    1 <= m & m <= len W1 & W1.m = W2.(n+1) by A1,Lm46;
A13:    W1.m Joins v, W2.(n+2),G by A3,A11,A12,Def3;
        reconsider maa1 = m - 1 as odd Element of NAT by A12,INT_1:18;
A14:    maa1 < len W1 - 0 by A12,XREAL_1:17;
        then
A15:    W1.(maa1+1) Joins W1.maa1, W1.(maa1+2), G by Def3;
A16:    W1.maa1 = W1.vertexAt(maa1) by A14,Def8;
A17:    maa1+2 <= len W1 by A14,Th1;
        then W1.(maa1+2) = W1.vertexAt(maa1+2) by Def8;
        then v = W1.vertexAt(maa1) or v = W1.vertexAt(maa1+2)
        by A13,A15,A16,GLIB_000:18;
        hence v in W1.vertices() by A14,A17,Th90;
      end;
    end;
    hence v in W1.vertices();
  end;
  hence thesis by TARSKI:def 3;
end;

theorem ::tTVWALK11
  W is non trivial implies
  for v being Vertex of G st v in W.vertices() holds not v is isolated
proof
  assume W is non trivial;
  then
A1: len W <> 1 by Lm55;
  let v be Vertex of G;
  assume v in W.vertices();
  then consider n being odd Element of NAT such that
A2: n <= len W & W.n = v by Lm45;
  now per cases;
    suppose
A3:   n = len W;
      1 <= len W by HEYTING3:1;
      then 1 < len W by A1,XXREAL_0:1;
      then 1+1 <= len W by NAT_1:13;
      then reconsider lenW2 = len W - 2*1 as odd Element of NAT by INT_1:18;
      lenW2 < len W - 0 by XREAL_1:17;
      then W.(lenW2+1) Joins W.lenW2,W.(lenW2+2),G by Def3;
      then W.(lenW2+1) Joins v,W.lenW2,G by A2,A3,GLIB_000:17;
      hence ex e being set st e in v.edgesInOut() by GLIB_000:65;
    end;
    suppose n <> len W;
      then n < len W by A2,XXREAL_0:1;
      then W.(n+1) Joins v, W.(n+2), G by A2,Def3;
      hence ex e being set st e in v.edgesInOut() by GLIB_000:65;
    end;
  end;
  hence not v is isolated by GLIB_000:def 51;
end;

theorem ::tTVWALK12
  W is trivial iff W.edges() = {}
proof
  hereby assume W is trivial;
   then W.length() = 0 by Def26;
  then W.edgeSeq() = {};
  hence W.edges() = {};
  end;
  assume W.edges() = {};
  then W.edgeSeq() = {};
  then W.length() = 0;
  hence W is trivial by Def26;
end;

theorem ::tTVWALK13
  for W1 being Walk of G1, W2 being Walk of G2 st W1 = W2 & W1 is trivial
  holds W2 is trivial
proof
  let W1 be Walk of G1, W2 be Walk of G2;
  assume W1 = W2 & W1 is trivial;
  then len W2 = 1 by Lm55;
  hence thesis by Lm55;
end;

theorem ::tTLWALK01
  W is Trail-like iff
  for m,n being even Element of NAT st 1 <= m & m < n & n <= len W holds
  W.m <> W.n by Lm57;

theorem ::tTLWALK02
  len W <= 3 implies W is Trail-like by Lm61;

theorem ::tTLWALK03
  W is Trail-like iff W.reverse() is Trail-like by Lm58;

theorem ::tTLWALK04
  for W being Trail of G, m,n being Element of NAT
  holds W.cut(m,n) is Trail-like;

theorem ::tTLWALK05
  for W being Trail of G, e being set
  st e in W.last().edgesInOut() & not e in W.edges()
  holds W.addEdge(e) is Trail-like by Lm60;

theorem ::tTLWALK06
  for W being Trail of G, v being Vertex of G
  st v in W.vertices() & v is endvertex holds v = W.first() or v = W.last()
proof
  let W be Trail of G, v be Vertex of G;
  assume
A1: v in W.vertices() & v is endvertex;
  then consider n being odd Element of NAT such that
A2: n <= len W & W.n = v by Lm45;
A3: W.vertexAt(n) = v by A2,Def8;
  consider e being set such that
A4: v.edgesInOut() = {e} & not e Joins v,v,G by A1,GLIB_000:def 53;
  now
    assume
A5: v <> W.first() & v <> W.last();
    1 <= n by HEYTING3:1;
    then
A6: 1 < n by A2,A5,XXREAL_0:1;
    reconsider naa1 = n-1 as even Element of NAT by HEYTING3:1,INT_1:18;
    1+1 <= n by A6,NAT_1:13;
    then
A7: 1+1-1 <= n-1 by XREAL_1:15;
A8: n < len W by A2,A5,XXREAL_0:1;
    then
A9: n+1 <= len W by NAT_1:13;
    n-1 < naa1+2 by NAT_1:16;
    then
A10: W.(naa1) <> W.(n+1) by A7,A9,Lm57;
    W.(n-1) in v.edgesInOut() by A2,A3,A6,Th12;
    then
A11: W.(n-1) = e by A4,TARSKI:def 1;
    W.(n+1) in v.edgesInOut() by A3,A8,Th11;
    hence contradiction by A4,A10,A11,TARSKI:def 1;
  end;
  hence thesis;
end;

theorem ::tTLWALK07
  for G being finite _Graph, W being Trail of G holds
  len W.edgeSeq() <= G.size()
proof
  let G be finite _Graph, W be Trail of G;
  consider f being Function such that
A1: dom f = W.edgeSeq() & for x being set st x in W.edgeSeq() holds f.x = x`2
  from FUNCT_1:sch 3;
  now
    let y be set;
    assume y in rng f;
    then consider x being set such that
A2: x in dom f & f.x = y by FUNCT_1:def 5;
A3: x in W.edgeSeq() & y = x`2 by A1,A2;
    consider a,b being set such that
A4: x = [a,b] by A1,A2,RELAT_1:def 1;
    y = b by A3,A4,MCART_1:def 2;
    then y in rng W.edgeSeq() by A1,A2,A4,RELAT_1:def 5;
    hence y in (the_Edges_of G);
  end;
  then
A5: rng f c= the_Edges_of G by TARSKI:def 3;
  now
    let x1,x2 be set;
    assume
A6: x1 in dom f & x2 in dom f & f.x1 = f.x2;
    then
A7: x1 in W.edgeSeq() & f.x1 = x1`2 & x2 in W.edgeSeq() & f.x2 = x2`2 by A1;
    consider a1,b1 being set such that
A8: x1 = [a1,b1] by A1,A6,RELAT_1:def 1;
    consider a2,b2 being set such that
A9: x2 = [a2,b2] by A1,A6,RELAT_1:def 1;
A10: b1 = f.x1 by A7,A8,MCART_1:def 2
      .= b2 by A6,A7,A9,MCART_1:def 2;
A11: W.edgeSeq() is one-to-one by Def27;
A12: a1 in dom W.edgeSeq() & W.edgeSeq().a1 = b1 by A1,A6,A8,FUNCT_1:8;
    a2 in dom W.edgeSeq() & W.edgeSeq().a2 = b1 by A1,A6,A9,A10,FUNCT_1:8;
    hence x1 = x2 by A8,A9,A10,A11,A12,FUNCT_1:def 8;
  end;
  then f is one-to-one by FUNCT_1:def 8;
  then card W.edgeSeq() c= card (the_Edges_of G) by A1,A5,CARD_1:26;
  then card W.edgeSeq() <= card (the_Edges_of G) by NAT_1:40;
  hence len W.edgeSeq() <= G.size() by GLIB_000:def 27;
end;

theorem ::tPLWALK01
  len W <= 3 implies W is Path-like by Lm69;

theorem ::tPLWALK02
  (for m,n being odd Element of NAT st m <= len W & n <= len W & W.m = W.n
  holds m = n) implies W is Path-like by Lm66;

theorem ::tPLWALK03
  for W being Path of G st W is open holds
  for m, n being odd Element of NAT st m < n & n <= len W holds W.m <> W.n
proof
  let W be Path of G;
  assume
A1: W is open;
  let m, n be odd Element of NAT;
  assume
A2: m < n & n <= len W;
  now
    assume
A3: W.m = W.n;
    then m = 1 & n = len W by A2,Def28;
    hence contradiction by A1,A3,Th119;
  end;
  hence thesis;
end;

theorem ::tPLWALK04
  W is Path-like iff W.reverse() is Path-like by Lm63;

theorem ::tPLWALK05
  for W being Path of G, m, n being Element of NAT
  holds W.cut(m,n) is Path-like;

theorem Th151: ::tPLWALK06
  for W being Path of G, e,v being set
  st e Joins W.last(),v,G & not e in W.edges() & (W is trivial or W is open) &
  for n being odd Element of NAT st 1 < n & n <= len W holds W.n <> v holds
  W.addEdge(e) is Path-like
proof
  let W be Path of G, e,v be set;
  assume
A1: e Joins W.last(), v,G & not e in W.edges() & (W is trivial or W is open) &
  (for n being odd Element of NAT st 1 < n & n <= len W holds W.n <> v);
  then
A2: e in W.last().edgesInOut() by GLIB_000:65;
  set W2 = W.addEdge(e);
  reconsider lenW = len W as odd Element of NAT;
  now thus W2 is Trail-like by A1,A2,Lm60;
    let m, n be odd Element of NAT;
    assume
A3: m < n & n <= len W2 & W2.m = W2.n;
    now per cases by A1;
      suppose
A4:     W is open;
        now per cases;
          suppose
A5:         n <= len W;
            then
A6:         m <= len W by A3,XXREAL_0:2;
            1 <= m by HEYTING3:1;
            then m in dom W by A6,FINSEQ_3:27;
            then
A7:         W2.m = W.m by A1,Lm38;
            1 <= n by HEYTING3:1;
            then
A8:         n in dom W by A5,FINSEQ_3:27;
            then W.m = W.n by A1,A3,A7,Lm38;
            then m = 1 & n = len W by A3,A5,Def28;
            then W.first() = W.last() by A1,A3,A7,A8,Lm38;
            hence m = 1 & n = len W2 by A4,Def24;
          end;
          suppose n > len W;
            then lenW + 1 <= n by NAT_1:13;
            then lenW + 1 < n by XXREAL_0:1;
            then lenW + 1 + 1 <= n by NAT_1:13;
            then len W + (1+1) <= n;
            then
A9:         len W2 <= n by A1,Lm37;
            then
A10:        n = len W2 by A3,XXREAL_0:1;
            then W2.n = W2.(len W + 2) by A1,Lm37;
            then
A11:        W2.n = v by A1,Lm38;
            m < len W + (1 + 1) by A1,A3,A10,Lm37;
            then m < len W + 1 + 1;
            then m <= lenW + 1 by NAT_1:13;
            then m < lenW + 1 by XXREAL_0:1;
            then
A12:        m <= len W by NAT_1:13;
            1 <= m by HEYTING3:1;
            then m in dom W by A12,FINSEQ_3:27;
            then
A13:        W.m = v by A1,A3,A11,Lm38;
            now
              assume
A14:          m <> 1;
              1 <= m by HEYTING3:1;
              then 1 < m by A14,XXREAL_0:1;
              hence contradiction by A1,A12,A13;
            end;
            hence m = 1;
            thus n = len W2 by A3,A9,XXREAL_0:1;
          end;
        end;
        hence m = 1 & n = len W2;
      end;
      suppose W is trivial;
        then consider v being Vertex of G such that
A15:    W = G.walkOf(v) by Lm56;
        len W = 1 by A15,Th14;
        then
A16:    len W2 = 1 + 2 by A1,Lm37;
A17:    1 <= m by HEYTING3:1;
        then
A18:    1+1 <= m+1 by XREAL_1:9;
        m+1 <= n by A3,NAT_1:13;
        then 2*1 <= n by A18,XXREAL_0:2;
        then 2*1 < n by XXREAL_0:1;
        then
A19:    len W2 <= n by A16,NAT_1:13;
        then m < 3 by A3,A16,XXREAL_0:1;
        then m+1-1 <= 3-1 by A16,NAT_1:13;
        then m < 2*1 by XXREAL_0:1;
        then m+1 <= 2 by NAT_1:13;
        then m+1-1 <= 2-1 by XREAL_1:15;
        hence m = 1 & n = len W2 by A3,A17,A19,XXREAL_0:1;
      end;
    end;
    hence m = 1 & n = len W2;
  end;
  hence W.addEdge(e) is Path-like by Def28;
end;

theorem ::tPLWALK07
  for W being Path of G, e, v being set st e Joins W.last(),v,G &
  not v in W.vertices() & (W is trivial or W is open)
  holds W.addEdge(e) is Path-like by Lm68;

theorem ::tPLWALK08
  (for n being odd Element of NAT st n <= len W
  holds W.find(W.n) = W.rfind(W.n)) implies W is Path-like
proof
  assume
A1: for n being odd Element of NAT st n <= len W
  holds W.find(W.n) = W.rfind(W.n);
A2: now
    let x be odd Element of NAT;
    assume
A3: x <= len W;
    then
A4: W.find(W.x) <= x by Th116;
A5: W.rfind(W.x) >= x by A3,Th116;
    W.find(W.x) = W.rfind(W.x) by A1,A3;
    hence W.find(W.x) = x & W.rfind(W.x) = x by A4,A5,XXREAL_0:1;
  end;
  now
    let m, n be even Element of NAT;
    assume
A6: 1 <= m & m < n & n <= len W;
    then 1 <= m & m <= len W by XXREAL_0:2;
    then m in dom W by FINSEQ_3:27;
    then consider maa1 being odd Element of NAT such that
A7: maa1 = m-1 & m-1 in dom W & m+1 in dom W &
    W.m Joins W.(maa1), W.(m+1),G by Lm2;
    1 <= n & n <= len W by A6,XXREAL_0:2;
    then n in dom W by FINSEQ_3:27;
    then consider naa1 being odd Element of NAT such that
A8: naa1 = n-1 & n-1 in dom W & n+1 in dom W &
    W.n Joins W.(naa1), W.(n+1),G by Lm2;
    now
      assume
A9:   W.m = W.n;
      set Wmaa1 = W.(maa1), Wm1 = W.(m+1);
      set Wnaa1 = W.(naa1), Wn1 = W.(n+1);
A10:  maa1 <= len W & n+1 <= len W & naa1 <= len W by A7,A8,FINSEQ_3:27;
      then
A11:  W.find(Wmaa1) = maa1 & W.rfind(Wnaa1) = naa1 & W.rfind(Wn1) = n+1 by A2;
      now per cases by A7,A8,A9,GLIB_000:18;
        suppose Wmaa1 = Wnaa1 & Wm1 = Wn1;
          then maa1 = naa1 by A1,A10,A11;
          hence contradiction by A6,A7,A8;
        end;
        suppose Wmaa1 = Wn1 & Wm1 = Wnaa1;
          then maa1 = n+1 by A1,A10,A11;
          then n <= maa1-1+1 by NAT_1:12;
          then n <= m-1+1 by A7,NAT_1:12;
          hence contradiction by A6;
        end;
      end;
      hence contradiction;
    end;
    hence W.m <> W.n;
  end;
  then
A12: W is Trail-like by Lm57;
  now
    let m, n be odd Element of NAT;
    assume
A13: m < n & n <= len W & W.m = W.n;
    then m <= len W by XXREAL_0:2;
    then W.find(W.m) = m & W.find(W.m) = n by A2,A13;
    hence m = 1 & n = len W by A13;
  end;
  hence thesis by A12,Def28;
end;

theorem ::tPLWALK09
  (for n being odd Element of NAT st n <= len W holds W.rfind(n) = n)
  implies W is Path-like by Lm67;

theorem ::tPLWALK10
  for G being finite _Graph, W being Path of G holds
  len W.vertexSeq() <= G.order() + 1
proof
  let G be finite _Graph, W be Path of G;
  now per cases;
    suppose len W = 1;
      then 1 + 1 = 2 * len W.vertexSeq() by Def14;
      hence thesis by NAT_1:12;
    end;
    suppose len W <> 1;
      then W is non trivial by Lm55;
      then consider lenW2 being odd Element of NAT such that
A1:   lenW2 = len W - 2 & W.cut(1,lenW2).addEdge(W.(lenW2+1)) = W by Th134;
      set W2 = W.cut(1,lenW2), vs1 = W2.vertexSeq();
A2:   lenW2 < len W - 0 by A1,XREAL_1:17;
      then
A3:   len W2 = lenW2 by Lm22;
      consider f being Function such that
A4:   dom f = vs1 & for x being set st x in vs1 holds f.x = x`2
      from FUNCT_1:sch 3;
      now
        let y be set;
        assume y in rng f;
        then consider x being set such that
A5:     x in dom f & f.x = y by FUNCT_1:def 5;
        consider a,b being set such that
A6:     x = [a,b] by A4,A5,RELAT_1:def 1;
        y = x`2 by A4,A5;
        then
A7:     y = b by A6,MCART_1:def 2;
        a in dom vs1 & b = vs1.a by A4,A5,A6,FUNCT_1:8;
        then y in rng vs1 by A7,FUNCT_1:def 5;
        hence y in the_Vertices_of G;
      end;
      then
A8:   rng f c= the_Vertices_of G by TARSKI:def 3;
      now
        let x1, x2 be set;
        assume
A9:     x1 in dom f & x2 in dom f & f.x1 = f.x2;
        then consider a1,b1 being set such that
A10:    x1 = [a1,b1] by A4,RELAT_1:def 1;
        consider a2,b2 being set such that
A11:    x2 = [a2,b2] by A4,A9,RELAT_1:def 1;
A12:    f.x1 = x1`2 by A4,A9
          .= b1 by A10,MCART_1:def 2;
A13:    f.x2 = x2`2 by A4,A9
          .= b2 by A11,MCART_1:def 2;
A14:    a1 in dom vs1 & b1 = vs1.a1 & a2 in dom vs1 & b2 = vs1.a2
        by A4,A9,A10,A11,FUNCT_1:8;
        then reconsider a1,a2 as Element of NAT;
A15:    now
          let n1,n2 be Element of NAT;
          assume
A16:      n1<n2 & n1 in dom vs1 & n2 in dom vs1 & vs1.n1 = vs1.n2;
          then
A17:      2*n1-1 in dom W2 & 2*n2-1 in dom W2 by Th74;
          then reconsider a = 2*n1-1, b=2*n2-1 as odd Element of NAT;
          1 <= n1 & n1 <= len vs1 & 1 <= n2 & n2 <= len vs1
          by A16,FINSEQ_3:27;
          then
A18:      vs1.n1 = W2.a & vs1.n2 = W2.b by Def14;
A19:      W2.a = W.a & W2.b = W.b by A2,A17,Lm23;
          2*n1 < 2*n2 by A16,XREAL_1:70;
          then
A20:      a < b by XREAL_1:16;
          b <= lenW2 by A3,A17,FINSEQ_3:27;
          then b < len W by A2,XXREAL_0:2;
          hence contradiction by A16,A18,A19,A20,Def28;
        end;
        now
          assume
A21:      a1 <> a2;
          now per cases;
            suppose a1 <= a2;
              then a1 < a2 by A21,XXREAL_0:1;
              hence contradiction by A9,A12,A13,A14,A15;
            end;
            suppose a1 > a2;
              hence contradiction by A9,A12,A13,A14,A15;
            end;
          end;
          hence contradiction;
        end;
        hence x1 = x2 by A9,A10,A11,A12,A13;
      end;
      then f is one-to-one by FUNCT_1:def 8;
      then card vs1 c= card the_Vertices_of G by A4,A8,CARD_1:26;
      then card vs1 <= card the_Vertices_of G by NAT_1:40;
      then len vs1 <= G.order() by GLIB_000:def 26;
      then
A22:  len vs1 + 1 <= G.order() + 1 by XREAL_1:9;
A23:  lenW2 < len W - 0 by A1,XREAL_1:17;
      then
A24:  W.(lenW2+1) Joins W.lenW2, W.(lenW2+2), G by Def3;
      1 is odd & 1 <= lenW2 by HEYTING3:1,JORDAN12:3;
      then W2.last() = W.lenW2 by A23,Lm16;
      then W.vertexSeq() = vs1 ^ <*W.(lenW2+2)*> by A1,A24,Th76;
      then len W.vertexSeq() = len vs1 + len <*W.(lenW2+2)*> by FINSEQ_1:35;
      hence thesis by A22,FINSEQ_1:56;
    end;
  end;
  hence thesis;
end;

theorem ::tWVDISTINCT01
  for G being _Graph, W being vertex-distinct Walk of G, e,v being set
  st e Joins W.last(),v,G & not v in W.vertices()
  holds W.addEdge(e) is vertex-distinct
proof
  let G be _Graph, W be vertex-distinct Walk of G, e,v be set;
  assume
A1: e Joins W.last(),v,G & not v in W.vertices();
  set W2 = W.addEdge(e);
A2: len W2 = len W + 2 by A1,Lm37;
A3: now
    let n be odd Element of NAT;
    assume
A4: n <= len W2 & n > len W;
    then len W + 1 <= n by NAT_1:13;
    then len W + 1 < n by XXREAL_0:1;
    then len W + 1 + 1 <= n by NAT_1:13;
    hence n = len W2 by A2,A4,XXREAL_0:1;
    hence W2.n = v by A1,A2,Lm38;
  end;
  now
    let m,n be odd Element of NAT;
    assume
A5: m <= len W2 & n <= len W2 & W2.m = W2.n;
A6: 1 <= m & 1 <= n by HEYTING3:1;
    now per cases;
      suppose
A7:     m <= len W;
        then m in dom W by A6,FINSEQ_3:27;
        then
A8:     W2.m = W.m by A1,Lm38;
        now per cases;
          suppose
A9:         n <= len W;
            then n in dom W by A6,FINSEQ_3:27;
            then W2.n = W.n by A1,Lm38;
            hence m = n by A5,A7,A8,A9,Def29;
          end;
          suppose n > len W;
            then n = len W2 & W.m = v by A3,A5,A8;
            hence m = n by A1,A7,Lm45;
          end;
        end;
        hence m = n;
      end;
      suppose m > len W;
        then
A10:    m = len W2 & W2.m = v by A3,A5;
        now per cases;
          suppose
A11:        n <= len W;
            then n in dom W by A6,FINSEQ_3:27;
            then v = W.n by A1,A5,A10,Lm38;
            hence m = n by A1,A11,Lm45;
          end;
          suppose n > len W;
            hence m = n by A3,A5,A10;
          end;
        end;
        hence m =n;
      end;
    end;
    hence m = n;
  end;
  hence thesis by Def29;
end;

theorem ::tCYWALK01
  e Joins x,x,G implies G.walkOf(x,e,x) is Cycle-like
proof
  set W = G.walkOf(x,e,x);
  assume e Joins x,x,G;
  then len W = 3 by Th15;
  then W is non trivial by Lm54;
  hence thesis by Def31;
end;

theorem ::tCYWALK02
  e Joins x,y,G & e in W1.edges() & W1 is Cycle-like implies
  ex W2 being Walk of G st W2 is_Walk_from x,y & not e in W2.edges()
proof
  assume
A1: e Joins x,y,G & e in W1.edges() & W1 is Cycle-like;
  then consider v1,v2 being Vertex of G, n being odd Element of NAT such that
A2: n+2 <= len W1 & v1 = W1.n & e = W1.(n+1) & v2 = W1.(n+2) &
  e Joins v1,v2,G by Lm47;
  set WA = W1.cut(n+2, len W1), WB = W1.cut(2*0+1,n);
A3: WA is_Walk_from v2, W1.(len W1) by A2,Lm16;
A4: 1 <= n by HEYTING3:1;
A5: n+2-2 < len W1-0 by A2,XREAL_1:17;
  then
A6: WB is_Walk_from W1.first(), v1 by A2,A4,Lm16;
  W1 is closed by A1;
  then
A7: WB is_Walk_from W1.last(), v1 by A6,Def24;
  then
A8: WA.append(WB) is_Walk_from v2,v1 by A3,Th32;
A9: WA.last() = W1.last() & WB.first() = W1.last() by A2,A7,Def23,Lm16;
  W1 is Path-like by A1;
  then
A10: W1 is Trail-like;
A11: now
    assume e in WA.edges();
    then consider m being even Element of NAT such that
A12: 1 <= m & m <= len WA & WA.m = e by Lm46;
    reconsider maa1 = m-1 as odd Element of NAT by A12,INT_1:18;
A13: maa1+1 = m;
    maa1 < len WA - 0 by A12,XREAL_1:17;
    then
A14: e = W1.(n+2+maa1) & n+2+maa1 in dom W1 by A2,A12,A13,Lm15;
    then
A15: n+2+maa1 <= len W1 by FINSEQ_3:27;
    n+1 < n+1+1 by NAT_1:13;
    then
A16: n+1+0 < n+2+maa1 by XREAL_1:10;
    1 <= n+1 by NAT_1:12;
    hence contradiction by A2,A10,A14,A15,A16,Lm57;
  end;
A17: now
    assume e in WB.edges();
    then consider m being even Element of NAT such that
A18: 1 <= m & m <= len WB & WB.m = e by Lm46;
    m in dom WB by A18,FINSEQ_3:27;
    then
A19: W1.m = W1.(n+1) by A2,A5,A18,Lm23;
    len WB = n by A5,Lm22;
    then
A20: m+0 < n+1 by A18,XREAL_1:10;
    n+1 <= len W1 by A5,NAT_1:13;
    hence contradiction by A10,A18,A19,A20,Lm57;
  end;
  WA.append(WB).edges() = WA.edges() \/ WB.edges() by A9,Th103;
  then
A21: not e in WA.append(WB).edges() by A11,A17,XBOOLE_0:def 3;
  then
A22: not e in WA.append(WB).reverse().edges() by Th108;
A23: WA.append(WB).reverse() is_Walk_from v1,v2 by A8,Th24;
  now per cases by A1,A2,GLIB_000:18;
    suppose x = v1 & y = v2;
      hence thesis by A22,A23;
    end;
    suppose x = v2 & y = v1;
      hence thesis by A3,A7,A21,Th32;
    end;
  end;
  hence thesis;
end;

theorem ::tSUBWALK01
  W is Subwalk of W by Lm70;

theorem ::tSUBWALK02
  for W1 being Walk of G, W2 being Subwalk of W1, W3 being Subwalk of W2
  holds W3 is Subwalk of W1 by Lm71;

theorem ::tSUBWALK03
  W1 is Subwalk of W2 implies (W1 is_Walk_from x,y iff W2 is_Walk_from x,y)
proof
  assume
A1: W1 is Subwalk of W2;
  hereby
    assume W1 is_Walk_from x,y;
    then
A2: W1.first() = x & W1.last() = y by Def23;
    W1 is_Walk_from W2.first(),W2.last() by A1,Def32;
    then x = W2.first() & y = W2.last() by A2,Def23;
    hence W2 is_Walk_from x,y by Def23;
  end;
  assume W2 is_Walk_from x,y;
  then W2.first() = x & W2.last() = y by Def23;
  hence W1 is_Walk_from x,y by A1,Def32;
end;

theorem Th162: ::tSUBWALK04
  W1 is Subwalk of W2 implies W1.first() = W2.first() & W1.last() = W2.last()
proof
  assume W1 is Subwalk of W2;
  then W1 is_Walk_from W2.first(), W2.last() by Def32;
  hence thesis by Def23;
end;

theorem ::tSUBWALK05
  W1 is Subwalk of W2 implies len W1 <= len W2 by Lm72;

theorem Th164: ::tSUBWALK06
  W1 is Subwalk of W2 implies
  W1.edges() c= W2.edges() & W1.vertices() c= W2.vertices()
proof
  assume
A1: W1 is Subwalk of W2;
  then consider es being Subset of W2.edgeSeq() such that
A2: W1.edgeSeq() = Seq es by Def32;
  now
    let e be set;
    assume e in W1.edges();
    then consider n being even Element of NAT such that
A3: 1 <= n & n <= len W1 & W1.n = e by Lm46;
    n div 2 in dom Seq es & W1.n = (Seq es).(n div 2) by A2,A3,Lm40;
    then consider m being Element of NAT such that
A4: m in dom W2.edgeSeq() & n div 2 <= m & W1.n = W2.edgeSeq().m by Th4;
    thus e in W2.edges() by A3,A4,Th105;
  end;
  hence
A5: W1.edges() c= W2.edges() by TARSKI:def 3;
  now per cases;
    suppose
A6:   W1 is trivial;
      now
        let v be set;
        assume v in W1.vertices();
        then consider n being odd Element of NAT such that
A7:     n <= len W1 & W1.n = v by Lm45;
        1 <= n & n <= 1 by A6,A7,Lm55,HEYTING3:1;
        then v = W1.first() by A7,XXREAL_0:1;
        then v = W2.first() by A1,Th162;
        hence v in W2.vertices() by Th89;
      end;
      hence W1.vertices() c= W2.vertices() by TARSKI:def 3;
    end;
    suppose W1 is non trivial;
      hence W1.vertices() c= W2.vertices() by A5,Th135;
    end;
  end;
  hence thesis;
end;

theorem Th165: ::tSUBWALK07
  W1 is Subwalk of W2 implies
  for m being odd Element of NAT st m <= len W1 holds
  ex n being odd Element of NAT st m <= n & n <= len W2 & W1.m = W2.n
proof
  assume
A1: W1 is Subwalk of W2;
  then consider es being Subset of W2.edgeSeq() such that
A2: W1.edgeSeq() = Seq es by Def32;
  let m be odd Element of NAT such that
A3: m <= len W1;
  now per cases by A3,XXREAL_0:1;
    suppose
A4:   m < len W1;
      then
A5:   W1.(m+1) Joins W1.m, W1.(m+2), G by Def3;
      reconsider m1= m+1 as even Element of NAT;
      1 <= m1 & m1 <= len W1 by A4,NAT_1:12,13;
      then m1 div 2 in dom W1.edgeSeq() & W1.m1 = W1.edgeSeq().(m1 div 2)
      by Lm40;
      then consider x being Element of NAT such that
A6:   x in dom W2.edgeSeq() & m1 div 2 <= x & W1.m1 = W2.edgeSeq().x
      by A2,Th4;
      set n = 2*x;
A7:   1 <= x & x <= len W2.edgeSeq() by A6,FINSEQ_3:27;
      2 divides m1 by PEPIN:22;
      then
A8:   2 * (m1 div 2) = m1 by NAT_D:3;
      n in dom W2 by A6,Lm41;
      then
A9:   1 <= n & n <= len W2 by FINSEQ_3:27;
      then reconsider naa1 = n - 1 as odd Element of NAT by INT_1:18;
A10:  naa1 < len W2 - 0 by A9,XREAL_1:17;
      then W2.(naa1+1) Joins W2.naa1, W2.(naa1+2), G by Def3;
      then
A11:  W1.m1 Joins W2.naa1, W2.(naa1+2), G by A6,A7,Def15;
      m1 <= n by A6,A8,XREAL_1:66;
      then
A12:  m1-1 <= n-1 by XREAL_1:15;
A13:  naa1 + 2 <= len W2 by A10,Th1;
      now per cases by A5,A11,GLIB_000:18;
        suppose W1.m = W2.naa1;
          hence thesis by A10,A12;
        end;
        suppose W1.m = W2.(naa1+2);
          hence thesis by A12,A13,NAT_1:12;
        end;
      end;
      hence thesis;
    end;
    suppose m = len W1;
      then
A14:  W1.m = W1.last()
        .= W2.last() by A1,Th162
        .= W2.(len W2);
      len W1 <= len W2 by A1,Lm72;
      then m <= len W2 by A3,XXREAL_0:2;
      hence thesis by A14;
    end;
  end;
  hence thesis;
end;

theorem ::tSUBWALK08
  W1 is Subwalk of W2 implies
  for m being even Element of NAT st 1 <= m & m <= len W1 holds
  ex n being even Element of NAT st m <= n & n <= len W2 & W1.m = W2.n
proof
  assume W1 is Subwalk of W2;
  then consider es being Subset of W2.edgeSeq() such that
A1: W1.edgeSeq() = Seq es by Def32;
  let m be even Element of NAT such that
A2: 1 <= m & m <= len W1;
  m div 2 in dom W1.edgeSeq() & W1.m = W1.edgeSeq().(m div 2) by A2,Lm40;
  then consider ndiv2 being Element of NAT such that
A3: ndiv2 in dom W2.edgeSeq() & m div 2 <= ndiv2 & W1.m = W2.edgeSeq().ndiv2
  by A1,Th4;
  1 <= ndiv2 & ndiv2 <= len W2.edgeSeq() by A3,FINSEQ_3:27;
  then
A4: W1.m = W2.(2*ndiv2) by A3,Def15;
  2 divides m by PEPIN:22;
  then
A5: 2 * (m div 2) = m by NAT_D:3;
  2*ndiv2 in dom W2 by A3,Lm41;
  then 2*ndiv2 <= len W2 by FINSEQ_3:27;
  hence thesis by A3,A4,A5,XREAL_1:66;
end;

theorem ::tSUBPATH01
  for W1 being Trail of G st W1 is non trivial holds
  ex W2 being Path of W1 st W2 is non trivial
proof
  let W1 be Trail of G;
  assume W1 is non trivial;
  then
A1: 1 <> len W1 by Lm55;
  1 <= len W1 by HEYTING3:1;
  then
A2: 1 < len W1 by A1,XXREAL_0:1;
  now per cases;
    suppose W1 is open;
      then
A3:   W1.first() <> W1.last() by Def24;
      consider P being Path of W1;
      take P;
      P.first() = W1.first() & P.last() = W1.last() by Th162;
      hence P is non trivial by A3,Lm55;
    end;
    suppose W1 is closed;
      then
A4:   W1.1 = W1.(len W1) by Th119;
      defpred P[Nat] means $1 is odd & 1 < $1 & $1 <= len W1 &
      W1.($1) = W1.(len W1);
A5:   ex k being Nat st P[k] by A2;
      consider k being Nat such that
A6:   P[k] & for m being Nat st P[m] holds k <= m from NAT_1:sch 5(A5);
      reconsider k as odd Element of NAT by A6,ORDINAL1:def 13;
      set W3 = W1.remove(k,len W1);
      1+1 < k+1 by A6,XREAL_1:10;
      then 2 <= k by NAT_1:13;
      then reconsider k2 = k - 2*1 as odd Element of NAT by INT_1:18;
      set W4 = W3.cut(2*0+1,k2);
      consider W5 being Path of W4;
      set e = W1.(k2+1), W2 = W5.addEdge(e);
      k2 < len W1 - 0 by A6,XREAL_1:17;
      then
A7:   e Joins W1.k2, W1.(k2+2), G by Def3;
A8:   len W3 + len W1 = len W1 + k by A6,Lm24;
      then
A9:   k2 <= len W3 - 0 by XREAL_1:15;
A10:  1 <= k2 by HEYTING3:1;
      then
A11:  W4.first() = W3.1 & W4.last() = W3.k2 by A9,Lm16;
      W5 is_Walk_from W4.first(), W4.last() by Def32;
      then
A12:  W5.first() = W3.1 & W5.last() = W3.k2 by A11,Def23;
      W1.k = W1.last() by A6;
      then
A13:  W3 = W1.cut(1,k) by Th58;
      k2 in dom W3 by A9,A10,FINSEQ_3:27;
      then
A14:  W5.last() = W1.k2 by A6,A12,A13,Lm23;
A15:  k2 < len W3 - 0 by A8,XREAL_1:17;
      then k2+1 <= k by A8,NAT_1:13;
      then
A16:  k2+1 <= len W1 by A6,XXREAL_0:2;
A17:  len W4 = k2 by A15,Lm22;
A18:  now
        assume
A19:    e in W5.edges();
        W5.edges() c= W4.edges() by Th164;
        then consider n being even Element of NAT such that
A20:    1 <= n & n <= len W4 & W4.n = e by A19,Lm46;
        n in dom W4 by A20,FINSEQ_3:27;
        then
A21:    e = W3.n by A9,A20,Lm23;
        n <= k2+2 by A17,A20,NAT_1:12;
        then n in dom W3 by A8,A20,FINSEQ_3:27;
        then
A22:    W1.(k2+1) = W1.n by A6,A13,A21,Lm23;
        n < k2+1 by A17,A20,NAT_1:13;
        hence contradiction by A16,A20,A22,Lm57;
      end;
A23:  now
        assume
A24:    W5 is non trivial & W5 is closed;
        then
A25:    W5.first() = W1.k2 by A14,Def24;
        1 <= len W3 by HEYTING3:1;
        then 2*0+1 in dom W3 by FINSEQ_3:27;
        then
A26:    W1.k2 = W1.(len W1) by A4,A6,A12,A13,A25,Lm23;
        now
          assume k2 = 1;
          then len W4 = 1 by A9,Lm22;
          then 1 <= len W5 & len W5 <= 1 by Lm72,HEYTING3:1;
          then len W5 = 1 by XXREAL_0:1;
          hence contradiction by A24,Lm55;
        end;
        then
A27:    1 < k2 by A10,XXREAL_0:1;
A28:    k2 < k - 0 by XREAL_1:17;
        then k2 <= len W1 by A6,XXREAL_0:2;
        hence contradiction by A6,A26,A27,A28;
      end;
      now
        let m be odd Element of NAT;
        assume
A29:    1 < m & m <= len W5;
        then consider n being odd Element of NAT such that
A30:    m <= n & n <= len W4 & W5.m = W4.n by Th165;
A31:    1 < n by A29,A30,XXREAL_0:2;
        then n in dom W4 by A30,FINSEQ_3:27;
        then
A32:    W5.m = W3.n by A9,A30,Lm23;
A33:    n+0 < k2+2 by A17,A30,XREAL_1:10;
        then n in dom W3 by A8,A31,FINSEQ_3:27;
        then
A34:    W5.m = W1.n by A6,A13,A32,Lm23;
        n <= len W1 by A6,A33,XXREAL_0:2;
        hence W5.m <> W1.k by A6,A31,A33,A34;
      end;
      then reconsider W2 as Path of G by A7,A14,A18,A23,Th151;
      1 <= len W3 by HEYTING3:1;
      then 2*0+1 in dom W3 by FINSEQ_3:27;
      then
A35:  W5.first() = W1.first() by A6,A12,A13,Lm23;
A36:  k2 in dom W3 by A10,A15,FINSEQ_3:27;
      then
A37:  W5.last() = W1.k2 by A6,A12,A13,Lm23;
      then W5 is_Walk_from W1.first(), W1.k2 by A35,Def23;
      then
A38:  W2 is_Walk_from W1.first(), W1.last() by A6,A7,Lm39;
      consider es5 being Subset of W4.edgeSeq() such that
A39:  W5.edgeSeq() = Seq es5 by Def32;
A40:  W4.edgeSeq() c= W3.edgeSeq() by Lm43;
      W3.edgeSeq() c= W1.edgeSeq() by A13,Lm43;
      then W4.edgeSeq() c= W1.edgeSeq() by A40,XBOOLE_1:1;
      then reconsider es5 as Subset of W1.edgeSeq() by XBOOLE_1:1;
      set g = ((k2+1) div 2) .--> e, es = es5 +* g;
A41:  dom es = dom es5 \/ dom g & for x st x in dom es5 \/ dom g
      holds (x in dom g implies es.x = g.x) &
      (not x in dom g implies es.x = es5.x) by FUNCT_4:def 1;
A42:  dom g = {(k2+1) div 2} & rng g = {e} by FUNCOP_1:14,19;
A43:  g.((k2+1) div 2) = e by FUNCOP_1:87;
A44:  now
        let z be set;
        assume
A45:    z in es;
        then consider x,y being set such that
A46:    z = [x,y] by RELAT_1:def 1;
A47:    x in dom es & y = es.x by A45,A46,FUNCT_1:8;
        now per cases;
          suppose
A48:        x in dom g;
            then
A49:        x = (k2+1) div 2 by A42,TARSKI:def 1;
            1 <= k2+1 by NAT_1:12;
            then
A50:        x in dom W1.edgeSeq() & W1.(k2+1) = W1.edgeSeq().x
            by A16,A49,Lm40;
            then W1.edgeSeq().x = y by A41,A43,A47,A48,A49;
            hence z in W1.edgeSeq() by A46,A50,FUNCT_1:8;
          end;
          suppose
A51:        not x in dom g;
            then
A52:        x in dom es5 by A41,A47,XBOOLE_0:def 3;
            y = es5.x by A41,A47,A51;
            then z in es5 by A46,A52,FUNCT_1:8;
            hence z in W1.edgeSeq();
          end;
        end;
        hence z in W1.edgeSeq();
      end;
      then es c= W1.edgeSeq() by TARSKI:def 3;
      then dom es c= dom W1.edgeSeq() by RELAT_1:25;
      then
A53:  dom es c= Seg len W1.edgeSeq() by FINSEQ_1:def 3;
      then reconsider es as FinSubsequence by FINSEQ_1:def 12;
      reconsider es as Subset of W1.edgeSeq() by A44,TARSKI:def 3;
A54:  dom es5 c= dom W4.edgeSeq() by GRAPH_2:27;
      now thus dom es5 c= Seg len W1.edgeSeq() &
        dom g c= Seg len W1.edgeSeq() by A41,A53,XBOOLE_1:11;
        let x,y be Element of NAT such that
A55:    x in dom es5 & y in dom g;
A56:    y = (k2+1) div 2 by A42,A55,TARSKI:def 1;
        2 divides k2+1 by PEPIN:22;
        then
A57:    2*y = k2+1 by A56,NAT_D:3;
        x <= len W4.edgeSeq() by A54,A55,FINSEQ_3:27;
        then 2*x <= 2*len W4.edgeSeq() by XREAL_1:66;
        then 2*x+1 <= 2*len W4.edgeSeq()+1 by XREAL_1:9;
        then 2*x+1 <= k2 by A17,Def15;
        then 2*x+1 < 2*y by A57,NAT_1:13;
        then
A58:    2*x+1-1 < 2*y - 0 by XREAL_1:16;
        then x <= y by XREAL_1:70;
        hence x < y by A58,XXREAL_0:1;
      end;
      then
A59:  Sgm(dom es) = Sgm(dom es5) ^ Sgm(dom g) by A41,FINSEQ_3:48;
      now
A60:    e Joins W5.last(), W1.k, G by A6,A7,A12,A13,A36,Lm23;
        len W2 = len W5 + 2 by A7,A37,Lm37;
        then
A61:    len W5 + 2 = 2 * len W2.edgeSeq() + 1 by Def15;
A62:    len Seq es = card es by Th5
          .= card dom es by PRE_CIRC:21;
        now
          assume dom es5 /\ dom g <> {};
          then consider x being set such that
A63:      x in dom es5 /\ dom g by XBOOLE_0:def 1;
A64:      x in dom es5 & x in dom g by A63,XBOOLE_0:def 4;
          then x = (k2+1) div 2 by A42,TARSKI:def 1;
          then (k2+1) div 2 <= len W4.edgeSeq() by A54,A64,FINSEQ_3:27;
          then
A65:      2 * ((k2+1) div 2) <= 2*len W4.edgeSeq() by XREAL_1:66;
          2 divides (k2+1) by PEPIN:22;
          then k2+1 <= 2*len W4.edgeSeq() by A65,NAT_D:3;
          then k2+1+1 <= 2*len W4.edgeSeq()+1 by XREAL_1:9;
          then (1+1)+k2 <= 0 + k2 by A17,Def15;
          hence contradiction by XREAL_1:8;
        end;
        then
A66:    dom es5 misses dom g by XBOOLE_0:def 7;
        then len Seq es = card dom es5 + card dom g by A41,A62,CARD_2:53
          .= card dom es5 + 1 by A42,CARD_1:50
          .= card es5 + 1 by PRE_CIRC:21
          .= len W5.edgeSeq() + 1 by A39,Th5;
        then
A67:    2 * len Seq es + 1 = 2*len W5.edgeSeq() + 1 + 2
          .= 2 * len W2.edgeSeq() + 1 by A61,Def15;
        hence len W2.edgeSeq() = len Seq es;
        let x be Nat;
        assume
A68:    1 <= x & x <= len W2.edgeSeq();
        set h = Sgm dom es;
A69:    Seq es = es * h by FINSEQ_1:def 14;
A70:    x in dom (Seq es) by A67,A68,FINSEQ_3:27;
        then
A71:    x in dom h & h.x in dom es by A69,FUNCT_1:21;
A72:    (Seq es).x = es.(h.x) by A69,A70,FUNCT_1:22;
A73:    dom h = Seg (len Sgm(dom es5) + len (Sgm dom g)) &
        (for x being Element of NAT st x in dom Sgm dom es5 holds
        h.x = Sgm(dom es5).x) &
        (for x being Element of NAT st x in dom Sgm dom g holds
        h.(len Sgm(dom es5) + x) = (Sgm dom g).x) by A59,FINSEQ_1:def 7;
A74:    Sgm dom g = Sgm {(k2+1) div 2} by FUNCOP_1:19;
        now
          assume k2+1 div 2 = 0;
          then
A75:      2 * ((k2+1) div 2) = 2*0;
          2 divides k2+1 by PEPIN:22;
          hence contradiction by A75,NAT_D:3;
        end;
        then Sgm dom g = <* (k2+1) div 2 *> by A74,FINSEQ_3:50;
        then
A76:    len Sgm dom g = 1 & (Sgm dom g).1 = (k2+1) div 2 by FINSEQ_1:57;
A77:    dom es5 c=Seg len W1.edgeSeq() by A41,A53,XBOOLE_1:11;
        then
A78:    len Sgm(dom es5) = card dom es5 by FINSEQ_3:44
          .= card es5 by PRE_CIRC:21
          .= len W5.edgeSeq() by A39,Th5;
        now per cases;
          suppose
A79:        x <= len Sgm (dom es5);
            then
A80:        x in dom Sgm dom es5 by A68,FINSEQ_3:27;
            then
A81:        h.x = Sgm(dom es5).x by A59,FINSEQ_1:def 7;
            rng Sgm(dom es5) = dom es5 by A77,FINSEQ_1:def 13;
            then h.x in dom es5 by A80,A81,FUNCT_1:def 5;
            then not h.x in dom g by A66,XBOOLE_0:3;
            then
A82:        (Seq es).x = es5.(Sgm(dom es5).x) by A41,A71,A72,A81;
A83:        W5.edgeSeq().x = W5.(2*x) by A68,A78,A79,Def15;
A84:        x in dom W5.edgeSeq() by A68,A78,A79,FINSEQ_3:27;
            then 2*x in dom W5 by Lm41;
            then
A85:        W2.(2*x) = W5.edgeSeq().x by A60,A83,Lm38
              .= (es5 * Sgm(dom es5)).x by A39,FINSEQ_1:def 14;
            x in dom (es5 * Sgm(dom es5)) by A39,A84,FINSEQ_1:def 14;
            hence (Seq es).x = W2.(2*x) by A82,A85,FUNCT_1:22;
          end;
          suppose len Sgm (dom es5) < x;
            then
A86:        len Sgm(dom es5) + 1 <= x by NAT_1:13;
            x <= len Sgm(dom es5) + 1 by A71,A73,A76,FINSEQ_1:3;
            then
A87:        x = len Sgm(dom es5) + 1 by A86,XXREAL_0:1;
            1 in dom Sgm(dom g) by A76,FINSEQ_3:27;
            then
A88:        h.x = (k2+1) div 2 by A59,A76,A87,FINSEQ_1:def 7;
            then h.x in dom g by A42,TARSKI:def 1;
            then
A89:        (Seq es).x = g.((k2+1) div 2) by A41,A71,A72,A88
              .= e by FUNCOP_1:87
              .= W2.(len W5 + 1) by A60,Lm38;
            2*x = 2*len W5.edgeSeq()+1+1 by A78,A87
              .= len W5 + 1 by Def15;
            hence (Seq es).x = W2.(2*x) by A89;
          end;
        end;
        hence W2.edgeSeq().x = (Seq es).x by A68,Def15;
      end;
      then W2.edgeSeq() = Seq es by FINSEQ_1:18;
      then reconsider W2 as Path of W1 by A38,Def32;
      take W2;
      thus W2 is non trivial by A7,A14,Th133;
    end;
  end;
  hence thesis;
end;

theorem Th168: ::tSUBGRAPH_W01
  for G1 being _Graph, G2 being Subgraph of G1, W being Walk of G2 holds
  W is Walk of G1
proof
  let G1 be _Graph, G2 be Subgraph of G1, W be Walk of G2;
  set VG1 = the_Vertices_of G1, VG2 = the_Vertices_of G2;
  set EG1 = the_Edges_of G1, EG2 = the_Edges_of G2;
  VG2 c= VG1 \/ EG1 & EG2 c= VG1 \/ EG1 by XBOOLE_1:10;
  then VG2 \/ EG2 c= VG1 \/ EG1 by XBOOLE_1:8;
  then for y being set st y in rng W holds y in VG1 \/ EG1 by TARSKI:def 3;
  then rng W c= VG1 \/ EG1 by TARSKI:def 3;
  then
A1: W is FinSequence of VG1 \/ EG1 by FINSEQ_1:def 4;
  now thus len W is odd;
    W.1 in VG2 by Def3;
    hence W.1 in VG1;
    let n be odd Element of NAT;
    assume n < len W;
    then W.(n+1) Joins W.n, W.(n+2), G2 by Def3;
    hence W.(n+1) Joins W.n, W.(n+2), G1 by GLIB_000:75;
  end;
  hence W is Walk of G1 by A1,Def3;
end;

theorem Th169: ::tSUBGRAPH_W02
  for G1 being _Graph, G2 being Subgraph of G1, W being Walk of G1
  st W is trivial & W.first() in the_Vertices_of G2 holds W is Walk of G2
proof
  let G1 be _Graph, G2 be Subgraph of G1, W be Walk of G1;
  assume
A1: W is trivial & W.first() in the_Vertices_of G2;
  then consider v being Vertex of G1 such that
A2: W = G1.walkOf(v) by Lm56;
  reconsider v'= v as Vertex of G2 by A1,A2,Th14;
  W = G2.walkOf(v') by A2;
  hence W is Walk of G2;
end;

theorem Th170: ::tSUBGRAPH_W03
  for G1 being _Graph, G2 being Subgraph of G1, W being Walk of G1
  st W is non trivial & W.edges() c= the_Edges_of G2 holds W is Walk of G2
proof
  let G1 be _Graph, G2 be Subgraph of G1, W be Walk of G1;
  assume
A1: W is non trivial & W.edges() c= the_Edges_of G2;
  set WV = W.vertices(), WE = W.edges();
  set VG2 = the_Vertices_of G2, EG2 = the_Edges_of G2;
A2: now
    let n be odd Element of NAT such that
A3: n <= len W;
    now per cases;
      suppose
A4:     n = len W;
        then
A5:     n <> 1 by A1,Lm54;
        1 <= n by HEYTING3:1;
        then 1 < n by A5,XXREAL_0:1;
        then 1+1 <= n by NAT_1:13;
        then reconsider n5 = n-2*1 as odd Element of NAT by INT_1:18;
        n5 < len W - 0 by A4,XREAL_1:17;
        then
A6:     W.(n5+1) Joins W.n5, W.(n5+2), G1 by Def3;
A7:     1 <= n5+1 by NAT_1:12;
        n5+1 = n-(2-1);
        then n5+1 <= len W-0 by A4,XREAL_1:15;
        then W.(n5+1) in W.edges() by A7,Lm46;
        then W.(n5+1) Joins W.n5, W.(n5+2), G2 by A1,A6,GLIB_000:76;
        hence W.n in the_Vertices_of G2 by GLIB_000:16;
      end;
      suppose n <> len W;
        then
A8:     n < len W by A3,XXREAL_0:1;
        then
A9:     W.(n+1) Joins W.n, W.(n+2), G1 by Def3;
A10:    1 <= n+1 by NAT_1:12;
        n+1 <= len W by A8,NAT_1:13;
        then W.(n+1) in W.edges() by A10,Lm46;
        then W.(n+1) Joins W.n, W.(n+2), G2 by A1,A9,GLIB_000:76;
        hence W.n in the_Vertices_of G2 by GLIB_000:16;
      end;
    end;
    hence W.n in VG2;
  end;
  now
    let y be set;
    assume y in rng W;
    then
A11: y in WV \/ WE by Th102;
    now per cases by A11,XBOOLE_0:def 3;
      suppose y in WV;
        then consider n being odd Element of NAT such that
A12:    n <= len W & W.n = y by Lm45;
        y in VG2 by A2,A12;
        hence y in VG2 \/ EG2 by XBOOLE_0:def 3;
      end;
      suppose y in WE;
        hence y in VG2 \/ EG2 by A1,XBOOLE_0:def 3;
      end;
    end;
    hence y in VG2 \/ EG2;
  end;
  then rng W c= VG2 \/ EG2 by TARSKI:def 3;
  then
A13: W is FinSequence of VG2 \/ EG2 by FINSEQ_1:def 4;
  now thus len W is odd;
    reconsider aa1 = 1 as odd Element of NAT by JORDAN12:3;
    aa1 <= len W by HEYTING3:1;
    hence W.1 in VG2 by A2;
    let n be odd Element of NAT;
    assume
A14: n < len W;
    then
A15: W.(n+1) Joins W.n, W.(n+2), G1 by Def3;
    1 <= n+1 & n+1 <= len W by A14,NAT_1:12,13;
    then W.(n+1) in W.edges() by Lm46;
    hence W.(n+1) Joins W.n, W.(n+2), G2 by A1,A15,GLIB_000:76;
  end;
  hence W is Walk of G2 by A13,Def3;
end;

theorem Th171: ::tSUBGRAPH_W04
  for G1 being _Graph, G2 being Subgraph of G1, W being Walk of G1
  st W.vertices() c= the_Vertices_of G2 & W.edges() c= the_Edges_of G2
  holds W is Walk of G2
proof
  let G1 be _Graph, G2 be Subgraph of G1, W be Walk of G1;
  assume
A1: W.vertices() c= the_Vertices_of G2 & W.edges() c= the_Edges_of G2;
  now per cases;
    suppose W is non trivial;
      hence thesis by A1,Th170;
    end;
    suppose
A2:   W is trivial;
      W.first() in W.vertices() by Th89;
      hence thesis by A1,A2,Th169;
    end;
  end;
  hence thesis;
end;

theorem ::tSUBGRAPH_W05
  for G1 being non trivial _Graph, W being Walk of G1, v being Vertex of G1,
  G2 being removeVertex of G1,v st not v in W.vertices() holds W is Walk of G2
proof
  let G1 be non trivial _Graph, W be Walk of G1, v be Vertex of G1,
  G2 be removeVertex of G1,v;
  assume
A1: not v in W.vertices();
  set W2 = W, VG2 = (the_Vertices_of G1) \ {v};
  set EG2 = (the_Edges_of G1) \ v.edgesInOut();
  v.edgesInOut() = G1.edgesInOut({v}) by GLIB_000:def 42;
  then
A2: EG2 = G1.edgesBetween( the_Vertices_of G1 \ {v}) by GLIB_000:38;
  now
    let y be set;
    assume y in rng W2;
    then consider x being set such that
A3: x in dom W2 & y = W2.x by FUNCT_1:def 5;
    reconsider x as Element of NAT by A3;
A4: 1 <= x & x <= len W2 by A3,FINSEQ_3:27;
    now per cases;
      suppose
A5:     x is odd;
        then
A6:     y in the_Vertices_of G1 by A3,A4,Lm1;
        now
          assume y in {v};
          then not y in W.vertices() by A1,TARSKI:def 1;
          hence contradiction by A3,A4,A5,Lm45;
        end;
        then y in VG2 by A6,XBOOLE_0:def 5;
        hence y in VG2 \/ EG2 by XBOOLE_0:def 3;
      end;
      suppose x is even;
        then reconsider x as even Element of NAT;
        consider xaa1 being odd Element of NAT such that
A7:     xaa1 = x-1 & x-1 in dom W2 & x+1 in dom W2 &
        W2.x Joins W2.(xaa1), W2.(x+1),G1 by A3,Lm2;
A8:     y in the_Edges_of G1 by A3,A7,GLIB_000:def 15;
A9:     xaa1 <= len W2 & x+1 <= len W2 by A7,FINSEQ_3:27;
        now
          assume y in v.edgesInOut();
          then
A10:      y in v.edgesIn() \/ v.edgesOut() by GLIB_000:63;
          now per cases by A10,XBOOLE_0:def 3;
            suppose y in v.edgesIn();
              then (the_Target_of G1).y = v by GLIB_000:59;
              hence v=W2.(xaa1) or v = W2.(x+1) by A3,A7,GLIB_000:def 15;
            end;
            suppose y in v.edgesOut();
              then (the_Source_of G1).y = v by GLIB_000:61;
              hence v=W2.(xaa1) or v = W2.(x+1) by A3,A7,GLIB_000:def 15;
            end;
          end;
          then v = W2.vertexAt(xaa1) or v = W2.vertexAt(x+1) by A9,Def8;
          hence contradiction by A1,A9,Th90;
        end;
        then y in EG2 by A8,XBOOLE_0:def 5;
        hence y in VG2 \/ EG2 by XBOOLE_0:def 3;
      end;
    end;
    then y in (the_Vertices_of G2) \/ EG2 by GLIB_000:50;
    hence y in (the_Vertices_of G2) \/ (the_Edges_of G2) by A2,GLIB_000:50;
  end;
  then rng W2 c= (the_Vertices_of G2) \/ (the_Edges_of G2) by TARSKI:def 3;
  then reconsider W2 as FinSequence of (the_Vertices_of G2)\/(the_Edges_of G2
  ) by FINSEQ_1:def 4;
  now thus len W2 is odd;
A11: W.first() in the_Vertices_of G1;
    W.first() in W.vertices() by Th89;
    then not W2.1 in {v} by A1,TARSKI:def 1;
    then W2.1 in VG2 by A11,XBOOLE_0:def 5;
    hence W2.1 in the_Vertices_of G2 by GLIB_000:50;
    let n be odd Element of NAT;
    assume
A12: n < len W2;
    then
A13: W.(n+1) Joins W.n, W.(n+2), G1 by Def3;
A14: W.n <> v by A1,A12,Lm45;
    reconsider lenW2 = len W2 as odd Element of NAT;
    n+1 <= len W2 by A12,NAT_1:13;
    then n+1 < lenW2 by XXREAL_0:1;
    then n+1+1 <= len W2 by NAT_1:13;
    then
A15: W.(n+2) <> v by A1,Lm45;
A16: W.(n+1) in the_Edges_of G1 by A13,GLIB_000:def 15;
    not W.(n+1) in v.edgesInOut() by A13,A14,A15,GLIB_000:68;
    then W.(n+1) in EG2 by A16,XBOOLE_0:def 5;
    then W.(n+1) in the_Edges_of G2 by A2,GLIB_000:50;
    hence W.(n+1) Joins W.n, W.(n+2), G2 by A13,GLIB_000:76;
  end;
  hence W is Walk of G2 by Def3;
end;

theorem ::tSUBGRAPH_W06
  for G1 being _Graph, W being Walk of G1, e being set,
  G2 being removeEdge of G1,e st not e in W.edges() holds W is Walk of G2
proof
  let G1 be _Graph, W be Walk of G1, e be set, G2 be removeEdge of G1,e;
  assume
A1: not e in W.edges();
A2: the_Vertices_of G2 = the_Vertices_of G1 &
  the_Edges_of G2 = (the_Edges_of G1) \ {e} by GLIB_000:56;
  then
A3: W.vertices() c= the_Vertices_of G2;
  now
    let x be set;
    assume
A4: x in W.edges();
    then not x in {e} by A1,TARSKI:def 1;
    hence x in the_Edges_of G2 by A2,A4,XBOOLE_0:def 5;
  end;
  then W.edges() c= the_Edges_of G2 by TARSKI:def 3;
  hence thesis by A3,Th171;
end;

theorem Th174: ::tSUBGRAPH_WF01
  for G1 being _Graph, G2 being Subgraph of G1, x,y,e being set
  st e Joins x,y,G2 holds G1.walkOf(x, e, y) = G2.walkOf(x, e, y)
proof
  let G1 be _Graph, G2 be Subgraph of G1, x, y, e be set;
  assume
A1: e Joins x,y,G2;
  then
A2: G2.walkOf(x,e,y) = <*x,e,y*> by Def5;
  e Joins x,y,G1 by A1,GLIB_000:75;
  hence G1.walkOf(x,e,y) = G2.walkOf(x,e,y) by A2,Def5;
end;

theorem ::tSUBGRAPH_WF02
  for G1 being _Graph, G2 being Subgraph of G1, W1 being Walk of G1,
  W2 being Walk of G2, e being set st W1 = W2 & e in W2.last().edgesInOut()
  holds W1.addEdge(e) = W2.addEdge(e)
proof
  let G1 be _Graph, G2 be Subgraph of G1, W1 be Walk of G1,
  W2 be Walk of G2, e be set;
  assume
A1: W1 = W2 & e in W2.last().edgesInOut();
  then
A2: e Joins W2.last(),W2.last().adj(e),G2 by GLIB_000:70;
  set W1B = G1.walkOf(W1.last(), e, W1.last().adj(e));
  set W2B = G2.walkOf(W2.last(), e, W2.last().adj(e));
  W1.last().adj(e) = W2.last().adj(e) by A1,GLIB_000:83;
  then W1B = W2B by A1,A2,Th174;
  hence W1.addEdge(e) = W2.addEdge(e) by A1,Th36;
end;

theorem Th176: ::tSUBGRAPH_WA01
  for G1 being _Graph, G2 being Subgraph of G1, W being Walk of G2 holds
  (W is closed implies W is closed Walk of G1) &
  (W is directed implies W is directed Walk of G1) &
  (W is trivial implies W is trivial Walk of G1) &
  (W is Trail-like implies W is Trail-like Walk of G1) &
  (W is Path-like implies W is Path-like Walk of G1) &
  (W is vertex-distinct implies W is vertex-distinct Walk of G1)
proof
  let G1 be _Graph, G2 be Subgraph of G1, W be Walk of G2;
  reconsider W'=W as Walk of G1 by Th168;
  hereby
    assume W is closed;
    then W.first() = W.last() by Def24;
    then W'.first() = W'.last();
    hence W is closed Walk of G1 by Def24;
  end;
  hereby
    assume
A1: W is directed;
    now
      let n be odd Element of NAT;
      assume
A2:   n < len W';
      then
A3:   (the_Source_of G2).(W'.(n+1)) = W'.n by A1,Def25;
A4:   1 <= n+1 by NAT_1:12;
      n+1 <= len W' by A2,NAT_1:13;
      then n+1 in dom W' by A4,FINSEQ_3:27;
      then W'.(n+1) in the_Edges_of G2 by Th9;
      hence (the_Source_of G1).(W'.(n+1)) = W'.n by A3,GLIB_000:def 34;
    end;
    hence W is directed Walk of G1 by Def25;
  end;
  hereby
    assume W is trivial;
    then len W' = 1 by Lm55;
    hence W is trivial Walk of G1 by Lm54;
  end;
A5: now
    assume W is Trail-like;
    then for m,n being even Element of NAT st 1 <= m & m < n & n <= len W
    holds W'.m <> W'.n by Lm57;
    hence W is Trail-like Walk of G1 by Lm57;
  end;
  hence W is Trail-like implies W is Trail-like Walk of G1;
  now
    assume W is Path-like;
    then W' is Trail-like &
    for m,n being odd Element of NAT st m < n & n <= len W'
    holds W'.m = W'.n implies (m=1 & n = len W') by A5,Def28;
    hence W is Path-like Walk of G1 by Def28;
  end;
  hence W is Path-like implies W is Path-like Walk of G1;
  hereby
    assume W is vertex-distinct;
    then for m,n being odd Element of NAT
    st m <= len W' & n <= len W' & W'.m = W'.n holds m = n by Def29;
    hence W is vertex-distinct Walk of G1 by Def29;
  end;
  thus thesis;
end;

theorem Th177: ::tSUBGRAPH_WA02
  for G1 being _Graph, G2 being Subgraph of G1, W1 being Walk of G1,
  W2 being Walk of G2 st W1 = W2 holds (W1 is closed iff W2 is closed) &
  (W1 is directed iff W2 is directed) & (W1 is trivial iff W2 is trivial) &
  (W1 is Trail-like iff W2 is Trail-like) &
  (W1 is Path-like iff W2 is Path-like) &
  (W1 is vertex-distinct iff W2 is vertex-distinct)
proof
  let G1 be _Graph, G2 be Subgraph of G1, W1 be Walk of G1, W2 be Walk of G2;
  assume
A1: W1 = W2;
A2: W1 is closed iff W1.first() = W1.last() by Def24;
  W1.first() = W2.first() & W1.last() = W2.last() by A1;
  hence W1 is closed iff W2 is closed by A2,Def24;
  now
    hereby
      assume
A3:   W1 is directed;
      now
        let n be odd Element of NAT;
        assume
A4:     n < len W2;
        then 1 <= n+1 & n+1 <= len W2 by NAT_1:12,13;
        then n+1 in dom W2 by FINSEQ_3:27;
        then W2.(n+1) in the_Edges_of G2 by Th9;
        then (the_Source_of G2).(W2.(n+1)) = (the_Source_of G1).(W2.(n +1))
        by GLIB_000:def 34;
        hence (the_Source_of G2).(W2.(n+1)) = W2.n by A1,A3,A4,Def25;
      end;
      hence W2 is directed by Def25;
    end;
    assume W2 is directed;
    hence W1 is directed Walk of G1 by A1,Th176;
  end;
  hence W1 is directed iff W2 is directed;
  W1 is trivial iff len W2 = 1 by A1,Lm55;
  hence W1 is trivial iff W2 is trivial by Lm55;
  W1 is Trail-like iff for m,n being even Element of NAT
  st 1 <= m & m < n & n <= len W2 holds W2.m <> W2.n by A1,Lm57;
  hence
A5: W1 is Trail-like iff W2 is Trail-like by Lm57;
  W1 is Path-like iff (W1 is Trail-like & for m,n being odd Element of NAT
  st m < n & n <= len W2 holds W2.m = W2.n implies (m = 1 & n = len W2))
  by A1,Def28;
  hence W1 is Path-like iff W2 is Path-like by A5,Def28;
  W1 is vertex-distinct iff (for m,n being odd Element of NAT
  st m <= len W2 & n <= len W2 & W2.m = W2.n holds m = n) by A1,Def29;
  hence W1 is vertex-distinct iff W2 is vertex-distinct by Def29;
end;

theorem ::tGPEQ_VSEQ01
  G1 == G2 & x is VertexSeq of G1 implies x is VertexSeq of G2
proof
  assume
A1: G1 == G2 & x is VertexSeq of G1;
  then reconsider x2 = x as FinSequence of the_Vertices_of G2
  by GLIB_000:def 36;
  now
    let n be Element of NAT;
    assume 1 <= n & n < len x2;
    then consider e being set such that
A2: e Joins x2.n, x2.(n+1), G1 by A1,Def1;
    e Joins x2.n, x2.(n+1), G2 by A1,A2,GLIB_000:91;
    hence ex e being set st e Joins x2.n, x2.(n+1), G2;
  end;
  hence thesis by Def1;
end;

theorem ::tGPEQ_ESEQ01
  G1 == G2 & x is EdgeSeq of G1 implies x is EdgeSeq of G2
proof
  assume
A1: G1 == G2 & x is EdgeSeq of G1;
  then reconsider es = x as EdgeSeq of G1;
  consider vs being FinSequence of the_Vertices_of G1 such that
A2: len vs = len es + 1 & for n being Element of NAT st 1 <= n & n <= len es
  holds es.n Joins vs.n,vs.(n+1),G1 by Def2;
  reconsider es2 = es as FinSequence of the_Edges_of G2 by A1,GLIB_000:def 36;
  now reconsider vs as FinSequence of the_Vertices_of G2
    by A1,GLIB_000:def 36;
    take vs;
    thus len vs = len es + 1 by A2;
    let n be Element of NAT;
    assume 1 <= n & n <= len es2;
    then es2.n Joins vs.n,vs.(n+1),G1 by A2;
    hence es2.n Joins vs.n,vs.(n+1),G2 by A1,GLIB_000:91;
  end;
  hence thesis by Def2;
end;

theorem ::tGPEQ_WALK01
  G1 == G2 & x is Walk of G1 implies x is Walk of G2
proof
  assume
A1: G1 == G2 & x is Walk of G1;
  then
A2: the_Vertices_of G1 = the_Vertices_of G2 &
  the_Edges_of G2 = the_Edges_of G1 by GLIB_000:def 36;
  then reconsider W = x as FinSequence of the_Vertices_of G2 \/ the_Edges_of
  G2 by A1;
A3: len W is odd & W.1 in the_Vertices_of G2 by A1,A2,Def3;
  now
    let n be odd Element of NAT;
    assume n < len W;
    then W.(n+1) Joins W.n, W.(n+2), G1 by A1,Def3;
    hence W.(n+1) Joins W.n, W.(n+2), G2 by A1,GLIB_000:91;
  end;
  hence thesis by A3,Def3;
end;

theorem ::tGPEQ_WF01
  G1 == G2 implies G1.walkOf(x,e,y) = G2.walkOf(x,e,y)
proof
  assume
A1: G1 == G2;
  now per cases;
    suppose
A2:   e Joins x,y,G1;
      then
A3:   e Joins x,y,G2 by A1,GLIB_000:91;
      thus G1.walkOf(x,e,y) = <*x,e,y*> by A2,Def5
        .= G2.walkOf(x,e,y) by A3,Def5;
    end;
    suppose
A4:   not e Joins x,y,G1;
      then
A5:   not e Joins x,y,G2 by A1,GLIB_000:91;
      thus G1.walkOf(x,e,y) = G1.walkOf(choose the_Vertices_of G1) by A4,Def5
        .= G2.walkOf(choose the_Vertices_of G2) by A1,GLIB_000:def 36
        .= G2.walkOf(x,e,y) by A5,Def5;
    end;
  end;
  hence thesis;
end;

theorem ::tGPEQ_WA01
  for W1 being Walk of G1, W2 being Walk of G2 st G1 == G2 & W1 = W2 holds
  (W1 is closed iff W2 is closed) & (W1 is directed iff W2 is directed) &
  (W1 is trivial iff W2 is trivial) &
  (W1 is Trail-like iff W2 is Trail-like) &
  (W1 is Path-like iff W2 is Path-like) &
  (W1 is vertex-distinct iff W2 is vertex-distinct)
proof
  let W1 be Walk of G1, W2 be Walk of G2;
  assume
A1: G1 == G2 & W1 = W2;
  then G1 is Subgraph of G2 by GLIB_000:90;
  hence thesis by A1,Th177;
end;

