:: Walks in a Graph
::  by Gilbert Lee
::
:: Received February 22, 2005
:: Copyright (c) 2005 Association of Mizar Users

environ

 vocabularies ARYTM, ARYTM_1, ARYTM_3, BOOLE, CARD_1, CAT_1, FINSEQ_1,
      FINSEQ_5, FINSET_1, FUNCT_1, FUNCT_4, GRAPH_1, GRAPH_2, GLIB_000,
      GLIB_001, MATRIX_2, MCART_1, MSAFREE2, NAT_1, NEWTON, PRE_TOPC, QUANTAL1,
      REALSET1, RELAT_1, TOPGEN_1;
 notations TARSKI, XBOOLE_0, NUMBERS, SUBSET_1, XCMPLX_0, XXREAL_0, XREAL_0,
      DOMAIN_1, RELAT_1, FUNCT_1, FINSEQ_1, FINSEQ_2, CARD_1, GRAPH_2,
      FINSEQ_5, ORDINAL1, RELSET_1, MCART_1, FINSET_1, NAT_1, NAT_D, FUNCOP_1,
      FUNCT_4, GLIB_000, ABIAN;
 constructors DOMAIN_1, FUNCT_4, XXREAL_0, NAT_1, INT_1, BINOP_2, RECDEF_1,
      FUNCOP_1, REALSET1, FINSEQ_5, ABIAN, GRAPH_2, GLIB_000, WELLORD2, NAT_D;
 registrations SUBSET_1, RELSET_1, FINSET_1, XREAL_0, PNPROC_1, INT_1, ABIAN,
      FINSEQ_1, GRAPH_3, NAT_1, FUNCT_1, XBOOLE_0, RELAT_1, NUMBERS, ORDINAL1,
      GLIB_000, XXREAL_0, FUNCOP_1, HEYTING3, NAT_3;
 definitions FUNCOP_1;
 requirements ARITHM, BOOLE, NUMERALS, REAL, SUBSET;
 theorems CARD_1, CARD_2, FUNCOP_1, ENUMSET1, FINSEQ_1, FINSEQ_2, FINSEQ_3,
      FINSEQ_4, FINSEQ_5, FINSEQ_6, FINSET_1, FUNCT_1, FUNCT_4, GLIB_000,
      GRAPH_2, GRAPH_5, INT_1, JORDAN12, MCART_1, NAT_1, NAT_2, PEPIN, REAL_1,
      RELAT_1, SPPOL_1, TARSKI, XBOOLE_0, XBOOLE_1, XREAL_1, PRE_CIRC,
      XXREAL_0, HEYTING3, ORDINAL1, NAT_D;
 schemes BINARITH, FINSEQ_1, FUNCT_1, NAT_1, RECDEF_1;

begin :: Preliminaries

theorem Th1: ::tODD01
  for x,y being odd Element of NAT holds
    x < y iff x + 2 <= y proof
    let x,y be odd Element of NAT;
    hereby assume x < y; then
        x + 1 <= y by NAT_1:13; then
        x + 1 < y by REAL_1:def 5; then
        x + 1 + 1 < y + 1 by XREAL_1:10;
        hence x + 2 <= y by NAT_1:13;
    end;
    assume x + 2 <= y; then
    x + 2 - 2 < y - 0 by REAL_1:92;
    hence x < y;
end;

Lm1:
  for x, y, z being real number holds
    0 < z & x * z <= y * z implies x <= y by XREAL_1:70;

Lm2:
  for F being finite Function holds card (dom F) = card F by PRE_CIRC:21;

theorem Th2: ::tSGM01
  for X being set, k being Element of NAT st X c= Seg k holds
    (for m,n being Element of NAT st m in dom (Sgm X) & n = (Sgm X).m
       holds m <= n) proof
    let X be set, k be Element of NAT; assume
A1: X c= Seg k;
    let m, n be Element of NAT; assume
A2: m in dom (Sgm X) & n = (Sgm X).m;
    defpred P[Element of NAT] means ($1 in dom (Sgm X) &
    (ex n being Element of NAT st n=(Sgm X).$1 &
                          $1 <= n)) or (not $1 in dom (Sgm X));
    now 1 <= m & m <= len (Sgm X) by A2, FINSEQ_3:27; then
        1 <= len (Sgm X) by XXREAL_0:2;
        hence 1 in dom (Sgm X) by FINSEQ_3:27; then
    A3: (Sgm X).1 in rng (Sgm X) by FUNCT_1:12; set n = (Sgm X).1;
        reconsider n as Element of NAT by A3;
        take n;
        thus n = (Sgm X).1;
        rng (Sgm X) = X by A1, FINSEQ_1:def 13;
        hence 1 <= n by A1,A3,FINSEQ_1:3;
    end; then
A4: P[1];
    now let x be non empty Element of NAT; assume
    A5: P[x];
        now per cases by A5;
        suppose
        A6: x in dom (Sgm X) & ex n being Element of NAT
         st n = (Sgm X).x & x <= n; then
        A7: 1 <= x by FINSEQ_3:27;
        A8: x+0 < x+1 by XREAL_1:10;
            consider n being Element of NAT such that
        A9: n = Sgm(X).x & x <= n by A6;
            now assume
            A10: x+1 in dom (Sgm X);
                set n1 = (Sgm X).(x+1);
            A11: (Sgm X).(x+1) in rng (Sgm X) by A10, FUNCT_1:12;
                reconsider n1 as Element of NAT by A11;
                take n1;
                thus n1 = (Sgm X).(x+1);
                x+1 <= len Sgm X by A10, FINSEQ_3:27; then
                n < n1 by A1, A7, A8, A9, FINSEQ_1:def 13; then
                x < n1 by A9, XXREAL_0:2;
                hence x+1 <= n1 by NAT_1:13;
            end;
            hence P[x+1]; end;
        suppose not x in dom (Sgm X); then
            x < 0+1 or x > len Sgm X by FINSEQ_3:27; then
            x <= 0 or x > len Sgm X by NAT_1:13; then
            x+1 > len Sgm X + 0 by  XREAL_1:10;
            hence P[x+1] by FINSEQ_3:27; end;
        end;
        hence P[x+1];
    end; then
A12: for x being non empty Element of NAT st P[x] holds P[x+1];
A13: for x being non empty Element of NAT holds P[x]
from BINARITH:sch 1(A4,A12);
    m <> 0 by A2, FINSEQ_3:27;
    then reconsider m'=m as non empty Element of NAT;
    P[m'] by A13; then
    consider n' being Element of NAT such that
A14: n' = (Sgm X).m & m <= n' by A2;
    thus m <= n by A2, A14;
end;

theorem Th3: ::tFINSUBSEQ01
  for X being set, fs being FinSequence of X,
      fss being FinSubsequence of fs holds len (Seq fss) <= len fs proof
    let X be set, fs be FinSequence of X, fss be FinSubsequence of fs;
A1: fss c= fs by GRAPH_2:def 5;
    dom fss c= dom fs by GRAPH_2:27; then
A2: dom fss c= Seg len fs by FINSEQ_1:def 3;
A3: Seq fss = fss * Sgm(dom fss) by FINSEQ_1:def 14;
    rng (Sgm(dom fss)) = dom fss by A2, FINSEQ_1:def 13; then
    len (Seq fss) = len Sgm (dom fss) by A3, FINSEQ_2:33
                 .= card (dom fss) by A2, FINSEQ_3:44
                 .= card fss by Lm2;
    hence len (Seq fss) <= len fs by A1, CARD_1:80;
end;

theorem Th4: ::tFINSUBSEQ02
  for X being set, fs being FinSequence of X, fss being FinSubsequence of fs,
      m being Element of NAT st m in dom Seq fss holds
    ex n being Element of NAT st n in dom fs & m <= n & (Seq fss).m = fs.n
    proof
    let X be set, fs be FinSequence of X, fss be FinSubsequence of fs,
        m be Element of NAT;
A1: fss c= fs by GRAPH_2:def 5; set f = Sgm(dom fss), n = f.m;
A2: Seq fss = fss * f by FINSEQ_1:def 14; assume
A3: m in dom Seq fss; then
    m in dom (fss * f) by FINSEQ_1:def 14; then
A4: m in dom f & n in dom fss by FUNCT_1:21;
    (Seq fss).m = fss.n by A2,A3,FUNCT_1:22; then
    [n, Seq(fss).m] in fss by A4, FUNCT_1:def 4; then
A5: n in dom fs & (Seq fss).m = fs.n by A1, FUNCT_1:8; then
    reconsider n as Element of NAT;
    set X = dom fss;
    consider k being Element of NAT such that
A6: dom fss c= Seg k by FINSEQ_1:def 12;
    m <= n by A4, A6, Th2;
    hence thesis by A5;
end;

theorem Th5: ::tFINSUBSEQ03
  for X being set, fs being FinSequence of X, fss being FinSubsequence of fs
    holds len Seq fss = card fss proof
    let X be set, fs be FinSequence of X, fss be FinSubsequence of fs;
A1: Seq fss = fss * Sgm(dom fss) by FINSEQ_1:def 14;
    consider k being Element of NAT such that
A2: dom fss c= Seg k by FINSEQ_1:def 12;
    rng Sgm(dom fss) = dom fss by A2, FINSEQ_1:def 13; then
    dom (Seq fss) = dom (Sgm (dom fss)) by A1, RELAT_1:46; then
    dom (Seq fss) = Seg (card dom fss) by A2, FINSEQ_3:45; then
    len Seq fss = card dom fss by FINSEQ_1:def 3;
    hence len Seq fss = card fss by Lm2;
end;

theorem Th6: ::tFINSUBSEQ04
  for X being set, fs being FinSequence of X, fss being FinSubsequence of fs
    holds dom Seq fss = dom Sgm (dom fss) proof
    let X be set, fs be FinSequence of X, fss be FinSubsequence of fs;
    consider k being Element of NAT such that
A1: dom fss c= Seg k by FINSEQ_1:def 12;
A2: Seq fss = fss * Sgm (dom fss) by FINSEQ_1:def 14;
    rng Sgm(dom fss) c= dom fss by A1, FINSEQ_1:def 13;
    hence dom Seq fss = dom Sgm (dom fss) by A2, RELAT_1:46;
end;

begin :: Definitions

definition let G be _Graph;
  mode VertexSeq of G -> FinSequence of the_Vertices_of G means :Def1: ::dVSEQ
    for n being Element of NAT st 1 <= n & n < len it holds
      ex e being set st e Joins it.n, it.(n+1), G;
  existence proof
    set v = choose the_Vertices_of G, IT = <*v*>;
    reconsider IT as FinSequence of the_Vertices_of G;
    take IT;
    let n be Element of NAT; assume 1 <= n & n < len IT;
    hence thesis by FINSEQ_1:57;
  end;
end;

definition let G be _Graph;
  mode EdgeSeq of G -> FinSequence of the_Edges_of G means :Def2: ::dESEQ
    ex vs being FinSequence of the_Vertices_of G st
      len vs = len it + 1 &
      for n being Element of NAT st 1 <= n & n <= len it holds
        it.n Joins vs.n,vs.(n+1),G;
  existence proof
    set IT = {}, vs = <*choose the_Vertices_of G*>;
    reconsider IT as FinSequence of the_Edges_of G by FINSEQ_1:29;
    reconsider vs as FinSequence of the_Vertices_of G;
    take IT, vs;
    len vs = 0 + 1 by FINSEQ_1:57;
    hence len vs = len IT + 1 by FINSEQ_1:25;
    let n be Element of NAT; assume 1 <= n & n <= len IT;
    hence thesis by FINSEQ_1:25;
  end;
end;

definition let G be _Graph;
  mode Walk of G -> FinSequence of the_Vertices_of G \/ the_Edges_of G means
  :Def3: ::dWALK
    len it is odd & it.1 in the_Vertices_of G &
    for n being odd Element of NAT st n < len it
     holds it.(n+1) Joins it.n, it.(n+2), G;
  existence proof
    set VE = (the_Vertices_of G) \/ (the_Edges_of G);
    consider v being set such that
A1: v in the_Vertices_of G by XBOOLE_0:def 1;
    reconsider v as Element of VE by A1, XBOOLE_0:def 2;
    take <*v*>;
    thus len <*v*> is odd by FINSEQ_1:57, JORDAN12:3;
    thus <*v*>.1 in the_Vertices_of G by A1, FINSEQ_1:57;
    let n be odd Element of NAT; assume n < len <*v*>; then
    n < 1 by FINSEQ_1:57;
    hence thesis by HEYTING3:1;
end;
end;

registration let G be _Graph, W be Walk of G;
  cluster len W -> odd non empty;
  correctness proof
    thus len W is odd by Def3; then
    len W <> 0 by HEYTING3:1;
    hence len W is non empty;
  end;
end;

definition let G be _Graph, v be Vertex of G;
  func G.walkOf(v) -> Walk of G equals  ::dWALKOFV
    <*v*>;
  coherence proof
    set VE = (the_Vertices_of G) \/ (the_Edges_of G), W = <*v*>, v' = v;
    reconsider v' as Element of VE by XBOOLE_0:def 2;
    <*v'*> is FinSequence of VE; then reconsider W as FinSequence of VE;
    now thus len W is odd by FINSEQ_1:57, JORDAN12:3;
        W.1 = v by FINSEQ_1:57;
        hence W.1 in the_Vertices_of G;
        let n be odd Element of NAT; assume n < len <*v*>; then
        1 <= n & n < 1 by FINSEQ_1:57, HEYTING3:1;
        hence W.(n+1) Joins W.n, W.(n+2), G;
    end;
    hence <*v*> is Walk of G by Def3;
  end;
end;

definition let G be _Graph, x,y,e be set;
    func G.walkOf(x,e,y) -> Walk of G equals: Def5: ::dWALKOFE
      <*x,e,y*> if e Joins x,y,G otherwise G.walkOf(choose the_Vertices_of G);
   coherence proof
    set VE = (the_Vertices_of G)\/(the_Edges_of G);
    hereby assume
    A1: e Joins x,y,G; then
        x is Vertex of G & y is Vertex of G by GLIB_000:16; then
    A2: x is Element of VE & y is Element of VE by XBOOLE_0:def 2;
        e in the_Edges_of G by A1, GLIB_000:def 15; then
    A3: e is Element of VE by XBOOLE_0:def 2;
        set W = <*x,e,y*>;
        reconsider W as FinSequence of VE by A2, A3, FINSEQ_2:16;
    A4: len W = 3 & W.1 = x & W.2 = e & W.3 = y by FINSEQ_1:62;
        now reconsider aa1=1 as odd Element of NAT by JORDAN12:3;
            aa1+2 is odd;
            hence len W is odd by FINSEQ_1:62;
            thus W.1 in the_Vertices_of G by A4, A1, GLIB_000:16;
            let n be odd Element of NAT; assume n < len W; then
            n < 2 + 1 by FINSEQ_1:62; then
            n <= 2*1 by NAT_1:13; then
            n = 2*0 or n = 1 or n = 2*1 by NAT_1:27;
            hence W.(n+1) Joins W.n,W.(n+2),G by A1,A4;
        end;
        hence <*x,e,y*> is Walk of G by Def3;
    end;
    thus thesis;
  end;
  consistency;
end;

definition let G be _Graph, W be Walk of G;
  func W.first() -> Vertex of G equals   ::dWFIRST
    W.1;
  coherence by Def3;

  func W.last() -> Vertex of G equals  ::dWLAST
    W.(len W);
  coherence proof
    now per cases;
    suppose len W = 1;
        hence thesis by Def3; end;
    suppose
    A1: len W <> 1;
        1 <= len W by HEYTING3:1; then
        1 < len W by A1, REAL_1:def 5; then
        1+1 < len W + 1 by XREAL_1:10; then
        2 <= len W by NAT_1:13; then
        reconsider n = len W - 2 * 1 as odd Element of NAT by INT_1:18;
    A2: n + 2 = len W; then
        n < len W by NAT_1:16; then
        W.(n+1) Joins W.n, W.(len W), G by A2, Def3;
        hence thesis by GLIB_000:16; end;
    end;
    hence thesis;
  end;
end;

definition let G be _Graph, W be Walk of G, n be Nat;
  func W.vertexAt(n) -> Vertex of G equals :Def8: ::dWVAT
    W.n if n is odd & n <= len W otherwise W.first();
  correctness proof
    hereby assume
    A1: n is odd & n <= len W;
        reconsider n1 = n as Element of NAT by ORDINAL1:def 13;
        now per cases;
        suppose n = len W; then
            W.n = W.last();
            hence W.n is Vertex of G; end;
        suppose n <> len W; then
            n < len W by A1, REAL_1:def 5; then
            W.(n1+1) Joins W.n, W.(n+2), G by A1, Def3;
            hence W.n is Vertex of G by GLIB_000:16; end;
        end;
        hence W.n is Vertex of G;
    end;
    thus thesis;
  end;
end;

definition let G be _Graph, W be Walk of G;
  func W.reverse() -> Walk of G equals  ::dWREV
    Rev W;
  coherence proof
    set W' = Rev W;
    reconsider W' as FinSequence of (the_Vertices_of G)\/(the_Edges_of G);
A1: len W' = len W by FINSEQ_5:def 3;
    now thus len W' is odd by A1;
        W'.1 = W.(len W) by FINSEQ_5:65; then
        W'.1 = W.last();
        hence W'.1 in the_Vertices_of G;
        let n be odd Element of NAT; assume
    A2: n < len W';
    A3: now 1 <= n & n <= len W by A2, FINSEQ_5:def 3, HEYTING3:1;
            hence n in dom W by FINSEQ_3:27;
        A4: 1 <= n+1 & 1 <= n+2 by NAT_1:12;
        A5: n+1 <= len W by A1, A2, NAT_1:13;
            hence n+1 in dom W by A4, FINSEQ_3:27;
            n+1 < len W by A5, REAL_1:def 5; then
            n+1+1 <= len W by NAT_1:13;
            hence n+2 in dom W by A4, FINSEQ_3:27;
        end; then
    A6: n <= len W & n+1 <= len W & n+2 <= len W by FINSEQ_3:27;
        set rn = len W-n+1, rnaa1 = len W-(n+1)+1, rn2 = len W-(n+2)+1;
        reconsider rn as odd Element of NAT by  A6, FINSEQ_5:1;
        reconsider rn2 as odd Element of NAT by  A6, FINSEQ_5:1;
        reconsider rnaa1 as even Element of NAT by  A6, FINSEQ_5:1;
        1+0 < n+2 by XREAL_1:10; then
        len W - (n+2) < len W - 1 by REAL_1:92; then
        len W - (n+2) + 1 < len W - 1 + 1 by XREAL_1:10; then
    A7: W.(rn2+1) Joins W.rn2, W.(rn2+2), G by Def3;
    A8: W'.n = W.rn by A3,FINSEQ_5:61
            .= W.(rn2+2);
    A9:  W'.(n+1) = W.(rnaa1) by A3, FINSEQ_5:61
                 .= W.(rn2+1);
        W'.(n+1) Joins W'.(n+2), W'.n, G by A8,A9,A3, A7, FINSEQ_5:61;
        hence W'.(n+1) Joins W'.n, W'.(n+2), G by GLIB_000:17;
    end;
    hence Rev W is Walk of G by Def3;
  end;
end;

definition let G be _Graph, W1, W2 be Walk of G;
  func W1.append(W2) -> Walk of G equals :Def10: ::dWAPPND
     W1 ^' W2 if W1.last() = W2.first() otherwise W1;
  correctness proof
    set W = W1 ^' W2, lenW = len W;
    hereby assume
    A1: W1.last() = W2.first();
        len W2 <> 0; then
    A2: W2 <> {} by FINSEQ_1:25;
    A3: now assume len W is even; then reconsider lenW as even Element of NAT;
            lenW + 1 = len W1 + len W2 by A2, GRAPH_2:13;
            hence contradiction;
        end;
        1 <= len W1 by HEYTING3:1; then
    A4: W.1 = W1.first() by GRAPH_2:14;
        now let n be odd Element of NAT such that
        A5: n < len W; set v1 = W.n, v2 = W.(n+2), e = W.(n+1);
            now per cases;
            suppose
            A6: n+2 <= len W1;
            A7: 1 <= n by HEYTING3:1;
            A8: 1 <= n+1 & 1 <= n+2 by NAT_1:12;
                n < n+2 by NAT_1:16; then
            A9: n < len W1 by A6, XXREAL_0:2;
                n+2-2 <= len W1-0 & n+2-1 <= len W1-0 by A6, REAL_1:92; then
                W.n = W1.n & W.(n+1) = W1.(n+1) & W.(n+2) = W1.(n+2)
                  by  A6,A7,A8,GRAPH_2:14;
                hence W.(n+1) Joins W.n,W.(n+2),G by  A9, Def3; end;
            suppose
            A10: len W1 < n+2; then consider k being Nat such that
            A11: n + 2 = len W1 + k by NAT_1:10;
                now assume k is odd; then reconsider k as odd Element of NAT
                  by ORDINAL1:def 13;
                    n+2 = len W1 + k by A11;
                    hence contradiction;
                end; then reconsider k as even Element of NAT
                by ORDINAL1:def 13;
                k <> 0 by A10, A11; then
                0 < k; then
                0 + 1 < k + 1 by XREAL_1:10; then
            A12: 1 <= k by NAT_1:13;
                n + 1 < len W + 1 by A5, XREAL_1:10; then
                n + 1 < len W1 + len W2 by A2, GRAPH_2:13; then
                n + 1 + 1 < len W1 + len W2 + 1 by XREAL_1:10; then
                n + (1+1) < len W1 + len W2 + 1; then
            A13: k + len W1 < len W1 + (len W2 + 1) by A11; then
                k <= len W2 + 1 by XREAL_1:8; then
            A14: k < len W2 + 1 by A13, REAL_1:def 5; then
            A15: k <= len W2 by NAT_1:13; then
            A16: k < len W2 by REAL_1:def 5; then
            A17: W.(n + 2) = W2.(k+1) by A11, A12, GRAPH_2:15;
                len W1 + 1 <= n+2 by A10, NAT_1:13; then
                len W1 + 1 < n+1+1 by REAL_1:def 5; then
                len W1 <= n + 1 by XREAL_1:8; then
                len W1 < n + 1 by REAL_1:def 5; then
            A18: len W1 <= n by NAT_1:13;
                now per cases;
                suppose
                A19: n = len W1; then
                    1 <= n & n <= len W1 by HEYTING3:1; then
                    W.n = W1.(len W1) by A19, GRAPH_2:14; then
                A20: W.n = W2.1 by A1;
                A21: k = 2 by A11, A19;
                A22: 1+1+0< len W2 + 1 by A11, A14, A19; then
                    1 <= len W2 by XREAL_1:8; then
                A23: 1 < len W2 by A22, REAL_1:def 5; then
                    W.(n + 1) = W2.(1+1) by A19, GRAPH_2:15;
                    hence W.(n+1) Joins W.n, W.(n+2), G
                      by A20, A21, A17, A23, Def3, JORDAN12:3; end;
                suppose len W1 <> n; then
                    len W1 < n by A18, REAL_1:def 5; then
                A24: 2+len W1-len W1<k+len W1-len W1
                      by A11,XREAL_1:10;
                    reconsider two=2*1 as even Element of NAT;
                    reconsider k2 = k-two as even Element of NAT
                    by A24, INT_1:18;
                    n + 2 = len W1 + k2 + 2 by A11; then
                A25: n = len W1 + k2;
                    1+1-1 < k2 + 1 + 1 - 1 by A24, REAL_1:92; then
                A26: 1 <= k2 by NAT_1:13;
                    k2 < k2 + (1+1) by NAT_1:16; then
                    k2 < len W2 by A15, XXREAL_0:2; then
                A27: W.n = W2.(k2+1) by A25, A26, GRAPH_2:15;
                    set kaa1 = k2+1; reconsider kaa1 as odd Element of NAT;
                    kaa1+2 = k + 1; then
                A28: W2.(kaa1+2) = W.(n+2) by A11, A12, A16, GRAPH_2:15;
                    kaa1 < kaa1 + 1 by NAT_1:19; then
                A29: kaa1 < len W2 by A15, XXREAL_0:2;
                A30: 1 <= k2+1 by NAT_1:12;
                    kaa1+1-1 < len W2-0 by A15, REAL_1:92; then
                    W2.(kaa1+1) = W.(len W1 + kaa1) by A30, GRAPH_2:15
                              .= W.(n+1) by A25;
                    hence e Joins v1,v2,G by A29, A27, A28, Def3; end;
                end;
                hence e Joins v1,v2,G; end;
            end;
            hence e Joins v1,v2,G;
        end;
        hence W1 ^' W2 is Walk of G by A3, A4, Def3;
    end;
    thus thesis;
  end;
end;

definition let G be _Graph, W be Walk of G, m, n being Nat;
  func W.cut(m,n) -> Walk of G equals :Def11: ::dWCUT
     (m,n)-cut W if m is odd & n is odd & m <= n & n <= len W otherwise W;
  correctness proof
    hereby assume
    A1: m is odd & n is odd & m <= n & n <= len W;
        reconsider m4 = m, n4 = n as odd Nat by A1;
        set W2 = (m,n)-cut W, VG = the_Vertices_of G, EG = the_Edges_of G;
    A2: 1 <= m & m <= n & n <= len W by A1, HEYTING3:1; then
        len W2 + m4 - m4 = n4 + 1 - m4 by GRAPH_2:def 1; then
        reconsider lenW2 = len W2 as odd Element of NAT;
        now lenW2 is odd;
            hence len W2 is odd;
            1 <= lenW2 by HEYTING3:1; then
            reconsider lenW2aa1 = lenW2-1 as Element of NAT by INT_1:18;
            0 < lenW2aa1 + 1; then
        A3: W2.(0+1) = W.(m+0) by A2, GRAPH_2:def 1;
            1 <= m & m <= len W by A1, XXREAL_0:2, HEYTING3:1; then
            W.m = W.vertexAt(m) by A1, Def8;
            hence W2.1 in VG by A3;
            let i be odd Element of NAT; assume
        A4: i < len W2; then
            i + m < len W2 + m by XREAL_1:10; then
            i + m < n + 1 by A2, GRAPH_2:def 1; then
            i + m4 <= n4 by NAT_1:13; then
            m4 + i < n4 by REAL_1:def 5; then
        A5: m + i < len W by A1, XXREAL_0:2;
            1 <= i by HEYTING3:1; then
            reconsider iaa1 = i-1 as even Element of NAT by INT_1:18;
            iaa1 < len W2-0 by A4, REAL_1:92; then
        A6: W2.(iaa1+1) = W.(m+iaa1) by A2, GRAPH_2:def 1;
            i+1 <= lenW2 by A4, NAT_1:13; then
            i+1 < len W2 by REAL_1:def 5; then
        A7: W2.(i+1+1) = W.(m+(i+1)) by A2, GRAPH_2:def 1;
            1 <= m+i by A2, NAT_1:12; then
            reconsider x=m4+i-1 as odd Element of NAT by INT_1:18;
            m + i - 1 < len W - 0 by A5, REAL_1:92; then
            W.(x+1) Joins W.x, W.(x+2), G by Def3;
          hence W2.(i+1) Joins W2.i, W2.(i+2), G by A6,A2,A4,GRAPH_2:def 1,A7;
        end;
        hence (m,n)-cut W is Walk of G by Def3;

    end;
    thus thesis;
  end;
end;

definition let G be _Graph, W be Walk of G, m, n be Element of NAT;
  func W.remove(m,n) -> Walk of G equals :Def12: ::dWREMOVE
     W.cut(1,m).append(W.cut(n,len W)) if m is odd & n is odd &
     m <= n & n <= len W & W.m = W.n otherwise W;
  correctness;
end;

definition let G be _Graph, W be Walk of G, e be set;
  func W.addEdge(e) -> Walk of G equals  ::dWADDEDGE
    W.append(G.walkOf(W.last(), e, W.last().adj(e)));
  coherence;
end;

definition let G be _Graph, W be Walk of G;
  func W.vertexSeq() -> VertexSeq of G means :Def14: ::dWVSEQ
    len W + 1 = 2 * len it &
    for n being Element of NAT st 1 <= n & n <= len it
    holds it.n = W.(2*n - 1);
  existence proof
    reconsider lenW1 = len W + 1 as even Element of NAT;
    set lenIT = lenW1 div 2;
A1: 2 divides lenW1 by PEPIN:22; then
A2: 2*lenIT = lenW1 by NAT_D:3;
    deffunc F(Element of NAT) = W.(2*$1-1);
    consider IT being FinSequence such that
A3: len IT = lenIT &
      for k being Element of NAT st k in Seg lenIT holds IT.k = F(k)
      from FINSEQ_1:sch 2;
    now let y be set; assume y in rng IT; then
        consider x being set such that
    A4: x in dom IT & y = IT.x by FUNCT_1:def 5;
    A5: x in Seg lenIT by A3, A4, FINSEQ_1:def 3;
        reconsider x as Element of NAT by A4;
        set 2x = x*2; reconsider 2x as even Element of NAT;
        set 2xaa1 = 2x-1;
        1 <= x & x <= lenIT by A5, FINSEQ_1:3; then
    A6: 1*2 <= 2x & 2x <= lenIT * 2 by XREAL_1:66; then
        1 <= 2x by XXREAL_0:2;
        then reconsider 2xaa1 as odd Element of NAT by INT_1:18;
        2 - 1 <= 2xaa1 & 2xaa1 <= lenW1-1 by A2, A6, XREAL_1:11; then
        W.2xaa1 = W.vertexAt(2xaa1) by Def8; then
        W.2xaa1 in the_Vertices_of G;
        hence y in the_Vertices_of G by A3, A4, A5;
    end; then
    rng IT c= the_Vertices_of G by TARSKI:def 3; then
    reconsider IT as FinSequence of the_Vertices_of G by FINSEQ_1:def 4;
    now let n be Element of NAT; set v1 = IT.n, v2 = IT.(n+1); assume
    A7: 1 <= n & n < len IT; then
    A8: n in Seg lenIT by A3, FINSEQ_1:3;
        set 2n = 2*n; reconsider 2n as even Element of NAT; set 2naa1 = 2n-1;
        1 <= 2 & 1*2 <= n*2 by A7, XREAL_1:66; then
        1 <= 2n by XXREAL_0:2;
        then reconsider 2naa1 as odd Element of NAT by INT_1:18;
        1 <= n+1 & n+1 <= lenIT by A3, A7, NAT_1:13; then
        n+1 in Seg lenIT by FINSEQ_1:3; then
    A9: v2 = W.(2*(n+1)-1) by A3
          .= W.(2n+1);
        2n <= lenW1 & 2n <> lenW1 by A2, A3, A7, XREAL_1:70; then
    A10: 2n - 1 <= len W + 1 - 1 by XREAL_1:11;
        2naa1 <> len W by A2,A3,A7; then
        2naa1 < len W by A10, REAL_1:def 5; then
        W.(2naa1+1) Joins W.2naa1, W.(2naa1+2), G by Def3; then
    A11: W.(2naa1+1) Joins IT.n, W.(2naa1+2), G by A3, A8;
        thus ex e being set st e Joins IT.n, IT.(n+1), G by A9, A11;
    end; then reconsider IT as VertexSeq of G by Def1;
    take IT;
    thus len W + 1 = 2 * len IT by A1, A3, NAT_D:3;
    let n be Element of NAT; assume
    1 <= n & n <= len IT; then
    n in Seg len IT by FINSEQ_1:3;
    hence IT.n = W.(2*n-1) by A3;
end;
  uniqueness proof
    let IT1, IT2 be VertexSeq of G such that
A12: len W + 1 = 2 * len IT1 &
      for n being Element of NAT st 1 <= n & n <= len IT1
      holds IT1.n = W.(2*n - 1) and
A13: len W + 1 = 2 * len IT2 &
      for n being Element of NAT st 1 <= n & n <= len IT2
      holds IT2.n = W.(2*n - 1);
A14: len IT1 = len IT2 by A12, A13;
A15: dom IT1 = Seg len IT2 by A14, FINSEQ_1:def 3
           .= dom IT2 by FINSEQ_1:def 3;
    now let n be Element of NAT such that
    A16:  n in dom IT1;
    A17:  1 <= n & n <= len IT1 by A16, FINSEQ_3:27; then
         IT1.n = W.(2*n - 1) by A12;
         hence IT1.n = IT2.n by A13, A14, A17;
    end;
    hence IT1 = IT2 by A15, FINSEQ_1:17;
end;
end;

definition let G be _Graph, W be Walk of G;
  func W.edgeSeq() -> EdgeSeq of G means :Def15: ::dWESEQ
    len W = 2*len it+1 &
    for n being Element of NAT st 1 <= n & n <= len it holds it.n = W.(2*n);
  existence proof
    1 <= len W by HEYTING3:1; then
    reconsider lenWaa1 = len W-1 as even Element of NAT by INT_1:18;
    set lenIT = lenWaa1 div 2; reconsider lenIT as Element of NAT;
    2 divides lenWaa1 by PEPIN:22; then
A1: lenWaa1 = 2 * lenIT by NAT_D:3; then
A2: len W = 2 * lenIT + 1;
    deffunc F(Element of NAT) = W.(2*$1);
    consider IT being FinSequence such that
A3: len IT = lenIT &
    for n being Element of NAT st n in Seg lenIT holds IT.n = F(n)
    from FINSEQ_1:sch 2;
    now let y be set; assume y in rng IT; then consider x being set such that
    A4: x in dom IT & y = IT.x by FUNCT_1:def 5;
    A5: x in Seg lenIT by A3, A4, FINSEQ_1:def 3;
    reconsider x as Element of NAT by A4;
    A6: y = W.(2*x) by A3, A4, A5; reconsider 2x = 2*x as even Element of NAT;
        1 <= x & x <= lenIT by A5, FINSEQ_1:3; then
    A7: 1*2 <= 2*x & x*2 <= lenIT*2 by XREAL_1:66; then
    A8: 1 <= 2x by XXREAL_0:2;
        2 divides lenWaa1 by PEPIN:22; then
        2x <= lenWaa1 by A7, NAT_D:3; then
        2x + 1 <= lenWaa1 + 1 by XREAL_1:9; then
        2x <= 2x+1 & 2x+1 <= len W by NAT_1:11; then
    A9: 2x <= len W by XXREAL_0:2;
        reconsider 2xaa1 = 2x-1 as odd Element of NAT by A8, INT_1:18;
        2xaa1 < len W by A9, SPPOL_1:5; then
        W.(2xaa1+1) Joins W.2xaa1, W.(2xaa1+2), G by Def3;
        hence y in the_Edges_of G by A6, GLIB_000:def 15;
    end; then
    rng IT c= the_Edges_of G by TARSKI:def 3; then
    reconsider IT as FinSequence of the_Edges_of G by FINSEQ_1:def 4;
    now set vs = W.vertexSeq();
        take vs;
        (2 * len IT + 1) + 1 = 2 * len vs by A2, A3, Def14; then
        2 * len IT + (1 + 1) = 2 * len vs; then
        2 * len IT + 2 * 1 = 2 * len vs; then
        2 * (len IT + 1) = 2 * len vs;
        hence
    A10: len vs = len IT + 1;
        let n be Element of NAT; set v1 = vs.n, v2 = vs.(n+1); assume
    A11: 1 <= n & n <= len IT; then
    A12: 1 <= n & n <= len vs by A10, NAT_1:12;
    A13: 1 <= n+1 & n+1 <= len vs by A10, A11, NAT_1:12, XREAL_1:9;
        set 2n = 2*n; reconsider 2n as even Element of NAT;
        set 2naa1 = 2n-1;
        1 <= n+n by A11, NAT_1:12; then
        reconsider 2naa1 as odd Element of NAT by INT_1:18;
    A14: v1 = W.(2*n-1) & v2 = W.(2*(n+1)-1) by A12, A13, Def14;
        n in Seg lenIT by A11, A3, FINSEQ_1:3; then
    A15: IT.n = W.(2naa1+1) by A3;
    A16: v2 = W.(2naa1+2) by A14;
        n*2 <= len IT*2 by A11, XREAL_1:66; then
        n*2 <= len W by A2, A3, NAT_1:12; then
        2naa1 < len W - 0 by REAL_1:92;
        hence IT.n Joins vs.n, vs.(n+1), G by A14, A15, A16, Def3;
    end; then reconsider IT as EdgeSeq of G by Def2;
    take IT;
    thus len W = 2*len IT+1 by A1, A3;
    let n be Element of NAT; assume 1 <= n & n <= len IT;  then
    n in Seg lenIT by A3, FINSEQ_1:3;
    hence IT.n = W.(2*n) by A3;
end;
  uniqueness proof
    let IT1, IT2 be EdgeSeq of G such that
A17: len W = 2*len IT1 + 1 &
    for n being Element of NAT st 1 <= n & n <= len IT1 holds IT1.n = W.(2*n)
     and
A18: len W = 2*len IT2 + 1 &
      for n being Element of NAT st 1 <= n & n <= len IT2
      holds IT2.n = W.(2*n);
    2*len IT1 = 2*len IT2 by A17, A18; then
A19: len IT1 = len IT2;
A20: dom IT1 = Seg len IT2 by A19, FINSEQ_1:def 3
           .= dom IT2 by FINSEQ_1:def 3;
    now let n be Element of NAT; assume n in dom IT1; then
    A21: 1 <= n & n <= len IT1 & n <= len IT2 by A19, FINSEQ_3:27;
        hence IT1.n = W.(2*n) by A17
                   .= IT2.n by A21, A18;
    end;
    hence IT1 = IT2 by A20, FINSEQ_1:17;
end;
end;

definition let G be _Graph, W be Walk of G;
  func W.vertices() -> finite Subset of the_Vertices_of G equals  ::dWVERTICES
    rng W.vertexSeq();
  coherence;
end;

definition let G be _Graph, W be Walk of G;
  func W.edges() -> finite Subset of the_Edges_of G equals  ::dWEDGES
    rng W.edgeSeq();
  coherence;
end;

definition let G be _Graph, W be Walk of G;
  func W.length() -> Element of NAT equals  ::dWLENGTH
    len W.edgeSeq();
  coherence;
end;

definition let G be _Graph, W be Walk of G, v be set;
  func W.find(v) -> odd Element of NAT means :Def19: ::dWFINDV
    it <= len W & W.it = v &
    for n being odd Element of NAT st n <= len W & W.n = v holds it <= n if
    v in W.vertices() otherwise it = len W;
  existence proof
    hereby assume
A1: v in W.vertices();
  set vs = W.vertexSeq();
    defpred P[Element of NAT] means $1 is odd & $1 <= len W & W.$1 = v;
    now v in rng vs by A1; then consider i being Element of NAT such that
    A2: i in dom vs & vs.i = v by FINSEQ_2:11;
        set n1 = 2*i; reconsider n1 as even Element of NAT; set n = n1-1;
    A3: 1 <= i & i <= len vs by A2, FINSEQ_3:27; then
        1 <= i+i by NAT_1:12; then reconsider n as odd Element of NAT
         by INT_1:18;
        take n;
        i*2 <= len vs *2 by A3, XREAL_1:66; then
        i*2 <= len W + 1 by Def14; then
        n1 - 1 <= len W + 1 - 1 by REAL_1:92;
        hence n <= len W;
        thus W.n = v by A2, A3, Def14;
    end; then
A4: ex k being Element of NAT st P[k];
    consider IT being Element of NAT such that
A5: P[IT] & for n being Element of NAT st P[n] holds IT <= n
 from NAT_1:sch 5(A4);
    reconsider IT as odd Element of NAT by A5;
    take IT;
    thus IT <= len W & W.IT = v by A5;
    let n be odd Element of NAT; assume
    n <= len W & W.n = v;
    hence IT <= n by A5;
    end;
    assume not v in W.vertices();
    set IT = len W;
    take IT;
    thus thesis;
end;
  uniqueness proof
    let IT1, IT2 be odd Element of NAT;
    hereby assume v in W.vertices();
        assume
    A6: IT1 <= len W & W.IT1 = v &
        for n being odd Element of NAT st n <= len W & W.n = v holds IT1 <= n;
        assume
    A7: IT2 <= len W & W.IT2 = v &
        for n being odd Element of NAT st n <= len W & W.n = v holds IT2 <= n;
    A8: IT1 <= IT2 by A6, A7;
        IT2 <= IT1 by A6, A7;
        hence IT1 = IT2 by A8, XXREAL_0:1;
    end;
    assume not v in W.vertices();
    thus thesis;
  end;
  consistency;
end;

definition let G be _Graph, W be Walk of G, n be Element of NAT;
  func W.find(n) -> odd Element of NAT means :Def20: ::dWFINDN
    it <= len W & W.it = W.n &
      for k being odd Element of NAT st k <= len W & W.k = W.n holds it <= k
    if (n is odd & n <= len W) otherwise it = len W;
  existence proof
    defpred P[Element of NAT] means $1 is odd & $1 <= len W & W.$1 = W.n;
    hereby assume (n is odd & n <= len W); then
    A1: ex n being Element of NAT st P[n];
        consider IT being Element of NAT such that
    A2: P[IT] & for k being Element of NAT st P[k] holds IT <= k
     from NAT_1:sch 5(A1);
        reconsider IT as odd Element of NAT by A2;
        take IT;
        thus IT <= len W & W.IT = W.n by A2;
        thus for k being odd Element of NAT st k <= len W & W.k = W.n
        holds IT <= k by A2;
    end;
    thus thesis;
  end;
  uniqueness proof
    let IT1, IT2 be odd Element of NAT;
    hereby assume n is odd & n <= len W; assume
    A3: IT1 <= len W & W.IT1 = W.n &
         for k being odd Element of NAT st k <= len W & W.k = W.n
         holds IT1 <= k;
        assume IT2 <= len W & W.IT2 = W.n &
          for k being odd Element of NAT st k <= len W & W.k = W.n
          holds IT2 <= k; then
        IT1 <= IT2 & IT2 <= IT1 by A3;
        hence IT1 = IT2 by XXREAL_0:1;
    end;
    thus thesis;
  end;
  consistency;
end;

definition let G be _Graph, W be Walk of G, v be set;
  func W.rfind(v) -> odd Element of NAT means :Def21: ::dWRFINDV
    it <= len W & W.it = v &
    for n being odd Element of NAT st n <= len W & W.n = v holds n <= it
    if v in W.vertices() otherwise it = len W;
  existence proof
    hereby assume
    A1: v in W.vertices();
        defpred P[Element of NAT] means $1 is odd & $1 <= len W & W.$1 = v;
    A2: for k being Element of NAT st P[k] holds k <= len W;
        W.find(v) <= len W & W.(W.find(v)) = v by A1, Def19; then
    A3: ex k being Element of NAT st P[k];
        consider IT being Element of NAT such that
    A4: P[IT] & for n being Element of NAT st P[n] holds n <= IT
    from NAT_1:sch 6(A2,A3);
        reconsider IT as odd Element of NAT by A4;
        take IT;
        thus IT <= len W & W.IT = v by A4;
        let n be odd Element of NAT; assume
        n <= len W & W.n = v;
        hence n <= IT by A4;
    end;
    thus thesis;
  end;
  uniqueness proof
    let IT1, IT2 be odd Element of NAT;
    hereby assume v in W.vertices(); assume
    A5: IT1 <= len W & W.IT1 = v &
          for n being odd Element of NAT st n <= len W & W.n = v
          holds n <= IT1; assume
    A6: IT2 <= len W & W.IT2 = v &
          for n being odd Element of NAT st n <= len W & W.n = v
          holds n <= IT2;
    A7: IT2 <= IT1 by A5, A6;
          IT1 <= IT2 by A5, A6;
        hence IT1 = IT2 by A7, XXREAL_0:1;
    end;
    thus thesis;
  end;
  consistency;
end;

definition let G be _Graph, W be Walk of G, n be Element of NAT;
  func W.rfind(n) -> odd Element of NAT means :Def22: ::dWRFINDN
    it <= len W & W.it = W.n &
    for k being odd Element of NAT st k <= len W & W.k = W.n holds k <= it
    if (n is odd & n <= len W) otherwise it = len W;
  existence proof
    defpred P[Element of NAT] means $1 is odd & $1 <= len W & W.$1 = W.n;
    hereby assume (n is odd & n <= len W); then
    A1: ex k being Element of NAT st P[k];
    A2: for k being Element of NAT st P[k] holds k <= len W;
        consider IT being Element of NAT such that
    A3: P[IT] & for k being Element of NAT st P[k] holds k <= IT
    from NAT_1:sch 6(A2,A1);
        reconsider IT as odd Element of NAT by A3;
        take IT;
        thus IT <= len W & W.IT = W.n by A3;
        thus for k being odd Element of NAT st k <= len W & W.k = W.n
           holds k <= IT by A3;
    end;
    thus thesis;
  end;
  uniqueness proof
    let IT1, IT2 be odd Element of NAT;
    hereby assume n is odd & n <= len W; assume
    A4: IT1 <= len W & W.IT1 = W.n &
         for k being odd Element of NAT st k <= len W & W.k = W.n
         holds k <= IT1;
        assume IT2 <= len W & W.IT2 = W.n &
          for k being odd Element of NAT st k <= len W & W.k = W.n
          holds k <= IT2; then
        IT1 <= IT2 & IT2 <= IT1 by A4;
        hence IT1 = IT2 by XXREAL_0:1;
    end;
    thus thesis;
  end;
  consistency;
end;

definition let G be _Graph, u, v be set, W be Walk of G;
  pred W is_Walk_from u,v  means :Def23: ::dWALKFROM
    W.first() = u & W.last() = v;
end;

definition let G be _Graph, W be Walk of G;
  attr W is closed means :Def24: ::dCLWALK
    W.first() = W.last();
  attr W is directed means :Def25: ::dDIWALK
    for n being odd Element of NAT st n < len W
      holds (the_Source_of G).(W.(n+1)) = W.n;
  attr W is trivial means :Def26: ::dTVWALK
    W.length() = 0;
  attr W is Trail-like means :Def27: ::dTLWALK
    W.edgeSeq() is one-to-one;
end;

notation let G be _Graph, W be Walk of G;
  antonym W is open for W is closed;
end;

definition let G be _Graph, W be Walk of G;
  attr W is Path-like means :Def28: ::dPLWALK
    W is Trail-like &
    for m, n being odd Element of NAT st m < n & n <= len W holds
      W.m = W.n implies (m = 1 & n = len W);
end;

definition let G be _Graph, W be Walk of G;
  attr W is vertex-distinct means :Def29: ::dVDWALK
    for m,n being odd Element of NAT st m <= len W & n <= len W & W.m = W.n
      holds m = n;
end;

definition let G be _Graph, W be Walk of G;
  attr W is Circuit-like means :Def30: ::dCIWALK
     W is closed & W is Trail-like & W is non trivial;

  attr W is Cycle-like means :Def31: ::dCYWALK
    W is closed & W is Path-like & W is non trivial;
end;

Lm3:
  for G be _Graph, W be Walk of G, n being odd Element of NAT st n <= len W
  holds
    W.n in the_Vertices_of G proof
    let G be _Graph, W be Walk of G, n be odd Element of NAT;
    assume n <= len W; then
    W.n = W.vertexAt(n) by Def8;
    hence thesis;
end;

Lm4:
  for G be _Graph, W be Walk of G, n being even Element of NAT st n in dom W
  holds
    ex naa1 being odd Element of NAT st
      naa1 = n-1 & n-1 in dom W & n+1 in dom W &
      W.n Joins W.(naa1), W.(n+1),G proof
    let G be _Graph, W be Walk of G, n be even Element of NAT;
    assume n in dom W; then
A1: 1 <= n & n <= len W by FINSEQ_3:27; then
    reconsider naa1 = n-1 as odd Element of NAT by INT_1:18;
    take naa1;
    thus naa1 = n-1;
    1 < n by A1,JORDAN12:3,REAL_1:def 5; then
    1+1 <= n by NAT_1:13; then
    1+1-1 <= n-1 by REAL_1:92; then
A2: 1 <= naa1;
    n - 1 <= len W - 0 by A1, REAL_1:92;
    hence n - 1 in dom W by A2, FINSEQ_3:27;
    n < len W by A1, REAL_1:def 5; then
A3: n+1 <= len W by NAT_1:13;
    1 <= 1+n by NAT_1:12;
    hence n+1 in dom W by A3, FINSEQ_3:27;
    n - 1 < len W - 0 by A1, REAL_1:92; then
    W.(naa1+1) Joins W.naa1, W.(naa1+2),G by Def3;
    hence thesis;
end;

Lm5:
  for G be _Graph, W be Walk of G, n being odd Element of NAT st n < len W
  holds
     n in dom W & n+1 in dom W & n+2 in dom W proof
    let G be _Graph, W be Walk of G, n be odd Element of NAT; assume
A1: n < len W;
A2: 1 <= n by HEYTING3:1;
A3: 1 <= n+1 & 1 <= n+2 by NAT_1:12;
    n+1 <= len W & n+2 <= len W by A1,NAT_1:13,Th1;
    hence thesis by A1,A2,A3,FINSEQ_3:27;
end;

Lm6:
  for G being _Graph, v being Vertex of G holds
    G.walkOf(v) is closed & G.walkOf(v) is directed & G.walkOf(v) is trivial &
    G.walkOf(v) is Trail-like & G.walkOf(v) is Path-like proof
    let G be _Graph, v be Vertex of G; set W = G.walkOf(v);
    W.first() = W.last() by FINSEQ_1:57;
    hence W is closed by Def24;
    now let n be odd Element of NAT; assume n < len W; then
        n < 1 by FINSEQ_1:56;
        hence W.n = (the_Source_of G).(W.(n+1)) by HEYTING3:1;
    end;
    hence W is directed by Def25;
    len W = 1 by FINSEQ_1:56; then
    0 + 1 = 2*len W.edgeSeq() + 1 by Def15; then
    0 = 2*len W.edgeSeq(); then
    0 = len W.edgeSeq(); then
    W.length() = 0;
    hence W is trivial by Def26;
    len W = 2*(len (W.edgeSeq()))+1 by Def15; then
    0 + 1 = 2 * (len (W.edgeSeq())) + 1 by FINSEQ_1:57; then
    0 = 2 * len (W.edgeSeq());  then
    len (W.edgeSeq()) = 0; then
    W.edgeSeq() is one-to-one by FINSEQ_1:25;
    hence
A1: W is Trail-like by Def27;
    now let n, m be odd Element of NAT; assume n < m & m <= len W; then
        n < m & m <= 1 by FINSEQ_1:57; then
        n < 1 by XXREAL_0:2;
        hence W.n = W.m implies (n = 1 & m = len W) by HEYTING3:1;
    end;
    hence W is Path-like by A1, Def28;
end;

Lm7:
  for G be _Graph, x,e,y be set holds
    e Joins x,y,G implies len G.walkOf(x,e,y) = 3 proof
    let G be _Graph, x,e,y be set; assume e Joins x,y,G; then
    G.walkOf(x,e,y) = <*x,e,y*> by Def5;
    hence thesis by FINSEQ_1:62;
end;

Lm8:
  for G being _Graph, x,e,y being set holds e Joins x,y,G implies
    G.walkOf(x,e,y).first() = x & G.walkOf(x,e,y).last() = y &
    G.walkOf(x,e,y) is_Walk_from x,y proof
    let G be _Graph, x,e,y be set; set W = G.walkOf(x,e,y);
    assume e Joins x,y,G; then
    W = <*x,e,y*> by Def5; then
A1: len W = 3 & W.1 = x & W.2 = e & W.3 = y by FINSEQ_1:62;
    hence
A2: W.first() = x;
    thus W.last() = y by A1;
    hence W is_Walk_from x, y by A2, Def23;
end;

Lm9:
 for G being _Graph, W being Walk of G holds
  len W = len W.reverse() & dom W = dom W.reverse() &
    rng W = rng W.reverse() by FINSEQ_5:def 3,60;

Lm10:
  for G be _Graph, W be Walk of G holds
    W.first() = W.reverse().last() & W.last() = W.reverse().first() proof
    let G be _Graph, W be Walk of G;
A1: len W = len W.reverse() by Lm9;
    thus W.first() = W.reverse().last() by  FINSEQ_5:65,A1;
    thus W.last() = W.reverse().first() by FINSEQ_5:65;
end;

Lm11:
  for G being _Graph, W being Walk of G, n being Element of NAT holds
  n in dom W.reverse() implies W.reverse().n = W.(len W - n + 1) &
    (len W - n + 1) in dom W proof
    let G be _Graph, W be Walk of G, n be Element of NAT; assume
A1: n in dom W.reverse();
    hence W.reverse().n = W.(len W - n + 1) by FINSEQ_5:def 3;
    n in Seg len W.reverse() by A1, FINSEQ_1:def 3; then
    n in Seg len W by Lm9; then
    len W - n + 1 in Seg len W by FINSEQ_5:2;
    hence len W - n + 1 in dom W by FINSEQ_1:def 3;
end;

Lm12:
  for G being _Graph, W being Walk of G holds
    W.reverse().reverse() = W by FINSEQ_6:29;

Lm13:
  for G being _Graph, W1,W2 being Walk of G holds
    W1.last() = W2.first() implies
    len W1.append(W2) + 1 = len W1 + len W2 proof
    let G be _Graph, W1,W2 be Walk of G; set W = W1.append(W2);
    assume W1.last() = W2.first(); then
A1: W = W1 ^' W2 by Def10;
    len W2 <> 0; then
    W2 <> {} by FINSEQ_1:25;
    hence thesis by A1, GRAPH_2:13;
end;

Lm14:
  for G be _Graph, W1,W2 be Walk of G holds W1.last() = W2.first() implies
    len W1 <= len W1.append(W2) & len W2 <= len W1.append(W2) proof
    let G be _Graph, W1,W2 be Walk of G; set W = W1.append(W2);
    assume W1.last() = W2.first(); then
A1: len W + 1 = len W1 + len W2 by Lm13;
A2: 1 <= len W1 & 1 <= len W2 by HEYTING3:1; then
    len W1 + len W2 - len W2 <= len W + 1 - 1 by A1, REAL_1:92;
    hence len W1 <= len W;
    len W2 + len W1 - len W1 <= len W + 1 - 1 by A1, A2, REAL_1:92;
    hence len W2 <= len W;
end;

Lm15:
  for G being _Graph, W1,W2 being Walk of G holds
  W1.last() = W2.first() implies
    W1.append(W2).first() = W1.first() & W1.append(W2).last() = W2.last() &
    W1.append(W2) is_Walk_from W1.first(), W2.last() proof
    let G be _Graph, W1, W2 be Walk of G; assume
A1: W1.last() = W2.first(); set W = W1.append(W2);
A2: W = W1 ^' W2 by A1, Def10;
    1 <= len W1 by HEYTING3:1; then
    W.1 = W1.first() by A2,GRAPH_2:14;
    hence
A3: W.first() = W1.first();
    now per cases;
    suppose
    A4: len W2 <> 1;
        1 <= len W2 by HEYTING3:1; then
        1 < len W2 by A4, REAL_1:def 5; then
        W.(len W) = W2.last() by A2,GRAPH_2:16;
        hence W.last() = W2.last(); end;
    suppose
    A5: len W2 = 1; then
    A6: W = W1^(2,1)-cut W2 by A2, GRAPH_2:def 2;
         (2,1)-cut W2 = {} by GRAPH_2:def 1;
        then len (2,1)-cut W2 = 0 by CARD_1:47;
        then len (2,1)-cut W2 + 2 = 1 + 1;
        then len (2,1)-cut W2 = 0; then
        (2,1)-cut W2 = {} by FINSEQ_1:25;
        hence W.last() = W2.last() by  A1,A6,FINSEQ_1:47,A5; end;
    end;
    hence thesis by A3, Def23;
end;

Lm16:
  for G be _Graph, W1,W2 be Walk of G, n being Element of NAT holds
  n in dom W1 implies
    W1.append(W2).n = W1.n & n in dom W1.append(W2) proof
    let G be _Graph, W1,W2 be Walk of G, n be Element of NAT;
    set W = W1.append(W2); assume
A1: n in dom W1; then
A2: 1 <= n & n <= len W1 by FINSEQ_3:27;
    now per cases;
    suppose
    A3: W1.last() = W2.first(); then
        W = W1 ^' W2 by Def10;
        hence W.n = W1.n by A2,GRAPH_2:14;
        1 <= len W2 by HEYTING3:1; then
        reconsider lenW2aa1 = len W2 - 1 as Element of NAT by INT_1:18;
        n <= len W1 + lenW2aa1 by A2, NAT_1:12; then
        n <= len W1 + len W2 + -1; then
        n <= len W + 1 + -1 by A3, Lm13;
        hence n in dom W by A2, FINSEQ_3:27; end;
    suppose W1.last() <> W2.first();
        hence W.n = W1.n & n in dom W by A1,Def10; end;
    end;
    hence thesis;
end;

Lm17:
  for G be _Graph, W1,W2 be Walk of G holds W1.last() = W2.first() implies
  for n being Element of NAT st n < len W2 holds
    W1.append(W2).(len W1 + n) = W2.(n+1) &
    (len W1 + n) in dom W1.append(W2) proof
    let G be _Graph, W1,W2 be Walk of G;
    set W = W1.append(W2); assume
A1: W1.last() = W2.first(); then
A2: W = W1 ^' W2 by Def10;
    let n be Element of NAT; assume
A3: n < len W2;
    now per cases;
    suppose
    A4: n = 0; then
        1 <= len W1 + n & len W1 + n <= len W1 by HEYTING3:1; then
        len W1 + n in dom W1 by FINSEQ_3:27;
        hence W1.append(W2).(len W1 + n) = W2.(n + 1) by  A1,A4,Lm16; end;
    suppose n <> 0; then
        0 < n; then
        0 + 1 < n + 1 by XREAL_1:10; then
        1 <= n by NAT_1:13;
        hence W1.append(W2).(len W1 + n) = W2.(n+1) by A2, A3, GRAPH_2:15; end;
    end;
    hence W1.append(W2).(len W1 + n) = W2.(n+1);
    1 <= len W1 by HEYTING3:1; then
A5: 1 <= len W1 + n by NAT_1:12;
    n + 1 <= len W2 by A3, NAT_1:13; then
    n + 1 + len W1 <= len W2 + len W1 by XREAL_1:9; then
    len W1 + n + 1 <= len W + 1 by A1,Lm13; then
    len W1 + n <= len W by XREAL_1:8;
    hence thesis by A5, FINSEQ_3:27;
end;

Lm18:
  for G be _Graph, W1,W2 be Walk of G, n be Element of NAT holds
  n in dom W1.append(W2) implies
     n in dom W1 or ex k being Element of NAT st k < len W2 & n = len W1 + k
     proof
    let G be _Graph, W1,W2 be Walk of G, n be Element of NAT;
    set W3 = W1.append(W2); assume
A1: n in dom W3; then
A2: 1 <= n & n <= len W3 by FINSEQ_3:27;
    now per cases;
    suppose W1.last() = W2.first(); then
    A3: len W3 + 1 = len W1 + len W2 by Lm13;
        now assume not n in dom W1; then
            len W1 < n by A2, FINSEQ_3:27; then
            reconsider k = n - len W1 as Element of NAT by INT_1:18;
            take k;
            now assume len W2 <= k; then
                len W1 + len W2 <= len W1 + k by XREAL_1:9;
                hence contradiction by A2,A3,NAT_1:13;
            end;
            hence k < len W2;
            thus n = len W1+k;
        end;
        hence thesis; end;
    suppose W1.last() <> W2.first();
        hence thesis by A1,Def10; end;
    end;
    hence thesis;
end;

Lm19:
  for G being _Graph, W being Walk of G, m,n being odd Element of NAT
   st m <= n & n <= len W holds len W.cut(m,n) + m = n+1 &
    for i being Element of NAT st i < len W.cut(m,n)
        holds W.cut(m,n).(i+1) = W.(m+i) & m+i in dom W proof
    let G be _Graph, W be Walk of G, m, n be odd Element of NAT;
    set W2 = W.cut(m,n); assume
A1: m <= n & n <= len W; then
A2: W2 = (m,n)-cut W by Def11;
A3: 1 <= m & m <= n & n <= len W by A1, HEYTING3:1;
    hence
A4: len W.cut(m,n) + m = n + 1 by A2, GRAPH_2:def 1;
    let i be Element of NAT; assume
A5: i < len W.cut(m,n);
    hence W.cut(m,n).(i+1) = W.(m+i) by A2, A3,GRAPH_2:def 1;
    1 <= m by HEYTING3:1; then
A6: 1 <= m+i by NAT_1:12;
    m+i < n + 1 by A4,A5,XREAL_1:10; then
    m+i <= n by NAT_1:13; then
    m+i <= len W by A1, XXREAL_0:2;
    hence m+i in dom W by A6, FINSEQ_3:27;
end;

Lm20:
  for G being _Graph, W being Walk of G, m, n being odd Element of NAT
    st m <= n & n <= len W holds
    W.cut(m,n).first() = W.m & W.cut(m,n).last() = W.n &
    W.cut(m,n) is_Walk_from W.m, W.n proof
    let G be _Graph, W be Walk of G, m, n be odd Element of NAT;
    set W2 = W.cut(m,n); assume
A1: m <= n & n <= len W;
    1-1 < len W2 - 0; then
    W2.(0+1) = W.(m+0) by A1, Lm19;
    hence
A2: W2.first() = W.m;
    reconsider nm4 = n-m as Element of NAT by A1, INT_1:18;
A3: len W2 + m - m = n + 1 - m by A1, Lm19; then
    len W2 = n - m + 1; then
    n - m + 1 -1 < len W2 - 0 by REAL_1:92; then
    nm4 < len W2; then
    W2.((n-m)+1) = W.(m+(n-m)) by A1, Lm19; then
    W2.(len W2) = W.n by A3;
    hence W2.last() = W.n;
    hence thesis by A2, Def23;
end;

Lm21:
  for G be _Graph, W be Walk of G, m,n,o being odd Element of NAT
    st m <= n & n <= o & o <= len W holds
    W.cut(m,n).append(W.cut(n,o)) = W.cut(m,o) proof
    let G be _Graph, W be Walk of G, m,n,o be odd Element of NAT; assume
A1: m <= n & n <= o & o <= len W; then
A2: m <= o & n <= len W by XXREAL_0:2;
    set W1 = W.cut(m,n), W2 = W.cut(n,o), W3 = W.cut(m,o), W4 = W1.append(W2);
    now
    A3: W1.last() = W.n by A1,A2,Lm20
                 .= W2.first() by A1,Lm20;
    A4: len W1 + m = n + 1 by A1, A2, Lm19;
        len W2 + n = o + 1 by A1, Lm19; then
        len W1 + m + len W2 + n = o + 1 + 1 + n by A4; then
    A5: len W1 + len W2 + m = 1 + (o + 1);
        len W3 + m = o + 1 by A1, A2, Lm19; then
        len W1 + len W2 + m = 1 + len W3 + m by A5; then
    A6: len W1 + len W2 = 1 + len W3; then
    A7: len W4 + 1 = len W3 + 1 by A3, Lm13; then
    A8: len W4 = len W3;
        thus len W4 = len W4 & len W3 = len W4 by A7;
        let x be Element of NAT; assume x in Seg len W4; then
        x in dom W4 by FINSEQ_1:def 3; then
    A9: 1 <= x & x <= len W4 by FINSEQ_3:27; then
        reconsider xaa1 = x-1 as Element of NAT by INT_1:18;
        xaa1 < len W4 - 0 by A9, REAL_1:92; then
    A10: W3.(xaa1+1) = W.(m+xaa1) by A1, A2, A8, Lm19;
        now per cases;
        suppose
        A11: x <= len W1; then
        A12: xaa1 < len W1 - 0 by REAL_1:92;
        A13: x in dom W1 by A11, A9, FINSEQ_3:27;
            thus W4.x = W1.(xaa1+1) by A13,Lm16
                     .= W3.x by A1,A2,A12,Lm19,A10; end;
        suppose x > len W1; then consider k being Nat such that
        A14: len W1 + k = x by NAT_1:10;
        reconsider k as Element of NAT by ORDINAL1:def 13;
            len W1 + k + 1 <= len W3 + 1
              by A7,A9,A14,XREAL_1:9; then
            (k + 1)+len W1-len W1 <= len W2 +len W1-len W1
              by A6,REAL_1:92; then
        A15: k + 1 - 1 < len W2 + 1 - 1 by NAT_1:13; then
        A16: W4.x = W2.(k+1) by A3, A14, Lm17
                .= W.(n+k) by A1,A15,Lm19;
            n + k = m + xaa1 by  A4,A14;
            hence W4.x = W3.x by A16, A10; end;
        end;
        hence W4.x = W3.x;
    end;
    hence thesis by FINSEQ_2:10;
end;

Lm22:
  for G be _Graph, W be Walk of G holds W.cut(1,len W) = W proof
    let G be _Graph, W be Walk of G;
    1 is odd & 1 <= len W by JORDAN12:3, HEYTING3:1; then
    W.cut(1,len W) = (1,len W)-cut W by Def11;
    hence thesis by GRAPH_2:7;
end;


Lm23:
  for G be _Graph, W be Walk of G, n being odd Element of NAT st n <= len W
  holds
     W.cut(n,n) = <* W.vertexAt(n) *> proof
    let G be _Graph, W be Walk of G, n be odd Element of NAT; assume
A1: n <= len W; then
A2: W.cut(n,n) = (n,n)-cut W by Def11;
A3: W.n = W.vertexAt(n) by A1, Def8;
    1 <= n by HEYTING3:1;
    hence W.cut(n,n) = <* W.vertexAt(n) *> by A1, A2, A3, GRAPH_2:6;
end;

Lm24:
  for G being _Graph, W being Walk of G, m,n being Element of NAT holds
    m is odd & m <= n implies W.cut(1,n).cut(1,m) = W.cut(1,m) proof
    let G be _Graph, W be Walk of G, m,n be Element of NAT;
    set W1 = W.cut(1,n); assume
A1: m is odd & m <= n;
    now per cases;
    suppose
    A2: n is odd & n <= len W; then
    A3: 1 <= n & 1 <= m & m <= len W by HEYTING3:1, A1, XXREAL_0:2;
        len W1 + 1 = n + 1 by JORDAN12:3,Lm19,A2,A3; then
    A4: len W1 = n; then
    A5: W1.cut(1,m) = (1,m)-cut W1 by A1,A3,JORDAN12:3,Def11;
        len W1.cut(1,m) + 1 = m + 1 by A1,A3,JORDAN12:3,A4,Lm19; then
    A6: len W1.cut(1,m) = m;
        len W.cut(1,m) + 1 = m + 1 by A1,A3,JORDAN12:3,Lm19; then
    A7: len W.cut(1,m) = m;
    A8: W1 = (1,n)-cut W by A2,A3,JORDAN12:3,Def11;
    A9: W.cut(1,m) = (1,m)-cut W by A1, A3,JORDAN12:3, Def11;
    A10: len W.cut(1,m) + 1 = m + 1 by A1, A3,JORDAN12:3, Lm19;
        now let x be Element of NAT; assume x in Seg m; then
        A11: 1 <= x & x <= m by FINSEQ_1:3; then
            reconsider xaa1 = x-1 as Element of NAT by INT_1:18;
            x <= n by A1, A11, XXREAL_0:2; then
        A12: xaa1 < len W1 - 0 by A4, REAL_1:92;
        A13: xaa1 < len W1.cut(1,m) - 0 by A11, A6, REAL_1:92;
            x <= len W.cut(1,m) by A11, A10; then
        A14: xaa1 < len W.cut(1,m) - 0 by REAL_1:92;
        1 <= m by A11,XXREAL_0:2;
          hence W1.cut(1,m).x = W1.(1+xaa1) by A1,A4,A5,A13,GRAPH_2:def 1
                        .= W.(1+xaa1) by A2,A8,A12,GRAPH_2:def 1,A3
                        .= W.cut(1,m).x by A14,A3,A9,GRAPH_2:def 1;
        end;
        hence W1.cut(1,m) = W.cut(1,m) by A6, A7, FINSEQ_2:10; end;
    suppose not (n is odd & n <= len W);
        hence thesis by Def11; end;
    end;
    hence thesis;
end;

Lm25:
  for G be _Graph, W1,W2 be Walk of G, m,n being odd Element of NAT
    st m <= n & n <= len W1 & W1.last() = W2.first()
    holds W1.append(W2).cut(m,n) = W1.cut(m,n) proof
    let G be _Graph, W1,W2 be Walk of G, m,n be odd Element of NAT; assume
A1: m <= n & n <= len W1 & W1.last() = W2.first();
    set W3 = W1.append(W2);
    len W1 <= len W3 by A1, Lm14;  then
A2: n <= len W3 by A1, XXREAL_0:2; then
    len W3.cut(m,n) + m = n + 1 by A1, Lm19
                       .= len W1.cut(m,n) + m by A1, Lm19; then
A3: len W3.cut(m,n) = len W1.cut(m,n);
A4: W3.cut(m,n) = (m,n)-cut W3 by A1, A2, Def11;
A5: W1.cut(m,n) = (m,n)-cut W1 by A1, Def11;
A6: 1 <= m & m <= n by HEYTING3:1, A1;
    now let x be Element of NAT; assume x in Seg len W1.cut(m,n); then
        x in dom W1.cut(m,n) by FINSEQ_1:def 3; then
    A7: 1 <= x & x <= len W1.cut(m,n) by FINSEQ_3:27; then
        reconsider xaa1 = x-1 as Element of NAT by INT_1:18;
    A8: xaa1 + 1 = x;
    A9: xaa1 < len W3.cut(m,n) - 0 by A3,A7,REAL_1:92;
    A10: xaa1 < len W1.cut(m,n) - 0 by A7,REAL_1:92; then
    A11: W1.cut(m,n).x = W1.(m+xaa1) by A1,A5,A6,A8,GRAPH_2:def 1;
    A12: W3.cut(m,n).x = W3.(m+xaa1) by A2,A4,A6,A8,A9,GRAPH_2:def 1;
    A13: 1 <= m+xaa1 by A6, NAT_1:12;
        len W1.cut(m,n) + m = n + 1 by A1, Lm19; then
        m + xaa1 < n + 1 by A10, XREAL_1:10; then
        m + xaa1 <= n by NAT_1:13; then
        m+xaa1 <= len W1 by A1, XXREAL_0:2; then
        m+xaa1 in dom W1 by A13, FINSEQ_3:27;
        hence W3.cut(m,n).x = W1.cut(m,n).x by A11,A12,Lm16;
    end;
    hence thesis by A3, FINSEQ_2:10;
end;

Lm26:
  for G being _Graph, W being Walk of G, m being odd Element of NAT
  st m <= len W holds
     len W.cut(1,m) = m proof
    let G be _Graph, W be Walk of G, m be odd Element of NAT; assume
A1: m <= len W;
    1 is odd & 1 <= m by HEYTING3:1, JORDAN12:3; then
    len W.cut(1,m) + 1 = m + 1 by A1, Lm19;
    hence thesis;
end;

Lm27:
  for G be _Graph, W be Walk of G, m be odd Element of NAT, x be Element of NAT
    st x in dom W.cut(1,m) & m <= len W holds W.cut(1,m).x = W.x proof
    let G be _Graph, W be Walk of G, m be odd Element of NAT,
    x be Element of NAT; assume
A1: x in dom W.cut(1,m) & m <= len W; then
A2: 1 <= x & x <= len W.cut(1,m) by FINSEQ_3:27; then
    reconsider xaa1 = x-1 as Element of NAT by INT_1:18;
A3: xaa1 + 1 = x;
A4: 1 is odd & 1 <= m by HEYTING3:1, JORDAN12:3;
    x-1 < len W.cut(1,m) - 0 by A2, REAL_1:92;
    hence W.cut(1,m).x = W.x by A1,A3,A4,Lm19;
end;

Lm28:
  for G be _Graph, W be Walk of G, m,n be odd Element of NAT
    st m <= n & n <= len W & W.m = W.n holds
    len W.remove(m,n) + n = len W + m proof
    let G be _Graph, W be Walk of G, m, n be odd Element of NAT;
    set W1 = W.cut(1,m), W2 = W.cut(n,len W); assume
A1: m <= n & n <= len W & W.m = W.n; then
A2: 1 is odd & 1 <= m & m <= len W by HEYTING3:1, JORDAN12:3, XXREAL_0:2;
A3: W.remove(m,n) = W1.append(W2) by A1,Def12;
A4: W1.last() = W.n & W.n = W2.first() by A1, A2, Lm20;
    len W1 + 1 = m + 1 by A2, Lm19; then
A5: len W1 = m;
    len W2 + n = len W + 1 by A1, Lm19; then
    len W2 = len W + 1 - n; then
    len W1.append(W2) + 1 = m + (len W + 1 + -n) by A4,Lm13,A5
                         .= len W + m + -n + 1; then
    len W1.append(W2) = len W + m - n;
    hence thesis by A3;
end;

Lm29:
  for G be _Graph, W be Walk of G, m,n be Element of NAT, x,y be set holds
    W is_Walk_from x,y implies W.remove(m,n) is_Walk_from x,y proof
    let G be _Graph, W be Walk of G, m,n be Element of NAT, x,y be set;
    set W2 = W.remove(m,n), WA = W.cut(1,m), WB = W.cut(n,len W); assume
A1: W is_Walk_from x,y;
    now per cases;
    suppose
    A2: m is odd & n is odd & m <= n & n <= len W & W.m = W.n; then
    A3: 1 is odd & 1 <= m & m <= len W by HEYTING3:1,JORDAN12:3,XXREAL_0:2;
    A4: W2 = WA.append(WB) by A2, Def12;
    A5: WA.last() = W.n by A2, A3, Lm20
                 .= WB.first() by A2, Lm20;
    A6: WA.first() = W.first() by A2,A3,Lm20
                  .= x by A1, Def23;
        WB.last() = W.last() by A2,Lm20
                 .= y by A1, Def23;
        hence thesis by A4,A5,A6,Lm15; end;
    suppose not (m is odd & n is odd & m <= n & n <= len W & W.m = W.n);
       hence thesis by A1,Def12; end;
    end;
    hence thesis;
end;

Lm30:
  for G being _Graph, W being Walk of G, m,n be Element of NAT holds
    len W.remove(m,n) <= len W proof
    let G be _Graph, W be Walk of G, m,n be Element of NAT;
    set W2 = W.remove(m,n);
    now per cases;
    suppose
    A1: m is odd & n is odd & m <= n & n <= len W & W.m = W.n; then
        len W2 + n = len W + m by Lm28; then
        len W2 + n - n <= len W + m - m by A1, REAL_1:92;
        hence len W2 <= len W; end;
    suppose not (m is odd & n is odd & m <= n & n <= len W & W.m = W.n);
        hence len W2 <= len W by Def12; end;
    end;
    hence thesis;
end;

Lm31:
  for G be _Graph, W be Walk of G, m be Element of NAT
  holds W.remove(m,m) = W proof
    let G be _Graph, W be Walk of G, m be Element of NAT;
    now per cases;
    suppose
    A1: m is odd & m <= len W & W.m = W.m; then
    A2: 1 is odd & 1 <= m by HEYTING3:1, JORDAN12:3;
        thus W.remove(m,m) = W.cut(1,m).append(W.cut(m,len W)) by A1, Def12
                          .= W.cut(1,len W) by A1, A2, Lm21
                          .= W by Lm22; end;
    suppose not (m is odd & m <= len W & W.m = W.m);
        hence W.remove(m,m) = W by Def12; end;
    end;
    hence thesis;

end;

Lm32:
  for G being _Graph, W being Walk of G, m,n be odd Element of NAT
   st m <= n & n <= len W & W.m = W.n holds
     W.cut(1,m).last() = W.cut(n,len W).first() proof
    let G be _Graph, W be Walk of G, m,n be odd Element of NAT; assume
A1: m <= n & n <= len W & W.m = W.n; then
A2: m <= len W by XXREAL_0:2;
    1 <= m & 1 is odd by HEYTING3:1, JORDAN12:3;
    hence W.cut(1,m).last() = W.n by A1,A2,Lm20
                           .= W.cut(n,len W).first() by A1, Lm20;
end;

Lm33:
  for G be _Graph, W be Walk of G, x,y be set, m,n being odd Element of NAT
   st m <= n & n <= len W & W.m = W.n holds
     (for x being Element of NAT st x in Seg m holds W.remove(m,n).x = W.x)
     proof
    let G be _Graph, W be Walk of G, x,y be set, m, n be odd Element of NAT;
    set W2 = W.remove(m,n); assume
A1: m <= n & n <= len W & W.m = W.n; then
A2: W2 = W.cut(1,m).append(W.cut(n,len W)) by Def12;
A3: m <= len W by A1, XXREAL_0:2;
    let x be Element of NAT; assume x in Seg m; then
    1 <= x & x <= m by FINSEQ_1:3; then
    1 <= x & x <= len W.cut(1,m) by A3, Lm26; then
A4: x in dom W.cut(1,m) by FINSEQ_3:27;
    hence W2.x = W.cut(1,m).x by A2,Lm16
              .= W.x by A3,A4,Lm27;
end;

Lm34:
  for G be _Graph, W be Walk of G, m,n being odd Element of NAT
    st m <= n & n <= len W & W.m = W.n holds
     (for x being Element of NAT st m <= x & x <= len W.remove(m,n) holds
        W.remove(m,n).x = W.(x - m + n) &
        x - m + n is Element of NAT & x - m + n <= len W) proof
    let G be _Graph, W be Walk of G, m, n be odd Element of NAT;
    set W2 = W.remove(m,n), WA = W.cut(1,m), WB = W.cut(n,len W); assume
A1: m <= n & n <= len W & W.m = W.n; then
A2: W2 = WA.append(WB) by Def12;
A3: WA.last() = WB.first() by A1, Lm32;
    1 is odd & 1 <= m & m <= len W by HEYTING3:1,JORDAN12:3,A1,XXREAL_0:2; then
A4: len WA = m by Lm26;
A5: len WB + n = len W + 1 by A1, Lm19;
A6: len W2 + n = len W + m by A1, Lm28;
    let x be Element of NAT; assume
A7: m <= x & x <= len W2; then consider a being Nat such that
A8: len WA + a = x by A4, NAT_1:10;
    reconsider a as Element of NAT by ORDINAL1:def 13;
    m + a + n <= m + len W by A4,A6,A7,A8,XREAL_1:9; then
A9: a+n + m - m <= len W + m - m by REAL_1:92; then
    a + n + 1 <= len WB + n by A5, XREAL_1:9; then
    a + 1 + n - n <= len WB + n - n by REAL_1:92; then
A10: a + 1 - 1 < len WB + 1 - 1 by NAT_1:13; then
A11: W2.x = WB.(a+1) by A2,A3,A8,Lm17
        .= W.(a + n) by A1, A10, Lm19;
    thus W2.x = W.(x - m + n) by A11, A4, A8;
    a + n is Element of NAT;
    hence x-m+n is Element of NAT by A4, A8;
    thus x-m+n <= len W by A4, A8, A9;
end;

Lm35:
  for G be _Graph, W be Walk of G, m,n be odd Element of NAT
    st m <= n & n <= len W & W.m = W.n holds
    len W.remove(m,n) = len W + m - n proof
   let G be _Graph, W be Walk of G, m,n be odd Element of NAT; assume
   m <= n & n <= len W & W.m = W.n; then
   len W.remove(m,n) + n = len W + m by Lm28;
   hence thesis;
end;

Lm36:
  for G be _Graph, W be Walk of G, m being Element of NAT st W.first() = W.m
  holds
    W.remove(1,m) = W.cut(m, len W) proof
    let G be _Graph, W be Walk of G, m be Element of NAT;
    assume W.first() = W.m; then
A1: W.1 = W.m;
    now per cases;
    suppose
    A2: m is odd & m <= len W; then
        1 is odd & 1 <= m by JORDAN12:3, HEYTING3:1; then
    A3: W.remove(1,m) = W.cut(1,1).append(W.cut(m, len W))
          by A1,A2,Def12;
    A4: 1 <= len W by HEYTING3:1; then
    A5: W.cut(1,1).last() = W.m by A1,JORDAN12:3,Lm20
                         .= W.cut(m, len W).first() by A2,Lm20; then
        len W.remove(1,m) + 1 = len W.cut(1,1) + len W.cut(m, len W)
          by A3, Lm13; then
        len W.remove(1,m) + 1 = len W.cut(m, len W) + 1
          by JORDAN12:3,A4,Lm26; then
    A6: len W.remove(1,m) = len W.cut(m, len W);
        now let n be Element of NAT; assume 1 <= n & n <= len W.remove(1,m);
        then
        A7: n in dom W.remove(1,m) by FINSEQ_3:27;
            now per cases by A3, A7, Lm18;
              suppose
            A8: n in dom W.cut(1,1); then
            A9: 1 <= n & n <= len W.cut(1,1) by FINSEQ_3:27; then
            A10: n <= 1 by JORDAN12:3,A4,Lm26; then
            A11: n = 1 by A9, XXREAL_0:1;
                W.remove(1,m).n = W.cut(1,1).n by A3,A8,Lm16
                               .= <* W.vertexAt(1) *>.1
                                 by JORDAN12:3,A4,A11,Lm23
                               .= W.vertexAt(1) by FINSEQ_1:def 8
                               .= W.m by A1,JORDAN12:3,A4,Def8
                               .= W.cut(m, len W).first() by A2, Lm20
                               .= W.cut(m, len W).1;
                hence W.remove(1,m).n = W.cut(m, len W).n by A10,A9,XXREAL_0:1;
              end;
              suppose ex k being Element of NAT st k < len W.cut(m, len W) &
                    n = len W.cut(1,1) + k;
                    then consider k being Element of NAT such that
            A12: k < len W.cut(m, len W) & n = len W.cut(1,1) + k;
                n = k + 1 by A12,JORDAN12:3,A4, Lm26;
                hence W.remove(1,m).n = W.cut(m, len W).n
                  by A3,A5,A12,Lm17;
              end;
            end;
            hence W.remove(1,m).n = W.cut(m, len W).n;
        end;
        hence thesis by A6, FINSEQ_1:18; end;
    suppose
    A13: not (m is odd & m <= len W); then
        W.cut(m, len W) = W by Def11;
        hence thesis by A13, Def12; end;
    end;
    hence thesis;
end;

Lm37:
  for G be _Graph, W be Walk of G, m,n be Element of NAT holds
  W.remove(m,n).first() = W.first() &
    W.remove(m,n).last() = W.last() proof
    let G be _Graph, W be Walk of G, m,n be Element of NAT;
    W is_Walk_from W.first(), W.last() by Def23; then
    W.remove(m,n) is_Walk_from W.first(), W.last() by Lm29;
    hence thesis by Def23;
end;

Lm38:
 for G be _Graph, W be Walk of G, m,n being odd Element of NAT,
 x being Element of NAT
  st m <= n & n <= len W & W.m = W.n & x in dom W.remove(m,n) holds
     x in Seg m or (m <= x & x <= len W.remove(m,n)) proof
   let G be _Graph, W be Walk of G, m,n be odd Element of NAT,
   x be Element of NAT; assume
    m <= n & n <= len W & W.m = W.n & x in dom W.remove(m,n); then
    1 <= x & x <= len W.remove(m,n) by FINSEQ_3:27;
    hence thesis by FINSEQ_1:3;
end;

Lm39:
  for G be _Graph, W be Walk of G, e,x be set holds
  e Joins W.last(), x, G implies
  W.addEdge(e) = W^<*e,x*> proof
    let G be _Graph, W be Walk of G, e,x be set;
    set W1 = G.walkOf(W.last(), e, W.last().adj(e)); assume
A1: e Joins W.last(), x, G; then
    reconsider x'=x as Vertex of G by GLIB_000:16;
A2: W.last().adj(e) = x' by A1, GLIB_000:69; then
A3: W1 = <*W.last(), e, x*> by A1, Def5;
    W.last() = W1.first() by A1, A2, Lm8; then
A4: W.append(W1) = W ^' W1 by Def10
                .= W ^ (2,len W1)-cut W1 by GRAPH_2:def 2
                .= W ^ (2,3)-cut W1 by A3, FINSEQ_1:62;
A5: len W1 = 3 & W1.2 = e & W1.3 = x by A3, FINSEQ_1:62; then
    (2,2)-cut W1 = <*e*> & (3,3)-cut W1 = <*x*> by GRAPH_2:6; then
    <*e*> ^ (2+1,3)-cut W1 = (1+1,3)-cut W1 by A5, GRAPH_2:8; then
    <*e*> ^ <*x*> = (2,3)-cut W1 by A5, GRAPH_2:6; then
    W.append(G.walkOf(W.last(), e, x)) = W^<*e,x*> by A2, A4, FINSEQ_1:def 9;
    hence thesis by A2;
end;

Lm40:
  for G be _Graph, W be Walk of G, e,x be set holds
    e Joins W.last(),x,G implies
    W.addEdge(e).first() = W.first() & W.addEdge(e).last() = x &
  W.addEdge(e) is_Walk_from W.first(), x proof
    let G be _Graph, W be Walk of G, e,x be set;
    set W2 = G.walkOf(W.last(), e, W.last().adj(e)); assume
A1: e Joins W.last(), x, G; then
    reconsider x'=x as Vertex of G by GLIB_000:16;
    W.last().adj(e) = x' by A1, GLIB_000:69; then
    W2.first() = W.last() & W2.last() = x by A1, Lm8; then
    W.append(W2) is_Walk_from W.first(), x by Lm15; then
    W.addEdge(e) is_Walk_from W.first(), x;
    hence thesis by Def23;
end;

Lm41:
  for G be _Graph, W be Walk of G, e,x be set holds
  e Joins W.last(),x,G implies
  len W.addEdge(e) = len W + 2 proof
    let G be _Graph, W be Walk of G, e,x be set;
    set W2 = G.walkOf(W.last(),e, W.last().adj(e)); assume
A1: e Joins W.last(), x, G; then
    reconsider x'=x as Vertex of G by GLIB_000:16;
A2: W.last().adj(e) = x' by A1, GLIB_000:69; then
A3: W2 = <*W.last(), e, x*> by A1, Def5;
A4: W2.first() = W.last() by A1, A2, Lm8;
    len W.addEdge(e) + 1 = len W + len W2 by A4, Lm13; then
    len W.addEdge(e) + 1 = len W + 3 by A3, FINSEQ_1:62;
    hence len W.addEdge(e) = len W + 2;
end;

Lm42:
  for G be _Graph, W be Walk of G, e,x be set holds
  e Joins W.last(),x,G implies
  W.addEdge(e).(len W + 1) = e & W.addEdge(e).(len W + 2) = x &
  for n being Element of NAT st n in dom W holds W.addEdge(e).n = W.n proof
    let G be _Graph, W be Walk of G, e,x be set;
    set W2 = W.addEdge(e); assume
    e Joins W.last(), x, G; then
A1: W2 = W^<*e,x*> by Lm39;
A2: <*e,x*>.1 = e & <*e,x*>.2 = x by FINSEQ_1:61;
A3: dom <*e,x*> = Seg 2 by FINSEQ_3:29; then
    1 in dom <*e,x*> by FINSEQ_1:3;
    hence W2.(len W + 1) = e by A1, A2, FINSEQ_1:def 7;
    2 in dom <*e,x*> by A3, FINSEQ_1:3;
    hence W2.(len W + 2) = x by A1, A2, FINSEQ_1:def 7;
    let n be Element of NAT;
    assume n in dom W;
    hence thesis by A1, FINSEQ_1:def 7;
end;

Lm43:
  for G be _Graph, W be Walk of G, e,x,y,z be set holds
  W is_Walk_from x,y & e Joins y,z,G implies
  W.addEdge(e) is_Walk_from x,z proof
    let G be _Graph, W be Walk of G, e,x,y,z be set; assume
A1: W is_Walk_from x,y & e Joins y,z,G; then
    W.first() = x & W.last() = y by Def23;
    hence thesis by A1, Lm40;
end;

Lm44:
  for G being _Graph, W being Walk of G, n being even Element of NAT
    st 1 <= n & n <= len W holds
    n div 2 in dom W.edgeSeq() & W.n = W.edgeSeq().(n div 2) proof
    let G be _Graph, W be Walk of G, n be even Element of NAT; assume
A1: 1 <= n & n <= len W;
A2: 2 divides n by PEPIN:22; then
A3: n = 2 * (n div 2) by NAT_D:3;
A4: now assume
    A5: not n div 2 in dom W.edgeSeq();
        now per cases by A5,FINSEQ_3:27;
        suppose n div 2 < 0+1; then
            n div 2 <= 0 by NAT_1:13; then
            n div 2 = 0; then
            n = 2 * 0 by A2,NAT_D:3;
            hence contradiction by A1; end;
        suppose n div 2 > len W.edgeSeq(); then
            2 * (n div 2) > 2 * len W.edgeSeq() by XREAL_1:70; then
            n + 1 > 2 * len W.edgeSeq() + 1 by A3, XREAL_1:10; then
            n + 1 > len W by Def15; then
            n >= len W by NAT_1:13;
            hence contradiction by A1,REAL_1:def 5; end;
        end;
        hence contradiction;
    end;
    hence n div 2 in dom W.edgeSeq();
    1 <= n div 2 & n div 2 <= len W.edgeSeq() by A4,FINSEQ_3:27;
    hence thesis by A3,Def15;
end;

Lm45:
  for G being _Graph, W being Walk of G, n being Element of NAT holds
    n in dom W.edgeSeq() iff 2*n in dom W proof
    let G be _Graph, W be Walk of G, n be Element of NAT;
    hereby assume n in dom W.edgeSeq(); then
    A1: 1 <= n & n <= len W.edgeSeq() by FINSEQ_3:27; then
    A2: 1 <= n + n by NAT_1:12;
        2*n <= len W.edgeSeq()*2 by A1, NAT_1:4; then
        2*n <= len W.edgeSeq()*2 + 1 by NAT_1:12; then
        2*n <= len W by Def15;
        hence 2*n in dom W by A2,FINSEQ_3:27;
    end;
    assume 2*n in dom W; then
    1 <= 2*n & 2*n <= len W by FINSEQ_3:27; then
    2*n div 2 in dom W.edgeSeq() by Lm44;
    hence n in dom W.edgeSeq() by NAT_D:20;
end;

Lm46:
  for G be _Graph, W be Walk of G holds
  ex lenWaa1 being even Element of NAT st lenWaa1 = len W - 1 &
  len W.edgeSeq() = lenWaa1 div 2 proof
    let G be _Graph, W be Walk of G; set lenWaa1 = len W - 1;
    1 <= len W by HEYTING3:1; then
    reconsider lenWaa1 as even Element of NAT by INT_1:18;
    take lenWaa1;
    thus lenWaa1 = len W - 1;
A1: len W = 2*len W.edgeSeq()+1 by Def15;
    2 divides lenWaa1 by PEPIN:22; then
    lenWaa1 = 2 * (lenWaa1 div 2) by NAT_D:3;
    hence thesis by A1;
end;

Lm47:
  for G be _Graph, W be Walk of G, n be Element of NAT holds
   W.cut(1,n).edgeSeq() c= W.edgeSeq() proof
    let G be _Graph, W be Walk of G, n be Element of NAT;
    per cases;
    suppose
    A1: n is odd & 1 <= n & n <= len W;
        set f = W.cut(1,n).edgeSeq();
        now let e be set; assume
        A2: e in W.cut(1,n).edgeSeq(); then
            consider x,y being set such that
        A3: e = [x,y] by RELAT_1:def 1;
        A4: x in dom f & y = f.x by A2, A3, FUNCT_1:8; then
            reconsider x as Element of NAT;
            1 <= x & x <= len f by A4, FINSEQ_3:27; then
        A5: y = W.cut(1,n).(2*x) by A4, Def15;
        A6: 2*x in dom W.cut(1,n) by A4, Lm45; then
        A7: y = W.(2*x) by A1, A5, Lm27;
        A8: 1 <= 2*x & 2*x <= len W.cut(1,n) by A6, FINSEQ_3:27; then
            2*x <= n by A1, Lm26; then
            2*x <= len W by A1, XXREAL_0:2; then
            2*x in dom W by A8, FINSEQ_3:27; then
        A9: x in dom W.edgeSeq() by Lm45; then
            1 <= x & x <= len W.edgeSeq() by FINSEQ_3:27; then
            W.edgeSeq().x = y by A7, Def15;
            hence e in W.edgeSeq() by A3, A9, FUNCT_1:8;
        end;
        hence thesis by TARSKI:def 3;
        end;
    suppose not (n is odd & 1 <= n & n <= len W);
        hence thesis by Def11; end;
end;

Lm48:
  for G be _Graph, W be Walk of G, e,x be set holds
    e Joins W.last(),x,G implies
    W.addEdge(e).edgeSeq() = W.edgeSeq() ^ <*e*> proof
    let G be _Graph, W be Walk of G, e,x be set;
    set W2 = W.addEdge(e), W3 = W.edgeSeq() ^ <*e*>; assume
A1: e Joins W.last(),x,G; then
    len W2 = len W + 2 by Lm41; then
    len W + 2 = 2 * len W2.edgeSeq() + 1 by Def15; then
    2 + (2*len W.edgeSeq()+1) = 2*len W2.edgeSeq() + 1 by Def15; then
    2 + 2*len W.edgeSeq() + 1 = 2*len W2.edgeSeq() + 1; then
A2: 2*(len W.edgeSeq()+1) = 2*len W2.edgeSeq();
    len W3 = len W.edgeSeq() + len <*e*> by FINSEQ_1:35; then
    2*len W3 = 2*len W2.edgeSeq() by A2,FINSEQ_1:56; then
A3: len W3 = len W2.edgeSeq();
    now let k be Element of NAT; assume
    A4: 1 <= k & k <= len W2.edgeSeq(); then
    A5: k in dom W3 by A3, FINSEQ_3:27;
    A6: W2.edgeSeq().k = W2.(2*k) by A4, Def15;
        now per cases by A5, FINSEQ_1:38;
        suppose
        A7: k in dom W.edgeSeq(); then
        A8: W3.k = W.edgeSeq().k by FINSEQ_1:def 7;
            1 <= k & k <= len W.edgeSeq() by A7, FINSEQ_3:27; then
        A9: W3.k = W.(2*k) by A8, Def15;
            2*k in dom W by A7, Lm45;
            hence W2.edgeSeq().k = W3.k by A1,A6,A9,Lm42; end;
        suppose ex n being Element of NAT
        st n in dom <*e*> & k=len W.edgeSeq() + n;then
            consider n being Element of NAT such that
        A10: n in dom <*e*> & k = len W.edgeSeq() + n;
            n in {1} by FINSEQ_1:4,A10,FINSEQ_1:55; then
        A11: n = 1 by TARSKI:def 1; then
        A12: W3.k = <*e*>.1 by A10, FINSEQ_1:def 7
                .= e by FINSEQ_1:def 8;
            2*k = 2*len W.edgeSeq() + 1 + 1 by A10,A11
               .= len W + 1 by Def15;
            hence W2.edgeSeq().k = W3.k by A1,Lm42,A6, A12; end;
        end;
        hence W2.edgeSeq().k = W3.k;
    end;
    hence W2.edgeSeq() = W3 by A3, FINSEQ_1:18;
end;

Lm49:
  for G be _Graph, W be Walk of G, x be set holds
    x in W.vertices() iff
     ex n being odd Element of NAT st n <= len W & W.n = x proof
    let G be _Graph, W be Walk of G, x be set; set vs = W.vertexSeq();
    hereby assume x in W.vertices(); then
        x in rng vs; then consider i being Element of NAT such that
    A1: i in dom vs & vs.i = x by FINSEQ_2:11;
        set n1 = 2*i; reconsider n1 as even Element of NAT; set n = n1-1;
    A2: 1 <= i & i <= len vs by A1, FINSEQ_3:27;
        1 <= i+i by A2,NAT_1:12;
        then reconsider n as odd Element of NAT by INT_1:18;
        take n;
        i*2 <= len vs *2 by A2, XREAL_1:66; then
        i*2 <= len W + 1 by Def14; then
        n1 - 1 <= len W + 1 - 1 by REAL_1:92;
        hence n <= len W;
        thus W.n = x by A1,A2,Def14;
    end;
    assume ex n being odd Element of NAT st n <= len W & W.n = x; then
    consider n being odd Element of NAT such that
A3: n <= len W & W.n = x;
    set n1 = n+1; reconsider n1 as even Element of NAT;
    set i = n1 div 2;
A4: 2 divides n1 by PEPIN:22; then
A5: 2*i = n1 by NAT_D:3;
    reconsider i as Element of NAT;
    now 1 <= n by HEYTING3:1; then
        1+1 <= n1 by XREAL_1:9; then
        2*1 <= 2*i by A4,NAT_D:3; then
    A6: 1 <= i by Lm1;
        n1 <= len W + 1 by A3, XREAL_1:9; then
        2*i <= 2*len vs by A5, Def14; then
    A7: i <= len vs by Lm1;
        hence i in dom vs by A6, FINSEQ_3:27;
        thus vs.i = W.(2*i-1) by A6,A7,Def14
                 .= x by A3, A5;
    end; then
    x in rng vs by FUNCT_1:def 5;
    hence x in W.vertices();
end;

Lm50:
  for G be _Graph, W be Walk of G, e be set holds
    e in W.edges() iff
     ex n being even Element of NAT st 1 <= n & n <= len W & W.n = e proof
    let G be _Graph, W be Walk of G, e be set; set es = W.edgeSeq();
    hereby assume e in W.edges(); then
        e in rng es; then consider i being Element of NAT such that
    A1: i in dom es & es.i = e by FINSEQ_2:11;
        set n = 2*i; reconsider n as even Element of NAT;
    A2: 1 <= i & i <= len es by A1, FINSEQ_3:27;
        take n;
        1 <= i+i by A2, NAT_1:12;
        hence 1 <= n;
        i*2 <= len es * 2 by A2, XREAL_1:66; then
        n <= len es * 2 + 1 by NAT_1:12;
        hence n <= len W by Def15;
        thus W.n = e by A1,A2,Def15;
    end;
    assume ex n being even Element of NAT
    st 1 <= n & n <= len W & W.n = e; then
    consider n being even Element of NAT such that
A3: 1 <= n & n <= len W & W.n = e;
    set i = n div 2;
    2 divides n by PEPIN:22; then
A4: 2*i = n by NAT_D:3;
    reconsider i as Element of NAT;
    now 1 < n by A3, JORDAN12:3,REAL_1:def 5; then
        1+1 < n+1 by XREAL_1:10; then
        2*1 <= 2*i by NAT_1:13,A4; then
    A5: 1 <= i by Lm1;
        n < len W by A3, REAL_1:def 5; then
        2*i < 2*len es + 1 by A4, Def15; then
        2*i <= 2*len es by NAT_1:13; then
    A6: i <= len es by Lm1;
        hence i in dom es by A5, FINSEQ_3:27;
        thus es.i = e by A3, A4, A5, A6, Def15;
    end; then
    e in rng es by FUNCT_1:def 5;
    hence e in W.edges();
end;

Lm51:
  for G be _Graph, W be Walk of G, e be set holds
  e in W.edges() implies
  ex v1, v2 being Vertex of G, n being odd Element of NAT st
    n+2 <= len W & v1 = W.n & e = W.(n+1) & v2 = W.(n+2) &
    e Joins v1, v2,G proof
    let G be _Graph, W be Walk of G, e be set; assume
    e in W.edges(); then consider n1 being even Element of NAT such that
A1: 1 <= n1 & n1 <= len W & W.n1 = e by Lm50;
    reconsider n = n1-1 as odd Element of NAT by A1, INT_1:18;
    set v1 = W.n, v2 = W.(n+2);
    n1-1 <= len W - 0 by A1, REAL_1:92; then
    reconsider v1 as Vertex of G by Lm3;
    reconsider lenW = len W as odd Element of NAT;
    n1 < lenW by A1, REAL_1:def 5; then
A2: n+1+1 <= len W by NAT_1:13;
    reconsider v2 as Vertex of G by A2,Lm3;
    take v1, v2, n;
    thus n+2 <= len W by A2;
    thus v1 = W.n & e = W.(n+1) & v2 = W.(n+2) by A1;
    n+1-1 < len W - 0 by A1,REAL_1:92;
    hence e Joins v1, v2, G by A1, Def3;
end;

Lm52:
  for G be _Graph, W be Walk of G, e,x,y be set holds
  e in W.edges() & e Joins x,y,G implies
    x in W.vertices() & y in W.vertices() proof
    let G be _Graph, W be Walk of G, e,x,y be set; assume
A1: e in W.edges() & e Joins x,y,G; then
    consider v1,v2 being Vertex of G, n being odd Element of NAT such that
A2: n+2 <= len W & v1 = W.n & e = W.(n+1) & v2 = W.(n+2) &
      e Joins v1,v2,G by Lm51;
A3: v2 in W.vertices() by A2, Lm49;
    n+2-2 <= len W-0 by A2, REAL_1:92; then
    v1 in W.vertices() by A2, Lm49;
    hence thesis by A1,A2,A3,GLIB_000:18;
end;

Lm53:
  for G be _Graph, W be Walk of G holds len W = 2 * W.length() + 1
    by Def15;

Lm54:

  for G be _Graph, W be Walk of G, n be odd Element of NAT
    st n <= len W holds W.find(n) <= n proof
    let G be _Graph, W be Walk of G, n be odd Element of NAT; assume
A1: n <= len W; then
    W.find(n) <= len W & W.(W.find(n)) = W.n &
    for k being odd Element of NAT st k <= len W & W.k = W.n
    holds W.find(n) <= k
      by Def20;
    hence thesis by A1;
end;

Lm55:
  for G be _Graph, W be Walk of G, n being odd Element of NAT
    st n <= len W holds W.rfind(n) >= n proof
    let G be _Graph, W be Walk of G, n be odd Element of NAT; assume
A1: n <= len W; then
    W.rfind(n) <= len W & W.(W.rfind(n)) = W.n &
    for k being odd Element of NAT st k <= len W & W.k = W.n
    holds k <= W.rfind(n)
      by Def22;
    hence thesis by A1;
end;

Lm56:
  for G being _Graph, W being Walk of G holds W is directed iff
    for n being odd Element of NAT st n < len W
      holds W.(n+1) DJoins W.n, W.(n+2), G proof
    let G be _Graph, W be Walk of G;
    hereby assume
    A1: W is directed;
        let n be odd Element of NAT; assume
    A2: n < len W; then
    A3: W.(n+1) Joins W.n, W.(n+2), G by Def3;
    A4: W.n = (the_Source_of G).(W.(n+1)) by A1, A2, Def25;
        now assume
        A5: W.(n+1) DJoins W.(n+2), W.n, G; then
            W.(n+2) = W.n by GLIB_000:def 16, A4;
            hence W.(n+1) DJoins W.n, W.(n+2), G by A5;
        end;
        hence W.(n+1) DJoins W.n, W.(n+2), G by A3,GLIB_000:19;
    end;
    assume
A6: for n being odd Element of NAT st n < len W
holds W.(n+1) DJoins W.n, W.(n+2), G;
    now let n be odd Element of NAT; assume
        n < len W; then
        W.(n+1) DJoins W.n, W.(n+2), G by A6;
        hence (the_Source_of G).(W.(n+1)) = W.n by GLIB_000:def 16;
    end;
    hence W is directed by Def25;
end;

Lm57:
  for G be _Graph, W be Walk of G, x,e,y,z be set holds
    W is directed & W is_Walk_from x,y & e DJoins y,z,G
    implies W.addEdge(e) is directed & W.addEdge(e) is_Walk_from x,z proof
    let G be _Graph, W be Walk of G, x,e,y,z be set;
    set W2 = W.addEdge(e); assume
A1: W is directed & W is_Walk_from x,y & e DJoins y,z,G; then
A2: W.last() = y by Def23; then
A3: e Joins W.last(),z,G by A1, GLIB_000:19; then
A4: len W2 = len W + 2 by Lm41;
    1 <= len W by HEYTING3:1; then
    len W in dom W by FINSEQ_3:27; then
A5: W2.(len W) = y by  A3,Lm42,A2;
A6: W2.(len W + 1) = e by A3, Lm42;
    now let n be odd Element of NAT; assume n < len W2; then
        n < len W + 1+1 by A4; then
        n <= len W + 1 by NAT_1:13; then
        n < len W + 1 by REAL_1:def 5; then
    A7: n <= len W by NAT_1:13;
        now per cases;
          suppose n = len W;
            hence W2.n = (the_Source_of G).(W2.(n+1))
              by A1,A5,A6,GLIB_000:def 16;
          end;
          suppose n <> len W; then
        A8: n < len W by A7, REAL_1:def 5;
            1 <= n by HEYTING3:1; then
            n in dom W by A7,FINSEQ_3:27; then
        A9: W2.n = W.n by A3, Lm42;
        A10: 1 <= n+1 by NAT_1:12;
            n + 1 <= len W by A8,NAT_1:13; then
            n+1 in dom W by A10, FINSEQ_3:27; then
            W2.(n+1) = W.(n+1) by A3, Lm42;
            hence W2.n = (the_Source_of G).(W2.(n+1))
              by A1,A8,A9,Def25;
          end;
        end;
        hence W2.n = (the_Source_of G).(W2.(n+1));
    end;
    hence W.addEdge(e) is directed by Def25;
    thus W2 is_Walk_from x,z by A1,A2,A3,Lm43 ;
end;

Lm58:
  for G being _Graph, W being Walk of G, m,n being Element of NAT holds
    W is directed implies W.cut(m,n) is directed proof
    let G be _Graph, W be Walk of G, m, n be Element of NAT;
    set W2 = W.cut(m,n); assume
A1: W is directed;
    now per cases;
    suppose
    A2: m is odd & n is odd & m <= n & n <= len W; then
        reconsider m' = m as odd Element of NAT;
        now let x be odd Element of NAT; assume
        A3: x < len W2; then
        A4: W2.(x+1) = W.(m+x) & m+x in dom W by A2, Lm19;
            1 <= x by HEYTING3:1; then
            reconsider xaa1 = x - 1 as even Element of NAT by INT_1:18;
            xaa1 < len W2 - 0 by A3, REAL_1:92; then
        A5: W2.(xaa1+1) = W.(m+xaa1) & m+xaa1 in dom W by A2, Lm19;
            x + 1 <= len W2 by A3,NAT_1:13; then
        A6: x + 1 < len W2 by REAL_1:def 5;
             m'+x <= len W by A4, FINSEQ_3:27; then
        A7: m'+x-1 < len W - 0 by REAL_1:92;
        A8: W2.(x+1) = W.(m+x-1+1) by A3,A2,Lm19
                    .= W.(m+xaa1+1);
            W2.(x+2) = W2.(x+1+1)
                    .= W.(m+(x-1+1+1)) by A6,A2,Lm19
                    .= W.(m+xaa1+2);
            hence W2.(x+1) DJoins W2.x, W2.(x+2), G by A7,A1,Lm56,A8,A5;
        end;
        hence W2 is directed by Lm56; end;
    suppose not (m is odd & n is odd & m <= n & n <= len W);
        hence thesis by A1,Def11; end;
    end;
    hence thesis;
end;

Lm59:
  for G being _Graph, W being Walk of G holds
    W is non trivial iff 3 <= len W proof
    let G be _Graph, W be Walk of G;
    hereby assume W is non trivial; then
        W.length() <> 0 by Def26; then
        len W.edgeSeq() <> 0; then
        len W.edgeSeq() > 0; then
        0+1 <= len W.edgeSeq() by NAT_1:13; then
        2*1 <= 2*len W.edgeSeq() by NAT_1:4; then
        2+1 <= 2*len W.edgeSeq() + 1 by XREAL_1:9;
        hence 3 <= len W by Def15;
    end;
    assume 3 <= len W; then
    2*1 + 1 <= 2*len W.edgeSeq() + 1 by Def15; then
    len W.edgeSeq() <> 0; then
    W.length() <> 0;
    hence W is non trivial by Def26;
end;

Lm60:
  for G being _Graph, W being Walk of G holds
    W is non trivial iff len W <> 1 proof
    let G be _Graph, W be Walk of G;
    thus W is non trivial implies len W <> 1 by Lm59;
    assume
A1: len W <> 1;
    1 <= len W by HEYTING3:1; then
    1 < len W by A1, REAL_1:def 5; then
    1+1 <= len W by NAT_1:13; then
    2*1 < len W by REAL_1:def 5; then
    2*1+1 <= len W by NAT_1:13;
    hence W is non trivial by Lm59;
end;

Lm61:
  for G be _Graph, W be Walk of G holds
  W is trivial iff ex v being Vertex of G st W = G.walkOf(v) proof
    let G be _Graph, W be Walk of G;
    hereby assume W is trivial; then
    A1: len W = 1 by Lm60;
        take v = W.first();
        W = <*v*> by A1, FINSEQ_1:57;
        hence W = G.walkOf(v);
    end;
    given v being Vertex of G such that
A2: W = G.walkOf(v);
    W = <*v*> by A2; then
    len W = 1 by FINSEQ_1:56;
    hence W is trivial by Lm60;
end;

Lm62:
  for G being _Graph, W being Walk of G holds W is Trail-like iff
  for m,n being even Element of NAT st 1 <= m & m < n & n <= len W holds
    W.m <> W.n proof
    let G be _Graph, W be Walk of G;
    hereby assume W is Trail-like; then
    A1: W.edgeSeq() is one-to-one by Def27;
        let m, n be even Element of NAT; assume
    A2: 1 <= m & m < n & n <= len W; then
        m <= len W by XXREAL_0:2; then
    A3: m div 2 in dom W.edgeSeq() & W.m = W.edgeSeq().(m div 2)
          by A2, Lm44;
        1 <= n by A2, XXREAL_0:2; then
    A4: n div 2 in dom W.edgeSeq() & W.n = W.edgeSeq().(n div 2)
          by A2, Lm44;
        now assume
        A5: m div 2 = n div 2;
            2 divides m & 2 divides n by PEPIN:22; then
            2 * (m div 2) = m & 2 * (n div 2) = n by NAT_D:3;
            hence contradiction by A2,A5;
        end;
        hence W.m <> W.n by A1, A3, A4, FUNCT_1:def 8;
    end;
    assume
A6: for m,n being even Element of NAT st 1 <= m & m < n & n <= len W
holds W.m <> W.n;
    now let x1, x2 be set; assume
    A7: x1 in dom W.edgeSeq() & x2 in dom W.edgeSeq() &
          W.edgeSeq().x1 = W.edgeSeq().x2; then
        reconsider m = x1, n = x2 as Element of NAT;
        1 <= m & m <= len W.edgeSeq() by A7, FINSEQ_3:27; then
    A8: W.edgeSeq().x1 = W.(2*m) by Def15;
        1 <= n & n <= len W.edgeSeq() by A7, FINSEQ_3:27; then
    A9: W.(2*m) = W.(2*n) by A7, A8, Def15;
        2*m in dom W & 2*n in dom W by A7, Lm45; then
    A10: 1 <= 2*m & 2*m <= len W & 1 <= 2*n & 2*n <= len W by FINSEQ_3:27;
        now per cases by REAL_1:def 5;
        suppose 2*m < 2*n;
            hence x1 = x2 by A6, A10,A9; end;
        suppose 2*m = 2*n;
            hence x1 = x2; end;
        suppose 2*m > 2*n;
            hence x1 = x2 by A6,A10,A9; end;
        end;
        hence x1 = x2;
    end; then
    W.edgeSeq() is one-to-one by FUNCT_1:def 8;
    hence W is Trail-like by Def27;
end;

Lm63:
  for G being _Graph, W being Walk of G holds
    W is Trail-like iff W.reverse() is Trail-like proof
    let G be _Graph, W be Walk of G;
A1: now let W be Walk of G; assume
    A2: W is Trail-like;
        now let m, n be even Element of NAT; assume
        A3: 1 <= m & m < n & n <= len W.reverse(); then
            m <= len W.reverse() by XXREAL_0:2; then
            m in dom W.reverse() by A3, FINSEQ_3:27; then
        A4: W.reverse().m = W.(len W - m + 1) &
              len W - m + 1 in dom W by Lm11;
            1 <= n by A3, XXREAL_0:2; then
            n in dom W.reverse() by A3, FINSEQ_3:27; then
        A5: W.reverse().n = W.(len W - n + 1) &
              len W - n + 1 in dom W by Lm11;
            reconsider lenW = len W as odd Element of NAT;
            reconsider rn = lenW-n+1 as even Element of NAT by A5;
            reconsider rm = lenW-m+1 as even Element of NAT by A4;
            len W - n < len W - m by A3, REAL_1:92; then
        A6: len W - n + 1 < len W - m + 1 by XREAL_1:10;
            1 <= rn & rm <= len W by A4, A5, FINSEQ_3:27;
            hence W.reverse().m <> W.reverse().n
              by A4, A5, A2, A6, Lm62;
        end;
        hence W.reverse() is Trail-like by Lm62;
    end;
    thus W is Trail-like implies W.reverse() is Trail-like by A1;
    assume W.reverse() is Trail-like; then
    W.reverse().reverse() is Trail-like by A1;
    hence W is Trail-like by Lm12;
end;

Lm64:
  for G being _Graph, W being Walk of G, m,n being Element of NAT holds
    W is Trail-like implies W.cut(m,n) is Trail-like proof
    let G be _Graph, W be Walk of G, m,n be Element of NAT; assume
A1: W is Trail-like;
    now per cases;
      suppose
    A2: m is odd & n is odd & m <= n & n <= len W;
        now let x,y be even Element of NAT; assume
        A3: 1 <= x & x < y & y <= len W.cut(m,n);
            reconsider xaa1 = x-1 as odd Element of NAT by A3, INT_1:18;
            1 <= y by A3, XXREAL_0:2; then
            reconsider yaa1 = y-1 as odd Element of NAT by INT_1:18;
            reconsider m'=m, n'=n as odd Element of NAT by A2;
            x <= len W.cut(m,n) by A3, XXREAL_0:2; then
            x-1 < len W.cut(m,n)-0 by REAL_1:92; then
        A4: W.cut(m,n).(xaa1+1) = W.(m+xaa1) &
              m+xaa1 in dom W by A2, Lm19;
            y-1 < len W.cut(m,n)-0 by A3, REAL_1:92; then
        A5: W.cut(m,n).(yaa1+1) = W.(m+yaa1) &
               m+yaa1 in dom W by A2, Lm19;
        A6: m+yaa1 <= len W by A5, FINSEQ_3:27;
            1 <= m by A2, HEYTING3:1; then
        A7: 1 <= m+xaa1 by NAT_1:12;
            x - 1 < y - 1 by A3, REAL_1:92; then
            xaa1 + m < yaa1 + m by XREAL_1:10; then
            W.(m'+xaa1) <> W.(m'+yaa1) by A1, A6, A7, Lm62;
            hence W.cut(m,n).x <> W.cut(m,n).y by A4,A5;
        end;
        hence thesis by Lm62;
      end;
      suppose not (m is odd & n is odd & m <= n & n <= len W);
        hence thesis by A1,Def11;
      end;

    end;
    hence thesis;
end;

Lm65:
  for G be _Graph, W being Walk of G, e being set
    st W is Trail-like & e in W.last().edgesInOut() & not e in W.edges()
    holds W.addEdge(e) is Trail-like proof
    let G be _Graph, W be Walk of G, e be set; assume
A1: W is Trail-like & e in W.last().edgesInOut() & not e in W.edges(); then
A2: e Joins W.last(), W.last().adj(e),G by GLIB_000:70;
    set W2 = W.addEdge(e);
    reconsider lenW = len W, lenW2 = len W2 as odd Element of NAT;
    now let m,n be even Element of NAT; assume
    A3: 1 <= m & m < n & n <= len W2;
        now per cases;
        suppose
        A4: n <= len W;
            1 <= n by A3, XXREAL_0:2; then
            n in dom W by A4, FINSEQ_3:27; then
        A5: W2.n = W.n by A2, Lm42;
            m <= len W by A3, A4, XXREAL_0:2; then
            m in dom W by A3, FINSEQ_3:27; then
            W2.m = W.m by A2, Lm42;
            hence W2.m <> W2.n by A1, A3, A4, A5, Lm62; end;
        suppose n > len W; then
        A6: len W + 1 <= n by NAT_1:13;
            n < lenW2 by A3, REAL_1:def 5; then
            n+1 <= len W2 by NAT_1:13; then
            n+1-1 <= len W2 - 1 by REAL_1:92; then
            n <= len W + (1+1) - 1 by A2, Lm41; then
        A7: n = len W + 1 by A6, XXREAL_0:1; then
        A8: W2.n = e by A2, Lm42;
        A9: m + 1 - 1 <= len W + 1 - 1 by A3,A7,NAT_1:13; then
            m in dom W by A3, FINSEQ_3:27; then
            W2.m = W.m by A2, Lm42;
            hence W2.m <> W2.n by A1,A3,A8,A9,Lm50; end;
        end;
        hence W2.m <> W2.n;
    end;
    hence W2 is Trail-like by Lm62;
end;

Lm66:
  for G be _Graph, W be Walk of G holds
   len W <= 3 implies W is Trail-like proof
    let G be _Graph, W be Walk of G; assume
A1: len W <= 3;
    now per cases;
    suppose len W = 1; then
        W is trivial by Lm60; then consider v being Vertex of G such that
    A2: W = G.walkOf(v) by Lm61;
        thus W is Trail-like by A2, Lm6; end;
    suppose
    A3: len W <> 1;
        1 <= len W by HEYTING3:1; then
        1 < len W by A3, REAL_1:def 5; then
        1+2 <= len W by JORDAN12:3, Th1; then
    A4: len W = 3 by A1, XXREAL_0:1;
        now let m, n be even Element of NAT such that
        A5: 1 <= m & m < n & n <= len W;
            2*0+1 < m by A5, REAL_1:def 5; then
        A6: 1+1 <= m by NAT_1:13;
            n < 2+1 by A4, A5, REAL_1:def 5; then
            n <= 2 by NAT_1:13;
            hence W.m <> W.n by A5,A6,XXREAL_0:2;
        end;
        hence W is Trail-like by Lm62; end;
    end;
    hence thesis;
end;

Lm67:
  for G being _Graph, x,e,y being set holds
  e Joins x,y,G implies G.walkOf(x,e,y) is Path-like proof
    let G be _Graph, x,e,y be set; set W = G.walkOf(x,e,y); assume
A1: e Joins x,y,G; then
A2: len W = 3 by Lm7;
   now let m,n be even Element of NAT; assume
    A3: 1 <= m & m < n & n <= len W; then
        1 < m by JORDAN12:3, REAL_1:def 5; then
        1+1 <= m by NAT_1:13; then
    A4: 2 < n by A3, XXREAL_0:2;
        n <= 3 by A1,A3,Lm7; then
        n < 2*1+1 by REAL_1:def 5;
        hence W.m <> W.n by A4,NAT_1:13;
    end; then
A5: W is Trail-like by Lm62;
    now let m,n be odd Element of NAT; assume
    A6: m < n & n <= len W;  assume W.m = W.n;
    A7: 1 <= m by HEYTING3:1; then
        1 < n by A6, XXREAL_0:2; then
        1+1 < n+1 by XREAL_1:10; then
        2*1 <= n by NAT_1:13; then
        2*1 < n by REAL_1:def 5; then
        2+1 < n+1 by XREAL_1:10; then
    A8: 3 <= n by NAT_1:13; then
    A9: n = 3 by A2, A6, XXREAL_0:1;
        now assume m <> 1; then
            1 < m by A7, REAL_1:def 5; then
            1+1 < m+1 by XREAL_1:10; then
            2*1 <= m by NAT_1:13; then
            2*1 < m by REAL_1:def 5; then
            2+1 < m+1 by XREAL_1:10;
            hence contradiction by A6, A9, NAT_1:13;
        end;
        hence m = 1 & n = len W by A8,A2,A6,XXREAL_0:1;
    end;
    hence thesis by A5, Def28;
end;

Lm68:
  for G being _Graph, W being Walk of G holds
   W is Path-like iff W.reverse() is Path-like proof
    let G be _Graph, W be Walk of G;
A1: now let W be Walk of G; assume
    A2: W is Path-like; then
        W is Trail-like & for m, n being odd Element of NAT
        st m < n & n <= len W
          holds W.m = W.n implies (m = 1 & n = len W) by Def28; then
    A3: W.reverse() is Trail-like by Lm63;
        reconsider lenW=len W as odd Element of NAT;
        now let m, n be odd Element of NAT; assume
        A4: m < n & n <= len W.reverse() & W.reverse().m = W.reverse().n; then
        A5: m <= len W.reverse() by XXREAL_0:2;
            1 <= m by HEYTING3:1; then
        A6: m in dom W.reverse() by A5, FINSEQ_3:27; then
        A7: W.reverse().m = W.(len W - m + 1) & len W - m + 1 in dom W
              by Lm11; then
            reconsider rm = lenW-m+1 as odd Element of NAT;
            1 <= n by HEYTING3:1; then
            n in dom W.reverse() by A4, FINSEQ_3:27; then
        A8: W.reverse().n = W.(len W - n + 1) & len W - n + 1 in dom W
              by Lm11; then
            reconsider rn = lenW-n+1 as odd Element of NAT;
            lenW - n < len W - m by A4, REAL_1:92; then
        A9: rn < rm by XREAL_1:10;
        A10: rm <= len W by A7, FINSEQ_3:27;
        A11: W.rm = W.rn by A4, A6,Lm11, A8; then
        A12: rn = 1 & rm = len W by A2,Def28,A9,A10;
            len W + (1 + -m) = len W by A11,A2,Def28,A9,A10; then
            1 + -m + len W - len W = 0; then
            1 - m = 0;
            hence m = 1;
            len W - n + 1 - 1 = 0 by A12; then
            n = len W;
            hence n = len W.reverse() by Lm9;
        end;
        hence W.reverse() is Path-like by A3, Def28;
    end;
    thus W is Path-like implies W.reverse() is Path-like by A1;
    assume W.reverse() is Path-like; then
    W.reverse().reverse() is Path-like by A1;
    hence W is Path-like by Lm12;
end;

Lm69:
  for G being _Graph, W being Walk of G, m, n being Element of NAT
  st W is Path-like
     holds W.cut(m,n) is Path-like proof
    let G be _Graph, W be Walk of G, m, n be Element of NAT; assume
A1: W is Path-like;
    now per cases;
    suppose
    A2: m is odd & n is odd & m <= n & n <= len W; then
        reconsider m'=m, n'=n as odd Element of NAT;
        now W is Trail-like by A1,Def28;
            hence W.cut(m,n) is Trail-like by Lm64;
            let x,y be odd Element of NAT; assume
        A3: x < y & y <= len W.cut(m,n) & W.cut(m,n).x = W.cut(m,n).y;
            1 <= x by HEYTING3:1; then
            reconsider xaa1 = x-1 as even Element of NAT by INT_1:18;
            1 <= y by HEYTING3:1; then
            reconsider yaa1 = y-1 as even Element of NAT by INT_1:18;
            x <= len W.cut(m,n) by A3, XXREAL_0:2; then
            x-1 < len W.cut(m,n) - 0 by REAL_1:92; then
        A4: W.cut(m,n).(xaa1+1) = W.(m+xaa1) &
              m+xaa1 in dom W by A2, Lm19;
            y-1 < len W.cut(m,n) - 0 by A3, REAL_1:92; then
        A5: W.cut(m,n).(yaa1+1) = W.(m+yaa1) &
              m+yaa1 in dom W by A2, Lm19;
            x - 1 < y - 1 by A3, REAL_1:92; then
        A6: xaa1 + m < yaa1 + m by XREAL_1:10;
        A7: 1 <= m'+xaa1 & m'+yaa1 <= len W by A4, A5, FINSEQ_3:27; then
        A8: m'+xaa1 = 1 & m'+yaa1 = len W by A1,A3,A4,A5,A6,Def28;
        A9: now assume xaa1 <> 0; then
            A10: 0 < xaa1;
                1 <= m by A2, HEYTING3:1; then
                1+0 < m + xaa1 by A10, XREAL_1:10;
                hence contradiction by A7,A1,A3,A4,A5,A6,Def28;
            end;
            hence x = 1;
        A11: m + 1 - 1 = 1 by A7,A9,A1,A3,A4,A5,A6,Def28;
        A12: y = len W by A9,A8;
            len W.cut(m,n) + 1 = n + 1
              by A2,A11,Lm19; then
            len W.cut(m,n) + 1 - 1 = n;
            hence y = len W.cut(m,n) by A2,A12,A3,XXREAL_0:1;
        end;
        hence W.cut(m,n) is Path-like by Def28; end;
    suppose not (m is odd & n is odd & m <= n & n <= len W);
        hence thesis by A1,Def11; end;
    end;
    hence thesis;
end;

Lm70:
  for G being _Graph, W being Walk of G, e,v being set
   st W is Path-like & e Joins W.last(),v,G & not e in W.edges() &
      (W is trivial or W is open) &
     for n being odd Element of NAT st 1 < n & n <= len W holds W.n <> v holds
   W.addEdge(e) is Path-like proof
    let G be _Graph, W be Walk of G, e,v be set; assume
A1: W is Path-like & e Joins W.last(), v,G & not e in W.edges() &
      (W is trivial or W is open) &
      (for n being odd Element of NAT st 1 < n & n <= len W holds W.n <> v);
      then
A2: e in W.last().edgesInOut() by GLIB_000:65;
    set W2 = W.addEdge(e); reconsider lenW = len W as odd Element of NAT;
    now W is Trail-like by A1, Def28;
        hence W2 is Trail-like by A1, A2, Lm65;
        let m, n be odd Element of NAT; assume
    A3: m < n & n <= len W2 & W2.m = W2.n;
        now per cases by A1;
          suppose
        A4: W is open;
            now per cases;
              suppose
            A5: n <= len W; then
            A6: m <= len W by A3, XXREAL_0:2;
                1 <= m by HEYTING3:1; then
                m in dom W by A6, FINSEQ_3:27; then
            A7: W2.m = W.m by A1, Lm42;
                1 <= n by HEYTING3:1; then
                n in dom W by A5, FINSEQ_3:27; then
            A8: W.m = W.n by A3, A7,A1,Lm42; then
             m = 1 & n = len W by A1,A3, A5, Def28; then
                W.first() = W.last() by A8;
                hence m = 1 & n = len W2 by A4, Def24;
              end;
              suppose n > len W; then
                lenW + 1 <= n by NAT_1:13; then
                lenW + 1 < n by REAL_1:def 5; then
                lenW + 1 + 1 <= n by NAT_1:13; then
                len W + (1+1) <= n; then
            A9: len W2 <= n by A1, Lm41; then
                n = len W2 by A3, XXREAL_0:1; then
                W2.n = W2.(len W + 2) by A1, Lm41; then
            A10: W2.n = v by A1, Lm42;
                m < len W2 by A9,A3,XXREAL_0:1; then
                m < len W + (1 + 1) by A1, Lm41; then
                m < len W + 1 + 1; then
                m <= lenW + 1 by NAT_1:13; then
                m < lenW + 1 by REAL_1:def 5; then
            A11: m <= len W by NAT_1:13;
                1 <= m by HEYTING3:1; then
                m in dom W by A11, FINSEQ_3:27; then
            A12: W.m = v by A3, A10,A1,Lm42;
                now assume
                A13: m <> 1;
                    1 <= m by HEYTING3:1; then
                    1 < m by A13, REAL_1:def 5;
                    hence contradiction by A12,A11,A1;
                end;
                hence m = 1;
                thus n = len W2 by A9,A3,XXREAL_0:1;
              end;
            end;
            hence m = 1 & n = len W2;
          end;
          suppose W is trivial; then consider v being Vertex of G such that
        A14: W = G.walkOf(v) by Lm61;
            W = <*v*> by A14; then
            len W = 1 by FINSEQ_1:56; then
        A15: len W2 = 1 + 2 by A1, Lm41;
        A16: 1 <= m by HEYTING3:1; then
        A17: 1+1 <= m+1 by XREAL_1:9;
            m+1 <= n by A3, NAT_1:13; then
            2*1 <= n by A17, XXREAL_0:2; then
            2*1 < n by REAL_1:def 5; then
        A18: len W2 <= n by A15,NAT_1:13; then
            n = len W2 by A3, XXREAL_0:1; then
            m+1-1 <= 3-1 by A3,A15,NAT_1:13; then
            m < 2*1 by REAL_1:def 5; then
            m+1 <= 2 by NAT_1:13; then
            m+1-1 <= 2-1 by REAL_1:92;
            hence m = 1 & n = len W2 by A16,A18,A3,XXREAL_0:1;
          end;
        end;
        hence m = 1 & n = len W2;
    end;
    hence W.addEdge(e) is Path-like by Def28;
end;

Lm71:
  for G be _Graph, W be Walk of G holds
  (for m,n being odd Element of NAT st m <= len W & n <= len W & W.m = W.n
  holds m = n)
      implies W is Path-like proof
    let G be _Graph, W be Walk of G; assume
A1: for m,n being odd Element of NAT st m <= len W & n <= len W & W.m = W.n
holds m = n;
    now let m,n be even Element of NAT; assume
    A2: 1 <= m & m < n & n <= len W; then
        1 <= n & m <= len W by XXREAL_0:2; then
    A3: m in dom W & n in dom W by A2, FINSEQ_3:27;
        now assume
        A4: W.m = W.n;
            consider maa1 being odd Element of NAT such that
        A5: maa1 = m-1 & m-1 in dom W & m+1 in dom W &
            W.m Joins W.(maa1), W.(m+1), G by A3, Lm4;
            consider naa1 being odd Element of NAT such that
        A6: naa1 = n-1 & n-1 in dom W & n+1 in dom W &
            W.m Joins W.(naa1), W.(n+1), G by A4, A3, Lm4;
        A7: maa1 <= len W & m+1 <= len W by A5, FINSEQ_3:27;
        A8: naa1 <= len W & n+1 <= len W by A6, FINSEQ_3:27;
            now per cases by A5, A6, GLIB_000:18;
              suppose W.(naa1) = W.(maa1) & W.(n+1) = W.(m+1); then
                naa1 = maa1 by A1, A7, A8; then
                n = m by  A6,A5;
                hence contradiction by A2;
              end;
              suppose
            A9: W.(naa1) = W.(m+1) & W.(n+1) = W.(maa1); then
                naa1 = m+1 & n+1 = maa1 by A1,A7,A8; then
                n = m+1+1 by A6; then
                maa1 = m+(2+1) by A9,A1,A7,A8; then
                m = m+3+1 by A5; then
                m + 0 = m+(3+1);
                hence contradiction;
              end;
            end;
            hence contradiction;
        end;
        hence W.m <> W.n;
    end; then
A10: W is Trail-like by Lm62;
    now let m,n be odd Element of NAT; assume
    A11: m < n & n <= len W; then
    A12: m <= len W by XXREAL_0:2;
        assume W.m = W.n;
        hence m = 1 & n = len W by A11,A12,A1;
    end;
    hence W is Path-like by A10, Def28;
end;

Lm72:
  for G be _Graph, W be Walk of G holds
    (for n being odd Element of NAT st n <= len W holds W.rfind(n) = n)
    implies W is Path-like proof
    let G be _Graph, W be Walk of G; assume
A1: for n being odd Element of NAT st n <= len W holds W.rfind(n) = n;
    now let m,n be odd Element of NAT; assume
    A2: m <= len W & n <= len W & W.m = W.n; then
    A3: W.rfind(m) = m & W.rfind(n) = n by A1;
    A4: n <= m by A2,A3,Def22;
        m <= n by A2,A3,Def22;
        hence m = n by A4, XXREAL_0:1;
    end;
    hence W is Path-like by Lm71;
end;

Lm73:
  for G be _Graph, W being Walk of G, e, v being set st e Joins W.last(),v,G &
    W is Path-like &
    not v in W.vertices() & (W is trivial or W is open)
    holds W.addEdge(e) is Path-like proof
    let G be _Graph, W be Walk of G, e , v be set; assume
A1: e Joins W.last(),v,G & W is Path-like & not v in W.vertices() &
    (W is trivial or W is open);
A2: not e in W.edges() by A1,Lm52;
    for n being odd Element of NAT st 1 < n & n <= len W holds v <> W.n
      by A1,Lm49;
    hence thesis by A1, A2, Lm70;
end;

Lm74:
  for G be _Graph, W be Walk of G holds
  len W <= 3 implies W is Path-like proof
    let G be _Graph, W be Walk of G; assume
A1: len W <= 3;
    now per cases;
    suppose len W = 1; then
        W is trivial by Lm60; then consider v being Vertex of G such that
    A2: W = G.walkOf(v) by Lm61;
        thus W is Path-like by A2, Lm6; end;
    suppose
    A3: len W <> 1;
        1 <= len W by HEYTING3:1; then
        1 < len W by A3, REAL_1:def 5; then
        1+2 <= len W by JORDAN12:3, Th1; then
    A4: len W = 3 by A1, XXREAL_0:1;
    A5: W is Trail-like by A1, Lm66;
        now let m, n be odd Element of NAT; assume
        A6: m < n & n <= len W & W.m = W.n;
            m < 2*1+1 by A4, A6, XXREAL_0:2; then
            m+2 <= 3 by Th1; then
        A7: m+2-2 <= 3-2 by REAL_1:92;
        A8: 1 <= m by HEYTING3:1;
            hence m = 1 by A7,XXREAL_0:1;
            2*0+1 < n by A6,A8,XXREAL_0:2; then
            1+2 <= n by Th1;
            hence n = len W by A4,A6,XXREAL_0:1;
        end;
        hence W is Path-like by A5, Def28; end;
    end;
    hence thesis;
end;

registration let G be _Graph;
  cluster Path-like -> Trail-like Walk of G;
  correctness by Def28;
  cluster trivial -> Path-like Walk of G;
  correctness proof
    let W be Walk of G; assume
A1: W is trivial; then
    len W = 1 by Lm60; then
    2*len W.edgeSeq() + 1 = 0+1 by Def15; then
    2*len W.edgeSeq() = 0; then
    len W.edgeSeq() = 0; then
    W.edgeSeq() is one-to-one by FINSEQ_1:25; then
A2: W is Trail-like by Def27;
    now let m,n be odd Element of NAT; assume
    A3: m < n & n <= len W & W.m = W.n; then
        1 <= m & 1 <= n & n <= 1 by A1,Lm60,HEYTING3:1;
        hence m = 1 & n = len W by A3,XXREAL_0:1;
    end;
    hence thesis by A2, Def28;
  end;
  cluster trivial -> vertex-distinct Walk of G;
  coherence proof
    let W be Walk of G; assume
A4: W is trivial;
    now let m,n be odd Element of NAT;
    assume m <= len W & n <= len W & W.m = W.n; then
        m <= 1 & n <= 1 & 1 <= m & 1 <= n by A4,Lm60,HEYTING3:1; then
        m = 1 & n = 1 by XXREAL_0:1;
        hence m = n;
    end;
    hence W is vertex-distinct by Def29;
  end;
  cluster vertex-distinct -> Path-like Walk of G;
  coherence proof
    let W be Walk of G; assume W is vertex-distinct; then
    for m,n being odd Element of NAT st m <= len W & n <= len W & W.m = W.n
      holds m = n by Def29;
    hence W is Path-like by Lm71;
  end;
  cluster Circuit-like -> closed Trail-like non trivial Walk of G;
  correctness by Def30;
  cluster Cycle-like -> closed Path-like non trivial Walk of G;
  correctness by Def31;
end;

registration let G be _Graph;
  cluster closed directed trivial Walk of G;
  existence proof
    consider v being Vertex of G;
    take G.walkOf(v);
    thus thesis by Lm6;
  end;
end;

registration let G be _Graph;
  cluster vertex-distinct Walk of G;
  existence proof
    consider W being trivial Walk of G;
    take W;
    thus thesis;
  end;
end;

definition let G be _Graph;
  mode Trail of G is Trail-like Walk of G;
  mode Path  of G is Path-like  Walk of G;
end;

definition let G be _Graph;
  mode DWalk  of G is directed Walk of G;
  mode DTrail of G is directed Trail of G;
  mode DPath  of G is directed Path of G;
end;

registration let G be _Graph, v be Vertex of G;
  cluster G.walkOf(v) -> closed directed trivial;
  coherence by Lm6;
end;

registration let G be _Graph, x,e,y be set;
  cluster G.walkOf(x,e,y) -> Path-like;
  coherence proof
    set W = G.walkOf(x,e,y);
    now per cases;
    suppose e Joins x,y,G;
        hence thesis by Lm67; end;
    suppose not e Joins x,y,G; then
        W = G.walkOf(choose the_Vertices_of G) by Def5;
        hence thesis; end;
    end;
    hence thesis;
  end;
end;

registration let G be _Graph, x,e be set;
  cluster G.walkOf(x,e,x) -> closed;
  coherence proof
    set W = G.walkOf(x,e,x);
    now per cases;
    suppose e Joins x,x,G; then
        W.first() = x & W.last() = x by Lm8;
        hence W is closed by Def24; end;
    suppose not e Joins x,x,G; then
        W = G.walkOf(choose the_Vertices_of G) by Def5;
        hence thesis; end;
    end;
    hence thesis;
  end;
end;

registration let G be _Graph, W be closed Walk of G;
  cluster W.reverse() -> closed;
  coherence proof
    W is closed iff W.first() = W.last() by Def24; then
    W is closed iff W.reverse().last() = W.last() by Lm10; then
    W is closed iff W.reverse().last() = W.reverse().first() by Lm10;
    hence thesis by Def24;
  end;
end;

registration let G be _Graph, W be trivial Walk of G;
  cluster W.reverse() -> trivial;
  coherence proof
    len W = 1 by Lm60; then
    len W.reverse() = 1 by Lm9;
    hence thesis by Lm60;
  end;
end;

registration let G be _Graph, W be Trail of G;
  cluster W.reverse() -> Trail-like;
  coherence by Lm63;
end;

registration let G be _Graph, W be Path of G;
  cluster W.reverse() -> Path-like;
  coherence by Lm68;
end;

registration let G be _Graph, W1,W2 be closed Walk of G;
  cluster W1.append(W2) -> closed;
  coherence proof
    set W = W1.append(W2);
    now per cases;
    suppose
    A1: W1.last() = W2.first(); then
        W1.last() = W2.last() by Def24; then
        W1.first() = W2.last() by Def24
                  .= W.last() by A1,Lm15; then
        W.first() = W.last() by A1, Lm15;
        hence thesis by Def24; end;
    suppose W1.last() <> W2.first();
        hence thesis by Def10; end;
    end;
    hence thesis;
  end;
end;

registration let G be _Graph, W1,W2 be DWalk of G;
  cluster W1.append(W2) -> directed;
  coherence proof
    set W = W1.append(W2);
    now per cases;
    suppose
    A1: W1.last() = W2.first();
        now let n be odd Element of NAT; assume
        A2: n < len W;
            1 <= n by HEYTING3:1; then
        A3: n in dom W by A2, FINSEQ_3:27;
            now per cases by A3, Lm18;
            suppose
            A4: n in dom W1; then
            A5: W.n = W1.n by Lm16;
            A6: 1 <= n & n <= len W1 by A4, FINSEQ_3:27;
                now per cases by A6, REAL_1:def 5;
                  suppose
                A7: n < len W1; then
                    n+1 in dom W1 & n+2 in dom W1 by Lm5; then
                    W.(n+1) = W1.(n+1) & W.(n+2) = W1.(n+2) by Lm16;
                    hence W.(n+1) DJoins W.n, W.(n+2), G by A5,A7,Lm56;
                  end;
                  suppose
                A8: n = len W1; then
                A9: 0 < len W2 & n = len W1 + 0;
                    n + 1 < len W + 1 by A2, XREAL_1:10; then
                A10: 1 + n < len W2 + n by A1,A8,Lm13; then
                    1 <= len W2 by XREAL_1:8; then
                A11: 1 < len W2 & n+1 = len W1 + 1 by A8,A10,REAL_1:def 5; then
                A12: W.(n+1) = W2.(1+1) by A1,Lm17;
                    1+1 <= len W2 by A11,NAT_1:13; then
                    2*1 < len W2 & n+2 = len W1+2 by A8,REAL_1:def 5; then
                A13: W.(n+2) = W2.(2+1) by A1, Lm17;
                    W2.(2*0+1+1) DJoins W2.(2*0+1), W2.(2*0+1+2), G
                      by A11,Lm56;
                    hence W.(n+1) DJoins W.n, W.(n+2), G
                      by A9,A12,A13,A1,Lm17;
                  end;
                end;
                hence W.(n+1) DJoins W.n, W.(n+2), G; end;
              suppose ex k being Element of NAT st k < len W2 & n = len W1 + k;
              then
                consider k being Element of NAT such that
            A14: k < len W2 & n = len W1 + k;
                now assume k is odd; then
                    reconsider k' = k as odd Element of NAT;
                    n = len W1 + k' by A14;
                    hence contradiction;
                end; then reconsider k as even Element of NAT;
            A15: W.n = W2.(k+1) by A1, A14, Lm17;
                n + 1 < len W + 1 by A2, XREAL_1:10; then
                1 + (k + len W1) < len W2 + len W1
                  by A14,A1,Lm13; then
            A16: k + 1 + len W1 - len W1 < len W2 + len W1 - len W1
                  by REAL_1:92;
                k + 1 + 1 <= len W2 by A16,NAT_1:13; then
            A17: k + 1 + 1 < len W2 by REAL_1:def 5;
            A18: n + 1 + 1 = len W1 + ((k + 1) + 1) by A14;
            A19: W.(n+1) = W2.(k+1+1) by A1,A16,A14,Lm17;
                W2.(k+1+(1+1)) = W2.(k+1+1+1)
                              .= W.(n+(1+1)) by A1,A17,A18,Lm17;
                hence W.(n+1) DJoins W.n, W.(n+2), G by A15,A16,A19,Lm56;
              end;
            end;
            hence W.(n+1) DJoins W.n, W.(n+2), G;
        end;
        hence thesis by Lm56; end;
    suppose W1.last() <> W2.first();
        hence thesis by Def10; end;
    end;
    hence thesis;
  end;
end;

registration let G be _Graph, W1,W2 be trivial Walk of G;
  cluster W1.append(W2) -> trivial;
  coherence proof
    set W = W1.append(W2);
    now per cases;
    suppose W1.last() = W2.first(); then
        len W + 1 = len W1 + len W2 by Lm13
                 .= len W1 + 1 by Lm60
                 .= 1 + 1 by Lm60; then
        len W = 1;
        hence thesis by Lm60; end;
    suppose W1.last() <> W2.first();
        hence thesis by Def10; end;
    end;
    hence thesis;
  end;
end;

registration let G be _Graph, W be DWalk of G, m,n be Element of NAT;
  cluster W.cut(m,n) -> directed;
  coherence by Lm58;
end;

registration let G be _Graph, W be trivial Walk of G, m,n be Element of NAT;
  cluster W.cut(m,n) -> trivial;
  coherence proof
    set W2 = W.cut(m,n);
    now per cases;
    suppose
    A1: m is odd & n is odd & m <= n & n <= len W; then
    A2: len W2 + m = n + 1 by Lm19;
    A3: 1 <= m & 1 <= n & n <= 1 by A1, Lm60, HEYTING3:1; then
        n = 1 by XXREAL_0:1; then
        len W2 + 1 = 1 + 1 by A1,A2,A3,XXREAL_0:1; then
        len W2 = 1;
        hence thesis by Lm60; end;
    suppose not (m is odd & n is odd & m <= n & n <= len W);
        hence thesis by Def11; end;
    end;
    hence thesis;
  end;
end;

registration let G be _Graph, W be Trail of G, m,n be Element of NAT;
  cluster W.cut(m,n) -> Trail-like;
  coherence by Lm64;
end;

registration let G be _Graph, W be Path of G, m,n be Element of NAT;
  cluster W.cut(m,n) -> Path-like;
  coherence by Lm69;
end;

registration let G be _Graph, W be vertex-distinct Walk of G,
m,n be Element of NAT;
  cluster W.cut(m,n) -> vertex-distinct;
  coherence proof
    set W2 = W.cut(m,n);
    now per cases;
      suppose
    A1: m is odd & n is odd & m <= n & n <= len W; then
        reconsider m' = m as odd Element of NAT;
        now let a,b be odd Element of NAT; assume
        A2: a <= len W2 & b <= len W2 & W2.a = W2.b;
            1 <= a & 1 <= b by HEYTING3:1; then
            reconsider aaa1 = a-1, baa1 = b-1 as even Element of NAT
            by INT_1:18;
            aaa1 < len W2 - 0 & baa1 < len W2 - 0 by A2,REAL_1:92; then
        A3: W2.(aaa1+1) = W.(m+aaa1) & m+aaa1 in dom W &
              W2.(baa1+1) = W.(m+baa1) & m+baa1 in dom W by A1,Lm19; then
            m'+aaa1 <= len W & m' + baa1 <= len W by FINSEQ_3:27; then
            aaa1+m' = baa1 + m' by A3,A2,Def29; then
            aaa1 = baa1;
            hence a = b;
        end;
        hence thesis by Def29;
      end;
      suppose not (m is odd & n is odd & m <= n & n <= len W);
        hence thesis by Def11;
      end;
    end;
    hence thesis;
  end;
end;

registration let G be _Graph, W be closed Walk of G, m,n be Element of NAT;
  cluster W.remove(m,n) -> closed;
  coherence proof
    thus W.remove(m,n).first() = W.first() by Lm37
                              .= W.last() by Def24
                              .= W.remove(m,n).last() by Lm37;
  end;
end;

registration let G be _Graph, W be DWalk of G, m,n be Element of NAT;
  cluster W.remove(m,n) -> directed;
  coherence proof
    now per cases;
      suppose m is odd & n is odd & m <= n & n <= len W & W.m = W.n; then
        W.remove(m,n) = W.cut(1,m).append(W.cut(n,len W)) by Def12;
        hence thesis;
      end;
      suppose not (m is odd & n is odd & m <= n & n <= len W & W.m = W.n);
        hence thesis by Def12;
      end;
    end;
    hence thesis;
  end;
end;

registration let G be _Graph, W be trivial Walk of G, m,n be Element of NAT;
  cluster W.remove(m,n) -> trivial;
  coherence proof
    now per cases;
      suppose m is odd & n is odd & m <= n & n <= len W & W.m = W.n; then
        W.remove(m,n) = W.cut(1,m).append(W.cut(n,len W)) by Def12;
        hence thesis;
      end;
      suppose not (m is odd & n is odd & m <= n & n <= len W & W.m = W.n);
        hence thesis by Def12;
      end;
    end;
    hence thesis;
  end;
end;

registration let G be _Graph, W be Trail of G, m,n be Element of NAT;
  cluster W.remove(m,n) -> Trail-like;
  coherence proof
    set W2 = W.remove(m,n);
A1: len W2 <= len W by Lm30;
    now per cases;
    suppose
    A2: m is odd & n is odd & m <= n & n <= len W & W.m = W.n; then
        reconsider m'=m, n'=n as odd Element of NAT;
        now given a,b being even Element of NAT such that
        A3: 1 <= a & a < b & b <= len W2 & W2.a = W2.b;
            1 <= b & a <= len W2 by A3,XXREAL_0:2; then
        A4: a in dom W2 & b in dom W2 by A3,FINSEQ_3:27;
            now per cases by A2,A4,Lm38;
            suppose a in Seg m; then
            A5: W2.a = W.a by A2,Lm33;
                now per cases by A2,A4,Lm38;
                suppose b in Seg m; then
                A6: W2.b = W.b by A2,Lm33;
                    b <= len W by A1,A3,XXREAL_0:2;
                    hence contradiction by A3,A5,A6,Lm62; end;
                suppose
                A7: m <= b & b <= len W2; then
                    reconsider b2 = b-m'+n' as even Element of NAT by A2,Lm34;
                A8: W2.b = W.b2 & b2 <= len W by A7,A2,Lm34;
                    now per cases;
                    suppose a < b2;
                        hence contradiction by A3,A5,A8,Lm62; end;
                    suppose b2 <= a; then
                    A9:(n-m)+b-b <= a-b by REAL_1:92;
                        n-m >= m-m by A2,REAL_1:92; then
                    A10: 0 <= a-b by A9;
                        a-b < b-b by A3,REAL_1:92;
                        hence contradiction by A10; end;
                    end;
                    hence contradiction; end;
                end;
                hence contradiction; end;
            suppose
            A11: m <= a & a <= len W2;
                reconsider a2 = a-m'+n' as even Element of NAT by A11,A2,Lm34;
                reconsider nm4 = n'-m' as even Element of NAT by A2, INT_1:18;
            A12: W2.a = W.a2 & a2 <= len W by A11,A2,Lm34;
                now per cases by A2,A4,Lm38;
                  suppose b in Seg m; then
                    b <= m by FINSEQ_1:3;
                    hence contradiction by A11,A3,XXREAL_0:2;
                  end;
                  suppose
                A13: m <= b & b <= len W2;
                    reconsider b2 = b-m'+n' as even Element of NAT
                    by A13,A2,Lm34;
                A14: W2.b = W.b2 & b2 <= len W by A13,A2,Lm34;
                    now per cases;
                      suppose
                    A15: a2 < b2;
                        1 <= m' by HEYTING3:1; then
                        1 <= a by A11, XXREAL_0:2; then
                        1 <= a+nm4 by NAT_1:12;
                        hence contradiction by A3,A12,A14,A15,Lm62;
                      end;
                      suppose b2 <= a2; then
                        b + nm4 <= a + nm4;
                        hence contradiction by A3,XREAL_1:8;
                      end;
                    end;
                    hence contradiction; end;
                end;
                hence contradiction; end;
            end;
            hence contradiction;
        end;
        hence thesis by Lm62; end;
    suppose not (m is odd & n is odd & m <= n & n <= len W & W.m = W.n);
        hence thesis by Def12; end;
    end;
    hence thesis;
  end;
end;

registration let G be _Graph, W be Path of G, m,n be Element of NAT;
  cluster W.remove(m,n) -> Path-like;
  coherence proof
    set W2 = W.remove(m,n);
A1: len W2 <= len W by Lm30;
    now per cases;
    suppose
    A2: m is odd & n is odd & m <= n & n <= len W & W.m = W.n;
        reconsider m'=m, n'=n as odd Element of NAT by A2;
        now let x,y be odd Element of NAT; assume
        A3: x < y & y <= len W2 & W2.x = W2.y; then
        A4: 1 <= x & 1 <= y & x <= len W2 by HEYTING3:1, XXREAL_0:2; then
        A5: x in dom W2 & y in dom W2 by A3, FINSEQ_3:27;
        A6: x <= len W & y <= len W by A3, A4, A1, XXREAL_0:2;
            now per cases by A2,A5,Lm38;
            suppose x in Seg m; then
            A7: W2.x = W.x by A2,Lm33;
                now per cases by A2,A5,Lm38;
                  suppose y in Seg m; then
                    W2.y = W.y by A2,Lm33; then
                    x = 1 & y = len W by A3,A6,A7,Def28;
                    hence x = 1 & y = len W2 by A1,A3,XXREAL_0:1;
                  end;
                  suppose
                A8: m <= y & y <= len W2; then
                A9: W2.y = W.(y-m+n) & y-m+n is Element of NAT & y-m+n <= len W
                      by A2,Lm34;
                    reconsider y2 = y-m'+n' as odd Element of NAT
                    by A8,A2,Lm34;
                    y-m + n >= y-m+m by A2,XREAL_1:9; then
                A10: x < y2 & y2 <= len W by A3,A8,A2,Lm34,XXREAL_0:2; then
                    x = 1 & y2 = len W by A3,A7,A9,Def28; then
                    len W2 + n = y -m + n + m by A2,Lm28
                              .= y + n;
                    hence x = 1 & y = len W2
                      by A3,A7,A9,A10,Def28;
                  end;
                end;
                hence x = 1 & y = len W2; end;
            suppose
            A11: m <= x & x <= len W2; then
            A12: W2.x = W.(x-m+n) & x-m+n is Element of NAT & x-m+n <= len W
                  by A2,Lm34;
                reconsider x2 = x-m'+n' as odd Element of NAT by A11,A2,Lm34;
                now per cases by A2,A5,Lm38;
                  suppose y in Seg m; then
                    y <= m by FINSEQ_1:3;
                    hence x = 1 & y = len W2 by A3,A11,XXREAL_0:2;
                  end;
                  suppose
                A13: m <= y & y <= len W2; then
                A14: W2.y = W.(y-m+n) & y-m+n is Element of NAT &
                y-m+n <= len W
                      by A2,Lm34;
                    reconsider y2 = y-m'+n' as odd Element of NAT
                    by A13,A2,Lm34;
                    x + (n - m) < y + (n-m) by A3, XREAL_1:10; then
                A15: x2 < y2; then
                A16: x2 = 1 & y2 = len W by A3,A12,A14,Def28; then
                A17: len W2 + n = y -m + n + m by A2,Lm28
                              .= y + n;
                    reconsider xm4 = x-m as Element of NAT by A11, INT_1:18;
                    1 <= n' by HEYTING3:1; then
                    x2 - n' <= 1-1 by A16,REAL_1:92; then
                A18: xm4 = 0; then
                A19: x = m;
                A20: m <= 1 by A2,A15,A3,A12,A14,Def28,A18;
                    1 <= m' by HEYTING3:1;
                    hence x = 1 & y = len W2
                      by A17,A19,A20,XXREAL_0:1; end;
                end;
                hence x = 1 & y = len W2; end;
            end;
            hence x = 1 & y = len W2;
        end;
        hence thesis by Def28; end;
    suppose not (m is odd & n is odd & m <= n & n <= len W & W.m = W.n);
        hence thesis by Def12; end;
    end;
    hence thesis;
  end;
end;

definition let G be _Graph, W be Walk of G;
  mode Subwalk of W -> Walk of G means :Def32: ::dSUBWALK
    it is_Walk_from W.first(), W.last() &
    ex es being FinSubsequence of W.edgeSeq() st
      it.edgeSeq() = Seq es;
  existence proof
   take W;
   thus W is_Walk_from W.first(), W.last() by Def23;
::   reconsider fs = W.edgeSeq() as FinSubsequence;
   reconsider es = W.edgeSeq() as FinSubsequence of W.edgeSeq()
     by GRAPH_2:def 5;
   take es;
   thus W.edgeSeq() = Seq es by FINSEQ_3:125;
  end;
end;

Lm75:
  for G being _Graph, W being Walk of G holds W is Subwalk of W proof
    let G be _Graph, W be Walk of G;
A1: W is_Walk_from W.first(),W.last() by Def23;
::    reconsider fs = W.edgeSeq() as FinSubsequence;
    reconsider es = W.edgeSeq() as FinSubsequence of W.edgeSeq()
      by GRAPH_2:def 5;
    W.edgeSeq() = Seq es by FINSEQ_3:125;
    hence thesis by A1, Def32;
end;

Lm76:
  for G be _Graph, W1 be Walk of G, W2 be Subwalk of W1, W3 be Subwalk of W2
    holds W3 is Subwalk of W1 proof
    let G be _Graph, W1 be Walk of G, W2 be Subwalk of W1, W3 be Subwalk of W2;
    set fs  = W1.edgeSeq(),fs1 = W2.edgeSeq(),fs2 = W3.edgeSeq();
A1: W3 is_Walk_from W2.first(), W2.last() &
      ex fss1 being FinSubsequence of fs1 st fs2 = Seq fss1 by Def32;
    W2 is_Walk_from W1.first(), W1.last() &
      ex fss being FinSubsequence of fs st fs1 = Seq fss by Def32; then
A2: W2.first() = W1.first() & W2.last() = W1.last() by Def23;
    consider fss1 being FinSubsequence of fs1 such that
A3: fs2 = Seq fss1 by Def32;
    consider fss being FinSubsequence of fs such that
A4: fs1 = Seq fss by Def32;
    set fss2 = fss | rng((Sgm dom fss)|dom fss1);
    reconsider fss2 as FinSubsequence of fs by GRAPH_2:29;
    fs2 = Seq fss2 by A3, A4, GRAPH_2:30;

    hence W3 is Subwalk of W1 by A1,A2,Def32;
end;

Lm77:
  for G be _Graph, W1,W2 be Walk of G holds
    W1 is Subwalk of W2 implies
      len W1 <= len W2 proof
    let G be _Graph, W1,W2 be Walk of G; assume W1 is Subwalk of W2; then
    consider es being FinSubsequence of W2.edgeSeq() such that
A1: W1.edgeSeq() = Seq es by Def32;
    len W1.edgeSeq() <= len W2.edgeSeq() by A1, Th3; then
    2*len W1.edgeSeq() <= 2*len W2.edgeSeq() by XREAL_1:66; then
    2*len W1.edgeSeq()+1 <= 2*len W2.edgeSeq() + 1 by XREAL_1:9; then
    len W1 <= 2*len W2.edgeSeq() + 1 by Def15;
    hence thesis by Def15;
end;

definition let G be _Graph, W be Walk of G, m,n being Element of NAT;
  redefine func W.remove(m,n) -> Subwalk of W;
  coherence proof
    set W2 = W.remove(m,n), es1 = W2.edgeSeq();
    now per cases;
    suppose
    A1: m is odd & n is odd & m <= n & n <= len W & W.m = W.n;  then
        reconsider m'=m, n'=n as odd Element of NAT;
        W is_Walk_from W.first(), W.last() by Def23; then
    A2: W2 is_Walk_from W.first(), W.last() by Lm29;
        1 <= m by A1, HEYTING3:1; then
        reconsider maa1 = m'-1 as even Element of NAT by INT_1:18;
        reconsider lenWn4 = len W - n' as even Element of NAT by A1, INT_1:18;
        reconsider n1 = n'+1 as even Element of NAT;
        1 <= len W by HEYTING3:1; then
        reconsider lenWaa1 = len W - 1 as even Element of NAT by INT_1:18;
     2 divides maa1 & 2 divides lenWn4 & 2 divides lenWaa1 & 2 divides n1
          by PEPIN:22; then
    A3: maa1 = 2 * (maa1 div 2) & lenWn4 = 2 * (lenWn4 div 2) &
          lenWaa1 = 2 * (lenWaa1 div 2) & n1 = 2 * (n1 div 2) by NAT_D:3;
        set X = {x where x is Element of NAT : 1 <= x & x <= maa1 div 2};
        set Y = {x where x is Element of NAT :
        n1 div 2 <= x & x <= lenWaa1 div 2};
        set Z = X \/ Y, es = W.edgeSeq() | Z;
        now let x be set; assume
        A4: x in Z;
            now per cases by A4,XBOOLE_0:def 2;
            suppose x in X; then consider y being Element of NAT such that
            A5: y = x & 1 <= y & y <= maa1 div 2;
            A6: 1 <= y+y by A5, NAT_1:12;
                2*y <= maa1 by A3,A5,XREAL_1:66; then
                2*y <= maa1+1 by NAT_1:12; then
                2*y <= n by A1, XXREAL_0:2; then
                2*y <= len W by A1, XXREAL_0:2; then
                2*y in dom W by A6, FINSEQ_3:27;
                hence x in dom W.edgeSeq() by A5, Lm45; end;
            suppose x in Y; then consider y being Element of NAT such that
            A7: y = x & n1 div 2 <= y & y <= lenWaa1 div 2;
::                2 * (n1 div 2) <= 2 * y by D1, AXIOMS:25; then
            A8: n1 <= 2*y by A3, A7,XREAL_1:66;
                1 <= n1 by NAT_1:12; then
            A9: 1 <= 2*y by A8, XXREAL_0:2;
                2*y <= lenWaa1 by A3,A7,XREAL_1:66; then
                2*y <= lenWaa1+1 by NAT_1:12; then
                2*y in dom W by A9, FINSEQ_3:27;
                hence x in dom W.edgeSeq() by A7, Lm45; end;
            end;
            hence x in dom W.edgeSeq();
        end; then
    A10: Z c= dom W.edgeSeq() by TARSKI:def 3; then
    A11: dom W.edgeSeq() /\ Z = Z by XBOOLE_1:28; then
    A12: dom es = Z by RELAT_1:90;
    A13: Z c= Seg len W.edgeSeq() by A10, FINSEQ_1:def 3; then
    A14: X c= Seg len W.edgeSeq() & Y c= Seg len W.edgeSeq() by XBOOLE_1:11;
        reconsider Z as finite set by A10, FINSET_1:13;
        reconsider X,Y as finite set by A14, FINSET_1:13;
    A15: now let a,b be Element of NAT; assume
        A16: a in X & b in Y; then
            consider a' being Element of NAT such that
        A17: a'=a & 1 <= a' & a' <= maa1 div 2;
            consider b' being Element of NAT such that
        A18: b'=b & n1 div 2 <= b' & b' <= lenWaa1 div 2 by A16;
            2*a' <= maa1 by A3,A17,XREAL_1:66; then
            2*a' < maa1+1 by NAT_1:13; then
            2*a' < n by A1, XXREAL_0:2; then
        A19: 2*a'+0 < n+1 by XREAL_1:10;
        A20: n+1 <= 2*b' by A3,A18,XREAL_1:66; then
            2*a' < 2*b' by A19, XXREAL_0:2; then
            a' <= b' by Lm1;
            hence a < b by A17,A18,A20,A19,REAL_1:def 5;
        end;
        W.edgeSeq() is FinSubsequence of W.edgeSeq() by GRAPH_2:28; then
        reconsider es as FinSubsequence of W.edgeSeq() by GRAPH_2:29;
    A21: len W2 = 2*len W2.edgeSeq()+1 by Def15;
    A22: Seg len es1 = dom es1 by FINSEQ_1:def 3;
        set es2 = Seq es;
    A23: es2 = es * Sgm(dom es) by FINSEQ_1:def 14;
        dom es c= Seg len W.edgeSeq() by A11,RELAT_1:90,A13; then
        rng Sgm(dom es) = dom es by FINSEQ_1:def 13; then
    A24: dom es2 = dom Sgm(Z) by A23, A12, RELAT_1:46
               .= Seg card Z by A13, FINSEQ_3:45;
        len W + m - n = 2*len es1 + 1 by A21,A1,Lm35; then
        m + len W + -n = 2*len es1 + 1; then
    A25: 2 * len es1 = m - 1 + len W - n;
    A26: now per cases;
          suppose
        A27: maa1 div 2 = 0;
            now assume X <> {}; then consider x being set such that
            A28: x in X by XBOOLE_0:def 1;
                consider x' being Element of NAT such that
            A29: x' = x & 1 <= x' & x' <= maa1 div 2 by A28;
                thus contradiction by A29,A27;
            end;
            hence card X = maa1 div 2 by A27,CARD_1:78;
          end;
          suppose maa1 div 2 <> 0; then consider k being Nat such that
A30:      maa1 div 2 = k + 1 by NAT_1:6;
            reconsider k as Element of NAT by ORDINAL1:def 13;
            maa1 div 2 = k + 1 by A30;
            hence card X = maa1 div 2 by GRAPH_2:4;
          end;
        end;
    A31: now per cases;
          suppose
        A32: n1 div 2 > lenWaa1 div 2;
        A33: now assume Y <> {}; then consider x being set such that
            A34: x in Y by XBOOLE_0:def 1;
                consider x' being Element of NAT such that
            A35: x' = x & n1 div 2 <= x' & x' <= lenWaa1 div 2 by A34;
                thus contradiction by A32,A35,XXREAL_0:2;
            end;
            lenWaa1 < n+1 by A3,A32,XREAL_1:70; then
            lenWaa1 + 1 <= n+1 by NAT_1:13; then
            len W <= n'+1; then
            len W < n+1 by REAL_1:def 5; then
            len W <= n by NAT_1:13; then
            len W = n by A1, XXREAL_0:1; then
A36:          lenWn4 div 2 = 0 by NAT_2:4;
            card Y = 0 by A33,CARD_1:78;
            hence card Y = lenWn4 div 2 by A36;
          end;
        suppose n1 div 2 <= lenWaa1 div 2; then
            reconsider k = (lenWaa1 div 2) - (n1 div 2) as Element of NAT
            by INT_1:18;
            Y = {x where x is Element of NAT:
            n1 div 2 <= x & x <= n1 div 2 + k};
            then
            card Y = k+1 by GRAPH_2:4; then
            2 * card Y = lenWn4 by A3; then
            lenWn4 = 2 * card Y + 0 & 0 < 2;
            hence card Y = lenWn4 div 2 by NAT_D:def 1;
          end;
        end;
        now assume not X /\ Y = {}; then consider x being set such that
        A37: x in X /\ Y by XBOOLE_0:def 1;
        A38: x in X & x in Y by A37, XBOOLE_0:def 3; then
            consider x' being Element of NAT such that
        A39: x' = x & 1 <= x' & x' <= maa1 div 2;
            consider y' being Element of NAT such that
        A40: y' = x & n1 div 2 <= y' & y' <= lenWaa1 div 2 by A38;
            2*x' <= maa1 by A3,A39,XREAL_1:66; then
            2*y' < maa1+1 by A39,A40,NAT_1:13; then
            2*y' < n by A1,XXREAL_0:2; then
            2*y'+0 < n+1 by XREAL_1:10;
            hence contradiction by A3,A40,XREAL_1:66;
        end; then
    A41: X misses Y by XBOOLE_0:def 7;
        card Z = (maa1 div 2) + (lenWn4 div 2) by A26, A31,A41,CARD_2:53; then
        card Z * 2 = 2 * len es1 by A3,A25; then
    A42: dom es1 = dom es2 by A22,A24;
    A43: dom Sgm X = Seg (maa1 div 2) by A14, A26, FINSEQ_3:45;
    A44: dom Sgm Y = Seg (lenWn4 div 2) by A14, A31, FINSEQ_3:45;
    A45: X = {x where x is Element of NAT : 0+1 <= x & x <= 0+(maa1 div 2)};
        now assume n1 div 2 < 1; then
            2*(n1 div 2) < 2*1 by XREAL_1:70; then
            n + 1 - 1 < 2 - 1 by A3,REAL_1:92; then
            n' < 1;
            hence contradiction by HEYTING3:1;
        end; then reconsider n1div2aa1 = (n1 div 2) - 1 as Element of NAT
        by INT_1:18;
        set lenY = lenWaa1 div 2 - n1div2aa1;
        now assume n1div2aa1 > lenWaa1 div 2; then
            2*n1div2aa1 > 2 * (lenWaa1 div 2) by XREAL_1:70; then
            n1 - 2*1 > lenWaa1 by A3; then
        A46: n+1 - 1 - 1 > len W - 1; then
            n+1 - 1 >= len W by XREAL_1:11;
            hence contradiction by A1,A46,REAL_1:def 5;
        end; then reconsider lenY as Element of NAT by INT_1:18;
    A47: Y = {x where x is Element of NAT:
    n1div2aa1+1 <= x & x <= n1div2aa1+lenY};
    A48: len (Sgm X) = maa1 div 2 by A43, FINSEQ_1:def 3;
        2*lenY = lenWn4 by A3; then
        lenWn4 = 2 * lenY + 0 & 0 < 2; then
    A49: lenY = lenWn4 div 2 by NAT_D:def 1;
        now let x' be set; assume
        A50: x' in dom es1; then reconsider x = x' as Element of NAT;
        A51: 1 <= x & x <= len es1 by A50, FINSEQ_3:27; then
        A52: es1.x = W2.(2*x) by Def15;
            now per cases;
              suppose
            A53: 2*x+1 <= m; then
            A54: 2*x+1-1 < m - 0 by REAL_1:92;
                1 <= x+x by A51, NAT_1:12; then
                2*x in Seg m by A54, FINSEQ_1:3; then
            A55: es1.x' = W.(2*x) by A1, A52, Lm33;
            A56: Sgm(Z).x = (Sgm(X) ^ Sgm(Y)).x by A15,A14,FINSEQ_3:48;
                2*x+1-1 <= maa1 by A53, REAL_1:92; then
            A57: x <= maa1 div 2 by A3,XREAL_1:70; then
                x in dom Sgm X by A43,A51,FINSEQ_1:3; then
                Sgm(Z).x = Sgm(X).x by A56, FINSEQ_1:def 7
                        .= 0+x by A45,GRAPH_2:5,A51, A57; then
            A58: es2.x = es.x by A12,A23,A42,A50,FUNCT_1:22;
                x in X by A51, A57; then
            A59: x in dom es by A12, XBOOLE_0:def 2; then
            A60: es2.x = W.edgeSeq().x by A58, FUNCT_1:70;
                x <= len W.edgeSeq() by A12,A13,A59,FINSEQ_1:3;
                hence es1.x' = es2.x' by A51,A60,A55,Def15;
              end;
              suppose
            A61: 2*x+1 > m; then
            A62: m <= 2*x by NAT_1:13;
                2*x <= 2*len es1 by A51, XREAL_1:66; then
                2*x <= 2*len es1 + 1 by NAT_1:12; then
            A63: 2*x <= len W2 by Def15; then
            A64: es1.x' = W.(2*x-m+n) & 2*x-m+n is Element of NAT &
            2*x-m+n <= len W
                  by A1, A52, A62, Lm34;
            A65: Sgm(Z).x = (Sgm(X) ^ Sgm(Y)).x by A15,A14,FINSEQ_3:48;
            A66: now assume x <= maa1 div 2; then
                    2*x <= maa1 by A3,XREAL_1:66; then
                    2*x+1 <= maa1+1 by XREAL_1:9;
                    hence contradiction by A61;
                end; then consider k being Nat such that
            A67: x = maa1 div 2 + k by NAT_1:10;
            reconsider k as Element of NAT by ORDINAL1:def 13;
                k <> 0 by A67,A66; then
                0 < k; then
                0+1 < k+1 by XREAL_1:10; then
            A68: 1 <= k by NAT_1:13;
            A69: now assume lenWn4 div 2 < x - (maa1 div 2); then
            2 * (lenWn4 div 2) < 2*(x - (maa1 div 2)) by XREAL_1:70; then
                    lenWn4 < 2*x - maa1 by A3; then
                A70: lenWn4 + n < 2*x - m + 1 + n by XREAL_1:10;
                    set z = 2*x-m'+n';
                    reconsider z as Element of NAT by A1,A62,A63,Lm34;
                    2*x-m'+n' < len W by A64, REAL_1:def 5; then
                    z+1 <= len W by NAT_1:13;
                    hence contradiction by A70;
                end; then
                k in dom Sgm(Y) by A44,A67,A68,FINSEQ_1:3; then
                Sgm(Z).x = Sgm(Y).k by A48, A65, A67, FINSEQ_1:def 7
                        .= n1div2aa1 + k by A67,A68, A69, A47, GRAPH_2:5,A49;
then
            A71: es2.x = es.(n1div2aa1 + k) by A12,A23,A42,A50,FUNCT_1:22;
            A72: 1 <= n1div2aa1+k by A68, NAT_1:12;
            A73: n1div2aa1 + 1 <= n1div2aa1 + k by A68, XREAL_1:9;
            A74: now assume lenWaa1 div 2 < k + n1div2aa1; then
                    lenWaa1 < 2*(x - (maa1 div 2) + n1div2aa1)
                      by A3,A67,XREAL_1:70; then
                    lenWaa1 < 2*(x- (maa1 div 2)) + 2*(n1div2aa1); then
                    lenWaa1 < (2*x - maa1) + 2*(n1div2aa1) by A3;
                    then
                    lenWaa1 < 2*x - maa1 + (n1 - 2*1) by A3; then
                A75: lenWaa1 + 1 < 2*x-m+n+1 by XREAL_1:10;
                    reconsider z = 2*x-m'+n' as Element of NAT
                    by A63,A1,A62,Lm34;
                    len W <= z by A75, NAT_1:13;
                    hence contradiction by A64,REAL_1:def 5;
                end; then
                n1div2aa1 + k in Y by A73; then
                n1div2aa1+k in dom es by A12,XBOOLE_0:def 2; then
            A76: es.(n1div2aa1+k) = W.edgeSeq().(n1div2aa1+k) by FUNCT_1:70;
                consider lenWaa1' being even Element of NAT such that
            A77: lenWaa1' = lenWaa1 & len W.edgeSeq() = lenWaa1' div 2
                  by Lm46;
            A78: es2.x = W.(2*(n1div2aa1+k)) by A71,A72,A74,A76,A77,Def15;
                2*(n1div2aa1 + k) = 2*x - m + n by  A67,A3;
                hence es1.x' = es2.x' by A63,A1,A52,A62,Lm34,A78; end;
            end;
            hence es1.x' = es2.x';
        end; then
        W2.edgeSeq() = Seq es by A42, FUNCT_1:9;
        hence W.remove(m,n) is Subwalk of W by A2, Def32; end;
    suppose not (m is odd & n is odd & m <= n & n <= len W & W.m = W.n); then
        W.remove(m,n) = W by Def12;
        hence thesis by Lm75; end;
    end;
    hence thesis;
  end;
end;

registration let G be _Graph, W be Walk of G;
  cluster Trail-like Path-like Subwalk of W;
  existence proof
    defpred P1[Element of NAT,set,set] means
      ($2 is Walk of G & ex Wn being Walk of G st Wn = $2 &
      $3 = Wn.remove(Wn.find(2*$1+1),Wn.rfind(2*$1+1))) or
      (not $2 is Walk of G & $3 = $2);
A1: now let n be Element of NAT, x be set;
        now per cases;
        suppose x is Walk of G; then reconsider W = x as Walk of G;
            set y = W.remove(W.find(2*n+1),W.rfind(2*n+1));
            P1[n,x,y];
            hence ex y being set st P1[n,x,y]; end;
        suppose not x is Walk of G;
            hence ex y being set st P1[n,x,y]; end;
        end;
        hence ex y being set st P1[n,x,y];
    end;
A2: for n being Element of NAT, x,y1,y2 being set st P1[n,x,y1] & P1[n,x,y2]
holds y1=y2;
    consider f being Function such that
A3: dom f = NAT & f.0 = W &
    for n being Element of NAT holds P1[n,f.n,f.(n+1)]
      from RECDEF_1:sch 1(A1,A2);
    defpred P2[Element of NAT] means f.$1 is Subwalk of W;
A4: P2[0] by A3, Lm75;
    now let n be Element of NAT; assume
    A5: f.n is Subwalk of W; then consider Wn being Walk of G such that
    A6: Wn = f.n &
        f.(n+1) = Wn.remove(Wn.find(2*n+1),Wn.rfind(2*n+1)) by A3;
        thus f.(n+1) is Subwalk of W by A5, A6, Lm76;
    end; then
A7: for n being Element of NAT st P2[n] holds P2[n+1];
    for n being Element of NAT holds P2[n] from NAT_1:sch 1(A4,A7); then
    reconsider W0 = f.0 as Subwalk of W;
    defpred P3[Element of NAT] means
      ex Wn being Subwalk of W st Wn = f.$1 & len Wn <= len W &
      for m being odd Element of NAT st m < 2*$1+1 &  m <= len Wn
        holds Wn.rfind(m) = m;
    for m being odd Element of NAT st m < 2*0+1 & m <= len W0
    holds W0.rfind(m) = m
      by HEYTING3:1; then
A8: P3[0] by A3;
    now let n be Element of NAT; assume P3[n]; then
        consider Wn being Subwalk of W such that
    A9: Wn = f.n & len Wn <= len W &
          for m being odd Element of NAT st m < 2*n+1 & m <= len Wn
          holds Wn.rfind(m) = m;
        set a = Wn.find(2*n+1), b = Wn.rfind(2*n+1);
        set Wn1 = Wn.remove(a,b);
        reconsider Wn1 as Subwalk of W by Lm76;
        take Wn1;
        P1[n,f.n,f.(n+1)] by A3;
        hence f.(n+1) = Wn1 by A9;
        len Wn1 <= len Wn by Lm30;
        hence len Wn1 <= len W by A9, XXREAL_0:2;
        let m be odd Element of NAT; set m' = Wn1.rfind(m); assume
    A10: m < 2*(n+1)+1 & m <= len Wn1; then
        m <= 2*(n+1) by NAT_1:13; then
        m < 2*n+1+1 by REAL_1:def 5; then
    A11: m <= 2*n+1 by NAT_1:13;
    A12: len Wn1 <= len Wn by Lm30; then
    A13: m <= len Wn by A10, XXREAL_0:2;
        set W1 = Wn.cut(1,a), W2 = Wn.cut(b, len Wn);
        now per cases;
          suppose
        A14: 2*n+1 <= len Wn; then
        A15: a <= len Wn & Wn.a = Wn.(2*n+1) & for k being odd Element of NAT
        st
              k <= len Wn & Wn.k = Wn.(2*n+1) holds a <= k by Def20;
        A16: b <= len Wn & Wn.b = Wn.(2*n+1) & for k being odd Element of NAT
        st
              k <= len Wn & Wn.k = Wn.(2*n+1) holds k <= b by A14, Def22;
        A17: a <= 2*n+1 & 2*n+1 <= b by A14, Lm54, Lm55; then
        A18: a <= b by XXREAL_0:2; then
        A19: Wn1 = W1.append(W2) by A15,A16,Def12;
        A20: now assume
            A21: a < 2*n+1; then
                a <= len Wn by A14, XXREAL_0:2; then
                Wn.rfind(a) = a by A21, A9;
                hence contradiction by A14, A15, A21, Def22;
            end; then
        A22: a = 2*n+1 by A17, XXREAL_0:1;
        A23: 1 is odd & 1 <= a & 1 <= m by JORDAN12:3, HEYTING3:1;
        A24: W1.last() = Wn.(2*n+1) by A15, A23, Lm20
                     .= W2.first() by A16, Lm20;
            set m' = Wn1.rfind(m);
        A25: m' >= m by A10, Lm55;
        A26: m' <= len Wn1 & Wn1.m' = Wn1.m & for k being odd Element of NAT st
              k <= len Wn1 & Wn1.k = Wn1.m holds k <= m' by A10, Def22; then
        A27: m' <= len Wn by A12, XXREAL_0:2;
            now per cases by A11, XXREAL_0:1;
              suppose
            A28: m < 2*n+1; then
            A29: Wn.rfind(m) = m by A9, A13;
                m < len Wn.cut(1,a) by A14, A22, A28, Lm26; then
            A30: Wn1.cut(1,m) = Wn.cut(1,a).cut(1,m) by A19, A23, A24, Lm25
                            .= Wn.cut(1,m) by A11, A22, Lm24;
                reconsider maa1 = m - 1 as Element of NAT by A23, INT_1:18;
            A31: maa1 + 1 = m;
            A32: maa1 < m - 0 by REAL_1:92; then
                maa1 < len Wn1.cut(1,m) by A10, Lm26; then
            A33: Wn1.m = Wn.cut(1,m).m by A30,A31,A23,A10,Lm19;
                maa1 < len Wn.cut(1,m) by A13, A32, Lm26; then
            A34: Wn1.m = Wn.m by A13, A23,A31,A33,Lm19;
                now per cases;
                  suppose
                A35: m' < a; then
                A36: m' < len Wn.cut(1,a) by A15, Lm26;
                A37: 1 <= m' by HEYTING3:1; then
                A38: Wn1.cut(1,m') = Wn.cut(1,a).cut(1,m')
                                     by A19,JORDAN12:3,A24,A36,Lm25
                                 .= Wn.cut(1,m') by A35, Lm24;
                    reconsider m'aa1 = m' - 1 as Element of NAT
                    by A37, INT_1:18;
                A39: m'aa1 < m' - 0 by REAL_1:92; then
                    m'aa1 < len Wn1.cut(1,m') by A26, Lm26; then
                A40: Wn1.m' = Wn.cut(1,m').(m'aa1+1)
                      by A38,JORDAN12:3,A26,A37,Lm19;
                    m'aa1 < len Wn.cut(1,m') by A39, A27, Lm26; then
                    Wn.m' = Wn.m
                      by A26,JORDAN12:3,A27,A34,A37,A40,Lm19; then
                    m' <= m by A29,A13,Def22,A27;
                    hence Wn1.rfind(m) = m by A25, XXREAL_0:1;
                  end;
                  suppose
                A41: a <= m'; set x = m' - a + b;
                A42: Wn1.m' = Wn.x & x is Element of NAT & x <= len Wn
                      by A18, A15, A16, A26, A41, Lm34;
                    reconsider x as Element of NAT by A18,A15,A16,A26,A41,Lm34;
                A43: x <= m by A29,A13,Def22,A42,A26,A34;
                    m' + a <= m' + b by A18, XREAL_1:9; then
                    m' + a - a <= m' + b - a by REAL_1:92; then
                    m' <= m by A43, XXREAL_0:2;
                    hence Wn1.rfind(m) = m by A25, XXREAL_0:1;
                  end;
                end;
                hence Wn1.rfind(m) = m;
              end;
              suppose
            A44: m = 2*n+1; then
                m <= len Wn.cut(1,a) by A14,A22,Lm26; then
            A45: Wn1.cut(1,m) = Wn.cut(1,a).cut(1,m) by A19, A23, A24, Lm25
                            .= Wn.cut(1,m) by A11, A22, Lm24;
                reconsider maa1 = m - 1 as Element of NAT by A23, INT_1:18;
            A46: maa1 + 1 = m;
            A47: maa1 < m - 0 by REAL_1:92; then
                maa1 < len Wn1.cut(1,m) by A10, Lm26; then
            A48: Wn1.m = Wn.cut(1,m).m by A45,A23,A10,A46,Lm19;
                maa1 < len Wn.cut(1,m) by A13, A47, Lm26; then
            A49: Wn1.m = Wn.m by A13, A23,A46,A48,Lm19;
                now assume
                A50: m < m'; then
                A51: a < m' by A20,A17,XXREAL_0:1,A44; set x = m' - a + b;
                    Wn1.m' = Wn.x & x is Element of NAT & x <= len Wn
                      by A18, A15, A16, A26, A51, Lm34; then
                    m' - a + b <= b by A44,A49,A14,Def22,A26; then
                    m' - a + b - b <= b - b by REAL_1:92; then
                    m' - a + a <= 0 + a by XREAL_1:9;
                    hence contradiction by A50,A20,A17,XXREAL_0:1,A44;
                end;
                hence Wn1.rfind(m) = m by A25, XXREAL_0:1; end;
            end;
            hence Wn1.rfind(m) = m; end;
        suppose
        A52: len Wn < 2*n+1; then
            a = len Wn & b = len Wn by Def20, Def22; then
        A53: Wn1 = Wn by Lm31;
            m < 2*n+1 by A13, A52, XXREAL_0:2;
            hence Wn1.rfind(m) = m by A53,A9,A10; end;
        end;
        hence Wn1.rfind(m) = m;
    end; then
A54: for n being Element of NAT st P3[n] holds P3[n+1];
A55: for n being Element of NAT holds P3[n] from NAT_1:sch 1(A8,A54);
    set n = len W + 1;
    consider P being Subwalk of W such that
A56: P = f.n & len P <= len W &
    for m being odd Element of NAT st m < 2*n+1 & m <= len P
      holds P.rfind(m) = m by A55;
    take P;
    now let m be odd Element of NAT; assume
    A57: m <= len P;
    A58: len P + 0 < n by A56, XREAL_1:10;
        len P + 0 < n+n by A58, XREAL_1:10; then
        len P + 0 < 2*n+1 by XREAL_1:10; then
        m < 2*n+1 by A57, XXREAL_0:2;
        hence P.rfind(m) = m by A56, A57;
    end; then
    P is Path-like by Lm72;
    hence P is Trail-like & P is Path-like by Def28;
  end;
end;

definition let G be _Graph, W be Walk of G;
   mode Trail of W is Trail-like Subwalk of W;
   mode Path of W is Path-like Subwalk of W;
end;

registration let G be _Graph, W be DWalk of G;
  cluster directed Path of W;
  existence proof
    defpred P[Element of NAT] means
      for W1 being DWalk of G st W1.length() = $1 holds
       ex W2 being Path of W1 st W2 is directed;
    now let W1 be DWalk of G; assume W1.length() = 0; then
    A1: len W1 = 2*0+1 by Lm53;
        consider W2 being Path of W1;
        take W2;
    A2: len W2 <= 1 by A1, Lm77;
        1 <= len W2 by HEYTING3:1; then
        len W2 = 1 by A2, XXREAL_0:1; then
        W2 is trivial by Lm60; then
        consider v being Vertex of G such that
    A3: W2 = G.walkOf(v) by Lm61;
        thus W2 is directed by A3;
    end; then
A4: P[0];
    now let k be Element of NAT; assume
    A5: P[k];
        let W1 be DWalk of G; assume
    A6: W1.length() = k + 1; then
    A7: len W1 = 2*(k+1)+1 by Lm53
              .= 2*k+1+2; then
    A8: 2*k+1+2-2 < len W1 - 0 by REAL_1:92;
        set WA = W1.cut(1,2*k+1);
        len WA = 2*k+1 by A8, Lm26; then
        2*k+1 = 2*WA.length()+1 by Lm53; then
        2*k = 2*WA.length(); then
    A9: WA.length() = k; then
        consider WB being Path of WA such that
    A10: WB is directed by A5;
        set e = W1.(2*k+1+1), v = W1.(2*k+1+2);
    A11: e DJoins W1.(2*k+1), v, G by A8, Lm56;
    A12: WB is_Walk_from WA.first(), WA.last() by Def32;
        1 is odd & 1 <= 2*k+1 by JORDAN12:3, NAT_1:12; then
    A13: WA.first() = W1.1 & WA.last() = W1.(2*k+1) by A8, Lm20; then
    A14: WB.first() = W1.1 & WB.last() = W1.(2*k+1) by A12, Def23; then
    A15: e Joins WB.last(), v, G by A11, GLIB_000:19;
    A16: WA.edgeSeq() c= W1.edgeSeq() by Lm47;
        now per cases;
          suppose WB is closed; then
            W1.1 = W1.(2*k+1) by A14, Def24; then
        A17: W1.first() = W1.(2*k+1);
            set W2 = W1.remove(1,2*k+1);
            W2 = W1.cut(2*k+1, 2*k+1+2) by A7, A17, Lm36; then
            len W2 + (2*k+1) = 2*k+1+2+1 by A7,A8,Lm19
                            .= 2*k+1+(2+1); then
            len W2 = 3; then
            reconsider W2 as Path of W1 by Lm74;
            take W2;
            thus W2 is directed;
          end;
          suppose
        A18: WB is open;
            consider esb being FinSubsequence of WA.edgeSeq() such that
        A19: WB.edgeSeq() = Seq esb by Def32;
        A20: esb c= WA.edgeSeq() by GRAPH_2:def 5;
        A21: now let x be set; assume
                x in dom esb; then
                [x,esb.x] in esb by FUNCT_1:8; then
                x in dom WA.edgeSeq() by FUNCT_1:8,A20; then
                x in Seg len WA.edgeSeq() by FINSEQ_1:def 3;
                hence x in Seg k by A9;
            end; then
        A22: dom esb c= Seg k by TARSKI:def 3;
        A23: Seq esb = esb * (Sgm (dom esb)) by FINSEQ_1:def 14;
        A24: Seq esb is one-to-one by A19, Def27;
            rng Sgm(dom esb) = dom esb by A22, FINSEQ_1:def 13; then
        A25: esb is one-to-one & Sgm(dom esb) is one-to-one by A23,A24,FUNCT_1:
48;
            now per cases;
              suppose v in WB.vertices(); then
                consider n being odd Element of NAT such that
            A26: n <= len WB & WB.n = v by Lm49;
                reconsider WB' = WB as directed Path of G by A10;
                set W2 = WB'.cut(1,n);
                2*0+1 <= n by HEYTING3:1; then
                W2 is_Walk_from WB.1, v by A26,Lm20; then
                W2 is_Walk_from W1.1, v by  A14; then
                W2 is_Walk_from W1.1, W1.last() by A7; then
            A27: W2 is_Walk_from W1.first(), W1.last();
                len W2 = n by A26, Lm26; then
                consider naa1 being even Element of NAT such that
            A28: naa1 = n - 1 & len W2.edgeSeq() = naa1 div 2 by Lm46;
                set es = esb | (rng (Sgm (dom esb) | Seg (naa1 div 2)));
                reconsider es as FinSubsequence of WA.edgeSeq() by GRAPH_2:29;
            A29: es c= WA.edgeSeq() by GRAPH_2:def 5;
                for x being set st x in es holds x in W1.edgeSeq()
                  by A16, A29, TARSKI:def 3; then
                es c= W1.edgeSeq() by TARSKI:def 3; then
                reconsider es as FinSubsequence of W1.edgeSeq()
                  by GRAPH_2:def 5;
            A30: W2.edgeSeq() c= WB.edgeSeq() by Lm47;
            A31: Seq es = es * Sgm (dom es) by FINSEQ_1:def 14;
            A32: es c= esb by RELAT_1:88;
                now let z be set;
                    hereby assume
                    A33: z in esb;
                        now per cases;
                        suppose z in es;
                            hence z in es \/ (esb \ es) by XBOOLE_0:def 2; end;
                        suppose not z in es; then
                            z in esb \ es by A33, XBOOLE_0:def 4;
                            hence z in es \/ (esb \ es) by XBOOLE_0:def 2; end;
                        end;
                        hence z in es \/ (esb \ es);
                    end;
                    assume
                A34: z in es \/ (esb \ es);
                    now per cases by A34, XBOOLE_0:def 2;
                    suppose z in es;
                       hence z in esb by A32; end;
                    suppose z in esb \ es;
                       hence z in esb; end;
                    end;
                    hence z in esb;
                end; then
                esb = es \/ (esb \ es) by TARSKI:2; then
            A35: dom esb = dom es \/ dom (esb \ es) by RELAT_1:13;
                dom (esb \ es) c= dom esb by RELAT_1:25; then
            A36: dom (esb \ es) c= Seg k by A22, XBOOLE_1:1;
                dom es c= dom esb by A32, RELAT_1:25; then
            A37: dom es c= Seg k by A22, XBOOLE_1:1;
                now let z be set; assume
                A38: z in rng (Sgm (dom esb) | Seg (naa1 div 2));
                    rng (Sgm (dom esb) | Seg (naa1 div 2)) c= rng Sgm (dom esb)
                      by RELAT_1:99; then
                    z in rng Sgm (dom esb) by A38;
                    hence z in dom esb by A22, FINSEQ_1:def 13;
                end; then
                rng (Sgm (dom esb) | Seg (naa1 div 2)) c= dom esb
                  by TARSKI:def 3; then
            A39: dom es = rng (Sgm (dom esb) | Seg (naa1 div 2)) by RELAT_1:91;
                2 divides naa1 by PEPIN:22; then
            A40: 2*(naa1 div 2) = naa1 by NAT_D:3;
            A41: dom Sgm(dom esb) = dom WB.edgeSeq() by A19, Th6
                                .= Seg len WB.edgeSeq() by FINSEQ_1:def 3;
                now assume naa1 div 2 > len WB.edgeSeq(); then
                    naa1 > 2 * len WB.edgeSeq() by A40,XREAL_1:70; then
                    naa1+1 > 2*len WB.edgeSeq() + 1 by XREAL_1:10;
                    hence contradiction by A26,A28,Def15;
                end; then
                Seg (naa1 div 2) c= dom Sgm (dom esb) by A41, FINSEQ_1:7; then
            A42: dom (Sgm(dom esb)| Seg(naa1 div 2)) = Seg (naa1 div 2)
                  by RELAT_1:91; then
                reconsider ses = Sgm(dom esb)|Seg(naa1 div 2) as FinSequence
                  by FINSEQ_1:def 2;
            A43: len ses = naa1 div 2 by A42, FINSEQ_1:def 3;
                ses is one-to-one by A25,FUNCT_1:84; then
                card dom es = naa1 div 2 by A39,A43,FINSEQ_4:77; then
                card es = naa1 div 2 by Lm2; then
            A44: len Seq es = len W2.edgeSeq() by A28,Th5;
                for x,y1,y2 being set st [x,y1] in esb\es & [x,y2] in esb\es
                  holds y1 = y2 by FUNCT_1:def 1; then
                reconsider esbes1 = esb \ es as Function by FUNCT_1:def 1;
                now let a,b be Element of NAT; assume
                A45: a in dom es & b in dom (esbes1); then
                    consider xa being set such that
                A46: xa in dom ses & ses.xa = a by A39, FUNCT_1:def 5;
                    reconsider xa as Element of NAT by A46;
                A47: a = Sgm(dom esb).xa by A46, FUNCT_1:70;
                A48: xa in Seg(naa1 div 2) & xa in dom Sgm(dom esb)
                      by A46, RELAT_1:86;
                A49: [b, esbes1.b] in esb \ es by A45, FUNCT_1:8; then
                    b in dom esb by FUNCT_1:8; then
                    b in rng (Sgm (dom esb)) by A22, FINSEQ_1:def 13; then
                    consider xb being set such that
                A50: xb in dom (Sgm (dom esb)) & Sgm(dom esb).xb = b
                      by FUNCT_1:def 5;
                    reconsider xb as Element of NAT by A50;
                A51: 1 <= xa & xa <= naa1 div 2 by A48, FINSEQ_1:3;
                A52: 1 <= xb & xb <= len WB.edgeSeq() by A41,A50,FINSEQ_1:3;
then
                    xb in dom Seq esb by A19,FINSEQ_3:27; then
                    xb in dom Sgm (dom esb) by Th6; then
                A53: xb <= len Sgm(dom esb) by FINSEQ_3:27;
                    now assume xb <= xa; then
                        xb <= naa1 div 2 by A51, XXREAL_0:2; then
                    A54: xb in Seg(naa1 div 2) by A52, FINSEQ_1:3;
                        [xb, b] in Sgm(dom esb) by A50, FUNCT_1:8; then
                        [xb, b] in ses by A54, RELAT_1:def 11; then
                        b in rng ses by RELAT_1:def 5; then
                        [b, esbes1.b] in es
                          by A49,RELAT_1:def 11;
                        hence contradiction by A49,XBOOLE_0:def 4;
                    end;
                    hence a < b by A22, A47, A50, A51, A53, FINSEQ_1:def 13;
                end; then
            A55: Sgm(dom esb) = Sgm(dom es) ^ Sgm(dom (esb \ es))
                  by A35, A36, A37, FINSEQ_3:48;
            A56: dom W2.edgeSeq() c= dom Seq esb by A19,A30,RELAT_1:25;
                now let x be Element of NAT; assume
                A57: 1 <= x & x <= len W2.edgeSeq(); then
                A58: x in dom W2.edgeSeq() by FINSEQ_3:27; then
                    [x,W2.edgeSeq().x] in W2.edgeSeq() by FUNCT_1:8; then
                A59: W2.edgeSeq().x = (Seq esb).x by A19, FUNCT_1:8,A30
                                  .= esb.(Sgm(dom esb).x)
                                       by A23,A58,A56,FUNCT_1:22;
                A60: x in dom Seq es by A44, A57, FINSEQ_3:27; then
                    x in dom Sgm(dom es) by Th6; then
                A61: Sgm(dom esb).x = Sgm(dom es).x by A55, FINSEQ_1:def 7;
                A62: x in dom Sgm(dom esb) &
                     Sgm(dom esb).x in dom esb by A23,A58,A56,FUNCT_1:21; then
                A63: [Sgm(dom esb).x, esb.(Sgm(dom esb).x)] in esb by FUNCT_1:8
;
                A64: x in Seg (naa1 div 2) by A57, FINSEQ_1:3,A28;
                    [x, Sgm(dom esb).x] in Sgm(dom esb) by A62, FUNCT_1:8; then
                    [x, Sgm(dom esb).x] in ses by A64, RELAT_1:def 11; then
                    Sgm(dom esb).x in rng ses by RELAT_1:def 5; then
                    [Sgm(dom esb).x, esb.(Sgm(dom esb).x)] in es
                      by A63, RELAT_1:def 11; then
                    es.(Sgm(dom es).x) = esb.(Sgm(dom esb).x) by A61, FUNCT_1:8
;
                    hence W2.edgeSeq().x = (Seq es).x by A59,A60,A31,FUNCT_1:22
;
                end; then
                W2.edgeSeq() = Seq es by A44, FINSEQ_1:18; then
                reconsider W2 as Path of W1 by A27, Def32;
                take W2;
                thus W2 is directed;
              end;
              suppose
            A65: not v in WB.vertices(); set W2 = WB.addEdge(e);
                W2 is directed & W2 is_Walk_from W1.1,v
                  by A10,A11,A12,A13,Lm57; then
                W2 is_Walk_from W1.first(), v; then
            A66: W2 is_Walk_from W1.first(), W1.last() by A7;
                set es = esb +* ((k+1) .--> e);
            A67: dom ((k+1) .--> e) = {k+1} by FUNCOP_1:19; then
            A68: dom es = dom esb \/ {k+1} by FUNCT_4:def 1;
                now let x be set; assume
                A69: x in dom es;
                    now per cases by A68, A69, XBOOLE_0:def 2;
                    suppose x in dom esb; then
                    A70: x in Seg k by A21; then
                        reconsider x'=x as Element of NAT;
                    A71: 1 <= x' & x' <= k by A70,FINSEQ_1:3; then
                        x' <= k+1 by NAT_1:12;
                        hence x in Seg (k+1) by A71, FINSEQ_1:3; end;
                    suppose x in {k+1}; then
                    A72: x = k+1 by TARSKI:def 1;
                        1 <= k+1 by NAT_1:12;
                        hence x in Seg (k+1) by A72,FINSEQ_1:3; end;
                    end;
                    hence x in Seg (k+1);
                end; then
            A73: dom es c= Seg (k+1) by TARSKI:def 3; then
                reconsider es as FinSubsequence by FINSEQ_1:def 12;
                now let z be set; assume
                A74: z in es; then consider x,y being set such that
                A75: z = [x,y] by RELAT_1:def 1;
                A76: x in dom es & es.x = y by A74, A75, FUNCT_1:8;
                    now per cases;
                    suppose
                    A77: x in dom ((k+1) .--> e); then
                    A78: y = ((k+1).-->e).x by A67,A68,A76,FUNCT_4:def 1;
                    A79: x = k+1 by A67, A77, TARSKI:def 1; then
                    A80: y = e by A78, FUNCOP_1:87;
                        reconsider x' = x as Element of NAT by A67,A77;
                    A81: 1 <= x' & x' <= len W1.edgeSeq()
                          by A79, NAT_1:12,A6; then
                    A82: x in dom W1.edgeSeq() by FINSEQ_3:27;
                        W1.edgeSeq().x = W1.(2*(k+1)) by A79, A81,Def15
                                      .= W1.(2*k+1+1);
                        hence z in W1.edgeSeq() by A75,A80,A82,FUNCT_1:8;
                      end;
                      suppose
                    A83: not x in dom ((k+1) .--> e); then
                    A84: y = esb.x by A67, A68, A76, FUNCT_4:def 1;
                        x in dom esb by A67, A68, A76, A83, XBOOLE_0:def 2;
then
                        [x,y] in esb by A84, FUNCT_1:8; then
                        [x,y] in WA.edgeSeq() by A20;
                        hence z in W1.edgeSeq() by A16,A75;
                     end;
                    end;
                    hence z in W1.edgeSeq();
                end; then
                es c= W1.edgeSeq() by TARSKI:def 3; then
                reconsider es as FinSubsequence of W1.edgeSeq()
                  by GRAPH_2:def 5;
                now assume dom esb /\ dom ((k+1).-->e) <> {}; then
                    consider x being set such that
                A85: x in dom esb /\ dom ((k+1).-->e) by XBOOLE_0:def 1;
                A86: x in dom esb & x in {k+1} by A67, A85, XBOOLE_0:def 3;
then
                    x = k+1 by TARSKI:def 1; then
                    k+1 <= k+0 by A22,A86,FINSEQ_1:3;
                    hence contradiction by XREAL_1:8;
                end; then
            A87: dom esb misses dom ((k+1).-->e) by XBOOLE_0:def 7;
            A88: W2.edgeSeq() = Seq esb ^ <*e*> by A15, A19, Lm48; then
            A89: len W2.edgeSeq() = len Seq esb + len <*e*> by FINSEQ_1:35
                                .= len Seq esb + 1 by FINSEQ_1:56
                                .= card esb + 1 by Th5;
            A90: len Seq es = card es by Th5
                          .= card esb + card ((k+1).-->e) by A87, PRE_CIRC:27
                          .= card esb + card {[k+1,e]} by FUNCT_4:87
                          .= len W2.edgeSeq() by A89, CARD_1:79;
            A91: {k+1} c= Seg (k+1) by A68,A73,XBOOLE_1:11;
                now let m, n be Element of NAT; assume
                A92: m in dom esb & n in {k+1}; then
                A93: n = k+1 by TARSKI:def 1;
                    m <= k by FINSEQ_1:3,A22,A92;
                    hence m < n by A93, NAT_1:13;
                end; then
            A94: Sgm(dom es)=Sgm(dom esb) ^ Sgm({k+1}) by A22,A68,A91,FINSEQ_3:
48
                          .=Sgm(dom esb) ^ <* k+1 *> by FINSEQ_3:50;
                now let n be Element of NAT; assume
                A95: 1 <= n & n <= len W2.edgeSeq(); then
                A96: n in dom W2.edgeSeq() by FINSEQ_3:27;
                A97: n in dom Seq es by A95, A90, FINSEQ_3:27;
                    Seq es = es * Sgm(dom es) by FINSEQ_1:def 14; then
                A98: (Seq es).n = es.(Sgm(dom es).n) by A97,FUNCT_1:22;
                A99: Seq esb = esb * Sgm(dom esb) by FINSEQ_1:def 14;
                    now per cases by A88, A96, FINSEQ_1:38;
                      suppose
                    A100: n in dom Seq esb; then
                    A101: W2.edgeSeq().n = (Seq esb).n by A88, FINSEQ_1:def 7
                                   .= esb.(Sgm(dom esb).n) by A99,A100,FUNCT_1:
22;
                    A102: n in dom Sgm(dom esb) &
                          Sgm(dom esb).n in dom esb by A99,A100,FUNCT_1:21;
then
                        Sgm(dom es).n=Sgm(dom esb).n by A94,FINSEQ_1:def 7;
                        hence W2.edgeSeq().n = (Seq es).n
                          by A101,A87,A98,A102,FUNCT_4:17;
                      end;
                      suppose ex m being Element of NAT st m in dom <*e*> &
                      n = len Seq esb + m; then consider m being Element of NAT
                      such that
                    A103: m in dom <*e*> & n = len Seq esb + m;
                        m in {1} by A103,FINSEQ_1:4,def 8; then
                    A104: m = 1 by TARSKI:def 1; then
                    A105: W2.edgeSeq().n = <*e*>.1 by A88, A103, FINSEQ_1:def 7
                                      .= e by FINSEQ_1:def 8;
                        len Sgm(dom esb) = card dom esb by A22, FINSEQ_3:44
                                       .= card esb by Lm2
                                       .= len Seq esb by Th5; then
                    A106: (Seq es).n = es.(k+1) by A98,A94,A103,A104,FINSEQ_1:
59;
                    A107: k+1 in dom ((k+1).-->e) by A67, TARSKI:def 1; then
                        k+1 in dom esb \/ dom ((k+1).-->e)
                          by XBOOLE_0:def 2; then
                        (Seq es).n = ((k+1).-->e).(k+1) by A106,A107,FUNCT_4:
def 1
                                  .= e by FUNCOP_1:87;
                        hence W2.edgeSeq().n = (Seq es).n by A105; end;
                    end;
                    hence W2.edgeSeq().n = (Seq es).n;
                end; then
                W2.edgeSeq() = Seq es by A90, FINSEQ_1:18; then
                reconsider W2 as Path of W1 by A65,A15,A18,Lm73,A66,Def32;
                take W2;
                thus W2 is directed by A10,A11,A12,A13,Lm57; end;
            end;
            hence ex W2 being Path of W1 st W2 is directed; end;
        end;
        hence ex W2 being Path of W1 st W2 is directed;
    end; then
A108: for k being Element of NAT st P[k] holds P[k+1];
A109: for k being Element of NAT holds P[k] from NAT_1:sch 1(A4,A108);
    W.length() = W.length();
    hence thesis by A109;
  end;
end;

definition let G be _Graph, W be DWalk of G;
  mode DWalk of W is directed Subwalk of W;
  mode DTrail of W is directed Trail of W;
  mode DPath of W is directed Path of W;
end;

definition let G be _Graph;
  func G.allWalks()-> non empty
                      Subset of ((the_Vertices_of G)\/(the_Edges_of G))*
    equals  ::dGALLWALKS
    {W where W is Walk of G : not contradiction};
  coherence proof
    set IT = {W where W is Walk of G : not contradiction};
A1: G.walkOf(choose(the_Vertices_of G)) in IT;
    now let x be set; assume x in IT; then consider W being Walk of G such that
    A2: x = W;
        thus x in ((the_Vertices_of G)\/(the_Edges_of G))*
          by A2, FINSEQ_1:def 11;
    end;
    hence thesis by A1,TARSKI:def 3;
  end;
end;

definition let G be _Graph;
   func G.allTrails() -> non empty Subset of G.allWalks()
     equals  ::dGALLTRAILS
     {W where W is Trail of G : not contradiction};
  coherence proof
    set IT = {W where W is Trail of G : not contradiction};
A1: G.walkOf(choose(the_Vertices_of G)) in IT;
    now let e be set; assume e in IT; then
        consider W being Trail of G such that
    A2: W = e;
        e in {X where X is Walk of G : not contradiction} by A2;
        hence e in G.allWalks();
    end;
    hence thesis by A1,TARSKI:def 3;
 end;
end;

definition let G be _Graph;
  func G.allPaths() -> non empty Subset of G.allTrails()
    equals  ::dGALLPATHS
    {W where W is Path of G : not contradiction};
  coherence proof
    set IT = {W where W is Path of G : not contradiction};
A1: G.walkOf(choose(the_Vertices_of G)) in IT;
    now let e be set; assume e in IT; then
        consider W being Path of G such that
    A2: e = W;
        e in {X where X is Trail of G : not contradiction} by A2;
        hence e in G.allTrails();
    end;
    hence thesis by A1,TARSKI:def 3;
  end;
end;

definition let G be _Graph;
  func G.allDWalks() -> non empty Subset of G.allWalks()
    equals  ::dGALLDWALKS
    {W where W is DWalk of G : not contradiction};
  coherence proof
    set IT = {W where W is directed Walk of G : not contradiction};
A1: G.walkOf(choose(the_Vertices_of G)) in IT;
    now let e be set; assume e in IT; then
        consider W being directed Walk of G such that
    A2: e = W;
        e in {X where X is Walk of G : not contradiction} by A2;
        hence e in G.allWalks();
    end;
    hence thesis by A1,TARSKI:def 3;
  end;
end;

definition let G be _Graph;
  func G.allDTrails() -> non empty Subset of G.allTrails()
    equals  ::dGALLDTRAILS
    {W where W is DTrail of G : not contradiction};
  coherence proof
    set IT = {W where W is DTrail of G : not contradiction};
A1: G.walkOf(choose(the_Vertices_of G)) in IT;
    now let e be set; assume e in IT; then
        consider W being DTrail of G such that
    A2: e = W;
        e in {X where X is Trail of G : not contradiction} by A2;
        hence e in G.allTrails();
    end;
    hence thesis by A1,TARSKI:def 3;
  end;
end;

definition let G be _Graph;
  func G.allDPaths() -> non empty Subset of G.allDTrails()
    equals  ::dGALLPATHS
    {W where W is directed Path of G : not contradiction};
  coherence proof
    set IT = {W where W is DPath of G : not contradiction};
A1: G.walkOf(choose(the_Vertices_of G)) in IT;
    now let e be set; assume e in IT; then
        consider W being DPath of G such that
    A2: e = W;
        e in {X where X is DTrail of G : not contradiction} by A2;
        hence e in G.allDTrails();
    end;
    hence thesis by A1,TARSKI:def 3;
  end;
end;

registration let G be finite _Graph;
  cluster G.allTrails() -> finite;
  correctness proof
    set D = (the_Vertices_of G)\/(the_Edges_of G);
A1: now let W be Trail of G;
        consider f being Function such that
    A2: dom f = W.edgeSeq() & for x being set st x in W.edgeSeq()
          holds f.x = x`2 from FUNCT_1:sch 3;
        now let y be set; assume y in rng f; then
            consider x being set such that
        A3: x in dom f & f.x = y by FUNCT_1:def 5;
        A4: x in W.edgeSeq() & y = x`2 by A2, A3;
            consider a,b being set such that
        A5: x = [a,b] by A2,A3,RELAT_1:def 1;
            y = b by A4, A5, MCART_1:def 2; then
            y in rng W.edgeSeq() by A2,A3,A5,RELAT_1:def 5;
            hence y in (the_Edges_of G);
        end; then
    A6: rng f c= the_Edges_of G by TARSKI:def 3;
        now let x1,x2 be set; assume
        A7: x1 in dom f & x2 in dom f & f.x1 = f.x2; then
        A8: x1 in W.edgeSeq() & f.x1 = x1`2 & x2 in W.edgeSeq() & f.x2 = x2`2
              by A2; consider a1,b1 being set such that
        A9: x1 = [a1,b1] by A2,A7,RELAT_1:def 1;
            consider a2,b2 being set such that
        A10: x2 = [a2,b2] by A2,A7, RELAT_1:def 1;
        A11: b1 = f.x1 by A8,A9,MCART_1:def 2
              .= b2 by A7,A8,A10,MCART_1:def 2;
        A12: W.edgeSeq() is one-to-one by Def27;
        A13: a1 in dom W.edgeSeq() & W.edgeSeq().a1 = b1
              by A2,A7,A9,FUNCT_1:8;
            a2 in dom W.edgeSeq() & W.edgeSeq().a2 = b1
              by A2,A7,A10,A11,FUNCT_1:8;
            hence x1 = x2 by A9, A10, A11,A12,A13,FUNCT_1:def 8;
        end; then
        f is one-to-one by FUNCT_1:def 8; then
        Card W.edgeSeq() <=` Card (the_Edges_of G) by A2,A6,CARD_1:26; then
        len W.edgeSeq() <= card (the_Edges_of G) by CARD_2:57; then
        len W.edgeSeq() <= G.size() by GLIB_000:def 27; then
        2*len W.edgeSeq() <= 2*G.size() by XREAL_1:66; then
        2*len W.edgeSeq()+1 <= 2*G.size()+1 by XREAL_1:9;
        hence len W <= 2*G.size()+1 by Def15;
    end;
    set X = {x where x is Element of D* : len x <= 2*G.size()+1};
A14: X is finite by GRAPH_5:4;
    now let e be set; assume e in G.allTrails(); then
        e in {W where W is Trail of G : not contradiction};then
        consider W being Trail of G such that
    A15: W = e;
    A16: e is Element of D* by A15, FINSEQ_1:def 11;
        len W <= 2*G.size()+1 by A1;
        hence e in X by A15,A16;
    end; then
    G.allTrails() c= X by TARSKI:def 3;
    hence G.allTrails() is finite by A14, FINSET_1:13;
  end;
end;

definition let G be _Graph, X be non empty Subset of G.allWalks();
  redefine mode Element of X -> Walk of G;
  coherence proof
    let x be Element of X;
    x in {W where W is Walk of G : not contradiction}; then
    consider y being Walk of G such that
A1: y = x;
    thus thesis by A1;
   end;
end;
definition let G be _Graph, X be non empty Subset of G.allTrails();
  redefine mode Element of X -> Trail of G;
  coherence proof
    let x be Element of X;
    x in {W where W is Trail of G : not contradiction}; then
    consider y being Trail of G such that
A1: y = x;
    thus thesis by A1;
   end;
end;

definition let G be _Graph, X be non empty Subset of G.allPaths();
  redefine mode Element of X -> Path of G;
  coherence proof
    let x be Element of X;
    x in {W where W is Path of G : not contradiction}; then
    consider y being Path of G such that
A1: y = x;
    thus thesis by A1;
  end;
end;
definition let G be _Graph, X be non empty Subset of G.allDWalks();
  redefine mode Element of X -> DWalk of G;
  coherence proof
    let x be Element of X;
    x in {W where W is DWalk of G : not contradiction}; then
    consider y being DWalk of G such that
A1: y = x;
    thus thesis by A1;
  end;
end;

definition let G be _Graph, X be non empty Subset of G.allDTrails();
  redefine mode Element of X -> DTrail of G;
  coherence proof
    let x be Element of X;
    x in {W where W is DTrail of G : not contradiction}; then
    consider y being DTrail of G such that
A1: y = x;
    thus thesis by A1;
  end;
end;

definition let G be _Graph, X be non empty Subset of G.allDPaths();
  redefine mode Element of X -> DPath of G;
  coherence proof
    let x be Element of X;
    x in {W where W is DPath of G : not contradiction}; then
    consider y being DPath of G such that
A1: y = x;
    thus thesis by A1;
  end;
end;

begin :: Theorems

reserve G,G1,G2 for _Graph;
reserve W,W1,W2 for Walk of G;
reserve e,x,y,z for set;
reserve v for Vertex of G;
reserve n,m for Element of NAT;

canceled;

theorem ::tWALK02
  for n being odd Element of NAT st n <= len W holds
    W.n in the_Vertices_of G by Lm3;

theorem Th9: ::tWALK03
  for n being even Element of NAT st n in dom W holds
    W.n in the_Edges_of G proof
    let n be even Element of NAT; assume n in dom W; then
A1: 1 <= n & n <= len W by FINSEQ_3:27; then
    reconsider naa1 = n-1 as odd Element of NAT by INT_1:18;
    naa1 < len W - 0 by A1, REAL_1:92; then
    W.(naa1+1) Joins W.naa1, W.(naa1+2), G by Def3;
    hence thesis by GLIB_000:def 15;
end;

theorem ::tWALK04
  for n being even Element of NAT st n in dom W holds
    ex naa1 being odd Element of NAT st
      naa1 = n-1 & n-1 in dom W & n+1 in dom W &
      W.n Joins W.(naa1), W.(n+1),G by Lm4;

theorem Th11: ::tWALK05
  for n being odd Element of NAT st n < len W holds
    W.(n+1) in W.vertexAt(n).edgesInOut() proof
    let n be odd Element of NAT; assume
A1: n < len W; then
A2: W.(n+1) Joins W.n, W.(n+2), G by Def3;
    W.vertexAt(n) = W.n by A1, Def8;
    hence thesis by A2,GLIB_000:65;
end;

theorem Th12: ::tWALK06
  for n being odd Element of NAT st 1 < n & n <= len W holds
     W.(n-1) in W.vertexAt(n).edgesInOut() proof
    let n be odd Element of NAT; assume
A1: 1 < n & n <= len W;
    reconsider naa1 = n-1 as even Element of NAT by A1, INT_1:18;
A2: n - 1 <= len W - 0 by A1, REAL_1:92;
    1+1 <= n by A1, NAT_1:13; then
    1+1-1 <= n-1 by REAL_1:92; then
    naa1 in dom W by A2, FINSEQ_3:27; then
    consider n5 being odd Element of NAT such that
A3: n5 = naa1-1 & naa1-1 in dom W & naa1+1 in dom W &
      W.naa1 Joins W.(n5), W.(naa1+1),G by Lm4;
    n5 <= len W by A3, FINSEQ_3:27; then
    W.(n5) = W.vertexAt(n5) by Def8; then
    W.(n-1) Joins W.vertexAt(n5), W.vertexAt(n), G by A1,A3,Def8; then
    W.(n-1) Joins W.vertexAt(n), W.vertexAt(n5), G by GLIB_000:17;
    hence thesis by GLIB_000:65;
end;

theorem ::tWALK07
  for n being odd Element of NAT st n < len W holds
     n in dom W & n+1 in dom W & n+2 in dom W proof
    let n be odd Element of NAT; assume
A1: n < len W;
A2: 1 <= n by HEYTING3:1;
A3: 1 <= n+1 & 1 <= n+2 by NAT_1:12;
    n+1 <= len W & n+2 <= len W by A1,NAT_1:13,Th1;
    hence thesis by A1,A2,A3,FINSEQ_3:27;
end;

theorem Th14: ::tWALKOFV01
  len G.walkOf(v) = 1 &  G.walkOf(v).1 = v &
    G.walkOf(v).first() = v & G.walkOf(v).last() = v &
    G.walkOf(v) is_Walk_from v,v proof
    thus A1: len G.walkOf(v) = 1 & G.walkOf(v).1 = v by FINSEQ_1:57;
    hence A2: G.walkOf(v).first() = v;
    thus G.walkOf(v).last() = v by A1;
    hence G.walkOf(v) is_Walk_from v,v by A2, Def23;
end;

theorem Th15: ::tWALKOFE01
  e Joins x,y,G implies len G.walkOf(x,e,y) = 3 proof
    assume e Joins x,y,G; then
    G.walkOf(x,e,y) = <*x,e,y*> by Def5;
    hence thesis by FINSEQ_1:62;
end;

theorem Th16: ::tWALKOFE02
  e Joins x,y,G implies
    G.walkOf(x,e,y).first() = x & G.walkOf(x,e,y).last() = y &
    G.walkOf(x,e,y) is_Walk_from x,y proof
    set W = G.walkOf(x,e,y);
    assume e Joins x,y,G; then
    W = <*x,e,y*> by Def5; then
A1: len W = 3 & W.1 = x & W.2 = e & W.3 = y by FINSEQ_1:62;
    hence
A2: W.first() = x;
    thus W.last() = y by A1;
    hence W is_Walk_from x, y by A2, Def23;
end;

theorem  ::tWFIRST01
  for W1 being Walk of G1, W2 being Walk of G2 st W1 = W2 holds
    W1.first() = W2.first() & W1.last() = W2.last();

theorem Th18: ::tWALKFROM01
  W is_Walk_from x,y iff W.1 = x & W.(len W) = y proof
  W is_Walk_from x,y iff W.first() = x & W.last() = y by Def23;
  hence thesis;
end;

theorem ::tWALKFROM02
  W is_Walk_from x,y implies x is Vertex of G & y is Vertex of G proof
      assume W is_Walk_from x,y; then
      W.first() = x & W.last() = y by Def23;
      hence thesis;
end;

theorem ::tWALKFROM03
  for W1 being Walk of G1, W2 being Walk of G2 st W1 = W2 holds
    W1 is_Walk_from x,y iff W2 is_Walk_from x,y proof
    let W1 be Walk of G1, W2 be Walk of G2; assume
A1: W1 = W2;
    W1 is_Walk_from x,y iff W1.first() = x & W1.last() = y by Def23; then
    W1 is_Walk_from x,y iff W2.first() = x & W2.last() = y by A1;
    hence W1 is_Walk_from x,y iff W2 is_Walk_from x,y by Def23;
end;

theorem ::tWVAT01
  for W1 being Walk of G1, W2 being Walk of G2 st W1 = W2 holds
    for n being Element of NAT holds W1.vertexAt(n) = W2.vertexAt(n) proof
    let W1 be Walk of G1, W2 be Walk of G2; assume
A1: W1 = W2;
    let n be Element of NAT;
    now per cases;
    suppose
    A2: n is odd & n <= len W1;
        hence W1.vertexAt(n) = W2.n by A1, Def8
                            .= W2.vertexAt(n) by A1,A2,Def8; end;
    suppose
    A3: not (n is odd & n <= len W1);
        hence W1.vertexAt(n) = W1.first() by Def8
                            .= W2.first() by A1
                            .= W2.vertexAt(n) by A1,A3,Def8; end;
    end;
    hence thesis;
end;

theorem ::tWREV01
  len W = len W.reverse() & dom W = dom W.reverse() &
    rng W = rng W.reverse() by Lm9;

theorem Th23: ::tWREV02
  W.first() = W.reverse().last() & W.last() = W.reverse().first() proof
A1: len W = len W.reverse() by Lm9;
    thus W.first() = W.reverse().last() by  FINSEQ_5:65,A1;
    thus W.last() = W.reverse().first() by FINSEQ_5:65;
end;

theorem Th24: ::tWREV03
  W is_Walk_from x,y iff W.reverse() is_Walk_from y, x proof
A1: len W = len W.reverse() by Lm9;
    hereby assume W is_Walk_from x, y; then
        W.1 = x & W.(len W) = y by Th18; then
        W.reverse().1 = y & W.reverse().(len W) = x by FINSEQ_5:65;
        hence W.reverse() is_Walk_from y,x by A1, Th18;
    end;
    assume W.reverse() is_Walk_from y,x; then
    W.reverse().1=y & W.reverse().(len W.reverse())=x by Th18; then
    W.1 = x & W.(len W) = y by A1,FINSEQ_5:65;
    hence W is_Walk_from x,y by Th18;
end;

theorem Th25: ::tWREV04
  n in dom W implies W.n = W.reverse().(len W - n + 1) &
    (len W - n + 1) in dom W.reverse() proof
    set rn = len W - n + 1; assume
A1: n in dom W; then
    n <= len W by FINSEQ_3:27; then
    reconsider rn as Element of NAT by FINSEQ_5:1;
    n in Seg len W by A1, FINSEQ_1:def 3; then
    len W - n + 1 in Seg len W by FINSEQ_5:2; then
A2: rn in Seg len W.reverse() by FINSEQ_5:def 3; then
    rn in dom W.reverse() by FINSEQ_1:def 3; then
    W.reverse().rn = W.(len W - rn + 1) by FINSEQ_5:def 3;
    hence thesis by A2,FINSEQ_1:def 3;
end;

theorem ::tWREV05
  n in dom W.reverse() implies W.reverse().n = W.(len W - n + 1) &
    (len W - n + 1) in dom W by Lm11;

theorem ::tWREV06
  W.reverse().reverse() = W by Lm12;

theorem ::tWREV07
  for W1 being Walk of G1, W2 being Walk of G2 st W1 = W2 holds
    W1.reverse() = W2.reverse();

theorem ::tWAPPND01
  W1.last() = W2.first() implies
  len W1.append(W2) + 1 = len W1 + len W2 by Lm13;

theorem ::tWAPPND02
  W1.last() = W2.first() implies
    len W1 <= len W1.append(W2) & len W2 <= len W1.append(W2) by Lm14;

theorem ::tWAPPND03
  W1.last() = W2.first() implies
    W1.append(W2).first() = W1.first() & W1.append(W2).last() = W2.last() &
    W1.append(W2) is_Walk_from W1.first(), W2.last() by Lm15;

theorem Th32: ::tWAPPND04
  W1 is_Walk_from x,y & W2 is_Walk_from y,z implies
  W1.append(W2) is_Walk_from x,z proof
    assume W1 is_Walk_from x, y & W2 is_Walk_from y,z; then
    W1.first() = x & W1.last() = y & W2.first() = y & W2.last() = z
      by Def23;
    hence thesis by Lm15;
end;

theorem ::tWAPPND05
  n in dom W1 implies
    W1.append(W2).n = W1.n & n in dom W1.append(W2) by Lm16;

theorem ::tWAPPND06
  W1.last() = W2.first() implies
  for n being Element of NAT st n < len W2 holds
    W1.append(W2).(len W1 + n) = W2.(n+1) &
    (len W1 + n) in dom W1.append(W2) by Lm17;

theorem ::tWAPPND07
  n in dom W1.append(W2) implies
     n in dom W1 or ex k being Element of NAT st k < len W2 & n = len W1 + k
     by Lm18;

theorem Th36: ::tWAPPND08
  for W1A, W1B being Walk of G1, W2A,W2B being Walk of G2
   st W1A = W2A & W1B = W2B holds
    W1A.append(W1B) = W2A.append(W2B) proof
    let W1A, W1B be Walk of G1, W2A, W2B be Walk of G2; assume
A1: W1A = W2A & W1B = W2B;
    now per cases;
    suppose
    A2: W1A.last() = W1B.first(); then
    A3: W2A.last() = W2B.first() by  A1;
        thus W1A.append(W1B) = W1A ^' W1B by A2, Def10
                             .= W2A.append(W2B) by A1,A3, Def10; end;
    suppose
    A4: W1A.last() <> W1B.first(); then
        W2A.last() <> W1B.first() by A1; then
    A5: W2A.last() <> W2B.first() by A1;
        thus W1A.append(W1B) = W2A by A1, A4, Def10
                            .= W2A.append(W2B) by A5, Def10; end;
    end;
    hence thesis;
end;

theorem ::tWCUT01
  for m,n being odd Element of NAT st m <= n & n <= len W holds
    len W.cut(m,n) + m = n+1 &
    for i being Element of NAT st i < len W.cut(m,n)
        holds W.cut(m,n).(i+1) = W.(m+i) & m+i in dom W by Lm19;

theorem ::tWCUT02
  for m, n being odd Element of NAT st m <= n & n <= len W holds
    W.cut(m,n).first() = W.m & W.cut(m,n).last() = W.n &
    W.cut(m,n) is_Walk_from W.m, W.n by Lm20;

theorem ::tWCUT03
  for m,n,o being odd Element of NAT st m <= n & n <= o & o <= len W holds
    W.cut(m,n).append(W.cut(n,o)) = W.cut(m,o) by Lm21;

theorem ::tWCUT04
  W.cut(1,len W) = W by Lm22;

theorem Th41: ::tWCUT05
  for n being odd Element of NAT st n < len W holds
  G.walkOf(W.n, W.(n+1), W.(n+2)) = W.cut(n,n+2) proof
    let n be odd Element of NAT; set v1 = W.n, e = W.(n+1), v2 = W.(n+2);
    assume
A1: n < len W; then
A2: e Joins v1,v2,G by Def3; then
A3: G.walkOf(v1,e,v2) = <*v1,e,v2*> by Def5;
    set W1 = G.walkOf(v1,e,v2), W2 = W.cut(n,n+2);
A4: n <= n+2 & n+2 <= len W by A1, Th1; then
    len W.cut(n,n+2) + n = 1 + (2+n) by Lm19; then
    len W.cut(n,n+2) + n = (1+2) + n; then
A5: len W2 = 3;
A6: len W1 = 3 by A2,Th15;
    now let x be Element of NAT; assume
    A7: x in Seg 3; then
    A8: 1 <= x & x <= 3 by FINSEQ_1:3; then
        reconsider xaa1 = x-1 as Element of NAT by INT_1:18;
    A9: xaa1+1 = x;
        xaa1 < 3-0 by A8, REAL_1:92; then
    A10: W2.x = W.(n+xaa1) by A4, A5, A9, Lm19;
        now per cases by A7, FINSEQ_3:1, ENUMSET1:def 1;
        suppose x = 1;
            hence W1.x = W2.x by A3, A10, FINSEQ_1:62; end;
        suppose x = 2;
            hence W1.x = W2.x by A3, A10, FINSEQ_1:62; end;
        suppose x = 3;
            hence W1.x = W2.x by A3, A10, FINSEQ_1:62; end;
        end;
        hence W1.x = W2.x;
    end;
    hence thesis by A5, A6, FINSEQ_2:10;
end;

theorem Th42: ::tWCUT06
  for m,n being odd Element of NAT st m <= n & n < len W holds
    W.cut(m,n).addEdge(W.(n+1)) = W.cut(m,n+2) proof
    let m,n be odd Element of NAT; set W1 = W.cut(m,n); set e = W.(n+1); assume
A1: m <= n & n < len W; then
A2: n <= n+2 & n+2 <= len W by Th1;
A3: W1.last() = W.n by A1, Lm20; then
    e Joins W1.last(), W.(n+2), G by A1, Def3; then
    e Joins W1.last(), W.vertexAt(n+2), G by A2, Def8; then
    W1.last().adj(e) = W.vertexAt(n+2) by GLIB_000:69; then
    W1.last().adj(e) = W.(n+2) by A2, Def8; then
    G.walkOf(W1.last(),e,W1.last().adj(e)) = W.cut(n,n+2)
      by A1, A3, Th41; then
    W1.addEdge(e) = W1.append(W.cut(n,n+2));
    hence thesis by A1, A2, Lm21;
end;

theorem ::tWCUT07
  for n being odd Element of NAT st n <= len W holds
     W.cut(n,n) = <* W.vertexAt(n) *> by Lm23;

theorem ::tWCUT08
  m is odd & m <= n implies
    W.cut(1,n).cut(1,m) = W.cut(1,m) by Lm24;

theorem ::tWCUT09
  for m,n being odd Element of NAT
  st m <= n & n <= len W1 & W1.last() = W2.first()
    holds W1.append(W2).cut(m,n) = W1.cut(m,n) by Lm25;

theorem ::tWCUT10
  for m being odd Element of NAT st m <= len W holds
     len W.cut(1,m) = m by Lm26;

theorem ::tWCUT11
  for m being odd Element of NAT, x being Element of NAT
  st x in dom W.cut(1,m) & m <= len W holds
     W.cut(1,m).x = W.x  by Lm27;

theorem ::tWCUT12
  for m,n being odd Element of NAT, i being Element of NAT
    st m <= n & n <= len W & i in dom W.cut(m,n) holds
      W.cut(m,n).i = W.(m+i-1) & m+i-1 in dom W proof
    let m,n be odd Element of NAT, i be Element of NAT; assume
A1: m <= n & n <= len W & i in dom W.cut(m,n); then
A2: 1 <= i & i <= len W.cut(m,n) by FINSEQ_3:27; then
    reconsider iaa1 = i-1 as Element of NAT by INT_1:18;
A3: iaa1 < len W.cut(m,n) - 0 by A2, REAL_1:92;
    iaa1+1 = i; then
    W.cut(m,n).i = W.(m+iaa1) & m+iaa1 in dom W by A1,A3,Lm19;
    hence thesis;
end;

theorem Th49: ::tWCUT13
  for W1 being Walk of G1, W2 being Walk of G2, m, n being Element of NAT
  st W1 = W2 holds
    W1.cut(m,n) = W2.cut(m,n) proof
    let W1 be Walk of G1, W2 be Walk of G2, m, n be Element of NAT; assume
A1: W1 = W2;
    now per cases;
    suppose
    A2: m is odd & n is odd & m <= n & n <= len W1;
        hence W1.cut(m,n) = (m,n)-cut W2 by A1, Def11
                         .= W2.cut(m,n) by A1, A2, Def11; end;
    suppose
    A3: not (m is odd & n is odd & m <= n & n <= len W1);
        hence W1.cut(m,n) = W2 by A1, Def11
                         .= W2.cut(m,n) by A1, A3, Def11; end;
    end;
    hence thesis;
end;

theorem ::tWREMOVE01
  for m,n being odd Element of NAT st m <= n & n <= len W & W.m = W.n holds
     len W.remove(m,n) + n = len W + m  by Lm28;

theorem ::tWREMOVE02
   W is_Walk_from x,y implies W.remove(m,n) is_Walk_from x,y by Lm29;

theorem ::tWREMOVE03
  len W.remove(m,n) <= len W by Lm30;

theorem ::tWREMOVE04
  W.remove(m,m) = W by Lm31;

theorem ::tWREMOVE05
  for m,n being odd Element of NAT st m <= n & n <= len W & W.m = W.n holds
     W.cut(1,m).last() = W.cut(n,len W).first() by Lm32;

theorem ::tWREMOVE06
  for m,n being odd Element of NAT st m <= n & n <= len W & W.m = W.n holds
     (for x being Element of NAT st x in Seg m holds W.remove(m,n).x = W.x)
     by Lm33;

theorem ::tWREMOVE07
  for m,n being odd Element of NAT st m <= n & n <= len W & W.m = W.n holds
     (for x being Element of NAT st m <= x & x <= len W.remove(m,n) holds
        W.remove(m,n).x = W.(x - m + n) &
        x - m + n is Element of NAT & x - m + n <= len W) by Lm34;

theorem ::tWREMOVE08
  for m,n being odd Element of NAT st m <= n & n <= len W & W.m = W.n holds
    len W.remove(m,n) = len W + m - n by Lm35;

theorem Th58: ::tWREMOVE09
   for m being Element of NAT st W.m = W.last() holds
     W.remove(m,len W) = W.cut(1,m) proof
    let m be Element of NAT; assume W.m = W.last(); then
A1: W.m = W.(len W);
    now per cases;
    suppose
    A2: m is odd & m <= len W; then
        len W.remove(m,len W) + len W = len W + m by A1, Lm28; then
    A3: len W.remove(m,len W) = m; then
    A4: len W.remove(m,len W) = len W.cut(1,m) by A2, Lm26;
        now let k be Element of NAT; assume
        A5: 1 <= k & k <= len W.remove(m, len W); then
        A6: k in dom W.cut(1,m) by A4, FINSEQ_3:27;
            k in Seg m by A3, A5, FINSEQ_1:3;
            hence W.remove(m,len W).k = W.k by A1, A2, Lm33
                                     .= W.cut(1,m).k by A2,A6,Lm27;
        end;
        hence thesis by A4, FINSEQ_1:18; end;
    suppose
    A7: not (m is odd & m <= len W); then
        W.cut(1,m) = W by Def11;
        hence W.remove(m,len W) = W.cut(1,m) by A7, Def12; end;
    end;
    hence thesis;
end;

theorem ::tWREMOVE10
  for m being Element of NAT st W.first() = W.m holds
    W.remove(1,m) = W.cut(m, len W) by Lm36;

theorem ::tWREMOVE11
  W.remove(m,n).first() = W.first() &
    W.remove(m,n).last() = W.last() by Lm37;

theorem ::tWREMOVE12
 for m,n being odd Element of NAT, x being Element of NAT
  st m <= n & n <= len W & W.m = W.n & x in dom W.remove(m,n) holds
     x in Seg m or (m <= x & x <= len W.remove(m,n)) by Lm38;

theorem ::tWREMOVE13
  for W1 being Walk of G1, W2 being Walk of G2, m, n being Element of NAT
  st W1 = W2 holds
    W1.remove(m,n) = W2.remove(m,n) proof
    let W1 be Walk of G1, W2 be Walk of G2, m, n be Element of NAT; assume
A1: W1 = W2;
    now per cases;
    suppose
    A2: (m is odd & n is odd & m <= n & n <= len W1 & W1.m = W1.n); then
    A3: W1.remove(m,n) = W1.cut(1,m).append(W1.cut(n,len W1)) by Def12;
        W1.cut(1,m) = W2.cut(1,m) & W1.cut(n,len W1) = W2.cut(n,len W2)
          by A1, Th49; then
        W1.remove(m,n) = W2.cut(1,m).append(W2.cut(n,len W2))
          by A3, Th36;
        hence W1.remove(m,n) = W2.remove(m,n) by A1, A2, Def12; end;
    suppose
    A4: not (m is odd & n is odd & m <= n & n <= len W1 & W1.m = W1.n);
        hence W1.remove(m,n) = W2 by A1, Def12
                            .= W2.remove(m,n) by A1, A4, Def12; end;
    end;
    hence thesis;
end;

theorem ::tWADDEDGE01
  e Joins W.last(), x, G implies
  W.addEdge(e) = W^<*e,x*> by Lm39;

theorem ::tWADDEDGE02
  e Joins W.last(),x,G implies
  W.addEdge(e).first() = W.first() & W.addEdge(e).last() = x &
  W.addEdge(e) is_Walk_from W.first(), x by Lm40;

theorem ::tWADDEDGE03
  e Joins W.last(),x,G implies
  len W.addEdge(e) = len W + 2 by Lm41;

theorem ::tWADDEDGE04
  e Joins W.last(),x,G implies
  W.addEdge(e).(len W + 1) = e & W.addEdge(e).(len W + 2) = x &
  for n being Element of NAT st n in dom W holds W.addEdge(e).n = W.n by Lm42;

theorem ::tWADDEDGE05
  W is_Walk_from x,y & e Joins y,z,G implies
  W.addEdge(e) is_Walk_from x,z  by Lm43;

theorem Th68: ::tWVSEQ01
  1 <= len W.vertexSeq() proof
    now assume len W.vertexSeq() < 1; then
        len W.vertexSeq() < 0 + 1; then
        len W.vertexSeq() <= 0 by NAT_1:13; then
        len W.vertexSeq() = 0; then
        len W + 1 = 2 * 0 by Def14;
        hence contradiction;
    end;
    hence thesis;
end;

theorem Th69: ::tWVSEQ02
  for n being odd Element of NAT st n <= len W holds
    2 * ((n+1) div 2) - 1 = n &
    1 <= (n+1) div 2 & (n+1) div 2 <= len W.vertexSeq() proof
    let n be odd Element of NAT; assume
A1: n <= len W; set m = (n+1) div 2;
    2 divides n+1 by PEPIN:22; then
A2: 2 * m = n+1 by NAT_D:3;
    hence 2 * m - 1 = n;
A3: now assume m < 1; then
        m < 0 + 1; then
        m <= 0 by NAT_1:13; then
        m = 0;
        hence contradiction by A2;
    end;
    hence 1 <= m;
    reconsider maa1 = m-1 as Element of NAT by A3, INT_1:18;
    now assume len W.vertexSeq() < m; then
        len W.vertexSeq() < maa1 + 1; then
        len W.vertexSeq() <= maa1 by NAT_1:13; then
        2 * len W.vertexSeq() <= 2 * maa1 by NAT_1:4; then
        len W + 1 <= (2 * m) - (2 * 1) by Def14; then
        len W + 1 + 2 <= n + 1 - 2 + 2 by A2, XREAL_1:9; then
        len W + 1 + 2 < n + 1 + 1 by NAT_1:13; then
        len W + 3 - 3 < n + 2 - 2 by REAL_1:92;
        hence contradiction by A1;
    end;
    hence m <= len W.vertexSeq();
end;

theorem ::tWVSEQ03
  G.walkOf(v).vertexSeq() = <*v*> proof
    set VS = G.walkOf(v).vertexSeq();
    len G.walkOf(v) + 1 = 2 * len VS by Def14; then
    1 + 1 = 2 * len VS by Th14; then
A1: len VS = 1; then
    VS.1 = G.walkOf(v).(2*1-1) by Def14
        .= v by Th14;
    hence thesis by A1, FINSEQ_1:57;
end;

theorem Th71: ::tWVSEQ04
  e Joins x,y,G implies
    G.walkOf(x,e,y).vertexSeq() = <*x,y*> proof
    set W = G.walkOf(x,e,y); assume e Joins x, y, G; then
A1: W = <*x, e, y*> by Def5;
    len W + 1 = 2 * len W.vertexSeq() by Def14; then
    3 + 1 = 2 * len W.vertexSeq() by A1, FINSEQ_1:62; then
    2 * 2 = 2 * len W.vertexSeq(); then
A2: len W.vertexSeq() = 2; then
    W.vertexSeq().1 = W.(2*1-1) & W.vertexSeq().2 = W.(2*2-1) by Def14; then
    W.vertexSeq().1 = x & W.vertexSeq().2 = y by A1, FINSEQ_1:62;
    hence thesis by A2, FINSEQ_1:61;
end;

theorem ::tWVSEQ05
  W.first() = W.vertexSeq().1 &
  W.last() = W.vertexSeq().(len W.vertexSeq()) proof
    1 <= len W.vertexSeq() by Th68; then
A1: W.vertexSeq().1 = W.(2*1-1) &
      W.vertexSeq().(len W.vertexSeq()) = W.(2*len W.vertexSeq()-1) by Def14;
    hence W.vertexSeq().1 = W.first();
    len W + 1 = 2*len W.vertexSeq() by Def14;
    hence W.vertexSeq().(len W.vertexSeq()) = W.last() by A1;
end;

theorem ::tWVSEQ06
  for n being odd Element of NAT st n <= len W holds
    W.vertexAt(n) = W.vertexSeq().((n+1) div 2) proof
    let n be odd Element of NAT; assume
A1: n <= len W; then
A2: W.vertexAt(n) = W.n by Def8; set m = (n+1) div 2;
    2 * m - 1 = n & 1 <= m & m <= len W.vertexSeq() by A1, Th69;
    hence thesis by A2, Def14;
end;

theorem Th74: ::tWVSEQ07
  n in dom W.vertexSeq() iff (2*n-1 in dom W) proof
    hereby assume n in dom W.vertexSeq(); then
    A1: 1 <= n & n <= len W.vertexSeq() by FINSEQ_3:27; then
        2*n <= 2*len W.vertexSeq() by XREAL_1:66; then
        2*n <= len W + 1 by Def14; then
    A2: 2*n-1 <= len W + 1 - 1 by REAL_1:92;
        2*1 <= 2*n by A1, XREAL_1:66; then
    A3: 2-1 <= 2*n-1 by REAL_1:92;
        1 <= n+n by A1, NAT_1:12; then
        2*n-1 is Element of NAT by INT_1:18;
        hence 2*n-1 in dom W by A2,A3,FINSEQ_3:27;
    end;
    assume
A4: 2*n-1 in dom W; then
    reconsider 2naa1=2*n-1 as Element of NAT;
    1 <= 2naa1 & 2naa1 <= len W by A4,FINSEQ_3:27; then
A5: 1+1 <= 2*n-1+1 & 2*n-1+1 <= len W+1 by XREAL_1:9; then
A6: 2*1 <= 2*n & 2*n <= len W + 1;
    2*n <= 2 * len W.vertexSeq() by A5,Def14; then
    1 <= n & n <= len W.vertexSeq() by A6, Lm1;
    hence n in dom W.vertexSeq() by FINSEQ_3:27;
end;

theorem ::tWVSEQ08
  W.cut(1,n).vertexSeq() c= W.vertexSeq() proof
    now per cases;
    suppose
    A1: n is odd & 1 <= n & n <= len W;
        set f = W.cut(1,n).vertexSeq();
        now let v be set; assume
        A2: v in f; then consider x,y being set such that
        A3: v = [x,y] by RELAT_1:def 1;
        A4: x in dom f & y = f.x by A2, A3, FUNCT_1:8; then
            reconsider x as Element of NAT;
            1 <= x & x <= len f by A4,FINSEQ_3:27; then
        A5: y = W.cut(1,n).(2*x-1) by A4, Def14;
        A6: 2*x-1 in dom W.cut(1,n) by A4, Th74; then
        A7: y = W.(2*x-1) by A1, A5, Lm27;
        A8: 2*x-1 is Element of NAT by A6; then
        A9: 1 <= 2*x-1 & 2*x-1 <= len W.cut(1,n) by A6, FINSEQ_3:27; then
            2*x-1 <= n by A1, Lm26; then
        A10: 2*x-1 <= len W by A1, XXREAL_0:2;
            2*x-1 in dom W by A8,A9, A10, FINSEQ_3:27; then
        A11: x in dom W.vertexSeq() by Th74; then
            1 <= x & x <= len W.vertexSeq() by FINSEQ_3:27; then
            W.vertexSeq().x = y by A7, Def14;
            hence v in W.vertexSeq() by A3, A11, FUNCT_1:8;
        end;
        hence thesis by TARSKI:def 3; end;
    suppose not (n is odd & 1 <= n & n <= len W);
        hence thesis by Def11; end;
    end;
    hence thesis;
end;

theorem Th76: ::tWVSEQ09
  e Joins W.last(),x,G implies
    W.addEdge(e).vertexSeq() = W.vertexSeq() ^ <*x*> proof
    set W2 = W.addEdge(e), W3 = W.vertexSeq() ^ <*x*>; assume
A1: e Joins W.last(),x,G; then
    len W2 = len W + 2 by Lm41; then
A2: len W + 2 + 1 = 2 * len W2.vertexSeq() by Def14;
    len W3 = len W.vertexSeq() + len <*x*> by FINSEQ_1:35; then
    len W3 = len W.vertexSeq() + 1 by FINSEQ_1:56; then
    2*len W3 = 2*len W.vertexSeq()+2*1; then
    2*len W3 = len W + 1 + 2 by Def14
            .= 2* len W2.vertexSeq() by A2; then
A3: len W3 = len W2.vertexSeq();
    now let k be Element of NAT; assume
    A4: 1 <= k & k <= len W2.vertexSeq(); then
    A5: k in dom W3 by A3, FINSEQ_3:27;
    A6: W2.vertexSeq().k = W2.(2*k-1) by A4, Def14;
        now per cases by A5, FINSEQ_1:38;
        suppose
        A7: k in dom W.vertexSeq(); then
        A8: W3.k = W.vertexSeq().k by FINSEQ_1:def 7;
            1 <= k & k <= len W.vertexSeq() by A7, FINSEQ_3:27; then
        A9: W3.k = W.(2*k-1) by A8, Def14;
            2*k-1 in dom W by A7, Th74;
            hence W2.vertexSeq().k = W3.k by A1,A6,A9,Lm42; end;
        suppose ex n being Element of NAT st n in dom <*x*> &
        k=len W.vertexSeq()+n; then
            consider n being Element of NAT such that
        A10: n in dom <*x*> & k  = len W.vertexSeq() + n;
            n in Seg 1 by A10, FINSEQ_1:55; then
        A11: n = 1 by FINSEQ_1:4,TARSKI:def 1; then
        A12: W3.k = <*x*>.1 by A10, FINSEQ_1:def 7
                .= x by FINSEQ_1:def 8;
            2*k = 2*len W.vertexSeq() + 2*1 by A10,A11
               .= len W + 1 + 2 by Def14
               .= len W + 2 + 1;
            hence W2.vertexSeq().k = W3.k by A1,A6,A12,Lm42; end;
        end;
        hence W2.vertexSeq().k = W3.k;
    end;
    hence thesis by A3, FINSEQ_1:18;
end;

theorem Th77: ::tWVSEQ10
  for W1 being Walk of G1, W2 being Walk of G2 st W1 = W2 holds
    W1.vertexSeq() = W2.vertexSeq() proof
    let W1 be Walk of G1, W2 be Walk of G2;
    set VS1 = W1.vertexSeq(), VS2 = W2.vertexSeq(); assume
A1: W1 = W2;
    now thus len VS1 = len VS1;
        2 * len VS1 = len W2 + 1 by A1, Def14
                   .= 2 * len VS2 by Def14;
        hence
    A2: len VS2 = len VS1;
        let x be Element of NAT; assume x in Seg len VS1; then
        x in dom VS1 by FINSEQ_1:def 3; then
    A3: 1 <= x & x <= len VS1 & x <= len VS2 by A2, FINSEQ_3:27;
        hence VS1.x = W2.(2*x - 1) by A1, Def14
                   .= VS2.x by A3, Def14;
    end;
    hence W1.vertexSeq() = W2.vertexSeq() by FINSEQ_2:10;
end;

theorem ::tWESEQ01
  for n being even Element of NAT st 1 <= n & n <= len W holds
    n div 2 in dom W.edgeSeq() & W.n = W.edgeSeq().(n div 2) by Lm44;

theorem ::tWESEQ02
    n in dom W.edgeSeq() iff 2*n in dom W by Lm45;

theorem ::tWESEQ03
  for n being Element of NAT st n in dom W.edgeSeq()
    holds W.edgeSeq().n in the_Edges_of G proof
    let n be Element of NAT; assume n in dom W.edgeSeq(); then
    W.edgeSeq().n in rng W.edgeSeq() by FUNCT_1:def 5;
    hence W.edgeSeq().n in the_Edges_of G;
end;

theorem ::tWESEQ04
  ex lenWaa1 being even Element of NAT st lenWaa1 = len W - 1 &
  len W.edgeSeq() = lenWaa1 div 2 by Lm46;

theorem ::tWESEQ05
   W.cut(1,n).edgeSeq() c= W.edgeSeq() by Lm47;

theorem ::tWESEQ06
  e Joins W.last(),x,G implies
    W.addEdge(e).edgeSeq() = W.edgeSeq() ^ <*e*> by Lm48;

theorem Th84: ::tWESEQ07
  e Joins x,y,G iff
     G.walkOf(x,e,y).edgeSeq() = <*e*> proof
    set W = G.walkOf(x,e,y);
    hereby assume
    A1: e Joins x,y, G; then
        len W = 3 by Th15; then
        2+1 = 2*len W.edgeSeq()+1 by Def15; then
        2*1 = 2*len W.edgeSeq(); then
    A2: len W.edgeSeq() = 1; then
    A3: len W.edgeSeq() = len <*e*> by FINSEQ_1:56;
    A4: W = <*x,e,y*> by A1, Def5;
        now let k be Element of NAT; assume
        A5: 1 <= k & k <= len W.edgeSeq();
        A6: k = 1 by A5, A2, XXREAL_0:1; then
            W.edgeSeq().k = W.(2*1) by A5, Def15
                         .= e by A4, FINSEQ_1:62;
            hence W.edgeSeq().k = <*e*>.k by A6,FINSEQ_1:def 8;
        end;
        hence W.edgeSeq() = <*e*> by A3, FINSEQ_1:18;
    end;
    assume W.edgeSeq() = <*e*>; then
    len W.edgeSeq() = 1 by FINSEQ_1:56; then
A7: len W = 2*1+1 by Def15;
    now assume not e Joins x,y,G; then
        W = G.walkOf(choose the_Vertices_of G) by Def5;
        hence contradiction by A7,Th14;
    end;
    hence thesis;
end;

theorem ::tWESEQ08
  W.reverse().edgeSeq() = Rev (W.edgeSeq()) proof
    set W1 = W.reverse().edgeSeq(), W2 = Rev (W.edgeSeq());
A1: len W = len W.reverse() by Lm9;
    len W = 2 * len W.edgeSeq() + 1 by Def15; then
    2 * len W.edgeSeq() + 1 = 2 * len W1 + 1 by A1, Def15; then
    2 * len W.edgeSeq() = 2 * len W1; then
A2: len W1 = len W.edgeSeq(); then
A3: len W1 = len W2 by FINSEQ_5:def 3;
    now let n be Element of NAT; assume
    A4: 1 <= n & n <= len W1;
        set rn = len W.edgeSeq() - n + 1;
        reconsider rn as Element of NAT by A2,A4,FINSEQ_5:1;
    A5: n in Seg len W.edgeSeq() by A2, A4, FINSEQ_1:3; then
        rn in Seg len W.edgeSeq() by FINSEQ_5:2; then
    A6: 1 <= rn & rn <= len W.edgeSeq() by FINSEQ_1:3;
    A7: n in dom W.edgeSeq() by A5, FINSEQ_1:def 3; then
    A8: W2.n = W.edgeSeq().rn by FINSEQ_5:61
            .= W.(2*rn) by A6, Def15;
        2*n in dom W by A7, Lm45; then
        1 <= 2*n & 2*n <= len W.reverse() by A1, FINSEQ_3:27; then
    A9: 2*n in dom W.reverse() by FINSEQ_3:27;
    A10: W1.n = W.reverse().(2*n) by A4, Def15;
        len W - 2*n + 1 = 2*len W.edgeSeq() + 1 - 2*n + 1 by Def15
                       .= 2*rn;
        hence W1.n = W2.n by A8,A10,A9,Lm11;
    end;
    hence thesis by A3, FINSEQ_1:18;
end;

theorem ::tWESEQ09
  W1.last() = W2.first() implies
    W1.append(W2).edgeSeq() = W1.edgeSeq() ^ W2.edgeSeq() proof
    set W3 = W1.append(W2), W4 = W1.edgeSeq() ^ W2.edgeSeq(); assume
A1: W1.last() = W2.first();
A2: len W4 = len W1.edgeSeq() + len W2.edgeSeq() by FINSEQ_1:35;
    len W3 + 1 = len W1 + len W2 by A1, Lm13; then
    len W3 + 1 = len W1 + (2*len W2.edgeSeq() + 1) by Def15
              .= len W1 + 2*len W2.edgeSeq() + 1; then
    len W3 = 2*len W2.edgeSeq() + len W1; then
    2*len W3.edgeSeq()+1 = 2*len W2.edgeSeq()+len W1 by Def15
                  .= 2*len W2.edgeSeq()+(2*len W1.edgeSeq()+1) by Def15
                  .= 2*len W2.edgeSeq()+2*len W1.edgeSeq()+1;then
    2*len W3.edgeSeq() = 2*(len W1.edgeSeq() + len W2.edgeSeq()); then
A3: len W3.edgeSeq() = len W4 by A2;
A4: W3 = W1 ^' W2 by A1, Def10;
    now let n be Element of NAT; assume
    A5: 1 <= n & n <= len W3.edgeSeq(); then
    A6: n in dom W4 by A3, FINSEQ_3:27;
    A7: W3.edgeSeq().n = W3.(2*n) by A5, Def15;
        now per cases by A6, FINSEQ_1:38;
        suppose
        A8: n in dom W1.edgeSeq(); then
        A9: 1 <= n & n <= len W1.edgeSeq() by FINSEQ_3:27;
        A10: W4.n = W1.edgeSeq().n by A8, FINSEQ_1:def 7
                .= W1.(2*n) by A9, Def15;
            2*n in dom W1 by A8, Lm45; then
            1 <= 2*n & 2*n <= len W1 by FINSEQ_3:27;
            hence W3.edgeSeq().n = W4.n by A4,A7,A10,GRAPH_2:14; end;
        suppose ex k being Element of NAT st k in dom W2.edgeSeq() &
                n = len W1.edgeSeq() + k;
                then consider k being Element of NAT such that
        A11: k in dom W2.edgeSeq() & n = len W1.edgeSeq() + k;
        A12: 1 <= k & k <= len W2.edgeSeq() by A11, FINSEQ_3:27; then
            1 <= k+k by NAT_1:12; then
            reconsider 2kaa1 = 2*k-1 as Element of NAT by INT_1:18;
        A13: W4.n = W2.edgeSeq().k by A11, FINSEQ_1:def 7
                .= W2.(2*k) by A12, Def15;
            2*n+1 = 2*k + (2*len W1.edgeSeq()+1) by A11
                 .= 2*k + len W1 by Def15; then
        A14: 2*n = len W1 + (2*k-1);
            1+1 <= k+k by A12, XREAL_1:9; then
        A15: 1+1-1 <= 2kaa1 by REAL_1:92;
            2*k <= 2*len W2.edgeSeq() by A12, XREAL_1:66; then
            2*k < 2*len W2.edgeSeq() + 1 by NAT_1:13; then
            2*k < len W2 by Def15; then
            2kaa1 < len W2 - 0 by REAL_1:92; then
            W3.(2*n) = W2.(2kaa1+1) by A4, A14, A15, GRAPH_2:15
                    .= W2.(2*k);
            hence W3.edgeSeq().n = W4.n by A5,Def15,A13; end;
        end;
        hence W3.edgeSeq().n = W4.n;
    end;
    hence thesis by A3, FINSEQ_1:18;
end;

theorem Th87: ::tWESEQ10
  for W1 being Walk of G1, W2 being Walk of G2 st W1 = W2 holds
    W1.edgeSeq() = W2.edgeSeq() proof
    let W1 be Walk of G1, W2 be Walk of G2;
    set ES1 = W1.edgeSeq(), ES2 = W2.edgeSeq(); assume
A1: W1 = W2;
    now thus len ES1 = len ES1;
        2 * len ES1 + 1 = len W2 by A1, Def15
                       .= 2 * len ES2 + 1 by Def15; then
        2 * len ES1 = 2 * len ES2;
        hence
    A2: len ES2 = len ES1;
        let x be Element of NAT; assume x in Seg len ES1; then
        x in dom ES1 by FINSEQ_1:def 3; then
    A3: 1 <= x & x <= len ES1 & x <= len ES2 by A2, FINSEQ_3:27;
        hence ES1.x = W2.(2*x) by A1, Def15
                   .= ES2.x by A3, Def15;
    end;
    hence thesis by FINSEQ_2:10;
end;

theorem ::tWVERTICES01
  x in W.vertices() iff
     ex n being odd Element of NAT st n <= len W & W.n = x by Lm49;

theorem Th89: ::tWVERTICES02
    W.first() in W.vertices() & W.last() in W.vertices() proof
    1 <= len W by HEYTING3:1;
    hence W.first() in W.vertices() by  JORDAN12:3, Lm49;
    thus W.last() in W.vertices() by Lm49;
end;

theorem Th90: ::tWVERTICES03
  for n being odd Element of NAT st n <= len W holds
    W.vertexAt(n) in W.vertices() proof
    let n be odd Element of NAT; assume
A1: n <= len W;
    W.vertexAt(n) = W.n by A1, Def8;
    hence thesis by A1, Lm49;
end;

theorem ::tWVERTICES04
  G.walkOf(v).vertices() = {v} proof
    now let x be set;
        hereby assume x in G.walkOf(v).vertices(); then
            consider n being odd Element of NAT such that
        A1: n <= len G.walkOf(v) & G.walkOf(v).n = x by Lm49;
        A2: n <= 1 by A1, Th14;
            1 <= n by HEYTING3:1; then
            x = G.walkOf(v).1 by A1,A2,XXREAL_0:1; then
            x = v by Th14;
            hence x in {v} by TARSKI:def 1;
        end;
        assume x in {v}; then
    A3: x = v by TARSKI:def 1;
    A4: 1 <= len G.walkOf(v) & 1 is odd by HEYTING3:1, JORDAN12:3;
        G.walkOf(v).1 = v by Th14;
        hence x in G.walkOf(v).vertices() by A3,A4,Lm49;
    end;
    hence thesis by TARSKI:2;
end;

theorem Th92: ::tWVERTICES05
  e Joins x,y,G implies G.walkOf(x,e,y).vertices() = {x,y} proof
    set W = G.walkOf(x,e,y);
    assume e Joins x, y, G; then
    W.vertexSeq() = <*x,y*> by Th71; then
    W.vertices() = rng <*x,y*>;
    hence W.vertices() = {x,y} by FINSEQ_2:147;
end;

theorem ::tWVERTICES06
  W.vertices() = W.reverse().vertices() proof
    now let x be set;
        hereby assume
        A1: x in W.vertices(); then
            consider n being odd Element of NAT such that
        A2: n <= len W & W.n = x by Lm49;
            1 <= n by HEYTING3:1; then
        A3: n in dom W by A2, FINSEQ_3:27; then
        A4: W.reverse().(len W - n + 1) = x by A2, Th25;
            reconsider lenW = len W as odd Element of NAT;
        A5: lenW-n+1 is odd Element of NAT by A2, FINSEQ_5:1;
            n in Seg len W by A3, FINSEQ_1:def 3; then
            lenW-n+1 in Seg len W by FINSEQ_5:2; then
        A6: lenW-n+1 in dom W by FINSEQ_1:def 3; then
            lenW-n+1 is Element of NAT; then
            lenW-n+1 <= len W by A6,FINSEQ_3:27; then
        A7: lenW-n+1 <= len W.reverse() by Lm9;
            reconsider v=x as Vertex of G by A1;
            thus x in W.reverse().vertices() by A4,A5,A7,Lm49;
        end;
        assume
    A8: x in W.reverse().vertices(); then
        consider n being odd Element of NAT such that
    A9: n <= len W.reverse() & W.reverse().n = x by Lm49;
    A10: 1 <= n by HEYTING3:1; then
        n in dom W.reverse() by A9, FINSEQ_3:27; then
    A11: W.(len W - n + 1) = x by A9, FINSEQ_5:def 3;
        reconsider lenW = len W as odd Element of NAT;
    A12: n <= len W by A9, Lm9; then
    A13: lenW-n+1 is odd Element of NAT by FINSEQ_5:1;
        n in Seg len W by A10,A12, FINSEQ_1:3; then
        lenW-n+1 in Seg len W by FINSEQ_5:2; then
    A14: lenW-n+1 <= len W by A13, FINSEQ_1:3;
        reconsider v = x as Vertex of G by A8;
        thus x in W.vertices() by A11,A13,A14,Lm49;
    end;
    hence thesis by TARSKI:2;
end;

theorem Th94: ::tWVERTICES07
  W1.last() = W2.first() implies
  W1.append(W2).vertices() = W1.vertices() \/ W2.vertices() proof
    set W = W1.append(W2); assume
A1: W1.last() = W2.first(); then
A2: W = W1 ^' W2 by Def10;
    now let x be set;
        hereby assume
        A3: x in W.vertices(); then reconsider v=x as Vertex of G;
            consider n being odd Element of NAT such that
        A4: n <= len W & W.n = v by A3, Lm49;
        A5: 1 <= n by HEYTING3:1;
            now per cases;
            suppose
            A6: n <= len W1; then
                n in dom W1 by A5, FINSEQ_3:27; then
                W1.n = v by A4,Lm16; then
                v in W1.vertices() by A6, Lm49;
                hence x in W1.vertices()\/W2.vertices() by XBOOLE_0:def 2; end;
            suppose
            A7: n > len W1; then consider k being Nat such that
            A8: len W1 + k = n by NAT_1:10;
                reconsider lenW1 = len W1 as odd Element of NAT;
                now assume k is odd; then
                   reconsider k'=k as odd Element of NAT by ORDINAL1:def 13;
                   lenW1 + k' = n by A8;
                   hence contradiction;
                end; then reconsider k as even Element of NAT
                by ORDINAL1:def 13;
                k <> 0 by A7, A8 ; then
                0 < k; then
            A9: 0+1 <= k by NAT_1:13;
                len W1 + k + 1 <= len W + 1 by A4,A8,XREAL_1:9; then
                (k + 1) + len W1 <= len W2 + len W1 by A1,Lm13; then
            A10: k + 1 + len W1 - len W1 <= len W2 + len W1 - len W1
                  by REAL_1:92; then
                k < len W2 - 1 + 1 by NAT_1:13; then
            A11: W2.(k+1) = v by A2, A4, A8, A9, GRAPH_2:15;
                W2.vertexAt(k+1) in W2.vertices() by A10, Th90; then
                v in W2.vertices() by Def8, A10, A11;
                hence x in W1.vertices() \/ W2.vertices()
                  by XBOOLE_0:def 2; end;
            end;
            hence x in W1.vertices() \/ W2.vertices();
        end;
        assume
    A12: x in W1.vertices() \/ W2.vertices();
    A13: now assume x in W1.vertices(); then
            consider n being odd Element of NAT such that
        A14: n <= len W1 & W1.n = x by Lm49;
            1 <= n by HEYTING3:1; then
            n in dom W1 by A14, FINSEQ_3:27; then
            W.n = W1.n & n in dom W by Lm16; then
            W.n = x & n <= len W by A14, FINSEQ_3:27;
            hence x in W.vertices() by Lm49;
        end;
        now per cases by A12, XBOOLE_0:def 2;
        suppose x in W1.vertices();
            hence x in W.vertices() by A13; end;
        suppose x in W2.vertices();
        then consider n being odd Element of NAT such that
        A15: n <= len W2 & W2.n = x by Lm49;
            now per cases;
            suppose n = 1; then
                W1.last() = x by A1,A15;
                hence x in W.vertices() by A13,Th89; end;
            suppose n <> 1;
                1 <= n by HEYTING3:1; then
                reconsider naa1 = n-1 as even Element of NAT by INT_1:18;
                naa1 < len W2 - 0 by A15, REAL_1:92; then
            A16: W.(len W1 + naa1) = W2.(naa1 + 1) & (len W1 + naa1) in dom W
                  by A1, Lm17;
                reconsider lenW1 = len W1 as odd Element of NAT;
                lenW1 + naa1 <= len W by A16, FINSEQ_3:27;
                hence x in W.vertices() by A16,A15,Lm49; end;
            end;
            hence x in W.vertices(); end;
        end;
        hence x in W.vertices();
    end;
    hence thesis by TARSKI:2;
end;

theorem ::tWVERTICES08
  for m,n being odd Element of NAT st m <= n & n <= len W holds
    W.cut(m,n).vertices() c= W.vertices() proof
    let m, n be odd Element of NAT; set W2 = W.cut(m,n); assume
A1: m <= n & n <= len W;
    now let x be set; assume x in W2.vertices(); then
    consider n being odd Element of NAT such that
A2: n <= len W2 & W2.n = x by Lm49;
    1 <= n by HEYTING3:1; then
    reconsider naa1 = n - 1 as even Element of NAT by INT_1:18;
    naa1 < len W2 - 0 by A2, REAL_1:92; then
A3: W2.(naa1+1) = W.(m+naa1) & m+naa1 in dom W by A1, Lm19; then
    m+naa1 <= len W by FINSEQ_3:27;
    hence x in W.vertices() by A2,A3,Lm49;
    end;
    hence thesis by TARSKI:def 3;
end;

theorem Th96: ::tWVERTICES09
  e Joins W.last(),x,G implies
  W.addEdge(e).vertices() = W.vertices() \/ {x} proof
    set W2 = G.walkOf(W.last(), e, W.last().adj(e));
    set W3 = W.addEdge(e), WV = W.vertices(); assume
A1: e Joins W.last(), x, G;
    reconsider x'=x as Vertex of G by A1, GLIB_000:16;
A2: W.last().adj(e) = x' by A1, GLIB_000:69; then
    W2.first() = W.last() by A1, Th16; then
A3: W3.vertices() = WV \/ W2.vertices() by  Th94;
A4: W2.vertices() = {W.last(), x} by A1,A2, Th92;
    now let y be set;
        hereby assume
        A5: y in WV \/ {W.last(), x};
            now per cases by A5, XBOOLE_0:def 2;
            suppose y in WV;
                hence y in WV \/ {x} by XBOOLE_0:def 2; end;
            suppose
            A6: y in {W.last(), x};
                now per cases by A6, TARSKI:def 2;
                suppose y = W.last(); then
                    y in WV by Th89;
                    hence y in WV \/ {x} by XBOOLE_0:def 2; end;
                suppose y = x; then
                    y in {x} by TARSKI:def 1;
                    hence y in WV \/ {x} by XBOOLE_0:def 2; end;
                end;
                hence y in WV \/ {x}; end;
            end;
            hence y in WV \/ {x};
        end;
        assume
    A7: y in WV \/ {x};
        now per cases by A7, XBOOLE_0:def 2;
        suppose y in WV;
            hence y in WV \/ {W.last(), x} by XBOOLE_0:def 2; end;
        suppose y in {x}; then
            y = x by TARSKI:def 1; then
            y in {W.last(), x} by TARSKI:def 2;
            hence y in WV \/ {W.last(), x} by XBOOLE_0:def 2; end;
        end;
        hence y in WV \/ {W.last(), x};
    end;
    hence thesis by A3,A4,TARSKI:2;
end;

theorem ::tWVERTICES10
  for G being finite _Graph, W being Walk of G, e,x being set holds
    e Joins W.last(),x,G & not x in W.vertices() implies
    card W.addEdge(e).vertices() = card W.vertices() + 1 proof
    let G be finite _Graph, W be Walk of G, e, x be set; assume
A1: e Joins W.last(),x,G & not x in W.vertices(); then
    card W.addEdge(e).vertices() = card (W.vertices()\/{x}) by Th96;
    hence thesis by A1, CARD_2:54;
end;

theorem ::tWVERTICES11
   x in W.vertices() & y in W.vertices() implies
     ex W' being Walk of G st W' is_Walk_from x,y proof
    assume
A1: x in W.vertices() & y in W.vertices(); then
    consider m being odd Element of NAT such that
A2: m <= len W & W.m = x by Lm49;
    consider n being odd Element of NAT such that
A3: n <= len W & W.n = y by A1, Lm49;
    now per cases;
        suppose m <= n; then
        W.cut(m,n) is_Walk_from x, y by A2,A3,Lm20;
        hence thesis; end;
        suppose n <= m; then
        W.cut(n,m) is_Walk_from y, x by A2,A3,Lm20; then
        W.cut(n,m).reverse() is_Walk_from x, y by Th24;
        hence thesis; end;
    end;
    hence thesis;
end;

theorem Th99: ::tWVERTICES12
  for W1 being Walk of G1, W2 being Walk of G2 st W1 = W2 holds
    W1.vertices() = W2.vertices() by Th77;

theorem ::tWEDGES01
   e in W.edges() iff
     ex n being even Element of NAT st 1 <= n & n <= len W & W.n = e by Lm50;

theorem Th101: ::tWEDGES02
  e in W.edges() iff
    ex n being odd Element of NAT st n < len W & W.(n+1) = e proof
    hereby assume e in W.edges(); then
        consider n1 being even Element of NAT such that
    A1: 1 <= n1 & n1 <= len W & W.n1 = e by Lm50;
        reconsider n = n1-1 as odd Element of NAT by A1, INT_1:18;
        take n;
        n1-1 < len W - 0 by A1, REAL_1:92;
        hence n < len W;
        thus W.(n+1) = e by A1;
    end;
    given n being odd Element of NAT such that
A2: n < len W & W.(n+1) = e;
A3: n+1 <= len W by A2,NAT_1:13;
    1 <= n+1 by NAT_1:12;
    hence e in W.edges() by A2, A3, Lm50;
end;

theorem Th102: ::tWEDGES03
  rng W = W.vertices() \/ W.edges() proof
    now let y be set; assume y in rng W; then
        consider x being Element of NAT such that
    A1: x in dom W & W.x = y by FINSEQ_2:11;
    A2: 1 <= x & x <= len W by A1, FINSEQ_3:27;
        now per cases;
            suppose x is odd; then
            y in W.vertices() by A1, A2, Lm49;
            hence y in W.vertices() \/ W.edges() by XBOOLE_0:def 2; end;
            suppose x is even; then
            y in W.edges() by A1, A2, Lm50;
            hence y in W.vertices() \/ W.edges() by XBOOLE_0:def 2; end;
        end;
        hence y in W.vertices() \/ W.edges();
    end; then
A3: rng W c= W.vertices() \/ W.edges() by TARSKI:def 3;
    now let y be set; assume
    A4: y in W.vertices() \/ W.edges();
        now per cases by A4, XBOOLE_0:def 2;
            suppose y in W.vertices(); then
            consider x being odd Element of NAT such that
        A5: x <= len W & W.x = y by Lm49;
            1 <= x by HEYTING3:1; then
            x in dom W by A5, FINSEQ_3:27;
            hence y in rng W by A5, FUNCT_1:def 5; end;
            suppose y in W.edges(); then
            consider x being even Element of NAT such that
        A6: 1 <= x & x <= len W & W.x = y by Lm50;
            x in dom W by A6, FINSEQ_3:27;
            hence y in rng W by A6, FUNCT_1:def 5; end;
        end;
        hence y in rng W;
    end; then
    W.vertices() \/ W.edges() c= rng W by TARSKI:def 3;
    hence rng W = W.vertices() \/ W.edges() by A3, XBOOLE_0:def 10;
end;

theorem Th103: ::tWEDGES04
  W1.last() = W2.first() implies
    W1.append(W2).edges() = W1.edges() \/ W2.edges() proof
    set W = W1.append(W2);
    set WV = W.vertices(), W1V = W1.vertices(), W2V = W2.vertices();
    set WE = W.edges(),    W1E = W1.edges(),    W2E = W2.edges(); assume
A1: W1.last() = W2.first(); then
A2: W = W1 ^' W2 by Def10;
    set lenW1 = len W1, lenW2 = len W2;
    reconsider lenW1, lenW2 as odd Element of NAT;
    now let x be set;
        hereby assume x in WE;
        then consider n being even Element of NAT such that
        A3: 1 <= n & n <= len W & W.n = x by Lm50;
            now per cases;
            suppose
            A4: n <= len W1; then
                W.n = W1.n by A2, A3, GRAPH_2:14; then
                x in W1E by A3, A4, Lm50;
                hence x in W1E \/ W2E by XBOOLE_0:def 2; end;
            suppose len W1 < n; then
                reconsider k = n-lenW1 as odd Element of NAT by INT_1:18;
            A5: 1 <= k by HEYTING3:1;
                n - lenW1 + len W1 < len W + 1 by A3,NAT_1:13; then
                n-lenW1 + lenW1 < lenW2 + len W1 by A1, Lm13; then
            A6: k < lenW2 + len W1 - len W1 by REAL_1:92; then
            A7: W2.(k+1) = W.(len W1+k) by A2, A5, GRAPH_2:15
                        .= x by A3;
            A8: 1 <= k+1 by NAT_1:12;
                k+1 <= len W2 by A6,NAT_1:13; then
                x in W2E by A7, A8, Lm50;
                hence x in W1E \/ W2E by XBOOLE_0:def 2; end;
            end;
            hence x in W1E \/ W2E;
        end;
        assume
    A9: x in W1E \/ W2E;
        now per cases by A9, XBOOLE_0:def 2;
            suppose x in W1E;
            then consider n being even Element of NAT such that
        A10: 1 <= n & n <= len W1 & W1.n = x by Lm50;
        A11: W.n = x by A2, A10, GRAPH_2:14;
            len W1 <= len W by A1, Lm14; then
            n <= len W by A10, XXREAL_0:2;
            hence x in WE by A10, A11, Lm50; end;

            suppose x in W2E;
            then consider n being even Element of NAT such that
        A12: 1 <= n & n <= len W2 & W2.n = x by Lm50;
            reconsider naa1 = n-1 as odd Element of NAT by A12, INT_1:18;
        A13: 1 <= naa1 by HEYTING3:1;
             naa1 < len W2 by A12, SPPOL_1:5; then
        A14:  W.(lenW1 + naa1) = W2.(naa1+1) by A2, A13, GRAPH_2:15
                            .= x by A12;
            1 <= lenW1 by HEYTING3:1; then
        A15: 1 <= lenW1+naa1 by NAT_1:12;
            (naa1 + 1) + lenW1 <= len W2 + len W1 by A12,XREAL_1:9; then
            lenW1 + naa1 + 1 <= len W + 1 by A1, Lm13; then
            lenW1+naa1 <= len W by XREAL_1:8;
            hence x in WE by A14, A15, Lm50; end;
        end;
        hence x in WE;
    end;
    hence thesis by TARSKI:2;
end;

theorem ::tWEDGES05
  e in W.edges() implies
  ex v1, v2 being Vertex of G, n being odd Element of NAT st
    n+2 <= len W & v1 = W.n & e = W.(n+1) & v2 = W.(n+2) &
    e Joins v1, v2,G by Lm51;

theorem Th105: ::tWEDGES06
  e in W.edges() iff
    ex n being Element of NAT st n in dom W.edgeSeq() & W.edgeSeq().n = e proof
    hereby assume e in W.edges(); then
        e in rng W.edgeSeq(); then
        consider n being set such that
    A1: n in dom W.edgeSeq() & W.edgeSeq().n = e by FUNCT_1:def 5;
        reconsider n as Element of NAT by A1;
        take n;
        thus n in dom W.edgeSeq() & W.edgeSeq().n = e by A1;
    end;
    given n being Element of NAT such that
A2: n in dom W.edgeSeq() & W.edgeSeq().n = e;
    e in rng W.edgeSeq() by A2, FUNCT_1:def 5;
    hence thesis;
end;

theorem ::tWEDGES07
  e in W.edges() & e Joins x,y,G implies
    x in W.vertices() & y in W.vertices() by Lm52;

theorem ::tWEDGES08
  W.cut(m,n).edges() c= W.edges() proof
    now per cases;
    suppose
    A1: m is odd & n is odd & m <= n & n <= len W; then
        reconsider m' = m as odd Element of NAT;
        now let e be set; assume e in W.cut(m,n).edges(); then
            consider x being even Element of NAT such that
        A2: 1 <= x & x <= len W.cut(m,n) & W.cut(m,n).x = e
              by Lm50;
            reconsider xaa1 = x-1 as odd Element of NAT by A2, INT_1:18;
        A3: xaa1+1 = x;
            xaa1 < len W.cut(m,n) - 0 by A2, REAL_1:92; then
        A4: e = W.(m+xaa1) & m+xaa1 in dom W by A1, A2, A3, Lm19; then
            1 <= m'+xaa1 & m'+xaa1 <= len W by FINSEQ_3:27;
            hence e in W.edges() by A4, Lm50;
        end;
        hence thesis by TARSKI:def 3; end;
    suppose not (m is odd & n is odd & m <= n & n <= len W);
        hence thesis by Def11; end;
    end;
    hence thesis;
end;

theorem Th108: ::tWEDGES09
  W.edges() = W.reverse().edges() proof
    now let e be set;
        hereby assume e in W.edges(); then
            consider n being even Element of NAT such that
        A1: 1 <= n & n <= len W & W.n = e by Lm50;
            n in dom W by A1, FINSEQ_3:27; then
        A2: e = W.reverse().(len W - n + 1) &
              (len W - n + 1) in dom W.reverse() by A1, Th25; then
            reconsider rn = len W - n + 1 as even Element of NAT;
            1 <= rn & rn <= len W.reverse() by A2, FINSEQ_3:27;
            hence e in W.reverse().edges() by A2, Lm50;

        end;
        assume e in W.reverse().edges(); then
        consider n being even Element of NAT such that
    A3: 1 <= n & n <= len W.reverse() & W.reverse().n = e by Lm50;
        n in dom W.reverse() by A3, FINSEQ_3:27; then
    A4: e = W.reverse().reverse().(len W.reverse() - n + 1) &
          (len W.reverse() - n + 1) in dom W.reverse().reverse()
          by A3, Th25; then
        reconsider rn = len W.reverse() - n + 1 as even Element of NAT;
    A5: e = W.rn & rn in dom W by A4, Lm12; then
        1 <= rn & rn <= len W by FINSEQ_3:27;
        hence e in W.edges() by A5, Lm50;
    end;
    hence thesis by TARSKI:2;
end;

theorem Th109: ::tWEDGES10
  e Joins x,y,G iff G.walkOf(x,e,y).edges() = {e} proof
    set W = G.walkOf(x,e,y);
    hereby assume e Joins x,y,G; then
        W.edgeSeq() = <*e*> by Th84;
        hence W.edges() = {e} by FINSEQ_1:56;
    end;
    assume W.edges() = {e}; then
    e in W.edges() by TARSKI:def 1; then
    consider n being even Element of NAT such that
A1: 1 <= n & n <= len W & W.n = e by Lm50;
A2: 2*0+1 < n by A1, REAL_1:def 5;
    now assume not e Joins x,y,G; then
        W = G.walkOf(choose the_Vertices_of G) by Def5;
        hence contradiction by A1,A2,Th14;
    end;
    hence thesis;
end;

theorem ::tWEDGES11
  W.edges() c= G.edgesBetween(W.vertices()) proof
    now let e be set; assume e in W.edges(); then
        consider v1,v2 being Vertex of G, n being odd Element of NAT such that
    A1: n+2 <= len W & v1 = W.n & e = W.(n+1) & v2 = W.(n+2) &
        e Joins v1,v2,G by Lm51;
        n < len W by A1, Th1; then
    A2: v1 in W.vertices() by A1, Lm49;
        v2 in W.vertices() by A1, Lm49;
        hence e in G.edgesBetween(W.vertices()) by A1, A2, GLIB_000:35;
    end;
    hence thesis by TARSKI:def 3;
end;

theorem ::tWEDGES12
  for W1 being Walk of G1, W2 being Walk of G2 st W1 = W2 holds
    W1.edges() = W2.edges() by Th87;

theorem ::tWEDGES13
  e Joins W.last(),x,G implies
    W.addEdge(e).edges() = W.edges() \/ {e} proof
    set W2 = W.addEdge(e), WB = G.walkOf(W.last(),e,W.last().adj(e));
    assume e Joins W.last(),x,G; then
    e in W.last().edgesInOut() by GLIB_000:65; then
A1: e Joins W.last(), W.last().adj(e), G by GLIB_000:70;
A2: WB.edges() = {e} by A1,Th109;
    WB.first() = W.last() by A1,Th16;
    hence thesis by A2,Th103;
end;

theorem ::tWLENGTH01
   len W = 2 * W.length() + 1 by Lm53;

theorem ::tWLENGTH02
  len W1 = len W2 iff W1.length() = W2.length() proof
    hereby assume len W1 = len W2; then
        2 * W1.length() + 1 = len W2 by Lm53
                           .= 2 * W2.length() + 1 by Lm53; then
        2 * W1.length() = 2 * W2.length();
        hence W1.length() = W2.length();
    end;
    assume W1.length() = W2.length();
    hence len W1 = 2*W2.length()+1 by Lm53
                .= len W2 by Lm53;
end;

theorem ::tWLENGTH03
  for W1 being Walk of G1, W2 being Walk of G2 st W1 = W2 holds
      W1.length() = W2.length() by Th87;

theorem Th116: ::tWFINDV01
  for n being odd Element of NAT st n <= len W holds
    W.find(W.n) <= n & W.rfind(W.n) >= n proof
    let n be odd Element of NAT; assume
A1: n <= len W; then
A2: W.n in W.vertices() by Lm49;
    hence W.find(W.n) <= n by A1,Def19;
    thus thesis by A1,A2,Def21;
end;

theorem ::tWFINDV02
  for W1 being Walk of G1, W2 being Walk of G2, v being set st W1 = W2 holds
    W1.find(v) = W2.find(v) & W1.rfind(v) = W2.rfind(v) proof
    let W1 be Walk of G1, W2 be Walk of G2, v be set; assume
A1: W1 = W2;
    now per cases;
    suppose
    A2: v in W1.vertices(); then
    A3: v in W2.vertices() by A1,Th99;
        W1.find(v) <= len W2 & W2.(W1.find(v)) = v &
        for n being odd Element of NAT st n <= len W2 & W2.n = v
        holds W1.find(v) <= n
          by A1, A2, Def19;
        hence W1.find(v) = W2.find(v) by A3,Def19;
        W1.rfind(v) <= len W2 & W2.(W1.rfind(v)) = v &
          for n being odd Element of NAT st n <= len W2 & W2.n = v
          holds n <= W1.rfind(v)
          by A1, A2, Def21;
        hence W1.rfind(v) = W2.rfind(v) by A3,Def21; end;
    suppose
    A4: not v in W1.vertices(); then
    A5: not v in W2.vertices() by A1,Th99;
        thus W1.find(v) = len W2 by A1, A4, Def19
                       .= W2.find(v) by A5,Def19;
        thus W1.rfind(v) = len W2 by A1, A4, Def21
                        .= W2.rfind(v) by A5,Def21; end;
    end;
    hence thesis;
end;

theorem ::tWFINDN01
  for n being odd Element of NAT st n <= len W holds
    W.find(n) <= n & W.rfind(n) >= n by Lm54, Lm55;

theorem Th119: ::tCLWALK01
  W is closed iff W.1 = W.(len W) proof
    hereby assume W is closed; then
        W.first() = W.last() by Def24; then
        W.1 = W.last();
        hence W.1 = W.(len W);
    end;
    assume W.1 = W.(len W); then
    W.first() = W.(len W); then
    W.first() = W.last();
    hence W is closed by Def24;
end;

theorem ::tCLWALK02
  W is closed iff ex x being set st W is_Walk_from x,x proof
    hereby assume W is closed; then
    A1: W.first() = W.last() by Def24;
        set x = W.first();
        W is_Walk_from x,x by A1, Def23;
        hence ex x being set st W is_Walk_from x,x;
    end;
    given v being set such that
A2: W is_Walk_from v,v;
    W.first() = v & W.last() = v by A2, Def23;
    hence W is closed by Def24;
end;

theorem ::tCLWALK03
  W is closed iff W.reverse() is closed proof
    W is closed iff W.first() = W.last() by Def24; then
    W is closed iff W.reverse().last() = W.last() by Th23; then
    W is closed iff W.reverse().last() = W.reverse().first() by Th23;
    hence thesis by Def24;
end;

theorem ::tCLWALK04
  for W1 being Walk of G1, W2 being Walk of G2 st W1 = W2 & W1 is closed
    holds W2 is closed proof
    let W1 be Walk of G1, W2 be Walk of G2; assume
    W1 = W2 & W1 is closed; then
    W2.1 = W2.(len W2) by Th119;
    hence W2 is closed by Th119;
end;

theorem ::tDIWALK01
  W is directed iff
  for n being odd Element of NAT st n < len W
    holds W.(n+1) DJoins W.n, W.(n+2), G by Lm56;

theorem ::tDIWALK02
  W is directed & W is_Walk_from x,y & e DJoins y,z,G
    implies W.addEdge(e) is directed & W.addEdge(e) is_Walk_from x,z
    by Lm57;

theorem ::tDIWALK03
  for W being DWalk of G, m,n being Element of NAT holds
    W.cut(m,n) is directed;

theorem ::tTVWALK01
  W is non trivial iff 3 <= len W by Lm59;

theorem ::tTVWALK02
  W is non trivial iff len W <> 1 by Lm60;

theorem Th128: ::tTVWALK03
  W.first() <> W.last() implies W is non trivial by Lm60;

theorem ::tTVWALK04
  W is trivial iff ex v being Vertex of G st W = G.walkOf(v) by Lm61;

theorem ::tTVWALK05
  W is trivial iff W.reverse() is trivial proof
    hereby assume W is trivial; then
         len W = 1 by Lm60; then
         len W.reverse() = 1 by Lm9;
         hence W.reverse() is trivial by Lm60;
    end;
    assume W.reverse() is trivial; then
    len W.reverse() = 1 by Lm60; then
    len W = 1 by Lm9;
    hence W is trivial by Lm60;
end;

theorem ::tTVWALK06
  W2 is trivial implies W1.append(W2) = W1 proof
    assume W2 is trivial; then
A1: len W2 = 1 by Lm60;  then
A2: W2 <> {} by FINSEQ_1:25;
    now per cases;
    suppose W1.last() = W2.first(); then
    A3: W1.append(W2) = W1 ^' W2 by Def10; then
        len W1.append(W2) + 1 = len W1 + 1 by A1, A2, GRAPH_2:13; then
    A4: len W1.append(W2) = len W1;
        for k being Element of NAT st 1 <= k & k <= len W1.append(W2)
          holds W1.append(W2).k = W1.k by A3,A4,GRAPH_2:14;
        hence thesis by A4, FINSEQ_1:18; end;
    suppose W1.last() <> W2.first();
       hence thesis by Def10; end;
    end;
    hence thesis;
end;

theorem ::tTVWALK07
  for m, n being odd Element of NAT st m <= n & n <= len W holds
    W.cut(m,n) is trivial iff m = n proof
    let m, n be odd Element of NAT; assume m <= n & n <= len W; then
    len W.cut(m,n) + m = n + 1 by Lm19; then
A1: len W.cut(m,n) = (n - m) + 1;
    hereby assume W.cut(m,n) is trivial; then
        1 = (n - m) + 1 by A1,Lm60; then
        n - m = 0;
        hence m = n;
    end;
    assume m = n;
    hence W.cut(m,n) is trivial by A1,Lm60;
end;

theorem Th133: ::tTVWALK08
  e Joins W.last(),x,G implies W.addEdge(e) is non trivial proof
A1: 1 + 0 < len W + 2 by XREAL_1:10;
    assume e Joins W.last(), x, G; then
    len W.addEdge(e) = len W + 2 by Lm41;
    hence thesis by A1,Lm60;
end;

theorem Th134: ::tTVWALK09
  W is non trivial implies ex lenW2 being odd Element of NAT
  st lenW2 = len W - 2 &
    W.cut(1,lenW2).addEdge(W.(lenW2+1)) = W proof
    assume W is non trivial; then
A1: len W >= 3 by Lm59;
    set lenW2 = len W - 2*1;
    2 <= len W by A1, XXREAL_0:2; then reconsider lenW2 as odd Element of NAT
    by INT_1:18;
    take lenW2;
    thus lenW2 = len W - 2;
    set W1 = W.cut(1,lenW2), e = W.(lenW2+1);
    1 <= lenW2 & lenW2 < len W - 0 by REAL_1:92, HEYTING3:1;
    hence W1.addEdge(e) = W.cut(1,lenW2+2) by Th42,JORDAN12:3
                       .= W by Lm22;
end;

theorem Th135: ::tTVWALK10
  W2 is non trivial & W2.edges() c= W1.edges() implies
    W2.vertices() c= W1.vertices() proof
    assume
A1: W2 is non trivial & W2.edges() c= W1.edges(); then
A2: 3 <= len W2 by Lm59;
    now let v be set; assume v in W2.vertices(); then
        consider n being odd Element of NAT such that
    A3: n <= len W2 & W2.n = v by Lm49;
        now per cases;
        suppose n = len W2; then
            3-1 < n-0 by A2, REAL_1:92; then
            reconsider n5 = n-2*1 as odd Element of NAT by INT_1:18;
            n5 < n - 0 by REAL_1:92; then
        A4: n5 < len W2 by A3, XXREAL_0:2; then
        A5: W2.(n5+1) Joins W2.n5, W2.(n5+2), G by Def3;
            1 <= n5+1 & n5+1 <= len W2
              by A4,NAT_1:12,13; then
            W2.(n5+1) in W2.edges() by Lm50; then
            consider m being even Element of NAT such that
        A6: 1 <= m & m <= len W1 & W1.m = W2.(n5+1) by A1,Lm50;
            reconsider maa1 = m - 1 as odd Element of NAT by A6, INT_1:18;
        A7: maa1 < len W1 - 0 by A6, REAL_1:92; then
        A8: W1.(maa1+1) Joins W1.maa1, W1.(maa1+2), G by Def3;
        A9: W1.maa1 = W1.vertexAt(maa1) by A7, Def8;
        A10: maa1+2 <= len W1 by A7, Th1; then
            W1.(maa1+2) = W1.vertexAt(maa1+2) by Def8; then
            v = W1.vertexAt(maa1) or v = W1.vertexAt(maa1+2)
              by GLIB_000:18,A6,A3,A5,A8,A9;
            hence v in W1.vertices() by A7, A10, Th90; end;
        suppose n <> len W2; then
        A11: n < len W2 by A3, REAL_1:def 5; then
            W2.(n+1) in W2.edges() by Th101; then
            consider m being even Element of NAT such that
        A12: 1 <= m & m <= len W1 & W1.m = W2.(n+1) by A1,Lm50;
        A13: W1.m Joins v, W2.(n+2),G by A11,A3,A12,Def3;
            reconsider maa1 = m - 1 as odd Element of NAT by A12, INT_1:18;
        A14: maa1 < len W1 - 0 by A12, REAL_1:92; then
        A15: W1.(maa1+1) Joins W1.maa1, W1.(maa1+2), G by Def3;
        A16: W1.maa1 = W1.vertexAt(maa1) by A14, Def8;
        A17: maa1+2 <= len W1 by A14, Th1; then
            W1.(maa1+2) = W1.vertexAt(maa1+2) by Def8; then
            v = W1.vertexAt(maa1) or v = W1.vertexAt(maa1+2)
              by GLIB_000:18,A15,A16,A13;
            hence v in W1.vertices() by A14, A17, Th90; end;
        end;
        hence v in W1.vertices();
     end;
     hence thesis by TARSKI:def 3;
end;

theorem ::tTVWALK11
  W is non trivial implies
    for v being Vertex of G st v in W.vertices() holds not v is isolated proof
    assume W is non trivial; then
A1: len W <> 1 by Lm60;
    let v be Vertex of G; assume v in W.vertices(); then
    consider n being odd Element of NAT such that
A2: n <= len W & W.n = v by Lm49;
    now per cases;
    suppose
    A3: n = len W;
        1 <= len W by HEYTING3:1; then
        1 < len W by A1, REAL_1:def 5; then
        1+1 <= len W by NAT_1:13; then
        reconsider lenW2 = len W - 2*1 as odd Element of NAT by INT_1:18;
        lenW2 < len W - 0 by REAL_1:92; then
        W.(lenW2+1) Joins W.lenW2,W.(lenW2+2),G by Def3; then
        W.(lenW2+1) Joins v,W.lenW2,G by A2,A3,GLIB_000:17; then
        W.(lenW2+1) in v.edgesInOut() by GLIB_000:65;
        hence ex e being set st e in v.edgesInOut(); end;
    suppose n <> len W; then
        n < len W by A2, REAL_1:def 5; then
        W.(n+1) Joins v, W.(n+2), G by A2, Def3; then
        W.(n+1) in v.edgesInOut() by GLIB_000:65;
        hence ex e being set st e in v.edgesInOut(); end;
    end;
    hence not v is isolated by GLIB_000:def 51;
end;

theorem ::tTVWALK12
  W is trivial iff W.edges() = {} proof
    W is trivial iff W.length() = 0 by Def26; then
    W is trivial iff len W.edgeSeq() = 0; then
    W is trivial iff W.edgeSeq() = {} by FINSEQ_1:25;
    hence W is trivial implies W.edges() = {} by RELAT_1:60;
    assume W.edges() = {}; then
    rng W.edgeSeq() = {}; then
    W.edgeSeq() = {} by RELAT_1:64; then
    len W.edgeSeq() = 0 by FINSEQ_1:25; then
    W.length() = 0;
    hence W is trivial by Def26;
end;

theorem ::tTVWALK13
  for W1 being Walk of G1, W2 being Walk of G2 st W1 = W2 & W1 is trivial
    holds W2 is trivial proof
    let W1 be Walk of G1, W2 be Walk of G2; assume
    W1 = W2 & W1 is trivial; then
    len W2 = 1 by Lm60;
    hence thesis by Lm60;
end;

theorem ::tTLWALK01
  W is Trail-like iff
  for m,n being even Element of NAT st 1 <= m & m < n & n <= len W holds
    W.m <> W.n by Lm62;

theorem ::tTLWALK02
   len W <= 3 implies W is Trail-like by Lm66;

theorem ::tTLWALK03
  W is Trail-like iff W.reverse() is Trail-like by Lm63;

theorem ::tTLWALK04
  for W being Trail of G, m,n being Element of NAT
  holds W.cut(m,n) is Trail-like;

theorem ::tTLWALK05
  for W being Trail of G, e being set
    st e in W.last().edgesInOut() & not e in W.edges()
    holds W.addEdge(e) is Trail-like by Lm65;

theorem ::tTLWALK06
  for W being Trail of G, v being Vertex of G
    st v in W.vertices() & v is endvertex
    holds v = W.first() or v = W.last() proof
    let W be Trail of G, v be Vertex of G; assume
A1: v in W.vertices() & v is endvertex; then
    consider n being odd Element of NAT such that
A2: n <= len W & W.n = v by Lm49;
A3: W.vertexAt(n) = v by A2, Def8;
    consider e being set such that
A4: v.edgesInOut() = {e} & not e Joins v,v,G by A1, GLIB_000:def 53;
    now assume
    A5: v <> W.first() & v <> W.last(); then
    A6: n <> 1 & n <> len W by A2;
    A7: 1 <= n by HEYTING3:1; then
    A8: 1 < n by A6, REAL_1:def 5;
        reconsider naa1 = n-1 as even Element of NAT by A7,INT_1:18;
        1+1 <= n by A8, NAT_1:13; then
    A9: 1+1-1 <= n-1 by REAL_1:92;
        n <> len W by A2, A5; then
    A10: n < len W by A2, REAL_1:def 5; then
    A11: n+1 <= len W by NAT_1:13;
        n-1 < naa1+2 by NAT_1:16; then
    A12: W.(naa1) <> W.(n+1) by A9, A11, Lm62;
        W.(n-1) in v.edgesInOut() by A2, A3, A8, Th12; then
    A13: W.(n-1) = e by A4, TARSKI:def 1;
        W.(n+1) in v.edgesInOut() by A3, A10, Th11;
        hence contradiction by A4,A12, A13,TARSKI:def 1;
    end;
    hence thesis;
end;

theorem ::tTLWALK07
  for G being finite _Graph, W being Trail of G holds
    len W.edgeSeq() <= G.size() proof
    let G be finite _Graph, W be Trail of G;
    consider f being Function such that
A1: dom f = W.edgeSeq() & for x being set st x in W.edgeSeq() holds f.x = x`2
      from FUNCT_1:sch 3;
    now let y be set; assume y in rng f; then
        consider x being set such that
    A2: x in dom f & f.x = y by FUNCT_1:def 5;
    A3: x in W.edgeSeq() & y = x`2 by A1, A2;
        consider a,b being set such that
    A4: x = [a,b] by A1,A2,RELAT_1:def 1;
        y = b by A3, A4, MCART_1:def 2; then
        y in rng W.edgeSeq() by A1,A2,A4,RELAT_1:def 5;
        hence y in (the_Edges_of G);
    end; then
A5: rng f c= the_Edges_of G by TARSKI:def 3;
    now let x1,x2 be set; assume
    A6: x1 in dom f & x2 in dom f & f.x1 = f.x2; then
    A7: x1 in W.edgeSeq() & f.x1 = x1`2 & x2 in W.edgeSeq() & f.x2 = x2`2
          by A1;
        consider a1,b1 being set such that
    A8: x1 = [a1,b1] by A1,A6,RELAT_1:def 1;
        consider a2,b2 being set such that
    A9: x2 = [a2,b2] by A1,A6,RELAT_1:def 1;
    A10: b1 = f.x1 by A7,A8,MCART_1:def 2
          .= b2 by A6,A7,A9,MCART_1:def 2;
    A11: W.edgeSeq() is one-to-one by Def27;
    A12: a1 in dom W.edgeSeq() & W.edgeSeq().a1 = b1 by A1,A6,A8,FUNCT_1:8;
        a2 in dom W.edgeSeq() & W.edgeSeq().a2 = b1 by A1,A6,A9,A10,FUNCT_1:8;
        hence x1 = x2 by A8,A9,A10,A11,A12,FUNCT_1:def 8;
    end; then
    f is one-to-one by FUNCT_1:def 8; then
    Card W.edgeSeq() <=` Card (the_Edges_of G) by A1,A5,CARD_1:26; then
    card W.edgeSeq() <= card (the_Edges_of G) by CARD_2:57;
    hence len W.edgeSeq() <= G.size() by GLIB_000:def 27;
end;

theorem ::tPLWALK01
  len W <= 3 implies W is Path-like by Lm74;

theorem ::tPLWALK02
  (for m,n being odd Element of NAT st m <= len W & n <= len W & W.m = W.n
  holds m = n)
      implies W is Path-like by Lm71;

theorem ::tPLWALK03
  for W being Path of G st W is open holds
    for m, n being odd Element of NAT st m < n & n <= len W holds W.m <> W.n
    proof
    let W be Path of G; assume
A1: W is open;
    let m, n be odd Element of NAT; assume
A2: m < n & n <= len W;
    now assume
    A3: W.m = W.n; then
        m = 1 & n = len W by A2, Def28;
        hence contradiction by A1,A3,Th119;
    end;
    hence thesis;
end;

theorem ::tPLWALK04
   W is Path-like iff W.reverse() is Path-like by Lm68;

theorem ::tPLWALK05
   for W being Path of G, m, n being Element of NAT
     holds W.cut(m,n) is Path-like;

theorem Th151: ::tPLWALK06
  for W being Path of G, e,v being set
   st e Joins W.last(),v,G & not e in W.edges() & (W is trivial or W is open) &
     for n being odd Element of NAT st 1 < n & n <= len W holds W.n <> v holds
   W.addEdge(e) is Path-like proof
    let W be Path of G, e,v be set; assume
A1: e Joins W.last(), v,G & not e in W.edges() & (W is trivial or W is open) &
    (for n being odd Element of NAT st 1 < n & n <= len W holds W.n <> v); then
A2: e in W.last().edgesInOut() by GLIB_000:65;
    set W2 = W.addEdge(e); reconsider lenW = len W as odd Element of NAT;
    now thus W2 is Trail-like by A1, A2, Lm65;
        let m, n be odd Element of NAT; assume
    A3: m < n & n <= len W2 & W2.m = W2.n;
        now per cases by A1;
        suppose
        A4: W is open;
            now per cases;
            suppose
            A5: n <= len W; then
            A6: m <= len W by A3, XXREAL_0:2;
                1 <= m by HEYTING3:1; then
                m in dom W by A6, FINSEQ_3:27; then
            A7: W2.m = W.m by A1, Lm42;
                1 <= n by HEYTING3:1; then
                n in dom W by A5, FINSEQ_3:27; then
            A8: W.m = W.n by A1,A3,A7,Lm42; then
             m = 1 & n = len W by A3, A5, Def28; then
                W.first() = W.last() by A8;
            hence m = 1 & n = len W2 by A4, Def24; end;
            suppose n > len W; then
                lenW + 1 <= n by NAT_1:13; then
                lenW + 1 < n by REAL_1:def 5; then
                lenW + 1 + 1 <= n by NAT_1:13; then
                len W + (1+1) <= n; then
            A9: len W2 <= n by A1, Lm41; then
            A10: n = len W2 by A3, XXREAL_0:1; then
                W2.n = W2.(len W + 2) by A1, Lm41; then
            A11: W2.n = v by A1, Lm42;
                m < len W + (1 + 1) by A1,A3,A10,Lm41; then
                m < len W + 1 + 1; then
                m <= lenW + 1 by NAT_1:13; then
                m < lenW + 1 by REAL_1:def 5; then
            A12: m <= len W by NAT_1:13;
                1 <= m by HEYTING3:1; then
                m in dom W by A12, FINSEQ_3:27; then
            A13: W.m = v by A1,A3,A11,Lm42;
                now assume
                A14: m <> 1;
                    1 <= m by HEYTING3:1; then
                    1 < m by A14, REAL_1:def 5;
                    hence contradiction by A1,A12,A13;
                end;
                hence m = 1;
                thus n = len W2 by A9,A3,XXREAL_0:1; end;
            end;
            hence m = 1 & n = len W2; end;
        suppose W is trivial; then consider v being Vertex of G such that
        A15: W = G.walkOf(v) by Lm61;
            len W = 1 by A15, Th14; then
        A16: len W2 = 1 + 2 by A1, Lm41;
        A17: 1 <= m by HEYTING3:1; then
        A18: 1+1 <= m+1 by XREAL_1:9;
            m+1 <= n by A3, NAT_1:13; then
            2*1 <= n by A18, XXREAL_0:2; then
            2*1 < n by REAL_1:def 5; then
        A19: len W2 <= n by A16,NAT_1:13; then
            m < 3  by A3,A16,XXREAL_0:1; then
            m+1-1 <= 3-1 by A16,NAT_1:13; then
            m < 2*1 by REAL_1:def 5; then
            m+1 <= 2 by NAT_1:13; then
            m+1-1 <= 2-1 by REAL_1:92;
            hence m = 1 & n = len W2 by A3,A17,A19,XXREAL_0:1; end;
        end;
        hence m = 1 & n = len W2;
    end;
    hence W.addEdge(e) is Path-like by Def28;
end;

theorem ::tPLWALK07
  for W being Path of G, e, v being set st e Joins W.last(),v,G &
    not v in W.vertices() & (W is trivial or W is open)
    holds W.addEdge(e) is Path-like by Lm73;

theorem ::tPLWALK08
  (for n being odd Element of NAT st n <= len W
  holds W.find(W.n) = W.rfind(W.n))
    implies W is Path-like proof
    assume
A1: for n being odd Element of NAT st n <= len W
holds W.find(W.n) = W.rfind(W.n);
A2: now let x be odd Element of NAT; assume
    A3: x <= len W;
    A4: W.find(W.x) <= x by A3, Th116;
    A5: W.rfind(W.x) >= x by A3, Th116;
        W.find(W.x) = W.rfind(W.x) by A3, A1;
        hence W.find(W.x) = x & W.rfind(W.x) = x by A4, A5, XXREAL_0:1;
    end;
    now let m, n be even Element of NAT; assume
    A6: 1 <= m & m < n & n <= len W; then
        1 <= m & m <= len W by XXREAL_0:2; then
         m in dom W by FINSEQ_3:27; then
        consider maa1 being odd Element of NAT such that
    A7: maa1 = m-1 & m-1 in dom W & m+1 in dom W &
         W.m Joins W.(maa1), W.(m+1),G by Lm4;
         1 <= n & n <= len W by A6, XXREAL_0:2; then
        n in dom W by FINSEQ_3:27; then
        consider naa1 being odd Element of NAT such that
    A8: naa1 = n-1 & n-1 in dom W & n+1 in dom W &
          W.n Joins W.(naa1), W.(n+1),G by Lm4;
        now assume
        A9: W.m = W.n;
            set Wmaa1 = W.(maa1), Wm1 = W.(m+1);
            set Wnaa1 = W.(naa1), Wn1 = W.(n+1);
        A10: maa1 <= len W & n+1 <= len W & naa1 <= len W
              by A7, A8, FINSEQ_3:27;
        A11: W.find(Wmaa1) = maa1 & W.rfind(Wnaa1) = naa1 & W.rfind(Wn1) = n+1
              by A2, A10;
            now per cases by A9,A8,A7,GLIB_000:18;
            suppose Wmaa1 = Wnaa1 & Wm1 = Wn1; then
                maa1 = naa1 by A1,A10,A11; then
                m = n - 1 + 1 by A7,A8;
                hence contradiction by A6; end;
            suppose Wmaa1 = Wn1 & Wm1 = Wnaa1; then
                maa1 = n+1 by A1,A10,A11; then
                n <= maa1-1+1 by NAT_1:12; then
                n <= m-1+1 by A7, NAT_1:12;
                hence contradiction by A6; end;
            end;
            hence contradiction;
        end;
        hence W.m <> W.n;
    end; then
A12: W is Trail-like by Lm62;
    now let m, n be odd Element of NAT; assume
    A13: m < n & n <= len W & W.m = W.n; then
        m <= len W by XXREAL_0:2; then
        W.find(W.m) = m & W.find(W.m) = n by A2, A13;
        hence m = 1 & n = len W by A13;
    end;
    hence thesis by A12, Def28;
end;

theorem ::tPLWALK09
  (for n being odd Element of NAT st n <= len W holds W.rfind(n) = n)
    implies W is Path-like by Lm72;

theorem ::tPLWALK10
  for G being finite _Graph, W being Path of G holds
    len W.vertexSeq() <= G.order() + 1 proof
    let G be finite _Graph, W be Path of G;
    now per cases;
    suppose len W = 1; then
        1 + 1 = 2 * len W.vertexSeq() by Def14; then
        2*1 = 2*len W.vertexSeq(); then
        len W.vertexSeq() = 1;
        hence thesis by NAT_1:12; end;
    suppose len W <> 1; then
        W is non trivial by Lm60; then
        consider lenW2 being odd Element of NAT such that
    A1: lenW2 = len W - 2 & W.cut(1,lenW2).addEdge(W.(lenW2+1)) = W
          by Th134;
        set W2 = W.cut(1,lenW2), vs1 = W2.vertexSeq();
    A2: lenW2 < len W - 0 by A1, REAL_1:92; then
    A3: len W2 = lenW2 by Lm26;
        consider f being Function such that
    A4: dom f = vs1 & for x being set st x in vs1 holds f.x = x`2
          from FUNCT_1:sch 3;
        now let y be set; assume
            y in rng f; then consider x being set such that
        A5: x in dom f & f.x = y by FUNCT_1:def 5;
            consider a,b being set such that
        A6: x = [a,b] by A5,A4,RELAT_1:def 1;
            y = x`2 by A5, A4; then
        A7: y = b by A6, MCART_1:def 2;
            a in dom vs1 & b = vs1.a by A5,A4,A6,FUNCT_1:8; then
            y in rng vs1 by A7, FUNCT_1:def 5;
            hence y in the_Vertices_of G;
        end; then
    A8: rng f c= the_Vertices_of G by TARSKI:def 3;
        now let x1, x2 be set; assume
        A9: x1 in dom f & x2 in dom f & f.x1 = f.x2; then
            consider a1,b1 being set such that
        A10: x1 = [a1,b1] by A4,RELAT_1:def 1;
            consider a2,b2 being set such that
        A11: x2 = [a2,b2] by A9,A4,RELAT_1:def 1;
        A12: f.x1 = x1`2 by A9,A4
                .= b1 by A10, MCART_1:def 2;
        A13: f.x2 = x2`2 by A9,A4
                .= b2 by A11, MCART_1:def 2;
        A14: a1 in dom vs1 & b1 = vs1.a1 & a2 in dom vs1 & b2 = vs1.a2
              by A9,A4,A10,A11,FUNCT_1:8;
            reconsider a1,a2 as Element of NAT by A14;
        A15: now let n1,n2 be Element of NAT; assume
            A16: n1<n2 & n1 in dom vs1 & n2 in dom vs1 & vs1.n1 = vs1.n2; then
            A17: 2*n1-1 in dom W2 & 2*n2-1 in dom W2 by Th74; then
                reconsider a = 2*n1-1, b=2*n2-1 as odd Element of NAT;
                1 <= n1 & n1 <= len vs1 & 1 <= n2 & n2 <= len vs1
                  by A16, FINSEQ_3:27; then
            A18: vs1.n1 = W2.a & vs1.n2 = W2.b by Def14;
            A19: W2.a = W.a & W2.b = W.b by A2,A17,Lm27;
                2*n1 < 2*n2 by A16, XREAL_1:70; then
            A20: a < b by REAL_1:92;
                b <= lenW2 by A3, A17, FINSEQ_3:27; then
                b < len W by A2, XXREAL_0:2;
                hence contradiction by A16,A18,A19,A20,Def28;
            end;
            now assume
            A21: a1 <> a2;
                now per cases;
                suppose a1 <= a2; then
                    a1 < a2 by A21, REAL_1:def 5;
                    hence contradiction by A9,A12,A13,A14,A15; end;
                suppose a1 > a2;
                    hence contradiction by A9,A12,A13,A14,A15; end;
                end;
                hence contradiction;
            end;
            hence x1 = x2 by A9,A10,A11,A12,A13;
        end; then
        f is one-to-one by FUNCT_1:def 8; then
        Card vs1 <=` Card the_Vertices_of G by A4,A8,CARD_1:26; then
        card vs1 <= card the_Vertices_of G by CARD_2:57; then
        len vs1 <= G.order() by GLIB_000:def 26; then
    A22: len vs1 + 1 <= G.order() + 1 by XREAL_1:9;
    A23: lenW2 < len W - 0 by A1, REAL_1:92; then
    A24: W.(lenW2+1) Joins W.lenW2, W.(lenW2+2), G by Def3;
        1 is odd & 1 <= lenW2 by HEYTING3:1, JORDAN12:3; then
        W2.last() = W.lenW2 by A23, Lm20; then
        W.vertexSeq() = vs1 ^ <*W.(lenW2+2)*> by A1, A24, Th76; then
        len W.vertexSeq() = len vs1 + len <*W.(lenW2+2)*> by FINSEQ_1:35;
        hence thesis by A22,FINSEQ_1:56; end;
    end;
    hence thesis;
end;

theorem ::tWVDISTINCT01
  for G being _Graph, W being vertex-distinct Walk of G, e,v being set
   st e Joins W.last(),v,G & not v in W.vertices()
   holds W.addEdge(e) is vertex-distinct proof
    let G be _Graph, W be vertex-distinct Walk of G, e,v be set; assume
A1: e Joins W.last(),v,G & not v in W.vertices();
    set W2 = W.addEdge(e);
A2: len W2 = len W + 2 by A1,Lm41;
A3: now let n be odd Element of NAT; assume
    A4: n <= len W2 & n > len W; then
        len W + 1 <= n by NAT_1:13; then
        len W + 1 < n by REAL_1:def 5; then
        len W + 1 + 1 <= n by NAT_1:13;
        hence n = len W2 by A2,A4,XXREAL_0:1;
        hence W2.n = v by A1,A2,Lm42;
    end;
    now let m,n be odd Element of NAT; assume
    A5: m <= len W2 & n <= len W2 & W2.m = W2.n;
    A6: 1 <= m & 1 <= n by HEYTING3:1;
        now per cases;
          suppose
        A7: m <= len W; then
            m in dom W by A6,FINSEQ_3:27; then
        A8: W2.m = W.m by A1,Lm42;
            now per cases;
              suppose
            A9: n <= len W; then
                n in dom W by A6,FINSEQ_3:27; then
                W2.n = W.n by A1,Lm42;
                hence m = n by A5,A7,A9,A8,Def29;
              end;
              suppose n > len W; then
                n = len W2 & W.m = v by A3,A8,A5;
                hence m = n by A1,A7,Lm49;
              end;
            end;
            hence m = n;
          end;
          suppose m > len W; then
        A10: m = len W2 & W2.m = v by A3,A5;
            now per cases;
              suppose
            A11: n <= len W; then
                n in dom W by A6,FINSEQ_3:27; then
                v = W.n by A1,A5,A10,Lm42;
                hence m = n by A1,A11,Lm49;
              end;
              suppose n > len W;
                hence m = n by A3,A5,A10;
              end;
            end;
            hence m =n;
          end;
        end;
        hence m = n;
    end;
    hence thesis by Def29;
end;

theorem ::tCYWALK01
  e Joins x,x,G implies G.walkOf(x,e,x) is Cycle-like proof
    set W = G.walkOf(x,e,x); assume e Joins x,x,G; then
    len W = 3 by Th15; then
    W is non trivial by Lm59;
    hence thesis by Def31;
end;

theorem ::tCYWALK02
  e Joins x,y,G & e in W1.edges() & W1 is Cycle-like implies
    ex W2 being Walk of G st W2 is_Walk_from x,y & not e in W2.edges() proof
    assume
A1: e Joins x,y,G & e in W1.edges() & W1 is Cycle-like; then
    consider v1,v2 being Vertex of G, n being odd Element of NAT such that
A2: n+2 <= len W1 & v1 = W1.n & e = W1.(n+1) & v2 = W1.(n+2) &
      e Joins v1,v2,G by Lm51;
    set WA = W1.cut(n+2, len W1), WB = W1.cut(2*0+1,n);
    WA is_Walk_from v2, W1.(len W1) by A2, Lm20; then
A3: WA is_Walk_from v2, W1.last();
A4: 1 <= n by HEYTING3:1;
A5: n+2-2 < len W1-0 by A2, REAL_1:92; then
    WB is_Walk_from W1.(2*0+1), v1 by A2, A4, Lm20; then
A6: WB is_Walk_from W1.first(), v1;
    W1 is closed by A1, Def31; then
A7: WB is_Walk_from W1.last(), v1 by A6,Def24; then
A8: WA.append(WB) is_Walk_from v2,v1 by A3, Th32;
A9: WA.last() = W1.last() & WB.first() = W1.last() by A3,A7,Def23;
    W1 is Path-like by A1, Def31; then
A10: W1 is Trail-like by Def28;
A11: now assume e in WA.edges(); then
        consider m being even Element of NAT such that
    A12: 1 <= m & m <= len WA & WA.m = e by Lm50;
        reconsider maa1 = m-1 as odd Element of NAT by A12, INT_1:18;
    A13: maa1+1 = m;
        maa1 < len WA - 0 by A12, REAL_1:92; then
    A14: e = W1.(n+2+maa1) & n+2+maa1 in dom W1 by A2, A12, A13, Lm19; then
    A15: n+2+maa1 <= len W1 by FINSEQ_3:27;
    A16: n+1 < n+1+1 by NAT_1:13;
    A17: n+1+0 < n+2+maa1 by A16, XREAL_1:10;
        1 <= n+1 by NAT_1:12;
        hence contradiction by A2,A10,A14,A15,A17,Lm62;
    end;
A18: now assume e in WB.edges(); then
        consider m being even Element of NAT such that
    A19: 1 <= m & m <= len WB & WB.m = e by Lm50;
        m in dom WB by A19, FINSEQ_3:27; then
    A20: W1.m = W1.(n+1) by A2, A5, A19, Lm27;
        len WB = n by A5, Lm26; then
    A21: m+0 < n+1 by A19,XREAL_1:10;
        n+1 <= len W1 by A5, NAT_1:13;
        hence contradiction by A10, A19, A20, A21, Lm62;
    end;
    WA.append(WB).edges() = WA.edges() \/ WB.edges() by A9, Th103; then
A22: not e in WA.append(WB).edges() by A11,A18,XBOOLE_0:def 2; then
A23: not e in WA.append(WB).reverse().edges() by Th108;
A24: WA.append(WB).reverse() is_Walk_from v1,v2 by A8, Th24;
    now per cases by A1,A2,GLIB_000:18;
    suppose x = v1 & y = v2;
        hence thesis by A24,A23; end;
    suppose x = v2 & y = v1;
        hence thesis by A8,A22; end;
    end;
    hence thesis;
end;

theorem ::tSUBWALK01
  W is Subwalk of W by Lm75;

theorem ::tSUBWALK02
  for W1 being Walk of G, W2 being Subwalk of W1, W3 being Subwalk of W2
    holds W3 is Subwalk of W1 by Lm76;

theorem ::tSUBWALK03
    W1 is Subwalk of W2 implies
      (W1 is_Walk_from x,y iff W2 is_Walk_from x,y) proof
    assume
A1: W1 is Subwalk of W2;
    hereby assume W1 is_Walk_from x,y; then
    A2: W1.first() = x & W1.last() = y by Def23;
        W1 is_Walk_from W2.first(),W2.last() by A1, Def32; then
        x = W2.first() & y = W2.last() by A2, Def23;
        hence W2 is_Walk_from x,y by Def23;
    end;
    assume W2 is_Walk_from x,y; then
    W2.first() = x & W2.last() = y by Def23;
    hence W1 is_Walk_from x,y by A1, Def32;
end;

theorem Th162: ::tSUBWALK04
    W1 is Subwalk of W2 implies
       W1.first() = W2.first() & W1.last() = W2.last() proof
    assume W1 is Subwalk of W2; then
    W1 is_Walk_from W2.first(), W2.last() by Def32;
    hence thesis by Def23;
end;

theorem ::tSUBWALK05
    W1 is Subwalk of W2 implies
      len W1 <= len W2 by Lm77;

theorem Th164: ::tSUBWALK06
    W1 is Subwalk of W2 implies
      W1.edges() c= W2.edges() & W1.vertices() c= W2.vertices() proof
    assume
A1: W1 is Subwalk of W2; then
    consider es being FinSubsequence of W2.edgeSeq() such that
A2: W1.edgeSeq() = Seq es by Def32;
    now let e be set; assume e in W1.edges(); then
        consider n being even Element of NAT such that
    A3: 1 <= n & n <= len W1 & W1.n = e by Lm50;
        n div 2 in dom Seq es & W1.n = (Seq es).(n div 2)
          by Lm44, A2, A3; then
        consider m being Element of NAT such that
    A4: m in dom W2.edgeSeq() & n div 2 <= m & W1.n = W2.edgeSeq().m
          by Th4;
        thus e in W2.edges() by A3, A4, Th105;
    end;
    hence
A5: W1.edges() c= W2.edges() by TARSKI:def 3;
    now per cases;
    suppose
    A6: W1 is trivial;
        now let v be set; assume v in W1.vertices(); then
            consider n being odd Element of NAT such that
        A7: n <= len W1 & W1.n = v by Lm49;
            1 <= n & n <= 1 by A6,A7,Lm60,HEYTING3:1; then
            n = 1 by XXREAL_0:1; then
            v = W1.first() by A7; then
            v = W2.first() by A1, Th162;
            hence v in W2.vertices() by Th89;
        end;
        hence W1.vertices() c= W2.vertices() by TARSKI:def 3; end;
    suppose W1 is non trivial;
        hence W1.vertices() c= W2.vertices() by A5, Th135; end;
    end;
    hence thesis;
end;

theorem Th165: ::tSUBWALK07
    W1 is Subwalk of W2 implies
      for m being odd Element of NAT st m <= len W1 holds
       ex n being odd Element of NAT st m <= n & n <= len W2 & W1.m = W2.n
       proof
    assume
A1: W1 is Subwalk of W2; then
    consider es being FinSubsequence of W2.edgeSeq() such that
A2: W1.edgeSeq() = Seq es by Def32;
    let m be odd Element of NAT such that
A3: m <= len W1;
    now per cases by A3, REAL_1:def 5;
    suppose
    A4: m < len W1; then
    A5: W1.(m+1) Joins W1.m, W1.(m+2), G by Def3;
        reconsider m1= m+1 as even Element of NAT;
        1 <= m1 & m1 <= len W1 by A4,NAT_1:12, 13; then
        m1 div 2 in dom W1.edgeSeq() & W1.m1 = W1.edgeSeq().(m1 div 2)
          by Lm44; then
        consider x being Element of NAT such that
    A6: x in dom W2.edgeSeq() & m1 div 2 <= x & W1.m1 = W2.edgeSeq().x
          by A2, Th4; set n = 2*x;
    A7: 1 <= x & x <= len W2.edgeSeq() by A6, FINSEQ_3:27;
        2 divides m1 by PEPIN:22; then
    A8: 2 * (m1 div 2) = m1 by NAT_D:3;
        n in dom W2 by A6, Lm45; then
    A9: 1 <= n & n <= len W2 by FINSEQ_3:27; then
        reconsider naa1 = n - 1 as odd Element of NAT by INT_1:18;
    A10: naa1 < len W2 - 0 by A9, REAL_1:92; then
        W2.(naa1+1) Joins W2.naa1, W2.(naa1+2), G by Def3; then
    A11: W1.m1 Joins W2.naa1, W2.(naa1+2), G by A7,A6,Def15;
        m1 <= n by A8,A6,XREAL_1:66; then
    A12: m1-1 <= n-1 by REAL_1:92; then
    A13: m <= naa1+2 by NAT_1:12;
    A14: naa1 + 2 <= len W2 by A10, Th1;
        now per cases by A5, A11, GLIB_000:18;
        suppose W1.m = W2.naa1;
           hence thesis by A12, A10; end;
        suppose W1.m = W2.(naa1+2);
           hence thesis by A13, A14; end;
        end;
        hence thesis; end;
    suppose m = len W1; then
    A15: W1.m = W1.last()
            .= W2.last() by A1, Th162
            .= W2.(len W2);
        len W1 <= len W2 by A1, Lm77; then
        m <= len W2 by A3, XXREAL_0:2;
        hence thesis by A15; end;
    end;
    hence thesis;
end;

theorem ::tSUBWALK08
   W1 is Subwalk of W2 implies
      for m being even Element of NAT st 1 <= m & m <= len W1 holds
       ex n being even Element of NAT st m <= n & n <= len W2 & W1.m = W2.n
       proof
    assume W1 is Subwalk of W2; then
    consider es being FinSubsequence of W2.edgeSeq() such that
A1: W1.edgeSeq() = Seq es by Def32;
    let m be even Element of NAT such that
A2: 1 <= m & m <= len W1;
    m div 2 in dom W1.edgeSeq() & W1.m = W1.edgeSeq().(m div 2)
      by A2, Lm44; then
    consider ndiv2 being Element of NAT such that
A3: ndiv2 in dom W2.edgeSeq() & m div 2 <= ndiv2 & W1.m = W2.edgeSeq().ndiv2
      by A1, Th4;
    1 <= ndiv2 & ndiv2 <= len W2.edgeSeq() by A3, FINSEQ_3:27; then
A4: W1.m = W2.(2*ndiv2) by A3, Def15;
    2 divides m by PEPIN:22; then
    2 * (m div 2) = m by NAT_D:3; then
A5: m <= 2*ndiv2 by A3, XREAL_1:66;
    2*ndiv2 in dom W2 by A3, Lm45; then
    2*ndiv2 <= len W2 by FINSEQ_3:27;
    hence thesis by A4, A5;
end;

theorem ::tSUBPATH01
  for W1 being Trail of G st W1 is non trivial holds
    ex W2 being Path of W1 st W2 is non trivial proof
    let W1 be Trail of G; assume
    W1 is non trivial; then
A1: 1 <> len W1 by Lm60;
    1 <= len W1 by HEYTING3:1; then
A2: 1 < len W1 by A1, REAL_1:def 5;
    now per cases;
    suppose W1 is open; then
    A3: W1.first() <> W1.last() by Def24;
        consider P being Path of W1;
        take P;
        P.first() = W1.first() & P.last() = W1.last() by Th162;
        hence P is non trivial by A3,Th128; end;
    suppose W1 is closed; then
    A4: W1.1 = W1.(len W1) by Th119;
        defpred P[Element of NAT] means $1 is odd & 1 < $1 & $1 <= len W1 &
          W1.($1) = W1.(len W1);
    A5: ex k being Element of NAT st P[k] by A2;
        consider k being Element of NAT such that
    A6: P[k] & for m being Element of NAT st P[m] holds k <= m
    from NAT_1:sch 5(A5);
        reconsider k as odd Element of NAT by A6;
        set W3 = W1.remove(k,len W1);
        1+1 < k+1 by A6, XREAL_1:10; then
        2 <= k by NAT_1:13; then
        reconsider k2 = k - 2*1 as odd Element of NAT by INT_1:18;
        set W4 = W3.cut(2*0+1,k2);
        consider W5 being Path of W4;
        set e = W1.(k2+1), W2 = W5.addEdge(e);
        k2 < len W1 - 0 by A6, REAL_1:92; then
    A7: e Joins W1.k2, W1.(k2+2), G by Def3;
        len W3 + len W1 = len W1 + k by A6, Lm28; then
    A8: len W3 = k; then
    A9: k2 <= len W3 - 0 by REAL_1:92;
    A10: 1 <= k2 by HEYTING3:1; then
    A11: W4.first() =  W3.1 & W4.last() = W3.k2 by A9, Lm20;
        W5 is_Walk_from W4.first(), W4.last() by Def32; then
    A12: W5.first() = W3.1 & W5.last() = W3.k2 by A11, Def23;
        W1.k = W1.last() by A6; then
    A13: W3 = W1.cut(1,k) by Th58;
        k2 in dom W3 by A10, A9, FINSEQ_3:27; then
    A14: W5.last() = W1.k2 by A6, A12, A13, Lm27;
    A15: k2 < len W3 - 0 by A8, REAL_1:92; then
        k2+1 <= k by A8, NAT_1:13; then
    A16: k2+1 <= len W1 by A6, XXREAL_0:2;
    A17: len W4 = k2 by A15, Lm26;
    A18: now assume
        A19: e in W5.edges();
            W5.edges() c= W4.edges() by Th164; then
            consider n being even Element of NAT such that
        A20: 1 <= n & n <= len W4 & W4.n = e by A19,Lm50;
            n in dom W4 by A20, FINSEQ_3:27; then
        A21: e = W3.n by A9, A20, Lm27;
            n <= k2+2 by A17,A20,NAT_1:12; then
            n in dom W3 by A20, A8, FINSEQ_3:27; then
        A22: W1.(k2+1) = W1.n by A6, A13, A21, Lm27;
            n < k2+1 by A17,A20,NAT_1:13;
            hence contradiction by A16, A20, A22, Lm62;
        end;
    A23: now assume
        A24: W5 is non trivial & W5 is closed; then
        A25: W5.first() = W1.k2 by A14, Def24;
            1 <= len W3 by HEYTING3:1; then
            2*0+1 in dom W3 by FINSEQ_3:27; then
        A26: W1.k2 = W1.(len W1) by A4, A6, A12, A13, A25, Lm27;
            now assume k2 = 1; then
                len W4 = 1 by A9, Lm26; then
                1 <= len W5 & len W5 <= 1 by HEYTING3:1, Lm77; then
                len W5 = 1 by XXREAL_0:1;
                hence contradiction by A24, Lm60;
            end; then
        A27: 1 < k2 by A10, REAL_1:def 5;
        A28: k2 < k - 0 by REAL_1:92; then
            k2 <= len W1 by A6, XXREAL_0:2;
            hence contradiction by A6,A26,A27,A28;
        end;
        now let m be odd Element of NAT; assume
        A29: 1 < m & m <= len W5;
        then consider n being odd Element of NAT such that
        A30: m <= n & n <= len W4 & W5.m = W4.n by Th165;
        A31: 1 < n by A29, A30, XXREAL_0:2; then
            n in dom W4 by A30, FINSEQ_3:27; then
        A32: W5.m = W3.n by A9, A30, Lm27;
        A33: n+0 < k2+2 by A30, A17, XREAL_1:10; then
            n in dom W3 by  A8, A31, FINSEQ_3:27; then
        A34: W5.m = W1.n by A6, A13, A32, Lm27;
            n <= len W1 by A6, A33, XXREAL_0:2;
            hence W5.m <> W1.k by A31, A6, A33, A34;
        end; then
        reconsider W2 as Path of G by A14,A7,A18,A23,Th151;
        1 <= len W3 by HEYTING3:1; then
        2*0+1 in dom W3 by FINSEQ_3:27; then
    A35: W5.first() = W1.first() by A6,A12,A13,Lm27;
    A36: k2 in dom W3 by A10, A15, FINSEQ_3:27; then
    A37: W5.last() = W1.k2 by A6, A12, A13, Lm27; then
        W5 is_Walk_from W1.first(), W1.k2 by A35, Def23; then
        W2 is_Walk_from W1.first(), W1.k by A7, Lm43; then
    A38: W2 is_Walk_from W1.first(), W1.last() by A6;
        consider es5 being FinSubsequence of W4.edgeSeq() such that
    A39: W5.edgeSeq() = Seq es5 by Def32;
    A40: W4.edgeSeq() c= W3.edgeSeq() by Lm47;
        W3.edgeSeq() c= W1.edgeSeq() by A13, Lm47; then
    A41: W4.edgeSeq() c= W1.edgeSeq() by A40, XBOOLE_1:1;
        es5 c= W4.edgeSeq() by GRAPH_2:def 5; then
    A42: es5 c= W1.edgeSeq() by A41, XBOOLE_1:1; then
        reconsider es5 as FinSubsequence of W1.edgeSeq() by GRAPH_2:def 5;
        set g = ((k2+1) div 2) .--> e, es = es5 +* g;
    A43: dom es = dom es5 \/ dom g & for x st x in dom es5 \/ dom g
          holds (x in dom g implies es.x = g.x) &
          (not x in dom g implies es.x = es5.x) by FUNCT_4:def 1;
    A44: dom g = {(k2+1) div 2} & rng g = {e} by FUNCOP_1:14,19;
    A45: g.((k2+1) div 2) = e by FUNCOP_1:87;
        now let z be set; assume
        A46: z in es; then consider x,y being set such that
        A47: z = [x,y] by RELAT_1:def 1;
        A48: x in dom es & y = es.x by A46,A47, FUNCT_1:8;
            now per cases;
            suppose
            A49: x in dom g; then
            A50: x = (k2+1) div 2 by A44, TARSKI:def 1;
                1 <= k2+1 by NAT_1:12; then
            A51: x in dom W1.edgeSeq() & W1.(k2+1) = W1.edgeSeq().x
                  by A16,A50,Lm44;
                W1.edgeSeq().x = y by A43,A45,A48,A49,A50,A51;
                hence z in W1.edgeSeq() by A47, A51, FUNCT_1:8; end;
            suppose
            A52: not x in dom g; then
            A53: x in dom es5 by A43, A48, XBOOLE_0:def 2;
                y = es5.x by A43, A48, A52; then
                z in es5 by A47,A53,FUNCT_1:8;
                hence z in W1.edgeSeq() by A42; end;
            end;
            hence z in W1.edgeSeq();
        end; then
    A54: es c= W1.edgeSeq() by TARSKI:def 3; then
        dom es c= dom W1.edgeSeq() by RELAT_1:25; then
    A55: dom es c= Seg len W1.edgeSeq() by FINSEQ_1:def 3; then
        reconsider es as FinSubsequence by FINSEQ_1:def 12;
        reconsider es as FinSubsequence of W1.edgeSeq() by A54, GRAPH_2:def 5;
    A56: dom es5 c= dom W4.edgeSeq() by GRAPH_2:27;
        now thus dom es5 c= Seg len W1.edgeSeq() &
              dom g c= Seg len W1.edgeSeq() by A43,XBOOLE_1:11,A55;
            let x,y be Element of NAT such that
        A57: x in dom es5 & y in dom g;
        A58: y = (k2+1) div 2 by A44, A57, TARSKI:def 1;
            2 divides k2+1 by PEPIN:22; then
        A59: 2*y = k2+1 by A58, NAT_D:3;
            x <= len W4.edgeSeq() by A56,A57,FINSEQ_3:27; then
            2*x <= 2*len W4.edgeSeq() by XREAL_1:66; then
            2*x+1 <= 2*len W4.edgeSeq()+1 by XREAL_1:9; then
            2*x+1 <= k2 by A17, Def15; then
            2*x+1 < 2*y by A59, NAT_1:13; then
        A60: 2*x+1-1 < 2*y - 0 by REAL_1:92; then
            x <= y by Lm1;
            hence x < y by A60, REAL_1:def 5;
        end; then
    A61: Sgm(dom es) = Sgm(dom es5) ^ Sgm(dom g) by A43, FINSEQ_3:48;
        now
        A62: e Joins W5.last(), W1.k, G by A7,A36,A6,A12,A13,Lm27;
            len W2 = len W5 + 2 by A7,A37,Lm41; then
        A63: len W5 + 2 = 2 * len W2.edgeSeq() + 1 by Def15;
        A64: len Seq es = card es by Th5
                      .= card dom es by Lm2;
            now assume dom es5 /\ dom g <> {}; then
                consider x being set such that
            A65: x in dom es5 /\ dom g by XBOOLE_0:def 1;
            A66: x in dom es5 & x in dom g by A65, XBOOLE_0:def 3; then
            A67: x = (k2+1) div 2 by A44, TARSKI:def 1;
                (k2+1) div 2 <= len W4.edgeSeq() by A56,A66,A67,FINSEQ_3:27;
then
            A68: 2 * ((k2+1) div 2) <= 2*len W4.edgeSeq() by XREAL_1:66;
                2 divides (k2+1) by PEPIN:22; then
                k2+1 <= 2*len W4.edgeSeq() by A68, NAT_D:3; then
                k2+1+1 <= 2*len W4.edgeSeq()+1 by XREAL_1:9; then
                (1+1)+k2 <= 0 + k2 by A17,Def15;
                hence contradiction by XREAL_1:8;
            end; then
        A69: dom es5 misses dom g by XBOOLE_0:def 7; then
            len Seq es = card dom es5 + card dom g by A43,A64,CARD_2:53
                      .= card dom es5 + 1 by A44, CARD_1:79
                      .= card es5 + 1 by Lm2
                      .= len W5.edgeSeq() + 1 by A39, Th5; then
            2 * len Seq es + 1 = 2*len W5.edgeSeq() + 1 + 2
                              .= 2 * len W2.edgeSeq() + 1 by A63, Def15; then
            2 * len Seq es = 2 * len W2.edgeSeq();
            hence
        A70: len W2.edgeSeq() = len Seq es;
            let x be Element of NAT; assume
        A71: 1 <= x & x <= len W2.edgeSeq();
            set h = Sgm dom es;
        A72: Seq es = es * h by FINSEQ_1:def 14;
        A73: x in dom (Seq es) by A70, A71, FINSEQ_3:27; then
        A74: x in dom h & h.x in dom es by A72,FUNCT_1:21;
        A75: (Seq es).x = es.(h.x) by A72, A73, FUNCT_1:22;
        A76: dom h = Seg (len Sgm(dom es5) + len (Sgm dom g)) &
              (for x being Element of NAT st x in dom Sgm dom es5 holds
               h.x = Sgm(dom es5).x) &
              (for x being Element of NAT st x in dom Sgm dom g holds
                h.(len Sgm(dom es5) + x) = (Sgm dom g).x)
                by A61, FINSEQ_1:def 7;
        A77: Sgm dom g = Sgm {(k2+1) div 2} by FUNCOP_1:19;
            now assume k2+1 div 2 = 0; then
            A78: 2 * ((k2+1) div 2) = 2*0;
                2 divides k2+1 by PEPIN:22;
                hence contradiction by A78,NAT_D:3;
            end; then
            Sgm dom g = <* (k2+1) div 2 *> by A77, FINSEQ_3:50; then
        A79: len Sgm dom g = 1 & (Sgm dom g).1 = (k2+1) div 2 by FINSEQ_1:57;
        A80: dom es5 c=Seg len W1.edgeSeq() by A43,A55,XBOOLE_1:11;then
        A81: len Sgm(dom es5) = card dom es5 by FINSEQ_3:44
                            .= card es5 by Lm2
                            .= len W5.edgeSeq() by A39, Th5;
            now per cases;
            suppose
            A82: x <= len Sgm (dom es5); then
            A83: x in dom Sgm dom es5 by A71, FINSEQ_3:27; then
            A84: h.x = Sgm(dom es5).x by A61, FINSEQ_1:def 7;
                rng Sgm(dom es5) = dom es5 by A80, FINSEQ_1:def 13; then
                h.x in dom es5 by A83, A84, FUNCT_1:def 5; then
                not h.x in dom g by A69, XBOOLE_0:3; then
            A85: (Seq es).x = es5.(Sgm(dom es5).x) by A74,A75,A43,A84;
            A86: W5.edgeSeq().x = W5.(2*x) by A81,A82,A71, Def15;
            A87: x in dom W5.edgeSeq() by A71,A81,A82,FINSEQ_3:27; then
                2*x in dom W5 by Lm45; then
            A88: W2.(2*x) = W5.edgeSeq().x by A62, A86, Lm42
                        .= (es5 * Sgm(dom es5)).x by A39, FINSEQ_1:def 14;
                x in dom (es5 * Sgm(dom es5)) by A39,A87,FINSEQ_1:def 14;
                hence (Seq es).x = W2.(2*x) by A85,A88,FUNCT_1:22; end;
            suppose len Sgm (dom es5) < x; then
            A89: len Sgm(dom es5) + 1 <= x by NAT_1:13;
                x <= len Sgm(dom es5) + 1 by A74,A76,A79,FINSEQ_1:3; then
            A90: x = len Sgm(dom es5) + 1 by A89, XXREAL_0:1;
                1 in dom Sgm(dom g) by A79, FINSEQ_3:27; then
            A91: h.x = (k2+1) div 2 by A61,FINSEQ_1:def 7,A79,A90;
                 h.x in dom g by A91, A44, TARSKI:def 1; then
                 A92: (Seq es).x = g.((k2+1) div 2) by A43,A74,A91,A75
                          .= e by FUNCOP_1:87
                          .= W2.(len W5 + 1) by A62, Lm42;
                2*x = 2*len W5.edgeSeq()+1+1 by A81,A90
                   .= len W5 + 1 by Def15;
                hence (Seq es).x = W2.(2*x) by A92; end;
            end;
            hence W2.edgeSeq().x = (Seq es).x by A71,Def15;
        end; then
        W2.edgeSeq() = Seq es by FINSEQ_1:18; then
        reconsider W2 as Path of W1 by A38, Def32;
        take W2;
        thus W2 is non trivial by A7,A14, Th133; end;
    end;
    hence thesis;
end;

theorem Th168: ::tSUBGRAPH_W01
  for G1 being _Graph, G2 being Subgraph of G1, W being Walk of G2 holds
    W is Walk of G1 proof
    let G1 be _Graph, G2 be Subgraph of G1, W be Walk of G2;
    set VG1 = the_Vertices_of G1, VG2 = the_Vertices_of G2;
    set EG1 = the_Edges_of G1, EG2 = the_Edges_of G2;
    VG2 c= VG1 \/ EG1 & EG2 c= VG1 \/ EG1 by XBOOLE_1:10; then
A1: VG2 \/ EG2 c= VG1 \/ EG1 by XBOOLE_1:8;
    for y being set st y in rng W holds y in VG1 \/ EG1
      by A1, TARSKI:def 3; then
    rng W c= VG1 \/ EG1 by TARSKI:def 3; then
A2: W is FinSequence of VG1 \/ EG1 by FINSEQ_1:def 4;
    now thus len W is odd;
        W.1 in VG2 by Def3;
        hence W.1 in VG1;
        let n be odd Element of NAT; assume n < len W; then
        W.(n+1) Joins W.n, W.(n+2), G2 by Def3;
        hence W.(n+1) Joins W.n, W.(n+2), G1 by GLIB_000:75;
    end;
    hence W is Walk of G1 by A2, Def3;
end;

theorem Th169: ::tSUBGRAPH_W02
  for G1 being _Graph, G2 being Subgraph of G1, W being Walk of G1
   st W is trivial & W.first() in the_Vertices_of G2
   holds W is Walk of G2 proof
    let G1 be _Graph, G2 be Subgraph of G1, W be Walk of G1; assume
A1: W is trivial & W.first() in the_Vertices_of G2; then
    consider v being Vertex of G1 such that
A2: W = G1.walkOf(v) by Lm61;
A3: W = <*v*> by A2;
    reconsider v'= v as Vertex of G2 by A1,A2,Th14;
    W = G2.walkOf(v') by A3;
    hence W is Walk of G2;
end;

theorem Th170: ::tSUBGRAPH_W03
  for G1 being _Graph, G2 being Subgraph of G1, W being Walk of G1
   st W is non trivial & W.edges() c= the_Edges_of G2
   holds W is Walk of G2 proof
    let G1 be _Graph, G2 be Subgraph of G1, W be Walk of G1; assume
A1: W is non trivial & W.edges() c= the_Edges_of G2;
    set WV = W.vertices(), WE = W.edges();
    set VG2 = the_Vertices_of G2, EG2 = the_Edges_of G2;
A2: now let n be odd Element of NAT such that
    A3: n <= len W;
        now per cases;
        suppose
        A4: n = len W; then
        A5: n <> 1 by A1, Lm59;
            1 <= n by HEYTING3:1; then
            1 < n by A5, REAL_1:def 5; then
            1+1 <= n by NAT_1:13; then
            reconsider n5 = n-2*1 as odd Element of NAT by INT_1:18;
            n5 < len W - 0 by A4, REAL_1:92; then
        A6: W.(n5+1) Joins W.n5, W.(n5+2), G1 by Def3;
        A7: 1 <= n5+1 by NAT_1:12;
            n5+1 = n-(2-1); then
            n5+1 <= len W-0 by A4, REAL_1:92; then
            W.(n5+1) in W.edges() by A7, Lm50; then
            W.(n5+1) Joins W.n5, W.(n5+2), G2 by A1,GLIB_000:76, A6;
            hence W.n in the_Vertices_of G2 by GLIB_000:16; end;
        suppose n <> len W; then
        A8: n < len W by A3, REAL_1:def 5; then
        A9: W.(n+1) Joins W.n, W.(n+2), G1 by Def3;
        A10: 1 <= n+1 by NAT_1:12;
            n+1 <= len W by A8, NAT_1:13; then
            W.(n+1) in W.edges() by A10, Lm50; then
            W.(n+1) Joins W.n, W.(n+2), G2 by A1,A9, GLIB_000:76;
            hence W.n in the_Vertices_of G2 by GLIB_000:16; end;
        end;
        hence W.n in VG2;
    end;
    now let y be set; assume y in rng W; then
    A11: y in WV \/ WE by Th102;
        now per cases by A11, XBOOLE_0:def 2;
        suppose y in WV; then consider n being odd Element of NAT such that
        A12: n <= len W & W.n = y by Lm49;
            y in VG2 by A2, A12;
            hence y in VG2 \/ EG2 by XBOOLE_0:def 2; end;
        suppose y in WE;
            hence y in VG2 \/ EG2 by A1,XBOOLE_0:def 2; end;
        end;
        hence y in VG2 \/ EG2;
    end; then
    rng W c= VG2 \/ EG2 by TARSKI:def 3; then
A13: W is FinSequence of VG2 \/ EG2 by FINSEQ_1:def 4;
    now thus len W is odd;
        reconsider aa1 = 1 as odd Element of NAT by JORDAN12:3;
        aa1 <= len W by HEYTING3:1;
        hence W.1 in VG2 by A2;
        let n be odd Element of NAT; set e = W.(n+1); assume
    A14: n < len W; then
    A15: W.(n+1) Joins W.n, W.(n+2), G1 by Def3;
        1 <= n+1 & n+1 <= len W by A14,NAT_1:12,13; then
        W.(n+1) in W.edges() by Lm50;
        hence W.(n+1) Joins W.n, W.(n+2), G2 by A1,A15, GLIB_000:76;
    end;
    hence W is Walk of G2 by A13, Def3;
end;

theorem Th171: ::tSUBGRAPH_W04
  for G1 being _Graph, G2 being Subgraph of G1, W being Walk of G1
   st W.vertices() c= the_Vertices_of G2 & W.edges() c= the_Edges_of G2
   holds W is Walk of G2 proof
    let G1 be _Graph, G2 be Subgraph of G1, W be Walk of G1; assume
A1: W.vertices() c= the_Vertices_of G2 & W.edges() c= the_Edges_of G2;
    now per cases;
    suppose W is non trivial;
         hence thesis by A1, Th170; end;
    suppose
    A2: W is trivial;
        W.first() in W.vertices() by Th89;
        hence thesis by A1,A2,Th169; end;
    end;
    hence thesis;
end;

theorem ::tSUBGRAPH_W05
  for G1 being non trivial _Graph, W being Walk of G1, v being Vertex of G1,
      G2 being removeVertex of G1,v st not v in W.vertices()
    holds W is Walk of G2 proof
    let G1 be non trivial _Graph, W be Walk of G1, v be Vertex of G1,
        G2 be removeVertex of G1,v; assume
A1: not v in W.vertices();
    set W2 = W, VG2 = (the_Vertices_of G1) \ {v};
    set EG2 = (the_Edges_of G1) \ v.edgesInOut();
    v.edgesInOut() = G1.edgesInOut({v}) by GLIB_000:def 42; then
A2: EG2 = G1.edgesBetween( the_Vertices_of G1 \ {v}) by GLIB_000:38;
    now let y be set; assume y in rng W2; then consider x being set such that
    A3: x in dom W2 & y = W2.x by FUNCT_1:def 5;
        reconsider x as Element of NAT by A3;
    A4: 1 <= x & x <= len W2 by A3, FINSEQ_3:27;
        now per cases;
        suppose
        A5: x is odd; then
        A6: y in the_Vertices_of G1 by A3, A4, Lm3;
            now assume y in {v}; then
                not y in W.vertices() by A1,TARSKI:def 1;
                hence contradiction by A3, A4, A5,Lm49;
            end; then
            y in VG2 by A6, XBOOLE_0:def 4;
            hence y in VG2 \/ EG2 by XBOOLE_0:def 2; end;
        suppose x is even; then reconsider x as even Element of NAT;
            consider xaa1 being odd Element of NAT such that
        A7: xaa1 = x-1 & x-1 in dom W2 & x+1 in dom W2 &
              W2.x Joins W2.(xaa1), W2.(x+1),G1 by A3, Lm4;
        A8: y in the_Edges_of G1 by A3, A7, GLIB_000:def 15;
        A9: xaa1 <= len W2 & x+1 <= len W2 by A7, FINSEQ_3:27;
            now assume y in v.edgesInOut(); then
            A10: y in v.edgesIn() \/ v.edgesOut() by GLIB_000:63;
                now per cases by A10, XBOOLE_0:def 2;
                  suppose y in v.edgesIn(); then
                    (the_Target_of G1).y = v by GLIB_000:59;
                    hence v=W2.(xaa1) or v = W2.(x+1) by A3,A7,GLIB_000:def 15;
                  end;
                  suppose y in v.edgesOut(); then
                    (the_Source_of G1).y = v by GLIB_000:61;
                    hence v=W2.(xaa1) or v = W2.(x+1) by A3,A7,GLIB_000:def 15;
                  end;
                end; then
                v = W2.vertexAt(xaa1) or v = W2.vertexAt(x+1)
                  by A9, Def8;
                hence contradiction by A1,A9,Th90;
            end; then
            y in EG2 by A8, XBOOLE_0:def 4;
            hence y in VG2 \/ EG2 by XBOOLE_0:def 2; end;
        end; then
        y in (the_Vertices_of G2) \/ EG2 by GLIB_000:50;
        hence y in (the_Vertices_of G2) \/ (the_Edges_of G2) by A2,GLIB_000:50;
    end; then
    rng W2 c= (the_Vertices_of G2) \/ (the_Edges_of G2) by TARSKI:def 3; then
    reconsider W2 as FinSequence of (the_Vertices_of G2)\/(the_Edges_of G2)
      by FINSEQ_1:def 4;
    now thus len W2 is odd by Def3;
        W.first() in the_Vertices_of G1; then
    A11: W.1 in the_Vertices_of G1;
        W.first() in W.vertices() by Th89; then
        W.1 <> v by A1; then
        not W2.1 in {v} by TARSKI:def 1; then
        W2.1 in VG2 by A11, XBOOLE_0:def 4;
        hence W2.1 in the_Vertices_of G2 by GLIB_000:50;
        let n be odd Element of NAT; assume
    A12: n < len W2; then
    A13: W.(n+1) Joins W.n, W.(n+2), G1 by Def3;
    A14: W.n <> v by A1,A12,Lm49;
        reconsider lenW2 = len W2 as odd Element of NAT by Def3;
        set e = W.(n+1);
        n+1 <= len W2 by A12, NAT_1:13; then
        n+1 < lenW2 by REAL_1:def 5; then
        n+1+1 <= len W2 by NAT_1:13; then
    A15: W.(n+2) <> v by Lm49,A1;
    A16: W.(n+1) in the_Edges_of G1 by A13, GLIB_000:def 15;
        not W.(n+1) in v.edgesInOut() by A14, A15, A13, GLIB_000:68; then
        W.(n+1) in EG2 by A16, XBOOLE_0:def 4; then
        W.(n+1) in the_Edges_of G2 by A2,GLIB_000:50;
        hence W.(n+1) Joins W.n, W.(n+2), G2 by A13, GLIB_000:76;
    end;
    hence W is Walk of G2 by Def3;
end;

theorem ::tSUBGRAPH_W06
  for G1 being _Graph, W being Walk of G1, e being set,
      G2 being removeEdge of G1,e st not e in W.edges()
    holds W is Walk of G2 proof
    let G1 be _Graph, W be Walk of G1, e be set, G2 be removeEdge of G1,e;
    assume
A1: not e in W.edges();
A2: the_Vertices_of G2 = the_Vertices_of G1 &
      the_Edges_of G2 = (the_Edges_of G1) \ {e} by GLIB_000:56; then
A3: W.vertices() c= the_Vertices_of G2;
    now let x be set; assume
    A4: x in W.edges(); then
        not x in {e} by A1, TARSKI:def 1;
        hence x in the_Edges_of G2 by A2, A4, XBOOLE_0:def 4;
    end; then
    W.edges() c= the_Edges_of G2 by TARSKI:def 3;
    hence thesis by Th171, A3;
end;

theorem Th174: ::tSUBGRAPH_WF01
  for G1 being _Graph, G2 being Subgraph of G1, x,y,e being set
   st e Joins x,y,G2 holds
   G1.walkOf(x, e, y) = G2.walkOf(x, e, y) proof
    let G1 be _Graph, G2 be Subgraph of G1, x, y, e be set;
    assume
A1: e Joins x,y,G2; then
A2: G2.walkOf(x,e,y) = <*x,e,y*> by Def5;
    e Joins x,y,G1 by A1, GLIB_000:75;
    hence G1.walkOf(x,e,y) = G2.walkOf(x,e,y) by A2, Def5;
end;

theorem ::tSUBGRAPH_WF02
  for G1 being _Graph, G2 being Subgraph of G1, W1 being Walk of G1,
    W2 being Walk of G2, e being set st W1 = W2 & e in W2.last().edgesInOut()
    holds W1.addEdge(e) = W2.addEdge(e) proof
    let G1 be _Graph, G2 be Subgraph of G1, W1 be Walk of G1,
        W2 be Walk of G2, e be set; assume
A1: W1 = W2 & e in W2.last().edgesInOut(); then
A2: e Joins W2.last(),W2.last().adj(e),G2 by GLIB_000:70;
    set W1B = G1.walkOf(W1.last(), e, W1.last().adj(e));
    set W2B = G2.walkOf(W2.last(), e, W2.last().adj(e));
A3: W1.last() = W2.last() by A1;
    W1.last().adj(e) = W2.last().adj(e) by A1, GLIB_000:83; then
A4: W1B = W2B by A2, A3, Th174;
    thus W1.addEdge(e) = W2.addEdge(e) by A1,A4,Th36;
end;

theorem Th176: ::tSUBGRAPH_WA01
  for G1 being _Graph, G2 being Subgraph of G1, W being Walk of G2 holds
    (W is closed          implies W is closed          Walk of G1) &
    (W is directed        implies W is directed        Walk of G1) &
    (W is trivial         implies W is trivial         Walk of G1) &
    (W is Trail-like      implies W is Trail-like      Walk of G1) &
    (W is Path-like       implies W is Path-like       Walk of G1) &
    (W is vertex-distinct implies W is vertex-distinct Walk of G1) proof
    let G1 be _Graph, G2 be Subgraph of G1, W be Walk of G2;
    reconsider W'=W as Walk of G1 by Th168;
    hereby assume W is closed; then
        W.first() = W.last() by Def24; then
        W.1 = W.(len W); then
        W'.first() = W'.(len W'); then
        W'.first() = W'.last();
        hence W is closed Walk of G1 by Def24;
    end;
    hereby assume
    A1: W is directed;
        now let n be odd Element of NAT; assume
        A2: n < len W'; then
        A3: (the_Source_of G2).(W'.(n+1)) = W'.n by A1, Def25;
        A4: 1 <= n+1 by NAT_1:12;
            n+1 <= len W' by A2,NAT_1:13; then
            n+1 in dom W' by A4, FINSEQ_3:27; then
            W'.(n+1) in the_Edges_of G2 by Th9;
            hence (the_Source_of G1).(W'.(n+1)) = W'.n by GLIB_000:def 34, A3;
        end;
        hence W is directed Walk of G1 by Def25;
    end;
    hereby assume W is trivial; then
        len W' = 1 by Lm60;
        hence W is trivial Walk of G1 by Lm59;
    end;
A5: now assume W is Trail-like; then
        for m,n being even Element of NAT st 1 <= m & m < n & n <= len W
          holds W'.m <> W'.n by Lm62;
        hence W is Trail-like Walk of G1 by Lm62;
    end;
    hence W is Trail-like implies W is Trail-like Walk of G1;
    now assume W is Path-like; then
        W' is Trail-like &
         for m,n being odd Element of NAT st m < n & n <= len W'
          holds W'.m = W'.n implies (m=1 & n = len W') by A5,Def28;
        hence W is Path-like Walk of G1 by Def28;
    end;
    hence W is Path-like implies W is Path-like Walk of G1;
    hereby assume W is vertex-distinct; then
        for m,n being odd Element of NAT
        st m <= len W' & n <= len W' & W'.m = W'.n
          holds m = n by Def29;
        hence W is vertex-distinct Walk of G1 by Def29;
    end;
    thus thesis;
end;

theorem Th177: ::tSUBGRAPH_WA02
  for G1 being _Graph, G2 being Subgraph of G1, W1 being Walk of G1,
    W2 being Walk of G2 st W1 = W2 holds
    (W1 is closed          iff W2 is closed) &
    (W1 is directed        iff W2 is directed) &
    (W1 is trivial         iff W2 is trivial) &
    (W1 is Trail-like      iff W2 is Trail-like) &
    (W1 is Path-like       iff W2 is Path-like) &
    (W1 is vertex-distinct iff W2 is vertex-distinct) proof
    let G1 be _Graph, G2 be Subgraph of G1, W1 be Walk of G1, W2 be Walk of G2;
    assume
A1: W1 = W2;
A2: W1 is closed iff W1.first() = W1.last() by Def24;
    W1.first() = W2.first() & W1.last() = W2.last() by A1;
    hence W1 is closed iff W2 is closed by A2,Def24;
    now
        hereby assume
        A3: W1 is directed;
            now let n be odd Element of NAT; assume
            A4: n < len W2; then
                1 <= n+1 & n+1 <= len W2 by NAT_1:13, 12; then
                n+1 in dom W2 by FINSEQ_3:27; then
                W2.(n+1) in the_Edges_of G2 by Th9; then
                (the_Source_of G2).(W2.(n+1)) = (the_Source_of G1).(W2.(n+1))
                  by GLIB_000:def 34;
                hence (the_Source_of G2).(W2.(n+1)) = W2.n by A1,A3,A4,Def25;
            end;
            hence W2 is directed by Def25;
        end;
        assume W2 is directed;
        hence W1 is directed Walk of G1 by A1, Th176;
    end;
    hence W1 is directed iff W2 is directed;
    W1 is trivial iff len W2 = 1 by A1, Lm60;
    hence W1 is trivial iff W2 is trivial by Lm60;
    W1 is Trail-like iff for m,n being even Element of NAT
    st 1 <= m & m < n & n <= len W2
      holds W2.m <> W2.n by A1, Lm62;
    hence
A5: W1 is Trail-like iff W2 is Trail-like by Lm62;
    W1 is Path-like iff (W1 is Trail-like & for m,n being odd Element of NAT
      st m < n & n <= len W2 holds W2.m = W2.n implies (m = 1 & n = len W2))
      by A1, Def28;
    hence W1 is Path-like iff W2 is Path-like by A5, Def28;
    W1 is vertex-distinct iff
      (for m,n being odd Element of NAT
      st m <= len W2 & n <= len W2 & W2.m = W2.n
        holds m = n) by A1,Def29;
    hence W1 is vertex-distinct iff W2 is vertex-distinct by Def29;
end;

theorem ::tGPEQ_VSEQ01
  G1 == G2 & x is VertexSeq of G1 implies x is VertexSeq of G2 proof
  assume
A1: G1 == G2 & x is VertexSeq of G1; then
    reconsider x2 = x as FinSequence of the_Vertices_of G2
      by GLIB_000:def 36;
    now let n be Element of NAT; assume
        1 <= n & n < len x2; then
        consider e being set such that
    A2: e Joins x2.n, x2.(n+1), G1 by A1,Def1;
        e Joins x2.n, x2.(n+1), G2 by A1,A2,GLIB_000:91;
        hence ex e being set st e Joins x2.n, x2.(n+1), G2;
    end;
    hence thesis by Def1;
end;

theorem ::tGPEQ_ESEQ01
  G1 == G2 & x is EdgeSeq of G1 implies x is EdgeSeq of G2 proof assume
A1: G1 == G2 & x is EdgeSeq of G1; then
    reconsider es = x as EdgeSeq of G1;
    consider vs being FinSequence of the_Vertices_of G1 such that
A2: len vs = len es + 1 & for n being Element of NAT st 1 <= n & n <= len es
holds
      es.n Joins vs.n,vs.(n+1),G1 by Def2;
    reconsider es2 = es as FinSequence of the_Edges_of G2
      by A1,GLIB_000:def 36;
    now reconsider vs as FinSequence of the_Vertices_of G2
          by A1,GLIB_000:def 36;
        take vs;
        thus len vs = len es + 1 by A2;
        let n be Element of NAT; assume 1 <= n & n <= len es2; then
        es2.n Joins vs.n,vs.(n+1),G1 by A2;
        hence es2.n Joins vs.n,vs.(n+1),G2 by A1,GLIB_000:91;
    end;
    hence thesis by Def2;
end;

theorem ::tGPEQ_WALK01
  G1 == G2 & x is Walk of G1 implies x is Walk of G2 proof assume
A1: G1 == G2 & x is Walk of G1; then
A2: the_Vertices_of G1 = the_Vertices_of G2 &
    the_Edges_of G2 = the_Edges_of G1 by GLIB_000:def 36; then
    reconsider W = x as FinSequence of the_Vertices_of G2 \/ the_Edges_of G2
      by A1;
A3: len W is odd & W.1 in the_Vertices_of G2 by A1,A2,Def3;
    now let n be odd Element of NAT; assume n < len W; then
        W.(n+1) Joins W.n, W.(n+2), G1 by A1, Def3;
        hence W.(n+1) Joins W.n, W.(n+2), G2 by A1,GLIB_000:91;
    end;
    hence thesis by A3,Def3;
end;

theorem ::tGPEQ_WF01
  G1 == G2 implies G1.walkOf(x,e,y) = G2.walkOf(x,e,y) proof
  assume
A1: G1 == G2;
    now per cases;
    suppose
    A2: e Joins x,y,G1; then
    A3: e Joins x,y,G2 by A1, GLIB_000:91;
        thus G1.walkOf(x,e,y) = <*x,e,y*> by A2, Def5
                             .= G2.walkOf(x,e,y) by A3, Def5; end;
    suppose
    A4: not e Joins x,y,G1; then
    A5: not e Joins x,y,G2 by A1,GLIB_000:91;
        thus G1.walkOf(x,e,y) = G1.walkOf(choose the_Vertices_of G1)
                                by A4,Def5
                             .= G2.walkOf(choose the_Vertices_of G2) by A1,
GLIB_000:def 36
                             .= G2.walkOf(x,e,y) by A5, Def5; end;
    end;
    hence thesis;
end;

theorem ::tGPEQ_WA01
  for W1 being Walk of G1, W2 being Walk of G2 st G1 == G2 & W1 = W2 holds
    (W1 is closed          iff W2 is closed) &
    (W1 is directed        iff W2 is directed) &
    (W1 is trivial         iff W2 is trivial) &
    (W1 is Trail-like      iff W2 is Trail-like) &
    (W1 is Path-like       iff W2 is Path-like) &
    (W1 is vertex-distinct iff W2 is vertex-distinct) proof
    let W1 be Walk of G1, W2 be Walk of G2; assume
A1: G1 == G2 & W1 = W2; then
    G1 is Subgraph of G2 by GLIB_000:90;
    hence thesis by A1,Th177;
end;    
