:: Walks in a Graph
::  by Gilbert Lee
::
:: Received February 22, 2005
:: Copyright (c) 2005 Association of Mizar Users
 
environ

 vocabularies NUMBERS, ABIAN, SUBSET_1, ARYTM_3, XXREAL_0, ARYTM_1, CARD_1,
      TARSKI, FINSEQ_1, RELAT_1, FUNCT_1, NAT_1, XBOOLE_0, GLIB_000, FINSEQ_5,
      GRAPH_2, INT_1, FINSET_1, RCOMP_1, WAYBEL_0, ZFMISC_1, MSAFREE2,
      ORDINAL4, GRAPH_1, FUNCT_4, FUNCOP_1, MCART_1, GLIB_001;
 notations TARSKI, XBOOLE_0, CARD_1, NUMBERS, SUBSET_1, XCMPLX_0, XXREAL_0,
      DOMAIN_1, RELAT_1, FUNCT_1, FINSEQ_1, GRAPH_2, FINSEQ_5, RELSET_1,
      MCART_1, FINSET_1, NAT_1, NAT_D, FUNCOP_1, FUNCT_4, GLIB_000, ABIAN;
 constructors DOMAIN_1, FUNCT_4, NAT_D, RECDEF_1, FINSEQ_5, GLIB_000, ABIAN,
      GRAPH_2, XXREAL_2, RELSET_1, FINSEQ_2, RAT_1;
 registrations XBOOLE_0, RELAT_1, FUNCT_1, ORDINAL1, FUNCOP_1, FINSET_1,
      XXREAL_0, XREAL_0, NAT_1, INT_1, FINSEQ_1, GLIB_000, ABIAN, GRAPH_2,
      GRAPH_3, CARD_1, SUBSET_1;
 requirements ARITHM, BOOLE, NUMERALS, REAL, SUBSET;
 definitions FUNCOP_1;
 theorems CARD_1, CARD_2, FUNCOP_1, ENUMSET1, FINSEQ_1, FINSEQ_2, FINSEQ_3,
      FINSEQ_4, FINSEQ_5, FINSEQ_6, FINSET_1, FUNCT_1, FUNCT_4, GLIB_000,
      GRAPH_2, GRAPH_5, INT_1, JORDAN12, MCART_1, NAT_1, NAT_2, PEPIN, RELAT_1,
      TARSKI, XBOOLE_0, XBOOLE_1, XREAL_1, PRE_CIRC, XXREAL_0, ABIAN, ORDINAL1,
      NAT_D;
 schemes FINSEQ_1, FUNCT_1, NAT_1, RECDEF_1;

begin :: Preliminaries

theorem Th1:
  for x,y being odd Element of NAT holds x < y iff x + 2 <= y
proof
  let x,y be odd Element of NAT;
  hereby
    assume x < y;
    then x + 1 <= y by NAT_1:13;
    then x + 1 < y by XXREAL_0:1;
    then x + 1 + 1 < y + 1 by XREAL_1:10;
    hence x + 2 <= y by NAT_1:13;
  end;
  assume x + 2 <= y;
  then x + 2 - 2 < y - 0 by XREAL_1:17;
  hence thesis;
end;

theorem Th2:
  for X being set, k being Element of NAT st X c= Seg k holds for m
  ,n being Element of NAT st m in dom (Sgm X) & n = (Sgm X).m holds m <= n
proof
  let X be set, k be Element of NAT;
  defpred P[Nat] means ($1 in dom (Sgm X) & (ex n being Element of NAT st n=(
  Sgm X).$1 & $1 <= n)) or (not $1 in dom (Sgm X));
  assume
A1: X c= Seg k;
  now
    let x be non empty Nat;
    assume
A2: P[x];
    now
      per cases by A2;
      suppose
A3:     x in dom (Sgm X) & ex n being Element of NAT st n = (Sgm X).x & x <= n;
A4:     x+0 < x+1 by XREAL_1:10;
        consider n being Element of NAT such that
A5:     n = Sgm(X).x and
A6:     x <= n by A3;
A7:     1 <= x by A3,FINSEQ_3:27;
        now
          set n1 = (Sgm X).(x+1);
          assume
A8:       x+1 in dom (Sgm X);
          then (Sgm X).(x+1) in rng (Sgm X) by FUNCT_1:12;
          then reconsider n1 as Element of NAT;
          take n1;
          thus n1 = (Sgm X).(x+1);
          x+1 <= len Sgm X by A8,FINSEQ_3:27;
          then n < n1 by A1,A7,A4,A5,FINSEQ_1:def 13;
          then x < n1 by A6,XXREAL_0:2;
          hence x+1 <= n1 by NAT_1:13;
        end;
        hence P[x+1];
      end;
      suppose
        not x in dom (Sgm X);
        then x < 0+1 or x > len Sgm X by FINSEQ_3:27;
        then x+1 > len Sgm X + 0 by NAT_1:13;
        hence P[x+1] by FINSEQ_3:27;
      end;
    end;
    hence P[x+1];
  end;
  then
A9: for x being non empty Nat st P[x] holds P[x+1];
  let m, n be Element of NAT;
  assume that
A10: m in dom (Sgm X) and
A11: n = (Sgm X).m;
  reconsider m9=m as non empty Element of NAT by A10,FINSEQ_3:27;
  now
    set n = (Sgm X).1;
A12: m <= len (Sgm X) by A10,FINSEQ_3:27;
    1 <= m by A10,FINSEQ_3:27;
    then 1 <= len (Sgm X) by A12,XXREAL_0:2;
    hence 1 in dom (Sgm X) by FINSEQ_3:27;
    then
A13: (Sgm X).1 in rng (Sgm X) by FUNCT_1:12;
    then reconsider n as Element of NAT;
    take n;
    thus n = (Sgm X).1;
    rng (Sgm X) = X by A1,FINSEQ_1:def 13;
    hence 1 <= n by A1,A13,FINSEQ_1:3;
  end;
  then
A14: P[1];
  for x being non empty Nat holds P[x] from NAT_1:sch 10(A14,A9);
  then P[m9];
  hence thesis by A10,A11;
end;

theorem Th3:
  for X being set, fs being FinSequence of X, fss being Subset of
  fs holds len (Seq fss) <= len fs
proof
  let X be set, fs be FinSequence of X, fss be Subset of fs;
A1: Seq fss = fss * Sgm(dom fss) by FINSEQ_1:def 14;
  dom fss c= dom fs by GRAPH_2:27;
  then
A2: dom fss c= Seg len fs by FINSEQ_1:def 3;
  then rng (Sgm(dom fss)) = dom fss by FINSEQ_1:def 13;
  then len (Seq fss) = len Sgm (dom fss) by A1,FINSEQ_2:33
    .= card (dom fss) by A2,FINSEQ_3:44
    .= card fss by CARD_1:104;
  hence thesis by NAT_1:44;
end;

theorem Th4:
  for X being set, fs being FinSequence of X, fss being Subset of
fs, m being Element of NAT st m in dom Seq fss holds ex n being Element of NAT
  st n in dom fs & m <= n & (Seq fss).m = fs.n
proof
  let X be set, fs be FinSequence of X, fss be Subset of fs, m be Element of
  NAT;
  set f = Sgm(dom fss), n = f.m;
  consider k being Nat such that
A1: dom fss c= Seg k by FINSEQ_1:def 12;
  assume
A2: m in dom Seq fss;
  then
A3: m in dom (fss * f) by FINSEQ_1:def 14;
  then
A4: n in dom fss by FUNCT_1:21;
  Seq fss = fss * f by FINSEQ_1:def 14;
  then (Seq fss).m = fss.n by A2,FUNCT_1:22;
  then
A5: [n, Seq(fss).m] in fss by A4,FUNCT_1:def 4;
  then
A6: n in dom fs by FUNCT_1:8;
A7: m in dom f by A3,FUNCT_1:21;
A8: (Seq fss).m = fs.n by A5,FUNCT_1:8;
  k in NAT by ORDINAL1:def 13;
  hence thesis by A7,A6,A8,A1,Th2;
end;

theorem Th5:
  for X being set, fs being FinSequence of X, fss being Subset of
  fs holds len Seq fss = card fss
proof
  let X be set, fs be FinSequence of X, fss be Subset of fs;
A1: Seq fss = fss * Sgm(dom fss) by FINSEQ_1:def 14;
A2: ex k being Nat st dom fss c= Seg k by FINSEQ_1:def 12;
  then rng Sgm(dom fss) = dom fss by FINSEQ_1:def 13;
  then dom (Seq fss) = dom (Sgm (dom fss)) by A1,RELAT_1:46;
  then dom (Seq fss) = Seg (card dom fss) by A2,FINSEQ_3:45;
  then len Seq fss = card dom fss by FINSEQ_1:def 3;
  hence thesis by CARD_1:104;
end;

theorem Th6:
  for X being set, fs being FinSequence of X, fss being Subset of
  fs holds dom Seq fss = dom Sgm (dom fss)
proof
  let X be set, fs be FinSequence of X, fss be Subset of fs;
  ex k being Nat st dom fss c= Seg k by FINSEQ_1:def 12;
  then
A1: rng Sgm(dom fss) c= dom fss by FINSEQ_1:def 13;
  Seq fss = fss * Sgm (dom fss) by FINSEQ_1:def 14;
  hence thesis by A1,RELAT_1:46;
end;

begin :: Definitions

definition
  let G be _Graph;
  mode VertexSeq of G -> FinSequence of the_Vertices_of G means
    :Def1:
    for n
being Element of NAT st 1 <= n & n < len it holds ex e being set st e Joins it.
    n, it.(n+1), G;
  existence
  proof
    set v = choose the_Vertices_of G, IT = <*v*>;
    reconsider IT as FinSequence of the_Vertices_of G;
    take IT;
    let n be Element of NAT;
    assume that
A1: 1 <= n and
A2: n < len IT;
    thus thesis by A1,A2,FINSEQ_1:57;
  end;
end;

definition
  let G be _Graph;
  mode EdgeSeq of G -> FinSequence of the_Edges_of G means
    :Def2:
    ex vs being
FinSequence of the_Vertices_of G st len vs = len it + 1 & for n being Element
    of NAT st 1 <= n & n <= len it holds it.n Joins vs.n,vs.(n+1),G;
  existence
  proof
    set IT = <*>the_Edges_of G, vs = <*choose the_Vertices_of G*>;
    reconsider vs as FinSequence of the_Vertices_of G;
    take IT, vs;
    thus len vs = len IT + 1 by FINSEQ_1:57;
    let n be Element of NAT;
    assume that
A1: 1 <= n and
A2: n <= len IT;
    thus thesis by A1,A2;
  end;
end;

definition
  let G be _Graph;
  mode Walk of G -> FinSequence of the_Vertices_of G \/ the_Edges_of G means
    :
    Def3: len
 it is odd & it.1 in the_Vertices_of G & for n being odd Element of
    NAT st n < len it holds it.(n+1) Joins it.n, it.(n+2), G;
  existence
  proof
    set VE = (the_Vertices_of G) \/ (the_Edges_of G);
    consider v being set such that
A1: v in the_Vertices_of G by XBOOLE_0:def 1;
    reconsider v as Element of VE by A1,XBOOLE_0:def 3;
    take <*v*>;
    thus len <*v*> is odd by FINSEQ_1:57,JORDAN12:3;
    thus <*v*>.1 in the_Vertices_of G by A1,FINSEQ_1:57;
    let n be odd Element of NAT;
    assume n < len <*v*>;
    then n < 1 by FINSEQ_1:57;
    hence thesis by ABIAN:12;
  end;
end;

registration
  let G be _Graph, W be Walk of G;
  cluster len W -> odd non empty;
  correctness
  proof
    thus len W is odd by Def3;
    hence thesis;
  end;
end;

definition
  let G be _Graph, v be Vertex of G;
  func G.walkOf(v) -> Walk of G equals
  <*v*>;
  coherence
  proof
    set VE = (the_Vertices_of G) \/ (the_Edges_of G), W = <*v*>, v9 = v;
    reconsider v9 as Element of VE by XBOOLE_0:def 3;
    <*v9*> is FinSequence of VE;
    then reconsider W as FinSequence of VE;
    now
      thus len W is odd by FINSEQ_1:57,JORDAN12:3;
      W.1 = v by FINSEQ_1:57;
      hence W.1 in the_Vertices_of G;
      let n be odd Element of NAT;
A1:   1 <= n by ABIAN:12;
      assume n < len <*v*>;
      hence W.(n+1) Joins W.n, W.(n+2), G by A1,FINSEQ_1:57;
    end;
    hence thesis by Def3;
  end;
end;

definition
  let G be _Graph, x,y,e be set;
  func G.walkOf(x,e,y) -> Walk of G equals
  : Def5:
  <*x,e,y*> if e Joins x,y,G
  otherwise G.walkOf(choose the_Vertices_of G);
  coherence
  proof
    set VE = (the_Vertices_of G)\/(the_Edges_of G);
    hereby
      set W = <*x,e,y*>;
      assume
A1:   e Joins x,y,G;
      then y is Vertex of G by GLIB_000:16;
      then
A2:   y is Element of VE by XBOOLE_0:def 3;
      e in the_Edges_of G by A1,GLIB_000:def 15;
      then
A3:   e is Element of VE by XBOOLE_0:def 3;
      x is Vertex of G by A1,GLIB_000:16;
      then x is Element of VE by XBOOLE_0:def 3;
      then reconsider W as FinSequence of VE by A2,A3,FINSEQ_2:16;
A4:   W.1 = x by FINSEQ_1:62;
A5:   W.2 = e by FINSEQ_1:62;
      now
        reconsider aa1=1 as odd Element of NAT by JORDAN12:3;
        aa1+2 is odd;
        hence len W is odd by FINSEQ_1:62;
        thus W.1 in the_Vertices_of G by A1,A4,GLIB_000:16;
        let n be odd Element of NAT;
        assume n < len W;
        then n < 2 + 1 by FINSEQ_1:62;
        then n <= 2*1 by NAT_1:13;
        then n = 2*0 or n = 1 or n = 2*1 by NAT_1:27;
        hence W.(n+1) Joins W.n,W.(n+2),G by A1,A4,A5,FINSEQ_1:62;
      end;
      hence <*x,e,y*> is Walk of G by Def3;
    end;
    thus thesis;
  end;
  consistency;
end;

definition
  let G be _Graph, W be Walk of G;
  func W.first() -> Vertex of G equals
  W.1;
  coherence by Def3;
  func W.last() -> Vertex of G equals
  W.(len W);
  coherence
  proof
    now
      per cases;
      suppose
        len W = 1;
        hence thesis by Def3;
      end;
      suppose
A1:     len W <> 1;
        1 <= len W by ABIAN:12;
        then 1 < len W by A1,XXREAL_0:1;
        then 1+1 < len W + 1 by XREAL_1:10;
        then 2 <= len W by NAT_1:13;
        then reconsider n = len W - 2 * 1 as odd Element of NAT by INT_1:18;
A2:     n + 2 = len W;
        then n < len W by NAT_1:16;
        then W.(n+1) Joins W.n, W.(len W), G by A2,Def3;
        hence thesis by GLIB_000:16;
      end;
    end;
    hence thesis;
  end;
end;

definition
  let G be _Graph, W be Walk of G, n be Nat;
  func W.vertexAt(n) -> Vertex of G equals
  :Def8:
  W.n if n is odd & n <= len W
  otherwise W.first();
  correctness
  proof
    hereby
      reconsider n1 = n as Element of NAT by ORDINAL1:def 13;
      assume that
A1:   n is odd and
A2:   n <= len W;
      now
        per cases;
        suppose
          n = len W;
          then W.n = W.last();
          hence W.n is Vertex of G;
        end;
        suppose
          n <> len W;
          then n < len W by A2,XXREAL_0:1;
          then W.(n1+1) Joins W.n, W.(n+2), G by A1,Def3;
          hence W.n is Vertex of G by GLIB_000:16;
        end;
      end;
      hence W.n is Vertex of G;
    end;
    thus thesis;
  end;
end;

definition
  let G be _Graph, W be Walk of G;
  func W.reverse() -> Walk of G equals
  Rev W;
  coherence
  proof
    set W9 = Rev W;
    reconsider W9 as FinSequence of (the_Vertices_of G)\/(the_Edges_of G);
A1: len W9 = len W by FINSEQ_5:def 3;
    now
      thus len W9 is odd by A1;
      W9.1 = W.last() by FINSEQ_5:65;
      hence W9.1 in the_Vertices_of G;
      let n be odd Element of NAT;
      set rn = len W-n+1, rnaa1 = len W-(n+1)+1, rn2 = len W-(n+2)+1;
      assume
A2:   n < len W9;
      then
A3:   n+1 <= len W by A1,NAT_1:13;
      then reconsider rnaa1 as even Element of NAT by FINSEQ_5:1;
      n+1 < len W by A3,XXREAL_0:1;
      then
A4:   n+1+1 <= len W by NAT_1:13;
      then reconsider rn2 as odd Element of NAT by FINSEQ_5:1;
      1 <= n+1 by NAT_1:12;
      then n+1 in dom W by A3,FINSEQ_3:27;
      then
A5:   W9.(n+1) = W.(rnaa1) by FINSEQ_5:61
        .= W.(rn2+1);
A6:   n <= len W by A2,FINSEQ_5:def 3;
      then reconsider rn as odd Element of NAT by FINSEQ_5:1;
      1 <= n by ABIAN:12;
      then n in dom W by A6,FINSEQ_3:27;
      then
A7:   W9.n = W.rn by FINSEQ_5:61
        .= W.(rn2+2);
      1+0 < n+2 by XREAL_1:10;
      then len W - (n+2) < len W - 1 by XREAL_1:17;
      then len W - (n+2) + 1 < len W - 1 + 1 by XREAL_1:10;
      then
A8:   W.(rn2+1) Joins W.rn2, W.(rn2+2), G by Def3;
      1 <= n+2 by NAT_1:12;
      then n+2 in dom W by A4,FINSEQ_3:27;
      then W9.(n+1) Joins W9.(n+2), W9.n, G by A8,A7,A5,FINSEQ_5:61;
      hence W9.(n+1) Joins W9.n, W9.(n+2), G by GLIB_000:17;
    end;
    hence thesis by Def3;
  end;
end;

definition
  let G be _Graph, W1, W2 be Walk of G;
  func W1.append(W2) -> Walk of G equals
  :Def10:
  W1 ^' W2 if W1.last() = W2
  .first() otherwise W1;
  correctness
  proof
    set W = W1 ^' W2, lenW = len W;
    hereby
      assume
A1:   W1.last() = W2.first();
A2:   now
        let n be odd Element of NAT such that
A3:     n < len W;
        set v1 = W.n, v2 = W.(n+2), e = W.(n+1);
        now
          per cases;
          suppose
A4:         n+2 <= len W1;
A5:         1 <= n by ABIAN:12;
            n+2-2 <= len W1-0 by A4,XREAL_1:15;
            then
A6:         W.n = W1.n by A5,GRAPH_2:14;
            n+2-1 <= len W1-0 by A4,XREAL_1:15;
            then
A7:         W.(n+1) = W1.(n+1) by GRAPH_2:14,NAT_1:12;
A8:         W.(n+2) = W1.(n+2) by A4,GRAPH_2:14,NAT_1:12;
            n < len W1 by A4,NAT_1:16,XXREAL_0:2;
            hence W.(n+1) Joins W.n,W.(n+2),G by A6,A7,A8,Def3;
          end;
          suppose
A9:         len W1 < n+2;
            then len W1 + 1 <= n+2 by NAT_1:13;
            then len W1 + 1 < n+1+1 by XXREAL_0:1;
            then len W1 < n + 1 by XREAL_1:8;
            then
A10:        len W1 <= n by NAT_1:13;
            consider k being Nat such that
A11:        n + 2 = len W1 + k by A9,NAT_1:10;
            reconsider k as even Element of NAT by A11,ORDINAL1:def 13;
            k <> 0 by A9,A11;
            then 0 + 1 < k + 1 by XREAL_1:10;
            then
A12:        1 <= k by NAT_1:13;
            n + 1 < len W + 1 by A3,XREAL_1:10;
            then n + 1 < len W1 + len W2 by CARD_1:47,GRAPH_2:13;
            then n + 1 + 1 < len W1 + len W2 + 1 by XREAL_1:10;
            then
A13:        k + len W1 < len W1 + (len W2 + 1) by A11;
            then k < len W2 + 1 by XREAL_1:8;
            then
A14:        k <= len W2 by NAT_1:13;
            then
A15:        k < len W2 by XXREAL_0:1;
            then
A16:        W.(n + 2) = W2.(k+1) by A11,A12,GRAPH_2:15;
            now
              per cases;
              suppose
A17:            n = len W1;
                1 <= n by ABIAN:12;
                then
A18:            W.n = W1.(len W1) by A17,GRAPH_2:14;
                1+1+0< len W2 + 1 by A11,A13,A17,XREAL_1:8;
                then
A19:            1 < len W2 by XREAL_1:8;
                then W.(n + 1) = W2.(1+1) by A17,GRAPH_2:15;
                hence W.(n+1) Joins W.n, W.(n+2), G by A1,A11,A16,A17,A18,A19
,Def3,JORDAN12:3;
              end;
              suppose
A20:            len W1 <> n;
                reconsider two=2*1 as even Element of NAT;
A21:            len W1 < n by A10,A20,XXREAL_0:1;
                then reconsider k2 = k-two as even Element of NAT by A11,
INT_1:18,XREAL_1:10;
                2+len W1-len W1<k+len W1-len W1 by A11,A21,XREAL_1:10;
                then 1+1-1 < k2 + 1 + 1 - 1 by XREAL_1:16;
                then
A22:            1 <= k2 by NAT_1:13;
                set kaa1 = k2+1;
                reconsider kaa1 as odd Element of NAT;
A23:            1 <= k2+1 by NAT_1:12;
                kaa1+1-1 < len W2-0 by A14,XREAL_1:17;
                then
A24:            W2.(kaa1+1) = W.(len W1 + kaa1) by A23,GRAPH_2:15
                  .= W.(n+1) by A11;
                kaa1 < kaa1 + 1 by NAT_1:19;
                then
A25:            kaa1 < len W2 by A14,XXREAL_0:2;
                kaa1+2 = k + 1;
                then
A26:            W2.(kaa1+2) = W.(n+2) by A11,A12,A15,GRAPH_2:15;
                k2 < k2 + (1+1) by NAT_1:16;
                then
A27:            k2 < len W2 by A14,XXREAL_0:2;
                n + 2 = len W1 + k2 + 2 by A11;
                then W.n = W2.(k2+1) by A22,A27,GRAPH_2:15;
                hence e Joins v1,v2,G by A26,A25,A24,Def3;
              end;
            end;
            hence e Joins v1,v2,G;
          end;
        end;
        hence e Joins v1,v2,G;
      end;
A28:  now
        assume len W is even;
        then reconsider lenW as even Element of NAT;
        lenW + 1 = len W1 + len W2 by CARD_1:47,GRAPH_2:13;
        hence contradiction;
      end;
      1 <= len W1 by ABIAN:12;
      then W.1 = W1.first() by GRAPH_2:14;
      hence W1 ^' W2 is Walk of G by A28,A2,Def3;
    end;
    thus thesis;
  end;
end;

definition
  let G be _Graph, W be Walk of G, m, n being Nat;
  func W.cut(m,n) -> Walk of G equals
  :Def11:
  (m,n)-cut W if m is odd & n is
  odd & m <= n & n <= len W otherwise W;
  correctness
  proof
    hereby
      set W2 = (m,n)-cut W, VG = the_Vertices_of G;
      assume that
A1:   m is odd and
A2:   n is odd and
A3:   m <= n and
A4:   n <= len W;
      reconsider m4 = m, n4 = n as odd Nat by A1,A2;
A5:   1 <= m by A1,ABIAN:12;
      then len W2 + m4 - m4 = n4 + 1 - m4 by A3,A4,GRAPH_2:def 1;
      then reconsider lenW2 = len W2 as odd Element of NAT;
      now
        reconsider lenW2aa1 = lenW2-1 as Element of NAT by ABIAN:12,INT_1:18;
        lenW2 is odd;
        hence len W2 is odd;
        0 < lenW2aa1 + 1;
        then
A6:     W2.(0+1) = W.(m+0) by A3,A4,A5,GRAPH_2:def 1;
        m <= len W by A3,A4,XXREAL_0:2;
        then W.m = W.vertexAt(m) by A1,Def8;
        hence W2.1 in VG by A6;
        let i be odd Element of NAT;
        reconsider x=m4+i-1 as odd Element of NAT by A5,INT_1:18,NAT_1:12;
        reconsider iaa1 = i-1 as even Element of NAT by ABIAN:12,INT_1:18;
        assume
A7:     i < len W2;
        then i+1 <= lenW2 by NAT_1:13;
        then i+1 < len W2 by XXREAL_0:1;
        then
A8:     W2.(i+1+1) = W.(m+(i+1)) by A3,A4,A5,GRAPH_2:def 1;
        i + m < len W2 + m by A7,XREAL_1:10;
        then i + m < n + 1 by A3,A4,A5,GRAPH_2:def 1;
        then i + m4 <= n4 by NAT_1:13;
        then m4 + i < n4 by XXREAL_0:1;
        then m + i < len W by A4,XXREAL_0:2;
        then m + i - 1 < len W - 0 by XREAL_1:16;
        then
A9:     W.(x+1) Joins W.x, W.(x+2), G by Def3;
        iaa1 < len W2-0 by A7,XREAL_1:16;
        then W2.(iaa1+1) = W.(m+iaa1) by A3,A4,A5,GRAPH_2:def 1;
        hence W2.(i+1) Joins W2.i, W2.(i+2), G by A3,A4,A5,A7,A8,A9,
GRAPH_2:def 1;
      end;
      hence (m,n)-cut W is Walk of G by Def3;
    end;
    thus thesis;
  end;
end;

definition
  let G be _Graph, W be Walk of G, m, n be Element of NAT;
  func W.remove(m,n) -> Walk of G equals
  :Def12:
  W.cut(1,m).append(W.cut(n,len
  W)) if m is odd & n is odd & m <= n & n <= len W & W.m = W.n otherwise W;
  correctness;
end;

definition
  let G be _Graph, W be Walk of G, e be set;
  func W.addEdge(e) -> Walk of G equals
  W.append(G.walkOf(W.last(), e, W
  .last().adj(e)));
  coherence;
end;

definition
  let G be _Graph, W be Walk of G;
  func W.vertexSeq() -> VertexSeq of G means
  :Def14:
  len W + 1 = 2 * len it &
  for n being Nat st 1 <= n & n <= len it holds it.n = W.(2*n - 1);
  existence
  proof
    deffunc F(Nat) = W.(2*$1-1);
    reconsider lenW1 = len W + 1 as even Element of NAT;
    set lenIT = lenW1 div 2;
    consider IT being FinSequence such that
A1: len IT = lenIT & for k being Nat st k in dom IT holds IT.k = F(k)
    from FINSEQ_1:sch 2;
A2: 2 divides lenW1 by PEPIN:22;
    then
A3: 2*lenIT = lenW1 by NAT_D:3;
    now
      let y be set;
      assume y in rng IT;
      then consider x being set such that
A4:   x in dom IT and
A5:   y = IT.x by FUNCT_1:def 5;
A6:   x in Seg lenIT by A1,A4,FINSEQ_1:def 3;
      reconsider x as Element of NAT by A4;
      set 2x = x*2;
      reconsider 2x as even Element of NAT;
      set 2xaa1 = 2x-1;
      1 <= x by A6,FINSEQ_1:3;
      then 1*2 <= 2x by XREAL_1:66;
      then reconsider 2xaa1 as odd Element of NAT by INT_1:18,XXREAL_0:2;
      x <= lenIT by A6,FINSEQ_1:3;
      then 2x <= lenIT * 2 by XREAL_1:66;
      then 2xaa1 <= lenW1-1 by A3,XREAL_1:11;
      then W.2xaa1 = W.vertexAt(2xaa1) by Def8;
      then W.2xaa1 in the_Vertices_of G;
      hence y in the_Vertices_of G by A1,A4,A5;
    end;
    then rng IT c= the_Vertices_of G by TARSKI:def 3;
    then reconsider IT as FinSequence of the_Vertices_of G by FINSEQ_1:def 4;
    now
      let n be Element of NAT;
      set v2 = IT.(n+1);
      assume that
A7:   1 <= n and
A8:   n < len IT;
      set 2n = 2*n;
      reconsider 2n as even Element of NAT;
A9:   1 <= n+1 by A7,NAT_1:13;
      set 2naa1 = 2n-1;
      1*2 <= n*2 by A7,XREAL_1:66;
      then reconsider 2naa1 as odd Element of NAT by INT_1:18,XXREAL_0:2;
      2n <= lenW1 by A3,A1,A8,XREAL_1:70;
      then
A10:  2n - 1 <= len W + 1 - 1 by XREAL_1:11;
      2naa1 <> len W by A3,A1,A8;
      then 2naa1 < len W by A10,XXREAL_0:1;
      then
A11:  W.(2naa1+1) Joins W.2naa1, W.(2naa1+2), G by Def3;
      n+1 <= lenIT by A1,A8,NAT_1:13;
      then n+1 in dom IT by A1,A9,FINSEQ_3:27;
      then
A12:  v2 = W.(2*(n+1)-1) by A1
        .= W.(2n+1);
      n in dom IT by A7,A8,FINSEQ_3:27;
      then W.(2naa1+1) Joins IT.n, W.(2naa1+2), G by A1,A11;
      hence ex e being set st e Joins IT.n, IT.(n+1), G by A12;
    end;
    then reconsider IT as VertexSeq of G by Def1;
    take IT;
    thus len W + 1 = 2 * len IT by A2,A1,NAT_D:3;
    let n be Nat;
    assume that
A13: 1 <= n and
A14: n <= len IT;
    n in dom IT by A13,A14,FINSEQ_3:27;
    hence thesis by A1;
  end;
  uniqueness
  proof
    let IT1, IT2 be VertexSeq of G such that
A15: len W + 1 = 2 * len IT1 and
A16: for n being Nat st 1 <= n & n <= len IT1 holds IT1.n = W.(2*n - 1 ) and
A17: len W + 1 = 2 * len IT2 and
A18: for n being Nat st 1 <= n & n <= len IT2 holds IT2.n = W.(2*n - 1 );
A19: now
      let n be Nat such that
A20:  n in dom IT1;
A21:  n <= len IT1 by A20,FINSEQ_3:27;
A22:  1 <= n by A20,FINSEQ_3:27;
      then IT1.n = W.(2*n - 1) by A16,A21;
      hence IT1.n = IT2.n by A15,A17,A18,A22,A21;
    end;
    dom IT1 = Seg len IT2 by A15,A17,FINSEQ_1:def 3
      .= dom IT2 by FINSEQ_1:def 3;
    hence IT1 = IT2 by A19,FINSEQ_1:17;
  end;
end;

definition
  let G be _Graph, W be Walk of G;
  func W.edgeSeq() -> EdgeSeq of G means
  :Def15:
  len W = 2*len it+1 & for n
  being Nat st 1 <= n & n <= len it holds it.n = W.(2*n);
  existence
  proof
    deffunc F(Nat) = W.(2*$1);
    reconsider lenWaa1 = len W-1 as even Element of NAT by ABIAN:12,INT_1:18;
    set lenIT = lenWaa1 div 2;
    reconsider lenIT as Element of NAT;
    consider IT being FinSequence such that
A1: len IT = lenIT & for n being Nat st n in dom IT holds IT.n = F(n)
    from FINSEQ_1:sch 2;
    now
      let y be set;
A2:   2 divides lenWaa1 by PEPIN:22;
      assume y in rng IT;
      then consider x being set such that
A3:   x in dom IT and
A4:   y = IT.x by FUNCT_1:def 5;
A5:   x in Seg lenIT by A1,A3,FINSEQ_1:def 3;
      reconsider x as Element of NAT by A3;
      reconsider 2x = 2*x as even Element of NAT;
      x <= lenIT by A5,FINSEQ_1:3;
      then x*2 <= lenIT*2 by XREAL_1:66;
      then 2x <= lenWaa1 by A2,NAT_D:3;
      then
A6:   2x + 1 <= lenWaa1 + 1 by XREAL_1:9;
      1 <= x by A5,FINSEQ_1:3;
      then 1*2 <= 2*x by XREAL_1:66;
      then reconsider 2xaa1 = 2x-1 as odd Element of NAT by INT_1:18,XXREAL_0:2
;
      2x <= 2x+1 by NAT_1:11;
      then 2x <= len W by A6,XXREAL_0:2;
      then 2xaa1 < len W by XREAL_1:149;
      then
A7:   W.(2xaa1+1) Joins W.2xaa1, W.(2xaa1+2), G by Def3;
      y = W.(2*x) by A1,A3,A4;
      hence y in the_Edges_of G by A7,GLIB_000:def 15;
    end;
    then rng IT c= the_Edges_of G by TARSKI:def 3;
    then reconsider IT as FinSequence of the_Edges_of G by FINSEQ_1:def 4;
    2 divides lenWaa1 by PEPIN:22;
    then
A8: lenWaa1 = 2 * lenIT by NAT_D:3;
    then
A9: len W = 2 * lenIT + 1;
    now
      set vs = W.vertexSeq();
      take vs;
A10:  (2 * len IT + 1) + 1 = 2 * len vs by A8,A1,Def14;
      then
A11:  2 * (len IT + 1) = 2 * len vs;
      thus len vs = len IT + 1 by A10;
      let n be Element of NAT;
      set v1 = vs.n, v2 = vs.(n+1);
      assume that
A12:  1 <= n and
A13:  n <= len IT;
      set 2n = 2*n;
      reconsider 2n as even Element of NAT;
      set 2naa1 = 2n-1;
      1 <= n+n by A12,NAT_1:12;
      then reconsider 2naa1 as odd Element of NAT by INT_1:18;
A14:  1 <= n+1 by NAT_1:12;
      n*2 <= len IT*2 by A13,XREAL_1:66;
      then n*2 <= len W by A9,A1,NAT_1:12;
      then
A15:  2naa1 < len W - 0 by XREAL_1:17;
      n+1 <= len vs by A11,A13,XREAL_1:9;
      then v2 = W.(2*(n+1)-1) by A14,Def14;
      then
A16:  v2 = W.(2naa1+2);
      n in dom IT by A12,A13,FINSEQ_3:27;
      then
A17:  IT.n = W.(2naa1+1) by A1;
      n <= len vs by A11,A13,NAT_1:12;
      then v1 = W.(2*n-1) by A12,Def14;
      hence IT.n Joins vs.n, vs.(n+1), G by A17,A16,A15,Def3;
    end;
    then reconsider IT as EdgeSeq of G by Def2;
    take IT;
    thus len W = 2*len IT+1 by A8,A1;
    let n be Nat;
    assume that
A18: 1 <= n and
A19: n <= len IT;
    n in dom IT by A18,A19,FINSEQ_3:27;
    hence thesis by A1;
  end;
  uniqueness
  proof
    let IT1, IT2 be EdgeSeq of G such that
A20: len W = 2*len IT1 + 1 and
A21: for n being Nat st 1 <= n & n <= len IT1 holds IT1.n = W.(2*n) and
A22: len W = 2*len IT2 + 1 and
A23: for n being Nat st 1 <= n & n <= len IT2 holds IT2.n = W.(2*n);
A24: now
      let n be Nat;
      assume
A25:  n in dom IT1;
      then
A26:  1 <= n by FINSEQ_3:27;
A27:  n <= len IT2 by A20,A22,A25,FINSEQ_3:27;
      n <= len IT1 by A25,FINSEQ_3:27;
      hence IT1.n = W.(2*n) by A21,A26
        .= IT2.n by A23,A26,A27;
    end;
    dom IT1 = Seg len IT2 by A20,A22,FINSEQ_1:def 3
      .= dom IT2 by FINSEQ_1:def 3;
    hence IT1 = IT2 by A24,FINSEQ_1:17;
  end;
end;

definition
  let G be _Graph, W be Walk of G;
  func W.vertices() -> finite Subset of the_Vertices_of G equals
  rng W
  .vertexSeq();
  coherence;
end;

definition
  let G be _Graph, W be Walk of G;
  func W.edges() -> finite Subset of the_Edges_of G equals
  rng W.edgeSeq();
  coherence;
end;

definition
  let G be _Graph, W be Walk of G;
  func W.length() -> Element of NAT equals
  len W.edgeSeq();
  coherence;
end;

definition
  let G be _Graph, W be Walk of G, v be set;
  func W.find(v) -> odd Element of NAT means
  :Def19:
  it <= len W & W.it = v &
for n being odd Nat st n <= len W & W.n = v holds it <= n if v in W.vertices()
  otherwise it = len W;
  existence
  proof
    hereby
      defpred P[Nat] means $1 is odd & $1 <= len W & W.$1 = v;
      set vs = W.vertexSeq();
      assume
A1:   v in W.vertices();
      now
        consider i being Nat such that
A2:     i in dom vs and
A3:     vs.i = v by A1,FINSEQ_2:11;
        set n1 = 2*i;
        reconsider n1 as even Nat;
        set n = n1-1;
A4:     1 <= i by A2,FINSEQ_3:27;
        then 1 <= i+i by NAT_1:12;
        then reconsider n as odd Element of NAT by INT_1:18;
        take n;
A5:     i <= len vs by A2,FINSEQ_3:27;
        then i*2 <= len vs *2 by XREAL_1:66;
        then i*2 <= len W + 1 by Def14;
        then n1 - 1 <= len W + 1 - 1 by XREAL_1:15;
        hence n <= len W;
        thus W.n = v by A3,A4,A5,Def14;
      end;
      then
A6:   ex k being Nat st P[k];
      consider IT being Nat such that
A7:   P[IT] & for n being Nat st P[n] holds IT <= n from NAT_1:sch 5(
      A6);
      reconsider IT as odd Element of NAT by A7,ORDINAL1:def 13;
      take IT;
      thus IT <= len W & W.IT = v by A7;
      let n be odd Nat;
      assume that
A8:   n <= len W and
A9:   W.n = v;
      thus IT <= n by A7,A8,A9;
    end;
    set IT = len W;
    assume not v in W.vertices();
    take IT;
    thus thesis;
  end;
  uniqueness
  proof
    let IT1, IT2 be odd Element of NAT;
    hereby
      assume v in W.vertices();
      assume that
A10:  IT1 <= len W and
A11:  W.IT1 = v and
A12:  for n being odd Nat st n <= len W & W.n = v holds IT1 <= n;
      assume that
A13:  IT2 <= len W and
A14:  W.IT2 = v and
A15:  for n being odd Nat st n <= len W & W.n = v holds IT2 <= n;
A16:  IT2 <= IT1 by A10,A11,A15;
      IT1 <= IT2 by A12,A13,A14;
      hence IT1 = IT2 by A16,XXREAL_0:1;
    end;
    assume not v in W.vertices();
    thus thesis;
  end;
  consistency;
end;

definition
  let G be _Graph, W be Walk of G, n be Element of NAT;
  func W.find(n) -> odd Element of NAT means
  :Def20:
  it <= len W & W.it = W.n
  & for k being odd Nat st k <= len W & W.k = W.n holds it <= k if n is odd & n
  <= len W otherwise it = len W;
  existence
  proof
    defpred P[Nat] means $1 is odd & $1 <= len W & W.$1 = W.n;
    hereby
      assume that
A1:   n is odd and
A2:   n <= len W;
A3:   ex n being Nat st P[n] by A1,A2;
      consider IT being Nat such that
A4:   P[IT] & for k being Nat st P[k] holds IT <= k from NAT_1:sch 5(
      A3);
      reconsider IT as odd Element of NAT by A4,ORDINAL1:def 13;
      take IT;
      thus IT <= len W & W.IT = W.n by A4;
      let k be odd Nat;
      thus k <= len W & W.k = W.n implies IT <= k by A4;
    end;
    thus thesis;
  end;
  uniqueness
  proof
    let IT1, IT2 be odd Element of NAT;
    hereby
      assume that
      n is odd and
      n <= len W;
      assume that
A5:   IT1 <= len W and
A6:   W.IT1 = W.n and
A7:   for k being odd Nat st k <= len W & W.k = W.n holds IT1 <= k;
      assume that
A8:   IT2 <= len W and
A9:   W.IT2 = W.n and
A10:  for k being odd Nat st k <= len W & W.k = W.n holds IT2 <= k;
A11:  IT2 <= IT1 by A5,A6,A10;
      IT1 <= IT2 by A7,A8,A9;
      hence IT1 = IT2 by A11,XXREAL_0:1;
    end;
    thus thesis;
  end;
  consistency;
end;

definition
  let G be _Graph, W be Walk of G, v be set;
  func W.rfind(v) -> odd Element of NAT means
  :Def21:
  it <= len W & W.it = v &
for n being odd Element of NAT st n <= len W & W.n = v holds n <= it if v in W
  .vertices() otherwise it = len W;
  existence
  proof
    hereby
      defpred P[Nat] means $1 is odd & $1 <= len W & W.$1 = v;
      assume
A1:   v in W.vertices();
      then
A2:   W.(W.find(v)) = v by Def19;
      W.find(v) <= len W by A1,Def19;
      then
A3:   ex k being Nat st P[k] by A2;
A4:   for k being Nat st P[k] holds k <= len W;
      consider IT being Nat such that
A5:   P[IT] & for n being Nat st P[n] holds n <= IT from NAT_1:sch 6(
      A4, A3);
      reconsider IT as odd Element of NAT by A5,ORDINAL1:def 13;
      take IT;
      thus IT <= len W & W.IT = v by A5;
      let n be odd Element of NAT;
      assume that
A6:   n <= len W and
A7:   W.n = v;
      thus n <= IT by A5,A6,A7;
    end;
    thus thesis;
  end;
  uniqueness
  proof
    let IT1, IT2 be odd Element of NAT;
    hereby
      assume v in W.vertices();
      assume that
A8:   IT1 <= len W and
A9:   W.IT1 = v and
A10:  for n being odd Element of NAT st n <= len W & W.n = v holds n <= IT1;
      assume that
A11:  IT2 <= len W and
A12:  W.IT2 = v and
A13:  for n being odd Element of NAT st n <= len W & W.n = v holds n <= IT2;
A14:  IT1 <= IT2 by A8,A9,A13;
      IT2 <= IT1 by A10,A11,A12;
      hence IT1 = IT2 by A14,XXREAL_0:1;
    end;
    thus thesis;
  end;
  consistency;
end;

definition
  let G be _Graph, W be Walk of G, n be Element of NAT;
  func W.rfind(n) -> odd Element of NAT means
  :Def22:
  it <= len W & W.it = W.n
  & for k being odd Element of NAT st k <= len W & W.k = W.n holds k <= it if n
  is odd & n <= len W otherwise it = len W;
  existence
  proof
    defpred P[Nat] means $1 is odd & $1 <= len W & W.$1 = W.n;
    hereby
A1:   for k being Nat st P[k] holds k <= len W;
      assume that
A2:   n is odd and
A3:   n <= len W;
A4:   ex k being Nat st P[k] by A2,A3;
      consider IT being Nat such that
A5:   P[IT] & for k being Nat st P[k] holds k <= IT from NAT_1:sch 6(
      A1, A4);
      reconsider IT as odd Element of NAT by A5,ORDINAL1:def 13;
      take IT;
      thus IT <= len W & W.IT = W.n by A5;
      thus for k being odd Element of NAT st k <= len W & W.k = W.n holds k <=
      IT by A5;
    end;
    thus thesis;
  end;
  uniqueness
  proof
    let IT1, IT2 be odd Element of NAT;
    hereby
      assume that
      n is odd and
      n <= len W;
      assume that
A6:   IT1 <= len W and
A7:   W.IT1 = W.n and
A8:   for k being odd Element of NAT st k <= len W & W.k = W.n holds k <= IT1;
      assume that
A9:   IT2 <= len W and
A10:  W.IT2 = W.n and
A11:  for k being odd Element of NAT st k <= len W & W.k = W.n holds k <= IT2;
A12:  IT2 <= IT1 by A8,A9,A10;
      IT1 <= IT2 by A6,A7,A11;
      hence IT1 = IT2 by A12,XXREAL_0:1;
    end;
    thus thesis;
  end;
  consistency;
end;

definition
  let G be _Graph, u, v be set, W be Walk of G;
  pred W is_Walk_from u,v means
  :Def23:
  W.first() = u & W.last() = v;
end;

definition
  let G be _Graph, W be Walk of G;
  attr W is closed means
  :Def24:
  W.first() = W.last();
  attr W is directed means
  :Def25:
  for n being odd Element of NAT st n < len W
  holds (the_Source_of G).(W.(n+1)) = W.n;
  attr W is trivial means
  :Def26:
  W.length() = 0;
  attr W is Trail-like means
  :Def27:
  W.edgeSeq() is one-to-one;
end;

notation
  let G be _Graph, W be Walk of G;
  antonym W is open for W is closed;
end;

definition
  let G be _Graph, W be Walk of G;
  attr W is Path-like means
  :Def28:
  W is Trail-like & for m, n being odd
Element of NAT st m < n & n <= len W holds W.m = W.n implies m = 1 & n = len W;
end;

definition
  let G be _Graph, W be Walk of G;
  attr W is vertex-distinct means
  :Def29:
  for m,n being odd Element of NAT st
  m <= len W & n <= len W & W.m = W.n holds m = n;
end;

definition
  let G be _Graph, W be Walk of G;
  attr W is Circuit-like means
  :Def30:
  W is closed & W is Trail-like & W is non trivial;
  attr W is Cycle-like means
  :Def31:
  W is closed & W is Path-like & W is non trivial;
end;

Lm1: for G be _Graph, W be Walk of G, n being odd Element of NAT st n <= len W
holds W.n in the_Vertices_of G
proof
  let G be _Graph, W be Walk of G, n be odd Element of NAT;
  assume n <= len W;
  then W.n = W.vertexAt(n) by Def8;
  hence thesis;
end;

Lm2: for G be _Graph, W be Walk of G, n being even Element of NAT st n in dom
W holds ex naa1 being odd Element of NAT st naa1 = n-1 & n-1 in dom W & n+1 in
dom W & W.n Joins W.(naa1), W.(n+1),G
proof
  let G be _Graph, W be Walk of G, n be even Element of NAT;
A1: 1 <= 1+n by NAT_1:12;
  assume
A2: n in dom W;
  then
A3: n <= len W by FINSEQ_3:27;
A4: 1 <= n by A2,FINSEQ_3:27;
  then reconsider naa1 = n-1 as odd Element of NAT by INT_1:18;
  take naa1;
  thus naa1 = n-1;
  1 < n by A4,JORDAN12:3,XXREAL_0:1;
  then 1+1 <= n by NAT_1:13;
  then 1+1-1 <= n-1 by XREAL_1:15;
  then
A5: 1 <= naa1;
  n - 1 <= len W - 0 by A3,XREAL_1:15;
  hence n - 1 in dom W by A5,FINSEQ_3:27;
  n < len W by A3,XXREAL_0:1;
  then n+1 <= len W by NAT_1:13;
  hence n+1 in dom W by A1,FINSEQ_3:27;
  n - 1 < len W - 0 by A3,XREAL_1:17;
  then W.(naa1+1) Joins W.naa1, W.(naa1+2),G by Def3;
  hence thesis;
end;

Lm3: for G be _Graph, W be Walk of G, n being odd Element of NAT st n < len W
holds n in dom W & n+1 in dom W & n+2 in dom W
proof
  let G be _Graph, W be Walk of G, n be odd Element of NAT;
A1: 1 <= n by ABIAN:12;
A2: 1 <= n+1 by NAT_1:12;
A3: 1 <= n+2 by NAT_1:12;
  assume
A4: n < len W;
  then
A5: n+1 <= len W by NAT_1:13;
  n+2 <= len W by A4,Th1;
  hence thesis by A4,A1,A2,A3,A5,FINSEQ_3:27;
end;

Lm4: for G being _Graph, v being Vertex of G holds G.walkOf(v) is closed & G
.walkOf(v) is directed & G.walkOf(v) is trivial & G.walkOf(v) is Trail-like & G
.walkOf(v) is Path-like
proof
  let G be _Graph, v be Vertex of G;
  set W = G.walkOf(v);
  W.first() = W.last() by FINSEQ_1:57;
  hence W is closed by Def24;
  now
    let n be odd Element of NAT;
    assume n < len W;
    then n < 1 by FINSEQ_1:56;
    hence W.n = (the_Source_of G).(W.(n+1)) by ABIAN:12;
  end;
  hence W is directed by Def25;
  len W = 1 by FINSEQ_1:56;
  then 0 + 1 = 2*len W.edgeSeq() + 1 by Def15;
  then W.length() = 0;
  hence W is trivial by Def26;
  len W = 2*(len (W.edgeSeq()))+1 by Def15;
  then 0 + 1 = 2 * (len (W.edgeSeq())) + 1 by FINSEQ_1:57;
  then W.edgeSeq() = {};
  hence
A1: W is Trail-like by Def27;
  now
    let n, m be odd Element of NAT;
    assume that
A2: n < m and
A3: m <= len W;
    m <= 1 by A3,FINSEQ_1:57;
    then n < 1 by A2,XXREAL_0:2;
    hence W.n = W.m implies n = 1 & m = len W by ABIAN:12;
  end;
  hence thesis by A1,Def28;
end;

Lm5: for G be _Graph, x,e,y be set holds e Joins x,y,G implies len G.walkOf(x,
e,y) = 3
proof
  let G be _Graph, x,e,y be set;
  assume e Joins x,y,G;
  then G.walkOf(x,e,y) = <*x,e,y*> by Def5;
  hence thesis by FINSEQ_1:62;
end;

Lm6: for G being _Graph, x,e,y being set holds e Joins x,y,G implies G.walkOf(
x,e,y).first() = x & G.walkOf(x,e,y).last() = y & G.walkOf(x,e,y) is_Walk_from
x,y
proof
  let G be _Graph, x,e,y be set;
  set W = G.walkOf(x,e,y);
  assume e Joins x,y,G;
  then
A1: W = <*x,e,y*> by Def5;
  hence
A2: W.first() = x by FINSEQ_1:62;
  len W = 3 by A1,FINSEQ_1:62;
  hence W.last() = y by A1,FINSEQ_1:62;
  hence thesis by A2,Def23;
end;

Lm7: for G be _Graph, W be Walk of G holds W.first() = W.reverse().last() & W
.last() = W.reverse().first()
proof
  let G be _Graph, W be Walk of G;
  len W = len W.reverse() by FINSEQ_5:def 3;
  hence W.first() = W.reverse().last() by FINSEQ_5:65;
  thus thesis by FINSEQ_5:65;
end;

Lm8: for G being _Graph, W being Walk of G, n being Element of NAT holds n in
dom W.reverse() implies W.reverse().n = W.(len W - n + 1) & (len W - n + 1) in
dom W
proof
  let G be _Graph, W be Walk of G, n be Element of NAT;
  assume
A1: n in dom W.reverse();
  hence W.reverse().n = W.(len W - n + 1) by FINSEQ_5:def 3;
  n in Seg len W.reverse() by A1,FINSEQ_1:def 3;
  then n in Seg len W by FINSEQ_5:def 3;
  then len W - n + 1 in Seg len W by FINSEQ_5:2;
  hence thesis by FINSEQ_1:def 3;
end;

Lm9: for G being _Graph, W1,W2 being Walk of G holds W1.last() = W2.first()
implies len W1.append(W2) + 1 = len W1 + len W2
proof
  let G be _Graph, W1,W2 be Walk of G;
  set W = W1.append(W2);
  assume W1.last() = W2.first();
  then W = W1 ^' W2 by Def10;
  hence thesis by CARD_1:47,GRAPH_2:13;
end;

Lm10: for G be _Graph, W1,W2 be Walk of G holds W1.last() = W2.first() implies
len W1 <= len W1.append(W2) & len W2 <= len W1.append(W2)
proof
  let G be _Graph, W1,W2 be Walk of G;
  set W = W1.append(W2);
  assume W1.last() = W2.first();
  then
A1: len W + 1 = len W1 + len W2 by Lm9;
  1 <= len W2 by ABIAN:12;
  then len W1 + len W2 - len W2 <= len W + 1 - 1 by A1,XREAL_1:15;
  hence len W1 <= len W;
  1 <= len W1 by ABIAN:12;
  then len W2 + len W1 - len W1 <= len W + 1 - 1 by A1,XREAL_1:15;
  hence thesis;
end;

Lm11: for G being _Graph, W1,W2 being Walk of G holds W1.last() = W2.first()
implies W1.append(W2).first() = W1.first() & W1.append(W2).last() = W2.last() &
W1.append(W2) is_Walk_from W1.first(), W2.last()
proof
  let G be _Graph, W1, W2 be Walk of G;
  set W = W1.append(W2);
  assume
A1: W1.last() = W2.first();
  then
A2: W = W1 ^' W2 by Def10;
  1 <= len W1 by ABIAN:12;
  hence
A3: W.first() = W1.first() by A2,GRAPH_2:14;
  now
    per cases;
    suppose
A4:   len W2 <> 1;
      1 <= len W2 by ABIAN:12;
      then 1 < len W2 by A4,XXREAL_0:1;
      hence W.last() = W2.last() by A2,GRAPH_2:16;
    end;
    suppose
A5:   len W2 = 1;
A6:   (2,1)-cut W2 = {} by GRAPH_2:def 1;
      W = W1^(2,1)-cut W2 by A2,A5,GRAPH_2:def 2;
      hence W.last() = W2.last() by A1,A5,A6,FINSEQ_1:47;
    end;
  end;
  hence thesis by A3,Def23;
end;

Lm12: for G be _Graph, W1,W2 be Walk of G, n being Element of NAT holds n in
dom W1 implies W1.append(W2).n = W1.n & n in dom W1.append(W2)
proof
  let G be _Graph, W1,W2 be Walk of G, n be Element of NAT;
  set W = W1.append(W2);
  assume
A1: n in dom W1;
  then
A2: n <= len W1 by FINSEQ_3:27;
A3: 1 <= n by A1,FINSEQ_3:27;
  now
    per cases;
    suppose
A4:   W1.last() = W2.first();
      then W = W1 ^' W2 by Def10;
      hence W.n = W1.n by A3,A2,GRAPH_2:14;
      reconsider lenW2aa1 = len W2 - 1 as Element of NAT by ABIAN:12,INT_1:18;
      n <= len W1 + lenW2aa1 by A2,NAT_1:12;
      then n <= len W1 + len W2 + -1;
      then n <= len W + 1 + -1 by A4,Lm9;
      hence n in dom W by A3,FINSEQ_3:27;
    end;
    suppose
      W1.last() <> W2.first();
      hence thesis by A1,Def10;
    end;
  end;
  hence thesis;
end;

Lm13: for G be _Graph, W1,W2 be Walk of G holds W1.last() = W2.first() implies
for n being Element of NAT st n < len W2 holds W1.append(W2).(len W1 + n) = W2.
(n+1) & (len W1 + n) in dom W1.append(W2)
proof
  let G be _Graph, W1,W2 be Walk of G;
  set W = W1.append(W2);
  assume
A1: W1.last() = W2.first();
  let n be Element of NAT;
  assume
A2: n < len W2;
  then n + 1 <= len W2 by NAT_1:13;
  then n + 1 + len W1 <= len W2 + len W1 by XREAL_1:9;
  then len W1 + n + 1 <= len W + 1 by A1,Lm9;
  then
A3: len W1 + n <= len W by XREAL_1:8;
A4: W = W1 ^' W2 by A1,Def10;
  now
    per cases;
    suppose
A5:   n = 0;
      then 1 <= len W1 + n by ABIAN:12;
      then len W1 + n in dom W1 by A5,FINSEQ_3:27;
      hence W1.append(W2).(len W1 + n) = W2.(n + 1) by A1,A5,Lm12;
    end;
    suppose
      n <> 0;
      then 0 + 1 < n + 1 by XREAL_1:10;
      then 1 <= n by NAT_1:13;
      hence W1.append(W2).(len W1 + n) = W2.(n+1) by A4,A2,GRAPH_2:15;
    end;
  end;
  hence W1.append(W2).(len W1 + n) = W2.(n+1);
  1 <= len W1 + n by ABIAN:12,NAT_1:12;
  hence thesis by A3,FINSEQ_3:27;
end;

Lm14: for G be _Graph, W1,W2 be Walk of G, n be Element of NAT holds n in dom
W1.append(W2) implies n in dom W1 or ex k being Element of NAT st k < len W2 &
n = len W1 + k
proof
  let G be _Graph, W1,W2 be Walk of G, n be Element of NAT;
  set W3 = W1.append(W2);
  assume
A1: n in dom W3;
  then
A2: n <= len W3 by FINSEQ_3:27;
A3: 1 <= n by A1,FINSEQ_3:27;
  now
    per cases;
    suppose
      W1.last() = W2.first();
      then
A4:   len W3 + 1 = len W1 + len W2 by Lm9;
      now
        assume not n in dom W1;
        then len W1 < n by A3,FINSEQ_3:27;
        then reconsider k = n - len W1 as Element of NAT by INT_1:18;
        take k;
        now
          assume len W2 <= k;
          then len W1 + len W2 <= len W1 + k by XREAL_1:9;
          hence contradiction by A2,A4,NAT_1:13;
        end;
        hence k < len W2;
        thus n = len W1+k;
      end;
      hence thesis;
    end;
    suppose
      W1.last() <> W2.first();
      hence thesis by A1,Def10;
    end;
  end;
  hence thesis;
end;

Lm15: for G being _Graph, W being Walk of G, m,n being odd Element of NAT st m
<= n & n <= len W holds len W.cut(m,n) + m = n+1 & for i being Element of NAT
st i < len W.cut(m,n) holds W.cut(m,n).(i+1) = W.(m+i) & m+i in dom W
proof
  let G be _Graph, W be Walk of G, m, n be odd Element of NAT;
  set W2 = W.cut(m,n);
  assume that
A1: m <= n and
A2: n <= len W;
A3: 1 <= m by ABIAN:12;
A4: W2 = (m,n)-cut W by A1,A2,Def11;
  hence
A5: len W.cut(m,n) + m = n + 1 by A1,A2,A3,GRAPH_2:def 1;
  let i be Element of NAT;
  assume
A6: i < len W.cut(m,n);
  hence W.cut(m,n).(i+1) = W.(m+i) by A1,A2,A4,A3,GRAPH_2:def 1;
  m+i < n + 1 by A5,A6,XREAL_1:10;
  then m+i <= n by NAT_1:13;
  then
A7: m+i <= len W by A2,XXREAL_0:2;
  1 <= m+i by ABIAN:12,NAT_1:12;
  hence thesis by A7,FINSEQ_3:27;
end;

Lm16: for G being _Graph, W being Walk of G, m, n being odd Element of NAT st
m <= n & n <= len W holds W.cut(m,n).first() = W.m & W.cut(m,n).last() = W.n &
W.cut(m,n) is_Walk_from W.m, W.n
proof
  let G be _Graph, W be Walk of G, m, n be odd Element of NAT;
  set W2 = W.cut(m,n);
  assume that
A1: m <= n and
A2: n <= len W;
  1-1 < len W2 - 0;
  then W2.(0+1) = W.(m+0) by A1,A2,Lm15;
  hence
A3: W2.first() = W.m;
  reconsider nm4 = n-m as Element of NAT by A1,INT_1:18;
A4: len W2 + m - m = n + 1 - m by A1,A2,Lm15;
  then n - m + 1 -1 < len W2 - 0 by XREAL_1:17;
  then nm4 < len W2;
  then W2.((n-m)+1) = W.(m+(n-m)) by A1,A2,Lm15;
  hence W2.last() = W.n by A4;
  hence thesis by A3,Def23;
end;

Lm17: for G be _Graph, W be Walk of G, m,n,o being odd Element of NAT st m <=
n & n <= o & o <= len W holds W.cut(m,n).append(W.cut(n,o)) = W.cut(m,o)
proof
  let G be _Graph, W be Walk of G, m,n,o be odd Element of NAT;
  assume that
A1: m <= n and
A2: n <= o and
A3: o <= len W;
  set W1 = W.cut(m,n), W2 = W.cut(n,o), W3 = W.cut(m,o), W4 = W1.append(W2);
A4: n <= len W by A2,A3,XXREAL_0:2;
A5: m <= o by A1,A2,XXREAL_0:2;
  now
A6: len W3 + m = o + 1 by A3,A5,Lm15;
A7: W1.last() = W.n by A1,A4,Lm16
      .= W2.first() by A2,A3,Lm16;
A8: len W1 + m = n + 1 by A1,A4,Lm15;
A9: len W2 + n = o + 1 by A2,A3,Lm15;
    then len W1 + len W2 + m = 1 + len W3 + m by A8,A6;
    then
A10: len W4 + 1 = len W3 + 1 by A7,Lm9;
    hence len W4 = len W4 & len W3 = len W4;
    let x be Nat;
    assume
A11: x in dom W4;
    then
A12: 1 <= x by FINSEQ_3:27;
    then reconsider xaa1 = x-1 as Element of NAT by INT_1:18;
A13: x <= len W4 by A11,FINSEQ_3:27;
    then xaa1 < len W4 - 0 by XREAL_1:17;
    then
A14: W3.(xaa1+1) = W.(m+xaa1) by A3,A5,A10,Lm15;
    now
      per cases;
      suppose
A15:    x <= len W1;
        then
A16:    xaa1 < len W1 - 0 by XREAL_1:17;
        x in dom W1 by A12,A15,FINSEQ_3:27;
        hence W4.x = W1.(xaa1+1) by Lm12
          .= W3.x by A1,A4,A14,A16,Lm15;
      end;
      suppose
        x > len W1;
        then consider k being Nat such that
A17:    len W1 + k = x by NAT_1:10;
        reconsider k as Element of NAT by ORDINAL1:def 13;
        len W1 + k + 1 <= len W3 + 1 by A10,A13,A17,XREAL_1:9;
        then (k + 1)+len W1-len W1 <= len W2 +len W1-len W1 by A8,A9,A6,
XREAL_1:15;
        then
A18:    k + 1 - 1 < len W2 + 1 - 1 by NAT_1:13;
        then W4.x = W2.(k+1) by A7,A17,Lm13
          .= W.(n+k) by A2,A3,A18,Lm15;
        hence W4.x = W3.x by A8,A14,A17;
      end;
    end;
    hence W4.x = W3.x;
  end;
  hence thesis by FINSEQ_2:10;
end;

Lm18: for G be _Graph, W be Walk of G holds W.cut(1,len W) = W
proof
  let G be _Graph, W be Walk of G;
  1 <= len W by ABIAN:12;
  then W.cut(1,len W) = (1,len W)-cut W by Def11,JORDAN12:3;
  hence thesis by GRAPH_2:7;
end;

Lm19: for G be _Graph, W be Walk of G, n being odd Element of NAT st n <= len
W holds W.cut(n,n) = <* W.vertexAt(n) *>
proof
  let G be _Graph, W be Walk of G, n be odd Element of NAT;
A1: 1 <= n by ABIAN:12;
  assume
A2: n <= len W;
  then
A3: W.n = W.vertexAt(n) by Def8;
  W.cut(n,n) = (n,n)-cut W by A2,Def11;
  hence thesis by A2,A3,A1,GRAPH_2:6;
end;

Lm20: for G being _Graph, W being Walk of G, m,n being Element of NAT holds m
is odd & m <= n implies W.cut(1,n).cut(1,m) = W.cut(1,m)
proof
  let G be _Graph, W be Walk of G, m,n be Element of NAT;
  set W1 = W.cut(1,n);
  assume that
A1: m is odd and
A2: m <= n;
  now
    per cases;
    suppose
A3:   n is odd & n <= len W;
A4:   1 <= m by A1,ABIAN:12;
A5:   1 <= n by A3,ABIAN:12;
      then
A6:   len W1 + 1 = n + 1 by A3,Lm15,JORDAN12:3;
      then
A7:   len W1.cut(1,m) + 1 = m + 1 by A1,A2,A4,Lm15,JORDAN12:3;
A8:   m <= len W by A2,A3,XXREAL_0:2;
      then
A9:   W.cut(1,m) = (1,m)-cut W by A1,A4,Def11,JORDAN12:3;
A10:  len W.cut(1,m) + 1 = m + 1 by A1,A4,A8,Lm15,JORDAN12:3;
A11:  W1 = (1,n)-cut W by A3,A5,Def11,JORDAN12:3;
A12:  W1.cut(1,m) = (1,m)-cut W1 by A1,A2,A4,A6,Def11,JORDAN12:3;
A13:  now
        let x be Nat;
        assume
A14:    x in dom W1.cut(1,m);
        then
A15:    x <= m by A7,FINSEQ_3:27;
A16:    1 <= x by A14,FINSEQ_3:27;
        then reconsider xaa1 = x-1 as Element of NAT by INT_1:18;
A17:    1 <= m by A16,A15,XXREAL_0:2;
A18:    xaa1 < len W.cut(1,m) - 0 by A10,A15,XREAL_1:17;
        x <= n by A2,A15,XXREAL_0:2;
        then
A19:    xaa1 < len W1 - 0 by A6,XREAL_1:17;
        xaa1 < len W1.cut(1,m) - 0 by A7,A15,XREAL_1:17;
        hence W1.cut(1,m).x = W1.(1+xaa1) by A2,A6,A12,A17,GRAPH_2:def 1
          .= W.(1+xaa1) by A3,A5,A11,A19,GRAPH_2:def 1
          .= W.cut(1,m).x by A4,A8,A9,A18,GRAPH_2:def 1;
      end;
      len W.cut(1,m) + 1 = m + 1 by A1,A4,A8,Lm15,JORDAN12:3;
      hence thesis by A7,A13,FINSEQ_2:10;
    end;
    suppose
      not (n is odd & n <= len W);
      hence thesis by Def11;
    end;
  end;
  hence thesis;
end;

Lm21: for G be _Graph, W1,W2 be Walk of G, m,n being odd Element of NAT st m
<= n & n <= len W1 & W1.last() = W2.first() holds W1.append(W2).cut(m,n) = W1
.cut(m,n)
proof
  let G be _Graph, W1,W2 be Walk of G, m,n be odd Element of NAT;
  assume that
A1: m <= n and
A2: n <= len W1 and
A3: W1.last() = W2.first();
A4: W1.cut(m,n) = (m,n)-cut W1 by A1,A2,Def11;
  set W3 = W1.append(W2);
  len W1 <= len W3 by A3,Lm10;
  then
A5: n <= len W3 by A2,XXREAL_0:2;
  then
A6: len W3.cut(m,n) + m = n + 1 by A1,Lm15
    .= len W1.cut(m,n) + m by A1,A2,Lm15;
A7: 1 <= m by ABIAN:12;
A8: W3.cut(m,n) = (m,n)-cut W3 by A1,A5,Def11;
  now
    let x be Nat;
    assume
A9: x in dom W1.cut(m,n);
    then 1 <= x by FINSEQ_3:27;
    then reconsider xaa1 = x-1 as Element of NAT by INT_1:18;
A10: x <= len W1.cut(m,n) by A9,FINSEQ_3:27;
    then
A11: xaa1 < len W1.cut(m,n) - 0 by XREAL_1:17;
    len W1.cut(m,n) + m = n + 1 by A1,A2,Lm15;
    then m + xaa1 < n + 1 by A11,XREAL_1:10;
    then m + xaa1 <= n by NAT_1:13;
    then
A12: m+xaa1 <= len W1 by A2,XXREAL_0:2;
    1 <= m+xaa1 by ABIAN:12,NAT_1:12;
    then
A13: m+xaa1 in dom W1 by A12,FINSEQ_3:27;
A14: xaa1 + 1 = x;
    xaa1 < len W3.cut(m,n) - 0 by A6,A10,XREAL_1:17;
    then
A15: W3.cut(m,n).x = W3.(m+xaa1) by A1,A5,A8,A7,A14,GRAPH_2:def 1;
    W1.cut(m,n).x = W1.(m+xaa1) by A1,A2,A4,A7,A14,A11,GRAPH_2:def 1;
    hence W3.cut(m,n).x = W1.cut(m,n).x by A15,A13,Lm12;
  end;
  hence thesis by A6,FINSEQ_2:10;
end;

Lm22: for G being _Graph, W being Walk of G, m being odd Element of NAT st m
<= len W holds len W.cut(1,m) = m
proof
  let G be _Graph, W be Walk of G, m be odd Element of NAT;
A1: 1 <= m by ABIAN:12;
  assume m <= len W;
  then len W.cut(1,m) + 1 = m + 1 by A1,Lm15,JORDAN12:3;
  hence thesis;
end;

Lm23: for G be _Graph, W be Walk of G, m be odd Element of NAT, x be Element
of NAT st x in dom W.cut(1,m) & m <= len W holds W.cut(1,m).x = W.x
proof
  let G be _Graph, W be Walk of G, m be odd Element of NAT, x be Element of
  NAT;
  assume that
A1: x in dom W.cut(1,m) and
A2: m <= len W;
  x <= len W.cut(1,m) by A1,FINSEQ_3:27;
  then
A3: x-1 < len W.cut(1,m) - 0 by XREAL_1:17;
  1 <= x by A1,FINSEQ_3:27;
  then reconsider xaa1 = x-1 as Element of NAT by INT_1:18;
A4: 1 <= m by ABIAN:12;
  xaa1 + 1 = x;
  hence thesis by A2,A4,A3,Lm15,JORDAN12:3;
end;

Lm24: for G be _Graph, W be Walk of G, m,n be odd Element of NAT st m <= n & n
<= len W & W.m = W.n holds len W.remove(m,n) + n = len W + m
proof
  let G be _Graph, W be Walk of G, m, n be odd Element of NAT;
  set W1 = W.cut(1,m), W2 = W.cut(n,len W);
  assume that
A1: m <= n and
A2: n <= len W and
A3: W.m = W.n;
A4: W.remove(m,n) = W1.append(W2) by A1,A2,A3,Def12;
A5: len W2 + n = len W + 1 by A2,Lm15;
A6: W.n = W2.first() by A2,Lm16;
A7: 1 <= m by ABIAN:12;
A8: m <= len W by A1,A2,XXREAL_0:2;
  then
A9: len W1 + 1 = m + 1 by A7,Lm15,JORDAN12:3;
  W1.last() = W.n by A3,A7,A8,Lm16,JORDAN12:3;
  then len W1.append(W2) + 1 = m + (len W + 1 + -n) by A6,A9,A5,Lm9
    .= len W + m + -n + 1;
  hence thesis by A4;
end;

Lm25: for G be _Graph, W be Walk of G, m,n be Element of NAT, x,y be set holds
W is_Walk_from x,y implies W.remove(m,n) is_Walk_from x,y
proof
  let G be _Graph, W be Walk of G, m,n be Element of NAT, x,y be set;
  set W2 = W.remove(m,n), WA = W.cut(1,m), WB = W.cut(n,len W);
  assume
A1: W is_Walk_from x,y;
  now
    per cases;
    suppose
A2:   m is odd & n is odd & m <= n & n <= len W & W.m = W.n;
      then
A3:   WB.last() = W.last() by Lm16
        .= y by A1,Def23;
A4:   W2 = WA.append(WB) by A2,Def12;
A5:   m <= len W by A2,XXREAL_0:2;
A6:   1 <= m by A2,ABIAN:12;
      then
A7:   WA.first() = W.first() by A2,A5,Lm16,JORDAN12:3
        .= x by A1,Def23;
      WA.last() = W.n by A2,A6,A5,Lm16,JORDAN12:3
        .= WB.first() by A2,Lm16;
      hence thesis by A4,A7,A3,Lm11;
    end;
    suppose
      not (m is odd & n is odd & m <= n & n <= len W & W.m = W.n);
      hence thesis by A1,Def12;
    end;
  end;
  hence thesis;
end;

Lm26: for G being _Graph, W being Walk of G, m,n be Element of NAT holds len W
.remove(m,n) <= len W
proof
  let G be _Graph, W be Walk of G, m,n be Element of NAT;
  set W2 = W.remove(m,n);
  now
    per cases;
    suppose
A1:   m is odd & n is odd & m <= n & n <= len W & W.m = W.n;
      then len W2 + n = len W + m by Lm24;
      then len W2 + n - n <= len W + m - m by A1,XREAL_1:15;
      hence thesis;
    end;
    suppose
      not (m is odd & n is odd & m <= n & n <= len W & W.m = W.n);
      hence thesis by Def12;
    end;
  end;
  hence thesis;
end;

Lm27: for G be _Graph, W be Walk of G, m be Element of NAT holds W.remove(m,m)
= W
proof
  let G be _Graph, W be Walk of G, m be Element of NAT;
  now
    per cases;
    suppose
A1:   m is odd & m <= len W & W.m = W.m;
      then
A2:   1 <= m by ABIAN:12;
      thus W.remove(m,m) = W.cut(1,m).append(W.cut(m,len W)) by A1,Def12
        .= W.cut(1,len W) by A1,A2,Lm17,JORDAN12:3
        .= W by Lm18;
    end;
    suppose
      not (m is odd & m <= len W & W.m = W.m);
      hence thesis by Def12;
    end;
  end;
  hence thesis;
end;

Lm28: for G being _Graph, W being Walk of G, m,n be odd Element of NAT st m <=
n & n <= len W & W.m = W.n holds W.cut(1,m).last() = W.cut(n,len W).first()
proof
  let G be _Graph, W be Walk of G, m,n be odd Element of NAT;
  assume that
A1: m <= n and
A2: n <= len W and
A3: W.m = W.n;
A4: 1 <= m by ABIAN:12;
  m <= len W by A1,A2,XXREAL_0:2;
  hence W.cut(1,m).last() = W.n by A3,A4,Lm16,JORDAN12:3
    .= W.cut(n,len W).first() by A2,Lm16;
end;

Lm29: for G be _Graph, W be Walk of G, x,y be set, m,n being odd Element of
NAT st m <= n & n <= len W & W.m = W.n holds for x being Element of NAT st x in
Seg m holds W.remove(m,n).x = W.x
proof
  let G be _Graph, W be Walk of G, x,y be set, m, n be odd Element of NAT;
  set W2 = W.remove(m,n);
  assume that
A1: m <= n and
A2: n <= len W and
A3: W.m = W.n;
  let x be Element of NAT;
  assume
A4: x in Seg m;
  then x <= m by FINSEQ_1:3;
  then
A5: x <= len W.cut(1,m) by A1,A2,Lm22,XXREAL_0:2;
  1 <= x by A4,FINSEQ_1:3;
  then
A6: x in dom W.cut(1,m) by A5,FINSEQ_3:27;
  W2 = W.cut(1,m).append(W.cut(n,len W)) by A1,A2,A3,Def12;
  hence W2.x = W.cut(1,m).x by A6,Lm12
    .= W.x by A1,A2,A6,Lm23,XXREAL_0:2;
end;

Lm30: for G be _Graph, W be Walk of G, m,n being odd Element of NAT st m <= n
& n <= len W & W.m = W.n holds for x being Element of NAT st m <= x & x <= len
W.remove(m,n) holds W.remove(m,n).x = W.(x - m + n) & x - m + n is Element of
NAT & x - m + n <= len W
proof
  let G be _Graph, W be Walk of G, m, n be odd Element of NAT;
  set W2 = W.remove(m,n), WA = W.cut(1,m), WB = W.cut(n,len W);
  assume that
A1: m <= n and
A2: n <= len W and
A3: W.m = W.n;
A4: WA.last() = WB.first() by A1,A2,A3,Lm28;
  let x be Element of NAT;
  assume that
A5: m <= x and
A6: x <= len W2;
A7: len WA = m by A1,A2,Lm22,XXREAL_0:2;
  then consider a being Nat such that
A8: len WA + a = x by A5,NAT_1:10;
  reconsider a as Element of NAT by ORDINAL1:def 13;
  len W2 + n = len W + m by A1,A2,A3,Lm24;
  then m + a + n <= m + len W by A7,A6,A8,XREAL_1:9;
  then
A9: a+n + m - m <= len W + m - m by XREAL_1:15;
  len WB + n = len W + 1 by A2,Lm15;
  then a + n + 1 <= len WB + n by A9,XREAL_1:9;
  then a + 1 + n - n <= len WB + n - n by XREAL_1:15;
  then
A10: a + 1 - 1 < len WB + 1 - 1 by NAT_1:13;
  W2 = WA.append(WB) by A1,A2,A3,Def12;
  then W2.x = WB.(a+1) by A4,A8,A10,Lm13
    .= W.(a + n) by A2,A10,Lm15;
  hence W2.x = W.(x - m + n) by A7,A8;
  a + n is Element of NAT;
  hence x-m+n is Element of NAT by A7,A8;
  thus thesis by A7,A8,A9;
end;

Lm31: for G be _Graph, W be Walk of G, m,n be odd Element of NAT st m <= n & n
<= len W & W.m = W.n holds len W.remove(m,n) = len W + m - n
proof
  let G be _Graph, W be Walk of G, m,n be odd Element of NAT;
  assume that
A1: m <= n and
A2: n <= len W and
A3: W.m = W.n;
  len W.remove(m,n) + n = len W + m by A1,A2,A3,Lm24;
  hence thesis;
end;

Lm32: for G be _Graph, W be Walk of G, m being Element of NAT st W.first() = W
.m holds W.remove(1,m) = W.cut(m, len W)
proof
  let G be _Graph, W be Walk of G, m be Element of NAT;
  assume
A1: W.first() = W.m;
  now
    per cases;
    suppose
A2:   m is odd & m <= len W;
      then 1 <= m by ABIAN:12;
      then
A3:   W.remove(1,m) = W.cut(1,1).append(W.cut(m, len W)) by A1,A2,Def12,
JORDAN12:3;
A4:   1 <= len W by ABIAN:12;
      then
A5:   W.cut(1,1).last() = W.m by A1,Lm16,JORDAN12:3
        .= W.cut(m, len W).first() by A2,Lm16;
A6:   now
        let n be Nat;
        assume that
A7:     1 <= n and
A8:     n <= len W.remove(1,m);
A9:     n in dom W.remove(1,m) by A7,A8,FINSEQ_3:27;
        now
          per cases by A3,A9,Lm14;
          suppose
A10:        n in dom W.cut(1,1);
            then n <= len W.cut(1,1) by FINSEQ_3:27;
            then
A11:        n <= 1 by A4,Lm22,JORDAN12:3;
A12:        1 <= n by A10,FINSEQ_3:27;
            then
A13:        n = 1 by A11,XXREAL_0:1;
            W.remove(1,m).n = W.cut(1,1).n by A3,A10,Lm12
              .= <* W.vertexAt(1) *>.1 by A4,A13,Lm19,JORDAN12:3
              .= W.vertexAt(1) by FINSEQ_1:def 8
              .= W.m by A1,A4,Def8,JORDAN12:3
              .= W.cut(m, len W).first() by A2,Lm16
              .= W.cut(m, len W).1;
            hence W.remove(1,m).n = W.cut(m, len W).n by A12,A11,XXREAL_0:1;
          end;
          suppose
            ex k being Element of NAT st k < len W.cut(m, len W) & n
            = len W.cut(1,1) + k;
            then consider k being Element of NAT such that
A14:        k < len W.cut(m, len W) and
A15:        n = len W.cut(1,1) + k;
            n = k + 1 by A14,A15,Lm22,ABIAN:12,JORDAN12:3;
            hence W.remove(1,m).n = W.cut(m, len W).n by A3,A5,A14,A15,Lm13;
          end;
        end;
        hence W.remove(1,m).n = W.cut(m, len W).n;
      end;
      len W.remove(1,m) + 1 = len W.cut(1,1) + len W.cut(m, len W) by A3,A5,Lm9
;
      then len W.remove(1,m) + 1 = len W.cut(m, len W) + 1 by Lm22,ABIAN:12
,JORDAN12:3;
      hence thesis by A6,FINSEQ_1:18;
    end;
    suppose
A16:  not (m is odd & m <= len W);
      then W.cut(m, len W) = W by Def11;
      hence thesis by A16,Def12;
    end;
  end;
  hence thesis;
end;

Lm33: for G be _Graph, W be Walk of G, m,n be Element of NAT holds W.remove(m,
n).first() = W.first() & W.remove(m,n).last() = W.last()
proof
  let G be _Graph, W be Walk of G, m,n be Element of NAT;
  W is_Walk_from W.first(), W.last() by Def23;
  then W.remove(m,n) is_Walk_from W.first(), W.last() by Lm25;
  hence thesis by Def23;
end;

Lm34: for G be _Graph, W be Walk of G, m,n being odd Element of NAT, x being
Element of NAT st x in dom W.remove(m,n) holds x in Seg m or m <= x & x <= len
W.remove(m,n)
proof
  let G be _Graph, W be Walk of G, m,n be odd Element of NAT, x be Element of
  NAT;
  assume that
A1: x in dom W.remove(m,n);
  1 <= x by A1,FINSEQ_3:27;
  hence thesis by A1,FINSEQ_1:3,FINSEQ_3:27;
end;

Lm35: for G be _Graph, W be Walk of G, e,x be set holds e Joins W.last(), x, G
implies W.addEdge(e) = W^<*e,x*>
proof
  let G be _Graph, W be Walk of G, e,x be set;
  set W1 = G.walkOf(W.last(), e, W.last().adj(e));
  assume
A1: e Joins W.last(), x, G;
  then reconsider x9=x as Vertex of G by GLIB_000:16;
A2: W.last().adj(e) = x9 by A1,GLIB_000:69;
  then
A3: W1 = <*W.last(), e, x*> by A1,Def5;
  then
A4: len W1 = 3 by FINSEQ_1:62;
A5: W1.3 = x by A3,FINSEQ_1:62;
  W1.2 = e by A3,FINSEQ_1:62;
  then (2,2)-cut W1 = <*e*> by A4,GRAPH_2:6;
  then <*e*> ^ (2+1,3)-cut W1 = (1+1,3)-cut W1 by A4,GRAPH_2:8;
  then
A6: <*e*> ^ <*x*> = (2,3)-cut W1 by A4,A5,GRAPH_2:6;
  W.last() = W1.first() by A1,A2,Lm6;
  then W.append(W1) = W ^' W1 by Def10
    .= W ^ (2,len W1)-cut W1 by GRAPH_2:def 2
    .= W ^ (2,3)-cut W1 by A3,FINSEQ_1:62;
  hence thesis by A6,FINSEQ_1:def 9;
end;

Lm36: for G be _Graph, W be Walk of G, e,x be set holds e Joins W.last(),x,G
implies W.addEdge(e).first() = W.first() & W.addEdge(e).last() = x & W.addEdge(
e) is_Walk_from W.first(), x
proof
  let G be _Graph, W be Walk of G, e,x be set;
  set W2 = G.walkOf(W.last(), e, W.last().adj(e));
  assume
A1: e Joins W.last(), x, G;
  then reconsider x9=x as Vertex of G by GLIB_000:16;
A2: W.last().adj(e) = x9 by A1,GLIB_000:69;
  then
A3: W2.last() = x by A1,Lm6;
  W2.first() = W.last() by A1,A2,Lm6;
  hence thesis by A3,Lm11;
end;

Lm37: for G be _Graph, W be Walk of G, e,x be set holds e Joins W.last(),x,G
implies len W.addEdge(e) = len W + 2
proof
  let G be _Graph, W be Walk of G, e,x be set;
  set W2 = G.walkOf(W.last(),e, W.last().adj(e));
  assume
A1: e Joins W.last(), x, G;
  then reconsider x9=x as Vertex of G by GLIB_000:16;
A2: W.last().adj(e) = x9 by A1,GLIB_000:69;
  then W2.first() = W.last() by A1,Lm6;
  then
A3: len W.addEdge(e) + 1 = len W + len W2 by Lm9;
  W2 = <*W.last(), e, x*> by A1,A2,Def5;
  then len W.addEdge(e) + 1 = len W + 3 by A3,FINSEQ_1:62;
  hence thesis;
end;

Lm38: for G be _Graph, W be Walk of G, e,x be set holds e Joins W.last(),x,G
implies W.addEdge(e).(len W + 1) = e & W.addEdge(e).(len W + 2) = x & for n
being Element of NAT st n in dom W holds W.addEdge(e).n = W.n
proof
  let G be _Graph, W be Walk of G, e,x be set;
  set W2 = W.addEdge(e);
A1: <*e,x*>.1 = e by FINSEQ_1:61;
  assume e Joins W.last(), x, G;
  then
A2: W2 = W^<*e,x*> by Lm35;
A3: dom <*e,x*> = Seg 2 by FINSEQ_3:29;
  then 1 in dom <*e,x*> by FINSEQ_1:3;
  hence W2.(len W + 1) = e by A2,A1,FINSEQ_1:def 7;
A4: <*e,x*>.2 = x by FINSEQ_1:61;
  2 in dom <*e,x*> by A3,FINSEQ_1:3;
  hence W2.(len W + 2) = x by A2,A4,FINSEQ_1:def 7;
  let n be Element of NAT;
  assume n in dom W;
  hence thesis by A2,FINSEQ_1:def 7;
end;

Lm39: for G be _Graph, W be Walk of G, e,x,y,z be set holds W is_Walk_from x,y
& e Joins y,z,G implies W.addEdge(e) is_Walk_from x,z
proof
  let G be _Graph, W be Walk of G, e,x,y,z be set;
  assume that
A1: W is_Walk_from x,y and
A2: e Joins y,z,G;
A3: W.last() = y by A1,Def23;
  W.first() = x by A1,Def23;
  hence thesis by A2,A3,Lm36;
end;

Lm40: for G being _Graph, W being Walk of G, n being even Element of NAT st 1
<= n & n <= len W holds n div 2 in dom W.edgeSeq() & W.n = W.edgeSeq().(n div 2
)
proof
  let G be _Graph, W be Walk of G, n be even Element of NAT;
  assume that
A1: 1 <= n and
A2: n <= len W;
A3: 2 divides n by PEPIN:22;
  then
A4: n = 2 * (n div 2) by NAT_D:3;
A5: now
    assume
A6: not n div 2 in dom W.edgeSeq();
    now
      per cases by A6,FINSEQ_3:27;
      suppose
        n div 2 < 0+1;
        then n div 2 = 0 by NAT_1:13;
        then n = 2 * 0 by A3,NAT_D:3;
        hence contradiction by A1;
      end;
      suppose
        n div 2 > len W.edgeSeq();
        then 2 * (n div 2) > 2 * len W.edgeSeq() by XREAL_1:70;
        then n + 1 > 2 * len W.edgeSeq() + 1 by A4,XREAL_1:10;
        then n + 1 > len W by Def15;
        then n >= len W by NAT_1:13;
        hence contradiction by A2,XXREAL_0:1;
      end;
    end;
    hence contradiction;
  end;
  hence n div 2 in dom W.edgeSeq();
A7: n div 2 <= len W.edgeSeq() by A5,FINSEQ_3:27;
  1 <= n div 2 by A5,FINSEQ_3:27;
  hence thesis by A4,A7,Def15;
end;

Lm41: for G being _Graph, W being Walk of G, n being Element of NAT holds n in
dom W.edgeSeq() iff 2*n in dom W
proof
  let G be _Graph, W be Walk of G, n be Element of NAT;
  hereby
    assume
A1: n in dom W.edgeSeq();
    then n <= len W.edgeSeq() by FINSEQ_3:27;
    then 2*n <= len W.edgeSeq()*2 by NAT_1:4;
    then 2*n <= len W.edgeSeq()*2 + 1 by NAT_1:12;
    then
A2: 2*n <= len W by Def15;
    1 <= n by A1,FINSEQ_3:27;
    then 1 <= n + n by NAT_1:12;
    hence 2*n in dom W by A2,FINSEQ_3:27;
  end;
  assume
A3: 2*n in dom W;
  then
A4: 2*n <= len W by FINSEQ_3:27;
  1 <= 2*n by A3,FINSEQ_3:27;
  then 2*n div 2 in dom W.edgeSeq() by A4,Lm40;
  hence thesis by NAT_D:20;
end;

Lm42: for G be _Graph, W be Walk of G holds ex lenWaa1 being even Element of
NAT st lenWaa1 = len W - 1 & len W.edgeSeq() = lenWaa1 div 2
proof
  let G be _Graph, W be Walk of G;
  set lenWaa1 = len W - 1;
  reconsider lenWaa1 as even Element of NAT by ABIAN:12,INT_1:18;
  take lenWaa1;
  thus lenWaa1 = len W - 1;
  2 divides lenWaa1 by PEPIN:22;
  then
A1: lenWaa1 = 2 * (lenWaa1 div 2) by NAT_D:3;
  len W = 2*len W.edgeSeq()+1 by Def15;
  hence thesis by A1;
end;

Lm43: for G be _Graph, W be Walk of G, n be Element of NAT holds W.cut(1,n)
.edgeSeq() c= W.edgeSeq()
proof
  let G be _Graph, W be Walk of G, n be Element of NAT;
  per cases;
  suppose
A1: n is odd & 1 <= n & n <= len W;
    set f = W.cut(1,n).edgeSeq();
    now
      let e be set;
      assume
A2:   e in W.cut(1,n).edgeSeq();
      then consider x,y being set such that
A3:   e = [x,y] by RELAT_1:def 1;
A4:   y = f.x by A2,A3,FUNCT_1:8;
A5:   x in dom f by A2,A3,FUNCT_1:8;
      then reconsider x as Element of NAT;
A6:   x <= len f by A5,FINSEQ_3:27;
A7:   2*x in dom W.cut(1,n) by A5,Lm41;
      then 2*x <= len W.cut(1,n) by FINSEQ_3:27;
      then 2*x <= n by A1,Lm22;
      then
A8:   2*x <= len W by A1,XXREAL_0:2;
      1 <= 2*x by A7,FINSEQ_3:27;
      then 2*x in dom W by A8,FINSEQ_3:27;
      then
A9:   x in dom W.edgeSeq() by Lm41;
      then
A10:  x <= len W.edgeSeq() by FINSEQ_3:27;
      1 <= x by A5,FINSEQ_3:27;
      then y = W.cut(1,n).(2*x) by A4,A6,Def15;
      then
A11:  y = W.(2*x) by A1,A7,Lm23;
      1 <= x by A9,FINSEQ_3:27;
      then W.edgeSeq().x = y by A11,A10,Def15;
      hence e in W.edgeSeq() by A3,A9,FUNCT_1:8;
    end;
    hence thesis by TARSKI:def 3;
  end;
  suppose
    not (n is odd & 1 <= n & n <= len W);
    hence thesis by Def11;
  end;
end;

Lm44: for G be _Graph, W be Walk of G, e,x be set holds e Joins W.last(),x,G
implies W.addEdge(e).edgeSeq() = W.edgeSeq() ^ <*e*>
proof
  let G be _Graph, W be Walk of G, e,x be set;
  set W2 = W.addEdge(e), W3 = W.edgeSeq() ^ <*e*>;
  assume
A1: e Joins W.last(),x,G;
  then len W2 = len W + 2 by Lm37;
  then len W + 2 = 2 * len W2.edgeSeq() + 1 by Def15;
  then 2 + (2*len W.edgeSeq()+1) = 2*len W2.edgeSeq() + 1 by Def15;
  then
A2: 2*(len W.edgeSeq()+1) = 2*len W2.edgeSeq();
  len W3 = len W.edgeSeq() + len <*e*> by FINSEQ_1:35;
  then
A3: 2*len W3 = 2*len W2.edgeSeq() by A2,FINSEQ_1:56;
  now
    let k be Nat;
    assume that
A4: 1 <= k and
A5: k <= len W2.edgeSeq();
A6: W2.edgeSeq().k = W2.(2*k) by A4,A5,Def15;
A7: k in dom W3 by A3,A4,A5,FINSEQ_3:27;
    now
      per cases by A7,FINSEQ_1:38;
      suppose
A8:     k in dom W.edgeSeq();
        then
A9:     2*k in dom W by Lm41;
A10:    1 <= k by A8,FINSEQ_3:27;
A11:    k <= len W.edgeSeq() by A8,FINSEQ_3:27;
        W3.k = W.edgeSeq().k by A8,FINSEQ_1:def 7;
        then W3.k = W.(2*k) by A10,A11,Def15;
        hence W2.edgeSeq().k = W3.k by A1,A6,A9,Lm38;
      end;
      suppose
        ex n being Nat st n in dom <*e*> & k=len W.edgeSeq() + n;
        then consider n being Element of NAT such that
A12:    n in dom <*e*> and
A13:    k = len W.edgeSeq() + n;
        n in {1} by A12,FINSEQ_1:4,55;
        then
A14:    n = 1 by TARSKI:def 1;
        then
A15:    2*k = 2*len W.edgeSeq() + 1 + 1 by A13
          .= len W + 1 by Def15;
        W3.k = <*e*>.1 by A12,A13,A14,FINSEQ_1:def 7
          .= e by FINSEQ_1:def 8;
        hence W2.edgeSeq().k = W3.k by A1,A6,A15,Lm38;
      end;
    end;
    hence W2.edgeSeq().k = W3.k;
  end;
  hence thesis by A3,FINSEQ_1:18;
end;

Lm45: for G be _Graph, W be Walk of G, x be set holds x in W.vertices() iff ex
n being odd Element of NAT st n <= len W & W.n = x
proof
  let G be _Graph, W be Walk of G, x be set;
  set vs = W.vertexSeq();
  hereby
    assume x in W.vertices();
    then consider i being Nat such that
A1: i in dom vs and
A2: vs.i = x by FINSEQ_2:11;
    set n1 = 2*i;
    reconsider n1 as even Nat;
    set n = n1-1;
A3: 1 <= i by A1,FINSEQ_3:27;
    then 1 <= i+i by NAT_1:12;
    then reconsider n as odd Element of NAT by INT_1:18;
    take n;
A4: i <= len vs by A1,FINSEQ_3:27;
    then i*2 <= len vs *2 by XREAL_1:66;
    then i*2 <= len W + 1 by Def14;
    then n1 - 1 <= len W + 1 - 1 by XREAL_1:15;
    hence n <= len W;
    thus W.n = x by A2,A3,A4,Def14;
  end;
  assume ex n being odd Element of NAT st n <= len W & W.n = x;
  then consider n being odd Element of NAT such that
A5: n <= len W and
A6: W.n = x;
  set n1 = n+1;
  reconsider n1 as even Element of NAT;
  set i = n1 div 2;
A7: 2 divides n1 by PEPIN:22;
  then
A8: 2*i = n1 by NAT_D:3;
  reconsider i as Element of NAT;
  1 <= n by ABIAN:12;
  then 1+1 <= n1 by XREAL_1:9;
  then 2*1 <= 2*i by A7,NAT_D:3;
  then
A9: 1 <= i by XREAL_1:70;
  n1 <= len W + 1 by A5,XREAL_1:9;
  then 2*i <= 2*len vs by A8,Def14;
  then
A10: i <= len vs by XREAL_1:70;
  then
A11: i in dom vs by A9,FINSEQ_3:27;
  vs.i = W.(2*i-1) by A9,A10,Def14
    .= x by A6,A8;
  hence thesis by A11,FUNCT_1:def 5;
end;

Lm46: for G be _Graph, W be Walk of G, e be set holds e in W.edges() iff ex n
being even Element of NAT st 1 <= n & n <= len W & W.n = e
proof
  let G be _Graph, W be Walk of G, e be set;
  set es = W.edgeSeq();
  hereby
    assume e in W.edges();
    then consider i being Nat such that
A1: i in dom es and
A2: es.i = e by FINSEQ_2:11;
    set n = 2*i;
    reconsider n as even Element of NAT;
    take n;
A3: 1 <= i by A1,FINSEQ_3:27;
    then 1 <= i+i by NAT_1:12;
    hence 1 <= n;
A4: i <= len es by A1,FINSEQ_3:27;
    then i*2 <= len es * 2 by XREAL_1:66;
    then n <= len es * 2 + 1 by NAT_1:12;
    hence n <= len W by Def15;
    thus W.n = e by A2,A3,A4,Def15;
  end;
  assume ex n being even Element of NAT st 1 <= n & n <= len W & W.n = e;
  then consider n being even Element of NAT such that
A5: 1 <= n and
A6: n <= len W and
A7: W.n = e;
  set i = n div 2;
  2 divides n by PEPIN:22;
  then
A8: 2*i = n by NAT_D:3;
  reconsider i as Element of NAT;
  1 < n by A5,JORDAN12:3,XXREAL_0:1;
  then 1+1 < n+1 by XREAL_1:10;
  then 2*1 <= 2*i by A8,NAT_1:13;
  then
A9: 1 <= i by XREAL_1:70;
  n < len W by A6,XXREAL_0:1;
  then 2*i < 2*len es + 1 by A8,Def15;
  then 2*i <= 2*len es by NAT_1:13;
  then
A10: i <= len es by XREAL_1:70;
  then
A11: i in dom es by A9,FINSEQ_3:27;
  es.i = e by A7,A8,A9,A10,Def15;
  hence thesis by A11,FUNCT_1:def 5;
end;

Lm47: for G be _Graph, W be Walk of G, e be set holds e in W.edges() implies
ex v1, v2 being Vertex of G, n being odd Element of NAT st n+2 <= len W & v1 =
W.n & e = W.(n+1) & v2 = W.(n+2) & e Joins v1, v2,G
proof
  let G be _Graph, W be Walk of G, e be set;
  reconsider lenW = len W as odd Element of NAT;
  assume e in W.edges();
  then consider n1 being even Element of NAT such that
A1: 1 <= n1 and
A2: n1 <= len W and
A3: W.n1 = e by Lm46;
  reconsider n = n1-1 as odd Element of NAT by A1,INT_1:18;
  set v1 = W.n, v2 = W.(n+2);
  n1-1 <= len W - 0 by A2,XREAL_1:15;
  then reconsider v1 as Vertex of G by Lm1;
  n1 < lenW by A2,XXREAL_0:1;
  then
A4: n+1+1 <= len W by NAT_1:13;
  then reconsider v2 as Vertex of G by Lm1;
  take v1, v2, n;
  thus n+2 <= len W by A4;
  thus v1 = W.n & e = W.(n+1) & v2 = W.(n+2) by A3;
  n+1-1 < len W - 0 by A2,XREAL_1:17;
  hence thesis by A3,Def3;
end;

Lm48: for G be _Graph, W be Walk of G, e,x,y be set holds e in W.edges() & e
Joins x,y,G implies x in W.vertices() & y in W.vertices()
proof
  let G be _Graph, W be Walk of G, e,x,y be set;
  assume that
A1: e in W.edges() and
A2: e Joins x,y,G;
  consider v1,v2 being Vertex of G, n being odd Element of NAT such that
A3: n+2 <= len W and
A4: v1 = W.n and
  e = W.(n+1) and
A5: v2 = W.(n+2) and
A6: e Joins v1,v2,G by A1,Lm47;
  n+2-2 <= len W-0 by A3,XREAL_1:15;
  then
A7: v1 in W.vertices() by A4,Lm45;
  v2 in W.vertices() by A3,A5,Lm45;
  hence thesis by A2,A6,A7,GLIB_000:18;
end;

Lm49: for G be _Graph, W be Walk of G, n be odd Element of NAT st n <= len W
holds W.find(n) <= n
proof
  let G be _Graph, W be Walk of G, n be odd Element of NAT;
  assume
A1: n <= len W;
  then
  for k being odd Element of NAT st k <= len W & W.k = W.n holds W.find(n)
  <= k by Def20;
  hence thesis by A1;
end;

Lm50: for G be _Graph, W be Walk of G, n being odd Element of NAT st n <= len
W holds W.rfind(n) >= n
proof
  let G be _Graph, W be Walk of G, n be odd Element of NAT;
  assume
A1: n <= len W;
  then for k being odd Element of NAT st k <= len W & W.k = W.n holds k <= W
  .rfind(n) by Def22;
  hence thesis by A1;
end;

Lm51: for G being _Graph, W being Walk of G holds W is directed iff for n
being odd Element of NAT st n < len W holds W.(n+1) DJoins W.n, W.(n+2), G
proof
  let G be _Graph, W be Walk of G;
  hereby
    assume
A1: W is directed;
    let n be odd Element of NAT;
    assume
A2: n < len W;
    then
A3: W.n = (the_Source_of G).(W.(n+1)) by A1,Def25;
A4: now
      assume
A5:   W.(n+1) DJoins W.(n+2), W.n, G;
      then W.(n+2) = W.n by A3,GLIB_000:def 16;
      hence W.(n+1) DJoins W.n, W.(n+2), G by A5;
    end;
    W.(n+1) Joins W.n, W.(n+2), G by A2,Def3;
    hence W.(n+1) DJoins W.n, W.(n+2), G by A4,GLIB_000:19;
  end;
  assume
A6: for n being odd Element of NAT st n < len W holds W.(n+1) DJoins W.n
  , W.(n+2), G;
  now
    let n be odd Element of NAT;
    assume n < len W;
    then W.(n+1) DJoins W.n, W.(n+2), G by A6;
    hence (the_Source_of G).(W.(n+1)) = W.n by GLIB_000:def 16;
  end;
  hence thesis by Def25;
end;

Lm52: for G be _Graph, W be Walk of G, x,e,y,z be set holds W is directed & W
is_Walk_from x,y & e DJoins y,z,G implies W.addEdge(e) is directed & W.addEdge(
e) is_Walk_from x,z
proof
  let G be _Graph, W be Walk of G, x,e,y,z be set;
  set W2 = W.addEdge(e);
  assume that
A1: W is directed and
A2: W is_Walk_from x,y and
A3: e DJoins y,z,G;
A4: W.last() = y by A2,Def23;
  then
A5: e Joins W.last(),z,G by A3,GLIB_000:19;
  then
A6: len W2 = len W + 2 by Lm37;
A7: W2.(len W + 1) = e by A5,Lm38;
  1 <= len W by ABIAN:12;
  then len W in dom W by FINSEQ_3:27;
  then
A8: W2.(len W) = y by A4,A5,Lm38;
  now
    let n be odd Element of NAT;
    assume n < len W2;
    then n < len W + 1+1 by A6;
    then n <= len W + 1 by NAT_1:13;
    then n < len W + 1 by XXREAL_0:1;
    then
A9: n <= len W by NAT_1:13;
    now
      per cases;
      suppose
        n = len W;
        hence W2.n = (the_Source_of G).(W2.(n+1)) by A3,A8,A7,GLIB_000:def 16;
      end;
      suppose
A10:    n <> len W;
A11:    1 <= n+1 by NAT_1:12;
        1 <= n by ABIAN:12;
        then n in dom W by A9,FINSEQ_3:27;
        then
A12:    W2.n = W.n by A5,Lm38;
A13:    n < len W by A9,A10,XXREAL_0:1;
        then n + 1 <= len W by NAT_1:13;
        then n+1 in dom W by A11,FINSEQ_3:27;
        then W2.(n+1) = W.(n+1) by A5,Lm38;
        hence W2.n = (the_Source_of G).(W2.(n+1)) by A1,A13,A12,Def25;
      end;
    end;
    hence W2.n = (the_Source_of G).(W2.(n+1));
  end;
  hence W.addEdge(e) is directed by Def25;
  thus thesis by A2,A4,A5,Lm39;
end;

Lm53: for G being _Graph, W being Walk of G, m,n being Element of NAT holds W
is directed implies W.cut(m,n) is directed
proof
  let G be _Graph, W be Walk of G, m, n be Element of NAT;
  set W2 = W.cut(m,n);
  assume
A1: W is directed;
  now
    per cases;
    suppose
A2:   m is odd & n is odd & m <= n & n <= len W;
      then reconsider m9 = m as odd Element of NAT;
      now
        let x be odd Element of NAT;
        reconsider xaa1 = x - 1 as even Element of NAT by ABIAN:12,INT_1:18;
        assume
A3:     x < len W2;
        then x + 1 <= len W2 by NAT_1:13;
        then
A4:     x + 1 < len W2 by XXREAL_0:1;
        m+x in dom W by A2,A3,Lm15;
        then m9+x <= len W by FINSEQ_3:27;
        then
A5:     m9+x-1 < len W - 0 by XREAL_1:17;
        xaa1 < len W2 - 0 by A3,XREAL_1:16;
        then
A6:     W2.(xaa1+1) = W.(m+xaa1) by A2,Lm15;
A7:     W2.(x+2) = W2.(x+1+1) .= W.(m+(x-1+1+1)) by A2,A4,Lm15
          .= W.(m+xaa1+2);
        W2.(x+1) = W.(m+x-1+1) by A2,A3,Lm15
          .= W.(m+xaa1+1);
        hence W2.(x+1) DJoins W2.x, W2.(x+2), G by A1,A6,A5,A7,Lm51;
      end;
      hence thesis by Lm51;
    end;
    suppose
      not (m is odd & n is odd & m <= n & n <= len W);
      hence thesis by A1,Def11;
    end;
  end;
  hence thesis;
end;

Lm54: for G being _Graph, W being Walk of G holds W is non trivial iff 3 <=
len W
proof
  let G be _Graph, W be Walk of G;
  hereby
    assume W is non trivial;
    then W.length() <> 0 by Def26;
    then 0+1 <= len W.edgeSeq() by NAT_1:13;
    then 2*1 <= 2*len W.edgeSeq() by NAT_1:4;
    then 2+1 <= 2*len W.edgeSeq() + 1 by XREAL_1:9;
    hence 3 <= len W by Def15;
  end;
  assume 3 <= len W;
  then 2*1 + 1 <= 2*len W.edgeSeq() + 1 by Def15;
  then W.length() <> 0;
  hence thesis by Def26;
end;

Lm55: for G being _Graph, W being Walk of G holds W is non trivial iff len W
<> 1
proof
  let G be _Graph, W be Walk of G;
A1: 1 <= len W by ABIAN:12;
  thus W is non trivial implies len W <> 1 by Lm54;
  assume len W <> 1;
  then 1 < len W by A1,XXREAL_0:1;
  then 1+1 <= len W by NAT_1:13;
  then 2*1 < len W by XXREAL_0:1;
  then 2*1+1 <= len W by NAT_1:13;
  hence thesis by Lm54;
end;

Lm56: for G be _Graph, W be Walk of G holds W is trivial iff ex v being Vertex
of G st W = G.walkOf(v)
proof
  let G be _Graph, W be Walk of G;
  hereby
    assume
A1: W is trivial;
    take v = W.first();
    len W = 1 by A1,Lm55;
    hence W = G.walkOf(v) by FINSEQ_1:57;
  end;
  given v being Vertex of G such that
A2: W = G.walkOf(v);
  len W = 1 by A2,FINSEQ_1:56;
  hence thesis by Lm55;
end;

Lm57: for G being _Graph, W being Walk of G holds W is Trail-like iff for m,n
being even Element of NAT st 1 <= m & m < n & n <= len W holds W.m <> W.n
proof
  let G be _Graph, W be Walk of G;
  hereby
    assume W is Trail-like;
    then
A1: W.edgeSeq() is one-to-one by Def27;
    let m, n be even Element of NAT;
    assume that
A2: 1 <= m and
A3: m < n and
A4: n <= len W;
A5: 1 <= n by A2,A3,XXREAL_0:2;
    then
A6: n div 2 in dom W.edgeSeq() by A4,Lm40;
A7: m <= len W by A3,A4,XXREAL_0:2;
    then
A8: W.m = W.edgeSeq().(m div 2) by A2,Lm40;
A9: now
      2 divides m by PEPIN:22;
      then
A10:  2 * (m div 2) = m by NAT_D:3;
A11:  2 divides n by PEPIN:22;
      assume m div 2 = n div 2;
      hence contradiction by A3,A11,A10,NAT_D:3;
    end;
A12: W.n = W.edgeSeq().(n div 2) by A4,A5,Lm40;
    m div 2 in dom W.edgeSeq() by A2,A7,Lm40;
    hence W.m <> W.n by A1,A8,A6,A12,A9,FUNCT_1:def 8;
  end;
  assume
A13: for m,n being even Element of NAT st 1 <= m & m < n & n <= len W
  holds W.m <> W.n;
  now
    let x1, x2 be set;
    assume that
A14: x1 in dom W.edgeSeq() and
A15: x2 in dom W.edgeSeq() and
A16: W.edgeSeq().x1 = W.edgeSeq().x2;
    reconsider m = x1, n = x2 as Element of NAT by A14,A15;
A17: m <= len W.edgeSeq() by A14,FINSEQ_3:27;
    1 <= m by A14,FINSEQ_3:27;
    then
A18: W.edgeSeq().x1 = W.(2*m) by A17,Def15;
A19: n <= len W.edgeSeq() by A15,FINSEQ_3:27;
    1 <= n by A15,FINSEQ_3:27;
    then
A20: W.(2*m) = W.(2*n) by A16,A18,A19,Def15;
A21: 2*n in dom W by A15,Lm41;
    then
A22: 1 <= 2*n by FINSEQ_3:27;
A23: 2*m in dom W by A14,Lm41;
    then
A24: 2*m <= len W by FINSEQ_3:27;
A25: 2*n <= len W by A21,FINSEQ_3:27;
A26: 1 <= 2*m by A23,FINSEQ_3:27;
    now
      per cases by XXREAL_0:1;
      suppose
        2*m < 2*n;
        hence x1 = x2 by A13,A20,A26,A25;
      end;
      suppose
        2*m = 2*n;
        hence x1 = x2;
      end;
      suppose
        2*m > 2*n;
        hence x1 = x2 by A13,A20,A24,A22;
      end;
    end;
    hence x1 = x2;
  end;
  then W.edgeSeq() is one-to-one by FUNCT_1:def 8;
  hence thesis by Def27;
end;

Lm58: for G being _Graph, W being Walk of G holds W is Trail-like iff W
.reverse() is Trail-like
proof
  let G be _Graph, W be Walk of G;
A1: now
    let W be Walk of G;
    assume
A2: W is Trail-like;
    now
      reconsider lenW = len W as odd Element of NAT;
      let m, n be even Element of NAT;
      assume that
A3:   1 <= m and
A4:   m < n and
A5:   n <= len W.reverse();
      len W - n < len W - m by A4,XREAL_1:17;
      then
A6:   len W - n + 1 < len W - m + 1 by XREAL_1:10;
      m <= len W.reverse() by A4,A5,XXREAL_0:2;
      then
A7:   m in dom W.reverse() by A3,FINSEQ_3:27;
      then
A8:   len W - m + 1 in dom W by Lm8;
      then reconsider rm = lenW-m+1 as even Element of NAT;
A9:   rm <= len W by A8,FINSEQ_3:27;
      1 <= n by A3,A4,XXREAL_0:2;
      then
A10:  n in dom W.reverse() by A5,FINSEQ_3:27;
      then
A11:  W.reverse().n = W.(len W - n + 1) by Lm8;
A12:  len W - n + 1 in dom W by A10,Lm8;
      then reconsider rn = lenW-n+1 as even Element of NAT;
A13:  1 <= rn by A12,FINSEQ_3:27;
      W.reverse().m = W.(len W - m + 1) by A7,Lm8;
      hence W.reverse().m <> W.reverse().n by A2,A11,A6,A13,A9,Lm57;
    end;
    hence W.reverse() is Trail-like by Lm57;
  end;
  hence W is Trail-like implies W.reverse() is Trail-like;
  assume W.reverse() is Trail-like;
  then W.reverse().reverse() is Trail-like by A1;
  hence thesis by FINSEQ_6:29;
end;

Lm59: for G being _Graph, W being Walk of G, m,n being Element of NAT holds W
is Trail-like implies W.cut(m,n) is Trail-like
proof
  let G be _Graph, W be Walk of G, m,n be Element of NAT;
  assume
A1: W is Trail-like;
  now
    per cases;
    suppose
A2:   m is odd & n is odd & m <= n & n <= len W;
      now
        reconsider m9=m as odd Element of NAT by A2;
        let x,y be even Element of NAT;
        assume that
A3:     1 <= x and
A4:     x < y and
A5:     y <= len W.cut(m,n);
        reconsider xaa1 = x-1 as odd Element of NAT by A3,INT_1:18;
        reconsider yaa1 = y-1 as odd Element of NAT by A3,A4,INT_1:18
,XXREAL_0:2;
        x - 1 < y - 1 by A4,XREAL_1:16;
        then
A6:     xaa1 + m < yaa1 + m by XREAL_1:10;
        x <= len W.cut(m,n) by A4,A5,XXREAL_0:2;
        then x-1 < len W.cut(m,n)-0 by XREAL_1:17;
        then
A7:     W.cut(m,n).(xaa1+1) = W.(m+xaa1) by A2,Lm15;
A8:     y-1 < len W.cut(m,n)-0 by A5,XREAL_1:17;
        then
A9:     W.cut(m,n).(yaa1+1) = W.(m+yaa1) by A2,Lm15;
        m+yaa1 in dom W by A2,A8,Lm15;
        then
A10:    m+yaa1 <= len W by FINSEQ_3:27;
        1 <= m+xaa1 by ABIAN:12,NAT_1:12;
        then W.(m9+xaa1) <> W.(m9+yaa1) by A1,A10,A6,Lm57;
        hence W.cut(m,n).x <> W.cut(m,n).y by A7,A9;
      end;
      hence thesis by Lm57;
    end;
    suppose
      not (m is odd & n is odd & m <= n & n <= len W);
      hence thesis by A1,Def11;
    end;
  end;
  hence thesis;
end;

Lm60: for G be _Graph, W being Walk of G, e being set st W is Trail-like & e
in W.last().edgesInOut() & not e in W.edges() holds W.addEdge(e) is Trail-like
proof
  let G be _Graph, W be Walk of G, e be set;
  assume that
A1: W is Trail-like and
A2: e in W.last().edgesInOut() and
A3: not e in W.edges();
  set W2 = W.addEdge(e);
  reconsider lenW2 = len W2 as odd Element of NAT;
A4: e Joins W.last(), W.last().adj(e),G by A2,GLIB_000:70;
  now
    let m,n be even Element of NAT;
    assume that
A5: 1 <= m and
A6: m < n and
A7: n <= len W2;
    now
      per cases;
      suppose
A8:     n <= len W;
        then m <= len W by A6,XXREAL_0:2;
        then m in dom W by A5,FINSEQ_3:27;
        then
A9:     W2.m = W.m by A4,Lm38;
        1 <= n by A5,A6,XXREAL_0:2;
        then n in dom W by A8,FINSEQ_3:27;
        then W2.n = W.n by A4,Lm38;
        hence W2.m <> W2.n by A1,A5,A6,A8,A9,Lm57;
      end;
      suppose
A10:    n > len W;
        n < lenW2 by A7,XXREAL_0:1;
        then n+1 <= len W2 by NAT_1:13;
        then n+1-1 <= len W2 - 1 by XREAL_1:15;
        then
A11:    n <= len W + (1+1) - 1 by A4,Lm37;
        len W + 1 <= n by A10,NAT_1:13;
        then
A12:    n = len W + 1 by A11,XXREAL_0:1;
        then
A13:    W2.n = e by A4,Lm38;
A14:    m + 1 - 1 <= len W + 1 - 1 by A6,A12,NAT_1:13;
        then m in dom W by A5,FINSEQ_3:27;
        then W2.m = W.m by A4,Lm38;
        hence W2.m <> W2.n by A3,A5,A13,A14,Lm46;
      end;
    end;
    hence W2.m <> W2.n;
  end;
  hence thesis by Lm57;
end;

Lm61: for G be _Graph, W be Walk of G holds len W <= 3 implies W is Trail-like
proof
  let G be _Graph, W be Walk of G;
  assume
A1: len W <= 3;
  now
    per cases;
    suppose
      len W = 1;
      then W is trivial by Lm55;
      then ex v being Vertex of G st W = G.walkOf(v) by Lm56;
      hence thesis by Lm4;
    end;
    suppose
A2:   len W <> 1;
      1 <= len W by ABIAN:12;
      then 1 < len W by A2,XXREAL_0:1;
      then 1+2 <= len W by Th1,JORDAN12:3;
      then
A3:   len W = 3 by A1,XXREAL_0:1;
      now
        let m, n be even Element of NAT such that
A4:     1 <= m and
A5:     m < n and
A6:     n <= len W;
        2*0+1 < m by A4,XXREAL_0:1;
        then
A7:     1+1 <= m by NAT_1:13;
        n < 2+1 by A3,A6,XXREAL_0:1;
        then n <= 2 by NAT_1:13;
        hence W.m <> W.n by A5,A7,XXREAL_0:2;
      end;
      hence thesis by Lm57;
    end;
  end;
  hence thesis;
end;

Lm62: for G being _Graph, x,e,y being set holds e Joins x,y,G implies G.walkOf
(x,e,y) is Path-like
proof
  let G be _Graph, x,e,y be set;
  set W = G.walkOf(x,e,y);
  assume
A1: e Joins x,y,G;
  then
A2: len W = 3 by Lm5;
A3: now
    let m,n be odd Element of NAT;
    assume that
A4: m < n and
A5: n <= len W;
    assume W.m = W.n;
A6: 1 <= m by ABIAN:12;
    then 1 < n by A4,XXREAL_0:2;
    then 1+1 < n+1 by XREAL_1:10;
    then 2*1 <= n by NAT_1:13;
    then 2*1 < n by XXREAL_0:1;
    then 2+1 < n+1 by XREAL_1:10;
    then
A7: 3 <= n by NAT_1:13;
    then
A8: n = 3 by A2,A5,XXREAL_0:1;
    now
      assume m <> 1;
      then 1 < m by A6,XXREAL_0:1;
      then 1+1 < m+1 by XREAL_1:10;
      then 2*1 <= m by NAT_1:13;
      then 2*1 < m by XXREAL_0:1;
      then 2+1 < m+1 by XREAL_1:10;
      hence contradiction by A4,A8,NAT_1:13;
    end;
    hence m = 1 & n = len W by A2,A5,A7,XXREAL_0:1;
  end;
  now
    let m,n be even Element of NAT;
    assume that
A9: 1 <= m and
A10: m < n and
A11: n <= len W;
    1 < m by A9,JORDAN12:3,XXREAL_0:1;
    then 1+1 <= m by NAT_1:13;
    then
A12: 2 < n by A10,XXREAL_0:2;
    n <= 3 by A1,A11,Lm5;
    then n < 2*1+1 by XXREAL_0:1;
    hence W.m <> W.n by A12,NAT_1:13;
  end;
  then W is Trail-like by Lm57;
  hence thesis by A3,Def28;
end;

Lm63: for G being _Graph, W being Walk of G holds W is Path-like iff W
.reverse() is Path-like
proof
  let G be _Graph, W be Walk of G;
A1: now
    let W be Walk of G;
    reconsider lenW=len W as odd Element of NAT;
    assume
A2: W is Path-like;
A3: now
      let m, n be odd Element of NAT;
      assume that
A4:   m < n and
A5:   n <= len W.reverse() and
A6:   W.reverse().m = W.reverse().n;
A7:   1 <= m by ABIAN:12;
      m <= len W.reverse() by A4,A5,XXREAL_0:2;
      then
A8:   m in dom W.reverse() by A7,FINSEQ_3:27;
      then
A9:   len W - m + 1 in dom W by Lm8;
      then reconsider rm = lenW-m+1 as odd Element of NAT;
      1 <= n by ABIAN:12;
      then
A10:  n in dom W.reverse() by A5,FINSEQ_3:27;
      then len W - n + 1 in dom W by Lm8;
      then reconsider rn = lenW-n+1 as odd Element of NAT;
      lenW - n < len W - m by A4,XREAL_1:17;
      then
A11:  rn < rm by XREAL_1:10;
      W.reverse().n = W.(len W - n + 1) by A10,Lm8;
      then
A12:  W.rm = W.rn by A6,A8,Lm8;
A13:  rm <= len W by A9,FINSEQ_3:27;
      then len W + (1 + -m) = len W by A2,A11,A12,Def28;
      hence m = 1;
      rn = 1 by A2,A11,A13,A12,Def28;
      hence n = len W.reverse() by FINSEQ_5:def 3;
    end;
    W is Trail-like by A2,Def28;
    then W.reverse() is Trail-like by Lm58;
    hence W.reverse() is Path-like by A3,Def28;
  end;
  hence W is Path-like implies W.reverse() is Path-like;
  assume W.reverse() is Path-like;
  then W.reverse().reverse() is Path-like by A1;
  hence thesis by FINSEQ_6:29;
end;

Lm64: for G being _Graph, W being Walk of G, m, n being Element of NAT st W is
Path-like holds W.cut(m,n) is Path-like
proof
  let G be _Graph, W be Walk of G, m, n be Element of NAT;
  assume
A1: W is Path-like;
  now
    per cases;
    suppose
A2:   m is odd & n is odd & m <= n & n <= len W;
      then reconsider m9=m as odd Element of NAT;
      now
        W is Trail-like by A1,Def28;
        hence W.cut(m,n) is Trail-like by Lm59;
        let x,y be odd Element of NAT;
        assume that
A3:     x < y and
A4:     y <= len W.cut(m,n) and
A5:     W.cut(m,n).x = W.cut(m,n).y;
        reconsider xaa1 = x-1 as even Element of NAT by ABIAN:12,INT_1:18;
        reconsider yaa1 = y-1 as even Element of NAT by ABIAN:12,INT_1:18;
        x - 1 < y - 1 by A3,XREAL_1:16;
        then
A6:     xaa1 + m < yaa1 + m by XREAL_1:10;
        x <= len W.cut(m,n) by A3,A4,XXREAL_0:2;
        then x-1 < len W.cut(m,n) - 0 by XREAL_1:17;
        then
A7:     W.cut(m,n).(xaa1+1) = W.(m+xaa1) by A2,Lm15;
A8:     y-1 < len W.cut(m,n) - 0 by A4,XREAL_1:17;
        then
A9:     W.cut(m,n).(yaa1+1) = W.(m+yaa1) by A2,Lm15;
        m+yaa1 in dom W by A2,A8,Lm15;
        then
A10:    m9+yaa1 <= len W by FINSEQ_3:27;
        then
A11:    m9+yaa1 = len W by A1,A5,A7,A9,A6,Def28;
A12:    now
          assume
A13:      xaa1 <> 0;
          m >= 1 by A2,ABIAN:12;
          then 1+0 < m + xaa1 by A13,XREAL_1:10;
          hence contradiction by A1,A5,A7,A9,A6,A10,Def28;
        end;
        then m + 1 - 1 = 1 by A1,A5,A7,A9,A6,A10,Def28;
        then
A14:    len W.cut(m,n) + 1 = n + 1 by A2,Lm15;
        thus x = 1 by A12;
        m9+xaa1 = 1 by A1,A5,A7,A9,A6,A10,Def28;
        hence y = len W.cut(m,n) by A2,A4,A11,A12,A14,XXREAL_0:1;
      end;
      hence thesis by Def28;
    end;
    suppose
      not (m is odd & n is odd & m <= n & n <= len W);
      hence thesis by A1,Def11;
    end;
  end;
  hence thesis;
end;

Lm65: for G being _Graph, W being Walk of G, e,v being set st W is Path-like &
e Joins W.last(),v,G & not e in W.edges() & (W is trivial or W is open) & for n
being odd Element of NAT st 1 < n & n <= len W holds W.n <> v holds W.addEdge(e
) is Path-like
proof
  let G be _Graph, W be Walk of G, e,v be set;
  assume that
A1: W is Path-like and
A2: e Joins W.last(), v,G and
A3: not e in W.edges() and
A4: W is trivial or W is open and
A5: for n being odd Element of NAT st 1 < n & n <= len W holds W.n <> v;
  reconsider lenW = len W as odd Element of NAT;
  set W2 = W.addEdge(e);
A6: e in W.last().edgesInOut() by A2,GLIB_000:65;
  now
    W is Trail-like by A1,Def28;
    hence W2 is Trail-like by A3,A6,Lm60;
    let m, n be odd Element of NAT;
    assume that
A7: m < n and
A8: n <= len W2 and
A9: W2.m = W2.n;
    now
      per cases by A4;
      suppose
A10:    W is open;
        now
          per cases;
          suppose
A11:        n <= len W;
A12:        1 <= m by ABIAN:12;
            m <= len W by A7,A11,XXREAL_0:2;
            then m in dom W by A12,FINSEQ_3:27;
            then
A13:        W2.m = W.m by A2,Lm38;
            1 <= n by ABIAN:12;
            then n in dom W by A11,FINSEQ_3:27;
            then
A14:        W.m = W.n by A2,A9,A13,Lm38;
            then m = 1 by A1,A7,A11,Def28;
            then W.first() = W.last() by A1,A7,A11,A14,Def28;
            hence m = 1 & n = len W2 by A10,Def24;
          end;
          suppose
            n > len W;
            then lenW + 1 <= n by NAT_1:13;
            then lenW + 1 < n by XXREAL_0:1;
            then lenW + 1 + 1 <= n by NAT_1:13;
            then len W + (1+1) <= n;
            then
A15:        len W2 <= n by A2,Lm37;
            then n = len W2 by A8,XXREAL_0:1;
            then W2.n = W2.(len W + 2) by A2,Lm37;
            then
A16:        W2.n = v by A2,Lm38;
            m < len W2 by A7,A8,A15,XXREAL_0:1;
            then m < len W + (1 + 1) by A2,Lm37;
            then m < len W + 1 + 1;
            then m <= lenW + 1 by NAT_1:13;
            then m < lenW + 1 by XXREAL_0:1;
            then
A17:        m <= len W by NAT_1:13;
            1 <= m by ABIAN:12;
            then m in dom W by A17,FINSEQ_3:27;
            then
A18:        W.m = v by A2,A9,A16,Lm38;
            now
A19:          1 <= m by ABIAN:12;
              assume m <> 1;
              then 1 < m by A19,XXREAL_0:1;
              hence contradiction by A5,A17,A18;
            end;
            hence m = 1;
            thus n = len W2 by A8,A15,XXREAL_0:1;
          end;
        end;
        hence m = 1 & n = len W2;
      end;
      suppose
        W is trivial;
        then ex v being Vertex of G st W = G.walkOf(v) by Lm56;
        then len W = 1 by FINSEQ_1:56;
        then
A20:    len W2 = 1 + 2 by A2,Lm37;
A21:    m+1 <= n by A7,NAT_1:13;
A22:    1 <= m by ABIAN:12;
        then 1+1 <= m+1 by XREAL_1:9;
        then 2*1 <= n by A21,XXREAL_0:2;
        then 2*1 < n by XXREAL_0:1;
        then
A23:    len W2 <= n by A20,NAT_1:13;
        then n = len W2 by A8,XXREAL_0:1;
        then m+1-1 <= 3-1 by A7,A20,NAT_1:13;
        then m < 2*1 by XXREAL_0:1;
        then m+1 <= 2 by NAT_1:13;
        then m+1-1 <= 2-1 by XREAL_1:15;
        hence m = 1 & n = len W2 by A8,A22,A23,XXREAL_0:1;
      end;
    end;
    hence m = 1 & n = len W2;
  end;
  hence thesis by Def28;
end;

Lm66: for G be _Graph, W be Walk of G holds (for m,n being odd Element of NAT
st m <= len W & n <= len W & W.m = W.n holds m = n) implies W is Path-like
proof
  let G be _Graph, W be Walk of G;
  assume
A1: for m,n being odd Element of NAT st m <= len W & n <= len W & W.m =
  W.n holds m = n;
  now
    let m,n be even Element of NAT;
    assume that
A2: 1 <= m and
A3: m < n and
A4: n <= len W;
    m <= len W by A3,A4,XXREAL_0:2;
    then
A5: m in dom W by A2,FINSEQ_3:27;
    1 <= n by A2,A3,XXREAL_0:2;
    then
A6: n in dom W by A4,FINSEQ_3:27;
    now
      assume W.m = W.n;
      then consider naa1 being odd Element of NAT such that
A7:   naa1 = n-1 and
A8:   n-1 in dom W and
A9:   n+1 in dom W and
A10:  W.m Joins W.(naa1), W.(n+1), G by A6,Lm2;
A11:  naa1 <= len W by A7,A8,FINSEQ_3:27;
      consider maa1 being odd Element of NAT such that
A12:  maa1 = m-1 and
A13:  m-1 in dom W and
A14:  m+1 in dom W and
A15:  W.m Joins W.(maa1), W.(m+1), G by A5,Lm2;
A16:  maa1 <= len W by A12,A13,FINSEQ_3:27;
A17:  n+1 <= len W by A9,FINSEQ_3:27;
A18:  m+1 <= len W by A14,FINSEQ_3:27;
      now
        per cases by A15,A10,GLIB_000:18;
        suppose
          W.(naa1) = W.(maa1) & W.(n+1) = W.(m+1);
          then naa1 = maa1 by A1,A16,A11;
          hence contradiction by A3,A12,A7;
        end;
        suppose
A19:      W.(naa1) = W.(m+1) & W.(n+1) = W.(maa1);
          then
A20:      n+1 = maa1 by A1,A16,A17;
          naa1 = m+1 by A1,A18,A11,A19;
          hence contradiction by A12,A7,A20;
        end;
      end;
      hence contradiction;
    end;
    hence W.m <> W.n;
  end;
  then
A21: W is Trail-like by Lm57;
  now
    let m,n be odd Element of NAT;
    assume that
A22: m < n and
A23: n <= len W;
    assume
A24: W.m = W.n;
    m <= len W by A22,A23,XXREAL_0:2;
    hence m = 1 & n = len W by A1,A22,A23,A24;
  end;
  hence thesis by A21,Def28;
end;

Lm67: for G be _Graph, W be Walk of G holds (for n being odd Element of NAT st
n <= len W holds W.rfind(n) = n) implies W is Path-like
proof
  let G be _Graph, W be Walk of G;
  assume
A1: for n being odd Element of NAT st n <= len W holds W.rfind(n) = n;
  now
    let m,n be odd Element of NAT;
    assume that
A2: m <= len W and
A3: n <= len W and
A4: W.m = W.n;
    W.rfind(n) = n by A1,A3;
    then
A5: m <= n by A2,A3,A4,Def22;
    W.rfind(m) = m by A1,A2;
    then n <= m by A2,A3,A4,Def22;
    hence m = n by A5,XXREAL_0:1;
  end;
  hence thesis by Lm66;
end;

Lm68: for G be _Graph, W being Walk of G, e, v being set st e Joins W.last(),v
,G & W is Path-like & not v in W.vertices() & (W is trivial or W is open) holds
W.addEdge(e) is Path-like
proof
  let G be _Graph, W be Walk of G, e, v be set;
  assume that
A1: e Joins W.last(),v,G and
A2: W is Path-like and
A3: not v in W.vertices() and
A4: W is trivial or W is open;
A5: for n being odd Element of NAT st 1 < n & n <= len W holds v <> W.n by A3
,Lm45;
  not e in W.edges() by A1,A3,Lm48;
  hence thesis by A1,A2,A4,A5,Lm65;
end;

Lm69: for G be _Graph, W be Walk of G holds len W <= 3 implies W is Path-like
proof
  let G be _Graph, W be Walk of G;
  assume
A1: len W <= 3;
  now
    per cases;
    suppose
      len W = 1;
      then W is trivial by Lm55;
      then ex v being Vertex of G st W = G.walkOf(v) by Lm56;
      hence thesis by Lm4;
    end;
    suppose
A2:   len W <> 1;
      1 <= len W by ABIAN:12;
      then 1 < len W by A2,XXREAL_0:1;
      then 1+2 <= len W by Th1,JORDAN12:3;
      then
A3:   len W = 3 by A1,XXREAL_0:1;
A4:   now
        let m, n be odd Element of NAT;
        assume that
A5:     m < n and
A6:     n <= len W and
        W.m = W.n;
A7:     1 <= m by ABIAN:12;
        m < 2*1+1 by A3,A5,A6,XXREAL_0:2;
        then m+2-2 <= 3-2 by Th1;
        hence m = 1 by A7,XXREAL_0:1;
        2*0+1 < n by A5,A7,XXREAL_0:2;
        then 1+2 <= n by Th1;
        hence n = len W by A3,A6,XXREAL_0:1;
      end;
      W is Trail-like by A1,Lm61;
      hence thesis by A4,Def28;
    end;
  end;
  hence thesis;
end;

registration
  let G be _Graph;
  cluster Path-like -> Trail-like Walk of G;
  correctness by Def28;
  cluster trivial -> Path-like Walk of G;
  correctness
  proof
    let W be Walk of G;
    assume
A1: W is trivial;
A2: now
      let m,n be odd Element of NAT;
      assume that
A3:   m < n and
A4:   n <= len W and
      W.m = W.n;
A5:   1 <= m by ABIAN:12;
A6:   1 <= n by ABIAN:12;
      n <= 1 by A1,A4,Lm55;
      hence m = 1 & n = len W by A3,A5,A6,XXREAL_0:1;
    end;
    len W = 1 by A1,Lm55;
    then 2*len W.edgeSeq() + 1 = 0+1 by Def15;
    then W.edgeSeq() = {};
    then W is Trail-like by Def27;
    hence thesis by A2,Def28;
  end;
  cluster trivial -> vertex-distinct Walk of G;
  coherence
  proof
    let W be Walk of G;
    assume
A7: W is trivial;
    now
      let m,n be odd Element of NAT;
      assume that
A8:   m <= len W and
A9:   n <= len W and
      W.m = W.n;
A10:  1 <= m by ABIAN:12;
      m <= 1 by A7,A8,Lm55;
      then
A11:  m = 1 by A10,XXREAL_0:1;
A12:  1 <= n by ABIAN:12;
      n <= 1 by A7,A9,Lm55;
      hence m = n by A12,A11,XXREAL_0:1;
    end;
    hence thesis by Def29;
  end;
  cluster vertex-distinct -> Path-like Walk of G;
  coherence
  proof
    let W be Walk of G;
    assume W is vertex-distinct;
    then
    for m,n being odd Element of NAT st m <= len W & n <= len W & W.m = W
    .n holds m = n by Def29;
    hence thesis by Lm66;
  end;
  cluster Circuit-like -> closed Trail-like non trivial Walk of G;
  correctness by Def30;
  cluster Cycle-like -> closed Path-like non trivial Walk of G;
  correctness by Def31;
end;

registration
  let G be _Graph;
  cluster closed directed trivial Walk of G;
  existence
  proof
    consider v being Vertex of G;
    take G.walkOf(v);
    thus thesis by Lm4;
  end;
end;

registration
  let G be _Graph;
  cluster vertex-distinct Walk of G;
  existence
  proof
    consider W being trivial Walk of G;
    take W;
    thus thesis;
  end;
end;

definition
  let G be _Graph;
  mode Trail of G is Trail-like Walk of G;
  mode Path of G is Path-like Walk of G;
end;

definition
  let G be _Graph;
  mode DWalk of G is directed Walk of G;
  mode DTrail of G is directed Trail of G;
  mode DPath of G is directed Path of G;
end;

registration
  let G be _Graph, v be Vertex of G;
  cluster G.walkOf(v) -> closed directed trivial;
  coherence by Lm4;
end;

registration
  let G be _Graph, x,e,y be set;
  cluster G.walkOf(x,e,y) -> Path-like;
  coherence
  proof
    set W = G.walkOf(x,e,y);
    now
      per cases;
      suppose
        e Joins x,y,G;
        hence thesis by Lm62;
      end;
      suppose
        not e Joins x,y,G;
        then W = G.walkOf(choose the_Vertices_of G) by Def5;
        hence thesis;
      end;
    end;
    hence thesis;
  end;
end;

registration
  let G be _Graph, x,e be set;
  cluster G.walkOf(x,e,x) -> closed;
  coherence
  proof
    set W = G.walkOf(x,e,x);
    now
      per cases;
      suppose
A1:     e Joins x,x,G;
        then
A2:     W.last() = x by Lm6;
        W.first() = x by A1,Lm6;
        hence thesis by A2,Def24;
      end;
      suppose
        not e Joins x,x,G;
        then W = G.walkOf(choose the_Vertices_of G) by Def5;
        hence thesis;
      end;
    end;
    hence thesis;
  end;
end;

registration
  let G be _Graph, W be closed Walk of G;
  cluster W.reverse() -> closed;
  coherence
  proof
    W is closed iff W.first() = W.last() by Def24;
    then W is closed iff W.reverse().last() = W.last() by Lm7;
    then W is closed iff W.reverse().last() = W.reverse().first() by Lm7;
    hence thesis by Def24;
  end;
end;

registration
  let G be _Graph, W be trivial Walk of G;
  cluster W.reverse() -> trivial;
  coherence
  proof
    len W = 1 by Lm55;
    then len W.reverse() = 1 by FINSEQ_5:def 3;
    hence thesis by Lm55;
  end;
end;

registration
  let G be _Graph, W be Trail of G;
  cluster W.reverse() -> Trail-like;
  coherence by Lm58;
end;

registration
  let G be _Graph, W be Path of G;
  cluster W.reverse() -> Path-like;
  coherence by Lm63;
end;

registration
  let G be _Graph, W1,W2 be closed Walk of G;
  cluster W1.append(W2) -> closed;
  coherence
  proof
    set W = W1.append(W2);
    now
      per cases;
      suppose
A1:     W1.last() = W2.first();
        then W1.last() = W2.last() by Def24;
        then W1.first() = W2.last() by Def24
          .= W.last() by A1,Lm11;
        then W.first() = W.last() by A1,Lm11;
        hence thesis by Def24;
      end;
      suppose
        W1.last() <> W2.first();
        hence thesis by Def10;
      end;
    end;
    hence thesis;
  end;
end;

registration
  let G be _Graph, W1,W2 be DWalk of G;
  cluster W1.append(W2) -> directed;
  coherence
  proof
    set W = W1.append(W2);
    now
      per cases;
      suppose
A1:     W1.last() = W2.first();
        now
          let n be odd Element of NAT;
          assume
A2:       n < len W;
          1 <= n by ABIAN:12;
          then
A3:       n in dom W by A2,FINSEQ_3:27;
          now
            per cases by A3,Lm14;
            suppose
A4:           n in dom W1;
              then
A5:           n <= len W1 by FINSEQ_3:27;
A6:           W.n = W1.n by A4,Lm12;
              now
                per cases by A5,XXREAL_0:1;
                suppose
A7:               n < len W1;
                  then n+2 in dom W1 by Lm3;
                  then
A8:               W.(n+2) = W1.(n+2) by Lm12;
                  n+1 in dom W1 by A7,Lm3;
                  then W.(n+1) = W1.(n+1) by Lm12;
                  hence W.(n+1) DJoins W.n, W.(n+2), G by A6,A7,A8,Lm51;
                end;
                suppose
A9:               n = len W1;
                  n + 1 < len W + 1 by A2,XREAL_1:10;
                  then 1 + n < len W2 + n by A1,A9,Lm9;
                  then
A10:              1 < len W2 by XREAL_1:8;
                  then
A11:              W2.(2*0+1+1) DJoins W2.(2*0+1), W2.(2*0+1+2), G by Lm51;
A12:              n = len W1 + 0 by A9;
A13:              0 < len W2;
                  1+1 <= len W2 by A10,NAT_1:13;
                  then 2*1 < len W2 by XXREAL_0:1;
                  then
A14:              W.(n+2) = W2.(2+1) by A1,A9,Lm13;
                  W.(n+1) = W2.(1+1) by A1,A9,A10,Lm13;
                  hence W.(n+1) DJoins W.n, W.(n+2), G by A1,A13,A12,A14,A11
,Lm13;
                end;
              end;
              hence W.(n+1) DJoins W.n, W.(n+2), G;
            end;
            suppose
              ex k being Element of NAT st k < len W2 & n = len W1 + k;
              then consider k being Element of NAT such that
A15:          k < len W2 and
A16:          n = len W1 + k;
              reconsider k as even Element of NAT by A16;
A17:          W.n = W2.(k+1) by A1,A15,A16,Lm13;
              n + 1 < len W + 1 by A2,XREAL_1:10;
              then 1 + (k + len W1) < len W2 + len W1 by A1,A16,Lm9;
              then
A18:          k + 1 + len W1 - len W1 < len W2 + len W1 - len W1 by XREAL_1:16;
              then k + 1 + 1 <= len W2 by NAT_1:13;
              then
A19:          k + 1 + 1 < len W2 by XXREAL_0:1;
A20:          n + 1 + 1 = len W1 + ((k + 1) + 1) by A16;
A21:          W2.(k+1+(1+1)) = W2.(k+1+1+1) .= W.(n+(1+1)) by A1,A19,A20,Lm13;
              W.(n+1) = W2.(k+1+1) by A1,A16,A18,Lm13;
              hence W.(n+1) DJoins W.n, W.(n+2), G by A17,A18,A21,Lm51;
            end;
          end;
          hence W.(n+1) DJoins W.n, W.(n+2), G;
        end;
        hence thesis by Lm51;
      end;
      suppose
        W1.last() <> W2.first();
        hence thesis by Def10;
      end;
    end;
    hence thesis;
  end;
end;

registration
  let G be _Graph, W1,W2 be trivial Walk of G;
  cluster W1.append(W2) -> trivial;
  coherence
  proof
    set W = W1.append(W2);
    now
      per cases;
      suppose
        W1.last() = W2.first();
        then len W + 1 = len W1 + len W2 by Lm9
          .= len W1 + 1 by Lm55
          .= 1 + 1 by Lm55;
        hence thesis by Lm55;
      end;
      suppose
        W1.last() <> W2.first();
        hence thesis by Def10;
      end;
    end;
    hence thesis;
  end;
end;

registration
  let G be _Graph, W be DWalk of G, m,n be Element of NAT;
  cluster W.cut(m,n) -> directed;
  coherence by Lm53;
end;

registration
  let G be _Graph, W be trivial Walk of G, m,n be Element of NAT;
  cluster W.cut(m,n) -> trivial;
  coherence
  proof
    set W2 = W.cut(m,n);
    now
      per cases;
      suppose
A1:     m is odd & n is odd & m <= n & n <= len W;
        then
A2:     1 <= n by ABIAN:12;
        n <= 1 by A1,Lm55;
        then
A3:     n = 1 by A2,XXREAL_0:1;
A4:     1 <= m by A1,ABIAN:12;
        len W2 + m = n + 1 by A1,Lm15;
        then len W2 + 1 = 1 + 1 by A1,A4,A3,XXREAL_0:1;
        hence thesis by Lm55;
      end;
      suppose
        not (m is odd & n is odd & m <= n & n <= len W);
        hence thesis by Def11;
      end;
    end;
    hence thesis;
  end;
end;

registration
  let G be _Graph, W be Trail of G, m,n be Element of NAT;
  cluster W.cut(m,n) -> Trail-like;
  coherence by Lm59;
end;

registration
  let G be _Graph, W be Path of G, m,n be Element of NAT;
  cluster W.cut(m,n) -> Path-like;
  coherence by Lm64;
end;

registration
  let G be _Graph, W be vertex-distinct Walk of G, m,n be Element of NAT;
  cluster W.cut(m,n) -> vertex-distinct;
  coherence
  proof
    set W2 = W.cut(m,n);
    now
      per cases;
      suppose
A1:     m is odd & n is odd & m <= n & n <= len W;
        then reconsider m9 = m as odd Element of NAT;
        now
          let a,b be odd Element of NAT;
          assume that
A2:       a <= len W2 and
A3:       b <= len W2 and
A4:       W2.a = W2.b;
          reconsider aaa1 = a-1, baa1 = b-1 as even Element of NAT by ABIAN:12
,INT_1:18;
A5:       baa1 < len W2 - 0 by A3,XREAL_1:17;
          then
A6:       W2.(baa1+1) = W.(m+baa1) by A1,Lm15;
A7:       aaa1 < len W2 - 0 by A2,XREAL_1:17;
          then m+aaa1 in dom W by A1,Lm15;
          then
A8:       m9+aaa1 <= len W by FINSEQ_3:27;
          m+baa1 in dom W by A1,A5,Lm15;
          then
A9:       m9 + baa1 <= len W by FINSEQ_3:27;
          W2.(aaa1+1) = W.(m+aaa1) by A1,A7,Lm15;
          then aaa1+m9 = baa1 + m9 by A4,A6,A8,A9,Def29;
          hence a = b;
        end;
        hence thesis by Def29;
      end;
      suppose
        not (m is odd & n is odd & m <= n & n <= len W);
        hence thesis by Def11;
      end;
    end;
    hence thesis;
  end;
end;

registration
  let G be _Graph, W be closed Walk of G, m,n be Element of NAT;
  cluster W.remove(m,n) -> closed;
  coherence
  proof
    thus W.remove(m,n).first() = W.first() by Lm33
      .= W.last() by Def24
      .= W.remove(m,n).last() by Lm33;
  end;
end;

registration
  let G be _Graph, W be DWalk of G, m,n be Element of NAT;
  cluster W.remove(m,n) -> directed;
  coherence
  proof
    now
      per cases;
      suppose
        m is odd & n is odd & m <= n & n <= len W & W.m = W.n;
        then W.remove(m,n) = W.cut(1,m).append(W.cut(n,len W)) by Def12;
        hence thesis;
      end;
      suppose
        not (m is odd & n is odd & m <= n & n <= len W & W.m = W.n);
        hence thesis by Def12;
      end;
    end;
    hence thesis;
  end;
end;

registration
  let G be _Graph, W be trivial Walk of G, m,n be Element of NAT;
  cluster W.remove(m,n) -> trivial;
  coherence
  proof
    now
      per cases;
      suppose
        m is odd & n is odd & m <= n & n <= len W & W.m = W.n;
        then W.remove(m,n) = W.cut(1,m).append(W.cut(n,len W)) by Def12;
        hence thesis;
      end;
      suppose
        not (m is odd & n is odd & m <= n & n <= len W & W.m = W.n);
        hence thesis by Def12;
      end;
    end;
    hence thesis;
  end;
end;

registration
  let G be _Graph, W be Trail of G, m,n be Element of NAT;
  cluster W.remove(m,n) -> Trail-like;
  coherence
  proof
    set W2 = W.remove(m,n);
A1: len W2 <= len W by Lm26;
    now
      per cases;
      suppose
A2:     m is odd & n is odd & m <= n & n <= len W & W.m = W.n;
        then reconsider m9=m, n9=n as odd Element of NAT;
        now
          given a,b being even Element of NAT such that
A3:       1 <= a and
A4:       a < b and
A5:       b <= len W2 and
A6:       W2.a = W2.b;
          1 <= b by A3,A4,XXREAL_0:2;
          then
A7:       b in dom W2 by A5,FINSEQ_3:27;
          a <= len W2 by A4,A5,XXREAL_0:2;
          then
A8:       a in dom W2 by A3,FINSEQ_3:27;
          now
            per cases by A2,A8,Lm34;
            suppose
              a in Seg m;
              then
A9:           W2.a = W.a by A2,Lm29;
              now
                per cases by A2,A7,Lm34;
                suppose
A10:              b in Seg m;
A11:              b <= len W by A1,A5,XXREAL_0:2;
                  W2.b = W.b by A2,A10,Lm29;
                  hence contradiction by A3,A4,A6,A9,A11,Lm57;
                end;
                suppose
A12:              m <= b & b <= len W2;
                  then reconsider b2 = b-m9+n9 as even Element of NAT by A2
,Lm30;
A13:              b2 <= len W by A2,A12,Lm30;
A14:              W2.b = W.b2 by A2,A12,Lm30;
                  now
                    per cases;
                    suppose
                      a < b2;
                      hence contradiction by A3,A6,A9,A14,A13,Lm57;
                    end;
                    suppose
A15:                  b2 <= a;
A16:                  n-m >= m-m by A2,XREAL_1:15;
A17:                  a-b < b-b by A4,XREAL_1:16;
                      (n-m)+b-b <= a-b by A15,XREAL_1:15;
                      then 0 <= a-b by A16;
                      hence contradiction by A17;
                    end;
                  end;
                  hence contradiction;
                end;
              end;
              hence contradiction;
            end;
            suppose
A18:          m <= a & a <= len W2;
              then reconsider a2 = a-m9+n9 as even Element of NAT by A2,Lm30;
              reconsider nm4 = n9-m9 as even Element of NAT by A2,INT_1:18;
A19:          W2.a = W.a2 by A2,A18,Lm30;
              now
                per cases by A2,A7,Lm34;
                suppose
                  b in Seg m;
                  then b <= m by FINSEQ_1:3;
                  hence contradiction by A4,A18,XXREAL_0:2;
                end;
                suppose
A20:              m <= b & b <= len W2;
                  then reconsider b2 = b-m9+n9 as even Element of NAT by A2
,Lm30;
A21:              b2 <= len W by A2,A20,Lm30;
A22:              W2.b = W.b2 by A2,A20,Lm30;
                  now
                    per cases;
                    suppose
A23:                  a2 < b2;
                      1 <= m9 by ABIAN:12;
                      then 1 <= a by A18,XXREAL_0:2;
                      then 1 <= a+nm4 by NAT_1:12;
                      hence contradiction by A6,A19,A22,A21,A23,Lm57;
                    end;
                    suppose
                      b2 <= a2;
                      then b + nm4 <= a + nm4;
                      hence contradiction by A4,XREAL_1:8;
                    end;
                  end;
                  hence contradiction;
                end;
              end;
              hence contradiction;
            end;
          end;
          hence contradiction;
        end;
        hence thesis by Lm57;
      end;
      suppose
        not (m is odd & n is odd & m <= n & n <= len W & W.m = W.n);
        hence thesis by Def12;
      end;
    end;
    hence thesis;
  end;
end;

registration
  let G be _Graph, W be Path of G, m,n be Element of NAT;
  cluster W.remove(m,n) -> Path-like;
  coherence
  proof
    set W2 = W.remove(m,n);
A1: len W2 <= len W by Lm26;
    now
      per cases;
      suppose
A2:     m is odd & n is odd & m <= n & n <= len W & W.m = W.n;
        then reconsider m9=m, n9=n as odd Element of NAT;
        now
          let x,y be odd Element of NAT;
          assume that
A3:       x < y and
A4:       y <= len W2 and
A5:       W2.x = W2.y;
A6:       1 <= x by ABIAN:12;
          x <= len W2 by A3,A4,XXREAL_0:2;
          then
A7:       x in dom W2 by A6,FINSEQ_3:27;
          1 <= y by ABIAN:12;
          then
A8:       y in dom W2 by A4,FINSEQ_3:27;
A9:       y <= len W by A1,A4,XXREAL_0:2;
          now
            per cases by A2,A7,Lm34;
            suppose
              x in Seg m;
              then
A10:          W2.x = W.x by A2,Lm29;
              now
                per cases by A2,A8,Lm34;
                suppose
                  y in Seg m;
                  then
A11:              W2.y = W.y by A2,Lm29;
                  then y = len W by A3,A5,A9,A10,Def28;
                  hence x = 1 & y = len W2 by A1,A3,A4,A5,A10,A11,Def28,
XXREAL_0:1;
                end;
                suppose
A12:              m <= y & y <= len W2;
                  then
A13:              y-m+n <= len W by A2,Lm30;
A14:              W2.y = W.(y-m+n) by A2,A12,Lm30;
                  reconsider y2 = y-m9+n9 as odd Element of NAT by A2,A12,Lm30;
                  y-m + n >= y-m+m by A2,XREAL_1:9;
                  then
A15:              x < y2 by A3,XXREAL_0:2;
                  y2 <= len W by A2,A12,Lm30;
                  then y2 = len W by A5,A10,A14,A15,Def28;
                  then len W2 + n = y -m + n + m by A2,Lm24
                    .= y + n;
                  hence x = 1 & y = len W2 by A5,A10,A14,A13,A15,Def28;
                end;
              end;
              hence x = 1 & y = len W2;
            end;
            suppose
A16:          m <= x & x <= len W2;
              then reconsider x2 = x-m9+n9 as odd Element of NAT by A2,Lm30;
A17:          W2.x = W.(x-m+n) by A2,A16,Lm30;
              now
                per cases by A2,A8,Lm34;
                suppose
                  y in Seg m;
                  then y <= m by FINSEQ_1:3;
                  hence x = 1 & y = len W2 by A3,A16,XXREAL_0:2;
                end;
                suppose
A18:              m <= y & y <= len W2;
                  then reconsider y2 = y-m9+n9 as odd Element of NAT by A2,Lm30
;
                  x + (n - m) < y + (n-m) by A3,XREAL_1:10;
                  then
A19:              x2 < y2;
                  reconsider xm4 = x-m as Element of NAT by A16,INT_1:18;
A20:              1 <= n9 by ABIAN:12;
A21:              1 <= m9 by ABIAN:12;
A22:              y-m+n <= len W by A2,A18,Lm30;
A23:              W2.y = W.(y-m+n) by A2,A18,Lm30;
                  then y2 = len W by A5,A17,A22,A19,Def28;
                  then
A24:              len W2 + n = y -m + n + m by A2,Lm24
                    .= y + n;
                  x2 = 1 by A5,A17,A23,A22,A19,Def28;
                  then x2 - n9 <= 1-1 by A20,XREAL_1:15;
                  then
A25:              xm4 = 0;
                  then m <= 1 by A2,A5,A17,A23,A22,A19,Def28;
                  hence x = 1 & y = len W2 by A24,A25,A21,XXREAL_0:1;
                end;
              end;
              hence x = 1 & y = len W2;
            end;
          end;
          hence x = 1 & y = len W2;
        end;
        hence thesis by Def28;
      end;
      suppose
        not (m is odd & n is odd & m <= n & n <= len W & W.m = W.n);
        hence thesis by Def12;
      end;
    end;
    hence thesis;
  end;
end;

definition
  let G be _Graph, W be Walk of G;
  mode Subwalk of W -> Walk of G means
    :Def32:
    it is_Walk_from W.first(), W
    .last() & ex es being Subset of W.edgeSeq() st it.edgeSeq() = Seq es;
  existence
  proof
    reconsider es = W.edgeSeq() as Subset of W.edgeSeq() by GRAPH_2:28;
    take W;
    thus W is_Walk_from W.first(), W.last() by Def23;
    take es;
    thus thesis by FINSEQ_3:125;
  end;
end;

Lm70: for G being _Graph, W being Walk of G holds W is Subwalk of W
proof
  let G be _Graph, W be Walk of G;
  reconsider es = W.edgeSeq() as Subset of W.edgeSeq() by GRAPH_2:28;
A1: W.edgeSeq() = Seq es by FINSEQ_3:125;
  W is_Walk_from W.first(),W.last() by Def23;
  hence thesis by A1,Def32;
end;

Lm71: for G be _Graph, W1 be Walk of G, W2 be Subwalk of W1, W3 be Subwalk of
W2 holds W3 is Subwalk of W1
proof
  let G be _Graph, W1 be Walk of G, W2 be Subwalk of W1, W3 be Subwalk of W2;
  set fs = W1.edgeSeq(),fs1 = W2.edgeSeq(),fs2 = W3.edgeSeq();
  consider fss1 being Subset of fs1 such that
A1: fs2 = Seq fss1 by Def32;
  consider fss being Subset of fs such that
A2: fs1 = Seq fss by Def32;
  set fss2 = fss | rng((Sgm dom fss)|dom fss1);
  reconsider fss2 as Subset of fs by GRAPH_2:29;
A3: fs2 = Seq fss2 by A1,A2,GRAPH_2:30;
A4: W2 is_Walk_from W1.first(), W1.last() by Def32;
  then
A5: W2.last() = W1.last() by Def23;
  W2.first() = W1.first() by A4,Def23;
  hence thesis by A5,A3,Def32;
end;

Lm72: for G be _Graph, W1,W2 be Walk of G holds W1 is Subwalk of W2 implies
len W1 <= len W2
proof
  let G be _Graph, W1,W2 be Walk of G;
  assume W1 is Subwalk of W2;
  then ex es being Subset of W2.edgeSeq() st W1.edgeSeq() = Seq es by Def32;
  then 2*len W1.edgeSeq() <= 2*len W2.edgeSeq() by Th3,XREAL_1:66;
  then 2*len W1.edgeSeq()+1 <= 2*len W2.edgeSeq() + 1 by XREAL_1:9;
  then len W1 <= 2*len W2.edgeSeq() + 1 by Def15;
  hence thesis by Def15;
end;

definition
  let G be _Graph, W be Walk of G, m,n being Element of NAT;
  redefine func W.remove(m,n) -> Subwalk of W;
  coherence
  proof
    set W2 = W.remove(m,n), es1 = W2.edgeSeq();
    now
      per cases;
      suppose
A1:     m is odd & n is odd & m <= n & n <= len W & W.m = W.n;
        then reconsider m9=m, n9=n as odd Element of NAT;
        reconsider lenWn4 = len W - n9 as even Element of NAT by A1,INT_1:18;
A2:     Seg len es1 = dom es1 by FINSEQ_1:def 3;
        reconsider lenWaa1 = len W - 1 as even Element of NAT by ABIAN:12
,INT_1:18;
        reconsider n1 = n9+1 as even Element of NAT;
        reconsider maa1 = m9-1 as even Element of NAT by ABIAN:12,INT_1:18;
        set X = {x where x is Element of NAT : 1 <= x & x <= maa1 div 2};
        set Y = {x where x is Element of NAT : n1 div 2 <= x & x <= lenWaa1
        div 2};
        set Z = X \/ Y, es = W.edgeSeq() | Z;
        2 divides maa1 by PEPIN:22;
        then
A3:     maa1 = 2 * (maa1 div 2) by NAT_D:3;
        2 divides n1 by PEPIN:22;
        then
A4:     n1 = 2 * (n1 div 2) by NAT_D:3;
        now
          assume n1 div 2 < 1;
          then 2*(n1 div 2) < 2*1 by XREAL_1:70;
          then n + 1 - 1 < 2 - 1 by A4,XREAL_1:16;
          then n9 < 1;
          hence contradiction by ABIAN:12;
        end;
        then reconsider n1div2aa1 = (n1 div 2) - 1 as Element of NAT by
INT_1:18;
A5:     2 divides lenWaa1 by PEPIN:22;
        then
A6:     lenWaa1 = 2 * (lenWaa1 div 2) by NAT_D:3;
        now
          let x be set;
          assume
A7:       x in Z;
          now
            per cases by A7,XBOOLE_0:def 3;
            suppose
              x in X;
              then consider y being Element of NAT such that
A8:           y = x and
A9:           1 <= y and
A10:          y <= maa1 div 2;
              2*y <= maa1 by A3,A10,XREAL_1:66;
              then 2*y <= maa1+1 by NAT_1:12;
              then 2*y <= n by A1,XXREAL_0:2;
              then
A11:          2*y <= len W by A1,XXREAL_0:2;
              1 <= y+y by A9,NAT_1:12;
              then 2*y in dom W by A11,FINSEQ_3:27;
              hence x in dom W.edgeSeq() by A8,Lm41;
            end;
            suppose
              x in Y;
              then consider y being Element of NAT such that
A12:          y = x and
A13:          n1 div 2 <= y and
A14:          y <= lenWaa1 div 2;
              2*y <= lenWaa1 by A6,A14,XREAL_1:66;
              then
A15:          2*y <= lenWaa1+1 by NAT_1:12;
A16:          1 <= n1 by NAT_1:12;
              n1 <= 2*y by A4,A13,XREAL_1:66;
              then 1 <= 2*y by A16,XXREAL_0:2;
              then 2*y in dom W by A15,FINSEQ_3:27;
              hence x in dom W.edgeSeq() by A12,Lm41;
            end;
          end;
          hence x in dom W.edgeSeq();
        end;
        then
A17:    Z c= dom W.edgeSeq() by TARSKI:def 3;
        then
A18:    Z c= Seg len W.edgeSeq() by FINSEQ_1:def 3;
        then
A19:    X c= Seg len W.edgeSeq() by XBOOLE_1:11;
A20:    Y c= Seg len W.edgeSeq() by A18,XBOOLE_1:11;
        reconsider X,Y as finite set by A18,FINSET_1:13,XBOOLE_1:11;
A21:    X = {x where x is Element of NAT : 0+1 <= x & x <= 0+(maa1 div 2 )};
A22:    dom W.edgeSeq() /\ Z = Z by A17,XBOOLE_1:28;
        then
A23:    dom es = Z by RELAT_1:90;
        2 divides lenWn4 by PEPIN:22;
        then
A24:    lenWn4 = 2 * (lenWn4 div 2) by NAT_D:3;
A25:    now
          per cases;
          suppose
A26:        n1 div 2 > lenWaa1 div 2;
            then lenWaa1 < n+1 by A6,A4,XREAL_1:70;
            then lenWaa1 + 1 <= n+1 by NAT_1:13;
            then len W <= n9+1;
            then len W < n+1 by XXREAL_0:1;
            then len W <= n by NAT_1:13;
            then
A27:        len W = n by A1,XXREAL_0:1;
            now
              assume Y <> {};
              then consider x being set such that
A28:          x in Y by XBOOLE_0:def 1;
              ex x9 being Element of NAT st x9 = x & n1 div 2 <= x9 &
              x9 <= lenWaa1 div 2 by A28;
              hence contradiction by A26,XXREAL_0:2;
            end;
            hence card Y = lenWn4 div 2 by A27,CARD_1:47,NAT_2:4;
          end;
          suppose
            n1 div 2 <= lenWaa1 div 2;
            then reconsider
            k = (lenWaa1 div 2) - (n1 div 2) as Element of NAT by INT_1:18;
            Y = {x where x is Element of NAT: n1 div 2 <= x & x <= n1 div
            2 + k};
            then card Y = k+1 by GRAPH_2:4;
            hence card Y = lenWn4 div 2 by A24,A6,A4;
          end;
        end;
        reconsider Z as finite set by A17;
        W.edgeSeq() is Subset of W.edgeSeq() by GRAPH_2:28;
        then reconsider es as Subset of W.edgeSeq() by GRAPH_2:29;
        set es2 = Seq es;
A29:    es2 = es * Sgm(dom es) by FINSEQ_1:def 14;
        set lenY = lenWaa1 div 2 - n1div2aa1;
        now
          assume n1div2aa1 > lenWaa1 div 2;
          then 2*n1div2aa1 > 2 * (lenWaa1 div 2) by XREAL_1:70;
          then n+1 - 1 - 1 > len W - 1 by A5,A4,NAT_D:3;
          hence contradiction by A1,XREAL_1:11;
        end;
        then reconsider lenY as Element of NAT by INT_1:18;
A30:    Y = {x where x is Element of NAT: n1div2aa1+1 <= x & x <=
        n1div2aa1+lenY};
A31:    now
          let a,b be Element of NAT;
          assume that
A32:      a in X and
A33:      b in Y;
          consider b9 being Element of NAT such that
A34:      b9=b and
A35:      n1 div 2 <= b9 and
          b9 <= lenWaa1 div 2 by A33;
          consider a9 being Element of NAT such that
A36:      a9=a and
          1 <= a9 and
A37:      a9 <= maa1 div 2 by A32;
          2*a9 <= maa1 by A3,A37,XREAL_1:66;
          then 2*a9 < maa1+1 by NAT_1:13;
          then 2*a9 < n by A1,XXREAL_0:2;
          then
A38:      2*a9+0 < n+1 by XREAL_1:10;
A39:      n+1 <= 2*b9 by A4,A35,XREAL_1:66;
          then 2*a9 < 2*b9 by A38,XXREAL_0:2;
          then a9 <= b9 by XREAL_1:70;
          hence a < b by A36,A34,A38,A39,XXREAL_0:1;
        end;
A40:    now
          per cases;
          suppose
A41:        maa1 div 2 = 0;
            now
              assume X <> {};
              then consider x being set such that
A42:          x in X by XBOOLE_0:def 1;
              ex x9 being Element of NAT st x9 = x & 1 <= x9 & x9 <=
              maa1 div 2 by A42;
              hence contradiction by A41;
            end;
            hence card X = maa1 div 2 by A41;
          end;
          suppose
            maa1 div 2 <> 0;
            then consider k being Nat such that
A43:        maa1 div 2 = k + 1 by NAT_1:6;
            reconsider k as Element of NAT by ORDINAL1:def 13;
            maa1 div 2 = k + 1 by A43;
            hence card X = maa1 div 2 by GRAPH_2:4;
          end;
        end;
        then
A44:    dom Sgm X = Seg (maa1 div 2) by A18,FINSEQ_3:45,XBOOLE_1:11;
        then
A45:    len (Sgm X) = maa1 div 2 by FINSEQ_1:def 3;
        len W2 = 2*len W2.edgeSeq()+1 by Def15;
        then
A46:    len W + m - n = 2*len es1 + 1 by A1,Lm31;
        now
          assume not X /\ Y = {};
          then consider x being set such that
A47:      x in X /\ Y by XBOOLE_0:def 1;
          x in Y by A47,XBOOLE_0:def 4;
          then consider y9 being Element of NAT such that
A48:      y9 = x and
A49:      n1 div 2 <= y9 and
          y9 <= lenWaa1 div 2;
          x in X by A47,XBOOLE_0:def 4;
          then consider x9 being Element of NAT such that
A50:      x9 = x and
          1 <= x9 and
A51:      x9 <= maa1 div 2;
          2*x9 <= maa1 by A3,A51,XREAL_1:66;
          then 2*y9 < maa1+1 by A50,A48,NAT_1:13;
          then 2*y9 < n by A1,XXREAL_0:2;
          then 2*y9+0 < n+1 by XREAL_1:10;
          hence contradiction by A4,A49,XREAL_1:66;
        end;
        then X misses Y by XBOOLE_0:def 7;
        then
A52:    card Z = (maa1 div 2) + (lenWn4 div 2) by A40,A25,CARD_2:53;
        dom es c= Seg len W.edgeSeq() by A22,A18,RELAT_1:90;
        then rng Sgm(dom es) = dom es by FINSEQ_1:def 13;
        then
A53:    dom es2 = dom Sgm(Z) by A23,A29,RELAT_1:46
          .= Seg card Z by A18,FINSEQ_3:45;
A54:    dom Sgm Y = Seg (lenWn4 div 2) by A18,A25,FINSEQ_3:45,XBOOLE_1:11;
        now
          let x9 be set;
          assume
A55:      x9 in dom es1;
          then reconsider x = x9 as Element of NAT;
A56:      1 <= x by A55,FINSEQ_3:27;
A57:      x <= len es1 by A55,FINSEQ_3:27;
          then
A58:      es1.x = W2.(2*x) by A56,Def15;
          now
            per cases;
            suppose
A59:          2*x+1 <= m;
A60:          1 <= x+x by A56,NAT_1:12;
              2*x+1-1 < m - 0 by A59,XREAL_1:17;
              then 2*x in Seg m by A60,FINSEQ_1:3;
              then
A61:          es1.x9 = W.(2*x) by A1,A58,Lm29;
A62:          Sgm(Z).x = (Sgm(X) ^ Sgm(Y)).x by A19,A20,A31,FINSEQ_3:48;
              2*x+1-1 <= maa1 by A59,XREAL_1:15;
              then
A63:          x <= maa1 div 2 by A3,XREAL_1:70;
              then x in X by A56;
              then
A64:          x in dom es by A23,XBOOLE_0:def 3;
              x in dom Sgm X by A44,A56,A63,FINSEQ_1:3;
              then Sgm(Z).x = Sgm(X).x by A62,FINSEQ_1:def 7
                .= 0+x by A21,A56,A63,GRAPH_2:5;
              then
              es2.x = es.x by A3,A24,A23,A2,A29,A53,A46,A52,A55,FUNCT_1:22;
              then
A65:          es2.x = W.edgeSeq().x by A64,FUNCT_1:70;
              x <= len W.edgeSeq() by A23,A18,A64,FINSEQ_1:3;
              hence es1.x9 = es2.x9 by A56,A61,A65,Def15;
            end;
            suppose
A66:          2*x+1 > m;
A67:          now
                assume x <= maa1 div 2;
                then 2*x <= maa1 by A3,XREAL_1:66;
                then 2*x+1 <= maa1+1 by XREAL_1:9;
                hence contradiction by A66;
              end;
              then consider k being Nat such that
A68:          x = maa1 div 2 + k by NAT_1:10;
A69:          Sgm(Z).x = (Sgm(X) ^ Sgm(Y)).x by A19,A20,A31,FINSEQ_3:48;
A70:          ex lenWaa19 being even Element of NAT st lenWaa19 =
              lenWaa1 & len W.edgeSeq() = lenWaa19 div 2 by Lm42;
              2*x <= 2*len es1 by A57,XREAL_1:66;
              then 2*x <= 2*len es1 + 1 by NAT_1:12;
              then
A71:          2*x <= len W2 by Def15;
              reconsider k as Element of NAT by ORDINAL1:def 13;
A72:          2*(n1div2aa1 + k) = 2*x - m + n by A3,A4,A68;
A73:          m <= 2*x by A66,NAT_1:13;
              then
A74:          2*x-m+n <= len W by A1,A71,Lm30;
A75:          now
                reconsider z = 2*x-m9+n9 as Element of NAT by A1,A73,A71,Lm30;
                assume lenWaa1 div 2 < k + n1div2aa1;
                then lenWaa1 < 2*(x - (maa1 div 2) + n1div2aa1) by A6,A68,
XREAL_1:70;
                then lenWaa1 + 1 < 2*x-m+n+1 by A3,A4,XREAL_1:10;
                then len W <= z by NAT_1:13;
                hence contradiction by A74,XXREAL_0:1;
              end;
              k <> 0 by A67,A68;
              then 0+1 < k+1 by XREAL_1:10;
              then
A76:          1 <= k by NAT_1:13;
              then n1div2aa1 + 1 <= n1div2aa1 + k by XREAL_1:9;
              then n1div2aa1 + k in Y by A75;
              then n1div2aa1+k in dom es by A23,XBOOLE_0:def 3;
              then
A77:          es.(n1div2aa1+k) = W.edgeSeq().(n1div2aa1+k) by FUNCT_1:70;
A78:          now
                set z = 2*x-m9+n9;
                reconsider z as Element of NAT by A1,A73,A71,Lm30;
                assume lenWn4 div 2 < x - (maa1 div 2);
                then 2 * (lenWn4 div 2) < 2*(x - (maa1 div 2)) by XREAL_1:70;
                then
A79:            lenWn4 + n < 2*x - m + 1 + n by A3,A24,XREAL_1:10;
                2*x-m9+n9 < len W by A74,XXREAL_0:1;
                then z+1 <= len W by NAT_1:13;
                hence contradiction by A79;
              end;
              then k in dom Sgm(Y) by A54,A68,A76,FINSEQ_1:3;
              then Sgm(Z).x = Sgm(Y).k by A45,A69,A68,FINSEQ_1:def 7
                .= n1div2aa1 + k by A24,A6,A4,A30,A68,A76,A78,GRAPH_2:5;
              then
A80:          es2.x = es.(n1div2aa1 + k) by A3,A24,A23,A2,A29,A53,A46,A52,A55,
FUNCT_1:22;
              1 <= n1div2aa1+k by A76,NAT_1:12;
              then es2.x = W.(2*(n1div2aa1+k)) by A80,A75,A77,A70,Def15;
              hence es1.x9 = es2.x9 by A1,A58,A73,A71,A72,Lm30;
            end;
          end;
          hence es1.x9 = es2.x9;
        end;
        then
A81:    W2.edgeSeq() = Seq es by A3,A24,A2,A53,A46,A52,FUNCT_1:9;
        W is_Walk_from W.first(), W.last() by Def23;
        then W2 is_Walk_from W.first(), W.last() by Lm25;
        hence thesis by A81,Def32;
      end;
      suppose
        not (m is odd & n is odd & m <= n & n <= len W & W.m = W.n);
        then W.remove(m,n) = W by Def12;
        hence thesis by Lm70;
      end;
    end;
    hence thesis;
  end;
end;

registration
  let G be _Graph, W be Walk of G;
  cluster Trail-like Path-like Subwalk of W;
  existence
  proof
    set n = len W + 1;
    defpred P1[Element of NAT,set,set] means ($2 is Walk of G & ex Wn being
Walk of G st Wn = $2 & $3 = Wn.remove(Wn.find(2*$1+1),Wn.rfind(2*$1+1))) or (
    not $2 is Walk of G & $3 = $2);
A1: now
      let n be Element of NAT, x be set;
      now
        per cases;
        suppose
          x is Walk of G;
          then reconsider W = x as Walk of G;
          set y = W.remove(W.find(2*n+1),W.rfind(2*n+1));
          P1[n,x,y];
          hence ex y being set st P1[n,x,y];
        end;
        suppose
          not x is Walk of G;
          hence ex y being set st P1[n,x,y];
        end;
      end;
      hence ex y being set st P1[n,x,y];
    end;
    consider f being Function such that
A2: dom f = NAT & f.0 = W & for n being Element of NAT holds P1[n,f.n,
    f.(n+1)] from RECDEF_1:sch 1(A1);
    defpred P3[Element of NAT] means ex Wn being Subwalk of W st Wn = f.$1 &
len Wn <= len W & for m being odd Element of NAT st m < 2*$1+1 & m <= len Wn
    holds Wn.rfind(m) = m;
    now
      let n be Element of NAT;
      assume P3[n];
      then consider Wn being Subwalk of W such that
A3:   Wn = f.n and
A4:   len Wn <= len W and
A5:   for m being odd Element of NAT st m < 2*n+1 & m <= len Wn holds
      Wn .rfind(m) = m;
      set a = Wn.find(2*n+1), b = Wn.rfind(2*n+1);
      set Wn1 = Wn.remove(a,b);
      reconsider Wn1 as Subwalk of W by Lm71;
      take Wn1;
      P1[n,f.n,f.(n+1)] by A2;
      hence f.(n+1) = Wn1 by A3;
      len Wn1 <= len Wn by Lm26;
      hence len Wn1 <= len W by A4,XXREAL_0:2;
      let m be odd Element of NAT;
      assume that
A6:   m < 2*(n+1)+1 and
A7:   m <= len Wn1;
      set W1 = Wn.cut(1,a), W2 = Wn.cut(b, len Wn);
A8:   len Wn1 <= len Wn by Lm26;
      then
A9:   m <= len Wn by A7,XXREAL_0:2;
      m <= 2*(n+1) by A6,NAT_1:13;
      then m < 2*n+1+1 by XXREAL_0:1;
      then
A10:  m <= 2*n+1 by NAT_1:13;
      now
        per cases;
        suppose
A11:      2*n+1 <= len Wn;
          then
A12:      a <= 2*n+1 by Lm49;
A13:      Wn.a = Wn.(2*n+1) by A11,Def20;
A14:      a <= len Wn by A11,Def20;
A15:      now
            assume
A16:        a < 2*n+1;
            then a <= len Wn by A11,XXREAL_0:2;
            then Wn.rfind(a) = a by A5,A16;
            hence contradiction by A11,A14,A13,A16,Def22;
          end;
          then
A17:      a = 2*n+1 by A12,XXREAL_0:1;
A18:      Wn.b = Wn.(2*n+1) by A11,Def22;
          set m9 = Wn1.rfind(m);
A19:      1 <= m by ABIAN:12;
A20:      Wn1.m9 = Wn1.m by A7,Def22;
A21:      m9 >= m by A7,Lm50;
A22:      b <= len Wn by A11,Def22;
          1 <= a by ABIAN:12;
          then
A23:      W1.last() = Wn.(2*n+1) by A14,A13,Lm16,JORDAN12:3
            .= W2.first() by A22,A18,Lm16;
          2*n+1 <= b by A11,Lm50;
          then
A24:      a <= b by A12,XXREAL_0:2;
          then
A25:      Wn1 = W1.append(W2) by A13,A22,A18,Def12;
A26:      m9 <= len Wn1 by A7,Def22;
          then
A27:      m9 <= len Wn by A8,XXREAL_0:2;
          now
            per cases by A10,XXREAL_0:1;
            suppose
A28:          m < 2*n+1;
              then m < len Wn.cut(1,a) by A11,A17,Lm22;
              then
A29:          Wn1.cut(1,m) = Wn.cut(1,a).cut(1,m) by A25,A19,A23,Lm21,
JORDAN12:3
                .= Wn.cut(1,m) by A10,A17,Lm20;
              reconsider maa1 = m - 1 as Element of NAT by ABIAN:12,INT_1:18;
A30:          maa1 + 1 = m;
A31:          maa1 < m - 0 by XREAL_1:17;
              then
A32:          maa1 < len Wn.cut(1,m) by A7,A8,Lm22,XXREAL_0:2;
              maa1 < len Wn1.cut(1,m) by A7,A31,Lm22;
              then Wn1.m = Wn.cut(1,m).m by A7,A19,A29,A30,Lm15,JORDAN12:3;
              then
A33:          Wn1.m = Wn.m by A9,A19,A30,A32,Lm15,JORDAN12:3;
A34:          Wn.rfind(m) = m by A5,A9,A28;
              now
                per cases;
                suppose
A35:              m9 < a;
                  reconsider m9aa1 = m9 - 1 as Element of NAT by ABIAN:12
,INT_1:18;
A36:              1 <= m9 by ABIAN:12;
A37:              m9aa1 < m9 - 0 by XREAL_1:17;
                  then
A38:              m9aa1 < len Wn1.cut(1,m9) by A26,Lm22;
A39:              m9aa1 < len Wn.cut(1,m9) by A8,A26,A37,Lm22,XXREAL_0:2;
                  m9 < len Wn.cut(1,a) by A14,A35,Lm22;
                  then Wn1.cut(1,m9) = Wn.cut(1,a).cut(1,m9) by A25,A23,A36
,Lm21,JORDAN12:3
                    .= Wn.cut(1,m9) by A35,Lm20;
                  then Wn1.m9 = Wn.cut(1,m9).(m9aa1+1) by A26,A36,A38,Lm15,
JORDAN12:3;
                  then Wn.m9 = Wn.m by A20,A27,A33,A36,A39,Lm15,JORDAN12:3;
                  then m9 <= m by A9,A27,A34,Def22;
                  hence Wn1.rfind(m) = m by A21,XXREAL_0:1;
                end;
                suppose
A40:              a <= m9;
                  set x = m9 - a + b;
A41:              Wn1.m9 = Wn.x by A13,A22,A18,A24,A26,A40,Lm30;
A42:              x <= len Wn by A13,A22,A18,A24,A26,A40,Lm30;
                  m9 + a <= m9 + b by A24,XREAL_1:9;
                  then
A43:              m9 + a - a <= m9 + b - a by XREAL_1:15;
                  reconsider x as Element of NAT by A13,A22,A18,A24,A26,A40
,Lm30;
                  x <= m by A9,A20,A34,A33,A41,A42,Def22;
                  then m9 <= m by A43,XXREAL_0:2;
                  hence Wn1.rfind(m) = m by A21,XXREAL_0:1;
                end;
              end;
              hence Wn1.rfind(m) = m;
            end;
            suppose
A44:          m = 2*n+1;
              then m <= len Wn.cut(1,a) by A11,A17,Lm22;
              then
A45:          Wn1.cut(1,m) = Wn.cut(1,a).cut(1,m) by A25,A19,A23,Lm21,
JORDAN12:3
                .= Wn.cut(1,m) by A10,A17,Lm20;
              reconsider maa1 = m - 1 as Element of NAT by ABIAN:12,INT_1:18;
A46:          maa1 + 1 = m;
A47:          maa1 < m - 0 by XREAL_1:17;
              then
A48:          maa1 < len Wn.cut(1,m) by A7,A8,Lm22,XXREAL_0:2;
              maa1 < len Wn1.cut(1,m) by A7,A47,Lm22;
              then Wn1.m = Wn.cut(1,m).m by A7,A19,A45,A46,Lm15,JORDAN12:3;
              then
A49:          Wn1.m = Wn.m by A9,A19,A46,A48,Lm15,JORDAN12:3;
              now
                set x = m9 - a + b;
                assume
A50:            m < m9;
                then
A51:            a < m9 by A12,A15,A44,XXREAL_0:1;
                then
A52:            x is Element of NAT by A13,A22,A18,A24,A26,Lm30;
A53:            x <= len Wn by A13,A22,A18,A24,A26,A51,Lm30;
                Wn1.m9 = Wn.x by A13,A22,A18,A24,A26,A51,Lm30;
                then m9 - a + b <= b by A11,A20,A44,A49,A52,A53,Def22;
                then m9 - a + b - b <= b - b by XREAL_1:15;
                then m9 - a + a <= 0 + a by XREAL_1:9;
                hence contradiction by A12,A15,A44,A50,XXREAL_0:1;
              end;
              hence Wn1.rfind(m) = m by A21,XXREAL_0:1;
            end;
          end;
          hence Wn1.rfind(m) = m;
        end;
        suppose
A54:      len Wn < 2*n+1;
          then
A55:      m < 2*n+1 by A9,XXREAL_0:2;
A56:      b = len Wn by A54,Def22;
          a = len Wn by A54,Def20;
          then Wn1 = Wn by A56,Lm27;
          hence Wn1.rfind(m) = m by A5,A7,A55;
        end;
      end;
      hence Wn1.rfind(m) = m;
    end;
    then
A57: for n being Element of NAT st P3[n] holds P3[n+1];
    reconsider W0 = f.0 as Subwalk of W by A2,Lm70;
    for m being odd Element of NAT st m < 2*0+1 & m <= len W0 holds W0
    .rfind(m) = m by ABIAN:12;
    then
A58: P3[0] by A2;
    for n being Element of NAT holds P3[n] from NAT_1:sch 1(A58,A57);
    then consider P being Subwalk of W such that
    P = f.n and
A59: len P <= len W and
A60: for m being odd Element of NAT st m < 2*n+1 & m <= len P holds P
    .rfind(m) = m;
    take P;
    now
      let m be odd Element of NAT;
      assume
A61:  m <= len P;
      len P + 0 < n by A59,XREAL_1:10;
      then len P + 0 < n+n by XREAL_1:10;
      then len P + 0 < 2*n+1 by XREAL_1:10;
      then m < 2*n+1 by A61,XXREAL_0:2;
      hence P.rfind(m) = m by A60,A61;
    end;
    then P is Path-like by Lm67;
    hence thesis;
  end;
end;

definition
  let G be _Graph, W be Walk of G;
  mode Trail of W is Trail-like Subwalk of W;
  mode Path of W is Path-like Subwalk of W;
end;

registration
  let G be _Graph, W be DWalk of G;
  cluster directed Path of W;
  existence
  proof
    defpred P[Element of NAT] means for W1 being DWalk of G st W1.length() =
    $1 holds ex W2 being Path of W1 st W2 is directed;
A1: W.length() = W.length();
    now
      let k be Element of NAT;
      assume
A2:   P[k];
      let W1 be DWalk of G;
      set WA = W1.cut(1,2*k+1);
      set e = W1.(2*k+1+1), v = W1.(2*k+1+2);
      assume
A3:   W1.length() = k + 1;
      then
A4:   len W1 = 2*(k+1)+1 by Def15
        .= 2*k+1+2;
      then
A5:   2*k+1+2-2 < len W1 - 0 by XREAL_1:17;
      then
A6:   e DJoins W1.(2*k+1), v, G by Lm51;
      len WA = 2*k+1 by A5,Lm22;
      then
A7:   2*k+1 = 2*WA.length()+1 by Def15;
      then consider WB being Path of WA such that
A8:   WB is directed by A2;
A9:   WA.edgeSeq() c= W1.edgeSeq() by Lm43;
A10:  WB is_Walk_from WA.first(), WA.last() by Def32;
A11:  1 <= 2*k+1 by NAT_1:12;
      then
A12:  WA.last() = W1.(2*k+1) by A5,Lm16,JORDAN12:3;
A13:  WA.first() = W1.1 by A5,A11,Lm16,JORDAN12:3;
      then
A14:  WB.first() = W1.1 by A10,Def23;
A15:  WB.last() = W1.(2*k+1) by A10,A12,Def23;
      then
A16:  e Joins WB.last(), v, G by A6,GLIB_000:19;
      now
        per cases;
        suppose
A17:      WB is closed;
          set W2 = W1.remove(1,2*k+1);
          W1.first() = W1.(2*k+1) by A14,A15,A17,Def24;
          then W2 = W1.cut(2*k+1, 2*k+1+2) by A4,Lm32;
          then len W2 + (2*k+1) = 2*k+1+2+1 by A4,A5,Lm15
            .= 2*k+1+(2+1);
          then reconsider W2 as Path of W1 by Lm69;
          take W2;
          thus W2 is directed;
        end;
        suppose
A18:      WB is open;
          consider esb being Subset of WA.edgeSeq() such that
A19:      WB.edgeSeq() = Seq esb by Def32;
A20:      Seq esb is one-to-one by A19,Def27;
A21:      Seq esb = esb * (Sgm (dom esb)) by FINSEQ_1:def 14;
A22:      now
            let x be set;
            assume x in dom esb;
            then [x,esb.x] in esb by FUNCT_1:8;
            then x in dom WA.edgeSeq() by FUNCT_1:8;
            hence x in Seg k by A7,FINSEQ_1:def 3;
          end;
          then
A23:      dom esb c= Seg k by TARSKI:def 3;
          then rng Sgm(dom esb) = dom esb by FINSEQ_1:def 13;
          then
A24:      Sgm(dom esb) is one-to-one by A21,A20,FUNCT_1:48;
          now
            per cases;
            suppose
A25:          v in WB.vertices();
              reconsider WB9 = WB as directed Path of G by A8;
A26:          dom Sgm(dom esb) = dom WB.edgeSeq() by A19,Th6
                .= Seg len WB.edgeSeq() by FINSEQ_1:def 3;
              consider n being odd Element of NAT such that
A27:          n <= len WB and
A28:          WB.n = v by A25,Lm45;
              set W2 = WB9.cut(1,n);
              len W2 = n by A27,Lm22;
              then consider naa1 being even Element of NAT such that
A29:          naa1 = n - 1 and
A30:          len W2.edgeSeq() = naa1 div 2 by Lm42;
              2*0+1 <= n by ABIAN:12;
              then
A31:          W2 is_Walk_from W1.first(), W1.last() by A4,A14,A27,A28,Lm16;
              2 divides naa1 by PEPIN:22;
              then
A32:          2*(naa1 div 2) = naa1 by NAT_D:3;
              now
                assume naa1 div 2 > len WB.edgeSeq();
                then naa1 > 2 * len WB.edgeSeq() by A32,XREAL_1:70;
                then naa1+1 > 2*len WB.edgeSeq() + 1 by XREAL_1:10;
                hence contradiction by A27,A29,Def15;
              end;
              then Seg (naa1 div 2) c= dom Sgm (dom esb) by A26,FINSEQ_1:7;
              then
A33:          dom (Sgm(dom esb)| Seg(naa1 div 2)) = Seg ( naa1 div 2) by
RELAT_1:91;
              then reconsider
              ses = Sgm(dom esb)|Seg(naa1 div 2) as FinSequence by
FINSEQ_1:def 2;
A34:          ses is one-to-one by A24,FUNCT_1:84;
              set es = esb | (rng (Sgm (dom esb) | Seg (naa1 div 2)));
              reconsider es as Subset of WA.edgeSeq() by GRAPH_2:29;
              for x being set st x in es holds x in W1.edgeSeq() by A9,
TARSKI:def 3;
              then reconsider es as Subset of W1.edgeSeq() by TARSKI:def 3;
              reconsider esbes1 = esb \ es as Function;
              now
                let z be set;
A35:            rng (Sgm (dom esb) | Seg (naa1 div 2)) c= rng Sgm (dom
                esb ) by RELAT_1:99;
                assume z in rng (Sgm (dom esb) | Seg (naa1 div 2));
                then z in rng Sgm (dom esb) by A35;
                hence z in dom esb by A23,FINSEQ_1:def 13;
              end;
              then rng (Sgm (dom esb) | Seg (naa1 div 2)) c= dom esb by
TARSKI:def 3;
              then
A36:          dom es = rng (Sgm (dom esb) | Seg (naa1 div 2) ) by RELAT_1:91;
A37:          now
                let a,b be Element of NAT;
                assume that
A38:            a in dom es and
A39:            b in dom (esbes1);
                consider xa being set such that
A40:            xa in dom ses and
A41:            ses.xa = a by A36,A38,FUNCT_1:def 5;
                reconsider xa as Element of NAT by A40;
A42:            xa in Seg(naa1 div 2) by A40,RELAT_1:86;
                then
A43:            1 <= xa by FINSEQ_1:3;
A44:            [b, esbes1.b] in esb \ es by A39,FUNCT_1:8;
                then
A45:            [b, esbes1.b] in esb by XBOOLE_0:def 5;
                then b in dom esb by FUNCT_1:8;
                then b in rng (Sgm (dom esb)) by A23,FINSEQ_1:def 13;
                then consider xb being set such that
A46:            xb in dom (Sgm (dom esb)) and
A47:            Sgm(dom esb).xb = b by FUNCT_1:def 5;
                reconsider xb as Element of NAT by A46;
A48:            1 <= xb by A26,A46,FINSEQ_1:3;
A49:            xa <= naa1 div 2 by A42,FINSEQ_1:3;
A50:            now
                  assume xb <= xa;
                  then xb <= naa1 div 2 by A49,XXREAL_0:2;
                  then
A51:              xb in Seg(naa1 div 2) by A48,FINSEQ_1:3;
                  [xb, b] in Sgm(dom esb) by A46,A47,FUNCT_1:8;
                  then [xb, b] in ses by A51,RELAT_1:def 11;
                  then b in rng ses by RELAT_1:def 5;
                  then [b, esbes1.b] in es by A45,RELAT_1:def 11;
                  hence contradiction by A44,XBOOLE_0:def 5;
                end;
                xb <= len WB.edgeSeq() by A26,A46,FINSEQ_1:3;
                then xb in dom Seq esb by A19,A48,FINSEQ_3:27;
                then xb in dom Sgm (dom esb) by Th6;
                then
A52:            xb <= len Sgm(dom esb) by FINSEQ_3:27;
                a = Sgm(dom esb).xa by A40,A41,FUNCT_1:70;
                hence a < b by A23,A47,A43,A52,A50,FINSEQ_1:def 13;
              end;
              len ses = naa1 div 2 by A33,FINSEQ_1:def 3;
              then card dom es = naa1 div 2 by A36,A34,FINSEQ_4:77;
              then card es = naa1 div 2 by CARD_1:104;
              then
A53:          len Seq es = len W2.edgeSeq() by A30,Th5;
A54:          es c= esb by RELAT_1:88;
              now
                let z be set;
                hereby
                  assume
A55:              z in esb;
                  now
                    per cases;
                    suppose
                      z in es;
                      hence z in es \/ (esb \ es) by XBOOLE_0:def 3;
                    end;
                    suppose
                      not z in es;
                      then z in esb \ es by A55,XBOOLE_0:def 5;
                      hence z in es \/ (esb \ es) by XBOOLE_0:def 3;
                    end;
                  end;
                  hence z in es \/ (esb \ es);
                end;
                assume
A56:            z in es \/ (esb \ es);
                now
                  per cases by A56,XBOOLE_0:def 3;
                  suppose
                    z in es;
                    hence z in esb by A54;
                  end;
                  suppose
                    z in esb \ es;
                    hence z in esb by XBOOLE_0:def 5;
                  end;
                end;
                hence z in esb;
              end;
              then esb = es \/ (esb \ es) by TARSKI:2;
              then
A57:          dom esb = dom es \/ dom (esb \ es) by RELAT_1:13;
              esb \ es c= esb by XBOOLE_1:36;
              then dom (esb \ es) c= dom esb by RELAT_1:25;
              then
A58:          dom (esb \ es) c= Seg k by A23,XBOOLE_1:1;
              dom es c= dom esb by A54,RELAT_1:25;
              then dom es c= Seg k by A23,XBOOLE_1:1;
              then
A59:          Sgm(dom esb) = Sgm(dom es) ^ Sgm(dom (esb \ es )) by A57,A58,A37,
FINSEQ_3:48;
A60:          W2.edgeSeq() c= WB.edgeSeq() by Lm43;
              then
A61:          dom W2.edgeSeq() c= dom Seq esb by A19,RELAT_1:25;
A62:          Seq es = es * Sgm (dom es) by FINSEQ_1:def 14;
              now
                let x be Nat;
                assume that
A63:            1 <= x and
A64:            x <= len W2.edgeSeq();
A65:            x in dom W2.edgeSeq() by A63,A64,FINSEQ_3:27;
                then x in dom Sgm(dom esb) by A21,A61,FUNCT_1:21;
                then
A66:            [x, Sgm(dom esb).x] in Sgm(dom esb) by FUNCT_1:8;
                x in Seg (naa1 div 2) by A30,A63,A64,FINSEQ_1:3;
                then [x, Sgm(dom esb).x] in ses by A66,RELAT_1:def 11;
                then
A67:            Sgm(dom esb).x in rng ses by RELAT_1:def 5;
                Sgm(dom esb).x in dom esb by A21,A61,A65,FUNCT_1:21;
                then [Sgm(dom esb).x, esb.(Sgm(dom esb).x)] in esb by FUNCT_1:8
;
                then
A68:            [Sgm(dom esb).x, esb.(Sgm(dom esb).x)] in es by A67,
RELAT_1:def 11;
                [x,W2.edgeSeq().x] in W2.edgeSeq() by A65,FUNCT_1:8;
                then
A69:            W2.edgeSeq().x = (Seq esb).x by A19,A60,FUNCT_1:8
                  .= esb.(Sgm(dom esb).x) by A21,A61,A65,FUNCT_1:22;
A70:            x in dom Seq es by A53,A63,A64,FINSEQ_3:27;
                then x in dom Sgm(dom es) by Th6;
                then Sgm(dom esb).x = Sgm(dom es).x by A59,FINSEQ_1:def 7;
                then es.(Sgm(dom es).x) = esb.(Sgm(dom esb).x) by A68,FUNCT_1:8
;
                hence W2.edgeSeq().x = (Seq es).x by A62,A69,A70,FUNCT_1:22;
              end;
              then W2.edgeSeq() = Seq es by A53,FINSEQ_1:18;
              then reconsider W2 as Path of W1 by A31,Def32;
              take W2;
              thus W2 is directed;
            end;
            suppose
A71:          not v in WB.vertices();
              set es = esb +* ((k+1) .--> e);
              set W2 = WB.addEdge(e);
A72:          now
                let m, n be Element of NAT;
                assume that
A73:            m in dom esb and
A74:            n in {k+1};
A75:            n = k+1 by A74,TARSKI:def 1;
                m <= k by A23,A73,FINSEQ_1:3;
                hence m < n by A75,NAT_1:13;
              end;
A76:          dom ((k+1) .--> e) = {k+1} by FUNCOP_1:19;
              then
A77:          dom es = dom esb \/ {k+1} by FUNCT_4:def 1;
              now
                let x be set;
                assume
A78:            x in dom es;
                now
                  per cases by A77,A78,XBOOLE_0:def 3;
                  suppose
                    x in dom esb;
                    then
A79:                x in Seg k by A22;
                    then reconsider x9=x as Element of NAT;
                    x9 <= k by A79,FINSEQ_1:3;
                    then
A80:                x9 <= k+1 by NAT_1:12;
                    1 <= x9 by A79,FINSEQ_1:3;
                    hence x in Seg (k+1) by A80,FINSEQ_1:3;
                  end;
                  suppose
A81:                x in {k+1};
A82:                1 <= k+1 by NAT_1:12;
                    x = k+1 by A81,TARSKI:def 1;
                    hence x in Seg (k+1) by A82,FINSEQ_1:3;
                  end;
                end;
                hence x in Seg (k+1);
              end;
              then
A83:          dom es c= Seg (k+1) by TARSKI:def 3;
              then reconsider es as FinSubsequence by FINSEQ_1:def 12;
              now
                let z be set;
                assume
A84:            z in es;
                then consider x,y being set such that
A85:            z = [x,y] by RELAT_1:def 1;
A86:            x in dom es by A84,A85,FUNCT_1:8;
A87:            es.x = y by A84,A85,FUNCT_1:8;
                now
                  per cases;
                  suppose
A88:                x in dom ((k+1) .--> e);
                    then reconsider x9 = x as Element of NAT by A76;
A89:                x = k+1 by A76,A88,TARSKI:def 1;
                    then
A90:                1 <= x9 by NAT_1:12;
                    then
A91:                x in dom W1.edgeSeq() by A3,A89,FINSEQ_3:27;
                    y = ((k+1).-->e).x by A76,A77,A86,A87,A88,FUNCT_4:def 1;
                    then
A92:                y = e by A89,FUNCOP_1:87;
                    W1.edgeSeq().x = W1.(2*(k+1)) by A3,A89,A90,Def15
                      .= W1.(2*k+1+1);
                    hence z in W1.edgeSeq() by A85,A92,A91,FUNCT_1:8;
                  end;
                  suppose
A93:                not x in dom ((k+1) .--> e);
                    then
A94:                x in dom esb by A76,A77,A86,XBOOLE_0:def 3;
                    y = esb.x by A76,A77,A86,A87,A93,FUNCT_4:def 1;
                    then [x,y] in esb by A94,FUNCT_1:8;
                    then [x,y] in WA.edgeSeq();
                    hence z in W1.edgeSeq() by A9,A85;
                  end;
                end;
                hence z in W1.edgeSeq();
              end;
              then reconsider es as Subset of W1.edgeSeq() by TARSKI:def 3;
              {k+1} c= Seg (k+1) by A77,A83,XBOOLE_1:11;
              then
A95:          Sgm(dom es)=Sgm(dom esb) ^ Sgm({k+1}) by A23,A77,A72,FINSEQ_3:48
                .=Sgm(dom esb) ^ <* k+1 *> by FINSEQ_3:50;
              now
                assume dom esb /\ dom ((k+1).-->e) <> {};
                then consider x being set such that
A96:            x in dom esb /\ dom ((k+1).-->e) by XBOOLE_0:def 1;
                x in {k+1} by A76,A96,XBOOLE_0:def 4;
                then
A97:            x = k+1 by TARSKI:def 1;
                x in dom esb by A96,XBOOLE_0:def 4;
                then k+1 <= k+0 by A23,A97,FINSEQ_1:3;
                hence contradiction by XREAL_1:8;
              end;
              then
A98:          dom esb misses dom ((k+1).-->e) by XBOOLE_0:def 7;
A99:          W2.edgeSeq() = Seq esb ^ <*e*> by A16,A19,Lm44;
              then
A100:         len W2.edgeSeq() = len Seq esb + len <*e*> by FINSEQ_1:35
                .= len Seq esb + 1 by FINSEQ_1:56
                .= card esb + 1 by Th5;
A101:         len Seq es = card es by Th5
                .= card esb + card ((k+1).-->e) by A98,PRE_CIRC:27
                .= card esb + card {[k+1,e]} by FUNCT_4:87
                .= len W2.edgeSeq() by A100,CARD_1:50;
              now
A102:           Seq es = es * Sgm(dom es) by FINSEQ_1:def 14;
                let n be Nat;
                assume that
A103:           1 <= n and
A104:           n <= len W2.edgeSeq();
                n in dom Seq es by A101,A103,A104,FINSEQ_3:27;
                then
A105:           (Seq es).n = es.(Sgm(dom es).n) by A102,FUNCT_1:22;
A106:           Seq esb = esb * Sgm(dom esb) by FINSEQ_1:def 14;
A107:           n in dom W2.edgeSeq() by A103,A104,FINSEQ_3:27;
                now
                  per cases by A99,A107,FINSEQ_1:38;
                  suppose
A108:               n in dom Seq esb;
                    then n in dom Sgm(dom esb) by A106,FUNCT_1:21;
                    then
A109:               Sgm(dom es).n=Sgm(dom esb).n by A95,FINSEQ_1:def 7;
A110:               Sgm(dom esb).n in dom esb by A106,A108,FUNCT_1:21;
                    W2.edgeSeq().n = (Seq esb).n by A99,A108,FINSEQ_1:def 7
                      .= esb.(Sgm(dom esb).n) by A106,A108,FUNCT_1:22;
                    hence W2.edgeSeq().n = (Seq es).n by A98,A105,A110,A109,
FUNCT_4:17;
                  end;
                  suppose
                    ex m being Nat st m in dom <*e*> & n = len Seq esb + m;
                    then consider m being Nat such that
A111:               m in dom <*e*> and
A112:               n = len Seq esb + m;
                    m in {1} by A111,FINSEQ_1:4,def 8;
                    then
A113:               m = 1 by TARSKI:def 1;
A114:               k+1 in dom ((k+1).-->e) by A76,TARSKI:def 1;
                    then
A115:               k+1 in dom esb \/ dom ((k+1).-->e) by XBOOLE_0:def 3;
                    len Sgm(dom esb) = card dom esb by A23,FINSEQ_3:44
                      .= card esb by CARD_1:104
                      .= len Seq esb by Th5;
                    then (Seq es).n = es.(k+1) by A95,A105,A112,A113,
FINSEQ_1:59;
                    then
A116:               (Seq es).n = ((k+1).-->e).(k+1) by A114,A115,FUNCT_4:def 1
                      .= e by FUNCOP_1:87;
                    W2.edgeSeq().n = <*e*>.1 by A99,A111,A112,A113,
FINSEQ_1:def 7
                      .= e by FINSEQ_1:def 8;
                    hence W2.edgeSeq().n = (Seq es).n by A116;
                  end;
                end;
                hence W2.edgeSeq().n = (Seq es).n;
              end;
              then
A117:         W2.edgeSeq() = Seq es by A101,FINSEQ_1:18;
              W2 is_Walk_from W1.first(), W1.last() by A4,A8,A6,A10,A13,A12
,Lm52;
              then reconsider W2 as Path of W1 by A16,A18,A71,A117,Def32,Lm68;
              take W2;
              thus W2 is directed by A8,A6,A10,A12,Lm52;
            end;
          end;
          hence ex W2 being Path of W1 st W2 is directed;
        end;
      end;
      hence ex W2 being Path of W1 st W2 is directed;
    end;
    then
A118: for k being Element of NAT st P[k] holds P[k+1];
    now
      let W1 be DWalk of G;
      consider W2 being Path of W1;
      assume W1.length() = 0;
      then len W1 = 2*0+1 by Def15;
      then
A119: len W2 <= 1 by Lm72;
      take W2;
      1 <= len W2 by ABIAN:12;
      then len W2 = 1 by A119,XXREAL_0:1;
      then W2 is trivial by Lm55;
      then ex v being Vertex of G st W2 = G.walkOf(v) by Lm56;
      hence W2 is directed;
    end;
    then
A120: P[0];
    for k being Element of NAT holds P[k] from NAT_1:sch 1(A120,A118);
    hence thesis by A1;
  end;
end;

definition
  let G be _Graph, W be DWalk of G;
  mode DWalk of W is directed Subwalk of W;
  mode DTrail of W is directed Trail of W;
  mode DPath of W is directed Path of W;
end;

definition
  let G be _Graph;
  func G.allWalks()-> non empty Subset of ((the_Vertices_of G)\/(the_Edges_of
  G))* equals
  {W where W is Walk of G : not contradiction};
  coherence
  proof
    set IT = {W where W is Walk of G : not contradiction};
A1: now
      let x be set;
      assume x in IT;
      then ex W being Walk of G st x = W;
      hence x in ((the_Vertices_of G)\/(the_Edges_of G))* by FINSEQ_1:def 11;
    end;
    G.walkOf(choose(the_Vertices_of G)) in IT;
    hence thesis by A1,TARSKI:def 3;
  end;
end;

definition
  let G be _Graph;
  func G.allTrails() -> non empty Subset of G.allWalks() equals
  {W where W is
  Trail of G : not contradiction};
  coherence
  proof
    set IT = {W where W is Trail of G : not contradiction};
A1: now
      let e be set;
      assume e in IT;
      then ex W being Trail of G st W = e;
      hence e in G.allWalks();
    end;
    G.walkOf(choose(the_Vertices_of G)) in IT;
    hence thesis by A1,TARSKI:def 3;
  end;
end;

definition
  let G be _Graph;
  func G.allPaths() -> non empty Subset of G.allTrails() equals
  {W where W is
  Path of G : not contradiction};
  coherence
  proof
    set IT = {W where W is Path of G : not contradiction};
A1: now
      let e be set;
      assume e in IT;
      then ex W being Path of G st e = W;
      hence e in G.allTrails();
    end;
    G.walkOf(choose(the_Vertices_of G)) in IT;
    hence thesis by A1,TARSKI:def 3;
  end;
end;

definition
  let G be _Graph;
  func G.allDWalks() -> non empty Subset of G.allWalks() equals
  {W where W is
  DWalk of G : not contradiction};
  coherence
  proof
    set IT = {W where W is directed Walk of G : not contradiction};
A1: now
      let e be set;
      assume e in IT;
      then ex W being directed Walk of G st e = W;
      hence e in G.allWalks();
    end;
    G.walkOf(choose(the_Vertices_of G)) in IT;
    hence thesis by A1,TARSKI:def 3;
  end;
end;

definition
  let G be _Graph;
  func G.allDTrails() -> non empty Subset of G.allTrails() equals
  {W where W
  is DTrail of G : not contradiction};
  coherence
  proof
    set IT = {W where W is DTrail of G : not contradiction};
A1: now
      let e be set;
      assume e in IT;
      then ex W being DTrail of G st e = W;
      hence e in G.allTrails();
    end;
    G.walkOf(choose(the_Vertices_of G)) in IT;
    hence thesis by A1,TARSKI:def 3;
  end;
end;

definition
  let G be _Graph;
  func G.allDPaths() -> non empty Subset of G.allDTrails() equals
  {W where W
  is directed Path of G : not contradiction};
  coherence
  proof
    set IT = {W where W is DPath of G : not contradiction};
A1: now
      let e be set;
      assume e in IT;
      then ex W being DPath of G st e = W;
      hence e in G.allDTrails();
    end;
    G.walkOf(choose(the_Vertices_of G)) in IT;
    hence thesis by A1,TARSKI:def 3;
  end;
end;

registration
  let G be finite _Graph;
  cluster G.allTrails() -> finite;
  correctness
  proof
    set D = (the_Vertices_of G)\/(the_Edges_of G);
    set X = {x where x is Element of D* : len x <= 2*G.size()+1};
A1: now
      let W be Trail of G;
      consider f being Function such that
A2:   dom f = W.edgeSeq() & for x being set st x in W.edgeSeq() holds
      f.x = x`2 from FUNCT_1:sch 3;
      now
A3:     W.edgeSeq() is one-to-one by Def27;
        let x1,x2 be set;
        assume that
A4:     x1 in dom f and
A5:     x2 in dom f and
A6:     f.x1 = f.x2;
        consider a1,b1 being set such that
A7:     x1 = [a1,b1] by A2,A4,RELAT_1:def 1;
A8:     a1 in dom W.edgeSeq() by A2,A4,A7,FUNCT_1:8;
A9:     f.x2 = x2`2 by A2,A5;
A10:    W.edgeSeq().a1 = b1 by A2,A4,A7,FUNCT_1:8;
        consider a2,b2 being set such that
A11:    x2 = [a2,b2] by A2,A5,RELAT_1:def 1;
A12:    a2 in dom W.edgeSeq() by A2,A5,A11,FUNCT_1:8;
        f.x1 = x1`2 by A2,A4;
        then
A13:    b1 = f.x1 by A7,MCART_1:def 2
          .= b2 by A6,A9,A11,MCART_1:def 2;
        then W.edgeSeq().a2 = b1 by A2,A5,A11,FUNCT_1:8;
        hence x1 = x2 by A7,A11,A13,A3,A8,A10,A12,FUNCT_1:def 8;
      end;
      then
A14:  f is one-to-one by FUNCT_1:def 8;
      now
        let y be set;
        assume y in rng f;
        then consider x being set such that
A15:    x in dom f and
A16:    f.x = y by FUNCT_1:def 5;
        consider a,b being set such that
A17:    x = [a,b] by A2,A15,RELAT_1:def 1;
        y = x`2 by A2,A15,A16;
        then y = b by A17,MCART_1:def 2;
        then y in rng W.edgeSeq() by A2,A15,A17,RELAT_1:def 5;
        hence y in (the_Edges_of G);
      end;
      then rng f c= the_Edges_of G by TARSKI:def 3;
      then card W.edgeSeq() c= card (the_Edges_of G) by A2,A14,CARD_1:26;
      then len W.edgeSeq() <= card (the_Edges_of G) by NAT_1:40;
      then len W.edgeSeq() <= G.size() by GLIB_000:def 27;
      then 2*len W.edgeSeq() <= 2*G.size() by XREAL_1:66;
      then 2*len W.edgeSeq()+1 <= 2*G.size()+1 by XREAL_1:9;
      hence len W <= 2*G.size()+1 by Def15;
    end;
    now
      let e be set;
      assume e in G.allTrails();
      then consider W being Trail of G such that
A18:  W = e;
A19:  len W <= 2*G.size()+1 by A1;
      e is Element of D* by A18,FINSEQ_1:def 11;
      hence e in X by A18,A19;
    end;
    then G.allTrails() c= X by TARSKI:def 3;
    hence thesis by FINSET_1:13,GRAPH_5:4;
  end;
end;

definition
  let G be _Graph, X be non empty Subset of G.allWalks();
  redefine mode Element of X -> Walk of G;
  coherence
  proof
    let x be Element of X;
    x in {W where W is Walk of G : not contradiction};
    then ex y being Walk of G st y = x;
    hence thesis;
  end;
end;

definition
  let G be _Graph, X be non empty Subset of G.allTrails();
  redefine mode Element of X -> Trail of G;
  coherence
  proof
    let x be Element of X;
    x in {W where W is Trail of G : not contradiction};
    then ex y being Trail of G st y = x;
    hence thesis;
  end;
end;

definition
  let G be _Graph, X be non empty Subset of G.allPaths();
  redefine mode Element of X -> Path of G;
  coherence
  proof
    let x be Element of X;
    x in {W where W is Path of G : not contradiction};
    then ex y being Path of G st y = x;
    hence thesis;
  end;
end;

definition
  let G be _Graph, X be non empty Subset of G.allDWalks();
  redefine mode Element of X -> DWalk of G;
  coherence
  proof
    let x be Element of X;
    x in {W where W is DWalk of G : not contradiction};
    then ex y being DWalk of G st y = x;
    hence thesis;
  end;
end;

definition
  let G be _Graph, X be non empty Subset of G.allDTrails();
  redefine mode Element of X -> DTrail of G;
  coherence
  proof
    let x be Element of X;
    x in {W where W is DTrail of G : not contradiction};
    then ex y being DTrail of G st y = x;
    hence thesis;
  end;
end;

definition
  let G be _Graph, X be non empty Subset of G.allDPaths();
  redefine mode Element of X -> DPath of G;
  coherence
  proof
    let x be Element of X;
    x in {W where W is DPath of G : not contradiction};
    then ex y being DPath of G st y = x;
    hence thesis;
  end;
end;

begin :: Theorems

reserve G,G1,G2 for _Graph;
reserve W,W1,W2 for Walk of G;
reserve e,x,y,z for set;
reserve v for Vertex of G;
reserve n,m for Element of NAT;

canceled;

theorem
  for n being odd Element of NAT st n <= len W holds W.n in
  the_Vertices_of G by Lm1;

theorem Th9:
  for n being even Element of NAT st n in dom W holds W.n in the_Edges_of G
proof
  let n be even Element of NAT;
  assume
A1: n in dom W;
  then 1 <= n by FINSEQ_3:27;
  then reconsider naa1 = n-1 as odd Element of NAT by INT_1:18;
  n <= len W by A1,FINSEQ_3:27;
  then naa1 < len W - 0 by XREAL_1:17;
  then W.(naa1+1) Joins W.naa1, W.(naa1+2), G by Def3;
  hence thesis by GLIB_000:def 15;
end;

theorem
  for n being even Element of NAT st n in dom W holds ex naa1 being odd
Element of NAT st naa1 = n-1 & n-1 in dom W & n+1 in dom W & W.n Joins W.(naa1)
  , W.(n+1),G by Lm2;

theorem Th11:
  for n being odd Element of NAT st n < len W holds W.(n+1) in W
  .vertexAt(n).edgesInOut()
proof
  let n be odd Element of NAT;
  assume
A1: n < len W;
  then
A2: W.vertexAt(n) = W.n by Def8;
  W.(n+1) Joins W.n, W.(n+2), G by A1,Def3;
  hence thesis by A2,GLIB_000:65;
end;

theorem Th12:
  for n being odd Element of NAT st 1 < n & n <= len W holds W.(n-
  1) in W.vertexAt(n).edgesInOut()
proof
  let n be odd Element of NAT;
  assume that
A1: 1 < n and
A2: n <= len W;
  reconsider naa1 = n-1 as even Element of NAT by A1,INT_1:18;
  1+1 <= n by A1,NAT_1:13;
  then
A3: 1+1-1 <= n-1 by XREAL_1:15;
  n - 1 <= len W - 0 by A2,XREAL_1:15;
  then naa1 in dom W by A3,FINSEQ_3:27;
  then consider n5 being odd Element of NAT such that
A4: n5 = naa1-1 and
A5: naa1-1 in dom W and
  naa1+1 in dom W and
A6: W.naa1 Joins W.(n5), W.(naa1+1),G by Lm2;
  n5 <= len W by A4,A5,FINSEQ_3:27;
  then W.(n5) = W.vertexAt(n5) by Def8;
  then W.(n-1) Joins W.vertexAt(n5), W.vertexAt(n), G by A2,A6,Def8;
  hence thesis by GLIB_000:17,65;
end;

theorem
  for n being odd Element of NAT st n < len W holds n in dom W & n+1 in
  dom W & n+2 in dom W
proof
  let n be odd Element of NAT;
A1: 1 <= n by ABIAN:12;
A2: 1 <= n+1 by NAT_1:12;
A3: 1 <= n+2 by NAT_1:12;
  assume
A4: n < len W;
  then
A5: n+1 <= len W by NAT_1:13;
  n+2 <= len W by A4,Th1;
  hence thesis by A4,A1,A2,A3,A5,FINSEQ_3:27;
end;

theorem Th14:
  len G.walkOf(v) = 1 & G.walkOf(v).1 = v & G.walkOf(v).first() =
  v & G.walkOf(v).last() = v & G.walkOf(v) is_Walk_from v,v
proof
  thus
A1: len G.walkOf(v) = 1 & G.walkOf(v).1 = v by FINSEQ_1:57;
  thus
A2: G.walkOf(v).first() = v by FINSEQ_1:57;
  thus G.walkOf(v).last() = v by A1;
  hence thesis by A2,Def23;
end;

theorem Th15:
  e Joins x,y,G implies len G.walkOf(x,e,y) = 3
proof
  assume e Joins x,y,G;
  then G.walkOf(x,e,y) = <*x,e,y*> by Def5;
  hence thesis by FINSEQ_1:62;
end;

theorem Th16:
  e Joins x,y,G implies G.walkOf(x,e,y).first() = x & G.walkOf(x,e
  ,y).last() = y & G.walkOf(x,e,y) is_Walk_from x,y
proof
  set W = G.walkOf(x,e,y);
  assume e Joins x,y,G;
  then
A1: W = <*x,e,y*> by Def5;
  hence
A2: W.first() = x by FINSEQ_1:62;
  len W = 3 by A1,FINSEQ_1:62;
  hence W.last() = y by A1,FINSEQ_1:62;
  hence thesis by A2,Def23;
end;

theorem
  for W1 being Walk of G1, W2 being Walk of G2 st W1 = W2 holds W1
  .first() = W2.first() & W1.last() = W2.last();

theorem Th18:
  W is_Walk_from x,y iff W.1 = x & W.(len W) = y
proof
  W is_Walk_from x,y iff W.first() = x & W.last() = y by Def23;
  hence thesis;
end;

theorem
  W is_Walk_from x,y implies x is Vertex of G & y is Vertex of G
proof
  assume
A1: W is_Walk_from x,y;
  then
A2: W.last() = y by Def23;
  W.first() = x by A1,Def23;
  hence thesis by A2;
end;

theorem
  for W1 being Walk of G1, W2 being Walk of G2 st W1 = W2 holds W1
  is_Walk_from x,y iff W2 is_Walk_from x,y
proof
  let W1 be Walk of G1, W2 be Walk of G2;
  assume
A1: W1 = W2;
  W1 is_Walk_from x,y iff W1.first() = x & W1.last() = y by Def23;
  then W1 is_Walk_from x,y iff W2.first() = x & W2.last() = y by A1;
  hence thesis by Def23;
end;

theorem
  for W1 being Walk of G1, W2 being Walk of G2 st W1 = W2 holds for n
  being Element of NAT holds W1.vertexAt(n) = W2.vertexAt(n)
proof
  let W1 be Walk of G1, W2 be Walk of G2;
  assume
A1: W1 = W2;
  let n be Element of NAT;
  now
    per cases;
    suppose
A2:   n is odd & n <= len W1;
      hence W1.vertexAt(n) = W2.n by A1,Def8
        .= W2.vertexAt(n) by A1,A2,Def8;
    end;
    suppose
A3:   not (n is odd & n <= len W1);
      hence W1.vertexAt(n) = W1.first() by Def8
        .= W2.first() by A1
        .= W2.vertexAt(n) by A1,A3,Def8;
    end;
  end;
  hence thesis;
end;

theorem
  len W = len W.reverse() & dom W = dom W.reverse() & rng W = rng W
  .reverse() by FINSEQ_5:60,def 3;

theorem Th23:
  W.first() = W.reverse().last() & W.last() = W.reverse().first()
proof
  len W = len W.reverse() by FINSEQ_5:def 3;
  hence W.first() = W.reverse().last() by FINSEQ_5:65;
  thus thesis by FINSEQ_5:65;
end;

theorem Th24:
  W is_Walk_from x,y iff W.reverse() is_Walk_from y, x
proof
A1: len W = len W.reverse() by FINSEQ_5:def 3;
  hereby
    assume
A2: W is_Walk_from x, y;
    then W.(len W) = y by Th18;
    then
A3: W.reverse().1 = y by FINSEQ_5:65;
    W.1 = x by A2,Th18;
    then W.reverse().(len W) = x by FINSEQ_5:65;
    hence W.reverse() is_Walk_from y,x by A1,A3,Th18;
  end;
  assume
A4: W.reverse() is_Walk_from y,x;
  then W.reverse().1=y by Th18;
  then
A5: W.(len W) = y by FINSEQ_5:65;
  W.reverse().(len W.reverse())=x by A4,Th18;
  then W.1 = x by A1,FINSEQ_5:65;
  hence thesis by A5,Th18;
end;

theorem Th25:
  n in dom W implies W.n = W.reverse().(len W - n + 1) & (len W -
  n + 1) in dom W.reverse()
proof
  set rn = len W - n + 1;
  assume
A1: n in dom W;
  then n <= len W by FINSEQ_3:27;
  then reconsider rn as Element of NAT by FINSEQ_5:1;
  n in Seg len W by A1,FINSEQ_1:def 3;
  then len W - n + 1 in Seg len W by FINSEQ_5:2;
  then
A2: rn in Seg len W.reverse() by FINSEQ_5:def 3;
  then rn in dom W.reverse() by FINSEQ_1:def 3;
  then W.reverse().rn = W.(len W - rn + 1) by FINSEQ_5:def 3;
  hence thesis by A2,FINSEQ_1:def 3;
end;

theorem
  n in dom W.reverse() implies W.reverse().n = W.(len W - n + 1) & (len
  W - n + 1) in dom W by Lm8;

theorem
  W.reverse().reverse() = W by FINSEQ_6:29;

theorem
  for W1 being Walk of G1, W2 being Walk of G2 st W1 = W2 holds W1
  .reverse() = W2.reverse();

theorem
  W1.last() = W2.first() implies len W1.append(W2) + 1 = len W1 + len W2
  by Lm9;

theorem
  W1.last() = W2.first() implies len W1 <= len W1.append(W2) & len W2 <=
  len W1.append(W2) by Lm10;

theorem
  W1.last() = W2.first() implies W1.append(W2).first() = W1.first() & W1
  .append(W2).last() = W2.last() & W1.append(W2) is_Walk_from W1.first(), W2
  .last() by Lm11;

theorem Th32:
  W1 is_Walk_from x,y & W2 is_Walk_from y,z implies W1.append(W2)
  is_Walk_from x,z
proof
  assume that
A1: W1 is_Walk_from x, y and
A2: W2 is_Walk_from y,z;
A3: W1.last() = y by A1,Def23;
A4: W2.last() = z by A2,Def23;
A5: W2.first() = y by A2,Def23;
  W1.first() = x by A1,Def23;
  hence thesis by A3,A5,A4,Lm11;
end;

theorem
  n in dom W1 implies W1.append(W2).n = W1.n & n in dom W1.append(W2) by Lm12;

theorem
  W1.last() = W2.first() implies for n being Element of NAT st n < len
W2 holds W1.append(W2).(len W1 + n) = W2.(n+1) & (len W1 + n) in dom W1.append(
  W2) by Lm13;

theorem
  n in dom W1.append(W2) implies n in dom W1 or ex k being Element of
  NAT st k < len W2 & n = len W1 + k by Lm14;

theorem Th36:
  for W1A, W1B being Walk of G1, W2A,W2B being Walk of G2 st W1A =
  W2A & W1B = W2B holds W1A.append(W1B) = W2A.append(W2B)
proof
  let W1A, W1B be Walk of G1, W2A, W2B be Walk of G2;
  assume that
A1: W1A = W2A and
A2: W1B = W2B;
  now
    per cases;
    suppose
A3:   W1A.last() = W1B.first();
      then
A4:   W2A.last() = W2B.first() by A1,A2;
      thus W1A.append(W1B) = W1A ^' W1B by A3,Def10
        .= W2A.append(W2B) by A1,A2,A4,Def10;
    end;
    suppose
A5:   W1A.last() <> W1B.first();
      then
A6:   W2A.last() <> W2B.first() by A1,A2;
      thus W1A.append(W1B) = W2A by A1,A5,Def10
        .= W2A.append(W2B) by A6,Def10;
    end;
  end;
  hence thesis;
end;

theorem
  for m,n being odd Element of NAT st m <= n & n <= len W holds len W
.cut(m,n) + m = n+1 & for i being Element of NAT st i < len W.cut(m,n) holds W
  .cut(m,n).(i+1) = W.(m+i) & m+i in dom W by Lm15;

theorem
  for m, n being odd Element of NAT st m <= n & n <= len W holds W.cut(m
,n).first() = W.m & W.cut(m,n).last() = W.n & W.cut(m,n) is_Walk_from W.m, W.n
  by Lm16;

theorem
  for m,n,o being odd Element of NAT st m <= n & n <= o & o <= len W
  holds W.cut(m,n).append(W.cut(n,o)) = W.cut(m,o) by Lm17;

theorem
  W.cut(1,len W) = W by Lm18;

theorem Th41:
  for n being odd Element of NAT st n < len W holds G.walkOf(W.n,
  W.(n+1), W.(n+2)) = W.cut(n,n+2)
proof
  let n be odd Element of NAT;
  set v1 = W.n, e = W.(n+1), v2 = W.(n+2);
  set W1 = G.walkOf(v1,e,v2), W2 = W.cut(n,n+2);
  assume
A1: n < len W;
  then
A2: n+2 <= len W by Th1;
A3: n <= n+2 by Th1;
  then
A4: len W.cut(n,n+2) + n = 1 + (2+n) by A2,Lm15;
A5: e Joins v1,v2,G by A1,Def3;
  then
A6: G.walkOf(v1,e,v2) = <*v1,e,v2*> by Def5;
A7: len W1 = 3 by A5,Th15;
  then
A8: dom W1 = Seg 3 by FINSEQ_1:def 3;
  now
    let x be Nat;
    assume
A9: x in dom W1;
    then 1 <= x by FINSEQ_3:27;
    then reconsider xaa1 = x-1 as Element of NAT by INT_1:18;
    x <= 3 by A7,A9,FINSEQ_3:27;
    then
A10: xaa1 < 3-0 by XREAL_1:17;
    xaa1+1 = x;
    then
A11: W2.x = W.(n+xaa1) by A3,A2,A4,A10,Lm15;
    now
      per cases by A8,A9,ENUMSET1:def 1,FINSEQ_3:1;
      suppose
        x = 1;
        hence W1.x = W2.x by A6,A11,FINSEQ_1:62;
      end;
      suppose
        x = 2;
        hence W1.x = W2.x by A6,A11,FINSEQ_1:62;
      end;
      suppose
        x = 3;
        hence W1.x = W2.x by A6,A11,FINSEQ_1:62;
      end;
    end;
    hence W1.x = W2.x;
  end;
  hence thesis by A4,A7,FINSEQ_2:10;
end;

theorem Th42:
  for m,n being odd Element of NAT st m <= n & n < len W holds W
  .cut(m,n).addEdge(W.(n+1)) = W.cut(m,n+2)
proof
  let m,n be odd Element of NAT;
  set W1 = W.cut(m,n);
  set e = W.(n+1);
  assume that
A1: m <= n and
A2: n < len W;
A3: n+2 <= len W by A2,Th1;
A4: W1.last() = W.n by A1,A2,Lm16;
  then e Joins W1.last(), W.(n+2), G by A2,Def3;
  then e Joins W1.last(), W.vertexAt(n+2), G by A3,Def8;
  then W1.last().adj(e) = W.vertexAt(n+2) by GLIB_000:69;
  then W1.last().adj(e) = W.(n+2) by A3,Def8;
  then
A5: G.walkOf(W1.last(),e,W1.last().adj(e)) = W.cut(n,n+2) by A2,A4,Th41;
  n <= n+2 by Th1;
  hence thesis by A1,A3,A5,Lm17;
end;

theorem
  for n being odd Element of NAT st n <= len W holds W.cut(n,n) = <* W
  .vertexAt(n) *> by Lm19;

theorem
  m is odd & m <= n implies W.cut(1,n).cut(1,m) = W.cut(1,m) by Lm20;

theorem
  for m,n being odd Element of NAT st m <= n & n <= len W1 & W1.last() =
  W2.first() holds W1.append(W2).cut(m,n) = W1.cut(m,n) by Lm21;

theorem
  for m being odd Element of NAT st m <= len W holds len W.cut(1,m) = m
  by Lm22;

theorem
  for m being odd Element of NAT, x being Element of NAT st x in dom W
  .cut(1,m) & m <= len W holds W.cut(1,m).x = W.x by Lm23;

theorem
  for m,n being odd Element of NAT, i being Element of NAT st m <= n & n
<= len W & i in dom W.cut(m,n) holds W.cut(m,n).i = W.(m+i-1) & m+i-1 in dom W
proof
  let m,n be odd Element of NAT, i be Element of NAT;
  assume that
A1: m <= n and
A2: n <= len W and
A3: i in dom W.cut(m,n);
  1 <= i by A3,FINSEQ_3:27;
  then reconsider iaa1 = i-1 as Element of NAT by INT_1:18;
  i <= len W.cut(m,n) by A3,FINSEQ_3:27;
  then
A4: iaa1 < len W.cut(m,n) - 0 by XREAL_1:17;
  iaa1+1 = i;
  then W.cut(m,n).i = W.(m+iaa1) by A1,A2,A4,Lm15;
  hence thesis by A1,A2,A4,Lm15;
end;

theorem Th49:
  for W1 being Walk of G1, W2 being Walk of G2, m, n being Element
  of NAT st W1 = W2 holds W1.cut(m,n) = W2.cut(m,n)
proof
  let W1 be Walk of G1, W2 be Walk of G2, m, n be Element of NAT;
  assume
A1: W1 = W2;
  now
    per cases;
    suppose
A2:   m is odd & n is odd & m <= n & n <= len W1;
      hence W1.cut(m,n) = (m,n)-cut W2 by A1,Def11
        .= W2.cut(m,n) by A1,A2,Def11;
    end;
    suppose
A3:   not (m is odd & n is odd & m <= n & n <= len W1);
      hence W1.cut(m,n) = W2 by A1,Def11
        .= W2.cut(m,n) by A1,A3,Def11;
    end;
  end;
  hence thesis;
end;

theorem
  for m,n being odd Element of NAT st m <= n & n <= len W & W.m = W.n
  holds len W.remove(m,n) + n = len W + m by Lm24;

theorem
  W is_Walk_from x,y implies W.remove(m,n) is_Walk_from x,y by Lm25;

theorem
  len W.remove(m,n) <= len W by Lm26;

theorem
  W.remove(m,m) = W by Lm27;

theorem
  for m,n being odd Element of NAT st m <= n & n <= len W & W.m = W.n
  holds W.cut(1,m).last() = W.cut(n,len W).first() by Lm28;

theorem
  for m,n being odd Element of NAT st m <= n & n <= len W & W.m = W.n
  holds for x being Element of NAT st x in Seg m holds W.remove(m,n).x = W.x
by Lm29;

theorem
  for m,n being odd Element of NAT st m <= n & n <= len W & W.m = W.n
  holds for x being Element of NAT st m <= x & x <= len W.remove(m,n) holds W
.remove(m,n).x = W.(x - m + n) & x - m + n is Element of NAT & x - m + n <= len
  W by Lm30;

theorem
  for m,n being odd Element of NAT st m <= n & n <= len W & W.m = W.n
  holds len W.remove(m,n) = len W + m - n by Lm31;

theorem Th58:
  for m being Element of NAT st W.m = W.last() holds W.remove(m,
  len W) = W.cut(1,m)
proof
  let m be Element of NAT;
  assume
A1: W.m = W.last();
  now
    per cases;
    suppose
A2:   m is odd & m <= len W;
      then
A3:   len W.remove(m,len W) + len W = len W + m by A1,Lm24;
      then
A4:   len W.remove(m,len W) = len W.cut(1,m) by A2,Lm22;
      now
        let k be Nat;
        assume that
A5:     1 <= k and
A6:     k <= len W.remove(m, len W);
A7:     k in dom W.cut(1,m) by A4,A5,A6,FINSEQ_3:27;
        k in Seg m by A3,A5,A6,FINSEQ_1:3;
        hence W.remove(m,len W).k = W.k by A1,A2,Lm29
          .= W.cut(1,m).k by A2,A7,Lm23;
      end;
      hence thesis by A4,FINSEQ_1:18;
    end;
    suppose
A8:   not (m is odd & m <= len W);
      then W.cut(1,m) = W by Def11;
      hence thesis by A8,Def12;
    end;
  end;
  hence thesis;
end;

theorem
  for m being Element of NAT st W.first() = W.m holds W.remove(1,m) = W
  .cut(m, len W) by Lm32;

theorem
  W.remove(m,n).first() = W.first() & W.remove(m,n).last() = W.last() by Lm33;

theorem
  for m,n being odd Element of NAT, x being Element of NAT st m <= n & n
<= len W & W.m = W.n & x in dom W.remove(m,n) holds x in Seg m or m <= x & x <=
  len W.remove(m,n) by Lm34;

theorem
  for W1 being Walk of G1, W2 being Walk of G2, m, n being Element of
  NAT st W1 = W2 holds W1.remove(m,n) = W2.remove(m,n)
proof
  let W1 be Walk of G1, W2 be Walk of G2, m, n be Element of NAT;
  assume
A1: W1 = W2;
  now
    per cases;
    suppose
A2:   m is odd & n is odd & m <= n & n <= len W1 & W1.m = W1.n;
A3:   W1.cut(n,len W1) = W2.cut(n,len W2) by A1,Th49;
A4:   W1.cut(1,m) = W2.cut(1,m) by A1,Th49;
      W1.remove(m,n) = W1.cut(1,m).append(W1.cut(n,len W1)) by A2,Def12;
      then W1.remove(m,n) = W2.cut(1,m).append(W2.cut(n,len W2)) by A4,A3,Th36;
      hence thesis by A1,A2,Def12;
    end;
    suppose
A5:   not (m is odd & n is odd & m <= n & n <= len W1 & W1.m = W1.n);
      hence W1.remove(m,n) = W2 by A1,Def12
        .= W2.remove(m,n) by A1,A5,Def12;
    end;
  end;
  hence thesis;
end;

theorem
  e Joins W.last(), x, G implies W.addEdge(e) = W^<*e,x*> by Lm35;

theorem
  e Joins W.last(),x,G implies W.addEdge(e).first() = W.first() & W
  .addEdge(e).last() = x & W.addEdge(e) is_Walk_from W.first(), x by Lm36;

theorem
  e Joins W.last(),x,G implies len W.addEdge(e) = len W + 2 by Lm37;

theorem
  e Joins W.last(),x,G implies W.addEdge(e).(len W + 1) = e & W.addEdge(
e).(len W + 2) = x & for n being Element of NAT st n in dom W holds W.addEdge(e
  ).n = W.n by Lm38;

theorem
  W is_Walk_from x,y & e Joins y,z,G implies W.addEdge(e) is_Walk_from x
  ,z by Lm39;

theorem Th68:
  1 <= len W.vertexSeq()
proof
  now
    assume len W.vertexSeq() < 1;
    then len W.vertexSeq() < 0 + 1;
    then len W.vertexSeq() = 0 by NAT_1:13;
    then len W + 1 = 2 * 0 by Def14;
    hence contradiction;
  end;
  hence thesis;
end;

theorem Th69:
  for n being odd Element of NAT st n <= len W holds 2 * ((n+1)
  div 2) - 1 = n & 1 <= (n+1) div 2 & (n+1) div 2 <= len W.vertexSeq()
proof
  let n be odd Element of NAT;
  assume
A1: n <= len W;
  set m = (n+1) div 2;
  2 divides n+1 by PEPIN:22;
  then
A2: 2 * m = n+1 by NAT_D:3;
  hence 2 * m - 1 = n;
A3: now
    assume m < 1;
    then m < 0 + 1;
    then m = 0 by NAT_1:13;
    hence contradiction by A2;
  end;
  then reconsider maa1 = m-1 as Element of NAT by INT_1:18;
  thus 1 <= m by A3;
  now
    assume len W.vertexSeq() < m;
    then len W.vertexSeq() < maa1 + 1;
    then len W.vertexSeq() <= maa1 by NAT_1:13;
    then 2 * len W.vertexSeq() <= 2 * maa1 by NAT_1:4;
    then len W + 1 <= (2 * m) - (2 * 1) by Def14;
    then len W + 1 + 2 <= n + 1 - 2 + 2 by A2,XREAL_1:9;
    then len W + 1 + 2 < n + 1 + 1 by NAT_1:13;
    then len W + 3 - 3 < n + 2 - 2 by XREAL_1:16;
    hence contradiction by A1;
  end;
  hence thesis;
end;

theorem
  G.walkOf(v).vertexSeq() = <*v*>
proof
  set VS = G.walkOf(v).vertexSeq();
  len G.walkOf(v) + 1 = 2 * len VS by Def14;
  then
A1: 1 + 1 = 2 * len VS by Th14;
  then VS.1 = G.walkOf(v).(2*1-1) by Def14
    .= v by Th14;
  hence thesis by A1,FINSEQ_1:57;
end;

theorem Th71:
  e Joins x,y,G implies G.walkOf(x,e,y).vertexSeq() = <*x,y*>
proof
  set W = G.walkOf(x,e,y);
  assume e Joins x, y, G;
  then
A1: W = <*x, e, y*> by Def5;
  len W + 1 = 2 * len W.vertexSeq() by Def14;
  then
A2: 3 + 1 = 2 * len W.vertexSeq() by A1,FINSEQ_1:62;
  then W.vertexSeq().2 = W.(2*2-1) by Def14;
  then
A3: W.vertexSeq().2 = y by A1,FINSEQ_1:62;
  W.vertexSeq().1 = W.(2*1-1) by A2,Def14;
  then W.vertexSeq().1 = x by A1,FINSEQ_1:62;
  hence thesis by A2,A3,FINSEQ_1:61;
end;

theorem
  W.first() = W.vertexSeq().1 & W.last() = W.vertexSeq().(len W .vertexSeq())
proof
A1: len W + 1 = 2*len W.vertexSeq() by Def14;
A2: 1 <= len W.vertexSeq() by Th68;
  then W.vertexSeq().1 = W.(2*1-1) by Def14;
  hence W.vertexSeq().1 = W.first();
  W.vertexSeq().(len W.vertexSeq()) = W.(2*len W.vertexSeq()-1) by A2,Def14;
  hence thesis by A1;
end;

theorem
  for n being odd Element of NAT st n <= len W holds W.vertexAt(n) = W
  .vertexSeq().((n+1) div 2)
proof
  let n be odd Element of NAT;
  set m = (n+1) div 2;
  assume
A1: n <= len W;
  then
A2: 2 * m - 1 = n by Th69;
A3: m <= len W.vertexSeq() by A1,Th69;
A4: 1 <= m by A1,Th69;
  W.vertexAt(n) = W.n by A1,Def8;
  hence thesis by A2,A4,A3,Def14;
end;

theorem Th74:
  n in dom W.vertexSeq() iff 2*n-1 in dom W
proof
  hereby
    assume
A1: n in dom W.vertexSeq();
    then
A2: 1 <= n by FINSEQ_3:27;
    then 1 <= n+n by NAT_1:12;
    then
A3: 2*n-1 is Element of NAT by INT_1:18;
    n <= len W.vertexSeq() by A1,FINSEQ_3:27;
    then 2*n <= 2*len W.vertexSeq() by XREAL_1:66;
    then 2*n <= len W + 1 by Def14;
    then
A4: 2*n-1 <= len W + 1 - 1 by XREAL_1:15;
    2*1 <= 2*n by A2,XREAL_1:66;
    then 2-1 <= 2*n-1 by XREAL_1:15;
    hence 2*n-1 in dom W by A4,A3,FINSEQ_3:27;
  end;
  assume
A5: 2*n-1 in dom W;
  then reconsider 2naa1=2*n-1 as Element of NAT;
  1 <= 2naa1 by A5,FINSEQ_3:27;
  then 1+1 <= 2*n-1+1 by XREAL_1:9;
  then 2*1 <= 2*n;
  then
A6: 1 <= n by XREAL_1:70;
  2naa1 <= len W by A5,FINSEQ_3:27;
  then 2*n-1+1 <= len W+1 by XREAL_1:9;
  then 2*n <= 2 * len W.vertexSeq() by Def14;
  then n <= len W.vertexSeq() by XREAL_1:70;
  hence thesis by A6,FINSEQ_3:27;
end;

theorem
  W.cut(1,n).vertexSeq() c= W.vertexSeq()
proof
  now
    per cases;
    suppose
A1:   n is odd & 1 <= n & n <= len W;
      set f = W.cut(1,n).vertexSeq();
      now
        let v be set;
        assume
A2:     v in f;
        then consider x,y being set such that
A3:     v = [x,y] by RELAT_1:def 1;
A4:     y = f.x by A2,A3,FUNCT_1:8;
A5:     x in dom f by A2,A3,FUNCT_1:8;
        then reconsider x as Element of NAT;
A6:     x <= len f by A5,FINSEQ_3:27;
A7:     2*x-1 in dom W.cut(1,n) by A5,Th74;
        then 2*x-1 <= len W.cut(1,n) by FINSEQ_3:27;
        then 2*x-1 <= n by A1,Lm22;
        then
A8:     2*x-1 <= len W by A1,XXREAL_0:2;
        1 <= 2*x-1 by A7,FINSEQ_3:27;
        then 2*x-1 in dom W by A7,A8,FINSEQ_3:27;
        then
A9:     x in dom W.vertexSeq() by Th74;
        then
A10:    x <= len W.vertexSeq() by FINSEQ_3:27;
        1 <= x by A5,FINSEQ_3:27;
        then y = W.cut(1,n).(2*x-1) by A4,A6,Def14;
        then
A11:    y = W.(2*x-1) by A1,A7,Lm23;
        1 <= x by A9,FINSEQ_3:27;
        then W.vertexSeq().x = y by A11,A10,Def14;
        hence v in W.vertexSeq() by A3,A9,FUNCT_1:8;
      end;
      hence thesis by TARSKI:def 3;
    end;
    suppose
      not (n is odd & 1 <= n & n <= len W);
      hence thesis by Def11;
    end;
  end;
  hence thesis;
end;

theorem Th76:
  e Joins W.last(),x,G implies W.addEdge(e).vertexSeq() = W
  .vertexSeq() ^ <*x*>
proof
  set W2 = W.addEdge(e), W3 = W.vertexSeq() ^ <*x*>;
  assume
A1: e Joins W.last(),x,G;
  then len W2 = len W + 2 by Lm37;
  then
A2: len W + 2 + 1 = 2 * len W2.vertexSeq() by Def14;
  len W3 = len W.vertexSeq() + len <*x*> by FINSEQ_1:35;
  then len W3 = len W.vertexSeq() + 1 by FINSEQ_1:56;
  then 2*len W3 = 2*len W.vertexSeq()+2*1;
  then
A3: 2*len W3 = len W + 1 + 2 by Def14
    .= 2* len W2.vertexSeq() by A2;
  now
    let k be Nat;
    assume that
A4: 1 <= k and
A5: k <= len W2.vertexSeq();
A6: W2.vertexSeq().k = W2.(2*k-1) by A4,A5,Def14;
A7: k in dom W3 by A3,A4,A5,FINSEQ_3:27;
    now
      per cases by A7,FINSEQ_1:38;
      suppose
A8:     k in dom W.vertexSeq();
        then
A9:     2*k-1 in dom W by Th74;
A10:    1 <= k by A8,FINSEQ_3:27;
A11:    k <= len W.vertexSeq() by A8,FINSEQ_3:27;
        W3.k = W.vertexSeq().k by A8,FINSEQ_1:def 7;
        then W3.k = W.(2*k-1) by A10,A11,Def14;
        hence W2.vertexSeq().k = W3.k by A1,A6,A9,Lm38;
      end;
      suppose
        ex n being Nat st n in dom <*x*> & k=len W.vertexSeq()+n;
        then consider n being Nat such that
A12:    n in dom <*x*> and
A13:    k = len W.vertexSeq() + n;
        n in Seg 1 by A12,FINSEQ_1:55;
        then
A14:    n = 1 by FINSEQ_1:4,TARSKI:def 1;
        then
A15:    2*k = 2*len W.vertexSeq() + 2*1 by A13
          .= len W + 1 + 2 by Def14
          .= len W + 2 + 1;
        W3.k = <*x*>.1 by A12,A13,A14,FINSEQ_1:def 7
          .= x by FINSEQ_1:def 8;
        hence W2.vertexSeq().k = W3.k by A1,A6,A15,Lm38;
      end;
    end;
    hence W2.vertexSeq().k = W3.k;
  end;
  hence thesis by A3,FINSEQ_1:18;
end;

theorem Th77:
  for W1 being Walk of G1, W2 being Walk of G2 st W1 = W2 holds W1
  .vertexSeq() = W2.vertexSeq()
proof
  let W1 be Walk of G1, W2 be Walk of G2;
  set VS1 = W1.vertexSeq(), VS2 = W2.vertexSeq();
  assume
A1: W1 = W2;
  now
    thus len VS1 = len VS1;
A2: 2 * len VS1 = len W2 + 1 by A1,Def14
      .= 2 * len VS2 by Def14;
    hence len VS2 = len VS1;
    let x be Nat;
    assume
A3: x in dom VS1;
    then
A4: x <= len VS2 by A2,FINSEQ_3:27;
A5: 1 <= x by A3,FINSEQ_3:27;
    x <= len VS1 by A3,FINSEQ_3:27;
    hence VS1.x = W2.(2*x - 1) by A1,A5,Def14
      .= VS2.x by A5,A4,Def14;
  end;
  hence thesis by FINSEQ_2:10;
end;

theorem
  for n being even Element of NAT st 1 <= n & n <= len W holds n div 2
  in dom W.edgeSeq() & W.n = W.edgeSeq().(n div 2) by Lm40;

theorem
  n in dom W.edgeSeq() iff 2*n in dom W by Lm41;

theorem
  for n being Element of NAT st n in dom W.edgeSeq() holds W.edgeSeq().n
  in the_Edges_of G
proof
  let n be Element of NAT;
  assume n in dom W.edgeSeq();
  then W.edgeSeq().n in rng W.edgeSeq() by FUNCT_1:def 5;
  hence thesis;
end;

theorem
  ex lenWaa1 being even Element of NAT st lenWaa1 = len W - 1 & len W
  .edgeSeq() = lenWaa1 div 2 by Lm42;

theorem
  W.cut(1,n).edgeSeq() c= W.edgeSeq() by Lm43;

theorem
  e Joins W.last(),x,G implies W.addEdge(e).edgeSeq() = W.edgeSeq() ^ <*
  e*> by Lm44;

theorem Th84:
  e Joins x,y,G iff G.walkOf(x,e,y).edgeSeq() = <*e*>
proof
  set W = G.walkOf(x,e,y);
  hereby
    assume
A1: e Joins x,y, G;
    then len W = 3 by Th15;
    then
A2: 2+1 = 2*len W.edgeSeq()+1 by Def15;
A3: W = <*x,e,y*> by A1,Def5;
A4: now
      let k be Nat;
      assume that
A5:   1 <= k and
A6:   k <= len W.edgeSeq();
A7:   k = 1 by A2,A5,A6,XXREAL_0:1;
      then W.edgeSeq().k = W.(2*1) by A6,Def15
        .= e by A3,FINSEQ_1:62;
      hence W.edgeSeq().k = <*e*>.k by A7,FINSEQ_1:def 8;
    end;
    len W.edgeSeq() = len <*e*> by A2,FINSEQ_1:56;
    hence W.edgeSeq() = <*e*> by A4,FINSEQ_1:18;
  end;
  assume W.edgeSeq() = <*e*>;
  then len W.edgeSeq() = 1 by FINSEQ_1:56;
  then
A8: len W = 2*1+1 by Def15;
  now
    assume not e Joins x,y,G;
    then W = G.walkOf(choose the_Vertices_of G) by Def5;
    hence contradiction by A8,Th14;
  end;
  hence thesis;
end;

theorem
  W.reverse().edgeSeq() = Rev (W.edgeSeq())
proof
  set W1 = W.reverse().edgeSeq(), W2 = Rev (W.edgeSeq());
A1: len W = len W.reverse() by FINSEQ_5:def 3;
  len W = 2 * len W.edgeSeq() + 1 by Def15;
  then
A2: 2 * len W.edgeSeq() + 1 = 2 * len W1 + 1 by A1,Def15;
A3: now
    let n be Nat;
    assume that
A4: 1 <= n and
A5: n <= len W1;
A6: W1.n = W.reverse().(2*n) by A4,A5,Def15;
    set rn = len W.edgeSeq() - n + 1;
    reconsider rn as Element of NAT by A2,A5,FINSEQ_5:1;
A7: n in Seg len W.edgeSeq() by A2,A4,A5,FINSEQ_1:3;
    then
A8: rn in Seg len W.edgeSeq() by FINSEQ_5:2;
    then
A9: 1 <= rn by FINSEQ_1:3;
A10: n in dom W.edgeSeq() by A7,FINSEQ_1:def 3;
    then
A11: 2*n in dom W by Lm41;
    then
A12: 1 <= 2*n by FINSEQ_3:27;
A13: rn <= len W.edgeSeq() by A8,FINSEQ_1:3;
A14: len W - 2*n + 1 = 2*len W.edgeSeq() + 1 - 2*n + 1 by Def15
      .= 2*rn;
    2*n <= len W.reverse() by A1,A11,FINSEQ_3:27;
    then
A15: 2*n in dom W.reverse() by A12,FINSEQ_3:27;
    W2.n = W.edgeSeq().rn by A10,FINSEQ_5:61
      .= W.(2*rn) by A9,A13,Def15;
    hence W1.n = W2.n by A15,A6,A14,Lm8;
  end;
  len W1 = len W2 by A2,FINSEQ_5:def 3;
  hence thesis by A3,FINSEQ_1:18;
end;

theorem
  W1.last() = W2.first() implies W1.append(W2).edgeSeq() = W1.edgeSeq()
  ^ W2.edgeSeq()
proof
  set W3 = W1.append(W2), W4 = W1.edgeSeq() ^ W2.edgeSeq();
A1: len W4 = len W1.edgeSeq() + len W2.edgeSeq() by FINSEQ_1:35;
  assume
A2: W1.last() = W2.first();
  then len W3 + 1 = len W1 + len W2 by Lm9;
  then len W3 + 1 = len W1 + (2*len W2.edgeSeq() + 1) by Def15
    .= len W1 + 2*len W2.edgeSeq() + 1;
  then
A3: 2*len W3.edgeSeq()+1 = 2*len W2.edgeSeq()+len W1 by Def15
    .= 2*len W2.edgeSeq()+(2*len W1.edgeSeq()+1) by Def15
    .= 2*len W2.edgeSeq()+2*len W1.edgeSeq()+1;
A4: W3 = W1 ^' W2 by A2,Def10;
  now
    let n be Nat;
    assume that
A5: 1 <= n and
A6: n <= len W3.edgeSeq();
    reconsider n1 = n as Element of NAT by ORDINAL1:def 13;
A7: W3.edgeSeq().n1 = W3.(2*n1) by A5,A6,Def15;
A8: n1 in dom W4 by A1,A3,A5,A6,FINSEQ_3:27;
    now
      per cases by A8,FINSEQ_1:38;
      suppose
A9:     n in dom W1.edgeSeq();
        then
A10:    n <= len W1.edgeSeq() by FINSEQ_3:27;
A11:    1 <= n by A9,FINSEQ_3:27;
A12:    2*n in dom W1 by A9,Lm41;
        then
A13:    1 <= 2*n by FINSEQ_3:27;
A14:    2*n <= len W1 by A12,FINSEQ_3:27;
        W4.n = W1.edgeSeq().n by A9,FINSEQ_1:def 7
          .= W1.(2*n) by A11,A10,Def15;
        hence W3.edgeSeq().n = W4.n by A4,A7,A13,A14,GRAPH_2:14;
      end;
      suppose
        ex k being Nat st k in dom W2.edgeSeq() & n = len W1 .edgeSeq() + k;
        then consider k being Nat such that
A15:    k in dom W2.edgeSeq() and
A16:    n = len W1.edgeSeq() + k;
        2*n+1 = 2*k + (2*len W1.edgeSeq()+1) by A16
          .= 2*k + len W1 by Def15;
        then
A17:    2*n = len W1 + (2*k-1);
A18:    1 <= k by A15,FINSEQ_3:27;
        then 1 <= k+k by NAT_1:12;
        then reconsider 2kaa1 = 2*k-1 as Element of NAT by INT_1:18;
A19:    k <= len W2.edgeSeq() by A15,FINSEQ_3:27;
        then 2*k <= 2*len W2.edgeSeq() by XREAL_1:66;
        then 2*k < 2*len W2.edgeSeq() + 1 by NAT_1:13;
        then 2*k < len W2 by Def15;
        then
A20:    2kaa1 < len W2 - 0 by XREAL_1:16;
        1+1 <= k+k by A18,XREAL_1:9;
        then 1+1-1 <= 2kaa1 by XREAL_1:15;
        then
A21:    W3.(2*n) = W2.(2kaa1+1) by A4,A17,A20,GRAPH_2:15
          .= W2.(2*k);
        W4.n = W2.edgeSeq().k by A15,A16,FINSEQ_1:def 7
          .= W2.(2*k) by A18,A19,Def15;
        hence W3.edgeSeq().n = W4.n by A5,A6,A21,Def15;
      end;
    end;
    hence W3.edgeSeq().n = W4.n;
  end;
  hence thesis by A1,A3,FINSEQ_1:18;
end;

theorem Th87:
  for W1 being Walk of G1, W2 being Walk of G2 st W1 = W2 holds W1
  .edgeSeq() = W2.edgeSeq()
proof
  let W1 be Walk of G1, W2 be Walk of G2;
  set ES1 = W1.edgeSeq(), ES2 = W2.edgeSeq();
  assume
A1: W1 = W2;
  now
    thus len ES1 = len ES1;
A2: 2 * len ES1 + 1 = len W2 by A1,Def15
      .= 2 * len ES2 + 1 by Def15;
    hence len ES2 = len ES1;
    let x be Nat;
    assume
A3: x in dom ES1;
    then
A4: x <= len ES2 by A2,FINSEQ_3:27;
A5: 1 <= x by A3,FINSEQ_3:27;
    x <= len ES1 by A3,FINSEQ_3:27;
    hence ES1.x = W2.(2*x) by A1,A5,Def15
      .= ES2.x by A5,A4,Def15;
  end;
  hence thesis by FINSEQ_2:10;
end;

theorem
  x in W.vertices() iff ex n being odd Element of NAT st n <= len W & W.
  n = x by Lm45;

theorem Th89:
  W.first() in W.vertices() & W.last() in W.vertices()
proof
  1 <= len W by ABIAN:12;
  hence W.first() in W.vertices() by Lm45,JORDAN12:3;
  thus thesis by Lm45;
end;

theorem Th90:
  for n being odd Element of NAT st n <= len W holds W.vertexAt(n)
  in W.vertices()
proof
  let n be odd Element of NAT;
  assume
A1: n <= len W;
  then W.vertexAt(n) = W.n by Def8;
  hence thesis by A1,Lm45;
end;

theorem
  G.walkOf(v).vertices() = {v}
proof
  now
    let x be set;
A1: 1 <= len G.walkOf(v) by ABIAN:12;
    hereby
      assume x in G.walkOf(v).vertices();
      then consider n being odd Element of NAT such that
A2:   n <= len G.walkOf(v) and
A3:   G.walkOf(v).n = x by Lm45;
A4:   1 <= n by ABIAN:12;
      n <= 1 by A2,Th14;
      then x = G.walkOf(v).1 by A3,A4,XXREAL_0:1;
      then x = v by Th14;
      hence x in {v} by TARSKI:def 1;
    end;
    assume x in {v};
    then
A5: x = v by TARSKI:def 1;
    G.walkOf(v).1 = v by Th14;
    hence x in G.walkOf(v).vertices() by A5,A1,Lm45,JORDAN12:3;
  end;
  hence thesis by TARSKI:2;
end;

theorem Th92:
  e Joins x,y,G implies G.walkOf(x,e,y).vertices() = {x,y}
proof
  set W = G.walkOf(x,e,y);
  assume e Joins x, y, G;
  then W.vertexSeq() = <*x,y*> by Th71;
  hence thesis by FINSEQ_2:147;
end;

theorem
  W.vertices() = W.reverse().vertices()
proof
  now
    reconsider lenW = len W as odd Element of NAT;
    let x be set;
    hereby
      reconsider lenW = len W as odd Element of NAT;
      assume x in W.vertices();
      then consider n being odd Element of NAT such that
A1:   n <= len W and
A2:   W.n = x by Lm45;
A3:   lenW-n+1 is odd Element of NAT by A1,FINSEQ_5:1;
      1 <= n by ABIAN:12;
      then
A4:   n in dom W by A1,FINSEQ_3:27;
      then n in Seg len W by FINSEQ_1:def 3;
      then lenW-n+1 in Seg len W by FINSEQ_5:2;
      then lenW-n+1 in dom W by FINSEQ_1:def 3;
      then lenW-n+1 <= len W by FINSEQ_3:27;
      then
A5:   lenW-n+1 <= len W.reverse() by FINSEQ_5:def 3;
      W.reverse().(len W - n + 1) = x by A2,A4,Th25;
      hence x in W.reverse().vertices() by A3,A5,Lm45;
    end;
    assume x in W.reverse().vertices();
    then consider n being odd Element of NAT such that
A6: n <= len W.reverse() and
A7: W.reverse().n = x by Lm45;
A8: 1 <= n by ABIAN:12;
    then n in dom W.reverse() by A6,FINSEQ_3:27;
    then
A9: W.(len W - n + 1) = x by A7,FINSEQ_5:def 3;
A10: n <= len W by A6,FINSEQ_5:def 3;
    then n in Seg len W by A8,FINSEQ_1:3;
    then lenW-n+1 in Seg len W by FINSEQ_5:2;
    then
A11: lenW-n+1 <= len W by FINSEQ_1:3;
    lenW-n+1 is odd Element of NAT by A10,FINSEQ_5:1;
    hence x in W.vertices() by A9,A11,Lm45;
  end;
  hence thesis by TARSKI:2;
end;

theorem Th94:
  W1.last() = W2.first() implies W1.append(W2).vertices() = W1
  .vertices() \/ W2.vertices()
proof
  set W = W1.append(W2);
  assume
A1: W1.last() = W2.first();
  then
A2: W = W1 ^' W2 by Def10;
  now
    let x be set;
A3: now
      assume x in W1.vertices();
      then consider n being odd Element of NAT such that
A4:   n <= len W1 and
A5:   W1.n = x by Lm45;
      1 <= n by ABIAN:12;
      then
A6:   n in dom W1 by A4,FINSEQ_3:27;
      then n in dom W by Lm12;
      then
A7:   n <= len W by FINSEQ_3:27;
      W.n = x by A5,A6,Lm12;
      hence x in W.vertices() by A7,Lm45;
    end;
    hereby
      assume
A8:   x in W.vertices();
      then reconsider v=x as Vertex of G;
      consider n being odd Element of NAT such that
A9:   n <= len W and
A10:  W.n = v by A8,Lm45;
A11:  1 <= n by ABIAN:12;
      now
        per cases;
        suppose
A12:      n <= len W1;
          then n in dom W1 by A11,FINSEQ_3:27;
          then W1.n = v by A10,Lm12;
          then v in W1.vertices() by A12,Lm45;
          hence x in W1.vertices()\/W2.vertices() by XBOOLE_0:def 3;
        end;
        suppose
A13:      n > len W1;
          then consider k being Nat such that
A14:      len W1 + k = n by NAT_1:10;
          reconsider k as even Element of NAT by A14,ORDINAL1:def 13;
          k <> 0 by A13,A14;
          then
A15:      0+1 <= k by NAT_1:13;
          len W1 + k + 1 <= len W + 1 by A9,A14,XREAL_1:9;
          then (k + 1) + len W1 <= len W2 + len W1 by A1,Lm9;
          then
A16:      k + 1 + len W1 - len W1 <= len W2 + len W1 - len W1 by XREAL_1:15;
          then
A17:      W2.vertexAt(k+1) in W2.vertices() by Th90;
          k < len W2 - 1 + 1 by A16,NAT_1:13;
          then W2.(k+1) = v by A2,A10,A14,A15,GRAPH_2:15;
          then v in W2.vertices() by A16,A17,Def8;
          hence x in W1.vertices() \/ W2.vertices() by XBOOLE_0:def 3;
        end;
      end;
      hence x in W1.vertices() \/ W2.vertices();
    end;
    assume
A18: x in W1.vertices() \/ W2.vertices();
    now
      per cases by A18,XBOOLE_0:def 3;
      suppose
        x in W1.vertices();
        hence x in W.vertices() by A3;
      end;
      suppose
A19:    x in W2.vertices();
        reconsider lenW1 = len W1 as odd Element of NAT;
        consider n being odd Element of NAT such that
A20:    n <= len W2 and
A21:    W2.n = x by A19,Lm45;
        reconsider naa1 = n-1 as even Element of NAT by ABIAN:12,INT_1:18;
A22:    naa1 < len W2 - 0 by A20,XREAL_1:17;
        then (len W1 + naa1) in dom W by A1,Lm13;
        then
A23:    lenW1 + naa1 <= len W by FINSEQ_3:27;
        W.(len W1 + naa1) = W2.(naa1 + 1) by A1,A22,Lm13;
        hence x in W.vertices() by A21,A23,Lm45;
      end;
    end;
    hence x in W.vertices();
  end;
  hence thesis by TARSKI:2;
end;

theorem
  for m,n being odd Element of NAT st m <= n & n <= len W holds W.cut(m,
  n).vertices() c= W.vertices()
proof
  let m, n be odd Element of NAT;
  set W2 = W.cut(m,n);
  assume that
A1: m <= n and
A2: n <= len W;
  now
    let x be set;
    assume x in W2.vertices();
    then consider n being odd Element of NAT such that
A3: n <= len W2 and
A4: W2.n = x by Lm45;
    reconsider naa1 = n - 1 as even Element of NAT by ABIAN:12,INT_1:18;
A5: naa1 < len W2 - 0 by A3,XREAL_1:17;
    then m+naa1 in dom W by A1,A2,Lm15;
    then
A6: m+naa1 <= len W by FINSEQ_3:27;
    W2.(naa1+1) = W.(m+naa1) by A1,A2,A5,Lm15;
    hence x in W.vertices() by A4,A6,Lm45;
  end;
  hence thesis by TARSKI:def 3;
end;

theorem Th96:
  e Joins W.last(),x,G implies W.addEdge(e).vertices() = W .vertices() \/ {x}
proof
  set W2 = G.walkOf(W.last(), e, W.last().adj(e));
  set W3 = W.addEdge(e), WV = W.vertices();
  assume
A1: e Joins W.last(), x, G;
  then reconsider x9=x as Vertex of G by GLIB_000:16;
A2: W.last().adj(e) = x9 by A1,GLIB_000:69;
  then W2.first() = W.last() by A1,Th16;
  then
A3: W3.vertices() = WV \/ W2.vertices() by Th94;
A4: now
    let y be set;
    hereby
      assume
A5:   y in WV \/ {W.last(), x};
      now
        per cases by A5,XBOOLE_0:def 3;
        suppose
          y in WV;
          hence y in WV \/ {x} by XBOOLE_0:def 3;
        end;
        suppose
A6:       y in {W.last(), x};
          now
            per cases by A6,TARSKI:def 2;
            suppose
              y = W.last();
              then y in WV by Th89;
              hence y in WV \/ {x} by XBOOLE_0:def 3;
            end;
            suppose
              y = x;
              then y in {x} by TARSKI:def 1;
              hence y in WV \/ {x} by XBOOLE_0:def 3;
            end;
          end;
          hence y in WV \/ {x};
        end;
      end;
      hence y in WV \/ {x};
    end;
    assume
A7: y in WV \/ {x};
    now
      per cases by A7,XBOOLE_0:def 3;
      suppose
        y in WV;
        hence y in WV \/ {W.last(), x} by XBOOLE_0:def 3;
      end;
      suppose
        y in {x};
        then y = x by TARSKI:def 1;
        then y in {W.last(), x} by TARSKI:def 2;
        hence y in WV \/ {W.last(), x} by XBOOLE_0:def 3;
      end;
    end;
    hence y in WV \/ {W.last(), x};
  end;
  W2.vertices() = {W.last(), x} by A1,A2,Th92;
  hence thesis by A3,A4,TARSKI:2;
end;

theorem
  for G being finite _Graph, W being Walk of G, e,x being set holds e
Joins W.last(),x,G & not x in W.vertices() implies card W.addEdge(e).vertices()
  = card W.vertices() + 1
proof
  let G be finite _Graph, W be Walk of G, e, x be set;
  assume that
A1: e Joins W.last(),x,G and
A2: not x in W.vertices();
  card W.addEdge(e).vertices() = card (W.vertices()\/{x}) by A1,Th96;
  hence thesis by A2,CARD_2:54;
end;

theorem
  x in W.vertices() & y in W.vertices() implies ex W9 being Walk of G st
  W9 is_Walk_from x,y
proof
  assume that
A1: x in W.vertices() and
A2: y in W.vertices();
  consider m being odd Element of NAT such that
A3: m <= len W and
A4: W.m = x by A1,Lm45;
  consider n being odd Element of NAT such that
A5: n <= len W and
A6: W.n = y by A2,Lm45;
  now
    per cases;
    suppose
      m <= n;
      then W.cut(m,n) is_Walk_from x, y by A4,A5,A6,Lm16;
      hence thesis;
    end;
    suppose
      n <= m;
      then W.cut(n,m) is_Walk_from y, x by A3,A4,A6,Lm16;
      then W.cut(n,m).reverse() is_Walk_from x, y by Th24;
      hence thesis;
    end;
  end;
  hence thesis;
end;

theorem
  for W1 being Walk of G1, W2 being Walk of G2 st W1 = W2 holds W1
  .vertices() = W2.vertices() by Th77;

theorem
  e in W.edges() iff ex n being even Element of NAT st 1 <= n & n <= len
  W & W.n = e by Lm46;

theorem Th101:
  e in W.edges() iff ex n being odd Element of NAT st n < len W & W.(n+1) = e
proof
  hereby
    assume e in W.edges();
    then consider n1 being even Element of NAT such that
A1: 1 <= n1 and
A2: n1 <= len W and
A3: W.n1 = e by Lm46;
    reconsider n = n1-1 as odd Element of NAT by A1,INT_1:18;
    take n;
    n1-1 < len W - 0 by A2,XREAL_1:17;
    hence n < len W;
    thus W.(n+1) = e by A3;
  end;
  given n being odd Element of NAT such that
A4: n < len W and
A5: W.(n+1) = e;
A6: 1 <= n+1 by NAT_1:12;
  n+1 <= len W by A4,NAT_1:13;
  hence thesis by A5,A6,Lm46;
end;

theorem Th102:
  rng W = W.vertices() \/ W.edges()
proof
  now
    let y be set;
    assume
A1: y in W.vertices() \/ W.edges();
    now
      per cases by A1,XBOOLE_0:def 3;
      suppose
        y in W.vertices();
        then consider x being odd Element of NAT such that
A2:     x <= len W and
A3:     W.x = y by Lm45;
        1 <= x by ABIAN:12;
        then x in dom W by A2,FINSEQ_3:27;
        hence y in rng W by A3,FUNCT_1:def 5;
      end;
      suppose
        y in W.edges();
        then consider x being even Element of NAT such that
A4:     1 <= x and
A5:     x <= len W and
A6:     W.x = y by Lm46;
        x in dom W by A4,A5,FINSEQ_3:27;
        hence y in rng W by A6,FUNCT_1:def 5;
      end;
    end;
    hence y in rng W;
  end;
  then
A7: W.vertices() \/ W.edges() c= rng W by TARSKI:def 3;
  now
    let y be set;
    assume y in rng W;
    then consider x being Nat such that
A8: x in dom W and
A9: W.x = y by FINSEQ_2:11;
A10: x <= len W by A8,FINSEQ_3:27;
A11: 1 <= x by A8,FINSEQ_3:27;
    now
      per cases;
      suppose
        x is odd;
        then y in W.vertices() by A8,A9,A10,Lm45;
        hence y in W.vertices() \/ W.edges() by XBOOLE_0:def 3;
      end;
      suppose
        x is even;
        then y in W.edges() by A8,A9,A11,A10,Lm46;
        hence y in W.vertices() \/ W.edges() by XBOOLE_0:def 3;
      end;
    end;
    hence y in W.vertices() \/ W.edges();
  end;
  then rng W c= W.vertices() \/ W.edges() by TARSKI:def 3;
  hence thesis by A7,XBOOLE_0:def 10;
end;

theorem Th103:
  W1.last() = W2.first() implies W1.append(W2).edges() = W1
  .edges() \/ W2.edges()
proof
  set W = W1.append(W2);
  set WE = W.edges(), W1E = W1.edges(), W2E = W2.edges();
  set lenW1 = len W1, lenW2 = len W2;
  reconsider lenW1, lenW2 as odd Element of NAT;
  assume
A1: W1.last() = W2.first();
  then
A2: W = W1 ^' W2 by Def10;
  now
    let x be set;
    hereby
      assume x in WE;
      then consider n being even Element of NAT such that
A3:   1 <= n and
A4:   n <= len W and
A5:   W.n = x by Lm46;
      now
        per cases;
        suppose
A6:       n <= len W1;
          then W.n = W1.n by A2,A3,GRAPH_2:14;
          then x in W1E by A3,A5,A6,Lm46;
          hence x in W1E \/ W2E by XBOOLE_0:def 3;
        end;
        suppose
          len W1 < n;
          then reconsider k = n-lenW1 as odd Element of NAT by INT_1:18;
A7:       1 <= k+1 by NAT_1:12;
          n - lenW1 + len W1 < len W + 1 by A4,NAT_1:13;
          then n-lenW1 + lenW1 < lenW2 + len W1 by A1,Lm9;
          then
A8:       k < lenW2 + len W1 - len W1 by XREAL_1:16;
          then
A9:       k+1 <= len W2 by NAT_1:13;
          W2.(k+1) = W.(len W1+k) by A2,A8,ABIAN:12,GRAPH_2:15
            .= x by A5;
          then x in W2E by A7,A9,Lm46;
          hence x in W1E \/ W2E by XBOOLE_0:def 3;
        end;
      end;
      hence x in W1E \/ W2E;
    end;
    assume
A10: x in W1E \/ W2E;
    now
      per cases by A10,XBOOLE_0:def 3;
      suppose
        x in W1E;
        then consider n being even Element of NAT such that
A11:    1 <= n and
A12:    n <= len W1 and
A13:    W1.n = x by Lm46;
        len W1 <= len W by A1,Lm10;
        then
A14:    n <= len W by A12,XXREAL_0:2;
        W.n = x by A2,A11,A12,A13,GRAPH_2:14;
        hence x in WE by A11,A14,Lm46;
      end;
      suppose
        x in W2E;
        then consider n being even Element of NAT such that
A15:    1 <= n and
A16:    n <= len W2 and
A17:    W2.n = x by Lm46;
        reconsider naa1 = n-1 as odd Element of NAT by A15,INT_1:18;
        naa1 < len W2 by A16,XREAL_1:149;
        then
A18:    W.(lenW1 + naa1) = W2.(naa1+1) by A2,ABIAN:12,GRAPH_2:15
          .= x by A17;
        (naa1 + 1) + lenW1 <= len W2 + len W1 by A16,XREAL_1:9;
        then lenW1 + naa1 + 1 <= len W + 1 by A1,Lm9;
        then
A19:    lenW1+naa1 <= len W by XREAL_1:8;
        1 <= lenW1+naa1 by ABIAN:12,NAT_1:12;
        hence x in WE by A18,A19,Lm46;
      end;
    end;
    hence x in WE;
  end;
  hence thesis by TARSKI:2;
end;

theorem
  e in W.edges() implies ex v1, v2 being Vertex of G, n being odd
  Element of NAT st n+2 <= len W & v1 = W.n & e = W.(n+1) & v2 = W.(n+2) & e
  Joins v1, v2,G by Lm47;

theorem Th105:
  e in W.edges() iff ex n being Element of NAT st n in dom W
  .edgeSeq() & W.edgeSeq().n = e
proof
  hereby
    assume e in W.edges();
    then consider n being set such that
A1: n in dom W.edgeSeq() and
A2: W.edgeSeq().n = e by FUNCT_1:def 5;
    reconsider n as Element of NAT by A1;
    take n;
    thus n in dom W.edgeSeq() & W.edgeSeq().n = e by A1,A2;
  end;
  given n being Element of NAT such that
A3: n in dom W.edgeSeq() and
A4: W.edgeSeq().n = e;
  thus thesis by A3,A4,FUNCT_1:def 5;
end;

theorem
  e in W.edges() & e Joins x,y,G implies x in W.vertices() & y in W
  .vertices() by Lm48;

theorem
  W.cut(m,n).edges() c= W.edges()
proof
  now
    per cases;
    suppose
A1:   m is odd & n is odd & m <= n & n <= len W;
      then reconsider m9 = m as odd Element of NAT;
      now
        let e be set;
        assume e in W.cut(m,n).edges();
        then consider x being even Element of NAT such that
A2:     1 <= x and
A3:     x <= len W.cut(m,n) and
A4:     W.cut(m,n).x = e by Lm46;
        reconsider xaa1 = x-1 as odd Element of NAT by A2,INT_1:18;
A5:     xaa1 < len W.cut(m,n) - 0 by A3,XREAL_1:17;
        then
A6:     m+xaa1 in dom W by A1,Lm15;
        then
A7:     m9+xaa1 <= len W by FINSEQ_3:27;
        xaa1+1 = x;
        then
A8:     e = W.(m+xaa1) by A1,A4,A5,Lm15;
        1 <= m9+xaa1 by A6,FINSEQ_3:27;
        hence e in W.edges() by A8,A7,Lm46;
      end;
      hence thesis by TARSKI:def 3;
    end;
    suppose
      not (m is odd & n is odd & m <= n & n <= len W);
      hence thesis by Def11;
    end;
  end;
  hence thesis;
end;

theorem Th108:
  W.edges() = W.reverse().edges()
proof
  now
    let e be set;
    hereby
      assume e in W.edges();
      then consider n being even Element of NAT such that
A1:   1 <= n and
A2:   n <= len W and
A3:   W.n = e by Lm46;
A4:   n in dom W by A1,A2,FINSEQ_3:27;
      then
A5:   (len W - n + 1) in dom W.reverse() by Th25;
      then reconsider rn = len W - n + 1 as even Element of NAT;
A6:   1 <= rn by A5,FINSEQ_3:27;
A7:   rn <= len W.reverse() by A5,FINSEQ_3:27;
      e = W.reverse().(len W - n + 1) by A3,A4,Th25;
      hence e in W.reverse().edges() by A6,A7,Lm46;
    end;
    assume e in W.reverse().edges();
    then consider n being even Element of NAT such that
A8: 1 <= n and
A9: n <= len W.reverse() and
A10: W.reverse().n = e by Lm46;
A11: n in dom W.reverse() by A8,A9,FINSEQ_3:27;
    then
A12: (len W.reverse() - n + 1) in dom W.reverse().reverse() by Th25;
    then reconsider rn = len W.reverse() - n + 1 as even Element of NAT;
    e = W.reverse().reverse().(len W.reverse() - n + 1) by A10,A11,Th25;
    then
A13: e = W.rn by FINSEQ_6:29;
    rn in dom W by A12,FINSEQ_6:29;
    then
A14: rn <= len W by FINSEQ_3:27;
    1 <= rn by A12,FINSEQ_3:27;
    hence e in W.edges() by A13,A14,Lm46;
  end;
  hence thesis by TARSKI:2;
end;

theorem Th109:
  e Joins x,y,G iff G.walkOf(x,e,y).edges() = {e}
proof
  set W = G.walkOf(x,e,y);
  hereby
    assume e Joins x,y,G;
    then W.edgeSeq() = <*e*> by Th84;
    hence W.edges() = {e} by FINSEQ_1:56;
  end;
  assume W.edges() = {e};
  then e in W.edges() by TARSKI:def 1;
  then consider n being even Element of NAT such that
A1: 1 <= n and
A2: n <= len W and
  W.n = e by Lm46;
A3: 2*0+1 < n by A1,XXREAL_0:1;
  now
    assume not e Joins x,y,G;
    then W = G.walkOf(choose the_Vertices_of G) by Def5;
    hence contradiction by A2,A3,Th14;
  end;
  hence thesis;
end;

theorem
  W.edges() c= G.edgesBetween(W.vertices())
proof
  now
    let e be set;
    assume e in W.edges();
    then consider
    v1,v2 being Vertex of G, n being odd Element of NAT such that
A1: n+2 <= len W and
A2: v1 = W.n and
    e = W.(n+1) and
A3: v2 = W.(n+2) and
A4: e Joins v1,v2,G by Lm47;
    n < len W by A1,Th1;
    then
A5: v1 in W.vertices() by A2,Lm45;
    v2 in W.vertices() by A1,A3,Lm45;
    hence e in G.edgesBetween(W.vertices()) by A4,A5,GLIB_000:35;
  end;
  hence thesis by TARSKI:def 3;
end;

theorem
  for W1 being Walk of G1, W2 being Walk of G2 st W1 = W2 holds W1
  .edges() = W2.edges() by Th87;

theorem
  e Joins W.last(),x,G implies W.addEdge(e).edges() = W.edges() \/ {e}
proof
  set WB = G.walkOf(W.last(),e,W.last().adj(e));
  assume e Joins W.last(),x,G;
  then e in W.last().edgesInOut() by GLIB_000:65;
  then
A1: e Joins W.last(), W.last().adj(e), G by GLIB_000:70;
  then
A2: WB.first() = W.last() by Th16;
  WB.edges() = {e} by A1,Th109;
  hence thesis by A2,Th103;
end;

theorem
  len W = 2 * W.length() + 1 by Def15;

theorem
  len W1 = len W2 iff W1.length() = W2.length()
proof
  hereby
    assume len W1 = len W2;
    then 2 * W1.length() + 1 = len W2 by Def15
      .= 2 * W2.length() + 1 by Def15;
    hence W1.length() = W2.length();
  end;
  assume W1.length() = W2.length();
  hence len W1 = 2*W2.length()+1 by Def15
    .= len W2 by Def15;
end;

theorem
  for W1 being Walk of G1, W2 being Walk of G2 st W1 = W2 holds W1
  .length() = W2.length() by Th87;

theorem Th116:
  for n being odd Element of NAT st n <= len W holds W.find(W.n)
  <= n & W.rfind(W.n) >= n
proof
  let n be odd Element of NAT;
  assume
A1: n <= len W;
  then
A2: W.n in W.vertices() by Lm45;
  hence W.find(W.n) <= n by A1,Def19;
  thus thesis by A1,A2,Def21;
end;

theorem
  for W1 being Walk of G1, W2 being Walk of G2, v being set st W1 = W2
  holds W1.find(v) = W2.find(v) & W1.rfind(v) = W2.rfind(v)
proof
  let W1 be Walk of G1, W2 be Walk of G2, v be set;
  assume
A1: W1 = W2;
  now
    per cases;
    suppose
A2:   v in W1.vertices();
      then
A3:   W2.(W1.find(v)) = v by A1,Def19;
A4:   v in W2.vertices() by A1,A2,Th77;
A5:   for n being odd Nat st n <= len W2 & W2.n = v holds W1.find(v) <= n
      by A1,A2,Def19;
      W1.find(v) <= len W2 by A1,A2,Def19;
      hence W1.find(v) = W2.find(v) by A4,A3,A5,Def19;
A6:   W2.(W1.rfind(v)) = v by A1,A2,Def21;
A7:   for n being odd Element of NAT st n <= len W2 & W2.n = v holds n <=
      W1 .rfind(v) by A1,A2,Def21;
      W1.rfind(v) <= len W2 by A1,A2,Def21;
      hence W1.rfind(v) = W2.rfind(v) by A4,A6,A7,Def21;
    end;
    suppose
A8:   not v in W1.vertices();
      then
A9:   not v in W2.vertices() by A1,Th77;
      thus W1.find(v) = len W2 by A1,A8,Def19
        .= W2.find(v) by A9,Def19;
      thus W1.rfind(v) = len W2 by A1,A8,Def21
        .= W2.rfind(v) by A9,Def21;
    end;
  end;
  hence thesis;
end;

theorem
  for n being odd Element of NAT st n <= len W holds W.find(n) <= n & W
  .rfind(n) >= n by Lm49,Lm50;

theorem Th119:
  W is closed iff W.1 = W.(len W)
proof
  hereby
    assume W is closed;
    then W.first() = W.last() by Def24;
    hence W.1 = W.(len W);
  end;
  assume W.1 = W.(len W);
  then W.first() = W.last();
  hence thesis by Def24;
end;

theorem
  W is closed iff ex x being set st W is_Walk_from x,x
proof
  hereby
    set x = W.first();
    assume W is closed;
    then W.first() = W.last() by Def24;
    then W is_Walk_from x,x by Def23;
    hence ex x being set st W is_Walk_from x,x;
  end;
  given v being set such that
A1: W is_Walk_from v,v;
A2: W.last() = v by A1,Def23;
  W.first() = v by A1,Def23;
  hence thesis by A2,Def24;
end;

theorem
  W is closed iff W.reverse() is closed
proof
  W is closed iff W.first() = W.last() by Def24;
  then W is closed iff W.reverse().last() = W.last() by Th23;
  then W is closed iff W.reverse().last() = W.reverse().first() by Th23;
  hence thesis by Def24;
end;

theorem
  for W1 being Walk of G1, W2 being Walk of G2 st W1 = W2 & W1 is closed
  holds W2 is closed
proof
  let W1 be Walk of G1, W2 be Walk of G2;
  assume that
A1: W1 = W2 and
A2: W1 is closed;
  W2.1 = W2.(len W2) by A1,A2,Th119;
  hence thesis by Th119;
end;

theorem
  W is directed iff for n being odd Element of NAT st n < len W holds W.
  (n+1) DJoins W.n, W.(n+2), G by Lm51;

theorem
  W is directed & W is_Walk_from x,y & e DJoins y,z,G implies W.addEdge(
  e) is directed & W.addEdge(e) is_Walk_from x,z by Lm52;

theorem
  for W being DWalk of G, m,n being Element of NAT holds W.cut(m,n) is
  directed;

theorem
  W is non trivial iff 3 <= len W by Lm54;

theorem
  W is non trivial iff len W <> 1 by Lm55;

theorem
  W.first() <> W.last() implies W is non trivial by Lm55;

theorem
  W is trivial iff ex v being Vertex of G st W = G.walkOf(v) by Lm56;

theorem
  W is trivial iff W.reverse() is trivial
proof
  thus W is trivial implies W.reverse() is trivial;
  assume W.reverse() is trivial;
  then len W.reverse() = 1 by Lm55;
  then len W = 1 by FINSEQ_5:def 3;
  hence thesis by Lm55;
end;

theorem
  W2 is trivial implies W1.append(W2) = W1
proof
  assume W2 is trivial;
  then
A1: len W2 = 1 by Lm55;
  now
    per cases;
    suppose
      W1.last() = W2.first();
      then
A2:   W1.append(W2) = W1 ^' W2 by Def10;
      then
A3:   len W1.append(W2) + 1 = len W1 + 1 by A1,CARD_1:47,GRAPH_2:13;
      for k being Nat st 1 <= k & k <= len W1.append(W2) holds W1.append(
      W2).k = W1.k
      proof
        let k be Nat;
        reconsider k as Element of NAT by ORDINAL1:def 13;
        1 <= k & k <= len W1.append(W2) implies W1.append(W2).k = W1.k by A2,A3
,GRAPH_2:14;
        hence thesis;
      end;
      hence thesis by A3,FINSEQ_1:18;
    end;
    suppose
      W1.last() <> W2.first();
      hence thesis by Def10;
    end;
  end;
  hence thesis;
end;

theorem
  for m, n being odd Element of NAT st m <= n & n <= len W holds W.cut(m
  ,n) is trivial iff m = n
proof
  let m, n be odd Element of NAT;
  assume that
A1: m <= n and
A2: n <= len W;
A3: len W.cut(m,n) + m = n + 1 by A1,A2,Lm15;
  hereby
    assume W.cut(m,n) is trivial;
    then 1 = (n - m) + 1 by A3,Lm55;
    hence m = n;
  end;
  assume m = n;
  hence thesis by A3,Lm55;
end;

theorem Th133:
  e Joins W.last(),x,G implies W.addEdge(e) is non trivial
proof
  assume e Joins W.last(), x, G;
  then
A1: len W.addEdge(e) = len W + 2 by Lm37;
  1 + 0 < len W + 2 by XREAL_1:10;
  hence thesis by A1,Lm55;
end;

theorem Th134:
  W is non trivial implies ex lenW2 being odd Element of NAT st
  lenW2 = len W - 2 & W.cut(1,lenW2).addEdge(W.(lenW2+1)) = W
proof
  set lenW2 = len W - 2*1;
  assume W is non trivial;
  then len W >= 3 by Lm54;
  then reconsider lenW2 as odd Element of NAT by INT_1:18,XXREAL_0:2;
  set W1 = W.cut(1,lenW2), e = W.(lenW2+1);
  take lenW2;
  thus lenW2 = len W - 2;
  lenW2 < len W - 0 by XREAL_1:17;
  hence W1.addEdge(e) = W.cut(1,lenW2+2) by Th42,ABIAN:12,JORDAN12:3
    .= W by Lm18;
end;

theorem Th135:
  W2 is non trivial & W2.edges() c= W1.edges() implies W2
  .vertices() c= W1.vertices()
proof
  assume that
A1: W2 is non trivial and
A2: W2.edges() c= W1.edges();
A3: 3 <= len W2 by A1,Lm54;
  now
    let v be set;
    assume v in W2.vertices();
    then consider n being odd Element of NAT such that
A4: n <= len W2 and
A5: W2.n = v by Lm45;
    now
      per cases;
      suppose
        n = len W2;
        then 3-1 < n-0 by A3,XREAL_1:17;
        then reconsider n5 = n-2*1 as odd Element of NAT by INT_1:18;
A6:     1 <= n5+1 by NAT_1:12;
        n5 < n - 0 by XREAL_1:17;
        then
A7:     n5 < len W2 by A4,XXREAL_0:2;
        then
A8:     W2.(n5+1) Joins W2.n5, W2.(n5+2), G by Def3;
        n5+1 <= len W2 by A7,NAT_1:13;
        then W2.(n5+1) in W2.edges() by A6,Lm46;
        then consider m being even Element of NAT such that
A9:     1 <= m and
A10:    m <= len W1 and
A11:    W1.m = W2.(n5+1) by A2,Lm46;
        reconsider maa1 = m - 1 as odd Element of NAT by A9,INT_1:18;
A12:    maa1 < len W1 - 0 by A10,XREAL_1:17;
        then
A13:    W1.(maa1+1) Joins W1.maa1, W1.(maa1+2), G by Def3;
A14:    W1.maa1 = W1.vertexAt(maa1) by A12,Def8;
A15:    maa1+2 <= len W1 by A12,Th1;
        then W1.(maa1+2) = W1.vertexAt(maa1+2) by Def8;
        then v = W1.vertexAt(maa1) or v = W1.vertexAt(maa1+2) by A5,A8,A11,A13
,A14,GLIB_000:18;
        hence v in W1.vertices() by A12,A15,Th90;
      end;
      suppose
        n <> len W2;
        then
A16:    n < len W2 by A4,XXREAL_0:1;
        then W2.(n+1) in W2.edges() by Th101;
        then consider m being even Element of NAT such that
A17:    1 <= m and
A18:    m <= len W1 and
A19:    W1.m = W2.(n+1) by A2,Lm46;
A20:    W1.m Joins v, W2.(n+2),G by A5,A16,A19,Def3;
        reconsider maa1 = m - 1 as odd Element of NAT by A17,INT_1:18;
A21:    maa1 < len W1 - 0 by A18,XREAL_1:17;
        then
A22:    W1.(maa1+1) Joins W1.maa1, W1.(maa1+2), G by Def3;
A23:    W1.maa1 = W1.vertexAt(maa1) by A21,Def8;
A24:    maa1+2 <= len W1 by A21,Th1;
        then W1.(maa1+2) = W1.vertexAt(maa1+2) by Def8;
        then v = W1.vertexAt(maa1) or v = W1.vertexAt(maa1+2) by A20,A22,A23,
GLIB_000:18;
        hence v in W1.vertices() by A21,A24,Th90;
      end;
    end;
    hence v in W1.vertices();
  end;
  hence thesis by TARSKI:def 3;
end;

theorem
  W is non trivial implies for v being Vertex of G st v in W.vertices()
  holds not v is isolated
proof
  assume W is non trivial;
  then
A1: len W <> 1 by Lm55;
  let v be Vertex of G;
  assume v in W.vertices();
  then consider n being odd Element of NAT such that
A2: n <= len W and
A3: W.n = v by Lm45;
  now
    per cases;
    suppose
A4:   n = len W;
      1 <= len W by ABIAN:12;
      then 1 < len W by A1,XXREAL_0:1;
      then 1+1 <= len W by NAT_1:13;
      then reconsider lenW2 = len W - 2*1 as odd Element of NAT by INT_1:18;
      lenW2 < len W - 0 by XREAL_1:17;
      then W.(lenW2+1) Joins W.lenW2,W.(lenW2+2),G by Def3;
      then W.(lenW2+1) Joins v,W.lenW2,G by A3,A4,GLIB_000:17;
      hence ex e being set st e in v.edgesInOut() by GLIB_000:65;
    end;
    suppose
      n <> len W;
      then n < len W by A2,XXREAL_0:1;
      then W.(n+1) Joins v, W.(n+2), G by A3,Def3;
      hence ex e being set st e in v.edgesInOut() by GLIB_000:65;
    end;
  end;
  hence thesis by GLIB_000:def 51;
end;

theorem
  W is trivial iff W.edges() = {}
proof
  hereby
    assume W is trivial;
    then W.length() = 0 by Def26;
    then W.edgeSeq() = {};
    hence W.edges() = {};
  end;
  assume W.edges() = {};
  then W.edgeSeq() = {};
  then W.length() = 0;
  hence thesis by Def26;
end;

theorem
  for W1 being Walk of G1, W2 being Walk of G2 st W1 = W2 & W1 is
  trivial holds W2 is trivial
proof
  let W1 be Walk of G1, W2 be Walk of G2;
  assume that
A1: W1 = W2 and
A2: W1 is trivial;
  len W2 = 1 by A1,A2,Lm55;
  hence thesis by Lm55;
end;

theorem
  W is Trail-like iff for m,n being even Element of NAT st 1 <= m & m <
  n & n <= len W holds W.m <> W.n by Lm57;

theorem
  len W <= 3 implies W is Trail-like by Lm61;

theorem
  W is Trail-like iff W.reverse() is Trail-like by Lm58;

theorem
  for W being Trail of G, m,n being Element of NAT holds W.cut(m,n) is
  Trail-like;

theorem
  for W being Trail of G, e being set st e in W.last().edgesInOut() &
  not e in W.edges() holds W.addEdge(e) is Trail-like by Lm60;

theorem
  for W being Trail of G, v being Vertex of G st v in W.vertices() & v
  is endvertex holds v = W.first() or v = W.last()
proof
  let W be Trail of G, v be Vertex of G;
  assume that
A1: v in W.vertices() and
A2: v is endvertex;
  consider e being set such that
A3: v.edgesInOut() = {e} and
  not e Joins v,v,G by A2,GLIB_000:def 53;
  consider n being odd Element of NAT such that
A4: n <= len W and
A5: W.n = v by A1,Lm45;
A6: W.vertexAt(n) = v by A4,A5,Def8;
  now
    reconsider naa1 = n-1 as even Element of NAT by ABIAN:12,INT_1:18;
    assume that
A7: v <> W.first() and
A8: v <> W.last();
A9: n-1 < naa1+2 by NAT_1:16;
    1 <= n by ABIAN:12;
    then
A10: 1 < n by A5,A7,XXREAL_0:1;
    then 1+1 <= n by NAT_1:13;
    then
A11: 1+1-1 <= n-1 by XREAL_1:15;
A12: n < len W by A4,A5,A8,XXREAL_0:1;
    then
A13: W.(n+1) in v.edgesInOut() by A6,Th11;
    W.(n-1) in v.edgesInOut() by A4,A6,A10,Th12;
    then
A14: W.(n-1) = e by A3,TARSKI:def 1;
    n+1 <= len W by A12,NAT_1:13;
    then W.(naa1) <> W.(n+1) by A11,A9,Lm57;
    hence contradiction by A3,A14,A13,TARSKI:def 1;
  end;
  hence thesis;
end;

theorem
  for G being finite _Graph, W being Trail of G holds len W.edgeSeq() <=
  G.size()
proof
  let G be finite _Graph, W be Trail of G;
  consider f being Function such that
A1: dom f = W.edgeSeq() & for x being set st x in W.edgeSeq() holds f.x
  = x`2 from FUNCT_1:sch 3;
  now
A2: W.edgeSeq() is one-to-one by Def27;
    let x1,x2 be set;
    assume that
A3: x1 in dom f and
A4: x2 in dom f and
A5: f.x1 = f.x2;
    consider a1,b1 being set such that
A6: x1 = [a1,b1] by A1,A3,RELAT_1:def 1;
A7: a1 in dom W.edgeSeq() by A1,A3,A6,FUNCT_1:8;
A8: f.x2 = x2`2 by A1,A4;
A9: W.edgeSeq().a1 = b1 by A1,A3,A6,FUNCT_1:8;
    consider a2,b2 being set such that
A10: x2 = [a2,b2] by A1,A4,RELAT_1:def 1;
A11: a2 in dom W.edgeSeq() by A1,A4,A10,FUNCT_1:8;
    f.x1 = x1`2 by A1,A3;
    then
A12: b1 = f.x1 by A6,MCART_1:def 2
      .= b2 by A5,A8,A10,MCART_1:def 2;
    then W.edgeSeq().a2 = b1 by A1,A4,A10,FUNCT_1:8;
    hence x1 = x2 by A6,A10,A12,A2,A7,A9,A11,FUNCT_1:def 8;
  end;
  then
A13: f is one-to-one by FUNCT_1:def 8;
  now
    let y be set;
    assume y in rng f;
    then consider x being set such that
A14: x in dom f and
A15: f.x = y by FUNCT_1:def 5;
    consider a,b being set such that
A16: x = [a,b] by A1,A14,RELAT_1:def 1;
    y = x`2 by A1,A14,A15;
    then y = b by A16,MCART_1:def 2;
    then y in rng W.edgeSeq() by A1,A14,A16,RELAT_1:def 5;
    hence y in (the_Edges_of G);
  end;
  then rng f c= the_Edges_of G by TARSKI:def 3;
  then card W.edgeSeq() c= card (the_Edges_of G) by A1,A13,CARD_1:26;
  then card W.edgeSeq() <= card (the_Edges_of G) by NAT_1:40;
  hence thesis by GLIB_000:def 27;
end;

theorem
  len W <= 3 implies W is Path-like by Lm69;

theorem
  (for m,n being odd Element of NAT st m <= len W & n <= len W & W.m = W
  .n holds m = n) implies W is Path-like by Lm66;

theorem
  for W being Path of G st W is open holds for m, n being odd Element of
  NAT st m < n & n <= len W holds W.m <> W.n
proof
  let W be Path of G;
  assume
A1: W is open;
  let m, n be odd Element of NAT;
  assume that
A2: m < n and
A3: n <= len W;
  now
    assume
A4: W.m = W.n;
    then
A5: n = len W by A2,A3,Def28;
    m = 1 by A2,A3,A4,Def28;
    hence contradiction by A1,A4,A5,Th119;
  end;
  hence thesis;
end;

theorem
  W is Path-like iff W.reverse() is Path-like by Lm63;

theorem
  for W being Path of G, m, n being Element of NAT holds W.cut(m,n) is
  Path-like;

theorem Th151:
  for W being Path of G, e,v being set st e Joins W.last(),v,G &
  not e in W.edges() & (W is trivial or W is open) & for n being odd Element of
  NAT st 1 < n & n <= len W holds W.n <> v holds W.addEdge(e) is Path-like
proof
  let W be Path of G, e,v be set;
  assume that
A1: e Joins W.last(), v,G and
A2: not e in W.edges() and
A3: W is trivial or W is open and
A4: for n being odd Element of NAT st 1 < n & n <= len W holds W.n <> v;
  reconsider lenW = len W as odd Element of NAT;
  set W2 = W.addEdge(e);
A5: e in W.last().edgesInOut() by A1,GLIB_000:65;
  now
    thus W2 is Trail-like by A2,A5,Lm60;
    let m, n be odd Element of NAT;
    assume that
A6: m < n and
A7: n <= len W2 and
A8: W2.m = W2.n;
    now
      per cases by A3;
      suppose
A9:     W is open;
        now
          per cases;
          suppose
A10:        n <= len W;
A11:        1 <= m by ABIAN:12;
            m <= len W by A6,A10,XXREAL_0:2;
            then m in dom W by A11,FINSEQ_3:27;
            then
A12:        W2.m = W.m by A1,Lm38;
            1 <= n by ABIAN:12;
            then n in dom W by A10,FINSEQ_3:27;
            then
A13:        W.m = W.n by A1,A8,A12,Lm38;
            then m = 1 by A6,A10,Def28;
            then W.first() = W.last() by A6,A10,A13,Def28;
            hence m = 1 & n = len W2 by A9,Def24;
          end;
          suppose
            n > len W;
            then lenW + 1 <= n by NAT_1:13;
            then lenW + 1 < n by XXREAL_0:1;
            then lenW + 1 + 1 <= n by NAT_1:13;
            then len W + (1+1) <= n;
            then
A14:        len W2 <= n by A1,Lm37;
            then
A15:        n = len W2 by A7,XXREAL_0:1;
            then W2.n = W2.(len W + 2) by A1,Lm37;
            then
A16:        W2.n = v by A1,Lm38;
            m < len W + (1 + 1) by A1,A6,A15,Lm37;
            then m < len W + 1 + 1;
            then m <= lenW + 1 by NAT_1:13;
            then m < lenW + 1 by XXREAL_0:1;
            then
A17:        m <= len W by NAT_1:13;
            1 <= m by ABIAN:12;
            then m in dom W by A17,FINSEQ_3:27;
            then
A18:        W.m = v by A1,A8,A16,Lm38;
            now
A19:          1 <= m by ABIAN:12;
              assume m <> 1;
              then 1 < m by A19,XXREAL_0:1;
              hence contradiction by A4,A17,A18;
            end;
            hence m = 1;
            thus n = len W2 by A7,A14,XXREAL_0:1;
          end;
        end;
        hence m = 1 & n = len W2;
      end;
      suppose
        W is trivial;
        then ex v being Vertex of G st W = G.walkOf(v) by Lm56;
        then len W = 1 by Th14;
        then
A20:    len W2 = 1 + 2 by A1,Lm37;
A21:    m+1 <= n by A6,NAT_1:13;
A22:    1 <= m by ABIAN:12;
        then 1+1 <= m+1 by XREAL_1:9;
        then 2*1 <= n by A21,XXREAL_0:2;
        then 2*1 < n by XXREAL_0:1;
        then
A23:    len W2 <= n by A20,NAT_1:13;
        then m < 3 by A6,A7,A20,XXREAL_0:1;
        then m+1-1 <= 3-1 by A20,NAT_1:13;
        then m < 2*1 by XXREAL_0:1;
        then m+1 <= 2 by NAT_1:13;
        then m+1-1 <= 2-1 by XREAL_1:15;
        hence m = 1 & n = len W2 by A7,A22,A23,XXREAL_0:1;
      end;
    end;
    hence m = 1 & n = len W2;
  end;
  hence thesis by Def28;
end;

theorem
  for W being Path of G, e, v being set st e Joins W.last(),v,G & not v
  in W.vertices() & (W is trivial or W is open) holds W.addEdge(e) is Path-like
  by Lm68;

theorem
  (for n being odd Element of NAT st n <= len W holds W.find(W.n) = W
  .rfind(W.n)) implies W is Path-like
proof
  assume
A1: for n being odd Element of NAT st n <= len W holds W.find(W.n) = W
  .rfind(W.n);
A2: now
    let x be odd Element of NAT;
    assume
A3: x <= len W;
    then
A4: W.rfind(W.x) >= x by Th116;
A5: W.find(W.x) = W.rfind(W.x) by A1,A3;
    W.find(W.x) <= x by A3,Th116;
    hence W.find(W.x) = x & W.rfind(W.x) = x by A4,A5,XXREAL_0:1;
  end;
  now
    let m, n be even Element of NAT;
    assume that
A6: 1 <= m and
A7: m < n and
A8: n <= len W;
    1 <= n by A6,A7,XXREAL_0:2;
    then n in dom W by A8,FINSEQ_3:27;
    then consider naa1 being odd Element of NAT such that
A9: naa1 = n-1 and
A10: n-1 in dom W and
A11: n+1 in dom W and
A12: W.n Joins W.(naa1), W.(n+1),G by Lm2;
    m <= len W by A7,A8,XXREAL_0:2;
    then m in dom W by A6,FINSEQ_3:27;
    then consider maa1 being odd Element of NAT such that
A13: maa1 = m-1 and
A14: m-1 in dom W and
    m+1 in dom W and
A15: W.m Joins W.(maa1), W.(m+1),G by Lm2;
    now
      set Wnaa1 = W.(naa1), Wn1 = W.(n+1);
      set Wmaa1 = W.(maa1), Wm1 = W.(m+1);
      assume
A16:  W.m = W.n;
      maa1 <= len W by A13,A14,FINSEQ_3:27;
      then
A17:  W.find(Wmaa1) = maa1 by A2;
A18:  n+1 <= len W by A11,FINSEQ_3:27;
A19:  naa1 <= len W by A9,A10,FINSEQ_3:27;
      now
        per cases by A15,A12,A16,GLIB_000:18;
        suppose
          Wmaa1 = Wnaa1 & Wm1 = Wn1;
          then maa1 = naa1 by A2,A19,A17;
          hence contradiction by A7,A13,A9;
        end;
        suppose
          Wmaa1 = Wn1 & Wm1 = Wnaa1;
          then maa1 = n+1 by A2,A18,A17;
          then n <= maa1-1+1 by NAT_1:12;
          then n <= m-1+1 by A13,NAT_1:12;
          hence contradiction by A7;
        end;
      end;
      hence contradiction;
    end;
    hence W.m <> W.n;
  end;
  then
A20: W is Trail-like by Lm57;
  now
    let m, n be odd Element of NAT;
    assume that
A21: m < n and
A22: n <= len W and
A23: W.m = W.n;
    m <= len W by A21,A22,XXREAL_0:2;
    then W.find(W.m) = m by A2;
    hence m = 1 & n = len W by A2,A21,A22,A23;
  end;
  hence thesis by A20,Def28;
end;

theorem
  (for n being odd Element of NAT st n <= len W holds W.rfind(n) = n)
  implies W is Path-like by Lm67;

theorem
  for G being finite _Graph, W being Path of G holds len W.vertexSeq()
  <= G.order() + 1
proof
  let G be finite _Graph, W be Path of G;
  now
    per cases;
    suppose
      len W = 1;
      then 1 + 1 = 2 * len W.vertexSeq() by Def14;
      hence thesis by NAT_1:12;
    end;
    suppose
      len W <> 1;
      then W is non trivial by Lm55;
      then consider lenW2 being odd Element of NAT such that
A1:   lenW2 = len W - 2 and
A2:   W.cut(1,lenW2).addEdge(W.(lenW2+1)) = W by Th134;
      set W2 = W.cut(1,lenW2), vs1 = W2.vertexSeq();
      consider f being Function such that
A3:   dom f = vs1 & for x being set st x in vs1 holds f.x = x`2 from
      FUNCT_1:sch 3;
A4:   lenW2 < len W - 0 by A1,XREAL_1:17;
      then
A5:   len W2 = lenW2 by Lm22;
      now
        let x1, x2 be set;
        assume that
A6:     x1 in dom f and
A7:     x2 in dom f and
A8:     f.x1 = f.x2;
        consider a1,b1 being set such that
A9:     x1 = [a1,b1] by A3,A6,RELAT_1:def 1;
A10:    b1 = vs1.a1 by A3,A6,A9,FUNCT_1:8;
A11:    f.x1 = x1`2 by A3,A6
          .= b1 by A9,MCART_1:def 2;
        consider a2,b2 being set such that
A12:    x2 = [a2,b2] by A3,A7,RELAT_1:def 1;
A13:    a2 in dom vs1 by A3,A7,A12,FUNCT_1:8;
A14:    a1 in dom vs1 by A3,A6,A9,FUNCT_1:8;
A15:    b2 = vs1.a2 by A3,A7,A12,FUNCT_1:8;
A16:    f.x2 = x2`2 by A3,A7
          .= b2 by A12,MCART_1:def 2;
        reconsider a1,a2 as Element of NAT by A14,A13;
A17:    now
          let n1,n2 be Element of NAT;
          assume that
A18:      n1<n2 and
A19:      n1 in dom vs1 and
A20:      n2 in dom vs1 and
A21:      vs1.n1 = vs1.n2;
A22:      2*n2-1 in dom W2 by A20,Th74;
A23:      2*n1-1 in dom W2 by A19,Th74;
          then reconsider a = 2*n1-1, b=2*n2-1 as odd Element of NAT by A22;
A24:      W2.b = W.b by A4,A22,Lm23;
A25:      n2 <= len vs1 by A20,FINSEQ_3:27;
          1 <= n2 by A20,FINSEQ_3:27;
          then
A26:      vs1.n2 = W2.b by A25,Def14;
A27:      n1 <= len vs1 by A19,FINSEQ_3:27;
          1 <= n1 by A19,FINSEQ_3:27;
          then
A28:      vs1.n1 = W2.a by A27,Def14;
          b <= lenW2 by A5,A22,FINSEQ_3:27;
          then
A29:      b < len W by A4,XXREAL_0:2;
          2*n1 < 2*n2 by A18,XREAL_1:70;
          then
A30:      a < b by XREAL_1:16;
          W2.a = W.a by A4,A23,Lm23;
          hence contradiction by A21,A28,A26,A24,A30,A29,Def28;
        end;
        now
          assume
A31:      a1 <> a2;
          now
            per cases;
            suppose
              a1 <= a2;
              then a1 < a2 by A31,XXREAL_0:1;
              hence contradiction by A8,A11,A16,A14,A10,A13,A15,A17;
            end;
            suppose
              a1 > a2;
              hence contradiction by A8,A11,A16,A14,A10,A13,A15,A17;
            end;
          end;
          hence contradiction;
        end;
        hence x1 = x2 by A8,A9,A12,A11,A16;
      end;
      then
A32:  f is one-to-one by FUNCT_1:def 8;
      now
        let y be set;
        assume y in rng f;
        then consider x being set such that
A33:    x in dom f and
A34:    f.x = y by FUNCT_1:def 5;
        consider a,b being set such that
A35:    x = [a,b] by A3,A33,RELAT_1:def 1;
        y = x`2 by A3,A33,A34;
        then
A36:    y = b by A35,MCART_1:def 2;
A37:    b = vs1.a by A3,A33,A35,FUNCT_1:8;
        a in dom vs1 by A3,A33,A35,FUNCT_1:8;
        then y in rng vs1 by A36,A37,FUNCT_1:def 5;
        hence y in the_Vertices_of G;
      end;
      then rng f c= the_Vertices_of G by TARSKI:def 3;
      then card vs1 c= card the_Vertices_of G by A3,A32,CARD_1:26;
      then card vs1 <= card the_Vertices_of G by NAT_1:40;
      then len vs1 <= G.order() by GLIB_000:def 26;
      then
A38:  len vs1 + 1 <= G.order() + 1 by XREAL_1:9;
A39:  lenW2 < len W - 0 by A1,XREAL_1:17;
      then
A40:  W.(lenW2+1) Joins W.lenW2, W.(lenW2+2), G by Def3;
      1 <= lenW2 by ABIAN:12;
      then W2.last() = W.lenW2 by A39,Lm16,JORDAN12:3;
      then W.vertexSeq() = vs1 ^ <*W.(lenW2+2)*> by A2,A40,Th76;
      then len W.vertexSeq() = len vs1 + len <*W.(lenW2+2)*> by FINSEQ_1:35;
      hence thesis by A38,FINSEQ_1:56;
    end;
  end;
  hence thesis;
end;

theorem
  for G being _Graph, W being vertex-distinct Walk of G, e,v being set
  st e Joins W.last(),v,G & not v in W.vertices() holds W.addEdge(e) is
  vertex-distinct
proof
  let G be _Graph, W be vertex-distinct Walk of G, e,v be set;
  assume that
A1: e Joins W.last(),v,G and
A2: not v in W.vertices();
  set W2 = W.addEdge(e);
A3: len W2 = len W + 2 by A1,Lm37;
A4: now
    let n be odd Element of NAT;
    assume that
A5: n <= len W2 and
A6: n > len W;
    len W + 1 <= n by A6,NAT_1:13;
    then len W + 1 < n by XXREAL_0:1;
    then len W + 1 + 1 <= n by NAT_1:13;
    hence n = len W2 by A3,A5,XXREAL_0:1;
    hence W2.n = v by A1,A3,Lm38;
  end;
  now
    let m,n be odd Element of NAT;
    assume that
A7: m <= len W2 and
A8: n <= len W2 and
A9: W2.m = W2.n;
A10: 1 <= n by ABIAN:12;
A11: 1 <= m by ABIAN:12;
    now
      per cases;
      suppose
A12:    m <= len W;
        then m in dom W by A11,FINSEQ_3:27;
        then
A13:    W2.m = W.m by A1,Lm38;
        now
          per cases;
          suppose
A14:        n <= len W;
            then n in dom W by A10,FINSEQ_3:27;
            then W2.n = W.n by A1,Lm38;
            hence m = n by A9,A12,A13,A14,Def29;
          end;
          suppose
            n > len W;
            then W.m = v by A4,A8,A9,A13;
            hence m = n by A2,A12,Lm45;
          end;
        end;
        hence m = n;
      end;
      suppose
A15:    m > len W;
        then
A16:    W2.m = v by A4,A7;
A17:    m = len W2 by A4,A7,A15;
        now
          per cases;
          suppose
A18:        n <= len W;
            then n in dom W by A10,FINSEQ_3:27;
            then v = W.n by A1,A9,A16,Lm38;
            hence m = n by A2,A18,Lm45;
          end;
          suppose
            n > len W;
            hence m = n by A4,A8,A17;
          end;
        end;
        hence m =n;
      end;
    end;
    hence m = n;
  end;
  hence thesis by Def29;
end;

theorem
  e Joins x,x,G implies G.walkOf(x,e,x) is Cycle-like
proof
  set W = G.walkOf(x,e,x);
  assume e Joins x,x,G;
  then len W = 3 by Th15;
  then W is non trivial by Lm54;
  hence thesis by Def31;
end;

theorem
  e Joins x,y,G & e in W1.edges() & W1 is Cycle-like implies ex W2 being
  Walk of G st W2 is_Walk_from x,y & not e in W2.edges()
proof
  assume that
A1: e Joins x,y,G and
A2: e in W1.edges() and
A3: W1 is Cycle-like;
  consider v1,v2 being Vertex of G, n being odd Element of NAT such that
A4: n+2 <= len W1 and
A5: v1 = W1.n and
A6: e = W1.(n+1) and
A7: v2 = W1.(n+2) and
A8: e Joins v1,v2,G by A2,Lm47;
  set WA = W1.cut(n+2, len W1), WB = W1.cut(2*0+1,n);
A9: WA.last() = W1.last() by A4,Lm16;
A10: n+2-2 < len W1-0 by A4,XREAL_1:17;
A11: now
    assume e in WB.edges();
    then consider m being even Element of NAT such that
A12: 1 <= m and
A13: m <= len WB and
A14: WB.m = e by Lm46;
    m in dom WB by A12,A13,FINSEQ_3:27;
    then
A15: W1.m = W1.(n+1) by A6,A10,A14,Lm23;
    len WB = n by A10,Lm22;
    then
A16: m+0 < n+1 by A13,XREAL_1:10;
    n+1 <= len W1 by A10,NAT_1:13;
    hence contradiction by A3,A12,A15,A16,Lm57;
  end;
  1 <= n by ABIAN:12;
  then WB is_Walk_from W1.first(), v1 by A5,A10,Lm16;
  then
A17: WB is_Walk_from W1.last(), v1 by A3,Def24;
A18: WA is_Walk_from v2, W1.(len W1) by A4,A7,Lm16;
  then WA.append(WB) is_Walk_from v2,v1 by A17,Th32;
  then
A19: WA.append(WB).reverse() is_Walk_from v1,v2 by Th24;
A20: now
    assume e in WA.edges();
    then consider m being even Element of NAT such that
A21: 1 <= m and
A22: m <= len WA and
A23: WA.m = e by Lm46;
    reconsider maa1 = m-1 as odd Element of NAT by A21,INT_1:18;
A24: maa1 < len WA - 0 by A22,XREAL_1:17;
    then n+2+maa1 in dom W1 by A4,Lm15;
    then
A25: n+2+maa1 <= len W1 by FINSEQ_3:27;
    maa1+1 = m;
    then
A26: e = W1.(n+2+maa1) by A4,A23,A24,Lm15;
    n+1 < n+1+1 by NAT_1:13;
    then
A27: n+1+0 < n+2+maa1 by XREAL_1:10;
    1 <= n+1 by NAT_1:12;
    hence contradiction by A3,A6,A26,A25,A27,Lm57;
  end;
  WB.first() = W1.last() by A17,Def23;
  then WA.append(WB).edges() = WA.edges() \/ WB.edges() by A9,Th103;
  then
A28: not e in WA.append(WB).edges() by A20,A11,XBOOLE_0:def 3;
  then
A29: not e in WA.append(WB).reverse().edges() by Th108;
  now
    per cases by A1,A8,GLIB_000:18;
    suppose
      x = v1 & y = v2;
      hence thesis by A29,A19;
    end;
    suppose
      x = v2 & y = v1;
      hence thesis by A18,A17,A28,Th32;
    end;
  end;
  hence thesis;
end;

theorem
  W is Subwalk of W by Lm70;

theorem
  for W1 being Walk of G, W2 being Subwalk of W1, W3 being Subwalk of W2
  holds W3 is Subwalk of W1 by Lm71;

theorem
  W1 is Subwalk of W2 implies (W1 is_Walk_from x,y iff W2 is_Walk_from x ,y)
proof
  assume
A1: W1 is Subwalk of W2;
  hereby
A2: W1 is_Walk_from W2.first(),W2.last() by A1,Def32;
    assume
A3: W1 is_Walk_from x,y;
    then W1.last() = y by Def23;
    then
A4: y = W2.last() by A2,Def23;
    W1.first() = x by A3,Def23;
    then x = W2.first() by A2,Def23;
    hence W2 is_Walk_from x,y by A4,Def23;
  end;
  assume
A5: W2 is_Walk_from x,y;
  then
A6: W2.last() = y by Def23;
  W2.first() = x by A5,Def23;
  hence thesis by A1,A6,Def32;
end;

theorem Th162:
  W1 is Subwalk of W2 implies W1.first() = W2.first() & W1.last() = W2.last()
proof
  assume W1 is Subwalk of W2;
  then W1 is_Walk_from W2.first(), W2.last() by Def32;
  hence thesis by Def23;
end;

theorem
  W1 is Subwalk of W2 implies len W1 <= len W2 by Lm72;

theorem Th164:
  W1 is Subwalk of W2 implies W1.edges() c= W2.edges() & W1
  .vertices() c= W2.vertices()
proof
  assume
A1: W1 is Subwalk of W2;
  then consider es being Subset of W2.edgeSeq() such that
A2: W1.edgeSeq() = Seq es by Def32;
  now
    let e be set;
    assume e in W1.edges();
    then consider n being even Element of NAT such that
A3: 1 <= n and
A4: n <= len W1 and
A5: W1.n = e by Lm46;
A6: W1.n = (Seq es).(n div 2) by A2,A3,A4,Lm40;
    n div 2 in dom Seq es by A2,A3,A4,Lm40;
    then
    ex m being Element of NAT st m in dom W2.edgeSeq() & n div 2 <= m &
    W1.n = W2.edgeSeq().m by A6,Th4;
    hence e in W2.edges() by A5,Th105;
  end;
  hence
A7: W1.edges() c= W2.edges() by TARSKI:def 3;
  now
    per cases;
    suppose
A8:   W1 is trivial;
      now
        let v be set;
        assume v in W1.vertices();
        then consider n being odd Element of NAT such that
A9:     n <= len W1 and
A10:    W1.n = v by Lm45;
A11:    1 <= n by ABIAN:12;
        n <= 1 by A8,A9,Lm55;
        then v = W1.first() by A10,A11,XXREAL_0:1;
        then v = W2.first() by A1,Th162;
        hence v in W2.vertices() by Th89;
      end;
      hence thesis by TARSKI:def 3;
    end;
    suppose
      W1 is non trivial;
      hence thesis by A7,Th135;
    end;
  end;
  hence thesis;
end;

theorem Th165:
  W1 is Subwalk of W2 implies for m being odd Element of NAT st m
<= len W1 holds ex n being odd Element of NAT st m <= n & n <= len W2 & W1.m =
  W2.n
proof
  assume
A1: W1 is Subwalk of W2;
  let m be odd Element of NAT such that
A2: m <= len W1;
A3: ex es being Subset of W2.edgeSeq() st W1.edgeSeq() = Seq es by A1,Def32;
  now
    per cases by A2,XXREAL_0:1;
    suppose
A4:   m < len W1;
      then
A5:   W1.(m+1) Joins W1.m, W1.(m+2), G by Def3;
      reconsider m1= m+1 as even Element of NAT;
A6:   1 <= m1 by NAT_1:12;
A7:   m1 <= len W1 by A4,NAT_1:13;
      then
A8:   W1.m1 = W1.edgeSeq().(m1 div 2) by A6,Lm40;
      m1 div 2 in dom W1.edgeSeq() by A6,A7,Lm40;
      then consider x being Element of NAT such that
A9:   x in dom W2.edgeSeq() and
A10:  m1 div 2 <= x and
A11:  W1.m1 = W2.edgeSeq().x by A3,A8,Th4;
      set n = 2*x;
A12:  1 <= x by A9,FINSEQ_3:27;
      2 divides m1 by PEPIN:22;
      then 2 * (m1 div 2) = m1 by NAT_D:3;
      then m1 <= n by A10,XREAL_1:66;
      then
A13:  m1-1 <= n-1 by XREAL_1:15;
A14:  x <= len W2.edgeSeq() by A9,FINSEQ_3:27;
A15:  n in dom W2 by A9,Lm41;
      then 1 <= n by FINSEQ_3:27;
      then reconsider naa1 = n - 1 as odd Element of NAT by INT_1:18;
      n <= len W2 by A15,FINSEQ_3:27;
      then
A16:  naa1 < len W2 - 0 by XREAL_1:17;
      then W2.(naa1+1) Joins W2.naa1, W2.(naa1+2), G by Def3;
      then
A17:  W1.m1 Joins W2.naa1, W2.(naa1+2), G by A11,A12,A14,Def15;
A18:  naa1 + 2 <= len W2 by A16,Th1;
      now
        per cases by A5,A17,GLIB_000:18;
        suppose
          W1.m = W2.naa1;
          hence thesis by A16,A13;
        end;
        suppose
          W1.m = W2.(naa1+2);
          hence thesis by A13,A18,NAT_1:12;
        end;
      end;
      hence thesis;
    end;
    suppose
A19:  m = len W1;
      len W1 <= len W2 by A1,Lm72;
      then
A20:  m <= len W2 by A2,XXREAL_0:2;
      W1.m = W1.last() by A19
        .= W2.last() by A1,Th162
        .= W2.(len W2);
      hence thesis by A20;
    end;
  end;
  hence thesis;
end;

theorem
  W1 is Subwalk of W2 implies for m being even Element of NAT st 1 <= m
& m <= len W1 holds ex n being even Element of NAT st m <= n & n <= len W2 & W1
  .m = W2.n
proof
  assume W1 is Subwalk of W2;
  then
A1: ex es being Subset of W2.edgeSeq() st W1.edgeSeq() = Seq es by Def32;
  let m be even Element of NAT such that
A2: 1 <= m and
A3: m <= len W1;
A4: W1.m = W1.edgeSeq().(m div 2) by A2,A3,Lm40;
  m div 2 in dom W1.edgeSeq() by A2,A3,Lm40;
  then consider ndiv2 being Element of NAT such that
A5: ndiv2 in dom W2.edgeSeq() and
A6: m div 2 <= ndiv2 and
A7: W1.m = W2.edgeSeq().ndiv2 by A1,A4,Th4;
A8: ndiv2 <= len W2.edgeSeq() by A5,FINSEQ_3:27;
  2 divides m by PEPIN:22;
  then
A9: 2 * (m div 2) = m by NAT_D:3;
  2*ndiv2 in dom W2 by A5,Lm41;
  then
A10: 2*ndiv2 <= len W2 by FINSEQ_3:27;
  1 <= ndiv2 by A5,FINSEQ_3:27;
  then W1.m = W2.(2*ndiv2) by A7,A8,Def15;
  hence thesis by A6,A9,A10,XREAL_1:66;
end;

theorem
  for W1 being Trail of G st W1 is non trivial holds ex W2 being Path of
  W1 st W2 is non trivial
proof
  let W1 be Trail of G;
  assume W1 is non trivial;
  then
A1: 1 <> len W1 by Lm55;
  1 <= len W1 by ABIAN:12;
  then
A2: 1 < len W1 by A1,XXREAL_0:1;
  now
    per cases;
    suppose
A3:   W1 is open;
      consider P being Path of W1;
      take P;
A4:   P.first() = W1.first() by Th162;
A5:   P.last() = W1.last() by Th162;
      W1.first() <> W1.last() by A3,Def24;
      hence P is non trivial by A4,A5,Lm55;
    end;
    suppose
A6:   W1 is closed;
      defpred P[Nat] means $1 is odd & 1 < $1 & $1 <= len W1 & W1.($1) = W1.(
      len W1);
A7:   ex k being Nat st P[k] by A2;
      consider k being Nat such that
A8:   P[k] & for m being Nat st P[m] holds k <= m from NAT_1:sch 5(
      A7);
      reconsider k as odd Element of NAT by A8,ORDINAL1:def 13;
      1+1 < k+1 by A8,XREAL_1:10;
      then 2 <= k by NAT_1:13;
      then reconsider k2 = k - 2*1 as odd Element of NAT by INT_1:18;
      set W3 = W1.remove(k,len W1);
      set W4 = W3.cut(2*0+1,k2);
      consider W5 being Path of W4;
      consider es5 being Subset of W4.edgeSeq() such that
A9:   W5.edgeSeq() = Seq es5 by Def32;
A10:  W4.edgeSeq() c= W3.edgeSeq() by Lm43;
      W1.k = W1.last() by A8;
      then
A11:  W3 = W1.cut(1,k) by Th58;
      then W3.edgeSeq() c= W1.edgeSeq() by Lm43;
      then W4.edgeSeq() c= W1.edgeSeq() by A10,XBOOLE_1:1;
      then reconsider es5 as Subset of W1.edgeSeq() by XBOOLE_1:1;
A12:  W5 is_Walk_from W4.first(), W4.last() by Def32;
A13:  len W3 + len W1 = len W1 + k by A8,Lm24;
      then
A14:  k2 <= len W3 - 0 by XREAL_1:15;
A15:  1 <= k2 by ABIAN:12;
      then W4.last() = W3.k2 by A14,Lm16;
      then
A16:  W5.last() = W3.k2 by A12,Def23;
      k2 in dom W3 by A14,A15,FINSEQ_3:27;
      then
A17:  W5.last() = W1.k2 by A8,A16,A11,Lm23;
      W4.first() = W3.1 by A14,A15,Lm16;
      then
A18:  W5.first() = W3.1 by A12,Def23;
A19:  W1.1 = W1.(len W1) by A6,Th119;
A20:  now
        1 <= len W3 by ABIAN:12;
        then
A21:    2*0+1 in dom W3 by FINSEQ_3:27;
        assume that
A22:    W5 is non trivial and
A23:    W5 is closed;
        W5.first() = W1.k2 by A17,A23,Def24;
        then
A24:    W1.k2 = W1.(len W1) by A19,A8,A18,A11,A21,Lm23;
        now
          assume k2 = 1;
          then len W4 = 1 by A14,Lm22;
          then
A25:      len W5 <= 1 by Lm72;
          1 <= len W5 by ABIAN:12;
          then len W5 = 1 by A25,XXREAL_0:1;
          hence contradiction by A22,Lm55;
        end;
        then
A26:    1 < k2 by A15,XXREAL_0:1;
A27:    k2 < k - 0 by XREAL_1:17;
        then k2 <= len W1 by A8,XXREAL_0:2;
        hence contradiction by A8,A24,A26,A27;
      end;
      set e = W1.(k2+1), W2 = W5.addEdge(e);
      k2 < len W1 - 0 by A8,XREAL_1:17;
      then
A28:  e Joins W1.k2, W1.(k2+2), G by Def3;
A29:  k2 < len W3 - 0 by A13,XREAL_1:17;
      then
A30:  len W4 = k2 by Lm22;
A31:  now
        let m be odd Element of NAT;
        assume that
A32:    1 < m and
A33:    m <= len W5;
        consider n being odd Element of NAT such that
A34:    m <= n and
A35:    n <= len W4 and
A36:    W5.m = W4.n by A33,Th165;
A37:    1 < n by A32,A34,XXREAL_0:2;
        then n in dom W4 by A35,FINSEQ_3:27;
        then
A38:    W5.m = W3.n by A14,A36,Lm23;
A39:    n+0 < k2+2 by A30,A35,XREAL_1:10;
        then
A40:    n <= len W1 by A8,XXREAL_0:2;
        n in dom W3 by A13,A37,A39,FINSEQ_3:27;
        then W5.m = W1.n by A8,A11,A38,Lm23;
        hence W5.m <> W1.k by A8,A37,A39,A40;
      end;
      k2+1 <= k by A13,A29,NAT_1:13;
      then
A41:  k2+1 <= len W1 by A8,XXREAL_0:2;
      now
        assume
A42:    e in W5.edges();
        W5.edges() c= W4.edges() by Th164;
        then consider n being even Element of NAT such that
A43:    1 <= n and
A44:    n <= len W4 and
A45:    W4.n = e by A42,Lm46;
A46:    n < k2+1 by A30,A44,NAT_1:13;
        n <= k2+2 by A30,A44,NAT_1:12;
        then
A47:    n in dom W3 by A13,A43,FINSEQ_3:27;
        n in dom W4 by A43,A44,FINSEQ_3:27;
        then e = W3.n by A14,A45,Lm23;
        then W1.(k2+1) = W1.n by A8,A11,A47,Lm23;
        hence contradiction by A41,A43,A46,Lm57;
      end;
      then reconsider W2 as Path of G by A28,A17,A20,A31,Th151;
      set g = ((k2+1) div 2) .--> e, es = es5 +* g;
A48:  dom es = dom es5 \/ dom g by FUNCT_4:def 1;
A49:  dom g = {(k2+1) div 2} by FUNCOP_1:19;
A50:  g.((k2+1) div 2) = e by FUNCOP_1:87;
A51:  now
        let z be set;
        assume
A52:    z in es;
        then consider x,y being set such that
A53:    z = [x,y] by RELAT_1:def 1;
A54:    x in dom es by A52,A53,FUNCT_1:8;
A55:    y = es.x by A52,A53,FUNCT_1:8;
        now
          per cases;
          suppose
A56:        x in dom g;
            then
A57:        x = (k2+1) div 2 by A49,TARSKI:def 1;
A58:        1 <= k2+1 by NAT_1:12;
            then W1.(k2+1) = W1.edgeSeq().x by A41,A57,Lm40;
            then
A59:        W1.edgeSeq().x = y by A48,A50,A54,A55,A56,A57,FUNCT_4:def 1;
            x in dom W1.edgeSeq() by A41,A57,A58,Lm40;
            hence z in W1.edgeSeq() by A53,A59,FUNCT_1:8;
          end;
          suppose
A60:        not x in dom g;
            then
A61:        x in dom es5 by A48,A54,XBOOLE_0:def 3;
            y = es5.x by A48,A54,A55,A60,FUNCT_4:def 1;
            then z in es5 by A53,A61,FUNCT_1:8;
            hence z in W1.edgeSeq();
          end;
        end;
        hence z in W1.edgeSeq();
      end;
      then es c= W1.edgeSeq() by TARSKI:def 3;
      then dom es c= dom W1.edgeSeq() by RELAT_1:25;
      then
A62:  dom es c= Seg len W1.edgeSeq() by FINSEQ_1:def 3;
      then reconsider es as FinSubsequence by FINSEQ_1:def 12;
      reconsider es as Subset of W1.edgeSeq() by A51,TARSKI:def 3;
A63:  dom es5 c= dom W4.edgeSeq() by GRAPH_2:27;
      now
        thus dom es5 c= Seg len W1.edgeSeq() & dom g c= Seg len W1.edgeSeq()
        by A48,A62,XBOOLE_1:11;
        let x,y be Element of NAT such that
A64:    x in dom es5 and
A65:    y in dom g;
        x <= len W4.edgeSeq() by A63,A64,FINSEQ_3:27;
        then 2*x <= 2*len W4.edgeSeq() by XREAL_1:66;
        then 2*x+1 <= 2*len W4.edgeSeq()+1 by XREAL_1:9;
        then
A66:    2*x+1 <= k2 by A30,Def15;
A67:    2 divides k2+1 by PEPIN:22;
        y = (k2+1) div 2 by A49,A65,TARSKI:def 1;
        then 2*y = k2+1 by A67,NAT_D:3;
        then 2*x+1 < 2*y by A66,NAT_1:13;
        then
A68:    2*x+1-1 < 2*y - 0 by XREAL_1:16;
        then x <= y by XREAL_1:70;
        hence x < y by A68,XXREAL_0:1;
      end;
      then
A69:  Sgm(dom es) = Sgm(dom es5) ^ Sgm(dom g) by A48,FINSEQ_3:48;
A70:  k2 in dom W3 by A15,A29,FINSEQ_3:27;
      then
A71:  W5.last() = W1.k2 by A8,A16,A11,Lm23;
      now
        now
          assume dom es5 /\ dom g <> {};
          then consider x being set such that
A72:      x in dom es5 /\ dom g by XBOOLE_0:def 1;
          x in dom g by A72,XBOOLE_0:def 4;
          then
A73:      x = (k2+1) div 2 by A49,TARSKI:def 1;
          x in dom es5 by A72,XBOOLE_0:def 4;
          then (k2+1) div 2 <= len W4.edgeSeq() by A63,A73,FINSEQ_3:27;
          then
A74:      2 * ((k2+1) div 2) <= 2*len W4.edgeSeq() by XREAL_1:66;
          2 divides (k2+1) by PEPIN:22;
          then k2+1 <= 2*len W4.edgeSeq() by A74,NAT_D:3;
          then k2+1+1 <= 2*len W4.edgeSeq()+1 by XREAL_1:9;
          then (1+1)+k2 <= 0 + k2 by A30,Def15;
          hence contradiction by XREAL_1:8;
        end;
        then
A75:    dom es5 misses dom g by XBOOLE_0:def 7;
        len W2 = len W5 + 2 by A28,A71,Lm37;
        then
A76:    len W5 + 2 = 2 * len W2.edgeSeq() + 1 by Def15;
A77:    len Sgm(dom es5) = card dom es5 by A48,A62,FINSEQ_3:44,XBOOLE_1:11
          .= card es5 by CARD_1:104
          .= len W5.edgeSeq() by A9,Th5;
A78:    now
          assume k2+1 div 2 = 0;
          then
A79:      2 * ((k2+1) div 2) = 2*0;
          2 divides k2+1 by PEPIN:22;
          hence contradiction by A79,NAT_D:3;
        end;
        Sgm dom g = Sgm {(k2+1) div 2} by FUNCOP_1:19;
        then
A80:    Sgm dom g = <* (k2+1) div 2 *> by A78,FINSEQ_3:50;
        then
A81:    len Sgm dom g = 1 by FINSEQ_1:57;
A82:    (Sgm dom g).1 = (k2+1) div 2 by A80,FINSEQ_1:57;
        set h = Sgm dom es;
A83:    Seq es = es * h by FINSEQ_1:def 14;
        len Seq es = card es by Th5
          .= card dom es by CARD_1:104;
        then len Seq es = card dom es5 + card dom g by A48,A75,CARD_2:53
          .= card dom es5 + 1 by A49,CARD_1:50
          .= card es5 + 1 by CARD_1:104
          .= len W5.edgeSeq() + 1 by A9,Th5;
        then
A84:    2 * len Seq es + 1 = 2*len W5.edgeSeq() + 1 + 2
          .= 2 * len W2.edgeSeq() + 1 by A76,Def15;
        hence len W2.edgeSeq() = len Seq es;
        let x be Nat;
        assume that
A85:    1 <= x and
A86:    x <= len W2.edgeSeq();
A87:    dom es5 c=Seg len W1.edgeSeq() by A48,A62,XBOOLE_1:11;
A88:    x in dom (Seq es) by A84,A85,A86,FINSEQ_3:27;
        then
A89:    h.x in dom es by A83,FUNCT_1:21;
A90:    dom h = Seg (len Sgm(dom es5) + len (Sgm dom g)) by A69,FINSEQ_1:def 7;
A91:    e Joins W5.last(), W1.k, G by A8,A28,A16,A11,A70,Lm23;
A92:    (Seq es).x = es.(h.x) by A83,A88,FUNCT_1:22;
A93:    x in dom h by A83,A88,FUNCT_1:21;
        now
          per cases;
          suppose
A94:        x <= len Sgm (dom es5);
            then
A95:        x in dom Sgm dom es5 by A85,FINSEQ_3:27;
            then
A96:        h.x = Sgm(dom es5).x by A69,FINSEQ_1:def 7;
            rng Sgm(dom es5) = dom es5 by A87,FINSEQ_1:def 13;
            then h.x in dom es5 by A95,A96,FUNCT_1:def 5;
            then not h.x in dom g by A75,XBOOLE_0:3;
            then
A97:        (Seq es).x = es5.(Sgm(dom es5).x) by A48,A89,A92,A96,FUNCT_4:def 1;
A98:        x in dom W5.edgeSeq() by A85,A77,A94,FINSEQ_3:27;
            then
A99:        2*x in dom W5 by Lm41;
            W5.edgeSeq().x = W5.(2*x) by A85,A77,A94,Def15;
            then
A100:       W2.(2*x) = W5.edgeSeq().x by A91,A99,Lm38
              .= (es5 * Sgm(dom es5)).x by A9,FINSEQ_1:def 14;
            x in dom (es5 * Sgm(dom es5)) by A9,A98,FINSEQ_1:def 14;
            hence (Seq es).x = W2.(2*x) by A97,A100,FUNCT_1:22;
          end;
          suppose
            len Sgm (dom es5) < x;
            then
A101:       len Sgm(dom es5) + 1 <= x by NAT_1:13;
            x <= len Sgm(dom es5) + 1 by A93,A90,A81,FINSEQ_1:3;
            then
A102:       x = len Sgm(dom es5) + 1 by A101,XXREAL_0:1;
            1 in dom Sgm(dom g) by A81,FINSEQ_3:27;
            then
A103:       h.x = (k2+1) div 2 by A69,A82,A102,FINSEQ_1:def 7;
            then h.x in dom g by A49,TARSKI:def 1;
            then
A104:       (Seq es).x = g.((k2+1) div 2) by A48,A89,A92,A103,FUNCT_4:def 1
              .= e by FUNCOP_1:87
              .= W2.(len W5 + 1) by A91,Lm38;
            2*x = 2*len W5.edgeSeq()+1+1 by A77,A102
              .= len W5 + 1 by Def15;
            hence (Seq es).x = W2.(2*x) by A104;
          end;
        end;
        hence W2.edgeSeq().x = (Seq es).x by A85,A86,Def15;
      end;
      then
A105: W2.edgeSeq() = Seq es by FINSEQ_1:18;
      1 <= len W3 by ABIAN:12;
      then 2*0+1 in dom W3 by FINSEQ_3:27;
      then W5.first() = W1.first() by A8,A18,A11,Lm23;
      then W5 is_Walk_from W1.first(), W1.k2 by A71,Def23;
      then W2 is_Walk_from W1.first(), W1.last() by A8,A28,Lm39;
      then reconsider W2 as Path of W1 by A105,Def32;
      take W2;
      thus W2 is non trivial by A28,A17,Th133;
    end;
  end;
  hence thesis;
end;

theorem Th168:
  for G1 being _Graph, G2 being Subgraph of G1, W being Walk of
  G2 holds W is Walk of G1
proof
  let G1 be _Graph, G2 be Subgraph of G1, W be Walk of G2;
  set VG1 = the_Vertices_of G1, VG2 = the_Vertices_of G2;
  set EG1 = the_Edges_of G1, EG2 = the_Edges_of G2;
A1: EG2 c= VG1 \/ EG1 by XBOOLE_1:10;
A2: now
    thus len W is odd;
    W.1 in VG2 by Def3;
    hence W.1 in VG1;
    let n be odd Element of NAT;
    assume n < len W;
    then W.(n+1) Joins W.n, W.(n+2), G2 by Def3;
    hence W.(n+1) Joins W.n, W.(n+2), G1 by GLIB_000:75;
  end;
  VG2 c= VG1 \/ EG1 by XBOOLE_1:10;
  then VG2 \/ EG2 c= VG1 \/ EG1 by A1,XBOOLE_1:8;
  then for y being set st y in rng W holds y in VG1 \/ EG1 by TARSKI:def 3;
  then rng W c= VG1 \/ EG1 by TARSKI:def 3;
  then W is FinSequence of VG1 \/ EG1 by FINSEQ_1:def 4;
  hence thesis by A2,Def3;
end;

theorem Th169:
  for G1 being _Graph, G2 being Subgraph of G1, W being Walk of
  G1 st W is trivial & W.first() in the_Vertices_of G2 holds W is Walk of G2
proof
  let G1 be _Graph, G2 be Subgraph of G1, W be Walk of G1;
  assume that
A1: W is trivial and
A2: W.first() in the_Vertices_of G2;
  consider v being Vertex of G1 such that
A3: W = G1.walkOf(v) by A1,Lm56;
  reconsider v9= v as Vertex of G2 by A2,A3,Th14;
  W = G2.walkOf(v9) by A3;
  hence thesis;
end;

theorem Th170:
  for G1 being _Graph, G2 being Subgraph of G1, W being Walk of
  G1 st W is non trivial & W.edges() c= the_Edges_of G2 holds W is Walk of G2
proof
  let G1 be _Graph, G2 be Subgraph of G1, W be Walk of G1;
  assume that
A1: W is non trivial and
A2: W.edges() c= the_Edges_of G2;
  set VG2 = the_Vertices_of G2, EG2 = the_Edges_of G2;
  set WV = W.vertices(), WE = W.edges();
A3: now
    let n be odd Element of NAT such that
A4: n <= len W;
    now
      per cases;
      suppose
A5:     n = len W;
A6:     1 <= n by ABIAN:12;
        n <> 1 by A1,A5,Lm54;
        then 1 < n by A6,XXREAL_0:1;
        then 1+1 <= n by NAT_1:13;
        then reconsider n5 = n-2*1 as odd Element of NAT by INT_1:18;
        n5+1 = n-(2-1);
        then
A7:     n5+1 <= len W-0 by A5,XREAL_1:15;
        n5 < len W - 0 by A5,XREAL_1:17;
        then
A8:     W.(n5+1) Joins W.n5, W.(n5+2), G1 by Def3;
        1 <= n5+1 by NAT_1:12;
        then W.(n5+1) in W.edges() by A7,Lm46;
        then W.(n5+1) Joins W.n5, W.(n5+2), G2 by A2,A8,GLIB_000:76;
        hence W.n in the_Vertices_of G2 by GLIB_000:16;
      end;
      suppose
        n <> len W;
        then
A9:     n < len W by A4,XXREAL_0:1;
        then
A10:    W.(n+1) Joins W.n, W.(n+2), G1 by Def3;
A11:    1 <= n+1 by NAT_1:12;
        n+1 <= len W by A9,NAT_1:13;
        then W.(n+1) in W.edges() by A11,Lm46;
        then W.(n+1) Joins W.n, W.(n+2), G2 by A2,A10,GLIB_000:76;
        hence W.n in the_Vertices_of G2 by GLIB_000:16;
      end;
    end;
    hence W.n in VG2;
  end;
  now
    let y be set;
    assume y in rng W;
    then
A12: y in WV \/ WE by Th102;
    now
      per cases by A12,XBOOLE_0:def 3;
      suppose
        y in WV;
        then ex n being odd Element of NAT st n <= len W & W.n = y by Lm45;
        then y in VG2 by A3;
        hence y in VG2 \/ EG2 by XBOOLE_0:def 3;
      end;
      suppose
        y in WE;
        hence y in VG2 \/ EG2 by A2,XBOOLE_0:def 3;
      end;
    end;
    hence y in VG2 \/ EG2;
  end;
  then rng W c= VG2 \/ EG2 by TARSKI:def 3;
  then
A13: W is FinSequence of VG2 \/ EG2 by FINSEQ_1:def 4;
  now
    reconsider aa1 = 1 as odd Element of NAT by JORDAN12:3;
    thus len W is odd;
    aa1 <= len W by ABIAN:12;
    hence W.1 in VG2 by A3;
    let n be odd Element of NAT;
A14: 1 <= n+1 by NAT_1:12;
    assume
A15: n < len W;
    then
A16: W.(n+1) Joins W.n, W.(n+2), G1 by Def3;
    n+1 <= len W by A15,NAT_1:13;
    then W.(n+1) in W.edges() by A14,Lm46;
    hence W.(n+1) Joins W.n, W.(n+2), G2 by A2,A16,GLIB_000:76;
  end;
  hence thesis by A13,Def3;
end;

theorem Th171:
  for G1 being _Graph, G2 being Subgraph of G1, W being Walk of
G1 st W.vertices() c= the_Vertices_of G2 & W.edges() c= the_Edges_of G2 holds W
  is Walk of G2
proof
  let G1 be _Graph, G2 be Subgraph of G1, W be Walk of G1;
  assume that
A1: W.vertices() c= the_Vertices_of G2 and
A2: W.edges() c= the_Edges_of G2;
  now
    per cases;
    suppose
      W is non trivial;
      hence thesis by A2,Th170;
    end;
    suppose
A3:   W is trivial;
      W.first() in W.vertices() by Th89;
      hence thesis by A1,A3,Th169;
    end;
  end;
  hence thesis;
end;

theorem
  for G1 being non trivial _Graph, W being Walk of G1, v being Vertex of
  G1, G2 being removeVertex of G1,v st not v in W.vertices() holds W is Walk of
  G2
proof
  let G1 be non trivial _Graph, W be Walk of G1, v be Vertex of G1, G2 be
  removeVertex of G1,v;
  assume
A1: not v in W.vertices();
  set EG2 = (the_Edges_of G1) \ v.edgesInOut();
  set W2 = W, VG2 = (the_Vertices_of G1) \ {v};
  v.edgesInOut() = G1.edgesInOut({v}) by GLIB_000:def 42;
  then
A2: EG2 = G1.edgesBetween( the_Vertices_of G1 \ {v}) by GLIB_000:38;
  now
    let y be set;
    assume y in rng W2;
    then consider x being set such that
A3: x in dom W2 and
A4: y = W2.x by FUNCT_1:def 5;
    reconsider x as Element of NAT by A3;
A5: x <= len W2 by A3,FINSEQ_3:27;
    now
      per cases;
      suppose
A6:     x is odd;
A7:     now
          assume y in {v};
          then not y in W.vertices() by A1,TARSKI:def 1;
          hence contradiction by A4,A5,A6,Lm45;
        end;
        y in the_Vertices_of G1 by A4,A5,A6,Lm1;
        then y in VG2 by A7,XBOOLE_0:def 5;
        hence y in VG2 \/ EG2 by XBOOLE_0:def 3;
      end;
      suppose
        x is even;
        then reconsider x as even Element of NAT;
        consider xaa1 being odd Element of NAT such that
A8:     xaa1 = x-1 and
A9:     x-1 in dom W2 and
A10:    x+1 in dom W2 and
A11:    W2.x Joins W2.(xaa1), W2.(x+1),G1 by A3,Lm2;
A12:    x+1 <= len W2 by A10,FINSEQ_3:27;
A13:    xaa1 <= len W2 by A8,A9,FINSEQ_3:27;
A14:    now
          assume y in v.edgesInOut();
          then
A15:      y in v.edgesIn() \/ v.edgesOut() by GLIB_000:63;
          now
            per cases by A15,XBOOLE_0:def 3;
            suppose
              y in v.edgesIn();
              then (the_Target_of G1).y = v by GLIB_000:59;
              hence v=W2.(xaa1) or v = W2.(x+1) by A4,A11,GLIB_000:def 15;
            end;
            suppose
              y in v.edgesOut();
              then (the_Source_of G1).y = v by GLIB_000:61;
              hence v=W2.(xaa1) or v = W2.(x+1) by A4,A11,GLIB_000:def 15;
            end;
          end;
          then v = W2.vertexAt(xaa1) or v = W2.vertexAt(x+1) by A13,A12,Def8;
          hence contradiction by A1,A13,A12,Th90;
        end;
        y in the_Edges_of G1 by A4,A11,GLIB_000:def 15;
        then y in EG2 by A14,XBOOLE_0:def 5;
        hence y in VG2 \/ EG2 by XBOOLE_0:def 3;
      end;
    end;
    then y in (the_Vertices_of G2) \/ EG2 by GLIB_000:50;
    hence y in (the_Vertices_of G2) \/ (the_Edges_of G2) by A2,GLIB_000:50;
  end;
  then rng W2 c= (the_Vertices_of G2) \/ (the_Edges_of G2) by TARSKI:def 3;
  then reconsider
  W2 as FinSequence of (the_Vertices_of G2)\/(the_Edges_of G2 ) by
FINSEQ_1:def 4;
  now
    reconsider lenW2 = len W2 as odd Element of NAT;
    thus len W2 is odd;
    W.first() in W.vertices() by Th89;
    then
A16: not W2.1 in {v} by A1,TARSKI:def 1;
    W.first() in the_Vertices_of G1;
    then W2.1 in VG2 by A16,XBOOLE_0:def 5;
    hence W2.1 in the_Vertices_of G2 by GLIB_000:50;
    let n be odd Element of NAT;
    assume
A17: n < len W2;
    then
A18: W.(n+1) Joins W.n, W.(n+2), G1 by Def3;
    then
A19: W.(n+1) in the_Edges_of G1 by GLIB_000:def 15;
    n+1 <= len W2 by A17,NAT_1:13;
    then n+1 < lenW2 by XXREAL_0:1;
    then n+1+1 <= len W2 by NAT_1:13;
    then
A20: W.(n+2) <> v by A1,Lm45;
    W.n <> v by A1,A17,Lm45;
    then not W.(n+1) in v.edgesInOut() by A18,A20,GLIB_000:68;
    then W.(n+1) in EG2 by A19,XBOOLE_0:def 5;
    then W.(n+1) in the_Edges_of G2 by A2,GLIB_000:50;
    hence W.(n+1) Joins W.n, W.(n+2), G2 by A18,GLIB_000:76;
  end;
  hence thesis by Def3;
end;

theorem
  for G1 being _Graph, W being Walk of G1, e being set, G2 being
  removeEdge of G1,e st not e in W.edges() holds W is Walk of G2
proof
  let G1 be _Graph, W be Walk of G1, e be set, G2 be removeEdge of G1,e;
A1: the_Edges_of G2 = (the_Edges_of G1) \ {e} by GLIB_000:56;
  assume
A2: not e in W.edges();
  now
    let x be set;
    assume
A3: x in W.edges();
    then not x in {e} by A2,TARSKI:def 1;
    hence x in the_Edges_of G2 by A1,A3,XBOOLE_0:def 5;
  end;
  then
A4: W.edges() c= the_Edges_of G2 by TARSKI:def 3;
  the_Vertices_of G2 = the_Vertices_of G1 by GLIB_000:56;
  then W.vertices() c= the_Vertices_of G2;
  hence thesis by A4,Th171;
end;

theorem Th174:
  for G1 being _Graph, G2 being Subgraph of G1, x,y,e being set
  st e Joins x,y,G2 holds G1.walkOf(x, e, y) = G2.walkOf(x, e, y)
proof
  let G1 be _Graph, G2 be Subgraph of G1, x, y, e be set;
  assume
A1: e Joins x,y,G2;
  then
A2: e Joins x,y,G1 by GLIB_000:75;
  G2.walkOf(x,e,y) = <*x,e,y*> by A1,Def5;
  hence thesis by A2,Def5;
end;

theorem
  for G1 being _Graph, G2 being Subgraph of G1, W1 being Walk of G1, W2
being Walk of G2, e being set st W1 = W2 & e in W2.last().edgesInOut() holds W1
  .addEdge(e) = W2.addEdge(e)
proof
  let G1 be _Graph, G2 be Subgraph of G1, W1 be Walk of G1, W2 be Walk of G2,
  e be set;
  assume that
A1: W1 = W2 and
A2: e in W2.last().edgesInOut();
  set W2B = G2.walkOf(W2.last(), e, W2.last().adj(e));
  set W1B = G1.walkOf(W1.last(), e, W1.last().adj(e));
A3: e Joins W2.last(),W2.last().adj(e),G2 by A2,GLIB_000:70;
  W1.last().adj(e) = W2.last().adj(e) by A1,A2,GLIB_000:83;
  then W1B = W2B by A1,A3,Th174;
  hence thesis by A1,Th36;
end;

theorem Th176:
  for G1 being _Graph, G2 being Subgraph of G1, W being Walk of
G2 holds (W is closed implies W is closed Walk of G1) & (W is directed implies
W is directed Walk of G1) & (W is trivial implies W is trivial Walk of G1) & (W
  is Trail-like implies W is Trail-like Walk of G1) & (W is Path-like implies W
  is Path-like Walk of G1) & (W is vertex-distinct implies W is vertex-distinct
  Walk of G1)
proof
  let G1 be _Graph, G2 be Subgraph of G1, W be Walk of G2;
  reconsider W9=W as Walk of G1 by Th168;
  hereby
    assume W is closed;
    then W.first() = W.last() by Def24;
    then W9.first() = W9.last();
    hence W is closed Walk of G1 by Def24;
  end;
  hereby
    assume
A1: W is directed;
    now
      let n be odd Element of NAT;
A2:   1 <= n+1 by NAT_1:12;
      assume
A3:   n < len W9;
      then n+1 <= len W9 by NAT_1:13;
      then n+1 in dom W9 by A2,FINSEQ_3:27;
      then
A4:   W9.(n+1) in the_Edges_of G2 by Th9;
      (the_Source_of G2).(W9.(n+1)) = W9.n by A1,A3,Def25;
      hence (the_Source_of G1).(W9.(n+1)) = W9.n by A4,GLIB_000:def 34;
    end;
    hence W is directed Walk of G1 by Def25;
  end;
  hereby
    assume W is trivial;
    then len W9 = 1 by Lm55;
    hence W is trivial Walk of G1 by Lm54;
  end;
A5: now
    assume W is Trail-like;
    then for m,n being even Element of NAT st 1 <= m & m < n & n <= len W
    holds W9.m <> W9.n by Lm57;
    hence W is Trail-like Walk of G1 by Lm57;
  end;
  hence W is Trail-like implies W is Trail-like Walk of G1;
  now
    assume
A6: W is Path-like;
    then for m,n being odd Element of NAT st m < n & n <= len W9 holds W9.m =
    W9 .n implies m=1 & n = len W9 by Def28;
    hence W is Path-like Walk of G1 by A5,A6,Def28;
  end;
  hence W is Path-like implies W is Path-like Walk of G1;
  hereby
    assume W is vertex-distinct;
    then for m,n being odd Element of NAT st m <= len W9 & n <= len W9 & W9.m
    = W9.n holds m = n by Def29;
    hence W is vertex-distinct Walk of G1 by Def29;
  end;
end;

theorem Th177:
  for G1 being _Graph, G2 being Subgraph of G1, W1 being Walk of
G1, W2 being Walk of G2 st W1 = W2 holds (W1 is closed iff W2 is closed) & (W1
  is directed iff W2 is directed) & (W1 is trivial iff W2 is trivial) & (W1 is
Trail-like iff W2 is Trail-like) & (W1 is Path-like iff W2 is Path-like) & (W1
  is vertex-distinct iff W2 is vertex-distinct)
proof
  let G1 be _Graph, G2 be Subgraph of G1, W1 be Walk of G1, W2 be Walk of G2;
  assume
A1: W1 = W2;
  then
A2: W1.last() = W2.last();
A3: W1 is closed iff W1.first() = W1.last() by Def24;
  W1.first() = W2.first() by A1;
  hence W1 is closed iff W2 is closed by A3,A2,Def24;
  now
    hereby
      assume
A4:   W1 is directed;
      now
        let n be odd Element of NAT;
A5:     1 <= n+1 by NAT_1:12;
        assume
A6:     n < len W2;
        then n+1 <= len W2 by NAT_1:13;
        then n+1 in dom W2 by A5,FINSEQ_3:27;
        then W2.(n+1) in the_Edges_of G2 by Th9;
        then
        (the_Source_of G2).(W2.(n+1)) = (the_Source_of G1).(W2.(n +1)) by
GLIB_000:def 34;
        hence (the_Source_of G2).(W2.(n+1)) = W2.n by A1,A4,A6,Def25;
      end;
      hence W2 is directed by Def25;
    end;
    assume W2 is directed;
    hence W1 is directed Walk of G1 by A1,Th176;
  end;
  hence W1 is directed iff W2 is directed;
  W1 is trivial iff len W2 = 1 by A1,Lm55;
  hence W1 is trivial iff W2 is trivial by Lm55;
  W1 is Trail-like iff for m,n being even Element of NAT st 1 <= m & m <
  n & n <= len W2 holds W2.m <> W2.n by A1,Lm57;
  hence
A7: W1 is Trail-like iff W2 is Trail-like by Lm57;
  W1 is Path-like iff (W1 is Trail-like & for m,n being odd Element of
NAT st m < n & n <= len W2 holds W2.m = W2.n implies m = 1 & n = len W2 ) by A1
,Def28;
  hence W1 is Path-like iff W2 is Path-like by A7,Def28;
  W1 is vertex-distinct iff for m,n being odd Element of NAT st m <= len
  W2 & n <= len W2 & W2.m = W2.n holds m = n by A1,Def29;
  hence thesis by Def29;
end;

theorem
  G1 == G2 & x is VertexSeq of G1 implies x is VertexSeq of G2
proof
  assume that
A1: G1 == G2 and
A2: x is VertexSeq of G1;
  reconsider x2 = x as FinSequence of the_Vertices_of G2 by A1,A2,
GLIB_000:def 36;
  now
    let n be Element of NAT;
    assume that
A3: 1 <= n and
A4: n < len x2;
    consider e being set such that
A5: e Joins x2.n, x2.(n+1), G1 by A2,A3,A4,Def1;
    e Joins x2.n, x2.(n+1), G2 by A1,A5,GLIB_000:91;
    hence ex e being set st e Joins x2.n, x2.(n+1), G2;
  end;
  hence thesis by Def1;
end;

theorem
  G1 == G2 & x is EdgeSeq of G1 implies x is EdgeSeq of G2
proof
  assume that
A1: G1 == G2 and
A2: x is EdgeSeq of G1;
  reconsider es = x as EdgeSeq of G1 by A2;
  reconsider es2 = es as FinSequence of the_Edges_of G2 by A1,GLIB_000:def 36;
  consider vs being FinSequence of the_Vertices_of G1 such that
A3: len vs = len es + 1 and
A4: for n being Element of NAT st 1 <= n & n <= len es holds es.n Joins
  vs.n,vs.(n+1),G1 by Def2;
  now
    reconsider vs as FinSequence of the_Vertices_of G2 by A1,GLIB_000:def 36;
    take vs;
    thus len vs = len es + 1 by A3;
    let n be Element of NAT;
    assume that
A5: 1 <= n and
A6: n <= len es2;
    es2.n Joins vs.n,vs.(n+1),G1 by A4,A5,A6;
    hence es2.n Joins vs.n,vs.(n+1),G2 by A1,GLIB_000:91;
  end;
  hence thesis by Def2;
end;

theorem
  G1 == G2 & x is Walk of G1 implies x is Walk of G2
proof
  assume that
A1: G1 == G2 and
A2: x is Walk of G1;
A3: the_Vertices_of G1 = the_Vertices_of G2 by A1,GLIB_000:def 36;
  then reconsider
  W = x as FinSequence of the_Vertices_of G2 \/ the_Edges_of G2 by A1,A2,
GLIB_000:def 36;
A4: now
    let n be odd Element of NAT;
    assume n < len W;
    then W.(n+1) Joins W.n, W.(n+2), G1 by A2,Def3;
    hence W.(n+1) Joins W.n, W.(n+2), G2 by A1,GLIB_000:91;
  end;
  W.1 in the_Vertices_of G2 by A2,A3,Def3;
  hence thesis by A2,A4,Def3;
end;

theorem
  G1 == G2 implies G1.walkOf(x,e,y) = G2.walkOf(x,e,y)
proof
  assume
A1: G1 == G2;
  now
    per cases;
    suppose
A2:   e Joins x,y,G1;
      then
A3:   e Joins x,y,G2 by A1,GLIB_000:91;
      thus G1.walkOf(x,e,y) = <*x,e,y*> by A2,Def5
        .= G2.walkOf(x,e,y) by A3,Def5;
    end;
    suppose
A4:   not e Joins x,y,G1;
      then
A5:   not e Joins x,y,G2 by A1,GLIB_000:91;
      thus G1.walkOf(x,e,y) = G1.walkOf(choose the_Vertices_of G1) by A4,Def5
        .= G2.walkOf(choose the_Vertices_of G2) by A1,GLIB_000:def 36
        .= G2.walkOf(x,e,y) by A5,Def5;
    end;
  end;
  hence thesis;
end;

theorem
  for W1 being Walk of G1, W2 being Walk of G2 st G1 == G2 & W1 = W2
holds (W1 is closed iff W2 is closed) & (W1 is directed iff W2 is directed) & (
W1 is trivial iff W2 is trivial) & (W1 is Trail-like iff W2 is Trail-like) & (
  W1 is Path-like iff W2 is Path-like) & (W1 is vertex-distinct iff W2 is
  vertex-distinct)
proof
  let W1 be Walk of G1, W2 be Walk of G2;
  assume that
A1: G1 == G2 and
A2: W1 = W2;
  G1 is Subgraph of G2 by A1,GLIB_000:90;
  hence thesis by A2,Th177;
end;
