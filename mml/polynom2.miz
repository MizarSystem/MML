:: Evaluation of Multivariate Polynomials
::  by Christoph Schwarzweller and Andrzej Trybulec
::
:: Received April 14, 2000
:: Copyright (c) 2000-2011 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies NUMBERS, XBOOLE_0, SUBSET_1, FINSEQ_1, RELAT_1, PARTFUN1, CARD_1,
      FUNCT_1, TARSKI, XXREAL_0, ARYTM_1, ARYTM_3, NAT_1, ORDERS_1, RELAT_2,
      GROUP_1, BINOP_1, ALGSTR_0, RLVECT_1, VECTSP_1, LATTICES, ZFMISC_1,
      FINSET_1, ALGSTR_1, STRUCT_0, SUPINF_2, CARD_3, FINSOP_1, ORDINAL4,
      PRE_POLY, FINSEQ_5, FUNCT_4, FUNCOP_1, ORDINAL1, WELLORD2, MESFUNC1,
      RFINSEQ, POLYNOM1, ALGSEQ_1, QC_LANG1, MSSUBFAM, QUOFIELD, POLYNOM2;
 notations TARSKI, XBOOLE_0, ZFMISC_1, SUBSET_1, CARD_1, NUMBERS, RELAT_1,
      FINSOP_1, RELAT_2, RELSET_1, FUNCT_1, FINSET_1, ORDINAL1, PARTFUN1,
      FUNCT_2, BINOP_1, FUNCT_4, FUNCT_7, REAL_1, NAT_1, ALGSTR_1, ORDERS_1,
      FINSEQ_1, STRUCT_0, ALGSTR_0, RLVECT_1, FUNCOP_1, VFUNCT_1, VECTSP_1,
      GROUP_1, GROUP_4, QUOFIELD, FINSEQ_5, GRCAT_1, RFINSEQ, YELLOW_1,
      GROUP_6, XXREAL_0, RECDEF_1, PRE_POLY, POLYNOM1;
 constructors XXREAL_0, REAL_1, FINSOP_1, RFINSEQ, BINARITH, FINSEQ_5, GROUP_4,
      GRCAT_1, GROUP_6, MONOID_0, TRIANG_1, YELLOW_1, QUOFIELD, POLYNOM1,
      RECDEF_1, ALGSTR_1, RELSET_1, FUNCT_7, FVSUM_1, VFUNCT_1;
 registrations XBOOLE_0, ORDINAL1, RELSET_1, FUNCOP_1, FINSET_1, XXREAL_0,
      XREAL_0, NAT_1, INT_1, FINSEQ_1, STRUCT_0, VECTSP_1, ALGSTR_1, MONOID_0,
      POLYNOM1, VALUED_0, CARD_1, SUBSET_1, PRE_POLY, RELAT_1, VFUNCT_1,
      FUNCT_2;
 requirements NUMERALS, BOOLE, SUBSET, REAL, ARITHM;
 definitions QUOFIELD, GROUP_1, BINOP_1, FUNCOP_1, ALGSTR_0;
 theorems TARSKI, FINSEQ_1, FUNCT_1, FUNCT_2, ORDINAL1, RELAT_1, ZFMISC_1,
      VECTSP_1, POLYNOM1, RELAT_2, WELLORD2, FUNCT_7, FUNCT_4, FUNCOP_1,
      ORDERS_1, NAT_1, FINSEQ_4, GRCAT_1, INT_1, FINSEQ_3, RLVECT_1, GROUP_4,
      PARTFUN2, CARD_1, RFINSEQ, FINSOP_1, FINSEQ_5, CARD_2, FINSEQ_2,
      ALGSTR_1, GROUP_1, XBOOLE_0, XBOOLE_1, PARTFUN1, XREAL_1, GROUP_6,
      XXREAL_0, VALUED_0, PRE_POLY;
 schemes FUNCT_2, NAT_1, RECDEF_1, INT_1;

begin :: Preliminaries

Lm1: for X being set, A being Subset of X, O being Order of X holds O
is_reflexive_in A & O is_antisymmetric_in A & O is_transitive_in A
proof
  let X be set, A be Subset of X, O be Order of X;
A1: field O = X by ORDERS_1:97;
  then O is_antisymmetric_in X by RELAT_2:def 12;
  then
A2: for x,y being set holds x in A & y in A & [x,y] in O & [y,x] in O
  implies x = y by RELAT_2:def 4;
  O is_transitive_in X by A1,RELAT_2:def 16;
  then
A3: for x,y,z being set holds x in A & y in A & z in A & [x,y] in O & [y,z]
  in O implies [x,z] in O by RELAT_2:def 8;
  O is_reflexive_in X by A1,RELAT_2:def 9;
  then for x being set holds x in A implies [x,x] in O by RELAT_2:def 1;
  hence thesis by A2,A3,RELAT_2:def 1,def 4,def 8;
end;

Lm2: for X being set, A being Subset of X, O being Order of X st O
is_connected_in X holds O is_connected_in A
proof
  let X be set, A be Subset of X, O be Order of X;
  assume O is_connected_in X;
  then
  for x,y being set holds x in A & y in A & x <> y implies [x,y] in O or [
  y,x] in O by RELAT_2:def 6;
  hence thesis by RELAT_2:def 6;
end;

Lm3: for X being set, S being Subset of X, R being Order of X st R is
being_linear-order holds R linearly_orders S
proof
  let X be set, S be Subset of X, R be Order of X;
A1: field R = X by ORDERS_1:97;
  then
A2: R is_reflexive_in X by RELAT_2:def 9;
  R is_transitive_in X by A1,RELAT_2:def 16;
  then
  for x,y,z being set holds x in S & y in S & z in S & [x,y] in R & [y,z]
  in R implies [x,z] in R by RELAT_2:def 8;
  then
A3: R is_transitive_in S by RELAT_2:def 8;
  R is_antisymmetric_in X by A1,RELAT_2:def 12;
  then for x,y being set holds x in S & y in S & [x,y] in R & [y,x] in R
  implies x = y by RELAT_2:def 4;
  then
A4: R is_antisymmetric_in S by RELAT_2:def 4;
  assume R is being_linear-order;
  then R is connected by ORDERS_1:def 5;
  then
A5: R is_connected_in field R by RELAT_2:def 14;
  for x,y being set holds x in S & y in S & x <> y implies [x,y] in R or
  [y,x] in R
  proof
    let x,y be set;
    assume that
A6: x in S and
A7: y in S and
A8: x <> y;
A9: field R = dom R \/ rng R by RELAT_1:def 6;
    [y,y] in R by A2,A7,RELAT_2:def 1;
    then y in dom R by RELAT_1:def 4;
    then
A10: y in field R by A9,XBOOLE_0:def 3;
    [x,x] in R by A2,A6,RELAT_2:def 1;
    then x in dom R by RELAT_1:def 4;
    then x in field R by A9,XBOOLE_0:def 3;
    hence thesis by A5,A8,A10,RELAT_2:def 6;
  end;
  then
A11: R is_connected_in S by RELAT_2:def 6;
  for x being set holds x in S implies [x,x] in R by A2,RELAT_2:def 1;
  then R is_reflexive_in S by RELAT_2:def 1;
  hence thesis by A4,A3,A11,ORDERS_1:def 8;
end;

canceled;

theorem Th2:
  for L being unital associative (non empty multMagma), a being
Element of L, n,m being Element of NAT holds power(L).(a,n+m) = power(L).(a,n)
  * power(L).(a,m)
proof
  let L be unital associative (non empty multMagma), a be Element of L, n,m be
  Element of NAT;
  defpred P[Element of NAT] means power(L).(a,n+$1) = power(L).(a,n) * power(L
  ).(a,$1);
A1: now
    let m be Element of NAT;
    assume
A2: P[m];
    power(L).(a,n+(m+1)) = power(L).(a,(n+m)+1)
      .= (power(L).(a,n) * power(L).(a,m)) * a by A2,GROUP_1:def 8
      .= power(L).(a,n) * (power(L).(a,m) * a) by GROUP_1:def 4
      .= power(L).(a,n) * power(L).(a,(m+1)) by GROUP_1:def 8;
    hence P[m+1];
  end;
  power(L).(a,n + 0) = power(L).(a,n) * 1_L by GROUP_1:def 5
    .= power(L).(a,n) * power(L).(a,0) by GROUP_1:def 8;
  then
A3: P[0];
  for m being Element of NAT holds P[m] from NAT_1:sch 1(A3,A1);
  hence thesis;
end;

registration
  cluster Abelian right_zeroed add-associative right_complementable
    well-unital distributive commutative associative non trivial (non empty
    doubleLoopStr);
  existence
  proof
    take F_Real;
    thus thesis;
  end;
end;


begin :: About Finite Sequences and the Functor SgmX ------------------------------

canceled;

theorem Th4:
  for p being FinSequence, k being Element of NAT st k in dom p for
  i being Element of NAT st 1 <= i & i <= k holds i in dom p
proof
  let p be FinSequence, k be Element of NAT;
  assume
A1: k in dom p;
  let i be Element of NAT;
  assume that
A2: 1 <= i and
A3: i <= k;
  consider l being Nat such that
A4: dom p = Seg l by FINSEQ_1:def 2;
  k <= l by A1,A4,FINSEQ_1:3;
  then i <= l by A3,XXREAL_0:2;
  hence thesis by A2,A4,FINSEQ_1:3;
end;

Lm4: for X being set, A being finite Subset of X, a being Element of X, R
being Order of X st R linearly_orders {a} \/ A holds R linearly_orders A
proof
  let X be set, A be finite Subset of X, a be Element of X, R be Order of X;
  for x being set holds x in A implies x in {a} \/ A by XBOOLE_0:def 3;
  then
A1: A c= {a} \/ A by TARSKI:def 3;
  assume R linearly_orders {a} \/ A;
  hence thesis by A1,ORDERS_1:134;
end;

theorem Th5:
  for L being left_zeroed right_zeroed (non empty addLoopStr), p
  being FinSequence of the carrier of L, i being Element of NAT st i in dom p &
  for i9 being Element of NAT st i9 in dom p & i9 <> i holds p/.i9 = 0.L holds
  Sum p = p/.i
proof
  let L be left_zeroed right_zeroed (non empty addLoopStr), p be FinSequence
  of the carrier of L, i be Element of NAT;
  assume that
A1: i in dom p and
A2: for i9 being Element of NAT st i9 in dom p & i9 <> i holds p/.i9 = 0.L;
  consider fp being Function of NAT,the carrier of L such that
A3: Sum p = fp.(len p) and
A4: fp.0 = 0.L and
A5: for j being Element of NAT, v being Element of L st j < len p & v =
  p.(j + 1) holds fp.(j + 1) = fp.j + v by RLVECT_1:def 15;
  defpred P[Element of NAT] means ($1 < i & fp.($1) = 0.L) or (i <= $1 & fp.(
  $1) = p/.i);
  consider l being Nat such that
A6: dom p = Seg l by FINSEQ_1:def 2;
  reconsider l as Element of NAT by ORDINAL1:def 13;
A7: len p = l by A6,FINSEQ_1:def 3;
  i in {z where z is Element of NAT : 1 <= z & z <= l} by A1,A6,FINSEQ_1:def 1;
  then
A8: ex i9 being Element of NAT st i9 = i & 1 <= i9 & i9 <= l;
A9: for j being Element of NAT st 0 <= j & j < len p holds P[j] implies P[j +1]
  proof
    let j be Element of NAT;
    assume that
    0 <= j and
A10: j < len p;
    assume
A11: P[j];
    per cases;
    suppose
A12:  j < i;
      now
        per cases;
        case
A13:      j + 1 = i;
          then p.(j+1) = p/.(j+1) by A1,PARTFUN1:def 8;
          then fp.(j+1) = 0.L + p/.(j+1) by A5,A10,A11,A12
            .= p/.(j+1) by ALGSTR_1:def 5;
          hence thesis by A13;
        end;
        case
A14:      j + 1 <> i;
A15:      j + 1 < i
          proof
            assume i <= j + 1;
            then i < j + 1 by A14,XXREAL_0:1;
            hence thesis by A12,NAT_1:13;
          end;
          j + 1 <= i by A12,NAT_1:13;
          then
A16:      j + 1 <= l by A8,XXREAL_0:2;
          0 + 1 <= j + 1 by XREAL_1:8;
          then
A17:      j + 1 in Seg l by A16,FINSEQ_1:3;
          then p.(j+1) = p/.(j+1) by A6,PARTFUN1:def 8;
          then fp.(j+1) = 0.L + p/.(j+1) by A5,A10,A11,A12
            .= p/.(j+1) by ALGSTR_1:def 5
            .= 0.L by A2,A6,A14,A17;
          hence thesis by A15;
        end;
      end;
      hence thesis;
    end;
    suppose
A18:  i <= j;
      j < l by A6,A10,FINSEQ_1:def 3;
      then
A19:  j + 1 <= l by NAT_1:13;
A20:  i < j + 1 by A18,NAT_1:13;
      0 + 1 <= j + 1 by XREAL_1:8;
      then
A21:  j + 1 in dom p by A6,A19,FINSEQ_1:3;
      then p.(j+1) = p/.(j+1) by PARTFUN1:def 8;
      then fp.(j+1) = p/.i + p/.(j+1) by A5,A10,A11,A18
        .= p/.i + 0.L by A2,A20,A21
        .= p/.i by RLVECT_1:def 7;
      hence thesis by A18,NAT_1:13;
    end;
  end;
A22: P[0] by A4,A8;
  for j being Element of NAT st 0 <= j & j <= len p holds P[j] from
  INT_1:sch 7(A22,A9);
  hence thesis by A3,A8,A7;
end;

theorem
  for L being add-associative right_zeroed right_complementable
distributive well-unital (non empty doubleLoopStr), p being FinSequence of the
  carrier of L st ex i being Element of NAT st i in dom p & p/.i = 0.L holds
  Product p = 0.L
proof
  let L be add-associative right_zeroed right_complementable distributive
  well-unital (non empty doubleLoopStr), p be FinSequence of the carrier of L;
  given i being Element of NAT such that
A1: i in dom p and
A2: p/.i = 0.L;
  defpred P[Element of NAT] means for p being FinSequence of the carrier of L
  st len p = $1 & ex i being Element of NAT st i in dom p & p/.i = 0.L holds
  Product p = 0.L;
A3: for j being Element of NAT holds P[j] implies P[j+1]
  proof
    let j be Element of NAT;
    assume
A4: P[j];
    for p being FinSequence of the carrier of L st len p = j+1 & ex i
    being Element of NAT st i in dom p & p/.i = 0.L holds Product p = 0.L
    proof
      let p be FinSequence of the carrier of L;
      assume that
A5:   len p = j+1 and
A6:   ex i being Element of NAT st i in dom p & p/.i = 0.L;
A7:   ex fp being Function of NAT,the carrier of L st fp.1 = p.1 &( for
i being Element of NAT st 0 <> i & i < len p holds fp.(i + 1) = (the multF of L
).(fp.i,p.(i+1)))& (the multF of L) "**" p = fp.(len p) by A5,FINSOP_1:2
,NAT_1:14;
A8:   len p >= 1 by A5,NAT_1:14;
      then
A9:   1 in dom p by FINSEQ_3:27;
A10:  dom p = Seg len p by FINSEQ_1:def 3;
      then
A11:  j+1 in dom p by A5,A8,FINSEQ_1:3;
      per cases;
      suppose
A12:    j = 0;
        then
A13:    dom p = {1} by A5,FINSEQ_1:4,def 3;
        Product p = p.1 by A5,A7,A12,GROUP_4:def 3
          .= p/.1 by A9,PARTFUN1:def 8;
        hence thesis by A6,A13,TARSKI:def 1;
      end;
      suppose
        j <> 0;
        then
A14:    1 <= j by NAT_1:14;
        reconsider p9 = p|(Seg j) as FinSequence of the carrier of L by
FINSEQ_1:23;
A15:    j <= j+1 by XREAL_1:31;
        then
A16:    dom p9 = Seg j by A5,FINSEQ_1:21;
        p = (p9)^<*p.(len p)*> by A5,FINSEQ_3:61;
        then
A17:    p = (p9)^<*p/.(len p)*> by A5,A11,PARTFUN1:def 8;
A18:    len p9 = j by A5,A15,FINSEQ_1:21;
        now
          per cases;
          case
            p/.(len p) = 0.L;
            hence Product p = Product(p9) * 0.L by A17,GROUP_4:9
              .= 0.L by VECTSP_1:36;
          end;
          case
A19:        p/.(len p) <> 0.L;
            consider i being Element of NAT such that
A20:        i in dom p and
A21:        p/.i = 0.L by A6;
            i <= len p by A10,A20,FINSEQ_1:3;
            then i < len p by A19,A21,XXREAL_0:1;
            then
A22:        i <= j by A5,NAT_1:13;
A23:        1 <= i by A10,A20,FINSEQ_1:3;
            then
A24:        i in dom p9 by A16,A22,FINSEQ_1:3;
A25:        j in dom p by A5,A10,A14,A15,FINSEQ_1:3;
            i in Seg j by A23,A22,FINSEQ_1:3;
            then (p|j).i = p.i by A25,RFINSEQ:19;
            then p9.i = p.i by FINSEQ_1:def 15;
            then p9/.i = p.i by A24,PARTFUN1:def 8;
            then
A26:        p9/.i = 0.L by A20,A21,PARTFUN1:def 8;
            thus Product p = Product(p9) * p/.(len p) by A17,GROUP_4:9
              .= 0.L * p/.(len p) by A4,A18,A24,A26
              .= 0.L by VECTSP_1:39;
          end;
        end;
        hence thesis;
      end;
    end;
    hence thesis;
  end;
A27: ex l being Element of NAT st l = len p;
A28: P[0]
  proof
    let p be FinSequence of L;
    assume len p = 0;
    then p = {};
    hence thesis;
  end;
  for j being Element of NAT holds P[j] from NAT_1:sch 1(A28,A3);
  hence thesis by A1,A2,A27;
end;

theorem Th7:
  for L being Abelian add-associative (non empty addLoopStr), a
being Element of L, p,q being FinSequence of the carrier of L st len p = len q
  & ex i being Element of NAT st i in dom p & q/.i = a + p/.i & for i9 being
  Element of NAT st i9 in dom p & i9 <> i holds q/.i9 = p/.i9 holds Sum q = a +
  Sum p
proof
  let L be Abelian add-associative (non empty addLoopStr), a be Element of L,
  p,q be FinSequence of the carrier of L;
  assume that
A1: len p = len q and
A2: ex i being Element of NAT st i in dom p & q/.i = a + p/.i & for i9
  being Element of NAT st i9 in dom p & i9 <> i holds q/.i9 = p/.i9;
  consider i being Element of NAT such that
A3: i in dom p and
A4: q/.i = a + p/.i and
A5: for i9 being Element of NAT st i9 in dom p & i9 <> i holds q/.i9 = p
  /.i9 by A2;
  consider fq being Function of NAT,the carrier of L such that
A6: Sum q = fq.(len q) and
A7: fq.0 = 0.L and
A8: for j being Element of NAT, v being Element of L st j < len q & v =
  q.(j + 1) holds fq.(j + 1) = fq.j + v by RLVECT_1:def 15;
  consider l being Nat such that
A9: dom p = Seg l by FINSEQ_1:def 2;
  i in {z where z is Element of NAT : 1 <= z & z <= l} by A3,A9,FINSEQ_1:def 1;
  then
A10: ex i9 being Element of NAT st i9 = i & 1 <= i9 & i9 <= l;
  consider l9 being Nat such that
A11: dom q = Seg l9 by FINSEQ_1:def 2;
  reconsider l,l9 as Element of NAT by ORDINAL1:def 13;
  consider fp being Function of NAT,the carrier of L such that
A12: Sum p = fp.(len p) and
A13: fp.0 = 0.L and
A14: for j being Element of NAT, v being Element of L st j < len p & v =
  p.(j + 1) holds fp.(j + 1) = fp.j + v by RLVECT_1:def 15;
A15: len p = l by A9,FINSEQ_1:def 3;
  defpred P[Element of NAT] means ($1 < i & fp.($1) = fq.($1)) or (i <= $1 &
  fq.($1) = a + fp.($1));
A16: l = len p by A9,FINSEQ_1:def 3
    .= l9 by A1,A11,FINSEQ_1:def 3;
A17: for j being Element of NAT st 0 <= j & j < len p holds P[j] implies P[j
  +1]
  proof
    let j be Element of NAT;
    assume that
    0 <= j and
A18: j < len p;
    assume
A19: P[j];
    per cases;
    suppose
A20:  j < i;
      now
        per cases;
        case
A21:      j + 1 = i;
          then
A22:      p.(j+1) = p/.(j+1) by A3,PARTFUN1:def 8;
          q.(j+1) = q/.(j+1) by A3,A9,A11,A16,A21,PARTFUN1:def 8;
          then fq.(j+1) = fq.j + (a + p/.(j+1)) by A1,A4,A8,A18,A21
            .= a + (fq.j + p/.(j+1)) by RLVECT_1:def 6
            .= a + fp.(j+1) by A14,A18,A19,A20,A22;
          hence thesis by A21;
        end;
        case
A23:      j + 1 <> i;
A24:      j + 1 < i
          proof
            assume i <= j + 1;
            then i < j + 1 by A23,XXREAL_0:1;
            hence thesis by A20,NAT_1:13;
          end;
          j + 1 <= i by A20,NAT_1:13;
          then
A25:      j + 1 <= l by A10,XXREAL_0:2;
          0 + 1 <= j + 1 by XREAL_1:8;
          then
A26:      j + 1 in Seg l by A25,FINSEQ_1:3;
          then
A27:      p.(j+1) = p/.(j+1) by A9,PARTFUN1:def 8;
          q.(j+1) = q/.(j+1) by A11,A16,A26,PARTFUN1:def 8;
          then fq.(j+1) = fq.j + q/.(j+1) by A1,A8,A18
            .= fp.(j+1) by A5,A14,A9,A18,A19,A20,A23,A26,A27;
          hence thesis by A24;
        end;
      end;
      hence thesis;
    end;
    suppose
A28:  i <= j;
      j < l by A9,A18,FINSEQ_1:def 3;
      then
A29:  j + 1 <= l by NAT_1:13;
      0 + 1 <= j + 1 by XREAL_1:8;
      then
A30:  j + 1 in dom p by A9,A29,FINSEQ_1:3;
      then
A31:  p.(j+1) = p/.(j+1) by PARTFUN1:def 8;
A32:  i < j + 1 by A28,NAT_1:13;
      q.(j+1) = q/.(j+1) by A9,A11,A16,A30,PARTFUN1:def 8;
      then fq.(j+1) = fq.j + q/.(j+1) by A1,A8,A18
        .= (a + fp.j) + p/.(j+1) by A5,A19,A28,A32,A30
        .= a + (fp.j + p/.(j+1)) by RLVECT_1:def 6
        .= a + fp.(j+1) by A14,A18,A31;
      hence thesis by A28,NAT_1:13;
    end;
  end;
A33: P[0] by A13,A7,A10;
  for j being Element of NAT st 0 <= j & j <= len p holds P[j] from
  INT_1:sch 7(A33,A17);
  hence thesis by A1,A12,A6,A10,A15;
end;

theorem Th8:
  for L being commutative associative (non empty doubleLoopStr), a
being Element of L, p,q being FinSequence of the carrier of L st len p = len q
  & ex i being Element of NAT st i in dom p & q/.i = a * p/.i & for i9 being
Element of NAT st i9 in dom p & i9 <> i holds q/.i9 = p/.i9 holds Product q = a
  * Product p
proof
  let L be commutative associative (non empty doubleLoopStr), a be Element of
  L, p,q be FinSequence of the carrier of L;
  assume that
A1: len p = len q and
A2: ex i being Element of NAT st i in dom p & q/.i = a * p/.i & for i9
  being Element of NAT st i9 in dom p & i9 <> i holds q/.i9 = p/.i9;
  consider i being Element of NAT such that
A3: i in dom p and
A4: q/.i = a * p/.i and
A5: for i9 being Element of NAT st i9 in dom p & i9 <> i holds q/.i9 = p
  /.i9 by A2;
A6: Product p = (the multF of L) "**" p by GROUP_4:def 3;
A7: Product q = (the multF of L) "**" q by GROUP_4:def 3;
  per cases;
  suppose
    len p = 0;
    then p = {};
    hence thesis by A3;
  end;
  suppose
A8: len p <> 0;
    then
A9: len p >= 1 by NAT_1:14;
    consider l9 being Nat such that
A10: dom q = Seg l9 by FINSEQ_1:def 2;
    consider fp being Function of NAT,the carrier of L such that
A11: fp.1 = p.1 and
A12: for i being Element of NAT st 0 <> i & i < len p holds fp.(i + 1)
    = (the multF of L).(fp.i,p.(i+1)) and
A13: Product p = fp.(len p) by A6,A8,FINSOP_1:2,NAT_1:14;
    consider fq being Function of NAT,the carrier of L such that
A14: fq.1 = q.1 and
A15: for i being Element of NAT st 0 <> i & i < len q holds fq.(i + 1)
    = (the multF of L).(fq.i,q.(i+1)) and
A16: Product q = fq.(len p) by A1,A7,A8,FINSOP_1:2,NAT_1:14;
    defpred P[Element of NAT] means ($1 < i & fp.($1) = fq.($1)) or (i <= $1 &
    fq.($1) = a * fp.($1));
    consider l being Nat such that
A17: dom p = Seg l by FINSEQ_1:def 2;
    i in {z where z is Element of NAT : 1 <= z & z <= l} by A3,A17,
FINSEQ_1:def 1;
    then
A18: ex i9 being Element of NAT st i9 = i & 1 <= i9 & i9 <= l;
    reconsider l,l9 as Element of NAT by ORDINAL1:def 13;
A19: len p = l by A17,FINSEQ_1:def 3;
A20: 1 <= l by A18,XXREAL_0:2;
    then
A21: 1 in dom p by A17,FINSEQ_1:3;
A22: l = len p by A17,FINSEQ_1:def 3
      .= l9 by A1,A10,FINSEQ_1:def 3;
A23: for j being Element of NAT st 1 <= j & j < len p holds P[j] implies P
    [j+1]
    proof
      let j be Element of NAT;
      assume that
A24:  1 <= j and
A25:  j < len p;
      assume
A26:  P[j];
      per cases;
      suppose
A27:    j < i;
        now
          per cases;
          case
A28:        j + 1 = i;
            then
A29:        p.(j+1) = p/.(j+1) by A3,PARTFUN1:def 8;
            q.(j+1) = q/.(j+1) by A3,A17,A10,A22,A28,PARTFUN1:def 8;
            then
            fq.(j+1) = fp.j * (a * p/.(j+1)) by A1,A4,A15,A24,A25,A26,A27,A28
              .= (fp.j * p/.(j+1)) * a by GROUP_1:def 4
              .= fp.(j+1) * a by A12,A24,A25,A29;
            hence thesis by A28;
          end;
          case
A30:        j + 1 <> i;
A31:        j + 1 < i
            proof
              assume i <= j + 1;
              then i < j + 1 by A30,XXREAL_0:1;
              hence thesis by A27,NAT_1:13;
            end;
            j + 1 <= i by A27,NAT_1:13;
            then
A32:        j + 1 <= l by A18,XXREAL_0:2;
            0 + 1 <= j + 1 by XREAL_1:8;
            then
A33:        j + 1 in Seg l by A32,FINSEQ_1:3;
            then
A34:        p.(j+1) = p/.(j+1) by A17,PARTFUN1:def 8;
            q.(j+1) = q/.(j+1) by A10,A22,A33,PARTFUN1:def 8;
            then fq.(j+1) = fq.j * q/.(j+1) by A1,A15,A24,A25
              .= (the multF of L).(fq.j,p.(j+1)) by A5,A17,A30,A33,A34
              .= fp.(j+1) by A12,A24,A25,A26,A27;
            hence thesis by A31;
          end;
        end;
        hence thesis;
      end;
      suppose
A35:    i <= j;
        j < l by A17,A25,FINSEQ_1:def 3;
        then
A36:    j + 1 <= l by NAT_1:13;
        0 + 1 <= j + 1 by XREAL_1:8;
        then
A37:    j + 1 in dom p by A17,A36,FINSEQ_1:3;
        then
A38:    p.(j+1) = p/.(j+1) by PARTFUN1:def 8;
A39:    i < j + 1 by A35,NAT_1:13;
        q.(j+1) = q/.(j+1) by A17,A10,A22,A37,PARTFUN1:def 8;
        then fq.(j+1) = fq.j * q/.(j+1) by A1,A15,A24,A25
          .= (a * fp.j) * p/.(j+1) by A5,A26,A35,A39,A37
          .= a * (fp.j * p/.(j+1)) by GROUP_1:def 4
          .= a * fp.(j+1) by A12,A24,A25,A38;
        hence thesis by A35,NAT_1:13;
      end;
    end;
A40: 1 in dom q by A10,A22,A20,FINSEQ_1:3;
    now
      per cases;
      case
A41:    1 < i;
        thus fp.1 = p/.1 by A11,A21,PARTFUN1:def 8
          .= q/.1 by A5,A21,A41
          .= fq.1 by A14,A40,PARTFUN1:def 8;
      end;
      case
        i <= 1;
        then i = 1 by A18,XXREAL_0:1;
        hence fq.1 = a * p/.1 by A3,A4,A14,A17,A10,A22,PARTFUN1:def 8
          .= a * fp.1 by A11,A21,PARTFUN1:def 8;
      end;
    end;
    then
A42: P[1];
    for j being Element of NAT st 1 <= j & j <= len p holds P[j] from
    INT_1:sch 7(A42,A23);
    hence thesis by A9,A13,A16,A18,A19;
  end;
end;

theorem Th9:
  for X being set, A being empty Subset of X, R being Order of X st
  R linearly_orders A holds SgmX(R,A) = {}
proof
  let X be set, A be empty Subset of X, R be Order of X;
  assume R linearly_orders A;
  then rng SgmX(R,A) = {} by PRE_POLY:def 2;
  hence thesis;
end;

theorem Th10:
  for X being set, A being finite Subset of X, R be Order of X st
R linearly_orders A for i,j being Element of NAT st i in dom(SgmX(R,A)) & j in
  dom(SgmX(R,A)) holds SgmX(R,A)/.i = SgmX(R,A)/.j implies i = j
proof
  let X be set, A be finite Subset of X, R be Order of X;
  assume
A1: R linearly_orders A;
  let i,j be Element of NAT such that
A2: i in dom(SgmX(R,A)) and
A3: j in dom(SgmX(R,A)) and
A4: SgmX(R,A)/.i = SgmX(R,A)/.j;
  assume i <> j;
  then i < j or j < i by XXREAL_0:1;
  hence thesis by A1,A2,A3,A4,PRE_POLY:def 2;
end;

Lm5: for D being set, p being FinSequence of D st dom p <> {} holds 1 in dom p
proof
  let D be set, p be FinSequence of D;
  assume dom p <> {};
   then p <> {};
  hence thesis by FINSEQ_5:6;
end;

theorem Th11:
  for X being set, A being finite Subset of X, a being Element of
  X st not a in A for B being finite Subset of X st B = {a} \/ A for R being
Order of X st R linearly_orders B for k being Element of NAT st k in dom(SgmX(R
,B)) & SgmX(R,B)/.k = a for i being Element of NAT st 1 <= i & i <= k - 1 holds
  SgmX(R,B)/.i = SgmX(R,A)/.i
proof
  let X be set, A be finite Subset of X, a be Element of X;
  assume
A1: not a in A;
  let B be finite Subset of X;
  assume
A2: B = {a} \/ A;
  let R be Order of X;
  assume
A3: R linearly_orders B;
  then
A4: R linearly_orders A by A2,Lm4;
  field R = X by ORDERS_1:97;
  then
A5: R is_antisymmetric_in X by RELAT_2:def 12;
  set sgb = SgmX(R,B), sga = SgmX(R,A);
  consider lensga being Nat such that
A6: dom sga = Seg lensga by FINSEQ_1:def 2;
  consider lensgb being Nat such that
A7: dom sgb = Seg lensgb by FINSEQ_1:def 2;
  reconsider lensga,lensgb as Element of NAT by ORDINAL1:def 13;
  lensgb = len sgb by A7,FINSEQ_1:def 3
    .= card B by A3,PRE_POLY:11
    .= card A + 1 by A1,A2,CARD_2:54
    .= len sga + 1 by A2,A3,Lm4,PRE_POLY:11
    .= lensga + 1 by A6,FINSEQ_1:def 3;
  then
A8: lensga <= lensgb by NAT_1:11;
  defpred P[Element of NAT] means sgb/.($1) = sga/.($1);
  let k be Element of NAT;
  assume that
A9: k in dom(SgmX(R,B)) and
A10: SgmX(R,B)/.k = a;
  k in Seg(len(sgb)) by A9,FINSEQ_1:def 3;
  then
A11: 1 <= k by FINSEQ_1:3;
  then 1 - 1 <= k - 1 by XREAL_1:11;
  then reconsider k9 = k - 1 as Element of NAT by INT_1:16;
A12: k9 + 1 = k + 0;
A13: for j being Element of NAT st 1 <= j & j < k9 holds (for j9 being
  Element of NAT st 1 <= j9 & j9 <= j holds P[j9]) implies P[j+1]
  proof
    let i9 be Element of NAT;
    assume that
A14: 1 <= i9 and
A15: i9 < k9;
A16: 1 <= i9 + 1 by A14,XREAL_1:31;
A17: i9 + 1 < k by A12,A15,XREAL_1:8;
    then
A18: i9 + 1 in dom sgb by A9,A16,Th4;
    sgb/.(i9+1) = sgb.(i9+1) by A9,A17,A16,Th4,PARTFUN1:def 8;
    then sgb/.(i9+1) in rng sgb by A18,FUNCT_1:def 5;
    then
A19: sgb/.(i9+1) in B by A3,PRE_POLY:def 2;
    sgb/.(i9+1) <> a by A3,A9,A10,A17,A18,PRE_POLY:def 2;
    then not sgb/.(i9+1) in {a} by TARSKI:def 1;
    then sgb/.(i9+1) in A by A2,A19,XBOOLE_0:def 3;
    then sgb/.(i9+1) in rng sga by A4,PRE_POLY:def 2;
    then consider l being set such that
A20: l in dom sga and
A21: sga.l = sgb/.(i9+1) by FUNCT_1:def 5;
    reconsider l as Element of NAT by A20;
A22: 1 <= l by A6,A20,FINSEQ_1:3;
    l <= lensga by A6,A20,FINSEQ_1:3;
    then l <= lensgb by A8,XXREAL_0:2;
    then
A23: l in dom sgb by A7,A22,FINSEQ_1:3;
    assume
A24: for j9 being Element of NAT st 1 <= j9 & j9 <= i9 holds P[j9];
    assume
A25: sgb/.(i9+1) <> sga/.(i9+1);
    then
A26: l <> i9 + 1 by A20,A21,PARTFUN1:def 8;
    per cases;
    suppose
      l < i9 + 1;
      then l <= i9 by NAT_1:13;
      then sgb/.l = sga/.l by A24,A22
        .= sgb/.(i9+1) by A20,A21,PARTFUN1:def 8;
      hence thesis by A3,A18,A26,A23,Th10;
    end;
    suppose
A27:  i9 + 1 <= l;
      then
A28:  i9 + 1 in dom sga by A16,A20,Th4;
      sga/.(i9+1) = sga.(i9+1) by A16,A20,A27,Th4,PARTFUN1:def 8;
      then sga/.(i9+1) in rng sga by A28,FUNCT_1:def 5;
      then sga/.(i9+1) in A by A4,PRE_POLY:def 2;
      then sga/.(i9+1) in B by A2,XBOOLE_0:def 3;
      then sga/.(i9+1) in rng sgb by A3,PRE_POLY:def 2;
      then consider l9 being set such that
A29:  l9 in dom sgb and
A30:  sgb.l9 = sga/.(i9+1) by FUNCT_1:def 5;
      reconsider l9 as Element of NAT by A29;
      i9 + 1 < l by A26,A27,XXREAL_0:1;
      then [sga/.(i9+1),sga/.l] in R by A4,A20,A28,PRE_POLY:def 2;
      then [sgb/.l9,sga/.l] in R by A29,A30,PARTFUN1:def 8;
      then
A31:  [sgb/.l9,sgb/.(i9+1)] in R by A20,A21,PARTFUN1:def 8;
      sgb/.l9 = sgb.l9 by A29,PARTFUN1:def 8;
      then sgb/.l9 in rng sgb by A29,FUNCT_1:def 5;
      then
A32:  sgb/.l9 in B by A3,PRE_POLY:def 2;
A33:  1 <= l9 by A7,A29,FINSEQ_1:3;
A34:  i9 + 1 < l9
      proof
        assume
A35:    l9 <= i9 + 1;
        now
          per cases by A35,XXREAL_0:1;
          case
            l9 = i9 + 1;
            hence thesis by A25,A29,A30,PARTFUN1:def 8;
          end;
          case
A36:        l9 < i9 + 1;
            then l9 <= i9 by NAT_1:13;
            then
A37:        sga/.l9 = sgb/.l9 by A24,A33
              .= sga/.(i9+1) by A29,A30,PARTFUN1:def 8;
            l9 in dom sga by A28,A33,A36,Th4;
            hence thesis by A2,A3,A28,A36,A37,Lm4,Th10;
          end;
        end;
        hence thesis;
      end;
      then [sgb/.(i9+1),sgb/.l9] in R by A3,A18,A29,PRE_POLY:def 2;
      then sgb/.l9 = sgb/.(i9+1) by A5,A31,A32,RELAT_2:def 4;
      hence thesis by A3,A18,A29,A34,Th10;
    end;
  end;
  let i be Element of NAT;
  assume that
A38: 1 <= i and
A39: i <= k - 1;
A40: 1 in dom sgb by A9,Lm5;
A41: P[1]
  proof
    sgb/.1 = sgb.1 by A9,Lm5,PARTFUN1:def 8;
    then sgb/.1 in rng sgb by A40,FUNCT_1:def 5;
    then
A42: sgb/.1 in B by A3,PRE_POLY:def 2;
    k <> 1 by A38,A39,XXREAL_0:2;
    then 1 < k by A11,XXREAL_0:1;
    then sgb/.1 <> a by A3,A9,A10,A40,PRE_POLY:def 2;
    then not sgb/.1 in {a} by TARSKI:def 1;
    then sgb/.1 in A by A2,A42,XBOOLE_0:def 3;
    then sgb/.1 in rng sga by A4,PRE_POLY:def 2;
    then consider l being set such that
A43: l in dom sga and
A44: sga.l = sgb/.1 by FUNCT_1:def 5;
A45: sga/.1 = sga.1 by A43,Lm5,PARTFUN1:def 8;
    assume
A46: sgb/.1 <> sga/.1;
    reconsider l as Element of NAT by A43;
A47: 1 in dom sga by A43,Lm5;
    1 <= l by A6,A43,FINSEQ_1:3;
    then 1 < l by A46,A44,A45,XXREAL_0:1;
    then [sga/.1,sga/.l] in R by A4,A43,A47,PRE_POLY:def 2;
    then
A48: [sga/.1,sgb/.1] in R by A43,A44,PARTFUN1:def 8;
    not sga/.1 in B
    proof
A49:  sgb/.1 = sgb.1 by A9,Lm5,PARTFUN1:def 8;
      assume sga/.1 in B;
      then sga/.1 in rng sgb by A3,PRE_POLY:def 2;
      then consider l9 being set such that
A50:  l9 in dom sgb and
A51:  sgb.l9 = sga/.1 by FUNCT_1:def 5;
      reconsider l9 as Element of NAT by A50;
      1 <= l9 by A7,A50,FINSEQ_1:3;
      then 1 < l9 by A46,A51,A49,XXREAL_0:1;
      then [sgb/.1,sgb/.l9] in R by A3,A40,A50,PRE_POLY:def 2;
      then [sgb/.1,sga/.1] in R by A50,A51,PARTFUN1:def 8;
      hence thesis by A5,A46,A42,A48,RELAT_2:def 4;
    end;
    then
A52: not(sga/.1) in A by A2,XBOOLE_0:def 3;
    sga/.1 in rng sga by A47,A45,FUNCT_1:def 5;
    hence thesis by A4,A52,PRE_POLY:def 2;
  end;
  for j being Element of NAT st 1 <= j & j <= k9 holds P[j] from INT_1:sch 8
  (A41,A13);
  hence thesis by A38,A39;
end;

theorem Th12:
  for X being set, A being finite Subset of X, a being Element of
  X st not a in A for B being finite Subset of X st B = {a} \/ A for R being
Order of X st R linearly_orders B for k being Element of NAT st k in dom(SgmX(R
,B)) & SgmX(R,B)/.k = a for i being Element of NAT st k <= i & i <= len(SgmX(R,
  A)) holds SgmX(R,B)/.(i+1) = SgmX(R,A)/.i
proof
  let X be set, A be finite Subset of X, a be Element of X;
  assume
A1: not a in A;
  let B be finite Subset of X;
  assume
A2: B = {a} \/ A;
  let R be Order of X;
  assume
A3: R linearly_orders B;
  then
A4: R linearly_orders A by A2,Lm4;
  field R = X by ORDERS_1:97;
  then
A5: R is_antisymmetric_in X by RELAT_2:def 12;
  set sgb = SgmX(R,B), sga = SgmX(R,A);
  consider lensga being Nat such that
A6: dom sga = Seg lensga by FINSEQ_1:def 2;
  defpred P[Element of NAT] means sgb/.($1 + 1) = sga/.($1);
  consider lensgb being Nat such that
A7: dom sgb = Seg lensgb by FINSEQ_1:def 2;
  let k be Element of NAT;
  assume that
A8: k in dom(SgmX(R,B)) and
A9: SgmX(R,B)/.k = a;
  k in Seg(len(sgb)) by A8,FINSEQ_1:def 3;
  then
A10: 1 <= k by FINSEQ_1:3;
  then 1 - 1 <= k - 1 by XREAL_1:11;
  then reconsider k9 = k - 1 as Element of NAT by INT_1:16;
  reconsider lensga,lensgb as Element of NAT by ORDINAL1:def 13;
A11: k9 + 1 = k + 0;
A12: lensgb = len sgb by A7,FINSEQ_1:def 3
    .= card B by A3,PRE_POLY:11
    .= card A + 1 by A1,A2,CARD_2:54
    .= len sga + 1 by A2,A3,Lm4,PRE_POLY:11
    .= lensga + 1 by A6,FINSEQ_1:def 3;
A13: for j being Element of NAT st k <= j & j < len sga holds (for j9 being
  Element of NAT st k <= j9 & j9 <= j holds P[j9]) implies P[j+1]
  proof
    let j be Element of NAT;
    assume that
A14: k <= j and
A15: j < len sga;
A16: (j + 1) + 1 = j + (1 + 1);
A17: 1 <= j + 2 by NAT_1:12;
    len sgb = card B by A3,PRE_POLY:11
      .= card A + 1 by A1,A2,CARD_2:54
      .= len sga + 1 by A2,A3,Lm4,PRE_POLY:11;
    then j + 1 < len sgb by A15,XREAL_1:8;
    then j + 2 <= len sgb by A16,NAT_1:13;
    then j + 2 <= lensgb by A7,FINSEQ_1:def 3;
    then
A18: j+2 in dom sgb by A7,A17,FINSEQ_1:3;
    now
      assume sgb/.(j+2) = a;
      then j + 2 = k by A3,A8,A9,A18,Th10;
      hence contradiction by A14,NAT_1:19;
    end;
    then
A19: not sgb/.(j+2) in {a} by TARSKI:def 1;
    sgb/.(j+2) = sgb.(j+2) by A18,PARTFUN1:def 8;
    then sgb/.(j+2) in rng sgb by A18,FUNCT_1:def 5;
    then sgb/.(j+2) in B by A3,PRE_POLY:def 2;
    then sgb/.(j+2) in A by A2,A19,XBOOLE_0:def 3;
    then sgb/.(j+2) in rng sga by A4,PRE_POLY:def 2;
    then consider l being set such that
A20: l in dom sga and
A21: sga.l = sgb/.(j+2) by FUNCT_1:def 5;
    reconsider l as Element of NAT by A20;
A22: sga/.l = sga.l by A20,PARTFUN1:def 8;
A23: 1 <= l by A6,A20,FINSEQ_1:3;
    j + 1 <= len sga by A15,NAT_1:13;
    then
A24: j + 1 <= lensga by A6,FINSEQ_1:def 3;
    1 <= j + 1 by NAT_1:12;
    then
A25: j + 1 in dom sga by A6,A24,FINSEQ_1:3;
    then
A26: sga/.(j+1) = sga.(j+1) by PARTFUN1:def 8;
    assume
A27: for j9 being Element of NAT st k <= j9 & j9 <= j holds P[j9];
    l <= lensga by A6,A20,FINSEQ_1:3;
    then
A28: l + 1 <= lensgb by A12,XREAL_1:8;
    1 <= l + 1 by NAT_1:12;
    then
A29: l + 1 in dom sgb by A7,A28,FINSEQ_1:3;
    l <= l + 1 by XREAL_1:31;
    then
A30: l in dom sgb by A23,A29,Th4;
    assume
A31: sgb/.((j+1)+1) <> sga/.(j+1);
    then
A32: l <> j + 1 by A20,A21,PARTFUN1:def 8;
    per cases;
    suppose
A33:  l <= j + 1;
      then l < j + 1 by A32,XXREAL_0:1;
      then
A34:  l <= j by NAT_1:13;
      now
        per cases;
        case
          k <= l;
          then sgb/.(l+1) = sga/.l by A27,A34;
          then j + 2 = l + 1 by A3,A18,A20,A21,A29,Th10,PARTFUN1:def 8;
          hence thesis by A31,A20,A21,PARTFUN1:def 8;
        end;
        case
          l < k;
          then l <= k9 by A11,NAT_1:13;
          then
A35:      sgb/.l = sga/.l by A1,A2,A3,A8,A9,A23,Th11;
          j + 1 < (j + 1) + 1 by XREAL_1:31;
          hence thesis by A3,A18,A20,A21,A30,A33,A35,Th10,PARTFUN1:def 8;
        end;
      end;
      hence thesis;
    end;
    suppose
A36:  l > j + 1;
A37:  for i9 being Element of NAT st 1 <= i9 & i9 <= j + 2 holds sga/.(j
      +1) <> sgb/.i9
      proof
        let i9 be Element of NAT;
        assume that
A38:    1 <= i9 and
A39:    i9 <= j + 2;
        assume
A40:    sga/.(j+1) = sgb/.i9;
        per cases;
        suppose
          i9 = j + 2;
          hence contradiction by A31,A40;
        end;
        suppose
A41:      i9 <> j + 2;
          then i9 < j + 2 by A39,XXREAL_0:1;
          then
A42:      i9 <= j + 1 by A16,NAT_1:13;
          then i9 <= lensga by A24,XXREAL_0:2;
          then
A43:      i9 in dom sga by A6,A38,FINSEQ_1:3;
          now
            per cases;
            case
A44:          i9 <= k;
              now
                per cases;
                case
                  i9 = k;
                  then sga.(j+1) = a by A9,A25,A40,PARTFUN1:def 8;
                  then a in rng sga by A25,FUNCT_1:def 5;
                  hence contradiction by A1,A4,PRE_POLY:def 2;
                end;
                case
                  i9 <> k;
                  then i9 < k by A44,XXREAL_0:1;
                  then i9 <= k9 by A11,NAT_1:13;
                  then sgb/.i9 = sga/.i9 by A1,A2,A3,A8,A9,A38,Th11;
                  then
A45:              i9 = j + 1 by A2,A3,A25,A40,A43,Lm4,Th10;
                  i9 <= j by A14,A44,XXREAL_0:2;
                  hence contradiction by A45,XREAL_1:31;
                end;
              end;
              hence contradiction;
            end;
            case
A46:          k < i9;
A47:          i9 - 1 <= (j + 1) - 1 by A42,XREAL_1:11;
A48:          i9 - 1 <= i9 by XREAL_1:148;
              1 <= i9 by A10,A46,XXREAL_0:2;
              then 1 - 1 <= i9 - 1 by XREAL_1:11;
              then
A49:          i9 - 1 is Element of NAT by INT_1:16;
A50:          (i9 - 1) + 1 = i9 + 0;
              then k <= i9 - 1 by A46,A49,NAT_1:13;
              then 1 <= i9 - 1 by A10,XXREAL_0:2;
              then
A51:          i9 - 1 in dom sga by A43,A49,A48,Th4;
              k <= i9 - 1 by A46,A49,A50,NAT_1:13;
              then sga/.(i9-1) = sga/.(j+1) by A27,A40,A49,A50,A47;
              hence contradiction by A2,A3,A16,A25,A41,A50,A51,Lm4,Th10;
            end;
          end;
          hence thesis;
        end;
      end;
      sga/.(j+1) in rng sga by A25,A26,FUNCT_1:def 5;
      then
A52:  sga/.(j+1) in A by A4,PRE_POLY:def 2;
      then sga/.(j+1) in B by A2,XBOOLE_0:def 3;
      then sga/.(j+1) in rng sgb by A3,PRE_POLY:def 2;
      then consider l9 being set such that
A53:  l9 in dom sgb and
A54:  sgb.l9 = sga/.(j+1) by FUNCT_1:def 5;
      reconsider l9 as Element of NAT by A53;
A55:  sgb/.l9 = sgb.l9 by A53,PARTFUN1:def 8;
A56:  1 <= j + 1 by NAT_1:12;
      j + 1 <= len sga by A15,NAT_1:13;
      then j + 1 in Seg(len sga) by A56,FINSEQ_1:3;
      then j + 1 in dom sga by FINSEQ_1:def 3;
      then
A57:  [sga/.(j+1),sga/.l] in R by A4,A20,A36,PRE_POLY:def 2;
      1 <= l9 by A7,A53,FINSEQ_1:3;
      then l9 > j + 2 by A37,A54,A55;
      then [sga/.l,sga/.(j+1)] in R by A3,A18,A21,A22,A53,A54,A55,
PRE_POLY:def 2;
      then sga/.l = sga/.(j+1) by A5,A57,A52,RELAT_2:def 4;
      hence thesis by A2,A3,A25,A20,A36,Lm4,Th10;
    end;
  end;
  let i be Element of NAT;
  assume that
A58: k <= i and
A59: i <= len(SgmX(R,A));
  k <= len sga by A58,A59,XXREAL_0:2;
  then
A60: k <= lensga by A6,FINSEQ_1:def 3;
  then
A61: k in dom sga by A10,A6,FINSEQ_1:3;
A62: lensga <= lensgb by A12,NAT_1:11;
A63: P[k]
  proof
A64: sga/.k = sga.k by A61,PARTFUN1:def 8;
    then sga/.k in rng sga by A61,FUNCT_1:def 5;
    then sga/.k in A by A4,PRE_POLY:def 2;
    then sga/.k in B by A2,XBOOLE_0:def 3;
    then sga/.k in rng sgb by A3,PRE_POLY:def 2;
    then consider l being set such that
A65: l in dom sgb and
A66: sgb.l = sga/.k by FUNCT_1:def 5;
    reconsider l as Element of NAT by A65;
A67: sgb/.l = sgb.l by A65,PARTFUN1:def 8;
A68: 1 <= l by A7,A65,FINSEQ_1:3;
    assume
A69: not(P[k]);
    then
A70: l <> k + 1 by A65,A66,PARTFUN1:def 8;
    per cases by XXREAL_0:1;
    suppose
      l = k;
      then sga.k = a by A8,A9,A64,A66,PARTFUN1:def 8;
      then a in rng sga by A61,FUNCT_1:def 5;
      hence thesis by A1,A4,PRE_POLY:def 2;
    end;
    suppose
A71:  l < k;
      then l <= lensga by A60,XXREAL_0:2;
      then
A72:  l in dom sga by A6,A68,FINSEQ_1:3;
      l <= k9 by A11,A71,NAT_1:13;
      then sga/.l = sga/.k by A1,A2,A3,A8,A9,A66,A68,A67,Th11;
      hence thesis by A2,A3,A61,A71,A72,Lm4,Th10;
    end;
    suppose
      k < l;
      then
A73:  k + 1 <= l by NAT_1:13;
A74:  1 <= k + 1 by NAT_1:12;
      then
A75:  k + 1 in dom sgb by A65,A73,Th4;
      now
        assume sgb/.(k+1) = a;
        then k + 1 = k by A3,A8,A9,A75,Th10;
        hence contradiction;
      end;
      then
A76:  not sgb/.(k+1) in {a} by TARSKI:def 1;
      k + 1 < l by A70,A73,XXREAL_0:1;
      then
A77:  [sgb/.(k+1),sgb/.l] in R by A3,A65,A75,PRE_POLY:def 2;
      sgb/.l in rng sgb by A65,A67,FUNCT_1:def 5;
      then
A78:  sgb/.l in B by A3,PRE_POLY:def 2;
      sgb/.(k+1) = sgb.(k+1) by A65,A73,A74,Th4,PARTFUN1:def 8;
      then sgb/.(k+1) in rng sgb by A75,FUNCT_1:def 5;
      then sgb/.(k+1) in B by A3,PRE_POLY:def 2;
      then sgb/.(k+1) in A by A2,A76,XBOOLE_0:def 3;
      then sgb/.(k+1) in rng sga by A4,PRE_POLY:def 2;
      then consider l9 being set such that
A79:  l9 in dom sga and
A80:  sga.l9 = sgb/.(k+1) by FUNCT_1:def 5;
      reconsider l9 as Element of NAT by A79;
A81:  sga/.l9 = sga.l9 by A79,PARTFUN1:def 8;
A82:  1 <= l9 by A6,A79,FINSEQ_1:3;
      l9 <= lensga by A6,A79,FINSEQ_1:3;
      then l9 <= lensgb by A62,XXREAL_0:2;
      then
A83:  l9 in dom sgb by A7,A82,FINSEQ_1:3;
      now
        assume
A84:    l9 < k;
        then l9 <= k9 by A11,NAT_1:13;
        then sgb/.l9 = sga/.l9 by A1,A2,A3,A8,A9,A82,Th11;
        then l9 = k + 1 by A3,A75,A79,A80,A83,Th10,PARTFUN1:def 8;
        hence contradiction by A84,XREAL_1:31;
      end;
      then l9 > k by A69,A80,A81,XXREAL_0:1;
      then [sgb/.l,sgb/.(k+1)] in R by A4,A61,A66,A67,A79,A80,A81,
PRE_POLY:def 2;
      then sgb/.l = sgb/.(k+1) by A5,A77,A78,RELAT_2:def 4;
      hence thesis by A69,A65,A66,PARTFUN1:def 8;
    end;
  end;
  for j being Element of NAT st k <= j & j <= len sga holds P[j] from
  INT_1:sch 8(A63,A13);
  hence thesis by A58,A59;
end;

theorem Th13:
  for X being non empty set, A being finite Subset of X, a being
Element of X st not a in A for B being finite Subset of X st B = {a} \/ A for R
being Order of X st R linearly_orders B for k being Element of NAT st k + 1 in
  dom(SgmX(R,B)) & SgmX(R,B)/.(k+1) = a holds SgmX(R,B) = Ins(SgmX(R,A),k,a)
proof
  let X be non empty set, A be finite Subset of X, a be Element of X;
  assume
A1: not a in A;
  let B be finite Subset of X;
  assume
A2: B = {a} \/ A;
  let R be Order of X;
  assume
A3: R linearly_orders B;
  let k be Element of NAT;
  assume that
A4: k+1 in dom(SgmX(R,B)) and
A5: SgmX(R,B)/.(k+1) = a;
  set sgb = SgmX(R,B), sga = Ins(SgmX(R,A),k,a);
A6: dom sgb = Seg(len sgb) by FINSEQ_1:def 3;
  then k + 1 <= len sgb by A4,FINSEQ_1:3;
  then
A7: k + 1 -1 <= len sgb -1 by XREAL_1:11;
A8: k + 1 - 1 = k + 0;
A9: len sgb = card B by A3,PRE_POLY:11
    .= card A + 1 by A1,A2,CARD_2:54
    .= len SgmX(R,A) + 1 by A2,A3,Lm4,PRE_POLY:11;
  then
A10: dom sgb = Seg(len sga) by A6,FINSEQ_5:72
    .= dom sga by FINSEQ_1:def 3;
A11: for i being Nat st 1 <= i & i <= len sgb holds sgb.i = sga.i
  proof
    let i be Nat;
    assume that
A12: 1 <= i and
A13: i <= len sgb;
A14: i in Seg(len sgb) by A12,A13,FINSEQ_1:3;
    then
A15: i in dom sgb by FINSEQ_1:def 3;
A16: i in dom sga by A10,A14,FINSEQ_1:def 3;
    per cases;
    suppose
A17:  i = k + 1;
      thus sgb.i = sgb/.i by A15,PARTFUN1:def 8
        .= sga/.(k+1) by A5,A9,A7,A17,FINSEQ_5:76
        .= sga.i by A16,A17,PARTFUN1:def 8;
    end;
    suppose
A18:  i <> k + 1;
      now
        per cases;
        case
          i < k + 1;
          then
A19:      i <= k by NAT_1:13;
          SgmX(R,A)|(Seg k) is FinSequence by FINSEQ_1:19;
          then dom(SgmX(R,A)|(Seg k)) = Seg k by A9,A7,FINSEQ_1:21;
          then i in dom(SgmX(R,A)|(Seg k)) by A12,A19,FINSEQ_1:3;
          then
A20:      i in dom(SgmX(R,A)|k) by FINSEQ_1:def 15;
          thus sgb.i = sgb/.i by A15,PARTFUN1:def 8
            .= SgmX(R,A)/.i by A1,A2,A3,A4,A5,A8,A12,A14,A19,Th11
            .= sga/.i by A20,FINSEQ_5:75
            .= sga.i by A16,PARTFUN1:def 8;
        end;
        case
A21:      k + 1 <= i;
          1 - 1 <= i - 1 by A12,XREAL_1:11;
          then reconsider i9 = i - 1 as Element of NAT by INT_1:16;
A22:      i9 + 1 = i + 0;
          k + 1 < i by A18,A21,XXREAL_0:1;
          then
A23:      k + 1 <= i9 by A22,NAT_1:13;
A24:      i9 <= len sgb - 1 by A13,XREAL_1:11;
          thus sgb.i = sgb/.(i9+1) by A15,PARTFUN1:def 8
            .= SgmX(R,A)/.i9 by A1,A2,A3,A4,A5,A9,A24,A23,Th12
            .= sga/.(i9+1) by A9,A24,A23,FINSEQ_5:77
            .= sga.i by A16,PARTFUN1:def 8;
        end;
      end;
      hence thesis;
    end;
  end;
  len sgb = len sga by A9,FINSEQ_5:72;
  hence thesis by A11,FINSEQ_1:18;
end;


begin :: Evaluation of Bags -------------------------------------------------------

theorem Th14:
  for X being set, b being bag of X st support b = {} holds b = EmptyBag X
proof
  let X be set, b be bag of X;
A1: X = dom (EmptyBag X) by PARTFUN1:def 4;
  assume
A2: support b = {};
A3: for u being set st u in X holds b.u = (EmptyBag X).u
  proof
    let u be set;
    assume u in X;
    b.u = 0 by A2,PRE_POLY:def 7;
    hence thesis by PRE_POLY:52;
  end;
  X = dom b by PARTFUN1:def 4;
  hence thesis by A1,A3,FUNCT_1:9;
end;

Lm6: for X being set, b being bag of X holds b is PartFunc of X,NAT
proof
  let X be set, b be bag of X;
  for u being set holds u in b implies u in [:X,NAT:]
  proof
    let u be set;
A1: rng b c= NAT by VALUED_0:def 6;
    assume
A2: u in b;
    then consider u1,u2 being set such that
A3: u = [u1,u2] by RELAT_1:def 1;
    u1 in dom b by A2,A3,RELAT_1:def 4;
    then
A4: u1 in X by PARTFUN1:def 4;
    u2 in rng b by A2,A3,RELAT_1:def 5;
    hence thesis by A3,A4,A1,ZFMISC_1:def 2;
  end;
  hence thesis by TARSKI:def 3;
end;

definition
  let X be set, b be bag of X;
  attr b is empty means
  :Def1:
  b = EmptyBag X;
end;

registration
  let X be non empty set;
  cluster non empty bag of X;
  existence
  proof
    set x =the  Element of X;
    set b = EmptyBag X +* (x,1);
    take b;
    dom (EmptyBag X) = X by PARTFUN1:def 4;
    then
A1: b.x = ((EmptyBag X)+*(x.-->1)).x by FUNCT_7:def 3;
    dom (x.-->1) = {x} by FUNCOP_1:19;
    then x in dom (x.-->1) by TARSKI:def 1;
    then b.x = (x.-->1).x by A1,FUNCT_4:14
      .= 1 by FUNCOP_1:87;
    then b.x <> (EmptyBag X).x by PRE_POLY:52;
    hence thesis by Def1;
  end;
end;

definition
  let X be set, b be bag of X;
  redefine func support b -> finite Subset of X;
  coherence
  proof
A1: support b c= dom b by PRE_POLY:37;
    for x being set holds x in support b implies x in X
    proof
      let x be set;
      assume x in support b;
      then x in dom b by A1;
      hence thesis by PARTFUN1:def 4;
    end;
    hence thesis by TARSKI:def 3;
  end;
end;

theorem Th15:
  for n being Ordinal, b being bag of n holds RelIncl n
  linearly_orders support b
proof
  let n be Ordinal, b be bag of n;
  set R = RelIncl n, s = support b;
  for x,y being set holds x in s & y in s & x <> y implies [x,y] in R or [
  y,x] in R
  proof
    let x,y be set;
    assume that
A1: x in s and
A2: y in s and
    x <> y;
    assume
A3: not [x,y] in R;
    reconsider x,y as Ordinal by A1,A2;
    y c= x by A1,A2,A3,WELLORD2:def 1;
    hence thesis by A1,A2,WELLORD2:def 1;
  end;
  then
A4: R is_connected_in s by RELAT_2:def 6;
A5: R is_antisymmetric_in s by Lm1;
A6: R is_transitive_in s by Lm1;
  R is_reflexive_in s by Lm1;
  hence thesis by A4,A5,A6,ORDERS_1:def 8;
end;

definition
  let X be set;
  let x be FinSequence of X, b be bag of X;
  redefine func b * x -> PartFunc of NAT,NAT;
  coherence
  proof
    reconsider b as PartFunc of X,NAT by Lm6;
    b * x c= [:NAT,NAT:];
    hence thesis;
  end;
end;

definition
  let n be Ordinal, b be bag of n, L be non trivial well-unital (non empty
  doubleLoopStr), x be Function of n, L;
  func eval(b,x) -> Element of L means
  :Def2:
  ex y being FinSequence of the
carrier of L st len y = len SgmX(RelIncl n, support b) & it = Product y & for i
  being Element of NAT st 1 <= i & i <= len y holds y/.i = power(L).((x * SgmX(
  RelIncl n, support b))/.i, (b * SgmX(RelIncl n, support b))/.i);
  existence
  proof
    set S = SgmX(RelIncl n, support b);
    set l = len S;
    defpred P[Element of NAT,Element of L] means $2 = power(L).((x * S)/.($1),
    (b * S)/.($1));
A1: for k being Element of NAT st k in Seg l ex x being Element of L st P[
    k,x];
    consider p being FinSequence of the carrier of L such that
A2: dom p = Seg l & for k being Element of NAT st k in Seg l holds P[k
    ,p/.k] from RECDEF_1:sch 17(A1);
    take Product p;
A3: len p = l by A2,FINSEQ_1:def 3;
    now
      let m be Element of NAT;
      assume that
A4:   1 <= m and
A5:   m <= len p;
      m in Seg l by A3,A4,A5,FINSEQ_1:3;
      hence p/.m = power(L).((x * SgmX(RelIncl n, support b))/.m, (b * SgmX(
      RelIncl n, support b))/.m) by A2;
    end;
    hence thesis by A3;
  end;
  uniqueness
  proof
    set S = SgmX(RelIncl n, support b);
    let a,c be Element of L;
    assume that
A6: ex y1 being FinSequence of the carrier of L st len y1 = (len SgmX(
RelIncl n, support b)) & a = Product y1 & for i being Element of NAT st 1 <= i
& i <= len y1 holds y1/.i = power(L).((x * SgmX(RelIncl n, support b))/.i, (b *
    SgmX(RelIncl n, support b))/.i) and
A7: ex y2 being FinSequence of the carrier of L st len y2 = (len SgmX(
RelIncl n, support b)) & c = Product y2 & for i being Element of NAT st 1 <= i
& i <= len y2 holds y2/.i = power(L).((x * SgmX(RelIncl n, support b))/.i, (b *
    SgmX(RelIncl n, support b))/.i);
    consider y1 being FinSequence of the carrier of L such that
A8: len y1 = (len SgmX(RelIncl n, support b)) and
A9: Product y1 = a and
A10: for i being Element of NAT st 1 <= i & i <= len y1 holds y1/.i =
power(L).((x * SgmX(RelIncl n, support b))/.i, (b * SgmX(RelIncl n, support b))
    /.i) by A6;
    consider y2 being FinSequence of the carrier of L such that
A11: len y2 = (len SgmX(RelIncl n, support b)) and
A12: Product y2 = c and
A13: for i being Element of NAT st 1 <= i & i <= len y2 holds y2/.i =
power(L).((x * SgmX(RelIncl n, support b))/.i, (b * SgmX(RelIncl n, support b))
    /.i) by A7;
    now
      let i be Nat;
      assume that
A14:  1 <= i and
A15:  i <= len y1;
      i in Seg (len y2) by A8,A11,A14,A15,FINSEQ_1:3;
      then
A16:  i in dom y2 by FINSEQ_1:def 3;
A17:  i in Seg (len y1) by A14,A15,FINSEQ_1:3;
      then i in dom y1 by FINSEQ_1:def 3;
      hence y1.i = y1/.i by PARTFUN1:def 8
        .= power(L).((x * S)/.i,(b * S)/.i) by A10,A14,A15,A17
        .= y2/.i by A8,A11,A13,A14,A15,A17
        .= y2.i by A16,PARTFUN1:def 8;
    end;
    hence thesis by A8,A9,A11,A12,FINSEQ_1:18;
  end;
end;

Lm7: for X being set holds support (EmptyBag X) = {}
proof
  let X be set;
  assume support (EmptyBag X) <> {};
  then reconsider S = support (EmptyBag X) as non empty set;
  set u =the  Element of S;
  (EmptyBag X).u <> 0 by PRE_POLY:def 7;
  hence thesis by PRE_POLY:52;
end;

theorem Th16:
  for n being Ordinal, L being non trivial well-unital (non empty
  doubleLoopStr), x being Function of n, L holds eval(EmptyBag n,x) = 1.L
proof
  let n be Ordinal, L be non trivial well-unital (non empty doubleLoopStr), x
  be Function of n, L;
  set b = EmptyBag n;
  reconsider s = support b as empty Subset of n by Lm7;
  consider y being FinSequence of the carrier of L such that
A1: len y = (len SgmX(RelIncl n, support b)) and
A2: eval(b,x) = Product y and
  for i being Element of NAT st 1 <= i & i <= len y holds y/.i = power (L)
.((x * SgmX(RelIncl n, support b))/.i, (b * SgmX(RelIncl n, support b))/.i) by
Def2;
  SgmX(RelIncl n, s) = {} by Th9,Th15;
  then y = <*>the carrier of L by A1;
  then eval(EmptyBag n,x) = 1_L by A2,GROUP_4:11;
  hence thesis;
end;

theorem Th17:
  for n being Ordinal, L being well-unital non trivial (non empty
  doubleLoopStr), u being set, b being bag of n st support b = {u} for x being
  Function of n, L holds eval(b,x) = power(L).(x.u,b.u)
proof
  let n be Ordinal, L be well-unital non trivial (non empty doubleLoopStr), u
  be set, b be bag of n;
  reconsider sb = support b as finite Subset of n;
  set sg = SgmX(RelIncl n, sb);
  assume
A1: support b = {u};
  then
A2: u in support b by TARSKI:def 1;
  let x be Function of n, L;
A3: rng x c= the carrier of L by RELAT_1:def 19;
A4: n = dom x by FUNCT_2:def 1;
  then x.u in rng x by A2,FUNCT_1:def 5;
  then reconsider xu = x.u as Element of L by A3;
A5: RelIncl n linearly_orders sb by Th15;
  then
A6: rng sg = {u} by A1,PRE_POLY:def 2;
  then
A7: u in rng sg by TARSKI:def 1;
  then
A8: 1 in dom sg by FINSEQ_3:33;
  then
A9: sg.1 in rng sg by FUNCT_1:def 5;
  then
A10: sg.1 = u by A6,TARSKI:def 1;
  then 1 in dom (x * sg) by A4,A8,A2,FUNCT_1:21;
  then
A11: (x * sg)/.1 = (x * sg).1 by PARTFUN1:def 8
    .= x.(sg.1) by A8,FUNCT_1:23
    .= x.u by A6,A9,TARSKI:def 1;
  dom b = n by PARTFUN1:def 4;
  then 1 in dom (b * sg) by A8,A10,A2,FUNCT_1:21;
  then
A12: (b * sg)/.1 = (b * sg).1 by PARTFUN1:def 8
    .= b.(sg.1) by A8,FUNCT_1:23
    .= b.u by A6,A9,TARSKI:def 1;
A13: power(L).(xu,b.u) = power(L).[xu,b.u];
A14: for v being set holds v in dom sg implies v in {1}
  proof
    let v be set;
    assume
A15: v in dom sg;
    assume
A16: not v in {1};
    reconsider v as Element of NAT by A15;
    sg/.v = sg.v by A15,PARTFUN1:def 8;
    then
A17: sg/.v in rng sg by A15,FUNCT_1:def 5;
A18: v <> 1 by A16,TARSKI:def 1;
A19: 1 < v
    proof
      consider k being Nat such that
A20:  dom sg = Seg k by FINSEQ_1:def 2;
      Seg k = {l where l is Element of NAT : 1 <= l & l <= k} by FINSEQ_1:def 1
;
      then
      ex m9 being Element of NAT st m9 = v & 1 <= m9 & m9 <= k by A15,A20;
      hence thesis by A18,XXREAL_0:1;
    end;
    sg/.1 = sg.1 by A7,A15,FINSEQ_3:33,PARTFUN1:def 8;
    then sg/.1 in rng sg by A8,FUNCT_1:def 5;
    then sg/.1 = u by A6,TARSKI:def 1
      .= sg/.v by A6,A17,TARSKI:def 1;
    hence thesis by A5,A8,A15,A19,PRE_POLY:def 2;
  end;
  consider y being FinSequence of the carrier of L such that
A21: len y = (len SgmX(RelIncl n, support b)) and
A22: eval(b,x) = Product y and
A23: for i being Element of NAT st 1 <= i & i <= len y holds y/.i = power
(L).((x * SgmX(RelIncl n, support b))/.i, (b * SgmX(RelIncl n, support b))/.i)
  by Def2;
  for v being set holds v in {1} implies v in dom sg by A8,TARSKI:def 1;
  then dom sg = Seg 1 by A14,FINSEQ_1:4,TARSKI:2;
  then
A24: len sg = 1 by FINSEQ_1:def 3;
  then y.1 = y/.1 by A21,FINSEQ_4:24
    .= power(L).((x * sg)/.1,(b * sg)/.1) by A21,A23,A24;
  then y = <* power(L).(x.u,b.u) *> by A21,A24,A12,A11,FINSEQ_1:57;
  hence thesis by A22,A13,GROUP_4:12;
end;

Lm8: for n being Ordinal, L being right_zeroed add-associative
right_complementable well-unital distributive non trivial commutative
associative (non empty doubleLoopStr), b1,b2 being bag of n, u being set st not
(u in support b1) & support b2 = support b1 \/ {u} & for u9 being set st u9 <>
u holds b2.u9 = b1.u9 for x being Function of n, L for a being Element of L st
a = (power(L)).(x.u,b2.u) holds eval(b2,x) = a * eval(b1,x)
proof
  let n be Ordinal, L be right_zeroed add-associative right_complementable
  well-unital distributive non trivial commutative associative (non empty
  doubleLoopStr), b1,b2 be bag of n, u be set;
  assume that
A1: not u in support b1 and
A2: support b2 = support b1 \/ {u} and
A3: for u9 being set st u9 <> u holds b2.u9 = b1.u9;
  u in {u} by TARSKI:def 1;
  then
A4: u in support b2 by A2,XBOOLE_0:def 3;
  set sb2 = SgmX(RelIncl n, support b2), sb1 = SgmX(RelIncl n, support b1);
  let x be Function of n, L;
A5: n = dom x by FUNCT_2:def 1;
  let a be Element of L;
  assume
A6: a = (power(L)).(x.u,b2.u);
  RelIncl n linearly_orders support b2 by Th15;
  then u in rng sb2 by A4,PRE_POLY:def 2;
  then consider k being Nat such that
A7: k in dom sb2 and
A8: sb2.k = u by FINSEQ_2:11;
A9: sb2/.k = u by A7,A8,PARTFUN1:def 8;
  reconsider u as Element of n by A4;
A10: dom sb2 = Seg(len sb2) by FINSEQ_1:def 3;
  then
A11: k <= len sb2 by A7,FINSEQ_1:3;
A12: 1 <= k by A7,A10,FINSEQ_1:3;
  then 1 - 1 <= k - 1 by XREAL_1:11;
  then reconsider k9 = k - 1 as Element of NAT by INT_1:16;
A13: k9 + 1 = k + 0;
A14: RelIncl n linearly_orders support b1 by Th15;
  per cases;
  suppose
A15: n = {};
A16: b2 in Bags n by PRE_POLY:def 12;
    u in {u} by TARSKI:def 1;
    then u in support b2 by A2,XBOOLE_0:def 3;
    then
A17: b2.u <> 0 by PRE_POLY:def 7;
    Bags n = {EmptyBag n} by A15,PRE_POLY:51,TARSKI:def 1;
    then b2 = EmptyBag n by A16,TARSKI:def 1;
    hence thesis by A17,PRE_POLY:52;
  end;
  suppose
    n <> {};
    then reconsider n9 = n as non empty Ordinal;
    reconsider x9 = x as Function of n9, L;
    reconsider b1, b2 as bag of n9;
    reconsider sb2, sb1 as FinSequence of n9;
    reconsider u as Element of n9;
    consider yb2 being FinSequence of the carrier of L such that
A18: len yb2 = len sb2 and
A19: eval(b2,x9) = Product yb2 and
A20: for i being Element of NAT st 1 <= i & i <= len yb2 holds yb2/.i
    = power(L).((x * sb2)/.i,(b2 * sb2)/.i) by Def2;
    consider yb1 being FinSequence of the carrier of L such that
A21: len yb1 = len sb1 and
A22: eval(b1,x9) = Product yb1 and
A23: for i being Element of NAT st 1 <= i & i <= len yb1 holds yb1/.i
    = power(L).((x * sb1)/.i,(b1 * sb1)/.i) by Def2;
    set ytmp = Ins(yb1,k9,a);
A24: len sb1 + 1 = (card(support b1) + 1) by Th15,PRE_POLY:11
      .= card(support b2) by A1,A2,CARD_2:54
      .= len sb2 by Th15,PRE_POLY:11;
    then
A25: len yb2 = len ytmp by A18,A21,FINSEQ_5:72;
A26: sb2 = Ins(sb1,k9,u) by A1,A2,A7,A9,A13,Th13,Th15;
A27: for i being Nat st 1 <= i & i <= len yb2 holds yb2.i = ytmp.i
    proof
      let i be Nat;
      assume that
A28:  1 <= i and
A29:  i <= len yb2;
A30:  i in Seg(len yb2) by A28,A29,FINSEQ_1:3;
      then
A31:  yb2/.i = power(L).((x * Ins(sb1,k9,u))/.i, (b2 * Ins(sb1,k9,u))/.i)
      by A26,A20,A28,A29;
A32:  i in dom yb2 by A30,FINSEQ_1:def 3;
      i in Seg(len ytmp) by A25,A28,A29,FINSEQ_1:3;
      then
A33:  i in dom ytmp by FINSEQ_1:def 3;
A34:  1 - 1 <= i - 1 by A28,XREAL_1:11;
      then
A35:  i - 1 is Element of NAT by INT_1:16;
      now
        per cases;
        case
A36:      i = k;
A37:      sb2.k in {u} by A8,TARSKI:def 1;
          then
A38:      k in dom(x * sb2) by A5,A7,A8,FUNCT_1:21;
          then
A39:      (x * sb2)/.k = (x * sb2).k by PARTFUN1:def 8
            .= x.u by A8,A38,FUNCT_1:22;
A40:      support b2 c= dom b2 by PRE_POLY:37;
          sb2.k in support b2 by A2,A37,XBOOLE_0:def 3;
          then
A41:      k in dom(b2 * sb2) by A7,A40,FUNCT_1:21;
          then (b2 * sb2)/.k = (b2 * sb2).k by PARTFUN1:def 8
            .= b2.u by A8,A41,FUNCT_1:22;
          then
A42:      yb2/.i = power(L).(x.u,b2.u) by A20,A28,A29,A30,A36,A39;
A43:      k9 <= len yb1 by A13,A18,A21,A24,A29,A36,XREAL_1:8;
          thus ytmp.i = ytmp/.i by A33,PARTFUN1:def 8
            .= yb2/.i by A6,A13,A36,A43,A42,FINSEQ_5:76
            .= yb2.i by A32,PARTFUN1:def 8;
        end;
        case
A44:      i <> k;
          len(Ins(sb1,k9,u)) = len sb1 + 1 by FINSEQ_5:72;
          then
A45:      dom(Ins(sb1,k9,u)) = Seg(len(sb1)+1) by FINSEQ_1:def 3;
          now
            per cases by A44,XXREAL_0:1;
            case
A46:          i < k;
              then
A47:          i <= k9 by A13,NAT_1:13;
              then
A48:          i in Seg k9 by A28,FINSEQ_1:3;
A49:          yb1|(Seg k9) is FinSequence by FINSEQ_1:19;
              k9 <= len yb1 by A11,A13,A21,A24,XREAL_1:8;
              then i in dom(yb1|(Seg k9)) by A48,A49,FINSEQ_1:21;
              then
A50:          i in dom(yb1|k9) by FINSEQ_1:def 15;
A51:          sb1|(Seg k9) is FinSequence by FINSEQ_1:19;
A52:          rng sb1 c= n by FINSEQ_1:def 4;
A53:          i < len yb2 by A11,A18,A46,XXREAL_0:2;
              then
A54:          i <= len yb1 by A18,A21,A24,NAT_1:13;
              i <= len sb1 by A18,A24,A53,NAT_1:13;
              then i in Seg(len sb1) by A28,FINSEQ_1:3;
              then
A55:          i in dom sb1 by FINSEQ_1:def 3;
              then
A56:          sb1.i in rng sb1 by FUNCT_1:def 5;
              then
A57:          i in dom(x * sb1) by A5,A55,A52,FUNCT_1:21;
A58:          now
                assume sb1/.i = u;
                then sb1.i = u by A55,PARTFUN1:def 8;
                then u in rng sb1 by A55,FUNCT_1:def 5;
                hence contradiction by A1,A14,PRE_POLY:def 2;
              end;
A59:          k - 1 <= (len sb1 + 1) - 1 by A11,A24,XREAL_1:11;
A60:          rng Ins(sb1,k9,u) c= n by FINSEQ_1:def 4;
              sb1.i in n by A56,A52;
              then sb1.i in dom b1 by PARTFUN1:def 4;
              then
A61:          i in dom(b1 * sb1) by A55,FUNCT_1:21;
              i in Seg k9 by A28,A47,FINSEQ_1:3;
              then i in dom(sb1|(Seg k9)) by A59,A51,FINSEQ_1:21;
              then
A62:          i in dom(sb1|k9) by FINSEQ_1:def 15;
              i <= len sb1 + 1 by A11,A24,A46,XXREAL_0:2;
              then
A63:          i in dom(Ins(sb1,k9,u)) by A28,A45,FINSEQ_1:3;
              then
A64:          Ins(sb1,k9,u).i in rng Ins(sb1,k9,u) by FUNCT_1:def 5;
              then
A65:          i in dom(x * Ins(sb1,k9,u)) by A5,A63,A60,FUNCT_1:21;
              then
A66:          (x * Ins(sb1,k9,u))/.i = (x * Ins(sb1,k9,u)).i by PARTFUN1:def 8
                .= x.(Ins(sb1,k9,u).i) by A65,FUNCT_1:22
                .= x.(Ins(sb1,k9,u)/.i) by A63,PARTFUN1:def 8
                .= x.(sb1/.i) by A62,FINSEQ_5:75
                .= x.(sb1.i) by A55,PARTFUN1:def 8
                .= (x * sb1).i by A57,FUNCT_1:22
                .= (x * sb1)/.i by A57,PARTFUN1:def 8;
              dom b2 = n by PARTFUN1:def 4;
              then
A67:          i in dom(b2 * Ins(sb1,k9,u)) by A63,A64,A60,FUNCT_1:21;
              then (b2 * Ins(sb1,k9,u))/.i = (b2 * Ins(sb1,k9,u)).i by
PARTFUN1:def 8
                .= b2.(Ins(sb1,k9,u).i) by A67,FUNCT_1:22
                .= b2.(Ins(sb1,k9,u)/.i) by A63,PARTFUN1:def 8
                .= b2.(sb1/.i) by A62,FINSEQ_5:75
                .= b1.(sb1/.i) by A3,A58
                .= b1.(sb1.i) by A55,PARTFUN1:def 8
                .= (b1 * sb1).i by A61,FUNCT_1:22
                .= (b1 * sb1)/.i by A61,PARTFUN1:def 8;
              then
A68:          yb2/.i = yb1/.i by A23,A28,A30,A31,A54,A66
                .= ytmp/.i by A50,FINSEQ_5:75;
              thus yb2.i = yb2/.i by A32,PARTFUN1:def 8
                .= ytmp.i by A33,A68,PARTFUN1:def 8;
            end;
            case
A69:          i > k;
              reconsider i1 = i - 1 as Element of NAT by A34,INT_1:16;
A70:          (i - 1) + 1 = i + 0;
A71:          rng sb1 c= n by FINSEQ_1:def 4;
A72:          i - 1 <= len sb2 - 1 by A18,A29,XREAL_1:11;
              1 < i by A12,A69,XXREAL_0:2;
              then
A73:          1 <= (i - 1) by A35,A70,NAT_1:13;
              then i1 in Seg(len sb1) by A24,A72,FINSEQ_1:3;
              then
A74:          i1 in dom sb1 by FINSEQ_1:def 3;
              then
A75:          sb1.i1 in rng sb1 by FUNCT_1:def 5;
              then
A76:          i1 in dom(x * sb1) by A5,A74,A71,FUNCT_1:21;
              dom b1 = n by PARTFUN1:def 4;
              then
A77:          i1 in dom(b1 * sb1) by A74,A75,A71,FUNCT_1:21;
A78:          now
                assume sb1/.i1 = u;
                then sb1.i1 = u by A74,PARTFUN1:def 8;
                then u in rng sb1 by A74,FUNCT_1:def 5;
                hence contradiction by A1,A14,PRE_POLY:def 2;
              end;
A79:          i = i1 + 1;
A80:          rng Ins(sb1,k9,u) c= n by FINSEQ_1:def 4;
A81:          i1 + 1 = i + 0;
              then
A82:          k9 + 1 <= i1 by A69,NAT_1:13;
A83:          i in dom(Ins(sb1,k9,u)) by A18,A24,A28,A29,A45,FINSEQ_1:3;
              then
A84:          Ins(sb1,k9,u).i in rng Ins(sb1,k9,u) by FUNCT_1:def 5;
              then
A85:          i in dom(x * Ins(sb1,k9,u)) by A5,A83,A80,FUNCT_1:21;
              then
A86:          (x * Ins(sb1,k9,u))/.i = (x * Ins(sb1,k9,u)).i by PARTFUN1:def 8
                .= x.(Ins(sb1,k9,u).i) by A85,FUNCT_1:22
                .= x.(Ins(sb1,k9,u)/.i) by A83,PARTFUN1:def 8
                .= x.(sb1/.i1) by A24,A72,A81,A82,FINSEQ_5:77
                .= x.(sb1.i1) by A74,PARTFUN1:def 8
                .= (x * sb1).i1 by A76,FUNCT_1:22
                .= (x * sb1)/.i1 by A76,PARTFUN1:def 8;
              dom b2 = n by PARTFUN1:def 4;
              then
A87:          i in dom(b2 * Ins(sb1,k9,u)) by A83,A84,A80,FUNCT_1:21;
              then (b2 * Ins(sb1,k9,u))/.i = (b2 * Ins(sb1,k9,u)).i by
PARTFUN1:def 8
                .= b2.(Ins(sb1,k9,u).i) by A87,FUNCT_1:22
                .= b2.(Ins(sb1,k9,u)/.i) by A83,PARTFUN1:def 8
                .= b2.(sb1/.i1) by A24,A72,A81,A82,FINSEQ_5:77
                .= b1.(sb1/.i1) by A3,A78
                .= b1.(sb1.i1) by A74,PARTFUN1:def 8
                .= (b1 * sb1).i1 by A77,FUNCT_1:22
                .= (b1 * sb1)/.i1 by A77,PARTFUN1:def 8;
              then
A88:          yb2/.i = yb1/.i1 by A21,A23,A24,A31,A73,A72,A86
                .= ytmp/.i by A21,A24,A72,A79,A82,FINSEQ_5:77;
              thus yb2.i = yb2/.i by A32,PARTFUN1:def 8
                .= ytmp.i by A33,A88,PARTFUN1:def 8;
            end;
          end;
          hence thesis;
        end;
      end;
      hence thesis;
    end;
    Product((yb1|k9)^<*a*>^(yb1/^k9)) = Product((yb1|k9)^<*a*>) * Product
    (yb1/^k9) by GROUP_4:8
      .= (Product(yb1|k9) * Product(<*a*>)) * Product(yb1/^k9) by GROUP_4:8
      .= (Product(yb1|k9) * Product(yb1/^k9)) * Product(<*a*>) by GROUP_1:def 4
      .= Product((yb1|k9)^(yb1/^k9)) * Product(<*a*>) by GROUP_4:8
      .= Product(yb1) * Product(<*a*>) by RFINSEQ:21
      .= eval(b1,x9) * a by A22,GROUP_4:12;
    then Product ytmp = eval(b1,x9) * a by FINSEQ_5:def 4;
    hence thesis by A19,A25,A27,FINSEQ_1:18;
  end;
end;

Lm9: for n being Ordinal, L being right_zeroed add-associative
right_complementable Abelian well-unital distributive non trivial commutative
associative (non empty doubleLoopStr), b1 being bag of n st (ex u being set st
support b1 = {u}) for b2 being bag of n, x being Function of n, L holds eval(b1
+b2,x) = eval(b1,x) * eval(b2,x)
proof
  let n be Ordinal, L be right_zeroed add-associative right_complementable
well-unital distributive Abelian non trivial commutative associative (non empty
  doubleLoopStr), b1 be bag of n;
  assume ex u being set st support b1 = {u};
  then consider u being set such that
A1: support b1 = {u};
  let b2 be bag of n, x be Function of n, L;
A2: support(b1+b2) = support b2 \/ {u} by A1,PRE_POLY:38;
A3: for u9 being set st u9 <> u holds (b1+b2).u9 = b2.u9
  proof
    let u9 be set;
    assume u9 <> u;
    then
A4: not u9 in support b1 by A1,TARSKI:def 1;
    thus (b1+b2).u9 = b1.u9 + b2.u9 by PRE_POLY:def 5
      .= 0 + b2.u9 by A4,PRE_POLY:def 7
      .= b2.u9;
  end;
  set sb2 = SgmX(RelIncl n, support b2), sb1b2 = SgmX(RelIncl n, support (b1+
  b2));
A5: n c= dom x by FUNCT_2:def 1;
A6: RelIncl n linearly_orders support b2 by Th15;
  consider yb1b2 being FinSequence of the carrier of L such that
A7: len yb1b2 = len sb1b2 and
A8: eval(b1+b2,x) = Product yb1b2 and
A9: for i being Element of NAT st 1 <= i & i <= len yb1b2 holds yb1b2/.i
  = power(L).((x * sb1b2)/.i,((b1+b2) * sb1b2)/.i) by Def2;
  consider yb2 being FinSequence of the carrier of L such that
A10: len yb2 = len sb2 and
A11: eval(b2,x) = Product yb2 and
A12: for i being Element of NAT st 1 <= i & i <= len yb2 holds yb2/.i =
  power(L).((x * sb2)/.i,(b2 * sb2)/.i) by Def2;
  per cases;
  suppose
A13: u in support b2;
    consider sb2k being Nat such that
A14: dom sb2 = Seg sb2k by FINSEQ_1:def 2;
A15: for v being set holds v in support b2 implies v in support(b1+b2)
    proof
      let v be set;
      assume
A16:  v in support b2;
      now
        per cases;
        case
          u = v;
          then v in {u} by TARSKI:def 1;
          hence thesis by A2,XBOOLE_0:def 3;
        end;
        case
          u <> v;
          then (b1+b2).v = b2.v by A3;
          then (b1+b2).v <> 0 by A16,PRE_POLY:def 7;
          hence thesis by PRE_POLY:def 7;
        end;
      end;
      hence thesis;
    end;
A17: for v being set holds v in support(b1+b2) implies v in support b2
    proof
      let v be set;
      assume
A18:  v in support(b1+b2);
      now
        per cases by A2,A18,XBOOLE_0:def 3;
        case
          v in {u};
          hence thesis by A13,TARSKI:def 1;
        end;
        case
          v in support b2;
          hence thesis;
        end;
      end;
      hence thesis;
    end;
    then
A19: len yb1b2 = len yb2 by A7,A10,A15,TARSKI:2;
A20: support(b1+b2) = support b2 by A17,A15,TARSKI:2;
    u in rng sb2 by A6,A13,PRE_POLY:def 2;
    then consider k being Nat such that
A21: k in dom sb2 and
A22: sb2.k = u by FINSEQ_2:11;
    reconsider k as Element of NAT by ORDINAL1:def 13;
A23: 1 <= k by A21,A14,FINSEQ_1:3;
A24: support b2 c= dom b2 by PRE_POLY:37;
    then
A25: k in dom(b2 * sb2) by A13,A21,A22,FUNCT_1:21;
    then
A26: (b2 * sb2)/.k = (b2 * sb2).k by PARTFUN1:def 8
      .= b2.u by A22,A25,FUNCT_1:22;
A27: rng x c= the carrier of L by RELAT_1:def 19;
    consider sb1b2k being Nat such that
A28: dom sb1b2 = Seg sb1b2k by FINSEQ_1:def 2;
    support(b1+b2) c= dom(b1+b2) by PRE_POLY:37;
    then
A29: k in dom((b1+b2) * sb2) by A13,A20,A21,A22,FUNCT_1:21;
    then
A30: ((b1+b2) * sb2)/.k = ((b1+b2) * sb2).k by PARTFUN1:def 8
      .= (b1+b2).u by A22,A29,FUNCT_1:22;
    consider i being Nat such that
A31: dom yb2 = Seg i by FINSEQ_1:def 2;
    reconsider sb2k,sb1b2k as Element of NAT by ORDINAL1:def 13;
A32: k <= sb2k by A21,A14,FINSEQ_1:3;
    i in NAT by ORDINAL1:def 13;
    then
A33: len yb2 = i by A31,FINSEQ_1:def 3;
A34: sb2k = len yb2 by A10,A14,FINSEQ_1:def 3;
    then
A35: k in dom yb2 by A21,A14,FINSEQ_1:def 3;
A36: sb2k = len sb2 by A14,FINSEQ_1:def 3
      .= len sb1b2 by A17,A15,TARSKI:2
      .= sb1b2k by A28,FINSEQ_1:def 3;
    then len yb1b2 = sb2k by A7,A28,FINSEQ_1:def 3;
    then
A37: yb1b2/.k = power(L).((x * sb2)/.k,((b1+b2) * sb2)/.k) by A9,A20,A23,A32
      .= power(L).((x * sb2)/.k,b1.u + b2.u) by A30,PRE_POLY:def 5
      .= power(L).((x * sb2)/.k,b1.u) * power(L).((x * sb2)/.k,(b2 * sb2)/.k
    ) by A26,Th2
      .= power(L).((x * sb2)/.k,b1.u) * yb2/.k by A12,A23,A32,A34;
A38: dom(b1+b2) = n by PARTFUN1:def 4;
A39: for i9 being Element of NAT st i9 in dom yb2 & i9 <> k holds yb1b2/.
    i9 = yb2/.i9
    proof
      rng(sb1b2) c= dom b2 by A6,A20,A24,PRE_POLY:def 2;
      then
A40:  rng(sb1b2) c= n by PARTFUN1:def 4;
A41:  rng(sb2) c= dom b2 by A6,A24,PRE_POLY:def 2;
      let i9 be Element of NAT;
      assume that
A42:  i9 in dom yb2 and
A43:  i9 <> k;
A44:  1 <= i9 by A31,A42,FINSEQ_1:3;
A45:  i9 in dom sb2 by A10,A31,A33,A42,FINSEQ_1:def 3;
      then sb2.i9 in rng(sb2) by FUNCT_1:def 5;
      then
A46:  i9 in dom(b2 * sb2) by A45,A41,FUNCT_1:21;
      then
A47:  (b2 * sb2)/.i9 = (b2 * sb2).i9 by PARTFUN1:def 8
        .= b2.(sb2.i9) by A46,FUNCT_1:22
        .= b2.(sb2/.i9) by A45,PARTFUN1:def 8;
A48:  i9 <= len yb2 by A31,A33,A42,FINSEQ_1:3;
A49:  i9 in Seg sb1b2k by A36,A34,A42,FINSEQ_1:def 3;
A50:  sb1b2/.i9 <> u
      proof
        assume sb1b2/.i9 = u;
        then
A51:    sb1b2.i9 = u by A28,A49,PARTFUN1:def 8;
A52:    sb1b2 is one-to-one by Th15,PRE_POLY:10;
        sb1b2.k = u by A17,A15,A22,TARSKI:2;
        hence thesis by A21,A14,A28,A36,A43,A49,A51,A52,FUNCT_1:def 8;
      end;
      sb1b2.i9 in rng(sb1b2) by A28,A49,FUNCT_1:def 5;
      then
A53:  i9 in dom((b1+b2) * sb1b2) by A28,A38,A49,A40,FUNCT_1:21;
      then ((b1+b2) * sb1b2)/.i9 = ((b1+b2) * sb1b2).i9 by PARTFUN1:def 8
        .= (b1+b2).(sb1b2.i9) by A53,FUNCT_1:22
        .= (b1+b2).(sb1b2/.i9) by A28,A49,PARTFUN1:def 8;
      hence yb1b2/.i9 = power(L).((x * sb1b2)/.i9,(b1+b2).(sb1b2/.i9)) by A9
,A19,A44,A48
        .= power(L).((x * sb2)/.i9,b2.(sb2/.i9)) by A3,A20,A50
        .= yb2/.i9 by A12,A44,A48,A47;
    end;
A54: support b1 c= dom b1 by PRE_POLY:37;
    u in support b1 by A1,TARSKI:def 1;
    then
A55: u in dom b1 by A54;
A56: dom b1 = n by PARTFUN1:def 4;
    then x.u in rng x by A5,A55,FUNCT_1:def 5;
    then reconsider xu = x.u as Element of L by A27;
    consider a being Element of L such that
A57: a = (power(L)).(xu,b1.u);
A58: k in dom (x * sb2) by A5,A21,A22,A55,A56,FUNCT_1:21;
    then (x * sb2).k = x.(sb2.k) by FUNCT_1:22;
    then yb1b2/.k = a * yb2/.k by A22,A37,A57,A58,PARTFUN1:def 8;
    hence eval(b1+b2,x) = a * Product yb2 by A8,A19,A35,A39,Th8
      .= eval(b1,x) * eval(b2,x) by A1,A11,A57,Th17;
  end;
  suppose
A59: not u in support b2;
A60: support b1 c= dom b1 by PRE_POLY:37;
    u in support b1 by A1,TARSKI:def 1;
    then
A61: u in dom b1 by A60;
A62: rng x c= the carrier of L by RELAT_1:def 19;
    dom b1 = n by PARTFUN1:def 4;
    then x.u in rng x by A5,A61,FUNCT_1:def 5;
    then reconsider xu = x.u as Element of L by A62;
    consider a being Element of L such that
A63: a = (power(L)).(xu,(b1+b2).u);
A64: (b1+b2).u = b1.u + b2.u by PRE_POLY:def 5
      .= b1.u + 0 by A59,PRE_POLY:def 7;
    thus eval(b1+b2,x) = a * eval(b2,x) by A3,A2,A59,A63,Lm8
      .= eval(b1,x) * eval(b2,x) by A1,A64,A63,Th17;
  end;
end;

theorem Th18:
  for n being Ordinal, L being right_zeroed add-associative
  right_complementable well-unital distributive Abelian non trivial commutative
  associative (non empty doubleLoopStr), b1,b2 being bag of n, x being Function
  of n, L holds eval(b1+b2,x) = eval(b1,x) * eval(b2,x)
proof
  let n be Ordinal, L be right_zeroed add-associative right_complementable
well-unital distributive Abelian non trivial commutative associative (non empty
  doubleLoopStr), b1,b2 be bag of n, x be Function of n, L;
  defpred P[Element of NAT] means for b1 being bag of n st card(support b1) =
  $1 holds eval(b1+b2,x) = eval(b1,x) * eval(b2,x);
A1: ex k being Element of NAT st card(support b1) = k;
A2: for k being Element of NAT st P[k] holds P[k + 1]
  proof
    let k be Element of NAT;
    assume
A3: P[k];
    let b1 be bag of n;
    assume
A4: card(support b1) = k + 1;
    set sgb1 = SgmX(RelIncl n, support b1);
    set bg = sgb1/.(len sgb1);
A5: RelIncl n linearly_orders support b1 by Th15;
    then sgb1 <> {} by A4,CARD_1:47,PRE_POLY:def 2,RELAT_1:60;
    then 1 <= len sgb1 by NAT_1:14;
    then len sgb1 in Seg(len sgb1) by FINSEQ_1:3;
    then
A6: len sgb1 in dom sgb1 by FINSEQ_1:def 3;
    then sgb1/.(len sgb1) = sgb1.(len sgb1) by PARTFUN1:def 8;
    then bg in rng sgb1 by A6,FUNCT_1:def 5;
    then
A7: bg in support b1 by A5,PRE_POLY:def 2;
    set b19 = b1+*(bg,0);
    support b1 c= dom b1 by PRE_POLY:37;
    then
A8: b19 = b1+*(bg.-->0) by A7,FUNCT_7:def 3;
A9: for u being set holds u in support b1 implies u in support b19 \/ {bg }
    proof
      let u be set;
      assume u in support b1;
      then
A10:  b1.u <> 0 by PRE_POLY:def 7;
      per cases;
      suppose
        u = bg;
        then u in {bg} by TARSKI:def 1;
        hence thesis by XBOOLE_0:def 3;
      end;
      suppose
        u <> bg;
        then not u in {bg} by TARSKI:def 1;
        then not u in dom(bg.-->0) by FUNCOP_1:19;
        then b19.u = b1.u by A8,FUNCT_4:12;
        then u in support b19 by A10,PRE_POLY:def 7;
        hence thesis by XBOOLE_0:def 3;
      end;
    end;
    bg in {bg} by TARSKI:def 1;
    then bg in dom(bg.-->0) by FUNCOP_1:19;
    then b19.bg = (bg.-->0).bg by A8,FUNCT_4:14;
    then
A11: b19.bg = 0 by FUNCOP_1:87;
    then
A12: not bg in support b19 by PRE_POLY:def 7;
    for u being set holds u in support b19 \/ {bg} implies u in support b1
    proof
      let u be set;
      assume
A13:  u in support b19 \/ {bg};
      per cases by A13,XBOOLE_0:def 3;
      suppose
A14:    u in support b19;
        then u <> bg by A11,PRE_POLY:def 7;
        then not u in {bg} by TARSKI:def 1;
        then not u in dom(bg.-->0) by FUNCOP_1:19;
        then
A15:    b19.u = b1.u by A8,FUNCT_4:12;
        b19.u <> 0 by A14,PRE_POLY:def 7;
        hence thesis by A15,PRE_POLY:def 7;
      end;
      suppose
        u in {bg};
        hence thesis by A7,TARSKI:def 1;
      end;
    end;
    then support b1 = support b19 \/ {bg} by A9,TARSKI:2;
    then
A16: k + 1 = card(support b19) + 1 by A4,A12,CARD_2:54;
    set m = (EmptyBag n)+*(bg,b1.bg);
A17: dom b1 = n by PARTFUN1:def 4;
    dom(EmptyBag n) = n by PARTFUN1:def 4;
    then
A18: m = (EmptyBag n)+*(bg.-->b1.bg) by A7,FUNCT_7:def 3;
A19: for u being set holds u in support m implies u in {bg}
    proof
      let u be set;
      assume u in support m;
      then
A20:  m.u <> 0 by PRE_POLY:def 7;
      now
        assume u <> bg;
        then not u in {bg} by TARSKI:def 1;
        then not u in dom(bg.-->b1.bg) by FUNCOP_1:19;
        then m.u = (EmptyBag n).u by A18,FUNCT_4:12;
        hence contradiction by A20,PRE_POLY:52;
      end;
      hence thesis by TARSKI:def 1;
    end;
A21: b1.bg <> 0 by A7,PRE_POLY:def 7;
    for u being set holds u in {bg} implies u in support m
    proof
      let u be set;
      bg in {bg} by TARSKI:def 1;
      then bg in dom(bg.-->b1.bg) by FUNCOP_1:19;
      then m.bg = (bg.-->b1.bg).bg by A18,FUNCT_4:14;
      then
A22:  m.bg = b1.bg by FUNCOP_1:87;
      assume u in {bg};
      then u = bg by TARSKI:def 1;
      hence thesis by A21,A22,PRE_POLY:def 7;
    end;
    then
A23: support m = {bg} by A19,TARSKI:2;
A24: for u being set st u in n holds (b19+m).u = b1.u
    proof
      let u be set;
      assume u in n;
      per cases;
      suppose
A25:    u = bg;
        bg in {bg} by TARSKI:def 1;
        then bg in dom(bg.-->b1.bg) by FUNCOP_1:19;
        then m.bg = (bg.-->b1.bg).bg by A18,FUNCT_4:14;
        then
A26:    m.bg = b1.bg by FUNCOP_1:87;
        u in {bg} by A25,TARSKI:def 1;
        then u in dom(bg.-->0) by FUNCOP_1:19;
        then
A27:    b19.u = (bg.-->0).bg by A8,A25,FUNCT_4:14;
        (b19+m).u = b19.u + m.u by PRE_POLY:def 5
          .= 0 + b1.bg by A25,A27,A26,FUNCOP_1:87
          .= b1.bg;
        hence thesis by A25;
      end;
      suppose
        u <> bg;
        then
A28:    not u in {bg} by TARSKI:def 1;
        then
A29:    not u in dom(bg.-->0) by FUNCOP_1:19;
        not u in dom(bg.-->b1.bg) by A28,FUNCOP_1:19;
        then m.u = (EmptyBag n).u by A18,FUNCT_4:12;
        then
A30:    m.u = 0 by PRE_POLY:52;
        (b19+m).u = b19.u + m.u by PRE_POLY:def 5
          .= b1.u by A8,A29,A30,FUNCT_4:12;
        hence thesis;
      end;
    end;
A31: dom(b19 + m) = n by PARTFUN1:def 4;
    then eval(b1,x) = eval(m+b19,x) by A17,A24,FUNCT_1:9
      .= eval(b19,x) * eval(m,x) by A23,Lm9;
    hence eval(b1,x) * eval(b2,x) = (eval(b19,x) * eval(b2,x)) * eval(m,x) by
GROUP_1:def 4
      .= eval(b19+b2,x) * eval(m,x) by A3,A16
      .= eval(m+(b19+b2),x) by A23,Lm9
      .= eval((b19+m)+b2,x) by PRE_POLY:35
      .= eval(b1+b2,x) by A31,A17,A24,FUNCT_1:9;
  end;
A32: P[0]
  proof
    let b1 be bag of n;
    assume card(support b1) = 0;
    then support b1 = {};
    then
A33: b1 = EmptyBag n by Th14;
    hence eval(b1+b2,x) = eval(b2,x) by PRE_POLY:53
      .= 1.L * eval(b2,x) by VECTSP_1:def 16
      .= eval(b1,x) * eval(b2,x) by A33,Th16;
  end;
  for k being Element of NAT holds P[k] from NAT_1:sch 1(A32,A2);
  hence thesis by A1;
end;


begin :: Evaluation of Polynomials ------------------------------------------------

registration
  let n be Ordinal, L be add-associative right_zeroed right_complementable (
  non empty addLoopStr), p,q be Polynomial of n, L;
  cluster p - q -> finite-Support;
  coherence
  proof
    p - q = p + (-q) by POLYNOM1:def 23;
    hence thesis;
  end;
end;

theorem Th19:
  for L being right_zeroed add-associative right_complementable
well-unital distributive non trivial (non empty doubleLoopStr), n being Ordinal
  , p being Polynomial of n,L st Support p = {} holds p = 0_(n,L)
proof
  let L be right_zeroed add-associative right_complementable well-unital
  distributive non trivial (non empty doubleLoopStr), n be Ordinal, p be
  Polynomial of n,L such that
A1: Support p = {};
A2: for u being set st u in Bags n holds p.u = 0_(n,L).u
  proof
    let u be set;
    assume
A3: u in Bags n;
    then reconsider b = u as bag of n;
    p.b = 0.L by A1,A3,POLYNOM1:def 9;
    hence thesis by POLYNOM1:81;
  end;
A4: Bags n = dom 0_(n,L) by FUNCT_2:def 1;
  Bags n = dom p by FUNCT_2:def 1;
  hence thesis by A4,A2,FUNCT_1:9;
end;

registration
  let n be Ordinal, L be right_zeroed add-associative right_complementable
well-unital distributive non trivial (non empty doubleLoopStr), p be Polynomial
  of n,L;
  cluster Support p -> finite;
  coherence by POLYNOM1:def 10;
end;

theorem Th20:
  for n being Ordinal, L being right_zeroed add-associative
  right_complementable well-unital distributive non trivial (non empty
  doubleLoopStr), p being Polynomial of n,L holds BagOrder n linearly_orders
  Support p
proof
  let n be Ordinal, L be right_zeroed add-associative right_complementable
well-unital distributive non trivial (non empty doubleLoopStr), p be Polynomial
  of n,L;
  set R = BagOrder n;
  R is connected by ORDERS_1:def 5;
  then
A1: R is_connected_in field R by RELAT_2:def 14;
  for x being set holds x in Bags n implies x in field R
  proof
    let x be set;
    assume x in Bags n;
    then reconsider x as bag of n;
    EmptyBag n <=' x by PRE_POLY:60;
    then [EmptyBag n, x] in R by PRE_POLY:def 14;
    then
A2: x in rng R by RELAT_1:def 5;
    field R = dom R \/ rng R by RELAT_1:def 6;
    then rng R c= field R by XBOOLE_1:7;
    hence thesis by A2;
  end;
  then
A3: Bags n c= field R by TARSKI:def 3;
  then [:Bags n, Bags n:] c= [:field R, field R:] by ZFMISC_1:119;
  then reconsider R9 = R as Relation of field R by XBOOLE_1:1;
  R is_reflexive_in field R by RELAT_2:def 9;
  then dom R9 = field R by ORDERS_1:98;
  then
A4: R9 is total by PARTFUN1:def 4;
  Support p c= field R by A3,XBOOLE_1:1;
  then
A5: R9 is_connected_in Support p by A1,A4,Lm2;
A6: R is_antisymmetric_in Support p by Lm1;
A7: R is_transitive_in Support p by Lm1;
  R is_reflexive_in Support p by Lm1;
  hence thesis by A6,A7,A5,ORDERS_1:def 8;
end;

definition
  let n be Ordinal, b be Element of Bags n;
  func b@ -> bag of n equals
  b;
  correctness;
end;

definition
  let n be Ordinal, L be right_zeroed add-associative right_complementable
well-unital distributive non trivial (non empty doubleLoopStr), p be Polynomial
  of n,L, x be Function of n, L;
  func eval(p,x) -> Element of L means
  :Def4:
  ex y being FinSequence of the
  carrier of L st len y = len SgmX(BagOrder n, Support p) & it = Sum y & for i
being Element of NAT st 1 <= i & i <= len y holds y/.i = (p * SgmX(BagOrder n,
  Support p))/.i * eval(((SgmX(BagOrder n, Support p))/.i)@,x);
  existence
  proof
    set S = SgmX(BagOrder n, Support p);
    set l = len S;
    defpred P[Element of NAT,Element of L] means $2 = (p * S)/.($1) * eval((S
    /.($1))@,x);
A1: for k being Element of NAT st k in Seg l ex x being Element of L st P[
    k,x];
    consider q being FinSequence of the carrier of L such that
A2: dom q = Seg l & for m being Element of NAT st m in Seg l holds P[m
    ,q/.m] from RECDEF_1:sch 17(A1 );
    take Sum q;
A3: len q = l by A2,FINSEQ_1:def 3;
    now
      let m be Element of NAT;
      assume that
A4:   1 <= m and
A5:   m <= len q;
      m in Seg(len q) by A4,A5,FINSEQ_1:3;
      hence q/.m = (p * SgmX(BagOrder n, Support p))/.m * eval(((SgmX(BagOrder
      n, Support p))/.m)@,x) by A2,A3;
    end;
    hence thesis by A3;
  end;
  uniqueness
  proof
    let a,c be Element of L;
    assume that
A6: ex y1 being FinSequence of the carrier of L st len y1 = len SgmX(
BagOrder n, Support p) & a = Sum y1 & for i being Element of NAT st 1 <= i & i
    <= len y1 holds y1/.i = (p * SgmX(BagOrder n, Support p))/.i * eval(((SgmX(
    BagOrder n, Support p))/.i)@,x) and
A7: ex y2 being FinSequence of the carrier of L st len y2 = len SgmX(
BagOrder n, Support p) & c = Sum y2 & for i being Element of NAT st 1 <= i & i
    <= len y2 holds y2/.i = (p * SgmX(BagOrder n, Support p))/.i * eval(((SgmX(
    BagOrder n, Support p))/.i)@,x);
    consider y1 being FinSequence of the carrier of L such that
A8: len y1 = len SgmX(BagOrder n, Support p) and
A9: a = Sum y1 and
A10: for i being Element of NAT st 1 <= i & i <= len y1 holds y1/.i =
(p * SgmX(BagOrder n, Support p))/.i * eval(((SgmX(BagOrder n, Support p))/.i)@
    ,x) by A6;
    consider y2 being FinSequence of the carrier of L such that
A11: len y2 = len SgmX(BagOrder n, Support p) and
A12: c = Sum y2 and
A13: for i being Element of NAT st 1 <= i & i <= len y2 holds y2/.i =
(p * SgmX(BagOrder n, Support p))/.i * eval(((SgmX(BagOrder n, Support p))/.i)@
    ,x) by A7;
    for k being Nat st 1 <= k & k <= len y1 holds y1.k = y2.k
    proof
      let k be Nat;
      assume that
A14:  1 <= k and
A15:  k <= len y1;
      k in Seg(len y2) by A8,A11,A14,A15,FINSEQ_1:3;
      then
A16:  k in dom y2 by FINSEQ_1:def 3;
A17:  k in Seg(len y1) by A14,A15,FINSEQ_1:3;
      then k in dom y1 by FINSEQ_1:def 3;
      hence y1.k = y1/.k by PARTFUN1:def 8
        .= (p * SgmX(BagOrder n, Support p))/.k * eval(((SgmX(BagOrder n,
      Support p))/.k)@,x) by A10,A14,A15,A17
        .= y2/.k by A8,A11,A13,A14,A15,A17
        .= y2.k by A16,PARTFUN1:def 8;
    end;
    hence thesis by A8,A9,A11,A12,FINSEQ_1:18;
  end;
end;

theorem Th21:
  for n being Ordinal, L being right_zeroed add-associative
  right_complementable well-unital distributive non trivial (non empty
doubleLoopStr), p being Polynomial of n,L, b being bag of n st Support p = {b}
  for x being Function of n, L holds eval(p,x) = p.b * eval(b,x)
proof
  let n be Ordinal, L be right_zeroed add-associative right_complementable
well-unital distributive non trivial (non empty doubleLoopStr), p be Polynomial
  of n,L, b be bag of n;
  reconsider sp = Support p as finite Subset of Bags n;
  set sg = SgmX(BagOrder n, sp);
A1: b in Bags n by PRE_POLY:def 12;
A2: dom p = Bags n by FUNCT_2:def 1;
A3: BagOrder n linearly_orders sp by Th20;
  assume Support p = {b};
  then
A4: rng sg = {b} by A3,PRE_POLY:def 2;
  then
A5: b in rng sg by TARSKI:def 1;
  then
A6: 1 in dom sg by FINSEQ_3:33;
  then
A7: sg/.1 = sg.1 by PARTFUN1:def 8;
A8: for u being set holds u in dom sg implies u in {1}
  proof
    let u be set;
    assume
A9: u in dom sg;
    assume
A10: not u in {1};
    reconsider u as Element of NAT by A9;
    sg/.u = sg.u by A9,PARTFUN1:def 8;
    then
A11: sg/.u in rng sg by A9,FUNCT_1:def 5;
A12: u <> 1 by A10,TARSKI:def 1;
A13: 1 < u
    proof
      consider k being Nat such that
A14:  dom sg = Seg k by FINSEQ_1:def 2;
      Seg k = {l where l is Element of NAT : 1 <= l & l <= k} by FINSEQ_1:def 1
;
      then
      ex m9 being Element of NAT st m9 = u & 1 <= m9 & m9 <= k by A9,A14;
      hence thesis by A12,XXREAL_0:1;
    end;
    sg/.1 = sg.1 by A5,A9,FINSEQ_3:33,PARTFUN1:def 8;
    then sg/.1 in rng sg by A6,FUNCT_1:def 5;
    then sg/.1 = b by A4,TARSKI:def 1
      .= sg/.u by A4,A11,TARSKI:def 1;
    hence thesis by A3,A6,A9,A13,PRE_POLY:def 2;
  end;
  for u being set holds u in {1} implies u in dom sg by A6,TARSKI:def 1;
  then
A15: dom sg = Seg 1 by A8,FINSEQ_1:4,TARSKI:2;
  then
A16: len sg = 1 by FINSEQ_1:def 3;
A17: sg.1 in rng sg by A6,FUNCT_1:def 5;
  then sg.1 = b by A4,TARSKI:def 1;
  then 1 in dom (p * sg) by A6,A1,A2,FUNCT_1:21;
  then
A18: (p * sg)/.1 = (p * sg).1 by PARTFUN1:def 8
    .= p.(sg.1) by A6,FUNCT_1:23
    .= p.b by A4,A17,TARSKI:def 1;
  1 in dom sg by A15,FINSEQ_1:4,TARSKI:def 1;
  then
A19: sg/.1 in rng sg by A7,FUNCT_1:def 5;
  let x be Function of n, L;
  consider y being FinSequence of the carrier of L such that
A20: len y = len SgmX(BagOrder n, Support p) and
A21: eval(p,x) = Sum y and
A22: for i being Element of NAT st 1 <= i & i <= len y holds y/.i = (p *
  SgmX(BagOrder n, Support p))/.i * eval(((SgmX(BagOrder n, Support p))/.i)@,x)
  by Def4;
  y.1 = y/.1 by A20,A16,FINSEQ_4:24
    .= (p * sg)/.1 * eval((sg/.1)@,x) by A20,A22,A16
    .= (p * sg)/.1 * eval(b,x) by A4,A19,TARSKI:def 1;
  then y = <* p.b * eval(b,x) *> by A20,A16,A18,FINSEQ_1:57;
  hence thesis by A21,RLVECT_1:61;
end;

theorem Th22:
  for n being Ordinal, L being right_zeroed add-associative
  right_complementable well-unital distributive non trivial (non empty
  doubleLoopStr), x being Function of n, L holds eval(0_(n,L),x) = 0.L
proof
  let n be Ordinal, L be right_zeroed add-associative right_complementable
  well-unital distributive non trivial (non empty doubleLoopStr), x be Function
  of n, L;
  set 0p = 0_(n,L);
  consider y being FinSequence of the carrier of L such that
A1: len y = len SgmX(BagOrder n, Support 0p) and
A2: Sum y = eval(0p,x) and
  for i being Element of NAT st 1 <= i & i <= len y holds y/.i = (0p *
SgmX(BagOrder n, Support 0p))/.i * eval(((SgmX(BagOrder n, Support 0p))/.i)@,x)
  by Def4;
  Support 0p = {}
  proof
    set u =the  Element of Support 0p;
    assume Support 0p <> {};
    then
A3: u in Support 0p;
    then
A4: u is Element of Bags n;
    0p.u <> 0.L by A3,POLYNOM1:def 9;
    hence thesis by A4,POLYNOM1:81;
  end;
  then SgmX(BagOrder n, Support 0p) = {} by Th9,Th20;
  then y = <*>the carrier of L by A1;
  hence thesis by A2,RLVECT_1:60;
end;

theorem Th23:
  for n being Ordinal, L being right_zeroed add-associative
  right_complementable well-unital distributive non trivial (non empty
  doubleLoopStr), x being Function of n, L holds eval(1_(n,L),x) = 1.L
proof
  let n be Ordinal, L be right_zeroed add-associative right_complementable
  well-unital distributive non trivial (non empty doubleLoopStr), x be Function
  of n, L;
  set 1p = 1_(n,L);
A1: for u being set holds u in {EmptyBag n} implies u in Support 1p
  proof
    let u be set;
    assume
A2: u in {EmptyBag n};
    then
A3: u = EmptyBag n by TARSKI:def 1;
    reconsider u as Element of Bags n by A2,TARSKI:def 1;
    1p.u = 1.L by A3,POLYNOM1:84;
    then 1p.u <> 0.L;
    hence thesis by POLYNOM1:def 9;
  end;
  reconsider s1p = Support 1p as finite Subset of Bags n;
  set sg1p = SgmX(BagOrder n, s1p);
A4: BagOrder n linearly_orders Support 1p by Th20;
  for u being set holds u in Support 1p implies u in {EmptyBag n}
  proof
    let u be set;
    assume
A5: u in Support 1p;
    then reconsider u as Element of Bags n;
    1p.u <> 0.L by A5,POLYNOM1:def 9;
    then u = EmptyBag n by POLYNOM1:84;
    hence thesis by TARSKI:def 1;
  end;
  then
A6: Support 1p = {EmptyBag n} by A1,TARSKI:2;
  then
A7: rng sg1p = {EmptyBag n} by A4,PRE_POLY:def 2;
  then
A8: EmptyBag n in rng sg1p by TARSKI:def 1;
  then
A9: 1 in dom sg1p by FINSEQ_3:33;
  then sg1p/.1 = sg1p.1 by PARTFUN1:def 8;
  then sg1p/.1 in rng sg1p by A9,FUNCT_1:def 5;
  then
A10: sg1p/.1 = EmptyBag n by A7,TARSKI:def 1;
A11: for u being set holds u in dom sg1p implies u in {1}
  proof
    let u be set;
    assume
A12: u in dom sg1p;
    assume
A13: not u in {1};
    reconsider u as Element of NAT by A12;
    sg1p/.u = sg1p.u by A12,PARTFUN1:def 8;
    then
A14: sg1p/.u in rng sg1p by A12,FUNCT_1:def 5;
A15: u <> 1 by A13,TARSKI:def 1;
A16: 1 < u
    proof
      consider k being Nat such that
A17:  dom sg1p = Seg k by FINSEQ_1:def 2;
      Seg k = {m where m is Element of NAT : 1 <= m & m <= k} by FINSEQ_1:def 1
;
      then
      ex m9 being Element of NAT st m9 = u & 1 <= m9 & m9 <= k by A12,A17;
      hence thesis by A15,XXREAL_0:1;
    end;
    sg1p/.1 = sg1p.1 by A8,A12,FINSEQ_3:33,PARTFUN1:def 8;
    then sg1p/.1 in rng sg1p by A9,FUNCT_1:def 5;
    then sg1p/.1 = EmptyBag n by A7,TARSKI:def 1
      .= sg1p/.u by A7,A14,TARSKI:def 1;
    hence thesis by A4,A9,A12,A16,PRE_POLY:def 2;
  end;
A18: dom 1p = Bags n by FUNCT_2:def 1;
A19: 1 in dom sg1p by A8,FINSEQ_3:33;
A20: sg1p.1 in rng sg1p by A9,FUNCT_1:def 5;
  then sg1p.1 in {EmptyBag n} by A6,A4,PRE_POLY:def 2;
  then sg1p.1 = EmptyBag n by TARSKI:def 1;
  then 1 in dom (1p * sg1p) by A19,A18,FUNCT_1:21;
  then
A21: (1p * sg1p)/.1 = (1p * sg1p).1 by PARTFUN1:def 8
    .= 1p.(sg1p.1) by A9,FUNCT_1:23
    .= 1p.(EmptyBag n) by A7,A20,TARSKI:def 1
    .= 1.L by POLYNOM1:84;
  consider y being FinSequence of the carrier of L such that
A22: len y = len sg1p and
A23: Sum y = eval(1p,x) and
A24: for i being Element of NAT st 1 <= i & i <= len y holds y/.i = (1p
  * sg1p)/.i * eval(((sg1p)/.i)@,x) by Def4;
  for u being set holds u in {1} implies u in dom sg1p by A9,TARSKI:def 1;
  then dom sg1p = Seg 1 by A11,FINSEQ_1:4,TARSKI:2;
  then
A25: len sg1p = 1 by FINSEQ_1:def 3;
  then y.1 = y/.1 by A22,FINSEQ_4:24
    .= (1p * sg1p)/.1 * eval(((sg1p)/.1)@,x) by A25,A22,A24
    .= (1p * sg1p)/.1 * 1.L by A10,Th16
    .= (1p * sg1p)/.1 by VECTSP_1:def 16;
  then y = <* 1.L *> by A25,A22,A21,FINSEQ_1:57;
  hence thesis by A23,RLVECT_1:61;
end;

theorem Th24:
  for n being Ordinal, L being right_zeroed add-associative
  right_complementable well-unital distributive non trivial (non empty
doubleLoopStr), p being Polynomial of n,L, x being Function of n, L holds eval(
  -p,x) = - eval(p,x)
proof
  let n be Ordinal, L be right_zeroed add-associative right_complementable
well-unital distributive non trivial (non empty doubleLoopStr), p be Polynomial
  of n,L, x be Function of n, L;
  set mp = -p;
A1: for u being set holds u in Support p implies u in Support mp
  proof
    let u be set;
    assume
A2: u in Support p;
    then reconsider u as Element of Bags n;
    reconsider u as bag of n;
A3: p.u <> 0.L by A2,POLYNOM1:def 9;
    mp.u <> 0.L
    proof
      assume mp.u = 0.L;
      then -(-(p.u)) = - 0.L by POLYNOM1:37;
      then p.u = - 0.L by RLVECT_1:30;
      hence thesis by A3,RLVECT_1:25;
    end;
    hence thesis by POLYNOM1:def 9;
  end;
  consider ymp being FinSequence of the carrier of L such that
A4: len ymp = len SgmX(BagOrder n, Support mp) and
A5: Sum ymp = eval(mp,x) and
A6: for i being Element of NAT st 1 <= i & i <= len ymp holds ymp/.i =
(mp * SgmX(BagOrder n, Support mp))/.i * eval(((SgmX(BagOrder n, Support mp))/.
  i)@,x) by Def4;
  consider yp being FinSequence of the carrier of L such that
A7: len yp = len SgmX(BagOrder n, Support p) and
A8: Sum yp = eval(p,x) and
A9: for i being Element of NAT st 1 <= i & i <= len yp holds yp/.i = (p
* SgmX(BagOrder n, Support p))/.i * eval(((SgmX(BagOrder n, Support p))/.i)@,x)
  by Def4;
A10: for u being set holds u in Support mp implies u in Support p
  proof
    let u be set;
    assume
A11: u in Support mp;
    then reconsider u as Element of Bags n;
    reconsider u as bag of n;
    mp.u <> 0.L by A11,POLYNOM1:def 9;
    then -(p.u) <> 0.L by POLYNOM1:37;
    then p.u <> 0.L by RLVECT_1:25;
    hence thesis by POLYNOM1:def 9;
  end;
  then
A12: len ymp = len yp by A1,A7,A4,TARSKI:2;
A13: dom ((-1.L) * yp) = dom yp by POLYNOM1:def 2;
  consider k being Element of NAT such that
A14: k = len ((-1.L) * yp);
  consider l being Element of NAT such that
A15: l = len yp;
A16: dom ((-1.L) * yp) = Seg k by A14,FINSEQ_1:def 3;
A17: SgmX(BagOrder n, Support p) = SgmX(BagOrder n, Support mp) by A1,A10,
TARSKI:2;
A18: for k being Nat st 1 <= k & k <= len ymp holds ymp.k = ((-1.L) * yp).k
  proof
    let k be Nat;
    assume that
A19: 1 <= k and
A20: k <= len ymp;
A21: k <= len ((-1.L) * yp) by A12,A13,A14,A16,A20,FINSEQ_1:def 3;
A22: (mp * SgmX(BagOrder n, Support p))/.k = (-1.L) * ((p * SgmX(BagOrder
    n, Support p))/.k)
    proof
      reconsider b = SgmX(BagOrder n, Support p)/.k as bag of n;
      k in Seg (len(SgmX(BagOrder n, Support p))) by A7,A12,A19,A20,FINSEQ_1:3;
      then
A23:  k in dom SgmX(BagOrder n, Support p) by FINSEQ_1:def 3;
A24:  dom p = Bags n by FUNCT_2:def 1;
      then b in dom p;
      then
A25:  k in dom (p * SgmX(BagOrder n, Support p)) by A23,PARTFUN2:6;
A26:  dom mp = Bags n by FUNCT_2:def 1;
      then b in dom mp;
      then k in dom (mp * SgmX(BagOrder n, Support p)) by A23,PARTFUN2:6;
      hence (mp * SgmX(BagOrder n, Support p))/.k = mp/.b by PARTFUN2:6
        .= mp.b by A26,PARTFUN1:def 8
        .= -(p.b) by POLYNOM1:37
        .= -(p/.b) by A24,PARTFUN1:def 8
        .= -(1.L * p/.b) by VECTSP_1:def 16
        .= (-1.L) * p/.b by VECTSP_1:41
        .= (-1.L) * ((p * SgmX(BagOrder n, Support p))/.k) by A25,PARTFUN2:6;
    end;
A27: k in Seg l by A12,A15,A19,A20,FINSEQ_1:3;
    then
A28: k in dom yp by A15,FINSEQ_1:def 3;
    thus ymp.k = ymp/.k by A19,A20,FINSEQ_4:24
      .= ((-1.L) * ((p * SgmX(BagOrder n, Support p))/.k)) * eval(((SgmX(
    BagOrder n, Support p))/.k)@,x) by A17,A6,A19,A20,A27,A22
      .= (-(1.L * ((p * SgmX(BagOrder n, Support p))/.k))) * eval(((SgmX(
    BagOrder n, Support p))/.k)@,x) by VECTSP_1:41
      .= (-((p * SgmX(BagOrder n, Support p))/.k)) * eval(((SgmX(BagOrder n,
    Support p))/.k)@,x) by VECTSP_1:def 16
      .= -(((p * SgmX(BagOrder n, Support p))/.k) * eval(((SgmX(BagOrder n,
    Support p))/.k)@,x)) by VECTSP_1:41
      .= - (yp/.k) by A9,A12,A19,A20,A27
      .= - (1.L * (yp/.k)) by VECTSP_1:def 16
      .= (-1.L) * (yp/.k) by VECTSP_1:41
      .= ((-1.L) * yp)/.k by A28,POLYNOM1:def 2
      .= ((-1.L) * yp).k by A19,A21,FINSEQ_4:24;
  end;
  dom yp = Seg l by A15,FINSEQ_1:def 3;
  hence eval(mp,x) = Sum((-1.L) * yp) by A5,A12,A13,A14,A15,A16,A18,FINSEQ_1:8
,18
    .= (-1.L) * Sum(yp) by POLYNOM1:28 :: Sum yp = eval(p,x)
    .= (-1.L) * eval(p,x) by A8
    .= -(1.L * eval(p,x)) by VECTSP_1:41
    .= - eval(p,x) by VECTSP_1:def 16;
end;

Lm10: for n being Ordinal, L being right_zeroed add-associative
right_complementable Abelian well-unital distributive non trivial (non empty
doubleLoopStr), p,q being Polynomial of n,L, x being Function of n, L, b being
bag of n st not(b in Support p) & Support q = Support p \/ {b} & for b9 being
bag of n st b9 <> b holds q.b9 = p.b9 holds eval(q,x) = eval(p,x) + q.b * eval(
b,x)
proof
  let n be Ordinal, L be right_zeroed add-associative right_complementable
Abelian well-unital distributive non trivial (non empty doubleLoopStr), p,q be
  Polynomial of n,L, x be Function of n, L, b be bag of n;
  assume that
A1: not b in Support p and
A2: Support q = Support p \/ {b} and
A3: for b9 being bag of n st b9 <> b holds q.b9 = p.b9;
  set sq = SgmX(BagOrder n, Support q), sp = SgmX(BagOrder n, Support p);
A4: BagOrder n linearly_orders Support q by Th20;
  b in {b} by TARSKI:def 1;
  then b in Support q by A2,XBOOLE_0:def 3;
  then b in rng sq by A4,PRE_POLY:def 2;
  then consider k being Nat such that
A5: k in dom sq and
A6: sq.k = b by FINSEQ_2:11;
A7: sq/.k = b by A5,A6,PARTFUN1:def 8;
  reconsider b as Element of Bags n by PRE_POLY:def 12;
A8: dom sq = Seg(len sq) by FINSEQ_1:def 3;
  then
A9: k <= len sq by A5,FINSEQ_1:3;
  1 <= k by A5,A8,FINSEQ_1:3;
  then 1 - 1 <= k - 1 by XREAL_1:11;
  then reconsider k9 = k - 1 as Element of NAT by INT_1:16;
A10: k9 + 1 = k + 0;
  then
A11: sq = Ins(sp,k9,b) by A1,A2,A5,A7,Th13,Th20;
  consider yp being FinSequence of the carrier of L such that
A12: len yp = len sp and
A13: Sum yp = eval(p,x) and
A14: for i being Element of NAT st 1 <= i & i <= len yp holds yp/.i = (p
  * sp)/.i * eval((sp/.i)@,x) by Def4;
  consider yq being FinSequence of the carrier of L such that
A15: len yq = len sq and
A16: Sum yq = eval(q,x) and
A17: for i being Element of NAT st 1 <= i & i <= len yq holds yq/.i = (q
  * sq)/.i * eval((sq/.i)@,x) by Def4;
  reconsider b as Element of Bags n;
  set ytmp = Ins(yp,k9,q.b * eval(b,x));
A18: len sp + 1 = (card(Support p) + 1) by Th20,PRE_POLY:11
    .= card(Support q) by A1,A2,CARD_2:54
    .= len sq by Th20,PRE_POLY:11;
  then
A19: len yq = len ytmp by A15,A12,FINSEQ_5:72;
A20: BagOrder n linearly_orders Support p by Th20;
A21: for i being Nat st 1 <= i & i <= len yq holds yq.i = ytmp.i
  proof
    let i be Nat;
    assume that
A22: 1 <= i and
A23: i <= len yq;
    i in Seg(len yq) by A22,A23,FINSEQ_1:3;
    then
A24: i in dom yq by FINSEQ_1:def 3;
    i in Seg(len ytmp) by A19,A22,A23,FINSEQ_1:3;
    then
A25: i in dom ytmp by FINSEQ_1:def 3;
    per cases;
    suppose
A26:  i = k;
      dom q = Bags n by FUNCT_2:def 1;
      then sq.k in dom q by A6,PRE_POLY:def 12;
      then
A27:  k in dom(q * sq) by A5,FUNCT_1:21;
      then
A28:  (q * sq)/.k = (q * sq).k by PARTFUN1:def 8
        .= q.b by A6,A27,FUNCT_1:22;
A29:  yq/.i = (q * sq)/.k * eval((sq/.k)@,x) by A5,A17,A22,A23,A26
        .= q.b * eval(b,x) by A5,A6,A28,PARTFUN1:def 8;
A30:  k9 <= len yp by A9,A10,A12,A18,XREAL_1:8;
      thus ytmp.i = ytmp/.i by A25,PARTFUN1:def 8
        .= q.b * eval(b,x) by A10,A26,A30,FINSEQ_5:76
        .= yq.i by A24,A29,PARTFUN1:def 8;
    end;
    suppose
A31:  i <> k;
      len(Ins(sp,k9,b)) = len sp + 1 by FINSEQ_5:72;
      then
A32:  dom(Ins(sp,k9,b)) = Seg(len(sp)+1) by FINSEQ_1:def 3;
      now
        per cases by A31,XXREAL_0:1;
        case
A33:      i < k;
          k9 < k by A10,NAT_1:19;
          then k9 < len yq by A9,A15,XXREAL_0:2;
          then
A34:      k9 <= len yp by A15,A12,A18,NAT_1:13;
A35:      yp|(Seg k9) is FinSequence by FINSEQ_1:19;
A36:      i <= k9 by A10,A33,NAT_1:13;
          then i in Seg k9 by A22,FINSEQ_1:3;
          then i in dom(yp|(Seg k9)) by A34,A35,FINSEQ_1:21;
          then
A37:      i in dom(yp|k9) by FINSEQ_1:def 15;
A38:      k - 1 <= (len sp + 1) - 1 by A9,A18,XREAL_1:11;
          then
A39:      i <= len sp by A36,XXREAL_0:2;
          then i in Seg(len sp) by A22,FINSEQ_1:3;
          then
A40:      i in dom sp by FINSEQ_1:def 3;
A41:      now
            assume sp/.i = b;
            then sp.i = b by A40,PARTFUN1:def 8;
            then b in rng sp by A40,FUNCT_1:def 5;
            hence contradiction by A1,A20,PRE_POLY:def 2;
          end;
          i < len yq by A9,A15,A33,XXREAL_0:2;
          then
A42:      i <= len yp by A15,A12,A18,NAT_1:13;
A43:      sp|(Seg k9) is FinSequence by FINSEQ_1:19;
A44:      rng Ins(sp,k9,b) c= Bags n by FINSEQ_1:def 4;
A45:      dom q = Bags n by FUNCT_2:def 1;
A46:      rng sp c= Bags n by FINSEQ_1:def 4;
          i in Seg k9 by A22,A36,FINSEQ_1:3;
          then i in dom(sp|(Seg k9)) by A38,A43,FINSEQ_1:21;
          then
A47:      i in dom(sp|k9) by FINSEQ_1:def 15;
          sp.i in rng sp by A40,FUNCT_1:def 5;
          then sp.i in Bags n by A46;
          then sp.i in dom p by FUNCT_2:def 1;
          then
A48:      i in dom(p * sp) by A40,FUNCT_1:21;
          len sp <= len sp + 1 by XREAL_1:31;
          then i <= len sp + 1 by A39,XXREAL_0:2;
          then
A49:      i in dom(Ins(sp,k9,b)) by A22,A32,FINSEQ_1:3;
          then Ins(sp,k9,b).i in rng Ins(sp,k9,b) by FUNCT_1:def 5;
          then
A50:      i in dom(q * Ins(sp,k9,b)) by A49,A44,A45,FUNCT_1:21;
          then
A51:      (q * Ins(sp,k9,b))/.i = (q * Ins(sp,k9,b)).i by PARTFUN1:def 8
            .= q.(Ins(sp,k9,b).i) by A50,FUNCT_1:22
            .= q.(Ins(sp,k9,b)/.i) by A49,PARTFUN1:def 8
            .= q.(sp/.i) by A47,FINSEQ_5:75
            .= p.(sp/.i) by A3,A41
            .= p.(sp.i) by A40,PARTFUN1:def 8
            .= (p * sp).i by A48,FUNCT_1:22
            .= (p * sp)/.i by A48,PARTFUN1:def 8;
A52:      yq/.i = (q * sq)/.i * eval((sq/.i)@,x) by A17,A22,A23,A49
            .= (p * sp)/.i * eval((sp/.i)@,x) by A11,A47,A51,FINSEQ_5:75
            .= yp/.i by A14,A22,A49,A42
            .= ytmp/.i by A37,FINSEQ_5:75;
          thus yq.i = yq/.i by A24,PARTFUN1:def 8
            .= ytmp.i by A25,A52,PARTFUN1:def 8;
        end;
        case
A53:      i > k;
          then i - 1 > k9 by XREAL_1:11;
          then reconsider i1 = i - 1 as Element of NAT by INT_1:16;
A54:      (i - 1) + 1 = i + 0;
          then
A55:      k9 + 1 <= i1 by A53,NAT_1:13;
A56:      dom q = Bags n by FUNCT_2:def 1;
A57:      rng Ins(sp,k9,b) c= Bags n by FINSEQ_1:def 4;
A58:      dom p = Bags n by FUNCT_2:def 1;
A59:      rng sp c= Bags n by FINSEQ_1:def 4;
A60:      i - 1 <= (len yp + 1) - 1 by A15,A12,A18,A23,XREAL_1:11;
          0 + 1 <= k9 + 1 by XREAL_1:8;
          then 1 < i by A53,XXREAL_0:2;
          then
A61:      1 <= i1 by A54,NAT_1:13;
          then i1 in Seg(len sp) by A12,A60,FINSEQ_1:3;
          then
A62:      i1 in dom sp by FINSEQ_1:def 3;
A63:      now
            assume sp/.i1 = b;
            then sp.i1 = b by A62,PARTFUN1:def 8;
            then b in rng sp by A62,FUNCT_1:def 5;
            hence contradiction by A1,A20,PRE_POLY:def 2;
          end;
          sp.i1 in rng sp by A62,FUNCT_1:def 5;
          then
A64:      i1 in dom(p * sp) by A62,A59,A58,FUNCT_1:21;
A65:      i = i1 + 1;
A66:      i in dom(Ins(sp,k9,b)) by A15,A18,A22,A23,A32,FINSEQ_1:3;
          then Ins(sp,k9,b).i in rng Ins(sp,k9,b) by FUNCT_1:def 5;
          then
A67:      i in dom(q * Ins(sp,k9,b)) by A66,A57,A56,FUNCT_1:21;
          then
A68:      (q * Ins(sp,k9,b))/.i = (q * Ins(sp,k9,b)).i by PARTFUN1:def 8
            .= q.(Ins(sp,k9,b).i) by A67,FUNCT_1:22
            .= q.(Ins(sp,k9,b)/.i) by A66,PARTFUN1:def 8
            .= q.(sp/.i1) by A12,A60,A65,A55,FINSEQ_5:77
            .= p.(sp/.i1) by A3,A63
            .= p.(sp.i1) by A62,PARTFUN1:def 8
            .= (p * sp).i1 by A64,FUNCT_1:22
            .= (p * sp)/.i1 by A64,PARTFUN1:def 8;
A69:      yq/.i = (q * sq)/.i * eval((sq/.i)@,x) by A17,A22,A23,A66
            .= (p * sp)/.i1 * eval((sp/.i1)@,x) by A11,A12,A60,A65,A55,A68,
FINSEQ_5:77
            .= yp/.i1 by A14,A60,A61
            .= ytmp/.i by A60,A65,A55,FINSEQ_5:77;
          thus yq.i = yq/.i by A24,PARTFUN1:def 8
            .= ytmp.i by A25,A69,PARTFUN1:def 8;
        end;
      end;
      hence thesis;
    end;
  end;
  Sum((yp|k9)^<*q.b * eval(b,x)*>^(yp/^k9)) = Sum((yp|k9)^<*q.b * eval(b,
  x)*>) + Sum(yp/^k9) by RLVECT_1:58
    .= (Sum(yp|k9) + Sum(<*q.b * eval(b,x)*>)) + Sum(yp/^k9) by RLVECT_1:58
    .= (Sum(yp|k9) + Sum(yp/^k9)) + Sum(<*q.b * eval(b,x)*>) by RLVECT_1:def 6
    .= Sum((yp|k9)^(yp/^k9)) + Sum(<*q.b * eval(b,x)*>) by RLVECT_1:58
    .= Sum yp + Sum(<*q.b * eval(b,x)*>) by RFINSEQ:21
    .= eval(p,x) + q.b * eval(b,x) by A13,RLVECT_1:61;
  then Sum ytmp = eval(p,x) + q.b * eval(b,x) by FINSEQ_5:def 4;
  hence thesis by A16,A19,A21,FINSEQ_1:18;
end;

Lm11: for n being Ordinal, L being right_zeroed add-associative
right_complementable Abelian well-unital distributive non trivial (non empty
doubleLoopStr), p being Polynomial of n,L st (ex b being bag of n st Support p
= {b}) for q being Polynomial of n,L, x being Function of n, L holds eval(p+q,x
) = eval(p,x) + eval(q,x)
proof
  let n be Ordinal, L be right_zeroed add-associative right_complementable
  well-unital distributive Abelian non trivial (non empty doubleLoopStr), p be
  Polynomial of n,L;
  assume ex b being bag of n st Support p = {b};
  then consider b being bag of n such that
A1: Support p = {b};
  b in Support p by A1,TARSKI:def 1;
  then
A2: p.b <> 0.L by POLYNOM1:def 9;
  let q be Polynomial of n,L, x be Function of n, L;
A3: for b9 being bag of n st b9 <> b holds (p+q).b9 = q.b9
  proof
    let b9 be bag of n;
A4: b9 is Element of Bags n by PRE_POLY:def 12;
    assume b9 <> b;
    then
A5: not b9 in Support p by A1,TARSKI:def 1;
    thus (p+q).b9 = p.b9 + q.b9 by POLYNOM1:35
      .= 0.L + q.b9 by A5,A4,POLYNOM1:def 9
      .= q.b9 by RLVECT_1:def 7;
  end;
  set sq = SgmX(BagOrder n, Support q), spq = SgmX(BagOrder n, Support (p+q));
A6: b is Element of Bags n by PRE_POLY:def 12;
A7: Support(p+q) c= Support p \/ Support q by POLYNOM1:79;
  consider yq being FinSequence of the carrier of L such that
A8: len yq = len sq and
A9: eval(q,x) = Sum yq and
A10: for i being Element of NAT st 1 <= i & i <= len yq holds yq/.i = (q
  * sq)/.i * eval((sq/.i)@,x) by Def4;
  consider ypq being FinSequence of the carrier of L such that
A11: len ypq = len spq and
A12: eval(p+q,x) = Sum ypq and
A13: for i being Element of NAT st 1 <= i & i <= len ypq holds ypq/.i =
  ((p+q) * spq)/.i * eval((spq/.i)@,x) by Def4;
A14: BagOrder n linearly_orders Support q by Th20;
  now
    per cases;
    case
A15:  b in Support q;
      now
        per cases;
        case
A16:      p.b = - q.b;
A17:      for u being set holds u in Support q implies u in Support(p+q)
          \/ {b }
          proof
            let u be set;
            assume
A18:        u in Support q;
            then reconsider u as bag of n;
            per cases;
            suppose
              u = b;
              then u in {b} by TARSKI:def 1;
              hence thesis by XBOOLE_0:def 3;
            end;
            suppose
              u <> b;
              then (p+q).u = q.u by A3;
              then
A19:          (p+q).u <> 0.L by A18,POLYNOM1:def 9;
              u is Element of Bags n by PRE_POLY:def 12;
              then u in Support(p+q) by A19,POLYNOM1:def 9;
              hence thesis by XBOOLE_0:def 3;
            end;
          end;
          (p+q).b = p.b + q.b by POLYNOM1:35
            .= 0.L by A16,RLVECT_1:16;
          then
A20:      not b in Support(p+q) by POLYNOM1:def 9;
          for u being set holds u in Support(p+q) \/ {b} implies u in Support q
          proof
            let u be set;
            assume
A21:        u in Support(p+q) \/ {b};
            per cases by A21,XBOOLE_0:def 3;
            suppose
A22:          u in Support(p+q);
              then not u in {b} by A20,TARSKI:def 1;
              hence thesis by A1,A7,A22,XBOOLE_0:def 3;
            end;
            suppose
              u in {b};
              hence thesis by A15,TARSKI:def 1;
            end;
          end;
          then
A23:      Support(p+q) \/ {b} = Support q by A17,TARSKI:2;
          thus eval(p+q,x) = eval(p+q,x) + 0.L by RLVECT_1:def 7
            .= eval(p+q,x) + (q.b * eval(b,x) + -q.b * eval(b,x)) by
RLVECT_1:16
            .= (eval(p+q,x) + q.b * eval(b,x)) + -q.b * eval(b,x) by
RLVECT_1:def 6
            .= eval(q,x) + -q.b * eval(b,x) by A3,A20,A23,Lm10
            .= eval(q,x) + p.b * eval(b,x) by A16,VECTSP_1:41
            .= eval(q,x) + eval(p,x) by A1,Th21;
        end;
        case
A24:      p.b <> -q.b;
          p.b + q.b <> (-q.b) + q.b
          proof
            assume
A25:        p.b + q.b = (-q.b) + q.b;
            p.b = p.b + 0.L by RLVECT_1:def 7
              .= p.b + (q.b + -q.b) by RLVECT_1:16
              .= ((-q.b) + q.b) + -q.b by A25,RLVECT_1:def 6
              .= 0.L + -q.b by RLVECT_1:16
              .= - q.b by RLVECT_1:def 7;
            hence thesis by A24;
          end;
          then p.b + q.b <> 0.L by RLVECT_1:16;
          then
A26:      (p+q).b <> 0.L by POLYNOM1:35;
A27:      for u being set holds u in Support q implies u in Support(p+q)
          proof
            let u be set;
            assume
A28:        u in Support q;
            then reconsider u as bag of n;
            per cases;
            suppose
              u = b;
              hence thesis by A6,A26,POLYNOM1:def 9;
            end;
            suppose
              u <> b;
              then (p+q).u = q.u by A3;
              then
A29:          (p+q).u <> 0.L by A28,POLYNOM1:def 9;
              u is Element of Bags n by PRE_POLY:def 12;
              hence thesis by A29,POLYNOM1:def 9;
            end;
          end;
A30:      for u being set holds u in Support(p+q) implies u in Support q
          proof
            let u be set;
            assume
A31:        u in Support(p+q);
            then reconsider u as bag of n;
            per cases by A7,A31,XBOOLE_0:def 3;
            suppose
              u in Support p;
              hence thesis by A1,A15,TARSKI:def 1;
            end;
            suppose
              u in Support q;
              hence thesis;
            end;
          end;
          then
A32:      Support(p+q) = Support q by A27,TARSKI:2;
A33:      len ypq = len yq by A11,A8,A30,A27,TARSKI:2;
          consider spqk being Nat such that
A34:      dom spq = Seg spqk by FINSEQ_1:def 2;
          b in rng sq by A14,A15,PRE_POLY:def 2;
          then consider k being Nat such that
A35:      k in dom sq and
A36:      sq.k = b by FINSEQ_2:11;
          consider sqk being Nat such that
A37:      dom sq = Seg sqk by FINSEQ_1:def 2;
          reconsider k as Element of NAT by ORDINAL1:def 13;
          reconsider k,sqk,spqk as Element of NAT by ORDINAL1:def 13;
A38:      1 <= k by A35,A37,FINSEQ_1:3;
A39:      dom(p+q) = Bags n by FUNCT_2:def 1;
          then sq.k in dom(p+q) by A36,PRE_POLY:def 12;
          then
A40:      k in dom((p+q) * sq) by A35,FUNCT_1:21;
          then
A41:      ((p+q) * sq)/.k = ((p+q) * sq).k by PARTFUN1:def 8
            .= (p+q).b by A36,A40,FUNCT_1:22;
A42:      k <= sqk by A35,A37,FINSEQ_1:3;
A43:      dom q = Bags n by FUNCT_2:def 1;
          then sq.k in dom q by A36,PRE_POLY:def 12;
          then
A44:      k in dom(q * sq) by A35,FUNCT_1:21;
          then
A45:      (q * sq)/.k = (q * sq).k by PARTFUN1:def 8
            .= q.b by A36,A44,FUNCT_1:22;
          consider i being Nat such that
A46:      dom yq = Seg i by FINSEQ_1:def 2;
A47:      sqk = len sq by A37,FINSEQ_1:def 3
            .= len spq by A30,A27,TARSKI:2
            .= spqk by A34,FINSEQ_1:def 3;
A48:      i in NAT by ORDINAL1:def 13;
          then
A49:      len yq = i by A46,FINSEQ_1:def 3;
A50:      for i9 being Element of NAT st i9 in dom yq & i9 <> k holds ypq
          /.i9 = yq/.i9
          proof
            let i9 be Element of NAT;
            assume that
A51:        i9 in dom yq and
A52:        i9 <> k;
A53:        1 <= i9 by A46,A51,FINSEQ_1:3;
            i9 in Seg(len spq) by A11,A33,A51,FINSEQ_1:def 3;
            then
A54:        i9 in dom spq by FINSEQ_1:def 3;
            then spq/.i9 = spq.i9 by PARTFUN1:def 8;
            then
A55:        i9 in dom((p+q) * spq) by A39,A54,FUNCT_1:21;
            then
A56:        ((p+q) * spq)/.i9 = ((p+q) * spq).i9 by PARTFUN1:def 8
              .= (p+q).(spq.i9) by A55,FUNCT_1:22
              .= (p+q).(spq/.i9) by A54,PARTFUN1:def 8;
A57:        spq/.i9 <> b
            proof
              assume spq/.i9 = b;
              then
A58:          spq.i9 = b by A54,PARTFUN1:def 8;
A59:          spq is one-to-one by Th20,PRE_POLY:10;
              spq.k = b by A30,A27,A36,TARSKI:2;
              hence thesis by A35,A37,A34,A47,A52,A54,A58,A59,FUNCT_1:def 8;
            end;
A60:        i9 in dom sq by A8,A46,A49,A51,FINSEQ_1:def 3;
            sq/.i9 = sq.i9 by A37,A34,A47,A54,PARTFUN1:def 8;
            then
A61:        i9 in dom(q * sq) by A43,A60,FUNCT_1:21;
            then
A62:        (q * sq)/.i9 = (q * sq).i9 by PARTFUN1:def 8
              .= q.(sq.i9) by A61,FUNCT_1:22
              .= q.(sq/.i9) by A60,PARTFUN1:def 8;
A63:        i9 <= len yq by A46,A49,A51,FINSEQ_1:3;
            hence ypq/.i9 = ((p+q) * spq)/.i9 * eval((spq/.i9)@,x) by A13,A33
,A53
              .= q.(sq/.i9) * eval((sq/.i9)@,x) by A3,A32,A57,A56
              .= yq/.i9 by A10,A53,A63,A62;
          end;
A64:      sq/.k = b by A35,A36,PARTFUN1:def 8;
A65:      sqk = len yq by A8,A37,FINSEQ_1:def 3;
          then k <= i by A42,A46,A48,FINSEQ_1:def 3;
          then
A66:      k in dom yq by A38,A46,FINSEQ_1:3;
          len ypq = sqk by A11,A34,A47,FINSEQ_1:def 3;
          then ypq/.k = ((p+q) * spq)/.k * eval((spq/.k)@,x) by A13,A38,A42
            .= (p.b + q.b) * eval(b,x) by A32,A64,A41,POLYNOM1:35
            .= p.b * eval(b,x) + (q * sq)/.k * eval((sq/.k)@,x) by A64,A45,
VECTSP_1:def 18
            .= p.b * eval(b,x) + yq/.k by A10,A38,A42,A65;
          hence eval(p+q,x) = p.b * eval(b,x) + Sum yq by A12,A33,A66,A50,Th7
            .= eval(p,x) + eval(q,x) by A1,A9,Th21;
        end;
      end;
      hence thesis;
    end;
    case
A67:  not b in Support q;
A68:  (p+q).b = p.b + q.b by POLYNOM1:35
        .= p.b + 0.L by A6,A67,POLYNOM1:def 9
        .= p.b by RLVECT_1:def 7;
A69:  for u being set holds u in Support p \/ Support q implies u in
      Support(p+q)
      proof
        let u be set;
        assume
A70:    u in Support p \/ Support q;
        per cases by A70,XBOOLE_0:def 3;
        suppose
          u in Support p;
          then u = b by A1,TARSKI:def 1;
          hence thesis by A6,A2,A68,POLYNOM1:def 9;
        end;
        suppose
A71:      u in Support q;
          then reconsider u as bag of n;
A72:      q.u <> 0.L by A71,POLYNOM1:def 9;
          (p+q).u = q.u by A3,A67,A71;
          hence thesis by A71,A72,POLYNOM1:def 9;
        end;
      end;
      for u being set holds u in Support(p+q) implies u in Support p \/
      Support q by A7;
      then Support(p+q) = {b} \/ Support q by A1,A69,TARSKI:2;
      hence eval(p+q,x) = eval(q,x) + (p+q).b * eval(b,x) by A3,A67,Lm10
        .= eval(q,x) + eval(p,x) by A1,A68,Th21;
    end;
  end;
  hence thesis;
end;

theorem Th25:
  for n being Ordinal, L being right_zeroed add-associative
  right_complementable Abelian well-unital distributive non trivial (non empty
  doubleLoopStr), p,q being Polynomial of n,L, x being Function of n, L holds
  eval(p+q,x) = eval(p,x) + eval(q,x)
proof
  let n be Ordinal, L be right_zeroed add-associative right_complementable
Abelian well-unital distributive non trivial (non empty doubleLoopStr), p,q be
  Polynomial of n,L, x be Function of n, L;
  defpred P[Element of NAT] means for p being Polynomial of n,L st card(
  Support p) = $1 holds eval(p+q,x) = eval(p,x) + eval(q,x);
A1: ex k being Element of NAT st card(Support p) = k;
A2: for k being Element of NAT st P[k] holds P[k + 1]
  proof
    let k be Element of NAT;
    assume
A3: P[k];
    let p be Polynomial of n,L;
    assume
A4: card(Support p) = k + 1;
    set sgp = SgmX(BagOrder n, Support p);
    set bg = sgp/.(len sgp);
A5: BagOrder n linearly_orders Support p by Th20;
    then sgp <> {} by A4,CARD_1:47,PRE_POLY:def 2,RELAT_1:60;
    then 1 <= len sgp by NAT_1:14;
    then len sgp in Seg(len sgp) by FINSEQ_1:3;
    then
A6: len sgp in dom sgp by FINSEQ_1:def 3;
    then sgp/.(len sgp) = sgp.(len sgp) by PARTFUN1:def 8;
    then bg in rng sgp by A6,FUNCT_1:def 5;
    then
A7: bg in Support p by A5,PRE_POLY:def 2;
    then
A8: p.bg <> 0.L by POLYNOM1:def 9;
    set m = 0_(n,L)+*(bg,p.bg);
    set p9 = p+*(bg,0.L);
    reconsider bg as bag of n;
    dom p = Bags n by FUNCT_2:def 1;
    then
A9: p9 = p+*(bg.-->0.L) by FUNCT_7:def 3;
    reconsider p9 as Function of Bags n,the carrier of L;
    reconsider p9 as Function of Bags n,L;
    for u being set holds u in Support p9 implies u in Support p
    proof
      let u be set;
      assume
A10:  u in Support p9;
      then reconsider u as Element of Bags n;
      reconsider u as bag of n;
      now
        assume
A11:    u = bg;
        then u in {bg} by TARSKI:def 1;
        then u in dom(bg.-->0.L) by FUNCOP_1:19;
        then p9.u = (bg.-->0.L).bg by A9,A11,FUNCT_4:14;
        then p9.u = 0.L by FUNCOP_1:87;
        hence contradiction by A10,POLYNOM1:def 9;
      end;
      then not u in {bg} by TARSKI:def 1;
      then not u in dom(bg.-->0.L) by FUNCOP_1:19;
      then p.u = p9.u by A9,FUNCT_4:12;
      then p.u <> 0.L by A10,POLYNOM1:def 9;
      hence thesis by POLYNOM1:def 9;
    end;
    then Support p9 c= Support p by TARSKI:def 3;
    then reconsider p9 as Polynomial of n,L by POLYNOM1:def 10;
A12: dom p = Bags n by FUNCT_2:def 1;
A13: for u being set holds u in Support p implies u in Support p9 \/ {bg}
    proof
      let u be set;
      assume
A14:  u in Support p;
      then reconsider u as Element of Bags n;
A15:  p.u <> 0.L by A14,POLYNOM1:def 9;
      per cases;
      suppose
        u = bg;
        then u in {bg} by TARSKI:def 1;
        hence thesis by XBOOLE_0:def 3;
      end;
      suppose
        u <> bg;
        then not u in {bg} by TARSKI:def 1;
        then not u in dom(bg.-->0.L) by FUNCOP_1:19;
        then p9.u = p.u by A9,FUNCT_4:12;
        then u in Support p9 by A15,POLYNOM1:def 9;
        hence thesis by XBOOLE_0:def 3;
      end;
    end;
    bg in {bg} by TARSKI:def 1;
    then bg in dom(bg.-->0.L) by FUNCOP_1:19;
    then p9.bg = (bg.-->0.L).bg by A9,FUNCT_4:14;
    then
A16: p9.bg = 0.L by FUNCOP_1:87;
    then
A17: not bg in Support p9 by POLYNOM1:def 9;
    for u being set holds u in Support p9 \/ {bg} implies u in Support p
    proof
      let u be set;
      assume
A18:  u in Support p9 \/ {bg};
      per cases by A18,XBOOLE_0:def 3;
      suppose
A19:    u in Support p9;
        then reconsider u as Element of Bags n;
        u <> bg by A16,A19,POLYNOM1:def 9;
        then not u in {bg} by TARSKI:def 1;
        then not u in dom(bg.-->0.L) by FUNCOP_1:19;
        then
A20:    p9.u = p.u by A9,FUNCT_4:12;
        p9.u <> 0.L by A19,POLYNOM1:def 9;
        hence thesis by A20,POLYNOM1:def 9;
      end;
      suppose
        u in {bg};
        hence thesis by A7,TARSKI:def 1;
      end;
    end;
    then Support p = Support p9 \/ {bg} by A13,TARSKI:2;
    then
A21: k + 1 = card(Support p9) + 1 by A4,A17,CARD_2:54;
    dom 0_(n,L) = Bags n by FUNCT_2:def 1;
    then
A22: m = 0_(n,L)+*(bg.-->p.bg) by FUNCT_7:def 3;
    reconsider m as Function of Bags n,the carrier of L;
    reconsider m as Function of Bags n,L;
A23: for u being set holds u in Support m implies u in {bg}
    proof
      let u be set;
      assume
A24:  u in Support m;
      then reconsider u as Element of Bags n;
A25:  m.u <> 0.L by A24,POLYNOM1:def 9;
      now
        assume u <> bg;
        then not u in {bg} by TARSKI:def 1;
        then not u in dom(bg.-->p.bg) by FUNCOP_1:19;
        then m.u = 0_(n,L).u by A22,FUNCT_4:12;
        hence contradiction by A25,POLYNOM1:81;
      end;
      hence thesis by TARSKI:def 1;
    end;
    for u being set holds u in {bg} implies u in Support m
    proof
      let u be set;
      bg in {bg} by TARSKI:def 1;
      then bg in dom(bg.-->p.bg) by FUNCOP_1:19;
      then m.bg = (bg.-->p.bg).bg by A22,FUNCT_4:14;
      then
A26:  m.bg = p.bg by FUNCOP_1:87;
      assume u in {bg};
      then u = bg by TARSKI:def 1;
      hence thesis by A8,A26,POLYNOM1:def 9;
    end;
    then
A27: Support m = {bg} by A23,TARSKI:2;
    then reconsider m as Polynomial of n,L by POLYNOM1:def 10;
    reconsider m as Polynomial of n,L;
A28: for u being set st u in Bags n holds (p9+m).u = p.u
    proof
      let u be set;
      assume u in Bags n;
      then reconsider u as bag of n;
      per cases;
      suppose
A29:    u = bg;
        bg in {bg} by TARSKI:def 1;
        then bg in dom(bg.-->p.bg) by FUNCOP_1:19;
        then m.bg = (bg.-->p.bg).bg by A22,FUNCT_4:14;
        then
A30:    m.bg = p.bg by FUNCOP_1:87;
        u in {bg} by A29,TARSKI:def 1;
        then u in dom(bg.-->0.L) by FUNCOP_1:19;
        then
A31:    p9.u = (bg.-->0.L).bg by A9,A29,FUNCT_4:14;
        (p9+m).u = p9.u + m.u by POLYNOM1:35
          .= 0.L + p.bg by A29,A31,A30,FUNCOP_1:87
          .= p.bg by RLVECT_1:def 7;
        hence thesis by A29;
      end;
      suppose
        u <> bg;
        then
A32:    not u in {bg} by TARSKI:def 1;
        then
A33:    not u in dom(bg.-->0.L) by FUNCOP_1:19;
        not u in dom(bg.-->p.bg) by A32,FUNCOP_1:19;
        then m.u = 0_(n,L).u by A22,FUNCT_4:12;
        then
A34:    m.u = 0.L by POLYNOM1:81;
        (p9+m).u = p9.u + m.u by POLYNOM1:35
          .= p.u + 0.L by A9,A33,A34,FUNCT_4:12
          .= p.u by RLVECT_1:def 7;
        hence thesis;
      end;
    end;
A35: dom(p9 + m) = Bags n by FUNCT_2:def 1;
    then eval(p,x) = eval(m+p9,x) by A12,A28,FUNCT_1:9
      .= eval(p9,x) + eval(m,x) by A27,Lm11;
    hence eval(p,x) + eval(q,x) = (eval(p9,x) + eval(q,x)) + eval(m,x) by
RLVECT_1:def 6
      .= eval(p9+q,x) + eval(m,x) by A3,A21
      .= eval(m+(p9+q),x) by A27,Lm11
      .= eval((p9+m)+q,x) by POLYNOM1:80
      .= eval(p+q,x) by A35,A12,A28,FUNCT_1:9;
  end;
A36: P[0]
  proof
    let p be Polynomial of n,L;
    assume card(Support p) = 0;
    then Support p = {};
    then
A37: p = 0_(n,L) by Th19;
    hence eval(p+q,x) = eval(q,x) by POLYNOM1:82
      .= 0.L + eval(q,x) by RLVECT_1:10
      .= eval(p,x) + eval(q,x) by A37,Th22;
  end;
  for k being Element of NAT holds P[k] from NAT_1:sch 1(A36,A2);
  hence thesis by A1;
end;

theorem
  for n being Ordinal, L being right_zeroed add-associative
  right_complementable Abelian well-unital distributive non trivial (non empty
  doubleLoopStr), p,q being Polynomial of n,L, x being Function of n, L holds
  eval(p-q,x) = eval(p,x) - eval(q,x)
proof
  let n be Ordinal, L be right_zeroed add-associative right_complementable
Abelian well-unital distributive non trivial (non empty doubleLoopStr), p,q be
  Polynomial of n,L, x be Function of n, L;
  thus eval(p-q,x) = eval(p + -q,x) by POLYNOM1:def 23
    .= eval(p,x) + eval(-q,x) by Th25
    .= eval(p,x) + -eval(q,x) by Th24
    .= eval(p,x) - eval(q,x);
end;

Lm12: for n being Ordinal, L being right_zeroed add-associative
right_complementable Abelian well-unital distributive non trivial commutative
associative (non empty doubleLoopStr), p,q being Polynomial of n,L, b1, b2
being bag of n st Support p = {b1} & Support q = {b2} for x being Function of n
, L holds eval(p*'q,x) = eval(p,x) * eval(q,x)
proof
  let n be Ordinal, L be right_zeroed add-associative right_complementable
Abelian well-unital distributive non trivial commutative associative (non empty
  doubleLoopStr), p,q be Polynomial of n,L, b1, b2 be bag of n;
  assume that
A1: Support p = {b1} and
A2: Support q = {b2};
  consider s being FinSequence of the carrier of L such that
A3: (p*'q).(b1+b2) = Sum s and
A4: len s = len decomp(b1+b2) and
A5: for k being Element of NAT st k in dom s ex u1,u2 being bag of n st
  (decomp(b1+b2))/.k = <*u1,u2*> & s/.k = p.u1 * q.u2 by POLYNOM1:def 26;
A6: b1+b2 is Element of Bags n by PRE_POLY:def 12;
  let x be Function of n, L;
A7: (p.b1 * q.b2) * (eval(b1,x) * eval(b2,x)) = ((p.b1 * q.b2) * eval(b1,x)
  ) * eval(b2,x) by GROUP_1:def 4
    .= ((p.b1 * eval(b1,x)) * q.b2) * eval(b2,x) by GROUP_1:def 4
    .= (p.b1 * eval(b1,x)) * (q.b2 * eval(b2,x)) by GROUP_1:def 4
    .= eval(p,x) * (q.b2 * eval(b2,x)) by A1,Th21
    .= eval(p,x) * eval(q,x) by A2,Th21;
A8: for b being bag of n st b <> b2 holds q.b = 0.L
  proof
    let b be bag of n;
    assume b <> b2;
    then
A9: not b in Support q by A2,TARSKI:def 1;
    b is Element of Bags n by PRE_POLY:def 12;
    hence thesis by A9,POLYNOM1:def 9;
  end;
A10: for b being bag of n st b <> b1 holds p.b = 0.L
  proof
    let b be bag of n;
    assume b <> b1;
    then
A11: not b in Support p by A1,TARSKI:def 1;
    b is Element of Bags n by PRE_POLY:def 12;
    hence thesis by A11,POLYNOM1:def 9;
  end;
A12: for u being set holds u in Support(p*'q) implies u in {b1+b2}
  proof
    let u be set;
    assume
A13: u in Support(p*'q);
    assume
A14: not u in {b1+b2};
    reconsider u as bag of n by A13;
    consider t being FinSequence of the carrier of L such that
A15: (p*'q).u = Sum t and
A16: len t = len decomp u and
A17: for k being Element of NAT st k in dom t ex b19,b29 being bag of
    n st (decomp u)/.k = <*b19,b29*> & t/.k = p.b19 * q.b29 by POLYNOM1:def 26;
    1 <= len t by A16,NAT_1:14;
    then
A18: 1 in dom t by FINSEQ_3:27;
A19: dom t = Seg len t by FINSEQ_1:def 3
      .= dom decomp u by A16,FINSEQ_1:def 3;
A20: for i being Element of NAT st i in dom t holds t/.i = 0.L
    proof
      let i be Element of NAT;
      consider S being non empty finite Subset of Bags n such that
A21:  divisors u = SgmX(BagOrder n, S) and
A22:  for b being bag of n holds b in S iff b divides u by PRE_POLY:def 16;
      BagOrder n linearly_orders S by Lm3;
      then
A23:  S = rng(divisors u) by A21,PRE_POLY:def 2;
      assume
A24:  i in dom t;
      then consider b19,b29 being bag of n such that
A25:  (decomp u)/.i = <*b19,b29*> and
A26:  t/.i = p.b19 * q.b29 by A17;
A27:  b19 = (divisors u)/.i by A19,A24,A25,PRE_POLY:70;
A28:  i in dom(divisors u) by A19,A24,PRE_POLY:def 17;
      then b19 = (divisors u).i by A27,PARTFUN1:def 8;
      then b19 in rng(divisors u) by A28,FUNCT_1:def 5;
      then
A29:  b19 divides u by A22,A23;
      per cases;
      suppose
A30:    b19 = b1 & b29 = b2;
        b2 = <*b1,b2*>.2 by FINSEQ_1:61
          .= <*b1,u-'b1*>.2 by A19,A24,A25,A27,A30,PRE_POLY:def 17
          .= u-'b1 by FINSEQ_1:61;
        then b1 + b2 = u by A29,A30,PRE_POLY:47;
        hence thesis by A14,TARSKI:def 1;
      end;
      suppose
        b19 <> b1;
        then p.b19 = 0.L by A10;
        hence thesis by A26,VECTSP_1:39;
      end;
      suppose
        b29 <> b2;
        then q.b29 = 0.L by A8;
        hence thesis by A26,VECTSP_1:39;
      end;
    end;
    then for i being Element of NAT st i in dom t & i <> 1 holds t/.i = 0.L;
    then Sum t = t/.1 by A18,Th5
      .= 0.L by A18,A20;
    hence thesis by A13,A15,POLYNOM1:def 9;
  end;
  consider k being Element of NAT such that
A31: k in dom decomp(b1+b2) and
A32: (decomp(b1+b2))/.k = <*b1,b2*> by PRE_POLY:69;
A33: dom s = Seg(len s) by FINSEQ_1:def 3
    .= dom decomp(b1+b2) by A4,FINSEQ_1:def 3;
  then consider b19,b29 being bag of n such that
A34: (decomp(b1+b2))/.k = <*b19,b29*> and
A35: s/.k = p.b19 * q.b29 by A5,A31;
A36: b2 = <*b1,b2*>.2 by FINSEQ_1:61
    .= b29 by A32,A34,FINSEQ_1:61;
A37: for k9 being Element of NAT st k9 in dom s & k9 <> k holds s/.k9 = 0.L
  proof
    let k9 be Element of NAT;
    assume that
A38: k9 in dom s and
A39: k9 <> k;
    consider b19,b29 being bag of n such that
A40: (decomp(b1+b2))/.k9 = <*b19,b29*> and
A41: s/.k9 = p.b19 * q.b29 by A5,A38;
    per cases;
    suppose
A42:  b19 = b1 & b29 = b2;
      (decomp(b1+b2)).k9 = (decomp(b1+b2))/.k9 by A33,A38,PARTFUN1:def 8
        .= (decomp(b1+b2)).k by A31,A32,A40,A42,PARTFUN1:def 8;
      hence thesis by A33,A31,A38,A39,FUNCT_1:def 8;
    end;
    suppose
      b19 <> b1;
      then p.b19 = 0.L by A10;
      hence thesis by A41,VECTSP_1:39;
    end;
    suppose
      b29 <> b2;
      then q.b29 = 0.L by A8;
      hence thesis by A41,VECTSP_1:39;
    end;
  end;
  b1 = <*b19,b29*>.1 by A32,A34,FINSEQ_1:61
    .= b19 by FINSEQ_1:61;
  then
A43: (p*'q).(b1+b2) = p.b1 * q.b2 by A3,A33,A31,A35,A36,A37,Th5;
  per cases;
  suppose
A44: p.b1 * q.b2 = 0.L;
    then
A45: not b1+b2 in Support(p*'q) by A43,POLYNOM1:def 9;
    Support(p*'q) = {}
    proof
      set u =the  Element of Support(p*'q);
      assume
A46:  Support(p*'q) <> {};
      then
A47:  u in Support(p*'q);
      u in {b1+b2} by A12,A46;
      hence thesis by A45,A47,TARSKI:def 1;
    end;
    then p*'q = 0_(n,L) by Th19;
    hence eval(p*'q,x) = 0.L by Th22
      .= eval(p,x) * eval(q,x) by A7,A44,VECTSP_1:39;
  end;
  suppose
    p.b1 * q.b2 <> 0.L;
    then b1+b2 in Support(p*'q) by A43,A6,POLYNOM1:def 9;
    then for u being set holds u in {b1+b2} implies u in Support(p*'q) by
TARSKI:def 1;
    then Support(p*'q) = {b1+b2} by A12,TARSKI:2;
    hence eval(p*'q,x) = (p*'q).(b1+b2) * eval(b1+b2,x) by Th21
      .= eval(p,x) * eval(q,x) by A43,A7,Th18;
  end;
end;

Lm13: for n being Ordinal, L being right_zeroed add-associative
right_complementable Abelian well-unital distributive non trivial commutative
associative (non empty doubleLoopStr), q being Polynomial of n,L st ex b being
bag of n st Support q = {b} for p being Polynomial of n,L, x being Function of
n, L holds eval(p*'q,x) = eval(p,x) * eval(q,x)
proof
  let n be Ordinal, L be right_zeroed add-associative right_complementable
Abelian well-unital distributive non trivial commutative associative (non empty
  doubleLoopStr), q be Polynomial of n,L;
  given b being bag of n such that
A1: Support q = {b};
  let p be Polynomial of n,L;
  let x be Function of n, L;
  defpred P[Element of NAT] means for p being Polynomial of n,L st card(
  Support p) = $1 holds eval(p*'q,x) = eval(p,x) * eval(q,x);
A2: for k being Element of NAT st P[k] holds P[k + 1]
  proof
    let k be Element of NAT;
    assume
A3: P[k];
    let p be Polynomial of n,L;
    assume
A4: card(Support p) = k + 1;
    set sgp = SgmX(BagOrder n, Support p);
    set bg = sgp/.(len sgp);
A5: BagOrder n linearly_orders Support p by Th20;
    then sgp <> {} by A4,CARD_1:47,PRE_POLY:def 2,RELAT_1:60;
    then 1 <= len sgp by NAT_1:14;
    then len sgp in Seg(len sgp) by FINSEQ_1:3;
    then
A6: len sgp in dom sgp by FINSEQ_1:def 3;
    then sgp/.(len sgp) = sgp.(len sgp) by PARTFUN1:def 8;
    then bg in rng sgp by A6,FUNCT_1:def 5;
    then
A7: bg in Support p by A5,PRE_POLY:def 2;
    then
A8: p.bg <> 0.L by POLYNOM1:def 9;
    set m = 0_(n,L)+*(bg,p.bg);
    set p9 = p+*(bg,0.L);
    reconsider bg as bag of n;
    dom p = Bags n by FUNCT_2:def 1;
    then
A9: p9 = p+*(bg.-->0.L) by FUNCT_7:def 3;
    reconsider p9 as Function of Bags n,the carrier of L;
    reconsider p9 as Function of Bags n,L;
    for u being set holds u in Support p9 implies u in Support p
    proof
      let u be set;
      assume
A10:  u in Support p9;
      then reconsider u as Element of Bags n;
      reconsider u as bag of n;
      now
        assume
A11:    u = bg;
        then u in {bg} by TARSKI:def 1;
        then u in dom(bg.-->0.L) by FUNCOP_1:19;
        then p9.u = (bg.-->0.L).bg by A9,A11,FUNCT_4:14;
        then p9.u = 0.L by FUNCOP_1:87;
        hence contradiction by A10,POLYNOM1:def 9;
      end;
      then not u in {bg} by TARSKI:def 1;
      then not u in dom(bg.-->0.L) by FUNCOP_1:19;
      then p.u = p9.u by A9,FUNCT_4:12;
      then p.u <> 0.L by A10,POLYNOM1:def 9;
      hence thesis by POLYNOM1:def 9;
    end;
    then Support p9 c= Support p by TARSKI:def 3;
    then reconsider p9 as Polynomial of n,L by POLYNOM1:def 10;
A12: dom p = Bags n by FUNCT_2:def 1;
A13: for u being set holds u in Support p implies u in Support p9 \/ {bg}
    proof
      let u be set;
      assume
A14:  u in Support p;
      then reconsider u as Element of Bags n;
A15:  p.u <> 0.L by A14,POLYNOM1:def 9;
      per cases;
      suppose
        u = bg;
        then u in {bg} by TARSKI:def 1;
        hence thesis by XBOOLE_0:def 3;
      end;
      suppose
        u <> bg;
        then not u in {bg} by TARSKI:def 1;
        then not u in dom(bg.-->0.L) by FUNCOP_1:19;
        then p9.u = p.u by A9,FUNCT_4:12;
        then u in Support p9 by A15,POLYNOM1:def 9;
        hence thesis by XBOOLE_0:def 3;
      end;
    end;
    bg in {bg} by TARSKI:def 1;
    then bg in dom(bg.-->0.L) by FUNCOP_1:19;
    then p9.bg = (bg.-->0.L).bg by A9,FUNCT_4:14;
    then
A16: p9.bg = 0.L by FUNCOP_1:87;
    then
A17: not bg in Support p9 by POLYNOM1:def 9;
    for u being set holds u in Support p9 \/ {bg} implies u in Support p
    proof
      let u be set;
      assume
A18:  u in Support p9 \/ {bg};
      per cases by A18,XBOOLE_0:def 3;
      suppose
A19:    u in Support p9;
        then reconsider u as Element of Bags n;
        u <> bg by A16,A19,POLYNOM1:def 9;
        then not u in {bg} by TARSKI:def 1;
        then not u in dom(bg.-->0.L) by FUNCOP_1:19;
        then
A20:    p9.u = p.u by A9,FUNCT_4:12;
        p9.u <> 0.L by A19,POLYNOM1:def 9;
        hence thesis by A20,POLYNOM1:def 9;
      end;
      suppose
        u in {bg};
        hence thesis by A7,TARSKI:def 1;
      end;
    end;
    then Support p = Support p9 \/ {bg} by A13,TARSKI:2;
    then
A21: k + 1 = card(Support p9) + 1 by A4,A17,CARD_2:54;
    dom 0_(n,L) = Bags n by FUNCT_2:def 1;
    then
A22: m = 0_(n,L)+*(bg.-->p.bg) by FUNCT_7:def 3;
    reconsider m as Function of Bags n,the carrier of L;
    reconsider m as Function of Bags n,L;
A23: for u being set holds u in Support m implies u in {bg}
    proof
      let u be set;
      assume
A24:  u in Support m;
      then reconsider u as Element of Bags n;
A25:  m.u <> 0.L by A24,POLYNOM1:def 9;
      now
        assume u <> bg;
        then not u in {bg} by TARSKI:def 1;
        then not u in dom(bg.-->p.bg) by FUNCOP_1:19;
        then m.u = 0_(n,L).u by A22,FUNCT_4:12;
        hence contradiction by A25,POLYNOM1:81;
      end;
      hence thesis by TARSKI:def 1;
    end;
    for u being set holds u in {bg} implies u in Support m
    proof
      let u be set;
      bg in {bg} by TARSKI:def 1;
      then bg in dom(bg.-->p.bg) by FUNCOP_1:19;
      then m.bg = (bg.-->p.bg).bg by A22,FUNCT_4:14;
      then
A26:  m.bg = p.bg by FUNCOP_1:87;
      assume u in {bg};
      then u = bg by TARSKI:def 1;
      hence thesis by A8,A26,POLYNOM1:def 9;
    end;
    then
A27: Support m = {bg} by A23,TARSKI:2;
    then reconsider m as Polynomial of n,L by POLYNOM1:def 10;
    reconsider m as Polynomial of n,L;
A28: for u being set st u in Bags n holds (p9+m).u = p.u
    proof
      let u be set;
      assume u in Bags n;
      then reconsider u as bag of n;
      per cases;
      suppose
A29:    u = bg;
        bg in {bg} by TARSKI:def 1;
        then bg in dom(bg.-->p.bg) by FUNCOP_1:19;
        then m.bg = (bg.-->p.bg).bg by A22,FUNCT_4:14;
        then
A30:    m.bg = p.bg by FUNCOP_1:87;
        u in {bg} by A29,TARSKI:def 1;
        then u in dom(bg.-->0.L) by FUNCOP_1:19;
        then
A31:    p9.u = (bg.-->0.L).bg by A9,A29,FUNCT_4:14;
        (p9+m).u = p9.u + m.u by POLYNOM1:35
          .= 0.L + p.bg by A29,A31,A30,FUNCOP_1:87
          .= p.bg by RLVECT_1:def 7;
        hence thesis by A29;
      end;
      suppose
        u <> bg;
        then
A32:    not u in {bg} by TARSKI:def 1;
        then
A33:    not u in dom(bg.-->0.L) by FUNCOP_1:19;
        not u in dom(bg.-->p.bg) by A32,FUNCOP_1:19;
        then m.u = 0_(n,L).u by A22,FUNCT_4:12;
        then
A34:    m.u = 0.L by POLYNOM1:81;
        (p9+m).u = p9.u + m.u by POLYNOM1:35
          .= p.u + 0.L by A9,A33,A34,FUNCT_4:12
          .= p.u by RLVECT_1:def 7;
        hence thesis;
      end;
    end;
A35: dom(p9 + m) = Bags n by FUNCT_2:def 1;
    then eval(p,x) = eval(m+p9,x) by A12,A28,FUNCT_1:9
      .= eval(p9,x) + eval(m,x) by A27,Lm11;
    hence
    eval(p,x) * eval(q,x) = eval(p9,x)*eval(q,x) + eval(m,x)*eval(q,x) by
VECTSP_1:def 18
      .= eval(p9*'q,x) + eval(m,x)*eval(q,x) by A3,A21
      .= eval(p9*'q,x)+eval(m*'q,x) by A1,A27,Lm12
      .= eval(p9*'q+m*'q,x) by Th25
      .= eval(q*'(p9+m),x) by POLYNOM1:85
      .= eval(p*'q,x) by A35,A12,A28,FUNCT_1:9;
  end;
A36: ex k being Element of NAT st card(Support p) = k;
A37: P[0]
  proof
    let p be Polynomial of n,L;
    assume card(Support p) = 0;
    then Support p ={};
    then
A38: p = 0_(n,L) by Th19;
    hence eval(p*'q,x) = eval(p,x) by POLYNOM1:87
      .= 0.L by A38,Th22
      .= 0.L * eval(q,x) by VECTSP_1:39
      .= eval(p,x) * eval(q,x) by A38,Th22;
  end;
  for k being Element of NAT holds P[k] from NAT_1:sch 1(A37,A2);
  hence thesis by A36;
end;

theorem Th27:
  for n being Ordinal, L being right_zeroed add-associative
  right_complementable Abelian well-unital distributive non trivial commutative
  associative (non empty doubleLoopStr), p,q being Polynomial of n,L, x being
  Function of n, L holds eval(p*'q,x) = eval(p,x) * eval(q,x)
proof
  let n be Ordinal, L be right_zeroed add-associative right_complementable
Abelian well-unital distributive non trivial commutative associative (non empty
  doubleLoopStr), p,q be Polynomial of n,L, x be Function of n, L;
  defpred P[Element of NAT] means for p being Polynomial of n,L st card(
  Support p) = $1 holds eval(p*'q,x) = eval(p,x) * eval(q,x);
A1: ex k being Element of NAT st card(Support p) = k;
A2: for k being Element of NAT st P[k] holds P[k + 1]
  proof
    let k be Element of NAT;
    assume
A3: P[k];
    let p be Polynomial of n,L;
    assume
A4: card(Support p) = k + 1;
    set sgp = SgmX(BagOrder n, Support p);
    set bg = sgp/.(len sgp);
A5: BagOrder n linearly_orders Support p by Th20;
    then sgp <> {} by A4,CARD_1:47,PRE_POLY:def 2,RELAT_1:60;
    then 1 <= len sgp by NAT_1:14;
    then len sgp in Seg(len sgp) by FINSEQ_1:3;
    then
A6: len sgp in dom sgp by FINSEQ_1:def 3;
    then sgp/.(len sgp) = sgp.(len sgp) by PARTFUN1:def 8;
    then bg in rng sgp by A6,FUNCT_1:def 5;
    then
A7: bg in Support p by A5,PRE_POLY:def 2;
    then
A8: p.bg <> 0.L by POLYNOM1:def 9;
    set m = 0_(n,L)+*(bg,p.bg);
    set p9 = p+*(bg,0.L);
    reconsider bg as bag of n;
    dom p = Bags n by FUNCT_2:def 1;
    then
A9: p9 = p+*(bg.-->0.L) by FUNCT_7:def 3;
    reconsider p9 as Function of Bags n,the carrier of L;
    reconsider p9 as Function of Bags n,L;
    for u being set holds u in Support p9 implies u in Support p
    proof
      let u be set;
      assume
A10:  u in Support p9;
      then reconsider u as Element of Bags n;
      reconsider u as bag of n;
      now
        assume
A11:    u = bg;
        then u in {bg} by TARSKI:def 1;
        then u in dom(bg.-->0.L) by FUNCOP_1:19;
        then p9.u = (bg.-->0.L).bg by A9,A11,FUNCT_4:14;
        then p9.u = 0.L by FUNCOP_1:87;
        hence contradiction by A10,POLYNOM1:def 9;
      end;
      then not u in {bg} by TARSKI:def 1;
      then not u in dom(bg.-->0.L) by FUNCOP_1:19;
      then p.u = p9.u by A9,FUNCT_4:12;
      then p.u <> 0.L by A10,POLYNOM1:def 9;
      hence thesis by POLYNOM1:def 9;
    end;
    then Support p9 c= Support p by TARSKI:def 3;
    then reconsider p9 as Polynomial of n,L by POLYNOM1:def 10;
A12: dom p = Bags n by FUNCT_2:def 1;
A13: for u being set holds u in Support p implies u in Support p9 \/ {bg}
    proof
      let u be set;
      assume
A14:  u in Support p;
      then reconsider u as Element of Bags n;
A15:  p.u <> 0.L by A14,POLYNOM1:def 9;
      per cases;
      suppose
        u = bg;
        then u in {bg} by TARSKI:def 1;
        hence thesis by XBOOLE_0:def 3;
      end;
      suppose
        u <> bg;
        then not u in {bg} by TARSKI:def 1;
        then not u in dom(bg.-->0.L) by FUNCOP_1:19;
        then p9.u = p.u by A9,FUNCT_4:12;
        then u in Support p9 by A15,POLYNOM1:def 9;
        hence thesis by XBOOLE_0:def 3;
      end;
    end;
    bg in {bg} by TARSKI:def 1;
    then bg in dom(bg.-->0.L) by FUNCOP_1:19;
    then p9.bg = (bg.-->0.L).bg by A9,FUNCT_4:14;
    then
A16: p9.bg = 0.L by FUNCOP_1:87;
    then
A17: not bg in Support p9 by POLYNOM1:def 9;
    for u being set holds u in Support p9 \/ {bg} implies u in Support p
    proof
      let u be set;
      assume
A18:  u in Support p9 \/ {bg};
      per cases by A18,XBOOLE_0:def 3;
      suppose
A19:    u in Support p9;
        then reconsider u as Element of Bags n;
        u <> bg by A16,A19,POLYNOM1:def 9;
        then not u in {bg} by TARSKI:def 1;
        then not u in dom(bg.-->0.L) by FUNCOP_1:19;
        then
A20:    p9.u = p.u by A9,FUNCT_4:12;
        p9.u <> 0.L by A19,POLYNOM1:def 9;
        hence thesis by A20,POLYNOM1:def 9;
      end;
      suppose
        u in {bg};
        hence thesis by A7,TARSKI:def 1;
      end;
    end;
    then Support p = Support p9 \/ {bg} by A13,TARSKI:2;
    then
A21: k + 1 = card(Support p9) + 1 by A4,A17,CARD_2:54;
    dom 0_(n,L) = Bags n by FUNCT_2:def 1;
    then
A22: m = 0_(n,L)+*(bg.-->p.bg) by FUNCT_7:def 3;
    reconsider m as Function of Bags n,the carrier of L;
    reconsider m as Function of Bags n,L;
A23: for u being set holds u in Support m implies u in {bg}
    proof
      let u be set;
      assume
A24:  u in Support m;
      then reconsider u as Element of Bags n;
A25:  m.u <> 0.L by A24,POLYNOM1:def 9;
      now
        assume u <> bg;
        then not u in {bg} by TARSKI:def 1;
        then not u in dom(bg.-->p.bg) by FUNCOP_1:19;
        then m.u = 0_(n,L).u by A22,FUNCT_4:12;
        hence contradiction by A25,POLYNOM1:81;
      end;
      hence thesis by TARSKI:def 1;
    end;
    for u being set holds u in {bg} implies u in Support m
    proof
      let u be set;
      bg in {bg} by TARSKI:def 1;
      then bg in dom(bg.-->p.bg) by FUNCOP_1:19;
      then m.bg = (bg.-->p.bg).bg by A22,FUNCT_4:14;
      then
A26:  m.bg = p.bg by FUNCOP_1:87;
      assume u in {bg};
      then u = bg by TARSKI:def 1;
      hence thesis by A8,A26,POLYNOM1:def 9;
    end;
    then
A27: Support m = {bg} by A23,TARSKI:2;
    then reconsider m as Polynomial of n,L by POLYNOM1:def 10;
    reconsider m as Polynomial of n,L;
A28: for u being set st u in Bags n holds (p9+m).u = p.u
    proof
      let u be set;
      assume u in Bags n;
      then reconsider u as bag of n;
      per cases;
      suppose
A29:    u = bg;
        bg in {bg} by TARSKI:def 1;
        then bg in dom(bg.-->p.bg) by FUNCOP_1:19;
        then m.bg = (bg.-->p.bg).bg by A22,FUNCT_4:14;
        then
A30:    m.bg = p.bg by FUNCOP_1:87;
        u in {bg} by A29,TARSKI:def 1;
        then u in dom(bg.-->0.L) by FUNCOP_1:19;
        then
A31:    p9.u = (bg.-->0.L).bg by A9,A29,FUNCT_4:14;
        (p9+m).u = p9.u + m.u by POLYNOM1:35
          .= 0.L + p.bg by A29,A31,A30,FUNCOP_1:87
          .= p.bg by RLVECT_1:def 7;
        hence thesis by A29;
      end;
      suppose
        u <> bg;
        then
A32:    not u in {bg} by TARSKI:def 1;
        then
A33:    not u in dom(bg.-->0.L) by FUNCOP_1:19;
        not u in dom(bg.-->p.bg) by A32,FUNCOP_1:19;
        then m.u = 0_(n,L).u by A22,FUNCT_4:12;
        then
A34:    m.u = 0.L by POLYNOM1:81;
        (p9+m).u = p9.u + m.u by POLYNOM1:35
          .= p.u + 0.L by A9,A33,A34,FUNCT_4:12
          .= p.u by RLVECT_1:def 7;
        hence thesis;
      end;
    end;
A35: dom(p9 + m) = Bags n by FUNCT_2:def 1;
    then eval(p,x) = eval(m+p9,x) by A12,A28,FUNCT_1:9
      .= eval(p9,x) + eval(m,x) by A27,Lm11;
    hence
    eval(p,x) * eval(q,x) = eval(p9,x)*eval(q,x) + eval(m,x)*eval(q,x) by
VECTSP_1:def 18
      .= eval(p9*'q,x) + eval(m,x)*eval(q,x) by A3,A21
      .= eval(p9*'q,x)+eval(m*'q,x) by A27,Lm13
      .= eval(p9*'q+m*'q,x) by Th25
      .= eval(q*'(p9+m),x) by POLYNOM1:85
      .= eval(p*'q,x) by A35,A12,A28,FUNCT_1:9;
  end;
A36: P[0]
  proof
    let p be Polynomial of n,L;
    assume card(Support p) = 0;
    then Support p = {};
    then
A37: p = 0_(n,L) by Th19;
    hence eval(p*'q,x) = eval(p,x) by POLYNOM1:87
      .= 0.L by A37,Th22
      .= 0.L * eval(q,x) by VECTSP_1:39
      .= eval(p,x) * eval(q,x) by A37,Th22;
  end;
  for k being Element of NAT holds P[k] from NAT_1:sch 1(A36,A2);
  hence thesis by A1;
end;


begin :: Evaluation Homomorphism --------------------------------------------------

definition
  let n be Ordinal, L be right_zeroed add-associative right_complementable
  well-unital distributive non trivial (non empty doubleLoopStr), x be Function
  of n, L;
  func Polynom-Evaluation(n,L,x) -> Function of Polynom-Ring(n,L),L means
  :
  Def5: for p being Polynomial of n,L holds it.p = eval(p,x);
  existence
  proof
    defpred P[set,set] means ex p9 being Polynomial of n,L st p9 = $1 & $2 =
    eval(p9,x);
A1: now
      let p be set;
      assume p in the carrier of Polynom-Ring(n,L);
      then reconsider p9 = p as Polynomial of n,L by POLYNOM1:def 27;
      thus ex y being set st y in the carrier of L & P[p,y]
      proof
        take eval(p9,x);
        thus thesis;
      end;
    end;
    consider f being Function of the carrier of Polynom-Ring(n,L), the carrier
    of L such that
A2: for x being set st x in the carrier of Polynom-Ring(n,L) holds P[x
    ,f.x] from FUNCT_2:sch 1(A1);
    reconsider f as Function of Polynom-Ring(n,L),L;
    take f;
    let p be Polynomial of n,L;
    p in the carrier of Polynom-Ring(n,L) by POLYNOM1:def 27;
    then ex p9 being Polynomial of n,L st p9 = p & f.p = eval(p9,x) by A2;
    hence thesis;
  end;
  uniqueness
  proof
    let f,g be Function of Polynom-Ring(n,L), L such that
A3: for p being Polynomial of n,L holds f.p = eval(p,x) and
A4: for p being Polynomial of n,L holds g.p = eval(p,x);
    reconsider f,g as Function of the carrier of Polynom-Ring(n,L), the
    carrier of L;
A5: now
      let p be set;
      assume p in the carrier of Polynom-Ring(n,L);
      then reconsider p9 = p as Polynomial of n,L by POLYNOM1:def 27;
      f.p9 = eval(p9,x) by A3
        .= g.p9 by A4;
      hence f.p = g.p;
    end;
A6: dom g = the carrier of Polynom-Ring(n,L) by FUNCT_2:def 1;
    dom f = the carrier of Polynom-Ring(n,L) by FUNCT_2:def 1;
    hence thesis by A6,A5,FUNCT_1:9;
  end;
end;

registration
  let n be Ordinal, L be right_zeroed Abelian add-associative
  right_complementable well-unital distributive associative non trivial (non
  empty doubleLoopStr);
  cluster Polynom-Ring (n, L) -> well-unital;
  coherence;
end;

registration
  let n be Ordinal, L be Abelian right_zeroed add-associative
  right_complementable well-unital distributive associative non trivial (non
  empty doubleLoopStr), x be Function of n, L;
  cluster Polynom-Evaluation(n,L,x) -> unity-preserving;
  coherence
  proof
    set f = Polynom-Evaluation(n,L,x);
    thus f.(1_(Polynom-Ring(n,L))) = f.(1_(n,L)) by POLYNOM1:90
      .= eval(1_(n,L),x) by Def5
      .= 1_L by Th23;
  end;
end;

registration
  let n be Ordinal, L be right_zeroed add-associative right_complementable
  Abelian well-unital distributive non trivial (non empty doubleLoopStr), x be
  Function of n, L;
  cluster Polynom-Evaluation(n,L,x) -> additive;
  coherence
  proof
    set f = Polynom-Evaluation(n,L,x);
    for p,q being Element of Polynom-Ring(n,L) holds f.(p+q) = f.p + f.q
    proof
      let p,q be Element of Polynom-Ring(n,L);
      reconsider p9 = p, q9 = q as Polynomial of n,L by POLYNOM1:def 27;
      reconsider p,q as Element of Polynom-Ring(n,L);
A1:   f.p = eval(p9,x) by Def5;
      f.(p + q) = f.(p9+q9) by POLYNOM1:def 27
        .= eval(p9+q9,x) by Def5
        .= eval(p9,x) + eval(q9,x) by Th25;
      hence thesis by A1,Def5;
    end;
    hence thesis by GRCAT_1:def 13;
  end;
end;

registration
  let n be Ordinal, L be right_zeroed add-associative right_complementable
Abelian well-unital distributive non trivial commutative associative (non empty
  doubleLoopStr), x be Function of n, L;
  cluster Polynom-Evaluation(n,L,x) -> multiplicative;
  coherence
  proof
    set f = Polynom-Evaluation(n,L,x);
    for p,q being Element of Polynom-Ring(n,L) holds f.(p * q) = f.p * f.q
    proof
      let p,q be Element of Polynom-Ring(n,L);
      reconsider p9 = p, q9 = q as Polynomial of n,L by POLYNOM1:def 27;
      reconsider p,q as Element of Polynom-Ring(n,L);
A1:   f.p = eval(p9,x) by Def5;
      f.(p * q) = f.(p9*'q9) by POLYNOM1:def 27
        .= eval(p9*'q9,x) by Def5
        .= eval(p9,x) * eval(q9,x) by Th27;
      hence thesis by A1,Def5;
    end;
    hence thesis by GROUP_6:def 7;
  end;
end;

registration
  let n be Ordinal, L be right_zeroed add-associative right_complementable
Abelian well-unital distributive non trivial commutative associative (non empty
  doubleLoopStr), x be Function of n, L;
  cluster Polynom-Evaluation(n,L,x) -> RingHomomorphism;
  coherence
  proof
    thus Polynom-Evaluation(n,L,x) is additive multiplicative unity-preserving;
  end;
end;
