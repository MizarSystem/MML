:: Certain Facts about Families of Subsets of Many Sorted Sets
::  by Artur Korni{\l}owicz
::
:: Received October 27, 1995
:: Copyright (c) 1995 Association of Mizar Users

environ

 vocabularies PBOOLE, SETFAM_1, PRALG_1, FUNCT_1, BOOLE, CANTOR_1, TARSKI,
      ZF_REFLE, FUNCT_6, RELAT_1, MSUALG_3, CAT_4, NATTRA_1, MATRIX_1,
      PRE_CIRC, FINSET_1, MSUALG_2, PRALG_2, CAT_1, FUNCT_4, AUTALG_1, FUNCT_2,
      GRCAT_1, COHSP_1, MSSUBFAM, HAHNBAN, FUNCOP_1;
 notations TARSKI, XBOOLE_0, ZFMISC_1, SUBSET_1, SETFAM_1, RELAT_1, FUNCT_1,
      ORDINAL1, FUNCT_2, FUNCOP_1, FINSET_1, FUNCT_4, FUNCT_6, PBOOLE,
      PRE_CIRC, MBOOLEAN, PZFMISC1;
 constructors SETFAM_1, FUNCT_4, FUNCT_6, PRE_CIRC, MBOOLEAN, PZFMISC1;
 registrations XBOOLE_0, RELAT_1, FUNCT_1, FUNCOP_1, FINSET_1, PBOOLE,
      PRE_CIRC, MBOOLEAN, PZFMISC1;
 requirements SUBSET, BOOLE;
 definitions XBOOLE_0, PBOOLE, PRE_CIRC, ORDINAL1, FUNCOP_1;
 theorems FUNCOP_1, FINSET_1, ORDERS_1, FRAENKEL, FUNCT_2, FUNCT_4, FUNCT_6,
      MBOOLEAN, PBOOLE, PRE_CIRC, PZFMISC1, SETFAM_1, TARSKI, RELSET_1,
      RELAT_1, XBOOLE_0, XBOOLE_1;
 schemes FUNCT_2, PBOOLE;

begin :: Preliminaries

definition
  let I be set;
  let F be ManySortedFunction of I;
  redefine func doms F -> ManySortedSet of I;
  coherence
  proof
    dom doms F = dom F by FUNCT_6:89
      .= I by PBOOLE:def 3;
    hence doms F is ManySortedSet of I by PBOOLE:def 3;
  end;
  redefine func rngs F -> ManySortedSet of I;
  coherence
  proof
    dom rngs F = dom F by FUNCT_6:90
      .= I by PBOOLE:def 3;
    hence rngs F is ManySortedSet of I by PBOOLE:def 3;
  end;
end;

reserve I, G, H, i, x for set,
  A, B, M for ManySortedSet of I,
  sf, sg, sh for Subset-Family of I,
  v, w for Subset of I,
  F for ManySortedFunction of I;

scheme MSFExFunc { I() -> set, A, B() -> ManySortedSet of I(),
  P[set,set,set] } : ex F be ManySortedFunction of A(), B() st
  for i be set st i in I() holds ex f be Function of A().i, B().i st f = F.i &
  for x be set st x in A().i holds P[f.x,x,i]
provided
A1: for i be set st i in I() holds
for x be set st x in A().i ex y be set st y in B().i & P[y,x,i]
proof
  defpred Q[set,set] means ex f1 be Function of A().$1, B().$1 st f1 = $2 &
  for x be set st x in A().$1 holds P[f1.x,x,$1];
A2: now
    let i be set such that
A3: i in I();
    per cases;
    suppose B().i is non empty;
      then reconsider bb = B().i as non empty set;
      defpred Z[set,set] means P[ $2,$1,i];
A4:   for e be set st e in A().i ex u be set st u in bb & Z[e,u] by A1,A3;
      consider ff be Function of A().i, bb such that
A5:   for e be set st e in A().i holds Z[e,ff.e] from FUNCT_2:sch 1(A4);
      reconsider fff = ff as Function of A().i, B().i;
      reconsider j = fff as set;
      take j;
      thus Q[i,j] by A5;
    end;
    suppose
A6:   B().i is empty;
A7:   now
        let x be set;
        for y be set holds not (y in B().i & P[y,x,i]) by A6;
        hence not x in A().i by A1,A3;
      end;
      then A().i = {} by XBOOLE_0:def 1;
      then reconsider fff = {} as Function of A().i, B().i
      by FUNCT_2:55,RELAT_1:60;
      reconsider j = fff as set;
      take j;
      thus Q[i,j]
      proof
        take fff;
        thus fff = j;
        thus for e be set st e in A().i holds P[fff.e,e,i] by A7;
      end;
    end;
  end;
  consider F be ManySortedSet of I() such that
A8: for i be set st i in I() holds Q[i,F.i] from PBOOLE:sch 3(A2);
  F is ManySortedFunction of A(), B()
  proof
    let i be set;
    assume i in I();
    then consider f be Function of A().i, B().i such that
A9: f = F.i and for x be set st x in A().i holds P[f.x,x,i] by A8;
    thus F.i is Function of A().i, B().i by A9;
  end;
  then reconsider F as ManySortedFunction of A(), B();
  take F;
  thus thesis by A8;
end;

theorem     :: SETFAM_1:3
  sf <> {} implies Intersect sf c= union sf
proof
  assume sf <> {};
  then Intersect sf = meet sf by SETFAM_1:def 10;
  hence thesis by SETFAM_1:3;
end;

theorem     :: SETFAM_1:4
  G in sf implies Intersect sf c= G
proof
  assume
A1: G in sf;
  then meet sf = Intersect sf by SETFAM_1:def 10;
  hence thesis by A1,SETFAM_1:4;
end;

theorem     :: SETFAM_1:5
  {} in sf implies Intersect sf = {}
proof
  assume
A1: {} in sf;
  then Intersect sf = meet sf by SETFAM_1:def 10;
  hence thesis by A1,SETFAM_1:5;
end;

theorem     :: SETFAM_1:6
  for Z be Subset of I holds
  (for Z1 be set st Z1 in sf holds Z c= Z1) implies Z c= Intersect sf
proof
  let Z be Subset of I such that
A1: (for Z1 be set st Z1 in sf holds Z c= Z1);
  per cases;
  suppose
A2: sf <> {};
    then Intersect sf = meet sf by SETFAM_1:def 10;
    hence Z c= Intersect sf by A1,A2,SETFAM_1:6;
  end;
  suppose sf = {};
    then Intersect sf = I by SETFAM_1:def 10;
    hence Z c= Intersect sf;
  end;
end;

theorem     :: SETFAM_1:6
  sf <> {} & (for Z1 be set st Z1 in sf holds G c= Z1) implies G c= Intersect
  sf
proof
  assume that
A1: sf <> {} and
A2: for Z1 be set st Z1 in sf holds G c= Z1;
  Intersect sf = meet sf by A1,SETFAM_1:def 10;
  hence thesis by A1,A2,SETFAM_1:6;
end;

theorem     :: SETFAM_1:8
  G in sf & G c= H implies Intersect sf c= H
proof
  assume
A1: G in sf & G c= H;
  then Intersect sf = meet sf by SETFAM_1:def 10;
  hence thesis by A1,SETFAM_1:8;
end;

theorem     :: SETFAM_1:9
  G in sf & G misses H implies Intersect sf misses H
proof
  assume
A1: G in sf & G misses H;
  then Intersect sf = meet sf by SETFAM_1:def 10;
  hence thesis by A1,SETFAM_1:9;
end;

theorem     :: SETFAM_1:10
  sh = sf \/ sg implies Intersect sh = Intersect sf /\ Intersect sg
proof
  assume
A1: sh = sf \/ sg;
  per cases;
  suppose sf = {} & sg = {};
    hence thesis by A1;
  end;
  suppose
A2: sf <> {} & sg = {};
    hence Intersect sh = meet sf by A1,SETFAM_1:def 10
      .= meet sf /\ I by XBOOLE_1:28
      .= Intersect sf /\ I by A2,SETFAM_1:def 10
      .= Intersect sf /\ Intersect sg by A2,SETFAM_1:def 10;
  end;
  suppose
A3: sf = {} & sg <> {};
    hence Intersect sh = meet sg by A1,SETFAM_1:def 10
      .= I /\ meet sg by XBOOLE_1:28
      .= I /\ Intersect sg by A3,SETFAM_1:def 10
      .= Intersect sf /\ Intersect sg by A3,SETFAM_1:def 10;
  end;
  suppose
A4: sf <> {} & sg <> {};
    then sh <> {} by A1,XBOOLE_1:15;
    then
A5: Intersect sh = meet sh by SETFAM_1:def 10;
    Intersect sf = meet sf & Intersect sg = meet sg by A4,SETFAM_1:def 10;
    hence thesis by A1,A4,A5,SETFAM_1:10;
  end;
end;

theorem     :: SETFAM_1:11
  sf = {v} implies Intersect sf = v
proof
  assume
A1: sf = {v};
  then Intersect sf = meet sf by SETFAM_1:def 10;
  hence thesis by A1,SETFAM_1:11;
end;

theorem     :: SETFAM_1:12
  sf = { v,w } implies Intersect sf = v /\ w
proof
  assume
A1: sf = {v,w};
  then Intersect sf = meet sf by SETFAM_1:def 10;
  hence thesis by A1,SETFAM_1:12;
end;

theorem
  A in B implies A is Element of B
proof
  assume
A1: A in B;
  let i;
  assume i in I;
  hence A.i is Element of B.i by A1,PBOOLE:def 4;
end;

theorem
  for B be non-empty ManySortedSet of I holds A is Element of B implies A in B
proof
  let B be non-empty ManySortedSet of I;
  assume
A1: A is Element of B;
  let i;
  assume
A2: i in I;
  then
A3: A.i is Element of B.i by A1,PBOOLE:def 17;
  B.i <> {} by A2,PBOOLE:def 16;
  hence A.i in B.i by A3;
end;

theorem Th13:
  for f be Function st i in I & f = F.i holds (rngs F).i = rng f
proof
  let f be Function such that
A1: i in I & f = F.i;
  dom F = I by PBOOLE:def 3;
  hence (rngs F).i = rng f by A1,FUNCT_6:31;
end;

theorem Th14:
  for f be Function st i in I & f = F.i holds (doms F).i = dom f
proof
  let f be Function such that
A1: i in I & f = F.i;
  dom F = I by PBOOLE:def 3;
  hence (doms F).i = dom f by A1,FUNCT_6:31;
end;

theorem
  for F, G be ManySortedFunction of I holds G ** F is ManySortedFunction of I
proof
  let F, G be ManySortedFunction of I;
  dom (G ** F) = (dom F) /\ (dom G) by PBOOLE:def 24
    .= I /\ (dom G) by PBOOLE:def 3
    .= I /\ I by PBOOLE:def 3
    .= I;
  hence thesis by PBOOLE:def 3;
end;

theorem
  for A be non-empty ManySortedSet of I
  for F be ManySortedFunction of A, [0]I holds F = [0]I
proof
  let A be non-empty ManySortedSet of I;
  let F be ManySortedFunction of A, [0]I;
  now
    let i;
    assume
A1: i in I;
    then reconsider f = F.i as Function of A.i, [0]I.i by PBOOLE:def 18;
A2: A.i <> {} by A1,PBOOLE:def 16;
    [0]I.i = {} by PBOOLE:5;
    then f = {} by A2,FUNCT_2:def 1;
    hence F.i = [0]I.i by PBOOLE:5;
  end;
  hence F = [0]I by PBOOLE:3;
end;

theorem
  A is_transformable_to B & F is ManySortedFunction of A, B implies
  doms F = A & rngs F c= B
proof
  assume that
A1: A is_transformable_to B and
A2: F is ManySortedFunction of A, B;
  now
    let i;
    assume
A3: i in I;
    then reconsider f = F.i as Function of A.i, B.i by A2,PBOOLE:def 18;
A4: B.i = {} implies A.i = {} by A1,A3,PZFMISC1:def 3;
    thus (doms F).i = dom f by A3,Th14
      .= A.i by A4,FUNCT_2:def 1;
  end;
  hence doms F = A by PBOOLE:3;
  let i;
  assume
A5: i in I;
  then reconsider f = F.i as Function of A.i, B.i by A2,PBOOLE:def 18;
  rng f c= B.i by RELSET_1:12;
  hence (rngs F).i c= B.i by A5,Th13;
end;

begin :: Finite Many Sorted Sets

registration
  let I;
  cluster empty-yielding -> locally-finite ManySortedSet of I;
  coherence
  proof
    let A be ManySortedSet of I such that
A1: A is empty-yielding;
    let i;
    assume i in I;
    then reconsider B = A.i as empty set by A1,PBOOLE:def 15;
    B is finite;
    hence A.i is finite;
  end;
end;

registration
  let I;
  cluster [0]I -> empty-yielding locally-finite;
  coherence;
end;

registration
  let I, A;
  cluster empty-yielding locally-finite ManySortedSubset of A;
  existence
  proof
    set x = [0]I;
    x c= A by PBOOLE:49;
    then reconsider x as ManySortedSubset of A by PBOOLE:def 23;
    take x;
    thus thesis;
  end;
end;

theorem Th18:     :: FINSET_1:13
  A c= B & B is locally-finite implies A is locally-finite
proof
  assume that
A1: A c= B and
A2: B is locally-finite;
  let i;
  assume
A3: i in I;
  then
A4: A.i c= B.i by A1,PBOOLE:def 5;
  B.i is finite by A2,A3,PRE_CIRC:def 3;
  hence thesis by A4,FINSET_1:13;
end;

registration
  let I;
  let A be locally-finite ManySortedSet of I;
  cluster -> locally-finite ManySortedSubset of A;
  coherence
  proof
    let x be ManySortedSubset of A;
    reconsider x' = x as ManySortedSet of I;
    x' c= A by PBOOLE:def 23;
    hence x is locally-finite by Th18;
  end;
end;

registration
  let I;
  let A, B be locally-finite ManySortedSet of I;
  cluster A \/ B -> locally-finite;
  coherence
  proof
    let i;
    assume
A1: i in I;
    then A.i is finite & B.i is finite by PRE_CIRC:def 3;
    then A.i \/ B.i is finite by FINSET_1:14;
    hence (A \/ B).i is finite by A1,PBOOLE:def 7;
  end;
end;

registration
  let I, A;
  let B be locally-finite ManySortedSet of I;
  cluster A /\ B -> locally-finite;
  coherence
  proof
    let i;
    assume
A1: i in I;
    then B.i is finite by PRE_CIRC:def 3;
    then A.i /\ B.i is finite by FINSET_1:15;
    hence (A /\ B).i is finite by A1,PBOOLE:def 8;
  end;
end;

registration
  let I, B;
  let A be locally-finite ManySortedSet of I;
  cluster A /\ B -> locally-finite;
  coherence;
end;

registration
  let I, B;
  let A be locally-finite ManySortedSet of I;
  cluster A \ B -> locally-finite;
  coherence
  proof
    let i;
    assume
A1: i in I;
    then A.i is finite by PRE_CIRC:def 3;
    then A.i \ B.i is finite by FINSET_1:16;
    hence (A \ B).i is finite by A1,PBOOLE:def 9;
  end;
end;

registration
  let I, F;
  let A be locally-finite ManySortedSet of I;
  cluster F.:.:A -> locally-finite;
  coherence
  proof
    let i such that
A1: i in I;
    reconsider f = F.i as Function;
    A.i is finite by A1,PRE_CIRC:def 3;
    then f.:(A.i) is finite by FINSET_1:17;
    hence (F.:.:A).i is finite by A1,PBOOLE:def 25;
  end;
end;

registration
  let I;
  let A, B be locally-finite ManySortedSet of I;
  cluster [|A,B|] -> locally-finite;
  coherence
  proof
    let i;
    assume
A1: i in I;
    then A.i is finite & B.i is finite by PRE_CIRC:def 3;
    then [:A.i,B.i:] is finite by FINSET_1:19;
    hence [|A,B|].i is finite by A1,PBOOLE:def 21;
  end;
end;

theorem     :: FINSET_1:22
  B is non-empty & [|A,B|] is locally-finite implies A is locally-finite
proof
  assume
A1: B is non-empty & [|A,B|] is locally-finite;
  let i;
  assume
A2: i in I;
  then [|A,B|].i is finite by A1,PRE_CIRC:def 3;
  then B.i <> {} & [:A.i,B.i:] is finite by A1,A2,PBOOLE:def 16,def 21;
  hence A.i is finite by FINSET_1:22;
end;

theorem     :: FINSET_1:23
  A is non-empty & [|A,B|] is locally-finite implies B is locally-finite
proof
  assume
A1: A is non-empty & [|A,B|] is locally-finite;
  let i;
  assume
A2: i in I;
  then [|A,B|].i is finite by A1,PRE_CIRC:def 3;
  then A.i <> {} & [:A.i,B.i:] is finite by A1,A2,PBOOLE:def 16,def 21;
  hence B.i is finite by FINSET_1:23;
end;

theorem Th21:     :: FINSET_1:24
  A is locally-finite iff bool A is locally-finite
proof
  thus A is locally-finite implies bool A is locally-finite
  proof
    assume
A1: A is locally-finite;
    let i;
    assume
A2: i in I;
    then A.i is finite by A1,PRE_CIRC:def 3;
    then bool (A.i) is finite by FINSET_1:24;
    hence (bool A).i is finite by A2,MBOOLEAN:def 1;
  end;
  assume
A3: bool A is locally-finite;
  let i;
  assume
A4: i in I;
  then (bool A).i is finite by A3,PRE_CIRC:def 3;
  then bool (A.i) is finite by A4,MBOOLEAN:def 1;
  hence A.i is finite by FINSET_1:24;
end;

registration
  let I;
  let M be locally-finite ManySortedSet of I;
  cluster bool M -> locally-finite;
  coherence by Th21;
end;

theorem     :: FINSET_1:25 a
  for A be non-empty ManySortedSet of I holds A is locally-finite &
  (for M be ManySortedSet of I st M in A holds M is locally-finite)
  implies union A is locally-finite
proof
  let A be non-empty ManySortedSet of I;
  assume that
A1: A is locally-finite and
A2: (for M be ManySortedSet of I st M in A holds M is locally-finite);
  let i;
  assume
A3: i in I;
  then
A4: A.i is finite by A1,PRE_CIRC:def 3;
  for X' be set st X' in A.i holds X' is finite
  proof
    let X' be set such that
A5: X' in A.i;
    consider M be ManySortedSet of I such that
A6: M in A by PBOOLE:146;
A7: dom (i .--> X') = {i} by FUNCOP_1:19;
    dom (M +* (i .--> X')) = I by A3,PZFMISC1:1;
    then reconsider K = M +* (i .--> X') as ManySortedSet of I by PBOOLE:def 3;
    i in {i} by TARSKI:def 1;
    then
A8: K.i = (i .--> X').i by A7,FUNCT_4:14
      .= X' by FUNCOP_1:87;
    K in A
    proof
      let j be set such that
A9:   j in I;
      now per cases;
        case j = i;
          hence K.j in A.j by A5,A8;
        end;
        case j <> i;
          then not j in dom (i .--> X') by A7,TARSKI:def 1;
          then K.j = M.j by FUNCT_4:12;
          hence K.j in A.j by A6,A9,PBOOLE:def 4;
        end;
      end;
      hence K.j in A.j;
    end;
    then K is locally-finite by A2;
    hence X' is finite by A3,A8,PRE_CIRC:def 3;
  end;
  then union (A.i) is finite by A4,FINSET_1:25;
  hence thesis by A3,MBOOLEAN:def 2;
end;

theorem     :: FINSET_1:25 b
  union A is locally-finite implies
  A is locally-finite & for M st M in A holds M is locally-finite
proof
  assume
A1: union A is locally-finite;
  thus A is locally-finite
  proof
    let i;
    assume
A2: i in I;
    then (union A).i is finite by A1,PRE_CIRC:def 3;
    then union (A.i) is finite by A2,MBOOLEAN:def 2;
    hence A.i is finite by FINSET_1:25;
  end;
  let M such that
A3: M in A;
  let i;
  assume
A4: i in I;
  then (union A).i is finite by A1,PRE_CIRC:def 3;
  then
A5: union (A.i) is finite by A4,MBOOLEAN:def 2;
  M.i in A.i by A3,A4,PBOOLE:def 4;
  hence M.i is finite by A5,FINSET_1:25;
end;

theorem     :: FINSET_1:26
  doms F is locally-finite implies rngs F is locally-finite
proof
  assume
A1: doms F is locally-finite;
  let i such that
A2: i in I;
  reconsider f = F.i as Function;
  (doms F).i is finite by A1,A2,PRE_CIRC:def 3;
  then dom f is finite by A2,Th14;
  then rng f is finite by FINSET_1:26;
  hence (rngs F).i is finite by A2,Th13;
end;

theorem     :: FINSET_1:27
  (A c= rngs F & for i be set for f be Function st i in I & f = F.i
  holds f"(A.i) is finite) implies A is locally-finite
proof
  assume that
A1: A c= rngs F and
A2: for i be set for f be Function st i in I & f = F.i
  holds f"(A.i) is finite;
  let i such that
A3: i in I;
  reconsider f = F.i as Function;
  (rngs F).i = rng f by A3,Th13;
  then
A4: A.i c= rng f by A1,A3,PBOOLE:def 5;
  f"(A.i) is finite by A2,A3;
  hence A.i is finite by A4,FINSET_1:27;
end;

registration
  let I;
  let A, B be locally-finite ManySortedSet of I;
  cluster MSFuncs(A,B) -> locally-finite;
  coherence
  proof
    let i;
    assume
A1: i in I;
    then
A2: MSFuncs(A,B).i = Funcs(A.i, B.i) by PBOOLE:def 22;
    A.i is finite & B.i is finite by A1,PRE_CIRC:def 3;
    hence MSFuncs(A,B).i is finite by A2,FRAENKEL:16;
  end;
end;

registration
  let I;
  let A, B be locally-finite ManySortedSet of I;
  cluster A \+\ B -> locally-finite;
  coherence;
end;

reserve X, Y, Z for ManySortedSet of I;

theorem     :: CQC_THE1:13
  X is locally-finite & X c= [|Y,Z|] implies
  ex A, B st A is locally-finite & A c= Y & B is locally-finite & B c= Z &
  X c= [|A,B|]
proof
  assume that
A1: X is locally-finite and
A2: X c= [|Y,Z|];
  defpred Q[set,set] means ex b be set st
  $2 is finite & $2 c= Y.$1 & b is finite & b c= Z.$1 & X.$1 c= [:$2,b:];
A3: for i st i in I ex j be set st Q[i,j]
  proof
    let i;
    assume
A4: i in I;
    then
A5: X.i is finite by A1,PRE_CIRC:def 3;
    X.i c= [|Y,Z|].i by A2,A4,PBOOLE:def 5;
    then X.i c= [:Y.i,Z.i:] by A4,PBOOLE:def 21;
    then consider a, b be set such that
A6: a is finite & a c= Y.i & b is finite & b c= Z.i & X.i c= [:a,b:]
    by A5,FINSET_1:32;
    thus ex a, b be set st a is finite & a c= Y.i & b is finite &
    b c= Z.i & X.i c= [:a,b:] by A6;
  end;
  consider A be ManySortedSet of I such that
A7: for i st i in I holds Q[i,A.i] from PBOOLE:sch 3(A3);
  defpred P[set,set] means A.$1 is finite & A.$1 c= Y.$1 & $2 is finite
  & $2 c= Z.$1 & X.$1 c= [:A.$1,$2:];
A8: for i st i in I ex j be set st P[i,j] by A7;
  consider B be ManySortedSet of I such that
A9: for i st i in I holds P[i,B.i] from PBOOLE:sch 3(A8);
  take A, B;
  thus A is locally-finite
  proof
    let i;
    assume i in I;
    hence thesis by A9;
  end;
  thus A c= Y
  proof
    let i;
    assume i in I;
    hence thesis by A9;
  end;
  thus B is locally-finite
  proof
    let i;
    assume i in I;
    hence thesis by A9;
  end;
  thus B c= Z
  proof
    let i;
    assume i in I;
    hence thesis by A9;
  end;
  thus X c= [|A,B|]
  proof
    let i;
    assume
A10: i in I;
    then X.i c= [:A.i,B.i:] by A9;
    hence thesis by A10,PBOOLE:def 21;
  end;
end;

theorem     :: CQC_THE1:14
  X is locally-finite & Z is locally-finite & X c= [|Y,Z|] implies
  ex A st A is locally-finite & A c= Y & X c= [|A,Z|]
proof
  assume that
A1: X is locally-finite and
A2: Z is locally-finite and
A3: X c= [|Y,Z|];
  defpred P[set,set] means $2 is finite & $2 c= Y.$1 & X.$1 c= [:$2,Z.$1:];
A4: for i st i in I ex j be set st P[i,j]
  proof
    let i;
    assume
A5: i in I;
    then
A6: X.i is finite by A1,PRE_CIRC:def 3;
A7: Z.i is finite by A2,A5,PRE_CIRC:def 3;
    X.i c= [|Y,Z|].i by A3,A5,PBOOLE:def 5;
    then X.i c= [:Y.i, Z.i:] by A5,PBOOLE:def 21;
    then consider A' be set such that
A8: A' is finite & A' c= Y.i & X.i c= [:A',Z.i:] by A6,A7,FINSET_1:33;
    take A';
    thus A' is finite & A' c= Y.i & X.i c= [:A',Z.i:] by A8;
  end;
  consider A such that
A9: for i st i in I holds P[i,A.i] from PBOOLE:sch 3(A4);
  take A;
  thus A is locally-finite
  proof
    let i;
    assume i in I;
    hence A.i is finite by A9;
  end;
  thus A c= Y
  proof
    let i;
    assume i in I;
    hence A.i c= Y.i by A9;
  end;
  thus X c= [|A,Z|]
  proof
    let i;
    assume
A10: i in I;
    then X.i c= [:A.i,Z.i:] by A9;
    hence X.i c= [|A,Z|].i by A10,PBOOLE:def 21;
  end;
end;

theorem     :: ALI2:1
  for M be non-empty locally-finite ManySortedSet of I st
  for A, B be ManySortedSet of I st A in M & B in M holds A c= B or B c= A
  ex m be ManySortedSet of I st m in M & for K be ManySortedSet of I st K in M
  holds m c= K
proof
  let M be non-empty locally-finite ManySortedSet of I such that
A1: for A, B be ManySortedSet of I st A in M & B in M holds A c= B or B c= A;
  defpred Q[set,set] means $2 in M.$1 & for D' be set st D' in M.$1
  holds $2 c= D';
A2: for i st i in I ex j be set st Q[i,j]
  proof
    let i;
    assume
A3: i in I;
    then
A4: M.i is finite by PRE_CIRC:def 3;
A5: M.i <> {} by A3,PBOOLE:def 16;
    M.i is c=-linear
    proof
      let B', C' be set such that
A6:   B' in M.i & C' in M.i;
      assume
A7:   not B' c= C';
      consider b' be ManySortedSet of I such that
A8:   b' in M by PBOOLE:146;
      consider c' be ManySortedSet of I such that
A9:   c' in M by PBOOLE:146;
      set qb = b' +* (i.-->B');
      set qc = c' +* (i.-->C');
      dom qb = I by A3,PZFMISC1:1;
      then reconsider qb as ManySortedSet of I by PBOOLE:def 3;
      dom qc = I by A3,PZFMISC1:1;
      then reconsider qc as ManySortedSet of I by PBOOLE:def 3;
A10:  dom (i .--> B') = {i} by FUNCOP_1:19;
      i in {i} by TARSKI:def 1;
      then
A11:  qb.i = (i .--> B').i by A10,FUNCT_4:14
        .= B' by FUNCOP_1:87;
A12:  dom (i .--> C') = {i} by FUNCOP_1:19;
      i in {i} by TARSKI:def 1;
      then
A13:  qc.i = (i .--> C').i by A12,FUNCT_4:14
        .= C' by FUNCOP_1:87;
A14:  qb in M
      proof
        let j be set such that
A15:    j in I;
        now per cases;
          case j = i;
            hence qb.j in M.j by A6,A11;
          end;
          case j <> i;
            then not j in dom (i .--> B') by A10,TARSKI:def 1;
            then qb.j = b'.j by FUNCT_4:12;
            hence qb.j in M.j by A8,A15,PBOOLE:def 4;
          end;
        end;
        hence qb.j in M.j;
      end;
      qc in M
      proof
        let j be set such that
A16:    j in I;
        now per cases;
          case j = i;
            hence qc.j in M.j by A6,A13;
          end;
          case j <> i;
            then not j in dom (i .--> C') by A12,TARSKI:def 1;
            then qc.j = c'.j by FUNCT_4:12;
            hence qc.j in M.j by A9,A16,PBOOLE:def 4;
          end;
        end;
        hence qc.j in M.j;
      end;
      then qb c= qc or qc c= qb by A1,A14;
      hence thesis by A3,A7,A11,A13,PBOOLE:def 5;
    end;
    then consider m' be set such that
A17: m' in M.i & for D' be set st D' in M.i holds m' c= D'
    by A4,A5,FINSET_1:30;
    take m';
    thus m' in M.i & for D' be set st D' in M.i holds m' c= D' by A17;
  end;
  consider m be ManySortedSet of I such that
A18: for i st i in I holds Q[i,m.i] from PBOOLE:sch 3(A2);
  take m;
  thus m in M
  proof
    let i;
    assume i in I;
    hence m.i in M.i by A18;
  end;
  thus for C be ManySortedSet of I st C in M holds m c= C
  proof
    let C be ManySortedSet of I such that
A19: C in M;
    let i;
    assume
A20: i in I;
    then C.i in M.i by A19,PBOOLE:def 4;
    hence m.i c= C.i by A18,A20;
  end;
end;

theorem     :: FIN_TOPO:3
  for M be non-empty locally-finite ManySortedSet of I st
  for A, B be ManySortedSet of I st A in M & B in M holds A c= B or B c= A
  ex m be ManySortedSet of I st m in M & for K be ManySortedSet of I st K in M
  holds K c= m
proof
  let M be non-empty locally-finite ManySortedSet of I such that
A1: for A, B be ManySortedSet of I st A in M & B in M holds A c= B or B c= A;
  defpred Z[set,set] means $2 in M.$1 & for D' be set st D' in M.$1
  holds D' c= $2;
A2: for i st i in I ex j be set st Z[i,j]
  proof
    let i;
    assume
A3: i in I;
    then
A4: M.i is finite by PRE_CIRC:def 3;
A5: M.i <> {} by A3,PBOOLE:def 16;
    M.i is c=-linear
    proof
      let B', C' be set such that
A6:   B' in M.i & C' in M.i;
      assume
A7:   not B' c= C';
      consider b' be ManySortedSet of I such that
A8:   b' in M by PBOOLE:146;
      consider c' be ManySortedSet of I such that
A9:   c' in M by PBOOLE:146;
      set qb = b' +* (i.-->B');
      set qc = c' +* (i.-->C');
      dom qb = I by A3,PZFMISC1:1;
      then reconsider qb as ManySortedSet of I by PBOOLE:def 3;
      dom qc = I by A3,PZFMISC1:1;
      then reconsider qc as ManySortedSet of I by PBOOLE:def 3;
A10:  dom (i .--> B') = {i} by FUNCOP_1:19;
      i in {i} by TARSKI:def 1;
      then
A11:  qb.i = (i .--> B').i by A10,FUNCT_4:14
        .= B' by FUNCOP_1:87;
A12:  dom (i .--> C') = {i} by FUNCOP_1:19;
      i in {i} by TARSKI:def 1;
      then
A13:  qc.i = (i .--> C').i by A12,FUNCT_4:14
        .= C' by FUNCOP_1:87;
A14:  qb in M
      proof
        let j be set such that
A15:    j in I;
        now per cases;
          case j = i;
            hence qb.j in M.j by A6,A11;
          end;
          case j <> i;
            then not j in dom (i .--> B') by A10,TARSKI:def 1;
            then qb.j = b'.j by FUNCT_4:12;
            hence qb.j in M.j by A8,A15,PBOOLE:def 4;
          end;
        end;
        hence qb.j in M.j;
      end;
      qc in M
      proof
        let j be set such that
A16:    j in I;
        now per cases;
          case j = i;
            hence qc.j in M.j by A6,A13;
          end;
          case j <> i;
            then not j in dom (i .--> C') by A12,TARSKI:def 1;
            then qc.j = c'.j by FUNCT_4:12;
            hence qc.j in M.j by A9,A16,PBOOLE:def 4;
          end;
        end;
        hence qc.j in M.j;
      end;
      then qb c= qc or qc c= qb by A1,A14;
      hence thesis by A3,A7,A11,A13,PBOOLE:def 5;
    end;
    then consider m' be set such that
A17: m' in M.i & for D' be set st D' in M.i holds D' c= m'
    by A4,A5,FINSET_1:31;
    take m';
    thus m' in M.i & for D' be set st D' in M.i holds D' c= m' by A17;
  end;
  consider m be ManySortedSet of I such that
A18: for i st i in I holds Z[i,m.i] from PBOOLE:sch 3(A2);
  take m;
  thus m in M
  proof
    let i;
    assume i in I;
    hence m.i in M.i by A18;
  end;
  thus for K be ManySortedSet of I st K in M holds K c= m
  proof
    let K be ManySortedSet of I such that
A19: K in M;
    let i;
    assume
A20: i in I;
    then K.i in M.i by A19,PBOOLE:def 4;
    hence K.i c= m.i by A18,A20;
  end;
end;

theorem     :: COMPTS_1:1
  Z is locally-finite & Z c= rngs F implies
  ex Y st Y c= doms F & Y is locally-finite & F.:.:Y = Z
proof
  assume that
A1: Z is locally-finite and
A2: Z c= rngs F;
  defpred P[set,set] means ex f be Function st f = F.$1 &
  $2 c= (doms F).$1 & $2 is finite & f.:($2) = Z.$1;
A3: for i st i in I ex j be set st P[i,j]
  proof
    let i;
    assume
A4: i in I;
    then
A5: Z.i is finite by A1,PRE_CIRC:def 3;
    reconsider f = F.i as Function;
    rng f = (rngs F).i by A4,Th13;
    then Z.i c= rng f by A2,A4,PBOOLE:def 5;
    then consider y be set such that
A6: y c= dom f & y is finite & f.:y = Z.i by A5,ORDERS_1:195;
    take y, f;
    thus f = F.i;
    thus y c= (doms F).i & y is finite & f.:y = Z.i by A4,A6,Th14;
  end;
  consider Y be ManySortedSet of I such that
A7: for i st i in I holds P[i,Y.i] from PBOOLE:sch 3(A3);
  take Y;
  thus Y c= doms F
  proof
    let i;
    assume i in I;
    then consider f be Function such that
A8: f = F.i & Y.i c= (doms F).i & Y.i is finite & f.:(Y.i) = Z.i by A7;
    thus Y.i c= (doms F).i by A8;
  end;
  thus Y is locally-finite
  proof
    let i;
    assume i in I;
    then consider f be Function such that
A9: f = F.i & Y.i c= (doms F).i & Y.i is finite & f.:(Y.i) = Z.i by A7;
    thus Y.i is finite by A9;
  end;
  now
    let i;
    assume
A10: i in I;
    then consider f be Function such that
A11: f = F.i & Y.i c= (doms F).i & Y.i is finite & f.:(Y.i) = Z.i by A7;
    thus (F.:.:Y).i = Z.i by A10,A11,PBOOLE:def 25;
  end;
  hence F.:.:Y = Z by PBOOLE:3;
end;

begin :: A Family of Subsets of Many Sorted Sets

definition
  let I, M;
  mode MSSubsetFamily of M is ManySortedSubset of bool M;
end;

registration
  let I, M;
  cluster non-empty MSSubsetFamily of M;
  existence
  proof
    bool M is ManySortedSubset of bool M by PBOOLE:def 23;
    hence thesis;
  end;
end;

definition
  let I, M;
  redefine func bool M -> MSSubsetFamily of M;
  coherence by PBOOLE:def 23;
end;

registration
  let I, M;
  cluster empty-yielding locally-finite MSSubsetFamily of M;
  existence
  proof
    [0]I c= bool M by PBOOLE:49;
    then [0]I is ManySortedSubset of bool M by PBOOLE:def 23;
    hence thesis;
  end;
end;

theorem
  [0]I is empty-yielding locally-finite MSSubsetFamily of M
proof
  [0]I c= bool M by PBOOLE:49;
  hence thesis by PBOOLE:def 23;
end;

registration
  let I;
  let M be locally-finite ManySortedSet of I;
  cluster non-empty locally-finite MSSubsetFamily of M;
  existence
  proof
    bool M is MSSubsetFamily of M;
    hence thesis;
  end;
end;

reserve SF, SG, SH for MSSubsetFamily of M,
  SFe for non-empty MSSubsetFamily of M,
  V, W for ManySortedSubset of M;

definition
  let I be non empty set, M be ManySortedSet of I, SF be MSSubsetFamily of M,
  i be Element of I;
  redefine func SF.i -> Subset-Family of (M.i);
  coherence
  proof
    SF c= bool M by PBOOLE:def 23;
    then SF.i c= (bool M).i by PBOOLE:def 5;
    hence thesis by MBOOLEAN:def 1;
  end;
end;

theorem Th32:
  i in I implies SF.i is Subset-Family of (M.i)
proof
  assume
A1: i in I;
  SF c= bool M by PBOOLE:def 23;
  then SF.i c= (bool M).i by A1,PBOOLE:def 5;
  hence thesis by A1,MBOOLEAN:def 1;
end;

theorem Th33:
  A in SF implies A is ManySortedSubset of M
proof
  assume
A1: A in SF;
  SF c= bool M by PBOOLE:def 23;
  then A in bool M by A1,PBOOLE:9;
  then A c= M by MBOOLEAN:19;
  hence thesis by PBOOLE:def 23;
end;

theorem Th34:
  SF \/ SG is MSSubsetFamily of M
proof
  SF \/ SG is ManySortedSubset of bool M
  proof
A1: SF c= bool M by PBOOLE:def 23;
    SG c= bool M by PBOOLE:def 23;
    hence SF \/ SG c= bool M by A1,PBOOLE:18;
  end;
  hence thesis;
end;

theorem
  SF /\ SG is MSSubsetFamily of M
proof
  SF /\ SG is ManySortedSubset of bool M
  proof
A1: SF c= bool M by PBOOLE:def 23;
    SG c= bool M by PBOOLE:def 23;
    then SF /\ SG c= (bool M) /\ (bool M) by A1,PBOOLE:23;
    hence SF /\ SG c= bool M;
  end;
  hence thesis;
end;

theorem Th36:
  SF \ A is MSSubsetFamily of M
proof
  SF \ A is ManySortedSubset of bool M
  proof
    SF c= bool M by PBOOLE:def 23;
    then
A1: SF \ A c= (bool M) \ A by PBOOLE:59;
    (bool M) \ A c= bool M by PBOOLE:62;
    hence SF \ A c= bool M by A1,PBOOLE:15;
  end;
  hence thesis;
end;

theorem
  SF \+\ SG is MSSubsetFamily of M
proof
  SF \ SG is MSSubsetFamily of M & SG \ SF is MSSubsetFamily of M by Th36;
  hence SF \+\ SG is MSSubsetFamily of M by Th34;
end;

theorem Th38:
  A c= M implies {A} is MSSubsetFamily of M
proof
  assume A c= M;
  then A in bool M by MBOOLEAN:19;
  then {A} c= bool M by PZFMISC1:36;
  hence thesis by PBOOLE:def 23;
end;

theorem Th39:
  A c= M & B c= M implies {A,B} is MSSubsetFamily of M
proof
  assume A c= M & B c= M;
  then {A} is MSSubsetFamily of M & {B} is MSSubsetFamily of M by Th38;
  then {A} \/ {B} is MSSubsetFamily of M by Th34;
  hence thesis by PZFMISC1:11;
end;

theorem Th40:
  union SF c= M
proof
  let i such that
A1: i in I;
A2: for F be Subset-Family of x holds union F is Subset of x;
  SF.i is Subset-Family of M.i by A1,Th32;
  then union (SF.i) is Subset of M.i by A2;
  then union (SF.i) c= M.i;
  hence thesis by A1,MBOOLEAN:def 2;
end;

begin :: Intersection of a Family of Many Sorted Sets

definition
  let I, M, SF;
  canceled;
  func meet SF -> ManySortedSet of I means
  :Def2:
  for i be set st i in I holds ex Q be Subset-Family of (M.i) st Q = SF.i &
  it.i = Intersect Q;
  existence
  proof
    defpred Z[set,set] means ex Q be Subset-Family of (M.$1) st Q = SF.$1 &
    $2 = Intersect Q;
A1: for i st i in I ex j be set st Z[i,j]
    proof
      let i;
      assume
A2:   i in I;
      then reconsider Q = SF.i as Subset-Family of (M.i) by Th32;
      reconsider a = I --> Intersect Q as ManySortedSet of I;
      take j = a.i;
      take Q;
      thus Q = SF.i & j = Intersect Q by A2,FUNCOP_1:13;
    end;
    consider X be ManySortedSet of I such that
A3: for i be set st i in I holds Z[i,X.i] from PBOOLE:sch 3(A1);
    thus thesis by A3;
  end;
  uniqueness
  proof
    let X1, X2 be ManySortedSet of I such that
A4: for i st i in I holds ex Q1 be Subset-Family of (M.i) st Q1 = SF.i &
    X1.i = Intersect Q1 and
A5: for i st i in I holds ex Q2 be Subset-Family of (M.i) st Q2 = SF.i &
    X2.i = Intersect Q2;
    now
      let i be set;
      assume
A6:   i in I;
      then consider Q1 be Subset-Family of (M.i) such that
A7:   Q1 = SF.i & X1.i = Intersect Q1 by A4;
      consider Q2 be Subset-Family of (M.i) such that
A8:   Q2 = SF.i & X2.i = Intersect Q2 by A5,A6;
      thus X1.i = X2.i by A7,A8;
    end;
    hence X1 = X2 by PBOOLE:3;
  end;
end;

definition
  let I, M, SF;
  redefine func meet SF -> ManySortedSubset of M;
  coherence
  proof
    let i;
    assume i in I;
    then consider Q be Subset-Family of (M.i) such that
A1: Q = SF.i & (meet SF).i = Intersect Q by Def2;
    thus (meet SF).i c= M.i by A1;
  end;
end;

theorem Th41:    :: SETFAM_1:2
  SF = [0]I implies meet SF = M
proof
  assume
A1: SF = [0]I;
  now
    let i;
    assume i in I;
    then consider Q be Subset-Family of (M.i) such that
A2: Q = SF.i and
A3: (meet SF).i = Intersect Q by Def2;
    Q = {} by A1,A2,PBOOLE:5;
    hence (meet SF).i = M.i by A3,SETFAM_1:def 10;
  end;
  hence thesis by PBOOLE:3;
end;

theorem     :: SETFAM_1:3
  meet SFe c= union SFe
proof
  let i;
  assume
A1: i in I;
  then consider Q be Subset-Family of (M.i) such that
A2: Q = SFe.i and
A3: (meet SFe).i = Intersect Q by Def2;
A4: meet Q c= union Q by SETFAM_1:3;
  Q <> {} by A1,A2,PBOOLE:def 16;
  then Intersect Q = meet Q by SETFAM_1:def 10;
  hence (meet SFe).i c= (union SFe).i by A1,A2,A3,A4,MBOOLEAN:def 2;
end;

theorem     :: SETFAM_1:4
  A in SF implies meet SF c= A
proof
  assume
A1: A in SF;
  let i;
  assume
A2: i in I;
  then consider Q be Subset-Family of (M.i) such that
A3: Q = SF.i and
A4: (meet SF).i = Intersect Q by Def2;
A5: A.i in SF.i by A1,A2,PBOOLE:def 4;
  then Intersect Q = meet Q by A3,SETFAM_1:def 10;
  hence (meet SF).i c= A.i by A3,A4,A5,SETFAM_1:4;
end;

theorem     :: SETFAM_1:5
  [0]I in SF implies meet SF = [0]I
proof
  assume
A1: [0]I in SF;
  now
    let i;
    assume
A2: i in I;
    then consider Q be Subset-Family of (M.i) such that
A3: Q = SF.i and
A4: (meet SF).i = Intersect Q by Def2;
    [0]I.i in SF.i by A1,A2,PBOOLE:def 4;
    then
A5: Intersect Q = meet Q by A3,SETFAM_1:def 10;
    [0]I.i in Q by A1,A2,A3,PBOOLE:def 4;
    then {} in Q by PBOOLE:5;
    then Intersect Q = {} by A5,SETFAM_1:5;
    hence (meet SF).i = [0]I.i by A4,PBOOLE:5;
  end;
  hence thesis by PBOOLE:3;
end;

theorem     :: SETFAM_1:6
  for Z, M be ManySortedSet of I for SF be non-empty MSSubsetFamily of M st
  (for Z1 be ManySortedSet of I st Z1 in SF holds Z c= Z1) holds Z c= meet SF
proof
  let Z, M be ManySortedSet of I,
  SF be non-empty MSSubsetFamily of M such that
A1: for Z1 be ManySortedSet of I st Z1 in SF holds Z c= Z1;
  let i;
  assume
A2: i in I;
  then consider Q be Subset-Family of (M.i) such that
A3: Q = SF.i and
A4: (meet SF).i = Intersect Q by Def2;
A5: Q <> {} by A2,A3,PBOOLE:def 16;
  then
A6: Intersect Q = meet Q by SETFAM_1:def 10;
  consider T be ManySortedSet of I such that
A7: T in SF by PBOOLE:146;
  for Z' be set st Z' in Q holds Z.i c= Z'
  proof
    let Z' be set such that
A8: Z' in Q;
A9: dom (i .--> Z') = {i} by FUNCOP_1:19;
    dom (T +* (i .--> Z')) = I by A2,PZFMISC1:1;
    then reconsider K = T +* (i .--> Z') as ManySortedSet of I by PBOOLE:def 3;
    i in {i} by TARSKI:def 1;
    then
A10: K.i = (i .--> Z').i by A9,FUNCT_4:14
      .= Z' by FUNCOP_1:87;
    K in SF
    proof
      let q be set such that
A11:  q in I;
      per cases;
      suppose q = i;
        hence K.q in SF.q by A3,A8,A10;
      end;
      suppose q <> i;
        then not q in dom (i .--> Z') by A9,TARSKI:def 1;
        then K.q = T.q by FUNCT_4:12;
        hence K.q in SF.q by A7,A11,PBOOLE:def 4;
      end;
    end;
    then Z c= K by A1;
    hence Z.i c= Z' by A2,A10,PBOOLE:def 5;
  end;
  hence Z.i c= (meet SF).i by A4,A5,A6,SETFAM_1:6;
end;

theorem     :: SETFAM_1:7 :: SETFAM_1:59
  SF c= SG implies meet SG c= meet SF
proof
  assume
A1: SF c= SG;
  let i;
  assume
A2: i in I;
  then consider Qf be Subset-Family of (M.i) such that
A3: Qf = SF.i and
A4: (meet SF).i = Intersect Qf by Def2;
  consider Qg be Subset-Family of (M.i) such that
A5: Qg = SG.i and
A6: (meet SG).i = Intersect Qg by A2,Def2;
  Qf c= Qg by A1,A2,A3,A5,PBOOLE:def 5;
  hence (meet SG).i c= (meet SF).i by A4,A6,SETFAM_1:59;
end;

theorem     :: SETFAM_1:8
  A in SF & A c= B implies meet SF c= B
proof
  assume that
A1: A in SF and
A2: A c= B;
  let i;
  assume
A3: i in I;
  then consider Q be Subset-Family of (M.i) such that
A4: Q = SF.i and
A5: (meet SF).i = Intersect Q by Def2;
A6: A.i in SF.i by A1,A3,PBOOLE:def 4;
  then
A7: Intersect Q = meet Q by A4,SETFAM_1:def 10;
  A.i c= B.i by A2,A3,PBOOLE:def 5;
  hence (meet SF).i c= B.i by A4,A5,A6,A7,SETFAM_1:8;
end;

theorem     :: SETFAM_1:9
  A in SF & A /\ B = [0]I implies meet SF /\ B = [0]I
proof
  assume that
A1: A in SF and
A2: A /\ B = [0]I;
  now
    let i;
    assume
A3: i in I;
    then consider Q be Subset-Family of (M.i) such that
A4: Q = SF.i and
A5: (meet SF).i = Intersect Q by Def2;
A6: A.i in SF.i by A1,A3,PBOOLE:def 4;
    then
A7: Intersect Q = meet Q by A4,SETFAM_1:def 10;
    A.i /\ B.i = [0]I.i by A2,A3,PBOOLE:def 8;
    then A.i /\ B.i = {} by PBOOLE:5;
    then A.i misses B.i by XBOOLE_0:def 7;
    then meet Q misses B.i by A4,A6,SETFAM_1:9;
    then meet Q /\ B.i = {} by XBOOLE_0:def 7;
    then meet Q /\ B.i = [0]I.i by PBOOLE:5;
    hence (meet SF /\ B).i = [0]I.i by A3,A5,A7,PBOOLE:def 8;
  end;
  hence meet SF /\ B = [0]I by PBOOLE:3;
end;

theorem     :: SETFAM_1:10
  SH = SF \/ SG implies meet SH = meet SF /\ meet SG
proof
  assume
A1: SH = SF \/ SG;
  now
    let i;
    assume
A2: i in I;
    then consider Qf be Subset-Family of (M.i) such that
A3: Qf = SF.i and
A4: (meet SF).i = Intersect Qf by Def2;
    consider Qg be Subset-Family of (M.i) such that
A5: Qg = SG.i and
A6: (meet SG).i = Intersect Qg by A2,Def2;
    consider Qh be Subset-Family of (M.i) such that
A7: Qh = SH.i and
A8: (meet SH).i = Intersect Qh by A2,Def2;
A9: Qh = Qf \/ Qg by A1,A2,A3,A5,A7,PBOOLE:def 7;
    now per cases;
      case
A10:    Qf <> {} & Qg <> {};
        then Qh <> {} by A9,XBOOLE_1:15;
        hence (meet SH).i = meet Qh by A8,SETFAM_1:def 10
          .= meet Qf /\ meet Qg by A9,A10,SETFAM_1:10
          .= (meet SF).i /\ meet Qg by A4,A10,SETFAM_1:def 10
          .= (meet SF).i /\ (meet SG).i by A6,A10,SETFAM_1:def 10
          .= (meet SF /\ meet SG).i by A2,PBOOLE:def 8;
      end;
      case
A11:    Qf <> {} & Qg = {};
        hence (meet SH).i = (meet SF).i /\ M.i by A4,A8,A9,XBOOLE_1:28
          .= (meet SF).i /\ (meet SG).i by A6,A11,SETFAM_1:def 10
          .= (meet SF /\ meet SG).i by A2,PBOOLE:def 8;
      end;
      case
A12:    Qf = {} & Qg <> {};
        hence (meet SH).i = M.i /\ (meet SG).i by A6,A8,A9,XBOOLE_1:28
          .= (meet SF).i /\ (meet SG).i by A4,A12,SETFAM_1:def 10
          .= (meet SF /\ meet SG).i by A2,PBOOLE:def 8;
      end;
      case Qf = {} & Qg = {};
        hence (meet SH).i = Intersect Qf /\ Intersect Qg by A8,A9
          .= (meet SF /\ meet SG).i by A2,A4,A6,PBOOLE:def 8;
      end;
    end;
    hence (meet SH).i = (meet SF /\ meet SG).i;
  end;
  hence thesis by PBOOLE:3;
end;

theorem     :: SETFAM_1:11
  SF = {V} implies meet SF = V
proof
  assume
A1: SF = {V};
  now
    let i be set;
    assume
A2: i in I;
    then consider Q be Subset-Family of (M.i) such that
A3: Q = SF.i and
A4: (meet SF).i = Intersect Q by Def2;
    Q <> {} by A1,A2,A3,PBOOLE:def 16;
    hence (meet SF).i = meet Q by A4,SETFAM_1:def 10
      .= meet {V.i} by A1,A2,A3,PZFMISC1:def 1
      .= V.i by SETFAM_1:11;
  end;
  hence thesis by PBOOLE:3;
end;

theorem Th51:    :: SETFAM_1:12
  SF = { V,W } implies meet SF = V /\ W
proof
  assume
A1: SF = { V,W };
  now
    let i be set;
    assume
A2: i in I;
    then consider Q be Subset-Family of (M.i) such that
A3: Q = SF.i and
A4: (meet SF).i = Intersect Q by Def2;
    Q <> {} by A1,A2,A3,PBOOLE:def 16;
    hence (meet SF).i = meet ({V,W}.i) by A1,A3,A4,SETFAM_1:def 10
      .= meet {V.i,W.i} by A2,PZFMISC1:def 2
      .= V.i /\ W.i by SETFAM_1:12
      .= (V /\ W).i by A2,PBOOLE:def 8;
  end;
  hence thesis by PBOOLE:3;
end;

theorem     :: SETFAM_1:58 a
  A in meet SF implies for B st B in SF holds A in B
proof
  assume
A1: A in meet SF;
  let B such that
A2: B in SF;
  let i;
  assume
A3: i in I;
  then consider Q be Subset-Family of (M.i) such that
A4: Q = SF.i and
A5: (meet SF).i = Intersect Q by Def2;
A6: A.i in (meet SF).i by A1,A3,PBOOLE:def 4;
  B.i in SF.i by A2,A3,PBOOLE:def 4;
  hence A.i in B.i by A4,A5,A6,SETFAM_1:58;
end;

theorem     :: SETFAM_1:58 b
  for A, M be ManySortedSet of I for SF be non-empty MSSubsetFamily of M st
  (A in M & for B be ManySortedSet of I st B in SF holds A in B)
  holds A in meet SF
proof
  let A, M be ManySortedSet of I, SF be non-empty MSSubsetFamily of M;
  assume that
A1: A in M and
A2: for B be ManySortedSet of I st B in SF holds A in B;
  let i;
  assume
A3: i in I;
  then consider Q be Subset-Family of (M.i) such that
A4: Q = SF.i and
A5: (meet SF).i = Intersect Q by Def2;
A6: A.i in M.i by A1,A3,PBOOLE:def 4;
  consider T be ManySortedSet of I such that
A7: T in SF by PBOOLE:146;
  for B' be set st B' in Q holds A.i in B'
  proof
    let B' be set such that
A8: B' in Q;
A9: dom (i .--> B') = {i} by FUNCOP_1:19;
    dom (T +* (i .--> B')) = I by A3,PZFMISC1:1;
    then reconsider K = T +* (i .--> B') as ManySortedSet of I by PBOOLE:def 3;
    i in {i} by TARSKI:def 1;
    then
A10: K.i = (i .--> B').i by A9,FUNCT_4:14
      .= B' by FUNCOP_1:87;
    K in SF
    proof
      let q be set such that
A11:  q in I;
      per cases;
      suppose q = i;
        hence K.q in SF.q by A4,A8,A10;
      end;
      suppose q <> i;
        then not q in dom (i .--> B') by A9,TARSKI:def 1;
        then K.q = T.q by FUNCT_4:12;
        hence K.q in SF.q by A7,A11,PBOOLE:def 4;
      end;
    end;
    then A in K by A2;
    hence A.i in B' by A3,A10,PBOOLE:def 4;
  end;
  hence A.i in (meet SF).i by A5,A6,SETFAM_1:58;
end;

definition
  let I, M;
  let IT be MSSubsetFamily of M;
  attr IT is additive means

  for A, B st A in IT & B in IT holds A \/ B in IT;
  attr IT is absolutely-additive means
  :Def4:
  for F be MSSubsetFamily of M st F c= IT holds union F in IT;
  attr IT is multiplicative means
  for A, B st A in IT & B in IT holds A /\ B in IT;
  attr IT is absolutely-multiplicative means
  :Def6:
  for F be MSSubsetFamily of M st F c= IT holds meet F in IT;
  attr IT is properly-upper-bound means
  :Def7:
  M in IT;
  attr IT is properly-lower-bound means
  :Def8:
  [0]I in IT;
end;

Lm1: bool M is additive absolutely-additive multiplicative
absolutely-multiplicative properly-upper-bound properly-lower-bound
proof
  thus bool M is additive
  proof
    let A, B;
    assume A in bool M & B in bool M;
    then A c= M & B c= M by MBOOLEAN:1;
    then A \/ B c= M by PBOOLE:18;
    hence A \/ B in bool M by MBOOLEAN:1;
  end;
  thus bool M is absolutely-additive
  proof
    let F be MSSubsetFamily of M such that F c= bool M;
    union F c= M by Th40;
    hence union F in bool M by MBOOLEAN:19;
  end;
  thus bool M is multiplicative
  proof
    let A, B;
    assume A in bool M & B in bool M;
    then A c= M & B c= M by MBOOLEAN:1;
    then A /\ B c= M by MBOOLEAN:15;
    hence A /\ B in bool M by MBOOLEAN:1;
  end;
  thus bool M is absolutely-multiplicative
  proof
    let F be MSSubsetFamily of M such that F c= bool M;
    meet F c= M by PBOOLE:def 23;
    hence meet F in bool M by MBOOLEAN:19;
  end;
  thus bool M is properly-upper-bound
  proof
    thus M in bool M by MBOOLEAN:19;
  end;
  thus bool M is properly-lower-bound
  proof
    [0]I c= M by MBOOLEAN:5;
    hence [0]I in bool M by MBOOLEAN:1;
  end;
end;

registration
  let I, M;
  cluster non-empty additive absolutely-additive
    multiplicative absolutely-multiplicative
    properly-upper-bound properly-lower-bound MSSubsetFamily of M;
  existence
  proof
    take bool M;
    thus thesis by Lm1;
  end;
end;

definition
  let I, M;
  redefine func bool M -> additive absolutely-additive multiplicative
  absolutely-multiplicative properly-upper-bound
  properly-lower-bound MSSubsetFamily of M;
  coherence by Lm1;
end;

registration
  let I, M;
  cluster absolutely-additive -> additive MSSubsetFamily of M;
  coherence
  proof
    let SF be MSSubsetFamily of M such that
A1: SF is absolutely-additive;
    let A, B;
    assume
A2: A in SF & B in SF;
    then A is ManySortedSubset of M & B is ManySortedSubset of M by Th33;
    then A c= M & B c= M by PBOOLE:def 23;
    then
A3: {A,B} is MSSubsetFamily of M by Th39;
    {A} c= SF & {B} c= SF by A2,PZFMISC1:36;
    then {A} \/ {B} c= SF by PBOOLE:18;
    then {A,B} c= SF by PZFMISC1:11;
    then union {A,B} in SF by A1,A3,Def4;
    hence A \/ B in SF by PZFMISC1:35;
  end;
end;

registration
  let I, M;
  cluster absolutely-multiplicative -> multiplicative MSSubsetFamily of M;
  coherence
  proof
    let SF be MSSubsetFamily of M such that
A1: SF is absolutely-multiplicative;
    let A, B;
    assume
A2: A in SF & B in SF;
    then
A3: A is ManySortedSubset of M & B is ManySortedSubset of M by Th33;
    then A c= M & B c= M by PBOOLE:def 23;
    then reconsider ab = {A,B} as MSSubsetFamily of M by Th39;
    {A} c= SF & {B} c= SF by A2,PZFMISC1:36;
    then {A} \/ {B} c= SF by PBOOLE:18;
    then {A,B} c= SF by PZFMISC1:11;
    then meet ab in SF by A1,Def6;
    hence A /\ B in SF by A3,Th51;
  end;
end;

registration
  let I, M;
  cluster absolutely-multiplicative ->
    properly-upper-bound MSSubsetFamily of M;
  coherence
  proof
    let SF be MSSubsetFamily of M such that
A1: SF is absolutely-multiplicative;
    [0]I c= bool M by PBOOLE:49;
    then reconsider a = [0]I as MSSubsetFamily of M by PBOOLE:def 23;
A2: meet a = M by Th41;
    [0]I c= SF by PBOOLE:49;
    hence M in SF by A1,A2,Def6;
  end;
end;

registration
  let I, M;
  cluster properly-upper-bound -> non-empty MSSubsetFamily of M;
  coherence
  proof
    let SF be MSSubsetFamily of M;
    assume SF is properly-upper-bound;
    then
A1: M in SF by Def7;
    let i;
    assume i in I;
    hence thesis by A1,PBOOLE:def 4;
  end;
end;

registration
  let I, M;
  cluster absolutely-additive -> properly-lower-bound MSSubsetFamily of M;
  coherence
  proof
    let SF be MSSubsetFamily of M such that
A1: SF is absolutely-additive;
    [0]I c= bool M by PBOOLE:49;
    then reconsider a = [0]I as MSSubsetFamily of M by PBOOLE:def 23;
A2: union a = [0]I by MBOOLEAN:22;
    [0]I c= SF by PBOOLE:49;
    hence [0]I in SF by A1,A2,Def4;
  end;
end;

registration
  let I, M;
  cluster properly-lower-bound -> non-empty MSSubsetFamily of M;
  coherence
  proof
    let SF be MSSubsetFamily of M;
    assume SF is properly-lower-bound;
    then
A1: [0]I in SF by Def8;
    let i;
    assume i in I;
    hence thesis by A1,PBOOLE:def 4;
  end;
end;

