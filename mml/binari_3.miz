:: Binary Arithmetics. Binary Sequences
::  by Robert Milewski
::
:: Received February 24, 1998
:: Copyright (c) 1998 Association of Mizar Users
 
environ

 vocabularies NUMBERS, XBOOLE_0, NAT_1, FINSEQ_2, MARGREL1, BINARITH, ARYTM_3,
      POWER, SUBSET_1, ORDINAL4, FINSEQ_1, FUNCOP_1, XBOOLEAN, CARD_1, RELAT_1,
      REAL_1, FINSEQ_5, EUCLID, XXREAL_0, FUNCT_1, PARTFUN1, ARYTM_1, BINARI_2,
      ZFMISC_1, INT_1, ABIAN, BINARI_3;
 notations XBOOLE_0, SUBSET_1, NUMBERS, XCMPLX_0, REAL_1, XXREAL_0, NAT_1,
      NAT_D, POWER, ABIAN, SERIES_1, MARGREL1, FUNCT_1, PARTFUN1, FUNCOP_1,
      FINSEQ_1, FINSEQ_5, FINSEQOP, REALSET1, FINSEQ_2, BINARITH, BINARI_2,
      EUCLID;
 constructors XXREAL_0, NAT_1, NAT_D, FINSEQOP, SERIES_1, REALSET1, BINARITH,
      FINSEQ_5, BINARI_2, ABIAN, EUCLID, BINOP_2, RELSET_1;
 registrations RELSET_1, XREAL_0, NAT_1, XBOOLEAN, MARGREL1, REALSET1, NAT_2,
      ORDINAL1, XBOOLE_0, FINSEQ_2, INT_1;
 requirements REAL, NUMERALS, SUBSET, BOOLE, ARITHM;
 definitions FINSEQ_2, EUCLID, XBOOLEAN;
 theorems TARSKI, NAT_1, NAT_2, MARGREL1, POWER, FUNCOP_1, FINSEQ_1, FINSEQ_2,
      FINSEQ_4, FINSEQ_5, FINSEQ_6, BINARITH, BINARI_2, XREAL_1, XCMPLX_1,
      XBOOLEAN, NAT_D, PARTFUN1, XXREAL_0;
 schemes NAT_1, NAT_2, FINSEQ_2;

begin :: Binary Arithmetics

theorem Th1:
  for n be non empty Nat for F be Tuple of n,BOOLEAN holds Absval F
  < 2 to_power n
proof
  defpred P[non empty Nat] means for F be Tuple of $1,BOOLEAN holds Absval F <
  2 to_power $1;
A1: for n be non empty Nat st P[n] holds P[n+1]
  proof
    let n be non empty Nat;
    assume
A2: P[n];
    n < n+1 by NAT_1:13;
    then
A3: 2 to_power n < 2 to_power (n+1) by POWER:44;
    let F be Tuple of n+1,BOOLEAN;
    consider T be Element of n-tuples_on BOOLEAN,
         d be Element of BOOLEAN such that
A4: F = T^<*d*> by FINSEQ_2:137;
A5: Absval F = Absval T + IFEQ(d,FALSE,0,2 to_power n) by A4,BINARITH:46;
A6: Absval T < 2 to_power n by A2;
    per cases by XBOOLEAN:def 3;
    suppose
      d = FALSE;
      then Absval F = Absval T + 0 by A5,FUNCOP_1:def 8;
      then
      Absval F + 2 to_power n < 2 to_power n + 2 to_power (n+1) by A2,A3
      ,XREAL_1:10;
      hence thesis by XREAL_1:8;
    end;
    suppose
      d = TRUE;
      then Absval F = Absval T + 2 to_power n by A5,FUNCOP_1:def 8;
      then Absval F < 2 to_power n + 2 to_power n by A6,XREAL_1:8;
      then Absval F < 2 to_power n * 2;
      then Absval F < 2 to_power n * 2 to_power 1 by POWER:30;
      hence thesis by POWER:32;
    end;
  end;
A7: P[1]
  proof
    let F be Tuple of 1,BOOLEAN;
    consider d be Element of BOOLEAN such that
A8: F = <*d*> by FINSEQ_2:117;
    d = TRUE or d = FALSE by XBOOLEAN:def 3;
    then Absval F = 1 or Absval F = 0 by A8,BINARITH:41,42;
    then Absval F < 2;
    hence thesis by POWER:30;
  end;
  thus for n being non empty Nat holds P[n] from NAT_1:sch 10(A7,A1);
end;

theorem Th2:
  for n be non empty Nat for F1,F2 be Tuple of n,BOOLEAN st Absval
  F1 = Absval F2 holds F1 = F2
proof
  defpred P[non empty Nat] means for F1,F2 be Tuple of $1,BOOLEAN st Absval F1
  = Absval F2 holds F1 = F2;
A1: for k be non empty Nat st P[k] holds P[k+1]
  proof
    let k be non empty Nat;
    assume
A2: for F1,F2 be Tuple of k,BOOLEAN st Absval F1 = Absval F2 holds F1 = F2;
    let F1,F2 be Tuple of k+1,BOOLEAN;
    consider T1 be Element of k-tuples_on BOOLEAN,
    d1 be Element of BOOLEAN such that
A3: F1 = T1^<*d1*> by FINSEQ_2:137;
    assume
A4: Absval F1 = Absval F2;
    consider T2 be Element of k-tuples_on BOOLEAN,
    d2 be Element of BOOLEAN such that
A5: F2 = T2^<*d2*> by FINSEQ_2:137;
A6: Absval T1 + IFEQ(d1,FALSE,0,2 to_power k) = Absval F1 by A3,BINARITH
    :46
      .= Absval T2 + IFEQ(d2,FALSE,0,2 to_power k) by A5,A4,BINARITH:46;
    d1 = d2
    proof
      assume
A7:   d1 <> d2;
      per cases by XBOOLEAN:def 3;
      suppose
A8:     d1 = FALSE;
        then
A9:     IFEQ(d1,FALSE,0 qua Real,2 to_power k) = 0 by
        FUNCOP_1:def 8;
        IFEQ(d2,FALSE,0 qua Real,2 to_power k) = 2 to_power k by A7,A8
        ,FUNCOP_1:def 8;
        hence contradiction by A6,A9,Th1,NAT_1:11;
      end;
      suppose
A10:    d1 = TRUE;
        then d2 = FALSE by A7,XBOOLEAN:def 3;
        then
A11:    IFEQ(d2,FALSE,0 qua Real,2 to_power k) = 0 by
        FUNCOP_1:def 8;
        IFEQ(d1,FALSE,0 qua Real,2 to_power k) = 2 to_power k by A10,
        FUNCOP_1:def 8;
        hence contradiction by A6,A11,Th1,NAT_1:11;
      end;
    end;
    hence thesis by A2,A3,A5,A6,XCMPLX_1:2;
  end;
A12: P[1]
  proof
    let F1,F2 be Tuple of 1,BOOLEAN;
    consider d1 be Element of BOOLEAN such that
A13: F1 = <*d1*> by FINSEQ_2:117;
    assume
A14: Absval F1 = Absval F2;
    assume
A15: F1 <> F2;
    consider d2 be Element of BOOLEAN such that
A16: F2 = <*d2*> by FINSEQ_2:117;
    per cases by XBOOLEAN:def 3;
    suppose
A17:  d1 = FALSE;
      then
A18:  Absval F1 = 0 by A13,BINARITH:41;
      d2 = TRUE by A13,A16,A15,A17,XBOOLEAN:def 3;
      hence contradiction by A16,A14,A18,BINARITH:42;
    end;
    suppose
A19:  d1 = TRUE;
      then
A20:  Absval F1 = 1 by A13,BINARITH:42;
      d2 = FALSE by A13,A16,A15,A19,XBOOLEAN:def 3;
      hence contradiction by A16,A14,A20,BINARITH:41;
    end;
  end;
  thus for n being non empty Nat holds P[n] from NAT_1:sch 10(A12,A1);
end;

theorem
  for t1,t2 be FinSequence st Rev t1 = Rev t2 holds t1 = t2
proof
  let t1,t2 be FinSequence;
  assume
A1: Rev t1 = Rev t2;
  thus t1 = Rev Rev t1 by FINSEQ_6:29
    .= t2 by A1,FINSEQ_6:29;
end;

canceled;

theorem Th5:
  for n be Nat holds 0*n in BOOLEAN*
proof
  let n be Nat;
  n |-> FALSE is FinSequence of BOOLEAN;
  hence thesis by FINSEQ_1:def 11;
end;

theorem Th6:
  for n be Nat for y be Tuple of n,BOOLEAN st y = 0*n holds 'not' y = n |-> 1
proof
  let n be Nat;
  let y be Tuple of n,BOOLEAN;
  assume
A1: y = 0*n;
A2: now
A3: len y = n by FINSEQ_1:def 18;
    let i be Nat;
    assume that
A4: 1 <= i and
A5: i <= len 'not' y;
A6: len 'not' y = n by FINSEQ_1:def 18;
    then
A7: i in Seg n by A4,A5,FINSEQ_1:3;
    then
A8: y.i = FALSE by A1,FUNCOP_1:13;
    thus ('not' y).i = ('not' y)/.i by A4,A5,FINSEQ_4:24
      .= 'not' (y/.i) by A7,BINARITH:def 4
      .= 'not' FALSE by A4,A5,A6,A3,A8,FINSEQ_4:24
      .= (n |-> 1).i by A7,FUNCOP_1:13;
  end;
  len 'not' y = n by FINSEQ_1:def 18
    .= len (n |-> 1) by FINSEQ_1:def 18;
  hence thesis by A2,FINSEQ_1:18;
end;

theorem Th7:
  for n be non empty Nat for F be Tuple of n,BOOLEAN st F = 0*n
  holds Absval F = 0
proof
  defpred P[Nat] means for F be Tuple of $1,BOOLEAN st F = 0*$1 holds Absval F
  = 0;
A1: for n be non empty Nat st P[n] holds P[n+1]
  proof
    let n be non empty Nat;
    assume
A2: for F be Tuple of n,BOOLEAN st F = 0*n holds Absval F = 0;
    let F be Tuple of n+1,BOOLEAN;
    0*n in BOOLEAN* by Th5;
    then
 0*n is FinSequence of BOOLEAN by FINSEQ_1:def 11;
    then reconsider F1 = 0*n as Tuple of n,BOOLEAN;
    assume F = 0*(n+1);
    hence Absval F = Absval(F1 ^ <*FALSE*>) by FINSEQ_2:74
      .= Absval(F1) + IFEQ(FALSE,FALSE,0,2 to_power n) by BINARITH:46
      .= 0 + IFEQ(FALSE,FALSE,0,2 to_power n) by A2
      .= 0 by FUNCOP_1:def 8;
  end;
A4: P[1] by BINARITH:41,FINSEQ_2:73;
  thus for n being non empty Nat holds P[n] from NAT_1:sch 10(A4,A1);
end;

theorem
  for n be non empty Nat for F be Tuple of n,BOOLEAN st F = 0*n holds
  Absval 'not' F = 2 to_power n - 1
proof
  let n be non empty Nat;
  let F be Tuple of n,BOOLEAN;
  assume
A1: F = 0*n;
  thus Absval 'not' F = - Absval F + 2 to_power n - 1 by BINARI_2:15
    .= - 0 + 2 to_power n - 1 by A1,Th7
    .= 2 to_power n - 1;
end;

theorem
  for n be Nat holds Rev (0*n) = 0*n
proof
  let n be Nat;
A1: now
    let k be Nat;
    assume
A2: k in dom 0*n;
    then k in Seg len 0*n by FINSEQ_1:def 3;
    then
A3: k in Seg n by FINSEQ_1:def 18;
    then n - k + 1 in Seg n by FINSEQ_5:2;
    then
A4: len 0*n - k + 1 in Seg n by FINSEQ_1:def 18;
    thus (Rev 0*n).k = (0*n).(len 0*n - k + 1) by A2,FINSEQ_5:61
      .= 0 by A4,FUNCOP_1:13
      .= (0*n).k by A3,FUNCOP_1:13;
  end;
  dom Rev (0*n) = Seg len Rev (0*n) by FINSEQ_1:def 3
    .= Seg len 0*n by FINSEQ_5:def 3
    .= dom 0*n by FINSEQ_1:def 3;
  hence thesis by A1,FINSEQ_1:17;
end;

theorem
  for n be Nat for y be Tuple of n,BOOLEAN st y = 0*n holds Rev 'not' y
  = 'not' y
proof
  let n be Nat;
  let y be Tuple of n,BOOLEAN;
  assume
A1: y = 0*n;
A2: now
    let k be Nat;
    assume
A3: k in dom 'not' y;
    then k in Seg len 'not' y by FINSEQ_1:def 3;
    then
A4: k in Seg n by FINSEQ_1:def 18;
    then n - k + 1 in Seg n by FINSEQ_5:2;
    then
A5: len 'not' y - k + 1 in Seg n by FINSEQ_1:def 18;
    thus (Rev 'not' y).k = ('not' y).(len 'not' y - k + 1) by A3,FINSEQ_5:61
      .= (n |-> 1).(len 'not' y - k + 1) by A1,Th6
      .= 1 by A5,FUNCOP_1:13
      .= (n |-> 1).k by A4,FUNCOP_1:13
      .= ('not' y).k by A1,Th6;
  end;
  dom Rev 'not' y = Seg len Rev 'not' y by FINSEQ_1:def 3
    .= Seg len 'not' y by FINSEQ_5:def 3
    .= dom 'not' y by FINSEQ_1:def 3;
  hence thesis by A2,FINSEQ_1:17;
end;

theorem Th11:
  Bin1 1 = <*TRUE*>
proof
  1 in Seg 1 by FINSEQ_1:5;
  then
A1: (Bin1 1)/.1 = TRUE by BINARI_2:7;
  ex d be Element of BOOLEAN st Bin1 1 = <*d*> by FINSEQ_2:117;
  hence thesis by A1,FINSEQ_4:25;
end;

theorem Th12:
  for n be non empty Nat holds Absval (Bin1 n) = 1
proof
  defpred P[Nat] means Absval (Bin1 $1) = 1;
A1: for n be non empty Nat st P[n] holds P[n+1]
  proof
    let n be non empty Nat;
    assume
A2: Absval (Bin1 n) = 1;
    thus Absval (Bin1 (n+1)) = Absval (Bin1 n ^ <*FALSE*>) by BINARI_2:9
      .= Absval Bin1 n + IFEQ(FALSE,FALSE,0,2 to_power n) by BINARITH:46
      .= Absval Bin1 n + 0 by FUNCOP_1:def 8
      .= 1 by A2;
  end;
A3: P[1] by Th11,BINARITH:42;
  thus for n being non empty Nat holds P[n] from NAT_1:sch 10(A3,A1);
end;

theorem Th13:
  for x,y be Element of BOOLEAN holds (x 'or' y = TRUE iff x =
  TRUE or y = TRUE) & (x 'or' y = FALSE iff x = FALSE & y = FALSE)
proof
  let x,y be Element of BOOLEAN;
  thus x 'or' y = TRUE implies x = TRUE or y = TRUE
  proof
    assume x 'or' y = TRUE;
    then 'not' x = FALSE or 'not' y = FALSE by MARGREL1:45;
    hence thesis;
  end;
  thus x = TRUE or y = TRUE implies x 'or' y = TRUE;
  thus x 'or' y = FALSE implies x = FALSE & y = FALSE
  proof
    assume
A1: x 'or' y = FALSE;
    then 'not' x = TRUE by MARGREL1:45;
    hence thesis by A1;
  end;
  thus thesis;
end;

theorem Th14:
  for x,y be Element of BOOLEAN holds add_ovfl(<*x*>,<*y*>) = TRUE
  iff x = TRUE & y = TRUE
proof
  let x,y be Element of BOOLEAN;
A1: (<*TRUE*>/.1) '&' (<*TRUE*>/.1) = TRUE by FINSEQ_4:25;
  thus add_ovfl(<*x*>,<*y*>) = TRUE implies x = TRUE & y = TRUE
  proof
    assume add_ovfl(<*x*>,<*y*>) = TRUE;
    then
    (<*x*>/.1) '&' (<*y*>/.1) 'or' (<*x*>/.1) '&' ((carry(<*x*>,<*y*>))/.1
    ) 'or' (<*y*>/.1) '&' ((carry(<*x*>,<*y*>))/.1) = TRUE by BINARITH:def 9;
    then
A2: (<*x*>/.1) '&' (<*y*>/.1) 'or' (<*x*>/.1) '&' ((carry(<*x*>,<*y*>))/.1
    ) = TRUE or (<*y*>/.1) '&' ((carry(<*x*>,<*y*>))/.1) = TRUE by Th13;
    now
      per cases by A2,Th13;
      suppose
A3:     (<*x*>/.1) '&' (<*y*>/.1) = TRUE;
        then (<*x*>/.1) = TRUE by MARGREL1:45;
        hence thesis by A3,FINSEQ_4:25;
      end;
      suppose
        (<*x*>/.1) '&' ((carry(<*x*>,<*y*>))/.1) = TRUE;
        then (carry(<*x*>,<*y*>))/.1 = TRUE by MARGREL1:45;
        hence thesis by BINARITH:def 5;
      end;
      suppose
        (<*y*>/.1) '&' ((carry(<*x*>,<*y*>))/.1) = TRUE;
        then (carry(<*x*>,<*y*>))/.1 = TRUE by MARGREL1:45;
        hence thesis by BINARITH:def 5;
      end;
    end;
    hence thesis;
  end;
  assume that
A4: x = TRUE and
A5: y = TRUE;
  thus add_ovfl(<*x*>,<*y*>) = (<*TRUE*>/.1) '&' (<*TRUE*>/.1) 'or' (<*TRUE*>
/.1) '&' ((carry(<*TRUE*>,<*TRUE*>))/.1) 'or' (<*TRUE*>/.1) '&' (((carry(<*TRUE
  *>,<*TRUE*>))/.1)) by A4,A5,BINARITH:def 9
    .= TRUE by A1;
end;

theorem Th15:
  'not' <*FALSE*> = <*TRUE*>
proof
  now
    let i be Nat;
    assume
A1: i in Seg 1;
    then
A2: i = 1 by FINSEQ_1:4,TARSKI:def 1;
    len <*FALSE*> = 1 by FINSEQ_1:def 18;
    then
A3: (<*FALSE*>/.i) = <*FALSE*>.1 by A2,FINSEQ_4:24;
    len 'not' <*FALSE*> = 1 by FINSEQ_1:def 18;
    hence ('not' <*FALSE*>).i = ('not' <*FALSE*>)/.i by A2,FINSEQ_4:24
      .= 'not' (<*FALSE*>/.i) by A1,BINARITH:def 4
      .= 'not' FALSE by A3,FINSEQ_1:57
      .= <*TRUE*>.i by A2,FINSEQ_1:57;
  end;
  hence thesis by FINSEQ_2:139;
end;

theorem
  'not' <*TRUE*> = <*FALSE*>
proof
  now
    let i be Nat;
    assume
A1: i in Seg 1;
    then
A2: i = 1 by FINSEQ_1:4,TARSKI:def 1;
    len <*TRUE*> = 1 by FINSEQ_1:def 18;
    then
A3: (<*TRUE*>/.i) = <*TRUE*>.1 by A2,FINSEQ_4:24;
    len 'not' <*TRUE*> = 1 by FINSEQ_1:def 18;
    hence ('not' <*TRUE*>).i = ('not' <*TRUE*>)/.i by A2,FINSEQ_4:24
      .= 'not' (<*TRUE*>/.i) by A1,BINARITH:def 4
      .= 'not' TRUE by A3,FINSEQ_1:57
      .= <*FALSE*>.i by A2,FINSEQ_1:57;
  end;
  hence thesis by FINSEQ_2:139;
end;

theorem
  <*FALSE*> + <*FALSE*> = <*FALSE*>
proof
  add_ovfl(<*FALSE*>,<*FALSE*>) <> TRUE by Th14;
  then add_ovfl(<*FALSE*>,<*FALSE*>) = FALSE by XBOOLEAN:def 3;
  then <*FALSE*>,<*FALSE*> are_summable by BINARITH:def 10;
  then Absval(<*FALSE*> + <*FALSE*>) = Absval <*FALSE*> + Absval <*FALSE*> by
  BINARITH:48
    .= Absval <*FALSE*> + 0 by BINARITH:41
    .= Absval <*FALSE*>;
  hence thesis by Th2;
end;

theorem Th18:
  <*FALSE*> + <*TRUE*> = <*TRUE*> & <*TRUE*> + <*FALSE*> = <*TRUE *>
proof
  add_ovfl(<*FALSE*>,<*TRUE*>) <> TRUE by Th14;
  then add_ovfl(<*FALSE*>,<*TRUE*>) = FALSE by XBOOLEAN:def 3;
  then <*FALSE*>,<*TRUE*> are_summable by BINARITH:def 10;
  then Absval(<*FALSE*> + <*TRUE*>) = Absval <*FALSE*> + Absval <*TRUE*> by
  BINARITH:48
    .= Absval <*FALSE*> + 1 by BINARITH:42
    .= 0 + 1 by BINARITH:41
    .= Absval <*TRUE*> by BINARITH:42;
  hence <*FALSE*> + <*TRUE*> = <*TRUE*> by Th2;
  add_ovfl(<*TRUE*>,<*FALSE*>) <> TRUE by Th14;
  then add_ovfl(<*TRUE*>,<*FALSE*>) = FALSE by XBOOLEAN:def 3;
  then <*TRUE*>,<*FALSE*> are_summable by BINARITH:def 10;
  then Absval(<*TRUE*> + <*FALSE*>) = Absval <*TRUE*> + Absval <*FALSE*> by
  BINARITH:48
    .= Absval <*TRUE*> + 0 by BINARITH:41
    .= Absval <*TRUE*>;
  hence thesis by Th2;
end;

theorem
  <*TRUE*> + <*TRUE*> = <*FALSE*>
proof
A1: add_ovfl(<*TRUE*>,<*TRUE*>) = TRUE by Th14;
  Absval(<*TRUE*> + <*TRUE*>) = Absval(<*TRUE*> + <*TRUE*>) + 2 - 2
    .= Absval(<*TRUE*> + <*TRUE*>) + 2 to_power 1 - 2 by POWER:30
    .= Absval(<*TRUE*> + <*TRUE*>) + IFEQ(add_ovfl(<*TRUE*>,<*TRUE*>), FALSE
  ,0,2 to_power (1)) - 2 by A1,FUNCOP_1:def 8
    .= Absval <*TRUE*> + Absval <*TRUE*> - 2 by BINARITH:47
    .= Absval <*TRUE*> + 1 - 2 by BINARITH:42
    .= 1 + 1 - 2 by BINARITH:42
    .= Absval <*FALSE*> by BINARITH:41;
  hence thesis by Th2;
end;

theorem Th20:
  for n be non empty Nat for x,y be Tuple of n,BOOLEAN st x/.n =
  TRUE & (carry(x,Bin1 n))/.n = TRUE holds for k be non empty Nat st k <> 1 & k
  <= n holds x/.k = TRUE & (carry(x,Bin1 n))/.k = TRUE
proof
  let n be non empty Nat;
  let x,y be Tuple of n,BOOLEAN;
  assume that
A1: x/.n = TRUE and
A2: (carry(x,Bin1 n))/.n = TRUE;
  defpred P[Nat] means ($1 in Seg (n -' 1) implies x/.(n -' $1 + 1) = TRUE & (
  carry(x,Bin1 n))/.(n -' $1 + 1) = TRUE);
  let k be non empty Nat;
  assume that
A3: k <> 1 and
A4: k <= n;
  set i = n -' k + 1;
  1 < k by A3,NAT_2:21;
  then 1 + 1 <= k by NAT_1:13;
  then
A5: 1 <= k - 1 by XREAL_1:21;
A6: for j be non empty Nat st P[j] holds P[j+1]
  proof
    let j be non empty Nat;
    assume that
A7: P[j] and
A8: j + 1 in Seg (n -' 1);
A9: j + 1 <= n -' 1 by A8,FINSEQ_1:3;
    then
A10: j < n -' 1 by NAT_1:13;
    then j < n - 1 by NAT_1:14,XREAL_1:235;
    then j + 1 < n by XREAL_1:22;
    then
A11: j < n by NAT_1:13;
    j + 1 <= n - 1 by A9,NAT_1:14,XREAL_1:235;
    then 1 <= n - 1 - j by XREAL_1:21;
    then 1 <= n - j - 1;
    then 1 + 1 <= n - j by XREAL_1:21;
    then 1 + 1 <= n -' j by A11,XREAL_1:235;
    then
A12: n -' j > 1 by NAT_1:13;
A13: 1 <= j by NAT_1:14;
A14: n -' j < n by NAT_2:11;
    then n -' j in Seg n by A12,FINSEQ_1:3;
    then
A15: (Bin1 n)/.(n -' j) = FALSE by A12,BINARI_2:8;
    then ((Bin1 n)/.(n -' j)) '&' ((carry(x,Bin1 n))/.(n -' j)) = FALSE;
    then
A16: TRUE = (x/.(n -' j)) '&' ((Bin1 n)/.(n -' j)) 'or' (x/.(n -' j)) '&'
    ((carry(x,Bin1 n))/.(n -' j)) by A7,A13,A10,A14,A12,A15,BINARITH:def 5,
    FINSEQ_1:3
      .= (x/.(n -' j)) '&' ((carry(x,Bin1 n))/.(n -' j)) by A15;
    then x/.(n -' j) = TRUE by MARGREL1:45;
    hence x/.(n -' (j+1) + 1) = TRUE by A11,NAT_2:9;
    (carry(x,Bin1 n))/.(n -' j) = TRUE by A16,MARGREL1:45;
    hence thesis by A11,NAT_2:9;
  end;
A17: 1 <= i by NAT_1:11;
  i = n - k + 1 by A4,XREAL_1:235
    .= n - (k - 1);
  then
A18: i <= n - 1 by A5,XREAL_1:15;
  then i + 1 <= n by XREAL_1:21;
  then i < n by NAT_1:13;
  then
A19: k = n -' i + 1 by A4,NAT_2:7;
  i <= n -' 1 by A18,NAT_1:14,XREAL_1:235;
  then
A20: i in Seg (n -' 1) by A17,FINSEQ_1:3;
A21: P[1] by A1,A2,NAT_1:14,XREAL_1:237;
  for j be non empty Nat holds P[j] from NAT_1:sch 10(A21,A6);
  hence thesis by A19,A20;
end;

theorem Th21:
  for n be non empty Nat for x be Tuple of n,BOOLEAN st x/.n =
  TRUE & (carry(x,Bin1 n))/.n = TRUE holds carry(x,Bin1 n) = 'not' Bin1 n
proof
  let n be non empty Nat;
  let x be Tuple of n,BOOLEAN;
  assume that
A1: x/.n = TRUE and
A2: (carry(x,Bin1 n))/.n = TRUE;
  now
A3: len 'not' Bin1 n = n by FINSEQ_1:def 18;
    let i be Nat;
    reconsider z = i as Nat;
A4: len carry(x,Bin1 n) = n by FINSEQ_1:def 18;
    assume
A5: i in Seg n;
    then
A6: 1 <= i by FINSEQ_1:3;
A7: i <= n by A5,FINSEQ_1:3;
    per cases;
    suppose
A8:   i = 1;
      thus carry(x,Bin1 n).i = (carry(x,Bin1 n))/.z by A6,A7,A4,FINSEQ_4:24
        .= 'not' TRUE by A8,BINARITH:def 5
        .= 'not' ((Bin1 n)/.i) by A5,A8,BINARI_2:7
        .= ('not' Bin1 n)/.z by A5,BINARITH:def 4
        .= ('not' Bin1 n).i by A6,A7,A3,FINSEQ_4:24;
    end;
    suppose
A9:   i <> 1;
A10:  i is non empty by A5,FINSEQ_1:3;
      thus carry(x,Bin1 n).i = (carry(x,Bin1 n))/.z by A6,A7,A4,FINSEQ_4:24
        .= 'not' FALSE by A1,A2,A7,A9,A10,Th20
        .= 'not' ((Bin1 n)/.i) by A5,A9,BINARI_2:8
        .= ('not' Bin1 n)/.z by A5,BINARITH:def 4
        .= ('not' Bin1 n).i by A6,A7,A3,FINSEQ_4:24;
    end;
  end;
  hence thesis by FINSEQ_2:139;
end;

theorem Th22:
  for n be non empty Nat for x,y be Tuple of n,BOOLEAN st y = 0*n
  & x/.n = TRUE & (carry(x,Bin1 n))/.n = TRUE holds x = 'not' y
proof
  let n be non empty Nat;
  let x,y be Tuple of n,BOOLEAN;
  assume that
A1: y = 0*n and
A2: x/.n = TRUE and
A3: (carry(x,Bin1 n))/.n = TRUE;
A4: len x = n by FINSEQ_1:def 18;
A5: len 'not' y = n by FINSEQ_1:def 18;
A6: len y = n by FINSEQ_1:def 18;
A7: len carry(x,Bin1 n) = n by FINSEQ_1:def 18;
  now
    let i be Nat;
    reconsider z = i as Nat;
    assume
A8: i in Seg n;
    then
A9: 1 <= i by FINSEQ_1:3;
A10: i <= n by A8,FINSEQ_1:3;
A11: y.i = FALSE by A1,A8,FUNCOP_1:13;
    now
      per cases;
      suppose
A12:    i = 1;
A13:    n >= 1 by NAT_1:14;
        now
          per cases by A13,XXREAL_0:1;
          suppose
            n = 1;
            hence x .i = ('not' y).i by A3,BINARITH:def 5;
          end;
          suppose
A14:        n > 1;
A15:        len 'not' Bin1 n = n by FINSEQ_1:def 18;
A16:        (carry(x,Bin1 n))/.i = FALSE by A12,BINARITH:def 5;
            then
A17:        ((Bin1 n)/.i) '&' ((carry(x,Bin1 n))/.i) = FALSE;
A18:        (1+1) <= n by A14,NAT_1:13;
            then
A19:        2 in Seg n by FINSEQ_1:3;
            carry(x,Bin1 n).(i+1) = ('not' Bin1 n).2 by A2,A3,A12,Th21
              .= ('not' Bin1 n)/.2 by A18,A15,FINSEQ_4:24
              .= 'not' ((Bin1 n)/.2) by A19,BINARITH:def 4
              .= 'not' FALSE by A19,BINARI_2:8
              .= TRUE;
            then
A20:        TRUE = (carry(x,Bin1 n))/.(i+1) by A7,A12,A18, FINSEQ_4:
            24
              .= (x/.i) '&' ((Bin1 n)/.i) 'or' (x/.i) '&' ((carry(x,Bin1 n))
            /.i) by A12,A14,A16,A17,BINARITH:def 5
              .= (x/.i) '&' ((Bin1 n)/.i) by A16;
            thus x .i = x/.z by A4,A9,A10,FINSEQ_4:24
              .= 'not' FALSE by A20,MARGREL1:45
              .= 'not' (y/.z) by A6,A9,A10,A11,FINSEQ_4:24
              .= ('not' y)/.z by A8,BINARITH:def 4
              .= ('not' y).i by A5,A9,A10,FINSEQ_4:24;
          end;
        end;
        hence x .i = ('not' y).i;
      end;
      suppose
A21:    i <> 1;
A22:    i is non empty by A8,FINSEQ_1:3;
        thus x .i = x/.z by A4,A9,A10,FINSEQ_4:24
          .= 'not' FALSE by A2,A3,A10,A21,A22,Th20
          .= 'not' (y/.z) by A6,A9,A10,A11,FINSEQ_4:24
          .= ('not' y)/.z by A8,BINARITH:def 4
          .= ('not' y).i by A5,A9,A10,FINSEQ_4:24;
      end;
    end;
    hence x .i = ('not' y).i;
  end;
  hence thesis by FINSEQ_2:139;
end;

theorem Th23:
  for n be non empty Nat for y be Tuple of n,BOOLEAN st y = 0*n
  holds carry('not' y,Bin1 n) = 'not' Bin1 n
proof
  let n be non empty Nat;
  let y be Tuple of n,BOOLEAN;
A1: n >= 1 by NAT_1:14;
A2: len y = n by FINSEQ_1:def 18;
  assume
A3: y = 0*n;
  then
A4: y.n = 0 by FINSEQ_1:5,FUNCOP_1:13;
  n in Seg n by FINSEQ_1:5;
  then
A5: ('not' y)/.n = 'not' (y/.n) by BINARITH:def 4
    .= 'not' FALSE by A1,A4,A2,FINSEQ_4:24
    .= TRUE;
  per cases;
  suppose
A6: n = 1;
    now
      let i be Nat;
A7:   len 'not' Bin1 n = n by FINSEQ_1:def 18;
      assume
A8:   i in Seg n;
      then
A9:   i = 1 by A6,FINSEQ_1:4,TARSKI:def 1;
      len carry('not' y,Bin1 n) = n by FINSEQ_1:def 18;
      hence carry('not' y,Bin1 n).i = (carry('not' y,Bin1 n))/.i by A6,A9,
      FINSEQ_4:24
        .= 'not' TRUE by A9,BINARITH:def 5
        .= 'not' ((Bin1 n)/.i) by A8,A9,BINARI_2:7
        .= ('not' Bin1 n)/.i by A8,BINARITH:def 4
        .= ('not' Bin1 n).i by A6,A9,A7,FINSEQ_4:24;
    end;
    hence thesis by FINSEQ_2:139;
  end;
  suppose
    n <> 1;
    then
A10: n is non trivial by NAT_2:def 1;
    defpred P[Nat] means $1 <= n implies (carry('not' y,Bin1 n))/.$1 = TRUE;
A11: for i be non trivial Nat st P[i] holds P[i+1]
    proof
      let i be non trivial Nat;
      assume that
A12:  i <= n implies (carry('not' y,Bin1 n))/.i = TRUE and
A13:  i + 1 <= n;
A14:  1 <= i by NAT_1:14;
A15:  i < n by A13,NAT_1:13;
      then
A16:  i in Seg n by A14,FINSEQ_1:3;
      then
A17:  y.i = FALSE by A3,FUNCOP_1:13;
A18:  ('not' y)/.i = 'not' (y/.i) by A16,BINARITH:def 4
        .= 'not' FALSE by A2,A14,A15,A17,FINSEQ_4:24
        .= TRUE;
      i <> 1 by NAT_2:def 1;
      then
A19:  ((Bin1 n)/.i) = FALSE by A16,BINARI_2:8;
      then ((Bin1 n)/.i) '&' ((carry('not' y,Bin1 n))/.i) = FALSE;
      hence
      (carry('not' y,Bin1 n))/.(i + 1) = (('not' y)/.i) '&' ((Bin1 n)/.i)
      'or' (('not' y)/.i) '&' ((carry('not' y,Bin1 n))/.i) by A14,A15,A19,
      BINARITH:def 5
        .= TRUE by A12,A13,A18,NAT_1:13;
    end;
A20: P[2]
    proof
      assume 2 <= n;
      then 1 + 1 <= n;
      then
A21:  1 < n by NAT_1:13;
      then
A22:  1 in Seg n by FINSEQ_1:3;
      then
A23:  y.1 = FALSE by A3,FUNCOP_1:13;
      ('not' y)/.1 = 'not' (y/.1) by A22,BINARITH:def 4
        .= 'not' FALSE by A2,A21,A23,FINSEQ_4:24
        .= TRUE;
      then
A24:  (('not' y)/.1) '&' ((Bin1 n)/.1) = TRUE by A22,BINARI_2:7;
      thus (carry('not' y,Bin1 n))/.2 = (carry('not' y,Bin1 n))/.(1 + 1)
        .= (('not' y)/.1) '&' ((Bin1 n)/.1) 'or' (('not' y)/.1) '&' ((carry(
'not' y,Bin1 n))/.1) 'or' ((Bin1 n)/.1) '&' ( (carry('not' y,Bin1 n))/.1) by
      A21,BINARITH:def 5
        .= TRUE by A24;
    end;
    for i be non trivial Nat holds P[i] from NAT_2:sch 2(A20,A11);
    then (carry('not' y,Bin1 n))/.n = TRUE by A10;
    hence thesis by A5,Th21;
  end;
end;

theorem Th24:
  for n be non empty Nat for x,y be Tuple of n,BOOLEAN st y = 0*n
  holds add_ovfl(x,Bin1 n) = TRUE iff x = 'not' y
proof
  let n be non empty Nat;
  let x,y be Tuple of n,BOOLEAN;
  assume
A1: y = 0*n;
A2: n in Seg n by FINSEQ_1:5;
A3: 1 in Seg 1 by FINSEQ_1:5;
  thus add_ovfl(x,Bin1 n) = TRUE implies x = 'not' y
  proof
    assume
A4: add_ovfl(x,Bin1 n) = TRUE;
    then
A5: (x/.n) '&' ((Bin1 n)/.n) 'or' (x/.n) '&' ((carry(x,Bin1 n))/.n) 'or' (
    (Bin1 n)/.n) '&' ((carry(x,Bin1 n))/.n) = TRUE by BINARITH:def 9;
    per cases;
    suppose
A6:   n <> 1;
      now
        per cases by A5,Th13;
        suppose
A7:       (x/.n) '&' ((Bin1 n)/.n) 'or' (x/.n) '&' ((carry(x,Bin1 n))
          /.n) = TRUE;
          now
            per cases by A7,Th13;
            suppose
A8:           (x/.n) '&' ((Bin1 n)/.n) = TRUE;
              assume x <> 'not' y;
              ((Bin1 n)/.n) = TRUE by A8,MARGREL1:45;
              hence contradiction by A2,A6,BINARI_2:8;
            end;
            suppose
A9:           (x/.n) '&' ((carry(x,Bin1 n))/.n) = TRUE;
              then (x/.n) = TRUE by MARGREL1:45;
              hence thesis by A1,A9,Th22;
            end;
          end;
          hence thesis;
        end;
        suppose
A10:      ((Bin1 n)/.n) '&' ((carry(x,Bin1 n))/.n) = TRUE;
          assume x <> 'not' y;
          ((Bin1 n)/.n) = TRUE by A10,MARGREL1:45;
          hence contradiction by A2,A6,BINARI_2:8;
        end;
      end;
      hence thesis;
    end;
    suppose
A11:  n = 1;
      then len y = 1 by FINSEQ_1:def 18;
      then 1 in dom y by A3,FINSEQ_1:def 3;
      then
A12:  (y/.1) = y.1 by PARTFUN1:def 8
        .= 0 by A1,A11,FINSEQ_1:5,FUNCOP_1:13;
      consider d be Element of BOOLEAN such that
A13:  x = <*d*> by A11,FINSEQ_2:117;
A14:  d = TRUE by A4,A11,A13,Th11,Th14;
      now
        let i be Nat;
        assume i in Seg n;
        then i = 1 by A11,FINSEQ_1:4,TARSKI:def 1;
        hence x/.i = 'not' (y/.i) by A13,A14,A12,FINSEQ_4:25;
      end;
      hence thesis by BINARITH:def 4;
    end;
  end;
  assume
A15: x = 'not' y;
  per cases;
  suppose
A16: n <> 1;
A17: (carry(x,Bin1 n))/.n = ('not' Bin1 n)/.n by A1,A15,Th23
      .= 'not' ((Bin1 n)/.n) by A2,BINARITH:def 4
      .= 'not' FALSE by A2,A16,BINARI_2:8
      .= TRUE;
    len y = n by FINSEQ_1:def 18;
    then n in dom y by A2,FINSEQ_1:def 3;
    then
A18: (y/.n) = y.n by PARTFUN1:def 8
      .= 0 by A1,FINSEQ_1:5,FUNCOP_1:13;
A19: x/.n = 'not' (y/.n) by A2,A15,BINARITH:def 4
      .= TRUE by A18;
    thus add_ovfl(x,Bin1 n) = (x/.n) '&' ((Bin1 n)/.n) 'or' (x/.n) '&' ((carry
(x,Bin1 n))/.n) 'or' ((Bin1 n)/.n) '&' ((carry(x,Bin1 n))/.n) by BINARITH:def 9
      .= TRUE by A19,A17;
  end;
  suppose
A20: n = 1;
    then len y = 1 by FINSEQ_1:def 18;
    then 1 in dom y by A3,FINSEQ_1:def 3;
    then
A21: (y/.1) = y.1 by PARTFUN1:def 8
      .= 0 by A1,A20,FINSEQ_1:5,FUNCOP_1:13;
    consider d be Element of BOOLEAN such that
A22: x = <*d*> by A20,FINSEQ_2:117;
    d = ('not' y)/.1 by A15,A22,FINSEQ_4:25
      .= 'not' (y/.1) by A3,A20,BINARITH:def 4
      .= TRUE by A21;
    hence thesis by A20,A22,Th11,Th14;
  end;
end;

theorem Th25:
  for n be non empty Nat for z be Tuple of n,BOOLEAN st z = 0*n
  holds 'not' z + Bin1 n = z
proof
  let n be non empty Nat;
  let z be Tuple of n,BOOLEAN;
  assume
A1: z = 0*n;
  then
A2: add_ovfl('not' z,Bin1 n) = TRUE by Th24;
  Absval ('not' z + Bin1 n) = Absval ('not' z + Bin1 n) + 2 to_power n - 2
  to_power n
    .= Absval ('not' z + Bin1 n) + IFEQ(add_ovfl('not' z,Bin1 n),FALSE, 0,2
  to_power (n)) - 2 to_power n by A2,FUNCOP_1:def 8
    .= Absval 'not' z + Absval Bin1 n - 2 to_power n by BINARITH:47
    .= - Absval(z) + 2 to_power n - 1 + Absval Bin1 n - 2 to_power n by
  BINARI_2:15
    .= - Absval(z) + 2 to_power n - 1 + 1 - 2 to_power n by Th12
    .= -0 by A1,Th7
    .= Absval z by A1,Th7;
  hence thesis by Th2;
end;

begin :: Binary Sequences

definition
  let n,k be Nat;
  func n-BinarySequence k -> Tuple of n,BOOLEAN means
  :Def1:
  for i be Nat st i
  in Seg n holds it/.i = IFEQ((k div 2 to_power (i-'1)) mod 2,0,FALSE,TRUE);
  existence
  proof
    reconsider n9 = n as Nat;
    deffunc F(Nat) = IFEQ((k div 2 to_power ($1-'1)) mod 2,0,FALSE,TRUE);
    consider p be FinSequence of BOOLEAN such that
A1: len p = n9 and
A2: for i be Nat st i in dom p holds p.i = F(i) from FINSEQ_2:sch 1;
A3: dom p = Seg n9 by A1,FINSEQ_1:def 3;
    reconsider p as Element of n-tuples_on BOOLEAN by A1,FINSEQ_2:110;
    take p;
    let i be Nat;
    assume
A4: i in Seg n;
    then i in dom p by A1,FINSEQ_1:def 3;
    hence p/.i = p.i by PARTFUN1:def 8
      .= IFEQ((k div 2 to_power (i-'1)) mod 2,0,FALSE,TRUE) by A2,A3,A4;
  end;
  uniqueness
  proof
    let p1,p2 be Tuple of n,BOOLEAN such that
A5: for i be Nat st i in Seg n holds p1/.i = IFEQ((k div 2 to_power (i
    -'1)) mod 2,0,FALSE,TRUE) and
A6: for i be Nat st i in Seg n holds p2/.i = IFEQ((k div 2 to_power (i
    -'1)) mod 2,0,FALSE,TRUE);
A7: len p1 = n by FINSEQ_1:def 18;
    then
A8: dom p1 = Seg n by FINSEQ_1:def 3;
A9: len p2 = n by FINSEQ_1:def 18;
    now
      let i be Nat;
      assume
A10:  i in dom p1;
      then
A11:  i in dom p2 by A9,A8,FINSEQ_1:def 3;
      thus p1.i = p1/.i by A10,PARTFUN1:def 8
        .= IFEQ((k div 2 to_power (i-'1)) mod 2,0,FALSE,TRUE) by A5,A8,A10
        .= p2/.i by A6,A8,A10
        .= p2.i by A11,PARTFUN1:def 8;
    end;
    hence thesis by A7,A9,FINSEQ_2:10;
  end;
end;

theorem Th26:
  for n be Nat holds n-BinarySequence 0 = 0*n
proof
  let n be Nat;
  0*n in BOOLEAN* by Th5;
  then
 0*n is FinSequence of BOOLEAN by FINSEQ_1:def 11;
  then reconsider F = 0*n as Tuple of n,BOOLEAN;
  now
    let i be Nat;
    assume
A2: i in Seg n;
    len (n-BinarySequence 0) = n by FINSEQ_1:def 18;
    then i in dom (n-BinarySequence 0) by A2,FINSEQ_1:def 3;
    hence (n-BinarySequence 0).i = (n-BinarySequence 0)/.i by PARTFUN1:def 8
      .= IFEQ((0 div 2 to_power (i-'1)) mod 2,0,FALSE,TRUE) by A2,Def1
      .= IFEQ(0 mod 2,0,FALSE,TRUE) by NAT_2:4
      .= IFEQ(0,0,FALSE,TRUE) by NAT_D:26
      .= 0 by FUNCOP_1:def 8
      .= F.i by A2,FUNCOP_1:13;
  end;
  hence thesis by FINSEQ_2:139;
end;

theorem Th27:
  for n,k be Nat st k < 2 to_power n holds ((n+1)-BinarySequence k
  ).(n+1) = FALSE
proof
  let n,k be Nat;
A1: n+1-'1 = n+1-1 by NAT_D:37
    .= n;
  assume k < 2 to_power n;
  then
A2: (k div 2 to_power (n+1-'1)) mod 2 = 0 mod 2 by A1,NAT_D:27
    .= 0 by NAT_D:26;
A3: n + 1 in Seg (n+1) by FINSEQ_1:6;
  then n + 1 in Seg len ((n+1)-BinarySequence k) by FINSEQ_1:def 18;
  then n + 1 in dom ((n+1)-BinarySequence k) by FINSEQ_1:def 3;
  hence ((n+1)-BinarySequence k).(n+1) = ((n+1)-BinarySequence k)/.(n+1) by
  PARTFUN1:def 8
    .= IFEQ((k div 2 to_power (n+1-'1)) mod 2,0,FALSE,TRUE) by A3,Def1
    .= FALSE by A2,FUNCOP_1:def 8;
end;

theorem Th28:
  for n be non empty Nat for k be Nat st k < 2 to_power n holds (n
  +1)-BinarySequence k = (n-BinarySequence k)^<*FALSE*>
proof
  let n be non empty Nat;
  let k be Nat;
  assume
A1: k < 2 to_power n;
  now
    let i be Nat;
    assume
A2: i in Seg (n + 1);
    then i in Seg len ((n+1)-BinarySequence k) by FINSEQ_1:def 18;
    then
A3: i in dom ((n+1)-BinarySequence k) by FINSEQ_1:def 3;
    now
      per cases by A2,FINSEQ_2:8;
      suppose
A4:     i in Seg n;
        then i in Seg len (n-BinarySequence k) by FINSEQ_1:def 18;
        then
A5:     i in dom (n-BinarySequence k) by FINSEQ_1:def 3;
        thus ((n+1)-BinarySequence k).i = ((n+1)-BinarySequence k)/.i by A3,
        PARTFUN1:def 8
          .= IFEQ((k div 2 to_power (i-'1)) mod 2,0,FALSE,TRUE) by A2,Def1
          .= (n-BinarySequence k)/.i by A4,Def1
          .= (n-BinarySequence k).i by A5,PARTFUN1:def 8
          .= ((n-BinarySequence k)^<*FALSE*>).i by A5,FINSEQ_1:def 7;
      end;
      suppose
A6:     i = n + 1;
        hence ((n+1)-BinarySequence k).i = FALSE by A1,Th27
          .= ((n-BinarySequence k)^<*FALSE*>).i by A6,FINSEQ_2:136;
      end;
    end;
    hence ((n+1)-BinarySequence k).i = ((n-BinarySequence k)^<*FALSE*>).i;
  end;
  hence thesis by FINSEQ_2:139;
end;

Lm1: for n be non empty Nat holds (n+1)-BinarySequence 2 to_power n = 0*n^<*
TRUE*>
proof
  let n be non empty Nat;
  0*n in BOOLEAN* by Th5;
  then
 0*n is FinSequence of BOOLEAN by FINSEQ_1:def 11;
  then reconsider 0n = 0*n as Tuple of n,BOOLEAN;
  now
    let i be Nat;
    assume
A2: i in Seg (n+1);
    now
      per cases by A2,FINSEQ_2:8;
      suppose
A3:     i in Seg n;
        then
A4:     i >= 1 by FINSEQ_1:3;
        i <= n + 1 by A2,FINSEQ_1:3;
        then i - 1 <= n + 1 - 1 by XREAL_1:11;
        then
A5:     i-'1 <= n + 1 - 1 by A4,XREAL_1:235;
        n = n-(i-'1)+(i-'1) .= n-'(i-'1)+(i-'1) by A5,XREAL_1:235;
        then
A6:     2 to_power n = 2 to_power (n-'(i-'1)) * 2 to_power (i-'1) by
        POWER:32;
        i in Seg len 0n by A3,FINSEQ_1:def 18;
        then
A7:     i in dom 0n by FINSEQ_1:def 3;
        n >= i by A3,FINSEQ_1:3;
        then n + 1 > i by NAT_1:13;
        then n > i - 1 by XREAL_1:21;
        then n - (i - 1) > 0 by XREAL_1:52;
        then n - (i-'1) > 0 by A4,XREAL_1:235;
        then n-'(i-'1) > 0 by A5,XREAL_1:235;
        then consider n1 be Nat such that
A8:     n-'(i-'1) = n1 + 1 by NAT_1:6;
        reconsider n1 as Nat;
A9:     2 to_power (n -' (i-'1)) = 2 to_power n1 * 2 to_power 1 by A8,
        POWER:32
          .= 2 to_power n1 * 2 by POWER:30;
        2 to_power (i-'1) > 0 by POWER:39;
        then
A10:    ((2 to_power n) div 2 to_power (i-'1)) mod 2 = (2 to_power (n-'(i
        -'1))) mod 2 by A6,NAT_D:20
          .= 0 by A9,NAT_D:13;
        i in Seg len ((n+1)-BinarySequence 2 to_power n) by A2, FINSEQ_1:
        def 18;
        then i in dom ((n+1)-BinarySequence 2 to_power n) by FINSEQ_1:def
        3;
        hence ((n+1)-BinarySequence 2 to_power n).i = ((n+1)-BinarySequence 2
        to_power n)/.i by PARTFUN1:def 8
          .= IFEQ(((2 to_power n) div 2 to_power (i-'1)) mod 2,0,FALSE,TRUE)
        by A2,Def1
          .= 0 by A10,FUNCOP_1:def 8
          .= 0n.i by A3,FUNCOP_1:13
          .= (0n^<*TRUE*>).i by A7,FINSEQ_1:def 7;
      end;
      suppose
A11:    i = n + 1;
A12:    2 to_power n > 0 by POWER:39;
        i-'1 = n+1-1 by A11,NAT_D:37
          .= n;
        then
A13:    ((2 to_power n) div 2 to_power (i-'1)) mod 2 = 1 mod 2 by A12,
        NAT_2:5
          .= 1 by NAT_D:14;
        n + 1 in Seg (n+1) by FINSEQ_1:6;
        then n + 1 in Seg len ((n+1)-BinarySequence 2 to_power n) by
        FINSEQ_1:def 18;
        then n + 1 in dom ((n+1)-BinarySequence 2 to_power n) by
        FINSEQ_1
        :def 3;
        hence ((n+1)-BinarySequence 2 to_power n).i = ((n+1)-BinarySequence 2
        to_power n)/.i by A11,PARTFUN1:def 8
          .= IFEQ(((2 to_power n) div 2 to_power (i-'1)) mod 2,0,FALSE,TRUE)
        by A2,Def1
          .= TRUE by A13,FUNCOP_1:def 8
          .= (0n^<*TRUE*>).i by A11,FINSEQ_2:136;
      end;
    end;
    hence ((n+1)-BinarySequence 2 to_power n).i = (0n^<*TRUE*>).i;
  end;
  hence thesis by FINSEQ_2:139;
end;

Lm2: for n be non empty Nat for k be Nat st 2 to_power n <= k & k < 2 to_power
(n+1) holds ((n+1)-BinarySequence k).(n+1) = TRUE
proof
  let n be non empty Nat;
  let k be Nat;
  assume that
A1: 2 to_power n <= k and
A2: k < 2 to_power (n+1);
  k < 2 to_power n * 2 to_power 1 by A2,POWER:32;
  then k < 2 * 2 to_power n by POWER:30;
  then
A3: k < 2 to_power n + 2 to_power n;
  n+1-'1 = n+1-1 by NAT_D:37
    .= n;
  then
A4: (k div 2 to_power (n+1-'1)) mod 2 = 1 mod 2 by A1,A3,NAT_2:22
    .= 1 by NAT_D:24;
A5: n + 1 in Seg (n+1) by FINSEQ_1:6;
  then n + 1 in Seg len ((n+1)-BinarySequence k) by FINSEQ_1:def 18;
  then n + 1 in dom ((n+1)-BinarySequence k) by FINSEQ_1:def 3;
  hence ((n+1)-BinarySequence k).(n+1) = ((n+1)-BinarySequence k)/.(n+1) by
  PARTFUN1:def 8
    .= IFEQ((k div 2 to_power (n+1-'1)) mod 2,0,FALSE,TRUE) by A5,Def1
    .= TRUE by A4,FUNCOP_1:def 8;
end;

Lm3: for n be non empty Nat for k be Nat st 2 to_power n <= k & k < 2 to_power
(n+1) holds (n+1)-BinarySequence k = (n-BinarySequence (k -' 2 to_power n))^<*
TRUE*>
proof
  let n be non empty Nat;
  let k be Nat;
  assume that
A1: 2 to_power n <= k and
A2: k < 2 to_power (n+1);
  now
    let i be Nat;
    reconsider z = i as Nat;
    assume
A3: i in Seg (n+1);
    then i in Seg len ((n+1)-BinarySequence k) by FINSEQ_1:def 18;
    then
A4: i in dom ((n+1)-BinarySequence k) by FINSEQ_1:def 3;
    now
      per cases by A3,FINSEQ_2:8;
      suppose
A5:     i in Seg n;
        then
A6:     1 <= i by FINSEQ_1:3;
A7:     2 * 2 to_power (i-'1) = 2 to_power (i-'1) * 2 to_power 1 by POWER
        :30
          .= 2 to_power (i-'1+1) by POWER:32
          .= 2 to_power (i-1+1) by A6,XREAL_1:235
          .= 2 to_power i;
        2 to_power (i-'1) > 0 by POWER:39;
        then
A8:     0 + 1 <= 2 to_power (i-'1) by NAT_1:13;
        i <= n by A5,FINSEQ_1:3;
        then
A9:     2 * 2 to_power (z-'1) divides 2 to_power n by A7,NAT_2:13;
A10:    now
          per cases;
          suppose
A11:        k div 2 to_power (i-'1) is even;
            then
A12:        (k div 2 to_power (i-'1)) mod 2 = 0 by NAT_2:23;
            (k-' 2 to_power n) div 2 to_power (i-'1) is even by A1,A8,
            A9,A11,NAT_2:25;
            hence (k div 2 to_power (i-'1)) mod 2 = ((k -' 2 to_power n) div 2
            to_power (i-'1)) mod 2 by A12, NAT_2:23;
          end;
          suppose
A13:        k div 2 to_power (i-'1) is odd;
            then
A14:        (k div 2 to_power (i-'1)) mod 2 = 1 by NAT_2:24;
            (k -' 2 to_power n) div 2 to_power (i-'1) is odd by A1,A8,
            A9,A13,NAT_2:25;
            hence (k div 2 to_power (i-'1)) mod 2 = ((k -' 2 to_power n) div 2
            to_power (i-'1)) mod 2 by A14, NAT_2:24;
          end;
        end;
        i in Seg len (n-BinarySequence (k -' 2 to_power n)) by A5,FINSEQ_1
        :def 18;
        then
A15:    i in dom (n-BinarySequence (k -' 2 to_power n)) by
        FINSEQ_1:
        def 3;
        thus ((n+1)-BinarySequence k).i = ((n+1)-BinarySequence k)/.i by A4,
        PARTFUN1:def 8
          .= IFEQ((k div 2 to_power (i-'1)) mod 2,0,FALSE,TRUE) by A3,Def1
          .= (n-BinarySequence (k -' 2 to_power n))/.i by A5,A10,Def1
          .= (n-BinarySequence (k -' 2 to_power n)).i by A15,PARTFUN1:def 8
          .= ((n-BinarySequence (k -' 2 to_power n))^<*TRUE*>).i by A15,
        FINSEQ_1:def 7;
      end;
      suppose
A16:    i = n + 1;
        hence ((n+1)-BinarySequence k).i = TRUE by A1,A2,Lm2
          .= ((n-BinarySequence (k -' 2 to_power n))^<*TRUE*>).i by A16,
        FINSEQ_2:136;
      end;
    end;
    hence
    ((n+1)-BinarySequence k).i = ((n-BinarySequence (k -' 2 to_power n))^
    <*TRUE*>).i;
  end;
  hence thesis by FINSEQ_2:139;
end;

Lm4: for n be non empty Nat for k be Nat st k < 2 to_power n for x be Tuple of
n,BOOLEAN st x = 0*n holds n-BinarySequence k = 'not' x iff k = 2 to_power n -
1
proof
  let n be non empty Nat;
  let k be Nat;
  assume
A1: k < 2 to_power n;
  let x be Tuple of n,BOOLEAN;
  assume
A2: x = 0*n;
  thus n-BinarySequence k = 'not' x implies k = 2 to_power n - 1
  proof
    defpred P[Nat] means for k be Nat holds (k < 2 to_power $1 implies for y
be Tuple of $1,BOOLEAN st y = 0*$1 holds $1-BinarySequence k = 'not' y implies
    k = 2 to_power $1 - 1);
    assume
A3: n-BinarySequence k = 'not' x;
A4: for m be non empty Nat st P[m] holds P[m+1]
    proof
      let m be non empty Nat;
      assume
A5:   P[m];
A6:   m + 1 in Seg (m + 1) by FINSEQ_1:6;
      0 <= m by NAT_1:2;
      then
A7:   0 + 1 <= m + 1 by XREAL_1:8;
      0*m in BOOLEAN* by Th5;
      then
   0*m is FinSequence of BOOLEAN by FINSEQ_1:def 11;
      then reconsider y1 = 0*m as Tuple of m,BOOLEAN;
      let k be Nat;
      assume
A9:   k < 2 to_power (m+1);
      let y be Tuple of m+1,BOOLEAN;
      assume that
A10:  y = 0*(m+1) and
A11:  (m+1)-BinarySequence k = 'not' y;
A12:  y.(m + 1) = FALSE by A10,FINSEQ_1:6,FUNCOP_1:13;
A13:  y = y1 ^ <* 0 *> by A10,FINSEQ_2:74;
A14:  len y = m + 1 by FINSEQ_1:def 18;
      len 'not' y = m + 1 by FINSEQ_1:def 18;
      then
A15:  ((m+1)-BinarySequence k).(m+1) = ('not' y)/.(m+1) by A11,A7,
      FINSEQ_4:24
        .= 'not' (y/.(m+1)) by A6,BINARITH:def 4
        .= 'not' FALSE by A14,A7,A12,FINSEQ_4:24
        .= TRUE;
      then (m+1)-BinarySequence k = (m-BinarySequence (k -' 2 to_power m))^<*
      TRUE*> by A9,Lm3,Th27;
      then (m-BinarySequence (k -' 2 to_power m))^<*TRUE*> = 'not' y1^<*'not'
      FALSE*> by A11,A13,BINARI_2:11;
      then
A16:  m-BinarySequence (k -' 2 to_power m) = 'not' y1 by
      FINSEQ_2:20;
      k < (2 to_power m) * (2 to_power 1) by A9,POWER:32;
      then k < 2 * (2 to_power m) by POWER:30;
      then k < 2 to_power m + 2 to_power m;
      then k - 2 to_power m < 2 to_power m by XREAL_1:21;
      then k -' 2 to_power m < 2 to_power m by A15,Th27,XREAL_1:235;
      then k -' 2 to_power m = 2 to_power m - 1 by A5,A16;
      then k - 2 to_power m = 2 to_power m - 1 by A15,Th27,XREAL_1:235;
      hence k = (2 to_power m) * 2 - 1
        .= (2 to_power m) * (2 to_power 1) - 1 by POWER:30
        .= 2 to_power (m+1) - 1 by POWER:32;
    end;
A17: P[1]
    proof
      let k be Nat;
A18:  1 <= len (1-BinarySequence k) by FINSEQ_1:def 18;
      assume k < 2 to_power 1;
      then
A19:  k < 2 by POWER:30;
      let y be Tuple of 1,BOOLEAN;
      assume y = 0*1;
      then
A20:  y = <*FALSE*> by FINSEQ_2:73;
      assume
A21:  1-BinarySequence k = 'not' y;
A22:  1 in Seg 1 by FINSEQ_1:5;
A23:  1 = <*1*>.1 by FINSEQ_1:57
        .= (1-BinarySequence k)/.1 by A20,A21,A18,Th15,FINSEQ_4:24
        .= IFEQ((k div 2 to_power (1-'1)) mod 2,0,FALSE,TRUE) by A22,Def1;
      k = 1
      proof
        assume k <> 1;
        then k = 0 by A19,NAT_1:23;
        then k div 2 to_power (1-'1) = 0 by NAT_D:27,POWER:39;
        then (k div 2 to_power (1-'1)) mod 2 = 0 by NAT_D:26;
        hence contradiction by A23,FUNCOP_1:def 8;
      end;
      hence k = 1 + 1 - 1 .= 2 to_power 1 - 1 by POWER:30;
    end;
    for m be non empty Nat holds P[m] from NAT_1:sch 10(A17,A4 );
    hence thesis by A1,A2,A3;
  end;
  assume
A24: k = 2 to_power n - 1;
  now
    let i be Nat;
A25: len x = n by FINSEQ_1:def 18;
    2 to_power (i-'1) > 0 by POWER:39;
    then
A26: 2 to_power (i-'1) >= 0 + 1 by NAT_1:13;
A27: len 'not' x = n by FINSEQ_1:def 18;
A28: 2 to_power (n-'(i-'1)) > 0 by POWER:39;
    then
A29: 2 to_power (n-'(i-'1)) >= 0 + 1 by NAT_1:13;
    reconsider z = i as Nat;
    assume
A30: i in Seg n;
    then
A31: 1 <= i by FINSEQ_1:3;
    i <= n by A30,FINSEQ_1:3;
    then i < n + 1 by NAT_1:13;
    then
A32: i - 1 < n + 1 - 1 by XREAL_1:11;
    1 <= i by A30,FINSEQ_1:3;
    then
A33: 0 + (i-'1) < n by A32,XREAL_1:235;
    then n - (i-'1) > 0 by XREAL_1:22;
    then n-'(i-'1) > 0 by A33,XREAL_1:235;
    then
A34: 2 to_power (n-'(i-'1)) mod 2 = 0 by NAT_2:19;
    2 to_power n > 0 by POWER:39;
    then
A35: 2 to_power n >= 0 + 1 by NAT_1:13;
    then k div 2 to_power (i-'1) = (2 to_power n -' 1) div 2 to_power (i-'1)
    by A24,XREAL_1:235
      .= (2 to_power n div 2 to_power (i-'1)) - 1 by A26,A33,A35,NAT_2:13,17
      .= (2 to_power (n-'(i-'1))) - 1 by A33,NAT_2:18
      .= (2 to_power (n-'(i-'1))) -' 1 by A29,XREAL_1:235;
    then
A36: (k div 2 to_power (i-'1)) mod 2 = 1 by A34,A28,NAT_2:20;
A37: (x).i = FALSE by A2,A30,FUNCOP_1:13;
A38: i <= n by A30,FINSEQ_1:3;
    i in Seg len (n-BinarySequence k) by A30,FINSEQ_1:def 18;
    then i in dom (n-BinarySequence k) by FINSEQ_1:def 3;
    hence (n-BinarySequence k).i = (n-BinarySequence k)/.i by PARTFUN1:def
    8
      .= IFEQ((k div 2 to_power (i-'1)) mod 2,0,FALSE,TRUE) by A30,Def1
      .= 'not' FALSE by A36,FUNCOP_1:def 8
      .= 'not' (x/.z) by A25,A31,A38,A37,FINSEQ_4:24
      .= ('not' x)/.z by A30,BINARITH:def 4
      .= ('not' x).i by A27,A31,A38,FINSEQ_4:24;
  end;
  hence thesis by FINSEQ_2:139;
end;

theorem Th29:
  for i being Nat holds (i+1)-BinarySequence 2 to_power i= 0*i^<*1 *>
proof
  deffunc Bi(Nat) = ($1+1)-BinarySequence 2 to_power $1;
  let i be Nat;
  set Bi = Bi(i);
  per cases by NAT_1:3;
  suppose
A1: i = 0;
    then
A2: 0*i = 0 by FINSEQ_2:72;
    reconsider i1 = i+1 as non empty Nat;
A3: 0*i1 = <*FALSE*> by A1,FINSEQ_2:73;
    then reconsider x = 0*i1 as Tuple of i1, BOOLEAN;
    2 to_power i1 = 2 by A1,POWER:30;
    then 1 = (2 to_power i1) - 1;
    then i1-BinarySequence 1 = 'not' x by Lm4;
    hence Bi = <*TRUE*> by A1,A3,Th15,POWER:29
      .= 0*i^<*1*> by A2,FINSEQ_1:47;
  end;
  suppose
    i > 0;
    then reconsider i9 = i as non empty Nat;
    Bi = 0*(i9)^<*1*> by Lm1;
    hence thesis;
  end;
end;

theorem
  for n be non empty Nat for k be Nat st 2 to_power n <= k & k < 2
  to_power (n+1) holds ((n+1)-BinarySequence k).(n+1) = TRUE by Lm2;

theorem
  for n be non empty Nat for k be Nat st 2 to_power n <= k & k < 2
  to_power (n+1) holds (n+1)-BinarySequence k = (n-BinarySequence (k -' 2
  to_power n))^<*TRUE*> by Lm3;

theorem
  for n be non empty Nat for k be Nat st k < 2 to_power n for x be Tuple
of n,BOOLEAN st x = 0*n holds n-BinarySequence k = 'not' x iff k = 2 to_power n
  - 1 by Lm4;

theorem Th33:
  for n be non empty Nat for k be Nat st k + 1 < 2 to_power n
  holds add_ovfl(n-BinarySequence k,Bin1 n) = FALSE
proof
  let n be non empty Nat;
  let k be Nat;
  assume
A1: k + 1 < 2 to_power n;
  then
A2: k < 2 to_power n by NAT_1:13;
  0*n in BOOLEAN* by Th5;
  then
 0*n is FinSequence of BOOLEAN by FINSEQ_1:def 11;
  then reconsider y = 0*n as Tuple of n,BOOLEAN;
  k < 2 to_power n - 1 by A1,XREAL_1:22;
  then n-BinarySequence k <> 'not' y by A2,Lm4;
  then add_ovfl(n-BinarySequence k,Bin1 n) <> TRUE by Th24;
  hence thesis by XBOOLEAN:def 3;
end;

theorem Th34:
  for n be non empty Nat for k be Nat st k + 1 < 2 to_power n
  holds n-BinarySequence (k+1) = n-BinarySequence k + Bin1 n
proof
  defpred P[non empty Nat] means for k be Nat st k + 1 < 2 to_power $1 holds
  $1-BinarySequence (k+1) = $1-BinarySequence k + Bin1 $1;
A1: for n be non empty Nat st P[n] holds P[n+1]
  proof
    let n be non empty Nat;
    assume
A2: P[n];
    let k be Nat;
    assume
A3: k + 1 < 2 to_power (n+1);
    then
A4: k < 2 to_power (n+1) by NAT_1:13;
    now
      per cases by XXREAL_0:1;
      suppose
A5:     k + 1 < 2 to_power n;
        then
A6:     k < 2 to_power n by NAT_1:13;
A7:     add_ovfl(n-BinarySequence k,Bin1 n) = FALSE by A5,Th33;
        thus (n+1)-BinarySequence (k+1) = (n-BinarySequence (k+1))^<*FALSE*>
        by A5,Th28
          .= (n-BinarySequence k + Bin1 n)^<*FALSE 'xor' FALSE 'xor'
        add_ovfl(n-BinarySequence k,Bin1 n)*> by A2,A5,A7
          .= ((n-BinarySequence k)^<*FALSE*>) + (Bin1 n^<*FALSE*>) by
        BINARITH:45
          .= ((n-BinarySequence k)^<*FALSE*>) + Bin1 (n+1) by BINARI_2:9
          .= (n+1)-BinarySequence k + Bin1 (n+1) by A6,Th28;
      end;
      suppose
A8:     k + 1 > 2 to_power n;
        then
A9:     k >= 2 to_power n by NAT_1:13;
        k + 1 < (2 to_power n) * (2 to_power 1) by A3,POWER:32;
        then k + 1 < (2 to_power n) * 2 by POWER:30;
        then k + 1 < 2 to_power n + 2 to_power n;
        then k + 1 - 2 to_power n < 2 to_power n by XREAL_1:21;
        then k - 2 to_power n + 1 < 2 to_power n;
        then
A10:    k -' 2 to_power n + 1 < 2 to_power n by A9,XREAL_1:235;
        then
A11:    add_ovfl(n-BinarySequence (k -' 2 to_power n),Bin1 n) = FALSE by
        Th33;
        thus (n+1)-BinarySequence (k+1) = (n-BinarySequence (k + 1 -' 2
        to_power n))^<*TRUE*> by A3,A8,Lm3
          .= (n-BinarySequence (k-'2 to_power n + 1))^<*TRUE*> by A9,NAT_D:
        38
          .= (n-BinarySequence (k -' 2 to_power n) + Bin1 n)^<*TRUE 'xor'
FALSE 'xor' add_ovfl(n-BinarySequence (k -' 2 to_power n),Bin1 n)*> by A2,A10,
        A11
          .= (n-BinarySequence (k -' 2 to_power n))^<*TRUE*> + Bin1 n^<*
        FALSE*> by BINARITH:45
          .= (n-BinarySequence (k -' 2 to_power n))^<*TRUE*> + Bin1 (n+1) by
        BINARI_2:9
          .= (n+1)-BinarySequence k + Bin1 (n+1) by A4,A9,Lm3;
      end;
      suppose
A12:    k + 1 = 2 to_power n;
        0*n in BOOLEAN* by Th5;
        then
    0*n is FinSequence of BOOLEAN by FINSEQ_1:def 11;
        then reconsider z = 0*n as Tuple of n,BOOLEAN;
A14:    k < 2 to_power n by A12,NAT_1:13;
        k = 2 to_power n - 1 by A12;
        then
A15:    n-BinarySequence k = 'not' z by A14,Lm4;
        thus (n+1)-BinarySequence (k+1) = 0*n^<*1*> by A12,Th29
          .= ('not' z + Bin1 n)^<*TRUE*> by Th25
          .= (n-BinarySequence k + Bin1 n)^<*FALSE 'xor' FALSE 'xor'
        add_ovfl(n-BinarySequence k,Bin1 n)*> by A15,Th24
          .= (n-BinarySequence k)^<*FALSE*> + Bin1 n^<*FALSE*> by BINARITH:
        45
          .= (n-BinarySequence k)^<*FALSE*> + Bin1 (n+1) by BINARI_2:9
          .= (n+1)-BinarySequence k + Bin1 (n+1) by A14,Th28;
      end;
    end;
    hence thesis;
  end;
A16: P[1]
  proof
    0*1 in BOOLEAN* by Th5;
    then
 0*1 is FinSequence of BOOLEAN by FINSEQ_1:def 11;
    then reconsider x = 0*1 as Tuple of 1,BOOLEAN;
    let k be Nat;
A18: 0*1 = <*FALSE*> by FINSEQ_2:73;
    assume
A19: k + 1 < 2 to_power 1;
    then k + 1 < 1 + 1 by POWER:30;
    then k < 1 by XREAL_1:8;
    then
A20: k = 0 by NAT_1:14;
    then k + 1 = 2 - 1 .= 2 to_power 1 - 1 by POWER:30;
    hence 1-BinarySequence (k+1) = 'not' x by A19,Lm4
      .= 1-BinarySequence k + Bin1 1 by A20,A18,Th11,Th15,Th18,Th26;
  end;
  thus for n being non empty Nat holds P[n] from NAT_1:sch 10(A16,A1);
end;

theorem
  for n,i be Nat holds (n+1)-BinarySequence i = <*i mod 2*> ^ (n
  -BinarySequence (i div 2))
proof
  let n,i be Nat;
A1: len ((n+1)-BinarySequence i) = n + 1 by FINSEQ_1:def 18;
  then
A2: dom ((n+1)-BinarySequence i) = Seg(n+1) by FINSEQ_1:def 3;
A3: len (<*i mod 2*> ^ (n-BinarySequence (i div 2))) = 1 + len (n
  -BinarySequence (i div 2)) by FINSEQ_5:8
    .= n + 1 by FINSEQ_1:def 18;
  now
    let j be Nat;
    reconsider z = j as Nat;
    assume
A4: j in dom ((n+1)-BinarySequence i);
    then
A5: 1 <= j by A2,FINSEQ_1:3;
A6: j <= n + 1 by A2,A4,FINSEQ_1:3;
A7: len <*i mod 2*> = 1 by FINSEQ_1:56;
    now
      per cases by A5,XXREAL_0:1;
      suppose
A8:     j > 1;
A9:     2 to_power (j-'1-'1 + 1) = (2 to_power (j-'1-'1)) * (2 to_power 1
        ) by POWER:32
          .= 2 * 2 to_power (j-'1-'1) by POWER:30;
        j - 1 > 1 - 1 by A8,XREAL_1:11;
        then j-'1 > 0 by A5,XREAL_1:235;
        then
A10:    j-'1 >= 0 + 1 by NAT_1:13;
        then
A11:    i div 2 to_power (j-'1) = i div 2 to_power (j-'1-'1 + 1) by
        XREAL_1:237
          .= (i div 2) div 2 to_power (j-'1-'1) by A9,NAT_2:29;
        j - 1 <= n by A6,XREAL_1:22;
        then
A12:    j-'1 <= n by A5,XREAL_1:235;
        then
A13:    j-'1 <= len (n-BinarySequence (i div 2)) by
        FINSEQ_1:def 18;
A14:    j-'1 in Seg n by A10,A12,FINSEQ_1:3;
        j <= len ((n+1)-BinarySequence i) by A6,FINSEQ_1:def 18;
        hence ((n+1)-BinarySequence i).j = ((n+1)-BinarySequence i)/.z by A5,
        FINSEQ_4:24
          .= IFEQ((i div 2 to_power (j-'1)) mod 2,0,FALSE,TRUE) by A2,A4,
        Def1
          .= (n-BinarySequence (i div 2))/.(j-'1) by A14,A11,Def1
          .= (n-BinarySequence (i div 2)).(j-'1) by A10,A13,FINSEQ_4:24
          .= (n-BinarySequence (i div 2)).(j - 1) by A5,XREAL_1:235
          .= (<*i mod 2*> ^ (n-BinarySequence (i div 2))).j by A3,A6,A7,A8,
        FINSEQ_1:37;
      end;
      suppose
A15:    j = 1;
A16:    now
          per cases;
          suppose
            i mod 2 = 0;
            hence IFEQ(i mod 2,0,FALSE,TRUE) = i mod 2 by FUNCOP_1:def 8;
          end;
          suppose
A17:        i mod 2 <> 0;
            hence IFEQ(i mod 2,0,FALSE,TRUE) = 1 by FUNCOP_1:def 8
              .= i mod 2 by A17,NAT_D:12;
          end;
        end;
A18:    2 to_power 0 = 1 by POWER:29;
        thus ((n+1)-BinarySequence i).j = ((n+1)-BinarySequence i)/.z by A1,A5
        ,A6,FINSEQ_4:24
          .= IFEQ((i div 2 to_power (1-'1)) mod 2,0,FALSE,TRUE) by A2,A4,A15
        ,Def1
          .= IFEQ((i div 1) mod 2,0,FALSE,TRUE) by A18,XREAL_1:234
          .= IFEQ(i mod 2,0,FALSE,TRUE) by NAT_2:6
          .= (<*i mod 2*> ^ (n-BinarySequence (i div 2))).j by A15,A16,
        FINSEQ_1:58;
      end;
    end;
    hence ((n+1)-BinarySequence i).j = (<*i mod 2*> ^ (n-BinarySequence (i div
    2))).j;
  end;
  hence thesis by A1,A3,FINSEQ_2:10;
end;

theorem Th36:
  for n be non empty Nat for k be Nat holds k < 2 to_power n
  implies Absval (n-BinarySequence k) = k
proof
  let n be non empty Nat;
  defpred P[Nat] means $1 < 2 to_power n implies Absval (n-BinarySequence $1)
  = $1;
A1: for k be Nat st P[k] holds P[k+1]
  proof
    0*n in BOOLEAN* by Th5;
    then
 0*n is FinSequence of BOOLEAN by FINSEQ_1:def 11;
    then reconsider 0n = 0*n as Tuple of n,BOOLEAN;
    let k be Nat;
    assume
A3: k < 2 to_power n implies Absval (n-BinarySequence k) = k;
    assume
A4: k + 1 < 2 to_power n;
    then
A5: k + 1 - 1 < 2 to_power n - 1 by XREAL_1:11;
    k < 2 to_power n by A4,NAT_1:13;
    then n-BinarySequence k <> 'not' 0n by A5,Lm4;
    then add_ovfl(n-BinarySequence k,Bin1 n) <> TRUE by Th24;
    then add_ovfl(n-BinarySequence k,Bin1 n) = FALSE by XBOOLEAN:def 3;
    then
A6: n-BinarySequence k,Bin1 n are_summable by BINARITH:def 10;
    thus Absval (n-BinarySequence (k+1)) = Absval (n-BinarySequence k + Bin1 n
    ) by A4,Th34
      .= Absval (n-BinarySequence k) + Absval (Bin1 n) by A6,BINARITH:48
      .= k + 1 by A3,A4,Th12,NAT_1:13;
  end;
A7: P[0]
  proof
    assume 0 < 2 to_power n;
    n-BinarySequence 0 = 0*n by Th26;
    hence thesis by Th7;
  end;
  thus for n being Nat holds P[n] from NAT_1:sch 2(A7,A1);
end;

theorem
  for n be non empty Nat for x be Tuple of n,BOOLEAN holds n
  -BinarySequence (Absval x) = x
proof
  let n be non empty Nat;
  let x be Tuple of n,BOOLEAN;
  Absval x < 2 to_power n by Th1;
  then Absval (n-BinarySequence Absval x) = Absval x by Th36;
  hence thesis by Th2;
end;
