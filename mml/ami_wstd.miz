:: Weakly Standard Ordering of Instruction Locations
::  by Andrzej Trybulec , Piotr Rudnicki and Artur Korni{\l}owicz
::
:: Received April 22, 2010
:: Copyright (c) 2010 Association of Mizar Users

environ

 vocabularies NUMBERS, XBOOLE_0, SUBSET_1, ORDINAL1, SETFAM_1, AMI_1, FSM_1,
      FUNCT_4, FUNCOP_1, RELAT_1, TARSKI, FUNCT_1, CARD_3, ZFMISC_1,
      CIRCUIT2, NAT_1, GLIB_000, XXREAL_0, PARTFUN1, FINSEQ_1, ARYTM_3,
      GRAPH_2, CARD_1, FUNCT_2, FINSEQ_4, ARYTM_1, FINSET_1, FRECHET,
      RCOMP_1, WAYBEL_0, MEMBERED, AMISTD_1, SCMNORM, AMI_WSTD;
 notations TARSKI, XBOOLE_0, ZFMISC_1, SUBSET_1, RELAT_1, SETFAM_1, ORDINAL1,
      CARD_1, XXREAL_0, NUMBERS, XCMPLX_0, NAT_1, MEMBERED, FUNCT_1, RELSET_1,
      PARTFUN1, MCART_1,
      DOMAIN_1, CARD_3, FINSEQ_1, FINSEQ_4, FUNCOP_1, FINSET_1,
      FUNCT_4, AFINSQ_1,
      STRUCT_0, GRAPH_2, NAT_D, XXREAL_2, COMPOS_1, EXTPRO_1, AMI_1, FUNCT_2,
      AMISTD_1;
 constructors WELLORD2, REAL_1, FINSEQ_4, REALSET1, NAT_D, AMI_1, XXREAL_2,
      RELSET_1, PRE_POLY, GRAPH_2, AFINSQ_1, MCART_1, AMISTD_1;
 registrations XBOOLE_0, SETFAM_1, RELAT_1, FUNCT_1, PARTFUN1, FUNCT_2,
      FUNCOP_1, FINSET_1, NUMBERS, XREAL_0, NAT_1, MEMBERED, FINSEQ_1, CARD_3,
      REALSET1, FUNCT_7, STRUCT_0, AMI_1, JORDAN1J, CARD_1, XXREAL_2, RELSET_1,
      FUNCT_4, AFINSQ_1, ORDINAL1, ZFMISC_1, SUBSET_1, AMISTD_1, COMPOS_1,
      EXTPRO_1;
 requirements NUMERALS, BOOLE, REAL, SUBSET, ARITHM;
 definitions TARSKI, STRUCT_0, COMPOS_1, EXTPRO_1, YELLOW_8, XBOOLE_0,
      FUNCOP_1, NAT_1, RELAT_1, FUNCT_4, NAT_D, AFINSQ_1, AMISTD_1;
 theorems TARSKI, FINSEQ_4, FINSEQ_1, GRAPH_2, NAT_1, FUNCT_4, FUNCT_1,
      FUNCT_2, RELAT_1, ZFMISC_1, CARD_1, FUNCOP_1, ORDINAL1,
      GRFUNC_1, FINSEQ_3, INT_1, REVROT_1, FUNCT_7,
      XBOOLE_0, MEMBERED, XREAL_1, XXREAL_0, FINSEQ_6,
      PARTFUN1, XXREAL_2, XREAL_0, NAT_D, PBOOLE, RECDEF_2,
      AMISTD_1, COMPOS_1, EXTPRO_1;
 schemes NAT_1, FUNCT_7, FINSEQ_2, FRAENKEL, DOMAIN_1, FINSEQ_4;

begin :: Ami-Struct

reserve x for set,
  D for non empty set,
  k, n for Element of NAT,
  z for natural number;
reserve N for with_non-empty_elements non empty set,
  S for
    IC-Ins-separated definite (non empty stored-program AMI-Struct over N),
  i for Element of the Instructions of S,
  l, l1, l2, l3 for Element of NAT,
  s for State of S;
reserve ss for Element of product the Object-Kind of S;

begin :: Ordering of Instruction Locations

definition
  canceled 7;
  let N,S; let l1,l2 be Nat;
  pred l1 <= l2, S means
  :Def8:
  ex f being non empty FinSequence of NAT st
  f/.1 = l1 & f/.len f = l2 & for n st 1 <= n & n < len f
  holds f/.(n+1) in SUCC(f/.n,S);
end;

canceled 15;

theorem
 for N,S for l1,l2 being Nat holds
  l1 <= l2,S & l2 <= l3, S implies l1 <= l3, S
proof let N,S;  let l1,l2 be Nat;
  given f1 being non empty FinSequence of NAT such that
A1: f1/.1 = l1 and
A2: f1/.len f1 = l2 and
A3: for n st 1 <= n & n < len f1 holds f1/.(n+1) in SUCC(f1/.n,S);
  given f2 being non empty FinSequence of NAT such that
A4: f2/.1 = l2 and
A5: f2/.len f2 = l3 and
A6: for n st 1 <= n & n < len f2 holds f2/.(n+1) in SUCC(f2/.n,S);
  take f1^'f2;
  thus (f1^'f2)/.1 = l1 by A1,GRAPH_2:57;
  now
    per cases;
    suppose
      f2 is trivial;
      then
A7:   ex x being Element of NAT st f2 = <*x*> by FINSEQ_6:113;
      then f1^'f2 = f1 by GRAPH_2:60;
      hence (f1^'f2)/.len(f1^'f2) = l3 by A2,A4,A5,A7,FINSEQ_1:56;
    end;
    suppose
      f2 is not trivial;
      hence (f1^'f2)/.len(f1^'f2) = l3 by A5,GRAPH_2:58;
    end;
  end;
  hence (f1^'f2)/.len(f1^'f2) = l3;
  let n such that
A8: 1 <= n and
A9: n < len(f1^'f2);
A10: len (f1^'f2) +1 = len f1 + len f2 by GRAPH_2:13;
  per cases by XXREAL_0:1;
  suppose
A11: n < len f1;
    then n+1 <= len f1 by NAT_1:13;
    then
A12: (f1^'f2)/.(n+1) = f1/.(n+1) by GRAPH_2:61,NAT_1:11;
    (f1^'f2)/.n = f1/.n by A8,A11,GRAPH_2:61;
    hence thesis by A3,A8,A11,A12;
  end;
  suppose
A13: n = len f1;
    then
A14: (f1^'f2)/.n = f2/.1 by A2,A4,A8,GRAPH_2:61;
    n+1 < len (f1^'f2) +1 by A9,XREAL_1:8;
    then
A15: 1 < len f2 by A10,A13,XREAL_1:8;
    then (f1^'f2)/.(n+1) = f2/.(1+1) by A13,GRAPH_2:62;
    hence thesis by A6,A14,A15;
  end;
  suppose
A16: n > len f1;
    then consider m being Nat such that
A17: len f1 + m = n by NAT_1:10;
    reconsider m as Element of NAT by ORDINAL1:def 13;
A18: len f1 + m > len f1 + 0 by A16,A17;
    len f1 + m+1 < len f1 + len f2 by A9,A10,A17,XREAL_1:8;
    then len f1 + (m+1) < len f1 + len f2;
    then
A19: m+1 < len f2 by XREAL_1:8;
A20: (f1^'f2)/.(n+1) = (f1^'f2)/.(len f1 + (m+1)) by A17
      .= f2/.(m+1+1) by A19,GRAPH_2:62,NAT_1:11;
    m <= m+1 by NAT_1:11;
    then m < len f2 by A19,XXREAL_0:2;
    then (f1^'f2)/.n = f2/.(m+1) by A17,A18,GRAPH_2:62,NAT_1:14;
    hence thesis by A6,A19,A20,NAT_1:11;
  end;
end;

definition
  let N, S;
  attr S is InsLoc-antisymmetric means
  for l1, l2 st l1 <= l2, S & l2 <= l1, S holds
  l1 = l2;
end;

definition
  let N, S;
  attr S is weakly_standard means
  :Def10:
  ex f being Function of NAT, NAT st f is
  bijective & for m, n being Element of NAT holds m <= n iff f.m <= f.n, S;
end;

theorem Th17:
  for f1, f2 being Function of NAT, NAT st f1 is bijective & (for
m, n being Element of NAT holds m <= n iff f1.m <= f1.n,S) & f2 is bijective &
 (for m, n being Element of NAT holds m <= n iff f2.m <= f2.n, S) holds f1 = f2
proof
  let f1, f2 be Function of NAT, NAT such that
A1: f1 is bijective and
A2: for m, n being Element of NAT holds m <= n iff f1.m <= f1.n,S and
A3: f2 is bijective and
A4: for m, n being Element of NAT holds m <= n iff f2.m <= f2.n,S;
A5: dom f1 = NAT by FUNCT_2:def 1;
A6: dom f2 = NAT by FUNCT_2:def 1;
  defpred P[Nat] means f1.$1 <> f2.$1;
  assume f1 <> f2;
  then ex c being Element of NAT st P[c] by FUNCT_2:113;
  then
A7: ex c being Nat st P[c];
  consider d being Nat such that
A8: P[d] and
A9: for n being Nat st P[n] holds d <= n from NAT_1:sch 5(A7);
  reconsider d as Element of NAT by ORDINAL1:def 13;
B1: rng f1 = NAT by A1,FUNCT_2:def 3;
B2:  rng f2 = NAT by A3,FUNCT_2:def 3;
  consider d1 being set such that
A10: d1 in dom f1 and
A11: f2.d = f1.d1 by B1,FUNCT_1:def 5;
  reconsider d1 as Element of NAT by A10;
  consider d2 being set such that
A12: d2 in dom f2 and
A13: f1.d = f2.d2 by B2,FUNCT_1:def 5;
  reconsider d2 as Element of NAT by A12;
  per cases;
  suppose
A14: d1 <= d & d2 <= d;
    then f2.d2 <= f2.d, S by A4;
    then d <= d1 by A2,A13,A11;
    hence contradiction by A8,A11,A14,XXREAL_0:1;
  end;
  suppose
A15: d <= d1 & d2 <= d;
    f2.d2 = f1.d2
    proof
      assume not thesis;
      then d <= d2 by A9;
      hence contradiction by A8,A13,A15,XXREAL_0:1;
    end;
    hence contradiction by A1,A8,A13,A5,FUNCT_1:def 8;
  end;
  suppose
A16: d1 <= d & d <= d2;
    f1.d1 = f2.d1
    proof
      assume not thesis;
      then d <= d1 by A9;
      hence contradiction by A8,A11,A16,XXREAL_0:1;
    end;
    hence contradiction by A3,A8,A11,A6,FUNCT_1:def 8;
  end;
  suppose
A17: d <= d1 & d <= d2;
    then f2.d <= f2.d2,S by A4;
    then d1 <= d by A2,A13,A11;
    hence contradiction by A8,A11,A17,XXREAL_0:1;
  end;
end;

LemRefle: k <= k, S
  proof
     reconsider l=k as Element of NAT;
     reconsider f = <*l*> as non empty FinSequence of NAT;
    take f;
    thus f/.1 = k by FINSEQ_4:25;
    hence thesis by FINSEQ_1:56;
  end;

theorem Th18:
  for f being Function of NAT, NAT st f is bijective holds
  (for m, n being Element of NAT holds m <= n iff f.m <= f.n, S)
   iff for k being Element of NAT holds f.(k+1) in SUCC(f.k,S) &
    for j being Element of NAT st f.j in SUCC(f.k,S) holds k <= j
proof
  let f be Function of NAT, NAT;
  assume
A1: f is bijective;
  hereby
    assume
A2: for m, n being Element of NAT holds m <= n iff f.m <= f.n, S;
    let k be Element of NAT;
    k <= k+1 by NAT_1:11;
    then f.k <= f.(k+1), S by A2;
    then consider F being non empty FinSequence of NAT such that
A3: F/.1 = f.k and
A4: F/.len F = f.(k+1) and
A5: for n st 1 <= n & n < len F holds F/.(n+1) in SUCC(F/.n,S) by Def8;
    set F1 = F -| f.(k+1);
    set x = (f.(k+1))..F;
A6: f.(k+1) in rng F by A4,REVROT_1:3;
    then
A7: len F1 = x-1 by FINSEQ_4:46;
    then
A8: len F1+1 = x;
A9: x in dom F by A6,FINSEQ_4:30;
    then
A10: F/.(len F1+1) = F.x by A7,PARTFUN1:def 8
      .= f.(k+1) by A6,FINSEQ_4:29;
    x <= len F by A9,FINSEQ_3:27;
    then
A11: len F1 < len F by A8,NAT_1:13;
    1 <= len F by NAT_1:14;
    then
A12: 1 in dom F by FINSEQ_3:27;
    then
A13: F/.1 = F.1 by PARTFUN1:def 8;
A14: F.x = f.(k+1) by A6,FINSEQ_4:29;
A15: dom f = NAT by FUNCT_2:def 1;
A16: f.k <> f.(k+1)
    proof
      assume not thesis;
      then 0+k = k+1 by A1,A15,FUNCT_1:def 8;
      hence contradiction;
    end;
    then len F1 <> 0 by A3,A14,A12,A7,PARTFUN1:def 8;
    then
A17: F1 is non empty FinSequence of NAT by A6,FINSEQ_4:53;
    1 <= x by A9,FINSEQ_3:27;
    then 1 < x by A3,A16,A14,A13,XXREAL_0:1;
    then
A18: 1 <= len F1 by A8,NAT_1:13;
    reconsider F1 as non empty FinSequence of NAT by A17;
    rng f = NAT by A1,FUNCT_2:def 3;
    then consider m being set such that
A19: m in dom f and
A20: f.m = F/.len F1 by FUNCT_1:def 5;
    reconsider m as Element of NAT by A19;
A21: len F1 in dom F by A18,A11,FINSEQ_3:27;
A22: len F1 in dom F1 by A18,FINSEQ_3:27;
    then
A23: F1/.len F1 = F1.len F1 by PARTFUN1:def 8
      .= F.len F1 by A6,A22,FINSEQ_4:48
      .= F/.len F1 by A21,PARTFUN1:def 8;
A24: now
      (rng F1) misses {f.(k+1)} by A6,FINSEQ_4:50;
      then rng F1 /\ {f.(k+1)} = {} by XBOOLE_0:def 7;
      then
A25:  not f.(k+1) in rng F1 or not f.(k+1) in {f.(k+1)} by XBOOLE_0:def 4;
      assume
A26:  m = k+1;
A27:  len F1 in dom F1 by A18,FINSEQ_3:27;
      then F1/.len F1 = F1.len F1 by PARTFUN1:def 8;
      hence contradiction by A20,A23,A26,A25,A27,FUNCT_1:def 5,TARSKI:def 1;
    end;
    reconsider F2 = <*F/.len F1, F/.x*> as non empty FinSequence of NAT;
A28: len F2 = 2 by FINSEQ_1:61;
    then
A29: 2 in dom F2 by FINSEQ_3:27;
    then
A30: F2/.len F2 = F2.2 by A28,PARTFUN1:def 8
      .= F/.x by FINSEQ_1:61
      .= f.(k+1) by A14,A9,PARTFUN1:def 8;
A31: 1 in dom F2 by A28,FINSEQ_3:27;
A32: now
      let n;
      assume 1 <= n & n < len F2;
      then n <> 0 & n < 2 by FINSEQ_1:61;
      then
A33:  n = 1 by NAT_1:27;
      then
A34:  F2/.n = F2.1 by A31,PARTFUN1:def 8
        .= F/.len F1 by FINSEQ_1:61;
      F2/.(n+1) = F2.2 by A29,A33,PARTFUN1:def 8
        .= F/.(len F1+1) by A7,FINSEQ_1:61;
      hence F2/.(n+1) in SUCC(F2/.n,S) by A5,A18,A11,A34;
    end;
A35: now
      let n;
      assume that
A36:  1 <= n and
A37:  n < len F1;
A38:  1 <= n+1 by A36,NAT_1:13;
A39:  n+1 <= len F1 by A37,NAT_1:13;
      then n+1 <= len F by A11,XXREAL_0:2;
      then
A40:  n+1 in dom F by A38,FINSEQ_3:27;
      n <= len F by A11,A37,XXREAL_0:2;
      then
A41:  n in dom F by A36,FINSEQ_3:27;
A42:  n in dom F1 by A36,A37,FINSEQ_3:27;
      then
A43:  F1/.n = F1.n by PARTFUN1:def 8
        .= F.n by A6,A42,FINSEQ_4:48
        .= F/.n by A41,PARTFUN1:def 8;
A44:  n < len F by A11,A37,XXREAL_0:2;
A45:  n+1 in dom F1 by A38,A39,FINSEQ_3:27;
      then F1/.(n+1) = F1.(n+1) by PARTFUN1:def 8
        .= F.(n+1) by A6,A45,FINSEQ_4:48
        .= F/.(n+1) by A40,PARTFUN1:def 8;
      hence F1/.(n+1) in SUCC(F1/.n,S) by A5,A36,A43,A44;
    end;
    F2/.1 = F2.1 by A31,PARTFUN1:def 8
      .= f.m by A20,FINSEQ_1:61;
    then f.m <= f.(k+1), S by A30,A32,Def8;
    then
A46: m <= k+1 by A2;
A47: 1 in dom F1 by A18,FINSEQ_3:27;
    then F1/.1 = F1.1 by PARTFUN1:def 8
      .= F.1 by A6,A47,FINSEQ_4:48
      .= f.k by A3,A12,PARTFUN1:def 8;
    then f.k <= f.m, S by A20,A23,A35,Def8;
    then k <= m by A2;
    then m = k or m = k+1 by A46,NAT_1:9;
    hence f.(k+1) in SUCC(f.k,S) by A5,A18,A11,A10,A20,A24;
    let j be Element of NAT;
    reconsider fk=f.k, fj=f.j as Element of NAT;
    reconsider F = <*fk, fj*> as non empty FinSequence of NAT;
A48: len F = 2 by FINSEQ_1:61;
    then
A49: 2 in dom F by FINSEQ_3:27;
A50: 1 in dom F by A48,FINSEQ_3:27;
    then
A51: F/.1 = F.1 by PARTFUN1:def 8
      .= f.k by FINSEQ_1:61;
    assume
A52: f.j in SUCC(f.k,S);
A53: now
      let n be Element of NAT;
      assume 1 <= n & n < len F;
      then n <> 0 & n < 2 by FINSEQ_1:61;
      then
A54:  n = 1 by NAT_1:27;
      then
A55:  F/.n = F.1 by A50,PARTFUN1:def 8
        .= f.k by FINSEQ_1:61;
      F/.(n+1) = F.2 by A49,A54,PARTFUN1:def 8
        .= f.j by FINSEQ_1:61;
      hence F/.(n+1) in SUCC(F/.n,S) by A52,A55;
    end;
    F/.len F = F.2 by A48,A49,PARTFUN1:def 8
      .= f.j by FINSEQ_1:61;
    then f.k <= f.j, S by A51,A53,Def8;
    hence k <= j by A2;
  end;
  assume
A56: for k being Element of NAT holds f.(k+1) in SUCC(f.k,S) & for j
  being Element of NAT st f.j in SUCC(f.k,S) holds k <= j;
  let m, n be Element of NAT;
  hereby
    assume
A57: m <= n;
    per cases by A57,XXREAL_0:1;
    suppose
      m = n;
      hence f.m <= f.n, S by LemRefle;
    end;
    suppose
A58:  m < n;
      thus f.m <= f.n, S
      proof
        reconsider f9=f as Function of NAT, NAT;
        set mn = n -' m;
        deffunc F(Nat) = f9.(m+$1-'1);
        consider F being FinSequence of NAT such that
A59:    len F = mn+1 and
A60:    for j being Nat st j in dom F holds F.j = F(j) from FINSEQ_2:
        sch 1;
        reconsider F as non empty FinSequence of NAT by A59;
        take F;
A61:    1 <= mn+1 by NAT_1:11;
        then
A62:    1 in dom F by A59,FINSEQ_3:27;
        hence F/.1 = F.1 by PARTFUN1:def 8
          .= f.(m+1-'1) by A60,A62
          .= f.m by NAT_D:34;
        m+1 <= n by A58,INT_1:20;
        then 1 <= n-m by XREAL_1:21;
        then 0 <= n-m by XXREAL_0:2;
        then
A63:    mn = n - m by XREAL_0:def 2;
A64:    len F in dom F by A59,A61,FINSEQ_3:27;
        hence F/.len F = F.len F by PARTFUN1:def 8
          .= f.(m+(mn+1)-'1) by A59,A60,A64
          .= f.(m+mn+1-'1)
          .= f.n by A63,NAT_D:34;
        let p be Element of NAT;
        assume that
A65:    1 <= p and
A66:    p < len F;
A67:    p in dom F by A65,A66,FINSEQ_3:27;
        then
A68:    F/.p = F.p by PARTFUN1:def 8
          .= f.(m+p-'1) by A60,A67;
A69:    p <= m+p by NAT_1:11;
        1 <= p+1 & p+1 <= len F by A65,A66,NAT_1:13;
        then
A70:    p+1 in dom F by FINSEQ_3:27;
        then F/.(p+1) = F.(p+1) by PARTFUN1:def 8
          .= f.(m+(p+1)-'1) by A60,A70
          .= f.(m+p+1-'1)
          .= f.(m+p-'1+1) by A65,A69,NAT_D:38,XXREAL_0:2;
        hence thesis by A56,A68;
      end;
    end;
  end;
  assume f.m <= f.n, S;
  then consider F being non empty FinSequence of NAT such that
A71: F/.1 = f.m and
A72: F/.len F = f.n and
A73: for n being Element of NAT st 1 <= n & n < len F holds F/.(n+1) in
  SUCC(F/.n,S) by Def8;
  defpred P[Element of NAT] means 1 <= $1 & $1 <= len F implies ex l being
  Element of NAT st F/.$1 = f.l & m <= l;
A74: now
    let k be Element of NAT such that
A75: P[k];
    now
      assume that
      1 <= k+1 and
A76:  k+1 <= len F;
      per cases by NAT_1:3;
      suppose
        k = 0;
        hence ex l being Element of NAT st F/.(k+1) = f.l & m <= l by A71;
      end;
      suppose
A77:    k > 0;
        rng f = NAT by A1,FUNCT_2:def 3;
        then consider l1 being set such that
A78:    l1 in dom f and
A79:    f.l1 = F/.(k+1) by FUNCT_1:def 5;
        consider l being Element of NAT such that
A80:    F/.k = f.l and
A81:    m <= l by A75,A76,A77,NAT_1:13,14;
        reconsider l1 as Element of NAT by A78;
        k < len F by A76,NAT_1:13;
        then F/.(k+1) in SUCC(F/.k,S) by A73,A77,NAT_1:14;
        then l <= l1 by A56,A80,A79;
        hence
        ex l being Element of NAT st F/.(k+1) = f.l & m <= l by A81,A79,
XXREAL_0:2;
      end;
    end;
    hence P[k+1];
  end;
A82: 1 <= len F by NAT_1:14;
A83: P[0];
  for k being Element of NAT holds P[k] from NAT_1:sch 1(A83, A74);
  then dom f = NAT & ex l being Element of NAT st F/.len F = f.l & m <= l by
A82,FUNCT_2:def 1;
  hence thesis by A1,A72,FUNCT_1:def 8;
end;

theorem Th19:
  S is weakly_standard iff ex f being Function of NAT, NAT st f is
  bijective & for k being Element of NAT holds f.(k+1) in SUCC(f.k,S) & for j
  being Element of NAT st f.j in SUCC(f.k,S) holds k <= j
proof
  hereby
    assume S is weakly_standard;
    then consider f being Function of NAT, NAT such that
A1: f is bijective and
A2: for m, n being Element of NAT holds m <= n iff f.m <= f.n, S by Def10;
    thus ex f being Function of NAT, NAT st f is bijective & for k being
Element of NAT holds f.(k+1) in SUCC(f.k,S) & for j being Element of NAT st f.j
    in SUCC(f.k,S) holds k <= j
    proof
      take f;
      thus f is bijective by A1;
      thus thesis by A1,A2,Th18;
    end;
  end;
  given f be Function of NAT, NAT such that
A3: f is bijective and
A4: for k being Element of NAT holds f.(k+1) in SUCC(f.k,S) & for j being
  Element of NAT st f.j in SUCC(f.k,S) holds k <= j;
  take f;
  thus f is bijective by A3;
  thus thesis by A3,A4,Th18;
end;

set III = {[1,0,0],[0,0,0]};

begin :: Standard trivial computer

Lm4: for i being Instruction of STC N, s being State of STC N st InsCode i = 1
holds Exec(i,s).IC STC N = succ (IC s)

proof
  let i be Instruction of STC N, s be State of STC N;
  set M = STC N;
  assume
A1: InsCode i = 1;
A2: now
    assume i in {[0,0,0]};
    then i = [0,0,0] by TARSKI:def 1;
    hence contradiction by A1,RECDEF_2:def 1;
  end;
  the Instructions of M = III by AMISTD_1:def 11;
  then i = [1,0,0] or i = [0,0,0] by TARSKI:def 2;
  then
A3: i in {[1,0,0]} by A1,RECDEF_2:def 1,TARSKI:def 1;
A4: NAT in {NAT} by TARSKI:def 1;
  then
A5: NAT in dom (NAT .-->succ(s.NAT)) by FUNCOP_1:19;

  consider f be Function of product the Object-Kind of M, product the
  Object-Kind of M such that
A6: for s being Element of product the Object-Kind of M holds f.s = s+*(
  NAT .-->succ(s.NAT)) and

A7: the Execution of M = ([1,0,0] .--> f) +* ([0,0,0] .--> id product the
  Object-Kind of M) by AMISTD_1:def 11;
B6: for s being State of M holds f.s = s+*(NAT .-->succ(s.NAT))
 proof let s be State of M;
  reconsider s as Element of product the Object-Kind of M by PBOOLE:155;
  f.s = s+*(NAT .-->succ(s.NAT)) by A6;
  hence thesis;
 end;

A8: the Instruction-Counter of M = NAT by AMISTD_1:def 11;
  dom ([0,0,0] .--> id product the Object-Kind of M) = {[0,0,0]}
   by FUNCOP_1:19;
  then (the Execution of M).i = ([1,0,0] .--> f).i by A7,A2,FUNCT_4:12
    .= f by A3,FUNCOP_1:13;
  hence Exec(i,s).IC STC N = (s+*(NAT .-->succ(s.NAT))).NAT by A8,B6
    .= (NAT .-->succ(s.NAT)).NAT by A5,FUNCT_4:14
    .= succ (IC s) by A8,A4,FUNCOP_1:13;
end;

Lm5: for l being Element of NAT, i being Element of the
Instructions of STC N st l = z & InsCode i = 1 holds NIC(i, l) = {z+1}
proof
  let l be Element of NAT, i be Element of the Instructions of STC N;
  assume that
A1: l = z and
A2: InsCode i = 1;
  set M = STC N;
  set F = { IC Exec(i,ss)
    where ss is Element of product the Object-Kind of STC N:
    IC ss = l };
  now
    set f = (NAT) --> i;
    consider w being State of M;
    reconsider l9 = l as Element of ObjectKind IC M by COMPOS_1:def 6;
    set u = (IC M).-->l9;
A4: dom u = {IC M} by FUNCOP_1:19;
    reconsider s = w +* f as State of M;
    let y be set;
A5: dom f = NAT by FUNCOP_1:19;
    reconsider t = s+*u as Element of product the Object-Kind of STC N
     by PBOOLE:155;
    l <> IC M by COMPOS_1:3;
    then
X:    not l in dom u by A4,TARSKI:def 1;
A6: (ProgramPart t)/.l = t.l by COMPOS_1:38
      .= s.l by X,FUNCT_4:12
      .= f.l by A5,FUNCT_4:14
      .= i by FUNCOP_1:13;
    hereby
      assume y in F;
      then ex s being Element of product the Object-Kind of STC N
      st y = IC Exec(i,s) & IC s = l;
      then y = succ z by A1,A2,Lm4
        .= z+1;
      hence y in {z+1} by TARSKI:def 1;
    end;
    assume y in {z+1};
    then
A7: y = z+1 by TARSKI:def 1
      .= succ z;
    IC M in dom u by A4,TARSKI:def 1;
    then
A8: IC t = u.IC M by FUNCT_4:14
      .= z by A1,FUNCOP_1:87;
    then IC Following(ProgramPart t,t) = succ z by A1,A2,A6,Lm4;
    hence y in F by A1,A7,A8,A6;
  end;
  hence thesis by TARSKI:2;
end;

canceled 5;

registration
  let N be with_non-empty_elements non empty set;
  cluster STC N -> weakly_standard;
  coherence
  proof
    reconsider f = id NAT as Function of NAT, NAT;
    set M = STC N;
    now
      let k be Element of NAT;
      reconsider fk = f.k as Element of NAT;
A1:   SUCC(fk,STC N) = {k,k+1} by AMISTD_1:24,FUNCT_1:35;
      f.(k+1) = k+1 by FUNCT_1:35;
      hence f.(k+1) in SUCC(f.k,STC N) by A1,TARSKI:def 2;
      let j be Element of NAT;
      assume f.j in SUCC(f.k,STC N);
      then f.j = k or f.j = k+1 by A1,TARSKI:def 2;
      then j = k+1 or j = k by FUNCT_1:35;
      hence k <= j by NAT_1:11;
    end;
    hence thesis by Th19;
  end;
end;

registration
  let N be with_non-empty_elements non empty set;
  cluster weakly_standard halting realistic steady-programmed
standard-ins (IC-Ins-separated definite (non empty stored-program AMI-Struct
    over N));
  existence
  proof
    take STC N;
    thus thesis;
  end;
end;

reserve T for weakly_standard
 (IC-Ins-separated definite (non empty stored-program
  AMI-Struct over N));

definition
 canceled;
  let N be with_non-empty_elements non empty set,
  S be weakly_standard (IC-Ins-separated definite
   (non empty stored-program AMI-Struct over N)), k be natural number;
  func il.(S,k) -> Element of NAT means
  :Def12:
  ex f being
Function of NAT, NAT st f is bijective & (for m, n being Element of NAT holds
  m <= n iff f.m <= f.n, S) & it = f.k;
  existence
  proof
    reconsider k as Element of NAT by ORDINAL1:def 13;
    consider f being Function of NAT, NAT such that
A1: f is bijective & for m, n being Element of NAT holds m <= n iff f.
    m <= f.n, S by Def10;
      reconsider fk = f.k as Element of NAT;
    take fk;
    take f;
    thus thesis by A1;
  end;
  uniqueness by Th17;
end;

theorem Th25:
  for N,T
  for k1, k2 being natural number st il.(T,k1) = il.(T,k2) holds
  k1 = k2
proof let N,T;
  let k1, k2 be natural number;
  assume
A1: il.(T,k1) = il.(T,k2);
A2: k1 is Element of NAT & k2 is Element of NAT by ORDINAL1:def 13;
  consider f2 being Function of NAT, NAT such that
A3: f2 is bijective & for m, n being Element of NAT holds m <= n iff f2.
  m <= f2. n, T and
A4: il.(T,k2) = f2.k2 by Def12;
  consider f1 being Function of NAT, NAT such that
A5: f1 is bijective and
A6: for m, n being Element of NAT holds m <= n iff f1.m <= f1.n, T and
A7: il.(T,k1) = f1.k1 by Def12;
A8: dom f1 = NAT by FUNCT_2:def 1;
  f1 = f2 by A5,A6,A3,Th17;
  hence thesis by A1,A2,A5,A7,A4,A8,FUNCT_1:def 8;
end;

theorem Th26:
  for l being Nat ex k being natural number st l = il.(T,k)
proof
  let l be Nat;
  consider f1 being Function of NAT, NAT such that
A1: f1 is bijective and
A2: for m, n being Element of NAT holds m <= n iff f1.m <= f1.n, T and
  il.(T,0) = f1.0 by Def12;
  l in NAT & rng f1 = NAT by A1,FUNCT_2:def 3,ORDINAL1:def 13;
  then consider k being set such that
A3: k in dom f1 and
A4: f1.k = l by FUNCT_1:def 5;
  reconsider k as Nat by A3;
  take k;
  l in NAT by ORDINAL1:def 13;
  then reconsider l as Element of NAT;
   l = il.(T,k) by A1,A2,A4,Def12;
  hence thesis;
end;

definition
  let N be with_non-empty_elements non empty set,
  S be weakly_standard (IC-Ins-separated
  definite (non empty stored-program AMI-Struct over N)), l be Nat;
  func locnum(l,S) -> natural number means
  :Def13:
  il.(S,it) = l;
  existence by Th26;
  uniqueness by Th25;
end;

definition
  let N be with_non-empty_elements non empty set,
  S be weakly_standard (IC-Ins-separated
  definite (non empty stored-program AMI-Struct over N)), l be Nat;
  redefine func locnum(l,S) -> Element of NAT;
  coherence by ORDINAL1:def 13;
end;

theorem Th27:
  for l1, l2 being Element of NAT holds locnum(l1,T) =
  locnum(l2,T) implies l1 = l2
proof
  let l1, l2 be Element of NAT;
  assume
A1: locnum(l1,T) = locnum(l2,T);
  il.(T,locnum(l1,T)) = l1 by Def13;
  hence thesis by A1,Def13;
end;

theorem Th28:
  for N,T
  for k1, k2 being natural number holds il.(T,k1) <= il.(T,k2), T iff
  k1 <= k2
proof let N,T;
  let k1, k2 be natural number;
A1: k1 is Element of NAT & k2 is Element of NAT by ORDINAL1:def 13;
  consider f2 being Function of NAT, NAT such that
A2: f2 is bijective & for m, n being Element of NAT holds m <= n iff f2.
  m <= f2. n, T and
A3: il.(T,k2) = f2.k2 by Def12;
  consider f1 being Function of NAT, NAT such that
A4: f1 is bijective and
A5: for m, n being Element of NAT holds m <= n iff f1.m <= f1.n, T and
A6: il.(T,k1) = f1.k1 by Def12;
  f1 = f2 by A4,A5,A2,Th17;
  hence thesis by A1,A5,A6,A3;
end;

theorem Th29:
  for N,T
  for l1, l2 being Element of NAT holds locnum(l1,T) <=
  locnum(l2,T) iff l1 <= l2, T
proof let N,T;
  let l1, l2 be Element of NAT;
  il.(T,locnum(l1,T)) = l1 & il.(T,locnum(l2,T)) = l2 by Def13;
  hence thesis by Th28;
end;

theorem Th30:
  for N,T holds T is InsLoc-antisymmetric
proof let N,T;
  let l1, l2 be Element of NAT;
  assume
A1: l1 <= l2, T & l2 <= l1, T;
  reconsider T as weakly_standard (IC-Ins-separated definite (non empty
  stored-program AMI-Struct over N));
  reconsider l1, l2 as Element of NAT;
  locnum(l1,T) <= locnum(l2,T) & locnum(l2,T) <= locnum(l1,T) by A1,Th29;
  hence thesis by Th27,XXREAL_0:1;
end;

registration
  let N;
  cluster weakly_standard -> InsLoc-antisymmetric
   (IC-Ins-separated definite (non
    empty stored-program AMI-Struct over N));
  coherence by Th30;
end;

definition
  let N be with_non-empty_elements non empty set,
  S be weakly_standard (IC-Ins-separated
  definite (non empty stored-program AMI-Struct over N)), f be
  Element of NAT, k be natural number;
  func f +(k,S) -> Element of NAT equals
  il.(S,locnum(f,S) + k);
  coherence;
end;

theorem
  for f being Element of NAT holds f + (0,T) = f by Def13;

theorem
  for f, g being Element of NAT st f + (z,T) = g + (z,T)
   holds f = g
proof
  let f, g be Element of NAT;
  assume f + (z,T) = g + (z,T);
  then locnum(f,T) + z = locnum(g,T) + z by Th25;
  hence thesis by Th27;
end;

theorem
  for f being Element of NAT
   holds locnum(f,T) + z = locnum(f+(z,T),T) by Def13;

definition
  let N be with_non-empty_elements non empty set,
  S be weakly_standard (IC-Ins-separated
  definite (non empty stored-program AMI-Struct over N)), f be
  Element of NAT;
  func NextLoc(f,S) -> Element of NAT equals
  f + (1,S);
  coherence;
end;

theorem
  for f being Element of NAT
   holds NextLoc(f,T) = il.(T,locnum(f,T)+ 1);

theorem Th35:
  for f being Element of NAT holds f <> NextLoc(f,T)
proof
  let f be Element of NAT;
  assume f = NextLoc(f,T);
  then locnum(f,T) = locnum(f,T) + 1 by Def13;
  hence thesis;
end;

theorem
  for f, g being Element of NAT st NextLoc(f,T) = NextLoc(g,T)
  holds f = g
proof
  let f, g be Element of NAT such that
A1: NextLoc(f,T) = NextLoc(g,T);
  set m = locnum(g,T);
  set k = locnum(f,T);
  k+0 = k+1-1
    .= m+1-1 by A1,Th25
    .= m+0;
  hence thesis by Th27;
end;

theorem Th37:
  il.(STC N, z) = z
proof
  set M = STC N;
  reconsider f2 = id NAT as Function of NAT, NAT;
  consider f being Function of NAT, NAT such that
A1: f is bijective & for m, n being Element of NAT holds m <= n iff f.m
  <= f.n, STC N and
A2: il.(M,z) = f.z by Def12;
  now
    let k be Element of NAT;
      reconsider fk = f2.k as Element of NAT;
A3: SUCC(fk,STC N) = {k,k+1} by AMISTD_1:24,FUNCT_1:35;
    f2.(k+1) = k+1 by FUNCT_1:35;
    hence f2.(k+1) in SUCC(f2.k,STC N) by A3,TARSKI:def 2;
    let j be Element of NAT;
A4: j = f2.j by FUNCT_1:35;
    assume f2.j in SUCC(f2.k,STC N);
    then j = k or j = k+1 by A3,A4,TARSKI:def 2;
    hence k <= j by NAT_1:11;
  end;
  then for m, n being Element of NAT holds m <= n iff f2.m <= f2.n, M by Th18;
  then z is Element of NAT & f = f2 by A1,Th17,ORDINAL1:def 13;
  hence thesis by A2,FUNCT_1:35;
end;

theorem
  for i being Instruction of STC N, s being State of STC N st InsCode i
  = 1 holds Exec(i,s).IC STC N = NextLoc(IC s,STC N)
proof
  let i be Instruction of STC N, s be State of STC N;
  set M = STC N;
  set k = locnum(IC s,STC N);
  reconsider K = IC s as Element of NAT;
  assume InsCode i = 1;
  then
A1: Exec(i,s).IC STC N = succ IC s by Lm4
    .= K+1;
  il.(M,k) = k & il.(M,k+1) = k+1 by Th37;
  hence thesis by A1,Def13;
end;

theorem
  for l being Element of NAT, i being Element of the
  Instructions of STC N st InsCode i = 1 holds NIC(i, l) = {NextLoc(l,STC N)}
proof
  let l be Element of NAT, i be Element of the Instructions of
  STC N;
  assume
A1: InsCode i = 1;
  set M = STC N;
  consider k being natural number such that
A2: l = il.(M,k) by Th26;
  k = locnum(l,M) by A2,Def13;
  then NextLoc(l,STC N) = k+1 by Th37;
  hence thesis by A1,A2,Lm5,Th37;
end;

theorem
  for l being Element of NAT holds SUCC(l,STC N) = {l, NextLoc(l,STC N)}
proof
  let l be Element of NAT;
  set M = STC N;
  consider k being natural number such that
A1: l = il.(M,k) by Th26;
A2: k = locnum(l,M) by A1,Def13;
  thus SUCC(l,STC N) = {k,k+1} by A1,Th37,AMISTD_1:24
    .= {k,il.(M,k+1)} by Th37
    .= {l, NextLoc(l,STC N)} by A1,A2,Th37;
end;

definition
  let N be with_non-empty_elements non empty set,
  S be weakly_standard (IC-Ins-separated
definite (non empty stored-program AMI-Struct over N)), i be Instruction of
  S;
  attr i is sequential means
  for s being State of S holds Exec(i, s).IC S = NextLoc(IC s,S);
end;

theorem Th41:
  for S being weakly_standard realistic
   (IC-Ins-separated definite steady-programmed
   (non empty stored-program AMI-Struct over N)), il being Element of NAT,
  i being Instruction of S st i is sequential holds NIC(i,il)
   = {NextLoc(il,S)}
proof
  let S be weakly_standard realistic
   (IC-Ins-separated definite steady-programmed
   (non empty
  stored-program AMI-Struct over N)), il be Element of NAT, i be
  Instruction of S such that
A1: for s being State of S holds Exec(i, s).IC S = NextLoc(IC s,S);
  now
    let x be set;
A2: now
      reconsider il1 = il as Element of ObjectKind IC S by COMPOS_1:def 6;
      reconsider I = i as Element of (the Object-Kind of S).il by
COMPOS_1:def 8;
      consider t being State of S;
      assume
A3:   x = NextLoc(il,S);
      reconsider f = (IC S,il) --> (il1,I) as PartState of S by COMPOS_1:37;
      reconsider u = t+*f as
       Element of product the Object-Kind of S by PBOOLE:155;
A4:   dom ((IC S, il)-->(il1, I)) = {IC S, il} by FUNCT_4:65;
      then
X:     il in dom ((IC S, il)-->(il1, I)) by TARSKI:def 2;
A5:   (ProgramPart u)/.il = u.il by COMPOS_1:38
        .= ((IC S, il)-->(il1, I)).il by X,FUNCT_4:14
        .= i by FUNCT_4:66;
      IC S in dom ((IC S, il)-->(il1, I)) by A4,TARSKI:def 2;
      then
A6:   IC u = ((IC S, il)-->(il1, I)).IC S by FUNCT_4:14
        .= il by COMPOS_1:3,FUNCT_4:66;
      then IC Following(ProgramPart u,u) = NextLoc(il,S) by A1,A5;
      hence x in {IC Exec(i,ss)
       where ss is Element of product the Object-Kind of S
        : IC ss = il } by A3,A6,A5;
    end;
    now
      assume x in {IC Exec(i,ss)
       where ss is Element of product the Object-Kind of S
      : IC ss = il};
      then ex s being Element of product the Object-Kind of S
       st x = IC Exec(i,s) & IC s = il;
      hence x = NextLoc(il,S) by A1;
    end;
    hence
    x in {NextLoc(il,S)} iff x in {IC Exec(i,ss)
       where ss is Element of product the Object-Kind of S: IC ss = il}
     by A2,TARSKI:def 1;
  end;
  hence thesis by TARSKI:2;
end;

theorem Th42:
  for S being realistic weakly_standard (IC-Ins-separated definite
   steady-programmed (non
empty stored-program AMI-Struct over N)), i being Instruction of S st i is
  sequential holds i is non halting
proof
  let S be realistic weakly_standard (IC-Ins-separated definite
   steady-programmed (non empty
  stored-program AMI-Struct over N)), i be Instruction of S such that
A1: i is sequential;
  consider s being State of S;
  NIC(i,IC s) = {NextLoc(IC s,S)} by A1,Th41;
  then NIC(i,IC s) <> {IC s} by Th35,ZFMISC_1:6;
  hence thesis by AMISTD_1:15;
end;

registration
  let N;
  let S be realistic weakly_standard (IC-Ins-separated definite
   steady-programmed (non empty stored-program AMI-Struct over N));
  cluster sequential -> non halting Instruction of S;
  coherence by Th42;
  cluster halting -> non sequential Instruction of S;
  coherence;
end;

canceled;

begin :: Closedness of finite partial states

definition
 canceled 2;
  let N be with_non-empty_elements non empty set;
  let S be weakly_standard (IC-Ins-separated definite (non empty stored-program
  AMI-Struct over N));
  let F be NAT-defined (the Instructions of S)-valued Function;
  attr F is para-closed means
  for s being State of S st IC s = il.(S,0)
   for k being Element of NAT holds IC Comput(F,s,k) in dom F;
end;

theorem Th44:
  for S being weakly_standard steady-programmed (IC-Ins-separated
definite (non empty stored-program AMI-Struct over N)),
   F being NAT-defined (the Instructions of S)-valued
  FinPartState of S st F is really-closed & il.(S,0) in dom F holds F is
  para-closed
proof
  let S be weakly_standard steady-programmed
   (IC-Ins-separated definite (non empty
stored-program AMI-Struct over N)),
      F be NAT-defined (the Instructions of S)-valued
   FinPartState of S such that
A1: ( for s being State of S st IC s in dom F
  for k being
  Element of NAT holds IC Comput(F,s,k) in dom F)& il.(S,0) in dom F;
  let s be State of S;
  assume IC s = il.(S,0);
  hence thesis by A1;
end;

canceled;

theorem Th46:
  for S being weakly_standard realistic halting (IC-Ins-separated
definite steady-programmed
 (non empty stored-program AMI-Struct over N)) holds il.(S,0) .-->
  halt S qua NAT-defined (the Instructions of S)-valued
   FinPartState of S is closed
proof
  let S be weakly_standard realistic halting (IC-Ins-separated definite
   steady-programmed (non empty
  stored-program AMI-Struct over N));
  reconsider F = il.(S,0) .--> halt S as
   NAT-defined (the Instructions of S)-valued FinPartState of S;
  let l be Element of NAT;
  assume
A1: l in dom(il.(S,0) .--> halt S);
A2: dom F = {il.(S,0)} by FUNCOP_1:19;
  then
A3: l = il.(S,0) by A1,TARSKI:def 1;
  F/.l = F.l by A1,PARTFUN1:def 8
    .= halt S by A3,FUNCOP_1:87;
  hence thesis by A2,A3,AMISTD_1:15;
end;

definition

  let N be with_non-empty_elements non empty set;
  let S be IC-Ins-separated definite (non empty stored-program AMI-Struct over
  N);
  let F be FinPartState of S;
  attr F is lower means
  :Def20:
  for l being Element of NAT st l in
  dom F holds for m being Element of NAT st m <= l, S
   holds m in dom F;
end;

theorem Th47:
  for F being empty FinPartState of S holds F is lower
proof
  let F be empty FinPartState of S;
  let l be Element of NAT;
  assume l in dom F;
  hence thesis;
end;

registration
  let N be with_non-empty_elements non empty set,
  S be IC-Ins-separated definite (non
  empty stored-program AMI-Struct over N);
  cluster empty -> lower FinPartState of S;
  coherence by Th47;
end;

theorem Th48:
  for i being Element of the Instructions of T holds il.(T,0) .-->
  i is lower
proof
  let i be Element of the Instructions of T;
  set F = il.(T,0).--> i;
  let l be Element of NAT such that
A1: l in dom F;
  let m be Element of NAT such that
A2: m <= l, T;
  consider k being natural number such that
A3: m = il.(T,k) by Th26;
  dom F = {il.(T,0)} by FUNCOP_1:19;
  then
A4: l = il.(T,0) by A1,TARSKI:def 1;
  then 0 <= k & k <= 0 by A2,A3,Th28,NAT_1:2;
  hence thesis by A1,A4,A3,XXREAL_0:1;
end;

registration
  let N be with_non-empty_elements non empty set;
  let S be weakly_standard (IC-Ins-separated definite (non empty stored-program
  AMI-Struct over N));
  cluster lower non empty trivial NAT-defined
     (the Instructions of S)-valued FinPartState of S;
  existence
  proof
    consider i being Instruction of S;
    take il.(S,0).--> i;
    thus thesis by Th48;
  end;
end;

theorem Th49:
  for F being lower non empty NAT-defined FinPartState of T holds
  il.(T,0) in dom F
proof
  let F be lower non empty NAT-defined FinPartState of T;
  consider l being set such that
A1: l in dom F by XBOOLE_0:def 1;
    dom F c= NAT by RELAT_1:def 18;
  then reconsider l as Element of NAT by A1;
  consider f being Function of NAT, NAT such that
A3: f is bijective and
A4: for m, n being Element of NAT holds m <= n iff f.m <= f.n, T and
A5: il.(T,0) = f.0 by Def12;
  rng f = NAT by A3,FUNCT_2:def 3;
  then consider x being set such that
A6: x in dom f and
A7: l = f.x by FUNCT_1:def 5;
  reconsider x as Element of NAT by A6;
  0 <= x by NAT_1:2;
  then f.0 <= f.x, T by A4;
  hence thesis by A1,A5,A7,Def20;
end;

theorem Th50:
  for P being lower NAT-defined FinPartState of T holds z < card P
  iff il.(T,z) in dom P
proof
  let P be lower NAT-defined FinPartState of T;
  deffunc F(Element of NAT) = il.(T,$1);
  defpred P[Element of NAT] means F($1) in dom P;
  set A = { k : P[k]};
A1: A is Subset of NAT from DOMAIN_1:sch 7;
A2: now
    let a, b be Element of NAT;
    assume a in A;
    then
A3: ex l being Element of NAT st l = a & il.(T,l) in dom P;
    assume b < a;
    then il.(T,b) <= il.(T,a), T by Th28;
    then il.(T,b) in dom P by A3,Def20;
    hence b in A;
  end;
A4: now
    let x be set;
A5: dom P c= NAT by RELAT_1:def 18;
    assume x in dom P;
    then reconsider l=x as Element of NAT by A5;
    consider n being natural number such that
A6: l = il.(T,n) by Th26;
    reconsider n as Element of NAT by ORDINAL1:def 13;
    take n;
    thus x = F(n) by A6;
  end;
  reconsider A as Cardinal by A1,A2,FUNCT_7:22;
  set A1 = {k : F(k) in dom P};
A7: z is Element of NAT by ORDINAL1:def 13;
A8: card A = A by CARD_1:def 5;
A9: for k1, k2 being Element of NAT st F(k1) = F(k2) holds k1 = k2 by Th25;
A10: dom P, A1 are_equipotent from FUNCT_7:sch 3(A4,A9);
A11: card z = z by CARD_1:def 5;
  hereby
    assume z < card P;
    then card z in card card P by NAT_1:42;
    then z in card dom P by A11,CARD_1:104;
    then z in card A by A10,CARD_1:21;
    then ex d being Element of NAT st d = z & il.(T,d) in dom P by A8;
    hence il.(T,z) in dom P;
  end;
  assume il.(T,z) in dom P;
  then z in card A by A7,A8;
  then z in card dom P by A10,CARD_1:21;
  then card z in card card P by A11,CARD_1:104;
  hence thesis by NAT_1:42;
end;

definition
  let N be with_non-empty_elements non empty set;
  let S be weakly_standard (IC-Ins-separated definite (non empty stored-program
  AMI-Struct over N));
  let F be non empty NAT-defined FinPartState of S;
  func LastLoc F -> Element of NAT means
  :Def21:
  ex M being finite
  non empty natural-membered set st M = { locnum(l,S) where l is
  Element of NAT : l in dom F } & it = il.(S, max M);
  existence
  proof
    deffunc F(Element of NAT) = locnum($1,S);
    set M = { F(l) where l is Element of NAT : l in dom F };
    consider l being Element of dom F;
    l in dom F & dom F c= NAT by RELAT_1:def 18;
    then reconsider l as Element of NAT;
A1: locnum(l,S) in M;
A2: M c= NAT
    proof
      let k be set;
      assume k in M;
      then
      ex l being Element of NAT st k = locnum(l,S) & l in dom F;
      hence thesis;
    end;
A3: dom F is finite;
    M is finite from FRAENKEL:sch 21(A3);
    then reconsider M as finite non empty Subset of NAT by A1,A2;
    take il.(S, max M), M;
    thus thesis;
  end;
  uniqueness;
end;

theorem Th51:
  for F being non empty NAT-defined FinPartState of T holds
  LastLoc F in dom F
proof
  let F be non empty NAT-defined FinPartState of T;
  consider M being finite non empty natural-membered set such that
A1: M = { locnum(l,T) where l is Element of NAT : l in dom F } and
A2: LastLoc F = il.(T, max M) by Def21;
  max M in M by XXREAL_2:def 8;
  then
  ex l being Element of NAT st max M = locnum(l,T) & l in dom F
  by A1;
  hence thesis by A2,Def13;
end;

theorem
  for F, G being non empty NAT-defined FinPartState of T st F c= G holds
  LastLoc F <= LastLoc G, T
proof
  let F, G be non empty NAT-defined FinPartState of T such that
A1: F c= G;
  consider N being finite non empty natural-membered set such that
A2: N = { locnum(l,T) where l is Element of NAT : l in dom G } and
A3: LastLoc G = il.(T, max N) by Def21;
  consider M being finite non empty natural-membered set such that
A4: M = { locnum(l,T) where l is Element of NAT : l in dom F } and
A5: LastLoc F = il.(T, max M) by Def21;
  reconsider MM = M, NN = N as non empty finite Subset of REAL by MEMBERED:3;
  M c= N
  proof
    let a be set;
    assume a in M;
    then
A6: ex l being Element of NAT st a = locnum(l,T) & l in dom F by A4;
    dom F c= dom G by A1,GRFUNC_1:8;
    hence thesis by A2,A6;
  end;
  then max MM <= max NN by XXREAL_2:59;
  hence thesis by A5,A3,Th28;
end;

theorem Th53:
  for F being non empty NAT-defined FinPartState of T, l being
  Element of NAT st l in dom F holds l <= LastLoc F, T
proof
  let F be non empty NAT-defined FinPartState of T, l be Element of NAT
   such that
A1: l in dom F;
  consider M being finite non empty natural-membered set such that
A2: M = { locnum(w,T) where w is Element of NAT : w in dom F } and
A3: LastLoc F = il.(T, max M) by Def21;
  locnum(l,T) in M by A1,A2;
  then
A4: locnum(l,T) <= max M by XXREAL_2:def 8;
  locnum(LastLoc F,T) = max M by A3,Def13;
  hence thesis by A4,Th29;
end;

theorem
  for F being lower non empty NAT-defined FinPartState of T, G being non
  empty NAT-defined FinPartState of T holds F c= G & LastLoc F = LastLoc G
  implies F = G
proof
  let F be lower non empty NAT-defined FinPartState of T, G be non empty NAT
  -defined FinPartState of T such that
A1: F c= G and
A2: LastLoc F = LastLoc G;
  dom F = dom G
  proof
    thus dom F c= dom G by A1,GRFUNC_1:8;
    let x be set;
    assume
A3: x in dom G;
    dom G c= NAT by RELAT_1:def 18;
    then reconsider x as Element of NAT by A3;
A4: LastLoc F in dom F by Th51;
    x <= LastLoc F, T by A2,A3,Th53;
    hence thesis by A4,Def20;
  end;
  hence thesis by A1,GRFUNC_1:9;
end;

theorem Th55:
  for F being lower non empty NAT-defined FinPartState of T holds
  LastLoc F = il.(T, card F -' 1)
proof
  let F be lower non empty NAT-defined FinPartState of T;
  consider k being natural number such that
A1: LastLoc F = il.(T,k) by Th26;
  reconsider k as Element of NAT by ORDINAL1:def 13;
  LastLoc F in dom F by Th51;
  then k < card F by A1,Th50;
  then
A2: k <= card F -' 1 by NAT_D:49;
  per cases by A2,XXREAL_0:1;
  suppose
    k < card F -' 1;
    then k+1 < card F -' 1 + 1 by XREAL_1:8;
    then k+1 < card F by NAT_1:14,XREAL_1:237;
    then il.(T,k+1) in dom F by Th50;
    then il.(T,k+1) <= LastLoc F, T by Th53;
    then
A3: k+1 <= k by A1,Th28;
    k <= k+1 by NAT_1:11;
    then k+0 = k+1 by A3,XXREAL_0:1;
    hence thesis;
  end;
  suppose
    k = card F -' 1;
    hence thesis by A1;
  end;
end;

registration
  let N be with_non-empty_elements non empty set,
  S be weakly_standard steady-programmed (
  IC-Ins-separated definite (non empty stored-program AMI-Struct over N));
  cluster really-closed lower non empty -> para-closed (NAT-defined
    (the Instructions of S)-valued FinPartState of S);
  coherence
  proof
    let F be NAT-defined (the Instructions of S)-valued FinPartState of S;
    assume
A1: F is really-closed;
    assume F is lower non empty;
    then il.(S,0) in dom F by Th49;
    hence thesis by A1,Th44;
  end;
end;

Lm7: now
  let N;
  let S be weakly_standard halting (IC-Ins-separated definite (non empty
  stored-program AMI-Struct over N));
  set F = il.(S,0) .--> halt S;
A1: dom F = {il.(S,0)} by FUNCOP_1:19;
  then
A2: card dom F = 1 by CARD_1:50;
  F is lower FinPartState of S by Th48;
  then
A3: LastLoc F = il.(S,card F -' 1) by Th55
    .= il.(S,card dom F -' 1) by CARD_1:104
    .= il.(S,0) by A2,XREAL_1:234;
  hence F.(LastLoc F) = halt S by FUNCOP_1:87;
  let l be Element of NAT such that
  F.l = halt S;
  assume l in dom F;
  hence l = LastLoc F by A1,A3,TARSKI:def 1;
end;

definition
  let N be with_non-empty_elements non empty set,
  S be weakly_standard halting (
IC-Ins-separated definite (non empty stored-program AMI-Struct over N)), F
  be non empty NAT-defined FinPartState of S;
  attr F is halt-ending means
  :Def22:
  F.(LastLoc F) = halt S;
  attr F is unique-halt means
  :Def23:
  for f being Element of NAT st
  F.f = halt S & f in dom F holds f = LastLoc F;
end;

registration
  let N be with_non-empty_elements non empty set;
  let S be weakly_standard halting (IC-Ins-separated definite (non empty
  stored-program AMI-Struct over N));
  cluster halt-ending unique-halt trivial (lower non empty NAT-defined
    (the Instructions of S)-valued FinPartState of S);
  existence
  proof
    reconsider F = il.(S,0) .--> halt S as lower non empty NAT-defined
    (the Instructions of S)-valued FinPartState of S by Th48;
    take F;
    thus F.(LastLoc F) = halt S by Lm7;
    thus for f being Element of NAT st F.f = halt S & f in dom F
    holds f = LastLoc F by Lm7;
    thus thesis;
  end;
end;

registration
  let N be with_non-empty_elements non empty set;
  let S be weakly_standard halting realistic (IC-Ins-separated definite
   steady-programmed (non empty
  stored-program AMI-Struct over N));
  cluster trivial closed lower non empty
  (NAT-defined (the Instructions of S)-valued FinPartState of S);
  existence
  proof
    reconsider F = il.(S,0) .--> halt S as lower non empty NAT-defined
    (the Instructions of S)-valued FinPartState of S by Th48;
    take F;
    thus thesis by Th46;
  end;
end;

registration
  let N be with_non-empty_elements non empty set;
  let S be weakly_standard halting realistic (IC-Ins-separated definite
   steady-programmed (non empty
  stored-program AMI-Struct over N));
  cluster halt-ending unique-halt trivial closed (lower non empty NAT-defined
    (the Instructions of S)-valued FinPartState of S);
  existence
  proof
    reconsider F = il.(S,0) .--> halt S as lower non empty NAT-defined
    (the Instructions of S)-valued FinPartState of S by Th48;
    take F;
    thus F.(LastLoc F) = halt S by Lm7;
    thus for f being Element of NAT st F.f = halt S & f in dom F
    holds f = LastLoc F by Lm7;
    thus thesis by Th46;
  end;
end;

definition
  let N be with_non-empty_elements non empty set;
  let S be weakly_standard halting (IC-Ins-separated definite (non empty
  stored-program AMI-Struct over N));
  mode pre-Macro of S is halt-ending unique-halt (lower non empty NAT-defined
    (the Instructions of S)-valued FinPartState of S);
end;

registration
  let N be with_non-empty_elements non empty set;
  let S be weakly_standard realistic halting (IC-Ins-separated definite
   steady-programmed(non empty
  stored-program AMI-Struct over N));
  cluster closed pre-Macro of S;
  existence
  proof
    reconsider F = il.(S,0) .--> halt S as lower non empty NAT-defined
    FinPartState of S by Th48;
    F.(LastLoc F) = halt S & for l being Element of NAT st F.l
    = halt S & l in dom F holds l = LastLoc F by Lm7;
    then reconsider F as pre-Macro of S by Def22,Def23;
    take F;
    thus thesis by Th46;
  end;
end;

canceled 3;

theorem
  for N being with_non-empty_elements non empty set,
      S being IC-Ins-separated definite
       (non empty stored-program AMI-Struct over N),
  l1, l2 being Element of NAT st SUCC(l1,S) = NAT
   holds l1 <= l2, S
proof
  let N be with_non-empty_elements non empty set,
  S be IC-Ins-separated definite (non
empty stored-program AMI-Struct over N), l1, l2 be Element of NAT
  such that
A1: SUCC(l1,S) = NAT;
  defpred P[set,set] means ($1 = 1 implies $2 = l1) & ($1 = 2 implies $2 = l2);
A2: for n being Nat st n in Seg 2 ex d being Element of NAT st P[n,d]
  proof
    let n be Nat;
    assume
A3: n in Seg 2;
    per cases by A3,FINSEQ_1:4,TARSKI:def 2;
    suppose
A4:   n = 1;
      reconsider l1 as Element of NAT;
      take l1;
      thus thesis by A4;
    end;
    suppose
A5:   n = 2;
      reconsider l2 as Element of NAT;
      take l2;
      thus thesis by A5;
    end;
  end;
  consider f being FinSequence of NAT such that
A6: len f = 2 and
A7: for n being Nat st n in Seg 2 holds P[n,f/.n] from FINSEQ_4:sch 1(A2);
A8: 1 in Seg 2 by FINSEQ_1:4,TARSKI:def 2;
  then
A9: f/.1 = l1 by A7;
  reconsider f as non empty FinSequence of NAT by A6;
  take f;
  2 in Seg 2 by FINSEQ_1:4,TARSKI:def 2;
  hence f/.1 = l1 & f/.len f = l2 by A6,A7,A8;
  let n be Element of NAT;
  assume
A10: 1 <= n;
  assume n < len f;
  then n < 1+1 by A6;
  then n <= 1 by NAT_1:13;
  then n = 1 by A10,XXREAL_0:1;
  hence thesis by A1,A9;
end;

:: from SCMRING4, 2008.03.13, A.T.

reserve i, j, k for natural number,
  n for Element of NAT,
  N for with_non-empty_elements non empty set,
  S for weakly_standard (IC-Ins-separated definite
  (non empty stored-program AMI-Struct over N)),
  l for Element of NAT,
  f for FinPartState of S;

definition
  let N be with_non-empty_elements non empty set,
  S be weakly_standard (IC-Ins-separated
  definite (non empty stored-program AMI-Struct over N)), loc be
  Element of NAT, k be natural number;
  func loc -' (k,S) -> Element of NAT equals
  il.(S, (locnum(loc,S)) -' k);
  coherence;
end;

theorem
  l -' (0,S) = l
proof
  thus l -' (0,S) = il.(S,locnum(l,S)) by NAT_D:40
    .= l by Def13;
end;

theorem
  l + (k,S) -' (k,S) = l
proof
  thus l + (k,S) -' (k,S) = il.(S,locnum(l,S) + k -' k) by Def13
    .= il.(S,locnum(l,S)) by NAT_D:34
    .= l by Def13;
end;

