:: On the Calculus of Binary Arithmetics
::  by Shunichi Kobayashi
::
:: Received August 23, 2003
:: Copyright (c) 2003 Association of Mizar Users

environ

 vocabularies MARGREL1, ZF_LANG, BINARITH, PARTIT1, BINARI_5;
 notations SUBSET_1, XBOOLEAN, MARGREL1, BVFUNC_1;
 constructors XXREAL_0, BINARITH, BVFUNC_1;
 registrations MARGREL1, BINARITH, BVFUNC_1, XBOOLEAN;
 requirements SUBSET, BOOLE, NUMERALS, ARITHM, REAL;
 definitions MARGREL1, BVFUNC_1, XBOOLEAN;
 theorems BINARITH, BVFUNC_1, XBOOLEAN;

begin

definition
 canceled;
  let x, y be Element of BOOLEAN;
  redefine func x 'nand' y -> Element of BOOLEAN;
  correctness
   proof
      x 'nand' y =FALSE or  x 'nand' y = TRUE by XBOOLEAN:def 3;
     hence thesis;
   end;
end;

definition
 canceled;
  let x, y be Element of BOOLEAN;
  redefine func x 'nor' y -> Element of BOOLEAN;
  correctness
   proof
      x 'nor' y =FALSE or  x 'nor' y = TRUE by XBOOLEAN:def 3;
     hence thesis;
   end;
end;

definition
  let x, y be boolean set;
 redefine func x <=> y equals
   'not' (x 'xor' y);
  correctness;
end;

definition
  let x, y be Element of BOOLEAN;
  redefine func x <=> y -> Element of BOOLEAN;
  correctness
   proof
      x <=> y =FALSE or  x <=> y = TRUE by XBOOLEAN:def 3;
     hence thesis;
   end;
end;

 reserve x,y,z,w for boolean set;

theorem
 TRUE 'nand' x = 'not' x;

theorem
 FALSE 'nand' x = TRUE;

theorem
 x 'nand' x = 'not' x &
'not' (x 'nand' x) = x;

theorem
 'not' (x 'nand' y) = x '&' y;

theorem
 x 'nand' 'not' x = TRUE &
'not' (x 'nand' 'not' x) = FALSE by XBOOLEAN:135,138;

theorem
 x 'nand' (y '&' z) = 'not' (x '&' y '&' z);

theorem
 x 'nand' (y '&' z) = (x '&' y) 'nand' z;

theorem
 x 'nand' (y 'or' z) = 'not' (x '&' y) '&' 'not' (x '&' z) by XBOOLEAN:55;

theorem
 x 'nand' (y 'xor' z) = (x '&' y) <=> (x '&' z)
  by BINARITH:38;

theorem
 TRUE 'nor' x = FALSE;

theorem
 FALSE 'nor' x = 'not' x;

theorem
 x 'nor' x = 'not' x &
'not' (x 'nor' x) = x;

theorem
 'not' (x 'nor' y) = x 'or' y;

theorem
 x 'nor' 'not' x = FALSE &
'not' (x 'nor' 'not' x) = TRUE by XBOOLEAN:134,138;

theorem
 x 'nor' (y '&' z) = 'not' (x 'or' y) 'or' 'not' (x 'or' z) by XBOOLEAN:40;

theorem
 x 'nor' (y 'or' z) = 'not' (x 'or' y 'or' z);

theorem
 TRUE <=> x = x;

theorem
 FALSE <=> x = 'not' x;

theorem
 x <=> x = TRUE &
'not' (x <=> x) = FALSE by XBOOLEAN:125,143;

theorem
 'not' (x <=> y) = x 'xor' y;

theorem
 x <=> 'not' x = FALSE &
'not' (x <=> 'not' x) = TRUE by XBOOLEAN:129,142;

theorem
 x '<' (y => z) iff x '&' y '<' z
proof
 A1:x '<' (y => z) implies x '&' y '<' z
 proof
  assume x '<' (y => z);
  then A2:x => (y => z) = TRUE by BVFUNC_1:def 3;
   x => (y => z)
  = (x '&' y) => z;
  hence thesis by A2,BVFUNC_1:def 3;
 end;
  x '&' y '<' z implies x '<' (y => z)
 proof
  assume x '&' y '<' z;
  then A3:(x '&' y) => z = TRUE by BVFUNC_1:def 3;
   (x '&' y) => z
  = x => (y => z);
  hence thesis by A3,BVFUNC_1:def 3;
 end;
 hence thesis by A1;
end;

theorem
x <=> y = (x => y) '&' (y => x);

theorem
x <=> y = TRUE iff (x => y) = TRUE & (y => x) = TRUE by XBOOLEAN:132;

theorem
(x => y)=TRUE & (y => x)=TRUE implies x = y by XBOOLEAN:116;

theorem
(x => y)=TRUE & (y => z)=TRUE implies (x => z)=TRUE by XBOOLEAN:117;

theorem
 (x <=> y)=TRUE & (y <=> z)=TRUE implies (x <=> z)=TRUE by XBOOLEAN:127;

theorem
x => y = 'not' y => 'not' x;

theorem
 x <=> y = 'not' x <=> 'not' y;

theorem
 (x <=> y)=TRUE & (z <=> w)=TRUE implies ((x '&' z) <=> (y '&' w))=TRUE
         by XBOOLEAN:130;

theorem
 (x <=> y)=TRUE & (z <=> w)=TRUE implies
(x => z) <=> (y => w)=TRUE by XBOOLEAN:133;

theorem
 (x <=> y)=TRUE & (z <=> w)=TRUE implies
(x 'or' z) <=> (y 'or' w)=TRUE by XBOOLEAN:131;

theorem
 (x <=> y)=TRUE & (z <=> w)=TRUE implies
((x <=> z) <=> (y <=> w))=TRUE by XBOOLEAN:128;

theorem
 x=TRUE & (x => y)=TRUE implies y=TRUE;

theorem
 y=TRUE implies (x => y)=TRUE;

theorem
 ('not' x)=TRUE implies (x => y)=TRUE;

theorem
 x => x=TRUE by XBOOLEAN:103;

theorem
 (x => y)=TRUE & (x => 'not' y)=TRUE implies
'not' x=TRUE by XBOOLEAN:120;

theorem
 ('not' x => x) => x = TRUE by XBOOLEAN:118;

theorem
 (x => y) => ('not' (y '&' z) => 'not' (x '&' z)) = TRUE by XBOOLEAN:121;

theorem
 (x => y) => ((y => z) => (x => z)) = TRUE by XBOOLEAN:106;

theorem
 (x => y)=TRUE implies ((y => z) => (x => z)) = TRUE by XBOOLEAN:113;

theorem
 y => (x => y) = TRUE by XBOOLEAN:104;

theorem
 ((x => y) => z) => (y => z) = TRUE by XBOOLEAN:111;

theorem
 y => ((y => x) => x) = TRUE by XBOOLEAN:105;

theorem
 (z => (y => x)) => (y => (z => x)) = TRUE by XBOOLEAN:110;

theorem
 (y => z) => ((x => y) => (x => z)) = TRUE by XBOOLEAN:107;

theorem
 (y => (y => z)) => (y => z) = TRUE by XBOOLEAN:108;

theorem
 (x => (y => z)) => ((x => y) => (x => z)) = TRUE by XBOOLEAN:109;

theorem
 x=TRUE implies (x => y) => y=TRUE by XBOOLEAN:112;

theorem
 z => (y => x)=TRUE implies y => (z => x)=TRUE;

theorem
 z => (y => x)=TRUE & y=TRUE implies z => x=TRUE;

theorem
 z => (y => x)=TRUE & y=TRUE & z = TRUE implies x=TRUE;

theorem
 y => (y => z)=TRUE implies y => z = TRUE by XBOOLEAN:114;

theorem
 (x => (y => z)) = TRUE implies
(x => y) => (x => z) = TRUE by XBOOLEAN:115;
