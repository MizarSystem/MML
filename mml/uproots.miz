:: Little {B}ezout Theorem (Factor Theorem)
::  by Piotr Rudnicki
::
:: Received December 30, 2003
:: Copyright (c) 2003 Association of Mizar Users

environ

 vocabularies ARYTM_1, SQUARE_1, ARYTM_3, FINSEQ_1, RELAT_1, FUNCT_1, RLVECT_1,
      BOOLE, FINSEQ_2, FINSEQ_4, BINOP_1, VECTSP_1, LATTICES, NORMSP_1, ARYTM,
      COMPLFLD, GROUP_1, REALSET1, POLYNOM1, TARSKI, CARD_1, CARD_3, SETWISEO,
      ALGSEQ_1, POLYNOM3, POLYNOM2, ALGSTR_2, FUNCT_4, VECTSP_2, FUNCOP_1,
      FUNCT_2, RFINSEQ, POLYNOM5, FVSUM_1, FINSET_1, NEWTON, MCART_1, SGRAPH1,
      CAT_1, DTCONSTR, MEMBERED, ANPROJ_1, UPROOTS, ORDINAL2, SEQ_1, PBOOLE;
 notations TARSKI, XBOOLE_0, XCMPLX_0, SUBSET_1, STRUCT_0, ORDINAL1, ORDINAL2,
      NUMBERS, XREAL_0, ZFMISC_1, REALSET1, REAL_1, NAT_1, SETWISEO, RLVECT_1,
      VECTSP_1, VECTSP_2, BINOP_1, RELAT_1, FUNCT_1, FUNCT_2, SETWOP_2,
      FINSEQ_1, FINSEQ_2, FINSEQ_4, FINSOP_1, TOPREAL1, NORMSP_1, BINARITH,
      RVSUM_1, BINOP_2, ALGSEQ_1, COMPLFLD, POLYNOM3, POLYNOM4, POLYNOM5,
      CARD_1, FINSET_1, GROUP_1, MCART_1, PRE_CIRC, FUNCT_4, RLVECT_2,
      CQC_LANG, DTCONSTR, RFINSEQ, SEQ_1, PBOOLE, POLYNOM1, FVSUM_1, WSIERP_1,
      MEMBERED, REALSET2;
 constructors REAL_1, FINSOP_1, MONOID_0, WELLORD2, BINARITH, POLYNOM4,
      POLYNOM5, PREPOWER, SETWOP_2, WELLFND1, PRE_CIRC, FINSEQOP, ALGSTR_1,
      RLVECT_2, CQC_LANG, POLYNOM2, WSIERP_1, SETWISEO, GOBOARD1, NORMSP_1,
      DTCONSTR;
 registrations XREAL_0, STRUCT_0, RELSET_1, VECTSP_1, POLYNOM1, POLYNOM3,
      MONOID_0, NAT_1, INT_1, POLYNOM5, FINSEQ_1, FINSET_1, CARD_1, MEMBERED,
      FUNCT_1, ALGSTR_1, SUBSET_1, ORDINAL2, RFINSEQ, GOBRD13, PRE_CIRC,
      TREES_2, CHAIN_1, POLYNOM7, BINOP_2;
 requirements NUMERALS, BOOLE, SUBSET, ARITHM, REAL;
 definitions TARSKI, VECTSP_2, FUNCT_1, POLYNOM5;
 theorems GROUP_1, CARD_1, FINSEQ_1, ZFMISC_1, NAT_1, FUNCT_1, FUNCT_2,
      RELAT_1, TARSKI, XBOOLE_0, XBOOLE_1, VECTSP_1, REAL_1, XCMPLX_1,
      POLYNOM5, BINARITH, INT_1, SCMFSA_7, AXIOMS, RVSUM_1, FVSUM_1, FINSEQ_3,
      FINSEQ_2, FINSEQ_4, POLYNOM4, POLYNOM3, FUNCT_7, ALGSEQ_1, RLVECT_1,
      FINSET_1, PBOOLE, FUNCOP_1, POLYNOM1, MATRIX_3, PRE_CIRC, VECTSP_2,
      CARD_2, FINSEQ_5, GRAPH_5, QC_LANG4, CQC_LANG, DTCONSTR, BAGORDER,
      RFINSEQ, GOBOARD9, WELLORD2, CARD_3, ORDINAL2, FSM_1, JORDAN3, FINSOP_1,
      MONOID_0, INTEGRA1, SEQM_3, TRIANG_1, FUNCT_4, MCART_1, REALSET2,
      REALSET1, SEQ_1;
 schemes NAT_1, FUNCT_1, FINSEQ_1, FUNCT_2, FRAENKEL, POLYNOM2, INT_2,
      ALGSEQ_1, RECDEF_1;

begin :: Preliminaries

theorem Th1: :: neNat1:
for n being natural number holds n is non empty iff n = 1 or n > 1
proof let n be natural number;
 hereby assume n is non empty; then 0 < n by NAT_1:19;
   then 0+1 <= n by NAT_1:38;
  hence n = 1 or n > 1 by REAL_1:def 5;
 end;
 assume n = 1 or n > 1; then n <> 0;
 hence thesis;
end;

theorem Th2: :: SumFS:
for f being FinSequence of NAT
 st for i being Nat st i in dom f holds f.i <> 0
  holds Sum f = len f iff f = (len f) |-> 1
proof let f be FinSequence of NAT;
 defpred P[Nat] means
  for f being FinSequence of NAT
   st len f = $1 &
      for i being Nat st i in dom f holds f.i <> 0
    holds Sum f = len f iff f = (len f) |-> 1;
A1: P[0] proof let f be FinSequence of NAT such that
    A2: len f = 0 and for i being Nat st i in dom f holds f.i <> 0;
       hereby assume Sum f = len f;
        thus f = {} by A2,FINSEQ_1:25 .= (len f) |-> 1 by A2,FINSEQ_2:72;
       end;
       assume f = (len f) |-> 1;
       thus Sum f = len f by A2,FINSEQ_1:25,RVSUM_1:102;
    end;
A3: for n being Nat st P[n] holds P[n+1] proof let n be Nat; assume
    A4: P[n];
     let f be FinSequence of NAT such that
    A5: len f = n+1 and
    A6: for i being Nat st i in dom f holds f.i <> 0;
       consider g being FinSequence of NAT, a being Nat such that
    A7: f = g^<*a*> by A5,FINSEQ_2:22;
    A8: g is FinSequence of REAL by FINSEQ_2:27;
          n+1 = len g + len <*a*> by A5,A7,FINSEQ_1:35;
       then A9: n+1 = len g + 1 by FINSEQ_1:57;
    then A10: len g = n by XCMPLX_1:2;
    A11: now let i be Nat; assume
       A12: i in dom g;
           A13: dom g c= dom f by A7,FINSEQ_1:39;
              f.i = g.i by A7,A12,FINSEQ_1:def 7;
         hence g.i <> 0 by A6,A12,A13;
       end;
    A14: Sum f = Sum g + a by A7,A8,RVSUM_1:104;
    A15: len f in Seg len f by A5,FINSEQ_1:6;
    A16: dom f = Seg len f by FINSEQ_1:def 3;
          f.len f = a by A5,A7,A9,FINSEQ_1:59;
       then a <> 0 by A6,A15,A16; then 0 < a by NAT_1:19;
    then A17: 0+1 <= a by NAT_1:38;
     hereby assume A18: Sum f = len f;
         reconsider h = (len g) |-> (1 qua Real) as FinSequence of REAL;
     A19: len h = len g by FINSEQ_2:69;
     A20: h is Element of (len h)-tuples_on REAL by FINSEQ_2:110;
     A21: g is Element of (len g)-tuples_on REAL by A8,FINSEQ_2:110;
            now let j be Nat; assume
         A22: j in Seg len g;
             then j in dom g by FINSEQ_1:def 3;
             then g.j <> 0 by A11; then 0 < g.j by NAT_1:19;
             then 0+1 <= g.j by NAT_1:38;
          hence h.j <= g.j by A22,FINSEQ_2:70;
         end;
     then A23: Sum h <= Sum g by A19,A20,A21,RVSUM_1:112;
     A24: Sum h = n*1 by A10,RVSUM_1:110 .= n;
     A25: Sum g = Sum g +a -a .= n+1 -a by A5,A7,A8,A18,RVSUM_1:104;
          then n+a <= n+1-a+a by A23,A24,AXIOMS:24;
         then a <= 1 by REAL_1:53;
     then A26: a = 1 by A17,AXIOMS:21;
         then g = (len g) |-> 1 by A4,A10,A11,A25;
      hence f = (len f) |-> 1 by A5,A7,A9,A26,FINSEQ_2:74;
     end;
     assume f = (len f) |-> 1;
         then f = (n |-> 1)^(1 |-> 1) by A5,FINSEQ_2:143
          .= (n |-> 1)^<*1*> by FINSEQ_2:73;
     then g = (len g) |-> 1 & a = 1 by A7,A10,FINSEQ_2:20;
     hence Sum f = len f by A4,A5,A10,A11,A14;
    end;
    for n being Nat holds P[n] from NAT_1:sch 1(A1, A3);
 hence thesis;
end;

:: Stolen from POLYNOM2
scheme IndFinSeq0 { F() -> FinSequence, P[set, set]} :
for i being Nat st 1 <= i & i <= len F() holds P[i, F().i]
provided
 A1: P[1, F().1] and
 A2: for i being Nat st 1 <= i & i < len F()
      holds P[i, F().i] implies P[i+1, F().(i+1)]
proof
defpred Q[Nat] means 1 <= $1 & $1 <= len F() & not(P[$1, F().($1)]);
assume not(for i being Nat st 1 <= i & i <= len F() holds P[i, F().i]);
then A3: ex k being Nat st Q[k];
consider k being Nat such that
A4: Q[k] & for k' being Nat st Q[k'] holds k <= k' from NAT_1:sch 5(A3);
 per cases;
 suppose k = 1;
  hence thesis by A1,A4;
 end;
 suppose A5: k <> 1;
       1 - 1 <= k - 1 by A4,REAL_1:49;
  then reconsider k' = k - 1 as Nat by INT_1:16;
  A6: (k - 1) + 1 = k + 0;
  A7: k' <= k' + 1 by NAT_1:29;
       k' <> k' + 1
    proof
    assume A8: k' = k' + 1;
         (k' + 1) - k' = 1 + 0;
    hence thesis by A8,XCMPLX_1:14;
    end;
  then A9: k' < k by A7,REAL_1:def 5;
  then A10: not(Q[k']) by A4;
       1 < k by A4,A5,REAL_1:def 5;
  then A11: 1 <= k' by A6,NAT_1:38;
       k' < len F() by A4,A9,AXIOMS:22;
  hence thesis by A2,A4,A6,A10,A11;
end;
end;

theorem Th3: :: thsum2:
for L be add-associative right_zeroed right_complementable (non empty LoopStr),
    r be FinSequence of L
 st len r >= 2 & for k being Nat st 2 < k & k in dom r holds r.k = 0.L
  holds Sum r = r/.1 + r/.2
proof let L be add-associative right_zeroed right_complementable
            (non empty LoopStr), r being FinSequence of L such that
A1: len r >= 2 and
A2: for k being Nat st 2 < k & k in dom r holds r.k = 0.L;
      now assume r is empty; then r = <*>(the carrier of L);
     then len r = 0 by FINSEQ_1:32;
    hence contradiction by A1;
   end;
   then consider a being Element of L, r1 being FinSequence of L such that
A3: a = r.1 and
A4: r = <*a*>^r1 by FINSEQ_3:111;
A5: len <*a*> = 1 by FINSEQ_1:57;
then A6: len r = 1 + len r1 by A4,FINSEQ_1:35;
      now assume r1 is empty; then r1 = <*>(the carrier of L);
     then len r1 = 0 by FINSEQ_1:32;
     hence contradiction by A1,A6;
   end;
   then consider b being Element of L, r2 being FinSequence of L such that
A7: b = r1.1 and
A8: r1 = <*b*>^r2 by FINSEQ_3:111;
A9: len <*b*> = 1 by FINSEQ_1:57;
A10: now let i be Nat such that
   A11: i in dom r2;
   A12: 1+i in dom r1 by A8,A9,A11,FINSEQ_1:41;
          1 <= i by A11,FINSEQ_3:27; then 1 < 1+i by NAT_1:38;
   then A13: 1+1 < 1+(1+i) by REAL_1:67;
   A14: 1+(1+i) in dom r by A4,A5,A12,FINSEQ_1:41;
    thus r2.i = r1.(1+i) by A8,A9,A11,FINSEQ_1:def 7
         .= r.(1+(1+i)) by A4,A5,A12,FINSEQ_1:def 7 .= 0.L by A2,A13,A14;
   end;    1 <= len r by A1,AXIOMS:22;
then A15: 1 in dom r by FINSEQ_3:27;
A16: 2 in dom r by A1,FINSEQ_3:27;
A17: r.2 = r1.(2-1) by A1,A4,A5,FINSEQ_1:37 .= r1.1;
  thus Sum r = a + Sum r1 by A4,FVSUM_1:89
    .= a + (b + Sum r2) by A8,FVSUM_1:89 .= a + (b + 0.L) by A10,POLYNOM3:1
   .= a+b by RLVECT_1:def 7 .= r/.1 + b by A3,A15,FINSEQ_4:def 4
   .= r/.1 + r/.2 by A7,A16,A17,FINSEQ_4:def 4;
end;

begin :: Canonical ordering of a finite set into a finite sequence

definition
  let A be finite set;
  func canFS(A) -> FinSequence of A means                           :Def1:
   len it = card A &
   ex f being FinSequence st len f = card A &
    (f.1 = [choose A, A \ {choose A}] or card A = 0) &
    (for i being Nat st 1 <= i & i < card A
      for x being set
       st f.i = x holds f.(i+1) = [choose x`2, x`2 \ {choose x`2}]) &
    for i being Nat st i in dom it holds it.i = (f.i)`1;
  existence proof set cA = card A;
  defpred P[Nat,set,set] means
    $3 = [choose $2`2, $2`2 \ {choose $2`2}];
A1: for n being Nat st 1 <= n & n < cA
          for x being set ex y being set st P[n,x,y];
A2: for n being Nat st 1 <= n & n < cA
         for x,y1,y2 being set st P[n,x,y1] & P[n,x,y2] holds y1 = y2;
   consider f being FinSequence such that
A3: len f = cA and
A4: f.1 = [choose A, A \ {choose A}] or cA = 0 and
A5: for n being Nat st 1<=n&n<cA holds P[n,f.n,f.(n+1)] from RECDEF_1:sch 5
(A1, A2);
   defpred R[Nat,set] means
   $1 in dom f implies $2 in [: A, bool A :] &
   ex X being finite set st X = ($2)`2  & card X +$1 = cA;
A6: R[1,f.1] proof assume A7:1 in dom f;
then 0+1 <= len f by FINSEQ_3:27;
         then A8: 0 < len f;
      A9:   A <> {} by A3,A7,CARD_1:78,FINSEQ_3:27;
           A \ {choose A} c= A by XBOOLE_1:36;
      hence f.1 in [: A, bool A :]
        by A3,A4,A7,A9,FINSEQ_3:27,ZFMISC_1:def 2;
      reconsider X = A \ {choose A} as finite set;
      take X; thus X = (f.1)`2 by A3,A4,A7,FINSEQ_3:27,MCART_1:7;
     A10: now assume choose A in A \ {choose A};
          then not choose A in {choose A} by XBOOLE_0:def 4;
          hence contradiction by TARSKI:def 1;
         end;
            {choose A} c= A by A3,A8,CARD_1:78,ZFMISC_1:37;
         then A = {choose A} \/ (A \ {choose A}) by XBOOLE_1:45;
      hence card X + 1 = cA by A10,CARD_2:54;
    end;
A11: for i being Nat st 1 <= i & i < len f & R[i, f.i] holds R[i+1,f.(i+1)]
    proof let i be Nat such that
    A12: 1 <= i and
    A13: i < len f and
    A14: R[i, f.i] and i+1 in dom f;
        consider X being finite set such that
    A15: X = (f.i)`2  and
    A16: card X +i = cA by A12,A13,A14,FINSEQ_3:27;
    A17: X <> {} by A3,A13,A16,CARD_1:78;
        consider a, ba being set such that a in A and
    A18: ba in bool A and
    A19: f.i = [a, ba] by A12,A13,A14,FINSEQ_3:27,ZFMISC_1:def 2;
    A20: f.(i+1) = [choose (f.i)`2, (f.i)`2 \ {choose (f.i)`2}] by A3,A5,A12
,A13;
    A21: (f.i)`1 = a & (f.i)`2 = ba by A19,MCART_1:7;
      A22: choose (f.i)`2 in (f.i)`2 by A15,A17;
           (f.i)`2 \ {choose (f.i)`2} c= (f.i)`2 by XBOOLE_1:36;
        then (f.i)`2 \ {choose (f.i)`2} c= A by A18,A21,XBOOLE_1:1;
     hence f.(i+1) in [: A, bool A :] by A18,A20,A21,A22,ZFMISC_1:def 2;
     reconsider XX = (f.i)`2 \{choose(f.i)`2} as finite set by A15,FINSET_1:16
;
     take XX; thus XX = (f.(i+1))`2 by A20,MCART_1:7;
    A23: now assume choose (f.i)`2 in (f.i)`2 \ {choose (f.i)`2};
          then not choose (f.i)`2 in {choose (f.i)`2} by XBOOLE_0:def 4;
          hence contradiction by TARSKI:def 1;
         end;
            {choose (f.i)`2} c= (f.i)`2 by A15,A17,ZFMISC_1:37;
         then (f.i)`2 = {choose (f.i)`2} \/ ((f.i)`2 \ {choose (f.i)`2})
         by XBOOLE_1:45;
       then card X = card XX + 1 by A15,A23,CARD_2:54;
      hence card XX + (i+1) = cA by A16,XCMPLX_1:1;
    end;
A24: for i being Nat st 1<=i & i <= len f holds R[i,f.i]from IndFinSeq0(A6, A11
);
      rng f c= [: A, bool A :] proof let y be set; assume y in rng f;
      then consider i being Nat such that
   A25: i in dom f and
   A26: y = f.i by FINSEQ_2:11;          1 <= i & i <= len f by A25,FINSEQ_3:27
;
    hence thesis by A24,A25,A26;
   end; then reconsider f as FinSequence of [: A, bool A :] by FINSEQ_1:def 4;
   deffunc F(Nat) = (f.$1)`1;
   consider p being FinSequence such that
A27: len p = card A and
A28: for k being Nat st k in Seg card A holds p.k = F(k) from FINSEQ_1:sch 2;
A29: dom p = Seg card A by A27,FINSEQ_1:def 3;
A30: dom p = dom f by A3,A27,FINSEQ_3:31;
      rng p c= A proof let y be set; assume y in rng p;
      then consider i being Nat such that
   A31: i in dom p and
   A32: p.i = y by FINSEQ_2:11;
   A33: p.i = (f.i)`1 by A28,A29,A31;
       f.i in [:A, bool A:] by A30,A31,FINSEQ_2:13;
    hence y in A by A32,A33,MCART_1:10;
   end; then reconsider p as FinSequence of A by FINSEQ_1:def 4;
   take p; thus len p = card A by A27;
   take f; thus thesis by A3,A4,A5,A28,A29;
  end;
  uniqueness proof let it1, it2 be FinSequence of A such that
  A34: len it1 = card A; given f being FinSequence such that
  A35: len f = card A and
  A36: f.1 = [choose A, A \ {choose A}] or card A = 0 and
  A37: for i being Nat st 1 <= i & i < card A
          holds for x being set
           st f.i = x holds f.(i+1) = [choose x`2, x`2 \ {choose x`2}] and
  A38: for i being Nat st i in dom it1 holds it1.i = (f.i)`1;
      assume
  A39: len it2 = card A; given g being FinSequence such that
  A40: len g = card A and
  A41: g.1 = [choose A, A \ {choose A}] or card A = 0 and
  A42: for i being Nat st 1 <= i & i < card A
          holds for x being set
           st g.i = x holds g.(i+1) = [choose x`2, x`2 \ {choose x`2}] and
  A43: for i being Nat st i in dom it2 holds it2.i = (g.i)`1;
  defpred Q[Nat,set] means card A <> 0 implies $2 = g.$1;
A44: Q[1, f.1] by A36,A41;
A45: for i being Nat st 1 <= i & i < len f & Q[i, f.i] holds Q[i+1, f.(i+1)]
    proof let i be Nat such that
    A46: 1 <= i and
    A47: i < len f and
    A48: Q[i, f.i] and
    card A <> 0;
    set x = f.i;
     thus f.(i+1) = [choose x`2, x`2 \ {choose x`2}] by A35,A37,A46,A47
         .= g.(i+1) by A35,A42,A46,A47,A48;
    end;
A49: for i being Nat st 1<=i & i<=len f holds Q[i, f.i] from IndFinSeq0(A44,A45
);
  A50: f = g proof
       per cases;
       suppose A51: card A = 0;
        hence f = {} by A35,FINSEQ_1:25 .= g by A40,A51,FINSEQ_1:25;
       end;
       suppose A52: card A <> 0;
          now let j be Nat; assume j in Seg len f;
          then j in dom f by FINSEQ_1:def 3;
          then 1 <= j & j <= len f by FINSEQ_3:27;
         hence f.j = g.j by A49,A52;
       end;
       hence f = g by A35,A40,FINSEQ_2:10;
      end;
      end;
       now let j be Nat such that
    A53: j in Seg card A;
    A54: dom it1 = dom it2 by A34,A39,FINSEQ_3:31;
    A55: dom it1 = Seg card A by A34,FINSEQ_1:def 3;
      hence it1.j = (f.j)`1 by A38,A53 .= it2.j by A43,A50,A53,A54,A55;
    end;
   hence it1 = it2 by A34,A39,FINSEQ_2:10;
  end;
end;

theorem Th4: :: CFS0:
for A being finite set holds canFS(A) is one-to-one
proof let A be finite set;
 set F = canFS(A), cA = card A;
A1: len F = card A by Def1;
   consider f being FinSequence such that
A2: len f = cA and
A3: f.1 = [choose A, A \ {choose A}] or card A = 0 and
A4: for i being Nat st 1 <= i & i < cA
    for x being set
     st f.i = x holds f.(i+1) = [choose x`2, x`2 \ {choose x`2}] and
A5: for i being Nat st i in dom F holds F.i = (f.i)`1 by Def1;
 per cases;
 suppose  A = {};
  hence canFS(A) is one-to-one by A1,CARD_1:78,FINSEQ_1:25;
 end;
 suppose A6: A <> {};
then card A <> 0 by GRAPH_5:5; then card A > 0 by NAT_1:19;
then A7: 0+1 <= len F by A1,NAT_1:38;
then A8: 1 in dom F by FINSEQ_3:27;
 defpred P[Nat, set] means
  rng (F| Seg $1) /\ ($2)`2 = {} &
  (ex X being finite set st X = ($2)`2  & card X +$1 = cA) &
  ($1 < len F implies not F.($1+1) in rng (F| Seg $1));
A9: P[1, f.1] proof
         reconsider F1 = (F | Seg 1) as FinSequence of A by FINSEQ_1:23;
         consider a being Element of A such that
     A10: F1 = <* a *> by A6,A7,QC_LANG4:7;
            1 in Seg (0+1) by FINSEQ_1:6;
         then F1.1 = F.1 by FUNCT_1:72 .= (f.1)`1 by A5,A8
             .= choose A by A3,A6,GRAPH_5:5,MCART_1:7;
         then F | Seg 1 = <* choose A *> by A10,FINSEQ_1:57;
     then A11: rng (F| Seg 1) = {choose A} by FINSEQ_1:56;
     A12: (f.1)`2 = A \ {choose A} by A3,A6,GRAPH_5:5,MCART_1:7;
      thus rng (F| Seg 1) /\ (f.1)`2 = {} proof assume not thesis;
      then consider x being set such that
      A13: x in rng (F| Seg 1) /\ (f.1)`2 by XBOOLE_0:def 1;
             x in {choose A} & x in (f.1)`2 by A11,A13,XBOOLE_0:def 3;
       hence contradiction by A12,XBOOLE_0:def 4;
      end;
      A14: now reconsider X = A \ {choose A} as finite set;
       take X; thus X = (f.1)`2 by A3,A6,GRAPH_5:5,MCART_1:7;
      A15: now assume choose A in A \ {choose A};
          then not choose A in {choose A} by XBOOLE_0:def 4;
          hence contradiction by TARSKI:def 1;
         end;
            {choose A} c= A by A6,ZFMISC_1:37;
         then A = {choose A} \/ (A \ {choose A}) by XBOOLE_1:45;
       hence card X + 1 = cA by A15,CARD_2:54;
      end;
     hence ex X being finite set st X = (f.1)`2  & card X +1 = cA;
         consider X being finite set such that
     A16: X = (f.1)`2  and
     A17: card X +1 = cA by A14;
     A18: 1 < len F implies (f.1)`2 <> {} by A16,A17,Def1,CARD_1:78;
      assume
      A19: 1 < len F; then 1+1 <= len F by NAT_1:38;
         then 1+1 in dom F by FINSEQ_3:27;
      then A20: F.2 = (f.2)`1 by A5;
             f.(1+1) = [choose (f.1)`2, (f.1)`2 \ {choose (f.1)`2}]
            by A1,A4,A19;
      then (f.(1+1))`1 = choose (A \ {choose A}) by A12,MCART_1:7;
         hence not F.(1+1) in rng (F| Seg 1)
             by A11,A12,A18,A19,A20,XBOOLE_0:def 4;
    end;
A21: for i being Nat st 1 <= i & i < len f & P[i, f.i] holds P[i+1, f.(i+1)]
    proof let i be Nat such that
    A22: 1 <= i and
    A23: i < len f and
    A24: P[i, f.i];
        consider X being finite set such that
    A25: X = (f.i)`2  and
    A26: card X +i = cA by A24;
    A27: f.(i+1) = [choose (f.i)`2, (f.i)`2 \ {choose (f.i)`2}] by A2,A4,A22
,A23;
       (f.i)`2 is non empty by A2,A23,A25,A26,CARD_1:78;
        then {choose (f.i)`2} c= (f.i)`2 by ZFMISC_1:37;
    then A28: (f.i)`2={choose (f.i)`2}\/((f.i)`2 \ {choose (f.i)`2}) by
XBOOLE_1:45;
    A29: i+1 <= len F by A1,A2,A23,NAT_1:38;
           1 <= i+1 by NAT_1:37;
    then A30: i+1 in dom F by A29,FINSEQ_3:27;
        reconsider Fi = F| Seg i, Fi1 = F| Seg (i+1) as FinSequence of A
          by FINSEQ_1:23;
        consider a being Element of A such that
    A31: Fi1 = Fi^<*a*> by A6,A29,QC_LANG4:6;
    A32: rng Fi1 = rng Fi \/ rng <*a*> by A31,FINSEQ_1:44
               .= rng Fi \/ {a} by FINSEQ_1:56;
           i+1 in Seg (i+1) by FINSEQ_1:6;
    then A33: F.(i+1) = Fi1.(i+1) by FUNCT_1:72;
           i = len Fi by A1,A2,A23,FINSEQ_1:21;
     then a = F.(i+1) by A31,A33,FINSEQ_1:59 .= (f.(i+1))`1 by A5,A30
           .= choose (f.i)`2 by A27,MCART_1:7;
    then A34: (f.(i+1))`2 = (f.i)`2 \ {a} by A27,MCART_1:7;
    thus
    A35: rng (F| Seg (i+1)) /\ (f.(i+1))`2 = {} proof assume not thesis;
     then consider x being set such that
    A36: x in (rng Fi \/ {a}) /\ ((f.i)`2 \ {a}) by A32,A34,XBOOLE_0:def 1;
           x in (rng Fi \/ {a}) & x in ((f.i)`2 \ {a}) by A36,XBOOLE_0:def 3;
        then (x in rng Fi or x in {a}) & (x in (f.i)`2 & not x in {a})
              by XBOOLE_0:def 2,def 4;
     hence contradiction by A24,XBOOLE_0:def 3;
    end;
     A37: now reconsider XX = (f.i)`2 \{choose(f.i)`2} as finite set
             by A25,FINSET_1:16;
     take XX; thus XX = (f.(i+1))`2 by A27,MCART_1:7;
         now assume choose (f.i)`2 in (f.i)`2 \ {choose (f.i)`2};
          then not choose (f.i)`2 in {choose (f.i)`2} by XBOOLE_0:def 4;
          hence contradiction by TARSKI:def 1;
         end;
       then card X = card XX + 1 by A25,A28,CARD_2:54;
      hence card XX + (i+1) = cA by A26,XCMPLX_1:1;
     end;
    hence
       ex X being finite set st X = (f.(i+1))`2  & card X +(i+1) = cA;
    assume
    A38: i+1 < len F;     consider X being finite set such that
    A39: X = (f.(i+1))`2  and
    A40: card X +(i+1) = cA by A37;
    A41: (f.(i+1))`2 <> {} by A38,A39,A40,Def1,CARD_1:78;
    A42: 1 <= i+1 by NAT_1:37;        set i1 = i+1;
    A43: 1 <= i1+1 by NAT_1:37;          i1+1 <= len F by A38,NAT_1:38;
        then i1+1 in dom F by A43,FINSEQ_3:27;
    then A44: F.(i1+1) = (f.(i1+1))`1 by A5;
           f.(i1+1) = [choose (f.i1)`2, (f.i1)`2 \ {choose (f.i1)`2}]
        by A1,A4,A38,A42;
    then A45: (f.(i1+1))`1 = choose (f.i1)`2 by MCART_1:7;
    assume
      F.((i+1)+1) in rng (F| Seg (i+1));
     hence contradiction by A35,A41,A44,A45,XBOOLE_0:def 3;
    end;
A46: for i being Nat st 1<=i & i<=len f holds P[i, f.i] from IndFinSeq0(A9,A21
);
  thus canFS(A) is one-to-one proof let i, j be set such that
A47: i in dom F and
A48: j in dom F and
A49: F.i = F.j;
A50: dom F = Seg len F by FINSEQ_1:def 3;
   per cases;
   suppose i = j;
    hence thesis;
   end;
   suppose A51: i <> j; reconsider i, j as Nat by A47,A48,FINSEQ_3:25;
A52: 1 <= i & i <= len F by A47,FINSEQ_3:27;
A53: 1 <= j & j <= len F by A48,FINSEQ_3:27;
      now
   per cases by A51,REAL_1:def 5;
    suppose A54: i < j;    j <> 0 by A48,FINSEQ_3:27; then consider j1 being
Nat
such that
  A55: j = j1+1 by NAT_1:22;
  A56: j1 < len F by A53,A55,NAT_1:38;
  A57: i <= j1 by A54,A55,NAT_1:38; then 1 <= j1 by A52,AXIOMS:22;
  then A58: not F.(j1+1) in rng (F|Seg j1) by A1,A2,A46,A56;
  A59: i in Seg j1 by A52,A57,FINSEQ_1:3;
  then A60: (F|Seg j1).i = F.i by FUNCT_1:72;
        Seg j1 c= dom F by A50,A56,FINSEQ_1:7;
      then i in dom (F|Seg j1) by A59,RELAT_1:91;
     hence contradiction by A49,A55,A58,A60,FUNCT_1:12;
    end;
    suppose A61: i > j;
         i <> 0 by A47,FINSEQ_3:27;
        then consider i1 being Nat such that
  A62: i = i1+1 by NAT_1:22;
  A63: i1 < len F by A52,A62,NAT_1:38;
  A64: j <= i1 by A61,A62,NAT_1:38; then 1 <= i1 by A53,AXIOMS:22;
  then A65: not F.(i1+1) in rng (F|Seg i1) by A1,A2,A46,A63;
  A66: j in Seg i1 by A53,A64,FINSEQ_1:3;
  then A67: (F|Seg i1).j = F.j by FUNCT_1:72;
        Seg i1 c= dom F by A50,A63,FINSEQ_1:7; then j in dom (F|Seg
i1) by A66,RELAT_1:91;
     hence contradiction by A49,A62,A65,A67,FUNCT_1:12;
   end;
   end;
    hence thesis;
  end;
  end;
end;
end;

theorem Th5: :: CFS1:
for A being finite set holds rng canFS(A) = A
proof let A be finite set; set F = canFS(A), cA = card A;
A1: len F = card A by Def1;
   consider f being FinSequence such that
A2: len f = cA and
A3: f.1 = [choose A, A \ {choose A}] or card A = 0 and
A4: for i being Nat st 1 <= i & i < cA
    for x being set
     st f.i = x holds f.(i+1) = [choose x`2, x`2 \ {choose x`2}] and
A5: for i being Nat st i in dom F holds F.i = (f.i)`1 by Def1;
 per cases;
 suppose A6: A = {};
    then F = {} by A1,CARD_1:78,FINSEQ_1:25;
  hence thesis by A6,FINSEQ_1:27;
 end;
 suppose A7: A <> {};
then card A <> 0 by GRAPH_5:5; then card A > 0 by NAT_1:19;
then A8: 0+1 <= len F by A1,NAT_1:38;
then A9: 1 in dom F by FINSEQ_3:27;
 defpred P[Nat, set] means
 rng (F| Seg $1) \/ ($2)`2 = A &
 ex X being finite set st X = ($2)`2  & card X +$1 = cA;
A10: P[1, f.1] proof
         reconsider F1 = (F | Seg 1) as FinSequence of A by FINSEQ_1:23;
     consider a being Element of A such that
     A11: F1 = <* a *> by A7,A8,QC_LANG4:7;      1 in Seg (0+1) by FINSEQ_1:6;
         then F1.1 = F.1 by FUNCT_1:72
              .= (f.1)`1 by A5,A9 .= choose A by A3,A7,GRAPH_5:5,MCART_1:7;
         then F | Seg 1 = <* choose A *> by A11,FINSEQ_1:57;
     then A12: rng (F| Seg 1) = {choose A} by FINSEQ_1:56;
     A13: (f.1)`2 = A \ {choose A} by A3,A7,GRAPH_5:5,MCART_1:7;
            {choose A} c= A by A7,ZFMISC_1:37;
      hence rng (F| Seg 1) \/ (f.1)`2 = A by A12,A13,XBOOLE_1:45;
      reconsider X = A \ {choose A} as finite set;
      take X;      thus X = (f.1)`2 by A3,A7,GRAPH_5:5,MCART_1:7;
     A14: now assume choose A in A \ {choose A};
          then not choose A in {choose A} by XBOOLE_0:def 4;
          hence contradiction by TARSKI:def 1;
         end;
            {choose A} c= A by A7,ZFMISC_1:37;
         then A = {choose A} \/ (A \ {choose A}) by XBOOLE_1:45;
      hence card X + 1 = cA by A14,CARD_2:54;
    end;
A15: for i being Nat st 1 <= i & i < len f & P[i, f.i] holds P[i+1, f.(i+1)]
    proof let i be Nat such that
    A16: 1 <= i and
    A17: i < len f and
    A18: P[i, f.i];
        consider X being finite set such that
    A19: X = (f.i)`2  and
    A20: card X +i = cA by A18;
    A21: f.(i+1) = [choose (f.i)`2, (f.i)`2 \ {choose (f.i)`2}] by A2,A4,A16
,A17;
       (f.i)`2 is non empty by A2,A17,A19,A20,CARD_1:78;
        then {choose (f.i)`2} c= (f.i)`2 by ZFMISC_1:37;
    then A22: (f.i)`2 = {choose (f.i)`2} \/ ((f.i)`2 \ {choose (f.i)`2})
         by XBOOLE_1:45;
    A23: i+1 <= len F by A1,A2,A17,NAT_1:38;
           1 <= i+1 by NAT_1:37;
    then A24: i+1 in dom F by A23,FINSEQ_3:27;
        reconsider Fi = F| Seg i, Fi1 = F| Seg (i+1) as FinSequence of A
          by FINSEQ_1:23;
        consider a being Element of A such that
    A25: Fi1 = Fi^<*a*> by A7,A23,QC_LANG4:6;
    A26: rng Fi1 = rng Fi \/ rng <*a*> by A25,FINSEQ_1:44
               .= rng Fi \/ {a} by FINSEQ_1:56;
           i+1 in Seg (i+1) by FINSEQ_1:6;
    then A27: F.(i+1) = Fi1.(i+1) by FUNCT_1:72;
           i = len Fi by A1,A2,A17,FINSEQ_1:21;
    then A28: a = F.(i+1) by A25,A27,FINSEQ_1:59 .= (f.(i+1))`1 by A5,A24
           .= choose (f.i)`2 by A21,MCART_1:7;
    then (f.(i+1))`2 = (f.i)`2 \ {a} by A21,MCART_1:7;
    hence rng (F| Seg (i+1)) \/ (f.(i+1))`2 = A by A18,A22,A26,A28,XBOOLE_1:4;
     reconsider XX = (f.i)`2 \{choose(f.i)`2} as finite set by A19,FINSET_1:16
;
     take XX;
     thus XX = (f.(i+1))`2 by A21,MCART_1:7;
           now assume choose (f.i)`2 in (f.i)`2 \ {choose (f.i)`2};
          then not choose (f.i)`2 in {choose (f.i)`2} by XBOOLE_0:def 4;
          hence contradiction by TARSKI:def 1;
         end;
       then card X = card XX + 1 by A19,A22,CARD_2:54;
      hence card XX + (i+1) = cA by A20,XCMPLX_1:1;
    end;
A29: for i being Nat st 1<=i & i<=len f holds P[i, f.i] from IndFinSeq0(A10,A15
);
   A30: now assume len F < 1; then len F = 0 by NAT_1:39;
    hence contradiction by A1,A7,GRAPH_5:5;
   end;
   F = F | (Seg len F) by FINSEQ_3:55;
then A31: rng F \/ (f.len F)`2 = A by A1,A2,A29,A30;
   consider X being finite set such that
A32: X = (f.len F)`2  and
A33: card X + len f = cA by A1,A2,A29,A30;
      card X = 0 by A2,A33,XCMPLX_1:3;
   then X = {} by GRAPH_5:5;
 hence rng canFS(A) = A by A31,A32;
end;
end;

theorem Th6: :: CFS2:
for a being set holds canFS({a}) = <* a *>
proof let a be set;
A1: len canFS({a}) = card {a} by Def1 .= 1 by CARD_1:79;
      rng canFS({a}) = {a} by Th5;
 hence canFS({a}) = <* a *> by A1,FINSEQ_1:56;
end;

theorem Th7: :: CFS3:
for A being finite set holds (canFS A)" is Function of A, Seg card A
proof let A be finite set;
A1: canFS A is one-to-one by Th4;
      len canFS A = card A by Def1;
then A2: dom canFS A = Seg card A by FINSEQ_1:def 3;
      rng canFS A = A by Th5;
then A3: dom ((canFS A)") = A by A1,FUNCT_1:55;
      rng ((canFS A)") = Seg card A by A1,A2,FUNCT_1:55;
 hence (canFS A)" is Function of A, Seg card A by A3,FUNCT_2:3;
end;

begin :: More about bags

definition
let X be set, S be finite Subset of X, n be Nat;
func (S, n)-bag -> Element of Bags X equals    :Def2:
 (EmptyBag X) +* (S --> n);
 correctness proof
   set b = (EmptyBag X) +* (S --> n);
 A1: dom (S --> n) = S by FUNCOP_1:19;
 A2: EmptyBag X = (X --> 0) by POLYNOM1:def 15;
 A3: dom b = dom (EmptyBag X) \/ dom (S --> n) by FUNCT_4:def 1
         .= X \/ dom (S --> n) by A2,FUNCOP_1:19 .= X \/ S by FUNCOP_1:19
         .= X by XBOOLE_1:12;
       rng (EmptyBag X) c= {0} & rng (S-->n) c= {n} by A2,FUNCOP_1:19;
 then A4: rng (EmptyBag X) \/ rng (S --> n) c= {0} \/ {n} by XBOOLE_1:13;
 A5: {0} c= NAT by ZFMISC_1:37;
    {n} c= NAT by ZFMISC_1:37;
 then A6: {0} \/ {n} c= NAT by A5,XBOOLE_1:8;
       rng b c= rng (EmptyBag X) \/ rng (S --> n) by FUNCT_4:18;
    then rng b c= {0} \/ {n} by A4,XBOOLE_1:1;
    then A7: rng b c= NAT by A6,XBOOLE_1:1;
 A8: now let i be set such that
    A9: not i in S;
      thus b.i = (EmptyBag X).i by A1,A9,FUNCT_4:12 .= 0 by POLYNOM1:56;
    end;
 A10: now let i be set such that A11: i in S;
      thus b.i = (S --> n).i by A1,A11,FUNCT_4:14 .= n by A11,FUNCOP_1:13;
    end;
      support b is finite proof
     per cases;
     suppose A12: S is empty;
          now assume support b is non empty; then consider x being set
such that
       A13: x in support b by XBOOLE_0:def 1;
             b.x <> 0 by A13,POLYNOM1:def 7;
        hence contradiction by A8,A12;
       end;
      hence support b is finite;
     end;
     suppose A14:  S is non empty & n = 0;
          now assume support b is non empty; then consider x being set
such that
       A15: x in support b by XBOOLE_0:def 1;
          b.x <> 0 by A15,POLYNOM1:def 7;
       then A16: x in S by A8;
           then b.x = (S-->n).x by A1,FUNCT_4:14 .= 0 by A14,A16,FUNCOP_1:13;
        hence contradiction by A15,POLYNOM1:def 7;
       end;
      hence support b is finite;
     end;
     suppose S is non empty & n <> 0;
       then for x being set holds x in S iff b.x <> 0 by A8,A10;
      hence support b is finite by POLYNOM1:def 7;
    end;
    end;
    then (EmptyBag X) +* (S --> n) is bag of X by A3,A7,PBOOLE:def 3
,POLYNOM1:def 8,SEQM_3:def 8;
  hence (EmptyBag X) +* (S --> n) is Element of Bags X by POLYNOM1:def 14;
 end;
end;

theorem Th8: :: Snbag0:
for X being set, S being finite Subset of X, n being Nat, i being set
 st not i in S holds (S, n)-bag.i = 0
proof let X be set, S be finite Subset of X, n be Nat, i be set such that
A1: not i in S;
A2: dom (S --> n) = S by FUNCOP_1:19;
      (S, n)-bag = (EmptyBag X) +* (S --> n) by Def2;
 hence (S, n)-bag.i = (EmptyBag X).i by A1,A2,FUNCT_4:12 .= 0 by POLYNOM1:56
;
end;

theorem Th9: :: Snbag1:
for X being set, S being finite Subset of X, n being Nat, i being set
 st i in S holds (S, n)-bag.i = n
proof let X be set, S be finite Subset of X, n be Nat, i be set such that
A1: i in S;
A2: dom (S --> n) = S by FUNCOP_1:19;
      (S, n)-bag = (EmptyBag X) +* (S --> n) by Def2;
 hence (S, n)-bag.i = (S --> n).i by A1,A2,FUNCT_4:14 .= n by A1,FUNCOP_1:13;
end;

theorem Th10: :: Snbagsup:
for X being set, S being finite Subset of X, n being Nat
 st n <> 0 holds support (S, n)-bag = S
proof let X be set, S be finite Subset of X, n be Nat; assume n <> 0;
   then for x being set holds x in S iff (S, n)-bag.x <> 0 by Th8,Th9;
 hence support (S, n)-bag = S by POLYNOM1:def 7;
end;

theorem :: Snbage: :: :: Snbage:
   for X being set, S being finite Subset of X, n being Nat
 st S is empty or n = 0 holds (S, n)-bag = EmptyBag X
proof let X be set, S be finite Subset of X, n be Nat such that
A1: S is empty or n = 0;
      now let i be set; assume i in X;
    per cases;
    suppose i in S;
     hence (S, n)-bag.i = 0 by A1,Th9 .= (EmptyBag X).i by POLYNOM1:56;
    end;
    suppose not i in S;
     hence (S, n)-bag.i = 0 by Th8 .= (EmptyBag X).i by POLYNOM1:56;
   end;
   end;
 hence (S, n)-bag = EmptyBag X by PBOOLE:3;
end;

theorem Th12: :: Snbagsum:
for X being set, S, T being finite Subset of X, n being Nat
 st S misses T holds (S \/ T, n)-bag = (S,n)-bag + (T,n)-bag
proof let X be set, S, T be finite Subset of X, n be Nat; assume
      S misses T;
then A1: S /\ T = {} by XBOOLE_0:def 7;
      now let i be set such that i in X;
    per cases by XBOOLE_0:def 2;
    suppose
    A2: not i in S \/ T;
    then A3: not i in S & not i in T by XBOOLE_0:def 2;
     thus (S \/ T, n)-bag.i = 0 by A2,Th8 .= (S,n)-bag.i + 0 by A3,Th8
       .= (S,n)-bag.i + (T,n)-bag.i by A3,Th8
       .= ((S,n)-bag + (T,n)-bag).i by POLYNOM1:def 5;
    end;
    suppose
    A4: i in S;
    then A5: i in S \/ T by XBOOLE_0:def 2;
    A6: not i in T by A1,A4,XBOOLE_0:def 3;
     thus (S \/ T, n)-bag.i = n by A5,Th9
       .= (S,n)-bag.i + 0 by A4,Th9 .= (S,n)-bag.i +(T,n)-bag.i by A6,Th8
       .= ((S,n)-bag + (T,n)-bag).i by POLYNOM1:def 5;
    end;
    suppose
    A7: i in T;
    then A8: i in S \/ T by XBOOLE_0:def 2;
    A9: not i in S by A1,A7,XBOOLE_0:def 3;
     thus (S \/ T, n)-bag.i = n by A8,Th9 .= (T,n)-bag.i + 0 by A7,Th9
       .= (S,n)-bag.i + (T,n)-bag.i by A9,Th8
       .= ((S,n)-bag + (T,n)-bag).i by POLYNOM1:def 5;
   end;
   end;
 hence (S \/ T, n)-bag = (S,n)-bag + (T,n)-bag by PBOOLE:3;
end;

definition
 let X be set;
 mode Rbag of X is real-yielding finite-support ManySortedSet of X;
end;

definition
  let A be set, b be Rbag of A;
  func Sum b -> real number means                                    :Def3:
  ex f being FinSequence of REAL st it = Sum f & f = b*canFS(support b);
  existence proof set cS = canFS(support b);
   set f = b*cS;
  A1: rng b c= REAL by SEQ_1:def 1;
  A2: support b c= dom b by POLYNOM1:41;  rng cS = support b by Th5;
      then dom f = dom cS by A2,RELAT_1:46;
     then dom f = Seg len cS by FINSEQ_1:def 3;
  then A3: f is FinSequence by FINSEQ_1:def 2;
       rng f c= rng b by RELAT_1:45; then rng f c= REAL by A1, XBOOLE_1:1;
   then reconsider f as FinSequence of REAL by A3, FINSEQ_1:def 4;
   take S = Sum f; thus thesis;
  end;
  uniqueness;
end;

notation
  let A be set, b be bag of A;
  synonym degree b for Sum b;
end;

definition
  let A be set, b be bag of A;
  redefine func degree b -> Nat means                                   :Def3n:
  ex f being FinSequence of NAT st it = Sum f & f = b*canFS(support b);
  coherence proof
     consider f being FinSequence of REAL such that
  A: degree b = Sum f and
  B: f = b*canFS(support b) by Def3;
     rng f c= NAT proof let y be set; assume y in rng f;
         then consider x being set such that
     A8: x in dom f and
     A9: y = f.x by FUNCT_1:def 5; 
         f.x = b.((canFS(support b)).x) by B, A8, FUNCT_1:22; then f.x is Nat;
      hence y in NAT by A9;
     end; then reconsider f as FinSequence of NAT by FINSEQ_1:def 4;
     Sum f is Nat;
   hence degree b is Nat by A;
  end;
  compatibility proof let n be Nat;
  set cS = canFS(support b);
  hereby assume
  AA: n = degree b;
     consider f being FinSequence of REAL such that
  A: degree b = Sum f and
  B: f = b*canFS(support b) by Def3;
     rng f c= NAT proof let y be set; assume y in rng f;
         then consider x being set such that
     A8: x in dom f and
     A9: y = f.x by FUNCT_1:def 5; 
         f.x = b.((canFS(support b)).x) by B, A8, FUNCT_1:22; then f.x is Nat;
      hence y in NAT by A9;
     end; then reconsider f as FinSequence of NAT by FINSEQ_1:def 4;
   take f;
   thus n = Sum f & f = b*cS by AA, A, B;
  end;
   given f being FinSequence of NAT such that
  A: n = Sum f and
  B: f = b*cS;
    rng f c= NAT by FINSEQ_1:def 4;
    then rng f c= REAL by XBOOLE_1:1;
    then reconsider f as FinSequence of REAL by FINSEQ_1:def 4;
    f = f;
   hence n = degree b by A, B, Def3;
  end;
end;

theorem Th13a: :: BAGDEG0a:
for A being set, b being Rbag of A st b = EmptyBag A holds Sum b = 0
proof let A be set, b be Rbag of A;
  set cS = canFS(support b);
  assume b = EmptyBag A; then support b = {} by BAGORDER:19;
    then len cS = 0 by Def1, CARD_1:78; then cS = <*>NAT by FINSEQ_1:32;
    then A1: b*cS = <*>NAT by RELAT_1:62; set f = <*>NAT;
  thus Sum b = 0 by A1,Def3,RVSUM_1:102;
end;

theorem Th13: :: BAGDEG0:
for A being set, b being bag of A st Sum b = 0 holds b = EmptyBag A
proof let A be set, b be bag of A;
  set cS = canFS(support b);
  assume A2: degree b = 0;
     consider f being FinSequence of NAT such that
  A3: degree b = Sum f and
  A4: f = b*canFS(support b) by Def3n;
       now assume
     A5: support b <> {};   A6: f is FinSequence of REAL by FINSEQ_2:27;
     A7: for i be Nat st i in dom f holds 0 <= f.i by NAT_1:18;
          now consider x being set such that
         A8: x in support b by A5, XBOOLE_0:def 1;
               x in rng cS by A8, Th5; then consider i being Nat such that
         A9: i in dom cS and
         A10: cS.i = x by FINSEQ_2:11;
              support b c= dom b by POLYNOM1:41;
         then A11: i in dom f by A4,A8,A9,A10,FUNCT_1:21;
               f.i = b.(cS.i) by A9, A4, FUNCT_1:23;
             then f.i <> 0 by A8, A10, POLYNOM1:def 7;
             then 0 < f.i by NAT_1:19;
          hence ex i being Nat st i in dom f & 0 < f.i by A11;
         end;
       hence contradiction by A2,A3,A6,A7,RVSUM_1:115;
     end;
  hence b = EmptyBag A by BAGORDER:20;
end;

theorem Th14: :: BAGDEG1:
for A being set, S being finite Subset of A, b being bag of A
 holds S = support b & degree b = card S iff b = (S, 1)-bag
proof let A be set, S be finite Subset of A, b be bag of A;
  set cS = canFS(S);    set f = b*cS;
A1: rng cS = S by Th5;
A2: dom b = A by PBOOLE:def 3;
then A3: dom f = dom cS by A1,RELAT_1:46;
then A4: dom f = Seg len cS by FINSEQ_1:def 3;
   then reconsider f as FinSequence by FINSEQ_1:def 2;
A5: len cS = card S by Def1;
A6: rng cS = S by Th5;
A7: len cS = len f by A3,FINSEQ_3:31;
      rng f c= NAT proof let y be set; assume y in rng f;
      then consider x being set such that
   A8: x in dom f and
   A9: y = f.x by FUNCT_1:def 5;
         f.x = b.(cS.x) by A8,FUNCT_1:22;
    hence y in NAT by A9;
   end; then reconsider f as FinSequence of NAT by FINSEQ_1:def 4;
 hereby assume that
 A10: S = support b and
 A11: degree b = card S;
     consider F being FinSequence of NAT such that
 A12: degree b = Sum F and
 A13: F = b*cS by A10,Def3n;
        now let i be Nat; assume
     A14: i in dom F;
     then A15: F.i = b.(cS.i) by A13,FUNCT_1:22;    cS.i in rng cS by A3,A13
,A14,FUNCT_1:12;
       hence F.i <> 0 by A1,A10,A15,POLYNOM1:def 7;
     end;
 then A16: F = len F |-> 1 by A5,A7,A11,A12,A13,Th2;
     set sb = (S, 1)-bag;
 A17: support b = support sb by A10,Th10;
        now
      thus dom b = dom sb by A2,PBOOLE:def 3;
      let x be set; assume x in dom b;
      per cases;
      suppose A18: x in support b;
      A19: cS is one-to-one by Th4;
      A20: rng cS = support b by A10,Th5;
      A21: cS".x in dom cS by A1,A10,A18,A19,FUNCT_1:54;
      then A22: cS".x in Seg len F by A3,A13,FINSEQ_1:def 3;
       thus b.x = b.(cS.(cS".x)) by A18,A19,A20,FUNCT_1:57 .= F.(cS".x) by A13
,A21,FUNCT_1:23
               .= 1 by A16,A22,FINSEQ_2:70 .= sb.x by A10,A18,Th9;
      end;
      suppose A23: not x in support b;
       hence b.x = 0 by POLYNOM1:def 7 .= sb.x by A17,A23,POLYNOM1:def 7;
     end;
     end;
  hence b = (S, 1)-bag by FUNCT_1:9;
 end;
 assume
 A24: b = (S, 1)-bag;
 hence
    S = support b by Th10;
 then A25: degree b = Sum f by Def3n;  set g = (card S) |-> 1;
      now
    thus len f = card S by A3,A5,FINSEQ_3:31;
    thus len g = card S by FINSEQ_2:69;
    let i be Nat; assume
   A26: i in Seg card S;
   then A27: cS.i in S by A3,A4,A5,A6,FUNCT_1:12;
    thus f.i = b.(cS.i) by A4,A5,A26,FUNCT_1:22
            .= 1 by A24,A27,Th9 .= g.i by A26,FINSEQ_2:70;
   end; then f = g by FINSEQ_2:10;
 hence degree b = (card S)*1 by A25,RVSUM_1:110 .= card S;
end;

theorem Th15: :: BAGDEG2c:
for A being set, S being finite Subset of A, b being Rbag of A
 st support b c= S
  ex f being FinSequence of REAL st f = b*canFS(S) & Sum b = Sum f
proof let A be set, S be finite Subset of A, b be Rbag of A such that
A1: support b c= S;   set cS = canFS(S); set f = b*cS;
     len cS = card S by Def1;
then A2: dom cS = Seg card S by FINSEQ_1:def 3;
A3: rng cS = S by Th5;
A4: cS is one-to-one by Th4;
A5: dom b = A by PBOOLE:def 3;
then A6: dom f = Seg card S by A2, A3, RELAT_1:46;
   then reconsider f as FinSequence by FINSEQ_1:def 2;
A7: rng b c= REAL by SEQ_1:def 1;
    rng f c= rng b by RELAT_1:45; then rng f c= REAL by A7, XBOOLE_1:1;
   then reconsider f as FinSequence of REAL by FINSEQ_1:def 4;
   take f; thus f = b*canFS(S);
   set cs = canFS(support b);
A8: cs is one-to-one by Th4;
   consider g being FinSequence of REAL such that
A9: Sum b = Sum g and
A10: g = b*cs by Def3;      len cs = card support b by Def1;
then A11: dom cs = Seg card support b by FINSEQ_1:def 3;
A12: rng cs = support b by Th5;      support b c= A by A1, XBOOLE_1:1;
then A13: dom g = Seg card support b by A10, A11, A12, A5, RELAT_1:46;
then A14: len g = card support b by FINSEQ_1:def 3;
A15: card support b <= card S by A1, CARD_1:80;
 per cases by A15, REAL_1:def 5;
 suppose
 A16: card support b < card S; then consider d being Nat such that
 A17: card S = (card support b) + d and 1 <= d by FSM_1:1;
    set h = d |-> (0 qua Real);
   len h = d by FINSEQ_2:69;
 then A18: dom h = Seg d by FINSEQ_1:def 3;
    reconsider gr = g, fr = f as FinSequence of REAL;
    set F = gr^h;
      len F = len g + len h by FINSEQ_1:35 .= card S by A14,A17,FINSEQ_2:69
;
 then A19: dom F = Seg card S by FINSEQ_1:def 3;
    set dd = {j where j is Nat : j in dom f & f.j = 0};
 A20: now consider x being set such that
    A21: not (x in support b iff x in S) by A16,TARSKI:2;
 consider j being set such
that
    A22: j in dom cS and
    A23: cS.j = x by A1,A3,A21,FUNCT_1:def 5;
        reconsider j as Nat by A22, FINSEQ_3:25;   f.j =b.x by A22, A23,
FUNCT_1
:23;
        then f.j = 0 by A1,A21,POLYNOM1:def 7; then j in dd by A22,
A2, A6;
     hence dd is non empty;
    end;
 A24: dd c= dom f proof let x be set; assume x in dd;
      then ex j being Nat st x = j & j in dom f & f.j = 0;
     hence thesis;
    end;
    then reconsider dd as finite non empty set by A20, FINSET_1:13;
      rng canFS(dd) = dd & dd c= NAT by Th5, A24, A6, XBOOLE_1:1;
    then reconsider cdd = canFS(dd) as FinSequence of NAT by FINSEQ_1:def 4;
    set cdi = cdd";
    reconsider cdi as Function of dd, Seg card dd by Th7;
    reconsider cadd = card dd as non empty Nat by GRAPH_5:5;
 A25: Seg cadd <> {} & Seg card dd c= NAT;
    then reconsider cdi as Function of dd, NAT by FUNCT_2:9;
     set cSr = cS | (dom f \ dd);
 A26: cSr is one-to-one by A4, FUNCT_1:84;
       dom f \ dd c= dom f by XBOOLE_1:36;
     then (dom f \ dd) /\ dom f = dom f \ dd by XBOOLE_1:28;
 then A27: dom cSr = (dom f \ dd) by A2, A6, FUNCT_1:68;
       now let y be set;
      hereby assume y in rng cSr; then consider x being set such that
      A28: x in dom cSr and
      A29: y = cSr.x by FUNCT_1:def 5;
      A30: x in dom cS & x in dom f \ dd by A28, RELAT_1:86;
          then reconsider j = x as Nat by FINSEQ_3:25;
      A31: cSr.x = cS.x by A28, FUNCT_1:70;
            not j in dd by A30, XBOOLE_0:def 4;
          then f.j <> 0 by A30, A2, A6;
          then b.(cS.j) <> 0 by A30, FUNCT_1:23;
       hence y in support b by A29, A31, POLYNOM1:def 7;
      end;
      assume A32: y in support b;
        then consider x being set such that
      A33: x in dom cS and
      A34: y = cS.x by A1,A3,FUNCT_1:def 5;
            now assume x in dd; then consider j being Nat such that
          A35: j = x and
          A36: j in dom f and
          A37: f.j = 0;
            0 = b.(cS.j) by A37, A36, A2, A6, FUNCT_1:23;
           hence contradiction by A32, A35, A34, POLYNOM1:def 7;
          end; then x in dom f \ dd by A33, A2, A6, XBOOLE_0:def 4;
      hence y in rng cSr by A33, A34, FUNCT_1:73;
     end;
     then rng cSr = support b by TARSKI:2;
     then support b, dom f \dd are_equipotent by A26, A27, WELLORD2:def 4;
 then A38: card support b = card (dom f \ dd) by CARD_1:81;
       card (dom f \ dd) = card dom f - card dd by A24, CARD_2:63;
     then card (dom f \ dd) = card S - card dd by A6, FINSEQ_1:78;
      then card support b + card dd = card S by A38,XCMPLX_1:27;
 then A39: card dd = d by A17, XCMPLX_1:2;
      len cdd = card dd by Def1;
 then A40: dom cdd = Seg d by A39, FINSEQ_1:def 3;
 A41: rng cdd = dd by Th5;
 A42: dom cdi = dd by FUNCT_2:def 1;
 A43: cdd is one-to-one by Th4;
 then A44: cdi is one-to-one by FUNCT_1:62;
 A45: rng cdi = Seg d by A43, A40, FUNCT_1:55;
    deffunc Z(set) = cdi /. $1 + card support b;
    consider z being Function such that
 A46: dom z = dd and
 A47: for x being set st x in dd holds z.x = Z(x) from FUNCT_1:sch 3;
 A48: rng z c= Seg card S proof let y be set; assume y in rng z;
         then consider x being set such that
     A49: x in dom z and
     A50: y = z.x by FUNCT_1:def 5;
     A51: y = cdi/.x + card support b by A49, A46, A47, A50;
     A52: cdi/.x = cdi.x by A49, A46, A42, FINSEQ_4:def 4;
           cdi.x in Seg d by A45, A49, A46, A42, FUNCT_1:12;
         then 1 <= cdi/.x & cdi/.x <= d by A52, FINSEQ_1:3;
         then 1 <= cdi/.x + card support b &
         cdi/.x + card support b <= d + card support b by NAT_1:37, AXIOMS:24;
       hence thesis by A17,A51,FINSEQ_1:3;
     end;
    set p = cs"*cS +* z;
 A53: dom p = dom (cs"*cS) \/ dom z by FUNCT_4:def 1;
 A54: now assume dom (cs"*cS) /\ dom z <> {};
         then consider x being set such that
     A55: x in dom (cs"*cS) /\ dom z by XBOOLE_0:def 1;
     A56: x in dom (cs"*cS) & x in dom z by A55, XBOOLE_0:def 3;
         then consider j being Nat such that
     A57: j = x and j in dom f and
     A58: f.j = 0 by A46;
     A59: dom (cs") = support b by A12, A8, FUNCT_1:55;
           j in dom cS by A56, A57, FUNCT_1:21;
         then f.j = b.(cS.j) by FUNCT_1:23;
         then not cS.j in support b by A58, POLYNOM1:def 7;
      hence contradiction by A57, A56, A59, FUNCT_1:21;
     end;
       now let x be set;
      hereby assume A60: x in dom (cs"*cS) \/ dom z;
       per cases by A60, XBOOLE_0:def 2;
       suppose x in dom (cs"*cS);
        hence x in dom F by A2,A19,FUNCT_1:21;
       end;
       suppose x in dom z;
        hence x in dom F by A24, A19, A6, A46;
      end;
      end;
      assume
     A61: x in dom F; then reconsider i = x as Nat by FINSEQ_3:25;
      per cases;
      suppose f.x = 0; then i in dom z by A46, A61, A19, A6;
       hence x in dom (cs"*cS) \/ dom z by XBOOLE_0:def 2;
      end;
      suppose A62: f.x <> 0;
        f.i = b.(cS.i) by A2,A19,A61,FUNCT_1:23;
          then cS.i in support b by A62, POLYNOM1:def 7;  then cS.
i in dom (cs"
) by A8,A12,FUNCT_1:55;
          then i in dom (cs"*cS) by A2,A19,A61,FUNCT_1:21;
       hence x in dom (cs"*cS) \/ dom z by XBOOLE_0:def 2;
     end;
     end;
 then A63: dom (cs"*cS) \/ dom z = dom F by TARSKI:2;
 then A64: dom p = dom F by FUNCT_4:def 1;
      now let x be set such that
    A65: x in dom F;
     per cases by A65, A63, XBOOLE_0:def 2;
     suppose A66: x in dom (cs"*cS);
          then not x in dom z by A54, XBOOLE_0:def 3;
      then A67: p.x = (cs"*cS).x by FUNCT_4:12;
            (cs"*cS).x in rng (cs"*cS) by A66, FUNCT_1:12;
          then (cs"*cS).x in rng (cs") by FUNCT_1:25;
          then A68: (cs"*cS).x in dom cs by A8, FUNCT_1:55;
            Seg card support b c= Seg card S by A15, FINSEQ_1:7;
      hence p.x in dom F by A11,A19,A67,A68;
     end;
     suppose A69: x in dom z;
     then A70: p.x = z.x by FUNCT_4:14;           z.x in rng z by A69,
FUNCT_1:
12;
      hence p.x in dom F by A70, A19, A48;
    end;
    end;
    then reconsider p as Function of dom F, dom F by A64, FUNCT_2:5;
 A71: p is one-to-one proof let a, c be set such that
     A72: a in dom p and
     A73: c in dom p and
     A74: p.a = p.c;
      per cases by A53,A72,A73,XBOOLE_0:def 2;
      suppose A75: a in dom (cs"*cS) & c in dom (cs"*cS);
          then not a in dom z by A54, XBOOLE_0:def 3;
      then A76: p.a = (cs"*cS).a by FUNCT_4:12 .= cs".(cS.a) by A75, FUNCT_1:
22
;
            not c in dom z by A75, A54, XBOOLE_0:def 3;
      then A77: p.c = (cs"*cS).c by FUNCT_4:12 .= cs".(cS.c) by A75, FUNCT_1:
22;
            cS.a in dom (cs") by A75, FUNCT_1:21;
          then cS.a in rng cs by A8, FUNCT_1:55;
      then A78: cs.(cs".(cS.a)) = cS.a by A8, FUNCT_1:57;
            cS.c in dom (cs") by A75, FUNCT_1:21;
          then cS.c in rng cs by A8, FUNCT_1:55;
      then A79: cS".(cS.a) = cS".(cS.c) by A8,A74,A76,A77,A78,FUNCT_1:57;
            a in dom cS by A75, FUNCT_1:21;
      then A80: cS".(cS.a) = a by A4, FUNCT_1:56;
           c in dom cS by A75, FUNCT_1:21;
        hence a = c by A4,A79,A80,FUNCT_1:56;
      end;
      suppose A81: a in dom (cs"*cS) & c in dom z;
      then A82: p.c = z.c by FUNCT_4:14 .= cdi /. c + card support b by A81,
A46, A47;
            not a in dom z by A81, A54, XBOOLE_0:def 3;
      then A83: p.a = (cs"*cS).a by FUNCT_4:12 .= cs".(cS.a) by A81, FUNCT_1:
22
;
            cS.a in dom (cs") by A81, FUNCT_1:21;
          then cs".(cS.a) in rng (cs") by FUNCT_1:12;
      then A84: cs".(cS.a) in dom cs by A8, FUNCT_1:55;
          then reconsider ccc = cs".(cS.a) as Nat by FINSEQ_3:25;
            cdi /. c + card support b <= 0+card support b
              by A74, A82, A83, A84, A11, FINSEQ_1:3;
      then cdi /. c <= 0 by REAL_1:53;
      then cdi /. c = 0 by NAT_1:18;
      then A85: cdi.c = 0 by A81, A46, A42, FINSEQ_4:def 4;
           cdi.c in rng cdi by A81, A46, A42, FUNCT_1:12;
       hence a = c by A45,A85,FINSEQ_1:3;
      end;
      suppose A86: a in dom z & c in dom (cs"*cS);
      then A87: p.a = z.a by FUNCT_4:14 .= cdi /. a + card support b by A86,
A46, A47;
            not c in dom z by A86, A54, XBOOLE_0:def 3;
      then A88: p.c = (cs"*cS).c by FUNCT_4:12 .= cs".(cS.c) by A86, FUNCT_1:
22
;
            cS.c in dom (cs") by A86, FUNCT_1:21;
          then cs".(cS.c) in rng (cs") by FUNCT_1:12;
      then A89: cs".(cS.c) in dom cs by A8, FUNCT_1:55;
          then reconsider ccc = cs".(cS.c) as Nat by FINSEQ_3:25;
            cdi /. a + card support b <= 0+card support b
              by A74, A87, A88, A89, A11, FINSEQ_1:3;
      then cdi /. a <= 0 by REAL_1:53;
      then cdi /. a = 0 by NAT_1:18;
      then A90: cdi.a = 0 by A86, A46, A42, FINSEQ_4:def 4;
           cdi.a in rng cdi by A86, A46, A42, FUNCT_1:12;
       hence a = c by A45,A90,FINSEQ_1:3;
      end;
      suppose A91: a in dom z & c in dom z;
      then A92: p.a = z.a by FUNCT_4:14 .= cdi /. a + card support b by A91,
A46, A47;
        p.c = z.c by A91, FUNCT_4:14 .= cdi /. c + card support b by A91
, A46,
A47;
      then A93: cdi /. a = cdi /. c by A92, A74, XCMPLX_1:2;
            cdi /. a = cdi . a & cdi /. c = cdi . c by A91,A42,A46,
FINSEQ_4:def
4;
       hence a = c by A44, A91, A42, A46, A93, FUNCT_1:def 8;
     end;
     end;
      now let x be set;
     hereby assume x in rng p; then consider a being set such that
     A94: a in dom p and
     A95: x = p.a by FUNCT_1:def 5;
      per cases by A94, FUNCT_4:13;
      suppose A96: a in dom (cs"*cS);
          then not a in dom z by A54, XBOOLE_0:def 3;
     then A97: p.a = (cs"*cS).a by FUNCT_4:12 .= cs".(cS.a) by A96, FUNCT_1:
22;
           cS.a in dom (cs") by A96, FUNCT_1:21;
         then cs".(cS.a) in rng (cs") by FUNCT_1:12;
     then A98: cs".(cS.a) in dom cs by A8, FUNCT_1:55;
           dom cs c= dom F by A15, A19, A11, FINSEQ_1:7;
       hence x in dom F by A98, A97, A95;
      end;
      suppose A99: a in dom z;
      then A100: z.a in rng z by FUNCT_1:12;          p.a = z.a by A99,
FUNCT_4
:14;
       hence x in dom F by A95, A19, A48, A100;
     end;
     end;
     assume A101: x in dom F; then reconsider j = x as Nat by FINSEQ_3:25;
     per cases by A101, FINSEQ_1:38;
     suppose A102: j in dom gr;
     then A103: cs.j in support b by A11,A12,A13,FUNCT_1:12;
     then A104: cS".(cs.j) in Seg card S by A1,A2,A3,A4,FUNCT_1:54;
           now assume
         A105: cS".(cs.j) in dom z;
             A106: (b*cS).(cS".(cs.j)) = b.(cS.(cS".(cs.j))) by A104, A2,
FUNCT_1:23
             .= b.(cs.j) by A1,A3,A4,A103,FUNCT_1:57;
               ex k being Nat st k = cS".(cs.j) & k in dom f & f.k = 0 by
A105,
A46;
          hence contradiction by A103,A106,POLYNOM1:def 7;
         end; then p.(cS".(cs.j)) = (cs"*cS).(cS".(cs.j)) by FUNCT_4:12
         .= cs".(cS.(cS".(cs.j))) by A104, A2, FUNCT_1:23
         .= cs".(cs.j) by A1,A3,A4,A103,FUNCT_1:57 .= j by
A11,A13,A102,A8,FUNCT_1:56;
      hence x in rng p by A19,A64,A104,FUNCT_1:12;
     end;
     suppose ex n being Nat st n in dom h & j=len gr + n;
       then consider n being Nat such that
     A107: n in dom h and
     A108: j = len gr + n;
     A109: cdd.n in dd by A107, A40, A41, A18, FUNCT_1:12;
           then p.(cdd.n) = z.(cdd.n) by  A46, FUNCT_4:14
      .= cdi /. (cdd.n) + card support b by A109, A47
      .= cdi.(cdd.n) + card support b by A109, A42, FINSEQ_4:def 4
      .= n + card support b by A107, A40, A18, A43, FUNCT_1:56 .= j by A13,A108
,FINSEQ_1:def 3;
      hence x in rng p by A6,A19,A24,A64,A109,FUNCT_1:12;
    end;
    end;
 then A110: rng p = dom F by TARSKI:2; then p is onto by FUNCT_2:def 3;
 then A111: p is Permutation of dom F by A71, FUNCT_2:def 4;
 A112: dom (F*p) = dom F by A64, A110, RELAT_1:46;
      now let x be set; assume
    A113: x in dom f;
    per cases;
    suppose A114: f.x = 0;
       reconsider j = x as Nat by A113, FINSEQ_3:25;
    A115: j in dom z by A113, A114, A46;
    then A116: p.x = z.x by FUNCT_4:14 .= cdi /. x + card support b by A115,
A47, A46;
          p.x in dom F by A6,A19,A64,A110,A113,FUNCT_1:12;
        then reconsider px = p.x as Nat by FINSEQ_3:25;
          dom cdi = dd by FUNCT_2:def 1;
    then A117: cdi /. x = cdi.x by A115, A46, FINSEQ_4:def 4;
        A118: cdi.x in Seg card dd by A25, A115, A46, FUNCT_2:7;
        reconsider cdix = cdi /. x as Nat;
     thus f.x = h.(cdix) by A39,A114,A117,A118,FINSEQ_2:70
       .= F.px by A14,A18,A39,A116,A117,A118,FINSEQ_1:def 7 .= (F*p).x by A6,
A19,A112,A113,FUNCT_1:22;
    end;
    suppose A119: f.x <> 0;
    A120: now assume x in dd;
      then ex j being Nat st j=x & j in dom f & f.j = 0;
         hence contradiction by A119;
        end;          f.x = b.(cS.x) by A113, FUNCT_1:22;
        then cS.x in support b by A119, POLYNOM1:def 7;
    then A121: cS.x in rng cs by Th5;
    then A122: cs".(cS.x) in dom cs by A8, FUNCT_1:54;
    A123: p.x = (cs"*cS).x by A46, A120, FUNCT_4:12
           .= cs".(cS.x) by A113, A2, A6, FUNCT_1:23;
        then reconsider px = p.x as Nat by A122,FINSEQ_3:25;
     thus f.x = b.(cS.x) by A113, FUNCT_1:22
       .= b.(cs.px) by A8,A121,A123,FUNCT_1:54
       .= g.(px) by A10, A122, A123,FUNCT_1:23
       .= F.(px) by A11,A13,A122,A123,FINSEQ_1:def 7
       .= (F*p).x by A6,A19,A112,A113,FUNCT_1:22;
    end;
    end;
 then A124: f = F*p by A6,A19,A112,FUNCT_1:9;
 A125: Sum F = addreal $$ F by RVSUM_1:def 10
         .= addreal $$ fr by A111,A124,FINSOP_1:8 .= Sum f by
RVSUM_1:def 10;
      Sum h = 0 by RVSUM_1:111;
    then Sum gr = Sum gr + Sum h .= Sum F by RVSUM_1:105;
  hence Sum b = Sum f by A125, A9;
 end;
 suppose card support b = card S;
  hence Sum b = Sum f by A1,A9,A10,TRIANG_1:3;
end;
end;

theorem Th16: :: BAGDEG2:
for A being set, b, b1, b2 being Rbag of A
 st b = b1 + b2 holds Sum b = Sum b1 + Sum b2
proof let A be set, b, b1, b2 be Rbag of A; assume
A1: b = b1 + b2;
    set S = support b; set SS = support b1 \/ support b2;
A4: dom b = A & dom b1 = A & dom b2 = A by PBOOLE:def 3; then
    support b1 c= A & support b2 c= A  by POLYNOM1:41; then
    SS c= A by XBOOLE_1:8; 
    then reconsider SS as finite Subset of A;
    S c= SS by A1, POLYNOM1:91; then
    consider f being FinSequence of REAL such that
A3: f = b*canFS(SS) and
A2: Sum b = Sum f by Th15;
   support b1 c= SS by XBOOLE_1:7;
   then consider f1r being FinSequence of REAL such that
A6: f1r = b1*canFS(SS) and
A7: Sum b1 = Sum f1r by Th15;
    support b2 c= SS by XBOOLE_1:7;
   then consider f2r being FinSequence of REAL such that
A8: f2r = b2*canFS(SS) and
A9: Sum b2 = Sum f2r by Th15;
   set cS = canFS SS;   rng cS = SS by Th5;
   then A10: dom f = dom cS & dom f1r = dom cS & dom f2r = dom cS
     by A4, A3, A6, A8, RELAT_1:46;
then A11: len f1r = len f2r & len f1r = len f by FINSEQ_3:31;
    now let k be Nat such that
   A12: k in dom f1r;
   A13: f1r/.k = f1r.k by A12, FINSEQ_4:def 4 .= b1.(cS.k) by A12, A6, FUNCT_1:
22;
   A14: f2r/.k = f2r.k by A12, A10, FINSEQ_4:def 4
       .= b2.(cS.k) by A12, A8, A10, FUNCT_1:22;
         f.k = b.(cS.k) by A12, A3, A10, FUNCT_1:22;
    hence f.k = f1r/.k + f2r/.k by A13, A14, A1, POLYNOM1:def 5;
   end;
 hence Sum b = Sum b1 + Sum b2 by A2,A7,A9,A11,INTEGRA1:23;
end;

theorem Th17: :: GROUP_4:18 but about a different Product
for L being associative commutative unital (non empty HGrStr),
    f, g being FinSequence of L, p being Permutation of dom f
  st g = f * p holds Product(g) = Product(f)
proof let L be associative commutative unital (non empty HGrStr),
          f, g be FinSequence of L, p be Permutation of dom f such that
A1: g = f * p;   set mL = (the mult of L);
A2: mL is commutative by MONOID_0:def 11;
A3: mL is associative by GROUP_1:31;
A4: mL has_a_unity by GROUP_1:34;
 thus Product(g) = (the mult of L) $$ g by FVSUM_1:def 9
    .= (the mult of L) $$ f by A1,A2,A3,A4,FINSOP_1:8
    .= Product(f) by FVSUM_1:def 9;
end;

begin :: More on polynomials

definition
  let L be non empty ZeroStr, p be Polynomial of L;
  attr p is non-zero means                                       :Def4:
   p <> 0_. L;
end;

theorem Th18: :: lenNZ
for L being non empty ZeroStr, p being Polynomial of L
 holds p is non-zero iff len p > 0
proof let L be non empty ZeroStr, p be Polynomial of L;
 hereby assume p is non-zero; then p <> 0_. L by Def4;
   then len p <> 0 by POLYNOM4:8;
  hence len p > 0 by NAT_1:19;
 end;
 assume len p > 0; then p <> 0_. L by POLYNOM4:6;
 hence p is non-zero by Def4;
end;

registration
  let L be non trivial (non empty ZeroStr);
  cluster non-zero Polynomial of L;
  existence proof
   consider a being Element of (the carrier of L)\{0.L};
      the carrier of L is non trivial by REALSET2:def 5;
   then A1: (the carrier of L)\{0.L} is non empty by REALSET1:4;
   then A2: a in the carrier of L & not(a in {0.L}) by XBOOLE_0:def 4;
   reconsider a as Element of L by A1,XBOOLE_0:def 4;
   take p = <%a%>;
      p.0 = a & (0_. L).0 = 0.L by POLYNOM3:28,POLYNOM5:33;
   then p <> 0_. L by A2,TARSKI:def 1;
 hence thesis by Def4;
 end;
end;

registration
  let L be non degenerated (non empty multLoopStr_0), x be Element of L;
  cluster <%x, 1.L%> -> non-zero;
  correctness proof 0.L <> 1.L by VECTSP_1:def 21;
   then len <%x, 1.L%> = 2 by POLYNOM5:41;
   hence thesis by Th18;
  end;
end;

theorem Th19:
for L being non empty ZeroStr, p being Polynomial of L
 st len p > 0 holds p.(len p -'1) <> 0.L
proof let L be non empty ZeroStr, p be Polynomial of L; assume
      len p > 0; then consider k being Nat such that
A1: len p = k+1 by NAT_1:22;
      len p = (len p -'1)+1 by A1,BINARITH:39;
  hence p.(len p -'1) <> 0.L by ALGSEQ_1:25;
end;

theorem Th20: :: plen1:
for L being non empty ZeroStr, p being AlgSequence of L
 st len p = 1 holds p = <%p.0%> & p.0 <> 0.L
proof let L be non empty ZeroStr, p being AlgSequence of L such that
A1: len p = 1;
 thus p=<%p.0%> by A1,ALGSEQ_1:def 6;
 hence p.0 <> 0.L by A1,ALGSEQ_1:31;
end;

theorem Th21: :: P4Th5: from POLYNOM4:5 right-distributive
for L be add-associative right_zeroed right_complementable
         right-distributive (non empty doubleLoopStr),
    p be Polynomial of L holds p*'(0_.(L)) = 0_.(L)
proof let L be add-associative right_zeroed right_complementable
            right-distributive (non empty doubleLoopStr), p be Polynomial of L;
     now let i be Nat;  consider r be FinSequence of L such that
         len r = i+1 and
  A1: (p*'(0_.(L))).i = Sum r and
  A2: for k be Nat st k in dom r holds r.k = p.(k-'1) * (0_. L).(i+1-'k)
                                                         by POLYNOM3:def 11;
        now let k be Nat; assume k in dom r;
      hence r.k = p.(k-'1) * (0_. L).(i+1-'k) by A2
         .= p.(k-'1) * 0.L by POLYNOM3:28 .= 0.L by VECTSP_1:36;
     end;
     hence (p*'(0_.(L))).i = 0.L by A1,POLYNOM3:1 .= (0_.(L)).i by POLYNOM3:28
;
  end;
 hence thesis by FUNCT_2:113;
end;

registration
  cluster algebraic-closed add-associative right_zeroed right_complementable
     Abelian commutative associative distributive domRing-like
     non degenerated (unital (non empty doubleLoopStr));
   existence proof take F_Complex; thus thesis; end;
end;

theorem Th22: :: pintdom:
for L being add-associative right_zeroed right_complementable distributive
            domRing-like (non empty doubleLoopStr),
    p, q being Polynomial of L
 st p*'q = 0_. L holds p = 0_. L or q = 0_. L
proof let L be add-associative right_zeroed right_complementable distributive
                           domRing-like (non empty doubleLoopStr),
          p, q being Polynomial of L such that
A1: p*'q = 0_. L and
A2: p <> 0_. L and
A3: q <> 0_. L;
A4: len p <> 0 by A2,POLYNOM4:8; then consider lp1 being Nat such that
A5: len p = lp1+1 by NAT_1:22;    len q <> 0 by A3,POLYNOM4:8;
   then consider lq1 being Nat such that
A6: len q = lq1+1 by NAT_1:22;
A7: p.lp1 <> 0.L & q.lq1 <> 0.L by A5,A6,ALGSEQ_1:25;
   set lpq = lp1 + lq1;
   consider r being FinSequence of L such that
A8: len r = lpq+1 and
A9: (p*'q).lpq = Sum r and
A10: for k be Nat st k in dom r holds r.k=p.(k-'1)*q.(lpq+1-'k)
           by POLYNOM3:def 11;    A11: len p <= lp1+1+lq1 by A5,NAT_1:37;
0 < len p by A4,NAT_1:19;
then 0+1 <= len p by NAT_1:38;
then A12: len p in dom r by A8,A11,FINSEQ_3:27;
A13: lpq+1-'len p = lq1+(lp1+1)-'len p .= lq1 by A5,BINARITH:39;
      now let k be Nat such that
   A14: k in dom r and
   A15: k <> len p;
   A16: r.k = p.(k-'1) * q.(lpq+1-'k) by A10,A14;
    per cases by A15,REAL_1:def 5;
    suppose k < len p; then consider d being Nat such that
   A17: len p = k+d & 1 <= d by FSM_1:1;
          lpq+1 = lq1 +len p by A5;
   then A18: lpq+1-'k = lq1+d+k-'k by A17 .= lq1+d by BINARITH:39;
          len q <= lq1+d by A6,A17,AXIOMS:24;
      hence r.k = p.(k-'1)*0.L by A16,A18,ALGSEQ_1:22 .= 0.L by VECTSP_1:36;
    end;
    suppose k > len p; then k >= len p + 1 by NAT_1:38;
        then k-'1 >= len p + 1-'1 by JORDAN3:5; then k-'1 >= len p by
BINARITH:39;
      hence r.k = 0.L * q.(lpq+1-'k) by A16,ALGSEQ_1:22 .= 0.L by VECTSP_1:39
;
   end;
   end;
   then Sum r = r.(len p) by A12,MATRIX_3:14
   .= p.(len p -'1)*q.(lpq+1-'len p) by A10,A12.= p.lp1 * q.lq1 by A5,A13,
BINARITH:39;
   then Sum r <> 0.L by A7,VECTSP_2:def 5;
 hence contradiction by A1,A9,POLYNOM3:28;
end;

registration
  let L be add-associative right_zeroed right_complementable distributive
           domRing-like (non empty doubleLoopStr);
  cluster Polynom-Ring L -> domRing-like;
  correctness proof set PRL = Polynom-Ring L;
    let x, y be Element of PRL;
    reconsider xp = x, yp = y as Polynomial of L by POLYNOM3:def 12;
  A1: 0_. L = 0.PRL  by POLYNOM3:def 12;
    assume x*y = 0.PRL; then xp*'yp = 0_. L by A1,POLYNOM3:def 12;
   hence x = 0.PRL or y = 0.PRL by A1,Th22;
  end;
end;

registration
  let L be domRing, p, q be non-zero Polynomial of L;
  cluster p*'q -> non-zero;
  correctness proof p <> 0_. L & q <> 0_. L by Def4;
   then p*'q <> 0_. L by Th22;
   hence thesis by Def4;
  end;
end;

theorem :: pcomring0:
   for L being non degenerated comRing, p, q being Polynomial of L
 holds Roots p \/ Roots q c= Roots (p*'q)
proof let L be non degenerated comRing, p, q being Polynomial of L;
  let x be set;
  assume A1: x in Roots p \/ Roots q;
  per cases by A1,XBOOLE_0:def 2;
  suppose A2: x in Roots p; then reconsider a = x as Element of L;
       a is_a_root_of p by A2,POLYNOM5:def 9;
    then eval(p,a) = 0.L by POLYNOM5:def 6;
    then eval(p,a) * eval(q,a) = 0.L by VECTSP_1:39;
    then eval(p*'q,a) = 0.L by POLYNOM4:27;
    then a is_a_root_of p*'q by POLYNOM5:def 6;
   hence x in Roots (p*'q) by POLYNOM5:def 9;
  end;
  suppose A3: x in Roots q; then reconsider a = x as Element of L;
       a is_a_root_of q by A3,POLYNOM5:def 9;
    then eval(q,a) = 0.L by POLYNOM5:def 6;
    then eval(p,a) * eval(q,a) = 0.L by VECTSP_1:36;
    then eval(p*'q,a) = 0.L by POLYNOM4:27;
    then a is_a_root_of p*'q by POLYNOM5:def 6;
   hence x in Roots (p*'q) by POLYNOM5:def 9;
end;
end;

theorem Th24: :: pdomring0:
for L being domRing, p, q being Polynomial of L
 holds Roots (p*'q) = Roots p \/ Roots q
proof let L be domRing, p, q being Polynomial of L;
    now let x be set;
  hereby assume
  A1: x in Roots (p*'q); then reconsider a = x as Element of L;
        a is_a_root_of p*'q by A1,POLYNOM5:def 9;
     then eval(p*'q,a) = 0.L by POLYNOM5:def 6;
     then A2: eval(p,a) * eval(q,a) = 0.L by POLYNOM4:27;
   per cases by A2,VECTSP_2:def 5;
   suppose eval(p,a) = 0.L; then a is_a_root_of p by POLYNOM5:def 6;
     then a in Roots p by POLYNOM5:def 9;
    hence x in Roots p \/ Roots q by XBOOLE_0:def 2;
   end;
   suppose eval(q,a) = 0.L; then a is_a_root_of q by POLYNOM5:def 6;
     then a in Roots q by POLYNOM5:def 9;
    hence x in Roots p \/ Roots q by XBOOLE_0:def 2;
  end;
  end;
  assume A3: x in Roots p \/ Roots q;
  per cases by A3,XBOOLE_0:def 2;
  suppose A4: x in Roots p; then reconsider a = x as Element of L;
       a is_a_root_of p by A4,POLYNOM5:def 9;
    then eval(p,a) = 0.L by POLYNOM5:def 6;
    then eval(p,a) * eval(q,a) = 0.L by VECTSP_1:39;
    then eval(p*'q,a) = 0.L by POLYNOM4:27;
    then a is_a_root_of p*'q by POLYNOM5:def 6;
   hence x in Roots (p*'q) by POLYNOM5:def 9;
  end;
  suppose A5: x in Roots q; then reconsider a = x as Element of L;
       a is_a_root_of q by A5,POLYNOM5:def 9;
    then eval(q,a) = 0.L by POLYNOM5:def 6;
    then eval(p,a) * eval(q,a) = 0.L by VECTSP_1:36;
    then eval(p*'q,a) = 0.L by POLYNOM4:27;
    then a is_a_root_of p*'q by POLYNOM5:def 6;
   hence x in Roots (p*'q) by POLYNOM5:def 9;
 end;
 end;
 hence Roots (p*'q) = Roots p \/ Roots q by TARSKI:2;
end;

theorem Th25: :: puminus:
for L being add-associative right_zeroed right_complementable distributive
            (non empty doubleLoopStr),
    p being (Polynomial of L), pc being (Element of Polynom-Ring L)
 st p = pc holds -p = -pc
proof let L be add-associative right_zeroed right_complementable distributive
               (non empty doubleLoopStr),
   p be (Polynomial of L), pc be (Element of Polynom-Ring L) such that
A1: p = pc;
   set PRL = Polynom-Ring L;
   reconsider mpc = -p as Element of PRL by POLYNOM3:def 12;
      p+-p = p-p by POLYNOM3:def 8 .= 0_. L by POLYNOM3:30;
   then pc + mpc = 0_. L by A1,POLYNOM3:def 12 .= 0.PRL by POLYNOM3:def 12
;
 hence -p = -pc by RLVECT_1:def 10;
end;

theorem Th26: :: pminus:
for L being add-associative right_zeroed right_complementable distributive
            (non empty doubleLoopStr),
    p, q being (Polynomial of L), pc, qc being (Element of Polynom-Ring L)
 st p= pc & q = qc holds p-q = pc-qc
proof let L be add-associative right_zeroed right_complementable distributive
               (non empty doubleLoopStr),
    p,q be (Polynomial of L), pc,qc be (Element of Polynom-Ring L) such that
A1: p = pc and
A2: q = qc;
A3: -q = -qc by A2,Th25;
 thus p-q = p+-q by POLYNOM3:def 8 .= pc+-qc by A1,A3,POLYNOM3:def 12
   .= pc-qc by RLVECT_1:def 11;
end;

theorem Th27: :: distrminus:
for L being Abelian add-associative right_zeroed right_complementable
            distributive (non empty doubleLoopStr),
    p, q, r being (Polynomial of L)
 holds  p*'q-p*'r = p*'(q-r)
proof let L be Abelian add-associative right_zeroed right_complementable
               distributive (non empty doubleLoopStr),
    p, q, r be (Polynomial of L);
   set PRL = Polynom-Ring L;
   reconsider pc = p, qc = q, rc = r as Element of PRL by POLYNOM3:def 12;
A1: p*'q = pc*qc by POLYNOM3:def 12;
A2: p*'r = pc*rc by POLYNOM3:def 12;
A3: qc-rc = q-r by Th26;
 thus p*'q-p*'r = pc*qc - pc*rc by A1,A2,Th26
       .= pc*(qc-rc) by VECTSP_1:43 .= p*'(q-r) by A3,POLYNOM3:def 12;
end;

theorem Th28: :: minus0:
for L being add-associative right_zeroed right_complementable distributive
            (non empty doubleLoopStr),
    p, q being (Polynomial of L)
 st p-q = 0_. L holds p = q
proof let L be add-associative right_zeroed right_complementable distributive
            (non empty doubleLoopStr),
          q, r be (Polynomial of L);
   set PRL = Polynom-Ring L;
   reconsider qc = q, rc = r as Element of PRL by POLYNOM3:def 12;
A1: 0_. L = 0.PRL  by POLYNOM3:def 12;
   assume q-r = 0_. L; then qc-rc = 0.PRL by A1,Th26;
 hence q = r by VECTSP_1:84;
end;

theorem Th29: :: pcanc0:
for L being Abelian add-associative right_zeroed right_complementable
            distributive domRing-like (non empty doubleLoopStr),
    p, q, r being Polynomial of L
 st p <> 0_. L & p*'q = p*'r holds q = r
proof let L be Abelian add-associative right_zeroed right_complementable
               distributive domRing-like (non empty doubleLoopStr),
    p, q, r be Polynomial of L; assume
A1: p <> 0_. L;
   set PRL = Polynom-Ring L;
   reconsider pc = p, qc = q, rc = r as Element of PRL by POLYNOM3:def 12;
 assume p*'q = p*'r;
    then p*'q-p*'r = 0_. L by POLYNOM3:30; then p*'(q-r) = 0_. L by Th27;
   then q-r = 0_. L by A1,Th22;
 hence q = r by Th28;
end;

theorem Th30: :: pexp0:
for L being domRing, n being Nat, p being Polynomial of L
 st p <> 0_. L holds p`^n <> 0_. L
proof let L be domRing, n be Nat, p be Polynomial of L; assume
A1: p <> 0_. L;
      (1_. L).0 = 1.L & (0_. L).0 = 0.L by POLYNOM3:28,31;
then A2: 1_. L <> 0_. L by VECTSP_1:def 21;
    defpred P[Nat] means p`^$1 <> 0_. L;
A3: P[0] by A2,POLYNOM5:16;
A4: for n being Nat st P[n] holds P[n+1] proof
       let n be Nat such that
    A5: P[n];           p`^(n+1) = (p`^n) *' p by POLYNOM5:20;
     hence P[n+1] by A1,A5,Th22;
    end;     for n being Nat holds P[n] from NAT_1:sch 1(A3,A4);
  hence p`^n <> 0_. L;
end;

theorem Th31:  :: pexp1:
for L being comRing, i, j being Nat, p being Polynomial of L
 holds (p`^i) *' (p`^j) = p `^(i+j)
proof let L be comRing, i, j being Nat, p be Polynomial of L;
 defpred P[Nat] means (p`^i) *' (p`^$1) = p `^(i+$1);
       (p`^i) *' (p`^0) = (p`^i) *' 1_. L by POLYNOM5:16
    .= (p`^(i+0)) by POLYNOM3:36;
then A1: P[0];
A2: for j being Nat st P[j] holds P[j+1] proof
     let j be Nat such that
    A3: P[j];
          (p`^i) *' (p`^(j+1)) = (p`^i) *' ((p`^j) *' p) by POLYNOM5:20
       .= (p`^(i+j)) *' p by A3,POLYNOM3:34
       .= p`^(i+j+1) by POLYNOM5:20   .= p`^(i+(j+1));
     hence P[j+1];
    end;    for j being Nat holds P[j] from NAT_1:sch 1(A1,A2);
 hence (p`^i) *' (p`^j) = p `^(i+j);
end;

theorem Th32: :: poly1b:
for L being non empty multLoopStr_0 holds 1_.(L) = <%1.L%>
proof let L be non empty multLoopStr_0;
A1: 1_.(L) = 0_.(L)+*(0,1.(L)) by POLYNOM3:def 10;
A2: dom 0_.(L) = NAT by FUNCT_2:def 1;
     now let x be set; assume x in NAT; then reconsider n = x as Nat;
   per cases;
   suppose A3: x = 0;
    hence (1_.(L)).x = 1.(L) by A1,A2,FUNCT_7:33
                   .= <%1.L%>.x by A3,ALGSEQ_1:def 6;
   end;
   suppose A4: n <> 0; then A5: n = 1 or n > 1 by Th1;
    thus (1_.(L)).x = (0_.(L)).n by A1,A4,FUNCT_7:34
      .= 0.L by POLYNOM3:28 .= <%1.L%>.x by A5,POLYNOM5:33;
  end;
  end;
 hence 1_.(L) = <%1.L%> by FUNCT_2:18;
end;

theorem  :: poly1a
   for L being add-associative right_zeroed right_complementable right_unital
            right-distributive (non empty doubleLoopStr),
    p being Polynomial of L
 holds p*'<%1.L%> = p
proof let L be add-associative right_zeroed right_complementable right_unital
               right-distributive      (non empty doubleLoopStr),
    p being Polynomial of L;
 thus p*'<%1.L%> = p*'1_.(L) by Th32 .= p by POLYNOM3:36;
end;

theorem Th34:
for L being add-associative right_zeroed right_complementable distributive
                                                 (non empty doubleLoopStr),
    p, q being Polynomial of L
 st len p = 0 or len q = 0 holds len (p*'q) = 0
proof let L be add-associative right_zeroed right_complementable distributive
               (non empty doubleLoopStr),
          p, q being Polynomial of L; assume
A1: len p = 0 or len q = 0;
   per cases by A1;
   suppose len p = 0; then p = 0_. L by POLYNOM4:8;
     then p*'q = 0_. L by POLYNOM4:5;
    hence len (p*'q) = 0 by POLYNOM4:6;
   end;
   suppose len q = 0; then q = 0_. L by POLYNOM4:8; then p*'q = 0_.
L by Th21;
    hence len (p*'q) = 0 by POLYNOM4:6;
end;
end;

theorem Th35: :: LM1
for L being add-associative right_zeroed right_complementable distributive
                                                 (non empty doubleLoopStr),
    p, q being Polynomial of L
 st p*'q is non-zero holds p is non-zero & q is non-zero
proof let L be add-associative right_zeroed right_complementable distributive
                                                 (non empty doubleLoopStr),
          p, q being Polynomial of L; assume that
A1: p*'q is non-zero and
A2: p is non non-zero or q is non non-zero;
  len p <= 0 or len q <= 0 by A2,Th18;
    then len p = 0 or len q = 0 by NAT_1:18;
   then len (p*'q) = 0 by Th34;
 hence thesis by A1,Th18;
end;

theorem :: LM1a
   for L being add-associative right_zeroed right_complementable distributive
         commutative associative left_unital (non empty doubleLoopStr),
    p, q being Polynomial of L
 st p.(len p -'1) * q.(len q -'1) <> 0.L holds 0 < len (p*'q)
proof let L be add-associative right_zeroed right_complementable distributive
         commutative associative left_unital (non empty doubleLoopStr),
          p, q being Polynomial of L; assume
A1: p.(len p -'1) * q.(len q -'1) <> 0.L;
then A2: len (p*'q) = len p + len q -1 by POLYNOM4:13;
A3: now assume len p <= 0;
        then len p = 0 by NAT_1:18; then p = 0_. L by POLYNOM4:8;
       then p.(len p -'1) = 0.L by POLYNOM3:28;
       hence contradiction by A1,VECTSP_1:39;
      end;
     now assume len q <= 0;
        then len q = 0 by NAT_1:18; then q = 0_. L by POLYNOM4:8;
       then q.(len q -'1) = 0.L by POLYNOM3:28;
       hence contradiction by A1,VECTSP_1:36;
      end;
  then 0+1 <= len p & 0+1 <= len q by A3,NAT_1:38;
  then len p + len q >= 1+1 by REAL_1:55;
  then len p + len q -1 >= 1+1-1 by REAL_1:49;
  then len p + len q -1 >= 1 & 1 > 0;
 hence thesis by A2;
end;

theorem Th37: :: LM2
for L being add-associative right_zeroed right_complementable distributive
    commutative associative left_unital domRing-like (non empty doubleLoopStr),
    p, q being Polynomial of L
 st 1 < len p & 1 < len q holds len p < len (p*'q)
proof let L be add-associative right_zeroed right_complementable distributive
    commutative associative left_unital domRing-like (non empty doubleLoopStr),
          p, q be Polynomial of L such that
A1: 1 < len p and
A2: 1 < len q;
      0 < len p & 0 < len q by A1,A2;
   then p.(len p -'1) <> 0.L & q.(len q -'1)<>0.L by Th19;
   then p.(len p -'1) * q.(len q -'1)<>0.L by VECTSP_2:def 5;
then A3: len (p*'q) = len p + len q - 1 by POLYNOM4:13;
     len q - 1 > 1-1 by A2,REAL_1:92;
    then len p + (len q - 1) > 0+len p by REAL_1:67;
  hence len p < len (p*'q) by A3;
end;

theorem Th38: :: f2mpoly:
for L being add-associative right_zeroed right_complementable
            left-distributive (non empty doubleLoopStr),
    a, b being Element of L, p being Polynomial of L
 holds (<%a, b%>*'p).0 = a*p.0 &
       for i being Nat holds (<%a, b%>*'p).(i+1) = a*p.(i+1)+b*p.i
proof let L be add-associative right_zeroed right_complementable
            left-distributive (non empty doubleLoopStr),
          a, b be Element of L, q be Polynomial of L;    set p = <%a, b%>;
    consider r being FinSequence of L such that
A1:  len r = 0+1 and
A2:  p*'q.0 = Sum r and
A3:  for k be Nat st k in dom r holds r.k = p.(k-'1) * q.(0+1-'k)
      by POLYNOM3:def 11;
A4:  1 in dom r by A1,FINSEQ_3:27;
    then reconsider r1 = r.1 as Element of L by FINSEQ_2:13;
       r = <*r1*> by A1,FINSEQ_1:57;
    then Sum r = r1 by RLVECT_1:61 .= p.(1-'1) * q.(0+1-'1) by A3,A4
 .= p.0 * q.(0+1-'1) by GOBOARD9:1 .= p.0 * q.0 by BINARITH:39;
 hence (<%a, b%>*'q).0 = a*q.0 by A2,POLYNOM5:39;
 let i be Nat;
    consider r being FinSequence of L such that
A5:  len r = (i+1)+1 and
A6:  p*'q.(i+1) = Sum r and
A7:  for k be Nat st k in dom r holds r.k = p.(k-'1) * q.((i+1)+1-'k)
      by POLYNOM3:def 11;
A8: len r = i+2 by A5;     0 <= i by NAT_1:18;
then A9: 0+2 <= len r by A8,AXIOMS:24; then 1 <= len r by AXIOMS:22;
then A10: 1 in dom r by FINSEQ_3:27;
A11: 2 in dom r by A9,FINSEQ_3:27;
A12: r/.1 = r.1 by A10,FINSEQ_4:def 4
   .= p.(1-'1) * q.((i+1)+1-'1) by A7,A10  .= p.0 * q.((i+1)+1-'1) by
GOBOARD9:1
   .= p.0 * q.(i+1) by BINARITH:39  .= a*q.(i+1) by POLYNOM5:39;
A13: r/.2 = r.2 by A11,FINSEQ_4:def 4
   .= p.(1+1-'1) * q.((i+1)+1-'2) by A7,A11
   .= p.1 * q.((i+1)+1-'2) by BINARITH:39 .= b * q.(i+(1+1)-'2) by POLYNOM5:39
.= b * q.i by BINARITH:39;
     now let k be Nat such that
   A14: 2 < k and
   A15: k in dom r;          k <> 0 by A14; then consider k1 being Nat such
that
   A16: k = k1+1 by NAT_1:22;
   A17: 2 <= k1 by A14,A16,NAT_1:38;
    thus r.k = p.(k-'1) * q.((i+1)+1-'k) by A7,A15
       .= p.k1 * q.((i+1)+1-'k) by A16,BINARITH:39
       .= (0.L) * q.((i+1)+1-'k) by A17,POLYNOM5:39 .= 0.L by VECTSP_1:39;
   end;
 hence (<%a, b%>*'q).(i+1) = a*q.(i+1)+b*q.i by A6,A9,A12,A13,Th3;
end;

theorem Th39: :: LM3a
for L being add-associative right_zeroed right_complementable distributive
            unital commutative associative
            non degenerated (non empty doubleLoopStr),
    r being Element of L, q being non-zero Polynomial of L
 holds len (<%r, 1.L%>*'q) = len q + 1
proof let L be add-associative right_zeroed right_complementable distributive
            unital commutative associative
            non degenerated (non empty doubleLoopStr),
          r be Element of L, q being non-zero Polynomial of L;
   A1: 1.L <> 0.L by VECTSP_1:def 21;
then A2: len <%r, 1.L%> = 2 by POLYNOM5:41;
   set p = <%r, 1.L%>;
      len q > 0 by Th18;
then A3: q.(len q -'1)<>0.L by Th19;
      p.(len p -'1) * q.(len q -'1) = p.(1+1-'1) * q.(len q -'1) by A1,
POLYNOM5:41
   .= p.(1) * q.(len q -'1) by BINARITH:39
   .= 1.L * q.(len q -'1) by POLYNOM5:39
   .= q.(len q -'1) by VECTSP_1:def 19;
 hence len (<%r, 1.L%>*'q) = len q +(1+1)-1 by A2,A3,POLYNOM4:13 .= len q +1;
end;

theorem Th40: :: pexp2
for L being non degenerated comRing, x being Element of L, i being Nat
 holds len (<%x, 1.L%>`^i) = i+1
proof let L be non degenerated comRing, x be Element of L;
  defpred P[Nat] means  len (<%x, 1.L%>`^$1) = $1+1;
  set r = <%x, 1.L%>;
     r`^0 = 1_. L by POLYNOM5:16;
then A1: P[0] by POLYNOM4:7;
A2: for i being Nat st P[i] holds P[i+1] proof let i be Nat such that
    A3: P[i];    i+1 > 0 by NAT_1:18;
     then reconsider ri = r`^i as non-zero Polynomial of L by A3,Th18;
     thus len (r`^(i+1)) = len ((r`^1)*'ri) by Th31
       .= len (r*'ri) by POLYNOM5:17 .= i+1+1 by A3,Th39;
    end;
  thus for i being Nat holds P[i] from NAT_1:sch 1(A1,A2);
end;

registration
  let L be non degenerated comRing, x be Element of L, n be Nat;
  cluster <%x, 1.L%>`^n -> non-zero;
  correctness proof len (<%x, 1.L%>`^n) = n+1 by Th40;
    then len (<%x, 1.L%>`^n) > 0 by NAT_1:19;
   hence thesis by Th18;
  end;
end;

theorem Th41: :: pexp3
for L being non degenerated comRing, x being Element of L,
    q being non-zero (Polynomial of L),  i being Nat
 holds len ((<%x, 1.L%>`^i)*'q) = i + len q
proof let L being non degenerated comRing,  x being Element of L,
          q being non-zero Polynomial of L;
 set r = <%x, 1.L%>;
 defpred P[Nat] means len ((r`^$1)*'q) = $1 + len q;
    len ((r`^0)*'q) = len ((1_. L)*'q) by POLYNOM5:16
 .= 0 + len q by POLYNOM3:36;
then A1: P[0];
A2: for i being Nat st P[i] holds P[i+1] proof let i be Nat such that
    A3: P[i];
           0 <= i & len q > 0 by Th18,NAT_1:18; then i+len q > 0+0 by REAL_1:67
;
        then A4: (r`^i)*'q is non-zero by A3,Th18;
     thus len ((r`^(i+1))*'q) = len ((r`^1)*'(r`^i)*'q) by Th31
       .= len (r*'(r`^i)*'q) by POLYNOM5:17
       .= len (r*'((r`^i)*'q)) by POLYNOM3:34
       .= (i+len q)+1 by A3,A4,Th39
       .= (i+1)+len q;
    end;
 thus for i being Nat holds P[i] from NAT_1:sch 1(A1,A2);
end;

theorem Th42: :: LM3:
for L being add-associative right_zeroed right_complementable distributive
            unital commutative associative
            non degenerated (non empty doubleLoopStr),
    r being Element of L, p, q being Polynomial of L
 st p = <%r, 1.L%>*'q & p.(len p -'1) = 1.L holds q.(len q -'1) = 1.L
proof let L be add-associative right_zeroed right_complementable distributive
            unital commutative associative
            non degenerated (non empty doubleLoopStr),
          x be Element of L, p, q be Polynomial of L such that
A1: p = <%x, 1.L%>*'q and
A2: p.(len p -'1) = 1.L;
   set lp1 = (len p -'1), lq1 = (len q -'1), d = <%x, 1.L%>;
A3: now assume q = 0_. L; then p = 0_. L by A1,POLYNOM3:35;
     then p.(len p -'1) = 0.L by POLYNOM3:28;
    hence contradiction by A2,VECTSP_1:def 21;
   end; then q is non-zero by Def4;
then len p = len q + 1 by A1,Th39;
then A4: lp1 = len q by BINARITH:39;    len q <> 0 by A3,POLYNOM4:8;
   then consider lp2 being Nat such that
A5: lp1 = lp2+1 by A4,NAT_1:22;
A6: q.lp1 = 0.L by A4,ALGSEQ_1:22;
      (<%x, 1.L%>*'q).lp1 = x*q.(lp1)+(1.L)*q.lp2 by A5,Th38
   .= 0.L +(1.L)*q.lp2 by A6,VECTSP_1:36
   .= (1.L)*q.lp2 by RLVECT_1:10 .= q.lp2 by VECTSP_1:def 19;
 hence q.(len q -'1) = 1.L by A1,A2,A4,A5,BINARITH:39;
end;

begin :: Little Bezout theorem

definition
  let L be non empty ZeroStr, p be Polynomial of L; let n be Nat;
  func poly_shift(p,n) -> Polynomial of L means                    :Def5:
    for i being Nat holds it.i = p.(n + i);
  existence proof
     deffunc F(Nat) = p.(n+$1);
     consider ps being AlgSequence of L such that
  A1: len ps <= len p and
  A2: for k being Nat st k < len p holds ps.k = F(k) from ALGSEQ_1:sch 1;
     take ps; let i be Nat;
     per cases;
     suppose i < len p; hence ps.i = p.(n + i) by A2;
     end;
     suppose A3: i >= len p;
     then A4: i >= len ps by A1,AXIOMS:22;
     A5: n+i >= len p by A3,NAT_1:37;
      thus ps.i = 0.L by A4,ALGSEQ_1:22 .= p.(n + i) by A5,ALGSEQ_1:22;
  end;
  end;
  uniqueness proof let it1, it2 be Polynomial of L such that
  A6:     for i being Nat holds it1.i = p.(n + i) and
  A7:     for i being Nat holds it2.i = p.(n + i);
      now let x be set; assume x in NAT;
     then reconsider i = x as Nat;
    thus it1.x = p.(n+i) by A6 .= it2.x by A7;
   end;
   hence it1 = it2 by FUNCT_2:18;
  end;
end;

theorem Th43: :: PS0:
for L being non empty ZeroStr,p being Polynomial of L holds poly_shift(p,0) = p
proof let L be non empty ZeroStr, p be Polynomial of L;
   set ps = poly_shift(p,0);
      now let x be set; assume x in NAT; then reconsider i = x as Nat;
    thus ps.x = p.(0+i) by Def5 .= p.x;
   end;
 hence poly_shift(p,0) = p by FUNCT_2:18;
end;

theorem Th44: :: PS1:
for L being non empty ZeroStr,  n being Nat, p being Polynomial of L
 st n >= len p holds poly_shift(p,n) = 0_. L
proof let L be non empty ZeroStr, n be Nat, p be Polynomial of L; assume
A1: n >= len p;   set ps = poly_shift(p,n);
A2: dom ps = NAT by FUNCT_2:def 1;
      now let z be set; assume z in dom ps; then reconsider i = z as Nat
by FUNCT_2:def 1;
   A3: n+i >= len p by A1,NAT_1:37;
    thus ps.z = p.(n+i) by Def5 .= 0.L by A3,ALGSEQ_1:22;
   end; then ps = NAT --> 0.L by A2,FUNCOP_1:17;
 hence poly_shift(p,n) = 0_. L by POLYNOM3:def 9;
end;

theorem Th45: :: PS2:
for L being non degenerated (non empty multLoopStr_0),
    n being Nat, p being Polynomial of L
 st n <= len p holds len poly_shift(p,n) + n = len p
proof let L be non degenerated (non empty multLoopStr_0),
          n be Nat, p be Polynomial of L such that
A1: n <= len p;
   set ps = poly_shift(p,n), lpn = len p - n;
      n-n <= lpn by A1,REAL_1:49;
   then reconsider lpn as Nat by INT_1:16;
      now let i be Nat; assume i >= lpn;
   then A2: i+n >= len p by REAL_1:86;
    thus ps.i = p.(n+i) by Def5 .= 0.L by A2,ALGSEQ_1:22;
   end;
then A3: lpn is_at_least_length_of ps by ALGSEQ_1:def 3;
      now let m be Nat such that
   A4: m is_at_least_length_of ps and
   A5: lpn > m;          lpn >= m+1 by A5,NAT_1:38;
       then A6: lpn -1 >= m +1-1 by REAL_1:49;         0 <= m by NAT_1:18;
then reconsider lpn1 = lpn -1 as Nat by A6,INT_1:16;
   A7: (n+lpn1)+1 = len p;
   A8: ps.lpn1 = p.(n+lpn1) by Def5;
     p.(n+lpn1) <> 0.L by A7,ALGSEQ_1:25;
    hence contradiction by A4,A6,A8,ALGSEQ_1:def 3;
   end;
 hence len poly_shift(p,n) + n = lpn + n by A3,ALGSEQ_1:def 4
    .= len p;
end;

theorem Th46: :: evps:
for L being  non degenerated comRing,
    x being Element of L, n being Nat, p being Polynomial of L
 st n < len p holds eval(poly_shift(p,n),x) = x*eval(poly_shift(p,n+1),x) + p.n
proof let L be non degenerated comRing,
          x being Element of L, n be Nat, p being Polynomial of L such that
A1: n < len p;
   set ps = poly_shift(p,n), ps1 = poly_shift(p,n+1);
   consider f be FinSequence of L such that
A2: eval(ps,x) = Sum f and
A3: len f = len ps and
A4: for k be Nat st k in dom f holds f.k = ps.(k-'1) * (power L).(x,k-'1)
   by POLYNOM4:def 2;
   consider f1 be FinSequence of L such that
A5: eval(ps1,x) = Sum f1 and
A6: len f1 = len ps1 and
A7: for k be Nat st k in dom f1 holds f1.k = ps1.(k-'1) * (power L).(x,k-'1)
   by POLYNOM4:def 2;
A8: x*(Sum f1) = Sum (x*f1) by FVSUM_1:92;
A9: x*f1 = (x multfield)*f1 by FVSUM_1:def 6;
      rng f1 c= the carrier of L &
   dom (x multfield) = the carrier of L by FINSEQ_1:def 4,FUNCT_2:def 1;
then A10: dom ((x multfield)*f1) = dom f1 by RELAT_1:46;
      now thus len f = len f;
   A11: n+1 <= len p by A1,NAT_1:38;
          len ps1 +1+n = len ps1 + (n+1) .= len p by A11,Th45
.=
len ps + n by A1,Th45;
   then A12: len ps1 + 1 = len ps by XCMPLX_1:2;
   A13: len <*p.n*> = 1 by FINSEQ_1:57;
   A14: len ((x*f1)) = len f1 by A9,A10,FINSEQ_3:31;
    hence
      len (<*p.n*>^(x*f1)) = len f by A3,A6,A12,A13,FINSEQ_1:35;
    let j be Nat such that
   A15: j in Seg len f;
   A16: j in dom f by A15,FINSEQ_1:def 3;
   then A17: 1 <= j & j <= len f by FINSEQ_3:27;
    per cases by A17,REAL_1:def 5;
    suppose A18: j = 1;
    A19: 1 in dom <*p.n*> by A13,FINSEQ_3:27;
     thus f.j = ps.(1-'1) * (power L).(x,1-'1) by A4,A16,A18
       .= ps.0 * (power L).(x,1-'1) by GOBOARD9:1
       .= ps.0 * (power L).(x,0) by GOBOARD9:1 .= ps.0 * 1.L by GROUP_1:def 8
       .= ps.0 by GROUP_1:def 5 .= p.(n+0) by Def5 .= <*p.n*>.1 by FINSEQ_1:57
       .= (<*p.n*>^(x*f1)).j by A18,A19,FINSEQ_1:def 7;
    end;
    suppose 1 < j;
    then A20: 1+1 <= j by NAT_1:38;   1-1 <= j-1 by A17,REAL_1:49;
        then reconsider j1 = j-1 as Nat by INT_1:16;
    A21: 1+1-1 <= j-1 by A20,REAL_1:49;
           j-1 <= len f1 + 1-1 by A3,A6,A12,A17,REAL_1:49;
    then A22: j1 in dom f1 by A21,FINSEQ_3:27;
        then reconsider f1j = f1.j1 as Element of L by FINSEQ_2:13;
           j = j1+1;
    then A23: j1 = j-'1 by BINARITH:39;
           0 < j1 by A21;
        then consider j2 being Nat such that
    A24: j1 = j2+1 by NAT_1:22;
    A25: j1-'1+1 = j1 by A24,BINARITH:39;
    then A26: (n+1)+(j1-'1) = n+j1 by XCMPLX_1:1;
     thus f.j = ps.(j-'1) * (power L).(x,j-'1) by A4,A16
      .= p.(n+j1) * (power L).(x,j1) by A23,Def5
      .= p.((n+1)+(j1-'1)) * (((power L).(x,j1-'1)) * x) by A25,A26,
GROUP_1:def 8
      .= x*(p.((n+1)+(j1-'1)) * (power L).(x,j1-'1)) by GROUP_1:def 4
      .= x*(ps1.(j1-'1) * (power L).(x,j1-'1)) by Def5 .= x*f1j by A7,A22
      .= (x*f1).j1 by A9,A10,A22,FVSUM_1:62
      .= (<*p.n*>^(x*f1)).j by A3,A6,A12,A13,A14,A17,A20,FINSEQ_1:36;
   end;
   end; then f = <*p.n*>^(x*f1)by FINSEQ_2:10;
 hence eval(poly_shift(p,n),x) = x*eval(poly_shift(p,n+1),x) + p.n by A2,A5,A8,
FVSUM_1:89;
end;

theorem Th47: :: Roots0:
for L being non degenerated comRing, p being Polynomial of L
 st len p = 1 holds Roots p = {}
proof let L be non degenerated comRing,  p be Polynomial of L; assume
A1: len p = 1; assume Roots p <> {}; then consider x being set such that
A2: x in Roots p by XBOOLE_0:def 1;
A3: p =<%p.0%> & p.0 <> 0.L by A1,Th20;  reconsider x as Element of L by A2;
      x is_a_root_of p by A2,POLYNOM5:def 9; then eval(p,x) = 0.L by
POLYNOM5:def 6;
 hence contradiction by A3,POLYNOM5:38;
end;

definition
  let L be non degenerated comRing, r be Element of L,  p be Polynomial of L
  such that A1: r is_a_root_of p;
  func poly_quotient(p,r) -> Polynomial of L means                      :Def6:
     len it + 1 = len p &
     for i being Nat holds it.i = eval(poly_shift(p, i+1),r) if len p > 0
  otherwise it = 0_. L;
  existence proof
   hereby assume A2: len p > 0; then consider p1 being Nat such that
  A3: len p = p1+1 by NAT_1:22;     set lq = len p -'1;
  A4: lq = p1 by A3,BINARITH:39;
  A5: len p >= 0+1 by A2,NAT_1:38;     r in Roots p by A1,POLYNOM5:def 9;
then len p <> 1 by Th47;
      then consider lq1 being Nat such that
  A6: lq = lq1 + 1 by A3,A4,A5,NAT_1:22;
  A7: lq1 = lq -'1 by A6,BINARITH:39;
  A8: lq < len p by A3,A4,NAT_1:38;
     deffunc F(Nat) = eval(poly_shift(p, $1+1),r);
     consider q being sequence of L such that
  A9: for k being Nat holds q.k = F(k) from FUNCT_2:sch 4;
     reconsider q as sequence of L;
          q.lq1 = eval(poly_shift(p, lq1+1),r) by A9
            .= r*eval(poly_shift(p, len p),r) + p.lq by A3,A4,A6,A8,Th46
            .= r*eval(0_. L,r) + p.lq by Th44 .= r*0.L + p.lq by POLYNOM4:20
            .= 0.L + p.lq by VECTSP_1:36 .= p.lq by RLVECT_1:10;
  then A10: q.lq1 <> 0.L by A3,A4,ALGSEQ_1:25;
  A11: now let i be Nat such that
      A12: i >= lq;
             i >= p1 by A3,A12,BINARITH:39;
      then A13: i+1 >= len p by A3,AXIOMS:24;
          thus q.i = eval(poly_shift(p, i+1),r) by A9
           .= eval(0_.L,r) by A13,Th44 .= 0.L by POLYNOM4:20;
      end; then reconsider q as AlgSequence of L by ALGSEQ_1:def 2;
     take q;
  A14: lq is_at_least_length_of q by A11,ALGSEQ_1:def 3;
       now let m be Nat; assume A15: m is_at_least_length_of q;
       assume
     A16: lq > m;   0 <= m by NAT_1:18; then consider lq1 being Nat such
that
     A17: lq = lq1 + 1 by A16,NAT_1:22;
       lq1 >= m by A16,A17,NAT_1:38;
       then lq -'1 >= m by A17,BINARITH:39;
      hence contradiction by A7,A10,A15,ALGSEQ_1:def 3;
     end;
   hence len q + 1 =p1+1-'1+1 by A3,A14,ALGSEQ_1:def 4 .=len p by A3,
BINARITH:39;
   thus for k being Nat holds q.k = F(k) by A9;
   end;
   thus thesis;
  end;
  uniqueness proof let it1, it2 be Polynomial of L;
   hereby assume len p > 0; assume that
  A18: len it1 + 1 = len p &
     for i being Nat holds it1.i = eval(poly_shift(p, i+1),r) and
  A19: len it2 + 1 = len p &
     for i being Nat holds it2.i = eval(poly_shift(p, i+1),r);
  A20: len it1 = len it1 +1-1 .= len it2 by A18,A19;
        now let k be Nat such that k < len it1;
      thus it1.k = eval(poly_shift(p, k+1),r) by A18 .= it2.k by A19;
     end;
    hence it1 = it2 by A20,ALGSEQ_1:28;
   end;
   thus thesis;
  end;
  consistency;
end;

theorem Th48: :: pqlen:
for L being non degenerated comRing,
    r being Element of L, p being non-zero Polynomial of L
 st r is_a_root_of p holds len poly_quotient(p,r) > 0
proof let L be non degenerated comRing,
          r be Element of L, p be non-zero Polynomial of L such that
A1: r is_a_root_of p;
   len p > 0 by Th18;
then A2: len poly_quotient(p,r) + 1 = len p by A1,Def6;
  assume len poly_quotient(p,r) <= 0;
  then len poly_quotient(p,r) = 0 by NAT_1:18;
then Roots p = {} by A2,Th47;
 hence contradiction by A1,POLYNOM5:def 9;
end;

theorem Th49: :: Roots1:
for L being add-associative right_zeroed right_complementable
            left-distributive unital (non empty doubleLoopStr),
    x being Element of L
 holds Roots <%-x, 1.L%> = {x}
proof let L be add-associative right_zeroed right_complementable
            left-distributive unital (non empty doubleLoopStr),
          x be Element of L;
    now let a be set;
   hereby assume
   A1: a in Roots <%-x, 1.L%>;
      then reconsider b = a as Element of L;
         b is_a_root_of <%-x, 1.L%> by A1,POLYNOM5:def 9;
      then 0.L = eval(<%-x, 1.L%>,b) by POLYNOM5:def 6
         .= -x + b by POLYNOM5:48; then -x = -b by RLVECT_1:19;
    hence x = a by RLVECT_1:31;
   end;
   assume A2: a = x;
       eval(<%-x, 1.L%>,x) = -x + x by POLYNOM5:48 .= 0.L by RLVECT_1:16;
    then x is_a_root_of <%-x, 1.L%> by POLYNOM5:def 6;
  hence a in Roots <%-x, 1.L%> by A2,POLYNOM5:def 9;
 end;
 hence Roots <%-x, 1.L%> = {x} by TARSKI:def 1;
end;

theorem Th50: :: BZA:
for L being non trivial comRing,
    x being Element of L, p, q  being Polynomial of L
 st p = <%-x,1.L%>*'q holds x is_a_root_of p
proof let L be non trivial comRing,
          x be Element of L, p, q  be Polynomial of L such that
A1: p = <%-x,1.L%>*'q;
A2: eval(<%-x,1.L%>,x) = (-x)+x by POLYNOM5:48 .= 0.L by RLVECT_1:16;
 thus eval(p,x) = eval(<%-x,1.L%>,x) * eval(q,x) by A1,POLYNOM4:27
               .= 0.L by A2,VECTSP_1:39;
end;

theorem  Th51: :: Factor theorem (Bezout)
for L being non degenerated comRing,
    r being Element of L, p being Polynomial of L
 st r is_a_root_of p holds p = <%-r,1.L%>*'poly_quotient(p,r)
proof let L be non degenerated comRing,
          x be Element of L, p be Polynomial of L; assume that
A1: x is_a_root_of p;
   set r = <%-x,1.L%>, pq = poly_quotient(p,x);
   per cases by NAT_1:18;
   suppose A2: len p > 0;
      A3: 0.L <> 1.L by VECTSP_1:def 21;
      p is non-zero by A2,Th18;
   then len pq > 0 by A1,Th48;
then A4: pq.(len pq -'1) <> 0.L by Th19;
       r.(len r -'1) = r.(1+1-'1) by A3,POLYNOM5:41 .= r.1 by BINARITH:39
    .= 1.L by POLYNOM5:39;
then A5: r.(len r -'1) * pq.(len pq -'1) = pq.(len pq -'1) by VECTSP_1:def 19;
     now len (r *' pq) = len r + len pq - 1 by A4,A5,POLYNOM4:13
   .= len pq +(1+1)-1 by A3,POLYNOM5:41 .= len pq +1 .= len p by A1,A2,Def6;
   hence len p = len (r *' pq);
   let k be Nat; assume k < len p;
   defpred P[Nat] means p.$1 = (r*'pq).$1;
A6: (r*'pq).0 = (-x)*pq.0 by Th38
            .= (-x)*eval(poly_shift(p, 0+1),x) by A1,A2,Def6;
A7: 0.L = eval(p,x) by A1,POLYNOM5:def 6 .= eval(poly_shift(p,0),x) by Th43
      .= x*eval(poly_shift(p,0+1),x) + p.0 by A2,Th46;
      (-x)*eval(poly_shift(p, 0+1),x)
     = (-x)*eval(poly_shift(p, 0+1),x) + 0.L by RLVECT_1:def 7
    .= (-x)*eval(poly_shift(p, 0+1),x) + x*eval(poly_shift(p,1),x) + p.0
       by A7,RLVECT_1:def 6
    .= -x*eval(poly_shift(p, 0+1),x) + x*eval(poly_shift(p,1),x) + p.0
       by VECTSP_1:41    .= 0.L +p.0 by RLVECT_1:16 .= p.0 by RLVECT_1:10;
  then A8: P[0] by A6;
  A9: for k being Nat st P[k] holds P[k+1] proof
       let k be Nat; assume P[k];
      A10: pq.(k+1) = eval(poly_shift(p, k+1+1),x) by A1,A2,Def6;
      A11: pq.k = eval(poly_shift(p, k+1),x) by A1,A2,Def6;
      per cases;
      suppose A12: k+1 >= len p;
      then A13: pq.k = eval(0_.L,x) by A11,Th44 .= 0.L by POLYNOM4:20;    k
+1+1
>= len p by A12,NAT_1:37;
      then A14: pq.(k+1) = eval(0_.L,x) by A10,Th44 .= 0.L by POLYNOM4:20;
           (r*'pq).(k+1) = (-x)*pq.(k+1)+(1.L)*pq.k by Th38
      .= 0.L + (1.L)*pq.k by A14,VECTSP_1:36
      .= 0.L + 0.L by A13,VECTSP_1:36 .= 0.L by RLVECT_1:10;
       hence P[k+1] by A12,ALGSEQ_1:22;
      end;
      suppose k+1 < len p;
          then pq.k = x*eval(poly_shift(p, k+1+1),x) + p.(k+1) by A11,Th46;
      then A15: -x*pq.(k+1)+pq.k
        = -x*pq.(k+1)+x*eval(poly_shift(p, k+1+1),x)+p.(k+1) by RLVECT_1:def 6
       .= 0.L + p.(k+1) by A10,RLVECT_1:16;
            (r*'pq).(k+1) = (-x)*pq.(k+1)+(1.L)*pq.k by Th38
      .= (-x)*pq.(k+1)+pq.k by VECTSP_1:def 19
      .= -x*pq.(k+1)+pq.k by VECTSP_1:41;
       hence P[k+1] by A15,RLVECT_1:10;
      end;
      end;       for k being Nat holds P[k] from NAT_1:sch 1(A8,A9);
   hence p.k = (r*'pq).k;
  end;
 hence p = r*'pq by ALGSEQ_1:28;
 end;
 suppose len p = 0; then pq = 0_. L & p = 0_. L by A1,Def6,POLYNOM4:8;
  hence thesis by POLYNOM3:35;
end;
end;

theorem :: Factor theorem (Bezout)
   for L being non degenerated comRing,
    r being Element of L, p, q being Polynomial of L
 st p = <%-r,1.L%>*'q holds r is_a_root_of p
proof let L be non degenerated comRing,
          r be Element of L, p, q be Polynomial of L;
 assume p = <%-r,1.L%>*'q;
 then eval(p,r) = eval(<%-r,1.L%>,r) * eval(q,r) by POLYNOM4:27
            .= (-r+r) * eval(q,r) by POLYNOM5:48
            .= 0.L * eval(q,r) by RLVECT_1:def 10
            .= 0.L by VECTSP_1:39;
 hence thesis by POLYNOM5:def 6;
end;

Lm1: now let L be domRing, p be non-zero Polynomial of L;
      p <> 0_. L by Def4; then len p <> 0 by POLYNOM4:8;
   then len p > 0 by NAT_1:19;
then A1: len p >= 0+1 by NAT_1:38;
  defpred P[Nat] means
  for p being Polynomial of L st len p = $1 holds
  Roots p is finite &
  ex n being Nat st n = Card Roots p & n < len p;
A2: P[1] proof let p be Polynomial of L; assume
    A3: len p = 1;
     hence Roots p is finite by Th47;
     take 0; thus 0 = Card Roots p by A3,Th47,CARD_1:78; thus 0 < len p by A3
;
    end;
A4: for n being Nat st n>=1 & P[n] holds P[n+1] proof
     let n be Nat such that
    A5: n >= 1 and
    A6: P[n];     let p be Polynomial of L; assume
    A7: len p = n+1;
    then A8: len p > 1 by A5,NAT_1:38;
    per cases;
    suppose p is with_roots;
        then consider x being Element of L such that
    A9: x is_a_root_of p by POLYNOM5:def 7;
    A10: len p > 0 by A8;
    A11: p = <%-x,1.L%>*'poly_quotient(p,x) by A9,Th51;
        set r = <%-x,1.L%>, pq = poly_quotient(p,x);
        A12: len pq + 1 = len p by A9,A10,Def6;
    then A13: len pq = n by A7,XCMPLX_1:2;
    then A14: Roots pq is finite by A6;
    A15: Roots r = {x} by Th49;
       Roots p = (Roots r)\/Roots pq by A11,Th24;
     hence Roots p is finite by A14,A15,FINSET_1:14;
        consider k being Nat such that
    A16: k = Card Roots pq and
    A17: k < len pq by A6,A13;
        reconsider Rpq = Roots pq as finite set by A6,A13;
        reconsider Rr = Roots r as finite set by A15;
        reconsider Rp = Rpq \/ Rr as finite set;
        take m = card Rp; thus m = Card Roots p by A11,Th24;
            card Rr = 1 by A15,CARD_1:79;
    then A18:  card Rp <= k + 1 by A16,CARD_2:62;
            k+1 < n+1 by A7,A12,A17,REAL_1:67;
       hence m < len p by A7,A18,AXIOMS:22;
    end;
    suppose A19: not p is with_roots;
    A20: now assume Roots p <> {}; then consider x being set such that
        A21: x in Roots p by XBOOLE_0:def 1;
            reconsider x as Element of L by A21;
               x is_a_root_of p by A21,POLYNOM5:def 9;
         hence contradiction by A19,POLYNOM5:def 7;
        end;
     hence Roots p is finite;
     take 0; thus 0 = Card Roots p by A20,CARD_1:78;
     thus 0 < len p by A8;
    end;
    end;
     for n being Nat st n >= 1 holds P[n] from INT_2:sch 1(A2,A4);
  hence Roots p is finite &
        ex n being Nat st n = Card Roots p & n < len p by A1;
end;

begin :: Polynomials defined by roots

registration  :: It is not true for a comRing. Who knows an example?
  let L be domRing, p be non-zero Polynomial of L;
  cluster Roots p -> finite;
  correctness by Lm1;
end;

definition
  let L be non degenerated comRing, x be Element of L,
      p be non-zero (Polynomial of L);
  func multiplicity(p,x) -> Nat means                              :Def7:
  ex F being finite non empty Subset of NAT
   st F = {k where k is Nat : ex q being Polynomial of L
                      st p = (<%-x, 1.L%>`^k) *' q} &
      it = max F;
  existence proof
A1: len p > 0 by Th18;
   set r = <%-x, 1.L%>;
   defpred P[Nat] means ex q being Polynomial of L st p = (r`^$1) *' q;
   set F = {k where k is Nat : P[k]};
      p = (1_. L) *' p by POLYNOM3:36 .= (r`^0) *' p by POLYNOM5:16;
  then A2: 0 in F;
  A3: F c= len p proof let a be set; assume a in F;
         then consider k being Nat such that
      A4: a = k and
      A5: P[k];          consider q being Polynomial of L such that
      A6: p = (r`^k) *' q by A5;
             now assume len q = 0; then q = 0_. L by POLYNOM4:8;
            then p = 0_. L by A6,POLYNOM4:5;
           hence contradiction by A1,POLYNOM4:6;
          end;
      then A7: len q > 0 by NAT_1:19;
          then reconsider q as non-zero Polynomial of L by Th18;
             now assume k >= len p;
            then k+len q > len p + 0 by A7,REAL_1:67;
           hence contradiction by A6,Th41;
          end; then k in {i where i is Nat : i < len p};
        hence a in len p by A4,AXIOMS:30;
      end;      F c= NAT from FRAENKEL:sch 10;
   then reconsider F as finite non empty Subset of NAT by A2,A3,FINSET_1:13;
   reconsider FF = F as finite non empty natural-membered set;
   reconsider m = max FF as Nat by ORDINAL2:def 21;
   take m; thus thesis;
  end;
  uniqueness;
end;

theorem Th53: :: MULTI1:
for L being non degenerated comRing,
    p being non-zero (Polynomial of L), x being Element of L
 holds x is_a_root_of p iff multiplicity(p,x) >= 1
proof let L be non degenerated comRing,
    p being non-zero (Polynomial of L), x being Element of L;
    set r = <%-x, 1.L%>; set m = multiplicity(p,x);
   consider F being finite non empty Subset of NAT such that
A1: F = {k where k is Nat : ex q being Polynomial of L st p = (r`^k) *' q} and
A2: m = max F by Def7;
 hereby assume x is_a_root_of p;
 then A3: p = r*'poly_quotient(p,x) by Th51;
        r`^1 = r by POLYNOM5:17; then 1 in F by A1,A3;
  hence multiplicity(p,x) >= 1 by A2,PRE_CIRC:def 1;
 end;
 assume
 A4: multiplicity(p,x) >= 1;
        m in F by A2,PRE_CIRC:def 1; then consider k being Nat such that
 A5: m = k and
 A6: ex q being Polynomial of L st p = (r`^k) *' q by A1;
     consider q being Polynomial of L such that
 A7: p = (r`^k) *' q by A6;    m <> 0 by A4;
     then consider k1 being Nat such that
 A8: k = k1+1 by A5,NAT_1:22;
        p = r *' (r`^k1) *' q by A7,A8,POLYNOM5:20
      .= r *' ((r`^k1) *' q) by POLYNOM3:34;
 hence x is_a_root_of p by Th50;
end;

theorem Th54: :: MULTI2:
for L being non degenerated comRing,
    x being Element of L holds multiplicity(<%-x, 1.L%>,x) = 1
proof let L be non degenerated comRing, x be Element of L;
   set r = <%-x, 1.L%>;      0.L <> 1.L by VECTSP_1:def 21;
then A1: len r = 2 by POLYNOM5:41;
   consider F being finite non empty Subset of NAT such that
A2: F = {k where k is Nat : ex q being Polynomial of L st r = (r`^k) *' q} and
A3: multiplicity(r,x) = max F by Def7;
      r = (r`^1) by POLYNOM5:17; then r = (r`^1) *' 1_. L by POLYNOM3:36;
   then 1 in F by A2;
then A4: multiplicity(r,x) >= 1 by A3,PRE_CIRC:def 1;
   set j = multiplicity(r,x);      j in F by A3,PRE_CIRC:def 1;
   then consider k being Nat such that
A5: k = j and
A6: ex q being Polynomial of L st r = (r`^k) *' q by A2;
   consider q being Polynomial of L such that
A7: r = (r`^k) *' q by A6;
      now assume len q = 0; then q = 0_. L by POLYNOM4:8;
     then r = 0_. L by A7,POLYNOM4:5;
    hence contradiction by A1,POLYNOM4:6;
   end;
then A8: len q > 0 by NAT_1:19;
then A9: q is non-zero by Th18;
      now assume k > 1; then k >= 1+1 by NAT_1:38;
       then k+len q > 2+0 by A8,REAL_1:67;
    hence contradiction by A1,A7,A9,Th41;
   end;
 hence multiplicity(<%-x, 1.L%>,x) = 1 by A4,A5,REAL_1:def 5;
end;

definition
  let L be domRing, p be non-zero Polynomial of L;
  func BRoots(p) -> bag of the carrier of L means                    :Def8:
   support it = Roots p &
   for x being Element of L holds it.x = multiplicity(p,x);
  existence proof
    deffunc F(Element of L) = multiplicity(p,$1);
    consider b being Function of the carrier of L, NAT such that
  A1: for x being Element of L holds b.x = F(x) from FUNCT_2:sch 4;
  A2: dom b = the carrier of L by FUNCT_2:def 1;
  then A3: support b c= the carrier of L by POLYNOM1:41;
   A4: now let x be set;
    hereby assume
   A5: x in support b;
   then A6: b.x <> 0 by POLYNOM1:def 7; reconsider xx = x as Element of L by A3
,A5;
   A7: b.x = F(xx) by A1;    0 < b.xx by A6,NAT_1:19;
       then b.xx >= 0+1 by NAT_1:38; then xx is_a_root_of p by A7,Th53;
    hence x in Roots p by POLYNOM5:def 9;
   end;
   assume A8: x in Roots p;
     then reconsider xx = x as Element of L;    xx is_a_root_of p by A8,
POLYNOM5:def 9;
     then multiplicity(p,xx) >= 1 by Th53; then b.xx >= 1 by A1;
     then b.xx <> 0;
    hence x in support b by POLYNOM1:def 7;
    end;
  then support b = Roots p by TARSKI:2;
     then reconsider b as bag of the carrier of L by A2,PBOOLE:def 3
,POLYNOM1:def 8;
     take b;     thus thesis by A1,A4,TARSKI:2;
  end;
  uniqueness proof let it1, it2 be bag of the carrier of L such that
            support it1 = Roots p and
  A9:    for x being Element of L holds it1.x = multiplicity(p,x) and
            support it2 = Roots p and
  A10:    for x being Element of L holds it2.x = multiplicity(p,x);
       now let x be set; assume x in the carrier of L;
        then reconsider xx = x as Element of L;
     thus it1.x = multiplicity(p,xx) by A9 .= it2.x by A10;
    end;
   hence it1 = it2 by PBOOLE:3;
  end;
end;

theorem Th55: :: BR1e:
for L being domRing, x being Element of L
 holds BRoots <%-x, 1.L%> = ({x}, 1)-bag
proof let L be domRing, x be Element of L;
  set r = <%-x, 1.L%>;
      Roots r = {x} by Th49;
then A1: support BRoots r = {x} by Def8;
A2: x in {x} by TARSKI:def 1;
      now let i be set; assume i in the carrier of L;
       then reconsider i1 = i as Element of L;
    per cases;
    suppose A3: i = x;
    thus (BRoots r).i = multiplicity(r,i1) by Def8
        .= 1 by A3,Th54       .= (({x}, 1)-bag).i by A2,A3,Th9;
    end;
    suppose i <> x;
    then A4: not i in {x} by TARSKI:def 1;
      hence (BRoots r).i = 0 by A1,POLYNOM1:def 7
         .= (({x}, 1)-bag).i by A4,Th8;
   end;
   end;
 hence BRoots <%-x, 1.L%> = ({x}, 1)-bag by PBOOLE:3;
end;

theorem Th56: :: BR1da:
for L being domRing, x be Element of L, p, q being non-zero Polynomial of L
  holds multiplicity(p*'q,x) = multiplicity(p,x) + multiplicity(q,x)
proof let L be domRing,x be Element of L,  p, q being non-zero Polynomial of L;
   set r = <%-x, 1.L%>;
   consider F being finite non empty Subset of NAT such that
A1:  F = {k where k is Nat : ex pqq being Polynomial of L
                             st p*'q = (r`^k) *' pqq} and
A2: multiplicity(p*'q,x) = max F by Def7;
   consider f being finite non empty Subset of NAT such that
A3:  f = {k where k is Nat : ex pq being Polynomial of L
                      st p = (r`^k) *' pq} and
A4: multiplicity(p,x) = max f by Def7;
   consider g being finite non empty Subset of NAT such that
A5:  g = {k where k is Nat : ex qq being Polynomial of L
                      st q = (r`^k) *' qq} and
A6: multiplicity(q,x) = max g by Def7;
      max F in F by PRE_CIRC:def 1;
   then consider k being Nat such that
A7: k = max F and
A8: ex pqq being Polynomial of L st p*'q = (r`^k) *' pqq by A1;
    consider pqq being Polynomial of L such that
A9: p*'q = (r`^k) *' pqq by A8;
      max f in f by PRE_CIRC:def 1;
   then consider i being Nat such that
A10: i = max f and
A11: ex pq being Polynomial of L st p = (r`^i) *' pq by A3;
    consider pq being Polynomial of L such that
A12: p = (r`^i) *' pq by A11;
      max g in g by PRE_CIRC:def 1;
   then consider j being Nat such that
A13: j = max g and
A14: ex qq being Polynomial of L st q = (r`^j) *' qq by A5;
    consider qq being Polynomial of L such that
A15: q = (r`^j) *' qq by A14;
A16:  p*'q = (r`^i) *' pq *' (r`^j) *' qq by A12,A15,POLYNOM3:34
        .= (r`^i) *' (r`^j) *' pq  *' qq by POLYNOM3:34
        .= (r`^(i+j)) *' pq  *' qq by Th31
        .= (r`^(i+j)) *' (pq  *' qq) by POLYNOM3:34;
   then i+j in F by A1;
then A17: i+j <= k by A7,PRE_CIRC:def 1;
      now assume i+j < k; then 0+(i+j) < k;
   then A18: 0 < k-(i+j) by REAL_1:86;
       then reconsider kij = k-(i+j) as Nat by INT_1:16;
       consider kk being Nat such that
   A19: kij = kk+1 by A18,NAT_1:22;
          (0_. L).1 = 0.L & r.1 = 1.L by POLYNOM3:28,POLYNOM5:39;
       then r <> 0_. L by VECTSP_1:def 21;
   then A20: r`^(i+j) <> 0_. L by Th30;
          k = kij + (i+j);
       then p*'q = ((r`^(i+j)) *' (r`^kij)) *' pqq by A9,Th31
           .= (r`^(i+j)) *' ((r`^kij) *' pqq) by POLYNOM3:34;
   then A21: (r`^kij) *' pqq = pq  *' qq by A16,A20,Th29;
          (r`^kij) = (r`^1) *' (r`^kk) by A19,Th31
               .= r *' (r`^kk) by POLYNOM5:17;
       then (r`^kij) *' pqq = r *' ((r`^kk) *' pqq) by POLYNOM3:34;
       then x is_a_root_of (pq  *' qq) by A21,Th50;
       then x in Roots (pq  *' qq) by POLYNOM5:def 9;
       then A22: x in (Roots pq \/ Roots qq) by Th24;
    per cases by A22,XBOOLE_0:def 2;
    suppose x in Roots(pq); then x is_a_root_of pq by POLYNOM5:def 9;
      then pq = r *' poly_quotient(pq,x) by Th51;
      then p = (r`^i) *' r *' poly_quotient(pq,x) by A12,POLYNOM3:34
       .= (r`^i) *' (r`^1) *' poly_quotient(pq,x) by POLYNOM5:17
       .= (r`^(i+1)) *' poly_quotient(pq,x) by Th31;
      then i+1 in f by A3; then i+1 <= i by A10,PRE_CIRC:def 1;
     hence contradiction by NAT_1:38;
    end;
    suppose x in Roots(qq); then x is_a_root_of qq by POLYNOM5:def 9;
      then qq = r *' poly_quotient(qq,x) by Th51;
      then q = (r`^j) *' r *' poly_quotient(qq,x) by A15,POLYNOM3:34
       .= (r`^j) *' (r`^1) *' poly_quotient(qq,x) by POLYNOM5:17
       .= (r`^(j+1)) *' poly_quotient(qq,x) by Th31;
      then j+1 in g by A5; then j+1 <= j by A13,PRE_CIRC:def 1;
     hence contradiction by NAT_1:38;
   end;
   end;
  hence multiplicity(p*'q,x) = multiplicity(p,x) + multiplicity(q,x)
     by A2,A4,A6,A7,A10,A13,A17,REAL_1:def 5;
end;

theorem Th57: :: BR1d:
for L being domRing, p, q being non-zero Polynomial of L
 holds BRoots(p*'q) = BRoots(p) + BRoots(q)
proof let L be domRing, p, q being non-zero Polynomial of L;
      now let i be set; assume
      i in the carrier of L;
      then reconsider x = i as Element of L;
    thus (BRoots(p*'q)).i = multiplicity(p*'q, x) by Def8
       .= multiplicity(p,x) + multiplicity(q,x) by Th56
       .= (BRoots p).i + multiplicity(q,x) by Def8
       .= (BRoots p).i + (BRoots q).i by Def8
       .= (BRoots(p) + BRoots(q)).i by POLYNOM1:def 5;
   end;
 hence BRoots(p*'q) = BRoots(p) + BRoots(q) by PBOOLE:3;
end;

Lm2:
now let L be domRing, p, q be non-zero Polynomial of L;
      BRoots(p*'q) = BRoots(p) + BRoots(q) by Th57;
 hence degree BRoots (p*'q) = degree (BRoots p) + degree BRoots q by Th16;
end;

theorem Th58: :: BR1b:
for L being domRing, p being non-zero Polynomial of L
 st len p = 1 holds degree BRoots p = 0
proof let L be domRing, p being non-zero Polynomial of L; assume
      len p = 1; then Roots p = {} by Th47;
   then support BRoots p = {} by Def8;
   then BRoots p = EmptyBag the carrier of L by BAGORDER:20;
 hence degree BRoots p = 0 by Th13a;
end;

theorem Th59: :: BR1c:
for L being domRing, x be Element of L, n being Nat
 holds degree BRoots (<%-x, 1.L%>`^n) = n
proof let L be domRing, x be Element of L;
  set r = <%-x, 1.L%>;
  defpred P[Nat] means degree BRoots (r`^$1) = $1;
  A1: len 1_. L = 1 by POLYNOM4:7;
     r`^0 = 1_. L by POLYNOM5:16;
then A2: P[0] by A1,Th58;
A3: for n being Nat st P[n] holds P[n+1] proof let n be Nat such that
    A4: P[n];
       A5: card {x} = 1 & support ({x},1)-bag = {x} by Th10,CARD_1:79;
          r`^(n+1) = (r`^n)*'r by POLYNOM5:20;
       then degree BRoots(r`^(n+1))
       = degree BRoots (r`^n) + degree BRoots r by Lm2
      .= n + degree ({x},1)-bag by A4,Th55;
     hence P[n+1] by A5,Th14;
    end;
 thus for n being Nat holds P[n] from NAT_1:sch 1(A2,A3);
end;

theorem :: BR2
   for L being algebraic-closed domRing, p being non-zero Polynomial of L
 holds degree BRoots p = len p -' 1
proof let L be algebraic-closed domRing, p be non-zero Polynomial of L;
A1: len p > 0 by Th18;
    defpred P[Nat] means
    for p being non-zero Polynomial of L st len p = $1 & $1 > 0
     holds degree BRoots p = len p -' 1;
A2: for k being Nat st for n being Nat st n < k holds P[n] holds P[k]
   proof let k be Nat; assume
   A3: for n being Nat st n < k holds P[n];
    let p be non-zero Polynomial of L; assume that
   A4: len p = k and
   A5: k > 0;
   A6: k >= 0+1 by A5,NAT_1:38;
    thus thesis proof per cases by A6,REAL_1:def 5;
    suppose A7: k = 1;
     hence degree BRoots p = 1-1 by A4,Th58
        .= len p -' 1 by A4,A7,SCMFSA_7:3;
     end;
     suppose A8: k > 1;
       then p is with_roots by A4,POLYNOM5:def 8;
       then consider x being Element of L such that
   A9: x is_a_root_of p by POLYNOM5:def 7;
   A10: multiplicity(p,x) >= 1 by A9,Th53;
       consider F being finite non empty Subset of NAT such that
   A11: F = {l where l is Nat : ex q being Polynomial of L
                      st p = (<%-x, 1.L%>`^l) *' q} and
   A12: multiplicity(p,x) = max F by Def7;
          max F in F by PRE_CIRC:def 1;
       then consider l being Nat such that
   A13: l = max F and
   A14: ex q being Polynomial of L st p = (<%-x, 1.L%>`^l) *' q by A11;
       consider q being Polynomial of L such that
   A15: p = (<%-x, 1.L%>`^l) *' q by A14;
       set r = <%-x, 1.L%>; set rr = <%-x, 1.L%>`^l;
       reconsider q as non-zero Polynomial of L by A15,Th35;
         len q > 0 by Th18;
   then A16: len q >= 0+1 by NAT_1:38;
      thus thesis proof 0.L <> 1.L by VECTSP_1:def 21;
           then A17: len r = 2 by POLYNOM5:41;
       then A18: len rr = l*2 -l+1 by POLYNOM5:24;
       A19: l*2 -l+1 = l+1;
       A20: len rr > 1 by A10,A12,A13,A18,NAT_1:38;
       A21: len rr > 0 & len q > 0 by Th18;
           then rr.(len rr -'1) <> 0.L & q.(len q -'1) <> 0.L by Th19;
       then A22: rr.(len rr -'1) * q.(len q -'1) <> 0.L by VECTSP_2:def 5;
       per cases by A16,REAL_1:def 5;
       suppose A23: len q = 1;
       A24: len p = len rr + len q -1 by A15,A22,POLYNOM4:13
                .= len rr by A23;
        thus degree BRoots p
        = degree (BRoots rr) + degree BRoots q by A15,Lm2
       .= degree (BRoots rr) + 0 by A23,Th58
       .= 2*l-l+1-1 by Th59
       .= len p -' 1 by A4,A6,A18,A24,SCMFSA_7:3;
       end;
       suppose A25: len q > 1;
       then len rr < k & len q < k by A4,A15,A20,Th37;
       then A26: degree BRoots rr = l+1 -' 1 &
           degree BRoots q = len q -' 1 by A3,A18,A21;
      thus degree BRoots p
         = degree (BRoots rr) + degree BRoots q by A15,Lm2
        .= len rr-'1 + (len q -'1) by A17,A19,A26,POLYNOM5:24
        .= len rr-1 + (len q -'1) by A20,SCMFSA_7:3
        .= len rr-1 + (len q -1) by A25,SCMFSA_7:3
        .= len rr + len q -1 -1
        .= len p -1 by A15,A22,POLYNOM4:13 .= len p -' 1 by A4,A8,SCMFSA_7:3
;
  end;
  end; end;
       end; end;
    for n being Nat holds P[n] from NAT_1:sch 4(A2);
 hence degree BRoots p = len p -' 1 by A1;
end;

definition
  let L be add-associative right_zeroed right_complementable distributive
                                                (non empty doubleLoopStr),
      c be Element of L, n be Nat;
  func fpoly_mult_root(c,n) -> FinSequence of Polynom-Ring L means :Def9:
    len it = n &
    for i being Nat st i in dom it holds it.i = <% -c, 1.L%>;
  existence proof
     <% -c, 1.L%> is Element of Polynom-Ring L by POLYNOM3:def 12;
  then reconsider f = n |-> <% -c, 1.L%>
     as FinSequence of Polynom-Ring L by FINSEQ_2:77;
   take f;
   thus
  A1: len f = n by FINSEQ_2:69;
   let i be Nat;
   assume i in dom f; then i in Seg n by A1,FINSEQ_1:def 3;
   hence f.i = <% -c, 1.L%> by FINSEQ_2:70;
  end;
  uniqueness proof let it1, it2 be FinSequence of Polynom-Ring L such that
A2: len it1 = n and
A3: for i being Nat st i in dom it1 holds it1.i = <% -c, 1.L%> and
A4: len it2 = n and
A5: for i being Nat st i in dom it2 holds it2.i = <% -c, 1.L%>;
A6: dom it1 = dom it2 by A2,A4,FINSEQ_3:31;
       now let x be Nat; assume
    A7: x in dom it1;
     hence it1.x = <% -c, 1.L%> by A3 .= it2.x by A5,A6,A7;
    end;
   hence it1 = it2 by A6,FINSEQ_1:17;
  end;
end;

definition
  let L be add-associative right_zeroed right_complementable distributive
                                                (non empty doubleLoopStr),
      b be bag of the carrier of L;
  func poly_with_roots(b) -> Polynomial of L means                       :Def10
:
 ex f being FinSequence of (the carrier of Polynom-Ring L)*,
    s being FinSequence of L
  st len f = card support b & s = canFS(support b) &
     (for i being Nat st i in dom f holds f.i = fpoly_mult_root(s/.i,b.(s/.i)))
   & it = Product FlattenSeq f;
  existence proof
A1: support b c= dom b & dom b = the carrier of L by PBOOLE:def 3,POLYNOM1:41;
      rng canFS(support b) c= support b by FINSEQ_1:def 4;
   then rng canFS(support b) c= the carrier of L  by A1,XBOOLE_1:1;
   then reconsider s = canFS(support b) as FinSequence of L by FINSEQ_1:def 4;
   deffunc F(set) = fpoly_mult_root(s/.$1,b.(s/.$1));
   consider f being FinSequence such that
A2: len f = card support b and
A3: for k being Nat st k in Seg card support b holds f.k = F(k) from
FINSEQ_1:sch 2;
      rng f c= (the carrier of Polynom-Ring L)* proof let x be set;
     assume x in rng f; then consider i being Nat such that
   A4: i in dom f and
   A5: f.i = x by FINSEQ_2:11;
          i in Seg card support b by A2,A4,FINSEQ_1:def 3;
       then x = F(i) by A3,A5;
    hence x in (the carrier of Polynom-Ring L)* by FINSEQ_1:def 11;
   end;
   then reconsider f as FinSequence of (the carrier of Polynom-Ring L)*
       by FINSEQ_1:def 4;
   reconsider it1 = Product FlattenSeq f as Polynomial of L by POLYNOM3:def 12;
   take it1, f, s;
   thus len f = card support b by A2;
   thus s = canFS(support b);
   hereby let i be Nat; assume i in dom f;
       then i in Seg card support b by A2,FINSEQ_1:def 3;
     hence f.i = fpoly_mult_root(s/.i,b.(s/.i)) by A3;
   end;
   thus thesis;
  end;
  uniqueness proof let it1, it2 be Polynomial of L;
    given f1 being FinSequence of (the carrier of Polynom-Ring L)*,
          s1 being FinSequence of L such that
A6: len f1 = card support b & s1 = canFS(support b) &
     (for i being Nat st i in dom f1
       holds f1.i = fpoly_mult_root(s1/.i,b.(s1/.i)))
   & it1 = Product FlattenSeq f1;
    given f2 being FinSequence of (the carrier of Polynom-Ring L)*,
          s2 being FinSequence of L such that
A7: len f2 = card support b & s2 = canFS(support b) &
     (for i being Nat st i in dom f2
       holds f2.i = fpoly_mult_root(s2/.i,b.(s2/.i)))
   & it2 = Product FlattenSeq f2;
A8: dom f1 = dom f2 by A6,A7,FINSEQ_3:31;
A9: dom f1 = Seg len f1 by FINSEQ_1:def 3;
     now let i be Nat; assume
   A10: i in Seg len f1;
    hence f1.i = fpoly_mult_root(s1/.i,b.(s1/.i)) by A6,A9
              .= f2.i by A6,A7,A8,A9,A10;
   end;
   hence thesis by A6,A7,FINSEQ_2:10;
  end;
end;

theorem Th61: :: poly1:
for L being Abelian add-associative right_zeroed right_complementable
            commutative distributive right_unital (non empty doubleLoopStr)
 holds poly_with_roots(EmptyBag the carrier of L) = <%1.L%>
proof let L be Abelian add-associative right_zeroed right_complementable
               commutative distributive right_unital (non empty doubleLoopStr);
 set b = EmptyBag the carrier of L;
 consider f being FinSequence of (the carrier of Polynom-Ring L)*,
         s being FinSequence of L such that
A1: len f = card support b and s = canFS(support b) and
      for i being Nat st i in dom f holds f.i = fpoly_mult_root(s/.i,b.(s/.i))
and
A2: poly_with_roots(b) = Product FlattenSeq f by Def10;
      card support b = 0 by BAGORDER:19,CARD_1:78;
   then f = <*>((the carrier of Polynom-Ring L)*) by A1,FINSEQ_1:32;
   then FlattenSeq f = <*>(the carrier of Polynom-Ring L) by SCMFSA_7:13;
   then Product FlattenSeq f = 1.Polynom-Ring L by FVSUM_1:98
                       .= 1_.(L) by POLYNOM3:37;
 hence thesis by A2,Th32;
end;

theorem Th62: :: poly1_1:
for L being add-associative right_zeroed right_complementable distributive
                                                 (non empty doubleLoopStr),
    c being Element of L
  holds poly_with_roots(({c},1)-bag) = <% -c, 1.L %>
proof let L be add-associative right_zeroed right_complementable distributive
                                                 (non empty doubleLoopStr),
          c being Element of L;
  set b = ({c},1)-bag;
   consider f being FinSequence of (the carrier of Polynom-Ring L)*,
         s being FinSequence of L such that
A1: len f = card support b and
A2: s = canFS(support b) and
A3: for i being Nat st i in dom f holds f.i = fpoly_mult_root(s/.i,b.(s/.i))and
A4: poly_with_roots(b) = Product FlattenSeq f by Def10;
A5: support b = {c} by Th10;
then A6: card support b = 1 by CARD_1:79;
then A7: f = <*f/.1*> by A1,FINSEQ_5:15;
A8: 1 in dom f by A1,A6,FINSEQ_3:27; then f.1 = f/.1 by FINSEQ_4:def 4;
then A9: FlattenSeq f = f.1 by A7,DTCONSTR:13;
A10: f.1 =  fpoly_mult_root(s/.1,b.(s/.1))  by A3,A8;
   set f1 = fpoly_mult_root(s/.1,b.(s/.1));
A11: s = <* c *> by A2,A5,Th6;     len s = 1 by A2,A6,Def1;
    then 1 in dom s by FINSEQ_3:27;
then A12: s/.1 = s.1 by FINSEQ_4:def 4 .= c by A11,FINSEQ_1:57;
       c in {c} by TARSKI:def 1; then b.(s/.1) = 1 by A12,Th9;
then A13: len f1 = 1 by Def9;
then A14: f1 = <*f1/.1*> by FINSEQ_5:15;
A15: 1 in dom f1 by A13,FINSEQ_3:27;
  thus poly_with_roots(({c},1)-bag)     = f1/.1 by A4,A9,A10,A14,FVSUM_1:99
.= f1.1 by A15,FINSEQ_4:def 4
    .= <% -c, 1.L %> by A12,A15,Def9;
end;

theorem Th63: :: PWRBBa:
for L being add-associative right_zeroed right_complementable distributive
                                                (non empty doubleLoopStr),
    b being bag of the carrier of L,
    f being FinSequence of (the carrier of Polynom-Ring L)*,
    s being FinSequence of L
 st len f = card support b & s = canFS(support b) &
    (for i being Nat st i in dom f holds f.i = fpoly_mult_root(s/.i,b.(s/.i)))
  holds len FlattenSeq f = degree b
proof let L be add-associative right_zeroed right_complementable distributive
                                                (non empty doubleLoopStr),
    b being bag of the carrier of L,
    f being FinSequence of (the carrier of Polynom-Ring L)*,
    s being FinSequence of L such that
A1: len f = card support b and
A2: s = canFS(support b) and
A3: for i being Nat st i in dom f holds f.i = fpoly_mult_root(s/.i,b.(s/.i));
      len s = card support b by A2,Def1;
then A4: dom f = dom s by A1,FINSEQ_3:31;
   reconsider Cf = Card f as FinSequence of NAT;
A5: len FlattenSeq f = Sum Cf by POLYNOM1:30;
   consider g being FinSequence of NAT such that
A6: degree b = Sum g and
A7: g = b*canFS(support b) by Def3n;
     now
   A8: rng s c= dom b proof let x be set; assume x in rng s;
       then A9: x in support b by A2,Th5;     support b c= dom b by POLYNOM1:41
;
         hence x in dom b by A9;
       end;
    thus dom Card f = dom f by CARD_3:def 2
                   .= dom g by A2,A4,A7,A8,RELAT_1:46;
     let i be Nat such that
   A10: i in dom Card f;
   A11: i in dom f by A10,CARD_3:def 2;
       then f.i = fpoly_mult_root(s/.i,b.(s/.i)) by A3;
   then A12: len (f.i) = b.(s/.i) by Def9;
   A13: g.i = b.(s.i) by A2,A4,A7,A11,FUNCT_1:23;
     thus Cf.i = Card (f.i) by A11,CARD_3:def 2
               .= g.i by A4,A11,A12,A13,FINSEQ_4:def 4;
   end;
 hence len FlattenSeq f = degree b by A5,A6,FINSEQ_1:17;
end;

theorem Th64: :: PWRBBb:
for L being add-associative right_zeroed right_complementable distributive
                                                (non empty doubleLoopStr),
    b being bag of the carrier of L,
    f being FinSequence of (the carrier of Polynom-Ring L)*,
    s being FinSequence of L,
    c being Element of L
 st len f = card support b & s = canFS(support b) &
    (for i being Nat st i in dom f holds f.i = fpoly_mult_root(s/.i,b.(s/.i)))
  holds (c in support b implies card ((FlattenSeq f)"{<% -c, 1.L%>}) = b.c) &
        (not c in support b implies card ((FlattenSeq f)"{<% -c, 1.L%>}) = 0)
proof
 let L be add-associative right_zeroed right_complementable distributive
                                                (non empty doubleLoopStr),
     b be bag of the carrier of L,
     f be FinSequence of (the carrier of Polynom-Ring L)*,
     s be FinSequence of L,
     c be Element of L such that
A1: len f = card support b and
A2: s = canFS(support b) and
A3: for i being Nat st i in dom f holds f.i = fpoly_mult_root(s/.i,b.(s/.i));
   A4: len f = len s by A1,A2,Def1;
then A5: dom f = dom s by FINSEQ_3:31;
A6: s is one-to-one by A2,Th4;
  hereby assume c in support b; then c in rng s by A2,Th5;
     then consider i being Nat such that
  A7: i in dom s and
  A8: s.i = c by FINSEQ_2:11;
  A9: s/.i = c by A7,A8,FINSEQ_4:def 4;
  A10: card (b.c) = b.c by CARD_1:66;
  A11: b.c = { k where k is Nat : k < b.c } by AXIOMS:30;
      set ff = FlattenSeq f;  set Y = ff"{<% -c, 1.L%>};
      set X = { k where k is Nat : k < b.c };
      defpred P[set,set] means ex n being Nat st n = $1 &
                                $2 = (Sum Card(f|(i-'1)))+(1+n);
  A12: for x,y1,y2 being set st x in X & P[x,y1] & P[x,y2] holds y1 = y2;
  A13: for x being set st x in X ex y being set st P[x,y] proof
        let x be set; assume x in X; then consider k being Nat such that
      A14: x = k and k < b.c;
        take y = (Sum Card(f|(i-'1)))+(1+k);  thus P[x,y] by A14;
      end;
      consider g being Function such that
  A15: dom g = X and
  A16: for x being set st x in X holds P[x,g.x] from FUNCT_1:sch 2(A12,A13);
  A17: g is one-to-one proof let x1,x2 be set such that
      A18: x1 in dom g and
      A19: x2 in dom g and
      A20: g.x1 = g.x2;          consider n1 being Nat such that
      A21: n1 = x1 and
      A22: g.x1 = (Sum Card(f|(i-'1)))+(1+n1) by A15,A16,A18;
          consider n2 being Nat such that
      A23: n2 = x2 and
      A24: g.x2 = (Sum Card(f|(i-'1)))+(1+n2) by A15,A16,A19;
             1+n1 = 1+n2 by A20,A22,A24,XCMPLX_1:2;
       hence x1 = x2 by A21,A23,XCMPLX_1:2;
      end;
         now let y be set;
       hereby assume y in rng g; then consider x being set such that
       A25: x in dom g and
       A26: y = g.x by FUNCT_1:def 5;
           consider k being Nat such that
       A27: x = k and
       A28: k < b.c by A15,A25;
           consider n being Nat such that
       A29: n = x and
       A30: g.x = (Sum Card(f|(i-'1)))+(1+n) by A15,A16,A25;
       A31: f.i = fpoly_mult_root(s/.i,b.(s/.i)) by A3,A5,A7;
       A32: 1 <= 1+n & 1+n <= b.c by A27,A28,A29,NAT_1:37,38;
              len (f.i) = b.c by A9,A31,Def9;
       then A33: 1+n in dom (f.i) by A32,FINSEQ_3:27;
       then A34:(Sum Card (f|(i-'1))) + (1+n) in dom ff &
          (f.i).(1+n) = ff.((Sum Card (f|(i-'1))) + (1+n))
             by A5,A7,POLYNOM1:33;
             (f.i).(1+n) = <% -c, 1.L%> by A9,A31,A33,Def9;
          then (f.i).(1+n) in {<% -c, 1.L%>} by TARSKI:def 1;
        hence y in Y by A26,A30,A34,FUNCT_1:def 13;
       end;
       assume A35: y in Y;
      then A36: y in dom ff & ff.y in {<% -c, 1.L%>} by FUNCT_1:def 13;
          reconsider yn = y as Nat by A35;
          consider i1, j being Nat such that
      A37: i1 in dom f and
      A38: j in dom (f.i1) and
      A39: yn = (Sum Card (f|(i1-'1))) + j and
      A40: (f.i1).j = ff.yn by A36,POLYNOM1:32;
             j <> 0 by A38,FINSEQ_3:26; then consider j1 being Nat such
that
      A41: j = j1 + 1 by NAT_1:22;
      A42: f.i1 = fpoly_mult_root(s/.i1,b.(s/.i1)) by A3,A37;
              then (f.i1).j = <%-s/.i1, 1.L%> by A38,Def9;
          then A43: <% -c, 1.L%> = <%-s/.i1, 1.L%> by A36,A40,TARSKI:def 1;
               <% -c, 1.L%>.0 = -c & <% -s/.i1,1.L%>.0 = -s/.i1 by
POLYNOM5:39;
          then A44: c = s/.i1 by A43,RLVECT_1:31;
          A45: i1 in dom s by A4,A37,FINSEQ_3:31;   s/.i1 = s.i1 by A5,A37,
FINSEQ_4:def 4;
      then A46: i1 = i by A6,A7,A8,A44,A45,FUNCT_1:def 8;
             len (f.i1) = b.c by A42,A44,Def9;
          then j <= b.c by A38,FINSEQ_3:27; then j1 < b.c by A41,NAT_1:38;
      then A47: j1 in X; then consider n being Nat such that
      A48: n = j1 and
      A49: g.j1 = (Sum Card(f|(i-'1)))+(1+n) by A16;
       thus y in rng g by A15,A39,A41,A46,A47,A48,A49,FUNCT_1:12;
      end;
      then rng g = Y by TARSKI:2; then X,Y are_equipotent by A15,A17,
WELLORD2:def 4;
   hence card ((FlattenSeq f)"{<% -c, 1.L%>}) = b.c by A10,A11,CARD_1:21;
  end;
  assume that
A50: not c in support b and
A51: card ((FlattenSeq f)"{<% -c, 1.L%>}) <> 0;
   consider x being set such that
A52: x in (FlattenSeq f)"{<% -c, 1.L%>} by A51,CARD_1:78,XBOOLE_0:def 1;
A53: x in dom FlattenSeq f by A52,FUNCT_1:def 13;
   reconsider x as Nat by A52;
   consider i, j being Nat such that
A54: i in dom f and
A55: j in dom (f.i) and x = (Sum Card (f|(i-'1))) + j and
A56: (f.i).j = (FlattenSeq f).x by A53,POLYNOM1:32;
      (FlattenSeq f).x in {<% -c, 1.L%>} by A52,FUNCT_1:def 13;
then A57: (FlattenSeq f).x  = <% -c, 1.L%> by TARSKI:def 1;
      f.i = fpoly_mult_root(s/.i,b.(s/.i)) by A3,A54;
then A58: (f.i).j = <% -s/.i, 1.L%> by A55,Def9;
     <% -c, 1.L%>.0 = -c & <% -s/.i, 1.L%>.0 = -s/.i by POLYNOM5:39;
then A59: c = s/.i by A56,A57,A58,RLVECT_1:31;
     s/.i = s.i & s.i in rng s by A5,A54,FINSEQ_4:def 4,FUNCT_1:12;
  hence contradiction by A2,A50,A59,Th5;
end;

theorem Th65: :: PWRBB:
for L being comRing
for b1,b2 being bag of the carrier of L holds
  poly_with_roots(b1+b2) = (poly_with_roots b1)*'(poly_with_roots b2)
proof let L be comRing, b1,b2 be bag of the carrier of L;
  set b = b1+b2;
  consider f being FinSequence of (the carrier of Polynom-Ring L)*,
           s being FinSequence of L such that
A1: len f = card support b and
A2: s = canFS(support b) and
A3: for i being Nat st i in dom f holds f.i = fpoly_mult_root(s/.i,b.(s/.i))
and
A4: poly_with_roots(b1+b2) = Product FlattenSeq f by Def10;
   consider f1 being FinSequence of (the carrier of Polynom-Ring L)*,
           s1 being FinSequence of L such that
A5: len f1 = card support b1 and
A6: s1 = canFS(support b1) and
A7: for i being Nat st i in dom f1
     holds f1.i = fpoly_mult_root(s1/.i,b1.(s1/.i)) and
A8: poly_with_roots(b1) = Product FlattenSeq f1 by Def10;
    consider f2 being FinSequence of (the carrier of Polynom-Ring L)*,
           s2 being FinSequence of L such that
A9: len f2 = card support b2 and
A10: s2 = canFS(support b2) and
A11: for i being Nat st i in dom f2
     holds f2.i = fpoly_mult_root(s2/.i,b2.(s2/.i)) and
A12: poly_with_roots(b2) = Product FlattenSeq f2 by Def10;
    set ff = FlattenSeq f, ff1 = FlattenSeq f1, ff2 = FlattenSeq f2;
    set g = (FlattenSeq f1) ^ (FlattenSeq f2);
A13:  support b = support b1 \/ support b2 by POLYNOM1:42;
A14:  len ff = degree b by A1,A2,A3,Th63;
A15:  len ff2 = degree b2 by A9,A10,A11,Th63;
       len g = len ff1 + len ff2 by FINSEQ_1:35
         .= degree b1 + degree b2 by A5,A6,A7,A15,Th63 .= degree b by Th16;
then A16:  dom ff = dom g by A14,FINSEQ_3:31;
A17:  len s = card support b by A2,Def1;
       now let x be set;
      set ffx = ff"{x}, gx = g"{x};
      per cases;
      suppose x in rng ff; then consider k being Nat such that
      A18: k in dom ff and
      A19: ff.k = x by FINSEQ_2:11;
          consider i, j being Nat such that
      A20: i in dom f and
      A21: j in dom (f.i) and k = (Sum Card (f|(i-'1))) + j and
      A22: (f.i).j = ff.k by A18,POLYNOM1:32;
         f.i = fpoly_mult_root(s/.i,b.(s/.i)) by A3,A20;
      then A23: (f.i).j = <% -s/.i, 1.L %> by A21,Def9;
             i in dom s by A1,A17,A20,FINSEQ_3:31;
          then s.i = s/.i & s.i in rng s by FINSEQ_4:def 4,FUNCT_1:12;
      then A24: s/.i in support b by A2,Th5;
      A25: card (g"{x}) = card (ff1"{x}) + card (ff2"{x}) by FINSEQ_3:63;
       thus card (ff"{x}) = card (g"{x}) proof
        per cases by A13,A24,XBOOLE_0:def 2;
        suppose A26: s/.i in support b1 & not s/.i in support b2;
        then A27: card(ff2"{x}) = 0 by A9,A10,A11,A19,A22,A23,Th64;
         thus card (ff"{x}) = b.(s/.i) by A1,A2,A3,A19,A22,A23,A24,Th64
           .= b1.(s/.i) + b2.(s/.i) by POLYNOM1:def 5
           .= b1.(s/.i) + 0 by A26,POLYNOM1:def 7
           .= card(g"{x}) by A5,A6,A7,A19,A22,A23,A25,A26,A27,Th64;
        end;
        suppose A28: not s/.i in support b1 & s/.i in support b2;
        then A29: card(ff2"{x}) = b2.(s/.i) by A9,A10,A11,A19,A22,A23,Th64;
         thus card (ff"{x}) = b.(s/.i) by A1,A2,A3,A19,A22,A23,A24,Th64
           .= b1.(s/.i) + b2.(s/.i) by POLYNOM1:def 5
           .= 0+b2.(s/.i) by A28,POLYNOM1:def 7
           .= card(g"{x}) by A5,A6,A7,A19,A22,A23,A25,A28,A29,Th64;
        end;
        suppose A30: s/.i in support b1 & s/.i in support b2;
        then A31: card(ff2"{x}) = b2.(s/.i) by A9,A10,A11,A19,A22,A23,Th64;
         thus card (ff"{x}) = b.(s/.i) by A1,A2,A3,A19,A22,A23,A24,Th64
           .= b1.(s/.i) + b2.(s/.i) by POLYNOM1:def 5
           .= card(g"{x}) by A5,A6,A7,A19,A22,A23,A25,A30,A31,Th64;
       end;
       end;
      end;
      suppose A32: not x in rng ff;
             now assume x in rng g;
          then A33: x in (rng ff1 \/ rng ff2) by FINSEQ_1:44;
           per cases by A33,XBOOLE_0:def 2;
           suppose x in rng ff1; then consider k being Nat such that
          A34: k in dom ff1 and
          A35: ff1.k = x by FINSEQ_2:11; consider i, j being Nat such that
          A36: i in dom f1 and
          A37: j in dom (f1.i) and k = (Sum Card (f1|(i-'1))) + j and
          A38: (f1.i).j = ff1.k by A34,POLYNOM1:32;
             f1.i = fpoly_mult_root(s1/.i,b1.(s1/.i)) by A7,A36;
          then A39: (f1.i).j = <% -s1/.i, 1.L %> by A37,Def9;
                 len s1 = card support b1 by A6,Def1;
              then i in dom s1 by A5,A36,FINSEQ_3:31;
              then s1.i = s1/.i & s1.i in rng s1 by FINSEQ_4:def 4,FUNCT_1:12
;
              then s1/.i in support b1 by A6,Th5;
          then A40: s1/.i in support b by A13,XBOOLE_0:def 2;
              then s1/.i in rng s by A2,Th5; then consider l being Nat
such
that
          A41: l in dom s and
          A42: s.l = s1/.i by FINSEQ_2:11;
          A43: l in dom f by A1,A17,A41,FINSEQ_3:31;
          then A44: f.l = fpoly_mult_root(s/.l,b.(s/.l)) by A3;
          A45: s.l = s/.l by A41,FINSEQ_4:def 4;
                 b.(s1/.i) <> 0 by A40,POLYNOM1:def 7;
              then 0 < b.(s1/.i) by NAT_1:19;
          then A46: 0+1 <= b.(s1/.i) by NAT_1:38;
                 len (f.l) = b.(s/.l) by A44,Def9;
          then A47: 1 in dom (f.l) by A42,A45,A46,FINSEQ_3:27;
              then (Sum Card (f|(l-'1))) + 1 in dom ff &
              (f.l).1 = ff.((Sum Card (f|(l-'1))) + 1) by A43,POLYNOM1:33;
          then (f.l).1 in rng ff by FUNCT_1:12;
           hence contradiction by A32,A35,A38,A39,A42,A44,A45,A47,Def9;
           end;
           suppose x in rng ff2; then consider k being Nat such that
          A48: k in dom ff2 and
          A49: ff2.k = x by FINSEQ_2:11;
              consider i, j being Nat such that
          A50: i in dom f2 and
          A51: j in dom (f2.i) and k = (Sum Card (f2|(i-'1))) + j and
          A52: (f2.i).j = ff2.k by A48,POLYNOM1:32;
             f2.i = fpoly_mult_root(s2/.i,b2.(s2/.i)) by A11,A50;
          then A53: (f2.i).j = <% -s2/.i, 1.L %> by A51,Def9;
                 len s2 = card support b2 by A10,Def1;
              then i in dom s2 by A9,A50,FINSEQ_3:31;
              then s2.i = s2/.i & s2.i in rng s2 by FINSEQ_4:def 4,FUNCT_1:12
;
              then s2/.i in support b2 by A10,Th5;
          then A54: s2/.i in support b by A13,XBOOLE_0:def 2;
              then s2/.i in rng s by A2,Th5;
              then consider l being Nat such that
          A55: l in dom s and
          A56: s.l = s2/.i by FINSEQ_2:11;
          A57: l in dom f by A1,A17,A55,FINSEQ_3:31;
          then A58: f.l = fpoly_mult_root(s/.l,b.(s/.l)) by A3;
          A59: s.l = s/.l by A55,FINSEQ_4:def 4;
                 b.(s2/.i) <> 0 by A54,POLYNOM1:def 7;
              then 0 < b.(s2/.i) by NAT_1:19;
          then A60: 0+1 <= b.(s2/.i) by NAT_1:38;
                 len (f.l) = b.(s/.l) by A58,Def9;
          then A61: 1 in dom (f.l) by A56,A59,A60,FINSEQ_3:27;
              then (Sum Card (f|(l-'1))) + 1 in dom ff &
              (f.l).1 = ff.((Sum Card (f|(l-'1))) + 1) by A57,POLYNOM1:33;
          then (f.l).1 in rng ff by FUNCT_1:12;
           hence contradiction by A32,A49,A52,A53,A56,A58,A59,A61,Def9;
          end;
          end;
      then g"{x} = {} by FUNCT_1:142;
       hence card (ff"{x}) = card (g"{x}) by A32,FUNCT_1:142;
    end;
    end;
    then ff, g are_fiberwise_equipotent by RFINSEQ:def 1;
    then consider p being Permutation of dom FlattenSeq f such that
A62:  FlattenSeq f = ((FlattenSeq f1) ^ (FlattenSeq f2)) * p by A16,RFINSEQ:17
;
 thus poly_with_roots(b1+b2)
    = Product ((FlattenSeq f1) ^ (FlattenSeq f2)) by A4,A16,A62,Th17
   .= (Product FlattenSeq f1) * (Product FlattenSeq f2) by FVSUM_1:101
   .= (poly_with_roots b1)*'(poly_with_roots b2) by A8,A12,POLYNOM3:def 12;
end;

theorem  :: PWRBR1
   for L being algebraic-closed domRing, p being non-zero (Polynomial of L)
 st p.(len p-'1) = 1.L holds p = poly_with_roots(BRoots(p))
proof let L be algebraic-closed domRing, p be non-zero (Polynomial of L);assume
A1: p.(len p-'1) = 1.L;
      len p > 0 by Th18;
then A2: len p >= 0+1 by NAT_1:38;
   defpred P[Nat] means
    for p being non-zero Polynomial of L
     st len p = $1 & $1 >= 1 & p.(len p -'1) = 1.L
      holds p = poly_with_roots(BRoots(p));
A3: P[1] proof let p be non-zero Polynomial of L such that
    A4: len p = 1 and 1 >= 1 and
    A5: p.(len p -'1) = 1.L;
           degree BRoots p = 0 by A4,Th58;
    then A6: BRoots p = EmptyBag the carrier of L by Th13;
           len p -'1 = 0 by A4,GOBOARD9:1;
     hence p = <%1.L%> by A4,A5,ALGSEQ_1:def 6
           .= poly_with_roots(BRoots(p)) by A6,Th61;
    end;
A7: for n being Nat st n >= 1 & P[n] holds P[n+1] proof
     let n be Nat such that
    A8: n >= 1 and
    A9: P[n];
     let p being non-zero Polynomial of L such that
    A10: len p = n+1 and n+1 >= 1 and
    A11: p.(len p -'1) = 1.L;
           n+1 > 1 by A8,NAT_1:38;
        then p is with_roots by A10,POLYNOM5:def 8;
        then consider x being Element of L such that
    A12: x is_a_root_of p by POLYNOM5:def 7;
        set q = poly_quotient(p,x); set r = <%-x,1.L%>;
    A13: p = r*'q by A12,Th51;
         then reconsider q as non-zero Polynomial of L by Th35;
           BRoots r = ({x},1)-bag by Th55;
    then A14: BRoots(p) = ({x},1)-bag + BRoots(q) by A13,Th57;
           1.L <> 0.L by VECTSP_1:def 21;
    then A15: len r = 2 by POLYNOM5:41;
           len q > 0 by Th18;
        then r.(len r -'1) <> 0.L & q.(len q -'1) <> 0.L by A15,Th19;
        then r.(len r -'1) * q.(len q -'1) <> 0.L by VECTSP_2:def 5;
   then len p = len q + (1+1)- 1 by A13,A15,POLYNOM4:13;
        then len p = len q +1;
        then A16: len q = n by A10,XCMPLX_1:2;
           q.(len q -'1) = 1.L by A11,A13,Th42;
    then A17: q = poly_with_roots(BRoots(q)) by A8,A9,A16;
           poly_with_roots(({x},1)-bag) = <%-x,1.L%> by Th62;
     hence p = poly_with_roots(BRoots(p)) by A13,A14,A17,Th65;
    end;
      for n  being Nat st n >= 1 holds P[n] from INT_2:sch 1(A3,A7);
 hence p = poly_with_roots(BRoots(p)) by A1,A2;
end;

theorem
   for L being comRing, s being non empty finite Subset of L,
    f being FinSequence of Polynom-Ring L
 st len f = card s &
    for i being Nat, c being Element of L
     st i in dom f & c = (canFS(s)).i holds f.i = <% -c, 1.L %>
  holds poly_with_roots((s,1)-bag) = Product(f)
proof let L be comRing;
   set cL = the carrier of L;
   set cPRL = the carrier of Polynom-Ring L;
   let s be non empty finite Subset of cL, f be FinSequence of cPRL such that
A1: len f = card s and
A2: for i being Nat, c being Element of cL
     st i in dom f & c = (canFS(s)).i holds f.i = <% -c, 1.L %>;
   set cs = canFS(s);
A3: len cs = card s by Def1;     card s <> 0 by GRAPH_5:5;
   then 0 < card s by NAT_1:19;
then A4: 0+1 <= len f by A1,NAT_1:38;
   A5: cs | Seg len f is FinSequence by FINSEQ_1:23;
      f | Seg len f is FinSequence by FINSEQ_1:23;
then A6: f | Seg len f = f by FINSEQ_2:23;
A7: rng cs = s by Th5;
A8: dom f = dom cs by A1,A3,FINSEQ_3:31;
   defpred P[Nat] means
       ex t being finite Subset of cL, g being FinSequence of cPRL
        st t = rng (cs | Seg $1) & g = f | Seg $1 &
           poly_with_roots((t,1)-bag) = Product(g);
A9: P[1] proof reconsider cs_1 = cs | Seg 1 as FinSequence of s by FINSEQ_1:23
;
      reconsider g = f | Seg 1 as FinSequence of cPRL by FINSEQ_1:23;
      set t = rng cs_1;
      consider s1 being Element of s such that
  A10: cs_1 = <* s1 *> by A1,A3,A4,QC_LANG4:7;
  A11: 1 in Seg 1 by FINSEQ_1:3;    1 in dom cs by A1,A3,A4,FINSEQ_3:27;
      then reconsider cs1 = cs.1 as Element of s by FINSEQ_2:13;
  A12: cs_1.1 = cs1 by A11,FUNCT_1:72;
         cs1 in cL; then reconsider cs1 = cs.1 as Element of cL;
      A13: cs_1.1 = s1 by A10,FINSEQ_1:57;
      reconsider t = {cs1} as finite Subset of cL;
      consider p1 being Element of cPRL such that
  A14: g = <* p1 *> by A4,QC_LANG4:7;
  A15: 1 in dom f by A4,FINSEQ_3:27;
      then reconsider f1 = f.1 as Element of cPRL by FINSEQ_2:13;
  A16: g.1 = f1 by A11,FUNCT_1:72;
  A17: g.1 = p1 by A14,FINSEQ_1:57;
      take t, g; thus t = rng (cs | Seg 1) & g = f | Seg 1 by A10,A12,A13,
FINSEQ_1:56;
  A18: Product(g) = p1 by A14,FVSUM_1:99;
         f1 = <% -cs1, 1.L %> by A2,A15;
     hence poly_with_roots((t,1)-bag) = Product(g) by A16,A17,A18,Th62;
    end;
A19: for j being Nat st 1 <= j & j < len f holds P[j] implies P[j+1]
  proof let j be Nat such that
  A20: 1 <= j and
  A21: j < len f;
      reconsider cs_j = cs | Seg j as FinSequence of s by FINSEQ_1:23;
      reconsider cs_j1 = cs | Seg (j+1) as FinSequence of s by FINSEQ_1:23;
      given t being finite Subset of cL, g being FinSequence of cPRL
      such that
  A22: t = rng (cs | Seg j) and
  A23: g = f | Seg j and
  A24: poly_with_roots((t,1)-bag) = Product(g);
      reconsider g1 = f | Seg (j+1) as FinSequence of cPRL by FINSEQ_1:23;
      set t1 = rng cs_j1;
  A25: 1 <= j+1 & j+1 <= len f by A20,A21,NAT_1:38;
  then A26: j+1 in dom cs by A1,A3,FINSEQ_3:27; then cs.(j+1) in s by
FINSEQ_2:13; then reconsider csj1 = cs.(j+1) as Element of cL;
         Seg (j+1) = Seg j \/ {j+1} by FINSEQ_1:11;
  then A27: cs_j1 = cs_j \/ cs|{j+1} by RELAT_1:107;
         cs|{j+1} = (j+1) .--> csj1 by A26,FUNCT_7:6;
      then rng (cs|{j+1}) = {csj1} by CQC_LANG:5;
      then A28: t1 = t \/ {csj1} by A22,A27,RELAT_1:26;
      then reconsider t1 as finite Subset of cL;
      take t1, g1; thus t1 = rng (cs | Seg (j+1)) & g1 = f | Seg (j+1);
      reconsider pt = poly_with_roots((t,1)-bag) as Polynomial of L;
      reconsider ept = pt as Element of cPRL by POLYNOM3:def 12;
      reconsider pj1 = poly_with_roots(({csj1},1)-bag) as Polynomial of L;
      reconsider epj1 =<% -csj1, 1.L %> as Element of cPRL by POLYNOM3:def 12;
      consider l being Nat such that
  A29: len f = j+1+l by A25,NAT_1:28;
  A30: len g1 = j+1 by A29,FINSEQ_3:59;         j <= j+1 by NAT_1:37;
      then Seg j c= Seg (j+1) by FINSEQ_1:7;
  then A31: g = g1 | Seg j by A23,RELAT_1:103;    j+1 in Seg (j+1) by
FINSEQ_1:6
;
      then g1.(j+1) = f.(j+1) by FUNCT_1:72 .= <% -csj1, 1.L %> by A2,A8,A26;
  then A32: g1 = g ^ <* <% -csj1, 1.L %> *> by A30,A31,FINSEQ_3:61;
  A33: pj1 = epj1 by Th62;
         t misses {csj1} proof assume not thesis;
         then t /\ {csj1} <> {} by XBOOLE_0:def 7;
          then consider x being set such that
      A34: x in t /\ {csj1} by XBOOLE_0:def 1;
      A35: x in t & x in {csj1} by A34,XBOOLE_0:def 3;
      then A36: x = csj1 by TARSKI:def 1;
          consider i being set such that
      A37: i in dom (cs | Seg j) and
      A38: x = (cs | Seg j).i by A22,A35,FUNCT_1:def 5;
      A39: i in Seg j by A37,RELAT_1:86;
          then reconsider i as Nat;
      A40: 1 <= i & i <= j by A39,FINSEQ_1:3;
      then A41: i < j+1 by NAT_1:38;            x = cs.i by A37,A38,FUNCT_1:70
;
       hence contradiction by A1,A3,A7,A25,A36,A40,A41,GRAPH_5:10;
      end;
      then (t1,1)-bag = (t,1)-bag + ({csj1},1)-bag by A28,Th12;
      hence poly_with_roots((t1,1)-bag) = pt *' pj1 by Th65
        .= Product(g) * epj1 by A24,A33,POLYNOM3:def 12
        .= Product(g1) by A32,FVSUM_1:100;
     end;
   for i being Nat st 1 <= i & i <= len f holds P[i] from POLYNOM2:sch 4
(A9,A19);
  then consider t being finite Subset of cL, g being FinSequence of cPRL such
that
A42: t = rng (cs | Seg len f) and
A43: g = f | Seg len f and
A44: poly_with_roots((t,1)-bag) = Product(g) by A4;
 thus poly_with_roots((s,1)-bag) = Product(f) by A1,A3,A5,A6,A7,A42,A43,A44,
FINSEQ_2:23;
end;

theorem :: PolyEval1:
   for L being non trivial comRing, s being non empty finite Subset of L,
    x being Element of L, f being FinSequence of L
 st len f = card s &
    for i being Nat, c being Element of L
     st i in dom f & c = (canFS(s)).i holds f.i = eval(<% -c, 1.L %>,x)
  holds eval(poly_with_roots((s,1)-bag),x) = Product(f)
proof let L be non trivial comRing;
   set cL = the carrier of L;
   set cPRL = the carrier of Polynom-Ring L;
   let s be non empty finite Subset of cL, x be Element of cL,
          f be FinSequence of L such that
A1: len f = card s and
A2: for i being Nat, c being Element of cL
     st i in dom f & c = (canFS(s)).i holds f.i = eval(<% -c, 1.L %>,x);
   set cs = canFS(s);
A3: len cs = card s by Def1;
      card s <> 0 by GRAPH_5:5; then 0 < card s by NAT_1:19;
then A4: 0+1 <= len f by A1,NAT_1:38;
   A5: cs | Seg len f is FinSequence by FINSEQ_1:23;
      f | Seg len f is FinSequence by FINSEQ_1:23;
then A6: f | Seg len f = f by FINSEQ_2:23;
A7: rng cs = s by Th5;
A8: dom f = dom cs by A1,A3,FINSEQ_3:31;
   defpred P[Nat] means
       ex t being finite Subset of cL, g being FinSequence of cL
        st t = rng (cs | Seg $1) & g = f | Seg $1 &
           eval(poly_with_roots((t,1)-bag),x) = Product(g);
A9: P[1] proof
      reconsider cs_1 = cs | Seg 1 as FinSequence of s by FINSEQ_1:23;
      reconsider g = f | Seg 1 as FinSequence of cL by FINSEQ_1:23;
      set t = rng cs_1;
      consider s1 being Element of s such that
  A10: cs_1 = <* s1 *> by A1,A3,A4,QC_LANG4:7;
  A11: 1 in Seg 1 by FINSEQ_1:3;
         1 in dom cs by A1,A3,A4,FINSEQ_3:27;
      then reconsider cs1 = cs.1 as Element of s by FINSEQ_2:13;
  A12: cs_1.1 = cs1 by A11,FUNCT_1:72;
         cs1 in cL; then reconsider cs1 = cs.1 as Element of cL;
      A13: cs_1.1 = s1 by A10,FINSEQ_1:57;
      reconsider t = {cs1} as finite Subset of cL;
      consider p1 being Element of cL such that
  A14: g = <* p1 *> by A4,QC_LANG4:7;
  A15: 1 in dom f by A4,FINSEQ_3:27;
      then reconsider f1 = f.1 as Element of cL by FINSEQ_2:13;
  A16: g.1 = f1 by A11,FUNCT_1:72;
  A17: g.1 = p1 by A14,FINSEQ_1:57;
      take t, g;      thus t = rng (cs | Seg 1) & g = f | Seg 1 by A10,A12,A13,
FINSEQ_1:56;
  A18: Product(g) = p1 by A14,FVSUM_1:99;
         f1 = eval(<% -cs1, 1.L %>,x) by A2,A15;
     hence eval(poly_with_roots((t,1)-bag),x) = Product(g) by A16,A17,A18,Th62
;
    end;
A19: for j being Nat st 1 <= j & j < len f holds P[j] implies P[j+1]
  proof let j be Nat such that
  A20: 1 <= j and
  A21: j < len f;
      reconsider cs_j = cs | Seg j as FinSequence of s by FINSEQ_1:23;
      reconsider cs_j1 = cs | Seg (j+1) as FinSequence of s by FINSEQ_1:23;
      given t being finite Subset of cL, g being FinSequence of cL
      such that
  A22: t = rng (cs | Seg j) and
  A23: g = f | Seg j and
  A24: eval(poly_with_roots((t,1)-bag),x) = Product(g);
      reconsider g1 = f | Seg (j+1) as FinSequence of cL by FINSEQ_1:23;
      set t1 = rng cs_j1;
  A25: 1 <= j+1 & j+1 <= len f by A20,A21,NAT_1:38;
  then A26: j+1 in dom cs by A1,A3,FINSEQ_3:27; then cs.(j+1) in s by
FINSEQ_2:13; then reconsider csj1 = cs.(j+1) as Element of cL;
         Seg (j+1) = Seg j \/ {j+1} by FINSEQ_1:11;
  then A27: cs_j1 = cs_j \/ cs|{j+1} by RELAT_1:107;
         cs|{j+1} = (j+1) .--> csj1 by A26,FUNCT_7:6;
      then rng (cs|{j+1}) = {csj1} by CQC_LANG:5;
      then A28: t1 = t \/ {csj1} by A22,A27,RELAT_1:26;
      then reconsider t1 as finite Subset of cL;
      take t1, g1;      thus t1 = rng (cs | Seg (j+1)) & g1 = f | Seg (j+1);
      reconsider pt = poly_with_roots((t,1)-bag) as Polynomial of L;
      reconsider pj1 = poly_with_roots(({csj1},1)-bag) as Polynomial of L;
      reconsider epj1 = <% -csj1, 1.L %> as Element of cPRL
        by POLYNOM3:def 12;
      consider l being Nat such that
  A29: len f = j+1+l by A25,NAT_1:28;
  A30: len g1 = j+1 by A29,FINSEQ_3:59;
         j <= j+1 by NAT_1:37;
      then Seg j c= Seg (j+1) by FINSEQ_1:7;
  then A31: g = g1 | Seg j by A23,RELAT_1:103;
         j+1 in Seg (j+1) by FINSEQ_1:6;
      then g1.(j+1) = f.(j+1) by FUNCT_1:72
              .= eval(<% -csj1, 1.L %>,x) by A2,A8,A26;
  then A32: g1 = g ^ <* eval(<% -csj1, 1.L %>,x) *> by A30,A31,FINSEQ_3:61;
  A33: pj1 = <% -csj1, 1.L %> by Th62;
         t misses {csj1} proof assume not thesis;
         then t /\ {csj1} <> {} by XBOOLE_0:def 7;
          then consider x being set such that
      A34: x in t /\ {csj1} by XBOOLE_0:def 1;
      A35: x in t & x in {csj1} by A34,XBOOLE_0:def 3;
      then A36: x = csj1 by TARSKI:def 1;
          consider i being set such that
      A37: i in dom (cs | Seg j) and
      A38: x = (cs | Seg j).i by A22,A35,FUNCT_1:def 5;
      A39: i in Seg j by A37,RELAT_1:86; then reconsider i as Nat;
      A40: 1 <= i & i <= j by A39,FINSEQ_1:3;
      then A41: i < j+1 by NAT_1:38;            x = cs.i by A37,A38,FUNCT_1:70;
       hence contradiction by A1,A3,A7,A25,A36,A40,A41,GRAPH_5:10;
      end;
      then (t1,1)-bag = (t,1)-bag + ({csj1},1)-bag by A28,Th12;
      then poly_with_roots((t1,1)-bag) = pt *' pj1 by Th65;
      hence eval(poly_with_roots((t1,1)-bag),x)
          = Product(g) * eval(pj1,x) by A24,POLYNOM4:27
         .= Product(g1) by A32,A33,FVSUM_1:100;
     end;
   for i being Nat st 1 <= i & i <= len f holds P[i] from POLYNOM2:sch 4
(A9,A19);
  then consider t being finite Subset of cL, g being FinSequence of cL such
that
A42: t = rng (cs | Seg len f) and
A43: g = f | Seg len f and
A44: eval(poly_with_roots((t,1)-bag),x) = Product(g) by A4;
 thus eval(poly_with_roots((s,1)-bag),x) = Product(f) by A1,A3,A5,A6,A7,A42,A43
,A44,FINSEQ_2:23;
end;
