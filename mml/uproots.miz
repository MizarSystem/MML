:: Little {B}ezout Theorem (Factor Theorem)
::  by Piotr Rudnicki
::
:: Received December 30, 2003
:: Copyright (c) 2003 Association of Mizar Users

environ

 vocabularies ARYTM_1, SQUARE_1, ARYTM_3, FINSEQ_1, RELAT_1, FUNCT_1, RLVECT_1,
      BOOLE, FINSEQ_2, FINSEQ_4, BINOP_1, VECTSP_1, LATTICES, NORMSP_1, ARYTM,
      COMPLFLD, GROUP_1, REALSET1, POLYNOM1, TARSKI, CARD_1, CARD_3, SETWISEO,
      ALGSEQ_1, POLYNOM3, POLYNOM2, ALGSTR_2, FUNCT_4, VECTSP_2, FUNCOP_1,
      FUNCT_2, RFINSEQ, POLYNOM5, FVSUM_1, FINSET_1, NEWTON, MCART_1, SGRAPH1,
      CAT_1, DTCONSTR, MEMBERED, ANPROJ_1, UPROOTS, ORDINAL2, SEQ_1, PBOOLE,
      FINSOP_1, ALGSTR_0;
 notations TARSKI, XBOOLE_0, XCMPLX_0, XXREAL_0, SUBSET_1, ORDINAL1, CARD_1,
      NUMBERS, XREAL_0, ZFMISC_1, REAL_1, SETWISEO, VECTSP_2, BINOP_1,
      RELAT_1, FUNCT_1, RELSET_1, PARTFUN1, FINSEQ_1, FINSEQ_2, DOMAIN_1,
      FUNCT_2, STRUCT_0, ALGSTR_0, RLVECT_1, VECTSP_1, FINSOP_1, NORMSP_1,
      BINARITH, GROUP_4, RVSUM_1, ALGSEQ_1, COMPLFLD, BHSP_1, POLYNOM3,
      POLYNOM4, POLYNOM5, FINSET_1, MCART_1, PRE_CIRC, FUNCT_4, FUNCOP_1,
      DTCONSTR, RFINSEQ, SEQ_1, PBOOLE, POLYNOM1, FVSUM_1, WSIERP_1, MEMBERED,
      GROUP_1, NAT_1, RECDEF_1;
 constructors WELLORD2, SETWISEO, XXREAL_0, REAL_1, FINSEQOP, FINSOP_1,
      RFINSEQ, BINARITH, PRE_CIRC, WSIERP_1, VECTSP_2, REALSET2, ALGSTR_1,
      GROUP_4, BHSP_1, MATRIX_2, MONOID_0, GOBOARD1, DTCONSTR, POLYNOM2,
      POLYNOM4, POLYNOM5, SEQ_1, RECDEF_1, BINOP_2;
 registrations XBOOLE_0, SUBSET_1, RELAT_1, FUNCT_1, ORDINAL1, FUNCOP_1,
      FINSET_1, NUMBERS, XXREAL_0, XREAL_0, NAT_1, INT_1, BINOP_2, CARD_1,
      MEMBERED, FINSEQ_1, PRE_CIRC, STRUCT_0, VECTSP_1, COMPLFLD, ALGSTR_1,
      MONOID_0, GOBRD13, POLYNOM1, POLYNOM3, POLYNOM4, POLYNOM5, POLYNOM7,
      CHAIN_1, FINSEQ_2, VALUED_0;
 requirements NUMERALS, BOOLE, SUBSET, ARITHM, REAL;
 definitions TARSKI, VECTSP_2, FUNCT_1, POLYNOM3, POLYNOM5, FINSEQ_2, RVSUM_1,
      GROUP_4, RLVECT_1, FUNCOP_1;
 theorems GROUP_1, CARD_1, FINSEQ_1, ZFMISC_1, NAT_1, FUNCT_1, FUNCT_2,
      RELAT_1, TARSKI, XBOOLE_0, XBOOLE_1, VECTSP_1, REAL_1, POLYNOM5,
      BINARITH, INT_1, AXIOMS, RVSUM_1, FVSUM_1, FINSEQ_3, FINSEQ_2, POLYNOM4,
      POLYNOM3, FUNCT_7, ALGSEQ_1, RLVECT_1, FINSET_1, PBOOLE, FUNCOP_1,
      POLYNOM1, MATRIX_3, PRE_CIRC, VECTSP_2, CARD_2, FINSEQ_5, GRAPH_5,
      QC_LANG4, DTCONSTR, BAGORDER, RFINSEQ, WELLORD2, CARD_3, ORDINAL1, FSM_1,
      FINSOP_1, MONOID_0, INTEGRA1, TRIANG_1, FUNCT_4, MCART_1, REALSET1,
      XREAL_1, GROUP_4, XXREAL_0, PARTFUN1;
 schemes NAT_1, FUNCT_1, FUNCT_2, FRAENKEL, POLYNOM2, ALGSEQ_1, FINSEQ_1,
      RECDEF_1;

begin :: Preliminaries

theorem Th1:
  for n being natural number holds n is non empty iff n = 1 or n > 1
proof
  let n be natural number;
  hereby
    assume n is non empty;
    then 0 < n;
    then 0 qua Nat+1 <= n by NAT_1:13;
    hence n = 1 or n > 1 by REAL_1:def 5;
  end;
  assume n = 1 or n > 1;
  hence thesis;
end;

theorem Th2:
  for f being FinSequence of NAT
  st for i being Element of NAT st i in dom f holds f.i <> 0
  holds Sum f = len f iff f = (len f) |-> 1
proof
  let f be FinSequence of NAT;
  defpred P[Element of NAT] means for f being FinSequence of NAT
  st len f = $1 & for i being Element of NAT st i in dom f holds f.i <> 0
  holds Sum f = len f iff f = (len f) |-> 1;
A1: P[0]
  proof
    let f be FinSequence of NAT such that
A2: len f = 0 and for i being Element of NAT st i in dom f holds f.i <> 0;
    hereby
      assume Sum f = len f;
      thus f = {} by A2,CARD_2:59
        .= (len f) |-> 1 by A2,FINSEQ_2:72;
    end;
    assume f = (len f) |-> 1;
    thus Sum f = len f by A2,CARD_2:59,RVSUM_1:102;
  end;
A3: for n being Element of NAT st P[n] holds P[n+1]
  proof
    let n be Element of NAT;
    assume
A4: P[n];
    let f be FinSequence of NAT such that
A5: len f = n+1 and
A6: for i being Element of NAT st i in dom f holds f.i <> 0;
    consider g being FinSequence of NAT, a being Element of NAT such that
A7: f = g^<*a*> by A5,FINSEQ_2:22;
A8: g is FinSequence of REAL by FINSEQ_2:27;
    n+1 = len g + len <*a*> by A5,A7,FINSEQ_1:35;
    then
A9: n+1 = len g + 1 by FINSEQ_1:57;
A10: now
      let i be Element of NAT;
      assume
A11:  i in dom g;
A12:  dom g c= dom f by A7,FINSEQ_1:39;
      f.i = g.i by A7,A11,FINSEQ_1:def 7;
      hence g.i <> 0 by A6,A11,A12;
    end;
A13: Sum f = Sum g + a by A7,RVSUM_1:104;
A14: dom f = Seg len f by FINSEQ_1:def 3;
    f.len f = a by A5,A7,A9,FINSEQ_1:59;
    then a <> 0 by A5,A6,A14,FINSEQ_1:6;
    then 0 < a;
    then
A15: 0 qua Nat+1 <= a by NAT_1:13;
    hereby
      assume
A16:  Sum f = len f;
      reconsider h = (len g) |-> (1 qua Real) as FinSequence of REAL;
      reconsider h1=h as Element of (len h)-tuples_on REAL by FINSEQ_2:110;
      reconsider g1=g as Element of (len g)-tuples_on REAL by A8,FINSEQ_2:110;
A17:  len h1 = len g1 by FINSEQ_2:69;
      now
        let j be Nat;
        reconsider a = j as Element of NAT by ORDINAL1:def 13;
        assume
A18:    j in Seg len g;
        then j in dom g by FINSEQ_1:def 3;
        then g.j <> 0 by A10;
        then 0 < g.a;
        then 0 qua Nat+1 <= g.a by NAT_1:13;
        hence h1.j <= g1.j by A18,FUNCOP_1:13;
      end;
      then
A19:  Sum h1 <= Sum g1 by A17,RVSUM_1:112;
A20:  Sum h = n*1 by A9,RVSUM_1:110
        .= n;
A21:  Sum g = Sum g +a -a
        .= n+1 -a by A5,A7,A16,RVSUM_1:104;
      then n+a <= n+1-a+a by A19,A20,XREAL_1:8;
      then a <= 1 by XREAL_1:8;
      then
A22:  a = 1 by A15,XXREAL_0:1;
      then g = (len g) |-> 1 by A4,A9,A10,A21;
      hence f = (len f) |-> 1 by A5,A7,A9,A22,FINSEQ_2:74;
    end;
    assume f = (len f) |-> 1;
    then f = (n |-> 1)^(1 |-> 1) by A5,FINSEQ_2:143
      .= (n |-> 1)^<*1*> by FINSEQ_2:73;
    then g = (len g) |-> 1 & a = 1 by A7,A9,FINSEQ_2:20;
    hence Sum f = len f by A4,A5,A9,A10,A13;
  end;
  for n being Element of NAT holds P[n] from NAT_1:sch 1(A1, A3);
  hence thesis;
end;

:: Stolen from POLYNOM2

scheme IndFinSeq0 { F() -> FinSequence, P[set, set]} :
  for i being Element of NAT st 1 <= i & i <= len F() holds P[i, F().i]
provided
A1: P[1, F().1]
and
A2: for i being Element of NAT st 1 <= i & i < len F()
holds P[i, F().i] implies P[i+1, F().(i+1)]
proof
  defpred Q[Nat] means 1 <= $1 & $1 <= len F() & not(P[$1, F().($1)]);
  assume not(for i being Element of NAT st 1 <= i & i <= len F()
  holds P[i, F().i]);
  then
A3: ex k being Nat st Q[k];
  consider k being Nat such that
A4: Q[k] & for k' being Nat st Q[k'] holds k <= k' from NAT_1:sch 5(A3);
  per cases;
  suppose k = 1;
    hence thesis by A1,A4;
  end;
  suppose
A5: k <> 1;
    1 - 1 <= k - 1 by A4,XREAL_1:11;
    then reconsider k' = k - 1 as Element of NAT by INT_1:16;
A6: (k - 1) + 1 = k + (0 qua Nat);
A7: k' <= k' + 1 by NAT_1:11;
    k' <> k' + 1;
    then
A8: k' < k by A7,REAL_1:def 5;
    then
A9: not(Q[k']) by A4;
    1 < k by A4,A5,REAL_1:def 5;
    then
A10: 1 <= k' by A6,NAT_1:13;
    k' < len F() by A4,A8,XXREAL_0:2;
    hence thesis by A2,A4,A6,A9,A10;
  end;
end;

theorem Th3:
  for L be add-associative right_zeroed right_complementable
  (non empty addLoopStr), r be FinSequence of L
  st len r >= 2 & for k being Element of NAT st 2 < k & k in dom r
  holds r.k = 0.L holds Sum r = r/.1 + r/.2
proof
  let L be add-associative right_zeroed right_complementable
  (non empty addLoopStr), r being FinSequence of L such that
A1: len r >= 2 and
A2: for k being Element of NAT st 2 < k & k in dom r holds r.k = 0.L;
  now
    assume r is empty;
    then r = <*>(the carrier of L);
    hence contradiction by A1,FINSEQ_1:32;
  end;
  then consider a being Element of L, r1 being FinSequence of L such that
A3: a = r.1 and
A4: r = <*a*>^r1 by FINSEQ_3:111;
A5: len <*a*> = 1 by FINSEQ_1:57;
  then
A6: len r = 1 + len r1 by A4,FINSEQ_1:35;
  now
    assume r1 is empty;
    then r1 = <*>(the carrier of L);
    then len r1 = 0 by FINSEQ_1:32;
    hence contradiction by A1,A6;
  end;
  then consider b being Element of L, r2 being FinSequence of L such that
A7: b = r1.1 and
A8: r1 = <*b*>^r2 by FINSEQ_3:111;
A9: len <*b*> = 1 by FINSEQ_1:57;
A10: now
    let i be Element of NAT such that
A11: i in dom r2;
A12: 1+i in dom r1 by A8,A9,A11,FINSEQ_1:41;
    1 <= i by A11,FINSEQ_3:27;
    then 1 < 1+i by NAT_1:13;
    then
A13: 1+1 < 1+(1+i) by XREAL_1:10;
    thus r2.i = r1.(1+i) by A8,A9,A11,FINSEQ_1:def 7
      .= r.(1+(1+i)) by A4,A5,A12,FINSEQ_1:def 7
      .= 0.L by A2,A4,A5,A12,A13,
    FINSEQ_1:41;
  end;
  1 <= len r by A1,XXREAL_0:2;
  then
A14: 1 in dom r by FINSEQ_3:27;
A15: 2 in dom r by A1,FINSEQ_3:27;
A16: r.2 = r1.(2-1) by A1,A4,A5,FINSEQ_1:37
    .= r1.1;
  thus Sum r = a + Sum r1 by A4,FVSUM_1:89
    .= a + (b + Sum r2) by A8,FVSUM_1:89
    .= a + (b + 0.L) by A10,POLYNOM3:1
    .= a+b by RLVECT_1:def 7
    .= r/.1 + b by A3,A14,PARTFUN1:def 8
    .= r/.1 + r/.2 by A7,A15,A16,PARTFUN1:def 8;
end;

begin :: Canonical ordering of a finite set into a finite sequence

definition
  let A be finite set;
  func canFS(A) -> FinSequence of A means
  :Def1:
  len it = card A &
  ex f being FinSequence st len f = card A &
  (f.1 = [choose A, A \ {choose A}] or card A = 0) &
  (for i being Element of NAT st 1 <= i & i < card A for x being set
  st f.i = x holds f.(i+1) = [choose x`2, x`2 \ {choose x`2}]) &
  for i being Element of NAT st i in dom it holds it.i = (f.i)`1;
  existence
  proof
    set cA = card A;
    defpred P[Element of NAT,set,set] means
    $3 = [choose $2`2, $2`2 \ {choose $2`2}];
A1: for n being Element of NAT st 1 <= n & n < cA
    for x being set ex y being set st P[n,x,y];
A2: for n being Element of NAT st 1 <= n & n < cA
    for x,y1,y2 being set st P[n,x,y1] & P[n,x,y2] holds y1 = y2;
    consider f being FinSequence such that
A3: len f = cA and
A4: f.1 = [choose A, A \ {choose A}] or cA = 0 and
A5: for n being Element of NAT st 1<=n&n<cA holds P[n,f.n,f.(n+1)]
    from RECDEF_1:sch 3 (A1, A2);
    defpred R[Element of NAT,set] means
    $1 in dom f implies $2 in [: A, bool A :] &
    ex X being finite set st X = ($2)`2 & card X +$1 = cA;
A6: R[1,f.1]
    proof
      assume
A7:   1 in dom f;
      then
A8:   0 qua Nat+1 <= len f by FINSEQ_3:27;
      A <> {} by A3,A7,CARD_1:78,FINSEQ_3:27;
      hence f.1 in [: A, bool A :] by A3,A4,A7,FINSEQ_3:27,ZFMISC_1:def 2;
      reconsider X = A \ {choose A} as finite set;
      take X; thus X = (f.1)`2 by A3,A4,A7,FINSEQ_3:27,MCART_1:7;
A9:   now
        assume choose A in A \ {choose A};
        then not choose A in {choose A} by XBOOLE_0:def 4;
        hence contradiction by TARSKI:def 1;
      end;
      {choose A} c= A by A3,A8,CARD_1:78,ZFMISC_1:37;
      then A = {choose A} \/ (A \ {choose A}) by XBOOLE_1:45;
      hence card X + 1 = cA by A9,CARD_2:54;
    end;
A10: for i being Element of NAT st 1 <= i & i < len f & R[i, f.i]
    holds R[i+1,f.(i+1)]
    proof
      let i be Element of NAT such that
A11:  1 <= i and
A12:  i < len f and
A13:  R[i, f.i] and i+1 in dom f;
      consider X being finite set such that
A14:  X = (f.i)`2 and
A15:  card X +i = cA by A11,A12,A13,FINSEQ_3:27;
A16:  X <> {} by A3,A12,A15,CARD_1:78;
      consider a, ba being set such that a in A and
A17:  ba in bool A and
A18:  f.i = [a, ba] by A11,A12,A13,FINSEQ_3:27,ZFMISC_1:def 2;
A19:  f.(i+1) = [choose (f.i)`2, (f.i)`2 \ {choose (f.i)`2}] by A3,A5,A11
      ,A12;
A20:  (f.i)`1 = a & (f.i)`2 = ba by A18,MCART_1:7;
A21:  choose (f.i)`2 in (f.i)`2 by A14,A16;
      (f.i)`2 \ {choose (f.i)`2} c= A by A17,A20,XBOOLE_1:1;
      hence f.(i+1) in [: A, bool A :] by A17,A19,A20,A21,ZFMISC_1:def 2;

reconsider XX = (f.i)`2 \{choose(f.i)`2} as finite set by A14,FINSET_1:16;
      take XX; thus XX = (f.(i+1))`2 by A19,MCART_1:7;
A22:  now
        assume choose (f.i)`2 in (f.i)`2 \ {choose (f.i)`2};
        then not choose (f.i)`2 in {choose (f.i)`2} by XBOOLE_0:def 4;
        hence contradiction by TARSKI:def 1;
      end;
      {choose (f.i)`2} c= (f.i)`2 by A14,A16,ZFMISC_1:37;
      then (f.i)`2 = {choose (f.i)`2} \/ ((f.i)`2 \ {choose (f.i)`2})
      by XBOOLE_1:45;
      then card X = card XX + 1 by A14,A22,CARD_2:54;
      hence card XX + (i+1) = cA by A15;
    end;
A23: for i being Element of NAT st 1<=i & i <= len f holds R[i,f.i]
    from IndFinSeq0(A6, A10);
    rng f c= [: A, bool A :]
    proof
      let y be set;
      assume y in rng f;
      then consider i being Nat such that
A24:  i in dom f and
A25:  y = f.i by FINSEQ_2:11;
      1 <= i & i <= len f by A24,FINSEQ_3:27;
      hence thesis by A23,A24,A25;
    end;
    then reconsider f as FinSequence of [: A, bool A :] by FINSEQ_1:def 4;
    deffunc F(Nat) = (f.$1)`1;
    consider p being FinSequence such that
A26: len p = card A and
A27: for k being Nat st k in dom p holds p.k = F(k) from FINSEQ_1:sch 2;
A29: dom p = dom f by A3,A26,FINSEQ_3:31;
    rng p c= A
    proof
      let y be set;
      assume y in rng p;
      then consider i being Nat such that
A30:  i in dom p and
A31:  p.i = y by FINSEQ_2:11;
A32:  p.i = (f.i)`1 by A27,A30;
      f.i in [:A, bool A:] by A29,A30,FINSEQ_2:13;
      hence y in A by A31,A32,MCART_1:10;
    end;
    then reconsider p as FinSequence of A by FINSEQ_1:def 4;
    take p; thus len p = card A by A26;
    take f; thus thesis by A3,A4,A5,A27;
  end;
  uniqueness
  proof
    let it1, it2 be FinSequence of A such that
A33: len it1 = card A;
    given f being FinSequence such that
A34: len f = card A and
A35: f.1 = [choose A, A \ {choose A}] or card A = 0 and
A36: for i being Element of NAT st 1 <= i & i < card A holds for x being set
    st f.i = x holds f.(i+1) = [choose x`2, x`2 \ {choose x`2}] and
A37: for i being Element of NAT st i in dom it1 holds it1.i = (f.i)`1;
    assume
A38: len it2 = card A;
    given g being FinSequence such that
A39: len g = card A and
A40: g.1 = [choose A, A \ {choose A}] or card A = 0 and
A41: for i being Element of NAT st 1 <= i & i < card A holds for x being set
    st g.i = x holds g.(i+1) = [choose x`2, x`2 \ {choose x`2}] and
A42: for i being Element of NAT st i in dom it2 holds it2.i = (g.i)`1;
    defpred Q[Element of NAT,set] means card A <> 0 implies $2 = g.$1;
A43: Q[1, f.1] by A35,A40;
A44: for i being Element of NAT st 1 <= i & i < len f & Q[i, f.i]
    holds Q[i+1, f.(i+1)]
    proof
      let i be Element of NAT such that
A45:  1 <= i and
A46:  i < len f and
A47:  Q[i, f.i] and card A <> 0;
      set x = f.i;
      thus f.(i+1) = [choose x`2, x`2 \ {choose x`2}] by A34,A36,A45,A46
        .= g.(i+1) by A34,A41,A45,A46,A47;
    end;
A48: for i being Element of NAT st 1<=i & i<=len f holds Q[i, f.i]
    from IndFinSeq0(A43,A44);
A49: f = g
    proof
      per cases;
      suppose
A50:    card A = 0;
        hence f = {} by A34,CARD_2:59
          .= g by A39,A50,CARD_2:59;
      end;
      suppose
A51:    card A <> 0;
        now
          let j be Nat;
A52:      j in NAT by ORDINAL1:def 13;
          assume j in dom f;
          then 1 <= j & j <= len f by FINSEQ_3:27;
          hence f.j = g.j by A48,A51,A52;
        end;
        hence f = g by A34,A39,FINSEQ_2:10;
      end;
    end;
    now
      let j be Nat such that
A53:  j in dom it1;
A54:  dom it1 = dom it2 by A33,A38,FINSEQ_3:31;
      thus it1.j = (f.j)`1 by A37,A53
        .= it2.j by A42,A49,A53,A54;
    end;
    hence it1 = it2 by A33,A38,FINSEQ_2:10;
  end;
end;

theorem Th4:
  for A being finite set holds canFS(A) is one-to-one
proof
  let A be finite set;
  set F = canFS(A), cA = card A;
A1: len F = card A by Def1;
  consider f being FinSequence such that
A2: len f = cA and
A3: f.1 = [choose A, A \ {choose A}] or card A = 0 and
A4: for i being Element of NAT st 1 <= i & i < cA for x being set
  st f.i = x holds f.(i+1) = [choose x`2, x`2 \ {choose x`2}] and
A5: for i being Element of NAT st i in dom F holds F.i = (f.i)`1 by Def1;
  per cases;
  suppose A = {};
    hence canFS(A) is one-to-one by A1,CARD_1:78,CARD_2:59;
  end;
  suppose
A6: A <> {};
    then card A <> 0 by GRAPH_5:5;
    then card A > 0;
    then
A7: 0 qua Nat+1 <= len F by A1,NAT_1:13;
    then
A8: 1 in dom F by FINSEQ_3:27;
    defpred P[Element of NAT, set] means rng (F| Seg $1) /\ ($2)`2 = {} &
    (ex X being finite set st X = ($2)`2 & card X +$1 = cA) &
    ($1 < len F implies not F.($1+1) in rng (F| Seg $1));
A9: P[1, f.1]
    proof
      reconsider F1 = (F | Seg 1) as FinSequence of A by FINSEQ_1:23;
      consider a being Element of A such that
A10:  F1 = <* a *> by A6,A7,QC_LANG4:7;
      1 in Seg (0 qua Nat+1) by FINSEQ_1:6;
      then F1.1 = F.1 by FUNCT_1:72
        .= (f.1)`1 by A5,A8
        .= choose A by A3,A6,GRAPH_5:5,MCART_1:7;
      then F | Seg 1 = <* choose A *> by A10,FINSEQ_1:57;
      then
A11:  rng (F| Seg 1) = {choose A} by FINSEQ_1:56;
A12:  (f.1)`2 = A \ {choose A} by A3,A6,GRAPH_5:5,MCART_1:7;
      thus rng (F| Seg 1) /\ (f.1)`2 = {}
      proof
        assume not thesis;
        then consider x being set such that
A13:    x in rng (F| Seg 1) /\ (f.1)`2 by XBOOLE_0:def 1;
        x in {choose A} & x in (f.1)`2 by A11,A13,XBOOLE_0:def 3;
        hence contradiction by A12,XBOOLE_0:def 4;
      end;
A14:  now reconsider X = A \ {choose A} as finite set;
        take X; thus X = (f.1)`2 by A3,A6,GRAPH_5:5,MCART_1:7;
A15:    now
          assume choose A in A \ {choose A};
          then not choose A in {choose A} by XBOOLE_0:def 4;
          hence contradiction by TARSKI:def 1;
        end;
        {choose A} c= A by A6,ZFMISC_1:37;
        then A = {choose A} \/ (A \ {choose A}) by XBOOLE_1:45;
        hence card X + 1 = cA by A15,CARD_2:54;
      end;
      hence ex X being finite set st X = (f.1)`2 & card X +1 = cA;
      consider X being finite set such that
A16:  X = (f.1)`2 and
A17:  card X +1 = cA by A14;
A18:  1 < len F implies (f.1)`2 <> {} by A16,A17,Def1,CARD_1:78;
      assume
A19:  1 < len F;
      then 1+1 <= len F by NAT_1:13;
      then 1+1 in dom F by FINSEQ_3:27;
      then
A20:  F.2 = (f.2)`1 by A5;
      f.(1+1) = [choose (f.1)`2, (f.1)`2 \ {choose (f.1)`2}] by A1,A4,A19;
      then (f.(1+1))`1 = choose (A \ {choose A}) by A12,MCART_1:7;
      hence not F.(1+1) in rng (F| Seg 1)
      by A11,A12,A18,A19,A20,XBOOLE_0:def 4;
    end;
A21: for i being Element of NAT st 1 <= i & i < len f & P[i, f.i]
    holds P[i+1, f.(i+1)]
    proof
      let i be Element of NAT such that
A22:  1 <= i and
A23:  i < len f and
A24:  P[i, f.i];
      consider X being finite set such that
A25:  X = (f.i)`2 and
A26:  card X +i = cA by A24;
A27:  f.(i+1) = [choose (f.i)`2, (f.i)`2 \ {choose (f.i)`2}] by A2,A4,A22
      ,A23;
      (f.i)`2 is non empty by A2,A23,A25,A26,CARD_1:78;
      then {choose (f.i)`2} c= (f.i)`2 by ZFMISC_1:37;
      then
A28:  (f.i)`2={choose (f.i)`2}\/((f.i)`2 \ {choose (f.i)`2}) by XBOOLE_1:45;
A29:  i+1 <= len F by A1,A2,A23,NAT_1:13;
      1 <= i+1 by NAT_1:12;
      then
A30:  i+1 in dom F by A29,FINSEQ_3:27;
      reconsider Fi = F| Seg i, Fi1 = F| Seg (i+1) as FinSequence of A
      by FINSEQ_1:23;
      consider a being Element of A such that
A31:  Fi1 = Fi^<*a*> by A6,A29,QC_LANG4:6;
A32:  rng Fi1 = rng Fi \/ rng <*a*> by A31,FINSEQ_1:44
        .= rng Fi \/ {a} by FINSEQ_1:56;
A33:  F.(i+1) = Fi1.(i+1) by FINSEQ_1:6,FUNCT_1:72;
      i = len Fi by A1,A2,A23,FINSEQ_1:21;
      then a = F.(i+1) by A31,A33,FINSEQ_1:59
        .= (f.(i+1))`1 by A5,A30
        .= choose (f.i)`2 by A27,MCART_1:7;
      then
A34:  (f.(i+1))`2 = (f.i)`2 \ {a} by A27,MCART_1:7; thus
A35:  rng (F| Seg (i+1)) /\ (f.(i+1))`2 = {}
      proof
        assume not thesis;
        then consider x being set such that
A36:    x in (rng Fi \/ {a}) /\ ((f.i)`2 \ {a}) by A32,A34,XBOOLE_0:def 1;
        x in (rng Fi \/ {a}) & x in ((f.i)`2 \ {a}) by A36,XBOOLE_0:def 3;
        then (x in rng Fi or x in {a}) & (x in (f.i)`2 & not x in {a})
        by XBOOLE_0:def 2,def 4;
        hence contradiction by A24,XBOOLE_0:def 3;
      end;
A37:  now reconsider XX = (f.i)`2 \{choose(f.i)`2} as finite set
        by A25,FINSET_1:16;
        take XX; thus XX = (f.(i+1))`2 by A27,MCART_1:7;
        now
          assume choose (f.i)`2 in (f.i)`2 \ {choose (f.i)`2};
          then not choose (f.i)`2 in {choose (f.i)`2} by XBOOLE_0:def 4;
          hence contradiction by TARSKI:def 1;
        end;
        then card X = card XX + 1 by A25,A28,CARD_2:54;
        hence card XX + (i+1) = cA by A26;
      end;
      hence ex X being finite set st X = (f.(i+1))`2 & card X +(i+1) = cA;
      assume
A38:  i+1 < len F;
      consider X being finite set such that
A39:  X = (f.(i+1))`2 and
A40:  card X +(i+1) = cA by A37;
A41:  (f.(i+1))`2 <> {} by A38,A39,A40,Def1,CARD_1:78;
A42:  1 <= i+1 by NAT_1:12;
      set i1 = i+1;
A43:  1 <= i1+1 by NAT_1:12;
      i1+1 <= len F by A38,NAT_1:13;
      then i1+1 in dom F by A43,FINSEQ_3:27;
      then
A44:  F.(i1+1) = (f.(i1+1))`1 by A5;
      f.(i1+1) = [choose (f.i1)`2, (f.i1)`2 \ {choose (f.i1)`2}]
      by A1,A4,A38,A42;
      then
A45:  (f.(i1+1))`1 = choose (f.i1)`2 by MCART_1:7;
      assume F.((i+1)+1) in rng (F| Seg (i+1));
      hence contradiction by A35,A41,A44,A45,XBOOLE_0:def 3;
    end;
A46: for i being Element of NAT st 1<=i & i<=len f holds P[i, f.i]
    from IndFinSeq0(A9,A21 );
    thus canFS(A) is one-to-one
    proof
      let i, j be set such that
A47:  i in dom F and
A48:  j in dom F and
A49:  F.i = F.j;
A50:  dom F = Seg len F by FINSEQ_1:def 3;
      per cases;
      suppose i = j;
        hence thesis;
      end;
      suppose
A51:    i <> j;
        reconsider i, j as Element of NAT by A47,A48;
A52:    1 <= i & i <= len F by A47,FINSEQ_3:27;
A53:    1 <= j & j <= len F by A48,FINSEQ_3:27;
        now
          per cases by A51,REAL_1:def 5;
          suppose
A54:        i < j;
            j <> 0 by A48,FINSEQ_3:27;
            then consider j1 being Nat such that
A55:        j = j1+1 by NAT_1:6;
A56:        j1 in NAT by ORDINAL1:def 13;
A57:        j1 < len F by A53,A55,NAT_1:13;
A58:        i <= j1 by A54,A55,NAT_1:13;
            then 1 <= j1 by A52,XXREAL_0:2;
            then
A59:        not F.(j1+1) in rng (F|Seg j1) by A1,A2,A46,A56, A57;
A60:        i in Seg j1 by A52,A58,FINSEQ_1:3;
            then
A61:        (F|Seg j1).i = F.i by FUNCT_1:72;
            Seg j1 c= dom F by A50,A57,FINSEQ_1:7;
            then i in dom (F|Seg j1) by A60,RELAT_1:91;
            hence contradiction by A49,A55,A59,A61,FUNCT_1:12;
          end;
          suppose
A62:        i > j;
            i <> 0 by A47,FINSEQ_3:27;
            then consider i1 being Nat such that
A63:        i = i1+1 by NAT_1:6;
A64:        i1 in NAT by ORDINAL1:def 13;
A65:        i1 < len F by A52,A63,NAT_1:13;
A66:        j <= i1 by A62,A63,NAT_1:13;
            then 1 <= i1 by A53,XXREAL_0:2;
            then
A67:        not F.(i1+1) in rng (F|Seg i1) by A1,A2,A46,A64, A65;
A68:        j in Seg i1 by A53,A66,FINSEQ_1:3;
            then
A69:        (F|Seg i1).j = F.j by FUNCT_1:72;
            Seg i1 c= dom F by A50,A65,FINSEQ_1:7;
            then j in dom (F|Seg i1) by A68,RELAT_1:91;
            hence contradiction by A49,A63,A67,A69,FUNCT_1:12;
          end;
        end;
        hence thesis;
      end;
    end;
  end;
end;

theorem Th5:
  for A being finite set holds rng canFS(A) = A
proof
  let A be finite set;
  set F = canFS(A), cA = card A;
A1: len F = card A by Def1;
  consider f being FinSequence such that
A2: len f = cA and
A3: f.1 = [choose A, A \ {choose A}] or card A = 0 and
A4: for i being Element of NAT st 1 <= i & i < cA for x being set
  st f.i = x holds f.(i+1) = [choose x`2, x`2 \ {choose x`2}] and
A5: for i being Element of NAT st i in dom F holds F.i = (f.i)`1 by Def1;
  per cases;
  suppose
A6: A = {};
    then F = {} by A1,CARD_1:78,CARD_2:59;
    hence thesis by A6,RELAT_1:60;
  end;
  suppose
A7: A <> {};
    then card A <> 0 by GRAPH_5:5;
    then card A > 0;
    then
A8: 0 qua Nat+1 <= len F by A1,NAT_1:13;
    then
A9: 1 in dom F by FINSEQ_3:27;
    defpred P[Element of NAT, set] means rng (F| Seg $1) \/ ($2)`2 = A &
    ex X being finite set st X = ($2)`2 & card X +$1 = cA;
A10: P[1, f.1]
    proof
      reconsider F1 = (F | Seg 1) as FinSequence of A by FINSEQ_1:23;
      consider a being Element of A such that
A11:  F1 = <* a *> by A7,A8,QC_LANG4:7;
      1 in Seg (0 qua Nat+1) by FINSEQ_1:6;
      then F1.1 = F.1 by FUNCT_1:72
        .= (f.1)`1 by A5,A9
        .= choose A by A3,A7,GRAPH_5:5,MCART_1:7;
      then F | Seg 1 = <* choose A *> by A11,FINSEQ_1:57;
      then
A12:  rng (F| Seg 1) = {choose A} by FINSEQ_1:56;
      (f.1)`2 = A \ {choose A} by A3,A7,GRAPH_5:5,MCART_1:7;
      hence rng (F| Seg 1) \/ (f.1)`2 = A by A12,XBOOLE_1:45;
      reconsider X = A \ {choose A} as finite set;
      take X; thus X = (f.1)`2 by A3,A7,GRAPH_5:5,MCART_1:7;
A13:  now
        assume choose A in A \ {choose A};
        then not choose A in {choose A} by XBOOLE_0:def 4;
        hence contradiction by TARSKI:def 1;
      end;
      {choose A} c= A by A7,ZFMISC_1:37;
      then A = {choose A} \/ (A \ {choose A}) by XBOOLE_1:45;
      hence card X + 1 = cA by A13,CARD_2:54;
    end;
A14: for i being Element of NAT st 1 <= i & i < len f & P[i, f.i]
    holds P[i+1, f.(i+1)]
    proof
      let i be Element of NAT such that
A15:  1 <= i and
A16:  i < len f and
A17:  P[i, f.i];
      consider X being finite set such that
A18:  X = (f.i)`2 and
A19:  card X +i = cA by A17;
A20:  f.(i+1) = [choose (f.i)`2, (f.i)`2 \ {choose (f.i)`2}] by A2,A4,A15,A16;
      (f.i)`2 is non empty by A2,A16,A18,A19,CARD_1:78;
      then {choose (f.i)`2} c= (f.i)`2 by ZFMISC_1:37;
      then
A21:  (f.i)`2 = {choose (f.i)`2} \/ ((f.i)`2 \ {choose (f.i)`2})
      by XBOOLE_1:45;
A22:  i+1 <= len F by A1,A2,A16,NAT_1:13;
      1 <= i+1 by NAT_1:12;
      then
A23:  i+1 in dom F by A22,FINSEQ_3:27;
      reconsider Fi = F| Seg i, Fi1 = F| Seg (i+1) as FinSequence of A
      by FINSEQ_1:23;
      consider a being Element of A such that
A24:  Fi1 = Fi^<*a*> by A7,A22,QC_LANG4:6;
A25:  rng Fi1 = rng Fi \/ rng <*a*> by A24,FINSEQ_1:44
        .= rng Fi \/ {a} by FINSEQ_1:56;
A26:  F.(i+1) = Fi1.(i+1) by FINSEQ_1:6,FUNCT_1:72;
      i = len Fi by A1,A2,A16,FINSEQ_1:21;
      then
A27:  a = F.(i+1) by A24,A26,FINSEQ_1:59
        .= (f.(i+1))`1 by A5,A23
        .= choose (f.i)`2 by A20,MCART_1:7;
      then (f.(i+1))`2 = (f.i)`2 \ {a} by A20,MCART_1:7;

hence rng (F| Seg (i+1)) \/ (f.(i+1))`2 = A by A17,A21,A25,A27,XBOOLE_1:4;

reconsider XX = (f.i)`2 \{choose(f.i)`2} as finite set by A18,FINSET_1:16;
      take XX;
      thus XX = (f.(i+1))`2 by A20,MCART_1:7;
      now
        assume choose (f.i)`2 in (f.i)`2 \ {choose (f.i)`2};
        then not choose (f.i)`2 in {choose (f.i)`2} by XBOOLE_0:def 4;
        hence contradiction by TARSKI:def 1;
      end;
      then card X = card XX + 1 by A18,A21,CARD_2:54;
      hence card XX + (i+1) = cA by A19;
    end;
A28: for i being Element of NAT st 1<=i & i<=len f holds P[i, f.i]
    from IndFinSeq0(A10,A14);
A29: now
      assume len F < 1;
      then len F = 0 by NAT_1:14;
      hence contradiction by A1,A7,GRAPH_5:5;
    end;
    F = F | (Seg len F) by FINSEQ_3:55;
    then
A30: rng F \/ (f.len F)`2 = A by A1,A2,A28,A29;
    consider X being finite set such that
A31: X = (f.len F)`2 and
A32: card X + len f = cA by A1,A2,A28,A29;
    X = {} by A2,A32,GRAPH_5:5;
    hence rng canFS(A) = A by A30,A31;
  end;
end;

theorem Th6:
  for a being set holds canFS({a}) = <* a *>
proof
  let a be set;
A1: len canFS({a}) = card {a} by Def1
    .= 1 by CARD_1:79;
  rng canFS({a}) = {a} by Th5;
  hence canFS({a}) = <* a *> by A1,FINSEQ_1:56;
end;

theorem Th7:
  for A being finite set holds (canFS A)" is Function of A, Seg card A
proof
  let A be finite set;
A1: canFS A is one-to-one by Th4;
  len canFS A = card A by Def1;
  then
A2: dom canFS A = Seg card A by FINSEQ_1:def 3;
  rng canFS A = A by Th5;
  then
A3: dom ((canFS A)") = A by A1,FUNCT_1:55;
  rng ((canFS A)") = Seg card A by A1,A2,FUNCT_1:55;
  hence (canFS A)" is Function of A, Seg card A by A3,FUNCT_2:3;
end;

begin :: More about bags

definition
  let X be set, S be finite Subset of X, n be Element of NAT;
  func (S, n)-bag -> Element of Bags X equals

  (EmptyBag X) +* (S --> n);
  correctness
  proof
    set b = (EmptyBag X) +* (S --> n);
A1: dom (S --> n) = S by FUNCOP_1:19;
A2: EmptyBag X = (X --> 0) by POLYNOM1:def 15;
A3: dom b = dom (EmptyBag X) \/ dom (S --> n) by FUNCT_4:def 1
      .= X \/ dom (S --> n) by A2,FUNCOP_1:19
      .= X \/ S by FUNCOP_1:19
      .= X by XBOOLE_1:12;
A4: now
      let i be set such that
A5:   not i in S;
      thus b.i = (EmptyBag X).i by A1,A5,FUNCT_4:12
        .= 0 by POLYNOM1:56;
    end;
A6: now
      let i be set such that
A7:   i in S;
      thus b.i = (S --> n).i by A1,A7,FUNCT_4:14
        .= n by A7,FUNCOP_1:13;
    end;
    support b is finite
    proof
      per cases;
      suppose
A8:     S is empty;
        now
          assume support b is non empty;
          then consider x being set such that
A9:       x in support b by XBOOLE_0:def 1;
          b.x <> 0 by A9,POLYNOM1:def 7;
          hence contradiction by A4,A8;
        end;
        hence support b is finite;
      end;
      suppose
A10:    S is non empty & n = 0;
        now
          assume support b is non empty;
          then consider x being set such that
A11:      x in support b by XBOOLE_0:def 1;
A12:      b.x <> 0 by A11,POLYNOM1:def 7;
          then b.x = (S-->n).x by A1,A4,FUNCT_4:14
            .= 0 by A4,A10,A12,
          FUNCOP_1:13;
          hence contradiction by A11,POLYNOM1:def 7;
        end;
        hence support b is finite;
      end;
      suppose S is non empty & n <> 0;
        then for x being set holds x in S iff b.x <> 0 by A4,A6;
        hence support b is finite by POLYNOM1:def 7;
      end;
    end;
    then (EmptyBag X) +* (S --> n) is bag of X by A3,PBOOLE:def 3
    ,POLYNOM1:def 8;
    hence (EmptyBag X) +* (S --> n) is Element of Bags X by POLYNOM1:def 14;
  end;
end;

theorem Th8:
  for X being set, S being finite Subset of X, n being Element of NAT,
  i being set st not i in S holds (S, n)-bag.i = 0
proof
  let X be set, S be finite Subset of X, n be Element of NAT,
  i be set such that
A1: not i in S;
  dom (S --> n) = S by FUNCOP_1:19;
  hence (S, n)-bag.i = (EmptyBag X).i by A1,FUNCT_4:12
    .= 0 by POLYNOM1:56;
end;

theorem Th9:
  for X being set, S being finite Subset of X, n being Element of NAT,
  i being set st i in S holds (S, n)-bag.i = n
proof
  let X be set, S be finite Subset of X, n be Element of NAT,
  i be set such that
A1: i in S;
  dom (S --> n) = S by FUNCOP_1:19;
  hence (S, n)-bag.i = (S --> n).i by A1,FUNCT_4:14
    .= n by A1,FUNCOP_1:13;
end;

theorem Th10:
  for X being set, S being finite Subset of X, n being Element of NAT
  st n <> 0 holds support (S, n)-bag = S
proof
  let X be set, S be finite Subset of X, n be Element of NAT;
  assume n <> 0;
  then for x being set holds x in S iff (S, n)-bag.x <> 0 by Th8,Th9;
  hence support (S, n)-bag = S by POLYNOM1:def 7;
end;

theorem
  for X being set, S being finite Subset of X, n being Element of NAT
  st S is empty or n = 0 holds (S, n)-bag = EmptyBag X
proof
  let X be set, S be finite Subset of X, n be Element of NAT such that
A1: S is empty or n = 0;
  now
    let i be set;
    assume i in X;
    per cases;
    suppose i in S;
      hence (S, n)-bag.i = 0 by A1,Th9
        .= (EmptyBag X).i by POLYNOM1:56;
    end;
    suppose not i in S;
      hence (S, n)-bag.i = 0 by Th8
        .= (EmptyBag X).i by POLYNOM1:56;
    end;
  end;
  hence (S, n)-bag = EmptyBag X by PBOOLE:3;
end;

theorem Th12:
  for X being set, S, T being finite Subset of X, n being Element of NAT
  st S misses T holds (S \/ T, n)-bag = (S,n)-bag + (T,n)-bag
proof
  let X be set, S, T be finite Subset of X, n be Element of NAT;
  assume S misses T;
  then
A1: S /\ T = {} by XBOOLE_0:def 7;
  now
    let i be set such that i in X;
    per cases by XBOOLE_0:def 2;
    suppose
A2:   not i in S \/ T;
      then
A3:   not i in S & not i in T by XBOOLE_0:def 2;
      thus (S \/ T, n)-bag.i = 0 by A2,Th8
        .= (S,n)-bag.i + (0 qua Nat) by A3,
      Th8
        .= (S,n)-bag.i + (T,n)-bag.i by A3,Th8
        .= ((S,n)-bag + (T,n)-bag).i by POLYNOM1:def 5;
    end;
    suppose
A4:   i in S;
      then
A5:   i in S \/ T by XBOOLE_0:def 2;
A6:   not i in T by A1,A4,XBOOLE_0:def 3;
      thus (S \/ T, n)-bag.i = n by A5,Th9
        .= (S,n)-bag.i + (0 qua Nat) by A4,Th9
        .= (S,n)-bag.i +(T,n)-bag.i by A6,Th8
        .= ((S,n)-bag + (T,n)-bag).i by POLYNOM1:def 5;
    end;
    suppose
A7:   i in T;
      then
A8:   i in S \/ T by XBOOLE_0:def 2;
A9:   not i in S by A1,A7,XBOOLE_0:def 3;
      thus (S \/ T, n)-bag.i = n by A8,Th9
        .= (T,n)-bag.i + (0 qua Nat) by A7,
      Th9
        .= (S,n)-bag.i + (T,n)-bag.i by A9,Th8
        .= ((S,n)-bag + (T,n)-bag).i by POLYNOM1:def 5;
    end;
  end;
  hence (S \/ T, n)-bag = (S,n)-bag + (T,n)-bag by PBOOLE:3;
end;

definition
  let X be set;
  mode Rbag of X is real-yielding finite-support ManySortedSet of X;
end;

definition
  let A be set, b be Rbag of A;
  func Sum b -> real number means
  :Def3:
  ex f being FinSequence of REAL st it = Sum f & f = b*canFS(support b);
  existence
  proof
    set cS = canFS(support b);
    set f = b*cS;
A1: support b c= dom b by POLYNOM1:41;
    rng cS = support b by Th5;
    then dom f = dom cS by A1,RELAT_1:46;
    then dom f = Seg len cS by FINSEQ_1:def 3;
    then
A2: f is FinSequence by FINSEQ_1:def 2;
    rng f c= REAL;
    then reconsider f as FinSequence of REAL by A2,FINSEQ_1:def 4;
    take S = Sum f; thus thesis;
  end;
  uniqueness;
end;

notation
  let A be set, b be bag of A;
  synonym degree b for Sum b;
end;

definition
  let A be set, b be bag of A;
  redefine func degree b -> Element of NAT means
  :Def4:
  ex f being FinSequence of NAT st it = Sum f & f = b*canFS(support b);
  coherence
  proof
    consider f being FinSequence of REAL such that
A1: degree b = Sum f and
A2: f = b*canFS(support b) by Def3;
    rng f c= NAT
    proof
      let y be set;
      assume y in rng f;
      then consider x being set such that
A3:   x in dom f and
A4:   y = f.x by FUNCT_1:def 5;
      f.x = b.((canFS(support b)).x) by A2,A3,FUNCT_1:22;
      hence y in NAT by A4;
    end;
    then reconsider f as FinSequence of NAT by FINSEQ_1:def 4;
    Sum f is Element of NAT;
    hence degree b is Element of NAT by A1;
  end;
  compatibility
  proof
    let n be Element of NAT;
    set cS = canFS(support b);
    hereby
      assume
A5:   n = degree b;
      consider f being FinSequence of REAL such that
A6:   degree b = Sum f and
A7:   f = b*canFS(support b) by Def3;
      rng f c= NAT
      proof
        let y be set;
        assume y in rng f;
        then consider x being set such that
A8:     x in dom f and
A9:     y = f.x by FUNCT_1:def 5;
        f.x = b.((canFS(support b)).x) by A7,A8,FUNCT_1:22;
        hence y in NAT by A9;
      end;
      then reconsider f as FinSequence of NAT by FINSEQ_1:def 4;
      take f;
      thus n = Sum f & f = b*cS by A5,A6,A7;
    end;
    given f being FinSequence of NAT such that
A10: n = Sum f and
A11: f = b*cS;
    rng f c= REAL;
    then reconsider f as FinSequence of REAL by FINSEQ_1:def 4;
    f = f;
    hence n = degree b by A10,A11,Def3;
  end;
end;

theorem Th13:
  for A being set, b being Rbag of A st b = EmptyBag A holds Sum b = 0
proof
  let A be set, b be Rbag of A;
  set cS = canFS(support b);
  assume b = EmptyBag A;
  then support b = {} by BAGORDER:19;
  then len cS = 0 by Def1,CARD_1:78;
  then cS = <*>NAT by FINSEQ_1:32;
  then
A1: b*cS = <*>NAT by RELAT_1:62;
  thus Sum b = 0 by A1,Def3,RVSUM_1:102;
end;

theorem Th14:
  for A being set, b being bag of A st Sum b = 0 holds b = EmptyBag A
proof
  let A be set, b be bag of A;
  set cS = canFS(support b);
  assume
A1: degree b = 0;
  consider f being FinSequence of NAT such that
A2: degree b = Sum f and
A3: f = b*canFS(support b) by Def4;
  now
    assume
A4: support b <> {};
A5: for i be Nat st i in dom f holds 0 <= f.i;
    now consider x being set such that
A6:   x in support b by A4,XBOOLE_0:def 1;
      x in rng cS by A6,Th5;
      then consider i being Nat such that
A7:   i in dom cS and
A8:   cS.i = x by FINSEQ_2:11;
      reconsider i as Element of NAT by ORDINAL1:def 13;
      support b c= dom b by POLYNOM1:41;
      then
A9:   i in dom f by A3,A6,A7,A8,FUNCT_1:21;
      f.i = b.(cS.i) by A3,A7,FUNCT_1:23;
      then f.i <> 0 by A6,A8,POLYNOM1:def 7;
      then 0 < f.i;
      hence ex i being Nat st i in dom f & 0 < f.i by A9;
    end;
    hence contradiction by A1,A2,A5,RVSUM_1:115;
  end;
  hence b = EmptyBag A by BAGORDER:20;
end;

theorem Th15:
  for A being set, S being finite Subset of A, b being bag of A
  holds S = support b & degree b = card S iff b = (S, 1)-bag
proof
  let A be set, S be finite Subset of A, b be bag of A;
  set cS = canFS(S);
  set f = b*cS;
A1: rng cS = S by Th5;
A2: dom b = A by PBOOLE:def 3;
  then
A3: dom f = dom cS by A1,RELAT_1:46;
  then
 dom f = Seg len cS by FINSEQ_1:def 3;
  then reconsider f as FinSequence by FINSEQ_1:def 2;
A5: len cS = card S by Def1;
A6: rng cS = S by Th5;
A7: len cS = len f by A3,FINSEQ_3:31;
  rng f c= NAT
  proof
    let y be set;
    assume y in rng f;
    then consider x being set such that
A8: x in dom f and
A9: y = f.x by FUNCT_1:def 5;
    f.x = b.(cS.x) by A8,FUNCT_1:22;
    hence y in NAT by A9;
  end;
  then reconsider f as FinSequence of NAT by FINSEQ_1:def 4;
  hereby
    assume that
A10: S = support b and
A11: degree b = card S;
    consider F being FinSequence of NAT such that
A12: degree b = Sum F and
A13: F = b*cS by A10,Def4;
    now
      let i be Element of NAT;
      assume
A14:  i in dom F;
      then
A15:  F.i = b.(cS.i) by A13,FUNCT_1:22;
      cS.i in rng cS by A3,A13,A14,FUNCT_1:12;
      hence F.i <> 0 by A10,A15,POLYNOM1:def 7;
    end;
    then
A16: F = len F |-> 1 by A5,A7,A11,A12,A13,Th2;
    set sb = (S, 1)-bag;
A17: support b = support sb by A10,Th10;
    now
      thus dom b = dom sb by A2,PBOOLE:def 3;
      let x be set;
      assume x in dom b;
      per cases;
      suppose
A18:    x in support b;
A19:    cS is one-to-one by Th4;
A20:    rng cS = support b by A10,Th5;
A21:    cS".x in dom cS by A1,A10,A18,A19,FUNCT_1:54;
        then
A22:    cS".x in Seg len F by A3,A13,FINSEQ_1:def 3;
        thus b.x = b.(cS.(cS".x)) by A18,A19,A20,FUNCT_1:57
          .= F.(cS".x) by A13,A21,FUNCT_1:23
          .= 1 by A16,A22,FUNCOP_1:13
          .= sb.x by A10,A18,Th9;
      end;
      suppose
A23:    not x in support b;
        hence b.x = 0 by POLYNOM1:def 7
          .= sb.x by A17,A23,POLYNOM1:def 7;
      end;
    end;
    hence b = (S, 1)-bag by FUNCT_1:9;
  end;
  assume
A24: b = (S, 1)-bag;
  hence S = support b by Th10;
  then
A25: degree b = Sum f by Def4;
  set g = (card S) |-> 1;
  now
    thus
A:     len f = card S by A3,A5,FINSEQ_3:31;
    thus len g = card S by FINSEQ_2:69;
    let i be Nat;
X: dom f = Seg card S by A,FINSEQ_1:def 3;
    assume
A26: i in dom f;
    hence f.i = b.(cS.i) by FUNCT_1:22
      .= 1 by A3,A6,A24,A26,Th9,FUNCT_1:12
      .= g.i by A26,FUNCOP_1: 13,X;
  end;
  then f = g by FINSEQ_2:10;
  hence degree b = (card S)*1 by A25,RVSUM_1:110
    .= card S;
end;

theorem Th16:
  for A being set, S being finite Subset of A, b being Rbag of A
  st support b c= S
  ex f being FinSequence of REAL st f = b*canFS(S) & Sum b = Sum f
proof
  let A be set, S be finite Subset of A, b be Rbag of A such that
A1: support b c= S;
  set cS = canFS(S);
  set f = b*cS;
  len cS = card S by Def1;
  then
A2: dom cS = Seg card S by FINSEQ_1:def 3;
A3: rng cS = S by Th5;
A4: cS is one-to-one by Th4;
A5: dom b = A by PBOOLE:def 3;
  then
A6: dom f = Seg card S by A2,A3,RELAT_1:46;
  then reconsider f as FinSequence by FINSEQ_1:def 2;
  rng f c= rng b by RELAT_1:45;
  then rng f c= REAL by XBOOLE_1:1;
  then reconsider f as FinSequence of REAL by FINSEQ_1:def 4;
  take f; thus f = b*canFS(S);
  set cs = canFS(support b);
A7: cs is one-to-one by Th4;
  consider g being FinSequence of REAL such that
A8: Sum b = Sum g and
A9: g = b*cs by Def3;
  len cs = card support b by Def1;
  then
A10: dom cs = Seg card support b by FINSEQ_1:def 3;
A11: rng cs = support b by Th5;
  then
A12: dom g = Seg card support b by A1,A5,A9,A10,RELAT_1:46,XBOOLE_1:1;
  then
A13: len g = card support b by FINSEQ_1:def 3;
A14: card support b <= card S by A1,NAT_1:44;
  per cases by A14,REAL_1:def 5;
  suppose
A15: card support b < card S;
    then consider d being Element of NAT such that
A16: card S = (card support b) + d and 1 <= d by FSM_1:1;
    set h = d |-> (0 qua Real);
    len h = d by FINSEQ_2:69;
    then
A17: dom h = Seg d by FINSEQ_1:def 3;
    reconsider gr = g as FinSequence of REAL;
    set F = gr^h;
    len F = len g + len h by FINSEQ_1:35
      .= card S by A13,A16,FINSEQ_2:69;
    then
A18: dom F = Seg card S by FINSEQ_1:def 3;
    set dd = {j where j is Element of NAT : j in dom f & f.j = 0};
A19: now consider x being set such that
A20:  not (x in support b iff x in S) by A15,TARSKI:2;
      consider j being set such that
A21:  j in dom cS and
A22:  cS.j = x by A1,A3,A20,FUNCT_1:def 5;
      reconsider j as Element of NAT by A21;
      f.j =b.x by A21,A22,FUNCT_1:23;
      then f.j = 0 by A1,A20,POLYNOM1:def 7;
      then j in dd by A2,A6,A21;
      hence dd is non empty;
    end;
A23: dd c= dom f
    proof
      let x be set;
      assume x in dd;
      then ex j being Element of NAT st x = j & j in dom f & f.j = 0;
      hence thesis;
    end;
    then reconsider dd as finite non empty set by A19,FINSET_1:13;
    rng canFS(dd) = dd & dd c= NAT by A23,Th5,XBOOLE_1:1;
    then reconsider cdd = canFS(dd) as FinSequence of NAT by FINSEQ_1:def 4;
    set cdi = cdd qua Function";
    reconsider cdi as Function of dd, Seg card dd by Th7;
    reconsider cadd = card dd as non empty Element of NAT;
    reconsider cdi as Function of dd, NAT by FUNCT_2:9;
    set cSr = cS | (dom f \ dd);
A25: cSr is one-to-one by A4,FUNCT_1:84;
    (findom f \ dd) /\ dom f = dom f \ dd by XBOOLE_1:28;
    then
A26: dom cSr = (dom f \ dd) by A2,A6,FUNCT_1:68;
    now
      let y be set;
      hereby
        assume y in rng cSr;
        then consider x being set such that
A27:    x in dom cSr and
A28:    y = cSr.x by FUNCT_1:def 5;
A29:    x in dom cS & x in findom f \ dd by A27,RELAT_1:86;
        reconsider j = x as Element of NAT by A27;
A30:    cSr.x = cS.x by A27,FUNCT_1:70;
        not j in dd by A29,XBOOLE_0:def 4;
        then f.j <> 0 by A29;
        then b.(cS.j) <> 0 by A29,FUNCT_1:23;
        hence y in support b by A28,A30,POLYNOM1:def 7;
      end;
      assume
A31:  y in support b;
      then consider x being set such that
A32:  x in dom cS and
A33:  y = cS.x by A1,A3,FUNCT_1:def 5;
      now
        assume x in dd;
        then consider j being Element of NAT such that
A34:    j = x and
A35:    j in dom f and
A36:    f.j = 0;
        0 = b.(cS.j) by A2,A6,A35,A36,FUNCT_1:23;
        hence contradiction by A31,A33,A34,POLYNOM1:def 7;
      end;
      then x in dom f \ dd by A2,A6,A32,XBOOLE_0:def 4;
      hence y in rng cSr by A32,A33,FUNCT_1:73;
    end;
    then rng cSr = support b by TARSKI:2;
    then support b, dom f \dd are_equipotent by A25,A26,WELLORD2:def 4;
    then
A37: card support b = card (dom f \ dd) by CARD_1:81;
    card (dom f \ dd) = card dom f - card dd by A23,CARD_2:63;
    then
A38: card support b + card dd = card S by A6,A37,FINSEQ_1:78;
    len cdd = card dd by Def1;
    then
A39: dom cdd = Seg d by A16,A38,FINSEQ_1:def 3;
A40: rng cdd = dd by Th5;
A41: dom cdi = dd by FUNCT_2:def 1;
A42: cdd is one-to-one by Th4;
    then
A43: cdi is one-to-one by FUNCT_1:62;
A44: rng cdi = Seg d by A39,A42,FUNCT_1:55;
    deffunc Z(set) = cdi /. $1 + card support b;
    consider z being Function such that
A45: dom z = dd and
A46: for x being set st x in dd holds z.x = Z(x) from FUNCT_1:sch 3;
A47: rng z c= Seg card S
    proof
      let y be set;
      assume y in rng z;
      then consider x being set such that
A48:  x in dom z and
A49:  y = z.x by FUNCT_1:def 5;
A50:  y = cdi/.x + card support b by A45,A46,A48,A49;
A51:  cdi/.x = cdi.x by A41,A45,A48,PARTFUN1:def 8;
      cdi.x in Seg d by A41,A44,A45,A48,FUNCT_1:12;
      then 1 <= cdi/.x & cdi/.x <= d by A51,FINSEQ_1:3;
      then 1 <= cdi/.x + card support b &
      cdi/.x + card support b <= d + card support b by NAT_1:12,XREAL_1:8;
      hence thesis by A16,A50,FINSEQ_1:3;
    end;
    set p = cs"*cS +* z;
A52: dom p = dom (cs"*cS) \/ dom z by FUNCT_4:def 1;
A53: now
      assume dom (cs"*cS) /\ dom z <> {};
      then consider x being set such that
A54:  x in dom (cs"*cS) /\ dom z by XBOOLE_0:def 1;
A55:  x in dom (cs"*cS) & x in dom z by A54,XBOOLE_0:def 3;
      then consider j being Element of NAT such that
A56:  j = x and j in dom f and
A57:  f.j = 0 by A45;
A58:  dom (cs") = support b by A7,A11,FUNCT_1:55;
      j in dom cS by A55,A56,FUNCT_1:21;
      then f.j = b.(cS.j) by FUNCT_1:23;
      then not cS.j in support b by A57,POLYNOM1:def 7;
      hence contradiction by A55,A56,A58,FUNCT_1:21;
    end;
    now
      let x be set;
      hereby
        assume
A59:    x in dom (cs"*cS) \/ dom z;
        per cases by A59,XBOOLE_0:def 2;
        suppose x in dom (cs"*cS);
          hence x in dom F by A2,A18,FUNCT_1:21;
        end;
        suppose x in dom z;
          hence x in dom F by A6,A18,A23,A45;
        end;
      end;
      assume
A60:  x in dom F;
      then reconsider i = x as Element of NAT;
      per cases;
      suppose f.x = 0;
        then i in dom z by A6,A18,A45,A60;
        hence x in dom (cs"*cS) \/ dom z by XBOOLE_0:def 2;
      end;
      suppose
A61:    f.x <> 0;
        f.i = b.(cS.i) by A2,A18,A60,FUNCT_1:23;
        then cS.i in support b by A61,POLYNOM1:def 7;
        then cS. i in dom (cs") by A7,A11,FUNCT_1:55;
        then i in dom (cs"*cS) by A2,A18,A60,FUNCT_1:21;
        hence x in dom (cs"*cS) \/ dom z by XBOOLE_0:def 2;
      end;
    end;
    then
A62: dom (cs"*cS) \/ dom z = dom F by TARSKI:2;
    then
A63: dom p = dom F by FUNCT_4:def 1;
    now
      let x be set such that
A64:  x in dom F;
      per cases by A62,A64,XBOOLE_0:def 2;
      suppose
A65:    x in dom (cs"*cS);
        then not x in dom z by A53,XBOOLE_0:def 3;
        then
A66:    p.x = (cs"*cS).x by FUNCT_4:12;
        (cs"*cS).x in rng (cs"*cS) by A65,FUNCT_1:12;
        then (cs"*cS).x in rng (cs") by FUNCT_1:25;
        then
A67:    (cs"*cS).x in dom cs by A7,FUNCT_1:55;
        Seg card support b c= Seg card S by A14,FINSEQ_1:7;
        hence p.x in dom F by A10,A18,A66,A67;
      end;
      suppose
A68:    x in dom z;
        then
A69:    p.x = z.x by FUNCT_4:14;
        z.x in rng z by A68, FUNCT_1:12;
        hence p.x in dom F by A18,A47,A69;
      end;
    end;
    then reconsider p as Function of dom F, dom F by A63,FUNCT_2:5;
A70: p is one-to-one
    proof
      let a, c be set such that
A71:  a in dom p and
A72:  c in dom p and
A73:  p.a = p.c;
      per cases by A52,A71,A72,XBOOLE_0:def 2;
      suppose
A74:    a in dom (cs"*cS) & c in dom (cs"*cS);
        then not a in dom z by A53,XBOOLE_0:def 3;
        then
A75:    p.a = (cs"*cS).a by FUNCT_4:12
          .= cs".(cS.a) by A74,FUNCT_1:22;
        not c in dom z by A53,A74,XBOOLE_0:def 3;
        then
A76:    p.c = (cs"*cS).c by FUNCT_4:12
          .= cs".(cS.c) by A74,FUNCT_1:22;
        cS.a in dom (cs") by A74,FUNCT_1:21;
        then cS.a in rng cs by A7,FUNCT_1:55;
        then
A77:    cs.(cs".(cS.a)) = cS.a by A7,FUNCT_1:57;
        cS.c in dom (cs") by A74,FUNCT_1:21;
        then cS.c in rng cs by A7,FUNCT_1:55;
        then
A78:    cS".(cS.a) = cS".(cS.c) by A7,A73,A75,A76,A77,FUNCT_1:57;
        a in dom cS by A74,FUNCT_1:21;
        then
A79:    cS".(cS.a) = a by A4,FUNCT_1:56;
        c in dom cS by A74,FUNCT_1:21;
        hence a = c by A4,A78,A79,FUNCT_1:56;
      end;
      suppose
A80:    a in dom (cs"*cS) & c in dom z;
        then
A81:    p.c = z.c by FUNCT_4:14
          .= cdi /. c + card support b by A45,A46,A80;
        not a in dom z by A53,A80,XBOOLE_0:def 3;
        then
A82:    p.a = (cs"*cS).a by FUNCT_4:12
          .= cs".(cS.a) by A80,FUNCT_1:22;
        cS.a in dom (cs") by A80,FUNCT_1:21;
        then cs".(cS.a) in rng (cs") by FUNCT_1:12;
        then
A83:    cs".(cS.a) in dom cs by A7,FUNCT_1:55;
        cdi /. c + card support b <= (0 qua Nat)+card support b
        by A10,A73,A81,A82,A83,FINSEQ_1:3;
        then cdi /. c <= 0 by XREAL_1:8;
        then cdi /. c = 0;
        then
A84:    cdi.c = 0 by A41,A45,A80,PARTFUN1:def 8;
        cdi.c in rng cdi by A41,A45,A80,FUNCT_1:12;
        hence a = c by A44,A84,FINSEQ_1:3;
      end;
      suppose
A85:    a in dom z & c in dom (cs"*cS);
        then
A86:    p.a = z.a by FUNCT_4:14
          .= cdi /. a + card support b by A45,A46,A85;
        not c in dom z by A53,A85,XBOOLE_0:def 3;
        then
A87:    p.c = (cs"*cS).c by FUNCT_4:12
          .= cs".(cS.c) by A85,FUNCT_1:22;
        cS.c in dom (cs") by A85,FUNCT_1:21;
        then cs".(cS.c) in rng (cs") by FUNCT_1:12;
        then
A88:    cs".(cS.c) in dom cs by A7,FUNCT_1:55;
        cdi /. a + card support b <= (0 qua Nat)+card support b
        by A10,A73,A86,A87,A88,FINSEQ_1:3;
        then cdi /. a <= 0 by XREAL_1:8;
        then cdi /. a = 0;
        then
A89:    cdi.a = 0 by A41,A45,A85,PARTFUN1:def 8;
        cdi.a in rng cdi by A41,A45,A85,FUNCT_1:12;
        hence a = c by A44,A89,FINSEQ_1:3;
      end;
      suppose
A90:    a in dom z & c in dom z;
        then
A91:    p.a = z.a by FUNCT_4:14
          .= cdi /. a + card support b by A45,A46,A90;
A92:    p.c = z.c by A90,FUNCT_4:14
          .= cdi /. c + card support b by A45
        ,A46,A90;
        cdi /. a = cdi . a & cdi /. c = cdi . c by A41,A45,A90,
        PARTFUN1:def 8;
        hence a = c by A41,A43,A45,A73,A90,A91,A92,FUNCT_1:def 8;
      end;
    end;
    now
      let x be set;
      hereby
        assume x in rng p;
        then consider a being set such that
A93:    a in dom p and
A94:    x = p.a by FUNCT_1:def 5;
        per cases by A93,FUNCT_4:13;
        suppose
A95:      a in dom (cs"*cS);
          then not a in dom z by A53,XBOOLE_0:def 3;
          then
A96:      p.a = (cs"*cS).a by FUNCT_4:12
            .= cs".(cS.a) by A95,FUNCT_1:22;
          cS.a in dom (cs") by A95,FUNCT_1:21;
          then cs".(cS.a) in rng (cs") by FUNCT_1:12;
          then
A97:      cs".(cS.a) in dom cs by A7,FUNCT_1:55;
          dom cs c= dom F by A10,A14,A18,FINSEQ_1:7;
          hence x in dom F by A94,A96,A97;
        end;
        suppose
A98:      a in dom z;
          then
A99:      z.a in rng z by FUNCT_1:12;
          p.a = z.a by A98, FUNCT_4:14;
          hence x in dom F by A18,A47,A94,A99;
        end;
      end;
      assume
A100: x in dom F;
      then reconsider j = x as Element of NAT;
      per cases by A100,FINSEQ_1:38;
      suppose
A101:   j in dom gr;
        then
A102:   cs.j in support b by A10,A11,A12,FUNCT_1:12;
        then
A103:   cS".(cs.j) in Seg card S by A1,A2,A3,A4,FUNCT_1:54;
        now
          assume
A104:     cS".(cs.j) in dom z;
A105:     (b*cS).(cS".(cs.j)) = b.(cS.(cS".(cs.j))) by A2,A103, FUNCT_1:23
            .= b.(cs.j) by A1,A3,A4,A102,FUNCT_1:57;
          ex k being Element of NAT
          st k = cS".(cs.j) & k in dom f & f.k = 0 by A45,A104;
          hence contradiction by A102,A105,POLYNOM1:def 7;
        end;
        then p.(cS".(cs.j)) = (cs"*cS).(cS".(cs.j)) by FUNCT_4:12
          .= cs".(cS.(cS".(cs.j))) by A2,A103,FUNCT_1:23
          .= cs".(cs.j) by A1,A3,A4,A102,FUNCT_1:57
          .= j by A7,A10,A12,A101,
        FUNCT_1:56;
        hence x in rng p by A18,A63,A103,FUNCT_1:12;
      end;
      suppose ex n being Nat st n in dom h & j=len gr + n;
        then consider n being Nat such that
A106:   n in dom h and
A107:   j = len gr + n;
A108:   cdd.n in dd by A17,A39,A40,A106,FUNCT_1:12;
        p.(cdd.n) = z.(cdd.n) by A17,A39,A40,A45,A106,FUNCT_1:12,FUNCT_4:14
          .= cdi /. (cdd.n) + card support b by A17,A39,A40,A46,A106,FUNCT_1:12
          .= cdi.(cdd.n) + card support b by A17,A39,A40,A41,A106,FUNCT_1:12,
        PARTFUN1:def 8
          .= n + card support b by A17,A39,A42,A106,FUNCT_1:56
          .= j by A12,A107, FINSEQ_1:def 3;
        hence x in rng p by A6,A18,A23,A63,A108,FUNCT_1:12;
      end;
    end;
    then
A109: rng p = dom F by TARSKI:2;
    then p is onto by FUNCT_2:def 3;
    then
A110: p is Permutation of dom F by A70,FUNCT_2:def 4;
A111: dom (F*p) = dom F by A63,A109,RELAT_1:46;
    now
      let x be set;
      assume
A112: x in dom f;
      per cases;
      suppose
A113:   f.x = 0;
        reconsider j = x as Element of NAT by A112;
A114:   j in dom z by A45,A112,A113;
        then
A115:   p.x = z.x by FUNCT_4:14
          .= cdi /. x + card support b by A45,A46,A114;
        reconsider px = p.x as Element of NAT;
        dom cdi = dd by FUNCT_2:def 1;
        then
A116:   cdi /. x = cdi.x by A45,A114,PARTFUN1:def 8;
A117:   cdi.x in Seg card dd by A45,A114,FUNCT_2:7;
        reconsider cdix = cdi /. x as Element of NAT;

thus f.x = h.(cdix) by A16,A38,A45,A113,A114,A116,FUNCOP_1:13,FUNCT_2 :7
          .= F.px by A13,A16,A17,A38,A115,A116,A117,FINSEQ_1:def 7
          .= (F*p).x by A6,A18,A111,A112,FUNCT_1:22;
      end;
      suppose
A118:   f.x <> 0;
A119:   now
          assume x in dd;
          then ex j being Element of NAT st j=x & j in dom f & f.j = 0;
          hence contradiction by A118;
        end;
        f.x = b.(cS.x) by A112,FUNCT_1:22;
        then cS.x in support b by A118,POLYNOM1:def 7;
        then
A120:   cS.x in rng cs by Th5;
        then
A121:   cs".(cS.x) in dom cs by A7,FUNCT_1:54;
A122:   p.x = (cs"*cS).x by A45,A119,FUNCT_4:12
          .= cs".(cS.x) by A2,A6,A112,FUNCT_1:23;
        reconsider px = p.x as Element of NAT;
        thus f.x = b.(cS.x) by A112,FUNCT_1:22
          .= b.(cs.px) by A7,A120,A122,FUNCT_1:54
          .= g.(px) by A9,A121,A122,FUNCT_1:23
          .= F.(px) by A10,A12,A121,A122,FINSEQ_1:def 7
          .= (F*p).x by A6,A18,A111,A112,FUNCT_1:22;
      end;
    end;
    then
A123: f = F*p by A6,A18,A111,FUNCT_1:9;
    Sum h = 0 by RVSUM_1:111;
    then Sum gr = Sum gr + Sum h
      .= Sum F by RVSUM_1:105;
    hence Sum b = Sum f by A8,A110,A123,FINSOP_1:8;
  end;
  suppose card support b = card S;
    hence Sum b = Sum f by A1,A8,A9,TRIANG_1:3;
  end;
end;

theorem Th17:
  for A being set, b, b1, b2 being Rbag of A
  st b = b1 + b2 holds Sum b = Sum b1 + Sum b2
proof
  let A be set, b, b1, b2 be Rbag of A;
  assume
A1: b = b1 + b2;
  set S = support b;
  set SS = support b1 \/ support b2;
A2: dom b = A & dom b1 = A & dom b2 = A by PBOOLE:def 3;
  then support b1 c= A & support b2 c= A by POLYNOM1:41;
  then reconsider SS as finite Subset of A by XBOOLE_1:8;
  S c= SS by A1,POLYNOM1:91;
  then consider f being FinSequence of REAL such that
A3: f = b*canFS(SS) and
A4: Sum b = Sum f by Th16;
  support b1 c= SS by XBOOLE_1:7;
  then consider f1r being FinSequence of REAL such that
A5: f1r = b1*canFS(SS) and
A6: Sum b1 = Sum f1r by Th16;
  support b2 c= SS by XBOOLE_1:7;
  then consider f2r being FinSequence of REAL such that
A7: f2r = b2*canFS(SS) and
A8: Sum b2 = Sum f2r by Th16;
  set cS = canFS SS;
  rng cS = SS by Th5;
  then
A9: dom f = dom cS & dom f1r = dom cS & dom f2r = dom cS
  by A2,A3,A5,A7,RELAT_1:46;
  then
A10: len f1r = len f2r & len f1r = len f by FINSEQ_3:31;
  now
    let k be Element of NAT such that
A11: k in dom f1r;
A12: f1r/.k = f1r.k by A11,PARTFUN1:def 8
      .= b1.(cS.k) by A5,A11,FUNCT_1:22;
A13: f2r/.k = f2r.k by A9,A11,PARTFUN1:def 8
      .= b2.(cS.k) by A7,A9,A11,FUNCT_1:22;
    f.k = b.(cS.k) by A3,A9,A11,FUNCT_1:22;
    hence f.k = f1r/.k + f2r/.k by A1,A12,A13,POLYNOM1:def 5;
  end;
  hence Sum b = Sum b1 + Sum b2 by A4,A6,A8,A10,INTEGRA1:23;
end;

theorem Th18: :: GROUP_4:18 but about a different Product
  for L being associative commutative unital (non empty multMagma),
  f, g being FinSequence of L, p being Permutation of dom f
  st g = f * p holds Product(g) = Product(f)
proof
  let L be associative commutative unital (non empty multMagma),
  f, g be FinSequence of L, p be Permutation of dom f such that
A1: g = f * p;
  set mL = (the multF of L);
A2: mL is commutative by MONOID_0:def 11;
A3: mL is associative by GROUP_1:31;
  mL has_a_unity by GROUP_1:34;
  hence Product g = Product f by A1,A2,A3,FINSOP_1:8;
end;

begin :: More on polynomials

definition
  let L be non empty ZeroStr, p be Polynomial of L;
  attr p is non-zero means
  :Def5:
  p <> 0_. L;
end;

theorem Th19:
  for L being non empty ZeroStr, p being Polynomial of L
  holds p is non-zero iff len p > 0
proof
  let L be non empty ZeroStr, p be Polynomial of L;
  hereby
    assume p is non-zero;
    then p <> 0_. L by Def5;
    then len p <> 0 by POLYNOM4:8;
    hence len p > 0;
  end;
  assume len p > 0;
  then p <> 0_. L by POLYNOM4:6;
  hence p is non-zero by Def5;
end;

registration
  let L be non trivial (non empty ZeroStr);
  cluster non-zero Polynomial of L;
  existence
  proof
    consider a being Element of (the carrier of L)\{0.L};
A1: (the carrier of L)\{0.L} is non empty by REALSET1:4;
    then
A2: a in the carrier of L & not(a in {0.L}) by XBOOLE_0:def 4;
    reconsider a as Element of L by A1,XBOOLE_0:def 4;
    take p = <%a%>;
    p.0 = a & (0_. L).0 = 0.L by FUNCOP_1:13,POLYNOM5:33;
    then p <> 0_. L by A2,TARSKI:def 1;
    hence thesis by Def5;
  end;
end;

registration
  let L be non degenerated (non empty multLoopStr_0), x be Element of L;
  cluster <%x, 1.L%> -> non-zero;
  correctness
  proof
    len <%x, 1.L%> = 2 by POLYNOM5:41;
    hence thesis by Th19;
  end;
end;

theorem Th20:
  for L being non empty ZeroStr, p being Polynomial of L
  st len p > 0 holds p.(len p -'1) <> 0.L
proof
  let L be non empty ZeroStr, p be Polynomial of L;
  assume len p > 0;
  then consider k being Nat such that
A1: len p = k+1 by NAT_1:6;
  len p = (len p -'1)+1 by A1,BINARITH:39;
  hence p.(len p -'1) <> 0.L by ALGSEQ_1:25;
end;

theorem Th21:
  for L being non empty ZeroStr, p being AlgSequence of L
  st len p = 1 holds p = <%p.0%> & p.0 <> 0.L
proof
  let L be non empty ZeroStr, p being AlgSequence of L such that
A1: len p = 1;
  thus p=<%p.0%> by A1,ALGSEQ_1:def 6;
  hence p.0 <> 0.L by A1,ALGSEQ_1:31;
end;

theorem Th22: :: from POLYNOM4:5 right-distributive
  for L be add-associative right_zeroed right_complementable
  right-distributive (non empty doubleLoopStr),
  p be Polynomial of L holds p*'(0_.(L)) = 0_.(L)
proof
  let L be add-associative right_zeroed right_complementable
  right-distributive (non empty doubleLoopStr), p be Polynomial of L;
  now
    let i be Element of NAT;
    consider r be FinSequence of L such that len r = i+1 and
A1: (p*'(0_.(L))).i = Sum r and
A2: for k be Element of NAT st k in dom r
    holds r.k = p.(k-'1) * (0_. L).(i+1-'k) by POLYNOM3:def 11;
    now
      let k be Element of NAT;
      assume k in dom r;
      hence r.k = p.(k-'1) * (0_. L).(i+1-'k) by A2
        .= p.(k-'1) * 0.L by FUNCOP_1:13
        .= 0.L by VECTSP_1:36;
    end;
    hence (p*'(0_.(L))).i = 0.L by A1,POLYNOM3:1
      .= (0_.(L)).i by FUNCOP_1:13;
  end;
  hence thesis by FUNCT_2:113;
end;

registration
  cluster algebraic-closed add-associative right_zeroed right_complementable
    Abelian commutative associative distributive domRing-like
    non degenerated (unital (non empty doubleLoopStr));
  existence
  proof
    take F_Complex; thus thesis;
  end;
end;

theorem Th23:
  for L being add-associative right_zeroed right_complementable distributive
  domRing-like (non empty doubleLoopStr), p, q being Polynomial of L
  st p*'q = 0_. L holds p = 0_. L or q = 0_. L
proof
  let L be add-associative right_zeroed right_complementable distributive
  domRing-like (non empty doubleLoopStr), p, q being Polynomial of L such that
A1: p*'q = 0_. L and
A2: p <> 0_. L and
A3: q <> 0_. L;
A4: len p <> 0 by A2,POLYNOM4:8;
  then consider lp1 being Nat such that
A5: len p = lp1+1 by NAT_1:6;
  len q <> 0 by A3,POLYNOM4:8;
  then consider lq1 being Nat such that
A6: len q = lq1+1 by NAT_1:6;
  reconsider lp1, lq1 as Element of NAT by ORDINAL1:def 13;
A7: p.lp1 <> 0.L & q.lq1 <> 0.L by A5,A6,ALGSEQ_1:25;
  set lpq = lp1 + lq1;
  consider r being FinSequence of L such that
A8: len r = lpq+1 and
A9: (p*'q).lpq = Sum r and
A10: for k be Element of NAT st k in dom r holds r.k=p.(k-'1)*q.(lpq+1-'k)
  by POLYNOM3:def 11;
A11: len p <= lp1+1+lq1 by A5,NAT_1:12;
  0 < len p by A4;
  then 0 qua Nat+1 <= len p by NAT_1:13;
  then
A12: len p in dom r by A8,A11,FINSEQ_3:27;
A13: lpq+1-'len p = lq1+(lp1+1)-'len p
    .= lq1 by A5,BINARITH:39;
  now
    let k be Nat such that
A14: k in dom r and
A15: k <> len p;
    reconsider k1=k as Element of NAT by ORDINAL1:def 13;
A16: r.k1 = p.(k1-'1) * q.(lpq+1-'k1) by A10,A14;
    per cases by A15,REAL_1:def 5;
    suppose k < len p;
      then consider d being Element of NAT such that
A17:  len p = k1+d & 1 <= d by FSM_1:1;
A18:  lpq+1-'k = lq1+d+k-'k by A5,A17
        .= lq1+d by BINARITH:39;
      len q <= lq1+d by A6,A17,XREAL_1:8;
      hence r.k = p.(k-'1)*0.L by A16,A18,ALGSEQ_1:22
        .= 0.L by VECTSP_1:36;
    end;
    suppose k > len p;
      then k >= len p + 1 by NAT_1:13;
      then k-'1 >= len p + 1-'1 by BINARITH:60;
      then k-'1 >= len p by BINARITH:39;
      hence r.k = 0.L * q.(lpq+1-'k) by A16,ALGSEQ_1:22
        .= 0.L by VECTSP_1:39;
    end;
  end;
  then Sum r = r.(len p) by A12,MATRIX_3:14
    .= p.(len p -'1)*q.(lpq+1-'len p) by A10,A12
    .= p.lp1 * q.lq1 by A5,A13,
  BINARITH:39;
  then Sum r <> 0.L by A7,VECTSP_2:def 5;
  hence contradiction by A1,A9,FUNCOP_1:13;
end;

registration
  let L be add-associative right_zeroed right_complementable distributive
  domRing-like (non empty doubleLoopStr);
  cluster Polynom-Ring L -> domRing-like;
  correctness
  proof
    set PRL = Polynom-Ring L;
    let x, y be Element of PRL;
    reconsider xp = x, yp = y as Polynomial of L by POLYNOM3:def 12;
A1: 0_. L = 0.PRL by POLYNOM3:def 12;
    assume x*y = 0.PRL;
    then xp*'yp = 0_. L by A1,POLYNOM3:def 12;
    hence x = 0.PRL or y = 0.PRL by A1,Th23;
  end;
end;

registration
  let L be domRing, p, q be non-zero Polynomial of L;
  cluster p*'q -> non-zero;
  correctness
  proof p <> 0_. L & q <> 0_. L by Def5;
    then p*'q <> 0_. L by Th23;
    hence thesis by Def5;
  end;
end;

theorem
  for L being non degenerated comRing, p, q being Polynomial of L
  holds Roots p \/ Roots q c= Roots (p*'q)
proof
  let L be non degenerated comRing, p, q being Polynomial of L;
  let x be set;
  assume
A1: x in Roots p \/ Roots q;
  per cases by A1,XBOOLE_0:def 2;
  suppose
A2: x in Roots p;
    then reconsider a = x as Element of L;
    a is_a_root_of p by A2,POLYNOM5:def 9;
    then eval(p,a) = 0.L by POLYNOM5:def 6;
    then eval(p,a) * eval(q,a) = 0.L by VECTSP_1:39;
    then eval(p*'q,a) = 0.L by POLYNOM4:27;
    then a is_a_root_of p*'q by POLYNOM5:def 6;
    hence x in Roots (p*'q) by POLYNOM5:def 9;
  end;
  suppose
A3: x in Roots q;
    then reconsider a = x as Element of L;
    a is_a_root_of q by A3,POLYNOM5:def 9;
    then eval(q,a) = 0.L by POLYNOM5:def 6;
    then eval(p,a) * eval(q,a) = 0.L by VECTSP_1:36;
    then eval(p*'q,a) = 0.L by POLYNOM4:27;
    then a is_a_root_of p*'q by POLYNOM5:def 6;
    hence x in Roots (p*'q) by POLYNOM5:def 9;
  end;
end;

theorem Th25:
  for L being domRing, p, q being Polynomial of L
  holds Roots (p*'q) = Roots p \/ Roots q
proof
  let L be domRing, p, q being Polynomial of L;
  now
    let x be set;
    hereby
      assume
A1:   x in Roots (p*'q);
      then reconsider a = x as Element of L;
      a is_a_root_of p*'q by A1,POLYNOM5:def 9;
      then eval(p*'q,a) = 0.L by POLYNOM5:def 6;
      then
A2:   eval(p,a) * eval(q,a) = 0.L by POLYNOM4:27;
      per cases by A2,VECTSP_2:def 5;
      suppose eval(p,a) = 0.L;
        then a is_a_root_of p by POLYNOM5:def 6;
        then a in Roots p by POLYNOM5:def 9;
        hence x in Roots p \/ Roots q by XBOOLE_0:def 2;
      end;
      suppose eval(q,a) = 0.L;
        then a is_a_root_of q by POLYNOM5:def 6;
        then a in Roots q by POLYNOM5:def 9;
        hence x in Roots p \/ Roots q by XBOOLE_0:def 2;
      end;
    end;
    assume
A3: x in Roots p \/ Roots q;
    per cases by A3,XBOOLE_0:def 2;
    suppose
A4:   x in Roots p;
      then reconsider a = x as Element of L;
      a is_a_root_of p by A4,POLYNOM5:def 9;
      then eval(p,a) = 0.L by POLYNOM5:def 6;
      then eval(p,a) * eval(q,a) = 0.L by VECTSP_1:39;
      then eval(p*'q,a) = 0.L by POLYNOM4:27;
      then a is_a_root_of p*'q by POLYNOM5:def 6;
      hence x in Roots (p*'q) by POLYNOM5:def 9;
    end;
    suppose
A5:   x in Roots q;
      then reconsider a = x as Element of L;
      a is_a_root_of q by A5,POLYNOM5:def 9;
      then eval(q,a) = 0.L by POLYNOM5:def 6;
      then eval(p,a) * eval(q,a) = 0.L by VECTSP_1:36;
      then eval(p*'q,a) = 0.L by POLYNOM4:27;
      then a is_a_root_of p*'q by POLYNOM5:def 6;
      hence x in Roots (p*'q) by POLYNOM5:def 9;
    end;
  end;
  hence Roots (p*'q) = Roots p \/ Roots q by TARSKI:2;
end;

theorem Th26:
  for L being add-associative right_zeroed right_complementable distributive
  (non empty doubleLoopStr),
  p being (Polynomial of L), pc being (Element of Polynom-Ring L)
  st p = pc holds -p = -pc
proof
  let L be add-associative right_zeroed right_complementable distributive
  (non empty doubleLoopStr),
  p be (Polynomial of L), pc be (Element of Polynom-Ring L) such that
A1: p = pc;
  set PRL = Polynom-Ring L;
  reconsider mpc = -p as Element of PRL by POLYNOM3:def 12;
  p+-p = p-p
    .= 0_. L by POLYNOM3:30;
  then pc + mpc = 0_. L by A1,POLYNOM3:def 12
    .= 0.PRL by POLYNOM3:def 12;
  hence -p = -pc by RLVECT_1:def 11;
end;

theorem Th27:
  for L being add-associative right_zeroed right_complementable distributive
  (non empty doubleLoopStr),
  p, q being (Polynomial of L), pc, qc being (Element of Polynom-Ring L)
  st p= pc & q = qc holds p-q = pc-qc
proof
  let L be add-associative right_zeroed right_complementable distributive
  (non empty doubleLoopStr),
  p,q be (Polynomial of L), pc,qc be (Element of Polynom-Ring L) such that
A1: p = pc and
A2: q = qc;
  -q = -qc by A2,Th26;
  hence p-q = pc-qc by A1,POLYNOM3:def 12;
end;

theorem Th28:
  for L being Abelian add-associative right_zeroed right_complementable
  distributive (non empty doubleLoopStr), p, q, r being (Polynomial of L)
  holds p*'q-p*'r = p*'(q-r)
proof
  let L be Abelian add-associative right_zeroed right_complementable
  distributive (non empty doubleLoopStr), p, q, r be (Polynomial of L);
  set PRL = Polynom-Ring L;
  reconsider pc = p, qc = q, rc = r as Element of PRL by POLYNOM3:def 12;
A1: p*'q = pc*qc by POLYNOM3:def 12;
A2: p*'r = pc*rc by POLYNOM3:def 12;
A3: qc-rc = q-r by Th27;
  thus p*'q-p*'r = pc*qc - pc*rc by A1,A2,Th27
    .= pc*(qc-rc) by VECTSP_1:43
    .= p*'(q-r) by A3,POLYNOM3:def 12;
end;

theorem Th29:
  for L being add-associative right_zeroed right_complementable distributive
  (non empty doubleLoopStr), p, q being (Polynomial of L)
  st p-q = 0_. L holds p = q
proof
  let L be add-associative right_zeroed right_complementable distributive
  (non empty doubleLoopStr), q, r be (Polynomial of L);
  set PRL = Polynom-Ring L;
  reconsider qc = q, rc = r as Element of PRL by POLYNOM3:def 12;
A1: 0_. L = 0.PRL by POLYNOM3:def 12;
  assume q-r = 0_. L;
  then qc-rc = 0.PRL by A1,Th27;
  hence q = r by VECTSP_1:84;
end;

theorem Th30:
  for L being Abelian add-associative right_zeroed right_complementable
  distributive domRing-like (non empty doubleLoopStr),
  p, q, r being Polynomial of L st p <> 0_. L & p*'q = p*'r holds q = r
proof
  let L be Abelian add-associative right_zeroed right_complementable
  distributive domRing-like (non empty doubleLoopStr),
  p, q, r be Polynomial of L;
  assume
A1: p <> 0_. L;
  assume p*'q = p*'r;
  then p*'q-p*'r = 0_. L by POLYNOM3:30;
  then p*'(q-r) = 0_. L by Th28;
  then q-r = 0_. L by A1,Th23;
  hence q = r by Th29;
end;

theorem Th31:
  for L being domRing, n being Element of NAT, p being Polynomial of L
  st p <> 0_. L holds p`^n <> 0_. L
proof
  let L be domRing, n be Element of NAT, p be Polynomial of L;
  assume
A1: p <> 0_. L;
A2: (1_. L).0 = 1.L & (0_. L).0 = 0.L by FUNCOP_1:13,POLYNOM3:31;
  defpred P[Element of NAT] means p`^$1 <> 0_. L;
A3: P[0] by A2,POLYNOM5:16;
A4: for n being Element of NAT st P[n] holds P[n+1]
  proof
    let n be Element of NAT such that
A5: P[n];
    p`^(n+1) = (p`^n) *' p by POLYNOM5:20;
    hence P[n+1] by A1,A5,Th23;
  end;
  for n being Element of NAT holds P[n] from NAT_1:sch 1(A3,A4);
  hence p`^n <> 0_. L;
end;

theorem Th32:
  for L being comRing, i, j being Element of NAT, p being Polynomial of L
  holds (p`^i) *' (p`^j) = p `^(i+j)
proof
  let L be comRing, i, j being Element of NAT, p be Polynomial of L;
  defpred P[Element of NAT] means (p`^i) *' (p`^$1) = p `^(i+$1);
  (p`^i) *' (p`^0) = (p`^i) *' 1_. L by POLYNOM5:16
    .= (p`^(i+(0 qua Nat))) by POLYNOM3:36;
  then
A1: P[0];
A2: for j being Element of NAT st P[j] holds P[j+1]
  proof
    let j be Element of NAT such that
A3: P[j];
    (p`^i) *' (p`^(j+1)) = (p`^i) *' ((p`^j) *' p) by POLYNOM5:20
      .= (p`^(i+j)) *' p by A3,POLYNOM3:34
      .= p`^(i+j+1) by POLYNOM5:20
      .= p`^(i+(j+1));
    hence P[j+1];
  end;
  for j being Element of NAT holds P[j] from NAT_1:sch 1(A1,A2);
  hence (p`^i) *' (p`^j) = p `^(i+j);
end;

theorem Th33:
  for L being non empty multLoopStr_0 holds 1_.(L) = <%1.L%>
proof
  let L be non empty multLoopStr_0;
A1: dom 0_.(L) = NAT by FUNCT_2:def 1;
  now
    let x be set;
    assume x in NAT;
    then reconsider n = x as Element of NAT;
    per cases;
    suppose
A2:   x = 0;
      hence (1_.(L)).x = 1.L by A1,FUNCT_7:33
        .= <%1.L%>.x by A2,ALGSEQ_1:def 6;
    end;
    suppose
A3:   n <> 0;
      then
A4:   n = 1 or n > 1 by Th1;
      thus (1_.(L)).x = (0_.(L)).n by A3,FUNCT_7:34
        .= 0.L by FUNCOP_1:13
        .= <%1.L%>.x by A4,POLYNOM5:33;
    end;
  end;
  hence 1_.(L) = <%1.L%> by FUNCT_2:18;
end;

theorem
  for L being add-associative right_zeroed right_complementable well-unital
  right-distributive (non empty doubleLoopStr), p being Polynomial of L
  holds p*'<%1.L%> = p
proof
  let L be add-associative right_zeroed right_complementable well-unital
  right-distributive (non empty doubleLoopStr), p being Polynomial of L;
  thus p*'<%1.L%> = p*'1_.(L) by Th33
    .= p by POLYNOM3:36;
end;

theorem Th35:
  for L being add-associative right_zeroed right_complementable distributive
  (non empty doubleLoopStr), p, q being Polynomial of L
  st len p = 0 or len q = 0 holds len (p*'q) = 0
proof
  let L be add-associative right_zeroed right_complementable distributive
  (non empty doubleLoopStr), p, q being Polynomial of L;
  assume
A1: len p = 0 or len q = 0;
  per cases by A1;
  suppose len p = 0;
    then p = 0_. L by POLYNOM4:8;
    then p*'q = 0_. L by POLYNOM4:5;
    hence len (p*'q) = 0 by POLYNOM4:6;
  end;
  suppose len q = 0;
    then q = 0_. L by POLYNOM4:8;
    then p*'q = 0_. L by Th22;
    hence len (p*'q) = 0 by POLYNOM4:6;
  end;
end;

theorem Th36:
  for L being add-associative right_zeroed right_complementable distributive
  (non empty doubleLoopStr), p, q being Polynomial of L
  st p*'q is non-zero holds p is non-zero & q is non-zero
proof
  let L be add-associative right_zeroed right_complementable distributive
  (non empty doubleLoopStr), p, q being Polynomial of L;
  assume that
A1: p*'q is non-zero and
A2: p is non non-zero or q is non non-zero;
  len p <= 0 or len q <= 0 by A2,Th19;
  then len p = 0 or len q = 0;
  then len (p*'q) = 0 by Th35;
  hence thesis by A1,Th19;
end;

theorem
  for L being add-associative right_zeroed right_complementable distributive
  commutative associative well-unital (non empty doubleLoopStr),
  p, q being Polynomial of L
  st p.(len p -'1) * q.(len q -'1) <> 0.L holds 0 < len (p*'q)
proof
  let L be add-associative right_zeroed right_complementable distributive
  commutative associative well-unital (non empty doubleLoopStr),
  p, q being Polynomial of L;
  assume
A1: p.(len p -'1) * q.(len q -'1) <> 0.L;
A2: now
    assume len p <= 0;
    then len p = 0;
    then p = 0_. L by POLYNOM4:8;
    then p.(len p -'1) = 0.L by FUNCOP_1:13;
    hence contradiction by A1,VECTSP_1:39;
  end;
  now
    assume len q <= 0;
    then len q = 0;
    then q = 0_. L by POLYNOM4:8;
    then q.(len q -'1) = 0.L by FUNCOP_1:13;
    hence contradiction by A1,VECTSP_1:36;
  end;
  then 0 qua Nat+1 <= len p & 0 qua Nat+1 <= len q by A2,NAT_1:13;
  then len p + len q >= 1+1 by XREAL_1:9;
  then len p + len q -1 >= 1+1-1 by XREAL_1:11;
  hence thesis by A1,POLYNOM4:13;
end;

theorem Th38:
  for L being add-associative right_zeroed right_complementable distributive
  commutative associative well-unital domRing-like (non empty doubleLoopStr),
  p, q being Polynomial of L st 1 < len p & 1 < len q holds len p < len (p*'q)
proof
  let L be add-associative right_zeroed right_complementable distributive
  commutative associative well-unital domRing-like (non empty doubleLoopStr),
  p, q be Polynomial of L such that
A1: 1 < len p and
A2: 1 < len q;
  p.(len p -'1) <> 0.L & q.(len q -'1)<>0.L by A1,A2,Th20;
  then p.(len p -'1) * q.(len q -'1)<>0.L by VECTSP_2:def 5;
  then
A3: len (p*'q) = len p + len q - 1 by POLYNOM4:13;
  len q - 1 > 1-1 by A2,REAL_1:92;
  then len p + (len q - 1) > 0 qua Nat+len p by XREAL_1:10;
  hence len p < len (p*'q) by A3;
end;

theorem Th39:
  for L being add-associative right_zeroed right_complementable
  left-distributive (non empty doubleLoopStr),
  a, b being Element of L, p being Polynomial of L
  holds (<%a, b%>*'p).0 = a*p.0 &
  for i being Nat holds (<%a, b%>*'p).(i+1) = a*p.(i+1)+b*p.i
proof
  let L be add-associative right_zeroed right_complementable
  left-distributive (non empty doubleLoopStr),
  a, b be Element of L, q be Polynomial of L;
  set p = <%a, b%>;
  consider r being FinSequence of L such that
A1: len r = 0 qua Nat+1 and
A2: p*'q.0 = Sum r and
A3: for k be Element of NAT st k in dom r holds
  r.k = p.(k-'1) * q.(0 qua Nat+1-'k) by POLYNOM3:def 11;
A4: 1 in dom r by A1,FINSEQ_3:27;
  then reconsider r1 = r.1 as Element of L by FINSEQ_2:13;
  r = <*r1*> by A1,FINSEQ_1:57;
  then Sum r = r1 by RLVECT_1:61
    .= p.(1-'1) * q.(0 qua Nat+1-'1) by A3,A4
    .= p.0 * q.(0 qua Nat+1-'1) by BINARITH:51
    .= p.0 * q.0 by BINARITH:39;
  hence (<%a, b%>*'q).0 = a*q.0 by A2,POLYNOM5:39;
  let i be Nat;
  consider r being FinSequence of L such that
A5: len r = (i+1)+1 and
A6: p*'q.(i+1) = Sum r and
A7: for k be Element of NAT st k in dom r
  holds r.k = p.(k-'1) * q.((i+1)+1-'k) by POLYNOM3:def 11;
  len r = i+2 by A5;
  then
A8: 0 qua Nat+2 <= len r by XREAL_1:8;
  then 1 <= len r by XXREAL_0:2;
  then
A9: 1 in dom r by FINSEQ_3:27;
A10: 2 in dom r by A8,FINSEQ_3:27;
A11: r/.1 = r.1 by A9,PARTFUN1:def 8
    .= p.(1-'1) * q.((i+1)+1-'1) by A7,A9
    .= p.0 * q.((i+1)+1-'1) by BINARITH:51
    .= p.0 * q.(i+1) by BINARITH:39
    .= a*q.(i+1) by POLYNOM5:39;
A12: r/.2 = r.2 by A10,PARTFUN1:def 8
    .= p.(1+1-'1) * q.((i+1)+1-'2) by A7,A10
    .= p.1 * q.((i+1)+1-'2) by BINARITH:39
    .= b * q.(i+(1+1)-'2) by POLYNOM5:39
    .= b * q.i by BINARITH:39;
  now
    let k be Element of NAT such that
A13: 2 < k and
A14: k in dom r;
    consider k1 being Nat such that
A15: k = k1+1 by A13,NAT_1:6;
A16: 2 <= k1 by A13,A15,NAT_1:13;
    reconsider k1 as Element of NAT by ORDINAL1:def 13;
    thus r.k = p.(k-'1) * q.((i+1)+1-'k) by A7,A14
      .= p.k1 * q.((i+1)+1-'k) by A15,BINARITH:39
      .= (0.L) * q.((i+1)+1-'k) by A16,POLYNOM5:39
      .= 0.L by VECTSP_1:39;
  end;
  hence (<%a, b%>*'q).(i+1) = a*q.(i+1)+b*q.i by A6,A8,A11,A12,Th3;
end;

theorem Th40:
  for L being add-associative right_zeroed right_complementable distributive
  well-unital commutative associative
  non degenerated (non empty doubleLoopStr),
  r being Element of L, q being non-zero Polynomial of L
  holds len (<%r, 1.L%>*'q) = len q + 1
proof
  let L be add-associative right_zeroed right_complementable distributive
  well-unital commutative associative
  non degenerated (non empty doubleLoopStr),
  r be Element of L, q being non-zero Polynomial of L;
A1: len <%r, 1.L%> = 2 by POLYNOM5:41;
  set p = <%r, 1.L%>;
A2: len q > 0 by Th19;
  p.(len p -'1) * q.(len q -'1) = p.(1+1-'1) * q.(len q -'1) by POLYNOM5:41
    .= p.(1) * q.(len q -'1) by BINARITH:39
    .= 1.L * q.(len q -'1) by POLYNOM5:39
    .= q.(len q -'1) by VECTSP_1:def 19;
  hence len (<%r, 1.L%>*'q) = len q +(1+1)-1 by A1,A2,Th20,POLYNOM4:13
    .= len q +1;
end;

theorem Th41:
  for L being non degenerated comRing, x being Element of L,
  i being Element of NAT holds len (<%x, 1.L%>`^i) = i+1
proof
  let L be non degenerated comRing, x be Element of L;
  defpred P[Element of NAT] means len (<%x, 1.L%>`^$1) = $1+1;
  set r = <%x, 1.L%>;
  r`^0 = 1_. L by POLYNOM5:16;
  then
A1: P[0] by POLYNOM4:7;
A2: for i being Element of NAT st P[i] holds P[i+1]
  proof
    let i be Element of NAT such that
A3: P[i];
    reconsider ri = r`^i as non-zero Polynomial of L by A3,Th19;
    thus len (r`^(i+1)) = len ((r`^1)*'ri) by Th32
      .= len (r*'ri) by POLYNOM5:17
      .= i+1+1 by A3,Th40;
  end;
  thus for i being Element of NAT holds P[i] from NAT_1:sch 1(A1,A2);
end;

registration
  let L be non degenerated comRing, x be Element of L, n be Element of NAT;
  cluster <%x, 1.L%>`^n -> non-zero;
  correctness
  proof len (<%x, 1.L%>`^n) = n+1 by Th41;
    hence thesis by Th19;
  end;
end;

theorem Th42:
  for L being non degenerated comRing, x being Element of L,
  q being non-zero (Polynomial of L), i being Element of NAT
  holds len ((<%x, 1.L%>`^i)*'q) = i + len q
proof
  let L being non degenerated comRing, x being Element of L,
  q being non-zero Polynomial of L;
  set r = <%x, 1.L%>;
  defpred P[Element of NAT] means len ((r`^$1)*'q) = $1 + len q;
  len ((r`^0)*'q) = len ((1_. L)*'q) by POLYNOM5:16
    .= 0 qua Nat+ len q by POLYNOM3:36;
  then
A1: P[0];
A2: for i being Element of NAT st P[i] holds P[i+1]
  proof
    let i be Element of NAT such that
A3: P[i];
    0 <= i & len q > 0 by Th19;
    then i+len q > 0 qua Nat+ (0 qua Nat) by XREAL_1:10;
    then
A4: (r`^i)*'q is non-zero by A3,Th19;
    thus len ((r`^(i+1))*'q) = len ((r`^1)*'(r`^i)*'q) by Th32
      .= len (r*'(r`^i)*'q) by POLYNOM5:17
      .= len (r*'((r`^i)*'q)) by POLYNOM3:34
      .= (i+len q)+1 by A3,A4,Th40
      .= (i+1)+len q;
  end;
  thus for i being Element of NAT holds P[i] from NAT_1:sch 1(A1,A2);
end;

theorem Th43:
  for L being add-associative right_zeroed right_complementable distributive
  well-unital commutative associative
  non degenerated (non empty doubleLoopStr),
  r being Element of L, p, q being Polynomial of L
  st p = <%r, 1.L%>*'q & p.(len p -'1) = 1.L holds q.(len q -'1) = 1.L
proof
  let L be add-associative right_zeroed right_complementable distributive
  well-unital commutative associative
  non degenerated (non empty doubleLoopStr),
  x be Element of L, p, q be Polynomial of L such that
A1: p = <%x, 1.L%>*'q and
A2: p.(len p -'1) = 1.L;
  set lp1 = len p -'1;
A3: now
    assume q = 0_. L;
    then p = 0_. L by A1,POLYNOM3:35;
    hence contradiction by A2,FUNCOP_1:13;
  end;
  then q is non-zero by Def5;
  then len p = len q + 1 by A1,Th40;
  then
A4: lp1 = len q by BINARITH:39;
  len q <> 0 by A3,POLYNOM4:8;
  then consider lp2 being Nat such that
A5: lp1 = lp2+1 by A4,NAT_1:6;
  reconsider lp2 as Element of NAT by ORDINAL1:def 13;
A6: q.lp1 = 0.L by A4,ALGSEQ_1:22;
  (<%x, 1.L%>*'q).lp1 = x*q.(lp1)+(1.L)*q.lp2 by A5,Th39
    .= 0.L +(1.L)*q.lp2 by A6,VECTSP_1:36
    .= (1.L)*q.lp2 by RLVECT_1:10
    .= q.lp2 by VECTSP_1:def 19;
  hence q.(len q -'1) = 1.L by A1,A2,A4,A5,BINARITH:39;
end;

begin :: Little Bezout theorem

definition
  let L be non empty ZeroStr, p be Polynomial of L;
  let n be Nat;
  func poly_shift(p,n) -> Polynomial of L means
  :Def6:
  for i being Nat holds it.i = p.(n + i);
  existence
  proof
    deffunc F(Nat) = p.(n+$1);
    consider ps being AlgSequence of L such that
A1: len ps <= len p and
A2: for k being Nat st k < len p holds ps.k = F(k) from ALGSEQ_1:sch 1;
    take ps;
    let i be Nat;
    per cases;
    suppose i < len p;
      hence ps.i = p.(n + i) by A2;
    end;
    suppose
A3:   i >= len p;
      hence ps.i = 0.L by A1,ALGSEQ_1:22,XXREAL_0:2
        .= p.(n + i) by A3,ALGSEQ_1 :22,NAT_1:12;
    end;
  end;
  uniqueness
  proof
    let it1, it2 be Polynomial of L such that
A4: for i being Nat holds it1.i = p.(n + i) and
A5: for i being Nat holds it2.i = p.(n + i);
    now
      let x be set;
      assume x in NAT;
      then reconsider i = x as Element of NAT;
      thus it1.x = p.(n+i) by A4
        .= it2.x by A5;
    end;
    hence it1 = it2 by FUNCT_2:18;
  end;
end;

theorem Th44:

for L being non empty ZeroStr,p being Polynomial of L holds poly_shift(p,0) = p
proof
  let L be non empty ZeroStr, p be Polynomial of L;
  set ps = poly_shift(p,0);
  now
    let x be set;
    assume x in NAT;
    then reconsider i = x as Element of NAT;
    thus ps.x = p.(0 qua Nat+i) by Def6
      .= p.x;
  end;
  hence poly_shift(p,0) = p by FUNCT_2:18;
end;

theorem Th45:

for L being non empty ZeroStr, n being Element of NAT, p being Polynomial of L
  st n >= len p holds poly_shift(p,n) = 0_. L
proof
  let L be non empty ZeroStr, n be Element of NAT, p be Polynomial of L;
  assume
A1: n >= len p;
  set ps = poly_shift(p,n);
A2: dom ps = NAT by FUNCT_2:def 1;
  now
    let z be set;
    assume z in dom ps;
    then reconsider i = z as Element of NAT;
    thus ps.z = p.(n+i) by Def6
      .= 0.L by A1,ALGSEQ_1:22,NAT_1:12;
  end;
  hence poly_shift(p,n) = 0_. L by A2,FUNCOP_1:17;
end;

theorem Th46:
  for L being non degenerated (non empty multLoopStr_0),
  n being Element of NAT, p being Polynomial of L
  st n <= len p holds len poly_shift(p,n) + n = len p
proof
  let L be non degenerated (non empty multLoopStr_0),
  n be Element of NAT, p be Polynomial of L such that
A1: n <= len p;
  set ps = poly_shift(p,n), lpn = len p - n;
  n-n <= lpn by A1,XREAL_1:11;
  then reconsider lpn as Element of NAT by INT_1:16;
  now
    let i be Nat;
    assume i >= lpn;
    then
A2: i+n >= len p by XREAL_1:22;
    thus ps.i = p.(n+i) by Def6
      .= 0.L by A2,ALGSEQ_1:22;
  end;
  then
A3: lpn is_at_least_length_of ps by ALGSEQ_1:def 3;
  now
    let m be Nat such that
A4: m is_at_least_length_of ps and
A5: lpn > m;
    lpn >= m+1 by A5,NAT_1:13;
    then
A6: lpn -1 >= m +1-1 by XREAL_1:11;
    then reconsider lpn1 = lpn -1 as Element of NAT by INT_1:16;
A7: (n+lpn1)+1 = len p;
A8: ps.lpn1 = p.(n+lpn1) by Def6;
    p.(n+lpn1) <> 0.L by A7,ALGSEQ_1:25;
    hence contradiction by A4,A6,A8,ALGSEQ_1:def 3;
  end;
  hence len poly_shift(p,n) + n = lpn + n by A3,ALGSEQ_1:def 4
    .= len p;
end;

theorem Th47:
  for L being non degenerated comRing,
  x being Element of L, n being Element of NAT, p being Polynomial of L

st n < len p holds eval(poly_shift(p,n),x) = x*eval(poly_shift(p,n+1),x) + p.n
proof
  let L be non degenerated comRing,
  x being Element of L, n be Element of NAT, p being Polynomial of L such that
A1: n < len p;
A2: 1_L = 1.L;
  set ps = poly_shift(p,n), ps1 = poly_shift(p,n+1);
  consider f be FinSequence of L such that
A3: eval(ps,x) = Sum f and
A4: len f = len ps and
A5: for k be Element of NAT st k in dom f
  holds f.k = ps.(k-'1) * (power L).(x,k-'1) by POLYNOM4:def 2;
  consider f1 be FinSequence of L such that
A6: eval(ps1,x) = Sum f1 and
A7: len f1 = len ps1 and
A8: for k be Element of NAT st k in dom f1
  holds f1.k = ps1.(k-'1) * (power L).(x,k-'1) by POLYNOM4:def 2;
A9: x*(Sum f1) = Sum (x*f1) by FVSUM_1:92;
A10: x*f1 = (x multfield)*f1 by FVSUM_1:def 6;
  rng f1 c= the carrier of L &
  dom (x multfield) = the carrier of L by FUNCT_2:def 1;
  then
A11: dom ((x multfield)*f1) = dom f1 by RELAT_1:46;
  now thus len f = len f;
A12: n+1 <= len p by A1,NAT_1:13;
A13: len ps1 +1+n = len ps1 + (n+1)
      .= len p by A12,Th46
      .=
    len ps + n by A1,Th46;
A14: len <*p.n*> = 1 by FINSEQ_1:57;
A15: len ((x*f1)) = len f1 by A10,A11,FINSEQ_3:31;
    hence len (<*p.n*>^(x*f1)) = len f by A4,A7,A13,A14,FINSEQ_1:35;
    let j be Nat such that
A16: j in dom f;
A17: j in dom f by A16;
    then
A18: 1 <= j & j <= len f by FINSEQ_3:27;
    per cases by A18,REAL_1:def 5;
    suppose
A19:  j = 1;
A20:  1 in dom <*p.n*> by A14,FINSEQ_3:27;
      thus f.j = ps.(1-'1) * (power L).(x,1-'1) by A5,A17,A19
        .= ps.0 * (power L).(x,1-'1) by BINARITH:51
        .= ps.0 * (power L).(x,0) by BINARITH:51
        .= ps.0 * 1.L by A2,GROUP_1:def 8
        .= ps.0 by A2,GROUP_1:def 5
        .= p.(n+(0 qua Nat)) by Def6
        .= <*p.n*>.1 by FINSEQ_1:57
        .= (<*p.n*>^(x*f1)).j by A19,A20,FINSEQ_1:def 7;
    end;
    suppose 1 < j;
      then
A21:  1+1 <= j by NAT_1:13;
      1-1 <= j-1 by A18,XREAL_1:11;
      then reconsider j1 = j-1 as Element of NAT by INT_1:16;
A22:  1+1-1 <= j-1 by A21,XREAL_1:11;
      j-1 <= len f1 + 1-1 by A4,A7,A13,A18,XREAL_1:11;
      then
A23:  j1 in dom f1 by A22,FINSEQ_3:27;
      then reconsider f1j = f1.j1 as Element of L by FINSEQ_2:13;
      j = j1+1;
      then
A24:  j1 = j-'1 by BINARITH:39;
      consider j2 being Nat such that
A25:  j1 = j2+1 by A22,NAT_1:6;
A26:  j1-'1+1 = j1 by A25,BINARITH:39;
      thus f.j = ps.(j-'1) * (power L).(x,j-'1) by A5,A17
        .= p.(n+j1) * (power L).(x,j1) by A24,Def6
        .= p.((n+1)+(j1-'1)) * (((power L).(x,j1-'1)) * x) by A26,GROUP_1:def 8
        .= x*(p.((n+1)+(j1-'1)) * (power L).(x,j1-'1)) by GROUP_1:def 4
        .= x*(ps1.(j1-'1) * (power L).(x,j1-'1)) by Def6
        .= x*f1j by A8,A23
        .= (x*f1).j1 by A10,A11,A23,FVSUM_1:62
        .= (<*p.n*>^(x*f1)).j by A4,A7,A13,A14,A15,A18,A21,FINSEQ_1:36;
    end;
  end;
  then f = <*p.n*>^(x*f1) by FINSEQ_2:10;

hence eval(poly_shift(p,n),x) = x*eval(poly_shift(p,n+1),x) + p.n by A3,A6,A9,
  FVSUM_1:89;
end;

theorem Th48:
  for L being non degenerated comRing, p being Polynomial of L
  st len p = 1 holds Roots p = {}
proof
  let L be non degenerated comRing, p be Polynomial of L;
  assume
A1: len p = 1;
  assume Roots p <> {};
  then consider x being set such that
A2: x in Roots p by XBOOLE_0:def 1;
A3: p =<%p.0%> & p.0 <> 0.L by A1,Th21;
  reconsider x as Element of L by A2;
  x is_a_root_of p by A2,POLYNOM5:def 9;
  then eval(p,x) = 0.L by POLYNOM5:def 6;
  hence contradiction by A3,POLYNOM5:38;
end;

definition
  let L be non degenerated comRing, r be Element of L, p be Polynomial of L
  such that
A1: r is_a_root_of p;
  func poly_quotient(p,r) -> Polynomial of L means
  :Def7:
  len it + 1 = len p &
  for i being Nat holds it.i = eval(poly_shift(p, i+1),r) if len p > 0
  otherwise it = 0_. L;
  existence
  proof
    hereby
      assume
A2:   len p > 0;
      then consider p1 being Nat such that
A3:   len p = p1+1 by NAT_1:6;
      set lq = len p -'1;
A4:   lq = p1 by A3,BINARITH:39;
A5:   len p >= 0 qua Nat+1 by A2,NAT_1:13;
      r in Roots p by A1,POLYNOM5:def 9;
      then len p <> 1 by Th48;
      then consider lq1 being Nat such that
A6:   lq = lq1 + 1 by A3,A4,A5,NAT_1:6;
      reconsider lq1 as Element of NAT by ORDINAL1:def 13;
A7:   lq1 = lq -'1 by A6,BINARITH:39;
A8:   lq < len p by A3,A4,NAT_1:13;
      deffunc F(Nat) = eval(poly_shift(p, $1+1),r);
      consider q being sequence of L such that
A9:   for k being Element of NAT holds q.k = F(k) from FUNCT_2:sch 4;
      reconsider q as sequence of L;
      q.lq1 = eval(poly_shift(p, lq1+1),r) by A9
        .= r*eval(poly_shift(p, len p),r) + p.lq by A3,A4,A6,A8,Th47
        .= r*eval(0_. L,r) + p.lq by Th45
        .= r*0.L + p.lq by POLYNOM4:20
        .= 0.L + p.lq by VECTSP_1:36
        .= p.lq by RLVECT_1:10;
      then
A10:  q.lq1 <> 0.L by A3,A4,ALGSEQ_1:25;
A11:  now
        let i be Nat such that
A12:    i >= lq;
        i >= p1 by A3,A12,BINARITH:39;
        then
A13:    i+1 >= len p by A3,XREAL_1:8;
        i in NAT by ORDINAL1:def 13;
        hence q.i = eval(poly_shift(p, i+1),r) by A9
          .= eval(0_.L,r) by A13,Th45
          .= 0.L by POLYNOM4:20;
      end;
      then reconsider q as AlgSequence of L by ALGSEQ_1:def 2;
      take q;
A14:  lq is_at_least_length_of q by A11,ALGSEQ_1:def 3;
      now
        let m be Nat;
        assume
A15:    m is_at_least_length_of q;
        assume
A16:    lq > m;
        then consider lq1 being Nat such that
A17:    lq = lq1 + 1 by NAT_1:6;
        lq1 >= m by A16,A17,NAT_1:13;
        then lq -'1 >= m by A17,BINARITH:39;
        hence contradiction by A7,A10,A15,ALGSEQ_1:def 3;
      end;
      hence len q + 1 =p1+1-'1+1 by A3,A14,ALGSEQ_1:def 4
        .=len p by A3,
      BINARITH:39;
      let k be Nat;
      k in NAT by ORDINAL1:def 13;
      hence q.k = F(k) by A9;
    end;
    thus thesis;
  end;
  uniqueness
  proof
    let it1, it2 be Polynomial of L;
    hereby
      assume len p > 0;
      assume that
A18:  len it1 + 1 = len p &
      for i being Nat holds it1.i = eval(poly_shift(p, i+1),r) and
A19:  len it2 + 1 = len p &
      for i being Nat holds it2.i = eval(poly_shift(p, i+1),r);
      now
        let k be Nat such that k < len it1;
        thus it1.k = eval(poly_shift(p, k+1),r) by A18
          .= it2.k by A19;
      end;
      hence it1 = it2 by A18,A19,ALGSEQ_1:28;
    end;
    thus thesis;
  end;
  consistency;
end;

theorem Th49:
  for L being non degenerated comRing,
  r being Element of L, p being non-zero Polynomial of L
  st r is_a_root_of p holds len poly_quotient(p,r) > 0
proof
  let L be non degenerated comRing,
  r be Element of L, p be non-zero Polynomial of L such that
A1: r is_a_root_of p;
  len p > 0 by Th19;
  then
A2: len poly_quotient(p,r) + 1 = len p by A1,Def7;
  assume len poly_quotient(p,r) <= 0;
  then len poly_quotient(p,r) = 0;
  then Roots p = {} by A2,Th48;
  hence contradiction by A1,POLYNOM5:def 9;
end;

theorem Th50:
  for L being add-associative right_zeroed right_complementable
  left-distributive well-unital (non empty doubleLoopStr),
  x being Element of L holds Roots <%-x, 1.L%> = {x}
proof
  let L be add-associative right_zeroed right_complementable
  left-distributive well-unital (non empty doubleLoopStr), x be Element of L;
  now
    let a be set;
    hereby
      assume
A1:   a in Roots <%-x, 1.L%>;
      then reconsider b = a as Element of L;
      b is_a_root_of <%-x, 1.L%> by A1,POLYNOM5:def 9;
      then 0.L = eval(<%-x, 1.L%>,b) by POLYNOM5:def 6
        .= -x + b by POLYNOM5:48;
      then -x = -b by RLVECT_1:19;
      hence x = a by RLVECT_1:31;
    end;
    assume
A2: a = x;
    eval(<%-x, 1.L%>,x) = -x + x by POLYNOM5:48
      .= 0.L by RLVECT_1:16;
    then x is_a_root_of <%-x, 1.L%> by POLYNOM5:def 6;
    hence a in Roots <%-x, 1.L%> by A2,POLYNOM5:def 9;
  end;
  hence Roots <%-x, 1.L%> = {x} by TARSKI:def 1;
end;

theorem Th51:
  for L being non trivial comRing,
  x being Element of L, p, q being Polynomial of L
  st p = <%-x,1.L%>*'q holds x is_a_root_of p
proof
  let L be non trivial comRing,
  x be Element of L, p, q be Polynomial of L such that
A1: p = <%-x,1.L%>*'q;
A2: eval(<%-x,1.L%>,x) = (-x)+x by POLYNOM5:48
    .= 0.L by RLVECT_1:16;
  thus eval(p,x) = eval(<%-x,1.L%>,x) * eval(q,x) by A1,POLYNOM4:27
    .= 0.L by A2,VECTSP_1:39;
end;

theorem Th52: :: Factor theorem (Bezout)
  for L being non degenerated comRing,
  r being Element of L, p being Polynomial of L
  st r is_a_root_of p holds p = <%-r,1.L%>*'poly_quotient(p,r)
proof
  let L be non degenerated comRing, x be Element of L, p be Polynomial of L;
  assume that
A1: x is_a_root_of p;
  set r = <%-x,1.L%>, pq = poly_quotient(p,x);
  per cases;
  suppose
A2: len p > 0;
    then p is non-zero by Th19;
    then
A3: len pq > 0 by A1,Th49;
    r.(len r -'1) = r.(1+1-'1) by POLYNOM5:41
      .= r.1 by BINARITH:39
      .= 1.L by POLYNOM5:39;
    then
A4: r.(len r -'1) * pq.(len pq -'1) = pq.(len pq -'1) by VECTSP_1:def 19;
    now len (r *' pq) = len r + len pq - 1 by A3,A4,Th20,POLYNOM4:13
        .= len pq +(1+1)-1 by POLYNOM5:41
        .= len pq +1
        .= len p by A1,A2,Def7;
      hence len p = len (r *' pq);
      let k be Nat;
      assume k < len p;
      defpred P[Nat] means p.$1 = (r*'pq).$1;
A5:   (r*'pq).0 = (-x)*pq.0 by Th39
        .= (-x)*eval(poly_shift(p, 0 qua Nat+1),x) by A1,A2,Def7;
A6:   0.L = eval(p,x) by A1,POLYNOM5:def 6
        .= eval(poly_shift(p,0),x) by Th44
        .= x*eval(poly_shift(p,0 qua Nat+1),x) + p.0 by A2,Th47;
      (-x)*eval(poly_shift(p, 0 qua Nat+1),x)
      = (-x)*eval(poly_shift(p, 0 qua Nat+1),x) + 0.L by RLVECT_1:def 7
        .= (-x)*eval(poly_shift(p, 0 qua Nat+1),x) +
      x*eval(poly_shift(p,1),x) + p.0 by A6,RLVECT_1:def 6

.= -x*eval(poly_shift(p, 0 qua Nat+1),x) + x*eval(poly_shift(p,1),x) + p.0
      by VECTSP_1:41
        .= 0.L +p.0 by RLVECT_1:16
        .= p.0 by RLVECT_1:10;
      then
A7:   P[0] by A5;
A8:   for k being Nat st P[k] holds P[k+1]
      proof
        let k be Nat;
        assume P[k];
A9:     pq.(k+1) = eval(poly_shift(p, k+1+1),x) by A1,A2,Def7;
A10:    pq.k = eval(poly_shift(p, k+1),x) by A1,A2,Def7;
        per cases;
        suppose
A11:      k+1 >= len p;
          then
A12:      pq.k = eval(0_.L,x) by A10,Th45
            .= 0.L by POLYNOM4:20;
A13:      pq.(k+1) = eval(0_.L,x) by A9,A11,Th45,NAT_1:12
            .= 0.L by POLYNOM4:
          20;
          (r*'pq).(k+1) = (-x)*pq.(k+1)+(1.L)*pq.k by Th39
            .= 0.L + (1.L)*pq.k by A13,VECTSP_1:36
            .= 0.L + 0.L by A12,VECTSP_1:36
            .= 0.L by RLVECT_1:10;
          hence P[k+1] by A11,ALGSEQ_1:22;
        end;
        suppose k+1 < len p;
          then pq.k = x*eval(poly_shift(p, k+1+1),x) + p.(k+1) by A10,Th47;
          then
A14:      -x*pq.(k+1)+pq.k

= -x*pq.(k+1)+x*eval(poly_shift(p, k+1+1),x)+p.(k+1) by RLVECT_1:def 6
            .= 0.L + p.(k+1) by A9,RLVECT_1:16;
          (r*'pq).(k+1) = (-x)*pq.(k+1)+(1.L)*pq.k by Th39
            .= (-x)*pq.(k+1)+pq.k by VECTSP_1:def 19
            .= -x*pq.(k+1)+pq.k by VECTSP_1:41;
          hence P[k+1] by A14,RLVECT_1:10;
        end;
      end;
      for k being Nat holds P[k] from NAT_1:sch 2(A7,A8);
      hence p.k = (r*'pq).k;
    end;
    hence p = r*'pq by ALGSEQ_1:28;
  end;
  suppose len p = 0;
    then pq = 0_. L & p = 0_. L by A1,Def7,POLYNOM4:8;
    hence thesis by POLYNOM3:35;
  end;
end;

theorem :: Factor theorem (Bezout)
  for L being non degenerated comRing,
  r being Element of L, p, q being Polynomial of L
  st p = <%-r,1.L%>*'q holds r is_a_root_of p
proof
  let L be non degenerated comRing,
  r be Element of L, p, q be Polynomial of L;
  assume p = <%-r,1.L%>*'q;
  then eval(p,r) = eval(<%-r,1.L%>,r) * eval(q,r) by POLYNOM4:27
    .= (-r+r) * eval(q,r) by POLYNOM5:48
    .= 0.L * eval(q,r) by RLVECT_1:def 11
    .= 0.L by VECTSP_1:39;
  hence thesis by POLYNOM5:def 6;
end;

Lm1: now
  let L be domRing, p be non-zero Polynomial of L;
  p <> 0_. L by Def5;
  then len p <> 0 by POLYNOM4:8;
  then len p > 0;
  then
A1: len p >= 0 qua Nat+1 by NAT_1:13;
  defpred P[Nat] means for p being Polynomial of L st len p = $1 holds
  Roots p is finite &
  ex n being Element of NAT st n = Card Roots p & n < len p;
A2: P[1]
  proof
    let p be Polynomial of L;
    assume
A3: len p = 1;
    hence Roots p is finite by Th48;
    take 0; thus 0 = Card Roots p by A3,Th48,CARD_1:78; thus 0 < len p by A3;
  end;
A4: for n being Nat st n>=1 & P[n] holds P[n+1]
  proof
    let n be Nat such that n >= 1 and
A5: P[n];
    let p be Polynomial of L;
    assume
A6: len p = n+1;
    per cases;
    suppose p is with_roots;
      then consider x being Element of L such that
A7:   x is_a_root_of p by POLYNOM5:def 7;
A8:   p = <%-x,1.L%>*'poly_quotient(p,x) by A7,Th52;
      set r = <%-x,1.L%>, pq = poly_quotient(p,x);
A9:   len pq + 1 = len p by A6,A7,Def7;
      then
A10:  Roots pq is finite by A5,A6;
A11:  Roots r = {x} by Th50;
      Roots p = (Roots r)\/Roots pq by A8,Th25;
      hence Roots p is finite by A10,A11,FINSET_1:14;
      consider k being Element of NAT such that
A12:  k = Card Roots pq and
A13:  k < len pq by A5,A6,A9;
      reconsider Rpq = Roots pq as finite set by A5,A6,A9;
      reconsider Rr = Roots r as finite set by A11;
      reconsider Rp = Rpq \/ Rr as finite set;
      take m = card Rp; thus m = Card Roots p by A8,Th25;
      card Rr = 1 by A11,CARD_1:79;
      then
A14:  card Rp <= k + 1 by A12,CARD_2:62;
      k+1 < n+1 by A6,A9,A13,XREAL_1:10;
      hence m < len p by A6,A14,XXREAL_0:2;
    end;
    suppose
A15:  not p is with_roots;
A16:  now
        assume Roots p <> {};
        then consider x being set such that
A17:    x in Roots p by XBOOLE_0:def 1;
        reconsider x as Element of L by A17;
        x is_a_root_of p by A17,POLYNOM5:def 9;
        hence contradiction by A15,POLYNOM5:def 7;
      end;
      hence Roots p is finite;
      take 0; thus 0 = Card Roots p by A16,CARD_1:78;
      thus 0 < len p by A6;
    end;
  end;
  for n being Nat st n >= 1 holds P[n] from NAT_1:sch 8(A2,A4);
  hence Roots p is finite &
  ex n being Element of NAT st n = Card Roots p & n < len p by A1;
end;

begin :: Polynomials defined by roots

registration  :: It is not true for a comRing. Who knows an example?
  let L be domRing, p be non-zero Polynomial of L;
  cluster Roots p -> finite;
  correctness by Lm1;
end;

definition
  let L be non degenerated comRing, x be Element of L,
  p be non-zero (Polynomial of L);
  func multiplicity(p,x) -> Element of NAT means
  :Def8:
  ex F being finite non empty Subset of NAT
  st F = {k where k is Element of NAT : ex q being Polynomial of L
  st p = (<%-x, 1.L%>`^k) *' q} & it = max F;
  existence
  proof
A1: len p > 0 by Th19;
    set r = <%-x, 1.L%>;
    defpred P[Element of NAT] means
    ex q being Polynomial of L st p = (r`^$1) *' q;
    set F = {k where k is Element of NAT : P[k]};
    p = (1_. L) *' p by POLYNOM3:36
      .= (r`^0) *' p by POLYNOM5:16;
    then
A2: 0 in F;
A3: F c= len p
    proof
      let a be set;
      assume a in F;
      then consider k being Element of NAT such that
A4:   a = k and
A5:   P[k];
      consider q being Polynomial of L such that
A6:   p = (r`^k) *' q by A5;
      now
        assume len q = 0;
        then q = 0_. L by POLYNOM4:8;
        then p = 0_. L by A6,POLYNOM4:5;
        hence contradiction by A1,POLYNOM4:6;
      end;
      then
A7:   len q > 0;
      then reconsider q as non-zero Polynomial of L by Th19;
      now
        assume k >= len p;
        then k+len q > len p + (0 qua Nat) by A7,XREAL_1:10;
        hence contradiction by A6,Th42;
      end;
      then k in {i where i is Element of NAT : i < len p};
      hence a in len p by A4,AXIOMS:30;
    end;
    F c= NAT from FRAENKEL:sch 10;
    then reconsider F as finite non empty Subset of NAT by A2,A3,FINSET_1:13;
    reconsider FF = F as finite non empty natural-membered set;
    reconsider m = max FF as Element of NAT by ORDINAL1:def 13;
    take m; thus thesis;
  end;
  uniqueness;
end;

theorem Th54:
  for L being non degenerated comRing,
  p being non-zero (Polynomial of L), x being Element of L
  holds x is_a_root_of p iff multiplicity(p,x) >= 1
proof
  let L be non degenerated comRing,
  p being non-zero (Polynomial of L), x being Element of L;
  set r = <%-x, 1.L%>;
  set m = multiplicity(p,x);
  consider F being finite non empty Subset of NAT such that
A1: F =
  {k where k is Element of NAT : ex q being Polynomial of L st p = (r`^k) *' q}
  and
A2: m = max F by Def8;
  hereby
    assume x is_a_root_of p;
    then
A3: p = r*'poly_quotient(p,x) by Th52;
    r`^1 = r by POLYNOM5:17;
    then 1 in F by A1,A3;
    hence multiplicity(p,x) >= 1 by A2,PRE_CIRC:def 1;
  end;
  assume
A4: multiplicity(p,x) >= 1;
  m in F by A2,PRE_CIRC:def 1;
  then consider k being Element of NAT such that
A5: m = k and
A6: ex q being Polynomial of L st p = (r`^k) *' q by A1;
  consider q being Polynomial of L such that
A7: p = (r`^k) *' q by A6;
  consider k1 being Nat such that
A8: k = k1+1 by A4,A5,NAT_1:6;
  reconsider k1 as Element of NAT by ORDINAL1:def 13;
  p = r *' (r`^k1) *' q by A7,A8,POLYNOM5:20
    .= r *' ((r`^k1) *' q) by POLYNOM3:34;
  hence x is_a_root_of p by Th51;
end;

theorem Th55:
  for L being non degenerated comRing,
  x being Element of L holds multiplicity(<%-x, 1.L%>,x) = 1
proof
  let L be non degenerated comRing, x be Element of L;
  set r = <%-x, 1.L%>;
A1: len r = 2 by POLYNOM5:41;
  consider F being finite non empty Subset of NAT such that
A2: F =
  {k where k is Element of NAT : ex q being Polynomial of L st r = (r`^k) *' q}
  and
A3: multiplicity(r,x) = max F by Def8;
  r = (r`^1) by POLYNOM5:17;
  then r = (r`^1) *' 1_. L by POLYNOM3:36;
  then 1 in F by A2;
  then
A4: multiplicity(r,x) >= 1 by A3,PRE_CIRC:def 1;
  set j = multiplicity(r,x);
  j in F by A3,PRE_CIRC:def 1;
  then consider k being Element of NAT such that
A5: k = j and
A6: ex q being Polynomial of L st r = (r`^k) *' q by A2;
  consider q being Polynomial of L such that
A7: r = (r`^k) *' q by A6;
  now
    assume len q = 0;
    then q = 0_. L by POLYNOM4:8;
    then r = 0_. L by A7,POLYNOM4:5;
    hence contradiction by A1,POLYNOM4:6;
  end;
  then
A8: len q > 0;
  then
A9: q is non-zero by Th19;
  now
    assume k > 1;
    then k >= 1+1 by NAT_1:13;
    then k+len q > 2+(0 qua Nat) by A8,XREAL_1:10;
    hence contradiction by A1,A7,A9,Th42;
  end;
  hence multiplicity(<%-x, 1.L%>,x) = 1 by A4,A5,REAL_1:def 5;
end;

definition
  let L be domRing, p be non-zero Polynomial of L;
  func BRoots(p) -> bag of the carrier of L means
  :Def9:
  support it = Roots p &
  for x being Element of L holds it.x = multiplicity(p,x);
  existence
  proof
    deffunc F(Element of L) = multiplicity(p,$1);
    consider b being Function of the carrier of L, NAT such that
A1: for x being Element of L holds b.x = F(x) from FUNCT_2:sch 4;
A2: dom b = the carrier of L by FUNCT_2:def 1;
    then
A3: support b c= the carrier of L by POLYNOM1:41;
A4: now
      let x be set;
      hereby
        assume
A5:     x in support b;
        then
A6:     b.x <> 0 by POLYNOM1:def 7;
        reconsider xx = x as Element of L by A3,A5;
A7:     b.x = F(xx) by A1;
        0 < b.xx by A6;
        then b.xx >= 0 qua Nat+1 by NAT_1:13;
        then xx is_a_root_of p by A7, Th54;
        hence x in Roots p by POLYNOM5:def 9;
      end;
      assume
A8:   x in Roots p;
      then reconsider xx = x as Element of L;
      xx is_a_root_of p by A8, POLYNOM5:def 9;
      then multiplicity(p,xx) >= 1 by Th54;
      then b.xx >= 1 by A1;
      hence x in support b by POLYNOM1:def 7;
    end;
    then support b = Roots p by TARSKI:2;
    then reconsider b as bag of the carrier of L by A2,PBOOLE:def 3
    ,POLYNOM1:def 8;
    take b; thus thesis by A1,A4,TARSKI:2;
  end;
  uniqueness
  proof
    let it1, it2 be bag of the carrier of L such that
    support it1 = Roots p and
A9: for x being Element of L holds it1.x = multiplicity(p,x) and
    support it2 = Roots p and
A10: for x being Element of L holds it2.x = multiplicity(p,x);
    now
      let x be set;
      assume x in the carrier of L;
      then reconsider xx = x as Element of L;
      thus it1.x = multiplicity(p,xx) by A9
        .= it2.x by A10;
    end;
    hence it1 = it2 by PBOOLE:3;
  end;
end;

theorem Th56:
  for L being domRing, x being Element of L
  holds BRoots <%-x, 1.L%> = ({x}, 1)-bag
proof
  let L be domRing, x be Element of L;
  set r = <%-x, 1.L%>;
  Roots r = {x} by Th50;
  then
A1: support BRoots r = {x} by Def9;
A2: x in {x} by TARSKI:def 1;
  now
    let i be set;
    assume i in the carrier of L;
    then reconsider i1 = i as Element of L;
    per cases;
    suppose
A3:   i = x;
      thus (BRoots r).i = multiplicity(r,i1) by Def9
        .= 1 by A3,Th55
        .= (({x}, 1)-bag).i by A2,A3,Th9;
    end;
    suppose i <> x;
      then
A4:   not i in {x} by TARSKI:def 1;
      hence (BRoots r).i = 0 by A1,POLYNOM1:def 7
        .= (({x}, 1)-bag).i by A4,Th8;
    end;
  end;
  hence BRoots <%-x, 1.L%> = ({x}, 1)-bag by PBOOLE:3;
end;

theorem Th57:
  for L being domRing, x be Element of L, p, q being non-zero Polynomial of L
  holds multiplicity(p*'q,x) = multiplicity(p,x) + multiplicity(q,x)
proof
  let L be domRing,x be Element of L, p, q being non-zero Polynomial of L;
  set r = <%-x, 1.L%>;
  consider F being finite non empty Subset of NAT such that
A1: F = {k where k is Element of NAT : ex pqq being Polynomial of L
  st p*'q = (r`^k) *' pqq} and
A2: multiplicity(p*'q,x) = max F by Def8;
  consider f being finite non empty Subset of NAT such that
A3: f = {k where k is Element of NAT : ex pq being Polynomial of L
  st p = (r`^k) *' pq} and
A4: multiplicity(p,x) = max f by Def8;
  consider g being finite non empty Subset of NAT such that
A5: g = {k where k is Element of NAT : ex qq being Polynomial of L
  st q = (r`^k) *' qq} and
A6: multiplicity(q,x) = max g by Def8;
  max F in F by PRE_CIRC:def 1;
  then consider k being Element of NAT such that
A7: k = max F and
A8: ex pqq being Polynomial of L st p*'q = (r`^k) *' pqq by A1;
  consider pqq being Polynomial of L such that
A9: p*'q = (r`^k) *' pqq by A8;
  max f in f by PRE_CIRC:def 1;
  then consider i being Element of NAT such that
A10: i = max f and
A11: ex pq being Polynomial of L st p = (r`^i) *' pq by A3;
  consider pq being Polynomial of L such that
A12: p = (r`^i) *' pq by A11;
  max g in g by PRE_CIRC:def 1;
  then consider j being Element of NAT such that
A13: j = max g and
A14: ex qq being Polynomial of L st q = (r`^j) *' qq by A5;
  consider qq being Polynomial of L such that
A15: q = (r`^j) *' qq by A14;
A16: p*'q = (r`^i) *' pq *' (r`^j) *' qq by A12,A15,POLYNOM3:34
    .= (r`^i) *' (r`^j) *' pq *' qq by POLYNOM3:34
    .= (r`^(i+j)) *' pq *' qq by Th32
    .= (r`^(i+j)) *' (pq *' qq) by POLYNOM3:34;
  then i+j in F by A1;
  then
A17: i+j <= k by A7,PRE_CIRC:def 1;
  now
    assume i+j < k;
    then 0 qua Nat+(i+j) < k;
    then
A18: 0 < k-(i+j) by XREAL_1:22;
    then reconsider kij = k-(i+j) as Element of NAT by INT_1:16;
    consider kk being Nat such that
A19: kij = kk+1 by A18,NAT_1:6;
    reconsider kk as Element of NAT by ORDINAL1:def 13;
    (0_. L).1 = 0.L & r.1 = 1.L by FUNCOP_1:13,POLYNOM5:39;
    then
A20: r`^(i+j) <> 0_. L by Th31;
    k = kij + (i+j);
    then
A21: p*'q = ((r`^(i+j)) *' (r`^kij)) *' pqq by A9,Th32
      .= (r`^(i+j)) *' ((r`^kij) *' pqq) by POLYNOM3:34;
    (r`^kij) = (r`^1) *' (r`^kk) by A19,Th32
      .= r *' (r`^kk) by POLYNOM5:17;
    then (r`^kij) *' pqq = r *' ((r`^kk) *' pqq) by POLYNOM3:34;
    then x is_a_root_of (pq *' qq) by A16,A20,A21,Th30,Th51;
    then x in Roots (pq *' qq) by POLYNOM5:def 9;
    then
A22: x in (Roots pq \/ Roots qq) by Th25;
    per cases by A22,XBOOLE_0:def 2;
    suppose x in Roots(pq);
      then x is_a_root_of pq by POLYNOM5:def 9;
      then pq = r *' poly_quotient(pq,x) by Th52;
      then p = (r`^i) *' r *' poly_quotient(pq,x) by A12,POLYNOM3:34
        .= (r`^i) *' (r`^1) *' poly_quotient(pq,x) by POLYNOM5:17
        .= (r`^(i+1)) *' poly_quotient(pq,x) by Th32;
      then i+1 in f by A3;
      then i+1 <= i by A10,PRE_CIRC:def 1;
      hence contradiction by NAT_1:13;
    end;
    suppose x in Roots(qq);
      then x is_a_root_of qq by POLYNOM5:def 9;
      then qq = r *' poly_quotient(qq,x) by Th52;
      then q = (r`^j) *' r *' poly_quotient(qq,x) by A15,POLYNOM3:34
        .= (r`^j) *' (r`^1) *' poly_quotient(qq,x) by POLYNOM5:17
        .= (r`^(j+1)) *' poly_quotient(qq,x) by Th32;
      then j+1 in g by A5;
      then j+1 <= j by A13,PRE_CIRC:def 1;
      hence contradiction by NAT_1:13;
    end;
  end;
  hence multiplicity(p*'q,x) = multiplicity(p,x) + multiplicity(q,x)
  by A2,A4,A6,A7,A10,A13,A17,REAL_1:def 5;
end;

theorem Th58:
  for L being domRing, p, q being non-zero Polynomial of L
  holds BRoots(p*'q) = BRoots(p) + BRoots(q)
proof
  let L be domRing, p, q being non-zero Polynomial of L;
  now
    let i be set;
    assume i in the carrier of L;
    then reconsider x = i as Element of L;
    thus (BRoots(p*'q)).i = multiplicity(p*'q, x) by Def9
      .= multiplicity(p,x) + multiplicity(q,x) by Th57
      .= (BRoots p).i + multiplicity(q,x) by Def9
      .= (BRoots p).i + (BRoots q).i by Def9
      .= (BRoots(p) + BRoots(q)).i by POLYNOM1:def 5;
  end;
  hence BRoots(p*'q) = BRoots(p) + BRoots(q) by PBOOLE:3;
end;

Lm2: now
  let L be domRing, p, q be non-zero Polynomial of L;
  BRoots(p*'q) = BRoots(p) + BRoots(q) by Th58;
  hence degree BRoots (p*'q) = degree (BRoots p) + degree BRoots q by Th17;
end;

theorem Th59:
  for L being domRing, p being non-zero Polynomial of L
  st len p = 1 holds degree BRoots p = 0
proof
  let L be domRing, p being non-zero Polynomial of L;
  assume len p = 1;
  then Roots p = {} by Th48;
  then support BRoots p = {} by Def9;
  then BRoots p = EmptyBag the carrier of L by BAGORDER:20;
  hence degree BRoots p = 0 by Th13;
end;

theorem Th60:
  for L being domRing, x be Element of L, n being Element of NAT
  holds degree BRoots (<%-x, 1.L%>`^n) = n
proof
  let L be domRing, x be Element of L;
  set r = <%-x, 1.L%>;
  defpred P[Element of NAT] means degree BRoots (r`^$1) = $1;
A1: len 1_. L = 1 by POLYNOM4:7;
  r`^0 = 1_. L by POLYNOM5:16;
  then
A2: P[0] by A1,Th59;
A3: for n being Element of NAT st P[n] holds P[n+1]
  proof
    let n be Element of NAT such that
A4: P[n];
A5: card {x} = 1 & support ({x},1)-bag = {x} by Th10,CARD_1:79;
    r`^(n+1) = (r`^n)*'r by POLYNOM5:20;
    then degree BRoots(r`^(n+1))
    = degree BRoots (r`^n) + degree BRoots r by Lm2
      .= n + degree ({x},1)-bag by A4,Th56;
    hence P[n+1] by A5,Th15;
  end;
  thus for n being Element of NAT holds P[n] from NAT_1:sch 1(A2,A3);
end;

theorem
  for L being algebraic-closed domRing, p being non-zero Polynomial of L
  holds degree BRoots p = len p -' 1
proof
  let L be algebraic-closed domRing, p be non-zero Polynomial of L;
A1: len p > 0 by Th19;
  defpred P[Nat] means
  for p being non-zero Polynomial of L st len p = $1 & $1 > 0
  holds degree BRoots p = len p -' 1;
A2: for k being Nat st for n being Nat st n < k holds P[n] holds P[k]
  proof
    let k be Nat;
    assume
A3: for n being Nat st n < k holds P[n];
    let p be non-zero Polynomial of L;
    assume that
A4: len p = k and
A5: k > 0;
A6: k >= 0 qua Nat+1 by A5,NAT_1:13;
    thus thesis
    proof per cases by A6,REAL_1:def 5;
      suppose
A7:     k = 1;
        hence degree BRoots p = 1-1 by A4,Th59
          .= len p -' 1 by A4,A7,BINARITH:50;
      end;
      suppose
A8:     k > 1;
        then p is with_roots by A4,POLYNOM5:def 8;
        then consider x being Element of L such that
A9:     x is_a_root_of p by POLYNOM5:def 7;
A10:    multiplicity(p,x) >= 1 by A9,Th54;
        consider F being finite non empty Subset of NAT such that
A11:    F = {l where l is Element of NAT : ex q being Polynomial of L
        st p = (<%-x, 1.L%>`^l) *' q} and
A12:    multiplicity(p,x) = max F by Def8;
        max F in F by PRE_CIRC:def 1;
        then consider l being Element of NAT such that
A13:    l = max F and
A14:    ex q being Polynomial of L st p = (<%-x, 1.L%>`^l) *' q by A11;
        consider q being Polynomial of L such that
A15:    p = (<%-x, 1.L%>`^l) *' q by A14;
        set r = <%-x, 1.L%>;
        set rr = <%-x, 1.L%>`^l;
        reconsider q as non-zero Polynomial of L by A15,Th36;
        len q > 0 by Th19;
        then
A16:    len q >= 0 qua Nat+1 by NAT_1:13;
        thus thesis
        proof
A17:      len r = 2 by POLYNOM5:41;
          then
A18:      len rr = l*2 -l+1 by POLYNOM5:24;
A19:      l*2 -l+1 = l+1;
A20:      len rr > 1 by A10,A12,A13,A18,NAT_1:13;
          len rr > 0 & len q > 0 by Th19;
          then rr.(len rr -'1) <> 0.L & q.(len q -'1) <> 0.L by Th20;
          then
A21:      rr.(len rr -'1) * q.(len q -'1) <> 0.L by VECTSP_2:def 5;
          per cases by A16,REAL_1:def 5;
          suppose
A22:        len q = 1;
A23:        len p = len rr + len q -1 by A15,A21,POLYNOM4:13
              .= len rr by A22;
            thus degree BRoots p
            = degree (BRoots rr) + degree BRoots q by A15,Lm2
              .= degree (BRoots rr) + (0 qua Nat) by A22,Th59
              .= 2*l-l+1-1 by Th60
              .= len p -' 1 by A4,A6,A18,A23,BINARITH:50;
          end;
          suppose
A24:        len q > 1;
            then
A25:        degree BRoots rr = l+1 -' 1 &
            degree BRoots q = len q -' 1 by A3,A4,A15,A18,A20,Th38;
            thus degree BRoots p
            = degree (BRoots rr) + degree BRoots q by A15,Lm2
              .= len rr-'1 + (len q -'1) by A17,A19,A25,POLYNOM5:24
              .= len rr-1 + (len q -'1) by A20,BINARITH:50
              .= len rr-1 + (len q -1) by A24,BINARITH:50
              .= len rr + len q -1 -1
              .= len p -1 by A15,A21,POLYNOM4:13
              .= len p -' 1 by A4,A8,BINARITH:50;
          end;
        end;
      end;
    end;
  end;
  for n being Nat holds P[n] from NAT_1:sch 4(A2);
  hence degree BRoots p = len p -' 1 by A1;
end;

definition
  let L be add-associative right_zeroed right_complementable distributive
  (non empty doubleLoopStr), c be Element of L, n be Element of NAT;
  func fpoly_mult_root(c,n) -> FinSequence of Polynom-Ring L means
  :Def10:
  len it = n &
  for i being Element of NAT st i in dom it holds it.i = <% -c, 1.L%>;
  existence
  proof
    <% -c, 1.L%> is Element of Polynom-Ring L by POLYNOM3:def 12;
    then reconsider f = n |-> <% -c, 1.L%>
    as FinSequence of Polynom-Ring L by FINSEQ_2:77;
    take f; thus
A1: len f = n by FINSEQ_2:69;
    let i be Element of NAT;
    assume i in dom f;
    then i in Seg n by A1,FINSEQ_1:def 3;
    hence f.i = <% -c, 1.L%> by FUNCOP_1:13;
  end;
  uniqueness
  proof
    let it1, it2 be FinSequence of Polynom-Ring L such that
A2: len it1 = n and
A3: for i being Element of NAT st i in dom it1 holds it1.i = <% -c, 1.L%> and
A4: len it2 = n and
A5: for i being Element of NAT st i in dom it2 holds it2.i = <% -c, 1.L%>;
A6: dom it1 = dom it2 by A2,A4,FINSEQ_3:31;
    now
      let x be Nat;
      assume
A7:   x in dom it1;
      hence it1.x = <% -c, 1.L%> by A3
        .= it2.x by A5,A6,A7;
    end;
    hence it1 = it2 by A6,FINSEQ_1:17;
  end;
end;

definition
  let L be add-associative right_zeroed right_complementable distributive
  (non empty doubleLoopStr), b be bag of the carrier of L;
  func poly_with_roots(b) -> Polynomial of L means
  :Def11:
  ex f being FinSequence of (the carrier of Polynom-Ring L)*,
  s being FinSequence of L st len f = card support b & s = canFS(support b) &
  (for i being Element of NAT st i in dom f
  holds f.i = fpoly_mult_root(s/.i,b.(s/.i))) & it = Product FlattenSeq f;
  existence
  proof
    support b c= dom b & dom b = the carrier of L by PBOOLE:def 3,POLYNOM1:41;
    then rng canFS(support b) c= the carrier of L by XBOOLE_1:1;
    then reconsider s = canFS(support b) as FinSequence of L by FINSEQ_1:def 4;
    deffunc F(set) = fpoly_mult_root(s/.$1,b.(s/.$1));
    consider f being FinSequence such that
A1: len f = card support b and
A2: for k being Nat st k in dom f holds f.k = F(k) from
    FINSEQ_1:sch 2;
A3: dom f = Seg card support b by A1,FINSEQ_1:def 3;
    rng f c= (the carrier of Polynom-Ring L)*
    proof
      let x be set;
      assume x in rng f;
      then consider i being Nat such that
A4:   i in dom f and
A5:   f.i = x by FINSEQ_2:11;
      i in Seg card support b by A1,A4,FINSEQ_1:def 3;
      then x = F(i) by A2,A5,A3;
      hence x in (the carrier of Polynom-Ring L)* by FINSEQ_1:def 11;
    end;
    then reconsider f as FinSequence of (the carrier of Polynom-Ring L)*
    by FINSEQ_1:def 4;

reconsider it1 = Product FlattenSeq f as Polynomial of L by POLYNOM3:def 12;
    take it1, f, s;
    thus len f = card support b by A1;
    thus s = canFS(support b);
    thus for i be Element of NAT st i in dom f
      holds f.i = fpoly_mult_root(s/.i,b.(s/.i)) by A2;
    thus thesis;
  end;
  uniqueness
  proof
    let it1, it2 be Polynomial of L;
    given f1 being FinSequence of (the carrier of Polynom-Ring L)*,
    s1 being FinSequence of L such that
A6: len f1 = card support b & s1 = canFS(support b) &
    (for i being Element of NAT st i in dom f1
    holds f1.i = fpoly_mult_root(s1/.i,b.(s1/.i)))
    & it1 = Product FlattenSeq f1;
    given f2 being FinSequence of (the carrier of Polynom-Ring L)*,
    s2 being FinSequence of L such that
A7: len f2 = card support b & s2 = canFS(support b) &
    (for i being Element of NAT st i in dom f2
    holds f2.i = fpoly_mult_root(s2/.i,b.(s2/.i)))
    & it2 = Product FlattenSeq f2;
A8: dom f1 = dom f2 by A6,A7,FINSEQ_3:31;
    now
      let i be Nat;
      assume
A10:   i in dom f1;
      hence f1.i = fpoly_mult_root(s1/.i,b.(s1/.i)) by A6
        .= f2.i by A6,A7,A8,A10;
    end;
    hence thesis by A6,A7,FINSEQ_2:10;
  end;
end;

theorem Th62:
  for L being Abelian add-associative right_zeroed right_complementable
  commutative distributive well-unital (non empty doubleLoopStr)
  holds poly_with_roots(EmptyBag the carrier of L) = <%1.L%>
proof
  let L be Abelian add-associative right_zeroed right_complementable
  commutative distributive well-unital (non empty doubleLoopStr);
A1: 1_Polynom-Ring L = 1.Polynom-Ring L;
  set b = EmptyBag the carrier of L;
  consider f being FinSequence of (the carrier of Polynom-Ring L)*,
  s being FinSequence of L such that
A2: len f = card support b and s = canFS(support b) and
  for i being Element of NAT st i in dom f
  holds f.i = fpoly_mult_root(s/.i,b.(s/.i)) and
A3: poly_with_roots(b) = Product FlattenSeq f by Def11;
  card support b = 0 by BAGORDER:19,CARD_1:78;
  then f = <*>((the carrier of Polynom-Ring L)*) by A2,FINSEQ_1:32;
  then FlattenSeq f = <*>(the carrier of Polynom-Ring L) by DTCONSTR:20;
  then Product FlattenSeq f = 1.Polynom-Ring L by A1,GROUP_4:11
    .= 1_.(L) by POLYNOM3:37;
  hence thesis by A3,Th33;
end;

theorem Th63:
  for L being add-associative right_zeroed right_complementable distributive
  (non empty doubleLoopStr), c being Element of L
  holds poly_with_roots(({c},1)-bag) = <% -c, 1.L %>
proof
  let L be add-associative right_zeroed right_complementable distributive
  (non empty doubleLoopStr), c being Element of L;
  set b = ({c},1)-bag;
  consider f being FinSequence of (the carrier of Polynom-Ring L)*,
  s being FinSequence of L such that
A1: len f = card support b and
A2: s = canFS(support b) and
A3: for i being Element of NAT st i in dom f
  holds f.i = fpoly_mult_root(s/.i,b.(s/.i))and
A4: poly_with_roots(b) = Product FlattenSeq f by Def11;
A5: support b = {c} by Th10;
  then
A6: card support b = 1 by CARD_1:79;
A7: f = <*f/.1*> by A1,A5,CARD_1:79,FINSEQ_5:15;
A8: 1 in dom f by A1,A6,FINSEQ_3:27;
  then f.1 = f/.1 by PARTFUN1:def 8;
  then
A9: FlattenSeq f = f.1 by A7,DTCONSTR:13;
A10: f.1 = fpoly_mult_root(s/.1,b.(s/.1)) by A3,A8;
  set f1 = fpoly_mult_root(s/.1,b.(s/.1));
A11: s = <* c *> by A2,A5,Th6;
  len s = 1 by A2,A6,Def1;
  then 1 in dom s by FINSEQ_3:27;
  then
A12: s/.1 = s.1 by PARTFUN1:def 8
    .= c by A11,FINSEQ_1:57;
  c in {c} by TARSKI:def 1;
  then b.(s/.1) = 1 by A12,Th9;
  then
A13: len f1 = 1 by Def10;
  then
A14: f1 = <*f1/.1*> by FINSEQ_5:15;
A15: 1 in dom f1 by A13,FINSEQ_3:27;
  thus poly_with_roots(({c},1)-bag) = f1/.1 by A4,A9,A10,A14,FINSOP_1:12
    .= f1.1 by A15,PARTFUN1:def 8
    .= <% -c, 1.L %> by A12,A15,Def10;
end;

theorem Th64:
  for L being add-associative right_zeroed right_complementable distributive
  (non empty doubleLoopStr), b being bag of the carrier of L,
  f being FinSequence of (the carrier of Polynom-Ring L)*,
  s being FinSequence of L st len f = card support b & s = canFS(support b) &
  (for i being Element of NAT st i in dom f
  holds f.i = fpoly_mult_root(s/.i,b.(s/.i)))
  holds len FlattenSeq f = degree b
proof
  let L be add-associative right_zeroed right_complementable distributive
  (non empty doubleLoopStr), b being bag of the carrier of L,
  f being FinSequence of (the carrier of Polynom-Ring L)*,
  s being FinSequence of L such that
A1: len f = card support b and
A2: s = canFS(support b) and
A3: for i being Element of NAT st i in dom f
  holds f.i = fpoly_mult_root(s/.i,b.(s/.i));
  len s = card support b by A2,Def1;
  then
A4: dom f = dom s by A1,FINSEQ_3:31;
  reconsider Cf = Card f as FinSequence of NAT;
A5: len FlattenSeq f = Sum Cf by POLYNOM1:30;
  consider g being FinSequence of NAT such that
A6: degree b = Sum g and
A7: g = b*canFS(support b) by Def4;
  now
A8: rng s c= dom b
    proof
      let x be set;
      assume x in rng s;
      then
A9:   x in support b by A2,Th5;
      support b c= dom b by POLYNOM1:41;
      hence x in dom b by A9;
    end;
    thus dom Card f = dom f by CARD_3:def 2
      .= dom g by A2,A4,A7,A8,RELAT_1:46;
    let i be Nat such that
A10: i in dom Card f;
A11: i in dom f by A10,CARD_3:def 2;
    then f.i = fpoly_mult_root(s/.i,b.(s/.i)) by A3;
    then
A12: len (f.i) = b.(s/.i) by Def10;
A13: g.i = b.(s.i) by A2,A4,A7,A11,FUNCT_1:23;
    thus Cf.i = Card (f.i) by A11,CARD_3:def 2
      .= g.i by A4,A11,A12,A13,PARTFUN1:def 8;
  end;
  hence len FlattenSeq f = degree b by A5,A6,FINSEQ_1:17;
end;

theorem Th65:
  for L being add-associative right_zeroed right_complementable distributive
  (non empty doubleLoopStr), b being bag of the carrier of L,
  f being FinSequence of (the carrier of Polynom-Ring L)*,
  s being FinSequence of L, c being Element of L
  st len f = card support b & s = canFS(support b) &
  (for i being Element of NAT st i in dom f
  holds f.i = fpoly_mult_root(s/.i,b.(s/.i)))
  holds (c in support b implies card ((FlattenSeq f)"{<% -c, 1.L%>}) = b.c) &
  (not c in support b implies card ((FlattenSeq f)"{<% -c, 1.L%>}) = 0)
proof
  let L be add-associative right_zeroed right_complementable distributive
  (non empty doubleLoopStr), b be bag of the carrier of L,
  f be FinSequence of (the carrier of Polynom-Ring L)*, s be FinSequence of L,
  c be Element of L such that
A1: len f = card support b and
A2: s = canFS(support b) and
A3: for i being Element of NAT st i in dom f
  holds f.i = fpoly_mult_root(s/.i,b.(s/.i));
A4: len f = len s by A1,A2,Def1;
  then
A5: dom f = dom s by FINSEQ_3:31;
A6: s is one-to-one by A2,Th4;
  hereby
    assume c in support b;
    then c in rng s by A2,Th5;
    then consider i being Nat such that
A7: i in dom s and
A8: s.i = c by FINSEQ_2:11;
A9: s/.i = c by A7,A8,PARTFUN1:def 8;
A10: card (b.c) = b.c by CARD_1:66;
A11: b.c = { k where k is Element of NAT : k < b.c } by AXIOMS:30;
    set ff = FlattenSeq f;
    set Y = ff"{<% -c, 1.L%>};
    set X = { k where k is Element of NAT : k < b.c };
    defpred P[set,set] means ex n being Element of NAT st n = $1 &
    $2 = (Sum Card(f|(i-'1)))+(1+n);
A12: for x,y1,y2 being set st x in X & P[x,y1] & P[x,y2] holds y1 = y2;
A13: for x being set st x in X ex y being set st P[x,y]
    proof
      let x be set;
      assume x in X;
      then consider k being Element of NAT such that
A14:  x = k and k < b.c;
      take y = (Sum Card(f|(i-'1)))+(1+k); thus P[x,y] by A14;
    end;
    consider g being Function such that
A15: dom g = X and
A16: for x being set st x in X holds P[x,g.x] from FUNCT_1:sch 2(A12,A13);
A17: g is one-to-one
    proof
      let x1,x2 be set such that
A18:  x1 in dom g and
A19:  x2 in dom g and
A20:  g.x1 = g.x2;
      consider n1 being Element of NAT such that
A21:  n1 = x1 and
A22:  g.x1 = (Sum Card(f|(i-'1)))+(1+n1) by A15,A16,A18;
      consider n2 being Element of NAT such that
A23:  n2 = x2 and
A24:  g.x2 = (Sum Card(f|(i-'1)))+(1+n2) by A15,A16,A19;
      thus x1 = x2 by A20,A21,A22,A23,A24;
    end;
    now
      let y be set;
      hereby
        assume y in rng g;
        then consider x being set such that
A25:    x in dom g and
A26:    y = g.x by FUNCT_1:def 5;
        consider k being Element of NAT such that
A27:    x = k and
A28:    k < b.c by A15,A25;
        consider n being Element of NAT such that
A29:    n = x and
A30:    g.x = (Sum Card(f|(i-'1)))+(1+n) by A15,A16,A25;
A31:    f.i = fpoly_mult_root(s/.i,b.(s/.i)) by A3,A5,A7;
A32:    1 <= 1+n & 1+n <= b.c by A27,A28,A29,NAT_1:12,13;
        len (f.i) = b.c by A9,A31,Def10;
        then
A33:    1+n in dom (f.i) by A32,FINSEQ_3:27;
        then
A34:    (Sum Card (f|(i-'1))) + (1+n) in dom ff &
        (f.i).(1+n) = ff.((Sum Card (f|(i-'1))) + (1+n)) by A5,A7,POLYNOM1:33;
        (f.i).(1+n) = <% -c, 1.L%> by A9,A31,A33,Def10;
        then (f.i).(1+n) in {<% -c, 1.L%>} by TARSKI:def 1;
        hence y in Y by A26,A30,A34,FUNCT_1:def 13;
      end;
      assume
A35:  y in Y;
      then
A36:  y in dom ff & ff.y in {<% -c, 1.L%>} by FUNCT_1:def 13;
      reconsider yn = y as Element of NAT by A35;
      consider i1, j being Element of NAT such that
A37:  i1 in dom f and
A38:  j in dom (f.i1) and
A39:  yn = (Sum Card (f|(i1-'1))) + j and
A40:  (f.i1).j = ff.yn by A36,POLYNOM1:32;
      j <> 0 by A38,FINSEQ_3:26;
      then consider j1 being Nat such that
A41:  j = j1 + 1 by NAT_1:6;
      reconsider j1 as Element of NAT by ORDINAL1:def 13;
A42:  f.i1 = fpoly_mult_root(s/.i1,b.(s/.i1)) by A3,A37;
      then (f.i1).j = <%-s/.i1, 1.L%> by A38,Def10;
      then
A43:  <% -c, 1.L%> = <%-s/.i1, 1.L%> by A36,A40,TARSKI:def 1;
      <% -c, 1.L%>.0 = -c & <% -s/.i1,1.L%>.0 = -s/.i1 by POLYNOM5: 39;
      then
A44:  c = s/.i1 by A43,RLVECT_1:31;
A45:  i1 in dom s by A4,A37,FINSEQ_3:31;
      s/.i1 = s.i1 by A5,A37, PARTFUN1:def 8;
      then
A46:  i1 = i by A6,A7,A8,A44,A45,FUNCT_1:def 8;
      len (f.i1) = b.c by A42,A44,Def10;
      then j <= b.c by A38,FINSEQ_3:27;
      then j1 < b.c by A41,NAT_1:13;
      then
A47:  j1 in X;
      then consider n being Element of NAT such that
A48:  n = j1 and
A49:  g.j1 = (Sum Card(f|(i-'1)))+(1+n) by A16;
      thus y in rng g by A15,A39,A41,A46,A47,A48,A49,FUNCT_1:12;
    end;
    then rng g = Y by TARSKI:2;
    then X,Y are_equipotent by A15,A17, WELLORD2:def 4;
    hence card ((FlattenSeq f)"{<% -c, 1.L%>}) = b.c by A10,A11,CARD_1:21;
  end;
  assume that
A50: not c in support b and
A51: card ((FlattenSeq f)"{<% -c, 1.L%>}) <> 0;
  consider x being set such that
A52: x in (FlattenSeq f)"{<% -c, 1.L%>} by A51,CARD_1:78,XBOOLE_0:def 1;
A53: x in dom FlattenSeq f by A52,FUNCT_1:def 13;
  reconsider x as Element of NAT by A52;
  consider i, j being Element of NAT such that
A54: i in dom f and
A55: j in dom (f.i) and x = (Sum Card (f|(i-'1))) + j and
A56: (f.i).j = (FlattenSeq f).x by A53,POLYNOM1:32;
  (FlattenSeq f).x in {<% -c, 1.L%>} by A52,FUNCT_1:def 13;
  then
A57: (FlattenSeq f).x = <% -c, 1.L%> by TARSKI:def 1;
  f.i = fpoly_mult_root(s/.i,b.(s/.i)) by A3,A54;
  then
A58: (f.i).j = <% -s/.i, 1.L%> by A55,Def10;
  <% -c, 1.L%>.0 = -c & <% -s/.i, 1.L%>.0 = -s/.i by POLYNOM5:39;
  then
A59: c = s/.i by A56,A57,A58,RLVECT_1:31;
  s/.i = s.i & s.i in rng s by A5,A54,FUNCT_1:12,PARTFUN1:def 8;
  hence contradiction by A2,A50,A59,Th5;
end;

theorem Th66:
  for L being comRing for b1,b2 being bag of the carrier of L holds
  poly_with_roots(b1+b2) = (poly_with_roots b1)*'(poly_with_roots b2)
proof
  let L be comRing, b1,b2 be bag of the carrier of L;
  set b = b1+b2;
  consider f being FinSequence of (the carrier of Polynom-Ring L)*,
  s being FinSequence of L such that
A1: len f = card support b and
A2: s = canFS(support b) and
A3: for i being Element of NAT st i in dom f
  holds f.i = fpoly_mult_root(s/.i,b.(s/.i)) and
A4: poly_with_roots(b1+b2) = Product FlattenSeq f by Def11;
  consider f1 being FinSequence of (the carrier of Polynom-Ring L)*,
  s1 being FinSequence of L such that
A5: len f1 = card support b1 and
A6: s1 = canFS(support b1) and
A7: for i being Element of NAT st i in dom f1
  holds f1.i = fpoly_mult_root(s1/.i,b1.(s1/.i)) and
A8: poly_with_roots(b1) = Product FlattenSeq f1 by Def11;
  consider f2 being FinSequence of (the carrier of Polynom-Ring L)*,
  s2 being FinSequence of L such that
A9: len f2 = card support b2 and
A10: s2 = canFS(support b2) and
A11: for i being Element of NAT st i in dom f2
  holds f2.i = fpoly_mult_root(s2/.i,b2.(s2/.i)) and
A12: poly_with_roots(b2) = Product FlattenSeq f2 by Def11;
  set ff = FlattenSeq f, ff1 = FlattenSeq f1, ff2 = FlattenSeq f2;
  set g = (FlattenSeq f1) ^ (FlattenSeq f2);
A13: support b = support b1 \/ support b2 by POLYNOM1:42;
A14: len ff = degree b by A1,A2,A3,Th64;
A15: len ff2 = degree b2 by A9,A10,A11,Th64;
  len g = len ff1 + len ff2 by FINSEQ_1:35
    .= degree b1 + degree b2 by A5,A6,A7,A15,Th64
    .= degree b by Th17;
  then
A16: dom ff = dom g by A14,FINSEQ_3:31;
A17: len s = card support b by A2,Def1;
  now
    let x be set;
    per cases;
    suppose x in rng ff;
      then consider k being Nat such that
A18:  k in dom ff and
A19:  ff.k = x by FINSEQ_2:11;
      consider i, j being Element of NAT such that
A20:  i in dom f and
A21:  j in dom (f.i) and k = (Sum Card (f|(i-'1))) + j and
A22:  (f.i).j = ff.k by A18,POLYNOM1:32;
      f.i = fpoly_mult_root(s/.i,b.(s/.i)) by A3,A20;
      then
A23:  (f.i).j = <% -s/.i, 1.L %> by A21,Def10;
      i in dom s by A1,A17,A20,FINSEQ_3:31;
      then s.i = s/.i & s.i in rng s by FUNCT_1:12,PARTFUN1:def 8;
      then
A24:  s/.i in support b by A2,Th5;
A25:  card (g"{x}) = card (ff1"{x}) + card (ff2"{x}) by FINSEQ_3:63;
      thus card (ff"{x}) = card (g"{x})
      proof
        per cases by A13,A24,XBOOLE_0:def 2;
        suppose
A26:      s/.i in support b1 & not s/.i in support b2;
          then
A27:      card(ff2"{x}) = 0 by A9,A10,A11,A19,A22,A23,Th65;
          thus card (ff"{x}) = b.(s/.i) by A1,A2,A3,A19,A22,A23,A24,Th65
            .= b1.(s/.i) + b2.(s/.i) by POLYNOM1:def 5
            .= b1.(s/.i) + (0 qua Nat) by A26,POLYNOM1:def 7
            .= card(g"{x}) by A5,A6,A7,A19,A22,A23,A25,A26,A27,Th65;
        end;
        suppose
A28:      not s/.i in support b1 & s/.i in support b2;
          then
A29:      card(ff2"{x}) = b2.(s/.i) by A9,A10,A11,A19,A22,A23, Th65;
          thus card (ff"{x}) = b.(s/.i) by A1,A2,A3,A19,A22,A23,A24,Th65
            .= b1.(s/.i) + b2.(s/.i) by POLYNOM1:def 5
            .= 0 qua Nat+b2.(s/.i) by A28,POLYNOM1:def 7
            .= card(g"{x}) by A5,A6,A7,A19,A22,A23,A25,A28,A29,Th65;
        end;
        suppose
A30:      s/.i in support b1 & s/.i in support b2;
          then
A31:      card(ff2"{x}) = b2.(s/.i) by A9,A10,A11,A19,A22,A23, Th65;
          thus card (ff"{x}) = b.(s/.i) by A1,A2,A3,A19,A22,A23,A24,Th65
            .= b1.(s/.i) + b2.(s/.i) by POLYNOM1:def 5
            .= card(g"{x}) by A5,A6,A7,A19,A22,A23,A25,A30,A31,Th65;
        end;
      end;
    end;
    suppose
A32:  not x in rng ff;
      now
        assume x in rng g;
        then
A33:    x in (rng ff1 \/ rng ff2) by FINSEQ_1:44;
        per cases by A33,XBOOLE_0:def 2;
        suppose x in rng ff1;
          then consider k being Nat such that
A34:      k in dom ff1 and
A35:      ff1.k = x by FINSEQ_2:11;
          consider i, j being Element of NAT such that
A36:      i in dom f1 and
A37:      j in dom (f1.i) and k = (Sum Card (f1|(i-'1))) + j and
A38:      (f1.i).j = ff1.k by A34,POLYNOM1:32;
          f1.i = fpoly_mult_root(s1/.i,b1.(s1/.i)) by A7,A36;
          then
A39:      (f1.i).j = <% -s1/.i, 1.L %> by A37,Def10;
          len s1 = card support b1 by A6,Def1;
          then i in dom s1 by A5,A36,FINSEQ_3:31;
          then s1.i = s1/.i & s1.i in rng s1 by FUNCT_1:12,PARTFUN1:def 8;
          then s1/.i in support b1 by A6,Th5;
          then
A40:      s1/.i in support b by A13,XBOOLE_0:def 2;
          then s1/.i in rng s by A2,Th5;
          then consider l being Nat such that
A41:      l in dom s and
A42:      s.l = s1/.i by FINSEQ_2:11;
A43:      l in dom f by A1,A17,A41,FINSEQ_3:31;
          then
A44:      f.l = fpoly_mult_root(s/.l,b.(s/.l)) by A3;
A45:      s.l = s/.l by A41,PARTFUN1:def 8;
          b.(s1/.i) <> 0 by A40,POLYNOM1:def 7;
          then 0 < b.(s1/.i);
          then
A46:      0 qua Nat+1 <= b.(s1/.i) by NAT_1:13;
          len (f.l) = b.(s/.l) by A44,Def10;
          then
A47:      1 in dom (f.l) by A42,A45,A46,FINSEQ_3:27;
          then (Sum Card (f|(l-'1))) + 1 in dom ff &
          (f.l).1 = ff.((Sum Card (f|(l-'1))) + 1) by A43,POLYNOM1:33;
          then (f.l).1 in rng ff by FUNCT_1:12;
          hence contradiction by A32,A35,A38,A39,A42,A44,A45,A47,Def10;
        end;
        suppose x in rng ff2;
          then consider k being Nat such that
A48:      k in dom ff2 and
A49:      ff2.k = x by FINSEQ_2:11;
          consider i, j being Element of NAT such that
A50:      i in dom f2 and
A51:      j in dom (f2.i) and k = (Sum Card (f2|(i-'1))) + j and
A52:      (f2.i).j = ff2.k by A48,POLYNOM1:32;
          f2.i = fpoly_mult_root(s2/.i,b2.(s2/.i)) by A11,A50;
          then
A53:      (f2.i).j = <% -s2/.i, 1.L %> by A51,Def10;
          len s2 = card support b2 by A10,Def1;
          then i in dom s2 by A9,A50,FINSEQ_3:31;
          then s2.i = s2/.i & s2.i in rng s2 by FUNCT_1:12,PARTFUN1:def 8;
          then s2/.i in support b2 by A10,Th5;
          then
A54:      s2/.i in support b by A13,XBOOLE_0:def 2;
          then s2/.i in rng s by A2,Th5;
          then consider l being Nat such that
A55:      l in dom s and
A56:      s.l = s2/.i by FINSEQ_2:11;
A57:      l in dom f by A1,A17,A55,FINSEQ_3:31;
          then
A58:      f.l = fpoly_mult_root(s/.l,b.(s/.l)) by A3;
A59:      s.l = s/.l by A55,PARTFUN1:def 8;
          b.(s2/.i) <> 0 by A54,POLYNOM1:def 7;
          then 0 < b.(s2/.i);
          then
A60:      0 qua Nat+1 <= b.(s2/.i) by NAT_1:13;
          len (f.l) = b.(s/.l) by A58,Def10;
          then
A61:      1 in dom (f.l) by A56,A59,A60,FINSEQ_3:27;
          then (Sum Card (f|(l-'1))) + 1 in dom ff &
          (f.l).1 = ff.((Sum Card (f|(l-'1))) + 1) by A57,POLYNOM1:33;
          then (f.l).1 in rng ff by FUNCT_1:12;
          hence contradiction by A32,A49,A52,A53,A56,A58,A59,A61,Def10;
        end;
      end;
      then g"{x} = {} by FUNCT_1:142;
      hence card (ff"{x}) = card (g"{x}) by A32,FUNCT_1:142;
    end;
  end;
  then ff, g are_fiberwise_equipotent by RFINSEQ:def 1;
  then consider p being Permutation of dom FlattenSeq f such that
A62: FlattenSeq f = ((FlattenSeq f1) ^ (FlattenSeq f2)) * p by A16,RFINSEQ:17;
  thus poly_with_roots(b1+b2)
  = Product ((FlattenSeq f1) ^ (FlattenSeq f2)) by A4,A16,A62,Th18
    .= (Product FlattenSeq f1) * (Product FlattenSeq f2) by GROUP_4:8
    .= (poly_with_roots b1)*'(poly_with_roots b2) by A8,A12,POLYNOM3:def 12;
end;

theorem
  for L being algebraic-closed domRing, p being non-zero (Polynomial of L)
  st p.(len p-'1) = 1.L holds p = poly_with_roots(BRoots(p))
proof
  let L be algebraic-closed domRing, p be non-zero (Polynomial of L);
  assume
A1: p.(len p-'1) = 1.L;
  len p > 0 by Th19;
  then
A2: len p >= 0 qua Nat+1 by NAT_1:13;
  defpred P[Nat] means for p being non-zero Polynomial of L
  st len p = $1 & $1 >= 1 & p.(len p -'1) = 1.L
  holds p = poly_with_roots(BRoots(p));
A3: P[1]
  proof
    let p be non-zero Polynomial of L such that
A4: len p = 1 and 1 >= 1 and
A5: p.(len p -'1) = 1.L;
    degree BRoots p = 0 by A4,Th59;
    then
A6: BRoots p = EmptyBag the carrier of L by Th14;
    len p -'1 = 0 by A4,BINARITH:51;
    hence p = <%1.L%> by A4,A5,ALGSEQ_1:def 6
      .= poly_with_roots(BRoots(p)) by A6,Th62;
  end;
A7: for n being Nat st n >= 1 & P[n] holds P[n+1]
  proof
    let n be Nat such that
A8: n >= 1 and
A9: P[n];
    let p being non-zero Polynomial of L such that
A10: len p = n+1 and n+1 >= 1 and
A11: p.(len p -'1) = 1.L;
    n+1 > 1 by A8,NAT_1:13;
    then p is with_roots by A10,POLYNOM5:def 8;
    then consider x being Element of L such that
A12: x is_a_root_of p by POLYNOM5:def 7;
    set q = poly_quotient(p,x);
    set r = <%-x,1.L%>;
A13: p = r*'q by A12,Th52;
    then reconsider q as non-zero Polynomial of L by Th36;
    BRoots r = ({x},1)-bag by Th56;
    then
A14: BRoots(p) = ({x},1)-bag + BRoots(q) by A13,Th58;
A15: len r = 2 by POLYNOM5:41;
    len q > 0 by Th19;
    then r.(len r -'1) <> 0.L & q.(len q -'1) <> 0.L by A15,Th20;
    then r.(len r -'1) * q.(len q -'1) <> 0.L by VECTSP_2:def 5;
    then
A16: len p = len q + (1+1)- 1 by A13,A15,POLYNOM4:13;
    q.(len q -'1) = 1.L by A11,A13,Th43;
    then
A17: q = poly_with_roots(BRoots(q)) by A8,A9,A10,A16;
    poly_with_roots(({x},1)-bag) = <%-x,1.L%> by Th63;
    hence p = poly_with_roots(BRoots(p)) by A13,A14,A17,Th66;
  end;
  for n being Nat st n >= 1 holds P[n] from NAT_1:sch 8(A3,A7);
  hence p = poly_with_roots(BRoots(p)) by A1,A2;
end;

theorem
  for L being comRing, s being non empty finite Subset of L,
  f being FinSequence of Polynom-Ring L st len f = card s &
  for i being Element of NAT, c being Element of L
  st i in dom f & c = (canFS(s)).i holds f.i = <% -c, 1.L %>
  holds poly_with_roots((s,1)-bag) = Product(f)
proof
  let L be comRing;
  set cL = the carrier of L;
  set cPRL = the carrier of Polynom-Ring L;
  let s be non empty finite Subset of cL, f be FinSequence of cPRL such that
A1: len f = card s and
A2: for i being Element of NAT, c being Element of cL
  st i in dom f & c = (canFS(s)).i holds f.i = <% -c, 1.L %>;
  set cs = canFS(s);
A3: len cs = card s by Def1;
A4: 0 qua Nat+1 <= len f by A1,NAT_1:13;
A5: cs | Seg len f is FinSequence by FINSEQ_1:23;
  f | Seg len f is FinSequence by FINSEQ_1:23;
  then
A6: f | Seg len f = f by FINSEQ_2:23;
A7: rng cs = s by Th5;
A8: dom f = dom cs by A1,A3,FINSEQ_3:31;
  defpred P[Element of NAT] means
  ex t being finite Subset of cL, g being FinSequence of cPRL
  st t = rng (cs | Seg $1) & g = f | Seg $1 &
  poly_with_roots((t,1)-bag) = Product(g);
A9: P[1]
  proof reconsider cs1a = cs | Seg 1 as FinSequence of s by FINSEQ_1:23;
    reconsider g = f | Seg 1 as FinSequence of cPRL by FINSEQ_1:23;
    consider s1 being Element of s such that
A10: cs1a = <* s1 *> by A1,A3,A4,QC_LANG4:7;
A11: 1 in Seg 1 by FINSEQ_1:3;
    1 in dom cs by A1,A3,A4,FINSEQ_3:27;
    then reconsider cs1 = cs.1 as Element of s by FINSEQ_2:13;
A12: cs1a.1 = cs1 by A11,FUNCT_1:72;
    cs1 in cL;
    then reconsider cs1 = cs.1 as Element of cL;
A13: cs1a.1 = s1 by A10,FINSEQ_1:57;
    reconsider t = {cs1} as finite Subset of cL;
    consider p1 being Element of cPRL such that
A14: g = <* p1 *> by A4,QC_LANG4:7;
A15: 1 in dom f by A4,FINSEQ_3:27;
    then reconsider f1 = f.1 as Element of cPRL by FINSEQ_2:13;
A16: g.1 = f1 by A11,FUNCT_1:72;
A17: g.1 = p1 by A14,FINSEQ_1:57;
    take t, g; thus t = rng (cs | Seg 1) & g = f | Seg 1 by A10,A12,A13,
    FINSEQ_1:56;
A18: Product(g) = p1 by A14,FINSOP_1:12;
    f1 = <% -cs1, 1.L %> by A2,A15;
    hence poly_with_roots((t,1)-bag) = Product(g) by A16,A17,A18,Th63;
  end;
A19: for j being Element of NAT st 1 <= j & j < len f holds P[j] implies P[j+1]
  proof
    let j be Element of NAT such that
A20: 1 <= j and
A21: j < len f;
    reconsider csja = cs | Seg j as FinSequence of s by FINSEQ_1:23;
    reconsider csja1 = cs | Seg (j+1) as FinSequence of s by FINSEQ_1:23;
    given t being finite Subset of cL, g being FinSequence of cPRL such that
A22: t = rng (cs | Seg j) and
A23: g = f | Seg j and
A24: poly_with_roots((t,1)-bag) = Product(g);
    reconsider g1 = f | Seg (j+1) as FinSequence of cPRL by FINSEQ_1:23;
    set t1 = rng csja1;
A25: 1 <= j+1 & j+1 <= len f by A20,A21,NAT_1:13;
    then
A26: j+1 in dom cs by A1,A3,FINSEQ_3:27;
    then cs.(j+1) in s by FINSEQ_2:13;
    then reconsider csj1 = cs.(j+1) as Element of cL;
    Seg (j+1) = Seg j \/ {j+1} by FINSEQ_1:11;
    then
A27: csja1 = csja \/ cs|{j+1} by RELAT_1:107;
    cs|{j+1} = (j+1) .--> csj1 by A26,FUNCT_7:6;
    then rng (cs|{j+1}) = {csj1} by FUNCOP_1:14;
    then
A28: t1 = t \/ {csj1} by A22,A27,RELAT_1:26;
    then reconsider t1 as finite Subset of cL;
    take t1, g1; thus t1 = rng (cs | Seg (j+1)) & g1 = f | Seg (j+1);
    reconsider pt = poly_with_roots((t,1)-bag) as Polynomial of L;
    reconsider pj1 = poly_with_roots(({csj1},1)-bag) as Polynomial of L;
    reconsider epj1 =<% -csj1, 1.L %> as Element of cPRL by POLYNOM3:def 12;
    consider l being Nat such that
A29: len f = j+1+l by A25,NAT_1:10;
A30: len g1 = j+1 by A29,FINSEQ_3:59;
    j <= j+1 by NAT_1:12;
    then Seg j c= Seg (j+1) by FINSEQ_1:7;
    then
A31: g = g1 | Seg j by A23,RELAT_1:103;
    g1.(j+1) = f.(j+1) by FINSEQ_1:6,FUNCT_1:72
      .= <% -csj1, 1.L %> by A2,A8
    ,A26;
    then
A32: g1 = g ^ <* <% -csj1, 1.L %> *> by A30,A31,FINSEQ_3:61;
A33: pj1 = epj1 by Th63;
    t misses {csj1}
    proof
      assume not thesis;
      then t /\ {csj1} <> {} by XBOOLE_0:def 7;
      then consider x being set such that
A34:  x in t /\ {csj1} by XBOOLE_0:def 1;
A35:  x in t & x in {csj1} by A34,XBOOLE_0:def 3;
      then
A36:  x = csj1 by TARSKI:def 1;
      consider i being set such that
A37:  i in dom (cs | Seg j) and
A38:  x = (cs | Seg j).i by A22,A35,FUNCT_1:def 5;
A39:  i in Seg j by A37,RELAT_1:86;
      reconsider i as Element of NAT by A37;
A40:  1 <= i & i <= j by A39,FINSEQ_1:3;
      then
A41:  i < j+1 by NAT_1:13;
      x = cs.i by A37,A38,FUNCT_1: 70;
      hence contradiction by A1,A3,A7,A25,A36,A40,A41,GRAPH_5:10;
    end;
    then (t1,1)-bag = (t,1)-bag + ({csj1},1)-bag by A28,Th12;
    hence poly_with_roots((t1,1)-bag) = pt *' pj1 by Th66
      .= Product(g) * epj1 by A24,A33,POLYNOM3:def 12
      .= Product(g1) by A32,GROUP_4:9;
  end;
  for i being Element of NAT st 1 <= i & i <= len f holds P[i]
  from POLYNOM2:sch 4 (A9,A19);
  then consider t being finite Subset of cL, g being FinSequence of cPRL such
  that
A42: t = rng (cs | Seg len f) and
A43: g = f | Seg len f and
A44: poly_with_roots((t,1)-bag) = Product(g) by A4;
  thus poly_with_roots((s,1)-bag) = Product(f) by A1,A3,A5,A6,A7,A42,A43,A44,
  FINSEQ_2:23;
end;

theorem
  for L being non trivial comRing, s being non empty finite Subset of L,
  x being Element of L, f being FinSequence of L st len f = card s &
  for i being Element of NAT, c being Element of L
  st i in dom f & c = (canFS(s)).i holds f.i = eval(<% -c, 1.L %>,x)
  holds eval(poly_with_roots((s,1)-bag),x) = Product(f)
proof
  let L be non trivial comRing;
  set cL = the carrier of L;
  let s be non empty finite Subset of cL, x be Element of cL,
  f be FinSequence of L such that
A1: len f = card s and
A2: for i being Element of NAT, c being Element of cL
  st i in dom f & c = (canFS(s)).i holds f.i = eval(<% -c, 1.L %>,x);
  set cs = canFS(s);
A3: len cs = card s by Def1;
A4: 0 qua Nat+1 <= len f by A1,NAT_1:13;
A5: cs | Seg len f is FinSequence by FINSEQ_1:23;
  f | Seg len f is FinSequence by FINSEQ_1:23;
  then
A6: f | Seg len f = f by FINSEQ_2:23;
A7: rng cs = s by Th5;
A8: dom f = dom cs by A1,A3,FINSEQ_3:31;
  defpred P[Element of NAT] means
  ex t being finite Subset of cL, g being FinSequence of cL
  st t = rng (cs | Seg $1) & g = f | Seg $1 &
  eval(poly_with_roots((t,1)-bag),x) = Product(g);
A9: P[1]
  proof
    reconsider cs1a = cs | Seg 1 as FinSequence of s by FINSEQ_1:23;
    reconsider g = f | Seg 1 as FinSequence of cL by FINSEQ_1:23;
    consider s1 being Element of s such that
A10: cs1a = <* s1 *> by A1,A3,A4,QC_LANG4:7;
A11: 1 in Seg 1 by FINSEQ_1:3;
    1 in dom cs by A1,A3,A4,FINSEQ_3:27;
    then reconsider cs1 = cs.1 as Element of s by FINSEQ_2:13;
A12: cs1a.1 = cs1 by A11,FUNCT_1:72;
    cs1 in cL;
    then reconsider cs1 = cs.1 as Element of cL;
A13: cs1a.1 = s1 by A10,FINSEQ_1:57;
    reconsider t = {cs1} as finite Subset of cL;
    consider p1 being Element of cL such that
A14: g = <* p1 *> by A4,QC_LANG4:7;
A15: 1 in dom f by A4,FINSEQ_3:27;
    then reconsider f1 = f.1 as Element of cL by FINSEQ_2:13;
A16: g.1 = f1 by A11,FUNCT_1:72;
A17: g.1 = p1 by A14,FINSEQ_1:57;
    take t, g; thus t = rng (cs | Seg 1) & g = f | Seg 1 by A10,A12,A13,
    FINSEQ_1:56;
A18: Product(g) = p1 by A14,FINSOP_1:12;
    f1 = eval(<% -cs1, 1.L %>,x) by A2,A15;
    hence eval(poly_with_roots((t,1)-bag),x) = Product(g) by A16,A17,A18,Th63;
  end;
A19: for j being Element of NAT st 1 <= j & j < len f holds P[j] implies P[j+1]
  proof
    let j be Element of NAT such that
A20: 1 <= j and
A21: j < len f;
    reconsider csja = cs | Seg j as FinSequence of s by FINSEQ_1:23;
    reconsider csja1 = cs | Seg (j+1) as FinSequence of s by FINSEQ_1:23;
    given t being finite Subset of cL, g being FinSequence of cL such that
A22: t = rng (cs | Seg j) and
A23: g = f | Seg j and
A24: eval(poly_with_roots((t,1)-bag),x) = Product(g);
    reconsider g1 = f | Seg (j+1) as FinSequence of cL by FINSEQ_1:23;
    set t1 = rng csja1;
A25: 1 <= j+1 & j+1 <= len f by A20,A21,NAT_1:13;
    then
A26: j+1 in dom cs by A1,A3,FINSEQ_3:27;
    then cs.(j+1) in s by FINSEQ_2:13;
    then reconsider csj1 = cs.(j+1) as Element of cL;
    Seg (j+1) = Seg j \/ {j+1} by FINSEQ_1:11;
    then
A27: csja1 = csja \/ cs|{j+1} by RELAT_1:107;
    cs|{j+1} = (j+1) .--> csj1 by A26,FUNCT_7:6;
    then rng (cs|{j+1}) = {csj1} by FUNCOP_1:14;
    then
A28: t1 = t \/ {csj1} by A22,A27,RELAT_1:26;
    then reconsider t1 as finite Subset of cL;
    take t1, g1; thus t1 = rng (cs | Seg (j+1)) & g1 = f | Seg (j+1);
    reconsider pt = poly_with_roots((t,1)-bag) as Polynomial of L;
    reconsider pj1 = poly_with_roots(({csj1},1)-bag) as Polynomial of L;
    consider l being Nat such that
A29: len f = j+1+l by A25,NAT_1:10;
A30: len g1 = j+1 by A29,FINSEQ_3:59;
    j <= j+1 by NAT_1:12;
    then Seg j c= Seg (j+1) by FINSEQ_1:7;
    then
A31: g = g1 | Seg j by A23,RELAT_1:103;
    g1.(j+1) = f.(j+1) by FINSEQ_1:6,FUNCT_1:72
      .= eval(<% -csj1, 1.L %>,x) by A2,A8,A26;
    then
A32: g1 = g ^ <* eval(<% -csj1, 1.L %>,x) *> by A30,A31,FINSEQ_3:61;
A33: pj1 = <% -csj1, 1.L %> by Th63;
    t misses {csj1}
    proof
      assume not thesis;
      then t /\ {csj1} <> {} by XBOOLE_0:def 7;
      then consider x being set such that
A34:  x in t /\ {csj1} by XBOOLE_0:def 1;
A35:  x in t & x in {csj1} by A34,XBOOLE_0:def 3;
      then
A36:  x = csj1 by TARSKI:def 1;
      consider i being set such that
A37:  i in dom (cs | Seg j) and
A38:  x = (cs | Seg j).i by A22,A35,FUNCT_1:def 5;
A39:  i in Seg j by A37,RELAT_1:86;
      reconsider i as Element of NAT by A37;
A40:  1 <= i & i <= j by A39,FINSEQ_1:3;
      then
A41:  i < j+1 by NAT_1:13;
      x = cs.i by A37,A38,FUNCT_1: 70;
      hence contradiction by A1,A3,A7,A25,A36,A40,A41,GRAPH_5:10;
    end;
    then (t1,1)-bag = (t,1)-bag + ({csj1},1)-bag by A28,Th12;
    then poly_with_roots((t1,1)-bag) = pt *' pj1 by Th66;
    hence eval(poly_with_roots((t1,1)-bag),x)
    = Product(g) * eval(pj1,x) by A24,POLYNOM4:27
      .= Product(g1) by A32,A33,GROUP_4:9;
  end;
  for i being Element of NAT st 1 <= i & i <= len f holds P[i]
  from POLYNOM2:sch 4 (A9,A19);
  then consider t being finite Subset of cL, g being FinSequence of cL such
  that
A42: t = rng (cs | Seg len f) and
A43: g = f | Seg len f and
A44: eval(poly_with_roots((t,1)-bag),x) = Product(g) by A4;
  thus eval(poly_with_roots((s,1)-bag),x) = Product(f) by A1,A3,A5,A6,A7,A42,
  A43,A44,FINSEQ_2:23;
end;

