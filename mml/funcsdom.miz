:: Real Functions Spaces
::  by Henryk Oryszczyszyn and Krzysztof Pra\.zmowski
::
:: Received March 23, 1990
:: Copyright (c) 1990 Association of Mizar Users

environ

 vocabularies BINOP_1, FUNCT_2, FUNCT_1, RELAT_1, FUNCOP_1, VECTSP_1,
      RLVECT_1, ARYTM_1, LATTICES, FUNCSDOM, GROUP_1, VECTSP_2, STRUCT_0,
      ARYTM, ALGSTR_0, BOOLE;
 notations TARSKI, XBOOLE_0, ZFMISC_1, SUBSET_1, NUMBERS, RELAT_1, FUNCT_1,
      FUNCT_2, BINOP_1, DOMAIN_1, FUNCOP_1, BINOP_2,
      ORDINAL1, XCMPLX_0, XREAL_0, STRUCT_0, ALGSTR_0,
      RLVECT_1, REAL_1, GROUP_1, VECTSP_1;
 constructors BINOP_1, DOMAIN_1, FUNCOP_1, REAL_1, BINOP_2, VECTSP_1,
      RLVECT_1, FUNCT_3, RELSET_1;
 registrations XBOOLE_0, SUBSET_1, RELSET_1, NUMBERS, RLVECT_1, VECTSP_1,
      ALGSTR_0, BINOP_2, FUNCOP_1, FUNCT_3, REAL_1, XREAL_0, ORDINAL1;
 registrations RELAT_1, FUNCT_1, FUNCT_2;
 requirements NUMERALS, SUBSET, BOOLE, ARITHM;
 definitions RLVECT_1, STRUCT_0, GROUP_1, BINOP_1, VECTSP_1, ALGSTR_0,
      FUNCOP_1;
 theorems FUNCT_2, BINOP_1, FUNCOP_1, RLVECT_1, VECTSP_1, TARSKI, BINOP_2,
      GROUP_1, STRUCT_0, XREAL_0;
 schemes BINOP_1, FUNCT_2;

begin

reserve x1,x2,z for set;
reserve A,B for non empty set;

definition
  let A be set, B be non empty set;
  let F be BinOp of Funcs(A,B);
  let f,g be Element of Funcs(A,B);
  redefine func F.(f,g) -> Element of Funcs(A,B);
  coherence
  proof reconsider f,g as Element of Funcs(A,B) qua non empty set;
    F.(f,g) is Element of Funcs(A,B);
    hence thesis;
  end;
end;

definition
  let A,B,C,D be non empty set;
  let F be Function of [:C,D:],Funcs(A,B);
  let cd be Element of [:C,D:];
  redefine func F.cd -> Element of Funcs(A,B);
  coherence
  proof
    F.cd is Element of Funcs(A,B);
    hence thesis;
  end;
end;

reserve f,g,h for Element of Funcs(A,REAL);

definition
  let X be non empty set, Z be set;
  let F be (BinOp of X), f,g be Function of Z,X;
 canceled;
  redefine func F.:(f,g) -> Element of Funcs(Z,X);
  coherence
  proof
     F.:(f,g) in Funcs(Z,X) by FUNCT_2:11;
    hence thesis;
  end;
end;

definition
  let X be non empty set, Z be set;
  let F be (BinOp of X),a be Element of X,f be Function of Z,X;
  redefine func F[;](a,f) -> Element of Funcs(Z,X);
  coherence
  proof
    F[;](a,f) in Funcs(Z,X) by FUNCT_2:11;
    hence thesis;
  end;
end;

definition
  let A be set;
  func RealFuncAdd(A) -> BinOp of Funcs(A,REAL) means
  :Def2:
  for f,g being Element of Funcs(A,REAL) holds it.(f,g) = addreal.:(f,g);
  existence
  proof
    deffunc F(Element of Funcs(A,REAL),Element of Funcs(A,REAL)) =
    addreal.:($1,$2);
    consider F being BinOp of Funcs(A,REAL) such that
A1: for x,y being Element of Funcs(A,REAL) holds
    F.(x,y) = F(x,y) from BINOP_1:sch 4;
    take F;
    let f,g be Element of Funcs(A,REAL);
    thus thesis by A1;
  end;
  uniqueness
  proof
    let it1,it2 be BinOp of Funcs(A,REAL) such that
A2: for f,g being Element of Funcs(A,REAL)
    holds it1.(f,g) = addreal.:(f,g) and
A3: for f,g being Element of Funcs(A,REAL) holds it2.(f,g) = addreal.:(f,g);
    now
      let f,g be Element of Funcs(A,REAL);
      thus it1.(f,g) = addreal.:(f,g) by A2
        .= it2.(f,g) by A3;
    end;
    hence thesis by BINOP_1:2;
  end;
end;

definition
  let A;
  func RealFuncMult(A) -> BinOp of Funcs(A,REAL) means
  :Def3:
  for f,g being Element of Funcs(A,REAL) holds it.(f,g) = multreal.:(f,g);
  existence
  proof
    deffunc F(Element of Funcs(A,REAL),Element of Funcs(A,REAL)) =
    multreal.:($1,$2);
    consider F being BinOp of Funcs(A,REAL) such that
A1: for x,y being Element of Funcs(A,REAL) holds
    F.(x,y) = F(x,y) from BINOP_1:sch 4;
    take F;
    let f,g;
    thus thesis by A1;
  end;
  uniqueness
  proof
    let it1,it2 be BinOp of Funcs(A,REAL) such that
A2: for f,g being Element of Funcs(A,REAL) holds
    it1.(f,g) = multreal.:(f,g) and
A3: for f,g being Element of Funcs(A,REAL) holds it2.(f,g) = multreal.:(f,g);
    now
      let f,g be Element of Funcs(A,REAL);
      thus it1.(f,g) = multreal.:(f,g) by A2
        .=it2.(f,g) by A3;
    end;
    hence thesis by BINOP_1:2;
  end;
end;

definition
  let A be set;
  func RealFuncExtMult(A) -> Function of [:REAL,Funcs(A,REAL):],Funcs(A,REAL)
  means
  :Def4:
  for a being Real, f being Element of Funcs(A,REAL)
   holds it.(a,f) = multreal[;](a,f);
  existence
  proof
    deffunc F(Element of REAL,Element of Funcs(A,REAL)) =
      (multreal[;]($1,$2));
    consider F being Function of [:REAL,Funcs(A,REAL):],Funcs(A,REAL)
    such that
A1: for a being Element of REAL, f being Element of Funcs(A,REAL)
    holds F.(a,f) = F(a,f) from BINOP_1:sch 4;
    take F;
    let a be Real, f be Element of Funcs(A,REAL);
    thus thesis by A1;
  end;
  uniqueness
  proof
    let it1,it2 be Function of [:REAL,Funcs(A,REAL):],Funcs(A,REAL) such that
A2: for a being Real, f being Element of Funcs(A,REAL)
    holds it1.(a,f) = multreal[;](a,f) and
A3: for a being Real, f being Element of Funcs(A,REAL)
    holds it2.(a,f) = multreal[;](a,f);
    now
      let a be Real, f be Element of Funcs(A,REAL);
      thus it1.(a,f) = multreal[;](a,f) by A2
        .= it2.(a,f) by A3;
    end;
    hence thesis by BINOP_1:2;
  end;
end;

definition
  let A be set;
  func RealFuncZero(A) -> Element of Funcs(A,REAL) equals
  A --> 0;
  coherence
   proof
     A --> 0 is Function of A,REAL by FUNCOP_1:57;
    hence thesis by FUNCT_2:11;
   end;
end;

definition
  let A;
  func RealFuncUnit(A) -> Element of Funcs(A,REAL) equals

  A --> 1;
  coherence
   proof
     A --> 1 is Function of A,REAL by FUNCOP_1:57;
    hence thesis by FUNCT_2:11;
   end;
end;

Lm1: for x being (Element of A), f being Function of A,B holds x in dom f
proof
  let x be (Element of A),f be Function of A,B;
  x in A;
  hence thesis by FUNCT_2:def 1;
end;

canceled 9;

theorem Th10:
  h = (RealFuncAdd A).(f,g) iff
  for x being Element of A holds h.x = f.x + g.x
proof
A1: now
    assume
A2: h = (RealFuncAdd A).(f,g);
    let x be Element of A;
A3: x in dom (addreal.:(f,g)) by Lm1;
    thus h.x = (addreal.:(f,g)).x by A2,Def2
      .= addreal.(f.x,g.x) by A3,FUNCOP_1:28
      .= f.x + g.x by BINOP_2:def 9;
  end;
  now
    assume
A4: for x being Element of A holds h.x=f.x + g.x;
    now
      let x be Element of A;
A5:   x in dom (addreal.:(f,g)) by Lm1; thus
      ((RealFuncAdd A).(f,g)).x = (addreal.:(f,g)).x by Def2
        .= addreal.(f.x,g.x) by A5,FUNCOP_1:28
        .= f.x + g.x by BINOP_2:def 9
        .= h.x by A4;
    end;
    hence h = (RealFuncAdd A).(f,g) by FUNCT_2:113;
  end;
  hence thesis by A1;
end;

theorem Th11:
  h = (RealFuncMult(A)).(f,g) iff
  for x being Element of A holds h.x = f.x * g.x
proof
A1: now
    assume
A2: h = (RealFuncMult(A)).(f,g);
    let x be Element of A;
A3: x in dom (multreal.:(f,g)) by Lm1;
    thus h.x = (multreal.:(f,g)).x by A2,Def3
      .= multreal.(f.x,g.x) by A3,FUNCOP_1:28
      .= f.x * g.x by BINOP_2:def 11;
  end;
  now
    assume
A4: for x being Element of A holds h.x=f.x * g.x;
    now
      let x be Element of A;
A5:   x in dom (multreal.:(f,g)) by Lm1; thus
      ((RealFuncMult(A)).(f,g)).x = (multreal.:(f,g)).x by Def3
        .= multreal.(f.x,g.x) by A5,FUNCOP_1:28
        .= f.x * g.x by BINOP_2:def 11
        .= h.x by A4;
    end;
    hence h = (RealFuncMult(A)).(f,g) by FUNCT_2:113;
  end;
  hence thesis by A1;
end;

canceled 2;

theorem
  RealFuncZero(A) <> RealFuncUnit(A)
proof consider a being Element of A;
  (RealFuncZero(A)).a=0 & (RealFuncUnit(A)).a=1 by FUNCOP_1:13;
  hence thesis;
end;

reserve a,b for Real;

theorem Th15:
  h = (RealFuncExtMult A).[a,f] iff
  for x being Element of A holds h.x = a*(f.x)
proof
  thus h = (RealFuncExtMult A).[a,f] implies
   for x being Element of A holds h.x = a*(f.x)
  proof assume h = (RealFuncExtMult A).[a,f];
    then
Z:  h = (RealFuncExtMult A).(a,f);
   let x be Element of A;
   thus h.x = (multreal[;](a,f)).x by Z,Def4
      .= multreal.(a,f.x) by FUNCOP_1:66
      .= a*(f.x) by BINOP_2:def 11;
  end;
  now
    assume
A1: for x being Element of A holds h.x = a*(f.x);
    for x being Element of A holds h.x = ((RealFuncExtMult A).[a,f]).x
    proof
B:   multreal[;](a,f) = (RealFuncExtMult A).(a,f) by Def4;
      let x be Element of A;
      thus h.x = a*(f.x) by A1
        .= multreal.(a,f.x) by BINOP_2:def 11
        .= ((RealFuncExtMult A).[a,f]).x by B,FUNCOP_1:66;
    end;
    hence h = (RealFuncExtMult A).(a,f) by FUNCT_2:113;
  end;
  hence thesis;
end;

reserve u,v,w for VECTOR of RLSStruct(#Funcs(A,REAL),
    (RealFuncZero(A)),RealFuncAdd(A),RealFuncExtMult(A)#);

theorem Th16:
 for A being set, f,g being Element of Funcs(A,REAL)
 holds (RealFuncAdd A).(f,g) = (RealFuncAdd A).(g,f)
 proof let A be set, f,g be Element of Funcs(A,REAL);
  thus (RealFuncAdd A).(f,g) = addreal.:(f,g) by Def2
     .= addreal.:(g,f) by FUNCOP_1:80
     .= (RealFuncAdd A).(g,f) by Def2;
 end;

theorem Th17:
 for A being set, f,g,h being Element of Funcs(A,REAL) holds
  (RealFuncAdd A).(f,(RealFuncAdd A).(g,h)) =
  (RealFuncAdd A).((RealFuncAdd A).(f,g),h)
 proof let A be set, f,g,h be Element of Funcs(A,REAL);
  thus (RealFuncAdd A).(f,(RealFuncAdd A).(g,h))
     = (RealFuncAdd A).(f,addreal.:(g,h)) by Def2
    .= addreal.:(f,addreal.:(g,h)) by Def2
    .= addreal.:(addreal.:(f,g),h) by FUNCOP_1:76
    .= (RealFuncAdd A).(addreal.:(f,g),h) by Def2
    .= (RealFuncAdd A).((RealFuncAdd A).(f,g),h) by Def2;
 end;

theorem Th18:
  (RealFuncMult(A)).(f,g) = (RealFuncMult(A)).(g,f)
proof
  now
    let x be Element of A;
    thus ((RealFuncMult(A)).(f,g)).x = g.x * f.x by Th11
      .= ((RealFuncMult(A)).(g,f)).x by Th11;
  end;
  hence thesis by FUNCT_2:113;
end;

theorem Th19:
  (RealFuncMult(A)).(f,(RealFuncMult(A)).(g,h)) =
  (RealFuncMult(A)).((RealFuncMult(A)).(f,g),h)
proof
  now
    let x be Element of A; thus
    ((RealFuncMult(A)).(f,(RealFuncMult(A)).(g,h))).x =
    f.x * ((RealFuncMult(A)).(g,h)).x by Th11
      .= f.x * (g.x * h.x) by Th11
      .= (f.x * g.x) * h.x
      .= ((RealFuncMult(A)).(f,g)).x * h.x by Th11
      .= ((RealFuncMult(A)).((RealFuncMult(A)).(f,g),h)).x by Th11;
  end;
  hence thesis by FUNCT_2:113;
end;

theorem Th20:
  (RealFuncMult(A)).(RealFuncUnit(A),f) = f
proof
  now
    let x be Element of A;
    thus ((RealFuncMult(A)).(RealFuncUnit(A),f)).x=
    (RealFuncUnit(A)).x * f.x by Th11
      .=1 * f.x by FUNCOP_1:13
      .= f.x;
  end;
  hence thesis by FUNCT_2:113;
end;

theorem Th21:
 for A being set, f being Element of Funcs(A,REAL) holds
  (RealFuncAdd A).(RealFuncZero(A),f) = f
proof let A be set, f being Element of Funcs(A,REAL);
 per cases;
 suppose A = {};
   then
A:  f = {};
  thus (RealFuncAdd A).(RealFuncZero(A),f)
     = addreal.:(RealFuncZero(A),f) by Def2
    .= f by A;
 end;
 suppose A <> {};
  then reconsider A as non empty set;
  reconsider f as Element of Funcs(A,REAL);
  now
    let x be Element of A;
    thus ((RealFuncAdd A).(RealFuncZero(A),f)).x =
    (RealFuncZero(A)).x + f.x by Th10
      .= 0 + f.x by FUNCOP_1:13
      .= f.x;
  end;
  hence thesis by FUNCT_2:113;
 end;
end;

theorem Th22:
 for A being set, f be Element of Funcs(A,REAL) holds
  (RealFuncAdd A).(f,(RealFuncExtMult A).[-1,f]) = RealFuncZero(A)
proof let A be set, f be Element of Funcs(A,REAL);
 per cases;
 suppose
S: A = {};
  thus (RealFuncAdd A).(f,(RealFuncExtMult A).[-1,f])
     = {} by S
    .= RealFuncZero(A) by S;
 end;
 suppose A <> {};
  then reconsider A as non empty set;
  reconsider f as Element of Funcs(A,REAL);
  now
    let x be Element of A;
    set y=f.x; thus
    ((RealFuncAdd A).(f,(RealFuncExtMult A).[-1,f])).x =
    f.x + ((RealFuncExtMult A).[-1,f]).x by Th10
      .= f.x + ((-1)*y) by Th15
      .= (RealFuncZero(A)).x by FUNCOP_1:13;
  end;
  hence thesis by FUNCT_2:113;
 end;
end;

theorem Th23:
 for A being set, f being Element of Funcs(A,REAL) holds
  (RealFuncExtMult A).(1,f) = f
proof let A be set, f be Element of Funcs(A,REAL);
 per cases;
 suppose A = {};
   then
A:  f = {};
  thus (RealFuncExtMult A).(1,f)
     = multreal[;](1,f) by Def4
    .= f by A;
 end;
 suppose A <> {};
  then reconsider A as non empty set;
  reconsider f as Element of Funcs(A,REAL);
  reconsider g = (RealFuncExtMult A).(1,f) as Element of Funcs(A,REAL);
  now
    let x be Element of A;
    thus g.x = 1*(f.x) by Th15
      .= f.x;
  end;
  hence thesis by FUNCT_2:113;
 end;
end;

theorem Th24:
 for A being set, f being Element of Funcs(A,REAL) holds
  (RealFuncExtMult A).(a,(RealFuncExtMult A).(b,f)) =
  (RealFuncExtMult A).(a*b,f)
proof let A be set, f be Element of Funcs(A,REAL);
 per cases;
 suppose
S: A = {};
   (RealFuncExtMult A).(b,f) = multreal[;](b,f) by Def4;
  hence (RealFuncExtMult A).(a,(RealFuncExtMult A).(b,f))
     = multreal[;](a,multreal[;](b,f)) by Def4
    .= multreal[;](a*b,f) by S
    .= (RealFuncExtMult A).(a*b,f) by Def4;
 end;
 suppose A <> {};
  then reconsider A as non empty set;
  reconsider f as Element of Funcs(A,REAL);
  now
    let x be Element of A;
    thus ((RealFuncExtMult A).[a,(RealFuncExtMult A).[b,f]]).x
    = a*(((RealFuncExtMult A).[b,f]).x) by Th15
      .= a*(b*(f.x)) by Th15
      .= (a*b)*(f.x)
      .= ((RealFuncExtMult A).[a*b,f]).x by Th15;
  end;
  hence thesis by FUNCT_2:113;
 end;
end;

theorem Th25:
 for A being set, f being Element of Funcs(A,REAL) holds
  (RealFuncAdd A).((RealFuncExtMult A).(a,f),(RealFuncExtMult A).(b,f))
  = (RealFuncExtMult A).(a+b,f)
proof let A be set, f be Element of Funcs(A,REAL);
 per cases;
 suppose
S:  A = {};
  thus (RealFuncAdd A).((RealFuncExtMult A).(a,f),(RealFuncExtMult A).(b,f))
     = {} by S
    .= multreal[;](a+b,f) by S
    .= (RealFuncExtMult A).(a+b,f) by Def4;
 end;
 suppose A <> {};
  then reconsider A as non empty set;
  reconsider f as Element of Funcs(A,REAL);
  now
    let x be Element of A; thus
    ((RealFuncAdd A).
    ((RealFuncExtMult A).[a,f],(RealFuncExtMult A).[b,f])).x =
    ((RealFuncExtMult A).[a,f]).x + ((RealFuncExtMult A).[b,f]).x by Th10
      .= a*(f.x) + ((RealFuncExtMult A).[b,f]).x by Th15
      .= a*(f.x) + b*(f.x) by Th15
      .= (a+b)*(f.x)
      .= ((RealFuncExtMult A).[a+b,f]).x by Th15;
  end;
  hence thesis by FUNCT_2:113;
 end;
end;

Lm2:
 for A being set, f,g being Element of Funcs(A,REAL) holds
 (RealFuncAdd A). ((RealFuncExtMult A).(a,f),(RealFuncExtMult A).(a,g))
= (RealFuncExtMult A).(a,(RealFuncAdd A).(f,g))
proof let A be set, f,g be Element of Funcs(A,REAL);
 per cases;
 suppose
S: A = {};
  thus (RealFuncAdd A).((RealFuncExtMult A).(a,f),(RealFuncExtMult A).(a,g))
     = {} by S
    .= multreal[;](a,(RealFuncAdd A).(f,g)) by S
    .= (RealFuncExtMult A).(a,(RealFuncAdd A).(f,g)) by Def4;
 end;
 suppose A <> {};
  then reconsider A as non empty set;
  reconsider f,g as Element of Funcs(A,REAL);
  now
    let x be Element of A;
    thus ((RealFuncAdd A).
    ((RealFuncExtMult A).[a,f],(RealFuncExtMult A).[a,g])).x
    = ((RealFuncExtMult A).[a,f]).x + ((RealFuncExtMult A).[a,g]).x by Th10
      .= a*(f.x) + ((RealFuncExtMult A).[a,g]).x by Th15
      .= a*(f.x) + a*(g.x) by Th15
      .= a*(f.x + g.x)
      .= a*(((RealFuncAdd A).(f,g)).x) by Th10
      .= ((RealFuncExtMult A).[a,(RealFuncAdd A).(f,g)]).x by Th15;
  end;
  hence thesis by FUNCT_2:113;
 end;
end;

theorem Th26:
  (RealFuncMult(A)).(f,(RealFuncAdd A).(g,h)) =
  (RealFuncAdd A).((RealFuncMult(A)).(f,g),(RealFuncMult(A)).(f,h))
proof
  now
    let x be Element of A; thus
    ((RealFuncMult(A)).(f,(RealFuncAdd A).(g,h))).x =
    f.x * (((RealFuncAdd A).(g,h)).x) by Th11
      .= f.x * (g.x + h.x) by Th10
      .= (f.x * g.x) + (f.x * h.x)
      .= ((RealFuncMult(A)).(f,g)).x + (f.x * h.x) by Th11
      .= ((RealFuncMult(A)).(f,g)).x + ((RealFuncMult(A)).(f,h)).x by Th11
      .= ((RealFuncAdd A).
    ((RealFuncMult(A)).(f,g),(RealFuncMult(A)).(f,h))).x by Th10;
  end;
  hence thesis by FUNCT_2:113;
end;

theorem Th27:
  (RealFuncMult(A)).((RealFuncExtMult A).[a,f],g) =
  (RealFuncExtMult A).[a,(RealFuncMult(A)).(f,g)]
proof
  now
    let x be Element of A;
    thus ((RealFuncMult(A)). ((RealFuncExtMult A).[a,f],g)).x
    = ((RealFuncExtMult A).[a,f]).x * g.x by Th11
      .= (a*(f.x)) * g.x by Th15
      .= a*(f.x * g.x)
      .= a*(((RealFuncMult(A)).(f,g)).x) by Th11
      .= ((RealFuncExtMult A).[a,(RealFuncMult(A)).(f,g)]).x by Th15;
  end;
  hence thesis by FUNCT_2:113;
end;

theorem Th28:
  ex f,g st (for z st z in A holds
  (z=x1 implies f.z = 1) & (z<>x1 implies f.z = 0)) & (for z st z in A holds
  (z=x1 implies g.z = 0) & (z<>x1 implies g.z = 1))
proof
  defpred P[set] means $1 = x1;
  deffunc F(set) = 0;
  deffunc G(set) = 1;
A1: for z st z in A holds
  (P[z] implies G(z) in REAL) & (not P[z] implies F(z) in REAL);
  consider f being Function of A,REAL such that
A2: for z st z in A holds
  (P[z] implies f.z = G(z)) & (not P[z] implies f.z = F(z))
  from FUNCT_2:sch 5(A1);
A3: for z st z in A holds
  (P[z] implies F(z) in REAL) & (not P[z] implies G(z) in REAL);
  consider g being Function of A,REAL such that
A4: for z st z in A holds
  (P[z] implies g.z = F(z)) & (not P[z] implies g.z = G(z))
  from FUNCT_2:sch 5(A3);
  reconsider f,g as Element of Funcs(A,REAL) by FUNCT_2:11;
  take f,g; thus thesis by A2,A4;
end;

theorem Th29:
  (x1 in A & x2 in A & x1<>x2) & (for z st z in A holds
  (z=x1 implies f.z = 1) & (z<>x1 implies f.z = 0)) & (for z st z in A holds
  (z=x1 implies g.z = 0) & (z<>x1 implies g.z = 1)) implies
  (for a,b st (RealFuncAdd A).
  ((RealFuncExtMult A).[a,f],(RealFuncExtMult A).[b,g]) = RealFuncZero(A)
  holds a=0 & b=0)
proof
  assume that
A1: x1 in A & x2 in A & x1<>x2 and
A2: for z st z in A holds (z=x1 implies f.z = 1) & (z<>x1 implies f.z = 0) and
A3: for z st z in A holds (z=x1 implies g.z = 0) & (z<>x1 implies g.z = 1);
A4: f.x1=1 & f.x2=0 & g.x1=0 & g.x2=1 by A1,A2,A3;
  reconsider x1,x2 as Element of A by A1;
  let a,b;
  assume
A5: (RealFuncAdd A).
  ((RealFuncExtMult A).[a,f],(RealFuncExtMult A).[b,g]) = RealFuncZero(A);
  then
A6: 0 = ((RealFuncAdd A).
  ((RealFuncExtMult A).[a,f],(RealFuncExtMult A).[b,g])).x1 by FUNCOP_1:13
    .= (((RealFuncExtMult A).[a,f]).x1) +
  (((RealFuncExtMult A).[b,g]).x1) by Th10
    .= a*(f.x1) + (((RealFuncExtMult A).[b,g]).x1) by Th15
    .= a + b*0 by A4,Th15
    .= a;
  0 = ((RealFuncAdd A).
  ((RealFuncExtMult A).[a,f],(RealFuncExtMult A).[b,g])).x2 by A5,FUNCOP_1:13
    .= (((RealFuncExtMult A).[a,f]).x2) +
  (((RealFuncExtMult A).[b,g]).x2) by Th10
    .= a*(f.x2) + (((RealFuncExtMult A).[b,g]).x2) by Th15
    .=0 + b*1 by A4,Th15
    .= b;
  hence thesis by A6;
end;

theorem
  x1 in A & x2 in A & x1<>x2 implies (ex f,g st for a,b st (RealFuncAdd A).
  ((RealFuncExtMult A).[a,f],(RealFuncExtMult A).[b,g]) = RealFuncZero(A)
  holds a=0 & b=0)
proof
  assume
A1: x1 in A & x2 in A & x1<>x2;
  consider f,g such that
A2: for z st z in A holds (z=x1 implies f.z = 1) & (z<>x1 implies f.z = 0) and
A3: for z st z in A holds
  (z=x1 implies g.z = 0) & (z<>x1 implies g.z = 1) by Th28;
  take f,g;
  let a,b;
  assume (RealFuncAdd A).
  ((RealFuncExtMult A).[a,f],(RealFuncExtMult A).[b,g]) = RealFuncZero(A);
  hence thesis by A1,A2,A3,Th29;
end;

theorem Th31:
  A = {x1,x2} & x1<>x2 & (for z st z in A holds
  (z=x1 implies f.z = 1) & (z<>x1 implies f.z = 0)) & (for z st z in A holds
  (z=x1 implies g.z = 0) & (z<>x1 implies g.z = 1)) implies for h holds
  (ex a,b st h = (RealFuncAdd A).
  ((RealFuncExtMult A).[a,f],(RealFuncExtMult A).[b,g]))
proof
  assume that
A1: A = {x1,x2} & x1<>x2 and
A2: for z st z in A holds (z=x1 implies f.z = 1) & (z<>x1 implies f.z = 0) and
A3: for z st z in A holds (z=x1 implies g.z = 0) & (z<>x1 implies g.z = 1);
  x1 in A & x2 in A by A1,TARSKI:def 2;
  then
A4: f.x1=1 & f.x2=0 & g.x1=0 & g.x2=1 by A1,A2,A3;
  reconsider x1,x2 as Element of A by A1,TARSKI:def 2;
  let h;
  take a = h.x1, b = h.x2;
  now
    let x be Element of A;
A5: x = x1 or x = x2 by A1,TARSKI:def 2;
A6: ((RealFuncAdd A).
    ((RealFuncExtMult A).[a,f],(RealFuncExtMult A).[b,g])).x1
    = (((RealFuncExtMult A).[a,f]).x1) +
    (((RealFuncExtMult A).[b,g]).x1) by Th10
      .= a*(f.x1) + (((RealFuncExtMult A).[b,g]).x1) by Th15
      .= a + b*0 by A4,Th15
      .= h.x1;
    ((RealFuncAdd A).
    ((RealFuncExtMult A).[a,f],(RealFuncExtMult A).[b,g])).x2
    = (((RealFuncExtMult A).[a,f]).x2) +
    (((RealFuncExtMult A).[b,g]).x2) by Th10
      .= a*(f.x2) + (((RealFuncExtMult A).[b,g]).x2) by Th15
      .= 0 + b*1 by A4,Th15
      .= h.x2;
    hence h.x = ((RealFuncAdd A).
    ((RealFuncExtMult A).[a,f],(RealFuncExtMult A).[b,g])).x by A5,A6;
  end;
  hence thesis by FUNCT_2:113;
end;

theorem
  A = {x1,x2} & x1<>x2 implies ex f,g st (for h holds (ex a,b st h =
  (RealFuncAdd A). ((RealFuncExtMult A).[a,f],(RealFuncExtMult A).[b,g])))
proof
  assume
A1: A = {x1,x2} & x1<>x2;
  consider f,g such that
A2: for z st z in A holds (z=x1 implies f.z = 1) & (z<>x1 implies f.z =0) and
A3: for z st z in A holds
  (z=x1 implies g.z = 0) & (z<>x1 implies g.z = 1) by Th28;
  take f,g;
  let h; thus thesis by A1,A2,A3,Th31;
end;

theorem Th33:
  (A = {x1,x2} & x1<>x2) implies (ex f,g st (for a,b st
  (RealFuncAdd A).((RealFuncExtMult A).[a,f],
  (RealFuncExtMult A).[b,g]) = RealFuncZero(A) holds a=0 & b=0) &
  (for h holds (ex a,b st h = (RealFuncAdd A).
  ((RealFuncExtMult A).[a,f],(RealFuncExtMult A).[b,g]))))
proof
  assume
A1: A = {x1,x2} & x1<>x2;
  then
A2: x1 in A & x2 in A & x1<>x2 by TARSKI:def 2;
  consider f,g such that
A3: for z st z in A holds (z=x1 implies f.z = 1) & (z<>x1 implies f.z =0) and
A4: for z st z in A holds
  (z=x1 implies g.z = 0) & (z<>x1 implies g.z = 1) by Th28;
  take f,g;
  thus thesis by A1,A2,A3,A4,Th29,Th31;
end;

definition
  let A be set;
  func RealVectSpace(A) -> strict RealLinearSpace equals
  RLSStruct(#Funcs(A,REAL),
    (RealFuncZero(A)),RealFuncAdd(A),RealFuncExtMult(A)#);
  coherence
   proof
    set S =
     RLSStruct(#Funcs(A,REAL),
       (RealFuncZero(A)),RealFuncAdd(A),RealFuncExtMult(A)#);
X1:  S is Abelian
      proof let u,v be Element of S;
       thus thesis by Th16;
      end;
X2:  S is add-associative
      proof let u,v,w be Element of S;
       thus thesis by Th17;
      end;
X4:  S is right_zeroed
    proof let u be Element of S;
      reconsider u'=u as Element of Funcs(A,REAL);
      thus u+0.S = (RealFuncAdd A).(RealFuncZero(A),u') by Th16
        .= u by Th21;
    end;
X5:  S is right_complementable
    proof
      let u be Element of S;
      reconsider u' = u as Element of Funcs(A,REAL);
      reconsider w = (RealFuncExtMult A).[-1,u'] as VECTOR of S;
      take w;
      thus thesis by Th22;
    end;
     S is RealLinearSpace-like
      proof
       thus for a being real number for v,w being Element of S
        holds a * (v + w) = a * v + a * w
       proof let a be real number;
         reconsider a as Real by XREAL_0:def 1;
        for v,w being Element of S
        holds a * (v + w) = a * v + a * w by Lm2;
        hence thesis;
       end;
       thus for a,b being real number for v being Element of S
        holds (a + b) * v = a * v + b * v
       proof let a,b be real number;
         reconsider a,b as Real by XREAL_0:def 1;
         for v being Element of S
        holds (a + b) * v = a * v + b * v by Th25;
        hence thesis;
       end;
       thus for a,b being real number for v being Element of S
        holds (a * b) * v = a * (b * v)
       proof let a,b be real number;
         reconsider a,b as Real by XREAL_0:def 1;
         for v being Element of S
        holds (a * b) * v = a * (b * v) by Th24;
        hence thesis;
       end;
       let v being Element of S;
       thus 1 * v = v by Th23;
      end;
    hence thesis by X1,X2,X4,X5;
   end;
end;

canceled 3;

theorem
  ex V being strict RealLinearSpace st (ex u,v being Element of V st
  (for a,b st a*u + b*v = 0.V holds a=0 & b=0) &
  (for w being Element of V ex a,b st w = a*u + b*v))
proof set A ={0,1};
  take V = RealVectSpace(A);
  consider f,g being Element of Funcs(A,REAL) such that
A2: (for a,b st (RealFuncAdd A).((RealFuncExtMult A).[a,f],
  (RealFuncExtMult A).[b,g]) = RealFuncZero(A) holds a=0 & b=0) &
  (for h being Element of Funcs(A,REAL) holds (ex a,b st h = (RealFuncAdd A).
  ((RealFuncExtMult A).[a,f],(RealFuncExtMult A).[b,g]))) by Th33;
  reconsider u=f, v=g as Element of V;
  take u,v;
  thus for a,b st a*u + b*v = 0.V holds a=0 & b=0 by A2;
  thus for w being Element of V ex a,b st w = a*u + b*v
  proof
    let w be Element of V;
    reconsider h=w as Element of Funcs(A,REAL);
    consider a,b such that
A3: h = (RealFuncAdd A).((RealFuncExtMult A).[a,f],
    (RealFuncExtMult A).[b,g]) by A2;
    h = a*u + b*v by A3;
    hence thesis;
  end;
end;

definition
  let A;
  canceled 4;
  func RRing(A) -> strict doubleLoopStr equals
  doubleLoopStr(#Funcs(A,REAL),RealFuncAdd A,RealFuncMult A,
    RealFuncUnit A,RealFuncZero A#);
  correctness;
end;

registration
  let A;
  cluster RRing A -> non empty;
  coherence;
end;

Lm4: now
  let A;
  set FR = RRing(A);
  let h, a be Element of FR;
  assume
A1: a = RealFuncUnit(A);
  reconsider g = h as Element of Funcs(A,REAL);
  thus h * a = (RealFuncMult(A)).(RealFuncUnit(A),g) by A1,Th18
    .= h by Th20;
  thus a * h = h by A1,Th20;
end;

registration
  let A;
  cluster RRing(A) -> unital;
  coherence
  proof
    reconsider e = RealFuncUnit(A) as Element of RRing(A);
    take e;
    thus thesis by Lm4;
  end;
end;

canceled 3;

theorem
  1.RRing(A) = RealFuncUnit(A);

theorem Th42:
  for x,y,z being Element of RRing(A) holds x+y = y+x & (x+y)+z = x+(y+z) &
  x+(0.RRing(A)) = x & (ex t being Element of RRing(A) st x+t=(0.RRing(A))) &
  x*y = y*x & (x*y)*z = x*(y*z) & x*(1.RRing(A)) = x & (1.RRing(A))*x = x &
  x*(y+z) = x*y + x*z & (y+z)*x = y*x + z*x
proof
  let x,y,z be Element of RRing(A);
  set IT = RRing(A);
  reconsider f=x as Element of Funcs(A,REAL);
  thus x+y = y+x by Th16;
  thus (x+y)+z = x+(y+z) by Th17;
  thus x+(0.RRing(A)) = (RealFuncAdd A).(RealFuncZero(A),f) by Th16
    .= x by Th21;
  thus ex t being Element of RRing(A) st x+t=(0.RRing(A))
  proof
    set h = (RealFuncExtMult A).[-1,f];
    reconsider t=h as Element of IT;
    take t;
    thus thesis by Th22;
  end;
  thus x*y = y*x by Th18;
  thus (x*y)*z = x*(y*z) by Th19;
  thus x*(1.RRing(A)) = (RealFuncMult(A)).(RealFuncUnit(A),f) by Th18
    .= x by Th20;
  hence (1.RRing(A))*x = x by Th18;
  thus x*(y+z) = x*y + x*z by Th26;
  hence (y+z)*x = x*y + x*z by Th18
    .= y*x + x*z by Th18
    .= y*x + z*x by Th18;
end;

registration
  cluster strict Abelian add-associative right_zeroed right_complementable
    associative commutative right_unital right-distributive
    (non empty doubleLoopStr);
  existence
  proof
    take L = Trivial-doubleLoopStr;
    thus L is strict;
    thus L is Abelian
    proof
      let x be Element of L;
      thus thesis by STRUCT_0:def 10;
    end;
    thus L is add-associative
    proof
      let x be Element of L;
      thus thesis by STRUCT_0:def 10;
    end;
    thus L is right_zeroed
    proof
      let x be Element of L;
      thus thesis by STRUCT_0:def 10;
    end;
    thus L is right_complementable
    proof
      let x be Element of L;
      take x;
      thus thesis by STRUCT_0:def 10;
    end;
    thus L is associative
    proof
      let x be Element of L;
      thus thesis by STRUCT_0:def 10;
    end;
    thus L is commutative
    proof
      let x be Element of L;
      thus thesis by STRUCT_0:def 10;
    end;
    thus L is right_unital
    proof
      let x be Element of L;
      thus thesis by STRUCT_0:def 10;
    end;
    let x be Element of L;
    thus thesis by STRUCT_0:def 10;
  end;
end;

definition
  mode Ring is Abelian add-associative right_zeroed right_complementable
    associative well-unital distributive (non empty doubleLoopStr);
end;

theorem
  RRing(A) is commutative Ring
proof
A1: RRing A is commutative
  proof
    let x be Element of RRing A; thus thesis by Th42;
  end;
A2: RRing A is Abelian
  proof
    let x be Element of RRing A; thus thesis by Th42;
  end;
A3: RRing A is add-associative
  proof
    let x be Element of RRing A; thus thesis by Th42;
  end;
A4: RRing A is right_zeroed
  proof
    let x be Element of RRing A; thus thesis by Th42;
  end;
A5: RRing A is right_complementable
  proof
    let x be Element of RRing A;
    consider t being Element of RRing A such that
A6: x+t = 0.RRing(A) by Th42;
    take t;
    thus thesis by A6;
  end;
A7: RRing A is associative
  proof
    let x be Element of RRing A; thus thesis by Th42;
  end;
A8: RRing A is well-unital
  proof
    let x be Element of RRing A; thus thesis by Th42;
  end;
  RRing A is distributive
  proof
    let x be Element of RRing A; thus thesis by Th42;
  end;
  hence thesis by A1,A2,A3,A4,A5,A7,A8;
end;

definition
  struct(doubleLoopStr,RLSStruct) AlgebraStr (# carrier -> set,
    multF,addF -> (BinOp of the carrier),
    Mult -> (Function of [:REAL,the carrier:],the carrier),
    OneF,ZeroF -> Element of the carrier #);
end;

registration
  cluster non empty AlgebraStr;
  existence
  proof
    consider X being non empty set, m,a being BinOp of X,
    M being Function of [:REAL,X:],X, u,Z being Element of X;
    take AlgebraStr(#X,m,a,M,u,Z#);
    thus the carrier of AlgebraStr(#X,m,a,M,u,Z#) is non empty;
  end;
end;

definition
  let A;
  canceled 6;
  func RAlgebra(A) -> strict AlgebraStr equals
  AlgebraStr(#Funcs(A,REAL),RealFuncMult(A),RealFuncAdd(A),
    RealFuncExtMult(A),(RealFuncUnit(A)),(RealFuncZero(A))#);
  correctness;
end;

registration
  let A;
  cluster RAlgebra(A) -> non empty;
  coherence
  proof
    thus the carrier of RAlgebra A is non empty;
  end;
end;

Lm5: now
  let A;
  set F = RAlgebra(A);
  let x, e be Element of F;
  assume
A1: e = RealFuncUnit(A);
  reconsider f = x as Element of Funcs(A,REAL);
  thus x * e = (RealFuncMult(A)).(RealFuncUnit(A),f) by A1,Th18
    .= x by Th20;
  thus e * x = x by A1,Th20;
end;

registration
  let A;
  cluster RAlgebra(A) -> unital;
  coherence
  proof
    reconsider e = RealFuncUnit(A) as Element of RAlgebra(A);
    take e;
    thus thesis by Lm5;
  end;
end;

theorem
  1.RAlgebra(A) = RealFuncUnit(A);

canceled 4;

theorem Th49:
  for x,y,z being Element of RAlgebra(A) for a,b holds x+y = y+x &
  (x+y)+z = x+(y+z) & x+(0.RAlgebra(A)) = x & x*y = y*x & (x*y)*z = x*(y*z) &
  x*(1.RAlgebra(A)) = x & x*(y+z) = x*y + x*z & a*(x*y) = (a*x)*y &
  a*(x+y) = a*x + a*y & (a+b)*x = a*x + b*x & (a*b)*x = a*(b*x)
proof
  let x,y,z be Element of RAlgebra(A);
  let a,b;
  reconsider f=x as Element of Funcs(A,REAL);
  thus x+y = y+x by Th16;
  thus (x+y)+z = x+(y+z) by Th17;
  thus x+(0.RAlgebra(A)) = (RealFuncAdd A).(RealFuncZero(A),f) by Th16
    .= x by Th21;
  thus x*y = y*x by Th18;
  thus (x*y)*z = x*(y*z) by Th19;
  thus x*(1.RAlgebra(A)) = (RealFuncMult(A)).(RealFuncUnit(A),f) by Th18
    .= x by Th20;
  thus x*(y+z) = x*y + x*z by Th26;
  thus a*(x*y) = (a*x)*y by Th27;
  thus a*(x+y) = (a*x) + (a*y) by Lm2;
  thus (a+b)*x = (a*x) + (b*x) by Th25;
  thus thesis by Th24;
end;

definition
  let IT be non empty AlgebraStr;
  attr IT is Algebra-like means
  :Def20:
  for x,y,z being Element of IT
  for a,b holds
  a*(x*y) = (a*x)*y & a*(x+y) = a*x + a*y & (a+b)*x = a*x + b*x &
  (a*b)*x = a*(b*x);
end;

Lm6: RAlgebra A is right_complementable
proof
  let x be Element of RAlgebra A;
  reconsider f=x as Element of Funcs(A,REAL);
  set h = (RealFuncExtMult A).[-1,f];
  reconsider t=h as Element of RAlgebra A;
  take t;
  thus thesis by Th22;
end;

registration
  cluster strict Abelian add-associative right_zeroed right_complementable
    commutative associative right_unital right-distributive
    Algebra-like (non empty AlgebraStr);
  existence
  proof consider A;
    for x,y,z being Element of RAlgebra(A) for a,b holds x+y = y+x &
    (x+y)+z = x+(y+z) & x+(0.RAlgebra(A)) = x & x*y = y*x &
    (x*y)*z = x*(y*z) & x*(1.RAlgebra(A)) = x & x*(y+z) = x*y + x*z &
    a*(x*y) = (a*x)*y & a*(x+y) = a*x + a*y & (a+b)*x = a*x + b*x &
    (a*b)*x = a*(b*x) by Th49;
    then RAlgebra(A) is Abelian add-associative right_zeroed
    right_complementable right_unital right-distributive
    Algebra-like commutative associative
    by Def20,Lm6,GROUP_1:def 4,def 16,RLVECT_1:def 5,def 6,def 7
    ,VECTSP_1:def 11,def 13;
    hence thesis;
  end;
end;

definition
  mode Algebra is Abelian add-associative right_zeroed right_complementable
    commutative associative right_unital right-distributive
    Algebra-like (non empty AlgebraStr);
end;

theorem
  RAlgebra(A) is Algebra
proof
  for x,y,z being Element of RAlgebra(A) for a,b holds x+y = y+x &
  (x+y)+z = x+(y+z) & x+(0.RAlgebra(A)) = x & x*y = y*x & (x*y)*z = x*(y*z) &
  x*(1.RAlgebra(A)) = x & x*(y+z) = x*y + x*z & a*(x*y) = (a*x)*y &
  a*(x+y) = a*x + a*y & (a+b)*x = a*x + b*x & (a*b)*x = a*(b*x) by Th49;
  hence thesis by Def20,Lm6,GROUP_1:def 4,def 16,RLVECT_1:def 5,def 6,def 7
  ,VECTSP_1:def 11,def 13;
end;

