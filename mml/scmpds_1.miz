:: A Small Computer Model with Push-Down Stack
::  by JingChao Chen
::
:: Received June 15, 1999
:: Copyright (c) 1999 Association of Mizar Users

environ

 vocabularies GR_CY_1, AMI_2, INT_1, FINSEQ_1, FUNCT_1, RELAT_1, TARSKI, BOOLE,
      NAT_1, CARD_3, AMI_1, FUNCT_4, CAT_1, ABSVALUE, ARYTM_1, MCART_1,
      CQC_LANG, FUNCT_2, FUNCT_5, SCMPDS_1, FINSEQ_4;
 notations TARSKI, XBOOLE_0, ENUMSET1, ZFMISC_1, SUBSET_1, RELAT_1, FUNCT_1,
      CARD_1, FUNCT_2, BINOP_1, MCART_1, NUMBERS, XCMPLX_0, CARD_3, INT_1,
      NAT_1, NAT_D, FINSEQ_1, FRAENKEL, FINSEQ_4, FUNCOP_1, FUNCT_4, CAT_2,
      AMI_2, INT_2, XXREAL_0;
 constructors ENUMSET1, XXREAL_0, REAL_1, NAT_1, NAT_D, MEMBERED, INT_2,
      FINSEQ_4, CAT_2, AMI_1, AMI_2;
 registrations XBOOLE_0, SUBSET_1, SETFAM_1, ORDINAL1, RELSET_1, FUNCOP_1,
      FRAENKEL, NUMBERS, XREAL_0, NAT_1, INT_1, MEMBERED, FINSEQ_1, CARD_3,
      GR_CY_1, AMI_2, AFINSQ_1;
 requirements NUMERALS, REAL, SUBSET, BOOLE, ARITHM;
 definitions TARSKI, FINSEQ_1, FUNCOP_1;
 theorems AMI_1, AMI_2, CAT_2, CARD_3, FUNCOP_1, ENUMSET1, FINSEQ_1, FINSEQ_3,
      FINSEQ_4, FUNCT_1, FUNCT_2, FUNCT_4, GR_CY_1, MCART_1, NAT_1, SCHEME1,
      TARSKI, ZFMISC_1, INT_1, ABSVALUE, XBOOLE_0, XBOOLE_1, COMPLEX1,
      ORDINAL1, NAT_D;
 schemes FUNCT_2, BINOP_1;

begin :: Preliminaries

reserve x1,x2,x3,x4,x5 for set,
        i, j, k for Element of NAT,
        I,I2,I3,I4 for Element of Segm 14,
        i1 for Element of SCM-Instr-Loc,
        d1,d2,d3,d4,d5 for Element of SCM-Data-Loc,
        k1,k2 for Integer;

reserve ND for non empty set;
reserve y1,y2,y3,y4,y5 for Element of ND;
reserve p for FinSequence;

canceled 8;

theorem Th9:
 for k be Integer holds k in union {INT} \/ NAT
proof
   let k be Integer;
A1: k in INT by INT_1:def 2;
      union {INT} = INT by ZFMISC_1:31;
   then INT c= union {INT} \/ NAT by XBOOLE_1:7;
   hence thesis by A1;
end;

theorem Th10:
 for k be Integer holds k in SCM-Data-Loc \/ INT
proof
   let k be Integer;
A1: k in INT by INT_1:def 2;
      INT c= SCM-Data-Loc \/ INT by XBOOLE_1:7;
   hence thesis by A1;
end;

theorem
 for d be Element of SCM-Data-Loc holds d in SCM-Data-Loc \/ INT
proof
   let d be Element of SCM-Data-Loc;
      SCM-Data-Loc c= SCM-Data-Loc \/ INT by XBOOLE_1:7;
   hence thesis by TARSKI:def 3;
end;

begin  :: The construction of SCM with Push-Down Stack
:: [0,goto L]
:: [1,return sp<-sp+0,count<-(sp)+2]
:: [2,a:=c(constant)]
:: [3,saveIC (a,k)]
:: [4,if(a,k)<>0 goto L ]
:: [5,if(a,k)<=0 goto L ]
:: [6,if(a,k)>=0 goto L ]
:: [7,(a,k):=c(constant) ]
:: [8,(a,k1)+k2]
:: [9, (a1,k1)+(a2,k2)]
:: [10,(a1,k1)-(a2,k2)]
:: [11,(a1,k1)*(a2,k2)]
:: [12,(a1,k1)/(a2,k2)]
:: [13,(a1,k1):=(a2,k2)]

definition
 canceled 2;

 func SCMPDS-Instr ->
          Subset of [: NAT, (union {INT} \/ NAT)* :] equals
  { [0,<*l*>] where l is Element of INT: not contradiction} \/
  { [1,<*sp*>] where sp is Element of SCM-Data-Loc:not contradiction} \/
  { [I,<*v,c*>] where I is Element of Segm 14,v is Element of SCM-Data-Loc,
         c is Element of INT: I in {2,3} } \/
  { [I,<*v,c1,c2*>] where I is Element of Segm 14,
                    v is Element of SCM-Data-Loc,
                    c1,c2 is Element of INT: I in {4,5,6,7,8} } \/
  { [I,<*v1,v2,c1,c2*>] where I is Element of Segm 14,
                    v1,v2 is Element of SCM-Data-Loc,
                    c1,c2 is Element of INT: I in {9,10,11,12,13} };
coherence
  proof
   set U1=union {INT} \/ NAT;
   set UU=[: NAT, U1* :];
A1: NAT c= U1 by XBOOLE_1:7;
A2: { [I1,<*d1,d2,k1,k2*>] where I1 is Element of Segm 14,
                    d1,d2 is Element of SCM-Data-Loc,
                    k1,k2 is Element of INT: I1 in {9,10,11,12,13}} c= UU
     proof
      let x be set;
      assume x in { [I1,<*d1,d2,k1,k2*>] where I1 is Element of Segm 14,
                    d1,d2 is Element of SCM-Data-Loc,
                    k1,k2 is Element of INT: I1 in {9,10,11,12,13} };
      then consider I1 being Element of Segm 14,
               d1,d2 being Element of SCM-Data-Loc,
               k1,k2 being Element of INT such that
A3:     x = [I1,<*d1,d2,k1,k2*>] and I1 in {9,10,11,12,13};
      reconsider d1,d2 as Element of U1 by A1,TARSKI:def 3;
      reconsider k1,k2 as Element of U1 by Th9;
         <*d1,d2,k1,k2*> in U1* by FINSEQ_1:def 11;
      hence thesis by A3,ZFMISC_1:106;
    end;

A4: { [I2,<*d3,k3,k4*>] where I2 is Element of Segm 14,
                    d3 is Element of SCM-Data-Loc,
                    k3,k4 is Element of INT: I2 in {4,5,6,7,8}} c= UU
    proof
      let x be set;
      assume x in { [I2,<*d3,k3,k4*>] where I2 is Element of Segm 14,
                    d3 is Element of SCM-Data-Loc,
                    k3,k4 is Element of INT : I2 in {4,5,6,7,8} };
      then consider I2 being Element of Segm 14,
               d3 being Element of SCM-Data-Loc,
               k3,k4 being Element of INT such that
A5:     x = [I2,<*d3,k3,k4*>] and I2 in {4,5,6,7,8};
      reconsider d3 as Element of U1 by A1,TARSKI:def 3;
      reconsider k3,k4 as Element of U1 by Th9;
         <*d3,k3,k4*> in U1* by FINSEQ_1:def 11;
      hence thesis by A5,ZFMISC_1:106;
    end;

A6: { [0,<*k5*>] where k5 is Element of INT: not contradiction } c= UU
    proof
      let x be set;
      assume x in { [0,<*k5*>] where k5 is Element of INT: not contradiction }
;
      then consider k5 being Element of INT such that
A7:     x = [0,<*k5*>] and not contradiction;
      reconsider k5 as Element of U1 by Th9;
         <*k5*> in U1* by FINSEQ_1:def 11;
      hence thesis by A7,ZFMISC_1:106;
    end;

A8: { [1,<*d4*>] : not contradiction } c= UU
    proof
      let x be set;
      assume x in { [1,<*d4*>] : not contradiction };
      then consider d4 such that
A9:     x = [1,<*d4*>] and not contradiction;
      reconsider d4 as Element of U1 by A1,TARSKI:def 3;
         <*d4*> in U1* by FINSEQ_1:def 11;
      hence thesis by A9,ZFMISC_1:106;
    end;

A10: { [I4,<*d5,r*>] where I4 is Element of Segm 14,
                    d5 is Element of SCM-Data-Loc,
                    r is Element of INT : I4 in {2,3} } c=UU
    proof
      let x be set;
      assume x in { [I4,<*d5,r*>] where I4 is Element of Segm 14,
                    d5 is Element of SCM-Data-Loc,
                    r is Element of INT : I4 in {2,3} };
      then consider I4 being Element of Segm 14,
               d5 being Element of SCM-Data-Loc,
               r being Element of INT such that
A11:    x = [I4,<*d5,r*>] and I4 in {2,3};
      reconsider d5, r as Element of U1 by Th9;
         <*d5,r*> in U1* by FINSEQ_1:def 11;
      hence thesis by A11,ZFMISC_1:106;
    end;

   set S1={ [0,<*k5*>] where k5 is Element of INT: not contradiction },
       S2={ [1,<*d4*>] : not contradiction },
       S3={ [I4,<*d5,r*>] where I4 is Element of Segm 14,
                    d5 is Element of SCM-Data-Loc,
                    r is Element of INT : I4 in {2,3} };
      S1 \/ S2 c= UU by A6,A8,XBOOLE_1:8;
   then S1 \/ S2 \/ S3 c= UU by A10,XBOOLE_1:8;
   then S1 \/ S2 \/ S3 \/ { [I2,<*d3,k3,k4*>] where I2 is Element of Segm 14,
                    d3 is Element of SCM-Data-Loc,
                    k3,k4 is Element of INT: I2 in {4,5,6,7,8}} c= UU
   by A4,XBOOLE_1:8;
   hence thesis by A2,XBOOLE_1:8;
  end;
end;

canceled;

theorem Th13:
 [0,<*0*>] in SCMPDS-Instr
proof
 set S1={ [0,<*k1*>] where k1 is Element of INT: not contradiction},
     S2={ [1,<*d1*>] : not contradiction},
     S3={ [I2,<*d2,k2*>] where I2 is Element of Segm 14,
                    d2 is Element of SCM-Data-Loc,
                    k2 is Element of INT : I2 in {2,3} };
    0 is Element of INT by INT_1:def 2;
 then [0,<*0*>] in S1;
 then [0,<*0*>] in S1 \/ S2 by XBOOLE_0:def 2;
 then [0,<*0*>] in S1 \/ S2 \/ S3 by XBOOLE_0:def 2;
 then [0,<*0*>] in S1 \/ S2 \/ S3 \/ { [I3,<*d3,k3,k4*>]
              where I3 is Element of Segm 14,
                    d3 is Element of SCM-Data-Loc,
                    k3,k4 is Element of INT: I3 in {4,5,6,7,8} }
    by XBOOLE_0:def 2;
 hence [0,<*0*>] in SCMPDS-Instr by XBOOLE_0:def 2;
end;

registration
 cluster SCMPDS-Instr -> non empty;
 coherence by Th13;
end;

theorem Th14:
 k = 0 or (ex j be Element of NAT st k = 2*j+1) or
   (ex j be Element of NAT st k = 2*j+2)
proof
  consider i be Element of NAT such that
A1:   k = 2*i or k = 2*i+1 by SCHEME1:1;
     now assume
A2:  k = 2*i;
A3:  i = 0 or ex j be Nat st i = j + 1 by NAT_1:6;
     now given j be Nat such that
A4:    i = j + 1;
     reconsider j as Element of NAT by ORDINAL1:def 13;
     take j;
     thus k = 2*j + 2*1 by A2,A4;
    end;
   hence k = 0 or ex j be Element of NAT st k = 2*j+2 by A2,A3;
  end;
 hence thesis by A1;
end;

canceled;

theorem Th16:
  ((ex j st k = 2*j+1) implies k<>0 & not (ex j st k = 2*j+2)) &
  ((ex j st k = 2*j+2) implies k<>0 & not (ex j st k = 2*j+1))
proof
 thus (ex j st k = 2*j+1) implies k<>0 & not (ex j st k = 2*j+2)
  proof given j such that
A1:  k = 2*j+1;
   thus k<>0 by A1;
   given i such that
A2:  k = 2*i+2;
A3:  (2*i+2*1) = 2*(i+1) + 0;
       1 = (2*i+2) mod 2 by A1,A2,NAT_D:def 2
          .= 0 by A3,NAT_D:def 2;
   hence thesis;
  end;
  thus (ex j st k = 2*j+2) implies k<>0 & not (ex j st k = 2*j+1)
  proof
    given j such that
A4:  k = 2*j+2;
  thus k<>0 by A4;
  given i such that
A5:  k = 2*i+1;
A6:  (2*j+2*1) = 2*(j+1) + 0;
     1 = (2*j+2) mod 2 by A4,A5,NAT_D:def 2
        .= 0 by A6,NAT_D:def 2;
   hence contradiction;
  end;
end;

definition
 func SCMPDS-OK ->
    Function of NAT, { INT } \/ { SCMPDS-Instr, SCM-Instr-Loc } means
:Def4: it.0 = SCM-Instr-Loc &
  for k being Nat holds
    it.(2*k+1) = INT & it.(2*k+2) = SCMPDS-Instr;
existence
  proof
   defpred P[set,set] means
    ($1 = 0 & $2 = SCM-Instr-Loc) or
    ((ex j st $1 = 2*j+1) & $2 = INT) or
    ((ex j st $1 = 2*j+2) & $2 = SCMPDS-Instr);
A1:  now let k be Element of NAT;
        {INT} \/ { SCMPDS-Instr, SCM-Instr-Loc }
      = { INT, SCMPDS-Instr, SCM-Instr-Loc } by ENUMSET1:42;
then A2:  INT in {INT} \/ { SCMPDS-Instr, SCM-Instr-Loc } &
     SCMPDS-Instr in {INT} \/ { SCMPDS-Instr , SCM-Instr-Loc } &
     SCM-Instr-Loc in {INT} \/ { SCMPDS-Instr, SCM-Instr-Loc }
       by ENUMSET1:def 1;
     P[k,SCM-Instr-Loc] or P[k,INT] or P[k,SCMPDS-Instr] by Th14;
     hence ex b being Element of {INT} \/
       { SCMPDS-Instr, SCM-Instr-Loc } st P[k,b] by A2;
    end;
    consider h being Function of NAT, {INT} \/
     { SCMPDS-Instr, SCM-Instr-Loc } such that
A3:   for a being Element of NAT holds P[a,h.a] from FUNCT_2:sch 3(A1);
   take h;
   P[0,h.0] by A3;
   hence h.0 = SCM-Instr-Loc;
   let k be Nat;
   reconsider k'=k as Element of NAT by ORDINAL1:def 13;
   P[2*k'+1,h.(2*k'+1)] & P[2*k'+2,h.(2*k'+2)] by A3;
   hence h.(2*k+1) = INT & h.(2*k+2) = SCMPDS-Instr by Th16;
  end;
uniqueness
  proof
   let f, g be Function of NAT, {INT} \/
     { SCMPDS-Instr, SCM-Instr-Loc } such that
A4: f.0 = SCM-Instr-Loc &
    for k being Nat holds f.(2*k+1) = INT &
     f.(2*k+2) = SCMPDS-Instr and
A5: g.0 = SCM-Instr-Loc &
    for k being Nat holds g.(2*k+1) = INT &
     g.(2*k+2) = SCMPDS-Instr;
       now let k be Element of NAT;
      now per cases by Th14;
       suppose k = 0;
        hence f.k = g.k by A4,A5;
       end;
       suppose A6: ex i be Element of NAT st k = 2*i+1;
        hence f.k = INT by A4
                 .= g.k by A5,A6;
       end;
       suppose A7:ex i be Element of NAT st k = 2*i+2;
        hence f.k = SCMPDS-Instr by A4
                 .= g.k by A5,A7;
      end;
      end;
     hence f.k = g.k;
    end;
   hence thesis by FUNCT_2:113;
  end;
end;

definition
 mode SCMPDS-State is Element of product SCMPDS-OK;
end;

theorem Th17:
 SCM-Instr-Loc <> SCMPDS-Instr & SCMPDS-Instr <> INT
 proof
  set S1={ [0,<*k1*>] where k1 is Element of INT: not contradiction},
      S2={ [1,<*d1*>] : not contradiction},
      S3={ [I2,<*d2,k2*>] where I2 is Element of Segm 14,
                    d2 is Element of SCM-Data-Loc,
                    k2 is Element of INT : I2 in {2,3}},
      S4={ [I3,<*d3,k3,k4*>] where I3 is Element of Segm 14,
                    d3 is Element of SCM-Data-Loc,
                    k3,k4 is Element of INT: I3 in {4,5,6,7,8} },
      S5={ [I4,<*d4,d5,k5,k6*>] where I4 is Element of Segm 14,
                    d4,d5 is Element of SCM-Data-Loc,
                    k5,k6 is Element of INT: I4 in {9,10,11,12,13} };
A1: 2 = 2*1;
      now
    assume 2 in SCMPDS-Instr;
    then 2 in S1 \/ S2 \/ S3 \/ S4 or 2 in S5 by XBOOLE_0:def 2;
    then 2 in S1 \/ S2 \/ S3 or 2 in S4 or 2 in S5 by XBOOLE_0:def 2;
    then 2 in S1 \/ S2 or 2 in S3 or 2 in S4 or 2 in S5 by XBOOLE_0:def 2;
    then 2 in S1 or 2 in S2 or 2 in S3 or 2 in S4 or 2 in S5 by XBOOLE_0:def 2
;
   then (ex k1 being Element of INT st 2= [0,<*k1*>] & not contradiction) or
   (ex d1 st 2= [1,<*d1*>] & not contradiction) or
   (ex I2,d2 st ex k2 being Element of INT st 2= [I2,<*d2,k2*>] & I2 in {2,3})
     or
   (ex I3,d3 st ex k1,k2 being Element of INT st 2 = [I3,<*d3,k1,k2*>] &
       I3 in {4,5,6,7,8}) or
   (ex I4,d4,d5 st ex k5,k6 being Element of INT st 2 = [I4,<*d4,d5,k5,k6*>] &
     I4 in {9,10,11,12,13});
   hence contradiction;
   end;
  hence thesis by A1,AMI_2:def 3,INT_1:def 2;
end;

theorem Th18:
 SCMPDS-OK.i = SCM-Instr-Loc iff i = 0
 proof
  thus SCMPDS-OK.i = SCM-Instr-Loc implies i = 0
   proof assume
A1:  SCMPDS-OK.i = SCM-Instr-Loc;
    assume i <> 0;
     then (ex j be Element of NAT st i = 2*j+1) or
       (ex j be Element of NAT st i = 2*j+2) by Th14;
    hence contradiction by A1,Def4,Th17,AMI_2:6;
   end;
  thus thesis by Def4;
 end;

theorem Th19:
 SCMPDS-OK.i = INT iff ex k be Nat st i = 2*k+1
 proof
  thus SCMPDS-OK.i = INT implies ex k be Nat st i = 2*k+1
   proof assume
A1:   SCMPDS-OK.i = INT;
    assume
A2: not ex k be Nat st i = 2*k+1;
A3: not ex k be Element of NAT st i = 2*k+1
    proof
      given k be Element of NAT such that A4:i = 2*k+1;
      thus contradiction by A2,A4;
    end;
    per cases by A3,Th14;
    suppose i = 0;
    hence contradiction by A1,Def4,AMI_2:6;
    end;
    suppose ex j be Element of NAT st i = 2*j+2;
    then consider j be Element of NAT such that
A5:   i = 2*j+2;
    thus contradiction by A1,A5,Def4,Th17;
   end;
   end;
  thus thesis by Def4;
 end;

theorem Th20:
 SCMPDS-OK.i = SCMPDS-Instr iff ex k be Nat st i = 2*k+2
 proof
  thus SCMPDS-OK.i = SCMPDS-Instr implies ex k be Nat st i = 2*k+2
   proof assume
A1: SCMPDS-OK.i = SCMPDS-Instr;
    assume
A2: not ex k be Nat st i = 2*k+2;
A3: not ex k be Element of NAT st i = 2*k+2
    proof
      given k be Element of NAT such that A4:i = 2*k+2;
      thus contradiction by A2,A4;
    end;
    per cases by A3,Th14;
    suppose i = 0;
    hence contradiction by A1,Def4,Th17;
    end;
    suppose ex j be Element of NAT st i = 2*j+1;
    then consider j be Element of NAT such that
A5:   i = 2*j+1;
    thus contradiction by A1,A5,Def4,Th17;
   end;
   end;
  thus thesis by Def4;
 end;

theorem Th21:
 SCMPDS-OK.d1 = INT
 proof
   d1 in { 2*k + 1 : not contradiction } by AMI_2:def 2;
   then ex k st d1 = 2*k+1;
   hence SCMPDS-OK.d1 = INT by Th19;
 end;

theorem Th22:
 SCMPDS-OK.i1 = SCMPDS-Instr
 proof
    i1 in { 2*k : k > 0 } by AMI_2:def 3;
    then consider k such that
A1:   i1 = 2*k & k > 0;
    consider j be Nat such that
A2:  k = j+1 by A1,NAT_1:6;
       i1 = 2*j + 2*1 by A1,A2;
  hence SCMPDS-OK.i1 = SCMPDS-Instr by Th20;
 end;

theorem Th23:
 pi(product SCMPDS-OK,0) = SCM-Instr-Loc
 proof
  dom SCMPDS-OK = NAT by FUNCT_2:def 1;
  hence pi(product SCMPDS-OK,0) = SCMPDS-OK.0 by CARD_3:22
   .= SCM-Instr-Loc by Def4;
 end;

theorem Th24:
 pi(product SCMPDS-OK,d1) = INT
 proof
     dom SCMPDS-OK = NAT by FUNCT_2:def 1;
  hence pi(product SCMPDS-OK,d1) = SCMPDS-OK.d1 by CARD_3:22
   .= INT by Th21;
 end;

theorem
  pi(product SCMPDS-OK,i1) = SCMPDS-Instr
 proof
     dom SCMPDS-OK = NAT by FUNCT_2:def 1;
  hence pi(product SCMPDS-OK,i1) = SCMPDS-OK.i1 by CARD_3:22
   .= SCMPDS-Instr by Th22;
 end;

definition let s be SCMPDS-State;
 func IC s -> Element of SCM-Instr-Loc equals
   s.0;
coherence by Th23,CARD_3:def 6;
end;

definition let s be SCMPDS-State,
               u be Element of SCM-Instr-Loc;
 func SCM-Chg(s,u) -> SCMPDS-State equals
  s +* (0 .--> u);
coherence
  proof
A1:  dom SCMPDS-OK = NAT by FUNCT_2:def 1;
  then dom s = NAT by CARD_3:18;
then A2:  dom(s +* (0 .--> u)) = NAT \/ dom(0 .--> u) by FUNCT_4:def 1
      .= NAT \/ {0} by FUNCOP_1:19
      .= dom SCMPDS-OK by A1,ZFMISC_1:46;
       now let x be set;
     assume
A3:    x in dom SCMPDS-OK;
        now per cases;
      suppose
A4:     x = 0;
        {0} = dom(0 .--> u) by FUNCOP_1:19;
        then 0 in dom(0 .--> u) by TARSKI:def 1;
       then (s +* (0 .--> u)).0 = (0 .--> u).0 by FUNCT_4:14
          .= u by FUNCOP_1:87;
        then (s +* (0 .--> u)).0 in SCM-Instr-Loc;
       hence (s +* (0 .--> u)).x in SCMPDS-OK.x by A4,Th18;
      end;
      suppose
A5:     x <> 0;
        {0} = dom(0 .--> u) by FUNCOP_1:19;
        then not x in dom(0 .--> u) by A5,TARSKI:def 1;
         then (s +* (0 .--> u)).x = s.x by FUNCT_4:12;
       hence (s +* (0 .--> u)).x in SCMPDS-OK.x by A3,CARD_3:18;
     end;
     end;
     hence (s +* (0 .--> u)).x in SCMPDS-OK.x;
    end;
   hence thesis by A2,CARD_3:18;
  end;
end;

theorem
    for s being SCMPDS-State, u being Element of SCM-Instr-Loc
  holds SCM-Chg(s,u).0 = u
 proof
   let s be SCMPDS-State, u be Element of SCM-Instr-Loc;
     {0} = dom(0 .--> u) by FUNCOP_1:19;
   then 0 in dom(0 .--> u) by TARSKI:def 1;
  hence SCM-Chg(s,u).0 = (0 .--> u).0 by FUNCT_4:14
    .= u by FUNCOP_1:87;
 end;

theorem
    for s being SCMPDS-State, u being Element of SCM-Instr-Loc,
     mk being Element of SCM-Data-Loc
  holds SCM-Chg(s,u).mk = s.mk
 proof
  let s be SCMPDS-State,
      u be Element of SCM-Instr-Loc,
      mk be Element of SCM-Data-Loc;
A1:  SCMPDS-OK.0 = SCM-Instr-Loc & SCMPDS-OK.mk = INT
     by Th18,Th21;
     {0} = dom(0 .--> u) by FUNCOP_1:19;
  then not mk in dom(0 .--> u) by A1,AMI_2:6,TARSKI:def 1;
 hence SCM-Chg(s,u).mk = s.mk by FUNCT_4:12;
end;

theorem
    for s being SCMPDS-State,
     u, v being Element of SCM-Instr-Loc
  holds SCM-Chg(s,u).v = s.v
 proof
   let s be SCMPDS-State,
       u, v be Element of SCM-Instr-Loc;
A1:  SCMPDS-OK.0 = SCM-Instr-Loc & SCMPDS-OK.v = SCMPDS-Instr by Th18,Th22;
     {0} = dom(0 .--> u) by FUNCOP_1:19;
  then not v in dom(0 .--> u) by A1,Th17,TARSKI:def 1;
 hence SCM-Chg(s,u).v = s.v by FUNCT_4:12;
end;

definition let s be SCMPDS-State,
               t be Element of SCM-Data-Loc,
               u be Integer;
 func SCM-Chg(s,t,u) -> SCMPDS-State equals
   s +* (t .--> u);
coherence
  proof
A1: dom SCMPDS-OK = NAT by FUNCT_2:def 1;
 then dom s = NAT by CARD_3:18;
then A2: dom(s +* (t .--> u)) = NAT \/ dom(t .--> u) by FUNCT_4:def 1
      .= NAT \/ {t} by FUNCOP_1:19
      .= dom SCMPDS-OK by A1,ZFMISC_1:46;
       now let x be set;
     assume
A3:    x in dom SCMPDS-OK;
        now per cases;
      suppose
A4:     x = t;
           {t} = dom(t .--> u) by FUNCOP_1:19;
        then t in dom(t .--> u) by TARSKI:def 1;
       then (s +* (t .--> u)).t = (t .--> u).t by FUNCT_4:14
          .= u by FUNCOP_1:87;
       then (s +* (t .--> u)).t in INT by INT_1:def 2;
       hence (s +* (t .--> u)).x in SCMPDS-OK.x by A4,Th21;
      end;
      suppose
A5:     x <> t;
          {t} = dom(t .--> u) by FUNCOP_1:19;
       then not x in dom(t .--> u) by A5,TARSKI:def 1;
        then (s +* (t .--> u)).x = s.x by FUNCT_4:12;
       hence (s +* (t .--> u)).x in SCMPDS-OK.x by A3,CARD_3:18;
     end;
     end;
     hence (s +* (t .--> u)).x in SCMPDS-OK.x;
    end;
   hence thesis by A2,CARD_3:18;
  end;
end;

theorem
    for s being SCMPDS-State, t being Element of SCM-Data-Loc,
     u being Integer
  holds SCM-Chg(s,t,u).0 = s.0
 proof
 let s be SCMPDS-State, t be Element of SCM-Data-Loc,
    u be Integer;
A1:  SCMPDS-OK.0 = SCM-Instr-Loc & SCMPDS-OK.t = INT
    by Th18,Th21;
     {t} = dom(t .--> u) by FUNCOP_1:19;
  then not 0 in dom(t .--> u) by A1,AMI_2:6,TARSKI:def 1;
 hence SCM-Chg(s,t,u).0 = s.0 by FUNCT_4:12;
end;

theorem
    for s being SCMPDS-State, t being Element of SCM-Data-Loc,
     u being Integer
  holds SCM-Chg(s,t,u).t = u
 proof
 let s be SCMPDS-State, t be Element of SCM-Data-Loc,
     u be Integer;
    {t} = dom(t .--> u) by FUNCOP_1:19;
  then t in dom(t .--> u) by TARSKI:def 1;
 hence SCM-Chg(s,t,u).t = (t .--> u).t by FUNCT_4:14
   .= u by FUNCOP_1:87;
end;

theorem
    for s being SCMPDS-State, t being Element of SCM-Data-Loc,
     u being Integer,
     mk being Element of SCM-Data-Loc st mk <> t
  holds SCM-Chg(s,t,u).mk = s.mk
 proof
  let s be SCMPDS-State, t be Element of SCM-Data-Loc,
      u be Integer,
     mk be Element of SCM-Data-Loc such that
A1:   mk <> t;
     {t} = dom(t .--> u) by FUNCOP_1:19;
  then not mk in dom(t .--> u) by A1,TARSKI:def 1;
 hence SCM-Chg(s,t,u).mk = s.mk by FUNCT_4:12;
end;

theorem
    for s being SCMPDS-State, t being Element of SCM-Data-Loc,
     u being Integer,
     v being Element of SCM-Instr-Loc
  holds SCM-Chg(s,t,u).v = s.v
 proof
  let s be SCMPDS-State, t be Element of SCM-Data-Loc,
      u be Integer,
      v be Element of SCM-Instr-Loc;
A1: SCMPDS-OK.v = SCMPDS-Instr & SCMPDS-OK.t = INT
     by Th21,Th22;
     {t} = dom(t .--> u) by FUNCOP_1:19;
  then not v in dom(t .--> u) by A1,Th17,TARSKI:def 1;
 hence SCM-Chg(s,t,u).v = s.v by FUNCT_4:12;
end;

definition let s be SCMPDS-State,
               a be Element of SCM-Data-Loc;
 redefine func s.a -> Integer;
coherence
  proof
       s.a in pi(product SCMPDS-OK,a) by CARD_3:def 6;
    then s.a in INT by Th24;
    hence s.a is Integer by INT_1:def 2;
  end;
end;

definition let s be SCMPDS-State,
               a be Element of SCM-Data-Loc,
               n be Integer;
 func Address_Add(s,a,n) -> Element of SCM-Data-Loc equals
     2*abs(s.a+n)+1;
coherence
proof
  reconsider m=abs(s.a+n) as Element of NAT;
     2*m+1 in SCM-Data-Loc by AMI_2:def 2;
  hence thesis;
  end;
end;

definition let s be SCMPDS-State,
               n be Integer;
 func jump_address(s,n) -> Element of SCM-Instr-Loc equals
     abs(((IC s) qua Element of NAT )-2+2*n)+2;
coherence
proof
    reconsider n0=IC s as Element of NAT;
       IC s in { 2*k: k>0} by AMI_2:def 3;
    then consider k such that
A1: IC s = 2*k & k > 0;
    consider j be Nat such that
A2: k = j+1 by A1,NAT_1:6;
A3: abs(n0-2+2*n)+2 =abs(2*(j+n))+2 by A1,A2
    .=abs (2)*abs(j+n)+2 by COMPLEX1:151
    .=2*abs(j+n)+2*1 by ABSVALUE:def 1
    .=2*(abs(j+n)+1);
   reconsider m=abs(j+n)+1 as Element of NAT;
      m > 0 by NAT_1:3;
   then 2*m in SCM-Instr-Loc by AMI_2:def 3;
   hence thesis by A3;
  end;
end;

definition let d be Element of SCM-Data-Loc,
               s be Integer;
 redefine func <*d,s*> -> FinSequence of SCM-Data-Loc \/ INT;
coherence
  proof
    let y be set;
    assume y in rng <*d,s*>;
    then consider x being set such that
A1:   x in dom <*d,s*> and
A2:   <*d,s*>.x = y by FUNCT_1:def 5;
A3: dom <*d,s*> = {1,2} by FINSEQ_1:4,FINSEQ_3:29;
    per cases by A1,A3,TARSKI:def 2;
    suppose x = 1;
    then y = d by A2,FINSEQ_1:61;
    hence thesis by XBOOLE_0:def 2;
    end;
    suppose x = 2;
then A4: y = s by A2,FINSEQ_1:61;
       s in INT by INT_1:def 2;
    hence thesis by A4,XBOOLE_0:def 2;
  end;
  end;
end;

definition let x be Element of SCMPDS-Instr;
 given mk be Element of SCM-Data-Loc, I such that
A1: x = [ I, <*mk*>];
 func x address_1 -> Element of SCM-Data-Loc means
:Def10:  ex f being FinSequence of SCM-Data-Loc st f = x`2 & it = f/.1;
  existence
  proof
    take mk,<*mk*>;
    thus thesis by A1,FINSEQ_4:25,MCART_1:7;
  end;
uniqueness;
end;

theorem
     for x being Element of SCMPDS-Instr, mk being Element of SCM-Data-Loc
  st x = [ I, <*mk*>] holds
 x address_1 = mk
proof
  let x be Element of SCMPDS-Instr, mk be Element of SCM-Data-Loc;
  assume
A1: x = [ I, <*mk*>];
   then consider f being FinSequence of SCM-Data-Loc such that
A2:  f = x`2 & x address_1 = f/.1 by Def10;
      f = <*mk*> by A1,A2,MCART_1:7;
  hence x address_1 = mk by A2,FINSEQ_4:25;
end;

definition let x be Element of SCMPDS-Instr;
 given r being Integer, I such that
A1: x = [ I, <*r*>];
 func x const_INT -> Integer means
:Def11: ex f being FinSequence of INT st f = x`2 & it = f/.1;
  existence
  proof
    reconsider mm=r as Element of INT by INT_1:def 2;
    take r,<*mm*>;
    thus thesis by A1,FINSEQ_4:25,MCART_1:7;
  end;
uniqueness;
end;

theorem
     for x being Element of SCMPDS-Instr, k being Integer
  st x = [ I, <*k*>] holds
 x const_INT = k
proof
  let x be Element of SCMPDS-Instr, k be Integer;
  assume
A1: x = [ I, <*k*>];
   then consider f being FinSequence of INT such that
A2: f = x`2 & x const_INT = f/.1 by Def11;
A3: k is Element of INT by INT_1:def 2;
      f = <*k*> by A1,A2,MCART_1:7;
  hence x const_INT = k by A2,A3,FINSEQ_4:25;
end;

definition let x be Element of SCMPDS-Instr;
 given mk being Element of SCM-Data-Loc, r being Integer,
       I such that
A1: x = [ I, <*mk, r*>];
 func x P21address -> Element of SCM-Data-Loc means
:Def12: ex f being FinSequence of SCM-Data-Loc \/ INT
   st f = x`2 & it = f/.1;
  existence
  proof
    take mk,<*mk, r*>;
    r in INT by INT_1:def 2;
    then mk is Element of SCM-Data-Loc \/ INT &
     r is Element of SCM-Data-Loc \/ INT by XBOOLE_0:def 2;
    hence thesis by A1,FINSEQ_4:26,MCART_1:7;
  end;
uniqueness;

 func x P22const -> Integer means
:Def13: ex f being FinSequence of SCM-Data-Loc \/ INT
  st f = x`2 & it = f/.2;
  existence
  proof
    take r,<*mk, r*>;
    r in INT by INT_1:def 2;
    then mk is Element of SCM-Data-Loc \/ INT &
     r is Element of SCM-Data-Loc \/ INT by XBOOLE_0:def 2;
    hence thesis by A1,FINSEQ_4:26,MCART_1:7;
  end;
uniqueness;
end;

theorem
    for x being Element of SCMPDS-Instr, mk being Element of SCM-Data-Loc,
     r being Integer st x = [ I, <*mk, r*>] holds
  x P21address = mk & x P22const = r
 proof
   let x be Element of SCMPDS-Instr,
       mk be Element of SCM-Data-Loc,
       r be Integer;
  assume
A1: x = [ I, <*mk,r*>];
  then consider f being FinSequence of SCM-Data-Loc \/ INT such that
A2:  f = x`2 & x P21address = f/.1 by Def12;
A3: f = <*mk,r*> by A1,A2,MCART_1:7;
    r in INT by INT_1:def 2;
then A4: mk is Element of SCM-Data-Loc \/ INT &
   r is Element of SCM-Data-Loc \/ INT by XBOOLE_0:def 2;
  hence x P21address = mk by A2,A3,FINSEQ_4:26;
   consider f being FinSequence of SCM-Data-Loc \/ INT such that
A5:  f = x`2 & x P22const = f/.2 by A1,Def13;
      f = <*mk,r*> by A1,A5,MCART_1:7;
  hence x P22const = r by A4,A5,FINSEQ_4:26;
 end;

definition let x be Element of SCMPDS-Instr;
 given m1 being Element of SCM-Data-Loc,k1,k2 be Integer,I such that
A1: x = [I, <*m1,k1,k2*>];

 func x P31address -> Element of SCM-Data-Loc means
:Def14: ex f being FinSequence of (SCM-Data-Loc \/ INT) st
       f = x`2 & it = f/.1;
  existence
  proof
    reconsider mm=m1,k1,k2 as Element of (SCM-Data-Loc \/ INT)
    by Th10;
    take m1,f=<*mm,k1,k2*>;
    thus f=x`2 by A1,MCART_1:7;
    thus m1=f/.1 by FINSEQ_4:27;
  end;
uniqueness;

  func x P32const -> Integer means
:Def15: ex f being FinSequence of (SCM-Data-Loc \/ INT) st
  f = x`2 & it = f/.2;
  existence
  proof
    reconsider m1,mm=k1,k2 as Element of (SCM-Data-Loc \/ INT)
    by Th10;
    take k1,f=<*m1,mm,k2*>;
    thus f=x`2 by A1,MCART_1:7;
    thus k1=f/.2 by FINSEQ_4:27;
  end;
  uniqueness;

  func x P33const -> Integer means
:Def16:   ex f being FinSequence of (SCM-Data-Loc \/ INT) st
   f = x`2 & it = f/.3;
  existence
  proof
    reconsider m1,k1,mm=k2 as Element of (SCM-Data-Loc \/ INT)
    by Th10;
    take k2,f=<*m1,k1,mm*>;
    thus f=x`2 by A1,MCART_1:7;
    thus k2=f/.3 by FINSEQ_4:27;
  end;
  uniqueness;
end;

theorem
    for x being Element of SCMPDS-Instr, d1 being Element of SCM-Data-Loc,
     k1,k2 being Integer st x = [ I, <*d1,k1,k2*>] holds
  x P31address = d1 & x P32const = k1 & x P33const = k2
 proof
   let x be Element of SCMPDS-Instr,
       d1 be Element of SCM-Data-Loc, k1,k2 be Integer;
  assume
A1: x = [ I, <*d1,k1,k2*>];
A2:  d1 is Element of SCM-Data-Loc \/ INT by XBOOLE_0:def 2;
        k1 in INT by INT_1:def 2;
then A3:  k1 is Element of SCM-Data-Loc \/ INT by XBOOLE_0:def 2;
        k2 in INT by INT_1:def 2;
then A4:  k2 is Element of SCM-Data-Loc \/ INT by XBOOLE_0:def 2;
  consider f being FinSequence of SCM-Data-Loc \/ INT such that
A5:  f = x`2 & x P31address = f/.1 by A1,Def14;
        f = <*d1,k1,k2*> by A1,A5,MCART_1:7;
  hence x P31address = d1 by A2,A3,A4,A5,FINSEQ_4:27;
   consider f being FinSequence of SCM-Data-Loc \/ INT such that
A6:  f = x`2 & x P32const = f/.2 by A1,Def15;
        f = <*d1,k1,k2*> by A1,A6,MCART_1:7;
  hence x P32const = k1 by A2,A3,A4,A6,FINSEQ_4:27;
  consider f being FinSequence of SCM-Data-Loc \/ INT such that
A7:  f = x`2 & x P33const = f/.3 by A1,Def16;
        f = <*d1,k1,k2*> by A1,A7,MCART_1:7;
  hence x P33const = k2 by A2,A3,A4,A7,FINSEQ_4:27;
end;

definition let x be Element of SCMPDS-Instr;
 given m1,m2 being Element of SCM-Data-Loc,k1,k2 be Integer,I such that
A1: x = [ I, <*m1,m2,k1,k2*>];

 func x P41address -> Element of SCM-Data-Loc means
:Def17: ex f being FinSequence of (SCM-Data-Loc \/ INT) st
   f = x`2 & it = f/.1;
  existence
  proof
    reconsider mm=m1,m2,k1,k2 as Element of (SCM-Data-Loc \/ INT)
    by Th10;
    take m1,f=<*mm,m2,k1,k2*>;
    thus f=x`2 by A1,MCART_1:7;
    thus m1=f/.1 by FINSEQ_4:95;
  end;
uniqueness;

   func x P42address -> Element of SCM-Data-Loc means
:Def18:  ex f being FinSequence of (SCM-Data-Loc \/ INT) st
  f = x`2 & it = f/.2;
  existence
  proof
    reconsider m1,mm=m2,k1,k2 as Element of (SCM-Data-Loc \/ INT)
    by Th10;
    take m2,f=<*m1,mm,k1,k2*>;
    thus f=x`2 by A1,MCART_1:7;
    thus m2=f/.2 by FINSEQ_4:95;
  end;
  uniqueness;

  func x P43const -> Integer means
:Def19:  ex f being FinSequence of (SCM-Data-Loc \/ INT) st
  f = x`2 & it = f/.3;
  existence
  proof
    reconsider m1,m2,mm=k1,k2 as Element of (SCM-Data-Loc \/ INT)
    by Th10;
    take k1,f=<*m1,m2,mm,k2*>;
    thus f=x`2 by A1,MCART_1:7;
    thus k1=f/.3 by FINSEQ_4:95;
  end;
  uniqueness;

  func x P44const -> Integer means
:Def20:  ex f being FinSequence of (SCM-Data-Loc \/ INT) st
  f = x`2 & it = f/.4;
  existence
  proof
    reconsider m1,m2,k1,mm=k2 as Element of (SCM-Data-Loc \/ INT)
    by Th10;
    take k2,f=<*m1,m2,k1,mm*>;
    thus f=x`2 by A1,MCART_1:7;
    thus k2=f/.4 by FINSEQ_4:95;
  end;
  uniqueness;
end;

theorem
    for x being Element of SCMPDS-Instr, d1,d2 being Element of SCM-Data-Loc,
     k1,k2 being Integer st x = [ I, <*d1,d2,k1,k2*>] holds
  x P41address = d1 & x P42address = d2 & x P43const = k1 & x P44const = k2
 proof
   let x be Element of SCMPDS-Instr,
       d1,d2 be Element of SCM-Data-Loc, k1,k2 be Integer;
  assume
A1: x = [ I, <*d1,d2,k1,k2*>];
A2:  d1 is Element of SCM-Data-Loc \/ INT &
     d2 is Element of SCM-Data-Loc \/ INT by XBOOLE_0:def 2;
        k1 in INT by INT_1:def 2;
then A3:  k1 is Element of SCM-Data-Loc \/ INT by XBOOLE_0:def 2;
        k2 in INT by INT_1:def 2;
then A4:  k2 is Element of SCM-Data-Loc \/ INT by XBOOLE_0:def 2;
     consider f being FinSequence of SCM-Data-Loc \/ INT such that
A5:  f = x`2 & x P41address = f/.1 by A1,Def17;
        f = <*d1,d2,k1,k2*> by A1,A5,MCART_1:7;
  hence x P41address = d1 by A2,A3,A4,A5,FINSEQ_4:95;
     consider f being FinSequence of SCM-Data-Loc \/ INT such that
A6:  f = x`2 & x P42address = f/.2 by A1,Def18;
        f = <*d1,d2,k1,k2*> by A1,A6,MCART_1:7;
  hence x P42address = d2 by A2,A3,A4,A6,FINSEQ_4:95;
     consider f being FinSequence of SCM-Data-Loc \/ INT such that
A7:  f = x`2 & x P43const = f/.3 by A1,Def19;
        f = <*d1,d2,k1,k2*> by A1,A7,MCART_1:7;
  hence x P43const = k1 by A2,A3,A4,A7,FINSEQ_4:95;
     consider f being FinSequence of SCM-Data-Loc \/ INT such that
A8:  f = x`2 & x P44const = f/.4 by A1,Def20;
        f = <*d1,d2,k1,k2*> by A1,A8,MCART_1:7;
  hence x P44const = k2 by A2,A3,A4,A8,FINSEQ_4:95;
end;

definition let s be SCMPDS-State,
           a be Element of SCM-Data-Loc;
 func PopInstrLoc(s,a) -> Element of SCM-Instr-Loc equals
      2*(abs(s.a) div 2)+4;
coherence
proof set n=abs(s.a) div 2;
   reconsider m=n +2 as Element of NAT;
      m > 0 by NAT_1:3;
   then 2*m in SCM-Instr-Loc by AMI_2:def 3;
   hence thesis;
  end;
end;

:: RetSP: Return Stack Pointer
:: RetIC: Return Instruction-Counter

definition
   func RetSP -> Element of NAT equals
       0;
   coherence;
   func RetIC -> Element of NAT equals
      1;
   coherence;
end;

definition let x be Element of SCMPDS-Instr,
               s be SCMPDS-State;
 func SCM-Exec-Res (x,s) -> SCMPDS-State equals
     SCM-Chg(s, jump_address(s,x const_INT ))
        if ex k1 st x = [ 0, <*k1*>],
  SCM-Chg(SCM-Chg(s, x P21address, x P22const), Next IC s)
        if ex d1,k1 st x = [ 2, <*d1, k1*>],
  SCM-Chg(SCM-Chg(s, Address_Add(s,x P21address,x P22const),
  IC s qua Element of NAT),Next IC s)
        if ex d1,k1 st x = [ 3, <*d1, k1*>],
  SCM-Chg(SCM-Chg(s, x address_1,s.Address_Add(s,x address_1,RetSP)),
  PopInstrLoc(s,Address_Add(s,x address_1,RetIC)) )
        if ex d1 st x = [ 1, <*d1*>],
  SCM-Chg(s, IFEQ(s.Address_Add(s,x P31address,x P32const), 0,
  Next IC s,jump_address(s,x P33const )))
         if ex d1,k1,k2 st x = [ 4, <*d1,k1,k2*>],
  SCM-Chg(s, IFGT(s.Address_Add(s,x P31address,x P32const), 0,
  Next IC s,jump_address(s,x P33const )))
        if ex d1,k1,k2 st x = [ 5, <*d1,k1,k2*>],
  SCM-Chg(s, IFGT(0, s.Address_Add(s,x P31address,x P32const),
  Next IC s,jump_address(s,x P33const )))
        if ex d1,k1,k2 st x = [ 6, <*d1,k1,k2*>],
  SCM-Chg(SCM-Chg(s, Address_Add(s,x P31address,x P32const),
  x P33const), Next IC s)
        if ex d1,k1,k2 st x = [ 7, <*d1,k1,k2*>],
  SCM-Chg(SCM-Chg(s, Address_Add(s,x P31address,x P32const),
  s.Address_Add(s,x P31address,x P32const)+ (x P33const)), Next IC s)
        if ex d1,k1,k2 st x = [ 8, <*d1,k1,k2*>],
  SCM-Chg(SCM-Chg(s, Address_Add(s,x P41address,x P43const),
  s.Address_Add(s,x P41address,x P43const)+
  s.Address_Add(s,x P42address,x P44const)),Next IC s)
      if ex d1,d2,k1,k2 st x = [ 9, <*d1,d2,k1,k2*>],
  SCM-Chg(SCM-Chg(s, Address_Add(s,x P41address,x P43const),
  s.Address_Add(s,x P41address,x P43const) -
  s.Address_Add(s,x P42address,x P44const)),Next IC s)
      if ex d1,d2,k1,k2 st x = [ 10, <*d1,d2,k1,k2*>],
  SCM-Chg(SCM-Chg(s, Address_Add(s,x P41address,x P43const),
  s.Address_Add(s,x P41address,x P43const) *
  s.Address_Add(s,x P42address,x P44const)),Next IC s)
      if ex d1,d2,k1,k2 st x = [ 11, <*d1,d2,k1,k2*>],
  SCM-Chg(SCM-Chg(s, Address_Add(s,x P41address,x P43const),
  s.Address_Add(s,x P42address,x P44const)), Next IC s)
      if ex d1,d2,k1,k2 st x = [13, <*d1,d2,k1,k2*>],
  SCM-Chg(SCM-Chg(
           SCM-Chg(s,Address_Add(s,x P41address,x P43const),
     s.Address_Add(s,x P41address,x P43const) div
     s.Address_Add(s,x P42address,x P44const)),
           Address_Add(s,x P42address,x P44const),
     s.Address_Add(s,x P41address,x P43const) mod
     s.Address_Add(s,x P42address,x P44const)), Next IC s)
     if ex d1,d2,k1,k2 st x = [12, <*d1,d2,k1,k2*>]
  otherwise s;
coherence;
consistency by ZFMISC_1:33;
end;

registration
 let f be Function of SCMPDS-Instr, Funcs(product SCMPDS-OK,
 product SCMPDS-OK ), x be Element of SCMPDS-Instr;
 cluster f.x -> Function-like Relation-like;
coherence;
end;

definition
 func SCMPDS-Exec ->
      Function of SCMPDS-Instr, Funcs(product SCMPDS-OK, product SCMPDS-OK)
     means
     for x being Element of SCMPDS-Instr, y being SCMPDS-State holds
   (it.x).y = SCM-Exec-Res (x,y);
  existence
  proof
   consider f being
    Function of [:SCMPDS-Instr,product SCMPDS-OK:], product SCMPDS-OK
     such that
 A1:   for x being Element of SCMPDS-Instr, y being SCMPDS-State holds
    f.(x,y) = SCM-Exec-Res(x,y) from BINOP_1:sch 4;
   take curry f;
   let x be Element of SCMPDS-Instr, y be SCMPDS-State;
   thus (curry f).x.y = f.(x,y) by CAT_2:3
     .= SCM-Exec-Res(x,y) by A1;
  end;
uniqueness
  proof
   let f, g be Function of SCMPDS-Instr,
     Funcs(product SCMPDS-OK, product SCMPDS-OK) such that
A2:   for x being Element of SCMPDS-Instr, y being SCMPDS-State holds
      (f.x).y = SCM-Exec-Res(x,y) and
A3:   for x being Element of SCMPDS-Instr, y being SCMPDS-State holds
      (g.x).y = SCM-Exec-Res(x,y);
       now let x be Element of SCMPDS-Instr;
     reconsider gx = g.x, fx = f.x as
      Function of product SCMPDS-OK, product SCMPDS-OK;
        now let y be SCMPDS-State;
      thus fx.y = SCM-Exec-Res(x,y) by A2
               .= gx.y by A3;
     end;
     hence f.x = g.x by FUNCT_2:113;
    end;
   hence f = g by FUNCT_2:113;
  end;
end;

