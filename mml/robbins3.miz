:: Formalization of Ortholattices via Orthoposets
::  by Adam Grabowski and Markus Moschner
::
:: Received December 28, 2004
:: Copyright (c) 2004 Association of Mizar Users

environ

 vocabularies BINOP_1, BOOLE, FUNCT_1, SUBSET_1, LATTICES, ROBBINS3, ORDERS_1,
      RELAT_1, LATTICE3, ROBBINS1, OPOSET_1, MIDSP_1, VECTSP_2, FILTER_1,
      REALSET1, RELAT_2, WAYBEL_0, WAYBEL_1, YELLOW_0, SHEFFER1;
 notations TARSKI, XBOOLE_0, ZFMISC_1, BINOP_1, RELAT_1, RELSET_1, PARTFUN1,
      RELAT_2, FUNCT_2, FUNCT_5, STRUCT_0, LATTICE3, LATTICES, ORDERS_1,
      ORDERS_2, FILTER_1, ROBBINS1, QMAX_1, OPOSET_1, WAYBEL_0, WAYBEL_1,
      YELLOW_0, SHEFFER1;
 constructors BINOP_1, REALSET2, LATTICE3, WAYBEL_1, YELLOW_6, OPOSET_1,
      SHEFFER1, FUNCT_5;
 registrations RELAT_1, FUNCT_1, PARTFUN1, FUNCT_2, REALSET1, STRUCT_0,
      LATTICES, YELLOW_0, YELLOW_1, ROBBINS1, OPOSET_1, SHEFFER1;
 requirements SUBSET, BOOLE;
 definitions LATTICES, RELAT_2, TARSKI;
 theorems ZFMISC_1, STRUCT_0, LATTICE3, RELAT_1, FILTER_1, LATTICES, OPOSET_1,
      ORDERS_1, RELSET_1, ROBBINS1, PARTFUN1, RELAT_2, YELLOW_0, ORDERS_2,
      WAYBEL_9, WAYBEL_1, FUNCT_2, REALSET1, YELLOW_7, SHEFFER1, CARD_1;

begin :: Another short axiomatization of lattices

:: Originally proved by McCune with the help of OTTER

definition
  let L be non empty \/-SemiLattStr;
  attr L is join-Associative means
  :Def1:
  for x, y, z being Element of L holds
  x "\/" (y "\/" z) = y "\/" (x "\/" z);
end;

definition
  let L be non empty /\-SemiLattStr;
  attr L is meet-Associative means
  :Def2:
  for x, y, z being Element of L holds
  x "/\" (y "/\" z) = y "/\" (x "/\" z);
end;

definition
  let L be non empty LattStr;
  attr L is meet-Absorbing means
  :Def3:
  for x, y being Element of L holds
  x "\/" (x "/\" y) = x;
end;

theorem Th1:
  for L being non empty LattStr holds
  L is meet-Associative join-Associative meet-Absorbing join-absorbing
  implies L is meet-idempotent join-idempotent
proof
  let L be non empty LattStr;
  assume
A1: L is meet-Associative join-Associative meet-Absorbing join-absorbing;
A2: for x being Element of L holds x "/\" x = x
  proof
    let a be Element of L;
    a = a "/\" (a "\/" a) by A1,LATTICES:def 9;
    hence thesis by A1,Def3;
  end;
  for x being Element of L holds x "\/" x = x
  proof
    let a be Element of L;
    a = a "\/" (a "/\" a) by A1,Def3;
    hence thesis by A1,LATTICES:def 9;
  end;
  hence thesis by A2,ROBBINS1:def 7,SHEFFER1:def 9;
end;

theorem Th2:
  for L being non empty LattStr holds
  L is meet-Associative join-Associative meet-Absorbing join-absorbing
  implies L is meet-commutative join-commutative
proof
  let L be non empty LattStr;
  assume
A1: L is meet-Associative join-Associative meet-Absorbing join-absorbing;
  then
A2: L is join-idempotent meet-idempotent by Th1;
A3: for x,y being Element of L holds x "/\" y = y "/\" x
  proof
    let a,b be Element of L;
    a "/\" b = a "/\" (b "/\" (b "\/" a)) by A1,LATTICES:def 9
      .= b "/\" (a "/\" (b "\/" a)) by A1,Def2
      .= b "/\" (a "/\" (b "\/" (a "\/" a))) by A2,ROBBINS1:def 7
      .= b "/\" (a "/\" (a "\/" (b "\/" a))) by A1,Def1
      .= b "/\" a by A1,LATTICES:def 9;
    hence thesis;
  end;
  for x,y being Element of L holds x "\/" y = y "\/" x
  proof
    let a,b be Element of L;
    a "\/" b = a "\/" (b "\/" (b "/\" a)) by A1,Def3
      .= b "\/" (a "\/" (b "/\" a)) by A1,Def1
      .= b "\/" (a "\/" (b "/\" (a "/\" a))) by A2,SHEFFER1:def 9
      .= b "\/" (a "\/" (a "/\" (b "/\" a))) by A1,Def2
      .= b "\/" a by A1,Def3;
    hence thesis;
  end;
  hence thesis by A3,LATTICES:def 4,def 6;
end;

theorem Th3:
  for L being non empty LattStr holds
  L is meet-Associative join-Associative meet-Absorbing join-absorbing
  implies L is meet-absorbing
proof
  let L be non empty LattStr;
  assume
A1: L is meet-Associative join-Associative meet-Absorbing join-absorbing;
  then
A2: L is meet-commutative join-commutative by Th2;
  for x,y being Element of L holds (x "/\" y) "\/" y = y
  proof
    let a,b be Element of L;
    b = b "\/" (b "/\" a) by A1,Def3
      .= b "\/" (a "/\" b) by A2,LATTICES:def 6
      .= (a "/\" b) "\/" b by A2,LATTICES:def 4;
    hence thesis;
  end;
  hence thesis by LATTICES:def 8;
end;

theorem Th4:
  for L being non empty LattStr holds
  L is meet-Associative join-Associative meet-Absorbing join-absorbing
  implies L is meet-associative join-associative
proof
  let L be non empty LattStr;
  assume
A1: L is meet-Associative join-Associative meet-Absorbing join-absorbing;
  then
A2: L is meet-commutative join-commutative by Th2;
A3: for x,y,z being Element of L holds x "/\" (y "/\" z) = (x "/\" y) "/\" z
  proof
    let a,b,c be Element of L;
    a "/\" (b "/\" c) = a "/\" (c "/\" b) by A2,LATTICES:def 6
      .= c "/\" (a "/\" b) by A1,Def2
      .= (a "/\" b) "/\" c by A2,LATTICES:def 6;
    hence thesis;
  end;
  for x,y,z being Element of L holds x "\/" (y "\/" z) = (x "\/" y) "\/" z
  proof
    let a,b,c be Element of L;
    a "\/" (b "\/" c) = a "\/" (c "\/" b) by A2,LATTICES:def 4
      .= c "\/" (a "\/" b) by A1,Def1
      .= (a "\/" b) "\/" c by A2,LATTICES:def 4;
    hence thesis;
  end;
  hence thesis by A3,LATTICES:def 5,def 7;
end;

theorem Th5:
  for L being non empty LattStr holds L is Lattice-like iff
  L is meet-Associative join-Associative meet-Absorbing join-absorbing
proof
  let L be non empty LattStr;
A1: L is Lattice-like implies
  L is meet-Associative join-Associative meet-Absorbing join-absorbing
  proof
    assume
A2: L is Lattice-like;
    then
A3: L is meet-absorbing join-absorbing by LATTICES:def 10;
A4: L is meet-associative meet-commutative
    join-associative join-commutative by A2,LATTICES:def 10;
A5: for x,y,z being Element of L holds x "\/" (y "\/" z) = y "\/" (x "\/" z)
    proof
      let a,b,c be Element of L;
      a "\/" (b "\/" c) = (a "\/" b) "\/" c by A4,LATTICES:def 5
        .= (b "\/" a) "\/" c by A4,LATTICES:def 4
        .= b "\/" (a "\/" c) by A4,LATTICES:def 5;
      hence thesis;
    end;
A6: for x,y,z being Element of L holds x "/\" (y "/\" z) = y "/\" (x "/\" z)
    proof
      let a,b,c be Element of L;
      a "/\" (b "/\" c) = (a "/\" b) "/\" c by A4,LATTICES:def 7
        .= (b "/\" a) "/\" c by A4,LATTICES:def 6
        .= b "/\" (a "/\" c) by A4,LATTICES:def 7;
      hence thesis;
    end;
    for x,y being Element of L holds x "\/" (x "/\" y) = x
    proof
      let a,b be Element of L;
      a = (b "/\" a) "\/" a by A3,LATTICES:def 8
        .= (a "/\" b) "\/" a by A4,LATTICES:def 6
        .= a "\/" (a "/\" b) by A4,LATTICES:def 4;
      hence thesis;
    end;
    hence thesis by A2,A5,A6,Def1,Def2,Def3,LATTICES:def 10;
  end;
  L is meet-Associative join-Associative meet-Absorbing join-absorbing implies
  L is Lattice-like
  proof
    assume
A7: L is meet-Associative join-Associative meet-Absorbing join-absorbing;
    then
A8: L is meet-commutative join-commutative by Th2;
A9: L is meet-associative join-associative by A7,Th4;
    L is meet-absorbing by A7,Th3;
    hence thesis by A7,A8,A9,LATTICES:def 10;
  end;
  hence thesis by A1;
end;

registration
  cluster Lattice-like -> meet-Associative join-Associative meet-Absorbing
    (non empty LattStr);
  coherence by Th5,LATTICES:def 10;
  cluster meet-Associative join-Associative meet-Absorbing join-absorbing ->
    Lattice-like (non empty LattStr);
  coherence by Th5;
end;

begin :: Orthoposets

registration
  cluster OrderInvolutive -> Dneg (PartialOrdered (non empty OrthoRelStr));
  coherence
  proof
    let L be PartialOrdered (non empty OrthoRelStr);
    assume L is OrderInvolutive;
    then consider f being Function of L,L such that
A1: f = the Compl of L & f is Orderinvolutive by OPOSET_1:def 33;
    consider g being Function of L, L such that
A2: g = f & g is dneg antitone by A1,OPOSET_1:def 32;
    thus thesis by A1,A2,OPOSET_1:def 6;
  end;
end;

theorem Th6:
  for L being Dneg (non empty OrthoRelStr), x being Element of L holds x`` = x
proof
  let L be Dneg (non empty OrthoRelStr), x be Element of L;
  consider f being Function of L,L such that
A1: f = the Compl of L & f is dneg by OPOSET_1:def 6;
A2: f.x = x` by A1,ROBBINS1:def 3;
  f.(f.x) = x by A1,OPOSET_1:def 3;
  hence thesis by A1,A2,ROBBINS1:def 3;
end;

theorem Th7:
  for O being OrderInvolutive PartialOrdered (non empty OrthoRelStr),
  x, y being Element of O holds x <= y implies y` <= x`
proof
  let O be OrderInvolutive PartialOrdered (non empty OrthoRelStr),
  x, y be Element of O;
  assume
A1: x <= y;
  consider f being Function of O,O such that
A2: f = the Compl of O & f is Orderinvolutive by OPOSET_1:def 33;
  consider g being Function of O,O such that
A3: g = f & g is dneg antitone by A2,OPOSET_1:def 32;
  f.x >= f.y by A1,A3,WAYBEL_9:def 1;
  then x` >= f.y by A2,ROBBINS1:def 3;
  hence thesis by A2,ROBBINS1:def 3;
end;

registration
  cluster with_infima with_suprema strict PreOrthoPoset;
  existence
  proof
    take TrivOrthoRelStr;
    thus thesis;
  end;
end;

notation
  let L be non empty \/-SemiLattStr, x, y be Element of L;
  synonym x |_| y for x "\/" y;
end;

notation
  let L be non empty /\-SemiLattStr, x, y be Element of L;
  synonym x |^| y for x "/\" y;
end;

notation
  let L be non empty RelStr, x, y be Element of L;
  synonym x "|^|" y for x "/\" y;
  synonym x "|_|" y for x "\/" y;
end;

begin :: Merging relational structures and lattice structures together

definition
  struct (\/-SemiLattStr, RelStr) \/-SemiLattRelStr (# carrier -> set,
    L_join -> (BinOp of the carrier),
    InternalRel -> Relation of the carrier #);
end;

definition
  struct (/\-SemiLattStr, RelStr) /\-SemiLattRelStr (# carrier -> set,
    L_meet -> (BinOp of the carrier),
    InternalRel -> Relation of the carrier #);
end;

definition
  struct (/\-SemiLattRelStr, \/-SemiLattRelStr, LattStr) LattRelStr
  (# carrier -> set, L_join, L_meet -> (BinOp of the carrier),
    InternalRel -> Relation of the carrier #);
end;

definition
  func TrivLattRelStr -> LattRelStr equals

  LattRelStr (# 1, op2, op2, id 1 #);
  coherence;
end;

registration
  cluster TrivLattRelStr -> non empty trivial;
  coherence by CARD_1:87,STRUCT_0:def 1,def 9;
end;

registration
  cluster non empty \/-SemiLattRelStr;
  existence
  proof
    take TrivLattRelStr;
    thus thesis;
  end;
  cluster non empty /\-SemiLattRelStr;
  existence
  proof
    take TrivLattRelStr;
    thus thesis;
  end;
  cluster non empty LattRelStr;
  existence
  proof
    take TrivLattRelStr;
    thus thesis;
  end;
end;

theorem
  for R being non empty RelStr st
  the InternalRel of R is_reflexive_in the carrier of R &
  the InternalRel of R is antisymmetric transitive holds
  R is reflexive antisymmetric transitive
proof
  let r be non empty RelStr;
  set i = the InternalRel of r;
  set c = the carrier of r;
  assume
A1: i is_reflexive_in c & i is antisymmetric transitive;
  then
A2: field i = c by OPOSET_1:7;
  then
A3: i is_antisymmetric_in c by A1,RELAT_2:def 12;
  i is_transitive_in field i by A1,RELAT_2:def 16;
  hence thesis by A1,A2,A3,ORDERS_2:def 4,def 5,def 6;
end;

registration
  cluster TrivLattRelStr -> reflexive;
  coherence
  proof
    set T = TrivLattRelStr;
    set C = the carrier of T;
    set I = the InternalRel of T;
    field I = C by OPOSET_1:1;
    then I is_reflexive_in C by RELAT_2:def 9;
    hence thesis by ORDERS_2:def 4;
  end;
end;

registration
  cluster antisymmetric reflexive transitive
    with_suprema with_infima LattRelStr;
  existence
  proof
    take TrivLattRelStr;
    thus thesis;
  end;
end;

registration
  cluster TrivLattRelStr -> meet-Absorbing;
  coherence
  proof
    set TL = TrivLattRelStr;
    for x,y being Element of TL holds x "\/" (x "/\" y) = x
    by STRUCT_0:def 10;
    hence thesis by Def3;
  end;
end;

Lm1: TrivLattRelStr is Lattice-like;

registration
  cluster Lattice-like (non empty LattRelStr);
  existence by Lm1;
end;

definition
  let L be Lattice;
  redefine func LattRel L -> Order of the carrier of L;
  coherence
  proof
A1: LattRel L = { [p,q] where p is Element of L,
    q is Element of L: p [= q } by FILTER_1:def 8;
    LattRel L c= [:the carrier of L,the carrier of L:]
    proof
      let x be set;
      assume x in LattRel L;
      then ex p,q being Element of L st x = [p,q] & p [= q by A1;
      hence thesis by ZFMISC_1:106;
    end;
    then reconsider R = LattRel L as Relation of the carrier of L
    by RELSET_1:def 1;
A2: R is_reflexive_in the carrier of L
    proof
      let x be set;
      assume x in the carrier of L;
      then reconsider x as Element of L;
      x [= x;
      hence thesis by FILTER_1:32;
    end;
A3: R is_antisymmetric_in the carrier of L
    proof
      let x,y be set;
      assume x in the carrier of L & y in the carrier of L;
      then reconsider x' = x, y' = y as Element of L;
      assume [x,y] in R & [y,x] in R;
      then x' [= y' & y' [= x' by FILTER_1:32;
      hence thesis by LATTICES:26;
    end;
A4: R is_transitive_in the carrier of L
    proof
      let x,y,z be set;
      assume x in the carrier of L & y in the carrier of L &
      z in the carrier of L;
      then reconsider x' = x, y' = y, z' = z as Element of L;
      assume [x,y] in R & [y,z] in R;
      then x' [= y' & y' [= z' by FILTER_1:32;
      then x' [= z' by LATTICES:25;
      hence thesis by FILTER_1:32;
    end;
A5: dom R = the carrier of L by A2,ORDERS_1:98;
    field R = the carrier of L by A2,ORDERS_1:98;
    hence thesis by A2,A3,A4,A5,PARTFUN1:def 4,RELAT_2:def 9,def 12,def 16;
  end;
end;

begin :: Binary approach to ortholattices

definition
  struct (LattRelStr, OrthoLattStr, OrthoRelStr) OrthoLattRelStr
  (# carrier -> set, L_join, L_meet -> (BinOp of the carrier),
    InternalRel -> (Relation of the carrier), Compl -> UnOp of the carrier #);
end;

definition
  func TrivCLRelStr -> OrthoLattRelStr equals
  OrthoLattRelStr (# 1, op2, op2, id 1, op1 #);
  coherence;
end;

:: Axiomatics for ortholattices is the classical one for lattices extended
:: by the three following:
:: x ^ y = c(c(x) v c(y)).     % DM   de_Morgan from ROBBINS1
:: c(c(x)) = x.                % CC   dneg from OPOSET_1, too specific
:: x v c(x) = y v c(y).        % ONE

definition
  let L be non empty ComplStr;
  attr L is involutive means
  :Def6:
  for x being Element of L holds x`` = x;
end;

definition
  let L be non empty ComplLattStr;
  attr L is with_Top means
  :Def7:
  for x, y being Element of L holds
  x |_| x` = y |_| y`;
end;

registration
  cluster TrivOrtLat -> involutive with_Top;
  coherence
  proof
    thus TrivOrtLat is involutive
    proof
      let x be Element of TrivOrtLat;
      thus thesis by STRUCT_0:def 10;
    end;
    thus TrivOrtLat is with_Top
    proof
      let x, y be Element of TrivOrtLat;
      thus thesis by STRUCT_0:def 10;
    end;
  end;
end;

registration
  cluster TrivCLRelStr -> non empty trivial;
  coherence by CARD_1:87,STRUCT_0:def 1,def 9;
end;

registration
  cluster TrivCLRelStr -> reflexive;
  coherence
  proof
    for x being Element of TrivCLRelStr holds x <= x
    proof
      let x be Element of TrivCLRelStr;
      [x,x] in id {{}} by CARD_1:87,RELAT_1:def 10;
      hence thesis by CARD_1:87,ORDERS_2:def 9;
    end;
    hence thesis by YELLOW_0:def 1;
  end;
end;

registration
  cluster TrivCLRelStr -> involutive with_Top;
  coherence
  proof
    set L = TrivCLRelStr;
    thus L is involutive
    proof
      let x be Element of L;
      thus thesis by STRUCT_0:def 10;
    end;
    thus L is with_Top
    proof
      let x, y be Element of L;
      thus thesis by STRUCT_0:def 10;
    end;
  end;
end;

registration
  cluster involutive with_Top de_Morgan Lattice-like (non empty OrthoLattStr);
  existence
  proof
    take TrivOrtLat;
    thus thesis;
  end;
end;

definition
  mode Ortholattice is involutive with_Top de_Morgan
    Lattice-like (non empty OrthoLattStr);
end;

begin :: Lemmas

theorem Th9:
  for K, L being non empty LattStr st the LattStr of K = the LattStr of L &
  K is join-commutative holds L is join-commutative
proof
  let K, L be non empty LattStr;
  assume
A1: the LattStr of K = the LattStr of L & K is join-commutative;
  L is join-commutative
  proof
    let x, y be Element of L;
    reconsider x' = x, y' = y as Element of K by A1;
    x' |_| y' = y' |_| x' by A1,LATTICES:def 4;
    hence thesis by A1;
  end;
  hence thesis;
end;

theorem Th10:
  for K, L being non empty LattStr st the LattStr of K = the LattStr of L &
  K is meet-commutative holds L is meet-commutative
proof
  let K, L be non empty LattStr;
  assume
A1: the LattStr of K = the LattStr of L & K is meet-commutative;
  L is meet-commutative
  proof
    let x, y be Element of L;
    reconsider x' = x, y' = y as Element of K by A1;
    x' "/\" y' = y' "/\" x' by A1,LATTICES:def 6;
    hence thesis by A1;
  end;
  hence thesis;
end;

theorem Th11:
  for K, L being non empty LattStr st the LattStr of K = the LattStr of L &
  K is join-associative holds L is join-associative
proof
  let K, L be non empty LattStr;
  assume
A1: the LattStr of K = the LattStr of L & K is join-associative;
  L is join-associative
  proof
    let x, y, z be Element of L;
    reconsider x' = x, y' = y, z' = z as Element of K by A1;
    (x' |_| y') |_| z' = x' |_| (y' |_| z') by A1,LATTICES:def 5;
    hence thesis by A1;
  end;
  hence thesis;
end;

theorem Th12:
  for K, L being non empty LattStr st the LattStr of K = the LattStr of L &
  K is meet-associative holds L is meet-associative
proof
  let K, L be non empty LattStr;
  assume
A1: the LattStr of K = the LattStr of L & K is meet-associative;
  L is meet-associative
  proof
    let x, y, z be Element of L;
    reconsider x' = x, y' = y, z' = z as Element of K by A1;
    (x' "/\" y') "/\" z' = x' "/\" (y' "/\" z') by A1,LATTICES:def 7;
    hence thesis by A1;
  end;
  hence thesis;
end;

theorem Th13:
  for K, L being non empty LattStr st the LattStr of K = the LattStr of L &
  K is join-absorbing holds L is join-absorbing
proof
  let K, L be non empty LattStr;
  assume
A1: the LattStr of K = the LattStr of L & K is join-absorbing;
  L is join-absorbing
  proof
    let x, y be Element of L;
    reconsider x' = x, y' = y as Element of K by A1;
    x' "/\" (x' "\/" y') = x' by A1,LATTICES:def 9;
    hence thesis by A1;
  end;
  hence thesis;
end;

theorem Th14:
  for K, L being non empty LattStr st the LattStr of K = the LattStr of L &
  K is meet-absorbing holds L is meet-absorbing
proof
  let K, L be non empty LattStr;
  assume
A1: the LattStr of K = the LattStr of L & K is meet-absorbing;
  L is meet-absorbing
  proof
    let x, y be Element of L;
    reconsider x' = x, y' = y as Element of K by A1;
    (x' "/\" y') "\/" y' = y' by A1,LATTICES:def 8;
    hence thesis by A1;
  end;
  hence thesis;
end;

theorem
  for K, L being non empty LattStr st the LattStr of K = the LattStr of L &
  K is Lattice-like holds L is Lattice-like
proof
  let K, L be non empty LattStr;
  assume
A1: the LattStr of K = the LattStr of L & K is Lattice-like;
  then K is join-commutative join-associative meet-absorbing
  meet-commutative meet-associative join-absorbing by LATTICES:def 10;
  then L is join-commutative join-associative meet-absorbing
  meet-commutative meet-associative join-absorbing
  by A1,Th9,Th10,Th11,Th12,Th13,Th14;
  hence thesis by LATTICES:def 10;
end;

theorem
  for L1,L2 being non empty \/-SemiLattStr st
  the \/-SemiLattStr of L1 = the \/-SemiLattStr of L2
  for a1,b1 being Element of L1, a2,b2 being Element of L2 st
  a1 = a2 & b1 = b2 holds a1 "\/" b1 = a2 "\/" b2;

theorem
  for L1,L2 being non empty /\-SemiLattStr st
  the /\-SemiLattStr of L1 = the /\-SemiLattStr of L2
  for a1,b1 being Element of L1, a2,b2 being Element of L2 st
  a1 = a2 & b1 = b2 holds a1 "/\" b1 = a2 "/\" b2;

theorem Th18:
  for K, L being non empty ComplStr, x being Element of K,
  y being Element of L st the Compl of K = the Compl of L & x = y holds
  x` = y`
proof
  let K, L be non empty ComplStr, x be Element of K, y be Element of L;
  assume the Compl of K = the Compl of L & x = y;
  then x` = (the Compl of L).y by ROBBINS1:def 3
    .= y` by ROBBINS1:def 3;
  hence thesis;
end;

theorem Th19:
  for K, L being non empty ComplLattStr st
  the ComplLattStr of K = the ComplLattStr of L & K is with_Top holds
  L is with_Top
proof
  let K, L be non empty ComplLattStr;
  assume
A1: the ComplLattStr of K = the ComplLattStr of L & K is with_Top;
  for x, y being Element of L holds x |_| x` = y |_| y`
  proof
    let x, y be Element of L;
    reconsider x' = x, y' = y as Element of K by A1;
    x |_| x` = x' |_| x'` by A1,Th18
      .= y' |_| y'` by A1,Def7
      .= y |_| y` by A1,Th18;
    hence thesis;
  end;
  hence thesis by Def7;
end;

theorem Th20:
  for K, L being non empty OrthoLattStr st
  the OrthoLattStr of K = the OrthoLattStr of L & K is de_Morgan holds
  L is de_Morgan
proof
  let K, L be non empty OrthoLattStr;
  assume
A1: the OrthoLattStr of K = the OrthoLattStr of L & K is de_Morgan;
  for x, y being Element of L holds x "/\" y = (x` "\/" y`)`
  proof
    let x, y be Element of L;
    reconsider x' = x, y' = y as Element of K by A1;
A2: x` = x'` & y` = y'` by A1,Th18;
    x "/\" y = x' "/\" y' by A1
      .= (x'` "\/" y'`)` by A1,ROBBINS1:def 23
      .= (x` "\/" y`)` by A1,A2,Th18;
    hence thesis;
  end;
  hence thesis by ROBBINS1:def 23;
end;

theorem Th21:
  for K, L being non empty OrthoLattStr st
  the OrthoLattStr of K = the OrthoLattStr of L & K is involutive holds
  L is involutive
proof
  let K, L be non empty OrthoLattStr;
  assume
A1: the OrthoLattStr of K = the OrthoLattStr of L & K is involutive;
  for x being Element of L holds x`` = x
  proof
    let x be Element of L;
    reconsider x' = x as Element of K by A1;
    x` = x'` by A1,Th18;
    then x`` = x'`` by A1,Th18
      .= x by A1,Def6;
    hence thesis;
  end;
  hence thesis by Def6;
end;

begin :: Structure Extensions

definition
  let R be RelStr;
  mode RelAugmentation of R -> LattRelStr means
    the RelStr of it = the RelStr of R;
  existence
  proof
    consider A, B being BinOp of the carrier of R;
    set L = LattRelStr (# the carrier of R, A, B, the InternalRel of R #);
    take L;
    thus thesis;
  end;
end;

definition
  let R be LattStr;
  mode LatAugmentation of R -> LattRelStr means
    :Def9:
    the LattStr of it = the LattStr of R;
  existence
  proof
    consider IR being Relation of the carrier of R;
    set L = LattRelStr (# the carrier of R,
      the L_join of R, the L_meet of R, IR #);
    take L;
    thus thesis;
  end;
end;

registration
  let L be non empty LattStr;
  cluster -> non empty LatAugmentation of L;
  coherence
  proof
    let R be LatAugmentation of L;
    the LattStr of L = the LattStr of R by Def9;
    hence thesis by STRUCT_0:def 1;
  end;
end;

registration
  let L be meet-associative (non empty LattStr);
  cluster -> meet-associative LatAugmentation of L;
  coherence
  proof
    let R be LatAugmentation of L;
    the LattStr of L = the LattStr of R by Def9;
    hence thesis by Th12;
  end;
end;

registration
  let L be join-associative (non empty LattStr);
  cluster -> join-associative LatAugmentation of L;
  coherence
  proof
    let R be LatAugmentation of L;
    the LattStr of L = the LattStr of R by Def9;
    hence thesis by Th11;
  end;
end;

registration
  let L be meet-commutative (non empty LattStr);
  cluster -> meet-commutative LatAugmentation of L;
  coherence
  proof
    let R be LatAugmentation of L;
    the LattStr of L = the LattStr of R by Def9;
    hence thesis by Th10;
  end;
end;

registration
  let L be join-commutative (non empty LattStr);
  cluster -> join-commutative LatAugmentation of L;
  coherence
  proof
    let R be LatAugmentation of L;
    the LattStr of L = the LattStr of R by Def9;
    hence thesis by Th9;
  end;
end;

registration
  let L be join-absorbing (non empty LattStr);
  cluster -> join-absorbing LatAugmentation of L;
  coherence
  proof
    let R be LatAugmentation of L;
    the LattStr of L = the LattStr of R by Def9;
    hence thesis by Th13;
  end;
end;

registration
  let L be meet-absorbing (non empty LattStr);
  cluster -> meet-absorbing LatAugmentation of L;
  coherence
  proof
    let R be LatAugmentation of L;
    the LattStr of L = the LattStr of R by Def9;
    hence thesis by Th14;
  end;
end;

definition
  let L be non empty \/-SemiLattRelStr;
  attr L is naturally_sup-generated means
  :Def10:
  for x, y being Element of L holds x <= y iff x |_| y = y;
end;

definition
  let L be non empty /\-SemiLattRelStr;
  attr L is naturally_inf-generated means
  :Def11:
  for x, y being Element of L holds x <= y iff x |^| y = x;
end;

registration
  let L be Lattice;
  cluster naturally_sup-generated naturally_inf-generated
    Lattice-like LatAugmentation of L;
  existence
  proof
    set R = LattRel L;
    set S = LattRelStr (# the carrier of L, the L_join of L,
      the L_meet of L, R #);
    the LattStr of L = the LattStr of S;
    then reconsider S as LatAugmentation of L by Def9;
    for x, y being Element of S holds x <= y iff x |_| y = y
    proof
      let x, y be Element of S;
      reconsider x' = x, y' = y as Element of L;
      hereby
        assume x <= y;
        then [x,y] in the InternalRel of S by ORDERS_2:def 9;
        then x' [= y' by FILTER_1:32;
        then x' |_| y' = y' by LATTICES:def 3;
        hence x |_| y = y;
      end;
      assume
A1:   x |_| y = y;
      x' |_| y' = x |_| y;
      then x' [= y' by A1,LATTICES:def 3;
      then [x',y'] in LattRel L by FILTER_1:32;
      hence thesis by ORDERS_2:def 9;
    end;
    then
A2: S is naturally_sup-generated by Def10;
    for x, y being Element of S holds x <= y iff x |^| y = x
    proof
      let x, y be Element of S;
      reconsider x' = x, y' = y as Element of L;
      hereby
        assume x <= y;
        then [x,y] in the InternalRel of S by ORDERS_2:def 9;
        then x' [= y' by FILTER_1:32;
        then x' |^| y' = x' by LATTICES:21;
        hence x |^| y = x;
      end;
      assume
A3:   x |^| y = x;
      x' |^| y' = x |^| y;
      then x' [= y' by A3,LATTICES:21;
      then [x',y'] in LattRel L by FILTER_1:32;
      hence thesis by ORDERS_2:def 9;
    end;
    then S is naturally_inf-generated by Def11;
    hence thesis by A2;
  end;
end;

registration
  cluster trivial non empty reflexive LattRelStr;
  existence
  proof
    take TrivLattRelStr;
    thus thesis;
  end;
end;

registration
  cluster trivial non empty reflexive OrthoLattRelStr;
  existence
  proof
    take TrivCLRelStr;
    thus thesis;
  end;
end;

registration
  cluster trivial non empty reflexive OrthoRelStr;
  existence
  proof
    take TrivOrthoRelStr;
    thus thesis;
  end;
end;

registration
  cluster trivial -> involutive with_Top de_Morgan
    well-complemented (non empty OrthoLattStr);
  coherence
  proof
    let L be non empty OrthoLattStr;
    assume L is trivial;
    then reconsider L' = L as trivial (non empty OrthoLattStr);
A1: for x, y being Element of L' holds x |_| x` = y |_| y` by STRUCT_0:def 10;
A2: for x, y being Element of L' holds
    x |^| y = (x` |_| y`)` by STRUCT_0:def 10;
A3: for x being Element of L' holds x`` = x by STRUCT_0:def 10;
    for x being Element of L' holds x` is_a_complement_of x
    proof
      let x be Element of L';
      x |_| x` = Top L' & x |^| x` = Bottom L' &
      x` |_| x = Top L' & x` |^| x = Bottom L' by STRUCT_0:def 10;
      hence thesis by LATTICES:def 18;
    end;
    hence thesis by A1,A2,A3,Def6,Def7,ROBBINS1:def 10,def 23;
  end;
end;

registration
  cluster trivial -> OrderInvolutive Pure PartialOrdered
    (non empty reflexive OrthoRelStr);
  coherence
  proof
    let L be non empty reflexive OrthoRelStr;
    assume L is trivial;
    then reconsider L' = L as trivial (non empty reflexive OrthoRelStr);
    reconsider f = the Compl of L' as Function of L', L';
    consider x being set such that
A1: the carrier of L' = {x} by REALSET1:def 4;
    f = id {x} by A1,FUNCT_2:66;
    then
A2: f is dneg by A1,OPOSET_1:20;
    for z, y being Element of L' st z <= y holds f.z >= f.y
    proof
      let z, y be Element of L';
      assume z <= y;
A3:   f.z = x by A1,FUNCT_2:65;
      f.y = x by A1,FUNCT_2:65;
      hence thesis by A3,YELLOW_0:def 1;
    end;
    then f is antitone by WAYBEL_9:def 1;
    then
A4: f is Orderinvolutive by A2,OPOSET_1:def 32;
    L' is Dneg by A2,OPOSET_1:def 6;
    hence thesis by A4,OPOSET_1:def 26,def 33;
  end;
end;

registration
  cluster trivial -> naturally_sup-generated naturally_inf-generated
    (non empty reflexive LattRelStr);
  coherence
  proof
    let L be non empty reflexive LattRelStr;
    assume L is trivial;
    then reconsider L' = L as trivial (non empty reflexive LattRelStr);
A1: L' is naturally_sup-generated
    proof
      for x, y being Element of L' holds
      x <= y iff x |_| y = y by STRUCT_0:def 10;
      hence thesis by Def10;
    end;
    L' is naturally_inf-generated
    proof
      for x, y being Element of L' holds
      x <= y iff x |^| y = x by STRUCT_0:def 10;
      hence thesis by Def11;
    end;
    hence thesis by A1;
  end;
end;

registration
  cluster with_infima with_suprema naturally_sup-generated
    naturally_inf-generated de_Morgan Lattice-like OrderInvolutive Pure
    PartialOrdered (non empty OrthoLattRelStr);
  existence
  proof
    take TrivCLRelStr;
    thus thesis;
  end;
end;

registration
  cluster with_infima with_suprema naturally_sup-generated
    naturally_inf-generated Lattice-like (non empty LattRelStr);
  existence
  proof
    take TrivLattRelStr;
    thus thesis;
  end;
end;

theorem Th22:
  for L being naturally_sup-generated (non empty LattRelStr),
  x, y being Element of L holds x <= y iff x [= y
proof
  let L be naturally_sup-generated (non empty LattRelStr),
  x, y be Element of L;
  hereby
    assume x <= y;
    then x |_| y = y by Def10;
    hence x [= y by LATTICES:def 3;
  end;
  assume x [= y;
  then x |_| y = y by LATTICES:def 3;
  hence thesis by Def10;
end;

theorem Th23:
  for L being naturally_sup-generated Lattice-like (non empty LattRelStr)
  holds the RelStr of L = LattPOSet L
proof
  let L be naturally_sup-generated Lattice-like (non empty LattRelStr);
A1: LattPOSet L = RelStr (#the carrier of L, LattRel L#) by LATTICE3:def 2;
  for x, y being set holds
  [x,y] in the InternalRel of L iff [x,y] in LattRel L
  proof
    let x, y be set;
    hereby
      assume
A2:   [x,y] in the InternalRel of L;
      then reconsider x' = x, y' = y as Element of L by ZFMISC_1:106;
      x' <= y' by A2,ORDERS_2:def 9;
      then x' [= y' by Th22;
      hence [x,y] in LattRel L by FILTER_1:32;
    end;
    assume
A3: [x,y] in LattRel L;
    then reconsider x' = x, y' = y as Element of L by ZFMISC_1:106;
    x' [= y' by A3,FILTER_1:32;
    then x' <= y' by Th22;
    hence thesis by ORDERS_2:def 9;
  end;
  hence thesis by A1,RELAT_1:def 2;
end;

registration
  cluster naturally_sup-generated Lattice-like ->
    with_infima with_suprema (non empty LattRelStr);
  coherence
  proof
    let L be non empty LattRelStr;
    assume L is naturally_sup-generated Lattice-like;
    then reconsider L' = L as naturally_sup-generated Lattice-like
    (non empty LattRelStr);
    LattPOSet L' is with_suprema with_infima;
    then the RelStr of L' is with_suprema with_infima by Th23;
    hence thesis by YELLOW_7:14,15;
  end;
end;

begin :: Extending OrthoLattStr

definition
  let R be OrthoLattStr;
  mode CLatAugmentation of R -> OrthoLattRelStr means
    :Def12:
    the OrthoLattStr of it = the OrthoLattStr of R;
  existence
  proof
    consider IR being Relation of the carrier of R;
    set L = OrthoLattRelStr (# the carrier of R,
      the L_join of R, the L_meet of R, IR, the Compl of R #);
    take L;
    thus thesis;
  end;
end;

registration
  let L be non empty OrthoLattStr;
  cluster -> non empty CLatAugmentation of L;
  coherence
  proof
    let R be CLatAugmentation of L;
    the OrthoLattStr of L = the OrthoLattStr of R by Def12;
    hence thesis by STRUCT_0:def 1;
  end;
end;

registration
  let L be meet-associative (non empty OrthoLattStr);
  cluster -> meet-associative CLatAugmentation of L;
  coherence
  proof
    let R be CLatAugmentation of L;
    the OrthoLattStr of L = the OrthoLattStr of R by Def12;
    then the LattStr of L = the LattStr of R;
    hence thesis by Th12;
  end;
end;

registration
  let L be join-associative (non empty OrthoLattStr);
  cluster -> join-associative CLatAugmentation of L;
  coherence
  proof
    let R be CLatAugmentation of L;
    the OrthoLattStr of L = the OrthoLattStr of R by Def12;
    then the LattStr of L = the LattStr of R;
    hence thesis by Th11;
  end;
end;

registration
  let L be meet-commutative (non empty OrthoLattStr);
  cluster -> meet-commutative CLatAugmentation of L;
  coherence
  proof
    let R be CLatAugmentation of L;
    the OrthoLattStr of L = the OrthoLattStr of R by Def12;
    then the LattStr of L = the LattStr of R;
    hence thesis by Th10;
  end;
end;

registration
  let L be join-commutative (non empty OrthoLattStr);
  cluster -> join-commutative CLatAugmentation of L;
  coherence
  proof
    let R be CLatAugmentation of L;
    the OrthoLattStr of L = the OrthoLattStr of R by Def12;
    then the LattStr of L = the LattStr of R;
    hence thesis by Th9;
  end;
end;

registration
  let L be meet-absorbing (non empty OrthoLattStr);
  cluster -> meet-absorbing CLatAugmentation of L;
  coherence
  proof
    let R be CLatAugmentation of L;
    the OrthoLattStr of L = the OrthoLattStr of R by Def12;
    then the LattStr of L = the LattStr of R;
    hence thesis by Th14;
  end;
end;

registration
  let L be join-absorbing (non empty OrthoLattStr);
  cluster -> join-absorbing CLatAugmentation of L;
  coherence
  proof
    let R be CLatAugmentation of L;
    the OrthoLattStr of L = the OrthoLattStr of R by Def12;
    then the LattStr of L = the LattStr of R;
    hence thesis by Th13;
  end;
end;

registration
  let L be with_Top (non empty OrthoLattStr);
  cluster -> with_Top CLatAugmentation of L;
  coherence
  proof
    let R be CLatAugmentation of L;
    the OrthoLattStr of L = the OrthoLattStr of R by Def12;
    then the ComplLattStr of L = the ComplLattStr of R;
    hence thesis by Th19;
  end;
end;

registration
  let L be non empty Ortholattice;
  cluster naturally_sup-generated naturally_inf-generated Lattice-like
    CLatAugmentation of L;
  existence
  proof
    set R = LattRel L;
    set S = OrthoLattRelStr (# the carrier of L, the L_join of L,
      the L_meet of L, R, the Compl of L #);
    the OrthoLattStr of L = the OrthoLattStr of S;
    then reconsider S as CLatAugmentation of L by Def12;
    for x, y being Element of S holds x <= y iff x |_| y = y
    proof
      let x, y be Element of S;
      reconsider x' = x, y' = y as Element of L;
      hereby
        assume x <= y;
        then [x,y] in the InternalRel of S by ORDERS_2:def 9;
        then x' [= y' by FILTER_1:32;
        then x' |_| y' = y' by LATTICES:def 3;
        hence x |_| y = y;
      end;
      assume
A1:   x |_| y = y;
      x' |_| y' = x |_| y;
      then x' [= y' by A1,LATTICES:def 3;
      then [x',y'] in LattRel L by FILTER_1:32;
      hence thesis by ORDERS_2:def 9;
    end;
    then
A2: S is naturally_sup-generated by Def10;
    for x, y being Element of S holds x <= y iff x |^| y = x
    proof
      let x, y be Element of S;
      reconsider x' = x, y' = y as Element of L;
      hereby
        assume x <= y;
        then [x',y'] in the InternalRel of S by ORDERS_2:def 9;
        then x' [= y' by FILTER_1:32;
        then x' |^| y' = x' by LATTICES:21;
        hence x |^| y = x;
      end;
      assume
A3:   x |^| y = x;
      x' |^| y' = x |^| y;
      then x' [= y' by A3,LATTICES:21;
      then [x',y'] in LattRel L by FILTER_1:32;
      hence thesis by ORDERS_2:def 9;
    end;
    then S is naturally_inf-generated by Def11;
    hence thesis by A2;
  end;
end;

registration
  cluster involutive with_Top de_Morgan Lattice-like
    naturally_sup-generated well-complemented (non empty OrthoLattRelStr);
  existence
  proof
    take TrivCLRelStr;
    thus thesis;
  end;
end;

theorem Th24:
  for L being with_infima with_suprema PartialOrdered (non empty OrthoRelStr)
  for x,y being Element of L holds x <= y implies
  y = x "|_|" y & x = x "|^|" y
proof
  let L be with_infima with_suprema PartialOrdered (non empty OrthoRelStr);
  let a,b be Element of L;
  assume
A1: a <= b;
  then b = b "|_|" a by YELLOW_0:24;
  hence thesis by A1,LATTICE3:13,YELLOW_0:25;
end;

definition
  let L be meet-commutative (non empty /\-SemiLattStr), a, b be Element of L;
  redefine func a |^| b;
  commutativity by LATTICES:def 6;
end;

definition
  let L be join-commutative (non empty \/-SemiLattStr), a, b be Element of L;
  redefine func a |_| b;
  commutativity by LATTICES:def 4;
end;

registration
  cluster meet-absorbing join-absorbing meet-commutative
    naturally_sup-generated -> reflexive (non empty LattRelStr);
  coherence
  proof
    let L be non empty LattRelStr;
    assume L is meet-absorbing join-absorbing meet-commutative
    naturally_sup-generated;
    then reconsider L' = L as meet-absorbing join-absorbing meet-commutative
    naturally_sup-generated (non empty LattRelStr);
    for x being Element of L' holds x <= x
    proof
      let x be Element of L';
      x [= x;
      hence thesis by Th22;
    end;
    hence thesis by YELLOW_0:def 1;
  end;
end;

registration
  cluster join-associative naturally_sup-generated -> transitive
    (non empty LattRelStr);
  coherence
  proof
    let L be non empty LattRelStr;
    assume L is join-associative naturally_sup-generated;
    then reconsider L' = L as join-associative naturally_sup-generated
    (non empty LattRelStr);
    for x, y, z being Element of L' st x <= y & y <= z holds x <= z
    proof
      let x, y, z be Element of L';
      assume x <= y & y <= z;
      then x [= y & y [= z by Th22;
      then x [= z by LATTICES:25;
      hence thesis by Th22;
    end;
    hence thesis by YELLOW_0:def 2;
  end;
end;

registration
  cluster join-commutative naturally_sup-generated -> antisymmetric
    (non empty LattRelStr);
  coherence
  proof
    let L be non empty LattRelStr;
    assume L is join-commutative naturally_sup-generated;
    then reconsider L' = L as join-commutative naturally_sup-generated
    (non empty LattRelStr);
    for x, y being Element of L' st x <= y & y <= x holds x = y
    proof
      let x, y be Element of L';
      assume x <= y & y <= x;
      then x [= y & y [= x by Th22;
      hence thesis by LATTICES:26;
    end;
    hence thesis by YELLOW_0:def 3;
  end;
end;

theorem Th25:
  for L being with_infima with_suprema naturally_sup-generated
  Lattice-like (non empty OrthoLattRelStr), x, y being Element of L holds
  x "|_|" y = x |_| y
proof
  let L be with_infima with_suprema naturally_sup-generated
  Lattice-like (non empty OrthoLattRelStr), x, y be Element of L;
  x <= x "|_|" y by YELLOW_0:22;
  then
A1: x [= x "|_|" y by Th22;
  y <= x "|_|" y by YELLOW_0:22;
  then
A2: y [= x "|_|" y by Th22;
A3: (x "|_|" y) |_| (x |_| y) = (x "|_|" y) |_| x |_| y by LATTICES:def 5
    .= (x "|_|" y) |_| y by A1,LATTICES:def 3
    .= x "|_|" y by A2,LATTICES:def 3;
  y [= x |_| y by LATTICES:22;
  then
A4: y <= x |_| y by Th22;
  x [= x |_| y by LATTICES:22;
  then
A5: x <= x |_| y by Th22;
  (x |_| y) "|_|" (x "|_|" y) = (x |_| y) "|_|" x "|_|" y by LATTICE3:14
    .= (x |_| y) "|_|" y by A5,YELLOW_0:24
    .= x |_| y by A4,YELLOW_0:24;
  then x "|_|" y <= x |_| y by YELLOW_0:24;
  then x "|_|" y [= x |_| y by Th22;
  hence thesis by A3,LATTICES:def 3;
end;

theorem Th26:
  for L being with_infima with_suprema naturally_sup-generated
  Lattice-like (non empty OrthoLattRelStr), x, y being Element of L holds
  x "|^|" y = x |^| y
proof
  let L be with_infima with_suprema naturally_sup-generated
  Lattice-like (non empty OrthoLattRelStr), x, y be Element of L;
  x "|^|" y <= x by YELLOW_0:23;
  then
A1: x "|^|" y [= x by Th22;
  x "|^|" y <= y by YELLOW_0:23;
  then
A2: x "|^|" y [= y by Th22;
A3: (x "|^|" y) |^| (x |^| y) = (x "|^|" y) |^| x |^| y by LATTICES:def 7
    .= (x "|^|" y) |^| y by A1,LATTICES:21
    .= x "|^|" y by A2,LATTICES:21;
  x |^| y [= y by LATTICES:23;
  then
A4: x |^| y <= y by Th22;
  x |^| y [= x by LATTICES:23;
  then
A5: x |^| y <= x by Th22;
  (x |^| y) "|^|" (x "|^|" y) = (x |^| y) "|^|" x "|^|" y by LATTICE3:16
    .= (x |^| y) "|^|" y by A5,YELLOW_0:25
    .= x |^| y by A4,YELLOW_0:25;
  then x |^| y <= x "|^|" y by YELLOW_0:25;
  then x |^| y [= x "|^|" y by Th22;
  hence thesis by A3,LATTICES:21;
end;

theorem
  for L being with_infima with_suprema naturally_sup-generated
  naturally_inf-generated Lattice-like OrderInvolutive
  PartialOrdered (non empty OrthoLattRelStr) holds L is de_Morgan
proof
  let L be with_infima with_suprema
  naturally_sup-generated naturally_inf-generated Lattice-like
  OrderInvolutive PartialOrdered (non empty OrthoLattRelStr);
A1: for x,y being Element of L holds x` "|_|" y` <= ( x "|^|" y )`
  proof
    let a,b be Element of L;
    set i = a "|^|" b;
    set s = a` "|_|" b`;
    i <= a & i <= b by YELLOW_0:23;
    then
A2: a` <= i` & b` <= i` by Th7;
    then
A3: s <= i` "|_|" b` by WAYBEL_1:3;
    i` = b` "|_|" i` by A2,Th24;
    hence thesis by A3,LATTICE3:13;
  end;
A4: for x,y being Element of L holds ( x "|_|" y )` <= x` "|^|" y`
  proof
    let a,b be Element of L;
    set i = a` "|^|" b`;
    set s = a "|_|" b;
    a <= s & b <= s by YELLOW_0:22;
    then
A5: s` <= a` & s` <= b` by Th7;
    then s` "|^|" b` <= i by WAYBEL_1:2;
    hence thesis by A5,Th24;
  end;
  L is de_Morgan
  proof
    for x,y being Element of L holds (x` |_| y`)` = x |^| y
    proof
      let a,b be Element of L;
      set s = a` "|_|" b`;
      set i = a "|^|" b;
A6:   i = a |^| b by Th26;
A7:   s = a` |_| b` by Th25;
      a`` = a & b`` = b by Th6;
      then
A8:   s` <= i by A4;
      i`` <= s` by A1,Th7;
      then i <= s` by Th6;
      hence thesis by A6,A7,A8,ORDERS_2:25;
    end;
    hence thesis by ROBBINS1:def 23;
  end;
  hence thesis;
end;

registration
  let L be Ortholattice;
  cluster -> involutive CLatAugmentation of L;
  coherence
  proof
    let R be CLatAugmentation of L;
    the OrthoLattStr of L = the OrthoLattStr of R by Def12;
    hence thesis by Th21;
  end;
end;

registration
  let L be Ortholattice;
  cluster -> de_Morgan CLatAugmentation of L;
  coherence
  proof
    let R be CLatAugmentation of L;
    the OrthoLattStr of L = the OrthoLattStr of R by Def12;
    hence thesis by Th20;
  end;
end;

theorem Th28:
  for L being non empty OrthoLattRelStr st
  L is involutive with_Top de_Morgan Lattice-like
  naturally_sup-generated holds L is Orthocomplemented PartialOrdered
proof
  let L be non empty OrthoLattRelStr;
  assume L is involutive with_Top de_Morgan Lattice-like
  naturally_sup-generated;
  then reconsider L' = L as involutive with_Top de_Morgan Lattice-like
  naturally_sup-generated (non empty OrthoLattRelStr);
  reconsider f = the Compl of L' as Function of L', L';
  for x being Element of L' holds f.(f.x) = x
  proof
    let x be Element of L';
    f.(f.x) = f.(x`) by ROBBINS1:def 3
      .= x`` by ROBBINS1:def 3
      .= x by Def6;
    hence thesis;
  end;
  then
A1: f is dneg by OPOSET_1:def 3;
  for x, y being Element of L' st x <= y holds f.x >= f.y
  proof
    let x, y be Element of L';
    assume
A2: x <= y;
A3: f.x = x` by ROBBINS1:def 3;
A4: f.y = y` by ROBBINS1:def 3;
    x [= y by A2,Th22;
    then x` = (x |^| y)` by LATTICES:21
      .= (x` |_| y`)`` by ROBBINS1:def 23
      .= x` |_| y` by Def6;
    hence thesis by A3,A4,Def10;
  end;
  then f is antitone by WAYBEL_9:def 1;
  then
A5: f is Orderinvolutive by A1,OPOSET_1:def 32;
  for y being Element of L' holds ex_sup_of {y,f.y},L' & ex_inf_of {y,f.y},L'
  & "\/"({y,f.y},L') is_maximum_of the carrier of L' &
  "/\"({y,f.y},L') is_minimum_of the carrier of L'
  proof
    let y be Element of L';
    thus ex_sup_of {y,f.y},L' by YELLOW_0:20;
    thus ex_inf_of {y,f.y},L' by YELLOW_0:21;
    set t = y |_| y`;
    for b being Element of L' st b in the carrier of L' holds b <= t
    proof
      let b be Element of L';
      assume b in the carrier of L';
      b |_| (y |_| y`) = b |_| (b |_| b`) by Def7
        .= b |_| b |_| b` by LATTICES:def 5
        .= b |_| b` by LATTICES:17
        .= y |_| y` by Def7;
      then b [= t by LATTICES:def 3;
      hence thesis by Th22;
    end;
    then
A6: t is_>=_than the carrier of L' by LATTICE3:def 9;
    then L' is upper-bounded by YELLOW_0:def 5;
    then
A7: ex_sup_of the carrier of L',L' by YELLOW_0:43;
    reconsider t as Element of L';
    set xx = "\/"(the carrier of L',L');
A8: for a being Element of L' st the carrier of L' is_<=_than a holds
    t <= a by LATTICE3:def 9;
    "\/"({y,f.y},L') = "\/"({y,y`},L') by ROBBINS1:def 3
      .= y "|_|" y` by YELLOW_0:41
      .= y |_| y` by Th25
      .= xx by A6,A7,A8,YELLOW_0:def 9;
    hence "\/"({y,f.y},L') is_maximum_of the carrier of L'
    by A7,WAYBEL_1:def 7;
A9: for a, b being Element of L' holds a |^| a` = b |^| b`
    proof
      let a, b be Element of L';
      a |^| a` = (a` |_| a``)` by ROBBINS1:def 23
        .= (b` |_| b``)` by Def7
        .= b |^| b` by ROBBINS1:def 23;
      hence thesis;
    end;
    set t = y |^| y`;
    for b being Element of L' st b in the carrier of L' holds b >= t
    proof
      let b be Element of L';
      assume b in the carrier of L';
      b |^| (y |^| y`) = b |^| (b |^| b`) by A9
        .= b |^| b |^| b` by LATTICES:def 7
        .= b |^| b` by LATTICES:18
        .= y |^| y` by A9;
      then t [= b by LATTICES:21;
      hence thesis by Th22;
    end;
    then
A10: t is_<=_than the carrier of L' by LATTICE3:def 8;
    then L' is lower-bounded by YELLOW_0:def 4;
    then
A11: ex_inf_of the carrier of L',L' by YELLOW_0:42;
    reconsider t as Element of L';
    set xx = "/\"(the carrier of L',L');
A12: for a being Element of L' st the carrier of L' is_>=_than a holds
    t >= a by LATTICE3:def 8;
    "/\"({y,f.y},L') = "/\"({y,y`},L') by ROBBINS1:def 3
      .= y "|^|" y` by YELLOW_0:40
      .= y |^| y` by Th26
      .= xx by A10,A11,A12,YELLOW_0:def 10;
    hence "/\"({y,f.y},L') is_minimum_of the carrier of L'
    by A11,WAYBEL_1:def 6;
  end;
  then f OrthoComplement_on L' by A5,OPOSET_1:def 36;
  hence thesis by OPOSET_1:def 37;
end;

theorem
  for L being Ortholattice,
  E being naturally_sup-generated CLatAugmentation of L holds
  E is Orthocomplemented by Th28;

registration
  let L be Ortholattice;
  cluster -> Orthocomplemented
    (naturally_sup-generated CLatAugmentation of L);
  coherence by Th28;
end;

theorem Th30:
  for L being non empty OrthoLattStr st
  L is Boolean well-complemented Lattice-like holds L is Ortholattice
proof
  let L be non empty OrthoLattStr;
  assume L is Boolean well-complemented Lattice-like;
  then reconsider L' = L as Boolean well-complemented Lattice-like
  (non empty OrthoLattStr);
A1: for x being Element of L' holds x`` = x by ROBBINS1:3;
A2: for x, y being Element of L' holds x |_| x` = y |_| y` by ROBBINS1:4;
  for x, y being Element of L' holds x "/\" y = (x` "\/" y`)` by ROBBINS1:34;
  hence thesis by A1,A2,Def6,Def7,ROBBINS1:def 23;
end;

registration
  cluster Boolean well-complemented Lattice-like ->
    involutive with_Top de_Morgan (non empty OrthoLattStr);
  coherence by Th30;
end;

