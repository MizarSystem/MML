:: Generalized Full Adder Circuits (GFAs). {P}art {I}
::  by Shin'nosuke Yamaguchi , Katsumi Wasaki and Nobuhiro Shimoi
::
:: Received December 7, 2005
:: Copyright (c) 2005 Association of Mizar Users

environ

 vocabularies BOOLE, RELAT_1, FUNCT_1, FINSEQ_1, FINSEQ_2, FUNCT_4, ZF_LANG,
      LATTICES, MARGREL1, MIDSP_3, BINARITH, CLASSES1, PARTFUN1, AMI_1,
      MSUALG_1, MSAFREE2, CIRCUIT1, CIRCUIT2, CIRCCOMB, FACIRC_1, TWOSCOMP,
      GFACIRC1;
 notations TARSKI, XBOOLE_0, ENUMSET1, SUBSET_1, NAT_1, RELAT_1, STRUCT_0,
      FUNCT_1, FUNCT_2, FINSEQ_1, FINSEQ_2, MARGREL1, CLASSES1, BINARITH,
      MSUALG_1, MSAFREE2, CIRCUIT1, CIRCUIT2, CIRCCOMB, FACIRC_1, TWOSCOMP;
 constructors ENUMSET1, XXREAL_0, CLASSES1, BINARITH, CIRCUIT1, CIRCUIT2,
      FACIRC_1, TWOSCOMP;
 registrations STRUCT_0, RELAT_1, RELSET_1, FINSEQ_2, FRAENKEL, MARGREL1,
      CARD_3, CIRCCOMB, FACIRC_1;
 requirements NUMERALS, REAL, BOOLE, SUBSET, ARITHM;
 definitions TARSKI, XBOOLE_0, CIRCUIT2, FACIRC_1, MSAFREE2, MARGREL1,
      XBOOLEAN;
 theorems TARSKI, XBOOLE_0, XBOOLE_1, ZFMISC_1, ENUMSET1, RELAT_1, ORDINAL1,
      FUNCT_1, FUNCT_2, FINSEQ_1, FINSEQ_2, FINSEQ_3, FINSEQ_6, BINARITH,
      CIRCUIT1, CIRCUIT2, CIRCCOMB, FACIRC_1, TWOSCOMP, CIRCCMB2, FACIRC_2,
      XBOOLEAN;
 schemes FUNCT_2, FACIRC_1;

begin :: Preliminaries

::========================================================================

::------------------------------------------
:: schemes for Boolean Operations (1 input)

scheme 1AryBooleEx {F(set) -> Element of BOOLEAN}:
 ex f being Function of 1-tuples_on BOOLEAN, BOOLEAN st
  for x being Element of BOOLEAN holds f.<*x*> = F(x)
proof
   deffunc G(Tuple of 1, BOOLEAN) = F($1.1);
   consider f being Function of 1-tuples_on BOOLEAN, BOOLEAN such that
A1:  for a being Tuple of 1, BOOLEAN holds f.a = G(a) from FUNCT_2:sch 4;
   hereby take f; let x be Element of BOOLEAN;
    reconsider a = <*x*> as Tuple of 1, BOOLEAN by FINSEQ_2:118;
    thus f.<*x*> = F(a.1) by A1
       .= F(x) by FINSEQ_1:def 8;
   end;
  end;

scheme 1AryBooleUniq {F(set) -> Element of BOOLEAN}:
 for f1,f2 being Function of 1-tuples_on BOOLEAN, BOOLEAN st
  (for x being Element of BOOLEAN holds f1.<*x*> = F(x)) &
  (for x being Element of BOOLEAN holds f2.<*x*> = F(x))
 holds f1 = f2
proof
   let f1,f2 be Function of 1-tuples_on BOOLEAN, BOOLEAN such that
A1:  for x being Element of BOOLEAN holds f1.<*x*> = F(x) and
A2:  for x being Element of BOOLEAN holds f2.<*x*> = F(x);
       now let a be Tuple of 1, BOOLEAN;
     consider x being Element of BOOLEAN such that
A3:    a = <*x*> by FINSEQ_2:117;
     thus f1.a = F(x) by A1,A3 .= f2.a by A2,A3;
    end;
   hence f1 = f2 by FUNCT_2:113;
  end;

scheme 1AryBooleDef {F(set) -> Element of BOOLEAN}:
 (ex f being Function of 1-tuples_on BOOLEAN, BOOLEAN st
  for x being Element of BOOLEAN holds f.<*x*> = F(x)) &
 for f1,f2 being Function of 1-tuples_on BOOLEAN, BOOLEAN st
  (for x being Element of BOOLEAN holds f1.<*x*> = F(x)) &
  (for x being Element of BOOLEAN holds f2.<*x*> = F(x))
 holds f1 = f2
proof
   deffunc G(Tuple of 1, BOOLEAN) = F($1.1);
   consider f being Function of 1-tuples_on BOOLEAN, BOOLEAN such that
A1:  for a being Tuple of 1, BOOLEAN holds f.a = G(a) from FUNCT_2:sch 4;
   hereby take f; let x be Element of BOOLEAN;
    reconsider a = <*x*> as Tuple of 1, BOOLEAN by FINSEQ_2:118;
    thus f.<*x*> = F(a.1) by A1
       .= F(x) by FINSEQ_1:def 8;
   end;
   let f1,f2 be Function of 1-tuples_on BOOLEAN, BOOLEAN such that
A2:  for x being Element of BOOLEAN holds f1.<*x*> = F(x) and
A3:  for x being Element of BOOLEAN holds f2.<*x*> = F(x);
    now let a be Tuple of 1, BOOLEAN;
     consider x being Element of BOOLEAN such that
A4:  a = <*x*> by FINSEQ_2:117;
     thus f1.a = F(x) by A2,A4 .= f2.a by A3,A4;
    end;
   hence f1 = f2 by FUNCT_2:113;
  end;

::-------------------------------------
:: 1-Input Operators (inv1, buf1)

definition
  func inv1 -> Function of 1-tuples_on BOOLEAN, BOOLEAN means
:Def1:
    for x being Element of BOOLEAN holds it.<*x*> = 'not' x;
  existence
   proof
  deffunc U(Element of BOOLEAN) = 'not' $1;
    thus ex t being Function of 1-tuples_on BOOLEAN, BOOLEAN st
    for x being Element of BOOLEAN holds t.<*x*> = U(x) from 1AryBooleEx;
   end;
  uniqueness
   proof
  deffunc U(Element of BOOLEAN) = 'not' $1;
    thus for t1,t2 being Function of 1-tuples_on BOOLEAN, BOOLEAN st
      (for x being Element of BOOLEAN holds t1.<*x*> = U(x)) &
      (for x being Element of BOOLEAN holds t2.<*x*> = U(x))
         holds t1 = t2 from 1AryBooleUniq;
   end;
end;

theorem Th1:
  for x being Element of BOOLEAN holds
    inv1.<*x*> = 'not' x & inv1.<*x*> = nand2.<*x,x*> &
    inv1.<*0*> = 1 & inv1.<*1*> = 0
  proof
    let x be Element of BOOLEAN;
    thus inv1.<*x*> = 'not' x by Def1;
    thus inv1.<*x*> = 'not' ( x '&' x ) by Def1
         .= nand2.<*x,x*> by TWOSCOMP:def 4;
    thus inv1.<*0*> = 'not' FALSE by Def1
         .= 1;
    thus inv1.<*1*> = 'not' TRUE by Def1
         .= 0;
  end;

definition
  func buf1 -> Function of 1-tuples_on BOOLEAN, BOOLEAN means
:Def2:
    for x being Element of BOOLEAN holds it.<*x*> = x;
  existence
   proof
  deffunc U(Element of BOOLEAN) = $1;
    thus ex t being Function of 1-tuples_on BOOLEAN, BOOLEAN st
    for x being Element of BOOLEAN holds t.<*x*> = U(x) from 1AryBooleEx;
   end;
  uniqueness
   proof
  deffunc U(Element of BOOLEAN) = $1;
    thus for t1,t2 being Function of 1-tuples_on BOOLEAN, BOOLEAN st
      (for x being Element of BOOLEAN holds t1.<*x*> = U(x)) &
      (for x being Element of BOOLEAN holds t2.<*x*> = U(x))
         holds t1 = t2 from 1AryBooleUniq;
   end;
end;

theorem
  for x being Element of BOOLEAN holds
    buf1.<*x*> = x & buf1.<*x*> = and2.<*x,x*> &
    buf1.<*0*> = 0 & buf1.<*1*> = 1
  proof
    let x be Element of BOOLEAN;
    thus buf1.<*x*> = x by Def2;
    thus buf1.<*x*> = x '&' x by Def2
         .= and2.<*x,x*> by TWOSCOMP:def 1;
    thus buf1.<*0*> = FALSE by Def2 .= 0;
    thus buf1.<*1*> = TRUE by Def2 .= 1;
  end;

::-------------------------------------
:: 2-Input Operators (and2c, xor2c)

definition
  func and2c -> Function of 2-tuples_on BOOLEAN, BOOLEAN means
:Def3:
    for x,y being Element of BOOLEAN holds it.<*x,y*> = x '&' 'not' y;
  existence
   proof
  deffunc U(Element of BOOLEAN,Element of BOOLEAN) = $1 '&' 'not' $2;
    thus ex t being Function of 2-tuples_on BOOLEAN, BOOLEAN st
    for x,y being Element of BOOLEAN holds t.<*x,y*> = U(x,y)
       from FACIRC_1:sch 1;
   end;
  uniqueness
   proof
  deffunc U(Element of BOOLEAN,Element of BOOLEAN) = $1 '&' 'not' $2;
    thus for t1,t2 being Function of 2-tuples_on BOOLEAN, BOOLEAN st
      (for x,y being Element of BOOLEAN holds t1.<*x,y*> = U(x,y)) &
      (for x,y being Element of BOOLEAN holds t2.<*x,y*> = U(x,y))
         holds t1 = t2 from FACIRC_1:sch 2;
   end;
end;

theorem
  for x,y being Element of BOOLEAN holds
    and2c.<*x,y*> = x '&' 'not' y &
    and2c.<*x,y*> = and2a.<*y,x*> & and2c.<*x,y*> = nor2a.<*x,y*> &
    and2c.<*0,0*>=0 & and2c.<*0,1*>=0 & and2c.<*1,0*>=1 & and2c.<*1,1*>=0
  proof
    let x,y be Element of BOOLEAN;
    thus and2c.<*x,y*> = x '&' 'not' y by Def3;
    thus and2c.<*x,y*>
          = x '&' 'not' y by Def3
         .=and2a.<*y,x*> by TWOSCOMP:def 2;
    thus and2c.<*x,y*>
          = 'not' ('not' x 'or' 'not' 'not' y) by Def3
         .= nor2a.<*x,y*> by TWOSCOMP:def 11;
    thus and2c.<*0,0*>
          = FALSE '&' 'not' FALSE by Def3
         .= 0;
    thus and2c.<*0,1*>
          = FALSE '&' 'not' TRUE by Def3
         .= 0;
    thus and2c.<*1,0*>
          = TRUE '&' 'not' FALSE by Def3
         .= 1;
    thus and2c.<*1,1*>
          = TRUE '&' 'not' TRUE by Def3
         .= 0;
  end;

definition
  func xor2c -> Function of 2-tuples_on BOOLEAN, BOOLEAN means
:Def4:
    for x,y being Element of BOOLEAN holds it.<*x,y*> = x 'xor' 'not' y;
  existence
   proof
  deffunc U(Element of BOOLEAN,Element of BOOLEAN) = $1 'xor' 'not' $2;
    thus ex t being Function of 2-tuples_on BOOLEAN, BOOLEAN st
    for x,y being Element of BOOLEAN holds t.<*x,y*> = U(x,y)
       from FACIRC_1:sch 1;
   end;
  uniqueness
   proof
  deffunc U(Element of BOOLEAN,Element of BOOLEAN) = $1 'xor' 'not' $2;
    thus for t1,t2 being Function of 2-tuples_on BOOLEAN, BOOLEAN st
      (for x,y being Element of BOOLEAN holds t1.<*x,y*> = U(x,y)) &
      (for x,y being Element of BOOLEAN holds t2.<*x,y*> = U(x,y))
         holds t1 = t2 from FACIRC_1:sch 2;
   end;
end;

theorem Th4:
  for x,y being Element of BOOLEAN holds
    xor2c.<*x,y*> = x 'xor' 'not' y &
    xor2c.<*x,y*> = xor2a.<*x,y*> &
    xor2c.<*x,y*> = or2.<*and2b.<*x,y*>,and2.<*x,y*> *> &
    xor2c.<*0,0*>=1 & xor2c.<*0,1*>=0 & xor2c.<*1,0*>=0 & xor2c.<*1,1*>=1
  proof
    let x,y be Element of BOOLEAN;
    thus xor2c.<*x,y*> = x 'xor' 'not' y by Def4;
    thus xor2c.<*x,y*> = x 'xor' 'not' y by Def4
     .= 'not' x 'xor' y
     .= xor2a.<*x,y*> by TWOSCOMP:def 14;
    thus xor2c.<*x,y*>
      = x 'xor' 'not' y by Def4
     .= ('not' x '&' 'not' y) 'or' (x '&' 'not' 'not' y)
     .= or2.<*('not' x '&' 'not' y), (x '&' y) *> by TWOSCOMP:def 7
     .= or2.<*and2b.<*x,y*>, (x '&' y) *> by TWOSCOMP:def 3
     .= or2.<*and2b.<*x,y*>,and2.<*x,y*> *> by TWOSCOMP:def 1;
    thus xor2c.<*0,0*>
      = FALSE 'xor' 'not' FALSE by Def4
     .= 1 by BINARITH:17;
    thus xor2c.<*0,1*>
      = FALSE 'xor' 'not' TRUE by Def4
     .= 0;
    thus xor2c.<*1,0*>
      = TRUE 'xor' 'not' FALSE by Def4
     .= 0;
    thus xor2c.<*1,1*>
      = TRUE 'xor' 'not' TRUE by Def4
     .= 1 by BINARITH:13;
  end;

theorem
  for x,y being Element of BOOLEAN holds
    'not' (x 'xor' y) = 'not' x 'xor' y &
    'not' (x 'xor' y) = x 'xor' 'not' y by XBOOLEAN:74;

theorem
  for x,y being Element of BOOLEAN holds
    inv1.<* xor2.<*x,y*> *> = xor2a.<*x,y*> &
    inv1.<* xor2.<*x,y*> *> = xor2c.<*x,y*> &
    xor2.<* inv1.<*x*>, inv1.<*y*> *> = xor2.<*x,y*>
  proof
    let x,y be Element of BOOLEAN;
    thus inv1.<* xor2.<*x,y*> *>
       = inv1.<* x 'xor' y *> by TWOSCOMP:def 13
      .= 'not' (x 'xor' y) by Def1
      .= 'not' x 'xor' y by XBOOLEAN:74
      .= xor2a.<*x,y*> by TWOSCOMP:def 14;
    hence inv1.<* xor2.<*x,y*> *> = xor2c.<*x,y*> by Th4;
    thus xor2.<* inv1.<*x*>, inv1.<*y*> *>
       = xor2.<* 'not' x, inv1.<*y*> *> by Th1
      .= xor2.<* 'not' x, 'not' y *> by Th1
      .= 'not' x 'xor' 'not' y by TWOSCOMP:def 13
      .= x 'xor' y
      .= xor2.<*x,y*> by TWOSCOMP:def 13;
  end;

theorem
  for x,y,z being Element of BOOLEAN holds
    'not' ( ( x 'xor' 'not' y ) 'xor'       z )
        =   ( x 'xor' 'not' y ) 'xor' 'not' z by XBOOLEAN:74;

theorem
  for x,y,z being Element of BOOLEAN holds
    inv1.<* xor2.<* xor2c.<*x,y*>, z*> *>
     = xor2c.<* xor2c.<*x,y*>, z*>
  proof
    let x,y,z be Element of BOOLEAN;
    thus inv1.<* xor2.<* xor2c.<*x,y*>, z*> *>
      = inv1.<* xor2.<* x 'xor' 'not' y, z *> *> by Def4
     .= inv1.<* ( x 'xor' 'not' y ) 'xor' z *> by TWOSCOMP:def 13
     .= 'not' ( ( x 'xor' 'not' y ) 'xor' z ) by Def1
     .=  ( x 'xor' 'not' y ) 'xor' 'not' z by XBOOLEAN:74
     .=  xor2c.<* x 'xor' 'not' y, z *>  by Def4
     .=  xor2c.<* xor2c.<*x,y*>, z *>  by Def4;
  end;

theorem
  for x,y,z being Element of BOOLEAN holds
       ( 'not' x 'xor'       y ) 'xor' 'not' z
     = (       x 'xor' 'not' y ) 'xor' 'not' z;

theorem
  for x,y,z being Element of BOOLEAN holds
       xor2c.<* xor2a.<*x,y*>, z *>
     = xor2c.<* xor2c.<*x,y*>, z *> by Th4;

theorem Th11:
  for x,y,z being Element of BOOLEAN holds
    'not' ( ( 'not' x 'xor' 'not' y ) 'xor' 'not' z )
     = ( x 'xor' y ) 'xor' z by XBOOLEAN:74;

theorem
  for x,y,z being Element of BOOLEAN holds
    inv1.<* xor2c.<* xor2b.<*x,y*>, z*> *>
     = xor2.<* xor2.<*x,y*>, z*>
  proof
    let x,y,z be Element of BOOLEAN;
    thus inv1.<* xor2c.<* xor2b.<*x,y*>, z*> *>
      = inv1.<* xor2c.<* 'not' x 'xor' 'not' y, z *> *> by TWOSCOMP:def 15
     .= inv1.<* ( 'not' x 'xor' 'not' y ) 'xor' 'not' z *> by Def4
     .= 'not' ( ( 'not' x 'xor' 'not' y ) 'xor' 'not' z ) by Def1
     .= ( x 'xor' y ) 'xor' z by Th11
     .=  xor2.<* x 'xor' y, z *>  by TWOSCOMP:def 13
     .=  xor2.<* xor2.<*x,y*>, z *>  by TWOSCOMP:def 13;
  end;

Lm1:
 for f1,f2,f3 being Function of 2-tuples_on BOOLEAN, BOOLEAN
  for x,y,z being set st
    x <> [<*y,z*>,f2] & y <> [<*z,x*>,f3] & z <> [<*x,y*>,f1]
  holds
    not [<*x,y*>,f1] in {y,z} &
    not z in {[<*x,y*>,f1], [<*y,z*>,f2]} &
    not x in {[<*x,y*>,f1], [<*y,z*>,f2]} &
    not [<*z,x*>,f3] in {x,y,z}
  proof
     let f1,f2,f3 be Function of 2-tuples_on BOOLEAN, BOOLEAN;
     let x,y,z be set;
     set xy = [<*x,y*>,f1], yz = [<*y,z*>,f2], zx = [<*z,x*>,f3];
     assume
A1:  x <> yz & y <> zx & z <> xy;
A2:  y in {1,y} & y in {2,y} by TARSKI:def 2;
A3:  {1,y} in [1,y] & {2,y} in [2,y] by TARSKI:def 2;
A4:  <*y,z*> in {<*y,z*>} & {<*y,z*>} in yz by TARSKI:def 1,def 2;
A5: z in {2,z} by TARSKI:def 2;
A6: {2,z} in [2,z] by TARSKI:def 2;
     2 in dom <*y,z*> & <*y,z*>.2 = z
      proof
       dom<*y,z*> = Seg 2 by FINSEQ_3:29;
       hence thesis by FINSEQ_1:3,61;
      end;
then [2,z] in <*y,z*> by FUNCT_1:8;
then A7:z <> yz by A4,A5,A6,ORDINAL1:5;
     2 in dom <*x,y*> & <*x,y*>.2 = y
      proof
       dom<*x,y*> = Seg 2 by FINSEQ_3:29;
       hence thesis by FINSEQ_1:3,61;
      end;
then A8: [2,y] in <*x,y*> by FUNCT_1:8;
     <*x,y*> in {<*x,y*>} & {<*x,y*>} in xy by TARSKI:def 1,def 2;
then y <> xy by A2,A3,A8,ORDINAL1:5;
     hence not xy in {y,z} by A1,TARSKI:def 2;
A9: x in {1,x} by TARSKI:def 2;
A10: {1,x} in [1,x] by TARSKI:def 2;
     <*x,y*> = <*x*>^<*y*> by FINSEQ_1:def 9;
then A11: <*x*> c= <*x,y*> by FINSEQ_6:12;
     <*x*> = {[1,x]} by FINSEQ_1:def 5;
then A12: [1,x] in <*x*> by TARSKI:def 1;
     <*x,y*> in {<*x,y*>} & {<*x,y*>} in xy by TARSKI:def 1,def 2;
then x <> xy by A9,A10,A11,A12,ORDINAL1:5;
     hence not z in {xy, yz} & not x in {xy, yz} by A1,A7,TARSKI:def 2;
A13: x in {2,x} by TARSKI:def 2;
A14: {2,x} in [2,x] by TARSKI:def 2;
     2 in dom <*z,x*> & <*z,x*>.2 = x
      proof
       dom<*z,x*> = Seg 2 by FINSEQ_3:29;
       hence thesis by FINSEQ_1:3,61;
      end;
then A15: [2,x] in <*z,x*> by FUNCT_1:8;
     <*z,x*> in {<*z,x*>} & {<*z,x*>} in zx by TARSKI:def 1,def 2;
then A16: x <> zx by A13,A14,A15,ORDINAL1:5;
A17: z in {1,z} by TARSKI:def 2;
A18: {1,z} in [1,z] by TARSKI:def 2;
     <*z,x*> = <*z*>^<*x*> by FINSEQ_1:def 9;
then A19: <*z*> c= <*z,x*> by FINSEQ_6:12;
     <*z*> = {[1,z]} by FINSEQ_1:def 5;
then A20: [1,z] in <*z*> by TARSKI:def 1;
     <*z,x*> in {<*z,x*>} & {<*z,x*>} in zx by TARSKI:def 1,def 2;
then z <> zx by A17,A18,A19,A20,ORDINAL1:5;
     hence not zx in {x,y,z} by A1,A16,ENUMSET1:def 1;
  end;

Lm2:
 for f1,f2,f3 being Function of 2-tuples_on BOOLEAN, BOOLEAN
  for f4 being Function of 3-tuples_on BOOLEAN, BOOLEAN
   for x,y,z being set
   holds {x, y, z} \ {[<*[<*x,y*>,f1], [<*y,z*>,f2], [<*z,x*>,f3]*>,f4]}
       = {x, y, z}
   proof
     let f1,f2,f3 be Function of 2-tuples_on BOOLEAN, BOOLEAN;
     let f4 be Function of 3-tuples_on BOOLEAN, BOOLEAN;
     let x,y,z be set;
     set xy = [<*x,y*>,f1], yz = [<*y,z*>,f2], zx = [<*z,x*>,f3];
     set xyz = [<*xy, yz, zx*>,f4];
     rng <*z,x*> = {z,x} by FINSEQ_2:147;
then A1: x in rng <*z,x*> by TARSKI:def 2;
     len <*xy, yz, zx*> = 3 by FINSEQ_1:62;
then A2: Seg 3 = dom <*xy, yz, zx*> by FINSEQ_1:def 3;
then A3: 3 in dom <*xy, yz, zx*> by FINSEQ_1:3;
     <*xy, yz, zx*>.3 = zx by FINSEQ_1:62;
then [3,zx] in <*xy, yz, zx*> by A3,FUNCT_1:8;
then zx in rng <*xy, yz, zx*> by RELAT_1:def 5;
then A4: the_rank_of zx in the_rank_of xyz by CIRCCOMB:50;
     rng <*x,y*> = {x,y} by FINSEQ_2:147;
then A5: y in rng <*x,y*> by TARSKI:def 2;
A6:  1 in dom <*xy, yz, zx*> by A2,FINSEQ_1:3;
     <*xy, yz, zx*>.1 = xy by FINSEQ_1:62;
then [1,xy] in <*xy, yz, zx*> by A6,FUNCT_1:8;
then xy in rng <*xy, yz, zx*> by RELAT_1:def 5;
then A7: the_rank_of xy in the_rank_of xyz by CIRCCOMB:50;
     rng <*y,z*> = {y,z} by FINSEQ_2:147;
then A8: z in rng <*y,z*> by TARSKI:def 2;
A9: 2 in dom <*xy, yz, zx*> by A2,FINSEQ_1:3;
     <*xy, yz, zx*>.2 = yz by FINSEQ_1:62;
then [2,yz] in <*xy, yz, zx*> by A9,FUNCT_1:8;
then yz in rng <*xy, yz, zx*> by RELAT_1:def 5;
then A10: the_rank_of yz in the_rank_of xyz by CIRCCOMB:50;
     thus {x,y,z} \ {xyz} c= {x,y,z};
     let a be set; assume
A11: a in {x,y,z};
     then a = x or a = y or a = z by ENUMSET1:def 1;
     then a <> xyz by A1,A4,A5,A7,A8,A10,CIRCCOMB:50;
     then not a in {xyz} by TARSKI:def 1;
     hence thesis by A11,XBOOLE_0:def 4;
  end;

Lm3:
 for f being Function of 2-tuples_on BOOLEAN, BOOLEAN
  for x,y,c being set st c <> [<*x,y*>,f]
   for s being State of 2GatesCircuit(x,y,c,f) holds
      (Following s).2GatesCircOutput(x,y,c,f) = f.<*s.[<*x,y*>,f],s.c*> &
      (Following s).[<*x,y*>,f] = f.<*s.x, s.y*> &
      (Following s).x = s.x & (Following s).y = s.y & (Following s).c = s.c
   proof
     let f be Function of 2-tuples_on BOOLEAN, BOOLEAN;
     let x,y,c be set such that
A1:  c <> [<*x,y*>, f];
     set A = 2GatesCircuit(x,y,c,f);
     let s be State of A;
     set xyf = [<*x,y*>,f];
     set p = <*xyf, c*>;
     set S1 = 1GateCircStr(<*x,y*>,f), A1 = 1GateCircuit(x,y,f);
     set S2 = 1GateCircStr(p,f), A2 = 1GateCircuit(xyf,c,f);
     set S = 2GatesCircStr(x,y,c,f);
A2:  InputVertices S = {x,y,c} by A1,FACIRC_1:57;
A3:  InnerVertices S = {xyf, 2GatesCircOutput(x,y,c,f)} by FACIRC_1:56;
A4:  x in InputVertices S & y in InputVertices S & c in InputVertices S
       by A2,ENUMSET1:def 1;
     reconsider xyf as Element of InnerVertices S by A3,TARSKI:def 2;
     rng p = {xyf, c} by FINSEQ_2:147;
then xyf in rng p & c in rng p by TARSKI:def 2;
then A5: xyf in InputVertices S2 & c in InputVertices S2 by CIRCCOMB:49;
     reconsider s1 = s|the carrier of S1 as State of A1 by FACIRC_1:26;
     reconsider s2 = s|the carrier of S2 as State of A2 by FACIRC_1:26;
A6:  dom s2 = the carrier of S2 by CIRCUIT1:4;
A7:  dom s1 = the carrier of S1 by CIRCUIT1:4;
     reconsider vx = x, vy = y as Vertex of S1 by FACIRC_1:43;
     reconsider xyf1 = xyf as Element of InnerVertices S1 by FACIRC_1:47;
     reconsider xyf' = xyf, c' = c as Vertex of S2 by A5;
     reconsider v2 = [p,f] as Element of InnerVertices S2 by FACIRC_1:47;
     thus (Following s).2GatesCircOutput(x,y,c,f)
        = (Following s2).v2 by CIRCCOMB:72
       .= f.<*s2.xyf', s2.c'*> by FACIRC_1:50
       .= f.<*s.[<*x,y*>,f], s2.c'*> by A6,FUNCT_1:70
       .= f.<*s.[<*x,y*>,f], s.c*> by A6,FUNCT_1:70;
     thus (Following s).[<*x,y*>,f]
        = (Following s1).xyf1 by CIRCCOMB:72
       .= f.<*s1.vx, s1.vy*> by FACIRC_1:50
       .= f.<*s.x, s1.vy*> by A7,FUNCT_1:70
       .= f.<*s.x, s.y*> by A7,FUNCT_1:70;
     thus thesis by A4,CIRCUIT2:def 5;
  end;

::========================================================================

begin :: Generalized Full Adder (GFA) Circuit (TYPE-0)

::========================================================================
:: << GFA TYPE-0 >>
::------------------------------------------------------------------------
::   Name     : Generalized Full Adder Type-0 (GFA0)
::   Function : x + y + z = 2 * c + s
::
::   Logic Symbol :      x      y      Combined : GFA0CarryIStr(x,y,z)
::                       |     /                  GFA0CarryStr(x,y,z)
::                       |    /                   GFA0AdderStr(x,y,z)
::                   +---*---*                  --->
::                   |  GFA  *-----z              BitGFA0Str(x,y,z)
::                   | TYPE0 |
::                   *---*---+          Outputs : BitGFA0CarryOutput(x,y,z)
::                  /    |                        BitGFA0AdderOutput(x,y,z)
::                 /     |
::                c      s          Calculation : Following(s,2) is stable.
::=========================================================================

::-------------------------------------------------
:: GFA0 Carry : Circuit Definition of Carry Output
::-------------------------------------------------

definition
 let x,y,z be set;
 func GFA0CarryIStr(x,y,z) ->
    unsplit gate`1=arity gate`2isBoolean
    non void strict non empty ManySortedSign equals
    1GateCircStr(<*x,y*>,and2) +* 1GateCircStr(<*y,z*>,and2) +*
    1GateCircStr(<*z,x*>,and2);
  coherence;
end;

definition
 let x,y,z be set;
 func GFA0CarryICirc(x,y,z) ->
      strict Boolean gate`2=den Circuit of GFA0CarryIStr(x,y,z) equals
    1GateCircuit(x,y,and2) +* 1GateCircuit(y,z,and2) +*
    1GateCircuit(z,x,and2);
  coherence;
end;

definition
 let x,y,z be set;
 func GFA0CarryStr(x,y,z) ->
    unsplit gate`1=arity gate`2isBoolean
    non void strict non empty ManySortedSign equals
    GFA0CarryIStr(x,y,z) +*
    1GateCircStr(<*[<*x,y*>,and2], [<*y,z*>,and2], [<*z,x*>,and2]*>,or3);
  coherence;
end;

definition
 let x,y,z be set;
 func GFA0CarryCirc(x,y,z) ->
      strict Boolean gate`2=den Circuit of GFA0CarryStr(x,y,z) equals
    GFA0CarryICirc(x,y,z) +*
    1GateCircuit([<*x,y*>,and2],[<*y,z*>,and2],[<*z,x*>,and2],or3);
  coherence;
end;

definition
 let x,y,z be set;
 func GFA0CarryOutput(x,y,z) -> Element of InnerVertices GFA0CarryStr(x,y,z)
  equals
   [<*[<*x,y*>,and2],[<*y,z*>,and2],[<*z,x*>,and2]*>,or3];
  coherence
   proof
     [<*[<*x,y*>,and2],[<*y,z*>,and2],[<*z,x*>,and2]*>,or3] in
      InnerVertices
       1GateCircStr(<*[<*x,y*>,and2],[<*y,z*>,and2], [<*z,x*>,and2]*>,or3)
       by FACIRC_1:47;
    hence thesis by FACIRC_1:21;
   end;
end;

::-------------------------------------------------------
:: GFA0 Carry : Carrier, InnerVertices and InputVertices
::-------------------------------------------------------

::-------------------------------------------------------
:: InnerVertices

theorem Th13:
  for x,y,z being set holds
  InnerVertices GFA0CarryIStr(x,y,z) =
   {[<*x,y*>,and2], [<*y,z*>,and2], [<*z,x*>,and2]}
   proof
     set f1 = and2, f2 = and2, f3 = and2;
     let x,y,z be set;
     set xy = [<*x,y*>,f1], yz = [<*y,z*>,f2], zx = [<*z,x*>,f3];
     set Cxy = 1GateCircStr(<*x,y*>,f1);
     set Cyz = 1GateCircStr(<*y,z*>,f2);
     set Czx = 1GateCircStr(<*z,x*>,f3);
A1:  Cxy +* Cyz tolerates Czx by CIRCCOMB:55;
A2:  Cxy tolerates Cyz by CIRCCOMB:55;
     InnerVertices GFA0CarryIStr(x,y,z)
       = InnerVertices(Cxy +* Cyz) \/ InnerVertices(Czx) by A1,CIRCCOMB:15
      .= InnerVertices(Cxy) \/ InnerVertices(Cyz) \/
         InnerVertices(Czx) by A2,CIRCCOMB:15
      .= {xy} \/ InnerVertices(Cyz) \/ InnerVertices(Czx) by CIRCCOMB:49
      .= {xy} \/ {yz} \/ InnerVertices(Czx) by CIRCCOMB:49
      .= {xy} \/ {yz} \/ {zx} by CIRCCOMB:49
      .= {xy, yz} \/ {zx} by ENUMSET1:41
      .= {xy, yz, zx} by ENUMSET1:43;
    hence thesis;
   end;

theorem Th14:
 for x,y,z being set holds
  InnerVertices GFA0CarryStr(x,y,z) =
   {[<*x,y*>,and2], [<*y,z*>,and2], [<*z,x*>,and2]} \/ {GFA0CarryOutput(x,y,z)}
   proof
     set f1 = and2, f2 = and2, f3 = and2, f4 = or3;
     let x,y,z be set;
     set xy = [<*x,y*>,f1], yz = [<*y,z*>,f2], zx = [<*z,x*>,f3];
     set xyz = [<*xy, yz, zx*>,f4];
     set Cxy = 1GateCircStr(<*x,y*>,f1);
     set Cyz = 1GateCircStr(<*y,z*>,f2);
     set Czx = 1GateCircStr(<*z,x*>,f3);
     set Cxyz = 1GateCircStr(<*xy, yz, zx*>,f4);
A1:  Cxy tolerates (Cyz +* Czx +* Cxyz) by CIRCCOMB:55;
A2:  Cyz tolerates (Czx +* Cxyz) by CIRCCOMB:55;
A3:  Czx tolerates Cxyz by CIRCCOMB:55;
A4:  InnerVertices (Cyz +* (Czx +* Cxyz))
      = InnerVertices Cyz \/ InnerVertices (Czx +* Cxyz) by A2,CIRCCOMB:15;
A5:  InnerVertices (Czx +* Cxyz)
      = InnerVertices Czx \/ InnerVertices Cxyz by A3,CIRCCOMB:15;
thus InnerVertices GFA0CarryStr(x,y,z)
      = InnerVertices (Cxy +* (Cyz +* Czx) +* Cxyz) by CIRCCOMB:10
     .= InnerVertices (Cxy +* (Cyz +* Czx +* Cxyz)) by CIRCCOMB:10
     .= InnerVertices Cxy \/ InnerVertices (Cyz +* Czx +* Cxyz)
          by A1,CIRCCOMB:15
     .= InnerVertices Cxy \/ InnerVertices (Cyz +* (Czx +* Cxyz))
          by CIRCCOMB:10
     .= InnerVertices Cxy \/ InnerVertices Cyz \/
          (InnerVertices Czx \/ InnerVertices Cxyz) by A4,A5,XBOOLE_1:4
     .= InnerVertices Cxy \/ InnerVertices Cyz \/
           InnerVertices Czx \/ InnerVertices Cxyz by XBOOLE_1:4
     .= {xy} \/ InnerVertices Cyz \/
           InnerVertices Czx \/ InnerVertices Cxyz by CIRCCOMB:49
     .= {xy} \/ {yz} \/ InnerVertices Czx \/ InnerVertices Cxyz by CIRCCOMB:49
     .= {xy} \/ {yz} \/ {zx} \/ InnerVertices Cxyz by CIRCCOMB:49
     .= {xy, yz} \/ {zx} \/ InnerVertices Cxyz by ENUMSET1:41
     .= {xy, yz, zx} \/ InnerVertices Cxyz by ENUMSET1:43
     .= {xy, yz, zx} \/ {GFA0CarryOutput(x,y,z)} by CIRCCOMB:49;
  end;

theorem Th15:
  for x,y,z being set holds
  InnerVertices GFA0CarryStr(x,y,z) is Relation
   proof
     set f1 = and2, f2 = and2, f3 = and2, f4 = or3;
     let x,y,z be set;
     set xy = [<*x,y*>,f1], yz = [<*y,z*>,f2], zx = [<*z,x*>,f3];
     set Cxy = 1GateCircStr(<*x,y*>,f1);
     set Cyz = 1GateCircStr(<*y,z*>,f2);
     set Czx = 1GateCircStr(<*z,x*>,f3);
     set Cxyz = 1GateCircStr(<*xy, yz, zx*>,f4);
A1:  InnerVertices Cxy is Relation & InnerVertices Cyz is Relation &
     InnerVertices Czx is Relation by FACIRC_1:38;
then InnerVertices (Cxy +* Cyz) is Relation by FACIRC_1:3;
then InnerVertices Cxyz is Relation &
     InnerVertices GFA0CarryIStr(x,y,z) is Relation by A1,FACIRC_1:3,38;
    hence thesis by FACIRC_1:3;
   end;

::-------------------------------------------------------
:: InputVertices

theorem Th16:
 for x,y,z being set st
   x <> [<*y,z*>,and2] & y <> [<*z,x*>,and2] & z <> [<*x,y*>,and2]
  holds InputVertices GFA0CarryIStr(x,y,z) = {x,y,z}
   proof
     set f1 = and2, f2 = and2, f3 = and2;
     let x,y,z be set;
     set xy = [<*x,y*>,f1], yz = [<*y,z*>,f2], zx = [<*z,x*>,f3];
     set Cxy = 1GateCircStr(<*x,y*>,f1);
     set Cyz = 1GateCircStr(<*y,z*>,f2);
     set Czx = 1GateCircStr(<*z,x*>,f3);
     assume
A1:  x <> yz & y <> zx & z <> xy;
A2:  Cxy +* Cyz tolerates Czx by CIRCCOMB:55;
A3:  Cxy tolerates Cyz by CIRCCOMB:55;
A4:  y <> [<*y,z*>,f2] by FACIRC_2:3;
A5:  not xy in {y,z} by A1,Lm1;
A6:  not z in {xy, yz} & not x in {xy, yz} by A1,Lm1;
A7:  not zx in {x,y,z} by A1,Lm1;
     InputVertices GFA0CarryIStr(x,y,z)
      = (InputVertices(Cxy +* Cyz) \ InnerVertices(Czx)) \/
        (InputVertices(Czx) \ InnerVertices(Cxy +* Cyz)) by A2,CIRCCMB2:6
     .= ((InputVertices(Cxy) \ InnerVertices(Cyz)) \/
         (InputVertices(Cyz) \ InnerVertices(Cxy))) \ InnerVertices(Czx) \/
         (InputVertices(Czx) \ InnerVertices(Cxy +* Cyz)) by A3,CIRCCMB2:6
     .= ((InputVertices(Cxy) \ InnerVertices(Cyz)) \/
         (InputVertices(Cyz) \ InnerVertices(Cxy))) \ InnerVertices(Czx) \/
         (InputVertices(Czx) \ (InnerVertices(Cxy) \/ InnerVertices(Cyz)))
          by A3,CIRCCOMB:15
     .= ((InputVertices(Cxy) \ {yz}) \/
         (InputVertices(Cyz) \ InnerVertices(Cxy))) \ InnerVertices(Czx) \/
         (InputVertices(Czx) \ (InnerVertices(Cxy) \/ InnerVertices(Cyz)))
          by CIRCCOMB:49
     .= ((InputVertices(Cxy) \ {yz}) \/
         (InputVertices(Cyz) \ {xy})) \ InnerVertices(Czx) \/
         (InputVertices(Czx) \ (InnerVertices(Cxy) \/ InnerVertices(Cyz)))
          by CIRCCOMB:49
     .= ((InputVertices(Cxy) \ {yz}) \/
         (InputVertices(Cyz) \ {xy})) \ {zx} \/
         (InputVertices(Czx) \ (InnerVertices(Cxy) \/ InnerVertices(Cyz)))
          by CIRCCOMB:49
     .= ((InputVertices(Cxy) \ {yz}) \/
         (InputVertices(Cyz) \ {xy})) \ {zx} \/
         (InputVertices(Czx) \ ({xy} \/ InnerVertices(Cyz))) by CIRCCOMB:49
     .= ((InputVertices(Cxy) \ {yz}) \/
         (InputVertices(Cyz) \ {xy})) \ {zx} \/
         (InputVertices(Czx) \ ({xy} \/ {yz})) by CIRCCOMB:49
     .= (({x,y} \ {yz}) \/ (InputVertices(Cyz) \ {xy})) \ {zx} \/
         (InputVertices(Czx) \ ({xy} \/ {yz})) by FACIRC_1:40
     .= (({x,y} \ {yz}) \/ ({y,z} \ {xy})) \ {zx} \/
         (InputVertices(Czx) \ ({xy} \/ {yz})) by FACIRC_1:40
     .= (({x,y} \ {yz}) \/ ({y,z} \ {xy})) \ {zx} \/
         ({z,x} \ ({xy} \/ {yz})) by FACIRC_1:40
     .= (({x,y} \ {yz}) \/ ({y,z} \ {xy})) \ {zx} \/
         ({z,x} \ {xy,yz}) by ENUMSET1:41
     .= (({x,y} \/ ({y,z} \ {xy})) \ {zx}) \/ ({z,x} \ {xy,yz})
          by A1,A4,FACIRC_2:1
     .= ({x,y} \/ {y,z}) \ {zx} \/ ({z,x} \ {xy,yz}) by A5,ZFMISC_1:65
     .= ({x,y} \/ {y,z}) \ {zx} \/ {z,x} by A6,ZFMISC_1:72
     .= {x,y,y,z} \ {zx} \/ {z,x} by ENUMSET1:45
     .= {y,y,x,z} \ {zx} \/ {z,x} by ENUMSET1:110
     .= {y,x,z} \ {zx} \/ {z,x} by ENUMSET1:71
     .= {x,y,z} \ {zx} \/ {z,x} by ENUMSET1:99
     .= {x,y,z} \/ {z,x} by A7,ZFMISC_1:65
     .= {x,y,z,z,x} by ENUMSET1:49
     .= {x,y,z,z} \/ {x} by ENUMSET1:50
     .= {z,z,x,y} \/ {x} by ENUMSET1:118
     .= {z,x,y} \/ {x} by ENUMSET1:71
     .= {z,x,y,x} by ENUMSET1:46
     .= {x,x,y,z} by ENUMSET1:113
     .= {x,y,z} by ENUMSET1:71;
    hence thesis;
   end;

theorem Th17:
 for x,y,z being set st
   x <> [<*y,z*>,and2] & y <> [<*z,x*>,and2] & z <> [<*x,y*>,and2]
  holds InputVertices GFA0CarryStr(x,y,z) = {x,y,z}
   proof
     set f1 = and2, f2 = and2, f3 = and2, f4 = or3;
     let x,y,z be set;
     set xy = [<*x,y*>,f1], yz = [<*y,z*>,f2], zx = [<*z,x*>,f3];
     set xyz = [<*xy, yz, zx*>,f4];
     set S = 1GateCircStr(<*xy, yz, zx*>,f4);
     set MI = GFA0CarryIStr(x,y,z);
     assume
A1:  x <> yz & y <> zx & z <> xy;
A2:  InnerVertices S = {xyz} by CIRCCOMB:49;
A3:  InputVertices S = rng <*xy, yz, zx*> by CIRCCOMB:49
                    .= {xy, yz, zx} by FINSEQ_2:148;
A4:  {x, y, z} \ {xyz} = {x, y, z} by Lm2;
A5:  {xy, yz, zx} \ {xy, yz, zx} = {} by XBOOLE_1:37;
     GFA0CarryStr(x,y,z) = MI +* S & MI tolerates S by CIRCCOMB:55;
    hence InputVertices GFA0CarryStr(x,y,z)
      = ((InputVertices MI) \ InnerVertices S) \/
         ((InputVertices S) \ InnerVertices MI) by CIRCCMB2:6
     .= {x,y,z} \/ ({xy, yz, zx} \ InnerVertices MI) by A1,A2,A3,A4,Th16
     .= {x,y,z} \/ {} by A5,Th13
     .= {x,y,z};
  end;

theorem Th18:
 for x,y,z being non pair set holds
  InputVertices GFA0CarryStr(x,y,z) is without_pairs
   proof
     set f1 = and2, f2 = and2, f3 = and2, f4 = or3;
     let x,y,z be non pair set;
     set xy = [<*x,y*>,f1], yz = [<*y,z*>,f2], zx = [<*z,x*>,f3];
     set Cxy = 1GateCircStr(<*x,y*>,f1);
     set Cyz = 1GateCircStr(<*y,z*>,f2);
     set Czx = 1GateCircStr(<*z,x*>,f3);
     set S = 1GateCircStr(<*xy, yz, zx*>,f4);
     set M = GFA0CarryStr(x,y,z);
     set MI = GFA0CarryIStr(x,y,z);
A1:  InputVertices Cxy is without_pairs & InputVertices Cyz is without_pairs &
     InputVertices Czx is without_pairs by FACIRC_1:41;
then InputVertices (Cxy+*Cyz) is without_pairs by FACIRC_1:9;
then A2: InputVertices MI is without_pairs by A1,FACIRC_1:9;
     InnerVertices S is Relation by FACIRC_1:38;
then A3: InputVertices M = (InputVertices MI) \/
          (InputVertices S \ InnerVertices MI) by A2,FACIRC_1:6;
     given xx being pair set such that
A4:  xx in InputVertices M;
A5:  InputVertices S = {xy, yz, zx} by FACIRC_1:42;
A6:  InnerVertices Cxy = {xy} & InnerVertices Cyz = {yz} &
     InnerVertices Czx = {zx} by CIRCCOMB:49;
     Cxy tolerates Cyz & Cxy tolerates Czx & Cyz tolerates Czx by CIRCCOMB:55;
then A7: InnerVertices (Cxy +* Cyz) = {xy} \/ {yz} by A6,CIRCCOMB:15;
     Cxy +* Cyz tolerates Czx by CIRCCOMB:55;
then InnerVertices MI = {xy} \/ {yz} \/ {zx} by A6,A7,CIRCCOMB:15
     .= {xy, yz} \/ {zx} by ENUMSET1:41
     .= {xy, yz, zx} by ENUMSET1:43;
then InputVertices S \ InnerVertices MI = {} by A5,XBOOLE_1:37;
    hence thesis by A2,A3,A4,FACIRC_1:def 2;
  end;

::-------------------------------------------------------
:: Carrier and misc.

theorem Th19:
  for x,y,z being set holds
    x in the carrier of GFA0CarryStr(x,y,z) &
    y in the carrier of GFA0CarryStr(x,y,z) &
    z in the carrier of GFA0CarryStr(x,y,z) &
    [<*x,y*>,and2] in the carrier of GFA0CarryStr(x,y,z) &
    [<*y,z*>,and2] in the carrier of GFA0CarryStr(x,y,z) &
    [<*z,x*>,and2] in the carrier of GFA0CarryStr(x,y,z) &
    [<*[<*x,y*>,and2],[<*y,z*>,and2],[<*z,x*>,and2]*>,or3]
                   in the carrier of GFA0CarryStr(x,y,z)
   proof
     set f1 = and2, f2 = and2, f3 = and2, f4 = or3;
     let x,y,z be set;
     set xy = [<*x,y*>,f1], yz = [<*y,z*>,f2], zx = [<*z,x*>,f3];
     set xyz = [<*xy, yz, zx*>,f4];
     set Cxy = 1GateCircStr(<*x,y*>,f1);
     set Cyz = 1GateCircStr(<*y,z*>,f2);
     set Czx = 1GateCircStr(<*z,x*>,f3);
     set Cxyz = 1GateCircStr(<*xy, yz, zx*>,f4);
     y in the carrier of Cxy by FACIRC_1:43;
then A1: y in the carrier of Cxy +* Cyz by FACIRC_1:20;
     x in the carrier of Czx & z in the carrier of Czx by FACIRC_1:43;
then A2: x in the carrier of GFA0CarryIStr(x,y,z) &
         y in the carrier of GFA0CarryIStr(x,y,z) &
         z in the carrier of GFA0CarryIStr(x,y,z) by A1,FACIRC_1:20;
     xy in the carrier of Cxy & yz in the carrier of Cyz by FACIRC_1:43;
then A3: xy in the carrier of Cxy +* Cyz & yz in the carrier of Cxy +* Cyz
       by FACIRC_1:20;
     zx in the carrier of Czx by FACIRC_1:43;
then A4: xy in the carrier of GFA0CarryIStr(x,y,z) &
         yz in the carrier of GFA0CarryIStr(x,y,z) &
         zx in the carrier of GFA0CarryIStr(x,y,z) by A3,FACIRC_1:20;
     set p = <*xy,yz,zx*>;
     the carrier of Cxyz = rng p \/ {xyz} & [p,f4] in {[p,f4]}
       by CIRCCOMB:def 6,TARSKI:def 1;
then xyz in the carrier of Cxyz by XBOOLE_0:def 2;
    hence thesis by A2,A4,FACIRC_1:20;
  end;

theorem Th20:
 for x,y,z being set holds
   [<*x,y*>,and2] in InnerVertices GFA0CarryStr(x,y,z) &
   [<*y,z*>,and2] in InnerVertices GFA0CarryStr(x,y,z) &
   [<*z,x*>,and2] in InnerVertices GFA0CarryStr(x,y,z) &
   GFA0CarryOutput(x,y,z) in InnerVertices GFA0CarryStr(x,y,z)
   proof
     set f1 = and2, f2 = and2, f3 = and2;
     let x,y,z be set;
     set xy = [<*x,y*>,f1], yz = [<*y,z*>,f2], zx = [<*z,x*>,f3];
     InnerVertices GFA0CarryStr(x,y,z)
       = {xy,yz,zx} \/ {GFA0CarryOutput(x,y,z)} by Th14
      .= {xy,yz,zx,GFA0CarryOutput(x,y,z)} by ENUMSET1:46;
    hence thesis by ENUMSET1:def 2;
  end;

theorem Th21:
  for x,y,z being set st
     x <> [<*y,z*>,and2] & y <> [<*z,x*>,and2] & z <> [<*x,y*>,and2]
   holds
    x in InputVertices GFA0CarryStr(x,y,z) &
    y in InputVertices GFA0CarryStr(x,y,z) &
    z in InputVertices GFA0CarryStr(x,y,z)
   proof
     set f1 = and2, f2 = and2, f3 = and2;
     let x,y,z be set such that
A1:  x <> [<*y,z*>,f2] & y <> [<*z,x*>,f3] & z <> [<*x,y*>,f1];
     InputVertices GFA0CarryStr(x,y,z) = {x,y,z} by A1,Th17;
    hence thesis by ENUMSET1:def 1;
  end;

theorem Th22:
 for x,y,z being non pair set holds
  InputVertices GFA0CarryStr(x,y,z) = {x,y,z}
   proof
     set f1 = and2, f2 = and2, f3 = and2, f4 = or3;
     let x,y,z be non pair set;
     set xy = [<*x,y*>,f1], yz = [<*y,z*>,f2], zx = [<*z,x*>,f3];
     set Cxy = 1GateCircStr(<*x,y*>,f1);
     set Cyz = 1GateCircStr(<*y,z*>,f2);
     set Czx = 1GateCircStr(<*z,x*>,f3);
     set M = GFA0CarryStr(x,y,z);
     set MI = GFA0CarryIStr(x,y,z);
     set S = 1GateCircStr(<*xy,yz,zx*>,f4);
A1:  InputVertices Cxy is without_pairs &
     InputVertices Cyz is without_pairs &
     InputVertices Czx is without_pairs by FACIRC_1:41;
then A2: InputVertices (Cxy+*Cyz) is without_pairs by FACIRC_1:9;
then A3: InputVertices MI is without_pairs by A1,FACIRC_1:9;
A4:  InputVertices Cxy = {x,y} & InputVertices Cyz = {y,z} &
     InputVertices Czx = {z,x} by FACIRC_1:40;
     InnerVertices S is Relation by FACIRC_1:38;
then A5: InputVertices M =
      (InputVertices MI) \/ (InputVertices S \ InnerVertices MI)
       by A3,FACIRC_1:6;
A6:  InputVertices S = {xy, yz, zx} by FACIRC_1:42;
A7:  InnerVertices Cxy = {xy} & InnerVertices Cyz = {yz} &
     InnerVertices Czx = {zx} by CIRCCOMB:49;
     Cxy tolerates Cyz & Cxy tolerates Czx & Cyz tolerates Czx by CIRCCOMB:55;
then A8: InnerVertices (Cxy +* Cyz) = {xy} \/ {yz} by A7,CIRCCOMB:15;
     Cxy +* Cyz tolerates Czx by CIRCCOMB:55;
then InnerVertices MI = {xy} \/ {yz} \/ {zx} by A7,A8,CIRCCOMB:15
      .= {xy, yz} \/ {zx} by ENUMSET1:41
      .= {xy, yz, zx} by ENUMSET1:43;
then InputVertices S \ InnerVertices MI = {} by A6,XBOOLE_1:37;
    hence InputVertices M
       = (InputVertices(Cxy+*Cyz)) \/ InputVertices Czx
          by A1,A2,A7,A8,A5,FACIRC_1:7
      .= (InputVertices Cxy) \/ (InputVertices Cyz) \/ (InputVertices Czx)
          by A1,A7,FACIRC_1:7
      .= {x,y,y,z} \/ {z,x} by A4,ENUMSET1:45
      .= {y,y,x,z} \/ {z,x} by ENUMSET1:110
      .= {y,x,z} \/ {z,x} by ENUMSET1:71
      .= {x,y,z} \/ {z,x} by ENUMSET1:99
      .= {x,y,z} \/ ({z}\/{x}) by ENUMSET1:41
      .= {x,y,z} \/ {z} \/ {x} by XBOOLE_1:4
      .= {z,x,y} \/ {z} \/ {x} by ENUMSET1:100
      .= {z,z,x,y} \/ {x} by ENUMSET1:44
      .= {z,x,y} \/ {x} by ENUMSET1:71
      .= {x,y,z} \/ {x} by ENUMSET1:100
      .= {x,x,y,z} by ENUMSET1:44
      .= {x,y,z} by ENUMSET1:71;
  end;

::----------------------------------------------------
:: GFA0 Carry : Stability of the Carry Output Circuit
::----------------------------------------------------

theorem Th23:
 for x,y,z being set for s being State of GFA0CarryCirc(x,y,z)
  for a1,a2,a3 being Element of BOOLEAN st a1 = s.x & a2 = s.y & a3 = s.z
   holds
    (Following s).[<*x,y*>,and2] = a1 '&' a2 &
    (Following s).[<*y,z*>,and2] = a2 '&' a3 &
    (Following s).[<*z,x*>,and2] = a3 '&' a1
   proof
     set f1 = and2, f2 = and2, f3 = and2;
     let x,y,z be set;
     let s be State of GFA0CarryCirc(x,y,z);
     set xy = [<*x,y*>,f1], yz = [<*y,z*>,f2], zx = [<*z,x*>,f3];
     let a1,a2,a3 be Element of BOOLEAN such that
A1:  a1 = s.x & a2 = s.y & a3 = s.z;
     set S = GFA0CarryStr(x,y,z);
A2:  InnerVertices S = the OperSymbols of S by FACIRC_1:37;
A3:  dom s = the carrier of S by CIRCUIT1:4;
A4:  x in the carrier of S & y in the carrier of S & z in the carrier of S
      by Th19;
     xy in InnerVertices GFA0CarryStr(x,y,z) by Th20;
     hence (Following s).[<*x,y*>,f1] = f1.(s*<*x,y*>) by A2,FACIRC_1:35
         .= f1.<*a1,a2*> by A1,A3,A4,FINSEQ_2:145
         .= a1 '&' a2 by TWOSCOMP:def 1;
     yz in InnerVertices GFA0CarryStr(x,y,z) by Th20;
     hence (Following s).[<*y,z*>,f2] = f2.(s*<*y,z*>) by A2,FACIRC_1:35
         .= f2.<*a2,a3*> by A1,A3,A4,FINSEQ_2:145
         .= a2 '&' a3 by TWOSCOMP:def 1;
     zx in InnerVertices GFA0CarryStr(x,y,z) by Th20;
     hence (Following s).[<*z,x*>,f3] = f3.(s*<*z,x*>) by A2,FACIRC_1:35
         .= f3.<*a3,a1*> by A1,A3,A4,FINSEQ_2:145
         .= a3 '&' a1 by TWOSCOMP:def 1;
  end;

theorem Th24:
 for x,y,z being set for s being State of GFA0CarryCirc(x,y,z)
  for a1,a2,a3 being Element of BOOLEAN st
    a1 = s.[<*x,y*>,and2] & a2 = s.[<*y,z*>,and2] & a3 = s.[<*z,x*>,and2]
   holds
    (Following s).GFA0CarryOutput(x,y,z) = a1 'or' a2 'or' a3
   proof
     set f1 = and2, f2 = and2, f3 = and2, f4 = or3;
     let x,y,z be set;
     let s be State of GFA0CarryCirc(x,y,z);
     set xy =[<*x,y*>,f1], yz = [<*y,z*>,f2], zx = [<*z,x*>,f3];
     let a1,a2,a3 be Element of BOOLEAN such that
A1:  a1 = s.xy & a2 = s.yz & a3 = s.zx;
     set S = GFA0CarryStr(x,y,z);
A2:  InnerVertices S = the OperSymbols of S by FACIRC_1:37;
A3:  dom s = the carrier of S by CIRCUIT1:4;
     reconsider xy, yz, zx as Element of InnerVertices S by Th20;
thus (Following s).GFA0CarryOutput(x,y,z)
          = f4.(s*<*xy, yz, zx*>) by A2,FACIRC_1:35
         .= f4.<*a1,a2,a3*> by A1,A3,FINSEQ_2:146
         .= a1 'or' a2 'or' a3 by TWOSCOMP:16;
  end;

theorem Th25:
  for x,y,z being set st
    x <> [<*y,z*>,and2] & y <> [<*z,x*>,and2] & z <> [<*x,y*>,and2]
   for s being State of GFA0CarryCirc(x,y,z)
    for a1,a2,a3 being Element of BOOLEAN st a1 = s.x & a2 = s.y & a3 = s.z
     holds
      Following(s,2).GFA0CarryOutput(x,y,z) =
         (a1 '&' a2) 'or' (a2 '&' a3) 'or' (a3 '&' a1) &
      Following(s,2).[<*x,y*>,and2] = a1 '&' a2 &
      Following(s,2).[<*y,z*>,and2] = a2 '&' a3 &
      Following(s,2).[<*z,x*>,and2] = a3 '&' a1
   proof
     set f1 = and2, f2 = and2, f3 = and2;
     let x,y,z be set such that
A1:  x <> [<*y,z*>,f2] & y <> [<*z,x*>,f3] & z <> [<*x,y*>,f1];
     set xy = [<*x,y*>,f1], yz = [<*y,z*>,f2], zx = [<*z,x*>,f3];
     let s be State of GFA0CarryCirc(x,y,z);
     let a1,a2,a3 be Element of BOOLEAN such that
A2:  a1 = s.x & a2 = s.y & a3 = s.z;
     set S = GFA0CarryStr(x,y,z);
     reconsider x' = x, y' = y, z' = z as Vertex of S by Th19;
     x in InputVertices S & y in InputVertices S & z in InputVertices S
     by A1,Th21;
then A3: (Following s).x' = s.x & (Following s).y' = s.y &
         (Following s).z' = s.z by CIRCUIT2:def 5;
A4:  Following(s,2) = Following Following s by FACIRC_1:15;
     (Following s).xy = a1 '&' a2 &
     (Following s).yz = a2 '&' a3 &
     (Following s).zx = a3 '&' a1 by A2,Th23;
    hence Following(s,2).GFA0CarryOutput(x,y,z) =
        (a1 '&' a2) 'or' (a2 '&' a3) 'or' (a3 '&' a1) by A4,Th24;
   thus thesis by A2,A3,A4,Th23;
  end;

theorem Th26:
  for x,y,z being set st
     x <> [<*y,z*>,and2] & y <> [<*z,x*>,and2] & z <> [<*x,y*>,and2]
   for s being State of GFA0CarryCirc(x,y,z)
    holds Following(s,2) is stable
   proof
     set f1 = and2, f2 = and2, f3 = and2;
     let x,y,z be set such that
A1:  x <> [<*y,z*>,f2] & y <> [<*z,x*>,f3] & z <> [<*x,y*>,f1];
     set xy = [<*x,y*>,f1], yz = [<*y,z*>,f2], zx = [<*z,x*>,f3];
     let s be State of GFA0CarryCirc(x,y,z);
     set S = GFA0CarryStr(x,y,z);
A2:  dom Following Following(s,2) = the carrier of S &
     dom Following(s,2) = the carrier of S by CIRCUIT1:4;
     reconsider xx = x, yy = y, zz = z as Vertex of S by Th19;
     set a1 = s.xx, a2 = s.yy, a3 = s.zz;
     set ffs = Following(s,2), fffs = Following ffs;
     a1 = s.x & a2 = s.y & a3 = s.z;
then A3: ffs.GFA0CarryOutput(x,y,z) =
     a1 '&' a2 'or' a2 '&' a3 'or' a3 '&' a1 &
     ffs.xy = a1 '&' a2 &
     ffs.yz = a2 '&' a3 &
     ffs.zx = a1 '&' a3 by A1,Th25;
A4:  ffs = Following Following s by FACIRC_1:15;
A5:  x in InputVertices S & y in InputVertices S & z in InputVertices S
      by A1,Th21;
then (Following s).x = a1 & (Following s).y = a2 & (Following s).z = a3
      by CIRCUIT2:def 5;
then A6: ffs.x = a1 & ffs.y = a2 & ffs.z = a3 by A4,A5,CIRCUIT2:def 5;
     now let a be set; assume
A7:  a in the carrier of S;
then reconsider v = a as Vertex of S;
A8:  v in InputVertices S \/ InnerVertices S by A7,XBOOLE_1:45;
     thus ffs.a = (fffs).a
      proof per cases by A8,XBOOLE_0:def 2;
        suppose v in InputVertices S;
          hence thesis by CIRCUIT2:def 5;
        end;
        suppose v in InnerVertices S;
           then v in {xy, yz, zx} \/ {GFA0CarryOutput(x,y,z)} by Th14;
           then v in {xy, yz, zx} or
                v in {GFA0CarryOutput(x,y,z)} by XBOOLE_0:def 2;
           then v = xy or v = yz or v = zx or
                v = GFA0CarryOutput(x,y,z) by ENUMSET1:def 1,TARSKI:def 1;
          hence thesis by A3,A6,Th23,Th24;
        end;
      end;
     end;
    hence ffs = fffs by A2,FUNCT_1:9;
  end;

::=========================================================================

::-------------------------------------------------
:: GFA0 Adder : Circuit Definition of Adder Output
::-------------------------------------------------

definition
 let x,y,z be set;
 func GFA0AdderStr(x,y,z) ->
      unsplit gate`1=arity gate`2isBoolean
      non void strict non empty ManySortedSign equals
   2GatesCircStr(x,y,z, xor2);
  coherence;
end;

definition
 let x,y,z be set;
 func GFA0AdderCirc(x,y,z) ->
      strict Boolean gate`2=den Circuit of GFA0AdderStr(x,y,z) equals
   2GatesCircuit(x,y,z, xor2);
  coherence;
end;

definition
 let x,y,z be set;
 func GFA0AdderOutput(x,y,z) ->
      Element of InnerVertices GFA0AdderStr(x,y,z) equals
   2GatesCircOutput(x,y,z, xor2);
  coherence;
end;

::-------------------------------------------------------
:: GFA0 Adder : Carrier, InnerVertices and InputVertices
::-------------------------------------------------------

::-------------------------------------------------------
:: InnerVertices

theorem Th27:
 for x,y,z being set holds
  InnerVertices GFA0AdderStr(x,y,z) =
    {[<*x,y*>,xor2]} \/ {GFA0AdderOutput(x,y,z)}
   proof
     set f = xor2;
     let x,y,z be set;
     set xy = [<*x,y*>,f];
     set S = GFA0AdderStr(x,y,z);
     thus InnerVertices S
       = {xy, GFA0AdderOutput(x,y,z)} by FACIRC_1:56
      .= {xy} \/ {GFA0AdderOutput(x,y,z)} by ENUMSET1:41;
   end;

theorem
 for x,y,z being set holds
  InnerVertices GFA0AdderStr(x,y,z) is Relation by FACIRC_1:58;

::-------------------------------------------------------
:: InputVertices

theorem
 for x,y,z being set st z <> [<*x,y*>,xor2] holds
  InputVertices GFA0AdderStr(x,y,z) = {x,y,z} by FACIRC_1:57;

theorem
 for x,y,z being non pair set holds
  InputVertices GFA0AdderStr(x,y,z) is without_pairs by FACIRC_1:59;

::-------------------------------------------------------
:: Carrier and misc.

theorem
 for x,y,z being set holds
   x in the carrier of GFA0AdderStr(x,y,z) &
   y in the carrier of GFA0AdderStr(x,y,z) &
   z in the carrier of GFA0AdderStr(x,y,z) &
   [<*x,y*>,xor2] in the carrier of GFA0AdderStr(x,y,z) &
   [<*[<*x,y*>,xor2], z*>, xor2] in the carrier of GFA0AdderStr(x,y,z)
   by FACIRC_1:60,61;

theorem Th32:
 for x,y,z being set holds
   [<*x,y*>,xor2] in InnerVertices GFA0AdderStr(x,y,z) &
   GFA0AdderOutput(x,y,z) in InnerVertices GFA0AdderStr(x,y,z)
   proof
     set f = xor2;
     let x,y,z be set;
     set S = GFA0AdderStr(x,y,z);
     InnerVertices S
       = {[<*x,y*>,f]} \/ {GFA0AdderOutput(x,y,z)} by Th27
      .= {[<*x,y*>,f],GFA0AdderOutput(x,y,z)} by ENUMSET1:41;
    hence thesis by TARSKI:def 2;
   end;

theorem Th33:
 for x,y,z being set st z <> [<*x,y*>, xor2] holds
    x in InputVertices GFA0AdderStr(x,y,z) &
    y in InputVertices GFA0AdderStr(x,y,z) &
    z in InputVertices GFA0AdderStr(x,y,z)
   proof
     set f = xor2;
     let x,y,z be set such that
A1:  z <> [<*x,y*>,f];
     set S = GFA0AdderStr(x,y,z);
     InputVertices S = {x,y,z} by A1,FACIRC_1:57;
     hence thesis by ENUMSET1:def 1;
   end;

theorem
 for x,y,z being non pair set holds
   InputVertices GFA0AdderStr(x,y,z) = {x,y,z} by FACIRC_1:57;

::----------------------------------------------------
:: GFA0 Adder : Stability of the Adder Output Circuit
::----------------------------------------------------

theorem Th35:
 for x,y,z being set st z <> [<*x,y*>, xor2]
  for s being State of GFA0AdderCirc(x,y,z)
   for a1,a2,a3 being Element of BOOLEAN st a1 = s.x & a2 = s.y & a3 = s.z
     holds
      (Following s).[<*x,y*>,xor2] = a1 'xor' a2 &
      (Following s).x = a1 & (Following s).y = a2 & (Following s).z = a3
   proof
     set f = xor2;
     let x,y,z be set such that
A1:  z <> [<*x,y*>,f];
     set xy = [<*x,y*>,f];
     set A = GFA0AdderCirc(x,y,z);
     let s be State of A;
     let a1,a2,a3 be Element of BOOLEAN such that
A2:  a1 = s.x & a2 = s.y & a3 = s.z;
     (Following s).xy = f.<*a1, a2*> by A1,A2,Lm3;
     hence (Following s).xy = a1 'xor' a2 by TWOSCOMP:def 13;
     thus (Following s).x = a1 & (Following s).y = a2 & (Following s).z = a3
       by A1,A2,Lm3;
   end;

theorem Th36:
 for x,y,z being set st z <> [<*x,y*>, xor2]
  for s being State of GFA0AdderCirc(x,y,z)
   for a1a2,a1,a2,a3 being Element of BOOLEAN
     st a1a2 = s.[<*x,y*>,xor2] & a1 = s.x & a2 = s.y & a3 = s.z
    holds
     (Following s).GFA0AdderOutput(x,y,z) = a1a2 'xor' a3
   proof
     set f = xor2;
     let x,y,z be set such that
A1:  z <> [<*x,y*>,f];
     set xy = [<*x,y*>,f];
     set A = GFA0AdderCirc(x,y,z);
     let s be State of A;
     let a1a2,a1,a2,a3 be Element of BOOLEAN such that
A2:  a1a2 = s.xy & a1 = s.x & a2 = s.y & a3 = s.z;
     set C = GFA0AdderOutput(x,y,z);
     thus (Following s).GFA0AdderOutput(x,y,z)
         = f.<*s.xy, s.z*> by A1,Lm3
        .= a1a2 'xor' a3 by A2,TWOSCOMP:def 13;
   end;

theorem Th37:
 for x,y,z being set st z <> [<*x,y*>, xor2]
  for s being State of GFA0AdderCirc(x,y,z)
   for a1,a2,a3 being Element of BOOLEAN st a1 = s.x & a2 = s.y & a3 = s.z
    holds
     Following(s,2).GFA0AdderOutput(x,y,z) = a1 'xor' a2 'xor' a3 &
     Following(s,2).[<*x,y*>,xor2] = a1 'xor' a2 &
     Following(s,2).x = a1 & Following(s,2).y = a2 & Following(s,2).z = a3
   proof
     set f = xor2;
     let x,y,z be set such that
A1:  z <> [<*x,y*>,f];
     set xy = [<*x,y*>,f];
     set A = GFA0AdderCirc(x,y,z);
     let s be State of A;
     let a1,a2,a3 be Element of BOOLEAN such that
A2:  a1 = s.x & a2 = s.y & a3 = s.z;
     set C = GFA0AdderOutput(x,y,z);
     thus (Following(s,2)).GFA0AdderOutput(x,y,z)
         = f.<* f.<*a1, a2*>, a3*> by A1,A2,FACIRC_1:62
        .= f.<*a1 'xor' a2, a3*> by TWOSCOMP:def 13
        .= a1 'xor' a2 'xor' a3 by TWOSCOMP:def 13;
     (Following(s,2)).xy = f.<*a1, a2*> by A1,A2,FACIRC_1:62;
     hence (Following(s,2)).xy = a1 'xor' a2 by TWOSCOMP:def 13;
     thus (Following(s,2)).x = a1 & (Following(s,2)).y = a2 &
          (Following(s,2)).z = a3 by A1,A2,FACIRC_1:62;
   end;

theorem
 for x,y,z being set st z <> [<*x,y*>,xor2]
  for s being State of GFA0AdderCirc(x,y,z)
    holds Following(s,2) is stable by FACIRC_1:63;

::=====================================================================

::---------------------------------------------------
:: GFA0 : Circuit Definition of GFA Combined Circuit
::---------------------------------------------------

definition
 let x,y,z be set;
 func BitGFA0Str(x,y,z) ->
      unsplit gate`1=arity gate`2isBoolean
      non void strict non empty ManySortedSign equals
    GFA0AdderStr(x,y,z) +* GFA0CarryStr(x,y,z);
  coherence;
end;

definition
  let x,y,z be set;
 func BitGFA0Circ(x,y,z) ->
   strict Boolean gate`2=den Circuit of BitGFA0Str(x,y,z) equals
   GFA0AdderCirc(x,y,z) +* GFA0CarryCirc(x,y,z);
  coherence;
end;

::----------------------------------------------------------
:: GFA0 Combined : Carrier, InnerVertices and InputVertices
::----------------------------------------------------------

::-------------------------------------------------------
:: InnerVertices

theorem Th39:
  for x,y,z being set holds
   InnerVertices BitGFA0Str(x,y,z) =
     {[<*x,y*>,xor2]} \/ {GFA0AdderOutput(x,y,z)} \/
     {[<*x,y*>,and2], [<*y,z*>,and2], [<*z,x*>,and2]} \/
     {GFA0CarryOutput(x,y,z)}
   proof
     set f0 = xor2;
     set f1 = and2, f2 = and2, f3 = and2;
     let x,y,z be set;
     set xyf0 = [<*x,y*>,f0];
     set xyf1 = [<*x,y*>,f1], yzf2 = [<*y,z*>,f2], zxf3 = [<*z,x*>,f3];
     set S = BitGFA0Str(x,y,z);
     set S1 = GFA0AdderStr(x,y,z);
     set S2 = GFA0CarryStr(x,y,z);
     set A1 = GFA0AdderOutput(x,y,z);
     set A2 = GFA0CarryOutput(x,y,z);
     thus InnerVertices S
       = (InnerVertices S1) \/ InnerVertices S2 by FACIRC_1:27
      .= {xyf0} \/ {A1} \/ InnerVertices S2 by Th27
      .= {xyf0} \/ {A1} \/ ({xyf1, yzf2, zxf3} \/ {A2}) by Th14
      .= {xyf0} \/ {A1} \/ {xyf1, yzf2, zxf3} \/ {A2} by XBOOLE_1:4;
   end;

theorem
  for x,y,z being set holds
    InnerVertices BitGFA0Str(x,y,z) is Relation
   proof
     let x,y,z be set;
     set S1 = GFA0AdderStr(x,y,z);
     set S2 = GFA0CarryStr(x,y,z);
     InnerVertices S1 is Relation & InnerVertices S2 is Relation
       by FACIRC_1:58,Th15;
     hence thesis by FACIRC_1:3;
  end;

::-------------------------------------------------------
:: InputVertices

theorem Th41:
  for x,y,z being set  st z <> [<*x,y*>,xor2] &
    x <> [<*y,z*>,and2] & y <> [<*z,x*>,and2] & z <> [<*x,y*>,and2]
   holds
    InputVertices BitGFA0Str(x,y,z) = {x,y,z}
   proof
     set f0 = xor2;
     set f1 = and2, f2 = and2, f3 = and2;
     let x,y,z be set such that
A1:  z <> [<*x,y*>,f0] and
A2:  x <> [<*y,z*>,f2] & y <> [<*z,x*>,f3] & z <> [<*x,y*>,f1];
     set S = BitGFA0Str(x,y,z);
     set S1 = GFA0AdderStr(x,y,z);
     set S2 = GFA0CarryStr(x,y,z);
A3:  InputVertices S1 = {x,y,z} by A1,FACIRC_1:57;
A4:  InputVertices S2 = {x,y,z} by A2,Th17;
     S1 tolerates S2 by CIRCCOMB:55;
    hence thesis by A3,A4,FACIRC_2:22;
   end;

theorem Th42:
 for x,y,z being non pair set holds
    InputVertices BitGFA0Str(x,y,z) = {x,y,z}
   proof
     let x,y,z be non pair set;
     set S = BitGFA0Str(x,y,z);
     set S1 = GFA0AdderStr(x,y,z);
     set S2 = GFA0CarryStr(x,y,z);
A1:  InputVertices S1 is without_pairs & InnerVertices S1 is Relation
      by FACIRC_1:58,FACIRC_1:59;
A2:  InputVertices S2 is without_pairs & InnerVertices S2 is Relation
      by Th15,Th18;
     InputVertices S1 = {x,y,z} & InputVertices S2 = {x,y,z}
      by FACIRC_1:57,Th22;
    hence InputVertices S = {x,y,z} \/ {x,y,z} by A1,A2,FACIRC_1:7
                         .= {x,y,z};
  end;

theorem
 for x,y,z being non pair set holds
    InputVertices BitGFA0Str(x,y,z) is without_pairs
   proof
     let x,y,z be non pair set;
     InputVertices BitGFA0Str(x,y,z) = {x,y,z} by Th42;
    hence thesis;
   end;

::-------------------------------------------------------
:: Carrier and misc.

theorem
 for x,y,z being set holds
    x in the carrier of BitGFA0Str(x,y,z) &
    y in the carrier of BitGFA0Str(x,y,z) &
    z in the carrier of BitGFA0Str(x,y,z) &
    [<*x,y*>,xor2] in the carrier of BitGFA0Str(x,y,z) &
    [<*[<*x,y*>,xor2],z*>,xor2] in the carrier of BitGFA0Str(x,y,z) &
    [<*x,y*>,and2] in the carrier of BitGFA0Str(x,y,z) &
    [<*y,z*>,and2] in the carrier of BitGFA0Str(x,y,z) &
    [<*z,x*>,and2] in the carrier of BitGFA0Str(x,y,z) &
    [<*[<*x,y*>,and2],[<*y,z*>,and2],[<*z,x*>,and2]*>,or3]
                                in the carrier of BitGFA0Str(x,y,z)
   proof
     set f0 = xor2;
     set f1 = and2, f2 = and2, f3 = and2, f4 = or3;
     let x,y,z be set;
     set xy = [<*x,y*>,f1], yz = [<*y,z*>,f2], zx = [<*z,x*>,f3];
     set xyz = [<*xy, yz, zx*>,f4];
     set S1 = GFA0AdderStr(x,y,z);
     set S2 = GFA0CarryStr(x,y,z);
A1:  x in the carrier of S1 & y in the carrier of S1 &
     z in the carrier of S1 &
     [<*x,y*>,f0] in the carrier of S1 &
     [<*[<*x,y*>,f0],z*>,f0] in the carrier of S1 by FACIRC_1:60,61;
     xy in the carrier of S2 & yz in the carrier of S2 &
     zx in the carrier of S2 &
     xyz in the carrier of S2 by Th19;
    hence thesis by A1,FACIRC_1:20;
  end;

theorem Th45:
  for x,y,z being set holds
    [<*x,y*>,xor2] in InnerVertices BitGFA0Str(x,y,z) &
    GFA0AdderOutput(x,y,z) in InnerVertices BitGFA0Str(x,y,z) &
    [<*x,y*>,and2] in InnerVertices BitGFA0Str(x,y,z) &
    [<*y,z*>,and2] in InnerVertices BitGFA0Str(x,y,z) &
    [<*z,x*>,and2] in InnerVertices BitGFA0Str(x,y,z) &
    GFA0CarryOutput(x,y,z) in InnerVertices BitGFA0Str(x,y,z)
   proof
     set f0 = xor2;
     set f1 = and2, f2 = and2, f3 = and2;
     let x,y,z be set;
     set xyf0 = [<*x,y*>,f0];
     set xyf1 = [<*x,y*>,f1], yzf2 = [<*y,z*>,f2], zxf3 = [<*z,x*>,f3];
     set S = BitGFA0Str(x,y,z);
     set A1 = GFA0AdderOutput(x,y,z);
     set A2 = GFA0CarryOutput(x,y,z);
     InnerVertices S
       = {xyf0} \/ {A1} \/ {xyf1,yzf2,zxf3} \/ {A2} by Th39
      .= {xyf0,A1} \/ {xyf1,yzf2,zxf3} \/ {A2} by ENUMSET1:41
      .= {xyf0,A1,xyf1,yzf2,zxf3} \/ {A2} by ENUMSET1:48
      .= {xyf0,A1,xyf1,yzf2,zxf3,A2} by ENUMSET1:55;
     hence thesis by ENUMSET1:def 4;
   end;

theorem
  for x,y,z being set  st z <> [<*x,y*>,xor2] &
    x <> [<*y,z*>,and2] & y <> [<*z,x*>,and2] & z <> [<*x,y*>,and2]
   holds
    x in InputVertices BitGFA0Str(x,y,z) &
    y in InputVertices BitGFA0Str(x,y,z) &
    z in InputVertices BitGFA0Str(x,y,z)
   proof
     set f0 = xor2;
     set f1 = and2, f2 = and2, f3 = and2;
     let x,y,z be set such that
A1:  z <> [<*x,y*>,f0] &
     x <> [<*y,z*>,f2] & y <> [<*z,x*>,f3] & z <> [<*x,y*>,f1];
     set S = BitGFA0Str(x,y,z);
     InputVertices S = {x,y,z} by A1,Th41;
    hence thesis by ENUMSET1:def 1;
   end;

::------------------------------------------------------------------
:: GFA0 : Carry and Adder Output Definition of GFA Combined Circuit
::------------------------------------------------------------------

definition
 let x,y,z be set;
 func BitGFA0CarryOutput(x,y,z) ->
         Element of InnerVertices BitGFA0Str(x,y,z) equals
    [<*[<*x,y*>,and2],[<*y,z*>,and2],[<*z,x*>,and2]*>,or3];
  coherence
    proof
      GFA0CarryOutput(x,y,z)
        in InnerVertices BitGFA0Str(x,y,z) by Th45;
      hence thesis;
    end;
end;

definition
 let x,y,z be set;
 func BitGFA0AdderOutput(x,y,z) ->
         Element of InnerVertices BitGFA0Str(x,y,z) equals
    2GatesCircOutput(x,y,z, xor2);
  coherence
    proof
      GFA0AdderOutput(x,y,z)
        in InnerVertices BitGFA0Str(x,y,z) by Th45;
      hence thesis;
    end;
end;

::-------------------------------------------------------------
:: GFA0 Combined : Stability of the Adder/Carry Output Circuit
::-------------------------------------------------------------

theorem
  for x,y,z being set  st z <> [<*x,y*>,xor2] &
    x <> [<*y,z*>,and2] & y <> [<*z,x*>,and2] & z <> [<*x,y*>,and2]
   for s being State of BitGFA0Circ(x,y,z)
    for a1,a2,a3 being Element of BOOLEAN st a1 = s.x & a2 = s.y & a3 = s.z
     holds
      Following(s,2).GFA0AdderOutput(x,y,z) = a1 'xor' a2 'xor' a3 &
      Following(s,2).GFA0CarryOutput(x,y,z)
           = a1 '&' a2 'or' a2 '&' a3 'or' a3 '&' a1
   proof
     set f0 = xor2;
     set f1 = and2, f2 = and2, f3 = and2;
     let x,y,z be set such that
A1:  z <> [<*x,y*>,f0] &
     x <> [<*y,z*>,f2] & y <> [<*z,x*>,f3] & z <> [<*x,y*>,f1];
     set S = BitGFA0Str(x,y,z);
     set S1 = GFA0AdderStr(x,y,z);
     set S2 = GFA0CarryStr(x,y,z);
     set A = BitGFA0Circ(x,y,z);
     set A1 = GFA0AdderCirc(x,y,z);
     set A2 = GFA0CarryCirc(x,y,z);
     let s be State of A;
     let a1,a2,a3 be Element of BOOLEAN; assume
A2:  a1 = s.x & a2 = s.y & a3 = s.z;
A3:  x in the carrier of S1 & y in the carrier of S1 & z in the carrier of S1
     by FACIRC_1:60;
A4:  x in the carrier of S2 & y in the carrier of S2 & z in the carrier of S2
     by Th19;
     reconsider s1 = s|the carrier of S1 as State of A1 by FACIRC_1:26;
     reconsider s2 = s|the carrier of S2 as State of A2 by FACIRC_1:26;
     reconsider t = s as State of A1+*A2;
     InputVertices S1 = {x,y,z} by A1,FACIRC_1:57;
then A5: InputVertices S1 = InputVertices S2 by A1,Th17;
A6:  InnerVertices S1 misses InputVertices S1 &
     InnerVertices S2 misses InputVertices S2 by XBOOLE_1:79;
     dom s1 = the carrier of S1 by CIRCUIT1:4;
then a1 = s1.x & a2 = s1.y & a3 = s1.z by A2,A3,FUNCT_1:70;
then Following(t,2).GFA0AdderOutput(x,y,z)
        = Following(s1,2).GFA0AdderOutput(x,y,z) &
     Following(s1,2).GFA0AdderOutput(x,y,z) = a1 'xor' a2 'xor' a3
       by A1,A5,A6,Th37,FACIRC_1:32;
     hence Following(s,2).GFA0AdderOutput(x,y,z) = a1 'xor' a2 'xor' a3;
     dom s2 = the carrier of S2 by CIRCUIT1:4;
then a1 = s2.x & a2 = s2.y & a3 = s2.z by A2,A4,FUNCT_1:70;
then Following(t,2).GFA0CarryOutput(x,y,z)
        = Following(s2,2).GFA0CarryOutput(x,y,z) &
     Following(s2,2).GFA0CarryOutput(x,y,z)
        = a1 '&' a2 'or' a2 '&' a3 'or' a3 '&' a1
       by A1,A5,A6,Th25,FACIRC_1:33;
     hence Following(s,2).GFA0CarryOutput(x,y,z)
        = a1 '&' a2 'or' a2 '&' a3 'or' a3 '&' a1;
   end;

theorem
 for x,y,z being set  st z <> [<*x,y*>,xor2] &
   x <> [<*y,z*>,and2] & y <> [<*z,x*>,and2] & z <> [<*x,y*>,and2]
   for s being State of BitGFA0Circ(x,y,z)
    holds Following(s,2) is stable
   proof
     set f0 = xor2;
     set f1 = and2, f2 = and2, f3 = and2;
     let x,y,z be set such that
A1:  z <> [<*x,y*>,f0] &
     x <> [<*y,z*>,f2] & y <> [<*z,x*>,f3] & z <> [<*x,y*>,f1];
     set S = BitGFA0Str(x,y,z);
     set S1 = GFA0AdderStr(x,y,z);
     set S2 = GFA0CarryStr(x,y,z);
     set A = BitGFA0Circ(x,y,z);
     set A1 = GFA0AdderCirc(x,y,z);
     set A2 = GFA0CarryCirc(x,y,z);
     let s be State of A;
     reconsider s1 = s|the carrier of S1 as State of A1 by FACIRC_1:26;
     reconsider s2 = s|the carrier of S2 as State of A2 by FACIRC_1:26;
     reconsider t = s as State of A1+*A2;
     InputVertices S1 = {x,y,z} by A1,FACIRC_1:57;
then A2: InputVertices S1 = InputVertices S2 by A1,Th17;
     InnerVertices S1 misses InputVertices S1 &
     InnerVertices S2 misses InputVertices S2 by XBOOLE_1:79;
then A3: Following(s1,2) = Following(t,2)|the carrier of S1 &
         Following(s1,3) = Following(t,3)|the carrier of S1 &
         Following(s2,2) = Following(t,2)|the carrier of S2 &
         Following(s2,3) = Following(t,3)|the carrier of S2
          by A2,FACIRC_1:30,31;
     Following(s1,2) is stable by A1,FACIRC_1:63;
then A4: Following(s1,2)
       = Following Following(s1,2) by CIRCUIT2:def 6
      .= Following(s1,2+1) by FACIRC_1:12;
     Following(s2,2) is stable by A1,Th26;
then A5: Following(s2,2)
       = Following Following(s2,2) by CIRCUIT2:def 6
      .= Following(s2,2+1) by FACIRC_1:12;
A6:  Following(s,2+1) = Following Following(s,2) by FACIRC_1:12;
A7:  dom Following(s,2) = the carrier of S &
     dom Following(s,3) = the carrier of S &
     dom Following(s1,2) = the carrier of S1 &
     dom Following(s2,2) = the carrier of S2 by CIRCUIT1:4;
A8: the carrier of S = (the carrier of S1) \/ the carrier of S2
      by CIRCCOMB:def 2;
       now let a be set; assume a in the carrier of S;
       then a in the carrier of S1 or a in the carrier of S2
              by A8,XBOOLE_0:def 2;
       then (Following(s,2)).a = (Following(s1,2)).a &
            (Following(s,3)).a = (Following(s1,3)).a or
            (Following(s,2)).a = (Following(s2,2)).a &
            (Following(s,3)).a = (Following(s2,3)).a
              by A3,A4,A5,A7,FUNCT_1:70;
       hence (Following(s,2)).a = (Following Following(s,2)).a
              by A4,A5,FACIRC_1:12;
       end;
    hence Following(s,2) = Following Following(s,2) by A6,A7,FUNCT_1:9;
   end;

::========================================================================

begin :: Generalized Full Adder (GFA) Circuit (TYPE-1)

::========================================================================
:: << GFA TYPE-1 >>
::------------------------------------------------------------------------
::   Name     : Generalized Full Adder Type-1 (GFA1)
::   Function : x - y + z = 2 * c - s
::
::   Logic Symbol :      x     -y      Combined : GFA1CarryIStr(x,y,z)
::                       |     /                  GFA1CarryStr(x,y,z)
::                       |    /                   GFA1AdderStr(x,y,z)
::                   +---*---O                  --->
::                   |  GFA  *-----z              BitGFA1Str(x,y,z)
::                   | TYPE1 |
::                   *---O---+          Outputs : BitGFA1CarryOutput(x,y,z)
::                  /    |                        BitGFA1AdderOutput(x,y,z)
::                 /     |
::                c     -s          Calculation : Following(s,2) is stable.
::=========================================================================

::-------------------------------------------------
:: GFA1 Carry : Circuit Definition of Carry Output
::-------------------------------------------------

definition
 let x,y,z be set;
 func GFA1CarryIStr(x,y,z) ->
    unsplit gate`1=arity gate`2isBoolean
    non void strict non empty ManySortedSign equals
    1GateCircStr(<*x,y*>,and2c) +* 1GateCircStr(<*y,z*>,and2a) +*
    1GateCircStr(<*z,x*>,and2);
  coherence;
end;

definition
 let x,y,z be set;
 func GFA1CarryICirc(x,y,z) ->
      strict Boolean gate`2=den Circuit of GFA1CarryIStr(x,y,z) equals
    1GateCircuit(x,y,and2c) +* 1GateCircuit(y,z,and2a) +*
    1GateCircuit(z,x,and2);
  coherence;
end;

definition
 let x,y,z be set;
 func GFA1CarryStr(x,y,z) ->
    unsplit gate`1=arity gate`2isBoolean
    non void strict non empty ManySortedSign equals
    GFA1CarryIStr(x,y,z) +*
    1GateCircStr(<*[<*x,y*>,and2c], [<*y,z*>,and2a], [<*z,x*>,and2]*>,or3);
  coherence;
end;

definition
 let x,y,z be set;
 func GFA1CarryCirc(x,y,z) ->
      strict Boolean gate`2=den Circuit of GFA1CarryStr(x,y,z) equals
    GFA1CarryICirc(x,y,z) +*
    1GateCircuit([<*x,y*>,and2c],[<*y,z*>,and2a],[<*z,x*>,and2],or3);
  coherence;
end;

definition
 let x,y,z be set;
 func GFA1CarryOutput(x,y,z) -> Element of InnerVertices GFA1CarryStr(x,y,z)
  equals
   [<*[<*x,y*>,and2c],[<*y,z*>,and2a],[<*z,x*>,and2]*>,or3];
  coherence
   proof
     [<*[<*x,y*>,and2c],[<*y,z*>,and2a],[<*z,x*>,and2]*>,or3] in
      InnerVertices
       1GateCircStr(<*[<*x,y*>,and2c],[<*y,z*>,and2a], [<*z,x*>,and2]*>,or3)
       by FACIRC_1:47;
    hence thesis by FACIRC_1:21;
   end;
end;

::-------------------------------------------------------
:: GFA1 Carry : Carrier, InnerVertices and InputVertices
::-------------------------------------------------------

::-------------------------------------------------------
:: InnerVertices

theorem Th49:
  for x,y,z being set holds
  InnerVertices GFA1CarryIStr(x,y,z) =
   {[<*x,y*>,and2c], [<*y,z*>,and2a], [<*z,x*>,and2]}
   proof
     set f1 = and2c, f2 = and2a, f3 = and2;
     let x,y,z be set;
     set xy = [<*x,y*>,f1], yz = [<*y,z*>,f2], zx = [<*z,x*>,f3];
     set Cxy = 1GateCircStr(<*x,y*>,f1);
     set Cyz = 1GateCircStr(<*y,z*>,f2);
     set Czx = 1GateCircStr(<*z,x*>,f3);
A1:  Cxy +* Cyz tolerates Czx by CIRCCOMB:55;
A2:  Cxy tolerates Cyz by CIRCCOMB:55;
     InnerVertices GFA1CarryIStr(x,y,z)
       = InnerVertices(Cxy +* Cyz) \/ InnerVertices(Czx) by A1,CIRCCOMB:15
      .= InnerVertices(Cxy) \/ InnerVertices(Cyz) \/
         InnerVertices(Czx) by A2,CIRCCOMB:15
      .= {xy} \/ InnerVertices(Cyz) \/ InnerVertices(Czx) by CIRCCOMB:49
      .= {xy} \/ {yz} \/ InnerVertices(Czx) by CIRCCOMB:49
      .= {xy} \/ {yz} \/ {zx} by CIRCCOMB:49
      .= {xy, yz} \/ {zx} by ENUMSET1:41
      .= {xy, yz, zx} by ENUMSET1:43;
    hence thesis;
   end;

theorem Th50:
  for x,y,z being set holds
  InnerVertices GFA1CarryStr(x,y,z) =
     {[<*x,y*>,and2c], [<*y,z*>,and2a], [<*z,x*>,and2]} \/
     {GFA1CarryOutput(x,y,z)}
   proof
     set f1 = and2c, f2 = and2a, f3 = and2, f4 = or3;
     let x,y,z be set;
     set xy = [<*x,y*>,f1], yz = [<*y,z*>,f2], zx = [<*z,x*>,f3];
     set xyz = [<*xy, yz, zx*>,f4];
     set Cxy = 1GateCircStr(<*x,y*>,f1);
     set Cyz = 1GateCircStr(<*y,z*>,f2);
     set Czx = 1GateCircStr(<*z,x*>,f3);
     set Cxyz = 1GateCircStr(<*xy, yz, zx*>,f4);
A1:  Cxy tolerates (Cyz +* Czx +* Cxyz) by CIRCCOMB:55;
A2:  Cyz tolerates (Czx +* Cxyz) by CIRCCOMB:55;
A3:  Czx tolerates Cxyz by CIRCCOMB:55;
A4:  InnerVertices (Cyz +* (Czx +* Cxyz))
      = InnerVertices Cyz \/ InnerVertices (Czx +* Cxyz) by A2,CIRCCOMB:15;
A5:  InnerVertices (Czx +* Cxyz)
      = InnerVertices Czx \/ InnerVertices Cxyz by A3,CIRCCOMB:15;
thus InnerVertices GFA1CarryStr(x,y,z)
      = InnerVertices (Cxy +* (Cyz +* Czx) +* Cxyz) by CIRCCOMB:10
     .= InnerVertices (Cxy +* (Cyz +* Czx +* Cxyz)) by CIRCCOMB:10
     .= InnerVertices Cxy \/ InnerVertices (Cyz +* Czx +* Cxyz)
          by A1,CIRCCOMB:15
     .= InnerVertices Cxy \/ InnerVertices (Cyz +* (Czx +* Cxyz))
          by CIRCCOMB:10
     .= InnerVertices Cxy \/ InnerVertices Cyz \/
          (InnerVertices Czx \/ InnerVertices Cxyz) by A4,A5,XBOOLE_1:4
     .= InnerVertices Cxy \/ InnerVertices Cyz \/
           InnerVertices Czx \/ InnerVertices Cxyz by XBOOLE_1:4
     .= {xy} \/ InnerVertices Cyz \/
           InnerVertices Czx \/ InnerVertices Cxyz by CIRCCOMB:49
     .= {xy} \/ {yz} \/ InnerVertices Czx \/ InnerVertices Cxyz by CIRCCOMB:49
     .= {xy} \/ {yz} \/ {zx} \/ InnerVertices Cxyz by CIRCCOMB:49
     .= {xy, yz} \/ {zx} \/ InnerVertices Cxyz by ENUMSET1:41
     .= {xy, yz, zx} \/ InnerVertices Cxyz by ENUMSET1:43
     .= {xy, yz, zx} \/ {GFA1CarryOutput(x,y,z)} by CIRCCOMB:49;
  end;

theorem Th51:
  for x,y,z being set holds
  InnerVertices GFA1CarryStr(x,y,z) is Relation
   proof
     set f1 = and2c, f2 = and2a, f3 = and2, f4 = or3;
     let x,y,z be set;
     set xy = [<*x,y*>,f1], yz = [<*y,z*>,f2], zx = [<*z,x*>,f3];
     set Cxy = 1GateCircStr(<*x,y*>,f1);
     set Cyz = 1GateCircStr(<*y,z*>,f2);
     set Czx = 1GateCircStr(<*z,x*>,f3);
     set Cxyz = 1GateCircStr(<*xy, yz, zx*>,f4);
A1:  InnerVertices Cxy is Relation & InnerVertices Cyz is Relation &
     InnerVertices Czx is Relation by FACIRC_1:38;
then InnerVertices (Cxy +* Cyz) is Relation by FACIRC_1:3;
then InnerVertices Cxyz is Relation &
     InnerVertices GFA1CarryIStr(x,y,z) is Relation by A1,FACIRC_1:3,38;
    hence thesis by FACIRC_1:3;
   end;

::-------------------------------------------------------
:: InputVertices

theorem Th52:
 for x,y,z being set st
   x <> [<*y,z*>,and2a] & y <> [<*z,x*>,and2] & z <> [<*x,y*>,and2c]
  holds InputVertices GFA1CarryIStr(x,y,z) = {x,y,z}
   proof
     set f1 = and2c, f2 = and2a, f3 = and2;
     let x,y,z be set;
     set xy = [<*x,y*>,f1], yz = [<*y,z*>,f2], zx = [<*z,x*>,f3];
     set Cxy = 1GateCircStr(<*x,y*>,f1);
     set Cyz = 1GateCircStr(<*y,z*>,f2);
     set Czx = 1GateCircStr(<*z,x*>,f3);
     assume
A1:  x <> yz & y <> zx & z <> xy;
A2:  Cxy +* Cyz tolerates Czx by CIRCCOMB:55;
A3:  Cxy tolerates Cyz by CIRCCOMB:55;
A4:  y <> yz by FACIRC_2:3;
A5:  not xy in {y,z} by A1,Lm1;
A6:  not z in {xy, yz} & not x in {xy, yz} by A1,Lm1;
A7:  not zx in {x,y,z} by A1,Lm1;
     InputVertices GFA1CarryIStr(x,y,z)
      = (InputVertices(Cxy +* Cyz) \ InnerVertices(Czx)) \/
        (InputVertices(Czx) \ InnerVertices(Cxy +* Cyz)) by A2,CIRCCMB2:6
     .= ((InputVertices(Cxy) \ InnerVertices(Cyz)) \/
         (InputVertices(Cyz) \ InnerVertices(Cxy))) \ InnerVertices(Czx) \/
         (InputVertices(Czx) \ InnerVertices(Cxy +* Cyz)) by A3,CIRCCMB2:6
     .= ((InputVertices(Cxy) \ InnerVertices(Cyz)) \/
         (InputVertices(Cyz) \ InnerVertices(Cxy))) \ InnerVertices(Czx) \/
         (InputVertices(Czx) \ (InnerVertices(Cxy) \/ InnerVertices(Cyz)))
          by A3,CIRCCOMB:15
     .= ((InputVertices(Cxy) \ {yz}) \/
         (InputVertices(Cyz) \ InnerVertices(Cxy))) \ InnerVertices(Czx) \/
         (InputVertices(Czx) \ (InnerVertices(Cxy) \/ InnerVertices(Cyz)))
          by CIRCCOMB:49
     .= ((InputVertices(Cxy) \ {yz}) \/
         (InputVertices(Cyz) \ {xy})) \ InnerVertices(Czx) \/
         (InputVertices(Czx) \ (InnerVertices(Cxy) \/ InnerVertices(Cyz)))
          by CIRCCOMB:49
     .= ((InputVertices(Cxy) \ {yz}) \/
         (InputVertices(Cyz) \ {xy})) \ {zx} \/
         (InputVertices(Czx) \ (InnerVertices(Cxy) \/ InnerVertices(Cyz)))
          by CIRCCOMB:49
     .= ((InputVertices(Cxy) \ {yz}) \/
         (InputVertices(Cyz) \ {xy})) \ {zx} \/
         (InputVertices(Czx) \ ({xy} \/ InnerVertices(Cyz))) by CIRCCOMB:49
     .= ((InputVertices(Cxy) \ {yz}) \/
         (InputVertices(Cyz) \ {xy})) \ {zx} \/
         (InputVertices(Czx) \ ({xy} \/ {yz})) by CIRCCOMB:49
     .= (({x,y} \ {yz}) \/ (InputVertices(Cyz) \ {xy})) \ {zx} \/
         (InputVertices(Czx) \ ({xy} \/ {yz})) by FACIRC_1:40
     .= (({x,y} \ {yz}) \/ ({y,z} \ {xy})) \ {zx} \/
         (InputVertices(Czx) \ ({xy} \/ {yz})) by FACIRC_1:40
     .= (({x,y} \ {yz}) \/ ({y,z} \ {xy})) \ {zx} \/
         ({z,x} \ ({xy} \/ {yz})) by FACIRC_1:40
     .= (({x,y} \ {yz}) \/ ({y,z} \ {xy})) \ {zx} \/
         ({z,x} \ {xy,yz}) by ENUMSET1:41
     .= (({x,y} \/ ({y,z} \ {xy})) \ {zx}) \/ ({z,x} \ {xy,yz})
          by A1,A4,FACIRC_2:1
     .= ({x,y} \/ {y,z}) \ {zx} \/ ({z,x} \ {xy,yz}) by A5,ZFMISC_1:65
     .= ({x,y} \/ {y,z}) \ {zx} \/ {z,x} by A6,ZFMISC_1:72
     .= {x,y,y,z} \ {zx} \/ {z,x} by ENUMSET1:45
     .= {y,y,x,z} \ {zx} \/ {z,x} by ENUMSET1:110
     .= {y,x,z} \ {zx} \/ {z,x} by ENUMSET1:71
     .= {x,y,z} \ {zx} \/ {z,x} by ENUMSET1:99
     .= {x,y,z} \/ {z,x} by A7,ZFMISC_1:65
     .= {x,y,z,z,x} by ENUMSET1:49
     .= {x,y,z,z} \/ {x} by ENUMSET1:50
     .= {z,z,x,y} \/ {x} by ENUMSET1:118
     .= {z,x,y} \/ {x} by ENUMSET1:71
     .= {z,x,y,x} by ENUMSET1:46
     .= {x,x,y,z} by ENUMSET1:113
     .= {x,y,z} by ENUMSET1:71;
    hence thesis;
   end;

theorem Th53:
 for x,y,z being set st
   x <> [<*y,z*>,and2a] & y <> [<*z,x*>,and2] & z <> [<*x,y*>,and2c]
  holds InputVertices GFA1CarryStr(x,y,z) = {x,y,z}
   proof
     set f1 = and2c, f2 = and2a, f3 = and2, f4 = or3;
     let x,y,z be set;
     set xy = [<*x,y*>,f1], yz = [<*y,z*>,f2], zx = [<*z,x*>,f3];
     set xyz = [<*xy, yz, zx*>,f4];
     set S = 1GateCircStr(<*xy, yz, zx*>,f4);
     set MI = GFA1CarryIStr(x,y,z);
A1:  InnerVertices S = {xyz} by CIRCCOMB:49;
A2:  InputVertices S = rng <*xy, yz, zx*> by CIRCCOMB:49
                    .= {xy, yz, zx} by FINSEQ_2:148;
     assume
A3:  x <> yz & y <> zx & z <> xy;
A4:  {x, y, z} \ {xyz} = {x, y, z} by Lm2;
A5:  {xy, yz, zx} \ {xy, yz, zx} = {} by XBOOLE_1:37;
     GFA1CarryStr(x,y,z) = MI +* S & MI tolerates S by CIRCCOMB:55;
     hence InputVertices GFA1CarryStr(x,y,z)
      = ((InputVertices MI) \ InnerVertices S) \/
         ((InputVertices S) \ InnerVertices MI) by CIRCCMB2:6
     .= {x,y,z} \/ ({xy, yz, zx} \ InnerVertices MI) by A1,A2,A3,A4,Th52
     .= {x,y,z} \/ {} by A5,Th49
     .= {x,y,z};
  end;

theorem Th54:
 for x,y,z being non pair set holds
  InputVertices GFA1CarryStr(x,y,z) is without_pairs
   proof
     set f1 = and2c, f2 = and2a, f3 = and2, f4 = or3;
     let x,y,z be non pair set;
     set xy = [<*x,y*>,f1], yz = [<*y,z*>,f2], zx = [<*z,x*>,f3];
     set Cxy = 1GateCircStr(<*x,y*>,f1);
     set Cyz = 1GateCircStr(<*y,z*>,f2);
     set Czx = 1GateCircStr(<*z,x*>,f3);
     set S = 1GateCircStr(<*xy, yz, zx*>,f4);
     set M = GFA1CarryStr(x,y,z);
     set MI = GFA1CarryIStr(x,y,z);
A1:  InputVertices Cxy is without_pairs & InputVertices Cyz is without_pairs &
     InputVertices Czx is without_pairs by FACIRC_1:41;
then InputVertices (Cxy+*Cyz) is without_pairs by FACIRC_1:9;
then A2: InputVertices MI is without_pairs by A1,FACIRC_1:9;
     InnerVertices S is Relation by FACIRC_1:38;
then A3: InputVertices M = (InputVertices MI) \/
          (InputVertices S \ InnerVertices MI) by A2,FACIRC_1:6;
     given xx being pair set such that
A4:  xx in InputVertices M;
A5:  InputVertices S = {xy, yz, zx} by FACIRC_1:42;
A6:  InnerVertices Cxy = {xy} & InnerVertices Cyz = {yz} &
     InnerVertices Czx = {zx} by CIRCCOMB:49;
     Cxy tolerates Cyz & Cxy tolerates Czx & Cyz tolerates Czx by CIRCCOMB:55;
then A7: InnerVertices (Cxy +* Cyz) = {xy} \/ {yz} by A6,CIRCCOMB:15;
     Cxy +* Cyz tolerates Czx by CIRCCOMB:55;
then InnerVertices MI = {xy} \/ {yz} \/ {zx} by A6,A7,CIRCCOMB:15
     .= {xy, yz} \/ {zx} by ENUMSET1:41
     .= {xy, yz, zx} by ENUMSET1:43;
then InputVertices S \ InnerVertices MI = {} by A5,XBOOLE_1:37;
    hence thesis by A2,A3,A4,FACIRC_1:def 2;
  end;

::-------------------------------------------------------
:: Carrier and misc.

theorem Th55:
  for x,y,z being set holds
    x in the carrier of GFA1CarryStr(x,y,z) &
    y in the carrier of GFA1CarryStr(x,y,z) &
    z in the carrier of GFA1CarryStr(x,y,z) &
    [<*x,y*>,and2c] in the carrier of GFA1CarryStr(x,y,z) &
    [<*y,z*>,and2a] in the carrier of GFA1CarryStr(x,y,z) &
    [<*z,x*>,and2] in the carrier of GFA1CarryStr(x,y,z) &
    [<*[<*x,y*>,and2c],[<*y,z*>,and2a],[<*z,x*>,and2]*>,or3]
                   in the carrier of GFA1CarryStr(x,y,z)
   proof
     set f1 = and2c, f2 = and2a, f3 = and2, f4 = or3;
     let x,y,z be set;
     set xy = [<*x,y*>,f1], yz = [<*y,z*>,f2], zx = [<*z,x*>,f3];
     set xyz = [<*xy, yz, zx*>,f4];
     set Cxy = 1GateCircStr(<*x,y*>,f1);
     set Cyz = 1GateCircStr(<*y,z*>,f2);
     set Czx = 1GateCircStr(<*z,x*>,f3);
     set Cxyz = 1GateCircStr(<*xy, yz, zx*>,f4);
     y in the carrier of Cxy by FACIRC_1:43;
then A1: y in the carrier of Cxy +* Cyz by FACIRC_1:20;
     x in the carrier of Czx & z in the carrier of Czx by FACIRC_1:43;
then A2: x in the carrier of GFA1CarryIStr(x,y,z) &
         y in the carrier of GFA1CarryIStr(x,y,z) &
         z in the carrier of GFA1CarryIStr(x,y,z) by A1,FACIRC_1:20;
     xy in the carrier of Cxy & yz in the carrier of Cyz by FACIRC_1:43;
then A3: xy in the carrier of Cxy +* Cyz & yz in the carrier of Cxy +* Cyz
       by FACIRC_1:20;
     zx in the carrier of Czx by FACIRC_1:43;
then A4: xy in the carrier of GFA1CarryIStr(x,y,z) &
         yz in the carrier of GFA1CarryIStr(x,y,z) &
         zx in the carrier of GFA1CarryIStr(x,y,z) by A3,FACIRC_1:20;
     set p = <*xy,yz,zx*>;
     the carrier of Cxyz = rng p \/ {xyz} & [p,f4] in {[p,f4]}
       by CIRCCOMB:def 6,TARSKI:def 1;
then xyz in the carrier of Cxyz by XBOOLE_0:def 2;
    hence thesis by A2,A4,FACIRC_1:20;
  end;

theorem Th56:
 for x,y,z being set holds
   [<*x,y*>,and2c] in InnerVertices GFA1CarryStr(x,y,z) &
   [<*y,z*>,and2a] in InnerVertices GFA1CarryStr(x,y,z) &
   [<*z,x*>,and2] in InnerVertices GFA1CarryStr(x,y,z) &
   GFA1CarryOutput(x,y,z) in InnerVertices GFA1CarryStr(x,y,z)
   proof
     set f1 = and2c, f2 = and2a, f3 = and2;
     let x,y,z be set;
     set xy = [<*x,y*>,f1], yz = [<*y,z*>,f2], zx = [<*z,x*>,f3];
     InnerVertices GFA1CarryStr(x,y,z)
       = {xy,yz,zx} \/ {GFA1CarryOutput(x,y,z)} by Th50
      .= {xy,yz,zx,GFA1CarryOutput(x,y,z)} by ENUMSET1:46;
    hence thesis by ENUMSET1:def 2;
  end;

theorem Th57:
  for x,y,z being set st
     x <> [<*y,z*>,and2a] & y <> [<*z,x*>,and2] & z <> [<*x,y*>,and2c]
   holds
    x in InputVertices GFA1CarryStr(x,y,z) &
    y in InputVertices GFA1CarryStr(x,y,z) &
    z in InputVertices GFA1CarryStr(x,y,z)
   proof
     set f1 = and2c, f2 = and2a, f3 = and2;
     let x,y,z be set such that
A1:  x <> [<*y,z*>,f2] & y <> [<*z,x*>,f3] & z <> [<*x,y*>,f1];
     InputVertices GFA1CarryStr(x,y,z) = {x,y,z} by A1,Th53;
    hence thesis by ENUMSET1:def 1;
  end;

theorem Th58:
 for x,y,z being non pair set holds
  InputVertices GFA1CarryStr(x,y,z) = {x,y,z}
   proof
     set f1 = and2c, f2 = and2a, f3 = and2, f4 = or3;
     let x,y,z be non pair set;
     set xy = [<*x,y*>,f1], yz = [<*y,z*>,f2], zx = [<*z,x*>,f3];
     set Cxy = 1GateCircStr(<*x,y*>,f1);
     set Cyz = 1GateCircStr(<*y,z*>,f2);
     set Czx = 1GateCircStr(<*z,x*>,f3);
     set M = GFA1CarryStr(x,y,z);
     set MI = GFA1CarryIStr(x,y,z);
     set S = 1GateCircStr(<*xy,yz,zx*>,f4);
A1:  InputVertices Cxy is without_pairs &
     InputVertices Cyz is without_pairs &
     InputVertices Czx is without_pairs by FACIRC_1:41;
then A2: InputVertices (Cxy+*Cyz) is without_pairs by FACIRC_1:9;
then A3: InputVertices MI is without_pairs by A1,FACIRC_1:9;
A4:  InputVertices Cxy = {x,y} & InputVertices Cyz = {y,z} &
     InputVertices Czx = {z,x} by FACIRC_1:40;
     InnerVertices S is Relation by FACIRC_1:38;
then A5: InputVertices M =
      (InputVertices MI) \/ (InputVertices S \ InnerVertices MI)
       by A3,FACIRC_1:6;
A6:  InputVertices S = {xy, yz, zx} by FACIRC_1:42;
A7:  InnerVertices Cxy = {xy} & InnerVertices Cyz = {yz} &
     InnerVertices Czx = {zx} by CIRCCOMB:49;
     Cxy tolerates Cyz & Cxy tolerates Czx & Cyz tolerates Czx by CIRCCOMB:55;
then A8: InnerVertices (Cxy +* Cyz) = {xy} \/ {yz} by A7,CIRCCOMB:15;
     Cxy +* Cyz tolerates Czx by CIRCCOMB:55;
then InnerVertices MI = {xy} \/ {yz} \/ {zx} by A7,A8,CIRCCOMB:15
      .= {xy, yz} \/ {zx} by ENUMSET1:41
      .= {xy, yz, zx} by ENUMSET1:43;
then InputVertices S \ InnerVertices MI = {} by A6,XBOOLE_1:37;
     hence InputVertices M
       = (InputVertices(Cxy+*Cyz)) \/ InputVertices Czx
          by A1,A2,A7,A8,A5,FACIRC_1:7
      .= (InputVertices Cxy) \/ (InputVertices Cyz) \/ (InputVertices Czx)
          by A1,A7,FACIRC_1:7
      .= {x,y,y,z} \/ {z,x} by A4,ENUMSET1:45
      .= {y,y,x,z} \/ {z,x} by ENUMSET1:110
      .= {y,x,z} \/ {z,x} by ENUMSET1:71
      .= {x,y,z} \/ {z,x} by ENUMSET1:99
      .= {x,y,z} \/ ({z}\/{x}) by ENUMSET1:41
      .= {x,y,z} \/ {z} \/ {x} by XBOOLE_1:4
      .= {z,x,y} \/ {z} \/ {x} by ENUMSET1:100
      .= {z,z,x,y} \/ {x} by ENUMSET1:44
      .= {z,x,y} \/ {x} by ENUMSET1:71
      .= {x,y,z} \/ {x} by ENUMSET1:100
      .= {x,x,y,z} by ENUMSET1:44
      .= {x,y,z} by ENUMSET1:71;
  end;

::----------------------------------------------------
:: GFA1 Carry : Stability of the Carry Output Circuit
::----------------------------------------------------

theorem Th59:
 for x,y,z being set for s being State of GFA1CarryCirc(x,y,z)
  for a1,a2,a3 being Element of BOOLEAN st a1 = s.x & a2 = s.y & a3 = s.z
   holds
    (Following s).[<*x,y*>,and2c] = a1 '&' 'not' a2 &
    (Following s).[<*y,z*>,and2a] = 'not' a2 '&' a3 &
    (Following s).[<*z,x*>,and2]  = a3 '&' a1
   proof
     set f1 = and2c, f2 = and2a, f3 = and2;
     let x,y,z be set;
     let s be State of GFA1CarryCirc(x,y,z);
     set xy = [<*x,y*>,f1], yz = [<*y,z*>,f2], zx = [<*z,x*>,f3];
     let a1,a2,a3 be Element of BOOLEAN such that
A1:  a1 = s.x & a2 = s.y & a3 = s.z;
     set S = GFA1CarryStr(x,y,z);
A2:  InnerVertices S = the OperSymbols of S by FACIRC_1:37;
A3:  dom s = the carrier of S by CIRCUIT1:4;
A4:  x in the carrier of S & y in the carrier of S & z in the carrier of S
      by Th55;
     xy in InnerVertices GFA1CarryStr(x,y,z) by Th56;
     hence (Following s).[<*x,y*>,f1] = f1.(s*<*x,y*>) by A2,FACIRC_1:35
         .= f1.<*a1,a2*> by A1,A3,A4,FINSEQ_2:145
         .= a1 '&' 'not' a2 by Def3;
     yz in InnerVertices GFA1CarryStr(x,y,z) by Th56;
     hence (Following s).[<*y,z*>,f2] = f2.(s*<*y,z*>) by A2,FACIRC_1:35
         .= f2.<*a2,a3*> by A1,A3,A4,FINSEQ_2:145
         .= 'not' a2 '&' a3 by TWOSCOMP:def 2;
     zx in InnerVertices GFA1CarryStr(x,y,z) by Th56;
     hence (Following s).[<*z,x*>,f3] = f3.(s*<*z,x*>) by A2,FACIRC_1:35
         .= f3.<*a3,a1*> by A1,A3,A4,FINSEQ_2:145
         .= a3 '&' a1 by TWOSCOMP:def 1;
  end;

theorem Th60:
 for x,y,z being set for s being State of GFA1CarryCirc(x,y,z)
  for a1,a2,a3 being Element of BOOLEAN st
    a1 = s.[<*x,y*>,and2c] & a2 = s.[<*y,z*>,and2a] & a3 = s.[<*z,x*>,and2]
   holds
    (Following s).GFA1CarryOutput(x,y,z) = a1 'or' a2 'or' a3
   proof
     set f1 = and2c, f2 = and2a, f3 = and2, f4 = or3;
     let x,y,z be set;
     let s be State of GFA1CarryCirc(x,y,z);
     set xy =[<*x,y*>,f1], yz = [<*y,z*>,f2], zx = [<*z,x*>,f3];
     let a1,a2,a3 be Element of BOOLEAN such that
A1:  a1 = s.xy & a2 = s.yz & a3 = s.zx;
     set S = GFA1CarryStr(x,y,z);
A2:  InnerVertices S = the OperSymbols of S by FACIRC_1:37;
A3:  dom s = the carrier of S by CIRCUIT1:4;
     reconsider xy, yz, zx as Element of InnerVertices S by Th56;
     thus (Following s).GFA1CarryOutput(x,y,z)
          = f4.(s*<*xy, yz, zx*>) by A2,FACIRC_1:35
         .= f4.<*a1,a2,a3*> by A1,A3,FINSEQ_2:146
         .= a1 'or' a2 'or' a3 by TWOSCOMP:16;
  end;

theorem Th61:
  for x,y,z being set st
    x <> [<*y,z*>,and2a] & y <> [<*z,x*>,and2] & z <> [<*x,y*>,and2c]
   for s being State of GFA1CarryCirc(x,y,z)
    for a1,a2,a3 being Element of BOOLEAN st a1 = s.x & a2 = s.y & a3 = s.z
     holds
      Following(s,2).GFA1CarryOutput(x,y,z) =
        (a1 '&' 'not' a2) 'or' ('not' a2 '&' a3) 'or' (a3 '&' a1) &
      Following(s,2).[<*x,y*>,and2c] = a1 '&' 'not' a2 &
      Following(s,2).[<*y,z*>,and2a] = 'not' a2 '&' a3 &
      Following(s,2).[<*z,x*>,and2]  = a3 '&' a1
   proof
     set f1 = and2c, f2 = and2a, f3 = and2;
     let x,y,z be set such that
A1:  x <> [<*y,z*>,f2] & y <> [<*z,x*>,f3] & z <> [<*x,y*>,f1];
     set xy = [<*x,y*>,f1], yz = [<*y,z*>,f2], zx = [<*z,x*>,f3];
     let s be State of GFA1CarryCirc(x,y,z);
     let a1,a2,a3 be Element of BOOLEAN such that
A2:  a1 = s.x & a2 = s.y & a3 = s.z;
     set S = GFA1CarryStr(x,y,z);
     reconsider x' = x, y' = y, z' = z as Vertex of S by Th55;
     x in InputVertices S & y in InputVertices S & z in InputVertices S
     by A1,Th57;
then A3: (Following s).x' = s.x & (Following s).y' = s.y &
         (Following s).z' = s.z by CIRCUIT2:def 5;
A4:  Following(s,2) = Following Following s by FACIRC_1:15;
     (Following s).xy = a1 '&' 'not' a2 &
     (Following s).yz = 'not' a2 '&' a3 &
     (Following s).zx = a3 '&' a1 by A2,Th59;
    hence Following(s,2).GFA1CarryOutput(x,y,z) =
        (a1 '&' 'not' a2) 'or' ('not' a2 '&' a3) 'or' (a3 '&' a1)
          by A4,Th60;
    thus thesis by A2,A3,A4,Th59;
  end;

theorem Th62:
  for x,y,z being set st
     x <> [<*y,z*>,and2a] & y <> [<*z,x*>,and2] & z <> [<*x,y*>,and2c]
   for s being State of GFA1CarryCirc(x,y,z)
    holds Following(s,2) is stable
   proof
     set f1 = and2c, f2 = and2a, f3 = and2, f4 = or3;
     let x,y,z be set such that
A1:  x <> [<*y,z*>,f2] & y <> [<*z,x*>,f3] & z <> [<*x,y*>,f1];
     set xy = [<*x,y*>,f1], yz = [<*y,z*>,f2], zx = [<*z,x*>,f3];
     set xyz = [<*xy, yz, zx*>,f4];
     let s be State of GFA1CarryCirc(x,y,z);
     set S = GFA1CarryStr(x,y,z);
A2:  dom Following Following(s,2) = the carrier of S &
     dom Following(s,2) = the carrier of S by CIRCUIT1:4;
     reconsider xx = x, yy = y, zz = z as Vertex of S by Th55;
     set a1 = s.xx, a2 = s.yy, a3 = s.zz;
     set ffs = Following(s,2), fffs = Following ffs;
     a1 = s.x & a2 = s.y & a3 = s.z;
then A3: ffs.GFA1CarryOutput(x,y,z) =
         (a1 '&' 'not' a2) 'or' ('not' a2 '&' a3) 'or' (a3 '&' a1)  &
     ffs.xy = a1 '&' 'not' a2 &
     ffs.yz = 'not' a2 '&' a3 &
     ffs.zx = a1 '&' a3 by A1,Th61;
A4:  ffs = Following Following s by FACIRC_1:15;
A5:  x in InputVertices S & y in InputVertices S & z in InputVertices S
      by A1,Th57;
then (Following s).x = a1 & (Following s).y = a2 & (Following s).z = a3
      by CIRCUIT2:def 5;
then A6: ffs.x = a1 & ffs.y = a2 & ffs.z = a3 by A4,A5,CIRCUIT2:def 5;
     now let a be set; assume
A7:  a in the carrier of S;
then reconsider v = a as Vertex of S;
A8:  v in InputVertices S \/ InnerVertices S by A7,XBOOLE_1:45;
     thus ffs.a = (fffs).a
      proof per cases by A8,XBOOLE_0:def 2;
        suppose v in InputVertices S;
          hence thesis by CIRCUIT2:def 5;
        end;
        suppose v in InnerVertices S;
           then v in {xy, yz, zx} \/ {GFA1CarryOutput(x,y,z)} by Th50;
           then v in {xy, yz, zx} or
                v in {GFA1CarryOutput(x,y,z)} by XBOOLE_0:def 2;
           then v = xy or v = yz or v = zx or
                v = GFA1CarryOutput(x,y,z) by ENUMSET1:def 1,TARSKI:def 1;
          hence thesis by A3,A6,Th59,Th60;
        end;
      end;
     end;
    hence ffs = fffs by A2,FUNCT_1:9;
  end;

::=========================================================================

::-------------------------------------------------
:: GFA1 Adder : Circuit Definition of Adder Output
::-------------------------------------------------

definition
 let x,y,z be set;
 func GFA1AdderStr(x,y,z) ->
      unsplit gate`1=arity gate`2isBoolean
      non void strict non empty ManySortedSign equals
   2GatesCircStr(x,y,z, xor2c);
  coherence;
end;

definition
 let x,y,z be set;
 func GFA1AdderCirc(x,y,z) ->
      strict Boolean gate`2=den Circuit of GFA1AdderStr(x,y,z) equals
   2GatesCircuit(x,y,z, xor2c);
  coherence;
end;

definition
 let x,y,z be set;
 func GFA1AdderOutput(x,y,z) ->
      Element of InnerVertices GFA1AdderStr(x,y,z) equals
   2GatesCircOutput(x,y,z, xor2c);
  coherence;
end;

::-------------------------------------------------------
:: GFA1 Adder : Carrier, InnerVertices and InputVertices
::-------------------------------------------------------

::-------------------------------------------------------
:: InnerVertices

theorem Th63:
 for x,y,z being set holds
  InnerVertices GFA1AdderStr(x,y,z) =
    {[<*x,y*>,xor2c]} \/ {GFA1AdderOutput(x,y,z)}
   proof
     set f = xor2c;
     let x,y,z be set;
     set xy = [<*x,y*>,f];
     set S = GFA1AdderStr(x,y,z);
     thus InnerVertices S
       = {xy, GFA1AdderOutput(x,y,z)} by FACIRC_1:56
      .= {xy} \/ {GFA1AdderOutput(x,y,z)} by ENUMSET1:41;
   end;

theorem
 for x,y,z being set holds
  InnerVertices GFA1AdderStr(x,y,z) is Relation by FACIRC_1:58;

::-------------------------------------------------------
:: InputVertices

theorem
 for x,y,z being set st z <> [<*x,y*>,xor2c] holds
  InputVertices GFA1AdderStr(x,y,z) = {x,y,z} by FACIRC_1:57;

theorem
 for x,y,z being non pair set holds
  InputVertices GFA1AdderStr(x,y,z) is without_pairs by FACIRC_1:59;

::-------------------------------------------------------
:: Carrier and misc.

theorem
 for x,y,z being set holds
   x in the carrier of GFA1AdderStr(x,y,z) &
   y in the carrier of GFA1AdderStr(x,y,z) &
   z in the carrier of GFA1AdderStr(x,y,z) &
   [<*x,y*>,xor2c] in the carrier of GFA1AdderStr(x,y,z) &
   [<*[<*x,y*>,xor2c], z*>, xor2c] in the carrier of GFA1AdderStr(x,y,z)
   by FACIRC_1:60,61;

theorem Th68:
 for x,y,z being set holds
   [<*x,y*>,xor2c] in InnerVertices GFA1AdderStr(x,y,z) &
   GFA1AdderOutput(x,y,z) in InnerVertices GFA1AdderStr(x,y,z)
   proof
     set f = xor2c;
     let x,y,z be set;
     set S = GFA1AdderStr(x,y,z);
     InnerVertices S
       = {[<*x,y*>,f]} \/ {GFA1AdderOutput(x,y,z)} by Th63
      .= {[<*x,y*>,f],GFA1AdderOutput(x,y,z)} by ENUMSET1:41;
    hence thesis by TARSKI:def 2;
   end;

theorem Th69:
 for x,y,z being set st z <> [<*x,y*>, xor2c] holds
    x in InputVertices GFA1AdderStr(x,y,z) &
    y in InputVertices GFA1AdderStr(x,y,z) &
    z in InputVertices GFA1AdderStr(x,y,z)
   proof
     set f = xor2c;
     let x,y,z be set such that
A1:  z <> [<*x,y*>,f];
     set S = GFA1AdderStr(x,y,z);
     InputVertices S = {x,y,z} by A1,FACIRC_1:57;
     hence thesis by ENUMSET1:def 1;
   end;

theorem
 for x,y,z being non pair set holds
   InputVertices GFA1AdderStr(x,y,z) = {x,y,z} by FACIRC_1:57;

::----------------------------------------------------
:: GFA1 Adder : Stability of the Adder Output Circuit
::----------------------------------------------------

theorem Th71:
 for x,y,z being set st z <> [<*x,y*>, xor2c]
  for s being State of GFA1AdderCirc(x,y,z)
   for a1,a2,a3 being Element of BOOLEAN st a1 = s.x & a2 = s.y & a3 = s.z
     holds
      (Following s).[<*x,y*>,xor2c] = a1 'xor' 'not' a2 &
      (Following s).x = a1 & (Following s).y = a2 & (Following s).z = a3
   proof
     set f = xor2c;
     let x,y,z be set such that
A1:  z <> [<*x,y*>,f];
     set xy = [<*x,y*>,f];
     set A = GFA1AdderCirc(x,y,z);
     let s be State of A;
     let a1,a2,a3 be Element of BOOLEAN such that
A2:  a1 = s.x & a2 = s.y & a3 = s.z;
     (Following s).xy = f.<*a1, a2*> by A1,A2,Lm3;
     hence (Following s).xy = a1 'xor' 'not' a2 by Def4;
     thus (Following s).x = a1 & (Following s).y = a2 & (Following s).z = a3
       by A1,A2,Lm3;
   end;

theorem Th72:
 for x,y,z being set st z <> [<*x,y*>, xor2c]
  for s being State of GFA1AdderCirc(x,y,z)
   for a1a2,a1,a2,a3 being Element of BOOLEAN
     st a1a2 = s.[<*x,y*>,xor2c] & a1 = s.x & a2 = s.y & a3 = s.z
    holds
     (Following s).GFA1AdderOutput(x,y,z) = a1a2 'xor' 'not' a3
   proof
     set f = xor2c;
     let x,y,z be set such that
A1:  z <> [<*x,y*>,f];
     set xy = [<*x,y*>,f];
     set A = GFA1AdderCirc(x,y,z);
     let s be State of A;
     let a1a2,a1,a2,a3 be Element of BOOLEAN such that
A2:  a1a2 = s.xy & a1 = s.x & a2 = s.y & a3 = s.z;
     set C = GFA1AdderOutput(x,y,z);
     thus (Following s).GFA1AdderOutput(x,y,z)
         = f.<*s.xy, s.z*> by A1,Lm3
        .= a1a2 'xor' 'not' a3 by A2,Def4;
   end;

theorem Th73:
  for x,y,z being set st z <> [<*x,y*>, xor2c]
   for s being State of GFA1AdderCirc(x,y,z)
    for a1,a2,a3 being Element of BOOLEAN st a1 = s.x & a2 = s.y & a3 = s.z
     holds
      Following(s,2).GFA1AdderOutput(x,y,z)
             = a1 'xor' 'not' a2 'xor' 'not' a3 &
      Following(s,2).[<*x,y*>,xor2c] = a1 'xor' 'not' a2 &
      Following(s,2).x = a1 & Following(s,2).y = a2 & Following(s,2).z = a3
   proof
     set f = xor2c;
     let x,y,z be set such that
A1:  z <> [<*x,y*>,f];
     set xy = [<*x,y*>,f];
     set A = GFA1AdderCirc(x,y,z);
     let s be State of A;
     let a1,a2,a3 be Element of BOOLEAN such that
A2:  a1 = s.x & a2 = s.y & a3 = s.z;
     set C = GFA1AdderOutput(x,y,z);
     thus (Following(s,2)).GFA1AdderOutput(x,y,z)
         = f.<* f.<*a1, a2*>, a3*> by A1,A2,FACIRC_1:62
        .= f.<*a1 'xor' 'not' a2, a3*> by Def4
        .= a1 'xor' 'not' a2 'xor' 'not' a3 by Def4;
     (Following(s,2)).xy = f.<*a1, a2*> by A1,A2,FACIRC_1:62;
     hence (Following(s,2)).xy = a1 'xor' 'not' a2 by Def4;
     thus (Following(s,2)).x = a1 & (Following(s,2)).y = a2 &
          (Following(s,2)).z = a3 by A1,A2,FACIRC_1:62;
   end;

theorem Th74:
  for x,y,z being set st z <> [<*x,y*>, xor2c]
   for s being State of GFA1AdderCirc(x,y,z)
    for a1,a2,a3 being Element of BOOLEAN st a1 = s.x & a2 = s.y & a3 = s.z
     holds
      Following(s,2).GFA1AdderOutput(x,y,z)
         = 'not' (a1 'xor' 'not' a2 'xor' a3)
   proof
     set f = xor2c;
     let x,y,z be set such that
A1:  z <> [<*x,y*>,f];
     set xy = [<*x,y*>,f];
     set A = GFA1AdderCirc(x,y,z);
     let s be State of A;
     let a1,a2,a3 be Element of BOOLEAN such that
A2:  a1 = s.x & a2 = s.y & a3 = s.z;
     thus (Following(s,2)).GFA1AdderOutput(x,y,z)
         = a1 'xor' 'not' a2 'xor' 'not' a3 by A1,A2,Th73
        .= 'not' (a1 'xor' 'not' a2 'xor' a3) by XBOOLEAN:74;
   end;

theorem
 for x,y,z being set st z <> [<*x,y*>,xor2c]
  for s being State of GFA1AdderCirc(x,y,z)
    holds Following(s,2) is stable by FACIRC_1:63;

::=====================================================================

::---------------------------------------------------
:: GFA1 : Circuit Definition of GFA Combined Circuit
::---------------------------------------------------

definition
 let x,y,z be set;
 func BitGFA1Str(x,y,z) ->
      unsplit gate`1=arity gate`2isBoolean
      non void strict non empty ManySortedSign equals
    GFA1AdderStr(x,y,z) +* GFA1CarryStr(x,y,z);
  coherence;
end;

definition
  let x,y,z be set;
 func BitGFA1Circ(x,y,z) ->
   strict Boolean gate`2=den Circuit of BitGFA1Str(x,y,z) equals
   GFA1AdderCirc(x,y,z) +* GFA1CarryCirc(x,y,z);
  coherence;
end;

::----------------------------------------------------------
:: GFA1 Combined : Carrier, InnerVertices and InputVertices
::----------------------------------------------------------

::-------------------------------------------------------
:: InnerVertices

theorem Th76:
  for x,y,z being set holds
   InnerVertices BitGFA1Str(x,y,z) =
     {[<*x,y*>,xor2c]} \/ {GFA1AdderOutput(x,y,z)} \/
     {[<*x,y*>,and2c], [<*y,z*>,and2a], [<*z,x*>,and2]} \/
     {GFA1CarryOutput(x,y,z)}
   proof
     set f0 = xor2c;
     set f1 = and2c, f2 = and2a, f3 = and2;
     let x,y,z be set;
     set xyf0 = [<*x,y*>,f0];
     set xyf1 = [<*x,y*>,f1], yzf2 = [<*y,z*>,f2], zxf3 = [<*z,x*>,f3];
     set S = BitGFA1Str(x,y,z);
     set S1 = GFA1AdderStr(x,y,z);
     set S2 = GFA1CarryStr(x,y,z);
     set A1 = GFA1AdderOutput(x,y,z);
     set A2 = GFA1CarryOutput(x,y,z);
     thus InnerVertices S
       = (InnerVertices S1) \/ InnerVertices S2 by FACIRC_1:27
      .= {xyf0} \/ {A1} \/ InnerVertices S2 by Th63
      .= {xyf0} \/ {A1} \/ ({xyf1, yzf2, zxf3} \/ {A2}) by Th50
      .= {xyf0} \/ {A1} \/ {xyf1, yzf2, zxf3} \/ {A2} by XBOOLE_1:4;
   end;

theorem
  for x,y,z being set holds
    InnerVertices BitGFA1Str(x,y,z) is Relation
   proof
     let x,y,z be set;
     set S1 = GFA1AdderStr(x,y,z);
     set S2 = GFA1CarryStr(x,y,z);
     InnerVertices S1 is Relation & InnerVertices S2 is Relation
       by FACIRC_1:58,Th51;
     hence thesis by FACIRC_1:3;
  end;

::-------------------------------------------------------
:: InputVertices

theorem Th78:
  for x,y,z being set  st z <> [<*x,y*>,xor2c] &
    x <> [<*y,z*>,and2a] & y <> [<*z,x*>,and2] & z <> [<*x,y*>,and2c]
   holds
    InputVertices BitGFA1Str(x,y,z) = {x,y,z}
   proof
     set f0 = xor2c;
     set f1 = and2c, f2 = and2a, f3 = and2;
     let x,y,z be set such that
A1:  z <> [<*x,y*>,f0] and
A2:  x <> [<*y,z*>,f2] & y <> [<*z,x*>,f3] & z <> [<*x,y*>,f1];
     set S = BitGFA1Str(x,y,z);
     set S1 = GFA1AdderStr(x,y,z);
     set S2 = GFA1CarryStr(x,y,z);
A3:  InputVertices S1 = {x,y,z} by A1,FACIRC_1:57;
A4:  InputVertices S2 = {x,y,z} by A2,Th53;
     S1 tolerates S2 by CIRCCOMB:55;
    hence InputVertices S = {x,y,z} by A3,A4,FACIRC_2:22;
   end;

theorem Th79:
 for x,y,z being non pair set holds
    InputVertices BitGFA1Str(x,y,z) = {x,y,z}
   proof
     let x,y,z be non pair set;
     set S = BitGFA1Str(x,y,z);
     set S1 = GFA1AdderStr(x,y,z);
     set S2 = GFA1CarryStr(x,y,z);
A1:  InputVertices S1 is without_pairs & InnerVertices S1 is Relation
      by FACIRC_1:58,FACIRC_1:59;
A2:  InputVertices S2 is without_pairs & InnerVertices S2 is Relation
      by Th51,Th54;
     InputVertices S1 = {x,y,z} & InputVertices S2 = {x,y,z}
      by FACIRC_1:57,Th58;
    hence InputVertices S = {x,y,z} \/ {x,y,z} by A1,A2,FACIRC_1:7
                         .= {x,y,z};
  end;

theorem
 for x,y,z being non pair set holds
    InputVertices BitGFA1Str(x,y,z) is without_pairs
   proof
     let x,y,z be non pair set;
     InputVertices BitGFA1Str(x,y,z) = {x,y,z} by Th79;
     hence thesis;
   end;

::-------------------------------------------------------
:: Carrier and misc.

theorem
 for x,y,z being set holds
    x in the carrier of BitGFA1Str(x,y,z) &
    y in the carrier of BitGFA1Str(x,y,z) &
    z in the carrier of BitGFA1Str(x,y,z) &
    [<*x,y*>,xor2c] in the carrier of BitGFA1Str(x,y,z) &
    [<*[<*x,y*>,xor2c],z*>,xor2c] in the carrier of BitGFA1Str(x,y,z) &
    [<*x,y*>,and2c] in the carrier of BitGFA1Str(x,y,z) &
    [<*y,z*>,and2a] in the carrier of BitGFA1Str(x,y,z) &
    [<*z,x*>,and2]  in the carrier of BitGFA1Str(x,y,z) &
    [<*[<*x,y*>,and2c],[<*y,z*>,and2a],[<*z,x*>,and2]*>,or3]
                                in the carrier of BitGFA1Str(x,y,z)
   proof
     set f0 = xor2c;
     set f1 = and2c, f2 = and2a, f3 = and2, f4 = or3;
     let x,y,z be set;
     set xy = [<*x,y*>,f1], yz = [<*y,z*>,f2], zx = [<*z,x*>,f3];
     set xyz = [<*xy, yz, zx*>,f4];
     set S1 = GFA1AdderStr(x,y,z);
     set S2 = GFA1CarryStr(x,y,z);
A1:  x in the carrier of S1 & y in the carrier of S1 &
     z in the carrier of S1 &
     [<*x,y*>,f0] in the carrier of S1 &
     [<*[<*x,y*>,f0],z*>,f0] in the carrier of S1 by FACIRC_1:60,61;
     xy in the carrier of S2 & yz in the carrier of S2 &
     zx in the carrier of S2 &
     xyz in the carrier of S2 by Th55;
    hence thesis by A1,FACIRC_1:20;
  end;

theorem Th82:
  for x,y,z being set holds
    [<*x,y*>,xor2c] in InnerVertices BitGFA1Str(x,y,z) &
    GFA1AdderOutput(x,y,z) in InnerVertices BitGFA1Str(x,y,z) &
    [<*x,y*>,and2c] in InnerVertices BitGFA1Str(x,y,z) &
    [<*y,z*>,and2a] in InnerVertices BitGFA1Str(x,y,z) &
    [<*z,x*>,and2] in InnerVertices BitGFA1Str(x,y,z) &
    GFA1CarryOutput(x,y,z) in InnerVertices BitGFA1Str(x,y,z)
   proof
     set f0 = xor2c;
     set f1 = and2c, f2 = and2a, f3 = and2;
     let x,y,z be set;
     set xyf0 = [<*x,y*>,f0];
     set xyf1 = [<*x,y*>,f1], yzf2 = [<*y,z*>,f2], zxf3 = [<*z,x*>,f3];
     set S = BitGFA1Str(x,y,z);
     set A1 = GFA1AdderOutput(x,y,z);
     set A2 = GFA1CarryOutput(x,y,z);
     InnerVertices S
       = {xyf0} \/ {A1} \/ {xyf1,yzf2,zxf3} \/ {A2} by Th76
      .= {xyf0,A1} \/ {xyf1,yzf2,zxf3} \/ {A2} by ENUMSET1:41
      .= {xyf0,A1,xyf1,yzf2,zxf3} \/ {A2} by ENUMSET1:48
      .= {xyf0,A1,xyf1,yzf2,zxf3,A2} by ENUMSET1:55;
     hence thesis by ENUMSET1:def 4;
   end;

theorem
  for x,y,z being set  st z <> [<*x,y*>,xor2c] &
    x <> [<*y,z*>,and2a] & y <> [<*z,x*>,and2] & z <> [<*x,y*>,and2c]
   holds
    x in InputVertices BitGFA1Str(x,y,z) &
    y in InputVertices BitGFA1Str(x,y,z) &
    z in InputVertices BitGFA1Str(x,y,z)
   proof
     set f0 = xor2c;
     set f1 = and2c, f2 = and2a, f3 = and2;
     let x,y,z be set such that
A1:  z <> [<*x,y*>,f0] &
     x <> [<*y,z*>,f2] & y <> [<*z,x*>,f3] & z <> [<*x,y*>,f1];
     set S = BitGFA1Str(x,y,z);
     InputVertices S = {x,y,z} by A1,Th78;
    hence thesis by ENUMSET1:def 1;
   end;

::------------------------------------------------------------------
:: GFA1 : Carry and Adder Output Definition of GFA Combined Circuit
::------------------------------------------------------------------

definition
 let x,y,z be set;
 func BitGFA1CarryOutput(x,y,z) ->
         Element of InnerVertices BitGFA1Str(x,y,z) equals
    [<*[<*x,y*>,and2c],[<*y,z*>,and2a],[<*z,x*>,and2]*>,or3];
  coherence
    proof
      GFA1CarryOutput(x,y,z)
        in InnerVertices BitGFA1Str(x,y,z) by Th82;
      hence thesis;
    end;
end;

definition
 let x,y,z be set;
 func BitGFA1AdderOutput(x,y,z) ->
         Element of InnerVertices BitGFA1Str(x,y,z) equals
    2GatesCircOutput(x,y,z, xor2c);
  coherence
    proof
      GFA1AdderOutput(x,y,z)
        in InnerVertices BitGFA1Str(x,y,z) by Th82;
      hence thesis;
    end;
end;

::-------------------------------------------------------------
:: GFA1 Combined : Stability of the Adder/Carry Output Circuit
::-------------------------------------------------------------

theorem
  for x,y,z being set  st z <> [<*x,y*>,xor2c] &
    x <> [<*y,z*>,and2a] & y <> [<*z,x*>,and2] & z <> [<*x,y*>,and2c]
   for s being State of BitGFA1Circ(x,y,z)
    for a1,a2,a3 being Element of BOOLEAN st a1 = s.x & a2 = s.y & a3 = s.z
     holds
      Following(s,2).GFA1AdderOutput(x,y,z)
           = 'not' (a1 'xor' 'not' a2 'xor' a3) &
      Following(s,2).GFA1CarryOutput(x,y,z)
           = (a1 '&' 'not' a2) 'or' ('not' a2 '&' a3) 'or' (a3 '&' a1)
   proof
     set f0 = xor2c;
     set f1 = and2c, f2 = and2a, f3 = and2;
     let x,y,z be set such that
A1:  z <> [<*x,y*>,f0] &
     x <> [<*y,z*>,f2] & y <> [<*z,x*>,f3] & z <> [<*x,y*>,f1];
     set S = BitGFA1Str(x,y,z);
     set S1 = GFA1AdderStr(x,y,z);
     set S2 = GFA1CarryStr(x,y,z);
     set A = BitGFA1Circ(x,y,z);
     set A1 = GFA1AdderCirc(x,y,z);
     set A2 = GFA1CarryCirc(x,y,z);
     let s be State of A;
     let a1,a2,a3 be Element of BOOLEAN; assume
A2:  a1 = s.x & a2 = s.y & a3 = s.z;
A3:  x in the carrier of S1 & y in the carrier of S1 & z in the carrier of S1
     by FACIRC_1:60;
A4:  x in the carrier of S2 & y in the carrier of S2 & z in the carrier of S2
     by Th55;
     reconsider s1 = s|the carrier of S1 as State of A1 by FACIRC_1:26;
     reconsider s2 = s|the carrier of S2 as State of A2 by FACIRC_1:26;
     reconsider t = s as State of A1+*A2;
     InputVertices S1 = {x,y,z} by A1,FACIRC_1:57;
then A5: InputVertices S1 = InputVertices S2 by A1,Th53;
A6:  InnerVertices S1 misses InputVertices S1 &
     InnerVertices S2 misses InputVertices S2 by XBOOLE_1:79;
     dom s1 = the carrier of S1 by CIRCUIT1:4;
then a1 = s1.x & a2 = s1.y & a3 = s1.z by A2,A3,FUNCT_1:70;
then Following(t,2).GFA1AdderOutput(x,y,z)
        = Following(s1,2).GFA1AdderOutput(x,y,z) &
     Following(s1,2).GFA1AdderOutput(x,y,z)
        = 'not' (a1 'xor' 'not' a2 'xor' a3)
       by A1,A5,A6,Th74,FACIRC_1:32;
    hence
     Following(s,2).GFA1AdderOutput(x,y,z)
        = 'not' (a1 'xor' 'not' a2 'xor' a3);
     dom s2 = the carrier of S2 by CIRCUIT1:4;
then a1 = s2.x & a2 = s2.y & a3 = s2.z by A2,A4,FUNCT_1:70;
then Following(t,2).GFA1CarryOutput(x,y,z)
        = Following(s2,2).GFA1CarryOutput(x,y,z) &
     Following(s2,2).GFA1CarryOutput(x,y,z)
        = (a1 '&' 'not' a2) 'or' ('not' a2 '&' a3) 'or' (a3 '&' a1)
       by A1,A5,A6,Th61,FACIRC_1:33;
     hence Following(s,2).GFA1CarryOutput(x,y,z)
        = (a1 '&' 'not' a2) 'or' ('not' a2 '&' a3) 'or' (a3 '&' a1);
   end;

theorem
 for x,y,z being set  st z <> [<*x,y*>,xor2c] &
   x <> [<*y,z*>,and2a] & y <> [<*z,x*>,and2] & z <> [<*x,y*>,and2c]
   for s being State of BitGFA1Circ(x,y,z)
    holds Following(s,2) is stable
   proof
     set f0 = xor2c;
     set f1 = and2c, f2 = and2a, f3 = and2;
     let x,y,z be set such that
A1:  z <> [<*x,y*>,f0] &
     x <> [<*y,z*>,f2] & y <> [<*z,x*>,f3] & z <> [<*x,y*>,f1];
     set S = BitGFA1Str(x,y,z);
     set S1 = GFA1AdderStr(x,y,z);
     set S2 = GFA1CarryStr(x,y,z);
     set A = BitGFA1Circ(x,y,z);
     set A1 = GFA1AdderCirc(x,y,z);
     set A2 = GFA1CarryCirc(x,y,z);
     let s be State of A;
     reconsider s1 = s|the carrier of S1 as State of A1 by FACIRC_1:26;
     reconsider s2 = s|the carrier of S2 as State of A2 by FACIRC_1:26;
     reconsider t = s as State of A1+*A2;
     InputVertices S1 = {x,y,z} by A1,FACIRC_1:57;
then A2: InputVertices S1 = InputVertices S2 by A1,Th53;
     InnerVertices S1 misses InputVertices S1 &
     InnerVertices S2 misses InputVertices S2 by XBOOLE_1:79;
then A3: Following(s1,2) = Following(t,2)|the carrier of S1 &
         Following(s1,3) = Following(t,3)|the carrier of S1 &
         Following(s2,2) = Following(t,2)|the carrier of S2 &
         Following(s2,3) = Following(t,3)|the carrier of S2
          by A2,FACIRC_1:30,31;
     Following(s1,2) is stable by A1,FACIRC_1:63;
then A4: Following(s1,2)
       = Following Following(s1,2) by CIRCUIT2:def 6
      .= Following(s1,2+1) by FACIRC_1:12;
     Following(s2,2) is stable by A1,Th62;
then A5: Following(s2,2)
       = Following Following(s2,2) by CIRCUIT2:def 6
      .= Following(s2,2+1) by FACIRC_1:12;
A6:  Following(s,2+1) = Following Following(s,2) by FACIRC_1:12;
A7:  dom Following(s,2) = the carrier of S &
     dom Following(s,3) = the carrier of S &
     dom Following(s1,2) = the carrier of S1 &
     dom Following(s2,2) = the carrier of S2 by CIRCUIT1:4;
     A8: the carrier of S = (the carrier of S1) \/ the carrier of S2
      by CIRCCOMB:def 2;
       now let a be set; assume a in the carrier of S;
       then a in the carrier of S1 or a in the carrier of S2
              by A8,XBOOLE_0:def 2;
       then (Following(s,2)).a = (Following(s1,2)).a &
            (Following(s,3)).a = (Following(s1,3)).a or
            (Following(s,2)).a = (Following(s2,2)).a &
            (Following(s,3)).a = (Following(s2,3)).a
              by A3,A4,A5,A7,FUNCT_1:70;
       hence (Following(s,2)).a = (Following Following(s,2)).a
              by A4,A5,FACIRC_1:12;
       end;
    hence Following(s,2) = Following Following(s,2) by A6,A7,FUNCT_1:9;
   end;

::========================================================================

begin :: Generalized Full Adder (GFA) Circuit (TYPE-2)

::========================================================================
:: << GFA TYPE-2 >>
::------------------------------------------------------------------------
::   Name     : Generalized Full Adder Type-2 (GFA2)
::   Function : - x + y - z = - 2 * c + s
::
::   Logic Symbol :     -x      y      Combined : GFA2CarryIStr(x,y,z)
::                       |     /                  GFA2CarryStr(x,y,z)
::                       |    /                   GFA2AdderStr(x,y,z)
::                   +---O---*                  --->
::                   |  GFA  O---- -z             BitGFA2Str(x,y,z)
::                   | TYPE2 |
::                   O---*---+          Outputs : BitGFA2CarryOutput(x,y,z)
::                  /    |                        BitGFA2AdderOutput(x,y,z)
::                 /     |
::               -c      s          Calculation : Following(s,2) is stable.
::=========================================================================

::-------------------------------------------------
:: GFA2 Carry : Circuit Definition of Carry Output
::-------------------------------------------------

definition
 let x,y,z be set;
 func GFA2CarryIStr(x,y,z) ->
    unsplit gate`1=arity gate`2isBoolean
    non void strict non empty ManySortedSign equals
    1GateCircStr(<*x,y*>,and2a) +* 1GateCircStr(<*y,z*>,and2c) +*
    1GateCircStr(<*z,x*>,and2b);
  coherence;
end;

definition
 let x,y,z be set;
 func GFA2CarryICirc(x,y,z) ->
      strict Boolean gate`2=den Circuit of GFA2CarryIStr(x,y,z) equals
    1GateCircuit(x,y,and2a) +* 1GateCircuit(y,z,and2c) +*
    1GateCircuit(z,x,and2b);
  coherence;
end;

definition
 let x,y,z be set;
 func GFA2CarryStr(x,y,z) ->
    unsplit gate`1=arity gate`2isBoolean
    non void strict non empty ManySortedSign equals
    GFA2CarryIStr(x,y,z) +*
    1GateCircStr(<*[<*x,y*>,and2a], [<*y,z*>,and2c], [<*z,x*>,and2b]*>,nor3);
  coherence;
end;

definition
 let x,y,z be set;
 func GFA2CarryCirc(x,y,z) ->
      strict Boolean gate`2=den Circuit of GFA2CarryStr(x,y,z) equals
    GFA2CarryICirc(x,y,z) +*
    1GateCircuit([<*x,y*>,and2a],[<*y,z*>,and2c],[<*z,x*>,and2b],nor3);
  coherence;
end;

definition
 let x,y,z be set;
 func GFA2CarryOutput(x,y,z) -> Element of InnerVertices GFA2CarryStr(x,y,z)
  equals
   [<*[<*x,y*>,and2a],[<*y,z*>,and2c],[<*z,x*>,and2b]*>,nor3];
  coherence
   proof
     [<*[<*x,y*>,and2a],[<*y,z*>,and2c],[<*z,x*>,and2b]*>,nor3] in
      InnerVertices
       1GateCircStr(<*[<*x,y*>,and2a],[<*y,z*>,and2c], [<*z,x*>,and2b]*>,nor3)
       by FACIRC_1:47;
    hence thesis by FACIRC_1:21;
   end;
end;

::-------------------------------------------------------
:: GFA2 Carry : Carrier, InnerVertices and InputVertices
::-------------------------------------------------------

::-------------------------------------------------------
:: InnerVertices

theorem Th86:
  for x,y,z being set holds
  InnerVertices GFA2CarryIStr(x,y,z) =
   {[<*x,y*>,and2a], [<*y,z*>,and2c], [<*z,x*>,and2b]}
   proof
     set f1 = and2a, f2 = and2c, f3 = and2b;
     let x,y,z be set;
     set xy = [<*x,y*>,f1], yz = [<*y,z*>,f2], zx = [<*z,x*>,f3];
     set Cxy = 1GateCircStr(<*x,y*>,f1);
     set Cyz = 1GateCircStr(<*y,z*>,f2);
     set Czx = 1GateCircStr(<*z,x*>,f3);
A1:  Cxy +* Cyz tolerates Czx by CIRCCOMB:55;
A2:  Cxy tolerates Cyz by CIRCCOMB:55;
     InnerVertices GFA2CarryIStr(x,y,z)
       = InnerVertices(Cxy +* Cyz) \/ InnerVertices(Czx) by A1,CIRCCOMB:15
      .= InnerVertices(Cxy) \/ InnerVertices(Cyz) \/
         InnerVertices(Czx) by A2,CIRCCOMB:15
      .= {xy} \/ InnerVertices(Cyz) \/ InnerVertices(Czx) by CIRCCOMB:49
      .= {xy} \/ {yz} \/ InnerVertices(Czx) by CIRCCOMB:49
      .= {xy} \/ {yz} \/ {zx} by CIRCCOMB:49
      .= {xy, yz} \/ {zx} by ENUMSET1:41
      .= {xy, yz, zx} by ENUMSET1:43;
    hence thesis;
   end;

theorem Th87:
  for x,y,z being set holds
  InnerVertices GFA2CarryStr(x,y,z) =
    {[<*x,y*>,and2a], [<*y,z*>,and2c], [<*z,x*>,and2b]} \/
    {GFA2CarryOutput(x,y,z)}
   proof
     set f1 = and2a, f2 = and2c, f3 = and2b, f4 = nor3;
     let x,y,z be set;
     set xy = [<*x,y*>,f1], yz = [<*y,z*>,f2], zx = [<*z,x*>,f3];
     set xyz = [<*xy, yz, zx*>,f4];
     set Cxy = 1GateCircStr(<*x,y*>,f1);
     set Cyz = 1GateCircStr(<*y,z*>,f2);
     set Czx = 1GateCircStr(<*z,x*>,f3);
     set Cxyz = 1GateCircStr(<*xy, yz, zx*>,f4);
A1:  Cxy tolerates (Cyz +* Czx +* Cxyz) by CIRCCOMB:55;
A2:  Cyz tolerates (Czx +* Cxyz) by CIRCCOMB:55;
A3:  Czx tolerates Cxyz by CIRCCOMB:55;
A4:  InnerVertices (Cyz +* (Czx +* Cxyz))
      = InnerVertices Cyz \/ InnerVertices (Czx +* Cxyz) by A2,CIRCCOMB:15;
A5:  InnerVertices (Czx +* Cxyz)
      = InnerVertices Czx \/ InnerVertices Cxyz by A3,CIRCCOMB:15;
thus InnerVertices GFA2CarryStr(x,y,z)
      = InnerVertices (Cxy +* (Cyz +* Czx) +* Cxyz) by CIRCCOMB:10
     .= InnerVertices (Cxy +* (Cyz +* Czx +* Cxyz)) by CIRCCOMB:10
     .= InnerVertices Cxy \/ InnerVertices (Cyz +* Czx +* Cxyz)
          by A1,CIRCCOMB:15
     .= InnerVertices Cxy \/ InnerVertices (Cyz +* (Czx +* Cxyz))
          by CIRCCOMB:10
     .= InnerVertices Cxy \/ InnerVertices Cyz \/
          (InnerVertices Czx \/ InnerVertices Cxyz) by A4,A5,XBOOLE_1:4
     .= InnerVertices Cxy \/ InnerVertices Cyz \/
           InnerVertices Czx \/ InnerVertices Cxyz by XBOOLE_1:4
     .= {xy} \/ InnerVertices Cyz \/
           InnerVertices Czx \/ InnerVertices Cxyz by CIRCCOMB:49
     .= {xy} \/ {yz} \/ InnerVertices Czx \/ InnerVertices Cxyz by CIRCCOMB:49
     .= {xy} \/ {yz} \/ {zx} \/ InnerVertices Cxyz by CIRCCOMB:49
     .= {xy, yz} \/ {zx} \/ InnerVertices Cxyz by ENUMSET1:41
     .= {xy, yz, zx} \/ InnerVertices Cxyz by ENUMSET1:43
     .= {xy, yz, zx} \/ {GFA2CarryOutput(x,y,z)} by CIRCCOMB:49;
  end;

theorem Th88:
  for x,y,z being set holds
  InnerVertices GFA2CarryStr(x,y,z) is Relation
   proof
     set f1 = and2a, f2 = and2c, f3 = and2b, f4 = nor3;
     let x,y,z be set;
     set xy = [<*x,y*>,f1], yz = [<*y,z*>,f2], zx = [<*z,x*>,f3];
     set Cxy = 1GateCircStr(<*x,y*>,f1);
     set Cyz = 1GateCircStr(<*y,z*>,f2);
     set Czx = 1GateCircStr(<*z,x*>,f3);
     set Cxyz = 1GateCircStr(<*xy, yz, zx*>,f4);
A1:  InnerVertices Cxy is Relation & InnerVertices Cyz is Relation &
     InnerVertices Czx is Relation by FACIRC_1:38;
then InnerVertices (Cxy +* Cyz) is Relation by FACIRC_1:3;
then InnerVertices Cxyz is Relation &
     InnerVertices GFA2CarryIStr(x,y,z) is Relation by A1,FACIRC_1:3,38;
    hence thesis by FACIRC_1:3;
   end;

::-------------------------------------------------------
:: InputVertices

theorem Th89:
 for x,y,z being set st
   x <> [<*y,z*>,and2c] & y <> [<*z,x*>,and2b] & z <> [<*x,y*>,and2a]
  holds InputVertices GFA2CarryIStr(x,y,z) = {x,y,z}
   proof
     set f1 = and2a, f2 = and2c, f3 = and2b;
     let x,y,z be set;
     set xy = [<*x,y*>,f1], yz = [<*y,z*>,f2], zx = [<*z,x*>,f3];
     set Cxy = 1GateCircStr(<*x,y*>,f1);
     set Cyz = 1GateCircStr(<*y,z*>,f2);
     set Czx = 1GateCircStr(<*z,x*>,f3);
     assume
A1:  x <> yz & y <> zx & z <> xy;
A2:  Cxy +* Cyz tolerates Czx by CIRCCOMB:55;
A3:  Cxy tolerates Cyz by CIRCCOMB:55;
A4:  y <> yz by FACIRC_2:3;
A5:  not xy in {y,z} by A1,Lm1;
A6:  not z in {xy, yz} & not x in {xy, yz} by A1,Lm1;
A7:  not zx in {x,y,z} by A1,Lm1;
     InputVertices GFA2CarryIStr(x,y,z)
      = (InputVertices(Cxy +* Cyz) \ InnerVertices(Czx)) \/
        (InputVertices(Czx) \ InnerVertices(Cxy +* Cyz)) by A2,CIRCCMB2:6
     .= ((InputVertices(Cxy) \ InnerVertices(Cyz)) \/
         (InputVertices(Cyz) \ InnerVertices(Cxy))) \ InnerVertices(Czx) \/
         (InputVertices(Czx) \ InnerVertices(Cxy +* Cyz)) by A3,CIRCCMB2:6
     .= ((InputVertices(Cxy) \ InnerVertices(Cyz)) \/
         (InputVertices(Cyz) \ InnerVertices(Cxy))) \ InnerVertices(Czx) \/
         (InputVertices(Czx) \ (InnerVertices(Cxy) \/ InnerVertices(Cyz)))
          by A3,CIRCCOMB:15
     .= ((InputVertices(Cxy) \ {yz}) \/
         (InputVertices(Cyz) \ InnerVertices(Cxy))) \ InnerVertices(Czx) \/
         (InputVertices(Czx) \ (InnerVertices(Cxy) \/ InnerVertices(Cyz)))
          by CIRCCOMB:49
     .= ((InputVertices(Cxy) \ {yz}) \/
         (InputVertices(Cyz) \ {xy})) \ InnerVertices(Czx) \/
         (InputVertices(Czx) \ (InnerVertices(Cxy) \/ InnerVertices(Cyz)))
          by CIRCCOMB:49
     .= ((InputVertices(Cxy) \ {yz}) \/
         (InputVertices(Cyz) \ {xy})) \ {zx} \/
         (InputVertices(Czx) \ (InnerVertices(Cxy) \/ InnerVertices(Cyz)))
          by CIRCCOMB:49
     .= ((InputVertices(Cxy) \ {yz}) \/
         (InputVertices(Cyz) \ {xy})) \ {zx} \/
         (InputVertices(Czx) \ ({xy} \/ InnerVertices(Cyz))) by CIRCCOMB:49
     .= ((InputVertices(Cxy) \ {yz}) \/
         (InputVertices(Cyz) \ {xy})) \ {zx} \/
         (InputVertices(Czx) \ ({xy} \/ {yz})) by CIRCCOMB:49
     .= (({x,y} \ {yz}) \/ (InputVertices(Cyz) \ {xy})) \ {zx} \/
         (InputVertices(Czx) \ ({xy} \/ {yz})) by FACIRC_1:40
     .= (({x,y} \ {yz}) \/ ({y,z} \ {xy})) \ {zx} \/
         (InputVertices(Czx) \ ({xy} \/ {yz})) by FACIRC_1:40
     .= (({x,y} \ {yz}) \/ ({y,z} \ {xy})) \ {zx} \/
         ({z,x} \ ({xy} \/ {yz})) by FACIRC_1:40
     .= (({x,y} \ {yz}) \/ ({y,z} \ {xy})) \ {zx} \/
         ({z,x} \ {xy,yz}) by ENUMSET1:41
     .= (({x,y} \/ ({y,z} \ {xy})) \ {zx}) \/ ({z,x} \ {xy,yz})
          by A1,A4,FACIRC_2:1
     .= ({x,y} \/ {y,z}) \ {zx} \/ ({z,x} \ {xy,yz}) by A5,ZFMISC_1:65
     .= ({x,y} \/ {y,z}) \ {zx} \/ {z,x} by A6,ZFMISC_1:72
     .= {x,y,y,z} \ {zx} \/ {z,x} by ENUMSET1:45
     .= {y,y,x,z} \ {zx} \/ {z,x} by ENUMSET1:110
     .= {y,x,z} \ {zx} \/ {z,x} by ENUMSET1:71
     .= {x,y,z} \ {zx} \/ {z,x} by ENUMSET1:99
     .= {x,y,z} \/ {z,x} by A7,ZFMISC_1:65
     .= {x,y,z,z,x} by ENUMSET1:49
     .= {x,y,z,z} \/ {x} by ENUMSET1:50
     .= {z,z,x,y} \/ {x} by ENUMSET1:118
     .= {z,x,y} \/ {x} by ENUMSET1:71
     .= {z,x,y,x} by ENUMSET1:46
     .= {x,x,y,z} by ENUMSET1:113
     .= {x,y,z} by ENUMSET1:71;
    hence thesis;
   end;

theorem Th90:
 for x,y,z being set st
   x <> [<*y,z*>,and2c] & y <> [<*z,x*>,and2b] & z <> [<*x,y*>,and2a]
  holds InputVertices GFA2CarryStr(x,y,z) = {x,y,z}
   proof
     set f1 = and2a, f2 = and2c, f3 = and2b, f4 = nor3;
     let x,y,z be set;
     set xy = [<*x,y*>,f1], yz = [<*y,z*>,f2], zx = [<*z,x*>,f3];
     set xyz = [<*xy, yz, zx*>,f4];
     set S = 1GateCircStr(<*xy, yz, zx*>,f4);
     set MI = GFA2CarryIStr(x,y,z);
A1:  InnerVertices S = {xyz} by CIRCCOMB:49;
A2:  InputVertices S = rng <*xy, yz, zx*> by CIRCCOMB:49
                    .= {xy, yz, zx} by FINSEQ_2:148;
     assume
A3:  x <> yz & y <> zx & z <> xy;
A4:  {x, y, z} \ {xyz} = {x, y, z} by Lm2;
A5:  {xy, yz, zx} \ {xy, yz, zx} = {} by XBOOLE_1:37;
     GFA2CarryStr(x,y,z) = MI +* S & MI tolerates S by CIRCCOMB:55;
     hence InputVertices GFA2CarryStr(x,y,z)
      = ((InputVertices MI) \ InnerVertices S) \/
         ((InputVertices S) \ InnerVertices MI) by CIRCCMB2:6
     .= {x,y,z} \/ ({xy, yz, zx} \ InnerVertices MI) by A1,A2,A3,A4,Th89
     .= {x,y,z} \/ {} by A5,Th86
     .= {x,y,z};
  end;

theorem Th91:
 for x,y,z being non pair set holds
  InputVertices GFA2CarryStr(x,y,z) is without_pairs
   proof
     set f1 = and2a, f2 = and2c, f3 = and2b, f4 = nor3;
     let x,y,z be non pair set;
     set xy = [<*x,y*>,f1], yz = [<*y,z*>,f2], zx = [<*z,x*>,f3];
     set Cxy = 1GateCircStr(<*x,y*>,f1);
     set Cyz = 1GateCircStr(<*y,z*>,f2);
     set Czx = 1GateCircStr(<*z,x*>,f3);
     set S = 1GateCircStr(<*xy, yz, zx*>,f4);
     set M = GFA2CarryStr(x,y,z);
     set MI = GFA2CarryIStr(x,y,z);
A1:  InputVertices Cxy is without_pairs & InputVertices Cyz is without_pairs &
     InputVertices Czx is without_pairs by FACIRC_1:41;
then InputVertices (Cxy+*Cyz) is without_pairs by FACIRC_1:9;
then A2: InputVertices MI is without_pairs by A1,FACIRC_1:9;
     InnerVertices S is Relation by FACIRC_1:38;
then A3: InputVertices M = (InputVertices MI) \/
          (InputVertices S \ InnerVertices MI) by A2,FACIRC_1:6;
     given xx being pair set such that
A4:  xx in InputVertices M;
A5:  InputVertices S = {xy, yz, zx} by FACIRC_1:42;
A6:  InnerVertices Cxy = {xy} & InnerVertices Cyz = {yz} &
     InnerVertices Czx = {zx} by CIRCCOMB:49;
     Cxy tolerates Cyz & Cxy tolerates Czx & Cyz tolerates Czx by CIRCCOMB:55;
then A7: InnerVertices (Cxy +* Cyz) = {xy} \/ {yz} by A6,CIRCCOMB:15;
     Cxy +* Cyz tolerates Czx by CIRCCOMB:55;
then InnerVertices MI = {xy} \/ {yz} \/ {zx} by A6,A7,CIRCCOMB:15
     .= {xy, yz} \/ {zx} by ENUMSET1:41
     .= {xy, yz, zx} by ENUMSET1:43;
then InputVertices S \ InnerVertices MI = {} by A5,XBOOLE_1:37;
    hence thesis by A2,A3,A4,FACIRC_1:def 2;
  end;

::-------------------------------------------------------
:: Carrier and misc.

theorem Th92:
  for x,y,z being set holds
    x in the carrier of GFA2CarryStr(x,y,z) &
    y in the carrier of GFA2CarryStr(x,y,z) &
    z in the carrier of GFA2CarryStr(x,y,z) &
    [<*x,y*>,and2a] in the carrier of GFA2CarryStr(x,y,z) &
    [<*y,z*>,and2c] in the carrier of GFA2CarryStr(x,y,z) &
    [<*z,x*>,and2b] in the carrier of GFA2CarryStr(x,y,z) &
    [<*[<*x,y*>,and2a],[<*y,z*>,and2c],[<*z,x*>,and2b]*>,nor3]
                   in the carrier of GFA2CarryStr(x,y,z)
   proof
     set f1 = and2a, f2 = and2c, f3 = and2b, f4 = nor3;
     let x,y,z be set;
     set xy = [<*x,y*>,f1], yz = [<*y,z*>,f2], zx = [<*z,x*>,f3];
     set xyz = [<*xy, yz, zx*>,f4];
     set Cxy = 1GateCircStr(<*x,y*>,f1);
     set Cyz = 1GateCircStr(<*y,z*>,f2);
     set Czx = 1GateCircStr(<*z,x*>,f3);
     set Cxyz = 1GateCircStr(<*xy, yz, zx*>,f4);
     y in the carrier of Cxy by FACIRC_1:43;
then A1: y in the carrier of Cxy +* Cyz by FACIRC_1:20;
     x in the carrier of Czx & z in the carrier of Czx by FACIRC_1:43;
then A2: x in the carrier of GFA2CarryIStr(x,y,z) &
         y in the carrier of GFA2CarryIStr(x,y,z) &
         z in the carrier of GFA2CarryIStr(x,y,z) by A1,FACIRC_1:20;
     xy in the carrier of Cxy & yz in the carrier of Cyz by FACIRC_1:43;
then A3: xy in the carrier of Cxy +* Cyz & yz in the carrier of Cxy +* Cyz
       by FACIRC_1:20;
     zx in the carrier of Czx by FACIRC_1:43;
then A4: xy in the carrier of GFA2CarryIStr(x,y,z) &
         yz in the carrier of GFA2CarryIStr(x,y,z) &
         zx in the carrier of GFA2CarryIStr(x,y,z) by A3,FACIRC_1:20;
     set p = <*xy,yz,zx*>;
     the carrier of Cxyz = rng p \/ {xyz} & [p,f4] in {[p,f4]}
       by CIRCCOMB:def 6,TARSKI:def 1;
then xyz in the carrier of Cxyz by XBOOLE_0:def 2;
    hence thesis by A2,A4,FACIRC_1:20;
  end;

theorem Th93:
 for x,y,z being set holds
   [<*x,y*>,and2a] in InnerVertices GFA2CarryStr(x,y,z) &
   [<*y,z*>,and2c] in InnerVertices GFA2CarryStr(x,y,z) &
   [<*z,x*>,and2b] in InnerVertices GFA2CarryStr(x,y,z) &
   GFA2CarryOutput(x,y,z) in InnerVertices GFA2CarryStr(x,y,z)
   proof
     set f1 = and2a, f2 = and2c, f3 = and2b;
     let x,y,z be set;
     set xy = [<*x,y*>,f1], yz = [<*y,z*>,f2], zx = [<*z,x*>,f3];
     InnerVertices GFA2CarryStr(x,y,z)
       = {xy,yz,zx} \/ {GFA2CarryOutput(x,y,z)} by Th87
      .= {xy,yz,zx,GFA2CarryOutput(x,y,z)} by ENUMSET1:46;
    hence thesis by ENUMSET1:def 2;
  end;

theorem Th94:
  for x,y,z being set st
     x <> [<*y,z*>,and2c] & y <> [<*z,x*>,and2b] & z <> [<*x,y*>,and2a]
   holds
    x in InputVertices GFA2CarryStr(x,y,z) &
    y in InputVertices GFA2CarryStr(x,y,z) &
    z in InputVertices GFA2CarryStr(x,y,z)
   proof
     set f1 = and2a, f2 = and2c, f3 = and2b;
     let x,y,z be set such that
A1:  x <> [<*y,z*>,f2] & y <> [<*z,x*>,f3] & z <> [<*x,y*>,f1];
     InputVertices GFA2CarryStr(x,y,z) = {x,y,z} by A1,Th90;
    hence thesis by ENUMSET1:def 1;
  end;

theorem Th95:
 for x,y,z being non pair set holds
  InputVertices GFA2CarryStr(x,y,z) = {x,y,z}
   proof
     set f1 = and2a, f2 = and2c, f3 = and2b, f4 = nor3;
     let x,y,z be non pair set;
     set xy = [<*x,y*>,f1], yz = [<*y,z*>,f2], zx = [<*z,x*>,f3];
     set Cxy = 1GateCircStr(<*x,y*>,f1);
     set Cyz = 1GateCircStr(<*y,z*>,f2);
     set Czx = 1GateCircStr(<*z,x*>,f3);
     set M = GFA2CarryStr(x,y,z);
     set MI = GFA2CarryIStr(x,y,z);
     set S = 1GateCircStr(<*xy,yz,zx*>,f4);
A1:  InputVertices Cxy is without_pairs &
     InputVertices Cyz is without_pairs &
     InputVertices Czx is without_pairs by FACIRC_1:41;
then A2: InputVertices (Cxy+*Cyz) is without_pairs by FACIRC_1:9;
then A3: InputVertices MI is without_pairs by A1,FACIRC_1:9;
A4:  InputVertices Cxy = {x,y} & InputVertices Cyz = {y,z} &
     InputVertices Czx = {z,x} by FACIRC_1:40;
     InnerVertices S is Relation by FACIRC_1:38;
then A5: InputVertices M =
      (InputVertices MI) \/ (InputVertices S \ InnerVertices MI)
       by A3,FACIRC_1:6;
A6:  InputVertices S = {xy, yz, zx} by FACIRC_1:42;
A7:  InnerVertices Cxy = {xy} & InnerVertices Cyz = {yz} &
     InnerVertices Czx = {zx} by CIRCCOMB:49;
     Cxy tolerates Cyz & Cxy tolerates Czx & Cyz tolerates Czx by CIRCCOMB:55;
then A8: InnerVertices (Cxy +* Cyz) = {xy} \/ {yz} by A7,CIRCCOMB:15;
     Cxy +* Cyz tolerates Czx by CIRCCOMB:55;
then InnerVertices MI = {xy} \/ {yz} \/ {zx} by A7,A8,CIRCCOMB:15
      .= {xy, yz} \/ {zx} by ENUMSET1:41
      .= {xy, yz, zx} by ENUMSET1:43;
then InputVertices S \ InnerVertices MI = {} by A6,XBOOLE_1:37;
     hence InputVertices M
       = (InputVertices(Cxy+*Cyz)) \/ InputVertices Czx
          by A1,A2,A7,A8,A5,FACIRC_1:7
      .= (InputVertices Cxy) \/ (InputVertices Cyz) \/ (InputVertices Czx)
          by A1,A7,FACIRC_1:7
      .= {x,y,y,z} \/ {z,x} by A4,ENUMSET1:45
      .= {y,y,x,z} \/ {z,x} by ENUMSET1:110
      .= {y,x,z} \/ {z,x} by ENUMSET1:71
      .= {x,y,z} \/ {z,x} by ENUMSET1:99
      .= {x,y,z} \/ ({z}\/{x}) by ENUMSET1:41
      .= {x,y,z} \/ {z} \/ {x} by XBOOLE_1:4
      .= {z,x,y} \/ {z} \/ {x} by ENUMSET1:100
      .= {z,z,x,y} \/ {x} by ENUMSET1:44
      .= {z,x,y} \/ {x} by ENUMSET1:71
      .= {x,y,z} \/ {x} by ENUMSET1:100
      .= {x,x,y,z} by ENUMSET1:44
      .= {x,y,z} by ENUMSET1:71;
  end;

::----------------------------------------------------
:: GFA2 Carry : Stability of the Carry Output Circuit
::----------------------------------------------------

theorem Th96:
 for x,y,z being set for s being State of GFA2CarryCirc(x,y,z)
  for a1,a2,a3 being Element of BOOLEAN st a1 = s.x & a2 = s.y & a3 = s.z
   holds
    (Following s).[<*x,y*>,and2a] = 'not' a1 '&' a2 &
    (Following s).[<*y,z*>,and2c] = a2 '&' 'not' a3 &
    (Following s).[<*z,x*>,and2b] = 'not' a3 '&' 'not' a1
   proof
     set f1 = and2a, f2 = and2c, f3 = and2b;
     let x,y,z be set;
     let s be State of GFA2CarryCirc(x,y,z);
     set xy = [<*x,y*>,f1], yz = [<*y,z*>,f2], zx = [<*z,x*>,f3];
     let a1,a2,a3 be Element of BOOLEAN such that
A1:  a1 = s.x & a2 = s.y & a3 = s.z;
     set S = GFA2CarryStr(x,y,z);
A2:  InnerVertices S = the OperSymbols of S by FACIRC_1:37;
A3:  dom s = the carrier of S by CIRCUIT1:4;
A4:  x in the carrier of S & y in the carrier of S & z in the carrier of S
      by Th92;
     xy in InnerVertices GFA2CarryStr(x,y,z) by Th93;
     hence (Following s).[<*x,y*>,f1] = f1.(s*<*x,y*>) by A2,FACIRC_1:35
         .= f1.<*a1,a2*> by A1,A3,A4,FINSEQ_2:145
         .= 'not' a1 '&' a2 by TWOSCOMP:def 2;
     yz in InnerVertices GFA2CarryStr(x,y,z) by Th93;
     hence (Following s).[<*y,z*>,f2] = f2.(s*<*y,z*>) by A2,FACIRC_1:35
         .= f2.<*a2,a3*> by A1,A3,A4,FINSEQ_2:145
         .= a2 '&' 'not' a3 by Def3;
     zx in InnerVertices GFA2CarryStr(x,y,z) by Th93;
     hence (Following s).[<*z,x*>,f3] = f3.(s*<*z,x*>) by A2,FACIRC_1:35
         .= f3.<*a3,a1*> by A1,A3,A4,FINSEQ_2:145
         .= 'not' a3 '&' 'not' a1 by TWOSCOMP:def 3;
  end;

theorem Th97:
 for x,y,z being set for s being State of GFA2CarryCirc(x,y,z)
  for a1,a2,a3 being Element of BOOLEAN st
    a1 = s.[<*x,y*>,and2a] & a2 = s.[<*y,z*>,and2c] & a3 = s.[<*z,x*>,and2b]
   holds
    (Following s).GFA2CarryOutput(x,y,z) = 'not' (a1 'or' a2 'or' a3)
   proof
     set f1 = and2a, f2 = and2c, f3 = and2b, f4 = nor3;
     let x,y,z be set;
     let s be State of GFA2CarryCirc(x,y,z);
     set xy =[<*x,y*>,f1], yz = [<*y,z*>,f2], zx = [<*z,x*>,f3];
     let a1,a2,a3 be Element of BOOLEAN such that
A1:  a1 = s.xy & a2 = s.yz & a3 = s.zx;
     set S = GFA2CarryStr(x,y,z);
A2:  InnerVertices S = the OperSymbols of S by FACIRC_1:37;
A3:  dom s = the carrier of S by CIRCUIT1:4;
     reconsider xy, yz, zx as Element of InnerVertices S by Th93;
     thus (Following s).GFA2CarryOutput(x,y,z)
          = f4.(s*<*xy, yz, zx*>) by A2,FACIRC_1:35
         .= f4.<*a1,a2,a3*> by A1,A3,FINSEQ_2:146
         .= 'not' (a1 'or' a2 'or' a3) by TWOSCOMP:def 28;
  end;

theorem Th98:
  for x,y,z being set st
    x <> [<*y,z*>,and2c] & y <> [<*z,x*>,and2b] & z <> [<*x,y*>,and2a]
   for s being State of GFA2CarryCirc(x,y,z)
    for a1,a2,a3 being Element of BOOLEAN st a1 = s.x & a2 = s.y & a3 = s.z
     holds
      Following(s,2).GFA2CarryOutput(x,y,z) =
          'not' (('not' a1 '&' a2) 'or' (a2 '&' 'not' a3) 'or'
                 ('not' a3 '&' 'not' a1)) &
      Following(s,2).[<*x,y*>,and2a] = 'not' a1 '&' a2 &
      Following(s,2).[<*y,z*>,and2c] = a2 '&' 'not' a3 &
      Following(s,2).[<*z,x*>,and2b] = 'not' a3 '&' 'not' a1
   proof
     set f1 = and2a, f2 = and2c, f3 = and2b;
     let x,y,z be set such that
A1:  x <> [<*y,z*>,f2] & y <> [<*z,x*>,f3] & z <> [<*x,y*>,f1];
     set xy = [<*x,y*>,f1], yz = [<*y,z*>,f2], zx = [<*z,x*>,f3];
     let s be State of GFA2CarryCirc(x,y,z);
     let a1,a2,a3 be Element of BOOLEAN such that
A2:  a1 = s.x & a2 = s.y & a3 = s.z;
     set S = GFA2CarryStr(x,y,z);
     reconsider x' = x, y' = y, z' = z as Vertex of S by Th92;
     x in InputVertices S & y in InputVertices S & z in InputVertices S
     by A1,Th94;
then A3: (Following s).x' = s.x & (Following s).y' = s.y &
         (Following s).z' = s.z by CIRCUIT2:def 5;
A4:  Following(s,2) = Following Following s by FACIRC_1:15;
     (Following s).xy = 'not' a1 '&' a2 &
     (Following s).yz = a2 '&' 'not' a3 &
     (Following s).zx = 'not' a3 '&' 'not' a1 by A2,Th96;
    hence Following(s,2).GFA2CarryOutput(x,y,z) =
      'not'(('not' a1 '&' a2) 'or' (a2 '&' 'not' a3) 'or'
            ('not' a3 '&' 'not' a1))
          by A4,Th97;
    thus thesis by A2,A3,A4,Th96;
  end;

theorem Th99:
  for x,y,z being set st
     x <> [<*y,z*>,and2c] & y <> [<*z,x*>,and2b] & z <> [<*x,y*>,and2a]
   for s being State of GFA2CarryCirc(x,y,z)
    holds Following(s,2) is stable
   proof
     set f1 = and2a, f2 = and2c, f3 = and2b, f4 = nor3;
     let x,y,z be set such that
A1:  x <> [<*y,z*>,f2] & y <> [<*z,x*>,f3] & z <> [<*x,y*>,f1];
     set xy = [<*x,y*>,f1], yz = [<*y,z*>,f2], zx = [<*z,x*>,f3];
     set xyz = [<*xy, yz, zx*>,f4];
     let s be State of GFA2CarryCirc(x,y,z);
     set S = GFA2CarryStr(x,y,z);
A2:  dom Following Following(s,2) = the carrier of S &
     dom Following(s,2) = the carrier of S by CIRCUIT1:4;
     reconsider xx = x, yy = y, zz = z as Vertex of S by Th92;
     set a1 = s.xx, a2 = s.yy, a3 = s.zz;
     set ffs = Following(s,2), fffs = Following ffs;
     a1 = s.x & a2 = s.y & a3 = s.z;
then A3: ffs.GFA2CarryOutput(x,y,z) =
         'not'(('not' a1 '&' a2) 'or' (a2 '&' 'not' a3) 'or'
                                      ('not' a3 '&' 'not' a1)) &
     ffs.xy = 'not' a1 '&' a2 &
     ffs.yz = a2 '&' 'not' a3 &
     ffs.zx = 'not' a1 '&' 'not' a3 by A1,Th98;
A4:  ffs = Following Following s by FACIRC_1:15;
A5:  x in InputVertices S & y in InputVertices S & z in InputVertices S
      by A1,Th94;
then (Following s).x = a1 & (Following s).y = a2 & (Following s).z = a3
      by CIRCUIT2:def 5;
then A6: ffs.x = a1 & ffs.y = a2 & ffs.z = a3 by A4,A5,CIRCUIT2:def 5;
     now let a be set; assume
A7:  a in the carrier of S;
then reconsider v = a as Vertex of S;
A8:  v in InputVertices S \/ InnerVertices S by A7,XBOOLE_1:45;
     thus ffs.a = (fffs).a
      proof per cases by A8,XBOOLE_0:def 2;
        suppose v in InputVertices S;
          hence thesis by CIRCUIT2:def 5;
        end;
        suppose v in InnerVertices S;
           then v in {xy, yz, zx} \/ {GFA2CarryOutput(x,y,z)} by Th87;
           then v in {xy, yz, zx} or
                v in {GFA2CarryOutput(x,y,z)} by XBOOLE_0:def 2;
           then v = xy or v = yz or v = zx or
                v = GFA2CarryOutput(x,y,z) by ENUMSET1:def 1,TARSKI:def 1;
          hence thesis by A3,A6,Th96,Th97;
        end;
      end;
     end;
    hence ffs = fffs by A2,FUNCT_1:9;
  end;

::=========================================================================

::-------------------------------------------------
:: GFA2 Adder : Circuit Definition of Adder Output
::-------------------------------------------------

definition
 let x,y,z be set;
 func GFA2AdderStr(x,y,z) ->
      unsplit gate`1=arity gate`2isBoolean
      non void strict non empty ManySortedSign equals
   2GatesCircStr(x,y,z, xor2c);
  coherence;
end;

definition
 let x,y,z be set;
 func GFA2AdderCirc(x,y,z) ->
      strict Boolean gate`2=den Circuit of GFA2AdderStr(x,y,z) equals
   2GatesCircuit(x,y,z, xor2c);
  coherence;
end;

definition
 let x,y,z be set;
 func GFA2AdderOutput(x,y,z) ->
      Element of InnerVertices GFA2AdderStr(x,y,z) equals
   2GatesCircOutput(x,y,z, xor2c);
  coherence;
end;

::-------------------------------------------------------
:: GFA2 Adder : Carrier, InnerVertices and InputVertices
::-------------------------------------------------------

::-------------------------------------------------------
:: InnerVertices

theorem Th100:
 for x,y,z being set holds
  InnerVertices GFA2AdderStr(x,y,z) =
    {[<*x,y*>,xor2c]} \/ {GFA2AdderOutput(x,y,z)}
   proof
     let x,y,z be set;
     set S2 = GFA2AdderStr(x,y,z), A2 = GFA2AdderOutput(x,y,z);
     set S1 = GFA1AdderStr(x,y,z), A1 = GFA1AdderOutput(x,y,z);
     S2 = S1 & A2 = A1;
    hence thesis by Th63;
   end;

theorem
 for x,y,z being set holds
  InnerVertices GFA2AdderStr(x,y,z) is Relation by FACIRC_1:58;

::-------------------------------------------------------
:: InputVertices

theorem
 for x,y,z being set st z <> [<*x,y*>,xor2c] holds
  InputVertices GFA2AdderStr(x,y,z) = {x,y,z} by FACIRC_1:57;

theorem
 for x,y,z being non pair set holds
  InputVertices GFA2AdderStr(x,y,z) is without_pairs by FACIRC_1:59;

::-------------------------------------------------------
:: Carrier and misc.

theorem
 for x,y,z being set holds
   x in the carrier of GFA2AdderStr(x,y,z) &
   y in the carrier of GFA2AdderStr(x,y,z) &
   z in the carrier of GFA2AdderStr(x,y,z) &
   [<*x,y*>,xor2c] in the carrier of GFA2AdderStr(x,y,z) &
   [<*[<*x,y*>,xor2c], z*>, xor2c] in the carrier of GFA2AdderStr(x,y,z)
   by FACIRC_1:60,61;

theorem
 for x,y,z being set holds
   [<*x,y*>,xor2c] in InnerVertices GFA2AdderStr(x,y,z) &
   GFA2AdderOutput(x,y,z) in InnerVertices GFA2AdderStr(x,y,z)
   proof
     let x,y,z be set;
     set S1 = GFA1AdderStr(x,y,z);
     GFA2AdderStr(x,y,z) = S1;
    hence thesis by Th68;
   end;

theorem
 for x,y,z being set st z <> [<*x,y*>, xor2c] holds
    x in InputVertices GFA2AdderStr(x,y,z) &
    y in InputVertices GFA2AdderStr(x,y,z) &
    z in InputVertices GFA2AdderStr(x,y,z)
   proof
     set f = xor2c;
     let x,y,z be set such that
A1:  z <> [<*x,y*>,f];
     set S1 = GFA1AdderStr(x,y,z);
     GFA2AdderStr(x,y,z) = S1;
    hence thesis by A1,Th69;
   end;

theorem
 for x,y,z being non pair set holds
   InputVertices GFA2AdderStr(x,y,z) = {x,y,z} by FACIRC_1:57;

::----------------------------------------------------
:: GFA2 Adder : Stability of the Adder Output Circuit
::----------------------------------------------------

theorem
 for x,y,z being set st z <> [<*x,y*>, xor2c]
  for s being State of GFA2AdderCirc(x,y,z)
   for a1,a2,a3 being Element of BOOLEAN st a1 = s.x & a2 = s.y & a3 = s.z
     holds
      (Following s).[<*x,y*>,xor2c] = a1 'xor' 'not' a2 &
      (Following s).x = a1 & (Following s).y = a2 & (Following s).z = a3
   proof
     set f = xor2c;
     let x,y,z be set such that
A1:  z <> [<*x,y*>,f];
     set A1 = GFA1AdderCirc(x,y,z);
     GFA2AdderCirc(x,y,z) = A1;
     hence thesis by A1,Th71;
   end;

theorem
 for x,y,z being set st z <> [<*x,y*>, xor2c]
  for s being State of GFA2AdderCirc(x,y,z)
   for a1a2,a1,a2,a3 being Element of BOOLEAN
     st a1a2 = s.[<*x,y*>,xor2c] & a1 = s.x & a2 = s.y & a3 = s.z
    holds
     (Following s).GFA2AdderOutput(x,y,z) = a1a2 'xor' 'not' a3
   proof
     set f = xor2c;
     let x,y,z be set such that
A1:  z <> [<*x,y*>,f];
     set A2 = GFA2AdderCirc(x,y,z);
     set A1 = GFA1AdderCirc(x,y,z);
     set O2 = GFA2AdderOutput(x,y,z);
     set O1 = GFA1AdderOutput(x,y,z);
     A2 = A1 & O2 = O1;
     hence thesis by A1,Th72;
   end;

theorem Th110:
 for x,y,z being set st z <> [<*x,y*>, xor2c]
  for s being State of GFA2AdderCirc(x,y,z)
   for a1,a2,a3 being Element of BOOLEAN st a1 = s.x & a2 = s.y & a3 = s.z
    holds
     Following(s,2).GFA2AdderOutput(x,y,z)
         = a1 'xor' 'not' a2 'xor' 'not' a3 &
     Following(s,2).[<*x,y*>,xor2c] = a1 'xor' 'not' a2 &
     Following(s,2).x = a1 & Following(s,2).y = a2 & Following(s,2).z = a3
   proof
     set f = xor2c;
     let x,y,z be set such that
A1:  z <> [<*x,y*>,f];
     set A2 = GFA2AdderCirc(x,y,z);
     set A1 = GFA1AdderCirc(x,y,z);
     set O2 = GFA2AdderOutput(x,y,z);
     set O1 = GFA1AdderOutput(x,y,z);
     A2 = A1 & O2 = O1;
     hence thesis by A1,Th73;
   end;

theorem Th111:
  for x,y,z being set st z <> [<*x,y*>, xor2c]
   for s being State of GFA2AdderCirc(x,y,z)
    for a1,a2,a3 being Element of BOOLEAN st a1 = s.x & a2 = s.y & a3 = s.z
     holds
      Following(s,2).GFA2AdderOutput(x,y,z)
         = 'not' a1 'xor' a2 'xor' 'not' a3
   proof
     set f = xor2c;
     let x,y,z be set such that
A1:  z <> [<*x,y*>,f];
     set xy = [<*x,y*>,f];
     set A = GFA2AdderCirc(x,y,z);
     let s be State of A;
     let a1,a2,a3 be Element of BOOLEAN such that
A2:  a1 = s.x & a2 = s.y & a3 = s.z;
     thus (Following(s,2)).GFA2AdderOutput(x,y,z)
         = a1 'xor' 'not' a2 'xor' 'not' a3 by A1,A2,Th110
        .= 'not' a1 'xor' a2 'xor' 'not' a3;
   end;

theorem
 for x,y,z being set st z <> [<*x,y*>,xor2c]
  for s being State of GFA2AdderCirc(x,y,z)
    holds Following(s,2) is stable by FACIRC_1:63;

::=====================================================================

::---------------------------------------------------
:: GFA2 : Circuit Definition of GFA Combined Circuit
::---------------------------------------------------

definition
 let x,y,z be set;
 func BitGFA2Str(x,y,z) ->
      unsplit gate`1=arity gate`2isBoolean
      non void strict non empty ManySortedSign equals
    GFA2AdderStr(x,y,z) +* GFA2CarryStr(x,y,z);
  coherence;
end;

definition
 let x,y,z be set;
 func BitGFA2Circ(x,y,z) ->
   strict Boolean gate`2=den Circuit of BitGFA2Str(x,y,z) equals
   GFA2AdderCirc(x,y,z) +* GFA2CarryCirc(x,y,z);
  coherence;
end;

::----------------------------------------------------------
:: GFA2 Combined : Carrier, InnerVertices and InputVertices
::----------------------------------------------------------

::-------------------------------------------------------
:: InnerVertices

theorem Th113:
  for x,y,z being set holds
   InnerVertices BitGFA2Str(x,y,z) =
     {[<*x,y*>,xor2c]} \/ {GFA2AdderOutput(x,y,z)} \/
     {[<*x,y*>,and2a], [<*y,z*>,and2c], [<*z,x*>,and2b]} \/
     {GFA2CarryOutput(x,y,z)}
   proof
     set f0 = xor2c;
     set f1 = and2a, f2 = and2c, f3 = and2b;
     let x,y,z be set;
     set xyf0 = [<*x,y*>,f0];
     set xyf1 = [<*x,y*>,f1], yzf2 = [<*y,z*>,f2], zxf3 = [<*z,x*>,f3];
     set S = BitGFA2Str(x,y,z);
     set S1 = GFA2AdderStr(x,y,z);
     set S2 = GFA2CarryStr(x,y,z);
     set A1 = GFA2AdderOutput(x,y,z);
     set A2 = GFA2CarryOutput(x,y,z);
     thus InnerVertices S
       = (InnerVertices S1) \/ InnerVertices S2 by FACIRC_1:27
      .= {xyf0} \/ {A1} \/ InnerVertices S2 by Th100
      .= {xyf0} \/ {A1} \/ ({xyf1, yzf2, zxf3} \/ {A2}) by Th87
      .= {xyf0} \/ {A1} \/ {xyf1, yzf2, zxf3} \/ {A2} by XBOOLE_1:4;
   end;

theorem
 for x,y,z being set holds
   InnerVertices BitGFA2Str(x,y,z) is Relation
   proof
     let x,y,z be set;
     set S1 = GFA2AdderStr(x,y,z);
     set S2 = GFA2CarryStr(x,y,z);
     InnerVertices S1 is Relation & InnerVertices S2 is Relation
       by FACIRC_1:58,Th88;
     hence thesis by FACIRC_1:3;
  end;

::-------------------------------------------------------
:: InputVertices

theorem Th115:
  for x,y,z being set  st z <> [<*x,y*>,xor2c] &
    x <> [<*y,z*>,and2c] & y <> [<*z,x*>,and2b] & z <> [<*x,y*>,and2a]
   holds
    InputVertices BitGFA2Str(x,y,z) = {x,y,z}
   proof
     set f0 = xor2c;
     set f1 = and2a, f2 = and2c, f3 = and2b;
     let x,y,z be set such that
A1:  z <> [<*x,y*>,f0] and
A2:  x <> [<*y,z*>,f2] & y <> [<*z,x*>,f3] & z <> [<*x,y*>,f1];
     set S = BitGFA2Str(x,y,z);
     set S1 = GFA2AdderStr(x,y,z);
     set S2 = GFA2CarryStr(x,y,z);
A3:  InputVertices S1 = {x,y,z} by A1,FACIRC_1:57;
A4:  InputVertices S2 = {x,y,z} by A2,Th90;
     S1 tolerates S2 by CIRCCOMB:55;
    hence InputVertices S = {x,y,z} by A3,A4,FACIRC_2:22;
   end;

theorem Th116:
 for x,y,z being non pair set holds
    InputVertices BitGFA2Str(x,y,z) = {x,y,z}
   proof
     let x,y,z be non pair set;
     set S = BitGFA2Str(x,y,z);
     set S1 = GFA2AdderStr(x,y,z);
     set S2 = GFA2CarryStr(x,y,z);
A1:  InputVertices S1 is without_pairs & InnerVertices S1 is Relation
      by FACIRC_1:58,FACIRC_1:59;
A2:  InputVertices S2 is without_pairs & InnerVertices S2 is Relation
      by Th88,Th91;
     InputVertices S1 = {x,y,z} & InputVertices S2 = {x,y,z}
      by FACIRC_1:57,Th95;
    hence InputVertices S = {x,y,z} \/ {x,y,z} by A1,A2,FACIRC_1:7
                         .= {x,y,z};
  end;

theorem
 for x,y,z being non pair set holds
    InputVertices BitGFA2Str(x,y,z) is without_pairs
   proof
     let x,y,z be non pair set;
     InputVertices BitGFA2Str(x,y,z) = {x,y,z} by Th116;
     hence thesis;
   end;

::-------------------------------------------------------
:: Carrier and misc.

theorem
 for x,y,z being set holds
    x in the carrier of BitGFA2Str(x,y,z) &
    y in the carrier of BitGFA2Str(x,y,z) &
    z in the carrier of BitGFA2Str(x,y,z) &
    [<*x,y*>,xor2c] in the carrier of BitGFA2Str(x,y,z) &
    [<*[<*x,y*>,xor2c],z*>,xor2c] in the carrier of BitGFA2Str(x,y,z) &
    [<*x,y*>,and2a] in the carrier of BitGFA2Str(x,y,z) &
    [<*y,z*>,and2c] in the carrier of BitGFA2Str(x,y,z) &
    [<*z,x*>,and2b] in the carrier of BitGFA2Str(x,y,z) &
    [<*[<*x,y*>,and2a],[<*y,z*>,and2c],[<*z,x*>,and2b]*>,nor3]
                                in the carrier of BitGFA2Str(x,y,z)
   proof
     set f0 = xor2c;
     set f1 = and2a, f2 = and2c, f3 = and2b, f4 = nor3;
     let x,y,z be set;
     set xy = [<*x,y*>,f1], yz = [<*y,z*>,f2], zx = [<*z,x*>,f3];
     set xyz = [<*xy, yz, zx*>,f4];
     set S1 = GFA2AdderStr(x,y,z);
     set S2 = GFA2CarryStr(x,y,z);
A1:  x in the carrier of S1 & y in the carrier of S1 &
     z in the carrier of S1 &
     [<*x,y*>,f0] in the carrier of S1 &
     [<*[<*x,y*>,f0],z*>,f0] in the carrier of S1 by FACIRC_1:60,61;
     xy in the carrier of S2 & yz in the carrier of S2 &
     zx in the carrier of S2 &
     xyz in the carrier of S2 by Th92;
    hence thesis by A1,FACIRC_1:20;
  end;

theorem Th119:
  for x,y,z being set holds
    [<*x,y*>,xor2c] in InnerVertices BitGFA2Str(x,y,z) &
    GFA2AdderOutput(x,y,z) in InnerVertices BitGFA2Str(x,y,z) &
    [<*x,y*>,and2a] in InnerVertices BitGFA2Str(x,y,z) &
    [<*y,z*>,and2c] in InnerVertices BitGFA2Str(x,y,z) &
    [<*z,x*>,and2b] in InnerVertices BitGFA2Str(x,y,z) &
    GFA2CarryOutput(x,y,z) in InnerVertices BitGFA2Str(x,y,z)
   proof
     set f0 = xor2c;
     set f1 = and2a, f2 = and2c, f3 = and2b;
     let x,y,z be set;
     set xyf0 = [<*x,y*>,f0];
     set xyf1 = [<*x,y*>,f1], yzf2 = [<*y,z*>,f2], zxf3 = [<*z,x*>,f3];
     set S = BitGFA2Str(x,y,z);
     set A1 = GFA2AdderOutput(x,y,z);
     set A2 = GFA2CarryOutput(x,y,z);
     InnerVertices S
       = {xyf0} \/ {A1} \/ {xyf1,yzf2,zxf3} \/ {A2} by Th113
      .= {xyf0,A1} \/ {xyf1,yzf2,zxf3} \/ {A2} by ENUMSET1:41
      .= {xyf0,A1,xyf1,yzf2,zxf3} \/ {A2} by ENUMSET1:48
      .= {xyf0,A1,xyf1,yzf2,zxf3,A2} by ENUMSET1:55;
     hence thesis by ENUMSET1:def 4;
   end;

theorem
  for x,y,z being set  st z <> [<*x,y*>,xor2c] &
    x <> [<*y,z*>,and2c] & y <> [<*z,x*>,and2b] & z <> [<*x,y*>,and2a]
   holds
    x in InputVertices BitGFA2Str(x,y,z) &
    y in InputVertices BitGFA2Str(x,y,z) &
    z in InputVertices BitGFA2Str(x,y,z)
   proof
     set f0 = xor2c;
     set f1 = and2a, f2 = and2c, f3 = and2b;
     let x,y,z be set such that
A1:  z <> [<*x,y*>,f0] &
     x <> [<*y,z*>,f2] & y <> [<*z,x*>,f3] & z <> [<*x,y*>,f1];
     set S = BitGFA2Str(x,y,z);
     InputVertices S = {x,y,z} by A1,Th115;
    hence thesis by ENUMSET1:def 1;
   end;

::------------------------------------------------------------------
:: GFA2 : Carry and Adder Output Definition of GFA Combined Circuit
::------------------------------------------------------------------

definition
 let x,y,z be set;
 func BitGFA2CarryOutput(x,y,z) ->
         Element of InnerVertices BitGFA2Str(x,y,z) equals
    [<*[<*x,y*>,and2a],[<*y,z*>,and2c],[<*z,x*>,and2b]*>,nor3];
  coherence
    proof
      GFA2CarryOutput(x,y,z)
        in InnerVertices BitGFA2Str(x,y,z) by Th119;
      hence thesis;
    end;
end;

definition
 let x,y,z be set;
 func BitGFA2AdderOutput(x,y,z) ->
         Element of InnerVertices BitGFA2Str(x,y,z) equals
    2GatesCircOutput(x,y,z, xor2c);
  coherence
    proof
      GFA2AdderOutput(x,y,z)
        in InnerVertices BitGFA2Str(x,y,z) by Th119;
      hence thesis;
    end;
end;

::-------------------------------------------------------------
:: GFA2 Combined : Stability of the Adder/Carry Output Circuit
::-------------------------------------------------------------

theorem
  for x,y,z being set st z <> [<*x,y*>,xor2c] &
    x <> [<*y,z*>,and2c] & y <> [<*z,x*>,and2b] & z <> [<*x,y*>,and2a]
   for s being State of BitGFA2Circ(x,y,z)
    for a1,a2,a3 being Element of BOOLEAN st a1 = s.x & a2 = s.y & a3 = s.z
     holds
      Following(s,2).GFA2AdderOutput(x,y,z)
           = 'not' a1 'xor' a2 'xor' 'not' a3 &
      Following(s,2).GFA2CarryOutput(x,y,z)
           = 'not' (('not' a1 '&' a2) 'or' (a2 '&' 'not' a3) 'or'
                    ('not' a3 '&' 'not' a1))
   proof
     set f0 = xor2c;
     set f1 = and2a, f2 = and2c, f3 = and2b;
     let x,y,z be set such that
A1:  z <> [<*x,y*>,f0] &
     x <> [<*y,z*>,f2] & y <> [<*z,x*>,f3] & z <> [<*x,y*>,f1];
     set S = BitGFA2Str(x,y,z);
     set S1 = GFA2AdderStr(x,y,z);
     set S2 = GFA2CarryStr(x,y,z);
     set A = BitGFA2Circ(x,y,z);
     set A1 = GFA2AdderCirc(x,y,z);
     set A2 = GFA2CarryCirc(x,y,z);
     let s be State of A;
     let a1,a2,a3 be Element of BOOLEAN; assume
A2:  a1 = s.x & a2 = s.y & a3 = s.z;
A3:  x in the carrier of S1 & y in the carrier of S1 & z in the carrier of S1
     by FACIRC_1:60;
A4:  x in the carrier of S2 & y in the carrier of S2 & z in the carrier of S2
     by Th92;
     reconsider s1 = s|the carrier of S1 as State of A1 by FACIRC_1:26;
     reconsider s2 = s|the carrier of S2 as State of A2 by FACIRC_1:26;
     reconsider t = s as State of A1+*A2;
     InputVertices S1 = {x,y,z} by A1,FACIRC_1:57;
then A5: InputVertices S1 = InputVertices S2 by A1,Th90;
A6:  InnerVertices S1 misses InputVertices S1 &
     InnerVertices S2 misses InputVertices S2 by XBOOLE_1:79;
     dom s1 = the carrier of S1 by CIRCUIT1:4;
then a1 = s1.x & a2 = s1.y & a3 = s1.z by A2,A3,FUNCT_1:70;
then Following(t,2).GFA2AdderOutput(x,y,z)
        = Following(s1,2).GFA2AdderOutput(x,y,z) &
     Following(s1,2).GFA2AdderOutput(x,y,z) = 'not' a1 'xor' a2 'xor' 'not' a3
       by A1,A5,A6,Th111,FACIRC_1:32;
    hence
     Following(s,2).GFA2AdderOutput(x,y,z) = 'not' a1 'xor' a2 'xor' 'not' a3;
     dom s2 = the carrier of S2 by CIRCUIT1:4;
then a1 = s2.x & a2 = s2.y & a3 = s2.z by A2,A4,FUNCT_1:70;
then Following(t,2).GFA2CarryOutput(x,y,z)
        = Following(s2,2).GFA2CarryOutput(x,y,z) &
     Following(s2,2).GFA2CarryOutput(x,y,z) =
       'not' (('not' a1 '&' a2) 'or' (a2 '&' 'not' a3) 'or'
              ('not' a3 '&' 'not' a1))
       by A1,A5,A6,Th98,FACIRC_1:33;
     hence Following(s,2).GFA2CarryOutput(x,y,z) =
       'not' (('not' a1 '&' a2) 'or' (a2 '&' 'not' a3) 'or'
              ('not' a3 '&' 'not' a1));
   end;

theorem
 for x,y,z being set  st z <> [<*x,y*>,xor2c] &
   x <> [<*y,z*>,and2c] & y <> [<*z,x*>,and2b] & z <> [<*x,y*>,and2a]
   for s being State of BitGFA2Circ(x,y,z)
    holds Following(s,2) is stable
   proof
     set f0 = xor2c;
     set f1 = and2a, f2 = and2c, f3 = and2b;
     let x,y,z be set such that
A1:  z <> [<*x,y*>,f0] &
     x <> [<*y,z*>,f2] & y <> [<*z,x*>,f3] & z <> [<*x,y*>,f1];
     set S = BitGFA2Str(x,y,z);
     set S1 = GFA2AdderStr(x,y,z);
     set S2 = GFA2CarryStr(x,y,z);
     set A = BitGFA2Circ(x,y,z);
     set A1 = GFA2AdderCirc(x,y,z);
     set A2 = GFA2CarryCirc(x,y,z);
     let s be State of A;
     reconsider s1 = s|the carrier of S1 as State of A1 by FACIRC_1:26;
     reconsider s2 = s|the carrier of S2 as State of A2 by FACIRC_1:26;
     reconsider t = s as State of A1+*A2;
     InputVertices S1 = {x,y,z} by A1,FACIRC_1:57;
then A2: InputVertices S1 = InputVertices S2 by A1,Th90;
     InnerVertices S1 misses InputVertices S1 &
     InnerVertices S2 misses InputVertices S2 by XBOOLE_1:79;
then A3: Following(s1,2) = Following(t,2)|the carrier of S1 &
         Following(s1,3) = Following(t,3)|the carrier of S1 &
         Following(s2,2) = Following(t,2)|the carrier of S2 &
         Following(s2,3) = Following(t,3)|the carrier of S2
          by A2,FACIRC_1:30,31;
     Following(s1,2) is stable by A1,FACIRC_1:63;
then A4: Following(s1,2)
       = Following Following(s1,2) by CIRCUIT2:def 6
      .= Following(s1,2+1) by FACIRC_1:12;
     Following(s2,2) is stable by A1,Th99;
then A5: Following(s2,2)
       = Following Following(s2,2) by CIRCUIT2:def 6
      .= Following(s2,2+1) by FACIRC_1:12;
A6:  Following(s,2+1) = Following Following(s,2) by FACIRC_1:12;
A7:  dom Following(s,2) = the carrier of S &
     dom Following(s,3) = the carrier of S &
     dom Following(s1,2) = the carrier of S1 &
     dom Following(s2,2) = the carrier of S2 by CIRCUIT1:4;
     A8: the carrier of S = (the carrier of S1) \/ the carrier of S2
      by CIRCCOMB:def 2;
       now let a be set; assume a in the carrier of S;
       then a in the carrier of S1 or a in the carrier of S2
              by A8,XBOOLE_0:def 2;
       then (Following(s,2)).a = (Following(s1,2)).a &
            (Following(s,3)).a = (Following(s1,3)).a or
            (Following(s,2)).a = (Following(s2,2)).a &
            (Following(s,3)).a = (Following(s2,3)).a
              by A3,A4,A5,A7,FUNCT_1:70;
       hence (Following(s,2)).a = (Following Following(s,2)).a
              by A4,A5,FACIRC_1:12;
       end;
    hence Following(s,2) = Following Following(s,2) by A6,A7,FUNCT_1:9;
   end;

::========================================================================

begin :: Generalized Full Adder (GFA) Circuit (TYPE-3)

::========================================================================
:: << GFA TYPE-3 >>
::------------------------------------------------------------------------
::   Name     : Generalized Full Adder Type-3 (GFA3)
::   Function : - x - y - z = - 2 * c - s
::
::   Logic Symbol :     -x     -y      Combined : GFA3CarryIStr(x,y,z)
::                       |     /                  GFA3CarryStr(x,y,z)
::                       |    /                   GFA3AdderStr(x,y,z)
::                   +---O---O                  --->
::                   |  GFA  O---- -z             BitGFA3Str(x,y,z)
::                   | TYPE3 |
::                   O---O---+          Outputs : BitGFA3CarryOutput(x,y,z)
::                  /    |                        BitGFA3AdderOutput(x,y,z)
::                 /     |
::               -c     -s          Calculation : Following(s,2) is stable.
::=========================================================================

::-------------------------------------------------
:: GFA3 Carry : Circuit Definition of Carry Output
::-------------------------------------------------

definition
 let x,y,z be set;
 func GFA3CarryIStr(x,y,z) ->
    unsplit gate`1=arity gate`2isBoolean
    non void strict non empty ManySortedSign equals
    1GateCircStr(<*x,y*>,and2b) +* 1GateCircStr(<*y,z*>,and2b) +*
    1GateCircStr(<*z,x*>,and2b);
  coherence;
end;

definition
 let x,y,z be set;
 func GFA3CarryICirc(x,y,z) ->
      strict Boolean gate`2=den Circuit of GFA3CarryIStr(x,y,z) equals
    1GateCircuit(x,y,and2b) +* 1GateCircuit(y,z,and2b) +*
    1GateCircuit(z,x,and2b);
  coherence;
end;

definition
 let x,y,z be set;
 func GFA3CarryStr(x,y,z) ->
    unsplit gate`1=arity gate`2isBoolean
    non void strict non empty ManySortedSign equals
    GFA3CarryIStr(x,y,z) +*
    1GateCircStr(<*[<*x,y*>,and2b], [<*y,z*>,and2b], [<*z,x*>,and2b]*>,nor3);
  coherence;
end;

definition
 let x,y,z be set;
 func GFA3CarryCirc(x,y,z) ->
      strict Boolean gate`2=den Circuit of GFA3CarryStr(x,y,z) equals
    GFA3CarryICirc(x,y,z) +*
    1GateCircuit([<*x,y*>,and2b],[<*y,z*>,and2b],[<*z,x*>,and2b],nor3);
  coherence;
end;

definition
 let x,y,z be set;
 func GFA3CarryOutput(x,y,z) -> Element of InnerVertices GFA3CarryStr(x,y,z)
  equals
   [<*[<*x,y*>,and2b],[<*y,z*>,and2b],[<*z,x*>,and2b]*>,nor3];
  coherence
   proof
     [<*[<*x,y*>,and2b],[<*y,z*>,and2b],[<*z,x*>,and2b]*>,nor3] in
      InnerVertices
       1GateCircStr(<*[<*x,y*>,and2b],[<*y,z*>,and2b], [<*z,x*>,and2b]*>,nor3)
       by FACIRC_1:47;
    hence thesis by FACIRC_1:21;
   end;
end;

::-------------------------------------------------------
:: GFA3 Carry : Carrier, InnerVertices and InputVertices
::-------------------------------------------------------

::-------------------------------------------------------
:: InnerVertices

theorem Th123:
  for x,y,z being set holds
  InnerVertices GFA3CarryIStr(x,y,z) =
   {[<*x,y*>,and2b], [<*y,z*>,and2b], [<*z,x*>,and2b]}
   proof
     set f1 = and2b, f2 = and2b, f3 = and2b;
     let x,y,z be set;
     set xy = [<*x,y*>,f1], yz = [<*y,z*>,f2], zx = [<*z,x*>,f3];
     set Cxy = 1GateCircStr(<*x,y*>,f1);
     set Cyz = 1GateCircStr(<*y,z*>,f2);
     set Czx = 1GateCircStr(<*z,x*>,f3);
A1:  Cxy +* Cyz tolerates Czx by CIRCCOMB:55;
A2:  Cxy tolerates Cyz by CIRCCOMB:55;
     InnerVertices GFA3CarryIStr(x,y,z)
       = InnerVertices(Cxy +* Cyz) \/ InnerVertices(Czx) by A1,CIRCCOMB:15
      .= InnerVertices(Cxy) \/ InnerVertices(Cyz) \/
         InnerVertices(Czx) by A2,CIRCCOMB:15
      .= {xy} \/ InnerVertices(Cyz) \/ InnerVertices(Czx) by CIRCCOMB:49
      .= {xy} \/ {yz} \/ InnerVertices(Czx) by CIRCCOMB:49
      .= {xy} \/ {yz} \/ {zx} by CIRCCOMB:49
      .= {xy, yz} \/ {zx} by ENUMSET1:41
      .= {xy, yz, zx} by ENUMSET1:43;
    hence thesis;
   end;

theorem Th124:
  for x,y,z being set holds
  InnerVertices GFA3CarryStr(x,y,z) =
    {[<*x,y*>,and2b], [<*y,z*>,and2b], [<*z,x*>,and2b]} \/
    {GFA3CarryOutput(x,y,z)}
   proof
     set f1 = and2b, f2 = and2b, f3 = and2b, f4 = nor3;
     let x,y,z be set;
     set xy = [<*x,y*>,f1], yz = [<*y,z*>,f2], zx = [<*z,x*>,f3];
     set xyz = [<*xy, yz, zx*>,f4];
     set Cxy = 1GateCircStr(<*x,y*>,f1);
     set Cyz = 1GateCircStr(<*y,z*>,f2);
     set Czx = 1GateCircStr(<*z,x*>,f3);
     set Cxyz = 1GateCircStr(<*xy, yz, zx*>,f4);
A1:  Cxy tolerates (Cyz +* Czx +* Cxyz) by CIRCCOMB:55;
A2:  Cyz tolerates (Czx +* Cxyz) by CIRCCOMB:55;
A3:  Czx tolerates Cxyz by CIRCCOMB:55;
A4:  InnerVertices (Cyz +* (Czx +* Cxyz))
      = InnerVertices Cyz \/ InnerVertices (Czx +* Cxyz) by A2,CIRCCOMB:15;
A5:  InnerVertices (Czx +* Cxyz)
      = InnerVertices Czx \/ InnerVertices Cxyz by A3,CIRCCOMB:15;
thus InnerVertices GFA3CarryStr(x,y,z)
      = InnerVertices (Cxy +* (Cyz +* Czx) +* Cxyz) by CIRCCOMB:10
     .= InnerVertices (Cxy +* (Cyz +* Czx +* Cxyz)) by CIRCCOMB:10
     .= InnerVertices Cxy \/ InnerVertices (Cyz +* Czx +* Cxyz)
          by A1,CIRCCOMB:15
     .= InnerVertices Cxy \/ InnerVertices (Cyz +* (Czx +* Cxyz))
          by CIRCCOMB:10
     .= InnerVertices Cxy \/ InnerVertices Cyz \/
          (InnerVertices Czx \/ InnerVertices Cxyz) by A4,A5,XBOOLE_1:4
     .= InnerVertices Cxy \/ InnerVertices Cyz \/
           InnerVertices Czx \/ InnerVertices Cxyz by XBOOLE_1:4
     .= {xy} \/ InnerVertices Cyz \/
           InnerVertices Czx \/ InnerVertices Cxyz by CIRCCOMB:49
     .= {xy} \/ {yz} \/ InnerVertices Czx \/ InnerVertices Cxyz by CIRCCOMB:49
     .= {xy} \/ {yz} \/ {zx} \/ InnerVertices Cxyz by CIRCCOMB:49
     .= {xy, yz} \/ {zx} \/ InnerVertices Cxyz by ENUMSET1:41
     .= {xy, yz, zx} \/ InnerVertices Cxyz by ENUMSET1:43
     .= {xy, yz, zx} \/ {GFA3CarryOutput(x,y,z)} by CIRCCOMB:49;
  end;

theorem Th125:
  for x,y,z being set holds
  InnerVertices GFA3CarryStr(x,y,z) is Relation
   proof
     set f1 = and2b, f2 = and2b, f3 = and2b, f4 = nor3;
     let x,y,z be set;
     set xy = [<*x,y*>,f1], yz = [<*y,z*>,f2], zx = [<*z,x*>,f3];
     set Cxy = 1GateCircStr(<*x,y*>,f1);
     set Cyz = 1GateCircStr(<*y,z*>,f2);
     set Czx = 1GateCircStr(<*z,x*>,f3);
     set Cxyz = 1GateCircStr(<*xy, yz, zx*>,f4);
A1:  InnerVertices Cxy is Relation & InnerVertices Cyz is Relation &
     InnerVertices Czx is Relation by FACIRC_1:38;
then InnerVertices (Cxy +* Cyz) is Relation by FACIRC_1:3;
then InnerVertices Cxyz is Relation &
     InnerVertices GFA3CarryIStr(x,y,z) is Relation by A1,FACIRC_1:3,38;
    hence thesis by FACIRC_1:3;
   end;

::-------------------------------------------------------
:: InputVertices

theorem Th126:
 for x,y,z being set st
   x <> [<*y,z*>,and2b] & y <> [<*z,x*>,and2b] & z <> [<*x,y*>,and2b]
  holds InputVertices GFA3CarryIStr(x,y,z) = {x,y,z}
   proof
     set f1 = and2b, f2 = and2b, f3 = and2b;
     let x,y,z be set;
     set xy = [<*x,y*>,f1], yz = [<*y,z*>,f2], zx = [<*z,x*>,f3];
     set Cxy = 1GateCircStr(<*x,y*>,f1);
     set Cyz = 1GateCircStr(<*y,z*>,f2);
     set Czx = 1GateCircStr(<*z,x*>,f3);
     assume
A1:  x <> yz & y <> zx & z <> xy;
A2:  Cxy +* Cyz tolerates Czx by CIRCCOMB:55;
A3:  Cxy tolerates Cyz by CIRCCOMB:55;
A4:  y <> yz by FACIRC_2:3;
A5:  not xy in {y,z} by A1,Lm1;
A6:  not z in {xy, yz} & not x in {xy, yz} by A1,Lm1;
A7:  not zx in {x,y,z} by A1,Lm1;
     InputVertices GFA3CarryIStr(x,y,z)
      = (InputVertices(Cxy +* Cyz) \ InnerVertices(Czx)) \/
        (InputVertices(Czx) \ InnerVertices(Cxy +* Cyz)) by A2,CIRCCMB2:6
     .= ((InputVertices(Cxy) \ InnerVertices(Cyz)) \/
         (InputVertices(Cyz) \ InnerVertices(Cxy))) \ InnerVertices(Czx) \/
         (InputVertices(Czx) \ InnerVertices(Cxy +* Cyz)) by A3,CIRCCMB2:6
     .= ((InputVertices(Cxy) \ InnerVertices(Cyz)) \/
         (InputVertices(Cyz) \ InnerVertices(Cxy))) \ InnerVertices(Czx) \/
         (InputVertices(Czx) \ (InnerVertices(Cxy) \/ InnerVertices(Cyz)))
          by A3,CIRCCOMB:15
     .= ((InputVertices(Cxy) \ {yz}) \/
         (InputVertices(Cyz) \ InnerVertices(Cxy))) \ InnerVertices(Czx) \/
         (InputVertices(Czx) \ (InnerVertices(Cxy) \/ InnerVertices(Cyz)))
          by CIRCCOMB:49
     .= ((InputVertices(Cxy) \ {yz}) \/
         (InputVertices(Cyz) \ {xy})) \ InnerVertices(Czx) \/
         (InputVertices(Czx) \ (InnerVertices(Cxy) \/ InnerVertices(Cyz)))
          by CIRCCOMB:49
     .= ((InputVertices(Cxy) \ {yz}) \/
         (InputVertices(Cyz) \ {xy})) \ {zx} \/
         (InputVertices(Czx) \ (InnerVertices(Cxy) \/ InnerVertices(Cyz)))
          by CIRCCOMB:49
     .= ((InputVertices(Cxy) \ {yz}) \/
         (InputVertices(Cyz) \ {xy})) \ {zx} \/
         (InputVertices(Czx) \ ({xy} \/ InnerVertices(Cyz))) by CIRCCOMB:49
     .= ((InputVertices(Cxy) \ {yz}) \/
         (InputVertices(Cyz) \ {xy})) \ {zx} \/
         (InputVertices(Czx) \ ({xy} \/ {yz})) by CIRCCOMB:49
     .= (({x,y} \ {yz}) \/ (InputVertices(Cyz) \ {xy})) \ {zx} \/
         (InputVertices(Czx) \ ({xy} \/ {yz})) by FACIRC_1:40
     .= (({x,y} \ {yz}) \/ ({y,z} \ {xy})) \ {zx} \/
         (InputVertices(Czx) \ ({xy} \/ {yz})) by FACIRC_1:40
     .= (({x,y} \ {yz}) \/ ({y,z} \ {xy})) \ {zx} \/
         ({z,x} \ ({xy} \/ {yz})) by FACIRC_1:40
     .= (({x,y} \ {yz}) \/ ({y,z} \ {xy})) \ {zx} \/
         ({z,x} \ {xy,yz}) by ENUMSET1:41
     .= (({x,y} \/ ({y,z} \ {xy})) \ {zx}) \/ ({z,x} \ {xy,yz})
          by A1,A4,FACIRC_2:1
     .= ({x,y} \/ {y,z}) \ {zx} \/ ({z,x} \ {xy,yz}) by A5,ZFMISC_1:65
     .= ({x,y} \/ {y,z}) \ {zx} \/ {z,x} by A6,ZFMISC_1:72
     .= {x,y,y,z} \ {zx} \/ {z,x} by ENUMSET1:45
     .= {y,y,x,z} \ {zx} \/ {z,x} by ENUMSET1:110
     .= {y,x,z} \ {zx} \/ {z,x} by ENUMSET1:71
     .= {x,y,z} \ {zx} \/ {z,x} by ENUMSET1:99
     .= {x,y,z} \/ {z,x} by A7,ZFMISC_1:65
     .= {x,y,z,z,x} by ENUMSET1:49
     .= {x,y,z,z} \/ {x} by ENUMSET1:50
     .= {z,z,x,y} \/ {x} by ENUMSET1:118
     .= {z,x,y} \/ {x} by ENUMSET1:71
     .= {z,x,y,x} by ENUMSET1:46
     .= {x,x,y,z} by ENUMSET1:113
     .= {x,y,z} by ENUMSET1:71;
    hence thesis;
   end;

theorem Th127:
 for x,y,z being set st
   x <> [<*y,z*>,and2b] & y <> [<*z,x*>,and2b] & z <> [<*x,y*>,and2b]
  holds InputVertices GFA3CarryStr(x,y,z) = {x,y,z}
   proof
     set f1 = and2b, f2 = and2b, f3 = and2b, f4 = nor3;
     let x,y,z be set;
     set xy = [<*x,y*>,f1], yz = [<*y,z*>,f2], zx = [<*z,x*>,f3];
     set xyz = [<*xy, yz, zx*>,f4];
     set S = 1GateCircStr(<*xy, yz, zx*>,f4);
     set MI = GFA3CarryIStr(x,y,z);
A1:  InnerVertices S = {xyz} by CIRCCOMB:49;
A2:  InputVertices S = rng <*xy, yz, zx*> by CIRCCOMB:49
                    .= {xy, yz, zx} by FINSEQ_2:148;
     assume
A3:  x <> yz & y <> zx & z <> xy;
A4:  {x, y, z} \ {xyz} = {x, y, z} by Lm2;
A5:  {xy, yz, zx} \ {xy, yz, zx} = {} by XBOOLE_1:37;
     GFA3CarryStr(x,y,z) = MI +* S & MI tolerates S by CIRCCOMB:55;
     hence InputVertices GFA3CarryStr(x,y,z)
      = ((InputVertices MI) \ InnerVertices S) \/
         ((InputVertices S) \ InnerVertices MI) by CIRCCMB2:6
     .= {x,y,z} \/ ({xy, yz, zx} \ InnerVertices MI) by A1,A2,A3,A4,Th126
     .= {x,y,z} \/ {} by A5,Th123
     .= {x,y,z};
  end;

theorem Th128:
 for x,y,z being non pair set holds
  InputVertices GFA3CarryStr(x,y,z) is without_pairs
   proof
     set f1 = and2b, f2 = and2b, f3 = and2b, f4 = nor3;
     let x,y,z be non pair set;
     set xy = [<*x,y*>,f1], yz = [<*y,z*>,f2], zx = [<*z,x*>,f3];
     set Cxy = 1GateCircStr(<*x,y*>,f1);
     set Cyz = 1GateCircStr(<*y,z*>,f2);
     set Czx = 1GateCircStr(<*z,x*>,f3);
     set S = 1GateCircStr(<*xy, yz, zx*>,f4);
     set M = GFA3CarryStr(x,y,z);
     set MI = GFA3CarryIStr(x,y,z);
A1:  InputVertices Cxy is without_pairs & InputVertices Cyz is without_pairs &
     InputVertices Czx is without_pairs by FACIRC_1:41;
then InputVertices (Cxy+*Cyz) is without_pairs by FACIRC_1:9;
then A2: InputVertices MI is without_pairs by A1,FACIRC_1:9;
     InnerVertices S is Relation by FACIRC_1:38;
then A3: InputVertices M = (InputVertices MI) \/
          (InputVertices S \ InnerVertices MI) by A2,FACIRC_1:6;
     given xx being pair set such that
A4:  xx in InputVertices M;
A5:  InputVertices S = {xy, yz, zx} by FACIRC_1:42;
A6:  InnerVertices Cxy = {xy} & InnerVertices Cyz = {yz} &
     InnerVertices Czx = {zx} by CIRCCOMB:49;
     Cxy tolerates Cyz & Cxy tolerates Czx & Cyz tolerates Czx by CIRCCOMB:55;
then A7: InnerVertices (Cxy +* Cyz) = {xy} \/ {yz} by A6,CIRCCOMB:15;
     Cxy +* Cyz tolerates Czx by CIRCCOMB:55;
then InnerVertices MI = {xy} \/ {yz} \/ {zx} by A6,A7,CIRCCOMB:15
     .= {xy, yz} \/ {zx} by ENUMSET1:41
     .= {xy, yz, zx} by ENUMSET1:43;
then InputVertices S \ InnerVertices MI = {} by A5,XBOOLE_1:37;
    hence thesis by A2,A3,A4,FACIRC_1:def 2;
  end;

::-------------------------------------------------------
:: Carrier and misc.

theorem Th129:
  for x,y,z being set holds
    x in the carrier of GFA3CarryStr(x,y,z) &
    y in the carrier of GFA3CarryStr(x,y,z) &
    z in the carrier of GFA3CarryStr(x,y,z) &
    [<*x,y*>,and2b] in the carrier of GFA3CarryStr(x,y,z) &
    [<*y,z*>,and2b] in the carrier of GFA3CarryStr(x,y,z) &
    [<*z,x*>,and2b] in the carrier of GFA3CarryStr(x,y,z) &
    [<*[<*x,y*>,and2b],[<*y,z*>,and2b],[<*z,x*>,and2b]*>,nor3]
                    in the carrier of GFA3CarryStr(x,y,z)
   proof
     set f1 = and2b, f2 = and2b, f3 = and2b, f4 = nor3;
     let x,y,z be set;
     set xy = [<*x,y*>,f1], yz = [<*y,z*>,f2], zx = [<*z,x*>,f3];
     set xyz = [<*xy, yz, zx*>,f4];
     set Cxy = 1GateCircStr(<*x,y*>,f1);
     set Cyz = 1GateCircStr(<*y,z*>,f2);
     set Czx = 1GateCircStr(<*z,x*>,f3);
     set Cxyz = 1GateCircStr(<*xy, yz, zx*>,f4);
     y in the carrier of Cxy by FACIRC_1:43;
then A1: y in the carrier of Cxy +* Cyz by FACIRC_1:20;
     x in the carrier of Czx & z in the carrier of Czx by FACIRC_1:43;
then A2: x in the carrier of GFA3CarryIStr(x,y,z) &
         y in the carrier of GFA3CarryIStr(x,y,z) &
         z in the carrier of GFA3CarryIStr(x,y,z) by A1,FACIRC_1:20;
     xy in the carrier of Cxy & yz in the carrier of Cyz by FACIRC_1:43;
then A3: xy in the carrier of Cxy +* Cyz & yz in the carrier of Cxy +* Cyz
       by FACIRC_1:20;
     zx in the carrier of Czx by FACIRC_1:43;
then A4: xy in the carrier of GFA3CarryIStr(x,y,z) &
         yz in the carrier of GFA3CarryIStr(x,y,z) &
         zx in the carrier of GFA3CarryIStr(x,y,z) by A3,FACIRC_1:20;
     set p = <*xy,yz,zx*>;
     the carrier of Cxyz = rng p \/ {xyz} & [p,f4] in {[p,f4]}
       by CIRCCOMB:def 6,TARSKI:def 1;
then xyz in the carrier of Cxyz by XBOOLE_0:def 2;
    hence thesis by A2,A4,FACIRC_1:20;
  end;

theorem Th130:
 for x,y,z being set holds
   [<*x,y*>,and2b] in InnerVertices GFA3CarryStr(x,y,z) &
   [<*y,z*>,and2b] in InnerVertices GFA3CarryStr(x,y,z) &
   [<*z,x*>,and2b] in InnerVertices GFA3CarryStr(x,y,z) &
   GFA3CarryOutput(x,y,z) in InnerVertices GFA3CarryStr(x,y,z)
   proof
     set f1 = and2b, f2 = and2b, f3 = and2b;
     let x,y,z be set;
     set xy = [<*x,y*>,f1], yz = [<*y,z*>,f2], zx = [<*z,x*>,f3];
     InnerVertices GFA3CarryStr(x,y,z)
       = {xy,yz,zx} \/ {GFA3CarryOutput(x,y,z)} by Th124
      .= {xy,yz,zx,GFA3CarryOutput(x,y,z)} by ENUMSET1:46;
    hence thesis by ENUMSET1:def 2;
  end;

theorem Th131:
  for x,y,z being set st
     x <> [<*y,z*>,and2b] & y <> [<*z,x*>,and2b] & z <> [<*x,y*>,and2b]
   holds
    x in InputVertices GFA3CarryStr(x,y,z) &
    y in InputVertices GFA3CarryStr(x,y,z) &
    z in InputVertices GFA3CarryStr(x,y,z)
   proof
     set f1 = and2b, f2 = and2b, f3 = and2b;
     let x,y,z be set such that
A1:  x <> [<*y,z*>,f2] & y <> [<*z,x*>,f3] & z <> [<*x,y*>,f1];
     InputVertices GFA3CarryStr(x,y,z) = {x,y,z} by A1,Th127;
    hence thesis by ENUMSET1:def 1;
  end;

theorem Th132:
 for x,y,z being non pair set holds
  InputVertices GFA3CarryStr(x,y,z) = {x,y,z}
   proof
     set f1 = and2b, f2 = and2b, f3 = and2b, f4 = nor3;
     let x,y,z be non pair set;
     set xy = [<*x,y*>,f1], yz = [<*y,z*>,f2], zx = [<*z,x*>,f3];
     set Cxy = 1GateCircStr(<*x,y*>,f1);
     set Cyz = 1GateCircStr(<*y,z*>,f2);
     set Czx = 1GateCircStr(<*z,x*>,f3);
     set M = GFA3CarryStr(x,y,z);
     set MI = GFA3CarryIStr(x,y,z);
     set S = 1GateCircStr(<*xy,yz,zx*>,f4);
A1:  InputVertices Cxy is without_pairs &
     InputVertices Cyz is without_pairs &
     InputVertices Czx is without_pairs by FACIRC_1:41;
then A2: InputVertices (Cxy+*Cyz) is without_pairs by FACIRC_1:9;
then A3: InputVertices MI is without_pairs by A1,FACIRC_1:9;
A4:  InputVertices Cxy = {x,y} & InputVertices Cyz = {y,z} &
     InputVertices Czx = {z,x} by FACIRC_1:40;
     InnerVertices S is Relation by FACIRC_1:38;
then A5: InputVertices M =
      (InputVertices MI) \/ (InputVertices S \ InnerVertices MI)
       by A3,FACIRC_1:6;
A6:  InputVertices S = {xy, yz, zx} by FACIRC_1:42;
A7:  InnerVertices Cxy = {xy} & InnerVertices Cyz = {yz} &
     InnerVertices Czx = {zx} by CIRCCOMB:49;
     Cxy tolerates Cyz & Cxy tolerates Czx & Cyz tolerates Czx by CIRCCOMB:55;
then A8: InnerVertices (Cxy +* Cyz) = {xy} \/ {yz} by A7,CIRCCOMB:15;
     Cxy +* Cyz tolerates Czx by CIRCCOMB:55;
then InnerVertices MI = {xy} \/ {yz} \/ {zx} by A7,A8,CIRCCOMB:15
      .= {xy, yz} \/ {zx} by ENUMSET1:41
      .= {xy, yz, zx} by ENUMSET1:43;
then InputVertices S \ InnerVertices MI = {} by A6,XBOOLE_1:37;
     hence InputVertices M
       = (InputVertices(Cxy+*Cyz)) \/ InputVertices Czx
          by A1,A2,A7,A8,A5,FACIRC_1:7
      .= (InputVertices Cxy) \/ (InputVertices Cyz) \/ (InputVertices Czx)
          by A1,A7,FACIRC_1:7
      .= {x,y,y,z} \/ {z,x} by A4,ENUMSET1:45
      .= {y,y,x,z} \/ {z,x} by ENUMSET1:110
      .= {y,x,z} \/ {z,x} by ENUMSET1:71
      .= {x,y,z} \/ {z,x} by ENUMSET1:99
      .= {x,y,z} \/ ({z}\/{x}) by ENUMSET1:41
      .= {x,y,z} \/ {z} \/ {x} by XBOOLE_1:4
      .= {z,x,y} \/ {z} \/ {x} by ENUMSET1:100
      .= {z,z,x,y} \/ {x} by ENUMSET1:44
      .= {z,x,y} \/ {x} by ENUMSET1:71
      .= {x,y,z} \/ {x} by ENUMSET1:100
      .= {x,x,y,z} by ENUMSET1:44
      .= {x,y,z} by ENUMSET1:71;
  end;

::----------------------------------------------------
:: GFA3 Carry : Stability of the Carry Output Circuit
::----------------------------------------------------

theorem Th133:
 for x,y,z being set for s being State of GFA3CarryCirc(x,y,z)
  for a1,a2,a3 being Element of BOOLEAN st a1 = s.x & a2 = s.y & a3 = s.z
   holds
    (Following s).[<*x,y*>,and2b] = 'not' a1 '&' 'not' a2 &
    (Following s).[<*y,z*>,and2b] = 'not' a2 '&' 'not' a3 &
    (Following s).[<*z,x*>,and2b] = 'not' a3 '&' 'not' a1
   proof
     set f1 = and2b, f2 = and2b, f3 = and2b;
     let x,y,z be set;
     let s be State of GFA3CarryCirc(x,y,z);
     set xy = [<*x,y*>,f1], yz = [<*y,z*>,f2], zx = [<*z,x*>,f3];
     let a1,a2,a3 be Element of BOOLEAN such that
A1:  a1 = s.x & a2 = s.y & a3 = s.z;
     set S = GFA3CarryStr(x,y,z);
A2:  InnerVertices S = the OperSymbols of S by FACIRC_1:37;
A3:  dom s = the carrier of S by CIRCUIT1:4;
A4:  x in the carrier of S & y in the carrier of S & z in the carrier of S
      by Th129;
     xy in InnerVertices GFA3CarryStr(x,y,z) by Th130;
     hence (Following s).[<*x,y*>,f1] = f1.(s*<*x,y*>) by A2,FACIRC_1:35
         .= f1.<*a1,a2*> by A1,A3,A4,FINSEQ_2:145
         .= 'not' a1 '&' 'not' a2 by TWOSCOMP:def 3;
     yz in InnerVertices GFA3CarryStr(x,y,z) by Th130;
     hence (Following s).[<*y,z*>,f2] = f2.(s*<*y,z*>) by A2,FACIRC_1:35
         .= f2.<*a2,a3*> by A1,A3,A4,FINSEQ_2:145
         .= 'not' a2 '&' 'not' a3 by TWOSCOMP:def 3;
     zx in InnerVertices GFA3CarryStr(x,y,z) by Th130;
     hence (Following s).[<*z,x*>,f3] = f3.(s*<*z,x*>) by A2,FACIRC_1:35
         .= f3.<*a3,a1*> by A1,A3,A4,FINSEQ_2:145
         .= 'not' a3 '&' 'not' a1 by TWOSCOMP:def 3;
  end;

theorem Th134:
 for x,y,z being set for s being State of GFA3CarryCirc(x,y,z)
  for a1,a2,a3 being Element of BOOLEAN st
    a1 = s.[<*x,y*>,and2b] & a2 = s.[<*y,z*>,and2b] & a3 = s.[<*z,x*>,and2b]
   holds
    (Following s).GFA3CarryOutput(x,y,z) = 'not' (a1 'or' a2 'or' a3)
   proof
     set f1 = and2b, f2 = and2b, f3 = and2b, f4 = nor3;
     let x,y,z be set;
     let s be State of GFA3CarryCirc(x,y,z);
     set xy =[<*x,y*>,f1], yz = [<*y,z*>,f2], zx = [<*z,x*>,f3];
     let a1,a2,a3 be Element of BOOLEAN such that
A1:  a1 = s.xy & a2 = s.yz & a3 = s.zx;
     set S = GFA3CarryStr(x,y,z);
A2:  InnerVertices S = the OperSymbols of S by FACIRC_1:37;
A3:  dom s = the carrier of S by CIRCUIT1:4;
     reconsider xy, yz, zx as Element of InnerVertices S by Th130;
     thus (Following s).GFA3CarryOutput(x,y,z)
          = f4.(s*<*xy, yz, zx*>) by A2,FACIRC_1:35
         .= f4.<*a1,a2,a3*> by A1,A3,FINSEQ_2:146
         .= 'not' (a1 'or' a2 'or' a3) by TWOSCOMP:def 28;
  end;

theorem Th135:
  for x,y,z being set st
    x <> [<*y,z*>,and2b] & y <> [<*z,x*>,and2b] & z <> [<*x,y*>,and2b]
   for s being State of GFA3CarryCirc(x,y,z)
    for a1,a2,a3 being Element of BOOLEAN st a1 = s.x & a2 = s.y & a3 = s.z
     holds
      Following(s,2).GFA3CarryOutput(x,y,z) =
          'not' (('not' a1 '&' 'not' a2) 'or' ('not' a2 '&' 'not' a3) 'or'
                 ('not' a3 '&' 'not' a1)) &
      Following(s,2).[<*x,y*>,and2b] = 'not' a1 '&' 'not' a2 &
      Following(s,2).[<*y,z*>,and2b] = 'not' a2 '&' 'not' a3 &
      Following(s,2).[<*z,x*>,and2b] = 'not' a3 '&' 'not' a1
   proof
     set f1 = and2b, f2 = and2b, f3 = and2b;
     let x,y,z be set such that
A1:  x <> [<*y,z*>,f2] & y <> [<*z,x*>,f3] & z <> [<*x,y*>,f1];
     set xy = [<*x,y*>,f1], yz = [<*y,z*>,f2], zx = [<*z,x*>,f3];
     let s be State of GFA3CarryCirc(x,y,z);
     let a1,a2,a3 be Element of BOOLEAN such that
A2:  a1 = s.x & a2 = s.y & a3 = s.z;
     set S = GFA3CarryStr(x,y,z);
     reconsider x' = x, y' = y, z' = z as Vertex of S by Th129;
     x in InputVertices S & y in InputVertices S & z in InputVertices S
     by A1,Th131;
then A3: (Following s).x' = s.x & (Following s).y' = s.y &
         (Following s).z' = s.z by CIRCUIT2:def 5;
A4:  Following(s,2) = Following Following s by FACIRC_1:15;
     (Following s).xy = 'not' a1 '&' 'not' a2 &
     (Following s).yz = 'not' a2 '&' 'not' a3 &
     (Following s).zx = 'not' a3 '&' 'not' a1 by A2,Th133;
    hence Following(s,2).GFA3CarryOutput(x,y,z) =
    'not'(('not' a1 '&' 'not' a2) 'or' ('not' a2 '&' 'not' a3) 'or'
          ('not' a3 '&' 'not' a1)) by A4,Th134;
    thus thesis by A2,A3,A4,Th133;
  end;

theorem Th136:
  for x,y,z being set st
     x <> [<*y,z*>,and2b] & y <> [<*z,x*>,and2b] & z <> [<*x,y*>,and2b]
   for s being State of GFA3CarryCirc(x,y,z)
    holds Following(s,2) is stable
   proof
     set f1 = and2b, f2 = and2b, f3 = and2b, f4 = nor3;
     let x,y,z be set such that
A1:  x <> [<*y,z*>,f2] & y <> [<*z,x*>,f3] & z <> [<*x,y*>,f1];
     set xy = [<*x,y*>,f1], yz = [<*y,z*>,f2], zx = [<*z,x*>,f3];
     set xyz = [<*xy, yz, zx*>,f4];
     let s be State of GFA3CarryCirc(x,y,z);
     set S = GFA3CarryStr(x,y,z);
A2:  dom Following Following(s,2) = the carrier of S &
     dom Following(s,2) = the carrier of S by CIRCUIT1:4;
     reconsider xx = x, yy = y, zz = z as Vertex of S by Th129;
     set a1 = s.xx, a2 = s.yy, a3 = s.zz;
     set ffs = Following(s,2), fffs = Following ffs;
     a1 = s.x & a2 = s.y & a3 = s.z;
then A3: ffs.GFA3CarryOutput(x,y,z) =
         'not'(('not' a1 '&' 'not' a2) 'or' ('not' a2 '&' 'not' a3) 'or'
               ('not' a3 '&' 'not' a1)) &
     ffs.xy = 'not' a1 '&' 'not' a2 &
     ffs.yz = 'not' a2 '&' 'not' a3 &
     ffs.zx = 'not' a1 '&' 'not' a3 by A1,Th135;
A4:  ffs = Following Following s by FACIRC_1:15;
A5:  x in InputVertices S & y in InputVertices S & z in InputVertices S
      by A1,Th131;
then (Following s).x = a1 & (Following s).y = a2 & (Following s).z = a3
      by CIRCUIT2:def 5;
then A6: ffs.x = a1 & ffs.y = a2 & ffs.z = a3 by A4,A5,CIRCUIT2:def 5;
     now let a be set; assume
A7:  a in the carrier of S;
then reconsider v = a as Vertex of S;
A8:  v in InputVertices S \/ InnerVertices S by A7,XBOOLE_1:45;
     thus ffs.a = (fffs).a
      proof per cases by A8,XBOOLE_0:def 2;
        suppose v in InputVertices S;
          hence thesis by CIRCUIT2:def 5;
        end;
        suppose v in InnerVertices S;
           then v in {xy, yz, zx} \/ {GFA3CarryOutput(x,y,z)} by Th124;
           then v in {xy, yz, zx} or
                v in {GFA3CarryOutput(x,y,z)} by XBOOLE_0:def 2;
           then v = xy or v = yz or v = zx or
                v = GFA3CarryOutput(x,y,z) by ENUMSET1:def 1,TARSKI:def 1;
          hence thesis by A3,A6,Th133,Th134;
        end;
      end;
     end;
    hence ffs = fffs by A2,FUNCT_1:9;
  end;

::=========================================================================

::-------------------------------------------------
:: GFA3 Adder : Circuit Definition of Adder Output
::-------------------------------------------------

definition
 let x,y,z be set;
 func GFA3AdderStr(x,y,z) ->
      unsplit gate`1=arity gate`2isBoolean
      non void strict non empty ManySortedSign equals
   2GatesCircStr(x,y,z, xor2);
  coherence;
end;

definition
 let x,y,z be set;
 func GFA3AdderCirc(x,y,z) ->
      strict Boolean gate`2=den Circuit of GFA3AdderStr(x,y,z) equals
   2GatesCircuit(x,y,z, xor2);
  coherence;
end;

definition
 let x,y,z be set;
 func GFA3AdderOutput(x,y,z) ->
      Element of InnerVertices GFA3AdderStr(x,y,z) equals
   2GatesCircOutput(x,y,z, xor2);
  coherence;
end;

::-------------------------------------------------------
:: GFA3 Adder : Carrier, InnerVertices and InputVertices
::-------------------------------------------------------

::-------------------------------------------------------
:: InnerVertices

theorem Th137:
 for x,y,z being set holds
  InnerVertices GFA3AdderStr(x,y,z) =
    {[<*x,y*>,xor2]} \/ {GFA3AdderOutput(x,y,z)}
   proof
     let x,y,z be set;
     set S3 = GFA3AdderStr(x,y,z), O3 = GFA3AdderOutput(x,y,z);
     set S0 = GFA0AdderStr(x,y,z), O0 = GFA0AdderOutput(x,y,z);
     S3 = S0 & O3 = O0;
    hence thesis by Th27;
   end;

theorem
 for x,y,z being set holds
  InnerVertices GFA3AdderStr(x,y,z) is Relation by FACIRC_1:58;

::-------------------------------------------------------
:: InputVertices

theorem
 for x,y,z being set st z <> [<*x,y*>,xor2] holds
  InputVertices GFA3AdderStr(x,y,z) = {x,y,z} by FACIRC_1:57;

theorem
 for x,y,z being non pair set holds
  InputVertices GFA3AdderStr(x,y,z) is without_pairs by FACIRC_1:59;

::-------------------------------------------------------
:: Carrier and misc.

theorem
 for x,y,z being set holds
   x in the carrier of GFA3AdderStr(x,y,z) &
   y in the carrier of GFA3AdderStr(x,y,z) &
   z in the carrier of GFA3AdderStr(x,y,z) &
   [<*x,y*>,xor2] in the carrier of GFA3AdderStr(x,y,z) &
   [<*[<*x,y*>,xor2], z*>, xor2] in the carrier of GFA3AdderStr(x,y,z)
   by FACIRC_1:60,61;

theorem
 for x,y,z being set holds
   [<*x,y*>,xor2] in InnerVertices GFA3AdderStr(x,y,z) &
   GFA3AdderOutput(x,y,z) in InnerVertices GFA3AdderStr(x,y,z)
   proof
     let x,y,z be set;
     set S0 = GFA0AdderStr(x,y,z);
     GFA3AdderStr(x,y,z) = S0;
    hence thesis by Th32;
   end;

theorem
 for x,y,z being set st z <> [<*x,y*>, xor2] holds
    x in InputVertices GFA3AdderStr(x,y,z) &
    y in InputVertices GFA3AdderStr(x,y,z) &
    z in InputVertices GFA3AdderStr(x,y,z)
   proof
     let x,y,z be set such that
A1:  z <> [<*x,y*>,xor2];
     set S0 = GFA0AdderStr(x,y,z);
     GFA3AdderStr(x,y,z) = S0;
     hence thesis by A1,Th33;
   end;

theorem
 for x,y,z being non pair set holds
   InputVertices GFA3AdderStr(x,y,z) = {x,y,z} by FACIRC_1:57;

::----------------------------------------------------
:: GFA3 Adder : Stability of the Adder Output Circuit
::----------------------------------------------------

theorem
 for x,y,z being set st z <> [<*x,y*>, xor2]
  for s being State of GFA3AdderCirc(x,y,z)
   for a1,a2,a3 being Element of BOOLEAN st a1 = s.x & a2 = s.y & a3 = s.z
     holds
      (Following s).[<*x,y*>,xor2] = a1 'xor' a2 &
      (Following s).x = a1 & (Following s).y = a2 & (Following s).z = a3
   proof
     set f = xor2;
     let x,y,z be set such that
A1:  z <> [<*x,y*>,f];
     set A3 = GFA3AdderCirc(x,y,z);
     set A0 = GFA0AdderCirc(x,y,z);
     A3 = A0;
     hence thesis by A1,Th35;
   end;

theorem
 for x,y,z being set st z <> [<*x,y*>, xor2]
  for s being State of GFA3AdderCirc(x,y,z)
   for a1a2,a1,a2,a3 being Element of BOOLEAN
     st a1a2 = s.[<*x,y*>,xor2] & a1 = s.x & a2 = s.y & a3 = s.z
    holds
     (Following s).GFA3AdderOutput(x,y,z) = a1a2 'xor' a3
   proof
     set f = xor2;
     let x,y,z be set such that
A1:  z <> [<*x,y*>,f];
     set A3 = GFA3AdderCirc(x,y,z);
     set A0 = GFA0AdderCirc(x,y,z);
     set O3 = GFA3AdderOutput(x,y,z);
     set O0 = GFA0AdderOutput(x,y,z);
     A3 = A0 & O3 = O0;
     hence thesis by A1,Th36;
   end;

theorem Th147:
 for x,y,z being set st z <> [<*x,y*>, xor2]
  for s being State of GFA3AdderCirc(x,y,z)
   for a1,a2,a3 being Element of BOOLEAN st a1 = s.x & a2 = s.y & a3 = s.z
    holds
     Following(s,2).GFA3AdderOutput(x,y,z) = a1 'xor' a2 'xor' a3 &
     Following(s,2).[<*x,y*>,xor2] = a1 'xor' a2 &
     Following(s,2).x = a1 & Following(s,2).y = a2 & Following(s,2).z = a3
   proof
     set f = xor2;
     let x,y,z be set such that
A1:  z <> [<*x,y*>,f];
     set A3 = GFA3AdderCirc(x,y,z);
     set A0 = GFA0AdderCirc(x,y,z);
     set O3 = GFA3AdderOutput(x,y,z);
     set O0 = GFA0AdderOutput(x,y,z);
     A3 = A0 & O3 = O0;
     hence thesis by A1,Th37;
   end;

theorem Th148:
  for x,y,z being set st z <> [<*x,y*>, xor2]
   for s being State of GFA3AdderCirc(x,y,z)
    for a1,a2,a3 being Element of BOOLEAN st a1 = s.x & a2 = s.y & a3 = s.z
     holds
      Following(s,2).GFA3AdderOutput(x,y,z)
         = 'not' ('not' a1 'xor' 'not' a2 'xor' 'not' a3)
   proof
     set f = xor2;
     let x,y,z be set such that
A1:  z <> [<*x,y*>,f];
     set xy = [<*x,y*>,f];
     set A = GFA3AdderCirc(x,y,z);
     let s be State of A;
     let a1,a2,a3 be Element of BOOLEAN such that
A2:  a1 = s.x & a2 = s.y & a3 = s.z;
     thus (Following(s,2)).GFA3AdderOutput(x,y,z)
         = a1 'xor' a2 'xor' a3 by A1,A2,Th147
        .= 'not' ('not' a1 'xor' 'not' a2 'xor' 'not' a3) by Th11;
   end;

theorem
 for x,y,z being set st z <> [<*x,y*>,xor2]
  for s being State of GFA3AdderCirc(x,y,z)
    holds Following(s,2) is stable by FACIRC_1:63;

::=====================================================================

::---------------------------------------------------
:: GFA3 : Circuit Definition of GFA Combined Circuit
::---------------------------------------------------

definition
 let x,y,z be set;
 func BitGFA3Str(x,y,z) ->
      unsplit gate`1=arity gate`2isBoolean
      non void strict non empty ManySortedSign equals
    GFA3AdderStr(x,y,z) +* GFA3CarryStr(x,y,z);
  coherence;
end;

definition
 let x,y,z be set;
 func BitGFA3Circ(x,y,z) ->
   strict Boolean gate`2=den Circuit of BitGFA3Str(x,y,z) equals
   GFA3AdderCirc(x,y,z) +* GFA3CarryCirc(x,y,z);
  coherence;
end;

::----------------------------------------------------------
:: GFA3 Combined : Carrier, InnerVertices and InputVertices
::----------------------------------------------------------

::-------------------------------------------------------
:: InnerVertices

theorem Th150:
  for x,y,z being set holds
   InnerVertices BitGFA3Str(x,y,z) =
     {[<*x,y*>,xor2]} \/ {GFA3AdderOutput(x,y,z)} \/
     {[<*x,y*>,and2b], [<*y,z*>,and2b], [<*z,x*>,and2b]} \/
     {GFA3CarryOutput(x,y,z)}
   proof
     set f0 = xor2;
     set f1 = and2b, f2 = and2b, f3 = and2b;
     let x,y,z be set;
     set xyf0 = [<*x,y*>,f0];
     set xyf1 = [<*x,y*>,f1], yzf2 = [<*y,z*>,f2], zxf3 = [<*z,x*>,f3];
     set S = BitGFA3Str(x,y,z);
     set S1 = GFA3AdderStr(x,y,z);
     set S2 = GFA3CarryStr(x,y,z);
     set A1 = GFA3AdderOutput(x,y,z);
     set A2 = GFA3CarryOutput(x,y,z);
     thus InnerVertices S
       = (InnerVertices S1) \/ InnerVertices S2 by FACIRC_1:27
      .= {xyf0} \/ {A1} \/ InnerVertices S2 by Th137
      .= {xyf0} \/ {A1} \/ ({xyf1, yzf2, zxf3} \/ {A2}) by Th124
      .= {xyf0} \/ {A1} \/ {xyf1, yzf2, zxf3} \/ {A2} by XBOOLE_1:4;
   end;

theorem
 for x,y,z being set holds
   InnerVertices BitGFA3Str(x,y,z) is Relation
   proof
     let x,y,z be set;
     set S1 = GFA3AdderStr(x,y,z);
     set S2 = GFA3CarryStr(x,y,z);
     InnerVertices S1 is Relation & InnerVertices S2 is Relation
       by FACIRC_1:58,Th125;
     hence thesis by FACIRC_1:3;
  end;

::-------------------------------------------------------
:: InputVertices

theorem Th152:
  for x,y,z being set  st z <> [<*x,y*>,xor2] &
    x <> [<*y,z*>,and2b] & y <> [<*z,x*>,and2b] & z <> [<*x,y*>,and2b]
   holds
    InputVertices BitGFA3Str(x,y,z) = {x,y,z}
   proof
     set f0 = xor2;
     set f1 = and2b, f2 = and2b, f3 = and2b;
     let x,y,z be set such that
A1:  z <> [<*x,y*>,f0] and
A2:  x <> [<*y,z*>,f2] & y <> [<*z,x*>,f3] & z <> [<*x,y*>,f1];
     set S = BitGFA3Str(x,y,z);
     set S1 = GFA3AdderStr(x,y,z);
     set S2 = GFA3CarryStr(x,y,z);
A3:  InputVertices S1 = {x,y,z} by A1,FACIRC_1:57;
A4:  InputVertices S2 = {x,y,z} by A2,Th127;
     S1 tolerates S2 by CIRCCOMB:55;
    hence InputVertices S = {x,y,z} by A3,A4,FACIRC_2:22;
   end;

theorem Th153:
 for x,y,z being non pair set holds
    InputVertices BitGFA3Str(x,y,z) = {x,y,z}
   proof
     let x,y,z be non pair set;
     set S = BitGFA3Str(x,y,z);
     set S1 = GFA3AdderStr(x,y,z);
     set S2 = GFA3CarryStr(x,y,z);
A1:  InputVertices S1 is without_pairs & InnerVertices S1 is Relation
      by FACIRC_1:58,FACIRC_1:59;
A2:  InputVertices S2 is without_pairs & InnerVertices S2 is Relation
      by Th125,Th128;
     InputVertices S1 = {x,y,z} & InputVertices S2 = {x,y,z}
      by FACIRC_1:57,Th132;
    hence InputVertices S = {x,y,z} \/ {x,y,z} by A1,A2,FACIRC_1:7
                         .= {x,y,z};
  end;

theorem
 for x,y,z being non pair set holds
   InputVertices BitGFA3Str(x,y,z) is without_pairs
   proof
     let x,y,z be non pair set;
     InputVertices BitGFA3Str(x,y,z) = {x,y,z} by Th153;
     hence thesis;
   end;

::-------------------------------------------------------
:: Carrier and misc.

theorem
 for x,y,z being set holds
    x in the carrier of BitGFA3Str(x,y,z) &
    y in the carrier of BitGFA3Str(x,y,z) &
    z in the carrier of BitGFA3Str(x,y,z) &
    [<*x,y*>,xor2] in the carrier of BitGFA3Str(x,y,z) &
    [<*[<*x,y*>,xor2],z*>,xor2] in the carrier of BitGFA3Str(x,y,z) &
    [<*x,y*>,and2b] in the carrier of BitGFA3Str(x,y,z) &
    [<*y,z*>,and2b] in the carrier of BitGFA3Str(x,y,z) &
    [<*z,x*>,and2b] in the carrier of BitGFA3Str(x,y,z) &
    [<*[<*x,y*>,and2b],[<*y,z*>,and2b],[<*z,x*>,and2b]*>,nor3]
                                in the carrier of BitGFA3Str(x,y,z)
   proof
     set f0 = xor2;
     set f1 = and2b, f2 = and2b, f3 = and2b, f4 = nor3;
     let x,y,z be set;
     set xy = [<*x,y*>,f1], yz = [<*y,z*>,f2], zx = [<*z,x*>,f3];
     set xyz = [<*xy, yz, zx*>,f4];
     set S1 = GFA3AdderStr(x,y,z);
     set S2 = GFA3CarryStr(x,y,z);
A1:  x in the carrier of S1 & y in the carrier of S1 &
     z in the carrier of S1 &
     [<*x,y*>,f0] in the carrier of S1 &
     [<*[<*x,y*>,f0],z*>,f0] in the carrier of S1 by FACIRC_1:60,61;
     xy in the carrier of S2 & yz in the carrier of S2 &
     zx in the carrier of S2 &
     xyz in the carrier of S2 by Th129;
    hence thesis by A1,FACIRC_1:20;
  end;

theorem Th156:
  for x,y,z being set holds
    [<*x,y*>,xor2] in InnerVertices BitGFA3Str(x,y,z) &
    GFA3AdderOutput(x,y,z) in InnerVertices BitGFA3Str(x,y,z) &
    [<*x,y*>,and2b] in InnerVertices BitGFA3Str(x,y,z) &
    [<*y,z*>,and2b] in InnerVertices BitGFA3Str(x,y,z) &
    [<*z,x*>,and2b] in InnerVertices BitGFA3Str(x,y,z) &
    GFA3CarryOutput(x,y,z) in InnerVertices BitGFA3Str(x,y,z)
   proof
     set f0 = xor2;
     set f1 = and2b, f2 = and2b, f3 = and2b;
     let x,y,z be set;
     set xyf0 = [<*x,y*>,f0];
     set xyf1 = [<*x,y*>,f1], yzf2 = [<*y,z*>,f2], zxf3 = [<*z,x*>,f3];
     set S = BitGFA3Str(x,y,z);
     set A1 = GFA3AdderOutput(x,y,z);
     set A2 = GFA3CarryOutput(x,y,z);
     InnerVertices S
       = {xyf0} \/ {A1} \/ {xyf1,yzf2,zxf3} \/ {A2} by Th150
      .= {xyf0,A1} \/ {xyf1,yzf2,zxf3} \/ {A2} by ENUMSET1:41
      .= {xyf0,A1,xyf1,yzf2,zxf3} \/ {A2} by ENUMSET1:48
      .= {xyf0,A1,xyf1,yzf2,zxf3,A2} by ENUMSET1:55;
     hence thesis by ENUMSET1:def 4;
   end;

theorem
  for x,y,z being set  st z <> [<*x,y*>,xor2] &
    x <> [<*y,z*>,and2b] & y <> [<*z,x*>,and2b] & z <> [<*x,y*>,and2b]
   holds
    x in InputVertices BitGFA3Str(x,y,z) &
    y in InputVertices BitGFA3Str(x,y,z) &
    z in InputVertices BitGFA3Str(x,y,z)
   proof
     set f0 = xor2;
     set f1 = and2b, f2 = and2b, f3 = and2b;
     let x,y,z be set such that
A1:  z <> [<*x,y*>,f0] &
     x <> [<*y,z*>,f2] & y <> [<*z,x*>,f3] & z <> [<*x,y*>,f1];
     set S = BitGFA3Str(x,y,z);
     InputVertices S = {x,y,z} by A1,Th152;
    hence thesis by ENUMSET1:def 1;
   end;

::------------------------------------------------------------------
:: GFA3 : Carry and Adder Output Definition of GFA Combined Circuit
::------------------------------------------------------------------

definition
 let x,y,z be set;
 func BitGFA3CarryOutput(x,y,z) ->
         Element of InnerVertices BitGFA3Str(x,y,z) equals
    [<*[<*x,y*>,and2b],[<*y,z*>,and2b],[<*z,x*>,and2b]*>,nor3];
  coherence
    proof
      GFA3CarryOutput(x,y,z)
        in InnerVertices BitGFA3Str(x,y,z) by Th156;
      hence thesis;
    end;
end;

definition
 let x,y,z be set;
 func BitGFA3AdderOutput(x,y,z) ->
         Element of InnerVertices BitGFA3Str(x,y,z) equals
    2GatesCircOutput(x,y,z, xor2);
  coherence
    proof
      GFA3AdderOutput(x,y,z)
        in InnerVertices BitGFA3Str(x,y,z) by Th156;
      hence thesis;
    end;
end;

::-------------------------------------------------------------
:: GFA3 Combined : Stability of the Adder/Carry Output Circuit
::-------------------------------------------------------------

theorem
  for x,y,z being set st z <> [<*x,y*>,xor2] &
    x <> [<*y,z*>,and2b] & y <> [<*z,x*>,and2b] & z <> [<*x,y*>,and2b]
   for s being State of BitGFA3Circ(x,y,z)
    for a1,a2,a3 being Element of BOOLEAN st a1 = s.x & a2 = s.y & a3 = s.z
     holds
      Following(s,2).GFA3AdderOutput(x,y,z)
           = 'not' ('not' a1 'xor' 'not' a2 'xor' 'not' a3) &
      Following(s,2).GFA3CarryOutput(x,y,z)
           = 'not' (('not' a1 '&' 'not' a2) 'or' ('not' a2 '&' 'not' a3) 'or'
                    ('not' a3 '&' 'not' a1))
   proof
     set f0 = xor2;
     set f1 = and2b, f2 = and2b, f3 = and2b;
     let x,y,z be set such that
A1:  z <> [<*x,y*>,f0] &
     x <> [<*y,z*>,f2] & y <> [<*z,x*>,f3] & z <> [<*x,y*>,f1];
     set S = BitGFA3Str(x,y,z);
     set S1 = GFA3AdderStr(x,y,z);
     set S2 = GFA3CarryStr(x,y,z);
     set A = BitGFA3Circ(x,y,z);
     set A1 = GFA3AdderCirc(x,y,z);
     set A2 = GFA3CarryCirc(x,y,z);
     let s be State of A;
     let a1,a2,a3 be Element of BOOLEAN; assume
A2:  a1 = s.x & a2 = s.y & a3 = s.z;
A3:  x in the carrier of S1 & y in the carrier of S1 & z in the carrier of S1
     by FACIRC_1:60;
A4:  x in the carrier of S2 & y in the carrier of S2 & z in the carrier of S2
     by Th129;
     reconsider s1 = s|the carrier of S1 as State of A1 by FACIRC_1:26;
     reconsider s2 = s|the carrier of S2 as State of A2 by FACIRC_1:26;
     reconsider t = s as State of A1+*A2;
     InputVertices S1 = {x,y,z} by A1,FACIRC_1:57;
then A5: InputVertices S1 = InputVertices S2 by A1,Th127;
A6:  InnerVertices S1 misses InputVertices S1 &
     InnerVertices S2 misses InputVertices S2 by XBOOLE_1:79;
     dom s1 = the carrier of S1 by CIRCUIT1:4;
then a1 = s1.x & a2 = s1.y & a3 = s1.z by A2,A3,FUNCT_1:70;
then Following(t,2).GFA3AdderOutput(x,y,z)
        = Following(s1,2).GFA3AdderOutput(x,y,z) &
     Following(s1,2).GFA3AdderOutput(x,y,z)
        = 'not' ('not' a1 'xor' 'not' a2 'xor' 'not' a3)
          by A1,A5,A6,Th148,FACIRC_1:32;
    hence Following(s,2).GFA3AdderOutput(x,y,z)
        = 'not' ('not' a1 'xor' 'not' a2 'xor' 'not' a3);
     dom s2 = the carrier of S2 by CIRCUIT1:4;
then a1 = s2.x & a2 = s2.y & a3 = s2.z by A2,A4,FUNCT_1:70;
then Following(t,2).GFA3CarryOutput(x,y,z)
        = Following(s2,2).GFA3CarryOutput(x,y,z) &
     Following(s2,2).GFA3CarryOutput(x,y,z) =
     'not' (('not' a1 '&' 'not' a2) 'or' ('not' a2 '&' 'not' a3) 'or'
            ('not' a3 '&' 'not' a1)) by A1,A5,A6,Th135,FACIRC_1:33;
     hence Following(s,2).GFA3CarryOutput(x,y,z) =
     'not' (('not' a1 '&' 'not' a2) 'or' ('not' a2 '&' 'not' a3) 'or'
            ('not' a3 '&' 'not' a1));
   end;

theorem
 for x,y,z being set  st z <> [<*x,y*>,xor2] &
   x <> [<*y,z*>,and2b] & y <> [<*z,x*>,and2b] & z <> [<*x,y*>,and2b]
   for s being State of BitGFA3Circ(x,y,z)
    holds Following(s,2) is stable
   proof
     set f0 = xor2;
     set f1 = and2b, f2 = and2b, f3 = and2b;
     let x,y,z be set such that
A1:  z <> [<*x,y*>,f0] &
     x <> [<*y,z*>,f2] & y <> [<*z,x*>,f3] & z <> [<*x,y*>,f1];
     set S = BitGFA3Str(x,y,z);
     set S1 = GFA3AdderStr(x,y,z);
     set S2 = GFA3CarryStr(x,y,z);
     set A = BitGFA3Circ(x,y,z);
     set A1 = GFA3AdderCirc(x,y,z);
     set A2 = GFA3CarryCirc(x,y,z);
     let s be State of A;
     reconsider s1 = s|the carrier of S1 as State of A1 by FACIRC_1:26;
     reconsider s2 = s|the carrier of S2 as State of A2 by FACIRC_1:26;
     reconsider t = s as State of A1+*A2;
     InputVertices S1 = {x,y,z} by A1,FACIRC_1:57;
then A2: InputVertices S1 = InputVertices S2 by A1,Th127;
     InnerVertices S1 misses InputVertices S1 &
     InnerVertices S2 misses InputVertices S2 by XBOOLE_1:79;
then A3: Following(s1,2) = Following(t,2)|the carrier of S1 &
         Following(s1,3) = Following(t,3)|the carrier of S1 &
         Following(s2,2) = Following(t,2)|the carrier of S2 &
         Following(s2,3) = Following(t,3)|the carrier of S2
          by A2,FACIRC_1:30,31;
     Following(s1,2) is stable by A1,FACIRC_1:63;
then A4: Following(s1,2)
       = Following Following(s1,2) by CIRCUIT2:def 6
      .= Following(s1,2+1) by FACIRC_1:12;
     Following(s2,2) is stable by A1,Th136;
then A5: Following(s2,2)
       = Following Following(s2,2) by CIRCUIT2:def 6
      .= Following(s2,2+1) by FACIRC_1:12;
A6:  Following(s,2+1) = Following Following(s,2) by FACIRC_1:12;
A7:  dom Following(s,2) = the carrier of S &
     dom Following(s,3) = the carrier of S &
     dom Following(s1,2) = the carrier of S1 &
     dom Following(s2,2) = the carrier of S2 by CIRCUIT1:4;
A8: the carrier of S = (the carrier of S1) \/ the carrier of S2
      by CIRCCOMB:def 2;
       now let a be set; assume a in the carrier of S;
       then a in the carrier of S1 or a in the carrier of S2
         by A8,XBOOLE_0:def 2;
       then (Following(s,2)).a = (Following(s1,2)).a &
            (Following(s,3)).a = (Following(s1,3)).a or
            (Following(s,2)).a = (Following(s2,2)).a &
            (Following(s,3)).a = (Following(s2,3)).a
              by A3,A4,A5,A7,FUNCT_1:70;
       hence (Following(s,2)).a = (Following Following(s,2)).a
              by A4,A5,FACIRC_1:12;
       end;
    hence Following(s,2) = Following Following(s,2) by A6,A7,FUNCT_1:9;
   end;
