:: Joining of Decorated Trees
::  by Grzegorz Bancerek
::
:: Received October 8, 1993
:: Copyright (c) 1993 Association of Mizar Users
 
environ

 vocabularies NUMBERS, TREES_2, SUBSET_1, RELAT_1, FINSEQ_1, FUNCT_1, TARSKI,
      TREES_1, XXREAL_0, ARYTM_3, CARD_1, FUNCOP_1, XBOOLE_0, TREES_3,
      ZFMISC_1, NAT_1, FINSEQ_2, TREES_A, ORDINAL4, FUNCT_6, FINSEQ_4, MCART_1,
      PARTFUN1, TREES_4;
 notations TARSKI, XBOOLE_0, ZFMISC_1, SUBSET_1, NUMBERS, NAT_1, RELAT_1,
      FUNCT_1, DOMAIN_1, FUNCOP_1, FUNCT_3, FINSEQ_1, FINSEQ_2, TREES_1,
      TREES_2, FUNCT_6, TREES_3, XXREAL_0;
 constructors BINOP_1, DOMAIN_1, XXREAL_0, XREAL_0, NAT_1, FUNCT_5, FINSEQ_2,
      FUNCT_6, TREES_3, RELSET_1;
 registrations XBOOLE_0, SUBSET_1, RELAT_1, FUNCT_1, ORDINAL1, XREAL_0,
      FINSEQ_1, TREES_2, TREES_3, CARD_1, FINSEQ_2, FUNCOP_1, RELSET_1;
 requirements NUMERALS, REAL, BOOLE, SUBSET, ARITHM;
 definitions TARSKI, FINSEQ_1, TREES_1, TREES_2, FINSEQ_2, FUNCT_6;
 theorems TARSKI, ZFMISC_1, FINSEQ_1, MCART_1, NAT_1, FUNCT_1, FUNCT_2,
      FUNCOP_1, FUNCT_6, FINSEQ_2, FINSEQ_3, TREES_1, TREES_2, TREES_3,
      RELAT_1, XBOOLE_0, XBOOLE_1, XREAL_1, XXREAL_0, FUNCT_5, ORDINAL1;
 schemes CLASSES1, FINSEQ_1, XBOOLE_0;

begin :: Joining of decorated trees

definition
  let T be DecoratedTree;
  mode Node of T is Element of dom T;
end;

reserve x, y, z for set,
  i, j, n for Element of NAT,
  p, q, r for FinSequence,
  v for FinSequence of NAT;

Lm1: now
  let x,y;
  let p be FinSequence of x;
  assume y in dom p or y in dom p;
then A2: p.y in rng p by FUNCT_1:def 5;
 rng p c= x by FINSEQ_1:def 4;
  hence p.y in x by A2;
end;

definition
  let T1, T2 be DecoratedTree;
  redefine pred T1 = T2 means
  dom T1 = dom T2 & for p being Node of T1 holds T1.p = T2.p;
  compatibility
  proof
 (for p being Node of T1 holds T1.p = T2.p) & dom T1 = dom T2 implies
    for x st x in dom T1 holds T1.x = T2.x;
    hence thesis by FUNCT_1:9;
  end;
end;

theorem Th1:
  for i,j being Element of NAT
  st elementary_tree i c= elementary_tree j holds i <= j
proof
  let i,j be Element of NAT;
  assume that
A1: elementary_tree i c= elementary_tree j and
A2: i > j;
 <*j*> in elementary_tree i by A2,TREES_1:55;
then A4: ex n st n < j & <*j*> = <*n*> by A1,TREES_1:57;
 <*j*>.1 = j by FINSEQ_1:57;
  hence thesis by A4,FINSEQ_1:57;
end;

theorem Th2:
  for i,j being Element of NAT
  st elementary_tree i = elementary_tree j holds i = j
proof
  let i,j be Element of NAT;
  assume elementary_tree i = elementary_tree j;
then  i <= j & i >= j by Th1;
  hence thesis by XXREAL_0:1;
end;

Lm2: n < len p implies n+1 in dom p & p.(n+1) in rng p
proof
  assume
A1: n < len p;
 n >= 0 by NAT_1:2;
then A3: n+1 >= 0+1 by XREAL_1:9;
 n+1 <= len p by A1,NAT_1:13;
then  n+1 in dom p by A3,FINSEQ_3:27;
  hence thesis by FUNCT_1:def 5;
end;

Lm3: now
  let n,x;
  let p be FinSequence of x;
  assume n < len p;
then A2: p.(n+1) in rng p by Lm2;
 rng p c= x by FINSEQ_1:def 4;
  hence p.(n+1) in x by A2;
end;

definition
  let x;
  func root-tree x -> DecoratedTree equals
  (elementary_tree 0) --> x;
  correctness;
end;

definition
  let D be non empty set, d be Element of D;
  redefine func root-tree d -> Element of FinTrees D;
  coherence
  proof
    dom ((elementary_tree 0) --> d) = elementary_tree 0 by FUNCOP_1:19;
    hence thesis by TREES_3:def 8;
  end;
end;

theorem Th3:
  dom root-tree x = elementary_tree 0 & (root-tree x).{} = x
proof
 {} in elementary_tree 0 by TARSKI:def 1,TREES_1:56;
  hence thesis by FUNCOP_1:13,19;
end;

theorem
  root-tree x = root-tree y implies x = y
proof
 (root-tree x).{} = x by Th3;
  hence thesis by Th3;
end;

theorem Th5:
  for T being DecoratedTree st dom T = elementary_tree 0 holds
  T = root-tree (T.{})
proof
  let T be DecoratedTree;
  assume
A1: dom T = elementary_tree 0;
then  for x st x in dom T holds T.x = T.{} by TARSKI:def 1,TREES_1:56;
  hence thesis by A1,FUNCOP_1:17;
end;

theorem
  root-tree x = {[{},x]}
proof
  thus root-tree x = [:{{}},{x}:] by FUNCOP_1:def 2,TREES_1:56
    .= {[{},x]} by ZFMISC_1:35;
end;

definition
  let x;
  let p be FinSequence;
  func x-flat_tree(p) -> DecoratedTree means
  :
  Def3: dom it = elementary_tree len p & it.{} = x &
  for n st n < len p holds it.<*n*> = p.(n+1);
  existence
  proof
    defpred X[set,set] means
    $1 = {} & $2 = x or ex n st $1 = <*n*> & $2 = p.(n+1);
A1: for z st z in elementary_tree len p ex y st X[z,y]
    proof
      let z;
      assume z in elementary_tree len p;
      then reconsider z as Element of elementary_tree len p;
      reconsider z as FinSequence of NAT;
A3:   z = {} or ex n st n < len p & z = <*n*> by TREES_1:57;
   now
        given n such that
A5:     z = <*n*> and n < len p;
        take y = p.(n+1),n;
        thus z = <*n*> & y = p.(n+1) by A5;
      end;
      hence thesis by A3;
    end;
    consider f being Function such that
A6: dom f = elementary_tree len p & for y st y in
    elementary_tree len p holds X[y,f.y] from CLASSES1:sch 1(A1);
    reconsider f as DecoratedTree by A6,TREES_2:def 8;
    take f;
    thus dom f = elementary_tree len p by A6;
 {} in dom f & for n st {} = <*n*> holds f.{} <> p.(n+1) by TREES_1:47;
    hence f.{} = x by A6;
    let n;
    assume n < len p;
then  <*n*> in dom f by A6,TREES_1:55;
    then consider k being Element of NAT such that
A10: <*n*> = <*k*> and
A11: f.<*n*> = p.(k+1) by A6;
 k = <*n*>.1 by A10,FINSEQ_1:57
      .= n by FINSEQ_1:57;
    hence thesis by A11;
  end;
  uniqueness
  proof
    let T1, T2 be DecoratedTree such that
A13: dom T1 = elementary_tree len p and
A14: T1.{} = x and
A15: for n st n < len p holds T1.<*n*> = p.(n+1) and
A16: dom T2 = elementary_tree len p and
A17: T2.{} = x and
A18: for n st n < len p holds T2.<*n*> = p.(n+1);
 now
      let x;
      assume x in elementary_tree len p;
      then reconsider x9 = x as Element of elementary_tree len p;
A21:  x9 = {} or ex n st n < len p & x9 = <*n*> by TREES_1:57;
  now
        given n such that
A23:    n < len p & x = <*n*>;
        thus T1.x = p.(n+1) by A15,A23
          .= T2.x by A18,A23;
      end;
      hence T1.x = T2.x by A14,A17,A21;
    end;
    hence thesis by A13,A16,FUNCT_1:9;
  end;
end;

theorem
  x-flat_tree p = y-flat_tree q implies x = y & p = q
proof
  assume
A1: x-flat_tree p = y-flat_tree q;
 (x-flat_tree p).{} = x by Def3;
  hence x = y by A1,Def3;
  A3: dom (x-flat_tree p) = elementary_tree len p & dom (y-flat_tree q) =
  elementary_tree len q by Def3;
then A4: len p = len q by A1,Th2;
 now
    let i be Nat;
    assume that
A6: i >= 1 and
A7: i <= len p;
    consider n be Nat such that
A8: i = 1+n by A6,NAT_1:10;
A9: n in NAT & n < len p by A7,A8,NAT_1:13,ORDINAL1:def 13;
then  p.i = (x-flat_tree p).<*n*> by A8,Def3;
    hence p.i = q.i by A1,A4,A8,A9,Def3;
  end;
  hence thesis by A1,A3,Th2,FINSEQ_1:18;
end;

theorem Th8:
  j < i implies (elementary_tree i)|<*j*> = elementary_tree 0
proof
  set p = i |-> elementary_tree 0, T = tree(p);
  assume
A1: j < i;
then A2: 1+j >= 1 & j+1 <= i by NAT_1:11,13;
 len p = i by FINSEQ_1:def 18;
  then A4: elementary_tree i = T & T|<*j*> = p.(j+1) by A1,TREES_3:52,57;
 j+1 in Seg i by A2;
  hence thesis by A4,FUNCOP_1:13;
end;

theorem Th9:
  i < len p implies (x-flat_tree p)|<*i*> = root-tree (p.(i+1))
proof
  reconsider t = {} as Element of (dom (x-flat_tree p))|<*i*> by TREES_1:47;
  assume
A1: i < len p;
then A2: (x-flat_tree p).<*i*> = p.(i+1) by Def3;
A3: dom (x-flat_tree p) = elementary_tree len p by Def3;
 (elementary_tree len p)|<*i*> = elementary_tree 0 by A1,Th8;
then
A5: dom ((x-flat_tree p)|<*i*>) = elementary_tree 0 by A3,TREES_2:def 11;
   <*
i*>^t = <*i*> & ((x-flat_tree p)|<*i*>).t = (x-flat_tree p).(<*i*>^t) by
  FINSEQ_1:47,TREES_2:def 11;
  hence thesis by A2,A5,Th5;
end;

definition
  let x, p such that
A1: p is DTree-yielding;
  func x-tree(p) -> DecoratedTree means
  : Def4:
  ( ex q being DTree-yielding FinSequence st p = q & dom it = tree(doms q)) &
  it.{} = x & for n st n < len p holds it|<*n*> = p.(n+1);
  existence
  proof
A2: dom doms p = dom p by A1,TREES_3:39;
    reconsider q = doms p as Tree-yielding FinSequence by A1;
    defpred X[set,set] means $1 = {} & $2 = x or $1 <> {} &
    ex n,r st $1 = <*n*>^r & $2 = p..(n+1,r);
A3: for y st y in tree(q) ex z st X[y,z]
    proof
      let y;
      assume y in tree(q);
      then reconsider s = y as Element of tree(q);
   now
        assume y <> {};
        then consider w being (FinSequence of NAT), n being Nat such that
A7:     s = <*n*>^w by FINSEQ_2:150;
        reconsider n as Element of NAT by ORDINAL1:def 13;
        reconsider w as FinSequence;
        take z = p..(n+1,w);
        thus y = {} & z = x or y <> {} &
        ex n,r st y = <*n*>^r & z = p..(n+1,r) by A7;
      end;
      hence thesis;
    end;
    consider T being Function such that
A8: dom T = tree(q) & for y st y in tree(q) holds X[y,T.y]
    from CLASSES1:sch 1(A3);
    reconsider T as DecoratedTree by A8,TREES_2:def 8;
    take T;
    thus
    ex q being DTree-yielding FinSequence st p = q & dom T = tree(doms q)
    by A1,A8;
 {} in tree(q) by TREES_1:47;
    hence T.{} = x by A8;
A10: len p = len q by A2,FINSEQ_3:31;
    let n;
    assume
A11: n < len p;
then A12: n+1 in dom p by Lm2;
    then reconsider t = p.(n+1) as DecoratedTree by A1,TREES_3:26;
A13: dom t = q.(n+1) by A12,FUNCT_6:31;
A14: dom t = q.(n+1) by A12,FUNCT_6:31
      .= (dom T)|<*n*> by A8,A10,A11,TREES_3:52;
A15: (dom T)|<*n*> = dom (T|<*n*>) by TREES_2:def 11;
 now
      let r be FinSequence of NAT;
      assume
A17:  r in dom t;
then   <*n*>^r in dom T by A8,A10,A11,A13,TREES_3:def 15;
      then consider m being Element of NAT, s being FinSequence such that
A19:  <*n*>^r = <*m*>^s and
A20:  T.(<*n*>^r) = p..(m+1,s) by A8;
A21:  (<*n*>^r).1 = n & (<*m*>^s).1 = m by FINSEQ_1:58;
then   m+1 in dom p & r = s by A11,A19,Lm2,FINSEQ_1:46;
then   p..(m+1,s) = t.r by A17,A19,A21,FUNCT_5:45;
      hence (T|<*n*>).r = t.r by A14,A17,A20,TREES_2:def 11;
    end;
    hence thesis by A14,A15,TREES_2:33;
  end;
  uniqueness
  proof
    let T1, T2 be DecoratedTree;
    given q1 being DTree-yielding FinSequence such that
A24: p = q1 and
A25: dom T1 = tree(doms q1);
    assume that
A26: T1.{} = x and
A27: for n st n < len p holds T1|<*n*> = p.(n+1);
    given q2 being DTree-yielding FinSequence such that
A28: p = q2 & dom T2 = tree(doms q2);
    assume that
A29: T2.{} = x and
A30: for n st n < len p holds T2|<*n*> = p.(n+1);
 now
      let q be FinSequence of NAT;
      assume
A32:  q in dom T1;
  now
        assume q <> {};
        then consider s being FinSequence of NAT, n being Nat such that
A35:    q = <*n*>^s by FINSEQ_2:150;
        reconsider n as Element of NAT by ORDINAL1:def 13;
A36:    <*n*> in dom T1 by A32,A35,TREES_1:46;
A37:    n < len doms q1 by A25,A32,A35,TREES_3:51;
    len doms q1 = len p by A24,TREES_3:40;
then A39:    T1|<*n*> = p.(n+1) & T2|<*n*> = p.(n+1) by A27,A30,A37;
A40:    s in (dom T1)|<*n*> by A32,A35,A36,TREES_1:def 9;
then     T1.q = (T1|<*n*>).s by A35,TREES_2:def 11;
        hence T1.q = T2.q by A24,A25,A28,A35,A39,A40,TREES_2:def 11;
      end;
      hence T1.q = T2.q by A26,A29;
    end;
    hence thesis by A24,A25,A28,TREES_2:33;
  end;
end;

definition
  let x;
  let T be DecoratedTree;
  func x-tree T -> DecoratedTree equals
  x-tree <*T*>;
  correctness;
end;

definition
  let x;
  let T1, T2 be DecoratedTree;
  func x-tree (T1,T2) -> DecoratedTree equals
  x-tree <*T1,T2*>;
  correctness;
end;

theorem Th10:
  for p being DTree-yielding FinSequence holds dom (x-tree(p)) = tree(doms p)
proof
  let p be DTree-yielding FinSequence;
 ex q being DTree-yielding FinSequence st
  p = q & dom (x-tree(p)) = tree(doms q) by Def4;
  hence thesis;
end;

theorem Th11:
  for p being DTree-yielding FinSequence holds
  y in dom (x-tree(p)) iff y = {} or
  ex i being Element of NAT, T being DecoratedTree, q being Node of T st
  i < len p & T = p.(i+1) & y = <*i*>^q
proof
  let p be DTree-yielding FinSequence;
A1: dom (x-tree p) = tree(doms p) by Th10;
A2: now
    given i,q such that
A3: i < len doms p and
A4: q in (doms p).(i+1) and
A5: y = <*i*>^q;
 len doms p = len p by TREES_3:40;
then A7: i+1 in dom p by A3,Lm2;
    then reconsider T = p.(i+1) as DecoratedTree by TREES_3:26;
    take i, T;
    reconsider q as Node of T by A4,A7,FUNCT_6:31;
    take q;
    thus i < len p & T = p.(i+1) & y = <*i*>^q by A3,A5,TREES_3:40;
  end;
 now
    given i being Element of NAT, T being DecoratedTree, q being Node of T
    such that
A9: i < len p and
A10: T = p.(i+1) and
A11: y = <*i*>^q;
    reconsider q as FinSequence;
    take i, q;
 i+1 in dom p by A9,Lm2;
then  (doms p).(i+1) = dom T by A10,FUNCT_6:31;
    hence i < len doms p & q in (doms p).(i+1) & y = <*i*>^q by A9,A11,
    TREES_3:40;
  end;
  hence thesis by A1,A2,TREES_3:def 15;
end;

theorem Th12:
  for p being DTree-yielding FinSequence for i being Element of NAT,
  T being DecoratedTree, q being Node of T st i < len p &
  T = p.(i+1) holds (x-tree p).(<*i*>^q) = T.q
proof
  let p be DTree-yielding FinSequence, n be Element of NAT,
  T be DecoratedTree;
  let q be Node of T;
  assume
A1: n < len p & T = p.(n+1);
then A2: <*n*>^q in dom (x-tree(p)) by Th11;
then  <*n*> in dom (x-tree(p)) by TREES_1:46;
then  q in (dom (x-tree p))|<*n*> by A2,TREES_1:def 9;
then  ((x-tree(p))|<*n*>).q = (x-tree(p)).(<*n*>^q) by TREES_2:def 11;
  hence thesis by A1,Def4;
end;

theorem
  for T being DecoratedTree holds dom (x-tree T) = ^dom T
proof
  let T be DecoratedTree;
   dom (x-tree <*T*>) = tree(doms <*T*>) & doms <*T*> = <*dom T*> by Th10,
  FUNCT_6:33;
  hence thesis by TREES_3:def 16;
end;

theorem
  for T1, T2 being DecoratedTree holds
  dom (x-tree (T1,T2)) = tree(dom T1, dom T2)
proof
  let T1, T2 be DecoratedTree;
   dom
 (x-tree <*T1,T2*>) = tree(doms <*T1,T2*>) & doms <*T1,T2*> = <*dom T1,
  dom T2*> by Th10,FUNCT_6:34;
  hence thesis by TREES_3:def 17;
end;

theorem
  for p,q being DTree-yielding FinSequence st x-tree p = y-tree q holds
  x = y & p = q
proof
  let p,q be DTree-yielding FinSequence;
  assume
A1: x-tree p = y-tree q;
 (x-tree p).{} = x by Def4;
  hence x = y by A1,Def4;
   dom (x-tree p) = tree(doms p) & dom (y-tree q) = tree(doms q) by Th10;
then A4: doms p = doms q by A1,TREES_3:53;
 dom p = dom doms p & dom doms q = dom q by TREES_3:39;
then A6: len p = len q by A4,FINSEQ_3:31;
 now
    let i be Nat;
    assume that
A8: i >= 1 and
A9: i <= len p;
    consider n be Nat such that
A10: i = 1+n by A8,NAT_1:10;
    reconsider n as Element of NAT by ORDINAL1:def 13;
A11: n < len p by A9,A10,NAT_1:13;
then  p.i = (x-tree p)|<*n*> by A10,Def4;
    hence p.i = q.i by A1,A6,A10,A11,Def4;
  end;
  hence thesis by A6,FINSEQ_1:18;
end;

theorem
  root-tree x = y-flat_tree p implies x = y & p = {}
proof
  assume
A1: root-tree x = y-flat_tree p;
  thus x = (root-tree x).{} by Th3
    .= y by A1,Def3;
 dom (y-flat_tree p) = elementary_tree len p by Def3;
  hence thesis by A1,Th2,Th3;
end;

theorem
  root-tree x = y-tree p & p is DTree-yielding implies x = y & p = {}
proof
  assume that
A1: root-tree x = y-tree p and
A2: p is DTree-yielding;
  reconsider p9 = p as DTree-yielding FinSequence by A2;
  thus x = (root-tree x).{} by Th3
    .= y by A1,A2,Def4;
A3: dom (y-tree p) = tree(doms p9) by Th10;
then A4: doms p = {} by A1,Th3,TREES_3:53,55;
 dom doms p = dom p by A3,TREES_3:39;
  hence thesis by A4;
end;

theorem
  x-flat_tree p = y-tree q & q is DTree-yielding implies x = y &
  len p = len q & for i st i in dom p holds q.i = root-tree (p.i)
proof
  assume that
A1: x-flat_tree p = y-tree q and
A2: q is DTree-yielding;
  reconsider q9 = q as DTree-yielding FinSequence by A2;
  thus x = (x-flat_tree p).{} by Def3
    .= y by A1,A2,Def4;
 tree((len p)|->elementary_tree 0) = elementary_tree len p by TREES_3:57
    .= dom (x-flat_tree p) by Def3
    .= tree(doms q9) by A1,Th10;
then A4: (len p)|->elementary_tree 0 = doms q9 by TREES_3:53;
 len doms q9 = len q by TREES_3:40;
  thus
then A6: len p = len q by A4,FINSEQ_1:def 18;
  let i;
  assume
A7: i in dom p;
then A8: i >= 1 by FINSEQ_3:27;
A9: i <= len p by A7,FINSEQ_3:27;
  consider n being Nat such that
A10: i = 1+n by A8,NAT_1:10;
  reconsider n as Element of NAT by ORDINAL1:def 13;
A11: n < len p by A9,A10,NAT_1:13;
then  (x-flat_tree p)|<*n*> = root-tree (p.i) by A10,Th9;
  hence thesis by A1,A2,A6,A10,A11,Def4;
end;

theorem
  for p being DTree-yielding FinSequence, n being Element of NAT,
  q being FinSequence st <*n*>^q in dom (x-tree(p)) holds
  (x-tree(p)).(<*n*>^q) = p..(n+1,q)
proof
  let p be DTree-yielding FinSequence, n be Element of NAT, q be FinSequence;
  assume
A1: <*n*>^q in dom (x-tree(p));
then  <*n*>^q is Node of (x-tree(p));
  then reconsider q9 = q as FinSequence of NAT by FINSEQ_1:50;
A3: <*n*> in dom (x-tree p) by A1,TREES_1:46;
A4: <*n*>^q in tree(doms p) by A1,Th10;
A5: len doms p = len p by TREES_3:40;
A6: q9 in (dom (x-tree p))|<*n*> by A1,A3,TREES_1:def 9;
A7: n < len p by A4,A5,TREES_3:51;
  A8: dom
 ((x-tree p)|<*n*>) = (dom (x-tree p))|<*n*> & ((x-tree(p))|<*n*>).q9 = (
  x-tree(p)).(<*n*>^q) by A6,TREES_2:def 11;
 n+1 in dom p & p.(n+1) = (x-tree(p))|<*n*> by A7,Def4,Lm2;
  hence thesis by A6,A8,FUNCT_5:45;
end;

theorem
  x-flat_tree({}) = root-tree x & x-tree({}) = root-tree x
proof
 len {} = 0;
then A2: dom (x-flat_tree {}) = elementary_tree 0 by Def3;
 now
    let y;
    assume y in elementary_tree 0;
then  y = {} by TARSKI:def 1,TREES_1:56;
    hence (x-flat_tree {}).y = x by Def3;
  end;
  hence x-flat_tree({}) = root-tree x by A2,FUNCOP_1:17;
  reconsider e = {} as DTree-yielding FinSequence;
A6: dom (x-tree {}) = tree(doms e) by Th10
    .= elementary_tree 0 by FUNCT_6:32,TREES_3:55;
 now
    let y;
    assume y in elementary_tree 0;
then  y = {} by TARSKI:def 1,TREES_1:56;
    hence (x-tree e).y = x by Def4;
  end;
  hence thesis by A6,FUNCOP_1:17;
end;

theorem
  x-flat_tree(<*y*>) =
  ((elementary_tree 1) --> x) with-replacement (<*0*>, root-tree y)
proof
  set T = ((elementary_tree 1) --> x) with-replacement (<*0*>, root-tree y);
A1: dom (x-flat_tree <*y*>) = elementary_tree len <*y*> by Def3
    .= elementary_tree 1 by FINSEQ_1:57;
A2: dom root-tree y = elementary_tree 0 by FUNCOP_1:19;
  A3: dom ((elementary_tree 1) --> x) = elementary_tree 1 & <*0*> in
  elementary_tree 1 by FUNCOP_1:19,TARSKI:def 2,TREES_1:88;
then A4: dom T = elementary_tree 1 with-replacement (<*0*>, elementary_tree 0 )
  by A2,TREES_2:def 12
    .= elementary_tree 1 by TREES_3:61,70;
 now
    let z;
    assume z in elementary_tree 1;
then A7: z = {} or z = <*0*> by TARSKI:def 2,TREES_1:88;
A8: {} in elementary_tree 1 by TARSKI:def 2,TREES_1:88;
A9: not <*0*> is_a_prefix_of {};
A10: len <*y*> = 1 by FINSEQ_1:57;
A11: <*y*>.1 = y & (x-flat_tree <*y*>).{} = x by Def3,FINSEQ_1:57;
A12: T.{} = ((elementary_tree 1) --> x).{} by A3,A8,A9,TREES_3:48;
A13: (x-flat_tree <*y*>).<*0*> = <*y*>.(0+1) by A10,Def3;
 T.<*0*> = (root-tree y).{} by A3,TREES_3:47;
    hence
T.z = (x-flat_tree <*y*>).z by A7,A8,A11,A12,A13,Th3,FUNCOP_1:13;
  end;
  hence thesis by A1,A4,FUNCT_1:9;
end;

theorem
  for T being DecoratedTree holds
  x-tree(<*T*>) = ((elementary_tree 1) --> x) with-replacement (<*0*>, T)
proof
  let T be DecoratedTree;
  set D = ((elementary_tree 1) --> x) with-replacement (<*0*>, T);
  set W = elementary_tree 1 with-replacement(<*0*>,dom T);
A1: dom (x-tree <*T*>) = tree(doms <*T*>) by Th10
    .= tree(<*dom T*>) by FUNCT_6:33
    .= ^dom T by TREES_3:def 16
    .= W by TREES_3:61;
A2: dom ((elementary_tree 1) --> x) = elementary_tree 1 by FUNCOP_1:19;
  reconsider t1 = {}, t2 = <*0*> as Element of elementary_tree 1
  by TARSKI:def 2,TREES_1:88;
 t2 = t2;
then A4: dom D = W by A2,TREES_2:def 12;
A5: {} in dom T by TREES_1:47;
 now
    let y;
    assume y in W;
    then reconsider q = y as Element of W;
     q
 in elementary_tree 1 or ex v st v in dom T & q = t2^v by TREES_1:def 12;
then A9: q = {} or q = t2 & t2 = t2^t1 or
    ex v st v in dom T & q = <*0*>^v by FINSEQ_1:47,TARSKI:def 2,TREES_1:88;
 not t2 is_a_prefix_of t1;
then A11: D.{} = ((elementary_tree 1)-->x).t1 by A2,TREES_3:48
      .= x by FUNCOP_1:13
      .= (x-tree <*T*>).{} by Def4;
 now
      given r being FinSequence of NAT such that
A13:  r in dom T and
A14:  q = <*0*>^r;
      reconsider r as Node of T by A13;
  q = t2^r by A14;
then A16:  D.q = T.r by A2,TREES_3:49;
  len <*T*> = 1 & <*T*>.(0+1) = T by FINSEQ_1:57;
then A18:  (x-tree <*T*>)|t2 = T by Def4;
  W|t2 = dom T by TREES_1:66;
      hence D.q = (x-tree <*T*>).q by A1,A14,A16,A18,TREES_2:def 11;
    end;
    hence D.y = (x-tree <*T*>).y by A5,A9,A11;
  end;
  hence thesis by A1,A4,FUNCT_1:9;
end;

registration
  let D be non empty set, d be Element of D, p be FinSequence of D;
  cluster d-flat_tree(p) -> D-valued;
  coherence
  proof
    set T = d-flat_tree(p);
 rng T c= D
    proof
      let x;
      assume x in rng T;
      then consider y such that
A3:   y in dom T and
A4:   x = T.y by FUNCT_1:def 5;
      reconsider y as Node of T by A3;
A5:   dom T = elementary_tree len p by Def3;
A6:   T.{} = d by Def3;
   now
        assume y <> {};
        then consider n such that
A9:     n < len p & y = <*n*> by A5,TREES_1:57;
A10:    T.y = p.(n+1) & p.(n+1) in rng p by A9,Def3,Lm2;
    rng p c= D by FINSEQ_1:def 4;
        hence thesis by A4,A10;
      end;
      hence thesis by A4,A6;
    end;
    hence thesis by RELAT_1:def 19;
  end;
end;

registration
  let D be non empty set, F be non empty DTree-set of D;
  let d be Element of D, p be FinSequence of F;
  cluster d-tree(p) -> D-valued;
  coherence
  proof
    set T = d-tree(p);
 rng T c= D
    proof
      let x;
      assume x in rng T;
      then consider y such that
A3:   y in dom T and
A4:   x = T.y by FUNCT_1:def 5;
      reconsider y as Node of T by A3;
A5:   tree(doms p)-level 1 = {<*n*>: n < len doms p} by TREES_3:52;
A6:   T.{} = d by Def4;
A7:   tree(doms p) = dom T & len doms p = len p by Th10,TREES_3:40;
   now
        assume y <> {};
        then consider q being FinSequence of NAT, n being Nat such that
A10:    y = <*n*>^q by FINSEQ_2:150;
        reconsider n as Element of NAT by ORDINAL1:def 13;
A11:    <*n*> in dom T by A10,TREES_1:46;
A12:    len <*n*> = 1 by FINSEQ_1:57;
A13:    q in (dom T)|<*n*> by A10,A11,TREES_1:def 9;
A14:    <*n*> in (dom T)-level 1 by A11,A12;
A15:    dom (T|<*n*>) = (dom T)|<*n*> by TREES_2:def 11;
        consider i such that
A16:    <*n*> = <*i*> & i < len p by A5,A7,A14;
A17:    <*n*>.1 = n & <*i*>.1 = i by FINSEQ_1:57;
then A18:    T|<*n*> = p.(n+1) by A16,Def4;
A19:    p.(n+1) in rng p by A16,A17,Lm2;
    rng p c= F by FINSEQ_1:def 4;
        then reconsider t = p.(n+1) as Element of F by A19;
A21:    t.q = x by A4,A10,A13,A18,TREES_2:def 11;
A22:    t.q in rng t by A13,A15,A18,FUNCT_1:def 5;
    rng t c= D by RELAT_1:def 19;
        hence thesis by A21,A22;
      end;
      hence thesis by A4,A6;
    end;
    hence thesis by RELAT_1:def 19;
  end;
end;

registration
  let D be non empty set, d be Element of D, T be DecoratedTree of D;
  cluster d-tree T -> D-valued;
  coherence
  proof
    reconsider T as Element of Trees D by TREES_3:def 7;
    reconsider t = <*T*> as Element of (Trees D)* by FINSEQ_1:def 11;
 d-tree T = d-tree t;
    hence thesis;
  end;
end;

registration
  let D be non empty set, d be Element of D, T1, T2 be DecoratedTree of D;
  cluster d-tree(T1, T2) -> D-valued;
  coherence
  proof
    reconsider T1, T2 as Element of Trees D by TREES_3:def 7;
 <*T1,T2*> = <*T1 qua Element of Trees D qua non empty set*>^
    <*T2 qua Element of Trees D qua non empty set*>;
    then
reconsider t = <*T1,T2*> as Element of (Trees D)* by FINSEQ_1:def 11;
 d-tree(T1, T2) = d-tree t;
    hence thesis;
  end;
end;

definition
  let D be non empty set;
  let p be FinSequence of FinTrees D;
  redefine func doms p -> FinSequence of FinTrees;
  coherence
  proof
A1: dom doms p = dom p by TREES_3:39;
A2: rng p c= FinTrees D by FINSEQ_1:def 4;
    thus doms p is FinSequence of FinTrees
    proof
      let x;
      assume x in rng doms p;
      then consider y such that
A4:   y in dom p and
A5:   x = (doms p).y by A1,FUNCT_1:def 5;
      reconsider T = p.y as DecoratedTree by A4,TREES_3:26;
   T in rng p by A4,FUNCT_1:def 5;
then    dom T in FinTrees by A2,TREES_3:def 2;
      hence thesis by A4,A5,FUNCT_6:31;
    end;
  end;
end;

definition
  let D be non empty set;
  let d be Element of D, p be FinSequence of FinTrees D;
  redefine func d-tree p -> Element of FinTrees D;
  coherence
  proof
 dom (d-tree p) = tree(doms p) by Th10;
    hence thesis by TREES_3:def 8;
  end;
end;

definition
  let D be non empty set, x be Subset of D;
  redefine mode FinSequence of x -> FinSequence of D;
  coherence
  proof
    let p be FinSequence of x;
 rng p c= x by FINSEQ_1:def 4;
    hence rng p c= D by XBOOLE_1:1;
  end;
end;

registration
  let D be non empty constituted-DTrees set;
  let X be Subset of D;
  cluster -> DTree-yielding FinSequence of X;
  coherence;
end;

begin :: Expanding of decoreted tree by substitution

scheme ExpandTree{T1() -> Tree, T2() -> Tree, P[set]}: ex T being Tree st
  for p holds p in T iff p in T1() or
  ex q being Element of T1(), r being Element of T2() st P[q] & p = q^r
proof
  defpred X[set] means $1 in T1() or
  ex q being Element of T1(), r being Element of T2() st P[q] & $1 = q^r;
  consider T being set such that
A1: x in T iff x in NAT* & X[x] from XBOOLE_0:sch 1;
  consider t being Element of T1();
 t in NAT* by FINSEQ_1:def 11;
  then reconsider T as non empty set by A1;
 T is Tree-like
  proof
    thus T c= NAT*
    proof
      let x;
      thus thesis by A1;
    end;
    thus
    for p being FinSequence of NAT st p in T holds ProperPrefixes p c= T
    proof
      let p be FinSequence of NAT such that
A4:   p in T;
      let x;
      assume x in ProperPrefixes p;
      then consider q such that
A6:   x = q and
A7:   q is_a_proper_prefix_of p by TREES_1:def 4;
      assume
A8:   not thesis;
   q is_a_prefix_of p by A7,XBOOLE_0:def 8;
      then consider r such that
A10:  p = q^r by TREES_1:8;
      reconsider q,r as FinSequence of NAT by A10,FINSEQ_1:50;
  q^r in T1() & q in NAT* & (q^r in T1() implies q in T1()) or
      ex q being Element of T1(), r being Element of T2() st P[q] & p = q^r
      by A1,A4,A10,FINSEQ_1:def 11,TREES_1:46;
      then consider q9 being Element of T1(), r9 being Element of T2() such
      that
A12:  P[q9] and
A13:  q^r = q9^r9 by A1,A6,A8,A10;
  now
        assume len q <= len q9;
then     ex s being FinSequence st q^s = q9 by A13,FINSEQ_1:64;
then A17:    q in T1() by TREES_1:46;
    q in NAT* by FINSEQ_1:def 11;
        hence contradiction by A1,A6,A8,A17;
      end;
      then consider s being FinSequence such that
A19:  q9^s = q by A13,FINSEQ_1:64;
      reconsider s as FinSequence of NAT by A19,FINSEQ_1:50;
  q9^r9 = q9^(s^r) by A13,A19,FINSEQ_1:45;
then   s^r = r9 by FINSEQ_1:46;
then   q in NAT* & s is Element of T2() by FINSEQ_1:def 11,TREES_1:46;
      hence thesis by A1,A6,A8,A12,A19;
    end;
    let p be FinSequence of NAT, k,n be Element of NAT;
    assume that
A23: p^<*k*> in T and
A24: n <= k;
A25: now
      assume p^<*k*> in T1();
then A27:  p^<*n*> in T1() by A24,TREES_1:def 5;
  p^<*n*> in NAT* by FINSEQ_1:def 11;
      hence thesis by A1,A27;
    end;
 now
      assume
A30:  not p^<*k*> in T1();
      then consider q being Element of T1(), r being Element of T2() such that
A31:  P[q] and
A32:  p^<*k*> = q^r by A1,A23;
  q^{} = q by FINSEQ_1:47;
then   r <> {} by A30,A32;
      then consider w being FinSequence, z such that
A35:  r = w^<*z*> by FINSEQ_1:63;
      reconsider w as FinSequence of NAT by A35,FINSEQ_1:50;
A36:  p^<*k*> = q^w^<*z*> by A32,A35,FINSEQ_1:45;
      A37:  (
p^<*k*>).(len p+1) = k & (q^w^<*z*>).(len(q^w)+1) = z by FINSEQ_1:59;
A38:  len <*k*> = 1 & len <*z*> = 1 by FINSEQ_1:57;
      A39:  len
 (p^<*k*>) = len p+len <*k*> & len (q^w^<*z*>) = len (q^w)+len <*z*> by
      FINSEQ_1:35;
then A40:  p = q^w by A36,A37,A38,FINSEQ_1:46;
A41:  w^<*n*> in T2() by A24,A35,A36,A37,A38,A39,TREES_1:def 5;
A42:  p^<*n*> = q^(w^<*n*>) by A40,FINSEQ_1:45;
  p^<*n*> in NAT* by FINSEQ_1:def 11;
      hence thesis by A1,A31,A41,A42;
    end;
    hence thesis by A25;
  end;
  then reconsider T as Tree;
  take T;
  let p;
 p is Element of T1() or
  (ex q being Element of T1(), r being Element of T2() st P[q] & p = q^r)
  implies p in NAT* by FINSEQ_1:def 11;
  hence thesis by A1;
end;

definition
  let T,T9 be DecoratedTree;
  let x be set;
  func (T,x) <- T9 -> DecoratedTree means
  :
  Def7: (for p holds p in dom it iff p in dom T or
  ex q being Node of T, r being Node of T9 st
  q in Leaves dom T & T.q = x & p = q^r) & (for p being Node of T st
  not p in Leaves dom T or T.p <> x holds it.p = T.p) &
  for p being Node of T, q being Node of T9 st
  p in Leaves dom T & T.p = x holds it.(p^q) = T9.q;
  existence
  proof
    defpred X[set] means $1 in Leaves dom T & T.$1 = x;
    consider W being Tree such that
A1: p in W iff p in dom T or ex q being Node of T, r being Node of T9 st
    X[q] & p = q^r from ExpandTree;
    defpred X[set,set] means
    $1 is Node of T & (not $1 in Leaves dom T or T.$1 <> x) & $2 = T.$1 or
    ex p being Node of T, q being Node of T9 st
    $1 = p^q & p in Leaves dom T & T.p = x & $2 = T9.q;
A2: for z st z in W ex y st X[z,y]
    proof
      let z;
      assume z in W;
      then reconsider w = z as Element of W;
A4:   now
        given q being Node of T, r being Node of T9 such that
A5:     q in Leaves dom T & T.q = x & w = q^r;
        take y = T9.r, q, r;
        thus z = q^r & q in Leaves dom T & T.q = x & y = T9.r by A5;
      end;
   now
        assume
A7:     not ex q being Node of T, r being Node of T9 st
        q in Leaves dom T & T.q = x & w = q^r;
        take y = T.z;
        thus z is Node of T by A1,A7;
        reconsider w as Node of T by A1,A7;
        reconsider e = {} as Node of T9 by TREES_1:47;
     w^e = w by FINSEQ_1:47;
        hence (not z in Leaves dom T or T.z <> x) & y = T.z by A7;
      end;
      hence thesis by A4;
    end;
    consider f being Function such that
A9: dom f = W & for z st z in W holds X[z,f.z] from CLASSES1:sch 1(A2);
    reconsider f as DecoratedTree by A9,TREES_2:def 8;
    take f;
    thus p in dom f iff p in dom T or
    ex q being Node of T, r being Node of T9 st
    q in Leaves dom T & T.q = x & p = q^r by A1,A9;
    thus for p being Node of T st not p in Leaves dom T or T.p <> x holds
    f.p = T.p
    proof
      let p be Node of T;
      assume
A10:  not p in Leaves dom T or T.p <> x;
A11:  p in W by A1;
  now
        given p9 being Node of T, q being Node of T9 such that
A13:    p = p9^q and
A14:    p9 in Leaves dom T and
A15:    T.p9 = x and f.p = T9.q;
            p9
 is_a_prefix_of p & not p9 is_a_proper_prefix_of p by A13,A14,TREES_1:8
        ,def 8;
        hence contradiction by A10,A14,A15,XBOOLE_0:def 8;
      end;
      hence thesis by A9,A11;
    end;
    let p be Node of T, q be Node of T9;
    assume that
A17: p in Leaves dom T and
A18: T.p = x;
A19: p^q in W by A1,A17,A18;
 now
      assume p^q is Node of T;
then A22:  not p is_a_proper_prefix_of p^q by A17,TREES_1:def 8;
  p is_a_prefix_of p^q by TREES_1:8;
      hence p = p^q by A22,XBOOLE_0:def 8;
    end;
    then consider p9 being Node of T, q9 being Node of T9 such that
A24: p^q = p9^q9 and
A25: p9 in Leaves dom T and T.p9 = x and
A26: f.(p^q) = T9.q9 by A9,A17,A18,A19;
 now
      let p,p9,q,q9 be FinSequence of NAT, T be Tree;
      assume that
A28:  p^q = p9^q9 and
A29:  p in Leaves T & p9 in Leaves T and
A30:  p <> p9;
  now
        assume len p <= len p9;
then     ex r st p^r = p9 by A28,FINSEQ_1:64;
then     p is_a_prefix_of p9 by TREES_1:8;
then     p is_a_proper_prefix_of p9 by A30,XBOOLE_0:def 8;
        hence contradiction by A29,TREES_1:def 8;
      end;
then   ex r st p9^r = p by A28,FINSEQ_1:64;
then   p9 is_a_prefix_of p by TREES_1:8;
then   p9 is_a_proper_prefix_of p by A30,XBOOLE_0:def 8;
      hence contradiction by A29,TREES_1:def 8;
    end;
then  p = p9 by A17,A24,A25;
    hence thesis by A24,A26,FINSEQ_1:46;
  end;
  uniqueness
  proof
    let T1, T2 be DecoratedTree such that
A40: p in dom T1 iff p in dom T or ex q being Node of T, r being Node of T9 st
    q in Leaves dom T & T.q = x & p = q^r and
A41: for p being Node of T st
    not p in Leaves dom T or T.p <> x holds T1.p = T.p and
A42: for p being Node of T, q being Node of T9 st
    p in Leaves dom T & T.p = x holds T1.(p^q) = T9.q and
A43: p in dom T2 iff p in dom T or ex q being Node of T, r being Node of T9 st
    q in Leaves dom T & T.q = x & p = q^r and
A44: for p being Node of T st
    not p in Leaves dom T or T.p <> x holds T2.p = T.p and
A45: for p being Node of T, q being Node of T9 st
    p in Leaves dom T & T.p = x holds T2.(p^q) = T9.q;
A46: dom T1 = dom T2
    proof
      let p be FinSequence of NAT;
  p in dom T1 iff p in dom T or ex q being Node of T, r being Node of T9
      st q in Leaves dom T & T.q = x & p = q^r by A40;
      hence thesis by A43;
    end;
    reconsider p9 = {} as Node of T9 by TREES_1:47;
 now
      let y;
      assume y in dom T1;
      then reconsider p = y as Node of T1;
      per cases by A40;
      suppose
    p in dom T;
        then reconsider p as Node of T;
        hereby per cases;
          suppose
A51:        p in Leaves dom T & T.p = x;
then A52:        T1.(p^p9) = T9.p9 by A42;
        p^p9 = p by FINSEQ_1:47;
            hence T1.y = T2.y by A45,A51,A52;
          end;
          suppose
A54:        not p in Leaves dom T or T.p <> x;
then         T1.p = T.p by A41;
            hence T1.y = T2.y by A44,A54;
          end;
        end;
      end;
      suppose
            ex q being Node of T, r being Node of T9 st q in Leaves dom T &
        T.q = x & p = q^r;
        then consider q being Node of T, r being Node of T9 such that
A57:    q in Leaves dom T & T.q = x & p = q^r;
        thus T1.y = T9.r by A42,A57
          .= T2.y by A45,A57;
      end;
    end;
    hence thesis by A46,FUNCT_1:9;
  end;
end;

registration
  let D be non empty set;
  let T,T9 be DecoratedTree of D;
  let x be set;
  cluster (T,x) <- T9 -> D-valued;
  coherence
  proof
 rng ((T,x)<-T9) c= D
    proof
      let y be set;
      assume y in rng ((T,x)<-T9);
      then consider z being set such that
A3:   z in dom ((T,x)<-T9) and
A4:   y = ((T,x)<-T9).z by FUNCT_1:def 5;
      reconsider z as Node of (T,x)<-T9 by A3;
      reconsider p9 = {} as Node of T9 by TREES_1:47;
      per cases by Def7;
      suppose
     z in dom T;
        then reconsider p = z as Node of T;
        hereby per cases;
          suppose
         p in Leaves dom T & T.p = x;
then A7:         ((T,x)<-T9).(p^p9) = T9.p9 by Def7;
         p^p9 = p by FINSEQ_1:47;
            hence thesis by A4,A7;
          end;
          suppose
         not p in Leaves dom T or T.p <> x;
then         ((T,x)<-T9).p = T.p by Def7;
            hence thesis by A4;
          end;
        end;
      end;
      suppose
            ex q being Node of T, r being Node of T9 st q in Leaves dom T &
        T.q = x & z = q^r;
        then consider q being Node of T, r being Node of T9 such that
A12:    q in Leaves dom T & T.q = x & z = q^r;
    ((T,x)<-T9).z = T9.r by A12,Def7;
        hence thesis by A4;
      end;
    end;
    hence thesis by RELAT_1:def 19;
  end;
end;

reserve T,T9 for DecoratedTree,
  x,y for set;

theorem
  not x in rng T or not x in Leaves T implies (T,x) <- T9 = T
proof
A1: Leaves T c= rng T by RELAT_1:144;
  assume not x in rng T or not x in Leaves T;
then A3: not x in Leaves T by A1;
  thus
A4: dom ((T,x) <- T9) = dom T
  proof
    let p be FinSequence of NAT;
 p in dom (T,x) <- T9 iff p in dom T or
    ex q being Node of T, r being Node of T9 st
    q in Leaves dom T & T.q = x & p = q^r by Def7;
    hence thesis by A3,FUNCT_1:def 12;
  end;
  let p be Node of (T,x) <- T9;
  reconsider p9 = p as Node of T by A4;
 p9 in Leaves dom T implies T.p9 in Leaves T by FUNCT_1:def 12;
  hence thesis by A3,Def7;
end;

begin :: Double decoreted trees

reserve D1, D2 for non empty set,
  T for DecoratedTree of D1,D2,
  d1 for Element of D1,
  d2 for Element of D2,
  F for non empty DTree-set of D1,D2,
  F1 for non empty (DTree-set of D1),
  F2 for non empty DTree-set of D2;

theorem Th24:
  for D1, D2, T holds dom T`1 = dom T & dom T`2 = dom T
proof
  let D1, D2, T;
  A1: T`1 = pr1(D1,D2)*T & T`2 = pr2(D1,D2)*T by TREES_3:def 12,def 13;
  A2: rng T c= [:D1,D2:] & dom pr1(D1,D2) = [:D1,D2:] by FUNCT_2:def 1
  ,RELAT_1:def 19;
 dom pr2(D1,D2) = [:D1,D2:] by FUNCT_2:def 1;
  hence thesis by A1,A2,RELAT_1:46;
end;

theorem Th25:
  (root-tree [d1,d2])`1 = root-tree d1 & (root-tree [d1,d2])`2 = root-tree d2
proof reconsider r = {} as Node of root-tree [d1,d2] by TREES_1:47;
A1: dom (root-tree [d1,d2])`1 = dom root-tree [d1,d2] by Th24;
A2: dom (root-tree [d1,d2])`2 = dom root-tree [d1,d2] by Th24;
A3: (root-tree [d1,d2]).r = [d1,d2] by Th3;
A4: [d1,d2]`1 = d1 by MCART_1:7;
A5: [d1,d2]`2 = d2 by MCART_1:7;
  thus (root-tree [d1,d2])`1 = root-tree ((root-tree [d1,d2])`1.r) by A1,Th3
  ,Th5
    .= root-tree d1 by A3,A4,TREES_3:41;
  thus (root-tree [d1,d2])`2 = root-tree ((root-tree [d1,d2])`2.r) by A2,Th3
  ,Th5
    .= root-tree d2 by A3,A5,TREES_3:41;
end;

theorem
  <:root-tree x, root-tree y:> = root-tree [x,y]
proof reconsider x9 = x as Element of {x} by TARSKI:def 1;
  reconsider y9 = y as Element of {y} by TARSKI:def 1;
   (root-tree [x9,y9])`1 = root-tree x & (root-tree [x9,y9])`2 = root-tree y
  by Th25;
  hence thesis by TREES_3:42;
end;

theorem Th27:
  for D1,D2, d1,d2, F,F1
  for p being FinSequence of F, p1 being FinSequence of F1 st dom p1 = dom p &
  for i st i in dom p for T st T = p.i holds p1.i = T`1
  holds ([d1,d2]-tree p)`1 = d1-tree p1
proof
  let D1,D2, d1,d2, F,F1;
  let p be FinSequence of F, p1 be FinSequence of F1 such that
A1: dom p1 = dom p and
A2: for i st i in dom p for T st T = p.i holds p1.i = T`1;
  set W = [d1,d2]-tree p, W1 = d1-tree p1;
A3: len doms p = len p by TREES_3:40;
A4: len doms p1 = len p1 by TREES_3:40;
A5: len p = len p1 by A1,FINSEQ_3:31;
then A6: dom doms p = dom doms p1 by A3,A4,FINSEQ_3:31;
A7: dom doms p = dom p by A3,FINSEQ_3:31;
 now
    let i be Nat;
    assume
A9: i in dom p;
    then reconsider T = p.i as Element of F by Lm1;
A10: p1.i = T`1 by A2,A9;
A11: (doms p).i = dom T by A9,FUNCT_6:31;
 (doms p1).i = dom T`1 by A1,A9,A10,FUNCT_6:31;
    hence (doms p).i = (doms p1).i by A11,Th24;
  end;
then A13: doms p = doms p1 by A6,A7,FINSEQ_1:17;
 dom W`1 = dom W by Th24
    .= tree(doms p) by Th10;
  hence dom W`1 = dom W1 by A13,Th10;
  let x be Node of W`1;
  reconsider a = x as Node of W by Th24;
A15: W`1.x = (W.a)`1 by TREES_3:41;
  per cases;
  suppose
 x = {};
then  W.x = [d1,d2] & W1.x = d1 by Def4;
    hence thesis by A15,MCART_1:7;
  end;
  suppose
 x <> {};
    then consider n being Element of NAT, T being DecoratedTree,
    q being Node of T such that
A19: n < len p and
A20: T = p.(n+1) and
A21: a = <*n*>^q by Th11;
    reconsider T as Element of F by A19,A20,Lm3;
    reconsider q as Node of T`1 by Th24;
A22: p1.(n+1) = T`1 by A2,A19,A20,Lm2;
A23: W.a = T.q by A19,A20,A21,Th12;
 W1.a = T`1.q by A5,A19,A21,A22,Th12;
    hence thesis by A15,A23,TREES_3:41;
  end;
end;

theorem Th28:
  for D1,D2, d1,d2, F,F2
  for p being FinSequence of F, p2 being FinSequence of F2 st dom p2 = dom p &
  for i st i in dom p for T st T = p.i holds p2.i = T`2
  holds ([d1,d2]-tree p)`2 = d2-tree p2
proof
  let D1,D2, d1,d2, F,F2;
  let p be FinSequence of F, p2 be FinSequence of F2 such that
A1: dom p2 = dom p and
A2: for i st i in dom p for T st T = p.i holds p2.i = T`2;
  set W = [d1,d2]-tree p, W2 = d2-tree p2;
A3: len doms p = len p by TREES_3:40;
A4: len doms p2 = len p2 by TREES_3:40;
A5: len p = len p2 by A1,FINSEQ_3:31;
then A6: dom doms p = dom doms p2 by A3,A4,FINSEQ_3:31;
A7: dom doms p = dom p by A3,FINSEQ_3:31;
 now
    let i be Nat;
    assume
A9: i in dom p;
    then reconsider T = p.i as Element of F by Lm1;
A10: p2.i = T`2 by A2,A9;
A11: (doms p).i = dom T by A9,FUNCT_6:31;
 (doms p2).i = dom T`2 by A1,A9,A10,FUNCT_6:31;
    hence (doms p).i = (doms p2).i by A11,Th24;
  end;
then A13: doms p = doms p2 by A6,A7,FINSEQ_1:17;
 dom W`2 = dom W by Th24
    .= tree(doms p) by Th10;
  hence dom W`2 = dom W2 by A13,Th10;
  let x be Node of W`2;
  reconsider a = x as Node of W by Th24;
A15: W`2.x = (W.a)`2 by TREES_3:41;
  per cases;
  suppose
 x = {};
then  W.x = [d1,d2] & W2.x = d2 by Def4;
    hence thesis by A15,MCART_1:7;
  end;
  suppose
 x <> {};
    then consider n being Element of NAT, T being DecoratedTree,
    q being Node of T such that
A19: n < len p and
A20: T = p.(n+1) and
A21: a = <*n*>^q by Th11;
    reconsider T as Element of F by A19,A20,Lm3;
    reconsider q as Node of T`2 by Th24;
A22: p2.(n+1) = T`2 by A2,A19,A20,Lm2;
A23: W.a = T.q by A19,A20,A21,Th12;
 W2.a = T`2.q by A5,A19,A21,A22,Th12;
    hence thesis by A15,A23,TREES_3:41;
  end;
end;

theorem Th29:
  for D1,D2, d1,d2, F for p being FinSequence of F
  ex p1 being FinSequence of Trees D1 st dom p1 = dom p &
  (for i st i in dom p ex T being Element of F st T = p.i & p1.i = T`1) &
  ([d1,d2]-tree p)`1 = d1-tree p1
proof
  let D1,D2, d1,d2, F;
  let p be FinSequence of F;
A1: Seg len p = dom p by FINSEQ_1:def 3;
  defpred X[set,set] means ex T being Element of F st T = p.$1 & $2 = T`1;
A2: for i be Nat st i in Seg len p ex x being Element of Trees D1 st X[i,x]
  proof
    let i be Nat;
    assume i in Seg len p;
    then reconsider T = p.i as Element of F by A1,Lm1;
    reconsider y = T`1 as Element of Trees D1 by TREES_3:def 7;
    take y, T;
    thus thesis;
  end;
  consider p1 being FinSequence of Trees D1 such that
A4: dom p1 = Seg len p & for i be Nat st i in Seg len p holds X[i,p1.i]
  from FINSEQ_1:sch 5(A2);
  take p1;
  thus
A5: dom p1 = dom p by A4,FINSEQ_1:def 3;
  hence for i st i in dom p
  ex T being Element of F st T = p.i & p1.i = T`1 by A4;
 now
    let i;
    assume i in dom p;
then  ex T being Element of F st T = p.i & p1.i = T`1 by A4,A5;
    hence for T st T = p.i holds p1.i = T`1;
  end;
  hence thesis by A5,Th27;
end;

theorem Th30:
  for D1,D2, d1,d2, F for p being FinSequence of F
  ex p2 being FinSequence of Trees D2 st dom p2 = dom p &
  (for i st i in dom p ex T being Element of F st T = p.i & p2.i = T`2) &
  ([d1,d2]-tree p)`2 = d2-tree p2
proof
  let D1,D2, d1,d2, F;
  let p be FinSequence of F;
A1: Seg len p = dom p by FINSEQ_1:def 3;
  defpred X[Nat,set] means ex T being Element of F st T = p.$1 & $2 = T`2;
A2: for i be Nat st i in Seg len p ex x being Element of Trees D2 st X[i,x]
  proof
    let i be Nat;
    assume i in Seg len p;
    then reconsider T = p.i as Element of F by A1,Lm1;
    reconsider y = T`2 as Element of Trees D2 by TREES_3:def 7;
    take y, T;
    thus thesis;
  end;
  consider p2 being FinSequence of Trees D2 such that
A4: dom p2 = Seg len p & for i be Nat st i in Seg len p holds X[i,p2.i]
  from FINSEQ_1:sch 5(A2);
  take p2;
  thus
A5: dom p2 = dom p by A4,FINSEQ_1:def 3;
  hence for i st i in dom p
  ex T being Element of F st T = p.i & p2.i = T`2 by A4;
 now
    let i;
    assume i in dom p;
then  ex T being Element of F st T = p.i & p2.i = T`2 by A4,A5;
    hence for T st T = p.i holds p2.i = T`2;
  end;
  hence thesis by A5,Th28;
end;

theorem
  for D1,D2, d1,d2 for p being FinSequence of FinTrees [:D1,D2:]
  ex p1 being FinSequence of FinTrees D1 st dom p1 = dom p &
  (for i st i in dom p ex T being Element of FinTrees [:D1,D2:] st
  T = p.i & p1.i = T`1) & ([d1,d2]-tree p)`1 = d1-tree p1
proof
  let D1,D2, d1,d2;
  let p be FinSequence of FinTrees [:D1,D2:];
  consider p1 being FinSequence of Trees D1 such that
  A1: dom
 p1 = dom p & for i st i in dom p ex T being Element of FinTrees [:D1,D2
  :] st T = p.i & p1.i = T`1 and
A2: ([d1,d2]-tree p)`1 = d1-tree p1 by Th29;
 rng p1 c= FinTrees D1
  proof
    let x;
    assume x in rng p1;
    then consider y such that
A5: y in dom p1 and
A6: x = p1.y by FUNCT_1:def 5;
    reconsider y as Element of NAT by A5;
    consider T being Element of FinTrees [:D1,D2:] such that
    T = p.y and
A7: p1.y = T`1 by A1,A5;
 dom T`1 = dom T by Th24;
    hence thesis by A6,A7,TREES_3:def 8;
  end;
then  p1 is FinSequence of FinTrees D1 by FINSEQ_1:def 4;
  hence thesis by A1,A2;
end;

theorem
  for D1,D2, d1,d2 for p being FinSequence of FinTrees [:D1,D2:]
  ex p2 being FinSequence of FinTrees D2 st dom p2 = dom p &
  (for i st i in dom p ex T being Element of FinTrees [:D1,D2:] st
  T = p.i & p2.i = T`2) & ([d1,d2]-tree p)`2 = d2-tree p2
proof
  let D1,D2, d1,d2;
  let p be FinSequence of FinTrees [:D1,D2:];
  consider p2 being FinSequence of Trees D2 such that
  A1: dom
 p2 = dom p & for i st i in dom p ex T being Element of FinTrees [:D1,D2
  :] st T = p.i & p2.i = T`2 and
A2: ([d1,d2]-tree p)`2 = d2-tree p2 by Th30;
 rng p2 c= FinTrees D2
  proof
    let x;
    assume x in rng p2;
    then consider y such that
A5: y in dom p2 and
A6: x = p2.y by FUNCT_1:def 5;
    reconsider y as Element of NAT by A5;
    consider T being Element of FinTrees [:D1,D2:] such that
    T = p.y and
A7: p2.y = T`2 by A1,A5;
 dom T`2 = dom T by Th24;
    hence thesis by A6,A7,TREES_3:def 8;
  end;
then  p2 is FinSequence of FinTrees D2 by FINSEQ_1:def 4;
  hence thesis by A1,A2;
end;
