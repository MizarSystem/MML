:: Some Multi-instructions defined by sequence of instructions of SCM+FSA
::  by Noriko Asamoto
::
:: Received April 24, 1996
:: Copyright (c) 1996 Association of Mizar Users

environ

 vocabularies AMI_3, FINSET_1, AMI_1, SCMFSA_2, FINSEQ_1, FUNCT_4, RELAT_1,
      ABSVALUE, ARYTM_1, INT_1, TARSKI, BOOLE, FUNCT_1, DTCONSTR, CARD_1,
      FINSEQ_2, AMI_2, SCMFSA_7, FINSEQ_4, ARYTM;
 notations TARSKI, XBOOLE_0, SUBSET_1, CARD_1, NUMBERS, XCMPLX_0, NAT_1, INT_2,
      NAT_D, INT_1, RELAT_1, PARTFUN1, FINSEQ_1, FINSET_1, DTCONSTR, FINSOP_1,
      FUNCT_1, FUNCT_7, XXREAL_0, STRUCT_0, AMI_1, SCMNORM, SCMFSA_2;
 constructors PARTFUN1, WELLORD2, XXREAL_0, REAL_1, NAT_1, INT_2, FINSOP_1,
      DTCONSTR, AMI_3, SCMFSA_2, SCMNORM, NAT_D;
 registrations XBOOLE_0, SETFAM_1, RELAT_1, FUNCT_1, ORDINAL1, FRAENKEL,
      NUMBERS, XXREAL_0, XREAL_0, NAT_1, INT_1, FINSEQ_1, CARD_3, FUNCT_7,
      STRUCT_0, DTCONSTR, SCMFSA_2, FINSET_1;
 requirements REAL, NUMERALS, BOOLE, SUBSET, ARITHM;
 definitions TARSKI, AMI_1, FINSEQ_2, SCMFSA_2;
 theorems AMI_1, FUNCT_1, FUNCT_2, SCMFSA_2, PRE_CIRC, INT_1, NAT_1, FINSEQ_1,
      FINSEQ_2, FINSEQ_3, FINSEQ_4, FINSEQ_5, FINSEQ_6, RELAT_1, CARD_1,
      TARSKI, GRFUNC_1, DTCONSTR, ABSVALUE, FUNCT_7, XBOOLE_1, FINSET_1,
      XREAL_1, XXREAL_0, FUNCOP_1, AMI_3, CARD_3, ORDINAL1, PARTFUN1, NAT_D;
 schemes CLASSES1, FRAENKEL, FUNCT_7, NAT_1, FINSEQ_4, FINSEQ_1;

begin

reserve m for Element of NAT;

Lm1: for p1,p2,p3 being FinSequence holds
len p1 + len p2 + len p3 = len (p1 ^ p2 ^ p3) &
len p1 + len p2 + len p3 = len (p1 ^ (p2 ^ p3)) &
len p1 + (len p2 + len p3) = len (p1 ^ (p2 ^ p3)) &
len p1 + (len p2 + len p3) = len (p1 ^ p2 ^ p3)
proof
  let p1,p2,p3 be FinSequence; thus
A1: len p1 + len p2 + len p3 = len (p1 ^ p2) + len p3 by FINSEQ_1:35
    .= len (p1 ^ p2 ^ p3) by FINSEQ_1:35;
  hence len p1 + len p2 + len p3 = len (p1 ^ (p2 ^ p3)) by FINSEQ_1:45;
  thus len p1 + (len p2 + len p3) = len (p1 ^ (p2 ^ p3)) by A1,FINSEQ_1:45;
  thus thesis by A1;
end;

Lm2: for p1,p2,p3,p4 being FinSequence holds
p1 ^ p2 ^ p3 ^ p4 = p1 ^ p2 ^ (p3 ^ p4) &
p1 ^ p2 ^ p3 ^ p4 = p1 ^ (p2 ^ p3 ^ p4) &
p1 ^ p2 ^ p3 ^ p4 = p1 ^ (p2 ^ (p3 ^ p4)) &
p1 ^ p2 ^ p3 ^ p4 = p1 ^ (p2 ^ p3) ^ p4
proof
  let p1,p2,p3,p4 be FinSequence;
  thus p1 ^ p2 ^ p3 ^ p4 = p1 ^ p2 ^ (p3 ^ p4) by FINSEQ_1:45;
  thus p1 ^ p2 ^ p3 ^ p4 = p1 ^ (p2 ^ p3) ^ p4 by FINSEQ_1:45
    .= p1 ^ (p2 ^ p3 ^ p4) by FINSEQ_1:45;
  hence p1 ^ p2 ^ p3 ^ p4 = p1 ^ (p2 ^ (p3 ^ p4)) by FINSEQ_1:45;
  thus p1 ^ p2 ^ p3 ^ p4 = p1 ^ (p2 ^ p3) ^ p4 by FINSEQ_1:45;
end;

Lm3: for p1,p2,p3,p4,p5 being FinSequence holds
p1 ^ p2 ^ p3 ^ p4 ^ p5 = p1 ^ p2 ^ p3 ^ (p4 ^ p5) &
p1 ^ p2 ^ p3 ^ p4 ^ p5 = p1 ^ p2 ^ (p3 ^ p4 ^ p5) &
p1 ^ p2 ^ p3 ^ p4 ^ p5 = p1 ^ p2 ^ (p3 ^ (p4 ^ p5)) &
p1 ^ p2 ^ p3 ^ p4 ^ p5 = p1 ^ (p2 ^ p3 ^ p4 ^ p5) &
p1 ^ p2 ^ p3 ^ p4 ^ p5 = p1 ^ (p2 ^ p3 ^ (p4 ^ p5)) &
p1 ^ p2 ^ p3 ^ p4 ^ p5 = p1 ^ (p2 ^ (p3 ^ p4 ^ p5)) &
p1 ^ p2 ^ p3 ^ p4 ^ p5 = p1 ^ (p2 ^ (p3 ^ (p4 ^ p5))) &
p1 ^ p2 ^ p3 ^ p4 ^ p5 = p1 ^ p2 ^ (p3 ^ p4) ^ p5 &
p1 ^ p2 ^ p3 ^ p4 ^ p5 = p1 ^ (p2 ^ p3 ^ p4) ^ p5 &
p1 ^ p2 ^ p3 ^ p4 ^ p5 = p1 ^ (p2 ^ (p3 ^ p4)) ^ p5 &
p1 ^ p2 ^ p3 ^ p4 ^ p5 = p1 ^ (p2 ^ (p3 ^ p4) ^ p5)
proof
  let p1,p2,p3,p4,p5 be FinSequence;
  thus p1 ^ p2 ^ p3 ^ p4 ^ p5 = p1 ^ p2 ^ p3 ^ (p4 ^ p5) by FINSEQ_1:45;
  thus p1 ^ p2 ^ p3 ^ p4 ^ p5 = p1 ^ p2 ^ (p3 ^ p4 ^ p5) by Lm2;
  thus p1 ^ p2 ^ p3 ^ p4 ^ p5 = p1 ^ p2 ^ (p3 ^ (p4 ^ p5)) by Lm2; thus
A1: p1 ^ p2 ^ p3 ^ p4 ^ p5 = p1 ^ (p2 ^ p3 ^ p4) ^ p5 by Lm2
    .= p1 ^ (p2 ^ p3 ^ p4 ^ p5) by FINSEQ_1:45;
  hence p1 ^ p2 ^ p3 ^ p4 ^ p5 = p1 ^ (p2 ^ p3 ^ (p4 ^ p5)) by FINSEQ_1:45;
  thus p1 ^ p2 ^ p3 ^ p4 ^ p5 = p1 ^ (p2 ^ (p3 ^ p4 ^ p5)) by A1,Lm2;
  thus p1 ^ p2 ^ p3 ^ p4 ^ p5 = p1 ^ (p2 ^ (p3 ^ (p4 ^ p5))) by A1,Lm2;
  thus p1 ^ p2 ^ p3 ^ p4 ^ p5 = p1 ^ p2 ^ (p3 ^ p4) ^ p5 by Lm2;
  thus p1 ^ p2 ^ p3 ^ p4 ^ p5 = p1 ^ (p2 ^ p3 ^ p4) ^ p5 by Lm2;
  thus p1 ^ p2 ^ p3 ^ p4 ^ p5 = p1 ^ (p2 ^ (p3 ^ p4)) ^ p5 by Lm2;
  thus thesis by A1,Lm2;
end;
deffunc U(Element of NAT) = $1-'1;

definition
  let f be FinSequence of the Instructions of SCM+FSA;
  func Load f->FinPartState of SCM+FSA means
  :Def1:
  dom it = {m-'1: m in dom f} &
  for k being Element of NAT st k in dom it
  holds it.k = f/.(k+1);
  existence
  proof
    set X={ U(m): m in dom f};
    defpred P[set,set] means
    ex k being Element of NAT st $1 = insloc (k-'1) & $2 = f/.k & k in dom f;
A1: for e being set st e in X ex u being set st P[e,u]
    proof
      let e be set;
      assume e in X;
      then consider k being Element of NAT such that
A2:   e = k-'1 & k in dom f;
      take f/.k, k;
      thus thesis by A2;
    end;
    consider g being Function such that
A3: dom g = X & for e being set st e in
    X holds P[e,g.e] from CLASSES1:sch 1(A1);
A4: dom f is finite;
A5: X is finite from FRAENKEL:sch 21(A4);
A6: dom the Object-Kind of SCM+FSA = the carrier of SCM+FSA by FUNCT_2:def 1;
A7: dom g c= dom the Object-Kind of SCM+FSA
    proof
      let x be set;
      assume x in dom g;
      then consider k being Element of NAT such that
A8:   x = k-'1 & k in dom f by A3;
       x is Instruction-Location of SCM+FSA by A8,AMI_1:def 4;
      hence x in dom the Object-Kind of SCM+FSA by A6;
    end;
    now
      let x be set;
      assume x in dom g;
      then consider k being Element of NAT such that
A9:   x = insloc (k-'1) & g.x = f/.k & k in dom f by A3;
      (the Object-Kind of SCM+FSA).x = ObjectKind insloc (k-'1) by A9
        .= the Instructions of SCM+FSA by AMI_1:def 14;
      hence g.x in (the Object-Kind of SCM+FSA).x by A9;
    end;
    then reconsider g as FinPartState of SCM+FSA by A3,A5,A7,CARD_3:def 9,
    FINSET_1:29;
    take g;
    thus dom g = {m-'1: m in dom f} by A3;
    let k be Element of NAT;
    assume k in dom g;
    then consider a being Element of NAT such that
A10: insloc k = insloc (a-'1) & g.insloc k = f/.a & a in dom f by A3;
    consider n being Nat such that
A11: dom f = Seg n by FINSEQ_1:def 2;
A12: a >= 1 by A10,A11,FINSEQ_1:3;
A13: k + 1 >= 1 by NAT_1:11;
    k + 1 -' 1 = a -' 1 by A10,NAT_D:34;
    hence g.k = f/.(k+1) by A10,A12,A13,XREAL_1:236;
  end;
  uniqueness
  proof
    let g1,g2 be FinPartState of SCM+FSA such that
A14: dom g1 ={m-'1: m in dom f} &
    for k being Element of NAT st k in dom g1
    holds g1.k = f/.(k+1) and
A15: dom g2 ={m-'1: m in dom f} &
    for k being Element of NAT st k in dom g2
    holds g2.k = f/.(k+1);
    now
      let x be set;
      assume
A16:  x in dom g1;
      then consider k1 being Element of NAT such that
A17:  x = k1-'1 & k1 in dom f by A14;
      reconsider k = k1 -' 1 as Element of NAT;
      g2.insloc k = f/.(k+1) by A14,A15,A16,A17;
      hence g1.x = g2.x by A14,A16,A17;
    end;
    hence g1 = g2 by A14,A15,FUNCT_1:9;
  end;
end;

canceled 24;

theorem
  for f being FinSequence of the Instructions of SCM+FSA holds
  card Load f = len f
proof
  let f be FinSequence of the Instructions of SCM+FSA;
A1: dom f c= NAT;
A2: now
    let i,j be Element of NAT;
    assume
A3: i in dom f & j in dom f & U(i) = U(j);
    consider n being Nat such that
A4: dom f = Seg n by FINSEQ_1:def 2;
A5: 1 <= i & i <= n by A3,A4,FINSEQ_1:3;
    1 <= j & j <= n by A3,A4,FINSEQ_1:3;
    hence i = j by A3,A5,XREAL_1:236;
  end;
  set X={ U(m): m in dom f};
A6: dom f,X are_equipotent from FUNCT_7:sch 6(A1,A2);
  reconsider T = dom f as finite set;
A7: T = Seg len f by FINSEQ_1:def 3;
A8: dom f is finite;
  X is finite from FRAENKEL:sch 21(A8);
  then reconsider X as finite set;
A9: dom Load f = X by Def1;
  thus card Load f = card dom Load f by PRE_CIRC:21
    .= card T by A6,A9,CARD_1:21
    .= len Sgm Seg len f by A7,FINSEQ_3:44
    .= len f by FINSEQ_3:52;
end;

theorem Th26:
  for p being FinSequence of the Instructions of SCM+FSA,
  k being Element of NAT holds k in dom Load p iff k + 1 in dom p
proof
  let p be FinSequence of the Instructions of SCM+FSA, k be Element of NAT;
A1: dom Load p = {m-'1: m in dom p} by Def1;
  hereby
    assume k in dom Load p;
    then consider m such that
A2: m-'1 = k and
A3: m in dom p by A1;
    dom p = Seg len p by FINSEQ_1:def 3;
    then 1 <= m by A3,FINSEQ_1:3;
    then k + 1 = m - 1 + 1 by A2,XREAL_1:235
      .= m;
    hence k + 1 in dom p by A3;
  end;
  assume k + 1 in dom p;
  then insloc (k+1-'1) in dom Load p by A1;
  hence k in dom Load p by NAT_D:34;
end;

canceled 2;

theorem Th29:
  for p being FinSequence of the Instructions of SCM+FSA,
  k being Element of NAT holds k in dom Load p iff k < len p
proof
  let p be FinSequence of the Instructions of SCM+FSA, k be Element of NAT;
A1: dom p = Seg len p by FINSEQ_1:def 3;
  hereby
    assume k in dom Load p;
    then k + 1 in dom p by Th26;
    then 0 + 1 <= k + 1 & k + 1 <= len p by A1,FINSEQ_1:3;
    hence k < len p by NAT_1:13;
  end;
  assume k < len p;
  then 1 <= k + 1 & k + 1 <= len p by NAT_1:11,13;
  then k + 1 in Seg len p by FINSEQ_1:3;
  hence k in dom Load p by A1,Th26;
end;

theorem
  for f being non empty FinSequence of the Instructions of SCM+FSA holds
  1 in dom f & insloc 0 in dom Load f
proof
  let f be non empty FinSequence of the Instructions of SCM+FSA;
A1: dom Load f = {m-'1: m in dom f} by Def1;
  thus 1 in dom f by FINSEQ_5:6;
  then insloc (1-'1) in dom Load f by A1;
  hence insloc 0 in dom Load f by XREAL_1:234;
end;

theorem Th31:
  for p,q being FinSequence of the Instructions of SCM+FSA holds
  Load p c= Load (p ^ q)
proof
  let p,q be FinSequence of the Instructions of SCM+FSA;
A1: dom Load p = {m-'1: m in dom p} by Def1;
A2: dom Load (p ^ q) = {m-'1: m in dom (p ^ q)} by Def1;
A3: dom p c= dom (p ^ q) by FINSEQ_1:39;
  now
    let x be set;
    assume x in dom Load p;
    then consider m such that
A4: x = m-'1 & m in dom p by A1;
    thus x in dom Load (p ^ q) by A2,A3,A4;
  end;
  then
A5: dom Load p c= dom Load (p ^ q) by TARSKI:def 3;
A6: now
    let k be Element of NAT such that
A7:  k in dom Load p;
A8: dom p c= dom (p ^ q) by FINSEQ_1:39;
A9: k + 1 in dom p by A7,Th26;
    thus (Load (p ^ q)).k = (p ^ q)/.(k + 1) by A5,A7,Def1
      .= (p ^ q).(k + 1) by A8,A9,PARTFUN1:def 8
      .= p.(k + 1) by A9,FINSEQ_1:def 7
      .= p/.(k + 1) by A9,PARTFUN1:def 8
      .= (Load p).k by A7,Def1;
  end;
  now
    let x be set;
    assume
A10: x in dom Load p;
    then x in {m-'1: m in dom p} by Def1;
    then ex m being Element of NAT st x = m-'1 & m in dom p;
    hence (Load p).x = (Load (p ^ q)).x by A6,A10;
  end;
  hence thesis by A5,GRFUNC_1:8;
end;

theorem
  for p,q being FinSequence of the Instructions of SCM+FSA holds
  p c= q implies Load p c= Load q
proof
  let p,q be FinSequence of the Instructions of SCM+FSA;
  assume p c= q;
  then consider p' being FinSequence of the Instructions of SCM+FSA such that
A1: p ^ p' = q by FINSEQ_4:97;
  thus thesis by A1,Th31;
end;

definition
  let a be Int-Location;
  let k be Integer;
  func a := k -> FinPartState of SCM+FSA means
  :Def2:
  ex k1 being Element of NAT st k1 + 1 = k & it = Load(<* a:= intloc 0 *> ^
  ( k1 |-> AddTo(a,intloc 0) ) ^ <* halt SCM+FSA *> ) if k > 0 otherwise
  ex k1 being Element of NAT st k1 + k = 1 & it = Load(<* a:= intloc 0 *> ^
  ( k1 |-> SubFrom(a,intloc 0) ) ^ <* halt SCM+FSA *> );
  existence
  proof
    thus k > 0 implies ex f being FinPartState of SCM+FSA st
    ex k1 being Element of NAT st k1 + 1 = k &
    f = Load(<* a:= intloc 0 *> ^ ( k1 |-> AddTo(a,intloc 0) ) ^
    <* halt SCM+FSA *> )
    proof
      assume k > 0;
      then 0 + 1 <= k by INT_1:20;
      then reconsider k1 = k - 1 as Element of NAT by INT_1:18;
      take Load(<* a:= intloc 0 *> ^ ( k1 |-> AddTo(a,intloc 0) ) ^
      <* halt SCM+FSA *> ), k1;
      thus k1 + 1 = k;
      thus thesis;
    end;
    assume k <= 0;
    then reconsider k1 = 1 - k as Element of NAT by INT_1:18;
    take Load(<* a:= intloc 0 *> ^ ( k1 |-> SubFrom(a,intloc 0) ) ^
    <* halt SCM+FSA *> ), k1;
    thus k1 + k = 1;
    thus thesis;
  end;
  uniqueness;
  correctness;
end;

definition
  let a be Int-Location;
  let k be Integer;
  func aSeq(a,k) -> FinSequence of the Instructions of SCM+FSA means
  :Def3:
  ex k1 being Element of NAT st k1 + 1 = k &
  it = <* a:= intloc 0 *> ^ (k1 |-> AddTo(a,intloc 0)) if k > 0 otherwise
  ex k1 being Element of NAT st k1 + k = 1 &
  it = <* a:= intloc 0 *> ^ (k1 |-> SubFrom(a,intloc 0));
  existence
  proof
    thus k > 0 implies ex s being FinSequence of the Instructions of SCM+FSA
    st ex k1 being Element of NAT st k1 + 1 = k &
    s = <* a:= intloc 0 *> ^ ( k1 |-> AddTo(a,intloc 0) )
    proof
      assume k > 0;
      then 0 + 1 <= k by INT_1:20;
      then reconsider k1 = k - 1 as Element of NAT by INT_1:18;
      take <* a:= intloc 0 *> ^ ( k1 |-> AddTo(a,intloc 0) ),k1;
      thus k1 + 1 = k;
      thus thesis;
    end;
    assume k <= 0;
    then reconsider k1 = 1 - k as Element of NAT by INT_1:18;
    take <* a:= intloc 0 *> ^ ( k1 |-> SubFrom(a,intloc 0) ), k1;
    thus k1 + k = 1;
    thus thesis;
  end;
  uniqueness;
  correctness;
end;

theorem
  for a being Int-Location, k being Integer holds
  a:=k = Load (aSeq(a,k) ^ <* halt SCM+FSA *>)
proof
  let a be Int-Location, k be Integer;
  per cases;
  suppose k > 0;
    then consider k1 being Element of NAT such that
A1: k1 + 1 = k and
A2: a:=k = Load (<* a:=intloc 0 *>
    ^ (k1|->AddTo(a,intloc 0)) ^ <*halt SCM+FSA*>) by Def2;
    thus thesis by A1,A2,Def3;
  end;
  suppose
A3: k <= 0;
    then consider k1 being Element of NAT such that
A4: k1 + k = 1 and
A5: a:=k = Load (<* a:=intloc 0 *>
    ^ (k1|->SubFrom(a,intloc 0)) ^ <* halt SCM+FSA *>) by Def2;
    thus thesis by A3,A4,A5,Def3;
  end;
end;

definition
  let f be FinSeq-Location;
  let p be FinSequence of INT;
  func aSeq(f,p) -> FinSequence of the Instructions of SCM+FSA means
  :Def4:
  ex pp being FinSequence of (the Instructions of SCM+FSA)* st
  len pp = len p & (for k being Element of NAT st 1 <= k & k <= len p holds
  ex i being Integer st i = p.k & pp.k = (aSeq(intloc 1,k) ^
  aSeq(intloc 2,i) ^ <* (f,intloc 1):=intloc 2 *>)) & it = FlattenSeq pp;
  existence
  proof
    set D = (the Instructions of SCM+FSA)*;
    defpred P[Integer,set] means ex i being Integer st (i = p.$1 &
    $2 = (aSeq(intloc 1,$1) ^ aSeq(intloc 2,i) ^
    <* (f,intloc 1):=intloc 2 *>));
A1: for k being Nat st k in Seg len p
    ex d being Element of D st P[k,d]
    proof
      let k be Nat;
      assume k in Seg len p;
      then k in dom p by FINSEQ_1:def 3;
      then p.k in INT by FINSEQ_2:13;
      then reconsider i = p.k as Integer;
      reconsider d = aSeq(intloc 1,k) ^ aSeq(intloc 2,i) ^
      <* (f,intloc 1):=intloc 2 *> as Element of D by FINSEQ_1:def 11;
      take d;
      thus thesis;
    end;
    consider pp being FinSequence of D such that
A2: len pp = len p and
A3: for k being Nat st k in
    Seg len p holds P[k,pp/.k] from FINSEQ_4:sch 1(A1);
    take FlattenSeq pp;
    take pp;
    thus len pp = len p by A2;
    hereby
      let k be Element of NAT;
      assume
A4:   1 <= k & k <= len p;
      then k in dom p by FINSEQ_3:27;
      then p.k in INT by FINSEQ_2:13;
      then reconsider i = p.k as Integer;
      take i;
      thus i = p.k;
A5:   k in Seg len p by A4,FINSEQ_1:3;
      then
A6:   k in dom pp by A2,FINSEQ_1:def 3;
      P[k,pp/.k] by A3,A5;
      hence (aSeq(intloc 1,k) ^ aSeq(intloc 2,i) ^ <* (f,intloc 1):=intloc 2
      *>) = pp.k by A6,PARTFUN1:def 8;
    end;
    thus thesis;
  end;
  uniqueness
  proof
    let s1,s2 be FinSequence of the Instructions of SCM+FSA such that
A7: (ex pp being FinSequence of (the Instructions of SCM+FSA)* st
    len pp = len p & (for k being Element of NAT st 1 <= k & k <= len p holds
    ex i being Integer st i = p.k & pp.k = (aSeq(intloc 1,k) ^
    aSeq(intloc 2,i) ^ <* (f,intloc 1):=intloc 2 *>)) &
    s1 = FlattenSeq pp) and
A8: (ex pp being FinSequence of (the Instructions of SCM+FSA)* st
    len pp = len p & (for k being Element of NAT st 1 <= k & k <= len p holds
    ex i being Integer st i = p.k & pp.k = (aSeq(intloc 1,k) ^
    aSeq(intloc 2,i) ^ <* (f,intloc 1):=intloc 2 *>)) & s2 = FlattenSeq pp);
    consider pp1 being FinSequence of (the Instructions of SCM+FSA)* such that
A9: len pp1 = len p and
A10: for k being Element of NAT st 1 <= k & k <= len p holds
    ex i being Integer st i = p.k & pp1.k = (aSeq(intloc 1,k) ^
    aSeq(intloc 2,i) ^ <* (f,intloc 1):=intloc 2 *>) and
A11: s1 = FlattenSeq pp1 by A7;
    consider pp2 being FinSequence of (the Instructions of SCM+FSA)* such that
A12: len pp2 = len p and
A13: for k being Element of NAT st 1 <= k & k <= len p holds
    (ex i being Integer st i = p.k & pp2.k = (aSeq(intloc 1,k) ^
    aSeq(intloc 2,i) ^ <* (f,intloc 1):=intloc 2 *>)) and
A14: s2 = FlattenSeq pp2 by A8;
    reconsider i = len p as Element of NAT;
    len pp1=i & len pp2=i & (for k being Nat st k in dom pp1
    holds pp1.k = pp2.k)
    proof
      thus len pp1 = i & len pp2 = i by A9,A12;
      hereby
        let k be Nat;
A15:    k in NAT by ORDINAL1:def 13;
        assume k in dom pp1;
        then
A16:    1 <= k & k <= len p by A9,FINSEQ_3:27;
        then consider i1 being Integer such that
A17:    (i1 = p.k & pp1.k = (aSeq(intloc 1,k) ^ aSeq(intloc 2,i1) ^
        <* (f,intloc 1):=intloc 2 *>)) by A10,A15;
        consider i2 being Integer such that
A18:    (i2 = p.k & pp2.k = (aSeq(intloc 1,k) ^ aSeq(intloc 2,i2) ^
        <* (f,intloc 1):=intloc 2 *>)) by A13,A15,A16;
        thus pp1.k = pp2.k by A17,A18;
      end;
    end;
    hence s1 = s2 by A11,A14,FINSEQ_2:10;
  end;
  correctness;
end;

definition
  let f be FinSeq-Location;
  let p be FinSequence of INT;
  func f := p -> FinPartState of SCM+FSA equals

  Load (aSeq(intloc 1,len p) ^
  <* f:=<0,...,0>intloc 1 *> ^ aSeq(f,p) ^ <* halt SCM+FSA *> );
  correctness;
end;

theorem
  for a being Int-Location holds
  a:=1 = Load ( <* a:= intloc 0 *> ^ <* halt SCM+FSA *> )
proof
  let a be Int-Location;
A1: 0 |-> AddTo(a,intloc 0) = {} by FINSEQ_2:72;
A2: <* a:= intloc 0 *> ^ {} ^ <* halt SCM+FSA *>
  = <* a:= intloc 0 *> ^ <* halt SCM+FSA *> by FINSEQ_1:47;
  0 + 1 = 1;
  hence thesis by A1,A2,Def2;
end;

theorem
  for a being Int-Location holds
  a:=0 = Load (<* a:= intloc 0 *>^<*SubFrom(a,intloc 0)*>^<*halt SCM+FSA*>)
proof
  let a be Int-Location;
A1: 1 |-> SubFrom(a,intloc 0) = <*SubFrom(a,intloc 0)*> by FINSEQ_2:73;
  1 + 0 = 1;
  hence thesis by A1,Def2;
end;

theorem Th36:
  for s being State of SCM+FSA st s.intloc 0 = 1
  for c0 being Element of NAT st IC s = insloc c0 for a being Int-Location,
  k being Integer st a <> intloc 0 &
  (for c being Element of NAT st c in dom aSeq(a,k) holds
  aSeq(a,k).c = s.insloc (c0 + c -' 1)) holds
  (for i being Element of NAT st i <= len aSeq(a,k) holds
  IC  Computation(s,i) = insloc (c0 + i) &
  (for b being Int-Location st b <> a holds  Computation(s,i).b = s.b) &
  (for f being FinSeq-Location holds  Computation(s,i).f = s.f)) &
   Computation(s,len aSeq(a,k)).a = k
proof
  let s be State of SCM+FSA;
  assume
A1: s.intloc 0 = 1;
  let c0 be Element of NAT;
  assume
A2: IC s = insloc c0;
  let a be Int-Location;
  let k be Integer;
  assume that
A3: a <> intloc 0 and
A4: for c being Element of NAT st c in dom aSeq(a,k) holds
  aSeq(a,k).c = s.insloc (c0 + c -' 1);
  per cases;
  suppose
A5: k > 0;
    then reconsider k'= k as Element of NAT by INT_1:16;
    consider k1 being Element of NAT such that
A6: k1 + 1 = k' and
A7: aSeq(a,k') = <*a:=intloc 0*> ^ (k1 |-> AddTo(a,intloc 0)) by A5,Def3;
A8: len aSeq(a,k') = len <*a:=intloc 0*> + len (k1|->AddTo(a,intloc 0)) by A7,
    FINSEQ_1:35
      .= 1 + len(k1|->AddTo(a,intloc 0)) by FINSEQ_1:56
      .= k' by A6,FINSEQ_2:69;
    defpred Q[Element of NAT] means $1 <= k' implies
    IC  Computation(s,$1) = insloc (c0 + $1) &
    (1 <= $1 implies  Computation(s,$1).a = $1) &
    (for b being Int-Location st b <> a holds  Computation(s,$1).b=s.b) &
    (for f being FinSeq-Location holds  Computation(s,$1).f = s.f);
A9: (for i being Element of NAT st i <= len aSeq(a,k') holds
    IC  Computation(s,i) = insloc (c0 + i) &
    (1 <= i implies  Computation(s,i).a = i) &
    (for b being Int-Location st b <> a holds  Computation(s,i).b = s.b) &
    (for f being FinSeq-Location holds  Computation(s,i).f = s.f))
    proof
      let i be Element of NAT such that
A10:  i <= len aSeq(a,k');
A11:  now
        let i be Element of NAT;
        assume i < k';
        then insloc i in dom Load aSeq(a,k') by A8,Th29;
        hence i + 1 in dom aSeq(a,k') by Th26;
      end;
A12:  now
        let i be Element of NAT;
        assume
A13:    i < k';
        thus s.insloc (c0 + i) = s.insloc (c0 + i + 1 -' 1) by NAT_D:34
          .= s.insloc (c0 + (i + 1) -' 1)
          .= aSeq(a,k').(i + 1) by A4,A11,A13;
      end;
      then
A14:  s.insloc (c0 + 0) = aSeq(a,k').(0 + 1) by A5
        .= a:= intloc 0 by A7,FINSEQ_1:58;
A15:  now
        let i be Element of NAT;
        assume
A16:    1 < i & i <= k';
        then
A17:    1 <= i - 1 by INT_1:79;
        then reconsider i1 = i - 1 as Element of NAT by INT_1:16;
        i - 1 <= k' - 1 by A16,XREAL_1:11;
        then
A18:    i1 in Seg k1 by A6,A17,FINSEQ_1:3;
        len <* a:= intloc 0 *> = 1 by FINSEQ_1:56;
        hence aSeq(a,k').i
        = (k1 |-> AddTo(a,intloc 0)).(i - 1) by A7,A8,A16,FINSEQ_1:37
          .= AddTo(a,intloc 0) by A18,FUNCOP_1:13;
      end;
A19:  now
        let i be Element of NAT;
        assume
A20:    0 < i & i < k';
        then
A21:    0 + 1 < i + 1 by XREAL_1:8;
A22:    i + 1 <= k' by A20,NAT_1:13;
        thus s.insloc (c0 + i) = aSeq(a,k').(i+1) by A12,A20
          .=AddTo(a,intloc 0) by A15,A21,A22;
      end;
A23:  now
        let n be Element of NAT;
        assume n = 0;
        hence
A24:     Computation(s,n) = s by AMI_1:13;
        hence CurInstr  Computation(s,n) = a:= intloc 0 by A2,A14;
        thus  Computation(s,n+1) = Following  Computation(s,n) by AMI_1:14
          .= Exec(a:= intloc 0,s) by A2,A14,A24;
      end;
A25:  Q[0] by A2,AMI_1:13;
A26:  for n being Element of NAT st Q[n] holds Q[n + 1]
      proof
        let n be Element of NAT;
        assume
A27:    Q[n];
        assume
A28:    n + 1 <= k';
        per cases;
        suppose
A29:      n = 0;
          hence IC  Computation(s,n+1) = Exec(a:= intloc 0,s).IC SCM+FSA by
          A23
            .= Next insloc (c0 + n) by A2,A29,SCMFSA_2:89
            .= insloc (c0 + n + 1) by NAT_1:39
            .= insloc (c0 + (n + 1));
          hereby
            assume 1 <= n + 1;
            thus  Computation(s,n+1).a = Exec(a:= intloc 0,s).a by A23,A29
              .= n + 1 by A1,A29,SCMFSA_2:89;
          end;
          hereby
            let b be Int-Location;
            assume
A30:        b <> a;
            thus  Computation(s,n+1).b = Exec(a:= intloc 0,s).b by A23,A29
              .= s.b by A30,SCMFSA_2:89;
          end;
          let f be FinSeq-Location;
          thus  Computation(s,n+1).f = Exec(a:= intloc 0,s).f by A23,A29
            .= s.f by SCMFSA_2:89;
        end;
        suppose
A31:      n > 0;
          then
A32:      0 + 1 <= n by INT_1:20;
A33:      n + 0 <= n + 1 by XREAL_1:9;
A34:      0 < n & n < k' by A28,A31,NAT_1:13;
A35:      CurInstr  Computation(s,n)
          = s.insloc (c0 + n) by A27,A28,A33,AMI_1:54,XXREAL_0:2
            .= AddTo(a,intloc 0) by A19,A34;
A36:       Computation(s,n+1) = Following  Computation(s,n) by AMI_1:14
            .= Exec(AddTo(a,intloc 0), Computation(s,n)) by A35;
          hence IC  Computation(s,n+1) =
          Next IC  Computation(s,n) by SCMFSA_2:90
            .= insloc (c0 + n + 1) by A27,A28,A33,NAT_1:39,XXREAL_0:2
            .= insloc (c0 + (n + 1));
          hereby
            assume 1 <= n + 1;
            thus  Computation(s,n+1).a = n +  Computation(s,n).intloc 0
            by A27,A28,A32,A33,A36,SCMFSA_2:90,XXREAL_0:2
              .= n + 1 by A1,A3,A27,A28,A33,XXREAL_0:2;
          end;
          hereby
            let b be Int-Location;
            assume
A37:        b <> a;
            hence  Computation(s,n+1).b =  Computation(s,n).b
            by A36,SCMFSA_2:90
              .= s.b by A27,A28,A33,A37,XXREAL_0:2;
          end;
          let f be FinSeq-Location;
          thus ( Computation(s,n+1)).f =  Computation(s,n).f
          by A36,SCMFSA_2:90
            .= s.f by A27,A28,A33,XXREAL_0:2;
        end;
      end;
      for i being Element of NAT holds Q[i] from NAT_1:sch 1(A25,A26);
      hence thesis by A8,A10;
    end;
    hence for i being Element of NAT st i <= len aSeq(a,k) holds
    IC  Computation(s,i) = insloc (c0 + i) &
    (for b being Int-Location st b <> a holds  Computation(s,i).b = s.b) &
    (for f being FinSeq-Location holds  Computation(s,i).f = s.f);
    1 <= len aSeq(a,k) by A6,A8,NAT_1:11;
    hence  Computation(s,len aSeq(a,k)).a = k by A8,A9;
  end;
  suppose
A38: k <= 0;
    then -0 <= - k;
    then reconsider mk = - k as Element of NAT by INT_1:16;
    consider k1 being Element of NAT such that
A39: k1 + k = 1 and
A40: aSeq(a,k) = <*a:=intloc 0*> ^ (k1 |-> SubFrom(a,intloc 0)) by A38,Def3;
A41: len aSeq(a,k)
    = len <* a:=intloc 0 *> + len (k1|->SubFrom(a,intloc 0)) by A40,
    FINSEQ_1:35
      .= 1 + len (k1|->SubFrom(a,intloc 0)) by FINSEQ_1:56
      .= mk+1+1 by A39,FINSEQ_2:69;
    defpred Q[Element of NAT] means $1 <= mk+1+1 implies
    IC  Computation(s,$1) = insloc (c0 + $1) &
    (1 <= $1 implies  Computation(s,$1).a = -$1+1+1) &
    (for b being Int-Location st b <> a holds  Computation(s,$1).b=s.b) &
    (for f being FinSeq-Location holds  Computation(s,$1).f = s.f);
A42: for i being Element of NAT st i <= len aSeq(a,k) holds
    IC  Computation(s,i) = insloc (c0 + i) &
    (1 <= i implies  Computation(s,i).a = -i+1+1) &
    (for b being Int-Location st b <> a holds  Computation(s,i).b = s.b) &
    (for f being FinSeq-Location holds  Computation(s,i).f = s.f)
    proof
      let i be Element of NAT such that
A43:  i <= len aSeq(a,k);
A44:  now
        let i be Element of NAT;
        assume i < mk+1+1;
        then insloc i in dom Load aSeq(a,k) by A41,Th29;
        hence i + 1 in dom aSeq(a,k) by Th26;
      end;
A45:  now
        let i be Element of NAT;
        assume
A46:    i < mk+1+1;
        thus s.insloc (c0 + i) = s.insloc(c0 + i + 1 -' 1) by NAT_D:34
          .= s.insloc(c0 + (i + 1) -' 1)
          .= aSeq(a,k).(i+1) by A4,A44,A46;
      end;
      then
A47:  s.insloc (c0 + 0) = aSeq(a,k).(0+1)
        .= a:= intloc 0 by A40,FINSEQ_1:58;
A48:  now
        let i be Element of NAT;
        assume
A49:    1 < i & i <= mk+1+1;
        then
A50:    1 - 1 < i - 1 by XREAL_1:11;
        then
A51:    1 - 1 + 1 <= i - 1 by INT_1:20;
        reconsider i1 = i - 1 as Element of NAT by A50,INT_1:16;
        i - 1 <= mk+1+1 - 1 by A49,XREAL_1:11;
        then
A52:    i1 in Seg k1 by A39,A51,FINSEQ_1:3;
        len <* a:= intloc 0 *> = 1 by FINSEQ_1:56;
        hence aSeq(a,k).i
        = (k1|->SubFrom(a,intloc 0)).(i - 1) by A40,A41,A49,FINSEQ_1:37
          .= SubFrom(a,intloc 0) by A52,FUNCOP_1:13;
      end;
A53:  now
        let i be Element of NAT;
        assume
A54:    0 < i & i < mk+1+1;
        then
A55:    0 + 1 < i + 1 by XREAL_1:8;
A56:    i + 1 <= mk+1+1 by A54,NAT_1:13;
        thus s.insloc (c0 + i) = aSeq(a,k).(i+1) by A45,A54
          .=SubFrom(a,intloc 0) by A48,A55,A56;
      end;
A57:  for n being Element of NAT st n = 0 holds ( Computation(s,n) = s &
      CurInstr  Computation(s,n) = a:= intloc 0 &
       Computation(s,n+1) = Exec(a:= intloc 0,s))
      proof
        let n be Element of NAT;
        assume n = 0;
        hence
A58:     Computation(s,n) = s by AMI_1:13;
        hence CurInstr  Computation(s,n) = a:= intloc 0 by A2,A47;
        thus  Computation(s,n+1) = Following  Computation(s,n) by AMI_1:14
          .= Exec(a:= intloc 0,s) by A2,A47,A58;
      end;
A59:  Q[0] by A2,AMI_1:13;
A60:  for n being Element of NAT st Q[n] holds Q[n + 1]
      proof
        let n be Element of NAT;
        assume
A61:    Q[n];
        assume
A62:    n + 1 <= mk+1+1;
        per cases;
        suppose
A63:      n = 0;
          hence IC  Computation(s,n+1) = Exec(a:= intloc 0,s).IC SCM+FSA by
          A57
            .= Next insloc (c0 + n) by A2,A63,SCMFSA_2:89
            .= insloc (c0 + n + 1) by NAT_1:39
            .= insloc (c0 + (n + 1));
          hereby
            assume 1 <= n + 1;
            thus  Computation(s,n+1).a = Exec(a:= intloc 0,s).a by A57,A63
              .= -(n + 1)+1+1 by A1,A63,SCMFSA_2:89;
          end;
          hereby
            let b be Int-Location;
            assume
A64:        b <> a;
            thus  Computation(s,n+1).b = Exec(a:= intloc 0,s).b by A57,A63
              .= s.b by A64,SCMFSA_2:89;
          end;
          let f be FinSeq-Location;
          thus  Computation(s,n+1).f = Exec(a:= intloc 0,s).f by A57,A63
            .= s.f by SCMFSA_2:89;
        end;
        suppose
A65:      n > 0;
          then
A66:      0 + 1 < n + 1 by XREAL_1:8;
A67:      n + 0 <= n + 1 by XREAL_1:9;
A68:      0 < n & n < mk+1+1 by A62,A65,NAT_1:13;
A69:      CurInstr  Computation(s,n)
          = s.insloc (c0 + n) by A61,A62,A67,AMI_1:54,XXREAL_0:2
            .= SubFrom(a,intloc 0) by A53,A68;
A70:       Computation(s,n+1) = Following  Computation(s,n) by AMI_1:14
            .= Exec(SubFrom(a,intloc 0), Computation(s,n)) by A69;
          hence IC  Computation(s,n+1) =
          Next IC  Computation(s,n) by SCMFSA_2:91
            .= insloc (c0 + n + 1) by A61,A62,A67,NAT_1:39,XXREAL_0:2
            .= insloc (c0 + (n + 1));
          hereby
            assume 1 <= n + 1;
            thus  Computation(s,n+1).a =

-n+1+1 -  Computation(s,n).intloc 0 by A61,A62,A66,A70,NAT_1:13,SCMFSA_2:91
              .= -n+1+1 - s.intloc 0 by A3,A61,A62,A67,XXREAL_0:2
              .= -(n+1)+1+1 by A1;
          end;
          hereby
            let b be Int-Location;
            assume
A71:        b <> a;
            hence  Computation(s,n+1).b =  Computation(s,n).b
            by A70,SCMFSA_2:91
              .= s.b by A61,A62,A67,A71,XXREAL_0:2;
          end;
          let f be FinSeq-Location;
          thus ( Computation(s,n+1)).f =  Computation(s,n).f
          by A70,SCMFSA_2:91
            .= s.f by A61,A62,A67,XXREAL_0:2;
        end;
      end;
      for i being Element of NAT holds Q[i] from NAT_1:sch 1(A59,A60);
      hence thesis by A41,A43;
    end;
    hence for i being Element of NAT st i <= len aSeq(a,k) holds
    IC  Computation(s,i) = insloc (c0 + i) &
    (for b being Int-Location st b <> a holds  Computation(s,i).b = s.b) &
    (for f being FinSeq-Location holds  Computation(s,i).f = s.f);
    1 <= len aSeq(a,k) by A41,NAT_1:11;
    hence  Computation(s,len aSeq(a,k)).a = -(-k+(1+1))+1+1 by A41,A42
      .= k;
  end;
end;

theorem Th37:
  for s being State of SCM+FSA st IC s = insloc 0 & s.intloc 0 = 1
  for a being Int-Location
  for k being Integer st Load aSeq(a,k) c= s & a<>intloc 0 holds
  (for i being Element of NAT st i <= len aSeq(a,k) holds
  IC  Computation(s,i) = insloc i &
  (for b being Int-Location st b <> a holds  Computation(s,i).b = s.b) &
  (for f being FinSeq-Location holds  Computation(s,i).f = s.f)) &
   Computation(s,len aSeq(a,k)).a = k
proof
  let s be State of SCM+FSA;
  assume that
A1: IC s = insloc 0 and
A2: s.intloc 0 = 1;
  let a be Int-Location;
  let k be Integer;
  assume that
A3: Load aSeq(a,k) c= s and
A4: a <> intloc 0;
A5: dom Load aSeq(a,k) = {m-'1: m in dom aSeq(a,k)} &
  for m being Element of NAT st insloc m in dom Load aSeq(a,k) holds
  (Load aSeq(a,k)).insloc m = (aSeq(a,k))/.(m+1) by Def1;
A6: now
    let c be Element of NAT;
    assume
A7: c in dom aSeq(a,k);
    then c in Seg len aSeq(a,k) by FINSEQ_1:def 3;
    then 1 <= c by FINSEQ_1:3;
    then
A8: c -' 1 = c - 1 by XREAL_1:235;
A9: insloc (c-'1) in dom Load aSeq(a,k) by A5,A7;
    then (Load aSeq(a,k)).insloc (c-'1) = (aSeq(a,k))/.(c-'1+1) by Def1
      .= aSeq(a,k).c by A7,A8,PARTFUN1:def 8;
    hence aSeq(a,k).c = s.insloc (0 + c -' 1) by A3,A9,GRFUNC_1:8;
  end;
  hereby
    let i be Element of NAT;
    assume i <= len aSeq(a,k);
    then IC  Computation(s,i) = insloc (0 + i) &
    (for b being Int-Location st b <> a holds  Computation(s,i).b = s.b) &
    (for f being FinSeq-Location holds  Computation(s,i).f = s.f) by A1,A2
    ,A4,A6,Th36;
    hence IC  Computation(s,i) = insloc i &
    (for b being Int-Location st b <> a holds  Computation(s,i).b = s.b) &
    (for f being FinSeq-Location holds  Computation(s,i).f = s.f);
  end;
  thus thesis by A1,A2,A4,A6,Th36;
end;

:: Users' guide

theorem
  for s being State of SCM+FSA st IC s = insloc 0 & s.intloc 0 = 1
  for a being Int-Location, k being Integer st a:=k c= s & a<>intloc 0 holds
  s is halting & (Result s).a = k &
  (for b being Int-Location st b <> a holds (Result s).b = s.b) &
  (for f being FinSeq-Location holds (Result s).f = s.f)
proof
  let s be State of SCM+FSA;
  assume that
A1: IC s = insloc 0 and
A2: s.intloc 0 = 1;
  let a be Int-Location, k be Integer;
  assume that
A3: a:=k c= s and
A4: a <> intloc 0;
  per cases;
  suppose
A5: k > 0;
    then consider k1 being Element of NAT such that
A6: k1 + 1 = k & a:=k = Load (<*a:=intloc 0*> ^ (k1 |-> AddTo(a,intloc 0)) ^
    <*halt SCM+FSA*>) by Def2;
    set f = <*a:=intloc 0*> ^ (k1 |-> AddTo(a,intloc 0)) ^ <*halt SCM+FSA*>;
A7: len(<*a:=intloc 0*>^(k1|->AddTo(a,intloc 0)))
    = len<*a:=intloc 0*> + len(k1|->AddTo(a,intloc 0)) by FINSEQ_1:35
      .= 1 + len(k1|->AddTo(a,intloc 0)) by FINSEQ_1:56
      .= k by A6,FINSEQ_2:69;
    reconsider k as Element of NAT by A5,INT_1:16;
A8: len f = len(<*a:=intloc 0*>^(k1|->AddTo(a,intloc 0)))+len<*halt SCM+FSA*>
    by FINSEQ_1:35
      .= k + 1 by A7,FINSEQ_1:56;
    then
A9: dom f = Seg (k + 1) by FINSEQ_1:def 3;
A10: now
      let i be Element of NAT;
      assume
A11:  1 <= i & i <= k + 1;
A12:  dom Load f = {m-'1: m in dom f} by Def1;
      thus i in dom f by A9,A11,FINSEQ_1:3;
      hence insloc (i-'1) in dom Load f by A12;
    end;
A13: now
      let i be Element of NAT;
      assume 0 <= i & i <= k;
      then
A14:  0 + 1 <= i + 1 & i + 1 <= k + 1 by XREAL_1:8;
      hence i + 1 in dom f by A10;
      insloc (i + 1 -' 1) in dom Load f by A10,A14;
      hence insloc i in dom Load f by NAT_D:34;
    end;
A15: now
      let i be Element of NAT;
      assume 0 <= i & i <= k;
      then
A16:  i + 1 in dom f & insloc i in dom Load f by A13;
      hence s.insloc i = (Load f).insloc i by A3,A6,GRFUNC_1:8
        .= f/.(i+1) by A16,Def1
        .= f.(i+1) by A16,PARTFUN1:def 8;
    end;
A17: f.1 = (<*a:=intloc 0*>^((k1 |-> AddTo(a,intloc 0))^<*halt SCM+FSA*>)).1
    by FINSEQ_1:45
      .= a:= intloc 0 by FINSEQ_1:58;
A18: s.insloc 0 = f.(0+1) by A15
      .= a:= intloc 0 by A17;
A19: now
      let i be Element of NAT;
      assume
A20:  1 < i & i <= k;
      then
A21:  1 <= i - 1 by INT_1:79;
      then reconsider i1 = i - 1 as Element of NAT by INT_1:16;
      i - 1 <= k - 1 by A20,XREAL_1:11;
      then
A22:  i1 in Seg k1 by A6,A21,FINSEQ_1:3;
A23:  len <*a:= intloc 0*> = 1 by FINSEQ_1:56;
      dom (<*a:=intloc 0*>^(k1|->AddTo(a,intloc 0))) = Seg k
      by A7,FINSEQ_1:def 3;
      then i in dom (<*a:=intloc 0*>^(k1|->AddTo(a,intloc 0))) by A20,
      FINSEQ_1:3;
      hence f.i=(<*a:=intloc 0*>^(k1|->AddTo(a,intloc 0))).i by FINSEQ_1:def 7
        .= (k1|->AddTo(a,intloc 0)).(i - 1) by A7,A20,A23,FINSEQ_1:37
        .= AddTo(a,intloc 0) by A22,FUNCOP_1:13;
    end;
A24: now
      let i be Element of NAT;
      assume
A25:  0 < i & i < k;
      then
A26:  0 + 1 < i + 1 by XREAL_1:8;
A27:  i + 1 <= k by A25,NAT_1:13;
      thus s.insloc i = f.(i+1) by A15,A25
        .=AddTo(a,intloc 0) by A19,A26,A27;
    end;
    f.(k+1) = <* halt SCM+FSA *>.(k+1 - k) by A7,A8,FINSEQ_1:37,XREAL_1:31
      .= halt SCM+FSA by FINSEQ_1:def 8;
    then
A28: s.insloc k = halt SCM+FSA by A15;
A29: now
      let n be Element of NAT;
      assume n = 0;
      hence
A30:   Computation(s,n) = s by AMI_1:13;
      hence CurInstr  Computation(s,n) = a:= intloc 0 by A1,A18;
      thus  Computation(s,n+1) = Following  Computation(s,n) by AMI_1:14
        .= Exec(a:= intloc 0,s) by A1,A18,A30;
    end;
A31: for i being Element of NAT st i <= k holds IC  Computation(s,i) = insloc i
    proof
      let i be Element of NAT;
      assume
A32:  i <= k;
      defpred P[Element of NAT] means
      $1 <= k implies IC  Computation(s,$1) = insloc $1;
A33:  P[0] by A1,AMI_1:13;
A34:  for n being Element of NAT st P[n] holds P[n + 1]
      proof
        let n be Element of NAT;
        assume
A35:    P[n];
        assume
A36:    n+1 <= k;
        then
A37:    n < k by NAT_1:13;
        per cases;
        suppose
A38:      n=0;
          hence IC  Computation(s,n+1) = Exec(a:= intloc 0,s).IC SCM+FSA by
          A29
            .= Next insloc n by A1,A38,SCMFSA_2:89
            .= insloc (n+1) by NAT_1:39;
        end;
        suppose
A39:      n>0;
          n + 0 <= n + 1 by XREAL_1:9;
          then
A40:      CurInstr  Computation(s,n)
          = s.insloc n by A35,A36,AMI_1:54,XXREAL_0:2
            .= AddTo(a,intloc 0) by A24,A37,A39;
           Computation(s,n+1) = Following  Computation(s,n) by AMI_1:14
            .= Exec(AddTo(a,intloc 0), Computation(s,n)) by A40;
          hence IC  Computation(s,n+1) =
          Next IC  Computation(s,n) by SCMFSA_2:90
            .= insloc (n+1) by A35,A36,NAT_1:13,NAT_1:39;
        end;
      end;
      for i being Element of NAT holds P[i] from NAT_1:sch 1(A33,A34);
      hence IC  Computation(s,i) = insloc i by A32;
    end;
    defpred Q[Element of NAT] means $1 <= k implies
    (1 <= $1 implies  Computation(s,$1).a = $1) &
    (for b being Int-Location st b <> a holds  Computation(s,$1).b=s.b) &
    (for f being FinSeq-Location holds  Computation(s,$1).f = s.f);
A41: Q[0] by AMI_1:13;
A42: for n being Element of NAT st Q[n] holds Q[n + 1]
    proof
      let n be Element of NAT;
      assume
A43:  Q[n];
      assume
A44:  n + 1 <= k;
      per cases;
      suppose
A45:    n = 0;
        hereby
          assume 1 <= n + 1;
          thus  Computation(s,n+1).a = Exec(a:= intloc 0,s).a by A29,A45
            .= n + 1 by A2,A45,SCMFSA_2:89;
        end;
        hereby
          let b be Int-Location;
          assume
A46:      b <> a;
          thus  Computation(s,n+1).b = Exec(a:= intloc 0,s).b by A29,A45
            .= s.b by A46,SCMFSA_2:89;
        end;
        let f be FinSeq-Location;
        thus  Computation(s,n+1).f = Exec(a:= intloc 0,s).f by A29,A45
          .= s.f by SCMFSA_2:89;
      end;
      suppose
A47:    n > 0;
        then
A48:    0 + 1 <= n by INT_1:20;
A49:    n + 0 <= n + 1 by XREAL_1:9;
A50:    0 < n & n < k by A44,A47,NAT_1:13;
A51:    CurInstr  Computation(s,n)
        = ( Computation(s,n)).insloc n by A31,A44,A49,XXREAL_0:2
          .= s.insloc n by AMI_1:54
          .= AddTo(a,intloc 0) by A24,A50;
A52:     Computation(s,n+1) = Following  Computation(s,n) by AMI_1:14
          .= Exec(AddTo(a,intloc 0), Computation(s,n)) by A51;
        hereby
          assume 1 <= n + 1;
          thus  Computation(s,n+1).a = n +  Computation(s,n).intloc 0
          by A43,A44,A48,A49,A52,SCMFSA_2:90,XXREAL_0:2
            .= n + 1 by A2,A4,A43,A44,A49,XXREAL_0:2;
        end;
        hereby
          let b be Int-Location;
          assume
A53:      b <> a;
          hence  Computation(s,n+1).b =  Computation(s,n).b
          by A52,SCMFSA_2:90
            .= s.b by A43,A44,A49,A53,XXREAL_0:2;
        end;
        let f be FinSeq-Location;
        thus ( Computation(s,n+1)).f =  Computation(s,n).f
        by A52,SCMFSA_2:90
          .= s.f by A43,A44,A49,XXREAL_0:2;
      end;
    end;
A54: for i being Element of NAT holds Q[i] from NAT_1:sch 1(A41,A42);
A55: CurInstr  Computation(s,k) = ( Computation(s,k)).insloc k by A31
      .= halt SCM+FSA by A28,AMI_1:54;
    hence s is halting by AMI_1:def 20;
    then
A56:  Computation(s,k) = Result s by A55,AMI_1:def 22;
    0 + 1 < k + 1 by A5,XREAL_1:8;
    then 1 <= k by NAT_1:13;
    hence thesis by A54,A56;
  end;
  suppose
A57: k <= 0;
    then -0 <= - k;
    then reconsider mk = - k as Element of NAT by INT_1:16;
    consider k1 being Element of NAT such that
A58: k1 + k = 1 &
    a:=k = Load (<*a:=intloc 0*> ^ (k1 |-> SubFrom(a,intloc 0)) ^
    <*halt SCM+FSA*>) by A57,Def2;
    set f = <*a:=intloc 0*> ^ (k1 |-> SubFrom(a,intloc 0)) ^ <*halt SCM+FSA*>;
A59: len (<*a:=intloc 0*>^(k1|->SubFrom(a,intloc 0)))
    = len<*a:=intloc 0*> + len(k1|->SubFrom(a,intloc 0)) by FINSEQ_1:35
      .= 1 + len(k1|->SubFrom(a,intloc 0)) by FINSEQ_1:56
      .= mk+1+1 by A58,FINSEQ_2:69;
A60: len f = len(<*a:=intloc 0*>^(k1|->SubFrom(a,intloc 0)))+len<*halt SCM+FSA
    *> by FINSEQ_1:35
      .= mk+1+1 + 1 by A59,FINSEQ_1:56;
    then
A61: dom f = Seg (mk+1+1 + 1) by FINSEQ_1:def 3;
A62: now
      let i be Element of NAT;
      assume
A63:  1 <= i & i <= mk+1+1 + 1;
A64:  dom Load f = {m-'1: m in dom f} by Def1;
      thus i in dom f by A61,A63,FINSEQ_1:3;
      hence insloc (i-'1) in dom Load f by A64;
    end;
A65: now
      let i be Element of NAT;
      assume 0 <= i & i <= mk+1+1;
      then
A66:  0 + 1 <= i + 1 & i + 1 <= mk+1+1 + 1 by XREAL_1:8;
      hence i + 1 in dom f by A62;
      insloc (i + 1 -' 1) in dom Load f by A62,A66;
      hence insloc i in dom Load f by NAT_D:34;
    end;
A67: now
      let i be Element of NAT;
      assume 0 <= i & i <= mk+1+1;
      then
A68:  i + 1 in dom f & insloc i in dom Load f by A65;
      hence s.insloc i = (Load f).insloc i by A3,A58,GRFUNC_1:8
        .= f/.(i+1) by A68,Def1
        .= f.(i+1) by A68,PARTFUN1:def 8;
    end;
A69: f.1 = (<*a:=intloc 0*>^((k1|->SubFrom(a,intloc 0))^<*halt SCM+FSA*>)).1
    by FINSEQ_1:45
      .= a:= intloc 0 by FINSEQ_1:58;
A70: s.insloc 0 = f.(0+1) by A67
      .= a:= intloc 0 by A69;
A71: now
      let i be Element of NAT;
      assume
A72:  1 < i & i <= mk+1+1;
      then
A73:  1 - 1 < i - 1 by XREAL_1:11;
      then
A74:  1 - 1 + 1 <= i - 1 by INT_1:20;
      reconsider i1 = i - 1 as Element of NAT by A73,INT_1:16;
      i - 1 <= mk+1+1 - 1 by A72,XREAL_1:11;
      then
A75:  i1 in Seg k1 by A58,A74,FINSEQ_1:3;
A76:  len <*a:= intloc 0*> = 1 by FINSEQ_1:56;
      dom (<*a:=intloc 0*>^(k1|->SubFrom(a,intloc 0))) = Seg (mk+1+1)
      by A59,FINSEQ_1:def 3;
      then i in dom (<*a:=intloc 0*>^(k1|->SubFrom(a,intloc 0))) by A72,
      FINSEQ_1:3;
      hence f.i = (<*a:=intloc 0*>^(k1|->SubFrom(a,intloc 0))).i
      by FINSEQ_1:def 7
        .= (k1|->SubFrom(a,intloc 0)).(i - 1) by A59,A72,A76,FINSEQ_1:37
        .= SubFrom(a,intloc 0) by A75,FUNCOP_1:13;
    end;
A77: now
      let i be Element of NAT;
      assume
A78:  0 < i & i < mk+1+1;
      then
A79:  0 + 1 < i + 1 by XREAL_1:8;
A80:  i + 1 <= mk+1+1 by A78,NAT_1:13;
      thus s.insloc i = f.(i+1) by A67,A78
        .=SubFrom(a,intloc 0) by A71,A79,A80;
    end;
    f.(mk+1+1+1) = <*halt SCM+FSA*>.(mk+1+1+1-(mk+1+1)) by A59,A60,FINSEQ_1:37
    , XREAL_1:31
      .= halt SCM+FSA by FINSEQ_1:def 8;
    then
A81: s.insloc (mk+1+1) = halt SCM+FSA by A67;
A82: now
      let n be Element of NAT;
      assume n = 0;
      hence
A83:   Computation(s,n) = s by AMI_1:13;
      hence CurInstr  Computation(s,n) = a:= intloc 0 by A1,A70;
      thus  Computation(s,n+1) = Following  Computation(s,n) by AMI_1:14
        .= Exec(a:= intloc 0,s) by A1,A70,A83;
    end;
A84: for i being Element of NAT st i <= mk+1+1
    holds IC  Computation(s,i) = insloc i
    proof
      let i be Element of NAT;
      assume
A85:  i <= mk+1+1;
      defpred P[Element of NAT] means $1<=mk+1+1
      implies IC  Computation(s,$1)=insloc $1;
A86:  P[0] by A1,AMI_1:13;
A87:  for n being Element of NAT st P[n] holds P[n + 1]
      proof
        let n be Element of NAT;
        assume
A88:    P[n];
        assume
A89:    n+1 <= mk+1+1;
        then
A90:    n < mk+1+1 by NAT_1:13;
        per cases;
        suppose
A91:      n=0;
          hence IC  Computation(s,n+1) = Exec(a:= intloc 0,s).IC SCM+FSA by
          A82
            .= Next insloc n by A1,A91,SCMFSA_2:89
            .= insloc (n+1) by NAT_1:39;
        end;
        suppose
A92:      n>0;
          n + 0 <= n + 1 by XREAL_1:9;
          then
A93:      CurInstr  Computation(s,n)
          = s.insloc n by A88,A89,AMI_1:54,XXREAL_0:2
            .= SubFrom(a,intloc 0) by A77,A90,A92;
           Computation(s,n+1) = Following  Computation(s,n) by AMI_1:14
            .= Exec(SubFrom(a,intloc 0), Computation(s,n)) by A93;
          hence IC  Computation(s,n+1) =
          Next IC  Computation(s,n) by SCMFSA_2:91
            .= insloc (n+1) by A88,A89,NAT_1:13,NAT_1:39;
        end;
      end;
      for i being Element of NAT holds P[i] from NAT_1:sch 1(A86,A87);
      hence IC  Computation(s,i) = insloc i by A85;
    end;
    defpred Q[Element of NAT] means $1 <= mk+1+1 implies
    (1 <= $1 implies  Computation(s,$1).a = -$1+1+1) &
    (for b being Int-Location st b <> a holds  Computation(s,$1).b=s.b) &
    (for f being FinSeq-Location holds  Computation(s,$1).f = s.f);
A94: Q[0] by AMI_1:13;
A95: for n being Element of NAT st Q[n] holds Q[n + 1]
    proof
      let n be Element of NAT;
      assume
A96:  Q[n];
      assume
A97:  n + 1 <= mk+1+1;
      per cases;
      suppose
A98:    n = 0;
        hereby
          assume 1 <= n + 1;
          thus  Computation(s,n+1).a = Exec(a:= intloc 0,s).a by A82,A98
            .= -(n + 1)+1+1 by A2,A98,SCMFSA_2:89;
        end;
        hereby
          let b be Int-Location;
          assume
A99:      b <> a;
          thus  Computation(s,n+1).b = Exec(a:= intloc 0,s).b by A82,A98
            .= s.b by A99,SCMFSA_2:89;
        end;
        let f be FinSeq-Location;
        thus  Computation(s,n+1).f = Exec(a:= intloc 0,s).f by A82,A98
          .= s.f by SCMFSA_2:89;
      end;
      suppose
A100:   n > 0;
        then
A101:   0 + 1 < n + 1 by XREAL_1:8;
A102:   n + 0 <= n + 1 by XREAL_1:9;
A103:   0 < n & n < mk+1+1 by A97,A100,NAT_1:13;
A104:   CurInstr  Computation(s,n)
        = ( Computation(s,n)).insloc n by A84,A97,A102,XXREAL_0:2
          .= s.insloc n by AMI_1:54
          .= SubFrom(a,intloc 0) by A77,A103;
A105:    Computation(s,n+1) = Following  Computation(s,n) by AMI_1:14
          .= Exec(SubFrom(a,intloc 0), Computation(s,n)) by A104;
        hereby
          assume 1 <= n + 1;
          thus  Computation(s,n+1).a =

-n+1+1 -  Computation(s,n).intloc 0 by A96,A97,A101,A105,NAT_1:13,SCMFSA_2:91
            .= -n+1+1 - s.intloc 0 by A4,A96,A97,A102,XXREAL_0:2
            .= -(n+1)+1+1 by A2;
        end;
        hereby
          let b be Int-Location;
          assume
A106:     b <> a;
          hence  Computation(s,n+1).b =  Computation(s,n).b
          by A105,SCMFSA_2:91
            .= s.b by A96,A97,A102,A106,XXREAL_0:2;
        end;
        let f be FinSeq-Location;
        thus ( Computation(s,n+1)).f =  Computation(s,n).f
        by A105,SCMFSA_2:91
          .= s.f by A96,A97,A102,XXREAL_0:2;
      end;
    end;
A107: for i being Element of NAT holds Q[i] from NAT_1:sch 1(A94,A95);
A108: CurInstr  Computation(s,mk+1+1)
    = ( Computation(s,mk+1+1)).insloc (mk+1+1) by A84
      .= halt SCM+FSA by A81,AMI_1:54;
    hence s is halting by AMI_1:def 20;
    then
A109:  Computation(s,mk+1+1) = Result s by A108,AMI_1:def 22;
A110: -(mk+1+1)+1+1 = k;
    0 + 1 <= mk+(1+1) by XREAL_1:9;
    hence thesis by A107,A109,A110;
  end;
end;

theorem
  for s being State of SCM+FSA st IC s = insloc 0 & s.intloc 0 = 1
  for f being FinSeq-Location, p being FinSequence of INT st f:=p c= s holds
  s is halting & (Result s).f = p &
  (for b being Int-Location st b <> intloc 1 & b <> intloc 2
  holds (Result s).b = s.b) &
  (for g being FinSeq-Location st g <> f holds (Result s).g = s.g)
proof
  set O = intloc 0;    :: one
  set I = intloc 1;    :: location in p
  set V = intloc 2;    :: value
  set D = the Instructions of SCM+FSA;
A1: I <> O & V <> O & I <> V by AMI_3:52;
  let s be State of SCM+FSA such that
A2: IC s = insloc 0 and
A3: s.O = 1;
  let f be FinSeq-Location, p be FinSequence of INT such that
A4: f:=p c= s;
  set q = aSeq(I,len p)^<* f:=<0,...,0>I *>^aSeq(f,p)^<* halt SCM+FSA *>;
  set q0 = aSeq(I,len p) ^ <* f:=<0,...,0>I *>;
A5: dom Load q = {m-'1: m in dom q} by Def1;
A6: now
    let k be Element of NAT;
    assume
A7: insloc k in dom Load q;
    then
A8: k + 1 in dom q by Th26;
    thus (Load q).insloc k = q/.(k+1) by A7,Def1
      .= q.(k+1) by A8,PARTFUN1:def 8;
  end;
  consider pp being FinSequence of D* such that
A9: len pp = len p and
A10: for k being Element of NAT st 1 <= k & k <= len p holds
  ex i being Integer st i = p.k &
  pp.k = (aSeq(I,k) ^ aSeq(V,i) ^ <* (f,I):=V *>) and
A11: aSeq(f,p) = FlattenSeq pp by Def4;
  set k = len aSeq(I,len p);
A12: len q0 = k + 1 by FINSEQ_2:19;
A13: q = aSeq(I,len p)^<* f:=<0,...,0>I *>^(aSeq(f,p)^<* halt SCM+FSA *>)
  by FINSEQ_1:45;
  then q = aSeq(I,len p)^(<* f:=<0,...,0>I *>^(aSeq(f,p)^<* halt SCM+FSA *>))
  by FINSEQ_1:45;
  then Load aSeq(I,len p) c= f:=p by Th31;
  then
A14: Load aSeq(I,len p) c= s by A4,XBOOLE_1:1;
  then
A15: (for i being Element of NAT st i <= len aSeq(I,len p) holds
  IC  Computation(s,i) = insloc i &
  (for b being Int-Location st b <> I holds  Computation(s,i).b = s.b) &
  (for f being FinSeq-Location holds  Computation(s,i).f = s.f)) &
  Computation(s,len aSeq(I,len p)).I = len p by A1,A2,A3,Th37;
A16: now
    let i be Element of NAT;
    assume
A17: insloc i in dom Load q;
    then
A18: i + 1 in dom q by Th26;
    s.insloc i = (Load q).insloc i by A4,A17,GRFUNC_1:8;
    then s.insloc i = q/.(i + 1) by A17,Def1;
    hence s.insloc i = q.(i + 1) by A18,PARTFUN1:def 8;
  end;
A19: now
    let i,k be Element of NAT;
    assume i < len q;
    then
A20: insloc i in dom Load q by Th29;
    thus ( Computation(s,k)).insloc i = s.insloc i by AMI_1:54
      .= q.(i + 1) by A16,A20;
  end;
  defpred P[FinSequence] means $1 c= pp implies
  (ex pp0 being FinSequence of D* st (pp0 = $1 &
  (for i being Element of NAT st i <= len (q0 ^ FlattenSeq pp0) holds
  IC  Computation(s,i) = insloc i) &
  ((Computation(s,len (q0 ^ FlattenSeq pp0)).f) | Seg len pp0
  = p | Seg len pp0) &
  len (Computation(s,len (q0 ^ FlattenSeq pp0)).f) = len p &
  (for b being Int-Location st b <> I & b <> V
  holds Computation(s,len (q0 ^ FlattenSeq pp0)).b = s.b) &
  (for g being FinSeq-Location st g <> f
  holds Computation(s,len (q0 ^ FlattenSeq pp0)).g = s.g)));
A21: P[{}]
  proof
A22: q0 ^ FlattenSeq <*>(D*) = q0 ^ <*>D by DTCONSTR:20
      .= q0 by FINSEQ_1:47;
    assume {} c= pp;
    take <*>(D*);
    thus <*>(D*) = {};
A23: now
      let i be Element of NAT such that
A24:  i < len q0;
      i < len q0 implies i <= len aSeq(I,len p) by A12,NAT_1:13;
      hence IC  Computation(s,i) = insloc i by A1,A2,A3,A14,A24,Th37;
    end;
    k < len q0 by A12,NAT_1:13;
    then
A25: IC  Computation(s,k) = insloc k by A23;
    len q = len q0 + len ((aSeq(f,p) ^ <* halt SCM+FSA *>))
    by A13,FINSEQ_1:35;
    then len q0 <= len q by NAT_1:11;
    then
A26: k < len q by A12,NAT_1:13;
A27: 1 <= len q0 by A12,NAT_1:11;
A28: CurInstr  Computation(s,k) = q.len q0 by A12,A19,A25,A26
      .= q0.len q0 by A13,A27,FINSEQ_1:85
      .= f:=<0,...,0>I by A12,FINSEQ_1:59;
A29:  Computation(s,len q0) = Following  Computation(s,k) by A12,AMI_1:14
      .= Exec(f:=<0,...,0>I, Computation(s,k)) by A28;
    then
A30: IC  Computation(s,len q0) = Next IC  Computation(s,k) by SCMFSA_2 :101
      .= insloc len q0 by A12,A25,NAT_1:39;
    now
      let i be Element of NAT;
      assume i <= len q0;
      then i < len q0 or i = len q0 by XXREAL_0:1;
      hence IC  Computation(s,i) = insloc i by A23,A30;
    end;
    hence for i being Element of NAT st i <= len (q0 ^ FlattenSeq <*>(D*))
    holds IC  Computation(s,i) = insloc i by A22;
    len <*>(D*) = 0 by FINSEQ_1:32;
    hence (Computation(s,len (q0 ^ FlattenSeq <*>(D*))).f)|Seg len <*>(D *)
    = p | Seg len <*>(D*) by FINSEQ_1:94;
    consider ki being Element of NAT such that
A31: ki = abs( Computation(s,k).I) &
    Exec(f:=<0,...,0>I,  Computation(s,k)).f = ki |-> 0 by SCMFSA_2:101;
    ki = len p by A15,A31,ABSVALUE:def 1;
    hence len (Computation(s,len (q0 ^ FlattenSeq <*>(D*))).f)
    = len p by A22,A29,A31,FINSEQ_2:69;
    now
      let b be Int-Location such that
A32:  b <> I & b <> V;
      thus  Computation(s,len q0).b
      =  Computation(s,k).b by A29,SCMFSA_2:101
        .= s.b by A1,A2,A3,A14,A32,Th37;
    end;
    hence for b being Int-Location st b <> I & b <> V
    holds Computation(s,len (q0 ^ FlattenSeq <*>(D* ))).b = s.b by A22;
    now
      let g be FinSeq-Location such that
A33:  g <> f;
      thus  Computation(s,len q0).g
      =  Computation(s,k).g by A29,A33,SCMFSA_2:101
        .= s.g by A1,A2,A3,A14,Th37;
    end;
    hence thesis by A22;
  end;
A34: for r being FinSequence, x being set st P[r] holds P[r ^ <* x *>]
  proof
    let r be FinSequence, x be set;
    assume
A35: P[r];
    assume
A36: r ^ <* x *> c= pp;
    r c= r ^ <* x *> by FINSEQ_6:12;
    then consider pp0 being FinSequence of D* such that
A37: pp0 = r and
A38: for i being Element of NAT st i <= len (q0 ^ FlattenSeq pp0) holds
    IC  Computation(s,i) = insloc i and
A39: (Computation(s,len (q0 ^ FlattenSeq pp0)).f) | Seg len pp0
    = p | Seg len pp0 and
A40: len (Computation(s,len (q0 ^ FlattenSeq pp0)).f) = len p and
A41: for b being Int-Location st b <> I & b <> V
    holds Computation(s,len (q0 ^ FlattenSeq pp0)).b = s.b and
A42: for h being FinSeq-Location st h <> f
    holds Computation(s,len (q0 ^ FlattenSeq pp0)).h = s.h by A35,A36,
    XBOOLE_1:1;
    set r1 = len r + 1;
    len (r ^ <* x *>) = r1 by FINSEQ_2:19;
    then r1 in Seg len (r ^ <* x *>) by FINSEQ_1:6;
    then
A43: r1 in dom (r ^ <* x *>) by FINSEQ_1:def 3;
A44: dom (r ^ <* x *>) c= dom pp by A36,GRFUNC_1:8;
    then r1 in dom pp by A43;
    then
A45: r1 in Seg len pp by FINSEQ_1:def 3;
    then 1 <= r1 & r1 <= len pp by FINSEQ_1:3;
    then consider pr1 being Integer such that
A46: pr1 = p.r1 and
A47: pp.r1 = aSeq(I,r1) ^ aSeq(V,pr1) ^ <* (f,I):=V *> by A9,A10;
A48: now thus x = (r ^ <* x *>).r1 by FINSEQ_1:59
        .= pp.r1 by A36,A43,GRFUNC_1:8;
    end;
    then x in D* by A43,A44,FINSEQ_2:13;
    then <* x *> is FinSequence of D* by FINSEQ_1:95;
    then reconsider pp1 = pp0 ^ <* x *> as FinSequence of D* by FINSEQ_1:96;
    take pp1;
    thus pp1 = r ^ <* x *> by A37;
    reconsider x as Element of D* by A43,A44,A48,FINSEQ_2:13;
A49: x = aSeq(I,r1) ^ (aSeq(V,pr1) ^ <* (f,I):=V *>) by A47,A48,FINSEQ_1:45;
A50: FlattenSeq pp1 c= FlattenSeq pp by A36,A37,DTCONSTR:24;
A51: FlattenSeq pp1 = FlattenSeq pp0 ^ FlattenSeq <* x *> by DTCONSTR:21
      .= FlattenSeq pp0 ^ x by DTCONSTR:13;
    then
A52: q0 ^ FlattenSeq pp1 = q0 ^ FlattenSeq pp0 ^ x by FINSEQ_1:45;
    set c1 = len (q0 ^ FlattenSeq pp0);
    set s1 =  Computation(s,c1);
    set c2 = len (q0 ^ FlattenSeq pp0 ^ aSeq(I,r1));
    set s2 =  Computation(s,c2);
    set c3 = len (q0 ^ FlattenSeq pp0 ^ aSeq(I,r1) ^ aSeq(V,pr1));
A53: c2 = c1 + len aSeq(I,r1) by FINSEQ_1:35;
    then
A54: s2 = Computation(Computation(s,c1),len aSeq(I,r1)) by AMI_1:51;
A55: c3 = c1 + len aSeq(I,r1) + len aSeq(V,pr1) by A53,FINSEQ_1:35;
A56: c3 = c2 + len aSeq(V,pr1) by FINSEQ_1:35;
A57: now
      let p be FinSequence;
      assume p c= x;
      then FlattenSeq pp0 ^ p c= FlattenSeq pp0 ^ x by FINSEQ_6:15;
      then FlattenSeq pp0 ^ p c= FlattenSeq pp by A50,A51,XBOOLE_1:1;
      then q0 ^ (FlattenSeq pp0 ^ p) c= q0 ^ FlattenSeq pp by FINSEQ_6:15;
      then
A58:  q0 ^ FlattenSeq pp0 ^ p c= q0 ^ FlattenSeq pp by FINSEQ_1:45;
      q0 ^ FlattenSeq pp c= q by A11,FINSEQ_6:12;
      hence q0 ^ FlattenSeq pp0 ^ p c= q by A58,XBOOLE_1:1;
    end;
A59: s1.O = 1 & IC s1 = insloc c1 & I <> O &
    for c being Element of NAT st c in dom aSeq(I,r1) holds
    aSeq(I,r1).c = s1.insloc (c1 + c -' 1)
    proof
A60:  q0 ^ FlattenSeq pp0 ^ aSeq(I,r1) c= q by A49,A57,FINSEQ_6:12;
      then
A61:  dom (q0 ^ FlattenSeq pp0 ^ aSeq(I,r1)) c= dom q by GRFUNC_1:8;
      thus s1.O = 1 by A1,A3,A41;
      thus IC s1 = insloc c1 by A38;
      thus I <> O by AMI_3:52;
      let c be Element of NAT;
      assume
A62:  c in dom aSeq(I,r1);
      then
A63:  c1 + c in dom (q0 ^ FlattenSeq pp0 ^ aSeq(I,r1)) by FINSEQ_1: 41;
      then
A64:  insloc (c1 + c -' 1) in dom Load q by A5,A61;
      c1 + c >= 1 by A63,FINSEQ_3:27;
      then c1 + c -' 1 = c1 + c - 1 by XREAL_1:235;
      then
A65:  c1 + c -' 1 + 1 = c1 + c;
      thus aSeq(I,r1).c
      = (q0 ^ FlattenSeq pp0 ^ aSeq(I,r1)).(c1 + c) by A62,FINSEQ_1:def 7
        .= q.(c1 + c) by A60,A63,GRFUNC_1:8
        .= (Load q).insloc (c1 + c -' 1) by A6,A64,A65
        .= s.insloc (c1 + c -' 1) by A4,A64,GRFUNC_1:8
        .= s1.insloc (c1 + c -' 1) by AMI_1:54;
    end;
    then
A66: (for i being Element of NAT st i <= len aSeq(I,r1) holds
    IC  Computation(s1,i) = insloc (c1 + i) &
    (for b being Int-Location st b <> I holds  Computation(s1,i).b = s1.b)&
    (for f being FinSeq-Location holds  Computation(s1,i).f = s1.f)) &
    Computation(s1,len aSeq(I,r1)).I = r1 by Th36;
A67: now
      let i be Element of NAT;
      assume i <= len aSeq(I,r1);
      hence insloc (c1 + i) = IC  Computation(s1,i) by A59,Th36
        .= IC  Computation(s,c1+i) by AMI_1:51;
    end;
A68: s2.O = 1 & IC s2 = insloc c2 & V <> O &
    (for c being Element of NAT st c in dom aSeq(V,pr1) holds
    aSeq(V,pr1).c = s2.insloc (c2 + c -' 1))
    proof
      thus s2.O = 1 by A54,A59,Th36;
      thus IC s2 = insloc c2 by A53,A54,A59,Th36;
      thus V <> O by AMI_3:52;
      let c be Element of NAT;
      assume
A69:  c in dom aSeq(V,pr1);
      then
A70:  c2 + c in dom (q0 ^ FlattenSeq pp0 ^ aSeq(I,r1) ^ aSeq(V,pr1))
      by FINSEQ_1:41;
      q0 ^ FlattenSeq pp0 ^ (aSeq(I,r1) ^ aSeq(V,pr1)) c= q by A47,A48,A57,
      FINSEQ_6:12;
      then
A71:  q0 ^FlattenSeq pp0^aSeq(I,r1) ^ aSeq(V,pr1) c= q by FINSEQ_1: 45;
      then dom (q0 ^ FlattenSeq pp0 ^ aSeq(I,r1) ^ aSeq(V,pr1)) c= dom q
      by GRFUNC_1:8;
      then
A72:  insloc (c2 + c -' 1) in dom Load q by A5,A70;
      c2 + c >= 1 by A70,FINSEQ_3:27;
      then c2 + c -' 1 = c2 + c - 1 by XREAL_1:235;
      then
A73:  c2 + c -' 1 + 1 = c2 + c;
      thus aSeq(V,pr1).c
      = (q0 ^ FlattenSeq pp0 ^ aSeq(I,r1) ^ aSeq(V,pr1)).(c2 + c)
      by A69,FINSEQ_1:def 7
        .= q.(c2 + c) by A70,A71,GRFUNC_1:8
        .= (Load q).insloc (c2 + c -' 1) by A6,A72,A73
        .= s.insloc (c2 + c -' 1) by A4,A72,GRFUNC_1:8
        .= s2.insloc (c2 + c -' 1) by AMI_1:54;
    end;
    then
A74: (for i being Element of NAT st i <= len aSeq(V,pr1) holds
    IC  Computation(s2,i) = insloc (c2 + i) &
    (for b being Int-Location st b <> V holds  Computation(s2,i).b = s2.b)&
    (for f being FinSeq-Location holds  Computation(s2,i).f = s2.f)) &
    Computation(s2,len aSeq(V,pr1)).V = pr1 by Th36;
A75: now
      let i be Element of NAT;
      assume i <= len aSeq(V,pr1);
      hence insloc (c2 + i) = IC  Computation(s2,i) by A68,Th36
        .= IC  Computation(s,c2+i) by AMI_1:51;
    end;
A76: len q0 + len FlattenSeq pp1
    = len q0 + len (FlattenSeq pp0 ^ aSeq(I,r1) ^ (aSeq(V,pr1) ^
    <* (f,I):=V *>)) by A49,A51,FINSEQ_1:45
      .= len (q0 ^ (FlattenSeq pp0 ^ aSeq(I,r1) ^ (aSeq(V,pr1) ^
    <* (f,I):=V *>))) by FINSEQ_1:35
      .= len (q0 ^ FlattenSeq pp0 ^ aSeq(I,r1) ^ (aSeq(V,pr1) ^
    <* (f,I):=V *>)) by Lm3
      .= c2 + len (aSeq(V,pr1) ^ <* (f,I):=V *>) by FINSEQ_1:35
      .= c2 + (len aSeq(V,pr1) + len <* (f,I):=V *>) by FINSEQ_1:35
      .= c2 + (len aSeq(V,pr1) + 1) by FINSEQ_1:56
      .= c2 + len aSeq(V,pr1) + 1;
A77: for i being Element of NAT st i < len (q0 ^ FlattenSeq pp1) holds
    IC  Computation(s,i) = insloc i
    proof
      let i be Element of NAT;
      assume
A78:  i < len (q0 ^ FlattenSeq pp1);
A79:  now
        assume
A80:    not i <= c1;
        assume
A81:    not (c1 + 1 <= i & i <= c2);
        i < len q0 + len FlattenSeq pp1 by A78,FINSEQ_1:35;
        hence c2 + 1 <= i & i <= c2 + len aSeq(V,pr1) by A76,A80,A81,
        NAT_1:13;
      end;
      per cases by A79;
      suppose i <= len (q0 ^ FlattenSeq pp0);
        hence thesis by A38;
      end;
      suppose
A82:    c1 + 1 <= i & i <= c2;
        then
A83:    c1 + 1 - c1 <= i - c1 by XREAL_1:11;
A84:    i - c1 <= c2 - c1 by A82,XREAL_1:11;
        reconsider ii = i - c1 as Element of NAT by A83,INT_1:16;
        thus insloc i = IC  Computation(s,c1+ii) by A53,A67,A84
          .= IC  Computation(s,i);
      end;
      suppose
A85:    c2 + 1 <= i & i <= c2 + len aSeq(V,pr1);
        then
A86:    c2 + 1 - c2 <= i - c2 by XREAL_1:11;
A87:    i - c2 <= c2 + len aSeq(V,pr1) - c2 by A85,XREAL_1:11;
        reconsider ii = i - c2 as Element of NAT by A86,INT_1:16;
        thus insloc i = IC  Computation(s,c2+ii) by A75,A87
          .= IC  Computation(s,i);
      end;
    end;
A88: len (q0 ^ FlattenSeq pp1) = c2 + len aSeq(V,pr1) + 1 by A76,FINSEQ_1:35;
A89: len (q0 ^ FlattenSeq pp1) = c2 + len aSeq(V,pr1) + 1 &
    1 <= c2 + len aSeq(V,pr1) + 1 by A76,FINSEQ_1:35,NAT_1:11;
A90: len (q0 ^ FlattenSeq pp1) > c2 + len aSeq(V,pr1) by A88,NAT_1:13;
    len (q0 ^ FlattenSeq pp1) <= len q by A52,A57,FINSEQ_1:84;
    then
A91: c2 + len aSeq(V,pr1) < len q by A89,NAT_1:13;
A92: 1 <= len <* (f,I):=V *> by FINSEQ_1:57;
    len <* (f,I):=V *> <= len (aSeq(I,r1) ^ aSeq(V,pr1)) + len <* (f,I) := V
    *> by NAT_1:12;
    then len <* (f,I):=V *> <= len (aSeq(I,r1) ^ aSeq(V,pr1) ^ <* (f,I):=V *>)
    by FINSEQ_1:35;
    then
A93: 1 <= len x by A47,A48,FINSEQ_1:57;
    now thus CurInstr  Computation(s,c3)
      =  Computation(s,c3).insloc c3 by A56,A77,A90
        .= q.(c3 + 1) by A19,A56,A91
        .= (q0 ^ FlattenSeq pp0 ^ x).(c3 + 1) by A52,A56,A57,A89,FINSEQ_4:98
        .= (q0 ^ FlattenSeq pp0 ^ x).(c3 + len <* (f,I):=V *>) by FINSEQ_1:57
        .= (q0 ^ FlattenSeq pp0 ^ x).(c1 + (len aSeq(I,r1) + (len aSeq(V,pr1) +
      len <* (f,I):=V *>))) by A55;
    end;
    then
A94: CurInstr  Computation(s,c3)
    = (q0 ^ FlattenSeq pp0 ^ x).(c1 + len (aSeq(I,r1) ^ aSeq(V,pr1) ^
    <* (f,I):=V *>)) by Lm1
      .= (aSeq(I,r1) ^ aSeq(V,pr1) ^ <* (f,I):=V *>).
    len (aSeq(I,r1) ^ aSeq(V,pr1) ^ <* (f,I):=V *>) by A47,A48,A93,FINSEQ_1:86
      .= (aSeq(I,r1) ^ aSeq(V,pr1) ^ <* (f,I):=V *>).
    (len (aSeq(I,r1) ^ aSeq(V,pr1)) + len <* (f,I):=V *>) by FINSEQ_1:35
      .= <* (f,I):=V *>.len <* (f,I):=V *> by A92,FINSEQ_1:86
      .= <* (f,I):=V *>.1 by FINSEQ_1:57
      .= (f,I):=V by FINSEQ_1:57;
A95: now thus  Computation(s,c3+1)
      = Following  Computation(s,c3) by AMI_1:14
        .= Exec((f,I):=V, Computation(s,c3)) by A94;
    end;
A96: now thus IC Computation(s,len (q0 ^ FlattenSeq pp1))
      = Next IC  Computation(s,c3) by A56,A89,A95,SCMFSA_2:99
        .= Next insloc c3 by A56,A77,A90
        .= insloc len (q0 ^ FlattenSeq pp1) by A56,A88,NAT_1:39;
    end;
    thus for i being Element of NAT st i <= len (q0 ^ FlattenSeq pp1) holds
    IC  Computation(s,i) = insloc i
    proof
      let i be Element of NAT;
      assume
A97:  i <= len (q0 ^ FlattenSeq pp1);
      per cases by A97,XXREAL_0:1;
      suppose i < len (q0 ^ FlattenSeq pp1);
        hence IC  Computation(s,i) = insloc i by A77;
      end;
      suppose i = len (q0 ^ FlattenSeq pp1);
        hence IC  Computation(s,i) = insloc i by A96;
      end;
    end;
    consider ki being Element of NAT such that
A98: ki = abs( Computation(s,c3).I) & Exec((f,I):=V,  Computation(s,c3)).f
    =  Computation(s,c3).f +*(ki, Computation(s,c3).V) by SCMFSA_2:99;
A99: now thus ki = abs( Computation(s,c2 + len aSeq(V,pr1)).I ) by A98,
      FINSEQ_1:35
        .= abs( Computation(s2,len aSeq(V,pr1)).I ) by AMI_1:51
        .= abs( s2.I ) by A1,A68,Th36
        .= r1 by A54,A66,ABSVALUE:def 1;
    end;
A100: now thus  Computation(s,c3).V
      = Computation(s,c2 + len aSeq(V,pr1)).V by FINSEQ_1:35
        .= p.r1 by A46,A74,AMI_1:51;
    end;
A101: now thus  Computation(s,c3).f
      = Computation(s,c2 + len aSeq(V,pr1)).f by FINSEQ_1:35
        .= Computation(s2,len aSeq(V,pr1)).f by AMI_1:51
        .= s2.f by A68,Th36
        .= s1.f by A54,A59,Th36;
    end;
A102: dom (s1.f) = Seg len p by A40,FINSEQ_1:def 3;
A103: dom (s1.f +*(r1,p.r1)) = dom (s1.f) by FUNCT_7:32;
    then
A104: len (s1.f +*(r1,p.r1)) = len (s1.f) by FINSEQ_3:31;
    len pp1 <= len pp by A36,A37,FINSEQ_1:84;
    then
A105: Seg len pp1 c= Seg len p by A9,FINSEQ_1:7;
    dom (Computation(s,len (q0 ^ FlattenSeq pp1)).f) =
    Seg len p by A40,A56,A89,A95,A98,A99,A100,A101,A103,FINSEQ_1:def 3;
    then
A106: dom ((Computation(s,len (q0 ^ FlattenSeq pp1)).f) | Seg len pp1 )
    = Seg len pp1 by A105,RELAT_1:91;
    Seg len pp1 c= dom p by A105,FINSEQ_1:def 3;
    then
A107: dom (p | Seg len pp1) = Seg len pp1 by RELAT_1:91;
    for i being Element of NAT st i in Seg len pp1 holds
    ((Computation(s,len (q0 ^ FlattenSeq pp1)).f) | Seg len pp1).i
    = (p | Seg len pp1).i
    proof
      let i be Element of NAT;
      assume
A108: i in Seg len pp1;
      then
A109: 1 <= i & i <= len pp1 by FINSEQ_1:3;
      per cases;
      suppose
A110:   i = len pp1;
        then
A111:   i = len pp0 + 1 by FINSEQ_2:19;
        hence ((Computation(s,len (q0 ^ FlattenSeq pp1))).f | Seg len pp1).
        i = (s1.f +*(r1,p.r1)).i by A56,A88,A95,A98,A99,A100,A101,A110,
        FINSEQ_1:6,FUNCT_1:72
          .= p.i by A9,A37,A45,A102,A111,FUNCT_7:33
          .= (p | Seg len pp1).i by A110,A111,FINSEQ_1:6,FUNCT_1:72;
      end;
      suppose
A112:   i <> len pp1;
        then
A113:   i <> r1 by A37,FINSEQ_2:19;
        1 <= i & i < len pp1 by A109,A112,XXREAL_0:1;
        then 1 <= i & i < len pp0 + 1 by FINSEQ_2:19;
        then 1 <= i & i <= len pp0 by NAT_1:13;
        then
A114:   i in Seg len pp0 by FINSEQ_1:3;
        now thus ((Computation(s,len (q0 ^ FlattenSeq pp1))).f |
          Seg len pp1).i
          = (s1.f +*(r1,p.r1)).i by A56,A88,A95,A98,A99,A100,A101,A108,
          FUNCT_1:72
            .= s1.f.i by A113,FUNCT_7:34;
        end;
        hence ((Computation(s,len (q0 ^ FlattenSeq pp1))).f | Seg len pp1).
        i = (p | Seg len pp0).i by A39,A114,FUNCT_1:72
          .= p.i by A114,FUNCT_1:72
          .= (p | Seg len pp1).i by A108,FUNCT_1:72;
      end;
    end;
    then for i being set st i in Seg len pp1 holds
    ((Computation(s,len (q0 ^ FlattenSeq pp1)).f) | Seg len pp1).i
    = (p | Seg len pp1).i;
    hence (Computation(s,len (q0 ^ FlattenSeq pp1)).f) | Seg len pp1
    = p | Seg len pp1 by A106,A107,FUNCT_1:9;
    thus len (Computation(s,len (q0^FlattenSeq pp1)).f) = len p by A40, A89
    ,A95,A98,A99,A100,A101,A104,FINSEQ_1:35;
    hereby
      let b be Int-Location;
      assume
A115: b <> I & b <> V;
      thus Computation(s,len (q0 ^ FlattenSeq pp1)).b
      = Computation(s,c2 + len aSeq(V,pr1)).b by A56,A89,A95,SCMFSA_2:99
        .= Computation(s2,len aSeq(V,pr1)).b by AMI_1:51
        .= s2.b by A68,A115,Th36
        .= s1.b by A54,A59,A115,Th36
        .= s.b by A41,A115;
    end;
    hereby
      let h be FinSeq-Location;
      assume
A116: h <> f;
      hence Computation(s,len (q0 ^ FlattenSeq pp1)).h
      = Computation(s,c2 + len aSeq(V,pr1)).h by A56,A89,A95,SCMFSA_2:99
        .= Computation(s2,len aSeq(V,pr1)).h by AMI_1:51
        .= s2.h by A68,Th36
        .= s1.h by A54,A59,Th36
        .= s.h by A42,A116;
    end;
  end;
  for r being FinSequence holds P[r] from FINSEQ_1:sch 3(A21,A34);
  then consider pp0 being FinSequence of D* such that
A117: pp0 = pp and
A118: for i being Element of NAT st i <= len (q0 ^ FlattenSeq pp0) holds
  IC  Computation(s,i) = insloc i and
A119: (Computation(s,len (q0 ^ FlattenSeq pp0)).f) | Seg len pp0
  = p | Seg len pp0 and
A120: len (Computation(s,len (q0 ^ FlattenSeq pp0)).f) = len p and
A121: for b being Int-Location st b <> I & b <> V
  holds Computation(s,len (q0 ^ FlattenSeq pp0)).b = s.b and
A122: for g being FinSeq-Location st g <> f
  holds Computation(s,len (q0 ^ FlattenSeq pp0)).g = s.g;
A123: IC Computation(s,len (q0 ^ FlattenSeq pp))
  = insloc len (q0 ^ FlattenSeq pp) by A117,A118;
  len q = len (q0 ^ FlattenSeq pp) + 1 by A11,FINSEQ_2:19;
  then len (q0 ^ FlattenSeq pp) < len q by NAT_1:13;
  then
A124: CurInstr Computation(s,len (q0 ^ FlattenSeq pp))
  = q.(len (q0 ^ FlattenSeq pp) + 1) by A19,A123
    .= halt SCM+FSA by A11,FINSEQ_1:59;
  hence s is halting by AMI_1:def 20;
  then
A125: Computation(s,len (q0^FlattenSeq pp)) = Result s by A124, AMI_1:
  def 22;
  dom (Computation(s,len (q0 ^ FlattenSeq pp0)).f)
  = Seg len pp0 by A9,A117,A120,FINSEQ_1:def 3;
  then
A126: (Result s).f = p | Seg len pp0 by A117,A119,A125,RELAT_1:97;
  dom p = Seg len pp0 by A9,A117,FINSEQ_1:def 3;
  hence (Result s).f = p by A126,RELAT_1:97;
  thus thesis by A117,A121,A122,A125;
end;

