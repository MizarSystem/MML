:: Some Multi-instructions defined by sequence of instructions of SCM+FSA
::  by Noriko Asamoto
::
:: Received April 24, 1996
:: Copyright (c) 1996 Association of Mizar Users

environ

 vocabularies NUMBERS, SUBSET_1, FINSEQ_1, ARYTM_3, ORDINAL4, ARYTM_1, AMI_1,
      SCMFSA_2, RELAT_1, FUNCT_1, PARTFUN1, STRUCT_0, TARSKI, FINSET_1,
      XXREAL_0, NAT_1, CARD_1, XBOOLE_0, INT_1, GRAPHSP, FINSEQ_2, AMI_3,
      PRE_POLY, FSM_1, CIRCUIT2, SCMNORM, MSUALG_1, COMPLEX1, FUNCT_4,
      SCMFSA_7;
 notations TARSKI, XBOOLE_0, SUBSET_1, CARD_1, NUMBERS, XCMPLX_0, NAT_1, INT_2,
      NAT_D, INT_1, RELAT_1, PARTFUN1, FINSEQ_1, FINSET_1, FINSEQ_2, FUNCT_1,
      FUNCT_7, XXREAL_0, STRUCT_0, AMI_1, SCMNORM, SCMFSA_2, PRE_POLY;
 constructors PARTFUN1, WELLORD2, XXREAL_0, REAL_1, NAT_1, INT_2, FINSOP_1,
      DTCONSTR, AMI_3, SCMFSA_2, SCMNORM, NAT_D, RELSET_1, PRE_POLY, SCMFSA_1;
 registrations XBOOLE_0, SETFAM_1, RELAT_1, FUNCT_1, ORDINAL1, NUMBERS,
      XXREAL_0, XREAL_0, NAT_1, INT_1, FINSEQ_1, CARD_3, FUNCT_7, STRUCT_0,
      SCMFSA_2, FINSET_1, FINSEQ_2, CARD_1;
 requirements REAL, NUMERALS, BOOLE, SUBSET, ARITHM;
 definitions TARSKI, AMI_1, FINSEQ_1, FINSEQ_2, SCMFSA_2;
 theorems AMI_1, FUNCT_1, FUNCT_2, SCMFSA_2, INT_1, NAT_1, FINSEQ_1, FINSEQ_2,
      FINSEQ_3, FINSEQ_4, FINSEQ_5, FINSEQ_6, RELAT_1, CARD_1, TARSKI,
      GRFUNC_1, DTCONSTR, ABSVALUE, FUNCT_7, XBOOLE_1, FINSET_1, XREAL_1,
      XXREAL_0, FUNCOP_1, AMI_3, CARD_3, ORDINAL1, PARTFUN1, NAT_D, PRE_POLY;
 schemes CLASSES1, FRAENKEL, FUNCT_7, NAT_1, FINSEQ_4, FINSEQ_1;

begin

reserve m for Element of NAT;

Lm1: for p1,p2,p3 being FinSequence holds len p1 + len p2 + len p3 = len (p1 ^
p2 ^ p3) & len p1 + len p2 + len p3 = len (p1 ^ (p2 ^ p3)) & len p1 + (len p2 +
len p3) = len (p1 ^ (p2 ^ p3)) & len p1 + (len p2 + len p3) = len (p1 ^ p2 ^ p3
)

proof
  let p1,p2,p3 be FinSequence;
  thus
A1: len p1 + len p2 + len p3 = len (p1 ^ p2) + len p3 by FINSEQ_1:35
    .= len (p1 ^ p2 ^ p3) by FINSEQ_1:35;
  hence len p1 + len p2 + len p3 = len (p1 ^ (p2 ^ p3)) by FINSEQ_1:45;
  thus len p1 + (len p2 + len p3) = len (p1 ^ (p2 ^ p3)) by A1,FINSEQ_1:45;
  thus thesis by A1;
end;

Lm2: for p1,p2,p3,p4 being FinSequence holds p1 ^ p2 ^ p3 ^ p4 = p1 ^ p2 ^ (p3
^ p4) & p1 ^ p2 ^ p3 ^ p4 = p1 ^ (p2 ^ p3 ^ p4) & p1 ^ p2 ^ p3 ^ p4 = p1 ^ (p2
^ (p3 ^ p4)) & p1 ^ p2 ^ p3 ^ p4 = p1 ^ (p2 ^ p3) ^ p4

proof
  let p1,p2,p3,p4 be FinSequence;
  thus p1 ^ p2 ^ p3 ^ p4 = p1 ^ p2 ^ (p3 ^ p4) by FINSEQ_1:45;
  thus p1 ^ p2 ^ p3 ^ p4 = p1 ^ (p2 ^ p3) ^ p4 by FINSEQ_1:45
    .= p1 ^ (p2 ^ p3 ^ p4) by FINSEQ_1:45;
  hence p1 ^ p2 ^ p3 ^ p4 = p1 ^ (p2 ^ (p3 ^ p4)) by FINSEQ_1:45;
  thus thesis by FINSEQ_1:45;
end;

Lm3: for p1,p2,p3,p4,p5 being FinSequence holds p1 ^ p2 ^ p3 ^ p4 ^ p5 = p1 ^
p2 ^ p3 ^ (p4 ^ p5) & p1 ^ p2 ^ p3 ^ p4 ^ p5 = p1 ^ p2 ^ (p3 ^ p4 ^ p5) & p1 ^
p2 ^ p3 ^ p4 ^ p5 = p1 ^ p2 ^ (p3 ^ (p4 ^ p5)) & p1 ^ p2 ^ p3 ^ p4 ^ p5 = p1 ^
(p2 ^ p3 ^ p4 ^ p5) & p1 ^ p2 ^ p3 ^ p4 ^ p5 = p1 ^ (p2 ^ p3 ^ (p4 ^ p5)) & p1
^ p2 ^ p3 ^ p4 ^ p5 = p1 ^ (p2 ^ (p3 ^ p4 ^ p5)) & p1 ^ p2 ^ p3 ^ p4 ^ p5 = p1
^ (p2 ^ (p3 ^ (p4 ^ p5))) & p1 ^ p2 ^ p3 ^ p4 ^ p5 = p1 ^ p2 ^ (p3 ^ p4) ^ p5 &
p1 ^ p2 ^ p3 ^ p4 ^ p5 = p1 ^ (p2 ^ p3 ^ p4) ^ p5 & p1 ^ p2 ^ p3 ^ p4 ^ p5 = p1
^ (p2 ^ (p3 ^ p4)) ^ p5 & p1 ^ p2 ^ p3 ^ p4 ^ p5 = p1 ^ (p2 ^ (p3 ^ p4) ^ p5)

proof
  let p1,p2,p3,p4,p5 be FinSequence;
  thus p1 ^ p2 ^ p3 ^ p4 ^ p5 = p1 ^ p2 ^ p3 ^ (p4 ^ p5) by FINSEQ_1:45;
  thus p1 ^ p2 ^ p3 ^ p4 ^ p5 = p1 ^ p2 ^ (p3 ^ p4 ^ p5) by Lm2;
  thus p1 ^ p2 ^ p3 ^ p4 ^ p5 = p1 ^ p2 ^ (p3 ^ (p4 ^ p5)) by Lm2;
  thus
A1: p1 ^ p2 ^ p3 ^ p4 ^ p5 = p1 ^ (p2 ^ p3 ^ p4) ^ p5 by Lm2
    .= p1 ^ (p2 ^ p3 ^ p4 ^ p5) by FINSEQ_1:45;
  hence p1 ^ p2 ^ p3 ^ p4 ^ p5 = p1 ^ (p2 ^ p3 ^ (p4 ^ p5)) by FINSEQ_1:45;
  thus p1 ^ p2 ^ p3 ^ p4 ^ p5 = p1 ^ (p2 ^ (p3 ^ p4 ^ p5)) by A1,Lm2;
  thus p1 ^ p2 ^ p3 ^ p4 ^ p5 = p1 ^ (p2 ^ (p3 ^ (p4 ^ p5))) by A1,Lm2;
  thus p1 ^ p2 ^ p3 ^ p4 ^ p5 = p1 ^ p2 ^ (p3 ^ p4) ^ p5 by Lm2;
  thus p1 ^ p2 ^ p3 ^ p4 ^ p5 = p1 ^ (p2 ^ p3 ^ p4) ^ p5 by Lm2;
  thus p1 ^ p2 ^ p3 ^ p4 ^ p5 = p1 ^ (p2 ^ (p3 ^ p4)) ^ p5 by Lm2;
  thus thesis by A1,Lm2;
end;
deffunc U(Element of NAT) = $1-'1;

definition
  let f be FinSequence of the Instructions of SCM+FSA;
  func Load f->FinPartState of SCM+FSA means
  :Def1:
  dom it = {m-'1: m in dom f
  } & for k being Element of NAT st k in dom it holds it.k = f/.(k+1);
  existence
  proof
    defpred P[set,set] means ex k being Element of NAT st $1 = insloc (k-'1) &
    $2 = f/.k & k in dom f;
    set X={ U(m): m in dom f};
A1: for e being set st e in X ex u being set st P[e,u]
    proof
      let e be set;
      assume
      e in X;
      then consider k being Element of NAT such that
A2:   e = k-'1 & k in dom f;
      take f/.k, k;
      thus thesis by A2;
    end;
    consider g being Function such that
A3: dom g = X & for e being set st e in X holds P[e,g.e] from CLASSES1
    :sch 1(A1);
A4: dom the Object-Kind of SCM+FSA = the carrier of SCM+FSA by FUNCT_2:def 1;
A5: dom g c= dom the Object-Kind of SCM+FSA
    proof
      let x be set;
      assume
      x in dom g;
      then ex k being Element of NAT st x = k-'1 & k in dom f by A3;
      then x is Instruction-Location of SCM+FSA by AMI_1:def 4;
      hence thesis by A4;
    end;
A6: now
      let x be set;
      assume
      x in dom g;
      then consider k being Element of NAT such that
A7:   x = insloc (k-'1) and
A8:   g.x = f/.k and
      k in dom f by A3;
      (the Object-Kind of SCM+FSA).x = ObjectKind insloc (k-'1) by A7
        .= the Instructions of SCM+FSA by AMI_1:def 14;
      hence g.x in (the Object-Kind of SCM+FSA).x by A8;
    end;
A9: dom f is finite;
    X is finite from FRAENKEL:sch 21(A9);
    then reconsider g as FinPartState of SCM+FSA by A3,A5,A6,CARD_3:def 9
,FINSET_1:29;
    take g;
    thus dom g = {m-'1: m in dom f} by A3;
    let k be Element of NAT;
    assume
    k in dom g;
    then consider a being Element of NAT such that
A10: insloc k = insloc (a-'1) and
A11: g.insloc k = f/.a and
A12: a in dom f by A3;
A13: k + 1 >= 1 & k + 1 -' 1 = a -' 1 by A10,NAT_1:11,NAT_D:34;
    ex n being Nat st dom f = Seg n by FINSEQ_1:def 2;
    then a >= 1 by A12,FINSEQ_1:3;
    hence thesis by A11,A13,XREAL_1:236;
  end;
  uniqueness
  proof
    let g1,g2 be FinPartState of SCM+FSA such that
A14: dom g1 ={m-'1: m in dom f} & for k being Element of NAT st k in
    dom g1 holds g1.k = f/.(k+1) and
A15: dom g2 ={m-'1: m in dom f} & for k being Element of NAT st k in
    dom g2 holds g2.k = f/.(k+1);
    now
      let x be set;
      assume
A16:  x in dom g1;
      then consider k1 being Element of NAT such that
A17:  x = k1-'1 and
      k1 in dom f by A14;
      reconsider k = k1 -' 1 as Element of NAT;
      g2.insloc k = f/.(k+1) by A14,A15,A16,A17;
      hence g1.x = g2.x by A14,A16,A17;
    end;
    hence thesis by A14,A15,FUNCT_1:9;
  end;
end;

canceled 24;

theorem
  for f being FinSequence of the Instructions of SCM+FSA holds card Load
  f = len f
proof
  let f be FinSequence of the Instructions of SCM+FSA;
A1: now
    let i,j be Element of NAT;
    assume that
A2: i in dom f & j in dom f and
A3: U(i) = U(j);
    ex n being Nat st dom f = Seg n by FINSEQ_1:def 2;
    then 1 <= i & 1 <= j by A2,FINSEQ_1:3;
    hence i = j by A3,XREAL_1:236;
  end;
  set X={ U(m): m in dom f};
A4: dom f c= NAT;
A5: dom f,X are_equipotent from FUNCT_7:sch 6(A4,A1);
A6: dom f is finite;
  X is finite from FRAENKEL:sch 21(A6);
  then reconsider X as finite set;
A7: dom Load f = X by Def1;
  reconsider T = dom f as finite set;
A8: T = Seg len f by FINSEQ_1:def 3;
  thus card Load f = card dom Load f by CARD_1:104
    .= card T by A5,A7,CARD_1:21
    .= len Sgm Seg len f by A8,FINSEQ_3:44
    .= len f by FINSEQ_3:52;
end;

theorem Th26:
  for p being FinSequence of the Instructions of SCM+FSA, k being
  Element of NAT holds k in dom Load p iff k + 1 in dom p
proof
  let p be FinSequence of the Instructions of SCM+FSA, k be Element of NAT;
A1: dom Load p = {m-'1: m in dom p} by Def1;
  hereby
    assume
    k in dom Load p;
    then consider m such that
A2: m-'1 = k and
A3: m in dom p by A1;
    dom p = Seg len p by FINSEQ_1:def 3;
    then 1 <= m by A3,FINSEQ_1:3;
    then k + 1 = m - 1 + 1 by A2,XREAL_1:235
      .= m;
    hence k + 1 in dom p by A3;
  end;
  assume
  k + 1 in dom p;
  then insloc (k+1-'1) in dom Load p by A1;
  hence thesis by NAT_D:34;
end;

canceled 2;

theorem Th29:
  for p being FinSequence of the Instructions of SCM+FSA, k being
  Element of NAT holds k in dom Load p iff k < len p
proof
  let p be FinSequence of the Instructions of SCM+FSA, k be Element of NAT;
A1: dom p = Seg len p by FINSEQ_1:def 3;
  hereby
    assume
    k in dom Load p;
    then k + 1 in dom p by Th26;
    then k + 1 <= len p by A1,FINSEQ_1:3;
    hence k < len p by NAT_1:13;
  end;
  assume
  k < len p;
  then 1 <= k + 1 & k + 1 <= len p by NAT_1:11,13;
  then k + 1 in Seg len p;
  hence thesis by A1,Th26;
end;

theorem
  for f being non empty FinSequence of the Instructions of SCM+FSA holds
  1 in dom f & insloc 0 in dom Load f
proof
  let f be non empty FinSequence of the Instructions of SCM+FSA;
  thus
A1: 1 in dom f by FINSEQ_5:6;
  dom Load f = {m-'1: m in dom f} by Def1;
  then insloc (1-'1) in dom Load f by A1;
  hence thesis by XREAL_1:234;
end;

theorem Th31:
  for p,q being FinSequence of the Instructions of SCM+FSA holds
  Load p c= Load (p ^ q)
proof
  let p,q be FinSequence of the Instructions of SCM+FSA;
A1: dom p c= dom (p ^ q) by FINSEQ_1:39;
A2: dom Load (p ^ q) = {m-'1: m in dom (p ^ q)} by Def1;
A3: dom Load p = {m-'1: m in dom p} by Def1;
  now
    let x be set;
    assume
    x in dom Load p;
    then ex m st x = m-'1 & m in dom p by A3;
    hence x in dom Load (p ^ q) by A2,A1;
  end;
  then
A4: dom Load p c= dom Load (p ^ q) by TARSKI:def 3;
A5: now
A6: dom p c= dom (p ^ q) by FINSEQ_1:39;
    let k be Element of NAT such that
A7: k in dom Load p;
A8: k + 1 in dom p by A7,Th26;
    thus (Load (p ^ q)).k = (p ^ q)/.(k + 1) by A4,A7,Def1
      .= (p ^ q).(k + 1) by A6,A8,PARTFUN1:def 8
      .= p.(k + 1) by A8,FINSEQ_1:def 7
      .= p/.(k + 1) by A8,PARTFUN1:def 8
      .= (Load p).k by A7,Def1;
  end;
  now
    let x be set;
    assume
A9: x in dom Load p;
    then x in {m-'1: m in dom p} by Def1;
    then ex m being Element of NAT st x = m-'1 & m in dom p;
    hence (Load p).x = (Load (p ^ q)).x by A5,A9;
  end;
  hence thesis by A4,GRFUNC_1:8;
end;

theorem
  for p,q being FinSequence of the Instructions of SCM+FSA holds p c= q
  implies Load p c= Load q
proof
  let p,q be FinSequence of the Instructions of SCM+FSA;
  assume
  p c= q;
  then ex p' being FinSequence of the Instructions of SCM+FSA st p ^ p' = q by
FINSEQ_4:97;
  hence thesis by Th31;
end;

definition
  let a be Int-Location;
  let k be Integer;
  func a := k -> FinPartState of SCM+FSA means
  :Def2:
  ex k1 being Element of
NAT st k1 + 1 = k & it = Load(<* a:= intloc 0 *> ^ ( k1 |-> AddTo(a,intloc 0) )
^ <* halt SCM+FSA *> ) if k > 0 otherwise ex k1 being Element of NAT st k1 + k
  = 1 & it = Load(<* a:= intloc 0 *> ^ ( k1 |-> SubFrom(a,intloc 0) ) ^ <* halt
  SCM+FSA *> );
  existence
  proof
    thus k > 0 implies ex f being FinPartState of SCM+FSA st ex k1 being
Element of NAT st k1 + 1 = k & f = Load(<* a:= intloc 0 *> ^ ( k1 |-> AddTo(a,
    intloc 0) ) ^ <* halt SCM+FSA *> )
    proof
      assume
      k > 0;
      then 0 + 1 <= k by INT_1:20;
      then reconsider k1 = k - 1 as Element of NAT by INT_1:18;
      take Load(<* a:= intloc 0 *> ^ ( k1 |-> AddTo(a,intloc 0) ) ^ <* halt
      SCM+FSA *> ), k1;
      thus k1 + 1 = k;
      thus thesis;
    end;
    assume
    k <= 0;
    then reconsider k1 = 1 - k as Element of NAT by INT_1:18;
    take Load(<* a:= intloc 0 *> ^ ( k1 |-> SubFrom(a,intloc 0) ) ^ <* halt
    SCM+FSA *> ), k1;
    thus k1 + k = 1;
    thus thesis;
  end;
  uniqueness;
  correctness;
end;

definition
  let a be Int-Location;
  let k be Integer;
  func aSeq(a,k) -> FinSequence of the Instructions of SCM+FSA means
  :Def3:
  ex
k1 being Element of NAT st k1 + 1 = k & it = <* a:= intloc 0 *> ^ (k1 |-> AddTo
(a,intloc 0)) if k > 0 otherwise ex k1 being Element of NAT st k1 + k = 1 & it
  = <* a:= intloc 0 *> ^ (k1 |-> SubFrom(a,intloc 0));
  existence
  proof
    thus k > 0 implies ex s being FinSequence of the Instructions of SCM+FSA
st ex k1 being Element of NAT st k1 + 1 = k & s = <* a:= intloc 0 *> ^ ( k1 |->
    AddTo(a,intloc 0) )
    proof
      assume
      k > 0;
      then 0 + 1 <= k by INT_1:20;
      then reconsider k1 = k - 1 as Element of NAT by INT_1:18;
      take <* a:= intloc 0 *> ^ ( k1 |-> AddTo(a,intloc 0) ),k1;
      thus k1 + 1 = k;
      thus thesis;
    end;
    assume
    k <= 0;
    then reconsider k1 = 1 - k as Element of NAT by INT_1:18;
    take <* a:= intloc 0 *> ^ ( k1 |-> SubFrom(a,intloc 0) ), k1;
    thus k1 + k = 1;
    thus thesis;
  end;
  uniqueness;
  correctness;
end;

theorem
  for a being Int-Location, k being Integer holds a:=k = Load (aSeq(a,k)
  ^ <* halt SCM+FSA *>)
proof
  let a be Int-Location, k be Integer;
  per cases;
  suppose
    k > 0;
    then
    ex k1 being Element of NAT st k1 + 1 = k & a:=k = Load ( <* a:=intloc 0
    *> ^ (k1|->AddTo(a,intloc 0)) ^ <*halt SCM+FSA*>) by Def2;
    hence thesis by Def3;
  end;
  suppose
A1: k <= 0;
    then
    ex k1 being Element of NAT st k1 + k = 1 & a:=k = Load ( <* a:=intloc 0
    *> ^ (k1|->SubFrom(a,intloc 0)) ^ <* halt SCM+FSA *>) by Def2;
    hence thesis by A1,Def3;
  end;
end;

definition
  let f be FinSeq-Location;
  let p be FinSequence of INT;
  func aSeq(f,p) -> FinSequence of the Instructions of SCM+FSA means
  :Def4:
  ex
pp being FinSequence of (the Instructions of SCM+FSA)* st len pp = len p & (for
k being Element of NAT st 1 <= k & k <= len p holds ex i being Integer st i = p
.k & pp.k = (aSeq(intloc 1,k) ^ aSeq(intloc 2,i) ^ <* (f,intloc 1):=intloc 2 *>
  )) & it = FlattenSeq pp;
  existence
  proof
    defpred P[Integer,set] means ex i being Integer st (i = p.$1 & $2 = (aSeq(
    intloc 1,$1) ^ aSeq(intloc 2,i) ^ <* (f,intloc 1):=intloc 2 *>));
    set D = (the Instructions of SCM+FSA)*;
A1: for k being Nat st k in Seg len p ex d being Element of D st P[k,d]
    proof
      let k be Nat;
      assume
      k in Seg len p;
      then k in dom p by FINSEQ_1:def 3;
      then p.k in INT by FINSEQ_2:13;
      then reconsider i = p.k as Integer;
      reconsider d = aSeq(intloc 1,k) ^ aSeq(intloc 2,i) ^ <* (f,intloc 1):=
      intloc 2 *> as Element of D by FINSEQ_1:def 11;
      take d;
      thus thesis;
    end;
    consider pp being FinSequence of D such that
A2: len pp = len p and
A3: for k being Nat st k in Seg len p holds P[k,pp/.k] from FINSEQ_4:
    sch 1(A1);
    take FlattenSeq pp;
    take pp;
    thus len pp = len p by A2;
    hereby
      let k be Element of NAT;
      assume
A4:   1 <= k & k <= len p;
      then k in dom p by FINSEQ_3:27;
      then p.k in INT by FINSEQ_2:13;
      then reconsider i = p.k as Integer;
      take i;
      thus i = p.k;
      k in Seg len p by A4;
      then k in dom pp & P[k,pp/.k] by A2,A3,FINSEQ_1:def 3;
      hence
      (aSeq(intloc 1,k) ^ aSeq(intloc 2,i) ^ <* (f,intloc 1):=intloc 2 *>
      ) = pp.k by PARTFUN1:def 8;
    end;
    thus thesis;
  end;
  uniqueness
  proof
    reconsider i = len p as Element of NAT;
    let s1,s2 be FinSequence of the Instructions of SCM+FSA such that
A5: ex pp being FinSequence of (the Instructions of SCM+FSA)* st len
    pp = len p & (for k being Element of NAT st 1 <= k & k <= len p holds ex i
being Integer st i = p.k & pp.k = (aSeq(intloc 1,k) ^ aSeq(intloc 2,i) ^ <* (f,
    intloc 1):=intloc 2 *>)) & s1 = FlattenSeq pp and
A6: ex pp being FinSequence of (the Instructions of SCM+FSA)* st len
    pp = len p & (for k being Element of NAT st 1 <= k & k <= len p holds ex i
being Integer st i = p.k & pp.k = (aSeq(intloc 1,k) ^ aSeq(intloc 2,i) ^ <* (f,
    intloc 1):=intloc 2 *>)) & s2 = FlattenSeq pp;
    consider pp1 being FinSequence of (the Instructions of SCM+FSA)* such that
A7: len pp1 = len p and
A8: for k being Element of NAT st 1 <= k & k <= len p holds ex i
being Integer st i = p.k & pp1.k = (aSeq(intloc 1,k) ^ aSeq(intloc 2,i) ^ <* (f
    ,intloc 1):=intloc 2 *>) and
A9: s1 = FlattenSeq pp1 by A5;
    consider pp2 being FinSequence of (the Instructions of SCM+FSA)* such that
A10: len pp2 = len p and
A11: for k being Element of NAT st 1 <= k & k <= len p holds ex i
being Integer st i = p.k & pp2.k = (aSeq(intloc 1,k) ^ aSeq(intloc 2,i) ^ <* (f
    ,intloc 1):=intloc 2 *>) and
A12: s2 = FlattenSeq pp2 by A6;
    len pp1=i & len pp2=i & for k being Nat st k in dom pp1 holds pp1.k =
    pp2.k
    proof
      thus len pp1 = i & len pp2 = i by A7,A10;
      hereby
        let k be Nat;
        assume
        k in dom pp1;
        then
A13:    1 <= k & k <= len p by A7,FINSEQ_3:27;
        k in NAT by ORDINAL1:def 13;
        then (ex i1 being Integer st i1 = p.k & pp1.k = (aSeq(intloc 1, k) ^
aSeq(intloc 2,i1) ^ <* (f,intloc 1):= intloc 2 *>) )& ex i2 being Integer st i2
= p.k & pp2.k = (aSeq(intloc 1, k) ^ aSeq(intloc 2,i2) ^ <* (f,intloc 1):=
        intloc 2 *>) by A8,A11,A13;
        hence pp1.k = pp2.k;
      end;
    end;
    hence thesis by A9,A12,FINSEQ_2:10;
  end;
  correctness;
end;

definition
  let f be FinSeq-Location;
  let p be FinSequence of INT;
  func f := p -> FinPartState of SCM+FSA equals
  Load (aSeq(intloc 1,len p) ^
  <* f:=<0,...,0>intloc 1 *> ^ aSeq(f,p) ^ <* halt SCM+FSA *> );
  correctness;
end;

theorem
  for a being Int-Location holds a:=1 = Load ( <* a:= intloc 0 *> ^ <*
  halt SCM+FSA *> )
proof
  let a be Int-Location;
A1: 0 + 1 = 1;
  0 |-> AddTo(a,intloc 0) = {} & <* a:= intloc 0 *> ^ {} ^ <* halt SCM+FSA
  *> = <* a:= intloc 0 *> ^ <* halt SCM+FSA *> by FINSEQ_1:47;
  hence thesis by A1,Def2;
end;

theorem
  for a being Int-Location holds a:=0 = Load (<* a:= intloc 0 *>^<*
  SubFrom(a,intloc 0)*>^<*halt SCM+FSA*>)
proof
  let a be Int-Location;
  1 |-> SubFrom(a,intloc 0) = <*SubFrom(a,intloc 0)*> & 1 + 0 = 1 by
FINSEQ_2:73;
  hence thesis by Def2;
end;

theorem Th36:
  for s being State of SCM+FSA st s.intloc 0 = 1 for c0 being
Element of NAT st IC s = insloc c0 for a being Int-Location, k being Integer st
a <> intloc 0 & (for c being Element of NAT st c in dom aSeq(a,k) holds aSeq(a,
  k).c = s.insloc (c0 + c -' 1)) holds (for i being Element of NAT st i <= len
  aSeq(a,k) holds IC Computation(s,i) = insloc (c0 + i) & (for b being
  Int-Location st b <> a holds Computation(s,i).b = s.b) & (for f being
FinSeq-Location holds Computation(s,i).f = s.f)) & Computation(s,len aSeq(a,k))
  .a = k
proof
  let s be State of SCM+FSA;
  assume
A1: s.intloc 0 = 1;
  let c0 be Element of NAT;
  assume
A2: IC s = insloc c0;
  let a be Int-Location;
  let k be Integer;
  assume that
A3: a <> intloc 0 and
A4: for c being Element of NAT st c in dom aSeq(a,k) holds aSeq(a,k).c =
  s.insloc (c0 + c -' 1);
  per cases;
  suppose
A5: k > 0;
    then reconsider k'= k as Element of NAT by INT_1:16;
    consider k1 being Element of NAT such that
A6: k1 + 1 = k' and
A7: aSeq(a,k') = <*a:=intloc 0*> ^ (k1 |-> AddTo(a,intloc 0)) by A5,Def3;
    defpred Q[Element of NAT] means $1 <= k' implies IC Computation(s,$1) =
insloc (c0 + $1) & (1 <= $1 implies Computation(s,$1).a = $1) & (for b being
    Int-Location st b <> a holds Computation(s,$1).b=s.b) & (for f being
    FinSeq-Location holds Computation(s,$1).f = s.f);
A8: len aSeq(a,k') = len <*a:=intloc 0*> + len (k1|->AddTo(a,intloc 0)) by A7,
FINSEQ_1:35
      .= 1 + len(k1|->AddTo(a,intloc 0)) by FINSEQ_1:56
      .= k' by A6,FINSEQ_1:def 18;
A9: for i being Element of NAT st i <= len aSeq(a,k') holds IC Computation
    (s,i) = insloc (c0 + i) & (1 <= i implies Computation(s,i).a = i) & (for b
    being Int-Location st b <> a holds Computation(s,i).b = s.b) & for f being
    FinSeq-Location holds Computation(s,i).f = s.f
    proof
A10:  now
        let i be Element of NAT;
        assume
        i < k';
        then insloc i in dom Load aSeq(a,k') by A8,Th29;
        hence i + 1 in dom aSeq(a,k') by Th26;
      end;
A11:  now
        let i be Element of NAT;
        assume
A12:    i < k';
        thus s.insloc (c0 + i) = s.insloc (c0 + i + 1 -' 1) by NAT_D:34
          .= s.insloc (c0 + (i + 1) -' 1)
          .= aSeq(a,k').(i + 1) by A4,A10,A12;
      end;
      then
A13:  s.insloc (c0 + 0) = aSeq(a,k').(0 + 1) by A5
        .= a:= intloc 0 by A7,FINSEQ_1:58;
A14:  now
        let n be Element of NAT;
        assume
        n = 0;
        hence
A15:    Computation(s,n) = s by AMI_1:13;
        hence CurInstr Computation(s,n) = a:= intloc 0 by A2,A13;
        thus Computation(s,n+1) = Following Computation(s,n) by AMI_1:14
          .= Exec(a:= intloc 0,s) by A2,A13,A15;
      end;
A16:  now
        let i be Element of NAT;
        assume that
A17:    1 < i and
A18:    i <= k';
A19:    1 <= i - 1 by A17,INT_1:79;
        then reconsider i1 = i - 1 as Element of NAT by INT_1:16;
        i - 1 <= k' - 1 by A18,XREAL_1:11;
        then
A20:    i1 in Seg k1 by A6,A19;
        len <* a:= intloc 0 *> = 1 by FINSEQ_1:56;
        hence aSeq(a,k').i = (k1 |-> AddTo(a,intloc 0)).(i - 1) by A7,A8,A17
,A18,FINSEQ_1:37
          .= AddTo(a,intloc 0) by A20,FUNCOP_1:13;
      end;
A21:  now
        let i be Element of NAT;
        assume that
A22:    0 < i and
A23:    i < k';
A24:    0 + 1 < i + 1 & i + 1 <= k' by A22,A23,NAT_1:13,XREAL_1:8;
        thus s.insloc (c0 + i) = aSeq(a,k').(i+1) by A11,A23
          .=AddTo(a,intloc 0) by A16,A24;
      end;
A25:  for n being Element of NAT st Q[n] holds Q[n + 1]
      proof
        let n be Element of NAT;
        assume
A26:    Q[n];
        assume
A27:    n + 1 <= k';
        per cases;
        suppose
A28:      n = 0;
          hence IC Computation(s,n+1) = Exec(a:= intloc 0,s).IC SCM+FSA by A14
            .= Next insloc (c0 + n) by A2,A28,SCMFSA_2:89
            .= insloc (c0 + n + 1) by NAT_1:39
            .= insloc (c0 + (n + 1));
          hereby
            assume
            1 <= n + 1;
            thus Computation(s,n+1).a = Exec(a:= intloc 0,s).a by A14,A28
              .= n + 1 by A1,A28,SCMFSA_2:89;
          end;
          hereby
            let b be Int-Location;
            assume
A29:        b <> a;
            thus Computation(s,n+1).b = Exec(a:= intloc 0,s).b by A14,A28
              .= s.b by A29,SCMFSA_2:89;
          end;
          let f be FinSeq-Location;
          thus Computation(s,n+1).f = Exec(a:= intloc 0,s).f by A14,A28
            .= s.f by SCMFSA_2:89;
        end;
        suppose
A30:      n > 0;
A31:      n < k' by A27,NAT_1:13;
A32:      n + 0 <= n + 1 by XREAL_1:9;
          then
A33:      CurInstr Computation(s,n) = s.insloc (c0 + n) by A26,A27,AMI_1:54
,XXREAL_0:2
            .= AddTo(a,intloc 0) by A21,A30,A31;
A34:      Computation(s,n+1) = Following Computation(s,n) by AMI_1:14
            .= Exec(AddTo(a,intloc 0), Computation(s,n)) by A33;
          hence IC Computation(s,n+1) = Next IC Computation(s,n) by SCMFSA_2:90
            .= insloc (c0 + n + 1) by A26,A27,A32,NAT_1:39,XXREAL_0:2
            .= insloc (c0 + (n + 1));
A35:      0 + 1 <= n by A30,INT_1:20;
          hereby
            assume
            1 <= n + 1;
            thus Computation(s,n+1).a = n + Computation(s,n).intloc 0 by A26
,A27,A35,A32,A34,SCMFSA_2:90,XXREAL_0:2
              .= n + 1 by A1,A3,A26,A27,A32,XXREAL_0:2;
          end;
          hereby
            let b be Int-Location;
            assume
A36:        b <> a;
            hence Computation(s,n+1).b = Computation(s,n).b by A34,SCMFSA_2:90
              .= s.b by A26,A27,A32,A36,XXREAL_0:2;
          end;
          let f be FinSeq-Location;
          thus ( Computation(s,n+1)).f = Computation(s,n).f by A34,SCMFSA_2:90
            .= s.f by A26,A27,A32,XXREAL_0:2;
        end;
      end;
A37:  Q[0] by A2,AMI_1:13;
A38:  for i being Element of NAT holds Q[i] from NAT_1:sch 1(A37,A25);
      let i be Element of NAT;
      assume
      i <= len aSeq(a,k');
      hence thesis by A8,A38;
    end;
    hence
    for i being Element of NAT st i <= len aSeq(a,k) holds IC Computation
(s,i) = insloc (c0 + i) & (for b being Int-Location st b <> a holds Computation
(s,i).b = s.b) & for f being FinSeq-Location holds Computation(s,i).f = s.f;
    1 <= len aSeq(a,k) by A6,A8,NAT_1:11;
    hence thesis by A8,A9;
  end;
  suppose
A39: k <= 0;
    then reconsider mk = - k as Element of NAT by INT_1:16;
    defpred Q[Element of NAT] means $1 <= mk+1+1 implies IC Computation(s,$1)
= insloc (c0 + $1) & (1 <= $1 implies Computation(s,$1).a = -$1+1+1) & (for b
    being Int-Location st b <> a holds Computation(s,$1).b=s.b) & (for f being
    FinSeq-Location holds Computation(s,$1).f = s.f);
    consider k1 being Element of NAT such that
A40: k1 + k = 1 and
A41: aSeq(a,k) = <*a:=intloc 0*> ^ (k1 |-> SubFrom(a,intloc 0)) by A39,Def3;
A42: len aSeq(a,k) = len <* a:=intloc 0 *> + len (k1|->SubFrom(a,intloc 0)
    ) by A41,FINSEQ_1:35
      .= 1 + len (k1|->SubFrom(a,intloc 0)) by FINSEQ_1:56
      .= mk+1+1 by A40,FINSEQ_1:def 18;
A43: for i being Element of NAT st i <= len aSeq(a,k) holds IC Computation
(s,i) = insloc (c0 + i) & (1 <= i implies Computation(s,i).a = -i+1+1) & (for b
    being Int-Location st b <> a holds Computation(s,i).b = s.b) & for f being
    FinSeq-Location holds Computation(s,i).f = s.f
    proof
A44:  now
        let i be Element of NAT;
        assume
        i < mk+1+1;
        then insloc i in dom Load aSeq(a,k) by A42,Th29;
        hence i + 1 in dom aSeq(a,k) by Th26;
      end;
A45:  now
        let i be Element of NAT;
        assume
A46:    i < mk+1+1;
        thus s.insloc (c0 + i) = s.insloc(c0 + i + 1 -' 1) by NAT_D:34
          .= s.insloc(c0 + (i + 1) -' 1)
          .= aSeq(a,k).(i+1) by A4,A44,A46;
      end;
      then
A47:  s.insloc (c0 + 0) = aSeq(a,k).(0+1)
        .= a:= intloc 0 by A41,FINSEQ_1:58;
A48:  for n being Element of NAT st n = 0 holds Computation(s,n) = s &
CurInstr Computation(s,n) = a:= intloc 0 & Computation(s,n+1) = Exec(a:= intloc
      0,s)
      proof
        let n be Element of NAT;
        assume
        n = 0;
        hence
A49:    Computation(s,n) = s by AMI_1:13;
        hence CurInstr Computation(s,n) = a:= intloc 0 by A2,A47;
        thus Computation(s,n+1) = Following Computation(s,n) by AMI_1:14
          .= Exec(a:= intloc 0,s) by A2,A47,A49;
      end;
A50:  now
        let i be Element of NAT;
        assume that
A51:    1 < i and
A52:    i <= mk+1+1;
A53:    i - 1 <= mk+1+1 - 1 by A52,XREAL_1:11;
A54:    1 - 1 < i - 1 by A51,XREAL_1:11;
        then reconsider i1 = i - 1 as Element of NAT by INT_1:16;
        1 - 1 + 1 <= i - 1 by A54,INT_1:20;
        then
A55:    i1 in Seg k1 by A40,A53;
        len <* a:= intloc 0 *> = 1 by FINSEQ_1:56;
        hence aSeq(a,k).i = (k1|->SubFrom(a,intloc 0)).(i - 1) by A41,A42,A51
,A52,FINSEQ_1:37
          .= SubFrom(a,intloc 0) by A55,FUNCOP_1:13;
      end;
A56:  now
        let i be Element of NAT;
        assume that
A57:    0 < i and
A58:    i < mk+1+1;
A59:    0 + 1 < i + 1 & i + 1 <= mk+1+1 by A57,A58,NAT_1:13,XREAL_1:8;
        thus s.insloc (c0 + i) = aSeq(a,k).(i+1) by A45,A58
          .=SubFrom(a,intloc 0) by A50,A59;
      end;
A60:  for n being Element of NAT st Q[n] holds Q[n + 1]
      proof
        let n be Element of NAT;
        assume
A61:    Q[n];
        assume
A62:    n + 1 <= mk+1+1;
        per cases;
        suppose
A63:      n = 0;
          hence IC Computation(s,n+1) = Exec(a:= intloc 0,s).IC SCM+FSA by A48
            .= Next insloc (c0 + n) by A2,A63,SCMFSA_2:89
            .= insloc (c0 + n + 1) by NAT_1:39
            .= insloc (c0 + (n + 1));
          hereby
            assume
            1 <= n + 1;
            thus Computation(s,n+1).a = Exec(a:= intloc 0,s).a by A48,A63
              .= -(n + 1)+1+1 by A1,A63,SCMFSA_2:89;
          end;
          hereby
            let b be Int-Location;
            assume
A64:        b <> a;
            thus Computation(s,n+1).b = Exec(a:= intloc 0,s).b by A48,A63
              .= s.b by A64,SCMFSA_2:89;
          end;
          let f be FinSeq-Location;
          thus Computation(s,n+1).f = Exec(a:= intloc 0,s).f by A48,A63
            .= s.f by SCMFSA_2:89;
        end;
        suppose
A65:      n > 0;
A66:      n < mk+1+1 by A62,NAT_1:13;
A67:      n + 0 <= n + 1 by XREAL_1:9;
          then
A68:      CurInstr Computation(s,n) = s.insloc (c0 + n) by A61,A62,AMI_1:54
,XXREAL_0:2
            .= SubFrom(a,intloc 0) by A56,A65,A66;
A69:      Computation(s,n+1) = Following Computation(s,n) by AMI_1:14
            .= Exec(SubFrom(a,intloc 0), Computation(s,n)) by A68;
          hence IC Computation(s,n+1) = Next IC Computation(s,n) by SCMFSA_2:91
            .= insloc (c0 + n + 1) by A61,A62,A67,NAT_1:39,XXREAL_0:2
            .= insloc (c0 + (n + 1));
A70:      0 + 1 < n + 1 by A65,XREAL_1:8;
          hereby
            assume
            1 <= n + 1;
            thus Computation(s,n+1).a = -n+1+1 - Computation(s,n).intloc 0 by
A61,A62,A70,A69,NAT_1:13,SCMFSA_2:91
              .= -n+1+1 - s.intloc 0 by A3,A61,A62,A67,XXREAL_0:2
              .= -(n+1)+1+1 by A1;
          end;
          hereby
            let b be Int-Location;
            assume
A71:        b <> a;
            hence Computation(s,n+1).b = Computation(s,n).b by A69,SCMFSA_2:91
              .= s.b by A61,A62,A67,A71,XXREAL_0:2;
          end;
          let f be FinSeq-Location;
          thus ( Computation(s,n+1)).f = Computation(s,n).f by A69,SCMFSA_2:91
            .= s.f by A61,A62,A67,XXREAL_0:2;
        end;
      end;
A72:  Q[0] by A2,AMI_1:13;
A73:  for i being Element of NAT holds Q[i] from NAT_1:sch 1(A72,A60);
      let i be Element of NAT;
      assume
      i <= len aSeq(a,k);
      hence thesis by A42,A73;
    end;
    hence
    for i being Element of NAT st i <= len aSeq(a,k) holds IC Computation
(s,i) = insloc (c0 + i) & (for b being Int-Location st b <> a holds Computation
(s,i).b = s.b) & for f being FinSeq-Location holds Computation(s,i).f = s.f;
    1 <= len aSeq(a,k) by A42,NAT_1:11;
    hence Computation(s,len aSeq(a,k)).a = -(-k+(1+1))+1+1 by A42,A43
      .= k;
  end;
end;

theorem Th37:
  for s being State of SCM+FSA st IC s = insloc 0 & s.intloc 0 = 1
for a being Int-Location for k being Integer st Load aSeq(a,k) c= s & a<>intloc
0 holds (for i being Element of NAT st i <= len aSeq(a,k) holds IC Computation(
s,i) = insloc i & (for b being Int-Location st b <> a holds Computation(s,i).b
  = s.b) & (for f being FinSeq-Location holds Computation(s,i).f = s.f)) &
  Computation(s,len aSeq(a,k)).a = k
proof
  let s be State of SCM+FSA;
  assume
A1: IC s = insloc 0 & s.intloc 0 = 1;
  let a be Int-Location;
  let k be Integer;
  assume that
A2: Load aSeq(a,k) c= s and
A3: a <> intloc 0;
A4: dom Load aSeq(a,k) = {m-'1: m in dom aSeq(a,k)} by Def1;
A5: now
    let c be Element of NAT;
    assume
A6: c in dom aSeq(a,k);
    then c in Seg len aSeq(a,k) by FINSEQ_1:def 3;
    then 1 <= c by FINSEQ_1:3;
    then
A7: c -' 1 = c - 1 by XREAL_1:235;
A8: insloc (c-'1) in dom Load aSeq(a,k) by A4,A6;
    then (Load aSeq(a,k)).insloc (c-'1) = (aSeq(a,k))/.(c-'1+1) by Def1
      .= aSeq(a,k).c by A6,A7,PARTFUN1:def 8;
    hence aSeq(a,k).c = s.insloc (0 + c -' 1) by A2,A8,GRFUNC_1:8;
  end;
  hereby
    let i be Element of NAT;
    assume
A9: i <= len aSeq(a,k);
    then IC Computation(s,i) = insloc (0 + i) by A1,A3,A5,Th36;
    hence IC Computation(s,i) = insloc i & (for b being Int-Location st b <> a
holds Computation(s,i).b = s.b) & for f being FinSeq-Location holds Computation
    (s,i).f = s.f by A1,A3,A5,A9,Th36;
  end;
  thus thesis by A1,A3,A5,Th36;
end;

:: Users' guide

theorem
  for s being State of SCM+FSA st IC s = insloc 0 & s.intloc 0 = 1 for a
  being Int-Location, k being Integer st a:=k c= s & a<>intloc 0
   holds ProgramPart s halts_on s &
    (Result s).a = k & (for b being Int-Location st b <> a holds (Result
  s).b = s.b) & for f being FinSeq-Location holds (Result s).f = s.f
proof
  let s be State of SCM+FSA;
  assume that
A1: IC s = insloc 0 and
A2: s.intloc 0 = 1;
  let a be Int-Location, k be Integer;
  assume that
A3: a:=k c= s and
A4: a <> intloc 0;
  per cases;
  suppose
A5: k > 0;
    then consider k1 being Element of NAT such that
A6: k1 + 1 = k and
A7: a:=k = Load (<*a:=intloc 0*> ^ (k1 |-> AddTo(a,intloc 0)) ^ <*halt
    SCM+FSA*>) by Def2;
A8: len(<*a:=intloc 0*>^(k1|->AddTo(a,intloc 0))) = len<*a:=intloc 0*> +
    len(k1|->AddTo(a,intloc 0)) by FINSEQ_1:35
      .= 1 + len(k1|->AddTo(a,intloc 0)) by FINSEQ_1:56
      .= k by A6,FINSEQ_1:def 18;
    reconsider k as Element of NAT by A5,INT_1:16;
    defpred Q[Element of NAT] means $1 <= k implies (1 <= $1 implies
    Computation(s,$1).a = $1) & (for b being Int-Location st b <> a holds
Computation(s,$1).b=s.b) & (for f being FinSeq-Location holds Computation(s,$1)
    .f = s.f);
    set f = <*a:=intloc 0*> ^ (k1 |-> AddTo(a,intloc 0)) ^ <*halt SCM+FSA*>;
A9: f.1 = (<*a:=intloc 0*>^((k1 |-> AddTo(a,intloc 0))^<*halt SCM+FSA*>))
    .1 by FINSEQ_1:45
      .= a:= intloc 0 by FINSEQ_1:58;
A10: len f = len(<*a:=intloc 0*>^(k1|->AddTo(a,intloc 0)))+len<*halt
    SCM+FSA*> by FINSEQ_1:35
      .= k + 1 by A8,FINSEQ_1:56;
    then
A11: dom f = Seg (k + 1) by FINSEQ_1:def 3;
A12: now
      let i be Element of NAT;
      assume
      1 <= i & i <= k + 1;
      hence
A13:  i in dom f by A11;
      dom Load f = {m-'1: m in dom f} by Def1;
      hence insloc (i-'1) in dom Load f by A13;
    end;
A14: now
      let i be Element of NAT;
      assume that
      0 <= i and
A15:  i <= k;
A16:  0 + 1 <= i + 1 & i + 1 <= k + 1 by A15,XREAL_1:8;
      hence i + 1 in dom f by A12;
      insloc (i + 1 -' 1) in dom Load f by A12,A16;
      hence insloc i in dom Load f by NAT_D:34;
    end;
A17: now
      let i be Element of NAT;
      assume that
      0 <= i and
A18:  i <= k;
A19:  insloc i in dom Load f by A14,A18;
      hence s.insloc i = (Load f).insloc i by A3,A7,GRFUNC_1:8
        .= f/.(i+1) by A19,Def1
        .= f.(i+1) by A14,A18,PARTFUN1:def 8;
    end;
    then
A20: s.insloc 0 = f.(0+1)
      .= a:= intloc 0 by A9;
A21: now
      let n be Element of NAT;
      assume
      n = 0;
      hence
A22:  Computation(s,n) = s by AMI_1:13;
      hence CurInstr Computation(s,n) = a:= intloc 0 by A1,A20;
      thus Computation(s,n+1) = Following Computation(s,n) by AMI_1:14
        .= Exec(a:= intloc 0,s) by A1,A20,A22;
    end;
A23: now
      let i be Element of NAT;
      assume that
A24:  1 < i and
A25:  i <= k;
A26:  1 <= i - 1 by A24,INT_1:79;
      then reconsider i1 = i - 1 as Element of NAT by INT_1:16;
      i - 1 <= k - 1 by A25,XREAL_1:11;
      then
A27:  i1 in Seg k1 by A6,A26;
A28:  len <*a:= intloc 0*> = 1 by FINSEQ_1:56;
      dom (<*a:=intloc 0*>^(k1|->AddTo(a,intloc 0))) = Seg k by A8,
FINSEQ_1:def 3;
      then i in dom (<*a:=intloc 0*>^(k1|->AddTo(a,intloc 0))) by A24,A25;
      hence f.i=(<*a:=intloc 0*>^(k1|->AddTo(a,intloc 0))).i by FINSEQ_1:def 7
        .= (k1|->AddTo(a,intloc 0)).(i - 1) by A8,A24,A25,A28,FINSEQ_1:37
        .= AddTo(a,intloc 0) by A27,FUNCOP_1:13;
    end;
A29: now
      let i be Element of NAT;
      assume that
A30:  0 < i and
A31:  i < k;
A32:  0 + 1 < i + 1 & i + 1 <= k by A30,A31,NAT_1:13,XREAL_1:8;
      thus s.insloc i = f.(i+1) by A17,A31
        .=AddTo(a,intloc 0) by A23,A32;
    end;
A33: for i being Element of NAT st i <= k holds IC Computation(s,i) =
    insloc i
    proof
      defpred P[Element of NAT] means $1 <= k implies IC Computation(s,$1) =
      insloc $1;
      let i be Element of NAT;
      assume
A34:  i <= k;
A35:  for n being Element of NAT st P[n] holds P[n + 1]
      proof
        let n be Element of NAT;
        assume
A36:    P[n];
        assume
A37:    n+1 <= k;
        then
A38:    n < k by NAT_1:13;
        per cases;
        suppose
A39:      n=0;
          hence IC Computation(s,n+1) = Exec(a:= intloc 0,s).IC SCM+FSA by A21
            .= Next insloc n by A1,A39,SCMFSA_2:89
            .= insloc (n+1) by NAT_1:39;
        end;
        suppose
A40:      n>0;
          n + 0 <= n + 1 by XREAL_1:9;
          then
A41:      CurInstr Computation(s,n) = s.insloc n by A36,A37,AMI_1:54,XXREAL_0:2
            .= AddTo(a,intloc 0) by A29,A38,A40;
          Computation(s,n+1) = Following Computation(s,n) by AMI_1:14
            .= Exec(AddTo(a,intloc 0), Computation(s,n)) by A41;
          hence IC Computation(s,n+1) = Next IC Computation(s,n) by SCMFSA_2:90
            .= insloc (n+1) by A36,A37,NAT_1:13,39;
        end;
      end;
A42:  P[0] by A1,AMI_1:13;
      for i being Element of NAT holds P[i] from NAT_1:sch 1(A42,A35);
      hence thesis by A34;
    end;
A43: for n being Element of NAT st Q[n] holds Q[n + 1]
    proof
      let n be Element of NAT;
      assume
A44:  Q[n];
      assume
A45:  n + 1 <= k;
      per cases;
      suppose
A46:    n = 0;
        hereby
          assume
          1 <= n + 1;
          thus Computation(s,n+1).a = Exec(a:= intloc 0,s).a by A21,A46
            .= n + 1 by A2,A46,SCMFSA_2:89;
        end;
        hereby
          let b be Int-Location;
          assume
A47:      b <> a;
          thus Computation(s,n+1).b = Exec(a:= intloc 0,s).b by A21,A46
            .= s.b by A47,SCMFSA_2:89;
        end;
        let f be FinSeq-Location;
        thus Computation(s,n+1).f = Exec(a:= intloc 0,s).f by A21,A46
          .= s.f by SCMFSA_2:89;
      end;
      suppose
A48:    n > 0;
A49:    n < k by A45,NAT_1:13;
A50:    n + 0 <= n + 1 by XREAL_1:9;
        then
A51:    CurInstr Computation(s,n) = ( Computation(s,n)).insloc n by A33,A45,
XXREAL_0:2
          .= s.insloc n by AMI_1:54
          .= AddTo(a,intloc 0) by A29,A48,A49;
A52:    Computation(s,n+1) = Following Computation(s,n) by AMI_1:14
          .= Exec(AddTo(a,intloc 0), Computation(s,n)) by A51;
A53:    0 + 1 <= n by A48,INT_1:20;
        hereby
          assume
          1 <= n + 1;
          thus Computation(s,n+1).a = n + Computation(s,n).intloc 0 by A44,A45
,A53,A50,A52,SCMFSA_2:90,XXREAL_0:2
            .= n + 1 by A2,A4,A44,A45,A50,XXREAL_0:2;
        end;
        hereby
          let b be Int-Location;
          assume
A54:      b <> a;
          hence Computation(s,n+1).b = Computation(s,n).b by A52,SCMFSA_2:90
            .= s.b by A44,A45,A50,A54,XXREAL_0:2;
        end;
        let f be FinSeq-Location;
        thus ( Computation(s,n+1)).f = Computation(s,n).f by A52,SCMFSA_2:90
          .= s.f by A44,A45,A50,XXREAL_0:2;
      end;
    end;
    f.(k+1) = <* halt SCM+FSA *>.(k+1 - k) by A8,A10,FINSEQ_1:37,XREAL_1:31
      .= halt SCM+FSA by FINSEQ_1:def 8;
    then
A55: s.insloc k = halt SCM+FSA by A17;
    0 + 1 < k + 1 by A5,XREAL_1:8;
    then
A56: 1 <= k by NAT_1:13;
A57: Q[0] by AMI_1:13;
A58: for i being Element of NAT holds Q[i] from NAT_1:sch 1(A57,A43);
A59: CurInstr Computation(s,k) = ( Computation(s,k)).insloc k by A33
      .= halt SCM+FSA by A55,AMI_1:54;
    hence ProgramPart s halts_on s by AMI_1:146;
    then Computation(s,k) = Result s by A59,AMI_1:def 22;
    hence thesis by A58,A56;
  end;
  suppose
A60: k <= 0;
    then reconsider mk = - k as Element of NAT by INT_1:16;
    defpred Q[Element of NAT] means $1 <= mk+1+1 implies (1 <= $1 implies
    Computation(s,$1).a = -$1+1+1) & (for b being Int-Location st b <> a holds
Computation(s,$1).b=s.b) & (for f being FinSeq-Location holds Computation(s,$1)
    .f = s.f);
    consider k1 being Element of NAT such that
A61: k1 + k = 1 and
A62: a:=k = Load (<*a:=intloc 0*> ^ (k1 |-> SubFrom(a,intloc 0)) ^ <*
    halt SCM+FSA*>) by A60,Def2;
A63: len (<*a:=intloc 0*>^(k1|->SubFrom(a,intloc 0))) = len<*a:=intloc 0*>
    + len(k1|->SubFrom(a,intloc 0)) by FINSEQ_1:35
      .= 1 + len(k1|->SubFrom(a,intloc 0)) by FINSEQ_1:56
      .= mk+1+1 by A61,FINSEQ_1:def 18;
    set f = <*a:=intloc 0*> ^ (k1 |-> SubFrom(a,intloc 0)) ^ <*halt SCM+FSA*>;
A64: f.1 = (<*a:=intloc 0*>^((k1|->SubFrom(a,intloc 0))^<*halt SCM+FSA*>))
    .1 by FINSEQ_1:45
      .= a:= intloc 0 by FINSEQ_1:58;
A65: len f = len(<*a:=intloc 0*>^(k1|->SubFrom(a,intloc 0)))+len<*halt
    SCM+FSA *> by FINSEQ_1:35
      .= mk+1+1 + 1 by A63,FINSEQ_1:56;
    then
A66: dom f = Seg (mk+1+1 + 1) by FINSEQ_1:def 3;
A67: now
      let i be Element of NAT;
      assume
      1 <= i & i <= mk+1+1 + 1;
      hence
A68:  i in dom f by A66;
      dom Load f = {m-'1: m in dom f} by Def1;
      hence insloc (i-'1) in dom Load f by A68;
    end;
A69: now
      let i be Element of NAT;
      assume that
      0 <= i and
A70:  i <= mk+1+1;
A71:  0 + 1 <= i + 1 & i + 1 <= mk+1+1 + 1 by A70,XREAL_1:8;
      hence i + 1 in dom f by A67;
      insloc (i + 1 -' 1) in dom Load f by A67,A71;
      hence insloc i in dom Load f by NAT_D:34;
    end;
A72: now
      let i be Element of NAT;
      assume that
      0 <= i and
A73:  i <= mk+1+1;
A74:  insloc i in dom Load f by A69,A73;
      hence s.insloc i = (Load f).insloc i by A3,A62,GRFUNC_1:8
        .= f/.(i+1) by A74,Def1
        .= f.(i+1) by A69,A73,PARTFUN1:def 8;
    end;
    then
A75: s.insloc 0 = f.(0+1)
      .= a:= intloc 0 by A64;
A76: now
      let n be Element of NAT;
      assume
      n = 0;
      hence
A77:  Computation(s,n) = s by AMI_1:13;
      hence CurInstr Computation(s,n) = a:= intloc 0 by A1,A75;
      thus Computation(s,n+1) = Following Computation(s,n) by AMI_1:14
        .= Exec(a:= intloc 0,s) by A1,A75,A77;
    end;
A78: now
A79:  len <*a:= intloc 0*> = 1 by FINSEQ_1:56;
      let i be Element of NAT;
      assume that
A80:  1 < i and
A81:  i <= mk+1+1;
A82:  i - 1 <= mk+1+1 - 1 by A81,XREAL_1:11;
A83:  1 - 1 < i - 1 by A80,XREAL_1:11;
      then reconsider i1 = i - 1 as Element of NAT by INT_1:16;
      1 - 1 + 1 <= i - 1 by A83,INT_1:20;
      then
A84:  i1 in Seg k1 by A61,A82;
      dom (<*a:=intloc 0*>^(k1|->SubFrom(a,intloc 0))) = Seg (mk+1+1) by A63,
FINSEQ_1:def 3;
      then i in dom (<*a:=intloc 0*>^(k1|->SubFrom(a,intloc 0))) by A80,A81;
      hence f.i = (<*a:=intloc 0*>^(k1|->SubFrom(a,intloc 0))).i by
FINSEQ_1:def 7
        .= (k1|->SubFrom(a,intloc 0)).(i - 1) by A63,A80,A81,A79,FINSEQ_1:37
        .= SubFrom(a,intloc 0) by A84,FUNCOP_1:13;
    end;
A85: now
      let i be Element of NAT;
      assume that
A86:  0 < i and
A87:  i < mk+1+1;
A88:  0 + 1 < i + 1 & i + 1 <= mk+1+1 by A86,A87,NAT_1:13,XREAL_1:8;
      thus s.insloc i = f.(i+1) by A72,A87
        .=SubFrom(a,intloc 0) by A78,A88;
    end;
A89: for i being Element of NAT st i <= mk+1+1 holds IC Computation(s,i)
    = insloc i
    proof
      defpred P[Element of NAT] means $1<=mk+1+1 implies IC Computation(s,$1)=
      insloc $1;
      let i be Element of NAT;
      assume
A90:  i <= mk+1+1;
A91:  for n being Element of NAT st P[n] holds P[n + 1]
      proof
        let n be Element of NAT;
        assume
A92:    P[n];
        assume
A93:    n+1 <= mk+1+1;
        then
A94:    n < mk+1+1 by NAT_1:13;
        per cases;
        suppose
A95:      n=0;
          hence
          IC Computation(s,n+1) = Exec(a:= intloc 0,s).IC SCM+FSA by A76
            .= Next insloc n by A1,A95,SCMFSA_2:89
            .= insloc (n+1) by NAT_1:39;
        end;
        suppose
A96:      n>0;
          n + 0 <= n + 1 by XREAL_1:9;
          then
A97:      CurInstr Computation(s,n) = s.insloc n by A92,A93,AMI_1:54,XXREAL_0:2
            .= SubFrom(a,intloc 0) by A85,A94,A96;
          Computation(s,n+1) = Following Computation(s,n) by AMI_1:14
            .= Exec(SubFrom(a,intloc 0), Computation(s,n)) by A97;
          hence IC Computation(s,n+1) = Next IC Computation(s,n) by SCMFSA_2:91
            .= insloc (n+1) by A92,A93,NAT_1:13,39;
        end;
      end;
A98:  P[0] by A1,AMI_1:13;
      for i being Element of NAT holds P[i] from NAT_1:sch 1(A98,A91);
      hence thesis by A90;
    end;
A99: for n being Element of NAT st Q[n] holds Q[n + 1]
    proof
      let n be Element of NAT;
      assume
A100: Q[n];
      assume
A101: n + 1 <= mk+1+1;
      per cases;
      suppose
A102:   n = 0;
        hereby
          assume
          1 <= n + 1;
          thus Computation(s,n+1).a = Exec(a:= intloc 0,s).a by A76,A102
            .= -(n + 1)+1+1 by A2,A102,SCMFSA_2:89;
        end;
        hereby
          let b be Int-Location;
          assume
A103:     b <> a;
          thus Computation(s,n+1).b = Exec(a:= intloc 0,s).b by A76,A102
            .= s.b by A103,SCMFSA_2:89;
        end;
        let f be FinSeq-Location;
        thus Computation(s,n+1).f = Exec(a:= intloc 0,s).f by A76,A102
          .= s.f by SCMFSA_2:89;
      end;
      suppose
A104:   n > 0;
A105:   n < mk+1+1 by A101,NAT_1:13;
A106:   n + 0 <= n + 1 by XREAL_1:9;
        then
A107:   CurInstr Computation(s,n) = ( Computation(s,n)).insloc n by A89,A101,
XXREAL_0:2
          .= s.insloc n by AMI_1:54
          .= SubFrom(a,intloc 0) by A85,A104,A105;
A108:   Computation(s,n+1) = Following Computation(s,n) by AMI_1:14
          .= Exec(SubFrom(a,intloc 0), Computation(s,n)) by A107;
A109:   0 + 1 < n + 1 by A104,XREAL_1:8;
        hereby
          assume
          1 <= n + 1;
          thus Computation(s,n+1).a = -n+1+1 - Computation(s,n).intloc 0 by
A100,A101,A109,A108,NAT_1:13,SCMFSA_2:91
            .= -n+1+1 - s.intloc 0 by A4,A100,A101,A106,XXREAL_0:2
            .= -(n+1)+1+1 by A2;
        end;
        hereby
          let b be Int-Location;
          assume
A110:     b <> a;
          hence Computation(s,n+1).b = Computation(s,n).b by A108,SCMFSA_2:91
            .= s.b by A100,A101,A106,A110,XXREAL_0:2;
        end;
        let f be FinSeq-Location;
        thus ( Computation(s,n+1)).f = Computation(s,n).f by A108,SCMFSA_2:91
          .= s.f by A100,A101,A106,XXREAL_0:2;
      end;
    end;
    f.(mk+1+1+1) = <*halt SCM+FSA*>.(mk+1+1+1-(mk+1+1)) by A63,A65,FINSEQ_1:37
,XREAL_1:31
      .= halt SCM+FSA by FINSEQ_1:def 8;
    then
A111: s.insloc (mk+1+1) = halt SCM+FSA by A72;
A112: CurInstr Computation(s,mk+1+1) = ( Computation(s,mk+1+1)).insloc (mk
    +1+1) by A89
      .= halt SCM+FSA by A111,AMI_1:54;
    hence ProgramPart s halts_on s by AMI_1:146;
    then
A113: Computation(s,mk+1+1) = Result s by A112,AMI_1:def 22;
A114: Q[0] by AMI_1:13;
A115: for i being Element of NAT holds Q[i] from NAT_1:sch 1(A114,A99);
    -(mk+1+1)+1+1 = k & 0 + 1 <= mk+(1+1) by XREAL_1:9;
    hence thesis by A115,A113;
  end;
end;

theorem
  for s being State of SCM+FSA st IC s = insloc 0 & s.intloc 0 = 1 for f
  being FinSeq-Location, p being FinSequence of INT st f:=p c= s
   holds ProgramPart s halts_on s &
    (Result s).f = p & (for b being Int-Location st b <> intloc 1 & b <>
  intloc 2 holds (Result s).b = s.b) & for g being FinSeq-Location st g <> f
  holds (Result s).g = s.g
proof
  set D = the Instructions of SCM+FSA;
  set V = intloc 2;
  set I = intloc 1;
  set O = intloc 0;
A1: I <> O by AMI_3:52;
A2: I <> V by AMI_3:52;
  let s be State of SCM+FSA such that
A3: IC s = insloc 0 and
A4: s.O = 1;
  let f be FinSeq-Location, p be FinSequence of INT such that
A5: f:=p c= s;
  set q = aSeq(I,len p)^<* f:=<0,...,0>I *>^aSeq(f,p)^<* halt SCM+FSA *>;
A6: now
    let i be Element of NAT;
    assume
A7: insloc i in dom Load q;
    then s.insloc i = (Load q).insloc i by A5,GRFUNC_1:8;
    then
A8: s.insloc i = q/.(i + 1) by A7,Def1;
    i + 1 in dom q by A7,Th26;
    hence s.insloc i = q.(i + 1) by A8,PARTFUN1:def 8;
  end;
A9: now
    let i,k be Element of NAT;
    assume
    i < len q;
    then
A10: insloc i in dom Load q by Th29;
    thus ( Computation(s,k)).insloc i = s.insloc i by AMI_1:54
      .= q.(i + 1) by A6,A10;
  end;
A11: now
    let k be Element of NAT;
    assume
A12: insloc k in dom Load q;
    then
A13: k + 1 in dom q by Th26;
    thus (Load q).insloc k = q/.(k+1) by A12,Def1
      .= q.(k+1) by A13,PARTFUN1:def 8;
  end;
  set q0 = aSeq(I,len p) ^ <* f:=<0,...,0>I *>;
A14: dom Load q = {m-'1: m in dom q} by Def1;
  consider pp being FinSequence of D* such that
A15: len pp = len p and
A16: for k being Element of NAT st 1 <= k & k <= len p holds ex i being
  Integer st i = p.k & pp.k = (aSeq(I,k) ^ aSeq(V,i) ^ <* (f,I):=V *>) and
A17: aSeq(f,p) = FlattenSeq pp by Def4;
  len q = len (q0 ^ FlattenSeq pp) + 1 by A17,FINSEQ_2:19;
  then
A18: len (q0 ^ FlattenSeq pp) < len q by NAT_1:13;
  defpred P[FinSequence] means $1 c= pp implies (ex pp0 being FinSequence of D
* st (pp0 = $1 & (for i being Element of NAT st i <= len (q0 ^ FlattenSeq pp0)
  holds IC Computation(s,i) = insloc i) & ((Computation(s,len (q0 ^ FlattenSeq
  pp0)).f) | Seg len pp0 = p | Seg len pp0) & len (Computation(s,len (q0 ^
  FlattenSeq pp0)).f) = len p & (for b being Int-Location st b <> I & b <> V
  holds Computation(s,len (q0 ^ FlattenSeq pp0)).b = s.b) & (for g being
FinSeq-Location st g <> f holds Computation(s,len (q0 ^ FlattenSeq pp0)).g = s.
  g)));
A19: V <> O by AMI_3:52;
A20: for r being FinSequence, x being set st P[r] holds P[r ^ <* x *>]
  proof
    let r be FinSequence, x be set;
    assume
A21: P[r];
    set r1 = len r + 1;
    len (r ^ <* x *>) = r1 by FINSEQ_2:19;
    then r1 in Seg len (r ^ <* x *>) by FINSEQ_1:6;
    then
A22: r1 in dom (r ^ <* x *>) by FINSEQ_1:def 3;
    assume
A23: r ^ <* x *> c= pp;
    then
A24: dom (r ^ <* x *>) c= dom pp by GRFUNC_1:8;
    then r1 in dom pp by A22;
    then
A25: r1 in Seg len pp by FINSEQ_1:def 3;
    then 1 <= r1 & r1 <= len pp by FINSEQ_1:3;
    then consider pr1 being Integer such that
A26: pr1 = p.r1 and
A27: pp.r1 = aSeq(I,r1) ^ aSeq(V,pr1) ^ <* (f,I):=V *> by A15,A16;
    r c= r ^ <* x *> by FINSEQ_6:12;
    then consider pp0 being FinSequence of D* such that
A28: pp0 = r and
A29: for i being Element of NAT st i <= len (q0 ^ FlattenSeq pp0)
    holds IC Computation(s,i) = insloc i and
A30: (Computation(s,len (q0 ^ FlattenSeq pp0)).f) | Seg len pp0 = p |
    Seg len pp0 and
A31: len (Computation(s,len (q0 ^ FlattenSeq pp0)).f) = len p and
A32: for b being Int-Location st b <> I & b <> V holds Computation(s,
    len (q0 ^ FlattenSeq pp0)).b = s.b and
A33: for h being FinSeq-Location st h <> f holds Computation(s,len (q0
    ^ FlattenSeq pp0)).h = s.h by A21,A23,XBOOLE_1:1;
A34: x = (r ^ <* x *>).r1 by FINSEQ_1:59
      .= pp.r1 by A23,A22,GRFUNC_1:8;
    then x in D* by A22,A24,FINSEQ_2:13;
    then <* x *> is FinSequence of D* by FINSEQ_1:95;
    then reconsider pp1 = pp0 ^ <* x *> as FinSequence of D* by FINSEQ_1:96;
    take pp1;
    thus pp1 = r ^ <* x *> by A28;
    reconsider x as Element of D* by A22,A24,A34,FINSEQ_2:13;
A35: FlattenSeq pp1 = FlattenSeq pp0 ^ FlattenSeq <* x *> by PRE_POLY:3
      .= FlattenSeq pp0 ^ x by PRE_POLY:1;
    len pp1 <= len pp by A23,A28,FINSEQ_1:84;
    then
A36: Seg len pp1 c= Seg len p by A15,FINSEQ_1:7;
    then Seg len pp1 c= dom p by FINSEQ_1:def 3;
    then
A37: dom (p | Seg len pp1) = Seg len pp1 by RELAT_1:91;
    len <* (f,I):=V *> <= len (aSeq(I,r1) ^ aSeq(V,pr1)) + len <* (f,I)
    := V *> by NAT_1:12;
    then len <* (f,I):=V *> <= len (aSeq(I,r1) ^ aSeq(V,pr1) ^ <* (f,I):=V *>
    ) by FINSEQ_1:35;
    then
A38: 1 <= len x by A27,A34,FINSEQ_1:57;
A39: 1 <= len <* (f,I):=V *> by FINSEQ_1:57;
    set c2 = len (q0 ^ FlattenSeq pp0 ^ aSeq(I,r1));
    set c1 = len (q0 ^ FlattenSeq pp0);
    set s1 = Computation(s,c1);
    set s2 = Computation(s,c2);
A40: 1 <= c2 + len aSeq(V,pr1) + 1 by NAT_1:11;
A41: x = aSeq(I,r1) ^ (aSeq(V,pr1) ^ <* (f,I):=V *>) by A27,A34,FINSEQ_1:45;
    then
A42: len q0 + len FlattenSeq pp1 = len q0 + len (FlattenSeq pp0 ^ aSeq(I,
    r1) ^ (aSeq(V,pr1) ^ <* (f,I):=V *>)) by A35,FINSEQ_1:45
      .= len (q0 ^ (FlattenSeq pp0 ^ aSeq(I,r1) ^ (aSeq(V,pr1) ^ <* (f,I):=V
    *>))) by FINSEQ_1:35
      .= len (q0 ^ FlattenSeq pp0 ^ aSeq(I,r1) ^ (aSeq(V,pr1) ^ <* (f,I):=V
    *>)) by Lm3
      .= c2 + len (aSeq(V,pr1) ^ <* (f,I):=V *>) by FINSEQ_1:35
      .= c2 + (len aSeq(V,pr1) + len <* (f,I):=V *>) by FINSEQ_1:35
      .= c2 + (len aSeq(V,pr1) + 1) by FINSEQ_1:56
      .= c2 + len aSeq(V,pr1) + 1;
    then
A43: len (q0 ^ FlattenSeq pp1) = c2 + len aSeq(V,pr1) + 1 by FINSEQ_1:35;
A44: FlattenSeq pp1 c= FlattenSeq pp by A23,A28,PRE_POLY:6;
A45: now
      let p be FinSequence;
      assume
      p c= x;
      then FlattenSeq pp0 ^ p c= FlattenSeq pp0 ^ x by FINSEQ_6:15;
      then FlattenSeq pp0 ^ p c= FlattenSeq pp by A44,A35,XBOOLE_1:1;
      then q0 ^ (FlattenSeq pp0 ^ p) c= q0 ^ FlattenSeq pp by FINSEQ_6:15;
      then
A46:  q0 ^ FlattenSeq pp0 ^ p c= q0 ^ FlattenSeq pp by FINSEQ_1:45;
      q0 ^ FlattenSeq pp c= q by A17,FINSEQ_6:12;
      hence q0 ^ FlattenSeq pp0 ^ p c= q by A46,XBOOLE_1:1;
    end;
A47: s1.O = 1 & IC s1 = insloc c1 & I <> O & for c being Element of NAT st
    c in dom aSeq(I,r1) holds aSeq(I,r1).c = s1.insloc (c1 + c -' 1)
    proof
      thus s1.O = 1 by A1,A19,A4,A32;
      thus IC s1 = insloc c1 by A29;
      thus I <> O by AMI_3:52;
      let c be Element of NAT;
      assume
A48:  c in dom aSeq(I,r1);
      then
A49:  c1 + c in dom (q0 ^ FlattenSeq pp0 ^ aSeq(I,r1)) by FINSEQ_1:41;
      then c1 + c >= 1 by FINSEQ_3:27;
      then c1 + c -' 1 = c1 + c - 1 by XREAL_1:235;
      then
A50:  c1 + c -' 1 + 1 = c1 + c;
A51:  q0 ^ FlattenSeq pp0 ^ aSeq(I,r1) c= q by A41,A45,FINSEQ_6:12;
      then dom (q0 ^ FlattenSeq pp0 ^ aSeq(I,r1)) c= dom q by GRFUNC_1:8;
      then
A52:  insloc (c1 + c -' 1) in dom Load q by A14,A49;
      thus aSeq(I,r1).c = (q0 ^ FlattenSeq pp0 ^ aSeq(I,r1)).(c1 + c) by A48,
FINSEQ_1:def 7
        .= q.(c1 + c) by A51,A49,GRFUNC_1:8
        .= (Load q).insloc (c1 + c -' 1) by A11,A52,A50
        .= s.insloc (c1 + c -' 1) by A5,A52,GRFUNC_1:8
        .= s1.insloc (c1 + c -' 1) by AMI_1:54;
    end;
    then
A53: Computation(s1,len aSeq(I,r1)).I = r1 by Th36;
A54: q0 ^ FlattenSeq pp1 = q0 ^ FlattenSeq pp0 ^ x by A35,FINSEQ_1:45;
    then len (q0 ^ FlattenSeq pp1) <= len q by A45,FINSEQ_1:84;
    then
A55: c2 + len aSeq(V,pr1) < len q by A43,NAT_1:13;
A56: now
      let i be Element of NAT;
      assume
      i <= len aSeq(I,r1);
      hence insloc (c1 + i) = IC Computation(s1,i) by A47,Th36
        .= IC Computation(s,c1+i) by AMI_1:51;
    end;
    set c3 = len (q0 ^ FlattenSeq pp0 ^ aSeq(I,r1) ^ aSeq(V,pr1));
A57: c3 = c2 + len aSeq(V,pr1) by FINSEQ_1:35;
A58: c2 = c1 + len aSeq(I,r1) by FINSEQ_1:35;
    then
A59: s2 = Computation(Computation(s,c1),len aSeq(I,r1)) by AMI_1:51;
A60: s2.O = 1 & IC s2 = insloc c2 & V <> O & for c being Element of NAT
    st c in dom aSeq(V,pr1) holds aSeq(V,pr1).c = s2.insloc (c2 + c -' 1)
    proof
      thus s2.O = 1 by A59,A47,Th36;
      thus IC s2 = insloc c2 by A58,A59,A47,Th36;
      thus V <> O by AMI_3:52;
      let c be Element of NAT;
      assume
A61:  c in dom aSeq(V,pr1);
      then
A62:  c2 + c in dom (q0 ^ FlattenSeq pp0 ^ aSeq(I,r1) ^ aSeq(V,pr1)) by
FINSEQ_1:41;
      then c2 + c >= 1 by FINSEQ_3:27;
      then c2 + c -' 1 = c2 + c - 1 by XREAL_1:235;
      then
A63:  c2 + c -' 1 + 1 = c2 + c;
      q0 ^ FlattenSeq pp0 ^ (aSeq(I,r1) ^ aSeq(V,pr1)) c= q by A27,A34,A45,
FINSEQ_6:12;
      then
A64:  q0 ^FlattenSeq pp0^aSeq(I,r1) ^ aSeq(V,pr1) c= q by FINSEQ_1:45;
      then dom (q0 ^ FlattenSeq pp0 ^ aSeq(I,r1) ^ aSeq(V,pr1)) c= dom q by
GRFUNC_1:8;
      then
A65:  insloc (c2 + c -' 1) in dom Load q by A14,A62;
      thus aSeq(V,pr1).c = (q0 ^ FlattenSeq pp0 ^ aSeq(I,r1) ^ aSeq(V,pr1)).(
      c2 + c) by A61,FINSEQ_1:def 7
        .= q.(c2 + c) by A62,A64,GRFUNC_1:8
        .= (Load q).insloc (c2 + c -' 1) by A11,A65,A63
        .= s.insloc (c2 + c -' 1) by A5,A65,GRFUNC_1:8
        .= s2.insloc (c2 + c -' 1) by AMI_1:54;
    end;
    then
A66: Computation(s2,len aSeq(V,pr1)).V = pr1 by Th36;
A67: Computation(s,c3).f = Computation(s,c2 + len aSeq(V,pr1)).f by FINSEQ_1:35
      .= Computation(s2,len aSeq(V,pr1)).f by AMI_1:51
      .= s2.f by A60,Th36
      .= s1.f by A59,A47,Th36;
A68: now
      let i be Element of NAT;
      assume
      i <= len aSeq(V,pr1);
      hence insloc (c2 + i) = IC Computation(s2,i) by A60,Th36
        .= IC Computation(s,c2+i) by AMI_1:51;
    end;
A69: for i being Element of NAT st i < len (q0 ^ FlattenSeq pp1) holds IC
    Computation(s,i) = insloc i
    proof
      let i be Element of NAT;
      assume
A70:  i < len (q0 ^ FlattenSeq pp1);
A71:  now
A72:    i < len q0 + len FlattenSeq pp1 by A70,FINSEQ_1:35;
        assume
A73:    not i <= c1;
        assume
        not (c1 + 1 <= i & i <= c2);
        hence c2 + 1 <= i & i <= c2 + len aSeq(V,pr1) by A42,A73,A72,NAT_1:13;
      end;
      per cases by A71;
      suppose
        i <= len (q0 ^ FlattenSeq pp0);
        hence thesis by A29;
      end;
      suppose
A74:    c1 + 1 <= i & i <= c2;
        then c1 + 1 - c1 <= i - c1 by XREAL_1:11;
        then reconsider ii = i - c1 as Element of NAT by INT_1:16;
        i - c1 <= c2 - c1 by A74,XREAL_1:11;
        hence insloc i = IC Computation(s,c1+ii) by A58,A56
          .= IC Computation(s,i);
      end;
      suppose
A75:    c2 + 1 <= i & i <= c2 + len aSeq(V,pr1);
        then c2 + 1 - c2 <= i - c2 by XREAL_1:11;
        then reconsider ii = i - c2 as Element of NAT by INT_1:16;
        i - c2 <= c2 + len aSeq(V,pr1) - c2 by A75,XREAL_1:11;
        hence insloc i = IC Computation(s,c2+ii) by A68
          .= IC Computation(s,i);
      end;
    end;
A76: c3 = c1 + len aSeq(I,r1) + len aSeq(V,pr1) by A58,FINSEQ_1:35;
A77: len (q0 ^ FlattenSeq pp1) = c2 + len aSeq(V,pr1) + 1 by A42,FINSEQ_1:35;
    then
A78: len (q0 ^ FlattenSeq pp1) > c2 + len aSeq(V,pr1) by NAT_1:13;
    then CurInstr Computation(s,c3) = Computation(s,c3).insloc c3 by A57,A69
      .= q.(c3 + 1) by A9,A57,A55
      .= (q0 ^ FlattenSeq pp0 ^ x).(c3 + 1) by A54,A57,A45,A43,A40,FINSEQ_4:98
      .= (q0 ^ FlattenSeq pp0 ^ x).(c3 + len <* (f,I):=V *>) by FINSEQ_1:57
      .= (q0 ^ FlattenSeq pp0 ^ x).(c1 + (len aSeq(I,r1) + (len aSeq(V,pr1)
    + len <* (f,I):=V *>))) by A76;
    then
A79: CurInstr Computation(s,c3) = (q0 ^ FlattenSeq pp0 ^ x).(c1 + len (
    aSeq(I,r1) ^ aSeq(V,pr1) ^ <* (f,I):=V *>)) by Lm1
      .= (aSeq(I,r1) ^ aSeq(V,pr1) ^ <* (f,I):=V *>). len (aSeq(I,r1) ^ aSeq
    (V,pr1) ^ <* (f,I):=V *>) by A27,A34,A38,FINSEQ_1:86
      .= (aSeq(I,r1) ^ aSeq(V,pr1) ^ <* (f,I):=V *>). (len (aSeq(I,r1) ^
    aSeq(V,pr1)) + len <* (f,I):=V *>) by FINSEQ_1:35
      .= <* (f,I):=V *>.len <* (f,I):=V *> by A39,FINSEQ_1:86
      .= <* (f,I):=V *>.1 by FINSEQ_1:57
      .= (f,I):=V by FINSEQ_1:57;
A80: Computation(s,c3+1) = Following Computation(s,c3) by AMI_1:14
      .= Exec((f,I):=V, Computation(s,c3)) by A79;
    then
A81: IC Computation(s,len (q0 ^ FlattenSeq pp1)) = Next IC Computation(s,
    c3) by A57,A43,SCMFSA_2:99
      .= Next insloc c3 by A57,A69,A78
      .= insloc len (q0 ^ FlattenSeq pp1) by A57,A77,NAT_1:39;
    thus for i being Element of NAT st i <= len (q0 ^ FlattenSeq pp1) holds IC
    Computation(s,i) = insloc i
    proof
      let i be Element of NAT;
      assume
A82:  i <= len (q0 ^ FlattenSeq pp1);
      per cases by A82,XXREAL_0:1;
      suppose
        i < len (q0 ^ FlattenSeq pp1);
        hence thesis by A69;
      end;
      suppose
        i = len (q0 ^ FlattenSeq pp1);
        hence thesis by A81;
      end;
    end;
A83: Computation(s,c3).V = Computation(s,c2 + len aSeq(V,pr1)).V by FINSEQ_1:35
      .= p.r1 by A26,A66,AMI_1:51;
    consider ki being Element of NAT such that
A84: ki = abs( Computation(s,c3).I) and
A85: Exec((f,I):=V, Computation(s,c3)).f = Computation(s,c3).f +*(ki,
    Computation(s,c3).V) by SCMFSA_2:99;
A86: ki = abs( Computation(s,c2 + len aSeq(V,pr1)).I ) by A84,FINSEQ_1:35
      .= abs( Computation(s2,len aSeq(V,pr1)).I ) by AMI_1:51
      .= abs( s2.I ) by A2,A60,Th36
      .= r1 by A59,A53,ABSVALUE:def 1;
A87: dom (s1.f) = Seg len p by A31,FINSEQ_1:def 3;
    for i being Element of NAT st i in Seg len pp1 holds ((Computation(s
    ,len (q0 ^ FlattenSeq pp1)).f) | Seg len pp1).i = (p | Seg len pp1).i
    proof
      let i be Element of NAT;
      assume
A88:  i in Seg len pp1;
      then
A89:  i <= len pp1 by FINSEQ_1:3;
      per cases;
      suppose
A90:    i = len pp1;
        then
A91:    i = len pp0 + 1 by FINSEQ_2:19;
        hence
        ((Computation(s,len (q0 ^ FlattenSeq pp1))).f | Seg len pp1). i =
        (s1.f +*(r1,p.r1)).i by A57,A77,A80,A85,A86,A83,A67,A90,FINSEQ_1:6
,FUNCT_1:72
          .= p.i by A15,A28,A25,A87,A91,FUNCT_7:33
          .= (p | Seg len pp1).i by A90,A91,FINSEQ_1:6,FUNCT_1:72;
      end;
      suppose
A92:    i <> len pp1;
        then i < len pp1 by A89,XXREAL_0:1;
        then i < len pp0 + 1 by FINSEQ_2:19;
        then
A93:    i <= len pp0 by NAT_1:13;
        1 <= i by A88,FINSEQ_1:3;
        then
A94:    i in Seg len pp0 by A93;
A95:    i <> r1 by A28,A92,FINSEQ_2:19;
        ((Computation(s,len (q0 ^ FlattenSeq pp1))).f | Seg len pp1).i =
        (s1.f +*(r1,p.r1)).i by A57,A77,A80,A85,A86,A83,A67,A88,FUNCT_1:72
          .= s1.f.i by A95,FUNCT_7:34;
        hence
        ((Computation(s,len (q0 ^ FlattenSeq pp1))).f | Seg len pp1). i =
        (p | Seg len pp0).i by A30,A94,FUNCT_1:72
          .= p.i by A94,FUNCT_1:72
          .= (p | Seg len pp1).i by A88,FUNCT_1:72;
      end;
    end;
    then
A96: for i being set st i in Seg len pp1 holds ((Computation(s,len (q0 ^
    FlattenSeq pp1)).f) | Seg len pp1).i = (p | Seg len pp1).i;
A97: dom (s1.f +*(r1,p.r1)) = dom (s1.f) by FUNCT_7:32;
    then dom (Computation(s,len (q0 ^ FlattenSeq pp1)).f) = Seg len p by A31
,A57,A43,A80,A85,A86,A83,A67,FINSEQ_1:def 3;
    then dom ((Computation(s,len (q0 ^ FlattenSeq pp1)).f) | Seg len pp1 ) =
    Seg len pp1 by A36,RELAT_1:91;
    hence (Computation(s,len (q0 ^ FlattenSeq pp1)).f) | Seg len pp1 = p | Seg
    len pp1 by A37,A96,FUNCT_1:9;
    len (s1.f +*(r1,p.r1)) = len (s1.f) by A97,FINSEQ_3:31;
    hence len (Computation(s,len (q0^FlattenSeq pp1)).f) = len p by A31,A43,A80
,A85,A86,A83,A67,FINSEQ_1:35;
    hereby
      let b be Int-Location;
      assume that
A98:  b <> I and
A99:  b <> V;
      thus Computation(s,len (q0 ^ FlattenSeq pp1)).b = Computation(s,c2 + len
      aSeq(V,pr1)).b by A57,A43,A80,SCMFSA_2:99
        .= Computation(s2,len aSeq(V,pr1)).b by AMI_1:51
        .= s2.b by A60,A99,Th36
        .= s1.b by A59,A47,A98,Th36
        .= s.b by A32,A98,A99;
    end;
    hereby
      let h be FinSeq-Location;
      assume
A100: h <> f;
      hence
      Computation(s,len (q0 ^ FlattenSeq pp1)).h = Computation(s,c2 + len
      aSeq(V,pr1)).h by A57,A43,A80,SCMFSA_2:99
        .= Computation(s2,len aSeq(V,pr1)).h by AMI_1:51
        .= s2.h by A60,Th36
        .= s1.h by A59,A47,Th36
        .= s.h by A33,A100;
    end;
  end;
  set k = len aSeq(I,len p);
A101: len q0 = k + 1 by FINSEQ_2:19;
A102: q = aSeq(I,len p)^<* f:=<0,...,0>I *>^(aSeq(f,p)^<* halt SCM+FSA *>) by
FINSEQ_1:45;
  then q = aSeq(I,len p)^(<* f:=<0,...,0>I *>^(aSeq(f,p)^<* halt SCM+FSA *>))
  by FINSEQ_1:45;
  then Load aSeq(I,len p) c= f:=p by Th31;
  then
A103: Load aSeq(I,len p) c= s by A5,XBOOLE_1:1;
  then
A104: Computation(s,len aSeq(I,len p)).I = len p by A1,A3,A4,Th37;
A105: P[{}]
  proof
A106: now
      let i be Element of NAT such that
A107: i < len q0;
      i < len q0 implies i <= len aSeq(I,len p) by A101,NAT_1:13;
      hence IC Computation(s,i) = insloc i by A1,A3,A4,A103,A107,Th37;
    end;
A108: 1 <= len q0 by A101,NAT_1:11;
    assume
    {} c= pp;
     reconsider sD = <*>(D*) as FinSequence of D*;
    take sD;
A109: q0 ^ FlattenSeq <*>(D*) = q0 ^ <*>D by PRE_POLY:2
      .= q0 by FINSEQ_1:47;
    k < len q0 by A101,NAT_1:13;
    then
A110: IC Computation(s,k) = insloc k by A106;
    len q = len q0 + len ((aSeq(f,p) ^ <* halt SCM+FSA *>)) by A102,FINSEQ_1:35
;
    then len q0 <= len q by NAT_1:11;
    then k < len q by A101,NAT_1:13;
    then
A111: CurInstr Computation(s,k) = q.len q0 by A101,A9,A110
      .= q0.len q0 by A102,A108,FINSEQ_1:85
      .= f:=<0,...,0>I by A101,FINSEQ_1:59;
    thus sD = {};
A112: Computation(s,len q0) = Following Computation(s,k) by A101,AMI_1:14
      .= Exec(f:=<0,...,0>I, Computation(s,k)) by A111;
    then
A113: IC Computation(s,len q0) = Next IC Computation(s,k) by SCMFSA_2:101
      .= insloc len q0 by A101,A110,NAT_1:39;
    now
      let i be Element of NAT;
      assume
      i <= len q0;
      then i < len q0 or i = len q0 by XXREAL_0:1;
      hence IC Computation(s,i) = insloc i by A106,A113;
    end;
    hence for i being Element of NAT st i <= len (q0 ^ FlattenSeq sD)
    holds IC Computation(s,i) = insloc i by A109;
    consider ki being Element of NAT such that
A114: ki = abs( Computation(s,k).I) and
A115: Exec(f:=<0,...,0>I, Computation(s,k)).f = ki |-> 0 by SCMFSA_2:101;
     len sD = 0;
   then
  (Computation(s,len (q0 ^ FlattenSeq sD)).f) | Seg 0 = p | Seg len sD
   by FINSEQ_1:94;
    hence
    (Computation(s,len (q0 ^ FlattenSeq sD)).f)|Seg len sD = p
    | Seg len sD by FINSEQ_1:94;
    ki = len p by A104,A114,ABSVALUE:def 1;
    hence len (Computation(s,len (q0 ^ FlattenSeq sD)).f) = len p by A109
,A112,A115,FINSEQ_1:def 18;
    now
      let b be Int-Location such that
A116: b <> I and
      b <> V;
      thus Computation(s,len q0).b = Computation(s,k).b by A112,SCMFSA_2:101
        .= s.b by A1,A3,A4,A103,A116,Th37;
    end;
    hence
    for b being Int-Location st b <> I & b <> V holds Computation(s,len (
    q0 ^ FlattenSeq sD)).b = s.b by A109;
    now
      let g be FinSeq-Location;
      assume
      g <> f;
      hence Computation(s,len q0).g = Computation(s,k).g by A112,SCMFSA_2:101
        .= s.g by A1,A3,A4,A103,Th37;
    end;
    hence thesis by A109;
  end;
  for r being FinSequence holds P[r] from FINSEQ_1:sch 3(A105,A20);
  then consider pp0 being FinSequence of D* such that
A117: pp0 = pp and
A118: for i being Element of NAT st i <= len (q0 ^ FlattenSeq pp0) holds
  IC Computation(s,i) = insloc i and
A119: (Computation(s,len (q0 ^ FlattenSeq pp0)).f) | Seg len pp0 = p |
  Seg len pp0 and
A120: len (Computation(s,len (q0 ^ FlattenSeq pp0)).f) = len p and
A121: ( for b being Int-Location st b <> I & b <> V holds Computation(s,
  len (q0 ^ FlattenSeq pp0)).b = s.b)& for g being FinSeq-Location st g <> f
  holds Computation(s,len (q0 ^ FlattenSeq pp0)).g = s.g;
A122: dom p = Seg len pp0 by A15,A117,FINSEQ_1:def 3;
  IC Computation(s,len (q0 ^ FlattenSeq pp)) = insloc len (q0 ^
  FlattenSeq pp) by A117,A118;
  then
A123: CurInstr Computation(s,len (q0 ^ FlattenSeq pp)) = q.(len (q0 ^
  FlattenSeq pp) + 1) by A9,A18
    .= halt SCM+FSA by A17,FINSEQ_1:59;
  hence ProgramPart s halts_on s by AMI_1:146;
  then
A124: Computation(s,len (q0^FlattenSeq pp)) = Result s by A123,AMI_1:def 22;
  dom (Computation(s,len (q0 ^ FlattenSeq pp0)).f) = Seg len pp0 by A15,A117
,A120,FINSEQ_1:def 3;
  then (Result s).f = p | Seg len pp0 by A117,A119,A124,RELAT_1:97;
  hence (Result s).f = p by A122,RELAT_1:97;
  thus thesis by A117,A121,A124;
end;

