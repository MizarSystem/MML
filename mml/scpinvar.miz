:: Justifying the Correctness of Fibonacci Sequence and Euclide
:: Algorithm by Loop Invariant
::  by JingChao Chen
::
:: Received June 14, 2000
:: Copyright (c) 2000 Association of Mizar Users

environ

 vocabularies NUMBERS, SUBSET_1, AMI_1, SCMPDS_2, TURING_1, FUNCT_1, CARD_1,
      SCMFSA_7, RELAT_1, ARYTM_3, CARD_3, FSM_1, XXREAL_0, COMPLEX1, ARYTM_1,
      AMI_2, SCMPDS_5, SCMPDS_4, INT_1, SCMPDS_8, SCMFSA6B, SCMFSA_9, UNIALG_2,
      SCMFSA7B, SCMP_GCD, SEMI_AF1, GRAPHSP, AMI_3, FINSEQ_1, SCPISORT, NAT_1,
      SCMFSA6A, ORDINAL4, SFMASTR2, PRE_FF, FUNCT_4, CIRCUIT2, TARSKI,
      MSUALG_1, STRUCT_0, VALUED_1, XBOOLE_0, SCMFSA8B, INT_2, SCPINVAR,
      ORDINAL1, PARTFUN1, SCMNORM, SCMFSA6C;
 notations XBOOLE_0, SUBSET_1, CARD_1, NUMBERS, RELAT_1, FUNCT_1, PARTFUN1,
      VALUED_1, XCMPLX_0, FUNCT_4, INT_1, INT_2, NAT_1, STRUCT_0, COMPOS_1,
      EXTPRO_1, AMI_1,
      AMI_2, SCMPDS_2, SCMPDS_4, SCMPDS_6, SCMP_GCD, SCMPDS_5,
      SCMPDS_8, FUNCT_2, CARD_3, DOMAIN_1, FINSEQ_1, GR_CY_1, PRE_FF, SCPISORT,
      XXREAL_0;
 constructors DOMAIN_1, REAL_1, NAT_D, RECDEF_1, PRE_FF, MESFUNC1, GR_CY_1,
      SCM_1, SCMPDS_4, SCMPDS_5, SCMPDS_6, SCMP_GCD, SCMPDS_8, SCPISORT,
      BINOP_2, AMI_1;
 registrations SETFAM_1, FUNCT_1, ORDINAL1, RELSET_1, NUMBERS, XREAL_0, NAT_1,
      INT_1, CARD_3, STRUCT_0, SCMPDS_2, SCMPDS_4, SCMPDS_5, SCMPDS_6,
      SCMPDS_8, XBOOLE_0, FINSEQ_1, CARD_1, VALUED_1, AMI_1, VALUED_0,
      RELAT_1, FUNCT_2, COMPOS_1, AFINSQ_1, EXTPRO_1;
 requirements NUMERALS, REAL, SUBSET, ARITHM, BOOLE;
 definitions FUNCOP_1, COMPOS_1, EXTPRO_1, AMI_1, AMI_3, SCMPDS_2, SCMP_GCD,
 SCPISORT;
 theorems AMI_1, AMI_3, NAT_1, TARSKI, FUNCT_4, INT_1, SCMPDS_2, ABSVALUE,
      GRFUNC_1, SCMPDS_4, SCMPDS_5, SCMPDS_6, ENUMSET1, INT_2, SCMPDS_8,
      RELAT_1, SCMP_GCD, SCMPDS_7, FUNCT_1, FINSEQ_1, RVSUM_1, FINSEQ_2,
      PRE_FF, SCPISORT, XBOOLE_1, XREAL_1, COMPLEX1, XXREAL_0, PREPOWER,
      ORDINAL1, FUNCOP_1, AMI_2, ZFMISC_1, NAT_D, FINSEQ_3, PBOOLE, PARTFUN1,
      AFINSQ_1, COMPOS_1, FUNCT_7, EXTPRO_1;
 schemes NAT_1, SCMPDS_8, FUNCT_2;

begin :: Preliminaries

reserve m,n for Element of NAT,
  i,j for Instruction of SCMPDS,
  I for Program
  of SCMPDS,
  a for Int_position;

canceled 4;

theorem Th5:
  (i ';' j ';' I). 0=i & (i ';' j ';' I). 1=j
proof
  set jI=j ';' I;
A1: i ';' j ';' I =i ';' jI by SCMPDS_4:52
    .=Load i ';' jI by SCMPDS_4:def 4;
   0 in dom Load i by SCMPDS_5:2;
  hence (i ';' j ';' I). 0 =(Load i). 0 by A1,AFINSQ_1:def 4
    .=i by SCMPDS_5:4;
A2:  0 in dom Load j by SCMPDS_5:2;
  card jI=card I+1 by SCMPDS_6:15;
  then 0 < card jI by NAT_1:5;
  then
A3: card Load i=1 &  0 in dom jI by AFINSQ_1:70,SCMPDS_5:6;
  thus (i ';' j ';' I). 1 =(Load i ';' jI). (0+1) by A1
    .=jI. 0 by A3,AFINSQ_1:def 4
    .=(Load j ';' I). 0 by SCMPDS_4:def 4
    .=(Load j). 0 by A2,AFINSQ_1:def 4
    .=j by SCMPDS_5:4;
end;

theorem Th6:
  for a,b be Int_position holds ex f be Function of product the
  Object-Kind of SCMPDS,NAT st for s being State of SCMPDS holds (s.a = s.b
  implies f.s =0) & (s.a <> s.b implies f.s=max(abs(s.a),abs(s.b)))
proof
  let a,b be Int_position;
  defpred P[set,set] means ex t be State of SCMPDS st t=$1 & (t.a = t.b
  implies $2 =0) & (t.a <> t.b implies $2=max(abs(t.a),abs(t.b)));
A1: now
    let s be Element of product the Object-Kind of SCMPDS;
    per cases;
    suppose
A2:   s.a = s.b;
      reconsider y=0 as Element of NAT;
      take y;
      thus P[s,y] by A2;
    end;
    suppose
A3:   s.a <> s.b;
      set mm=max(abs(s.a),abs(s.b));
      reconsider y=mm as Element of NAT by XXREAL_0:16;
      take y;
      thus P[s,y] by A3;
    end;
  end;
  consider f be Function of product the Object-Kind of SCMPDS, NAT such that
B4: for s be Element of product the Object-Kind of SCMPDS holds P[s,f.s]
       from FUNCT_2:sch 3(A1);
A4: for s being State of SCMPDS holds P[s,f.s]
   proof
    let s be State of SCMPDS;
    reconsider s as Element of product the Object-Kind of SCMPDS by PBOOLE:155;
    P[s,f.s] by B4;
    hence thesis;
   end;
  take f;
  hereby
    let s be State of SCMPDS;
    P[s,f.s] by A4;
    hence
    (s.a = s.b implies f.s =0) & (s.a <> s.b implies f.s=max(abs(s.a),abs
    (s.b)));
  end;
end;

theorem Th7:
  ex f be Function of product the Object-Kind of SCMPDS,NAT st for
s being State of SCMPDS holds (s.a >= 0 implies f.s =0) & (s.a < 0 implies f.s=
  -s.a)
proof
  defpred P[set,set] means ex t be State of SCMPDS st t=$1 & (t.a >= 0 implies
  $2 =0) & (t.a < 0 implies $2=-t.a);
A1: now
    let s be Element of product the Object-Kind of SCMPDS;
    per cases;
    suppose
A2:   s.a >= 0;
      reconsider y=0 as Element of NAT;
      take y;
      thus P[s,y] by A2;
    end;
    suppose
A3:   s.a < 0;
      then -s.a > 0 by XREAL_1:60;
      then reconsider y=-s.a as Element of NAT by INT_1:16;
      take y;
      thus P[s,y] by A3;
    end;
  end;
  consider f be Function of product the Object-Kind of SCMPDS,NAT such that
B4: for s be Element of product the Object-Kind of SCMPDS holds P[s,f.s]
      from FUNCT_2:sch 3(A1);
A4: for s being State of SCMPDS holds P[s,f.s]
   proof
    let s be State of SCMPDS;
    reconsider s as Element of product the Object-Kind of SCMPDS by PBOOLE:155;
    P[s,f.s] by B4;
    hence thesis;
   end;
  take f;
  hereby
    let s be State of SCMPDS;
    P[s,f.s] by A4;
    hence (s.a >= 0 implies f.s =0) & (s.a < 0 implies f.s=-s.a);
  end;
end;
set A = NAT, D = SCM-Data-Loc;

begin :: Computing directly the result of "while<0" program by loop-invariant

scheme
  WhileLEnd { F(State of SCMPDS)-> Element of NAT, s() -> State of SCMPDS,I()
-> halt-free shiftable Program of SCMPDS, a() -> Int_position,i() -> Integer,
P[set]}: F(Dstate IExec(while<0(a(),i(),I()),s()))=0 & P[Dstate IExec(while<0(a
  (),i(),I()),s())]
provided
A1: card I() > 0 and
A2: for t be State of SCMPDS st P[Dstate t] holds F(Dstate(t))=0
   iff t.DataLoc(s().a(),i()) >= 0 and
A3: P[Dstate s()] and
A4: for t be State of SCMPDS st P[Dstate t] & t.a()=s().a() &
   t.DataLoc(s().a(),i()) < 0
 holds IExec(I(),t).a()=t.a() & I() is_closed_on t & I()
is_halting_on t & F(Dstate IExec(I(),t)) < F(Dstate t) & P[Dstate(IExec(I(),t))
]
proof
  set b=DataLoc(s().a(),i()), WHL=while<0(a(),i(),I());
  defpred Q[Element of NAT] means
  for t be State of SCMPDS st F(Dstate t) <=
  $1 & t.a()=s().a() & P[Dstate t] holds F(Dstate IExec(WHL,t))=0 & P[Dstate
  IExec(WHL,t)];
A5: Q[0]
  proof
    let t be State of SCMPDS;
    assume that
A6: F(Dstate t) <= 0 and
A7: t.a()=s().a() and
A8: P[Dstate t];
    F(Dstate t) >= 0 by NAT_1:2;
    then
A9: F(Dstate t)=0 by A6,XXREAL_0:1;
    then t.DataLoc(s().a(),i()) >= 0 by A2,A8;
    then for b be Int_position holds IExec(WHL,t).b = t.b by A7,SCMPDS_8:12;
    hence thesis by A8,A9,SCPISORT:5;
  end;
A10: now
    let k be Element of NAT;
    assume
A11: Q[k];
    now
      let u be State of SCMPDS;
      assume that
A12:  F(Dstate u) <= k+1 and
A13:  u.a()=s().a() and
A14:  P[Dstate u];
      per cases;
      suppose
        F(Dstate u)=0;
        hence F(Dstate IExec(WHL,u))=0 & P[Dstate IExec(WHL,u)] by A5,A13,A14;
      end;
      suppose
A15:    F(Dstate u) <> 0;
        set Iu=IExec(I(),u);
A16:    u.b < 0 by A2,A14,A15;
        then
A17:    Iu.a()=s().a() & P[Dstate Iu] by A4,A13,A14;
        deffunc F(State of SCMPDS) = F($1);
A18:    P[Dstate u] by A14;
A19:    for t be State of SCMPDS st P[Dstate t] & F(Dstate(t))=0
       holds t.DataLoc(u.a(),i()) >= 0 by A2,A13;
        F(Dstate Iu) < F(Dstate u) by A4,A13,A14,A16;
        then F(Dstate Iu)+1 <= F(Dstate u) by INT_1:20;
        then F(Dstate Iu)+1 <= k+1 by A12,XXREAL_0:2;
        then
A20:    F(Dstate Iu) <= k by XREAL_1:8;
A21:    for t being State of SCMPDS st P[Dstate t] & t.a()=u.a() & t.
DataLoc(u.a(),i()) < 0 holds IExec(I(),t).a()=t.a() & I() is_closed_on t & I()
is_halting_on t & F(Dstate IExec(I(),t)) < F(Dstate t) & P[Dstate(IExec(I(),t))
        ] by A4,A13;
A22:    u.DataLoc(u.a(),i()) < 0 by A2,A13,A14,A15;
        (F(u)=F(u) or P[u]) & IExec(WHL,u) = IExec(WHL,Iu) from SCMPDS_8:
        sch 2 (A1,A22,A19,A18,A21);
        hence F(Dstate IExec(WHL,u))=0 & P[Dstate IExec(WHL,u)] by A11,A20,A17;
      end;
    end;
    hence Q[k+1];
  end;
  for k being Element of NAT holds Q[k] from NAT_1:sch 1(A5,A10);
  then Q[F(Dstate s())];
  hence thesis by A3;
end;
set a1=intpos 1, a2=intpos 2, a3=intpos 3;

begin :: An Example : Summing directly n integers by loop-invariant

:: sum=Sum=x1+x2+...+xn

definition
  let n, p0 be Element of NAT;
  func sum(n,p0) -> Program of SCMPDS equals
  (GBP:=0) ';' (intpos 1:=0) ';' (
intpos 2:=-n) ';' (intpos 3:=(p0+1)) ';' while<0(GBP,2,AddTo(GBP,1,intpos 3,0)
  ';' AddTo(GBP,2,1) ';' AddTo(GBP,3,1));
  coherence;
end;
:: SCMPDS_7:73

definition
 let ff be Function of product the Object-Kind of SCMPDS,NAT,
     s be State of SCMPDS;
 redefine func ff.s -> Element of NAT;
 coherence by ORDINAL1:def 13;
end;

theorem Th8:
  for s being 0-started State of SCMPDS,
    I being halt-free shiftable Program
  of SCMPDS, a,b,c being Int_position,n,i,p0 be Element of NAT,f be FinSequence
  of INT st card I >0 & f is_FinSequence_on s,p0 & len f=n & s.b=0 & s.a=0 & s.
intpos i=-n & s.c = p0+1 &
 (for t be State of SCMPDS st (ex g be FinSequence of
INT st g is_FinSequence_on s,p0 & len g=t.intpos i+n & t.b=Sum g & t.c = p0+1+
  len g) & t.a=0 & t.intpos i < 0 & for i be Element of NAT st i > p0 holds t.
intpos i=s.intpos i holds IExec(I,t).a=0 & I is_closed_on t & I is_halting_on t
  & IExec(I,t).intpos i=t.intpos i+1 & (ex g be FinSequence of INT st g
  is_FinSequence_on s,p0 & len g=t.intpos i+n+1 & IExec(I,t).c = p0+1+len g &
IExec(I,t).b=Sum g) & for i be Element of NAT st i > p0 holds IExec(I,t).intpos
  i=s.intpos i) holds IExec(while<0(a,i,I),s).b=Sum f & while<0(a,i,I)
  is_closed_on s & while<0(a,i,I) is_halting_on s
proof
  let s be 0-started State of SCMPDS,
      I be halt-free shiftable Program of SCMPDS, a,b,c
  be Int_position,n,i,p0 be Element of NAT,f be FinSequence of INT;
  assume
A1: card I > 0;
  set Iw=IExec(while<0(a,i,I),s), Dw=Dstate Iw;
  set da=DataLoc(s.a,i);
  defpred P[State of SCMPDS] means (for i be Element of NAT st i > p0 holds $1
.intpos i=s.intpos i) & (ex g be FinSequence of INT st g is_FinSequence_on s,p0
  & len g=$1.intpos i+n & $1.b=Sum g & $1.intpos i <= 0 & $1.c = p0+1+len g);
  assume that
A2: f is_FinSequence_on s,p0 and
A3: len f=n and
A4: s.b=0 and
A5: s.a=0 and
A6: s.intpos i=-n and
A7: s.c = p0+1;
  consider ff be Function of product the Object-Kind of SCMPDS,NAT such that
A8: for t be State of SCMPDS holds (t.da >= 0 implies ff.t =0) & (t.da <
  0 implies ff.t=-t.da) by Th7;
  deffunc F(State of SCMPDS) = ff.$1;
  assume
A9: for t be State of SCMPDS st (ex g be FinSequence of INT st g
is_FinSequence_on s,p0 & len g=t.intpos i+n & t.b=Sum g & t.c = p0+1+len g) & t
  .a=0 & t.intpos i < 0 & for i be Element of NAT st i > p0 holds t.intpos i=s.
intpos i holds IExec(I,t).a=0 & I is_closed_on t & I is_halting_on t & IExec(I,
t).intpos i=t.intpos i+1 & (ex g be FinSequence of INT st g is_FinSequence_on s
,p0 & len g=t.intpos i+n+1 & IExec(I,t).c = p0+1+len g & IExec(I,t).b=Sum g) &
  for i be Element of NAT st i > p0 holds IExec(I,t).intpos i=s.intpos i;
A10: now
    let t be State of SCMPDS;
    set dt=Dstate t;
    assume P[dt];
    hereby
      assume
A11:  F(dt)=0;
      assume
A12:  t.da < 0;
      then dt.da < 0 by SCMPDS_8:4;
      then F(dt)=-dt.da by A8;
      hence contradiction by A11,A12,SCMPDS_8:4;
    end;
    assume t.da >= 0;
    then dt.da >= 0 by SCMPDS_8:4;
    hence F(dt)=0 by A8;
  end;
A13: now
    let t be State of SCMPDS;
    set Dt=Dstate t;
    assume that
A14: P[Dstate t] and
A15: t.a=s.a and
A16: t.DataLoc(s.a,i) < 0;
    consider h be FinSequence of INT such that
A17: h is_FinSequence_on s,p0 and
A18: len h=Dt.intpos i+n & Dt.b=Sum h and
A19: Dt.c = p0+1+len h by A14;
A20: t.c = p0+1+len h by A19,SCMPDS_8:4;
    set It=IExec(I,t);
    set Dit=Dstate It;
A21: now
      let i be Element of NAT;
      assume
A22:  i > p0;
      thus t.intpos i=Dt.intpos i by SCMPDS_8:4
        .=s.intpos i by A14,A22;
    end;
A23: intpos (0+i)=da by A5,SCMP_GCD:5;
A24: len h=t.intpos i+n & t.b=Sum h by A18,SCMPDS_8:4;
    hence IExec(I,t).a=t.a by A5,A9,A15,A16,A21,A17,A20,A23;
    consider g be FinSequence of INT such that
A25: g is_FinSequence_on s,p0 and
A26: len g=t.intpos i+n+1 and
A27: IExec(I,t).c = p0+1+len g and
A28: IExec(I,t).b=Sum g by A5,A9,A15,A16,A21,A17,A24,A20,A23;
    thus I is_closed_on t & I is_halting_on t by A5,A9,A15,A16,A21,A17,A24,A20
,A23;
A29: It.intpos i=t.intpos i+1 by A5,A9,A15,A16,A21,A17,A24,A20,A23;
    hereby
      per cases;
      suppose
        It.intpos i >= 0;
        then Dit.da >= 0 by A23,SCMPDS_8:4;
        then
A30:    F(Dit)=0 by A8;
        F(Dt) <> 0 by A10,A14,A16;
        hence F(Dit) < F(Dt) by A30,NAT_1:3;
      end;
      suppose
A31:    It.intpos i < 0;
        Dt.da < 0 by A16,SCMPDS_8:4;
        then
A32:    F(Dt)=-Dt.da by A8
          .=-t.intpos i by A23,SCMPDS_8:4;
        Dit.da < 0 by A23,A31,SCMPDS_8:4;
        then F(Dit)=-Dit.da by A8
          .=-(t.intpos i+1) by A23,A29,SCMPDS_8:4
          .=-t.intpos i-1;
        hence F(Dit) < F(Dt) by A32,XREAL_1:148;
      end;
    end;
    thus P[Dstate IExec(I,t)]
    proof
      hereby
        let i be Element of NAT;
        assume
A33:    i > p0;
        thus Dit.intpos i=It.intpos i by SCMPDS_8:4
          .=s.intpos i by A5,A9,A15,A16,A21,A17,A24,A20,A23,A33;
      end;
      take g;
      thus g is_FinSequence_on s,p0 by A25;
      thus len g=IExec(I,t).intpos i+n by A29,A26
        .=Dit.intpos i+n by SCMPDS_8:4;
      thus Dit.b=Sum g by A28,SCMPDS_8:4;
      Dit.intpos i=t.intpos i+1 by A29,SCMPDS_8:4;
      hence Dit.intpos i <= 0 by A16,A23,INT_1:20;
      thus thesis by A27,SCMPDS_8:4;
    end;
  end;
A34: P[Dstate s]
  proof
    set Ds=Dstate s;
    thus for i be Element of NAT st i > p0 holds Ds.intpos i=s.intpos i by
SCMPDS_8:4;
    consider h be FinSequence of INT such that
A35: len h=0 and
A36: h is_FinSequence_on s,p0 by SCPISORT:3;
    take h;
    thus h is_FinSequence_on s,p0 by A36;
    thus len h=s.intpos i+n by A6,A35
      .=Ds.intpos i+n by SCMPDS_8:4;
    h=<*> REAL by A35;
    hence Ds.b=Sum h by A4,RVSUM_1:102,SCMPDS_8:4;
    thus Ds.intpos i <= 0 by A6,SCMPDS_8:4;
    thus thesis by A7,A35,SCMPDS_8:4;
  end;
A37: F(Dw)=0 & P[Dw] from WhileLEnd(A1,A10,A34,A13);
  then consider g be FinSequence of INT such that
A38: g is_FinSequence_on s,p0 and
A39: len g=Dw.intpos i+n and
A40: Dw.b=Sum g and
A41: Dw.intpos i <= 0;
  Dw.intpos i=Iw.intpos(0+i) by SCMPDS_8:4
    .=Iw.da by A5,SCMP_GCD:5;
  then Dw.intpos i >= 0 by A10,A37;
  then
A42: Dw.intpos i=0 by A41,XXREAL_0:1;
  now
    let i be Nat;
    reconsider a = i as Element of NAT by ORDINAL1:def 13;
    assume i in dom f;
    then
A43: 1 <= i & i <= n by A3,FINSEQ_3:27;
    hence f.i = s.intpos(p0+a) by A2,A3,SCPISORT:def 1
      .=g.i by A38,A39,A42,A43,SCPISORT:def 1;
  end;
  then f = g by A3,A39,A42,FINSEQ_2:10;
  hence Iw.b=Sum f by A40,SCMPDS_8:4;
A44: for t be State of SCMPDS st P[Dstate t] & F(Dstate(t))=0 holds t.da >=
  0 by A10;
  (F(s)=F(s) or P[s]) & while<0(a,i,I) is_closed_on s & while<0(a,i,I)
  is_halting_on s from SCMPDS_8:sch 1(A1,A44,A34,A13);
  hence thesis;
end;

set j1= AddTo(GBP,1,a3,0), j2= AddTo(GBP,2,1), j3= AddTo(GBP,3,1), WB= j1 ';'
j2 ';' j3, WH= while<0(GBP,2,WB);

Lm1: for s being 0-started State of SCMPDS,
        m be Element of NAT st s.GBP=0 & s.a3=m holds
IExec(WB,s).GBP=0 & IExec(WB,s).a1=s.a1+s.intpos m & IExec(WB,s).a2=s.a2+1 &
IExec(WB,s).a3=m+1 & for i be Element of NAT st i >3 holds IExec(WB,s).intpos i
=s.intpos i

proof
  set a=GBP;
  let s be 0-started State of SCMPDS,m be Element of NAT;
  assume that
A1: s.a=0 and
A2: s.a3=m;

  set t0=Initialize s, t1=IExec(WB,s), t2=IExec(j1 ';' j2,s), t3=Exec(j1, t0);

A3: t0.a3=m by A2,SCMPDS_5:40;
A4: t0.a=0 by A1,SCMPDS_5:40;
  then 0 <> abs(t0.GBP+1) by ABSVALUE:def 1;
  then a <> DataLoc(t0.GBP,1) by ZFMISC_1:33;
  then
A5: t3.a=0 by A4,SCMPDS_2:61;
  then 0 <> abs(t3.GBP+2) by ABSVALUE:def 1;
  then
A6: a <> DataLoc(t3.GBP,2) by ZFMISC_1:33;
  3 <> abs(t0.GBP+1) by A4,ABSVALUE:def 1;
  then a3 <> DataLoc(t0.GBP,1) by ZFMISC_1:33;
  then
A7: t3.a3=m by A3,SCMPDS_2:61;
  3 <> abs(t3.GBP+2) by A5,ABSVALUE:def 1;
  then
A8: a3 <> DataLoc(t3.GBP,2) by ZFMISC_1:33;
A9: t2.a3=Exec(j2,t3).a3 by SCMPDS_5:47
    .=m by A7,A8,SCMPDS_2:60;
A10: t0.a1=s.a1 by SCMPDS_5:40;
A11: DataLoc(t0.a,1)=intpos (0+1) by A4,SCMP_GCD:5;
  then
A12: t3.a1=t0.a1+t0.DataLoc(t0.a3,0) by SCMPDS_2:61
    .=t0.a1+t0.intpos(m+0) by A3,SCMP_GCD:5
    .=s.a1+s.intpos m by A10,SCMPDS_5:40;
  1 <> abs(t3.GBP+2) by A5,ABSVALUE:def 1;
  then
A13: a1 <> DataLoc(t3.GBP,2) by ZFMISC_1:33;
A14: DataLoc(t3.a,2)=intpos (0+2) by A5,SCMP_GCD:5;
  then
A15: abs(t3.a+2)=0+2 by ZFMISC_1:33;
  2 <> abs(t0.GBP+1) by A4,ABSVALUE:def 1;
  then a2 <> DataLoc(t0.GBP,1) by ZFMISC_1:33;
  then
A16: t3.a2=t0.a2 by SCMPDS_2:61
    .=s.a2 by SCMPDS_5:40;
A17: t2.a=Exec(j2,t3).a by SCMPDS_5:47
    .=0 by A5,A6,SCMPDS_2:60;
  then
A18: DataLoc(t2.a,3)=intpos (0+3) by SCMP_GCD:5;
A19: t2.a2=Exec(j2,t3).a2 by SCMPDS_5:47
    .=s.a2+1 by A16,A14,SCMPDS_2:60;
A20: t2.a1=Exec(j2,t3).a1 by SCMPDS_5:47
    .=s.a1+s.intpos m by A12,A13,SCMPDS_2:60;
  0 <> abs(t2.GBP+3) by A17,ABSVALUE:def 1;
  then
A21: a <> DataLoc(t2.GBP,3) by ZFMISC_1:33;
  thus t1.a=Exec(j3,t2).a by SCMPDS_5:46
    .=0 by A17,A21,SCMPDS_2:60;
  1 <> abs(t2.GBP+3) by A17,ABSVALUE:def 1;
  then
A22: a1 <> DataLoc(t2.GBP,3) by ZFMISC_1:33;
  thus t1.a1=Exec(j3,t2).a1 by SCMPDS_5:46
    .=s.a1+s.intpos m by A20,A22,SCMPDS_2:60;
  2 <> abs(t2.GBP+3) by A17,ABSVALUE:def 1;
  then
A23: a2 <> DataLoc(t2.GBP,3) by ZFMISC_1:33;
  thus t1.a2=Exec(j3,t2).a2 by SCMPDS_5:46
    .=s.a2+1 by A19,A23,SCMPDS_2:60;
  thus t1.a3=Exec(j3,t2).a3 by SCMPDS_5:46
    .=m+1 by A9,A18,SCMPDS_2:60;
A24: abs(t0.a+1)=0+1 by A11,ZFMISC_1:33;
  hereby
    let i be Element of NAT;
    assume
A25: i >3;
    then
A26: intpos i <> DataLoc(t2.a,3) by A18,ZFMISC_1:33;
    i <> abs(t0.a+1) by A24,A25;
    then
A27: intpos i <> DataLoc(t0.a,1) by ZFMISC_1:33;
    i <> abs(t3.a+2) by A15,A25;
    then
A28: intpos i <> DataLoc(t3.a,2) by ZFMISC_1:33;
    thus t1.intpos i=Exec(j3,t2).intpos i by SCMPDS_5:46
      .=t2.intpos i by A26,SCMPDS_2:60
      .=Exec(j2,t3).intpos i by SCMPDS_5:47
      .=t3.intpos i by A28,SCMPDS_2:60
      .=t0.intpos i by A27,SCMPDS_2:61
      .=s.intpos i by SCMPDS_5:40;
  end;
end;

Lm2: card WB=3
proof
  thus card WB=card (j1 ';' j2) +1 by SCMP_GCD:8
    .=2+1 by SCMP_GCD:9
    .=3;
end;

Lm3: for s being 0-started State of SCMPDS,
n,p0 be Element of NAT,f be FinSequence of
INT st p0 >= 3 & f is_FinSequence_on s,p0 & len f=n & s.a1=0 & s.GBP=0 & s.a2=-
n & s.a3=p0+1 holds IExec(WH,s).a1=Sum f & WH is_closed_on s & WH is_halting_on
s

proof
  let s be 0-started State of SCMPDS,
      n,p0 be Element of NAT,f be FinSequence of INT;
  set a=GBP;
  assume that
A1: p0 >= 3 and

A2: f is_FinSequence_on s,p0 & len f=n & s.a1=0 & s.a=0 & s.a2=-n & s.a3
  = p0+1;

  now
    let t be State of SCMPDS;
    given g be FinSequence of INT such that
A3: g is_FinSequence_on s,p0 and
A4: len g=t.a2+n and
A5: t.a1=Sum g and
A6: t.a3 = p0+1+len g;
    assume that
A7: t.a=0 and
    t.a2 < 0;
X1:  IExec(WB,t) =  IExec(WB,Initialize t) by SCMPDS_5:48;
X2: (Initialize t).a3 = t.a3 by SCMPDS_5:40;
X3: (Initialize t).a1 = t.a1 by SCMPDS_5:40;
X4: (Initialize t).a = t.a by SCMPDS_5:40;
X5: (Initialize t).a2 = t.a2 by SCMPDS_5:40;
    assume
A8: for i be Element of NAT st i > p0 holds t.intpos i=s.intpos i;
    thus IExec(WB,t).a=0 by A6,A7,Lm1,X1,X2,X4;
    thus WB is_closed_on t & WB is_halting_on t by SCMPDS_6:34,35;
    thus IExec(WB,t).a2=t.a2+1 by A6,A7,Lm1,X1,X2,X4,X5;

    thus ex g be FinSequence of INT st g is_FinSequence_on s,p0 & len g=t.a2+n
    +1 & IExec(WB,t).a3 = p0+1+len g & IExec(WB,t).a1=Sum g

    proof
      consider h be FinSequence of INT such that
A9:   len h=len g+1 and
A10:  h is_FinSequence_on s,p0 by SCPISORT:3;
      take h;
      thus h is_FinSequence_on s,p0 by A10;
      thus len h=t.a2+n+1 by A4,A9;
      thus IExec(WB,t).a3 =p0+1+len g+1 by A6,A7,Lm1,X1,X2,X4
        .=p0+1+len h by A9;
A11:  p0+1 > p0 by XREAL_1:31;
      set m=len h;
A12:  m >= 1 by A9,NAT_1:11;
      then p0+m >= p0+1 by XREAL_1:8;
      then
A13:  p0+m > p0 by A11,XXREAL_0:2;
      reconsider q = h.m as Element of INT by INT_1:def 2;
A14:  now
        let i be Nat;
A15:    i in NAT by ORDINAL1:def 13;
        assume that
A16:    1 <= i and
A17:    i <= len h;
        per cases;
        suppose
          i=len h;
          hence h.i=(g^<*q*>).i by A9,FINSEQ_1:59;
        end;
        suppose
          i<>len h;
          then i < len h by A17,XXREAL_0:1;
          then
A18:      i <= len g by A9,INT_1:20;
          then i in Seg (len g) by A16,FINSEQ_1:3;
          then
A19:      i in dom g by FINSEQ_1:def 3;
          thus h.i = s.intpos(p0+i) by A10,A15,A16,A17,SCPISORT:def 1
            .= g.i by A3,A15,A16,A18,SCPISORT:def 1
            .= (g^<*q*>).i by A19,FINSEQ_1:def 7;
        end;
      end;
      len (g^<*q*>)=len h by A9,FINSEQ_2:19;
      then
A20:  g^<*q*>=h by A14,FINSEQ_1:18;
Y0:   (Initialize t).intpos(p0+1+len g) = t.intpos(p0+1+len g) by SCMPDS_5:40;
      h.m=s.intpos(p0+m) by A10,A12,SCPISORT:def 1
        .=t.intpos(p0+1+len g) by A8,A9,A13;
      hence IExec(WB,t).a1=t.a1+h.m by A6,A7,Lm1,X1,X2,X3,X4,Y0
        .=Sum h by A5,A20,RVSUM_1:104;
    end;
    hereby
      let i be Element of NAT;
Y0:   (Initialize t).intpos i = t.intpos i by SCMPDS_5:40;
      assume
A21:  i > p0;
      then i > 3 by A1,XXREAL_0:2;
      hence IExec(WB,t).intpos i=t.intpos i by A6,A7,Lm1,X1,X2,X4,Y0
        .=s.intpos i by A8,A21;
    end;
  end;
  hence thesis by A2,Lm2,Th8;
end;

Lm4: for s being 0-started State of SCMPDS,
  n,p0 be Element of NAT,f be FinSequence of
INT st p0 >= 3 & f is_FinSequence_on s,p0 & len f=n holds IExec(sum(n,p0),s).a1
=Sum f & sum(n,p0) is_halting_on s

proof
  let s be 0-started State of SCMPDS,
      n,p0 be Element of NAT,f be FinSequence of INT;
  assume that
A1: p0 >= 3 and
A2: f is_FinSequence_on s,p0 and
A3: len f=n;

  set a=GBP, i1=a:=0, i2=a1:=0, i3=a2:=-n, i4=a3:=(p0+1), t0=Initialize s,
    I4 =i1 ';' i2 ';' i3 ';' i4, t1=IExec(I4,s), t2=IExec(i1 ';' i2 ';' i3,s),
    t3= IExec(i1 ';' i2,s), t4=Exec(i1, t0);

  now
    let i be Element of NAT;
    assume that
A4: 1 <= i and
A5: i <= len f;
A6: p0+1 >= 3+1 by A1,XREAL_1:8;
A7: p0+i >= p0+ 1 by A4,XREAL_1:8;
    then p0+i <> 3 by A6,XXREAL_0:2;
    then
A8: intpos (p0+i) <> a3 by ZFMISC_1:33;
    p0+i <> 0 by A6,A7,XXREAL_0:2;
    then
A9: intpos (p0+i) <> a by ZFMISC_1:33;
    p0+i <> 1 by A6,A7,XXREAL_0:2;
    then
A10: intpos (p0+i) <> a1 by ZFMISC_1:33;
    p0+i <> 2 by A6,A7,XXREAL_0:2;
    then
A11: intpos (p0+i) <> a2 by ZFMISC_1:33;
    thus t1.intpos (p0+i)=Exec(i4, t2).intpos (p0+i) by SCMPDS_5:46
      .=t2.intpos (p0+i) by A8,SCMPDS_2:57
      .=Exec(i3, t3).intpos (p0+i) by SCMPDS_5:46
      .=t3.intpos (p0+i) by A11,SCMPDS_2:57
      .=Exec(i2, t4).intpos (p0+i) by SCMPDS_5:47
      .=t4.intpos (p0+i) by A10,SCMPDS_2:57
      .=t0.intpos (p0+i) by A9,SCMPDS_2:57
      .=s.intpos (p0+i) by SCMPDS_5:40
      .=f.i by A2,A4,A5,SCPISORT:def 1;
  end;
  then
A12: f is_FinSequence_on t1,p0 by SCPISORT:def 1;
B12: f is_FinSequence_on Initialize t1,p0
   proof let i be Element of NAT;
    assume 1 <= i & i <= len f;
     then f.i=t1.intpos(p0+i) by A12,SCPISORT:def 1;
    hence thesis by SCMPDS_5:40;
   end;
A13: t4.a=0 by SCMPDS_2:57;
A14: t3.a=Exec(i2, t4).a by SCMPDS_5:47
    .=0 by A13,AMI_3:52,SCMPDS_2:57;
A15: t2.a=Exec(i3, t3).a by SCMPDS_5:46
    .=0 by A14,AMI_3:52,SCMPDS_2:57;
A16: t1.a3=Exec(i4, t2).a3 by SCMPDS_5:46
    .=p0+1 by SCMPDS_2:57;
B16: (Initialize t1).a3 = t1.a3 by SCMPDS_5:40;
A17: t3.a1=Exec(i2, t4).a1 by SCMPDS_5:47
    .=0 by SCMPDS_2:57;
A18: t2.a1=Exec(i3, t3).a1 by SCMPDS_5:46
    .=0 by A17,AMI_3:52,SCMPDS_2:57;
B19: (Initialize t1).a1 = t1.a1 by SCMPDS_5:40;
A19: t1.a1=Exec(i4, t2).a1 by SCMPDS_5:46
    .=0 by A18,AMI_3:52,SCMPDS_2:57;
A20: t2.a2=Exec(i3, t3).a2 by SCMPDS_5:46
    .=-n by SCMPDS_2:57;
B21: (Initialize t1).a2 = t1.a2 by SCMPDS_5:40;
BX: (Initialize t1).a = t1.a by SCMPDS_5:40;
A21: t1.a2=Exec(i4, t2).a2 by SCMPDS_5:46
    .=-n by A20,AMI_3:52,SCMPDS_2:57;
A22: t1.a=Exec(i4, t2).a by SCMPDS_5:46
    .=0 by A15,AMI_3:52,SCMPDS_2:57;

  then WH is_closed_on Initialize t1 & WH is_halting_on Initialize t1
   by A1,A3,A19,A21,A16,Lm3,B12,B16,B19,B21,BX;
  then
A23: WH is_closed_on t1 & WH is_halting_on t1 by SCMPDS_6:139,140;

  IExec(WH,t1) = IExec(WH,Initialize t1) by SCMPDS_5:48;
  then IExec(WH,t1).a1=Sum f by A1,A3,A22,A19,A21,A16,Lm3,B12,B16,B19,B21,BX;
  hence IExec(sum(n,p0),s).a1=Sum f by A23,SCPISORT:8;
  thus thesis by A23,SCPISORT:10;
end;

theorem
  for s being 0-started State of SCMPDS,n,
    p0 be Element of NAT, f be FinSequence
of INT st p0 >= 3 & f is_FinSequence_on s,p0 & len f=n holds IExec(sum(n,p0),s)
  .intpos 1=Sum f & sum(n,p0) is parahalting
proof
  let s be 0-started State of SCMPDS,
      n,p0 be Element of NAT,f be FinSequence of INT;
  assume that
A1: p0 >= 3 and
A2: f is_FinSequence_on s,p0 & len f=n;
  thus IExec(sum(n,p0),s).a1=Sum f by A1,A2,Lm4;
  now
    let t be State of SCMPDS;
    consider g being FinSequence of INT such that
W:     len g=n & g is_FinSequence_on t,p0 by SCPISORT:3;
     g is_FinSequence_on Initialize t,p0
  proof let i be Element of NAT;
    assume 1 <= i & i <= len g;
     then g.i=t.intpos(p0+i) by W,SCPISORT:def 1;
    hence thesis by SCMPDS_5:40;
   end;
     then sum(n,p0) is_halting_on Initialize t by A1,Lm4,W;
    hence sum(n,p0) is_halting_on t by SCMPDS_6:140;
  end;
  hence thesis by SCMPDS_6:35;
end;

begin :: Computing directly the result of "while>0" program by loop-invariant

scheme
  WhileGEnd { F(State of SCMPDS)-> Element of NAT, s() -> State of SCMPDS,I()
-> halt-free shiftable Program of SCMPDS, a() -> Int_position,i() -> Integer,
P[set]}: F(Dstate IExec(while>0(a(),i(),I()),s()))=0 & P[Dstate IExec(while>0(a
  (),i(),I()),s())]
provided
A1: card I() > 0 and
A2: for t be State of SCMPDS st P[Dstate t] holds F(Dstate(t))=0 iff t.
DataLoc(s().a(),i()) <= 0 and
A3: P[Dstate s()] and
A4: for t be State of SCMPDS st P[Dstate t] & t.a()=s().a() & t.DataLoc(
s().a(),i()) > 0 holds IExec(I(),t).a()=t.a() & I() is_closed_on t & I()
is_halting_on t & F(Dstate IExec(I(),t)) < F(Dstate t) & P[Dstate(IExec(I(),t))
]
proof
  set b=DataLoc(s().a(),i()), WHL=while>0(a(),i(),I());
  defpred Q[Element of NAT] means for t be State of SCMPDS st F(Dstate t) <=
  $1 & t.a()=s().a() & P[Dstate t] holds F(Dstate IExec(WHL,t))=0 & P[Dstate
  IExec(WHL,t)];
A5: Q[0]
  proof
    let t be State of SCMPDS;
    assume that
A6: F(Dstate t) <= 0 and
A7: t.a()=s().a() and
A8: P[Dstate t];
    F(Dstate t) >= 0 by NAT_1:2;
    then
A9: F(Dstate t)=0 by A6,XXREAL_0:1;
    then t.DataLoc(s().a(),i()) <= 0 by A2,A8;
    then for b be Int_position holds IExec(WHL,t).b = t.b by A7,SCMPDS_8:23;
    hence thesis by A8,A9,SCPISORT:5;
  end;
A10: now
    let k be Element of NAT;
    assume
A11: Q[k];
    now
      let u be State of SCMPDS;
      assume that
A12:  F(Dstate u) <= k+1 and
A13:  u.a()=s().a() and
A14:  P[Dstate u];
      per cases;
      suppose
        F(Dstate u)=0;
        hence F(Dstate IExec(WHL,u))=0 & P[Dstate IExec(WHL,u)] by A5,A13,A14;
      end;
      suppose
A15:    F(Dstate u) <> 0;
        set Iu=IExec(I(),u);
A16:    u.b > 0 by A2,A14,A15;
        then
A17:    Iu.a()=s().a() & P[Dstate Iu] by A4,A13,A14;
        deffunc F(State of SCMPDS) = F($1);
A18:    P[Dstate u] by A14;
A19:    for t be State of SCMPDS st P[Dstate t] & F(Dstate(t))=0 holds t.
        DataLoc(u.a(),i()) <= 0 by A2,A13;
        F(Dstate Iu) < F(Dstate u) by A4,A13,A14,A16;
        then F(Dstate Iu)+1 <= F(Dstate u) by INT_1:20;
        then F(Dstate Iu)+1 <= k+1 by A12,XXREAL_0:2;
        then
A20:    F(Dstate Iu) <= k by XREAL_1:8;
A21:    for t being State of SCMPDS st P[Dstate t] & t.a()=u.a() & t.
DataLoc(u.a(),i()) > 0 holds IExec(I(),t).a()=t.a() & I() is_closed_on t & I()
is_halting_on t & F(Dstate IExec(I(),t)) < F(Dstate t) & P[Dstate(IExec(I(),t))
        ] by A4,A13;
A22:    u.DataLoc(u.a(),i()) > 0 by A2,A13,A14,A15;
        (F(u)=F(u) or P[u]) & IExec(WHL,u) = IExec(WHL,Iu) from SCMPDS_8:
        sch 4 (A1,A22,A19,A18,A21);
        hence F(Dstate IExec(WHL,u))=0 & P[Dstate IExec(WHL,u)] by A11,A20,A17;
      end;
    end;
    hence Q[k+1];
  end;
  for k being Element of NAT holds Q[k] from NAT_1:sch 1(A5,A10);
  then Q[F(Dstate s())];
  hence thesis by A3;
end;

begin :: An Example : Computing directly Fibonacci sequence by loop-invariant

definition
  let n be Element of NAT;
  func Fib-macro(n) -> Program of SCMPDS equals
  (GBP:=0) ';' (intpos 1:=0) ';'
(intpos 2:=1) ';' (intpos 3:=n) ';' while>0(GBP,3,((GBP,4):=(GBP,2)) ';' AddTo(
  GBP,2,GBP,1) ';' ((GBP,1):=(GBP,4)) ';' AddTo(GBP,3,-1));
  coherence;
end;

theorem Th10:
  for s being State of SCMPDS,I being halt-free shiftable
Program of SCMPDS, a,f0,f1 being Int_position,n,i be Element of NAT st card I >
  0 & s.a=0 & s.f0=0 & s.f1=1 & s.intpos i=n & (for t be State of SCMPDS,k be
  Element of NAT st n=t.intpos i+k & t.f0=Fib k & t.f1 = Fib (k+1) & t.a=0 & t.
  intpos i > 0 holds IExec(I,t).a=0 & I is_closed_on t & I is_halting_on t &
  IExec(I,t).intpos i=t.intpos i-1 & IExec(I,t).f0=Fib (k+1) & IExec(I,t).f1 =
Fib (k+1+1)) holds IExec(while>0(a,i,I),s).f0=Fib n & IExec(while>0(a,i,I),s).
  f1=Fib (n+1) & while>0(a,i,I) is_closed_on s & while>0(a,i,I) is_halting_on s
proof
  let s be State of SCMPDS,I be halt-free shiftable Program of SCMPDS, a,f0,
  f1 be Int_position,n,i be Element of NAT;
  assume
A1: card I > 0;
  set Iw=IExec(while>0(a,i,I),s), Dw=Dstate Iw;
  set da=DataLoc(s.a,i);
  defpred P[State of SCMPDS] means $1.intpos i >= 0 & ex k be Element of NAT
  st n=$1.intpos i+k & $1.f0=Fib k & $1.f1=Fib (k+1);
  assume that
A2: s.a=0 and
A3: s.f0=0 and
A4: s.f1=1 and
A5: s.intpos i=n;
  consider ff be Function of product the Object-Kind of SCMPDS,NAT such that
A6: for t be State of SCMPDS holds (t.da <= 0 implies ff.t =0) & (t.da >
  0 implies ff.t=t.da) by SCMPDS_8:5;
  deffunc F(State of SCMPDS) = ff.$1;
A7: now
    let t be State of SCMPDS;
    set dt=Dstate t;
    assume P[dt];
    hereby
      assume
A8:   F(dt)=0;
      assume t.da > 0;
      then dt.da > 0 by SCMPDS_8:4;
      hence contradiction by A6,A8;
    end;
    assume t.da <= 0;
    then dt.da <= 0 by SCMPDS_8:4;
    hence F(dt)=0 by A6;
  end;
  assume
A9: for t be State of SCMPDS,k be Element of NAT st n=t.intpos i+k & t.
  f0=Fib k & t.f1 = Fib (k+1) & t.a=0 & t.intpos i > 0 holds IExec(I,t).a=0 & I
is_closed_on t & I is_halting_on t & IExec(I,t).intpos i=t.intpos i-1 & IExec(I
  ,t).f0=Fib (k+1) & IExec(I,t).f1 = Fib (k+1+1);
A10: now
    let t be State of SCMPDS;
    set Dt=Dstate t;
    assume that
A11: P[Dstate t] and
A12: t.a=s.a and
A13: t.DataLoc(s.a,i) > 0;
    set It=IExec(I,t);
    set Dit=Dstate It;
    consider k be Element of NAT such that
A14: n=Dt.intpos i+k and
A15: Dt.f0=Fib k and
A16: Dt.f1=Fib (k+1) by A11;
A17: t.f1=Fib (k+1) by A16,SCMPDS_8:4;
A18: intpos (0+i)=da by A2,SCMP_GCD:5;
A19: n=t.intpos i+k & t.f0=Fib k by A14,A15,SCMPDS_8:4;
    hence IExec(I,t).a=t.a by A2,A9,A12,A13,A17,A18;
    thus I is_closed_on t & I is_halting_on t by A2,A9,A12,A13,A19,A17,A18;
A20: It.intpos i=t.intpos i-1 by A2,A9,A12,A13,A19,A17,A18;
    hereby
      per cases;
      suppose
        It.intpos i <= 0;
        then Dit.da <= 0 by A18,SCMPDS_8:4;
        then
A21:    F(Dit)=0 by A6;
        F(Dt) <> 0 by A7,A11,A13;
        hence F(Dit) < F(Dt) by A21,NAT_1:3;
      end;
      suppose
A22:    It.intpos i > 0;
        Dt.da > 0 by A13,SCMPDS_8:4;
        then
A23:    F(Dt)=Dt.da by A6
          .=t.intpos i by A18,SCMPDS_8:4;
        Dit.da > 0 by A18,A22,SCMPDS_8:4;
        then F(Dit)=Dit.da by A6
          .=t.intpos i-1 by A18,A20,SCMPDS_8:4;
        hence F(Dit) < F(Dt) by A23,XREAL_1:148;
      end;
    end;
    thus P[Dit]
    proof
      t.intpos i >= 1+0 by A13,A18,INT_1:20;
      then t.intpos i-1 >= 0 by XREAL_1:50;
      hence Dit.intpos i >= 0 by A20,SCMPDS_8:4;
      take m=k+1;
      thus n=t.intpos i-1+1+k by A14,SCMPDS_8:4
        .=Dit.intpos i+1+k by A20,SCMPDS_8:4
        .=Dit.intpos i+m;
      It.f0=Fib m & It.f1=Fib (k+1+1) by A2,A9,A12,A13,A19,A17,A18;
      hence thesis by SCMPDS_8:4;
    end;
  end;
A24: P[Dstate s]
  proof
    set Ds=Dstate s;
    Ds.intpos i =n by A5,SCMPDS_8:4;
    hence Ds.intpos i >= 0 by NAT_1:2;
    take k=0;
    thus n=Ds.intpos i+k by A5,SCMPDS_8:4;
    thus Ds.f0=Fib k by A3,PRE_FF:1,SCMPDS_8:4;
    thus thesis by A4,PRE_FF:1,SCMPDS_8:4;
  end;
A25: F(Dw)=0 & P[Dw] from WhileGEnd(A1,A7,A24,A10);
  Dw.intpos i=Iw.intpos(0+i) by SCMPDS_8:4
    .=Iw.da by A2,SCMP_GCD:5;
  then Dw.intpos i <= 0 by A7,A25;
  then Dw.intpos i=0 by A25,XXREAL_0:1;
  hence Iw.f0=Fib n & Iw.f1=Fib (n+1) by A25,SCMPDS_8:4;
A26: for t be State of SCMPDS st P[Dstate t] & F(Dstate(t))=0 holds t.da <=
  0 by A7;
  (F(s)=F(s) or P[s]) & while>0(a,i,I) is_closed_on s & while>0(a,i,I)
  is_halting_on s from SCMPDS_8:sch 3(A1,A26,A24,A10);
  hence thesis;
end;

set j1= (GBP,4):=(GBP,2), j2= AddTo(GBP,2,GBP,1), j3= (GBP,1):=(GBP,4), j4=
AddTo(GBP,3,-1), WB= j1 ';' j2 ';' j3 ';' j4, WH= while>0(GBP,3,WB);

Lm5: for s being State of SCMPDS st s.GBP=0 holds IExec(WB,s).GBP=0 & IExec(WB
,s).a1=s.a2 & IExec(WB,s).a2=s.a1+s.a2 & IExec(WB,s).a3=s.a3-1

proof
  set a=GBP;
  let s be State of SCMPDS;

  set t0=Initialize s, t1=IExec(WB,s), t2=IExec(j1 ';' j2 ';' j3,s),
      t3=IExec(j1 ';' j2,s), t4=Exec(j1, t0), a4=intpos 4;
X0: Initialize t0 = t0;
X1: t1=IExec(WB,t0) by SCMPDS_5:48;
X2: t2=IExec(j1 ';' j2 ';' j3,t0) by SCMPDS_5:48;
X3: t3=IExec(j1 ';' j2,t0) by SCMPDS_5:48;
  assume s.a=0;
  then
A1: t0.a=0 by SCMPDS_5:40;
  then DataLoc(t0.a,4)=intpos (0+4) by SCMP_GCD:5;
  then
A2: t4.a4=t0.DataLoc(t0.a,2) by SCMPDS_2:59
    .=t0.intpos(0+2) by A1,SCMP_GCD:5
    .=s.a2 by SCMPDS_5:40;
  0 <> abs(t0.GBP+4) by A1,ABSVALUE:def 1;
  then a <> DataLoc(t0.GBP,4) by ZFMISC_1:33;
  then
A3: t4.a=0 by A1,SCMPDS_2:59;
  then
A4: DataLoc(t4.a,2)=intpos (0+2) by SCMP_GCD:5;
  0 <> abs(t4.GBP+2) by A3,ABSVALUE:def 1;
  then
A5: a <> DataLoc(t4.GBP,2) by ZFMISC_1:33;
A6: t3.a=Exec(j2,t4).a by X0,X3,SCMPDS_5:47
    .=0 by A3,A5,SCMPDS_2:61;
  then
A7: DataLoc(t3.a,1)=intpos (0+1) by SCMP_GCD:5;
  4 <> abs(t4.GBP+2) by A3,ABSVALUE:def 1;
  then
A8: a4 <> DataLoc(t4.GBP,2) by ZFMISC_1:33;
A9: t3.a4=Exec(j2,t4).a4 by X0,X3,SCMPDS_5:47
    .=s.a2 by A2,A8,SCMPDS_2:61;
A10: t2.a1=Exec(j3,t3).a1 by X2,X3,SCMPDS_5:46
    .=t3.DataLoc(t3.a,4) by A7,SCMPDS_2:59
    .=s.a2 by A6,A9,SCMP_GCD:5;
  3 <> abs(t4.GBP+2) by A3,ABSVALUE:def 1;
  then
A11: a3 <> DataLoc(t4.GBP,2) by ZFMISC_1:33;
  2 <> abs(t0.GBP+4) by A1,ABSVALUE:def 1;
  then a2 <> DataLoc(t0.GBP,4) by ZFMISC_1:33;
  then
A12: t4.a2=t0.a2 by SCMPDS_2:59
    .=s.a2 by SCMPDS_5:40;
  1 <> abs(t0.GBP+4) by A1,ABSVALUE:def 1;
  then a1 <> DataLoc(t0.GBP,4) by ZFMISC_1:33;
  then
A13: t4.a1=t0.a1 by SCMPDS_2:59
    .=s.a1 by SCMPDS_5:40;
  3 <> abs(t0.GBP+4) by A1,ABSVALUE:def 1;
  then a3 <> DataLoc(t0.GBP,4) by ZFMISC_1:33;
  then
A14: t4.a3=t0.a3 by SCMPDS_2:59
    .=s.a3 by SCMPDS_5:40;
  0 <> abs(t3.GBP+1) by A6,ABSVALUE:def 1;
  then
A15: a <> DataLoc(t3.GBP,1) by ZFMISC_1:33;
A16: t2.a=Exec(j3,t3).a by X2,X3,SCMPDS_5:46
    .=0 by A6,A15,SCMPDS_2:59;
  then
A17: DataLoc(t2.a,3)=intpos (0+3) by SCMP_GCD:5;
  2 <> abs(t3.GBP+1) by A6,ABSVALUE:def 1;
  then
A18: a2 <> DataLoc(t3.GBP,1) by ZFMISC_1:33;
A19: t3.a2=Exec(j2,t4).a2 by X0,X3,SCMPDS_5:47
    .=t4.a2+t4.DataLoc(t4.a,1) by A4,SCMPDS_2:61
    .=s.a2+s.a1 by A3,A13,A12,SCMP_GCD:5;
A20: t2.a2=Exec(j3,t3).a2 by X2,X3,SCMPDS_5:46
    .=s.a2+s.a1 by A19,A18,SCMPDS_2:59;
  3 <> abs(t3.GBP+1) by A6,ABSVALUE:def 1;
  then
A21: a3 <> DataLoc(t3.GBP,1) by ZFMISC_1:33;
  0 <> abs(t2.GBP+3) by A16,ABSVALUE:def 1;
  then
A22: a <> DataLoc(t2.GBP,3) by ZFMISC_1:33;
  thus t1.a=Exec(j4,t2).a by X1,X2,SCMPDS_5:46
    .=0 by A16,A22,SCMPDS_2:60;
  1 <> abs(t2.GBP+3) by A16,ABSVALUE:def 1;
  then
A23: a1 <> DataLoc(t2.GBP,3) by ZFMISC_1:33;
  thus t1.a1=Exec(j4,t2).a1 by X1,X2,SCMPDS_5:46
    .=s.a2 by A10,A23,SCMPDS_2:60;
  2 <> abs(t2.GBP+3) by A16,ABSVALUE:def 1;
  then
A24: a2 <> DataLoc(t2.GBP,3) by ZFMISC_1:33;
A25: t3.a3=Exec(j2,t4).a3 by X0,X3,SCMPDS_5:47
    .=s.a3 by A14,A11,SCMPDS_2:61;
A26: t2.a3=Exec(j3,t3).a3 by X2,X3,SCMPDS_5:46
    .=s.a3 by A25,A21,SCMPDS_2:59;
  thus t1.a2=Exec(j4,t2).a2 by X1,X2,SCMPDS_5:46
    .=s.a1+s.a2 by A20,A24,SCMPDS_2:60;
  thus t1.a3=Exec(j4,t2).a3 by X1,X2,SCMPDS_5:46
    .=t2.a3+-1 by A17,SCMPDS_2:60
    .=s.a3-1 by A26;
end;

Lm6: card WB=4
proof
  thus card WB=card (j1 ';' j2 ';' j3) +1 by SCMP_GCD:8
    .=card (j1 ';' j2)+1+1 by SCMP_GCD:8
    .=2+1+1 by SCMP_GCD:9
    .=4;
end;

Lm7: for s being State of SCMPDS,n be Element of NAT st s.GBP=0 & s.a1=0 & s.
a2=1 & s.a3=n holds IExec(WH,s).a1=Fib n & IExec(WH,s).a2=Fib (n+1) & WH
is_closed_on s & WH is_halting_on s

proof
  let s be State of SCMPDS,n be Element of NAT;
  set a=GBP;
A1: now
    let t be State of SCMPDS,k be Element of NAT;
    assume that
    n=t.a3+k and
A2: t.a1=Fib k and
A3: t.a2 = Fib (k+1) and
A4: t.a=0 and
    t.a3 > 0;
    thus IExec(WB,t).a=0 by A4,Lm5;
    thus WB is_closed_on t & WB is_halting_on t by SCMPDS_6:34,35;
    thus IExec(WB,t).a3=t.a3-1 by A4,Lm5;
    thus IExec(WB,t).a1=Fib (k+1) by A3,A4,Lm5;
    thus IExec(WB,t).a2 =t.a1+t.a2 by A4,Lm5
      .=Fib (k+1+1) by A2,A3,PRE_FF:1;
  end;
  assume s.GBP=0 & s.a1=0 & s.a2=1 & s.a3=n;
  hence thesis by A1,Lm6,Th10;
end;

Lm8: for s being 0-started State of SCMPDS,
n be Element of NAT holds IExec(Fib-macro(n),
s).a1=Fib n & IExec(Fib-macro(n),s).a2=Fib (n+1) & Fib-macro(n) is_halting_on s

proof
  let s be 0-started State of SCMPDS,n be Element of NAT;

  set a=GBP, i1=a:=0, i2=a1:=0, i3=a2:=1, i4=a3:=n, I4=i1 ';' i2 ';' i3 ';' i4

, t1=IExec(I4,s),
  t2=IExec(i1 ';' i2 ';' i3,s), t3=IExec(i1 ';' i2,s), t4=Exec(
  i1, Initialize s);
A1: t4.a=0 by SCMPDS_2:57;
A2: t3.a=Exec(i2, t4).a by SCMPDS_5:47
    .=0 by A1,AMI_3:52,SCMPDS_2:57;
A3: t2.a=Exec(i3, t3).a by SCMPDS_5:46
    .=0 by A2,AMI_3:52,SCMPDS_2:57;
A4: t3.a1=Exec(i2, t4).a1 by SCMPDS_5:47
    .=0 by SCMPDS_2:57;
A5: t2.a1=Exec(i3, t3).a1 by SCMPDS_5:46
    .=0 by A4,AMI_3:52,SCMPDS_2:57;
A6: t1.a1=Exec(i4, t2).a1 by SCMPDS_5:46
    .=0 by A5,AMI_3:52,SCMPDS_2:57;
A7: t2.a2=Exec(i3, t3).a2 by SCMPDS_5:46
    .=1 by SCMPDS_2:57;
A8: t1.a2=Exec(i4, t2).a2 by SCMPDS_5:46
    .=1 by A7,AMI_3:52,SCMPDS_2:57;
A9: t1.a3=Exec(i4, t2).a3 by SCMPDS_5:46
    .=n by SCMPDS_2:57;
A10: t1.a=Exec(i4, t2).a by SCMPDS_5:46
    .=0 by A3,AMI_3:52,SCMPDS_2:57;
  then
A11: WH is_closed_on t1 & WH is_halting_on t1 by A6,A8,A9,Lm7;
  IExec(WH,t1).a1=Fib n by A10,A6,A8,A9,Lm7;
  hence IExec(Fib-macro(n),s).a1=Fib n by A11,SCPISORT:8;
  IExec(WH,t1).a2=Fib (n+1) by A10,A6,A8,A9,Lm7;
  hence IExec(Fib-macro(n),s).a2=Fib (n+1) by A11,SCPISORT:8;
  thus thesis by A11,SCPISORT:10;
end;

theorem
  for s being 0-started State of SCMPDS,
  n be Element of NAT holds IExec(Fib-macro(
n),s).intpos 1=Fib n & IExec(Fib-macro(n),s).intpos 2=Fib (n+1) & Fib-macro(n)
  is parahalting
proof
  let s be 0-started State of SCMPDS,n be Element of NAT;
  thus IExec(Fib-macro(n),s).a1=Fib n & IExec(Fib-macro(n),s).a2=Fib (n+1) by
Lm8;
  for t be State of SCMPDS holds Fib-macro(n) is_halting_on t
   proof let t be State of SCMPDS;
     Fib-macro(n) is_halting_on Initialize t by Lm8;
    hence thesis by SCMPDS_6:140;
   end;
  hence thesis by SCMPDS_6:35;
end;

begin :: The construction of while<>0 loop program

:: while (a,i)<>0 do I

definition
  let a be Int_position, i be Integer;
  let I be Program of SCMPDS;
  func while<>0(a,i,I) -> Program of SCMPDS equals
  (a,i)<>0_goto 2 ';' goto (
  card I+2) ';' I ';' goto -(card I+2);
  coherence;
end;

begin :: The basic property of "while<>0" program

theorem Th12:
  for a be Int_position,i be Integer,I be Program of SCMPDS holds
  card while<>0(a,i,I)= card I +3
proof
  let a be Int_position,i be Integer, I be Program of SCMPDS;
  set i1=(a,i)<>0_goto 2, i2=goto (card I+2);
  set I4=i1 ';' i2 ';' I;
  thus card while<>0(a,i,I) =card I4+1 by SCMP_GCD:8
    .=card (i1 ';' i2)+ card I+1 by AFINSQ_1:20
    .=2+card I +1 by SCMP_GCD:9
    .=card I + 3;
end;

Lm9: for a be Int_position,i be Integer,I be Program of SCMPDS holds card stop
while<>0(a,i,I)= card I+4

proof
  let a be Int_position,i be Integer,I be Program of SCMPDS;
  thus card stop while<>0(a,i,I)= card while<>0(a,i,I) +1 by SCMPDS_5:7
    .= card I +3+1 by Th12
    .= card I + 4;
end;

theorem Th13:
  for a be Int_position,i be Integer,m be Element of NAT,I be
  Program of SCMPDS holds m < card I+3 iff  m in dom while<>0(a,i,I)
proof
  let a be Int_position,i be Integer,m be Element of NAT, I be Program of
  SCMPDS;
  card while<>0(a,i,I)=card I + 3 by Th12;
  hence thesis by AFINSQ_1:70;
end;

theorem Th14:
  for a be Int_position,i be Integer,I be Program of SCMPDS holds
   0 in dom while<>0(a,i,I) &  1 in dom while<>0(a,i,I)
proof
  let a be Int_position,i be Integer,I be Program of SCMPDS;
  3 <= card I+3 by NAT_1:11;
  then 0 < card I+3 & 1 < card I+3 by XXREAL_0:2;
  hence thesis by Th13;
end;

theorem Th15:
  for a be Int_position,i be Integer,I be Program of SCMPDS holds
while<>0(a,i,I). 0=(a,i)<>0_goto 2 & while<>0(a,i,I). 1= goto (card
  I +2) & while<>0(a,i,I). (card I+2)=goto -(card I+2)
proof
  let a be Int_position,i be Integer,I be Program of SCMPDS;
  set i1=(a,i)<>0_goto 2, i2=goto (card I+2), i3=goto -(card I+2);
  set I4=i1 ';' i2 ';' I;
  set WHL=while<>0(a,i,I);
A1: WHL=i1 ';' i2 ';' (I ';' i3) by SCMPDS_4:47;
  hence WHL. 0=i1 by Th5;
  thus WHL. 1=i2 by A1,Th5;
  card I4=card (i1 ';' i2)+ card I by AFINSQ_1:20
    .=card I +2 by SCMP_GCD:9;
  hence thesis by SCMP_GCD:10;
end;

Lm10: for a be Int_position,i be Integer,I be Program of SCMPDS holds while<>0
(a,i,I)= ((a,i)<>0_goto 2) ';' (goto (card I+2) ';' I ';' goto -(card I+2))

proof
  let a be Int_position,i be Integer,I be Program of SCMPDS;
  set i1=(a,i)<>0_goto 2, i2=goto (card I+2), i3=goto -(card I+2);
  thus while<>0(a,i,I) = i1 ';' (i2 ';' I) ';' i3 by SCMPDS_4:52
    .= i1 ';' (i2 ';' I ';' i3) by SCMPDS_4:51;
end;

theorem Th16:
  for s being State of SCMPDS,I being Program of SCMPDS,a being
  Int_position, i being Integer st s.DataLoc(s.a,i) = 0 holds while<>0(a,i,I)
  is_closed_on s & while<>0(a,i,I) is_halting_on s
proof
  let s be State of SCMPDS,I be Program of SCMPDS,a be Int_position, i be
  Integer;
  set b=DataLoc(s.a,i);
  assume
A1: s.b = 0;
  set WHL=while<>0(a,i,I), pWH=stop WHL, iWH=Initialize pWH,
  s3 = Initialize s +* pWH,
  s4 = Comput(ProgramPart(s3),s3,1), s5 = Comput(ProgramPart(s3),s3,2);
I1: s3 = s +* Initialize pWH by COMPOS_1:125;
A2: not b in dom iWH by SCMPDS_4:31;
  not a in dom iWH by SCMPDS_4:31;
  then
A3: s3.DataLoc(s3.a,i)=s3.b by I1,FUNCT_4:12
    .= 0 by A1,A2,I1,FUNCT_4:12;
  set i1=(a,i)<>0_goto 2, i2=goto (card I+2), i3=goto -(card I+2);
A4: IC s3 = 0 by SCMPDS_6:21;
A5: WHL = i1 ';' (i2 ';' I ';' i3 ) by Lm10;
  Comput(ProgramPart(s3),s3,0+1) = Following(ProgramPart s3,
  Comput(ProgramPart(s3),s3,0)) by EXTPRO_1:4
    .= Following(ProgramPart s3,s3) by EXTPRO_1:3
    .= Exec(i1,s3) by A5,I1,SCMPDS_6:22;
  then
A6: IC s4 = succ IC s3 by A3,SCMPDS_2:67
    .= (0+1) by A4;
A7: iWH c= s3 by I1,FUNCT_4:26;
  then
A8: pWH c= s4 by AMI_1:81,COMPOS_1:132;
A9:  1 in dom WHL by Th14;
  then  1 in dom pWH by SCMPDS_6:18;
  then
A10: s4. 1 = pWH. 1 by A8,GRFUNC_1:8
    .=WHL. 1 by A9,SCMPDS_6:19
    .=i2 by Th15;
A11: card WHL=card I+3 by Th12;
  then
A12: (card I+3) in dom pWH by SCMPDS_6:25;
Y:  (ProgramPart s4)/.IC s4
 = s4.IC s4 by COMPOS_1:38;
T: ProgramPart s3 = ProgramPart s4
by AMI_1:123;
  Comput(ProgramPart(s3),s3,1+1) = Following(ProgramPart s3,s4) by EXTPRO_1:4
    .= Exec(i2,s4) by A6,A10,Y,T;
  then
A13: IC s5 = ICplusConst(s4,card I+2) by SCMPDS_2:66
    .= (card I+2+1) by A6,SCMPDS_6:23
    .= (card I+(2+1));
Y:  (ProgramPart s5)/.IC s5
 = s5.IC s5 by COMPOS_1:38;
  pWH c= s5 by A7,AMI_1:81,COMPOS_1:132;
  then s5.(card I+3) = pWH.(card I+3) by A12,GRFUNC_1:8
    .=halt SCMPDS by A11,SCMPDS_6:25;
  then
A14: CurInstr(ProgramPart s5,s5) = halt SCMPDS by A13,Y;
TX: ProgramPart s3 = ProgramPart s5
by AMI_1:123;
  now
    let k be Element of NAT;
    k = 0 or 0 < k by NAT_1:3;
    then
A15: k = 0 or 0 + 1 <= k by INT_1:20;
    per cases by A15,XXREAL_0:1;
    suppose
      k = 0;
      then Comput(ProgramPart(s3),s3,k) = s3 by EXTPRO_1:3;
      hence IC Comput(ProgramPart(s3),s3,k) in dom pWH by A4,COMPOS_1:135;
    end;
    suppose
      k = 1;
      hence IC Comput(ProgramPart(s3),s3,k) in dom pWH by A9,A6,SCMPDS_6:18;
    end;
    suppose
      1 < k;
      then 1+1 <= k by INT_1:20;
      hence IC Comput(ProgramPart(s3),s3,k) in dom pWH
      by A12,A13,A14,TX,EXTPRO_1:6;
    end;
  end;
  hence WHL is_closed_on s by SCMPDS_6:def 2;
  ProgramPart s3 halts_on s3 by A14,TX,EXTPRO_1:30;
  hence thesis by SCMPDS_6:def 3;
end;

theorem Th17:
  for s being State of SCMPDS,I being Program of SCMPDS,a,c being
Int_position, i being Integer st s.DataLoc(s.a,i) = 0 holds IExec(while<>0(a,i,
  I),s) = s +* Start-At((card I+3),SCMPDS)
proof
  let s be State of SCMPDS,I be Program of SCMPDS, a,c be Int_position, i be
  Integer;
  set b=DataLoc(s.a,i);
  assume
A1: s.b = 0;
  set i1=(a,i)<>0_goto 2, i2=goto (card I+2), i3=goto -(card I+2);
  set WHL=while<>0(a,i,I), pWH=stop WHL, iWH=Initialize pWH,
  s3 = Initialize s +* pWH,
  s4 = Comput(ProgramPart(s3),s3,1), s5 = Comput(ProgramPart(s3),s3,2);
I1: s3 = s +* Initialize pWH by COMPOS_1:125;
A2: IC s3 = 0 by SCMPDS_6:21;
A3: iWH c= s3 by I1,FUNCT_4:26;
  then
A4: pWH c= s4 by AMI_1:81,COMPOS_1:132;
A5: pWH c= s5 by A3,AMI_1:81,COMPOS_1:132;
A6: not b in dom iWH by SCMPDS_4:31;
A7: WHL = i1 ';' (i2 ';' I ';' i3 ) by Lm10;
A8: Comput(ProgramPart(s3),s3,0+1) = Following(ProgramPart s3,
Comput(ProgramPart(s3),s3,0)) by EXTPRO_1:4
    .= Following(ProgramPart s3,s3) by EXTPRO_1:3
    .= Exec(i1,s3) by A7,I1,SCMPDS_6:22;
A9:  1 in dom WHL by Th14;
  then  1 in dom pWH by SCMPDS_6:18;
  then
A10: s4. 1 = pWH. 1 by A4,GRFUNC_1:8
    .=WHL. 1 by A9,SCMPDS_6:19
    .=i2 by Th15;
  set SAl=Start-At((card I+3),SCMPDS);
A11: dom ProgramPart s = A by COMPOS_1:34;
  not a in dom iWH by SCMPDS_4:31;
  then s3.DataLoc(s3.a,i)=s3.b by I1,FUNCT_4:12
    .= 0 by A1,A6,I1,FUNCT_4:12;
  then
A12: IC s4 = succ IC s3 by A8,SCMPDS_2:67
    .= (0+1) by A2;
T4: ProgramPart s3 = ProgramPart s4 by AMI_1:123;
T5: ProgramPart s3 = ProgramPart s5 by AMI_1:123;
Y:  (ProgramPart s3)/.IC s4 = s4.IC s4 by T4,COMPOS_1:38;
A13: Comput(ProgramPart(s3),s3,1+1) = Following(ProgramPart s3,s4) by
EXTPRO_1:4
    .= Exec(i2,s4) by A12,A10,Y;
  then
A14: IC s5 = ICplusConst(s4,card I+2) by SCMPDS_2:66
    .= (card I+2+1) by A12,SCMPDS_6:23
    .= (card I+(2+1));
Y:  (ProgramPart s3)/.IC s5
 = s5.IC s5 by T5,COMPOS_1:38;
A15: card WHL=card I+3 by Th12;
  then (card I+3) in dom pWH by SCMPDS_6:25;
  then s5.(card I+3) = pWH.(card I+3) by A5,GRFUNC_1:8
    .=halt SCMPDS by A15,SCMPDS_6:25;
  then
A16: CurInstr(ProgramPart s3,s5) = halt SCMPDS by A14,Y;
  then ProgramPart s3 halts_on s3 by EXTPRO_1:30;
  then
A17: s5 = Result(ProgramPart(s3),s3) by A16,EXTPRO_1:def 8;
A18: IExec(WHL,s) = Result(ProgramPart(s3),s3) +* s | A by SCMPDS_4:def 8;
A19: now
    let x be set;
A20: dom SAl = {IC SCMPDS} by FUNCOP_1:19;
    assume
A21: x in dom IExec(WHL,s);
    per cases by A21,SCMPDS_4:20;
    suppose
A22:  x is Int_position;
      then x <> IC SCMPDS by SCMPDS_2:52;
      then
A23:  not x in dom SAl by A20,TARSKI:def 1;
      not x in dom (s | A) by A11,A22,SCMPDS_2:53;
      hence IExec(WHL,s).x = s5.x by A17,A18,FUNCT_4:12
        .= s4.x by A13,A22,SCMPDS_2:66
        .= s3.x by A8,A22,SCMPDS_2:67
        .= s.x by A22,SCMPDS_5:19
        .= (s +* SAl).x by A23,FUNCT_4:12;
    end;
    suppose
A24:  x = IC SCMPDS;
      not x in dom (s | A) by A11,A24,COMPOS_1:3;
      hence IExec(WHL,s).x = (card I + 3) by A14,A17,A18,A24,FUNCT_4:12
        .= (s +* SAl).x by A24,FUNCT_4:121;
    end;
    suppose
      x is Element of NAT;
      hence IExec(WHL,s).x = (s +* SAl).x by SCMPDS_6:27;
    end;
  end;
  dom IExec(WHL,s) = the carrier of SCMPDS by PARTFUN1:def 4
    .= dom (s +* SAl) by PARTFUN1:def 4;
  hence thesis by A19,FUNCT_1:9;
end;

theorem
  for s being State of SCMPDS,I being Program of SCMPDS,a being
Int_position, i being Integer st s.DataLoc(s.a,i) = 0 holds IC IExec(while<>0(a
  ,i,I),s) =  (card I + 3)
proof
  let s be State of SCMPDS,I be Program of SCMPDS,a be Int_position, i be
  Integer;
  assume s.DataLoc(s.a,i) = 0;
  then IExec(while<>0(a,i,I),s) =s +* Start-At((card I+3),SCMPDS)
  by Th17;
  hence thesis by FUNCT_4:121;
end;

theorem Th19:
  for s being State of SCMPDS,I being Program of SCMPDS,a,b being
Int_position, i being Integer st s.DataLoc(s.a,i) = 0 holds IExec(while<>0(a,i,
  I),s).b = s.b
proof
  let s be State of SCMPDS,I be Program of SCMPDS,a,b be Int_position, i be
  Integer;
  assume s.DataLoc(s.a,i) = 0;
  then
A1: IExec(while<>0(a,i,I),s) = s +* Start-At((card I+3),SCMPDS) by Th17;
  not b in dom Start-At((card I+3),SCMPDS) by SCMPDS_4:59;
  hence thesis by A1,FUNCT_4:12;
end;

Lm11: for I being Program of SCMPDS,a being Int_position,i being Integer holds
Shift(I,2) c= while<>0(a,i,I)

proof
  let I be Program of SCMPDS,a be Int_position,i be Integer;
  set i1=(a,i)<>0_goto 2, i2=goto (card I+2), i3=goto -(card I+2);

  card (i1 ';' i2)=2 & while<>0(a,i,I) = i1 ';' i2 ';' I ';' Load i3 by
SCMPDS_4:def 5,SCMP_GCD:9;

  hence thesis by SCMPDS_7:16;
end;

registration
  let I be shiftable Program of SCMPDS, a be Int_position,i be Integer;
  cluster while<>0(a,i,I) -> shiftable;
  correctness
  proof
    set WHL=while<>0(a,i,I), i1=(a,i)<>0_goto 2, i2=goto (card I+2), PF= i1
    ';' i2 ';' I;
    card PF=card (i1 ';' i2)+ card I by AFINSQ_1:20
      .=2+card I by SCMP_GCD:9;
    then PF=Load i1 ';' Load i2 ';' I & card PF+ -(card I+2) =0 by
SCMPDS_4:def 6;
    hence thesis by SCMPDS_4:78;
  end;
end;

registration
  let I be halt-free Program of SCMPDS, a be Int_position,i be Integer;
  cluster while<>0(a,i,I) -> halt-free;
  correctness
  proof
    reconsider i2=goto (card I+2) as No-StopCode Instruction of SCMPDS by
SCMPDS_5:25;
    -(card I+2) <> 0;
    then reconsider
    i3=goto -(card I+2) as No-StopCode Instruction of SCMPDS by SCMPDS_5:25;
    while<>0(a,i,I) =(a,i)<>0_goto 2 ';' i2 ';' I ';' i3;
    hence thesis;
  end;
end;

begin :: Computing directly the result of "while<>0" program by loop-invariant

scheme
  WhileNHalt { F(State of SCMPDS)-> Element of NAT, s() -> State of SCMPDS,I()
-> halt-free shiftable Program of SCMPDS, a() -> Int_position,i() -> Integer,
  P[set]}: while<>0(a(),i(),I()) is_closed_on s() & while<>0(a(),i(),I())
  is_halting_on s()
provided
A1: card I() > 0 and
A2: for t be State of SCMPDS st P[Dstate t] & F(Dstate(t))=0 holds t.
DataLoc(s().a(),i()) = 0 and
A3: P[Dstate s()] and
A4: for t be State of SCMPDS st P[Dstate t] & t.a()=s().a() & t.DataLoc(
s().a(),i()) <> 0 holds IExec(I(),t).a()=t.a() & I() is_closed_on t & I()
is_halting_on t & F(Dstate IExec(I(),t)) < F(Dstate t) & P[Dstate(IExec(I(),t))
]
proof
  set i1=(a(),i())<>0_goto 2, i2=goto (card I()+2), i3=goto -(card I()+2);
  set WHL=while<>0(a(),i(),I()), pWH=stop WHL, pI=stop I();
  set b=DataLoc(s().a(),i());
  defpred Q[Element of NAT] means for t be State of SCMPDS st F(Dstate(t)) <=
$1 & P[Dstate t] & t.a()=s().a()
     holds WHL is_closed_on t & WHL is_halting_on t;
A5: for k be Element of NAT st Q[k] holds Q[k + 1]
  proof
    let k be Element of NAT;
    assume
A6: Q[k];
    now
      let t be State of SCMPDS;
      assume
A7:   F(Dstate t) <= k+1;
      assume
A8:   P[Dstate t];
      assume
A9:   t.a()=s().a();
      per cases;
      suppose
        t.b = 0;
        hence WHL is_closed_on t & WHL is_halting_on t by A9,Th16;
      end;
      suppose
A10:    t.b <> 0;
A11:    dom ProgramPart t = A by COMPOS_1:34;
A12:  not a() in dom (t | A) by A11,SCMPDS_2:53;
A13:    IExec(I(),t).a()=t.a() by A4,A8,A9,A10;
A14:     0 in dom pWH by COMPOS_1:135;
A15:    dom ProgramPart t = A by COMPOS_1:34;
A16:    WHL = i1 ';' (i2 ';' I() ';' i3) by Lm10;
A17:    not b in dom Initialize pWH by SCMPDS_4:31;
        set t2 = Initialize t +* pI,
            t3 = Initialize t +* pWH,
        t4 = Comput(ProgramPart(t3),t3,1);
I2:     t2 = t +* Initialize pI by COMPOS_1:125;
I3:     t3 = t +* Initialize pWH by COMPOS_1:125;
A18:    Initialize pI c= t2 by I2,FUNCT_4:26;
        set m2=LifeSpan(ProgramPart(t2),t2), t5=Comput(ProgramPart(t4),t4,m2),
l2= (card I() + 2
);
A19:    IC t3 = 0 by SCMPDS_6:21;
        set m3=m2 +1;
        set t6=Comput(ProgramPart(t3),t3,m3);
        set t7=Comput(ProgramPart(t3),t3,m3+1);
        card I() + 2 < card I() + 3 by XREAL_1:8;
        then
A20:    l2 in dom WHL by Th13;
        WHL c= Initialize pWH & Initialize pWH c= t3
           by I3,FUNCT_4:26,SCMPDS_6:17;
        then
A21:    WHL c= t3 by XBOOLE_1:1;
        Shift(I(),2) c= WHL by Lm11;
        then Shift(I(),2) c= t3 by A21,XBOOLE_1:1;
        then
A22:    Shift(I(),2) c= t4 by AMI_1:81;
A23:    Comput(ProgramPart(t3),t3,0+1) = Following(ProgramPart t3,
Comput(ProgramPart(t3),t3,0)) by EXTPRO_1:4
          .= Following(ProgramPart t3,t3) by EXTPRO_1:3
          .= Exec(i1,t3) by A16,I3,SCMPDS_6:22;
A24:    DataPart t2 = DataPart t3 by COMPOS_1:138,FUNCT_7:134;
        now
          let a;
          thus t2.a = t3.a by A24,SCMPDS_4:23
            .= t4.a by A23,SCMPDS_2:67;
        end;
        then
A25:    DataPart t2 = DataPart t4 by SCMPDS_4:23;
        I() is_halting_on t by A4,A8,A9,A10;
        then
A26:    ProgramPart t2 halts_on t2 by SCMPDS_6:def 3;
I4:     Initialize t2+*pI =  t2+*Initialize pI by COMPOS_1:125;
        t2 = Initialize t2+*pI by A18,I4,FUNCT_4:79;
        then ProgramPart(Initialize t2+*pI) halts_on Initialize t2+*pI by A26;
        then
A27:    I() is_halting_on t2 by SCMPDS_6:def 3;
A28:    IExec(I(),t) = Result(ProgramPart(t2),t2) +* t | A
 by SCMPDS_4:def 8;
A29:    P[Dstate(IExec(I(),t))] by A4,A8,A9,A10;
A30:    I() is_closed_on t by A4,A8,A9,A10;
        then
A31:    I() is_closed_on t2 by SCMPDS_6:38;
        not a() in dom Initialize pWH by SCMPDS_4:31;
        then t3.DataLoc(t3.a(),i())= t3.b by A9,I3,FUNCT_4:12
          .= t.b by A17,I3,FUNCT_4:12;
        then
A32:    IC t4 = ICplusConst(t3,2) by A10,A23,SCMPDS_2:67
          .= (0+2) by A19,SCMPDS_6:23;
        then
A33:    IC t5=l2 by A1,A18,A27,A31,A25,A22,SCMPDS_7:36;
Y:  (ProgramPart t6)/.IC t6
 = t6.IC t6 by COMPOS_1:38;
 ProgramPart t3 = ProgramPart t4
by AMI_1:123;
 then
A34:    t6=t5 by EXTPRO_1:5;
        then
A35:    CurInstr(ProgramPart t6,t6)
=t5.l2 by A1,A18,A27,A31,A32,A25,A22,Y,SCMPDS_7:36
          .=t4.l2 by AMI_1:54
          .=t3.l2 by AMI_1:54
          .=WHL.l2 by A20,A21,GRFUNC_1:8
          .=i3 by Th15;
T: ProgramPart t3 = ProgramPart t6
by AMI_1:123;
A36:    t7 = Following(ProgramPart t3,t6) by EXTPRO_1:4
          .= Exec(i3,t6) by A35,T;
        then IC t7=ICplusConst(t6,0-(card I()+2)) by SCMPDS_2:66
          .= 0 by A33,A34,SCMPDS_7:1;
        then
A37:    Initialize t7 +* pWH=t7 by SCMPDS_7:37;
A38:    DataPart Comput(ProgramPart(t2),t2,m2) = DataPart t5 by A1,A18,A27,A31
,A32,A25,A22,SCMPDS_7:36;
        then
A39:    DataPart t5 = DataPart(Result(ProgramPart(t2),t2)) by A26,EXTPRO_1:23
          .= DataPart(Result(ProgramPart(t2),t2) +* t | A) by A15,AMI_2:29
,FUNCT_4:76,SCMPDS_2:100
          .= DataPart IExec(I(),t) by SCMPDS_4:def 8;
        InsCode i3=0 by SCMPDS_2:21;
        then InsCode i3 in {0,4,5,6} by ENUMSET1:def 2;
        then
A40:    Dstate(t7)=Dstate(t6) by A36,SCMPDS_8:3
          .=Dstate(IExec(I(),t)) by A39,A34,SCMPDS_8:2;
A41:    now
          F(Dstate(IExec(I(),t))) < F(Dstate(t)) by A4,A8,A9,A10;
          then
A42:      F(Dstate(t7)) < k+1 by A7,A40,XXREAL_0:2;
          assume F(Dstate(t7)) > k;
          hence contradiction by A42,INT_1:20;
        end;
A43:    t5.a()=Comput(ProgramPart(t2),t2,m2).a() by A38,SCMPDS_4:23
          .=(Result(ProgramPart(t2),t2)).a() by A26,EXTPRO_1:23
          .=s().a() by A9,A13,A28,A12,FUNCT_4:12;
T1: ProgramPart t4 = ProgramPart t3
by AMI_1:123;
A44:    t7.a()=t6.a() by A36,SCMPDS_2:66
          .=s().a() by A43,T1,EXTPRO_1:5;
        then
A45:    WHL is_closed_on t7 by A6,A29,A40,A41;
        now
          let k be Element of NAT;
          per cases;
          suppose
            k < m3+1;
            then
A46:        k <= m3 by INT_1:20;
            hereby
              per cases by A46,NAT_1:8;
              suppose
A47:            k <= m2;
                hereby
                  per cases;
                  suppose
                    k=0;
                    hence IC Comput(ProgramPart(t3),t3,k) in dom pWH by A14,A19
,EXTPRO_1:3;
                  end;
                  suppose
                    k<>0;
                    then consider kn be Nat such that
A48:                k=kn+1 by NAT_1:6;
                    reconsider kn as Element of NAT by ORDINAL1:def 13;
                    reconsider lm = IC Comput(ProgramPart(t2),t2,kn) as Element
of NAT;
t: ProgramPart t3 = ProgramPart t4
by AMI_1:123;
                    kn < k by A48,XREAL_1:31;
                    then kn < m2 by A47,XXREAL_0:2;
                    then IC Comput(ProgramPart(t2),t2,kn) + 2 = IC Comput(
ProgramPart(t4),t4,kn) by A1,A18,A27,A31,A32,A25,A22,SCMPDS_7:34;
                    then
A49:                IC Comput(ProgramPart(t3),t3,k) = (lm+2) by A48,t,
EXTPRO_1:5;
                    IC Comput(ProgramPart(t2),t2,kn) in dom pI by A30,
SCMPDS_6:def 2;
                    then lm < card pI by AFINSQ_1:70;
                    then lm < card I()+1 by SCMPDS_5:7;
                    then
A50:                lm+2 < card I() +1+2 by XREAL_1:8;
                    card I() + 3 < card I() + 4 by XREAL_1:8;
                    then lm+2 < card I() +4 by A50,XXREAL_0:2;
                    then lm+2 < card pWH by Lm9;
                    hence IC Comput(ProgramPart(t3),t3,k) in dom pWH by A49,
AFINSQ_1:70;
                  end;
                end;
              end;
              suppose
A51:            k=m3;
                l2 in dom pWH by A20,SCMPDS_6:18;
                hence
                IC Comput(ProgramPart(t3),t3,k) in dom pWH by A1,A18,A27,A31
,A32,A25,A22,A34,A51,SCMPDS_7:36;
              end;
            end;
          end;
          suppose
            k >= m3+1;
            then consider nn be Nat such that
A52:        k=m3+1+nn by NAT_1:10;
            reconsider nn as Element of NAT by ORDINAL1:def 13;
 ProgramPart t3 = ProgramPart t7
by AMI_1:123;
       then
            Comput(ProgramPart(t3),t3,k)=
            Comput(ProgramPart(Initialize t7+*pWH),Initialize t7+*pWH,nn
) by A37,A52,EXTPRO_1:5;
            hence IC Comput(ProgramPart(t3),t3,k) in dom pWH by A45,
SCMPDS_6:def 2;
          end;
        end;
        hence WHL is_closed_on t by SCMPDS_6:def 2;
        WHL is_halting_on t7 by A6,A29,A44,A40,A41;
        then ProgramPart t7 halts_on t7 by A37,SCMPDS_6:def 3;
        then ProgramPart t3 halts_on t7 by AMI_1:123;
        then ProgramPart t3 halts_on t3 by EXTPRO_1:22;
        hence WHL is_halting_on t by SCMPDS_6:def 3;
      end;
    end;
    hence thesis;
  end;
  set n=F(Dstate s());
A53: Q[0]
  proof
    let t be State of SCMPDS;
    assume that
A54: F(Dstate t) <= 0 & P[Dstate t] and
A55: t.a()=s().a();
    F(Dstate t) >= 0 by NAT_1:2;
    then t.b = 0 by A2,A54,XXREAL_0:1;
    hence thesis by A55,Th16;
  end;
  for k being Element of NAT holds Q[k] from NAT_1:sch 1(A53,A5);
  then Q[n];
  hence thesis by A3;
end;

scheme
  WhileNExec { F(State of SCMPDS)-> Element of NAT, s() -> State of SCMPDS,I()
-> halt-free shiftable Program of SCMPDS, a() -> Int_position,i() -> Integer,
P[set]}: IExec(while<>0(a(),i(),I()),s()) = IExec(while<>0(a(),i(),I()),IExec(I
  (),s()))
provided
A1: card I() > 0 and
A2: s().DataLoc(s().a(),i()) <> 0 and
A3: for t be State of SCMPDS st P[Dstate t] & F(Dstate(t))=0 holds t.
DataLoc(s().a(),i()) = 0 and
A4: P[Dstate s()] and
A5: for t be State of SCMPDS st P[Dstate t] & t.a()=s().a() & t.DataLoc(
s().a(),i()) <> 0 holds IExec(I(),t).a()=t.a() & I() is_closed_on t & I()
is_halting_on t & F(Dstate IExec(I(),t)) < F(Dstate t) & P[Dstate(IExec(I(),t))
]
proof
  set WHL=while<>0(a(),i(),I()),
  s1= Initialize s() +* stop WHL,
  ps= ProgramPart s();
I1: s1= s() +* Initialize stop WHL by COMPOS_1:125;
  set sI= Initialize s() +* stop I(),
    m1=LifeSpan(ProgramPart(sI),sI)+2,
    s2=Initialize IExec(I(),s()) +*stop WHL,
    m2=LifeSpan(ProgramPart s2,s2);
I2: sI= s() +* Initialize stop I() by COMPOS_1:125;
I3: s2=IExec(I(),s()) +*Initialize stop WHL by COMPOS_1:125;
A6: Initialize stop I() c= sI by I2,FUNCT_4:26;
  I() is_closed_on s() by A2,A4,A5;
  then
A7: I() is_closed_on sI by SCMPDS_6:38;
  I() is_halting_on s() by A2,A4,A5;
  then
A8: ProgramPart sI halts_on sI by SCMPDS_6:def 3;
I4: Initialize sI+*stop I() =  sI+*Initialize stop I() by COMPOS_1:125;
  sI = Initialize sI+*stop I() by A6,I4,FUNCT_4:79;
  then ProgramPart(Initialize sI+*stop I()) halts_on
   Initialize sI+*stop I() by A8;
  then
A9: I() is_halting_on sI by SCMPDS_6:def 3;
  set s4 = Comput(ProgramPart(s1),s1,1);
  set i1=(a(),i())<>0_goto 2, i2=goto (card I()+2), i3=goto -(card I()+2);
  set b=DataLoc(s().a(),i());
A10: IC s1 = 0 by SCMPDS_6:21;
  set mI=LifeSpan(ProgramPart(sI),sI), s5=Comput(ProgramPart(s4),s4,mI), l2= (
card I() + 2);
A11: WHL = i1 ';' (i2 ';' I() ';' i3) by Lm10;
  set m3=mI +1;
  set s6=Comput(ProgramPart(s1),s1,m3);
  card I() + 2 < card I() + 3 by XREAL_1:8;
  then
A12: l2 in dom WHL by Th13;
  set s7=Comput(ProgramPart(s1),s1,m3+1);
A13: IExec(I(),s()) = Result(ProgramPart(sI),sI) +* s() | A
 by SCMPDS_4:def 8;
A14: dom ProgramPart s() = A by COMPOS_1:34;
  WHL c= Initialize stop WHL & Initialize stop WHL c= s1
     by I1,FUNCT_4:26,SCMPDS_6:17;
  then
A15: WHL c= s1 by XBOOLE_1:1;
  deffunc F(State of SCMPDS) = F($1);
A16: for t be State of SCMPDS st P[Dstate t] & F(Dstate(t))=0 holds t.DataLoc
  (s().a(),i()) = 0 by A3;
A17: for t be State of SCMPDS st P[Dstate t] & t.a()=s().a() & t.DataLoc(s().
  a(),i()) <> 0 holds IExec(I(),t).a()=t.a() & I() is_closed_on t & I()
is_halting_on t & F(Dstate IExec(I(),t)) < F(Dstate t) & P[Dstate(IExec(I(),t))
  ] by A5;
A18: Comput(ProgramPart(s1),s1,0+1) = Following(ProgramPart s1,
Comput(ProgramPart(s1),s1,0)) by EXTPRO_1:4
    .= Following(ProgramPart s1,s1) by EXTPRO_1:3
    .= Exec(i1,s1) by A11,I1,SCMPDS_6:22;
  Shift(I(),2) c= WHL by Lm11;
  then Shift(I(),2) c= s1 by A15,XBOOLE_1:1;
  then
A19: Shift(I(),2) c= s4 by AMI_1:81;
A20: DataPart sI = DataPart s1 by COMPOS_1:138,FUNCT_7:134;
  now
    let a;
    thus sI.a = s1.a by A20,SCMPDS_4:23
      .= s4.a by A18,SCMPDS_2:67;
  end;
  then
A21: DataPart sI = DataPart s4 by SCMPDS_4:23;
  s1.DataLoc(s1.a(),i())=s1.b by SCMPDS_5:19
    .= s().b by SCMPDS_5:19;
  then
A22: IC s4 = ICplusConst(s1,2) by A2,A18,SCMPDS_2:67
    .= (0+2) by A10,SCMPDS_6:23;
  then
A23: IC s5=l2 by A1,A6,A9,A7,A21,A19,SCMPDS_7:36;
Y:  (ProgramPart s6)/.IC s6
 = s6.IC s6 by COMPOS_1:38;
 ProgramPart s1 = ProgramPart s4
by AMI_1:123;
 then
A24: s6=s5 by EXTPRO_1:5;
  then
A25: CurInstr(ProgramPart s6,s6)=s5.l2 by A1,A6,A9,A7,A22,A21,A19,Y,SCMPDS_7:36
    .=s4.l2 by AMI_1:54
    .=s1.l2 by AMI_1:54
    .=WHL.l2 by A12,A15,GRFUNC_1:8
    .=i3 by Th15;
T: ProgramPart s1 = ProgramPart s6
by AMI_1:123;
A26: s7 = Following(ProgramPart s1,s6) by EXTPRO_1:4
    .= Exec(i3,s6) by A25,T;
  then IC s7=ICplusConst(s6,0-(card I()+2)) by SCMPDS_2:66
    .= 0 by A23,A24,SCMPDS_7:1;
  then
A27: IC s2 =IC Comput(ProgramPart(s1),s1,m1) by SCMPDS_6:21;
A28: DataPart Comput(ProgramPart(sI),sI,mI) = DataPart s5 by A1,A6,A9,A7,A22
,A21,A19,SCMPDS_7:36;
  now
    let x be Int_position;
A29: not x in dom Initialize stop WHL by SCMPDS_4:31;
A30: not x in dom (s() | A) by A14,SCMPDS_2:53;
    s5.x=Comput(ProgramPart(sI),sI,mI).x by A28,SCMPDS_4:23
      .=(Result(ProgramPart(sI),sI)).x by A8,EXTPRO_1:23
      .=IExec(I(),s()).x by A13,A30,FUNCT_4:12;
    hence s7.x=IExec(I(),s()).x by A24,A26,SCMPDS_2:66
      .=s2.x by A29,I3,FUNCT_4:12;
  end;
  then
A31: DataPart s7 = DataPart s2 by SCMPDS_4:23;
  set m0=LifeSpan(ProgramPart(s1),s1);
A32: dom ps = dom s() /\ A by RELAT_1:90
    .= ({IC SCMPDS} \/ D \/ A) /\ A by SCMPDS_4:19
    .= A by XBOOLE_1:21;
A33: IExec(I(),s()) | A= (Result(ProgramPart(sI),sI) +* ps) | A by
SCMPDS_4:def 8
    .= ps by A32,FUNCT_4:24;
A34: P[Dstate s()] by A4;
  WHL is_closed_on s() & WHL is_halting_on s() from WhileNHalt(A1,A16, A34,
  A17);
  then
A35: ProgramPart s1 halts_on s1 by SCMPDS_6:def 3;
  deffunc F(State of SCMPDS) = F($1);
  set Es=IExec(I(),s()), bj=DataLoc(Es.a(),i());
A36: IExec(I(), s()).a()=s().a() by A2,A4,A5;
  then
A37: for t be State of SCMPDS st P[Dstate t] & F(Dstate(t))=0 holds t.bj = 0
  by A3;
A38: for t being State of SCMPDS st P[Dstate t] & t.a()=Es.a() & t.bj <> 0
  holds IExec(I(),t).a()=t.a() & I() is_closed_on t & I() is_halting_on t & F(
  Dstate IExec(I(),t)) < F(Dstate t) & P[Dstate(IExec(I(),t))] by A5,A36;
A39: P[Dstate Es] by A2,A4,A5;
  WHL is_closed_on Es & WHL is_halting_on Es from WhileNHalt(A1,A37,A39,
  A38);
  then
A40: ProgramPart s2 halts_on s2 by SCMPDS_6:def 3;
NX: ProgramPart s1 = ProgramPart Comput(ProgramPart(s1),s1,m1)
by AMI_1:123;
  ProgramPart s2
     = ProgramPart(Result(ProgramPart(sI),sI) +* ps +* Initialize stop WHL)
      by I3,SCMPDS_4:def 8
    .= ProgramPart (Result(ProgramPart(sI),sI) +* ps)+*
          ProgramPart Initialize stop WHL
         by FUNCT_4:75
    .= ps +* ProgramPart Initialize stop WHL by A32,FUNCT_4:24
    .= ProgramPart s1 by I1,FUNCT_4:75
    .= ProgramPart Comput(ProgramPart(s1),s1,m1) by AMI_1:123;
  then
A41: Comput(ProgramPart(s1),s1,m1)=s2 by A31,A27,SCMPDS_7:7;
  then CurInstr(ProgramPart (s1),Comput(ProgramPart(s1),s1,m1))
  =i1 by A11,NX,I3,SCMPDS_6:22;
  then m0 > m1 by A35,SCMPDS_6:2,29;
  then consider nn be Nat such that
A42: m0=m1+nn by NAT_1:10;
  reconsider nn as Element of NAT by ORDINAL1:def 13;
T: ProgramPart s1 = ProgramPart s2
by A41,AMI_1:123;
 then
  Comput(ProgramPart(s1),s1,m1+m2) = Comput(ProgramPart(s2),s2,m2) by A41,
EXTPRO_1:5;
  then CurInstr(ProgramPart (s1),Comput(ProgramPart(s1),s1,m1+m2))
   = halt SCMPDS by A40,T,EXTPRO_1:def 14;
  then m1 + m2 >= m0 by A35,EXTPRO_1:def 14;
  then
A43: m2 >= nn by A42,XREAL_1:8;
A44: Comput(ProgramPart(s1),s1,m0) = Comput(ProgramPart(s2),s2,nn) by A41,A42,T
,EXTPRO_1:5;
  then CurInstr(ProgramPart (s2),Comput(ProgramPart(s2),s2,nn))
   =halt SCMPDS by A35,T,EXTPRO_1:def 14;
  then nn >= m2 by A40,EXTPRO_1:def 14;
  then nn=m2 by A43,XXREAL_0:1;
  then Result(ProgramPart(s1),s1) = Comput(ProgramPart(s2),s2,m2) by A35,A44,
EXTPRO_1:23;
  hence IExec(WHL,s()) = Comput(ProgramPart(s2),s2,m2) +* ps
   by SCMPDS_4:def 8
    .= Result(ProgramPart(s2),s2) +* IExec(I(),s()) | A by A40,A33,EXTPRO_1:23
    .= IExec(WHL,IExec(I(),s())) by SCMPDS_4:def 8;
end;

scheme
  WhileNEnd { F(State of SCMPDS)-> Element of NAT, s() -> State of SCMPDS,I()
-> halt-free shiftable Program of SCMPDS, a() -> Int_position,i() -> Integer,
P[set]}: F(Dstate IExec(while<>0(a(),i(),I()),s()))=0 & P[Dstate IExec(while<>0
  (a(),i(),I()),s())]
provided
A1: card I() > 0 and
A2: for t be State of SCMPDS st P[Dstate t] holds F(Dstate(t))=0 iff t.
DataLoc(s().a(),i()) = 0 and
A3: P[Dstate s()] and
A4: for t be State of SCMPDS st P[Dstate t] & t.a()=s().a() & t.DataLoc(
s().a(),i()) <> 0 holds IExec(I(),t).a()=t.a() & I() is_closed_on t & I()
is_halting_on t & F(Dstate IExec(I(),t)) < F(Dstate t) & P[Dstate(IExec(I(),t))
]
proof
  set b=DataLoc(s().a(),i()), WHL=while<>0(a(),i(),I());
  defpred Q[Element of NAT] means for t be State of SCMPDS st F(Dstate t) <=
  $1 & t.a()=s().a() & P[Dstate t] holds F(Dstate IExec(WHL,t))=0 & P[Dstate
  IExec(WHL,t)];
A5: Q[0]
  proof
    let t be State of SCMPDS;
    assume that
A6: F(Dstate t) <= 0 and
A7: t.a()=s().a() and
A8: P[Dstate t];
    F(Dstate t) >= 0 by NAT_1:2;
    then
A9: F(Dstate t)=0 by A6,XXREAL_0:1;
    then t.DataLoc(t.a(),i()) = 0 by A2,A7,A8;
    then for b be Int_position holds IExec(WHL,t).b = t.b by Th19;
    hence thesis by A8,A9,SCPISORT:5;
  end;
A10: now
    let k be Element of NAT;
    assume
A11: Q[k];
    now
      let u be State of SCMPDS;
      assume that
A12:  F(Dstate u) <= k+1 and
A13:  u.a()=s().a() and
A14:  P[Dstate u];
      per cases;
      suppose
        F(Dstate u)=0;
        hence F(Dstate IExec(WHL,u))=0 & P[Dstate IExec(WHL,u)] by A5,A13,A14;
      end;
      suppose
A15:    F(Dstate u) <> 0;
        set Iu=IExec(I(),u);
A16:    u.b <> 0 by A2,A14,A15;
        then
A17:    Iu.a()=s().a() & P[Dstate Iu] by A4,A13,A14;
        deffunc F(State of SCMPDS) = F($1);
A18:    P[Dstate u] by A14;
A19:    for t be State of SCMPDS st P[Dstate t] & F(Dstate t)=0 holds t.
        DataLoc(u.a(),i()) = 0 by A2,A13;
        F(Dstate Iu) < F(Dstate u) by A4,A13,A14,A16;
        then F(Dstate Iu)+1 <= F(Dstate u) by INT_1:20;
        then F(Dstate Iu)+1 <= k+1 by A12,XXREAL_0:2;
        then
A20:    F(Dstate Iu) <= k by XREAL_1:8;
A21:    for t being State of SCMPDS st P[Dstate t] & t.a()=u.a() & t.
DataLoc(u.a(),i()) <> 0 holds IExec(I(),t).a()=t.a() & I() is_closed_on t & I()
is_halting_on t & F(Dstate IExec(I(),t)) < F(Dstate t) & P[Dstate(IExec(I(),t))
        ] by A4,A13;
A22:    u.DataLoc(u.a(),i()) <> 0 by A2,A13,A14,A15;
        IExec(WHL,u) = IExec(WHL,Iu) from WhileNExec(A1,A22,A19,A18,A21 );
        hence F(Dstate IExec(WHL,u))=0 & P[Dstate IExec(WHL,u)] by A11,A20,A17;
      end;
    end;
    hence Q[k+1];
  end;
  for k being Element of NAT holds Q[k] from NAT_1:sch 1(A5,A10);
  then Q[F(Dstate s())];
  hence thesis by A3;
end;

theorem Th20:
  for s being State of SCMPDS,I being halt-free shiftable
Program of SCMPDS, a,b,c be Int_position,i,d be Integer st card I > 0 & s.a=d &
s.b > 0 & s.c > 0 & s.DataLoc(d,i)=s.b-s.c & (for t be State of SCMPDS st t.b >
0 & t.c > 0 & t.a=d & t.DataLoc(d,i)=t.b-t.c & t.b<>t.c holds IExec(I,t).a=d &
I is_closed_on t & I is_halting_on t & (t.b > t.c implies IExec(I,t).b=t.b-t.c
& IExec(I,t).c = t.c) & (t.b <= t.c implies IExec(I,t).c = t.c-t.b & IExec(I,t)
.b=t.b) & IExec(I,t).DataLoc(d,i)=IExec(I,t).b-IExec(I,t).c) holds while<>0(a,i
  ,I) is_closed_on s & while<>0(a,i,I) is_halting_on s & (s.DataLoc(s.a,i) <> 0
  implies IExec(while<>0(a,i,I),s) =IExec(while<>0(a,i,I),IExec(I,s)))
proof
  let s be State of SCMPDS,I be halt-free shiftable Program of SCMPDS, a,b,c
  be Int_position, i,d be Integer;
  set ci=DataLoc(s.a,i);
  assume
A1: card I > 0;
  consider f be Function of product the Object-Kind of SCMPDS,NAT such that
A2: for s be State of SCMPDS holds (s.b = s.c implies f.s =0) & (s.b <>
  s.c implies f.s=max(abs(s.b),abs(s.c))) by Th6;
  deffunc F(State of SCMPDS) = f.$1;
  defpred P[set] means ex t be State of SCMPDS st t=$1 & t.b > 0 & t.c > 0 & t
  .DataLoc(d,i)=t.b-t.c;
  assume that
A3: s.a=d and
A4: s.b > 0 and
A5: s.c > 0 and
A6: s.DataLoc(d,i)=s.b-s.c;
  assume
A7: for t be State of SCMPDS st t.b > 0 & t.c > 0 & t.a=d & t.DataLoc(d,
i)=t.b-t.c & t.b<>t.c holds IExec(I,t).a=d & I is_closed_on t & I is_halting_on
t & (t.b > t.c implies IExec(I,t).b=t.b-t.c & IExec(I,t).c = t.c) & (t.b <= t.c
  implies IExec(I,t).c = t.c-t.b & IExec(I,t).b=t.b) & IExec(I,t).DataLoc(d,i)=
  IExec(I,t).b-IExec(I,t).c;
A8: now
    let t be State of SCMPDS;
    assume that
A9: P[Dstate t] and
A10: t.a=s.a and
A11: t.ci <> 0;
    set It=IExec(I,t), t2=Dstate It, t1=Dstate t;
    set x=IExec(I,t).b, y=IExec(I,t).c;
    consider v be State of SCMPDS such that
A12: v=Dstate t and
A13: v.b > 0 and
A14: v.c > 0 and
A15: v.DataLoc(d,i)=v.b-v.c by A9;
A16: t.b > 0 by A12,A13,SCMPDS_8:4;
A17: t.c > 0 by A12,A14,SCMPDS_8:4;
A18: t.DataLoc(d,i)=v.b-v.c by A12,A15,SCMPDS_8:4
      .=t.b-v.c by A12,SCMPDS_8:4
      .=t.b-t.c by A12,SCMPDS_8:4;
    then
A19: t.b<>t.c by A3,A11;
    hence IExec(I,t).a=t.a by A3,A7,A10,A16,A17,A18;
    thus I is_closed_on t & I is_halting_on t by A3,A7,A10,A16,A17,A18,A19;
A20: now
      per cases;
      suppose
A21:    t.b > t.c;
        then t.b-t.c > 0 by XREAL_1:52;
        hence x > 0 by A3,A7,A10,A16,A17,A18,A21;
        thus y > 0 by A3,A7,A10,A16,A17,A18,A21;
A22:    x=t.b-t.c by A3,A7,A10,A16,A17,A18,A21;
        hereby
A23:      max(t.b,t.c)=t.b by A21,XXREAL_0:def 10;
          per cases by XXREAL_0:16;
          suppose
            max(x,y) = x;
            hence max(x,y) < max(t.b,t.c) by A17,A22,A23,XREAL_1:46;
          end;
          suppose
            max(x,y) = y;
            hence max(x,y) < max(t.b,t.c) by A3,A7,A10,A16,A17,A18,A21,A23;
          end;
        end;
      end;
      suppose
A24:    t.b <= t.c;
        hence x > 0 by A3,A7,A10,A16,A17,A18,A19;
        t.b < t.c by A19,A24,XXREAL_0:1;
        then t.c-t.b > 0 by XREAL_1:52;
        hence y > 0 by A3,A7,A10,A16,A17,A18,A19,A24;
A25:    y=t.c-t.b by A3,A7,A10,A16,A17,A18,A19,A24;
A26:    x=t.b by A3,A7,A10,A16,A17,A18,A19,A24;
        hereby
A27:      max(t.b,t.c)=t.c by A24,XXREAL_0:def 10;
          per cases by XXREAL_0:16;
          suppose
            max(x,y) = y;
            hence max(x,y) < max(t.b,t.c) by A16,A25,A27,XREAL_1:46;
          end;
          suppose
            max(x,y) = x;
            hence max(x,y) < max(t.b,t.c) by A19,A24,A26,A27,XXREAL_0:1;
          end;
        end;
      end;
    end;
    thus F(t2) < F(t1)
    proof
      t1.b <> t.c by A19,SCMPDS_8:4;
      then t1.b <> t1.c by SCMPDS_8:4;
      then
A28:  F(t1)=max(abs(t1.b),abs(t1.c)) by A2
        .=max(abs(t.b),abs(t1.c)) by SCMPDS_8:4
        .=max(abs(t.b),abs(t.c)) by SCMPDS_8:4
        .=max( t.b,abs(t.c)) by A16,ABSVALUE:def 1
        .=max(t.b,t.c) by A17,ABSVALUE:def 1;
      then F(t1) >= t.b by XXREAL_0:25;
      then
A29:  F(t1) > 0 by A16,XXREAL_0:2;
      per cases;
      suppose
        t2.b=t2.c;
        hence thesis by A2,A29;
      end;
      suppose
        t2.b<>t2.c;
        then F(t2)=max(abs(t2.b),abs(t2.c)) by A2
          .=max(abs(x),abs(t2.c)) by SCMPDS_8:4
          .=max(abs(x),abs(y)) by SCMPDS_8:4
          .=max( x,abs(y)) by A20,ABSVALUE:def 1
          .=max(x,y) by A20,ABSVALUE:def 1;
        hence thesis by A20,A28;
      end;
    end;
A30: IExec(I,t).DataLoc(d,i)=IExec(I,t).b-IExec(I,t).c by A3,A7,A10,A16,A17,A18
,A19;
    thus P[Dstate It]
    proof
      take v=Dstate It;
      thus v=Dstate It;
      thus v.b > 0 & v.c > 0 by A20,SCMPDS_8:4;
      thus v.DataLoc(d,i)=x-y by A30,SCMPDS_8:4
        .=v.b-y by SCMPDS_8:4
        .=v.b-v.c by SCMPDS_8:4;
    end;
  end;
A31: for t be State of SCMPDS st P[Dstate t] & F(Dstate t)=0 holds t.ci = 0
  proof
    let t be State of SCMPDS;
    assume that
A32: P[Dstate t] and
A33: F(Dstate t)=0;
    consider v be State of SCMPDS such that
A34: v=Dstate t and
A35: v.b > 0 and
    v.c > 0 and
A36: v.DataLoc(d,i)=v.b-v.c by A32;
A37: now
      assume t.b <> t.c;
      then (Dstate t).b <> t.c by SCMPDS_8:4;
      then (Dstate t).b <> (Dstate t).c by SCMPDS_8:4;
      then
A38:  F(Dstate t)=max(abs((Dstate t).b),abs((Dstate t).c)) by A2
        .=max(abs(t.b),abs((Dstate t).c)) by SCMPDS_8:4
        .=max(abs(t.b),abs(t.c)) by SCMPDS_8:4;
      t.b > 0 by A34,A35,SCMPDS_8:4;
      then abs(t.b) > 0 by COMPLEX1:133;
      hence contradiction by A33,A38,XXREAL_0:25;
    end;
    thus t.ci=v.b-v.c by A3,A34,A36,SCMPDS_8:4
      .=t.b-v.c by A34,SCMPDS_8:4
      .=t.b-t.c by A34,SCMPDS_8:4
      .=0 by A37;
  end;
A39: P[Dstate s]
  proof
    take t=Dstate s;
    thus t=Dstate s;
    thus t.b > 0 by A4,SCMPDS_8:4;
    thus t.c > 0 by A5,SCMPDS_8:4;
    thus t.DataLoc(d,i)=s.b-s.c by A6,SCMPDS_8:4
      .=t.b-s.c by SCMPDS_8:4
      .=t.b-t.c by SCMPDS_8:4;
  end;
  while<>0(a,i,I) is_closed_on s & while<>0(a,i,I) is_halting_on s from
  WhileNHalt(A1,A31,A39,A8);
  hence while<>0(a,i,I) is_closed_on s & while<>0(a,i,I) is_halting_on s;
  assume
A40: s.DataLoc(s.a,i) <> 0;
  IExec(while<>0(a,i,I),s) =IExec(while<>0(a,i,I),IExec(I,s)) from
  WhileNExec(A1,A40,A31,A39,A8);
  hence thesis;
end;

begin :: An example: computing Greatest Common Divisor(Euclide algorithm)

::   by loop-invariant
:: gcd(x,y)     < x=(GBP,1) y=(GBP,2),(GBP,3)=x-y >
:: while x<>y do
:: if x>y then x=x-y else y=y-x

definition
  func GCD-Algorithm -> Program of SCMPDS equals
  (GBP:=0) ';' (GBP,3):=(GBP,1)
';' SubFrom(GBP,3,GBP,2) ';' while<>0(GBP,3, if>0(GBP,3,Load SubFrom(GBP,1,GBP,
2), Load SubFrom(GBP,2,GBP,1)) ';' (GBP,3):=(GBP,1) ';' SubFrom(GBP,3,GBP,2) );
  coherence;
end;

theorem Th21:
  for s being State of SCMPDS,I being halt-free shiftable
Program of SCMPDS, a,b,c be Int_position,i,d be Integer st card I > 0 & s.a=d &
s.b > 0 & s.c > 0 & s.DataLoc(d,i)=s.b-s.c & (for t be State of SCMPDS st t.b >
0 & t.c > 0 & t.a=d & t.DataLoc(d,i)=t.b-t.c & t.b<>t.c holds IExec(I,t).a=d &
I is_closed_on t & I is_halting_on t & (t.b > t.c implies IExec(I,t).b=t.b-t.c
& IExec(I,t).c = t.c) & (t.b <= t.c implies IExec(I,t).c = t.c-t.b & IExec(I,t)
  .b=t.b) & IExec(I,t).DataLoc(d,i)=IExec(I,t).b-IExec(I,t).c) holds IExec(
  while<>0(a,i,I),s).b = s.b gcd s.c & IExec(while<>0(a,i,I),s).c = s.b gcd s.c
proof
  let s be State of SCMPDS,I be halt-free shiftable Program of SCMPDS, a,b,c
  be Int_position, i,d be Integer;
  set ci=DataLoc(s.a,i);
  assume
A1: card I > 0;
  consider f be Function of product the Object-Kind of SCMPDS,NAT such that
A2: for s be State of SCMPDS holds (s.b = s.c implies f.s =0) & (s.b <>
  s.c implies f.s=max(abs(s.b),abs(s.c))) by Th6;
  deffunc F(State of SCMPDS) = f.$1;
  set s1=IExec(while<>0(a,i,I),s), ss=Dstate s1;
  defpred P[set] means ex t be State of SCMPDS st t=$1 & t.b > 0 & t.c > 0 & t
  .b gcd t.c =s.b gcd s.c & t.DataLoc(d,i)=t.b-t.c;
  assume that
A3: s.a=d and
A4: s.b > 0 and
A5: s.c > 0 and
A6: s.DataLoc(d,i)=s.b-s.c;
  assume
A7: for t be State of SCMPDS st t.b > 0 & t.c > 0 & t.a=d & t.DataLoc(d,
i)=t.b-t.c & t.b<>t.c holds IExec(I,t).a=d & I is_closed_on t & I is_halting_on
t & (t.b > t.c implies IExec(I,t).b=t.b-t.c & IExec(I,t).c = t.c) & (t.b <= t.c
  implies IExec(I,t).c = t.c-t.b & IExec(I,t).b=t.b) & IExec(I,t).DataLoc(d,i)=
  IExec(I,t).b-IExec(I,t).c;
A8: now
    let t be State of SCMPDS;
    assume that
A9: P[Dstate t] and
A10: t.a=s.a and
A11: t.ci <> 0;
    set It=IExec(I,t), t2=Dstate It, t1=Dstate t;
    set x=IExec(I,t).b, y=IExec(I,t).c;
    consider v be State of SCMPDS such that
A12: v=Dstate t and
A13: v.b > 0 and
A14: v.c > 0 and
A15: v.b gcd v.c =s.b gcd s.c and
A16: v.DataLoc(d,i)=v.b-v.c by A9;
A17: t.b > 0 by A12,A13,SCMPDS_8:4;
A18: t.c > 0 by A12,A14,SCMPDS_8:4;
A19: t.DataLoc(d,i)=v.b-v.c by A12,A16,SCMPDS_8:4
      .=t.b-v.c by A12,SCMPDS_8:4
      .=t.b-t.c by A12,SCMPDS_8:4;
    then
A20: t.b > t.c implies IExec(I,t).b=t.b-t.c & IExec(I,t).c = t.c by A3,A7,A10
,A17,A18;
A21: t.b<>t.c by A3,A11,A19;
    hence IExec(I,t).a=t.a by A3,A7,A10,A17,A18,A19;
    thus I is_closed_on t & I is_halting_on t by A3,A7,A10,A17,A18,A19,A21;
A22: t.b <= t.c implies IExec(I,t).c =t.c-t.b & IExec(I,t).b=t.b by A3,A7,A10
,A17,A18,A19,A21;
A23: now
      per cases;
      suppose
A24:    t.b > t.c;
        then t.b-t.c > 0 by XREAL_1:52;
        hence x > 0 by A3,A7,A10,A17,A18,A19,A24;
        thus y > 0 by A3,A7,A10,A17,A18,A19,A24;
        thus x gcd y = t.b gcd t.c by A17,A18,A20,A22,PREPOWER:111;
A25:    x=t.b-t.c by A3,A7,A10,A17,A18,A19,A24;
        hereby
A26:      max(t.b,t.c)=t.b by A24,XXREAL_0:def 10;
          per cases by XXREAL_0:16;
          suppose
            max(x,y) = x;
            hence max(x,y) < max(t.b,t.c) by A18,A25,A26,XREAL_1:46;
          end;
          suppose
            max(x,y) = y;
            hence max(x,y) < max(t.b,t.c) by A3,A7,A10,A17,A18,A19,A24,A26;
          end;
        end;
      end;
      suppose
A27:    t.b <= t.c;
        hence x > 0 by A3,A7,A10,A17,A18,A19,A21;
        t.b < t.c by A21,A27,XXREAL_0:1;
        then t.c-t.b > 0 by XREAL_1:52;
        hence y > 0 by A3,A7,A10,A17,A18,A19,A21,A27;
        thus x gcd y =t.b gcd t.c by A17,A18,A20,A22,PREPOWER:111;
A28:    y=t.c-t.b by A3,A7,A10,A17,A18,A19,A21,A27;
A29:    x=t.b by A3,A7,A10,A17,A18,A19,A21,A27;
        hereby
A30:      max(t.b,t.c)=t.c by A27,XXREAL_0:def 10;
          per cases by XXREAL_0:16;
          suppose
            max(x,y) = y;
            hence max(x,y) < max(t.b,t.c) by A17,A28,A30,XREAL_1:46;
          end;
          suppose
            max(x,y) = x;
            hence max(x,y) < max(t.b,t.c) by A21,A27,A29,A30,XXREAL_0:1;
          end;
        end;
      end;
    end;
    thus F(t2) < F(t1)
    proof
      t1.b <> t.c by A21,SCMPDS_8:4;
      then t1.b <> t1.c by SCMPDS_8:4;
      then
A31:  F(t1)=max(abs(t1.b),abs(t1.c)) by A2
        .=max(abs(t.b),abs(t1.c)) by SCMPDS_8:4
        .=max(abs(t.b),abs(t.c)) by SCMPDS_8:4
        .=max( t.b,abs(t.c)) by A17,ABSVALUE:def 1
        .=max(t.b,t.c) by A18,ABSVALUE:def 1;
      then F(t1) >= t.b by XXREAL_0:25;
      then
A32:  F(t1) > 0 by A17,XXREAL_0:2;
      per cases;
      suppose
        t2.b=t2.c;
        hence thesis by A2,A32;
      end;
      suppose
        t2.b<>t2.c;
        then F(t2)=max(abs(t2.b),abs(t2.c)) by A2
          .=max(abs(x),abs(t2.c)) by SCMPDS_8:4
          .=max(abs(x),abs(y)) by SCMPDS_8:4
          .=max( x,abs(y)) by A23,ABSVALUE:def 1
          .=max(x,y) by A23,ABSVALUE:def 1;
        hence thesis by A23,A31;
      end;
    end;
A33: IExec(I,t).DataLoc(d,i)=IExec(I,t).b-IExec(I,t).c by A3,A7,A10,A17,A18,A19
,A21;
    thus P[Dstate It]
    proof
      take u=Dstate It;
      thus u=Dstate It;
      thus u.b > 0 & u.c > 0 by A23,SCMPDS_8:4;
      thus u.b gcd u.c =It.b gcd u.c by SCMPDS_8:4
        .=t.b gcd t.c by A23,SCMPDS_8:4
        .=v.b gcd t.c by A12,SCMPDS_8:4
        .=s.b gcd s.c by A12,A15,SCMPDS_8:4;
      thus u.DataLoc(d,i)=x-y by A33,SCMPDS_8:4
        .=u.b-y by SCMPDS_8:4
        .=u.b-u.c by SCMPDS_8:4;
    end;
  end;
A34: for t be State of SCMPDS st P[Dstate t] holds F(Dstate t)=0 iff t.ci = 0
  proof
    let t be State of SCMPDS;
    assume P[Dstate t];
    then consider v be State of SCMPDS such that
A35: v=Dstate t and
A36: v.b > 0 and
    v.c > 0 and
    v.b gcd v.c =s.b gcd s.c and
A37: v.DataLoc(d,i)=v.b-v.c;
A38: t.ci=v.b-v.c by A3,A35,A37,SCMPDS_8:4
      .=t.b-v.c by A35,SCMPDS_8:4
      .=t.b-t.c by A35,SCMPDS_8:4;
    hereby
      assume
A39:  F(Dstate t)=0;
      now
        assume t.b <> t.c;
        then (Dstate t).b <> t.c by SCMPDS_8:4;
        then (Dstate t).b <> (Dstate t).c by SCMPDS_8:4;
        then
A40:    F(Dstate t)=max(abs((Dstate t).b),abs((Dstate t).c)) by A2
          .=max(abs(t.b),abs((Dstate t).c)) by SCMPDS_8:4
          .=max(abs(t.b),abs(t.c)) by SCMPDS_8:4;
        t.b > 0 by A35,A36,SCMPDS_8:4;
        then abs(t.b) > 0 by COMPLEX1:133;
        hence contradiction by A39,A40,XXREAL_0:25;
      end;
      hence t.ci=0 by A38;
    end;
    hereby
      assume t.ci=0;
      then (Dstate t).b = t.c by A38,SCMPDS_8:4;
      then (Dstate t).b = (Dstate t).c by SCMPDS_8:4;
      hence F(Dstate t)=0 by A2;
    end;
  end;
A41: P[Dstate s]
  proof
    take t=Dstate s;
    thus t=Dstate s;
    thus t.b > 0 by A4,SCMPDS_8:4;
    thus t.c > 0 by A5,SCMPDS_8:4;
    thus t.b gcd t.c = s.b gcd t.c by SCMPDS_8:4
      .=s.b gcd s.c by SCMPDS_8:4;
    thus t.DataLoc(d,i)=s.b-s.c by A6,SCMPDS_8:4
      .=t.b-s.c by SCMPDS_8:4
      .=t.b-t.c by SCMPDS_8:4;
  end;
A42: F(ss)=0 & P[ss] from WhileNEnd(A1,A34,A41,A8);
  then consider w be State of SCMPDS such that
A43: w=ss and
A44: w.b > 0 and
  w.c > 0 and
A45: w.b gcd w.c =s.b gcd s.c and
A46: w.DataLoc(d,i)=w.b-w.c;
A47: w.b-w.c =s1.ci by A3,A43,A46,SCMPDS_8:4
    .=0 by A34,A42;
  then
A48: abs(w.b)=abs(w.b) gcd abs(w.c) by NAT_D:32
    .=s.b gcd s.c by A45,INT_2:51;
  thus IExec(while<>0(a,i,I),s).b=ss.b by SCMPDS_8:4
    .=s.b gcd s.c by A43,A44,A48,ABSVALUE:def 1;
  thus IExec(while<>0(a,i,I),s).c =ss.c by SCMPDS_8:4
    .=s.b gcd s.c by A43,A44,A47,A48,ABSVALUE:def 1;
end;

set i1= GBP:=0, i2= (GBP,3):=(GBP,1), i3= SubFrom(GBP,3,GBP,2), j1= Load
SubFrom(GBP,1,GBP,2), j2= Load SubFrom(GBP,2,GBP,1), IF= if>0(GBP,3,j1,j2), k1=
(GBP,3):=(GBP,1), k2= SubFrom(GBP,3,GBP,2), WB= IF ';' k1 ';' k2, WH= while<>0(
GBP,3,WB);

Lm12: card WB=6
proof
  thus card WB=card (IF ';' k1)+1 by SCMP_GCD:8
    .=card IF +1+1 by SCMP_GCD:8
    .=card j1+card j2 +2+1+1 by SCMPDS_6:79
    .= 1+card j2 +2+1+1 by SCMPDS_5:6
    .= 1+1+2+1+1 by SCMPDS_5:6
    .=6;
end;

Lm13: card WH=9
proof
  thus card WH=6+3 by Lm12,Th12
    .=9;
end;

theorem
  card GCD-Algorithm=12
proof
  thus card GCD-Algorithm=card (i1 ';' i2 ';' i3) + card WH by AFINSQ_1:20
    .=card (i1 ';' i2) +1+ card WH by SCMP_GCD:8
    .=2+1+ 9 by Lm13,SCMP_GCD:9
    .=12;
end;

Lm14: for s being State of SCMPDS st s.GBP=0 holds (s.a3 > 0 implies IExec(WB,
s).a1=s.a1-s.a2 & IExec(WB,s).a2 = s.a2) & (s.a3 <= 0 implies IExec(WB,s).a2=s.
a2-s.a1 & IExec(WB,s).a1=s.a1) & IExec(WB,s).GBP=0 & IExec(WB,s).a3=IExec(WB,s)
.a1-IExec(WB,s).a2

proof
  let s be State of SCMPDS;
  set s1=IExec(IF,s), s2=IExec(IF ';' k1,s), a=GBP, t0 = Initialize s;
X1: s1=IExec(IF,t0) by SCMPDS_5:48;
Y1: IExec(WB,s)=IExec(WB,t0) by SCMPDS_5:48;
X2: s2=IExec(IF ';' k1,t0) by SCMPDS_5:48;
A1: now
    assume
A2: s1.GBP=0;
    then
A3: DataLoc(s1.a,3)=intpos (0+3) by SCMP_GCD:5;
A4: s2.a3 =Exec(k1, s1).a3 by X1,X2,SCMPDS_5:46
      .=s1.DataLoc(s1.a,1) by A3,SCMPDS_2:59
      .=s1.intpos (0+1) by A2,SCMP_GCD:5;
    1 <> abs(s1.GBP+3) by A2,ABSVALUE:def 1;
    then
A5: a1 <> DataLoc(s1.GBP,3) by ZFMISC_1:33;
A6: s2.a1 =Exec(k1, s1).a1 by X1,X2,SCMPDS_5:46
      .=s1.a1 by A5,SCMPDS_2:59;
    2 <> abs(s1.GBP+3) by A2,ABSVALUE:def 1;
    then
A7: a2 <> DataLoc(s1.GBP,3) by ZFMISC_1:33;
A8: s2.a2 =Exec(k1, s1).a2 by X1,X2,SCMPDS_5:46
      .=s1.a2 by A7,SCMPDS_2:59;
    0 <> abs(s1.GBP+3) by A2,ABSVALUE:def 1;
    then
A9: a <> DataLoc(s1.GBP,3) by ZFMISC_1:33;
A10: s2.a =Exec(k1, s1).a by X1,X2,SCMPDS_5:46
      .=0 by A2,A9,SCMPDS_2:59;
    then
A11: DataLoc(s2.a,3)=intpos (0+3) by SCMP_GCD:5;
    0 <> abs(s2.GBP+3) by A10,ABSVALUE:def 1;
    then
A12: a <> DataLoc(s2.GBP,3) by ZFMISC_1:33;
    thus IExec(WB,s).a =Exec(k2, s2).a by X2,Y1,SCMPDS_5:46
      .=0 by A10,A12,SCMPDS_2:62;
    1 <> abs(s2.GBP+3) by A10,ABSVALUE:def 1;
    then
A13: a1 <> DataLoc(s2.GBP,3) by ZFMISC_1:33;
    thus
A14: IExec(WB,s).a1 =Exec(k2, s2).a1 by X2,Y1,SCMPDS_5:46
      .=s1.a1 by A6,A13,SCMPDS_2:62;
    2 <> abs(s2.GBP+3) by A10,ABSVALUE:def 1;
    then
A15: a2 <> DataLoc(s2.GBP,3) by ZFMISC_1:33;
    thus
A16: IExec(WB,s).a2 =Exec(k2, s2).a2 by X2,Y1,SCMPDS_5:46
      .=s1.a2 by A8,A15,SCMPDS_2:62;
    thus IExec(WB,s).a3 =Exec(k2, s2).a3 by X2,Y1,SCMPDS_5:46
      .=s2.a3-s2.DataLoc(s2.a,2) by A11,SCMPDS_2:62
      .=IExec(WB,s).a1-IExec(WB,s).a2 by A10,A8,A4,A14,A16,SCMP_GCD:5;
  end;
  set s0=Initialize s, m1=SubFrom(GBP,1,GBP,2), m2=SubFrom(GBP,2,GBP,1);
  assume
A17: s.GBP=0;
  then
A18: s0.a=0 by SCMPDS_5:40;
A19: DataLoc(s.a,3)=intpos(0+3) by A17,SCMP_GCD:5;
A20: s0.a2=s.a2 by SCMPDS_5:40;
A21: now
    2 <> abs(s0.GBP+1) by A18,ABSVALUE:def 1;
    then
A22: a2 <> DataLoc(s0.GBP,1) by ZFMISC_1:33;
    0 <> abs(s0.GBP+1) by A18,ABSVALUE:def 1;
    then
A23: a <> DataLoc(s0.GBP,1) by ZFMISC_1:33;
    assume
A24: s.a3 > 0;
    hence s1.a=IExec(j1,s).a by A19,SCMPDS_6:87
      .=Exec(m1, s0).a by SCMPDS_5:45
      .=0 by A18,A23,SCMPDS_2:62;
A25: DataLoc(s0.a,1)=intpos (0+1) by A18,SCMP_GCD:5;
    thus s1.a1=IExec(j1,s).a1 by A19,A24,SCMPDS_6:87
      .=Exec(m1, s0).a1 by SCMPDS_5:45
      .=s0.a1-s0.DataLoc(s0.a,2) by A25,SCMPDS_2:62
      .=s0.a1-s0.intpos(0+2) by A18,SCMP_GCD:5
      .=s.a1-s.a2 by A20,SCMPDS_5:40;
    thus s1.a2=IExec(j1,s).a2 by A19,A24,SCMPDS_6:87
      .=Exec(m1, s0).a2 by SCMPDS_5:45
      .=s.a2 by A20,A22,SCMPDS_2:62;
  end;

  hence
  s.a3 > 0 implies IExec(WB,s).a1=s.a1-s.a2 & IExec(WB,s).a2 = s.a2 by A1;

A26: s0.a1=s.a1 by SCMPDS_5:40;
A27: now
    1 <> abs(s0.GBP+2) by A18,ABSVALUE:def 1;
    then
A28: a1 <> DataLoc(s0.GBP,2) by ZFMISC_1:33;
    0 <> abs(s0.GBP+2) by A18,ABSVALUE:def 1;
    then
A29: a <> DataLoc(s0.GBP,2) by ZFMISC_1:33;
    assume
A30: s.a3 <= 0;
    hence s1.a=IExec(j2,s).a by A19,SCMPDS_6:88
      .=Exec(m2, s0).a by SCMPDS_5:45
      .=0 by A18,A29,SCMPDS_2:62;
A31: DataLoc(s0.a,2)=intpos (0+2) by A18,SCMP_GCD:5;
    thus s1.a2=IExec(j2,s).a2 by A19,A30,SCMPDS_6:88
      .=Exec(m2, s0).a2 by SCMPDS_5:45
      .=s0.a2-s0.DataLoc(s0.a,1) by A31,SCMPDS_2:62
      .=s0.a2-s0.intpos(0+1) by A18,SCMP_GCD:5
      .=s.a2-s.a1 by A20,SCMPDS_5:40;
    thus s1.a1=IExec(j2,s).a1 by A19,A30,SCMPDS_6:88
      .=Exec(m2, s0).a1 by SCMPDS_5:45
      .=s.a1 by A26,A28,SCMPDS_2:62;
  end;

  hence s.a3 <= 0 implies IExec(WB,s).a2=s.a2-s.a1 & IExec(WB,s).a1 = s.a1 by
A1;

  now
    per cases;
    suppose
      s.a3 > 0;
      hence s1.a=0 by A21;
    end;
    suppose
      s.a3 <= 0;
      hence s1.a=0 by A27;
    end;
  end;
  hence thesis by A1;
end;

Lm15: for s being State of SCMPDS st s.GBP=0 & s.a1 > 0 & s.a2 > 0 & s.a3=s.a1
-s.a2 holds IExec(WH,s).a1 = s.a1 gcd s.a2 & IExec(WH,s).a2 = s.a1 gcd s.a2 &
WH is_closed_on s & WH is_halting_on s

proof
  set a=GBP;
  let s be State of SCMPDS;
A1: DataLoc(0,3)=intpos(0+3) by SCMP_GCD:5;
A2: now
    let t be State of SCMPDS;
    assume that
    t.a1 > 0 and
    t.a2 > 0 and
A3: t.a=0 and
A4: t.DataLoc(0,3)=t.a1-t.a2 and
    t.a1<>t.a2;
    thus IExec(WB,t).a=0 by A3,Lm14;
    thus WB is_closed_on t by SCMPDS_6:34;
    thus WB is_halting_on t by SCMPDS_6:35;
    hereby
      assume t.a1 > t.a2;
      then t.a3 > 0 by A1,A4,XREAL_1:52;
      hence IExec(WB,t).a1=t.a1-t.a2 & IExec(WB,t).a2 = t.a2 by A3,Lm14;
    end;
    hereby
      assume t.a1 <= t.a2;
      then t.a3 <= 0 by A1,A4,XREAL_1:49;
      hence IExec(WB,t).a2=t.a2-t.a1 & IExec(WB,t).a1 = t.a1 by A3,Lm14;
    end;
    thus IExec(WB,t).DataLoc(0,3)=IExec(WB,t).a1-IExec(WB,t).a2 by A1,A3,Lm14;
  end;
  assume
A5: s.a=0 & s.a1 > 0 & s.a2 > 0 & s.a3=s.a1-s.a2;

  hence IExec(WH,s).a1 = s.a1 gcd s.a2 & IExec(WH,s).a2 = s.a1 gcd s.a2 by A1
,A2,Lm12,Th21;

  thus thesis by A5,A1,A2,Lm12,Th20;
end;
set GA=i1 ';' i2 ';' i3 ';' WH;

Lm16: for s being State of SCMPDS st s.a1 > 0 & s.a2 > 0 holds IExec(GA,s).a1
= s.a1 gcd s.a2 & IExec(GA,s).a2 = s.a1 gcd s.a2 & GA is_closed_on s & GA
is_halting_on s

proof
  let s be State of SCMPDS;
  assume
A1: s.a1 > 0 & s.a2 > 0;

  set t0=Initialize s, t1=IExec(i1 ';' i2 ';' i3,s), t2=IExec(i1 ';' i2,s),
  t3=Exec(i1, t0), a=GBP;

X0: t0=Initialize t0;
X1: t1=IExec(i1 ';' i2 ';' i3,t0) by SCMPDS_5:48;
X2: t2=IExec(i1 ';' i2,t0) by SCMPDS_5:48;

A2: t3.a1=t0.a1 by AMI_3:52,SCMPDS_2:57
    .=s.a1 by SCMPDS_5:40;
A3: t3.a=0 by SCMPDS_2:57;
  then
A4: DataLoc(t3.a,3)=intpos (0+3) by SCMP_GCD:5;
  1 <> abs(t3.GBP+3) by A3,ABSVALUE:def 1;
  then
A5: a1 <> DataLoc(t3.GBP,3) by ZFMISC_1:33;
A6: t2.a1=Exec(i2,t3).a1 by X0,X2,SCMPDS_5:47
    .=s.a1 by A2,A5,SCMPDS_2:59;
A7: t3.a2=t0.a2 by AMI_3:52,SCMPDS_2:57
    .=s.a2 by SCMPDS_5:40;
A8: t2.a3=Exec(i2,t3).a3 by X0,X2,SCMPDS_5:47
    .=t3.DataLoc(t3.a,1) by A4,SCMPDS_2:59
    .=s.a1 by A3,A2,SCMP_GCD:5;
  2 <> abs(t3.GBP+3) by A3,ABSVALUE:def 1;
  then
A9: a2 <> DataLoc(t3.GBP,3) by ZFMISC_1:33;
A10: t2.a2=Exec(i2,t3).a2 by X0,X2,SCMPDS_5:47
    .=s.a2 by A7,A9,SCMPDS_2:59;
  0 <> abs(t3.GBP+3) by A3,ABSVALUE:def 1;
  then
A11: a <> DataLoc(t3.GBP,3) by ZFMISC_1:33;
A12: t2.a=Exec(i2,t3).a by X0,X2,SCMPDS_5:47
    .=0 by A3,A11,SCMPDS_2:59;
  then
A13: DataLoc(t2.a,3)=intpos (0+3) by SCMP_GCD:5;
  0 <> abs(t2.GBP+3) by A12,ABSVALUE:def 1;
  then
A14: a <> DataLoc(t2.GBP,3) by ZFMISC_1:33;
A15: t1.a=Exec(i3,t2).a by X1,X2,SCMPDS_5:46
    .=0 by A12,A14,SCMPDS_2:62;
  1 <> abs(t2.GBP+3) by A12,ABSVALUE:def 1;
  then
A16: a1 <> DataLoc(t2.GBP,3) by ZFMISC_1:33;
A17: t1.a1=Exec(i3,t2).a1 by X1,X2,SCMPDS_5:46
    .=s.a1 by A6,A16,SCMPDS_2:62;
  2 <> abs(t2.GBP+3) by A12,ABSVALUE:def 1;
  then
A18: a2 <> DataLoc(t2.GBP,3) by ZFMISC_1:33;
A19: t1.a2=Exec(i3,t2).a2 by X1,X2,SCMPDS_5:46
    .=s.a2 by A10,A18,SCMPDS_2:62;
A20: t1.a3=Exec(i3,t2).a3 by X1,X2,SCMPDS_5:46
    .=t2.a3-t2.DataLoc(t2.a,2) by A13,SCMPDS_2:62
    .=t1.a1-t1.a2 by A12,A10,A8,A17,A19,SCMP_GCD:5;
  then
A21: WH is_closed_on t1 & WH is_halting_on t1 by A1,A15,A17,A19,Lm15;
  IExec(WH,t1).a1 = t1.a1 gcd t1.a2 by A1,A15,A17,A19,A20,Lm15;
  hence IExec(GA,s).a1=s.a1 gcd s.a2 by A17,A19,A21,SCPISORT:8;
  IExec(WH,t1).a2 = t1.a1 gcd t1. a2 by A1,A15,A17,A19,A20,Lm15;
  hence IExec(GA,s).a2=s.a1 gcd s.a2 by A17,A19,A21,SCPISORT:8;
  thus thesis by A21,SCPISORT:10;
end;

theorem :: SCMP_GCD:18
  for s being State of SCMPDS,x, y being Integer st s.intpos 1 = x & s.
intpos 2 = y & x > 0 & y > 0 holds IExec(GCD-Algorithm,s).intpos 1 = x gcd y &
  IExec(GCD-Algorithm,s).intpos 2 = x gcd y & GCD-Algorithm is_closed_on s &
  GCD-Algorithm is_halting_on s by Lm16;

