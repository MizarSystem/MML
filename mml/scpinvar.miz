:: Justifying the Correctness of Fibonacci Sequence and Euclide
:: Algorithm by Loop Invariant
::  by JingChao Chen
::
:: Received June 14, 2000
:: Copyright (c) 2000-2011 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies NUMBERS, SUBSET_1, AMI_1, SCMPDS_2, TURING_1, FUNCT_1, CARD_1,
      SCMFSA_7, RELAT_1, ARYTM_3, CARD_3, FSM_1, XXREAL_0, COMPLEX1, ARYTM_1,
      AMI_2, SCMPDS_5, SCMPDS_4, INT_1, SCMPDS_8, SCMFSA6B, SCMFSA_9, UNIALG_2,
      SCMFSA7B, SCMP_GCD, SEMI_AF1, GRAPHSP, AMI_3, FINSEQ_1, SCPISORT, NAT_1,
      ORDINAL4, SFMASTR2, PRE_FF, FUNCT_4, CIRCUIT2, TARSKI, PBOOLE, MSUALG_1,
      STRUCT_0, VALUED_1, SCMFSA8B, INT_2, SCPINVAR, ORDINAL1, PARTFUN1,
      SCMNORM, SCMFSA6C, COMPOS_1;
 notations XBOOLE_0, SUBSET_1, CARD_1, NUMBERS, RELAT_1, FUNCT_1, PARTFUN1,
      VALUED_1, XCMPLX_0, FUNCT_4, PBOOLE, INT_1, INT_2, NAT_1, STRUCT_0,
      MEMSTR_0, COMPOS_1, EXTPRO_1, AMI_2, SCMPDS_2, SCMPDS_4, SCMPDS_6,
      SCMP_GCD, SCMPDS_5, SCMPDS_8, FUNCT_2, CARD_3, DOMAIN_1, FINSEQ_1,
      GR_CY_1, PRE_FF, SCPISORT, XXREAL_0;
 constructors DOMAIN_1, REAL_1, NAT_D, RECDEF_1, PRE_FF, MESFUNC1, GR_CY_1,
      SCM_1, SCMPDS_4, SCMPDS_5, SCMPDS_6, SCMP_GCD, SCMPDS_8, SCPISORT,
      BINOP_2, AMI_2, MEMSTR_0, RELSET_1;
 registrations SETFAM_1, FUNCT_1, ORDINAL1, RELSET_1, NUMBERS, XREAL_0, NAT_1,
      INT_1, CARD_3, STRUCT_0, SCMPDS_2, SCMPDS_4, SCMPDS_5, SCMPDS_6,
      SCMPDS_8, XBOOLE_0, FINSEQ_1, CARD_1, VALUED_1, VALUED_0, MEMSTR_0,
      RELAT_1, FUNCT_2, COMPOS_1, AFINSQ_1, EXTPRO_1, PBOOLE, FUNCT_4;
 requirements NUMERALS, REAL, SUBSET, ARITHM, BOOLE;
 definitions FUNCOP_1, COMPOS_1, EXTPRO_1, AMI_3, SCMPDS_2, SCMP_GCD, SCPISORT,
      MEMSTR_0;
 theorems AMI_3, NAT_1, TARSKI, FUNCT_4, INT_1, SCMPDS_2, ABSVALUE, GRFUNC_1,
      SCMPDS_4, SCMPDS_5, SCMPDS_6, ENUMSET1, INT_2, SCMPDS_8, SCMP_GCD,
      SCMPDS_7, FUNCT_1, FINSEQ_1, RVSUM_1, FINSEQ_2, MEMSTR_0, PRE_FF,
      SCPISORT, XBOOLE_1, XREAL_1, COMPLEX1, XXREAL_0, PREPOWER, ORDINAL1,
      FUNCOP_1, ZFMISC_1, NAT_D, FINSEQ_3, PBOOLE, PARTFUN1, AFINSQ_1,
      COMPOS_1, EXTPRO_1, CARD_3;
 schemes NAT_1, SCMPDS_8, FUNCT_2;

begin :: Preliminaries

reserve m,n for Element of NAT,
  i,j for Instruction of SCMPDS,
  I for Program
  of SCMPDS,
  a for Int_position;

theorem Th5:
  (i ';' j ';' I). 0=i & (i ';' j ';' I). 1=j
proof
  set jI=j ';' I;
A1: i ';' j ';' I =i ';' jI by SCMPDS_4:16
    .=Load i ';' jI by SCMPDS_4:def 2;
   0 in dom Load i by COMPOS_1:50;
  hence (i ';' j ';' I). 0 =(Load i). 0 by A1,AFINSQ_1:def 3
    .=i by COMPOS_1:52;
A2:  0 in dom Load j by COMPOS_1:50;
  card jI=card I+1 by SCMPDS_6:6;
  then 0 < card jI by NAT_1:5;
  then
A3: card Load i=1 &  0 in dom jI by AFINSQ_1:66,COMPOS_1:54;
  thus (i ';' j ';' I). 1 =(Load i ';' jI). (0+1) by A1
    .=jI. 0 by A3,AFINSQ_1:def 3
    .=(Load j ';' I). 0 by SCMPDS_4:def 2
    .=(Load j). 0 by A2,AFINSQ_1:def 3
    .=j by COMPOS_1:52;
end;

theorem Th6:
  for a,b be Int_position holds ex f be Function of product the
  Object-Kind of SCMPDS,NAT st for s being State of SCMPDS holds (s.a = s.b
  implies f.s =0) & (s.a <> s.b implies f.s=max(abs(s.a),abs(s.b)))
proof
  let a,b be Int_position;
  defpred P[set,set] means ex t be State of SCMPDS st t=$1 & (t.a = t.b
  implies $2 =0) & (t.a <> t.b implies $2=max(abs(t.a),abs(t.b)));
A1: now
    let s be Element of product the Object-Kind of SCMPDS;
    per cases;
    suppose
A2:   s.a = s.b;
      reconsider y=0 as Element of NAT;
      take y;
      thus P[s,y] by A2;
    end;
    suppose
A3:   s.a <> s.b;
      set mm=max(abs(s.a),abs(s.b));
      reconsider y=mm as Element of NAT by XXREAL_0:16;
      take y;
      thus P[s,y] by A3;
    end;
  end;
  consider f be Function of product the Object-Kind of SCMPDS, NAT such that
A4: for s be Element of product the Object-Kind of SCMPDS holds P[s,f.s]
       from FUNCT_2:sch 3(A1);
A5: for s being State of SCMPDS holds P[s,f.s]
   proof
    let s be State of SCMPDS;
    reconsider s as Element of product the Object-Kind of SCMPDS by CARD_3:107;
    P[s,f.s] by A4;
    hence thesis;
   end;
  take f;
  hereby
    let s be State of SCMPDS;
    P[s,f.s] by A5;
    hence
    (s.a = s.b implies f.s =0) & (s.a <> s.b implies f.s=max(abs(s.a),abs
    (s.b)));
  end;
end;

theorem Th7:
  ex f be Function of product the Object-Kind of SCMPDS,NAT
   st for s being State of SCMPDS holds (s.a >= 0 implies f.s =0) &
  (s.a < 0 implies f.s= -s.a)
proof
  defpred P[set,set] means ex t be State of SCMPDS st t=$1 & (t.a >= 0 implies
  $2 =0) & (t.a < 0 implies $2=-t.a);
A1: now
    let s be Element of product the Object-Kind of SCMPDS;
    per cases;
    suppose
A2:   s.a >= 0;
      reconsider y=0 as Element of NAT;
      take y;
      thus P[s,y] by A2;
    end;
    suppose
A3:   s.a < 0;
      then -s.a > 0 by XREAL_1:58;
      then reconsider y=-s.a as Element of NAT by INT_1:3;
      take y;
      thus P[s,y] by A3;
    end;
  end;
  consider f be Function of product the Object-Kind of SCMPDS,NAT such that
A4: for s be Element of product the Object-Kind of SCMPDS holds P[s,f.s]
      from FUNCT_2:sch 3(A1);
A5: for s being State of SCMPDS holds P[s,f.s]
   proof
    let s be State of SCMPDS;
    reconsider s as Element of product the Object-Kind of SCMPDS by CARD_3:107;
    P[s,f.s] by A4;
    hence thesis;
   end;
  take f;
  hereby
    let s be State of SCMPDS;
    P[s,f.s] by A5;
    hence (s.a >= 0 implies f.s =0) & (s.a < 0 implies f.s=-s.a);
  end;
end;
set A = NAT, D = SCM-Data-Loc;

begin :: Computing directly the result of "while<0" program by loop-invariant

reserve Q,U,P for Instruction-Sequence of SCMPDS;

scheme
  WhileLEnd { F(State of SCMPDS)-> Element of NAT,
  s() -> 0-started State of SCMPDS,
  P() -> Instruction-Sequence of SCMPDS,
  I() -> halt-free shiftable Program of SCMPDS,
  a() -> Int_position,i() -> Integer,
P[set]}: F(Initialize IExec(while<0(a(),i(),I()),P(),s()))=0
 & P[Initialize IExec(while<0(a(),i(),I()),P(),s())]
provided
A2: for t be 0-started State of SCMPDS st P[t] holds F(t)=0
   iff t.DataLoc(s().a(),i()) >= 0 and
A3: P[s()] and
A4: for t be 0-started State of SCMPDS,Q st P[t] & t.a()=s().a() &
   t.DataLoc(s().a(),i()) < 0
 holds IExec(I(),Q,t).a()=t.a() & I() is_closed_on t,Q & I()
is_halting_on t,Q & F(Initialize IExec(I(),Q,t)) < F(t)
 & P[Initialize(IExec(I(),Q,t))]
proof
  set b=DataLoc(s().a(),i()), WHL=while<0(a(),i(),I());
  defpred Q[Element of NAT] means
  for t be 0-started State of SCMPDS, Q st F(t) <= $1 & t.a()=s().a() & P[t]
   holds F(Initialize IExec(WHL,Q,t))=0 & P[Initialize IExec(WHL,Q,t)];
A5: Q[0]
  proof
    let t be 0-started State of SCMPDS, Q;
T: Initialize t = t by MEMSTR_0:44;
    assume that
A6: F(t) <= 0 and
A7: t.a()=s().a() and
A8: P[t];
    F(t) >= 0 by NAT_1:2;
    then
A9: F(t)=0 by A6,XXREAL_0:1;
    then t.DataLoc(s().a(),i()) >= 0 by A2,A8;
    then for b be Int_position
    holds IExec(WHL,Q,t).b = t.b by A7,SCMPDS_8:12;
    hence thesis by A8,A9,T,SCPISORT:4;
  end;
A10: now
    let k be Element of NAT;
    assume
A11: Q[k];
    now
      let u be 0-started State of SCMPDS;
      let U;
      assume that
A12:  F(u) <= k+1 and
A13:  u.a()=s().a() and
A14:  P[u];
      per cases;
      suppose
        F(u)=0;
        hence F(Initialize IExec(WHL,U,u))=0 &
        P[Initialize IExec(WHL,U,u)]
         by A5,A13,A14;
      end;
      suppose
A15:    F(u) <> 0;
        set Iu=IExec(I(),U,u);
A16:    u.b < 0 by A2,A14,A15;
        then
A17:    Iu.a()=s().a() & P[Initialize Iu] by A4,A13,A14;
        deffunc F(State of SCMPDS) = F($1);
A18:    P[u] by A14;
A19:    for t be 0-started State of SCMPDS st P[t] & F(t)=0
       holds t.DataLoc(u.a(),i()) >= 0 by A2,A13;
        F(Initialize Iu) < F(u) by A4,A13,A14,A16;
        then F(Initialize Iu)+1 <= F(u) by INT_1:7;
        then F(Initialize Iu)+1 <= k+1 by A12,XXREAL_0:2;
        then
A20:    F(Initialize Iu) <= k by XREAL_1:6;
A21:    for t being 0-started State of SCMPDS,Q
       st P[t] & t.a()=u.a() & t.DataLoc(u.a(),i()) < 0
       holds IExec(I(),Q,t).a()=t.a() &
        I() is_closed_on t,Q & I() is_halting_on t,Q &
         F(Initialize IExec(I(),Q,t)) < F(t) & P[Initialize(IExec(I(),Q,t))]
          by A4,A13;
A22:    u.DataLoc(u.a(),i()) < 0 by A2,A13,A14,A15;
XX:     IExec(WHL,U,u) = IExec(WHL,U,Initialize Iu)
         from SCMPDS_8:sch 2 (A22,A19,A18,A21);
        (Initialize Iu).a() = Iu.a() by SCMPDS_5:15;
       hence F(Initialize IExec(WHL,U,u))=0 &
        P[Initialize IExec(WHL,U,u)] by A11,A20,A17,XX;
      end;
    end;
    hence Q[k+1];
  end;
  for k being Element of NAT holds Q[k] from NAT_1:sch 1(A5,A10);
  then Q[F(s())];
  hence thesis by A3;
end;

set a1=intpos 1, a2=intpos 2, a3=intpos 3;

begin :: An Example : Summing directly n integers by loop-invariant

:: sum=Sum=x1+x2+...+xn

definition
  let n, p0 be Element of NAT;
  func sum(n,p0) -> Program of SCMPDS equals
  (GBP:=0) ';' (intpos 1:=0) ';' (
intpos 2:=-n) ';' (intpos 3:=(p0+1)) ';' while<0(GBP,2,AddTo(GBP,1,intpos 3,0)
  ';' AddTo(GBP,2,1) ';' AddTo(GBP,3,1));
  coherence;
end;

definition
 let ff be Function of product the Object-Kind of SCMPDS,NAT,
     s be State of SCMPDS;
 redefine func ff.s -> Element of NAT;
 coherence by ORDINAL1:def 12;
end;

theorem Th8:
  for s being 0-started State of SCMPDS,
    I being halt-free shiftable Program
  of SCMPDS, a,b,c being Int_position,n,i,p0 be Element of NAT,f be FinSequence
  of INT st f is_FinSequence_on s,p0 & len f=n & s.b=0 & s.a=0 & s.
intpos i=-n & s.c = p0+1 &
 (for t be 0-started State of SCMPDS, Q
    st (ex g be FinSequence of
INT st g is_FinSequence_on s,p0 & len g=t.intpos i+n & t.b=Sum g & t.c = p0+1+
  len g) & t.a=0 & t.intpos i < 0 & for i be Element of NAT st i > p0 holds t.
intpos i=s.intpos i holds IExec(I,Q,t).a=0 & I is_closed_on t,Q
 & I is_halting_on t,Q
  & IExec(I,Q,t).intpos i=t.intpos i+1 &
  (ex g be FinSequence of INT st g
  is_FinSequence_on s,p0 & len g=t.intpos i+n+1 &
  IExec(I,Q,t).c = p0+1+len g &
IExec(I,Q,t).b=Sum g) & for i be Element of NAT st i > p0
 holds IExec(I,Q,t).intpos
  i=s.intpos i)
   holds IExec(while<0(a,i,I),P,s).b=Sum f &
   while<0(a,i,I) is_closed_on s,P & while<0(a,i,I) is_halting_on s,P
proof
  let s be 0-started State of SCMPDS,
      I be halt-free shiftable Program of SCMPDS, a,b,c
  be Int_position,n,i,p0 be Element of NAT,f be FinSequence of INT;
  set Iw=IExec(while<0(a,i,I),P,s), Dw=Initialize Iw;
  set da=DataLoc(s.a,i);
  defpred P[State of SCMPDS] means (for i be Element of NAT st i > p0 holds $1
.intpos i=s.intpos i) & (ex g be FinSequence of INT st g is_FinSequence_on s,p0
  & len g=$1.intpos i+n & $1.b=Sum g & $1.intpos i <= 0 & $1.c = p0+1+len g);
  assume that
A2: f is_FinSequence_on s,p0 and
A3: len f=n and
A4: s.b=0 and
A5: s.a=0 and
A6: s.intpos i=-n and
A7: s.c = p0+1;
  consider ff be Function of product the Object-Kind of SCMPDS,NAT such that
A8: for t be State of SCMPDS holds (t.da >= 0 implies ff.t =0) & (t.da <
  0 implies ff.t=-t.da) by Th7;
  deffunc F(State of SCMPDS) = ff.$1;
  assume
A9: for t be 0-started State of SCMPDS,Q
 st (ex g be FinSequence of INT st g
is_FinSequence_on s,p0 & len g=t.intpos i+n & t.b=Sum g & t.c = p0+1+len g) & t
  .a=0 & t.intpos i < 0 & for i be Element of NAT st i > p0 holds t.intpos i=s.
intpos i holds IExec(I,Q,t).a=0 & I is_closed_on t,Q
 & I is_halting_on t,Q & IExec(I,Q,t).intpos i=t.intpos i+1
 & (ex g be FinSequence of INT st g is_FinSequence_on s
,p0 & len g=t.intpos i+n+1 & IExec(I,Q,t).c = p0+1+len g
 & IExec(I,Q,t).b=Sum g) &
  for i be Element of NAT st i > p0
  holds IExec(I,Q,t).intpos i=s.intpos i;
A10:
 for t being 0-started State of SCMPDS st P[t] holds
  (F(t) = 0 & t.da < 0 implies contradiction) &
  (t.da >= 0 implies F(t)=0)
  proof
    let t be 0-started State of SCMPDS;
    assume P[t];
    hereby
      assume
A11:  F(t)=0;
      assume
A12:  t.da < 0;
      then t.da < 0;
      then F(t)=-t.da by A8;
      hence contradiction by A11,A12;
    end;
    assume t.da >= 0;
    then t.da >= 0;
    hence F(t)=0 by A8;
  end;
A13: now
    let t be 0-started State of SCMPDS, Q;
    assume that
A14: P[t] and
A15: t.a=s.a and
A16: t.DataLoc(s.a,i) < 0;
    consider h be FinSequence of INT such that
A17: h is_FinSequence_on s,p0 and
A18: len h=t.intpos i+n & t.b=Sum h and
A19: t.c = p0+1+len h by A14;
A20: t.c = p0+1+len h by A19;
    set It=IExec(I,Q,t);
    set Dit=Initialize It;
A21: for i being Element of NAT st i > p0 holds t.intpos i = s.intpos i by A14;
A23: intpos (0+i)=da by A5,SCMP_GCD:1;
A24: len h=t.intpos i+n & t.b=Sum h by A18;
    hence IExec(I,Q,t).a=t.a by A5,A9,A15,A16,A21,A17,A20,A23;
    consider g be FinSequence of INT such that
A25: g is_FinSequence_on s,p0 and
A26: len g=t.intpos i+n+1 and
A27: IExec(I,Q,t).c = p0+1+len g and
A28: IExec(I,Q,t).b=Sum g by A5,A9,A15,A16,A21,A17,A24,A20,A23;
    thus I is_closed_on t,Q & I is_halting_on t,Q
     by A5,A9,A15,A16,A21,A17,A24,A20,A23;
A29: It.intpos i=t.intpos i+1 by A5,A9,A15,A16,A21,A17,A24,A20,A23;
    hereby
      per cases;
      suppose
        It.intpos i >= 0;
        then Dit.da >= 0 by A23,SCMPDS_5:15;
        then
A30:    F(Dit)=0 by A8;
        F(t) <> 0 by A10,A14,A16;
        hence F(Dit) < F(t) by A30,NAT_1:3;
      end;
      suppose
A31:    It.intpos i < 0;
        t.da < 0 by A16;
        then
A32:    F(t)=-t.da by A8
          .=-t.intpos i by A23;
        Dit.da < 0 by A23,A31,SCMPDS_5:15;
        then F(Dit)=-Dit.da by A8
          .=-(t.intpos i+1) by A23,A29,SCMPDS_5:15
          .=-t.intpos i-1;
        hence F(Dit) < F(t) by A32,XREAL_1:146;
      end;
    end;
    thus P[Initialize IExec(I,Q,t)]
    proof
      hereby
        let i be Element of NAT;
        assume
A33:    i > p0;
        thus Dit.intpos i=It.intpos i by SCMPDS_5:15
          .=s.intpos i by A5,A9,A15,A16,A21,A17,A24,A20,A23,A33;
      end;
      take g;
      thus g is_FinSequence_on s,p0 by A25;
      thus len g=IExec(I,Q,t).intpos i+n by A29,A26
        .=Dit.intpos i+n by SCMPDS_5:15;
      thus Dit.b=Sum g by A28,SCMPDS_5:15;
      Dit.intpos i=t.intpos i+1 by A29,SCMPDS_5:15;
      hence Dit.intpos i <= 0 by A16,A23,INT_1:7;
      thus thesis by A27,SCMPDS_5:15;
    end;
  end;
A34: P[s]
  proof
    thus for i be Element of NAT st i > p0 holds s.intpos i=s.intpos i;
    consider h be FinSequence of INT such that
A35: len h=0 and
A36: h is_FinSequence_on s,p0 by SCPISORT:2;
    take h;
    thus h is_FinSequence_on s,p0 by A36;
    thus len h=s.intpos i+n by A6,A35
      .=s.intpos i+n;
    h=<*> REAL by A35;
    hence s.b=Sum h by A4,RVSUM_1:72;
    thus s.intpos i <= 0 by A6;
    thus thesis by A7,A35;
  end;
A37: F(Dw)=0 & P[Dw] from WhileLEnd(A10,A34,A13);
  then consider g be FinSequence of INT such that
A38: g is_FinSequence_on s,p0 and
A39: len g=Dw.intpos i+n and
A40: Dw.b=Sum g and
A41: Dw.intpos i <= 0;
XX: Dw.intpos i=Iw.intpos(0+i) by SCMPDS_5:15
    .=Iw.da by A5,SCMP_GCD:1;
  Iw.da = Dw.da by SCMPDS_5:15;
  then Dw.intpos i >= 0 by A10,A37,XX;
  then
A42: Dw.intpos i=0 by A41,XXREAL_0:1;
  now
    let i be Nat;
    reconsider a = i as Element of NAT by ORDINAL1:def 12;
    assume i in dom f;
    then
A43: 1 <= i & i <= n by A3,FINSEQ_3:25;
    hence f.i = s.intpos(p0+a) by A2,A3,SCPISORT:def 1
      .=g.i by A38,A39,A42,A43,SCPISORT:def 1;
  end;
  then f = g by A3,A39,A42,FINSEQ_2:9;
  hence Iw.b=Sum f by A40,SCMPDS_5:15;
A44: for t be 0-started State of SCMPDS st P[t] & F(t)=0
     holds t.da >= 0 by A10;
  while<0(a,i,I) is_closed_on s,P & while<0(a,i,I)
  is_halting_on s,P from SCMPDS_8:sch 1(A44,A34,A13);
  hence thesis;
end;

set j1= AddTo(GBP,1,a3,0), j2= AddTo(GBP,2,1), j3= AddTo(GBP,3,1), WB= j1 ';'
j2 ';' j3, WH= while<0(GBP,2,WB);

Lm1: for s being 0-started State of SCMPDS,
        m be Element of NAT st s.GBP=0 & s.a3=m holds
IExec(WB,P,Initialize s).GBP=0 & IExec(WB,P,Initialize s).a1=s.a1+s.intpos m
 & IExec(WB,P,Initialize s).a2=s.a2+1 &
IExec(WB,P,Initialize s).a3=m+1 & for i be Element of NAT st i >3
 holds IExec(WB,P,Initialize s).intpos i =s.intpos i
proof
  set a=GBP;
  let s be 0-started State of SCMPDS,m be Element of NAT;
  assume that
A1: s.a=0 and
A2: s.a3=m;

  set t0=Initialize s, t1=IExec(WB,P,Initialize s),
  t2=IExec(j1 ';' j2,P,Initialize s), t3=Exec(j1, t0);

A3: t0.a3=m by A2,SCMPDS_5:15;
A4: t0.a=0 by A1,SCMPDS_5:15;
  then 0 <> abs(t0.GBP+1) by ABSVALUE:def 1;
  then a <> DataLoc(t0.GBP,1) by ZFMISC_1:27;
  then
A5: t3.a=0 by A4,SCMPDS_2:49;
  then 0 <> abs(t3.GBP+2) by ABSVALUE:def 1;
  then
A6: a <> DataLoc(t3.GBP,2) by ZFMISC_1:27;
  3 <> abs(t0.GBP+1) by A4,ABSVALUE:def 1;
  then a3 <> DataLoc(t0.GBP,1) by ZFMISC_1:27;
  then
A7: t3.a3=m by A3,SCMPDS_2:49;
  3 <> abs(t3.GBP+2) by A5,ABSVALUE:def 1;
  then
A8: a3 <> DataLoc(t3.GBP,2) by ZFMISC_1:27;
A9: t2.a3=Exec(j2,t3).a3 by SCMPDS_5:42
    .=m by A7,A8,SCMPDS_2:48;
A10: t0.a1=s.a1 by SCMPDS_5:15;
A11: DataLoc(t0.a,1)=intpos (0+1) by A4,SCMP_GCD:1;
  then
A12: t3.a1=t0.a1+t0.DataLoc(t0.a3,0) by SCMPDS_2:49
    .=t0.a1+t0.intpos(m+0) by A3,SCMP_GCD:1
    .=s.a1+s.intpos m by A10,SCMPDS_5:15;
  1 <> abs(t3.GBP+2) by A5,ABSVALUE:def 1;
  then
A13: a1 <> DataLoc(t3.GBP,2) by ZFMISC_1:27;
A14: DataLoc(t3.a,2)=intpos (0+2) by A5,SCMP_GCD:1;
  then
A15: abs(t3.a+2)=0+2 by ZFMISC_1:27;
  2 <> abs(t0.GBP+1) by A4,ABSVALUE:def 1;
  then a2 <> DataLoc(t0.GBP,1) by ZFMISC_1:27;
  then
A16: t3.a2=t0.a2 by SCMPDS_2:49
    .=s.a2 by SCMPDS_5:15;
A17: t2.a=Exec(j2,t3).a by SCMPDS_5:42
    .=0 by A5,A6,SCMPDS_2:48;
  then
A18: DataLoc(t2.a,3)=intpos (0+3) by SCMP_GCD:1;
A19: t2.a2=Exec(j2,t3).a2 by SCMPDS_5:42
    .=s.a2+1 by A16,A14,SCMPDS_2:48;
A20: t2.a1=Exec(j2,t3).a1 by SCMPDS_5:42
    .=s.a1+s.intpos m by A12,A13,SCMPDS_2:48;
  0 <> abs(t2.GBP+3) by A17,ABSVALUE:def 1;
  then
A21: a <> DataLoc(t2.GBP,3) by ZFMISC_1:27;
  thus t1.a=Exec(j3,t2).a by SCMPDS_5:41
    .=0 by A17,A21,SCMPDS_2:48;
  1 <> abs(t2.GBP+3) by A17,ABSVALUE:def 1;
  then
A22: a1 <> DataLoc(t2.GBP,3) by ZFMISC_1:27;
  thus t1.a1=Exec(j3,t2).a1 by SCMPDS_5:41
    .=s.a1+s.intpos m by A20,A22,SCMPDS_2:48;
  2 <> abs(t2.GBP+3) by A17,ABSVALUE:def 1;
  then
A23: a2 <> DataLoc(t2.GBP,3) by ZFMISC_1:27;
  thus t1.a2=Exec(j3,t2).a2 by SCMPDS_5:41
    .=s.a2+1 by A19,A23,SCMPDS_2:48;
  thus t1.a3=Exec(j3,t2).a3 by SCMPDS_5:41
    .=m+1 by A9,A18,SCMPDS_2:48;
A24: abs(t0.a+1)=0+1 by A11,ZFMISC_1:27;
  hereby
    let i be Element of NAT;
    assume
A25: i >3;
    then
A26: intpos i <> DataLoc(t2.a,3) by A18,ZFMISC_1:27;
    i <> abs(t0.a+1) by A24,A25;
    then
A27: intpos i <> DataLoc(t0.a,1) by ZFMISC_1:27;
    i <> abs(t3.a+2) by A15,A25;
    then
A28: intpos i <> DataLoc(t3.a,2) by ZFMISC_1:27;
    thus t1.intpos i=Exec(j3,t2).intpos i by SCMPDS_5:41
      .=t2.intpos i by A26,SCMPDS_2:48
      .=Exec(j2,t3).intpos i by SCMPDS_5:42
      .=t3.intpos i by A28,SCMPDS_2:48
      .=t0.intpos i by A27,SCMPDS_2:49
      .=s.intpos i by SCMPDS_5:15;
  end;
end;

Lm3: for s being 0-started State of SCMPDS,
n,p0 be Element of NAT,f be FinSequence of
INT st p0 >= 3 & f is_FinSequence_on s,p0 & len f=n & s.a1=0 & s.GBP=0 & s.a2=-
n & s.a3=p0+1 holds IExec(WH,P,Initialize s).a1=Sum f
 & WH is_closed_on s,P & WH is_halting_on s ,P
proof
  let s be 0-started State of SCMPDS,
      n,p0 be Element of NAT,f be FinSequence of INT;
  set a=GBP;
I: Initialize s = s by MEMSTR_0:44;
  assume that
A1: p0 >= 3 and

A2: f is_FinSequence_on s,p0 & len f=n & s.a1=0 & s.a=0 & s.a2=-n & s.a3
  = p0+1;
  now
    let t be 0-started State of SCMPDS;
    let Q;
T: Initialize t = t by MEMSTR_0:44;
    given g be FinSequence of INT such that
A3: g is_FinSequence_on s,p0 and
A4: len g=t.a2+n and
A5: t.a1=Sum g and
A6: t.a3 = p0+1+len g;
    assume that
A7: t.a=0 and
    t.a2 < 0;
    assume
A13: for i be Element of NAT st i > p0 holds t.intpos i=s.intpos i;
    thus IExec(WB,Q,t).a=0 by A6,A7,Lm1,T;
    thus WB is_closed_on t,Q & WB is_halting_on t,Q by SCMPDS_6:20,21;
    thus IExec(WB,Q,t).a2=t.a2+1 by A6,A7,Lm1,T;
    thus ex g be FinSequence of INT st g is_FinSequence_on s,p0 &
      len g=t.a2+n+1 & IExec(WB,Q,t).a3 = p0+1+len g &
    IExec(WB,Q,t).a1=Sum g
    proof
      consider h be FinSequence of INT such that
A14:   len h=len g+1 and
A15:  h is_FinSequence_on s,p0 by SCPISORT:2;
      take h;
      thus h is_FinSequence_on s,p0 by A15;
      thus len h=t.a2+n+1 by A4,A14;
      thus IExec(WB,Q,t).a3 =p0+1+len g+1 by A6,A7,Lm1,T
        .=p0+1+len h by A14;
A16:  p0+1 > p0 by XREAL_1:29;
      set m=len h;
A17:  m >= 1 by A14,NAT_1:11;
      then p0+m >= p0+1 by XREAL_1:6;
      then
A18:  p0+m > p0 by A16,XXREAL_0:2;
      reconsider q = h.m as Element of INT by INT_1:def 2;
A19:  now
        let i be Nat;
A20:    i in NAT by ORDINAL1:def 12;
        assume that
A21:    1 <= i and
A22:    i <= len h;
        per cases;
        suppose
          i=len h;
          hence h.i=(g^<*q*>).i by A14,FINSEQ_1:42;
        end;
        suppose
          i<>len h;
          then i < len h by A22,XXREAL_0:1;
          then
A23:      i <= len g by A14,INT_1:7;
          then i in Seg (len g) by A21,FINSEQ_1:1;
          then
A24:      i in dom g by FINSEQ_1:def 3;
          thus h.i = s.intpos(p0+i) by A15,A20,A21,A22,SCPISORT:def 1
            .= g.i by A3,A20,A21,A23,SCPISORT:def 1
            .= (g^<*q*>).i by A24,FINSEQ_1:def 7;
        end;
      end;
      len (g^<*q*>)=len h by A14,FINSEQ_2:16;
      then
A25:  g^<*q*>=h by A19,FINSEQ_1:14;
      h.m=s.intpos(p0+m) by A15,A17,SCPISORT:def 1
        .=t.intpos(p0+1+len g) by A13,A14,A18;
      hence IExec(WB,Q,t).a1=t.a1+h.m by A6,A7,Lm1,T
        .=Sum h by A5,A25,RVSUM_1:74;
    end;
    hereby
      let i be Element of NAT;
      assume
A28:  i > p0;
      then i > 3 by A1,XXREAL_0:2;
      hence IExec(WB,Q,t).intpos i=t.intpos i
      by A6,A7,Lm1,T
        .=s.intpos i by A13,A28;
    end;
  end;
  hence thesis by A2,Th8,I;
end;

Lm4: for s being 0-started State of SCMPDS,
  n,p0 be Element of NAT,f be FinSequence of
INT st p0 >= 3 & f is_FinSequence_on s,p0 & len f=n
 holds IExec(sum(n,p0),P,s).a1
=Sum f & sum(n,p0) is_halting_on s,P
proof
  let s be 0-started State of SCMPDS,
      n,p0 be Element of NAT,f be FinSequence of INT;
I: Initialize s = s by MEMSTR_0:44;
  assume that
A1: p0 >= 3 and
A2: f is_FinSequence_on s,p0 and
A3: len f=n;

  set a=GBP, i1=a:=0, i2=a1:=0, i3=a2:=-n, i4=a3:=(p0+1), t0=Initialize s,
    I4 =i1 ';' i2 ';' i3 ';' i4, t1=IExec(I4,P,Initialize s), Q1 = P,
    t2=IExec(i1 ';' i2 ';' i3,P,Initialize s),
    t3= IExec(i1 ';' i2,P,Initialize s), t4=Exec(i1, t0);

  now
    let i be Element of NAT;
    assume that
A4: 1 <= i and
A5: i <= len f;
A6: p0+1 >= 3+1 by A1,XREAL_1:6;
A7: p0+i >= p0+ 1 by A4,XREAL_1:6;
    then p0+i <> 3 by A6,XXREAL_0:2;
    then
A8: intpos (p0+i) <> a3 by ZFMISC_1:27;
    p0+i <> 0 by A6,A7,XXREAL_0:2;
    then
A9: intpos (p0+i) <> a by ZFMISC_1:27;
    p0+i <> 1 by A6,A7,XXREAL_0:2;
    then
A10: intpos (p0+i) <> a1 by ZFMISC_1:27;
    p0+i <> 2 by A6,A7,XXREAL_0:2;
    then
A11: intpos (p0+i) <> a2 by ZFMISC_1:27;
    thus t1.intpos (p0+i)=Exec(i4, t2).intpos (p0+i) by SCMPDS_5:41
      .=t2.intpos (p0+i) by A8,SCMPDS_2:45
      .=Exec(i3, t3).intpos (p0+i) by SCMPDS_5:41
      .=t3.intpos (p0+i) by A11,SCMPDS_2:45
      .=Exec(i2, t4).intpos (p0+i) by SCMPDS_5:42
      .=t4.intpos (p0+i) by A10,SCMPDS_2:45
      .=t0.intpos (p0+i) by A9,SCMPDS_2:45
      .=s.intpos (p0+i) by SCMPDS_5:15
      .=f.i by A2,A4,A5,SCPISORT:def 1;
  end;
  then
A12: f is_FinSequence_on t1,p0 by SCPISORT:def 1;
A13: f is_FinSequence_on Initialize t1,p0
   proof let i be Element of NAT;
    assume 1 <= i & i <= len f;
     then f.i=t1.intpos(p0+i) by A12,SCPISORT:def 1;
    hence thesis by SCMPDS_5:15;
   end;
A14: t4.a=0 by SCMPDS_2:45;
A15: t3.a=Exec(i2, t4).a by SCMPDS_5:42
    .=0 by A14,AMI_3:10,SCMPDS_2:45;
A16: t2.a=Exec(i3, t3).a by SCMPDS_5:41
    .=0 by A15,AMI_3:10,SCMPDS_2:45;
A17: t1.a3=Exec(i4, t2).a3 by SCMPDS_5:41
    .=p0+1 by SCMPDS_2:45;
A18: (Initialize t1).a3 = t1.a3 by SCMPDS_5:15;
A19: t3.a1=Exec(i2, t4).a1 by SCMPDS_5:42
    .=0 by SCMPDS_2:45;
A20: t2.a1=Exec(i3, t3).a1 by SCMPDS_5:41
    .=0 by A19,AMI_3:10,SCMPDS_2:45;
A21: (Initialize t1).a1 = t1.a1 by SCMPDS_5:15;
A22: t1.a1=Exec(i4, t2).a1 by SCMPDS_5:41
    .=0 by A20,AMI_3:10,SCMPDS_2:45;
A23: t2.a2=Exec(i3, t3).a2 by SCMPDS_5:41
    .=-n by SCMPDS_2:45;
A24: (Initialize t1).a2 = t1.a2 by SCMPDS_5:15;
A25: (Initialize t1).a = t1.a by SCMPDS_5:15;
A26: t1.a2=Exec(i4, t2).a2 by SCMPDS_5:41
    .=-n by A23,AMI_3:10,SCMPDS_2:45;
A27: t1.a=Exec(i4, t2).a by SCMPDS_5:41
    .=0 by A16,AMI_3:10,SCMPDS_2:45;

  then WH is_closed_on Initialize t1,Q1 & WH is_halting_on Initialize t1,Q1
   by A1,A3,A22,A26,A17,Lm3,A13,A18,A21,A24,A25;
  then
A28: WH is_closed_on t1,Q1 & WH is_halting_on t1,Q1 by SCMPDS_6:125,126;

  IExec(WH,Q1,Initialize t1) = IExec(WH,Q1,Initialize Initialize t1);
  then IExec(WH,Q1,Initialize t1).a1=Sum f
   by A1,A3,A27,A22,A26,A17,Lm3,A13,A18,A21,A24,A25;
  hence IExec(sum(n,p0),P,s).a1=Sum f by A28,I,SCPISORT:7;
  thus thesis by A28,SCPISORT:9;
end;

theorem
  for s being 0-started State of SCMPDS,n,
    p0 be Element of NAT, f be FinSequence
of INT st p0 >= 3 & f is_FinSequence_on s,p0 & len f=n
 holds IExec(sum(n,p0),P,s).intpos 1=Sum f & sum(n,p0) is parahalting
proof
  let s be 0-started State of SCMPDS,
      n,p0 be Element of NAT,f be FinSequence of INT;
  assume that
A1: p0 >= 3 and
A2: f is_FinSequence_on s,p0 & len f=n;
  thus IExec(sum(n,p0),P,s).a1=Sum f by A1,A2,Lm4;
  now
    let t be State of SCMPDS, Q;
    consider g being FinSequence of INT such that
A3:     len g=n & g is_FinSequence_on t,p0 by SCPISORT:2;
     g is_FinSequence_on Initialize t,p0
  proof let i be Element of NAT;
    assume 1 <= i & i <= len g;
     then g.i=t.intpos(p0+i) by A3,SCPISORT:def 1;
    hence thesis by SCMPDS_5:15;
   end;
     then sum(n,p0) is_halting_on Initialize t,Q by A1,Lm4,A3;
    hence sum(n,p0) is_halting_on t,Q by SCMPDS_6:126;
  end;
  hence thesis by SCMPDS_6:21;
end;

begin :: Computing directly the result of "while>0" program by loop-invariant

scheme
  WhileGEnd { F(State of SCMPDS)-> Element of NAT,
  s() -> 0-started State of SCMPDS,
  P() -> Instruction-Sequence of SCMPDS,
  I() -> halt-free shiftable Program of SCMPDS,
  a() -> Int_position,i() -> Integer, P[set]}:
   F(Initialize IExec(while>0(a(),i(),I()),P(),s()))=0
 & P[Initialize IExec(while>0(a(),i(),I()),P(),s())]
provided
A2: for t be 0-started State of SCMPDS st P[t]
 holds F(t)=0 iff t.DataLoc(s().a(),i()) <= 0 and
A3: P[s()] and
A4: for t be 0-started State of SCMPDS,Q
    st P[t] & t.a()=s().a() & t.DataLoc(
s().a(),i()) > 0 holds IExec(I(),Q,t).a()=t.a() &
I() is_closed_on t,Q & I()
is_halting_on t,Q & F(Initialize IExec(I(),Q,t)) < F(t)
 & P[Initialize(IExec(I(),Q,t))]
proof
  set b=DataLoc(s().a(),i()), WHL=while>0(a(),i(),I());
  defpred Q[Element of NAT] means
  for t be 0-started State of SCMPDS,Q st F(t) <=
  $1 & t.a()=s().a() & P[t]
  holds F(Initialize IExec(WHL,Q,t))=0 & P[Initialize IExec(WHL,Q,t)];
A5: Q[0]
  proof
    let t be 0-started State of SCMPDS, Q;
T: Initialize t = t by MEMSTR_0:44;
    assume that
A6: F(t) <= 0 and
A7: t.a()=s().a() and
A8: P[t];
    F(t) >= 0 by NAT_1:2;
    then
A9: F(t)=0 by A6,XXREAL_0:1;
    then t.DataLoc(s().a(),i()) <= 0 by A2,A8;
    then for b be Int_position holds IExec(WHL,Q,t).b = t.b
     by A7,SCMPDS_8:23;
    hence thesis by A8,A9,T,SCPISORT:4;
  end;
A10: now
    let k be Element of NAT;
    assume
A11: Q[k];
    now
      let u be 0-started State of SCMPDS;
      let U;
      assume that
A12:  F(u) <= k+1 and
A13:  u.a()=s().a() and
A14:  P[u];
      per cases;
      suppose
        F(u)=0;
        hence F(Initialize IExec(WHL,U,u))=0 &
        P[Initialize IExec(WHL,U,u)]
         by A5,A13,A14;
      end;
      suppose
A15:    F(u) <> 0;
        set Iu=IExec(I(),U,u);
A16:    u.b > 0 by A2,A14,A15;
        then
A17:    Iu.a()=s().a() & P[Initialize Iu] by A4,A13,A14;
        deffunc F(State of SCMPDS) = F($1);
A18:    P[u] by A14;
A19:    for t be 0-started State of SCMPDS st P[t] & F(t)=0
          holds t.DataLoc(u.a(),i()) <= 0 by A2,A13;
        F(Initialize Iu) < F(u) by A4,A13,A14,A16;
        then F(Initialize Iu)+1 <= F(u) by INT_1:7;
        then F(Initialize Iu)+1 <= k+1 by A12,XXREAL_0:2;
        then
A20:    F(Initialize Iu) <= k by XREAL_1:6;
A21:    for t being 0-started State of SCMPDS,Q st
     P[t] & t.a()=u.a() & t.
DataLoc(u.a(),i()) > 0 holds IExec(I(),Q,t).a()=t.a()
 & I() is_closed_on t,Q & I()
is_halting_on t,Q & F(Initialize IExec(I(),Q,t)) < F(t)
 & P[Initialize(IExec(I(),Q,t))
        ] by A4,A13;
A22:    u.DataLoc(u.a(),i()) > 0 by A2,A13,A14,A15;
XX:    IExec(WHL,U,u) = IExec(WHL,U,Initialize Iu) from SCMPDS_8:
        sch 4 (A22,A19,A18,A21);
         (Initialize Iu).a() = Iu.a() by SCMPDS_5:15;
        hence F(Initialize IExec(WHL,U,u))=0 &
        P[Initialize IExec(WHL,U,u)] by A11,A20,A17,XX;
      end;
    end;
    hence Q[k+1];
  end;
  for k being Element of NAT holds Q[k] from NAT_1:sch 1(A5,A10);
  then Q[F(s())];
  hence thesis by A3;
end;

begin :: An Example : Computing directly Fibonacci sequence by loop-invariant

definition
  let n be Element of NAT;
  func Fib-macro(n) -> Program of SCMPDS equals
  (GBP:=0) ';' (intpos 1:=0) ';'
(intpos 2:=1) ';' (intpos 3:=n) ';' while>0(GBP,3,((GBP,4):=(GBP,2)) ';' AddTo(
  GBP,2,GBP,1) ';' ((GBP,1):=(GBP,4)) ';' AddTo(GBP,3,-1));
  coherence;
end;

theorem Th10:
  for s being 0-started State of SCMPDS,I being halt-free shiftable
Program of SCMPDS, a,f0,f1 being Int_position,n,i be Element of NAT
 st s.a=0 & s.f0=0 & s.f1=1 & s.intpos i=n &
  (for t be 0-started State of SCMPDS,Q
  for k be
  Element of NAT st n=t.intpos i+k & t.f0=Fib k & t.f1 = Fib (k+1) & t.a=0 & t.
  intpos i > 0 holds IExec(I,Q,t).a=0 & I is_closed_on t,Q
   & I is_halting_on t,Q &
  IExec(I,Q,t).intpos i=t.intpos i-1
   & IExec(I,Q,t).f0=Fib (k+1) &
   IExec(I,Q,t).f1 = Fib (k+1+1))
 holds IExec(while>0(a,i,I),P,s).f0=Fib n
 & IExec(while>0(a,i,I),P,s).
  f1=Fib (n+1) & while>0(a,i,I) is_closed_on s,P
   & while>0(a,i,I) is_halting_on s,P
proof
  let s be 0-started State of SCMPDS,
      I be halt-free shiftable Program of SCMPDS, a,f0,
  f1 be Int_position,n,i be Element of NAT;
  set Iw=IExec(while>0(a,i,I),P,s), Dw=Initialize Iw;
  set da=DataLoc(s.a,i);
  defpred P[State of SCMPDS] means $1.intpos i >= 0 & ex k be Element of NAT
  st n=$1.intpos i+k & $1.f0=Fib k & $1.f1=Fib (k+1);
  assume that
A2: s.a=0 and
A3: s.f0=0 and
A4: s.f1=1 and
A5: s.intpos i=n;
  consider ff be Function of product the Object-Kind of SCMPDS,NAT such that
B6: for t be State of SCMPDS holds
    (t.da <= 0 implies ff.t =0) & (t.da > 0 implies ff.t=t.da) by SCMPDS_8:5;
A6: for t be 0-started State of SCMPDS holds
    (t.da <= 0 implies ff.t =0) & (t.da > 0 implies ff.t=t.da) by B6;
  deffunc F(State of SCMPDS) = ff.$1;
A7: for t being 0-started State of SCMPDS st P[t] holds
     not(F(t)=0 & t.da > 0) & (t.da <= 0 implies F(t)=0) by A6;
  assume
A9: for t be 0-started State of SCMPDS,Q
  for k be Element of NAT st n=t.intpos i+k & t.
  f0=Fib k & t.f1 = Fib (k+1) & t.a=0 & t.intpos i > 0
   holds IExec(I,Q,t).a=0 & I is_closed_on t,Q & I is_halting_on t,Q
 & IExec(I,Q,t).intpos i=t.intpos i-1 & IExec(I,Q,t).f0=Fib (k+1)
  & IExec(I,Q,t).f1 = Fib (k+1+1);
A10: now
    let t be 0-started State of SCMPDS, Q;
    assume that
A11: P[t] and
A12: t.a=s.a and
A13: t.DataLoc(s.a,i) > 0;
    set It=IExec(I,Q,t);
    set Dit=Initialize It;
    consider k be Element of NAT such that
A14: n=t.intpos i+k and
A15: t.f0=Fib k and
A16: t.f1=Fib (k+1) by A11;
A17: t.f1=Fib (k+1) by A16;
A18: intpos (0+i)=da by A2,SCMP_GCD:1;
A19: n=t.intpos i+k & t.f0=Fib k by A14,A15;
    hence IExec(I,Q,t).a=t.a by A2,A9,A12,A13,A17,A18;
    thus I is_closed_on t,Q & I is_halting_on t,Q by A2,A9,A12,A13,A19,A17,A18;
A20: It.intpos i=t.intpos i-1 by A2,A9,A12,A13,A19,A17,A18;
    hereby
      per cases;
      suppose
        It.intpos i <= 0;
        then Dit.da <= 0 by A18,SCMPDS_5:15;
        then
A21:    F(Dit)=0 by A6;
        F(t) <> 0 by A7,A11,A13;
        hence F(Dit) < F(t) by A21,NAT_1:3;
      end;
      suppose
A22:    It.intpos i > 0;
        t.da > 0 by A13;
        then
A23:    F(t)=t.da by A6
          .=t.intpos i by A18;
        Dit.da > 0 by A18,A22,SCMPDS_5:15;
        then F(Dit)=Dit.da by A6
          .=t.intpos i-1 by A18,A20,SCMPDS_5:15;
        hence F(Dit) < F(t) by A23,XREAL_1:146;
      end;
    end;
    thus P[Dit]
    proof
      t.intpos i >= 1+0 by A13,A18,INT_1:7;
      then t.intpos i-1 >= 0 by XREAL_1:48;
      hence Dit.intpos i >= 0 by A20,SCMPDS_5:15;
      take m=k+1;
      thus n=t.intpos i-1+1+k by A14
        .=Dit.intpos i+1+k by A20,SCMPDS_5:15
        .=Dit.intpos i+m;
      It.f0=Fib m & It.f1=Fib (k+1+1) by A2,A9,A12,A13,A19,A17,A18;
      hence thesis by SCMPDS_5:15;
    end;
  end;
A24: P[s]
  proof
    s.intpos i =n by A5;
    hence s.intpos i >= 0 by NAT_1:2;
    take k=0;
    thus n=s.intpos i+k by A5;
    thus s.f0=Fib k by A3,PRE_FF:1;
    thus thesis by A4,PRE_FF:1;
  end;
A25: F(Dw)=0 & P[Dw] from WhileGEnd(A7,A24,A10);
X1: Dw.da = Iw.da by SCMPDS_5:15;
  Dw.intpos i=Iw.intpos(0+i) by SCMPDS_5:15
    .=Iw.da by A2,SCMP_GCD:1;
  then Dw.intpos i <= 0 by A7,A25,X1;
  then Dw.intpos i=0 by A25,XXREAL_0:1;
  hence Iw.f0=Fib n & Iw.f1=Fib (n+1) by A25,SCMPDS_5:15;
A26: for t be 0-started State of SCMPDS st P[t] & F(t)=0
       holds t.da <= 0 by A7;
  while>0(a,i,I) is_closed_on s,P & while>0(a,i,I)
  is_halting_on s,P from SCMPDS_8:sch 3(A26,A24,A10);
  hence thesis;
end;

set j1= (GBP,4):=(GBP,2), j2= AddTo(GBP,2,GBP,1), j3= (GBP,1):=(GBP,4), j4=
AddTo(GBP,3,-1), WB= j1 ';' j2 ';' j3 ';' j4, WH= while>0(GBP,3,WB);

Lm5: for s being 0-started State of SCMPDS st s.GBP=0
 holds IExec(WB,P,s).GBP=0 & IExec(WB,P
,s).a1=s.a2 & IExec(WB,P,s).a2=s.a1+s.a2 &
IExec(WB,P,s).a3=s.a3-1

proof
  set a=GBP;
  let s be 0-started State of SCMPDS;
  set t0=s, t1=IExec(WB,P,s),
  t2=IExec(j1 ';' j2 ';' j3,P,s),
      Q0 = P,
      t3=IExec(j1 ';' j2,P,s), t4=Exec(j1, t0), a4=intpos 4;
  assume s.a=0;
  then
A5: t0.a=0;
  then DataLoc(t0.a,4)=intpos (0+4) by SCMP_GCD:1;
  then
A6: t4.a4=t0.DataLoc(t0.a,2) by SCMPDS_2:47
    .=t0.intpos(0+2) by A5,SCMP_GCD:1
    .=s.a2;
  0 <> abs(t0.GBP+4) by A5,ABSVALUE:def 1;
  then a <> DataLoc(t0.GBP,4) by ZFMISC_1:27;
  then
A7: t4.a=0 by A5,SCMPDS_2:47;
  then
A8: DataLoc(t4.a,2)=intpos (0+2) by SCMP_GCD:1;
  0 <> abs(t4.GBP+2) by A7,ABSVALUE:def 1;
  then
A9: a <> DataLoc(t4.GBP,2) by ZFMISC_1:27;
A10: t3.a=Exec(j2,t4).a by SCMPDS_5:42
    .=0 by A7,A9,SCMPDS_2:49;
  then
A11: DataLoc(t3.a,1)=intpos (0+1) by SCMP_GCD:1;
  4 <> abs(t4.GBP+2) by A7,ABSVALUE:def 1;
  then
A12: a4 <> DataLoc(t4.GBP,2) by ZFMISC_1:27;
A13: t3.a4=Exec(j2,t4).a4 by SCMPDS_5:42
    .=s.a2 by A6,A12,SCMPDS_2:49;
A14: t2.a1=Exec(j3,t3).a1 by SCMPDS_5:41
    .=t3.DataLoc(t3.a,4) by A11,SCMPDS_2:47
    .=s.a2 by A10,A13,SCMP_GCD:1;
  3 <> abs(t4.GBP+2) by A7,ABSVALUE:def 1;
  then
A15: a3 <> DataLoc(t4.GBP,2) by ZFMISC_1:27;
  2 <> abs(t0.GBP+4) by A5,ABSVALUE:def 1;
  then a2 <> DataLoc(t0.GBP,4) by ZFMISC_1:27;
  then
A16: t4.a2=t0.a2 by SCMPDS_2:47
    .=s.a2;
  1 <> abs(t0.GBP+4) by A5,ABSVALUE:def 1;
  then a1 <> DataLoc(t0.GBP,4) by ZFMISC_1:27;
  then
A17: t4.a1=t0.a1 by SCMPDS_2:47
    .=s.a1;
  3 <> abs(t0.GBP+4) by A5,ABSVALUE:def 1;
  then a3 <> DataLoc(t0.GBP,4) by ZFMISC_1:27;
  then
A18: t4.a3=t0.a3 by SCMPDS_2:47
    .=s.a3;
  0 <> abs(t3.GBP+1) by A10,ABSVALUE:def 1;
  then
A19: a <> DataLoc(t3.GBP,1) by ZFMISC_1:27;
A20: t2.a=Exec(j3,t3).a by SCMPDS_5:41
    .=0 by A10,A19,SCMPDS_2:47;
  then
A21: DataLoc(t2.a,3)=intpos (0+3) by SCMP_GCD:1;
  2 <> abs(t3.GBP+1) by A10,ABSVALUE:def 1;
  then
A22: a2 <> DataLoc(t3.GBP,1) by ZFMISC_1:27;
A23: t3.a2=Exec(j2,t4).a2 by SCMPDS_5:42
    .=t4.a2+t4.DataLoc(t4.a,1) by A8,SCMPDS_2:49
    .=s.a2+s.a1 by A7,A17,A16,SCMP_GCD:1;
A24: t2.a2=Exec(j3,t3).a2 by SCMPDS_5:41
    .=s.a2+s.a1 by A23,A22,SCMPDS_2:47;
  3 <> abs(t3.GBP+1) by A10,ABSVALUE:def 1;
  then
A25: a3 <> DataLoc(t3.GBP,1) by ZFMISC_1:27;
  0 <> abs(t2.GBP+3) by A20,ABSVALUE:def 1;
  then
A26: a <> DataLoc(t2.GBP,3) by ZFMISC_1:27;
  thus t1.a=Exec(j4,t2).a by SCMPDS_5:41
    .=0 by A20,A26,SCMPDS_2:48;
  1 <> abs(t2.GBP+3) by A20,ABSVALUE:def 1;
  then
A27: a1 <> DataLoc(t2.GBP,3) by ZFMISC_1:27;
  thus t1.a1=Exec(j4,t2).a1 by SCMPDS_5:41
    .=s.a2 by A14,A27,SCMPDS_2:48;
  2 <> abs(t2.GBP+3) by A20,ABSVALUE:def 1;
  then
A28: a2 <> DataLoc(t2.GBP,3) by ZFMISC_1:27;
A29: t3.a3=Exec(j2,t4).a3 by SCMPDS_5:42
    .=s.a3 by A18,A15,SCMPDS_2:49;
A30: t2.a3=Exec(j3,t3).a3 by SCMPDS_5:41
    .=s.a3 by A29,A25,SCMPDS_2:47;
  thus t1.a2=Exec(j4,t2).a2 by SCMPDS_5:41
    .=s.a1+s.a2 by A24,A28,SCMPDS_2:48;
  thus t1.a3=Exec(j4,t2).a3 by SCMPDS_5:41
    .=t2.a3+-1 by A21,SCMPDS_2:48
    .=s.a3-1 by A30;
end;

Lm7: for s being 0-started State of SCMPDS,n be Element of NAT
   st s.GBP=0 & s.a1=0 & s.
a2=1 & s.a3=n holds IExec(WH,P,s).a1=Fib n &
IExec(WH,P,s).a2=Fib (n+1) & WH
is_closed_on s,P & WH is_halting_on s,P
proof
  let s be 0-started State of SCMPDS,n be Element of NAT;
  set a=GBP;
A1: now
    let t be 0-started State of SCMPDS,Q;
    let k be Element of NAT;
    assume that
    n=t.a3+k and
A2: t.a1=Fib k and
A3: t.a2 = Fib (k+1) and
A4: t.a=0 and
    t.a3 > 0;
    thus IExec(WB,Q,t).a=0 by A4,Lm5;
    thus WB is_closed_on t,Q & WB is_halting_on t,Q by SCMPDS_6:20,21;
    thus IExec(WB,Q,t).a3=t.a3-1 by A4,Lm5;
    thus IExec(WB,Q,t).a1=Fib (k+1) by A3,A4,Lm5;
    thus IExec(WB,Q,t).a2 =t.a1+t.a2 by A4,Lm5
      .=Fib (k+1+1) by A2,A3,PRE_FF:1;
  end;
  assume s.GBP=0 & s.a1=0 & s.a2=1 & s.a3=n;
  hence thesis by A1,Th10;
end;

Lm8: for s being 0-started State of SCMPDS,
n be Element of NAT holds IExec(Fib-macro(n),P,s).a1=Fib n &
IExec(Fib-macro(n),P,s).a2=Fib (n+1)
 & Fib-macro(n) is_halting_on s,P
proof
  let s be 0-started State of SCMPDS,n be Element of NAT;
  set a=GBP, i1=a:=0, i2=a1:=0, i3=a2:=1, i4=a3:=n,
  I4=i1 ';' i2 ';' i3 ';' i4, t1=IExec(I4,P,s),
  t2=IExec(i1 ';' i2 ';' i3,P,s),
  t3=IExec(i1 ';' i2,P,s), t4=Exec(i1, s);
I: Initialize s = s by MEMSTR_0:44;
A1: t4.a=0 by SCMPDS_2:45;
A2: t3.a=Exec(i2, t4).a by SCMPDS_5:42
    .=0 by A1,AMI_3:10,SCMPDS_2:45;
A3: t2.a=Exec(i3, t3).a by SCMPDS_5:41
    .=0 by A2,AMI_3:10,SCMPDS_2:45;
A4: t3.a1=Exec(i2, t4).a1 by SCMPDS_5:42
    .=0 by SCMPDS_2:45;
A5: t2.a1=Exec(i3, t3).a1 by SCMPDS_5:41
    .=0 by A4,AMI_3:10,SCMPDS_2:45;
A6: t1.a1=Exec(i4, t2).a1 by SCMPDS_5:41
    .=0 by A5,AMI_3:10,SCMPDS_2:45;
A7: t2.a2=Exec(i3, t3).a2 by SCMPDS_5:41
    .=1 by SCMPDS_2:45;
A8: t1.a2=Exec(i4, t2).a2 by SCMPDS_5:41
    .=1 by A7,AMI_3:10,SCMPDS_2:45;
A9: t1.a3=Exec(i4, t2).a3 by SCMPDS_5:41
    .=n by SCMPDS_2:45;
A10: t1.a=Exec(i4, t2).a by SCMPDS_5:41
    .=0 by A3,AMI_3:10,SCMPDS_2:45;
X1: (Initialize t1).GBP = t1.GBP by SCMPDS_5:15;
X2: (Initialize t1).a1 = t1.a1 by SCMPDS_5:15;
X3: (Initialize t1).a2 = t1.a2 by SCMPDS_5:15;
X4: (Initialize t1).a3 = t1.a3 by SCMPDS_5:15;
B11: WH is_closed_on Initialize t1,P &
     WH is_halting_on Initialize t1,P by A6,A8,A9,Lm7,A10,X1,X2,X3,X4;
A11: WH is_closed_on t1,P
    proof
  for k being Element of NAT holds
   IC Comput(P+*stop WH,Initialize Initialize t1,k) in dom stop WH
             by B11,SCMPDS_6:def 2;
     hence thesis by SCMPDS_6:def 2;
    end;
A12: WH is_halting_on t1,P
   proof
     P+*stop WH halts_on Initialize Initialize t1 by B11,SCMPDS_6:def 3;
    hence thesis by SCMPDS_6:def 3;
   end;
  IExec(WH,P,Initialize t1).a1=Fib n by A10,A6,A8,A9,Lm7,X1,X2,X3,X4;
  hence IExec(Fib-macro(n),P,s).a1=Fib n by A11,A12,SCPISORT:7;
  IExec(WH,P,Initialize t1).a2=Fib (n+1) by A10,A6,A8,A9,Lm7,X1,X2,X3,X4;
  hence IExec(Fib-macro(n),P,s).a2=Fib (n+1) by A11,A12,SCPISORT:7;
  thus thesis by A11,A12,I,SCPISORT:9;
end;

theorem
  for s being 0-started State of SCMPDS,
  n be Element of NAT
  holds IExec(Fib-macro(n),P,s).intpos 1=Fib n &
IExec(Fib-macro(n),P,s).intpos 2=Fib (n+1) & Fib-macro(n)
  is parahalting
proof
  let s be 0-started State of SCMPDS,n be Element of NAT;
  thus IExec(Fib-macro(n),P,s).a1=Fib n &
  IExec(Fib-macro(n),P,s).a2=Fib (n+1) by Lm8;
  for t be State of SCMPDS,Q holds Fib-macro(n) is_halting_on t,Q
   proof let t be State of SCMPDS, Q;
     Fib-macro(n) is_halting_on Initialize t,Q by Lm8;
    hence thesis by SCMPDS_6:126;
   end;
  hence thesis by SCMPDS_6:21;
end;

begin :: The construction of while<>0 loop program

:: while (a,i)<>0 do I

definition
  let a be Int_position, i be Integer;
  let I be Program of SCMPDS;
  func while<>0(a,i,I) -> Program of SCMPDS equals
  (a,i)<>0_goto 2 ';' goto (
  card I+2) ';' I ';' goto -(card I+2);
  coherence;
end;

begin :: The basic property of "while<>0" program

theorem Th12:
  for a be Int_position,i be Integer,I be Program of SCMPDS holds
  card while<>0(a,i,I)= card I +3
proof
  let a be Int_position,i be Integer, I be Program of SCMPDS;
  set i1=(a,i)<>0_goto 2, i2=goto (card I+2);
  set I4=i1 ';' i2 ';' I;
  thus card while<>0(a,i,I) =card I4+1 by SCMP_GCD:4
    .=card (i1 ';' i2)+ card I+1 by AFINSQ_1:17
    .=2+card I +1 by SCMP_GCD:5
    .=card I + 3;
end;

Lm9: for a be Int_position,i be Integer,I be Program of SCMPDS holds card stop
while<>0(a,i,I)= card I+4

proof
  let a be Int_position,i be Integer,I be Program of SCMPDS;
  thus card stop while<>0(a,i,I)= card while<>0(a,i,I) +1 by COMPOS_1:55
    .= card I +3+1 by Th12
    .= card I + 4;
end;

theorem Th13:
  for a be Int_position,i be Integer,m be Element of NAT,I be
  Program of SCMPDS holds m < card I+3 iff  m in dom while<>0(a,i,I)
proof
  let a be Int_position,i be Integer,m be Element of NAT, I be Program of
  SCMPDS;
  card while<>0(a,i,I)=card I + 3 by Th12;
  hence thesis by AFINSQ_1:66;
end;

theorem Th14:
  for a be Int_position,i be Integer,I be Program of SCMPDS holds
   0 in dom while<>0(a,i,I) &  1 in dom while<>0(a,i,I)
proof
  let a be Int_position,i be Integer,I be Program of SCMPDS;
  3 <= card I+3 by NAT_1:11;
  then 0 < card I+3 & 1 < card I+3 by XXREAL_0:2;
  hence thesis by Th13;
end;

theorem Th15:
  for a be Int_position,i be Integer,I be Program of SCMPDS holds
while<>0(a,i,I). 0=(a,i)<>0_goto 2 & while<>0(a,i,I). 1= goto (card
  I +2) & while<>0(a,i,I). (card I+2)=goto -(card I+2)
proof
  let a be Int_position,i be Integer,I be Program of SCMPDS;
  set i1=(a,i)<>0_goto 2, i2=goto (card I+2), i3=goto -(card I+2);
  set I4=i1 ';' i2 ';' I;
  set WHL=while<>0(a,i,I);
A1: WHL=i1 ';' i2 ';' (I ';' i3) by SCMPDS_4:11;
  hence WHL. 0=i1 by Th5;
  thus WHL. 1=i2 by A1,Th5;
  card I4=card (i1 ';' i2)+ card I by AFINSQ_1:17
    .=card I +2 by SCMP_GCD:5;
  hence thesis by SCMP_GCD:6;
end;

Lm10: for a be Int_position,i be Integer,I be Program of SCMPDS holds while<>0
(a,i,I)= ((a,i)<>0_goto 2) ';' (goto (card I+2) ';' I ';' goto -(card I+2))

proof
  let a be Int_position,i be Integer,I be Program of SCMPDS;
  set i1=(a,i)<>0_goto 2, i2=goto (card I+2), i3=goto -(card I+2);
  thus while<>0(a,i,I) = i1 ';' (i2 ';' I) ';' i3 by SCMPDS_4:16
    .= i1 ';' (i2 ';' I ';' i3) by SCMPDS_4:15;
end;

theorem Th16:
  for s being State of SCMPDS,I being Program of SCMPDS,a being
  Int_position, i being Integer st s.DataLoc(s.a,i) = 0 holds while<>0(a,i,I)
  is_closed_on s,P & while<>0(a,i,I) is_halting_on s,P
proof
  let s be State of SCMPDS,I be Program of SCMPDS,a be Int_position, i be
  Integer;
  set b=DataLoc(s.a,i);
  assume
A1: s.b = 0;
  set WHL=while<>0(a,i,I), pWH=stop WHL, iWH=pWH,
  s3 = Initialize s, P3 = P +* pWH,
  s4 = Comput(P3,s3,1), s5 = Comput(P3,s3,2), P4 = P3, P5 = P3;
A3: not b in dom Start-At(0,SCMPDS) by SCMPDS_4:18;
  not a in dom Start-At(0,SCMPDS) by SCMPDS_4:18;
  then
A4: s3.DataLoc(s3.a,i)=s3.b by FUNCT_4:11
    .= 0 by A1,A3,FUNCT_4:11;
  set i1=(a,i)<>0_goto 2, i2=goto (card I+2), i3=goto -(card I+2);
A5: IC s3 = 0 by MEMSTR_0:47;
A6: WHL = i1 ';' (i2 ';' I ';' i3 ) by Lm10;
  Comput(P3,s3,0+1) = Following(P3,
  Comput(P3,s3,0)) by EXTPRO_1:3
    .= Following(P3,s3) by EXTPRO_1:2
    .= Exec(i1,s3) by A6,SCMPDS_6:11;
  then
A7: IC s4 = succ IC s3 by A4,SCMPDS_2:55
    .= (0+1) by A5;
A8: iWH c= P3 by FUNCT_4:25;
  then
A9: pWH c= P4;
A10:  1 in dom WHL by Th14;
  then  1 in dom pWH by COMPOS_1:62;
  then
A11: P4. 1 = pWH. 1 by A9,GRFUNC_1:2
    .=WHL. 1 by A10,COMPOS_1:63
    .=i2 by Th15;
A12: card WHL=card I+3 by Th12;
  then
A13: (card I+3) in dom pWH by COMPOS_1:64;
A14: P4/.IC s4 = P4.IC s4 by PBOOLE:143;
  Comput(P3,s3,1+1) = Following(P3,s4) by EXTPRO_1:3
    .= Exec(i2,s4) by A7,A11,A14;
  then
A16: IC s5 = ICplusConst(s4,card I+2) by SCMPDS_2:54
    .= (card I+2+1) by A7,SCMPDS_6:12
    .= (card I+(2+1));
A17: P5/.IC s5 = P5.IC s5 by PBOOLE:143;
  pWH c= P5 by A8;
  then P5.(card I+3) = pWH.(card I+3) by A13,GRFUNC_1:2
    .=halt SCMPDS by A12,COMPOS_1:64;
  then
A18: CurInstr(P5,s5) = halt SCMPDS by A16,A17;
  now
    let k be Element of NAT;
    k = 0 or 0 < k by NAT_1:3;
    then
A20: k = 0 or 0 + 1 <= k by INT_1:7;
    per cases by A20,XXREAL_0:1;
    suppose
      k = 0;
      then Comput(P3,s3,k) = s3 by EXTPRO_1:2;
      hence IC Comput(P3,s3,k) in dom pWH by A5,COMPOS_1:36;
    end;
    suppose
      k = 1;
      hence IC Comput(P3,s3,k) in dom pWH by A10,A7,COMPOS_1:62;
    end;
    suppose
      1 < k;
      then 1+1 <= k by INT_1:7;
      hence IC Comput(P3,s3,k) in dom pWH
      by A13,A16,A18,EXTPRO_1:5;
    end;
  end;
  hence WHL is_closed_on s,P by SCMPDS_6:def 2;
  P3 halts_on s3 by A18,EXTPRO_1:29;
  hence thesis by SCMPDS_6:def 3;
end;

theorem Th17:
  for s being State of SCMPDS,I being Program of SCMPDS,a,c being
Int_position, i being Integer st s.DataLoc(s.a,i) = 0
 holds IExec(while<>0(a,i,I),P,Initialize s) = s +* Start-At((card I+3),SCMPDS)
proof
  let s be State of SCMPDS,I be Program of SCMPDS, a,c be Int_position, i be
  Integer;
  set b=DataLoc(s.a,i);
  assume
A1: s.b = 0;
  set i1=(a,i)<>0_goto 2, i2=goto (card I+2), i3=goto -(card I+2);
  set WHL=while<>0(a,i,I), pWH=stop WHL, iWH=pWH,
  s3 = Initialize s, P3 = P +* pWH,
  s4 = Comput(P3,s3,1), s5 = Comput(P3,s3,2), P4 = P3, P5 = P3;
A3: IC s3 = 0 by MEMSTR_0:47;
A4: iWH c= P3 by FUNCT_4:25;
  then
A5: pWH c= P4;
A6: pWH c= P5 by A4;
A7: not b in dom Start-At(0,SCMPDS) by SCMPDS_4:18;
A8: WHL = i1 ';' (i2 ';' I ';' i3 ) by Lm10;
A9: Comput(P3,s3,0+1) = Following(P3,
Comput(P3,s3,0)) by EXTPRO_1:3
    .= Following(P3,s3) by EXTPRO_1:2
    .= Exec(i1,s3) by A8,SCMPDS_6:11;
A10:  1 in dom WHL by Th14;
  then  1 in dom pWH by COMPOS_1:62;
  then
A11: P4. 1 = pWH. 1 by A5,GRFUNC_1:2
    .=WHL. 1 by A10,COMPOS_1:63
    .=i2 by Th15;
  set SAl=Start-At((card I+3),SCMPDS);
  not a in dom Start-At(0,SCMPDS) by SCMPDS_4:18;
  then s3.DataLoc(s3.a,i)=s3.b by FUNCT_4:11
    .= 0 by A1,A7,FUNCT_4:11;
  then
A13: IC s4 = succ IC s3 by A9,SCMPDS_2:55
    .= (0+1) by A3;
A16: P3/.IC s4 = P4.IC s4 by PBOOLE:143;
A17: Comput(P3,s3,1+1) = Following(P3,s4) by EXTPRO_1:3
    .= Exec(i2,s4) by A13,A11,A16;
  then
A18: IC s5 = ICplusConst(s4,card I+2) by SCMPDS_2:54
    .= (card I+2+1) by A13,SCMPDS_6:12
    .= (card I+(2+1));
A19: P3/.IC s5 = P5.IC s5 by PBOOLE:143;
A20: card WHL=card I+3 by Th12;
  then (card I+3) in dom pWH by COMPOS_1:64;
  then P5.(card I+3) = pWH.(card I+3) by A6,GRFUNC_1:2
    .=halt SCMPDS by A20,COMPOS_1:64;
  then
A21: CurInstr(P3,s5) = halt SCMPDS by A18,A19;
  then P3 halts_on s3 by EXTPRO_1:29;
  then
A22: s5 = Result(P3,s3) by A21,EXTPRO_1:def 9;
A23: IExec(WHL,P,Initialize s) = Result(P3,s3) by SCMPDS_4:def 5;
A24: now
    let x be set;
A25: dom SAl = {IC SCMPDS} by FUNCOP_1:13;
    assume
A26: x in dom IExec(WHL,P,Initialize s);
    per cases by A26,SCMPDS_4:6;
    suppose
A27:  x is Int_position;
      then x <> IC SCMPDS by SCMPDS_2:43;
      then
A28:  not x in dom SAl by A25,TARSKI:def 1;
TT:   not x in dom Start-At(0,SCMPDS) by A27,SCMPDS_4:18;
      thus IExec(WHL,P,Initialize s).x = s5.x by A22,A23
        .= s4.x by A17,A27,SCMPDS_2:54
        .= s3.x by A9,A27,SCMPDS_2:55
        .= s.x by TT,FUNCT_4:11
        .= (s +* SAl).x by A28,FUNCT_4:11;
    end;
    suppose
A29:  x = IC SCMPDS;
      hence IExec(WHL,P,Initialize s).x = (card I + 3) by A18,A22,A23
        .= (s +* SAl).x by A29,FUNCT_4:113;
    end;
  end;
  dom IExec(WHL,P,Initialize s) = the carrier of SCMPDS by PARTFUN1:def 2
    .= dom (s +* SAl) by PARTFUN1:def 2;
  hence thesis by A24,FUNCT_1:2;
end;

theorem
  for s being State of SCMPDS,I being Program of SCMPDS,a being
Int_position, i being Integer st s.DataLoc(s.a,i) = 0
 holds IC IExec(while<>0(a,i,I),P,Initialize s) =  (card I + 3)
proof
  let s be State of SCMPDS,I be Program of SCMPDS,a be Int_position, i be
  Integer;
  assume s.DataLoc(s.a,i) = 0;
  then IExec(while<>0(a,i,I),P,Initialize s) =s +* Start-At((card I+3),SCMPDS)
  by Th17;
  hence thesis by FUNCT_4:113;
end;

theorem Th19:
  for s being State of SCMPDS,I being Program of SCMPDS,a,b being
Int_position, i being Integer st s.DataLoc(s.a,i) = 0
 holds IExec(while<>0(a,i,I),P,Initialize s).b = s.b
proof
  let s be State of SCMPDS,I be Program of SCMPDS,a,b be Int_position, i be
  Integer;
  assume s.DataLoc(s.a,i) = 0;
  then
A1: IExec(while<>0(a,i,I),P,Initialize s) = s +* Start-At((card I+3),SCMPDS)
 by Th17;
  not b in dom Start-At((card I+3),SCMPDS) by SCMPDS_4:18;
  hence thesis by A1,FUNCT_4:11;
end;

Lm11: for I being Program of SCMPDS,a being Int_position,i being Integer holds
Shift(I,2) c= while<>0(a,i,I)

proof
  let I be Program of SCMPDS,a be Int_position,i be Integer;
  set i1=(a,i)<>0_goto 2, i2=goto (card I+2), i3=goto -(card I+2);

  card (i1 ';' i2)=2 & while<>0(a,i,I) = i1 ';' i2 ';' I ';' Load i3 by
SCMPDS_4:def 3,SCMP_GCD:5;

  hence thesis by SCMPDS_7:3;
end;

registration
  let I be shiftable Program of SCMPDS, a be Int_position,i be Integer;
  cluster while<>0(a,i,I) -> shiftable;
  correctness
  proof
    set WHL=while<>0(a,i,I), i1=(a,i)<>0_goto 2, i2=goto (card I+2), PF= i1
    ';' i2 ';' I;
    card PF=card (i1 ';' i2)+ card I by AFINSQ_1:17
      .=2+card I by SCMP_GCD:5;
    then PF=Load i1 ';' Load i2 ';' I & card PF+ -(card I+2) =0 by
SCMPDS_4:def 4;
    hence thesis by SCMPDS_4:23;
  end;
end;

registration
  let I be halt-free Program of SCMPDS, a be Int_position,i be Integer;
  cluster while<>0(a,i,I) -> halt-free;
  correctness
  proof
    reconsider i2=goto (card I+2) as No-StopCode Instruction of SCMPDS by
SCMPDS_5:21;
    -(card I+2) <> 0;
    then reconsider
    i3=goto -(card I+2) as No-StopCode Instruction of SCMPDS by SCMPDS_5:21;
    while<>0(a,i,I) =(a,i)<>0_goto 2 ';' i2 ';' I ';' i3;
    hence thesis;
  end;
end;

begin :: Computing directly the result of "while<>0" program by loop-invariant

scheme
  WhileNHalt { F(State of SCMPDS)-> Element of NAT,
  s() -> 0-started State of SCMPDS,
  P() -> Instruction-Sequence of SCMPDS,
  I() -> halt-free shiftable Program of SCMPDS,
  a() -> Int_position,i() -> Integer, P[set]}:
  while<>0(a(),i(),I()) is_closed_on s(),P() &
  while<>0(a(),i(),I()) is_halting_on s(),P()
provided
A2: for t be 0-started State of SCMPDS st P[t] & F(t)=0
    holds t.DataLoc(s().a(),i()) = 0 and
A3: P[s()] and
A4: for t be 0-started State of SCMPDS,Q
   st P[t] & t.a()=s().a() & t.DataLoc(s().a(),i()) <> 0
    holds IExec(I(),Q,t).a()=t.a() & I() is_closed_on t,Q &
    I() is_halting_on t,Q & F(Initialize IExec(I(),Q,t)) < F(t)
 & P[Initialize(IExec(I(),Q,t))]
proof
I: Initialize s() = s() by MEMSTR_0:44;
  set i1=(a(),i())<>0_goto 2, i2=goto (card I()+2), i3=goto -(card I()+2);
  set WHL=while<>0(a(),i(),I()), pWH=stop WHL, pI=stop I();
  set b=DataLoc(s().a(),i());
  defpred Q[Element of NAT] means
   for t be 0-started State of SCMPDS,Q st F(Initialize(t)) <=
$1 & P[Initialize t] & t.a()=s().a()
     holds WHL is_closed_on t,Q & WHL is_halting_on t,Q;
A5: for k be Element of NAT st Q[k] holds Q[k + 1]
  proof
    let k be Element of NAT;
    assume
A6: Q[k];
    now
      let t be 0-started State of SCMPDS;
      let Q;
T: Initialize t = t by MEMSTR_0:44;
      assume
A7:   F(Initialize t) <= k+1;
      assume
A8:   P[Initialize t];
      assume
A9:   t.a()=s().a();
      per cases;
      suppose
        t.b = 0;
        hence WHL is_closed_on t,Q & WHL is_halting_on t,Q by A9,Th16;
      end;
      suppose
A10:    t.b <> 0;
A13:    IExec(I(),Q,t).a()=t.a() by A4,A8,A9,A10,T;
A14:     0 in dom pWH by COMPOS_1:36;
A16:    WHL = i1 ';' (i2 ';' I() ';' i3) by Lm10;
A17:    not b in dom Start-At(0,SCMPDS) by SCMPDS_4:18;
        set t2 = Initialize t, Q2 = Q +* pI,
            t3 = Initialize t, Q3 = Q +* pWH,
        t4 = Comput(Q3,t3,1), Q4 = Q3;
A20:    pI c= Q2 by FUNCT_4:25;
        set m2=LifeSpan(Q2,t2), t5=Comput(Q4,t4,m2), Q5 = Q4,
l2= (card I() + 2
);
A21:    IC t3 = 0 by MEMSTR_0:47;
        set m3=m2 +1;
        set t6=Comput(Q3,t3,m3), Q6 = Q3;
        set t7=Comput(Q3,t3,m3+1), Q7 = Q3;
        card I() + 2 < card I() + 3 by XREAL_1:6;
        then
A22:    l2 in dom WHL by Th13;
QQ:     pWH c= Q3 by FUNCT_4:25;
        WHL c= pWH by AFINSQ_1:74;
        then
A23:    WHL c= Q3 by QQ,XBOOLE_1:1;
        Shift(I(),2) c= WHL by Lm11;
        then Shift(I(),2) c= Q3 by A23,XBOOLE_1:1;
        then
A24:    Shift(I(),2) c= Q4;
A25:    Comput(Q3,t3,0+1) = Following(Q3,
Comput(Q3,t3,0)) by EXTPRO_1:3
          .= Following(Q3,t3) by EXTPRO_1:2
          .= Exec(i1,t3) by A16,SCMPDS_6:11;
        for a holds t2.a = t4.a by A25,SCMPDS_2:55;
        then
A27:    DataPart t2 = DataPart t4 by SCMPDS_4:8;
        I() is_halting_on t,Q by A4,A8,A9,A10,T;
        then
A28:    Q2 halts_on t2 by SCMPDS_6:def 3;
        Q2 = Q2+*pI by A20,FUNCT_4:98;
        then Q2+*pI halts_on Initialize t2 by A28;
        then
A30:    I() is_halting_on t2,Q2 by SCMPDS_6:def 3;
A31:    IExec(I(),Q,Initialize t) = Result(Q2,t2) by SCMPDS_4:def 5;
A32:    P[Initialize(IExec(I(),Q,Initialize t))] by A4,A8,A9,A10,T;
A33:    I() is_closed_on t,Q by A4,A8,A9,A10,T;
        then
A34:    I() is_closed_on t2,Q2 by SCMPDS_6:24;
        not a() in dom Start-At(0,SCMPDS) by SCMPDS_4:18;
        then t3.DataLoc(t3.a(),i())= t3.b by A9,FUNCT_4:11
          .= t.b by A17,FUNCT_4:11;
        then
A35:    IC t4 = ICplusConst(t3,2) by A10,A25,SCMPDS_2:55
          .= 0+2 by A21,SCMPDS_6:12;
        then
A36:    IC t5=l2 by A20,A30,A34,A27,A24,SCMPDS_7:18;
A37: Q6/.IC t6 = Q6.IC t6 by PBOOLE:143;
A38:    t6=t5 by EXTPRO_1:4;
        then
A39:    CurInstr(Q6,t6)
           =Q5.l2 by A20,A30,A34,A35,A27,A24,A37,SCMPDS_7:18
          .=Q4.l2
          .=Q3.l2
          .=WHL.l2 by A22,A23,GRFUNC_1:2
          .=i3 by Th15;
A41:    t7 = Following(Q3,t6) by EXTPRO_1:3
          .= Exec(i3,t6) by A39;
        then IC t7=ICplusConst(t6,0-(card I()+2)) by SCMPDS_2:54
          .= 0 by A36,A38,SCMPDS_7:1;
        then
B42:    Initialize t7 = t7 by MEMSTR_0:46;
A42:    Q7 +* pWH=Q7 by FUNCT_4:93;
A43:    DataPart Comput(Q2,t2,m2) = DataPart t5 by A20,A30,A34,A35,A27,A24,
SCMPDS_7:18;
        then
A44:    DataPart t5 = DataPart(Result(Q2,t2)) by A28,EXTPRO_1:23
          .= DataPart(Result(Q2,t2))
          .= DataPart IExec(I(),Q,Initialize t) by SCMPDS_4:def 5;
        InsCode i3=0 by SCMPDS_2:12;
        then InsCode i3 in {0,4,5,6} by ENUMSET1:def 2;
        then
A45:    Initialize(t7)=Initialize(t6) by A41,SCMPDS_8:3
          .=Initialize(IExec(I(),Q,Initialize t)) by A44,A38,MEMSTR_0:80;
A46:    now
          F(Initialize(IExec(I(),Q,Initialize t))) < F(Initialize(t))
           by A4,A8,A9,A10,T;
          then
A47:      F(Initialize(t7)) < k+1 by A7,A45,XXREAL_0:2;
          assume F(Initialize(t7)) > k;
          hence contradiction by A47,INT_1:7;
        end;
A48:    t5.a()=Comput(Q2,t2,m2).a() by A43,SCMPDS_4:8
          .=(Result(Q2,t2)).a() by A28,EXTPRO_1:23
          .=s().a() by A9,A13,A31,T;
A50:    t7.a()=t6.a() by A41,SCMPDS_2:54
          .=s().a() by A48,EXTPRO_1:4;
X1:  (Initialize t7).a() = t7.a() by SCMPDS_5:15;
    P[Initialize (Initialize t7)] by A32,A45;
    then
X3:  WHL is_closed_on (Initialize t7),Q7 &
     WHL is_halting_on (Initialize t7),Q7 by A6,A46,A50,X1;
A51: WHL is_closed_on t7,Q7
      proof
  for k being Element of NAT holds
   IC Comput(Q7+*stop WHL,Initialize Initialize t7,k) in dom stop WHL
          by X3,SCMPDS_6:def 2;
       hence thesis by SCMPDS_6:def 2;
      end;
        now
          let k be Element of NAT;
          per cases;
          suppose
            k < m3+1;
            then
A52:        k <= m3 by INT_1:7;
            hereby
              per cases by A52,NAT_1:8;
              suppose
A53:            k <= m2;
                hereby
                  per cases;
                  suppose
                    k=0;
                    hence IC Comput(Q3,t3,k) in dom pWH by A14,A21,EXTPRO_1:2;
                  end;
                  suppose
                    k<>0;
                    then consider kn be Nat such that
A54:                k=kn+1 by NAT_1:6;
                    reconsider kn as Element of NAT by ORDINAL1:def 12;
                    reconsider lm = IC Comput(Q2,t2,kn) as Element
of NAT;
                    kn < k by A54,XREAL_1:29;
                    then kn < m2 by A53,XXREAL_0:2;
                    then IC Comput(Q2,t2,kn) + 2 = IC Comput(
         Q4,t4,kn) by A20,A30,A34,A35,A27,A24,SCMPDS_7:16;
                    then
A56:                IC Comput(Q3,t3,k) = (lm+2) by A54,EXTPRO_1:4;
                    IC Comput(Q2,t2,kn) in dom pI by A33,SCMPDS_6:def 2;
                    then lm < card pI by AFINSQ_1:66;
                    then lm < card I()+1 by COMPOS_1:55;
                    then
A57:                lm+2 < card I() +1+2 by XREAL_1:6;
                    card I() + 3 < card I() + 4 by XREAL_1:6;
                    then lm+2 < card I() +4 by A57,XXREAL_0:2;
                    then lm+2 < card pWH by Lm9;
                    hence IC Comput(Q3,t3,k) in dom pWH by A56,AFINSQ_1:66;
                  end;
                end;
              end;
              suppose
A58:            k=m3;
                l2 in dom pWH by A22,COMPOS_1:62;
                hence
                IC Comput(Q3,t3,k) in dom pWH by A20,A30,A34,A35,A27,A24,A38
,A58,SCMPDS_7:18;
              end;
            end;
          end;
          suppose
            k >= m3+1;
            then consider nn be Nat such that
A59:        k=m3+1+nn by NAT_1:10;
            reconsider nn as Element of NAT by ORDINAL1:def 12;
    Q3 = Q7+*pWH by FUNCT_4:93;
       then
            Comput(Q3,t3,k)=
            Comput(Q7+*pWH,Initialize t7,nn) by A59,B42,EXTPRO_1:4;
            hence IC Comput(Q3,t3,k) in dom pWH by A51,SCMPDS_6:def 2;
          end;
        end;
        hence WHL is_closed_on t,Q by SCMPDS_6:def 2;
        WHL is_halting_on t7,Q7
        proof
          Q7+*stop WHL halts_on Initialize Initialize t7 by X3,SCMPDS_6:def 3;
         hence thesis by SCMPDS_6:def 3;
        end;
        then Q7 halts_on t7 by A42,B42,SCMPDS_6:def 3;
        then Q3 halts_on t7;
        then Q3 halts_on t3 by EXTPRO_1:22;
        hence WHL is_halting_on t,Q by SCMPDS_6:def 3;
      end;
    end;
    hence thesis;
  end;
  set n=F(s());
A60: Q[0]
  proof
    let t be 0-started State of SCMPDS, Q;
    assume that
A61: F(Initialize t) <= 0 & P[Initialize t] and
A62: t.a()=s().a();
X:  F(Initialize t) >= 0 by NAT_1:2;
    (Initialize t).b = t.b by SCMPDS_5:15;
    then t.b = 0 by A2,A61,X,XXREAL_0:1;
    hence thesis by A62,Th16;
  end;
  for k being Element of NAT holds Q[k] from NAT_1:sch 1(A60,A5);
  then Q[n];
  hence thesis by A3,I;
end;

scheme
  WhileNExec { F(State of SCMPDS)-> Element of NAT,
  s() -> 0-started State of SCMPDS,
  P() -> Instruction-Sequence of SCMPDS,
  I() -> halt-free shiftable Program of SCMPDS,
  a() -> Int_position,i() -> Integer,
P[set]}: IExec(while<>0(a(),i(),I()),P(),s())
 = IExec(while<>0(a(),i(),I()),P(),Initialize IExec(I(),P(),s()))
provided
A2: s().DataLoc(s().a(),i()) <> 0 and
A3: for t be 0-started State of SCMPDS st P[t] & F(t)=0
 holds t.DataLoc(s().a(),i()) = 0 and
A4: P[s()] and
A5: for t be 0-started State of SCMPDS,Q
   st P[t] & t.a()=s().a() & t.DataLoc(
s().a(),i()) <> 0 holds IExec(I(),Q,t).a()=t.a() &
I() is_closed_on t,Q & I()
is_halting_on t,Q & F(Initialize IExec(I(),Q,t)) < F(t)
 & P[Initialize(IExec(I(),Q,t))]
proof
I: Initialize s() = s() by MEMSTR_0:44;
  set WHL=while<>0(a(),i(),I()),
  s1= s(), P1 = P() +* stop WHL;
  set sI= s(), PI = P() +* stop I(),
    m1=LifeSpan(PI,sI)+2,
    s2=Initialize IExec(I(),P(),s()),
    m2=LifeSpan(P1,s2);
A9: stop I() c= PI by FUNCT_4:25;
  I() is_closed_on s(),P() by A2,A4,A5;
  then
A10: I() is_closed_on sI,PI by I,SCMPDS_6:24;
  I() is_halting_on s(),P() by A2,A4,A5;
  then
A11: PI halts_on sI by I,SCMPDS_6:def 3;
  PI = PI+*stop I() by A9,FUNCT_4:98;
  then PI+*stop I() halts_on Initialize sI by A11,I;
  then
A13: I() is_halting_on sI,PI by SCMPDS_6:def 3;
  set s4 = Comput(P1,s1,1), P4 = P1;
  set i1=(a(),i())<>0_goto 2, i2=goto (card I()+2), i3=goto -(card I()+2);
  set b=DataLoc(s().a(),i());
A14: IC s1 = 0 by I,MEMSTR_0:47;
  set mI=LifeSpan(PI,sI), s5=Comput(P4,s4,mI), P5 = P4,
  l2= (
card I() + 2);
A15: WHL = i1 ';' (i2 ';' I() ';' i3) by Lm10;
  set m3=mI +1;
  set s6=Comput(P1,s1,m3), P6 = P1;
  card I() + 2 < card I() + 3 by XREAL_1:6;
  then
A16: l2 in dom WHL by Th13;
  set s7=Comput(P1,s1,m3+1), P7 = P1;
A17: IExec(I(),P(),s()) = Result(PI,sI) by SCMPDS_4:def 5;
QQ: stop WHL c= P1 by FUNCT_4:25;
  WHL c= stop WHL by AFINSQ_1:74;
  then
A19: WHL c= P1 by QQ,XBOOLE_1:1;
  deffunc F(State of SCMPDS) = F($1);
A20: for t be 0-started State of SCMPDS st P[t] & F(t)=0
  holds t.DataLoc (s().a(),i()) = 0 by A3;
A21: for t be 0-started State of SCMPDS,Q
     st P[t] & t.a()=s().a() & t.DataLoc(s().
  a(),i()) <> 0 holds IExec(I(),Q,t).a()=t.a() &
  I() is_closed_on t,Q & I()
is_halting_on t,Q & F(Initialize IExec(I(),Q,t)) < F(t)
 & P[Initialize(IExec(I(),Q,t))] by A5;
A22: Comput(P1,s1,0+1) = Following(P1,
Comput(P1,s1,0)) by EXTPRO_1:3
    .= Following(P1,s1) by EXTPRO_1:2
    .= Exec(i1,s1) by A15,I,SCMPDS_6:11;
  Shift(I(),2) c= WHL by Lm11;
  then Shift(I(),2) c= P1 by A19,XBOOLE_1:1;
  then
A23: Shift(I(),2) c= P4;
  for a holds sI.a = s4.a by A22,SCMPDS_2:55;
  then
A25: DataPart sI = DataPart s4 by SCMPDS_4:8;
A26: IC s4 = ICplusConst(s1,2) by A2,A22,SCMPDS_2:55
    .= (0+2) by A14,SCMPDS_6:12;
  then
A27: IC s5=l2 by A9,A13,A10,A25,A23,SCMPDS_7:18;
A28: P6/.IC s6 = P6.IC s6 by PBOOLE:143;
A29: s6=s5 by EXTPRO_1:4;
  then
A30: CurInstr(P6,s6)=P5.l2 by A9,A13,A10,A26,A25,A23,A28,SCMPDS_7:18
    .=P4.l2
    .=P1.l2
    .=WHL.l2 by A16,A19,GRFUNC_1:2
    .=i3 by Th15;
A32: s7 = Following(P1,s6) by EXTPRO_1:3
    .= Exec(i3,s6) by A30;
  then IC s7=ICplusConst(s6,0-(card I()+2)) by SCMPDS_2:54
    .= 0 by A27,A29,SCMPDS_7:1;
  then
A33: IC s2 =IC Comput(P1,s1,m1) by MEMSTR_0:47;
A34: DataPart Comput(PI,sI,mI) = DataPart s5 by A9,A13,A10,A26,A25,A23,
SCMPDS_7:18;
  now
    let x be Int_position;
A35: not x in dom Start-At(0,SCMPDS) by SCMPDS_4:18;
    s5.x=Comput(PI,sI,mI).x by A34,SCMPDS_4:8
      .=(Result(PI,sI)).x by A11,EXTPRO_1:23
      .=IExec(I(),P(),s()).x by A17;
    hence s7.x=IExec(I(),P(),s()).x by A29,A32,SCMPDS_2:54
      .=s2.x by A35,FUNCT_4:11;
  end;
  then
A37: DataPart s7 = DataPart s2 by SCMPDS_4:8;
  set m0=LifeSpan(P1,s1);
A40: P[s()] by A4;
  WHL is_closed_on s(),P() & WHL is_halting_on s(),P()
   from WhileNHalt(A20,A40,A21);
  then
A41: P1 halts_on s1 by I,SCMPDS_6:def 3;
  deffunc F(State of SCMPDS) = F($1);
  set Es=IExec(I(),P(),s()), bj=DataLoc(Es.a(),i()), EP = P();
A42: IExec(I(),P(),s()).a()=s().a() by A2,A4,A5;
U1: (Initialize Es).a() = Es.a() by SCMPDS_5:15;
A43: for t be 0-started State of SCMPDS
 st P[t] & F(t)=0
 holds t.DataLoc((Initialize Es).a(),i()) = 0 by A3,A42,U1;
A45: P[Initialize Es] by A2,A4,A5;
A44: for t be 0-started State of SCMPDS,Q
   st P[t] & t.a()=(Initialize Es).a() &
      t.DataLoc((Initialize Es).a(),i()) <> 0
    holds IExec(I(),Q,t).a()=t.a() & I() is_closed_on t,Q &
    I() is_halting_on t,Q & F(Initialize IExec(I(),Q,t)) < F(t)
 & P[Initialize(IExec(I(),Q,t))] by A5,A42,U1;
XXX:  WHL is_closed_on Initialize Es,P() &
  WHL is_halting_on Initialize Es,P() from WhileNHalt(A43,A45,A44);
  WHL is_halting_on Es,P()
   proof
     P()+*stop WHL halts_on Initialize Initialize Es by XXX,SCMPDS_6:def 3;
    hence thesis by SCMPDS_6:def 3;
   end;
  then
A46: P1 halts_on s2 by SCMPDS_6:def 3;
A48: Comput(P1,s1,m1)=s2 by A37,A33,MEMSTR_0:78;
  then CurInstr(P1,Comput(P1,s1,m1)) =i1 by A15,SCMPDS_6:11;
  then m0 > m1 by A41,EXTPRO_1:36,SCMPDS_6:16;
  then consider nn be Nat such that
A49: m0=m1+nn by NAT_1:10;
  reconsider nn as Element of NAT by ORDINAL1:def 12;
  IC Comput(P1,s1,m1+m2) = IC Comput(P1,s2,m2) by A48,EXTPRO_1:4;
  then CurInstr(P1,Comput(P1,s1,m1+m2))
    = CurInstr(P1,Comput(P1,s2,m2))
   .= halt SCMPDS by A46,EXTPRO_1:def 15;
  then m1 + m2 >= m0 by A41,EXTPRO_1:def 15;
  then
A51: m2 >= nn by A49,XREAL_1:6;
A52: Comput(P1,s1,m0) = Comput(P1,s2,nn) by A48,A49,EXTPRO_1:4;
  then CurInstr(P1,Comput(P1,s2,nn))
   =halt SCMPDS by A41,EXTPRO_1:def 15;
  then nn >= m2 by A46,EXTPRO_1:def 15;
  then nn=m2 by A51,XXREAL_0:1;
  then Result(P1,s1) = Comput(P1,s2,m2) by A41,A52,EXTPRO_1:23;
  hence IExec(WHL,P(),s()) = Comput(P1,s2,m2) by SCMPDS_4:def 5
    .= Result(P1,s2) by A46,EXTPRO_1:23
    .= IExec(WHL,P(),Initialize IExec(I(),P(),s()))
     by SCMPDS_4:def 5;
end;

scheme
  WhileNEnd { F(State of SCMPDS)-> Element of NAT,
  s() -> 0-started State of SCMPDS,
  P() -> Instruction-Sequence of SCMPDS,
  I() -> halt-free shiftable Program of SCMPDS,
  a() -> Int_position,i() -> Integer,
P[set]}: F(Initialize IExec(while<>0(a(),i(),I()),P(),s()))=0
 & P[Initialize IExec(while<>0(a(),i(),I()),P(),s())]
provided
A2: for t be 0-started State of SCMPDS
 st P[t] holds F(t)=0 iff t.
DataLoc(s().a(),i()) = 0 and
A3: P[s()] and
A4: for t be 0-started State of SCMPDS,Q
  st P[t] & t.a()=s().a() & t.DataLoc(
s().a(),i()) <> 0 holds IExec(I(),Q,t).a()=t.a() &
I() is_closed_on t,Q & I()
is_halting_on t,Q & F(Initialize IExec(I(),Q,t)) < F(t)
 & P[Initialize(IExec(I(),Q,t))]
proof
  set b=DataLoc(s().a(),i()), WHL=while<>0(a(),i(),I());
  defpred Q[Element of NAT] means
   for t be 0-started State of SCMPDS,Q st F(t) <= $1
    & t.a()=s().a() & P[t]
  holds F(Initialize IExec(WHL,Q,t))=0 & P[Initialize IExec(WHL,Q,t)];
A5: Q[0]
  proof
    let t be 0-started State of SCMPDS, Q;
T: Initialize t = t by MEMSTR_0:44;
    assume that
A6: F(t) <= 0 and
A7: t.a()=s().a() and
A8: P[t];
    F(t) >= 0 by NAT_1:2;
    then
A9: F(t)=0 by A6,XXREAL_0:1;
    then t.DataLoc(t.a(),i()) = 0 by A2,A7,A8;
    then for b be Int_position holds IExec(WHL,Q,t).b = t.b by Th19,T;
    hence thesis by A8,A9,T,SCPISORT:4;
  end;
A10: now
    let k be Element of NAT;
    assume
A11: Q[k];
    now
      let u be 0-started State of SCMPDS;
      let U;
      assume that
A12:  F(u) <= k+1 and
A13:  u.a()=s().a() and
A14:  P[u];
      per cases;
      suppose
        F(u)=0;
        hence F(Initialize IExec(WHL,U,u))=0 & P[Initialize IExec(WHL,U,u)]
         by A5,A13,A14;
      end;
      suppose
A15:    F(u) <> 0;
        set Iu=IExec(I(),U,u);
A16:    u.b <> 0 by A2,A14,A15;
        then
A17:    Iu.a()=s().a() & P[Initialize Iu] by A4,A13,A14;
        deffunc F(State of SCMPDS) = F($1);
A18:    P[u] by A14;
A19:    for t be 0-started State of SCMPDS st P[t] & F(t)=0
         holds t.DataLoc(u.a(),i()) = 0 by A2,A13;
        F(Initialize Iu) < F(u) by A4,A13,A14,A16;
        then F(Initialize Iu)+1 <= F(u) by INT_1:7;
        then F(Initialize Iu)+1 <= k+1 by A12,XXREAL_0:2;
        then
A20:    F(Initialize Iu) <= k by XREAL_1:6;
A21:    for t being 0-started State of SCMPDS,Q
        st P[t] & t.a()=u.a() & t.DataLoc(u.a(),i()) <> 0
         holds IExec(I(),Q,t).a()=t.a()
         & I() is_closed_on t,Q &
          I() is_halting_on t,Q & F(Initialize IExec(I(),Q,t)) < F(t)
         & P[Initialize(IExec(I(),Q,t))] by A4,A13;
A22:    u.DataLoc(u.a(),i()) <> 0 by A2,A13,A14,A15;
XX:     IExec(WHL,U,u) = IExec(WHL,U,Initialize Iu)
         from WhileNExec(A22,A19,A18,A21);
         (Initialize Iu).a() = Iu.a() by SCMPDS_5:15;
       hence F(Initialize IExec(WHL,U,u))=0 &
        P[Initialize IExec(WHL,U,u)] by A11,A20,A17,XX;
      end;
    end;
    hence Q[k+1];
  end;
  for k being Element of NAT holds Q[k] from NAT_1:sch 1(A5,A10);
  then Q[F(s())];
  hence thesis by A3;
end;

theorem Th20:
  for s being 0-started State of SCMPDS,I being halt-free shiftable
Program of SCMPDS, a,b,c be Int_position,i,d be Integer st card I > 0 & s.a=d &
s.b > 0 & s.c > 0 & s.DataLoc(d,i)=s.b-s.c &
 (for t be 0-started State of SCMPDS,Q st t.b >
0 & t.c > 0 & t.a=d & t.DataLoc(d,i)=t.b-t.c & t.b<>t.c
 holds IExec(I,Q,t).a=d &
I is_closed_on t,Q & I is_halting_on t,Q
 & (t.b > t.c implies IExec(I,Q,t).b=t.b-t.c
& IExec(I,Q,t).c = t.c) & (t.b <= t.c
 implies IExec(I,Q,t).c = t.c-t.b & IExec(I,Q,t)
.b=t.b) & IExec(I,Q,t).DataLoc(d,i)=
IExec(I,Q,t).b-IExec(I,Q,t).c)
 holds while<>0(a,i,I) is_closed_on s,P & while<>0(a,i,I) is_halting_on s,P
   & (s.DataLoc(s.a,i) <> 0
  implies IExec(while<>0(a,i,I),P,s) =
  IExec(while<>0(a,i,I),P,Initialize IExec(I,P,s)))
proof
  let s be 0-started State of SCMPDS,
      I be halt-free shiftable Program of SCMPDS, a,b,c
  be Int_position, i,d be Integer;
  set ci=DataLoc(s.a,i);
  assume
 card I > 0;
  consider f be Function of product the Object-Kind of SCMPDS,NAT such that
A2: for s be State of SCMPDS holds (s.b = s.c implies f.s =0) & (s.b <>
  s.c implies f.s=max(abs(s.b),abs(s.c))) by Th6;
  deffunc F(State of SCMPDS) = f.$1;
  defpred P[set] means ex t be State of SCMPDS st t=$1 & t.b > 0 & t.c > 0 & t
  .DataLoc(d,i)=t.b-t.c;
  assume that
A3: s.a=d and
A4: s.b > 0 and
A5: s.c > 0 and
A6: s.DataLoc(d,i)=s.b-s.c;
  assume
A7: for t be 0-started State of SCMPDS,Q
   st t.b > 0 & t.c > 0 & t.a=d & t.DataLoc(d,
i)=t.b-t.c & t.b<>t.c holds IExec(I,Q,t).a=d
 & I is_closed_on t,Q & I is_halting_on
t,Q & (t.b > t.c implies IExec(I,Q,t).b=t.b-t.c
 & IExec(I,Q,t).c = t.c) & (t.b <= t.c
  implies IExec(I,Q,t).c = t.c-t.b
   & IExec(I,Q,t).b=t.b) & IExec(I,Q,t).DataLoc(d,i)=
  IExec(I,Q,t).b-IExec(I,Q,t).c;
A8: now
    let t be 0-started State of SCMPDS, Q;
    assume that
A9: P[t] and
A10: t.a=s.a and
A11: t.ci <> 0;
    set It=IExec(I,Q,t), t2=Initialize It, t1=t;
    set x=IExec(I,Q,t).b, y=IExec(I,Q,t).c;
    consider v be State of SCMPDS such that
A12: v=t and
A13: v.b > 0 and
A14: v.c > 0 and
A15: v.DataLoc(d,i)=v.b-v.c by A9;
A16: t.b > 0 by A12,A13;
A17: t.c > 0 by A12,A14;
A18: t.DataLoc(d,i)=v.b-v.c by A12,A15
      .=t.b-v.c by A12
      .=t.b-t.c by A12;
    then
A19: t.b<>t.c by A3,A11;
    hence IExec(I,Q,t).a=t.a by A3,A7,A10,A16,A17,A18;
    thus I is_closed_on t,Q & I is_halting_on t,Q by A3,A7,A10,A16,A17,A18,A19;
A20: now
      per cases;
      suppose
A21:    t.b > t.c;
        then t.b-t.c > 0 by XREAL_1:50;
        hence x > 0 by A3,A7,A10,A16,A17,A18,A21;
        thus y > 0 by A3,A7,A10,A16,A17,A18,A21;
A22:    x=t.b-t.c by A3,A7,A10,A16,A17,A18,A21;
        hereby
A23:      max(t.b,t.c)=t.b by A21,XXREAL_0:def 10;
          per cases by XXREAL_0:16;
          suppose
            max(x,y) = x;
            hence max(x,y) < max(t.b,t.c) by A17,A22,A23,XREAL_1:44;
          end;
          suppose
            max(x,y) = y;
            hence max(x,y) < max(t.b,t.c) by A3,A7,A10,A16,A17,A18,A21,A23;
          end;
        end;
      end;
      suppose
A24:    t.b <= t.c;
        hence x > 0 by A3,A7,A10,A16,A17,A18,A19;
        t.b < t.c by A19,A24,XXREAL_0:1;
        then t.c-t.b > 0 by XREAL_1:50;
        hence y > 0 by A3,A7,A10,A16,A17,A18,A19,A24;
A25:    y=t.c-t.b by A3,A7,A10,A16,A17,A18,A19,A24;
A26:    x=t.b by A3,A7,A10,A16,A17,A18,A19,A24;
        hereby
A27:      max(t.b,t.c)=t.c by A24,XXREAL_0:def 10;
          per cases by XXREAL_0:16;
          suppose
            max(x,y) = y;
            hence max(x,y) < max(t.b,t.c) by A16,A25,A27,XREAL_1:44;
          end;
          suppose
            max(x,y) = x;
            hence max(x,y) < max(t.b,t.c) by A19,A24,A26,A27,XXREAL_0:1;
          end;
        end;
      end;
    end;
    thus F(t2) < F(t1)
    proof
      t1.b <> t.c by A19;
      then t1.b <> t1.c;
      then
A28:  F(t1)=max(abs(t1.b),abs(t1.c)) by A2
        .=max(abs(t.b),abs(t1.c))
        .=max(abs(t.b),abs(t.c))
        .=max( t.b,abs(t.c)) by A16,ABSVALUE:def 1
        .=max(t.b,t.c) by A17,ABSVALUE:def 1;
      then F(t1) >= t.b by XXREAL_0:25;
      then
A29:  F(t1) > 0 by A16,XXREAL_0:2;
      per cases;
      suppose
        t2.b=t2.c;
        hence thesis by A2,A29;
      end;
      suppose
        t2.b<>t2.c;
        then F(t2)=max(abs(t2.b),abs(t2.c)) by A2
          .=max(abs(x),abs(t2.c)) by SCMPDS_5:15
          .=max(abs(x),abs(y)) by SCMPDS_5:15
          .=max( x,abs(y)) by A20,ABSVALUE:def 1
          .=max(x,y) by A20,ABSVALUE:def 1;
        hence thesis by A20,A28;
      end;
    end;
A30: IExec(I,Q,t).DataLoc(d,i)=
     IExec(I,Q,t).b-IExec(I,Q,t).c
 by A3,A7,A10,A16,A17,A18,A19;
    thus P[Initialize It]
    proof
      take v=Initialize It;
      thus v=Initialize It;
      thus v.b > 0 & v.c > 0 by A20,SCMPDS_5:15;
      thus v.DataLoc(d,i)=x-y by A30,SCMPDS_5:15
        .=v.b-y by SCMPDS_5:15
        .=v.b-v.c by SCMPDS_5:15;
    end;
  end;
A31: for t be 0-started State of SCMPDS st P[t] &
F(t)=0 holds t.ci = 0
  proof
    let t be 0-started State of SCMPDS;
    assume that
A32: P[t] and
A33: F(t)=0;
    consider v be State of SCMPDS such that
A34: v=t and
A35: v.b > 0 and
    v.c > 0 and
A36: v.DataLoc(d,i)=v.b-v.c by A32;
A37: now
      assume t.b <> t.c;
      then (t).b <> t.c;
      then (t).b <> (t).c;
      then
A38:  F(t)=max(abs((t).b),abs((t).c)) by A2
        .=max(abs(t.b),abs(t.c))
        .=max(abs(t.b),abs(t.c));
      t.b > 0 by A34,A35;
      then abs(t.b) > 0 by COMPLEX1:47;
      hence contradiction by A33,A38,XXREAL_0:25;
    end;
    thus t.ci=v.b-v.c by A3,A34,A36
      .=t.b-v.c by A34
      .=t.b-t.c by A34
      .=0 by A37;
  end;
A39: P[s] by A4,A5,A6;
  while<>0(a,i,I) is_closed_on s,P & while<>0(a,i,I) is_halting_on s,P
   from WhileNHalt(A31,A39,A8);
  hence while<>0(a,i,I) is_closed_on s,P & while<>0(a,i,I) is_halting_on s,P;
  assume
A40: s.DataLoc(s.a,i) <> 0;
  IExec(while<>0(a,i,I),P,s) =
  IExec(while<>0(a,i,I),P,Initialize IExec(I,P,s))
   from WhileNExec(A40,A31,A39,A8);
  hence thesis;
end;

begin :: An example: computing Greatest Common Divisor(Euclide algorithm)


::   by loop-invariant
:: gcd(x,y)     < x=(GBP,1) y=(GBP,2),(GBP,3)=x-y >
:: while x<>y do
:: if x>y then x=x-y else y=y-x

definition
  func GCD-Algorithm -> Program of SCMPDS equals
  (GBP:=0) ';' (GBP,3):=(GBP,1)
';' SubFrom(GBP,3,GBP,2) ';' while<>0(GBP,3, if>0(GBP,3,Load SubFrom(GBP,1,GBP,
2), Load SubFrom(GBP,2,GBP,1)) ';' (GBP,3):=(GBP,1) ';' SubFrom(GBP,3,GBP,2) );
  coherence;
end;

theorem Th21:
  for s being 0-started State of SCMPDS,I being halt-free shiftable
Program of SCMPDS, a,b,c be Int_position,i,d be Integer st
s.a=d &
s.b > 0 & s.c > 0 & s.DataLoc(d,i)=s.b-s.c &
 (for t be 0-started State of SCMPDS,Q st t.b >
0 & t.c > 0 & t.a=d & t.DataLoc(d,i)=t.b-t.c & t.b<>t.c
 holds IExec(I,Q,t).a=d &
I is_closed_on t,Q & I is_halting_on t,Q
 & (t.b > t.c implies IExec(I,Q,t).b=t.b-t.c
& IExec(I,Q,t).c = t.c) & (t.b <= t.c
 implies IExec(I,Q,t).c = t.c-t.b & IExec(I,Q,t)
  .b=t.b) & IExec(I,Q,t).DataLoc(d,i)=
  IExec(I,Q,t).b-IExec(I,Q,t).c)
   holds IExec(while<>0(a,i,I),P,s).b = s.b gcd s.c
   & IExec(while<>0(a,i,I),P,s).c = s.b gcd s.c
proof
  let s be 0-started State of SCMPDS,
      I be halt-free shiftable Program of SCMPDS, a,b,c
  be Int_position, i,d be Integer;
  set ci=DataLoc(s.a,i);
  consider f be Function of product the Object-Kind of SCMPDS,NAT such that
A2: for s be State of SCMPDS holds (s.b = s.c implies f.s =0) & (s.b <>
  s.c implies f.s=max(abs(s.b),abs(s.c))) by Th6;
  deffunc F(State of SCMPDS) = f.$1;
  set s1=IExec(while<>0(a,i,I),P,s), ss= s1;
  defpred P[set] means
   ex t be 0-started State of SCMPDS st t=$1 & t.b > 0 & t.c > 0
    & t.b gcd t.c =s.b gcd s.c & t.DataLoc(d,i)=t.b-t.c;
  assume that
A3: s.a=d and
A4: s.b > 0 and
A5: s.c > 0 and
A6: s.DataLoc(d,i)=s.b-s.c;
  assume
A7: for t be 0-started State of SCMPDS,Q
   st t.b > 0 & t.c > 0 & t.a=d & t.DataLoc(d,
i)=t.b-t.c & t.b<>t.c holds IExec(I,Q,t).a=d
 & I is_closed_on t,Q & I is_halting_on
t,Q & (t.b > t.c implies IExec(I,Q,t).b=t.b-t.c &
IExec(I,Q,t).c = t.c)
 & (t.b <= t.c implies IExec(I,Q,t).c = t.c-t.b & IExec(I,Q,t).b=t.b)
   & IExec(I,Q,t).DataLoc(d,i)=IExec(I,Q,t).b-IExec(I,Q,t).c;
A8: now
    let t be 0-started State of SCMPDS, Q;
    assume that
A9: P[t] and
A10: t.a=s.a and
A11: t.ci <> 0;
    set It=IExec(I,Q,t), t2=Initialize It, t1=t;
    set x=IExec(I,Q,t).b, y=IExec(I,Q,t).c;
    consider v be State of SCMPDS such that
A12: v=t and
A13: v.b > 0 and
A14: v.c > 0 and
A15: v.b gcd v.c =s.b gcd s.c and
A16: v.DataLoc(d,i)=v.b-v.c by A9;
A17: t.b > 0 by A12,A13;
A18: t.c > 0 by A12,A14;
A19: t.DataLoc(d,i)=v.b-v.c by A12,A16
      .=t.b-v.c by A12
      .=t.b-t.c by A12;
    then
A20: t.b > t.c implies IExec(I,Q,t).b=t.b-t.c &
IExec(I,Q,t).c = t.c
 by A3,A7,A10,A17,A18;
A21: t.b<>t.c by A3,A11,A19;
    hence IExec(I,Q,t).a=t.a by A3,A7,A10,A17,A18,A19;
    thus I is_closed_on t,Q & I is_halting_on t,Q by A3,A7,A10,A17,A18,A19,A21;
A22: t.b <= t.c implies IExec(I,Q,t).c =t.c-t.b &
IExec(I,Q,t).b=t.b
 by A3,A7,A10,A17,A18,A19,A21;
A23: now
      per cases;
      suppose
A24:    t.b > t.c;
        then t.b-t.c > 0 by XREAL_1:50;
        hence x > 0 by A3,A7,A10,A17,A18,A19,A24;
        thus y > 0 by A3,A7,A10,A17,A18,A19,A24;
        thus x gcd y = t.b gcd t.c by A17,A18,A20,A22,PREPOWER:97;
A25:    x=t.b-t.c by A3,A7,A10,A17,A18,A19,A24;
        hereby
A26:      max(t.b,t.c)=t.b by A24,XXREAL_0:def 10;
          per cases by XXREAL_0:16;
          suppose
            max(x,y) = x;
            hence max(x,y) < max(t.b,t.c) by A18,A25,A26,XREAL_1:44;
          end;
          suppose
            max(x,y) = y;
            hence max(x,y) < max(t.b,t.c) by A3,A7,A10,A17,A18,A19,A24,A26;
          end;
        end;
      end;
      suppose
A27:    t.b <= t.c;
        hence x > 0 by A3,A7,A10,A17,A18,A19,A21;
        t.b < t.c by A21,A27,XXREAL_0:1;
        then t.c-t.b > 0 by XREAL_1:50;
        hence y > 0 by A3,A7,A10,A17,A18,A19,A21,A27;
        thus x gcd y =t.b gcd t.c by A17,A18,A20,A22,PREPOWER:97;
A28:    y=t.c-t.b by A3,A7,A10,A17,A18,A19,A21,A27;
A29:    x=t.b by A3,A7,A10,A17,A18,A19,A21,A27;
        hereby
A30:      max(t.b,t.c)=t.c by A27,XXREAL_0:def 10;
          per cases by XXREAL_0:16;
          suppose
            max(x,y) = y;
            hence max(x,y) < max(t.b,t.c) by A17,A28,A30,XREAL_1:44;
          end;
          suppose
            max(x,y) = x;
            hence max(x,y) < max(t.b,t.c) by A21,A27,A29,A30,XXREAL_0:1;
          end;
        end;
      end;
    end;
    thus F(t2) < F(t1)
    proof
      t1.b <> t.c by A21;
      then t1.b <> t1.c;
      then
A31:  F(t1)=max(abs(t1.b),abs(t1.c)) by A2
        .=max(abs(t.b),abs(t1.c))
        .=max(abs(t.b),abs(t.c))
        .=max( t.b,abs(t.c)) by A17,ABSVALUE:def 1
        .=max(t.b,t.c) by A18,ABSVALUE:def 1;
      then F(t1) >= t.b by XXREAL_0:25;
      then
A32:  F(t1) > 0 by A17,XXREAL_0:2;
      per cases;
      suppose
        t2.b=t2.c;
        hence thesis by A2,A32;
      end;
      suppose
        t2.b<>t2.c;
        then F(t2)=max(abs(t2.b),abs(t2.c)) by A2
          .=max(abs(x),abs(t2.c)) by SCMPDS_5:15
          .=max(abs(x),abs(y)) by SCMPDS_5:15
          .=max( x,abs(y)) by A23,ABSVALUE:def 1
          .=max(x,y) by A23,ABSVALUE:def 1;
        hence thesis by A23,A31;
      end;
    end;
A33: IExec(I,Q,t).DataLoc(d,i)= IExec(I,Q,t).b-IExec(I,Q,t).c
         by A3,A7,A10,A17,A18,A19,A21;
    thus P[Initialize It]
    proof
      take u=Initialize It;
      thus u=Initialize It;
      thus u.b > 0 & u.c > 0 by A23,SCMPDS_5:15;
      thus u.b gcd u.c =It.b gcd u.c by SCMPDS_5:15
        .=t.b gcd t.c by A23,SCMPDS_5:15
        .=v.b gcd t.c by A12
        .=s.b gcd s.c by A12,A15;
      thus u.DataLoc(d,i)=x-y by A33,SCMPDS_5:15
        .=u.b-y by SCMPDS_5:15
        .=u.b-u.c by SCMPDS_5:15;
    end;
  end;
A34: for t be 0-started State of SCMPDS st P[t] holds
   F(t)=0 iff t.ci = 0
  proof
    let t be 0-started State of SCMPDS;
    assume P[t];
    then consider v be State of SCMPDS such that
A35: v=t and
A36: v.b > 0 and
    v.c > 0 and
    v.b gcd v.c =s.b gcd s.c and
A37: v.DataLoc(d,i)=v.b-v.c;
A38: t.ci=v.b-v.c by A3,A35,A37
      .=t.b-v.c by A35
      .=t.b-t.c by A35;
    hereby
      assume
A39:  F(t)=0;
      now
        assume t.b <> t.c;
        then (t).b <> t.c;
        then (t).b <> (t).c;
        then
A40:    F(t)=max(abs((t).b),abs((t).c)) by A2
          .=max(abs(t.b),abs((t).c))
          .=max(abs(t.b),abs(t.c));
        t.b > 0 by A35,A36;
        then abs(t.b) > 0 by COMPLEX1:47;
        hence contradiction by A39,A40,XXREAL_0:25;
      end;
      hence t.ci=0 by A38;
    end;
   thus t.ci=0 implies F(t)=0 by A2,A38;
  end;
A41: P[s] by A4,A5,A6;
A42: F(Initialize ss)=0 & P[Initialize ss] from WhileNEnd(A34,A41,A8);
  then consider w be 0-started State of SCMPDS such that
A43: w=Initialize ss and
A44: w.b > 0 and
  w.c > 0 and
A45: w.b gcd w.c =s.b gcd s.c and
A46: w.DataLoc(d,i)=w.b-w.c;
CI:  (Initialize ss).ci = ss.ci by SCMPDS_5:15;
B:  (Initialize ss).b = ss.b by SCMPDS_5:15;
C:  (Initialize ss).c = ss.c by SCMPDS_5:15;
A47: w.b-w.c =s1.ci by A3,A43,A46,SCMPDS_5:15
    .=0 by A34,A42,CI;
  then
A48: abs(w.b)=abs(w.b) gcd abs(w.c) by NAT_D:32
    .=s.b gcd s.c by A45,INT_2:34;
  thus IExec(while<>0(a,i,I),P,s).b=ss.b
    .=s.b gcd s.c by A43,A44,A48,B,ABSVALUE:def 1;
  thus IExec(while<>0(a,i,I),P,s).c =ss.c
    .=s.b gcd s.c by A43,A44,A47,A48,C,ABSVALUE:def 1;
end;

set i1= GBP:=0, i2= (GBP,3):=(GBP,1), i3= SubFrom(GBP,3,GBP,2), j1= Load
SubFrom(GBP,1,GBP,2), j2= Load SubFrom(GBP,2,GBP,1), IF= if>0(GBP,3,j1,j2), k1=
(GBP,3):=(GBP,1), k2= SubFrom(GBP,3,GBP,2), WB= IF ';' k1 ';' k2, WH= while<>0(
GBP,3,WB);

Lm12: card WB=6
proof
  thus card WB=card (IF ';' k1)+1 by SCMP_GCD:4
    .=card IF +1+1 by SCMP_GCD:4
    .=card j1+card j2 +2+1+1 by SCMPDS_6:65
    .= 1+card j2 +2+1+1 by COMPOS_1:54
    .= 1+1+2+1+1 by COMPOS_1:54
    .=6;
end;

Lm13: card WH=9
proof
  thus card WH=6+3 by Lm12,Th12
    .=9;
end;

theorem
  card GCD-Algorithm=12
proof
  thus card GCD-Algorithm=card (i1 ';' i2 ';' i3) + card WH by AFINSQ_1:17
    .=card (i1 ';' i2) +1+ card WH by SCMP_GCD:4
    .=2+1+ 9 by Lm13,SCMP_GCD:5
    .=12;
end;

Lm14: for s being 0-started State of SCMPDS st s.GBP=0 holds
 (s.a3 > 0 implies IExec(WB,P,s).a1=s.a1-s.a2 &
 IExec(WB,P,s).a2 = s.a2)
 & (s.a3 <= 0 implies IExec(WB,P,s).a2=s.a2-s.a1 &
  IExec(WB,P,s).a1=s.a1) & IExec(WB,P,s).GBP=0
 & IExec(WB,P,s).a3=IExec(WB,P,s).a1-IExec(WB,P,s).a2
proof
  let s be 0-started State of SCMPDS;
  set s1=IExec(IF,P,s),
  s2=IExec(IF ';' k1,P,s), a=GBP, t0 = s,
  Q0 = P;
A4: now
    assume
A5: s1.GBP=0;
    then
A6: DataLoc(s1.a,3)=intpos (0+3) by SCMP_GCD:1;
A7: s2.a3 =Exec(k1, s1).a3 by SCMPDS_5:41
      .=s1.DataLoc(s1.a,1) by A6,SCMPDS_2:47
      .=s1.intpos (0+1) by A5,SCMP_GCD:1;
    1 <> abs(s1.GBP+3) by A5,ABSVALUE:def 1;
    then
A8: a1 <> DataLoc(s1.GBP,3) by ZFMISC_1:27;
A9: s2.a1 =Exec(k1, s1).a1 by SCMPDS_5:41
      .=s1.a1 by A8,SCMPDS_2:47;
    2 <> abs(s1.GBP+3) by A5,ABSVALUE:def 1;
    then
A10: a2 <> DataLoc(s1.GBP,3) by ZFMISC_1:27;
A11: s2.a2 =Exec(k1, s1).a2 by SCMPDS_5:41
      .=s1.a2 by A10,SCMPDS_2:47;
    0 <> abs(s1.GBP+3) by A5,ABSVALUE:def 1;
    then
A12: a <> DataLoc(s1.GBP,3) by ZFMISC_1:27;
A13: s2.a =Exec(k1, s1).a by SCMPDS_5:41
      .=0 by A5,A12,SCMPDS_2:47;
    then
A14: DataLoc(s2.a,3)=intpos (0+3) by SCMP_GCD:1;
    0 <> abs(s2.GBP+3) by A13,ABSVALUE:def 1;
    then
A15: a <> DataLoc(s2.GBP,3) by ZFMISC_1:27;
    thus IExec(WB,P,s).a =Exec(k2, s2).a by SCMPDS_5:41
      .=0 by A13,A15,SCMPDS_2:50;
    1 <> abs(s2.GBP+3) by A13,ABSVALUE:def 1;
    then
A16: a1 <> DataLoc(s2.GBP,3) by ZFMISC_1:27;
    thus
A17: IExec(WB,P,s).a1 =Exec(k2, s2).a1 by SCMPDS_5:41
      .=s1.a1 by A9,A16,SCMPDS_2:50;
    2 <> abs(s2.GBP+3) by A13,ABSVALUE:def 1;
    then
A18: a2 <> DataLoc(s2.GBP,3) by ZFMISC_1:27;
    thus
A19: IExec(WB,P,s).a2 =Exec(k2, s2).a2 by SCMPDS_5:41
      .=s1.a2 by A11,A18,SCMPDS_2:50;
    thus IExec(WB,P,s).a3 =Exec(k2, s2).a3 by SCMPDS_5:41
      .=s2.a3-s2.DataLoc(s2.a,2) by A14,SCMPDS_2:50
      .=IExec(WB,P,s).a1-IExec(WB,P,s).a2
      by A13,A11,A7,A17,A19,SCMP_GCD:1;
  end;
  set s0=s, m1=SubFrom(GBP,1,GBP,2), m2=SubFrom(GBP,2,GBP,1);
  assume
A20: s.GBP=0;
  then
A21: s0.a=0;
A22: DataLoc(s.a,3)=intpos(0+3) by A20,SCMP_GCD:1;
A24: now
    2 <> abs(s0.GBP+1) by A21,ABSVALUE:def 1;
    then
A25: a2 <> DataLoc(s0.GBP,1) by ZFMISC_1:27;
    0 <> abs(s0.GBP+1) by A21,ABSVALUE:def 1;
    then
A26: a <> DataLoc(s0.GBP,1) by ZFMISC_1:27;
    assume
A27: s.a3 > 0;
    hence s1.a=IExec(j1,P,s).a by A22,SCMPDS_6:73
      .=Exec(m1, s0).a by SCMPDS_5:40
      .=0 by A21,A26,SCMPDS_2:50;
A28: DataLoc(s0.a,1)=intpos (0+1) by A21,SCMP_GCD:1;
    thus s1.a1=IExec(j1,P,s).a1 by A22,A27,SCMPDS_6:73
      .=Exec(m1, s0).a1 by SCMPDS_5:40
      .=s0.a1-s0.DataLoc(s0.a,2) by A28,SCMPDS_2:50
      .=s0.a1-s0.intpos(0+2) by A21,SCMP_GCD:1
      .=s.a1-s.a2;
    thus s1.a2=IExec(j1,P,s).a2 by A22,A27,SCMPDS_6:73
      .=Exec(m1, s0).a2 by SCMPDS_5:40
      .=s.a2 by A25,SCMPDS_2:50;
  end;
  hence
  s.a3 > 0 implies IExec(WB,P,s).a1=s.a1-s.a2 &
  IExec(WB,P,s).a2 = s.a2 by A4;
A30: now
    1 <> abs(s0.GBP+2) by A21,ABSVALUE:def 1;
    then
A31: a1 <> DataLoc(s0.GBP,2) by ZFMISC_1:27;
    0 <> abs(s0.GBP+2) by A21,ABSVALUE:def 1;
    then
A32: a <> DataLoc(s0.GBP,2) by ZFMISC_1:27;
    assume
A33: s.a3 <= 0;
    hence s1.a=IExec(j2,P,s).a by A22,SCMPDS_6:74
      .=Exec(m2, s0).a by SCMPDS_5:40
      .=0 by A21,A32,SCMPDS_2:50;
A34: DataLoc(s0.a,2)=intpos (0+2) by A21,SCMP_GCD:1;
    thus s1.a2=IExec(j2,P,s).a2 by A22,A33,SCMPDS_6:74
      .=Exec(m2, s0).a2 by SCMPDS_5:40
      .=s0.a2-s0.DataLoc(s0.a,1) by A34,SCMPDS_2:50
      .=s0.a2-s0.intpos(0+1) by A21,SCMP_GCD:1
      .=s.a2-s.a1;
    thus s1.a1=IExec(j2,P,s).a1 by A22,A33,SCMPDS_6:74
      .=Exec(m2, s0).a1 by SCMPDS_5:40
      .=s.a1 by A31,SCMPDS_2:50;
  end;
  hence s.a3 <= 0 implies IExec(WB,P,s).a2=s.a2-s.a1
   & IExec(WB,P,s).a1 = s.a1 by A4;
  now
    per cases;
    suppose
      s.a3 > 0;
      hence s1.a=0 by A24;
    end;
    suppose
      s.a3 <= 0;
      hence s1.a=0 by A30;
    end;
  end;
  hence thesis by A4;
end;

Lm15: for s being 0-started State of SCMPDS
   st s.GBP=0 & s.a1 > 0 & s.a2 > 0 & s.a3=s.a1
-s.a2 holds IExec(WH,P,s).a1 = s.a1 gcd s.a2
 & IExec(WH,P,s).a2 = s.a1 gcd s.a2 &
WH is_closed_on s,P & WH is_halting_on s,P
proof
  set a=GBP;
  let s be 0-started State of SCMPDS;
A1: DataLoc(0,3)=intpos(0+3) by SCMP_GCD:1;
A2: now
    let t be 0-started State of SCMPDS, Q;
    assume that
    t.a1 > 0 and
    t.a2 > 0 and
A3: t.a=0 and
A4: t.DataLoc(0,3)=t.a1-t.a2 and
    t.a1<>t.a2;
    thus IExec(WB,Q,t).a=0 by A3,Lm14;
    thus WB is_closed_on t,Q by SCMPDS_6:20;
    thus WB is_halting_on t,Q by SCMPDS_6:21;
    hereby
      assume t.a1 > t.a2;
      then t.a3 > 0 by A1,A4,XREAL_1:50;
      hence IExec(WB,Q,t).a1=t.a1-t.a2 &
      IExec(WB,Q,t).a2 = t.a2 by A3,Lm14;
    end;
    hereby
      assume t.a1 <= t.a2;
      then t.a3 <= 0 by A1,A4,XREAL_1:47;
      hence IExec(WB,Q,t).a2=t.a2-t.a1 &
      IExec(WB,Q,t).a1 = t.a1 by A3,Lm14;
    end;
    thus IExec(WB,Q,t).DataLoc(0,3)=
    IExec(WB,Q,t).a1-IExec(WB,Q,t).a2
     by A1,A3,Lm14;
  end;
  assume
A5: s.a=0 & s.a1 > 0 & s.a2 > 0 & s.a3=s.a1-s.a2;
  hence IExec(WH,P,s).a1 = s.a1 gcd s.a2
   & IExec(WH,P,s).a2 = s.a1 gcd s.a2 by A1,A2,Th21;
  thus WH is_closed_on s,P & WH is_halting_on s,P
  by A5,A1,A2,Lm12,Th20;
end;
set GA=i1 ';' i2 ';' i3 ';' WH;

Lm16: for s being 0-started State of SCMPDS st s.a1 > 0 & s.a2 > 0
 holds IExec(GA,P,s).a1
= s.a1 gcd s.a2 & IExec(GA,P,s).a2 = s.a1 gcd s.a2 &
GA is_closed_on s,P & GA is_halting_on s,P
proof
  let s be 0-started State of SCMPDS;
I: Initialize s = s by MEMSTR_0:44;
  assume
A1: s.a1 > 0 & s.a2 > 0;
  set t0=s, Q0 = P,
  t1=IExec(i1 ';' i2 ';' i3,P,s),
  t2=IExec(i1 ';' i2,P,s),
  Q1 = P,
  t3=Exec(i1, t0), a=GBP;
A5: t3.a1=t0.a1 by AMI_3:10,SCMPDS_2:45
    .=s.a1;
A6: t3.a=0 by SCMPDS_2:45;
  then
A7: DataLoc(t3.a,3)=intpos (0+3) by SCMP_GCD:1;
  1 <> abs(t3.GBP+3) by A6,ABSVALUE:def 1;
  then
A8: a1 <> DataLoc(t3.GBP,3) by ZFMISC_1:27;
A9: t2.a1=Exec(i2,t3).a1 by SCMPDS_5:42
    .=s.a1 by A5,A8,SCMPDS_2:47;
A10: t3.a2=t0.a2 by AMI_3:10,SCMPDS_2:45
    .=s.a2;
A11: t2.a3=Exec(i2,t3).a3 by SCMPDS_5:42
    .=t3.DataLoc(t3.a,1) by A7,SCMPDS_2:47
    .=s.a1 by A6,A5,SCMP_GCD:1;
  2 <> abs(t3.GBP+3) by A6,ABSVALUE:def 1;
  then
A12: a2 <> DataLoc(t3.GBP,3) by ZFMISC_1:27;
A13: t2.a2=Exec(i2,t3).a2 by SCMPDS_5:42
    .=s.a2 by A10,A12,SCMPDS_2:47;
  0 <> abs(t3.GBP+3) by A6,ABSVALUE:def 1;
  then
A14: a <> DataLoc(t3.GBP,3) by ZFMISC_1:27;
A15: t2.a=Exec(i2,t3).a by SCMPDS_5:42
    .=0 by A6,A14,SCMPDS_2:47;
  then
A16: DataLoc(t2.a,3)=intpos (0+3) by SCMP_GCD:1;
  0 <> abs(t2.GBP+3) by A15,ABSVALUE:def 1;
  then
A17: a <> DataLoc(t2.GBP,3) by ZFMISC_1:27;
A18: t1.a=Exec(i3,t2).a by SCMPDS_5:41
    .=0 by A15,A17,SCMPDS_2:50;
  1 <> abs(t2.GBP+3) by A15,ABSVALUE:def 1;
  then
A19: a1 <> DataLoc(t2.GBP,3) by ZFMISC_1:27;
A20: t1.a1=Exec(i3,t2).a1 by SCMPDS_5:41
    .=s.a1 by A9,A19,SCMPDS_2:50;
  2 <> abs(t2.GBP+3) by A15,ABSVALUE:def 1;
  then
A21: a2 <> DataLoc(t2.GBP,3) by ZFMISC_1:27;
A22: t1.a2=Exec(i3,t2).a2 by SCMPDS_5:41
    .=s.a2 by A13,A21,SCMPDS_2:50;
X1: (Initialize t1).a1 = t1.a1 by SCMPDS_5:15;
X2: (Initialize t1).a2 = t1.a2 by SCMPDS_5:15;
A23: t1.a3=Exec(i3,t2).a3 by SCMPDS_5:41
    .=t2.a3-t2.DataLoc(t2.a,2) by A16,SCMPDS_2:50
    .=t1.a1-t1.a2 by A15,A13,A11,A20,A22,SCMP_GCD:1;
X0: (Initialize t1).GBP = t1.GBP by SCMPDS_5:15;
X3: (Initialize t1).a3 = t1.a3 by SCMPDS_5:15;
B25: WH is_closed_on Initialize t1,P &
WH is_halting_on Initialize t1,P
  by A1,A18,A20,A22,Lm15,X1,X2,A23,X0,X3;
A24: WH is_closed_on t1,Q1
   proof
  for k being Element of NAT holds
   IC Comput(Q1+*stop WH,Initialize Initialize t1,k) in dom stop WH
            by B25,SCMPDS_6:def 2;
    hence thesis by SCMPDS_6:def 2;
   end;
A25:  WH is_halting_on t1,Q1
   proof
  Q1+*stop WH halts_on Initialize Initialize t1 by B25,SCMPDS_6:def 3;
    hence thesis by SCMPDS_6:def 3;
  end;
  IExec(WH,Q1,Initialize t1).a1 = t1.a1 gcd t1.a2
  by A1,A18,A20,A22,A23,Lm15,X1,X2,X3,X0;
  hence IExec(GA,P,s).a1=s.a1 gcd s.a2 by A20,A22,A24,A25,SCPISORT:7;
  IExec(WH,Q1,Initialize t1).a2 = t1.a1 gcd t1. a2
  by A1,A18,A20,A22,A23,Lm15,X1,X2,X3,X0;
  hence IExec(GA,P,s).a2=s.a1 gcd s.a2 by A20,A22,A24,A25,SCPISORT:7;
  thus thesis by A24,I,A25,SCPISORT:9;
end;

theorem :: SCMP_GCD:18
  for s being 0-started State of SCMPDS,x, y being Integer
   st s.intpos 1 = x & s.intpos 2 = y & x > 0 & y > 0
 holds IExec(GCD-Algorithm,P,s).intpos 1 = x gcd y &
  IExec(GCD-Algorithm,P,s).intpos 2 = x gcd y
   & GCD-Algorithm is_closed_on s,P &
  GCD-Algorithm is_halting_on s,P by Lm16;

