:: Justifying the Correctness of Fibonacci Sequence and Euclide
:: Algorithm by Loop Invariant
::  by JingChao Chen
::
:: Received June 14, 2000
:: Copyright (c) 2000-2011 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies NUMBERS, SUBSET_1, AMI_1, SCMPDS_2, TURING_1, FUNCT_1, CARD_1,
      SCMFSA_7, RELAT_1, ARYTM_3, CARD_3, FSM_1, XXREAL_0, COMPLEX1, ARYTM_1,
      AMI_2, SCMPDS_5, SCMPDS_4, INT_1, SCMPDS_8, SCMFSA6B, SCMFSA_9, UNIALG_2,
      SCMFSA7B, SCMP_GCD, SEMI_AF1, GRAPHSP, AMI_3, FINSEQ_1, SCPISORT, NAT_1,
      ORDINAL4, SFMASTR2, PRE_FF, FUNCT_4, CIRCUIT2, TARSKI, PBOOLE,
      MSUALG_1, STRUCT_0, VALUED_1, XBOOLE_0, SCMFSA8B, INT_2, SCPINVAR,
      ORDINAL1, PARTFUN1, SCMNORM, SCMFSA6C;
 notations XBOOLE_0, SUBSET_1, CARD_1, NUMBERS, RELAT_1, FUNCT_1, PARTFUN1,
      VALUED_1, XCMPLX_0, FUNCT_4, PBOOLE,
      INT_1, INT_2, NAT_1, STRUCT_0, COMPOS_1,
      EXTPRO_1, AMI_1,
      AMI_2, SCMPDS_2, SCMPDS_4, SCMPDS_6, SCMP_GCD, SCMPDS_5,
      SCMPDS_8, FUNCT_2, CARD_3, DOMAIN_1, FINSEQ_1, GR_CY_1, PRE_FF, SCPISORT,
      XXREAL_0;
 constructors DOMAIN_1, REAL_1, NAT_D, RECDEF_1, PRE_FF, MESFUNC1, GR_CY_1,
      SCM_1, SCMPDS_4, SCMPDS_5, SCMPDS_6, SCMP_GCD, SCMPDS_8, SCPISORT,
      BINOP_2, AMI_1, AMI_2;
 registrations SETFAM_1, FUNCT_1, ORDINAL1, RELSET_1, NUMBERS, XREAL_0, NAT_1,
      INT_1, CARD_3, STRUCT_0, SCMPDS_2, SCMPDS_4, SCMPDS_5, SCMPDS_6,
      SCMPDS_8, XBOOLE_0, FINSEQ_1, CARD_1, VALUED_1, AMI_1, VALUED_0,
      RELAT_1, FUNCT_2, COMPOS_1, AFINSQ_1, EXTPRO_1, PBOOLE, FUNCT_4;
 requirements NUMERALS, REAL, SUBSET, ARITHM, BOOLE;
 definitions FUNCOP_1, COMPOS_1, EXTPRO_1, AMI_1, AMI_3, SCMPDS_2, SCMP_GCD,
 SCPISORT;
 theorems AMI_1, AMI_3, NAT_1, TARSKI, FUNCT_4, INT_1, SCMPDS_2, ABSVALUE,
      GRFUNC_1, SCMPDS_4, SCMPDS_5, SCMPDS_6, ENUMSET1, INT_2, SCMPDS_8,
      RELAT_1, SCMP_GCD, SCMPDS_7, FUNCT_1, FINSEQ_1, RVSUM_1, FINSEQ_2,
      PRE_FF, SCPISORT, XBOOLE_1, XREAL_1, COMPLEX1, XXREAL_0, PREPOWER,
      ORDINAL1, FUNCOP_1, AMI_2, ZFMISC_1, NAT_D, FINSEQ_3, PBOOLE, PARTFUN1,
      AFINSQ_1, COMPOS_1, EXTPRO_1;
 schemes NAT_1, SCMPDS_8, FUNCT_2;

begin :: Preliminaries

reserve m,n for Element of NAT,
  i,j for Instruction of SCMPDS,
  I for Program
  of SCMPDS,
  a for Int_position;

canceled 4;

theorem Th5:
  (i ';' j ';' I). 0=i & (i ';' j ';' I). 1=j
proof
  set jI=j ';' I;
A1: i ';' j ';' I =i ';' jI by SCMPDS_4:52
    .=Load i ';' jI by SCMPDS_4:def 4;
   0 in dom Load i by SCMPDS_5:2;
  hence (i ';' j ';' I). 0 =(Load i). 0 by A1,AFINSQ_1:def 4
    .=i by SCMPDS_5:4;
A2:  0 in dom Load j by SCMPDS_5:2;
  card jI=card I+1 by SCMPDS_6:15;
  then 0 < card jI by NAT_1:5;
  then
A3: card Load i=1 &  0 in dom jI by AFINSQ_1:70,SCMPDS_5:6;
  thus (i ';' j ';' I). 1 =(Load i ';' jI). (0+1) by A1
    .=jI. 0 by A3,AFINSQ_1:def 4
    .=(Load j ';' I). 0 by SCMPDS_4:def 4
    .=(Load j). 0 by A2,AFINSQ_1:def 4
    .=j by SCMPDS_5:4;
end;

theorem Th6:
  for a,b be Int_position holds ex f be Function of product the
  Object-Kind of SCMPDS,NAT st for s being State of SCMPDS holds (s.a = s.b
  implies f.s =0) & (s.a <> s.b implies f.s=max(abs(s.a),abs(s.b)))
proof
  let a,b be Int_position;
  defpred P[set,set] means ex t be State of SCMPDS st t=$1 & (t.a = t.b
  implies $2 =0) & (t.a <> t.b implies $2=max(abs(t.a),abs(t.b)));
A1: now
    let s be Element of product the Object-Kind of SCMPDS;
    per cases;
    suppose
A2:   s.a = s.b;
      reconsider y=0 as Element of NAT;
      take y;
      thus P[s,y] by A2;
    end;
    suppose
A3:   s.a <> s.b;
      set mm=max(abs(s.a),abs(s.b));
      reconsider y=mm as Element of NAT by XXREAL_0:16;
      take y;
      thus P[s,y] by A3;
    end;
  end;
  consider f be Function of product the Object-Kind of SCMPDS, NAT such that
A4: for s be Element of product the Object-Kind of SCMPDS holds P[s,f.s]
       from FUNCT_2:sch 3(A1);
A5: for s being State of SCMPDS holds P[s,f.s]
   proof
    let s be State of SCMPDS;
    reconsider s as Element of product the Object-Kind of SCMPDS by PBOOLE:155;
    P[s,f.s] by A4;
    hence thesis;
   end;
  take f;
  hereby
    let s be State of SCMPDS;
    P[s,f.s] by A5;
    hence
    (s.a = s.b implies f.s =0) & (s.a <> s.b implies f.s=max(abs(s.a),abs
    (s.b)));
  end;
end;

theorem Th7:
  ex f be Function of product the Object-Kind of SCMPDS,NAT st for
s being State of SCMPDS holds (s.a >= 0 implies f.s =0) & (s.a < 0 implies f.s=
  -s.a)
proof
  defpred P[set,set] means ex t be State of SCMPDS st t=$1 & (t.a >= 0 implies
  $2 =0) & (t.a < 0 implies $2=-t.a);
A1: now
    let s be Element of product the Object-Kind of SCMPDS;
    per cases;
    suppose
A2:   s.a >= 0;
      reconsider y=0 as Element of NAT;
      take y;
      thus P[s,y] by A2;
    end;
    suppose
A3:   s.a < 0;
      then -s.a > 0 by XREAL_1:60;
      then reconsider y=-s.a as Element of NAT by INT_1:16;
      take y;
      thus P[s,y] by A3;
    end;
  end;
  consider f be Function of product the Object-Kind of SCMPDS,NAT such that
A4: for s be Element of product the Object-Kind of SCMPDS holds P[s,f.s]
      from FUNCT_2:sch 3(A1);
A5: for s being State of SCMPDS holds P[s,f.s]
   proof
    let s be State of SCMPDS;
    reconsider s as Element of product the Object-Kind of SCMPDS by PBOOLE:155;
    P[s,f.s] by A4;
    hence thesis;
   end;
  take f;
  hereby
    let s be State of SCMPDS;
    P[s,f.s] by A5;
    hence (s.a >= 0 implies f.s =0) & (s.a < 0 implies f.s=-s.a);
  end;
end;
set A = NAT, D = SCM-Data-Loc;

begin :: Computing directly the result of "while<0" program by loop-invariant

reserve Q,U,P for (the Instructions of SCMPDS)-valued ManySortedSet of NAT;

scheme
  WhileLEnd { F(State of SCMPDS)-> Element of NAT, s() -> State of SCMPDS,
  P() -> (the Instructions of SCMPDS)-valued ManySortedSet of NAT,
  I()
-> halt-free shiftable Program of SCMPDS, a() -> Int_position,i() -> Integer,
P[set]}: F(Dstate IExec(while<0(a(),i(),I()),P(),s()))=0
 & P[Dstate IExec(while<0(a(),i(),I()),P(),s())]
provided
A2: for t be State of SCMPDS st P[Dstate t] holds F(Dstate(t))=0
   iff t.DataLoc(s().a(),i()) >= 0 and
A3: P[Dstate s()] and
A4: for t be State of SCMPDS,Q st P[Dstate t] & t.a()=s().a() &
   t.DataLoc(s().a(),i()) < 0
 holds IExec(I(),Q,t).a()=t.a() & I() is_closed_on t,Q & I()
is_halting_on t,Q & F(Dstate IExec(I(),Q,t)) < F(Dstate t)
 & P[Dstate(IExec(I(),Q,t))]
proof
  set b=DataLoc(s().a(),i()), WHL=while<0(a(),i(),I());
  defpred Q[Element of NAT] means
  for t be State of SCMPDS, Q st F(Dstate t) <=
  $1 & t.a()=s().a() & P[Dstate t] holds F(Dstate IExec(WHL,Q,t))=0
   & P[Dstate
  IExec(WHL,Q,t)];
A5: Q[0]
  proof
    let t be State of SCMPDS, Q;
    assume that
A6: F(Dstate t) <= 0 and
A7: t.a()=s().a() and
A8: P[Dstate t];
    F(Dstate t) >= 0 by NAT_1:2;
    then
A9: F(Dstate t)=0 by A6,XXREAL_0:1;
    then t.DataLoc(s().a(),i()) >= 0 by A2,A8;
    then for b be Int_position holds IExec(WHL,Q,t).b = t.b by A7,SCMPDS_8:12;
    hence thesis by A8,A9,SCPISORT:5;
  end;
A10: now
    let k be Element of NAT;
    assume
A11: Q[k];
    now
      let u be State of SCMPDS;
      let U;
      assume that
A12:  F(Dstate u) <= k+1 and
A13:  u.a()=s().a() and
A14:  P[Dstate u];
      per cases;
      suppose
        F(Dstate u)=0;
        hence F(Dstate IExec(WHL,U,u))=0 & P[Dstate IExec(WHL,U,u)]
         by A5,A13,A14;
      end;
      suppose
A15:    F(Dstate u) <> 0;
        set Iu=IExec(I(),U,u);
A16:    u.b < 0 by A2,A14,A15;
        then
A17:    Iu.a()=s().a() & P[Dstate Iu] by A4,A13,A14;
        deffunc F(State of SCMPDS) = F($1);
A18:    P[Dstate u] by A14;
A19:    for t be State of SCMPDS st P[Dstate t] & F(Dstate(t))=0
       holds t.DataLoc(u.a(),i()) >= 0 by A2,A13;
        F(Dstate Iu) < F(Dstate u) by A4,A13,A14,A16;
        then F(Dstate Iu)+1 <= F(Dstate u) by INT_1:20;
        then F(Dstate Iu)+1 <= k+1 by A12,XXREAL_0:2;
        then
A20:    F(Dstate Iu) <= k by XREAL_1:8;
A21:    for t being State of SCMPDS,Q
       st P[Dstate t] & t.a()=u.a() & t.DataLoc(u.a(),i()) < 0
     holds IExec(I(),Q,t).a()=t.a()
     & I() is_closed_on t,Q & I()
is_halting_on t,Q & F(Dstate IExec(I(),Q,t)) < F(Dstate t)
 & P[Dstate(IExec(I(),Q,t))] by A4,A13;
A22:    u.DataLoc(u.a(),i()) < 0 by A2,A13,A14,A15;
        (F(u)=F(u) or P[u]) & IExec(WHL,U,u) = IExec(WHL,U,Iu) from SCMPDS_8:
        sch 2 (A22,A19,A18,A21);
        hence F(Dstate IExec(WHL,U,u))=0 & P[Dstate IExec(WHL,U,u)]
         by A11,A20,A17;
      end;
    end;
    hence Q[k+1];
  end;
  for k being Element of NAT holds Q[k] from NAT_1:sch 1(A5,A10);
  then Q[F(Dstate s())];
  hence thesis by A3;
end;
set a1=intpos 1, a2=intpos 2, a3=intpos 3;

begin :: An Example : Summing directly n integers by loop-invariant

:: sum=Sum=x1+x2+...+xn

definition
  let n, p0 be Element of NAT;
  func sum(n,p0) -> Program of SCMPDS equals
  (GBP:=0) ';' (intpos 1:=0) ';' (
intpos 2:=-n) ';' (intpos 3:=(p0+1)) ';' while<0(GBP,2,AddTo(GBP,1,intpos 3,0)
  ';' AddTo(GBP,2,1) ';' AddTo(GBP,3,1));
  coherence;
end;
:: SCMPDS_7:73

definition
 let ff be Function of product the Object-Kind of SCMPDS,NAT,
     s be State of SCMPDS;
 redefine func ff.s -> Element of NAT;
 coherence by ORDINAL1:def 13;
end;

theorem Th8:
  for s being 0-started State of SCMPDS,
    I being halt-free shiftable Program
  of SCMPDS, a,b,c being Int_position,n,i,p0 be Element of NAT,f be FinSequence
  of INT st card I >0 & f is_FinSequence_on s,p0 & len f=n & s.b=0 & s.a=0 & s.
intpos i=-n & s.c = p0+1 &
 (for t be State of SCMPDS, Q
    st (ex g be FinSequence of
INT st g is_FinSequence_on s,p0 & len g=t.intpos i+n & t.b=Sum g & t.c = p0+1+
  len g) & t.a=0 & t.intpos i < 0 & for i be Element of NAT st i > p0 holds t.
intpos i=s.intpos i holds IExec(I,Q,t).a=0 & I is_closed_on t,Q
 & I is_halting_on t,Q
  & IExec(I,Q,t).intpos i=t.intpos i+1 & (ex g be FinSequence of INT st g
  is_FinSequence_on s,p0 & len g=t.intpos i+n+1 & IExec(I,Q,t).c = p0+1+len g &
IExec(I,Q,t).b=Sum g) & for i be Element of NAT st i > p0
 holds IExec(I,Q,t).intpos
  i=s.intpos i) holds IExec(while<0(a,i,I),P,s).b=Sum f & while<0(a,i,I)
  is_closed_on s,P & while<0(a,i,I) is_halting_on s,P
proof
  let s be 0-started State of SCMPDS,
      I be halt-free shiftable Program of SCMPDS, a,b,c
  be Int_position,n,i,p0 be Element of NAT,f be FinSequence of INT;
  assume
A1: card I > 0;
  set Iw=IExec(while<0(a,i,I),P,s), Dw=Dstate Iw;
  set da=DataLoc(s.a,i);
  defpred P[State of SCMPDS] means (for i be Element of NAT st i > p0 holds $1
.intpos i=s.intpos i) & (ex g be FinSequence of INT st g is_FinSequence_on s,p0
  & len g=$1.intpos i+n & $1.b=Sum g & $1.intpos i <= 0 & $1.c = p0+1+len g);
  assume that
A2: f is_FinSequence_on s,p0 and
A3: len f=n and
A4: s.b=0 and
A5: s.a=0 and
A6: s.intpos i=-n and
A7: s.c = p0+1;
  consider ff be Function of product the Object-Kind of SCMPDS,NAT such that
A8: for t be State of SCMPDS holds (t.da >= 0 implies ff.t =0) & (t.da <
  0 implies ff.t=-t.da) by Th7;
  deffunc F(State of SCMPDS) = ff.$1;
  assume
A9: for t be State of SCMPDS,Q
 st (ex g be FinSequence of INT st g
is_FinSequence_on s,p0 & len g=t.intpos i+n & t.b=Sum g & t.c = p0+1+len g) & t
  .a=0 & t.intpos i < 0 & for i be Element of NAT st i > p0 holds t.intpos i=s.
intpos i holds IExec(I,Q,t).a=0 & I is_closed_on t,Q
 & I is_halting_on t,Q & IExec(I,Q,
t).intpos i=t.intpos i+1 & (ex g be FinSequence of INT st g is_FinSequence_on s
,p0 & len g=t.intpos i+n+1 & IExec(I,Q,t).c = p0+1+len g
 & IExec(I,Q,t).b=Sum g) &
  for i be Element of NAT st i > p0 holds IExec(I,Q,t).intpos i=s.intpos i;
A10: now
    let t be State of SCMPDS;
    set dt=Dstate t;
    assume P[dt];
    hereby
      assume
A11:  F(dt)=0;
      assume
A12:  t.da < 0;
      then dt.da < 0 by SCMPDS_8:4;
      then F(dt)=-dt.da by A8;
      hence contradiction by A11,A12,SCMPDS_8:4;
    end;
    assume t.da >= 0;
    then dt.da >= 0 by SCMPDS_8:4;
    hence F(dt)=0 by A8;
  end;
A13: now
    let t be State of SCMPDS, Q;
    set Dt=Dstate t;
    assume that
A14: P[Dstate t] and
A15: t.a=s.a and
A16: t.DataLoc(s.a,i) < 0;
    consider h be FinSequence of INT such that
A17: h is_FinSequence_on s,p0 and
A18: len h=Dt.intpos i+n & Dt.b=Sum h and
A19: Dt.c = p0+1+len h by A14;
A20: t.c = p0+1+len h by A19,SCMPDS_8:4;
    set It=IExec(I,Q,t);
    set Dit=Dstate It;
A21: now
      let i be Element of NAT;
      assume
A22:  i > p0;
      thus t.intpos i=Dt.intpos i by SCMPDS_8:4
        .=s.intpos i by A14,A22;
    end;
A23: intpos (0+i)=da by A5,SCMP_GCD:5;
A24: len h=t.intpos i+n & t.b=Sum h by A18,SCMPDS_8:4;
    hence IExec(I,Q,t).a=t.a by A5,A9,A15,A16,A21,A17,A20,A23;
    consider g be FinSequence of INT such that
A25: g is_FinSequence_on s,p0 and
A26: len g=t.intpos i+n+1 and
A27: IExec(I,Q,t).c = p0+1+len g and
A28: IExec(I,Q,t).b=Sum g by A5,A9,A15,A16,A21,A17,A24,A20,A23;
    thus I is_closed_on t,Q & I is_halting_on t,Q
     by A5,A9,A15,A16,A21,A17,A24,A20
,A23;
A29: It.intpos i=t.intpos i+1 by A5,A9,A15,A16,A21,A17,A24,A20,A23;
    hereby
      per cases;
      suppose
        It.intpos i >= 0;
        then Dit.da >= 0 by A23,SCMPDS_8:4;
        then
A30:    F(Dit)=0 by A8;
        F(Dt) <> 0 by A10,A14,A16;
        hence F(Dit) < F(Dt) by A30,NAT_1:3;
      end;
      suppose
A31:    It.intpos i < 0;
        Dt.da < 0 by A16,SCMPDS_8:4;
        then
A32:    F(Dt)=-Dt.da by A8
          .=-t.intpos i by A23,SCMPDS_8:4;
        Dit.da < 0 by A23,A31,SCMPDS_8:4;
        then F(Dit)=-Dit.da by A8
          .=-(t.intpos i+1) by A23,A29,SCMPDS_8:4
          .=-t.intpos i-1;
        hence F(Dit) < F(Dt) by A32,XREAL_1:148;
      end;
    end;
    thus P[Dstate IExec(I,Q,t)]
    proof
      hereby
        let i be Element of NAT;
        assume
A33:    i > p0;
        thus Dit.intpos i=It.intpos i by SCMPDS_8:4
          .=s.intpos i by A5,A9,A15,A16,A21,A17,A24,A20,A23,A33;
      end;
      take g;
      thus g is_FinSequence_on s,p0 by A25;
      thus len g=IExec(I,Q,t).intpos i+n by A29,A26
        .=Dit.intpos i+n by SCMPDS_8:4;
      thus Dit.b=Sum g by A28,SCMPDS_8:4;
      Dit.intpos i=t.intpos i+1 by A29,SCMPDS_8:4;
      hence Dit.intpos i <= 0 by A16,A23,INT_1:20;
      thus thesis by A27,SCMPDS_8:4;
    end;
  end;
A34: P[Dstate s]
  proof
    set Ds=Dstate s;
    thus for i be Element of NAT st i > p0 holds Ds.intpos i=s.intpos i by
SCMPDS_8:4;
    consider h be FinSequence of INT such that
A35: len h=0 and
A36: h is_FinSequence_on s,p0 by SCPISORT:3;
    take h;
    thus h is_FinSequence_on s,p0 by A36;
    thus len h=s.intpos i+n by A6,A35
      .=Ds.intpos i+n by SCMPDS_8:4;
    h=<*> REAL by A35;
    hence Ds.b=Sum h by A4,RVSUM_1:102,SCMPDS_8:4;
    thus Ds.intpos i <= 0 by A6,SCMPDS_8:4;
    thus thesis by A7,A35,SCMPDS_8:4;
  end;
A37: F(Dw)=0 & P[Dw] from WhileLEnd(A10,A34,A13);
  then consider g be FinSequence of INT such that
A38: g is_FinSequence_on s,p0 and
A39: len g=Dw.intpos i+n and
A40: Dw.b=Sum g and
A41: Dw.intpos i <= 0;
  Dw.intpos i=Iw.intpos(0+i) by SCMPDS_8:4
    .=Iw.da by A5,SCMP_GCD:5;
  then Dw.intpos i >= 0 by A10,A37;
  then
A42: Dw.intpos i=0 by A41,XXREAL_0:1;
  now
    let i be Nat;
    reconsider a = i as Element of NAT by ORDINAL1:def 13;
    assume i in dom f;
    then
A43: 1 <= i & i <= n by A3,FINSEQ_3:27;
    hence f.i = s.intpos(p0+a) by A2,A3,SCPISORT:def 1
      .=g.i by A38,A39,A42,A43,SCPISORT:def 1;
  end;
  then f = g by A3,A39,A42,FINSEQ_2:10;
  hence Iw.b=Sum f by A40,SCMPDS_8:4;
A44: for t be State of SCMPDS st P[Dstate t] & F(Dstate(t))=0 holds t.da >=
  0 by A10;
  (F(s)=F(s) or P[s]) & while<0(a,i,I) is_closed_on s,P & while<0(a,i,I)
  is_halting_on s,P from SCMPDS_8:sch 1(A44,A34,A13);
  hence thesis;
end;

set j1= AddTo(GBP,1,a3,0), j2= AddTo(GBP,2,1), j3= AddTo(GBP,3,1), WB= j1 ';'
j2 ';' j3, WH= while<0(GBP,2,WB);

Lm1: for s being 0-started State of SCMPDS,
        m be Element of NAT st s.GBP=0 & s.a3=m holds
IExec(WB,P,s).GBP=0 & IExec(WB,P,s).a1=s.a1+s.intpos m
 & IExec(WB,P,s).a2=s.a2+1 &
IExec(WB,P,s).a3=m+1 & for i be Element of NAT st i >3
 holds IExec(WB,P,s).intpos i
=s.intpos i

proof
  set a=GBP;
  let s be 0-started State of SCMPDS,m be Element of NAT;
  assume that
A1: s.a=0 and
A2: s.a3=m;

  set t0=Initialize s, t1=IExec(WB,P,s),
  t2=IExec(j1 ';' j2,P,s), t3=Exec(j1, t0);

A3: t0.a3=m by A2,SCMPDS_5:40;
A4: t0.a=0 by A1,SCMPDS_5:40;
  then 0 <> abs(t0.GBP+1) by ABSVALUE:def 1;
  then a <> DataLoc(t0.GBP,1) by ZFMISC_1:33;
  then
A5: t3.a=0 by A4,SCMPDS_2:61;
  then 0 <> abs(t3.GBP+2) by ABSVALUE:def 1;
  then
A6: a <> DataLoc(t3.GBP,2) by ZFMISC_1:33;
  3 <> abs(t0.GBP+1) by A4,ABSVALUE:def 1;
  then a3 <> DataLoc(t0.GBP,1) by ZFMISC_1:33;
  then
A7: t3.a3=m by A3,SCMPDS_2:61;
  3 <> abs(t3.GBP+2) by A5,ABSVALUE:def 1;
  then
A8: a3 <> DataLoc(t3.GBP,2) by ZFMISC_1:33;
A9: t2.a3=Exec(j2,t3).a3 by SCMPDS_5:47
    .=m by A7,A8,SCMPDS_2:60;
A10: t0.a1=s.a1 by SCMPDS_5:40;
A11: DataLoc(t0.a,1)=intpos (0+1) by A4,SCMP_GCD:5;
  then
A12: t3.a1=t0.a1+t0.DataLoc(t0.a3,0) by SCMPDS_2:61
    .=t0.a1+t0.intpos(m+0) by A3,SCMP_GCD:5
    .=s.a1+s.intpos m by A10,SCMPDS_5:40;
  1 <> abs(t3.GBP+2) by A5,ABSVALUE:def 1;
  then
A13: a1 <> DataLoc(t3.GBP,2) by ZFMISC_1:33;
A14: DataLoc(t3.a,2)=intpos (0+2) by A5,SCMP_GCD:5;
  then
A15: abs(t3.a+2)=0+2 by ZFMISC_1:33;
  2 <> abs(t0.GBP+1) by A4,ABSVALUE:def 1;
  then a2 <> DataLoc(t0.GBP,1) by ZFMISC_1:33;
  then
A16: t3.a2=t0.a2 by SCMPDS_2:61
    .=s.a2 by SCMPDS_5:40;
A17: t2.a=Exec(j2,t3).a by SCMPDS_5:47
    .=0 by A5,A6,SCMPDS_2:60;
  then
A18: DataLoc(t2.a,3)=intpos (0+3) by SCMP_GCD:5;
A19: t2.a2=Exec(j2,t3).a2 by SCMPDS_5:47
    .=s.a2+1 by A16,A14,SCMPDS_2:60;
A20: t2.a1=Exec(j2,t3).a1 by SCMPDS_5:47
    .=s.a1+s.intpos m by A12,A13,SCMPDS_2:60;
  0 <> abs(t2.GBP+3) by A17,ABSVALUE:def 1;
  then
A21: a <> DataLoc(t2.GBP,3) by ZFMISC_1:33;
  thus t1.a=Exec(j3,t2).a by SCMPDS_5:46
    .=0 by A17,A21,SCMPDS_2:60;
  1 <> abs(t2.GBP+3) by A17,ABSVALUE:def 1;
  then
A22: a1 <> DataLoc(t2.GBP,3) by ZFMISC_1:33;
  thus t1.a1=Exec(j3,t2).a1 by SCMPDS_5:46
    .=s.a1+s.intpos m by A20,A22,SCMPDS_2:60;
  2 <> abs(t2.GBP+3) by A17,ABSVALUE:def 1;
  then
A23: a2 <> DataLoc(t2.GBP,3) by ZFMISC_1:33;
  thus t1.a2=Exec(j3,t2).a2 by SCMPDS_5:46
    .=s.a2+1 by A19,A23,SCMPDS_2:60;
  thus t1.a3=Exec(j3,t2).a3 by SCMPDS_5:46
    .=m+1 by A9,A18,SCMPDS_2:60;
A24: abs(t0.a+1)=0+1 by A11,ZFMISC_1:33;
  hereby
    let i be Element of NAT;
    assume
A25: i >3;
    then
A26: intpos i <> DataLoc(t2.a,3) by A18,ZFMISC_1:33;
    i <> abs(t0.a+1) by A24,A25;
    then
A27: intpos i <> DataLoc(t0.a,1) by ZFMISC_1:33;
    i <> abs(t3.a+2) by A15,A25;
    then
A28: intpos i <> DataLoc(t3.a,2) by ZFMISC_1:33;
    thus t1.intpos i=Exec(j3,t2).intpos i by SCMPDS_5:46
      .=t2.intpos i by A26,SCMPDS_2:60
      .=Exec(j2,t3).intpos i by SCMPDS_5:47
      .=t3.intpos i by A28,SCMPDS_2:60
      .=t0.intpos i by A27,SCMPDS_2:61
      .=s.intpos i by SCMPDS_5:40;
  end;
end;

Lm2: card WB=3
proof
  thus card WB=card (j1 ';' j2) +1 by SCMP_GCD:8
    .=2+1 by SCMP_GCD:9
    .=3;
end;

Lm3: for s being 0-started State of SCMPDS,
n,p0 be Element of NAT,f be FinSequence of
INT st p0 >= 3 & f is_FinSequence_on s,p0 & len f=n & s.a1=0 & s.GBP=0 & s.a2=-
n & s.a3=p0+1 holds IExec(WH,P,s).a1=Sum f
 & WH is_closed_on s,P & WH is_halting_on
s ,P

proof
  let s be 0-started State of SCMPDS,
      n,p0 be Element of NAT,f be FinSequence of INT;
  set a=GBP;
  assume that
A1: p0 >= 3 and

A2: f is_FinSequence_on s,p0 & len f=n & s.a1=0 & s.a=0 & s.a2=-n & s.a3
  = p0+1;

  now
    let t be State of SCMPDS;
    let Q;
    given g be FinSequence of INT such that
A3: g is_FinSequence_on s,p0 and
A4: len g=t.a2+n and
A5: t.a1=Sum g and
A6: t.a3 = p0+1+len g;
    assume that
A7: t.a=0 and
    t.a2 < 0;
A8:  IExec(WB,Q,t) =  IExec(WB,Q,Initialize t) by SCMPDS_5:48;
A9: (Initialize t).a3 = t.a3 by SCMPDS_5:40;
A10: (Initialize t).a1 = t.a1 by SCMPDS_5:40;
A11: (Initialize t).a = t.a by SCMPDS_5:40;
A12: (Initialize t).a2 = t.a2 by SCMPDS_5:40;
    assume
A13: for i be Element of NAT st i > p0 holds t.intpos i=s.intpos i;
    thus IExec(WB,Q,t).a=0 by A6,A7,Lm1,A8,A9,A11;
    thus WB is_closed_on t,Q & WB is_halting_on t,Q by SCMPDS_6:34,35;
    thus IExec(WB,Q,t).a2=t.a2+1 by A6,A7,Lm1,A8,A9,A11,A12;

    thus ex g be FinSequence of INT st g is_FinSequence_on s,p0 & len g=t.a2+n
    +1 & IExec(WB,Q,t).a3 = p0+1+len g & IExec(WB,Q,t).a1=Sum g

    proof
      consider h be FinSequence of INT such that
A14:   len h=len g+1 and
A15:  h is_FinSequence_on s,p0 by SCPISORT:3;
      take h;
      thus h is_FinSequence_on s,p0 by A15;
      thus len h=t.a2+n+1 by A4,A14;
      thus IExec(WB,Q,t).a3 =p0+1+len g+1 by A6,A7,Lm1,A8,A9,A11
        .=p0+1+len h by A14;
A16:  p0+1 > p0 by XREAL_1:31;
      set m=len h;
A17:  m >= 1 by A14,NAT_1:11;
      then p0+m >= p0+1 by XREAL_1:8;
      then
A18:  p0+m > p0 by A16,XXREAL_0:2;
      reconsider q = h.m as Element of INT by INT_1:def 2;
A19:  now
        let i be Nat;
A20:    i in NAT by ORDINAL1:def 13;
        assume that
A21:    1 <= i and
A22:    i <= len h;
        per cases;
        suppose
          i=len h;
          hence h.i=(g^<*q*>).i by A14,FINSEQ_1:59;
        end;
        suppose
          i<>len h;
          then i < len h by A22,XXREAL_0:1;
          then
A23:      i <= len g by A14,INT_1:20;
          then i in Seg (len g) by A21,FINSEQ_1:3;
          then
A24:      i in dom g by FINSEQ_1:def 3;
          thus h.i = s.intpos(p0+i) by A15,A20,A21,A22,SCPISORT:def 1
            .= g.i by A3,A20,A21,A23,SCPISORT:def 1
            .= (g^<*q*>).i by A24,FINSEQ_1:def 7;
        end;
      end;
      len (g^<*q*>)=len h by A14,FINSEQ_2:19;
      then
A25:  g^<*q*>=h by A19,FINSEQ_1:18;
A26:   (Initialize t).intpos(p0+1+len g) = t.intpos(p0+1+len g) by SCMPDS_5:40;
      h.m=s.intpos(p0+m) by A15,A17,SCPISORT:def 1
        .=t.intpos(p0+1+len g) by A13,A14,A18;
      hence IExec(WB,Q,t).a1=t.a1+h.m by A6,A7,Lm1,A8,A9,A10,A11,A26
        .=Sum h by A5,A25,RVSUM_1:104;
    end;
    hereby
      let i be Element of NAT;
A27:   (Initialize t).intpos i = t.intpos i by SCMPDS_5:40;
      assume
A28:  i > p0;
      then i > 3 by A1,XXREAL_0:2;
      hence IExec(WB,Q,t).intpos i=t.intpos i by A6,A7,Lm1,A8,A9,A11,A27
        .=s.intpos i by A13,A28;
    end;
  end;
  hence thesis by A2,Lm2,Th8;
end;

Lm4: for s being 0-started State of SCMPDS,
  n,p0 be Element of NAT,f be FinSequence of
INT st p0 >= 3 & f is_FinSequence_on s,p0 & len f=n
 holds IExec(sum(n,p0),P,s).a1
=Sum f & sum(n,p0) is_halting_on s,P

proof
  let s be 0-started State of SCMPDS,
      n,p0 be Element of NAT,f be FinSequence of INT;
  assume that
A1: p0 >= 3 and
A2: f is_FinSequence_on s,p0 and
A3: len f=n;

  set a=GBP, i1=a:=0, i2=a1:=0, i3=a2:=-n, i4=a3:=(p0+1), t0=Initialize s,
    I4 =i1 ';' i2 ';' i3 ';' i4, t1=IExec(I4,P,s), Q1 = P,
    t2=IExec(i1 ';' i2 ';' i3,P,s),
    t3= IExec(i1 ';' i2,P,s), t4=Exec(i1, t0);

  now
    let i be Element of NAT;
    assume that
A4: 1 <= i and
A5: i <= len f;
A6: p0+1 >= 3+1 by A1,XREAL_1:8;
A7: p0+i >= p0+ 1 by A4,XREAL_1:8;
    then p0+i <> 3 by A6,XXREAL_0:2;
    then
A8: intpos (p0+i) <> a3 by ZFMISC_1:33;
    p0+i <> 0 by A6,A7,XXREAL_0:2;
    then
A9: intpos (p0+i) <> a by ZFMISC_1:33;
    p0+i <> 1 by A6,A7,XXREAL_0:2;
    then
A10: intpos (p0+i) <> a1 by ZFMISC_1:33;
    p0+i <> 2 by A6,A7,XXREAL_0:2;
    then
A11: intpos (p0+i) <> a2 by ZFMISC_1:33;
    thus t1.intpos (p0+i)=Exec(i4, t2).intpos (p0+i) by SCMPDS_5:46
      .=t2.intpos (p0+i) by A8,SCMPDS_2:57
      .=Exec(i3, t3).intpos (p0+i) by SCMPDS_5:46
      .=t3.intpos (p0+i) by A11,SCMPDS_2:57
      .=Exec(i2, t4).intpos (p0+i) by SCMPDS_5:47
      .=t4.intpos (p0+i) by A10,SCMPDS_2:57
      .=t0.intpos (p0+i) by A9,SCMPDS_2:57
      .=s.intpos (p0+i) by SCMPDS_5:40
      .=f.i by A2,A4,A5,SCPISORT:def 1;
  end;
  then
A12: f is_FinSequence_on t1,p0 by SCPISORT:def 1;
A13: f is_FinSequence_on Initialize t1,p0
   proof let i be Element of NAT;
    assume 1 <= i & i <= len f;
     then f.i=t1.intpos(p0+i) by A12,SCPISORT:def 1;
    hence thesis by SCMPDS_5:40;
   end;
A14: t4.a=0 by SCMPDS_2:57;
A15: t3.a=Exec(i2, t4).a by SCMPDS_5:47
    .=0 by A14,AMI_3:52,SCMPDS_2:57;
A16: t2.a=Exec(i3, t3).a by SCMPDS_5:46
    .=0 by A15,AMI_3:52,SCMPDS_2:57;
A17: t1.a3=Exec(i4, t2).a3 by SCMPDS_5:46
    .=p0+1 by SCMPDS_2:57;
A18: (Initialize t1).a3 = t1.a3 by SCMPDS_5:40;
A19: t3.a1=Exec(i2, t4).a1 by SCMPDS_5:47
    .=0 by SCMPDS_2:57;
A20: t2.a1=Exec(i3, t3).a1 by SCMPDS_5:46
    .=0 by A19,AMI_3:52,SCMPDS_2:57;
A21: (Initialize t1).a1 = t1.a1 by SCMPDS_5:40;
A22: t1.a1=Exec(i4, t2).a1 by SCMPDS_5:46
    .=0 by A20,AMI_3:52,SCMPDS_2:57;
A23: t2.a2=Exec(i3, t3).a2 by SCMPDS_5:46
    .=-n by SCMPDS_2:57;
A24: (Initialize t1).a2 = t1.a2 by SCMPDS_5:40;
A25: (Initialize t1).a = t1.a by SCMPDS_5:40;
A26: t1.a2=Exec(i4, t2).a2 by SCMPDS_5:46
    .=-n by A23,AMI_3:52,SCMPDS_2:57;
A27: t1.a=Exec(i4, t2).a by SCMPDS_5:46
    .=0 by A16,AMI_3:52,SCMPDS_2:57;

  then WH is_closed_on Initialize t1,Q1 & WH is_halting_on Initialize t1,Q1
   by A1,A3,A22,A26,A17,Lm3,A13,A18,A21,A24,A25;
  then
A28: WH is_closed_on t1,Q1 & WH is_halting_on t1,Q1 by SCMPDS_6:139,140;

  IExec(WH,Q1,t1) = IExec(WH,Q1,Initialize t1) by SCMPDS_5:48;
  then IExec(WH,Q1,t1).a1=Sum f
   by A1,A3,A27,A22,A26,A17,Lm3,A13,A18,A21,A24,A25;
  hence IExec(sum(n,p0),P,s).a1=Sum f by A28,SCPISORT:8;
  thus thesis by A28,SCPISORT:10;
end;

theorem
  for s being 0-started State of SCMPDS,n,
    p0 be Element of NAT, f be FinSequence
of INT st p0 >= 3 & f is_FinSequence_on s,p0 & len f=n
 holds IExec(sum(n,p0),P,s)
  .intpos 1=Sum f & sum(n,p0) is parahalting
proof
  let s be 0-started State of SCMPDS,
      n,p0 be Element of NAT,f be FinSequence of INT;
  assume that
A1: p0 >= 3 and
A2: f is_FinSequence_on s,p0 & len f=n;
  thus IExec(sum(n,p0),P,s).a1=Sum f by A1,A2,Lm4;
  now
    let t be State of SCMPDS, Q;
    consider g being FinSequence of INT such that
A3:     len g=n & g is_FinSequence_on t,p0 by SCPISORT:3;
     g is_FinSequence_on Initialize t,p0
  proof let i be Element of NAT;
    assume 1 <= i & i <= len g;
     then g.i=t.intpos(p0+i) by A3,SCPISORT:def 1;
    hence thesis by SCMPDS_5:40;
   end;
     then sum(n,p0) is_halting_on Initialize t,Q by A1,Lm4,A3;
    hence sum(n,p0) is_halting_on t,Q by SCMPDS_6:140;
  end;
  hence thesis by SCMPDS_6:35;
end;

begin :: Computing directly the result of "while>0" program by loop-invariant

scheme
  WhileGEnd { F(State of SCMPDS)-> Element of NAT, s() -> State of SCMPDS,
  P() -> (the Instructions of SCMPDS)-valued ManySortedSet of NAT,
  I()
-> halt-free shiftable Program of SCMPDS, a() -> Int_position,i() -> Integer,
P[set]}: F(Dstate IExec(while>0(a(),i(),I()),P(),s()))=0
 & P[Dstate IExec(while>0(a
  (),i(),I()),P(),s())]
provided
A2: for t be State of SCMPDS st P[Dstate t] holds F(Dstate(t))=0 iff t.
DataLoc(s().a(),i()) <= 0 and
A3: P[Dstate s()] and
A4: for t be State of SCMPDS,Q
    st P[Dstate t] & t.a()=s().a() & t.DataLoc(
s().a(),i()) > 0 holds IExec(I(),Q,t).a()=t.a() & I() is_closed_on t,Q & I()
is_halting_on t,Q & F(Dstate IExec(I(),Q,t)) < F(Dstate t)
 & P[Dstate(IExec(I(),Q,t))]
proof
  set b=DataLoc(s().a(),i()), WHL=while>0(a(),i(),I());
  defpred Q[Element of NAT] means
  for t be State of SCMPDS,Q st F(Dstate t) <=
  $1 & t.a()=s().a() & P[Dstate t] holds F(Dstate IExec(WHL,Q,t))=0 & P[Dstate
  IExec(WHL,Q,t)];
A5: Q[0]
  proof
    let t be State of SCMPDS, Q;
    assume that
A6: F(Dstate t) <= 0 and
A7: t.a()=s().a() and
A8: P[Dstate t];
    F(Dstate t) >= 0 by NAT_1:2;
    then
A9: F(Dstate t)=0 by A6,XXREAL_0:1;
    then t.DataLoc(s().a(),i()) <= 0 by A2,A8;
    then for b be Int_position holds IExec(WHL,Q,t).b = t.b by A7,SCMPDS_8:23;
    hence thesis by A8,A9,SCPISORT:5;
  end;
A10: now
    let k be Element of NAT;
    assume
A11: Q[k];
    now
      let u be State of SCMPDS;
      let U;
      assume that
A12:  F(Dstate u) <= k+1 and
A13:  u.a()=s().a() and
A14:  P[Dstate u];
      per cases;
      suppose
        F(Dstate u)=0;
        hence F(Dstate IExec(WHL,U,u))=0 & P[Dstate IExec(WHL,U,u)]
         by A5,A13,A14;
      end;
      suppose
A15:    F(Dstate u) <> 0;
        set Iu=IExec(I(),U,u);
A16:    u.b > 0 by A2,A14,A15;
        then
A17:    Iu.a()=s().a() & P[Dstate Iu] by A4,A13,A14;
        deffunc F(State of SCMPDS) = F($1);
A18:    P[Dstate u] by A14;
A19:    for t be State of SCMPDS st P[Dstate t] & F(Dstate(t))=0 holds t.
        DataLoc(u.a(),i()) <= 0 by A2,A13;
        F(Dstate Iu) < F(Dstate u) by A4,A13,A14,A16;
        then F(Dstate Iu)+1 <= F(Dstate u) by INT_1:20;
        then F(Dstate Iu)+1 <= k+1 by A12,XXREAL_0:2;
        then
A20:    F(Dstate Iu) <= k by XREAL_1:8;
A21:    for t being State of SCMPDS,Q st P[Dstate t] & t.a()=u.a() & t.
DataLoc(u.a(),i()) > 0 holds IExec(I(),Q,t).a()=t.a()
 & I() is_closed_on t,Q & I()
is_halting_on t,Q & F(Dstate IExec(I(),Q,t)) < F(Dstate t)
 & P[Dstate(IExec(I(),Q,t))
        ] by A4,A13;
A22:    u.DataLoc(u.a(),i()) > 0 by A2,A13,A14,A15;
        (F(u)=F(u) or P[u]) & IExec(WHL,U,u) = IExec(WHL,U,Iu) from SCMPDS_8:
        sch 4 (A22,A19,A18,A21);
        hence F(Dstate IExec(WHL,U,u))=0 & P[Dstate IExec(WHL,U,u)]
         by A11,A20,A17;
      end;
    end;
    hence Q[k+1];
  end;
  for k being Element of NAT holds Q[k] from NAT_1:sch 1(A5,A10);
  then Q[F(Dstate s())];
  hence thesis by A3;
end;

begin :: An Example : Computing directly Fibonacci sequence by loop-invariant

definition
  let n be Element of NAT;
  func Fib-macro(n) -> Program of SCMPDS equals
  (GBP:=0) ';' (intpos 1:=0) ';'
(intpos 2:=1) ';' (intpos 3:=n) ';' while>0(GBP,3,((GBP,4):=(GBP,2)) ';' AddTo(
  GBP,2,GBP,1) ';' ((GBP,1):=(GBP,4)) ';' AddTo(GBP,3,-1));
  coherence;
end;

theorem Th10:
  for s being State of SCMPDS,I being halt-free shiftable
Program of SCMPDS, a,f0,f1 being Int_position,n,i be Element of NAT st card I >
  0 & s.a=0 & s.f0=0 & s.f1=1 & s.intpos i=n &
  (for t be State of SCMPDS,Q
  for k be
  Element of NAT st n=t.intpos i+k & t.f0=Fib k & t.f1 = Fib (k+1) & t.a=0 & t.
  intpos i > 0 holds IExec(I,Q,t).a=0 & I is_closed_on t,Q
   & I is_halting_on t,Q &
  IExec(I,Q,t).intpos i=t.intpos i-1
   & IExec(I,Q,t).f0=Fib (k+1) & IExec(I,Q,t).f1 =
Fib (k+1+1)) holds IExec(while>0(a,i,I),P,s).f0=Fib n
 & IExec(while>0(a,i,I),P,s).
  f1=Fib (n+1) & while>0(a,i,I) is_closed_on s,P
   & while>0(a,i,I) is_halting_on s,P
proof
  let s be State of SCMPDS,I be halt-free shiftable Program of SCMPDS, a,f0,
  f1 be Int_position,n,i be Element of NAT;
  assume
A1: card I > 0;
  set Iw=IExec(while>0(a,i,I),P,s), Dw=Dstate Iw;
  set da=DataLoc(s.a,i);
  defpred P[State of SCMPDS] means $1.intpos i >= 0 & ex k be Element of NAT
  st n=$1.intpos i+k & $1.f0=Fib k & $1.f1=Fib (k+1);
  assume that
A2: s.a=0 and
A3: s.f0=0 and
A4: s.f1=1 and
A5: s.intpos i=n;
  consider ff be Function of product the Object-Kind of SCMPDS,NAT such that
A6: for t be State of SCMPDS holds (t.da <= 0 implies ff.t =0) & (t.da >
  0 implies ff.t=t.da) by SCMPDS_8:5;
  deffunc F(State of SCMPDS) = ff.$1;
A7: now
    let t be State of SCMPDS;
    set dt=Dstate t;
    assume P[dt];
    hereby
      assume
A8:   F(dt)=0;
      assume t.da > 0;
      then dt.da > 0 by SCMPDS_8:4;
      hence contradiction by A6,A8;
    end;
    assume t.da <= 0;
    then dt.da <= 0 by SCMPDS_8:4;
    hence F(dt)=0 by A6;
  end;
  assume
A9: for t be State of SCMPDS,Q
  for k be Element of NAT st n=t.intpos i+k & t.
  f0=Fib k & t.f1 = Fib (k+1) & t.a=0 & t.intpos i > 0
   holds IExec(I,Q,t).a=0 & I
is_closed_on t,Q & I is_halting_on t,Q
 & IExec(I,Q,t).intpos i=t.intpos i-1 & IExec(I,Q
  ,t).f0=Fib (k+1) & IExec(I,Q,t).f1 = Fib (k+1+1);
A10: now
    let t be State of SCMPDS, Q;
    set Dt=Dstate t;
    assume that
A11: P[Dstate t] and
A12: t.a=s.a and
A13: t.DataLoc(s.a,i) > 0;
    set It=IExec(I,Q,t);
    set Dit=Dstate It;
    consider k be Element of NAT such that
A14: n=Dt.intpos i+k and
A15: Dt.f0=Fib k and
A16: Dt.f1=Fib (k+1) by A11;
A17: t.f1=Fib (k+1) by A16,SCMPDS_8:4;
A18: intpos (0+i)=da by A2,SCMP_GCD:5;
A19: n=t.intpos i+k & t.f0=Fib k by A14,A15,SCMPDS_8:4;
    hence IExec(I,Q,t).a=t.a by A2,A9,A12,A13,A17,A18;
    thus I is_closed_on t,Q & I is_halting_on t,Q by A2,A9,A12,A13,A19,A17,A18;
A20: It.intpos i=t.intpos i-1 by A2,A9,A12,A13,A19,A17,A18;
    hereby
      per cases;
      suppose
        It.intpos i <= 0;
        then Dit.da <= 0 by A18,SCMPDS_8:4;
        then
A21:    F(Dit)=0 by A6;
        F(Dt) <> 0 by A7,A11,A13;
        hence F(Dit) < F(Dt) by A21,NAT_1:3;
      end;
      suppose
A22:    It.intpos i > 0;
        Dt.da > 0 by A13,SCMPDS_8:4;
        then
A23:    F(Dt)=Dt.da by A6
          .=t.intpos i by A18,SCMPDS_8:4;
        Dit.da > 0 by A18,A22,SCMPDS_8:4;
        then F(Dit)=Dit.da by A6
          .=t.intpos i-1 by A18,A20,SCMPDS_8:4;
        hence F(Dit) < F(Dt) by A23,XREAL_1:148;
      end;
    end;
    thus P[Dit]
    proof
      t.intpos i >= 1+0 by A13,A18,INT_1:20;
      then t.intpos i-1 >= 0 by XREAL_1:50;
      hence Dit.intpos i >= 0 by A20,SCMPDS_8:4;
      take m=k+1;
      thus n=t.intpos i-1+1+k by A14,SCMPDS_8:4
        .=Dit.intpos i+1+k by A20,SCMPDS_8:4
        .=Dit.intpos i+m;
      It.f0=Fib m & It.f1=Fib (k+1+1) by A2,A9,A12,A13,A19,A17,A18;
      hence thesis by SCMPDS_8:4;
    end;
  end;
A24: P[Dstate s]
  proof
    set Ds=Dstate s;
    Ds.intpos i =n by A5,SCMPDS_8:4;
    hence Ds.intpos i >= 0 by NAT_1:2;
    take k=0;
    thus n=Ds.intpos i+k by A5,SCMPDS_8:4;
    thus Ds.f0=Fib k by A3,PRE_FF:1,SCMPDS_8:4;
    thus thesis by A4,PRE_FF:1,SCMPDS_8:4;
  end;
A25: F(Dw)=0 & P[Dw] from WhileGEnd(A7,A24,A10);
  Dw.intpos i=Iw.intpos(0+i) by SCMPDS_8:4
    .=Iw.da by A2,SCMP_GCD:5;
  then Dw.intpos i <= 0 by A7,A25;
  then Dw.intpos i=0 by A25,XXREAL_0:1;
  hence Iw.f0=Fib n & Iw.f1=Fib (n+1) by A25,SCMPDS_8:4;
A26: for t be State of SCMPDS st P[Dstate t] & F(Dstate(t))=0 holds t.da <=
  0 by A7;
  (F(s)=F(s) or P[s]) & while>0(a,i,I) is_closed_on s,P & while>0(a,i,I)
  is_halting_on s,P from SCMPDS_8:sch 3(A26,A24,A10);
  hence thesis;
end;

set j1= (GBP,4):=(GBP,2), j2= AddTo(GBP,2,GBP,1), j3= (GBP,1):=(GBP,4), j4=
AddTo(GBP,3,-1), WB= j1 ';' j2 ';' j3 ';' j4, WH= while>0(GBP,3,WB);

Lm5: for s being State of SCMPDS st s.GBP=0
 holds IExec(WB,P,s).GBP=0 & IExec(WB,P
,s).a1=s.a2 & IExec(WB,P,s).a2=s.a1+s.a2 & IExec(WB,P,s).a3=s.a3-1

proof
  set a=GBP;
  let s be State of SCMPDS;

  set t0=Initialize s, t1=IExec(WB,P,s), t2=IExec(j1 ';' j2 ';' j3,P,s),
      Q0 = P,
      t3=IExec(j1 ';' j2,P,s), t4=Exec(j1, t0), a4=intpos 4;
A1: Initialize t0 = t0;
A2: t1=IExec(WB,Q0,t0) by SCMPDS_5:48;
A3: t2=IExec(j1 ';' j2 ';' j3,Q0,t0) by SCMPDS_5:48;
A4: t3=IExec(j1 ';' j2,Q0,t0) by SCMPDS_5:48;
  assume s.a=0;
  then
A5: t0.a=0 by SCMPDS_5:40;
  then DataLoc(t0.a,4)=intpos (0+4) by SCMP_GCD:5;
  then
A6: t4.a4=t0.DataLoc(t0.a,2) by SCMPDS_2:59
    .=t0.intpos(0+2) by A5,SCMP_GCD:5
    .=s.a2 by SCMPDS_5:40;
  0 <> abs(t0.GBP+4) by A5,ABSVALUE:def 1;
  then a <> DataLoc(t0.GBP,4) by ZFMISC_1:33;
  then
A7: t4.a=0 by A5,SCMPDS_2:59;
  then
A8: DataLoc(t4.a,2)=intpos (0+2) by SCMP_GCD:5;
  0 <> abs(t4.GBP+2) by A7,ABSVALUE:def 1;
  then
A9: a <> DataLoc(t4.GBP,2) by ZFMISC_1:33;
A10: t3.a=Exec(j2,t4).a by A1,A4,SCMPDS_5:47
    .=0 by A7,A9,SCMPDS_2:61;
  then
A11: DataLoc(t3.a,1)=intpos (0+1) by SCMP_GCD:5;
  4 <> abs(t4.GBP+2) by A7,ABSVALUE:def 1;
  then
A12: a4 <> DataLoc(t4.GBP,2) by ZFMISC_1:33;
A13: t3.a4=Exec(j2,t4).a4 by A1,A4,SCMPDS_5:47
    .=s.a2 by A6,A12,SCMPDS_2:61;
A14: t2.a1=Exec(j3,t3).a1 by A3,A4,SCMPDS_5:46
    .=t3.DataLoc(t3.a,4) by A11,SCMPDS_2:59
    .=s.a2 by A10,A13,SCMP_GCD:5;
  3 <> abs(t4.GBP+2) by A7,ABSVALUE:def 1;
  then
A15: a3 <> DataLoc(t4.GBP,2) by ZFMISC_1:33;
  2 <> abs(t0.GBP+4) by A5,ABSVALUE:def 1;
  then a2 <> DataLoc(t0.GBP,4) by ZFMISC_1:33;
  then
A16: t4.a2=t0.a2 by SCMPDS_2:59
    .=s.a2 by SCMPDS_5:40;
  1 <> abs(t0.GBP+4) by A5,ABSVALUE:def 1;
  then a1 <> DataLoc(t0.GBP,4) by ZFMISC_1:33;
  then
A17: t4.a1=t0.a1 by SCMPDS_2:59
    .=s.a1 by SCMPDS_5:40;
  3 <> abs(t0.GBP+4) by A5,ABSVALUE:def 1;
  then a3 <> DataLoc(t0.GBP,4) by ZFMISC_1:33;
  then
A18: t4.a3=t0.a3 by SCMPDS_2:59
    .=s.a3 by SCMPDS_5:40;
  0 <> abs(t3.GBP+1) by A10,ABSVALUE:def 1;
  then
A19: a <> DataLoc(t3.GBP,1) by ZFMISC_1:33;
A20: t2.a=Exec(j3,t3).a by A3,A4,SCMPDS_5:46
    .=0 by A10,A19,SCMPDS_2:59;
  then
A21: DataLoc(t2.a,3)=intpos (0+3) by SCMP_GCD:5;
  2 <> abs(t3.GBP+1) by A10,ABSVALUE:def 1;
  then
A22: a2 <> DataLoc(t3.GBP,1) by ZFMISC_1:33;
A23: t3.a2=Exec(j2,t4).a2 by A1,A4,SCMPDS_5:47
    .=t4.a2+t4.DataLoc(t4.a,1) by A8,SCMPDS_2:61
    .=s.a2+s.a1 by A7,A17,A16,SCMP_GCD:5;
A24: t2.a2=Exec(j3,t3).a2 by A3,A4,SCMPDS_5:46
    .=s.a2+s.a1 by A23,A22,SCMPDS_2:59;
  3 <> abs(t3.GBP+1) by A10,ABSVALUE:def 1;
  then
A25: a3 <> DataLoc(t3.GBP,1) by ZFMISC_1:33;
  0 <> abs(t2.GBP+3) by A20,ABSVALUE:def 1;
  then
A26: a <> DataLoc(t2.GBP,3) by ZFMISC_1:33;
  thus t1.a=Exec(j4,t2).a by A2,A3,SCMPDS_5:46
    .=0 by A20,A26,SCMPDS_2:60;
  1 <> abs(t2.GBP+3) by A20,ABSVALUE:def 1;
  then
A27: a1 <> DataLoc(t2.GBP,3) by ZFMISC_1:33;
  thus t1.a1=Exec(j4,t2).a1 by A2,A3,SCMPDS_5:46
    .=s.a2 by A14,A27,SCMPDS_2:60;
  2 <> abs(t2.GBP+3) by A20,ABSVALUE:def 1;
  then
A28: a2 <> DataLoc(t2.GBP,3) by ZFMISC_1:33;
A29: t3.a3=Exec(j2,t4).a3 by A1,A4,SCMPDS_5:47
    .=s.a3 by A18,A15,SCMPDS_2:61;
A30: t2.a3=Exec(j3,t3).a3 by A3,A4,SCMPDS_5:46
    .=s.a3 by A29,A25,SCMPDS_2:59;
  thus t1.a2=Exec(j4,t2).a2 by A2,A3,SCMPDS_5:46
    .=s.a1+s.a2 by A24,A28,SCMPDS_2:60;
  thus t1.a3=Exec(j4,t2).a3 by A2,A3,SCMPDS_5:46
    .=t2.a3+-1 by A21,SCMPDS_2:60
    .=s.a3-1 by A30;
end;

Lm6: card WB=4
proof
  thus card WB=card (j1 ';' j2 ';' j3) +1 by SCMP_GCD:8
    .=card (j1 ';' j2)+1+1 by SCMP_GCD:8
    .=2+1+1 by SCMP_GCD:9
    .=4;
end;

Lm7: for s being State of SCMPDS,n be Element of NAT st s.GBP=0 & s.a1=0 & s.
a2=1 & s.a3=n holds IExec(WH,P,s).a1=Fib n & IExec(WH,P,s).a2=Fib (n+1) & WH
is_closed_on s,P & WH is_halting_on s,P

proof
  let s be State of SCMPDS,n be Element of NAT;
  set a=GBP;
A1: now
    let t be State of SCMPDS,Q;
    let k be Element of NAT;
    assume that
    n=t.a3+k and
A2: t.a1=Fib k and
A3: t.a2 = Fib (k+1) and
A4: t.a=0 and
    t.a3 > 0;
    thus IExec(WB,Q,t).a=0 by A4,Lm5;
    thus WB is_closed_on t,Q & WB is_halting_on t,Q by SCMPDS_6:34,35;
    thus IExec(WB,Q,t).a3=t.a3-1 by A4,Lm5;
    thus IExec(WB,Q,t).a1=Fib (k+1) by A3,A4,Lm5;
    thus IExec(WB,Q,t).a2 =t.a1+t.a2 by A4,Lm5
      .=Fib (k+1+1) by A2,A3,PRE_FF:1;
  end;
  assume s.GBP=0 & s.a1=0 & s.a2=1 & s.a3=n;
  hence thesis by A1,Lm6,Th10;
end;

Lm8: for s being 0-started State of SCMPDS,
n be Element of NAT holds IExec(Fib-macro(n),P,
s).a1=Fib n & IExec(Fib-macro(n),P,s).a2=Fib (n+1)
 & Fib-macro(n) is_halting_on s,P

proof
  let s be 0-started State of SCMPDS,n be Element of NAT;

  set a=GBP, i1=a:=0, i2=a1:=0, i3=a2:=1, i4=a3:=n, I4=i1 ';' i2 ';' i3 ';' i4

, t1=IExec(I4,P,s), Q1 = P,
  t2=IExec(i1 ';' i2 ';' i3,P,s), t3=IExec(i1 ';' i2,P,s), t4=Exec(
  i1, Initialize s);
A1: t4.a=0 by SCMPDS_2:57;
A2: t3.a=Exec(i2, t4).a by SCMPDS_5:47
    .=0 by A1,AMI_3:52,SCMPDS_2:57;
A3: t2.a=Exec(i3, t3).a by SCMPDS_5:46
    .=0 by A2,AMI_3:52,SCMPDS_2:57;
A4: t3.a1=Exec(i2, t4).a1 by SCMPDS_5:47
    .=0 by SCMPDS_2:57;
A5: t2.a1=Exec(i3, t3).a1 by SCMPDS_5:46
    .=0 by A4,AMI_3:52,SCMPDS_2:57;
A6: t1.a1=Exec(i4, t2).a1 by SCMPDS_5:46
    .=0 by A5,AMI_3:52,SCMPDS_2:57;
A7: t2.a2=Exec(i3, t3).a2 by SCMPDS_5:46
    .=1 by SCMPDS_2:57;
A8: t1.a2=Exec(i4, t2).a2 by SCMPDS_5:46
    .=1 by A7,AMI_3:52,SCMPDS_2:57;
A9: t1.a3=Exec(i4, t2).a3 by SCMPDS_5:46
    .=n by SCMPDS_2:57;
A10: t1.a=Exec(i4, t2).a by SCMPDS_5:46
    .=0 by A3,AMI_3:52,SCMPDS_2:57;
  then
A11: WH is_closed_on t1,Q1 & WH is_halting_on t1,Q1 by A6,A8,A9,Lm7;
  IExec(WH,Q1,t1).a1=Fib n by A10,A6,A8,A9,Lm7;
  hence IExec(Fib-macro(n),P,s).a1=Fib n by A11,SCPISORT:8;
  IExec(WH,Q1,t1).a2=Fib (n+1) by A10,A6,A8,A9,Lm7;
  hence IExec(Fib-macro(n),P,s).a2=Fib (n+1) by A11,SCPISORT:8;
  thus thesis by A11,SCPISORT:10;
end;

theorem
  for s being 0-started State of SCMPDS,
  n be Element of NAT holds IExec(Fib-macro(
n),P,s).intpos 1=Fib n &
IExec(Fib-macro(n),P,s).intpos 2=Fib (n+1) & Fib-macro(n)
  is parahalting
proof
  let s be 0-started State of SCMPDS,n be Element of NAT;
  thus IExec(Fib-macro(n),P,s).a1=Fib n &
  IExec(Fib-macro(n),P,s).a2=Fib (n+1) by
Lm8;
  for t be State of SCMPDS,Q holds Fib-macro(n) is_halting_on t,Q
   proof let t be State of SCMPDS, Q;
     Fib-macro(n) is_halting_on Initialize t,Q by Lm8;
    hence thesis by SCMPDS_6:140;
   end;
  hence thesis by SCMPDS_6:35;
end;

begin :: The construction of while<>0 loop program

:: while (a,i)<>0 do I

definition
  let a be Int_position, i be Integer;
  let I be Program of SCMPDS;
  func while<>0(a,i,I) -> Program of SCMPDS equals
  (a,i)<>0_goto 2 ';' goto (
  card I+2) ';' I ';' goto -(card I+2);
  coherence;
end;

begin :: The basic property of "while<>0" program

theorem Th12:
  for a be Int_position,i be Integer,I be Program of SCMPDS holds
  card while<>0(a,i,I)= card I +3
proof
  let a be Int_position,i be Integer, I be Program of SCMPDS;
  set i1=(a,i)<>0_goto 2, i2=goto (card I+2);
  set I4=i1 ';' i2 ';' I;
  thus card while<>0(a,i,I) =card I4+1 by SCMP_GCD:8
    .=card (i1 ';' i2)+ card I+1 by AFINSQ_1:20
    .=2+card I +1 by SCMP_GCD:9
    .=card I + 3;
end;

Lm9: for a be Int_position,i be Integer,I be Program of SCMPDS holds card stop
while<>0(a,i,I)= card I+4

proof
  let a be Int_position,i be Integer,I be Program of SCMPDS;
  thus card stop while<>0(a,i,I)= card while<>0(a,i,I) +1 by SCMPDS_5:7
    .= card I +3+1 by Th12
    .= card I + 4;
end;

theorem Th13:
  for a be Int_position,i be Integer,m be Element of NAT,I be
  Program of SCMPDS holds m < card I+3 iff  m in dom while<>0(a,i,I)
proof
  let a be Int_position,i be Integer,m be Element of NAT, I be Program of
  SCMPDS;
  card while<>0(a,i,I)=card I + 3 by Th12;
  hence thesis by AFINSQ_1:70;
end;

theorem Th14:
  for a be Int_position,i be Integer,I be Program of SCMPDS holds
   0 in dom while<>0(a,i,I) &  1 in dom while<>0(a,i,I)
proof
  let a be Int_position,i be Integer,I be Program of SCMPDS;
  3 <= card I+3 by NAT_1:11;
  then 0 < card I+3 & 1 < card I+3 by XXREAL_0:2;
  hence thesis by Th13;
end;

theorem Th15:
  for a be Int_position,i be Integer,I be Program of SCMPDS holds
while<>0(a,i,I). 0=(a,i)<>0_goto 2 & while<>0(a,i,I). 1= goto (card
  I +2) & while<>0(a,i,I). (card I+2)=goto -(card I+2)
proof
  let a be Int_position,i be Integer,I be Program of SCMPDS;
  set i1=(a,i)<>0_goto 2, i2=goto (card I+2), i3=goto -(card I+2);
  set I4=i1 ';' i2 ';' I;
  set WHL=while<>0(a,i,I);
A1: WHL=i1 ';' i2 ';' (I ';' i3) by SCMPDS_4:47;
  hence WHL. 0=i1 by Th5;
  thus WHL. 1=i2 by A1,Th5;
  card I4=card (i1 ';' i2)+ card I by AFINSQ_1:20
    .=card I +2 by SCMP_GCD:9;
  hence thesis by SCMP_GCD:10;
end;

Lm10: for a be Int_position,i be Integer,I be Program of SCMPDS holds while<>0
(a,i,I)= ((a,i)<>0_goto 2) ';' (goto (card I+2) ';' I ';' goto -(card I+2))

proof
  let a be Int_position,i be Integer,I be Program of SCMPDS;
  set i1=(a,i)<>0_goto 2, i2=goto (card I+2), i3=goto -(card I+2);
  thus while<>0(a,i,I) = i1 ';' (i2 ';' I) ';' i3 by SCMPDS_4:52
    .= i1 ';' (i2 ';' I ';' i3) by SCMPDS_4:51;
end;

theorem Th16:
  for s being State of SCMPDS,I being Program of SCMPDS,a being
  Int_position, i being Integer st s.DataLoc(s.a,i) = 0 holds while<>0(a,i,I)
  is_closed_on s,P & while<>0(a,i,I) is_halting_on s,P
proof
  let s be State of SCMPDS,I be Program of SCMPDS,a be Int_position, i be
  Integer;
  set b=DataLoc(s.a,i);
  assume
A1: s.b = 0;
  set WHL=while<>0(a,i,I), pWH=stop WHL, iWH=pWH,
  s3 = Initialize s, P3 = P +* pWH,
  s4 = Comput(P3,s3,1), s5 = Comput(P3,s3,2), P4 = P3, P5 = P3;
A3: not b in dom Start-At(0,SCMPDS) by SCMPDS_4:59;
  not a in dom Start-At(0,SCMPDS) by SCMPDS_4:59;
  then
A4: s3.DataLoc(s3.a,i)=s3.b by FUNCT_4:12
    .= 0 by A1,A3,FUNCT_4:12;
  set i1=(a,i)<>0_goto 2, i2=goto (card I+2), i3=goto -(card I+2);
A5: IC s3 = 0 by COMPOS_1:223;
A6: WHL = i1 ';' (i2 ';' I ';' i3 ) by Lm10;
  Comput(P3,s3,0+1) = Following(P3,
  Comput(P3,s3,0)) by EXTPRO_1:4
    .= Following(P3,s3) by EXTPRO_1:3
    .= Exec(i1,s3) by A6,SCMPDS_6:22;
  then
A7: IC s4 = succ IC s3 by A4,SCMPDS_2:67
    .= (0+1) by A5;
A8: iWH c= P3 by FUNCT_4:26;
  then
A9: pWH c= P4;
A10:  1 in dom WHL by Th14;
  then  1 in dom pWH by SCMPDS_6:18;
  then
A11: P4. 1 = pWH. 1 by A9,GRFUNC_1:8
    .=WHL. 1 by A10,SCMPDS_6:19
    .=i2 by Th15;
A12: card WHL=card I+3 by Th12;
  then
A13: (card I+3) in dom pWH by SCMPDS_6:25;
A14: P4/.IC s4 = P4.IC s4 by PBOOLE:158;
  Comput(P3,s3,1+1) = Following(P3,s4) by EXTPRO_1:4
    .= Exec(i2,s4) by A7,A11,A14;
  then
A16: IC s5 = ICplusConst(s4,card I+2) by SCMPDS_2:66
    .= (card I+2+1) by A7,SCMPDS_6:23
    .= (card I+(2+1));
A17: P5/.IC s5 = P5.IC s5 by PBOOLE:158;
  pWH c= P5 by A8;
  then P5.(card I+3) = pWH.(card I+3) by A13,GRFUNC_1:8
    .=halt SCMPDS by A12,SCMPDS_6:25;
  then
A18: CurInstr(P5,s5) = halt SCMPDS by A16,A17;
  now
    let k be Element of NAT;
    k = 0 or 0 < k by NAT_1:3;
    then
A20: k = 0 or 0 + 1 <= k by INT_1:20;
    per cases by A20,XXREAL_0:1;
    suppose
      k = 0;
      then Comput(P3,s3,k) = s3 by EXTPRO_1:3;
      hence IC Comput(P3,s3,k) in dom pWH by A5,COMPOS_1:135;
    end;
    suppose
      k = 1;
      hence IC Comput(P3,s3,k) in dom pWH by A10,A7,SCMPDS_6:18;
    end;
    suppose
      1 < k;
      then 1+1 <= k by INT_1:20;
      hence IC Comput(P3,s3,k) in dom pWH
      by A13,A16,A18,EXTPRO_1:6;
    end;
  end;
  hence WHL is_closed_on s,P by SCMPDS_6:def 2;
  P3 halts_on s3 by A18,EXTPRO_1:30;
  hence thesis by SCMPDS_6:def 3;
end;

theorem Th17:
  for s being State of SCMPDS,I being Program of SCMPDS,a,c being
Int_position, i being Integer st s.DataLoc(s.a,i) = 0
 holds IExec(while<>0(a,i,I),P,s) = s +* Start-At((card I+3),SCMPDS)
proof
  let s be State of SCMPDS,I be Program of SCMPDS, a,c be Int_position, i be
  Integer;
  set b=DataLoc(s.a,i);
  assume
A1: s.b = 0;
  set i1=(a,i)<>0_goto 2, i2=goto (card I+2), i3=goto -(card I+2);
  set WHL=while<>0(a,i,I), pWH=stop WHL, iWH=pWH,
  s3 = Initialize s, P3 = P +* pWH,
  s4 = Comput(P3,s3,1), s5 = Comput(P3,s3,2), P4 = P3, P5 = P3;
A3: IC s3 = 0 by COMPOS_1:223;
A4: iWH c= P3 by FUNCT_4:26;
  then
A5: pWH c= P4;
A6: pWH c= P5 by A4;
A7: not b in dom Start-At(0,SCMPDS) by SCMPDS_4:59;
A8: WHL = i1 ';' (i2 ';' I ';' i3 ) by Lm10;
A9: Comput(P3,s3,0+1) = Following(P3,
Comput(P3,s3,0)) by EXTPRO_1:4
    .= Following(P3,s3) by EXTPRO_1:3
    .= Exec(i1,s3) by A8,SCMPDS_6:22;
A10:  1 in dom WHL by Th14;
  then  1 in dom pWH by SCMPDS_6:18;
  then
A11: P4. 1 = pWH. 1 by A5,GRFUNC_1:8
    .=WHL. 1 by A10,SCMPDS_6:19
    .=i2 by Th15;
  set SAl=Start-At((card I+3),SCMPDS);
A12: dom ProgramPart s = A by COMPOS_1:34;
  not a in dom Start-At(0,SCMPDS) by SCMPDS_4:59;
  then s3.DataLoc(s3.a,i)=s3.b by FUNCT_4:12
    .= 0 by A1,A7,FUNCT_4:12;
  then
A13: IC s4 = succ IC s3 by A9,SCMPDS_2:67
    .= (0+1) by A3;
A16: P3/.IC s4 = P4.IC s4 by PBOOLE:158;
A17: Comput(P3,s3,1+1) = Following(P3,s4) by
EXTPRO_1:4
    .= Exec(i2,s4) by A13,A11,A16;
  then
A18: IC s5 = ICplusConst(s4,card I+2) by SCMPDS_2:66
    .= (card I+2+1) by A13,SCMPDS_6:23
    .= (card I+(2+1));
A19: P3/.IC s5 = P5.IC s5 by PBOOLE:158;
A20: card WHL=card I+3 by Th12;
  then (card I+3) in dom pWH by SCMPDS_6:25;
  then P5.(card I+3) = pWH.(card I+3) by A6,GRFUNC_1:8
    .=halt SCMPDS by A20,SCMPDS_6:25;
  then
A21: CurInstr(P3,s5) = halt SCMPDS by A18,A19;
  then P3 halts_on s3 by EXTPRO_1:30;
  then
A22: s5 = Result(P3,s3) by A21,EXTPRO_1:def 8;
A23: IExec(WHL,P,s) = Result(P3,s3) +* s | A by SCMPDS_4:def 8;
A24: now
    let x be set;
A25: dom SAl = {IC SCMPDS} by FUNCOP_1:19;
    assume
A26: x in dom IExec(WHL,P,s);
    per cases by A26,SCMPDS_4:20;
    suppose
A27:  x is Int_position;
      then x <> IC SCMPDS by SCMPDS_2:52;
      then
A28:  not x in dom SAl by A25,TARSKI:def 1;
TT:   not x in dom Start-At(0,SCMPDS) by A27,SCMPDS_4:59;
      not x in dom (s | A) by A12,A27,SCMPDS_2:53;
      hence IExec(WHL,P,s).x = s5.x by A22,A23,FUNCT_4:12
        .= s4.x by A17,A27,SCMPDS_2:66
        .= s3.x by A9,A27,SCMPDS_2:67
        .= s.x by TT,FUNCT_4:12
        .= (s +* SAl).x by A28,FUNCT_4:12;
    end;
    suppose
A29:  x = IC SCMPDS;
      not x in dom (s | A) by A12,A29,COMPOS_1:3;
      hence IExec(WHL,P,s).x = (card I + 3) by A18,A22,A23,A29,FUNCT_4:12
        .= (s +* SAl).x by A29,FUNCT_4:121;
    end;
    suppose
      x is Element of NAT;
      hence IExec(WHL,P,s).x = (s +* SAl).x by SCMPDS_6:27;
    end;
  end;
  dom IExec(WHL,P,s) = the carrier of SCMPDS by PARTFUN1:def 4
    .= dom (s +* SAl) by PARTFUN1:def 4;
  hence thesis by A24,FUNCT_1:9;
end;

theorem
  for s being State of SCMPDS,I being Program of SCMPDS,a being
Int_position, i being Integer st s.DataLoc(s.a,i) = 0
 holds IC IExec(while<>0(a
  ,i,I),P,s) =  (card I + 3)
proof
  let s be State of SCMPDS,I be Program of SCMPDS,a be Int_position, i be
  Integer;
  assume s.DataLoc(s.a,i) = 0;
  then IExec(while<>0(a,i,I),P,s) =s +* Start-At((card I+3),SCMPDS)
  by Th17;
  hence thesis by FUNCT_4:121;
end;

theorem Th19:
  for s being State of SCMPDS,I being Program of SCMPDS,a,b being
Int_position, i being Integer st s.DataLoc(s.a,i) = 0
 holds IExec(while<>0(a,i,
  I),P,s).b = s.b
proof
  let s be State of SCMPDS,I be Program of SCMPDS,a,b be Int_position, i be
  Integer;
  assume s.DataLoc(s.a,i) = 0;
  then
A1: IExec(while<>0(a,i,I),P,s) = s +* Start-At((card I+3),SCMPDS) by Th17;
  not b in dom Start-At((card I+3),SCMPDS) by SCMPDS_4:59;
  hence thesis by A1,FUNCT_4:12;
end;

Lm11: for I being Program of SCMPDS,a being Int_position,i being Integer holds
Shift(I,2) c= while<>0(a,i,I)

proof
  let I be Program of SCMPDS,a be Int_position,i be Integer;
  set i1=(a,i)<>0_goto 2, i2=goto (card I+2), i3=goto -(card I+2);

  card (i1 ';' i2)=2 & while<>0(a,i,I) = i1 ';' i2 ';' I ';' Load i3 by
SCMPDS_4:def 5,SCMP_GCD:9;

  hence thesis by SCMPDS_7:16;
end;

registration
  let I be shiftable Program of SCMPDS, a be Int_position,i be Integer;
  cluster while<>0(a,i,I) -> shiftable;
  correctness
  proof
    set WHL=while<>0(a,i,I), i1=(a,i)<>0_goto 2, i2=goto (card I+2), PF= i1
    ';' i2 ';' I;
    card PF=card (i1 ';' i2)+ card I by AFINSQ_1:20
      .=2+card I by SCMP_GCD:9;
    then PF=Load i1 ';' Load i2 ';' I & card PF+ -(card I+2) =0 by
SCMPDS_4:def 6;
    hence thesis by SCMPDS_4:78;
  end;
end;

registration
  let I be halt-free Program of SCMPDS, a be Int_position,i be Integer;
  cluster while<>0(a,i,I) -> halt-free;
  correctness
  proof
    reconsider i2=goto (card I+2) as No-StopCode Instruction of SCMPDS by
SCMPDS_5:25;
    -(card I+2) <> 0;
    then reconsider
    i3=goto -(card I+2) as No-StopCode Instruction of SCMPDS by SCMPDS_5:25;
    while<>0(a,i,I) =(a,i)<>0_goto 2 ';' i2 ';' I ';' i3;
    hence thesis;
  end;
end;

begin :: Computing directly the result of "while<>0" program by loop-invariant

scheme
  WhileNHalt { F(State of SCMPDS)-> Element of NAT, s() -> State of SCMPDS,
  P() -> (the Instructions of SCMPDS)-valued ManySortedSet of NAT,
  I()
-> halt-free shiftable Program of SCMPDS, a() -> Int_position,i() -> Integer,
  P[set]}: while<>0(a(),i(),I()) is_closed_on s(),P() & while<>0(a(),i(),I())
  is_halting_on s(),P()
provided
A1: card I() > 0 and
A2: for t be State of SCMPDS st P[Dstate t] & F(Dstate(t))=0 holds t.
DataLoc(s().a(),i()) = 0 and
A3: P[Dstate s()] and
A4: for t be State of SCMPDS,Q
   st P[Dstate t] & t.a()=s().a() & t.DataLoc(
s().a(),i()) <> 0 holds IExec(I(),Q,t).a()=t.a() & I() is_closed_on t,Q & I()
is_halting_on t,Q & F(Dstate IExec(I(),Q,t)) < F(Dstate t)
 & P[Dstate(IExec(I(),Q,t))]
proof
  set i1=(a(),i())<>0_goto 2, i2=goto (card I()+2), i3=goto -(card I()+2);
  set WHL=while<>0(a(),i(),I()), pWH=stop WHL, pI=stop I();
  set b=DataLoc(s().a(),i());
  defpred Q[Element of NAT] means
   for t be State of SCMPDS,Q st F(Dstate(t)) <=
$1 & P[Dstate t] & t.a()=s().a()
     holds WHL is_closed_on t,Q & WHL is_halting_on t,Q;
A5: for k be Element of NAT st Q[k] holds Q[k + 1]
  proof
    let k be Element of NAT;
    assume
A6: Q[k];
    now
      let t be State of SCMPDS;
      let Q;
      assume
A7:   F(Dstate t) <= k+1;
      assume
A8:   P[Dstate t];
      assume
A9:   t.a()=s().a();
      per cases;
      suppose
        t.b = 0;
        hence WHL is_closed_on t,Q & WHL is_halting_on t,Q by A9,Th16;
      end;
      suppose
A10:    t.b <> 0;
A11:    dom ProgramPart t = A by COMPOS_1:34;
A12:  not a() in dom (t | A) by A11,SCMPDS_2:53;
A13:    IExec(I(),Q,t).a()=t.a() by A4,A8,A9,A10;
A14:     0 in dom pWH by COMPOS_1:135;
A15:    dom ProgramPart t = A by COMPOS_1:34;
A16:    WHL = i1 ';' (i2 ';' I() ';' i3) by Lm10;
A17:    not b in dom Start-At(0,SCMPDS) by SCMPDS_4:59;
        set t2 = Initialize t, Q2 = Q +* pI,
            t3 = Initialize t, Q3 = Q +* pWH,
        t4 = Comput(Q3,t3,1), Q4 = Q3;
A20:    pI c= Q2 by FUNCT_4:26;
B20:    Start-At(0,SCMPDS) c= t2 by FUNCT_4:26;
        set m2=LifeSpan(Q2,t2), t5=Comput(Q4,t4,m2), Q5 = Q4,
l2= (card I() + 2
);
A21:    IC t3 = 0 by COMPOS_1:223;
        set m3=m2 +1;
        set t6=Comput(Q3,t3,m3), Q6 = Q3;
        set t7=Comput(Q3,t3,m3+1), Q7 = Q3;
        card I() + 2 < card I() + 3 by XREAL_1:8;
        then
A22:    l2 in dom WHL by Th13;
QQ:     pWH c= Q3 by FUNCT_4:26;
        WHL c= pWH by AFINSQ_1:78;
        then
A23:    WHL c= Q3 by XBOOLE_1:1,QQ;
        Shift(I(),2) c= WHL by Lm11;
        then Shift(I(),2) c= Q3 by A23,XBOOLE_1:1;
        then
A24:    Shift(I(),2) c= Q4;
A25:    Comput(Q3,t3,0+1) = Following(Q3,
Comput(Q3,t3,0)) by EXTPRO_1:4
          .= Following(Q3,t3) by EXTPRO_1:3
          .= Exec(i1,t3) by A16,SCMPDS_6:22;
        now
          let a;
          thus t2.a = t3.a
            .= t4.a by A25,SCMPDS_2:67;
        end;
        then
A27:    DataPart t2 = DataPart t4 by SCMPDS_4:23;
        I() is_halting_on t,Q by A4,A8,A9,A10;
        then
A28:    Q2 halts_on t2 by SCMPDS_6:def 3;
        Q2 = Q2+*pI by A20,FUNCT_4:104;
        then Q2+*pI halts_on Initialize t2 by A28;
        then
A30:    I() is_halting_on t2,Q2 by SCMPDS_6:def 3;
A31:    IExec(I(),Q,t) = Result(Q2,t2) +* t | A
 by SCMPDS_4:def 8;
A32:    P[Dstate(IExec(I(),Q,t))] by A4,A8,A9,A10;
A33:    I() is_closed_on t,Q by A4,A8,A9,A10;
        then
A34:    I() is_closed_on t2,Q2 by SCMPDS_6:38;
        not a() in dom Start-At(0,SCMPDS) by SCMPDS_4:59;
        then t3.DataLoc(t3.a(),i())= t3.b by A9,FUNCT_4:12
          .= t.b by A17,FUNCT_4:12;
        then
A35:    IC t4 = ICplusConst(t3,2) by A10,A25,SCMPDS_2:67
          .= 0+2 by A21,SCMPDS_6:23;
        then
A36:    IC t5=l2 by A1,A20,B20,A30,A34,A27,A24,SCMPDS_7:36;
A37: Q6/.IC t6 = Q6.IC t6 by PBOOLE:158;
A38:    t6=t5 by EXTPRO_1:5;
        then
A39:    CurInstr(Q6,t6)
           =Q5.l2 by A1,A20,B20,A30,A34,A35,A27,A24,A37,SCMPDS_7:36
          .=Q4.l2
          .=Q3.l2
          .=WHL.l2 by A22,A23,GRFUNC_1:8
          .=i3 by Th15;
A41:    t7 = Following(Q3,t6) by EXTPRO_1:4
          .= Exec(i3,t6) by A39;
        then IC t7=ICplusConst(t6,0-(card I()+2)) by SCMPDS_2:66
          .= 0 by A36,A38,SCMPDS_7:1;
        then
B42:    Initialize t7 = t7 by SCMPDS_7:37;
A42:    Q7 +* pWH=Q7 by FUNCT_4:99;
A43:    DataPart Comput(Q2,t2,m2) = DataPart t5 by A1,A20,B20,A30,A34
,A35,A27,A24,SCMPDS_7:36;
        then
A44:    DataPart t5 = DataPart(Result(Q2,t2)) by A28,EXTPRO_1:23
          .= DataPart(Result(Q2,t2) +* t | A) by A15,AMI_2:29
,FUNCT_4:76,SCMPDS_2:100
          .= DataPart IExec(I(),Q,t) by SCMPDS_4:def 8;
        InsCode i3=0 by SCMPDS_2:21;
        then InsCode i3 in {0,4,5,6} by ENUMSET1:def 2;
        then
A45:    Dstate(t7)=Dstate(t6) by A41,SCMPDS_8:3
          .=Dstate(IExec(I(),Q,t)) by A44,A38,SCMPDS_8:2;
A46:    now
          F(Dstate(IExec(I(),Q,t))) < F(Dstate(t)) by A4,A8,A9,A10;
          then
A47:      F(Dstate(t7)) < k+1 by A7,A45,XXREAL_0:2;
          assume F(Dstate(t7)) > k;
          hence contradiction by A47,INT_1:20;
        end;
A48:    t5.a()=Comput(Q2,t2,m2).a() by A43,SCMPDS_4:23
          .=(Result(Q2,t2)).a() by A28,EXTPRO_1:23
          .=s().a() by A9,A13,A31,A12,FUNCT_4:12;
A50:    t7.a()=t6.a() by A41,SCMPDS_2:66
          .=s().a() by A48,EXTPRO_1:5;
        then
A51:    WHL is_closed_on t7,Q7 by A6,A32,A45,A46;
        now
          let k be Element of NAT;
          per cases;
          suppose
            k < m3+1;
            then
A52:        k <= m3 by INT_1:20;
            hereby
              per cases by A52,NAT_1:8;
              suppose
A53:            k <= m2;
                hereby
                  per cases;
                  suppose
                    k=0;
                    hence IC Comput(Q3,t3,k) in dom pWH by A14,A21
,EXTPRO_1:3;
                  end;
                  suppose
                    k<>0;
                    then consider kn be Nat such that
A54:                k=kn+1 by NAT_1:6;
                    reconsider kn as Element of NAT by ORDINAL1:def 13;
                    reconsider lm = IC Comput(Q2,t2,kn) as Element
of NAT;
                    kn < k by A54,XREAL_1:31;
                    then kn < m2 by A53,XXREAL_0:2;
                    then IC Comput(Q2,t2,kn) + 2 = IC Comput(
         Q4,t4,kn) by A1,A20,B20,A30,A34,A35,A27,A24,SCMPDS_7:34;
                    then
A56:                IC Comput(Q3,t3,k) = (lm+2) by A54,
EXTPRO_1:5;
                    IC Comput(Q2,t2,kn) in dom pI by A33,
SCMPDS_6:def 2;
                    then lm < card pI by AFINSQ_1:70;
                    then lm < card I()+1 by SCMPDS_5:7;
                    then
A57:                lm+2 < card I() +1+2 by XREAL_1:8;
                    card I() + 3 < card I() + 4 by XREAL_1:8;
                    then lm+2 < card I() +4 by A57,XXREAL_0:2;
                    then lm+2 < card pWH by Lm9;
                    hence IC Comput(Q3,t3,k) in dom pWH by A56,
AFINSQ_1:70;
                  end;
                end;
              end;
              suppose
A58:            k=m3;
                l2 in dom pWH by A22,SCMPDS_6:18;
                hence
                IC Comput(Q3,t3,k) in dom pWH by A1,A20,B20,A30,A34
,A35,A27,A24,A38,A58,SCMPDS_7:36;
              end;
            end;
          end;
          suppose
            k >= m3+1;
            then consider nn be Nat such that
A59:        k=m3+1+nn by NAT_1:10;
            reconsider nn as Element of NAT by ORDINAL1:def 13;
    Q3 = Q7+*pWH by FUNCT_4:99;
       then
            Comput(Q3,t3,k)=
            Comput(Q7+*pWH,Initialize t7,nn) by A59,EXTPRO_1:5,B42;
            hence IC Comput(Q3,t3,k) in dom pWH by A51,
SCMPDS_6:def 2;
          end;
        end;
        hence WHL is_closed_on t,Q by SCMPDS_6:def 2;
        WHL is_halting_on t7,Q7 by A6,A32,A50,A45,A46;
        then Q7 halts_on t7 by A42,SCMPDS_6:def 3,B42;
        then Q3 halts_on t7;
        then Q3 halts_on t3 by EXTPRO_1:22;
        hence WHL is_halting_on t,Q by SCMPDS_6:def 3;
      end;
    end;
    hence thesis;
  end;
  set n=F(Dstate s());
A60: Q[0]
  proof
    let t be State of SCMPDS, Q;
    assume that
A61: F(Dstate t) <= 0 & P[Dstate t] and
A62: t.a()=s().a();
    F(Dstate t) >= 0 by NAT_1:2;
    then t.b = 0 by A2,A61,XXREAL_0:1;
    hence thesis by A62,Th16;
  end;
  for k being Element of NAT holds Q[k] from NAT_1:sch 1(A60,A5);
  then Q[n];
  hence thesis by A3;
end;

scheme
  WhileNExec { F(State of SCMPDS)-> Element of NAT, s() -> State of SCMPDS,
  P() -> (the Instructions of SCMPDS)-valued ManySortedSet of NAT,
  I()
-> halt-free shiftable Program of SCMPDS, a() -> Int_position,i() -> Integer,
P[set]}: IExec(while<>0(a(),i(),I()),P(),s())
 = IExec(while<>0(a(),i(),I()),P(),IExec(I
  (),P(),s()))
provided
A1: card I() > 0 and
A2: s().DataLoc(s().a(),i()) <> 0 and
A3: for t be State of SCMPDS st P[Dstate t] & F(Dstate(t))=0 holds t.
DataLoc(s().a(),i()) = 0 and
A4: P[Dstate s()] and
A5: for t be State of SCMPDS,Q
   st P[Dstate t] & t.a()=s().a() & t.DataLoc(
s().a(),i()) <> 0 holds IExec(I(),Q,t).a()=t.a() & I() is_closed_on t,Q & I()
is_halting_on t,Q & F(Dstate IExec(I(),Q,t)) < F(Dstate t)
 & P[Dstate(IExec(I(),Q,t))]
proof
  set WHL=while<>0(a(),i(),I()),
  s1= Initialize s(), P1 = P() +* stop WHL,
  ps= ProgramPart s();
  set sI= Initialize s(), PI = P() +* stop I(),
    m1=LifeSpan(PI,sI)+2,
    s2=Initialize IExec(I(),P(),s()), P2 = P() +* stop WHL,
    m2=LifeSpan(P2,s2);
A9: stop I() c= PI by FUNCT_4:26;
B9: Start-At(0,SCMPDS) c= sI by FUNCT_4:26;
  I() is_closed_on s(),P() by A2,A4,A5;
  then
A10: I() is_closed_on sI,PI by SCMPDS_6:38;
  I() is_halting_on s(),P() by A2,A4,A5;
  then
A11: PI halts_on sI by SCMPDS_6:def 3;
  PI = PI+*stop I() by A9,FUNCT_4:104;
  then PI+*stop I() halts_on Initialize sI by A11;
  then
A13: I() is_halting_on sI,PI by SCMPDS_6:def 3;
  set s4 = Comput(P1,s1,1), P4 = P1;
  set i1=(a(),i())<>0_goto 2, i2=goto (card I()+2), i3=goto -(card I()+2);
  set b=DataLoc(s().a(),i());
A14: IC s1 = 0 by COMPOS_1:223;
  set mI=LifeSpan(PI,sI), s5=Comput(P4,s4,mI), P5 = P4,
  l2= (
card I() + 2);
A15: WHL = i1 ';' (i2 ';' I() ';' i3) by Lm10;
  set m3=mI +1;
  set s6=Comput(P1,s1,m3), P6 = P1;
  card I() + 2 < card I() + 3 by XREAL_1:8;
  then
A16: l2 in dom WHL by Th13;
  set s7=Comput(P1,s1,m3+1), P7 = P1;
A17: IExec(I(),P(),s()) = Result(PI,sI) +* s() | A
 by SCMPDS_4:def 8;
A18: dom ProgramPart s() = A by COMPOS_1:34;
QQ: stop WHL c= P1 by FUNCT_4:26;
  WHL c= stop WHL by AFINSQ_1:78;
  then
A19: WHL c= P1 by XBOOLE_1:1,QQ;
  deffunc F(State of SCMPDS) = F($1);
A20: for t be State of SCMPDS st P[Dstate t] & F(Dstate(t))=0 holds t.DataLoc
  (s().a(),i()) = 0 by A3;
A21: for t be State of SCMPDS,Q
     st P[Dstate t] & t.a()=s().a() & t.DataLoc(s().
  a(),i()) <> 0 holds IExec(I(),Q,t).a()=t.a() & I() is_closed_on t,Q & I()
is_halting_on t,Q & F(Dstate IExec(I(),Q,t)) < F(Dstate t)
 & P[Dstate(IExec(I(),Q,t))] by A5;
A22: Comput(P1,s1,0+1) = Following(P1,
Comput(P1,s1,0)) by EXTPRO_1:4
    .= Following(P1,s1) by EXTPRO_1:3
    .= Exec(i1,s1) by A15,SCMPDS_6:22;
  Shift(I(),2) c= WHL by Lm11;
  then Shift(I(),2) c= P1 by A19,XBOOLE_1:1;
  then
A23: Shift(I(),2) c= P4;
  now
    let a;
    thus sI.a = s1.a
      .= s4.a by A22,SCMPDS_2:67;
  end;
  then
A25: DataPart sI = DataPart s4 by SCMPDS_4:23;
TT:   not b in dom Start-At(0,SCMPDS) by SCMPDS_4:59;
   not a() in dom Start-At(0,SCMPDS) by SCMPDS_4:59;
  then s1.DataLoc(s1.a(),i())=s1.b by FUNCT_4:12
    .= s().b by TT,FUNCT_4:12;
  then
A26: IC s4 = ICplusConst(s1,2) by A2,A22,SCMPDS_2:67
    .= (0+2) by A14,SCMPDS_6:23;
  then
A27: IC s5=l2 by A1,A9,B9,A13,A10,A25,A23,SCMPDS_7:36;
A28: P6/.IC s6 = P6.IC s6 by PBOOLE:158;
A29: s6=s5 by EXTPRO_1:5;
  then
A30: CurInstr(P6,s6)=P5.l2 by A1,A9,B9,A13,A10,A26,A25,A23,A28,
SCMPDS_7:36
    .=P4.l2
    .=P1.l2
    .=WHL.l2 by A16,A19,GRFUNC_1:8
    .=i3 by Th15;
A32: s7 = Following(P1,s6) by EXTPRO_1:4
    .= Exec(i3,s6) by A30;
  then IC s7=ICplusConst(s6,0-(card I()+2)) by SCMPDS_2:66
    .= 0 by A27,A29,SCMPDS_7:1;
  then
A33: IC s2 =IC Comput(P1,s1,m1) by COMPOS_1:223;
A34: DataPart Comput(PI,sI,mI) = DataPart s5 by A1,A9,B9,A13,A10,A26
,A25,A23,SCMPDS_7:36;
  now
    let x be Int_position;
A35: not x in dom Start-At(0,SCMPDS) by SCMPDS_4:59;
A36: not x in dom (s() | A) by A18,SCMPDS_2:53;
    s5.x=Comput(PI,sI,mI).x by A34,SCMPDS_4:23
      .=(Result(PI,sI)).x by A11,EXTPRO_1:23
      .=IExec(I(),P(),s()).x by A17,A36,FUNCT_4:12;
    hence s7.x=IExec(I(),P(),s()).x by A29,A32,SCMPDS_2:66
      .=s2.x by A35,FUNCT_4:12;
  end;
  then
A37: DataPart s7 = DataPart s2 by SCMPDS_4:23;
  set m0=LifeSpan(P1,s1);
A38: dom ps = dom s() /\ A by RELAT_1:90
    .= ({IC SCMPDS} \/ D \/ A) /\ A by SCMPDS_4:19
    .= A by XBOOLE_1:21;
A39: IExec(I(),P(),s()) | A= (Result(PI,sI) +* ps) | A by
SCMPDS_4:def 8
    .= ps by A38,FUNCT_4:24;
A40: P[Dstate s()] by A4;
  WHL is_closed_on s(),P() & WHL is_halting_on s(),P()
   from WhileNHalt(A1,A20, A40,A21);
  then
A41: P1 halts_on s1 by SCMPDS_6:def 3;
  deffunc F(State of SCMPDS) = F($1);
  set Es=IExec(I(),P(),s()), bj=DataLoc(Es.a(),i()), EP = P();
A42: IExec(I(),P(),s()).a()=s().a() by A2,A4,A5;
  then
A43: for t be State of SCMPDS st P[Dstate t] & F(Dstate(t))=0 holds t.bj = 0
  by A3;
A44: for t being State of SCMPDS,Q
 st P[Dstate t] & t.a()=Es.a() & t.bj <> 0
  holds IExec(I(),Q,t).a()=t.a() & I() is_closed_on t,Q
   & I() is_halting_on t,Q & F(
  Dstate IExec(I(),Q,t)) < F(Dstate t) & P[Dstate(IExec(I(),Q,t))] by A5,A42;
A45: P[Dstate Es] by A2,A4,A5;
  WHL is_closed_on Es,EP & WHL is_halting_on Es,EP from WhileNHalt(A1,A43,A45,
  A44);
  then
A46: P2 halts_on s2 by SCMPDS_6:def 3;
  ProgramPart s2 = ProgramPart IExec(I(),P(),s()) by COMPOS_1:206
    .= ProgramPart(Result(PI,sI) +* ps) by SCMPDS_4:def 8
    .= ProgramPart (Result(PI,sI) +* ps)
    .= ps by A38,FUNCT_4:24
    .= ProgramPart s1 by  COMPOS_1:206
    .= ProgramPart Comput(P1,s1,m1) by AMI_1:123;
  then
A48: Comput(P1,s1,m1)=s2 by A37,A33,SCMPDS_7:7;
  then CurInstr(P1,Comput(P1,s1,m1))
  =i1 by A15,SCMPDS_6:22;
  then m0 > m1 by A41,SCMPDS_6:2,29;
  then consider nn be Nat such that
A49: m0=m1+nn by NAT_1:10;
  reconsider nn as Element of NAT by ORDINAL1:def 13;
  Comput(P1,s1,m1+m2) = Comput(P2,s2,m2) by A48,
EXTPRO_1:5;
  then CurInstr(P1,Comput(P1,s1,m1+m2))
   = halt SCMPDS by A46,EXTPRO_1:def 14;
  then m1 + m2 >= m0 by A41,EXTPRO_1:def 14;
  then
A51: m2 >= nn by A49,XREAL_1:8;
A52: Comput(P1,s1,m0) = Comput(P2,s2,nn) by A48,A49
,EXTPRO_1:5;
  then CurInstr(P2,Comput(P2,s2,nn))
   =halt SCMPDS by A41,EXTPRO_1:def 14;
  then nn >= m2 by A46,EXTPRO_1:def 14;
  then nn=m2 by A51,XXREAL_0:1;
  then Result(P1,s1) = Comput(P2,s2,m2) by A41,A52,
EXTPRO_1:23;
  hence IExec(WHL,P(),s()) = Comput(P2,s2,m2) +* ps
   by SCMPDS_4:def 8
    .= Result(P2,s2) +* IExec(I(),P(),s()) | A by A46,A39,EXTPRO_1:23
    .= IExec(WHL,P(),IExec(I(),P(),s())) by SCMPDS_4:def 8;
end;

scheme
  WhileNEnd { F(State of SCMPDS)-> Element of NAT, s() -> State of SCMPDS,
  P() -> (the Instructions of SCMPDS)-valued ManySortedSet of NAT,
  I()
-> halt-free shiftable Program of SCMPDS, a() -> Int_position,i() -> Integer,
P[set]}: F(Dstate IExec(while<>0(a(),i(),I()),P(),s()))=0
 & P[Dstate IExec(while<>0
  (a(),i(),I()),P(),s())]
provided
A1: card I() > 0 and
A2: for t be State of SCMPDS st P[Dstate t] holds F(Dstate(t))=0 iff t.
DataLoc(s().a(),i()) = 0 and
A3: P[Dstate s()] and
A4: for t be State of SCMPDS,Q
  st P[Dstate t] & t.a()=s().a() & t.DataLoc(
s().a(),i()) <> 0 holds IExec(I(),Q,t).a()=t.a() & I() is_closed_on t,Q & I()
is_halting_on t,Q & F(Dstate IExec(I(),Q,t)) < F(Dstate t)
 & P[Dstate(IExec(I(),Q,t))]
proof
  set b=DataLoc(s().a(),i()), WHL=while<>0(a(),i(),I());
  defpred Q[Element of NAT] means
   for t be State of SCMPDS,Q st F(Dstate t) <=
  $1 & t.a()=s().a() & P[Dstate t] holds F(Dstate IExec(WHL,Q,t))=0 & P[Dstate
  IExec(WHL,Q,t)];
A5: Q[0]
  proof
    let t be State of SCMPDS, Q;
    assume that
A6: F(Dstate t) <= 0 and
A7: t.a()=s().a() and
A8: P[Dstate t];
    F(Dstate t) >= 0 by NAT_1:2;
    then
A9: F(Dstate t)=0 by A6,XXREAL_0:1;
    then t.DataLoc(t.a(),i()) = 0 by A2,A7,A8;
    then for b be Int_position holds IExec(WHL,Q,t).b = t.b by Th19;
    hence thesis by A8,A9,SCPISORT:5;
  end;
A10: now
    let k be Element of NAT;
    assume
A11: Q[k];
    now
      let u be State of SCMPDS;
      let U;
      assume that
A12:  F(Dstate u) <= k+1 and
A13:  u.a()=s().a() and
A14:  P[Dstate u];
      per cases;
      suppose
        F(Dstate u)=0;
        hence F(Dstate IExec(WHL,U,u))=0 & P[Dstate IExec(WHL,U,u)]
         by A5,A13,A14;
      end;
      suppose
A15:    F(Dstate u) <> 0;
        set Iu=IExec(I(),U,u);
A16:    u.b <> 0 by A2,A14,A15;
        then
A17:    Iu.a()=s().a() & P[Dstate Iu] by A4,A13,A14;
        deffunc F(State of SCMPDS) = F($1);
A18:    P[Dstate u] by A14;
A19:    for t be State of SCMPDS st P[Dstate t] & F(Dstate t)=0 holds t.
        DataLoc(u.a(),i()) = 0 by A2,A13;
        F(Dstate Iu) < F(Dstate u) by A4,A13,A14,A16;
        then F(Dstate Iu)+1 <= F(Dstate u) by INT_1:20;
        then F(Dstate Iu)+1 <= k+1 by A12,XXREAL_0:2;
        then
A20:    F(Dstate Iu) <= k by XREAL_1:8;
A21:    for t being State of SCMPDS,Q
        st P[Dstate t] & t.a()=u.a() & t.
DataLoc(u.a(),i()) <> 0 holds IExec(I(),Q,t).a()=t.a()
 & I() is_closed_on t,Q & I()
is_halting_on t,Q & F(Dstate IExec(I(),Q,t)) < F(Dstate t)
 & P[Dstate(IExec(I(),Q,t))
        ] by A4,A13;
A22:    u.DataLoc(u.a(),i()) <> 0 by A2,A13,A14,A15;
        IExec(WHL,U,u) = IExec(WHL,U,Iu) from WhileNExec(A1,A22,A19,A18,A21 );
        hence F(Dstate IExec(WHL,U,u))=0 & P[Dstate IExec(WHL,U,u)]
         by A11,A20,A17;
      end;
    end;
    hence Q[k+1];
  end;
  for k being Element of NAT holds Q[k] from NAT_1:sch 1(A5,A10);
  then Q[F(Dstate s())];
  hence thesis by A3;
end;

theorem Th20:
  for s being State of SCMPDS,I being halt-free shiftable
Program of SCMPDS, a,b,c be Int_position,i,d be Integer st card I > 0 & s.a=d &
s.b > 0 & s.c > 0 & s.DataLoc(d,i)=s.b-s.c &
 (for t be State of SCMPDS,Q st t.b >
0 & t.c > 0 & t.a=d & t.DataLoc(d,i)=t.b-t.c & t.b<>t.c
 holds IExec(I,Q,t).a=d &
I is_closed_on t,Q & I is_halting_on t,Q
 & (t.b > t.c implies IExec(I,Q,t).b=t.b-t.c
& IExec(I,Q,t).c = t.c) & (t.b <= t.c
 implies IExec(I,Q,t).c = t.c-t.b & IExec(I,Q,t)
.b=t.b) & IExec(I,Q,t).DataLoc(d,i)=IExec(I,Q,t).b-IExec(I,Q,t).c)
 holds while<>0(a,i
  ,I) is_closed_on s,P & while<>0(a,i,I) is_halting_on s,P
   & (s.DataLoc(s.a,i) <> 0
  implies IExec(while<>0(a,i,I),P,s) =IExec(while<>0(a,i,I),P,IExec(I,P,s)))
proof
  let s be State of SCMPDS,I be halt-free shiftable Program of SCMPDS, a,b,c
  be Int_position, i,d be Integer;
  set ci=DataLoc(s.a,i);
  assume
A1: card I > 0;
  consider f be Function of product the Object-Kind of SCMPDS,NAT such that
A2: for s be State of SCMPDS holds (s.b = s.c implies f.s =0) & (s.b <>
  s.c implies f.s=max(abs(s.b),abs(s.c))) by Th6;
  deffunc F(State of SCMPDS) = f.$1;
  defpred P[set] means ex t be State of SCMPDS st t=$1 & t.b > 0 & t.c > 0 & t
  .DataLoc(d,i)=t.b-t.c;
  assume that
A3: s.a=d and
A4: s.b > 0 and
A5: s.c > 0 and
A6: s.DataLoc(d,i)=s.b-s.c;
  assume
A7: for t be State of SCMPDS,Q
   st t.b > 0 & t.c > 0 & t.a=d & t.DataLoc(d,
i)=t.b-t.c & t.b<>t.c holds IExec(I,Q,t).a=d
 & I is_closed_on t,Q & I is_halting_on
t,Q & (t.b > t.c implies IExec(I,Q,t).b=t.b-t.c
 & IExec(I,Q,t).c = t.c) & (t.b <= t.c
  implies IExec(I,Q,t).c = t.c-t.b
   & IExec(I,Q,t).b=t.b) & IExec(I,Q,t).DataLoc(d,i)=
  IExec(I,Q,t).b-IExec(I,Q,t).c;
A8: now
    let t be State of SCMPDS, Q;
    assume that
A9: P[Dstate t] and
A10: t.a=s.a and
A11: t.ci <> 0;
    set It=IExec(I,Q,t), t2=Dstate It, t1=Dstate t;
    set x=IExec(I,Q,t).b, y=IExec(I,Q,t).c;
    consider v be State of SCMPDS such that
A12: v=Dstate t and
A13: v.b > 0 and
A14: v.c > 0 and
A15: v.DataLoc(d,i)=v.b-v.c by A9;
A16: t.b > 0 by A12,A13,SCMPDS_8:4;
A17: t.c > 0 by A12,A14,SCMPDS_8:4;
A18: t.DataLoc(d,i)=v.b-v.c by A12,A15,SCMPDS_8:4
      .=t.b-v.c by A12,SCMPDS_8:4
      .=t.b-t.c by A12,SCMPDS_8:4;
    then
A19: t.b<>t.c by A3,A11;
    hence IExec(I,Q,t).a=t.a by A3,A7,A10,A16,A17,A18;
    thus I is_closed_on t,Q & I is_halting_on t,Q by A3,A7,A10,A16,A17,A18,A19;
A20: now
      per cases;
      suppose
A21:    t.b > t.c;
        then t.b-t.c > 0 by XREAL_1:52;
        hence x > 0 by A3,A7,A10,A16,A17,A18,A21;
        thus y > 0 by A3,A7,A10,A16,A17,A18,A21;
A22:    x=t.b-t.c by A3,A7,A10,A16,A17,A18,A21;
        hereby
A23:      max(t.b,t.c)=t.b by A21,XXREAL_0:def 10;
          per cases by XXREAL_0:16;
          suppose
            max(x,y) = x;
            hence max(x,y) < max(t.b,t.c) by A17,A22,A23,XREAL_1:46;
          end;
          suppose
            max(x,y) = y;
            hence max(x,y) < max(t.b,t.c) by A3,A7,A10,A16,A17,A18,A21,A23;
          end;
        end;
      end;
      suppose
A24:    t.b <= t.c;
        hence x > 0 by A3,A7,A10,A16,A17,A18,A19;
        t.b < t.c by A19,A24,XXREAL_0:1;
        then t.c-t.b > 0 by XREAL_1:52;
        hence y > 0 by A3,A7,A10,A16,A17,A18,A19,A24;
A25:    y=t.c-t.b by A3,A7,A10,A16,A17,A18,A19,A24;
A26:    x=t.b by A3,A7,A10,A16,A17,A18,A19,A24;
        hereby
A27:      max(t.b,t.c)=t.c by A24,XXREAL_0:def 10;
          per cases by XXREAL_0:16;
          suppose
            max(x,y) = y;
            hence max(x,y) < max(t.b,t.c) by A16,A25,A27,XREAL_1:46;
          end;
          suppose
            max(x,y) = x;
            hence max(x,y) < max(t.b,t.c) by A19,A24,A26,A27,XXREAL_0:1;
          end;
        end;
      end;
    end;
    thus F(t2) < F(t1)
    proof
      t1.b <> t.c by A19,SCMPDS_8:4;
      then t1.b <> t1.c by SCMPDS_8:4;
      then
A28:  F(t1)=max(abs(t1.b),abs(t1.c)) by A2
        .=max(abs(t.b),abs(t1.c)) by SCMPDS_8:4
        .=max(abs(t.b),abs(t.c)) by SCMPDS_8:4
        .=max( t.b,abs(t.c)) by A16,ABSVALUE:def 1
        .=max(t.b,t.c) by A17,ABSVALUE:def 1;
      then F(t1) >= t.b by XXREAL_0:25;
      then
A29:  F(t1) > 0 by A16,XXREAL_0:2;
      per cases;
      suppose
        t2.b=t2.c;
        hence thesis by A2,A29;
      end;
      suppose
        t2.b<>t2.c;
        then F(t2)=max(abs(t2.b),abs(t2.c)) by A2
          .=max(abs(x),abs(t2.c)) by SCMPDS_8:4
          .=max(abs(x),abs(y)) by SCMPDS_8:4
          .=max( x,abs(y)) by A20,ABSVALUE:def 1
          .=max(x,y) by A20,ABSVALUE:def 1;
        hence thesis by A20,A28;
      end;
    end;
A30: IExec(I,Q,t).DataLoc(d,i)=IExec(I,Q,t).b-IExec(I,Q,t).c
 by A3,A7,A10,A16,A17,A18
,A19;
    thus P[Dstate It]
    proof
      take v=Dstate It;
      thus v=Dstate It;
      thus v.b > 0 & v.c > 0 by A20,SCMPDS_8:4;
      thus v.DataLoc(d,i)=x-y by A30,SCMPDS_8:4
        .=v.b-y by SCMPDS_8:4
        .=v.b-v.c by SCMPDS_8:4;
    end;
  end;
A31: for t be State of SCMPDS st P[Dstate t] & F(Dstate t)=0 holds t.ci = 0
  proof
    let t be State of SCMPDS;
    assume that
A32: P[Dstate t] and
A33: F(Dstate t)=0;
    consider v be State of SCMPDS such that
A34: v=Dstate t and
A35: v.b > 0 and
    v.c > 0 and
A36: v.DataLoc(d,i)=v.b-v.c by A32;
A37: now
      assume t.b <> t.c;
      then (Dstate t).b <> t.c by SCMPDS_8:4;
      then (Dstate t).b <> (Dstate t).c by SCMPDS_8:4;
      then
A38:  F(Dstate t)=max(abs((Dstate t).b),abs((Dstate t).c)) by A2
        .=max(abs(t.b),abs((Dstate t).c)) by SCMPDS_8:4
        .=max(abs(t.b),abs(t.c)) by SCMPDS_8:4;
      t.b > 0 by A34,A35,SCMPDS_8:4;
      then abs(t.b) > 0 by COMPLEX1:133;
      hence contradiction by A33,A38,XXREAL_0:25;
    end;
    thus t.ci=v.b-v.c by A3,A34,A36,SCMPDS_8:4
      .=t.b-v.c by A34,SCMPDS_8:4
      .=t.b-t.c by A34,SCMPDS_8:4
      .=0 by A37;
  end;
A39: P[Dstate s]
  proof
    take t=Dstate s;
    thus t=Dstate s;
    thus t.b > 0 by A4,SCMPDS_8:4;
    thus t.c > 0 by A5,SCMPDS_8:4;
    thus t.DataLoc(d,i)=s.b-s.c by A6,SCMPDS_8:4
      .=t.b-s.c by SCMPDS_8:4
      .=t.b-t.c by SCMPDS_8:4;
  end;
  while<>0(a,i,I) is_closed_on s,P & while<>0(a,i,I) is_halting_on s,P from
  WhileNHalt(A1,A31,A39,A8);
  hence while<>0(a,i,I) is_closed_on s,P & while<>0(a,i,I) is_halting_on s,P;
  assume
A40: s.DataLoc(s.a,i) <> 0;
  IExec(while<>0(a,i,I),P,s) =IExec(while<>0(a,i,I),P,IExec(I,P,s)) from
  WhileNExec(A1,A40,A31,A39,A8);
  hence thesis;
end;

begin :: An example: computing Greatest Common Divisor(Euclide algorithm)


::   by loop-invariant
:: gcd(x,y)     < x=(GBP,1) y=(GBP,2),(GBP,3)=x-y >
:: while x<>y do
:: if x>y then x=x-y else y=y-x

definition
  func GCD-Algorithm -> Program of SCMPDS equals
  (GBP:=0) ';' (GBP,3):=(GBP,1)
';' SubFrom(GBP,3,GBP,2) ';' while<>0(GBP,3, if>0(GBP,3,Load SubFrom(GBP,1,GBP,
2), Load SubFrom(GBP,2,GBP,1)) ';' (GBP,3):=(GBP,1) ';' SubFrom(GBP,3,GBP,2) );
  coherence;
end;

theorem Th21:
  for s being State of SCMPDS,I being halt-free shiftable
Program of SCMPDS, a,b,c be Int_position,i,d be Integer st card I > 0 & s.a=d &
s.b > 0 & s.c > 0 & s.DataLoc(d,i)=s.b-s.c &
 (for t be State of SCMPDS,Q st t.b >
0 & t.c > 0 & t.a=d & t.DataLoc(d,i)=t.b-t.c & t.b<>t.c
 holds IExec(I,Q,t).a=d &
I is_closed_on t,Q & I is_halting_on t,Q
 & (t.b > t.c implies IExec(I,Q,t).b=t.b-t.c
& IExec(I,Q,t).c = t.c) & (t.b <= t.c
 implies IExec(I,Q,t).c = t.c-t.b & IExec(I,Q,t)
  .b=t.b) & IExec(I,Q,t).DataLoc(d,i)=IExec(I,Q,t).b-IExec(I,Q,t).c)
   holds IExec(
  while<>0(a,i,I),P,s).b = s.b gcd s.c
   & IExec(while<>0(a,i,I),P,s).c = s.b gcd s.c
proof
  let s be State of SCMPDS,I be halt-free shiftable Program of SCMPDS, a,b,c
  be Int_position, i,d be Integer;
  set ci=DataLoc(s.a,i);
  assume
A1: card I > 0;
  consider f be Function of product the Object-Kind of SCMPDS,NAT such that
A2: for s be State of SCMPDS holds (s.b = s.c implies f.s =0) & (s.b <>
  s.c implies f.s=max(abs(s.b),abs(s.c))) by Th6;
  deffunc F(State of SCMPDS) = f.$1;
  set s1=IExec(while<>0(a,i,I),P,s), ss=Dstate s1;
  defpred P[set] means ex t be State of SCMPDS st t=$1 & t.b > 0 & t.c > 0 & t
  .b gcd t.c =s.b gcd s.c & t.DataLoc(d,i)=t.b-t.c;
  assume that
A3: s.a=d and
A4: s.b > 0 and
A5: s.c > 0 and
A6: s.DataLoc(d,i)=s.b-s.c;
  assume
A7: for t be State of SCMPDS,Q
   st t.b > 0 & t.c > 0 & t.a=d & t.DataLoc(d,
i)=t.b-t.c & t.b<>t.c holds IExec(I,Q,t).a=d
 & I is_closed_on t,Q & I is_halting_on
t,Q & (t.b > t.c implies IExec(I,Q,t).b=t.b-t.c & IExec(I,Q,t).c = t.c)
 & (t.b <= t.c
  implies IExec(I,Q,t).c = t.c-t.b & IExec(I,Q,t).b=t.b)
   & IExec(I,Q,t).DataLoc(d,i)=
  IExec(I,Q,t).b-IExec(I,Q,t).c;
A8: now
    let t be State of SCMPDS, Q;
    assume that
A9: P[Dstate t] and
A10: t.a=s.a and
A11: t.ci <> 0;
    set It=IExec(I,Q,t), t2=Dstate It, t1=Dstate t;
    set x=IExec(I,Q,t).b, y=IExec(I,Q,t).c;
    consider v be State of SCMPDS such that
A12: v=Dstate t and
A13: v.b > 0 and
A14: v.c > 0 and
A15: v.b gcd v.c =s.b gcd s.c and
A16: v.DataLoc(d,i)=v.b-v.c by A9;
A17: t.b > 0 by A12,A13,SCMPDS_8:4;
A18: t.c > 0 by A12,A14,SCMPDS_8:4;
A19: t.DataLoc(d,i)=v.b-v.c by A12,A16,SCMPDS_8:4
      .=t.b-v.c by A12,SCMPDS_8:4
      .=t.b-t.c by A12,SCMPDS_8:4;
    then
A20: t.b > t.c implies IExec(I,Q,t).b=t.b-t.c & IExec(I,Q,t).c = t.c
 by A3,A7,A10
,A17,A18;
A21: t.b<>t.c by A3,A11,A19;
    hence IExec(I,Q,t).a=t.a by A3,A7,A10,A17,A18,A19;
    thus I is_closed_on t,Q & I is_halting_on t,Q by A3,A7,A10,A17,A18,A19,A21;
A22: t.b <= t.c implies IExec(I,Q,t).c =t.c-t.b & IExec(I,Q,t).b=t.b
 by A3,A7,A10
,A17,A18,A19,A21;
A23: now
      per cases;
      suppose
A24:    t.b > t.c;
        then t.b-t.c > 0 by XREAL_1:52;
        hence x > 0 by A3,A7,A10,A17,A18,A19,A24;
        thus y > 0 by A3,A7,A10,A17,A18,A19,A24;
        thus x gcd y = t.b gcd t.c by A17,A18,A20,A22,PREPOWER:111;
A25:    x=t.b-t.c by A3,A7,A10,A17,A18,A19,A24;
        hereby
A26:      max(t.b,t.c)=t.b by A24,XXREAL_0:def 10;
          per cases by XXREAL_0:16;
          suppose
            max(x,y) = x;
            hence max(x,y) < max(t.b,t.c) by A18,A25,A26,XREAL_1:46;
          end;
          suppose
            max(x,y) = y;
            hence max(x,y) < max(t.b,t.c) by A3,A7,A10,A17,A18,A19,A24,A26;
          end;
        end;
      end;
      suppose
A27:    t.b <= t.c;
        hence x > 0 by A3,A7,A10,A17,A18,A19,A21;
        t.b < t.c by A21,A27,XXREAL_0:1;
        then t.c-t.b > 0 by XREAL_1:52;
        hence y > 0 by A3,A7,A10,A17,A18,A19,A21,A27;
        thus x gcd y =t.b gcd t.c by A17,A18,A20,A22,PREPOWER:111;
A28:    y=t.c-t.b by A3,A7,A10,A17,A18,A19,A21,A27;
A29:    x=t.b by A3,A7,A10,A17,A18,A19,A21,A27;
        hereby
A30:      max(t.b,t.c)=t.c by A27,XXREAL_0:def 10;
          per cases by XXREAL_0:16;
          suppose
            max(x,y) = y;
            hence max(x,y) < max(t.b,t.c) by A17,A28,A30,XREAL_1:46;
          end;
          suppose
            max(x,y) = x;
            hence max(x,y) < max(t.b,t.c) by A21,A27,A29,A30,XXREAL_0:1;
          end;
        end;
      end;
    end;
    thus F(t2) < F(t1)
    proof
      t1.b <> t.c by A21,SCMPDS_8:4;
      then t1.b <> t1.c by SCMPDS_8:4;
      then
A31:  F(t1)=max(abs(t1.b),abs(t1.c)) by A2
        .=max(abs(t.b),abs(t1.c)) by SCMPDS_8:4
        .=max(abs(t.b),abs(t.c)) by SCMPDS_8:4
        .=max( t.b,abs(t.c)) by A17,ABSVALUE:def 1
        .=max(t.b,t.c) by A18,ABSVALUE:def 1;
      then F(t1) >= t.b by XXREAL_0:25;
      then
A32:  F(t1) > 0 by A17,XXREAL_0:2;
      per cases;
      suppose
        t2.b=t2.c;
        hence thesis by A2,A32;
      end;
      suppose
        t2.b<>t2.c;
        then F(t2)=max(abs(t2.b),abs(t2.c)) by A2
          .=max(abs(x),abs(t2.c)) by SCMPDS_8:4
          .=max(abs(x),abs(y)) by SCMPDS_8:4
          .=max( x,abs(y)) by A23,ABSVALUE:def 1
          .=max(x,y) by A23,ABSVALUE:def 1;
        hence thesis by A23,A31;
      end;
    end;
A33: IExec(I,Q,t).DataLoc(d,i)=IExec(I,Q,t).b-IExec(I,Q,t).c
 by A3,A7,A10,A17,A18,A19
,A21;
    thus P[Dstate It]
    proof
      take u=Dstate It;
      thus u=Dstate It;
      thus u.b > 0 & u.c > 0 by A23,SCMPDS_8:4;
      thus u.b gcd u.c =It.b gcd u.c by SCMPDS_8:4
        .=t.b gcd t.c by A23,SCMPDS_8:4
        .=v.b gcd t.c by A12,SCMPDS_8:4
        .=s.b gcd s.c by A12,A15,SCMPDS_8:4;
      thus u.DataLoc(d,i)=x-y by A33,SCMPDS_8:4
        .=u.b-y by SCMPDS_8:4
        .=u.b-u.c by SCMPDS_8:4;
    end;
  end;
A34: for t be State of SCMPDS st P[Dstate t] holds F(Dstate t)=0 iff t.ci = 0
  proof
    let t be State of SCMPDS;
    assume P[Dstate t];
    then consider v be State of SCMPDS such that
A35: v=Dstate t and
A36: v.b > 0 and
    v.c > 0 and
    v.b gcd v.c =s.b gcd s.c and
A37: v.DataLoc(d,i)=v.b-v.c;
A38: t.ci=v.b-v.c by A3,A35,A37,SCMPDS_8:4
      .=t.b-v.c by A35,SCMPDS_8:4
      .=t.b-t.c by A35,SCMPDS_8:4;
    hereby
      assume
A39:  F(Dstate t)=0;
      now
        assume t.b <> t.c;
        then (Dstate t).b <> t.c by SCMPDS_8:4;
        then (Dstate t).b <> (Dstate t).c by SCMPDS_8:4;
        then
A40:    F(Dstate t)=max(abs((Dstate t).b),abs((Dstate t).c)) by A2
          .=max(abs(t.b),abs((Dstate t).c)) by SCMPDS_8:4
          .=max(abs(t.b),abs(t.c)) by SCMPDS_8:4;
        t.b > 0 by A35,A36,SCMPDS_8:4;
        then abs(t.b) > 0 by COMPLEX1:133;
        hence contradiction by A39,A40,XXREAL_0:25;
      end;
      hence t.ci=0 by A38;
    end;
    hereby
      assume t.ci=0;
      then (Dstate t).b = t.c by A38,SCMPDS_8:4;
      then (Dstate t).b = (Dstate t).c by SCMPDS_8:4;
      hence F(Dstate t)=0 by A2;
    end;
  end;
A41: P[Dstate s]
  proof
    take t=Dstate s;
    thus t=Dstate s;
    thus t.b > 0 by A4,SCMPDS_8:4;
    thus t.c > 0 by A5,SCMPDS_8:4;
    thus t.b gcd t.c = s.b gcd t.c by SCMPDS_8:4
      .=s.b gcd s.c by SCMPDS_8:4;
    thus t.DataLoc(d,i)=s.b-s.c by A6,SCMPDS_8:4
      .=t.b-s.c by SCMPDS_8:4
      .=t.b-t.c by SCMPDS_8:4;
  end;
A42: F(ss)=0 & P[ss] from WhileNEnd(A1,A34,A41,A8);
  then consider w be State of SCMPDS such that
A43: w=ss and
A44: w.b > 0 and
  w.c > 0 and
A45: w.b gcd w.c =s.b gcd s.c and
A46: w.DataLoc(d,i)=w.b-w.c;
A47: w.b-w.c =s1.ci by A3,A43,A46,SCMPDS_8:4
    .=0 by A34,A42;
  then
A48: abs(w.b)=abs(w.b) gcd abs(w.c) by NAT_D:32
    .=s.b gcd s.c by A45,INT_2:51;
  thus IExec(while<>0(a,i,I),P,s).b=ss.b by SCMPDS_8:4
    .=s.b gcd s.c by A43,A44,A48,ABSVALUE:def 1;
  thus IExec(while<>0(a,i,I),P,s).c =ss.c by SCMPDS_8:4
    .=s.b gcd s.c by A43,A44,A47,A48,ABSVALUE:def 1;
end;

set i1= GBP:=0, i2= (GBP,3):=(GBP,1), i3= SubFrom(GBP,3,GBP,2), j1= Load
SubFrom(GBP,1,GBP,2), j2= Load SubFrom(GBP,2,GBP,1), IF= if>0(GBP,3,j1,j2), k1=
(GBP,3):=(GBP,1), k2= SubFrom(GBP,3,GBP,2), WB= IF ';' k1 ';' k2, WH= while<>0(
GBP,3,WB);

Lm12: card WB=6
proof
  thus card WB=card (IF ';' k1)+1 by SCMP_GCD:8
    .=card IF +1+1 by SCMP_GCD:8
    .=card j1+card j2 +2+1+1 by SCMPDS_6:79
    .= 1+card j2 +2+1+1 by SCMPDS_5:6
    .= 1+1+2+1+1 by SCMPDS_5:6
    .=6;
end;

Lm13: card WH=9
proof
  thus card WH=6+3 by Lm12,Th12
    .=9;
end;

theorem
  card GCD-Algorithm=12
proof
  thus card GCD-Algorithm=card (i1 ';' i2 ';' i3) + card WH by AFINSQ_1:20
    .=card (i1 ';' i2) +1+ card WH by SCMP_GCD:8
    .=2+1+ 9 by Lm13,SCMP_GCD:9
    .=12;
end;

Lm14: for s being State of SCMPDS st s.GBP=0 holds
 (s.a3 > 0 implies IExec(WB,P,
s).a1=s.a1-s.a2 & IExec(WB,P,s).a2 = s.a2)
 & (s.a3 <= 0 implies IExec(WB,P,s).a2=s.
a2-s.a1 & IExec(WB,P,s).a1=s.a1) & IExec(WB,P,s).GBP=0
 & IExec(WB,P,s).a3=IExec(WB,P,s)
.a1-IExec(WB,P,s).a2

proof
  let s be State of SCMPDS;
  set s1=IExec(IF,P,s), s2=IExec(IF ';' k1,P,s), a=GBP, t0 = Initialize s,
  Q0 = P;
A1: s1=IExec(IF,Q0,t0) by SCMPDS_5:48;
A2: IExec(WB,P,s)=IExec(WB,Q0,t0) by SCMPDS_5:48;
A3: s2=IExec(IF ';' k1,Q0,t0) by SCMPDS_5:48;
A4: now
    assume
A5: s1.GBP=0;
    then
A6: DataLoc(s1.a,3)=intpos (0+3) by SCMP_GCD:5;
A7: s2.a3 =Exec(k1, s1).a3 by A1,A3,SCMPDS_5:46
      .=s1.DataLoc(s1.a,1) by A6,SCMPDS_2:59
      .=s1.intpos (0+1) by A5,SCMP_GCD:5;
    1 <> abs(s1.GBP+3) by A5,ABSVALUE:def 1;
    then
A8: a1 <> DataLoc(s1.GBP,3) by ZFMISC_1:33;
A9: s2.a1 =Exec(k1, s1).a1 by A1,A3,SCMPDS_5:46
      .=s1.a1 by A8,SCMPDS_2:59;
    2 <> abs(s1.GBP+3) by A5,ABSVALUE:def 1;
    then
A10: a2 <> DataLoc(s1.GBP,3) by ZFMISC_1:33;
A11: s2.a2 =Exec(k1, s1).a2 by A1,A3,SCMPDS_5:46
      .=s1.a2 by A10,SCMPDS_2:59;
    0 <> abs(s1.GBP+3) by A5,ABSVALUE:def 1;
    then
A12: a <> DataLoc(s1.GBP,3) by ZFMISC_1:33;
A13: s2.a =Exec(k1, s1).a by A1,A3,SCMPDS_5:46
      .=0 by A5,A12,SCMPDS_2:59;
    then
A14: DataLoc(s2.a,3)=intpos (0+3) by SCMP_GCD:5;
    0 <> abs(s2.GBP+3) by A13,ABSVALUE:def 1;
    then
A15: a <> DataLoc(s2.GBP,3) by ZFMISC_1:33;
    thus IExec(WB,P,s).a =Exec(k2, s2).a by A3,A2,SCMPDS_5:46
      .=0 by A13,A15,SCMPDS_2:62;
    1 <> abs(s2.GBP+3) by A13,ABSVALUE:def 1;
    then
A16: a1 <> DataLoc(s2.GBP,3) by ZFMISC_1:33;
    thus
A17: IExec(WB,P,s).a1 =Exec(k2, s2).a1 by A3,A2,SCMPDS_5:46
      .=s1.a1 by A9,A16,SCMPDS_2:62;
    2 <> abs(s2.GBP+3) by A13,ABSVALUE:def 1;
    then
A18: a2 <> DataLoc(s2.GBP,3) by ZFMISC_1:33;
    thus
A19: IExec(WB,P,s).a2 =Exec(k2, s2).a2 by A3,A2,SCMPDS_5:46
      .=s1.a2 by A11,A18,SCMPDS_2:62;
    thus IExec(WB,P,s).a3 =Exec(k2, s2).a3 by A3,A2,SCMPDS_5:46
      .=s2.a3-s2.DataLoc(s2.a,2) by A14,SCMPDS_2:62
      .=IExec(WB,P,s).a1-IExec(WB,P,s).a2 by A13,A11,A7,A17,A19,SCMP_GCD:5;
  end;
  set s0=Initialize s, m1=SubFrom(GBP,1,GBP,2), m2=SubFrom(GBP,2,GBP,1);
  assume
A20: s.GBP=0;
  then
A21: s0.a=0 by SCMPDS_5:40;
A22: DataLoc(s.a,3)=intpos(0+3) by A20,SCMP_GCD:5;
A23: s0.a2=s.a2 by SCMPDS_5:40;
A24: now
    2 <> abs(s0.GBP+1) by A21,ABSVALUE:def 1;
    then
A25: a2 <> DataLoc(s0.GBP,1) by ZFMISC_1:33;
    0 <> abs(s0.GBP+1) by A21,ABSVALUE:def 1;
    then
A26: a <> DataLoc(s0.GBP,1) by ZFMISC_1:33;
    assume
A27: s.a3 > 0;
    hence s1.a=IExec(j1,P,s).a by A22,SCMPDS_6:87
      .=Exec(m1, s0).a by SCMPDS_5:45
      .=0 by A21,A26,SCMPDS_2:62;
A28: DataLoc(s0.a,1)=intpos (0+1) by A21,SCMP_GCD:5;
    thus s1.a1=IExec(j1,P,s).a1 by A22,A27,SCMPDS_6:87
      .=Exec(m1, s0).a1 by SCMPDS_5:45
      .=s0.a1-s0.DataLoc(s0.a,2) by A28,SCMPDS_2:62
      .=s0.a1-s0.intpos(0+2) by A21,SCMP_GCD:5
      .=s.a1-s.a2 by A23,SCMPDS_5:40;
    thus s1.a2=IExec(j1,P,s).a2 by A22,A27,SCMPDS_6:87
      .=Exec(m1, s0).a2 by SCMPDS_5:45
      .=s.a2 by A23,A25,SCMPDS_2:62;
  end;

  hence
  s.a3 > 0 implies IExec(WB,P,s).a1=s.a1-s.a2 & IExec(WB,P,s).a2 = s.a2 by A4;

A29: s0.a1=s.a1 by SCMPDS_5:40;
A30: now
    1 <> abs(s0.GBP+2) by A21,ABSVALUE:def 1;
    then
A31: a1 <> DataLoc(s0.GBP,2) by ZFMISC_1:33;
    0 <> abs(s0.GBP+2) by A21,ABSVALUE:def 1;
    then
A32: a <> DataLoc(s0.GBP,2) by ZFMISC_1:33;
    assume
A33: s.a3 <= 0;
    hence s1.a=IExec(j2,P,s).a by A22,SCMPDS_6:88
      .=Exec(m2, s0).a by SCMPDS_5:45
      .=0 by A21,A32,SCMPDS_2:62;
A34: DataLoc(s0.a,2)=intpos (0+2) by A21,SCMP_GCD:5;
    thus s1.a2=IExec(j2,P,s).a2 by A22,A33,SCMPDS_6:88
      .=Exec(m2, s0).a2 by SCMPDS_5:45
      .=s0.a2-s0.DataLoc(s0.a,1) by A34,SCMPDS_2:62
      .=s0.a2-s0.intpos(0+1) by A21,SCMP_GCD:5
      .=s.a2-s.a1 by A23,SCMPDS_5:40;
    thus s1.a1=IExec(j2,P,s).a1 by A22,A33,SCMPDS_6:88
      .=Exec(m2, s0).a1 by SCMPDS_5:45
      .=s.a1 by A29,A31,SCMPDS_2:62;
  end;

  hence s.a3 <= 0 implies IExec(WB,P,s).a2=s.a2-s.a1
   & IExec(WB,P,s).a1 = s.a1 by
A4;

  now
    per cases;
    suppose
      s.a3 > 0;
      hence s1.a=0 by A24;
    end;
    suppose
      s.a3 <= 0;
      hence s1.a=0 by A30;
    end;
  end;
  hence thesis by A4;
end;

Lm15: for s being State of SCMPDS st s.GBP=0 & s.a1 > 0 & s.a2 > 0 & s.a3=s.a1
-s.a2 holds IExec(WH,P,s).a1 = s.a1 gcd s.a2
 & IExec(WH,P,s).a2 = s.a1 gcd s.a2 &
WH is_closed_on s,P & WH is_halting_on s,P

proof
  set a=GBP;
  let s be State of SCMPDS;
A1: DataLoc(0,3)=intpos(0+3) by SCMP_GCD:5;
A2: now
    let t be State of SCMPDS, Q;
    assume that
    t.a1 > 0 and
    t.a2 > 0 and
A3: t.a=0 and
A4: t.DataLoc(0,3)=t.a1-t.a2 and
    t.a1<>t.a2;
    thus IExec(WB,Q,t).a=0 by A3,Lm14;
    thus WB is_closed_on t,Q by SCMPDS_6:34;
    thus WB is_halting_on t,Q by SCMPDS_6:35;
    hereby
      assume t.a1 > t.a2;
      then t.a3 > 0 by A1,A4,XREAL_1:52;
      hence IExec(WB,Q,t).a1=t.a1-t.a2 & IExec(WB,Q,t).a2 = t.a2 by A3,Lm14;
    end;
    hereby
      assume t.a1 <= t.a2;
      then t.a3 <= 0 by A1,A4,XREAL_1:49;
      hence IExec(WB,Q,t).a2=t.a2-t.a1 & IExec(WB,Q,t).a1 = t.a1 by A3,Lm14;
    end;
    thus IExec(WB,Q,t).DataLoc(0,3)=IExec(WB,Q,t).a1-IExec(WB,Q,t).a2
     by A1,A3,Lm14;
  end;
  assume
A5: s.a=0 & s.a1 > 0 & s.a2 > 0 & s.a3=s.a1-s.a2;

  hence IExec(WH,P,s).a1 = s.a1 gcd s.a2
   & IExec(WH,P,s).a2 = s.a1 gcd s.a2 by A1
,A2,Lm12,Th21;

  thus thesis by A5,A1,A2,Lm12,Th20;
end;
set GA=i1 ';' i2 ';' i3 ';' WH;

Lm16: for s being State of SCMPDS st s.a1 > 0 & s.a2 > 0
 holds IExec(GA,P,s).a1
= s.a1 gcd s.a2 & IExec(GA,P,s).a2 = s.a1 gcd s.a2 & GA is_closed_on s,P & GA
is_halting_on s,P

proof
  let s be State of SCMPDS;
  assume
A1: s.a1 > 0 & s.a2 > 0;

  set t0=Initialize s, Q0 = P,
  t1=IExec(i1 ';' i2 ';' i3,P,s), t2=IExec(i1 ';' i2,P,s),
  Q1 = P,
  t3=Exec(i1, t0), a=GBP;

A2: t0=Initialize t0;
A3: t1=IExec(i1 ';' i2 ';' i3,Q0,t0) by SCMPDS_5:48;
A4: t2=IExec(i1 ';' i2,Q0,t0) by SCMPDS_5:48;

A5: t3.a1=t0.a1 by AMI_3:52,SCMPDS_2:57
    .=s.a1 by SCMPDS_5:40;
A6: t3.a=0 by SCMPDS_2:57;
  then
A7: DataLoc(t3.a,3)=intpos (0+3) by SCMP_GCD:5;
  1 <> abs(t3.GBP+3) by A6,ABSVALUE:def 1;
  then
A8: a1 <> DataLoc(t3.GBP,3) by ZFMISC_1:33;
A9: t2.a1=Exec(i2,t3).a1 by A2,A4,SCMPDS_5:47
    .=s.a1 by A5,A8,SCMPDS_2:59;
A10: t3.a2=t0.a2 by AMI_3:52,SCMPDS_2:57
    .=s.a2 by SCMPDS_5:40;
A11: t2.a3=Exec(i2,t3).a3 by A2,A4,SCMPDS_5:47
    .=t3.DataLoc(t3.a,1) by A7,SCMPDS_2:59
    .=s.a1 by A6,A5,SCMP_GCD:5;
  2 <> abs(t3.GBP+3) by A6,ABSVALUE:def 1;
  then
A12: a2 <> DataLoc(t3.GBP,3) by ZFMISC_1:33;
A13: t2.a2=Exec(i2,t3).a2 by A2,A4,SCMPDS_5:47
    .=s.a2 by A10,A12,SCMPDS_2:59;
  0 <> abs(t3.GBP+3) by A6,ABSVALUE:def 1;
  then
A14: a <> DataLoc(t3.GBP,3) by ZFMISC_1:33;
A15: t2.a=Exec(i2,t3).a by A2,A4,SCMPDS_5:47
    .=0 by A6,A14,SCMPDS_2:59;
  then
A16: DataLoc(t2.a,3)=intpos (0+3) by SCMP_GCD:5;
  0 <> abs(t2.GBP+3) by A15,ABSVALUE:def 1;
  then
A17: a <> DataLoc(t2.GBP,3) by ZFMISC_1:33;
A18: t1.a=Exec(i3,t2).a by A3,A4,SCMPDS_5:46
    .=0 by A15,A17,SCMPDS_2:62;
  1 <> abs(t2.GBP+3) by A15,ABSVALUE:def 1;
  then
A19: a1 <> DataLoc(t2.GBP,3) by ZFMISC_1:33;
A20: t1.a1=Exec(i3,t2).a1 by A3,A4,SCMPDS_5:46
    .=s.a1 by A9,A19,SCMPDS_2:62;
  2 <> abs(t2.GBP+3) by A15,ABSVALUE:def 1;
  then
A21: a2 <> DataLoc(t2.GBP,3) by ZFMISC_1:33;
A22: t1.a2=Exec(i3,t2).a2 by A3,A4,SCMPDS_5:46
    .=s.a2 by A13,A21,SCMPDS_2:62;
A23: t1.a3=Exec(i3,t2).a3 by A3,A4,SCMPDS_5:46
    .=t2.a3-t2.DataLoc(t2.a,2) by A16,SCMPDS_2:62
    .=t1.a1-t1.a2 by A15,A13,A11,A20,A22,SCMP_GCD:5;
  then
A24: WH is_closed_on t1,Q1 & WH is_halting_on t1,Q1 by A1,A18,A20,A22,Lm15;
  IExec(WH,Q1,t1).a1 = t1.a1 gcd t1.a2 by A1,A18,A20,A22,A23,Lm15;
  hence IExec(GA,P,s).a1=s.a1 gcd s.a2 by A20,A22,A24,SCPISORT:8;
  IExec(WH,Q1,t1).a2 = t1.a1 gcd t1. a2 by A1,A18,A20,A22,A23,Lm15;
  hence IExec(GA,P,s).a2=s.a1 gcd s.a2 by A20,A22,A24,SCPISORT:8;
  thus thesis by A24,SCPISORT:10;
end;

theorem :: SCMP_GCD:18
  for s being State of SCMPDS,x, y being Integer st s.intpos 1 = x & s.
intpos 2 = y & x > 0 & y > 0
 holds IExec(GCD-Algorithm,P,s).intpos 1 = x gcd y &
  IExec(GCD-Algorithm,P,s).intpos 2 = x gcd y
   & GCD-Algorithm is_closed_on s,P &
  GCD-Algorithm is_halting_on s,P by Lm16;

