:: Input and Output of Instructions
::  by Artur Korni{\l}owicz
::
:: Received May 8, 2001
:: Copyright (c) 2001-2011 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies SETFAM_1, XBOOLE_0, AMI_1, FSM_1, CAT_1, FUNCT_1, RELAT_1,
      STRUCT_0, SUBSET_1, FUNCT_4, FUNCOP_1, GOBOARD5, FRECHET, AMISTD_1,
      ZFMISC_1, NUMBERS, CARD_1, GLIB_000, AMISTD_2, CARD_5, NET_1, TARSKI,
      AMI_7, ORDINAL1, UNIALG_1;
 notations TARSKI, XBOOLE_0, SUBSET_1, SETFAM_1, RELAT_1, FUNCT_1, ZFMISC_1,
      MCART_1, NUMBERS, FUNCOP_1, FUNCT_4, NAT_1, STRUCT_0, MEMSTR_0, COMPOS_1,
      EXTPRO_1, FUNCT_7, AMISTD_1, AMISTD_2;
 constructors ZFMISC_1, AMISTD_2, NAT_1, PRE_POLY, EXTPRO_1, AMISTD_1,
      DOMAIN_1, FUNCT_7, FUNCT_4, MEMSTR_0, RELSET_1;
 registrations SETFAM_1, FUNCOP_1, STRUCT_0, AMISTD_1, AMISTD_2, ZFMISC_1,
      CARD_1, RELSET_1, ORDINAL1, COMPOS_1, EXTPRO_1, ORDINAL6, FUNCT_7,
      FUNCT_4, MEMSTR_0;
 requirements SUBSET, BOOLE;
 definitions EXTPRO_1, COMPOS_1, AMISTD_1, XBOOLE_0, FUNCOP_1, MEMSTR_0;
 theorems FUNCT_7, TARSKI, AMISTD_1, SUBSET_1, FUNCOP_1, FUNCT_4, ZFMISC_1,
      YELLOW_8, FUNCT_1, YELLOW15, XBOOLE_0, XBOOLE_1, RELAT_1, PARTFUN1,
      MCART_1, ORDINAL1, COMPOS_1, STRUCT_0, MEMSTR_0;
 schemes SUBSET_1;

begin :: Preliminaries

reserve N for with_non-empty_elements non empty set;

definition
  let N be with_non-empty_elements non empty set,
  A be IC-Ins-separated non
empty AMI-Struct over N, s be State of A, o be Object of A,
  a be Element of ObjectKind o;
  redefine func s+*(o,a) -> State of A;
  coherence
  proof
    dom s = the carrier of A by PARTFUN1:def 2;
    then s+*(o,a) = s+*(o .--> a) by FUNCT_7:def 3;
    hence thesis;
  end;
end;

theorem Th6:
  for A being standard IC-Ins-separated non empty
AMI-Struct over N, I being Instruction of A, s being State
of A, o being Object of A, w being Element of ObjectKind o st I is sequential &
  o <> IC A holds IC Exec(I,s) = IC Exec(I,s+*(o,w))
proof
  let A be standard IC-Ins-separated non empty
AMI-Struct over N, I be Instruction of A, s be State of A, o be Object of
  A, w be Element of ObjectKind o such that
A1: for s being State of A holds Exec(I,s).IC A = succ IC s and
A2: o <> IC A;
  thus IC Exec(I,s) = succ IC s by A1
    .= succ IC (s+*(o,w)) by A2,FUNCT_7:32
    .= IC Exec(I,s+*(o,w)) by A1;
end;

theorem
  for A being standard IC-Ins-separated non empty
AMI-Struct over N, I being Instruction of A, s being State
of A, o being Object of A, w being Element of ObjectKind o st I is sequential &
  o <> IC A holds IC Exec(I,s+*(o,w)) = IC (Exec(I,s) +* (o,w))
proof
  let A be standard IC-Ins-separated non empty
AMI-Struct over N, I be Instruction of A, s be State of A, o be Object of
  A, w be Element of ObjectKind o such that
A1: I is sequential and
A2: o <> IC A;
  thus IC Exec(I,s+*(o,w)) = IC Exec(I,s) by A1,A2,Th6
    .= IC (Exec(I,s) +* (o,w)) by A2,FUNCT_7:32;
end;

begin :: Input and Output of Instructions

definition
  let N be set, A be AMI-Struct over N;
  attr A is with_non_trivial_Instructions means
  :Def1:
  the Instructions of A
  is non trivial;
end;

definition
  let N be set, A be non empty AMI-Struct over N;
  attr A is with_non_trivial_ObjectKinds means
  :Def2:
  for o being Object of A
  holds ObjectKind o is non trivial;
end;

registration
  let N be with_non-empty_elements set;
  cluster STC N -> with_non_trivial_ObjectKinds;
  coherence
  proof
    let o be Object of STC N;
A1: the carrier of STC N = {0} by AMISTD_1:def 7;
A2: the Object-Kind of STC N = 0 .--> NAT
    by AMISTD_1:def 7;
    per cases by A1;
    suppose
A7:   o in {0};
      ObjectKind o = (0 .--> NAT).o by A2
        .= NAT by A7,FUNCOP_1:7;
      hence thesis;
    end;
  end;
end;

registration
  let N be with_non-empty_elements non empty set;
  cluster with_explicit_jumps
    IC-relocable with_non_trivial_ObjectKinds
with_non_trivial_Instructions
 for regular J/A-independent homogeneous standard halting
  standard-ins IC-Ins-separated
    non empty AMI-Struct over N;
  existence
  proof
    take STC N;
A1: [1,0,0] in {[1,0,0],[0,0,0]} & [0,0,0] in {[1,0,0],[0,0,0]}
       by TARSKI:def 2;
    the Instructions of STC N = {[0,0,0],[1,0,0]} & [1,0,0] <> [0,0,0] by
AMISTD_1:def 7,MCART_1:25;
    then the Instructions of STC N is non trivial by A1,ZFMISC_1:def 10;
    hence thesis by Def1;
  end;
end;

registration
  let N be with_non-empty_elements set;
  cluster STC N -> with_non_trivial_Instructions;
  coherence
  proof
A:  [0,0,0] <> [1,0,0] by MCART_1:25;
     the Instructions of STC N = {[0,0,0],[1,0,0]} by AMISTD_1:def 7;
     then [0,0,0] in the Instructions of STC N
        & [1,0,0] in the Instructions of STC N by TARSKI:def 2;
    hence the Instructions of STC N is non trivial by A,ZFMISC_1:def 10;
  end;
end;

registration
  let N be with_non-empty_elements set;
  cluster with_non_trivial_ObjectKinds with_non_trivial_Instructions
    IC-Ins-separated for non empty AMI-Struct over N;
  existence
  proof
    take STC N;
    thus thesis;
  end;
end;

registration
  let N be with_non-empty_elements set, A be with_non_trivial_ObjectKinds non
  empty AMI-Struct over N, o be Object of A;
  cluster ObjectKind o -> non trivial;
  coherence by Def2;
end;

registration
  let N be with_non-empty_elements set, A be with_non_trivial_Instructions
  AMI-Struct over N;
  cluster the Instructions of A -> non trivial;
  coherence by Def1;
end;

registration
  let N be with_non-empty_elements set, A be IC-Ins-separated non empty
  AMI-Struct over N;
  cluster ObjectKind IC A -> non trivial;
  coherence by MEMSTR_0:def 3;
end;

definition

  let N be with_non-empty_elements set, A be non empty
  AMI-Struct over N, I be Instruction of A;
  func Output I -> Subset of A means
  :Def3:
  for o being Object of A holds o in
  it iff ex s being State of A st s.o <> Exec(I,s).o;
  existence
  proof
    defpred P[set] means ex s being State of A st s.$1 <> Exec(I,s).$1;
    consider X being Subset of A such that
A1: for x being set holds x in X iff x in the carrier of A & P[x] from
    SUBSET_1:sch 1;
    take X;
    thus thesis by A1;
  end;
  uniqueness
  proof
    defpred P[set] means ex s being State of A st s.$1 <> Exec(I,s).$1;
    let a, b be Subset of A such that
A2: for o being Object of A holds o in a iff P[o] and
A3: for o being Object of A holds o in b iff P[o];
    thus a = b from SUBSET_1:sch 2(A2,A3);
  end;
end;

definition

  let N be with_non-empty_elements non empty set,
  A be IC-Ins-separated non
  empty AMI-Struct over N, I be Instruction of A;
  func Out_\_Inp I -> Subset of A means
  :Def4:
  for o being Object of A holds o
in it iff for s being State of A, a being Element of ObjectKind o holds Exec(I,
  s) = Exec(I,s+*(o,a));
  existence
  proof
    defpred P[set] means ex l being Object of A st l = $1 & for s being State
    of A, a being Element of ObjectKind l holds Exec(I,s) = Exec(I,s+*(l,a));
    consider X being Subset of A such that
A1: for x being set holds x in X iff x in the carrier of A & P[x] from
    SUBSET_1:sch 1;
    take X;
    let l be Object of A;
    hereby
      assume l in X;
      then P[l] by A1;
      hence
      for s being State of A, a being Element of ObjectKind l holds Exec(
      I,s) = Exec(I,s+*(l,a));
    end;
    thus thesis by A1;
  end;
  uniqueness
  proof
    defpred P[Object of A] means for s being State of A, a being Element of
    ObjectKind $1 holds Exec(I,s) = Exec(I,s+*($1,a));
    let a, b be Subset of A such that
A2: for o being Object of A holds o in a iff P[o] and
A3: for o being Object of A holds o in b iff P[o];
    thus a = b from SUBSET_1:sch 2(A2,A3);
  end;
  func Out_U_Inp I -> Subset of A means
  :Def5:
  for o being Object of A holds o
in it iff ex s being State of A, a being Element of ObjectKind o st Exec(I,s+*(
  o,a)) <> Exec(I,s) +* (o,a);
  existence
  proof
    defpred P[set] means ex l being Object of A st l = $1 & ex s being State
of A, a being Element of ObjectKind l st Exec(I,s+*(l,a)) <> Exec(I,s) +* (l,a)
    ;
    consider X being Subset of A such that
A4: for x being set holds x in X iff x in the carrier of A & P[x] from
    SUBSET_1:sch 1;
    take X;
    let l be Object of A;
    hereby
      assume l in X;
      then P[l] by A4;
      hence ex s being State of A, a being Element of ObjectKind l st Exec(I,s
      +*(l,a)) <> Exec(I,s) +* (l,a);
    end;
    thus thesis by A4;
  end;
  uniqueness
  proof
    defpred P[Object of A] means ex s being State of A, a being Element of
    ObjectKind $1 st Exec(I,s+*($1,a)) <> Exec(I,s) +* ($1,a);
    let a, b be Subset of A such that
A5: for o being Object of A holds o in a iff P[o] and
A6: for o being Object of A holds o in b iff P[o];
    thus a = b from SUBSET_1:sch 2(A5,A6);
  end;
end;

definition

  let N be with_non-empty_elements non empty set,
  A be IC-Ins-separated non
  empty AMI-Struct over N, I be Instruction of A;
  func Input I -> Subset of A equals
  Out_U_Inp I \ Out_\_Inp I;
  coherence;
end;

theorem Th10:
  for A being with_non_trivial_ObjectKinds IC-Ins-separated
non empty AMI-Struct over N, I being Instruction
  of A holds Out_\_Inp I c= Output I
proof
  let A be with_non_trivial_ObjectKinds IC-Ins-separated non empty
  AMI-Struct over N, I be Instruction of A;
  for o being Object of A holds o in Out_\_Inp I implies o in Output I
  proof
    let o be Object of A;
    set s = the State of A,a = the Element of ObjectKind o;
    consider w being set such that
A1: w in ObjectKind o and
A2: w <> a by YELLOW15:3;
    reconsider w as Element of ObjectKind o by A1;
    set t = s +* (o,w);
A3: dom t = the carrier of A by PARTFUN1:def 2;
A4: dom s = the carrier of A by PARTFUN1:def 2;
    assume
A5: not thesis;
    then
A6: Exec(I,t+*(o,a)).o = (t+*(o,a)).o by Def3
      .= a by A3,FUNCT_7:31;
    Exec(I,t).o = t.o by A5,Def3
      .= w by A4,FUNCT_7:31;
    hence contradiction by A5,A2,A6,Def4;
  end;
  hence thesis by SUBSET_1:2;
end;

theorem Th11:
  for A being IC-Ins-separated non empty
  AMI-Struct over N, I being Instruction of A holds Output I c= Out_U_Inp I
proof
  let A be IC-Ins-separated non empty AMI-Struct over
  N, I be Instruction of A;
  for o being Object of A holds o in Output I implies o in Out_U_Inp I
  proof
    let o be Object of A;
    assume
A1: not thesis;
    for s being State of A holds s.o = Exec(I,s).o
    proof
      let s be State of A;
      reconsider so = s.o as Element of ObjectKind o by MEMSTR_0:77;
A2:   Exec(I,s+*(o,so)) = Exec(I,s) +* (o,so) by A1,Def5;
      dom Exec(I,s) = the carrier of A by PARTFUN1:def 2;
      hence s.o = (Exec(I,s) +* (o,so)).o by FUNCT_7:31
        .= Exec(I,s).o by A2,FUNCT_7:35;
    end;
    hence contradiction by A1,Def3;
  end;
  hence thesis by SUBSET_1:2;
end;

theorem
  for A being with_non_trivial_ObjectKinds IC-Ins-separated
non empty AMI-Struct over N, I being Instruction of A holds
  Out_\_Inp I = Output I \ Input I
proof
  let A be with_non_trivial_ObjectKinds IC-Ins-separated non empty
  AMI-Struct over N, I be Instruction of A;
  for o being Object of A holds o in Out_\_Inp I iff o in Output I \ Input
  I
  proof
    let o be Object of A;
    hereby
A1:   Out_\_Inp I c= Output I by Th10;
      assume
A2:   o in Out_\_Inp I;
      Out_\_Inp I misses Input I by XBOOLE_1:85;
      then not o in Input I by A2,XBOOLE_0:3;
      hence o in Output I \ Input I by A2,A1,XBOOLE_0:def 5;
    end;
    assume
A3: o in Output I \ Input I;
    then
A4: not o in Input I by XBOOLE_0:def 5;
    per cases by A4,XBOOLE_0:def 5;
    suppose
A5:   not o in Out_U_Inp I;
      Output I c= Out_U_Inp I by Th11;
      then not o in Output I by A5;
      hence thesis by A3,XBOOLE_0:def 5;
    end;
    suppose
      o in Out_\_Inp I;
      hence thesis;
    end;
  end;
  hence thesis by SUBSET_1:3;
end;

theorem
  for A being with_non_trivial_ObjectKinds IC-Ins-separated
non empty AMI-Struct over N, I being Instruction of A holds
  Out_U_Inp I = Output I \/ Input I
proof
  let A be with_non_trivial_ObjectKinds IC-Ins-separated non empty
  AMI-Struct over N, I be Instruction of A;
  for o being Object of A st o in Out_U_Inp I holds o in Output I \/ Input
  I
  proof
    let o be Object of A such that
A1: o in Out_U_Inp I;
    o in Input I or o in Output I
    proof
      assume
A2:   not o in Input I;
      per cases by A2,XBOOLE_0:def 5;
      suppose
        not o in Out_U_Inp I;
        hence thesis by A1;
      end;
      suppose
A3:     o in Out_\_Inp I;
        Out_\_Inp I c= Output I by Th10;
        hence thesis by A3;
      end;
    end;
    hence thesis by XBOOLE_0:def 3;
  end;
  hence Out_U_Inp I c= Output I \/ Input I by SUBSET_1:2;
  Output I c= Out_U_Inp I & Input I c= Out_U_Inp I by Th11,XBOOLE_1:36;
  hence thesis by XBOOLE_1:8;
end;

theorem Th15:
  for A being IC-Ins-separated non empty
  AMI-Struct over N, I being Instruction of A, o being Object of A st
  ObjectKind o is trivial holds not o in Out_U_Inp I
proof
  let A be IC-Ins-separated non empty AMI-Struct over
  N, I be Instruction of A, o be Object of A such that
A1: ObjectKind o is trivial;
  assume o in Out_U_Inp I;
  then consider s being State of A, a being Element of ObjectKind o such that
A2: Exec(I,s+*(o,a)) <> Exec(I,s) +* (o,a) by Def5;
  s.o is Element of ObjectKind o by MEMSTR_0:77;
  then s.o = a by A1,ZFMISC_1:def 10;
  then
A3: Exec(I,s+*(o,a)) = Exec(I,s) by FUNCT_7:35;
A4: dom Exec(I,s) = the carrier of A by PARTFUN1:def 2;
A5: for x being set st x in the carrier of A holds (Exec(I,s) +* (o,a)).x =
  Exec(I,s).x
  proof
    let x be set such that
    x in the carrier of A;
    per cases;
    suppose
A6:   x = o;
A7:   Exec(I,s).o is Element of ObjectKind o by MEMSTR_0:77;
      thus (Exec(I,s) +* (o,a)).x = a by A4,A6,FUNCT_7:31
        .= Exec(I,s).x by A1,A6,A7,ZFMISC_1:def 10;
    end;
    suppose
      x <> o;
      hence thesis by FUNCT_7:32;
    end;
  end;
  dom (Exec(I,s) +* (o,a)) = the carrier of A by PARTFUN1:def 2;
  hence contradiction by A2,A3,A4,A5,FUNCT_1:2;
end;

theorem
  for A being IC-Ins-separated non empty
  AMI-Struct over N , I being Instruction of A, o being Object of A st
  ObjectKind o is trivial holds not o in Input I
proof
  let A be IC-Ins-separated non empty AMI-Struct over
  N, I be Instruction of A, o be Object of A;
A1: Input I c= Out_U_Inp I by XBOOLE_1:36;
  assume ObjectKind o is trivial;
  hence thesis by A1,Th15;
end;

theorem
  for A being IC-Ins-separated non empty
  AMI-Struct over N , I being Instruction of A, o being Object of A st
  ObjectKind o is trivial holds not o in Output I
proof
  let A be IC-Ins-separated non empty AMI-Struct over
  N, I be Instruction of A, o be Object of A;
  assume
A1: ObjectKind o is trivial;
  Output I c= Out_U_Inp I by Th11;
  hence thesis by A1,Th15;
end;

theorem Th18:
  for A being IC-Ins-separated non empty
AMI-Struct over N, I being Instruction of A holds I is halting iff Output I
  is empty
proof
  let A be IC-Ins-separated non empty AMI-Struct over
  N, I be Instruction of A;
  thus I is halting implies Output I is empty
  proof
    assume
A1: for s being State of A holds Exec(I,s) = s;
    assume not thesis;
    then consider o being Object of A such that
A2: o in Output I by SUBSET_1:4;
    ex s being State of A st s.o <> Exec(I,s).o by A2,Def3;
    hence thesis by A1;
  end;
  assume
A3: Output I is empty;
  let s be State of A;
  assume
A4: Exec(I,s) <> s;
  dom s = the carrier of A & dom Exec(I,s) = the carrier of A
  by PARTFUN1:def 2;
  then ex x being set st x in the carrier of A & Exec(I,s).x <> s.x by A4,
FUNCT_1:2;
  hence contradiction by A3,Def3;
end;

theorem Th19:
  for A being with_non_trivial_ObjectKinds IC-Ins-separated
non empty AMI-Struct over N, I being Instruction
  of A st I is halting holds Out_\_Inp I is empty
proof
  let A be with_non_trivial_ObjectKinds IC-Ins-separated non empty
  AMI-Struct over N, I be Instruction of A such that
A1: I is halting;
  Out_\_Inp I c= Output I by Th10;
  then Out_\_Inp I c= {} by A1,Th18;
  hence thesis by XBOOLE_1:3;
end;

theorem Th20:
  for A being IC-Ins-separated non empty
AMI-Struct over N, I being Instruction of A st I is halting holds Out_U_Inp
  I is empty
proof
  let A be IC-Ins-separated non empty AMI-Struct over
  N, I be Instruction of A such that
A1: for s being State of A holds Exec(I,s) = s;
  assume not thesis;
  then consider o being Object of A such that
A2: o in Out_U_Inp I by SUBSET_1:4;
  consider s being State of A, a being Element of ObjectKind o such that
A3: Exec(I,s+*(o,a)) <> Exec(I,s) +* (o,a) by A2,Def5;
  Exec(I,s+*(o,a)) = s+*(o,a) by A1
    .= Exec(I,s) +* (o,a) by A1;
  hence thesis by A3;
end;

theorem Th21:
  for A being IC-Ins-separated non empty
  AMI-Struct over N, I being Instruction of A st I is halting holds Input I
  is empty
proof
  let A be IC-Ins-separated non empty AMI-Struct over
  N, I be Instruction of A;
  assume I is halting;
  then Input I = {} \ Out_\_Inp I by Th20
    .= {};
  hence thesis;
end;

registration

  let N be with_non-empty_elements non empty set,
  A be halting IC-Ins-separated
non empty AMI-Struct over N, I be halting Instruction of A;
  cluster Input I -> empty;
  coherence by Th21;
  cluster Output I -> empty;
  coherence by Th18;
  cluster Out_U_Inp I -> empty;
  coherence by Th20;
end;

registration
  let N be with_non-empty_elements non empty set;
  cluster halting with_non_trivial_ObjectKinds IC-Ins-separated for non
    empty AMI-Struct over N;
  existence
  proof
    take STC N;
    thus thesis;
  end;
end;

registration
  let N be with_non-empty_elements non empty set,
  A be halting
  with_non_trivial_ObjectKinds IC-Ins-separated non empty
  AMI-Struct over N, I be halting Instruction of A;
  cluster Out_\_Inp I -> empty;
  coherence by Th19;
end;

registration
  let N;
  cluster with_non_trivial_Instructions
  IC-Ins-separated
    for non empty AMI-Struct over N;
  existence
  proof
    take STC N;
    thus thesis;
  end;
end;

theorem
  for A being standard IC-Ins-separated non empty
  AMI-Struct over N, I being Instruction of A st I is
  sequential holds not IC A in Out_\_Inp I
proof
  let A be standard IC-Ins-separated non empty
  AMI-Struct over N, I be Instruction of A;
  set t = the State of A;
  set l = IC A;
   reconsider sICt = succ IC t as Element of NAT by ORDINAL1:def 12;
   reconsider w = sICt as Element of ObjectKind l by MEMSTR_0:def 3;
  set s = t +* (l,w);
  assume for s being State of A holds Exec(I,s).IC A = succ IC s;
  then
A1: Exec(I,t).l = succ IC t & Exec(I,s).l = succ IC s;
  dom t = the carrier of A by PARTFUN1:def 2;
  then Exec(I,t) <> Exec(I,s) by A1,FUNCT_7:31,ORDINAL1:9;
  hence thesis by Def4;
end;

theorem
  for A being IC-Ins-separated non empty
  AMI-Struct over N, I being Instruction of A st ex s being State of A st
  Exec(I,s).IC A <> IC s holds IC A in Output I by Def3;

registration
  let N;
  cluster standard for IC-Ins-separated non empty
    AMI-Struct over N;
  existence
  proof
    take STC N;
    thus thesis;
  end;
end;

theorem
  for A being standard IC-Ins-separated non empty
  AMI-Struct over N, I being Instruction of A st I is
  sequential holds IC A in Output I
proof
  let A be standard IC-Ins-separated non empty
  AMI-Struct over N, I be Instruction of A such that
A1: for s being State of A holds Exec(I, s).IC A = succ IC s;
  set s = the State of A;
  Exec(I,s).IC A = succ IC s by A1;
  then Exec(I,s).IC A <> IC s by ORDINAL1:9;
  hence thesis by Def3;
end;

theorem Th26:
  for A being IC-Ins-separated non empty
  AMI-Struct over N, I being Instruction of A st ex s being State of A st
  Exec(I,s).IC A <> IC s holds IC A in Out_U_Inp I
proof
  let A be IC-Ins-separated non empty AMI-Struct over
  N, I be Instruction of A;
  assume ex s being State of A st Exec(I,s).IC A <> IC s;
  then
A1: IC A in Output I by Def3;
  Output I c= Out_U_Inp I by Th11;
  hence thesis by A1;
end;

theorem
  for A being standard IC-Ins-separated non empty
  AMI-Struct over N, I being Instruction of A st I is
  sequential holds IC A in Out_U_Inp I
proof
  let A be standard IC-Ins-separated non empty
  AMI-Struct over N, I be Instruction of A;
  set s = the State of A;
  assume for s being State of A holds Exec(I,s).IC A = succ IC s;
  then Exec(I,s).IC A = succ IC s;
  then Exec(I,s).IC A <> IC s by ORDINAL1:9;
  hence thesis by Th26;
end;

theorem
  for A being IC-Ins-separated standard-ins non empty
   AMI-Struct over N, I being Instruction of A, o being Object
  of A st I is jump-only holds o in Output I implies o = IC A
proof
  let A be IC-Ins-separated standard-ins non empty
  AMI-Struct over N, I be Instruction of A, o be Object of A;
  assume
A1: for s being State of A, o being Object of A, J being Instruction of
  A st InsCode I = InsCode J & o in Data-Locations A holds Exec(J,s).o = s.o;
  assume o in Output I;
  then ex s being State of A st s.o <> Exec(I,s).o by Def3;
  then
A2:  not o in Data-Locations A by A1;
   o in the carrier of A;
   then o in {IC A} \/ Data-Locations A by STRUCT_0:4;
   then o in {IC A} by A2,XBOOLE_0:def 3;
  hence thesis by TARSKI:def 1;
end;

