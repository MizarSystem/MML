:: Memory handling for SCM+FSA
::  by Piotr Rudnicki and Andrzej Trybulec
::
:: Received July 18, 1996
:: Copyright (c) 1996 Association of Mizar Users

environ

 vocabularies SCMFSA_2, XBOOLE_0, AMI_1, GRAPHSP, AMI_3, FINSEQ_1, FUNCT_1,
      SUBSET_1, FINSUB_1, SETWISEO, CARD_1, TARSKI, CARD_3, RELAT_1, ZFMISC_1,
      SCMNORM, FINSET_1, NUMBERS, FUNCT_4, VALUED_1, ARYTM_3, AMISTD_2,
      XXREAL_0, SCMFSA6A, TURING_1, FSM_1, CIRCUIT2, STRUCT_0, ARYTM_1, INT_1,
      COMPLEX1, PARTFUN1, FINSEQ_2, NAT_1, SF_MASTR, ORDINAL1, RELOC;
 notations TARSKI, XBOOLE_0, ENUMSET1, ZFMISC_1, SUBSET_1, CARD_1, NUMBERS,
      XCMPLX_0, FINSET_1, FINSUB_1, NAT_1, INT_1, VALUED_1, STRUCT_0, SETWISEO,
      SEQ_4, CARD_3, FINSEQ_1, FINSEQ_2, RELAT_1, FUNCT_1, RELSET_1, PARTFUN1,
      FUNCT_2, FUNCT_4, FUNCT_7, COMPOS_1,
      EXTPRO_1, AMI_1, AMI_3, SCMFSA_2, AMISTD_2,
      SCMFSA6A, INT_2, XXREAL_0;
 constructors SETWISEO, INT_2, SEQ_4, AMI_5, SCMFSA6A,
      RELSET_1, VALUED_1, AMISTD_2, AMI_1;
 registrations SETFAM_1, FUNCT_1, ORDINAL1, RELSET_1, FUNCT_2, FINSET_1,
      FINSUB_1, NUMBERS, XREAL_0, INT_1, MEMBERED, CARD_3, AMI_1, AMI_5,
      SCMFSA_2, XBOOLE_0, XXREAL_2, VALUED_1, FINSEQ_1, AMISTD_2,
      SCMFSA10, COMPOS_1, EXTPRO_1;
 requirements NUMERALS, BOOLE, SUBSET, ARITHM;
 definitions XBOOLE_0, FUNCOP_1,
      EXTPRO_1, AMI_1, COMPOS_1, AMI_3, SCMFSA_2, SCMFSA6A,
      AMISTD_2;
 theorems TARSKI, ENUMSET1, ZFMISC_1, FINSEQ_1, FINSUB_1, SETWISEO, NAT_1,
      RELAT_1, GRFUNC_1, FUNCT_1, FUNCT_2, FUNCT_4, FUNCT_7, CARD_3,
      AMI_1, SCMFSA_2, SCMFSA_4, SCMFSA6A, XBOOLE_0, XBOOLE_1, ORDINAL1,
      AMI_3, VALUED_1, XXREAL_2, PARTFUN1, MCART_1, COMPOS_1, EXTPRO_1;
 schemes NAT_1, DOMAIN_1, FUNCT_2;

begin :: Preliminaries

registration
  cluster Int-Locations -> non empty;
  coherence by AMI_3:72;
end;

registration
  cluster FinSeq-Locations -> non empty;
  coherence by SCMFSA_2:10;
end;

begin :: Uniqueness of instruction components

reserve a, b, c, a1, a2, b1, b2 for Int-Location,
  l, l1, l2 for
  Element of NAT,
  f, g, f1, f2 for FinSeq-Location,
  i, j for
  Instruction of SCM+FSA;

canceled 4;

theorem Th5:
  a1:=b1 = a2:=b2 implies a1 = a2 & b1 = b2
proof
  assume
A1: a1:=b1 = a2:=b2;
  consider A1, B1 being Data-Location such that
A2: a1 = A1 & b1 = B1 & a1:=b1 = A1:=B1 by SCMFSA_2:def 11;
  consider A2, B2 being Data-Location such that
A3: a2 = A2 & b2 = B2 & a2:=b2 = A2:=B2 by SCMFSA_2:def 11;
A4: <*A2,B2*>.1 = A2 & <*A2,B2*>.2 = B2 by FINSEQ_1:61;
  <*A1,B1*>.1 = A1 & <*A1,B1*>.2 = B1 by FINSEQ_1:61;
  hence thesis by A1,A2,A3,A4,MCART_1:28;
end;

theorem Th6:
  AddTo(a1,b1) = AddTo(a2,b2) implies a1 = a2 & b1 = b2
proof
  assume
A1: AddTo(a1,b1) = AddTo(a2,b2);
  consider A1, B1 being Data-Location such that
A2: a1 = A1 & b1 = B1 & AddTo(a1,b1) = AddTo(A1,B1) by SCMFSA_2:def 12;
  consider A2, B2 being Data-Location such that
A3: a2 = A2 & b2 = B2 & AddTo(a2,b2) = AddTo(A2,B2) by SCMFSA_2:def 12;
A4: <*A2,B2*>.1 = A2 & <*A2,B2*>.2 = B2 by FINSEQ_1:61;
  <*A1,B1*>.1 = A1 & <*A1,B1*>.2 = B1 by FINSEQ_1:61;
  hence thesis by A1,A2,A3,A4,MCART_1:28;
end;

theorem Th7:
  SubFrom(a1,b1) = SubFrom(a2,b2) implies a1 = a2 & b1 = b2
proof
  assume
A1: SubFrom(a1,b1) = SubFrom(a2,b2);
  consider A1, B1 being Data-Location such that
A2: a1 = A1 & b1 = B1 & SubFrom(a1,b1) = SubFrom(A1,B1) by SCMFSA_2:def 13;
  consider A2, B2 being Data-Location such that
A3: a2 = A2 & b2 = B2 & SubFrom(a2,b2) = SubFrom(A2,B2) by SCMFSA_2:def 13;
A4: <*A2,B2*>.1 = A2 & <*A2,B2*>.2 = B2 by FINSEQ_1:61;
  <*A1,B1*>.1 = A1 & <*A1,B1*>.2 = B1 by FINSEQ_1:61;
  hence thesis by A1,A2,A3,A4,MCART_1:28;
end;

theorem Th8:
  MultBy(a1,b1) = MultBy(a2,b2) implies a1 = a2 & b1 = b2
proof
  assume
A1: MultBy(a1,b1) = MultBy(a2,b2);
  consider A1, B1 being Data-Location such that
A2: a1 = A1 & b1 = B1 & MultBy(a1,b1) = MultBy(A1,B1) by SCMFSA_2:def 14;
  consider A2, B2 being Data-Location such that
A3: a2 = A2 & b2 = B2 & MultBy(a2,b2) = MultBy(A2,B2) by SCMFSA_2:def 14;
A4: <*A2,B2*>.1 = A2 & <*A2,B2*>.2 = B2 by FINSEQ_1:61;
  <*A1,B1*>.1 = A1 & <*A1,B1*>.2 = B1 by FINSEQ_1:61;
  hence thesis by A1,A2,A3,A4,MCART_1:28;
end;

theorem Th9:
  Divide(a1,b1) = Divide(a2,b2) implies a1 = a2 & b1 = b2
proof
  assume
A1: Divide(a1,b1) = Divide(a2,b2);
  consider A1, B1 being Data-Location such that
A2: a1 = A1 & b1 = B1 & Divide(a1,b1) = Divide(A1,B1) by SCMFSA_2:def 15;
  consider A2, B2 being Data-Location such that
A3: a2 = A2 & b2 = B2 & Divide(a2,b2) = Divide(A2,B2) by SCMFSA_2:def 15;
A4: <*A2,B2*>.1 = A2 & <*A2,B2*>.2 = B2 by FINSEQ_1:61;
  <*A1,B1*>.1 = A1 & <*A1,B1*>.2 = B1 by FINSEQ_1:61;
  hence thesis by A1,A2,A3,A4,MCART_1:28;
end;

theorem
  goto l1 = goto l2 implies l1 = l2
proof
  assume
A1: goto l1 = goto l2;
  <*l1*>.1 = l1 & <*l2*>.1 = l2 by FINSEQ_1:57;
  hence thesis by A1,MCART_1:28;
end;

theorem Th11:
  a1=0_goto l1 = a2=0_goto l2 implies a1 = a2 & l1 = l2
proof
  assume
A1: a1=0_goto l1 = a2=0_goto l2;
  consider A1 being Data-Location such
  that
A2: a1 = A1 & a1=0_goto l1 = A1=0_goto l1 by SCMFSA_2:def 17;
  consider A2 being Data-Location such
  that
A3: a2 = A2 & a2=0_goto l2 = A2=0_goto l2 by SCMFSA_2:def 17;
A4: <*l2*>.1 = l2 & <*A2*>.1 = A2 by FINSEQ_1:57;
  <*l1*>.1 = l1 & <*A1*>.1 = A1 by FINSEQ_1:57;
  hence thesis by A1,A2,A3,A4,MCART_1:28;
end;

theorem Th12:
  a1>0_goto l1 = a2>0_goto l2 implies a1 = a2 & l1 = l2
proof
  assume
A1: a1>0_goto l1 = a2>0_goto l2;
  consider A1 being Data-Location such
  that
A2: a1 = A1 & a1>0_goto l1 = A1>0_goto l1 by SCMFSA_2:def 18;
  consider A2 being Data-Location such
  that
A3: a2 = A2 & a2>0_goto l2 = A2>0_goto l2 by SCMFSA_2:def 18;
A4: <*l2*>.1 = l2 & <*A2*>.1 = A2 by FINSEQ_1:57;
  <*l1*>.1 = l1 & <*A1*>.1 = A1 by FINSEQ_1:57;
  hence thesis by A1,A2,A3,A4,MCART_1:28;
end;

theorem Th13:
  b1:=(f1, a1) = b2:=(f2, a2) implies a1 = a2 & b1 = b2 & f1 = f2
proof
A1: <*b1,f1,a1*>.1 = b1 & <*b1,f1,a1*>.2 = f1 by FINSEQ_1:62;
A2: <*b1,f1,a1*>.3 = a1 & <*b2,f2,a2*>.1 = b2 by FINSEQ_1:62;
A3: <*b2,f2,a2*>.2 = f2 & <*b2,f2,a2*>.3 = a2 by FINSEQ_1:62;
  assume b1:=(f1, a1) = b2:=(f2, a2);
  hence thesis by A1,A2,A3,MCART_1:28;
end;

theorem Th14:
  (f1, a1):=b1 = (f2, a2):=b2 implies a1 = a2 & b1 = b2 & f1 = f2
proof
A1: <*b1,f1,a1*>.1 = b1 & <*b1,f1,a1*>.2 = f1 by FINSEQ_1:62;
A2: <*b1,f1,a1*>.3 = a1 & <*b2,f2,a2*>.1 = b2 by FINSEQ_1:62;
A3: <*b2,f2,a2*>.2 = f2 & <*b2,f2,a2*>.3 = a2 by FINSEQ_1:62;
  assume (f1, a1):=b1 = (f2, a2):=b2;
  hence thesis by A1,A2,A3,MCART_1:28;
end;

theorem Th15:
  a1:=len f1 = a2:=len f2 implies a1 = a2 & f1 = f2
proof
A1: <*a1,f1*>.1 = a1 & <*a1,f1*>.2 = f1 by FINSEQ_1:61;
A2: <*a2,f2*>.1 = a2 & <*a2,f2*>.2 = f2 by FINSEQ_1:61;
  assume a1:=len f1 = a2:=len f2;
  hence thesis by A1,A2,MCART_1:28;
end;

theorem Th16:
  f1:=<0,...,0>a1 = f2:=<0,...,0>a2 implies a1 = a2 & f1 = f2
proof
A1: <*a1,f1*>.1 = a1 & <*a1,f1*>.2 = f1 by FINSEQ_1:61;
A2: <*a2,f2*>.1 = a2 & <*a2,f2*>.2 = f2 by FINSEQ_1:61;
  assume f1:=<0,...,0>a1 = f2:=<0,...,0>a2;
  hence thesis by A1,A2,MCART_1:28;
end;

begin :: Integer locations used in a macro instruction

definition
  let i be Instruction of SCM+FSA;
  func UsedIntLoc i -> Element of Fin Int-Locations means
  :Def1:
  ex a, b being
  Int-Location st (i = (a := b) or i = AddTo(a, b) or i = SubFrom(a, b) or i =
MultBy(a, b) or i = Divide(a, b)) & it = {a, b} if InsCode i in {1, 2, 3, 4, 5}
  , ex a being Int-Location, l being Element of NAT st (i = a
=0_goto l or i = a>0_goto l) & it = {a} if InsCode i = 7 or InsCode i = 8, ex a
, b being Int-Location, f being FinSeq-Location st (i = b := (f, a) or i = (f,
  a) := b) & it = {a, b} if InsCode i = 9 or InsCode i = 10, ex a being
Int-Location, f being FinSeq-Location st (i = a :=len f or i = f :=<0,...,0>a)
  & it = {a} if InsCode i = 11 or InsCode i = 12 otherwise it = {};
  existence
  proof
    hereby
      assume InsCode i in {1, 2, 3, 4, 5};
      then
      InsCode i = 1 or InsCode i = 2 or InsCode i = 3 or InsCode i = 4 or
      InsCode i = 5 by ENUMSET1:def 3;
      then consider a, b being Int-Location such that
A1:   i = (a := b) or i = AddTo(a, b) or i = SubFrom(a, b) or i =
      MultBy(a, b) or i = Divide(a, b) by SCMFSA_2:54,55,56,57,58;
      reconsider a9 = a, b9 = b as Element of Int-Locations by SCMFSA_2:9;
      reconsider IT = {.a9, b9.} as Element of Fin Int-Locations;
      take IT;
      take a, b;
      thus (i = (a := b) or i = AddTo(a, b) or i = SubFrom(a, b) or i = MultBy
      (a, b) or i = Divide(a, b)) & IT = {a, b} by A1;
    end;
    hereby
      assume InsCode i = 7 or InsCode i = 8;
      then consider
      l being Element of NAT, a being Int-Location
      such that
A2:   i = a=0_goto l or i = a>0_goto l by SCMFSA_2:60,61;
      reconsider a9 = a as Element of Int-Locations by SCMFSA_2:9;
      reconsider IT = {.a9.} as Element of Fin Int-Locations;
      take IT;
      take a, l;
      thus (i = a=0_goto l or i = a>0_goto l) & IT = {a} by A2;
    end;
    hereby
      assume InsCode i = 9 or InsCode i = 10;
      then consider a, b being Int-Location, f being FinSeq-Location such that
A3:   i = b := (f, a) or i = (f, a) := b by SCMFSA_2:62,63;
      reconsider a9 = a, b9 = b as Element of Int-Locations by SCMFSA_2:9;
      reconsider IT = {.a9, b9.} as Element of Fin Int-Locations;
      take IT;
      take a, b, f;
      thus (i = b := (f, a) or i = (f, a) := b) & IT = {a, b} by A3;
    end;
    hereby
      assume InsCode i = 11 or InsCode i = 12;
      then consider a being Int-Location, f being FinSeq-Location such that
A4:   i = a :=len f or i = f :=<0,...,0>a by SCMFSA_2:64,65;
      reconsider a9 = a as Element of Int-Locations by SCMFSA_2:9;
      reconsider IT = {.a9.} as Element of Fin Int-Locations;
      take IT;
      take a, f;
      thus (i = a :=len f or i = f :=<0,...,0>a) & IT = {a} by A4;
    end;
    {} in Fin Int-Locations by FINSUB_1:18;
    hence thesis;
  end;
  uniqueness
  proof
    let it1, it2 be Element of Fin Int-Locations;
    hereby
      assume InsCode i in {1, 2, 3, 4, 5};
      given a1, b1 being Int-Location such that
A5:   i = (a1 := b1) or i = AddTo(a1, b1) or i = SubFrom(a1, b1) or i
      = MultBy(a1, b1) or i = Divide(a1, b1) and
A6:   it1 = {a1, b1};
      given a2, b2 being Int-Location such that
A7:   i = (a2 := b2) or i = AddTo(a2, b2) or i = SubFrom(a2, b2) or i
      = MultBy(a2, b2) or i = Divide(a2, b2) and
A8:   it2 = {a2, b2};
A9:   i = AddTo(a1, b1) or i = AddTo(a2, b2) implies InsCode i = 2 by
SCMFSA_2:43;
A10:  i = Divide(a1, b1) or i = Divide(a2, b2) implies InsCode i = 5 by
SCMFSA_2:46;
A11:  i = MultBy(a1, b1) or i = MultBy(a2, b2) implies InsCode i = 4 by
SCMFSA_2:45;
A12:  i = SubFrom(a1, b1) or i = SubFrom(a2, b2) implies InsCode i = 3 by
SCMFSA_2:44;
      per cases by A5,A7,A9,A12,A11,A10,SCMFSA_2:42;
      suppose
A13:    i = (a1 := b1) & i = (a2 := b2);
        then a1 = a2 by Th5;
        hence it1 = it2 by A6,A8,A13,Th5;
      end;
      suppose
A14:    i = AddTo(a1, b1) & i = AddTo(a2, b2);
        then a1 = a2 by Th6;
        hence it1 = it2 by A6,A8,A14,Th6;
      end;
      suppose
A15:    i = SubFrom(a1, b1) & i = SubFrom(a2, b2);
        then a1 = a2 by Th7;
        hence it1 = it2 by A6,A8,A15,Th7;
      end;
      suppose
A16:    i = MultBy(a1, b1) & i = MultBy(a2, b2);
        then a1 = a2 by Th8;
        hence it1 = it2 by A6,A8,A16,Th8;
      end;
      suppose
A17:    i = Divide(a1, b1) & i = Divide(a2, b2);
        then a1 = a2 by Th9;
        hence it1 = it2 by A6,A8,A17,Th9;
      end;
    end;
    hereby
      assume InsCode i = 7 or InsCode i = 8;
      given a1 being Int-Location, l1 being Element of NAT
      such that
A18:  i = a1=0_goto l1 or i = a1>0_goto l1 and
A19:  it1 = {a1};
      given a2 being Int-Location, l2 being Element of NAT
      such that
A20:  i = a2=0_goto l2 or i = a2>0_goto l2 and
A21:  it2 = {a2};
A22:  i = a1>0_goto l1 or i = a2>0_goto l2 implies InsCode i = 8 by SCMFSA_2:49
;
      per cases by A18,A20,A22,SCMFSA_2:48;
      suppose
        i = a1=0_goto l1 & i = a2=0_goto l2;
        hence it1 = it2 by A19,A21,Th11;
      end;
      suppose
        i = a1>0_goto l1 & i = a2>0_goto l2;
        hence it1 = it2 by A19,A21,Th12;
      end;
    end;
    hereby
      assume InsCode i = 9 or InsCode i = 10;
      given a1, b1 being Int-Location, f1 being FinSeq-Location such that
A23:  i = b1 := (f1, a1) or i = (f1, a1) := b1 and
A24:  it1 = {a1, b1};
      given a2, b2 being Int-Location, f2 being FinSeq-Location such that
A25:  i = b2 := (f2, a2) or i = (f2, a2) := b2 and
A26:  it2 = {a2, b2};
A27:  i = (f1, a1) := b1 or i = (f2, a2) := b2 implies InsCode i = 10 by
SCMFSA_2:51;
      per cases by A23,A25,A27,SCMFSA_2:50;
      suppose
A28:    i = b1 := (f1, a1) & i = b2 := (f2, a2);
        then a1 = a2 by Th13;
        hence it1 = it2 by A24,A26,A28,Th13;
      end;
      suppose
A29:    i = (f1, a1) := b1 & i = (f2, a2) := b2;
        then a1 = a2 by Th14;
        hence it1 = it2 by A24,A26,A29,Th14;
      end;
    end;
    hereby
      assume InsCode i = 11 or InsCode i = 12;
      given a1 being Int-Location, f1 being FinSeq-Location such that
A30:  i = a1 :=len f1 or i = f1 :=<0,...,0>a1 and
A31:  it1 = {a1};
      given a2 being Int-Location, f2 being FinSeq-Location such that
A32:  i = a2 :=len f2 or i = f2 :=<0,...,0>a2 and
A33:  it2 = {a2};
A34:  i = f1 :=<0,...,0>a1 or i = f2 :=<0,...,0>a2 implies InsCode i = 12
      by SCMFSA_2:53;
      per cases by A30,A32,A34,SCMFSA_2:52;
      suppose
        i = a1 :=len f1 & i = a2 :=len f2;
        hence it1 = it2 by A31,A33,Th15;
      end;
      suppose
        i = f1 :=<0,...,0>a1 & i = f2 :=<0,...,0>a2;
        hence it1 = it2 by A31,A33,Th16;
      end;
    end;
    thus thesis;
  end;
  consistency by ENUMSET1:def 3;
end;

theorem Th17:
  UsedIntLoc halt SCM+FSA = {}
proof
  not 0 in {1, 2, 3, 4, 5};
  hence thesis by Def1,SCMFSA_2:124;
end;

theorem Th18:
  i = a:=b or i = AddTo(a, b) or i = SubFrom(a, b) or i = MultBy(a
  , b) or i = Divide(a, b) implies UsedIntLoc i = {a, b}
proof
  a in Int-Locations & b in Int-Locations by SCMFSA_2:9;
  then {a, b} c= Int-Locations by ZFMISC_1:38;
  then reconsider ab = {a, b} as Element of Fin Int-Locations by FINSUB_1:def 5
;
  assume
A1: i = a:=b or i = AddTo(a, b) or i = SubFrom(a, b) or i = MultBy(a, b)
  or i = Divide(a, b);
  then InsCode i = 1 or InsCode i = 2 or InsCode i = 3 or InsCode i = 4 or
  InsCode i = 5 by SCMFSA_2:42,43,44,45,46;
  then InsCode i in {1, 2, 3, 4, 5} by ENUMSET1:def 3;
  then UsedIntLoc i = ab by A1,Def1;
  hence thesis;
end;

theorem Th19:
  UsedIntLoc goto l = {}
proof
  InsCode goto l = 6 & not 6 in {1, 2, 3, 4, 5} by ENUMSET1:def 3,SCMFSA_2:47;
  hence thesis by Def1;
end;

theorem Th20:
  i = a=0_goto l or i = a>0_goto l implies UsedIntLoc i = {a}
proof
  a in Int-Locations by SCMFSA_2:9;
  then {a} c= Int-Locations by ZFMISC_1:37;
  then reconsider ab = {a} as Element of Fin Int-Locations by FINSUB_1:def 5;
  assume
A1: i = a=0_goto l or i = a>0_goto l;
  then InsCode i = 7 or InsCode i = 8 by SCMFSA_2:48,49;
  then UsedIntLoc i = ab by A1,Def1;
  hence thesis;
end;

theorem Th21:
  i = b := (f, a) or i = (f, a) := b implies UsedIntLoc i = {a, b}
proof
  a in Int-Locations & b in Int-Locations by SCMFSA_2:9;
  then {a, b} c= Int-Locations by ZFMISC_1:38;
  then reconsider ab = {a, b} as Element of Fin Int-Locations by FINSUB_1:def 5
;
  assume
A1: i = b := (f, a) or i = (f, a) := b;
  then InsCode i = 9 or InsCode i = 10 by SCMFSA_2:50,51;
  then UsedIntLoc i = ab by A1,Def1;
  hence thesis;
end;

theorem Th22:
  i = a :=len f or i = f :=<0,...,0>a implies UsedIntLoc i = {a}
proof
  a in Int-Locations by SCMFSA_2:9;
  then {a} c= Int-Locations by ZFMISC_1:37;
  then reconsider ab = {a} as Element of Fin Int-Locations by FINSUB_1:def 5;
  assume
A1: i = a :=len f or i = f :=<0,...,0>a;
  then InsCode i = 11 or InsCode i = 12 by SCMFSA_2:52,53;
  then UsedIntLoc i = ab by A1,Def1;
  hence thesis;
end;

definition
  let p be Function;
  func UsedIntLoc p -> Subset of Int-Locations means
  :Def2:
  ex UIL being
  Function of the Instructions of SCM+FSA, Fin Int-Locations st (for i being
  Instruction of SCM+FSA holds UIL.i = UsedIntLoc i) & it = Union (UIL * p);
  existence
  proof
    defpred P[set,set] means ex I being Instruction of SCM+FSA st $1 = I & $2
    = UsedIntLoc I;
A1: for e being Element of the Instructions of SCM+FSA ex u being Element
    of Fin Int-Locations st P[e,u]
    proof
      let e be Element of the Instructions of SCM+FSA;
      reconsider f = e as Instruction of SCM+FSA;
      reconsider u = UsedIntLoc f as Element of Fin Int-Locations;
      take u, f;
      thus thesis;
    end;
    consider UIL being Function of the Instructions of SCM+FSA, Fin
    Int-Locations such that
A2: for i being Element of the Instructions of SCM+FSA holds P[i,UIL.i
    ] from FUNCT_2:sch 3(A1);
    set IT = Union (UIL * p), Up =UIL * p;
    take IT;
    Fin Int-Locations c= bool Int-Locations by FINSUB_1:26;
    then rng Up c= rng UIL & rng UIL c= bool Int-Locations by RELAT_1:45
,XBOOLE_1:1;
    then rng Up c= bool Int-Locations by XBOOLE_1:1;
    then IT = union rng Up & union rng Up c= union bool Int-Locations by
CARD_3:def 4,ZFMISC_1:95;
    hence IT is Subset of Int-Locations by ZFMISC_1:99;
    take UIL;
    hereby
      let i be Instruction of SCM+FSA;
      P[i,UIL.i] by A2;
      hence UIL.i = UsedIntLoc i;
    end;
    thus thesis;
  end;
  uniqueness
  proof
    let IT1, IT2 be Subset of Int-Locations;
    given UIL1 being Function of the Instructions of SCM+FSA, Fin
    Int-Locations such that
A3: for i being Instruction of SCM+FSA holds UIL1.i = UsedIntLoc i and
A4: IT1 = Union (UIL1 * p);
    given UIL2 being Function of the Instructions of SCM+FSA, Fin
    Int-Locations such that
A5: for i being Instruction of SCM+FSA holds UIL2.i = UsedIntLoc i and
A6: IT2 = Union (UIL2 * p);
    for c be Element of the Instructions of SCM+FSA holds UIL1.c = UIL2.c
    proof
      let c be Element of the Instructions of SCM+FSA;
      reconsider d = c as Instruction of SCM+FSA;
      thus UIL1.c = UsedIntLoc d by A3
        .= UIL2.c by A5;
    end;
    hence thesis by A4,A6,FUNCT_2:113;
  end;
end;

registration
  let p be preProgram of SCM+FSA;
  cluster UsedIntLoc p -> finite;
  coherence
  proof
    reconsider dp = dom p as finite set;
    consider UIL being Function of the Instructions of SCM+FSA, Fin
    Int-Locations such that
    for i being Instruction of SCM+FSA holds UIL.i = UsedIntLoc i and
A1: UsedIntLoc p = Union (UIL * p) by Def2;
    rng p c= the Instructions of SCM+FSA by RELAT_1:def 19;
    then reconsider p9 = p as Function of dp, the Instructions of SCM+FSA by
FUNCT_2:4;
    reconsider Up = UIL * p9 as Function of dp, Fin Int-Locations;
    Union Up is finite;
    hence thesis by A1;
  end;
end;

reserve p, r for preProgram of SCM+FSA,
  I, J for Program of SCM+FSA,
  k, m, n
  for Element of NAT;

theorem Th23:
  i in rng p implies UsedIntLoc i c= UsedIntLoc p
proof
  assume i in rng p;
  then consider x being set such that
A1: x in dom p & i = p.x by FUNCT_1:def 5;
  consider UIL being Function of the Instructions of SCM+FSA, Fin
  Int-Locations such that
A2: for i being Instruction of SCM+FSA holds UIL.i = UsedIntLoc i and
A3: UsedIntLoc p = Union (UIL * p) by Def2;
A4: UsedIntLoc p = union rng (UIL * p) by A3,CARD_3:def 4;
  dom UIL = the Instructions of SCM+FSA by FUNCT_2:def 1;
  then x in dom (UIL * p) by A1,FUNCT_1:21;
  then
A5: (UIL * p).x in rng (UIL * p) by FUNCT_1:def 5;
  (UIL * p).x = UIL.i by A1,FUNCT_1:23
    .= UsedIntLoc i by A2;
  hence thesis by A5,A4,ZFMISC_1:92;
end;

theorem
  UsedIntLoc (p +* r) c= (UsedIntLoc p) \/ (UsedIntLoc r)
proof
  consider UIL being Function of the Instructions of SCM+FSA, Fin
  Int-Locations such that
A1: for i being Instruction of SCM+FSA holds UIL.i = UsedIntLoc i and
A2: UsedIntLoc (p +* r) = Union (UIL * (p +* r)) by Def2;
  consider UIL1 being Function of the Instructions of SCM+FSA, Fin
  Int-Locations such that
A3: for i being Instruction of SCM+FSA holds UIL1.i = UsedIntLoc i and
A4: UsedIntLoc p = Union (UIL1 * p) by Def2;
  for c be Element of the Instructions of SCM+FSA holds UIL.c = UIL1.c
  proof
    let c be Element of the Instructions of SCM+FSA;
    reconsider d = c as Instruction of SCM+FSA;
    thus UIL.c = UsedIntLoc d by A1
      .= UIL1.c by A3;
  end;
  then
A5: UIL=UIL1 by FUNCT_2:113;
  consider UIL2 being Function of the Instructions of SCM+FSA, Fin
  Int-Locations such that
A6: for i being Instruction of SCM+FSA holds UIL2.i = UsedIntLoc i and
A7: UsedIntLoc r = Union (UIL2 * r) by Def2;
  for c be Element of the Instructions of SCM+FSA holds UIL.c = UIL2.c
  proof
    let c be Element of the Instructions of SCM+FSA;
    reconsider d = c as Instruction of SCM+FSA;
    thus UIL.c = UsedIntLoc d by A1
      .= UIL2.c by A6;
  end;
  then
A8: UIL=UIL2 by FUNCT_2:113;
  dom UIL = the Instructions of SCM+FSA by FUNCT_2:def 1;
  then rng r c= dom UIL by RELAT_1:def 19;
  then UIL * (p +* r) = (UIL * p) +* (UIL * r) by FUNCT_7:10;
  then
A9: Union (UIL * r) = union rng (UIL * r) & union rng (UIL * (p +* r)) c=
  union (rng (UIL * p) \/ rng (UIL * r)) by CARD_3:def 4,FUNCT_4:18,ZFMISC_1:95
;
  Union (UIL * (p +* r)) = union rng (UIL * (p +* r)) & Union (UIL * p) =
  union rng (UIL * p) by CARD_3:def 4;
  hence thesis by A2,A4,A7,A5,A8,A9,ZFMISC_1:96;
end;

theorem Th25:
  dom p misses dom r implies UsedIntLoc (p +* r) = (UsedIntLoc p)
  \/ (UsedIntLoc r)
proof
  consider UIL being Function of the Instructions of SCM+FSA, Fin
  Int-Locations such that
A1: for i being Instruction of SCM+FSA holds UIL.i = UsedIntLoc i and
A2: UsedIntLoc (p +* r) = Union (UIL * (p +* r)) by Def2;
  assume dom p misses dom r;
  then dom (UIL * p) c= dom p & dom p misses dom (UIL * r) by RELAT_1:44
,XBOOLE_1:63;
  then
A3: (UIL * p) +* (UIL * r) = (UIL * p) \/ (UIL * r) by FUNCT_4:32,XBOOLE_1:63;
  dom UIL = the Instructions of SCM+FSA by FUNCT_2:def 1;
  then rng r c= dom UIL by RELAT_1:def 19;
  then UIL * (p +* r) = (UIL * p) +* (UIL * r) by FUNCT_7:10;
  then
A4: Union (UIL * r) = union rng (UIL * r) & union rng (UIL * (p +* r)) =
  union ( rng (UIL * p) \/ rng (UIL * r)) by A3,CARD_3:def 4,RELAT_1:26;
  consider UIL1 being Function of the Instructions of SCM+FSA, Fin
  Int-Locations such that
A5: for i being Instruction of SCM+FSA holds UIL1.i = UsedIntLoc i and
A6: UsedIntLoc p = Union (UIL1 * p) by Def2;
  for c be Element of the Instructions of SCM+FSA holds UIL.c = UIL1.c
  proof
    let c be Element of the Instructions of SCM+FSA;
    reconsider d = c as Instruction of SCM+FSA;
    thus UIL.c = UsedIntLoc d by A1
      .= UIL1.c by A5;
  end;
  then
A7: UIL=UIL1 by FUNCT_2:113;
  consider UIL2 being Function of the Instructions of SCM+FSA, Fin
  Int-Locations such that
A8: for i being Instruction of SCM+FSA holds UIL2.i = UsedIntLoc i and
A9: UsedIntLoc r = Union (UIL2 * r) by Def2;
  for c be Element of the Instructions of SCM+FSA holds UIL.c = UIL2.c
  proof
    let c be Element of the Instructions of SCM+FSA;
    reconsider d = c as Instruction of SCM+FSA;
    thus UIL.c = UsedIntLoc d by A1
      .= UIL2.c by A8;
  end;
  then
A10: UIL=UIL2 by FUNCT_2:113;
  Union (UIL * (p +* r)) = union rng (UIL * (p +* r)) & Union (UIL * p) =
  union rng (UIL * p) by CARD_3:def 4;
  hence thesis by A2,A6,A9,A7,A10,A4,ZFMISC_1:96;
end;

theorem Th26:
  UsedIntLoc p = UsedIntLoc Shift(p, k)
proof
  set Sp = Shift (p, k);
  consider UIL being Function of the Instructions of SCM+FSA, Fin
  Int-Locations such that
A1: for i being Instruction of SCM+FSA holds UIL.i = UsedIntLoc i and
A2: UsedIntLoc p = Union (UIL * p) by Def2;
  consider UIL2 being Function of the Instructions of SCM+FSA, Fin
  Int-Locations such that
A3: for i being Instruction of SCM+FSA holds UIL2.i = UsedIntLoc i and
A4: UsedIntLoc Shift (p, k) = Union (UIL2 * Shift (p, k)) by Def2;
  for c be Element of the Instructions of SCM+FSA holds UIL.c = UIL2.c
  proof
    let c be Element of the Instructions of SCM+FSA;
    reconsider d = c as Instruction of SCM+FSA;
    thus UIL.c = UsedIntLoc d by A1
      .= UIL2.c by A3;
  end;
  then
A5: UIL=UIL2 by FUNCT_2:113;
A6: dom Sp = { m+k where m is Element of NAT : m in dom p } by VALUED_1:def 12;
  now
    let y be set;
    hereby
      assume y in rng Sp;
      then consider x being set such that
A7:   x in dom Sp and
A8:   y = Sp.x by FUNCT_1:def 5;
      consider m being Element of NAT such that
A9:   x = m+k and
A10:  m in dom p by A6,A7;
      Sp.x = p. m by A9,A10,VALUED_1:def 12;
      hence y in rng p by A8,A10,FUNCT_1:def 5;
    end;
    assume y in rng p;
    then consider x being set such that
A11: x in dom p and
A12: y = p.x by FUNCT_1:def 5;
    dom p c= NAT by RELAT_1:def 18;
    then reconsider x9 = x as Element of NAT by A11;
    reconsider m = x9 as Element of NAT;
     (m+k) in dom Sp & Sp. (m+k) = p. m by A6,A11,VALUED_1:def 12;
    hence y in rng Sp by A12,FUNCT_1:def 5;
  end;
  then
A13: rng Sp = rng p by TARSKI:2;
A14: Union (UIL * Sp) = union rng (UIL * Sp) by CARD_3:def 4;
  rng (UIL * Sp) = UIL.:rng Sp by RELAT_1:160
    .= rng (UIL * p) by A13,RELAT_1:160;
  hence thesis by A2,A4,A5,A14,CARD_3:def 4;
end;

theorem Th27:
  UsedIntLoc i = UsedIntLoc IncAddr(i, k)
proof
A1: InsCode i <= 11+1 by SCMFSA_2:35;
A2: InsCode i <= 10+1 implies InsCode i <= 10 or InsCode i = 11 by NAT_1:8;
A3: InsCode i <= 9+1 implies InsCode i <= 8+1 or InsCode i = 10 by NAT_1:8;
  per cases by A1,A2,A3,NAT_1:8,33;
  suppose
    InsCode i = 0;
    then i = halt SCM+FSA by SCMFSA_2:122;
    hence thesis by SCMFSA_4:8;
  end;
  suppose
    InsCode i = 1;
    then ex a, b st i = a:=b by SCMFSA_2:54;
    hence thesis by SCMFSA_4:9;
  end;
  suppose
    InsCode i = 2;
    then ex a, b st i = AddTo(a,b) by SCMFSA_2:55;
    hence thesis by SCMFSA_4:10;
  end;
  suppose
    InsCode i = 3;
    then ex a, b st i = SubFrom(a, b) by SCMFSA_2:56;
    hence thesis by SCMFSA_4:11;
  end;
  suppose
    InsCode i = 4;
    then ex a, b st i = MultBy(a, b) by SCMFSA_2:57;
    hence thesis by SCMFSA_4:12;
  end;
  suppose
    InsCode i = 5;
    then ex a, b st i = Divide(a, b) by SCMFSA_2:58;
    hence thesis by SCMFSA_4:13;
  end;
  suppose
    InsCode i = 6;
    then consider l such that
A4: i = goto l by SCMFSA_2:59;
    IncAddr(i, k) = goto (l+k) by A4,SCMFSA_4:14;
    hence UsedIntLoc IncAddr(i, k) = {} by Th19
      .= UsedIntLoc i by A4,Th19;
  end;
  suppose
    InsCode i = 7;
    then consider l, a such that
A5: i = a=0_goto l by SCMFSA_2:60;
    IncAddr(i, k) = a=0_goto (l+k) by A5,SCMFSA_4:15;
    hence UsedIntLoc IncAddr(i, k) = {a} by Th20
      .= UsedIntLoc i by A5,Th20;
  end;
  suppose
    InsCode i = 8;
    then consider l, a such that
A6: i = a>0_goto l by SCMFSA_2:61;
    IncAddr(i, k) = a>0_goto (l+k) by A6,SCMFSA_4:16;
    hence UsedIntLoc IncAddr(i, k) = {a} by Th20
      .= UsedIntLoc i by A6,Th20;
  end;
  suppose
    InsCode i = 9;
    then ex a, b, f st i = b:=(f,a) by SCMFSA_2:62;
    hence thesis by SCMFSA_4:17;
  end;
  suppose
    InsCode i = 10;
    then ex a, b, f st i = (f,a):=b by SCMFSA_2:63;
    hence thesis by SCMFSA_4:18;
  end;
  suppose
    InsCode i = 11;
    then ex a, f st i = a:=len f by SCMFSA_2:64;
    hence thesis by SCMFSA_4:19;
  end;
  suppose
    InsCode i = 12;
    then ex a,f st i = f:=<0,...,0>a by SCMFSA_2:65;
    hence thesis by SCMFSA_4:20;
  end;
end;

theorem Th28:
  UsedIntLoc p = UsedIntLoc IncAddr(p, k)
proof
  set Ip = IncAddr (p, k);
  consider UIL being Function of the Instructions of SCM+FSA, Fin
  Int-Locations such that
A1: for i being Instruction of SCM+FSA holds UIL.i = UsedIntLoc i and
A2: UsedIntLoc p = Union (UIL * p) by Def2;
  set g = UIL * p;
  set f = UIL * Ip;
  consider UIL2 being Function of the Instructions of SCM+FSA, Fin
  Int-Locations such that
A3: for i being Instruction of SCM+FSA holds UIL2.i = UsedIntLoc i and
A4: UsedIntLoc IncAddr (p, k) = Union (UIL2 * IncAddr (p, k)) by Def2;
  for c be Element of the Instructions of SCM+FSA holds UIL.c = UIL2.c
  proof
    let c be Element of the Instructions of SCM+FSA;
    reconsider d = c as Instruction of SCM+FSA;
    thus UIL.c = UsedIntLoc d by A1
      .= UIL2.c by A3;
  end;
  then
A5: UIL=UIL2 by FUNCT_2:113;
  now
A6: dom UIL = the Instructions of SCM+FSA by FUNCT_2:def 1;
    then
A7: rng p c= dom UIL by RELAT_1:def 19;
A8: rng Ip c= dom UIL by A6,RELAT_1:def 19;
    then
A9: dom f = dom Ip by RELAT_1:46;
A10: dom Ip = dom p by COMPOS_1:def 40;
    hence dom f = dom g by A7,A9,RELAT_1:46;
    let x be set;
    assume
A11: x in dom f;
    then p.x in rng p by A10,A9,FUNCT_1:def 5;
    then reconsider px = p.x as Instruction of SCM+FSA by A7,FUNCT_2:def 1;
    dom p c= NAT by RELAT_1:def 18;
    then reconsider x9 = x as Element of NAT by A10,A9,A11;
    reconsider m = x9 as Element of NAT;
A12: Ip.x = IncAddr(p/.m,k) by A10,A9,A11,COMPOS_1:def 40
      .= IncAddr(px, k) by A10,A9,A11,PARTFUN1:def 8;
    Ip.x in rng Ip by A9,A11,FUNCT_1:def 5;
    then reconsider Ipx = Ip.x as Instruction of SCM+FSA by A8,FUNCT_2:def 1;
    thus f.x = UIL.Ipx by A11,FUNCT_1:22
      .= UsedIntLoc Ipx by A1
      .= UsedIntLoc px by A12,Th27
      .= UIL.px by A3,A5
      .= g.x by A10,A9,A11,FUNCT_1:23;
  end;
  hence thesis by A2,A4,A5,FUNCT_1:9;
end;

theorem Th29:
  UsedIntLoc I = UsedIntLoc ProgramPart Relocated (I, k)
proof
  UsedIntLoc ProgramPart Relocated (I, k) = UsedIntLoc Reloc(
  ProgramPart I,k) by COMPOS_1:116
    .= UsedIntLoc Shift (ProgramPart I, k) by Th28
    .= UsedIntLoc ProgramPart I by Th26;
  hence thesis by RELAT_1:209;
end;

theorem Th30:
  UsedIntLoc I = UsedIntLoc Directed I
proof
  consider UIL being Function of the Instructions of SCM+FSA, Fin
  Int-Locations such that
A1: for i being Instruction of SCM+FSA holds UIL.i = UsedIntLoc i and
A2: UsedIntLoc I = Union (UIL * I) by Def2;
A3: dom UIL = the Instructions of SCM+FSA & UIL.halt SCM+FSA = {} by A1,Th17,
FUNCT_2:def 1;
  consider UIL2 being Function of the Instructions of SCM+FSA, Fin
  Int-Locations such that
A4: for i being Instruction of SCM+FSA holds UIL2.i = UsedIntLoc i and
A5: UsedIntLoc Directed I = Union (UIL2 * Directed I) by Def2;
A6: for c be Element of the Instructions of SCM+FSA holds UIL.c = UIL2.c
  proof
    let c be Element of the Instructions of SCM+FSA;
    reconsider d = c as Instruction of SCM+FSA;
    thus UIL.c = UsedIntLoc d by A1
      .= UIL2.c by A4;
  end;
A7: UIL.goto  card I = UsedIntLoc goto  card I by A1
    .= {} by Th19;
  rng I c= the Instructions of SCM+FSA by RELAT_1:def 19;
  then UIL * Directed I = UIL * (((id the Instructions of SCM+FSA) +* (halt
  SCM+FSA, goto  card I))*I) by FUNCT_7:118
    .= UIL * ((id the Instructions of SCM+FSA) +* (halt SCM+FSA, goto
  card I)) * I by RELAT_1:55
    .= UIL * I by A3,A7,FUNCT_7:110;
  hence thesis by A2,A5,A6,FUNCT_2:113;
end;

theorem Th31:
  UsedIntLoc (I ';' J) = (UsedIntLoc I) \/ (UsedIntLoc J)
proof
  dom I = dom Directed I by FUNCT_4:105;
  then dom (Directed I) misses dom (ProgramPart Relocated(J, card I)) by
SCMFSA6A:16;
  hence UsedIntLoc (I ';' J) = UsedIntLoc (Directed I) \/ UsedIntLoc
  ProgramPart Relocated(J, card I) by Th25
    .= (UsedIntLoc I) \/ UsedIntLoc ProgramPart Relocated(J, card I) by Th30
    .= (UsedIntLoc I) \/ (UsedIntLoc J) by Th29;
end;

theorem Th32:
  UsedIntLoc Macro i = UsedIntLoc i
proof
  consider UIL being Function of the Instructions of SCM+FSA, Fin
  Int-Locations such that
A1: for i being Instruction of SCM+FSA holds UIL.i = UsedIntLoc i and
A2: UsedIntLoc Macro i = Union (UIL * Macro i) by Def2;
A3: rng (Macro i) = {i, halt SCM+FSA} & dom UIL = the Instructions of
  SCM+FSA by FUNCT_2:def 1,FUNCT_4:67;
  thus UsedIntLoc Macro i = union rng (UIL * Macro i) by A2,CARD_3:def 4
    .= union (UIL.:rng Macro i) by RELAT_1:160
    .= union {UIL.i,UIL.halt SCM+FSA} by A3,FUNCT_1:118
    .= UIL.i \/ UIL.halt SCM+FSA by ZFMISC_1:93
    .= (UsedIntLoc i) \/ UIL.halt SCM+FSA by A1
    .= (UsedIntLoc i) \/ (UsedIntLoc halt SCM+FSA) by A1
    .= UsedIntLoc i by Th17;
end;

theorem
  UsedIntLoc (i ';' J) = (UsedIntLoc i) \/ UsedIntLoc J
proof
  thus UsedIntLoc (i ';' J) = (UsedIntLoc Macro i) \/ UsedIntLoc J by Th31
    .= (UsedIntLoc i) \/ UsedIntLoc J by Th32;
end;

theorem
  UsedIntLoc (I ';' j) = (UsedIntLoc I) \/ UsedIntLoc j
proof
  thus UsedIntLoc (I ';' j) = (UsedIntLoc I) \/ UsedIntLoc Macro j by Th31
    .= (UsedIntLoc I) \/ UsedIntLoc j by Th32;
end;

theorem
  UsedIntLoc (i ';' j) = (UsedIntLoc i) \/ UsedIntLoc j
proof
  thus UsedIntLoc (i ';' j) = (UsedIntLoc Macro i) \/ UsedIntLoc Macro j by
Th31
    .= (UsedIntLoc Macro i) \/ UsedIntLoc j by Th32
    .= (UsedIntLoc i) \/ UsedIntLoc j by Th32;
end;

begin :: Finite sequence locations used in macro instructions

definition
  let i be Instruction of SCM+FSA;
  func UsedInt*Loc i -> Element of Fin FinSeq-Locations means
  :Def3:
  ex a, b
  being Int-Location, f being FinSeq-Location st (i = b := (f, a) or i = (f, a)
:= b) & it = {f} if InsCode i = 9 or InsCode i = 10, ex a being Int-Location, f
  being FinSeq-Location st (i = a :=len f or i = f :=<0,...,0>a) & it = {f} if
  InsCode i = 11 or InsCode i = 12 otherwise it = {};
  existence
  proof
    hereby
      assume InsCode i = 9 or InsCode i = 10;
      then consider a, b being Int-Location, f being FinSeq-Location such that
A1:   i = b := (f, a) or i = (f, a) := b by SCMFSA_2:62,63;
      reconsider f9 = f as Element of FinSeq-Locations by SCMFSA_2:10;
      reconsider IT = {.f9.} as Element of Fin FinSeq-Locations;
      take IT;
      take a, b, f;
      thus (i = b := (f, a) or i = (f, a) := b) & IT = {f} by A1;
    end;
    hereby
      assume InsCode i = 11 or InsCode i = 12;
      then consider a being Int-Location, f being FinSeq-Location such that
A2:   i = a :=len f or i = f :=<0,...,0>a by SCMFSA_2:64,65;
      reconsider f9 = f as Element of FinSeq-Locations by SCMFSA_2:10;
      reconsider IT = {.f9.} as Element of Fin FinSeq-Locations;
      take IT;
      take a, f;
      thus (i = a :=len f or i = f :=<0,...,0>a) & IT = {f} by A2;
    end;
    {} in Fin FinSeq-Locations by FINSUB_1:18;
    hence thesis;
  end;
  uniqueness
  proof
    let it1, it2 be Element of Fin FinSeq-Locations;
    hereby
      assume InsCode i = 9 or InsCode i = 10;
      given a1, b1 being Int-Location, f1 being FinSeq-Location such that
A3:   i = b1 := (f1, a1) or i = (f1, a1) := b1 and
A4:   it1 = {f1};
      given a2, b2 being Int-Location, f2 being FinSeq-Location such that
A5:   i = b2 := (f2, a2) or i = (f2, a2) := b2 and
A6:   it2 = {f2};
A7:   i = (f1, a1) := b1 or i = (f2, a2) := b2 implies InsCode i = 10 by
SCMFSA_2:51;
      per cases by A3,A5,A7,SCMFSA_2:50;
      suppose
        i = b1 := (f1, a1) & i = b2 := (f2, a2);
        hence it1 = it2 by A4,A6,Th13;
      end;
      suppose
        i = (f1, a1) := b1 & i = (f2, a2) := b2;
        hence it1 = it2 by A4,A6,Th14;
      end;
    end;
    hereby
      assume InsCode i = 11 or InsCode i = 12;
      given a1 being Int-Location, f1 being FinSeq-Location such that
A8:   i = a1 :=len f1 or i = f1 :=<0,...,0>a1 and
A9:   it1 = {f1};
      given a2 being Int-Location, f2 being FinSeq-Location such that
A10:  i = a2 :=len f2 or i = f2 :=<0,...,0>a2 and
A11:  it2 = {f2};
A12:  i = f1 :=<0,...,0>a1 or i = f2 :=<0,...,0>a2 implies InsCode i = 12
      by SCMFSA_2:53;
      per cases by A8,A10,A12,SCMFSA_2:52;
      suppose
        i = a1 :=len f1 & i = a2 :=len f2;
        hence it1 = it2 by A9,A11,Th15;
      end;
      suppose
        i = f1 :=<0,...,0>a1 & i = f2 :=<0,...,0>a2;
        hence it1 = it2 by A9,A11,Th16;
      end;
    end;
    thus thesis;
  end;
  consistency;
end;

theorem Th36:
  i = halt SCM+FSA or i = a:=b or i = AddTo(a, b) or i = SubFrom(a
, b) or i = MultBy(a, b) or i = Divide(a, b) or i = goto l or i = a=0_goto l or
  i = a>0_goto l implies UsedInt*Loc i = {}
proof
  assume i = halt SCM+FSA or i = a:=b or i = AddTo(a, b) or i = SubFrom(a, b)
or i = MultBy(a, b) or i = Divide(a, b) or i = goto l or i = a=0_goto l or i =
  a>0_goto l;
  then InsCode i = 0 or InsCode i = 1 or InsCode i = 2 or InsCode i = 3 or
InsCode i = 4 or InsCode i = 5 or InsCode i = 6 or InsCode i = 7 or InsCode i =
  8 by SCMFSA_2:42,43,44,45,46,47,48,49,124;
  hence thesis by Def3;
end;

theorem Th37:
  i = b := (f, a) or i = (f, a) := b implies UsedInt*Loc i = {f}
proof
  f in FinSeq-Locations by SCMFSA_2:10;
  then {f} c= FinSeq-Locations by ZFMISC_1:37;
  then reconsider ab = {f} as Element of Fin FinSeq-Locations by FINSUB_1:def 5
;
  assume
A1: i = b := (f, a) or i = (f, a) := b;
  then InsCode i = 9 or InsCode i = 10 by SCMFSA_2:50,51;
  then UsedInt*Loc i = ab by A1,Def3;
  hence thesis;
end;

theorem Th38:
  i = a :=len f or i = f :=<0,...,0>a implies UsedInt*Loc i = {f}
proof
  f in FinSeq-Locations by SCMFSA_2:10;
  then {f} c= FinSeq-Locations by ZFMISC_1:37;
  then reconsider ab = {f} as Element of Fin FinSeq-Locations by FINSUB_1:def 5
;
  assume
A1: i = a :=len f or i = f :=<0,...,0>a;
  then InsCode i = 11 or InsCode i = 12 by SCMFSA_2:52,53;
  then UsedInt*Loc i = ab by A1,Def3;
  hence thesis;
end;

definition
  let p be Function;
  func UsedInt*Loc p -> Subset of FinSeq-Locations means
  :Def4:
  ex UIL being
  Function of the Instructions of SCM+FSA, Fin FinSeq-Locations st (for i being
  Instruction of SCM+FSA holds UIL.i = UsedInt*Loc i) & it = Union (UIL * p);
  existence
  proof
    defpred P[set,set] means ex I being Instruction of SCM+FSA st $1 = I & $2
    = UsedInt*Loc I;
A1: for e being Element of the Instructions of SCM+FSA ex u being Element
    of Fin FinSeq-Locations st P[e,u]
    proof
      let e be Element of the Instructions of SCM+FSA;
      reconsider f = e as Instruction of SCM+FSA;
      reconsider u = UsedInt*Loc f as Element of Fin FinSeq-Locations;
      take u, f;
      thus thesis;
    end;
    consider UIL being Function of the Instructions of SCM+FSA, Fin
    FinSeq-Locations such that
A2: for i being Element of the Instructions of SCM+FSA holds P[i,UIL.i
    ] from FUNCT_2:sch 3(A1);
    set IT = Union (UIL * p), Up = UIL * p;
    take IT;
    Fin FinSeq-Locations c= bool FinSeq-Locations by FINSUB_1:26;
    then rng Up c= rng UIL & rng UIL c= bool FinSeq-Locations by RELAT_1:45
,XBOOLE_1:1;
    then rng Up c= bool FinSeq-Locations by XBOOLE_1:1;
    then IT = union rng Up & union rng Up c= union bool FinSeq-Locations by
CARD_3:def 4,ZFMISC_1:95;
    hence IT is Subset of FinSeq-Locations by ZFMISC_1:99;
    take UIL;
    hereby
      let i be Instruction of SCM+FSA;
      P[i,UIL.i] by A2;
      hence UIL.i = UsedInt*Loc i;
    end;
    thus thesis;
  end;
  uniqueness
  proof
    let IT1, IT2 be Subset of FinSeq-Locations;
    given UIL1 being Function of the Instructions of SCM+FSA, Fin
    FinSeq-Locations such that
A3: for i being Instruction of SCM+FSA holds UIL1.i = UsedInt*Loc i and
A4: IT1 = Union (UIL1 * p);
    given UIL2 being Function of the Instructions of SCM+FSA, Fin
    FinSeq-Locations such that
A5: for i being Instruction of SCM+FSA holds UIL2.i = UsedInt*Loc i and
A6: IT2 = Union (UIL2 * p);
    for c be Element of the Instructions of SCM+FSA holds UIL1.c = UIL2.c
    proof
      let c be Element of the Instructions of SCM+FSA;
      reconsider d = c as Instruction of SCM+FSA;
      thus UIL1.c = UsedInt*Loc d by A3
        .= UIL2.c by A5;
    end;
    hence thesis by A4,A6,FUNCT_2:113;
  end;
end;

registration
  let p be preProgram of SCM+FSA;
  cluster UsedInt*Loc p -> finite;
  coherence
  proof
    reconsider dp = dom p as finite set;
    consider UIL being Function of the Instructions of SCM+FSA, Fin
    FinSeq-Locations such that
    for i being Instruction of SCM+FSA holds UIL.i = UsedInt*Loc i and
A1: UsedInt*Loc p = Union (UIL * p) by Def4;
    rng p c= the Instructions of SCM+FSA by RELAT_1:def 19;
    then reconsider p9 = p as Function of dp, the Instructions of SCM+FSA by
FUNCT_2:4;
    reconsider Up = UIL * p9 as Function of dp, Fin FinSeq-Locations;
    Union Up is finite;
    hence thesis by A1;
  end;
end;

theorem Th39:
  i in rng p implies UsedInt*Loc i c= UsedInt*Loc p
proof
  assume i in rng p;
  then consider x being set such that
A1: x in dom p & i = p.x by FUNCT_1:def 5;
  consider UIL being Function of the Instructions of SCM+FSA, Fin
  FinSeq-Locations such that
A2: for i being Instruction of SCM+FSA holds UIL.i = UsedInt*Loc i and
A3: UsedInt*Loc p = Union (UIL * p) by Def4;
A4: UsedInt*Loc p = union rng (UIL * p) by A3,CARD_3:def 4;
  dom UIL = the Instructions of SCM+FSA by FUNCT_2:def 1;
  then x in dom (UIL * p) by A1,FUNCT_1:21;
  then
A5: (UIL * p).x in rng (UIL * p) by FUNCT_1:def 5;
  (UIL * p).x = UIL.i by A1,FUNCT_1:23
    .= UsedInt*Loc i by A2;
  hence thesis by A5,A4,ZFMISC_1:92;
end;

theorem
  UsedInt*Loc (p +* r) c= (UsedInt*Loc p) \/ (UsedInt*Loc r)
proof
  consider UIL being Function of the Instructions of SCM+FSA, Fin
  FinSeq-Locations such that
A1: for i being Instruction of SCM+FSA holds UIL.i = UsedInt*Loc i and
A2: UsedInt*Loc (p +* r) = Union (UIL * (p +* r)) by Def4;
  consider UIL1 being Function of the Instructions of SCM+FSA, Fin
  FinSeq-Locations such that
A3: for i being Instruction of SCM+FSA holds UIL1.i = UsedInt*Loc i and
A4: UsedInt*Loc p = Union (UIL1 * p) by Def4;
  for c be Element of the Instructions of SCM+FSA holds UIL.c = UIL1.c
  proof
    let c be Element of the Instructions of SCM+FSA;
    reconsider d = c as Instruction of SCM+FSA;
    thus UIL.c = UsedInt*Loc d by A1
      .= UIL1.c by A3;
  end;
  then
A5: UIL=UIL1 by FUNCT_2:113;
  consider UIL2 being Function of the Instructions of SCM+FSA, Fin
  FinSeq-Locations such that
A6: for i being Instruction of SCM+FSA holds UIL2.i = UsedInt*Loc i and
A7: UsedInt*Loc r = Union (UIL2 * r) by Def4;
  for c be Element of the Instructions of SCM+FSA holds UIL.c = UIL2.c
  proof
    let c be Element of the Instructions of SCM+FSA;
    reconsider d = c as Instruction of SCM+FSA;
    thus UIL.c = UsedInt*Loc d by A1
      .= UIL2.c by A6;
  end;
  then
A8: UIL=UIL2 by FUNCT_2:113;
  dom UIL = the Instructions of SCM+FSA by FUNCT_2:def 1;
  then rng r c= dom UIL by RELAT_1:def 19;
  then UIL * (p +* r) = (UIL * p) +* (UIL * r) by FUNCT_7:10;
  then
A9: Union (UIL * r) = union rng (UIL * r) & union rng (UIL * (p +* r)) c=
  union (rng (UIL * p) \/ rng (UIL * r)) by CARD_3:def 4,FUNCT_4:18,ZFMISC_1:95
;
  Union (UIL * (p +* r)) = union rng (UIL * (p +* r)) & Union (UIL * p) =
  union rng (UIL * p) by CARD_3:def 4;
  hence thesis by A2,A4,A7,A5,A8,A9,ZFMISC_1:96;
end;

theorem Th41:
  dom p misses dom r implies UsedInt*Loc (p +* r) = (UsedInt*Loc p
  ) \/ (UsedInt*Loc r)
proof
  consider UIL being Function of the Instructions of SCM+FSA, Fin
  FinSeq-Locations such that
A1: for i being Instruction of SCM+FSA holds UIL.i = UsedInt*Loc i and
A2: UsedInt*Loc (p +* r) = Union (UIL * (p +* r)) by Def4;
  assume dom p misses dom r;
  then dom (UIL * p) c= dom p & dom p misses dom (UIL * r) by RELAT_1:44
,XBOOLE_1:63;
  then
A3: (UIL * p) +* (UIL * r) = (UIL * p) \/ (UIL * r) by FUNCT_4:32,XBOOLE_1:63;
  dom UIL = the Instructions of SCM+FSA by FUNCT_2:def 1;
  then rng r c= dom UIL by RELAT_1:def 19;
  then UIL * (p +* r) = (UIL * p) +* (UIL * r) by FUNCT_7:10;
  then
A4: Union (UIL * r) = union rng (UIL * r) & union rng (UIL * (p +* r)) =
  union ( rng (UIL * p) \/ rng (UIL * r)) by A3,CARD_3:def 4,RELAT_1:26;
  consider UIL1 being Function of the Instructions of SCM+FSA, Fin
  FinSeq-Locations such that
A5: for i being Instruction of SCM+FSA holds UIL1.i = UsedInt*Loc i and
A6: UsedInt*Loc p = Union (UIL1 * p) by Def4;
  for c be Element of the Instructions of SCM+FSA holds UIL.c = UIL1.c
  proof
    let c be Element of the Instructions of SCM+FSA;
    reconsider d = c as Instruction of SCM+FSA;
    thus UIL.c = UsedInt*Loc d by A1
      .= UIL1.c by A5;
  end;
  then
A7: UIL=UIL1 by FUNCT_2:113;
  consider UIL2 being Function of the Instructions of SCM+FSA, Fin
  FinSeq-Locations such that
A8: for i being Instruction of SCM+FSA holds UIL2.i = UsedInt*Loc i and
A9: UsedInt*Loc r = Union (UIL2 * r) by Def4;
  for c be Element of the Instructions of SCM+FSA holds UIL.c = UIL2.c
  proof
    let c be Element of the Instructions of SCM+FSA;
    reconsider d = c as Instruction of SCM+FSA;
    thus UIL.c = UsedInt*Loc d by A1
      .= UIL2.c by A8;
  end;
  then
A10: UIL=UIL2 by FUNCT_2:113;
  Union (UIL * (p +* r)) = union rng (UIL * (p +* r)) & Union (UIL * p) =
  union rng (UIL * p) by CARD_3:def 4;
  hence thesis by A2,A6,A9,A7,A10,A4,ZFMISC_1:96;
end;

theorem Th42:
  UsedInt*Loc p = UsedInt*Loc Shift(p, k)
proof
  set Sp = Shift (p, k);
  consider UIL being Function of the Instructions of SCM+FSA, Fin
  FinSeq-Locations such that
A1: for i being Instruction of SCM+FSA holds UIL.i = UsedInt*Loc i and
A2: UsedInt*Loc p = Union (UIL * p) by Def4;
  consider UIL2 being Function of the Instructions of SCM+FSA, Fin
  FinSeq-Locations such that
A3: for i being Instruction of SCM+FSA holds UIL2.i = UsedInt*Loc i and
A4: UsedInt*Loc Shift (p, k) = Union (UIL2 * Shift (p, k)) by Def4;
  for c be Element of the Instructions of SCM+FSA holds UIL.c = UIL2.c
  proof
    let c be Element of the Instructions of SCM+FSA;
    reconsider d = c as Instruction of SCM+FSA;
    thus UIL.c = UsedInt*Loc d by A1
      .= UIL2.c by A3;
  end;
  then
A5: UIL=UIL2 by FUNCT_2:113;
A6: dom Sp = { m+k where m is Element of NAT : m in dom p } by VALUED_1:def 12;
  now
    let y be set;
    hereby
      assume y in rng Sp;
      then consider x being set such that
A7:   x in dom Sp and
A8:   y = Sp.x by FUNCT_1:def 5;
      consider m being Element of NAT such that
A9:   x = m+k and
A10:  m in dom p by A6,A7;
      Sp.x = p. m by A9,A10,VALUED_1:def 12;
      hence y in rng p by A8,A10,FUNCT_1:def 5;
    end;
    assume y in rng p;
    then consider x being set such that
A11: x in dom p and
A12: y = p.x by FUNCT_1:def 5;
    dom p c= NAT by RELAT_1:def 18;
    then reconsider x9 = x as Element of NAT by A11;
    reconsider m = x9 as Element of NAT;
     (m+k) in dom Sp & Sp. (m+k) = p. m by A6,A11,VALUED_1:def 12;
    hence y in rng Sp by A12,FUNCT_1:def 5;
  end;
  then
A13: rng Sp = rng p by TARSKI:2;
A14: Union (UIL * Sp) = union rng (UIL * Sp) by CARD_3:def 4;
  rng (UIL * Sp) = UIL.:rng Sp by RELAT_1:160
    .= rng (UIL * p) by A13,RELAT_1:160;
  hence thesis by A2,A4,A5,A14,CARD_3:def 4;
end;

theorem Th43:
  UsedInt*Loc i = UsedInt*Loc IncAddr(i, k)
proof
A1: InsCode i <= 11+1 by SCMFSA_2:35;
A2: InsCode i <= 10+1 implies InsCode i <= 10 or InsCode i = 11 by NAT_1:8;
A3: InsCode i <= 9+1 implies InsCode i <= 8+1 or InsCode i = 10 by NAT_1:8;
  per cases by A1,A2,A3,NAT_1:8,33;
  suppose
    InsCode i = 0;
    then i = halt SCM+FSA by SCMFSA_2:122;
    hence thesis by SCMFSA_4:8;
  end;
  suppose
    InsCode i = 1;
    then ex a, b st i = a:=b by SCMFSA_2:54;
    hence thesis by SCMFSA_4:9;
  end;
  suppose
    InsCode i = 2;
    then ex a, b st i = AddTo(a,b) by SCMFSA_2:55;
    hence thesis by SCMFSA_4:10;
  end;
  suppose
    InsCode i = 3;
    then ex a, b st i = SubFrom(a, b) by SCMFSA_2:56;
    hence thesis by SCMFSA_4:11;
  end;
  suppose
    InsCode i = 4;
    then ex a, b st i = MultBy(a, b) by SCMFSA_2:57;
    hence thesis by SCMFSA_4:12;
  end;
  suppose
    InsCode i = 5;
    then ex a, b st i = Divide(a, b) by SCMFSA_2:58;
    hence thesis by SCMFSA_4:13;
  end;
  suppose
    InsCode i = 6;
    then consider l such that
A4: i = goto l by SCMFSA_2:59;
    IncAddr(i, k) = goto (l+k) by A4,SCMFSA_4:14;
    hence UsedInt*Loc IncAddr(i, k) = {} by Th36
      .= UsedInt*Loc i by A4,Th36;
  end;
  suppose
    InsCode i = 7;
    then consider l, a such that
A5: i = a=0_goto l by SCMFSA_2:60;
    IncAddr(i, k) = a=0_goto (l+k) by A5,SCMFSA_4:15;
    hence UsedInt*Loc IncAddr(i, k) = {} by Th36
      .= UsedInt*Loc i by A5,Th36;
  end;
  suppose
    InsCode i = 8;
    then consider l, a such that
A6: i = a>0_goto l by SCMFSA_2:61;
    IncAddr(i, k) = a>0_goto (l+k) by A6,SCMFSA_4:16;
    hence UsedInt*Loc IncAddr(i, k) = {} by Th36
      .= UsedInt*Loc i by A6,Th36;
  end;
  suppose
    InsCode i = 9;
    then ex a, b, f st i = b:=(f,a) by SCMFSA_2:62;
    hence thesis by SCMFSA_4:17;
  end;
  suppose
    InsCode i = 10;
    then ex a, b, f st i = (f,a):=b by SCMFSA_2:63;
    hence thesis by SCMFSA_4:18;
  end;
  suppose
    InsCode i = 11;
    then ex a, f st i = a:=len f by SCMFSA_2:64;
    hence thesis by SCMFSA_4:19;
  end;
  suppose
    InsCode i = 12;
    then ex a,f st i = f:=<0,...,0>a by SCMFSA_2:65;
    hence thesis by SCMFSA_4:20;
  end;
end;

theorem Th44:
  UsedInt*Loc p = UsedInt*Loc IncAddr(p, k)
proof
  set Ip = IncAddr (p, k);
  consider UIL being Function of the Instructions of SCM+FSA, Fin
  FinSeq-Locations such that
A1: for i being Instruction of SCM+FSA holds UIL.i = UsedInt*Loc i and
A2: UsedInt*Loc p = Union (UIL * p) by Def4;
  set g = UIL * p;
  set f = UIL * Ip;
  consider UIL2 being Function of the Instructions of SCM+FSA, Fin
  FinSeq-Locations such that
A3: for i being Instruction of SCM+FSA holds UIL2.i = UsedInt*Loc i and
A4: UsedInt*Loc IncAddr (p, k) = Union (UIL2 * IncAddr (p, k)) by Def4;
  for c be Element of the Instructions of SCM+FSA holds UIL.c = UIL2.c
  proof
    let c be Element of the Instructions of SCM+FSA;
    reconsider d = c as Instruction of SCM+FSA;
    thus UIL.c = UsedInt*Loc d by A1
      .= UIL2.c by A3;
  end;
  then
A5: UIL=UIL2 by FUNCT_2:113;
  now
A6: dom UIL = the Instructions of SCM+FSA by FUNCT_2:def 1;
    then
A7: rng p c= dom UIL by RELAT_1:def 19;
A8: rng Ip c= dom UIL by A6,RELAT_1:def 19;
    then
A9: dom f = dom Ip by RELAT_1:46;
A10: dom Ip = dom p by COMPOS_1:def 40;
    hence dom f = dom g by A7,A9,RELAT_1:46;
    let x be set;
    assume
A11: x in dom f;
    then p.x in rng p by A10,A9,FUNCT_1:def 5;
    then reconsider px = p.x as Instruction of SCM+FSA by A7,FUNCT_2:def 1;
    dom p c= NAT by RELAT_1:def 18;
    then reconsider x9 = x as Element of NAT by A10,A9,A11;
    reconsider m = x9 as Element of NAT;
A12: Ip.x = IncAddr(p/.m,k) by A10,A9,A11,COMPOS_1:def 40
      .= IncAddr(px, k) by A10,A9,A11,PARTFUN1:def 8;
    Ip.x in rng Ip by A9,A11,FUNCT_1:def 5;
    then reconsider Ipx = Ip.x as Instruction of SCM+FSA by A8,FUNCT_2:def 1;
    thus f.x = UIL.Ipx by A11,FUNCT_1:22
      .= UsedInt*Loc Ipx by A1
      .= UsedInt*Loc px by A12,Th43
      .= UIL.px by A3,A5
      .= g.x by A10,A9,A11,FUNCT_1:23;
  end;
  hence thesis by A2,A4,A5,FUNCT_1:9;
end;

theorem Th45:
  UsedInt*Loc I = UsedInt*Loc ProgramPart Relocated (I, k)
proof
  UsedInt*Loc ProgramPart Relocated (I, k) = UsedInt*Loc Reloc(
  ProgramPart(I),k) by COMPOS_1:116
    .= UsedInt*Loc Shift (ProgramPart I, k) by Th44
    .= UsedInt*Loc ProgramPart I by Th42;
  hence thesis by RELAT_1:209;
end;

theorem Th46:
  UsedInt*Loc I = UsedInt*Loc Directed I
proof
  consider UIL being Function of the Instructions of SCM+FSA, Fin
  FinSeq-Locations such that
A1: for i being Instruction of SCM+FSA holds UIL.i = UsedInt*Loc i and
A2: UsedInt*Loc I = Union (UIL * I) by Def4;
A3: UIL.halt SCM+FSA = UsedInt*Loc halt SCM+FSA by A1
    .= {} by Th36;
  consider UIL2 being Function of the Instructions of SCM+FSA, Fin
  FinSeq-Locations such that
A4: for i being Instruction of SCM+FSA holds UIL2.i = UsedInt*Loc i and
A5: UsedInt*Loc Directed I = Union (UIL2 * Directed I) by Def4;
A6: for c be Element of the Instructions of SCM+FSA holds UIL.c = UIL2.c
  proof
    let c be Element of the Instructions of SCM+FSA;
    reconsider d = c as Instruction of SCM+FSA;
    thus UIL.c = UsedInt*Loc d by A1
      .= UIL2.c by A4;
  end;
A7: UIL.goto  card I = UsedInt*Loc goto  card I by A1
    .= {} by Th36;
A8: dom UIL = the Instructions of SCM+FSA by FUNCT_2:def 1;
  rng I c= the Instructions of SCM+FSA by RELAT_1:def 19;
  then UIL * Directed I = UIL * (((id the Instructions of SCM+FSA) +* (halt
  SCM+FSA, goto  card I))*I) by FUNCT_7:118
    .= UIL * ((id the Instructions of SCM+FSA) +* (halt SCM+FSA, goto
  card I)) * I by RELAT_1:55
    .= UIL * I by A8,A3,A7,FUNCT_7:110;
  hence thesis by A2,A5,A6,FUNCT_2:113;
end;

theorem Th47:
  UsedInt*Loc (I ';' J) = (UsedInt*Loc I) \/ (UsedInt*Loc J)
proof
  dom I = dom Directed I by FUNCT_4:105;
  then dom (Directed I) misses dom (ProgramPart Relocated(J, card I)) by
SCMFSA6A:16;
  hence UsedInt*Loc (I ';' J) = UsedInt*Loc (Directed I) \/ UsedInt*Loc
  ProgramPart Relocated(J, card I) by Th41
    .= (UsedInt*Loc I) \/ UsedInt*Loc ProgramPart Relocated(J, card I) by Th46
    .= (UsedInt*Loc I) \/ (UsedInt*Loc J) by Th45;
end;

theorem Th48:
  UsedInt*Loc Macro i = UsedInt*Loc i
proof
  consider UIL being Function of the Instructions of SCM+FSA, Fin
  FinSeq-Locations such that
A1: for i being Instruction of SCM+FSA holds UIL.i = UsedInt*Loc i and
A2: UsedInt*Loc Macro i = Union (UIL * Macro i) by Def4;
A3: rng (Macro i) = {i, halt SCM+FSA} & dom UIL = the Instructions of
  SCM+FSA by FUNCT_2:def 1,FUNCT_4:67;
  thus UsedInt*Loc Macro i = union rng (UIL * Macro i) by A2,CARD_3:def 4
    .= union (UIL.:rng Macro i) by RELAT_1:160
    .= union {UIL.i,UIL.halt SCM+FSA} by A3,FUNCT_1:118
    .= UIL.i \/ UIL.halt SCM+FSA by ZFMISC_1:93
    .= (UsedInt*Loc i) \/ UIL.halt SCM+FSA by A1
    .= (UsedInt*Loc i) \/ (UsedInt*Loc halt SCM+FSA) by A1
    .= UsedInt*Loc i \/ {} by Th36
    .= UsedInt*Loc i;
end;

theorem
  UsedInt*Loc (i ';' J) = (UsedInt*Loc i) \/ UsedInt*Loc J
proof
  thus UsedInt*Loc (i ';' J) = (UsedInt*Loc Macro i) \/ UsedInt*Loc J by Th47
    .= (UsedInt*Loc i) \/ UsedInt*Loc J by Th48;
end;

theorem
  UsedInt*Loc (I ';' j) = (UsedInt*Loc I) \/ UsedInt*Loc j
proof
  thus UsedInt*Loc (I ';' j) = (UsedInt*Loc I) \/ UsedInt*Loc Macro j by Th47
    .= (UsedInt*Loc I) \/ UsedInt*Loc j by Th48;
end;

theorem
  UsedInt*Loc (i ';' j) = (UsedInt*Loc i) \/ UsedInt*Loc j
proof
  thus UsedInt*Loc (i ';' j) = (UsedInt*Loc Macro i) \/ UsedInt*Loc Macro j by
Th47
    .= (UsedInt*Loc Macro i) \/ UsedInt*Loc j by Th48
    .= (UsedInt*Loc i) \/ UsedInt*Loc j by Th48;
end;

begin :: Choosing integer location not used in a macro instruction

definition
  let IT be Int-Location;
  attr IT is read-only means
  :Def5:
  IT = intloc 0;
end;

notation
  let IT be Int-Location;
  antonym IT is read-write for IT is read-only;
end;

registration
  cluster intloc 0 -> read-only;
  coherence by Def5;
end;

registration
  cluster read-write Int-Location;
  existence
  proof
    take intloc 1;
    intloc 1 <> intloc 0 by AMI_3:52;
    hence thesis by Def5;
  end;
end;

reserve L for finite Subset of Int-Locations;

definition
  let L be finite Subset of Int-Locations;
  func FirstNotIn L -> Int-Location means
  :Def6:
  ex sn being non empty Subset
of NAT st it = intloc min sn & sn = {k where k is Element of NAT : not intloc k
  in L};
  existence
  proof
    defpred X[Element of NAT] means not intloc $1 in L;
    set sn = {k where k is Element of NAT : X[k]};
A1: sn is Subset of NAT from DOMAIN_1:sch 7;
    not Int-Locations c= L by AMI_3:72;
    then consider x being set such that
A2: x in Int-Locations and
A3: not x in L by TARSKI:def 3;
    reconsider x as Int-Location by A2,SCMFSA_2:11;
    consider k being Element of NAT such that
A4: x = intloc k by SCMFSA_2:19;
    k in sn by A3,A4;
    then reconsider sn as non empty Subset of NAT by A1;
    take intloc min sn, sn;
    thus thesis;
  end;
  uniqueness;
end;

theorem Th52:
  not FirstNotIn L in L
proof
  set FNI = FirstNotIn L;
  consider sn being non empty Subset of NAT such that
A1: FNI = intloc min sn and
A2: sn = {k where k is Element of NAT : not intloc k in L} by Def6;
  min sn in sn by XXREAL_2:def 7;
  then ex k being Element of NAT st k = min sn & not intloc k in L by A2;
  hence thesis by A1;
end;

theorem
  FirstNotIn L = intloc m & not intloc n in L implies m <= n
proof
  consider sn being non empty Subset of NAT such that
A1: FirstNotIn L = intloc min sn & sn = {k where k is Element of NAT :
  not intloc k in L} by Def6;
  assume FirstNotIn L = intloc m & not intloc n in L;
  then m = min sn & n in sn by A1,AMI_3:52;
  hence thesis by XXREAL_2:def 7;
end;

definition
  let p be preProgram of SCM+FSA;
  func FirstNotUsed p -> Int-Location means
  :Def7:
  ex sil being finite Subset
  of Int-Locations st sil = UsedIntLoc p \/ {intloc 0} & it = FirstNotIn sil;
  existence
  proof
    intloc 0 in Int-Locations by SCMFSA_2:def 4;
    then reconsider i0 = {intloc 0} as finite Subset of Int-Locations by
ZFMISC_1:37;
    reconsider sil = UsedIntLoc p \/ i0 as finite Subset of Int-Locations;
    take FirstNotIn sil, sil;
    thus thesis;
  end;
  uniqueness;
end;

registration
  let p be preProgram of SCM+FSA;
  cluster FirstNotUsed p -> read-write;
  coherence
  proof
    consider sil being finite Subset of Int-Locations such that
A1: sil = UsedIntLoc p \/ {intloc 0} and
A2: FirstNotUsed p = FirstNotIn sil by Def7;
    now
      assume FirstNotIn sil = intloc 0;
      then not intloc 0 in sil by Th52;
      hence contradiction by A1,SETWISEO:6;
    end;
    hence thesis by A2,Def5;
  end;
end;

theorem Th54:
  not FirstNotUsed p in UsedIntLoc p
proof
  consider sil being finite Subset of Int-Locations such that
A1: sil = UsedIntLoc p \/ {intloc 0} and
A2: FirstNotUsed p = FirstNotIn sil by Def7;
  not FirstNotUsed p in sil by A2,Th52;
  hence thesis by A1,XBOOLE_0:def 3;
end;

theorem
  a:=b in rng p or AddTo(a, b) in rng p or SubFrom(a, b) in rng p or
  MultBy(a, b) in rng p or Divide(a, b) in rng p implies FirstNotUsed p <> a &
  FirstNotUsed p <> b
proof
  assume a:=b in rng p or AddTo(a, b) in rng p or SubFrom(a, b) in rng p or
  MultBy(a, b) in rng p or Divide(a, b) in rng p;
  then consider i being Instruction of SCM+FSA such that
A1: i in rng p and
A2: i = a:=b or i = AddTo(a, b) or i = SubFrom(a, b) or i = MultBy(a, b
  ) or i = Divide(a, b);
  UsedIntLoc i = {a, b} by A2,Th18;
  then
A3: {a, b} c= UsedIntLoc p by A1,Th23;
  not FirstNotUsed p in UsedIntLoc p by Th54;
  hence thesis by A3,ZFMISC_1:38;
end;

theorem
  a=0_goto l in rng p or a>0_goto l in rng p implies FirstNotUsed p <> a
proof
  assume a=0_goto l in rng p or a>0_goto l in rng p;
  then consider i being Instruction of SCM+FSA such that
A1: i in rng p and
A2: i = a=0_goto l or i = a>0_goto l;
  UsedIntLoc i = {a} by A2,Th20;
  then
A3: {a} c= UsedIntLoc p by A1,Th23;
  not FirstNotUsed p in UsedIntLoc p by Th54;
  hence thesis by A3,ZFMISC_1:37;
end;

theorem
  b := (f, a) in rng p or (f, a) := b in rng p implies FirstNotUsed p <>
  a & FirstNotUsed p <> b
proof
  assume b := (f, a) in rng p or (f, a) := b in rng p;
  then consider i being Instruction of SCM+FSA such that
A1: i in rng p and
A2: i = b := (f, a) or i = (f, a) := b;
  UsedIntLoc i = {a, b} by A2,Th21;
  then
A3: {a, b} c= UsedIntLoc p by A1,Th23;
  not FirstNotUsed p in UsedIntLoc p by Th54;
  hence thesis by A3,ZFMISC_1:38;
end;

theorem
  a :=len f in rng p or f :=<0,...,0>a in rng p implies FirstNotUsed p
  <> a
proof
  assume a :=len f in rng p or f :=<0,...,0>a in rng p;
  then consider i being Instruction of SCM+FSA such that
A1: i in rng p and
A2: i = a :=len f or i = f :=<0,...,0>a;
  UsedIntLoc i = {a} by A2,Th22;
  then
A3: {a} c= UsedIntLoc p by A1,Th23;
  not FirstNotUsed p in UsedIntLoc p by Th54;
  hence thesis by A3,ZFMISC_1:37;
end;

begin :: Choosing finite sequence location not used in a macro instruction

reserve L for finite Subset of FinSeq-Locations;

definition
  let L be finite Subset of FinSeq-Locations;
  func First*NotIn L -> FinSeq-Location means
  :Def8:
  ex sn being non empty
  Subset of NAT st it = fsloc min sn & sn = {k where k is Element of NAT : not
  fsloc k in L};
  existence
  proof
    defpred X[Element of NAT] means not fsloc $1 in L;
    set sn = {k where k is Element of NAT : X[k]};
A1: sn is Subset of NAT from DOMAIN_1:sch 7;
    not FinSeq-Locations c= L by SCMFSA_2:23;
    then consider x being set such that
A2: x in FinSeq-Locations and
A3: not x in L by TARSKI:def 3;
    reconsider x as FinSeq-Location by A2,SCMFSA_2:12;
    consider k being Element of NAT such that
A4: x = fsloc k by SCMFSA_2:20;
    k in sn by A3,A4;
    then reconsider sn as non empty Subset of NAT by A1;
    take fsloc min sn, sn;
    thus thesis;
  end;
  uniqueness;
end;

theorem Th59:
  not First*NotIn L in L
proof
  set FNI = First*NotIn L;
  consider sn being non empty Subset of NAT such that
A1: FNI = fsloc min sn and
A2: sn = {k where k is Element of NAT : not fsloc k in L} by Def8;
  min sn in sn by XXREAL_2:def 7;
  then ex k being Element of NAT st k = min sn & not fsloc k in L by A2;
  hence thesis by A1;
end;

theorem
  First*NotIn L = fsloc m & not fsloc n in L implies m <= n
proof
  assume that
A1: First*NotIn L = fsloc m and
A2: not fsloc n in L;
  consider sn being non empty Subset of NAT such that
A3: First*NotIn L = fsloc min sn and
A4: sn = {k where k is Element of NAT : not fsloc k in L} by Def8;
  n in sn by A2,A4;
  hence thesis by A1,A3,XXREAL_2:def 7;
end;

definition
  let p be preProgram of SCM+FSA;
  func First*NotUsed p -> FinSeq-Location means
  :Def9:
  ex sil being finite
  Subset of FinSeq-Locations st sil = UsedInt*Loc p & it = First*NotIn sil;
  existence
  proof
    take First*NotIn UsedInt*Loc p, UsedInt*Loc p;
    thus thesis;
  end;
  uniqueness;
end;

theorem Th61:
  not First*NotUsed p in UsedInt*Loc p
proof
  ex sil being finite Subset of FinSeq-Locations st sil = UsedInt*Loc p &
  First*NotUsed p = First*NotIn sil by Def9;
  hence thesis by Th59;
end;

theorem
  b := (f, a) in rng p or (f, a) := b in rng p implies First*NotUsed p
  <> f
proof
  assume b := (f, a) in rng p or (f, a) := b in rng p;
  then consider i being Instruction of SCM+FSA such that
A1: i in rng p and
A2: i = b := (f, a) or i = (f, a) := b;
  UsedInt*Loc i = {f} by A2,Th37;
  then
A3: {f} c= UsedInt*Loc p by A1,Th39;
  not First*NotUsed p in UsedInt*Loc p by Th61;
  hence thesis by A3,ZFMISC_1:37;
end;

theorem
  a :=len f in rng p or f :=<0,...,0>a in rng p implies First*NotUsed p
  <> f
proof
  assume a :=len f in rng p or f :=<0,...,0>a in rng p;
  then consider i being Instruction of SCM+FSA such that
A1: i in rng p and
A2: i = a :=len f or i = f :=<0,...,0>a;
  UsedInt*Loc i = {f} by A2,Th38;
  then
A3: {f} c= UsedInt*Loc p by A1,Th39;
  not First*NotUsed p in UsedInt*Loc p by Th61;
  hence thesis by A3,ZFMISC_1:37;
end;

begin :: Semantics

reserve s, t for State of SCM+FSA;

canceled 4;

theorem Th68:
  not c in UsedIntLoc i implies Exec(i, s).c = s.c
proof
  assume
A1: not c in UsedIntLoc i;
A2: InsCode i <= 9+1 implies InsCode i <= 8+1 or InsCode i = 10 by NAT_1:8;
A3: InsCode i <= 10+1 implies InsCode i <= 10 or InsCode i = 11 by NAT_1:8;
A4: InsCode i <= 11+1 by SCMFSA_2:35;
  per cases by A4,A3,A2,NAT_1:8,33;
  suppose
    InsCode i = 0;
    then i = halt SCM+FSA by SCMFSA_2:122;
    hence thesis by EXTPRO_1:def 3;
  end;
  suppose
    InsCode i = 1;
    then consider a, b such that
A5: i = a:=b by SCMFSA_2:54;
    UsedIntLoc i = {a, b} by A5,Th18;
    then c <> a by A1,TARSKI:def 2;
    hence thesis by A5,SCMFSA_2:89;
  end;
  suppose
    InsCode i = 2;
    then consider a, b such that
A6: i = AddTo(a,b) by SCMFSA_2:55;
    UsedIntLoc i = {a, b} by A6,Th18;
    then c <> a by A1,TARSKI:def 2;
    hence thesis by A6,SCMFSA_2:90;
  end;
  suppose
    InsCode i = 3;
    then consider a, b such that
A7: i = SubFrom(a, b) by SCMFSA_2:56;
    UsedIntLoc i = {a, b} by A7,Th18;
    then c <> a by A1,TARSKI:def 2;
    hence thesis by A7,SCMFSA_2:91;
  end;
  suppose
    InsCode i = 4;
    then consider a, b such that
A8: i = MultBy(a, b) by SCMFSA_2:57;
    UsedIntLoc i = {a, b} by A8,Th18;
    then c <> a by A1,TARSKI:def 2;
    hence thesis by A8,SCMFSA_2:92;
  end;
  suppose
    InsCode i = 5;
    then consider a, b such that
A9: i = Divide(a, b) by SCMFSA_2:58;
    UsedIntLoc i = {a, b} by A9,Th18;
    then c <> a & c <> b by A1,TARSKI:def 2;
    hence thesis by A9,SCMFSA_2:93;
  end;
  suppose
    InsCode i = 6;
    then ex l st i = goto l by SCMFSA_2:59;
    hence thesis by SCMFSA_2:95;
  end;
  suppose
    InsCode i = 7;
    then ex l, a st i = a=0_goto l by SCMFSA_2:60;
    hence thesis by SCMFSA_2:96;
  end;
  suppose
    InsCode i = 8;
    then ex l, a st i = a>0_goto l by SCMFSA_2:61;
    hence thesis by SCMFSA_2:97;
  end;
  suppose
    InsCode i = 9;
    then consider a, b, f such that
A10: i = b:=(f,a) by SCMFSA_2:62;
    UsedIntLoc i = {a, b} by A10,Th21;
    then c <> b by A1,TARSKI:def 2;
    hence thesis by A10,SCMFSA_2:98;
  end;
  suppose
    InsCode i = 10;
    then ex a, b, f st i = (f,a):=b by SCMFSA_2:63;
    hence thesis by SCMFSA_2:99;
  end;
  suppose
    InsCode i = 11;
    then consider a, f such that
A11: i = a:=len f by SCMFSA_2:64;
    UsedIntLoc i = {a} by A11,Th22;
    then c <> a by A1,TARSKI:def 1;
    hence thesis by A11,SCMFSA_2:100;
  end;
  suppose
    InsCode i = 12;
    then ex a,f st i = f:=<0,...,0>a by SCMFSA_2:65;
    hence thesis by SCMFSA_2:101;
  end;
end;

theorem
  I+*Start-At( 0,SCM+FSA) c= s & (for m st m < n
   holds IC Comput(ProgramPart(s),s,m)
  in dom I) & not a in UsedIntLoc I implies Comput(ProgramPart(s),s,n).a = s.a
proof
  assume that
A1: I+*Start-At( 0,SCM+FSA) c= s and
A2: for m st m < n holds IC Comput(ProgramPart(s),s,m) in dom I and
A3: not a in UsedIntLoc I;
  defpred X[Nat] means $1 <= n implies Comput(ProgramPart(s),s,$1).a = s.a;
A4: for m st X[m] holds X[m+1]
  proof
    let m;
    set sm = Comput(ProgramPart(s),s,m);
    assume
A5: m <= n implies sm.a = s.a;
    assume
A6: m+1 <= n;
    then m < n by NAT_1:13;
    then
A7: IC sm in dom I by A2;
    then
A8: I.IC sm in rng I by FUNCT_1:def 5;
Y:  (ProgramPart sm)/.IC sm
 = sm.IC sm by COMPOS_1:38;
    dom I misses dom Start-At( 0,SCM+FSA) by COMPOS_1:140;
    then I c= I+*Start-At( 0,SCM+FSA) by FUNCT_4:33;
    then I c= s by A1,XBOOLE_1:1;
    then I c= sm by AMI_1:81;
    then I.IC sm = sm.IC sm by A7,GRFUNC_1:8;
    then UsedIntLoc sm.IC sm c= UsedIntLoc I by A8,Th23;
    then
A9: not a in UsedIntLoc sm.IC sm by A3;
T: ProgramPart s = ProgramPart sm
by AMI_1:123;
    thus Comput(ProgramPart(s),s,m+1).a = (Following(ProgramPart s,sm)).a by
EXTPRO_1:4
      .= s.a by A5,A6,A9,Th68,Y,T,NAT_1:13;
  end;
A10: X[0] by EXTPRO_1:3;
  for m holds X[m] from NAT_1:sch 1(A10, A4);
  hence thesis;
end;

theorem Th70:
  not f in UsedInt*Loc i implies Exec(i, s).f = s.f
proof
  assume
A1: not f in UsedInt*Loc i;
A2: InsCode i <= 9+1 implies InsCode i <= 8+1 or InsCode i = 10 by NAT_1:8;
A3: InsCode i <= 10+1 implies InsCode i <= 10 or InsCode i = 11 by NAT_1:8;
A4: InsCode i <= 11+1 by SCMFSA_2:35;
  per cases by A4,A3,A2,NAT_1:8,33;
  suppose
    InsCode i = 0;
    then i = halt SCM+FSA by SCMFSA_2:122;
    hence thesis by EXTPRO_1:def 3;
  end;
  suppose
    InsCode i = 1;
    then ex a, b st i = a:=b by SCMFSA_2:54;
    hence thesis by SCMFSA_2:89;
  end;
  suppose
    InsCode i = 2;
    then ex a, b st i = AddTo(a,b) by SCMFSA_2:55;
    hence thesis by SCMFSA_2:90;
  end;
  suppose
    InsCode i = 3;
    then ex a, b st i = SubFrom(a, b) by SCMFSA_2:56;
    hence thesis by SCMFSA_2:91;
  end;
  suppose
    InsCode i = 4;
    then ex a, b st i = MultBy(a, b) by SCMFSA_2:57;
    hence thesis by SCMFSA_2:92;
  end;
  suppose
    InsCode i = 5;
    then ex a, b st i = Divide(a, b) by SCMFSA_2:58;
    hence thesis by SCMFSA_2:93;
  end;
  suppose
    InsCode i = 6;
    then ex l st i = goto l by SCMFSA_2:59;
    hence thesis by SCMFSA_2:95;
  end;
  suppose
    InsCode i = 7;
    then ex l, a st i = a=0_goto l by SCMFSA_2:60;
    hence thesis by SCMFSA_2:96;
  end;
  suppose
    InsCode i = 8;
    then ex l, a st i = a>0_goto l by SCMFSA_2:61;
    hence thesis by SCMFSA_2:97;
  end;
  suppose
    InsCode i = 9;
    then ex a, b, g st i = b:=(g,a) by SCMFSA_2:62;
    hence thesis by SCMFSA_2:98;
  end;
  suppose
    InsCode i = 10;
    then consider a, b, g such that
A5: i = (g,a):=b by SCMFSA_2:63;
    UsedInt*Loc i = {g} by A5,Th37;
    then f <> g by A1,TARSKI:def 1;
    hence thesis by A5,SCMFSA_2:99;
  end;
  suppose
    InsCode i = 11;
    then ex a, g st i = a:=len g by SCMFSA_2:64;
    hence thesis by SCMFSA_2:100;
  end;
  suppose
    InsCode i = 12;
    then consider a,g such that
A6: i = g:=<0,...,0>a by SCMFSA_2:65;
    UsedInt*Loc i = {g} by A6,Th38;
    then f <> g by A1,TARSKI:def 1;
    hence thesis by A6,SCMFSA_2:101;
  end;
end;

theorem
  I+*Start-At( 0,SCM+FSA) c= s & (for m st m < n
   holds IC Comput(ProgramPart(s),s,m)
  in dom I) & not f in UsedInt*Loc I implies Comput(ProgramPart(s),s,n).f = s.f
proof
  assume that
A1: I+*Start-At( 0,SCM+FSA) c= s and
A2: for m st m < n holds IC Comput(ProgramPart(s),s,m) in dom I and
A3: not f in UsedInt*Loc I;
  defpred X[Nat] means $1 <= n implies Comput(ProgramPart(s),s,$1).f = s.f;
A4: for m st X[m] holds X[m+1]
  proof
    let m;
    set sm = Comput(ProgramPart(s),s,m);
    assume
A5: m <= n implies sm.f = s.f;
    assume
A6: m+1 <= n;
    then m < n by NAT_1:13;
    then
A7: IC sm in dom I by A2;
    then
A8: I.IC sm in rng I by FUNCT_1:def 5;
Y:  (ProgramPart sm)/.IC sm
 = sm.IC sm by COMPOS_1:38;
    dom I misses dom Start-At( 0,SCM+FSA) by COMPOS_1:140;
    then I c= I+*Start-At( 0,SCM+FSA) by FUNCT_4:33;
    then I c= s by A1,XBOOLE_1:1;
    then I c= sm by AMI_1:81;
    then I.IC sm = sm.IC sm by A7,GRFUNC_1:8;
    then UsedInt*Loc sm.IC sm c= UsedInt*Loc I by A8,Th39;
    then
A9: not f in UsedInt*Loc sm.IC sm by A3;
T: ProgramPart s = ProgramPart sm
by AMI_1:123;
    thus Comput(ProgramPart(s),s,m+1).f = (Following(ProgramPart s,sm)).f by
EXTPRO_1:4
      .= s.f by A5,A6,A9,Th70,Y,T,NAT_1:13;
  end;
A10: X[0] by EXTPRO_1:3;
  for m holds X[m] from NAT_1:sch 1(A10, A4);
  hence thesis;
end;

theorem Th72:
  s | UsedIntLoc i = t | UsedIntLoc i & s | UsedInt*Loc i = t |
UsedInt*Loc i & IC s = IC t implies IC Exec(i, s) = IC Exec(i, t) & Exec(i, s)
| UsedIntLoc i = Exec(i, t) | UsedIntLoc i & Exec(i, s) | UsedInt*Loc i = Exec(
  i, t) | UsedInt*Loc i
proof
  assume that
A1: s | UsedIntLoc i = t | UsedIntLoc i and
A2: s | UsedInt*Loc i = t | UsedInt*Loc i and
A3: IC s = IC t;
  set UFi = UsedInt*Loc i;
  set Ui = UsedIntLoc i;
  set Et = Exec(i, t);
  set Es = Exec(i, s);
A4: dom Es = the carrier of SCM+FSA by PARTFUN1:def 4
    .= dom Et by PARTFUN1:def 4;
A5: InsCode i <= 9+1 implies InsCode i <= 8+1 or InsCode i = 10 by NAT_1:8;
A6: InsCode i <= 10+1 implies InsCode i <= 10 or InsCode i = 11 by NAT_1:8;
A7: InsCode i <= 11+1 by SCMFSA_2:35;
  per cases by A7,A6,A5,NAT_1:8,33;
  suppose
    InsCode i = 0;
    then
A8: i = halt SCM+FSA by SCMFSA_2:122;
    then Exec(i, s) = s by EXTPRO_1:def 3;
    hence thesis by A1,A2,A3,A8,EXTPRO_1:def 3;
  end;
  suppose
    InsCode i = 1;
    then consider a, b such that
A9: i = a:=b by SCMFSA_2:54;
A10: Ui = {a, b} by A9,Th18;
    then
A11: b in Ui by TARSKI:def 2;
    then s.b = (s | Ui).b by FUNCT_1:72;
    then
A12: s.b = t.b by A1,A11,FUNCT_1:72;
    thus IC Es = succ IC t by A3,A9,SCMFSA_2:89
      .= IC Et by A9,SCMFSA_2:89;
    a = b or a <> b;
    then
A13: Es.b = s.b & Et.b = t.b by A9,SCMFSA_2:89;
    Es.a = s.b & Et.a = t.b by A9,SCMFSA_2:89;
    hence Es | Ui = Et | Ui by A4,A10,A12,A13,GRFUNC_1:91;
A14: UFi = {} by A9,Th36;
    hence Es | UFi = {} by RELAT_1:110
      .= Et | UFi by A14,RELAT_1:110;
  end;
  suppose
    InsCode i = 2;
    then consider a, b such that
A15: i = AddTo(a,b) by SCMFSA_2:55;
    thus IC Es = succ IC t by A3,A15,SCMFSA_2:90
      .= IC Et by A15,SCMFSA_2:90;
A16: Ui = {a, b} by A15,Th18;
    then
A17: a in Ui by TARSKI:def 2;
    then s.a = (s | Ui).a by FUNCT_1:72;
    then
A18: s.a = t.a by A1,A17,FUNCT_1:72;
A19: now
      per cases;
      case
        a = b;
        hence Es.b = s.a + s.b & Et.b = t.a + t.b by A15,SCMFSA_2:90;
      end;
      case
        a<> b;
        hence Es.b = s.b & Et.b = t.b by A15,SCMFSA_2:90;
      end;
    end;
A20: b in Ui by A16,TARSKI:def 2;
    then s.b = (s | Ui).b by FUNCT_1:72;
    then
A21: s.b = t.b by A1,A20,FUNCT_1:72;
    Es.a = s.a + s.b & Et.a = t.a + t.b by A15,SCMFSA_2:90;
    hence Es | Ui = Et | Ui by A4,A16,A18,A21,A19,GRFUNC_1:91;
A22: UFi = {} by A15,Th36;
    hence Es | UFi = {} by RELAT_1:110
      .= Et | UFi by A22,RELAT_1:110;
  end;
  suppose
    InsCode i = 3;
    then consider a, b such that
A23: i = SubFrom(a, b) by SCMFSA_2:56;
    thus IC Es = succ IC t by A3,A23,SCMFSA_2:91
      .= IC Et by A23,SCMFSA_2:91;
A24: Ui = {a, b} by A23,Th18;
    then
A25: a in Ui by TARSKI:def 2;
    then s.a = (s | Ui).a by FUNCT_1:72;
    then
A26: s.a = t.a by A1,A25,FUNCT_1:72;
A27: now
      per cases;
      case
        a = b;
        hence Es.b = s.a - s.b & Et.b = t.a - t.b by A23,SCMFSA_2:91;
      end;
      case
        a<> b;
        hence Es.b = s.b & Et.b = t.b by A23,SCMFSA_2:91;
      end;
    end;
A28: b in Ui by A24,TARSKI:def 2;
    then s.b = (s | Ui).b by FUNCT_1:72;
    then
A29: s.b = t.b by A1,A28,FUNCT_1:72;
    Es.a = s.a - s.b & Et.a = t.a - t.b by A23,SCMFSA_2:91;
    hence Es | Ui = Et | Ui by A4,A24,A26,A29,A27,GRFUNC_1:91;
A30: UFi = {} by A23,Th36;
    hence Es | UFi = {} by RELAT_1:110
      .= Et | UFi by A30,RELAT_1:110;
  end;
  suppose
    InsCode i = 4;
    then consider a, b such that
A31: i = MultBy(a, b) by SCMFSA_2:57;
    thus IC Es = succ IC t by A3,A31,SCMFSA_2:92
      .= IC Et by A31,SCMFSA_2:92;
A32: Ui = {a, b} by A31,Th18;
    then
A33: a in Ui by TARSKI:def 2;
    then s.a = (s | Ui).a by FUNCT_1:72;
    then
A34: s.a = t.a by A1,A33,FUNCT_1:72;
A35: now
      per cases;
      case
        a = b;
        hence Es.b = s.a * s.b & Et.b = t.a * t.b by A31,SCMFSA_2:92;
      end;
      case
        a<> b;
        hence Es.b = s.b & Et.b = t.b by A31,SCMFSA_2:92;
      end;
    end;
A36: b in Ui by A32,TARSKI:def 2;
    then s.b = (s | Ui).b by FUNCT_1:72;
    then
A37: s.b = t.b by A1,A36,FUNCT_1:72;
    Es.a = s.a * s.b & Et.a = t.a * t.b by A31,SCMFSA_2:92;
    hence Es | Ui = Et | Ui by A4,A32,A34,A37,A35,GRFUNC_1:91;
A38: UFi = {} by A31,Th36;
    hence Es | UFi = {} by RELAT_1:110
      .= Et | UFi by A38,RELAT_1:110;
  end;
  suppose
    InsCode i = 5;
    then consider a, b such that
A39: i = Divide(a, b) by SCMFSA_2:58;
A40: Ui = {a, b} by A39,Th18;
    then
A41: a in Ui by TARSKI:def 2;
    then s.a = (s | Ui).a by FUNCT_1:72;
    then
A42: s.a = t.a by A1,A41,FUNCT_1:72;
A43: UFi = {} by A39,Th36;
A44: b in Ui by A40,TARSKI:def 2;
    then s.b = (s | Ui).b by FUNCT_1:72;
    then
A45: s.b = t.b by A1,A44,FUNCT_1:72;
    hereby
      per cases;
      suppose
A46:    a = b;
        hence IC Es = succ IC t by A3,A39,SCMFSA_2:94
          .= IC Et by A39,A46,SCMFSA_2:94;
        Es.a = s.a mod s.a & Et.a = t.a mod t.b by A39,A46,SCMFSA_2:94;
        hence Es | Ui = Et | Ui by A4,A40,A42,A46,GRFUNC_1:91;
        thus Es | UFi = {} by A43,RELAT_1:110
          .= Et | UFi by A43,RELAT_1:110;
      end;
      suppose
A47:    a <> b;
        thus IC Es = succ IC t by A3,A39,SCMFSA_2:93
          .= IC Et by A39,SCMFSA_2:93;
A48:    Es.b = s.a mod s.b & Et.b = t.a mod t.b by A39,SCMFSA_2:93;
        Es.a = s.a div s.b & Et.a = t.a div t.b by A39,A47,SCMFSA_2:93;
        hence Es | Ui = Et | Ui by A4,A40,A42,A45,A48,GRFUNC_1:91;
        thus Es | UFi = {} by A43,RELAT_1:110
          .= Et | UFi by A43,RELAT_1:110;
      end;
    end;
  end;
  suppose
    InsCode i = 6;
    then consider l such that
A49: i = goto l by SCMFSA_2:59;
    thus IC Es = l by A49,SCMFSA_2:95
      .= IC Et by A49,SCMFSA_2:95;
A50: Ui = {} by A49,Th19;
    hence Es | Ui = {} by RELAT_1:110
      .= Et | Ui by A50,RELAT_1:110;
A51: UFi = {} by A49,Th36;
    hence Es | UFi = {} by RELAT_1:110
      .= Et | UFi by A51,RELAT_1:110;
  end;
  suppose
    InsCode i = 7;
    then consider l, a such that
A52: i = a=0_goto l by SCMFSA_2:60;
A53: Ui = {a} by A52,Th20;
    then
A54: a in Ui by TARSKI:def 1;
    then
A55: s.a = (s | Ui).a by FUNCT_1:72;
    then
A56: s.a = t.a by A1,A54,FUNCT_1:72;
    hereby
      per cases;
      suppose
A57:    s.a = 0;
        hence IC Es = l by A52,SCMFSA_2:96
          .= IC Et by A52,A56,A57,SCMFSA_2:96;
      end;
      suppose
A58:    s.a <> 0;
        hence IC Es = succ IC s by A52,SCMFSA_2:96
          .= IC Et by A3,A52,A56,A58,SCMFSA_2:96;
      end;
    end;
    Es.a = s.a & Et.a = t.a by A52,SCMFSA_2:96;
    hence Es | Ui = Et | Ui by A1,A4,A53,A54,A55,FUNCT_1:72,GRFUNC_1:90;
A59: UFi = {} by A52,Th36;
    hence Es | UFi = {} by RELAT_1:110
      .= Et | UFi by A59,RELAT_1:110;
  end;
  suppose
    InsCode i = 8;
    then consider l, a such that
A60: i = a>0_goto l by SCMFSA_2:61;
A61: Ui = {a} by A60,Th20;
    then
A62: a in Ui by TARSKI:def 1;
    then
A63: s.a = (s | Ui).a by FUNCT_1:72;
    then
A64: s.a = t.a by A1,A62,FUNCT_1:72;
    hereby
      per cases;
      suppose
A65:    s.a > 0;
        hence IC Es = l by A60,SCMFSA_2:97
          .= IC Et by A60,A64,A65,SCMFSA_2:97;
      end;
      suppose
A66:    s.a <= 0;
        hence IC Es = succ IC s by A60,SCMFSA_2:97
          .= IC Et by A3,A60,A64,A66,SCMFSA_2:97;
      end;
    end;
    Es.a = s.a & Et.a = t.a by A60,SCMFSA_2:97;
    hence Es | Ui = Et | Ui by A1,A4,A61,A62,A63,FUNCT_1:72,GRFUNC_1:90;
A67: UFi = {} by A60,Th36;
    hence Es | UFi = {} by RELAT_1:110
      .= Et | UFi by A67,RELAT_1:110;
  end;
  suppose
    InsCode i = 9;
    then consider a, b, f such that
A68: i = b:=(f,a) by SCMFSA_2:62;
A69: Ui = {a, b} by A68,Th21;
    then
A70: a in Ui by TARSKI:def 2;
    then s.a = (s | Ui).a by FUNCT_1:72;
    then
A71: s.a = t.a by A1,A70,FUNCT_1:72;
    thus IC Es = succ IC t by A3,A68,SCMFSA_2:98
      .= IC Et by A68,SCMFSA_2:98;
A72: UFi = {f} by A68,Th37;
    then
A73: f in UFi by TARSKI:def 1;
    then
A74: s.f = (s | UFi).f by FUNCT_1:72;
A75: (ex m st m = abs(s.a) & Es.b = (s.f)/.m )& ex n st n = abs(t.a) & Et
    .b = (t.f)/.n by A68,SCMFSA_2:98;
A76: now
      per cases;
      case
        a = b;
        thus Es.b = Et.b by A2,A73,A74,A71,A75,FUNCT_1:72;
      end;
      case
        a <> b;
        hence Es.a = s.a & Et.a = t.a by A68,SCMFSA_2:98;
      end;
    end;
    s.f = t.f by A2,A73,A74,FUNCT_1:72;
    hence Es | Ui = Et | Ui by A4,A69,A71,A75,A76,GRFUNC_1:91;
    Es.f = s.f & Et.f = t.f by A68,SCMFSA_2:98;
    hence thesis by A2,A4,A72,A73,A74,FUNCT_1:72,GRFUNC_1:90;
  end;
  suppose
    InsCode i = 10;
    then consider a, b, f such that
A77: i = (f,a):=b by SCMFSA_2:63;
    thus IC Es = succ IC t by A3,A77,SCMFSA_2:99
      .= IC Et by A77,SCMFSA_2:99;
A78: Et.a = t.a & Et.b = t.b by A77,SCMFSA_2:99;
A79: Ui = {a, b} by A77,Th21;
    then
A80: a in Ui by TARSKI:def 2;
    then s.a = (s | Ui).a by FUNCT_1:72;
    then
A81: s.a = t.a by A1,A80,FUNCT_1:72;
A82: b in Ui by A79,TARSKI:def 2;
    then s.b = (s | Ui).b by FUNCT_1:72;
    then
A83: s.b = t.b by A1,A82,FUNCT_1:72;
A84: UFi = {f} by A77,Th37;
    then
A85: f in UFi by TARSKI:def 1;
    then s.f = (s | UFi).f by FUNCT_1:72;
    then
A86: s.f = t.f by A2,A85,FUNCT_1:72;
    Es.a = s.a & Es.b = s.b by A77,SCMFSA_2:99;
    hence Es | Ui = Et | Ui by A4,A79,A81,A83,A78,GRFUNC_1:91;
    (ex m st m = abs(s.a) & Es.f = s.f+*(m,s.b) )& ex n st n = abs(t.a)
    & Et. f = t.f+*(n,t.b) by A77,SCMFSA_2:99;
    hence thesis by A4,A84,A81,A83,A86,GRFUNC_1:90;
  end;
  suppose
    InsCode i = 11;
    then consider a, f such that
A87: i = a:=len f by SCMFSA_2:64;
    thus IC Es = succ IC t by A3,A87,SCMFSA_2:100
      .= IC Et by A87,SCMFSA_2:100;
A88: Et.a = len(t.f) by A87,SCMFSA_2:100;
A89: Ui = {a} & Es.a = len(s.f) by A87,Th22,SCMFSA_2:100;
A90: UFi = {f} by A87,Th38;
    then
A91: f in UFi by TARSKI:def 1;
    then
A92: s.f = (s | UFi).f by FUNCT_1:72;
    then s.f = t.f by A2,A91,FUNCT_1:72;
    hence Es | Ui = Et | Ui by A4,A89,A88,GRFUNC_1:90;
    Es.f = s.f & Et.f = t.f by A87,SCMFSA_2:100;
    hence thesis by A2,A4,A90,A91,A92,FUNCT_1:72,GRFUNC_1:90;
  end;
  suppose
    InsCode i = 12;
    then consider a,f such that
A93: i = f:=<0,...,0>a by SCMFSA_2:65;
    thus IC Es = succ IC t by A3,A93,SCMFSA_2:101
      .= IC Et by A93,SCMFSA_2:101;
A94: Ui = {a} by A93,Th22;
    then
A95: a in Ui by TARSKI:def 1;
    then
A96: s.a = (s | Ui).a by FUNCT_1:72;
A97: UFi = {f} & ex m st m = abs(s.a) & Es.f = m |-> 0 by A93,Th38,SCMFSA_2:101
;
    Es.a = s.a & Et.a = t.a by A93,SCMFSA_2:101;
    hence Es | Ui = Et | Ui by A1,A4,A94,A95,A96,FUNCT_1:72,GRFUNC_1:90;
A98: ex n st n = abs(t.a) & Et.f = n |-> 0 by A93,SCMFSA_2:101;
    s.a = t.a by A1,A95,A96,FUNCT_1:72;
    hence thesis by A4,A97,A98,GRFUNC_1:90;
  end;
end;

theorem
  I+*Start-At( 0,SCM+FSA) c= s & I+*Start-At( 0,SCM+FSA) c= t &
   s | UsedIntLoc
I = t | UsedIntLoc I & s | UsedInt*Loc I = t | UsedInt*Loc I & (for m st m < n
  holds IC Comput(ProgramPart(s),s,m) in dom I) implies (for m st m < n holds
IC
  Comput(ProgramPart(t),t,m) in dom I) & for m st m <= n holds IC Comput(
ProgramPart(s),s,m) = IC
  Comput(ProgramPart(t),t,m) & (for a st a in UsedIntLoc I holds Comput(
ProgramPart(s),s,m).a =
  Comput(ProgramPart(t),t,m).a) & for f st f in UsedInt*Loc I holds Comput(
ProgramPart(s),s,m).f =
  Comput(ProgramPart(t),t,m).f
proof
  assume that
A1: I+*Start-At( 0,SCM+FSA) c= s and
A2: I+*Start-At( 0,SCM+FSA) c= t and
A3: s | UsedIntLoc I = t | UsedIntLoc I and
A4: s | UsedInt*Loc I = t | UsedInt*Loc I and
A5: for m st m < n holds IC Comput(ProgramPart(s),s,m) in dom I;
  defpred P[Nat] means $1 < n implies IC Comput(ProgramPart(t),t,$1) in dom I
  & IC Comput(ProgramPart(s),s,$1) = IC Comput(ProgramPart(t),t,$1) & (for a st
a in UsedIntLoc I
holds Comput(ProgramPart(s),s,$1).a = Comput(ProgramPart(t),t,$1).a) & for f st
f in UsedInt*Loc I
  holds Comput(ProgramPart(s),s,$1).f = Comput(ProgramPart(t),t,$1).f;
A6: now
    let m;
    assume
A7: P[m];
    thus P[m+1]
    proof
      dom I misses dom Start-At( 0,SCM+FSA) by COMPOS_1:140;
      then
A8:   I c= I +* Start-At( 0,SCM+FSA) by FUNCT_4:33;
      then I c= t by A2,XBOOLE_1:1;
      then
A9:   I c= Comput(ProgramPart(t),t,m) by AMI_1:81;
      set i = Comput(ProgramPart(s),s,m).IC Comput(ProgramPart(s),s,m);
Y:  (ProgramPart Comput(ProgramPart(s),s,m))/.IC Comput(ProgramPart(s),s,m)
 = Comput(ProgramPart(s),s,m).IC Comput(ProgramPart(s),s,m) by COMPOS_1:38;
      set m1 = m+1;
T: ProgramPart s = ProgramPart Comput(ProgramPart(s),s,m)
by AMI_1:123;
A10:  Comput(ProgramPart(s),s,m1) =
Following(ProgramPart s,Comput(ProgramPart(s),s,m))
 by EXTPRO_1:4
        .= Exec( Comput(ProgramPart(s),s,m).IC Comput(ProgramPart(s),s,m),
Comput(ProgramPart(s),s,m))
         by Y,T;
      assume
A11:  m1 < n;
      now
        thus dom ( Comput(ProgramPart(s),s,m) | UsedInt*Loc I) = dom ( Comput(
ProgramPart(s),s,m))
        /\ UsedInt*Loc I by RELAT_1:90
          .= (the carrier of SCM+FSA) /\ UsedInt*Loc I
           by PARTFUN1:def 4
          .= dom ( Comput(ProgramPart(t),t,m)) /\ UsedInt*Loc I by
PARTFUN1:def 4;
        let x be set;
        assume x in dom ( Comput(ProgramPart(s),s,m) | UsedInt*Loc I);
        then
A12:    x in UsedInt*Loc I by RELAT_1:86;
        then reconsider x9 = x as FinSeq-Location by SCMFSA_2:12;
        thus ( Comput(ProgramPart(s),s,m) | UsedInt*Loc I).x = Comput(
ProgramPart(s),s,m).x9 by A12,FUNCT_1:72
          .= Comput(ProgramPart(t),t,m).x by A7,A11,A12,NAT_1:13;
      end;
      then
A13:  Comput(ProgramPart(s),s,m) | UsedInt*Loc I = Comput(ProgramPart(t),t,m) |
UsedInt*Loc I
      by FUNCT_1:68;
      I c= s by A1,A8,XBOOLE_1:1;
      then I c= Comput(ProgramPart(s),s,m) by AMI_1:81;
      then
A14:  Comput(ProgramPart(s),s,m).IC Comput(ProgramPart(s),s,m) = I.IC Comput(
ProgramPart(s),s,m) by A7,A11,GRFUNC_1:8,NAT_1:13;
      then
A15:  Comput(ProgramPart(s),s,m).IC Comput(ProgramPart(s),s,m) = Comput(
ProgramPart(t),t,m).IC
      Comput(ProgramPart(t),t,m) by A7,A11,A9,GRFUNC_1:8,NAT_1:13;
      now
        thus dom ( Comput(ProgramPart(s),s,m) | UsedIntLoc I) = dom ( Comput(
ProgramPart(s),s,m))
        /\ UsedIntLoc I by RELAT_1:90
          .= (the carrier of SCM+FSA) /\ UsedIntLoc I
          by PARTFUN1:def 4
          .= dom ( Comput(ProgramPart(t),t,m)) /\ UsedIntLoc I by
PARTFUN1:def 4;
        let x be set;
        assume x in dom ( Comput(ProgramPart(s),s,m) | UsedIntLoc I);
        then
A16:    x in UsedIntLoc I by RELAT_1:86;
        then reconsider x9 = x as Int-Location by SCMFSA_2:11;
        thus ( Comput(ProgramPart(s),s,m) | UsedIntLoc I).x = Comput(
ProgramPart(s),s,m).x9 by A16,FUNCT_1:72
          .= Comput(ProgramPart(t),t,m).x by A7,A11,A16,NAT_1:13;
      end;
      then
A17:  Comput(ProgramPart(s),s,m) | UsedIntLoc I = Comput(ProgramPart(t),t,m) |
UsedIntLoc I
      by FUNCT_1:68;
Y:  (ProgramPart Comput(ProgramPart(t),t,m))/.IC Comput(ProgramPart(t),t,m)
 = Comput(ProgramPart(t),t,m).IC Comput(ProgramPart(t),t,m) by COMPOS_1:38;
T: ProgramPart t = ProgramPart Comput(ProgramPart(t),t,m)
by AMI_1:123;
A18:  Comput(ProgramPart(t),t,m1) =
Following(ProgramPart t,Comput(ProgramPart(t),t,m))
 by EXTPRO_1:4
        .= Exec( Comput(ProgramPart(t),t,m).IC Comput(ProgramPart(t),t,m),
Comput(ProgramPart(t),t,m))
         by Y,T;
      m < n by A11,NAT_1:13;
      then IC Comput(ProgramPart(s),s,m) in dom I by A5;
      then
A19:  i in rng I by A14,FUNCT_1:def 5;
      then
A20:  Comput(ProgramPart(s),s,m) | UsedInt*Loc i = ( Comput(ProgramPart(s),s,m)
| UsedInt*Loc
      I) | UsedInt*Loc i by Th39,RELAT_1:103
        .= Comput(ProgramPart(t),t,m) | UsedInt*Loc i by A19,A13,Th39,
RELAT_1:103;
A21:  Comput(ProgramPart(s),s,m) | UsedIntLoc i = ( Comput(ProgramPart(s),s,m)
| UsedIntLoc I
      ) | UsedIntLoc i by A19,Th23,RELAT_1:103
        .= Comput(ProgramPart(t),t,m) | UsedIntLoc i by A19,A17,Th23,
RELAT_1:103;
      then
A22:  Exec(i, Comput(ProgramPart(s),s,m)) | UsedInt*Loc i = Exec(i, Comput(
ProgramPart(t),t,m
      )) | UsedInt*Loc i by A7,A11,A20,Th72,NAT_1:13;
A23:  IC Exec(i, Comput(ProgramPart(s),s,m)) = IC Exec(i, Comput(ProgramPart(t)
,t,m)) by A7,A11,A21,A20,Th72,NAT_1:13;
      hence IC Comput(ProgramPart(t),t,m1) in dom I by A5,A11,A10,A18,A15;
      thus IC Comput(ProgramPart(s),s,m1) = IC Comput(ProgramPart(t),t,m1) by
A7,A11,A10,A18,A9,A14,A23,GRFUNC_1:8,NAT_1:13;
A24:  Exec(i, Comput(ProgramPart(s),s,m)) | UsedIntLoc i = Exec(i, Comput(
ProgramPart(t),t,m)
      ) | UsedIntLoc i by A7,A11,A21,A20,Th72,NAT_1:13;
      hereby
        let a;
        assume
A25:    a in UsedIntLoc I;
        per cases;
        suppose
A26:      a in UsedIntLoc i;
          hence
          Comput(ProgramPart(s),s,m1).a = (Exec(i, Comput(ProgramPart(s),s,m))
| UsedIntLoc i
          ).a by A10,FUNCT_1:72
            .= Comput(ProgramPart(t),t,m1).a by A18,A15,A24,A26,FUNCT_1:72;
        end;
        suppose
A27:      not a in UsedIntLoc i;
          hence Comput(ProgramPart(s),s,m1).a = Comput(ProgramPart(s),s,m).a
by A10,Th68
            .= Comput(ProgramPart(t),t,m).a by A7,A11,A25,NAT_1:13
            .= Comput(ProgramPart(t),t,m1).a by A18,A15,A27,Th68;
        end;
      end;
      let f;
      assume
A28:  f in UsedInt*Loc I;
      per cases;
      suppose
A29:    f in UsedInt*Loc i;
        hence
        Comput(ProgramPart(s),s,m1).f = (Exec(i, Comput(ProgramPart(s),s,m)) |
UsedInt*Loc i)
        .f by A10,FUNCT_1:72
          .= Comput(ProgramPart(t),t,m1).f by A18,A15,A22,A29,FUNCT_1:72;
      end;
      suppose
A30:    not f in UsedInt*Loc i;
        hence Comput(ProgramPart(s),s,m1).f = Comput(ProgramPart(s),s,m).f by
A10,Th70
          .= Comput(ProgramPart(t),t,m).f by A7,A11,A28,NAT_1:13
          .= Comput(ProgramPart(t),t,m1).f by A18,A15,A30,Th70;
      end;
    end;
  end;
A31: P[0]
  proof
A32: IC Comput(ProgramPart(t),t,0) = IC t by EXTPRO_1:3
      .=  0 by A2,COMPOS_1:143;
A33: IC Comput(ProgramPart(s),s,0) = IC s by EXTPRO_1:3
      .=  0 by A1,COMPOS_1:143;
    assume 0 < n;
    hence IC Comput(ProgramPart(t),t,0) in dom I by A5,A33,A32;
    thus IC Comput(ProgramPart(s),s,0) = IC Comput(ProgramPart(t),t,0) by A33
,A32;
    hereby
      let a;
      assume
A34:  a in UsedIntLoc I;
      thus Comput(ProgramPart(s),s,0).a = s.a by EXTPRO_1:3
        .= (s | UsedIntLoc I).a by A34,FUNCT_1:72
        .= t.a by A3,A34,FUNCT_1:72
        .= Comput(ProgramPart(t),t,0).a by EXTPRO_1:3;
    end;
    let f;
    assume
A35: f in UsedInt*Loc I;
    thus Comput(ProgramPart(s),s,0).f = s.f by EXTPRO_1:3
      .= (s | UsedInt*Loc I).f by A35,FUNCT_1:72
      .= t.f by A4,A35,FUNCT_1:72
      .= Comput(ProgramPart(t),t,0).f by EXTPRO_1:3;
  end;
A36: for m holds P[m] from NAT_1:sch 1(A31, A6);
  hence for m st m < n holds IC Comput(ProgramPart(t),t,m) in dom I;
  let m;
  assume
A37: m <= n;
  per cases by NAT_1:6;
  suppose
A38: m = 0;
A39: IC Comput(ProgramPart(t),t,0) = IC t by EXTPRO_1:3
      .=  0 by A2,COMPOS_1:143;
    IC Comput(ProgramPart(s),s,0) = IC s by EXTPRO_1:3
      .=  0 by A1,COMPOS_1:143;
    hence IC Comput(ProgramPart(s),s,m) = IC Comput(ProgramPart(t),t,m) by A38
,A39;
    hereby
      let a;
      assume
A40:  a in UsedIntLoc I;
      thus Comput(ProgramPart(s),s,m).a = s.a by A38,EXTPRO_1:3
        .= (s | UsedIntLoc I).a by A40,FUNCT_1:72
        .= t.a by A3,A40,FUNCT_1:72
        .= Comput(ProgramPart(t),t,m).a by A38,EXTPRO_1:3;
    end;
    let f;
    assume
A41: f in UsedInt*Loc I;
    thus Comput(ProgramPart(s),s,m).f = s.f by A38,EXTPRO_1:3
      .= (s | UsedInt*Loc I).f by A41,FUNCT_1:72
      .= t.f by A4,A41,FUNCT_1:72
      .= Comput(ProgramPart(t),t,m).f by A38,EXTPRO_1:3;
  end;
  suppose
    ex p being Nat st m = p+1;
    then consider p being Nat such that
A42: m = p+1;
    reconsider p as Element of NAT by ORDINAL1:def 13;
A43: p < n by A37,A42,NAT_1:13;
    then
A44: IC Comput(ProgramPart(s),s,p) in dom I by A5;
    now
      thus dom ( Comput(ProgramPart(s),s,p) | UsedInt*Loc I) = dom ( Comput(
ProgramPart(s),s,p))
      /\ UsedInt*Loc I by RELAT_1:90
        .= (the carrier of SCM+FSA) /\ UsedInt*Loc I by PARTFUN1:def 4
        .= dom ( Comput(ProgramPart(t),t,p)) /\ UsedInt*Loc I by PARTFUN1:def 4
;
      let x be set;
      assume x in dom ( Comput(ProgramPart(s),s,p) | UsedInt*Loc I);
      then
A45:  x in UsedInt*Loc I by RELAT_1:86;
      then reconsider x9 = x as FinSeq-Location by SCMFSA_2:12;
      thus ( Comput(ProgramPart(s),s,p) | UsedInt*Loc I).x = Comput(ProgramPart
(s),s,p).x9 by A45,FUNCT_1:72
        .= Comput(ProgramPart(t),t,p).x by A36,A43,A45;
    end;
    then
A46: Comput(ProgramPart(s),s,p) | UsedInt*Loc I = Comput(ProgramPart(t),t,p) |
UsedInt*Loc I
    by FUNCT_1:68;
    set i = Comput(ProgramPart(s),s,p).IC Comput(ProgramPart(s),s,p);
    set p1 = p+1;
Y:  (ProgramPart Comput(ProgramPart(s),s,p))/.IC Comput(ProgramPart(s),s,p)
 = Comput(ProgramPart(s),s,p).IC Comput(ProgramPart(s),s,p) by COMPOS_1:38;
T: ProgramPart s = ProgramPart Comput(ProgramPart(s),s,p)
by AMI_1:123;
A47: Comput(ProgramPart(s),s,p1) =
Following(ProgramPart s,Comput(ProgramPart(s),s,p))
 by EXTPRO_1:4
      .= Exec( Comput(ProgramPart(s),s,p).IC Comput(ProgramPart(s),s,p), Comput
(ProgramPart(s),s,p))
              by Y,T;
    now
      thus dom ( Comput(ProgramPart(s),s,p) | UsedIntLoc I) = dom ( Comput(
ProgramPart(s),s,p)) /\
      UsedIntLoc I by RELAT_1:90
        .= (the carrier of SCM+FSA) /\ UsedIntLoc I by PARTFUN1:def 4
        .= dom ( Comput(ProgramPart(t),t,p)) /\ UsedIntLoc I by PARTFUN1:def 4;
      let x be set;
      assume x in dom ( Comput(ProgramPart(s),s,p) | UsedIntLoc I);
      then
A48:  x in UsedIntLoc I by RELAT_1:86;
      then reconsider x9 = x as Int-Location by SCMFSA_2:11;
      thus ( Comput(ProgramPart(s),s,p) | UsedIntLoc I).x = Comput(ProgramPart(
s),s,p).x9 by A48,FUNCT_1:72
        .= Comput(ProgramPart(t),t,p).x by A36,A43,A48;
    end;
    then
A49: Comput(ProgramPart(s),s,p) | UsedIntLoc I = Comput(ProgramPart(t),t,p) |
UsedIntLoc I by FUNCT_1:68;
A50: IC Comput(ProgramPart(s),s,p) = IC Comput(ProgramPart(t),t,p) by A36,A43;
    dom I misses dom Start-At( 0,SCM+FSA) by COMPOS_1:140;
    then
A51: I c= I +* Start-At( 0,SCM+FSA) by FUNCT_4:33;
    then I c= s by A1,XBOOLE_1:1;
    then I c= Comput(ProgramPart(s),s,p) by AMI_1:81;
    then
A52: Comput(ProgramPart(s),s,p).IC Comput(ProgramPart(s),s,p) = I.IC Comput(
ProgramPart(s),s,p) by A44,GRFUNC_1:8;
Y:  (ProgramPart Comput(ProgramPart(t),t,p))/.IC Comput(ProgramPart(t),t,p)
 = Comput(ProgramPart(t),t,p).IC Comput(ProgramPart(t),t,p) by COMPOS_1:38;
T: ProgramPart t = ProgramPart Comput(ProgramPart(t),t,p)
by AMI_1:123;
A53: Comput(ProgramPart(t),t,p1) =
Following(ProgramPart t,Comput(ProgramPart(t),t,p))
 by EXTPRO_1:4
      .= Exec( Comput(ProgramPart(t),t,p).IC Comput(ProgramPart(t),t,p), Comput
(ProgramPart(t),t,p))
              by Y,T;
    I c= t by A2,A51,XBOOLE_1:1;
    then I c= Comput(ProgramPart(t),t,p) by AMI_1:81;
    then
A54: Comput(ProgramPart(s),s,p).IC Comput(ProgramPart(s),s,p) = Comput(
ProgramPart(t),t,p).IC
    Comput(ProgramPart(t),t,p) by A50,A44,A52,GRFUNC_1:8;
    IC Comput(ProgramPart(s),s,p) in dom I by A5,A43;
    then
A55: i in rng I by A52,FUNCT_1:def 5;
    then
A56: Comput(ProgramPart(s),s,p) | UsedInt*Loc i = ( Comput(ProgramPart(s),s,p)
| UsedInt*Loc I
    ) | UsedInt*Loc i by Th39,RELAT_1:103
      .= Comput(ProgramPart(t),t,p) | UsedInt*Loc i by A55,A46,Th39,RELAT_1:103
;
A57: Comput(ProgramPart(s),s,p) | UsedIntLoc i = ( Comput(ProgramPart(s),s,p) |
UsedIntLoc I)
    | UsedIntLoc i by A55,Th23,RELAT_1:103
      .= Comput(ProgramPart(t),t,p) | UsedIntLoc i by A55,A49,Th23,RELAT_1:103;
    hence IC Comput(ProgramPart(s),s,m) = IC Comput(ProgramPart(t),t,m) by A42
,A47,A53,A50,A54,A56,Th72;
A58: Exec(i, Comput(ProgramPart(s),s,p)) | UsedIntLoc i = Exec(i, Comput(
ProgramPart(t),t,p))
    | UsedIntLoc i by A50,A57,A56,Th72;
    hereby
      let a;
      assume
A59:  a in UsedIntLoc I;
      per cases;
      suppose
A60:    a in UsedIntLoc i;
        hence
        Comput(ProgramPart(s),s,m).a = (Exec(i, Comput(ProgramPart(s),s,p)) |
UsedIntLoc i).a
        by A42,A47,FUNCT_1:72
          .= Comput(ProgramPart(t),t,m).a by A42,A53,A54,A58,A60,FUNCT_1:72;
      end;
      suppose
A61:    not a in UsedIntLoc i;
        hence Comput(ProgramPart(s),s,m).a = Comput(ProgramPart(s),s,p).a by
A42,A47,Th68
          .= Comput(ProgramPart(t),t,p).a by A36,A43,A59
          .= Comput(ProgramPart(t),t,m).a by A42,A53,A54,A61,Th68;
      end;
    end;
A62: Exec(i, Comput(ProgramPart(s),s,p)) | UsedInt*Loc i = Exec(i, Comput(
ProgramPart(t),t,p))
    | UsedInt*Loc i by A50,A57,A56,Th72;
    hereby
      let f;
      assume
A63:  f in UsedInt*Loc I;
      per cases;
      suppose
A64:    f in UsedInt*Loc i;
        hence
        Comput(ProgramPart(s),s,m).f = (Exec(i, Comput(ProgramPart(s),s,p)) |
UsedInt*Loc i).
        f by A42,A47,FUNCT_1:72
          .= Comput(ProgramPart(t),t,m).f by A42,A53,A54,A62,A64,FUNCT_1:72;
      end;
      suppose
A65:    not f in UsedInt*Loc i;
        hence Comput(ProgramPart(s),s,m).f = Comput(ProgramPart(s),s,p).f by
A42,A47,Th70
          .= Comput(ProgramPart(t),t,p).f by A36,A43,A63
          .= Comput(ProgramPart(t),t,m).f by A42,A53,A54,A65,Th70;
      end;
    end;
  end;
end;

