:: Memory handling for SCM+FSA
::  by Piotr Rudnicki and Andrzej Trybulec
::
:: Received July 18, 1996
:: Copyright (c) 1996-2012 Association of Mizar Users
::           (Stowarzyszenie Uzytkownikow Mizara, Bialystok, Poland).
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies SCMFSA_2, XBOOLE_0, AMI_1, GRAPHSP, AMI_3, FINSEQ_1, FUNCT_1,
      SUBSET_1, FINSUB_1, SETWISEO, CARD_1, TARSKI, CARD_3, RELAT_1, ZFMISC_1,
      FINSET_1, NUMBERS, FUNCT_4, VALUED_1, ARYTM_3, AMISTD_2,
      XXREAL_0, SCMFSA6A, TURING_1, FSM_1, CIRCUIT2, STRUCT_0, ARYTM_1, INT_1,
      COMPLEX1, PARTFUN1, FINSEQ_2, NAT_1, SF_MASTR, ORDINAL1, RELOC, AMI_2,
      PBOOLE, SCMFSA6C, COMPOS_1, SCMPDS_4, EXTPRO_1;
 notations TARSKI, XBOOLE_0, ENUMSET1, ZFMISC_1, SUBSET_1, CARD_1, NUMBERS,
      XCMPLX_0, FINSET_1, FINSUB_1, ORDINAL1, NAT_1, INT_1, VALUED_1, STRUCT_0,
      SETWISEO, SEQ_4, CARD_3, FINSEQ_1, FINSEQ_2, RELAT_1, FUNCT_1, RELSET_1,
      PARTFUN1, FUNCT_2, FUNCT_4, PBOOLE, FUNCT_7, MEMSTR_0, COMPOS_0,
      COMPOS_1, AMI_2, EXTPRO_1, AMI_3, SCMFSA_2, AMISTD_2, SCMFSA6A, INT_2,
      XXREAL_0, SCMFSA_M;
 constructors SETWISEO, INT_2, SEQ_4, AMI_3, SCMFSA6A, RELSET_1, VALUED_1,
      AMISTD_2, AMISTD_1, AMI_2, SCMFSA_1, CARD_5, PRE_POLY, DOMAIN_1, PBOOLE,
      FUNCT_7, MEMSTR_0, SCMFSA_M;
 registrations SETFAM_1, FUNCT_1, ORDINAL1, RELSET_1, FUNCT_2, FINSET_1,
      FINSUB_1, NUMBERS, XREAL_0, INT_1, MEMBERED, CARD_3, SCMFSA_2, XBOOLE_0,
      XXREAL_2, VALUED_1, FINSEQ_1, AMISTD_2, AMI_3, SCMFSA10, COMPOS_1,
      EXTPRO_1, CARD_5, ZFMISC_1, AMI_2, CARD_1, PBOOLE, SCMFSA_4, MEMSTR_0,
      CARD_2, COMPOS_0, SCM_INST, SCMFSA_M;
 requirements NUMERALS, BOOLE, SUBSET, ARITHM;
 definitions XBOOLE_0, FUNCOP_1, MEMSTR_0, EXTPRO_1, COMPOS_1, AMI_3, SCMFSA_2,
      SCMFSA6A, AMISTD_2, COMPOS_0;
 theorems TARSKI, ENUMSET1, ZFMISC_1, FINSEQ_1, FINSUB_1, SETWISEO, NAT_1,
      RELAT_1, GRFUNC_1, FUNCT_1, FUNCT_2, FUNCT_4, FUNCT_7, CARD_3, SCMFSA_2,
      SCMFSA_4, XBOOLE_0, XBOOLE_1, ORDINAL1, AMI_2, MEMSTR_0, AMI_3, VALUED_1,
      XXREAL_2, PARTFUN1, MCART_1, COMPOS_1, EXTPRO_1, COMPOS_0, SCM_INST,
      SCMFSA_M, XTUPLE_0;
 schemes NAT_1, DOMAIN_1, FUNCT_2;

begin :: Uniqueness of instruction components

reserve a, b, c, a1, a2, b1, b2 for Int-Location,
  l, l1, l2 for Element of NAT,
  f, g, f1, f2 for FinSeq-Location,
  i, j for Instruction of SCM+FSA;

theorem Th1:
  a1:=b1 = a2:=b2 implies a1 = a2 & b1 = b2
proof
  assume
A1: a1:=b1 = a2:=b2;
  consider A1, B1 being Data-Location such that
A2: a1 = A1 & b1 = B1 & a1:=b1 = A1:=B1 by SCMFSA_2:def 8;
  consider A2, B2 being Data-Location such that
A3: a2 = A2 & b2 = B2 & a2:=b2 = A2:=B2 by SCMFSA_2:def 8;
A4: <*A2,B2*>.1 = A2 & <*A2,B2*>.2 = B2 by FINSEQ_1:44;
  <*A1,B1*>.1 = A1 & <*A1,B1*>.2 = B1 by FINSEQ_1:44;
  hence thesis by A1,A2,A3,A4,XTUPLE_0:3;
end;

theorem Th2:
  AddTo(a1,b1) = AddTo(a2,b2) implies a1 = a2 & b1 = b2
proof
  assume
A1: AddTo(a1,b1) = AddTo(a2,b2);
  consider A1, B1 being Data-Location such that
A2: a1 = A1 & b1 = B1 & AddTo(a1,b1) = AddTo(A1,B1) by SCMFSA_2:def 9;
  consider A2, B2 being Data-Location such that
A3: a2 = A2 & b2 = B2 & AddTo(a2,b2) = AddTo(A2,B2) by SCMFSA_2:def 9;
A4: <*A2,B2*>.1 = A2 & <*A2,B2*>.2 = B2 by FINSEQ_1:44;
  <*A1,B1*>.1 = A1 & <*A1,B1*>.2 = B1 by FINSEQ_1:44;
  hence thesis by A1,A2,A3,A4,XTUPLE_0:3;
end;

theorem Th3:
  SubFrom(a1,b1) = SubFrom(a2,b2) implies a1 = a2 & b1 = b2
proof
  assume
A1: SubFrom(a1,b1) = SubFrom(a2,b2);
  consider A1, B1 being Data-Location such that
A2: a1 = A1 & b1 = B1 & SubFrom(a1,b1) = SubFrom(A1,B1) by SCMFSA_2:def 10;
  consider A2, B2 being Data-Location such that
A3: a2 = A2 & b2 = B2 & SubFrom(a2,b2) = SubFrom(A2,B2) by SCMFSA_2:def 10;
A4: <*A2,B2*>.1 = A2 & <*A2,B2*>.2 = B2 by FINSEQ_1:44;
  <*A1,B1*>.1 = A1 & <*A1,B1*>.2 = B1 by FINSEQ_1:44;
  hence thesis by A1,A2,A3,A4,XTUPLE_0:3;
end;

theorem Th4:
  MultBy(a1,b1) = MultBy(a2,b2) implies a1 = a2 & b1 = b2
proof
  assume
A1: MultBy(a1,b1) = MultBy(a2,b2);
  consider A1, B1 being Data-Location such that
A2: a1 = A1 & b1 = B1 & MultBy(a1,b1) = MultBy(A1,B1) by SCMFSA_2:def 11;
  consider A2, B2 being Data-Location such that
A3: a2 = A2 & b2 = B2 & MultBy(a2,b2) = MultBy(A2,B2) by SCMFSA_2:def 11;
A4: <*A2,B2*>.1 = A2 & <*A2,B2*>.2 = B2 by FINSEQ_1:44;
  <*A1,B1*>.1 = A1 & <*A1,B1*>.2 = B1 by FINSEQ_1:44;
  hence thesis by A1,A2,A3,A4,XTUPLE_0:3;
end;

theorem Th5:
  Divide(a1,b1) = Divide(a2,b2) implies a1 = a2 & b1 = b2
proof
  assume
A1: Divide(a1,b1) = Divide(a2,b2);
  consider A1, B1 being Data-Location such that
A2: a1 = A1 & b1 = B1 & Divide(a1,b1) = Divide(A1,B1) by SCMFSA_2:def 12;
  consider A2, B2 being Data-Location such that
A3: a2 = A2 & b2 = B2 & Divide(a2,b2) = Divide(A2,B2) by SCMFSA_2:def 12;
A4: <*A2,B2*>.1 = A2 & <*A2,B2*>.2 = B2 by FINSEQ_1:44;
  <*A1,B1*>.1 = A1 & <*A1,B1*>.2 = B1 by FINSEQ_1:44;
  hence thesis by A1,A2,A3,A4,XTUPLE_0:3;
end;

theorem
  goto l1 = goto l2 implies l1 = l2
proof
  assume
A1: goto l1 = goto l2;
  <*l1*>.1 = l1 & <*l2*>.1 = l2 by FINSEQ_1:40;
  hence thesis by A1,XTUPLE_0:3;
end;

theorem Th7:
  a1=0_goto l1 = a2=0_goto l2 implies a1 = a2 & l1 = l2
proof
  assume
A1: a1=0_goto l1 = a2=0_goto l2;
  consider A1 being Data-Location such
  that
A2: a1 = A1 & a1=0_goto l1 = A1=0_goto l1 by SCMFSA_2:def 14;
  consider A2 being Data-Location such
  that
A3: a2 = A2 & a2=0_goto l2 = A2=0_goto l2 by SCMFSA_2:def 14;
A4: <*l2*>.1 = l2 & <*A2*>.1 = A2 by FINSEQ_1:40;
  <*l1*>.1 = l1 & <*A1*>.1 = A1 by FINSEQ_1:40;
  hence thesis by A1,A2,A3,A4,XTUPLE_0:3;
end;

theorem Th8:
  a1>0_goto l1 = a2>0_goto l2 implies a1 = a2 & l1 = l2
proof
  assume
A1: a1>0_goto l1 = a2>0_goto l2;
  consider A1 being Data-Location such
  that
A2: a1 = A1 & a1>0_goto l1 = A1>0_goto l1 by SCMFSA_2:def 15;
  consider A2 being Data-Location such
  that
A3: a2 = A2 & a2>0_goto l2 = A2>0_goto l2 by SCMFSA_2:def 15;
A4: <*l2*>.1 = l2 & <*A2*>.1 = A2 by FINSEQ_1:40;
  <*l1*>.1 = l1 & <*A1*>.1 = A1 by FINSEQ_1:40;
  hence thesis by A1,A2,A3,A4,XTUPLE_0:3;
end;

theorem Th9:
  b1:=(f1, a1) = b2:=(f2, a2) implies a1 = a2 & b1 = b2 & f1 = f2
proof
A1: <*b1,f1,a1*>.1 = b1 & <*b1,f1,a1*>.2 = f1 by FINSEQ_1:45;
A2: <*b1,f1,a1*>.3 = a1 & <*b2,f2,a2*>.1 = b2 by FINSEQ_1:45;
A3: <*b2,f2,a2*>.2 = f2 & <*b2,f2,a2*>.3 = a2 by FINSEQ_1:45;
  assume b1:=(f1, a1) = b2:=(f2, a2);
  hence thesis by A1,A2,A3,XTUPLE_0:3;
end;

theorem Th10:
  (f1, a1):=b1 = (f2, a2):=b2 implies a1 = a2 & b1 = b2 & f1 = f2
proof
A1: <*b1,f1,a1*>.1 = b1 & <*b1,f1,a1*>.2 = f1 by FINSEQ_1:45;
A2: <*b1,f1,a1*>.3 = a1 & <*b2,f2,a2*>.1 = b2 by FINSEQ_1:45;
A3: <*b2,f2,a2*>.2 = f2 & <*b2,f2,a2*>.3 = a2 by FINSEQ_1:45;
  assume (f1, a1):=b1 = (f2, a2):=b2;
  hence thesis by A1,A2,A3,XTUPLE_0:3;
end;

theorem Th11:
  a1:=len f1 = a2:=len f2 implies a1 = a2 & f1 = f2
proof
A1: <*a1,f1*>.1 = a1 & <*a1,f1*>.2 = f1 by FINSEQ_1:44;
A2: <*a2,f2*>.1 = a2 & <*a2,f2*>.2 = f2 by FINSEQ_1:44;
  assume a1:=len f1 = a2:=len f2;
  hence thesis by A1,A2,XTUPLE_0:3;
end;

theorem Th12:
  f1:=<0,...,0>a1 = f2:=<0,...,0>a2 implies a1 = a2 & f1 = f2
proof
A1: <*a1,f1*>.1 = a1 & <*a1,f1*>.2 = f1 by FINSEQ_1:44;
A2: <*a2,f2*>.1 = a2 & <*a2,f2*>.2 = f2 by FINSEQ_1:44;
  assume f1:=<0,...,0>a1 = f2:=<0,...,0>a2;
  hence thesis by A1,A2,XTUPLE_0:3;
end;

begin :: Integer locations used in a macro instruction

definition
  let i be Instruction of SCM+FSA;
  func UsedIntLoc i -> Element of Fin Int-Locations means
  :Def1:
  ex a, b being
  Int-Location st (i = (a := b) or i = AddTo(a, b) or i = SubFrom(a, b) or i =
MultBy(a, b) or i = Divide(a, b)) & it = {a, b} if InsCode i in {1, 2, 3, 4, 5}
  , ex a being Int-Location, l being Element of NAT st (i = a
=0_goto l or i = a>0_goto l) & it = {a} if InsCode i = 7 or InsCode i = 8, ex a
, b being Int-Location, f being FinSeq-Location st (i = b := (f, a) or i = (f,
  a) := b) & it = {a, b} if InsCode i = 9 or InsCode i = 10,
    ex a being Int-Location, f being FinSeq-Location st
     (i = a :=len f or i = f :=<0,...,0>a) & it = {a}
      if InsCode i = 11 or InsCode i = 12
    otherwise it = {};
  existence
  proof
    hereby
      assume InsCode i in {1, 2, 3, 4, 5};
      then
      InsCode i = 1 or InsCode i = 2 or InsCode i = 3 or InsCode i = 4 or
      InsCode i = 5 by ENUMSET1:def 3;
      then consider a, b being Int-Location such that
A1:   i = (a := b) or i = AddTo(a, b) or i = SubFrom(a, b) or i =
      MultBy(a, b) or i = Divide(a, b) by SCMFSA_2:30,31,32,33,34;
      reconsider a9 = a, b9 = b as Element of Int-Locations by AMI_2:def 16;
      reconsider IT = {.a9, b9.} as Element of Fin Int-Locations;
      take IT;
      take a, b;
      thus (i = (a := b) or i = AddTo(a, b) or i = SubFrom(a, b) or i = MultBy
      (a, b) or i = Divide(a, b)) & IT = {a, b} by A1;
    end;
    hereby
      assume InsCode i = 7 or InsCode i = 8;
      then consider
      l being Element of NAT, a being Int-Location
      such that
A2:   i = a=0_goto l or i = a>0_goto l by SCMFSA_2:36,37;
      reconsider a9 = a as Element of Int-Locations by AMI_2:def 16;
      reconsider IT = {.a9.} as Element of Fin Int-Locations;
      take IT;
      take a, l;
      thus (i = a=0_goto l or i = a>0_goto l) & IT = {a} by A2;
    end;
    hereby
      assume InsCode i = 9 or InsCode i = 10;
      then consider a, b being Int-Location, f being FinSeq-Location such that
A3:   i = b := (f, a) or i = (f, a) := b by SCMFSA_2:38,39;
      reconsider a9 = a, b9 = b as Element of Int-Locations by AMI_2:def 16;
      reconsider IT = {.a9, b9.} as Element of Fin Int-Locations;
      take IT;
      take a, b, f;
      thus (i = b := (f, a) or i = (f, a) := b) & IT = {a, b} by A3;
    end;
    hereby
      assume InsCode i = 11 or InsCode i = 12;
      then consider a being Int-Location, f being FinSeq-Location such that
A4:   i = a :=len f or i = f :=<0,...,0>a by SCMFSA_2:40,41;
      reconsider a9 = a as Element of Int-Locations by AMI_2:def 16;
      reconsider IT = {.a9.} as Element of Fin Int-Locations;
      take IT;
      take a, f;
      thus (i = a :=len f or i = f :=<0,...,0>a) & IT = {a} by A4;
    end;
    {} in Fin Int-Locations by FINSUB_1:7;
    hence thesis;
  end;
  uniqueness
  proof
    let it1, it2 be Element of Fin Int-Locations;
    hereby
      assume InsCode i in {1, 2, 3, 4, 5};
      given a1, b1 being Int-Location such that
A5:   i = (a1 := b1) or i = AddTo(a1, b1) or i = SubFrom(a1, b1) or i
      = MultBy(a1, b1) or i = Divide(a1, b1) and
A6:   it1 = {a1, b1};
      given a2, b2 being Int-Location such that
A7:   i = (a2 := b2) or i = AddTo(a2, b2) or i = SubFrom(a2, b2) or i
      = MultBy(a2, b2) or i = Divide(a2, b2) and
A8:   it2 = {a2, b2};
A9:   i = AddTo(a1, b1) or i = AddTo(a2, b2) implies InsCode i = 2 by
SCMFSA_2:19;
A10:  i = Divide(a1, b1) or i = Divide(a2, b2) implies InsCode i = 5 by
SCMFSA_2:22;
A11:  i = MultBy(a1, b1) or i = MultBy(a2, b2) implies InsCode i = 4 by
SCMFSA_2:21;
A12:  i = SubFrom(a1, b1) or i = SubFrom(a2, b2) implies InsCode i = 3 by
SCMFSA_2:20;
      per cases by A5,A7,A9,A12,A11,A10,SCMFSA_2:18;
      suppose
A13:    i = (a1 := b1) & i = (a2 := b2);
        then a1 = a2 by Th1;
        hence it1 = it2 by A6,A8,A13,Th1;
      end;
      suppose
A14:    i = AddTo(a1, b1) & i = AddTo(a2, b2);
        then a1 = a2 by Th2;
        hence it1 = it2 by A6,A8,A14,Th2;
      end;
      suppose
A15:    i = SubFrom(a1, b1) & i = SubFrom(a2, b2);
        then a1 = a2 by Th3;
        hence it1 = it2 by A6,A8,A15,Th3;
      end;
      suppose
A16:    i = MultBy(a1, b1) & i = MultBy(a2, b2);
        then a1 = a2 by Th4;
        hence it1 = it2 by A6,A8,A16,Th4;
      end;
      suppose
A17:    i = Divide(a1, b1) & i = Divide(a2, b2);
        then a1 = a2 by Th5;
        hence it1 = it2 by A6,A8,A17,Th5;
      end;
    end;
    hereby
      assume InsCode i = 7 or InsCode i = 8;
      given a1 being Int-Location, l1 being Element of NAT
      such that
A18:  i = a1=0_goto l1 or i = a1>0_goto l1 and
A19:  it1 = {a1};
      given a2 being Int-Location, l2 being Element of NAT
      such that
A20:  i = a2=0_goto l2 or i = a2>0_goto l2 and
A21:  it2 = {a2};
A22:  i = a1>0_goto l1 or i = a2>0_goto l2 implies InsCode i = 8 by SCMFSA_2:25
;
      per cases by A18,A20,A22,SCMFSA_2:24;
      suppose
        i = a1=0_goto l1 & i = a2=0_goto l2;
        hence it1 = it2 by A19,A21,Th7;
      end;
      suppose
        i = a1>0_goto l1 & i = a2>0_goto l2;
        hence it1 = it2 by A19,A21,Th8;
      end;
    end;
    hereby
      assume InsCode i = 9 or InsCode i = 10;
      given a1, b1 being Int-Location, f1 being FinSeq-Location such that
A23:  i = b1 := (f1, a1) or i = (f1, a1) := b1 and
A24:  it1 = {a1, b1};
      given a2, b2 being Int-Location, f2 being FinSeq-Location such that
A25:  i = b2 := (f2, a2) or i = (f2, a2) := b2 and
A26:  it2 = {a2, b2};
A27:  i = (f1, a1) := b1 or i = (f2, a2) := b2 implies InsCode i = 10 by
SCMFSA_2:27;
      per cases by A23,A25,A27,SCMFSA_2:26;
      suppose
A28:    i = b1 := (f1, a1) & i = b2 := (f2, a2);
        then a1 = a2 by Th9;
        hence it1 = it2 by A24,A26,A28,Th9;
      end;
      suppose
A29:    i = (f1, a1) := b1 & i = (f2, a2) := b2;
        then a1 = a2 by Th10;
        hence it1 = it2 by A24,A26,A29,Th10;
      end;
    end;
    hereby
      assume InsCode i = 11 or InsCode i = 12;
      given a1 being Int-Location, f1 being FinSeq-Location such that
A30:  i = a1 :=len f1 or i = f1 :=<0,...,0>a1 and
A31:  it1 = {a1};
      given a2 being Int-Location, f2 being FinSeq-Location such that
A32:  i = a2 :=len f2 or i = f2 :=<0,...,0>a2 and
A33:  it2 = {a2};
A34:  i = f1 :=<0,...,0>a1 or i = f2 :=<0,...,0>a2 implies InsCode i = 12
      by SCMFSA_2:29;
      per cases by A30,A32,A34,SCMFSA_2:28;
      suppose
        i = a1 :=len f1 & i = a2 :=len f2;
        hence it1 = it2 by A31,A33,Th11;
      end;
      suppose
        i = f1 :=<0,...,0>a1 & i = f2 :=<0,...,0>a2;
        hence it1 = it2 by A31,A33,Th12;
      end;
    end;
    thus thesis;
  end;
  consistency by ENUMSET1:def 3;
end;

theorem Th13:
  UsedIntLoc halt SCM+FSA = {}
proof
A1: InsCode halt SCM+FSA = 0 by COMPOS_1:70;
  not 0 in {1, 2, 3, 4, 5};
  hence thesis by Def1,A1;
end;

theorem Th14:
  i = a:=b or i = AddTo(a, b) or i = SubFrom(a, b) or i = MultBy(a
  , b) or i = Divide(a, b) implies UsedIntLoc i = {a, b}
proof
  reconsider ab = {a, b} as Element of Fin Int-Locations
     by FINSUB_1:def 5;
  assume
A1: i = a:=b or i = AddTo(a, b) or i = SubFrom(a, b) or i = MultBy(a, b)
  or i = Divide(a, b);
  then InsCode i = 1 or InsCode i = 2 or InsCode i = 3 or InsCode i = 4 or
  InsCode i = 5 by SCMFSA_2:18,19,20,21,22;
  then InsCode i in {1, 2, 3, 4, 5} by ENUMSET1:def 3;
  then UsedIntLoc i = ab by A1,Def1;
  hence thesis;
end;

theorem Th15:
  UsedIntLoc goto l = {}
proof
  InsCode goto l = 6 & not 6 in {1, 2, 3, 4, 5} by ENUMSET1:def 3,SCMFSA_2:23;
  hence thesis by Def1;
end;

theorem Th16:
  i = a=0_goto l or i = a>0_goto l implies UsedIntLoc i = {a}
proof
  reconsider ab = {a} as Element of Fin Int-Locations by FINSUB_1:def 5;
  assume
A1: i = a=0_goto l or i = a>0_goto l;
  then InsCode i = 7 or InsCode i = 8 by SCMFSA_2:24,25;
  then UsedIntLoc i = ab by A1,Def1;
  hence thesis;
end;

theorem Th17:
  i = b := (f, a) or i = (f, a) := b implies UsedIntLoc i = {a, b}
proof
  reconsider ab = {a, b} as Element of Fin Int-Locations
   by FINSUB_1:def 5;
  assume
A1: i = b := (f, a) or i = (f, a) := b;
  then InsCode i = 9 or InsCode i = 10 by SCMFSA_2:26,27;
  then UsedIntLoc i = ab by A1,Def1;
  hence thesis;
end;

theorem Th18:
  i = a :=len f or i = f :=<0,...,0>a implies UsedIntLoc i = {a}
proof
  reconsider ab = {a} as Element of Fin Int-Locations by FINSUB_1:def 5;
  assume
A1: i = a :=len f or i = f :=<0,...,0>a;
  then InsCode i = 11 or InsCode i = 12 by SCMFSA_2:28,29;
  then UsedIntLoc i = ab by A1,Def1;
  hence thesis;
end;

definition
  let p be Function;
  func UsedIntLoc p -> Subset of Int-Locations means
  :Def2:
  ex UIL being
  Function of the InstructionsF of SCM+FSA, Fin Int-Locations st (for i being
  Instruction of SCM+FSA holds UIL.i = UsedIntLoc i) & it = Union (UIL * p);
  existence
  proof
    defpred P[set,set] means ex I being Instruction of SCM+FSA st $1 = I & $2
    = UsedIntLoc I;
A1: for e being Element of the InstructionsF of SCM+FSA ex u being Element
    of Fin Int-Locations st P[e,u]
    proof
      let e be Element of the InstructionsF of SCM+FSA;
      reconsider f = e as Instruction of SCM+FSA;
      reconsider u = UsedIntLoc f as Element of Fin Int-Locations;
      take u, f;
      thus thesis;
    end;
    consider UIL being Function of the InstructionsF of SCM+FSA, Fin
    Int-Locations such that
A2: for i being Element of the InstructionsF of SCM+FSA holds P[i,UIL.i
    ] from FUNCT_2:sch 3(A1);
    set IT = Union (UIL * p), dp = dom p, Up =UIL * p;
    take IT;
    Fin Int-Locations c= bool Int-Locations by FINSUB_1:13;
    then rng Up c= rng UIL & rng UIL c= bool Int-Locations by RELAT_1:26
,XBOOLE_1:1;
    then rng Up c= bool Int-Locations by XBOOLE_1:1;
    then IT = union rng Up & union rng Up c= union bool Int-Locations by
CARD_3:def 4,ZFMISC_1:77;
    hence IT is Subset of Int-Locations by ZFMISC_1:81;
    take UIL;
    hereby
      let i be Instruction of SCM+FSA;
      P[i,UIL.i] by A2;
      hence UIL.i = UsedIntLoc i;
    end;
    thus thesis;
  end;
  uniqueness
  proof
    let IT1, IT2 be Subset of Int-Locations;
    given UIL1 being Function of the InstructionsF of SCM+FSA, Fin
    Int-Locations such that
A3: for i being Instruction of SCM+FSA holds UIL1.i = UsedIntLoc i and
A4: IT1 = Union (UIL1 * p);
    given UIL2 being Function of the InstructionsF of SCM+FSA, Fin
    Int-Locations such that
A5: for i being Instruction of SCM+FSA holds UIL2.i = UsedIntLoc i and
A6: IT2 = Union (UIL2 * p);
    for c be Element of the InstructionsF of SCM+FSA holds UIL1.c = UIL2.c
    proof
      let c be Element of the InstructionsF of SCM+FSA;
      reconsider d = c as Instruction of SCM+FSA;
      thus UIL1.c = UsedIntLoc d by A3
        .= UIL2.c by A5;
    end;
    hence thesis by A4,A6,FUNCT_2:63;
  end;
end;

registration
  let p be preProgram of SCM+FSA;
  cluster UsedIntLoc p -> finite;
  coherence
  proof
    reconsider dp = dom p as finite set;
    consider UIL being Function of the InstructionsF of SCM+FSA, Fin
    Int-Locations such that
    for i being Instruction of SCM+FSA holds UIL.i = UsedIntLoc i and
A1: UsedIntLoc p = Union (UIL * p) by Def2;
    rng p c= the InstructionsF of SCM+FSA;
    then reconsider p9 = p as Function of dp, the InstructionsF of SCM+FSA by
FUNCT_2:2;
    reconsider Up = UIL * p9 as Function of dp, Fin Int-Locations;
    Union Up is finite;
    hence thesis by A1;
  end;
end;

reserve p, r for preProgram of SCM+FSA,
  I, J for Program of SCM+FSA,
  k, m, n for Element of NAT;

theorem Th19:
  i in rng p implies UsedIntLoc i c= UsedIntLoc p
proof
  assume i in rng p;
  then consider x being set such that
A1: x in dom p & i = p.x by FUNCT_1:def 3;
  consider UIL being Function of the InstructionsF of SCM+FSA, Fin
  Int-Locations such that
A2: for i being Instruction of SCM+FSA holds UIL.i = UsedIntLoc i and
A3: UsedIntLoc p = Union (UIL * p) by Def2;
A4: UsedIntLoc p = union rng (UIL * p) by A3,CARD_3:def 4;
  dom UIL = the InstructionsF of SCM+FSA by FUNCT_2:def 1;
  then x in dom (UIL * p) by A1,FUNCT_1:11;
  then
A5: (UIL * p).x in rng (UIL * p) by FUNCT_1:def 3;
  (UIL * p).x = UIL.i by A1,FUNCT_1:13
    .= UsedIntLoc i by A2;
  hence thesis by A5,A4,ZFMISC_1:74;
end;

theorem
  UsedIntLoc (p +* r) c= (UsedIntLoc p) \/ (UsedIntLoc r)
proof
  consider UIL being Function of the InstructionsF of SCM+FSA, Fin
  Int-Locations such that
A1: for i being Instruction of SCM+FSA holds UIL.i = UsedIntLoc i and
A2: UsedIntLoc (p +* r) = Union (UIL * (p +* r)) by Def2;
  consider UIL1 being Function of the InstructionsF of SCM+FSA, Fin
  Int-Locations such that
A3: for i being Instruction of SCM+FSA holds UIL1.i = UsedIntLoc i and
A4: UsedIntLoc p = Union (UIL1 * p) by Def2;
  for c be Element of the InstructionsF of SCM+FSA holds UIL.c = UIL1.c
  proof
    let c be Element of the InstructionsF of SCM+FSA;
    reconsider d = c as Instruction of SCM+FSA;
    thus UIL.c = UsedIntLoc d by A1
      .= UIL1.c by A3;
  end;
  then
A5: UIL=UIL1 by FUNCT_2:63;
  consider UIL2 being Function of the InstructionsF of SCM+FSA, Fin
  Int-Locations such that
A6: for i being Instruction of SCM+FSA holds UIL2.i = UsedIntLoc i and
A7: UsedIntLoc r = Union (UIL2 * r) by Def2;
  for c be Element of the InstructionsF of SCM+FSA holds UIL.c = UIL2.c
  proof
    let c be Element of the InstructionsF of SCM+FSA;
    reconsider d = c as Instruction of SCM+FSA;
    thus UIL.c = UsedIntLoc d by A1
      .= UIL2.c by A6;
  end;
  then
A8: UIL=UIL2 by FUNCT_2:63;
  dom UIL = the InstructionsF of SCM+FSA by FUNCT_2:def 1;
  then rng r c= dom UIL;
  then UIL * (p +* r) = (UIL * p) +* (UIL * r) by FUNCT_7:9;
  then
A9: Union (UIL * r) = union rng (UIL * r) & union rng (UIL * (p +* r)) c=
  union (rng (UIL * p) \/ rng (UIL * r)) by CARD_3:def 4,FUNCT_4:17,ZFMISC_1:77
;
  Union (UIL * (p +* r)) = union rng (UIL * (p +* r)) & Union (UIL * p) =
  union rng (UIL * p) by CARD_3:def 4;
  hence thesis by A2,A4,A7,A5,A8,A9,ZFMISC_1:78;
end;

theorem Th21:
  dom p misses dom r implies UsedIntLoc (p +* r) = (UsedIntLoc p)
  \/ (UsedIntLoc r)
proof
  consider UIL being Function of the InstructionsF of SCM+FSA, Fin
  Int-Locations such that
A1: for i being Instruction of SCM+FSA holds UIL.i = UsedIntLoc i and
A2: UsedIntLoc (p +* r) = Union (UIL * (p +* r)) by Def2;
  assume dom p misses dom r;
  then dom (UIL * p) c= dom p & dom p misses dom (UIL * r) by RELAT_1:25
,XBOOLE_1:63;
  then
A3: (UIL * p) +* (UIL * r) = (UIL * p) \/ (UIL * r) by FUNCT_4:31,XBOOLE_1:63;
  dom UIL = the InstructionsF of SCM+FSA by FUNCT_2:def 1;
  then rng r c= dom UIL;
  then UIL * (p +* r) = (UIL * p) +* (UIL * r) by FUNCT_7:9;
  then
A4: Union (UIL * r) = union rng (UIL * r) & union rng (UIL * (p +* r)) =
  union ( rng (UIL * p) \/ rng (UIL * r)) by A3,CARD_3:def 4,RELAT_1:12;
  consider UIL1 being Function of the InstructionsF of SCM+FSA, Fin
  Int-Locations such that
A5: for i being Instruction of SCM+FSA holds UIL1.i = UsedIntLoc i and
A6: UsedIntLoc p = Union (UIL1 * p) by Def2;
  for c be Element of the InstructionsF of SCM+FSA holds UIL.c = UIL1.c
  proof
    let c be Element of the InstructionsF of SCM+FSA;
    reconsider d = c as Instruction of SCM+FSA;
    thus UIL.c = UsedIntLoc d by A1
      .= UIL1.c by A5;
  end;
  then
A7: UIL=UIL1 by FUNCT_2:63;
  consider UIL2 being Function of the InstructionsF of SCM+FSA, Fin
  Int-Locations such that
A8: for i being Instruction of SCM+FSA holds UIL2.i = UsedIntLoc i and
A9: UsedIntLoc r = Union (UIL2 * r) by Def2;
  for c be Element of the InstructionsF of SCM+FSA holds UIL.c = UIL2.c
  proof
    let c be Element of the InstructionsF of SCM+FSA;
    reconsider d = c as Instruction of SCM+FSA;
    thus UIL.c = UsedIntLoc d by A1
      .= UIL2.c by A8;
  end;
  then
A10: UIL=UIL2 by FUNCT_2:63;
  Union (UIL * (p +* r)) = union rng (UIL * (p +* r)) & Union (UIL * p) =
  union rng (UIL * p) by CARD_3:def 4;
  hence thesis by A2,A6,A9,A7,A10,A4,ZFMISC_1:78;
end;

theorem Th22:
  UsedIntLoc p = UsedIntLoc Shift(p, k)
proof
  set Sp = Shift (p, k);
  consider UIL being Function of the InstructionsF of SCM+FSA, Fin
  Int-Locations such that
A1: for i being Instruction of SCM+FSA holds UIL.i = UsedIntLoc i and
A2: UsedIntLoc p = Union (UIL * p) by Def2;
  consider UIL2 being Function of the InstructionsF of SCM+FSA, Fin
  Int-Locations such that
A3: for i being Instruction of SCM+FSA holds UIL2.i = UsedIntLoc i and
A4: UsedIntLoc Shift (p, k) = Union (UIL2 * Shift (p, k)) by Def2;
  for c be Element of the InstructionsF of SCM+FSA holds UIL.c = UIL2.c
  proof
    let c be Element of the InstructionsF of SCM+FSA;
    reconsider d = c as Instruction of SCM+FSA;
    thus UIL.c = UsedIntLoc d by A1
      .= UIL2.c by A3;
  end;
  then
A5: UIL=UIL2 by FUNCT_2:63;
A6: dom Sp = { m+k where m is Element of NAT : m in dom p } by VALUED_1:def 12;
  now
    let y be set;
    hereby
      assume y in rng Sp;
      then consider x being set such that
A7:   x in dom Sp and
A8:   y = Sp.x by FUNCT_1:def 3;
      consider m being Element of NAT such that
A9:   x = m+k and
A10:  m in dom p by A6,A7;
      Sp.x = p. m by A9,A10,VALUED_1:def 12;
      hence y in rng p by A8,A10,FUNCT_1:def 3;
    end;
    assume y in rng p;
    then consider x being set such that
A11: x in dom p and
A12: y = p.x by FUNCT_1:def 3;
    reconsider x9 = x as Element of NAT by A11;
    reconsider m = x9 as Element of NAT;
     (m+k) in dom Sp & Sp. (m+k) = p. m by A6,A11,VALUED_1:def 12;
    hence y in rng Sp by A12,FUNCT_1:def 3;
  end;
  then
A13: rng Sp = rng p by TARSKI:1;
A14: Union (UIL * Sp) = union rng (UIL * Sp) by CARD_3:def 4;
  rng (UIL * Sp) = UIL.:rng Sp by RELAT_1:127
    .= rng (UIL * p) by A13,RELAT_1:127;
  hence thesis by A2,A4,A5,A14,CARD_3:def 4;
end;

theorem Th23:
  UsedIntLoc i = UsedIntLoc IncAddr(i, k)
proof
A1: InsCode i <= 12 by SCMFSA_2:16;
  per cases by A1,NAT_1:36;
  suppose
    InsCode i = 0;
    then i = halt SCM+FSA by SCMFSA_2:95;
    hence thesis by COMPOS_0:4;
  end;
  suppose
    InsCode i = 1;
    then ex a, b st i = a:=b by SCMFSA_2:30;
    hence thesis by COMPOS_0:4;
  end;
  suppose
    InsCode i = 2;
    then ex a, b st i = AddTo(a,b) by SCMFSA_2:31;
    hence thesis by COMPOS_0:4;
  end;
  suppose
    InsCode i = 3;
    then ex a, b st i = SubFrom(a, b) by SCMFSA_2:32;
    hence thesis by COMPOS_0:4;
  end;
  suppose
    InsCode i = 4;
    then ex a, b st i = MultBy(a, b) by SCMFSA_2:33;
    hence thesis by COMPOS_0:4;
  end;
  suppose
    InsCode i = 5;
    then ex a, b st i = Divide(a, b) by SCMFSA_2:34;
    hence thesis by COMPOS_0:4;
  end;
  suppose
    InsCode i = 6;
    then consider l such that
A2: i = goto l by SCMFSA_2:35;
    IncAddr(i, k) = goto (l+k) by A2,SCMFSA_4:1;
    hence UsedIntLoc IncAddr(i, k) = {} by Th15
      .= UsedIntLoc i by A2,Th15;
  end;
  suppose
    InsCode i = 7;
    then consider l, a such that
A3: i = a=0_goto l by SCMFSA_2:36;
    IncAddr(i, k) = a=0_goto (l+k) by A3,SCMFSA_4:2;
    hence UsedIntLoc IncAddr(i, k) = {a} by Th16
      .= UsedIntLoc i by A3,Th16;
  end;
  suppose
    InsCode i = 8;
    then consider l, a such that
A4: i = a>0_goto l by SCMFSA_2:37;
    IncAddr(i, k) = a>0_goto (l+k) by A4,SCMFSA_4:3;
    hence UsedIntLoc IncAddr(i, k) = {a} by Th16
      .= UsedIntLoc i by A4,Th16;
  end;
  suppose
    InsCode i = 9;
    then ex a, b, f st i = b:=(f,a) by SCMFSA_2:38;
    hence thesis by COMPOS_0:4;
  end;
  suppose
    InsCode i = 10;
    then ex a, b, f st i = (f,a):=b by SCMFSA_2:39;
    hence thesis by COMPOS_0:4;
  end;
  suppose
    InsCode i = 11;
    then ex a, f st i = a:=len f by SCMFSA_2:40;
    hence thesis by COMPOS_0:4;
  end;
  suppose
    InsCode i = 12;
    then ex a,f st i = f:=<0,...,0>a by SCMFSA_2:41;
    hence thesis by COMPOS_0:4;
  end;
end;

theorem Th24:
  UsedIntLoc p = UsedIntLoc IncAddr(p, k)
proof
  set Ip = IncAddr (p, k);
  consider UIL being Function of the InstructionsF of SCM+FSA, Fin
  Int-Locations such that
A1: for i being Instruction of SCM+FSA holds UIL.i = UsedIntLoc i and
A2: UsedIntLoc p = Union (UIL * p) by Def2;
  set g = UIL * p;
  set f = UIL * Ip;
  consider UIL2 being Function of the InstructionsF of SCM+FSA, Fin
  Int-Locations such that
A3: for i being Instruction of SCM+FSA holds UIL2.i = UsedIntLoc i and
A4: UsedIntLoc IncAddr (p, k) = Union (UIL2 * IncAddr (p, k)) by Def2;
  for c be Element of the InstructionsF of SCM+FSA holds UIL.c = UIL2.c
  proof
    let c be Element of the InstructionsF of SCM+FSA;
    reconsider d = c as Instruction of SCM+FSA;
    thus UIL.c = UsedIntLoc d by A1
      .= UIL2.c by A3;
  end;
  then
A5: UIL=UIL2 by FUNCT_2:63;
  now
A6: dom UIL = the InstructionsF of SCM+FSA by FUNCT_2:def 1;
    then
A7: rng p c= dom UIL;
 rng Ip c= dom UIL by A6;
    then
A8: dom f = dom Ip by RELAT_1:27;
A9: dom Ip = dom p by COMPOS_1:def 21;
    hence dom f = dom g by A7,A8,RELAT_1:27;
    let x be set;
    assume
A10: x in dom f;
    then p.x in rng p by A9,A8,FUNCT_1:def 3;
    then reconsider px = p.x as Instruction of SCM+FSA;
    reconsider x9 = x as Element of NAT by A8,A10;
    reconsider m = x9 as Element of NAT;
A11: Ip.x = IncAddr(p/.m,k) by A9,A8,A10,COMPOS_1:def 21
      .= IncAddr(px, k) by A9,A8,A10,PARTFUN1:def 6;
    Ip.x in rng Ip by A8,A10,FUNCT_1:def 3;
    then reconsider Ipx = Ip.x as Instruction of SCM+FSA;
    thus f.x = UIL.Ipx by A10,FUNCT_1:12
      .= UsedIntLoc Ipx by A1
      .= UsedIntLoc px by A11,Th23
      .= UIL.px by A3,A5
      .= g.x by A9,A8,A10,FUNCT_1:13;
  end;
  hence thesis by A2,A4,A5,FUNCT_1:2;
end;

theorem Th25:
  UsedIntLoc I = UsedIntLoc Reloc(I, k)
proof
A1:  Reloc(I,k) = IncAddr(Shift(I,k),k) by COMPOS_1:34;
  UsedIntLoc Reloc(I, k) = UsedIntLoc Reloc(I,k)
    .= UsedIntLoc Shift (I, k) by Th24,A1
    .= UsedIntLoc I by Th22;
  hence thesis;
end;

theorem Th26:
  UsedIntLoc I = UsedIntLoc Directed I
proof
  consider UIL being Function of the InstructionsF of SCM+FSA, Fin
  Int-Locations such that
A1: for i being Instruction of SCM+FSA holds UIL.i = UsedIntLoc i and
A2: UsedIntLoc I = Union (UIL * I) by Def2;
A3: dom UIL = the InstructionsF of SCM+FSA & UIL.halt SCM+FSA = {} by A1,Th13,
FUNCT_2:def 1;
  consider UIL2 being Function of the InstructionsF of SCM+FSA, Fin
  Int-Locations such that
A4: for i being Instruction of SCM+FSA holds UIL2.i = UsedIntLoc i and
A5: UsedIntLoc Directed I = Union (UIL2 * Directed I) by Def2;
A6: for c be Element of the InstructionsF of SCM+FSA holds UIL.c = UIL2.c
  proof
    let c be Element of the InstructionsF of SCM+FSA;
    reconsider d = c as Instruction of SCM+FSA;
    thus UIL.c = UsedIntLoc d by A1
      .= UIL2.c by A4;
  end;
A7: UIL.goto  card I = UsedIntLoc goto  card I by A1
    .= {} by Th15;
  rng I c= the InstructionsF of SCM+FSA;
  then UIL * Directed I = UIL * (((id the InstructionsF of SCM+FSA) +* (halt
  SCM+FSA, goto  card I))*I) by FUNCT_7:116
    .= UIL * ((id the InstructionsF of SCM+FSA) +* (halt SCM+FSA, goto
  card I)) * I by RELAT_1:36
    .= UIL * I by A3,A7,FUNCT_7:108;
  hence thesis by A2,A5,A6,FUNCT_2:63;
end;

theorem Th27:
  UsedIntLoc (I ";" J) = (UsedIntLoc I) \/ (UsedIntLoc J)
proof
  dom I = dom Directed I by FUNCT_4:99;
  then dom (Directed I) misses dom (Reloc(J, card I)) by COMPOS_1:48;
  hence UsedIntLoc (I ";" J) = UsedIntLoc (Directed I) \/ UsedIntLoc
  Reloc(J, card I) by Th21
    .= (UsedIntLoc I) \/ UsedIntLoc Reloc(J, card I) by Th26
    .= (UsedIntLoc I) \/ (UsedIntLoc J) by Th25;
end;

theorem Th28:
  UsedIntLoc Macro i = UsedIntLoc i
proof
  consider UIL being Function of the InstructionsF of SCM+FSA, Fin
  Int-Locations such that
A1: for i being Instruction of SCM+FSA holds UIL.i = UsedIntLoc i and
A2: UsedIntLoc Macro i = Union (UIL * Macro i) by Def2;
A3: rng Macro i = {i, halt SCM+FSA} &
    dom UIL = the InstructionsF of SCM+FSA by COMPOS_1:67,FUNCT_2:def 1;
  thus UsedIntLoc Macro i = union rng (UIL * Macro i) by A2,CARD_3:def 4
    .= union (UIL.:rng Macro i) by RELAT_1:127
    .= union {UIL.i,UIL.halt SCM+FSA} by A3,FUNCT_1:60
    .= UIL.i \/ UIL.halt SCM+FSA by ZFMISC_1:75
    .= (UsedIntLoc i) \/ UIL.halt SCM+FSA by A1
    .= (UsedIntLoc i) \/ (UsedIntLoc halt SCM+FSA) by A1
    .= UsedIntLoc i by Th13;
end;

theorem
  UsedIntLoc (i ";" J) = (UsedIntLoc i) \/ UsedIntLoc J
proof
  thus UsedIntLoc (i ";" J) = (UsedIntLoc Macro i) \/ UsedIntLoc J by Th27
    .= (UsedIntLoc i) \/ UsedIntLoc J by Th28;
end;

theorem
  UsedIntLoc (I ";" j) = (UsedIntLoc I) \/ UsedIntLoc j
proof
  thus UsedIntLoc (I ";" j) = (UsedIntLoc I) \/ UsedIntLoc Macro j by Th27
    .= (UsedIntLoc I) \/ UsedIntLoc j by Th28;
end;

theorem
  UsedIntLoc (i ";" j) = (UsedIntLoc i) \/ UsedIntLoc j
proof
  thus UsedIntLoc (i ";" j) = (UsedIntLoc Macro i) \/ UsedIntLoc Macro j by
Th27
    .= (UsedIntLoc Macro i) \/ UsedIntLoc j by Th28
    .= (UsedIntLoc i) \/ UsedIntLoc j by Th28;
end;

begin :: Finite sequence locations used in macro instructions

definition
  let i be Instruction of SCM+FSA;
  func UsedInt*Loc i -> Element of Fin FinSeq-Locations means
  :Def3:
  ex a, b
  being Int-Location, f being FinSeq-Location st (i = b := (f, a) or i = (f, a)
:= b) & it = {f} if InsCode i = 9 or InsCode i = 10, ex a being Int-Location, f
  being FinSeq-Location st (i = a :=len f or i = f :=<0,...,0>a) & it = {f} if
  InsCode i = 11 or InsCode i = 12 otherwise it = {};
  existence
  proof
    hereby
      assume InsCode i = 9 or InsCode i = 10;
      then consider a, b being Int-Location, f being FinSeq-Location such that
A1:   i = b := (f, a) or i = (f, a) := b by SCMFSA_2:38,39;
      reconsider f9 = f as Element of FinSeq-Locations by SCMFSA_2:def 5;
      reconsider IT = {.f9.} as Element of Fin FinSeq-Locations;
      take IT;
      take a, b, f;
      thus (i = b := (f, a) or i = (f, a) := b) & IT = {f} by A1;
    end;
    hereby
      assume InsCode i = 11 or InsCode i = 12;
      then consider a being Int-Location, f being FinSeq-Location such that
A2:   i = a :=len f or i = f :=<0,...,0>a by SCMFSA_2:40,41;
      reconsider f9 = f as Element of FinSeq-Locations by SCMFSA_2:def 5;
      reconsider IT = {.f9.} as Element of Fin FinSeq-Locations;
      take IT;
      take a, f;
      thus (i = a :=len f or i = f :=<0,...,0>a) & IT = {f} by A2;
    end;
    {} in Fin FinSeq-Locations by FINSUB_1:7;
    hence thesis;
  end;
  uniqueness
  proof
    let it1, it2 be Element of Fin FinSeq-Locations;
    hereby
      assume InsCode i = 9 or InsCode i = 10;
      given a1, b1 being Int-Location, f1 being FinSeq-Location such that
A3:   i = b1 := (f1, a1) or i = (f1, a1) := b1 and
A4:   it1 = {f1};
      given a2, b2 being Int-Location, f2 being FinSeq-Location such that
A5:   i = b2 := (f2, a2) or i = (f2, a2) := b2 and
A6:   it2 = {f2};
A7:   i = (f1, a1) := b1 or i = (f2, a2) := b2 implies InsCode i = 10 by
SCMFSA_2:27;
      per cases by A3,A5,A7,SCMFSA_2:26;
      suppose
        i = b1 := (f1, a1) & i = b2 := (f2, a2);
        hence it1 = it2 by A4,A6,Th9;
      end;
      suppose
        i = (f1, a1) := b1 & i = (f2, a2) := b2;
        hence it1 = it2 by A4,A6,Th10;
      end;
    end;
    hereby
      assume InsCode i = 11 or InsCode i = 12;
      given a1 being Int-Location, f1 being FinSeq-Location such that
A8:   i = a1 :=len f1 or i = f1 :=<0,...,0>a1 and
A9:   it1 = {f1};
      given a2 being Int-Location, f2 being FinSeq-Location such that
A10:  i = a2 :=len f2 or i = f2 :=<0,...,0>a2 and
A11:  it2 = {f2};
A12:  i = f1 :=<0,...,0>a1 or i = f2 :=<0,...,0>a2 implies InsCode i = 12
      by SCMFSA_2:29;
      per cases by A8,A10,A12,SCMFSA_2:28;
      suppose
        i = a1 :=len f1 & i = a2 :=len f2;
        hence it1 = it2 by A9,A11,Th11;
      end;
      suppose
        i = f1 :=<0,...,0>a1 & i = f2 :=<0,...,0>a2;
        hence it1 = it2 by A9,A11,Th12;
      end;
    end;
    thus thesis;
  end;
  consistency;
end;

theorem Th32:
  i = halt SCM+FSA or i = a:=b or i = AddTo(a, b) or i = SubFrom(a
, b) or i = MultBy(a, b) or i = Divide(a, b) or i = goto l or i = a=0_goto l or
  i = a>0_goto l implies UsedInt*Loc i = {}
proof
  assume i = halt SCM+FSA or i = a:=b or i = AddTo(a, b) or i = SubFrom(a, b)
or i = MultBy(a, b) or i = Divide(a, b) or i = goto l or i = a=0_goto l or i =
  a>0_goto l;
  then InsCode i = 0 or InsCode i = 1 or InsCode i = 2 or InsCode i = 3 or
InsCode i = 4 or InsCode i = 5 or InsCode i = 6 or InsCode i = 7 or InsCode i =
  8 by COMPOS_1:70,SCMFSA_2:18,19,20,21,22,23,24,25;
  hence thesis by Def3;
end;

theorem Th33:
  i = b := (f, a) or i = (f, a) := b implies UsedInt*Loc i = {f}
proof
  f in FinSeq-Locations by SCMFSA_2:def 5;
  then {f} c= FinSeq-Locations by ZFMISC_1:31;
  then reconsider ab = {f} as Element of Fin FinSeq-Locations by FINSUB_1:def 5
;
  assume
A1: i = b := (f, a) or i = (f, a) := b;
  then InsCode i = 9 or InsCode i = 10 by SCMFSA_2:26,27;
  then UsedInt*Loc i = ab by A1,Def3;
  hence thesis;
end;

theorem Th34:
  i = a :=len f or i = f :=<0,...,0>a implies UsedInt*Loc i = {f}
proof
  f in FinSeq-Locations by SCMFSA_2:def 5;
  then {f} c= FinSeq-Locations by ZFMISC_1:31;
  then reconsider ab = {f} as Element of Fin FinSeq-Locations by FINSUB_1:def 5
;
  assume
A1: i = a :=len f or i = f :=<0,...,0>a;
  then InsCode i = 11 or InsCode i = 12 by SCMFSA_2:28,29;
  then UsedInt*Loc i = ab by A1,Def3;
  hence thesis;
end;

definition
  let p be Function;
  func UsedInt*Loc p -> Subset of FinSeq-Locations means
  :Def4:
  ex UIL being
  Function of the InstructionsF of SCM+FSA, Fin FinSeq-Locations
   st (for i being
  Instruction of SCM+FSA holds UIL.i = UsedInt*Loc i) & it = Union (UIL * p);
  existence
  proof
    defpred P[set,set] means ex I being Instruction of SCM+FSA st $1 = I & $2
    = UsedInt*Loc I;
A1: for e being Element of the InstructionsF of SCM+FSA ex u being Element
    of Fin FinSeq-Locations st P[e,u]
    proof
      let e be Element of the InstructionsF of SCM+FSA;
      reconsider f = e as Instruction of SCM+FSA;
      reconsider u = UsedInt*Loc f as Element of Fin FinSeq-Locations;
      take u, f;
      thus thesis;
    end;
    consider UIL being Function of the InstructionsF of SCM+FSA, Fin
    FinSeq-Locations such that
A2: for i being Element of the InstructionsF of SCM+FSA holds P[i,UIL.i
    ] from FUNCT_2:sch 3(A1);
    set IT = Union (UIL * p), dp = dom p, Up = UIL * p;
    take IT;
    Fin FinSeq-Locations c= bool FinSeq-Locations by FINSUB_1:13;
    then rng Up c= rng UIL & rng UIL c= bool FinSeq-Locations by RELAT_1:26
,XBOOLE_1:1;
    then rng Up c= bool FinSeq-Locations by XBOOLE_1:1;
    then IT = union rng Up & union rng Up c= union bool FinSeq-Locations by
CARD_3:def 4,ZFMISC_1:77;
    hence IT is Subset of FinSeq-Locations by ZFMISC_1:81;
    take UIL;
    hereby
      let i be Instruction of SCM+FSA;
      P[i,UIL.i] by A2;
      hence UIL.i = UsedInt*Loc i;
    end;
    thus thesis;
  end;
  uniqueness
  proof
    let IT1, IT2 be Subset of FinSeq-Locations;
    given UIL1 being Function of the InstructionsF of SCM+FSA, Fin
    FinSeq-Locations such that
A3: for i being Instruction of SCM+FSA holds UIL1.i = UsedInt*Loc i and
A4: IT1 = Union (UIL1 * p);
    given UIL2 being Function of the InstructionsF of SCM+FSA, Fin
    FinSeq-Locations such that
A5: for i being Instruction of SCM+FSA holds UIL2.i = UsedInt*Loc i and
A6: IT2 = Union (UIL2 * p);
    for c be Element of the InstructionsF of SCM+FSA holds UIL1.c = UIL2.c
    proof
      let c be Element of the InstructionsF of SCM+FSA;
      reconsider d = c as Instruction of SCM+FSA;
      thus UIL1.c = UsedInt*Loc d by A3
        .= UIL2.c by A5;
    end;
    hence thesis by A4,A6,FUNCT_2:63;
  end;
end;

registration
  let p be preProgram of SCM+FSA;
  cluster UsedInt*Loc p -> finite;
  coherence
  proof
    reconsider dp = dom p as finite set;
    consider UIL being Function of the InstructionsF of SCM+FSA, Fin
    FinSeq-Locations such that
    for i being Instruction of SCM+FSA holds UIL.i = UsedInt*Loc i and
A1: UsedInt*Loc p = Union (UIL * p) by Def4;
    rng p c= the InstructionsF of SCM+FSA;
    then reconsider p9 = p as Function of dp, the InstructionsF of SCM+FSA by
FUNCT_2:2;
    reconsider Up = UIL * p9 as Function of dp, Fin FinSeq-Locations;
    Union Up is finite;
    hence thesis by A1;
  end;
end;

theorem Th35:
  i in rng p implies UsedInt*Loc i c= UsedInt*Loc p
proof
  assume i in rng p;
  then consider x being set such that
A1: x in dom p & i = p.x by FUNCT_1:def 3;
  consider UIL being Function of the InstructionsF of SCM+FSA, Fin
  FinSeq-Locations such that
A2: for i being Instruction of SCM+FSA holds UIL.i = UsedInt*Loc i and
A3: UsedInt*Loc p = Union (UIL * p) by Def4;
A4: UsedInt*Loc p = union rng (UIL * p) by A3,CARD_3:def 4;
  dom UIL = the InstructionsF of SCM+FSA by FUNCT_2:def 1;
  then x in dom (UIL * p) by A1,FUNCT_1:11;
  then
A5: (UIL * p).x in rng (UIL * p) by FUNCT_1:def 3;
  (UIL * p).x = UIL.i by A1,FUNCT_1:13
    .= UsedInt*Loc i by A2;
  hence thesis by A5,A4,ZFMISC_1:74;
end;

theorem
  UsedInt*Loc (p +* r) c= (UsedInt*Loc p) \/ (UsedInt*Loc r)
proof
  consider UIL being Function of the InstructionsF of SCM+FSA, Fin
  FinSeq-Locations such that
A1: for i being Instruction of SCM+FSA holds UIL.i = UsedInt*Loc i and
A2: UsedInt*Loc (p +* r) = Union (UIL * (p +* r)) by Def4;
  consider UIL1 being Function of the InstructionsF of SCM+FSA, Fin
  FinSeq-Locations such that
A3: for i being Instruction of SCM+FSA holds UIL1.i = UsedInt*Loc i and
A4: UsedInt*Loc p = Union (UIL1 * p) by Def4;
  for c be Element of the InstructionsF of SCM+FSA holds UIL.c = UIL1.c
  proof
    let c be Element of the InstructionsF of SCM+FSA;
    reconsider d = c as Instruction of SCM+FSA;
    thus UIL.c = UsedInt*Loc d by A1
      .= UIL1.c by A3;
  end;
  then
A5: UIL=UIL1 by FUNCT_2:63;
  consider UIL2 being Function of the InstructionsF of SCM+FSA, Fin
  FinSeq-Locations such that
A6: for i being Instruction of SCM+FSA holds UIL2.i = UsedInt*Loc i and
A7: UsedInt*Loc r = Union (UIL2 * r) by Def4;
  for c be Element of the InstructionsF of SCM+FSA holds UIL.c = UIL2.c
  proof
    let c be Element of the InstructionsF of SCM+FSA;
    reconsider d = c as Instruction of SCM+FSA;
    thus UIL.c = UsedInt*Loc d by A1
      .= UIL2.c by A6;
  end;
  then
A8: UIL=UIL2 by FUNCT_2:63;
  dom UIL = the InstructionsF of SCM+FSA by FUNCT_2:def 1;
  then rng r c= dom UIL;
  then UIL * (p +* r) = (UIL * p) +* (UIL * r) by FUNCT_7:9;
  then
A9: Union (UIL * r) = union rng (UIL * r) & union rng (UIL * (p +* r)) c=
  union (rng (UIL * p) \/ rng (UIL * r)) by CARD_3:def 4,FUNCT_4:17,ZFMISC_1:77
;
  Union (UIL * (p +* r)) = union rng (UIL * (p +* r)) & Union (UIL * p) =
  union rng (UIL * p) by CARD_3:def 4;
  hence thesis by A2,A4,A7,A5,A8,A9,ZFMISC_1:78;
end;

theorem Th37:
  dom p misses dom r implies UsedInt*Loc (p +* r) = (UsedInt*Loc p
  ) \/ (UsedInt*Loc r)
proof
  consider UIL being Function of the InstructionsF of SCM+FSA, Fin
  FinSeq-Locations such that
A1: for i being Instruction of SCM+FSA holds UIL.i = UsedInt*Loc i and
A2: UsedInt*Loc (p +* r) = Union (UIL * (p +* r)) by Def4;
  assume dom p misses dom r;
  then dom (UIL * p) c= dom p & dom p misses dom (UIL * r) by RELAT_1:25
,XBOOLE_1:63;
  then
A3: (UIL * p) +* (UIL * r) = (UIL * p) \/ (UIL * r) by FUNCT_4:31,XBOOLE_1:63;
  dom UIL = the InstructionsF of SCM+FSA by FUNCT_2:def 1;
  then rng r c= dom UIL;
  then UIL * (p +* r) = (UIL * p) +* (UIL * r) by FUNCT_7:9;
  then
A4: Union (UIL * r) = union rng (UIL * r) & union rng (UIL * (p +* r)) =
  union ( rng (UIL * p) \/ rng (UIL * r)) by A3,CARD_3:def 4,RELAT_1:12;
  consider UIL1 being Function of the InstructionsF of SCM+FSA, Fin
  FinSeq-Locations such that
A5: for i being Instruction of SCM+FSA holds UIL1.i = UsedInt*Loc i and
A6: UsedInt*Loc p = Union (UIL1 * p) by Def4;
  for c be Element of the InstructionsF of SCM+FSA holds UIL.c = UIL1.c
  proof
    let c be Element of the InstructionsF of SCM+FSA;
    reconsider d = c as Instruction of SCM+FSA;
    thus UIL.c = UsedInt*Loc d by A1
      .= UIL1.c by A5;
  end;
  then
A7: UIL=UIL1 by FUNCT_2:63;
  consider UIL2 being Function of the InstructionsF of SCM+FSA, Fin
  FinSeq-Locations such that
A8: for i being Instruction of SCM+FSA holds UIL2.i = UsedInt*Loc i and
A9: UsedInt*Loc r = Union (UIL2 * r) by Def4;
  for c be Element of the InstructionsF of SCM+FSA holds UIL.c = UIL2.c
  proof
    let c be Element of the InstructionsF of SCM+FSA;
    reconsider d = c as Instruction of SCM+FSA;
    thus UIL.c = UsedInt*Loc d by A1
      .= UIL2.c by A8;
  end;
  then
A10: UIL=UIL2 by FUNCT_2:63;
  Union (UIL * (p +* r)) = union rng (UIL * (p +* r)) & Union (UIL * p) =
  union rng (UIL * p) by CARD_3:def 4;
  hence thesis by A2,A6,A9,A7,A10,A4,ZFMISC_1:78;
end;

theorem Th38:
  UsedInt*Loc p = UsedInt*Loc Shift(p, k)
proof
  set Sp = Shift (p, k);
  consider UIL being Function of the InstructionsF of SCM+FSA, Fin
  FinSeq-Locations such that
A1: for i being Instruction of SCM+FSA holds UIL.i = UsedInt*Loc i and
A2: UsedInt*Loc p = Union (UIL * p) by Def4;
  consider UIL2 being Function of the InstructionsF of SCM+FSA, Fin
  FinSeq-Locations such that
A3: for i being Instruction of SCM+FSA holds UIL2.i = UsedInt*Loc i and
A4: UsedInt*Loc Shift (p, k) = Union (UIL2 * Shift (p, k)) by Def4;
  for c be Element of the InstructionsF of SCM+FSA holds UIL.c = UIL2.c
  proof
    let c be Element of the InstructionsF of SCM+FSA;
    reconsider d = c as Instruction of SCM+FSA;
    thus UIL.c = UsedInt*Loc d by A1
      .= UIL2.c by A3;
  end;
  then
A5: UIL=UIL2 by FUNCT_2:63;
A6: dom Sp = { m+k where m is Element of NAT : m in dom p } by VALUED_1:def 12;
  now
    let y be set;
    hereby
      assume y in rng Sp;
      then consider x being set such that
A7:   x in dom Sp and
A8:   y = Sp.x by FUNCT_1:def 3;
      consider m being Element of NAT such that
A9:   x = m+k and
A10:  m in dom p by A6,A7;
      Sp.x = p. m by A9,A10,VALUED_1:def 12;
      hence y in rng p by A8,A10,FUNCT_1:def 3;
    end;
    assume y in rng p;
    then consider x being set such that
A11: x in dom p and
A12: y = p.x by FUNCT_1:def 3;
    reconsider x9 = x as Element of NAT by A11;
    reconsider m = x9 as Element of NAT;
     (m+k) in dom Sp & Sp. (m+k) = p. m by A6,A11,VALUED_1:def 12;
    hence y in rng Sp by A12,FUNCT_1:def 3;
  end;
  then
A13: rng Sp = rng p by TARSKI:1;
A14: Union (UIL * Sp) = union rng (UIL * Sp) by CARD_3:def 4;
  rng (UIL * Sp) = UIL.:rng Sp by RELAT_1:127
    .= rng (UIL * p) by A13,RELAT_1:127;
  hence thesis by A2,A4,A5,A14,CARD_3:def 4;
end;

theorem Th39:
  UsedInt*Loc i = UsedInt*Loc IncAddr(i, k)
proof
A1: InsCode i <= 12 by SCMFSA_2:16;
  per cases by A1,NAT_1:36;
  suppose
    InsCode i = 0;
    then i = halt SCM+FSA by SCMFSA_2:95;
    hence thesis by COMPOS_0:4;
  end;
  suppose
    InsCode i = 1;
    then ex a, b st i = a:=b by SCMFSA_2:30;
    hence thesis by COMPOS_0:4;
  end;
  suppose
    InsCode i = 2;
    then ex a, b st i = AddTo(a,b) by SCMFSA_2:31;
    hence thesis by COMPOS_0:4;
  end;
  suppose
    InsCode i = 3;
    then ex a, b st i = SubFrom(a, b) by SCMFSA_2:32;
    hence thesis by COMPOS_0:4;
  end;
  suppose
    InsCode i = 4;
    then ex a, b st i = MultBy(a, b) by SCMFSA_2:33;
    hence thesis by COMPOS_0:4;
  end;
  suppose
    InsCode i = 5;
    then ex a, b st i = Divide(a, b) by SCMFSA_2:34;
    hence thesis by COMPOS_0:4;
  end;
  suppose
    InsCode i = 6;
    then consider l such that
A2: i = goto l by SCMFSA_2:35;
    IncAddr(i, k) = goto (l+k) by A2,SCMFSA_4:1;
    hence UsedInt*Loc IncAddr(i, k) = {} by Th32
      .= UsedInt*Loc i by A2,Th32;
  end;
  suppose
    InsCode i = 7;
    then consider l, a such that
A3: i = a=0_goto l by SCMFSA_2:36;
    IncAddr(i, k) = a=0_goto (l+k) by A3,SCMFSA_4:2;
    hence UsedInt*Loc IncAddr(i, k) = {} by Th32
      .= UsedInt*Loc i by A3,Th32;
  end;
  suppose
    InsCode i = 8;
    then consider l, a such that
A4: i = a>0_goto l by SCMFSA_2:37;
    IncAddr(i, k) = a>0_goto (l+k) by A4,SCMFSA_4:3;
    hence UsedInt*Loc IncAddr(i, k) = {} by Th32
      .= UsedInt*Loc i by A4,Th32;
  end;
  suppose
    InsCode i = 9;
    then ex a, b, f st i = b:=(f,a) by SCMFSA_2:38;
    hence thesis by COMPOS_0:4;
  end;
  suppose
    InsCode i = 10;
    then ex a, b, f st i = (f,a):=b by SCMFSA_2:39;
    hence thesis by COMPOS_0:4;
  end;
  suppose
    InsCode i = 11;
    then ex a, f st i = a:=len f by SCMFSA_2:40;
    hence thesis by COMPOS_0:4;
  end;
  suppose
    InsCode i = 12;
    then ex a,f st i = f:=<0,...,0>a by SCMFSA_2:41;
    hence thesis by COMPOS_0:4;
  end;
end;

theorem Th40:
  UsedInt*Loc p = UsedInt*Loc IncAddr(p, k)
proof
  set Ip = IncAddr (p, k);
  consider UIL being Function of the InstructionsF of SCM+FSA, Fin
  FinSeq-Locations such that
A1: for i being Instruction of SCM+FSA holds UIL.i = UsedInt*Loc i and
A2: UsedInt*Loc p = Union (UIL * p) by Def4;
  set g = UIL * p;
  set f = UIL * Ip;
  consider UIL2 being Function of the InstructionsF of SCM+FSA, Fin
  FinSeq-Locations such that
A3: for i being Instruction of SCM+FSA holds UIL2.i = UsedInt*Loc i and
A4: UsedInt*Loc IncAddr (p, k) = Union (UIL2 * IncAddr (p, k)) by Def4;
  for c be Element of the InstructionsF of SCM+FSA holds UIL.c = UIL2.c
  proof
    let c be Element of the InstructionsF of SCM+FSA;
    reconsider d = c as Instruction of SCM+FSA;
    thus UIL.c = UsedInt*Loc d by A1
      .= UIL2.c by A3;
  end;
  then
A5: UIL=UIL2 by FUNCT_2:63;
  now
A6: dom UIL = the InstructionsF of SCM+FSA by FUNCT_2:def 1;
    then
A7: rng p c= dom UIL;
 rng Ip c= dom UIL by A6;
    then
A8: dom f = dom Ip by RELAT_1:27;
A9: dom Ip = dom p by COMPOS_1:def 21;
    hence dom f = dom g by A7,A8,RELAT_1:27;
    let x be set;
    assume
A10: x in dom f;
    then p.x in rng p by A9,A8,FUNCT_1:def 3;
    then reconsider px = p.x as Instruction of SCM+FSA;
    reconsider x9 = x as Element of NAT by A8,A10;
    reconsider m = x9 as Element of NAT;
A11: Ip.x = IncAddr(p/.m,k) by A9,A8,A10,COMPOS_1:def 21
      .= IncAddr(px, k) by A9,A8,A10,PARTFUN1:def 6;
    Ip.x in rng Ip by A8,A10,FUNCT_1:def 3;
    then reconsider Ipx = Ip.x as Instruction of SCM+FSA;
    thus f.x = UIL.Ipx by A10,FUNCT_1:12
      .= UsedInt*Loc Ipx by A1
      .= UsedInt*Loc px by A11,Th39
      .= UIL.px by A3,A5
      .= g.x by A9,A8,A10,FUNCT_1:13;
  end;
  hence thesis by A2,A4,A5,FUNCT_1:2;
end;

theorem Th41:
  UsedInt*Loc I = UsedInt*Loc Reloc(I, k)
proof
A1:  Reloc(I,k) = IncAddr(Shift(I,k),k) by COMPOS_1:34;
  UsedInt*Loc Reloc(I, k) = UsedInt*Loc Reloc(I,k)
    .= UsedInt*Loc Shift (I, k) by Th40,A1
    .= UsedInt*Loc I by Th38;
  hence thesis;
end;

theorem Th42:
  UsedInt*Loc I = UsedInt*Loc Directed I
proof
  consider UIL being Function of the InstructionsF of SCM+FSA, Fin
  FinSeq-Locations such that
A1: for i being Instruction of SCM+FSA holds UIL.i = UsedInt*Loc i and
A2: UsedInt*Loc I = Union (UIL * I) by Def4;
A3: UIL.halt SCM+FSA = UsedInt*Loc halt SCM+FSA by A1
    .= {} by Th32;
  consider UIL2 being Function of the InstructionsF of SCM+FSA, Fin
  FinSeq-Locations such that
A4: for i being Instruction of SCM+FSA holds UIL2.i = UsedInt*Loc i and
A5: UsedInt*Loc Directed I = Union (UIL2 * Directed I) by Def4;
A6: for c be Element of the InstructionsF of SCM+FSA holds UIL.c = UIL2.c
  proof
    let c be Element of the InstructionsF of SCM+FSA;
    reconsider d = c as Instruction of SCM+FSA;
    thus UIL.c = UsedInt*Loc d by A1
      .= UIL2.c by A4;
  end;
A7: UIL.goto  card I = UsedInt*Loc goto  card I by A1
    .= {} by Th32;
A8: dom UIL = the InstructionsF of SCM+FSA by FUNCT_2:def 1;
  rng I c= the InstructionsF of SCM+FSA;
  then UIL * Directed I = UIL * (((id the InstructionsF of SCM+FSA) +* (halt
  SCM+FSA, goto  card I))*I) by FUNCT_7:116
    .= UIL * ((id the InstructionsF of SCM+FSA) +* (halt SCM+FSA, goto
  card I)) * I by RELAT_1:36
    .= UIL * I by A8,A3,A7,FUNCT_7:108;
  hence thesis by A2,A5,A6,FUNCT_2:63;
end;

theorem Th43:
  UsedInt*Loc (I ";" J) = (UsedInt*Loc I) \/ (UsedInt*Loc J)
proof
  dom I = dom Directed I by FUNCT_4:99;
  then dom Directed I misses dom Reloc(J, card I) by COMPOS_1:48;
  hence UsedInt*Loc (I ";" J) = UsedInt*Loc (Directed I) \/ UsedInt*Loc
  Reloc(J, card I) by Th37
    .= (UsedInt*Loc I) \/ UsedInt*Loc Reloc(J, card I) by Th42
    .= (UsedInt*Loc I) \/ (UsedInt*Loc J) by Th41;
end;

theorem Th44:
  UsedInt*Loc Macro i = UsedInt*Loc i
proof
  consider UIL being Function of the InstructionsF of SCM+FSA, Fin
  FinSeq-Locations such that
A1: for i being Instruction of SCM+FSA holds UIL.i = UsedInt*Loc i and
A2: UsedInt*Loc Macro i = Union (UIL * Macro i) by Def4;
A3: rng Macro i = {i, halt SCM+FSA} & dom UIL = the InstructionsF of
  SCM+FSA by COMPOS_1:67,FUNCT_2:def 1;
  thus UsedInt*Loc Macro i = union rng (UIL * Macro i) by A2,CARD_3:def 4
    .= union (UIL.:rng Macro i) by RELAT_1:127
    .= union {UIL.i,UIL.halt SCM+FSA} by A3,FUNCT_1:60
    .= UIL.i \/ UIL.halt SCM+FSA by ZFMISC_1:75
    .= (UsedInt*Loc i) \/ UIL.halt SCM+FSA by A1
    .= (UsedInt*Loc i) \/ (UsedInt*Loc halt SCM+FSA) by A1
    .= UsedInt*Loc i \/ {} by Th32
    .= UsedInt*Loc i;
end;

theorem
  UsedInt*Loc (i ";" J) = (UsedInt*Loc i) \/ UsedInt*Loc J
proof
  thus UsedInt*Loc (i ";" J) = (UsedInt*Loc Macro i) \/ UsedInt*Loc J by Th43
    .= (UsedInt*Loc i) \/ UsedInt*Loc J by Th44;
end;

theorem
  UsedInt*Loc (I ";" j) = (UsedInt*Loc I) \/ UsedInt*Loc j
proof
  thus UsedInt*Loc (I ";" j) = (UsedInt*Loc I) \/ UsedInt*Loc Macro j by Th43
    .= (UsedInt*Loc I) \/ UsedInt*Loc j by Th44;
end;

theorem
  UsedInt*Loc (i ";" j) = (UsedInt*Loc i) \/ UsedInt*Loc j
proof
  thus UsedInt*Loc (i ";" j) = (UsedInt*Loc Macro i) \/ UsedInt*Loc Macro j by
Th43
    .= (UsedInt*Loc Macro i) \/ UsedInt*Loc j by Th44
    .= (UsedInt*Loc i) \/ UsedInt*Loc j by Th44;
end;

begin :: Choosing integer location not used in a macro instruction

reserve L for finite Subset of Int-Locations;

definition
 canceled;
end;

theorem
  not FirstNotIn L in L by SCMFSA_M:14;

theorem
  FirstNotIn L = intloc m & not intloc n in L implies m <= n by SCMFSA_M:15;

definition
  let p be preProgram of SCM+FSA;
  func FirstNotUsed p -> Int-Location means
  :Def6:
  ex sil being finite Subset
  of Int-Locations st sil = UsedIntLoc p \/ {intloc 0} & it = FirstNotIn sil;
  existence
  proof
    reconsider i0 = {intloc 0} as finite Subset of Int-Locations;
    reconsider sil = UsedIntLoc p \/ i0 as finite Subset of Int-Locations;
    take FirstNotIn sil, sil;
    thus thesis;
  end;
  uniqueness;
end;

registration
  let p be preProgram of SCM+FSA;
  cluster FirstNotUsed p -> read-write;
  coherence
  proof
    consider sil being finite Subset of Int-Locations such that
A1: sil = UsedIntLoc p \/ {intloc 0} and
A2: FirstNotUsed p = FirstNotIn sil by Def6;
    now
      assume FirstNotIn sil = intloc 0;
      then not intloc 0 in sil by SCMFSA_M:14;
      hence contradiction by A1,ZFMISC_1:136;
    end;
    hence thesis by A2,SCMFSA_M:def 2;
  end;
end;

theorem Th50:
  not FirstNotUsed p in UsedIntLoc p
proof
  consider sil being finite Subset of Int-Locations such that
A1: sil = UsedIntLoc p \/ {intloc 0} and
A2: FirstNotUsed p = FirstNotIn sil by Def6;
  not FirstNotUsed p in sil by A2,SCMFSA_M:14;
  hence thesis by A1,XBOOLE_0:def 3;
end;

theorem
  a:=b in rng p or AddTo(a, b) in rng p or SubFrom(a, b) in rng p or
  MultBy(a, b) in rng p or Divide(a, b) in rng p implies FirstNotUsed p <> a &
  FirstNotUsed p <> b
proof
  assume a:=b in rng p or AddTo(a, b) in rng p or SubFrom(a, b) in rng p or
  MultBy(a, b) in rng p or Divide(a, b) in rng p;
  then consider i being Instruction of SCM+FSA such that
A1: i in rng p and
A2: i = a:=b or i = AddTo(a, b) or i = SubFrom(a, b) or i = MultBy(a, b
  ) or i = Divide(a, b);
  UsedIntLoc i = {a, b} by A2,Th14;
  then
A3: {a, b} c= UsedIntLoc p by A1,Th19;
  not FirstNotUsed p in UsedIntLoc p by Th50;
  hence thesis by A3,ZFMISC_1:32;
end;

theorem
  a=0_goto l in rng p or a>0_goto l in rng p implies FirstNotUsed p <> a
proof
  assume a=0_goto l in rng p or a>0_goto l in rng p;
  then consider i being Instruction of SCM+FSA such that
A1: i in rng p and
A2: i = a=0_goto l or i = a>0_goto l;
  UsedIntLoc i = {a} by A2,Th16;
  then
A3: {a} c= UsedIntLoc p by A1,Th19;
  not FirstNotUsed p in UsedIntLoc p by Th50;
  hence thesis by A3,ZFMISC_1:31;
end;

theorem
  b := (f, a) in rng p or (f, a) := b in rng p implies FirstNotUsed p <>
  a & FirstNotUsed p <> b
proof
  assume b := (f, a) in rng p or (f, a) := b in rng p;
  then consider i being Instruction of SCM+FSA such that
A1: i in rng p and
A2: i = b := (f, a) or i = (f, a) := b;
  UsedIntLoc i = {a, b} by A2,Th17;
  then
A3: {a, b} c= UsedIntLoc p by A1,Th19;
  not FirstNotUsed p in UsedIntLoc p by Th50;
  hence thesis by A3,ZFMISC_1:32;
end;

theorem
  a :=len f in rng p or f :=<0,...,0>a in rng p implies FirstNotUsed p
  <> a
proof
  assume a :=len f in rng p or f :=<0,...,0>a in rng p;
  then consider i being Instruction of SCM+FSA such that
A1: i in rng p and
A2: i = a :=len f or i = f :=<0,...,0>a;
  UsedIntLoc i = {a} by A2,Th18;
  then
A3: {a} c= UsedIntLoc p by A1,Th19;
  not FirstNotUsed p in UsedIntLoc p by Th50;
  hence thesis by A3,ZFMISC_1:31;
end;

begin :: Choosing finite sequence location not used in a macro instruction

reserve L for finite Subset of FinSeq-Locations;

definition
 canceled;
end;

theorem
  not First*NotIn L in L by SCMFSA_M:16;

theorem
  First*NotIn L = fsloc m & not fsloc n in L implies m <= n by SCMFSA_M:17;

definition
  let p be preProgram of SCM+FSA;
  func First*NotUsed p -> FinSeq-Location means
  :Def8:
  ex sil being finite
  Subset of FinSeq-Locations st sil = UsedInt*Loc p & it = First*NotIn sil;
  existence
  proof
    take First*NotIn UsedInt*Loc p, UsedInt*Loc p;
    thus thesis;
  end;
  uniqueness;
end;

theorem Th57:
  not First*NotUsed p in UsedInt*Loc p
proof
  ex sil being finite Subset of FinSeq-Locations st sil = UsedInt*Loc p &
  First*NotUsed p = First*NotIn sil by Def8;
  hence thesis by SCMFSA_M:16;
end;

theorem
  b := (f, a) in rng p or (f, a) := b in rng p implies First*NotUsed p
  <> f
proof
  assume b := (f, a) in rng p or (f, a) := b in rng p;
  then consider i being Instruction of SCM+FSA such that
A1: i in rng p and
A2: i = b := (f, a) or i = (f, a) := b;
  UsedInt*Loc i = {f} by A2,Th33;
  then
A3: {f} c= UsedInt*Loc p by A1,Th35;
  not First*NotUsed p in UsedInt*Loc p by Th57;
  hence thesis by A3,ZFMISC_1:31;
end;

theorem
  a :=len f in rng p or f :=<0,...,0>a in rng p implies First*NotUsed p
  <> f
proof
  assume a :=len f in rng p or f :=<0,...,0>a in rng p;
  then consider i being Instruction of SCM+FSA such that
A1: i in rng p and
A2: i = a :=len f or i = f :=<0,...,0>a;
  UsedInt*Loc i = {f} by A2,Th34;
  then
A3: {f} c= UsedInt*Loc p by A1,Th35;
  not First*NotUsed p in UsedInt*Loc p by Th57;
  hence thesis by A3,ZFMISC_1:31;
end;

begin :: Semantics

reserve s, t for State of SCM+FSA;
reserve P for Instruction-Sequence of SCM+FSA;



theorem Th60:
  not c in UsedIntLoc i implies Exec(i, s).c = s.c
proof
  assume
A1: not c in UsedIntLoc i;
A2: InsCode i <= 12 by SCMFSA_2:16;
  per cases by A2,NAT_1:36;
  suppose
    InsCode i = 0;
    then i = halt SCM+FSA by SCMFSA_2:95;
    hence thesis by EXTPRO_1:def 3;
  end;
  suppose
    InsCode i = 1;
    then consider a, b such that
A3: i = a:=b by SCMFSA_2:30;
    UsedIntLoc i = {a, b} by A3,Th14;
    then c <> a by A1,TARSKI:def 2;
    hence thesis by A3,SCMFSA_2:63;
  end;
  suppose
    InsCode i = 2;
    then consider a, b such that
A4: i = AddTo(a,b) by SCMFSA_2:31;
    UsedIntLoc i = {a, b} by A4,Th14;
    then c <> a by A1,TARSKI:def 2;
    hence thesis by A4,SCMFSA_2:64;
  end;
  suppose
    InsCode i = 3;
    then consider a, b such that
A5: i = SubFrom(a, b) by SCMFSA_2:32;
    UsedIntLoc i = {a, b} by A5,Th14;
    then c <> a by A1,TARSKI:def 2;
    hence thesis by A5,SCMFSA_2:65;
  end;
  suppose
    InsCode i = 4;
    then consider a, b such that
A6: i = MultBy(a, b) by SCMFSA_2:33;
    UsedIntLoc i = {a, b} by A6,Th14;
    then c <> a by A1,TARSKI:def 2;
    hence thesis by A6,SCMFSA_2:66;
  end;
  suppose
    InsCode i = 5;
    then consider a, b such that
A7: i = Divide(a, b) by SCMFSA_2:34;
    UsedIntLoc i = {a, b} by A7,Th14;
    then c <> a & c <> b by A1,TARSKI:def 2;
    hence thesis by A7,SCMFSA_2:67;
  end;
  suppose
    InsCode i = 6;
    then ex l st i = goto l by SCMFSA_2:35;
    hence thesis by SCMFSA_2:69;
  end;
  suppose
    InsCode i = 7;
    then ex l, a st i = a=0_goto l by SCMFSA_2:36;
    hence thesis by SCMFSA_2:70;
  end;
  suppose
    InsCode i = 8;
    then ex l, a st i = a>0_goto l by SCMFSA_2:37;
    hence thesis by SCMFSA_2:71;
  end;
  suppose
    InsCode i = 9;
    then consider a, b, f such that
A8: i = b:=(f,a) by SCMFSA_2:38;
    UsedIntLoc i = {a, b} by A8,Th17;
    then c <> b by A1,TARSKI:def 2;
    hence thesis by A8,SCMFSA_2:72;
  end;
  suppose
    InsCode i = 10;
    then ex a, b, f st i = (f,a):=b by SCMFSA_2:39;
    hence thesis by SCMFSA_2:73;
  end;
  suppose
    InsCode i = 11;
    then consider a, f such that
A9: i = a:=len f by SCMFSA_2:40;
    UsedIntLoc i = {a} by A9,Th18;
    then c <> a by A1,TARSKI:def 1;
    hence thesis by A9,SCMFSA_2:74;
  end;
  suppose
    InsCode i = 12;
    then ex a,f st i = f:=<0,...,0>a by SCMFSA_2:41;
    hence thesis by SCMFSA_2:75;
  end;
end;

theorem
  I c= P &
   (for m st m < n holds IC Comput(P,s,m) in dom I) &
    not a in UsedIntLoc I implies Comput(P,s,n).a = s.a
proof
  assume that
A1: I c= P and
A2: for m st m < n holds IC Comput(P,s,m) in dom I and
A3: not a in UsedIntLoc I;
  defpred X[Nat] means $1 <= n implies Comput(P,s,$1).a = s.a;
A4: for m st X[m] holds X[m+1]
  proof
    let m;
    set sm = Comput(P,s,m);
    assume
A5: m <= n implies sm.a = s.a;
    assume
A6: m+1 <= n;
    then m < n by NAT_1:13;
    then
A7: IC sm in dom I by A2;
    then
A8: I.IC sm in rng I by FUNCT_1:def 3;
    dom P = NAT by PARTFUN1:def 2;
    then
A9:  (P)/.IC sm = P.IC sm by PARTFUN1:def 6;
    I.IC sm = P.IC sm by A7,A1,GRFUNC_1:2;
    then UsedIntLoc P.IC sm c= UsedIntLoc I by A8,Th19;
    then
A10: not a in UsedIntLoc P.IC sm by A3;
    thus Comput(P,s,m+1).a = (Following(P,sm)).a by EXTPRO_1:3
      .= s.a by A5,A6,A10,Th60,A9,NAT_1:13;
  end;
A11: X[0];
  for m holds X[m] from NAT_1:sch 1(A11, A4);
  hence thesis;
end;

theorem Th62:
  not f in UsedInt*Loc i implies Exec(i, s).f = s.f
proof
  assume
A1: not f in UsedInt*Loc i;
A2: InsCode i <= 12 by SCMFSA_2:16;
  per cases by A2,NAT_1:36;
  suppose
    InsCode i = 0;
    then i = halt SCM+FSA by SCMFSA_2:95;
    hence thesis by EXTPRO_1:def 3;
  end;
  suppose
    InsCode i = 1;
    then ex a, b st i = a:=b by SCMFSA_2:30;
    hence thesis by SCMFSA_2:63;
  end;
  suppose
    InsCode i = 2;
    then ex a, b st i = AddTo(a,b) by SCMFSA_2:31;
    hence thesis by SCMFSA_2:64;
  end;
  suppose
    InsCode i = 3;
    then ex a, b st i = SubFrom(a, b) by SCMFSA_2:32;
    hence thesis by SCMFSA_2:65;
  end;
  suppose
    InsCode i = 4;
    then ex a, b st i = MultBy(a, b) by SCMFSA_2:33;
    hence thesis by SCMFSA_2:66;
  end;
  suppose
    InsCode i = 5;
    then ex a, b st i = Divide(a, b) by SCMFSA_2:34;
    hence thesis by SCMFSA_2:67;
  end;
  suppose
    InsCode i = 6;
    then ex l st i = goto l by SCMFSA_2:35;
    hence thesis by SCMFSA_2:69;
  end;
  suppose
    InsCode i = 7;
    then ex l, a st i = a=0_goto l by SCMFSA_2:36;
    hence thesis by SCMFSA_2:70;
  end;
  suppose
    InsCode i = 8;
    then ex l, a st i = a>0_goto l by SCMFSA_2:37;
    hence thesis by SCMFSA_2:71;
  end;
  suppose
    InsCode i = 9;
    then ex a, b, g st i = b:=(g,a) by SCMFSA_2:38;
    hence thesis by SCMFSA_2:72;
  end;
  suppose
    InsCode i = 10;
    then consider a, b, g such that
A3: i = (g,a):=b by SCMFSA_2:39;
    UsedInt*Loc i = {g} by A3,Th33;
    then f <> g by A1,TARSKI:def 1;
    hence thesis by A3,SCMFSA_2:73;
  end;
  suppose
    InsCode i = 11;
    then ex a, g st i = a:=len g by SCMFSA_2:40;
    hence thesis by SCMFSA_2:74;
  end;
  suppose
    InsCode i = 12;
    then consider a,g such that
A4: i = g:=<0,...,0>a by SCMFSA_2:41;
    UsedInt*Loc i = {g} by A4,Th34;
    then f <> g by A1,TARSKI:def 1;
    hence thesis by A4,SCMFSA_2:75;
  end;
end;

theorem
   I c= P &
   (for m st m < n holds IC Comput(P,s,m) in dom I) &
    not f in UsedInt*Loc I implies Comput(P,s,n).f = s.f
proof
  assume that
A1: I c= P and
A2: for m st m < n holds IC Comput(P,s,m) in dom I and
A3: not f in UsedInt*Loc I;
  defpred X[Nat] means $1 <= n implies Comput(P,s,$1).f = s.f;
A4: for m st X[m] holds X[m+1]
  proof
    let m;
    set sm = Comput(P,s,m);
    assume
A5: m <= n implies sm.f = s.f;
    assume
A6: m+1 <= n;
    then m < n by NAT_1:13;
    then
A7: IC sm in dom I by A2;
    then
A8: I.IC sm in rng I by FUNCT_1:def 3;
   dom P = NAT by PARTFUN1:def 2;
   then
A9:  (P)/.IC sm
 = P.IC sm by PARTFUN1:def 6;
    I.IC sm = P.IC sm by A7,A1,GRFUNC_1:2;
    then UsedInt*Loc P.IC sm c= UsedInt*Loc I by A8,Th35;
    then
A10: not f in UsedInt*Loc P.IC sm by A3;
    thus Comput(P,s,m+1).f = (Following(P,sm)).f by EXTPRO_1:3
      .= s.f by A5,A6,A10,Th62,A9,NAT_1:13;
  end;
A11: X[0];
  for m holds X[m] from NAT_1:sch 1(A11, A4);
  hence thesis;
end;

theorem Th64:
  s | UsedIntLoc i = t | UsedIntLoc i & s | UsedInt*Loc i = t |
UsedInt*Loc i & IC s = IC t implies IC Exec(i, s) = IC Exec(i, t) & Exec(i, s)
| UsedIntLoc i = Exec(i, t) | UsedIntLoc i & Exec(i, s) | UsedInt*Loc i = Exec(
  i, t) | UsedInt*Loc i
proof
  assume that
A1: s | UsedIntLoc i = t | UsedIntLoc i and
A2: s | UsedInt*Loc i = t | UsedInt*Loc i and
A3: IC s = IC t;
  set UFi = UsedInt*Loc i;
  set Ui = UsedIntLoc i;
  set Et = Exec(i, t);
  set Es = Exec(i, s);
A4: dom Es = the carrier of SCM+FSA by PARTFUN1:def 2
    .= dom Et by PARTFUN1:def 2;
A5: InsCode i <= 12 by SCMFSA_2:16;
  per cases by A5,NAT_1:36;
  suppose
    InsCode i = 0;
    then
A6: i = halt SCM+FSA by SCMFSA_2:95;
    then Exec(i, s) = s by EXTPRO_1:def 3;
    hence thesis by A1,A2,A3,A6,EXTPRO_1:def 3;
  end;
  suppose
    InsCode i = 1;
    then consider a, b such that
A7: i = a:=b by SCMFSA_2:30;
A8: Ui = {a, b} by A7,Th14;
    then
A9: b in Ui by TARSKI:def 2;
    then s.b = (s | Ui).b by FUNCT_1:49;
    then
A10: s.b = t.b by A1,A9,FUNCT_1:49;
    thus IC Es = succ IC t by A3,A7,SCMFSA_2:63
      .= IC Et by A7,SCMFSA_2:63;
    a = b or a <> b;
    then
A11: Es.b = s.b & Et.b = t.b by A7,SCMFSA_2:63;
    Es.a = s.b & Et.a = t.b by A7,SCMFSA_2:63;
    hence Es | Ui = Et | Ui by A4,A8,A10,A11,GRFUNC_1:30;
A12: UFi = {} by A7,Th32;
    hence Es | UFi = {} by RELAT_1:81
      .= Et | UFi by A12,RELAT_1:81;
  end;
  suppose
    InsCode i = 2;
    then consider a, b such that
A13: i = AddTo(a,b) by SCMFSA_2:31;
    thus IC Es = succ IC t by A3,A13,SCMFSA_2:64
      .= IC Et by A13,SCMFSA_2:64;
A14: Ui = {a, b} by A13,Th14;
    then
A15: a in Ui by TARSKI:def 2;
    then s.a = (s | Ui).a by FUNCT_1:49;
    then
A16: s.a = t.a by A1,A15,FUNCT_1:49;
A17: now
      per cases;
      case
        a = b;
        hence Es.b = s.a + s.b & Et.b = t.a + t.b by A13,SCMFSA_2:64;
      end;
      case
        a<> b;
        hence Es.b = s.b & Et.b = t.b by A13,SCMFSA_2:64;
      end;
    end;
A18: b in Ui by A14,TARSKI:def 2;
    then s.b = (s | Ui).b by FUNCT_1:49;
    then
A19: s.b = t.b by A1,A18,FUNCT_1:49;
    Es.a = s.a + s.b & Et.a = t.a + t.b by A13,SCMFSA_2:64;
    hence Es | Ui = Et | Ui by A4,A14,A16,A19,A17,GRFUNC_1:30;
A20: UFi = {} by A13,Th32;
    hence Es | UFi = {} by RELAT_1:81
      .= Et | UFi by A20,RELAT_1:81;
  end;
  suppose
    InsCode i = 3;
    then consider a, b such that
A21: i = SubFrom(a, b) by SCMFSA_2:32;
    thus IC Es = succ IC t by A3,A21,SCMFSA_2:65
      .= IC Et by A21,SCMFSA_2:65;
A22: Ui = {a, b} by A21,Th14;
    then
A23: a in Ui by TARSKI:def 2;
    then s.a = (s | Ui).a by FUNCT_1:49;
    then
A24: s.a = t.a by A1,A23,FUNCT_1:49;
A25: now
      per cases;
      case
        a = b;
        hence Es.b = s.a - s.b & Et.b = t.a - t.b by A21,SCMFSA_2:65;
      end;
      case
        a<> b;
        hence Es.b = s.b & Et.b = t.b by A21,SCMFSA_2:65;
      end;
    end;
A26: b in Ui by A22,TARSKI:def 2;
    then s.b = (s | Ui).b by FUNCT_1:49;
    then
A27: s.b = t.b by A1,A26,FUNCT_1:49;
    Es.a = s.a - s.b & Et.a = t.a - t.b by A21,SCMFSA_2:65;
    hence Es | Ui = Et | Ui by A4,A22,A24,A27,A25,GRFUNC_1:30;
A28: UFi = {} by A21,Th32;
    hence Es | UFi = {} by RELAT_1:81
      .= Et | UFi by A28,RELAT_1:81;
  end;
  suppose
    InsCode i = 4;
    then consider a, b such that
A29: i = MultBy(a, b) by SCMFSA_2:33;
    thus IC Es = succ IC t by A3,A29,SCMFSA_2:66
      .= IC Et by A29,SCMFSA_2:66;
A30: Ui = {a, b} by A29,Th14;
    then
A31: a in Ui by TARSKI:def 2;
    then s.a = (s | Ui).a by FUNCT_1:49;
    then
A32: s.a = t.a by A1,A31,FUNCT_1:49;
A33: now
      per cases;
      case
        a = b;
        hence Es.b = s.a * s.b & Et.b = t.a * t.b by A29,SCMFSA_2:66;
      end;
      case
        a<> b;
        hence Es.b = s.b & Et.b = t.b by A29,SCMFSA_2:66;
      end;
    end;
A34: b in Ui by A30,TARSKI:def 2;
    then s.b = (s | Ui).b by FUNCT_1:49;
    then
A35: s.b = t.b by A1,A34,FUNCT_1:49;
    Es.a = s.a * s.b & Et.a = t.a * t.b by A29,SCMFSA_2:66;
    hence Es | Ui = Et | Ui by A4,A30,A32,A35,A33,GRFUNC_1:30;
A36: UFi = {} by A29,Th32;
    hence Es | UFi = {} by RELAT_1:81
      .= Et | UFi by A36,RELAT_1:81;
  end;
  suppose
    InsCode i = 5;
    then consider a, b such that
A37: i = Divide(a, b) by SCMFSA_2:34;
A38: Ui = {a, b} by A37,Th14;
    then
A39: a in Ui by TARSKI:def 2;
    then s.a = (s | Ui).a by FUNCT_1:49;
    then
A40: s.a = t.a by A1,A39,FUNCT_1:49;
A41: UFi = {} by A37,Th32;
A42: b in Ui by A38,TARSKI:def 2;
    then s.b = (s | Ui).b by FUNCT_1:49;
    then
A43: s.b = t.b by A1,A42,FUNCT_1:49;
    hereby
      per cases;
      suppose
A44:    a = b;
        hence IC Es = succ IC t by A3,A37,SCMFSA_2:68
          .= IC Et by A37,A44,SCMFSA_2:68;
        Es.a = s.a mod s.a & Et.a = t.a mod t.b by A37,A44,SCMFSA_2:68;
        hence Es | Ui = Et | Ui by A4,A38,A40,A44,GRFUNC_1:30;
        thus Es | UFi = {} by A41,RELAT_1:81
          .= Et | UFi by A41,RELAT_1:81;
      end;
      suppose
A45:    a <> b;
        thus IC Es = succ IC t by A3,A37,SCMFSA_2:67
          .= IC Et by A37,SCMFSA_2:67;
A46:    Es.b = s.a mod s.b & Et.b = t.a mod t.b by A37,SCMFSA_2:67;
        Es.a = s.a div s.b & Et.a = t.a div t.b by A37,A45,SCMFSA_2:67;
        hence Es | Ui = Et | Ui by A4,A38,A40,A43,A46,GRFUNC_1:30;
        thus Es | UFi = {} by A41,RELAT_1:81
          .= Et | UFi by A41,RELAT_1:81;
      end;
    end;
  end;
  suppose
    InsCode i = 6;
    then consider l such that
A47: i = goto l by SCMFSA_2:35;
    thus IC Es = l by A47,SCMFSA_2:69
      .= IC Et by A47,SCMFSA_2:69;
A48: Ui = {} by A47,Th15;
    hence Es | Ui = {} by RELAT_1:81
      .= Et | Ui by A48,RELAT_1:81;
A49: UFi = {} by A47,Th32;
    hence Es | UFi = {} by RELAT_1:81
      .= Et | UFi by A49,RELAT_1:81;
  end;
  suppose
    InsCode i = 7;
    then consider l, a such that
A50: i = a=0_goto l by SCMFSA_2:36;
A51: Ui = {a} by A50,Th16;
    then
A52: a in Ui by TARSKI:def 1;
    then
A53: s.a = (s | Ui).a by FUNCT_1:49;
    then
A54: s.a = t.a by A1,A52,FUNCT_1:49;
    hereby
      per cases;
      suppose
A55:    s.a = 0;
        hence IC Es = l by A50,SCMFSA_2:70
          .= IC Et by A50,A54,A55,SCMFSA_2:70;
      end;
      suppose
A56:    s.a <> 0;
        hence IC Es = succ IC s by A50,SCMFSA_2:70
          .= IC Et by A3,A50,A54,A56,SCMFSA_2:70;
      end;
    end;
    Es.a = s.a & Et.a = t.a by A50,SCMFSA_2:70;
    hence Es | Ui = Et | Ui by A1,A4,A51,A52,A53,FUNCT_1:49,GRFUNC_1:29;
A57: UFi = {} by A50,Th32;
    hence Es | UFi = {} by RELAT_1:81
      .= Et | UFi by A57,RELAT_1:81;
  end;
  suppose
    InsCode i = 8;
    then consider l, a such that
A58: i = a>0_goto l by SCMFSA_2:37;
A59: Ui = {a} by A58,Th16;
    then
A60: a in Ui by TARSKI:def 1;
    then
A61: s.a = (s | Ui).a by FUNCT_1:49;
    then
A62: s.a = t.a by A1,A60,FUNCT_1:49;
    hereby
      per cases;
      suppose
A63:    s.a > 0;
        hence IC Es = l by A58,SCMFSA_2:71
          .= IC Et by A58,A62,A63,SCMFSA_2:71;
      end;
      suppose
A64:    s.a <= 0;
        hence IC Es = succ IC s by A58,SCMFSA_2:71
          .= IC Et by A3,A58,A62,A64,SCMFSA_2:71;
      end;
    end;
    Es.a = s.a & Et.a = t.a by A58,SCMFSA_2:71;
    hence Es | Ui = Et | Ui by A1,A4,A59,A60,A61,FUNCT_1:49,GRFUNC_1:29;
A65: UFi = {} by A58,Th32;
    hence Es | UFi = {} by RELAT_1:81
      .= Et | UFi by A65,RELAT_1:81;
  end;
  suppose
    InsCode i = 9;
    then consider a, b, f such that
A66: i = b:=(f,a) by SCMFSA_2:38;
A67: Ui = {a, b} by A66,Th17;
    then
A68: a in Ui by TARSKI:def 2;
    then s.a = (s | Ui).a by FUNCT_1:49;
    then
A69: s.a = t.a by A1,A68,FUNCT_1:49;
    thus IC Es = succ IC t by A3,A66,SCMFSA_2:72
      .= IC Et by A66,SCMFSA_2:72;
A70: UFi = {f} by A66,Th33;
    then
A71: f in UFi by TARSKI:def 1;
    then
A72: s.f = (s | UFi).f by FUNCT_1:49;
A73: (ex m st m = abs(s.a) & Es.b = (s.f)/.m )& ex n st n = abs(t.a) & Et
    .b = (t.f)/.n by A66,SCMFSA_2:72;
A74: now
      per cases;
      case
        a = b;
        thus Es.b = Et.b by A2,A71,A72,A69,A73,FUNCT_1:49;
      end;
      case
        a <> b;
        hence Es.a = s.a & Et.a = t.a by A66,SCMFSA_2:72;
      end;
    end;
    s.f = t.f by A2,A71,A72,FUNCT_1:49;
    hence Es | Ui = Et | Ui by A4,A67,A69,A73,A74,GRFUNC_1:30;
    Es.f = s.f & Et.f = t.f by A66,SCMFSA_2:72;
    hence thesis by A2,A4,A70,A71,A72,FUNCT_1:49,GRFUNC_1:29;
  end;
  suppose
    InsCode i = 10;
    then consider a, b, f such that
A75: i = (f,a):=b by SCMFSA_2:39;
    thus IC Es = succ IC t by A3,A75,SCMFSA_2:73
      .= IC Et by A75,SCMFSA_2:73;
A76: Et.a = t.a & Et.b = t.b by A75,SCMFSA_2:73;
A77: Ui = {a, b} by A75,Th17;
    then
A78: a in Ui by TARSKI:def 2;
    then s.a = (s | Ui).a by FUNCT_1:49;
    then
A79: s.a = t.a by A1,A78,FUNCT_1:49;
A80: b in Ui by A77,TARSKI:def 2;
    then s.b = (s | Ui).b by FUNCT_1:49;
    then
A81: s.b = t.b by A1,A80,FUNCT_1:49;
A82: UFi = {f} by A75,Th33;
    then
A83: f in UFi by TARSKI:def 1;
    then s.f = (s | UFi).f by FUNCT_1:49;
    then
A84: s.f = t.f by A2,A83,FUNCT_1:49;
    Es.a = s.a & Es.b = s.b by A75,SCMFSA_2:73;
    hence Es | Ui = Et | Ui by A4,A77,A79,A81,A76,GRFUNC_1:30;
    (ex m st m = abs(s.a) & Es.f = s.f+*(m,s.b) )& ex n st n = abs(t.a)
    & Et. f = t.f+*(n,t.b) by A75,SCMFSA_2:73;
    hence thesis by A4,A82,A79,A81,A84,GRFUNC_1:29;
  end;
  suppose
    InsCode i = 11;
    then consider a, f such that
A85: i = a:=len f by SCMFSA_2:40;
    thus IC Es = succ IC t by A3,A85,SCMFSA_2:74
      .= IC Et by A85,SCMFSA_2:74;
A86: Et.a = len(t.f) by A85,SCMFSA_2:74;
A87: Ui = {a} & Es.a = len(s.f) by A85,Th18,SCMFSA_2:74;
A88: UFi = {f} by A85,Th34;
    then
A89: f in UFi by TARSKI:def 1;
    then
A90: s.f = (s | UFi).f by FUNCT_1:49;
    then s.f = t.f by A2,A89,FUNCT_1:49;
    hence Es | Ui = Et | Ui by A4,A87,A86,GRFUNC_1:29;
    Es.f = s.f & Et.f = t.f by A85,SCMFSA_2:74;
    hence thesis by A2,A4,A88,A89,A90,FUNCT_1:49,GRFUNC_1:29;
  end;
  suppose
    InsCode i = 12;
    then consider a,f such that
A91: i = f:=<0,...,0>a by SCMFSA_2:41;
    thus IC Es = succ IC t by A3,A91,SCMFSA_2:75
      .= IC Et by A91,SCMFSA_2:75;
A92: Ui = {a} by A91,Th18;
    then
A93: a in Ui by TARSKI:def 1;
    then
A94: s.a = (s | Ui).a by FUNCT_1:49;
A95: UFi = {f} & ex m st m = abs(s.a) & Es.f = m |-> 0
      by A91,Th34,SCMFSA_2:75;
    Es.a = s.a & Et.a = t.a by A91,SCMFSA_2:75;
    hence Es | Ui = Et | Ui by A1,A4,A92,A93,A94,FUNCT_1:49,GRFUNC_1:29;
A96: ex n st n = abs(t.a) & Et.f = n |-> 0 by A91,SCMFSA_2:75;
    s.a = t.a by A1,A93,A94,FUNCT_1:49;
    hence thesis by A4,A95,A96,GRFUNC_1:29;
  end;
end;

theorem
 for P,Q being Instruction-Sequence of SCM+FSA
  st I c= P & I c= Q &
   Start-At(0,SCM+FSA) c= s & Start-At(0,SCM+FSA) c= t &
   s | UsedIntLoc I = t | UsedIntLoc I &
   s | UsedInt*Loc I = t | UsedInt*Loc I &
   (for m st m < n holds IC Comput(P,s,m) in dom I)
  holds
   (for m st m < n holds IC Comput(Q,t,m) in dom I) &
   for m st m <= n holds IC Comput(P,s,m) = IC Comput(Q,t,m) &
    (for a st a in UsedIntLoc I holds Comput(P,s,m).a = Comput(Q,t,m).a) &
     for f st f in UsedInt*Loc I holds Comput(P,s,m).f = Comput(Q,t,m).f
proof
 let P,Q be Instruction-Sequence of SCM+FSA such that
A1: I c= P & I c= Q;
 assume that
A2: Start-At(0,SCM+FSA) c= s and
A3: Start-At(0,SCM+FSA) c= t and
A4: s | UsedIntLoc I = t | UsedIntLoc I and
A5: s | UsedInt*Loc I = t | UsedInt*Loc I and
A6: for m st m < n holds IC Comput(P,s,m) in dom I;
  defpred P[Nat] means $1 < n implies IC Comput(Q,t,$1) in dom I
  & IC Comput(P,s,$1) = IC Comput(Q,t,$1) & (for a st
a in UsedIntLoc I
holds Comput(P,s,$1).a = Comput(Q,t,$1).a) & for f st
f in UsedInt*Loc I
  holds Comput(P,s,$1).f = Comput(Q,t,$1).f;
A7: now
    let m;
    assume
A8: P[m];
    thus P[m+1]
    proof
      set i = P.IC Comput(P,s,m);
     dom P = NAT by PARTFUN1:def 2;
     then
A9:   P/.IC Comput(P,s,m) = P.IC Comput(P,s,m) by PARTFUN1:def 6;
      set m1 = m+1;
A10:  Comput(P,s,m1) = Following(P,Comput(P,s,m)) by EXTPRO_1:3
        .= Exec(P.IC Comput(P,s,m),Comput(P,s,m))
         by A9;
      assume
A11:  m1 < n;
      now
        thus dom ( Comput(P,s,m) | UsedInt*Loc I) = dom ( Comput(
P,s,m))
        /\ UsedInt*Loc I by RELAT_1:61
          .= (the carrier of SCM+FSA) /\ UsedInt*Loc I
           by PARTFUN1:def 2
          .= dom ( Comput(Q,t,m)) /\ UsedInt*Loc I by PARTFUN1:def 2;
        let x be set;
        assume x in dom ( Comput(P,s,m) | UsedInt*Loc I);
        then
A12:    x in UsedInt*Loc I by RELAT_1:57;
        then x in FinSeq-Locations;
        then reconsider x9 = x as FinSeq-Location by SCMFSA_2:def 5;
        thus ( Comput(P,s,m) | UsedInt*Loc I).x = Comput(
P,s,m).x9 by A12,FUNCT_1:49
          .= Comput(Q,t,m).x by A8,A11,A12,NAT_1:13;
      end;
      then
A13:  Comput(P,s,m) | UsedInt*Loc I = Comput(Q,t,m) | UsedInt*Loc I
      by FUNCT_1:46;
A14:  P.IC Comput(P,s,m) = I.IC Comput(P,s,m)
        by A8,A11,A1,GRFUNC_1:2,NAT_1:13;
      then
A15:  P.IC Comput(P,s,m) = Q.IC Comput(Q,t,m)
          by A8,A11,A1,GRFUNC_1:2,NAT_1:13;
      now
        thus dom ( Comput(P,s,m) | UsedIntLoc I) = dom ( Comput(
P,s,m))
        /\ UsedIntLoc I by RELAT_1:61
          .= (the carrier of SCM+FSA) /\ UsedIntLoc I
          by PARTFUN1:def 2
          .= dom ( Comput(Q,t,m)) /\ UsedIntLoc I by PARTFUN1:def 2;
        let x be set;
        assume x in dom ( Comput(P,s,m) | UsedIntLoc I);
        then
A16:    x in UsedIntLoc I by RELAT_1:57;
        then x in Int-Locations;
        then reconsider x9 = x as Int-Location by AMI_2:def 16;
        thus ( Comput(P,s,m) | UsedIntLoc I).x = Comput(
P,s,m).x9 by A16,FUNCT_1:49
          .= Comput(Q,t,m).x by A8,A11,A16,NAT_1:13;
      end;
      then
A17:  Comput(P,s,m) | UsedIntLoc I = Comput(Q,t,m) | UsedIntLoc I
      by FUNCT_1:46;
     dom Q = NAT by PARTFUN1:def 2;
     then
A18:  Q/.IC Comput(Q,t,m) = Q.IC Comput(Q,t,m) by PARTFUN1:def 6;
A19:  Comput(Q,t,m1) =
Following(Q,Comput(Q,t,m)) by EXTPRO_1:3
        .= Exec(Q.IC Comput(Q,t,m),Comput(Q,t,m))
         by A18;
      m < n by A11,NAT_1:13;
      then IC Comput(P,s,m) in dom I by A6;
      then
A20:  i in rng I by A14,FUNCT_1:def 3;
      then
A21:  Comput(P,s,m) | UsedInt*Loc i = ( Comput(P,s,m)
| UsedInt*Loc
      I) | UsedInt*Loc i by Th35,RELAT_1:74
        .= Comput(Q,t,m) | UsedInt*Loc i by A20,A13,Th35,RELAT_1:74;
A22:  Comput(P,s,m) | UsedIntLoc i = ( Comput(P,s,m)
| UsedIntLoc I
      ) | UsedIntLoc i by A20,Th19,RELAT_1:74
        .= Comput(Q,t,m) | UsedIntLoc i by A20,A17,Th19,RELAT_1:74;
      then
A23:  Exec(i, Comput(P,s,m)) | UsedInt*Loc i
      = Exec(i, Comput(Q,t,m)) | UsedInt*Loc i
       by A8,A11,A21,Th64,NAT_1:13;
A24:  IC Exec(i, Comput(P,s,m)) = IC Exec(i, Comput(Q,t,m))
           by A8,A11,A22,A21,Th64,NAT_1:13;
      hence IC Comput(Q,t,m1) in dom I by A6,A11,A10,A19,A15;
      thus IC Comput(P,s,m1) = IC Comput(Q,t,m1) by A8,A11,A10,A19,A14,A24,A1,
GRFUNC_1:2,NAT_1:13;
A25:  Exec(i, Comput(P,s,m)) | UsedIntLoc i = Exec(i, Comput(
Q,t,m)
      ) | UsedIntLoc i by A8,A11,A22,A21,Th64,NAT_1:13;
      hereby
        let a;
        assume
A26:    a in UsedIntLoc I;
        per cases;
        suppose
A27:      a in UsedIntLoc i;
          hence
          Comput(P,s,m1).a = (Exec(i, Comput(P,s,m))
| UsedIntLoc i
          ).a by A10,FUNCT_1:49
            .= Comput(Q,t,m1).a by A19,A15,A25,A27,FUNCT_1:49;
        end;
        suppose
A28:      not a in UsedIntLoc i;
          hence Comput(P,s,m1).a = Comput(P,s,m).a
by A10,Th60
            .= Comput(Q,t,m).a by A8,A11,A26,NAT_1:13
            .= Comput(Q,t,m1).a by A19,A15,A28,Th60;
        end;
      end;
      let f;
      assume
A29:  f in UsedInt*Loc I;
      per cases;
      suppose
A30:    f in UsedInt*Loc i;
        hence
        Comput(P,s,m1).f = (Exec(i, Comput(P,s,m)) |
UsedInt*Loc i)
        .f by A10,FUNCT_1:49
          .= Comput(Q,t,m1).f by A19,A15,A23,A30,FUNCT_1:49;
      end;
      suppose
A31:    not f in UsedInt*Loc i;
        hence Comput(P,s,m1).f = Comput(P,s,m).f by A10,Th62
          .= Comput(Q,t,m).f by A8,A11,A29,NAT_1:13
          .= Comput(Q,t,m1).f by A19,A15,A31,Th62;
      end;
    end;
  end;
A32: P[0]
  proof
A33: IC Comput(Q,t,0) = IC t
      .= 0 by A3,MEMSTR_0:39;
A34: IC Comput(P,s,0) = IC s
      .=  0 by A2,MEMSTR_0:39;
    assume 0 < n;
    hence IC Comput(Q,t,0) in dom I by A6,A34,A33;
    thus IC Comput(P,s,0) = IC Comput(Q,t,0) by A34,A33;
    hereby
      let a;
      assume
A35:  a in UsedIntLoc I;
      thus Comput(P,s,0).a = s.a
        .= (s | UsedIntLoc I).a by A35,FUNCT_1:49
        .= t.a by A4,A35,FUNCT_1:49
        .= Comput(Q,t,0).a;
    end;
    let f;
    assume
A36: f in UsedInt*Loc I;
    thus Comput(P,s,0).f = s.f
      .= (s | UsedInt*Loc I).f by A36,FUNCT_1:49
      .= t.f by A5,A36,FUNCT_1:49
      .= Comput(Q,t,0).f;
  end;
A37: for m holds P[m] from NAT_1:sch 1(A32, A7);
  hence for m st m < n holds IC Comput(Q,t,m) in dom I;
  let m;
  assume
A38: m <= n;
  per cases by NAT_1:6;
  suppose
A39: m = 0;
A40: IC Comput(Q,t,0) = IC t
      .=  0 by A3,MEMSTR_0:39;
    IC Comput(P,s,0) = IC s
      .=  0 by A2,MEMSTR_0:39;
    hence IC Comput(P,s,m) = IC Comput(Q,t,m) by A39,A40;
    hereby
      let a;
      assume
A41:  a in UsedIntLoc I;
      thus Comput(P,s,m).a = s.a by A39,EXTPRO_1:2
        .= (s | UsedIntLoc I).a by A41,FUNCT_1:49
        .= t.a by A4,A41,FUNCT_1:49
        .= Comput(Q,t,m).a by A39,EXTPRO_1:2;
    end;
    let f;
    assume
A42: f in UsedInt*Loc I;
    thus Comput(P,s,m).f = s.f by A39,EXTPRO_1:2
      .= (s | UsedInt*Loc I).f by A42,FUNCT_1:49
      .= t.f by A5,A42,FUNCT_1:49
      .= Comput(Q,t,m).f by A39,EXTPRO_1:2;
  end;
  suppose
    ex p being Nat st m = p+1;
    then consider p being Nat such that
A43: m = p+1;
    reconsider p as Element of NAT by ORDINAL1:def 12;
A44: p < n by A38,A43,NAT_1:13;
    then
A45: IC Comput(P,s,p) in dom I by A6;
    now
      thus dom ( Comput(P,s,p) | UsedInt*Loc I) = dom ( Comput(
P,s,p))
      /\ UsedInt*Loc I by RELAT_1:61
        .= (the carrier of SCM+FSA) /\ UsedInt*Loc I by PARTFUN1:def 2
        .= dom ( Comput(Q,t,p)) /\ UsedInt*Loc I by PARTFUN1:def 2;
      let x be set;
      assume x in dom ( Comput(P,s,p) | UsedInt*Loc I);
      then
A46:  x in UsedInt*Loc I by RELAT_1:57;
      then x in FinSeq-Locations;
      then reconsider x9 = x as FinSeq-Location by SCMFSA_2:def 5;
      thus ( Comput(P,s,p) | UsedInt*Loc I).x
         = Comput(P,s,p).x9 by A46,FUNCT_1:49
        .= Comput(Q,t,p).x by A37,A44,A46;
    end;
    then
A47: Comput(P,s,p) | UsedInt*Loc I = Comput(Q,t,p) |
UsedInt*Loc I
    by FUNCT_1:46;
    set i = P.IC Comput(P,s,p);
    set p1 = p+1;
     dom P = NAT by PARTFUN1:def 2;
     then
A48:  P/.IC Comput(P,s,p) = P.IC Comput(P,s,p) by PARTFUN1:def 6;
A49: Comput(P,s,p1) = Following(P,Comput(P,s,p)) by EXTPRO_1:3
      .= Exec(P.IC Comput(P,s,p), Comput(P,s,p))
              by A48;
    now
      thus dom ( Comput(P,s,p) | UsedIntLoc I) = dom ( Comput(
P,s,p)) /\
      UsedIntLoc I by RELAT_1:61
        .= (the carrier of SCM+FSA) /\ UsedIntLoc I by PARTFUN1:def 2
        .= dom ( Comput(Q,t,p)) /\ UsedIntLoc I by PARTFUN1:def 2;
      let x be set;
      assume x in dom ( Comput(P,s,p) | UsedIntLoc I);
      then
A50:  x in UsedIntLoc I by RELAT_1:57;
      then x in Int-Locations;
      then reconsider x9 = x as Int-Location by AMI_2:def 16;
      thus ( Comput(P,s,p) | UsedIntLoc I).x
       = Comput(P,s,p).x9 by A50,FUNCT_1:49
        .= Comput(Q,t,p).x by A37,A44,A50;
    end;
    then
A51: Comput(P,s,p) | UsedIntLoc I = Comput(Q,t,p) |
UsedIntLoc I by FUNCT_1:46;
A52: IC Comput(P,s,p) = IC Comput(Q,t,p) by A37,A44;
A53: P.IC Comput(P,s,p) = I.IC Comput(P,s,p) by A45,A1,GRFUNC_1:2;
     dom Q = NAT by PARTFUN1:def 2;
     then
A54:  Q/.IC Comput(Q,t,p) = Q.IC Comput(Q,t,p) by PARTFUN1:def 6;
A55: Comput(Q,t,p1) = Following(Q,Comput(Q,t,p)) by EXTPRO_1:3
      .= Exec(Q.IC Comput(Q,t,p), Comput(Q,t,p))
              by A54;
A56: P.IC Comput(P,s,p) = Q.IC Comput(Q,t,p) by A52,A45,A53,A1,GRFUNC_1:2;
    IC Comput(P,s,p) in dom I by A6,A44;
    then
A57: i in rng I by A53,FUNCT_1:def 3;
    then
A58: Comput(P,s,p) | UsedInt*Loc i = ( Comput(P,s,p)
| UsedInt*Loc I
    ) | UsedInt*Loc i by Th35,RELAT_1:74
      .= Comput(Q,t,p) | UsedInt*Loc i by A57,A47,Th35,RELAT_1:74;
A59: Comput(P,s,p) | UsedIntLoc i = ( Comput(P,s,p) |
UsedIntLoc I)
    | UsedIntLoc i by A57,Th19,RELAT_1:74
      .= Comput(Q,t,p) | UsedIntLoc i by A57,A51,Th19,RELAT_1:74;
    hence IC Comput(P,s,m) = IC Comput(Q,t,m) by A43,A49,A55,A52,A56,A58,Th64;
A60: Exec(i, Comput(P,s,p)) | UsedIntLoc i = Exec(i, Comput(
Q,t,p))
    | UsedIntLoc i by A52,A59,A58,Th64;
    hereby
      let a;
      assume
A61:  a in UsedIntLoc I;
      per cases;
      suppose
A62:    a in UsedIntLoc i;
        hence
        Comput(P,s,m).a = (Exec(i, Comput(P,s,p)) |
UsedIntLoc i).a
        by A43,A49,FUNCT_1:49
          .= Comput(Q,t,m).a by A43,A55,A56,A60,A62,FUNCT_1:49;
      end;
      suppose
A63:    not a in UsedIntLoc i;
        hence Comput(P,s,m).a = Comput(P,s,p).a by A43,A49,Th60
          .= Comput(Q,t,p).a by A37,A44,A61
          .= Comput(Q,t,m).a by A43,A55,A56,A63,Th60;
      end;
    end;
A64: Exec(i, Comput(P,s,p)) | UsedInt*Loc i = Exec(i, Comput(Q,t,p))
    | UsedInt*Loc i by A52,A59,A58,Th64;
    hereby
      let f;
      assume
A65:  f in UsedInt*Loc I;
      per cases;
      suppose
A66:    f in UsedInt*Loc i;
        hence
        Comput(P,s,m).f = (Exec(i, Comput(P,s,p)) |UsedInt*Loc i).f
         by A43,A49,FUNCT_1:49
          .= Comput(Q,t,m).f by A43,A55,A56,A64,A66,FUNCT_1:49;
      end;
      suppose
A67:    not f in UsedInt*Loc i;
        hence Comput(P,s,m).f = Comput(P,s,p).f by A43,A49,Th62
          .= Comput(Q,t,p).f by A37,A44,A65
          .= Comput(Q,t,m).f by A43,A55,A56,A67,Th62;
      end;
    end;
  end;
end;

