:: Categories of Groups
::  by Michal Muzalewski
::
:: Received October 3, 1991
:: Copyright (c) 1991 Association of Mizar Users

environ

 vocabularies CLASSES2, PARTFUN1, RELAT_1, FUNCT_1, MIDSP_1, BOOLE, VECTSP_2,
      FUNCT_2, VECTSP_1, MIDSP_2, RLVECT_1, ARYTM_1, CAT_1, TARSKI, CAT_2,
      ORDINAL4, FUNCOP_1, MOD_1, ENS_1, GRCAT_1, ALGSTR_1, REALSET1, SUBSET_1,
      SGRAPH1, NAT_1;
 notations TARSKI, XBOOLE_0, ZFMISC_1, SUBSET_1, RELAT_1, FUNCT_1,
      MCART_1, REALSET1, PARTFUN1, FUNCT_2, DOMAIN_1, CLASSES2, BINOP_1,
      STRUCT_0, CAT_1, PRE_TOPC, TOPS_2, RLVECT_1, VECTSP_1, VECTSP_2,
      FUNCOP_1, CAT_2, ALGSTR_1, MIDSP_1, MIDSP_2;
 constructors RELAT_2, PARTFUN1, DOMAIN_1, FUNCOP_1, CLASSES1, CLASSES2,
      REALSET1, TOPS_2, CAT_2, VECTSP_2, ALGSTR_1, MIDSP_2, NAT_D;
 registrations RELSET_1, GROUP_1, STRUCT_0, SUBSET_1, CLASSES2, ALGSTR_1,
      MIDSP_2, FUNCT_2, PARTFUN1, XBOOLE_0, FUNCOP_1;
 requirements SUBSET, BOOLE;
 definitions BINOP_1, PRE_TOPC, STRUCT_0, RLVECT_1, ALGSTR_1;
 theorems CAT_1, CAT_2, CLASSES2, FUNCOP_1, FUNCT_1, FUNCT_2, MIDSP_2, MCART_1,
      VECTSP_1, TARSKI, ZFMISC_1, RLVECT_1, RELAT_1, RELSET_1, ORDINAL1,
      XBOOLE_0, ALGSTR_1, TOPS_2, BINOP_1;
 schemes FUNCT_2, BINOP_1, TARSKI, XBOOLE_0;

begin ::  0a. Auxiliary theorems: sets and universums

reserve x, y for set;
reserve D for non empty set;
reserve UN for Universe;

canceled;

theorem
Th2: for X,Y,A being set, z being set st z in A & A c= [:X,Y:]
      ex x being Element of X, y being Element of Y st z = [x,y]
 proof
   let X,Y,A be set, z be set;
   assume z in A & A c= [:X,Y:];
   then consider x,y such that
   A1: x in X & y in Y & z = [x,y] by ZFMISC_1:103;
   reconsider x as Element of X by A1;
   reconsider y as Element of Y by A1;
   take x,y;
   thus thesis by A1;
 end;

theorem
Th3: for u1,u2,u3,u4 being Element of UN holds
 [u1,u2,u3] in UN & [u1,u2,u3,u4] in UN
 proof
   let u1,u2,u3,u4 be Element of UN;
   A1: [u1,u2,u3] = [[u1,u2],u3] by MCART_1:def 3;
        [u1,u2,u3,u4] = [[u1,u2,u3],u4] by MCART_1:def 4;
   hence thesis by A1,CLASSES2:64;
 end;

theorem
Th4: for x,y st x in y & y in UN holds x in UN
 proof
   let x,y; assume
   A1: x in y & y in UN;
   then y c= UN by ORDINAL1:def 2;
   hence thesis by A1;
 end;

::  0c. Auxiliary theorems: Trivial Group

theorem
Th5: op2.({},{}) = {} & op1.{} = {} & op0 = {}
 proof
   A1: {} in {{}} by TARSKI:def 1;
        [{},{}] in [:{{}},{{}}:] by ZFMISC_1:34;
   hence op2.({},{}) = {} by FUNCT_2:65;
   thus op1.{} = {} by A1,FUNCT_2:65;
   thus op0 = {} by TARSKI:def 1;
 end;

theorem
Th6: {{}} in UN & [{{}},{{}}] in UN & [:{{}},{{}}:] in UN &
  op2 in UN & op1 in UN
 proof
   set D = {{}};
       {} in UN by CLASSES2:62;
   hence A1: D in UN by CLASSES2:63;
   hence [D,D] in UN by CLASSES2:64;
   thus A2: [:D,D:] in UN by A1,CLASSES2:67;
   A3: Funcs(D,D) in UN by A1,CLASSES2:67;
   A4: Funcs([:D,D:],D) in UN by A1,A2,CLASSES2:67;
       op2 in Funcs([:D,D:],D) by FUNCT_2:11;
   hence op2 in UN by A4,Th4;
       op1 in Funcs(D,D) by FUNCT_2:11;
   hence op1 in UN by A3,Th4;
 end;

theorem
Th7: LoopStr (# {{}},op2,Extract {} #) is midpoint_operator
 proof
   set G = LoopStr (# {{}}, op2, Extract {} #);
   A1: for a being Element of G
         ex x being Element of G st Double x = a
    proof
      let a be Element of G;
      consider x being Element of G;
      take x;
      thus Double x = {} by TARSKI:def 1
              .= a by TARSKI:def 1;
    end;
       now
     let a be Element of G;
     assume Double a = 0.G;
     thus a = {} by TARSKI:def 1
           .= 0.G;end;
   hence thesis by A1,MIDSP_2:def 5;
 end;

registration
 cluster L_Trivial -> midpoint_operator;
 coherence by Th7;
end;

theorem
       (for x being Element of L_Trivial holds x = {})
  & (for x,y being Element of L_Trivial holds x+y = {})
  & (for x being Element of L_Trivial holds -x = {})
  & 0.L_Trivial = {} by TARSKI:def 1;

::  0d. Auxiliary theorems: subcategories

reserve C for Category;
reserve O for non empty Subset of the Objects of C;

definition let C,O;
 canceled 4;

 func Morphs(O) -> Subset of the Morphisms of C equals
  union{Hom(a,b) where a is Object of C,b is Object of C : a in O & b in O};
 coherence by CAT_2:28;
end;

registration let C,O;
 cluster Morphs(O) -> non empty;
 coherence by CAT_2:28;
end;

definition let C,O;
 func dom(O) -> Function of Morphs(O),O equals
   (the Dom of C)|Morphs(O);
 coherence by CAT_2:29;
 func cod(O) -> Function of Morphs(O),O equals
   (the Cod of C)|Morphs(O);
 coherence by CAT_2:29;
 func comp(O) -> PartFunc of [:Morphs(O),(Morphs(O)):],Morphs(O) equals
   (the Comp of C)||Morphs(O);
 coherence by CAT_2:29;
 func ID(O) -> Function of O,Morphs(O) equals
   (the Id of C)|O;
 coherence by CAT_2:29;
end;

definition let C,O;
 func cat(O) -> Subcategory of C equals
   CatStr (# O,Morphs(O),dom(O),cod(O),comp(O),ID(O)#);
 coherence
  proof
        CatStr (# O,Morphs(O),dom(O),cod(O),comp(O),ID(O)#)
 is_full_subcategory_of C by CAT_2:30;
    hence thesis by CAT_2:def 6;
  end;
end;

registration let C,O;
 cluster cat(O) -> strict;
 coherence;
end;

canceled;

theorem
 the Objects of cat(O) = O;

::  1a. Maps of the carriers of groups

definition 
  canceled;
end;

canceled;

theorem
  for G,H being 1-sorted, f being Function of G, H holds
  f*(id G) = f & (id H)*f = f by FUNCT_2:23;

definition let G be non empty 1-sorted, H be non empty ZeroStr;
 func ZeroMap(G,H) -> Function of G,H equals
   (the carrier of G) --> 0.H;
 coherence
  proof
   set i = (the carrier of G) --> 0.H;
   dom i = the carrier of G & rng i = {0.H} by FUNCOP_1:14,19;
   hence i is Function of G,H by FUNCT_2:4;
  end;
end;

definition let G,H be non empty LoopStr; let f be Function of G,H;
 attr f is additive means
 :Def13: for x,y being Element of G holds f.(x+y) = f.x+f.y;
end;

theorem Th13:
  comp L_Trivial = op1
  proof
    reconsider f = comp L_Trivial as Function of {{}}, {{}};
        for x being set st x in {{}} holds op1.x = f.x
    proof
      let x be set; assume A1: x in {{}};
      then reconsider x as Element of L_Trivial;
          x = {} by TARSKI:def 1;
      then op1.x = -x by Th5,TARSKI:def 1 .= f.x by
VECTSP_1:def 25;
      hence thesis;
    end;
    hence thesis by FUNCT_2:18;
  end;

theorem
Th14: for G1,G2,G3 being non empty LoopStr,
   f being Function of G1,G2, g being Function of G2,G3
      st f is additive & g is additive holds g*f is additive
 proof
   let G1,G2,G3 be non empty LoopStr,
       f be Function of G1,G2, g be Function of G2,G3 such that
   A1: f is additive and
   A2: g is additive;
   set h = g*f;
       now let x,y be Element of G1;
     A3: g.(f.x) = h.x & g.(f.y) = h.y by FUNCT_2:21;
     thus h.(x+y) = g.(f.(x+y)) by FUNCT_2:21
                 .= g.(f.x+f.y) by A1,Def13
                 .= h.x+h.y by A2,A3,Def13;end;
   hence thesis by Def13;
 end;

canceled;

theorem Th16:
  for G being non empty LoopStr,
      H being right_zeroed (non empty LoopStr) holds ZeroMap(G,H) is additive
 proof
   let G be non empty LoopStr, H be right_zeroed (non empty LoopStr);
   set f = ZeroMap(G,H);
       for x,y being Element of G holds f.(x+y) = f.x+f.y
    proof
      let x,y be Element of G;
          f.(x+y) = 0.H & f.x = 0.H & f.y = 0.H by FUNCOP_1:13;
      hence f.(x+y) = f.x+f.y by RLVECT_1:def 7;
    end;
   hence thesis by Def13;
 end;

::  1b. Morphisms of groups

reserve G,H for AddGroup;

definition
  struct GroupMorphismStr (# Dom,Cod -> AddGroup,
                          Fun -> Function of the Dom, the Cod #);
end;

definition let f be GroupMorphismStr;
 func dom(f) -> AddGroup equals
   the Dom of f;
 coherence;
 func cod(f) -> AddGroup equals
   the Cod of f;
 coherence;
end;

definition let f be GroupMorphismStr;
 func fun(f) -> Function of dom(f),cod(f) equals
   the Fun of f;
 coherence;
end;

theorem
    for f being GroupMorphismStr,
          G1,G2 being AddGroup,
          f0 being Function of G1,G2 st f = GroupMorphismStr(# G1,G2,f0#)
      holds dom f = G1 & cod f = G2 & fun f = f0;

definition let G,H;
 func ZERO(G,H) -> GroupMorphismStr equals
   GroupMorphismStr(# G,H,ZeroMap(G,H)#);
  coherence;
end;

registration let G,H;
 cluster ZERO(G,H) -> strict;
  coherence;
end;

definition let IT be GroupMorphismStr;
 attr IT is GroupMorphism-like means
 :Def18: fun(IT) is additive;
end;

registration
 cluster strict GroupMorphism-like GroupMorphismStr;
 existence
  proof
    consider G,H;
    set z = ZERO(G,H);
    fun(z) is additive by Th16;
    then z is GroupMorphism-like by Def18;
   hence thesis;
  end;
end;

definition
 mode GroupMorphism is GroupMorphism-like GroupMorphismStr;
end;

theorem
Th18: for F being GroupMorphism holds the Fun of F is additive
 proof
   let F be GroupMorphism;
   A1: the Fun of F = fun(F);
   thus thesis by A1,Def18;
 end;

registration let G,H;
 cluster ZERO(G,H) -> GroupMorphism-like;
 coherence
  proof
    set z = ZERO(G,H);
    fun(z) is additive by Th16;
    hence thesis by Def18;
  end;
end;

definition let G,H;
 mode Morphism of G,H -> GroupMorphism means
 :Def19: dom(it) = G & cod(it) = H;
  existence
   proof
     take ZERO(G,H);
     thus thesis;
   end;
end;

registration let G,H;
 cluster strict Morphism of G,H;
  existence
   proof
         dom(ZERO(G,H)) = G & cod(ZERO(G,H)) = H;
     then ZERO(G,H) is Morphism of G,H by Def19;
    hence thesis;
   end;
end;

theorem
Th19: for f being strict GroupMorphismStr
   st dom(f) = G & cod(f) = H & fun(f) is additive
   holds f is strict Morphism of G,H
 proof
   let f be strict GroupMorphismStr; assume
   A1: dom(f) = G & cod(f) = H & fun(f) is additive;
   then reconsider f' = f as strict GroupMorphism by Def18;
       f' is strict Morphism of G,H by A1,Def19;
   hence thesis;
 end;

theorem
Th20: for f being Function of G,H st f is additive
       holds GroupMorphismStr (# G,H,f#) is strict Morphism of G,H
 proof
   let f be Function of G,H such that
   A1: f is additive;
   set F = GroupMorphismStr (# G,H,f#);
        dom(F) = G & cod(F) = H & fun(F) = f;
   hence thesis by A1,Th19;
 end;

theorem Th21:
  for G being non empty LoopStr holds id G is additive
proof
  let G be non empty LoopStr;
  set f = id G;
      for x,y being Element of G holds f.(x+y) = f.x+f.y
   proof
     let x,y be Element of G;
          f.(x+y) = x+y & f.x = x & f.y = y by FUNCT_1:35;
     hence f.(x+y) = f.x+f.y;
   end;
  hence thesis by Def13;
end;

definition let G;
 func ID G -> Morphism of G,G equals
   GroupMorphismStr(# G,G,id G#);
  coherence
   proof
     set i = GroupMorphismStr(# G,G,id G#);
     A1: dom(i) = G & cod(i) = G & fun(i) = id G;
         id G is additive by Th21;
     hence i is Morphism of G,G by A1,Th19;
   end;
end;

registration let G;
 cluster ID G -> strict;
  coherence;
end;

definition let G,H;
 redefine func ZERO(G,H) -> strict Morphism of G,H;
  coherence
   proof
     set i = ZERO(G,H);
     A1: dom(i) = G & cod(i) = H & fun(i) = ZeroMap(G,H);
         ZeroMap(G,H) is additive by Th16;
     hence thesis by A1,Th19;
   end;
end;

theorem
Th22: for F being Morphism of G,H ex f being Function of G,H
       st the GroupMorphismStr of F = GroupMorphismStr(# G,H,f#) &
        f is additive
 proof
   let F be Morphism of G,H;
   A1: the Dom of F = dom(F)
                   .= G by Def19;
   A2: the Cod of F = cod(F)
                   .= H by Def19;
   then reconsider f = the Fun of F as Function of G,H by A1;
   take f;
   thus thesis by A1,A2,Th18;
 end;

theorem
Th23: for F being strict Morphism of G,H ex f being Function of G,H
       st F = GroupMorphismStr(# G,H,f#)
 proof
   let F be strict Morphism of G,H;
   consider f being Function of G,H such that
   A1: F = GroupMorphismStr(# G,H,f#) & f is additive by Th22;
   take f;
   thus thesis by A1;
 end;

theorem
Th24: for F being GroupMorphism ex G,H st F is Morphism of G,H
 proof
   let F be GroupMorphism;
   take G = the Dom of F,H = the Cod of F;
       dom(F) = G & cod(F) = H;
   hence thesis by Def19;
 end;

theorem
    for F being strict GroupMorphism ex G,H being AddGroup, f being Function
 of G,H
       st F is Morphism of G,H
        & F = GroupMorphismStr(# G,H,f#)
        & f is additive
 proof
   let F be strict GroupMorphism;
   consider G,H such that
   A1: F is Morphism of G,H by Th24;
   reconsider F' = F as Morphism of G,H by A1;
   consider f being Function of G,H such that
   A2: F' = GroupMorphismStr(# G,H,f#) & f is additive by Th22;
   take G,H,f;
   thus thesis by A2;
 end;

theorem
Th26: for g,f being GroupMorphism st dom(g) = cod(f)
       ex G1,G2,G3 being AddGroup st g is Morphism of G2,G3
                                   & f is Morphism of G1,G2
 proof
   defpred P[GroupMorphism,GroupMorphism] means dom($1) = cod($2);
   let g,f be GroupMorphism such that
   A1: P[g,f];
   consider G2,G3 being AddGroup such that
   A2: g is Morphism of G2,G3 by Th24;
   A3: G2 = dom(g) by A2,Def19;
   consider G1,G2' being AddGroup such that
   A4: f is Morphism of G1,G2' by Th24;
        G2' = cod(f) by A4,Def19;
   hence thesis by A1,A2,A3,A4;
 end;

definition let G,F be GroupMorphism;
 assume A1: dom(G) = cod(F);
 func G*F -> strict GroupMorphism means
 :Def21: for G1,G2,G3 being AddGroup,
           g being Function of G2,G3, f being Function of G1,G2
       st the GroupMorphismStr of G = GroupMorphismStr(# G2,G3,g#) &
          the GroupMorphismStr of F = GroupMorphismStr(# G1,G2,f#)
       holds it = GroupMorphismStr(# G1,G3,g*f#);
 existence
  proof
    consider G1',G2',G3' being AddGroup such that
    A2: G is Morphism of G2',G3' and
    A3: F is Morphism of G1',G2' by A1,Th26;
    consider g' being Function of G2',G3' such that
    A4: the GroupMorphismStr of G = GroupMorphismStr(# G2',G3',g'#)and
    A5: g' is additive by A2,Th22;
    consider f' being Function of G1',G2' such that
    A6: the GroupMorphismStr of F = GroupMorphismStr(# G1',G2',f'#)and
    A7: f' is additive by A3,Th22;
         g'*f' is additive by A5,A7,Th14;
    then reconsider T' = (GroupMorphismStr(# G1',G3',g'*f'#))
 as strict GroupMorphism by Th20;
    take T';
    thus thesis by A4,A6;
  end;
 uniqueness
  proof
    let S1,S2 be strict GroupMorphism such that
    A8: for G1,G2,G3 being AddGroup,
           g being Function of G2,G3, f being Function of G1,G2
       st the GroupMorphismStr of G = GroupMorphismStr(# G2,G3,g#) &
          the GroupMorphismStr of F = GroupMorphismStr(# G1,G2,f#)
       holds S1 = GroupMorphismStr(# G1,G3,g*f#)and
    A9: for G1,G2,G3 being AddGroup,
           g being Function of G2,G3, f being Function of G1,G2
       st the GroupMorphismStr of G = GroupMorphismStr(# G2,G3,g#) &
          the GroupMorphismStr of F = GroupMorphismStr(# G1,G2,f#)
       holds S2 = GroupMorphismStr(# G1,G3,g*f#);
    consider G2',G3' being AddGroup such that
    A10: G is Morphism of G2',G3' by Th24;
    reconsider G' = G as Morphism of G2',G3' by A10;
    A11: G2' = dom(G) by A10,Def19;
    consider G1',G2'' being AddGroup such that
    A12: F is Morphism of G1',G2'' by Th24;
    reconsider F' = F as Morphism of G1',G2'' by A12;
    reconsider F' as Morphism of G1',G2' by A1,A11,Def19;
    consider g' being Function of G2',G3' such that
    A13: the GroupMorphismStr of G' = GroupMorphismStr(# G2',G3',g'#)
and g' is additive by Th22;
    consider f' being Function of G1',G2' such that
    A14: the GroupMorphismStr of F' = GroupMorphismStr(# G1',G2',f'#)
and f' is additive by Th22;
    thus S1 = (GroupMorphismStr(# G1',G3',g'*f'#)) by A8,A13,A14
           .= S2 by A9,A13,A14;
  end;
end;

canceled;

theorem
Th28: for G1,G2,G3 being AddGroup,
          G being Morphism of G2,G3,
          F being Morphism of G1,G2
      holds G*F is Morphism of G1,G3
 proof
   let G1,G2,G3 be AddGroup,
       G be Morphism of G2,G3, F be Morphism of G1,G2;
   consider g being Function of G2,G3 such that
   A1: the GroupMorphismStr of G = GroupMorphismStr(# G2,G3,g#)
and g is additive by Th22;
   consider f being Function of G1,G2 such that
   A2: the GroupMorphismStr of F = GroupMorphismStr(# G1,G2,f#)
and f is additive by Th22;
       dom(G) = G2 by Def19
         .= cod(F) by Def19;
   then G*F = GroupMorphismStr(# G1,G3,g*f#) by A1,A2,Def21;
   then dom(G*F) = G1 & cod(G*F) = G3;
   hence thesis by Def19;
 end;

definition let G1,G2,G3 be AddGroup,
               G be Morphism of G2,G3,
               F be Morphism of G1,G2;
 redefine func G*F -> strict Morphism of G1,G3;
 coherence by Th28;
end;

theorem
Th29: for G1,G2,G3 being AddGroup,
          G being Morphism of G2,G3,
          F being Morphism of G1,G2,
          g being Function of G2,G3, f being Function of G1,G2
      st G = GroupMorphismStr(# G2,G3,g#) & F = GroupMorphismStr(# G1,G2,f#)
      holds G*F = GroupMorphismStr(# G1,G3,g*f#)
proof
  let G1,G2,G3 be AddGroup,
      G be Morphism of G2,G3, F be Morphism of G1,G2,
      g be Function of G2,G3, f be Function of G1,G2 such that
  A1: G = GroupMorphismStr(# G2,G3,g#) & F = GroupMorphismStr(# G1,G2,f#);
      dom(G) = G2 by Def19
        .= cod(F) by Def19;
  hence thesis by A1,Def21;
end;

 theorem
 Th30: for f,g being strict GroupMorphism st dom g = cod f holds
       ex G1,G2,G3 being AddGroup,
          f0 being Function of G1,G2, g0 being Function of G2,G3
          st f = GroupMorphismStr(# G1,G2,f0#)
           & g = GroupMorphismStr(# G2,G3,g0#)
           & g*f = GroupMorphismStr(# G1,G3,g0*f0#)
  proof
    let f,g be strict GroupMorphism such that
    A1: dom g = cod f;
    set G1 = dom f,G2 = cod f, G3 = cod g;
    reconsider f' = f as strict Morphism of G1,G2 by Def19;
    reconsider g' = g as strict Morphism of G2,G3 by A1,Def19;
    consider f0 being Function of G1,G2 such that
    A2: f' = GroupMorphismStr(# G1,G2,f0#);
    consider g0 being Function of G2,G3 such that
    A3: g' = GroupMorphismStr(# G2,G3,g0#) by Th23;
    take G1,G2,G3,f0,g0;
    thus thesis by A2,A3,Th29;
  end;

 theorem
 Th31: for f,g being strict GroupMorphism st dom g = cod f holds
     dom(g*f) = dom f & cod (g*f) = cod g
 proof
   let f,g be strict GroupMorphism; assume
        dom g = cod f;
   then consider G1,G2,G3 being AddGroup,
   f0 being Function of G1,G2, g0 being Function of G2,G3 such that
   A1: f = GroupMorphismStr(# G1,G2,f0#)
     & g = GroupMorphismStr(# G2,G3,g0#)
     & g*f = GroupMorphismStr(# G1,G3,g0*f0#) by Th30;
   thus dom(g*f) = dom f by  A1;
   thus cod(g*f) = cod g by  A1;
 end;

 theorem
 Th32: for G1,G2,G3,G4 being AddGroup, f being strict Morphism of G1,G2,
             g being strict Morphism of G2,G3,
             h being strict Morphism of G3,G4
         holds h*(g*f) = (h*g)*f
 proof
   let G1,G2,G3,G4 be AddGroup, f be strict Morphism of G1,G2,
       g be strict Morphism of G2,G3, h be strict Morphism of G3,G4;
   consider f0 being Function of G1,G2 such that
   A1: f = GroupMorphismStr(# G1,G2,f0#) by Th23;
   consider g0 being Function of G2,G3 such that
   A2: g = GroupMorphismStr(# G2,G3,g0#) by Th23;
   consider h0 being Function of G3,G4 such that
   A3: h = GroupMorphismStr(# G3,G4,h0#) by Th23;
   A4: g*f = GroupMorphismStr(# G1,G3,g0*f0#) by A1,A2,Th29;
   A5: h*g = GroupMorphismStr(# G2,G4,h0*g0#) by A2,A3,Th29;
       h*(g*f) = GroupMorphismStr(# G1,G4,h0*(g0*f0)#) by A3,A4,Th29
          .= GroupMorphismStr(# G1,G4,(h0*g0)*f0#) by RELAT_1:55
          .= (h*g)*f by A1,A5,Th29;
   hence thesis;
 end;

 theorem
 Th33: for f,g,h being strict GroupMorphism
        st dom h = cod g & dom g = cod f holds h*(g*f) = (h*g)*f
  proof
    let f,g,h be strict GroupMorphism such that
    A1: dom h = cod g & dom g = cod f;
    set G2 = cod f, G3 = cod g;
    reconsider f' = f as Morphism of (dom f),G2 by Def19;
    reconsider g' = g as Morphism of G2,G3 by A1,Def19;
    reconsider h' = h as Morphism of G3,(cod h) by A1,Def19;
        h'*(g'*f') = (h'*g')*f' by Th32;
    hence thesis;
  end;

 theorem
 Th34: dom ID(G) = G
      & cod ID(G) = G
      & (for f being strict GroupMorphism st cod f = G holds (ID G)*f = f)
      & (for g being strict GroupMorphism st dom g = G holds g*(ID G) = g)
 proof
   set i = ID G;
   thus dom i = G;
   thus cod i = G;
   thus for f being strict GroupMorphism st cod f = G holds i*f = f
    proof
      let f be strict GroupMorphism such that
      A1: cod f = G;
      set H = dom(f);
      reconsider f' = f as Morphism of H,G by A1,Def19;
      A2: dom(i) = G;
      consider m being Function of H,G such that
      A3: f' = GroupMorphismStr(# H,G,m#) by Th23;
           (id G)*m = m by FUNCT_2:23;
      hence i*f = f by A1,A2,A3,Def21;
    end;
   thus for g being strict GroupMorphism st dom g = G holds g*(ID G) = g
    proof
      let f be strict GroupMorphism such that
      A4: dom f = G;
      set H = cod(f);
      reconsider f' = f as Morphism of G,H by A4,Def19;
      A5: cod(i) = G;
      consider m being Function of G,H such that
      A6: f' = GroupMorphismStr(# G,H,m#) by Th23;
           m*(id G) = m by FUNCT_2:23;
      hence f*i = f by A4,A5,A6,Def21;
    end;
 end;

::  2. Domains of groups

definition let IT be set;
 attr IT is Group_DOMAIN-like means
 :Def22: for x being set st x in IT holds x is strict AddGroup;
end;

registration
 cluster Group_DOMAIN-like non empty set;
 existence
  proof
    set D = {L_Trivial};
A1: for x be set st x in D holds x is strict AddGroup by TARSKI:def 1;
    take D;
    thus thesis by A1,Def22;
  end;
end;

definition
 mode Group_DOMAIN is Group_DOMAIN-like non empty set;
end;

reserve V for Group_DOMAIN;

definition let V;
 redefine mode Element of V -> AddGroup;
  coherence by Def22;
end;

registration let V;
 cluster strict Element of V;
  existence
   proof consider v being Element of V;
         v is strict AddGroup by Def22;
    hence thesis;
   end;
end;

::  3. Domains of morphisms

definition let IT be set;
 attr IT is GroupMorphism_DOMAIN-like means
  :Def23: for x being set st x in IT holds x is strict GroupMorphism;
end;

registration
 cluster GroupMorphism_DOMAIN-like non empty set;
   existence
    proof
      consider G;
      take {ID G};
          for x being set st x in {ID G} holds x is strict GroupMorphism
 by TARSKI:def 1;
      hence thesis by Def23;
    end;
end;

definition
 mode GroupMorphism_DOMAIN is GroupMorphism_DOMAIN-like non empty set;
end;

definition let M be GroupMorphism_DOMAIN;
 redefine mode Element of M -> GroupMorphism;
  coherence by Def23;
end;

registration let M be GroupMorphism_DOMAIN;
 cluster strict Element of M;
  existence
   proof consider m being Element of M;
         m is strict GroupMorphism by Def23;
    hence thesis;
   end;
end;

canceled 2;

theorem
Th37: for f being strict GroupMorphism holds {f} is GroupMorphism_DOMAIN
 proof
   let f be strict GroupMorphism;
       for x being set st x in {f} holds x is strict GroupMorphism by
TARSKI:def 1
;
   hence thesis by Def23;
 end;

definition let G,H;
 mode GroupMorphism_DOMAIN of G,H -> GroupMorphism_DOMAIN means
 :Def24: for x being Element of it holds x is strict Morphism of G,H;
  existence
   proof
     reconsider D = {ZERO(G,H)} as GroupMorphism_DOMAIN by Th37;
     take D;
     thus thesis by TARSKI:def 1;
   end;
end;

theorem
Th38: D is GroupMorphism_DOMAIN of G,H
       iff for x being Element of D holds x is strict Morphism of G,H
 proof
   thus D is GroupMorphism_DOMAIN of G,H
    implies for x being Element of D holds x is strict Morphism of G,H
 by Def24;
   thus (for x being Element of D holds x is strict Morphism of G,H)
    implies D is GroupMorphism_DOMAIN of G,H
    proof
      assume A1: for x being Element of D holds x is strict Morphism of G,H;
      then for x being set st x in D holds x is strict GroupMorphism;
      then reconsider D' = D as GroupMorphism_DOMAIN by Def23;
          for x being Element of D' holds x is strict Morphism of G,H by A1;
      hence thesis by Def24;
    end;
 end;

theorem
    for f being strict Morphism of G,H holds {f} is GroupMorphism_DOMAIN of G,H
 proof
   let f be strict Morphism of G,H;
       for x being Element of {f} holds x is strict Morphism of G,H
 by TARSKI:def 1;
   hence thesis by Th38;
 end;

definition let G,H be 1-sorted;
 mode MapsSet of G,H means
:Def25: for x being set st x in it holds x is Function of G,H;
 existence
  proof take {};
   thus thesis;
  end;
end;

definition let G,H be 1-sorted;
 func Maps(G,H) -> MapsSet of G,H equals
  Funcs(the carrier of G, the carrier of H);
 coherence
  proof let x be set;
   assume  x in Funcs(the carrier of G, the carrier of H);
   hence thesis by FUNCT_2:121;
  end;
end;

registration let G be 1-sorted, H be non empty 1-sorted;
 cluster Maps(G,H) -> non empty;
 coherence;
end;

registration let G be 1-sorted, H be non empty 1-sorted;
 cluster non empty MapsSet of G,H;
 existence
  proof Maps(G,H) is non empty;
   hence thesis;
  end;
end;

definition let G be 1-sorted, H be non empty 1-sorted;
           let M be non empty MapsSet of G,H;
 redefine mode Element of M -> Function of G,H;
 coherence by Def25;
end;

definition let G,H;
 func Morphs(G,H) -> GroupMorphism_DOMAIN of G,H means
 :Def27: x in it iff x is strict Morphism of G,H;
  existence
   proof
     set D = { GroupMorphismStr(# G,H,f#) where f is Element of
                     Maps(G,H) : f is additive };
     reconsider f0 = ZeroMap(G,H) as Element of Maps(G,H) by FUNCT_2:11;
         f0 is additive by Th16;
     then GroupMorphismStr(# G,H,f0#) in D;
     then reconsider D as non empty set;
     A1: x in D implies x is strict Morphism of G,H
      proof
        assume x in D;
        then ex f being Element of
         Maps(G,H) st x = GroupMorphismStr (# G,H,f#) & f is additive;
        hence thesis by Th20;
      end;
     then A2: for x being Element of D holds x is strict Morphism of G,H;
A3:      x is strict Morphism of G,H implies x in D
      proof
        assume x is strict Morphism of G,H;
        then reconsider x as strict Morphism of G,H;
A4:     dom(x) = G & cod(x) = H by Def19;
        A5: (the Fun of x) is additive by Th18;
        reconsider f = the Fun of x as Function of G,H by A4;
        reconsider g = f as Element of Maps(G,H) by FUNCT_2:11;
        x = GroupMorphismStr(# G,H,g #) by A4;
        hence thesis by A5;
      end;
     reconsider D as GroupMorphism_DOMAIN of G,H by A2,Th38;
     take D;
     thus thesis by A1,A3;
   end;
  uniqueness
   proof
     let D1,D2 be GroupMorphism_DOMAIN of G,H such that
     A6: x in D1 iff x is strict Morphism of G,H and
     A7: x in D2 iff x is strict Morphism of G,H;
         x in D1 iff x in D2
      proof
        thus x in D1 implies x in D2
         proof
           assume x in D1;
           then x is strict Morphism of G,H by A6;
           hence thesis by A7;
         end;
        thus x in D2 implies x in D1
         proof
           assume x in D2;
           then x is strict Morphism of G,H by A7;
           hence thesis by A6;
         end;
      end;
     hence thesis by TARSKI:2;
   end;
end;

definition let G,H; let M be GroupMorphism_DOMAIN of G,H;
 redefine mode Element of M -> Morphism of G,H;
  coherence by Def24;
end;

registration let G,H; let M be GroupMorphism_DOMAIN of G,H;
 cluster strict Element of M;
  existence
   proof consider m being Element of M;
         m is strict Morphism of G,H by Def24;
    hence thesis;
   end;
end;

::  4a. Category of groups - objects

definition let x,y;
 pred GO x,y means
 :Def28: ex x1,x2,x3,x4 being set st x = [x1,x2,x3,x4] &
    ex G being strict AddGroup
    st y = G
    & x1 = the carrier of G
    & x2 = the add of G
    & x3 = comp G
    & x4 = 0.G;
end;

theorem
Th40: for x,y1,y2 being set st GO x,y1 & GO x,y2 holds y1 = y2
 proof
   let x,y1,y2 be set such that
   A1: GO x,y1 and
   A2: GO x,y2;
   consider a1,a2,a3,a4 being set such that
     A3: x = [a1,a2,a3,a4]and
     A4: ex G being strict AddGroup st y1 = G
                 & a1 = the carrier of G
                 & a2 = the add of G
                 & a3 = comp G
                 & a4 = 0.G by A1,Def28;
   consider b1,b2,b3,b4 being set such that
   A5: x = [b1,b2,b3,b4]and
   A6: ex G being strict AddGroup st y2 = G
               & b1 = the carrier of G
               & b2 = the add of G
               & b3 = comp G
               & b4 = 0.G by A2,Def28;
   consider G1 being strict AddGroup such that
   A7: y1 = G1
       & a1 = the carrier of G1
       & a2 = the add of G1
       & a3 = comp G1
       & a4 = 0.G1 by A4;
   consider G2 being strict AddGroup such that
   A8: y2 = G2
       & b1 = the carrier of G2
       & b2 = the add of G2
       & b3 = comp G2
       & b4 = 0.G2 by A6;
         the carrier of G1 = the carrier of G2
   & the add of G1 = the add of G2
   & comp G1 = comp G2
   & 0.G1 = 0.G2 by A3,A5,A7,A8,MCART_1:33;
   hence thesis by A7,A8;
 end;

theorem
Th41: ex x st x in UN & GO x,L_Trivial
 proof
    reconsider u = {} as Element of UN by CLASSES2:62;
    set x1 = {u};
        Extract {} = u;
    then reconsider x4 = Extract {} as Element of UN;
    reconsider x3 = comp L_Trivial as Element of UN by Th6,Th13;
    reconsider x2 = op2 as Element of UN by Th6;
    take x = [x1,x2,x3,x4];
    thus x in UN by Th3;
    take x1,x2,x3,x4;
    thus x = [x1,x2,x3,x4];
    take L_Trivial;
    thus thesis;
 end;

definition let UN;
 func GroupObjects(UN) -> set means
 :Def29: for y holds y in it iff ex x st x in UN & GO x,y;
 existence
  proof
    defpred P[set,set] means GO $1,$2;
A1: for x,y1,y2 being set st P[x,y1] & P[x,y2] holds y1 = y2 by Th40;
    consider Y being set such that
    A2: for y holds y in Y iff ex x st x in UN & P[x,y] from TARSKI:sch 1(A1);
    take Y;
    thus thesis by A2;
  end;
 uniqueness
 proof
   defpred P[set] means ex x st x in UN & GO x,$1;
     for X1,X2 being set st
    (for x being set holds x in X1 iff P[x]) &
    (for x being set holds x in X2 iff P[x]) holds X1 = X2 from XBOOLE_0:sch 3;
   hence thesis;
 end;
end;

theorem
Th42: L_Trivial in GroupObjects(UN)
 proof
       ex x st x in UN & GO x,L_Trivial by Th41;
   hence thesis by Def29;
 end;

registration let UN;
 cluster GroupObjects(UN) -> non empty;
 coherence by Th42;
end;

theorem
Th43: for x being Element of GroupObjects(UN) holds x is strict AddGroup
 proof
   let x be Element of GroupObjects(UN);
   consider u being set such that
   A1: u in UN & GO u,x by Def29;
        ex x1,x2,x3,x4 being set st
 u = [x1,x2,x3,x4] & ex G being strict AddGroup
    st x = G
    & x1 = the carrier of G
    & x2 = the add of G
    & x3 = comp G
    & x4 = 0.G by A1,Def28;
   hence thesis;
 end;

registration let UN;
  cluster GroupObjects(UN) -> Group_DOMAIN-like;
   coherence
    proof
          for x being set st x in GroupObjects(UN) holds x is strict AddGroup
 by Th43;
      hence thesis by Def22;
    end;
end;

::  4b. Category of groups - morphisms

definition let V;
 func Morphs(V) -> GroupMorphism_DOMAIN means
 :Def30: for x holds x in it iff ex G,H being strict Element of V
  st x is strict Morphism of G,H;
  existence
   proof
     consider G0,H0 being strict Element of V;
     set M = Morphs(G0,H0), S = { Morphs(G,H) where
      G is strict Element of V, H is strict Element of V :
         not contradiction };
     A1: (ZERO(G0,H0)) is Element of M by Def27;
         M in S;
     then reconsider T = union S as non empty set by A1,TARSKI:def 4;
     A2: for x holds x in T iff ex G,H being strict Element of V
          st x is strict Morphism of G,H
      proof
        let x;
        thus x in T implies ex G,H being strict Element of V
                            st x is strict Morphism of G,H
         proof
           assume x in T;
           then consider Y being set such that
           A3: x in Y and
           A4: Y in S by TARSKI:def 4;
           consider G,H being strict Element of V such that
           A5: Y = Morphs(G,H) by A4;
           take G,H;
          thus thesis by A3,A5,Def27;
         end;
        thus (ex G,H being strict Element of V
                  st x is strict Morphism of G,H) implies x in T
         proof
           given G,H being strict Element of V such that
           A6: x is strict Morphism of G,H;
           set M = Morphs(G,H);
           A7: x in M by A6,Def27;
               M in S;
           hence thesis by A7,TARSKI:def 4;
         end;
     end;
         now let x be set;
       assume x in T;
        then ex G,H being strict Element of V st
          x is strict Morphism of G,H by A2;
       hence x is strict GroupMorphism;end;
     then reconsider T' = T as GroupMorphism_DOMAIN by Def23;
     take T';
     thus thesis by A2;
   end;
  uniqueness
   proof
     let D1,D2 be GroupMorphism_DOMAIN such that
     A8: for x holds x in D1 iff ex G,H being strict Element of V
      st x is strict Morphism of G,H and
     A9: for x holds x in D2 iff ex G,H being strict Element of V
      st x is strict Morphism of G,H;
         now let x;
           x in D1 iff
        ex G,H being strict Element of V st x is strict Morphism of G,H
 by A8;
       hence x in D1 iff x in D2 by A9;end;
     hence thesis by TARSKI:2;
   end;
end;

      ::
      ::  4c. Category of groups - dom,cod,id
      ::

definition let V; let F be Element of Morphs(V);
redefine func dom(F) -> strict Element of V;
  coherence
   proof
     consider G,H being strict Element of V such that
     A1: F is strict Morphism of G,H by Def30;
     reconsider F' = F as Morphism of G,H by A1;
         dom(F') = G by Def19;
     hence thesis;
   end;
 func cod(F) -> strict Element of V;
  coherence
   proof
     consider G,H being strict Element of V such that
     A2: F is strict Morphism of G,H by Def30;
     reconsider F' = F as Morphism of G,H by A2;
         cod(F') = H by Def19;
     hence thesis;
   end;
end;

definition let V; let G be Element of V;
 func ID(G) -> strict Element of Morphs(V) equals
   ID(G);
 coherence
  proof
    reconsider G' = G as strict Element of V by Def22;
         ID(G') is strict Element of Morphs(V) by Def30;
   hence thesis;
  end;
end;

definition let V;
 func dom(V) -> Function of Morphs(V),V means
 :Def32: for f being Element of Morphs(V) holds it.f = dom(f);
  existence
    proof
      deffunc F(Element of Morphs(V)) = dom $1;
      consider F being Function of Morphs(V),V such that
      A1: for f being Element of Morphs(V) holds F.f = F(f) from FUNCT_2:sch 4;
      take F;
      thus thesis by A1;
    end;
  uniqueness
   proof
     let F1,F2 be Function of Morphs(V),V such that
     A2: for f being Element of Morphs(V) holds F1.f = dom(f) and
     A3: for f being Element of Morphs(V) holds F2.f = dom(f);
         now let f be Element of Morphs(V);
           F1.f = dom(f) by A2;
       hence F1.f = F2.f by A3;end;
     hence thesis by FUNCT_2:113;
   end;
 func cod(V) -> Function of Morphs(V),V means
 :Def33: for f being Element of Morphs(V) holds it.f = cod(f);
  existence
    proof
      deffunc F(Element of Morphs(V)) = cod $1;
      consider F being Function of Morphs(V),V such that
      A4: for f being Element of Morphs(V) holds F.f = F(f) from FUNCT_2:sch 4;
      take F;
      thus thesis by A4;
    end;
  uniqueness
   proof
     let F1,F2 be Function of Morphs(V),V such that
     A5: for f being Element of Morphs(V) holds F1.f = cod(f) and
     A6: for f being Element of Morphs(V) holds F2.f = cod(f);
         now let f be Element of Morphs(V);
           F1.f = cod(f) by A5;
       hence F1.f = F2.f by A6;end;
     hence thesis by FUNCT_2:113;
   end;
 func ID(V) -> Function of V,Morphs(V) means
 :Def34: for G being Element of V holds it.G = ID(G);
  existence
    proof
      deffunc F(Element of V) = ID $1;
      consider F being Function of V,Morphs(V) such that
      A7: for G being Element of V holds F.G = F(G) from FUNCT_2:sch 4;
      take F;
      thus thesis by A7;
    end;
  uniqueness
   proof
     let F1,F2 be Function of V,Morphs(V) such that
     A8: for G being Element of V holds F1.G = ID(G) and
     A9: for G being Element of V holds F2.G = ID(G);
         now let G be Element of V;
           F1.G = ID(G) by A8;
       hence F1.G = F2.G by A9;end;
     hence thesis by FUNCT_2:113;
   end;
 end;

      ::
      ::  4d. Category of groups - superposition
      ::

theorem
Th44: for g,f being Element of Morphs(V) st dom(g) = cod(f)
      ex G1,G2,G3 being strict Element of V st g is Morphism of G2,G3
                                      & f is Morphism of G1,G2
 proof
   set X = Morphs(V);
   defpred P[Element of X,Element of X] means dom($1) = cod($2);
   let g,f be Element of X such that
   A1: P[g,f];
   consider G2,G3 being strict Element of V such that
   A2: g is strict Morphism of G2,G3 by Def30;
   A3: G2 = dom(g) by A2,Def19;
   consider G1,G2' being strict Element of V such that
   A4: f is strict Morphism of G1,G2' by Def30;
        G2' = cod(f) by A4,Def19;
   hence thesis by A1,A2,A3,A4;
 end;

theorem
Th45: for g,f being Element of Morphs(V) st dom(g) = cod(f)
      holds g*f in Morphs(V)
 proof
   set X = Morphs(V);
   defpred P[Element of X,Element of X] means dom($1) = cod($2);
   let g,f be Element of X; assume
        P[g,f];
   then consider G1,G2,G3 being strict Element of V such that
   A1: g is Morphism of G2,G3 & f is Morphism of G1,G2 by Th44;
   reconsider g' = g as Morphism of G2,G3 by A1;
   reconsider f' = f as Morphism of G1,G2 by A1;
       g'*f' is Morphism of G1,G3;
   hence thesis by Def30;
 end;

definition let V;
 func comp(V) -> PartFunc of [:Morphs(V),Morphs(V):],Morphs(V) means
 :Def35:
 (for g,f being Element of Morphs(V) holds [g,f] in dom it iff dom(g) = cod(f))
 & (for g,f being Element of Morphs(V) st [g,f] in dom it
    holds it.(g,f) = g*f);
 existence
  proof
    set X = Morphs(V);
    defpred P[Element of X,Element of X] means dom($1) = cod($2);
    deffunc F(Element of X,Element of X) = $1*$2;
    A1: for g,f being Element of X st P[g,f] holds F(g,f) in X by Th45;
    consider c being PartFunc of [:X,X:],X such that
    A2: for g,f being Element of X holds [g,f] in dom c iff P[g,f] and
    A3: for g,f being Element of X st [g,f] in dom c
        holds c.(g,f) = F(g,f) from BINOP_1:sch 8(A1);
    take c;
    thus thesis by A2,A3;
  end;
 uniqueness
  proof
    set X = Morphs(V);
    defpred P[Element of X,Element of X] means dom($1) = cod($2);
    let c1,c2 be PartFunc of [:X,X:],X such that
    A4: for g,f being Element of X holds [g,f] in dom c1 iff P[g,f] and
    A5: for g,f being Element of X st [g,f] in dom c1
         holds c1.(g,f) = g*f and
    A6: for g,f being Element of X holds [g,f] in dom c2 iff P[g,f] and
    A7: for g,f being Element of X st [g,f] in dom c2
         holds c2.(g,f) = g*f;
    A8: dom c1 c= [:X,X:] & dom c2 c= [:X,X:] by RELSET_1:12;
    A9: dom c1 = dom c2
     proof
           now let x; assume
         A10: x in dom c1;
         then consider g,f being Element of X such that
         A11: x = [g,f] by A8,Th2;
             P[g,f] by A4,A10,A11;
         hence x in dom c2 by A6,A11;end;
       then A12: dom c1 c= dom c2 by TARSKI:def 3;
           now let x; assume
         A13: x in dom c2;
         then consider g,f being Element of X such that
         A14: x = [g,f] by A8,Th2;
             P[g,f] by A6,A13,A14;
         hence x in dom c1 by A4,A14;end;
       then dom c2 c= dom c1 by TARSKI:def 3;
       hence thesis by A12,XBOOLE_0:def 10;
     end;
    set V' = dom c1;
        for x,y st [x,y] in V' holds c1.(x,y)=c2.(x,y)
     proof
       let x,y;assume
       A15: [x,y] in V';
       then reconsider x,y as Element of X by A8,ZFMISC_1:106;
           c1.(x,y) = x*y by A5,A15;
       hence thesis by A7,A9,A15;
     end;
    hence thesis by A9,BINOP_1:32;
  end;
end;

      ::
      ::  4e. Definition of Category of groups
      ::

definition let UN;
 func GroupCat(UN) -> CatStr equals
   CatStr(# GroupObjects(UN),Morphs(GroupObjects(UN)),
                   dom(GroupObjects(UN)),cod(GroupObjects(UN)),
                   comp(GroupObjects(UN)),ID(GroupObjects(UN))#);
 coherence;
end;

registration let UN;
 cluster GroupCat(UN) -> strict;
 coherence;
end;

theorem
 Th46: for f,g being Morphism of GroupCat(UN) holds
        [g,f] in dom(the Comp of GroupCat(UN)) iff dom g = cod f
  proof
    set C = GroupCat(UN), V = GroupObjects(UN);
    let f,g be Morphism of C;
    reconsider f' = f as Element of Morphs(V);
    reconsider g' = g as Element of Morphs(V);
    A1: dom g = dom(V).g' by CAT_1:def 2
             .= dom(g') by Def32;
         cod f = cod(V).f' by CAT_1:def 3
             .= cod(f') by Def33;
    hence thesis by A1,Def35;
  end;

theorem
 Th47: for f  being (Morphism of GroupCat(UN)),
           f' being Element of Morphs(GroupObjects(UN)),
           b  being Object of GroupCat(UN),
           b' being Element of GroupObjects(UN)
       holds f is strict Element of Morphs(GroupObjects(UN))
           & f' is Morphism of GroupCat(UN)
           & b is strict Element of GroupObjects(UN)
           & b' is Object of GroupCat(UN)
 proof
   set C = GroupCat(UN), V = GroupObjects(UN); set X = Morphs(V);
  let f  be (Morphism of C),
      f' be Element of X,
      b  be Object of C,
      b' be Element of V;
       ex G,H being strict Element of V st f is strict Morphism of G,H
 by Def30;
  hence f is strict Element of X;
  thus f' is Morphism of C;
   consider x such that
A1: x in UN & GO x,b by Def29;
       ex x1,x2,x3,x4 being set st
    x = [x1,x2,x3,x4] &
    ex G being strict AddGroup
    st b = G
    & x1 = the carrier of G
    & x2 = the add of G
    & x3 = comp G
    & x4 = 0.G by A1,Def28;
  hence b is strict Element of V;
  thus b' is Object of C;
 end;

theorem
 Th48: for b  being Object of GroupCat(UN),
           b' being Element of GroupObjects(UN)
       st b = b' holds id b = ID(b')
 proof
   set C = GroupCat(UN), V = GroupObjects(UN);
   let b  be Object of C, b' be Element of V; assume
        b = b';
   hence id b = (ID(V)).b' by CAT_1:def 5
            .= ID(b') by Def34;
 end;

 theorem
 Th49: for f  being Morphism of GroupCat(UN)
       for f' being Element of Morphs(GroupObjects(UN))
       st f = f'
       holds dom f = dom f'
           & cod f = cod f'
 proof
   set C = GroupCat(UN), V = GroupObjects(UN); set X = Morphs(V);
  let f be (Morphism of C), f' be Element of X; assume
  A1: f = f';
  hence dom f = dom(V).f' by CAT_1:def 2
            .= dom f' by Def32;
  thus cod f = cod(V).f' by A1,CAT_1:def 3
            .= cod f' by Def33;
 end;

 theorem
 Th50: for f,g   being (Morphism of GroupCat(UN)),
           f',g' being Element of Morphs(GroupObjects(UN))
       st f = f' & g = g'
       holds (dom g = cod f iff dom g' = cod f')
           & (dom g = cod f iff [g',f'] in dom comp(GroupObjects(UN)))
           & (dom g = cod f implies g*f = g'*f')
           & (dom f = dom g iff dom f' = dom g')
           & (cod f = cod g iff cod f' = cod g')
 proof
   set C = GroupCat(UN), V = GroupObjects(UN); set X = Morphs(V);
  let f,g be Morphism of C;
  let f',g' be Element of X; assume
  A1: f = f' & g = g';
  then A2: dom g = dom g' by Th49;
  A3: cod f = cod f' by A1,Th49;
  A4: dom f = dom f' by A1,Th49;
  A5: cod g = cod g' by A1,Th49;
  thus dom g = cod f iff dom g' = cod f' by A1,A3,Th49;
  thus A6: dom g = cod f iff [g',f'] in dom comp(V) by A2,A3,Def35;
  thus dom g = cod f implies g*f = g'*f'
   proof
     assume A7: dom g = cod f;
     then [g,f] in dom (the Comp of C) by Th46;
     hence g*f = (comp(V)).(g',f') by A1,CAT_1:def 4
              .= g'*f' by A6,A7,Def35;
   end;
  thus dom f = dom g iff dom f' = dom g' by A1,A4,Th49;
  thus cod f = cod g iff cod f' = cod g' by A1,A5,Th49;
 end;

 Lm4: for f,g being Morphism of GroupCat(UN) st dom g = cod f holds
     dom(g*f) = dom f
   & cod (g*f) = cod g
  proof set X = Morphs(GroupObjects(UN));
    let f,g be Morphism of GroupCat(UN) such that
    A1: dom g = cod f;
    reconsider f' = f as strict Element of X by Th47;
    reconsider g' = g as strict Element of X by Th47;
    A2: dom g' = cod f' by A1,Th50;
    then A3: dom(g'*f') = dom f'
      & cod (g'*f') = cod g' by Th31;
    reconsider gf = g'*f' as Element of X by A2,Th45;
        gf = g*f by A1,Th50;
    hence thesis by A3,Th50;
 end;

 Lm5: for f,g,h being Morphism of GroupCat(UN)
        st dom h = cod g & dom g = cod f holds h*(g*f) = (h*g)*f
  proof set X = Morphs(
(GroupObjects(UN)));
    let f,g,h be Morphism of (GroupCat(UN)) such that
    A1: dom h = cod g & dom g = cod f;
    reconsider f'=f, g'=g, h'=h as strict Element of X by Th47;
    A2: dom h' = cod g' & dom g' = cod f' by A1,Th50;
    A3: g'*f' = g*f & h'*g' = h*g by A1,Th50;
    reconsider gf = g'*f', hg = h'*g' as Element of X by A2,Th45;
    A4: dom(h) = cod(g*f) by A1,Lm4;
    A5: dom(h*g) = cod(f) by A1,Lm4;
        h*(g*f) = h'*gf by A3,A4,Th50
           .= hg*f' by A2,Th33
           .= (h*g)*f by A3,A5,Th50;
    hence thesis;
  end;

 Lm6: for b being Object of GroupCat(UN) holds
    dom id b = b
  & cod id b = b
  & (for f being Morphism of GroupCat(UN)
       st cod f = b holds (id b)*f = f)
  & (for g being Morphism of GroupCat(UN)
       st dom g = b holds g*(id b) = g)
proof
  set C = GroupCat(UN), V = GroupObjects(UN); set X = Morphs(V);
  let b be Object of C;
  reconsider b' = b as Element of V;
  reconsider b'' = b' as AddGroup;
  A1: id b = ID(b') by Th48;
  hence A2: dom id b = dom ID(b'') by Th49
                   .= b;
  thus A3: cod id b = cod ID(b'') by A1,Th49
                   .= b;
  thus for f being Morphism of C st cod f = b holds (id b)*f = f
   proof
     let f be Morphism of C such that
     A4: cod f = b;
     reconsider f1 = f as strict Element of X by Th47;
     reconsider f' = f1 as strict GroupMorphism;
     A5: cod f' = b'' by A4,Th49;
     thus (id b)*f = ID(b'')*f' by A1,A2,A4,Th50
                  .= f by A5,Th34;
   end;
  thus for g being Morphism of C st dom g = b holds g*(id b) = g
   proof
     let f be Morphism of C such that
     A6: dom f = b;
     reconsider f1 = f as strict Element of X by Th47;
     reconsider f' = f1 as strict GroupMorphism;
     A7: dom f' = b'' by A6,Th49;
     thus f*(id b) = f'*ID(b'') by A1,A3,A6,Th50
                  .= f by A7,Th34;
   end;
end;

registration let UN;
 cluster GroupCat(UN) -> Category-like;
 coherence
  proof
           ( for f,g being Morphism of GroupCat(UN)
          holds [g,f] in dom(the Comp of GroupCat(UN)) iff dom g = cod f )
     & ( for f,g being Morphism of GroupCat(UN) st dom g = cod f
          holds dom(g*f) = dom f & cod (g*f) = cod g )
     & ( for f,g,h being Morphism of GroupCat(UN)
          st dom h = cod g & dom g = cod f holds h*(g*f) = (h*g)*f )
     & ( for b being Object of GroupCat(UN)
          holds dom id b = b & cod id b = b &
           (for f being Morphism of GroupCat(UN)
             st cod f = b holds (id b)*f = f) &
           (for g being Morphism of GroupCat(UN)
             st dom g = b holds g*(id b) = g) ) by Lm4,Lm5,Lm6,Th46;
   hence thesis by CAT_1:29;
  end;
end;

definition let UN;
 func AbGroupObjects(UN) -> Subset of the Objects of GroupCat(UN) equals
   {G where G is Element of the Objects of GroupCat(UN)
                 : ex H being AbGroup st G = H};
 coherence
  proof
    set D2 = the Objects of GroupCat(UN);
        now
      let x be set;
      assume x in {G where G is Element of D2 : ex H being AbGroup st G = H};
      then ex G being Element of D2 st x = G & ex H being AbGroup st G = H;
      hence x in D2;end;
    hence thesis by TARSKI:def 3;
  end;
end;

theorem
Th51: L_Trivial in AbGroupObjects(UN)
 proof
    L_Trivial in the Objects of GroupCat(UN) by Th42;
    hence thesis;
 end;

registration let UN;
 cluster AbGroupObjects(UN) -> non empty;
 coherence by Th51;
end;

definition let UN;
 func AbGroupCat(UN) -> Subcategory of GroupCat(UN) equals
   cat(AbGroupObjects(UN));
 coherence;
end;

registration let UN;
 cluster AbGroupCat(UN) -> strict;
 coherence;
end;

theorem
 the Objects of AbGroupCat(UN) = AbGroupObjects(UN);

::  6. Subcategory of groups with the operator of 1/2

definition let UN;
 func MidOpGroupObjects(UN) -> Subset of the Objects of AbGroupCat(UN) equals
   {G where G is Element of the Objects of AbGroupCat(UN)
                 : ex H being midpoint_operator AbGroup st G = H};
 coherence
  proof
    set D2 = the Objects of AbGroupCat(UN);
        now
      let x be set;
      assume x in {G where G is Element of D2
               : ex H being midpoint_operator AbGroup st G = H};
      then ex G being Element of D2 st
 x = G & ex H being midpoint_operator AbGroup st G = H;
      hence x in D2;end;
    hence thesis by TARSKI:def 3;
  end;
end;

registration let UN;
 cluster MidOpGroupObjects(UN) -> non empty;
 coherence
  proof
    set D2 = the Objects of AbGroupCat(UN);
    set D1 = {G where G is Element of D2
               : ex H being midpoint_operator AbGroup st G = H};
    set T = L_Trivial;
    T in D2 by Th51;
    then T in D1;
    then reconsider D1 as non empty set;
        now
      let x be set;
      assume x in D1;
      then ex G being Element of D2 st
 x = G & ex H being midpoint_operator AbGroup st G = H;
      hence x in D2;end;
    hence thesis;
  end;
end;

definition let UN;
 func MidOpGroupCat(UN) -> Subcategory of AbGroupCat(UN) equals
  cat(MidOpGroupObjects(UN));
 coherence;
end;

registration let UN;
 cluster MidOpGroupCat(UN) -> strict;
 coherence;
end;

theorem
    the Objects of MidOpGroupCat(UN) = MidOpGroupObjects(UN);

theorem
    L_Trivial in MidOpGroupObjects(UN)
 proof
    L_Trivial in the Objects of AbGroupCat(UN) by Th51;
    hence thesis;
 end;

canceled;

theorem :: WAYBEL29:1
 for S, T being non empty 1-sorted
 for f being Function of S, T st f is one-to-one onto
  holds f*f" = id T & f"*f = id S & f" is one-to-one onto
  proof let S, T be non empty 1-sorted;
   let f be Function of S, T;
A1:  dom f = the carrier of S by FUNCT_2:def 1;
   assume f is one-to-one onto;
    then f is one-to-one & rng f = the carrier of T & [#]T = the carrier of T
     by FUNCT_2:def 3;
    then f*f" = id the carrier of T & f"*f = id the carrier of S &
    rng (f") = [#]S & f" is one-to-one & [#]S = the carrier of S
     by A1,TOPS_2:62,63,65;
   hence thesis by FUNCT_2:def 3;
  end;

