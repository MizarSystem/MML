:: Preliminaries to Structures
::  by Library Committee
::
:: Received January 6, 1995
:: Copyright (c) 1995 Association of Mizar Users

environ

 vocabularies SETFAM_1, FUNCT_1, FINSEQ_1, PBOOLE, SUBSET_1, BOOLE, RLVECT_1,
      GROUP_1, VECTSP_1, NORMSP_1, PARTFUN1, REALSET1, STRUCT_0, FINSET_1,
      ARYTM, XREAL_0, FUNCT_7, COLLSP, AMI_1, FUNCOP_1, RELAT_1, ANPROJ_1,
      CARD_1;
 notations TARSKI, XBOOLE_0, SUBSET_1, SETFAM_1, FINSET_1, CARD_1,
      RELSET_1, PARTFUN1, FUNCT_2, NAT_1,
      NUMBERS, FINSEQ_1, FUNCOP_1,
      REALSET1, PBOOLE, FUNCT_7;
 constructors PARTFUN1, PBOOLE, REALSET1, FUNCT_7, SETFAM_1;
 registrations XBOOLE_0, FUNCT_1, FUNCT_2, REALSET1, CARD_5;
 requirements BOOLE, SUBSET;
 definitions SUBSET_1, TARSKI, XBOOLE_0, REALSET1;
 theorems TARSKI, REALSET1, XBOOLE_0, SUBSET_1, CARD_1, FUNCT_7;

begin

definition
  struct 1-sorted(# carrier -> set #);
end;

definition
  let S be 1-sorted;
  attr S is empty means
  :Def1:
  the carrier of S is empty;
end;

registration
  cluster strict empty 1-sorted;
  existence
  proof
    take T = 1-sorted(#{}#);
    thus T is strict;
    thus the carrier of T is empty;
  end;
end;

registration
  cluster strict non empty 1-sorted;
  existence
  proof
    take 1-sorted(#{{}}#);
    thus 1-sorted(#{{}}#) is strict;
    thus the carrier of 1-sorted(#{{}}#) is non empty;
  end;
end;

registration
  let S be empty 1-sorted;
  cluster the carrier of S -> empty;
  coherence by Def1;
end;

registration
  let S be non empty 1-sorted;
  cluster the carrier of S -> non empty;
  coherence by Def1;
end;

definition
  let S be 1-sorted;
  mode Element of S is Element of the carrier of S;
  mode Subset of S is Subset of the carrier of S;
  mode Subset-Family of S is Subset-Family of the carrier of S;
end;

:: Added by AK on 2005.09.22
:: Moved from ALG_1, GROUP_6, PRE_TOPC, POLYNOM1

definition
  let S be 1-sorted, X be set;
  mode Function of S,X is Function of the carrier of S, X;
  mode Function of X,S is Function of X, the carrier of S;
end;

definition
  let S, T be 1-sorted;
  mode Function of S,T is Function of the carrier of S, the carrier of T;
end;

:: from PRE_TOPC, 2006.12.02, AT

definition
  let T be 1-sorted;
  func {}T -> Subset of T equals

  {};
  coherence
  proof
    {} = {}the carrier of T;
    hence thesis;
  end;
  func [#]T -> Subset of T equals

  the carrier of T;
  coherence
  proof
    the carrier of T = [#]the carrier of T;
    hence thesis;
  end;
end;

registration
  let T be 1-sorted;
  cluster {}T -> empty;
  coherence;
end;

registration
  let T be empty 1-sorted;
  cluster [#]T -> empty;
  coherence;
end;

registration
  let T be non empty 1-sorted;
  cluster [#]T -> non empty;
  coherence;
end;

registration
  let S be non empty 1-sorted;
  cluster non empty Subset of S;
  existence
  proof
    take [#]S;
    thus thesis;
  end;
end;

::Moved from TOPREAL1 on 2005.09.22

definition
  let S be 1-sorted;
  mode FinSequence of S is FinSequence of the carrier of S;
end;

::Moved from YELLOW18, AK, 21.02.2006

definition
  let S be 1-sorted;
  mode ManySortedSet of S is ManySortedSet of the carrier of S;
end;

::Moved from GRCAT_1, AK, 16.01.2007

definition
  let S be 1-sorted;
  func id S -> Function of S,S equals

  id the carrier of S;
  coherence;
end;

::Moved from NORMSP_1, AK, 14.02.2007

definition
  let S be 1-sorted;
  mode sequence of S is sequence of the carrier of S;
end;

::Moved from NFCONT_1, AK, 14.02.2007

definition
  let S,T be 1-sorted;
  mode PartFunc of S,T is PartFunc of the carrier of S,the carrier of T;
end;

::Moved from RLVECT_1, 2007.02.19, A.T.

definition
  let S be 1-sorted;
  let x be set;
  pred x in S means

  x in the carrier of S;
end;

:: Pointed structures

definition
  struct (1-sorted) ZeroStr(# carrier -> set,
    ZeroF -> Element of the carrier #);
end;

registration
  cluster strict non empty ZeroStr;
  existence
  proof consider A being non empty set, a being Element of A;
    take ZeroStr(#A,a#);
    thus ZeroStr(#A,a#) is strict;
    thus the carrier of ZeroStr(#A,a#) is non empty;
  end;
end;

definition
  struct (1-sorted) OneStr(# carrier -> set,
    OneF -> Element of the carrier #);
end;

definition
  struct (ZeroStr,OneStr) ZeroOneStr(# carrier -> set,
    ZeroF -> Element of the carrier, OneF -> Element of the carrier #);
end;

definition
  let S be ZeroStr;
  func 0.S -> Element of S equals

  the ZeroF of S;
  coherence;
end;

definition
  let S be OneStr;
  func 1.S -> Element of S equals

  the OneF of S;
  coherence;
end;

definition
  let S be ZeroOneStr;
  attr S is degenerated means
  :Def8:
  0.S = 1.S;
end;

definition
  let IT be 1-sorted;
  attr IT is trivial means
  :Def9:
  the carrier of IT is trivial;
end;

registration
  cluster empty -> trivial 1-sorted;
  coherence
  proof
    let S be 1-sorted;
    assume the carrier of S is empty;
    hence the carrier of S is trivial;
  end;
  cluster non trivial -> non empty 1-sorted;
  coherence;
end;

definition
  let S be 1-sorted;
  redefine attr S is trivial means
  :Def10:
  for x,y being Element of S holds x = y;
  compatibility
  proof
    set I = the carrier of S;
    per cases;
    suppose
A1:   I is non empty;
      thus S is trivial implies for x,y being Element of I holds x = y
      proof
        assume I is trivial;
        then consider a being set such that
A2:     I = {a} by A1,REALSET1:def 4;
        let x, y be Element of I;
        thus x = a by A2,TARSKI:def 1
          .= y by A2,TARSKI:def 1;
      end;
      assume
A3:   for x,y being Element of I holds x = y;
      consider a being set such that
A4:   a in I by A1,XBOOLE_0:def 1;
      I = {a}
      proof
        hereby
          let i be set;
          assume i in I;
          then a = i by A3,A4;
          hence i in {a} by TARSKI:def 1;
        end;
        let i be set;
        assume i in {a};
        hence i in I by A4,TARSKI:def 1;
      end;
      hence I is empty or ex x being set st I = {x};
    end;
    suppose
A5:   I is empty;
      for x,y being Element of I holds x = y
      proof
        let x, y be Element of I;
        thus x = {} by A5,SUBSET_1:def 2
          .= y by A5,SUBSET_1:def 2;
      end;
      hence thesis by A5;
    end;
  end;
end;

registration
  cluster non degenerated -> non trivial ZeroOneStr;
  coherence
  proof
    let L be ZeroOneStr;
    assume
A1: L is non degenerated;
    assume L is trivial;
    then 0.L = 1.L by Def10;
    hence contradiction by A1,Def8;
  end;
end;

registration
  cluster trivial non empty 1-sorted;
  existence
  proof
    take Y = 1-sorted (#1#);
    thus thesis by Def9,CARD_1:87;
  end;
  cluster non trivial non empty 1-sorted;
  existence
  proof
    take Y = 1-sorted (#2#);
    thus Y is non trivial
    proof
      reconsider x=0, y=1 as Element of Y by CARD_1:88,TARSKI:def 2;
      take x,y;
      thus thesis;
    end;
    thus thesis;
  end;
end;

registration
  let S be non trivial 1-sorted;
  cluster the carrier of S -> non trivial;
  coherence by Def9;
end;

registration
  let S be trivial 1-sorted;
  cluster the carrier of S -> trivial;
  coherence by Def9;
end;

begin :: Finite 1-sorted Structures

definition
  let S be 1-sorted;
  attr S is finite means
  :Def11:
  the carrier of S is finite;
end;

registration :: WAYBEL11
  cluster strict finite non empty 1-sorted;
  existence
  proof
    take 1-sorted(#{{}}#);
    thus thesis by Def11;
  end;
end;

registration
  let S be finite 1-sorted; :: YELLOW13
  cluster the carrier of S -> finite;
  coherence by Def11;
end;

registration
  cluster -> finite (empty 1-sorted);
  coherence
  proof
    let S be empty 1-sorted;
    thus the carrier of S is finite;
  end;
end;

notation
  let S be 1-sorted;
  antonym S is infinite for S is finite;
end;

registration
  cluster strict infinite 1-sorted;
  existence
  proof consider o being infinite set;
    take A = 1-sorted(#o#);
    thus A is strict;
    thus the carrier of A is infinite;
  end;
end;

registration
  let S be infinite 1-sorted;
  cluster the carrier of S -> infinite;
  coherence by Def11;
end;

registration
  cluster -> non empty (infinite 1-sorted);
  coherence;
end;

:: from YELLOW_13, 2007.04.12, A.T.

registration
  cluster trivial -> finite 1-sorted;
  coherence
  proof
    let S be 1-sorted;
    assume S is trivial;
    then reconsider C = the carrier of S as trivial set;
    C is finite;
    hence the carrier of S is finite;
  end;
end;

registration
  cluster infinite -> non trivial 1-sorted;
  coherence;
end;

definition
  let S be ZeroStr, x be Element of S;
  attr x is zero means
  :Def12:
  x = 0.S;
end;

registration
  let S be ZeroStr;
  cluster 0.S -> zero;
  coherence by Def12;
end;

registration
  cluster strict non degenerated ZeroOneStr;
  existence
  proof
    take S = ZeroOneStr(#2,In(0,2),In(1,2)#);
    0 in 2 & 1 in 2 by CARD_1:88,TARSKI:def 2;
    then In(0,2) = 0 & In(1,2) = 1 by FUNCT_7:def 1;
    then 0.S <> 1.S;
    hence thesis by Def8;
  end;
end;

registration
  let S be non degenerated ZeroOneStr;
  cluster 1.S -> non zero;
  coherence
  proof
    0.S <> 1.S by Def8;
    hence thesis by Def12;
  end;
end;

definition let S be 1-sorted;
 mode Cover of S is Cover of the carrier of S;
end;

:: from RING_1, 2008.06.19, A.T. (needed in TEX_2)

registration
  let S be 1-sorted;
  cluster [#]S -> non proper;
  coherence
  proof
    thus [#]S = the carrier of S;
  end;
end;

begin :: 2-sorted structures, 2008.07.02, A.T.

definition
 struct(1-sorted) 2-sorted(#carrier,carrier' -> set#);
end;

definition let S be 2-sorted;
 attr S is void means
:Def13: the carrier' of S is empty;
end;

registration
 cluster strict empty void 2-sorted;
 existence
  proof
   take S = 2-sorted(#{},{}#);
   thus S is strict;
   thus the carrier of S is empty;
   thus the carrier' of S is empty;
  end;
end;

registration let S be void 2-sorted;
 cluster the carrier' of S -> empty;
 coherence by Def13;
end;

registration
 cluster strict non empty non void 2-sorted;
 existence
  proof
   take S = 2-sorted(#1,1#);
   thus S is strict;
   thus the carrier of S is not empty;
   thus the carrier' of S is not empty;
  end;
end;

registration let S be non void 2-sorted;
 cluster the carrier' of S -> non empty;
 coherence by Def13;
end;

:: from BORSUK_1, 2008.07.07, A.T.

definition
  let X be 1-sorted,Y be non empty 1-sorted, y be Element of Y;
  func X --> y -> Function of X,Y equals
  (the carrier of X) --> y;
  coherence;
end;

:: from RLVECT_1, 2008.07.28, A.T

definition let S be ZeroStr, x be Element of S;
  attr x is zero means
  x = 0.S;
end;

registration let S be ZeroStr;
 cluster zero Element of S;
 existence
  proof
   take 0.S;
   thus 0.S = 0.S;
  end;
end;

registration
 cluster strict non trivial ZeroStr;
 existence
  proof
    take S = ZeroStr(#2,In(0,2)#);
    0 in 2 & 1 in 2 by CARD_1:88,TARSKI:def 2;
    then In(0,2) = 0 & In(1,2) = 1 by FUNCT_7:def 1;
    hence thesis by Def10;
  end;
end;

registration let S be non trivial ZeroStr;
 cluster non zero Element of S;
 existence
  proof
    consider x,y being Element of S such that
W:   x <> y by Def10;
   per cases by W;
   suppose
S:   x <> 0.S;
    take x;
    thus x <> 0.S by S;
   end;
   suppose
S:   y <> 0.S;
    take y;
    thus y <> 0.S by S;
   end;
  end;
end;

:: comp. NDIFF_1, 2008.08.29, A.T.

definition let X be set, S be ZeroStr, R be Relation of X, the carrier of S;
 attr R is non-zero means
  not 0.S in rng R;
end;

:: 2008.10.12, A.T.

definition let S be 1-sorted;
 func card S -> Cardinal equals
  card the carrier of S;
 coherence;
end;
