:: Preliminaries to Structures
::  by Library Committee
::
:: Received January 6, 1995
:: Copyright (c) 1995 Association of Mizar Users
 
environ

 vocabularies XBOOLE_0, SUBSET_1, SETFAM_1, FUNCT_1, FINSEQ_1, PBOOLE, RELAT_1,
      NAT_1, PARTFUN1, SUPINF_2, MESFUNC1, ZFMISC_1, CARD_1, FINSET_1,
      XCMPLX_0, FUNCT_7, FUNCOP_1, VALUED_0, BINOP_1, STRUCT_0;
 notations TARSKI, XBOOLE_0, SUBSET_1, SETFAM_1, FINSET_1, CARD_1, RELAT_1,
      RELSET_1, PARTFUN1, FUNCT_2, BINOP_1, NAT_1, FINSEQ_1, FUNCOP_1,
      REALSET1, PBOOLE, FUNCT_7;
 constructors PARTFUN1, PBOOLE, REALSET1, FUNCT_7, SETFAM_1, RELSET_1;
 registrations XBOOLE_0, FUNCT_1, FUNCT_2, REALSET1, CARD_5, ZFMISC_1;
 requirements BOOLE, SUBSET;
 definitions SUBSET_1, TARSKI, XBOOLE_0, REALSET1;
 theorems TARSKI, REALSET1, XBOOLE_0, SUBSET_1, CARD_1, FUNCT_7, ZFMISC_1;

begin

definition
  struct 1-sorted(# carrier -> set #);
end;

definition
  let S be 1-sorted;
  attr S is empty means
  :Def1:
  the carrier of S is empty;
end;

registration
  cluster strict empty 1-sorted;
  existence
  proof
    take T = 1-sorted(#{}#);
    thus T is strict;
    thus the carrier of T is empty;
  end;
end;

registration
  cluster strict non empty 1-sorted;
  existence
  proof
    take 1-sorted(#{{}}#);
    thus 1-sorted(#{{}}#) is strict;
    thus the carrier of 1-sorted(#{{}}#) is non empty;
  end;
end;

registration
  let S be empty 1-sorted;
  cluster the carrier of S -> empty;
  coherence by Def1;
end;

registration
  let S be non empty 1-sorted;
  cluster the carrier of S -> non empty;
  coherence by Def1;
end;

definition
  let S be 1-sorted;
  mode Element of S is Element of the carrier of S;
  mode Subset of S is Subset of the carrier of S;
  mode Subset-Family of S is Subset-Family of the carrier of S;
end;
 
:: Added by AK on 2005.09.22
:: Moved from ALG_1, GROUP_6, PRE_TOPC, POLYNOM1

definition
  let S be 1-sorted, X be set;
  mode Function of S,X is Function of the carrier of S, X;
  mode Function of X,S is Function of X, the carrier of S;
end;

definition
  let S, T be 1-sorted;
  mode Function of S,T is Function of the carrier of S, the carrier of T;
end;
 
:: from PRE_TOPC, 2006.12.02, AT

definition
  let T be 1-sorted;
  func {}T -> Subset of T equals
  {};
  coherence
  proof
    {} = {}the carrier of T;
    hence thesis;
  end;
  func [#]T -> Subset of T equals
  the carrier of T;
  coherence
  proof
    the carrier of T = [#]the carrier of T;
    hence thesis;
  end;
end;

registration
  let T be 1-sorted;
  cluster {}T -> empty;
  coherence;
end;

registration
  let T be empty 1-sorted;
  cluster [#]T -> empty;
  coherence;
end;

registration
  let T be non empty 1-sorted;
  cluster [#]T -> non empty;
  coherence;
end;

registration
  let S be non empty 1-sorted;
  cluster non empty Subset of S;
  existence
  proof
    take [#]S;
    thus thesis;
  end;
end;
 
::Moved from TOPREAL1 on 2005.09.22

definition
  let S be 1-sorted;
  mode FinSequence of S is FinSequence of the carrier of S;
end;
 
::Moved from YELLOW18, AK, 21.02.2006

definition
  let S be 1-sorted;
  mode ManySortedSet of S is ManySortedSet of the carrier of S;
end;
 
::Moved from GRCAT_1, AK, 16.01.2007

definition
  let S be 1-sorted;
  func id S -> Function of S,S equals
  id the carrier of S;
  coherence;
end;
 
::Moved from NORMSP_1, AK, 14.02.2007

definition
  let S be 1-sorted;
  mode sequence of S is sequence of the carrier of S;
end;
 
::Moved from NFCONT_1, AK, 14.02.2007

definition
  let S,T be 1-sorted;
  mode PartFunc of S,T is PartFunc of the carrier of S,the carrier of T;
end;
 
::Moved from RLVECT_1, 2007.02.19, A.T.

definition
  let S be 1-sorted;
  let x be set;
  pred x in S means
  x in the carrier of S;
end;
 
:: Pointed structures

definition
  struct (1-sorted) ZeroStr(# carrier -> set, ZeroF -> Element of the carrier
  #);
end;

registration
  cluster strict non empty ZeroStr;
  existence
  proof
    consider A being non empty set, a being Element of A;
    take ZeroStr(#A,a#);
    thus ZeroStr(#A,a#) is strict;
    thus the carrier of ZeroStr(#A,a#) is non empty;
  end;
end;

definition
  struct (1-sorted) OneStr(# carrier -> set, OneF -> Element of the carrier #);
end;

definition
  struct (ZeroStr,OneStr) ZeroOneStr(# carrier -> set, ZeroF -> Element of the
    carrier, OneF -> Element of the carrier #);
end;

definition
  let S be ZeroStr;
  func 0.S -> Element of S equals
  the ZeroF of S;
  coherence;
end;

definition
  let S be OneStr;
  func 1.S -> Element of S equals
  the OneF of S;
  coherence;
end;

definition
  let S be ZeroOneStr;
  attr S is degenerated means
  :Def8:
  0.S = 1.S;
end;

definition
  let IT be 1-sorted;
  attr IT is trivial means
  :Def9:
  the carrier of IT is trivial;
end;

registration
  cluster empty -> trivial 1-sorted;
  coherence
  proof
    let S be 1-sorted;
    assume the carrier of S is empty;
    hence the carrier of S is trivial;
  end;
  cluster non trivial -> non empty 1-sorted;
  coherence;
end;

definition
  let S be 1-sorted;
  redefine attr S is trivial means
  :Def10:
  for x,y being Element of S holds x = y;
  compatibility
  proof
    set I = the carrier of S;
    per cases;
    suppose
A1:   I is non empty;
      thus S is trivial implies for x,y being Element of I holds x = y
      proof
        assume I is trivial;
        then consider a being set such that
A2:     I = {a} by A1,REALSET1:def 4;
        let x, y be Element of I;
        thus x = a by A2,TARSKI:def 1
          .= y by A2,TARSKI:def 1;
      end;
      consider a being set such that
A3:   a in I by A1,XBOOLE_0:def 1;
      assume
A4:   for x,y being Element of I holds x = y;
      I = {a}
      proof
        hereby
          let i be set;
          assume i in I;
          then a = i by A4,A3;
          hence i in {a} by TARSKI:def 1;
        end;
        let i be set;
        assume i in {a};
        hence thesis by A3,TARSKI:def 1;
      end;
      hence I is empty or ex x being set st I = {x};
    end;
    suppose
A5:   I is empty;
      for x,y being Element of I holds x = y
      proof
        let x, y be Element of I;
        thus x = {} by A5,SUBSET_1:def 2
          .= y by A5,SUBSET_1:def 2;
      end;
      hence thesis by A5;
    end;
  end;
end;

registration
  cluster non degenerated -> non trivial ZeroOneStr;
  coherence
  proof
    let L be ZeroOneStr;
    assume
A1: L is non degenerated;
    assume L is trivial;
    then 0.L = 1.L by Def10;
    hence contradiction by A1,Def8;
  end;
end;

registration
  cluster trivial non empty 1-sorted;
  existence
  proof
    take 1-sorted (#1#);
    thus thesis by Def9,CARD_1:87;
  end;
  cluster non trivial non empty 1-sorted;
  existence
  proof
    take Y = 1-sorted (#2#);
    thus Y is non trivial
    proof
      reconsider x=0, y=1 as Element of Y by CARD_1:88,TARSKI:def 2;
      take x,y;
      thus thesis;
    end;
    thus thesis;
  end;
end;

registration
  let S be non trivial 1-sorted;
  cluster the carrier of S -> non trivial;
  coherence by Def9;
end;

registration
  let S be trivial 1-sorted;
  cluster the carrier of S -> trivial;
  coherence by Def9;
end;

begin :: Finite 1-sorted Structures

definition
  let S be 1-sorted;
  attr S is finite means
  :Def11:
  the carrier of S is finite;
end;

registration
  cluster strict finite non empty 1-sorted;
  existence
  proof
    take 1-sorted(#{{}}#);
    thus thesis by Def11;
  end;
end;

registration
  let S be finite 1-sorted;
  cluster the carrier of S -> finite;
  coherence by Def11;
end;

registration
  cluster -> finite (empty 1-sorted);
  coherence
  proof
    let S be empty 1-sorted;
    thus the carrier of S is finite;
  end;
end;

notation
  let S be 1-sorted;
  antonym S is infinite for S is finite;
end;

registration
  cluster strict infinite 1-sorted;
  existence
  proof
    consider o being infinite set;
    take A = 1-sorted(#o#);
    thus A is strict;
    thus the carrier of A is infinite;
  end;
end;

registration
  let S be infinite 1-sorted;
  cluster the carrier of S -> infinite;
  coherence by Def11;
end;

registration
  cluster -> non empty (infinite 1-sorted);
  coherence;
end;
 
:: from YELLOW_13, 2007.04.12, A.T.

registration
  cluster trivial -> finite 1-sorted;
  coherence
  proof
    let S be 1-sorted;
    assume S is trivial;
    then reconsider C = the carrier of S as trivial set;
    C is finite;
    hence the carrier of S is finite;
  end;
end;

registration
  cluster infinite -> non trivial 1-sorted;
  coherence;
end;

definition
  let S be ZeroStr, x be Element of S;
  attr x is zero means
  :Def12:
  x = 0.S;
end;

registration
  let S be ZeroStr;
  cluster 0.S -> zero;
  coherence by Def12;
end;

registration
  cluster strict non degenerated ZeroOneStr;
  existence
  proof
    take S = ZeroOneStr(#2,In(0,2),In(1,2)#);
    0 in 2 by CARD_1:88,TARSKI:def 2;
    then 1 in 2 & In(0,2) = 0 by CARD_1:88,FUNCT_7:def 1,TARSKI:def 2;
    then 0.S <> 1.S by FUNCT_7:def 1;
    hence thesis by Def8;
  end;
end;

registration
  let S be non degenerated ZeroOneStr;
  cluster 1.S -> non zero;
  coherence
  proof
    0.S <> 1.S by Def8;
    hence thesis by Def12;
  end;
end;

definition
  let S be 1-sorted;
  mode Cover of S is Cover of the carrier of S;
end;
 
:: from RING_1, 2008.06.19, A.T. (needed in TEX_2)

registration
  let S be 1-sorted;
  cluster [#]S -> non proper;
  coherence
  proof
    thus [#]S = the carrier of S;
  end;
end;

begin :: 2-sorted structures, 2008.07.02, A.T.

definition
  struct(1-sorted) 2-sorted(#carrier,carrier' -> set#);
end;

definition
  let S be 2-sorted;
  attr S is void means
  :Def13:
  the carrier' of S is empty;
end;

registration
  cluster strict empty void 2-sorted;
  existence
  proof
    take S = 2-sorted(#{},{}#);
    thus S is strict;
    thus the carrier of S is empty;
    thus the carrier' of S is empty;
  end;
end;

registration
  let S be void 2-sorted;
  cluster the carrier' of S -> empty;
  coherence by Def13;
end;

registration
  cluster strict non empty non void 2-sorted;
  existence
  proof
    take S = 2-sorted(#1,1#);
    thus S is strict;
    thus the carrier of S is not empty;
    thus the carrier' of S is not empty;
  end;
end;

registration
  let S be non void 2-sorted;
  cluster the carrier' of S -> non empty;
  coherence by Def13;
end;
 
:: from BORSUK_1, 2008.07.07, A.T.

definition
  let X be 1-sorted,Y be non empty 1-sorted, y be Element of Y;
  func X --> y -> Function of X,Y equals
  (the carrier of X) --> y;
  coherence;
end;

registration
  let S be ZeroStr;
  cluster zero Element of S;
  existence
  proof
    take 0.S;
    thus 0.S = 0.S;
  end;
end;

registration
  cluster strict non trivial ZeroStr;
  existence
  proof
    take ZeroStr(#2,In(0,2)#);
    0 in 2 & 1 in 2 by CARD_1:88,TARSKI:def 2;
    hence thesis by Def10;
  end;
end;

registration
  let S be non trivial ZeroStr;
  cluster non zero Element of S;
  existence
  proof
    consider x,y being Element of S such that
A1: x <> y by Def10;
    per cases by A1;
    suppose
A2:   x <> 0.S;
      take x;
      thus x <> 0.S by A2;
    end;
    suppose
A3:   y <> 0.S;
      take y;
      thus y <> 0.S by A3;
    end;
  end;
end;
 
:: comp. NDIFF_1, 2008.08.29, A.T.

definition
  canceled;
  let X be set, S be ZeroStr, R be Relation of X, the carrier of S;
  attr R is non-zero means
  not 0.S in rng R;
end;
 
:: 2008.10.12, A.T.

definition
  let S be 1-sorted;
  func card S -> Cardinal equals
  card the carrier of S;
  coherence;
end;
 
:: 2009.01.11, A.K.

definition
  let S be 1-sorted;
  mode UnOp of S is UnOp of the carrier of S;
  mode BinOp of S is BinOp of the carrier of S;
end;
 
:: 2009.01.24, A.T.

definition
  let S be ZeroStr;
  func NonZero S -> Subset of S equals
  [#]S \ {0.S};
  coherence;
end;

theorem
  for S being non empty ZeroStr for u being Element of S holds u in
  NonZero S iff u is not zero
proof
  let S be non empty ZeroStr;
  let u be Element of S;
  thus u in NonZero S implies u is not zero
  proof
    assume u in NonZero S;
    then u <> 0.S by ZFMISC_1:64;
    hence thesis by Def12;
  end;
                         :: usunac !!! ???
  thus u is not zero implies u in NonZero S by ZFMISC_1:64;
end;

definition
  let V be non empty ZeroStr;
  redefine attr V is trivial means
  :Def19:
  for u being Element of V holds u = 0.V;
  compatibility
  proof
    thus V is trivial implies for a being Element of V holds a = 0.V by Def10;
    assume
A1: for a being Element of V holds a = 0.V;
    let a,b be Element of V;
    thus a = 0.V by A1
      .= b by A1;
  end;
end;

registration
  let V be non trivial ZeroStr;
  cluster NonZero V -> non empty;
  coherence
  proof
    ex u being Element of V st u <> 0.V by Def19;
    hence thesis by ZFMISC_1:64;
  end;
end;

registration
  let S be non empty 1-sorted;
  cluster non empty trivial Subset of S;
  existence
  proof
    {the Element of S} is Subset of S by ZFMISC_1:37;
    hence thesis;
  end;
end;

theorem
  for F being non degenerated ZeroOneStr holds 1.F in NonZero F
proof
  let F be non degenerated ZeroOneStr;
  not 1.F in {0.F} by TARSKI:def 1;
  hence thesis by XBOOLE_0:def 5;
end;
