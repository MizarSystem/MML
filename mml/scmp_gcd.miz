:: Recursive Euclide Algorithm
::  by JingChao Chen
::
:: Received June 15, 1999
:: Copyright (c) 1999 Association of Mizar Users

environ

 vocabularies AMI_3, SCMPDS_2, AMI_1, SCMPDS_4, ARYTM_3, NAT_1, INT_1, INT_2,
      ABSVALUE, SCMPDS_3, AMI_2, ARYTM_1, CARD_1, SCMFSA6A, SCMFSA_7, FUNCT_1,
      RELAT_1, SCMPDS_1, FUNCOP_1, FUNCT_4, BOOLE, SCMP_GCD, ARYTM;
 notations XBOOLE_0, SUBSET_1, CARD_1, NUMBERS, XCMPLX_0, RELAT_1, FUNCT_1,
      INT_1, NAT_1, NAT_D, DOMAIN_1, STRUCT_0, FUNCT_4, AMI_1, SCMNORM, AMI_2,
      AMI_3, SCMPDS_1, SCMPDS_2, SCMPDS_3, SCMPDS_4, INT_2, XXREAL_0;
 constructors DOMAIN_1, XXREAL_0, REAL_1, NAT_1, NAT_D, SCMPDS_1, SCMPDS_4,
      AMI_3, SCMNORM;
 registrations SETFAM_1, RELSET_1, FRAENKEL, NUMBERS, XREAL_0, INT_1, CARD_3,
      STRUCT_0, SCMPDS_2, ORDINAL1;
 requirements NUMERALS, REAL, SUBSET, ARITHM, BOOLE;
 definitions AMI_1, SCMPDS_3, AMI_3;
 theorems AMI_1, AMI_3, NAT_1, TARSKI, FUNCT_4, INT_1, SCMPDS_2, ABSVALUE,
      GRFUNC_1, SCMPDS_4, SCMPDS_5, SCMPDS_6, ENUMSET1, SCMPDS_1, INT_2,
      XBOOLE_0, XBOOLE_1, NEWTON, XREAL_1, RELAT_1, XXREAL_0, ORDINAL1, NAT_D;
 schemes NAT_1;

begin :: Preliminaries

reserve m,n for Element of NAT,
  a,b for Int_position,
  i,j for Instruction of SCMPDS,
  s,s1,s2 for State of SCMPDS,
  I,J for Program-block;

canceled 2;

theorem Th3:
  for m being Element of NAT,j being Integer st inspos m=j holds
  inspos(m+2) = (abs(j))+2
proof
  let m be Element of NAT,j be Integer;
  assume inspos m=j;
  then
A1: j=il.m
    .=m;
  then j >= 0 by NAT_1:2;
  hence (abs(j))+2 = m+2 by A1,ABSVALUE:def 1
    .= il.(m+2)
    .= inspos(m+2);
end;

definition
  let k be Nat;
  func intpos k -> Int_position equals

  dl.k;
  coherence
  proof
    dl.k in SCM-Data-Loc by AMI_3:def 2;
    hence dl.k is Int_position by SCMPDS_2:def 1,def 2;
  end;
end;

canceled;

theorem Th5:
  for n1,n2 be Element of NAT holds DataLoc(n1,n2) = intpos(n1+n2)
proof
  let n1,n2 be Element of NAT;
A1: n1+n2 >= 0 by NAT_1:2;
  thus DataLoc(n1,n2)=[1,abs(n1+n2)] by SCMPDS_2:def 4
    .=[1,n1+n2] by A1,ABSVALUE:def 1
    .=intpos(n1+n2);
end;

theorem Th6:
  for s being State of SCMPDS,m1,m2 being Element of NAT st IC s=inspos (m1+m2)
  holds ICplusConst(s,-m2)=inspos m1
proof
  let s be State of SCMPDS,m1,m2 be Element of NAT;
  assume
A1: IC s=inspos (m1+m2);
  consider m being Element of NAT such that
A2: m = IC s & ICplusConst(s,-m2) = abs(m+(-m2)) by SCMPDS_2:def 20;
A3: m=il.(m1+m2) by A1,A2
    .=(m1+m2);
  m1 >= 0 by NAT_1:2;
  hence ICplusConst(s,-m2) =m1 by A2,A3,ABSVALUE:def 1
    .=il.m1
    .=inspos m1;
end;

:: GBP:Global Base Pointer

definition
  func GBP -> Int_position equals

  intpos 0;
  coherence;

:: SBP:Stack Base(bottom) Pointer
  func SBP -> Int_position equals

  intpos 1;
  coherence;
end;

theorem Th7:
  GBP <> SBP by AMI_3:52;

theorem Th8:
  card (I ';' i)= card I + 1
proof
  thus card (I ';' i) = card (I ';' Load i) by SCMPDS_4:def 5
    .=card I+ card (Load i) by SCMPDS_4:45
    .=card I+1 by SCMPDS_5:6;
end;

theorem Th9:
  card (i ';' j)= 2
proof
  thus card (i ';' j) = card (Load i ';' Load j) by SCMPDS_4:def 6
    .=card (Load i)+card (Load j) by SCMPDS_4:45
    .=1+card(Load j) by SCMPDS_5:6
    .=1+1 by SCMPDS_5:6
    .=2;
end;

theorem Th10:
  (I ';' i).inspos card I =i & inspos card I in dom (I ';' i)
proof
A1: inspos 0 in dom Load i by SCMPDS_5:2;
  thus (I ';' i).inspos (card I) =(I ';' i).inspos(0+card I)
    .=(I ';' i).(inspos 0 + card I)
    .=(I ';' Load i).(inspos 0 + card I) by SCMPDS_4:def 5
    .=(Load i).inspos 0 by A1,SCMPDS_4:38
    .=i by SCMPDS_5:4;
  card (I ';' i) = card I+1 by Th8;
  then card I < card (I ';' i) by XREAL_1:31;
  hence thesis by SCMPDS_4:1;
end;

theorem Th11:
  (I ';' i ';' J).inspos card I =i
proof
  inspos card I in dom (I ';' i) by Th10;
  hence (I ';' i ';' J ).inspos card I =(I ';' i).inspos card I by SCMPDS_4:37
    .=i by Th10;
end;

begin :: The Construction of Recursive Euclide Algorithm

:: Greatest Common Divisor
:: gcd(x,y)     < x=(SBP,2) y=(SBP,3) >
:: BEGIN
:: if y=0 then gcd:=x else
:: gcd:=gcd(y, x mod y)
:: END

definition
  func GCD-Algorithm -> Program-block equals

::Def04
  (((GBP:=0) ';' (SBP := 7) ';' saveIC(SBP,RetIC) ';'
  goto 2 ';' halt SCMPDS ) ';' (SBP,3)<=0_goto 9 ';'
  ((SBP,6):=(SBP,3)) ';' Divide(SBP,2,SBP,3) ';'
  ((SBP,7):=(SBP,3)) ';' ((SBP,4+RetSP):=(GBP,1))) ';'
  AddTo(GBP,1,4) ';' saveIC(SBP,RetIC) ';'
  (goto -7) ';' ((SBP,2):=(SBP,6)) ';' return SBP;
  coherence;
end;
set i00= GBP:=0, i01=SBP := 7, i02=saveIC(SBP,RetIC), i03=goto 2,
i04=halt SCMPDS, i05= (SBP,3)<=0_goto 9, i06= (SBP,6):=(SBP,3),
i07= Divide(SBP,2,SBP,3), i08= (SBP,7):=(SBP,3), i09= (SBP,4+RetSP):=(GBP,1),
i10=AddTo(GBP,1,4), i11=saveIC(SBP,RetIC), i12=goto -7, i13=(SBP,2):=(SBP,6),
i14=return SBP;

begin :: The Computation of Recursive Euclide Algorithm

theorem Th12:
  card GCD-Algorithm = 15
proof
  set GCD1=i00 ';' i01 ';' i02 ';' i03 ';' i04,
  GCD2=GCD1 ';' i05 ';' i06 ';' i07 ';' i08 ';' i09;
A1: card GCD1=card (i00 ';' i01 ';' i02 ';' i03)+ 1 by Th8
    .=card (i00 ';' i01 ';' i02)+1+1 by Th8
    .=card (i00 ';' i01)+1+1+1 by Th8
    .=2+1+1+1 by Th9
    .=5;
A2: card GCD2=card (GCD1 ';' i05 ';' i06 ';' i07 ';' i08 )+ 1 by Th8
    .=card (GCD1 ';' i05 ';' i06 ';' i07)+1+1 by Th8
    .=card (GCD1 ';' i05 ';' i06) +1+1+1 by Th8
    .=card (GCD1 ';' i05 )+1+1+1+1 by Th8
    .=5+1+1+1+1+1 by A1,Th8
    .=10;
  thus card GCD-Algorithm =card(GCD2 ';' i10 ';' i11 ';' i12 ';' i13)+1 by Th8
    .=card(GCD2 ';' i10 ';' i11 ';' i12)+1+1 by Th8
    .=card(GCD2 ';' i10 ';' i11)+1+1+1 by Th8
    .=card(GCD2 ';' i10)+1+1+1+1 by Th8
    .=10+1+1+1+1+1 by A2,Th8
    .=15;
end;

theorem
  n < 15 iff inspos n in dom GCD-Algorithm by Th12,SCMPDS_4:1;

theorem Th14:
  GCD-Algorithm.inspos 0=GBP:=0 & GCD-Algorithm.inspos 1=SBP:= 7 &
  GCD-Algorithm.inspos 2=saveIC(SBP,RetIC) & GCD-Algorithm.inspos 3=goto 2 &
  GCD-Algorithm.inspos 4=halt SCMPDS &
  GCD-Algorithm.inspos 5=(SBP,3)<=0_goto 9 &
  GCD-Algorithm.inspos 6=(SBP,6):=(SBP,3) &
  GCD-Algorithm.inspos 7=Divide(SBP,2,SBP,3) &
  GCD-Algorithm.inspos 8=(SBP,7):=(SBP,3) &
  GCD-Algorithm.inspos 9=(SBP,4+RetSP):=(GBP,1) &
  GCD-Algorithm.inspos 10=AddTo(GBP,1,4) &
  GCD-Algorithm.inspos 11=saveIC(SBP,RetIC) &
  GCD-Algorithm.inspos 12=goto -7 & GCD-Algorithm.inspos 13=(SBP,2):=(SBP,6) &
  GCD-Algorithm.inspos 14=return SBP
proof
  set I2=i00 ';' i01, I3=I2 ';' i02, I4=I3 ';' i03, I5=I4 ';' i04,
  I6=I5 ';' i05, I7=I6 ';' i06, I8=I7 ';' i07, I9=I8 ';' i08, I10=I9 ';' i09,
  I11=I10 ';' i10, I12=I11 ';' i11, I13=I12 ';' i12, I14=I13 ';' i13;
A1: card I2=2 by Th9;
  then
A2: card I3=2+1 by Th8;
  then
A3: card I4=3+1 by Th8;
  then
A4: card I5=4+1 by Th8;
  then
A5: card I6=5+1 by Th8;
  then
A6: card I7=6+1 by Th8;
  then
A7: card I8=7+1 by Th8;
  then
A8: card I9=8+1 by Th8;
  then
A9: card I10=9+1 by Th8;
  then
A10: card I11=10+1 by Th8;
  then
A11: card I12=11+1 by Th8;
  then
A12: card I13=12+1 by Th8;
  then
A13: card I14=13+1 by Th8;
  set J14=i13 ';' i14, J13=i12 ';' J14, J12=i11 ';' J13, J11=i10 ';' J12,
  J10=i09 ';' J11, J9=i08 ';' J10, J8=i07 ';' J9, J7=i06 ';' J8,
  J6=i05 ';' J7, J5=i04 ';' J6, J4=i03 ';' J5, J3=i02 ';' J4, J2=i01 ';' J3;
A14: GCD-Algorithm=I13 ';' J14 by SCMPDS_4:49;
  then
A15: GCD-Algorithm=I12 ';' J13 by SCMPDS_4:48;
  then
A16: GCD-Algorithm=I11 ';' J12 by SCMPDS_4:48;
  then
A17: GCD-Algorithm=I10 ';' J11 by SCMPDS_4:48;
  then
A18: GCD-Algorithm=I9 ';' J10 by SCMPDS_4:48;
  then
A19: GCD-Algorithm=I8 ';' J9 by SCMPDS_4:48;
  then
A20: GCD-Algorithm=I7 ';' J8 by SCMPDS_4:48;
  then
A21: GCD-Algorithm=I6 ';' J7 by SCMPDS_4:48;
  then
A22: GCD-Algorithm=I5 ';' J6 by SCMPDS_4:48;
  then
A23: GCD-Algorithm=I4 ';' J5 by SCMPDS_4:48;
  then
A24: GCD-Algorithm=I3 ';' J4 by SCMPDS_4:48;
  then
A25: GCD-Algorithm=I2 ';' J3 by SCMPDS_4:48;
  then GCD-Algorithm=i00 ';' J2 by SCMPDS_4:52;
  hence GCD-Algorithm.inspos 0=i00 by SCMPDS_6:16;
A26: card Load i00=1 by SCMPDS_5:6;
  GCD-Algorithm=Load i00 ';' i01 ';' J3 by A25,SCMPDS_4:43;
  hence GCD-Algorithm.inspos 1=i01 by A26,Th11;
  thus GCD-Algorithm.inspos 2=i02 by A1,A24,Th11;
  thus GCD-Algorithm.inspos 3=i03 by A2,A23,Th11;
  thus GCD-Algorithm.inspos 4=i04 by A3,A22,Th11;
  thus GCD-Algorithm.inspos 5=i05 by A4,A21,Th11;
  thus GCD-Algorithm.inspos 6=i06 by A5,A20,Th11;
  thus GCD-Algorithm.inspos 7=i07 by A6,A19,Th11;
  thus GCD-Algorithm.inspos 8=i08 by A7,A18,Th11;
  thus GCD-Algorithm.inspos 9=i09 by A8,A17,Th11;
  thus GCD-Algorithm.inspos 10=i10 by A9,A16,Th11;
  thus GCD-Algorithm.inspos 11=i11 by A10,A15,Th11;
  thus GCD-Algorithm.inspos 12=i12 by A11,A14,Th11;
  GCD-Algorithm=I14 ';' Load i14 by SCMPDS_4:def 5;
  hence GCD-Algorithm.inspos 13=i13 by A12,Th11;
  thus GCD-Algorithm.inspos 14=i14 by A13,Th10;
end;

Lm1: GCD-Algorithm c= s implies s.inspos 0=i00 & s.inspos 1=i01 &
s.inspos 2=i02 & s.inspos 3=i03 & s.inspos 4=i04 & s.inspos 5=i05 &
s.inspos 6=i06 & s.inspos 7=i07 & s.inspos 8=i08 & s.inspos 9=i09 &
s.inspos 10=i10 & s.inspos 11=i11 & s.inspos 12=i12 & s.inspos 13=i13 &
s.inspos 14=i14
proof
  set GA=GCD-Algorithm;
  assume
A1: GA c= s;
  inspos 0 in dom GA by Th12,SCMPDS_4:1;
  hence s.inspos 0=i00 by A1,Th14,GRFUNC_1:8;
  inspos 1 in dom GA by Th12,SCMPDS_4:1;
  hence s.inspos 1=i01 by A1,Th14,GRFUNC_1:8;
  inspos 2 in dom GA by Th12,SCMPDS_4:1;
  hence s.inspos 2=i02 by A1,Th14,GRFUNC_1:8;
  inspos 3 in dom GA by Th12,SCMPDS_4:1;
  hence s.inspos 3=i03 by A1,Th14,GRFUNC_1:8;
  inspos 4 in dom GA by Th12,SCMPDS_4:1;
  hence s.inspos 4=i04 by A1,Th14,GRFUNC_1:8;
  inspos 5 in dom GA by Th12,SCMPDS_4:1;
  hence s.inspos 5=i05 by A1,Th14,GRFUNC_1:8;
  inspos 6 in dom GA by Th12,SCMPDS_4:1;
  hence s.inspos 6=i06 by A1,Th14,GRFUNC_1:8;
  inspos 7 in dom GA by Th12,SCMPDS_4:1;
  hence s.inspos 7=i07 by A1,Th14,GRFUNC_1:8;
  inspos 8 in dom GA by Th12,SCMPDS_4:1;
  hence s.inspos 8=i08 by A1,Th14,GRFUNC_1:8;
  inspos 9 in dom GA by Th12,SCMPDS_4:1;
  hence s.inspos 9=i09 by A1,Th14,GRFUNC_1:8;
  inspos 10 in dom GA by Th12,SCMPDS_4:1;
  hence s.inspos 10=i10 by A1,Th14,GRFUNC_1:8;
  inspos 11 in dom GA by Th12,SCMPDS_4:1;
  hence s.inspos 11=i11 by A1,Th14,GRFUNC_1:8;
  inspos 12 in dom GA by Th12,SCMPDS_4:1;
  hence s.inspos 12=i12 by A1,Th14,GRFUNC_1:8;
  inspos 13 in dom GA by Th12,SCMPDS_4:1;
  hence s.inspos 13=i13 by A1,Th14,GRFUNC_1:8;
  inspos 14 in dom GA by Th12,SCMPDS_4:1;
  hence s.inspos 14=i14 by A1,Th14,GRFUNC_1:8;
end;

theorem Th15:
  for s being State of SCMPDS st Initialized GCD-Algorithm c= s
  holds IC Computation(s,4) = inspos 5 & Computation(s,4).GBP = 0 &
  Computation(s,4).SBP = 7 & Computation(s,4).intpos(7+RetIC) = inspos 2 &
  Computation(s,4).intpos 9 = s.intpos 9 &
  Computation(s,4).intpos 10 = s.intpos 10
proof
  let s be State of SCMPDS;
  set GA=GCD-Algorithm;
:::  , Cs=Computation s;
  assume
A1: Initialized GA c= s;
  then
A2: GA c= s by SCMPDS_4:57;
A3: IC s=inspos 0 by A1,SCMPDS_5:18;
A4: Computation(s,0+1) = Following Computation(s,0) by AMI_1:14
    .= Following s by AMI_1:13
    .= Exec(i00,s) by A2,A3,Lm1;
  then
A5: IC Computation(s,1)= Next IC s by SCMPDS_2:57
    .= inspos (0+1) by A3;
  then
A6: CurInstr Computation(s,1)=s.inspos 1 by AMI_1:54
    .=i01 by A2,Lm1;
A7: Computation(s,1+1) = Following Computation(s,1) by AMI_1:14
    .= Exec(i01,Computation(s,1)) by A6;
A8: Computation(s,1).GBP=0 by A4,SCMPDS_2:57;
  intpos 9 <> GBP by AMI_3:52;
  then
A9: Computation(s,1).intpos 9=s.intpos 9 by A4,SCMPDS_2:57;
  intpos 10 <> GBP by AMI_3:52;
  then
A10: Computation(s,1).intpos 10 =s.intpos 10 by A4,SCMPDS_2:57;
A11: IC Computation(s,2)= Next IC Computation(s,1) by A7,SCMPDS_2:57
    .= inspos (1+1) by A5;
  then
A12: CurInstr Computation(s,2)=s.inspos 2 by AMI_1:54
    .=i02 by A2,Lm1;
A13: Computation(s,2+1) = Following Computation(s,2) by AMI_1:14
    .= Exec(i02,Computation(s,2)) by A12;
A14: Computation(s,2).GBP=0 by A7,A8,Th7,SCMPDS_2:57;
A15: Computation(s,2).SBP=7 by A7,SCMPDS_2:57;
  intpos 9 <> SBP by AMI_3:52;
  then
A16: Computation(s,2).intpos 9=s.intpos 9 by A7,A9,SCMPDS_2:57;
  intpos 10 <> SBP by AMI_3:52;
  then
A17: Computation(s,2).intpos 10 =s.intpos 10 by A7,A10,SCMPDS_2:57;
A18: IC Computation(s,3)= Next IC Computation(s,2) by A13,SCMPDS_2:71
    .= inspos (2+1) by A11;
  then
A19: CurInstr Computation(s,3)=s.inspos 3 by AMI_1:54
    .=i03 by A2,Lm1;
A20: Computation(s,3+1) = Following Computation(s,3) by AMI_1:14
    .= Exec(i03,Computation(s,3)) by A19;
A21: DataLoc(Computation(s,2).SBP,RetIC)=intpos(7+1)
 by A15,Th5,SCMPDS_1:def 23;
  intpos 0 <> intpos 8 by AMI_3:52;
  then
A22: Computation(s,3).GBP=0 by A13,A14,A21,SCMPDS_2:71;
  intpos 1 <> intpos 8 by AMI_3:52;
  then
A23: Computation(s,3).SBP=7 by A13,A15,A21,SCMPDS_2:71;
A24: Computation(s,3).intpos 8=inspos 2 by A11,A13,A21,SCMPDS_2:71;
  intpos 9 <> DataLoc(Computation(s,2).SBP,RetIC) by A21,AMI_3:52;
  then
A25: Computation(s,3).intpos 9=s.intpos 9 by A13,A16,SCMPDS_2:71;
  intpos 10 <> DataLoc(Computation(s,2).SBP,RetIC) by A21,AMI_3:52;
  then
A26: Computation(s,3).intpos 10 =s.intpos 10 by A13,A17,SCMPDS_2:71; thus
  IC Computation(s,4)= ICplusConst(Computation(s,3),2) by A20,SCMPDS_2:66
    .= inspos (3+2) by A18,SCMPDS_6:23
    .= inspos 5;
  thus Computation(s,4).GBP=0 by A20,A22,SCMPDS_2:66;
  thus Computation(s,4).SBP = 7 by A20,A23,SCMPDS_2:66;
  thus Computation(s,4).intpos(7+RetIC) = inspos 2
   by A20,A24,SCMPDS_1:def 23,SCMPDS_2:66;
  thus Computation(s,4).intpos 9=s.intpos 9 by A20,A25,SCMPDS_2:66;
  thus Computation(s,4).intpos 10=s.intpos 10 by A20,A26,SCMPDS_2:66;
end;

Lm2: n>0 implies GBP <> intpos(m+n)
proof
  assume
A1: n>0;
  n<=m+n by NAT_1:11;
  hence GBP <> intpos(m+n) by A1,AMI_3:52;
end;

Lm3: n>1 implies SBP <> intpos(m+n)
proof
  assume
A1: n>1;
  n<=m+n by NAT_1:11;
  hence SBP <> intpos(m+n) by A1,AMI_3:52;
end;

Lm4: GCD-Algorithm c= s & IC s = inspos 5 &
n=s.SBP & s.GBP=0 & s.DataLoc(s.SBP,3) > 0 implies
IC Computation(s,7) = inspos (5+7) &
Computation(s,8) = Exec(i12,Computation(s,7)) & Computation(s,7).SBP=n+4 &
Computation(s,7).GBP=0 & Computation(s,7).intpos(n+7)
= s.DataLoc(s.SBP,2) mod s.DataLoc(s.SBP,3) &
Computation(s,7).intpos(n+6) = s.DataLoc(s.SBP,3) &
Computation(s,7).intpos(n+4) = n & Computation(s,7).intpos(n+5) = inspos 11
proof
  set x=s.DataLoc(s.SBP,2), y=s.DataLoc(s.SBP,3);
:::  , Cs=Computation s;
  assume
A1: GCD-Algorithm c= s;
  assume
A2: IC s = inspos 5;
  assume
A3: n=s.SBP;
  assume
A4: s.GBP=0;
  assume
A5: y > 0;
A6: Computation(s,1+0) = Following Computation(s,0) by AMI_1:14
    .= Following s by AMI_1:13
    .= Exec(i05,s) by A1,A2,Lm1;
  then
A7: IC Computation(s,1)= Next IC s by A5,SCMPDS_2:68
    .= inspos (5+1) by A2;
  then
A8: CurInstr Computation(s,1) =s.inspos 6 by AMI_1:54
    .=i06 by A1,Lm1;
A9: Computation(s,1+1) = Following Computation(s,1) by AMI_1:14
    .= Exec(i06,Computation(s,1)) by A8;
A10: Computation(s,1).SBP=n by A3,A6,SCMPDS_2:68;
A11: Computation(s,1).GBP=0 by A4,A6,SCMPDS_2:68;
A12: Computation(s,1).intpos(n+3) = Computation(s,1).DataLoc(n,3) by Th5
    .=y by A3,A6,SCMPDS_2:68;
A13: Computation(s,1).intpos(n+2) = Computation(s,1).DataLoc(n,2) by Th5
    .=x by A3,A6,SCMPDS_2:68;
A14: IC Computation(s,2)= Next IC Computation(s,1) by A9,SCMPDS_2:59
    .= inspos (6+1) by A7;
  then
A15: CurInstr Computation(s,2) =s.inspos 7 by AMI_1:54
    .=i07 by A1,Lm1;
A16: Computation(s,2+1) = Following Computation(s,2) by AMI_1:14
    .= Exec(i07,Computation(s,2)) by A15;
A17: DataLoc(Computation(s,1).SBP,6)=intpos(n+6) by A10,Th5;
  then SBP <> DataLoc(Computation(s,1).SBP,6) by Lm3;
  then
A18: Computation(s,2).SBP=n by A9,A10,SCMPDS_2:59;
  GBP <> DataLoc(Computation(s,1).SBP,6) by A17,Lm2;
  then
A19: Computation(s,2).GBP=0 by A9,A11,SCMPDS_2:59;
A20: Computation(s,2).intpos(n+6)=Computation(s,1).DataLoc(n,3)
 by A9,A10,A17,SCMPDS_2:59
    .= y by A12,Th5;
  n+3<>n+6;
  then intpos(n+3) <> DataLoc(Computation(s,1).SBP,6) by A17,AMI_3:52;
  then
A21: Computation(s,2).intpos(n+3)=y by A9,A12,SCMPDS_2:59;
  n+2<>n+6;
  then intpos(n+2) <> DataLoc(Computation(s,1).SBP,6) by A17,AMI_3:52;
  then
A22: Computation(s,2).intpos(n+2)=x by A9,A13,SCMPDS_2:59;
A23: IC Computation(s,3)= Next IC Computation(s,2) by A16,SCMPDS_2:64
    .= inspos (7+1) by A14;
  then
A24: CurInstr Computation(s,3) =s.inspos 8 by AMI_1:54
    .=i08 by A1,Lm1;
A25: Computation(s,3+1) = Following Computation(s,3) by AMI_1:14
    .= Exec(i08,Computation(s,3)) by A24;
A26: DataLoc(Computation(s,2).SBP,2)=intpos(n+2) by A18,Th5;
  then
A27: SBP <> DataLoc(Computation(s,2).SBP,2) by Lm3;
A28: DataLoc(Computation(s,2).SBP,3)=intpos(n+3) by A18,Th5;
  then SBP <> DataLoc(Computation(s,2).SBP,3) by Lm3;
  then
A29: Computation(s,3).SBP=n by A16,A18,A27,SCMPDS_2:64;
A30: GBP <> DataLoc(Computation(s,2).SBP,2) by A26,Lm2;
  GBP <> DataLoc(Computation(s,2).SBP,3) by A28,Lm2;
  then
A31: Computation(s,3).GBP=0 by A16,A19,A30,SCMPDS_2:64;
A32: Computation(s,3).intpos(n+3) = x mod y by A16,A21,A22,A26,A28,SCMPDS_2:64;
  n+6<>n+2;
  then
A33: intpos(n+6) <> DataLoc(Computation(s,2).SBP,2) by A26,AMI_3:52;
  n+6<>n+3;
  then intpos(n+6) <> DataLoc(Computation(s,2).SBP,3) by A28,AMI_3:52;
  then
A34: Computation(s,3).intpos(n+6) =y by A16,A20,A33,SCMPDS_2:64;
A35: IC Computation(s,4)= Next IC Computation(s,3) by A25,SCMPDS_2:59
    .= inspos (8+1) by A23;
  then
A36: CurInstr Computation(s,4) =s.inspos 9 by AMI_1:54
    .=i09 by A1,Lm1;
A37: Computation(s,4+1) = Following Computation(s,4) by AMI_1:14
    .= Exec(i09,Computation(s,4)) by A36;
A38: DataLoc(Computation(s,3).SBP,7)=intpos(n+7) by A29,Th5;
  then
A39: SBP <> DataLoc(Computation(s,3).SBP,7) by Lm3;
  then
A40: Computation(s,4).SBP=n by A25,A29,SCMPDS_2:59;
  GBP <> DataLoc(Computation(s,3).SBP,7) by A38,Lm2;
  then
A41: Computation(s,4).GBP=0 by A25,A31,SCMPDS_2:59;
A42: Computation(s,4).intpos(n+7)=Computation(s,3).DataLoc(n,3)
 by A25,A29,A38,SCMPDS_2:59
    .= x mod y by A32,Th5;
  n+6<>n+7;
  then intpos(n+6) <> DataLoc(Computation(s,3).SBP,7) by A38,AMI_3:52;
  then
A43: Computation(s,4).intpos(n+6) =y by A25,A34,SCMPDS_2:59;
A44: IC Computation(s,5)= Next IC Computation(s,4) by A37,SCMPDS_2:59
    .= inspos (9+1) by A35;
  then
A45: CurInstr Computation(s,5) =s.inspos 10 by AMI_1:54
    .=i10 by A1,Lm1;
A46: Computation(s,5+1) = Following Computation(s,5) by AMI_1:14
    .= Exec(i10,Computation(s,5)) by A45;
A47: DataLoc(Computation(s,4).SBP,4+RetSP)=intpos(n+(4+0))
 by A40,Th5,SCMPDS_1:def 22;
  then SBP <> DataLoc(Computation(s,4).SBP,4+RetSP) by Lm3;
  then
A48: Computation(s,5).SBP=n by A37,A40,SCMPDS_2:59;
  GBP <> DataLoc(Computation(s,4).SBP,4+RetSP) by A47,Lm2;
  then
A49: Computation(s,5).GBP=0 by A37,A41,SCMPDS_2:59;
  n+7<>n+4;
  then intpos(n+7) <> DataLoc(Computation(s,4).SBP,4+RetSP) by A47,AMI_3:52;
  then
A50: Computation(s,5).intpos(n+7) =x mod y by A37,A42,SCMPDS_2:59;
  n+6<>n+4;
  then intpos(n+6) <> DataLoc(Computation(s,4).SBP,4+RetSP) by A47,AMI_3:52;
  then
A51: Computation(s,5).intpos(n+6) =y by A37,A43,SCMPDS_2:59;
A52: Computation(s,5).intpos(n+4) =Computation(s,4).DataLoc(0,1)
 by A37,A41,A47,SCMPDS_2:59
    .=Computation(s,4).intpos(0+1) by Th5
    .=n by A25,A29,A39,SCMPDS_2:59;
A53: IC Computation(s,6)= Next IC Computation(s,5) by A46,SCMPDS_2:60
    .= inspos (10+1) by A44;
  then
A54: CurInstr Computation(s,6) =s.inspos 11 by AMI_1:54
    .=i11 by A1,Lm1;
A55: Computation(s,6+1) = Following Computation(s,6) by AMI_1:14
    .= Exec(i11,Computation(s,6)) by A54;
A56: DataLoc(Computation(s,5).GBP,1)=intpos(0+1) by A49,Th5;
  then
A57: Computation(s,6).SBP=n+4 by A46,A48,SCMPDS_2:60;
A58: Computation(s,6).GBP=0 by A46,A49,A56,Th7,SCMPDS_2:60;
  n+7 <> 1 by NAT_1:11;
  then intpos(n+7) <> DataLoc(Computation(s,5).GBP,1) by A56,AMI_3:52;
  then
A59: Computation(s,6).intpos(n+7) =x mod y by A46,A50,SCMPDS_2:60;
  n+6 <> 1 by NAT_1:11;
  then intpos(n+6) <> DataLoc(Computation(s,5).GBP,1) by A56,AMI_3:52;
  then
A60: Computation(s,6).intpos(n+6) =y by A46,A51,SCMPDS_2:60;
  n+4 <> 1 by NAT_1:11;
  then intpos(n+4) <> DataLoc(Computation(s,5).GBP,1) by A56,AMI_3:52;
  then
A61: Computation(s,6).intpos(n+4) =n by A46,A52,SCMPDS_2:60; thus
  IC Computation(s,7)= Next IC Computation(s,6) by A55,SCMPDS_2:71
    .= inspos (11+1) by A53
    .= inspos (5+7);
  then
A62: CurInstr Computation(s,7) =s.inspos 12 by AMI_1:54
    .=i12 by A1,Lm1;
  thus Computation(s,8)=Computation(s,7+1)
    .= Following Computation(s,7) by AMI_1:14
    .= Exec(i12,Computation(s,7)) by A62;
A63: DataLoc(Computation(s,6).SBP,RetIC)=intpos(n+4+1)
 by A57,Th5,SCMPDS_1:def 23
    .=intpos(n+(4+1));
  then SBP <> DataLoc(Computation(s,6).SBP,RetIC) by Lm3;
  hence Computation(s,7).SBP=n+4 by A55,A57,SCMPDS_2:71;
  GBP <> DataLoc(Computation(s,6).SBP,RetIC) by A63,Lm2;
  hence Computation(s,7).GBP=0 by A55,A58,SCMPDS_2:71;
  n+7<>n+5;
  then intpos(n+7) <> DataLoc(Computation(s,6).SBP,RetIC) by A63,AMI_3:52;
  hence Computation(s,7).intpos(n+7) =x mod y by A55,A59,SCMPDS_2:71;
  n+6<>n+5;
  then intpos(n+6) <> DataLoc(Computation(s,6).SBP,RetIC) by A63,AMI_3:52;
  hence Computation(s,7).intpos(n+6) =y by A55,A60,SCMPDS_2:71;
  n+4<>n+5;
  then intpos(n+4) <> DataLoc(Computation(s,6).SBP,RetIC) by A63,AMI_3:52;
  hence Computation(s,7).intpos(n+4)=n by A55,A61,SCMPDS_2:71;
  thus Computation(s,7).intpos(n+5)=inspos 11 by A53,A55,A63,SCMPDS_2:71;
end;

Lm5: GCD-Algorithm c= s & IC s = inspos 5 &
n=s.SBP & s.GBP=0 & s.DataLoc(s.SBP,3) > 0 & 1<m & m <=n+1 implies
Computation(s,7).intpos m = s.intpos m
proof
:::  set Cs=Computation s;
  assume
A1: GCD-Algorithm c= s;
  assume
A2: IC s = inspos 5;
  assume
A3: n=s.SBP;
  assume
A4: s.GBP=0;
  assume
A5: s.DataLoc(s.SBP,3) > 0;
  assume
A6: 1 < m;
  assume
A7: m <= n+1;
A8: Computation(s,1+0) = Following Computation(s,0) by AMI_1:14
    .= Following s by AMI_1:13
    .= Exec(i05,s) by A1,A2,Lm1;
  then
A9: IC Computation(s,1)= Next IC s by A5,SCMPDS_2:68
    .= inspos (5+1) by A2;
  then
A10: CurInstr Computation(s,1) =s.inspos 6 by AMI_1:54
    .=i06 by A1,Lm1;
A11: Computation(s,1+1) = Following Computation(s,1) by AMI_1:14
    .= Exec(i06,Computation(s,1)) by A10;
A12: Computation(s,1).SBP=n by A3,A8,SCMPDS_2:68;
A13: Computation(s,1).GBP=0 by A4,A8,SCMPDS_2:68;
A14: Computation(s,1).intpos m = s.intpos m by A8,SCMPDS_2:68;
A15: IC Computation(s,2)= Next IC Computation(s,1) by A11,SCMPDS_2:59
    .= inspos (6+1) by A9;
  then
A16: CurInstr Computation(s,2) =s.inspos 7 by AMI_1:54
    .=i07 by A1,Lm1;
A17: Computation(s,2+1) = Following Computation(s,2) by AMI_1:14
    .= Exec(i07,Computation(s,2)) by A16;
A18: DataLoc(Computation(s,1).SBP,6)=intpos(n+6) by A12,Th5;
  then SBP <> DataLoc(Computation(s,1).SBP,6) by Lm3;
  then
A19: Computation(s,2).SBP=n by A11,A12,SCMPDS_2:59;
  GBP <> DataLoc(Computation(s,1).SBP,6) by A18,Lm2;
  then
A20: Computation(s,2).GBP=0 by A11,A13,SCMPDS_2:59;
  n+1 < n+6 by XREAL_1:8;
  then intpos m <> DataLoc(Computation(s,1).SBP,6) by A7,A18,AMI_3:52;
  then
A21: Computation(s,2).intpos m= s.intpos m by A11,A14,SCMPDS_2:59;
A22: IC Computation(s,3)= Next IC Computation(s,2) by A17,SCMPDS_2:64
    .= inspos (7+1) by A15;
  then
A23: CurInstr Computation(s,3) =s.inspos 8 by AMI_1:54
    .=i08 by A1,Lm1;
A24: Computation(s,3+1) = Following Computation(s,3) by AMI_1:14
    .= Exec(i08,Computation(s,3)) by A23;
A25: DataLoc(Computation(s,2).SBP,2)=intpos(n+2) by A19,Th5;
  then
A26: SBP <> DataLoc(Computation(s,2).SBP,2) by Lm3;
A27: DataLoc(Computation(s,2).SBP,3)=intpos(n+3) by A19,Th5;
  then SBP <> DataLoc(Computation(s,2).SBP,3) by Lm3;
  then
A28: Computation(s,3).SBP=n by A17,A19,A26,SCMPDS_2:64;
A29: GBP <> DataLoc(Computation(s,2).SBP,2) by A25,Lm2;
  GBP <> DataLoc(Computation(s,2).SBP,3) by A27,Lm2;
  then
A30: Computation(s,3).GBP=0 by A17,A20,A29,SCMPDS_2:64;
  n+1 < n+2 by XREAL_1:8;
  then
A31: intpos m <> DataLoc(Computation(s,2).SBP,2) by A7,A25,AMI_3:52;
  n+1 < n+3 by XREAL_1:8;
  then intpos m <> DataLoc(Computation(s,2).SBP,3) by A7,A27,AMI_3:52;
  then
A32: Computation(s,3).intpos m =s.intpos m by A17,A21,A31,SCMPDS_2:64;
A33: IC Computation(s,4)= Next IC Computation(s,3) by A24,SCMPDS_2:59
    .= inspos (8+1) by A22;
  then
A34: CurInstr Computation(s,4) =s.inspos 9 by AMI_1:54
    .=i09 by A1,Lm1;
A35: Computation(s,4+1) = Following Computation(s,4) by AMI_1:14
    .= Exec(i09,Computation(s,4)) by A34;
A36: DataLoc(Computation(s,3).SBP,7)=intpos(n+7) by A28,Th5;
  then SBP <> DataLoc(Computation(s,3).SBP,7) by Lm3;
  then
A37: Computation(s,4).SBP=n by A24,A28,SCMPDS_2:59;
  GBP <> DataLoc(Computation(s,3).SBP,7) by A36,Lm2;
  then
A38: Computation(s,4).GBP=0 by A24,A30,SCMPDS_2:59;
  n+1 < n+7 by XREAL_1:8;
  then intpos m <> DataLoc(Computation(s,3).SBP,7) by A7,A36,AMI_3:52;
  then
A39: Computation(s,4).intpos m =s.intpos m by A24,A32,SCMPDS_2:59;
A40: IC Computation(s,5)= Next IC Computation(s,4) by A35,SCMPDS_2:59
    .= inspos (9+1) by A33;
  then
A41: CurInstr Computation(s,5) =s.inspos 10 by AMI_1:54
    .=i10 by A1,Lm1;
A42: Computation(s,5+1) = Following Computation(s,5) by AMI_1:14
    .= Exec(i10,Computation(s,5)) by A41;
A43: DataLoc(Computation(s,4).SBP,4+RetSP)=intpos(n+(4+0))
 by A37,Th5,SCMPDS_1:def 22;
  then SBP <> DataLoc(Computation(s,4).SBP,4+RetSP) by Lm3;
  then
A44: Computation(s,5).SBP=n by A35,A37,SCMPDS_2:59;
  GBP <> DataLoc(Computation(s,4).SBP,4+RetSP) by A43,Lm2;
  then
A45: Computation(s,5).GBP=0 by A35,A38,SCMPDS_2:59;
  n+1 < n+4 by XREAL_1:8;
  then intpos m <> DataLoc(Computation(s,4).SBP,4+RetSP) by A7,A43,AMI_3:52;
  then
A46: Computation(s,5).intpos m = s.intpos m by A35,A39,SCMPDS_2:59;
  IC Computation(s,6)= Next IC Computation(s,5) by A42,SCMPDS_2:60
    .= inspos (10+1) by A40;
  then
A47: CurInstr Computation(s,6) =s.inspos 11 by AMI_1:54
    .=i11 by A1,Lm1;
A48: Computation(s,6+1) = Following Computation(s,6) by AMI_1:14
    .= Exec(i11,Computation(s,6)) by A47;
A49: DataLoc(Computation(s,5).GBP,1)=intpos(0+1) by A45,Th5;
  then
A50: Computation(s,6).SBP=n+4 by A42,A44,SCMPDS_2:60;
  intpos m <> DataLoc(Computation(s,5).GBP,1) by A6,A49,AMI_3:52;
  then
A51: Computation(s,6).intpos m =s.intpos m by A42,A46,SCMPDS_2:60;
A52: DataLoc(Computation(s,6).SBP,RetIC)=intpos(n+4+1)
 by A50,Th5,SCMPDS_1:def 23
    .=intpos(n+(4+1));
  n+1 < n+5 by XREAL_1:8;
  then intpos m <> DataLoc(Computation(s,6).SBP,RetIC) by A7,A52,AMI_3:52;
  hence Computation(s,7).intpos m=s.intpos m by A48,A51,SCMPDS_2:71;
end;

theorem Th16:
  for s being State of SCMPDS st GCD-Algorithm c= s
  & IC s = inspos 5 & s.SBP >0 & s.GBP=0 &
  s.DataLoc(s.SBP,3) >= 0 & s.DataLoc(s.SBP,2) >= s.DataLoc(s.SBP,3) holds
  ex n st CurInstr Computation(s,n) = return SBP &
  s.SBP=Computation(s,n).SBP & Computation(s,n).DataLoc(s.SBP,2)
  =s.DataLoc(s.SBP,2) gcd s.DataLoc(s.SBP,3) &
  (for j be Element of NAT st 1<j & j <= s.SBP+1 holds
  s.intpos j=Computation(s,n).intpos j)
proof
  set GA=GCD-Algorithm;
  defpred P[Element of NAT] means for s being State of SCMPDS st GA c= s
  & IC s = inspos 5 & s.SBP >0 & s.GBP=0 & s.DataLoc(s.SBP,3) <= $1 &
  s.DataLoc(s.SBP,3) >= 0 & s.DataLoc(s.SBP,2) >= s.DataLoc(s.SBP,3)
  holds ex n st CurInstr Computation(s,n) = return SBP &
  s.SBP=Computation(s,n).SBP & Computation(s,n).DataLoc(s.SBP,2)
  =s.DataLoc(s.SBP,2) gcd s.DataLoc(s.SBP,3) &
  (for j be Element of NAT st 1<j & j <= s.SBP+1 holds
  s.intpos j=Computation(s,n).intpos j);
  now
    let s be State of SCMPDS;
    set x=s.DataLoc(s.SBP,2), y=s.DataLoc(s.SBP,3);
:::    , Cs=Computation s;
    assume
A1: GA c= s;
    assume
A2: IC s = inspos 5;
    assume s.SBP >0;
    assume s.GBP=0;
    assume
A3: y <= 0;
    assume
A4: y >= 0;
    assume
A5: x >= y;
A6: Computation(s,1+0) = Following Computation(s,0) by AMI_1:14
      .= Following s by AMI_1:13
      .= Exec(i05,s) by A1,A2,Lm1;
    then
A7: IC Computation(s,1)= ICplusConst(s,9) by A3,SCMPDS_2:68
      .= inspos (5+9) by A2,SCMPDS_6:23;
    take n=1;
    thus CurInstr Computation(s,n)=s.inspos 14 by A7,AMI_1:54
      .=i14 by A1,Lm1;
    thus Computation(s,n).SBP=s.SBP by A6,SCMPDS_2:68;
A8: y = 0 by A3,A4,XXREAL_0:1;
    then
A9: abs(y)= 0 by ABSVALUE:def 1;
    thus Computation(s,n).DataLoc(s.SBP,2)=x by A6,SCMPDS_2:68
      .=abs(x) by A5,A8,ABSVALUE:def 1
      .=abs(x) hcf abs(y) by A9,NEWTON:65
      .=x gcd y by INT_2:51;
    thus for j be Element of NAT st 1<j & j <= s.SBP+1 holds
    s.intpos j=Computation(s,n).intpos j by A6,SCMPDS_2:68;
  end;
  then
A10: P[0];
A11: now
    let k be Element of NAT;
    assume
A12: P[k];
    now
      let s be State of SCMPDS;
      set x=s.DataLoc(s.SBP,2), y=s.DataLoc(s.SBP,3), yy=y;
:::      , Cs=Computation s;
      assume
A13:  GA c= s;
      assume
A14:  IC s = inspos 5;
      assume
A15:  s.SBP >0;
      assume
A16:  s.GBP=0;
      assume
A17:  y <= k+1;
      assume
A18:  y >= 0;
      assume
A19:  x >= y;
      then
A20:  x >= 0 by A18,XXREAL_0:2;
      reconsider y as Element of NAT by A18,INT_1:16;
      per cases by A17,NAT_1:8;
      suppose y <= k;
        hence ex n st CurInstr Computation(s,n) = return SBP &
        s.SBP=Computation(s,n).SBP &
        Computation(s,n).DataLoc(s.SBP,2)= x gcd yy &
        (for j be Element of NAT st 1<j & j <= s.SBP+1 holds
        s.intpos j=Computation(s,n).intpos j) by A12,A13,A14,A15,A16,A18,A19;
      end;
      suppose
A21:    y = k+1;
        then
A22:    y>0 by NAT_1:5;
        reconsider pn=s.SBP as Element of NAT by A15,INT_1:16;
A23:    pn=s.SBP;
        then
A24:    IC Computation(s,7) = inspos (5+7) &
Computation(s,8) = Exec(i12,Computation(s,7)) & Computation(s,7).SBP= pn+4 &
        Computation(s,7).GBP=0 & Computation(s,7).intpos(pn+7) = x mod y &
        Computation(s,7).intpos(pn+6) = y &
        Computation(s,7).intpos(pn+4) = pn &
        Computation(s,7).intpos(pn+5) = inspos 11 by A13,A14,A16,A22,Lm4;
        set s8=Computation(s,8);
A25:    IC s8= ICplusConst(Computation(s,7),-7) by A24,SCMPDS_2:66
          .= inspos 5 by A24,Th6;
A26:    GA c= s8 by A13,AMI_1:81;
A27:    s8.SBP=pn+4 by A24,SCMPDS_2:66;
A28:    4<=pn+4 by NAT_1:11;
        then
A29:    s8.SBP > 0 by A27,XXREAL_0:2;
A30:    s8.GBP=0 by A24,SCMPDS_2:66;
        set x1=s8.DataLoc(s8.SBP,2), y1=s8.DataLoc(s8.SBP,3);
A31:    x1=s8.intpos(pn+4+2) by A27,Th5
          .=y by A24,SCMPDS_2:66;
A32:    y1=s8.intpos(pn+4+3) by A27,Th5
          .=x mod y by A24,SCMPDS_2:66;
        then
A33:    y1<y by A21,NAT_1:5,NEWTON:79;
        then
A34:    y1 <= k by A21,INT_1:20;
        y1 >= 0 by A22,A32,NEWTON:78;
        then consider m such that
A35:    CurInstr Computation(s8,m) = return SBP &
        s8.SBP=Computation(s8,m).SBP &
        Computation(s8,m).DataLoc(s8.SBP,2)= x1 gcd y1 &
        (for j be Element of NAT st 1<j & j <= s8.SBP+1 holds
        s8.intpos j=Computation(s8,m).intpos j)
        by A12,A25,A26,A29,A30,A31,A33,A34;
        set s9=Computation(s,m+8);
A36:    s8.SBP=s9.SBP by A35,AMI_1:51;
A37:    Computation(s,m+(8+1))=Computation(s,m+8+1)
          .= Following s9 by AMI_1:14
          .= Exec(return SBP,s9) by A35,AMI_1:51;
A38:    1 < pn+4 by A28,XXREAL_0:2;
        pn+4 < s8.SBP+1 by A27,XREAL_1:31;
        then
A39:    s8.intpos(pn+4)=Computation(s8,m).intpos (pn+4) by A35, A38
          .=s9.intpos(pn+4) by AMI_1:51;
        5<=pn+5 by NAT_1:11;
        then
A40:    1 <pn+5 by XXREAL_0:2;
A41:    inspos 11=s8.intpos(pn+5) by A24,SCMPDS_2:66
          .=Computation(s8,m).intpos (pn+5) by A27,A35,A40
          .=s9.intpos(pn+4+1) by AMI_1:51
          .=s9.DataLoc(s9.SBP,RetIC) by A27,A36,Th5,SCMPDS_1:def 23;
A42:    IC Computation(s,m+9)= (abs(s9.DataLoc(s9.SBP,RetIC)))+2
 by A37,SCMPDS_2:70
          .= inspos (11+2) by A41,Th3;
        then
A43:    CurInstr Computation(s,m+9) =s.inspos 13 by AMI_1:54
          .=i13 by A13,Lm1;
A44:    Computation(s,m+(9+1))=Computation(s,m+9+1)
          .= Following Computation(s,m+9) by AMI_1:14
          .= Exec(i13,Computation(s,m+9)) by A43;
A45:    Computation(s,m+9).SBP=s9.DataLoc(pn+4,RetSP)
 by A27,A36,A37,SCMPDS_2:70
          .=s9.intpos(pn+4+0) by Th5,SCMPDS_1:def 22
          .=pn by A24,A39,SCMPDS_2:66;
        SBP <> intpos(pn+6) by Lm3;
        then
A46:    Computation(s,m+9).intpos(pn+6)=s9.intpos(pn+4+2) by A37,SCMPDS_2:70
          .=s9.DataLoc(s8.SBP,2) by A27,Th5
          .=x1 gcd y1 by A35,AMI_1:51;
        IC Computation(s,m+10)= Next IC Computation(s,m+9) by A44,SCMPDS_2:59
          .= inspos (13+1) by A42;
        then
A47:    CurInstr Computation(s,m+10)=s.inspos 14 by AMI_1:54
          .=i14 by A13,Lm1;
        hereby
          take n=m+10;
          thus CurInstr Computation(s,n) = return SBP by A47;
A48:      DataLoc(Computation(s,m+9).SBP,2)=intpos(pn+2) by A45,Th5;
          then SBP <> DataLoc(Computation(s,m+9).SBP,2) by Lm3;
          hence Computation(s,n).SBP=s.SBP by A44,A45,SCMPDS_2:59;
          thus Computation(s,n).DataLoc(s.SBP,2)
          =Computation(s,m+9).DataLoc(pn,6) by A44,A45,
          SCMPDS_2:59
            .=yy gcd (x mod yy) by A31,A32,A46,Th5
            .=x gcd yy by A20,A21,NAT_1:5,NAT_D:30;
          hereby
            let j be Element of NAT;
            assume
A49:        1<j & j <= s.SBP+1;
            s.SBP <= s8.SBP by A27,NAT_1:11;
            then s.SBP +1 <= s8.SBP+1 by XREAL_1:8;
            then
A50:        j <= s8.SBP+1 by A49,XXREAL_0:2;
            intpos j <> SBP by A49,AMI_3:52;
            then
A51:        Computation(s,m+9).intpos j=s9.intpos j by A37,SCMPDS_2:70
              .=Computation(s8,m).intpos j by AMI_1:51
              .=s8.intpos j by A35,A49,A50;
            pn+1<pn+2 by XREAL_1:8;
            then
A52:        intpos j <> DataLoc(Computation(s,m+9).SBP,2) by A48,A49, AMI_3:52;
            Computation(s,7).intpos j = s.intpos j
             by A13,A14,A16,A21,A23,A49,Lm5,
            NAT_1:5;
            hence s.intpos j=s8.intpos j by A24,SCMPDS_2:66
              .=Computation(s,n).intpos j by A44,A51,A52,SCMPDS_2:59;
          end;
        end;
      end;
    end;
    hence P[k+1];
  end;
A53: for n holds P[n] from NAT_1:sch 1(A10,A11);
  let s be State of SCMPDS;
  assume
A54: GA c= s & IC s = inspos 5 &
  s.SBP >0 & s.GBP=0 & s.DataLoc(s.SBP,3) >= 0 &
  s.DataLoc(s.SBP,2) >= s.DataLoc(s.SBP,3);
  then reconsider m=s.DataLoc(s.SBP,3) as Element of NAT by INT_1:16;
  P[m] by A53;
  hence thesis by A54;
end;

theorem Th17:
  for s being State of SCMPDS st GCD-Algorithm c= s
  & IC s = inspos 5 & s.SBP >0 & s.GBP=0 &
  s.DataLoc(s.SBP,3) >= 0 & s.DataLoc(s.SBP,2) >= 0 holds
  ex n st CurInstr Computation(s,n) = return SBP &
  s.SBP=Computation(s,n).SBP & Computation(s,n).DataLoc(s.SBP,2)
  =s.DataLoc(s.SBP,2) gcd s.DataLoc(s.SBP,3) &
  (for j be Element of NAT st 1<j & j <= s.SBP+1 holds
  s.intpos j=Computation(s,n).intpos j)
proof
  let s be State of SCMPDS;
  set GA=GCD-Algorithm, x=s.DataLoc(s.SBP,2), y=s.DataLoc(s.SBP,3), yy=y;
:::  Cs=(Computation s);
  assume
A1: GA c= s & IC s = inspos 5 & s.SBP>0 & s.GBP=0 & y >= 0 & x >= 0;
  per cases;
  suppose x >= y;
    hence thesis by A1,Th16;
  end;
  suppose x < y;
    then
A2: y>0 by A1,XXREAL_0:2;
    reconsider y as Element of NAT by A1,INT_1:16;
    reconsider pn=s.SBP as Element of NAT by A1,INT_1:16;
A3: pn=s.SBP;
    then
A4: IC Computation(s,7) = inspos (5+7) & Computation(s,8) =
 Exec(i12,Computation(s,7)) & Computation(s,7).SBP=pn+4 &
    Computation(s,7).GBP=0 & Computation(s,7).intpos(pn+7) = x mod y &
     Computation(s,7).intpos(pn+6) = y &
    Computation(s,7).intpos(pn+4) = pn &
    Computation(s,7).intpos(pn+5) = inspos 11 by A1,A2,Lm4;
    set s8=Computation(s,8);
A5: IC s8= ICplusConst(Computation(s,7),-7) by A4,SCMPDS_2:66
      .= inspos 5 by A4,Th6;
A6: GA c= s8 by A1,AMI_1:81;
A7: s8.SBP=pn+4 by A4,SCMPDS_2:66;
A8: 4<=pn+4 by NAT_1:11;
    then
A9: s8.SBP > 0 by A7,XXREAL_0:2;
A10: s8.GBP=0 by A4,SCMPDS_2:66;
    set x1=s8.DataLoc(s8.SBP,2), y1=s8.DataLoc(s8.SBP,3);
A11: x1=s8.intpos(pn+4+2) by A7,Th5
      .=y by A4,SCMPDS_2:66;
A12: y1=s8.intpos(pn+4+3) by A7,Th5
      .=x mod y by A4,SCMPDS_2:66;
    then
A13: y1<y by A2,NEWTON:79;
    y1 >= 0 by A1,A12,NEWTON:78;
    then consider m such that
A14: CurInstr Computation(s8,m) = return SBP &
    s8.SBP=Computation(s8,m).SBP &
    Computation(s8,m).DataLoc(s8.SBP,2)= x1 gcd y1 &
    (for j be Element of NAT st 1<j & j <= s8.SBP+1 holds
    s8.intpos j=Computation(s8,m).intpos j) by A5,A6,A9,A10,A11,A13,Th16;
    set s9=Computation(s,m+8);
A15: s8.SBP=s9.SBP by A14,AMI_1:51;
A16: Computation(s,m+(8+1))=Computation(s,m+8+1)
      .= Following s9 by AMI_1:14
      .= Exec(return SBP,s9) by A14,AMI_1:51;
A17: 1 < pn+4 by A8,XXREAL_0:2;
    pn+4 < s8.SBP+1 by A7,XREAL_1:31;
    then
A18: s8.intpos(pn+4)=Computation(s8,m).intpos (pn+4) by A14,A17
      .=s9.intpos(pn+4) by AMI_1:51;
    5<=pn+5 by NAT_1:11;
    then
A19: 1 <pn+5 by XXREAL_0:2;
A20: inspos 11=s8.intpos(pn+5) by A4,SCMPDS_2:66
      .=Computation(s8,m).intpos (pn+5) by A7,A14,A19
      .=s9.intpos(pn+4+1) by AMI_1:51
      .=s9.DataLoc(s9.SBP,RetIC) by A7,A15,Th5,SCMPDS_1:def 23;
A21: IC Computation(s,m+9)= (abs(s9.DataLoc(s9.SBP,RetIC)))+2
 by A16,SCMPDS_2:70
      .= inspos (11+2) by A20,Th3;
    then
A22: CurInstr Computation(s,m+9) =s.inspos 13 by AMI_1:54
      .=i13 by A1,Lm1;
A23: Computation(s,m+(9+1))=Computation(s,m+9+1)
      .= Following Computation(s,m+9) by AMI_1:14
      .= Exec(i13,Computation(s,m+9)) by A22;
A24: Computation(s,m+9).SBP=s9.DataLoc(pn+4,RetSP) by A7,A15,A16,SCMPDS_2:70
      .=s9.intpos(pn+4+0) by Th5,SCMPDS_1:def 22
      .=pn by A4,A18,SCMPDS_2:66;
    SBP <> intpos(pn+6) by Lm3;
    then
A25: Computation(s,m+9).intpos(pn+6)=s9.intpos(pn+4+2) by A16,SCMPDS_2:70
      .=s9.DataLoc(s8.SBP,2) by A7,Th5
      .=x1 gcd y1 by A14,AMI_1:51;
    IC Computation(s,m+10)= Next IC Computation(s,m+9) by A23,SCMPDS_2:59
      .= inspos (13+1) by A21;
    then
A26: CurInstr Computation(s,m+10)=s.inspos 14 by AMI_1:54
      .=i14 by A1,Lm1;
    hereby
      take n=m+10;
      thus CurInstr Computation(s,n) = return SBP by A26;
A27:  DataLoc(Computation(s,m+9).SBP,2)=intpos(pn+2) by A24,Th5;
      then SBP <> DataLoc(Computation(s,m+9).SBP,2) by Lm3;
      hence Computation(s,n).SBP=s.SBP by A23,A24,SCMPDS_2:59;
      thus Computation(s,n).DataLoc(s.SBP,2)=Computation(s,m+9).DataLoc(pn,6)
       by A23,A24,
      SCMPDS_2:59
        .=yy gcd (x mod yy) by A11,A12,A25,Th5
        .=x gcd yy by A1,A2,NAT_D:30;
      hereby
        let j be Element of NAT;
        assume
A28:    1<j & j <= s.SBP+1;
        s.SBP <= s8.SBP by A7,NAT_1:11;
        then s.SBP +1 <= s8.SBP+1 by XREAL_1:8;
        then
A29:    j <= s8.SBP+1 by A28,XXREAL_0:2;
        intpos j <> SBP by A28,AMI_3:52;
        then
A30:    Computation(s,m+9).intpos j=s9.intpos j by A16,SCMPDS_2:70
          .=Computation(s8,m).intpos j by AMI_1:51
          .=s8.intpos j by A14,A28,A29;
        pn+1<pn+2 by XREAL_1:8;
        then
A31:    intpos j <> DataLoc(Computation(s,m+9).SBP,2) by A27,A28,AMI_3:52;
        Computation(s,7).intpos j = s.intpos j by A1,A2,A3,A28,Lm5;
        hence s.intpos j=s8.intpos j by A4,SCMPDS_2:66
          .=Computation(s,n).intpos j by A23,A30,A31,SCMPDS_2:59;
      end;
    end;
  end;
end;

begin :: The Correctness of Recursive Euclide Algorithm

theorem
  for s being State of SCMPDS st Initialized GCD-Algorithm c= s
  for x, y being Integer st s.intpos 9 = x & s.intpos 10 = y
  & x >= 0 & y >= 0 holds (Result s).intpos 9 = x gcd y
proof
  let s be State of SCMPDS;
  set GA=GCD-Algorithm;
  assume
A1: Initialized GA c= s;
  let x, y be Integer;
  assume
A2: s.intpos 9 = x & s.intpos 10 = y & x >= 0 & y >= 0;
  set s4=Computation(s,4);
A3: GA c= s by A1,SCMPDS_4:57;
A4: GA c= s4 by A1,AMI_1:81,SCMPDS_4:57;
A5: IC s4 = inspos 5 & s4.GBP = 0 &
  s4.SBP = 7 & s4.intpos(7+RetIC) = inspos 2 &
  s4.intpos 9 = s.intpos 9 & s4.intpos 10 = s.intpos 10 by A1,Th15;
  then
A6: s4.DataLoc(s4.SBP,3)=s4.intpos (7+3) by Th5
    .=y by A1,A2,Th15;
A7: DataLoc(s4.SBP,2)=intpos(7+2) by A5,Th5;
  then
A8: s4.DataLoc(s4.SBP,2)=x by A1,A2,Th15;
:::  set Cs4=Computation s4;
  consider n such that
A9: CurInstr Computation(s4,n) = return SBP & s4.SBP=Computation(s4,n).SBP &
  Computation(s4,n).DataLoc(s4.SBP,2)
   =s4.DataLoc(s4.SBP,2) gcd s4.DataLoc(s4.SBP,3) &
  (for j be Element of NAT st 1<j & j <= s4.SBP+1
  holds s4.intpos j=Computation(s4,n).intpos j) by A2,A4,A5,A6,A7,Th17;
A10: DataLoc(Computation(s4,n).SBP,RetIC)=intpos(7+1)
 by A5,A9,Th5,SCMPDS_1:def 23;
A11: Computation(s4,n+1)= Following Computation(s4,n) by AMI_1:14
    .= Exec(i14,Computation(s4,n)) by A9;
  IC Computation(s,4+(n+1)) =Computation(s4,n+1).IC SCMPDS by AMI_1:51
    .= (abs(Computation(s4,n).DataLoc(Computation(s4,n).SBP,RetIC)))+2
     by A11,SCMPDS_2:70
    .= inspos (2+2) by A5,A9,A10,Th3,SCMPDS_1:def 23;
  then
A12: s.IC Computation(s,4+(n+1)) =i04 by A3,Lm1;
A13: intpos 9 <> SBP by AMI_3:52;
  Result s=Computation(s,4+(n+1)) by A12,AMI_1:56
    .=Computation(s4,n+1) by AMI_1:51;
  hence (Result s).intpos 9=x gcd y by A6,A7,A8,A9,A11,A13,SCMPDS_2:70;
end;

::--------------------------

Lm6: GCD-Algorithm c= s1 & GCD-Algorithm c= s2 & IC s1 = inspos 5 &
n=s1.SBP & s1.GBP=0 & s1.DataLoc(s1.SBP,3) > 0 &
IC s2 = IC s1 & s2.SBP = s1.SBP & s2.GBP=0 &
s2.DataLoc(s1.SBP,2) = s1.DataLoc(s1.SBP,2) &
s2.DataLoc(s1.SBP,3) = s1.DataLoc(s1.SBP,3) implies
IC Computation(s1,7) = inspos (5+7) &
Computation(s1,8) = Exec(i12,Computation(s1,7)) &
Computation(s1,7).SBP=n+4 & Computation(s1,7).GBP=0 &
Computation(s1,7).intpos(n+7) = s1.intpos(n+2) mod s1.intpos(n+3) &
Computation(s1,7).intpos(n+6) = s1.intpos(n+3) &
IC Computation(s2,7) = inspos (5+7) &
Computation(s2,8) = Exec(i12,Computation(s2,7)) &
Computation(s2,7).SBP=n+4 & Computation(s2,7).GBP=0 &
Computation(s2,7).intpos(n+7) = s1.intpos(n+2) mod s1.intpos(n+3) &
Computation(s2,7).intpos(n+6) = s1.intpos(n+3) &
Computation(s1,7).intpos(n+4) = n &
Computation(s1,7).intpos(n+5) = inspos 11 &
Computation(s2,7).intpos(n+4) = n &
Computation(s2,7).intpos(n+5) = inspos 11
proof
  set GA=GCD-Algorithm;
:::  , Cs1=Computation s1;::, Cs2=Computation s2;
  assume
A1: GA c= s1 & GA c= s2;
  assume
A2: IC s1 = inspos 5;
  assume
A3: n=s1.SBP;
  assume
A4: s1.GBP=0;
  assume
A5: s1.DataLoc(s1.SBP,3) > 0;
  assume
A6: IC s2 = IC s1 & s2.SBP = s1.SBP & s2.GBP=0;
  assume
A7: s2.DataLoc(s1.SBP,2) = s1.DataLoc(s1.SBP,2) &
  s2.DataLoc(s1.SBP,3) = s1.DataLoc(s1.SBP,3);
A8: DataLoc(s1.SBP,2)=intpos(n+2) by A3,Th5;
A9: DataLoc(s1.SBP,3)=intpos(n+3) by A3,Th5;
  thus IC Computation(s1,7) = inspos (5+7) &
  Computation(s1,8) = Exec(i12,Computation(s1,7)) &
  Computation(s1,7).SBP=n+4 & Computation(s1,7).GBP=0 by A1,A2,A3,A4,A5,Lm4;
  thus Computation(s1,7).intpos(n+7)
  = s1.intpos(n+2) mod s1.intpos(n+3) by A1,A2,A3,A4,A5,A8,A9,Lm4;
  thus Computation(s1,7).intpos(n+6) =s1.intpos(n+3) by A1,A2,A3,A4,A5,A9,Lm4;
  thus IC Computation(s2,7) = inspos (5+7) &
  Computation(s2,8) = Exec(i12,Computation(s2,7)) &
  Computation(s2,7).SBP=n+4 & Computation(s2,7).GBP=0 by A1,A2,A3,A5,A6,A7,Lm4;
  thus Computation(s2,7).intpos(n+7)
  = s1.intpos(n+2) mod s1.intpos(n+3) by A1,A2,A3,A5,A6,A7,A8,A9,Lm4;
  thus Computation(s2,7).intpos(n+6) =s1.intpos(n+3)
   by A1,A2,A3,A5,A6,A7,A9,Lm4;
  thus Computation(s1,7).intpos(n+4) = n &
  Computation(s1,7).intpos(n+5) = inspos 11
  by A1,A2,A3,A4,A5,Lm4;
  thus Computation(s2,7).intpos(n+4) = n &
   Computation(s2,7).intpos(n+5) = inspos 11
  by A1,A2,A3,A5,A6,A7,Lm4;
end;

Lm7: GCD-Algorithm c= s1 & GCD-Algorithm c= s2 & IC s1 = inspos 5 &
n=s1.SBP & s1.GBP=0 & s1.DataLoc(s1.SBP,3) > 0 &
IC s2 = IC s1 & s2.SBP = s1.SBP & s2.GBP=0 &
s2.DataLoc(s1.SBP,2) = s1.DataLoc(s1.SBP,2) &
s2.DataLoc(s1.SBP,3) = s1.DataLoc(s1.SBP,3) implies
(for k be Element of NAT,a be Int_position st k <= 7 & s1.a=s2.a holds
IC Computation(s1,k) = IC Computation(s2,k) &
Computation(s1,k).a = Computation(s2,k).a)
proof
  set GA=GCD-Algorithm;
:::  , Cs1=Computation s1;:::, Cs2=Computation s2;
  assume
A1: GA c= s1 & GA c= s2;
  assume
A2: IC s1 = inspos 5;
  assume
A3: n=s1.SBP;
  assume
A4: s1.GBP=0;
  assume
A5: s1.DataLoc(s1.SBP,3) > 0;
  assume
A6: IC s2 = IC s1 & s2.SBP = s1.SBP & s2.GBP=0;
  assume
A7: s2.DataLoc(s1.SBP,2) = s1.DataLoc(s1.SBP,2) &
  s2.DataLoc(s1.SBP,3) = s1.DataLoc(s1.SBP,3);
A8: Computation(s1,1+0) = Following Computation(s1,0) by AMI_1:14
    .= Following s1 by AMI_1:13
    .= Exec(i05,s1) by A1,A2,Lm1;
A9: Computation(s2,1+0) = Following Computation(s2,0) by AMI_1:14
    .= Following s2 by AMI_1:13
    .= Exec(i05,s2) by A1,A2,A6,Lm1;
A10: IC Computation(s1,1)= Next IC s1 by A5,A8,SCMPDS_2:68
    .= inspos (5+1) by A2;
  then
A11: CurInstr Computation(s1,1) =s1.inspos 6 by AMI_1:54
    .=i06 by A1,Lm1;
A12: Computation(s1,1+1) = Following Computation(s1,1) by AMI_1:14
    .= Exec(i06,Computation(s1,1)) by A11;
A13: Computation(s1,1).SBP=n by A3,A8,SCMPDS_2:68;
A14: Computation(s1,1).GBP=0 by A4,A8,SCMPDS_2:68;
A15: IC Computation(s2,1)= Next IC s2 by A5,A6,A7,A9,SCMPDS_2:68
    .= inspos (5+1) by A2,A6;
  then
A16: CurInstr Computation(s2,1) =s2.inspos 6 by AMI_1:54
    .=i06 by A1,Lm1;
A17: Computation(s2,1+1) = Following Computation(s2,1) by AMI_1:14
    .= Exec(i06,Computation(s2,1)) by A16;
A18: IC Computation(s1,2)= Next IC Computation(s1,1) by A12,SCMPDS_2:59
    .= inspos (6+1) by A10;
  then
A19: CurInstr Computation(s1,2) =s1.inspos 7 by AMI_1:54
    .=i07 by A1,Lm1;
A20: Computation(s1,2+1) = Following Computation(s1,2) by AMI_1:14
    .= Exec(i07,Computation(s1,2)) by A19;
A21: DataLoc(Computation(s1,1).SBP,6)=intpos(n+6) by A13,Th5;
  then SBP <> DataLoc(Computation(s1,1).SBP,6) by Lm3;
  then
A22: Computation(s1,2).SBP=n by A12,A13,SCMPDS_2:59;
  GBP <> DataLoc(Computation(s1,1).SBP,6) by A21,Lm2;
  then
A23: Computation(s1,2).GBP=0 by A12,A14,SCMPDS_2:59;
A24: IC Computation(s2,2)= Next IC Computation(s2,1) by A17,SCMPDS_2:59
    .= inspos (6+1) by A15;
  then
A25: CurInstr Computation(s2,2) =s2.inspos 7 by AMI_1:54
    .=i07 by A1,Lm1;
A26: Computation(s2,2+1) = Following Computation(s2,2) by AMI_1:14
    .= Exec(i07,Computation(s2,2)) by A25;
A27: IC Computation(s1,3)= Next IC Computation(s1,2) by A20,SCMPDS_2:64
    .= inspos (7+1) by A18;
  then
A28: CurInstr Computation(s1,3) =s1.inspos 8 by AMI_1:54
    .=i08 by A1,Lm1;
A29: Computation(s1,3+1) = Following Computation(s1,3) by AMI_1:14
    .= Exec(i08,Computation(s1,3)) by A28;
A30: DataLoc(Computation(s1,2).SBP,2)=intpos(n+2) by A22,Th5;
  then
A31: SBP <> DataLoc(Computation(s1,2).SBP,2) by Lm3;
A32: DataLoc(Computation(s1,2).SBP,3)=intpos(n+3) by A22,Th5;
  then SBP <> DataLoc(Computation(s1,2).SBP,3) by Lm3;
  then
A33: Computation(s1,3).SBP=n by A20,A22,A31,SCMPDS_2:64;
A34: GBP <> DataLoc(Computation(s1,2).SBP,2) by A30,Lm2;
  GBP <> DataLoc(Computation(s1,2).SBP,3) by A32,Lm2;
  then
A35: Computation(s1,3).GBP=0 by A20,A23,A34,SCMPDS_2:64;
A36: IC Computation(s2,3)= Next IC Computation(s2,2) by A26,SCMPDS_2:64
    .= inspos (7+1) by A24;
  then
A37: CurInstr Computation(s2,3) =s2.inspos 8 by AMI_1:54
    .=i08 by A1,Lm1;
A38: Computation(s2,3+1) = Following Computation(s2,3) by AMI_1:14
    .= Exec(i08,Computation(s2,3)) by A37;
A39: IC Computation(s1,4)= Next IC Computation(s1,3) by A29,SCMPDS_2:59
    .= inspos (8+1) by A27;
  then
A40: CurInstr Computation(s1,4) =s1.inspos 9 by AMI_1:54
    .=i09 by A1,Lm1;
A41: Computation(s1,4+1) = Following Computation(s1,4) by AMI_1:14
    .= Exec(i09,Computation(s1,4)) by A40;
A42: DataLoc(Computation(s1,3).SBP,7)=intpos(n+7) by A33,Th5;
  then SBP <> DataLoc(Computation(s1,3).SBP,7) by Lm3;
  then
A43: Computation(s1,4).SBP=n by A29,A33,SCMPDS_2:59;
  GBP <> DataLoc(Computation(s1,3).SBP,7) by A42,Lm2;
  then
A44: Computation(s1,4).GBP=0 by A29,A35,SCMPDS_2:59;
A45: IC Computation(s2,4)= Next IC Computation(s2,3) by A38,SCMPDS_2:59
    .= inspos (8+1) by A36;
  then
A46: CurInstr Computation(s2,4) =s2.inspos 9 by AMI_1:54
    .=i09 by A1,Lm1;
A47: Computation(s2,4+1) = Following Computation(s2,4) by AMI_1:14
    .= Exec(i09,Computation(s2,4)) by A46;
A48: IC Computation(s1,5)= Next IC Computation(s1,4) by A41,SCMPDS_2:59
    .= inspos (9+1) by A39;
  then
A49: CurInstr Computation(s1,5) =s1.inspos 10 by AMI_1:54
    .=i10 by A1,Lm1;
A50: Computation(s1,5+1) = Following Computation(s1,5) by AMI_1:14
    .= Exec(i10,Computation(s1,5)) by A49;
  DataLoc(Computation(s1,4).SBP,4+RetSP)=intpos(n+(4+0))
  by A43,Th5,SCMPDS_1:def 22;
  then GBP <> DataLoc(Computation(s1,4).SBP,4+RetSP) by Lm2;
  then
A51: Computation(s1,5).GBP=0 by A41,A44,SCMPDS_2:59;
A52: IC Computation(s2,5)= Next IC Computation(s2,4) by A47,SCMPDS_2:59
    .= inspos (9+1) by A45;
  then
A53: CurInstr Computation(s2,5) =s2.inspos 10 by AMI_1:54
    .=i10 by A1,Lm1;
A54: Computation(s2,5+1) = Following Computation(s2,5) by AMI_1:14
    .= Exec(i10,Computation(s2,5)) by A53;
A55: IC Computation(s1,6)= Next IC Computation(s1,5) by A50,SCMPDS_2:60
    .= inspos (10+1) by A48;
  then
A56: CurInstr Computation(s1,6) =s1.inspos 11 by AMI_1:54
    .=i11 by A1,Lm1;
A57: Computation(s1,6+1) = Following Computation(s1,6) by AMI_1:14
    .= Exec(i11,Computation(s1,6)) by A56;
A58: IC Computation(s2,6)= Next IC Computation(s2,5) by A54,SCMPDS_2:60
    .= inspos (10+1) by A52;
  then
A59: CurInstr Computation(s2,6) =s2.inspos 11 by AMI_1:54
    .=i11 by A1,Lm1;
A60: Computation(s2,6+1) = Following Computation(s2,6) by AMI_1:14
    .= Exec(i11,Computation(s2,6)) by A59;
A61: now
    let b;
    assume s1.b=s2.b;
    hence Computation(s1,1).b=s2.b by A8,SCMPDS_2:68
      .=Computation(s2,1).b by A9,SCMPDS_2:68;
  end;
A62: s1.b=s2.b implies Computation(s1,2).b=Computation(s2,2).b
  proof
    assume
A63: s1.b=s2.b;
    per cases;
    suppose
A64:  b=DataLoc(Computation(s1,1).SBP,6);
      then
A65:  b=DataLoc(Computation(s2,1).SBP,6) by A6,A61;
      thus Computation(s1,2).b=Computation(s1,1).DataLoc(s1.SBP,3)
      by A3,A12,A13,A64,SCMPDS_2:59
        .=Computation(s2,1).DataLoc(Computation(s1,1).SBP,3) by A3,A7,A13,A61
        .=Computation(s2,1).DataLoc(Computation(s2,1).SBP,3) by A6,A61
        .=Computation(s2,2).b by A17,A65,SCMPDS_2:59;
    end;
    suppose
A66:  b<>DataLoc(Computation(s1,1).SBP,6);
      then
A67:  b<>DataLoc(Computation(s2,1).SBP,6) by A6,A61;
      thus Computation(s1,2).b=Computation(s1,1).b by A12,A66,SCMPDS_2:59
        .=Computation(s2,1).b by A61,A63
        .=Computation(s2,2).b by A17,A67,SCMPDS_2:59;
    end;
  end;
A68: now
    let b;
    assume
A69: s1.b=s2.b;
    set x1=DataLoc(Computation(s1,2).SBP,2),
    x2=DataLoc(Computation(s1,2).SBP,3),
    y1=DataLoc(Computation(s2,2).SBP,2), y2=DataLoc(Computation(s2,2).SBP,3);
A70: x1=y1 by A6,A62;
A71: x2=y2 by A6,A62;
    per cases;
    suppose
A72:  b<>x1 & b<>x2;
      hence Computation(s1,3).b=Computation(s1,2).b by A20,SCMPDS_2:64
        .=Computation(s2,2).b by A62,A69
        .=Computation(s2,3).b by A26,A70,A71,A72,SCMPDS_2:64;
    end;
    suppose
A73:  b=x1;
A74:  n+2<>n+3;
      then
A75:  x1<>x2 by A30,A32,AMI_3:52;
A76:  y1<>y2 by A30,A32,A70,A71,A74,AMI_3:52;
      thus Computation(s1,3).b=Computation(s1,2).x1 div Computation(s1,2).x2
      by A20,A73,A75,SCMPDS_2:64
        .=Computation(s2,2).x1 div Computation(s1,2).x2 by A3,A7,A22,A62
        .=Computation(s2,2).x1 div Computation(s2,2).x2 by A3,A7,A22,A62
        .=Computation(s2,3).b by A26,A70,A71,A73,A76,SCMPDS_2:64;
    end;
    suppose
A77:  b=x2;
      hence Computation(s1,3).b=Computation(s1,2).x1 mod Computation(s1,2).x2
      by A20,SCMPDS_2:64
        .=Computation(s2,2).x1 mod Computation(s1,2).x2 by A3,A7,A22,A62
        .=Computation(s2,2).x1 mod Computation(s2,2).x2 by A3,A7,A22,A62
        .=Computation(s2,3).b by A26,A70,A71,A77,SCMPDS_2:64;
    end;
  end;
A78: now
    let b;
    assume
A79: s1.b=s2.b;
    per cases;
    suppose
A80:  b=DataLoc(Computation(s1,3).SBP,7);
      then
A81:  b=DataLoc(Computation(s2,3).SBP,7) by A6,A68;
      thus Computation(s1,4).b=Computation(s1,3).
      DataLoc(Computation(s1,3).SBP,3) by A29,A80,SCMPDS_2:59
        .=Computation(s2,3).DataLoc(Computation(s1,3).SBP,3) by A3,A7,A33,A68
        .=Computation(s2,3).DataLoc(Computation(s2,3).SBP,3) by A6,A68
        .=Computation(s2,4).b by A38,A81,SCMPDS_2:59;
    end;
    suppose
A82:  b<>DataLoc(Computation(s1,3).SBP,7);
      then
A83:  b<>DataLoc(Computation(s2,3).SBP,7) by A6,A68;
      thus Computation(s1,4).b=Computation(s1,3).b by A29,A82,SCMPDS_2:59
        .=Computation(s2,3).b by A68,A79
        .=Computation(s2,4).b by A38,A83,SCMPDS_2:59;
    end;
  end;
A84: now
    let b;
    assume
A85: s1.b=s2.b;
A86: s1.DataLoc(Computation(s1,4).GBP,1)=s2.intpos(0+1) by A6,A44,Th5
      .=s2.DataLoc(Computation(s1,4).GBP,1) by A44,Th5;
    per cases;
    suppose
A87:  b=DataLoc(Computation(s1,4).SBP,4+RetSP);
      then
A88:  b=DataLoc(Computation(s2,4).SBP,4+RetSP) by A6,A78;
      thus Computation(s1,5).b=Computation(s1,4).
      DataLoc(Computation(s1,4).GBP,1) by A41,A87,SCMPDS_2:59
        .=Computation(s2,4).DataLoc(Computation(s1,4).GBP,1) by A78,A86
        .=Computation(s2,4).DataLoc(Computation(s2,4).GBP,1) by A4,A6,A78
        .=Computation(s2,5).b by A47,A88,SCMPDS_2:59;
    end;
    suppose
A89:  b<>DataLoc(Computation(s1,4).SBP,4+RetSP);
      then
A90:  b<>DataLoc(Computation(s2,4).SBP,4+RetSP) by A6,A78;
      thus Computation(s1,5).b=Computation(s1,4).b by A41,A89,SCMPDS_2:59
        .=Computation(s2,4).b by A78,A85
        .=Computation(s2,5).b by A47,A90,SCMPDS_2:59;
    end;
  end;
A91: now
    let b;
    assume
A92: s1.b=s2.b;
A93: s1.DataLoc(Computation(s1,5).GBP,1)=s2.intpos(0+1) by A6,A51,Th5
      .=s2.DataLoc(Computation(s1,5).GBP,1) by A51,Th5;
    per cases;
    suppose
A94:  b=DataLoc(Computation(s1,5).GBP,1);
      then
A95:  b=DataLoc(Computation(s2,5).GBP,1) by A4,A6,A84;
      thus Computation(s1,6).b=Computation(s1,5).
      DataLoc(Computation(s1,5).GBP,1)+4 by A50,A94,SCMPDS_2:60
        .=Computation(s2,5).DataLoc(Computation(s1,5).GBP,1)+4 by A84,A93
        .=Computation(s2,5).DataLoc(Computation(s2,5).GBP,1)+4 by A4,A6,A84
        .=Computation(s2,6).b by A54,A95,SCMPDS_2:60;
    end;
    suppose
A96:  b<>DataLoc(Computation(s1,5).GBP,1);
      then
A97:  b<>DataLoc(Computation(s2,5).GBP,1) by A4,A6,A84;
      thus Computation(s1,6).b=Computation(s1,5).b by A50,A96,SCMPDS_2:60
        .=Computation(s2,5).b by A84,A92
        .=Computation(s2,6).b by A54,A97,SCMPDS_2:60;
    end;
  end;
A98: now
    let b;
    assume
A99: s1.b=s2.b;
    per cases;
    suppose
A100: b=DataLoc(Computation(s1,6).SBP,RetIC);
      then
A101: b=DataLoc(Computation(s2,6).SBP,RetIC) by A6,A91;
      thus Computation(s1,7).b=IC Computation(s1,6) by A57,A100,SCMPDS_2:71
        .=Computation(s2,7).b by A55,A58,A60,A101,SCMPDS_2:71;
    end;
    suppose
A102: b<>DataLoc(Computation(s1,6).SBP,RetIC);
      then
A103: b<>DataLoc(Computation(s2,6).SBP,RetIC) by A6,A91;
      thus Computation(s1,7).b=Computation(s1,6).b by A57,A102,SCMPDS_2:71
        .=Computation(s2,6).b by A91,A99
        .=Computation(s2,7).b by A60,A103,SCMPDS_2:71;
    end;
  end;
  hereby
    let k be Element of NAT,a be Int_position;
    assume
A104: k <= 7 & s1.a=s2.a;
    per cases by A104,NAT_1:32;
    suppose
A105: k=0;
      hence IC Computation(s1,k) = IC s1 by AMI_1:13
        .=IC Computation(s2,k) by A6,A105,AMI_1:13;
      thus Computation(s1,k).a = s1.a by A105,AMI_1:13
        .=Computation(s2,k).a by A104,A105,AMI_1:13;
    end;
    suppose
A106: k=1;
      hence IC Computation(s1,k)=IC Computation(s2,k) by A10,A15;
      thus Computation(s1,k).a = Computation(s2,k).a by A61,A104,A106;
    end;
    suppose
A107: k=2;
      hence IC Computation(s1,k)=IC Computation(s2,k) by A18,A24;
      thus Computation(s1,k).a = Computation(s2,k).a by A62,A104,A107;
    end;
    suppose
A108: k=3;
      hence IC Computation(s1,k)=IC Computation(s2,k) by A27,A36;
      thus Computation(s1,k).a = Computation(s2,k).a by A68,A104,A108;
    end;
    suppose
A109: k=4;
      hence IC Computation(s1,k)=IC Computation(s2,k) by A39,A45;
      thus Computation(s1,k).a = Computation(s2,k).a by A78,A104,A109;
    end;
    suppose
A110: k=5;
      hence IC Computation(s1,k)=IC Computation(s2,k) by A48,A52;
      thus Computation(s1,k).a = Computation(s2,k).a by A84,A104,A110;
    end;
    suppose
A111: k=6;
      hence IC Computation(s1,k)=IC Computation(s2,k) by A55,A58;
      thus Computation(s1,k).a = Computation(s2,k).a by A91,A104,A111;
    end;
    suppose
A112: k=7;
      hence IC Computation(s1,k)= Next IC Computation(s2,6)
      by A55,A57,A58,SCMPDS_2:71
        .= IC Computation(s2,k) by A60,A112,SCMPDS_2:71;
      thus Computation(s1,k).a = Computation(s2,k).a by A98,A104,A112;
    end;
  end;
end;

Lm8: for s1,s2 being State of SCMPDS st
GCD-Algorithm c= s1 & GCD-Algorithm c= s2 & IC s1 = inspos 5 &
s1.SBP >0 & s1.GBP=0 & s1.DataLoc(s1.SBP,3) >= 0 &
s1.DataLoc(s1.SBP,2) >= s1.DataLoc(s1.SBP,3) &
IC s2 = IC s1 & s2.SBP = s1.SBP & s2.GBP=0 &
s2.DataLoc(s1.SBP,2) = s1.DataLoc(s1.SBP,2) &
s2.DataLoc(s1.SBP,3) = s1.DataLoc(s1.SBP,3) holds
ex n st CurInstr Computation(s1,n) = return SBP &
s1.SBP=Computation(s1,n).SBP & CurInstr Computation(s2,n) = return SBP &
s2.SBP=Computation(s2,n).SBP &
(for j be Element of NAT st 1<j & j <= s1.SBP+1 holds
s1.intpos j=Computation(s1,n).intpos j &
s2.intpos j=Computation(s2,n).intpos j ) &
(for k be Element of NAT,a be Int_position st k <= n & s1.a=s2.a holds
IC Computation(s1,k) = IC Computation(s2,k) &
Computation(s1,k).a =Computation(s2,k).a)
proof
  set GA=GCD-Algorithm;
  defpred P[Element of NAT] means for s1,s2 being State of SCMPDS st
  GA c= s1 & GA c= s2 & IC s1 = inspos 5 &
  s1.SBP >0 & s1.GBP=0 & s1.DataLoc(s1.SBP,3) <= $1 &
  s1.DataLoc(s1.SBP,3) >= 0 & s1.DataLoc(s1.SBP,2) >= s1.DataLoc(s1.SBP,3) &
  IC s2 = IC s1 & s2.SBP = s1.SBP & s2.GBP=0 &
  s2.DataLoc(s1.SBP,2) = s1.DataLoc(s1.SBP,2) &
  s2.DataLoc(s1.SBP,3) = s1.DataLoc(s1.SBP,3) holds
  ex n st CurInstr Computation(s1,n) = return SBP &
  s1.SBP=Computation(s1,n).SBP & CurInstr Computation(s2,n) = return SBP &
  s2.SBP=Computation(s2,n).SBP &
  (for j be Element of NAT st 1<j & j <= s1.SBP+1 holds
  s1.intpos j=Computation(s1,n).intpos j &
  s2.intpos j=Computation(s2,n).intpos j) &
  (for k be Element of NAT,a be Int_position st k <= n & s1.a=s2.a holds
  IC Computation(s1,k) = IC Computation(s2,k) &
  Computation(s1,k).a =Computation(s2,k).a);
A1: P[0]
  proof
    let s1,s2 be State of SCMPDS;
    set x =s1.DataLoc(s1.SBP,2), y =s1.DataLoc(s1.SBP,3),
    y2=s2.DataLoc(s1.SBP,3);
:::    , Cs1=Computation s1;:::, Cs2=Computation s2;
    assume
A2: GA c= s1 & GA c= s2;
    assume
A3: IC s1 = inspos 5;
    assume s1.SBP >0 & s1.GBP=0;
    assume
A4: y <= 0;
    assume y >= 0;
    assume x >= y;
    assume
A5: IC s2 = IC s1 & s2.SBP = s1.SBP & s2.GBP=0;
    assume
A6: s2.DataLoc(s1.SBP,2) = x & y2 = y;
A7: Computation(s1,1+0) = Following Computation(s1,0) by AMI_1:14
      .= Following s1 by AMI_1:13
      .= Exec(i05,s1) by A2,A3,Lm1;
A8: Computation(s2,1+0) = Following Computation(s2,0) by AMI_1:14
      .= Following s2 by AMI_1:13
      .= Exec(i05,s2) by A2,A3,A5,Lm1;
A9: IC Computation(s1,1)= ICplusConst(s1,9) by A4,A7,SCMPDS_2:68
      .= inspos (5+9) by A3,SCMPDS_6:23;
A10: IC Computation(s2,1)= ICplusConst(s2,9) by A4,A5,A6,A8,SCMPDS_2:68
      .= inspos (5+9) by A3,A5,SCMPDS_6:23;
    take n=1;
    thus CurInstr Computation(s1,n)=s1.inspos 14 by A9,AMI_1:54
      .=i14 by A2,Lm1;
    thus Computation(s1,n).SBP=s1.SBP by A7,SCMPDS_2:68;
    thus CurInstr Computation(s2,n)=s2.inspos 14 by A10,AMI_1:54
      .=i14 by A2,Lm1;
    thus Computation(s2,n).SBP=s2.SBP by A8,SCMPDS_2:68;
    thus for j be Element of NAT st 1<j & j <= s1.SBP+1 holds
    s1.intpos j=Computation(s1,n).intpos j &
    s2.intpos j=Computation(s2,n).intpos j by A7,A8,SCMPDS_2:68;
    hereby
      let k be Element of NAT,a;
      assume
A11:  k <= n & s1.a=s2.a;
      per cases by A11,NAT_1:26;
      suppose
A12:    k=0;
        hence IC Computation(s1,k) = IC s2 by A5,AMI_1:13
          .=IC Computation(s2,k) by A12,AMI_1:13;
        thus Computation(s1,k).a =s1.a by A12,AMI_1:13
          .=Computation(s2,k).a by A11,A12,AMI_1:13;
      end;
      suppose
A13:    k=1;
        hence IC Computation(s1,k) =IC Computation(s2,k) by A9,A10;
        thus Computation(s1,k).a=s1.a by A7,A13,SCMPDS_2:68
          .=Computation(s2,k).a by A8,A11,A13,SCMPDS_2:68;
      end;
    end;
  end;
A14: now
    let k be Element of NAT;
    assume
A15: P[k];
    now
      let s1,s2 be State of SCMPDS;
      set x =s1.DataLoc(s1.SBP,2), y =s1.DataLoc(s1.SBP,3);
:::      Cs1=Computation s1;:::, Cs2=Computation s2;
      assume
A16:  GA c= s1 & GA c= s2;
      assume
A17:  IC s1 = inspos 5;
      assume
A18:  s1.SBP >0 & s1.GBP=0;
      assume
A19:  y <= k+1;
      assume
A20:  y >= 0;
      assume
A21:  x >= y;
      assume
A22:  IC s2 = IC s1 & s2.SBP = s1.SBP & s2.GBP=0;
      assume
A23:  s2.DataLoc(s1.SBP,2) = x & s2.DataLoc(s1.SBP,3) = y;
      reconsider y as Element of NAT by A20,INT_1:16;
      per cases by A19,NAT_1:8;
      suppose y <= k;
        hence ex n st CurInstr Computation(s1,n) = return SBP &
        s1.SBP=Computation(s1,n).SBP &
        CurInstr Computation(s2,n) = return SBP &
        s2.SBP=Computation(s2,n).SBP &
        (for j be Element of NAT st 1<j & j <= s1.SBP+1 holds
        s1.intpos j=Computation(s1,n).intpos j &
        s2.intpos j=Computation(s2,n).intpos j) &
        (for k be Element of NAT,a st k <= n & s1.a=s2.a holds
        IC Computation(s1,k) = IC Computation(s2,k) &
        Computation(s1,k).a = Computation(s2,k).a)
        by A15,A16,A17,A18,A20,A21,A22,A23;
      end;
      suppose
A24:    y = k+1;
        then
A25:    y>0 by NAT_1:5;
        reconsider n=s1.SBP as Element of NAT by A18,INT_1:16;
A26:    n=s1.SBP;
        set s8=Computation(s1,8), t8=Computation(s2,8);
A27:    IC Computation(s1,7) = inspos (5+7) & s8 = Exec(i12,Computation(s1,7))
 &
        Computation(s1,7).SBP=n+4 & Computation(s1,7).GBP=0 &
        Computation(s1,7).intpos(n+7) = s1.intpos(n+2) mod s1.intpos(n+3) &
        Computation(s1,7).intpos(n+6) = s1.intpos(n+3) &
        IC Computation(s2,7) = inspos (5+7) &
        t8 = Exec(i12,Computation(s2,7)) &
        Computation(s2,7).SBP=n+4 & Computation(s2,7).GBP=0 &
        Computation(s2,7).intpos(n+7) = s1.intpos(n+2) mod s1.intpos(n+3) &
        Computation(s2,7).intpos(n+6) = s1.intpos(n+3) &
        Computation(s1,7).intpos(n+4) = n &
        Computation(s1,7).intpos(n+5) = inspos 11 &
        Computation(s2,7).intpos(n+4) = n &
        Computation(s2,7).intpos(n+5) = inspos 11
        by A16,A17,A18,A22,A23,A25,A26,Lm6;
A28:    DataLoc(n+4,2)=intpos(n+4+2) by Th5
          .=intpos(n+(4+2));
A29:    DataLoc(n+4,3)=intpos(n+4+3) by Th5
          .=intpos(n+(4+3));
A30:    GA c= s8 & GA c= t8 by A16,AMI_1:81;
A31:    IC s8= ICplusConst(Computation(s1,7),-7) by A27,SCMPDS_2:66
          .= inspos 5 by A27,Th6;
A32:    s8.SBP=n+4 by A27,SCMPDS_2:66;
A33:    4<=n+4 by NAT_1:11;
        then
A34:    s8.SBP > 0 by A32,XXREAL_0:2;
A35:    s8.GBP=0 by A27,SCMPDS_2:66;
        set x1=s8.DataLoc(s8.SBP,2), y1=s8.DataLoc(s8.SBP,3);
A36:    x1=s1.intpos(n+3) by A27,A28,A32,SCMPDS_2:66
          .=y by Th5;
A37:    y1= s1.intpos(n+2) mod s1.intpos(n+3) by A27,A29,A32,SCMPDS_2:66
          .= s1.intpos(n+2) mod y by Th5;
        then
A38:    y1<y by A24,NAT_1:5,NEWTON:79;
        then
A39:    y1 <= k by A24,INT_1:20;
A40:    y1 >= 0 by A25,A37,NEWTON:78;
A41:    IC t8= ICplusConst(Computation(s2,7),-7) by A27,SCMPDS_2:66
          .= IC s8 by A27,A31,Th6;
A42:    t8.SBP=s8.SBP by A27,A32,SCMPDS_2:66;
A43:    t8.GBP=0 by A27,SCMPDS_2:66;
        set x3=t8.DataLoc(s8.SBP,2);
A44:    x3=s1.intpos(n+3) by A27,A28,A32,SCMPDS_2:66
          .=x1 by A36,Th5;
        t8.DataLoc(s8.SBP,3)=s1.intpos(n+2) mod s1.intpos(n+3) by A27,A29
        ,A32,SCMPDS_2:66
          .=y1 by A37,Th5;
        then consider m such that
A45:    CurInstr Computation(s8,m) = return SBP &
        s8.SBP=Computation(s8,m).SBP &
        CurInstr Computation(t8,m) = return SBP &
        t8.SBP=Computation(t8,m).SBP &
        (for j be Element of NAT st 1<j & j <= s8.SBP+1 holds
        s8.intpos j=Computation(s8,m).intpos j &
        t8.intpos j=Computation(t8,m).intpos j) &
        (for k be Element of NAT,a be Int_position st k <= m & s8.a=t8.a holds
        IC Computation(s8,k) = IC Computation(t8,k) &
        Computation(s8,k).a =Computation(t8,k).a)
        by A15,A30,A31,A34,A35,A36,A38,A39,A40,A41,A42,A43,A44;
        set s9=Computation(s1,m+8), t9=Computation(s2,m+8);
A46:    s8.SBP=s9.SBP by A45,AMI_1:51;
A47:    Computation(s1,m+(8+1))=Computation(s1,m+8+1)
          .= Following s9 by AMI_1:14
          .= Exec(return SBP,s9) by A45,AMI_1:51;
A48:    1 < n+4 by A33,XXREAL_0:2;
A49:    n+4 < s8.SBP+1 by A32,XREAL_1:31;
        then
A50:    s8.intpos(n+4)=Computation(s8,m).intpos (n+4) by A45,A48
          .=s9.intpos(n+4) by AMI_1:51;
        5<=n+5 by NAT_1:11;
        then
A51:    1 <n+5 by XXREAL_0:2;
A52:    intpos(n+(4+1))=intpos(n+4+1)
          .=DataLoc(n+4,1) by Th5;
A53:    inspos 11=s8.intpos(n+5) by A27,SCMPDS_2:66
          .=Computation(s8,m).intpos (n+5) by A32,A45,A51
          .=s9.DataLoc(s9.SBP,RetIC) by A32,A46,A52,AMI_1:51,SCMPDS_1:def 23;
A54:    t9.SBP=n+4 by A32,A42,A45,AMI_1:51;
A55:    Computation(s2,m+(8+1))=Computation(s2,m+8+1)
          .= Following t9 by AMI_1:14
          .= Exec(return SBP,t9) by A45,AMI_1:51;
A56:    t8.intpos(n+4)=Computation(t8,m).intpos (n+4) by A45,A48,A49
          .=t9.intpos(n+4) by AMI_1:51;
A57:    inspos 11=t8.intpos(n+5) by A27,SCMPDS_2:66
          .=Computation(t8,m).intpos (n+5) by A32,A45,A51
          .=t9.DataLoc(t9.SBP,RetIC) by A52,A54,AMI_1:51,SCMPDS_1:def 23;
A58:    IC Computation(s1,m+9)= (abs(s9.DataLoc(s9.SBP,RetIC)))+2
by A47,SCMPDS_2:70
          .= inspos (11+2) by A53,Th3;
        then
A59:    CurInstr Computation(s1,m+9) =s1.inspos 13 by AMI_1:54
          .=i13 by A16,Lm1;
A60:    Computation(s1,m+(9+1))=Computation(s1,m+9+1)
          .= Following Computation(s1,m+9) by AMI_1:14
          .= Exec(i13,Computation(s1,m+9)) by A59;
A61:    Computation(s1,m+9).SBP=s9.DataLoc(n+4,RetSP)
by A32,A46,A47,SCMPDS_2:70
          .=s9.intpos(n+4+0) by Th5,SCMPDS_1:def 22
          .=n by A27,A50,SCMPDS_2:66;
A62:    IC Computation(s2,m+9)= (abs(t9.DataLoc(t9.SBP,RetIC)))+2
by A55,SCMPDS_2:70
          .= inspos (11+2) by A57,Th3;
        then
A63:    CurInstr Computation(s2,m+9) =s2.inspos 13 by AMI_1:54
          .=i13 by A16,Lm1;
A64:    Computation(s2,m+(9+1))=Computation(s2,m+9+1)
          .= Following Computation(s2,m+9) by AMI_1:14
          .= Exec(i13,Computation(s2,m+9)) by A63;
A65:    Computation(s2,m+9).SBP=t9.DataLoc(n+4,RetSP) by A54,A55,SCMPDS_2:70
          .=t9.intpos(n+4+0) by Th5,SCMPDS_1:def 22
          .=n by A27,A56,SCMPDS_2:66;
A66:    IC Computation(s1,m+10)= Next IC Computation(s1,m+9) by A60,SCMPDS_2:59
          .= inspos (13+1) by A58;
A67:    IC Computation(s2,m+10)= Next IC Computation(s2,m+9) by A64,SCMPDS_2:59
          .= inspos (13+1) by A62;
        hereby
          take nn=m+10;
          thus CurInstr Computation(s1,nn) =s1.inspos 14 by A66,AMI_1:54
            .=return SBP by A16,Lm1;
A68:      DataLoc(Computation(s1,m+9).SBP,2)=intpos(n+2) by A61,Th5;
          then SBP <> DataLoc(Computation(s1,m+9).SBP,2) by Lm3;
          hence Computation(s1,nn).SBP=s1.SBP by A60,A61,SCMPDS_2:59;
          thus CurInstr Computation(s2,nn) =s2.inspos 14 by A67,AMI_1:54
            .=return SBP by A16,Lm1;
A69:      DataLoc(Computation(s2,m+9).SBP,2)=intpos(n+2) by A65,Th5;
          then SBP <> DataLoc(Computation(s2,m+9).SBP,2) by Lm3;
          hence Computation(s2,nn).SBP=s2.SBP by A22,A64,A65,SCMPDS_2:59;
          hereby
            let j be Element of NAT;
            assume
A70:        1<j & j <= s1.SBP+1;
            s1.SBP <= s8.SBP by A32,NAT_1:11;
            then s1.SBP +1 <= s8.SBP+1 by XREAL_1:8;
            then
A71:        j <= s8.SBP+1 by A70,XXREAL_0:2;
A72:        intpos j <> SBP by A70,AMI_3:52;
            then
A73:        Computation(s1,m+9).intpos j=s9.intpos j by A47,SCMPDS_2:70
              .=Computation(s8,m).intpos j by AMI_1:51
              .=s8.intpos j by A45,A70,A71;
A74:        n+1<n+2 by XREAL_1:8;
            then
A75:        intpos j <> DataLoc(Computation(s1,m+9).SBP,2)
by A68,A70, AMI_3:52;
            Computation(s1,7).intpos j = s1.intpos j
            by A16,A17,A18,A24,A26,A70,Lm5
            ,NAT_1:5;
            hence s1.intpos j=s8.intpos j by A27,SCMPDS_2:66
              .=Computation(s1,nn).intpos j by A60,A73,A75,SCMPDS_2:59;
A76:        Computation(s2,m+9).intpos j=t9.intpos j by A55,A72,SCMPDS_2:70
              .=Computation(t8,m).intpos j by AMI_1:51
              .=t8.intpos j by A45,A70,A71;
A77:        intpos j <> DataLoc(Computation(s2,m+9).SBP,2)
by A69,A70,A74,AMI_3:52;
            j <= n+1 by A70;
            then Computation(s2,7).intpos j = s2.intpos j
            by A16,A17,A22,A23,A24,A70,
            Lm5,NAT_1:5;
            hence s2.intpos j=t8.intpos j by A27,SCMPDS_2:66
              .=Computation(s2,nn).intpos j by A64,A76,A77,SCMPDS_2:59;
          end;
          hereby
            let j be Element of NAT,a;
            assume
A78:        j <= nn & s1.a=s2.a;
            nn=m+9+1;
            then
A79:        j <= m+9 or j=nn by A78,NAT_1:8;
A80:        m+(8+1)=m+8+1;
A81:        now
              assume
A82:          j <= m+8;
              per cases;
              suppose j<7+1;
                hence j <=7 or (j>=8 & j <= m+8) by NAT_1:13;
              end;
              suppose j>=8;
                hence j <=7 or (j>=8 & j <= m+8) by A82;
              end;
            end;
A83:        s8.a=Computation(s1,7).a by A27,SCMPDS_2:66
              .=Computation(s2,7).a by A16,A17,A18,A22,A23,A25,A26,A78,Lm7
              .=t8.a by A27,SCMPDS_2:66;
A84:        now
              let b;
              assume
A85:          s8.b=t8.b;
              per cases;
              suppose b=SBP;
                hence Computation(s1,m+9).b=Computation(s2,m+9).b by A61,A65;
              end;
              suppose
A86:            b<>SBP;
                hence Computation(s1,m+9).b=s9.b by A47,SCMPDS_2:70
                  .=Computation(s8,m).b by AMI_1:51
                  .=Computation(t8,m).b by A45,A85
                  .=t9.b by AMI_1:51
                  .=Computation(s2,m+9).b by A55,A86,SCMPDS_2:70;
              end;
            end;
A87:        s8.DataLoc(Computation(s1,m+9).SBP,6)=x1 by A28,A32,A61,Th5
              .=t8.DataLoc(Computation(s1,m+9).SBP,6) by A28,A32,A44,A61,Th5;
A88:        now
              per cases;
              suppose
A89:            a<>DataLoc(Computation(s2,m+9).SBP,2);
                hence Computation(s1,nn).a=Computation(s1,m+9).a
                by A60,A61,A65,SCMPDS_2:59
                  .=Computation(s2,m+9).a by A83,A84
                  .=Computation(s2,nn).a by A64,A89,SCMPDS_2:59;
              end;
              suppose
A90:            a=DataLoc(Computation(s2,m+9).SBP,2);
                hence Computation(s1,nn).a=
                Computation(s1,m+9).DataLoc(Computation(s1,m+9).SBP,6)
                by A60,A61,A65,SCMPDS_2:59
                  .=Computation(s2,m+9).DataLoc(Computation(s2,m+9).SBP,6)
                  by A61,A65,A84,A87
                  .=Computation(s2,nn).a by A64,A90,SCMPDS_2:59;
              end;
            end;
            per cases by A79,A80,A81,NAT_1:8;
            suppose j <=7;
              hence IC Computation(s1,j) = IC Computation(s2,j) &
              Computation(s1,j).a=Computation(s2,j).a
              by A16,A17,A18,A22,A23,A25,A26,A78,Lm7;
            end;
            suppose
A91:          j>=8 & j <= m+8;
              then consider j1 be Nat such that
A92:          j=8+j1 by NAT_1:10;
              reconsider j1 as Element of NAT by ORDINAL1:def 13;
A93:          j1 <= m by A91,A92,XREAL_1:8;
              thus IC Computation(s1,j) = IC Computation(s8,j1) by A92,AMI_1:51
                .=IC Computation(t8,j1) by A45,A83,A93
                .=IC Computation(s2,j) by A92,AMI_1:51;
              thus Computation(s1,j).a = Computation(s8,j1).a by A92,AMI_1:51
                .=Computation(t8,j1).a by A45,A83,A93
                .=Computation(s2,j).a by A92,AMI_1:51;
            end;
            suppose
A94:          j = m+9;
              hence IC Computation(s1,j) = IC Computation(s2,j) by A58,A62;
              thus Computation(s1,j).a=Computation(s2,j).a by A83,A84,A94;
            end;
            suppose
A95:          j = nn;
              hence IC Computation(s1,j) = IC Computation(s2,j) by A66,A67;
              thus Computation(s1,j).a=Computation(s2,j).a by A88,A95;
            end;
          end;
        end;
      end;
    end;
    hence P[k+1];
  end;
A96: for n holds P[n] from NAT_1:sch 1(A1,A14);
  let s1,s2 be State of SCMPDS;
  assume
A97: GA c= s1 & GA c= s2 & IC s1 = inspos 5 & s1.SBP >0 & s1.GBP=0 &
  s1.DataLoc(s1.SBP,3) >= 0 & s1.DataLoc(s1.SBP,2) >= s1.DataLoc(s1.SBP,3) &
  IC s2 = IC s1 & s2.SBP = s1.SBP & s2.GBP=0 &
  s2.DataLoc(s1.SBP,2) = s1.DataLoc(s1.SBP,2) &
  s2.DataLoc(s1.SBP,3) = s1.DataLoc(s1.SBP,3);
  then reconsider m=s1.DataLoc(s1.SBP,3) as Element of NAT by INT_1:16;
  P[m] by A96;
  hence thesis by A97;
end;

Lm9: for s1,s2 being State of SCMPDS,a be Int_position,k be Element of NAT
st Initialized GCD-Algorithm c= s1 & Initialized GCD-Algorithm c= s2
& s1.a=s2.a & k <= 4 holds IC Computation(s1,k) = IC Computation(s2,k) &
Computation(s1,k).a = Computation(s2,k).a
proof
  let s1,s2 be State of SCMPDS,a be Int_position,k be Element of NAT;
  set GA=GCD-Algorithm;
:::  , Cs1=Computation s1;:::, Cs2=Computation s2;
  assume
A1: Initialized GA c= s1 & Initialized GA c= s2;
  assume
A2: s1.a=s2.a & k <= 4;
A3: GA c= s1 & GA c= s2 by A1,SCMPDS_4:57;
A4: IC s1=inspos 0 by A1,SCMPDS_5:18;
A5: Computation(s1,0+1) = Following Computation(s1,0) by AMI_1:14
    .= Following s1 by AMI_1:13
    .= Exec(i00,s1) by A3,A4,Lm1;
A6: IC s2=inspos 0 by A1,SCMPDS_5:18;
A7: Computation(s2,0+1) = Following Computation(s2,0) by AMI_1:14
    .= Following s2 by AMI_1:13
    .= Exec(i00,s2) by A3,A6,Lm1;
A8: IC Computation(s1,1)= Next IC s1 by A5,SCMPDS_2:57
    .= inspos (0+1) by A4;
  then
A9: CurInstr Computation(s1,1)=s1.inspos 1 by AMI_1:54
    .=i01 by A3,Lm1;
A10: Computation(s1,1+1) = Following Computation(s1,1) by AMI_1:14
    .= Exec(i01,Computation(s1,1)) by A9;
A11: IC Computation(s2,1)= Next IC s2 by A7,SCMPDS_2:57
    .= inspos (0+1) by A6;
  then
A12: CurInstr Computation(s2,1)=s2.inspos 1 by AMI_1:54
    .=i01 by A3,Lm1;
A13: Computation(s2,1+1) = Following Computation(s2,1) by AMI_1:14
    .= Exec(i01,Computation(s2,1)) by A12;
A14: IC Computation(s1,2)= Next IC Computation(s1,1) by A10,SCMPDS_2:57
    .= inspos (1+1) by A8;
  then
A15: CurInstr Computation(s1,2)=s1.inspos 2 by AMI_1:54
    .=i02 by A3,Lm1;
A16: Computation(s1,2+1) = Following Computation(s1,2) by AMI_1:14
    .= Exec(i02,Computation(s1,2)) by A15;
A17: Computation(s1,2).SBP=7 by A10,SCMPDS_2:57;
A18: IC Computation(s2,2)= Next IC Computation(s2,1) by A13,SCMPDS_2:57
    .= inspos (1+1) by A11;
  then
A19: CurInstr Computation(s2,2)=s2.inspos 2 by AMI_1:54
    .=i02 by A3,Lm1;
A20: Computation(s2,2+1) = Following Computation(s2,2) by AMI_1:14
    .= Exec(i02,Computation(s2,2)) by A19;
A21: Computation(s2,2).SBP=7 by A13,SCMPDS_2:57;
A22: IC Computation(s1,3)= Next IC Computation(s1,2) by A16,SCMPDS_2:71
    .= inspos (2+1) by A14;
  then
A23: CurInstr Computation(s1,3)=s1.inspos 3 by AMI_1:54
    .=i03 by A3,Lm1;
A24: Computation(s1,3+1) = Following Computation(s1,3) by AMI_1:14
    .= Exec(i03,Computation(s1,3)) by A23;
A25: IC Computation(s2,3)= Next IC Computation(s2,2) by A20,SCMPDS_2:71
    .= inspos (2+1) by A18;
  then
A26: CurInstr Computation(s2,3)=s2.inspos 3 by AMI_1:54
    .=i03 by A3,Lm1;
A27: Computation(s2,3+1) = Following Computation(s2,3) by AMI_1:14
    .= Exec(i03,Computation(s2,3)) by A26;
A28: now
    let b;
    assume
A29: s1.b=s2.b;
    per cases;
    suppose
A30:  b=GBP;
      hence Computation(s1,1).b=0 by A5,SCMPDS_2:57
        .=Computation(s2,1).b by A7,A30,SCMPDS_2:57;
    end;
    suppose
A31:  b<>GBP;
      hence Computation(s1,1).b=s1.b by A5,SCMPDS_2:57
        .=Computation(s2,1).b by A7,A29,A31,SCMPDS_2:57;
    end;
  end;
A32: now
    let b;
    assume
A33: s1.b=s2.b;
    per cases;
    suppose
A34:  b=SBP;
      hence Computation(s1,2).b=7 by A10,SCMPDS_2:57
        .=Computation(s2,2).b by A13,A34,SCMPDS_2:57;
    end;
    suppose
A35:  b<>SBP;
      hence Computation(s1,2).b=Computation(s1,1).b by A10,SCMPDS_2:57
        .=Computation(s2,1).b by A28,A33
        .=Computation(s2,2).b by A13,A35,SCMPDS_2:57;
    end;
  end;
A36: now
    let b;
    assume
A37: s1.b=s2.b;
    per cases;
    suppose
A38:  b=DataLoc(Computation(s1,2).SBP,RetIC);
      hence Computation(s1,3).b=IC Computation(s1,2) by A16,SCMPDS_2:71
        .=Computation(s2,3).b by A14,A17,A18,A20,A21,A38,SCMPDS_2:71;
    end;
    suppose
A39:  b<>DataLoc(Computation(s1,2).SBP,RetIC);
      hence Computation(s1,3).b=Computation(s1,2).b by A16,SCMPDS_2:71
        .=Computation(s2,2).b by A32,A37
        .=Computation(s2,3).b by A17,A20,A21,A39,SCMPDS_2:71;
    end;
  end;
  per cases by A2,NAT_1:29;
  suppose
A40: k=0;
    hence IC Computation(s1,k) = IC s1 by AMI_1:13
      .=IC Computation(s2,k) by A4,A6,A40,AMI_1:13;
    thus Computation(s1,k).a = s1.a by A40,AMI_1:13
      .=Computation(s2,k).a by A2,A40,AMI_1:13;
  end;
  suppose
A41: k=1;
    hence IC Computation(s1,k)=IC Computation(s2,k) by A8,A11;
    thus Computation(s1,k).a = Computation(s2,k).a by A2,A28,A41;
  end;
  suppose
A42: k=2;
    hence IC Computation(s1,k)=IC Computation(s2,k) by A14,A18;
    thus Computation(s1,k).a = Computation(s2,k).a by A2,A32,A42;
  end;
  suppose
A43: k=3;
    hence IC Computation(s1,k)=IC Computation(s2,k) by A22,A25;
    thus Computation(s1,k).a = Computation(s2,k).a by A2,A36,A43;
  end;
  suppose
A44: k=4;
    hence IC Computation(s1,k)= ICplusConst(Computation(s1,3),2)
    by A24,SCMPDS_2:66
      .= inspos (3+2) by A22,SCMPDS_6:23
      .= ICplusConst(Computation(s2,3),2) by A25,SCMPDS_6:23
      .= IC Computation(s2,k) by A27,A44,SCMPDS_2:66;
    thus Computation(s1,k).a = Computation(s1,3).a by A24,A44,SCMPDS_2:66
      .=Computation(s2,3).a by A2,A36
      .=Computation(s2,k).a by A27,A44,SCMPDS_2:66;
  end;
end;

begin :: The Autonomy of Recursive Euclide Algorithm

theorem
  for p being FinPartState of SCMPDS,x,y being Integer st y >= 0 & x >= y
  & p=(intpos 9,intpos 10) --> (x,y)
  holds Initialized GCD-Algorithm +* p is autonomic
proof
  let p be FinPartState of SCMPDS,x,y be Integer;
  set GA=GCD-Algorithm, IA=Initialized GA, a=intpos 9, b=intpos 10;
  assume
A1: y >= 0 & x >= y & p=(a,b) --> (x,y);
  then
A2: dom p = { a,b } by FUNCT_4:65;
A3: dom IA= {IC SCMPDS} \/ dom GA by SCMPDS_4:27;
  now
    assume dom IA meets dom p;
    then consider z being set such that
A4: z in dom IA & z in dom p by XBOOLE_0:3;
    z = a or z = b by A2,A4,TARSKI:def 2;
    hence contradiction by A4,SCMPDS_4:31;
  end;
  then
A5: IA c= IA +* p by FUNCT_4:33;
A6: a in dom p & b in dom p by A2,TARSKI:def 2;
A7: for t being State of SCMPDS st IA +* p c= t holds t.a = x & t.b = y
  proof
    let t be State of SCMPDS such that
A8: IA +* p c= t;
    p c= IA +* p by FUNCT_4:26;
    then
A9: p c= t by A8,XBOOLE_1:1;
A10: a <> b by AMI_3:52;
    thus t.a = p.a by A6,A9,GRFUNC_1:8
      .= x by A1,A10,FUNCT_4:66;
    thus t.b = p.b by A6,A9,GRFUNC_1:8
      .= y by A1,FUNCT_4:66;
  end;
  thus IA +* p is autonomic
  proof
    let s1,s2 be State of SCMPDS such that
A11: IA +* p c= s1 and
A12: IA +* p c= s2;
A13: IA c= s1 by A5,A11,XBOOLE_1:1;
    then
A14: GA c= s1 by SCMPDS_4:57;
A15: IA c= s2 by A5,A12,XBOOLE_1:1;
    then
A16: GA c= s2 by SCMPDS_4:57;
A17: s1.a=x & s1.b=y by A7,A11;
A18: s2.a=x & s2.b=y by A7,A12;
:::    set Cs1 = Computation s1;:::, Cs2 = Computation s2;
    set s4=Computation(s1,4), t4=Computation(s2,4);
A19: GA c= s4 by A13,AMI_1:81,SCMPDS_4:57;
A20: IC s4 = inspos 5 & s4.GBP = 0 &
    s4.SBP = 7 & s4.intpos(7+RetIC) = inspos 2 &
    s4.intpos 9 = s1.intpos 9 & s4.intpos 10 = s1.intpos 10 by A13,Th15;
    then
A21: s4.DataLoc(s4.SBP,3)=s4.intpos (7+3) by Th5
      .=y by A7,A11,A20;
A22: DataLoc(s4.SBP,2)=intpos(7+2) by A20,Th5;
    then
A23: s4.DataLoc(s4.SBP,2)=x by A7,A11,A20;
A24: GA c= t4 by A15,AMI_1:81,SCMPDS_4:57;
A25: IC t4 = inspos 5 & t4.GBP = 0 &
    t4.SBP = 7 & t4.intpos(7+RetIC) = inspos 2 &
    t4.intpos 9 = s2.intpos 9 & t4.intpos 10 = s2.intpos 10 by A15,Th15;
    then
A26: t4.DataLoc(t4.SBP,3)=t4.intpos (7+3) by Th5
      .=s4.DataLoc(s4.SBP,3) by A7,A12,A21,A25;
    DataLoc(t4.SBP,2)=intpos(7+2) by A25,Th5;
    then
A27: t4.DataLoc(t4.SBP,2)=s4.DataLoc(s4.SBP,2) by A7,A12,A23,A25;
:::    set Cs4=Computation s4;::, Ct4=Computation t4;
    consider n such that
A28: CurInstr Computation(s4,n) = return SBP & s4.SBP=Computation(s4,n).SBP &
    CurInstr Computation(t4,n) = return SBP &
    t4.SBP=Computation(t4,n).SBP &
    (for j be Element of NAT st 1<j & j <= s4.SBP+1 holds
    s4.intpos j=Computation(s4,n).intpos j &
    t4.intpos j=Computation(t4,n).intpos j) &
    (for k be Element of NAT,c be Int_position st k <= n & s4.c = t4.c holds
    IC Computation(s4,k) = IC Computation(t4,k) &
    Computation(s4,k).c =Computation(t4,k).c)
    by A1,A17,A19,A20,A21,A22,A24,A25,A26,A27,Lm8;
A29: Computation(s4,n).DataLoc(Computation(s4,n).SBP,RetIC)
    =Computation(s4,n).intpos(7+1) by A20,A28,Th5,SCMPDS_1:def 23
      .=inspos 2 by A20,A28,SCMPDS_1:def 23;
A30: Computation(t4,n).DataLoc(Computation(t4,n).SBP,RetIC)
    =Computation(t4,n).intpos(7+1) by A25,A28,Th5,SCMPDS_1:def 23
      .=inspos 2 by A20,A25,A28,SCMPDS_1:def 23;
A31: Computation(s4,n+1)= Following Computation(s4,n) by AMI_1:14
      .= Exec(i14,Computation(s4,n)) by A28;
    then
A32: IC Computation(s4,n+1)=
 (abs(Computation(s4,n).DataLoc(Computation(s4,n).SBP,RetIC)))+2
  by SCMPDS_2 :70
      .= inspos (2+2) by A29,Th3;
    then
A33: CurInstr Computation(s4,n+1) =s4.inspos 4 by AMI_1:54
      .=s1.inspos 4 by AMI_1:54
      .=i04 by A14,Lm1;
A34: Computation(t4,n+1)= Following Computation(t4,n) by AMI_1:14
      .= Exec(i14,Computation(t4,n)) by A28;
    then
A35: IC Computation(t4,n+1)= (abs(Computation(t4,n).
DataLoc(Computation(t4,n).SBP,RetIC)))+2 by SCMPDS_2 :70
      .= inspos (2+2) by A30,Th3;
    then
A36: CurInstr Computation(t4,n+1) =t4.inspos 4 by AMI_1:54
      .=s2.inspos 4 by AMI_1:54
      .=i04 by A16,Lm1;
A37: s4.a=t4.a by A13,A15,A17,A18,Lm9;
A38: s4.b=t4.b by A13,A15,A17,A18,Lm9;
A39: a <> SBP by AMI_3:52;
    then
A40: Computation(s4,n+1).a=Computation(s4,n).a by A31,SCMPDS_2:70
      .=Computation(t4,n).a by A28,A37
      .=Computation(t4,n+1).a by A34,A39,SCMPDS_2:70;
A41: b <> SBP by AMI_3:52;
    then
A42: Computation(s4,n+1).b=Computation(s4,n).b by A31,SCMPDS_2:70
      .=Computation(t4,n).b by A28,A38
      .=Computation(t4,n+1).b by A34,A41,SCMPDS_2:70;
A43: now
      let j be Element of NAT;
A44:  j<n+4+1 or j>=n+5;
A45:  now
        assume
A46:    j <= n+4;
A47:    j<3+1 or j>= 4;
        per cases by A47,NAT_1:13;
        case j<=3;
          hence j<=3;
        end;
        case j>=4;
          hence j>=4 & j <= n+4 by A46;
        end;
      end;
      per cases by A44,A45,NAT_1:13;
      suppose j<=3;
        then
A48:    j<=4 by XXREAL_0:2;
        hence IC Computation(s1,j)=IC Computation(s2,j) by A13,A15,A17,A18,Lm9;
        thus Computation(s1,j).a=Computation(s2,j).a
        by A13,A15,A17,A18,A48,Lm9;
        thus Computation(s1,j).b=Computation(s2,j).b
        by A13,A15,A17,A18,A48,Lm9;
      end;
      suppose
A49:    j>=4 & j<=n+4;
        then consider j1 be Nat such that
A50:    j=4+j1 by NAT_1:10;
        reconsider j1 as Element of NAT by ORDINAL1:def 13;
A51:    j1 <= n by A49,A50,XREAL_1:8;
        thus IC Computation(s1,j) = IC Computation(s4,j1) by A50,AMI_1:51
          .=IC Computation(t4,j1) by A28,A37,A51
          .=IC Computation(s2,j) by A50,AMI_1:51;
        thus Computation(s1,j).a = Computation(s4,j1).a by A50,AMI_1:51
          .=Computation(t4,j1).a by A28,A37,A51
          .=Computation(s2,j).a by A50,AMI_1:51;
        thus Computation(s1,j).b = Computation(s4,j1).b by A50,AMI_1:51
          .=Computation(t4,j1).b by A28,A38,A51
          .=Computation(s2,j).b by A50,AMI_1:51;
      end;
      suppose j>=n+5;
        then consider j1 be Nat such that
A52:    j=n+(1+4)+j1 by NAT_1:10;
        reconsider j1 as Element of NAT by ORDINAL1:def 13;
A53:    j=n+1+j1+4 by A52;
        hence IC Computation(s1,j)=IC Computation(s4,n+1+j1) by AMI_1:51
          .=IC Computation(t4,n+1) by A32,A33,A35,AMI_1:52,NAT_1:11
          .=IC Computation(t4,n+1+j1) by A36,AMI_1:52,NAT_1:11
          .=IC Computation(s2,j) by A53,AMI_1:51;
        thus Computation(s1,j).a = Computation(s4,n+1+j1).a by A53,AMI_1:51
          .=Computation(t4,n+1).a by A33,A40,AMI_1:52,NAT_1:11
          .=Computation(t4,n+1+j1).a by A36,AMI_1:52,NAT_1:11
          .=Computation(s2,j).a by A53,AMI_1:51;
        thus Computation(s1,j).b = Computation(s4,n+1+j1).b by A53,AMI_1:51
          .=Computation(t4,n+1).b by A33,A42,AMI_1:52,NAT_1:11
          .=Computation(t4,n+1+j1).b by A36,AMI_1:52,NAT_1:11
          .=Computation(s2,j).b by A53,AMI_1:51;
      end;
    end;
    set A = { IC SCMPDS, a,b };
A54: dom(IA +* p) = { IC SCMPDS } \/ dom GA \/ { a, b } by A2,A3,FUNCT_4:def 1
      .= { IC SCMPDS } \/ { a,b } \/ dom GA by XBOOLE_1:4
      .= A \/ dom GA by ENUMSET1:42;
    let k be Element of NAT;
A55: GA c= Computation(s2,k) by A16,AMI_1:86;
    GA c= Computation(s1,k) by A14,AMI_1:86;
    then
A56: Computation(s1,k) | dom GA = GA by GRFUNC_1:64
      .= (Computation(s2,k))| dom GA by A55,GRFUNC_1:64;
A57: (Computation(s1,k)).IC SCMPDS = IC Computation(s1,k)
      .=IC Computation(s2,k) by A43
      .=(Computation(s2,k)).IC SCMPDS;
A58: Computation(s1,k).a = Computation(s2,k).a &
Computation(s1,k).b = Computation(s2,k).b by A43;
    dom(Computation(s1,k)) = the carrier of SCMPDS by AMI_1:79
      .= dom(Computation(s2,k)) by AMI_1:79;
    then (Computation(s1,k))|A = (Computation(s2,k))|A by A57,A58,GRFUNC_1:92;
    hence Computation(s1,k)|dom(IA +* p) = Computation(s2,k)|dom(IA +* p)
    by A54,A56,RELAT_1:185;
  end;
end;

