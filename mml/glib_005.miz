:: Proof of Ford/Fulkerson's Maximum Network Flow Algorithm
::  by Gilbert Lee
::
:: Received February 22, 2005
:: Copyright (c) 2005 Association of Mizar Users

environ

 vocabularies AMI_1, ARYTM, ARYTM_1, ARYTM_3, BOOLE, CARD_1, CAT_1, FINSEQ_1,
      FINSET_1, FUNCOP_1, FUNCT_1, FUNCT_4, GRAPH_1, GRAPH_5, GLIB_000,
      GLIB_001, GLIB_003, GLIB_005, MATRIX_2, MSAFREE2, NAT_1, NEWTON,
      ORDINAL2, PARTFUN1, PBOOLE, POLYNOM1, PRE_TOPC, REALSET1, RELAT_1,
      RLVECT_1, SEQ_1, SEQM_3, SGRAPH1, TREES_1, UPROOTS;
 notations TARSKI, XBOOLE_0, CARD_1, NUMBERS, SUBSET_1, XCMPLX_0, XXREAL_0,
      XREAL_0, DOMAIN_1, REAL_1, RELAT_1, PARTFUN1, FUNCT_1, FINSEQ_1,
      VALUED_1, SEQ_1, PBOOLE, FUNCT_2, GRAPH_5, ORDINAL1, POLYNOM1, UPROOTS,
      RELSET_1, FINSET_1, NAT_1, NAT_D, FUNCOP_1, FUNCT_4, PRE_CIRC, SEQM_3,
      GLIB_000, GLIB_001, ABIAN, GLIB_002, GLIB_003, GLIB_004;
 constructors DOMAIN_1, FUNCT_4, XXREAL_0, REAL_1, NAT_D, BINOP_2, PRE_CIRC,
      GRAPH_2, GRAPH_5, UPROOTS, GLIB_004, SEQ_1, VALUED_1, PARTFUN1;
 registrations XBOOLE_0, SUBSET_1, RELAT_1, FUNCT_1, ORDINAL1, FUNCOP_1,
      FINSET_1, NUMBERS, XXREAL_0, XREAL_0, NAT_1, MEMBERED, FINSEQ_1, RFINSEQ,
      GLIB_000, ABIAN, POLYNOM1, BAGORDER, GLIB_001, GLIB_002, GLIB_003,
      GLIB_004, SEQM_3, VALUED_0, VALUED_1, FUNCT_2;
 requirements ARITHM, BOOLE, NUMERALS, REAL, SUBSET;
 definitions GLIB_000, GLIB_003, FUNCOP_1, VALUED_1;
 theorems CARD_1, CARD_2, FUNCOP_1, FINSEQ_1, FINSEQ_2, FINSEQ_3, FUNCT_1,
      FUNCT_2, FUNCT_4, GLIB_000, GLIB_001, GLIB_003, GLIB_004, GRAPH_5,
      HEYTING3, INT_1, NAT_1, PBOOLE, PEPIN, POLYNOM1, REAL_1, RELAT_1, SEQ_1,
      SEQM_3, TARSKI, UPROOTS, XBOOLE_0, XBOOLE_1, XREAL_0, ZFMISC_1, XREAL_1,
      XXREAL_0, ORDINAL1, NAT_D, VALUED_0;
 schemes BINARITH, NAT_1, SUBSET_1, FINSEQ_1, FUNCT_1, RECDEF_1, GRAPH_5;

begin ::Preliminaries definitions for Maximum Flow Algorithm

definition let G be EGraph;
  attr G is complete-elabeled means :Def1: ::dCMPELABEL
    dom the_ELabel_of G = the_Edges_of G;
end;

registration let G be _Graph, X be ManySortedSet of the_Edges_of G;
  cluster G.set(ELabelSelector, X) -> complete-elabeled;
  coherence proof
    set G2 = G.set(ELabelSelector,X);
     the_ELabel_of G2 = X by GLIB_000:11;
then A1: dom the_ELabel_of G2 = the_Edges_of G by PBOOLE:def 3;
     G2 == G by GLIB_003:8;
    then the_Edges_of G2 = the_Edges_of G by GLIB_000:def 36;
    hence thesis by A1,Def1;
  end;
end;

registration let G be _Graph, Y be non empty set,
                 X be Function of the_Edges_of G, Y;
  cluster G.set(ELabelSelector, X) -> complete-elabeled;
  coherence proof
    set G2 = G.set(ELabelSelector,X);
     the_ELabel_of G2 = X by GLIB_000:11;
then A1: dom the_ELabel_of G2 = the_Edges_of G by FUNCT_2:def 1;
     G2 == G by GLIB_003:8;
    then the_Edges_of G2 = the_Edges_of G by GLIB_000:def 36;
    hence thesis by A1,Def1;
  end;
end;

definition let GSq be EGraphSeq;
  attr GSq is complete-elabeled means :Def2: ::dGSEQCELABEL
    for x being Nat holds GSq.x is complete-elabeled;
end;

definition let G be WGraph;
  attr G is natural-weighted means :Def3: ::dNATWEIGHT
    the_Weight_of G is natural-yielding;
end;

definition let G be EGraph;
  attr G is natural-elabeled means :Def4: ::dNATELABEL
    the_ELabel_of G is natural-yielding;
end;

definition let GSq be WGraphSeq;
  attr GSq is natural-weighted means :Def5: ::dGSEQNWEIGHT
    for x being Nat holds GSq.x is natural-weighted;
end;

definition let GSq be EGraphSeq;
  attr GSq is natural-elabeled means :Def6: ::dGSEQNELABEL
    for x being Nat holds GSq.x is natural-elabeled;
end;

registration
  cluster natural-weighted -> nonnegative-weighted WGraph;
  coherence proof
    let G be WGraph; assume G is natural-weighted;
then A1: the_Weight_of G is natural-yielding by Def3;
     now let y be set; assume
    A2: y in rng the_Weight_of G;
         rng the_Weight_of G c= NAT by A1,VALUED_0:def 6;
        then reconsider y'=y as Element of NAT by A2;
         y' is Real & y' >= 0;
        hence y in Real>=0 by GRAPH_5:def 12;
    end;
    then rng the_Weight_of G c= Real>=0 by TARSKI:def 3;
    hence thesis by GLIB_003:def 14;
  end;
end;

registration
  cluster natural-elabeled -> real-elabeled EGraph;
  coherence proof
    let G be EGraph; assume G is natural-elabeled;
    then reconsider EL = the_ELabel_of G as natural-yielding Function
      by Def4;
     EL is real-yielding;
    hence thesis by GLIB_003:def 15;
  end;
end;

registration
  cluster finite trivial Tree-like natural-weighted
          natural-elabeled complete-elabeled real-vlabeled WEVGraph;
  existence proof
    set V = {1}; set E = {};
    reconsider S = {} as Function of E,V by FUNCT_2:55,RELAT_1:60;
    set G1 = createGraph(V,E,S,S);
    consider WL being Function of the_Edges_of G1, NAT;
    set G2 = G1.set(WeightSelector, WL);
    consider EL being Function of the_Edges_of G2, NAT;
    set G3 = G2.set(ELabelSelector, EL);
    consider VL being PartFunc of the_Vertices_of G3, REAL;
    set G4 = G3.set(VLabelSelector, VL);
    take G4;
    thus G4 is finite & G4 is trivial & G4 is Tree-like;
A1: G4==G3 & G3==G2 & G2==G1 by GLIB_003:8;
     the_Weight_of G4 = G3.WeightSelector by GLIB_000:12
                    .= G2.WeightSelector by GLIB_000:12
                    .= WL by GLIB_000:11;
    hence G4 is natural-weighted by Def3;
A2: the_ELabel_of G4 = G3.ELabelSelector by GLIB_000:12
                    .= EL by GLIB_000:11;
    hence G4 is natural-elabeled by Def4;
     dom the_ELabel_of G4 = the_Edges_of G2 by A2,FUNCT_2:def 1
                        .= the_Edges_of G3 by A1,GLIB_000:def 36
                        .= the_Edges_of G4 by A1,GLIB_000:def 36;
    hence G4 is complete-elabeled by Def1;
    thus G4 is real-vlabeled;
  end;
end;

registration
  cluster finite natural-weighted real-WEV natural-elabeled
          complete-elabeled WEVGraphSeq;
  existence proof
    consider G being finite natural-weighted real-WEV natural-elabeled
      complete-elabeled WEVGraph;
    set F = NAT --> G;
A1: dom F = NAT by FUNCOP_1:19;
    reconsider F as ManySortedSet of NAT;
     now let x be Nat;
       x in NAT by ORDINAL1:def 13; then
         F.x in rng F by A1,FUNCT_1:12;
        then F.x in {G} by FUNCOP_1:14;
        hence F.x is _Graph by TARSKI:def 1;
    end; then reconsider F as GraphSeq by GLIB_000:def 55;
     now let x be Nat;  x in NAT by ORDINAL1:def 13;
        then F.x in rng F by A1,FUNCT_1:12;
        then F.x in {G} by FUNCOP_1:14;
        hence F.x is [Weighted] & F.x is [ELabeled] & F.x is [VLabeled] by
TARSKI:def 1;
    end; then reconsider F as WEVGraphSeq
      by GLIB_003:def 24,def 25,def 26;
    take F;
     now let x be Nat;  x in NAT by ORDINAL1:def 13;
      then F.x in rng F by A1,FUNCT_1:12;
      then F.x in {G} by FUNCOP_1:14;
      hence F.x is finite & F.x is real-WEV & F.x is complete-elabeled
        & F.x is natural-elabeled & F.x is natural-weighted by TARSKI:def 1;
    end;
    hence thesis by Def2,Def5,Def6,GLIB_000:def 60,GLIB_003:def 31;
  end;
end;

registration let GSq be complete-elabeled EGraphSeq, x be Element of NAT;
  cluster GSq.x -> complete-elabeled EGraph;
  coherence by Def2;
end;

registration let GSq be natural-elabeled EGraphSeq, x be Element of NAT;
  cluster GSq.x -> natural-elabeled EGraph;
  coherence by Def6;
end;

registration let GSq be natural-weighted WGraphSeq, x be Element of NAT;
  cluster GSq.x -> natural-weighted WGraph;
  coherence by Def5;
end;

registration let G be natural-weighted WGraph;
  cluster the_Weight_of G -> natural-yielding;
  coherence by Def3;
end;

registration let G be natural-elabeled EGraph;
  cluster the_ELabel_of G -> natural-yielding;
  coherence by Def4;
end;

definition let G be complete-elabeled EGraph;
  redefine func the_ELabel_of G -> ManySortedSet of the_Edges_of G;
  coherence proof
     dom the_ELabel_of G = the_Edges_of G by Def1;
    hence thesis by PBOOLE:def 3;
  end;
end;

registration let G be natural-weighted WGraph, X be set;
  cluster G.set(ELabelSelector, X) -> natural-weighted; coherence proof
    set G2 = G.set(ELabelSelector,X);
    the_Weight_of G2 = the_Weight_of G by GLIB_000:12;
    hence thesis by Def3;
  end;
  cluster G.set(VLabelSelector, X) -> natural-weighted; coherence proof
    set G2 = G.set(VLabelSelector,X);
     the_Weight_of G2 = the_Weight_of G by GLIB_000:12;
    hence thesis by Def3;
  end;
end;

registration let G be _Graph,
                 X be natural-yielding ManySortedSet of the_Edges_of G;
  cluster G.set(ELabelSelector, X) -> natural-elabeled;
  coherence proof
    set G2 = G.set(ELabelSelector, X);
     the_ELabel_of G2 = X by GLIB_000:11;
    hence thesis by Def4;
  end;
end;

definition let G be finite real-weighted
                    real-elabeled complete-elabeled WEGraph,
               source,sink be set;
  pred G has_valid_flow_from source,sink means :Def7: ::dVFLOW
     source is Vertex of G & sink is Vertex of G &
     (for e being set st e in the_Edges_of G holds
        0 <= (the_ELabel_of G).e &
             (the_ELabel_of G).e <= (the_Weight_of G).e) &
     (for v being Vertex of G st v <> source & v <> sink holds
       Sum ((the_ELabel_of G) | v.edgesIn()) =
       Sum ((the_ELabel_of G) | v.edgesOut()));
end;

definition let G be finite real-weighted real-elabeled
                    complete-elabeled WEGraph, source, sink be set; assume
  G has_valid_flow_from source,sink; ::
  func G.flow(source,sink) -> real number equals :Def8: ::dGFLOW
    Sum ((the_ELabel_of G) | G.edgesInto({sink})) -
    Sum ((the_ELabel_of G) | G.edgesOutOf({sink}));
  coherence;
end;

definition let G be finite real-weighted real-elabeled
                    complete-elabeled WEGraph, source,sink be set;
  pred G has_maximum_flow_from source,sink means :Def9: ::dGMAXFLOW
    G has_valid_flow_from source,sink &
    for G2 being finite real-weighted real-elabeled complete-elabeled WEGraph
     st G2 == G & the_Weight_of G = the_Weight_of G2 &
        G2 has_valid_flow_from source,sink holds
        G2.flow(source,sink) <= G.flow(source,sink);
end;

definition let G be real-weighted real-elabeled WEVGraph, e be set;
  pred e is_forward_labeling_in G means :Def10: ::dFORLABEL
    e in the_Edges_of G &
    (the_Source_of G).e in G.labeledV() &
    not (the_Target_of G).e in G.labeledV() &
    (the_ELabel_of G).e < (the_Weight_of G).e;
end;

definition let G be real-elabeled EVGraph, e be set;
  pred e is_backward_labeling_in G means :Def11: ::dBACKLABEL
    e in the_Edges_of G &
    (the_Target_of G).e in G.labeledV() &
    not (the_Source_of G).e in G.labeledV() &
    0 < (the_ELabel_of G).e;
end;

definition let G be real-weighted real-elabeled WEGraph, W be Walk of G;
  attr W is augmenting means :Def12: ::dWAUGMENT
   for n being odd Element of NAT st n < len W holds
     (W.(n+1) DJoins W.n, W.(n+2), G implies
       (the_ELabel_of G).(W.(n+1)) < (the_Weight_of G).(W.(n+1))) &
     (not W.(n+1) DJoins W.n,W.(n+2), G implies
       0 < (the_ELabel_of G).(W.(n+1)));
end;

registration let G be real-weighted real-elabeled WEGraph;
  cluster trivial -> augmenting Walk of G;
  coherence proof
    let W be Walk of G; assume
A1: W is trivial;
     now let n be odd Element of NAT; assume n < len W;
        then n < 1 by A1,GLIB_001:127;
        hence (W.(n+1) DJoins W.n, W.(n+2), G implies
          (the_ELabel_of G).(W.(n+1)) < (the_Weight_of G).(W.(n+1))) &
          (not W.(n+1) DJoins W.n,W.(n+2), G implies
          0 < (the_ELabel_of G).(W.(n+1))) by HEYTING3:1;
    end;
    hence W is augmenting by Def12;
  end;
end;

registration let G be real-weighted real-elabeled WEGraph;
  cluster vertex-distinct augmenting Path of G;
  existence proof
    consider P being trivial Path of G;
    take P;
    thus thesis;
  end;
end;

registration let G be real-weighted real-elabeled WEGraph,
                 W be augmenting Walk of G, m,n be Element of NAT;
  cluster W.cut(m,n) -> augmenting;
  coherence proof
    set W2 = W.cut(m,n);
     now per cases;
      suppose
    A1: (m is odd & n is odd & m <= n & n <= len W);
        then reconsider m'=m as odd Element of NAT;
         now let x be odd Element of NAT; assume x < len W2;
        then A2: x in dom W2 & x+1 in dom W2 & x+2 in dom W2 by GLIB_001:13;
            set v1b = W2.x, eb = W2.(x+1), v2b = W2.(x+2);
        A3: W2.x = W.(m+x-1) & (m+x-1) in dom W &
            W2.(x+1) = W.(m+(x+1)-1) & (m+(x+1)-1) in dom W &
            W2.(x+2) = W.(m+(x+2)-1) & (m+(x+2)-1) in dom W
              by A1,A2,GLIB_001:48;
            then reconsider a = m'+x-1,a1 = m+(x+1)-1,a2=m+(x+2)-1
            as Element of NAT;
            reconsider a as odd Element of NAT;
            set v1a = W.a, ea = W.(a+1), v2a = W.(a+2);
             a2 <= len W by A3,FINSEQ_3:27;
        then A4: m+(x+2)-1-2 < len W - 0 by REAL_1:92;
            hereby assume eb DJoins v1b,v2b,G;
                then ea DJoins v1a,v2a,G by A3;
                hence (the_ELabel_of G).eb < (the_Weight_of G).eb
                  by A3,A4,Def12;
            end;
            assume not eb DJoins v1b,v2b,G;
            then not ea DJoins v1a,v2a,G by A3;
            hence 0 < (the_ELabel_of G).eb by A3,A4,Def12;
        end;
        hence thesis by Def12;
      end;
      suppose not (m is odd & n is odd & m <= n & n <= len W);
        hence thesis by GLIB_001:def 11;
      end;
    end;
   hence thesis;
  end;
end;

theorem ::tWAUGMENT01
   for G1,G2 being real-weighted real-elabeled WEGraph, W1 being Walk of G1,
      W2 being Walk of G2
   st W1 is augmenting & G1 == G2 & the_Weight_of G1 = the_Weight_of G2 &
      the_ELabel_of G1 = the_ELabel_of G2 & W1 = W2 holds
      W2 is augmenting proof
    let G1,G2 be real-weighted real-elabeled WEGraph, W1 be Walk of G1,
        W2 be Walk of G2; assume
A1: W1 is augmenting & G1 == G2 & the_Weight_of G1 = the_Weight_of G2 &
    the_ELabel_of G1 = the_ELabel_of G2 & W1 = W2;
    let n be odd Element of NAT; assume
     n < len W2;
    then (W2.(n+1) DJoins W2.n, W2.(n+2), G1 implies
       (the_ELabel_of G2).(W2.(n+1)) < (the_Weight_of G2).(W2.(n+1))) &
     (not W2.(n+1) DJoins W2.n, W2.(n+2), G1 implies
       0 < (the_ELabel_of G2).(W2.(n+1))) by A1,Def12;
    hence thesis by A1,GLIB_000:91;
end;

theorem Th2: ::tWAUGMENT02
  for G being real-weighted real-elabeled WEGraph,
      W being augmenting Walk of G, e,v being set
   st not v in W.vertices() &
      ((e DJoins W.last(),v,G & (the_ELabel_of G).e < (the_Weight_of G).e) or
       (e DJoins v,W.last(),G & 0 < (the_ELabel_of G).e))
   holds W.addEdge(e) is augmenting proof
    let G be real-weighted real-elabeled WEGraph,
        W be augmenting Walk of G, e,v be set;
    set W2 = W.addEdge(e); assume
A1: not v in W.vertices() &
    ((e DJoins W.last(),v,G & (the_ELabel_of G).e < (the_Weight_of G).e) or
     (e DJoins v,W.last(),G & 0 < (the_ELabel_of G).e));
    let n be odd Element of NAT; assume
A2: n < len W2;
A3: e Joins W.last(),v,G by A1,GLIB_000:19;
     now per cases;
      suppose
    A4: n < len W;
        then n in dom W & n+1 in dom W & n+2 in dom W by GLIB_001:13;
        then W.n = W2.n & W.(n+1) = W2.(n+1) & W.(n+2) = W2.(n+2)
          by A3,GLIB_001:66;
        hence (W2.(n+1) DJoins W2.n, W2.(n+2), G implies
          (the_ELabel_of G).(W2.(n+1)) < (the_Weight_of G).(W2.(n+1))) &
        (not W2.(n+1) DJoins W2.n, W2.(n+2),G implies
          0 < (the_ELabel_of G).(W2.(n+1))) by A4,Def12;
      end;
      suppose
    A5: n >= len W;
         n+1 <= len W2 by A2,NAT_1:13;
        then n+1 <= len W + 2*1 by A3,GLIB_001:65;
        then n+1 < len W + 1+1 by REAL_1:def 5;
        then n+1 <= len W + 1 by NAT_1:13;
        then n <= len W by XREAL_1:8;
    then A6: 1 <= n & n = len W by A5,HEYTING3:1,XXREAL_0:1;
        then n in dom W by FINSEQ_3:27;
    then A7: W2.n = W.n by A3,GLIB_001:66
            .= W.last() by A6,GLIB_001:def 7;
    A8: W2.(n+1) = e & W2.(n+2) = v by A3,A6,GLIB_001:66;
     now assume e DJoins W.last(),v,G & e DJoins v,W.last(),G;
            then (the_Source_of G).e = W.last() &
              (the_Source_of G).e = v by GLIB_000:def 16;
            hence contradiction by A1,GLIB_001:89;
        end;
        hence W2.(n+1) DJoins W2.n, W2.(n+2),G implies
          (the_ELabel_of G).(W2.(n+1)) < (the_Weight_of G).(W2.(n+1))
          by A1,A7,A8;
        assume not W2.(n+1) DJoins W2.n, W2.(n+2),G;
        hence 0 < (the_ELabel_of G).(W2.(n+1)) by A1,A7,A8;
      end;
    end;
    hence thesis;
end;

begin :: Finding an Augmenting Path in a Graph
definition let G be real-weighted real-elabeled WEVGraph;
  func AP:NextBestEdges(G) -> Subset of the_Edges_of G means :Def13: ::dAPNEXT
     for e being set holds e in it iff
     (e is_forward_labeling_in G or e is_backward_labeling_in G);
  existence proof
    defpred P[set] means $1 is_forward_labeling_in G or
                         $1 is_backward_labeling_in G;
    consider IT being Subset of the_Edges_of G such that
A1: for e being set holds e in IT iff e in the_Edges_of G & P[e]
      from SUBSET_1:sch 1;
    take IT;
    let e be set;
    thus e in IT implies P[e] by A1;
    assume
A2: P[e];
    then e in the_Edges_of G by Def10,Def11;
    hence e in IT by A1,A2;
  end;
  uniqueness proof
    let IT1,IT2 be Subset of the_Edges_of G such that
A3: for e being set holds e in IT1 iff
    (e is_forward_labeling_in G or e is_backward_labeling_in G) and
A4: for e being set holds e in IT2 iff
    (e is_forward_labeling_in G or e is_backward_labeling_in G);
     now let e be set;
        hereby assume e in IT1;
            then (e is_forward_labeling_in G or e is_backward_labeling_in G)
by A3;
            hence e in IT2 by A4;
        end;
        assume e in IT2;
        then (e is_forward_labeling_in G or e is_backward_labeling_in G) by A4
;
        hence e in IT1 by A3;
    end;
    hence IT1 = IT2 by TARSKI:2;
  end;
end;

definition let G be real-weighted real-elabeled WEVGraph;
  func AP:Step(G) -> real-weighted real-elabeled WEVGraph equals :Def14:
     G if AP:NextBestEdges(G) = {},
     G.labelVertex((the_Source_of G).(choose AP:NextBestEdges(G)),
       choose AP:NextBestEdges(G)) if
          AP:NextBestEdges(G) <> {} &
          not (the_Source_of G).(choose AP:NextBestEdges(G)) in G.labeledV()
            otherwise
     G.labelVertex((the_Target_of G).(choose AP:NextBestEdges(G)),
       choose AP:NextBestEdges(G));
  coherence;
  consistency;
end;

registration let G be finite real-weighted real-elabeled WEVGraph;
  cluster AP:Step(G) -> finite;
  coherence proof
    set e = choose AP:NextBestEdges(G), G2 = AP:Step(G);
     now per cases;
      suppose AP:NextBestEdges(G) = {};
        hence thesis by Def14;
      end;
      suppose AP:NextBestEdges(G) <> {} &
          not (the_Source_of G).e in G.labeledV();
        then G2 = G.labelVertex((the_Source_of G).e, e) by Def14;
        hence thesis;
      end;
      suppose AP:NextBestEdges(G)<>{} &
        (the_Source_of G).e in G.labeledV();
        then G2 = G.labelVertex((the_Target_of G).e, e) by Def14;
        hence thesis;
      end;
   end;
   hence thesis;
  end;
end;

registration let s be real-weighted WEVGraphSeq, n be Nat;
 cluster s.n -> real-weighted WEVGraph;
 coherence by GLIB_003:def 27;
end;

registration let s be real-elabeled WEVGraphSeq, n be Nat;
 cluster s.n -> real-elabeled WEVGraph;
 coherence by GLIB_003:def 29;
end;

definition let G be real-weighted real-elabeled WEGraph, source be Vertex of G;
  func AP:CompSeq(G,source) -> real-weighted real-elabeled WEVGraphSeq means
:Def15: ::dAPCS
    it.0 = G.set(VLabelSelector, source .--> 1) &
    for n being Element of NAT holds it.(n+1) = AP:Step(it.n);
  existence proof
    defpred P[set,set,set] means
      ($2 is real-weighted real-elabeled WEVGraph &
        ex Gn,Gn1 being real-weighted real-elabeled WEVGraph st
          $2 = Gn & $3 = Gn1 & Gn1 = AP:Step(Gn)) or
      (not $2 is real-weighted real-elabeled WEVGraph & $2 = $3);
     now let n,x be set;
         now per cases;
          suppose
             x is real-weighted real-elabeled WEVGraph;
            then reconsider Gn=x as real-weighted real-elabeled WEVGraph;
             P[n,x,AP:Step(Gn)];
            hence ex y being set st P[n,x,y];
          end;
          suppose not x is real-weighted real-elabeled WEVGraph;
            hence ex y being set st P[n,x,y];
          end;
        end;
        hence ex y being set st P[n,x,y];
    end;
then A1: for n being Element of NAT for x being set ex y being set st P[n,x,y];
A2: for n being Element of NAT for x,y1,y2 being set st P[n,x,y1] & P[n,x,y2]
      holds y1 = y2;
    consider IT being Function such that
A3: dom IT = NAT & IT.0 = G.set(VLabelSelector, source.-->1) &
    for n being Element of NAT holds P[n,IT.n,IT.(n+1)]
      from RECDEF_1:sch 1(A1,A2);
    reconsider IT as ManySortedSet of NAT by A3,PBOOLE:def 3;
    defpred P2[Nat] means IT.$1
    is real-weighted real-elabeled WEVGraph;
A4: P2[0] by A3;
A5: now let n be Nat;
A6:  n in NAT by ORDINAL1:def 13;
      assume P2[n];
        then consider Gn,Gn1 being real-weighted real-elabeled WEVGraph such
that
    A7: IT.n = Gn & IT.(n+1) = Gn1 & Gn1 = AP:Step(Gn) by A3,A6;
        thus P2[n+1] by A7;
    end;
A8: for n being Nat holds P2[n] from NAT_1:sch 2(A4,A5);
    then for n being Nat holds IT.n is _Graph;
    then reconsider IT as GraphSeq by GLIB_000:def 55;
     for n being Nat holds
      IT.n is [Weighted] & IT.n is [ELabeled] & IT.n is [VLabeled] by A8;
    then reconsider IT as WEVGraphSeq
      by GLIB_003:def 24,def 25,def 26;
     for n being Nat holds IT.n is real-weighted &
      IT.n is real-elabeled by A8;
    then reconsider IT as real-weighted real-elabeled WEVGraphSeq
      by GLIB_003:def 27,def 29;
    take IT;
    thus IT.0 = G.set(VLabelSelector,source.-->1) by A3;
    let n be Element of NAT;
      ex Gn,Gn1 being real-weighted real-elabeled WEVGraph st
      IT.n = Gn & IT.(n+1) = Gn1 & Gn1 = AP:Step(Gn) by A3;
    hence IT.(n+1) = AP:Step(IT.n);
end;
  uniqueness proof
    let IT1,IT2 be real-weighted real-elabeled WEVGraphSeq such that
A9: IT1.0 = G.set(VLabelSelector, source.-->1) &
    for n being Element of NAT holds IT1.(n+1) = AP:Step(IT1.n) and
A10: IT2.0 = G.set(VLabelSelector, source.-->1) &
    for n being Element of NAT holds IT2.(n+1) = AP:Step(IT2.n);
    defpred P[Element of NAT] means IT1.$1 = IT2.$1;
A11: P[0] by A9,A10;
     now let n be Element of NAT; assume P[n];
        then IT1.(n+1) = AP:Step(IT2.n) by A9
                   .= IT2.(n+1) by A10;
        hence P[n+1];
    end;
then A12: for n being Element of NAT st P[n] holds P[n+1];
     for n being Element of NAT holds P[n] from NAT_1:sch 1(A11,A12);
    then for n being set st n in NAT holds IT1.n = IT2.n;
    hence IT1 = IT2 by PBOOLE:3;
  end;
end;

registration let G be finite real-weighted real-elabeled WEGraph,
               source be Vertex of G;
  cluster AP:CompSeq(G,source) -> finite;
  coherence proof
    set CS = AP:CompSeq(G,source);
    defpred P[Nat] means CS.$1 is finite;
     CS.0 = G.set(VLabelSelector,source.-->1) &
    for n being Element of NAT holds CS.(n+1) = AP:Step(CS.n) by Def15;
    then A1: P[0];
A2: now let n be Element of NAT; assume P[n];
        then reconsider Gn = CS.n as finite real-weighted real-elabeled
WEVGraph;
         CS.(n+1) = AP:Step(Gn) by Def15;
        hence P[n+1];
    end;
A3: for n being Element of NAT holds P[n] from NAT_1:sch 1(A1,A2);
     for n being Nat holds P[n]
    proof
      let n be Nat;  n in NAT by ORDINAL1:def 13;
      hence thesis by A3;
    end;
    hence thesis by GLIB_000:def 60;
  end;
end;

theorem Th3: ::tAPCS01
  for G being real-weighted real-elabeled WEGraph,
      source being Vertex of G holds
     G == AP:CompSeq(G,source).0 &
     the_Weight_of G = the_Weight_of (AP:CompSeq(G,source).0) &
     the_ELabel_of G = the_ELabel_of (AP:CompSeq(G,source).0) &
     (AP:CompSeq(G,source).0).labeledV() = {source} proof
    let G be real-weighted real-elabeled WEGraph, source be Vertex of G;
    set G0 = AP:CompSeq(G,source).0;
A1: G0 = G.set(VLabelSelector, source .--> 1) by Def15;
    hence G == G0 by GLIB_003:8;
    thus the_Weight_of G = the_Weight_of G0 by A1,GLIB_000:12;
    thus the_ELabel_of G = the_ELabel_of G0 by A1,GLIB_000:12;
 the_VLabel_of G0 = source .--> 1 by A1,GLIB_000:11;
    hence G0.labeledV() = {source} by FUNCOP_1:19;
end;

theorem Th4: ::tAPCS02
  for G being real-weighted real-elabeled WEGraph,
      source being Vertex of G, i,j being Element of NAT
   st i <= j holds (AP:CompSeq(G,source).i).labeledV() c=
                   (AP:CompSeq(G,source).j).labeledV() proof
    let G be real-weighted real-elabeled WEGraph, source be Vertex of G,
        i,j be Element of NAT; set CS = AP:CompSeq(G,source); assume
A1: i <= j;
    defpred P[Element of NAT] means
     (CS.i).labeledV() c= (CS.(i+$1)).labeledV();
A2: P[0];
A3: now let n be Element of NAT; set Gn = (CS.(i+n)), Gn1 = (CS.(i+(n+1)));
        set Next = AP:NextBestEdges(Gn), e = choose Next; assume
    A4: P[n];
         Gn1 = (CS.(i+n+1));
    then A5: Gn1 = AP:Step(Gn) by Def15;
         now per cases;
          suppose Next = {};
            hence P[n+1] by A4,A5,Def14;
          end;
          suppose
        A6: Next <> {} & not (the_Source_of Gn).e in Gn.labeledV();
            then e in Next;
        then A7: (the_Source_of Gn).e in the_Vertices_of Gn by FUNCT_2:7;
             Gn1 = Gn.labelVertex((the_Source_of Gn).e, e) by A5,A6,Def14;
            then Gn.labeledV() c= Gn1.labeledV() by A7,GLIB_003:60;
            hence P[n+1] by A4,XBOOLE_1:1;
          end;
          suppose
        A8: Next <> {} & (the_Source_of Gn).e in Gn.labeledV();
            then e in Next;
        then A9: (the_Target_of Gn).e in the_Vertices_of Gn by FUNCT_2:7;
             Gn1 = Gn.labelVertex((the_Target_of Gn).e, e) by A5,A8,Def14;
            then Gn.labeledV() c= Gn1.labeledV() by A9,GLIB_003:60;
            hence P[n+1] by A4,XBOOLE_1:1;
          end;
        end;
        hence P[n+1];
    end;
A10: for n being Element of NAT holds P[n] from NAT_1:sch 1(A2,A3);
    consider k being Nat such that
A11: j = i+k by A1,NAT_1:10;
      k in NAT by ORDINAL1:def 13;
     hence thesis by A10,A11;
end;

theorem Th5: ::tAPCS04
   for G being real-weighted real-elabeled WEGraph,
       source being Vertex of G, n being Element of NAT holds
     G == AP:CompSeq(G,source).n &
     the_Weight_of G = the_Weight_of (AP:CompSeq(G,source).n) &
     the_ELabel_of G = the_ELabel_of (AP:CompSeq(G,source).n) proof
    let G be real-weighted real-elabeled WEGraph,
        source be Vertex of G; set CS = AP:CompSeq(G,source);
    defpred P[Element of NAT] means CS.$1 == G &
      the_Weight_of (CS.$1) = the_Weight_of G &
      the_ELabel_of (CS.$1) = the_ELabel_of G;
A1: P[0] by Th3;
A2: now let n be Element of NAT; assume
    A3: P[n]; set Gn = CS.n, Gn1 = CS.(n+1);
        set Next = AP:NextBestEdges(Gn), e = choose Next;
    A4: Gn1 = AP:Step(Gn) by Def15;
         now per cases;
          suppose Next = {};
            hence P[n+1] by A3,A4,Def14;
          end;
          suppose Next <> {} & not (the_Source_of Gn).e in Gn.labeledV();
        then A5: Gn1 = Gn.labelVertex((the_Source_of Gn).e,e) by A4,Def14;
            then Gn1 == Gn by GLIB_003:47;
            hence P[n+1] by A3,A5,GLIB_000:88,GLIB_003:48,49;
          end;
          suppose Next <> {} & (the_Source_of Gn).e in Gn.labeledV();
        then A6: Gn1 = Gn.labelVertex((the_Target_of Gn).e,e) by A4,Def14;
            then Gn1 == Gn by GLIB_003:47;
            hence P[n+1] by A3,A6,GLIB_000:88,GLIB_003:48,49;
          end;
        end;
        hence P[n+1];
    end;
     for n being Element of NAT holds P[n] from NAT_1:sch 1(A1,A2);
    hence thesis;
end;

definition let G be real-weighted real-elabeled WEGraph, source be Vertex of G;
  func AP:FindAugPath(G,source) -> real-weighted real-elabeled WEVGraph equals
 ::dAPFAUGP
     AP:CompSeq(G,source).Result();
  coherence proof
    set CS = AP:CompSeq(G,source);
     CS.Result() = CS.(CS.Lifespan());
    hence thesis;
  end;
end;

theorem Th6: ::tAPFAP01
  for G being finite real-weighted real-elabeled WEGraph,
      source being Vertex of G
    holds AP:CompSeq(G,source) is halting proof
    let G be finite real-weighted real-elabeled WEGraph, source be Vertex of G;
    set CS = AP:CompSeq(G,source);
     now assume
    A1: for n being Element of NAT holds CS.n <> CS.(n+1);
        defpred P[Element of NAT] means card (CS.$1).labeledV() = $1+1;
         (CS.0).labeledV() = {source} by Th3;
    then A2: P[0] by CARD_1:79;
    A3: now let n be Element of NAT; assume
        A4: P[n];
            set Gn = CS.n, Gn1 = CS.(n+1);
        A5: Gn1 = AP:Step(Gn) by Def15;
            set Next = AP:NextBestEdges(Gn), e = choose Next;
             now per cases;
              suppose Next = {};
                 then Gn = CS.(n+1) by A5,Def14;
                 hence P[n+1] by A1;
              end;
              suppose
            A6: Next <> {} & not (the_Source_of Gn).e in Gn.labeledV();
            then A7: Gn1 = Gn.labelVertex((the_Source_of Gn).e,e) by A5,Def14;
                 e in Next by A6;
                then (the_Source_of Gn).e in the_Vertices_of Gn by FUNCT_2:7;
                hence P[n+1] by A4,A6,A7,GLIB_003:61;
              end;
              suppose
              A8: Next <> {} & (the_Source_of Gn).e in Gn.labeledV();
              then A9: Gn1 = Gn.labelVertex((the_Target_of Gn).e,e) by A5,Def14
;
              A10: e in Next by A8;
                   e is_forward_labeling_in Gn or e is_backward_labeling_in Gn
                    by A8,Def13;
              then A11: not (the_Target_of Gn).e in Gn.labeledV()
                    by A8,Def10,Def11;
                   (the_Target_of Gn).e in the_Vertices_of Gn
                    by A10,FUNCT_2:7;
                  hence P[n+1] by A4,A9,A11,GLIB_003:61;
              end;
            end;
            hence P[n+1];
        end;
    A12: for n being Element of NAT holds P[n] from NAT_1:sch 1(A2,A3);
        set x = card the_Vertices_of G;
    A13: card (CS.x).labeledV() = card the_Vertices_of G + 1 by A12;
         (CS.x) == G by Th5;
        then the_Vertices_of G = the_Vertices_of (CS.x) by GLIB_000:def 36;
        then 1+card the_Vertices_of G<=card the_Vertices_of G+0 by A13,NAT_1:44
;
        hence contradiction by XREAL_1:8;
    end;
    hence CS is halting by GLIB_000:def 56;
end;

theorem Th7: ::tAPCS05
  for G being finite real-weighted real-elabeled WEGraph,
      source being Vertex of G, n being Element of NAT, v being set
      st v in (AP:CompSeq(G,source).n).labeledV() holds
      (the_VLabel_of (AP:CompSeq(G,source).n)).v =
      (the_VLabel_of AP:FindAugPath(G,source)).v proof
    let G be finite real-weighted real-elabeled WEGraph,source be Vertex of G,
        n be Element of NAT, v be set;
    set CS = AP:CompSeq(G,source), FAP = AP:FindAugPath(G,source);
    set L = CS.Lifespan(), GL = CS.L, GL1 = CS.(L+1); assume
A1: v in (CS.n).labeledV();
    defpred P[Element of NAT] means
      for v being set st v in (CS.n).labeledV() holds
        (the_VLabel_of (CS.n)).v = (the_VLabel_of (CS.(n+$1))).v;
A2: P[0];
     now let k be Element of NAT; assume
    A3: P[k]; set Gn = CS.(n+k), Gn1 = CS.(n+k+1);
    A4: Gn1 = AP:Step(Gn) by Def15;
        set Next = AP:NextBestEdges(Gn), e = choose Next;
         now per cases;
          suppose Next = {};
            then Gn1 = Gn by A4,Def14;
            hence P[k+1] by A3;
          end;
          suppose
        A5: Next <> {} & not (the_Source_of Gn).e in Gn.labeledV();
        then A6: Gn1 = Gn.labelVertex((the_Source_of Gn).e, e) by A4,Def14;
             now let v be set; assume
            A7: v in (CS.n).labeledV();
            then A8: (the_VLabel_of (CS.n)).v = (the_VLabel_of Gn).v by A3;
                 n <= n+k by NAT_1:11;
                then (CS.n).labeledV() c= Gn.labeledV() by Th4;
                then v <> (the_Source_of Gn).e by A5,A7;
                hence (the_VLabel_of (CS.n)).v = (the_VLabel_of Gn1).v
                  by A6,A8,GLIB_003:50;
            end;
            hence P[k+1];
          end;
          suppose
        A9: Next <> {} & (the_Source_of Gn).e in Gn.labeledV();
        then A10: Gn1 = Gn.labelVertex((the_Target_of Gn).e, e) by A4,Def14;
        A11: e is_forward_labeling_in Gn or e is_backward_labeling_in Gn
              by A9,Def13;
             now let v be set; assume
            A12: v in (CS.n).labeledV();
            then A13: (the_VLabel_of (CS.n)).v = (the_VLabel_of Gn).v by A3;
                 n <= n+k by NAT_1:11;
                then (CS.n).labeledV() c= Gn.labeledV() by Th4;
                then v <> (the_Target_of Gn).e by A9,A11,A12,Def10,Def11;
                hence (the_VLabel_of (CS.n)).v = (the_VLabel_of Gn1).v
                  by A10,A13,GLIB_003:50;
            end;
            hence P[k+1];
          end;
        end;
        hence P[k+1];
    end;
then A14: for k being Element of NAT st P[k] holds P[k+1];
A15: for k being Element of NAT holds P[k] from NAT_1:sch 1(A2,A14);
    A16: CS is halting by Th6;
    defpred P2[Element of NAT] means GL = CS.(L+$1);
A17: P2[0];
A18: now let k be Element of NAT; set Gn1 = CS.(L+k+1); assume P2[k];
        then Gn1 = AP:Step(GL) by Def15
           .= GL1 by Def15;
        hence P2[k+1] by A16,GLIB_000:def 57;
    end;
A19: for k being Element of NAT holds P2[k] from NAT_1:sch 1(A17,A18);
     now per cases;
      suppose n <= CS.Lifespan(); then consider k being Nat
      such that
    A20: n + k = CS.Lifespan() by NAT_1:10;
    reconsider k as Element of NAT by ORDINAL1:def 13;
     n + k = CS.Lifespan() by A20;
    hence thesis by A1,A15;
      end;
      suppose CS.Lifespan() < n; then consider k being Nat such that
    A21: CS.Lifespan() + k = n by NAT_1:10;
    reconsider k as Element of NAT by ORDINAL1:def 13;
     CS.Lifespan() + k = n by A21;
        hence thesis by A19;
      end;
    end;
    hence thesis;
end;

definition let G be finite real-weighted real-elabeled WEGraph,
               source,sink be Vertex of G;
  func AP:GetAugPath(G,source,sink) -> vertex-distinct
                                       augmenting Path of G means :Def17
: ::dAPGETAUG
    it is_Walk_from source,sink &
    for n being even Element of NAT st n in dom it holds
      it.n = (the_VLabel_of AP:FindAugPath(G,source)).(it.(n+1)) if
    (sink in AP:FindAugPath(G,source).labeledV()) otherwise
    it = G.walkOf(source);
  existence proof
    set CS = AP:CompSeq(G,source), FAP = AP:FindAugPath(G,source);
    defpred P[Element of NAT] means
      for v being set st v in (CS.$1).labeledV() holds
       ex P being vertex-distinct augmenting Path of G st
          P is_Walk_from source,v &
          P.vertices() c= (CS.$1).labeledV() &
          for n being even Element of NAT st n in dom P holds
            P.n = (the_VLabel_of FAP).(P.(n+1));
     now let v be set; assume v in (CS.0).labeledV();
        then v in {source} by Th3;
    then A1: v = source by TARSKI:def 1;
        set P = G.walkOf(source);
        take P;
        thus P is_Walk_from source,v by A1,GLIB_001:14;
         P.vertices() = {source} by GLIB_001:91;
        hence P.vertices() c= (CS.0).labeledV() by Th3;
        let n be even Element of NAT; assume n in dom P;
    then A2: 1 <= n & n <= len P by FINSEQ_3:27;
        then n < len P by REAL_1:def 5;
        hence P.n = (the_VLabel_of FAP).(P.(n+1)) by A2,GLIB_001:14;
    end;
then A3: P[0];
     now let n be Element of NAT; assume
    A4: P[n]; set Gn = CS.n, Gn1 = CS.(n+1);
        set Next = AP:NextBestEdges(Gn), e = choose Next;
    A5: Gn1 = AP:Step(Gn) by Def15;
    A6: Gn == G & the_ELabel_of Gn = the_ELabel_of G &
          the_Weight_of Gn = the_Weight_of G by Th5;
         now per cases;
          suppose Next = {};
             then Gn1 = Gn by A5,Def14;
            hence P[n+1] by A4;
          end;
          suppose
        A7: Next <> {} & not (the_Source_of Gn).e in Gn.labeledV();
        then A8: Gn1 = Gn.labelVertex((the_Source_of Gn).e, e) by A5,Def14;
        A9: e in Next by A7;
             e is_forward_labeling_in Gn or e is_backward_labeling_in Gn
              by A7,Def13;
        then A10: (the_Target_of Gn).e in Gn.labeledV() &
              0 < (the_ELabel_of Gn).e by A7,Def10,Def11;
        A11: (the_Source_of Gn).e in the_Vertices_of Gn by A9,FUNCT_2:7;
        then A12: Gn1.labeledV() = Gn.labeledV() \/ {(the_Source_of Gn).e}
              by A8,GLIB_003:59;
             now let v be set; assume
            A13: v in Gn1.labeledV();
                 now per cases by A12,A13,XBOOLE_0:def 2;
                  suppose v in Gn.labeledV(); then consider P being
                      vertex-distinct augmenting Path of G such that
                A14: P is_Walk_from source,v & P.vertices() c= Gn.labeledV() &
                    for n being even Element of NAT st n in dom P holds
                    P.n = (the_VLabel_of FAP).(P.(n+1)) by A4;
                    take P;
                     n <= n+1 by NAT_1:11;
                    then Gn.labeledV() c= Gn1.labeledV() by Th4;
                    hence P is_Walk_from source,v &
                      P.vertices()c= Gn1.labeledV() &
                      for n being even Element of NAT st n in dom P holds
                        P.n = (the_VLabel_of FAP).(P.(n+1)) by A14,XBOOLE_1:1;
                  end;
                  suppose
                A15: v in {(the_Source_of Gn).e};
                then A16: v = (the_Source_of Gn).e by TARSKI:def 1;
                     now               consider W being vertex-distinct
                                         augmenting Path of G such that
                    A17: W is_Walk_from source, (the_Target_of Gn).e &
                        W.vertices() c= Gn.labeledV() &
                        for n being even Element of NAT st n in dom W holds
                          W.n = (the_VLabel_of FAP).(W.(n+1)) by A4,A10;
                        set W2 = W.addEdge(e);
                    A18: W.first() = source & W.last() = (the_Target_of Gn).e
                          by A17,GLIB_001:def 23;
                        then e Joins W.last(),(the_Source_of Gn).e,Gn
                          by A9,GLIB_000:def 15;
                    then A19: e Joins W.last(),(the_Source_of Gn).e,G
                          by A6,GLIB_000:91;
                    A20: not (the_Source_of Gn).e in W.vertices() by A7,A17;
then reconsider W2 as vertex-distinct Walk of G
                          by A19,GLIB_001:156;
                         e DJoins (the_Source_of Gn).e,W.last(),Gn
                          by A9,A18,GLIB_000:def 16;
                        then e DJoins (the_Source_of Gn).e,W.last(),G
                          by A6,GLIB_000:91;
                        then reconsider W2 as augmenting vertex-distinct Path
of G
                          by A6,A10,A20,Th2;
                        take W2;
                        thus W2 is_Walk_from source,v by A16,A18,A19,
GLIB_001:64;
                    A21: W2.vertices() = W.vertices() \/ {v}
                          by A16,A19,GLIB_001:96;
                         now let x be set; assume
                        A22: x in W2.vertices();
                             now per cases by A21,A22,XBOOLE_0:def 2;
                              suppose x in W.vertices();
                            then A23: x in Gn.labeledV() by A17;
                                 n <= n+1 by NAT_1:11;
                                then Gn.labeledV() c= Gn1.labeledV() by Th4;
                                hence x in Gn1.labeledV() by A23;
                              end;
                              suppose x in {v};
                                hence x in Gn1.labeledV()
                                  by A12,A16,XBOOLE_0:def 2;
                              end;
                            end;
                            hence x in Gn1.labeledV();
                        end;
                        hence W2.vertices() c= Gn1.labeledV() by TARSKI:def 3;
                        let n be even Element of NAT; assume
                         n in dom W2;
                    then A24: 1 <= n & n <= len W2 by FINSEQ_3:27;
                         now per cases;
                          suppose
                        A25: n <= len W;
                        then A26: n in dom W by A24,FINSEQ_3:27;
                        then A27: W2.n = W.n by A19,GLIB_001:66;
                             n < len W by A25,REAL_1:def 5;
                        then A28: n+1 <= len W by NAT_1:13;
                             1 <= 1+n by NAT_1:11;
                            then n+1 in dom W by A28,FINSEQ_3:27;
                            then W2.(n+1) = W.(n+1) by A19,GLIB_001:66;
                            hence W2.n = (the_VLabel_of FAP).(W2.(n+1))
                              by A17,A26,A27;
                          end;
                          suppose n > len W;
                        then A29: len W + 1 <= n by NAT_1:13;
                             n <= len W + 2*1 by A19,A24,GLIB_001:65;
                            then n < len W + 1+1 by REAL_1:def 5;
                            then n <= len W + 1 by NAT_1:13;
                        then n = len W + 1 by A29,XXREAL_0:1;
                            then n+1 = len W + (1+1);
                        then A30: W2.n = e & W2.(n+1) = v by A16,A19,A29,
GLIB_001:66;
                        A31: v in Gn1.labeledV()
                              by A12,A15,XBOOLE_0:def 2;
                             (the_VLabel_of Gn1).v = e
                              by A8,A11,A16,GLIB_003:46;
                            hence W2.n = (the_VLabel_of FAP).(W2.(n+1))
                              by A30,A31,Th7;
                          end;
                        end;
                        hence W2.n = (the_VLabel_of FAP).(W2.(n+1));
                      end;
                    hence ex P being vertex-distinct augmenting Path of G st
                      P is_Walk_from source,v & P.vertices() c=Gn1.labeledV() &
                      for n being even Element of NAT st n in dom P holds
                      P.n = (the_VLabel_of FAP).(P.(n+1));
                  end;
                end;
                hence ex P being vertex-distinct augmenting Path of G st
                  P is_Walk_from source,v & P.vertices() c=Gn1.labeledV() &
                  for n being even Element of NAT st n in dom P holds
                    P.n = (the_VLabel_of FAP).(P.(n+1));
            end;
            hence P[n+1];
          end;
          suppose
        A32: Next <> {} & (the_Source_of Gn).e in Gn.labeledV();
        then A33: Gn1 = Gn.labelVertex((the_Target_of Gn).e, e) by A5,Def14;
        A34: e in Next by A32;
        A35: e is_forward_labeling_in Gn or e is_backward_labeling_in Gn
              by A32,Def13;
        then A36: not (the_Target_of Gn).e in Gn.labeledV() &
              (the_ELabel_of Gn).e < (the_Weight_of Gn).e
              by A32,Def10,Def11;
        A37: (the_Target_of Gn).e in the_Vertices_of Gn by A34,FUNCT_2:7;
        then A38: Gn1.labeledV() = Gn.labeledV() \/ {(the_Target_of Gn).e}
              by A33,GLIB_003:59;
             now let v be set; assume
            A39: v in Gn1.labeledV();
                 now per cases by A38,A39,XBOOLE_0:def 2;
                  suppose v in Gn.labeledV();
                    then consider P being vertex-distinct
                                     augmenting Path of G such that
                A40: P is_Walk_from source,v & P.vertices() c= Gn.labeledV() &
                    for n being even Element of NAT st n in dom P holds
                      P.n = (the_VLabel_of FAP).(P.(n+1)) by A4;
                    take P;
                     n <= n+1 by NAT_1:11;
                    then Gn.labeledV() c= Gn1.labeledV() by Th4;
                    hence P is_Walk_from source,v &
                      P.vertices()c= Gn1.labeledV() &
                      for n being even Element of NAT st n in dom P holds
                        P.n = (the_VLabel_of FAP).(P.(n+1)) by A40,XBOOLE_1:1;
                  end;
                  suppose
                A41: v in {(the_Target_of Gn).e};
                then A42: v = (the_Target_of Gn).e by TARSKI:def 1;
                     now consider W being vertex-distinct
                                  augmenting Path of G such that
                    A43: W is_Walk_from source, (the_Source_of Gn).e &
                        W.vertices() c= Gn.labeledV() &
                        for n being even Element of NAT st n in dom W holds
                          W.n = (the_VLabel_of FAP).(W.(n+1)) by A4,A32;
                        set W2 = W.addEdge(e);
                    A44: W.first() = source & W.last() = (the_Source_of Gn).e
                          by A43,GLIB_001:def 23;
                        then e Joins W.last(),(the_Target_of Gn).e,Gn
                          by A34,GLIB_000:def 15;
                    then A45: e Joins W.last(),(the_Target_of Gn).e,G
                          by A6,GLIB_000:91;
                    A46: not (the_Target_of Gn).e in W.vertices()
                          by A32,A35,A43,Def10,Def11;
                        then reconsider W2 as vertex-distinct Walk of G
                          by A45,GLIB_001:156;
                         e DJoins W.last(),(the_Target_of Gn).e,Gn
                          by A34,A44,GLIB_000:def 16;
                        then e DJoins W.last(),(the_Target_of Gn).e,G
                          by A6,GLIB_000:91;
                        then reconsider W2 as vertex-distinct augmenting Path
of G
                          by A6,A36,A46,Th2;
                        take W2;
                        thus W2 is_Walk_from source,v by A42,A44,A45,
GLIB_001:64;
                    A47: W2.vertices() = W.vertices() \/ {v}
                          by A42,A45,GLIB_001:96;
                         now let x be set; assume
                        A48: x in W2.vertices();
                             now per cases by A47,A48,XBOOLE_0:def 2;
                              suppose x in W.vertices();
                            then A49: x in Gn.labeledV() by A43;
                                 n <= n+1 by NAT_1:11;
                                then Gn.labeledV() c= Gn1.labeledV() by Th4;
                                hence x in Gn1.labeledV() by A49;
                              end;
                              suppose x in {v};
                                hence x in Gn1.labeledV()
                                  by A38,A42,XBOOLE_0:def 2;
                              end;
                            end;
                            hence x in Gn1.labeledV();
                        end;
                        hence W2.vertices() c= Gn1.labeledV() by TARSKI:def 3;
                        let n be even Element of NAT; assume
                         n in dom W2;
                    then A50: 1 <= n & n <= len W2 by FINSEQ_3:27;
                         now per cases;
                          suppose
                        A51: n <= len W;
                        then A52: n in dom W by A50,FINSEQ_3:27;
                        then A53: W2.n = W.n by A45,GLIB_001:66;
                             n < len W by A51,REAL_1:def 5;
                        then A54: n+1 <= len W by NAT_1:13;
                             1 <= 1+n by NAT_1:11;
                            then n+1 in dom W by A54,FINSEQ_3:27;
                            then W2.(n+1) = W.(n+1) by A45,GLIB_001:66;
                            hence W2.n = (the_VLabel_of FAP).(W2.(n+1))
                              by A43,A52,A53;
                          end;
                          suppose n > len W;
                        then A55: len W + 1 <= n by NAT_1:13;
                             n <= len W + 2*1 by A45,A50,GLIB_001:65;
                            then n < len W + 1+1 by REAL_1:def 5;
                            then n <= len W + 1 by NAT_1:13;
                        then n = len W + 1 by A55,XXREAL_0:1;
                            then n+1 = len W + (1+1);
                        then A56: W2.n = e & W2.(n+1) = v by A42,A45,A55,
GLIB_001:66;
                        A57: v in Gn1.labeledV()
                              by A38,A41,XBOOLE_0:def 2;
                             (the_VLabel_of Gn1).v = e
                              by A33,A37,A42,GLIB_003:46;
                            hence W2.n = (the_VLabel_of FAP).(W2.(n+1))
                              by A56,A57,Th7;
                          end;
                        end;
                        hence W2.n = (the_VLabel_of FAP).(W2.(n+1));
                      end;
                    hence ex P being vertex-distinct augmenting Path of G st
                      P is_Walk_from source,v & P.vertices() c=Gn1.labeledV() &
                      for n being even Element of NAT st n in dom P holds
                      P.n = (the_VLabel_of FAP).(P.(n+1));
                  end;
                end;
                hence ex P being vertex-distinct augmenting Path of G st
                  P is_Walk_from source,v & P.vertices() c=Gn1.labeledV() &
                  for n being even Element of NAT st n in dom P holds
                    P.n = (the_VLabel_of FAP).(P.(n+1));
            end;
            hence P[n+1];
          end;
        end;
        hence P[n+1];
    end;
then A58: for n being Element of NAT st P[n] holds P[n+1];
A59: for n being Element of NAT holds P[n] from NAT_1:sch 1(A3,A58);
    hereby assume sink in FAP.labeledV();
        then consider W being vertex-distinct augmenting Path of G such that
    A60: W is_Walk_from source,sink & W.vertices() c= FAP.labeledV() &
        for n being even Element of NAT st n in dom W holds
          W.n = (the_VLabel_of FAP).((W.(n+1))) by A59;
        take W;
        thus W is_Walk_from source,sink &
          for n being even Element of NAT st n in dom W holds
            W.n = (the_VLabel_of FAP).((W.(n+1))) by A60;
    end;
    thus thesis;
  end;
  uniqueness proof
    let IT1, IT2 be vertex-distinct augmenting Path of G;
    set FAP = AP:FindAugPath(G,source), CS = AP:CompSeq(G,source);
    defpred P[Element of NAT] means
      for v being set, P1,P2 being vertex-distinct augmenting Path of G st
        v in (CS.$1).labeledV() &
        P1 is_Walk_from source,v &
        P2 is_Walk_from source,v &
        (for n being even Element of NAT st n in dom P1 holds
           P1.n = (the_VLabel_of FAP).(P1.(n+1))) &
        (for n being even Element of NAT st n in dom P2 holds
           P2.n = (the_VLabel_of FAP).(P2.(n+1))) holds P1 = P2;
    set G0 = CS.0;
     now let v be set, P1,P2 be vertex-distinct augmenting Path of G; assume
    A61: v in G0.labeledV() &
        P1 is_Walk_from source,v &
        P2 is_Walk_from source,v &
        (for n being even Element of NAT st n in dom P1 holds
          P1.n = (the_VLabel_of FAP).(P1.(n+1))) &
        (for n being even Element of NAT st n in dom P2 holds
          P2.n = (the_VLabel_of FAP).(P2.(n+1)));
        then v in {source} by Th3;
        then v = source by TARSKI:def 1;
    then A62: P1.(2*0+1) = v & P1.(len P1) = v & P2.(2*0+1) = v & P2.(len P2) =
v
          by A61,GLIB_001:18;
         1 <= len P1 & 1 <= len P2 by HEYTING3:1;
        then len P1 = 1 & len P2 = 1 by A62,GLIB_001:def 29;
        then P1 = <*v*> & P2 = <*v*> by A62,FINSEQ_1:57;
        hence P1 = P2;
    end;
then A63: P[0];
     now let n be Element of NAT; assume
    A64: P[n]; set Gn = CS.n, Gn1 = CS.(n+1);
    A65: Gn1 = AP:Step(Gn) by Def15;
    A66: G == Gn by Th5;
        set Next = AP:NextBestEdges(Gn), e = choose Next;
         now per cases;
          suppose Next = {};
            then Gn1 = Gn by A65,Def14;
            hence P[n+1] by A64;
          end;
          suppose
        A67: Next <> {} & not (the_Source_of Gn).e in Gn.labeledV();
        then A68: Gn1 = Gn.labelVertex((the_Source_of Gn).e,e) by A65,Def14;
        A69: e in Next by A67;
        then A70: (the_Source_of Gn).e in the_Vertices_of Gn by FUNCT_2:7;
        then A71: Gn1.labeledV() = Gn.labeledV() \/ {(the_Source_of Gn).e}
              by A68,GLIB_003:59;
             e is_forward_labeling_in Gn or e is_backward_labeling_in Gn
              by A67,Def13;
        then A72: (the_Target_of Gn).e in Gn.labeledV() by A67,Def10,Def11;
             source in {source} by TARSKI:def 1;
        then A73: source in G0.labeledV() by Th3;
             G0.labeledV() c= Gn.labeledV() by Th4;
        then A74: source in Gn.labeledV() by A73;
             now let v be set,P1,P2 be vertex-distinct augmenting Path of G;
                assume
            A75: v in Gn1.labeledV() & P1 is_Walk_from source,v &
                P2 is_Walk_from source,v &
                (for n being even Element of NAT st n in dom P1 holds
                  P1.n = (the_VLabel_of FAP).(P1.(n+1))) &
                (for n being even Element of NAT st n in dom P2 holds
                  P2.n = (the_VLabel_of FAP).(P2.(n+1)));
            then A76: P1.1 = source & P1.(len P1) = v &
                  P2.1 = source & P2.(len P2) = v by GLIB_001:18;
                 now per cases by A71,A75,XBOOLE_0:def 2;
                  suppose v in Gn.labeledV();
                     hence P1 = P2 by A64,A75;
                  end;
                  suppose
                A77: v in {(the_Source_of Gn).e};
                then A78: v = (the_Source_of Gn).e by TARSKI:def 1;
                     v <> source by A67,A74,A77,TARSKI:def 1;
                    then P1.1 <> P1.last() & P2.1 <> P2.last()
                      by A76,GLIB_001:def 7;
                    then P1.first() <> P1.last() & P2.first() <> P2.last()
                      by GLIB_001:def 6;
                    then P1 is non trivial & P2 is non trivial by GLIB_001:128
;
                then A79: 3 <= len P1 & 3 <= len P2 by GLIB_001:126;
                    then 3-2 < len P1-0 & 3-2 < len P2-0 by REAL_1:92;
                    then reconsider lenP11 = len P1 - 1, lenP21 = len P2 - 1 as
                      even Element of NAT by INT_1:18;
                A80: 3-2 <= lenP11 & 3-2 <= lenP21 by A79,REAL_1:92;
                A81: lenP11+1 = len P1 & lenP21+1 = len P2;
                A82: lenP11 < len P1-0 & lenP21 < len P2-0 by REAL_1:92;
                then A83: lenP11 in dom P1 & lenP21 in dom P2 by A80,
FINSEQ_3:27;
                     (the_VLabel_of Gn1).v = e by A68,A70,A78,GLIB_003:46;
then (the_VLabel_of FAP).v = e by A75,Th7;
                then A84: P1.lenP11 = e & P2.lenP21 = e by A75,A76,A81,A83
;
then consider lenP12 being odd Element of NAT such that
                A85: lenP12 = lenP11 - 1 & lenP11-1 in dom P1 &
                      lenP11+1 in dom P1 & e Joins P1.lenP12,v,G
                      by A76,A83,GLIB_001:10;
                     e Joins (the_Target_of Gn).e,v,Gn
                      by A69,A78,GLIB_000:def 15;
                    then e Joins (the_Target_of Gn).e,v,G
                      by A66,GLIB_000:91;
                then A86: P1.lenP12 = (the_Target_of Gn).e
                      by A67,A72,A78,A85,GLIB_000:18;
                    consider lenP22 being odd Element of NAT such that
                A87: lenP22 = lenP21 - 1 & lenP21-1 in dom P2 &
                      lenP21+1 in dom P2 & e Joins P2.lenP22,v,G
                      by A76,A83,A84,GLIB_001:10;
                     e Joins (the_Target_of Gn).e,v,Gn
                           by A69,A78,GLIB_000:def 15;
                     then e Joins (the_Target_of Gn).e,v,G by A66,GLIB_000:91;
                then A88: P2.lenP22 = (the_Target_of Gn).e
                      by A67,A72,A78,A87,GLIB_000:18;
                    set P1A = P1.cut(2*0+1,lenP12);
                    set P2A = P2.cut(2*0+1,lenP22);
                A89: 1 <= lenP12 & 1 <= lenP22 by HEYTING3:1;
                A90: lenP12 < len P1 & lenP22 < len P2
                      by A82,A85,A87,REAL_1:92;
                then A91: P1A is_Walk_from source,(the_Target_of Gn).e &
                      P2A is_Walk_from source,(the_Target_of Gn).e
                      by A76,A86,A88,A89,GLIB_001:38;
                A92: now let n be even Element of NAT; assume
                    A93: n in dom P1A;
                    then A94: 1 <= n & n <= len P1A by FINSEQ_3:27;
                    A95: P1A.n = P1.n by A90,A93,GLIB_001:47;
                         n < len P1A by A94,REAL_1:def 5;
                        then 1 <= n+1 & n+1 <= len P1A
                          by NAT_1:13;
                        then n+1 in dom P1A by FINSEQ_3:27;
                    then A96: P1A.(n+1) = P1.(n+1) by A90,GLIB_001:47;
                         len P1A = lenP12 by A90,GLIB_001:46;
                        then n <= len P1 by A90,A94,XXREAL_0:2;
                        then n in dom P1 by A94,FINSEQ_3:27;
                        hence P1A.n = (the_VLabel_of FAP).(P1A.(n+1))
                          by A75,A95,A96;
                    end;
                A97: now let n be even Element of NAT; assume
                    A98: n in dom P2A;
                    then A99: 1 <= n & n <= len P2A by FINSEQ_3:27;
                    A100: P2A.n = P2.n by A90,A98,GLIB_001:47;
                         n < len P2A by A99,REAL_1:def 5;
                        then 1 <= n+1 & n+1 <= len P2A
                          by NAT_1:13;
                        then n+1 in dom P2A by FINSEQ_3:27;
                    then A101: P2A.(n+1) = P2.(n+1) by A90,GLIB_001:47;
                         len P2A = lenP22 by A90,GLIB_001:46;
                        then n <= len P2 by A90,A99,XXREAL_0:2;
                        then n in dom P2 by A99,FINSEQ_3:27;
                        hence P2A.n = (the_VLabel_of FAP).(P2A.(n+1))
                          by A75,A100,A101;
                    end;
                A102: lenP12 + 1 = lenP11 & lenP22 + 1 = lenP21
                      by A85,A87;
                     lenP12+(1+1) = len P1 & lenP22+(1+1) = len P2
                      by A85,A87;
                then A103: P1.cut(lenP12,len P1) =
                     G.walkOf((the_Target_of Gn).e,e,v) &
                    P2.cut(lenP22,len P2) =
                     G.walkOf((the_Target_of Gn).e,e,v)
                       by A76,A84,A86,A88,A90,A102,GLIB_001:41;
                A104: P1A.append(P1.cut(lenP12,len P1))
                       = P1.cut(2*0+1, len P1) by A89,A90,GLIB_001:39
                      .= P1 by GLIB_001:40;
                     P2A.append(P2.cut(lenP22, len P2))
                      = P2.cut(2*0+1, len P2) by A89,A90,GLIB_001:39
                     .= P2 by GLIB_001:40;
                    hence P1 = P2 by A64,A72,A91,A92,A97,A103,A104;
                  end;
                end;
                hence P1 = P2;
            end;
            hence P[n+1];
          end;
          suppose
        A105: Next <> {} & (the_Source_of Gn).e in Gn.labeledV();
        then A106: Gn1 = Gn.labelVertex((the_Target_of Gn).e,e) by A65,Def14;
        A107: e in Next by A105;
        then A108: (the_Target_of Gn).e in the_Vertices_of Gn by FUNCT_2:7;
        then A109: Gn1.labeledV() = Gn.labeledV() \/ {(the_Target_of Gn).e}
              by A106,GLIB_003:59;
             e is_forward_labeling_in Gn or e is_backward_labeling_in Gn
              by A105,Def13;
        then A110: not (the_Target_of Gn).e in Gn.labeledV()
              by A105,Def10,Def11;
             source in {source} by TARSKI:def 1;
        then A111: source in G0.labeledV() by Th3;
             G0.labeledV() c= Gn.labeledV() by Th4;
        then A112: source in Gn.labeledV() by A111;
             now let v be set,P1,P2 be vertex-distinct augmenting Path of G;
                assume
            A113: v in Gn1.labeledV() & P1 is_Walk_from source,v &
                P2 is_Walk_from source,v &
                (for n being even Element of NAT st n in dom P1 holds
                  P1.n = (the_VLabel_of FAP).(P1.(n+1))) &
                (for n being even Element of NAT st n in dom P2 holds
                  P2.n = (the_VLabel_of FAP).(P2.(n+1)));
            then A114: P1.1 = source & P1.(len P1) = v &
                  P2.1 = source & P2.(len P2) = v by GLIB_001:18;
                 now per cases by A109,A113,XBOOLE_0:def 2;
                  suppose v in Gn.labeledV();
                     hence P1 = P2 by A64,A113;
                  end;
                  suppose
                A115: v in {(the_Target_of Gn).e};
                then A116: v = (the_Target_of Gn).e by TARSKI:def 1;
                     v <> source by A110,A112,A115,TARSKI:def 1;
                    then P1.1 <> P1.last() & P2.1 <> P2.last()
                      by A114,GLIB_001:def 7;
                    then P1.first() <> P1.last() & P2.first() <> P2.last()
                      by GLIB_001:def 6;
                    then P1 is non trivial & P2 is non trivial by GLIB_001:128
;
                then A117: 3 <= len P1 & 3 <= len P2 by GLIB_001:126;
                    then 3-2 < len P1-0 & 3-2 < len P2-0 by REAL_1:92;
                    then reconsider lenP11 = len P1 - 1, lenP21 = len P2 - 1 as
                      even Element of NAT by INT_1:18;
                A118: 3-2 <= lenP11 & 3-2 <= lenP21 by A117,REAL_1:92;
                A119: lenP11+1 = len P1 & lenP21+1 = len P2;
                A120: lenP11 < len P1-0 & lenP21 < len P2-0 by REAL_1:92;
                then A121: lenP11 in dom P1 & lenP21 in dom P2 by A118,
FINSEQ_3:27;
                     (the_VLabel_of Gn1).v = e by A106,A108,A116,GLIB_003:46;
then (the_VLabel_of FAP).v = e by A113,Th7;
                then A122: P1.lenP11 = e & P2.lenP21 = e by A113,A114,A119,A121
;
then consider lenP12 being odd Element of NAT such that
                A123: lenP12 = lenP11 - 1 & lenP11-1 in dom P1 &
                      lenP11+1 in dom P1 & e Joins P1.lenP12,v,G
                      by A114,A121,GLIB_001:10;
                     e Joins (the_Source_of Gn).e,v,Gn
                      by A107,A116,GLIB_000:def 15;
                    then e Joins (the_Source_of Gn).e,v,G
                      by A66,GLIB_000:91;
                then A124: P1.lenP12 = (the_Source_of Gn).e
                      by A105,A110,A116,A123,GLIB_000:18;
                    consider lenP22 being odd Element of NAT such that
                A125: lenP22 = lenP21 - 1 & lenP21-1 in dom P2 &
                      lenP21+1 in dom P2 & e Joins P2.lenP22,v,G
                      by A114,A121,A122,GLIB_001:10;
                     e Joins (the_Source_of Gn).e,v,Gn
                      by A107,A116,GLIB_000:def 15;
                    then e Joins (the_Source_of Gn).e,v,G
                      by A66,GLIB_000:91;
                then A126: P2.lenP22 = (the_Source_of Gn).e
                      by A105,A110,A116,A125,GLIB_000:18;
                    set P1A = P1.cut(2*0+1,lenP12);
                    set P2A = P2.cut(2*0+1,lenP22);
                A127: 1 <= lenP12 & 1 <= lenP22 by HEYTING3:1;
                A128: lenP12 < len P1 & lenP22 < len P2
                      by A120,A123,A125,REAL_1:92;
                then A129: P1A is_Walk_from source,(the_Source_of Gn).e &
                    P2A is_Walk_from source,(the_Source_of Gn).e
                      by A114,A124,A126,A127,GLIB_001:38;
                A130: now let n be even Element of NAT; assume
                    A131: n in dom P1A;
                    then A132: 1 <= n & n <= len P1A by FINSEQ_3:27;
                    A133: P1A.n = P1.n by A128,A131,GLIB_001:47;
                         n < len P1A by A132,REAL_1:def 5;
                        then 1 <= n+1 & n+1 <= len P1A
                          by NAT_1:13;
                        then n+1 in dom P1A by FINSEQ_3:27;
                    then A134: P1A.(n+1) = P1.(n+1) by A128,GLIB_001:47;
                         len P1A = lenP12 by A128,GLIB_001:46;
                        then n <= len P1 by A128,A132,XXREAL_0:2;
                        then n in dom P1 by A132,FINSEQ_3:27;
                        hence P1A.n = (the_VLabel_of FAP).(P1A.(n+1))
                          by A113,A133,A134;
                    end;
                A135: now let n be even Element of NAT; assume
                    A136: n in dom P2A;
                    then A137: 1 <= n & n <= len P2A by FINSEQ_3:27;
                    A138: P2A.n = P2.n by A128,A136,GLIB_001:47;
                         n < len P2A by A137,REAL_1:def 5;
                        then 1 <= n+1 & n+1 <= len P2A
                          by NAT_1:13;
                        then n+1 in dom P2A by FINSEQ_3:27;
                    then A139: P2A.(n+1) = P2.(n+1) by A128,GLIB_001:47;
                         len P2A = lenP22 by A128,GLIB_001:46;
                        then n <= len P2 by A128,A137,XXREAL_0:2;
                        then n in dom P2 by A137,FINSEQ_3:27;
                        hence P2A.n = (the_VLabel_of FAP).(P2A.(n+1))
                          by A113,A138,A139;
                    end;
                A140: lenP12 + 1 = lenP11 & lenP22 + 1 = lenP21
                      by A123,A125;
                     lenP12+(1+1) = len P1 & lenP22+(1+1) = len P2
                      by A123,A125;
                then A141: P1.cut(lenP12,len P1) =
                       G.walkOf((the_Source_of Gn).e,e,v) &
                       P2.cut(lenP22,len P2) =
                       G.walkOf((the_Source_of Gn).e,e,v)
                       by A114,A122,A124,A126,A128,A140,GLIB_001:41;
                A142: P1A.append(P1.cut(lenP12,len P1))
                       = P1.cut(2*0+1, len P1) by A127,A128,GLIB_001:39
                      .= P1 by GLIB_001:40;
                     P2A.append(P2.cut(lenP22, len P2))
                      = P2.cut(2*0+1, len P2) by A127,A128,GLIB_001:39
                     .= P2 by GLIB_001:40;
                    hence P1 = P2 by A64,A105,A129,A130,A135,A141,A142;
                  end;
                end;
                hence P1 = P2;
            end;
            hence P[n+1];
          end;
        end;
        hence P[n+1];
    end;
then A143: for n being Element of NAT st P[n] holds P[n+1];
 for n being Element of NAT holds P[n] from NAT_1:sch 1(A63,A143);
    hence (sink in FAP.labeledV() &
        (IT1 is_Walk_from source,sink &
        for n being even Element of NAT st n in dom IT1 holds
          IT1.n = (the_VLabel_of AP:FindAugPath(G,source)).(IT1.(n+1))) &
        (IT2 is_Walk_from source,sink &
        for n being even Element of NAT st n in dom IT2 holds
          IT2.n = (the_VLabel_of AP:FindAugPath(G,source)).(IT2.(n+1))))
        implies IT1 = IT2;
    thus thesis;
  end;
  consistency;
end;

theorem Th8: ::tAPCS03
  for G being real-weighted real-elabeled WEGraph,
      source being Vertex of G, n being Element of NAT, v being set
   st v in (AP:CompSeq(G,source).n).labeledV() holds
     ex P being Path of G
       st P is augmenting & P is_Walk_from source,v &
       P.vertices() c= (AP:CompSeq(G,source).n).labeledV() proof
    let G be real-weighted real-elabeled WEGraph, source be Vertex of G;
    set CS = AP:CompSeq(G,source), G0 = CS.0;
    defpred P[Element of NAT] means
       for v being set st v in (CS.$1).labeledV()
       holds ex P being Path of G st
         P is augmenting & P is_Walk_from source,v &
         P.vertices() c= (CS.$1).labeledV();
     now let v be set; assume
    A1: v in G0.labeledV();
         G == G0 by Th3;
        then reconsider v'=v as Vertex of G by A1,GLIB_000:def 36;
        set P = G.walkOf(v');
        take P;
        thus P is augmenting;
         v in {source} by A1,Th3;
        then v = source by TARSKI:def 1;
        hence P is_Walk_from source,v by GLIB_001:14;
         P.vertices() = {v'} by GLIB_001:91;
        hence P.vertices() c= G0.labeledV() by A1,ZFMISC_1:37;
    end;
then A2: P[0];
A3: now let n be Element of NAT; set Gn = CS.n, Gn1 = CS.(n+1);
        set Next = AP:NextBestEdges(Gn), e = choose Next; assume
    A4: P[n];
    A5: Gn1 = AP:Step(Gn) by Def15;
         now per cases;
          suppose Next = {};
            then Gn1 = Gn by A5,Def14;
            hence P[n+1] by A4;
          end;
          suppose
        A6: Next <> {};
            set se = (the_Source_of Gn).e, te = (the_Target_of Gn).e;
             now per cases by A6,Def13;
              suppose
            A7: e is_forward_labeling_in Gn;
            then A8: e in the_Edges_of Gn & se in Gn.labeledV() &
                not te in Gn.labeledV() &
                (the_ELabel_of Gn).e < (the_Weight_of Gn).e
                  by Def10;
            then A9: Gn1 = Gn.labelVertex(te, e) by A5,A6,Def14;
                 te in the_Vertices_of Gn by A8,FUNCT_2:7;
            then A10: Gn1.labeledV() = Gn.labeledV() \/ {te} by A9,GLIB_003:59;
            then A11: Gn.labeledV() c= Gn1.labeledV() by XBOOLE_1:7;
                 te in {te} by TARSKI:def 1;
            then A12: te in Gn1.labeledV() by A10,XBOOLE_0:def 2;
            A13: se in Gn1.labeledV() by A8,A11;
                let v be set; assume
            A14: v in Gn1.labeledV();
            A15: G == Gn & the_Weight_of G = the_Weight_of Gn &
                the_ELabel_of Gn = the_ELabel_of G by Th5;
                 e DJoins se,te,Gn by A8,GLIB_000:def 16;
            then A16: e DJoins se,te,G by A15,GLIB_000:91;
                 now per cases by A10,A14,XBOOLE_0:def 2;
                  suppose v in Gn.labeledV();
                    then consider P being Path of G such that
                A17: P is augmenting & P is_Walk_from source,v &
                    P.vertices() c= Gn.labeledV() by A4;
                    take P;
                    thus P is augmenting & P is_Walk_from source,v &
                       P.vertices() c= Gn1.labeledV() by A11,A17,XBOOLE_1:1;
                  end;
                  suppose v in {te};
                then A18: v = te by TARSKI:def 1;
                     now per cases;
                      suppose
                    A19: se = source;
                        set P = G.walkOf(se,e,te);
                        take P;
                         e Joins se,te,Gn by A8,GLIB_000:def 15;
                    then A20: e Joins se,te,G by A15,GLIB_000:91;
                         now let n be odd Element of NAT; assume n < len P;
                            then n < 2+1 by A20,GLIB_001:15;
                            then n <= 2*1 by NAT_1:13;
                            then n < 1+1 by REAL_1:def 5;
                            then 1 <= n & n <= 1 by HEYTING3:1,NAT_1:13;
                        then A21: n = 1 by XXREAL_0:1;
                             P = <*se,e,te*> by A20,GLIB_001:def 5;
                        then A22: P.n = se & P.(n+1) = e & P.(n+2) = te
                              by A21,FINSEQ_1:62;
                        then A23: P.(n+1) DJoins P.n,P.(n+2),Gn
                              by A8,GLIB_000:def 16;
                            thus P.(n+1) DJoins P.n,P.(n+2),G implies
                              (the_ELabel_of G).(P.(n+1)) <
                              (the_Weight_of G).(P.(n+1))
                              by A7,A15,A22,Def10;
                            assume not P.(n+1) DJoins P.n,P.(n+2),G;
                            hence 0 < (the_ELabel_of G).(P.(n+1))
                              by A15,A23,GLIB_000:91;
                        end;
                        hence P is augmenting by Def12;
                        thus P is_Walk_from source,v by A18,A19,A20,GLIB_001:16
;
                         now let x be set; assume x in P.vertices();
                            then x in {se,te} by A20,GLIB_001:92;
                            hence x in Gn1.labeledV() by A12,A13,TARSKI:def 2;
                        end;
                        hence P.vertices() c= Gn1.labeledV() by TARSKI:def 3;
                      end;
                      suppose
                    A24: se <> source;
                        consider P being Path of G such that
                    A25: P is augmenting & P is_Walk_from source,se &
                          P.vertices() c= Gn.labeledV() by A4,A8;
                        set P2 = P.addEdge(e);
                         e Joins se,v,Gn by A8,A18,GLIB_000:def 15;
                    then A26: e Joins se,v,G by A15,GLIB_000:91;
                    A27: se = P.last() by A25,GLIB_001:def 23;
                        then P.first() <> P.last() by A24,A25,GLIB_001:def 23;
                    then A28: P is open by GLIB_001:def 24;
                    A29: not v in P.vertices() by A7,A18,A25,Def10;
                        then reconsider P2 as Path of G by A26,A27,A28,
GLIB_001:152;
                        take P2;
                        thus P2 is augmenting
                          by A8,A15,A16,A18,A25,A27,A29,Th2;
                        thus P2 is_Walk_from source,v by A25,A26,GLIB_001:67;
                         now let x be set; assume x in P2.vertices();
                        then A30: x in P.vertices()\/{te} by A18,A26,A27,
GLIB_001:96
;
                             now per cases by A30,XBOOLE_0:def 2;
                              suppose x in P.vertices();
                                then x in Gn.labeledV() by A25;
                                hence x in Gn1.labeledV() by A11;
                              end;
                              suppose x in {te};
                                hence x in Gn1.labeledV() by A10,XBOOLE_0:def 2
;
                              end;
                            end;
                            hence x in Gn1.labeledV();
                        end;
                        hence P2.vertices() c= Gn1.labeledV() by TARSKI:def 3;
                      end;
                    end;
                    hence ex P being Path of G st P is augmenting &
                      P is_Walk_from source,v & P.vertices() c= Gn1.labeledV();
                  end;
                end;
                hence ex P being Path of G st P is augmenting &
                     P is_Walk_from source,v & P.vertices() c= Gn1.labeledV();
              end;
              suppose
            A31: e is_backward_labeling_in Gn;
            then A32: e in the_Edges_of Gn & te in Gn.labeledV() &
                not se in Gn.labeledV() &
                0 < (the_ELabel_of Gn).e by Def11;
            then A33: Gn1 = Gn.labelVertex(se, e) by A5,A6,Def14;
                 se in the_Vertices_of Gn by A32,FUNCT_2:7;
            then A34: Gn1.labeledV() = Gn.labeledV() \/ {se} by A33,GLIB_003:59
;
then A35: Gn.labeledV() c= Gn1.labeledV() by XBOOLE_1:7;
                 se in {se} by TARSKI:def 1;
            then A36: se in Gn1.labeledV() by A34,XBOOLE_0:def 2;
            A37: te in Gn1.labeledV() by A32,A35;
                let v be set; assume
            A38: v in Gn1.labeledV();
            A39: G == Gn & the_Weight_of G = the_Weight_of Gn &
                the_ELabel_of G = the_ELabel_of Gn by Th5;
                 e DJoins se,te,Gn by A32,GLIB_000:def 16;
            then A40: e DJoins se,te,G by A39,GLIB_000:91;
                 now per cases by A34,A38,XBOOLE_0:def 2;
                  suppose v in Gn.labeledV();
                    then consider P being Path of G such that
                A41: P is augmenting & P is_Walk_from source,v &
                    P.vertices() c= Gn.labeledV() by A4;
                    take P;
                    thus P is augmenting & P is_Walk_from source,v &
                       P.vertices() c= Gn1.labeledV() by A35,A41,XBOOLE_1:1;
                  end;
                  suppose v in {se};
                then A42: v = se by TARSKI:def 1;
                     now per cases;
                      suppose
                    A43: te = source;
                        set P = G.walkOf(te,e,se);
                        take P;
                         e Joins te,se,Gn by A32,GLIB_000:def 15;
                    then A44: e Joins te,se,G by A39,GLIB_000:91;
                         now let n be odd Element of NAT; assume n < len P;
                            then n < 2+1 by A44,GLIB_001:15;
                            then n <= 2*1 by NAT_1:13;
                            then n < 1+1 by REAL_1:def 5;
                            then 1 <= n & n <= 1 by HEYTING3:1,NAT_1:13;
                        then A45: n = 1 by XXREAL_0:1;
                             P = <*te,e,se*> by A44,GLIB_001:def 5;
                        then A46: P.n = te & P.(n+1) = e & P.(n+2) = se
                              by A45,FINSEQ_1:62;
                            hereby assume P.(n+1) DJoins P.n,P.(n+2),G;
                                then e DJoins te,se,Gn by A39,A46,GLIB_000:91;
                                hence (the_ELabel_of G).(P.(n+1)) <
                                      (the_Weight_of G).(P.(n+1))
                                      by A32,GLIB_000:def 16;
                            end;
                            assume not P.(n+1) DJoins P.n,P.(n+2),G;
                            thus 0 < (the_ELabel_of G).(P.(n+1))
                              by A31,A39,A46,Def11;
                        end;
                        hence P is augmenting by Def12;
                        thus P is_Walk_from source,v by A42,A43,A44,GLIB_001:16
;
                         now let x be set; assume x in P.vertices();
                            then x in {se,te} by A44,GLIB_001:92;
                            hence x in Gn1.labeledV() by A36,A37,TARSKI:def 2;
                        end;
                        hence P.vertices() c= Gn1.labeledV() by TARSKI:def 3;
                      end;
                      suppose
                    A47: te <> source;
                        consider P being Path of G such that
                    A48: P is augmenting & P is_Walk_from source,te &
                          P.vertices() c= Gn.labeledV() by A4,A32;
                        set P2 = P.addEdge(e);
                         e Joins te,v,Gn by A32,A42,GLIB_000:def 15;
                    then A49: e Joins te,v,G by A39,GLIB_000:91;
                    A50: te = P.last() by A48,GLIB_001:def 23;
                        then P.first() <> P.last() by A47,A48,GLIB_001:def 23;
                    then A51: P is open by GLIB_001:def 24;
                    A52: not v in P.vertices() by A31,A42,A48,Def11;
                        then reconsider P2 as Path of G by A49,A50,A51,
GLIB_001:152;
                        take P2;
                        thus P2 is augmenting
                          by A32,A39,A40,A42,A48,A50,A52,Th2;
                        thus P2 is_Walk_from source,v by A48,A49,GLIB_001:67;
                         now let x be set; assume x in P2.vertices();
                        then A53: x in P.vertices()\/{se} by A42,A49,A50,
GLIB_001:96
;
                             now per cases by A53,XBOOLE_0:def 2;
                              suppose x in P.vertices();
                                then x in Gn.labeledV() by A48;
                                hence x in Gn1.labeledV() by A35;
                              end;
                              suppose x in {se};
                                hence x in Gn1.labeledV() by A34,XBOOLE_0:def 2
;
                              end;
                            end;
                            hence x in Gn1.labeledV();
                        end;
                        hence P2.vertices() c= Gn1.labeledV() by TARSKI:def 3;
                      end;
                    end;
                    hence ex P being Path of G st P is augmenting &
                      P is_Walk_from source,v & P.vertices() c= Gn1.labeledV();
                  end;
                end;
                hence ex P being Path of G st P is augmenting &
                     P is_Walk_from source,v & P.vertices() c= Gn1.labeledV();
              end;
            end;
            hence P[n+1];
          end;
        end;
        hence P[n+1];
    end;
     for n being Element of NAT holds P[n] from NAT_1:sch 1(A2,A3);
    hence thesis;
end;

theorem Th9: ::tAPFAP02
  for G being finite real-weighted real-elabeled WEGraph,
      source being Vertex of G, v being set
   holds v in AP:FindAugPath(G,source).labeledV() iff
      ex P being Path of G st
        P is augmenting & P is_Walk_from source,v proof
    let G be finite real-weighted real-elabeled WEGraph,
        source be Vertex of G, v be set;
    set CS = AP:CompSeq(G,source), V = AP:FindAugPath(G,source).labeledV();
    hereby assume v in AP:FindAugPath(G,source).labeledV();
        then consider P being Path of G such that
    A1: P is augmenting & P is_Walk_from source,v &
        P.vertices() c= AP:FindAugPath(G,source).labeledV() by Th8;
        thus ex P being Path of G st
          P is augmenting & P is_Walk_from source,v by A1;
    end;
    given P being Path of G such that
A2: P is augmenting & P is_Walk_from source,v;
     now assume
    A3: not v in AP:FindAugPath(G,source).labeledV();
        defpred P[Nat] means
          $1 is odd & $1 <= len P & not P.$1 in V;
         P.(len P) = v by A2,GLIB_001:18;
    then A4: ex n being Nat st P[n] by A3;
        consider n being Nat such that
    A5: P[n] & for k being Nat st P[k] holds n <= k
           from NAT_1:sch 5(A4);
         P.(2*0+1) = source by A2,GLIB_001:18;
        then P.(2*0+1) in {source} by TARSKI:def 1;
    then A6: P.(2*0+1) in (CS.0).labeledV() by Th3;
         (CS.0).labeledV() c= V by Th4;
    then A7: n <> 1 by A5,A6;
        reconsider n'=n as odd Element of NAT by A5,ORDINAL1:def 13;
         1 <= n by A5,HEYTING3:1;
        then 1 < n by A7,REAL_1:def 5;
        then 1+1 <= n by NAT_1:13;
        then reconsider n2 = n'-2*1 as odd Element of NAT by INT_1:18;
    A8: n2 < n - 0 by REAL_1:92;
    then A9: n2 < len P by A5,XXREAL_0:2;
    then A10: P.n2 in V by A5,A8;
        set Gn = CS.(CS.Lifespan()), Gn1 = CS.(CS.Lifespan()+1);
        set Next = AP:NextBestEdges(Gn), en = choose Next;
    A11: Gn1 = AP:Step(Gn) by Def15;
         AP:CompSeq(G,source) is halting by Th6;
        then A12: Gn = CS.(CS.Lifespan()+1) by GLIB_000:def 57;
        set e = P.(n2+1);
    A13: P.(n2+2) = P.n;
    A14: G == Gn &
        the_ELabel_of G = the_ELabel_of Gn &
        the_Weight_of G = the_Weight_of Gn by Th5;
    then A15: the_Edges_of G = the_Edges_of Gn &
        the_Source_of G = the_Source_of Gn &
        the_Target_of G = the_Target_of Gn by GLIB_000:def 36;
    A16: e Joins P.n2, P.n, G by A9,A13,GLIB_001:def 3;
    A17: now per cases;
          suppose
        A18: e DJoins P.n2, P.n, G;
        then A19: (the_ELabel_of G).e<(the_Weight_of G).e by A2,A9,A13,Def12;
         e in the_Edges_of Gn & (the_Source_of Gn).e in Gn.labeledV() &
              not (the_Target_of Gn).e in Gn.labeledV()
              by A5,A10,A15,A18,GLIB_000:def 16;
            then e is_forward_labeling_in Gn by A14,A19,Def10;
            hence Next <> {} by Def13;
          end;
          suppose
        A20: not e DJoins P.n2,P.n, G;
        then A21: 0 < (the_ELabel_of G).e by A2,A9,A13,Def12;
             e DJoins P.n,P.n2,G by A16,A20,GLIB_000:19;
            then e in the_Edges_of Gn & not (the_Source_of Gn).e in Gn
.labeledV() &
              (the_Target_of Gn).e in Gn.labeledV()
              by A5,A10,A15,GLIB_000:def 16;
            then e is_backward_labeling_in Gn by A14,A21,Def11;
            hence Next <> {} by Def13;
          end;
        end;
        then en in Next;
    then A22: (the_Source_of Gn).en in the_Vertices_of Gn &
        (the_Target_of Gn).en in the_Vertices_of Gn by FUNCT_2:7;
         now per cases;
          suppose
        A23: not (the_Source_of Gn).en in Gn.labeledV();
            then Gn = Gn.labelVertex((the_Source_of Gn).en,en)
              by A11,A12,A17,Def14;
        then A24: Gn.labeledV() = Gn.labeledV() \/ {(the_Source_of Gn).en}
              by A22,GLIB_003:59;
             (the_Source_of Gn).en in {(the_Source_of Gn).en}
              by TARSKI:def 1;
            hence contradiction by A23,A24,XBOOLE_0:def 2;
          end;
          suppose
        A25: (the_Source_of Gn).en in Gn.labeledV();
        then A26: Gn = Gn.labelVertex((the_Target_of Gn).en,en) by A11,A12,A17,
Def14
;
             en is_forward_labeling_in Gn or en is_backward_labeling_in Gn
              by A17,Def13;
        then A27: not (the_Target_of Gn).en in Gn.labeledV()
              by A25,Def10,Def11;
        A28: Gn.labeledV() = Gn.labeledV() \/ {(the_Target_of Gn).en}
              by A22,A26,GLIB_003:59;
             (the_Target_of Gn).en in {(the_Target_of Gn).en}
              by TARSKI:def 1;
            hence contradiction by A27,A28,XBOOLE_0:def 2;
          end;
        end;
        hence contradiction;
    end;
    hence v in AP:FindAugPath(G,source).labeledV();
end;

theorem Th10: ::tAPFAP03
  for G being finite real-weighted real-elabeled WEGraph,
      source being Vertex of G holds
    source in AP:FindAugPath(G,source).labeledV() &
    G == AP:FindAugPath(G,source) &
    the_Weight_of G = the_Weight_of AP:FindAugPath(G,source) &
    the_ELabel_of G = the_ELabel_of AP:FindAugPath(G,source) proof
    let G be finite real-weighted real-elabeled WEGraph, source be Vertex of G;
    set CS = AP:CompSeq(G,source), V = AP:FindAugPath(G,source).labeledV();
     (CS.0).labeledV() = {source} by Th3;
then A1: source in (CS.0).labeledV() by TARSKI:def 1;
     (CS.0).labeledV() c= AP:FindAugPath(G,source).labeledV()
      by Th4;
    hence source in AP:FindAugPath(G,source).labeledV() by A1;
    thus thesis by Th5;
end;

begin :: Ford-Fulkerson Algorithm definitions

definition let G be real-weighted real-elabeled WEGraph,
               W be augmenting Walk of G;
  func W.flowSeq() -> FinSequence of REAL means :Def18: ::dWFLOWSEQ
    dom it = dom W.edgeSeq() &
    for n being Element of NAT st n in dom it holds
     ((W.(2*n) DJoins W.(2*n-1),W.(2*n+1),G implies
         it.n = (the_Weight_of G).(W.(2*n)) - (the_ELabel_of G).(W.(2*n))) &
      (not W.(2*n) DJoins W.(2*n-1),W.(2*n+1),G implies
         it.n = (the_ELabel_of G).(W.(2*n))));
  existence proof
    defpred P[Nat,set] means
     (W.(2*$1) DJoins W.(2*$1-1),W.(2*$1+1),G implies
         $2 = (the_Weight_of G).(W.(2*$1)) - (the_ELabel_of G).(W.(2*$1))) &
     (not W.(2*$1) DJoins W.(2*$1-1),W.(2*$1+1),G implies
         $2 = (the_ELabel_of G).(W.(2*$1)));
A1: for k being Nat,y1,y2 being set
     st k in Seg len W.edgeSeq() & P[k,y1] & P[k,y2] holds y1=y2;
     now let k be Nat; assume k in Seg len W.edgeSeq();
         now per cases;
          suppose W.(2*k) DJoins W.(2*k-1),W.(2*k+1),G;
            hence ex x being set st P[k,x];
          end;
          suppose not W.(2*k) DJoins W.(2*k-1),W.(2*k+1),G;
            hence ex x being set st P[k,x];
          end;
        end;
        hence ex x being set st P[k,x];
    end;
then A2: for k being Nat st k in Seg len W.edgeSeq()
     ex x being set st P[k,x];
    consider IT being FinSequence such that
A3: dom IT = Seg len W.edgeSeq() &
    for k being Nat st k in Seg len W.edgeSeq() holds P[k,IT.k]
      from FINSEQ_1:sch 1(A1,A2);
     now let y be set; assume y in rng IT; then consider x being set such that
    A4: x in dom IT & IT.x = y by FUNCT_1:def 5;
        reconsider x as Element of NAT by A4;
         P[x,y] by A3,A4;
        hence y in REAL;
    end;
    then rng IT c= REAL by TARSKI:def 3;
    then reconsider IT as FinSequence of REAL by FINSEQ_1:def 4;
    take IT;
    thus dom IT = dom W.edgeSeq() by A3,FINSEQ_1:def 3;
    let n be Element of NAT; assume n in dom IT;
    hence thesis by A3;
  end;
  uniqueness proof
    let IT1,IT2 be FinSequence of REAL such that
A5: dom IT1 = dom W.edgeSeq() &
    for n being Element of NAT st n in dom IT1 holds
     ((W.(2*n) DJoins W.(2*n-1),W.(2*n+1),G implies
         IT1.n = (the_Weight_of G).(W.(2*n)) - (the_ELabel_of G).(W.(2*n))) &
      (not W.(2*n) DJoins W.(2*n-1),W.(2*n+1),G implies
         IT1.n = (the_ELabel_of G).(W.(2*n)))) and
A6: dom IT2 = dom W.edgeSeq() &
    for n being Element of NAT st n in dom IT2 holds
     ((W.(2*n) DJoins W.(2*n-1),W.(2*n+1),G implies
         IT2.n = (the_Weight_of G).(W.(2*n)) - (the_ELabel_of G).(W.(2*n))) &
      (not W.(2*n) DJoins W.(2*n-1),W.(2*n+1),G implies
         IT2.n = (the_ELabel_of G).(W.(2*n))));
      now let n be Nat; assume
     A7: n in dom IT1;
          now per cases;
           suppose (W.(2*n) DJoins W.(2*n-1),W.(2*n+1),G);
             then IT1.n = (the_Weight_of G).(W.(2*n))-(the_ELabel_of G).(W.(2*
n))&
             IT2.n = (the_Weight_of G).(W.(2*n))-(the_ELabel_of G).(W.(2*n))
               by A5,A6,A7;
             hence IT1.n = IT2.n;
           end;
           suppose not (W.(2*n) DJoins W.(2*n-1),W.(2*n+1),G);
             then IT1.n = (the_ELabel_of G).(W.(2*n)) &
             IT2.n = (the_ELabel_of G).(W.(2*n)) by A5,A6,A7;
             hence IT1.n = IT2.n;
           end;
         end;
         hence IT1.n = IT2.n;
     end;
     hence IT1 = IT2 by A5,A6,FINSEQ_1:17;
  end;
end;

definition let G be real-weighted real-elabeled WEGraph,
               W be augmenting Walk of G;
  func W.tolerance() -> Real means :Def19: ::dWTOLERANCE
    it in rng W.flowSeq() &
    for k being Real st k in rng W.flowSeq() holds it <= k
    if W is non trivial otherwise it = 0;
  existence proof
    set D = rng W.flowSeq();
    hereby assume W is non trivial;
        then W.edges() <> {} by GLIB_001:137;
        then rng W.edgeSeq() <> {} by GLIB_001:def 17;
        then consider y being set such that
    A1: y in rng W.edgeSeq() by XBOOLE_0:def 1;
        consider x being set such that
    A2: x in dom W.edgeSeq() & y = W.edgeSeq().x by A1,FUNCT_1:def 5;
         x in dom W.flowSeq() by A2,Def18;
        then W.flowSeq().x in D by FUNCT_1:def 5;
        then reconsider D as non empty finite Subset of REAL;
        deffunc F(Real) = $1;
        consider IT being Element of D such that
    A3: for k being Element of D holds F(IT) <= F(k) from GRAPH_5:sch 2;
        reconsider IT as Real;
        take IT;
        thus IT in rng W.flowSeq();
        let k be Real; assume k in rng W.flowSeq();
        hence IT <= k by A3;
    end;
    thus thesis;
  end;
  uniqueness proof
    let IT1,IT2 be Real;
    hereby assume W is non trivial;
        assume
    A4: IT1 in rng W.flowSeq() &
        for k being Real st k in rng W.flowSeq() holds IT1 <= k; assume
     IT2 in rng W.flowSeq() &
        for k being Real st k in rng W.flowSeq() holds IT2 <= k;
        then IT1 <= IT2 & IT2 <= IT1 by A4;
        hence IT1 = IT2 by XXREAL_0:1;
    end;
    thus thesis;
  end;
  consistency;
end;

definition let G be natural-weighted natural-elabeled WEGraph,
               W be augmenting Walk of G;
   redefine func W.tolerance() -> Element of NAT;
  coherence proof
   set IT = W.tolerance();
    now per cases;
     suppose W is non trivial;
       then IT in rng W.flowSeq() by Def19;
       then consider n being Nat such that
   A1: n in dom W.flowSeq() & (W.flowSeq()).n = IT by FINSEQ_2:11;
   reconsider n as Element of NAT by ORDINAL1:def 13;
        n in dom W.edgeSeq() by A1,Def18;
       then 2*n in dom W by GLIB_001:79;
   then A2: 1 <= 2*n & 2*n <= len W by FINSEQ_3:27;
       then reconsider 2n1 = 2*n-1 as odd Element of NAT by INT_1:18;
   A3: 2n1 < len W - 0 by A2,REAL_1:92;
   A4: 2n1+1 = 2*n;
   A5: 2n1+(1+1) = 2*n+1;
        now per cases;
         suppose
       A6: W.(2*n) DJoins W.(2*n-1),W.(2*n+1),G;
       then A7: IT = (the_Weight_of G).(W.(2*n)) - (the_ELabel_of G).(W.(2*n))
             by A1,Def18;
            (the_ELabel_of G).(W.(2*n)) <
           (the_Weight_of G).(W.(2*n)) by A3,A4,A5,A6,Def12;
           hence IT is Element of NAT by A7,INT_1:18;
         end;
         suppose not W.(2*n) DJoins W.(2*n-1),W.(2*n+1),G;
           then IT = (the_ELabel_of G).(W.(2*n)) by A1,Def18;
           hence IT is Element of NAT;
         end;
       end;
       hence IT is Element of NAT;
     end;
     suppose W is trivial;
       hence IT is Element of NAT by Def19;
     end;
   end;
   hence IT is Element of NAT;
 end;
end;

definition let G be real-weighted real-elabeled WEGraph,
               P be augmenting Path of G;
  func FF:PushFlow(G,P) -> ManySortedSet of the_Edges_of G means :Def20
: ::dFFPUSH
    (for e being set st e in the_Edges_of G & not e in P.edges()
      holds it.e = (the_ELabel_of G).e) &
    (for n being odd Element of NAT st n < len P holds
      (P.(n+1) DJoins P.n, P.(n+2),G implies
       it.(P.(n+1)) = (the_ELabel_of G).(P.(n+1)) + P.tolerance()) &
      (not P.(n+1) DJoins P.n,P.(n+2),G implies
       it.(P.(n+1)) = (the_ELabel_of G).(P.(n+1)) - P.tolerance()));
  existence proof
    defpred P[set,set] means
      ($1 in the_Edges_of G & not $1 in P.edges()
        implies $2 = (the_ELabel_of G).$1) &
      (for n being odd Element of NAT st n < len P & $1 = P.(n+1) holds
        ((P.(n+1) DJoins P.n,P.(n+2),G) implies
         $2 = (the_ELabel_of G).(P.(n+1)) + P.tolerance()) &
        (not P.(n+1) DJoins P.n,P.(n+2),G implies
         $2 = (the_ELabel_of G).(P.(n+1)) - P.tolerance()));
     now let x,y1,y2 be set; assume
    A1: x in the_Edges_of G & P[x,y1] & P[x,y2];
         now per cases;
          suppose not x in P.edges();
            hence y1 = y2 by A1;
          end;
          suppose x in P.edges(); then consider n being odd Element of NAT
          such that
        A2: n < len P & P.(n+1) = x by GLIB_001:101;
             now per cases;
              suppose (P.(n+1) DJoins P.n,P.(n+2),G);
                then y1 = (the_ELabel_of G).(P.(n+1)) + P.tolerance() &
                y2 = (the_ELabel_of G).(P.(n+1)) + P.tolerance() by A1,A2;
                hence y1 = y2;
              end;
              suppose not (P.(n+1) DJoins P.n,P.(n+2),G);
                then y1 = (the_ELabel_of G).(P.(n+1)) - P.tolerance() &
                y2 = (the_ELabel_of G).(P.(n+1)) - P.tolerance() by A1,A2;
                hence y1 = y2;
              end;
            end;
            hence y1 = y2;
          end;
        end;
        hence y1 = y2;
    end;
then A3: for x,y1,y2 being set st x in the_Edges_of G & P[x,y1] & P[x,y2]
      holds y1 = y2;
     now let x be set; assume x in the_Edges_of G;
         now per cases;
          suppose
        A4: not x in P.edges();
            set y = (the_ELabel_of G).x;
             for n being odd Element of NAT st n < len P & x = P.(n+1) holds
              ((P.(n+1) DJoins P.n,P.(n+2),G) implies
                y = (the_ELabel_of G).(P.(n+1)) + P.tolerance()) &
               (not P.(n+1) DJoins P.n,P.(n+2),G implies
                y = (the_ELabel_of G).(P.(n+1)) - P.tolerance())
                by A4,GLIB_001:101;
            hence ex y being set st P[x,y];
          end;
          suppose
        A5: x in P.edges(); then consider n being odd Element of NAT such that
        A6: n < len P & P.(n+1) = x by GLIB_001:101;
        A7: 1 <= n+1 & n+1 <= len P by A6,NAT_1:11,13;
             now per cases;
              suppose
            A8: (P.(n+1) DJoins P.n,P.(n+2),G);
                set y = (the_ELabel_of G).(P.(n+1)) + P.tolerance();
                 now thus x in the_Edges_of G & not x in P.edges()
                      implies y = (the_ELabel_of G).x by A5;
                    let m be odd Element of NAT such that
                A9: m < len P & P.(m+1) = x;
                     1 <= m+1 & m+1 <= len P by A9,NAT_1:11,13;
                    then m+1 <= n+1 & n+1 <= m+1 by A6,A7,A9,GLIB_001:139;
                    then A10: m+1 = n+1 by XXREAL_0:1;
                    thus P.(m+1) DJoins P.m,P.(m+2),G implies y = y;
                    assume not P.(m+1) DJoins P.m,P.(m+2),G;
                    hence y = (the_ELabel_of G).(P.(m+1)) - P.tolerance()
                      by A8,A10;
                end;
                then P[x,y] by A6;
                hence ex y being set st P[x,y];
              end;
              suppose
            A11: not (P.(n+1) DJoins P.n,P.(n+2),G);
                set y =(the_ELabel_of G).(P.(n+1)) - P.tolerance();
                 now thus x in the_Edges_of G & not x in P.edges()
                      implies y = (the_ELabel_of G).x by A5;
                    let m be odd Element of NAT such that
                A12: m < len P & P.(m+1) = x;
                     1 <= m+1 & m+1 <= len P by A12,NAT_1:11,13;
                    then m+1 <= n+1 & n+1 <= m+1 by A6,A7,A12,GLIB_001:139;
                    then m+1 = n+1 by XXREAL_0:1;
                    hence P.(m+1) DJoins P.m,P.(m+2),G implies
                      y = (the_ELabel_of G).(P.(n+1)) + P.tolerance() by A11;
                    assume not P.(m+1) DJoins P.m,P.(m+2),G;
                    thus y = (the_ELabel_of G).(P.(n+1)) - P.tolerance();
                end;
                then P[x,y] by A6;
                hence ex y being set st P[x,y];
              end;
            end;
            hence ex y being set st P[x,y];
          end;
        end;
        hence ex y being set st P[x,y];
    end;
then A13: for x being set st x in the_Edges_of G holds
      ex y being set st P[x,y];
    consider IT being Function such that
A14: dom IT = the_Edges_of G &
    for e being set st e in the_Edges_of G holds P[e,IT.e]
      from FUNCT_1:sch 2(A3,A13);
    reconsider IT as ManySortedSet of the_Edges_of G by A14,PBOOLE:def 3;
    take IT;
    thus for e being set st e in the_Edges_of G & not e in P.edges()
      holds IT.e = (the_ELabel_of G).e by A14;
    let n be odd Element of NAT; assume
A15: n < len P;
    then P.(n+1) Joins P.n, P.(n+2), G by GLIB_001:def 3;
then A16: P.(n+1) in the_Edges_of G by GLIB_000:def 15;
    hence P.(n+1) DJoins P.n,P.(n+2),G implies
      IT.(P.(n+1)) = (the_ELabel_of G).(P.(n+1)) + P.tolerance() by A14,A15;
    assume not P.(n+1) DJoins P.n, P.(n+2), G;
    hence IT.(P.(n+1)) = (the_ELabel_of G).(P.(n+1)) - P.tolerance()
      by A14,A15,A16;
  end;
  uniqueness proof
    let IT1,IT2 be ManySortedSet of the_Edges_of G such that
A17: (for e being set st e in the_Edges_of G & not e in P.edges()
      holds IT1.e = (the_ELabel_of G).e) &
    (for n being odd Element of NAT st n < len P holds
      (P.(n+1) DJoins P.n, P.(n+2),G implies
       IT1.(P.(n+1)) = (the_ELabel_of G).(P.(n+1)) + P.tolerance()) &
      (not P.(n+1) DJoins P.n,P.(n+2),G implies
       IT1.(P.(n+1)) = (the_ELabel_of G).(P.(n+1)) - P.tolerance())) and
A18: (for e being set st e in the_Edges_of G & not e in P.edges()
      holds IT2.e = (the_ELabel_of G).e) &
    (for n being odd Element of NAT st n < len P holds
      (P.(n+1) DJoins P.n, P.(n+2),G implies
       IT2.(P.(n+1)) = (the_ELabel_of G).(P.(n+1)) + P.tolerance()) &
      (not P.(n+1) DJoins P.n,P.(n+2),G implies
       IT2.(P.(n+1)) = (the_ELabel_of G).(P.(n+1)) - P.tolerance()));
     now let e be set; assume
    A19: e in the_Edges_of G;
         now per cases;
          suppose not e in P.edges();
            then IT1.e = (the_ELabel_of G).e &
            IT2.e = (the_ELabel_of G).e by A17,A18,A19;
            hence IT1.e = IT2.e;
          end;
          suppose e in P.edges(); then consider n being odd Element of NAT
          such that
        A20: n < len P & P.(n+1) = e by GLIB_001:101;
             now per cases;
              suppose P.(n+1) DJoins P.n,P.(n+2),G;
                then IT1.e = (the_ELabel_of G).(P.(n+1)) + P.tolerance() &
                IT2.e = (the_ELabel_of G).(P.(n+1)) + P.tolerance()
                  by A17,A18,A20;
                hence IT1.e = IT2.e;
              end;
              suppose not P.(n+1) DJoins P.n,P.(n+2),G;
                then IT1.e = (the_ELabel_of G).(P.(n+1)) - P.tolerance() &
                IT2.e = (the_ELabel_of G).(P.(n+1)) - P.tolerance()
                  by A17,A18,A20;
                hence IT1.e = IT2.e;
              end;
            end;
            hence IT1.e = IT2.e;
          end;
        end;
        hence IT1.e = IT2.e;
    end;
    hence thesis by PBOOLE:3;
  end;
end;

registration let G be real-weighted real-elabeled WEGraph,
                 P be augmenting Path of G;
  cluster FF:PushFlow(G,P) -> real-yielding;
  coherence proof
    set F = FF:PushFlow(G,P);
     now let y be set; assume y in rng F;
        then consider e being set such that
    A1: e in dom F & F.e = y by FUNCT_1:def 5;
    A2: e in the_Edges_of G by A1,PBOOLE:def 3;
         now per cases;
          suppose not e in P.edges();
            then y = (the_ELabel_of G).e by A1,A2,Def20;
            hence y in REAL;
          end;
          suppose e in P.edges(); then consider n being odd Element of NAT
          such that
        A3: n < len P & P.(n+1) = e by GLIB_001:101;
             now per cases;
              suppose P.(n+1) DJoins P.n, P.(n+2), G;
                then y = (the_ELabel_of G).(P.(n+1))+P.tolerance() by A1,A3,
Def20;
                hence y in REAL;
              end;
              suppose not P.(n+1) DJoins P.n,P.(n+2),G;
                then y = (the_ELabel_of G).(P.(n+1))-P.tolerance() by A1,A3,
Def20;
                hence y in REAL;
              end;
            end;
            hence y in REAL;
          end;
       end;
       hence y in REAL;
    end;
    then rng F c= REAL by TARSKI:def 3;
    hence F is real-yielding by VALUED_0:def 3;
  end;
end;

registration let G be natural-weighted natural-elabeled WEGraph,
                 P be augmenting Path of G;
  cluster FF:PushFlow(G,P) -> natural-yielding;
  coherence proof
    set F = FF:PushFlow(G,P);
     now let y be set; assume y in rng F;
        then consider e being set such that
    A1: e in dom F & F.e = y by FUNCT_1:def 5;
    A2: e in the_Edges_of G by A1,PBOOLE:def 3;
         now per cases;
          suppose not e in P.edges();
            then y = (the_ELabel_of G).e by A1,A2,Def20;
            hence y in NAT;
          end;
          suppose
        A3: e in P.edges(); then consider n being odd Element of NAT such that
        A4: n < len P & P.(n+1) = e by GLIB_001:101;
        A5: P is non trivial by A3,GLIB_001:137;
             now per cases;
              suppose P.(n+1) DJoins P.n, P.(n+2), G;
                then y = (the_ELabel_of G).(P.(n+1))+P.tolerance() by A1,A4,
Def20;
                hence y in NAT;
              end;
              suppose
            A6: not P.(n+1) DJoins P.n,P.(n+2),G;
            then A7: y = (the_ELabel_of G).e-P.tolerance() by A1,A4,Def20;
                set n1div2 = (n+1) div 2;
                 1 <= n+1 & n+1 <= len P by A4,NAT_1:11,13;
                then n1div2 in dom P.edgeSeq() & e = P.edgeSeq().n1div2
                  by A4,GLIB_001:78;
            then A8: n1div2 in dom P.flowSeq() by Def18;
                 2 divides n+1 by PEPIN:22;
            then A9: 2*n1div2 = n+1 by NAT_D:3;
            then A10: 2*n1div2-1 = n;
                 2*n1div2+1 = n+(1+1) by A9;
                then P.flowSeq().n1div2 = (the_ELabel_of G).e
                  by A4,A6,A8,A10,Def18;
                then (the_ELabel_of G).e in rng P.flowSeq() by A8,FUNCT_1:def 5
;
                then P.tolerance() <= (the_ELabel_of G).e by A5,Def19;
                hence y in NAT by A7,INT_1:18;
              end;
            end;
            hence y in NAT;
          end;
       end;
       hence y in NAT;
    end;
    then rng F c= NAT by TARSKI:def 3;
    hence F is natural-yielding by VALUED_0:def 6;
  end;
end;

definition let G be real-weighted real-elabeled WEGraph,
               P be augmenting Path of G;
  func FF:AugmentPath(G,P) -> real-weighted real-elabeled
                              complete-elabeled WEGraph equals  ::dFFAUGP
     G.set(ELabelSelector, FF:PushFlow(G,P));
  coherence;
end;

registration let G be finite real-weighted real-elabeled WEGraph,
               P be augmenting Path of G;
  cluster FF:AugmentPath(G,P) -> finite;
  coherence;
end;

registration let G be finite nonnegative-weighted real-elabeled WEGraph,
                 P be augmenting Path of G;
  cluster FF:AugmentPath(G,P) -> nonnegative-weighted;
  coherence;
end;

registration let G be finite natural-weighted natural-elabeled WEGraph,
                 P be augmenting Path of G;
  cluster FF:AugmentPath(G,P) -> natural-weighted natural-elabeled;
  coherence;
end;

definition let G be finite real-weighted
                    real-elabeled complete-elabeled WEGraph,
               sink, source be Vertex of G;
  func FF:Step(G, source, sink) -> finite real-weighted real-elabeled
                                   complete-elabeled WEGraph equals :Def22
: ::dFFSTEP
    FF:AugmentPath(G, AP:GetAugPath(G,source,sink))
      if sink in AP:FindAugPath(G,source).labeledV()
    otherwise G;
  coherence;
  consistency;
end;

registration let G be finite nonnegative-weighted real-elabeled
                      complete-elabeled WEGraph, source,sink be Vertex of G;
  cluster FF:Step(G,source,sink) -> nonnegative-weighted;
  coherence proof
    set P = AP:GetAugPath(G,source,sink);
     now per cases;
      suppose sink in AP:FindAugPath(G,source).labeledV();
        then FF:Step(G,source,sink) = FF:AugmentPath(G,P) by Def22;
        hence thesis;
      end;
      suppose not sink in AP:FindAugPath(G,source).labeledV();
        hence thesis by Def22;
      end;
    end;
    hence thesis;
  end;
end;

registration let G be finite natural-weighted natural-elabeled
                      complete-elabeled WEGraph, source,sink be Vertex of G;
  cluster FF:Step(G,source,sink) -> natural-weighted natural-elabeled;
  coherence proof
    set P = AP:GetAugPath(G,source,sink);
     now per cases;
      suppose sink in AP:FindAugPath(G,source).labeledV();
        then FF:Step(G,source,sink) = FF:AugmentPath(G,P) by Def22;
        hence thesis;
      end;
      suppose not sink in AP:FindAugPath(G,source).labeledV();
        hence thesis by Def22;
      end;
    end;
    hence thesis;
  end;
end;

definition let s be WEGraphSeq, n be Nat;
 redefine func s.n -> WEGraph;
 coherence
  proof
   thus s.n is [Weighted] [ELabeled] _Graph;
  end;
end;

registration let s be finite WEGraphSeq, n be Nat;
 cluster s.n -> finite WEGraph;
 coherence by GLIB_000:def 60;
end;

registration let s be real-weighted WEGraphSeq, n be Nat;
 cluster s.n -> real-weighted WEGraph;
 coherence by GLIB_003:def 27;
end;

registration let s be real-elabeled WEGraphSeq, n be Nat;
 cluster s.n -> real-elabeled WEGraph;
 coherence by GLIB_003:def 29;
end;

registration let s be complete-elabeled WEGraphSeq, n be Nat;
 cluster s.n -> complete-elabeled WEGraph;
 coherence by Def2;
end;

definition let G be finite real-weighted WGraph,
               source,sink be Vertex of G;
  func FF:CompSeq(G,source,sink) -> finite real-weighted real-elabeled
                                    complete-elabeled
                                    WEGraphSeq means :Def23: ::dFFCS
    it.0 = G.set(ELabelSelector, the_Edges_of G --> 0) &
    for n being Nat holds
      ex source',sink' being Vertex of it.n
      st source' = source & sink' = sink &
         it.(n+1) = FF:Step(it.n,source',sink');
  existence proof
    defpred P[set,set,set] means
    (ex Gn being finite real-weighted real-elabeled complete-elabeled
                WEGraph, source',sink' being Vertex of Gn
     st $2 = Gn & source'=source & sink'=sink &
        $3 = FF:Step(Gn,source',sink')) or
     ((not ex Gn being finite real-weighted real-elabeled complete-elabeled
                WEGraph, source',sink' being Vertex of Gn
      st $2 = Gn & source'=source & sink'=sink) & $2 = $3);
     now let n,x be set;
         now per cases;
          suppose ex Gn being finite real-weighted real-elabeled
              complete-elabeled WEGraph, source',sink' being Vertex of Gn st
              x = Gn & source'=source & sink'=sink;
            then consider Gn being finite real-weighted real-elabeled
              complete-elabeled WEGraph, source',sink' being Vertex of Gn
              such that
        A1: x = Gn & source'=source & sink'=sink;
            set y = FF:Step(Gn,source',sink');
             P[n,x,y] by A1;
            hence ex y being set st P[n,x,y];
          end;
          suppose not ex Gn being finite real-weighted real-elabeled
            complete-elabeled WEGraph, source',sink' being Vertex of Gn st
            x = Gn & source'=source & sink'=sink;
            hence ex y being set st P[n,x,y];
          end;
        end;
        hence ex y being set st P[n,x,y];
    end;
then A2: for n being Element of NAT for x being set ex y being set st P[n,x,y];
A3: for n being Element of NAT for x,y1,y2 being set st P[n,x,y1] & P[n,x,y2]
      holds y1 = y2;
    consider IT being Function such that
A4: dom IT = NAT & IT.0 = G.set(ELabelSelector, the_Edges_of G --> 0) &
    for n being Element of NAT holds P[n,IT.n,IT.(n+1)]
      from RECDEF_1:sch 1(A2,A3);
    reconsider IT as ManySortedSet of NAT by A4,PBOOLE:def 3;
    defpred P2[Nat] means
      ex Gn being finite real-weighted real-elabeled complete-elabeled
        WEGraph st IT.$1 = Gn & Gn == G;
    reconsider E0 = the_Edges_of G --> 0 as Function of the_Edges_of G, REAL
      by FUNCOP_1:58;
    set G0 = G.set(ELabelSelector, E0);
     G0 == G by GLIB_003:8;
then A5: P2[0] by A4;
A6: now let n be Nat; assume P2[n];
        then consider Gn being finite real-weighted real-elabeled
          complete-elabeled WEGraph such that
    A7: IT.n = Gn & Gn == G;
        reconsider source'=source, sink'=sink as Vertex of Gn
          by A7,GLIB_000:def 36;
          n in NAT by ORDINAL1:def 13; then
    A8: P[n,Gn,IT.(n+1)] by A4,A7;
        set P = AP:GetAugPath(Gn,source',sink');
         now per cases;
           suppose sink in AP:FindAugPath(Gn,source').labeledV();
             then IT.(n+1) = FF:AugmentPath(Gn,P) by A8,Def22
                     .= Gn.set(ELabelSelector,FF:PushFlow(Gn,P));
             hence FF:Step(Gn,source',sink') == Gn by A8,GLIB_003:8;
           end;
           suppose not sink in AP:FindAugPath(Gn,source').labeledV();
             hence FF:Step(Gn,source',sink') == Gn by Def22;
           end;
        end;
        then FF:Step(Gn,source',sink') == G by A7,GLIB_000:88;
        hence P2[n+1] by A8;
    end;
A9: for n being Nat holds P2[n] from NAT_1:sch 2(A5,A6);
     now let n be Nat;
        consider Gn being finite real-weighted real-elabeled
                          complete-elabeled WEGraph such that
    A10: IT.n = Gn & Gn == G by A9;
        thus IT.n is _Graph by A10;
    end; then reconsider IT as GraphSeq by GLIB_000:def 55;
A11: now let n be Nat;
        n in NAT by ORDINAL1:def 13;
       consider Gn being finite real-weighted real-elabeled
          complete-elabeled WEGraph such that
    A12: IT.n = Gn & Gn == G by A9;
        thus IT.n is finite real-weighted real-elabeled
          complete-elabeled WEGraph by A12;
    end;
    then for n being Nat holds
      IT.n is [Weighted] & IT.n is [ELabeled];
    then reconsider IT as WEGraphSeq by GLIB_003:def 24,def 25;
     for n being Nat holds IT.n is finite & IT.n
    is real-weighted &
      IT.n is real-elabeled & IT.n is complete-elabeled by A11;
    then reconsider IT as finite real-weighted real-elabeled
      complete-elabeled WEGraphSeq
      by Def2,GLIB_000:def 60,GLIB_003:def 27,def 29;
    take IT;
    thus IT.0 = G.set(ELabelSelector,the_Edges_of G --> 0)
      by A4;
    let n be Nat;
     reconsider n' = n as Element of NAT by ORDINAL1:def 13;
    consider Gn being finite real-weighted real-elabeled
                      complete-elabeled WEGraph such that
A13: IT.n' = Gn & Gn == G by A9;
    reconsider source'=source,sink'=sink as Vertex of IT.n
      by A13,GLIB_000:def 36;
    take source',sink';
    thus source'=source & sink'=sink;
     IT.n is finite real-weighted real-elabeled complete-elabeled WEGraph &
    source' is Vertex of IT.n & sink' is Vertex of IT.n & IT.n = Gn &
    source'=source & sink'=sink by A13;
    then consider X being finite real-weighted real-elabeled complete-elabeled
      WEGraph, sourceX,sinkX being Vertex of X such that
A14: X = Gn & sourceX = source & sinkX = sink &
      IT.(n'+1) = FF:Step(X,sourceX,sinkX) by A4;
    thus IT.(n+1) = FF:Step(IT.n,source',sink') by A13,A14;
  end;
  uniqueness proof
    let IT1,IT2 be finite real-weighted real-elabeled complete-elabeled
                   WEGraphSeq such that
A15: IT1.0 = G.set(ELabelSelector, the_Edges_of G --> 0) &
    for n being Nat holds
      ex source',sink' being Vertex of IT1.n
      st source' = source & sink' = sink &
         IT1.(n+1) = FF:Step(IT1.n,source',sink') and
A16: IT2.0 = G.set(ELabelSelector, the_Edges_of G --> 0) &
    for n being Nat holds
      ex source',sink' being Vertex of IT2.n
      st source' = source & sink' = sink &
         IT2.(n+1) = FF:Step(IT2.n,source',sink');
    defpred P[Element of NAT] means IT1.$1 = IT2.$1;
A17: P[0] by A15,A16;
A18: now let n be Element of NAT; assume A19: P[n];
        consider source1,sink1 being Vertex of IT1.n such that
    A20: source1=source & sink1=sink &
        IT1.(n+1) = FF:Step(IT1.n,source1,sink1) by A15;
        consider source2,sink2 being Vertex of IT2.n such that
    A21: source2=source & sink2 = sink &
        IT2.(n+1) = FF:Step(IT2.n,source2,sink2) by A16;
        thus P[n+1] by A19,A20,A21;
    end;
     for n being Element of NAT holds P[n] from NAT_1:sch 1(A17,A18);
    then for n being set st n in NAT holds IT1.n = IT2.n;
    hence IT1 = IT2 by PBOOLE:3;
  end;
end;

registration let G be finite nonnegative-weighted WGraph,
                 sink, source be Vertex of G;
  cluster FF:CompSeq(G,source,sink) -> nonnegative-weighted;
  coherence proof
    set CS = FF:CompSeq(G,source,sink);
    defpred P[Nat] means CS.$1 is nonnegative-weighted;
     CS.0 = G.set(ELabelSelector, the_Edges_of G --> 0) by Def23;
then A1: P[0];
A2: now let n be Element of NAT; assume
    A3: P[n]; set Gn = CS.n, Gn1 = CS.(n+1);
        reconsider Gn as finite nonnegative-weighted real-elabeled
          complete-elabeled WEGraph by A3;
        consider source',sink' being Vertex of Gn such that
    A4: source'=source & sink'=sink & Gn1 = FF:Step(Gn,source',sink')
          by Def23;
        thus P[n+1] by A4;
    end;
A5: for n being Element of NAT holds P[n] from NAT_1:sch 1(A1,A2);
     for n being Nat holds P[n]
    proof
      let n be Nat;  n in NAT by ORDINAL1:def 13;
      hence thesis by A5;
    end;
    hence thesis by GLIB_003:def 28;
  end;
end;

registration let G be finite natural-weighted WGraph,
                 sink,source be Vertex of G;
  cluster FF:CompSeq(G,source,sink) -> natural-weighted natural-elabeled;
  coherence proof
    set CS = FF:CompSeq(G,source,sink);
    defpred P[Nat] means
      CS.$1 is natural-elabeled & CS.$1 is natural-weighted;
     CS.0 = G.set(ELabelSelector, the_Edges_of G --> 0) by Def23;
then A1: P[0];
A2: now let n be Element of NAT; assume
    A3: P[n]; set Gn = CS.n, Gn1 = CS.(n+1);
        reconsider Gn as finite natural-weighted natural-elabeled
          complete-elabeled WEGraph by A3;
        consider source',sink' being Vertex of Gn such that
    A4: source'=source & sink'=sink & Gn1 = FF:Step(Gn,source',sink')
          by Def23;
        thus P[n+1] by A4;
    end;
A5: for n being Element of NAT holds P[n] from NAT_1:sch 1(A1,A2);
     for n being Nat holds P[n]
    proof
      let n be Nat;  n in NAT by ORDINAL1:def 13;
      hence thesis by A5;
    end;
    hence thesis by Def5,Def6;
  end;
end;

definition let G be finite real-weighted WGraph, sink,source be Vertex of G;
  func FF:MaxFlow(G,source, sink) -> finite real-weighted real-elabeled
                                  complete-elabeled WEGraph equals  ::dFFMAXFLOW
     FF:CompSeq(G,source,sink).Result();
  coherence proof
    set CS = FF:CompSeq(G,source,sink);
     CS.Result() = CS.(CS.Lifespan());
    hence thesis;
  end;
end;

begin :: Ford Fulkerson Maximum Flow Theorems

theorem Th11: :: tFLOW01
  for G being finite real-weighted real-elabeled complete-elabeled WEGraph,
        source, sink being set, V being Subset of the_Vertices_of G
   st G has_valid_flow_from source,sink &
      source in V & not sink in V holds
      G.flow(source,sink) =
      Sum ((the_ELabel_of G) | G.edgesDBetween(V, the_Vertices_of G \ V)) -
      Sum ((the_ELabel_of G) | G.edgesDBetween(the_Vertices_of G \ V, V))
      proof
    let G be finite real-weighted real-elabeled complete-elabeled WEGraph,
        source,sink be set, V be Subset of the_Vertices_of G; assume
A1: G has_valid_flow_from source,sink & source in V & not sink in V;
    set EL = the_ELabel_of G, VG = the_Vertices_of G;
    defpred P[Element of NAT] means
      for V being Subset of VG
       st card (the_Vertices_of G \ V) = $1 & source in V & not sink in V holds
       G.flow(source,sink) =
       Sum (EL | G.edgesDBetween(V, the_Vertices_of G \ V)) -
       Sum (EL | G.edgesDBetween(the_Vertices_of G \ V, V));
     now let V be Subset of the_Vertices_of G; assume
    A2: card (the_Vertices_of G \ V) = 1 & source in V & not sink in V;
        then consider v being set such that
    A3: the_Vertices_of G \ V = {v} by CARD_2:60;
         sink is Vertex of G by A1,Def7;
        then sink in the_Vertices_of G \ V by A2,XBOOLE_0:def 4;
    then A4: v = sink by A3,TARSKI:def 1;
    A5: now let x be set;
            hereby assume x in the_Vertices_of G \ {sink};
                then x in the_Vertices_of G & not x in {sink} by XBOOLE_0:def 4
;
                hence x in V by A3,A4,XBOOLE_0:def 4;
            end;
            assume
        A6: x in V;
            then not x in {sink} by A2,TARSKI:def 1;
            hence x in the_Vertices_of G \ {sink} by A6,XBOOLE_0:def 4;
        end;
    then A7: V = the_Vertices_of G \ {sink} by TARSKI:2;
        set ESS = G.edgesDBetween({sink},{sink});
        reconsider EIN = G.edgesInto({sink}) \ ESS as Subset of the_Edges_of G;
        reconsider EOUT= G.edgesOutOf({sink})\ ESS as Subset of the_Edges_of G;
        set EESS = (the_ELabel_of G)|ESS;
         now let e be set;
            hereby assume e in G.edgesDBetween(V, the_Vertices_of G \ V);
                then e DSJoins the_Vertices_of G \ {sink}, {sink},G
                  by A3,A4,A7,GLIB_000:def 33;
            then A8: e in the_Edges_of G &
                (the_Source_of G).e in the_Vertices_of G \ {sink} &
                (the_Target_of G).e in {sink} by GLIB_000:def 18;
            then A9: e in G.edgesInto({sink}) by GLIB_000:def 28;
                 now assume e in ESS;
                    then e DSJoins {sink},{sink},G by GLIB_000:def 33;
                    then (the_Source_of G).e in {sink} by GLIB_000:def 18;
                    hence contradiction by A8,XBOOLE_0:def 4;
                end;
                hence e in EIN by A9,XBOOLE_0:def 4;
            end;
            assume
        A10: e in EIN;
        then A11: e in G.edgesInto({sink}) & not e in ESS by XBOOLE_0:def 4;
         G.edgesInto({sink}) qua set \ ESS is Subset of G.edgesInto({sink});
        then A12: e in the_Edges_of G & (the_Target_of G).e in {sink}
              by A10,GLIB_000:def 28;
             now assume not (the_Source_of G).e in V;
            then A13: not (the_Source_of G).e in the_Vertices_of G \ {sink}
                  by A5;
                 (the_Source_of G).e in the_Vertices_of G
                  by A10,FUNCT_2:7;
                then (the_Source_of G).e in {sink}
                  by A13,XBOOLE_0:def 4;
                then e DSJoins {sink},{sink},G by A12,GLIB_000:def 18;
                hence contradiction by A11,GLIB_000:def 33;
            end;
            then e DSJoins V, {sink}, G by A12,GLIB_000:def 18;
            hence e in G.edgesDBetween(V, the_Vertices_of G \ V)
              by A3,A4,GLIB_000:def 33;
        end;
    then A14: G.edgesDBetween(V, the_Vertices_of G \ V) = EIN by TARSKI:2;
         now let e be set; assume e in ESS;
            then e DSJoins {sink},{sink},G by GLIB_000:def 33;
            then e in the_Edges_of G & (the_Target_of G).e in {sink}
              by GLIB_000:def 18;
            hence e in G.edgesInto({sink}) by GLIB_000:def 28;
        end;
    then A15: ESS c= G.edgesInto({sink}) by TARSKI:def 3;
    A16: ESS \/ EIN = G.edgesInto({sink}) \/ ESS by XBOOLE_1:39
                  .= G.edgesInto({sink}) by A15,XBOOLE_1:12;
    A17: dom (EL|G.edgesInto({sink})) = G.edgesInto({sink}) & dom (EL|ESS)=ESS
&
          dom (EL|EIN)=EIN & dom (EL|EOUT)=EOUT & dom (EL|G.edgesOutOf({sink}))
          = G.edgesOutOf({sink}) by PBOOLE:def 3;
    then A18: dom (EL|ESS +* EL|EIN) = ESS \/ EIN by FUNCT_4:def 1;
         now let e be set; assume
        A19: e in dom (EL|G.edgesInto({sink}));
        then A20: e in G.edgesInto({sink}) by PBOOLE:def 3;
             now per cases;
              suppose
            A21: e in ESS;
                then not e in EIN by XBOOLE_0:def 4;
                hence (EL|ESS +* EL|EIN).e = (EL|ESS).e by A17,FUNCT_4:12
                                          .= EL.e by A17,A21,FUNCT_1:70;

              end;
              suppose not e in ESS;
            then A22: e in EIN by A20,XBOOLE_0:def 4;
                hence (EL|ESS +* EL|EIN).e = (EL|EIN).e by A17,FUNCT_4:14
                                          .= EL.e by A17,A22,FUNCT_1:70;
              end;
            end;
            hence (the_ELabel_of G)|G.edgesInto({sink}).e =
              ((the_ELabel_of G)|ESS +* (the_ELabel_of G)|EIN).e
              by A19,FUNCT_1:70;
        end;
        then EL|G.edgesInto({sink}) = EL|ESS +* EL|EIN by A16,A17,A18,FUNCT_1:9
;
then A23: Sum (EL|G.edgesInto({sink})) = Sum (EL|EIN) + Sum EESS by GLIB_004:3;
         now let e be set;
            hereby assume e in G.edgesDBetween(the_Vertices_of G \ V, V);
                then e DSJoins {sink},(the_Vertices_of G \ {sink}),G
                  by A3,A4,A7,GLIB_000:def 33;
            then A24: e in the_Edges_of G & (the_Source_of G).e in {sink} &
                (the_Target_of G).e in (the_Vertices_of G \ {sink})
                  by GLIB_000:def 18;
            then A25: e in G.edgesOutOf({sink}) by GLIB_000:def 29;
                 now assume e in ESS;
                    then e DSJoins {sink},{sink},G by GLIB_000:def 33;
                    then (the_Target_of G).e in {sink} by GLIB_000:def 18;
                    hence contradiction by A24,XBOOLE_0:def 4;
                end;
                hence e in EOUT by A25,XBOOLE_0:def 4;
            end;
            assume
        A26: e in EOUT;
        then A27: e in G.edgesOutOf({sink}) & not e in ESS by XBOOLE_0:def 4;
         G.edgesOutOf({sink}) qua set \ ESS is Subset of G.edgesOutOf({sink});
        then A28: e in the_Edges_of G & (the_Source_of G).e in {sink}
              by A26,GLIB_000:def 29;
             now assume
            A29: not (the_Target_of G).e in V;
                 (the_Target_of G).e in the_Vertices_of G
                  by A26,FUNCT_2:7;
                then (the_Target_of G).e in {sink} by A7,A29,XBOOLE_0:def 4;
                then e DSJoins {sink},{sink},G by A28,GLIB_000:def 18;
                hence contradiction by A27,GLIB_000:def 33;
            end;
            then e DSJoins (the_Vertices_of G \ V),V,G by A3,A4,A28,
GLIB_000:def 18;
            hence e in G.edgesDBetween(the_Vertices_of G \ V, V)
              by GLIB_000:def 33;
        end;
    then A30: G.edgesDBetween(the_Vertices_of G \ V, V) = EOUT by TARSKI:2;
         now let e be set; assume e in ESS;
            then e DSJoins {sink},{sink},G by GLIB_000:def 33;
            then e in the_Edges_of G & (the_Source_of G).e in {sink}
              by GLIB_000:def 18;
            hence e in G.edgesOutOf({sink}) by GLIB_000:def 29;
        end;
    then A31: ESS c= G.edgesOutOf({sink}) by TARSKI:def 3;
         ESS \/ EOUT = G.edgesOutOf({sink}) \/ ESS by XBOOLE_1:39
                   .= G.edgesOutOf({sink}) by A31,XBOOLE_1:12;
    then A32: dom (EL|ESS +* EL|EOUT) = G.edgesOutOf({sink}) by A17,
FUNCT_4:def 1;
         now let e be set; assume
        A33: e in dom (EL|G.edgesOutOf({sink}));
        then A34: e in G.edgesOutOf({sink}) by PBOOLE:def 3;
             now per cases;
              suppose
            A35: e in ESS;
                then not e in EOUT by XBOOLE_0:def 4;
                hence (EL|ESS +* EL|EOUT).e = (EL|ESS).e by A17,FUNCT_4:12
                                           .= EL.e by A17,A35,FUNCT_1:70;
              end;
              suppose not e in ESS;
            then A36: e in EOUT by A34,XBOOLE_0:def 4;
                hence (EL|ESS +* EL|EOUT).e = (EL|EOUT).e by A17,FUNCT_4:14
                                           .= EL.e by A17,A36,FUNCT_1:70;
              end;
            end;
            hence EL|G.edgesOutOf({sink}).e = (EL|ESS +* EL|EOUT).e
              by A33,FUNCT_1:70;
        end;
        then EL|G.edgesOutOf({sink}) = EL|ESS +* EL|EOUT by A17,A32,FUNCT_1:9;
        then Sum (EL|G.edgesOutOf({sink})) = Sum (EL|EOUT)+Sum EESS by
GLIB_004:3;
        then G.flow(source,sink) = Sum (EL|EIN)+Sum EESS -(Sum EESS + Sum (EL|
EOUT))
                                by A1,A23,Def8
                           .= Sum (EL|EIN) - Sum (EL|EOUT);
        hence G.flow(source,sink) =
          Sum (EL | G.edgesDBetween(V, the_Vertices_of G \ V)) -
          Sum (EL | G.edgesDBetween(the_Vertices_of G \ V, V)) by A14,A30;
    end;
then A37: P[1];
A38: now let n be non empty Element of NAT; assume
    A39: P[n];
         now let V2 be Subset of VG; assume
        A40: card (VG\V2) = n+1 & source in V2 & not sink in V2;
            set x = choose ((VG \ V2) \ {sink});
            A41: V2 qua set \ {x} is Subset of V2;
             sink is Vertex of G by A1,Def7;
            then sink in (VG \ V2) by A40,XBOOLE_0:def 4;
            then {sink} c= (VG \ V2) by ZFMISC_1:37;
            then card ((VG\V2)\{sink}) = n+1-card {sink} by A40,CARD_2:63
                                 .= n+1-1 by CARD_1:79
                                 .= n;
        then A42: x in (VG)\V2 & not x in {sink} by CARD_1:78,XBOOLE_0:def 4;
        then A43: x in VG & not x in V2 by XBOOLE_0:def 4;
            set V1 = V2 \/ {x};
            set EV1V1a = G.edgesDBetween(V1, VG \ V1);
            set EV1V1b = G.edgesDBetween(VG \ V1, V1);
            set EV2X   = G.edgesDBetween(V2,{x});
            set EXV2   = G.edgesDBetween({x},V2);
            set EXV1c  = G.edgesDBetween({x},VG\V1);
            set EV1Xd  = G.edgesDBetween(VG\V1,{x});
             {x} c= VG by A42,ZFMISC_1:37;
            then reconsider V1 as Subset of VG by XBOOLE_1:8;
        A44: VG \ V1 = (VG \ V2) \ {x} by XBOOLE_1:41;
             {x} c= VG \ V2 by A42,ZFMISC_1:37;
        then A45: card (VG \ V1) = card (VG \ V2) - card {x} by A44,CARD_2:63
                          .= n + 1 - 1 by A40,CARD_1:79
                          .= n;
        A46: source in V1 by A40,XBOOLE_0:def 2;
        A47: x <> sink by A42,TARSKI:def 1;
            then not sink in {x} by TARSKI:def 1;
            then not sink in V1 by A40,XBOOLE_0:def 2;
        then A48: G.flow(source,sink) = Sum (EL|EV1V1a) - Sum (EL|EV1V1b)
              by A39,A45,A46;
             now let e be set;
                hereby assume e in G.edgesDBetween(V2, VG \ V2);
                    then e DSJoins V2, VG \ V2, G by GLIB_000:def 33;
                then A49: e in the_Edges_of G & (the_Source_of G).e in V2 &
                    (the_Target_of G).e in VG \ V2 by GLIB_000:def 18;
                then A50: (the_Source_of G).e in V1 by XBOOLE_0:def 2;
                A51: now assume e in EXV1c;
                        then e DSJoins {x},VG \ V1,G by GLIB_000:def 33;
                        then (the_Source_of G).e in {x} by GLIB_000:def 18;
                        hence contradiction by A43,A49,TARSKI:def 1;
                    end;
                     now per cases;
                      suppose (the_Target_of G).e in {x};
                        then e DSJoins V2,{x},G by A49,GLIB_000:def 18;
                        then e in EV2X by GLIB_000:def 33;
                        then e in EV1V1a \/ EV2X by XBOOLE_0:def 2;
                        hence e in EV1V1a \/ EV2X \ EXV1c by A51,XBOOLE_0:def 4
;
                      end;
                      suppose not (the_Target_of G).e in {x};
                        then (the_Target_of G).e in VG \ V1
                          by A44,A49,XBOOLE_0:def 4;
                        then e DSJoins V1, VG \ V1, G by A49,A50,
GLIB_000:def 18;
then e in EV1V1a by GLIB_000:def 33;
                        then e in EV1V1a \/ EV2X by XBOOLE_0:def 2;
                        hence e in EV1V1a \/ EV2X \ EXV1c by A51,XBOOLE_0:def 4
;
                      end;
                    end;
                    hence e in EV1V1a \/ EV2X \ EXV1c;
                end;
                assume
            A52: e in EV1V1a \/ EV2X \ EXV1c;
                then e in EV1V1a \/ EV2X & not e in EXV1c by XBOOLE_0:def 4;
            then A53: not e DSJoins {x}, VG \ V1,G by GLIB_000:def 33;
            A54: EV1V1a \/ EV2X qua set \ EXV1c is Subset of EV1V1a \/ EV2X;
                 now per cases by A52,A54,XBOOLE_0:def 2;
                  suppose e in EV1V1a;
                    then e DSJoins V1, VG\V1, G by GLIB_000:def 33;
                then A55: e in the_Edges_of G & (the_Source_of G).e in V1 &
                    (the_Target_of G).e in VG \ V1 by GLIB_000:def 18;
                    then not (the_Source_of G).e in {x} by A53,GLIB_000:def 18
;
                    then (the_Source_of G).e in V1 \ {x} by A55,XBOOLE_0:def 4
;
                then A56: (the_Source_of G).e in V2 \ {x} by XBOOLE_1:40;
                     (the_Target_of G).e in VG &
                      not (the_Target_of G).e in V1 by A55,XBOOLE_0:def 4;
then not (the_Target_of G).e in V2 by XBOOLE_0:def 2;
                    then (the_Target_of G).e in VG \ V2 by A55,XBOOLE_0:def 4;
                    hence e DSJoins V2, VG \ V2, G
                    by A41,A55,A56,GLIB_000:def 18;
                  end;
                  suppose e in EV2X;
                    then e DSJoins V2, {x}, G by GLIB_000:def 33;
                then A57: e in the_Edges_of G & (the_Source_of G).e in V2 &
                    (the_Target_of G).e in {x} by GLIB_000:def 18;
                then A58: (the_Target_of G).e in VG by FUNCT_2:7;
                     not (the_Target_of G).e in V2 by A43,A57,TARSKI:def 1;
                    then (the_Target_of G).e in VG \ V2 by A58,XBOOLE_0:def 4
;
                    hence e DSJoins V2, VG \ V2, G by A57,GLIB_000:def 18;
                  end;
                end;
                hence e in G.edgesDBetween(V2, VG \ V2) by GLIB_000:def 33;
            end;
        then A59: G.edgesDBetween(V2, VG \ V2) = EV1V1a \/ EV2X \ EXV1c
              by TARSKI:2;
            reconsider EA = EV1V1a \/ EV2X as Subset of the_Edges_of G;
            reconsider E1 = EA \ EXV1c as Subset of the_Edges_of G;
            reconsider EB = EA \ EV2X as Subset of the_Edges_of G;
            reconsider EC = EV1V1b \/ EXV2 as Subset of the_Edges_of G;
            reconsider E2 = EC \ EV1Xd as Subset of the_Edges_of G;
            reconsider ED = EC \ EXV2 as Subset of the_Edges_of G;
             now assume EV1V1a meets EV2X;
            then A60: EV1V1a /\ EV2X <> {} by XBOOLE_0:def 7;
                set e = choose (EV1V1a /\ EV2X);
                 e in EV1V1a & e in EV2X by A60,XBOOLE_0:def 3;
                then e DSJoins V1,VG\V1,G & e DSJoins V2,{x},G
                  by GLIB_000:def 33;
                then (the_Target_of G).e in VG \ V1 &
                  (the_Target_of G).e in {x} by GLIB_000:def 18;
                then not (the_Target_of G).e in V1 &
                (the_Target_of G).e in V1 by XBOOLE_0:def 2,def 4;
                hence contradiction;
            end;
            then EV1V1a \ EV2X = EV1V1a by XBOOLE_1:83;
        then A61: EB = EV1V1a by XBOOLE_1:40;
             now assume EV1V1b meets EXV2;
            then A62: EV1V1b /\ EXV2 <> {} by XBOOLE_0:def 7;
                set e = choose (EV1V1b /\ EXV2);
                 e in EV1V1b & e in EXV2 by A62,XBOOLE_0:def 3;
                then e DSJoins VG\V1,V1,G & e DSJoins {x},V2,G
                  by GLIB_000:def 33;
                then (the_Source_of G).e in VG \ V1 &
                  (the_Source_of G).e in {x} by GLIB_000:def 18;
                then not (the_Source_of G).e in V1 &
                (the_Source_of G).e in V1 by XBOOLE_0:def 2,def 4;
                hence contradiction;
            end;
            then EV1V1b \ EXV2 = EV1V1b by XBOOLE_1:83;
        then A63: ED = EV1V1b by XBOOLE_1:40;
             now let e be set; assume e in EXV1c;
                then e DSJoins {x},VG \ V1, G by GLIB_000:def 33;
            then A64: e in the_Edges_of G & (the_Source_of G).e in {x} &
                (the_Target_of G).e in VG \ V1 by GLIB_000:def 18;
                then (the_Source_of G).e in V1 by XBOOLE_0:def 2;
                then e DSJoins V1,VG \ V1, G by A64,GLIB_000:def 18;
                hence e in EV1V1a by GLIB_000:def 33;
            end;
            then EXV1c c= EV1V1a by TARSKI:def 3;
        then A65: EXV1c c= (EV1V1a \/ EV2X) by XBOOLE_1:10;
        A66: dom (EL|EA) = EA & dom (EL|EB) = EB & dom (EL|EXV1c) = EXV1c &
              dom (EL|EV2X)=EV2X & dom (EL|E1)=EA \ EXV1c by PBOOLE:def 3;
        then A67: dom (EL|EXV1c +* EL|E1) = EXV1c \/ (EA \ EXV1c) by
FUNCT_4:def 1
                                   .= EXV1c \/ (EV1V1a \/ EV2X) by XBOOLE_1:39
                                   .= EA by A65,XBOOLE_1:12;
             now let e be set; assume e in dom (EL|EA);
            then A68: e in EA by PBOOLE:def 3;
                 now per cases;
                  suppose not e in EXV1c;
                then A69: e in E1 by A68,XBOOLE_0:def 4;
                    hence (EL|EXV1c +* EL|E1).e = (EL|E1).e by A66,FUNCT_4:14
                                               .= EL.e by A69,FUNCT_1:72;
                  end;
                  suppose
                A70: e in EXV1c;
                    then not e in E1 by XBOOLE_0:def 4;
                    hence (EL|EXV1c +* EL|E1).e = (EL|EXV1c).e by A66,
FUNCT_4:12
                                               .= EL.e by A70,FUNCT_1:72;
                  end;
                end;
                hence (EL|EA).e = (EL|EXV1c +* EL|E1).e by A68,FUNCT_1:72;
            end;
            then EL|EA = EL|EXV1c +* EL|E1 by A66,A67,FUNCT_1:9;
            then A71: Sum (EL|EA) = Sum (EL|E1) + Sum (EL|EXV1c) by GLIB_004:3;
        A72: dom (EL|EV2X +* EL|EB) = EV2X \/ EB by A66,FUNCT_4:def 1
                                  .= EV2X \/ (EV1V1a \/ EV2X) by XBOOLE_1:39
                                  .= EA by XBOOLE_1:6;
             now let e be set; assume e in dom (EL|EA);
            then A73: e in EA by PBOOLE:def 3;
                 now per cases;
                  suppose not e in EV2X;
                then A74: e in EB by A73,XBOOLE_0:def 4;
                    hence (EL|EV2X +* EL|EB).e = (EL|EB).e by A66,FUNCT_4:14
                                               .= EL.e by A74,FUNCT_1:72;
                  end;
                  suppose
                A75: e in EV2X;
                    then not e in EB by XBOOLE_0:def 4;
                    hence (EL|EV2X +* EL|EB).e = (EL|EV2X).e by A66,FUNCT_4:12
                                               .= EL.e by A75,FUNCT_1:72;
                  end;
                end;
                hence (EL|EA).e = (EL|EV2X +* EL|EB).e by A73,FUNCT_1:72;
            end;
            then EL|EA = EL|EV2X +* EL|EB by A66,A72,FUNCT_1:9;
        then A76: Sum (EL|EA) = Sum (EL|EV2X) + Sum (EL|EV1V1a) by A61,
GLIB_004:3;
             now let e be set; assume e in EV1Xd;
                then e DSJoins VG\V1,{x}, G by GLIB_000:def 33;
            then A77: e in the_Edges_of G & (the_Target_of G).e in {x} &
                (the_Source_of G).e in VG \ V1 by GLIB_000:def 18;
                then (the_Target_of G).e in V1 by XBOOLE_0:def 2;
                then e DSJoins VG\V1,V1, G by A77,GLIB_000:def 18;
                hence e in EV1V1b by GLIB_000:def 33;
            end;
            then EV1Xd c= EV1V1b by TARSKI:def 3;
        then A78: EV1Xd c= (EV1V1b \/ EXV2) by XBOOLE_1:10;
             now let e be set;
                hereby assume e in G.edgesDBetween(VG \ V2, V2);
                    then e DSJoins VG\V2, V2, G by GLIB_000:def 33;
                then A79: e in the_Edges_of G & (the_Target_of G).e in V2 &
                    (the_Source_of G).e in VG \ V2 by GLIB_000:def 18;
                then A80: (the_Target_of G).e in V1 by XBOOLE_0:def 2;
                A81: now assume e in EV1Xd;
                        then e DSJoins VG \ V1,{x},G by GLIB_000:def 33;
                        then (the_Target_of G).e in {x} by GLIB_000:def 18;
                        hence contradiction by A43,A79,TARSKI:def 1;
                    end;
                     now per cases;
                      suppose (the_Source_of G).e in {x};
                        then e DSJoins {x},V2,G by A79,GLIB_000:def 18;
                        then e in EXV2 by GLIB_000:def 33;
                        then e in EV1V1b \/ EXV2 by XBOOLE_0:def 2;
                        hence e in EV1V1b \/ EXV2 \ EV1Xd by A81,XBOOLE_0:def 4
;
                      end;
                      suppose not (the_Source_of G).e in {x};
                        then (the_Source_of G).e in VG \ V1
                          by A44,A79,XBOOLE_0:def 4;
                        then e DSJoins VG \ V1, V1, G by A79,A80,
GLIB_000:def 18;
then e in EV1V1b by GLIB_000:def 33;
                        then e in EV1V1b \/ EXV2 by XBOOLE_0:def 2;
                        hence e in EV1V1b \/ EXV2 \ EV1Xd by A81,XBOOLE_0:def 4
;
                      end;
                    end;
                    hence e in EV1V1b \/ EXV2 \ EV1Xd;
                end;
                assume
            A82: e in EV1V1b \/ EXV2 \ EV1Xd;
                then e in EV1V1b \/ EXV2 & not e in EV1Xd by XBOOLE_0:def 4;
            then A83: not e DSJoins VG \ V1, {x}, G by GLIB_000:def 33;
            A84: EV1V1b \/ EXV2 qua set \ EV1Xd is Subset of EV1V1b \/ EXV2;
                 now per cases by A82,A84,XBOOLE_0:def 2;
                  suppose e in EV1V1b;
                    then e DSJoins VG\V1, V1, G by GLIB_000:def 33;
                then A85: e in the_Edges_of G & (the_Target_of G).e in V1 &
                    (the_Source_of G).e in VG \ V1 by GLIB_000:def 18;
                    then not (the_Target_of G).e in {x} by A83,GLIB_000:def 18
;
                    then (the_Target_of G).e in V1 \ {x} by A85,XBOOLE_0:def 4
;
                then A86: (the_Target_of G).e in V2 \ {x} by XBOOLE_1:40;
                     (the_Source_of G).e in VG &
                      not (the_Source_of G).e in V1 by A85,XBOOLE_0:def 4;
then not (the_Source_of G).e in V2 by XBOOLE_0:def 2;
                    then (the_Source_of G).e in VG \ V2 by A85,XBOOLE_0:def 4;
                    hence e DSJoins VG \ V2, V2, G
                    by A41,A85,A86,GLIB_000:def 18;
                  end;
                  suppose e in EXV2;
                    then e DSJoins {x},V2, G by GLIB_000:def 33;
                then A87: e in the_Edges_of G & (the_Target_of G).e in V2 &
                    (the_Source_of G).e in {x} by GLIB_000:def 18;
                then A88: (the_Source_of G).e in VG by FUNCT_2:7;
                     not (the_Source_of G).e in V2 by A43,A87,TARSKI:def 1;
                    then (the_Source_of G).e in VG \ V2 by A88,XBOOLE_0:def 4
;
                    hence e DSJoins VG \ V2, V2, G by A87,GLIB_000:def 18;
                  end;
                end;
                hence e in G.edgesDBetween(VG\V2,V2) by GLIB_000:def 33;
            end;
        then A89: G.edgesDBetween(VG \ V2, V2) = E2 by TARSKI:2;
        A90: dom (EL|EC) = EC & dom (EL|ED) = ED & dom (EL|EV1Xd) = EV1Xd &
              dom (EL|EXV2)=EXV2 & dom (EL|E2)=EC\EV1Xd by PBOOLE:def 3;
        then A91: dom (EL|EV1Xd +* EL|E2) = EV1Xd \/ (EC \ EV1Xd) by
FUNCT_4:def 1
                                   .= EV1Xd \/ (EV1V1b \/ EXV2) by XBOOLE_1:39
                                   .= EC by A78,XBOOLE_1:12;
             now let e be set; assume e in dom (EL|EC);
            then A92: e in EC by PBOOLE:def 3;
                 now per cases;
                  suppose not e in EV1Xd;
                then A93: e in E2 by A92,XBOOLE_0:def 4;
                    hence (EL|EV1Xd +* EL|E2).e = (EL|E2).e by A90,FUNCT_4:14
                                               .= EL.e by A93,FUNCT_1:72;
                  end;
                  suppose
                A94: e in EV1Xd;
                    then not e in E2 by XBOOLE_0:def 4;
                    hence (EL|EV1Xd +* EL|E2).e = (EL|EV1Xd).e by A90,
FUNCT_4:12
                                               .= EL.e by A94,FUNCT_1:72;
                  end;
                end;
                hence (EL|EC).e = (EL|EV1Xd +* EL|E2).e by A92,FUNCT_1:72;
            end;
            then EL|EC = EL|EV1Xd +* EL|E2 by A90,A91,FUNCT_1:9;
            then A95: Sum (EL|EC) = Sum (EL|E2) + Sum (EL|EV1Xd) by GLIB_004:3;
        A96: dom (EL|EXV2 +* EL|ED) = EXV2 \/ ED by A90,FUNCT_4:def 1
                                  .= EXV2 \/ (EV1V1b \/ EXV2) by XBOOLE_1:39
                                  .= EC by XBOOLE_1:6;
             now let e be set; assume e in dom (EL|EC);
            then A97: e in EC by PBOOLE:def 3;
                 now per cases;
                  suppose not e in EXV2;
                then A98: e in ED by A97,XBOOLE_0:def 4;
                    hence (EL|EXV2 +* EL|ED).e = (EL|ED).e by A90,FUNCT_4:14
                                               .= EL.e by A98,FUNCT_1:72;
                  end;
                  suppose
                A99: e in EXV2;
                    then not e in ED by XBOOLE_0:def 4;
                    hence (EL|EXV2 +* EL|ED).e = (EL|EXV2).e by A90,FUNCT_4:12
                                               .= EL.e by A99,FUNCT_1:72;
                  end;
                end;
                hence (EL|EC).e = (EL|EXV2 +* EL|ED).e by A97,FUNCT_1:72;
            end;
            then EL|EC = EL|EXV2 +* EL|ED by A90,A96,FUNCT_1:9;
        then A100: Sum (EL|EC) = Sum (EL|EXV2) + Sum (EL|EV1V1b) by A63,
GLIB_004:3;

            set EXXe = G.edgesDBetween({x}, VG \ {x});
            set EXXf = G.edgesDBetween(VG \ {x}, {x});
         now let e be set;
                hereby assume e in EXXf \ EV2X;
                    then e in EXXf & not e in EV2X by XBOOLE_0:def 4;
                then A101: e DSJoins VG \ {x}, {x}, G & not e DSJoins V2, {x},
G
                      by GLIB_000:def 33;
                then A102: e in the_Edges_of G & (the_Source_of G).e in VG \ {x
} &
                    (the_Target_of G).e in {x} by GLIB_000:def 18;
                then A103: not (the_Source_of G).e in V2 by A101,
GLIB_000:def 18;
                     (the_Source_of G).e in VG & not (the_Source_of G).e in {x}
                      by A102,XBOOLE_0:def 4;
                    then not (the_Source_of G).e in V1 by A103,XBOOLE_0:def 2;
                    then (the_Source_of G).e in VG \ V1 by A102,XBOOLE_0:def 4;
then e DSJoins VG \ V1, {x}, G by A102,GLIB_000:def 18;
                    hence e in EV1Xd by GLIB_000:def 33;
                end;
                assume e in EV1Xd;
                then e DSJoins VG \ V1, {x}, G by GLIB_000:def 33;
            then A104: e in the_Edges_of G & (the_Source_of G).e in VG \ V1 &
                  (the_Target_of G).e in {x} by GLIB_000:def 18;
            then A105: (the_Source_of G).e in VG & not (the_Source_of G).e in
V1
                  by XBOOLE_0:def 4;
                then not (the_Source_of G).e in V2 by XBOOLE_0:def 2;
                then not e DSJoins V2,{x},G by GLIB_000:def 18;
            then A106: not e in EV2X by GLIB_000:def 33;
                 not (the_Source_of G).e in {x} by A105,XBOOLE_0:def 2;
                then (the_Source_of G).e in VG \ {x} by A104,XBOOLE_0:def 4;
                then e DSJoins VG \ {x}, {x}, G by A104,GLIB_000:def 18;
                then e in EXXf by GLIB_000:def 33;
                hence e in EXXf \ EV2X by A106,XBOOLE_0:def 4;
            end;
        then A107: EXXf \ EV2X = EV1Xd by TARSKI:2;
            reconsider EV1Xdb = EXXf \ EV2X as Subset of the_Edges_of G;
             now let e be set; assume e in EV2X;
                then e DSJoins V2,{x},G by GLIB_000:def 33;
            then A108: e in the_Edges_of G & (the_Source_of G).e in V2 &
                  (the_Target_of G).e in {x} by GLIB_000:def 18;
                then not (the_Source_of G).e in {x} by A43,TARSKI:def 1;
                then (the_Source_of G).e in VG \ {x} by A108,XBOOLE_0:def 4;
                then e DSJoins VG\{x}, {x}, G by A108,GLIB_000:def 18;
                hence e in EXXf by GLIB_000:def 33;
            end;
        then A109: EV2X c= EXXf by TARSKI:def 3;
        A110: dom (EL|EXXf) = EXXf & dom (EL|EV2X) = EV2X &
              dom (EL|EV1Xdb) = EXXf \ EV2X by PBOOLE:def 3;
        then A111: dom (EL|EV2X +* EL|(EXXf \ EV2X)) = EV2X \/ (EXXf \ EV2X)
                                                  by FUNCT_4:def 1
                                             .= EV2X \/ EXXf by XBOOLE_1:39
                                             .= EXXf by A109,XBOOLE_1:12;
             now let e be set; assume
            A112: e in dom (EL|EXXf);
            then A113: e in EXXf by PBOOLE:def 3;
                 now per cases;
                  suppose
                A114: e in EV2X;
                    then not e in EV1Xdb by XBOOLE_0:def 4;
                    hence (EL|EV2X +* EL|EV1Xdb).e=(EL|EV2X).e by A110,
FUNCT_4:12
                                                 .=EL.e by A114,FUNCT_1:72;
                  end;
                  suppose not e in EV2X;
                then A115: e in EV1Xdb by A113,XBOOLE_0:def 4;
                    hence (EL|EV2X +* EL|EV1Xdb).e = (EL|EV1Xdb).e
                                                     by A110,FUNCT_4:14
                                                 .= EL.e by A115,FUNCT_1:72;
                  end;
                end;
                hence (EL|EXXf).e = (EL|EV2X +* EL|EV1Xdb).e
                  by A110,A112,FUNCT_1:72;
            end;
            then EL|EXXf = EL|EV2X +* EL|(EXXf \ EV2X) by A110,A111,FUNCT_1:9;
        then A116: Sum (EL|EV2X) + Sum (EL|EV1Xd) = Sum (EL|EXXf)
              by A107,GLIB_004:3;
         now let e be set;
                hereby assume e in EXXe \ EXV2;
                    then e in EXXe & not e in EXV2 by XBOOLE_0:def 4;
                then A117: e DSJoins {x},VG\{x}, G & not e DSJoins {x},V2,G
                      by GLIB_000:def 33;
                then A118: e in the_Edges_of G & (the_Target_of G).e in VG \ {x
} &
                    (the_Source_of G).e in {x} by GLIB_000:def 18;
                then A119: not (the_Target_of G).e in V2 by A117,
GLIB_000:def 18;
                     (the_Target_of G).e in VG & not (the_Target_of G).e in {x}
                      by A118,XBOOLE_0:def 4;
                    then not (the_Target_of G).e in V1 by A119,XBOOLE_0:def 2;
                    then (the_Target_of G).e in VG \ V1 by A118,XBOOLE_0:def 4;
then e DSJoins {x}, VG \ V1, G by A118,GLIB_000:def 18;
                    hence e in EXV1c by GLIB_000:def 33;
                end;
                assume e in EXV1c;
                then e DSJoins {x}, VG \ V1, G by GLIB_000:def 33;
            then A120: e in the_Edges_of G & (the_Target_of G).e in VG \ V1 &
                (the_Source_of G).e in {x} by GLIB_000:def 18;
            then A121: (the_Target_of G).e in VG & not (the_Target_of G).e in
V1
                  by XBOOLE_0:def 4;
                then not (the_Target_of G).e in V2 by XBOOLE_0:def 2;
                then not e DSJoins {x},V2,G by GLIB_000:def 18;
            then A122: not e in EXV2 by GLIB_000:def 33;
                 not (the_Target_of G).e in {x} by A121,XBOOLE_0:def 2;
                then (the_Target_of G).e in VG \ {x} by A120,XBOOLE_0:def 4;
                then e DSJoins {x}, VG \ {x}, G by A120,GLIB_000:def 18;
                then e in EXXe by GLIB_000:def 33;
                hence e in EXXe \ EXV2 by A122,XBOOLE_0:def 4;
            end;
        then A123: EXXe \ EXV2 = EXV1c by TARSKI:2;
            reconsider EXV1cb = EXXe \ EXV2 as Subset of the_Edges_of G;
             now let e be set; assume e in EXV2;
                then e DSJoins {x},V2,G by GLIB_000:def 33;
            then A124: e in the_Edges_of G & (the_Target_of G).e in V2 &
                  (the_Source_of G).e in {x} by GLIB_000:def 18;
                then not (the_Target_of G).e in {x} by A43,TARSKI:def 1;
                then (the_Target_of G).e in VG \ {x} by A124,XBOOLE_0:def 4;
                then e DSJoins {x},VG\{x}, G by A124,GLIB_000:def 18;
                hence e in EXXe by GLIB_000:def 33;
            end;
        then A125: EXV2 c= EXXe by TARSKI:def 3;
        A126: dom (EL|EXXe) = EXXe & dom (EL|EXV2) = EXV2 &
              dom (EL|EXV1cb) = EXXe \ EXV2 by PBOOLE:def 3;
        then A127: dom (EL|EXV2 +* EL|(EXXe \ EXV2)) = EXV2 \/ (EXXe \ EXV2)
                                                  by FUNCT_4:def 1
                                             .= EXV2 \/ EXXe by XBOOLE_1:39
                                             .= EXXe by A125,XBOOLE_1:12;
             now let e be set; assume
            A128: e in dom (EL|EXXe);
            then A129: e in EXXe by PBOOLE:def 3;
                 now per cases;
                  suppose
                A130: e in EXV2;
                    then not e in EXV1cb by XBOOLE_0:def 4;
                    hence (EL|EXV2 +* EL|EXV1cb).e=(EL|EXV2).e by A126,
FUNCT_4:12
                                                 .=EL.e by A130,FUNCT_1:72;
                  end;
                  suppose not e in EXV2;
                then A131: e in EXV1cb by A129,XBOOLE_0:def 4;
                    hence (EL|EXV2 +* EL|EXV1cb).e = (EL|EXV1cb).e
                                                     by A126,FUNCT_4:14
                                                  .= EL.e by A131,FUNCT_1:72;
                  end;
                end;
                hence (EL|EXXe).e = (EL|EXV2 +* EL|EXV1cb).e
                  by A126,A128,FUNCT_1:72;
            end;
            then EL|EXXe = EL|EXV2 +* EL|(EXXe \ EXV2) by A126,A127,FUNCT_1:9;
        then A132: Sum (EL|EXV2) + Sum (EL|EXV1c) = Sum (EL|EXXe) by A123,
GLIB_004:3;
            reconsider x as Vertex of G by A42;
             x.edgesIn() = G.edgesDBetween(VG,{x}) &
              x.edgesOut() = G.edgesDBetween({x},VG) by GLIB_000:42;
        then A133: Sum (EL|G.edgesDBetween(VG,{x}))= Sum (EL|G.edgesDBetween({x
},VG)
)
              by A1,A40,A43,A47,Def7;
         now let e be set;
                hereby assume e in G.edgesDBetween(VG,{x}) \
                                   G.edgesDBetween({x},{x});
                    then e in G.edgesDBetween(VG,{x}) &
                    not e in G.edgesDBetween({x},{x}) by XBOOLE_0:def 4;
                then A134: e DSJoins VG,{x},G & not e DSJoins {x},{x},G
                      by GLIB_000:def 33;
                then A135: e in the_Edges_of G & (the_Source_of G).e in VG &
                    (the_Target_of G).e in {x} by GLIB_000:def 18;
                    then not (the_Source_of G).e in {x} by A134,GLIB_000:def 18
;
then (the_Source_of G).e in VG\{x} by A135,XBOOLE_0:def 4;
                    then e DSJoins VG\{x},{x},G by A135,GLIB_000:def 18;
                    hence e in EXXf by GLIB_000:def 33;
                end;
                assume e in EXXf;
                then e DSJoins VG \{x}, {x}, G by GLIB_000:def 33;
            then A136: e in the_Edges_of G & (the_Source_of G).e in VG \ {x} &
                (the_Target_of G).e in {x} by GLIB_000:def 18;
                then (the_Source_of G).e in VG & not (the_Source_of G).e in {x
}
                  by XBOOLE_0:def 4;
                then not e DSJoins {x},{x},G by GLIB_000:def 18;
            then A137: not e in G.edgesDBetween({x},{x}) by GLIB_000:def 33;
                 e DSJoins VG,{x},G by A136,GLIB_000:def 18;
                then e in G.edgesDBetween(VG,{x}) by GLIB_000:def 33;
                hence e in G.edgesDBetween(VG,{x}) \ G.edgesDBetween({x},{x})
                  by A137,XBOOLE_0:def 4;
            end;
        then A138: G.edgesDBetween(VG,{x}) \ G.edgesDBetween({x},{x}) = EXXf
              by TARSKI:2;
            reconsider EXXfb = G.edgesDBetween(VG,{x})\G.edgesDBetween({x},{x})
              as Subset of the_Edges_of G;
        A139: G.edgesDBetween({x},{x}) c= G.edgesDBetween(VG,{x}) by
GLIB_000:41;
        A140: dom (EL|G.edgesDBetween(VG,{x})) = G.edgesDBetween(VG,{x}) &
              dom (EL|G.edgesDBetween({x},{x})) = G.edgesDBetween({x},{x}) &
              dom (EL|EXXfb) = EXXfb by PBOOLE:def 3;
        then A141: dom (EL|G.edgesDBetween({x},{x}) +* EL|EXXfb)
              = G.edgesDBetween({x},{x}) \/ EXXfb by FUNCT_4:def 1
             .= G.edgesDBetween({x},{x}) \/ G.edgesDBetween(VG,{x})
                by XBOOLE_1:39
             .= G.edgesDBetween(VG,{x}) by A139,XBOOLE_1:12;
             now let e be set; assume e in dom (EL|G.edgesDBetween(VG,{x}));
            then A142: e in G.edgesDBetween(VG,{x}) by PBOOLE:def 3;
                 now per cases;
                  suppose
                A143: e in G.edgesDBetween({x},{x});
                    then not e in EXXfb by XBOOLE_0:def 4;
                    hence (EL|G.edgesDBetween({x},{x}) +* EL|EXXfb).e
                      = (EL|G.edgesDBetween({x},{x})).e by A140,FUNCT_4:12
                     .= EL.e by A143,FUNCT_1:72;
                  end;
                  suppose not e in G.edgesDBetween({x},{x});
                then A144: e in EXXfb by A142,XBOOLE_0:def 4;
                    hence (EL|G.edgesDBetween({x},{x}) +* EL|EXXfb).e
                      = (EL|EXXfb).e by A140,FUNCT_4:14
                     .= EL.e by A144,FUNCT_1:72;
                  end;
                end;
                hence (EL|G.edgesDBetween(VG,{x})).e =
                  (EL|G.edgesDBetween({x},{x}) +* EL|EXXfb).e by A142,
FUNCT_1:72;
            end;
            then EL|G.edgesDBetween(VG,{x}) =
              EL|G.edgesDBetween({x},{x}) +* EL|EXXfb by A140,A141,FUNCT_1:9;
then A145: Sum (EL|G.edgesDBetween(VG,{x})) =
            Sum (EL|EXXf) + Sum (EL|G.edgesDBetween({x},{x})) by A138,
GLIB_004:3;

        now let e be set;
                hereby assume e in G.edgesDBetween({x},VG) \
                                   G.edgesDBetween({x},{x});
                    then e in G.edgesDBetween({x},VG) &
                    not e in G.edgesDBetween({x},{x}) by XBOOLE_0:def 4;
                then A146: e DSJoins {x},VG,G & not e DSJoins {x},{x},G
                      by GLIB_000:def 33;
                then A147: e in the_Edges_of G & (the_Target_of G).e in VG &
                    (the_Source_of G).e in {x} by GLIB_000:def 18;
                    then not (the_Target_of G).e in {x} by A146,GLIB_000:def 18
;
then (the_Target_of G).e in VG\{x} by A147,XBOOLE_0:def 4;
                    then e DSJoins {x},VG\{x},G by A147,GLIB_000:def 18;
                    hence e in EXXe by GLIB_000:def 33;
                end;
                assume e in EXXe;
                then e DSJoins {x}, VG \{x}, G by GLIB_000:def 33;
            then A148: e in the_Edges_of G & (the_Target_of G).e in VG \ {x} &
                (the_Source_of G).e in {x} by GLIB_000:def 18;
                then (the_Target_of G).e in VG & not (the_Target_of G).e in {x
}
                  by XBOOLE_0:def 4;
                then not e DSJoins {x},{x},G by GLIB_000:def 18;
            then A149: not e in G.edgesDBetween({x},{x}) by GLIB_000:def 33;
                 e DSJoins {x},VG,G by A148,GLIB_000:def 18;
                then e in G.edgesDBetween({x},VG) by GLIB_000:def 33;
                hence e in G.edgesDBetween({x},VG) \ G.edgesDBetween({x},{x})
                  by A149,XBOOLE_0:def 4;
            end;
        then A150: G.edgesDBetween({x},VG) \ G.edgesDBetween({x},{x}) = EXXe
              by TARSKI:2;
            reconsider EXXeb = G.edgesDBetween({x},VG)\G.edgesDBetween({x},{x})
              as Subset of the_Edges_of G;
        A151: G.edgesDBetween({x},{x}) c= G.edgesDBetween({x},VG) by
GLIB_000:41;
        A152: dom (EL|G.edgesDBetween({x},VG)) = G.edgesDBetween({x},VG) &
              dom (EL|EXXeb) = EXXeb by PBOOLE:def 3;
        then A153: dom (EL|G.edgesDBetween({x},{x}) +* EL|EXXeb)
              = G.edgesDBetween({x},{x}) \/ EXXeb by A140,FUNCT_4:def 1
             .= G.edgesDBetween({x},{x}) \/ G.edgesDBetween({x},VG)
                by XBOOLE_1:39
             .= G.edgesDBetween({x},VG) by A151,XBOOLE_1:12;
             now let e be set; assume e in dom (EL|G.edgesDBetween({x},VG));
            then A154: e in G.edgesDBetween({x},VG) by PBOOLE:def 3;
                 now per cases;
                  suppose
                A155: e in G.edgesDBetween({x},{x});
                    then not e in EXXeb by XBOOLE_0:def 4;
                    hence (EL|G.edgesDBetween({x},{x}) +* EL|EXXeb).e
                      = (EL|G.edgesDBetween({x},{x})).e by A152,FUNCT_4:12
                     .= EL.e by A155,FUNCT_1:72;
                  end;
                  suppose not e in G.edgesDBetween({x},{x});
                then A156: e in EXXeb by A154,XBOOLE_0:def 4;
                    hence (EL|G.edgesDBetween({x},{x}) +* EL|EXXeb).e
                      = (EL|EXXeb).e by A152,FUNCT_4:14
                     .= EL.e by A156,FUNCT_1:72;
                  end;
                end;
                hence (EL|G.edgesDBetween({x},VG)).e =
                  (EL|G.edgesDBetween({x},{x}) +* EL|EXXeb).e by A154,
FUNCT_1:72;
            end;
            then EL|G.edgesDBetween({x},VG) =
              EL|G.edgesDBetween({x},{x}) +* EL|EXXeb by A152,A153,FUNCT_1:9;
then Sum (EL|G.edgesDBetween({x},VG)) =
              Sum (EL|EXXe) + Sum (EL|G.edgesDBetween({x},{x}))
              by A150,GLIB_004:3;
            hence G.flow(source,sink) =
              Sum(EL | G.edgesDBetween(V2, VG \ V2)) -
              Sum(EL | G.edgesDBetween(VG \ V2, V2)) by A48,A59,A71,A76,A89,A95
,A100,A116,A132,A133,A145;
        end;
        hence P[n+1];
    end;
A157: for n being non empty Element of NAT holds P[n]
from BINARITH:sch 1(A37,A38);
    set n = card (VG \ V);
     now assume n = 0;
    then A158: VG \ V = {} by CARD_2:59;
         sink is Vertex of G by A1,Def7;
        hence contradiction by A1,A158,XBOOLE_0:def 4;
    end;
    hence thesis by A1,A157;
end;

theorem Th12: ::tFLOW02
  for G being finite real-weighted real-elabeled complete-elabeled WEGraph,
      source,sink being set, V being Subset of the_Vertices_of G
   st G has_valid_flow_from source,sink &
      source in V & not sink in V holds
      G.flow(source,sink) <=
      Sum ((the_Weight_of G) | G.edgesDBetween(V,the_Vertices_of G \ V)) proof
    let G be finite real-weighted real-elabeled complete-elabeled WEGraph,
        source,sink be set, V be Subset of the_Vertices_of G; assume
A1: G has_valid_flow_from source,sink & source in V & not sink in V;
    set E1 = (the_ELabel_of G) | G.edgesDBetween(V, the_Vertices_of G \ V);
    set E2 = (the_ELabel_of G) | G.edgesDBetween(the_Vertices_of G \ V, V);
    set W1 = (the_Weight_of G) | G.edgesDBetween(V, the_Vertices_of G \ V);
    set B1 = EmptyBag G.edgesDBetween(the_Vertices_of G \ V, V);
A2: G.flow(source,sink) = Sum E1 - Sum E2 by A1,Th11;
     now let e be set; assume
    A3: e in G.edgesDBetween(V, the_Vertices_of G\V);
        then E1.e = (the_ELabel_of G).e & W1.e = (the_Weight_of G).e by
FUNCT_1:72;
        hence E1.e <= W1.e by A1,A3,Def7;
    end;
then A4: Sum E1 <= Sum W1 by GLIB_004:5;
A5: Sum B1 = 0 by UPROOTS:13;
     now let e be set; assume
    A6: e in G.edgesDBetween(the_Vertices_of G \ V, V);
        then E2.e = (the_ELabel_of G).e by FUNCT_1:72;
    then A7: 0 <= E2.e by A1,A6,Def7;
         B1 = G.edgesDBetween(the_Vertices_of G \ V, V)-->0
          by POLYNOM1:def 15;
        hence B1.e <= E2.e by A6,A7,FUNCOP_1:13;
    end;
    then 0 <= Sum E2 by A5,GLIB_004:5;
then A8: Sum W1 - Sum E2 <= Sum W1 - 0 by REAL_1:92;
     Sum E1 - Sum E2 <= Sum W1 - Sum E2 by A4,XREAL_1:11;
    hence G.flow(source,sink) <= Sum W1 by A2,A8,XXREAL_0:2;
end;

theorem  ::tFLOWAUG03
  for G being real-weighted real-elabeled WEGraph, P being augmenting Path of G
   holds G == FF:AugmentPath(G,P) &
         the_Weight_of G = the_Weight_of FF:AugmentPath(G,P)
          by GLIB_000:12,GLIB_003:8;

theorem Th14: ::tWTOLERANCE01
  for G being finite real-weighted real-elabeled WEGraph,
      W being augmenting Walk of G st W is non trivial holds
      0 < W.tolerance() proof
    let G be finite real-weighted real-elabeled WEGraph,
        W be augmenting Walk of G such that
A1: W is non trivial; set T = W.tolerance();
     T in rng W.flowSeq() & for k being Real st k in rng W.flowSeq() holds
      T <= k by A1,Def19; then consider n being Nat such that
A2: n in dom W.flowSeq() & T = (W.flowSeq()).n by FINSEQ_2:11;
   reconsider n as Element of NAT by ORDINAL1:def 13;
     dom W.flowSeq() = dom W.edgeSeq() by Def18;
    then 2*n in dom W by A2,GLIB_001:79;
then A3: 1 <= 2*n & 2*n <= len W by FINSEQ_3:27;
    then reconsider 2n1 = 2*n-1 as odd Element of NAT by INT_1:18;
A4: 2*n-1 < len W - 0 by A3,REAL_1:92;
    set v1 = W.(2n1), e = W.(2*n), v2 = W.(2*n+1);
A5: 2*n-1 + 1 = 2*n & 2*n-1 + 2 = 2*n+1;
     now per cases;
      suppose
    A6: e DJoins v1,v2,G;
    then A7: T = (the_Weight_of G).e - (the_ELabel_of G).e by A2,Def18;
         (the_ELabel_of G).e < (the_Weight_of G).e by A4,A5,A6,Def12;
        then (the_ELabel_of G).e - (the_ELabel_of G).e < T by A7,REAL_1:92;
        hence 0 < T;
      end;
      suppose
    A8: not e DJoins v1,v2,G;
        then T = (the_ELabel_of G).e by A2,Def18;
        hence 0 < T by A4,A5,A8,Def12;
      end;
    end;
    hence 0 < T;
end;

theorem Th15: ::tFLOWAUG02
  for G being finite real-weighted real-elabeled complete-elabeled WEGraph,
      source,sink being set, P being augmenting Path of G
   st source <> sink & G has_valid_flow_from source,sink &
      P is_Walk_from source,sink
   holds FF:AugmentPath(G,P) has_valid_flow_from source,sink proof
    let G be finite real-weighted real-elabeled complete-elabeled WEGraph,
        source,sink be set, P be augmenting Path of G; assume
A1: source <> sink & G has_valid_flow_from source,sink &
    P is_Walk_from source,sink;
    set G2 = FF:AugmentPath(G,P);
A2: G2 == G & the_Weight_of G = the_Weight_of G2 by GLIB_000:12,GLIB_003:8;
    set EL1 = the_ELabel_of G, EL2 = the_ELabel_of G2;
A3: EL2 = FF:PushFlow(G,P) by GLIB_000:11;
     now source is Vertex of G & sink is Vertex of G by A1,Def7;
        hence source is Vertex of G2 & sink is Vertex of G2
          by GLIB_000:12;
         now let e be set; assume e in the_Edges_of G2;
        then A4: e in the_Edges_of G by GLIB_000:12;
        then A5: 0 <= EL1.e & EL1.e <= (the_Weight_of G).e by A1,Def7;
             now per cases;
              suppose not e in P.edges();
                 hence 0 <= (the_ELabel_of G2).e &
                    (the_ELabel_of G2).e <= (the_Weight_of G2).e
                    by A2,A3,A4,A5,Def20;
              end;
              suppose e in P.edges(); then consider n being odd Element of NAT
              such that
            A6: n < len P & P.(n+1) = e by GLIB_001:101;
            A7: e Joins P.n,P.(n+2),G by A6,GLIB_001:def 3;
                 P.first() = source & P.last() = sink by A1,GLIB_001:def 23;
            then A8: P is non trivial by A1,GLIB_001:128;
            then A9: 0 < P.tolerance() by Th14;
            A10: now assume e DJoins P.n,P.(n+2),G & e DJoins P.(n+2),P.n,G;
then A11: (the_Source_of G).e = P.n & (the_Source_of G).e = P.(n+2)
                      by GLIB_000:def 16;
                A12: n + 0 < n+2 by XREAL_1:10;
                     n+2 <= len P by A6,GLIB_001:1;
                    then n = 1 & n+2 = len P by A11,A12,GLIB_001:def 28;
                    then P.n = source & P.(n+2) = sink by A1,GLIB_001:18;
                    hence contradiction by A1,A11;
                end;
                set PFS = P.flowSeq(), n1div2 = (n+1) div 2;
                 1 <= n+1 & n+1 <= len P by A6,NAT_1:11,13;
                then n1div2 in dom P.edgeSeq() & P.(n+1) = P.edgeSeq().n1div2
                  by GLIB_001:78;
            then A13: n1div2 in dom PFS by Def18;
                 2 divides n+1 by PEPIN:22;
            then A14: 2 * n1div2 = n+1 by NAT_D:3;
            then A15: 2 * n1div2 - 1 = n;
            A16: 2 * n1div2 + 1 = n + 2 by A14;
                 now per cases by A7,GLIB_000:19;
                  suppose
                A17: e DJoins P.n,P.(n+2),G;
                then A18: EL1.e + P.tolerance() = EL2.e by A3,A6,Def20;
                     0 + 0 <= EL1.e + P.tolerance() by A5,A9,XREAL_1:9;
                    hence 0 <= EL2.e by A3,A6,A17,Def20;
                     PFS.n1div2 = (the_Weight_of G).e - EL1.e
                      by A6,A13,A15,A16,A17,Def18;
                    then (the_Weight_of G2).e - EL1.e in rng PFS
                      by A2,A13,FUNCT_1:def 5;
                    then P.tolerance() <= (the_Weight_of G2).e - EL1.e
                      by A8,Def19;
                    then EL2.e <= (the_Weight_of G2).e - EL1.e + EL1.e
                      by A18,XREAL_1:9;
                    hence EL2.e <= (the_Weight_of G2).e;
                  end;
                  suppose
                A19: e DJoins P.(n+2),P.n,G;
                then A20: EL2.e = EL1.e - P.tolerance() by A3,A6,A10,Def20;
                     PFS.n1div2=EL1.e by A6,A10,A13,A15,A16,A19,Def18;
                    then EL1.e in rng PFS by A13,FUNCT_1:def 5;
                    then P.tolerance() <= EL1.e by A8,Def19;
                    then P.tolerance() - P.tolerance() <= EL2.e by A20,
REAL_1:92;
                    hence 0 <= EL2.e;
                     EL2.e <= EL1.e - 0 by A9,A20,REAL_1:92;
                    hence EL2.e <= (the_Weight_of G2).e by A2,A5,XXREAL_0:2;
                  end;
                end;
                hence 0 <= EL2.e & EL2.e <= (the_Weight_of G2).e;
              end;
            end;
            hence 0 <= EL2.e & EL2.e <= (the_Weight_of G2).e;
        end;
        hence for e being set st e in the_Edges_of G2 holds
           0 <= EL2.e & EL2.e <= (the_Weight_of G2).e;
        let v be Vertex of G2; assume
    A21: v <> source & v <> sink;
        reconsider v'=v as Vertex of G by GLIB_000:12;
    A22: v.edgesIn() = v'.edgesIn() & v.edgesOut() = v'.edgesOut()
          by A2,GLIB_000:99;
    A23: Sum (EL1 | v'.edgesIn()) = Sum (EL1 | v'.edgesOut())
          by A1,A21,Def7;
         now per cases;
          suppose v in P.vertices(); then consider n being odd Element of NAT
          such that
        A24: n <= len P & P.n = v by GLIB_001:88;
        A25: now assume n = len P;
                then v = P.last() by A24,GLIB_001:def 7
                 .= sink by A1,GLIB_001:def 23;
                hence contradiction by A21;
            end;
        then A26: n < len P by A24,REAL_1:def 5;
        A27: 1 <= n by HEYTING3:1;
        A28: now assume n = 1;
                then v = P.first() by A24,GLIB_001:def 6
                 .= source by A1,GLIB_001:def 23;
                hence contradiction by A21;
            end;
            then 1 < n by A27,REAL_1:def 5;
            then 1+1 <= n by NAT_1:13;
            then reconsider n2 = n-2*1 as odd Element of NAT by INT_1:18;
            set e1 = P.(n2+1), e2 = P.(n+1), T = P.tolerance();
        A29: n2 < len P - 0 by A24,REAL_1:92;
        then A30: e1 Joins P.n2,P.(n2+2),G by GLIB_001:def 3;
        A31: e2 Joins v,P.(n+2),G by A24,A26,GLIB_001:def 3;
        A32: P.(n2+2) = v by A24;
        A33: now assume
            A34: P.n2 = v;
                 n2 < n - 0 by REAL_1:92;
                hence contradiction
                  by A24,A25,A34,GLIB_001:def 28;
            end;
        A35: now assume
            A36: v = P.(n+2);
            A37: n+0 < n+2 by XREAL_1:10;
                 n+2 <= len P by A26,GLIB_001:1;
                hence contradiction
                  by A24,A28,A36,A37,GLIB_001:def 28;
            end;
        A38: now assume
            A39: e1 DJoins P.n2,v,G & e1 DJoins v,P.n2,G;
                then P.n2 = (the_Source_of G).e1 by GLIB_000:def 16
                     .= v by A39,GLIB_000:def 16;
                hence contradiction by A33;
            end;
        A40: now assume
            A41: e2 DJoins v,P.(n+2),G & e2 DJoins P.(n+2),v,G;
            then A42: P.n = (the_Source_of G).e2 by A24,GLIB_000:def 16
                   .= P.(n+2) by A41,GLIB_000:def 16;
            A43: n + 0 < n+2 by XREAL_1:10;
                 n+2 <= len P by A26,GLIB_001:1;
                hence contradiction
                  by A28,A42,A43,GLIB_001:def 28;
            end;
             n2 < n - 0 by REAL_1:92;
            then 1 <= n2+1 & n2+1 < n+1 & n+1 <= len P
              by A26,NAT_1:11,13,XREAL_1:10;
        then A44: e1 <> e2 by GLIB_001:139;
        A45: now let e be set; assume
            A46: (e in v'.edgesIn() or e in v'.edgesOut()) & e <> e1 & e <> e2;
                 now assume e in P.edges(); then consider v1,v2 being
                    Vertex of G, m being odd Element of NAT such that
                A47: m+2 <= len P & v1 = P.m & e = P.(m+1) & v2 = P.(m+2) &
                      e Joins v1,v2,G by GLIB_001:104;
                A48: m+2-2 < len P - 0 by A47,REAL_1:92;
                A49: now per cases by A46;
                      suppose e in v'.edgesIn();
                        then (the_Target_of G).e = v by GLIB_000:59;
                        hence v1 = v or v2 = v by A47,GLIB_000:def 15;
                      end;
                      suppose e in v'.edgesOut();
                        then (the_Source_of G).e = v by GLIB_000:61;
                        hence v1 = v or v2 = v by A47,GLIB_000:def 15;
                      end;
                    end;
                     now per cases by A49;
                      suppose
                    A50: v1 = v;
                         now per cases by REAL_1:def 5;
                          suppose m < n;
                            hence contradiction
                              by A24,A25,A47,A50,GLIB_001:def 28;
                          end;
                          suppose m = n;
                            hence contradiction by A46,A47;
                          end;
                          suppose n < m;
                            hence contradiction by A24,A47,A48,A50,
GLIB_001:def 28;
                          end;
                        end;
                        hence contradiction;
                      end;
                      suppose
                    A51: v2 = v;
                         now per cases by REAL_1:def 5;
                          suppose m+2 < n;
                            hence contradiction
                              by A24,A25,A47,A51,GLIB_001:def 28;
                          end;
                          suppose m+2 = n;
                            hence contradiction by A46,A47;
                          end;
                          suppose n < m+2;
                            hence contradiction by A24,A28,A47,A51,
GLIB_001:def 28;
                          end;
                        end;
                        hence contradiction;
                      end;
                    end;
                    hence contradiction;
                end;
                hence not e in P.edges();
            end;
             now per cases by A24,A30,A31,GLIB_000:19;
              suppose
            A52: e1 DJoins P.n2,v,G & e2 DJoins v,P.(n+2),G;
                set XIN = (EL1|v'.edgesIn()) +* (e1.-->(EL1.e1 + T));
                set XOUT= (EL1|v'.edgesOut())+* (e2.-->(EL1.e2 + T));
            A53: e1 in v'.edgesIn() & e2 in v'.edgesOut()
                  by A52,GLIB_000:60,62;
            A54: dom (e1.-->(EL1.e1+T)) = {e1} by FUNCOP_1:19;
            then A55: dom XIN = dom (EL1|v'.edgesIn()) \/ {e1} by FUNCT_4:def 1
                       .= v'.edgesIn() \/ {e1} by PBOOLE:def 3
                       .= v'.edgesIn() by A53,ZFMISC_1:46;
                then reconsider XIN as Rbag of v'.edgesIn() by PBOOLE:def 3;
            A56: dom (e2.-->(EL1.e2+T)) = {e2} by FUNCOP_1:19;
            then A57: dom XOUT = dom (EL1|v'.edgesOut())\/{e2} by FUNCT_4:def 1
                        .= v'.edgesOut() \/ {e2} by PBOOLE:def 3
                        .= v'.edgesOut() by A53,ZFMISC_1:46;
                then reconsider XOUT as Rbag of v'.edgesOut() by PBOOLE:def 3;
            A58: dom (EL2|v.edgesIn()) = v.edgesIn() by PBOOLE:def 3;
                 now let e be set; assume e in dom (EL2|v.edgesIn());
                then A59: e in v.edgesIn() by PBOOLE:def 3;
                then A60: (the_Target_of G).e = v by A22,GLIB_000:59;
                     now per cases;
                      suppose
                    A61: e = e1;
                        then e in dom (e1.-->(EL1.e1+T)) by A54,TARSKI:def 1;
                        hence XIN.e = (e1.-->(EL1.e1+T)).e1 by A61,FUNCT_4:14
                                   .= EL1.e1 + T by FUNCOP_1:87
                                   .= EL2.e by A3,A29,A32,A52,A61,Def20;
                      end;
                      suppose
                    A62: e <> e1;
                        then not e in dom (e1.-->(EL1.e1+T)) by A54,
TARSKI:def 1;
then A63: XIN.e = (EL1|v'.edgesIn()).e by FUNCT_4:12
                             .= EL1.e by A22,A59,FUNCT_1:72;
                         now assume e in P.edges(); then consider v1,v2 being
                            Vertex of G,m being odd Element of NAT such that
                        A64: m+2 <= len P & v1 = P.m & e = P.(m+1) & v2=P.(m+2)
                              & e Joins v1,v2,G by GLIB_001:104;
                        A65: m+2-2 < len P - 0 by A64,REAL_1:92;
                             now per cases by A60,A64,GLIB_000:def 15;
                              suppose
                            A66: v = v1;
                                 now per cases by REAL_1:def 5;
                                  suppose m < n;
                                    hence contradiction by A24,A25,A64,A66,
GLIB_001:def 28;
                                  end;
                                  suppose m = n;
                                then A67: P.(n+2) = P.n
                                      by A24,A52,A60,A64,GLIB_000:def 16;
                                A68: n+2-2 < n+2-0 by REAL_1:92;
                                     n+2 <= len P by A26,GLIB_001:1;
                                    hence contradiction by A28,A67,A68,
GLIB_001:def 28;
                                  end;
                                  suppose n < m;
                                    hence contradiction
                                      by A24,A64,A65,A66,GLIB_001:def 28;
                                  end;
                                end;
                                hence contradiction;
                              end;
                              suppose
                            A69: v = v2;
                                 now per cases by REAL_1:def 5;
                                  suppose m+2 < n;
                                    hence contradiction by A24,A25,A64,A69,
GLIB_001:def 28;
                                  end;
                                  suppose m+2 = n;
                                    hence contradiction by A62,A64;
                                  end;
                                  suppose n < m+2;
                                    hence contradiction by A24,A28,A64,A69,
GLIB_001:def 28;
                                  end;
                                end;
                                hence contradiction;
                              end;
                            end;
                            hence contradiction;
                        end;
                        hence EL2.e = XIN.e by A3,A22,A59,A63,Def20;
                      end;
                    end;
                    hence (EL2|v.edgesIn()).e = XIN.e by A59,FUNCT_1:72;
                end;
            then A70: Sum (EL2|v.edgesIn())=Sum XIN by A22,A55,A58,FUNCT_1:9;
            A71: dom (EL2|v.edgesOut()) = v.edgesOut() by PBOOLE:def 3;
            A72: now let e be set; assume e in dom (EL2|v.edgesOut());
                then A73: e in v.edgesOut() by PBOOLE:def 3;
                then A74: (the_Source_of G).e = v by A22,GLIB_000:61;
                     now per cases;
                      suppose
                    A75: e = e2;
                        then e in dom (e2.-->(EL1.e2+T)) by A56,TARSKI:def 1;
                        hence XOUT.e = (e2.-->(EL1.e2+T)).e2 by A75,FUNCT_4:14
                                    .= EL1.e2 + T by FUNCOP_1:87
                                    .= EL2.e by A3,A24,A26,A52,A75,Def20;
                      end;
                      suppose
                    A76: e <> e2;
                        then not e in dom (e2.-->(EL1.e2+T)) by A56,
TARSKI:def 1;
then A77: XOUT.e = (EL1|v'.edgesOut()).e by FUNCT_4:12
                              .= EL1.e by A22,A73,FUNCT_1:72;
                         now assume e in P.edges(); then consider v1,v2 being
                            Vertex of G,m being odd Element of NAT such that
                        A78: m+2 <= len P & v1 = P.m & e = P.(m+1) & v2=P.(m+2)
                              & e Joins v1,v2,G by GLIB_001:104;
                        A79: m+2-2 < len P - 0 by A78,REAL_1:92;
                             now per cases by A74,A78,GLIB_000:def 15;
                              suppose
                            A80: v = v1;
                                 now per cases by REAL_1:def 5;
                                  suppose m < n;
                                    hence contradiction by A24,A25,A78,A80,
GLIB_001:def 28;
                                  end;
                                  suppose m = n;
                                    hence contradiction by A76,A78;
                                  end;
                                  suppose n < m;
                                    hence contradiction
                                      by A24,A78,A79,A80,GLIB_001:def 28;
                                  end;
                                end;
                                hence contradiction;
                              end;
                              suppose
                            A81: v = v2;
                                 now per cases by REAL_1:def 5;
                                  suppose m+2 < n;
                                    hence contradiction by A24,A25,A78,A81,
GLIB_001:def 28;
                                  end;
                                  suppose m+2 = n;
                                then A82: P.n2 = P.n by A24,A52,A74,A78,
GLIB_000:def 16;
                                     n2 < n - 0 by REAL_1:92;
                                    hence contradiction
                                      by A24,A25,A82,GLIB_001:def 28;
                                  end;
                                  suppose n < m+2;
                                    hence contradiction by A24,A28,A78,A81,
GLIB_001:def 28;
                                  end;
                                end;
                                hence contradiction;
                              end;
                            end;
                            hence contradiction;
                        end;
                        hence EL2.e = XOUT.e by A3,A22,A73,A77,Def20;
                      end;
                    end;
                    hence (EL2|v.edgesOut()).e = XOUT.e by A73,FUNCT_1:72;
                end;
                 Sum XIN = Sum (EL1|v'.edgesIn()) + (T + EL1.e1)
                            - (EL1|v'.edgesIn()).e1 by GLIB_004:9
                       .= Sum (EL1|v'.edgesOut()) + T + EL1.e1 - EL1.e1
                            by A23,A53,FUNCT_1:72
                       .= Sum (EL1|v'.edgesOut()) + T + EL1.e2 - EL1.e2
                       .= Sum (EL1|v'.edgesOut()) + (T + EL1.e2)
                            - (EL1|v'.edgesOut()).e2 by A53,FUNCT_1:72
                       .= Sum XOUT by GLIB_004:9;
                hence Sum (EL2 | v.edgesIn()) = Sum (EL2 | v.edgesOut())
                  by A22,A57,A70,A71,A72,FUNCT_1:9;
              end;
              suppose
            A83: e1 DJoins P.n2,v,G & e2 DJoins P.(n+2),v,G;
            then A84: EL2.e1 = EL1.e1 + T & EL2.e2 = EL1.e2 - T
                  by A3,A26,A29,A32,A40,Def20;
            A85: e1 in v'.edgesIn() & e2 in v'.edgesIn() by A83,GLIB_000:60;
                set XIN1 = (EL1|v'.edgesIn())+*(e1.-->(EL1.e1+T));
                set XIN2 = XIN1 +* (e2.-->(EL1.e2-T));
            A86: dom XIN1 = dom (EL1|v'.edgesIn()) \/ dom (e1.-->(EL1.e1+T))
                             by FUNCT_4:def 1
                        .= dom (EL1|v'.edgesIn()) \/ {e1} by FUNCOP_1:19
                        .= v'.edgesIn() \/ {e1} by PBOOLE:def 3
                        .= v'.edgesIn() by A85,ZFMISC_1:46;
                then reconsider XIN1 as Rbag of v'.edgesIn() by PBOOLE:def 3;
            A87: dom XIN2 = dom XIN1 \/ dom (e2.-->(EL1.e2-T)) by FUNCT_4:def 1
                        .= v'.edgesIn() \/ {e2} by A86,FUNCOP_1:19
                        .= v'.edgesIn() by A85,ZFMISC_1:46;
                then reconsider XIN2 as Rbag of v'.edgesIn() by PBOOLE:def 3;
            A88: dom (EL2|v.edgesIn()) = v.edgesIn() by PBOOLE:def 3;
            A89: dom (e1.-->(EL1.e1+T)) = {e1} & dom (e2.-->(EL1.e2-T)) = {e2}
                  by FUNCOP_1:19;
            A90: now let e be set; assume
                A91: e in dom (EL2|v.edgesIn());
                then A92: e in v.edgesIn() by PBOOLE:def 3;
                A93: (EL2|v.edgesIn()).e = EL2.e by A88,A91,FUNCT_1:72;
                     now per cases;
                      suppose
                    A94: e = e1;
                    then A95: not e in dom (e2.-->(EL1.e2-T)) &
                        e in dom (e1.-->(EL1.e1+T)) by A44,A89,TARSKI:def 1;
then XIN2.e = XIN1.e by FUNCT_4:12
                              .= (e1.-->(EL1.e1+T)).e by A95,FUNCT_4:14
                              .= EL2.e by A84,A94,FUNCOP_1:87;
                        hence (EL2|v.edgesIn()).e = XIN2.e by A88,A91,
FUNCT_1:72;
                      end;
                      suppose
                    A96: e = e2;
                        then e in dom (e2.-->(EL1.e2-T)) by A89,TARSKI:def 1;
                        then XIN2.e = (e2.-->(EL1.e2-T)).e2 by A96,FUNCT_4:14
                              .= EL2.e by A84,A96,FUNCOP_1:87;
                        hence (EL2|v.edgesIn()).e = XIN2.e by A88,A91,
FUNCT_1:72;
                      end;
                      suppose
                    A97: e <> e1 & e <> e2;
                    then A98: not e in dom (e2.-->(EL1.e2-T)) &
                        not e in dom (e1.-->(EL1.e1+T)) by A89,TARSKI:def 1;
then A99: XIN2.e = XIN1.e by FUNCT_4:12
                              .= (EL1|v'.edgesIn()).e by A98,FUNCT_4:12
                              .= EL1.e by A22,A92,FUNCT_1:72;
                         not e in P.edges() by A22,A45,A92,A97;
                        hence (EL2|v.edgesIn()).e = XIN2.e
                          by A3,A22,A92,A93,A99,Def20;
                      end;
                    end;
                    hence (EL2|v.edgesIn()).e = XIN2.e;
                end;
                 not e2 in dom (e1.-->(EL1.e1+T)) by A44,A89,TARSKI:def 1;
            then A100: XIN1.e2 = (EL1|v'.edgesIn()).e2 by FUNCT_4:12
                       .= EL1.e2 by A85,FUNCT_1:72;
            A101: dom (EL2|v.edgesOut()) = v.edgesOut() &
                dom (EL1|v'.edgesOut()) = v.edgesOut() by A22,PBOOLE:def 3;
                 now let e be set; assume
                A102: e in dom (EL2|v.edgesOut());
                then A103: e in v.edgesOut() by PBOOLE:def 3;
                A104: (EL2|v.edgesOut()).e = EL2.e &
                    (EL1|v'.edgesOut()).e = EL1.e by A22,A101,A102,FUNCT_1:72;
                A105: e in the_Edges_of G &
                      (the_Source_of G).e = v by A22,A103,GLIB_000:61;
                then A106: e <> e1 by A33,A83,GLIB_000:def 16;
                     e <> e2 by A35,A83,A105,GLIB_000:def 16;
                    then not e in P.edges() by A22,A45,A103,A106;
                    hence (EL2|v.edgesOut()).e = (EL1|v'.edgesOut()).e
                      by A3,A22,A103,A104,Def20;
                end;
            then A107: EL2|v.edgesOut() = EL1|v'.edgesOut() by A101,FUNCT_1:9;
                 Sum (EL2|v.edgesIn())
                   = Sum XIN2 by A22,A87,A88,A90,FUNCT_1:9
                  .= Sum XIN1 + (EL1.e2-T) - EL1.e2 by A100,GLIB_004:9
                  .= Sum XIN1 - (EL1.e2 - (EL1.e2 - T))
                  .= Sum (EL1|v'.edgesIn())+(EL1.e1+T)-(EL1|v'.edgesIn()).e1-T
                       by GLIB_004:9
                  .= Sum (EL1|v'.edgesIn())+T+EL1.e1-EL1.e1-T
                       by A85,FUNCT_1:72
                  .= Sum (EL1|v'.edgesIn());
                hence Sum (EL2|v.edgesIn()) = Sum (EL2|v.edgesOut())
                  by A1,A21,A22,A107,Def7;
              end;
              suppose
            A108: e1 DJoins v,P.n2,G & e2 DJoins v,P.(n+2),G;
            then A109: EL2.e1 = EL1.e1 - T & EL2.e2 = EL1.e2 + T
                  by A3,A26,A29,A32,A38,Def20;
            A110: e1 in v'.edgesOut() & e2 in v'.edgesOut() by A108,GLIB_000:62
;
                set XOUT1 = (EL1|v'.edgesOut())+*(e1.-->(EL1.e1-T));
                set XOUT2 = XOUT1 +* (e2.-->(EL1.e2+T));
            A111: dom XOUT1 = dom (EL1|v'.edgesOut()) \/ dom (e1.-->(EL1.e1-T))
                              by FUNCT_4:def 1
                         .= dom (EL1|v'.edgesOut()) \/ {e1} by FUNCOP_1:19
                         .= v'.edgesOut() \/ {e1} by PBOOLE:def 3
                         .= v'.edgesOut() by A110,ZFMISC_1:46;
                then reconsider XOUT1 as Rbag of v'.edgesOut() by PBOOLE:def 3;
            A112: dom XOUT2 = dom XOUT1\/dom (e2.-->(EL1.e2+T)) by
FUNCT_4:def 1
                         .= v'.edgesOut() \/ {e2} by A111,FUNCOP_1:19
                         .= v'.edgesOut() by A110,ZFMISC_1:46;
                then reconsider XOUT2 as Rbag of v'.edgesOut() by PBOOLE:def 3;
            A113: dom (EL2|v.edgesOut()) = v.edgesOut() by PBOOLE:def 3;
            A114: dom (e1.-->(EL1.e1-T)) = {e1} & dom (e2.-->(EL1.e2+T)) = {e2}
                  by FUNCOP_1:19;
            A115: now let e be set; assume
                A116: e in dom (EL2|v.edgesOut());
                then A117: e in v.edgesOut() by PBOOLE:def 3;
                A118: (EL2|v.edgesOut()).e = EL2.e by A113,A116,FUNCT_1:72;
                     now per cases;
                      suppose
                    A119: e = e1;
                    then A120: not e in dom (e2.-->(EL1.e2+T)) &
                        e in dom (e1.-->(EL1.e1-T)) by A44,A114,TARSKI:def 1;
then XOUT2.e = XOUT1.e by FUNCT_4:12
                               .= (e1.-->(EL1.e1-T)).e by A120,FUNCT_4:14
                               .= EL2.e by A109,A119,FUNCOP_1:87;
                        hence (EL2|v.edgesOut()).e=XOUT2.e by A113,A116,
FUNCT_1:72;
                      end;
                      suppose
                    A121: e = e2;
                        then e in dom (e2.-->(EL1.e2+T)) by A114,TARSKI:def 1;
                        then XOUT2.e = (e2.-->(EL1.e2+T)).e by FUNCT_4:14
                               .= EL2.e by A109,A121,FUNCOP_1:87;
                        hence (EL2|v.edgesOut()).e=XOUT2.e by A113,A116,
FUNCT_1:72;
                      end;
                      suppose
                    A122: e <> e1 & e <> e2;
                    then A123: not e in dom (e2.-->(EL1.e2+T)) &
                        not e in dom (e1.-->(EL1.e1-T)) by A114,TARSKI:def 1;
then A124: XOUT2.e = XOUT1.e by FUNCT_4:12
                               .= (EL1|v'.edgesOut()).e by A123,FUNCT_4:12
                               .= EL1.e by A22,A117,FUNCT_1:72;
                         not e in P.edges() by A22,A45,A117,A122;
                        hence (EL2|v.edgesOut()).e = XOUT2.e
                          by A3,A22,A117,A118,A124,Def20;
                      end;
                    end;
                    hence (EL2|v.edgesOut()).e = XOUT2.e;
                end;
                 not e2 in dom (e1.-->(EL1.e1-T)) by A44,A114,TARSKI:def 1;
            then A125: XOUT1.e2 = (EL1|v'.edgesOut()).e2 by FUNCT_4:12
                        .= EL1.e2 by A110,FUNCT_1:72;
            A126: Sum (EL2|v.edgesOut())
                   = Sum XOUT2 by A22,A112,A113,A115,FUNCT_1:9
                  .= Sum XOUT1 + (EL1.e2+T) - EL1.e2 by A125,GLIB_004:9
                  .= Sum XOUT1 - EL1.e2 + EL1.e2 + T
                  .= Sum (EL1|v'.edgesOut()) + (EL1.e1 - T)
                       - (EL1|v'.edgesOut()).e1 + T by GLIB_004:9
                  .= Sum (EL1|v'.edgesOut()) + EL1.e1 - T - EL1.e1 + T
                       by A110,FUNCT_1:72
                  .= Sum (EL1|v'.edgesOut());
            A127: dom (EL2|v.edgesIn()) = v.edgesIn() &
                dom (EL1|v'.edgesIn()) = v.edgesIn() by A22,PBOOLE:def 3;
                 now let e be set; assume
                A128: e in dom (EL2|v.edgesIn());
                then A129: e in v.edgesIn() by PBOOLE:def 3;
                A130: (EL2|v.edgesIn()).e = EL2.e &
                    (EL1|v'.edgesIn()).e = EL1.e by A22,A127,A128,FUNCT_1:72;
                A131: e in the_Edges_of G &
                      (the_Target_of G).e = v by A22,A129,GLIB_000:59;
                then A132: e <> e1 by A33,A108,GLIB_000:def 16;
                     e <> e2 by A35,A108,A131,GLIB_000:def 16;
                    then not e in P.edges() by A22,A45,A129,A132;
                    hence (EL2|v.edgesIn()).e = (EL1|v'.edgesIn()).e
                      by A3,A22,A129,A130,Def20;
                end;
                then EL2|v.edgesIn() = EL1|v'.edgesIn() by A127,FUNCT_1:9;
                hence Sum (EL2|v.edgesIn()) = Sum (EL2|v.edgesOut())
                  by A23,A126,GLIB_004:7;
            end;
            suppose
            A133: e1 DJoins v,P.n2,G & e2 DJoins P.(n+2),v,G;
            then A134: EL2.e1 = EL1.e1 - T & EL2.e2 = EL1.e2 - T
                  by A3,A26,A29,A32,A38,A40,Def20;
            A135: e1 in v'.edgesOut() & e2 in v'.edgesIn()
                  by A133,GLIB_000:60,62;
                set XIN = (EL1|v'.edgesIn())+*(e2.-->(EL1.e2-T));
                set XOUT= (EL1|v'.edgesOut())+*(e1.-->(EL1.e1-T));
            A136: dom (e1.-->(EL1.e1-T)) = {e1} &
                dom (e2.-->(EL1.e2-T)) = {e2} by FUNCOP_1:19;
            then A137: dom XIN = dom (EL1|v'.edgesIn()) \/ {e2} by
FUNCT_4:def 1
                       .= v'.edgesIn() \/ {e2} by PBOOLE:def 3
                       .= v'.edgesIn() by A135,ZFMISC_1:46;
                then reconsider XIN as Rbag of v'.edgesIn() by PBOOLE:def 3;
            A138: dom XOUT = dom (EL1|v'.edgesOut())\/{e1} by A136,
FUNCT_4:def 1
                        .= v'.edgesOut() \/ {e1} by PBOOLE:def 3
                        .= v'.edgesOut() by A135,ZFMISC_1:46;
                then reconsider XOUT as Rbag of v'.edgesOut() by PBOOLE:def 3;
            A139: dom (EL2|v.edgesIn()) = v.edgesIn() &
                dom (EL2|v.edgesOut()) = v.edgesOut() by PBOOLE:def 3;
                 now let e be set; assume e in dom (EL2|v.edgesIn());
                then A140: e in v.edgesIn() by PBOOLE:def 3;
                then A141: (the_Target_of G).e = v by A22,GLIB_000:59;
                     now per cases;
                      suppose
                    A142: e = e2;
                        then e in dom (e2.-->(EL1.e2-T)) by A136,TARSKI:def 1;
                        hence XIN.e = (e2.-->(EL1.e2-T)).e2 by A142,FUNCT_4:14
                                   .= EL2.e by A134,A142,FUNCOP_1:87;
                      end;
                      suppose
                    A143: e <> e2;
                        then not e in dom (e2.-->(EL1.e2-T)) by A136,
TARSKI:def 1;
then A144: XIN.e = (EL1|v'.edgesIn()).e by FUNCT_4:12
                             .= EL1.e by A22,A140,FUNCT_1:72;
                         e <> e1 by A33,A133,A141,GLIB_000:def 16;
                        then not e in P.edges() by A22,A45,A140,A143;
                        hence EL2.e = XIN.e by A3,A22,A140,A144,Def20;
                      end;
                    end;
                    hence XIN.e = (EL2|v.edgesIn()).e by A140,FUNCT_1:72;
                end;
            then A145: Sum (EL2|v.edgesIn())
                  = Sum XIN by A22,A137,A139,FUNCT_1:9
                 .= Sum (EL1|v'.edgesIn()) + (EL1.e2-T) - (EL1|v'.edgesIn()).e2
                      by GLIB_004:9
                 .= Sum (EL1|v'.edgesIn()) + EL1.e2 - T - EL1.e2
                      by A135,FUNCT_1:72
                 .= Sum (EL1|v'.edgesIn()) - T;
                 now let e be set; assume e in dom (EL2|v.edgesOut());
                then A146: e in v.edgesOut() by PBOOLE:def 3;
                then A147: (the_Source_of G).e = v by A22,GLIB_000:61;
                     now per cases;
                      suppose
                    A148: e = e1;
                        then e in dom (e1.-->(EL1.e1-T)) by A136,TARSKI:def 1;
                        hence XOUT.e = (e1.-->(EL1.e1-T)).e1 by A148,FUNCT_4:14
                                    .= EL2.e by A134,A148,FUNCOP_1:87;
                      end;
                      suppose
                    A149: e <> e1;
                        then not e in dom (e1.-->(EL1.e1-T)) by A136,
TARSKI:def 1;
then A150: XOUT.e = (EL1|v'.edgesOut()).e by FUNCT_4:12
                              .= EL1.e by A22,A146,FUNCT_1:72;
                         e <> e2 by A35,A133,A147,GLIB_000:def 16;
                        then not e in P.edges() by A22,A45,A146,A149;
                        hence EL2.e = XOUT.e by A3,A22,A146,A150,Def20;
                      end;
                    end;
                    hence XOUT.e = (EL2|v.edgesOut()).e by A146,FUNCT_1:72;
                end;
                then Sum (EL2|v.edgesOut())
                  = Sum XOUT by A22,A138,A139,FUNCT_1:9
                 .= Sum (EL1|v'.edgesOut()) + (EL1.e1-T)-(EL1|v'.edgesOut()).e1
                      by GLIB_004:9
                 .= Sum (EL1|v'.edgesOut()) + EL1.e1 - T - EL1.e1
                      by A135,FUNCT_1:72
                 .= Sum (EL1|v'.edgesIn()) - T by A23;
                hence Sum (EL2 | v.edgesIn()) = Sum (EL2 | v.edgesOut()) by
A145;
              end;
            end;
            hence Sum (EL2 | v.edgesIn()) = Sum (EL2 | v.edgesOut());
          end;
          suppose
        A151: not v in P.vertices();
        A152: dom (EL1|v'.edgesIn()) = v.edgesIn()
              by A22,PBOOLE:def 3;
        then A153: dom (EL1|v'.edgesIn()) = dom (EL2|v.edgesIn())
              by PBOOLE:def 3;
             now let e be set; assume
            A154: e in dom (EL1|v'.edgesIn());
            then A155: (EL1|v'.edgesIn()).e = EL1.e &
                  (EL2|v.edgesIn()).e = EL2.e by A22,A152,FUNCT_1:72;
                 now assume
                A156: e in P.edges();
                    consider x being set such that
                A157: e DJoins x,v,G2 by A152,A154,GLIB_000:60;
                     e Joins x,v,G2 by A157,GLIB_000:19;
                    then e Joins x,v,G by A2,GLIB_000:91;
                    hence contradiction by A151,A156,GLIB_001:106;
                end;
                hence (EL1|v'.edgesIn()).e = (EL2|v.edgesIn()).e
                  by A3,A22,A152,A154,A155,Def20;
            end;
        then A158: EL1 | v'.edgesIn() = EL2 | v.edgesIn() by A153,FUNCT_1:9;
        A159: dom (EL1|v'.edgesOut()) = v.edgesOut() &
              dom (EL2|v.edgesOut()) = v.edgesOut() by A22,PBOOLE:def 3;
             now let e be set; assume
            A160: e in dom (EL1|v'.edgesOut());
            then A161: e in v.edgesOut() by A22,PBOOLE:def 3;
            A162: (EL1|v'.edgesOut()).e = EL1.e &
                  (EL2|v.edgesOut()).e = EL2.e by A22,A159,A160,FUNCT_1:72;
                 now assume
                A163: e in P.edges();
                    consider x being set such that
                A164: e DJoins v,x,G by A22,A161,GLIB_000:62;
                     e Joins v,x,G by A164,GLIB_000:19;
                    hence contradiction by A151,A163,GLIB_001:106;
                end;
                hence (EL1|v'.edgesOut()).e = (EL2|v.edgesOut()).e
                  by A3,A22,A161,A162,Def20;
            end;
        then A165: EL1 | v'.edgesOut() = EL2 | v.edgesOut() by A159,FUNCT_1:9;
            thus Sum (EL2|v.edgesIn())
                = Sum (EL1|v'.edgesIn()) by A158,GLIB_004:7
               .= Sum (EL2|v.edgesOut()) by A23,A165,GLIB_004:7;
          end;
        end;
        hence Sum (EL2 | v.edgesIn()) = Sum (EL2 | v.edgesOut());
    end;
    hence G2 has_valid_flow_from source,sink by Def7;
end;

theorem Th16: ::tFLOWAUG01
  for G being finite real-weighted real-elabeled complete-elabeled WEGraph,
      source,sink being set, P being augmenting Path of G
   st source <> sink & G has_valid_flow_from source,sink &
      P is_Walk_from source,sink holds
     G.flow(source,sink) + P.tolerance() =
       (FF:AugmentPath(G,P)).flow(source,sink) proof
    let G be finite real-weighted real-elabeled complete-elabeled WEGraph,
        source,sink be set, P be augmenting Path of G such that
A1: source <> sink & G has_valid_flow_from source,sink &
      P is_Walk_from source,sink;
    set G2 = FF:AugmentPath(G,P), T = P.tolerance();
    set EL1 = the_ELabel_of G, EL2 = the_ELabel_of G2;
A2: EL2 = FF:PushFlow(G,P) by GLIB_000:11;
A3: G2 has_valid_flow_from source,sink by A1,Th15;
    set EI1 = EL1|G.edgesInto({sink}), EO1 = EL1|G.edgesOutOf({sink});
     P.first() = source & P.last() = sink by A1,GLIB_001:def 23;
    then P is non trivial by A1,GLIB_001:128;
    then 3 <= len P by GLIB_001:126;
    then 2 <= len P by XXREAL_0:2;
    then reconsider lenP2g = len P - 2*1 as odd Element of NAT by INT_1:18;
    set e1 = P.(lenP2g+1);
A4: lenP2g < len P - 0 by REAL_1:92;
then A5: e1 Joins P.lenP2g, P.(lenP2g+2), G by GLIB_001:def 3;
then A6: e1 in the_Edges_of G by GLIB_000:def 15;
     G2 == G by GLIB_003:8;
then A7: G2.edgesInto({sink}) = G.edgesInto({sink}) &
    G2.edgesOutOf({sink}) = G.edgesOutOf({sink}) by GLIB_000:93;
A8: P.(len P) = sink by A1,GLIB_001:18;
     now per cases;
      suppose
    A9: e1 DJoins P.lenP2g, P.(lenP2g+2), G;
    then A10: EL2.e1 = EL1.e1 + T by A2,A4,Def20;
        (the_Target_of G).e1 = P.(lenP2g+2) by A9,GLIB_000:def 16
                            .= sink by A1,GLIB_001:18;
        then (the_Target_of G).e1 in {sink} by TARSKI:def 1;
    then A11: e1 in G.edgesInto({sink}) by A6,GLIB_000:def 28;
        set EI2 = EI1+*(e1.-->(EI1.e1 + T));
    A12: dom EI2 = dom EI1 \/ dom (e1.-->(EI1.e1 + T)) by FUNCT_4:def 1
               .= dom EI1 \/ {e1} by FUNCOP_1:19
               .= G.edgesInto({sink}) \/ {e1} by PBOOLE:def 3
               .= G.edgesInto({sink}) by A11,ZFMISC_1:46;
        then reconsider EI2 as Rbag of G.edgesInto({sink}) by PBOOLE:def 3;
    A13: dom (EL2|G2.edgesInto({sink})) = G2.edgesInto({sink})
          by PBOOLE:def 3;
         now let e be set; assume
        A14: e in dom (EL2|G2.edgesInto({sink}));
        then A15: e in G2.edgesInto({sink}) by PBOOLE:def 3;
        A16: (EL2|G2.edgesInto({sink})).e = EL2.e by A13,A14,FUNCT_1:72;
             (the_Target_of G).e in {sink} by A7,A15,GLIB_000:def 28;
        then A17: (the_Target_of G).e = sink by TARSKI:def 1;
             now per cases;
              suppose
            A18: e = e1;
                then e in {e1} by TARSKI:def 1;
                then e in dom (e1.-->(EI1.e1+T)) by FUNCOP_1:19;
                then EI2.e = (e1.-->(EI1.e1+T)).e1 by A18,FUNCT_4:14
                     .= EI1.e1 + T by FUNCOP_1:87
                     .= EL2.e1 by A7,A10,A15,A18,FUNCT_1:72;
                hence (EL2|G2.edgesInto({sink})).e = EI2.e
                  by A13,A14,A18,FUNCT_1:72;
              end;
              suppose
            A19: e <> e1;
                then not e in {e1} by TARSKI:def 1;
                then not e in dom (e1.-->(EI1.e1+T)) by FUNCOP_1:19;
            then A20: EI2.e = EI1.e by FUNCT_4:12
                     .= EL1.e by A7,A15,FUNCT_1:72;
                 now assume e in P.edges();
                    then consider v1,v2 being Vertex of G,m being odd Element
of NAT
                    such that
                A21: m+2 <= len P & v1 = P.m & e = P.(m+1) & v2 = P.(m+2) &
                      e Joins v1,v2,G by GLIB_001:104;
                     now per cases by A17,A21,GLIB_000:def 15;
                      suppose
                    A22: v1 = sink;
                    then A23: P.m = P.(len P) by A1,A21,GLIB_001:18;
                         m+2-2 < len P - 0 by A21,REAL_1:92;
                        then m = 1 by A23,GLIB_001:def 28;
                        hence contradiction by A1,A21,A22,GLIB_001:18;
                      end;
                      suppose v2 = sink;
                     then A24: P.(m+2) = P.(len P) by A1,A21,GLIB_001:18;
                          now assume m+2 < len P;
                             then m+2 = 1 by A24,GLIB_001:def 28;
                             then m = 1-2;
                             hence contradiction by HEYTING3:1;
                         end;
                         then m + 2 = len P by A21,XXREAL_0:1;
                         hence contradiction by A19,A21;
                      end;
                    end;
                    hence contradiction;
                end;
                hence (EL2|G2.edgesInto({sink})).e = EI2.e
                  by A2,A7,A15,A16,A20,Def20;
              end;
            end;
            hence (EL2|G2.edgesInto({sink})).e = EI2.e;
        end;
    then A25: Sum (EL2|G2.edgesInto({sink}))
           = Sum EI2 by A7,A12,A13,FUNCT_1:9
          .= Sum EI1 + (T + EI1.e1) - EI1.e1 by GLIB_004:9
          .= Sum EI1 + T;
    A26: dom (EL2|G2.edgesOutOf({sink})) = G2.edgesOutOf({sink}) &
        dom EO1 = G2.edgesOutOf({sink}) by A7,PBOOLE:def 3;
         now let e be set; assume
        A27: e in dom (EL2|G2.edgesOutOf({sink}));
        then A28: e in G2.edgesOutOf({sink}) by PBOOLE:def 3;
            then (the_Source_of G).e in {sink} by A7,GLIB_000:def 29;
        then A29: (the_Source_of G).e = sink by TARSKI:def 1;
             now assume e in P.edges();
                then consider v1,v2 being Vertex of G, m being odd Element of
NAT
                such that
            A30: m+2 <= len P & v1 = P.m & e = P.(m+1) & v2 = P.(m+2) &
                  e Joins v1,v2,G by GLIB_001:104;
                 now per cases by A29,A30,GLIB_000:def 15;
                  suppose
                A31: v1 = sink;
                then A32: P.m = P.(len P) by A1,A30,GLIB_001:18;
                     m+2-2 < len P - 0 by A30,REAL_1:92;
                    then m = 1 by A32,GLIB_001:def 28;
                    hence contradiction by A1,A30,A31,GLIB_001:18;
                  end;
                  suppose v2 = sink;
                then A33: P.(m+2) = P.(len P) by A1,A30,GLIB_001:18;
                     now assume m+2 < len P;
                        then m+2 = 1 by A33,GLIB_001:def 28;
                        then 1 <= 1-2 by HEYTING3:1;
                        hence contradiction;
                    end;
                    then m + 2 = len P by A30,XXREAL_0:1;
                then A34: P.lenP2g = sink by A9,A29,A30,GLIB_000:def 16;
                    then lenP2g = 1 by A4,A8,GLIB_001:def 28;
                    hence contradiction by A1,A34,GLIB_001:18;
                  end;
                end;
                hence contradiction;
            end;
            then EL2.e = EL1.e by A2,A7,A28,Def20
                 .= EO1.e by A7,A28,FUNCT_1:72;
            hence (EL2|G2.edgesOutOf({sink})).e = EO1.e by A26,A27,FUNCT_1:72;
        end;
        then EL2|G2.edgesOutOf({sink}) = EO1 by A26,FUNCT_1:9;
        then Sum (EL2|G2.edgesOutOf({sink})) = Sum EO1 by GLIB_004:7;
        hence G2.flow(source,sink) = Sum EI1 + T - Sum EO1 by A3,A25,Def8
                                  .= Sum EI1 - Sum EO1 + T
                                  .= G.flow(source,sink) + T by A1,Def8;
      end;
      suppose
    A35: not e1 DJoins P.lenP2g, P.(lenP2g+2), G;
    then A36: EL2.e1 = EL1.e1 - T by A2,A4,Def20;
    A37: e1 DJoins P.(lenP2g+2),P.lenP2g,G by A5,A35,GLIB_000:19;
        then (the_Source_of G).e1 = P.(lenP2g+2) by GLIB_000:def 16
                            .= sink by A1,GLIB_001:18;
        then (the_Source_of G).e1 in {sink} by TARSKI:def 1;
    then A38: e1 in G.edgesOutOf({sink}) by A6,GLIB_000:def 29;
        set EO2 = EO1+*(e1.-->(EO1.e1-T));
    A39: dom EO2 = dom EO1 \/ dom (e1.-->(EO1.e1 - T)) by FUNCT_4:def 1
               .= dom EO1 \/ {e1} by FUNCOP_1:19
               .= G.edgesOutOf({sink}) \/ {e1} by PBOOLE:def 3
               .= G.edgesOutOf({sink}) by A38,ZFMISC_1:46;
        then reconsider EO2 as Rbag of G.edgesOutOf({sink}) by PBOOLE:def 3;
    A40: dom (EL2|G2.edgesOutOf({sink})) = G2.edgesOutOf({sink})
          by PBOOLE:def 3;
         now let e be set; assume
        A41: e in dom (EL2|G2.edgesOutOf({sink}));
        then A42: e in G2.edgesOutOf({sink}) by PBOOLE:def 3;
        A43: (EL2|G2.edgesOutOf({sink})).e = EL2.e by A40,A41,FUNCT_1:72;
             (the_Source_of G).e in {sink} by A7,A42,GLIB_000:def 29;
        then A44: (the_Source_of G).e = sink by TARSKI:def 1;
             now per cases;
              suppose
            A45: e = e1;
                then e in {e1} by TARSKI:def 1;
                then e in dom (e1.-->(EO1.e1-T)) by FUNCOP_1:19;
                then EO2.e = (e1.-->(EO1.e1-T)).e1 by A45,FUNCT_4:14
                     .= EO1.e1 - T by FUNCOP_1:87
                     .= EL2.e by A7,A36,A42,A45,FUNCT_1:72;
                hence (EL2|G2.edgesOutOf({sink})).e = EO2.e
                  by A40,A41,FUNCT_1:72;
              end;
              suppose
            A46: e <> e1;
                then not e in {e1} by TARSKI:def 1;
                then not e in dom (e1.-->(EO1.e1-T)) by FUNCOP_1:19;
            then A47: EO2.e = EO1.e by FUNCT_4:12
                     .= EL1.e by A7,A42,FUNCT_1:72;
                 now assume e in P.edges();
                    then consider v1,v2 being Vertex of G,
                    m being odd Element of NAT such that
                A48: m+2 <= len P & v1 = P.m & e = P.(m+1) & v2 = P.(m+2) &
                     e Joins v1,v2,G by GLIB_001:104;
                     now per cases by A44,A48,GLIB_000:def 15;
                      suppose
                    A49: v1 = sink;
                    then A50: P.m = P.(len P) by A1,A48,GLIB_001:18;
                         m+2-2 < len P - 0 by A48,REAL_1:92;
                        then m = 1 by A50,GLIB_001:def 28;
                        hence contradiction by A1,A48,A49,GLIB_001:18;
                      end;
                      suppose v2 = sink;
                    then A51: P.(m+2) = P.(len P) by A1,A48,GLIB_001:18;
                         now assume m+2 < len P;
                            then m+2 = 1 by A51,GLIB_001:def 28;
                            then 1 <= 1-2 by HEYTING3:1;
                            hence contradiction;
                        end;
                        then m + 2 = len P by A48,XXREAL_0:1;
                        hence contradiction by A46,A48;
                      end;
                    end;
                    hence contradiction;
                end;
                hence (EL2|G2.edgesOutOf({sink})).e = EO2.e
                  by A2,A7,A42,A43,A47,Def20;
              end;
            end;
            hence (EL2|G2.edgesOutOf({sink})).e = EO2.e;
        end;
    then A52: Sum (EL2|G2.edgesOutOf({sink}))
           = Sum EO2 by A7,A39,A40,FUNCT_1:9
          .= Sum EO1 + (EO1.e1 - T) - EO1.e1 by GLIB_004:9
          .= Sum EO1 - T;
    A53: dom (EL2|G2.edgesInto({sink})) = G2.edgesInto({sink}) &
          dom EI1 = G2.edgesInto({sink}) by A7,PBOOLE:def 3;
         now let e be set; assume
        A54: e in dom (EL2|G2.edgesInto({sink}));
        then A55: e in G2.edgesInto({sink}) by PBOOLE:def 3;
            then (the_Target_of G).e in {sink} by A7,GLIB_000:def 28;
        then A56: (the_Target_of G).e = sink by TARSKI:def 1;
             now assume e in P.edges();
                then consider v1,v2 being Vertex of G, m being odd Element of
NAT
                such that
           A57: m+2 <= len P & v1 = P.m & e = P.(m+1) & v2 = P.(m+2) &
                  e Joins v1,v2,G by GLIB_001:104;
                 now per cases by A56,A57,GLIB_000:def 15;
                  suppose
                A58: v1 = sink;
                then A59: P.m = P.(len P) by A1,A57,GLIB_001:18;
                     m+2-2 < len P - 0 by A57,REAL_1:92;
                    then m = 1 by A59,GLIB_001:def 28;
                    hence contradiction by A1,A57,A58,GLIB_001:18;
                  end;
                  suppose v2 = sink;
                then A60: P.(m+2) = P.(len P) by A1,A57,GLIB_001:18;
                     now assume m+2 < len P;
                        then m+2 = 1 by A60,GLIB_001:def 28;
                        then 1 <= 1-2 by HEYTING3:1;
                        hence contradiction;
                    end;
                    then m + 2 = len P by A57,XXREAL_0:1;
                then A61: P.lenP2g = sink by A37,A56,A57,GLIB_000:def 16;
                    then lenP2g = 1 by A4,A8,GLIB_001:def 28;
                    hence contradiction by A1,A61,GLIB_001:18;
                  end;
                end;
                hence contradiction;
            end;
            then EL2.e = EL1.e by A2,A7,A55,Def20
                 .= EI1.e by A7,A55,FUNCT_1:72;
            hence (EL2|G2.edgesInto({sink})).e = EI1.e by A53,A54,FUNCT_1:72;
        end;
        then EL2|G2.edgesInto({sink}) = EI1 by A53,FUNCT_1:9;
        then Sum (EL2|G2.edgesInto({sink})) = Sum EI1 by GLIB_004:7;
        hence G2.flow(source,sink) = Sum EI1 - (Sum EO1 - T) by A3,A52,Def8
                                  .= Sum EI1 - Sum EO1 + T
                                  .= G.flow(source,sink) + T by A1,Def8;
      end;
    end;
    hence thesis;
end;

theorem Th17: ::tFLOWCS02
  for G being finite real-weighted WGraph, source,sink being Vertex of G,
      n being Element of NAT
  holds FF:CompSeq(G,source,sink).n == G &
  the_Weight_of G = the_Weight_of (FF:CompSeq(G,source,sink).n)  proof
    let G be finite real-weighted WGraph, source,sink be Vertex of G;
    set CS = FF:CompSeq(G,source,sink);
    defpred P[Element of NAT] means
      CS.$1 == G & the_Weight_of G = the_Weight_of (CS.$1);
     CS.0 = G.set(ELabelSelector, the_Edges_of G --> 0)
      by Def23;
then A1: P[0] by GLIB_000:12,GLIB_003:8;
A2: now let n be Element of NAT; set Gn = CS.n, Gn1 = CS.(n+1); assume
    A3: P[n];
        consider source',sink' being Vertex of Gn such that
    A4: source' = source & sink' = sink & Gn1 = FF:Step(Gn,source',sink')
          by Def23;
         now per cases;
          suppose
        A5: sink' in AP:FindAugPath(Gn,source').labeledV();
            set P = AP:GetAugPath(Gn,source',sink');
             Gn1 = FF:AugmentPath(Gn, P) by A4,A5,Def22;
            then Gn1 == Gn & the_Weight_of Gn1 = the_Weight_of Gn by
GLIB_000:12,GLIB_003:8;
            hence P[n+1] by A3,GLIB_000:88;
          end;
          suppose not sink' in AP:FindAugPath(Gn,source').labeledV();
            hence P[n+1] by A3,A4,Def22;
          end;
        end;
        hence P[n+1];
    end;
     for n being Element of NAT holds P[n] from NAT_1:sch 1(A1,A2);
    hence thesis;
end;

theorem Th18: ::tFLOWCS01
  for G being finite nonnegative-weighted WGraph,
              source,sink being Vertex of G, n being Element of NAT
   st source <> sink
    holds FF:CompSeq(G,source,sink).n has_valid_flow_from source,sink
    proof
    let G be finite nonnegative-weighted WGraph, source,sink be Vertex of G,
        n be Element of NAT; assume
A1: source <> sink;
    set CS = FF:CompSeq(G,source,sink);
    defpred P[Element of NAT] means (CS.$1) has_valid_flow_from source,sink;
     now set G0 = CS.0;
    A2: G0 = G.set(ELabelSelector, the_Edges_of G --> 0) by Def23;
    then A3: G0 == G by GLIB_003:8;
        hence source is Vertex of G0 & sink is Vertex of G0 by GLIB_000:def 36;
    A4: the_ELabel_of G0 = the_Edges_of G --> 0 by A2,GLIB_000:11;
         now let e be set; assume e in the_Edges_of G0;
        then A5: e in the_Edges_of G by A3,GLIB_000:def 36;
            hence 0 <= (the_ELabel_of G0).e by A4,FUNCOP_1:13;
             G0 is nonnegative-weighted by GLIB_003:def 28;
            then A6: rng the_Weight_of G0 c= Real>=0 by GLIB_003:def 14;
             dom the_Weight_of G0 = the_Edges_of G0 by PBOOLE:def 3
                                .= the_Edges_of G by A3,GLIB_000:def 36;
            then (the_Weight_of G0).e in rng (the_Weight_of G0)
              by A5,FUNCT_1:def 5;
            then (the_Weight_of G0).e in Real>=0 by A6;
            then consider r being Real such that
        A7: r = (the_Weight_of G0).e & r >= 0 by GRAPH_5:def 12;
            thus (the_ELabel_of G0).e <= (the_Weight_of G0).e
              by A4,A5,A7,FUNCOP_1:13;
        end;
        hence (for e being set st e in the_Edges_of G0 holds
          0 <= (the_ELabel_of G0).e &
          (the_ELabel_of G0).e <= (the_Weight_of G0).e);
        let v be Vertex of G0; assume v <> source & v <> sink;
        set B1 = EmptyBag v.edgesIn(), B2 = EmptyBag v.edgesOut();
        set E1 = ((the_ELabel_of G0)|v.edgesIn());
        set E2 = ((the_ELabel_of G0)|v.edgesOut());
         now let e be set; assume
        A8: e in v.edgesIn();
            then e in the_Edges_of G0;
        then A9: e in the_Edges_of G by A3,GLIB_000:def 36;
             E1.e = (the_ELabel_of G0).e by A8,FUNCT_1:72
                .= 0 by A4,A9,FUNCOP_1:13;
            hence B1.e = E1.e by POLYNOM1:56;
        end;
    then A10: Sum E1 = Sum B1 by GLIB_004:6
              .= 0 by UPROOTS:13;
         now let e be set; assume
        A11: e in v.edgesOut();
            then e in the_Edges_of G0;
        then A12: e in the_Edges_of G by A3,GLIB_000:def 36;
             E2.e = (the_ELabel_of G0).e by A11,FUNCT_1:72
                .= 0 by A4,A12,FUNCOP_1:13;
            hence B2.e = E2.e by POLYNOM1:56;
        end;
        then Sum E2 = Sum B2 by GLIB_004:6
              .= 0 by UPROOTS:13;
        hence Sum E1 = Sum E2 by A10;
    end;
then A13: P[0] by Def7;
     now let n be Element of NAT; set Gn = CS.n, Gn1 = CS.(n+1); assume
    A14: Gn has_valid_flow_from source,sink;
        consider source',sink' being Vertex of Gn such that
    A15: source'=source & sink'=sink & Gn1 = FF:Step(Gn,source',sink')
          by Def23;
         now per cases;
          suppose
        A16: sink in AP:FindAugPath(Gn,source').labeledV();
            set P = AP:GetAugPath(Gn,source',sink');
        A17: Gn1 = FF:AugmentPath(Gn, P) by A15,A16,Def22;
             P is_Walk_from source',sink'
              by A15,A16,Def17;
            hence P[n+1] by A1,A14,A15,A17,Th15;
          end;
          suppose not sink in AP:FindAugPath(Gn,source').labeledV();
            hence P[n+1] by A14,A15,Def22;
          end;
        end;
        hence P[n+1];
    end;
then A18: for n being Element of NAT st P[n] holds P[n+1];
     for n being Element of NAT holds P[n] from NAT_1:sch 1(A13,A18);
    hence thesis;
end;

registration let s be natural-weighted WEGraphSeq, n be Nat;
 cluster s.n -> natural-weighted WEGraph;
 coherence by Def5;
end;

registration let s be natural-elabeled WEGraphSeq, n be Nat;
 cluster s.n -> natural-elabeled WEGraph;
 coherence by Def6;
end;

theorem Th19: ::tMAXFLOW01
  for G being finite natural-weighted WGraph,source,sink being Vertex of G st
      source <> sink holds FF:CompSeq(G,source,sink) is halting  proof
    let G be finite natural-weighted WGraph, source, sink be Vertex of G;
    assume
A1: source <> sink;
    set CS = FF:CompSeq(G,source,sink);
     now assume
    A2: for n being Element of NAT holds CS.n <> CS.(n+1);
        defpred P[Element of NAT] means $1 <= (CS.$1).flow(source,sink) &
                             (CS.$1).flow(source,sink) is Element of NAT;
         now set G0 = CS.0;
            set E1 = (the_ELabel_of G0) | G0.edgesInto({sink});
            set E2 = (the_ELabel_of G0) | G0.edgesOutOf({sink});
        A3: G0 has_valid_flow_from source,sink by A1,Th18;
        then A4: G0.flow(source,sink) = Sum E1 - Sum E2 by Def8;
        A5: G0 = G.set(ELabelSelector, the_Edges_of G --> 0) by Def23;
            then G0 == G by GLIB_003:8;
        then A6: the_Edges_of G0 = the_Edges_of G by GLIB_000:def 36;
        A7: the_ELabel_of G0 = the_Edges_of G --> 0 by A5,GLIB_000:11;
            set B1 = EmptyBag G0.edgesInto({sink});
            set B2 = EmptyBag G0.edgesOutOf({sink});
             now let e be set; assume
            A8: e in G0.edgesInto({sink});
                then E1.e = (the_ELabel_of G0).e by FUNCT_1:72;
                hence E1.e = 0 by A6,A7,A8,FUNCOP_1:13
                          .= B1.e by POLYNOM1:56;
            end;
        then A9: Sum E1 = Sum B1 by GLIB_004:6
                  .= 0 by UPROOTS:13;
             now let e be set; assume
            A10: e in G0.edgesOutOf({sink});
                then E2.e = (the_ELabel_of G0).e by FUNCT_1:72;
                hence E2.e = 0 by A6,A7,A10,FUNCOP_1:13
                          .= B2.e by POLYNOM1:56;
            end;
        then A11: Sum E2 = Sum B2 by GLIB_004:6
                  .= 0 by UPROOTS:13;
            hence G0.flow(source,sink) = 0 qua Nat - 0 by A3,A9,Def8;
            thus G0.flow(source,sink) is Element of NAT by A4,A9,A11;
        end;
    then A12: P[0];
         now let n be Element of NAT; set Gn = CS.n, Gn1 = CS.(n+1); assume
        A13: n <= Gn.flow(source,sink) & Gn.flow(source,sink)
        is Element of NAT;
        A14: Gn has_valid_flow_from source,sink &
              Gn1 has_valid_flow_from source,sink by A1,Th18;
            consider source',sink' being Vertex of Gn such that
        A15: source' = source & sink' = sink &
              Gn1 = FF:Step(Gn, source',sink') by Def23;
        A16: now assume not sink in AP:FindAugPath(Gn,source').labeledV();
                then Gn1 = Gn by A15,Def22;
                hence contradiction by A2;
            end;
        then A17: Gn1 = FF:AugmentPath(Gn,AP:GetAugPath(Gn,source',sink'))
              by A15,Def22;
            set P = AP:GetAugPath(Gn,source',sink');
        A18: P is_Walk_from source',sink' by A15,A16,Def17;
            then P.first() = source' & P.last() = sink' by GLIB_001:def 23;
            then P is non trivial by A1,A15,GLIB_001:128;
        then A19: 0 < P.tolerance() by Th14;
            reconsider GnF = Gn.flow(source,sink) as Element of NAT by A13;
        A20: GnF + P.tolerance() = Gn1.flow(source,sink)
              by A1,A14,A15,A17,A18,Th16;
            then reconsider Gn1F = Gn1.flow(source,sink) as Element of NAT;
             GnF + P.tolerance()-P.tolerance() < Gn1F-0 by A19,A20,REAL_1:92;
then n < Gn1F by A13,XXREAL_0:2;
            hence n+1 <= Gn1.flow(source,sink) by NAT_1:13;
            thus Gn1.flow(source,sink) is Element of NAT by A20;
        end;
    then A21: for n being Element of NAT st P[n] holds P[n+1];
    A22: for n being Element of NAT holds P[n] from NAT_1:sch 1(A12,A21);
        set V = {source};
    A23: source in V & not sink in V by A1,TARSKI:def 1;
        set W1 = (the_Weight_of G)|G.edgesDBetween(V,the_Vertices_of G \ V);
         degree W1 = Sum W1;
        then reconsider N = Sum W1 as Element of NAT;
        set Gn1 = CS.(N+1);
        reconsider Gn1F = Gn1.flow(source,sink) as Element of NAT by A22;
         Sum W1 + 1 <= Gn1F by A22;
    then A24: Sum W1 < Gn1.flow(source,sink) by NAT_1:13;
    A25: Gn1 == G & the_Weight_of G = the_Weight_of Gn1 by Th17;
        then reconsider V'=V as Subset of the_Vertices_of Gn1 by
GLIB_000:def 36;
        set W2 = (the_Weight_of Gn1) |
                  Gn1.edgesDBetween(V',the_Vertices_of Gn1 \ V');
         W1 = (the_Weight_of Gn1) |
               G.edgesDBetween(V', the_Vertices_of Gn1 \ V')
               by A25,GLIB_000:def 36
          .= W2 by A25,GLIB_000:93;
    then A26: Sum W1 = Sum W2 by GLIB_004:7;
         Gn1 has_valid_flow_from source,sink by A1,Th18;
        hence contradiction by A23,A24,A26,Th12;
    end;
    hence FF:CompSeq(G,source,sink) is halting by GLIB_000:def 68;
end;

theorem Th20: ::tMAXFLOW02
  for G being finite real-weighted real-elabeled complete-elabeled WEGraph,
      source,sink being set
   st source <> sink & G has_valid_flow_from source,sink &
   not ex P being augmenting Path of G st P is_Walk_from source,sink
   holds G has_maximum_flow_from source,sink  proof
    let G be finite real-weighted real-elabeled complete-elabeled WEGraph,
        source,sink be set; assume
A1: source <> sink & G has_valid_flow_from source,sink &
    not ex P being augmenting Path of G st P is_Walk_from source,sink;
    then reconsider src = source as Vertex of G by Def7;
    set CS = AP:CompSeq(G,src), Gn = AP:FindAugPath(G,src), V = Gn.labeledV();
    set Gn1 = CS.(CS.Lifespan()+1);
A2: Gn == G & the_Weight_of Gn = the_Weight_of G &
      the_ELabel_of Gn = the_ELabel_of G by Th10;
then A3: the_Vertices_of Gn = the_Vertices_of G &
    the_Edges_of Gn = the_Edges_of G &
    the_Source_of Gn = the_Source_of G &
    the_Target_of Gn = the_Target_of G by GLIB_000:def 36;
    reconsider V as Subset of the_Vertices_of G by A2,GLIB_000:def 36;
A4: source in V by Th10;
A5: sink in Gn.labeledV() iff
     ex P being Path of G st P is augmenting & P is_Walk_from src,sink
      by Th9;
    set E1 = G.edgesDBetween(V, the_Vertices_of G \ V);
    set E2 = G.edgesDBetween(the_Vertices_of G \ V, V);
A6: G.flow(source,sink) = Sum((the_ELabel_of G) | E1) -
                          Sum((the_ELabel_of G) | E2) by A1,A4,A5,Th11;
    set A1 = (the_ELabel_of G)|E1, B1 = (the_Weight_of G)|E1;
A7: AP:CompSeq(G,src) is halting by Th6;
A8: Gn1 = AP:Step(Gn) by Def15;
A9: Gn1 = Gn by A7,GLIB_000:def 57;
    set e = choose AP:NextBestEdges(Gn);
A10: now assume
    A11: AP:NextBestEdges(Gn) <> {};
    then A12: e in AP:NextBestEdges(Gn);
         now per cases by A11,Def13;
          suppose e is_forward_labeling_in Gn;
        then A13: (the_Source_of Gn).e in V &
              not (the_Target_of Gn).e in V by Def10;
        then A14: Gn = Gn.labelVertex((the_Target_of Gn).e,e)
              by A8,A9,A11,Def14;
             (the_Target_of Gn).e in the_Vertices_of Gn
              by A12,FUNCT_2:7;
            hence contradiction by A13,A14,GLIB_003:64;
          end;
          suppose e is_backward_labeling_in Gn;
        then A15: (the_Target_of Gn).e in V &
              not (the_Source_of Gn).e in V by Def11;
        then A16: Gn = Gn.labelVertex((the_Source_of Gn).e,e)
              by A8,A9,A11,Def14;
             (the_Source_of Gn).e in the_Vertices_of Gn
              by A12,FUNCT_2:7;
            hence contradiction by A15,A16,GLIB_003:64;
          end;
        end;
        hence contradiction;
    end;
A17: now let x be set; assume
    A18: x in E1;
    then A19: A1.x = (the_ELabel_of Gn).x & B1.x = (the_Weight_of Gn).x
          by A2,FUNCT_1:72;
         x DSJoins V, the_Vertices_of G \ V, G by A18,GLIB_000:def 33;
    then A20: x in the_Edges_of Gn &
        (the_Source_of Gn).x in V &
        (the_Target_of Gn).x in the_Vertices_of Gn \ V
        by A3,GLIB_000:def 18;
    then A21: not (the_Target_of Gn).x in V by XBOOLE_0:def 4;
    A22: A1.x <= B1.x by A1,A2,A3,A19,A20,Def7;
        set e = choose AP:NextBestEdges(Gn);
         now assume A1.x < B1.x;
            then x is_forward_labeling_in Gn by A19,A20,A21,Def10;
            hence contradiction by A10,Def13;
        end;
        hence A1.x = B1.x by A22,XXREAL_0:1;
    end;
    set A2 = (the_ELabel_of G)|E2, B2 = EmptyBag E2;
     now let x be set; assume
    A23: x in E2;
    then A24: A2.x = (the_ELabel_of Gn).x by A2,FUNCT_1:72;
         B2 = E2 --> 0 by POLYNOM1:def 15;
    then A25: B2.x = 0 by A23,FUNCOP_1:13;
         x DSJoins the_Vertices_of G \ V, V, G by A23,GLIB_000:def 33;
    then A26: x in the_Edges_of Gn &
        (the_Source_of Gn).x in the_Vertices_of Gn \ V &
        (the_Target_of Gn).x in V by A3,GLIB_000:def 18;
    then A27: not (the_Source_of Gn).x in V by XBOOLE_0:def 4;
        set e = choose AP:NextBestEdges(Gn);
         now assume 0 < A2.x;
            then x is_backward_labeling_in Gn by A24,A26,A27,Def11;
            hence contradiction by A10,Def13;
        end;
        hence A2.x = B2.x by A1,A2,A3,A24,A25,A26,Def7;
    end;
    then Sum ((the_ELabel_of G) | E2) = Sum B2 by GLIB_004:6;
then Sum ((the_ELabel_of G) | E2) = 0 by UPROOTS:13;
then A28: G.flow(source,sink) = Sum ((the_Weight_of G)|E1) by A6,A17,GLIB_004:6
;
     now let X be finite real-weighted real-elabeled complete-elabeled WEGraph;
        assume
    A29: X == G & the_Weight_of X = the_Weight_of G &
          X has_valid_flow_from source,sink;
    then A30: the_Vertices_of G = the_Vertices_of X by GLIB_000:def 36;
        reconsider V'=V as Subset of the_Vertices_of X by A29,GLIB_000:def 36;
        set E1' = X.edgesDBetween(V', the_Vertices_of X \ V');
         E1' = E1 by A29,A30,GLIB_000:93;
        hence X.flow(source,sink) <= G.flow(source,sink)
          by A1,A4,A5,A28,A29,Th12;
    end;
    hence G has_maximum_flow_from source,sink by A1,Def9;
 end;

theorem ::tMAXFLOW03
   for G being finite real-weighted WGraph, source, sink being Vertex of G
holds
     G == FF:MaxFlow(G,source,sink) &
     the_Weight_of G = the_Weight_of FF:MaxFlow(G,source,sink) by Th17;

theorem ::tMAXFLOW04
   for G being finite natural-weighted WGraph, source,sink being Vertex of G
   st sink <> source holds
   FF:MaxFlow(G,source,sink) has_maximum_flow_from source,sink  proof
    let G be finite natural-weighted WGraph, source, sink be Vertex of G;
    set CS = FF:CompSeq(G,source,sink); assume
A1: sink <> source;
    set n = CS.Lifespan(), Gn = CS.n, Gn1 = CS.(n+1);
    consider source',sink' being Vertex of Gn such that
A2: source'=source & sink'=sink & Gn1 = FF:Step(Gn,source',sink') by Def23;
     CS is halting by A1,Th19;
then A3: Gn = CS.(n+1) by GLIB_000:def 57;
A4: Gn has_valid_flow_from source,sink by A1,Th18;
     now given P being augmenting Path of Gn such that
    A5: P is_Walk_from source,sink;
    A6: sink in AP:FindAugPath(Gn,source').labeledV() by A2,A5,Th9;
    then A7: Gn1 = FF:AugmentPath(Gn, AP:GetAugPath(Gn,source',sink'))
          by A2,Def22;
        set P = AP:GetAugPath(Gn,source',sink');
    A8: P is_Walk_from source',sink'
          by A2,A6,Def17;
        then P.first() = source' & P.last() = sink' by GLIB_001:def 23;
        then A9: P is non trivial by A1,A2,GLIB_001:128;
         Gn.flow(source',sink') + P.tolerance() = Gn1.flow(source,sink)
          by A1,A2,A4,A7,A8,Th16;
        hence contradiction by A2,A3,A9,Th14;
      end;
    hence thesis by A1,A4,Th20;
end;
