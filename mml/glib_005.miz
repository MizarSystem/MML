:: Proof of Ford/Fulkerson's Maximum Network Flow Algorithm
::  by Gilbert Lee
:: Revised by Piotr Rudnicki, September 2008
::
:: Received February 22, 2005
:: Copyright (c) 2005 Association of Mizar Users

environ

 vocabularies AMI_1, ARYTM, ARYTM_1, ARYTM_3, BOOLE, CARD_1, CAT_1, FINSEQ_1,
      FINSET_1, FUNCOP_1, FUNCT_1, FUNCT_4, GRAPH_1, GRAPH_5, GLIB_000,
      GLIB_001, GLIB_003, GLIB_005, MATRIX_2, MSAFREE2, NAT_1, NEWTON,
      PARTFUN1, PBOOLE, POLYNOM1, PRE_TOPC, REALSET1, RELAT_1, RLVECT_1,
      SGRAPH1, TREES_1, UPROOTS, VALUED_0;
 notations TARSKI, XBOOLE_0, CARD_1, ZFMISC_1, MCART_1, PRE_FF, NUMBERS,
      SUBSET_1, XCMPLX_0, XXREAL_0, XREAL_0, DOMAIN_1, REAL_1, RELAT_1,
      VALUED_0, PARTFUN1, FUNCT_1, PBOOLE, FINSEQ_1, VALUED_1, SEQ_1, FUNCT_2,
      GRAPH_5, ORDINAL1, POLYNOM1, UPROOTS, RELSET_1, FINSET_1, INT_1, NAT_1,
      NAT_D, FUNCOP_1, FUNCT_4, FUNCT_7, GLIB_000, GLIB_001,
      ABIAN, GLIB_002, GLIB_003, GLIB_004, RFUNCT_3;
 constructors RFUNCT_3, DOMAIN_1, FUNCT_4, XXREAL_0, REAL_1, NAT_D, BINOP_2,
      GRAPH_2, GRAPH_5, UPROOTS, GLIB_004, SEQ_1, VALUED_1, PARTFUN1,
      PRE_FF, RECDEF_1, XXREAL_2, RELSET_1, PBOOLE;
 registrations XBOOLE_0, SUBSET_1, RELAT_1, RELSET_1, PARTFUN1, RFUNCT_3,
      INT_1, FUNCT_1, ORDINAL1, FUNCOP_1, FINSET_1, NUMBERS, XXREAL_0, XREAL_0,
      NAT_1, MEMBERED, FINSEQ_1, RFINSEQ, GLIB_000, ABIAN, POLYNOM1, BAGORDER,
      GLIB_001, GLIB_002, GLIB_003, GLIB_004, SEQM_3, VALUED_0, VALUED_1,
      FUNCT_2, FINSEQ_2, XCMPLX_0, HEYTING3, CARD_1, PRE_CIRC;
 requirements ARITHM, BOOLE, NUMERALS, REAL, SUBSET;
 definitions TARSKI, GLIB_000, GLIB_003, FUNCOP_1, VALUED_1;
 theorems CARD_1, CARD_2, FUNCOP_1, FINSEQ_1, FINSEQ_2, FINSEQ_3, FUNCT_1,
      FUNCT_2, FUNCT_4, GLIB_000, GLIB_001, GLIB_003, GLIB_004, GRAPH_5,
      HEYTING3, INT_1, NAT_1, PBOOLE, PEPIN, POLYNOM1, TARSKI, UPROOTS,
      XBOOLE_0, XBOOLE_1, ZFMISC_1, XREAL_1, XXREAL_0, ORDINAL1, NAT_D,
      VALUED_0, RELSET_1, PARTFUN1, RELAT_1;
 schemes NAT_1, SUBSET_1, FINSEQ_1, CLASSES1, RECDEF_1, GRAPH_5;

begin

Tw0:
for F being Function, x,y being set
 holds dom(F+*(x.-->y)) = dom F \/ {x}
proof let F be Function, x,y be set;
  thus dom(F+*(x.-->y)) = dom F \/ dom(x.-->y) by FUNCT_4:def 1
          .= dom F \/ {x} by FUNCOP_1:19;
end;

Tw0a:
for F being Function, x,y being set holds x in dom (F+*(x.-->y))
proof
  let F be Function, x,y being set;
    dom (x.-->y) = {x} by FUNCOP_1:19;
    then
A: x in dom (x.-->y) by TARSKI:def 1;
    dom (x.-->y) c= dom (F+*(x.-->y)) by FUNCT_4:11;
  hence thesis by A;
end;

Tw1:
for F being Function, x,y being set
  holds (F+*(x.-->y)).x = y
proof
 let F be Function, x,y be set;
    dom (x.-->y) = {x} by FUNCOP_1:19;
    then
A: x in dom (x.-->y) by TARSKI:def 1;
  thus (F+*(x.-->y)).x = (x.-->y).x by A,FUNCT_4:14
    .= y by FUNCOP_1:87;
end;

Tw2:
for F being Function, x,y,z being set
  st x <> z holds (F+*(x.-->y)).z = F.z
proof
 let F be Function, x,y,z be set;
 assume
AA: x <> z;
    dom (x.-->y) = {x} by FUNCOP_1:19;
    then not z in dom (x.-->y) by AA,TARSKI:def 1;
 hence thesis by FUNCT_4:12;
end;

begin ::Preliminaries definitions for Maximum Flow Algorithm

definition
  let G be WGraph;
  attr G is natural-weighted means
  :Def3: ::dNATWEIGHT
  the_Weight_of G is natural-valued;
end;

registration
  cluster natural-weighted -> nonnegative-weighted WGraph;
  coherence
  proof
    let G be WGraph;
    assume G is natural-weighted;
    then
A1: the_Weight_of G is natural-valued by Def3;
    now
      let y be set;
      assume
A2:   y in rng the_Weight_of G;
      rng the_Weight_of G c= NAT by A1,VALUED_0:def 6;
      then reconsider y'=y as Element of NAT by A2;
      y' is Real & y' >= 0;
      hence y in Real>=0 by GRAPH_5:def 12;
    end;
    then rng the_Weight_of G c= Real>=0 by TARSKI:def 3;
    hence thesis by GLIB_003:def 14;
  end;
end;

registration
  cluster finite trivial Tree-like natural-weighted WGraph;
  existence
  proof
    set V = {1};
    set E = {};
    reconsider S = {} as Function of E,V by RELSET_1:25;
    set G1 = createGraph(V,E,S,S);
    consider WL being Function of the_Edges_of G1, NAT;
    set G2 = G1.set(WeightSelector, WL);
    take G2;
    thus G2 is finite & G2 is trivial & G2 is Tree-like;
    the_Weight_of G2 = WL by GLIB_000:11;
    hence thesis by Def3;
  end;
end;

registration
  let G be natural-weighted WGraph;
  cluster the_Weight_of G -> natural-valued;
  coherence by Def3;
end;

definition
  let G be _Graph;
  mode FF:ELabeling of G is natural-valued ManySortedSet of the_Edges_of G;
    :: NAT can be replaced by RAT but then we can convert it to the NAT case
    :: as the graphs are finite
end;

definition
  let G be finite real-weighted WGraph, EL be FF:ELabeling of G,
      source,sink be set;
  pred EL has_valid_flow_from source,sink means
  :Def7: ::dVFLOW
  source is Vertex of G & sink is Vertex of G &
  (for e being set st e in the_Edges_of G
    holds 0 <= EL.e &
          EL.e <= (the_Weight_of G).e) &
          (for v being Vertex of G st v <> source & v <> sink
            holds Sum (EL | v.edgesIn()) = Sum (EL | v.edgesOut()));
end;

definition
  let G be finite real-weighted WGraph, EL be FF:ELabeling of G,
      source, sink be set;
  assume EL has_valid_flow_from source,sink;
  func EL.flow(source,sink) -> real number equals
  :Def8: ::dGFLOW
  Sum (EL | G.edgesInto({sink})) - Sum (EL | G.edgesOutOf({sink}));
  coherence;
end;

definition
  let G be finite real-weighted WGraph, EL being FF:ELabeling of G,
      source,sink be set;
  pred EL has_maximum_flow_from source,sink means
  :Def9: ::dGMAXFLOW
  EL has_valid_flow_from source,sink &
  for E2 being FF:ELabeling of G st E2 has_valid_flow_from source,sink
   holds E2.flow(source,sink) <= EL.flow(source,sink);
end;

definition
  let G be _Graph, EL be FF:ELabeling of G;
  mode AP:VLabeling of EL
                      -> PartFunc of the_Vertices_of G, {1} \/ the_Edges_of G
     :: 1 used to mark source at the sart
  means :HeHe:
  not contradiction;
  existence;
end;

definition
  let G be real-weighted WGraph;
  let EL be FF:ELabeling of G, VL be AP:VLabeling of EL;
  let e be set;
  pred e is_forward_edge_wrt VL means                :Def10: ::dFORLABEL
  e in the_Edges_of G &
  (the_Source_of G).e in dom VL & not (the_Target_of G).e in dom VL &
  EL.e < (the_Weight_of G).e;
end;

definition
  let G be real-weighted WGraph;
  let EL be FF:ELabeling of G, VL be AP:VLabeling of EL;
  let e be set;
  pred e is_backward_edge_wrt VL means             :Def11: ::dBACKLABEL
  e in the_Edges_of G &
  (the_Target_of G).e in dom VL & not (the_Source_of G).e in dom VL &
  0 < EL.e;
end;

   :: attribute with alternative structures
definition
  let G be real-weighted WGraph, EL be FF:ELabeling of G,
      W be Walk of G;
  pred W is_augmenting_wrt EL means
  :Def12: ::dWAUGMENT
  for n being odd Nat st n < len W holds
  (W.(n+1) DJoins W.n, W.(n+2), G implies
                               EL.(W.(n+1)) < (the_Weight_of G).(W.(n+1))) &
  (not W.(n+1) DJoins W.n,W.(n+2), G implies 0 < EL.(W.(n+1)));
end;

theorem Th001:
for G being real-weighted WGraph, EL be FF:ELabeling of G,
    W being Walk of G
 st W is trivial
  holds W is_augmenting_wrt EL
proof
    let G be real-weighted WGraph, EL be FF:ELabeling of G;
    let W be Walk of G;
    assume
A1: W is trivial;
    now
      let n be odd Nat;
      assume n < len W;
      then n < 1 by A1,GLIB_001:127;
      hence (W.(n+1) DJoins W.n, W.(n+2), G implies
      EL.(W.(n+1)) < (the_Weight_of G).(W.(n+1))) &
      (not W.(n+1) DJoins W.n,W.(n+2), G implies
      0 < EL.(W.(n+1))) by HEYTING3:1;
    end;
    hence thesis by Def12;
end;

theorem Th002:
for G being real-weighted WGraph, EL be FF:ELabeling of G,
    W being Walk of G, m,n be Nat
 st W is_augmenting_wrt EL
  holds W.cut(m,n) is_augmenting_wrt EL
proof
  let G be real-weighted WGraph, EL be FF:ELabeling of G,
      W being Walk of G, m,n be Nat;
  assume
AA: W is_augmenting_wrt EL;
    set W2 = W.cut(m,n);
    now per cases;
      suppose
A1:     (m is odd & n is odd & m <= n & n <= len W);
        then reconsider m'=m, n' = n as odd Element of NAT by ORDINAL1:def 13;
        now
          let x be odd Nat;
          reconsider x' = x as Element of NAT by ORDINAL1:def 13;
          assume x < len W2;
          then
A2:       x' in dom W2 & x'+1 in dom W2 & x'+2 in dom W2 by GLIB_001:13;
          set v1b = W2.x, eb = W2.(x+1), v2b = W2.(x+2);
          m' <= n' & n' <= len W by A1;   :: Why do I have to do it?
          then
A3:       W2.x' = W.(m'+x'-1) & (m'+x'-1) in dom W &
          W2.(x'+1) = W.(m'+(x'+1)-1) & (m'+(x'+1)-1) in dom W &
          W2.(x'+2) = W.(m'+(x'+2)-1) & (m'+(x'+2)-1) in dom W
          by A2,GLIB_001:48;
          then reconsider a = m'+x-1,a1 = m+(x+1)-1,a2=m+(x+2)-1
          as Element of NAT;
          reconsider a as odd Element of NAT;
          set v1a = W.a, ea = W.(a+1), v2a = W.(a+2);
          a2 <= len W by A3,FINSEQ_3:27;
          then
A4:       m+(x+2)-1-2 < len W - 0 by XREAL_1:17;
          hereby
            assume eb DJoins v1b,v2b,G;
            then ea DJoins v1a,v2a,G by A3;
            hence EL.eb < (the_Weight_of G).eb by AA,A3,A4,Def12;
          end;
          assume not eb DJoins v1b,v2b,G;
          then not ea DJoins v1a,v2a,G by A3;
          hence 0 < EL.eb by AA,A3,A4,Def12;
        end;
        hence thesis by Def12;
      end;
      suppose not (m is odd & n is odd & m <= n & n <= len W);
        hence thesis by AA,GLIB_001:def 11;
      end;
    end;
    hence thesis;
  end;

theorem Th2: ::tWAUGMENT02
for G being real-weighted WGraph, EL being FF:ELabeling of G,
    W being Walk of G, e,v being set
 st W is_augmenting_wrt EL & not v in W.vertices() &
    ((e DJoins W.last(),v,G & EL.e < (the_Weight_of G).e) or
     (e DJoins v,W.last(),G & 0 < (EL.e)))
  holds W.addEdge(e) is_augmenting_wrt EL
proof
  let G be real-weighted WGraph, EL being FF:ELabeling of G,
  W be Walk of G, e,v be set;
  assume
AA: W is_augmenting_wrt EL;
  set W2 = W.addEdge(e);
  assume
A1: not v in W.vertices() &
  ((e DJoins W.last(),v,G & EL.e < (the_Weight_of G).e) or
  (e DJoins v,W.last(),G & 0 < EL.e));
  let n be odd Nat;
  assume
A2: n < len W2;
A3: e Joins W.last(),v,G by A1,GLIB_000:19;
  now per cases;
    suppose
A4:   n < len W;
      reconsider n' = n as Element of NAT by ORDINAL1:def 13;
      n' in dom W & n'+1 in dom W & n'+2 in dom W by A4,GLIB_001:13;
      then W.n = W2.n & W.(n+1) = W2.(n+1) & W.(n+2) = W2.(n+2)
      by A3,GLIB_001:66;
      hence thesis by AA,A4,Def12;
    end;
    suppose
A5:   n >= len W;
      n+1 <= len W2 by A2,NAT_1:13;
      then n+1 <= len W + 2*1 by A3,GLIB_001:65;
      then n+1 < len W + 1+1 by XXREAL_0:1;
      then n+1 <= len W + 1 by NAT_1:13;
      then n <= len W by XREAL_1:8;
      then
A6:   1 <= n & n = len W by A5,HEYTING3:1,XXREAL_0:1;
      then n in dom W by FINSEQ_3:27;
      then
A7:   W2.n = W.n by A3,GLIB_001:66
        .= W.last() by A6,GLIB_001:def 7;
A8:   W2.(n+1) = e & W2.(n+2) = v by A3,A6,GLIB_001:66;
      now
        assume e DJoins W.last(),v,G & e DJoins v,W.last(),G;
        then (the_Source_of G).e = W.last() &
        (the_Source_of G).e = v by GLIB_000:def 16;
        hence contradiction by A1,GLIB_001:89;
      end;
      hence W2.(n+1) DJoins W2.n, W2.(n+2),G implies
      EL.(W2.(n+1)) < (the_Weight_of G).(W2.(n+1)) by A1,A7,A8;
      assume not W2.(n+1) DJoins W2.n, W2.(n+2),G;
      hence 0 < EL.(W2.(n+1)) by A1,A7,A8;
    end;
  end;
  hence thesis;
end;

begin :: Finding an Augmenting Path in a Graph

definition
  let G be real-weighted WGraph;
  let EL be FF:ELabeling of G, VL be AP:VLabeling of EL;
  func AP:NextBestEdges(VL) -> Subset of the_Edges_of G means
  :Def13: ::dAPNEXT
  for e being set
   holds e in it iff (e is_forward_edge_wrt VL or e is_backward_edge_wrt VL);
  existence
  proof
    defpred P[set] means $1 is_forward_edge_wrt VL or
    $1 is_backward_edge_wrt VL;
    consider IT being Subset of the_Edges_of G such that
A1: for e being set holds e in IT iff e in the_Edges_of G & P[e]
    from SUBSET_1:sch 1;
    take IT;
    let e be set;
    thus e in IT implies P[e] by A1;
    assume
A2: P[e];
    then e in the_Edges_of G by Def10,Def11;
    hence thesis by A1,A2;
  end;
  uniqueness
  proof
    let IT1,IT2 be Subset of the_Edges_of G such that
A3: for e being set holds e in IT1 iff
    (e is_forward_edge_wrt VL or e is_backward_edge_wrt VL) and
A4: for e being set holds e in IT2 iff
    (e is_forward_edge_wrt VL or e is_backward_edge_wrt VL);
    now
      let e be set;
      hereby
        assume e in IT1;
        then (e is_forward_edge_wrt VL or e is_backward_edge_wrt VL)
        by A3;
        hence e in IT2 by A4;
      end;
      assume e in IT2;
      then (e is_forward_edge_wrt VL or e is_backward_edge_wrt VL) by A4;
      hence e in IT1 by A3;
    end;
    hence thesis by TARSKI:2;
  end;
end;

definition
  let G be real-weighted WGraph;
  let EL be FF:ELabeling of G, VL be AP:VLabeling of EL;
  func AP:Step(VL) -> AP:VLabeling of EL equals                     :Def14:
  VL if AP:NextBestEdges(VL) = {},
  VL+*((the_Source_of G).(choose AP:NextBestEdges(VL)) .-->
                                    choose AP:NextBestEdges(VL))
     if AP:NextBestEdges(VL) <> {} &
        not (the_Source_of G).(choose AP:NextBestEdges(VL)) in dom VL
     otherwise
  VL+*((the_Target_of G).(choose AP:NextBestEdges(VL)) .-->
                                   choose AP:NextBestEdges(VL));
  coherence proof
   set SG = the_Source_of G, TG = the_Target_of G,
       VG = the_Vertices_of G, EG = the_Edges_of G,
       NB = AP:NextBestEdges(VL);
   set cNB = choose AP:NextBestEdges(VL);
   per cases;
   suppose NB = {};
     hence thesis;
   end;
   suppose NB <> {};
        then
   A02: cNB in NB;
   A0: dom (VL+*(SG.cNB .--> cNB))
        = dom VL \/ dom (SG.cNB .--> cNB) by FUNCT_4:def 1
       .= dom VL \/ {SG.cNB} by FUNCOP_1:19;
   A1: {SG.cNB} c= VG
        proof
          let x be set;
          assume x in {SG.cNB};
          then x = SG.cNB by TARSKI:def 1;
          hence thesis by A02,FUNCT_2:7;
        end;
   Aa0: rng (VL+*(SG.cNB .--> cNB)) c=  rng VL \/ rng (SG.cNB .--> cNB)
          by FUNCT_4:18;
   Aa02: rng (SG.cNB .--> cNB) c= {cNB} by FUNCOP_1:19;
        {cNB} c= EG
        proof
          let x be set;
          assume x in {cNB};
          then x = cNB by TARSKI:def 1;
          hence thesis by A02;
        end;
        then {cNB} c= {1} \/ EG by XBOOLE_1:10;
        then rng (SG.cNB .--> cNB) c= {1} \/ EG by Aa02,XBOOLE_1:1;
        then rng VL \/ rng (SG.cNB .--> cNB) c= {1} \/ EG by XBOOLE_1:8;
        then rng (VL+*(SG.cNB .--> cNB)) c= {1} \/ EG by Aa0,XBOOLE_1:1;
        then
   A: VL+*(SG.cNB .--> cNB) is Relation of VG, {1} \/ EG
                     by A1,A0,RELSET_1:11,XBOOLE_1:8;

   A0: dom (VL+*(TG.cNB .--> cNB))
        = dom VL \/ dom (TG.cNB .--> cNB) by FUNCT_4:def 1
       .= dom VL \/ {TG.cNB} by FUNCOP_1:19;
   A1: {TG.cNB} c= VG
        proof
          let x be set;
          assume x in {TG.cNB};
          then x = TG.cNB by TARSKI:def 1;
          hence thesis by A02,FUNCT_2:7;
        end;
   Aa0: rng (VL+*(TG.cNB .--> cNB)) c=  rng VL \/ rng (TG.cNB .--> cNB)
          by FUNCT_4:18;
   Aa02: rng (TG.cNB .--> cNB) c= {cNB} by FUNCOP_1:19;
        {cNB} c= EG
        proof
          let x be set;
          assume x in {cNB};
          then x = cNB by TARSKI:def 1;
          hence thesis by A02;
        end;
        then {cNB} c= {1} \/ EG by XBOOLE_1:10;
        then rng (TG.cNB .--> cNB) c= {1} \/ EG by Aa02,XBOOLE_1:1;
        then rng VL \/ rng (TG.cNB .--> cNB) c= {1} \/ EG by XBOOLE_1:8;
        then rng (VL+*(TG.cNB .--> cNB)) c= {1} \/ EG by Aa0,XBOOLE_1:1;
        then VL+*(TG.cNB .--> cNB) is Relation of VG, {1} \/ EG
                        by A1,A0,RELSET_1:11,XBOOLE_1:8;
   hence thesis by A,HeHe;
  end;
  end;
  consistency;
end;

definition
  let G be _Graph, EL be FF:ELabeling of G;
  mode AP:VLabelingSeq of EL -> ManySortedSet of NAT means
:DEF1: for n being Nat holds it.n is AP:VLabeling of EL;
  existence proof
    set f = NAT --> {};
    reconsider f as ManySortedSet of NAT;
    take f;
    let n be Nat;
     n in NAT by ORDINAL1:def 13;
     then
  A: f.n = {} by FUNCOP_1:13;
    f.n is PartFunc of the_Vertices_of G, {1} \/ the_Edges_of G
       by A,RELSET_1:25;
    hence thesis by HeHe;
  end;
end;

definition
  let G be _Graph, EL be FF:ELabeling of G;
  let VS be AP:VLabelingSeq of EL, n be Nat;
  redefine func VS.n -> AP:VLabeling of EL;
 coherence by DEF1;
end;

definition
  let G be real-weighted WGraph, EL be FF:ELabeling of G;
  let source be Vertex of G;
  func AP:CompSeq(EL,source) -> AP:VLabelingSeq of EL means
  :Def15: ::dAPCS
  it.0 = source .--> 1 &  :: to start, later ignored
  for n being Nat holds it.(n+1) = AP:Step(it.n);
  existence
  proof
    defpred P[set,set,set] means
    ($2 is AP:VLabeling of EL &
      ex Gn,Gn1 being AP:VLabeling of EL
       st $2 = Gn & $3 = Gn1 & Gn1 = AP:Step(Gn)) or
    (not $2 is AP:VLabeling of EL & $2 = $3);
    now
      let n,x be set;
      now per cases;
        suppose x is AP:VLabeling of EL;
          then reconsider Gn=x as AP:VLabeling of EL;
          P[n,x,AP:Step(Gn)];
         hence ex y being set st P[n,x,y];
        end;
        suppose not x is AP:VLabeling of EL;
          hence ex y being set st P[n,x,y];
        end;
      end;
      hence ex y being set st P[n,x,y];
    end;
    then
A1: for n being Element of NAT for x being set ex y being set st P[n,x,y];
    consider IT being Function such that
A3: dom IT = NAT & IT.0 = source.--> 1 &
    for n being Element of NAT holds P[n,IT.n,IT.(n+1)]
    from RECDEF_1:sch 1(A1);
    reconsider IT as ManySortedSet of NAT by A3,PARTFUN1:def 4,RELAT_1:def 18;
    defpred P2[Nat] means IT.$1 is AP:VLabeling of EL;
    A3a: dom (source .--> 1) = {source} by FUNCOP_1:19;
    A3b: rng (source .--> 1) = {1} by FUNCOP_1:14;
A3e: source .--> 1 is Relation of the_Vertices_of G, {1} \/ the_Edges_of G
         by A3a,A3b,RELSET_1:11,XBOOLE_1:7;
A4: P2[0] by A3,A3e,HeHe;
A5: now
      let n be Nat;
A6:   n in NAT by ORDINAL1:def 13;
      assume P2[n];
      then consider Gn,Gn1 being AP:VLabeling of EL such
      that
A7:   IT.n = Gn & IT.(n+1) = Gn1 & Gn1 = AP:Step(Gn) by A3,A6;
      thus P2[n+1] by A7;
    end;
    for n being Nat holds P2[n] from NAT_1:sch 2(A4,A5);
    then reconsider IT as AP:VLabelingSeq of EL by DEF1;
    take IT;
    thus IT.0 = source.-->1 by A3;
    let n be Nat;
    n is Element of NAT by ORDINAL1:def 13;
    then
    ex Gn,Gn1 being AP:VLabeling of EL st
    IT.n = Gn & IT.(n+1) = Gn1 & Gn1 = AP:Step(Gn) by A3;
    hence thesis;
  end;
  uniqueness
  proof
    let IT1,IT2 be AP:VLabelingSeq of EL such that
A9: IT1.0 = source.-->1 &
    for n being Nat holds IT1.(n+1) = AP:Step(IT1.n) and
A10: IT2.0 = source.-->1 &
    for n being Nat holds IT2.(n+1) = AP:Step(IT2.n);
    defpred P[Nat] means IT1.$1 = IT2.$1;
A11: P[0] by A9,A10;
    now
      let n be Nat;
      assume P[n];
      then IT1.(n+1) = AP:Step(IT2.n) by A9
        .= IT2.(n+1) by A10;
      hence P[n+1];
    end;
    then
A12: for n being Nat st P[n] holds P[n+1];
A12a: for n being Nat holds P[n] from NAT_1:sch 2(A11,A12);
     for n being set st n in NAT holds IT1.n = IT2.n by A12a;
    hence IT1 = IT2 by PBOOLE:3;
  end;
end;

theorem Th3: ::tAPCS01
for G being real-weighted WGraph, EL be FF:ELabeling of G,
    source being Vertex of G
 holds dom (AP:CompSeq(EL,source).0) = {source}
proof
  let G be real-weighted WGraph, EL be FF:ELabeling of G,
      source be Vertex of G;
      AP:CompSeq(EL,source).0 = source .--> 1 by Def15;
  hence thesis by FUNCOP_1:19;
end;

theorem Th4: ::tAPCS02
  for G being real-weighted WGraph, EL being FF:ELabeling of G,
      source being Vertex of G, i,j being Nat
   st i <= j
    holds dom (AP:CompSeq(EL,source).i) c= dom (AP:CompSeq(EL,source).j)
proof
  let G be real-weighted WGraph, EL be FF:ELabeling of G,
      source be Vertex of G, i,j be Nat;
  set CS = AP:CompSeq(EL,source);
  assume
A1: i <= j;
  defpred P[Element of NAT] means dom (CS.i) c= dom (CS.(i+$1));
A2: P[0];
A3: now
    let n be Element of NAT;
    set Gn = (CS.(i+n)), Gn1 = (CS.(i+(n+1)));
    set Next = AP:NextBestEdges(Gn), e = choose Next;
    assume
A4: P[n];
    Gn1 = (CS.(i+n+1));
    then
A5: Gn1 = AP:Step(Gn) by Def15;
    now per cases;
      suppose Next = {};
        hence P[n+1] by A4,A5,Def14;
      end;
      suppose
A6:     Next <> {} & not (the_Source_of G).e in dom Gn;
        Gn1 = Gn+*((the_Source_of G).e .--> e) by A5,A6,Def14;
        then dom Gn c= dom Gn1 by FUNCT_4:11;
        hence P[n+1] by A4,XBOOLE_1:1;
      end;
      suppose
A8:     Next <> {} & (the_Source_of G).e in dom Gn;
        Gn1 = Gn+*((the_Target_of G).e .--> e) by A5,A8,Def14;
        then dom Gn c= dom Gn1 by FUNCT_4:11;
        hence P[n+1] by A4,XBOOLE_1:1;
      end;
    end;
    hence P[n+1];
  end;
A10: for n being Element of NAT holds P[n] from NAT_1:sch 1(A2,A3);
  consider k being Nat such that
A11: j = i+k by A1,NAT_1:10;
  k in NAT by ORDINAL1:def 13;
  hence thesis by A10,A11;
end;

definition
  let G be real-weighted WGraph, EL be FF:ELabeling of G,
      source be Vertex of G;
  func AP:FindAugPath(EL,source) -> AP:VLabeling of EL equals
::dAPFAUGP
    AP:CompSeq(EL,source).Result();
  coherence
  proof
    set CS = AP:CompSeq(EL,source);
    CS.Result() = CS.(CS.Lifespan());
    hence thesis;
  end;
end;

theorem Th6: ::tAPFAP01
  for G being finite real-weighted WGraph, EL be FF:ELabeling of G,
      source being Vertex of G
   holds AP:CompSeq(EL,source) is halting
proof
  let G be finite real-weighted WGraph, EL be FF:ELabeling of G,
      source be Vertex of G;
  set CS = AP:CompSeq(EL,source);
  now
    assume
A1: for n being Element of NAT holds CS.n <> CS.(n+1);
    defpred P[Element of NAT] means card dom (CS.$1) = $1+1;
    dom (CS.0) = {source} by Th3;
    then
A2: P[0] by CARD_1:50;
A3: now
      let n be Element of NAT;
      assume
A4:   P[n];
      set Gn = CS.n, Gn1 = CS.(n+1);
A5:   Gn1 = AP:Step(Gn) by Def15;
      set Next = AP:NextBestEdges(Gn), e = choose Next;
      now per cases;
        suppose Next = {};
          then Gn = CS.(n+1) by A5,Def14;
          hence P[n+1] by A1;
        end;
        suppose
A6:       Next <> {} & not (the_Source_of G).e in dom Gn;
          then
A7:       Gn1 = Gn+*((the_Source_of G).e .--> e) by A5,Def14;
          dom Gn1 = dom Gn \/ {(the_Source_of G).e} by A7,Tw0;
          hence P[n+1] by A4,A6,CARD_2:54;
        end;
        suppose
A8:       Next <> {} & (the_Source_of G).e in dom Gn;
          then
A9:       Gn1 = Gn+*((the_Target_of G).e .--> e) by A5,Def14;
          e is_forward_edge_wrt Gn or e is_backward_edge_wrt Gn by A8,Def13;
          then
A11:      not (the_Target_of G).e in dom Gn by A8,Def10,Def11;
          dom Gn1 = dom Gn \/ {(the_Target_of G).e} by A9,Tw0;
          hence P[n+1] by A4,A11,CARD_2:54;
        end;
      end;
      hence P[n+1];
    end;
A12: for n being Element of NAT holds P[n] from NAT_1:sch 1(A2,A3);
    set x = card the_Vertices_of G;
    card dom (CS.x) = card the_Vertices_of G + 1 by A12;
    then 1+card the_Vertices_of G<=card the_Vertices_of G+0 by NAT_1:44;
    hence contradiction by XREAL_1:8;
  end;
  hence thesis by GLIB_000:def 56;
end;

theorem Th7: ::tAPCS05
  for G being finite real-weighted WGraph, EL being FF:ELabeling of G,
      source being Vertex of G, n being Nat, v being set
  st v in dom (AP:CompSeq(EL,source).n) holds
    (AP:CompSeq(EL,source).n).v = (AP:FindAugPath(EL,source)).v
proof
 let G be finite real-weighted WGraph, EL being FF:ELabeling of G,
      source be Vertex of G, n be Nat, v be set;
  set SG = the_Source_of G, TG = the_Target_of G;
  set CS = AP:CompSeq(EL,source), FAP = AP:FindAugPath(EL,source);
  set L = CS.Lifespan(), GL = CS.L, GL1 = CS.(L+1);
  assume
A1: v in dom (CS.n);
  defpred P[Element of NAT] means
  for v being set st v in dom (CS.n) holds (CS.n).v = (CS.(n+$1)).v;
A2: P[0];
  now
    let k be Element of NAT;
    assume
A3: P[k];
    set Gn = CS.(n+k), Gn1 = CS.(n+k+1);
A4: Gn1 = AP:Step(Gn) by Def15;
    set Next = AP:NextBestEdges(Gn), e = choose Next;
    now per cases;
      suppose Next = {};
        then Gn1 = Gn by A4,Def14;
        hence P[k+1] by A3;
      end;
      suppose
A5:     Next <> {} & not SG.e in dom Gn;
        then
A6:     Gn1 = Gn+*(SG.e .--> e) by A4,Def14;
        now
          let v be set;
          assume
A7:       v in dom (CS.n);
          then
A8:       (CS.n).v = Gn.v by A3;
          dom (CS.n) c= dom Gn by Th4,NAT_1:11;
          then v <> SG.e by A5,A7;
          hence (CS.n).v = Gn1.v by A6,A8,Tw2;
        end;
        hence P[k+1];
      end;
      suppose
A9:     Next <> {} & SG.e in dom Gn;
        then
A10:    Gn1 = Gn+*(TG.e .--> e) by A4,Def14;
A11:    e is_forward_edge_wrt Gn or e is_backward_edge_wrt Gn by A9,Def13;
        now
          let v be set;
          assume
A12:      v in dom (CS.n);
          then
A13:      (CS.n).v = Gn.v by A3;
          dom (CS.n) c= dom Gn by Th4,NAT_1:11;
          then v <> TG.e by A9,A11,A12,Def10,Def11;
          hence (CS.n).v = Gn1.v by A10,A13,Tw2;
        end;
        hence P[k+1];
      end;
    end;
    hence P[k+1];
  end;
  then
A14: for k being Element of NAT st P[k] holds P[k+1];
A15: for k being Element of NAT holds P[k] from NAT_1:sch 1(A2,A14);
A16: CS is halting by Th6;
  defpred P2[Element of NAT] means GL = CS.(L+$1);
A17: P2[0];
A18: now
    let k be Element of NAT;
    set Gn1 = CS.(L+k+1);
    assume P2[k];
    then Gn1 = AP:Step(GL) by Def15
      .= GL1 by Def15;
    hence P2[k+1] by A16,GLIB_000:def 57;
  end;
A19: for k being Element of NAT holds P2[k] from NAT_1:sch 1(A17,A18);
  now per cases;
    suppose n <= CS.Lifespan();
      then consider k being Nat such that
A20:  n + k = CS.Lifespan() by NAT_1:10;
      reconsider k as Element of NAT by ORDINAL1:def 13;
      n + k = CS.Lifespan() by A20;
      hence thesis by A1,A15;
    end;
    suppose CS.Lifespan() < n;
      then consider k being Nat such that
A21:  CS.Lifespan() + k = n by NAT_1:10;
      reconsider k as Element of NAT by ORDINAL1:def 13;
      CS.Lifespan() + k = n by A21;
      hence thesis by A19;
    end;
  end;
  hence thesis;
end;

definition
  let G be finite real-weighted WGraph, EL be FF:ELabeling of G,
      source,sink be Vertex of G;
  func AP:GetAugPath(EL,source,sink) -> vertex-distinct Path of G means
  :Def17: ::dAPGETAUG
  it is_Walk_from source,sink &
  it is_augmenting_wrt EL &
  for n being even Nat st n in dom it holds
    it.n = (AP:FindAugPath(EL,source)).(it.(n+1))
     if sink in dom AP:FindAugPath(EL,source)
     otherwise
  it = G.walkOf(source);
  existence
  proof
    set CS = AP:CompSeq(EL,source), FAP = AP:FindAugPath(EL,source);
    defpred P[Nat] means
    for v being set st v in dom (CS.$1)
     ex P being vertex-distinct Path of G
      st P is_Walk_from source,v & P is_augmenting_wrt EL &
         P.vertices() c= dom (CS.$1) &
         for n being even Nat st n in dom P
          holds P.n = FAP.(P.(n+1));
    now
      let v be set;
      assume v in dom (CS.0);
      then v in {source} by Th3;
      then
A1:   v = source by TARSKI:def 1;
      set P = G.walkOf(source);
      take P;
      thus P is_Walk_from source,v by A1,GLIB_001:14;
      thus P is_augmenting_wrt EL by Th001;
      P.vertices() = {source} by GLIB_001:91;
      hence P.vertices() c= dom (CS.0) by Th3;
      let n be even Nat;
      assume n in dom P;
      then
A2:   1 <= n & n <= len P by FINSEQ_3:27;
      then n < len P by XXREAL_0:1;
      hence P.n = FAP.(P.(n+1)) by A2,GLIB_001:14;
    end;
    then
A3: P[0];
    now
      let n be Nat;
      assume
A4:   P[n];
      set Gn = CS.n, Gn1 = CS.(n+1);
      set Next = AP:NextBestEdges(Gn), e = choose Next;
A5:   Gn1 = AP:Step(Gn) by Def15;
      now per cases;
        suppose Next = {};
          then Gn1 = Gn by A5,Def14;
          hence P[n+1] by A4;
        end;
        suppose
A7:       Next <> {} & not (the_Source_of G).e in dom Gn;
          then
A8:       Gn1 = Gn+*((the_Source_of G).e .--> e) by A5,Def14;
A9:       e in Next by A7;
          e is_forward_edge_wrt Gn or e is_backward_edge_wrt Gn by A7,Def13;
          then
A10:      (the_Target_of G).e in dom Gn & 0 < EL.e by A7,Def10,Def11;
A11:      dom Gn1 = dom Gn \/ {(the_Source_of G).e} by A8,Tw0;
          now
            let v be set;
            assume
A12:        v in dom Gn1;
            now per cases by A11,A12,XBOOLE_0:def 3;
              suppose v in dom Gn;
                then consider P being vertex-distinct Path of G such that
A13:            P is_Walk_from source,v &
                P is_augmenting_wrt EL &
                P.vertices() c= dom Gn &
                for n being even Nat st n in dom P holds
                P.n = FAP.(P.(n+1)) by A4;
                take P;
                dom Gn c= dom Gn1 by Th4,NAT_1:11;
                hence P is_Walk_from source,v &
                P is_augmenting_wrt EL &
                P.vertices() c= dom Gn1 &
                for n being even Nat st n in dom P holds
                P.n = FAP.(P.(n+1)) by A13,XBOOLE_1:1;
              end;
              suppose
A14:            v in {(the_Source_of G).e};
                then
A15:            v = (the_Source_of G).e by TARSKI:def 1;
                now consider W being vertex-distinct Path of G such that
A16:              W is_Walk_from source, (the_Target_of G).e &
                  W is_augmenting_wrt EL &
                  W.vertices() c= dom Gn &
                  for n being even Nat st n in dom W holds
                  W.n = FAP.(W.(n+1)) by A4,A10;
                  set W2 = W.addEdge(e);
A17:              W.first() = source & W.last() = (the_Target_of G).e
                  by A16,GLIB_001:def 23;
                  then
A18:              e Joins W.last(),(the_Source_of G).e,G by A9,GLIB_000:def 15;
A19:              not (the_Source_of G).e in W.vertices() by A7,A16;
                  then reconsider W2 as vertex-distinct Walk of G
                  by A18,GLIB_001:156;
A19a:             e DJoins (the_Source_of G).e,W.last(),G
                  by A9,A17,GLIB_000:def 16;
                  take W2;
                  thus W2 is_Walk_from source,v by A15,A17,A18,GLIB_001:64;
                  thus W2 is_augmenting_wrt EL by A10,A16,A19,A19a,Th2;
A20:              W2.vertices() = W.vertices() \/ {v} by A15,A18,GLIB_001:96;
                  now
                    let x be set;
                    assume
A21:                x in W2.vertices();
                    now per cases by A20,A21,XBOOLE_0:def 3;
                      suppose x in W.vertices();
                        then
A22:                    x in dom Gn by A16;
                        dom Gn c= dom Gn1 by Th4,NAT_1:11;
                        hence x in dom Gn1 by A22;
                      end;
                      suppose x in {v};
                        hence x in dom Gn1 by A11,A15,XBOOLE_0:def 3;
                      end;
                    end;
                    hence x in dom Gn1;
                  end;
                  hence W2.vertices() c= dom Gn1 by TARSKI:def 3;
                  let n be even Nat;
                  assume n in dom W2;
                  then
A23:              1 <= n & n <= len W2 by FINSEQ_3:27;
                  now per cases;
                    suppose
A24:                  n <= len W;
                      then
A25:                  n in dom W by A23,FINSEQ_3:27;
                      then
A26:                  W2.n = W.n by A18,GLIB_001:66;
                      n < len W by A24,XXREAL_0:1;
                      then
A27:                  n+1 <= len W by NAT_1:13;
                      1 <= 1+n by NAT_1:11;
                      then n+1 in dom W by A27,FINSEQ_3:27;
                      then W2.(n+1) = W.(n+1) by A18,GLIB_001:66;
                      hence W2.n = FAP.(W2.(n+1))
                      by A16,A25,A26;
                    end;
                    suppose n > len W;
                      then
A28:                  len W + 1 <= n by NAT_1:13;
                      n <= len W + 2*1 by A18,A23,GLIB_001:65;
                      then n < len W + 1+1 by XXREAL_0:1;
                      then n <= len W + 1 by NAT_1:13;
                      then n = len W + 1 by A28,XXREAL_0:1;
                      then n+1 = len W + (1+1);
                      then
A29:                  W2.n = e & W2.(n+1) = v by A15,A18,A28,GLIB_001:66;
A30:                  v in dom Gn1 by A11,A14,XBOOLE_0:def 3;
                      Gn1.v = e by A8,A15,Tw1;
                      hence W2.n = FAP.(W2.(n+1))
                      by A29,A30,Th7;
                    end;
                  end;
                  hence W2.n = FAP.(W2.(n+1));
                end;
                hence ex P being vertex-distinct Path of G st
                P is_Walk_from source,v &
                P is_augmenting_wrt EL &
                P.vertices() c=dom Gn1 &
                for n being even Nat st n in dom P holds
                P.n = FAP.(P.(n+1));
              end;
            end;
            hence ex P being vertex-distinct Path of G st
            P is_Walk_from source,v &
            P is_augmenting_wrt EL &
            P.vertices() c=dom Gn1 &
            for n being even Nat st n in dom P holds
            P.n = FAP.(P.(n+1));
          end;
          hence P[n+1];
        end;
        suppose
A31:      Next <> {} & (the_Source_of G).e in dom Gn;
          then
A32:      Gn1 = Gn+*((the_Target_of G).e .--> e) by A5,Def14;
A33:      e in Next by A31;
A34:      e is_forward_edge_wrt Gn or e is_backward_edge_wrt Gn
          by A31,Def13;
          then
A35:      not (the_Target_of G).e in dom Gn &
          EL.e < (the_Weight_of G).e by A31,Def10,Def11;
A36:      dom Gn1 = dom Gn \/ {(the_Target_of G).e} by A32,Tw0;
          now
            let v be set;
            assume
A37:        v in dom Gn1;
            now per cases by A36,A37,XBOOLE_0:def 3;
              suppose v in dom Gn;
                then consider P being vertex-distinct Path of G such that
A38:            P is_Walk_from source,v &
                P is_augmenting_wrt EL &
                P.vertices() c= dom Gn &
                for n being even Nat st n in dom P holds
                P.n = FAP.(P.(n+1)) by A4;
                take P;
                dom Gn c= dom Gn1 by Th4,NAT_1:11;
                hence P is_Walk_from source,v &
                P is_augmenting_wrt EL &
                P.vertices()c= dom Gn1 &
                for n being even Nat st n in dom P holds
                P.n = FAP.(P.(n+1)) by A38,XBOOLE_1:1;
              end;
              suppose
A39:            v in {(the_Target_of G).e};
                then
A40:            v = (the_Target_of G).e by TARSKI:def 1;
                now consider W being vertex-distinct Path of G such that
A41:              W is_Walk_from source, (the_Source_of G).e &
                  W is_augmenting_wrt EL &
                  W.vertices() c= dom Gn &
                  for n being even Nat st n in dom W holds
                  W.n = FAP.(W.(n+1)) by A4,A31;
                  set W2 = W.addEdge(e);
A42:              W.first() = source & W.last() = (the_Source_of G).e
                  by A41,GLIB_001:def 23; then
A43:             e Joins W.last(),(the_Target_of G).e,G by A33,GLIB_000:def 15;
A44:              not (the_Target_of G).e in W.vertices()
                  by A31,A34,A41,Def10,Def11;
                  then reconsider W2 as vertex-distinct Walk of G
                  by A43,GLIB_001:156;
A44a:               e DJoins W.last(),(the_Target_of G).e,G
                  by A33,A42,GLIB_000:def 16;
                  take W2;
                  thus W2 is_Walk_from source,v by A40,A42,A43,GLIB_001:64;
                  thus W2 is_augmenting_wrt EL by A35,A41,A44,A44a,Th2;
A45:              W2.vertices() = W.vertices() \/ {v} by A40,A43,GLIB_001:96;
                  now
                    let x be set;
                    assume
A46:                x in W2.vertices();
                    now per cases by A45,A46,XBOOLE_0:def 3;
                      suppose x in W.vertices();
                        then
A47:                    x in dom Gn by A41;
                        dom Gn c= dom Gn1 by Th4,NAT_1:11;
                        hence x in dom Gn1 by A47;
                      end;
                      suppose x in {v};
                        hence x in dom Gn1 by A36,A40,XBOOLE_0:def 3;
                      end;
                    end;
                    hence x in dom Gn1;
                  end;
                  hence W2.vertices() c= dom Gn1 by TARSKI:def 3;
                  let n be even Nat;
                  assume n in dom W2;
                  then
A48:              1 <= n & n <= len W2 by FINSEQ_3:27;
                  now per cases;
                    suppose
A49:                  n <= len W;
                      then
A50:                  n in dom W by A48,FINSEQ_3:27;
                      then
A51:                  W2.n = W.n by A43,GLIB_001:66;
                      n < len W by A49,XXREAL_0:1;
                      then
A52:                  n+1 <= len W by NAT_1:13;
                      1 <= 1+n by NAT_1:11;
                      then n+1 in dom W by A52,FINSEQ_3:27;
                      then W2.(n+1) = W.(n+1) by A43,GLIB_001:66;
                      hence W2.n = FAP.(W2.(n+1))
                      by A41,A50,A51;
                    end;
                    suppose n > len W;
                      then
A53:                  len W + 1 <= n by NAT_1:13;
                      n <= len W + 2*1 by A43,A48,GLIB_001:65;
                      then n < len W + 1+1 by XXREAL_0:1;
                      then n <= len W + 1 by NAT_1:13;
                      then n = len W + 1 by A53,XXREAL_0:1;
                      then n+1 = len W + (1+1);
                      then
A54:                  W2.n = e & W2.(n+1) = v by A40,A43,A53,GLIB_001:66;
A55:                  v in dom Gn1 by A36,A39,XBOOLE_0:def 3;
                      Gn1.v = e by Tw1,A32,A40;
                      hence W2.n = FAP.(W2.(n+1))
                      by A54,A55,Th7;
                    end;
                  end;
                  hence W2.n = FAP.(W2.(n+1));
                end;
                hence ex P being vertex-distinct Path of G st
                P is_Walk_from source,v &
                P is_augmenting_wrt EL &
                P.vertices() c=dom Gn1 &
                for n being even Nat st n in dom P holds
                P.n = FAP.(P.(n+1));
              end;
            end;
            hence ex P being vertex-distinct Path of G st
            P is_Walk_from source,v &
            P is_augmenting_wrt EL &
            P.vertices() c=dom Gn1 &
            for n being even Nat st n in dom P holds
            P.n = FAP.(P.(n+1));
          end;
          hence P[n+1];
        end;
      end;
      hence P[n+1];
    end;
    then
A56: for n being Nat st P[n] holds P[n+1];
A57: for n being Nat holds P[n] from NAT_1:sch 2(A3,A56);
    hereby
      assume sink in dom FAP;
      then consider W being vertex-distinct Path of G such that
A58:  W is_Walk_from source,sink &
      W is_augmenting_wrt EL &
      W.vertices() c= dom FAP &
      for n being even Nat st n in dom W holds
      W.n = FAP.((W.(n+1))) by A57;
      take W;
      thus W is_Walk_from source,sink &
      W is_augmenting_wrt EL &
         for n being even Nat st n in dom W holds
      W.n = FAP.((W.(n+1))) by A58;
    end;
    thus thesis;
  end;
  uniqueness
  proof
    let IT1, IT2 be vertex-distinct Path of G;
    set FAP = AP:FindAugPath(EL,source), CS = AP:CompSeq(EL,source);
    defpred P[Nat] means
    for v being set, P1,P2 being vertex-distinct Path of G st
    v in dom (CS.$1) &
    P1 is_Walk_from source,v & P1 is_augmenting_wrt EL &
    P2 is_Walk_from source,v & P2 is_augmenting_wrt EL &
    (for n being even Nat st n in dom P1 holds
    P1.n = FAP.(P1.(n+1))) &
    (for n being even Nat st n in dom P2 holds
    P2.n = FAP.(P2.(n+1))) holds P1 = P2;
    set G0 = CS.0;
    now
      let v be set, P1,P2 be vertex-distinct Path of G;
      assume
A59:  v in dom G0 &
    P1 is_Walk_from source,v & P1 is_augmenting_wrt EL &
    P2 is_Walk_from source,v & P2 is_augmenting_wrt EL &
      (for n being even Nat st n in dom P1 holds
      P1.n = FAP.(P1.(n+1))) &
      (for n being even Nat st n in dom P2 holds
      P2.n = FAP.(P2.(n+1)));
      then v in {source} by Th3;
      then v = source by TARSKI:def 1;
      then
A60:  P1.(2*0+1) = v & P1.(len P1) = v & P2.(2*0+1) = v & P2.(len P2 ) = v
      by A59,GLIB_001:18;
      1 <= len P1 & 1 <= len P2 by HEYTING3:1;
      then len P1 = 1 & len P2 = 1 by A60,GLIB_001:def 29;
      then P1 = <*v*> & P2 = <*v*> by A60,FINSEQ_1:57;
      hence P1 = P2;
    end;
    then
A61: P[0];
    now
      let n be Nat;
      assume
A62:  P[n];
      set Gn = CS.n, Gn1 = CS.(n+1);
A63:  Gn1 = AP:Step(Gn) by Def15;
      set Next = AP:NextBestEdges(Gn), e = choose Next;
      now per cases;
        suppose Next = {};
          then Gn1 = Gn by A63,Def14;
          hence P[n+1] by A62;
        end;
        suppose
A65:      Next <> {} & not (the_Source_of G).e in dom Gn;
          then
A66:      Gn1 = Gn+*((the_Source_of G).e .--> e) by A63,Def14;
A68:      dom Gn1 = dom Gn \/ {(the_Source_of G). e} by Tw0,A66;
          e is_forward_edge_wrt Gn or e is_backward_edge_wrt Gn
          by A65,Def13;
          then
A69:      (the_Target_of G).e in dom Gn by A65,Def10,Def11;
          source in {source} by TARSKI:def 1;
          then
A70:      source in dom G0 by Th3;
          dom G0 c= dom Gn by Th4;
          then
A71:      source in dom Gn by A70;
          now
            let v be set,P1,P2 be vertex-distinct Path of G;
            assume
A72:        v in dom Gn1 &
            P1 is_Walk_from source,v & P1 is_augmenting_wrt EL &
            P2 is_Walk_from source,v & P2 is_augmenting_wrt EL &
            (for n being even Nat st n in dom P1 holds
            P1.n = FAP.(P1.(n+1))) &
            (for n being even Nat st n in dom P2 holds
            P2.n = FAP.(P2.(n+1)));
            then
A73:        P1.1 = source & P1.(len P1) = v &
            P2.1 = source & P2.(len P2) = v by GLIB_001:18;
            now per cases by A68,A72,XBOOLE_0:def 3;
              suppose v in dom Gn;
                hence P1 = P2 by A62,A72;
              end;
              suppose
A74:            v in {(the_Source_of G).e};
                then
A75:            v = (the_Source_of G).e by TARSKI:def 1;
                v <> source by A65,A71,A74,TARSKI:def 1;
                then P1.1 <> P1.last() & P2.1 <> P2.last()
                by A73,GLIB_001:def 7;
                then P1.first() <> P1.last() & P2.first() <> P2.last()
                by GLIB_001:def 6;
                then P1 is non trivial & P2 is non trivial by GLIB_001:128;
                then
A76:            3 <= len P1 & 3 <= len P2 by GLIB_001:126;
                then 3-2 < len P1-0 & 3-2 < len P2-0 by XREAL_1:17;
                then reconsider lenP11 = len P1 - 1, lenP21 = len P2 - 1 as
                   even Element of NAT by INT_1:18;
A77:            3-2 <= lenP11 & 3-2 <= lenP21 by A76,XREAL_1:17;
A78:            lenP11+1 = len P1 & lenP21+1 = len P2;
A79:            lenP11 < len P1-0 & lenP21 < len P2-0 by XREAL_1:17;
                then
A80:            lenP11 in dom P1 & lenP21 in dom P2 by A77,FINSEQ_3:27;
                Gn1.v = e by Tw1,A66,A75;
                then FAP.v = e by A72,Th7;
                then
A81:            P1.lenP11 = e & P2.lenP21 = e by A72,A73,A78,A80;
                then consider lenP12 being odd Element of NAT such that
A82:            lenP12 = lenP11 - 1 & lenP11-1 in dom P1 &
                lenP11+1 in dom P1 & e Joins P1.lenP12,v,G
                by A73,A80,GLIB_001:10;
A83:            P1.lenP12 = (the_Target_of G).e
                by A65,A69,A82,A75,GLIB_000:def 15;
                consider lenP22 being odd Element of NAT such that
A84:            lenP22 = lenP21 - 1 & lenP21-1 in dom P2 &
                lenP21+1 in dom P2 & e Joins P2.lenP22,v,G
                by A73,A80,A81,GLIB_001:10;
A85:            P2.lenP22 = (the_Target_of G).e
                by A65,A69,A84,A75,GLIB_000:def 15;
                set P1A = P1.cut(2*0+1,lenP12);
                set P2A = P2.cut(2*0+1,lenP22);
A86:            1 <= lenP12 & 1 <= lenP22 by HEYTING3:1;
A87:            lenP12 < len P1 & lenP22 < len P2 by A79,A82,A84,XREAL_1:17;
                then
A88:            P1A is_Walk_from source,(the_Target_of G).e &
                P2A is_Walk_from source,(the_Target_of G).e
                by A73,A83,A85,A86,GLIB_001:38;
A88a:           P1A is_augmenting_wrt EL & P2A is_augmenting_wrt EL
                by A72,Th002;
A89:            now
                  let n be even Nat;
                  assume
A90:              n in dom P1A;
                  then
A91:              1 <= n & n <= len P1A by FINSEQ_3:27;
A92:              P1A.n = P1.n by A87,A90,GLIB_001:47;
                  n < len P1A by A91,XXREAL_0:1;
                  then 1 <= n+1 & n+1 <= len P1A by NAT_1:13;
                  then n+1 in dom P1A by FINSEQ_3:27;
                  then
A93:              P1A.(n+1) = P1.(n+1) by A87,GLIB_001:47;
                  len P1A = lenP12 by A87,GLIB_001:46;
                  then n <= len P1 by A87,A91,XXREAL_0:2;
                  then n in dom P1 by A91,FINSEQ_3:27;
                  hence P1A.n = FAP.(P1A.(n+1))
                  by A72,A92,A93;
                end;
A94:            now
                  let n be even Nat;
                  assume
A95:              n in dom P2A;
                  then
A96:              1 <= n & n <= len P2A by FINSEQ_3:27;
A97:              P2A.n = P2.n by A87,A95,GLIB_001:47;
                  n < len P2A by A96,XXREAL_0:1;
                  then 1 <= n+1 & n+1 <= len P2A by NAT_1:13;
                  then n+1 in dom P2A by FINSEQ_3:27;
                  then
A98:              P2A.(n+1) = P2.(n+1) by A87,GLIB_001:47;
                  len P2A = lenP22 by A87,GLIB_001:46;
                  then n <= len P2 by A87,A96,XXREAL_0:2;
                  then n in dom P2 by A96,FINSEQ_3:27;
                  hence P2A.n = FAP.(P2A.(n+1))
                  by A72,A97,A98;
                end;
A99:            lenP12 + 1 = lenP11 & lenP22 + 1 = lenP21 by A82,A84;
                lenP12+(1+1) = len P1 & lenP22+(1+1) = len P2 by A82,A84;
                then
A100:           P1.cut(lenP12,len P1) = G.walkOf(( the_Target_of G).e,e,v) &
                P2.cut(lenP22,len P2) = G.walkOf((the_Target_of G).e,e,v)
                by A73,A81,A83,A85,A87,A99,GLIB_001:41;
A101:           P1A.append(P1.cut(lenP12,len P1))
                = P1.cut(2*0+1, len P1) by A86,A87,GLIB_001:39
                  .= P1 by GLIB_001:40;
                P2A.append(P2.cut(lenP22, len P2))
                = P2.cut(2*0+1, len P2) by A86,A87,GLIB_001:39
                  .= P2 by GLIB_001:40;
                hence P1 = P2 by A62,A69,A88,A88a,A89,A94,A100,A101;
              end;
            end;
            hence P1 = P2;
          end;
          hence P[n+1];
        end;
        suppose
A102:     Next <> {} & (the_Source_of G).e in dom Gn;
          then
A103:     Gn1 = Gn+*((the_Target_of G).e.--> e) by A63,Def14;
A105:     dom Gn1 = dom Gn \/ {(the_Target_of G). e} by A103,Tw0;
          e is_forward_edge_wrt Gn or e is_backward_edge_wrt Gn
          by A102,Def13;
          then
A106:     not (the_Target_of G).e in dom Gn by A102,Def10,Def11;
          source in {source} by TARSKI:def 1;
          then
A107:     source in dom G0 by Th3;
          dom G0 c= dom Gn by Th4;
          then
A108:     source in dom Gn by A107;
          now
            let v be set,P1,P2 be vertex-distinct Path of G;
            assume
A109:       v in dom Gn1 &
            P1 is_Walk_from source,v & P1 is_augmenting_wrt EL &
            P2 is_Walk_from source,v & P2 is_augmenting_wrt EL &
            (for n being even Nat st n in dom P1 holds
            P1.n = FAP.(P1.(n+1))) &
            (for n being even Nat st n in dom P2 holds
            P2.n = FAP.(P2.(n+1)));
            then
A110:       P1.1 = source & P1.(len P1) = v &
            P2.1 = source & P2.(len P2) = v by GLIB_001:18;
            now per cases by A105,A109,XBOOLE_0:def 3;
              suppose v in dom Gn;
                hence P1 = P2 by A62,A109;
              end;
              suppose
A111:           v in {(the_Target_of G).e};
                then
A112:           v = (the_Target_of G).e by TARSKI:def 1;
                v <> source by A106,A108,A111,TARSKI:def 1;
                then P1.1 <> P1.last() & P2.1 <> P2.last()
                by A110,GLIB_001:def 7;
                then P1.first() <> P1.last() & P2.first() <> P2.last()
                by GLIB_001:def 6;
                then P1 is non trivial & P2 is non trivial by GLIB_001:128;
                then
A113:           3 <= len P1 & 3 <= len P2 by GLIB_001:126;
                then 3-2 < len P1-0 & 3-2 < len P2-0 by XREAL_1:17;
                then reconsider lenP11 = len P1 - 1, lenP21 = len P2 - 1 as
                even Element of NAT by INT_1:18;
A114:           3-2 <= lenP11 & 3-2 <= lenP21 by A113,XREAL_1:17;
A115:           lenP11+1 = len P1 & lenP21+1 = len P2;
A116:           lenP11 < len P1-0 & lenP21 < len P2-0 by XREAL_1:17;
                then
A117:           lenP11 in dom P1 & lenP21 in dom P2 by A114,FINSEQ_3:27;
                Gn1.v = e by A103,A112,Tw1;
                then FAP.v = e by A109,Th7;
                then
A118:           P1.lenP11 = e & P2.lenP21 = e by A109,A110,A115,A117;
                then consider lenP12 being odd Element of NAT such that
A119:           lenP12 = lenP11 - 1 & lenP11-1 in dom P1 &
                lenP11+1 in dom P1 & e Joins P1.lenP12,v,G
                by A110,A117,GLIB_001:10;
A120:           P1.lenP12 = (the_Source_of G).e
                by A102,A106,A119,A112,GLIB_000:def 15;
                consider lenP22 being odd Element of NAT such that
A121:           lenP22 = lenP21 - 1 & lenP21-1 in dom P2 &
                lenP21+1 in dom P2 & e Joins P2.lenP22,v,G
                by A110,A117,A118,GLIB_001:10;
A122:           P2.lenP22 = (the_Source_of G).e
                by A102,A106,A121,A112,GLIB_000:def 15;
                set P1A = P1.cut(2*0+1,lenP12);
                set P2A = P2.cut(2*0+1,lenP22);
A123:           1 <= lenP12 & 1 <= lenP22 by HEYTING3:1;
A124:           lenP12 < len P1 & lenP22 < len P2 by A116,A119,A121,XREAL_1:17;
                then
A125:           P1A is_Walk_from source,(the_Source_of G).e &
                P2A is_Walk_from source,(the_Source_of G).e
                by A110,A120,A122,A123,GLIB_001:38;
A125a:          P1A is_augmenting_wrt EL & P2A is_augmenting_wrt EL
                by A109,Th002;
A126:           now
                  let n be even Nat;
                  assume
A127:             n in dom P1A;
                  then
A128:             1 <= n & n <= len P1A by FINSEQ_3:27;
A129:             P1A.n = P1.n by A124,A127,GLIB_001:47;
                  n < len P1A by A128,XXREAL_0:1;
                  then 1 <= n+1 & n+1 <= len P1A by NAT_1:13;
                  then n+1 in dom P1A by FINSEQ_3:27;
                  then
A130:             P1A.(n+1) = P1.(n+1) by A124,GLIB_001:47;
                  len P1A = lenP12 by A124,GLIB_001:46;
                  then n <= len P1 by A124,A128,XXREAL_0:2;
                  then n in dom P1 by A128,FINSEQ_3:27;
                  hence P1A.n = FAP.(P1A.(n+1))
                  by A109,A129,A130;
                end;
A131:           now
                  let n be even Nat;
                  assume
A132:             n in dom P2A;
                  then
A133:             1 <= n & n <= len P2A by FINSEQ_3:27;
A134:             P2A.n = P2.n by A124,A132,GLIB_001:47;
                  n < len P2A by A133,XXREAL_0:1;
                  then 1 <= n+1 & n+1 <= len P2A by NAT_1:13;
                  then n+1 in dom P2A by FINSEQ_3:27;
                  then
A135:             P2A.(n+1) = P2.(n+1) by A124,GLIB_001:47;
                  len P2A = lenP22 by A124,GLIB_001:46;
                  then n <= len P2 by A124,A133,XXREAL_0:2;
                  then n in dom P2 by A133,FINSEQ_3:27;
                  hence P2A.n = FAP.(P2A.(n+1))
                  by A109,A134,A135;
                end;
A136:           lenP12 + 1 = lenP11 & lenP22 + 1 = lenP21 by A119,A121;
                lenP12+(1+1) = len P1 & lenP22+(1+1) = len P2 by A119,A121;
                then
A137:           P1.cut(lenP12,len P1) = G.walkOf(( the_Source_of G).e,e,v) &
                P2.cut(lenP22,len P2) = G.walkOf((the_Source_of G).e,e,v)
                by A110,A118,A120,A122,A124,A136,GLIB_001:41;
A138:           P1A.append(P1.cut(lenP12,len P1))
                = P1.cut(2*0+1, len P1) by A123,A124,GLIB_001:39
                  .= P1 by GLIB_001:40;
                P2A.append(P2.cut(lenP22, len P2))
                = P2.cut(2*0+1, len P2) by A123,A124,GLIB_001:39
                  .= P2 by GLIB_001:40;
                hence P1 = P2 by A62,A102,A125,A125a,A126,A131,A137,A138;
              end;
            end;
            hence P1 = P2;
          end;
          hence P[n+1];
        end;
      end;
      hence P[n+1];
    end;
    then
A139: for n being Nat st P[n] holds P[n+1];
    for n being Nat holds P[n] from NAT_1:sch 2(A61,A139);
    hence (sink in dom FAP) &
    (IT1 is_Walk_from source,sink &
     IT1 is_augmenting_wrt EL &
    for n being even Nat st n in dom IT1 holds
    IT1.n = (AP:FindAugPath(EL,source)).(IT1.(n+1))) &
    (IT2 is_Walk_from source,sink &
     IT2 is_augmenting_wrt EL &
    for n being even Nat st n in dom IT2 holds
    IT2.n = (AP:FindAugPath(EL,source)).(IT2.(n+1)))
    implies IT1 = IT2;
    thus thesis;
  end;
  consistency;
end;

 theorem Th8: ::tAPCS03
for G being real-weighted WGraph, EL being FF:ELabeling of G,
      source being Vertex of G, n being Nat, v being set
 st v in dom (AP:CompSeq(EL,source).n)
  holds ex P being Path of G st P is_augmenting_wrt EL &
           P is_Walk_from source,v &
           P.vertices() c= dom (AP:CompSeq(EL,source).n)
proof
  let G be real-weighted WGraph, EL being FF:ELabeling of G,
      source be Vertex of G;
  set CS = AP:CompSeq(EL,source), G0 = CS.0;
  defpred P[Nat] means
  for v being set st v in dom (CS.$1)
   holds ex P being Path of G st P is_augmenting_wrt EL &
              P is_Walk_from source,v & P.vertices() c= dom (CS.$1);
  now
    let v be set;
    assume
A1: v in dom G0;
    then reconsider v'=v as Vertex of G;
    set P = G.walkOf(v');
    take P;
    thus P is_augmenting_wrt EL by Th001;
    v in {source} by A1,Th3;
    then v = source by TARSKI:def 1;
    hence P is_Walk_from source,v by GLIB_001:14;
    P.vertices() = {v'} by GLIB_001:91;
    hence P.vertices() c= dom G0 by A1,ZFMISC_1:37;
  end;
  then
A2: P[0];
A3: now
    let n be Nat;
    set Gn = CS.n, Gn1 = CS.(n+1);
    set Next = AP:NextBestEdges(Gn), e = choose Next;
    assume
A4: P[n];
A5: Gn1 = AP:Step(Gn) by Def15;
    now per cases;
      suppose Next = {};
        then Gn1 = Gn by A5,Def14;
        hence P[n+1] by A4;
      end;
      suppose
A6:     Next <> {};
        set se = (the_Source_of G).e, te = (the_Target_of G).e;
        now per cases by A6,Def13;
          suppose
A7:         e is_forward_edge_wrt Gn;
            then
A8:         e in the_Edges_of G & se in dom Gn &
            not te in dom Gn &
            EL.e < (the_Weight_of G).e by Def10;
            then Gn1 = Gn+*(te .--> e) by A5,A6,Def14;
            then
A9:         dom Gn1 = dom Gn \/ {te} by Tw0;
            then
A10:        dom Gn c= dom Gn1 by XBOOLE_1:7;
            te in {te} by TARSKI:def 1;
            then
A11:        te in dom Gn1 by A9,XBOOLE_0:def 3;
A12:        se in dom Gn1 by A8,A10;
            let v be set;
            assume
A13:        v in dom Gn1;
A15:        e DJoins se,te,G by A8,GLIB_000:def 16;
            now per cases by A9,A13,XBOOLE_0:def 3;
              suppose v in dom Gn;
                then consider P being Path of G such that
A16:            P is_augmenting_wrt EL & P is_Walk_from source,v &
                P.vertices() c= dom Gn by A4;
                take P;
                thus P is_augmenting_wrt EL & P is_Walk_from source,v &
                P.vertices() c= dom Gn1 by A10,A16,XBOOLE_1:1;
              end;
              suppose v in {te};
                then
A17:            v = te by TARSKI:def 1;
                now per cases;
                  suppose
A18:                se = source;
                    set P = G.walkOf(se,e,te);
A19:                e Joins se,te,G by A8,GLIB_000:def 15;
                    take P;
                    now
                      let n be odd Nat;
                      assume n < len P;
                      then n < 2+1 by A19,GLIB_001:15;
                      then n <= 2*1 by NAT_1:13;
                      then n < 1+1 by XXREAL_0:1;
                      then 1 <= n & n <= 1 by HEYTING3:1,NAT_1:13;
                      then
A20:                  n = 1 by XXREAL_0:1;
                      P = <*se,e,te*> by A19,GLIB_001:def 5;
                      then
A21:                  P.n = se & P.(n+1) = e & P.(n+ 2) = te
                      by A20,FINSEQ_1:62;
                      thus P.(n+1) DJoins P.n,P.(n+2),G implies
                    EL.(P.(n+1)) < (the_Weight_of G).(P.(n+1)) by A7,A21,Def10;
                      assume not P.(n+1) DJoins P.n,P.(n+2),G;
                      hence 0 < EL.(P.(n+1)) by A21,A8,GLIB_000:def 16;
                    end;
                    hence P is_augmenting_wrt EL by Def12;
                    thus P is_Walk_from source,v
                       by A17,A18,A19,GLIB_001:16;
                    now
                      let x be set;
                      assume x in P.vertices();
                      then x in {se,te} by A19,GLIB_001:92;
                      hence x in dom Gn1 by A11,A12,TARSKI:def 2;
                    end;
                    hence P.vertices() c= dom Gn1 by TARSKI:def 3;
                  end;
                  suppose
A23:                se <> source;
                    consider P being Path of G such that
A24:                P is_augmenting_wrt EL & P is_Walk_from source,se &
                    P.vertices() c= dom Gn by A4,A8;
                    set P2 = P.addEdge(e);
A25:                e Joins se,v,G by A8,A17,GLIB_000:def 15;
A26:                se = P.last() by A24,GLIB_001:def 23;
                    then P.first() <> P.last() by A23,A24,GLIB_001:def 23;
                    then
A27:                P is open by GLIB_001:def 24;
A28:                not v in P.vertices() by A7,A17,A24,Def10;
                  then reconsider P2 as Path of G by A25,A26,A27,GLIB_001:152;
                    take P2;
                    thus P2 is_augmenting_wrt EL by A8,A15,A17,A24,A26,A28,Th2;
                    thus P2 is_Walk_from source,v by A24,A25,GLIB_001:67;
                    now
                      let x be set;
                      assume x in P2.vertices();
                      then
A29:                  x in P.vertices()\/{te} by A17,A25,A26,GLIB_001:96;
                      now per cases by A29,XBOOLE_0:def 3;
                        suppose x in P.vertices();
                          then x in dom Gn by A24;
                          hence x in dom Gn1 by A10;
                        end;
                        suppose x in {te};
                          hence x in dom Gn1 by A9,XBOOLE_0:def 3;
                        end;
                      end;
                      hence x in dom Gn1;
                    end;
                    hence P2.vertices() c= dom Gn1 by TARSKI:def 3;
                  end;
                end;
                hence ex P being Path of G st P is_augmenting_wrt EL &
                P is_Walk_from source,v & P.vertices() c= dom Gn1;
              end;
            end;
            hence ex P being Path of G st P is_augmenting_wrt EL &
            P is_Walk_from source,v & P.vertices() c= dom Gn1;
          end;
          suppose
A30:        e is_backward_edge_wrt Gn;
            then
A31:        e in the_Edges_of G & te in dom Gn &
            not se in dom Gn & 0 < EL.e by Def11;
            then Gn1 = Gn+*(se .--> e) by A5,A6,Def14;
            then
A32:        dom Gn1 = dom Gn \/ {se} by Tw0;
            then
A33:        dom Gn c= dom Gn1 by XBOOLE_1:7;
            se in {se} by TARSKI:def 1;
            then
A34:        se in dom Gn1 by A32,XBOOLE_0:def 3;
A35:        te in dom Gn1 by A31,A33;
            let v be set;
            assume
A36:        v in dom Gn1;
A38:        e DJoins se,te,G by A31,GLIB_000:def 16;
            now per cases by A32,A36,XBOOLE_0:def 3;
              suppose v in dom Gn;
                then consider P being Path of G such that
A39:            P is_augmenting_wrt EL & P is_Walk_from source,v &
                P.vertices() c= dom Gn by A4;
                take P;
                thus P is_augmenting_wrt EL & P is_Walk_from source,v &
                P.vertices() c= dom Gn1 by A33,A39,XBOOLE_1:1;
              end;
              suppose v in {se};
                then
A40:            v = se by TARSKI:def 1;
                now per cases;
                  suppose
A41:                te = source;
                    set P = G.walkOf(te,e,se);
                    take P;
A42:                e Joins te,se,G by A31,GLIB_000:def 15;
                    now
                      let n be odd Nat;
                      assume n < len P;
                      then n < 2+1 by A42,GLIB_001:15;
                      then n <= 2*1 by NAT_1:13;
                      then n < 1+1 by XXREAL_0:1;
                      then 1 <= n & n <= 1 by HEYTING3:1,NAT_1:13;
                      then
A43:                  n = 1 by XXREAL_0:1;
                      P = <*te,e,se*> by A42,GLIB_001:def 5;
                      then
A44:                  P.n = te & P.(n+1) = e & P.(n+ 2) = se
                      by A43,FINSEQ_1:62;
                      thus P.(n+1) DJoins P.n,P.(n+2),G implies
                       EL.(P.(n+1)) <
                        (the_Weight_of G).(P.(n+1)) by A44,A31,GLIB_000:def 16;
                      assume not P.(n+1) DJoins P.n,P.(n+2),G;
                      thus 0 < EL.(P.(n+1))
                      by A30,A44,Def11;
                    end;
                    hence P is_augmenting_wrt EL by Def12;
                    thus P is_Walk_from source,v by A40,A41,A42,GLIB_001:16;
                    now
                      let x be set;
                      assume x in P.vertices();
                      then x in {se,te} by A42,GLIB_001:92;
                      hence x in dom Gn1 by A34,A35,TARSKI:def 2;
                    end;
                    hence P.vertices() c= dom Gn1 by TARSKI:def 3;
                  end;
                  suppose
A45:                te <> source;
                    consider P being Path of G such that
A46:                P is_augmenting_wrt EL & P is_Walk_from source,te &
                    P.vertices() c= dom Gn by A4,A31;
                    set P2 = P.addEdge(e);
A47:                e Joins te,v,G by A31,A40,GLIB_000:def 15;
A48:                te = P.last() by A46,GLIB_001:def 23;
                    then P.first() <> P.last() by A45,A46,GLIB_001:def 23;
                    then
A49:                P is open by GLIB_001:def 24;
A50:                not v in P.vertices() by A30,A40,A46,Def11;
                    then reconsider P2 as Path of G by A47,A48,A49,GLIB_001:152
;
                    take P2;
                    thus P2 is_augmenting_wrt EL
                                                by A31,A38,A40,A46,A48,A50,Th2;
                    thus P2 is_Walk_from source,v by A46,A47,GLIB_001:67;
                    now
                      let x be set;
                      assume x in P2.vertices();
                      then
A51:                  x in P.vertices()\/{se} by A40,A47,A48,GLIB_001:96;
                      now per cases by A51,XBOOLE_0:def 3;
                        suppose x in P.vertices();
                          then x in dom Gn by A46;
                          hence x in dom Gn1 by A33;
                        end;
                        suppose x in {se};
                          hence x in dom Gn1 by A32,XBOOLE_0:def 3;
                        end;
                      end;
                      hence x in dom Gn1;
                    end;
                    hence P2.vertices() c= dom Gn1 by TARSKI:def 3;
                  end;
                end;
                hence ex P being Path of G st P is_augmenting_wrt EL &
                P is_Walk_from source,v & P.vertices() c= dom Gn1;
              end;
            end;
            hence ex P being Path of G st P is_augmenting_wrt EL &
            P is_Walk_from source,v & P.vertices() c= dom Gn1;
          end;
        end;
        hence P[n+1];
      end;
    end;
    hence P[n+1];
  end;
  for n being Nat holds P[n] from NAT_1:sch 2(A2,A3);
  hence thesis;
end;

theorem Th9: ::tAPFAP02
for G being finite real-weighted WGraph, EL being FF:ELabeling of G,
    source being Vertex of G, v being set
 holds v in dom AP:FindAugPath(EL,source)
  iff ex P being Path of G st P is_Walk_from source,v & P is_augmenting_wrt EL
proof
  let G be finite real-weighted WGraph, EL be FF:ELabeling of G,
      source be Vertex of G, v be set;
  set CS = AP:CompSeq(EL,source), V = dom AP:FindAugPath(EL,source);
  hereby
    assume v in V;
    then consider P being Path of G such that
A1: P is_augmenting_wrt EL & P is_Walk_from source,v &
    P.vertices() c= V by Th8;
    thus ex P being Path of G st
    P is_Walk_from source,v & P is_augmenting_wrt EL by A1;
  end;
  given P being Path of G such that
A2: P is_Walk_from source,v & P is_augmenting_wrt EL;
  now
    assume
A3: not v in V;
    defpred P[Nat] means $1 is odd & $1 <= len P & not P.$1 in V;
    P.(len P) = v by A2,GLIB_001:18;
    then
A4: ex n being Nat st P[n] by A3;
    consider n being Nat such that
A5: P[n] & for k being Nat st P[k] holds n <= k from NAT_1:sch 5(A4);
    P.(2*0+1) = source by A2,GLIB_001:18;
    then P.(2*0+1) in {source} by TARSKI:def 1;
    then
A6: P.(2*0+1) in dom (CS.0) by Th3;
    dom (CS.0) c= V by Th4;
    then
A7: n <> 1 by A5,A6;
    reconsider n'=n as odd Element of NAT by A5,ORDINAL1:def 13;
    1 <= n by A5,HEYTING3:1;
    then 1 < n by A7,XXREAL_0:1;
    then 1+1 <= n by NAT_1:13;
    then reconsider n2 = n'-2*1 as odd Element of NAT by INT_1:18;
A8: n2 < n - 0 by XREAL_1:17;
    then
A9: n2 < len P by A5,XXREAL_0:2;
    then
A10: P.n2 in V by A5,A8;
    set Gn = CS.(CS.Lifespan()), Gn1 = CS.(CS.Lifespan()+1);
    set Next = AP:NextBestEdges(Gn), en = choose Next;
A11: Gn1 = AP:Step(Gn) by Def15;
    AP:CompSeq(EL,source) is halting by Th6;
    then
A12: Gn = CS.(CS.Lifespan()+1) by GLIB_000:def 57;
    set e = P.(n2+1);
A13: P.(n2+2) = P.n;
A16: e Joins P.n2, P.n, G by A9,A13,GLIB_001:def 3;
A17: now per cases;
      suppose
A18:    e DJoins P.n2, P.n, G;
        then
A19:    (EL).e<(the_Weight_of G).e by A2,A9,A13,Def12;
        e in the_Edges_of G & (the_Source_of G).e in dom Gn &
        not (the_Target_of G).e in dom Gn  by A5,A10,A18,GLIB_000:def 16;
        then e is_forward_edge_wrt Gn by A19,Def10;
        hence Next <> {} by Def13;
      end;
      suppose
A20:    not e DJoins P.n2,P.n, G;
        then
A21:    0 < (EL).e by A2,A9,A13,Def12;
        e DJoins P.n,P.n2,G by A16,A20,GLIB_000:19;
        then e in the_Edges_of G & not (the_Source_of G).e in dom Gn &
             (the_Target_of G).e in dom Gn by A5,A10,GLIB_000:def 16;
        then e is_backward_edge_wrt Gn by A21,Def11;
        hence Next <> {} by Def13;
      end;
    end;
    now per cases;
      suppose
A23:    not (the_Source_of G).en in dom Gn;
        then Gn = Gn+*((the_Source_of G).en .--> en) by A11,A12,A17,Def14;
        then
A24:    dom Gn = dom Gn \/ {(the_Source_of G).en} by Tw0;
        (the_Source_of G).en in {(the_Source_of G).en} by TARSKI:def 1;
        hence contradiction by A23,A24,XBOOLE_0:def 3;
      end;
      suppose
A25:    (the_Source_of G).en in dom Gn;
        then
A26:    Gn = Gn+*((the_Target_of G).en .--> en) by A11,A12,A17,Def14;
        en is_forward_edge_wrt Gn or en is_backward_edge_wrt Gn
        by A17,Def13;
        then
A27:    not (the_Target_of G).en in dom Gn by A25,Def10,Def11;
A28:    dom Gn = dom Gn \/ {(the_Target_of G).en} by A26,Tw0;
        (the_Target_of G).en in {(the_Target_of G).en} by TARSKI:def 1;
        hence contradiction by A27,A28,XBOOLE_0:def 3;
      end;
    end;
    hence contradiction;
  end;
  hence thesis;
end;

theorem Th10: ::tAPFAP03
for G being finite real-weighted WGraph, EL being FF:ELabeling of G,
    source being Vertex of G
 holds source in dom AP:FindAugPath(EL,source)
proof
  let G be finite real-weighted WGraph, EL being FF:ELabeling of G,
      source be Vertex of G;
  set CS = AP:CompSeq(EL,source), V = AP:FindAugPath(EL,source);
  dom (CS.0) = {source} by Th3;
  then
A1: source in dom (CS.0) by TARSKI:def 1;
  dom (CS.0) c= dom AP:FindAugPath(EL,source) by Th4;
  hence thesis by A1;
end;

begin :: Ford-Fulkerson Algorithm definitions

definition
  let G be natural-weighted WGraph, EL be FF:ELabeling of G,
      W be Walk of G;
  assume A: W is_augmenting_wrt EL;

    defpred P[Nat,set] means (W.(2*$1) DJoins W.(2*$1-1),W.(2*$1+1),G implies
    $2 = (the_Weight_of G).(W.(2*$1)) - EL.(W.(2*$1))) &
    (not W.(2*$1) DJoins W.(2*$1-1),W.(2*$1+1),G implies
    $2 = EL.(W.(2*$1)));

  func W.flowSeq(EL) -> FinSequence of NAT means
  :Def18: ::dWFLOWSEQ
  dom it = dom W.edgeSeq() &
  for n being Nat st n in dom it holds
     ((W.(2*n) DJoins W.(2*n-1),W.(2*n+1),G implies
           it.n = (the_Weight_of G).(W.(2*n)) - EL.(W.(2*n))) &
      (not W.(2*n) DJoins W.(2*n-1),W.(2*n+1),G implies
           it.n = EL.(W.(2*n))));
  existence
  proof
    now
      let k be Nat;
      assume k in Seg len W.edgeSeq();
      now per cases;
        suppose W.(2*k) DJoins W.(2*k-1),W.(2*k+1),G;
          hence ex x being set st P[k,x];
        end;
        suppose not W.(2*k) DJoins W.(2*k-1),W.(2*k+1),G;
          hence ex x being set st P[k,x];
        end;
      end;
      hence ex x being set st P[k,x];
    end;
    then
A2: for k being Nat st k in Seg len W.edgeSeq() ex x being set st P[k, x];
    consider IT being FinSequence such that
A3: dom IT = Seg len W.edgeSeq() and
A3a: for k being Nat st k in Seg len W.edgeSeq() holds P[k,IT.k]
    from FINSEQ_1:sch 1(A2);
    now
      let y be set;
      assume y in rng IT;
      then consider x being set such that
A4:   x in dom IT & IT.x = y by FUNCT_1:def 5;
      reconsider n = x as Element of NAT by A4;
      per cases;
      suppose S1: W.(2*n) DJoins W.(2*n-1),W.(2*n+1),G;
       n in dom W.edgeSeq() by A3,A4,FINSEQ_1:def 3;
       then 2*n in dom W by GLIB_001:79;
        then
A2c:   1 <= 2*n & 2*n <= len W by FINSEQ_3:27;
        then reconsider 2n1 = 2*n-1 as odd Element of NAT by INT_1:18;
A3c:    2n1 < len W - 0 by A2c,XREAL_1:17;
A4c:     2n1+1 = 2*n;
A5c:     2n1+(1+1) = 2*n+1;
      B1: IT.n = (the_Weight_of G).(W.(2*n))-EL.(W.(2*n))
              by S1,A4,A3,A3a;
         EL.(W.(2*n)) < (the_Weight_of G).(W.(2*n)) by A,S1,A3c,A4c,A5c,Def12;
        hence y in NAT by A4,B1,INT_1:18;
      end;
      suppose not W.(2*n) DJoins W.(2*n-1),W.(2*n+1),G;
         then IT.n = EL.(W.(2*n)) by A4,A3,A3a;
        hence y in NAT by A4,ORDINAL1:def 13;
      end;
    end;
    then rng IT c= NAT by TARSKI:def 3;
    then reconsider IT as FinSequence of NAT by FINSEQ_1:def 4;
    take IT;
    thus dom IT = dom W.edgeSeq() by A3,FINSEQ_1:def 3;
    let n be Nat;
    assume n in dom IT;
    hence thesis by A3,A3a;
  end;
  uniqueness
  proof
    let IT1,IT2 be FinSequence of NAT such that
A5: dom IT1 = dom W.edgeSeq() &
    for n being Nat st n in dom IT1 holds P[n,IT1.n] and
A6: dom IT2 = dom W.edgeSeq() &
    for n being Nat st n in dom IT2 holds P[n,IT2.n];
    now
      let n be Nat;
      assume
A7:   n in dom IT1;
      now per cases;
        suppose (W.(2*n) DJoins W.(2*n-1),W.(2*n+1),G);
          then IT1.n = (the_Weight_of G).(W.(2*n))-EL.(W.(2*
          n))& IT2.n = (the_Weight_of G).(W.(2*n))-EL.(W.(2*n))
          by A5,A6,A7;
          hence IT1.n = IT2.n;
        end;
        suppose not (W.(2*n) DJoins W.(2*n-1),W.(2*n+1),G);
          then IT1.n = EL.(W.(2*n)) &
          IT2.n = EL.(W.(2*n)) by A5,A6,A7;
          hence IT1.n = IT2.n;
        end;
      end;
      hence IT1.n = IT2.n;
    end;
    hence IT1 = IT2 by A5,A6,FINSEQ_1:17;
  end;
end;

definition
  let G be natural-weighted WGraph, EL being FF:ELabeling of G,
      W be Walk of G;
  assume A: W is_augmenting_wrt EL;
  func W.tolerance(EL) -> Nat means
  :Def19: ::dWTOLERANCE
  it in rng (W.flowSeq(EL)) &
  for k being real number st k in rng (W.flowSeq(EL)) holds it <= k
    if W is non trivial
    otherwise
  it = 0;
  existence
  proof
    set D = rng (W.flowSeq(EL));
    now
      assume W is non trivial;
      then W.edges() <> {} by GLIB_001:137;
      then rng W.edgeSeq() <> {} by GLIB_001:def 17;
      then consider y being set such that
A1:   y in rng W.edgeSeq() by XBOOLE_0:def 1;
      consider x being set such that
A2:   x in dom W.edgeSeq() & y = W.edgeSeq().x by A1,FUNCT_1:def 5;
      x in dom (W.flowSeq(EL)) by A,A2,Def18;
      then (W.flowSeq(EL)).x in D by FUNCT_1:def 5;
      then reconsider D as non empty finite Subset of NAT;
      deffunc F(Nat) = $1;
      consider IT being Element of D such that
A3:   for k being Element of D holds F(IT) <= F(k) from GRAPH_5:sch 2;
      reconsider IT as Nat;
      take IT;
      thus IT in rng (W.flowSeq(EL));
      let k be real number;
      assume k in rng (W.flowSeq(EL));
      hence IT <= k by A3;
    end;
    hence thesis;
  end;
  uniqueness
  proof
    let IT1,IT2 be Nat;
    hereby
      assume W is non trivial;
      assume
A4:   IT1 in rng (W.flowSeq(EL)) &
      for k being real number st k in rng (W.flowSeq(EL)) holds IT1 <= k;
      assume IT2 in rng (W.flowSeq(EL)) &
      for k being real number st k in rng (W.flowSeq(EL)) holds IT2 <= k;
      then IT1 <= IT2 & IT2 <= IT1 by A4;
      hence IT1 = IT2 by XXREAL_0:1;
    end;
    thus thesis;
  end;
  consistency;
end;

definition
  let G be natural-weighted WGraph, EL being FF:ELabeling of G,
      P be Path of G;
  assume A: P is_augmenting_wrt EL;

  func FF:PushFlow(EL,P) -> FF:ELabeling of G  means        :Def20: ::dFFPUSH
  (for e being set st e in the_Edges_of G & not e in P.edges()
     holds it.e = EL.e) &
  (for n being odd Nat st n < len P
     holds (P.(n+1) DJoins P.n, P.(n+2),G implies
              it.(P.(n+1)) = EL.(P.(n+1)) + P.tolerance(EL)) &
           (not P.(n+1) DJoins P.n,P.(n+2),G implies
              it.(P.(n+1)) = EL.(P.(n+1)) - P.tolerance(EL)));
  existence
  proof
  defpred P[set,set] means
    ($1 in the_Edges_of G & not $1 in P.edges() implies
        $2 = EL.$1) &
    (for n being odd Element of NAT st n < len P & $1 = P.(n+1)
      holds
       ((P.(n+1) DJoins P.n,P.(n+2),G) implies
         $2 = EL.(P.(n+1)) + P.tolerance(EL)) &
        (not P.(n+1) DJoins P.n,P.(n+2),G implies
         $2 = EL.(P.(n+1)) - P.tolerance(EL)));
    now
      let x be set;
      assume x in the_Edges_of G;
      now per cases;
        suppose
A4:       not x in P.edges();
          set y = EL.x;
          for n being odd Element of NAT st n < len P & x = P.(n+1) holds
          ((P.(n+1) DJoins P.n,P.(n+2),G) implies
          y = EL.(P.(n+1)) + P.tolerance(EL)) &
          (not P.(n+1) DJoins P.n,P.(n+2),G implies
          y = EL.(P.(n+1)) - P.tolerance(EL)) by A4,GLIB_001:101;
          hence ex y being set st P[x,y];
        end;
        suppose
A5:       x in P.edges();
          then consider n being odd Element of NAT such that
A6:       n < len P & P.(n+1) = x by GLIB_001:101;
A7:       1 <= n+1 & n+1 <= len P by A6,NAT_1:11,13;
          now per cases;
            suppose
A8:           (P.(n+1) DJoins P.n,P.(n+2),G);
              set y = EL.(P.(n+1)) + P.tolerance(EL);
              now thus x in the_Edges_of G & not x in P.edges()
                implies y = EL.x by A5;
                let m be odd Element of NAT such that
A9:             m < len P & P.(m+1) = x;
                1 <= m+1 & m+1 <= len P by A9,NAT_1:11,13;
                then m+1 <= n+1 & n+1 <= m+1 by A6,A7,A9,GLIB_001:139;
                then
A10:            m+1 = n+1 by XXREAL_0:1;
                thus P.(m+1) DJoins P.m,P.(m+2),G implies y = y;
                assume not P.(m+1) DJoins P.m,P.(m+2),G;
                hence y = EL.(P.(m+1)) - P.tolerance(EL)
                by A8,A10;
              end;
              then P[x,y] by A6;
              hence ex y being set st P[x,y];
            end;
            suppose
A11:          not (P.(n+1) DJoins P.n,P.(n+2),G);
              set y =EL.(P.(n+1)) - P.tolerance(EL);
              now thus x in the_Edges_of G & not x in P.edges()
                implies y = EL.x by A5;
                let m be odd Element of NAT such that
A12:            m < len P & P.(m+1) = x;
                1 <= m+1 & m+1 <= len P by A12,NAT_1:11,13;
                then m+1 <= n+1 & n+1 <= m+1 by A6,A7,A12,GLIB_001:139;
                then m+1 = n+1 by XXREAL_0:1;
                hence P.(m+1) DJoins P.m,P.(m+2),G implies
                y = EL.(P.(n+1)) + P.tolerance(EL) by A11;
                assume not P.(m+1) DJoins P.m,P.(m+2),G;
                thus y = EL.(P.(n+1)) - P.tolerance(EL);
              end;
              then P[x,y] by A6;
              hence ex y being set st P[x,y];
            end;
          end;
          hence ex y being set st P[x,y];
        end;
      end;
      hence ex y being set st P[x,y];
    end;
    then
A13: for x being set st x in the_Edges_of G holds ex y being set st P[ x,y];
    consider IT being Function such that
A14: dom IT = the_Edges_of G and
A14a: for e being set st e in the_Edges_of G holds P[e,IT.e]
                                                 from CLASSES1:sch 1(A13);
    rng IT c= NAT proof
      let y be set;
      assume y in rng IT;
      then consider e being set such that
A1:   e in dom IT and
A1a:  IT.e = y by FUNCT_1:def 5;
      now per cases;
        suppose not e in P.edges();
          then y = EL.e by A1a,A1,A14,A14a;
          hence thesis by ORDINAL1:def 13;
        end;
        suppose
A3:       e in P.edges();
          then consider n being odd Element of NAT such that
A4:       n < len P & P.(n+1) = e by GLIB_001:101;
A5:       P is non trivial by A3,GLIB_001:137;
          now per cases;
            suppose P.(n+1) DJoins P.n, P.(n+2), G;
              then y = EL.(P.(n+1))+P.tolerance(EL) by A1,A1a,A4,A14,A14a;
              hence thesis by ORDINAL1:def 13;
            end;
            suppose
A6:           not P.(n+1) DJoins P.n,P.(n+2),G;
              then
A7:           y = EL.e-P.tolerance(EL) by A1,A1a,A4,A14,A14a;
              set n1div2 = (n+1) div 2;
              1 <= n+1 & n+1 <= len P by A4,NAT_1:11,13;
              then n1div2 in dom P.edgeSeq() & e = P.edgeSeq().n1div2
              by A4,GLIB_001:78;
              then
A8:           n1div2 in dom (P.flowSeq(EL)) by A,Def18;
              2 divides n+1 by PEPIN:22;
              then
A9:           2*n1div2 = n+1 by NAT_D:3;
              then
A10:          2*n1div2-1 = n;
              2*n1div2+1 = n+(1+1) by A9;
              then (P.flowSeq(EL)).n1div2 = EL.e by A,A4,A6,A8,A10,Def18;
              then EL.e in rng (P.flowSeq(EL)) by A8,FUNCT_1:def 5;
              then P.tolerance(EL) <= EL.e by A,A5,Def19;
              hence thesis by A7,INT_1:18;
            end;
          end;
          hence thesis;
        end;
      end;
      hence thesis;
    end;
    then
    reconsider IT as
       natural-valued ManySortedSet of the_Edges_of G
                                         by A14,PARTFUN1:def 4,RELAT_1:def 18
,VALUED_0:def 6;
    take IT;
    thus for e being set st e in the_Edges_of G & not e in P.edges()
    holds IT.e = EL.e by A14a;
    let n be odd Nat;
      reconsider n' = n as odd Element of NAT by ORDINAL1:def 13;
A15a: n' = n;
    assume
A15: n < len P;
    then P.(n+1) Joins P.n, P.(n'+2), G by GLIB_001:def 3;
    then
A16: P.(n+1) in the_Edges_of G by GLIB_000:def 15;
    hence P.(n+1) DJoins P.n,P.(n+2),G implies
          IT.(P.(n+1)) = EL.(P.(n+1)) + P.tolerance(EL) by A14a,A15,A15a;
    assume not P.(n+1) DJoins P.n, P.(n+2), G;
    hence thesis by A14a,A15,A15a,A16;
  end;
  uniqueness
  proof
    let IT1,IT2 be FF:ELabeling of G such that
A17: (for e being set st e in the_Edges_of G & not e in P.edges()
       holds IT1.e = EL.e) &
    (for n being odd Nat st n < len P holds
    (P.(n+1) DJoins P.n, P.(n+2),G implies
    IT1.(P.(n+1)) = EL.(P.(n+1)) + P.tolerance(EL)) &
    (not P.(n+1) DJoins P.n,P.(n+2),G implies
    IT1.(P.(n+1)) = EL.(P.(n+1)) - P.tolerance(EL))) and
A18: (for e being set st e in the_Edges_of G & not e in P.edges()
    holds IT2.e = EL.e) &
    (for n being odd Nat st n < len P holds
    (P.(n+1) DJoins P.n, P.(n+2),G implies
    IT2.(P.(n+1)) = EL.(P.(n+1)) + P.tolerance(EL)) &
    (not P.(n+1) DJoins P.n,P.(n+2),G implies
    IT2.(P.(n+1)) = EL.(P.(n+1)) - P.tolerance(EL)));
    now
      let e be set;
      assume
A19:  e in the_Edges_of G;
      now per cases;
        suppose not e in P.edges();
          then IT1.e = EL.e &
          IT2.e = EL.e by A17,A18,A19;
          hence IT1.e = IT2.e;
        end;
        suppose e in P.edges();
          then consider n being odd Element of NAT such that
A20:      n < len P & P.(n+1) = e by GLIB_001:101;
          now per cases;
            suppose P.(n+1) DJoins P.n,P.(n+2),G;
              then IT1.e = EL.(P.(n+1)) + P.tolerance(EL) &
              IT2.e = EL.(P.(n+1)) + P.tolerance(EL)
              by A17,A18,A20;
              hence IT1.e = IT2.e;
            end;
            suppose not P.(n+1) DJoins P.n,P.(n+2),G;
              then IT1.e = EL.(P.(n+1)) - P.tolerance(EL) &
              IT2.e = EL.(P.(n+1)) - P.tolerance(EL)
              by A17,A18,A20;
              hence IT1.e = IT2.e;
            end;
          end;
          hence IT1.e = IT2.e;
        end;
      end;
      hence IT1.e = IT2.e;
    end;
    hence thesis by PBOOLE:3;
  end;
end;

definition
  let G be finite natural-weighted WGraph, EL being FF:ELabeling of G,
      sink, source be Vertex of G;
  func FF:Step(EL, source, sink) -> FF:ELabeling of G equals
  :Def22: ::dFFSTEP
  FF:PushFlow(EL, AP:GetAugPath(EL,source,sink))
    if sink in dom AP:FindAugPath(EL,source)
    otherwise
  EL;
  correctness;
end;

definition
  let G be _Graph;
  mode FF:ELabelingSeq of G -> ManySortedSet of NAT means   :dFFELS:
  for n being Nat holds it.n is FF:ELabeling of G;
  existence proof
     set el = the_Edges_of G --> 0;
     set f = NAT --> el;
     take f;
     let n be Nat;
     n in NAT by ORDINAL1:def 13;
     hence thesis by FUNCOP_1:13;
  end;
end;

definition
  let G be _Graph, ES be FF:ELabelingSeq of G, n be Nat;
  redefine func ES.n -> FF:ELabeling of G;
  coherence by dFFELS;
end;

definition
  let G be finite natural-weighted WGraph, source, sink be Vertex of G;
  func FF:CompSeq(G,source,sink) -> FF:ELabelingSeq of G means
  :Def23: ::dFFCS
  it.0 = the_Edges_of G --> 0 &
  for n being Nat holds it.(n+1) = FF:Step(it.n,source,sink);
  existence
proof
    defpred P[set,set,set] means
      (ex e being FF:ELabeling of G st e = $2 & $3 = FF:Step(e,source,sink)) or
      (not ex e being FF:ELabeling of G st e = $2) & $3 = $2;
      now
      let n,x be set;
      now per cases;
        suppose ex e being FF:ELabeling of G st e = x;
          then consider e being FF:ELabeling of G such that
        A1: e = x;
           set y = FF:Step(e,source,sink);
           P[n,x,y] by A1;
          hence ex y being set st P[n,x,y];
        end;
        suppose not ex e being FF:ELabeling of G st e = x;
          hence ex y being set st P[n,x,y];
        end;
      end;
      hence ex y being set st P[n,x,y];
    end;
    then
A2: for n being Element of NAT for x being set ex y being set st P[n,x,y];
    consider IT being Function such that
A4: dom IT = NAT & IT.0 = the_Edges_of G --> 0 &
    for n being Element of NAT holds P[n,IT.n,IT.(n+1)]
                from RECDEF_1:sch 1(A2);
    reconsider IT as ManySortedSet of NAT by A4,PARTFUN1:def 4,RELAT_1:def 18;
    defpred P2[Nat] means
       ex Gn being FF:ELabeling of G st IT.$1 = Gn;
    reconsider E0 = the_Edges_of G --> 0 as Function of the_Edges_of G, REAL
           by FUNCOP_1:58;
A5: P2[0] by A4;
A6: now
      let n be Nat;
      assume P2[n];
      then consider Gn being FF:ELabeling of G such that
A7:   IT.n = Gn;
      n in NAT by ORDINAL1:def 13;
      then
A8:   P[n,Gn,IT.(n+1)] by A4,A7;
      set P = AP:GetAugPath(Gn,source,sink);
      thus P2[n+1] by A8;
    end;
A9: for n being Nat holds P2[n] from NAT_1:sch 2(A5,A6);
    now
      let n be Nat;
      consider Gn being FF:ELabeling of G such that
A10:  IT.n = Gn by A9;
      thus IT.n is FF:ELabeling of G by A10;
    end;
    then reconsider IT as FF:ELabelingSeq of G by dFFELS;
    take IT;
    thus IT.0 = the_Edges_of G --> 0 by A4;
    let n be Nat;
    reconsider n' = n as Element of NAT by ORDINAL1:def 13;
    consider X being FF:ELabeling of G such that
A14: X = IT.n & IT.(n'+1) = FF:Step(X,source,sink) by A4;
    thus thesis by A14;
  end;
  uniqueness
  proof
    let IT1,IT2 be FF:ELabelingSeq of G such that
A15: IT1.0 = the_Edges_of G --> 0 &
    for n being Nat holds IT1.(n+1) = FF:Step(IT1.n,source,sink) and
A16: IT2.0 = the_Edges_of G --> 0 &
    for n being Nat holds IT2.(n+1) = FF:Step(IT2.n,source,sink);
    defpred P[Nat] means IT1.$1 = IT2.$1;
A17: P[0] by A15,A16;
A18: now
      let n be Element of NAT;
      assume
A19:  P[n];
A21:  IT2.(n+1) = FF:Step(IT2.n,source,sink) by A16;
      thus P[n+1] by A19,A15,A21;
    end;
    for n being Element of NAT holds P[n] from NAT_1:sch 1(A17,A18);
    then for n being set st n in NAT holds IT1.n = IT2.n;
    hence IT1 = IT2 by PBOOLE:3;
  end;
end;

definition
  let G be finite natural-weighted WGraph, sink,source be Vertex of G;
  func FF:MaxFlow(G,source, sink) -> FF:ELabeling of G equals  ::dFFMAXFLOW
  FF:CompSeq(G,source,sink).Result();
  coherence
  proof
    set CS = FF:CompSeq(G,source,sink);
    CS.Result() = CS.(CS.Lifespan());
    hence thesis;
  end;
end;

begin :: Ford Fulkerson Maximum Flow Theorems

theorem Th11: :: tFLOW01
for G being finite real-weighted WGraph, EL being FF:ELabeling of G,
    source, sink being set, V being Subset of the_Vertices_of G
 st EL has_valid_flow_from source,sink & source in V & not sink in V
  holds EL.flow(source,sink) =
    Sum (EL | G.edgesDBetween(V, the_Vertices_of G \ V)) -
    Sum (EL | G.edgesDBetween(the_Vertices_of G \ V, V))
proof
  let G be finite real-weighted WGraph, EL being FF:ELabeling of G,
      source,sink be set, V be Subset of the_Vertices_of G;
  assume
A1: EL has_valid_flow_from source,sink & source in V & not sink in V;
  set VG = the_Vertices_of G;
  set SG = the_Source_of G;
  set TG = the_Target_of G;
  defpred P[Nat] means for V being Subset of VG
  st card (VG \ V) = $1 & source in V & not sink in V holds
  EL.flow(source,sink) = Sum (EL | G.edgesDBetween(V, VG \ V)) -
  Sum (EL | G.edgesDBetween(VG \ V, V));
  now
    let V be Subset of VG;
    assume
A2: card (VG \ V) = 1 & source in V & not sink in V;
    then consider v being set such that
A3: VG \ V = {v} by CARD_2:60;
    sink is Vertex of G by A1,Def7;
    then sink in VG \ V by A2,XBOOLE_0:def 5;
    then
A4: v = sink by A3,TARSKI:def 1;
A5: now
      let x be set;
      hereby
        assume x in VG \ {sink};
        then x in VG & not x in {sink} by XBOOLE_0:def 5;
        hence x in V by A3,A4,XBOOLE_0:def 5;
      end;
      assume
A6:   x in V;
      then not x in {sink} by A2,TARSKI:def 1;
      hence x in VG \ {sink} by A6,XBOOLE_0:def 5;
    end;
    then
A7: V = VG \ {sink} by TARSKI:2;
    set ESS = G.edgesDBetween({sink},{sink});
    reconsider EIN = G.edgesInto({sink}) \ ESS as Subset of the_Edges_of G;
    reconsider EOUT= G.edgesOutOf({sink})\ ESS as Subset of the_Edges_of G;
    set EESS = EL|ESS;
    now
      let e be set;
      hereby
        assume e in G.edgesDBetween(V, VG \ V);
        then e DSJoins VG \ {sink}, {sink},G
        by A3,A4,A7,GLIB_000:def 33;
        then
A8:     e in the_Edges_of G &
        SG.e in VG \ {sink} &
        TG.e in {sink} by GLIB_000:def 18;
        then
A9:     e in G.edgesInto({sink}) by GLIB_000:def 28;
        now
          assume e in ESS;
          then e DSJoins {sink},{sink},G by GLIB_000:def 33;
          then SG.e in {sink} by GLIB_000:def 18;
          hence contradiction by A8,XBOOLE_0:def 5;
        end;
        hence e in EIN by A9,XBOOLE_0:def 5;
      end;
      assume
A10:  e in EIN;
      then
A11:  e in G.edgesInto({sink}) & not e in ESS by XBOOLE_0:def 5;
      G.edgesInto({sink}) qua set \ ESS is Subset of G.edgesInto({sink});
      then
A12:  e in the_Edges_of G & TG.e in {sink}
      by A10,GLIB_000:def 28;
      now
        assume not SG.e in V;
        then
A13:    not SG.e in VG \ {sink} by A5;
        SG.e in VG by A10,FUNCT_2:7;
        then SG.e in {sink} by A13,XBOOLE_0:def 5;
        then e DSJoins {sink},{sink},G by A12,GLIB_000:def 18;
        hence contradiction by A11,GLIB_000:def 33;
      end;
      then e DSJoins V, {sink}, G by A12,GLIB_000:def 18;
      hence e in G.edgesDBetween(V, VG \ V)
      by A3,A4,GLIB_000:def 33;
    end;
    then
A14: G.edgesDBetween(V, VG \ V) = EIN by TARSKI:2;
    now
      let e be set;
      assume e in ESS;
      then e DSJoins {sink},{sink},G by GLIB_000:def 33;
      then e in the_Edges_of G & TG.e in {sink}
      by GLIB_000:def 18;
      hence e in G.edgesInto({sink}) by GLIB_000:def 28;
    end;
    then
A15: ESS c= G.edgesInto({sink}) by TARSKI:def 3;
A16: ESS \/ EIN = G.edgesInto({sink}) \/ ESS by XBOOLE_1:39
      .= G.edgesInto({sink}) by A15,XBOOLE_1:12;
A17: dom (EL|G.edgesInto({sink})) = G.edgesInto({sink}) & dom (EL|ESS)=ESS &
    dom (EL|EIN)=EIN & dom (EL|EOUT)=EOUT & dom (EL|G.edgesOutOf({sink}))
    = G.edgesOutOf({sink}) by PARTFUN1:def 4;
    then
A18: dom (EL|ESS +* EL|EIN) = ESS \/ EIN by FUNCT_4:def 1;
    now
      let e be set;
      assume
A19:  e in dom (EL|G.edgesInto({sink}));
      then
A20:  e in G.edgesInto({sink}) by PARTFUN1:def 4;
      now per cases;
        suppose
A21:      e in ESS;
          then not e in EIN by XBOOLE_0:def 5;
          hence (EL|ESS +* EL|EIN).e = (EL|ESS).e by A17,FUNCT_4:12
            .= EL.e by A17,A21,FUNCT_1:70;
        end;
        suppose not e in ESS;
          then
A22:      e in EIN by A20,XBOOLE_0:def 5;
          hence (EL|ESS +* EL|EIN).e = (EL|EIN).e by A17,FUNCT_4:14
            .= EL.e by A17,A22,FUNCT_1:70;
        end;
      end;
      hence EL|G.edgesInto({sink}).e =
      (EL|ESS +* EL|EIN).e by A19,FUNCT_1:70;
    end;
    then
A23: Sum (EL|G.edgesInto({sink})) = Sum (EL|EIN) + Sum EESS
      by A16,A17,A18,FUNCT_1:9,GLIB_004:3;
    now
      let e be set;
      hereby
        assume e in G.edgesDBetween(VG \ V, V);
        then e DSJoins {sink},(VG \ {sink}),G
        by A3,A4,A7,GLIB_000:def 33;
        then
A24:    e in the_Edges_of G & SG.e in {sink} &
        TG.e in (VG \ {sink})
        by GLIB_000:def 18;
        then
A25:    e in G.edgesOutOf({sink}) by GLIB_000:def 29;
        now
          assume e in ESS;
          then e DSJoins {sink},{sink},G by GLIB_000:def 33;
          then TG.e in {sink} by GLIB_000:def 18;
          hence contradiction by A24,XBOOLE_0:def 5;
        end;
        hence e in EOUT by A25,XBOOLE_0:def 5;
      end;
      assume
A26:  e in EOUT;
      then
A27:  e in G.edgesOutOf({sink}) & not e in ESS by XBOOLE_0:def 5;
      G.edgesOutOf({sink}) qua set \ ESS is Subset of G.edgesOutOf({sink});
      then
A28:  e in the_Edges_of G & SG.e in {sink}
      by A26,GLIB_000:def 29;
      now
        assume
A29:    not TG.e in V;
        TG.e in VG by A26,FUNCT_2:7;
        then TG.e in {sink} by A7,A29,XBOOLE_0:def 5;
        then e DSJoins {sink},{sink},G by A28,GLIB_000:def 18;
        hence contradiction by A27,GLIB_000:def 33;
      end;
      then e DSJoins (VG \ V),V,G by A3,A4,A28,GLIB_000:def 18;
      hence e in G.edgesDBetween(VG \ V, V) by GLIB_000:def 33;
    end;
    then
A30: G.edgesDBetween(VG \ V, V) = EOUT by TARSKI:2;
    now
      let e be set;
      assume e in ESS;
      then e DSJoins {sink},{sink},G by GLIB_000:def 33;
      then e in the_Edges_of G & SG.e in {sink}
      by GLIB_000:def 18;
      hence e in G.edgesOutOf({sink}) by GLIB_000:def 29;
    end;
    then
A31: ESS c= G.edgesOutOf({sink}) by TARSKI:def 3;
    ESS \/ EOUT = G.edgesOutOf({sink}) \/ ESS by XBOOLE_1:39
      .= G.edgesOutOf({sink}) by A31,XBOOLE_1:12;
    then
A32: dom (EL|ESS +* EL|EOUT) = G.edgesOutOf({sink}) by A17,FUNCT_4:def 1;
    now
      let e be set;
      assume
A33:  e in dom (EL|G.edgesOutOf({sink}));
      then
A34:  e in G.edgesOutOf({sink}) by PARTFUN1:def 4;
      now per cases;
        suppose
A35:      e in ESS;
          then not e in EOUT by XBOOLE_0:def 5;
          hence (EL|ESS +* EL|EOUT).e = (EL|ESS).e by A17,FUNCT_4:12
            .= EL.e by A17,A35,FUNCT_1:70;
        end;
        suppose not e in ESS;
          then
A36:      e in EOUT by A34,XBOOLE_0:def 5;
          hence (EL|ESS +* EL|EOUT).e = (EL|EOUT).e by A17,FUNCT_4:14
            .= EL.e by A17,A36,FUNCT_1:70;
        end;
      end;
      hence EL|G.edgesOutOf({sink}).e = (EL|ESS +* EL|EOUT).e
      by A33,FUNCT_1:70;
    end;
    then Sum (EL|G.edgesOutOf({sink})) = Sum (EL|EOUT)+Sum EESS
       by A17,A32,FUNCT_1:9,GLIB_004:3;
    then EL.flow(source,sink) = Sum (EL|EIN)+Sum EESS -(Sum EESS + Sum (EL|
    EOUT)) by A1,A23,Def8
      .= Sum (EL|EIN) - Sum (EL|EOUT);
    hence EL.flow(source,sink) =
    Sum (EL | G.edgesDBetween(V, VG \ V)) -
    Sum (EL | G.edgesDBetween(VG \ V, V)) by A14,A30;
  end;
  then
A37: P[1];
A38: now
    let n be non empty Nat;
    assume
A39: P[n];
    now
      let V2 be Subset of VG;
      assume
A40:  card (VG\V2) = n+1 & source in V2 & not sink in V2;
      set x = choose ((VG \ V2) \ {sink});
A41:  V2 qua set \ {x} is Subset of V2;
      sink is Vertex of G by A1,Def7;
      then sink in (VG \ V2) by A40,XBOOLE_0:def 5;
      then {sink} c= (VG \ V2) by ZFMISC_1:37;
      then card ((VG\V2)\{sink}) = n+1-card {sink} by A40,CARD_2:63
        .= n+1-1 by CARD_1:50
        .= n;
      then
A42:  x in (VG)\V2 & not x in {sink} by CARD_1:47,XBOOLE_0:def 5;
      then
A43:  x in VG & not x in V2 by XBOOLE_0:def 5;
      set V1 = V2 \/ {x};
      set EV1V1a = G.edgesDBetween(V1, VG \ V1);
      set EV1V1b = G.edgesDBetween(VG \ V1, V1);
      set EV2X = G.edgesDBetween(V2,{x});
      set EXV2 = G.edgesDBetween({x},V2);
      set EXV1c = G.edgesDBetween({x},VG\V1);
      set EV1Xd = G.edgesDBetween(VG\V1,{x});
      {x} c= VG by A42,ZFMISC_1:37;
      then reconsider V1 as Subset of VG by XBOOLE_1:8;
A44:  VG \ V1 = (VG \ V2) \ {x} by XBOOLE_1:41;
      {x} c= VG \ V2 by A42,ZFMISC_1:37;
      then
A45:  card (VG \ V1) = card (VG \ V2) - card {x} by A44,CARD_2:63
        .= n + 1 - 1 by A40,CARD_1:50
        .= n;
A46:  source in V1 by A40,XBOOLE_0:def 3;
A47:  x <> sink by A42,TARSKI:def 1;
      then not sink in {x} by TARSKI:def 1;
      then not sink in V1 by A40,XBOOLE_0:def 3;
      then
A48:  EL.flow(source,sink) = Sum (EL|EV1V1a) - Sum (EL|EV1V1b) by A39,A45,A46;
      now
        let e be set;
        hereby
          assume e in G.edgesDBetween(V2, VG \ V2);
          then e DSJoins V2, VG \ V2, G by GLIB_000:def 33;
          then
A49:      e in the_Edges_of G & SG.e in V2 &
          TG.e in VG \ V2 by GLIB_000:def 18;
          then
A50:      SG.e in V1 by XBOOLE_0:def 3;
A51:      now
            assume e in EXV1c;
            then e DSJoins {x},VG \ V1,G by GLIB_000:def 33;
            then SG.e in {x} by GLIB_000:def 18;
            hence contradiction by A43,A49,TARSKI:def 1;
          end;
          now per cases;
            suppose TG.e in {x};
              then e DSJoins V2,{x},G by A49,GLIB_000:def 18;
              then e in EV2X by GLIB_000:def 33;
              then e in EV1V1a \/ EV2X by XBOOLE_0:def 3;
              hence e in EV1V1a \/ EV2X \ EXV1c by A51,XBOOLE_0:def 5;
            end;
            suppose not TG.e in {x};
              then TG.e in VG \ V1 by A44,A49,XBOOLE_0:def 5;
              then e DSJoins V1, VG \ V1, G by A49,A50,GLIB_000:def 18;
              then e in EV1V1a by GLIB_000:def 33;
              then e in EV1V1a \/ EV2X by XBOOLE_0:def 3;
              hence e in EV1V1a \/ EV2X \ EXV1c by A51,XBOOLE_0:def 5;
            end;
          end;
          hence e in EV1V1a \/ EV2X \ EXV1c;
        end;
        assume
A52:    e in EV1V1a \/ EV2X \ EXV1c;
        then e in EV1V1a \/ EV2X & not e in EXV1c by XBOOLE_0:def 5;
        then
A53:    not e DSJoins {x}, VG \ V1,G by GLIB_000:def 33;
A54:    EV1V1a \/ EV2X qua set \ EXV1c is Subset of EV1V1a \/ EV2X;
        now per cases by A52,A54,XBOOLE_0:def 3;
          suppose e in EV1V1a;
            then e DSJoins V1, VG\V1, G by GLIB_000:def 33;
            then
A55:        e in the_Edges_of G & SG.e in V1 &
            TG.e in VG \ V1 by GLIB_000:def 18;
            then not SG.e in {x} by A53,GLIB_000:def 18;
            then SG.e in V1 \ {x} by A55,XBOOLE_0:def 5;
            then
A56:        SG.e in V2 \ {x} by XBOOLE_1:40;
            TG.e in VG &
            not TG.e in V1 by A55,XBOOLE_0:def 5;
            then not TG.e in V2 by XBOOLE_0:def 3;
            then TG.e in VG \ V2 by A55,XBOOLE_0:def 5;
            hence e DSJoins V2, VG \ V2, G by A41,A55,A56,GLIB_000:def 18;
          end;
          suppose e in EV2X;
            then e DSJoins V2, {x}, G by GLIB_000:def 33;
            then
A57:        e in the_Edges_of G & SG.e in V2 &
            TG.e in {x} by GLIB_000:def 18;
            then
A58:        TG.e in VG by FUNCT_2:7;
            not TG.e in V2 by A43,A57,TARSKI:def 1;
            then TG.e in VG \ V2 by A58,XBOOLE_0:def 5;
            hence e DSJoins V2, VG \ V2, G by A57,GLIB_000:def 18;
          end;
        end;
        hence e in G.edgesDBetween(V2, VG \ V2) by GLIB_000:def 33;
      end;
      then
A59:  G.edgesDBetween(V2, VG \ V2) = EV1V1a \/ EV2X \ EXV1c by TARSKI:2;
      reconsider EA = EV1V1a \/ EV2X as Subset of the_Edges_of G;
      reconsider E1 = EA \ EXV1c as Subset of the_Edges_of G;
      reconsider EB = EA \ EV2X as Subset of the_Edges_of G;
      reconsider EC = EV1V1b \/ EXV2 as Subset of the_Edges_of G;
      reconsider E2 = EC \ EV1Xd as Subset of the_Edges_of G;
      reconsider ED = EC \ EXV2 as Subset of the_Edges_of G;
      now
        assume EV1V1a meets EV2X;
        then
A60:    EV1V1a /\ EV2X <> {} by XBOOLE_0:def 7;
        set e = choose (EV1V1a /\ EV2X);
        e in EV1V1a & e in EV2X by A60,XBOOLE_0:def 4;
        then e DSJoins V1,VG\V1,G & e DSJoins V2,{x},G by GLIB_000:def 33;
        then TG.e in VG \ V1 &
        TG.e in {x} by GLIB_000:def 18;
        then not TG.e in V1 &
        TG.e in V1 by XBOOLE_0:def 3,def 5;
        hence contradiction;
      end;
      then EV1V1a \ EV2X = EV1V1a by XBOOLE_1:83;
      then
A61:  EB = EV1V1a by XBOOLE_1:40;
      now
        assume EV1V1b meets EXV2;
        then
A62:    EV1V1b /\ EXV2 <> {} by XBOOLE_0:def 7;
        set e = choose (EV1V1b /\ EXV2);
        e in EV1V1b & e in EXV2 by A62,XBOOLE_0:def 4;
        then e DSJoins VG\V1,V1,G & e DSJoins {x},V2,G by GLIB_000:def 33;
        then SG.e in VG \ V1 &
        SG.e in {x} by GLIB_000:def 18;
        then not SG.e in V1 &
        SG.e in V1 by XBOOLE_0:def 3,def 5;
        hence contradiction;
      end;
      then EV1V1b \ EXV2 = EV1V1b by XBOOLE_1:83;
      then
A63:  ED = EV1V1b by XBOOLE_1:40;
      now
        let e be set;
        assume e in EXV1c;
        then e DSJoins {x},VG \ V1, G by GLIB_000:def 33;
        then
A64:    e in the_Edges_of G & SG.e in {x} &
        TG.e in VG \ V1 by GLIB_000:def 18;
        then SG.e in V1 by XBOOLE_0:def 3;
        then e DSJoins V1,VG \ V1, G by A64,GLIB_000:def 18;
        hence e in EV1V1a by GLIB_000:def 33;
      end;
      then
A65:  EXV1c c= EV1V1a by TARSKI:def 3;
A66:  dom (EL|EA) = EA & dom (EL|EB) = EB & dom (EL|EXV1c) = EXV1c &
      dom (EL|EV2X)=EV2X & dom (EL|E1)=EA \ EXV1c by PARTFUN1:def 4
;
      then
A67:  dom (EL|EXV1c +* EL|E1) = EXV1c \/ (EA \ EXV1c) by FUNCT_4:def 1
        .= EXV1c \/ (EV1V1a \/ EV2X) by XBOOLE_1:39
        .= EA by A65,XBOOLE_1:10,12;
      now
        let e be set;
        assume e in dom (EL|EA);
        then
A68:    e in EA by PARTFUN1:def 4;
        now per cases;
          suppose not e in EXV1c;
            then
A69:        e in E1 by A68,XBOOLE_0:def 5;
            hence (EL|EXV1c +* EL|E1).e = (EL|E1).e by A66,FUNCT_4:14
              .= EL.e by A69,FUNCT_1:72;
          end;
          suppose
A70:        e in EXV1c;
            then not e in E1 by XBOOLE_0:def 5;
            hence (EL|EXV1c +* EL|E1).e = (EL|EXV1c).e by A66,FUNCT_4:12
              .= EL.e by A70,FUNCT_1:72;
          end;
        end;
        hence (EL|EA).e = (EL|EXV1c +* EL|E1).e by A68,FUNCT_1:72;
      end;
      then
A71:  Sum (EL|EA) = Sum (EL|E1) + Sum (EL|EXV1c)
        by A66,A67,FUNCT_1:9,GLIB_004:3;
A72:  dom (EL|EV2X +* EL|EB) = EV2X \/ EB by A66,FUNCT_4:def 1
        .= EV2X \/ (EV1V1a \/ EV2X) by XBOOLE_1:39
        .= EA by XBOOLE_1:6;
      now
        let e be set;
        assume e in dom (EL|EA);
        then
A73:    e in EA by PARTFUN1:def 4;
        now per cases;
          suppose not e in EV2X;
            then
A74:        e in EB by A73,XBOOLE_0:def 5;
            hence (EL|EV2X +* EL|EB).e = (EL|EB).e by A66,FUNCT_4:14
              .= EL.e by A74,FUNCT_1:72;
          end;
          suppose
A75:        e in EV2X;
            then not e in EB by XBOOLE_0:def 5;
            hence (EL|EV2X +* EL|EB).e = (EL|EV2X).e by A66,FUNCT_4:12
              .= EL.e by A75,FUNCT_1:72;
          end;
        end;
        hence (EL|EA).e = (EL|EV2X +* EL|EB).e by A73,FUNCT_1:72;
      end;
      then
A76:  Sum (EL|EA) = Sum (EL|EV2X) + Sum (EL|EV1V1a)
        by A61,A66,A72,FUNCT_1:9,GLIB_004:3;
      now
        let e be set;
        assume e in EV1Xd;
        then e DSJoins VG\V1,{x}, G by GLIB_000:def 33;
        then
A77:    e in the_Edges_of G & TG.e in {x} &
        SG.e in VG \ V1 by GLIB_000:def 18;
        then TG.e in V1 by XBOOLE_0:def 3;
        then e DSJoins VG\V1,V1, G by A77,GLIB_000:def 18;
        hence e in EV1V1b by GLIB_000:def 33;
      end;
      then
A78:  EV1Xd c= EV1V1b by TARSKI:def 3;
      now
        let e be set;
        hereby
          assume e in G.edgesDBetween(VG \ V2, V2);
          then e DSJoins VG\V2, V2, G by GLIB_000:def 33;
          then
A79:      e in the_Edges_of G & TG.e in V2 &
          SG.e in VG \ V2 by GLIB_000:def 18;
          then
A80:      TG.e in V1 by XBOOLE_0:def 3;
A81:      now
            assume e in EV1Xd;
            then e DSJoins VG \ V1,{x},G by GLIB_000:def 33;
            then TG.e in {x} by GLIB_000:def 18;
            hence contradiction by A43,A79,TARSKI:def 1;
          end;
          now per cases;
            suppose SG.e in {x};
              then e DSJoins {x},V2,G by A79,GLIB_000:def 18;
              then e in EXV2 by GLIB_000:def 33;
              then e in EV1V1b \/ EXV2 by XBOOLE_0:def 3;
              hence e in EV1V1b \/ EXV2 \ EV1Xd by A81,XBOOLE_0:def 5;
            end;
            suppose not SG.e in {x};
              then SG.e in VG \ V1 by A44,A79,XBOOLE_0:def 5;
              then e DSJoins VG \ V1, V1, G by A79,A80,GLIB_000:def 18;
              then e in EV1V1b by GLIB_000:def 33;
              then e in EV1V1b \/ EXV2 by XBOOLE_0:def 3;
              hence e in EV1V1b \/ EXV2 \ EV1Xd by A81,XBOOLE_0:def 5;
            end;
          end;
          hence e in EV1V1b \/ EXV2 \ EV1Xd;
        end;
        assume
A82:    e in EV1V1b \/ EXV2 \ EV1Xd;
        then e in EV1V1b \/ EXV2 & not e in EV1Xd by XBOOLE_0:def 5;
        then
A83:    not e DSJoins VG \ V1, {x}, G by GLIB_000:def 33;
A84:    EV1V1b \/ EXV2 qua set \ EV1Xd is Subset of EV1V1b \/ EXV2;
        now per cases by A82,A84,XBOOLE_0:def 3;
          suppose e in EV1V1b;
            then e DSJoins VG\V1, V1, G by GLIB_000:def 33;
            then
A85:        e in the_Edges_of G & TG.e in V1 &
            SG.e in VG \ V1 by GLIB_000:def 18;
            then not TG.e in {x} by A83,GLIB_000:def 18;
            then TG.e in V1 \ {x} by A85,XBOOLE_0:def 5;
            then
A86:        TG.e in V2 \ {x} by XBOOLE_1:40;
            SG.e in VG &
            not SG.e in V1 by A85,XBOOLE_0:def 5;
            then not SG.e in V2 by XBOOLE_0:def 3;
            then SG.e in VG \ V2 by A85,XBOOLE_0:def 5;
            hence e DSJoins VG \ V2, V2, G by A41,A85,A86,GLIB_000:def 18;
          end;
          suppose e in EXV2;
            then e DSJoins {x},V2, G by GLIB_000:def 33;
            then
A87:        e in the_Edges_of G & TG.e in V2 &
            SG.e in {x} by GLIB_000:def 18;
            then
A88:        SG.e in VG by FUNCT_2:7;
            not SG.e in V2 by A43,A87,TARSKI:def 1;
            then SG.e in VG \ V2 by A88,XBOOLE_0:def 5;
            hence e DSJoins VG \ V2, V2, G by A87,GLIB_000:def 18;
          end;
        end;
        hence e in G.edgesDBetween(VG\V2,V2) by GLIB_000:def 33;
      end;
      then
A89:  G.edgesDBetween(VG \ V2, V2) = E2 by TARSKI:2;
A90:  dom (EL|EC) = EC & dom (EL|ED) = ED & dom (EL|EV1Xd) = EV1Xd &
      dom (EL|EXV2)=EXV2 & dom (EL|E2)=EC\EV1Xd by PARTFUN1:def 4
;
      then
A91:  dom (EL|EV1Xd +* EL|E2) = EV1Xd \/ (EC \ EV1Xd) by FUNCT_4:def 1
        .= EV1Xd \/ (EV1V1b \/ EXV2) by XBOOLE_1:39
        .= EC by A78,XBOOLE_1:10,12;
      now
        let e be set;
        assume e in dom (EL|EC);
        then
A92:    e in EC by PARTFUN1:def 4;
        now per cases;
          suppose not e in EV1Xd;
            then
A93:        e in E2 by A92,XBOOLE_0:def 5;
            hence (EL|EV1Xd +* EL|E2).e = (EL|E2).e by A90,FUNCT_4:14
              .= EL.e by A93,FUNCT_1:72;
          end;
          suppose
A94:        e in EV1Xd;
            then not e in E2 by XBOOLE_0:def 5;
            hence (EL|EV1Xd +* EL|E2).e = (EL|EV1Xd).e by A90,FUNCT_4:12
              .= EL.e by A94,FUNCT_1:72;
          end;
        end;
        hence (EL|EC).e = (EL|EV1Xd +* EL|E2).e by A92,FUNCT_1:72;
      end;
      then
A95:  Sum (EL|EC) = Sum (EL|E2) + Sum (EL|EV1Xd)
        by A90,A91,FUNCT_1:9,GLIB_004:3;
A96:  dom (EL|EXV2 +* EL|ED) = EXV2 \/ ED by A90,FUNCT_4:def 1
        .= EXV2 \/ (EV1V1b \/ EXV2) by XBOOLE_1:39
        .= EC by XBOOLE_1:6;
      now
        let e be set;
        assume e in dom (EL|EC);
        then
A97:    e in EC by PARTFUN1:def 4;
        now per cases;
          suppose not e in EXV2;
            then
A98:        e in ED by A97,XBOOLE_0:def 5;
            hence (EL|EXV2 +* EL|ED).e = (EL|ED).e by A90,FUNCT_4:14
              .= EL.e by A98,FUNCT_1:72;
          end;
          suppose
A99:        e in EXV2;
            then not e in ED by XBOOLE_0:def 5;
            hence (EL|EXV2 +* EL|ED).e = (EL|EXV2).e by A90,FUNCT_4:12
              .= EL.e by A99,FUNCT_1:72;
          end;
        end;
        hence (EL|EC).e = (EL|EXV2 +* EL|ED).e by A97,FUNCT_1:72;
      end;
      then
A100: Sum (EL|EC) = Sum (EL|EXV2) + Sum (EL|EV1V1b)
        by A63,A90,A96,FUNCT_1:9,GLIB_004:3;
      set EXXe = G.edgesDBetween({x}, VG \ {x});
      set EXXf = G.edgesDBetween(VG \ {x}, {x});
      now
        let e be set;
        hereby
          assume e in EXXf \ EV2X;
          then e in EXXf & not e in EV2X by XBOOLE_0:def 5;
          then
A101:     e DSJoins VG \ {x}, {x}, G & not e DSJoins V2, {x}, G
          by GLIB_000:def 33; then
A102:     e in the_Edges_of G & SG.e in VG \ {x } &
          TG.e in {x} by GLIB_000:def 18;
          then
A103:     not SG.e in V2 by A101,GLIB_000:def 18;
          SG.e in VG & not SG.e in {x } by A102,XBOOLE_0:def 5;
          then not SG.e in V1 by A103,XBOOLE_0:def 3;
          then SG.e in VG \ V1 by A102,XBOOLE_0:def 5;
          then e DSJoins VG \ V1, {x}, G by A102,GLIB_000:def 18;
          hence e in EV1Xd by GLIB_000:def 33;
        end;
        assume e in EV1Xd;
        then e DSJoins VG \ V1, {x}, G by GLIB_000:def 33;
        then
A104:   e in the_Edges_of G & SG.e in VG \ V1 &
        TG.e in {x} by GLIB_000:def 18;
        then
A105:   SG.e in VG & not SG.e in V1 by XBOOLE_0:def 5;
        then not SG.e in V2 by XBOOLE_0:def 3;
        then not e DSJoins V2,{x},G by GLIB_000:def 18;
        then
A106:   not e in EV2X by GLIB_000:def 33;
        not SG.e in {x} by A105,XBOOLE_0:def 3;
        then SG.e in VG \ {x} by A104,XBOOLE_0:def 5;
        then e DSJoins VG \ {x}, {x}, G by A104,GLIB_000:def 18;
        then e in EXXf by GLIB_000:def 33;
        hence e in EXXf \ EV2X by A106,XBOOLE_0:def 5;
      end;
      then
A107: EXXf \ EV2X = EV1Xd by TARSKI:2;
      reconsider EV1Xdb = EXXf \ EV2X as Subset of the_Edges_of G;
      now
        let e be set;
        assume e in EV2X;
        then e DSJoins V2,{x},G by GLIB_000:def 33;
        then
A108:   e in the_Edges_of G & SG.e in V2 &
        TG.e in {x} by GLIB_000:def 18;
        then not SG.e in {x} by A43,TARSKI:def 1;
        then SG.e in VG \ {x} by A108,XBOOLE_0:def 5;
        then e DSJoins VG\{x}, {x}, G by A108,GLIB_000:def 18;
        hence e in EXXf by GLIB_000:def 33;
      end;
      then
A109: EV2X c= EXXf by TARSKI:def 3;
A110: dom (EL|EXXf) = EXXf & dom (EL|EV2X) = EV2X &
      dom (EL|EV1Xdb) = EXXf \ EV2X by PARTFUN1:def 4;
      then
A111: dom (EL|EV2X +* EL|(EXXf \ EV2X)) = EV2X \/ (EXXf \ EV2X)
      by FUNCT_4:def 1
        .= EV2X \/ EXXf by XBOOLE_1:39
        .= EXXf by A109,XBOOLE_1:12;
      now
        let e be set;
        assume
A112:   e in dom (EL|EXXf);
        then
A113:   e in EXXf by PARTFUN1:def 4;
        now per cases;
          suppose
A114:       e in EV2X;
            then not e in EV1Xdb by XBOOLE_0:def 5;
            hence (EL|EV2X +* EL|EV1Xdb).e=(EL|EV2X).e by A110,FUNCT_4:12
              .=EL.e by A114,FUNCT_1:72;
          end;
          suppose not e in EV2X;
            then
A115:       e in EV1Xdb by A113,XBOOLE_0:def 5;
            hence (EL|EV2X +* EL|EV1Xdb).e = (EL|EV1Xdb).e by A110,FUNCT_4:14
              .= EL.e by A115,FUNCT_1:72;
          end;
        end;
        hence (EL|EXXf).e = (EL|EV2X +* EL|EV1Xdb).e by A110,A112,FUNCT_1:72;
      end;
      then
A116: Sum (EL|EV2X) + Sum (EL|EV1Xd) = Sum (EL|EXXf)
        by A107,A110,A111,FUNCT_1:9,GLIB_004:3;
      now
        let e be set;
        hereby
          assume e in EXXe \ EXV2;
          then e in EXXe & not e in EXV2 by XBOOLE_0:def 5;
          then
A117:     e DSJoins {x},VG\{x}, G & not e DSJoins {x},V2,G by GLIB_000:def 33;
          then
A118:     e in the_Edges_of G & TG.e in VG \ {x } &
          SG.e in {x} by GLIB_000:def 18;
          then
A119:     not TG.e in V2 by A117,GLIB_000:def 18;
          TG.e in VG & not TG.e in {x } by A118,XBOOLE_0:def 5;
          then not TG.e in V1 by A119,XBOOLE_0:def 3;
          then TG.e in VG \ V1 by A118,XBOOLE_0:def 5;
          then e DSJoins {x}, VG \ V1, G by A118,GLIB_000:def 18;
          hence e in EXV1c by GLIB_000:def 33;
        end;
        assume e in EXV1c;
        then e DSJoins {x}, VG \ V1, G by GLIB_000:def 33;
        then
A120:   e in the_Edges_of G & TG.e in VG \ V1 &
        SG.e in {x} by GLIB_000:def 18;
        then
A121:   TG.e in VG & not TG.e in V1 by XBOOLE_0:def 5;
        then not TG.e in V2 by XBOOLE_0:def 3;
        then not e DSJoins {x},V2,G by GLIB_000:def 18;
        then
A122:   not e in EXV2 by GLIB_000:def 33;
        not TG.e in {x} by A121,XBOOLE_0:def 3;
        then TG.e in VG \ {x} by A120,XBOOLE_0:def 5;
        then e DSJoins {x}, VG \ {x}, G by A120,GLIB_000:def 18;
        then e in EXXe by GLIB_000:def 33;
        hence e in EXXe \ EXV2 by A122,XBOOLE_0:def 5;
      end;
      then
A123: EXXe \ EXV2 = EXV1c by TARSKI:2;
      reconsider EXV1cb = EXXe \ EXV2 as Subset of the_Edges_of G;
      now
        let e be set;
        assume e in EXV2;
        then e DSJoins {x},V2,G by GLIB_000:def 33;
        then
A124:   e in the_Edges_of G & TG.e in V2 &
        SG.e in {x} by GLIB_000:def 18;
        then not TG.e in {x} by A43,TARSKI:def 1;
        then TG.e in VG \ {x} by A124,XBOOLE_0:def 5;
        then e DSJoins {x},VG\{x}, G by A124,GLIB_000:def 18;
        hence e in EXXe by GLIB_000:def 33;
      end;
      then
A125: EXV2 c= EXXe by TARSKI:def 3;
A126: dom (EL|EXXe) = EXXe & dom (EL|EXV2) = EXV2 &
      dom (EL|EXV1cb) = EXXe \ EXV2 by PARTFUN1:def 4;
      then
A127: dom (EL|EXV2 +* EL|(EXXe \ EXV2)) = EXV2 \/ (EXXe \ EXV2)
      by FUNCT_4:def 1
        .= EXV2 \/ EXXe by XBOOLE_1:39
        .= EXXe by A125,XBOOLE_1:12;
      now
        let e be set;
        assume
A128:   e in dom (EL|EXXe);
        then
A129:   e in EXXe by PARTFUN1:def 4;
        now per cases;
          suppose
A130:       e in EXV2;
            then not e in EXV1cb by XBOOLE_0:def 5;
            hence (EL|EXV2 +* EL|EXV1cb).e=(EL|EXV2).e by A126,FUNCT_4:12
              .=EL.e by A130,FUNCT_1:72;
          end;
          suppose not e in EXV2;
            then
A131:       e in EXV1cb by A129,XBOOLE_0:def 5;
            hence (EL|EXV2 +* EL|EXV1cb).e = (EL|EXV1cb).e by A126,FUNCT_4:14
              .= EL.e by A131,FUNCT_1:72;
          end;
        end;
        hence (EL|EXXe).e = (EL|EXV2 +* EL|EXV1cb).e by A126,A128,FUNCT_1:72;
      end;
      then
A132: Sum (EL|EXV2) + Sum (EL|EXV1c) = Sum (EL|EXXe)
        by A123,A126,A127,FUNCT_1:9,GLIB_004:3;
      reconsider x as Vertex of G by A42;
      x.edgesIn() = G.edgesDBetween(VG,{x}) &
      x.edgesOut() = G.edgesDBetween({x},VG) by GLIB_000:42;
      then
A133: Sum (EL|G.edgesDBetween(VG,{x}))= Sum (EL|G.edgesDBetween({x } ,VG) )
      by A1,A40,A43,A47,Def7;
      now
        let e be set;
        hereby
          assume e in G.edgesDBetween(VG,{x}) \ G.edgesDBetween({x},{x});
          then e in G.edgesDBetween(VG,{x}) &
          not e in G.edgesDBetween({x},{x}) by XBOOLE_0:def 5;
          then
A134:     e DSJoins VG,{x},G & not e DSJoins {x},{x},G by GLIB_000:def 33;
          then
A135:     e in the_Edges_of G & SG.e in VG &
          TG.e in {x} by GLIB_000:def 18;
          then not SG.e in {x} by A134,GLIB_000:def 18;
          then SG.e in VG\{x} by A135,XBOOLE_0:def 5;
          then e DSJoins VG\{x},{x},G by A135,GLIB_000:def 18;
          hence e in EXXf by GLIB_000:def 33;
        end;
        assume e in EXXf;
        then e DSJoins VG \{x}, {x}, G by GLIB_000:def 33;
        then
A136:   e in the_Edges_of G & SG.e in VG \ {x} &
        TG.e in {x} by GLIB_000:def 18;
        then SG.e in VG & not SG.e in {x} by XBOOLE_0:def 5;
        then not e DSJoins {x},{x},G by GLIB_000:def 18;
        then
A137:   not e in G.edgesDBetween({x},{x}) by GLIB_000:def 33;
        e DSJoins VG,{x},G by A136,GLIB_000:def 18;
        then e in G.edgesDBetween(VG,{x}) by GLIB_000:def 33;
        hence e in G.edgesDBetween(VG,{x}) \ G.edgesDBetween({x},{x})
        by A137,XBOOLE_0:def 5;
      end;
      then
A138: G.edgesDBetween(VG,{x}) \ G.edgesDBetween({x},{x}) = EXXf by TARSKI:2;
      reconsider EXXfb = G.edgesDBetween(VG,{x})\G.edgesDBetween({x},{x})
      as Subset of the_Edges_of G;
A139: dom (EL|G.edgesDBetween(VG,{x})) = G.edgesDBetween(VG,{x}) &
      dom (EL|G.edgesDBetween({x},{x})) = G.edgesDBetween({x},{x}) &
      dom (EL|EXXfb) = EXXfb by PARTFUN1:def 4;
      then
A140: dom (EL|G.edgesDBetween({x},{x}) +* EL|EXXfb)
      = G.edgesDBetween({x},{x}) \/ EXXfb by FUNCT_4:def 1
        .= G.edgesDBetween({x},{x}) \/ G.edgesDBetween(VG,{x}) by XBOOLE_1:39
        .= G.edgesDBetween(VG,{x}) by GLIB_000:41,XBOOLE_1:12;
      now
        let e be set;
        assume e in dom (EL|G.edgesDBetween(VG,{x}));
        then
A141:   e in G.edgesDBetween(VG,{x}) by PARTFUN1:def 4;
        now per cases;
          suppose
A142:       e in G.edgesDBetween({x},{x});
            then not e in EXXfb by XBOOLE_0:def 5;
            hence (EL|G.edgesDBetween({x},{x}) +* EL|EXXfb).e
            = (EL|G.edgesDBetween({x},{x})).e by A139,FUNCT_4:12
              .= EL.e by A142,FUNCT_1:72;
          end;
          suppose not e in G.edgesDBetween({x},{x});
            then
A143:       e in EXXfb by A141,XBOOLE_0:def 5;
            hence (EL|G.edgesDBetween({x},{x}) +* EL|EXXfb).e
            = (EL|EXXfb).e by A139,FUNCT_4:14
              .= EL.e by A143,FUNCT_1:72;
          end;
        end;
        hence (EL|G.edgesDBetween(VG,{x})).e =
        (EL|G.edgesDBetween({x},{x}) +* EL|EXXfb).e by A141,FUNCT_1:72;
      end;
      then
A144: Sum (EL|G.edgesDBetween(VG,{x})) =
      Sum (EL|EXXf) + Sum (EL|G.edgesDBetween({x},{x}))
        by A138,A139,A140,FUNCT_1:9,GLIB_004:3;
      now
        let e be set;
        hereby
          assume e in G.edgesDBetween({x},VG) \ G.edgesDBetween({x},{x});
          then e in G.edgesDBetween({x},VG) &
          not e in G.edgesDBetween({x},{x}) by XBOOLE_0:def 5;
          then
A145:     e DSJoins {x},VG,G & not e DSJoins {x},{x},G by GLIB_000:def 33;
          then
A146:     e in the_Edges_of G & TG.e in VG &
          SG.e in {x} by GLIB_000:def 18;
          then not TG.e in {x} by A145,GLIB_000:def 18;
          then TG.e in VG\{x} by A146,XBOOLE_0:def 5;
          then e DSJoins {x},VG\{x},G by A146,GLIB_000:def 18;
          hence e in EXXe by GLIB_000:def 33;
        end;
        assume e in EXXe;
        then e DSJoins {x}, VG \{x}, G by GLIB_000:def 33;
        then
A147:   e in the_Edges_of G & TG.e in VG \ {x} &
        SG.e in {x} by GLIB_000:def 18;
        then TG.e in VG & not TG.e in {x} by XBOOLE_0:def 5;
        then not e DSJoins {x},{x},G by GLIB_000:def 18;
        then
A148:   not e in G.edgesDBetween({x},{x}) by GLIB_000:def 33;
        e DSJoins {x},VG,G by A147,GLIB_000:def 18;
        then e in G.edgesDBetween({x},VG) by GLIB_000:def 33;
        hence e in G.edgesDBetween({x},VG) \ G.edgesDBetween({x},{x})
        by A148,XBOOLE_0:def 5;
      end;
      then
A149: G.edgesDBetween({x},VG) \ G.edgesDBetween({x},{x}) = EXXe by TARSKI:2;
      reconsider EXXeb = G.edgesDBetween({x},VG)\G.edgesDBetween({x},{x})
      as Subset of the_Edges_of G;
A150: dom (EL|G.edgesDBetween({x},VG)) = G.edgesDBetween({x},VG) &
      dom (EL|EXXeb) = EXXeb by PARTFUN1:def 4;
      then
A151: dom (EL|G.edgesDBetween({x},{x}) +* EL|EXXeb)
      = G.edgesDBetween({x},{x}) \/ EXXeb by A139,FUNCT_4:def 1
     .= G.edgesDBetween({x},{x}) \/ G.edgesDBetween({x},VG) by XBOOLE_1:39
     .= G.edgesDBetween({x},VG) by GLIB_000:41,XBOOLE_1:12;
      now
        let e be set;
        assume e in dom (EL|G.edgesDBetween({x},VG));
        then
A152:   e in G.edgesDBetween({x},VG) by PARTFUN1:def 4;
        now per cases;
          suppose
A153:       e in G.edgesDBetween({x},{x});
            then not e in EXXeb by XBOOLE_0:def 5;
            hence (EL|G.edgesDBetween({x},{x}) +* EL|EXXeb).e
            = (EL|G.edgesDBetween({x},{x})).e by A150,FUNCT_4:12
              .= EL.e by A153,FUNCT_1:72;
          end;
          suppose not e in G.edgesDBetween({x},{x});
            then
A154:       e in EXXeb by A152,XBOOLE_0:def 5;
            hence (EL|G.edgesDBetween({x},{x}) +* EL|EXXeb).e
            = (EL|EXXeb).e by A150,FUNCT_4:14
              .= EL.e by A154,FUNCT_1:72;
          end;
        end;
        hence (EL|G.edgesDBetween({x},VG)).e =
        (EL|G.edgesDBetween({x},{x}) +* EL|EXXeb).e by A152,FUNCT_1:72;
      end;
      then Sum (EL|G.edgesDBetween({x},VG)) =
      Sum (EL|EXXe) + Sum (EL|G.edgesDBetween({x},{x}))
        by A149,A150,A151,FUNCT_1:9,GLIB_004:3;
      hence EL.flow(source,sink) = Sum(EL | G.edgesDBetween(V2, VG \ V2)) -
      Sum(EL | G.edgesDBetween(VG \ V2, V2)) by A48,A59,A71,A76,A89,A95,A100
,A116,A132,A133,A144;
    end;
    hence P[n+1];
  end;
A155: for n being non empty Nat holds P[n] from NAT_1:sch 10(A37,A38);
  set n = card (VG \ V);
  now
    assume n = 0; then
A156: VG \ V = {};
    sink is Vertex of G by A1,Def7;
    hence contradiction by A1,A156,XBOOLE_0:def 5;
  end;
  hence thesis by A1,A155;
end;

theorem Th12: ::tFLOW02
for G being finite real-weighted WGraph, EL being FF:ELabeling of G,
    source,sink being set, V being Subset of the_Vertices_of G
 st EL has_valid_flow_from source,sink & source in V & not sink in V
  holds
   EL.flow(source,sink) <=
     Sum ((the_Weight_of G) | G.edgesDBetween(V,the_Vertices_of G \ V))
proof
  let G be finite real-weighted WGraph, EL being FF:ELabeling of G,
      source,sink be set, V be Subset of the_Vertices_of G;
  assume
A1: EL has_valid_flow_from source,sink & source in V & not sink in V;
  set E1 = EL | G.edgesDBetween(V, the_Vertices_of G \ V);
  set E2 = EL | G.edgesDBetween(the_Vertices_of G \ V, V);
  set W1 = (the_Weight_of G) | G.edgesDBetween(V, the_Vertices_of G \ V);
  set B1 = EmptyBag G.edgesDBetween(the_Vertices_of G \ V, V);
A2: EL.flow(source,sink) = Sum E1 - Sum E2 by A1,Th11;
  now
    let e be set;
    assume
A3: e in G.edgesDBetween(V, the_Vertices_of G\V);
    then E1.e = EL.e & W1.e = (the_Weight_of G).e by FUNCT_1:72;
    hence E1.e <= W1.e by A1,A3,Def7;
  end;
  then
A4: Sum E1 <= Sum W1 by GLIB_004:5;
A5: Sum B1 = 0 by UPROOTS:13;
  now
    let e be set;
    assume
A6: e in G.edgesDBetween(the_Vertices_of G \ V, V);
    B1 = G.edgesDBetween(the_Vertices_of G \ V, V)-->0 by POLYNOM1:def 15;
    hence B1.e <= E2.e by A6,FUNCOP_1:13;
  end;
  then 0 <= Sum E2 by A5,GLIB_004:5;
  then
A8: Sum W1 - Sum E2 <= Sum W1 - 0 by XREAL_1:15;
  Sum E1 - Sum E2 <= Sum W1 - Sum E2 by A4,XREAL_1:11;
  hence thesis by A2,A8,XXREAL_0:2;
end;

theorem Th14: ::tWTOLERANCE01
for G being finite natural-weighted WGraph, EL being FF:ELabeling of G,
    W being Walk of G
 st W is non trivial & W is_augmenting_wrt EL holds 0 < W.tolerance(EL)
proof
  let G be finite natural-weighted WGraph, EL being FF:ELabeling of G,
      W be Walk of G such that
A1: W is non trivial and
A1a: W is_augmenting_wrt EL;
  set T = W.tolerance(EL);
  T in rng (W.flowSeq(EL)) &
     for k being real number st k in rng (W.flowSeq(EL)) holds T <= k
            by A1,A1a,Def19;
  then consider n being Nat such that
A2: n in dom (W.flowSeq(EL)) & T = (W.flowSeq(EL)).n by FINSEQ_2:11;
  reconsider n as Element of NAT by ORDINAL1:def 13;
  dom (W.flowSeq(EL)) = dom W.edgeSeq() by A1a,Def18;
  then 2*n in dom W by A2,GLIB_001:79;
  then
A3: 1 <= 2*n & 2*n <= len W by FINSEQ_3:27;
  then reconsider 2n1 = 2*n-1 as odd Element of NAT by INT_1:18;
A4: 2*n-1 < len W - 0 by A3,XREAL_1:17;
  set v1 = W.(2n1), e = W.(2*n), v2 = W.(2*n+1);
A5: 2*n-1 + 1 = 2*n & 2*n-1 + 2 = 2*n+1;
  now per cases;
    suppose
A6:   e DJoins v1,v2,G;
      then
A7:   T = (the_Weight_of G).e - EL.e by A1a,A2,Def18;
      EL.e < (the_Weight_of G).e by A1a,A4,A5,A6,Def12;
      then EL.e - EL.e < T by A7,XREAL_1:16;
      hence thesis;
    end;
    suppose
A8:   not e DJoins v1,v2,G;
      then T = EL.e by A1a,A2,Def18;
      hence thesis by A1a,A4,A5,A8,Def12;
    end;
  end;
  hence thesis;
end;

theorem Th15: ::tFLOWAUG02
for G being finite natural-weighted WGraph, EL being FF:ELabeling of G,
    source,sink being set, P being Path of G
 st source <> sink & EL has_valid_flow_from source,sink &
    P is_Walk_from source,sink & P is_augmenting_wrt EL
   holds FF:PushFlow(EL,P) has_valid_flow_from source,sink
proof
  let G be finite natural-weighted WGraph, EL being FF:ELabeling of G,
      source,sink be set, P be Path of G;
  assume that
A1: source <> sink and
A1a: EL has_valid_flow_from source,sink and
A1b: P is_Walk_from source,sink and
A1c: P is_augmenting_wrt EL;
    set EL2 = FF:PushFlow(EL,P);
  now
    thus source is Vertex of G & sink is Vertex of G by A1a,Def7;
    now
      let e be set;
      assume
A4:   e in the_Edges_of G;
      then
A5:   0 <= EL.e & EL.e <= (the_Weight_of G).e by A1a,Def7;
      now per cases;
        suppose not e in P.edges();
          hence 0 <= EL2.e & EL2.e <= (the_Weight_of G).e by A1c,A4,A5,Def20;
        end;
        suppose e in P.edges();
          then consider n being odd Element of NAT such that
A6:       n < len P & P.(n+1) = e by GLIB_001:101;
A7:       e Joins P.n,P.(n+2),G by A6,GLIB_001:def 3;
          P.first() = source & P.last() = sink by A1b,GLIB_001:def 23;
          then
A8:       P is non trivial by A1,GLIB_001:128;
A10:      now
            assume e DJoins P.n,P.(n+2),G & e DJoins P.(n+2),P.n,G;
            then
A11:        (the_Source_of G).e = P.n & (the_Source_of G).e = P.(n+2)
            by GLIB_000:def 16;
A12:        n + 0 < n+2 by XREAL_1:10;
            n+2 <= len P by A6,GLIB_001:1;
            then n = 1 & n+2 = len P by A11,A12,GLIB_001:def 28;
            then P.n = source & P.(n+2) = sink by A1b,GLIB_001:18;
            hence contradiction by A1,A11;
          end;
          set PFS = P.flowSeq(EL), n1div2 = (n+1) div 2;
          1 <= n+1 & n+1 <= len P by A6,NAT_1:11,13;
          then n1div2 in dom P.edgeSeq() & P.(n+1) = P.edgeSeq().n1div2
          by GLIB_001:78;
          then
A13:      n1div2 in dom PFS by A1c,Def18;
          2 divides n+1 by PEPIN:22;
          then
A14:      2 * n1div2 = n+1 by NAT_D:3;
          then
A15:      2 * n1div2 - 1 = n;
A16:      2 * n1div2 + 1 = n + 2 by A14;
          now per cases by A7,GLIB_000:19;
            suppose
A17:          e DJoins P.n,P.(n+2),G;
              then
A18:          EL.e + P.tolerance(EL) = EL2.e by A1c,A6,Def20;
              thus 0 <= EL2.e;
              PFS.n1div2 = (the_Weight_of G).e - EL.e
              by A1c,A6,A13,A15,A16,A17,Def18;
              then (the_Weight_of G).e - EL.e in rng PFS by A13,FUNCT_1:def 5;
              then P.tolerance(EL) <= (the_Weight_of G).e-EL.e by A1c,A8,Def19;
              then EL2.e <= (the_Weight_of G).e - EL.e + EL.e
              by A18,XREAL_1:9;
              hence EL2.e <= (the_Weight_of G).e;
            end;
            suppose
              e DJoins P.(n+2),P.n,G;
              then
A20:          EL2.e = EL.e - P.tolerance(EL) by A1c,A6,A10,Def20;
              thus 0 <= EL2.e;
              EL2.e <= EL.e - 0 by A20,XREAL_1:15;
              hence EL2.e <= (the_Weight_of G).e by A5,XXREAL_0:2;
            end;
          end;
          hence 0 <= EL2.e & EL2.e <= (the_Weight_of G).e;
        end;
      end;
      hence 0 <= EL2.e & EL2.e <= (the_Weight_of G).e;
    end;
    hence for e being set st e in the_Edges_of G holds
    0 <= EL2.e & EL2.e <= (the_Weight_of G).e;
    let v be Vertex of G;
    assume
A21: v <> source & v <> sink;
A23: Sum (EL | v.edgesIn()) = Sum (EL | v.edgesOut()) by A1a,A21,Def7;
    now per cases;
      suppose v in P.vertices();
        then consider n being odd Element of NAT such that
A24:    n <= len P & P.n = v by GLIB_001:88;
A25:    now
          assume n = len P;
          then v = P.last() by A24,GLIB_001:def 7
            .= sink by A1b,GLIB_001:def 23;
          hence contradiction by A21;
        end;
        then
A26:    n < len P by A24,XXREAL_0:1;
A27:    1 <= n by HEYTING3:1;
A28:    now
          assume n = 1;
          then v = P.first() by A24,GLIB_001:def 6
            .= source by A1b,GLIB_001:def 23;
          hence contradiction by A21;
        end;
        then 1 < n by A27,XXREAL_0:1;
        then 1+1 <= n by NAT_1:13;
        then reconsider n2 = n-2*1 as odd Element of NAT by INT_1:18;
        set e1 = P.(n2+1), e2 = P.(n+1), T = P.tolerance(EL);
A29:    n2 < len P - 0 by A24,XREAL_1:17;
        then
A30:    e1 Joins P.n2,P.(n2+2),G by GLIB_001:def 3;
A31:    e2 Joins v,P.(n+2),G by A24,A26,GLIB_001:def 3;
A32:    P.(n2+2) = v by A24;
A33:    now
          assume
A34:      P.n2 = v;
          n2 < n - 0 by XREAL_1:17;
          hence contradiction by A24,A25,A34,GLIB_001:def 28;
        end;
A35:    now
          assume
A36:      v = P.(n+2);
A37:      n+0 < n+2 by XREAL_1:10;
          n+2 <= len P by A26,GLIB_001:1;
          hence contradiction by A24,A28,A36,A37,GLIB_001:def 28;
        end;
A38:    now
          assume
A39:      e1 DJoins P.n2,v,G & e1 DJoins v,P.n2,G;
          then P.n2 = (the_Source_of G).e1 by GLIB_000:def 16
            .= v by A39,GLIB_000:def 16;
          hence contradiction by A33;
        end;
A40:    now
          assume
A41:      e2 DJoins v,P.(n+2),G & e2 DJoins P.(n+2),v,G;
          then
A42:      P.n = (the_Source_of G).e2 by A24,GLIB_000:def 16
            .= P.(n+2) by A41,GLIB_000:def 16;
A43:      n + 0 < n+2 by XREAL_1:10;
          n+2 <= len P by A26,GLIB_001:1;
          hence contradiction by A28,A42,A43,GLIB_001:def 28;
        end;
        n2 < n - 0 by XREAL_1:17;
        then 1 <= n2+1 & n2+1 < n+1 & n+1 <= len P
        by A26,NAT_1:11,13,XREAL_1:10;
        then
A44:    e1 <> e2 by GLIB_001:139;
A45:    now
          let e be set;
          assume
A46:      (e in v.edgesIn() or e in v.edgesOut()) & e <> e1 & e <> e2;
          now
            assume e in P.edges();
            then consider v1,v2 being
            Vertex of G, m being odd Element of NAT such that
A47:        m+2 <= len P & v1 = P.m & e = P.(m+1) & v2 = P.(m+2) &
            e Joins v1,v2,G by GLIB_001:104;
A48:        m+2-2 < len P - 0 by A47,XREAL_1:17;
A49:        now per cases by A46;
              suppose e in v.edgesIn();
                then (the_Target_of G).e = v by GLIB_000:59;
                hence v1 = v or v2 = v by A47,GLIB_000:def 15;
              end;
              suppose e in v.edgesOut();
                then (the_Source_of G).e = v by GLIB_000:61;
                hence v1 = v or v2 = v by A47,GLIB_000:def 15;
              end;
            end;
            now per cases by A49;
              suppose
A50:            v1 = v;
                now per cases by XXREAL_0:1;
                  suppose m < n;
                    hence contradiction by A24,A25,A47,A50,GLIB_001:def 28;
                  end;
                  suppose m = n;
                    hence contradiction by A46,A47;
                  end;
                  suppose n < m;
                    hence contradiction by A24,A47,A48,A50,GLIB_001:def 28;
                  end;
                end;
                hence contradiction;
              end;
              suppose
A51:            v2 = v;
                now per cases by XXREAL_0:1;
                  suppose m+2 < n;
                    hence contradiction by A24,A25,A47,A51,GLIB_001:def 28;
                  end;
                  suppose m+2 = n;
                    hence contradiction by A46,A47;
                  end;
                  suppose n < m+2;
                    hence contradiction by A24,A28,A47,A51,GLIB_001:def 28;
                  end;
                end;
                hence contradiction;
              end;
            end;
            hence contradiction;
          end;
          hence not e in P.edges();
        end;
        now per cases by A24,A30,A31,GLIB_000:19;
          suppose
A52:        e1 DJoins P.n2,v,G & e2 DJoins v,P.(n+2),G;
            set XIN = (EL|v.edgesIn()) +* (e1.-->(EL.e1 + T));
            set XOUT= (EL|v.edgesOut())+* (e2.-->(EL.e2 + T));
A53:        e1 in v.edgesIn() & e2 in v.edgesOut() by A52,GLIB_000:60,62;
A54:        dom (e1.-->(EL.e1+T)) = {e1} by FUNCOP_1:19;
            then
A55:        dom XIN = dom (EL|v.edgesIn()) \/ {e1} by FUNCT_4:def 1
              .= v.edgesIn() \/ {e1} by PARTFUN1:def 4
              .= v.edgesIn() by A53,ZFMISC_1:46;
            then reconsider XIN as Rbag of v.edgesIn() by PARTFUN1:def 4
,RELAT_1:def 18;
A56:        dom (e2.-->(EL.e2+T)) = {e2} by FUNCOP_1:19;
            then
A57:        dom XOUT = dom (EL|v.edgesOut())\/{e2} by FUNCT_4:def 1
              .= v.edgesOut() \/ {e2} by PARTFUN1:def 4
              .= v.edgesOut() by A53,ZFMISC_1:46;
            then reconsider XOUT as Rbag of v.edgesOut() by PARTFUN1:def 4
,RELAT_1:def 18;
A58:        dom (EL2|v.edgesIn()) = v.edgesIn() by PARTFUN1:def 4
;
            now
              let e be set;
              assume e in dom (EL2|v.edgesIn());
              then
A59:          e in v.edgesIn() by PARTFUN1:def 4;
              then
A60:          (the_Target_of G).e = v by GLIB_000:59;
              now per cases;
                suppose
A61:              e = e1;
                  then e in dom (e1.-->(EL.e1+T)) by A54,TARSKI:def 1;
                  hence XIN.e = (e1.-->(EL.e1+T)).e1 by A61,FUNCT_4:14
                    .= EL.e1 + T by FUNCOP_1:87
                    .= EL2.e by A1c,A29,A32,A52,A61,Def20;
                end;
                suppose
A62:              e <> e1;
                  then not e in dom (e1.-->(EL.e1+T)) by A54,TARSKI:def 1;
                  then
A63:              XIN.e = (EL|v.edgesIn()).e by FUNCT_4:12
                    .= EL.e by A59,FUNCT_1:72;
                  now
                    assume e in P.edges();
                    then consider v1,v2 being
                    Vertex of G,m being odd Element of NAT such that
A64:                m+2 <= len P & v1 = P.m & e = P.(m+1) & v2=P.(m+2)
                    & e Joins v1,v2,G by GLIB_001:104;
A65:                m+2-2 < len P - 0 by A64,XREAL_1:17;
                    now per cases by A60,A64,GLIB_000:def 15;
                      suppose
A66:                    v = v1;
                        now per cases by XXREAL_0:1;
                          suppose m < n;
                            hence contradiction by A24,A25,A64,A66,
GLIB_001:def 28;
                          end;
                          suppose m = n;
                            then
A67:                        P.(n+2) = P.n by A24,A52,A60,A64,GLIB_000:def 16;
A68:                        n+2-2 < n+2-0 by XREAL_1:17;
                            n+2 <= len P by A26,GLIB_001:1;
                            hence contradiction by A28,A67,A68,GLIB_001:def 28;
                          end;
                          suppose n < m;
                            hence contradiction
                            by A24,A64,A65,A66,GLIB_001:def 28;
                          end;
                        end;
                        hence contradiction;
                      end;
                      suppose
A69:                    v = v2;
                        now per cases by XXREAL_0:1;
                          suppose m+2 < n;
                            hence contradiction by A24,A25,A64,A69,
GLIB_001:def 28;
                          end;
                          suppose m+2 = n;
                            hence contradiction by A62,A64;
                          end;
                          suppose n < m+2;
                            hence contradiction by A24,A28,A64,A69,
GLIB_001:def 28;
                          end;
                        end;
                        hence contradiction;
                      end;
                    end;
                    hence contradiction;
                  end;
                  hence EL2.e = XIN.e by A1c,A59,A63,Def20;
                end;
              end;
              hence (EL2|v.edgesIn()).e = XIN.e by A59,FUNCT_1:72;
            end;
            then
A70:        Sum (EL2|v.edgesIn())=Sum XIN by A55,A58,FUNCT_1:9;
A71:        dom (EL2|v.edgesOut()) = v.edgesOut() by PARTFUN1:def 4
;
A72:        now
              let e be set;
              assume e in dom (EL2|v.edgesOut());
              then
A73:          e in v.edgesOut() by PARTFUN1:def 4;
              then
A74:          (the_Source_of G).e = v by GLIB_000:61;
              now per cases;
                suppose
A75:              e = e2;
                  then e in dom (e2.-->(EL.e2+T)) by A56,TARSKI:def 1;
                  hence XOUT.e = (e2.-->(EL.e2+T)).e2 by A75,FUNCT_4:14
                    .= EL.e2 + T by FUNCOP_1:87
                    .= EL2.e by A1c,A24,A26,A52,A75,Def20;
                end;
                suppose
A76:              e <> e2;
                  then not e in dom (e2.-->(EL.e2+T)) by A56,TARSKI:def 1;
                  then
A77:              XOUT.e = (EL|v.edgesOut()).e by FUNCT_4:12
                    .= EL.e by A73,FUNCT_1:72;
                  now
                    assume e in P.edges();
                    then consider v1,v2 being
                    Vertex of G,m being odd Element of NAT such that
A78:                m+2 <= len P & v1 = P.m & e = P.(m+1) & v2=P.(m+2)
                    & e Joins v1,v2,G by GLIB_001:104;
A79:                m+2-2 < len P - 0 by A78,XREAL_1:17;
                    now per cases by A74,A78,GLIB_000:def 15;
                      suppose
A80:                    v = v1;
                        now per cases by XXREAL_0:1;
                          suppose m < n;
                            hence contradiction by A24,A25,A78,A80,
GLIB_001:def 28;
                          end;
                          suppose m = n;
                            hence contradiction by A76,A78;
                          end;
                          suppose n < m;
                            hence contradiction
                            by A24,A78,A79,A80,GLIB_001:def 28;
                          end;
                        end;
                        hence contradiction;
                      end;
                      suppose
A81:                    v = v2;
                        now per cases by XXREAL_0:1;
                          suppose m+2 < n;
                            hence contradiction by A24,A25,A78,A81,
GLIB_001:def 28;
                          end;
                          suppose m+2 = n;
                            then
A82:                        P.n2 = P.n by A24,A52,A74,A78,GLIB_000:def 16;
                            n2 < n - 0 by XREAL_1:17;
                            hence contradiction
                            by A24,A25,A82,GLIB_001:def 28;
                          end;
                          suppose n < m+2;
                            hence contradiction by A24,A28,A78,A81,
GLIB_001:def 28;
                          end;
                        end;
                        hence contradiction;
                      end;
                    end;
                    hence contradiction;
                  end;
                  hence EL2.e = XOUT.e by A1c,A73,A77,Def20;
                end;
              end;
              hence (EL2|v.edgesOut()).e = XOUT.e by A73,FUNCT_1:72;
            end;
            Sum XIN = Sum (EL|v.edgesIn()) + (T + EL.e1)
            - (EL|v.edgesIn()).e1 by GLIB_004:9
              .= Sum (EL|v.edgesOut()) + T + EL.e1 - EL.e1
            by A23,A53,FUNCT_1:72
              .= Sum (EL|v.edgesOut()) + T + EL.e2 - EL.e2
              .= Sum (EL|v.edgesOut()) + (T + EL.e2)
            - (EL|v.edgesOut()).e2 by A53,FUNCT_1:72
              .= Sum XOUT by GLIB_004:9;
            hence Sum (EL2 | v.edgesIn()) = Sum (EL2 | v.edgesOut())
            by A57,A70,A71,A72,FUNCT_1:9;
          end;
          suppose
A83:        e1 DJoins P.n2,v,G & e2 DJoins P.(n+2),v,G;
            then
A84:        EL2.e1 = EL.e1 + T & EL2.e2 = EL.e2 - T
            by A1c,A26,A29,A32,A40,Def20;
A85:        e1 in v.edgesIn() & e2 in v.edgesIn() by A83,GLIB_000:60;
            set XIN1 = (EL|v.edgesIn())+*(e1.-->(EL.e1+T));
            set XIN2 = XIN1 +* (e2.-->(EL.e2-T));
A86:        dom XIN1 = dom (EL|v.edgesIn()) \/ dom (e1.-->(EL.e1+T))
            by FUNCT_4:def 1
              .= dom (EL|v.edgesIn()) \/ {e1} by FUNCOP_1:19
              .= v.edgesIn() \/ {e1} by PARTFUN1:def 4
              .= v.edgesIn() by A85,ZFMISC_1:46;
            then reconsider XIN1 as Rbag of v.edgesIn() by PARTFUN1:def 4
,RELAT_1:def 18;
A87:        dom XIN2 = dom XIN1 \/ dom (e2.-->(EL.e2-T)) by FUNCT_4:def 1
              .= v.edgesIn() \/ {e2} by A86,FUNCOP_1:19
              .= v.edgesIn() by A85,ZFMISC_1:46;
            then reconsider XIN2 as Rbag of v.edgesIn() by PARTFUN1:def 4
,RELAT_1:def 18;
A88:        dom (EL2|v.edgesIn()) = v.edgesIn() by PARTFUN1:def 4
;
A89:        dom (e1.-->(EL.e1+T)) = {e1} & dom (e2.-->(EL.e2-T)) = {e2}
            by FUNCOP_1:19;
A90:        now
              let e be set;
              assume
A91:          e in dom (EL2|v.edgesIn());
              then
A92:          e in v.edgesIn() by PARTFUN1:def 4;
A93:          (EL2|v.edgesIn()).e = EL2.e by A88,A91,FUNCT_1:72;
              now per cases;
                suppose
A94:              e = e1;
                  then
A95:              not e in dom (e2.-->(EL.e2-T)) &
                  e in dom (e1.-->(EL.e1+T)) by A44,A89,TARSKI:def 1;
                  then XIN2.e = XIN1.e by FUNCT_4:12
                    .= (e1.-->(EL.e1+T)).e by A95,FUNCT_4:14
                    .= EL2.e by A84,A94,FUNCOP_1:87;
                  hence (EL2|v.edgesIn()).e = XIN2.e by A88,A91,FUNCT_1:72;
                end;
                suppose
A96:              e = e2;
                  then e in dom (e2.-->(EL.e2-T)) by A89,TARSKI:def 1;
                  then XIN2.e = (e2.-->(EL.e2-T)).e2 by A96,FUNCT_4:14
                    .= EL2.e by A84,A96,FUNCOP_1:87;
                  hence (EL2|v.edgesIn()).e = XIN2.e by A88,A91,FUNCT_1:72;
                end;
                suppose
A97:              e <> e1 & e <> e2;
                  then
A98:              not e in dom (e2.-->(EL.e2-T)) &
                  not e in dom (e1.-->(EL.e1+T)) by A89,TARSKI:def 1;
                  then
A99:              XIN2.e = XIN1.e by FUNCT_4:12
                    .= (EL|v.edgesIn()).e by A98,FUNCT_4:12
                    .= EL.e by A92,FUNCT_1:72;
                  not e in P.edges() by A45,A92,A97;
                  hence (EL2|v.edgesIn()).e = XIN2.e
                  by A1c,A92,A93,A99,Def20;
                end;
              end;
              hence (EL2|v.edgesIn()).e = XIN2.e;
            end;
            not e2 in dom (e1.-->(EL.e1+T)) by A44,A89,TARSKI:def 1;
            then
A100:       XIN1.e2 = (EL|v.edgesIn()).e2 by FUNCT_4:12
              .= EL.e2 by A85,FUNCT_1:72;
A101:       dom (EL2|v.edgesOut()) = v.edgesOut() &
            dom (EL|v.edgesOut()) = v.edgesOut() by PARTFUN1:def 4
;
            now
              let e be set;
              assume
A102:         e in dom (EL2|v.edgesOut());
              then
A103:         e in v.edgesOut() by PARTFUN1:def 4;
A104:         (EL2|v.edgesOut()).e = EL2.e &
              (EL|v.edgesOut()).e = EL.e by A101,A102,FUNCT_1:72;
A105:         e in the_Edges_of G &
              (the_Source_of G).e = v by A103,GLIB_000:61;
              then
A106:         e <> e1 by A33,A83,GLIB_000:def 16;
              e <> e2 by A35,A83,A105,GLIB_000:def 16;
              then not e in P.edges() by A45,A103,A106;
              hence (EL2|v.edgesOut()).e = (EL|v.edgesOut()).e
              by A1c,A103,A104,Def20;
            end;
            then
A107:       EL2|v.edgesOut() = EL|v.edgesOut() by A101,FUNCT_1:9;
            Sum (EL2|v.edgesIn()) = Sum XIN1 + (EL.e2-T) - EL.e2
                by A100,A87,A88,A90,FUNCT_1:9,GLIB_004:9
              .= Sum XIN1 - (EL.e2 - (EL.e2 - T))
              .= Sum (EL|v.edgesIn())+(EL.e1+T)-(EL|v.edgesIn()).e1-T
            by GLIB_004:9
              .= Sum (EL|v.edgesIn())+T+EL.e1-EL.e1-T
            by A85,FUNCT_1:72
              .= Sum (EL|v.edgesIn());
            hence Sum (EL2|v.edgesIn()) = Sum (EL2|v.edgesOut())
            by A1a,A21,A107,Def7;
          end;
          suppose
A108:       e1 DJoins v,P.n2,G & e2 DJoins v,P.(n+2),G;
            then
A109:       EL2.e1 = EL.e1 - T & EL2.e2 = EL.e2 + T
            by A1c,A26,A29,A32,A38,Def20;
A110:       e1 in v.edgesOut() & e2 in v.edgesOut() by A108,GLIB_000:62;
            set XOUT1 = (EL|v.edgesOut())+*(e1.-->(EL.e1-T));
            set XOUT2 = XOUT1 +* (e2.-->(EL.e2+T));
A111:       dom XOUT1 = dom (EL|v.edgesOut()) \/ dom (e1.-->(EL.e1-T))
            by FUNCT_4:def 1
              .= dom (EL|v.edgesOut()) \/ {e1} by FUNCOP_1:19
              .= v.edgesOut() \/ {e1} by PARTFUN1:def 4
              .= v.edgesOut() by A110,ZFMISC_1:46;
            then reconsider XOUT1 as Rbag of v.edgesOut() by PARTFUN1:def 4
,RELAT_1:def 18;
A112:       dom XOUT2 = dom XOUT1\/dom (e2.-->(EL.e2+T)) by FUNCT_4:def 1
              .= v.edgesOut() \/ {e2} by A111,FUNCOP_1:19
              .= v.edgesOut() by A110,ZFMISC_1:46;
            then reconsider XOUT2 as Rbag of v.edgesOut() by PARTFUN1:def 4
,RELAT_1:def 18;
A113:       dom (EL2|v.edgesOut()) = v.edgesOut() by PARTFUN1:def 4
;
A114:       dom (e1.-->(EL.e1-T)) = {e1} & dom (e2.-->(EL.e2+T)) = {e2}
            by FUNCOP_1:19;
A115:       now
              let e be set;
              assume
A116:         e in dom (EL2|v.edgesOut());
              then
A117:         e in v.edgesOut() by PARTFUN1:def 4;
A118:         (EL2|v.edgesOut()).e = EL2.e by A113,A116,FUNCT_1:72;
              now per cases;
                suppose
A119:             e = e1;
                  then
A120:             not e in dom (e2.-->(EL.e2+T)) &
                  e in dom (e1.-->(EL.e1-T)) by A44,A114,TARSKI:def 1;
                  then XOUT2.e = XOUT1.e by FUNCT_4:12
                    .= (e1.-->(EL.e1-T)).e by A120,FUNCT_4:14
                    .= EL2.e by A109,A119,FUNCOP_1:87;
                  hence (EL2|v.edgesOut()).e=XOUT2.e by A113,A116,FUNCT_1:72;
                end;
                suppose
A121:             e = e2;
                  then e in dom (e2.-->(EL.e2+T)) by A114,TARSKI:def 1;
                  then XOUT2.e = (e2.-->(EL.e2+T)).e by FUNCT_4:14
                    .= EL2.e by A109,A121,FUNCOP_1:87;
                  hence (EL2|v.edgesOut()).e=XOUT2.e by A113,A116,FUNCT_1:72;
                end;
                suppose
A122:             e <> e1 & e <> e2;
                  then
A123:             not e in dom (e2.-->(EL.e2+T)) &
                  not e in dom (e1.-->(EL.e1-T)) by A114,TARSKI:def 1;
                  then
A124:             XOUT2.e = XOUT1.e by FUNCT_4:12
                    .= (EL|v.edgesOut()).e by A123,FUNCT_4:12
                    .= EL.e by A117,FUNCT_1:72;
                  not e in P.edges() by A45,A117,A122;
                  hence (EL2|v.edgesOut()).e = XOUT2.e
                  by A1c,A117,A118,A124,Def20;
                end;
              end;
              hence (EL2|v.edgesOut()).e = XOUT2.e;
            end;
            not e2 in dom (e1.-->(EL.e1-T)) by A44,A114,TARSKI:def 1;
            then
A125:       XOUT1.e2 = (EL|v.edgesOut()).e2 by FUNCT_4:12
              .= EL.e2 by A110,FUNCT_1:72;
A126:       Sum (EL2|v.edgesOut())
              = Sum XOUT1 + (EL.e2+T) - EL.e2
                by A125,A112,A113,A115,FUNCT_1:9,GLIB_004:9
              .= Sum XOUT1 - EL.e2 + EL.e2 + T
              .= Sum (EL|v.edgesOut()) + (EL.e1 - T)
            - (EL|v.edgesOut()).e1 + T by GLIB_004:9
              .= Sum (EL|v.edgesOut()) + EL.e1 - T - EL.e1 + T
            by A110,FUNCT_1:72
              .= Sum (EL|v.edgesOut());
A127:       dom (EL2|v.edgesIn()) = v.edgesIn() &
            dom (EL|v.edgesIn()) = v.edgesIn() by PARTFUN1:def 4;
            now
              let e be set;
              assume
A128:         e in dom (EL2|v.edgesIn());
              then
A129:         e in v.edgesIn() by PARTFUN1:def 4;
A130:         (EL2|v.edgesIn()).e = EL2.e &
              (EL|v.edgesIn()).e = EL.e by A127,A128,FUNCT_1:72;
A131:         e in the_Edges_of G &
              (the_Target_of G).e = v by A129,GLIB_000:59;
              then
A132:         e <> e1 by A33,A108,GLIB_000:def 16;
              e <> e2 by A35,A108,A131,GLIB_000:def 16;
              then not e in P.edges() by A45,A129,A132;
              hence (EL2|v.edgesIn()).e = (EL|v.edgesIn()).e
              by A1c,A129,A130,Def20;
            end;
            hence Sum (EL2|v.edgesIn()) = Sum (EL2|v.edgesOut())
               by A23,A126,A127,FUNCT_1:9;
          end;
          suppose
A133:       e1 DJoins v,P.n2,G & e2 DJoins P.(n+2),v,G;
            then
A134:       EL2.e1 = EL.e1 - T & EL2.e2 = EL.e2 - T
            by A1c,A26,A29,A32,A38,A40,Def20;
A135:       e1 in v.edgesOut() & e2 in v.edgesIn() by A133,GLIB_000:60,62;
            set XIN = (EL|v.edgesIn())+*(e2.-->(EL.e2-T));
            set XOUT= (EL|v.edgesOut())+*(e1.-->(EL.e1-T));
A136:       dom (e1.-->(EL.e1-T)) = {e1} &
            dom (e2.-->(EL.e2-T)) = {e2} by FUNCOP_1:19;
            then
A137:       dom XIN = dom (EL|v.edgesIn()) \/ {e2} by FUNCT_4:def 1
              .= v.edgesIn() \/ {e2} by PARTFUN1:def 4
              .= v.edgesIn() by A135,ZFMISC_1:46;
            then reconsider XIN as Rbag of v.edgesIn() by PARTFUN1:def 4
,RELAT_1:def 18;
A138:       dom XOUT = dom (EL|v.edgesOut())\/{e1} by A136,FUNCT_4:def 1
              .= v.edgesOut() \/ {e1} by PARTFUN1:def 4
              .= v.edgesOut() by A135,ZFMISC_1:46;
            then reconsider XOUT as Rbag of v.edgesOut() by PARTFUN1:def 4
,RELAT_1:def 18;
A139:       dom (EL2|v.edgesIn()) = v.edgesIn() &
            dom (EL2|v.edgesOut()) = v.edgesOut() by PARTFUN1:def 4
;
            now
              let e be set;
              assume e in dom (EL2|v.edgesIn());
              then
A140:         e in v.edgesIn() by PARTFUN1:def 4;
              then
A141:         (the_Target_of G).e = v by GLIB_000:59;
              now per cases;
                suppose
A142:             e = e2;
                  then e in dom (e2.-->(EL.e2-T)) by A136,TARSKI:def 1;
                  hence XIN.e = (e2.-->(EL.e2-T)).e2 by A142,FUNCT_4:14
                    .= EL2.e by A134,A142,FUNCOP_1:87;
                end;
                suppose
A143:             e <> e2;
                  then not e in dom (e2.-->(EL.e2-T)) by A136,TARSKI:def 1;
                  then
A144:             XIN.e = (EL|v.edgesIn()).e by FUNCT_4:12
                    .= EL.e by A140,FUNCT_1:72;
                  e <> e1 by A33,A133,A141,GLIB_000:def 16;
                  then not e in P.edges() by A45,A140,A143;
                  hence EL2.e = XIN.e by A1c,A140,A144,Def20;
                end;
              end;
              hence XIN.e = (EL2|v.edgesIn()).e by A140,FUNCT_1:72;
            end;
            then
A145:       Sum (EL2|v.edgesIn())
               = Sum (EL|v.edgesIn()) + (EL.e2-T) - (EL|v.edgesIn()).e2
            by A137,A139,FUNCT_1:9,GLIB_004:9
              .= Sum (EL|v.edgesIn()) + EL.e2 - T - EL.e2
            by A135,FUNCT_1:72
              .= Sum (EL|v.edgesIn()) - T;
            now
              let e be set;
              assume e in dom (EL2|v.edgesOut());
              then
A146:         e in v.edgesOut() by PARTFUN1:def 4;
              then
A147:         (the_Source_of G).e = v by GLIB_000:61;
              now per cases;
                suppose
A148:             e = e1;
                  then e in dom (e1.-->(EL.e1-T)) by A136,TARSKI:def 1;
                  hence XOUT.e = (e1.-->(EL.e1-T)).e1 by A148,FUNCT_4:14
                    .= EL2.e by A134,A148,FUNCOP_1:87;
                end;
                suppose
A149:             e <> e1;
                  then not e in dom (e1.-->(EL.e1-T)) by A136,TARSKI:def 1;
                  then
A150:             XOUT.e = (EL|v.edgesOut()).e by FUNCT_4:12
                    .= EL.e by A146,FUNCT_1:72;
                  e <> e2 by A35,A133,A147,GLIB_000:def 16;
                  then not e in P.edges() by A45,A146,A149;
                  hence EL2.e = XOUT.e by A1c,A146,A150,Def20;
                end;
              end;
              hence XOUT.e = (EL2|v.edgesOut()).e by A146,FUNCT_1:72;
            end;
            then Sum (EL2|v.edgesOut())
               = Sum (EL|v.edgesOut()) + (EL.e1-T)-(EL|v.edgesOut()).e1
            by A138,A139,FUNCT_1:9,GLIB_004:9
              .= Sum (EL|v.edgesOut()) + EL.e1 - T - EL.e1
            by A135,FUNCT_1:72
              .= Sum (EL|v.edgesIn()) - T by A23;
            hence Sum (EL2 | v.edgesIn()) = Sum (EL2 | v.edgesOut()) by A145;
          end;
        end;
        hence Sum (EL2 | v.edgesIn()) = Sum (EL2 | v.edgesOut());
      end;
      suppose
A151:   not v in P.vertices();
A152:   dom (EL|v.edgesIn()) = v.edgesIn() by PARTFUN1:def 4;
        then
A153:   dom (EL|v.edgesIn()) = dom (EL2|v.edgesIn()) by PARTFUN1:def 4
;
A158a:   now
          let e be set;
          assume
A154:     e in dom (EL|v.edgesIn());
          then
A155:     (EL|v.edgesIn()).e = EL.e &
          (EL2|v.edgesIn()).e = EL2.e by A152,FUNCT_1:72;
          now
            assume
A156:       e in P.edges();
            consider x being set such that
A157:       e DJoins x,v,G by A152,A154,GLIB_000:60;
            e Joins x,v,G by A157,GLIB_000:19;
            hence contradiction by A151,A156,GLIB_001:106;
          end;
          hence (EL|v.edgesIn()).e = (EL2|v.edgesIn()).e
          by A1c,A152,A154,A155,Def20;
        end;
A159:   dom (EL|v.edgesOut()) = v.edgesOut() &
        dom (EL2|v.edgesOut()) = v.edgesOut() by PARTFUN1:def 4;
        now
          let e be set;
          assume
A160:     e in dom (EL|v.edgesOut());
          then
A161:     e in v.edgesOut() by PARTFUN1:def 4;
A162:     (EL|v.edgesOut()).e = EL.e &
          (EL2|v.edgesOut()).e = EL2.e by A159,A160,FUNCT_1:72;
          now
            assume
A163:       e in P.edges();
            consider x being set such that
A164:       e DJoins v,x,G by A161,GLIB_000:62;
            e Joins v,x,G by A164,GLIB_000:19;
            hence contradiction by A151,A163,GLIB_001:106;
          end;
          hence (EL|v.edgesOut()).e = (EL2|v.edgesOut()).e
          by A1c,A161,A162,Def20;
        end;
        then
A165:   EL | v.edgesOut() = EL2 | v.edgesOut() by A159,FUNCT_1:9;
        thus Sum (EL2|v.edgesIn()) = Sum (EL|v.edgesIn())
                                 by A158a,A153,FUNCT_1:9
          .= Sum (EL2|v.edgesOut()) by A165,A1a,A21,Def7;
      end;
    end;
    hence Sum (EL2 | v.edgesIn()) = Sum (EL2 | v.edgesOut());
  end;
  hence thesis by Def7;
end;

theorem Th16: ::tFLOWAUG01
for G being finite natural-weighted WGraph, EL being FF:ELabeling of G,
    source,sink being set, P being Path of G
 st source <> sink & EL has_valid_flow_from source,sink &
    P is_Walk_from source,sink & P is_augmenting_wrt EL
  holds EL.flow(source,sink) + P.tolerance(EL) =
           (FF:PushFlow(EL,P)).flow(source,sink)
proof
  let G be finite natural-weighted WGraph, EL being FF:ELabeling of G,
      source,sink be set, P be Path of G such that
A1: source <> sink and
A1a: EL has_valid_flow_from source,sink and
A1b: P is_Walk_from source,sink and
A1c: P is_augmenting_wrt EL;
  set EL2 = FF:PushFlow(EL,P), T = P.tolerance(EL);
  set EI1 = EL|G.edgesInto({sink}), EO1 = EL|G.edgesOutOf({sink});
  P.first() = source & P.last() = sink by A1b,GLIB_001:def 23;
  then P is non trivial by A1,GLIB_001:128;
  then 3 <= len P by GLIB_001:126;
  then reconsider lenP2g = len P - 2*1 as odd Element of NAT
       by INT_1:18,XXREAL_0:2;
  set e1 = P.(lenP2g+1);
A3: lenP2g < len P - 0 by XREAL_1:17;
  then
A4: e1 Joins P.lenP2g, P.(lenP2g+2), G by GLIB_001:def 3;
  then
A5: e1 in the_Edges_of G by GLIB_000:def 15;
A7: P.(len P) = sink by A1b,GLIB_001:18;
  now per cases;
    suppose
A8:   e1 DJoins P.lenP2g, P.(lenP2g+2), G;
      then
A9:   EL2.e1 = EL.e1 + T by A1c,A3,Def20;
      (the_Target_of G).e1 = P.(lenP2g+2) by A8,GLIB_000:def 16
        .= sink by A1b,GLIB_001:18;
      then (the_Target_of G).e1 in {sink} by TARSKI:def 1;
      then
A10:  e1 in G.edgesInto({sink}) by A5,GLIB_000:def 28;
      set EI2 = EI1+*(e1.-->(EI1.e1 + T));
A11:  dom EI2 = dom EI1 \/ dom (e1.-->(EI1.e1 + T)) by FUNCT_4:def 1
        .= dom EI1 \/ {e1} by FUNCOP_1:19
        .= G.edgesInto({sink}) \/ {e1} by PARTFUN1:def 4
        .= G.edgesInto({sink}) by A10,ZFMISC_1:46;
      then reconsider EI2 as Rbag of G.edgesInto({sink}) by PARTFUN1:def 4
,RELAT_1:def 18;
A12:  dom (EL2|G.edgesInto({sink})) = G.edgesInto({sink}) by PARTFUN1:def 4
;
      now
        let e be set;
        assume
A13:    e in dom (EL2|G.edgesInto({sink}));
        then
A14:    e in G.edgesInto({sink}) by PARTFUN1:def 4;
A15:    (EL2|G.edgesInto({sink})).e = EL2.e by A12,A13,FUNCT_1:72;
        (the_Target_of G).e in {sink} by A14,GLIB_000:def 28;
        then
A16:    (the_Target_of G).e = sink by TARSKI:def 1;
        now per cases;
          suppose
A17:        e = e1;
            then e in {e1} by TARSKI:def 1;
            then e in dom (e1.-->(EI1.e1+T)) by FUNCOP_1:19;
            then EI2.e = (e1.-->(EI1.e1+T)).e1 by A17,FUNCT_4:14
              .= EI1.e1 + T by FUNCOP_1:87
              .= EL2.e1 by A9,A14,A17,FUNCT_1:72;
            hence (EL2|G.edgesInto({sink})).e = EI2.e
            by A12,A13,A17,FUNCT_1:72;
          end;
          suppose
A18:        e <> e1;
            then not e in {e1} by TARSKI:def 1;
            then not e in dom (e1.-->(EI1.e1+T)) by FUNCOP_1:19;
            then
A19:        EI2.e = EI1.e by FUNCT_4:12
              .= EL.e by A14,FUNCT_1:72;
            now
              assume e in P.edges();
              then consider v1,v2 being Vertex of G,m being odd Element of NAT
              such that
A20:          m+2 <= len P & v1 = P.m & e = P.(m+1) & v2 = P.(m+2) &
              e Joins v1,v2,G by GLIB_001:104;
              now per cases by A16,A20,GLIB_000:def 15;
                suppose
A21:              v1 = sink;
                  then
A22:              P.m = P.(len P) by A1b,A20,GLIB_001:18;
                  m+2-2 < len P - 0 by A20,XREAL_1:17;
                  then m = 1 by A22,GLIB_001:def 28;
                  hence contradiction by A1,A1b,A20,A21,GLIB_001:18;
                end;
                suppose v2 = sink;
                  then
A23:              P.(m+2) = P.(len P) by A1b,A20,GLIB_001:18;
                  now
                    assume m+2 < len P;
                    then m+2 = 1 by A23,GLIB_001:def 28;
                    then m = 1-2;
                    hence contradiction by HEYTING3:1;
                  end;
                  then m + 2 = len P by A20,XXREAL_0:1;
                  hence contradiction by A18,A20;
                end;
              end;
              hence contradiction;
            end;
            hence (EL2|G.edgesInto({sink})).e = EI2.e
            by A1c,A14,A15,A19,Def20;
          end;
        end;
        hence (EL2|G.edgesInto({sink})).e = EI2.e;
      end;
      then
A24:  Sum (EL2|G.edgesInto({sink}))
         = Sum EI1 + (T + EI1.e1) - EI1.e1 by A11,A12,FUNCT_1:9,GLIB_004:9
        .= Sum EI1 + T;
A25:  dom (EL2|G.edgesOutOf({sink})) = G.edgesOutOf({sink}) &
      dom EO1 = G.edgesOutOf({sink}) by PARTFUN1:def 4;
      now
        let e be set;
        assume
A26:    e in dom (EL2|G.edgesOutOf({sink}));
        then
A27:    e in G.edgesOutOf({sink}) by PARTFUN1:def 4;
        then (the_Source_of G).e in {sink} by GLIB_000:def 29;
        then
A28:    (the_Source_of G).e = sink by TARSKI:def 1;
        now
          assume e in P.edges();
          then consider v1,v2 being Vertex of G, m being odd Element of NAT
          such that
A29:      m+2 <= len P & v1 = P.m & e = P.(m+1) & v2 = P.(m+2) &
          e Joins v1,v2,G by GLIB_001:104;
          now per cases by A28,A29,GLIB_000:def 15;
            suppose
A30:          v1 = sink;
              then
A31:          P.m = P.(len P) by A1b,A29,GLIB_001:18;
              m+2-2 < len P - 0 by A29,XREAL_1:17;
              then m = 1 by A31,GLIB_001:def 28;
              hence contradiction by A1,A1b,A29,A30,GLIB_001:18;
            end;
            suppose v2 = sink;
              then
A32:          P.(m+2) = P.(len P) by A1b,A29,GLIB_001:18;
              now
                assume m+2 < len P;
                then m+2 = 1 by A32,GLIB_001:def 28;
                then 1 <= 1-2 by HEYTING3:1;
                hence contradiction;
              end;
              then m + 2 = len P by A29,XXREAL_0:1;
              then
A33:          P.lenP2g = sink by A8,A28,A29,GLIB_000:def 16;
              then lenP2g = 1 by A3,A7,GLIB_001:def 28;
              hence contradiction by A1,A1b,A33,GLIB_001:18;
            end;
          end;
          hence contradiction;
        end;
        then EL2.e = EL.e by A1c,A27,Def20
          .= EO1.e by A27,FUNCT_1:72;
        hence (EL2|G.edgesOutOf({sink})).e = EO1.e by A25,A26,FUNCT_1:72;
      end;
      then Sum (EL2|G.edgesOutOf({sink})) = Sum EO1 by A25,FUNCT_1:9;
      hence EL2.flow(source,sink) = Sum EI1 + T - Sum EO1
                by A1,A1a,A1b,A1c,A24,Def8,Th15
        .= Sum EI1 - Sum EO1 + T
        .= EL.flow(source,sink) + T by A1a,Def8;
    end;
    suppose
A34:  not e1 DJoins P.lenP2g, P.(lenP2g+2), G;
      then
A35:  EL2.e1 = EL.e1 - T by A1c,A3,Def20;
A36:  e1 DJoins P.(lenP2g+2),P.lenP2g,G by A4,A34,GLIB_000:19;
      then (the_Source_of G).e1 = P.(lenP2g+2) by GLIB_000:def 16
        .= sink by A1b,GLIB_001:18;
      then (the_Source_of G).e1 in {sink} by TARSKI:def 1;
      then
A37:  e1 in G.edgesOutOf({sink}) by A5,GLIB_000:def 29;
      set EO2 = EO1+*(e1.-->(EO1.e1-T));
A38:  dom EO2 = dom EO1 \/ dom (e1.-->(EO1.e1 - T)) by FUNCT_4:def 1
        .= dom EO1 \/ {e1} by FUNCOP_1:19
        .= G.edgesOutOf({sink}) \/ {e1} by PARTFUN1:def 4
        .= G.edgesOutOf({sink}) by A37,ZFMISC_1:46;
      then reconsider EO2 as Rbag of G.edgesOutOf({sink}) by PARTFUN1:def 4
,RELAT_1:def 18;
A39:  dom (EL2|G.edgesOutOf({sink})) = G.edgesOutOf({sink}) by PARTFUN1:def 4
;
      now
        let e be set;
        assume
A40:    e in dom (EL2|G.edgesOutOf({sink}));
        then
A41:    e in G.edgesOutOf({sink}) by PARTFUN1:def 4;
A42:    (EL2|G.edgesOutOf({sink})).e = EL2.e by A39,A40,FUNCT_1:72;
        (the_Source_of G).e in {sink} by A41,GLIB_000:def 29;
        then
A43:    (the_Source_of G).e = sink by TARSKI:def 1;
        now per cases;
          suppose
A44:        e = e1;
            then e in {e1} by TARSKI:def 1;
            then e in dom (e1.-->(EO1.e1-T)) by FUNCOP_1:19;
            then EO2.e = (e1.-->(EO1.e1-T)).e1 by A44,FUNCT_4:14
              .= EO1.e1 - T by FUNCOP_1:87
              .= EL2.e by A35,A41,A44,FUNCT_1:72;
            hence (EL2|G.edgesOutOf({sink})).e = EO2.e by A39,A40,FUNCT_1:72;
          end;
          suppose
A45:        e <> e1;
            then not e in {e1} by TARSKI:def 1;
            then not e in dom (e1.-->(EO1.e1-T)) by FUNCOP_1:19;
            then
A46:        EO2.e = EO1.e by FUNCT_4:12
              .= EL.e by A41,FUNCT_1:72;
            now
              assume e in P.edges();
              then consider v1,v2 being Vertex of G,
              m being odd Element of NAT such that
A47:          m+2 <= len P & v1 = P.m & e = P.(m+1) & v2 = P.(m+2) &
              e Joins v1,v2,G by GLIB_001:104;
              now per cases by A43,A47,GLIB_000:def 15;
                suppose
A48:              v1 = sink;
                  then
A49:              P.m = P.(len P) by A1b,A47,GLIB_001:18;
                  m+2-2 < len P - 0 by A47,XREAL_1:17;
                  then m = 1 by A49,GLIB_001:def 28;
                  hence contradiction by A1,A1b,A47,A48,GLIB_001:18;
                end;
                suppose v2 = sink;
                  then
A50:              P.(m+2) = P.(len P) by A1b,A47,GLIB_001:18;
                  now
                    assume m+2 < len P;
                    then m+2 = 1 by A50,GLIB_001:def 28;
                    then 1 <= 1-2 by HEYTING3:1;
                    hence contradiction;
                  end;
                  then m + 2 = len P by A47,XXREAL_0:1;
                  hence contradiction by A45,A47;
                end;
              end;
              hence contradiction;
            end;
            hence (EL2|G.edgesOutOf({sink})).e = EO2.e
                      by A1c,A41,A42,A46,Def20;
          end;
        end;
        hence (EL2|G.edgesOutOf({sink})).e = EO2.e;
      end;
      then
A51:  Sum (EL2|G.edgesOutOf({sink}))
         = Sum EO1 + (EO1.e1 - T) - EO1.e1 by A38,A39,FUNCT_1:9,GLIB_004:9
        .= Sum EO1 - T;
A52:  dom (EL2|G.edgesInto({sink})) = G.edgesInto({sink}) &
      dom EI1 = G.edgesInto({sink}) by PARTFUN1:def 4;
      now
        let e be set;
        assume
A53:    e in dom (EL2|G.edgesInto({sink}));
        then
A54:    e in G.edgesInto({sink}) by PARTFUN1:def 4;
        then (the_Target_of G).e in {sink} by GLIB_000:def 28;
        then
A55:    (the_Target_of G).e = sink by TARSKI:def 1;
        now
          assume e in P.edges();
          then consider v1,v2 being Vertex of G, m being odd Element of NAT
          such that
A56:      m+2 <= len P & v1 = P.m & e = P.(m+1) & v2 = P.(m+2) &
          e Joins v1,v2,G by GLIB_001:104;
          now per cases by A55,A56,GLIB_000:def 15;
            suppose
A57:          v1 = sink;
              then
A58:          P.m = P.(len P) by A1b,A56,GLIB_001:18;
              m+2-2 < len P - 0 by A56,XREAL_1:17;
              then m = 1 by A58,GLIB_001:def 28;
              hence contradiction by A1,A1b,A56,A57,GLIB_001:18;
            end;
            suppose v2 = sink;
              then
A59:          P.(m+2) = P.(len P) by A1b,A56,GLIB_001:18;
              now
                assume m+2 < len P;
                then m+2 = 1 by A59,GLIB_001:def 28;
                then 1 <= 1-2 by HEYTING3:1;
                hence contradiction;
              end;
              then m + 2 = len P by A56,XXREAL_0:1;
              then
A60:          P.lenP2g = sink by A36,A55,A56,GLIB_000:def 16;
              then lenP2g = 1 by A3,A7,GLIB_001:def 28;
              hence contradiction by A1,A1b,A60,GLIB_001:18;
            end;
          end;
          hence contradiction;
        end;
        then EL2.e = EL.e by A1c,A54,Def20
          .= EI1.e by A54,FUNCT_1:72;
        hence (EL2|G.edgesInto({sink})).e = EI1.e by A52,A53,FUNCT_1:72;
      end;
      then Sum (EL2|G.edgesInto({sink})) = Sum EI1 by A52,FUNCT_1:9;
     hence EL2.flow(source,sink) = Sum EI1 - (Sum EO1 - T)
             by A1,A1a,A1b,A1c,A51,Def8,Th15
        .= Sum EI1 - Sum EO1 + T
        .= EL.flow(source,sink) + T by A1a,Def8;
    end;
  end;
  hence thesis;
end;

theorem Th18: ::tFLOWCS01
for G being finite natural-weighted WGraph,
    source,sink being Vertex of G, n being Nat
 st source <> sink
  holds FF:CompSeq(G,source,sink).n has_valid_flow_from source,sink
proof
  let G be finite natural-weighted WGraph, source,sink be Vertex of G,
      n be Nat;
  assume
A1: source <> sink;
  set CS = FF:CompSeq(G,source,sink);
  defpred P[Nat] means (CS.$1) has_valid_flow_from source,sink;
  now
    set G0 = CS.0;
A2: G0 = the_Edges_of G --> 0 by Def23;
    hence (for e being set st e in the_Edges_of G holds
    0 <= G0.e & G0.e <= (the_Weight_of G).e) by FUNCOP_1:13;
    let v be Vertex of G;
    assume v <> source & v <> sink;
    set B1 = EmptyBag v.edgesIn(), B2 = EmptyBag v.edgesOut();
    set E1 = (G0|v.edgesIn()), E2 = (G0|v.edgesOut());
    now
      let e be set;
      assume
A8:   e in v.edgesIn();
      E1.e = G0.e by A8,FUNCT_1:72
        .= 0 by A2,A8,FUNCOP_1:13;
      hence B1.e = E1.e by POLYNOM1:56;
    end;
    then
A10: Sum E1 = Sum B1 by GLIB_004:6
      .= 0 by UPROOTS:13;
    now
      let e be set;
      assume
A11:  e in v.edgesOut();
      E2.e = G0.e by A11,FUNCT_1:72
        .= 0 by A2,A11,FUNCOP_1:13;
      hence B2.e = E2.e by POLYNOM1:56;
    end;
    then Sum E2 = Sum B2 by GLIB_004:6
      .= 0 by UPROOTS:13;
    hence Sum E1 = Sum E2 by A10;
  end;
  then
A13: P[0] by Def7;
  now
    let n be Nat;
    set Gn = CS.n, Gn1 = CS.(n+1);
    assume
A14: Gn has_valid_flow_from source,sink;
A15: Gn1 = FF:Step(Gn,source,sink) by Def23;
    now per cases;
      suppose
A16:    sink in dom AP:FindAugPath(Gn,source);
        set P = AP:GetAugPath(Gn,source,sink);
A17:    Gn1 = FF:PushFlow(Gn, P) by A15,A16,Def22;
        P is_Walk_from source,sink & P is_augmenting_wrt Gn by A16,Def17;
        hence P[n+1] by A1,A14,A17,Th15;
      end;
      suppose not sink in dom AP:FindAugPath(Gn,source);
        hence P[n+1] by A14,A15,Def22;
      end;
    end;
    hence P[n+1];
  end;
  then
A18: for n being Nat st P[n] holds P[n+1];
  for n being Nat holds P[n] from NAT_1:sch 2(A13,A18);
  hence thesis;
end;

theorem Th19: ::tMAXFLOW01
for G being finite natural-weighted WGraph,source,sink being Vertex of G
 st source <> sink holds FF:CompSeq(G,source,sink) is halting
proof
  let G be finite natural-weighted WGraph, source, sink be Vertex of G;
  assume
A1: source <> sink;
  set CS = FF:CompSeq(G,source,sink);
  now
    assume
A2: for n being Element of NAT holds CS.n <> CS.(n+1);
    defpred P[Element of NAT] means $1 <= (CS.$1).flow(source,sink) &
    (CS.$1).flow(source,sink) is Element of NAT;
    now
      set G0 = CS.0;
      set E1 = G0 | G.edgesInto({sink}), E2 = G0 | G.edgesOutOf({sink});
A3:   G0.flow(source,sink) = Sum E1 - Sum E2 by A1,Def8,Th18;
A4:   G0 = the_Edges_of G --> 0 by Def23;
      set B1 = EmptyBag G.edgesInto({sink}),B2 = EmptyBag G.edgesOutOf({sink});
      now
        let e be set;
        assume
A7:     e in G.edgesInto({sink});
        hence E1.e = G0.e by FUNCT_1:72 .= 0 by A4,A7,FUNCOP_1:13
                  .= B1.e by POLYNOM1:56;
      end;
      then
A8:   Sum E1 = Sum B1 by GLIB_004:6 .= 0 by UPROOTS:13;
      now
        let e be set;
        assume
A9:     e in G.edgesOutOf({sink});
        hence E2.e = G0.e by FUNCT_1:72 .= 0 by A4,A9,FUNCOP_1:13
                  .= B2.e by POLYNOM1:56;
      end;
      then
A10:  Sum E2 = Sum B2 by GLIB_004:6 .= 0 by UPROOTS:13;
      hence G0.flow(source,sink) = 0 qua Nat - 0 by A1,A8,Def8,Th18;
      thus G0.flow(source,sink) is Element of NAT by A3,A8,A10;
    end;
    then
A11: P[0];
    now
      let n be Element of NAT;
      set Gn = CS.n, Gn1 = CS.(n+1);
      assume
A12:  n <= Gn.flow(source,sink) & Gn.flow(source,sink) is Element of NAT;
A13:  Gn1 = FF:Step(Gn, source,sink) by Def23;
A14:  now
        assume not sink in dom AP:FindAugPath(Gn,source);
        then Gn1 = Gn by A13,Def22;
        hence contradiction by A2;
      end;
      then
A15:  Gn1 = FF:PushFlow(Gn,AP:GetAugPath(Gn,source,sink)) by A13,Def22;
      set P = AP:GetAugPath(Gn,source,sink);
A16a: P is_augmenting_wrt Gn by A14,Def17;
A16:  P is_Walk_from source,sink by A14,Def17;
      then P.first() = source & P.last() = sink by GLIB_001:def 23;
      then
A17:  0 < P.tolerance(Gn) by A16a,Th14,A1,GLIB_001:128;
      reconsider GnF = Gn.flow(source,sink) as Element of NAT by A12;
A18:  GnF + P.tolerance(Gn) = Gn1.flow(source,sink)
           by A1,A15,A16,A16a,Th16,Th18;
      then reconsider Gn1F = Gn1.flow(source,sink) as Element of NAT;
      GnF + P.tolerance(Gn)-P.tolerance(Gn) < Gn1F-0 by A17,A18,XREAL_1:17;
      then n < Gn1F by A12,XXREAL_0:2;
      hence n+1 <= Gn1.flow(source,sink) by NAT_1:13;
      thus Gn1.flow(source,sink) is Element of NAT by A18;
    end;
    then
A19: for n being Element of NAT st P[n] holds P[n+1];
A20: for n being Element of NAT holds P[n] from NAT_1:sch 1(A11,A19);
    set V = {source};
A21: source in V & not sink in V by A1,TARSKI:def 1;
    set W1 = (the_Weight_of G)|G.edgesDBetween(V,the_Vertices_of G \ V);
    degree W1 = Sum W1;
    then reconsider N = Sum W1 as Element of NAT;
    set Gn1 = CS.(N+1);
    reconsider Gn1F = Gn1.flow(source,sink) as Element of NAT by A20;
    Sum W1 + 1 <= Gn1F by A20;
    then Sum W1 < Gn1.flow(source,sink) by NAT_1:13;
    hence contradiction by A21,Th12,Th18;
  end;
  hence thesis by GLIB_000:def 56;
end;

theorem Th20: ::tMAXFLOW02
for G being finite natural-weighted WGraph, EL being FF:ELabeling of G,
    source,sink being set
 st EL has_valid_flow_from source,sink &
    not ex P being Path of G
         st P is_Walk_from source,sink & P is_augmenting_wrt EL
  holds EL has_maximum_flow_from source,sink
proof
  let G be finite natural-weighted WGraph, EL be FF:ELabeling of G,
      source,sink be set;
  assume that
A1a: EL has_valid_flow_from source,sink and
A1b: not ex P being Path of G
          st P is_Walk_from source,sink & P is_augmenting_wrt EL;
    reconsider src = source as Vertex of G by A1a,Def7;
  set CS = AP:CompSeq(EL,src), Gn = AP:FindAugPath(EL,src);
  set Gn1 = CS.(CS.Lifespan()+1);
  reconsider V = dom Gn as Subset of the_Vertices_of G;
  set E1 = G.edgesDBetween(V, the_Vertices_of G \ V);
  set E2 = G.edgesDBetween(the_Vertices_of G \ V, V);
A5: not sink in dom Gn by A1b,Th9;
    then
A6: EL.flow(source,sink) = Sum(EL|E1)-Sum(EL|E2) by A1a,Th10,Th11;
  set A1 = EL|E1, B1 = (the_Weight_of G)|E1;
A7: AP:CompSeq(EL,src) is halting by Th6;
A8: Gn1 = AP:Step(Gn) by Def15;
A9: Gn1 = Gn by A7,GLIB_000:def 57;
  set e = choose AP:NextBestEdges(Gn);
A10: now
    assume
A11: AP:NextBestEdges(Gn) <> {};
    now per cases by A11,Def13;
      suppose e is_forward_edge_wrt Gn;
        then
A13:    (the_Source_of G).e in V & not (the_Target_of G).e in V by Def10;
        then Gn = Gn+*((the_Target_of G).e .--> e) by A8,A9,A11,Def14;
        hence contradiction by Tw0a,A13;
      end;
      suppose e is_backward_edge_wrt Gn;
        then
A15:    (the_Target_of G).e in V & not (the_Source_of G).e in V by Def11;
        then Gn = Gn+*((the_Source_of G).e .--> e) by A8,A9,A11,Def14;
        hence contradiction by A15,Tw0a;
      end;
    end;
    hence contradiction;
  end;
A17: now
    let x be set;
    assume
A18: x in E1;
    then
A19: A1.x = EL.x & B1.x = (the_Weight_of G).x by FUNCT_1:72;
    x DSJoins V, the_Vertices_of G \ V, G by A18,GLIB_000:def 33;
    then
A20: x in the_Edges_of G & (the_Source_of G).x in V &
    (the_Target_of G).x in the_Vertices_of G \ V by GLIB_000:def 18;
    then
A21: not (the_Target_of G).x in V by XBOOLE_0:def 5;
A22: A1.x <= B1.x by A1a,A19,A20,Def7;
    set e = choose AP:NextBestEdges(Gn);
    now
      assume A1.x < B1.x;
      then x is_forward_edge_wrt Gn by A19,A20,A21,Def10;
      hence contradiction by A10,Def13;
    end;
    hence A1.x = B1.x by A22,XXREAL_0:1;
  end;
  set A2 = EL|E2, B2 = EmptyBag E2;
  now
    let x be set;
    assume
A23: x in E2;
    then
A24: A2.x = EL.x by FUNCT_1:72;
    B2 = E2 --> 0 by POLYNOM1:def 15;
    then
A25: B2.x = 0 by A23,FUNCOP_1:13;
    x DSJoins the_Vertices_of G \ V, V, G by A23,GLIB_000:def 33;
    then
A26: x in the_Edges_of G & (the_Source_of G).x in the_Vertices_of G \ V &
    (the_Target_of G).x in V by GLIB_000:def 18;
    then
A27: not (the_Source_of G).x in V by XBOOLE_0:def 5;
    set e = choose AP:NextBestEdges(Gn);
    now
      assume 0 < A2.x;
      then x is_backward_edge_wrt Gn by A24,A26,A27,Def11;
      hence contradiction by A10,Def13;
    end;
    hence A2.x = B2.x by A25;
  end;
  then Sum (EL | E2) = Sum B2 by GLIB_004:6;
  then Sum (EL | E2) = 0 by UPROOTS:13;
  then
A28: EL.flow(source,sink) = Sum ((the_Weight_of G)|E1) by A6,A17,GLIB_004:6;
    for X be FF:ELabeling of G st X has_valid_flow_from source,sink
     holds X.flow(source,sink) <= EL.flow(source,sink) by Th10,A5,A28,Th12;
  hence thesis by A1a,Def9;
end;

theorem ::tMAXFLOW04
for G being finite natural-weighted WGraph, source, sink being Vertex of G
 st sink <> source
  holds FF:MaxFlow(G,source,sink) has_maximum_flow_from source,sink
proof
  let G be finite natural-weighted WGraph, source, sink be Vertex of G;
  set CS = FF:CompSeq(G,source,sink);
  assume
A1: sink <> source;
  set n = CS.Lifespan(), Gn = CS.n, Gn1 = CS.(n+1);
A2: Gn1 = FF:Step(Gn,source,sink) by Def23;
    CS is halting by A1,Th19;
    then
A3: Gn = CS.(n+1) by GLIB_000:def 57;
  now
    given P being Path of G such that
A5: P is_Walk_from source,sink and
A5a: P is_augmenting_wrt Gn;
A6: sink in dom AP:FindAugPath(Gn,source) by A5,A5a,Th9;
    then
A7: Gn1 = FF:PushFlow(Gn, AP:GetAugPath(Gn,source,sink)) by A2,Def22;
    set P = AP:GetAugPath(Gn,source,sink);
A8: P is_Walk_from source,sink by A6,Def17;
    then
A9a: P.first() = source & P.last() = sink by GLIB_001:def 23;
A8a: P is_augmenting_wrt Gn by A6,Def17;
    Gn.flow(source,sink) + P.tolerance(Gn) = Gn1.flow(source,sink)
       by A1,A7,A8,A8a,Th16,Th18;
    hence contradiction by A3,A8a,A9a,Th14,A1,GLIB_001:128;
  end;
  hence thesis by A1,Th18,Th20;
end;

